{
    "hands_on_practices": [
        {
            "introduction": "Before building an adaptive mesh, we must understand the fundamental constraints that govern numerical wave simulations. This exercise  delves into the Courant–Friedrichs–Lewy (CFL) condition, which establishes a critical link between the time step $\\Delta t$, spatial resolution $\\Delta x$, and wave speed $c$. By deriving the stability limit from first principles and connecting it to the physical requirement of resolving a minimum wavelength, you will establish the theoretical foundation for why the finest cells in an AMR hierarchy dictate the global time step in explicit schemes.",
            "id": "4116322",
            "problem": "Consider one-dimensional acoustic wave propagation in a homogeneous medium with sound speed $c$, modeled by the scalar second-order wave equation $\\frac{\\partial^{2} u}{\\partial t^{2}} = c^{2} \\frac{\\partial^{2} u}{\\partial x^{2}}$, where $u(x,t)$ denotes the acoustic pressure fluctuation. An explicit leapfrog time integrator with centered second-order finite differences in space is used, so that the fully discrete scheme on a uniform grid with spacing $\\Delta x$ and time step $\\Delta t$ is\n$$\nu_{j}^{n+1} - 2 u_{j}^{n} + u_{j}^{n-1} = \\left(\\frac{c \\Delta t}{\\Delta x}\\right)^{2} \\left(u_{j+1}^{n} - 2 u_{j}^{n} + u_{j-1}^{n}\\right),\n$$\nfor integer indices $j$ and $n$. Using a von Neumann plane-wave analysis starting from first principles, derive the Courant–Friedrichs–Lewy (CFL) stability limit for this scheme as a constraint on the Courant number $\\nu$, where $\\nu$ is defined by $\\nu = \\frac{c \\Delta t}{\\Delta x}$. Then, consider an adaptive mesh refinement strategy in which the finest level is chosen to resolve the highest relevant acoustic frequency $f_{\\max}$ with $N_{\\mathrm{ppw}}$ points per wavelength. Using only well-founded physical relations for wavelength and frequency, express the finest-grid spacing $\\Delta x_{\\mathrm{fine}}$ in terms of $c$, $f_{\\max}$, and $N_{\\mathrm{ppw}}$, and determine the maximum allowable global time step $\\Delta t_{\\max}$ that satisfies the CFL limit when the global time step is limited by the finest mesh.\n\nCompute the numerical value of $\\Delta t_{\\max}$ for $c = 1500\\,\\mathrm{m/s}$, $f_{\\max} = 20000\\,\\mathrm{Hz}$, and $N_{\\mathrm{ppw}} = 12$. Round your answer to four significant figures and express it in seconds.",
            "solution": "The problem is first validated to ensure it is scientifically grounded, well-posed, and objective.\n\n### Step 1: Extract Givens\n-   The governing partial differential equation: $\\frac{\\partial^{2} u}{\\partial t^{2}} = c^{2} \\frac{\\partial^{2} u}{\\partial x^{2}}$\n-   The discrete finite difference scheme: $u_{j}^{n+1} - 2 u_{j}^{n} + u_{j}^{n-1} = \\left(\\frac{c \\Delta t}{\\Delta x}\\right)^{2} \\left(u_{j+1}^{n} - 2 u_{j}^{n} + u_{j-1}^{n}\\right)$\n-   Definition of the Courant number: $\\nu = \\frac{c \\Delta t}{\\Delta x}$\n-   Acoustic medium and parameters: sound speed $c$, highest relevant frequency $f_{\\max}$, points per wavelength $N_{\\mathrm{ppw}}$\n-   Quantities to be determined: The CFL stability limit for $\\nu$, the finest-grid spacing $\\Delta x_{\\mathrm{fine}}$, and the maximum allowable global time step $\\Delta t_{\\max}$.\n-   Numerical values for calculation: $c = 1500\\,\\mathrm{m/s}$, $f_{\\max} = 20000\\,\\mathrm{Hz}$, $N_{\\mathrm{ppw}} = 12$.\n\n### Step 2: Validate Using Extracted Givens\n-   **Scientifically Grounded**: The problem is based on the canonical one-dimensional acoustic wave equation and a standard, widely-used explicit finite difference time domain (FDTD) method (leapfrog scheme). The method of von Neumann stability analysis is a fundamental tool in the analysis of numerical methods for partial differential equations. The relationship between wavelength, frequency, and wave speed is a cornerstone of wave physics. The problem is entirely grounded in established principles of physics and numerical analysis.\n-   **Well-Posed**: The problem is clearly stated and contains all necessary information to derive the requested analytical expressions and compute the final numerical value. The tasks are sequential and logically connected, leading to a unique and meaningful solution.\n-   **Objective**: The problem is stated in precise, technical language, free of ambiguity or subjective claims.\n\n### Step 3: Verdict and Action\nThe problem is valid. We will now proceed with the solution, which consists of three parts: a) deriving the CFL condition, b) expressing the grid parameters in terms of physical quantities, and c) computing the maximum time step.\n\n**Part 1: Derivation of the CFL Stability Limit**\n\nWe perform a von Neumann stability analysis. We assume a single Fourier mode solution (a plane wave) for a given wavenumber $k$ on the discrete grid $x_j = j \\Delta x$. The solution ansatz is:\n$$\nu_j^n = G^n e^{i k x_j} = G^n e^{i k j \\Delta x}\n$$\nwhere $n$ is the time index, $j$ is the space index, $i = \\sqrt{-1}$, and $G$ is the amplification factor per time step. For the scheme to be stable, the magnitude of the amplification factor must satisfy $|G| \\le 1$.\n\nSubstituting the ansatz into the left-hand side of the discrete scheme gives:\n$$\nu_j^{n+1} - 2u_j^n + u_j^{n-1} = G^{n+1} e^{i k j \\Delta x} - 2G^n e^{i k j \\Delta x} + G^{n-1} e^{i k j \\Delta x} = G^n e^{i k j \\Delta x} \\left( G - 2 + \\frac{1}{G} \\right)\n$$\nSubstituting into the right-hand side gives:\n$$\n\\nu^2 \\left( u_{j+1}^n - 2u_j^n + u_{j-1}^n \\right) = \\nu^2 \\left( G^n e^{i k (j+1) \\Delta x} - 2G^n e^{i k j \\Delta x} + G^n e^{i k (j-1) \\Delta x} \\right)\n$$\nFactoring out $G^n e^{i k j \\Delta x}$ on the right-hand side:\n$$\n\\nu^2 G^n e^{i k j \\Delta x} \\left( e^{i k \\Delta x} - 2 + e^{-i k \\Delta x} \\right)\n$$\nUsing Euler's formula, $e^{i\\theta} + e^{-i\\theta} = 2 \\cos(\\theta)$, this simplifies to:\n$$\n\\nu^2 G^n e^{i k j \\Delta x} \\left( 2 \\cos(k \\Delta x) - 2 \\right) = -2 \\nu^2 G^n e^{i k j \\Delta x} \\left( 1 - \\cos(k \\Delta x) \\right)\n$$\nNow, using the trigonometric identity $1 - \\cos(\\theta) = 2 \\sin^2(\\theta/2)$:\n$$\n-4 \\nu^2 G^n e^{i k j \\Delta x} \\sin^2\\left(\\frac{k \\Delta x}{2}\\right)\n$$\nEquating the transformed left and right sides and dividing by the common factor $G^n e^{i k j \\Delta x}$ (which is non-zero), we obtain an equation for $G$:\n$$\nG - 2 + \\frac{1}{G} = -4 \\nu^2 \\sin^2\\left(\\frac{k \\Delta x}{2}\\right)\n$$\nMultiplying by $G$ and rearranging yields a quadratic equation for the amplification factor $G$:\n$$\nG^2 - 2 \\left(1 - 2 \\nu^2 \\sin^2\\left(\\frac{k \\Delta x}{2}\\right)\\right) G + 1 = 0\n$$\nThis is an equation of the form $G^2 - 2\\alpha G + 1 = 0$, where $\\alpha = 1 - 2 \\nu^2 \\sin^2\\left(\\frac{k \\Delta x}{2}\\right)$. The roots are $G = \\alpha \\pm \\sqrt{\\alpha^2 - 1}$. For stability, we require $|G| \\le 1$. If $|\\alpha| > 1$, then $\\alpha^2 - 1 > 0$, and the roots are real. One root will have a magnitude greater than $1$, leading to exponential growth and instability. If $|\\alpha| \\le 1$, then $\\alpha^2 - 1 \\le 0$, and the roots are complex conjugates $G = \\alpha \\pm i\\sqrt{1-\\alpha^2}$. The magnitude of these roots is $|G|^2 = \\alpha^2 + (1-\\alpha^2) = 1$, so $|G|=1$. This corresponds to a stable, non-dissipative scheme.\n\nThus, the stability condition is $|\\alpha| \\le 1$, which translates to:\n$$\n-1 \\le 1 - 2 \\nu^2 \\sin^2\\left(\\frac{k \\Delta x}{2}\\right) \\le 1\n$$\nThe right-hand inequality, $1 - 2 \\nu^2 \\sin^2\\left(\\frac{k \\Delta x}{2}\\right) \\le 1$, simplifies to $-2 \\nu^2 \\sin^2\\left(\\frac{k \\Delta x}{2}\\right) \\le 0$, which is always satisfied since $\\nu^2 \\ge 0$ and the sine-squared term is non-negative.\n\nThe left-hand inequality provides the stability constraint:\n$$\n-1 \\le 1 - 2 \\nu^2 \\sin^2\\left(\\frac{k \\Delta x}{2}\\right) \\implies 2 \\nu^2 \\sin^2\\left(\\frac{k \\Delta x}{2}\\right) \\le 2 \\implies \\nu^2 \\sin^2\\left(\\frac{k \\Delta x}{2}\\right) \\le 1\n$$\nThis condition must hold for all wavenumbers $k$ that can be represented on the grid. The term $\\sin^2\\left(\\frac{k \\Delta x}{2}\\right)$ is maximized when its argument is an odd multiple of $\\pi/2$. The highest frequency that can be resolved on a grid with spacing $\\Delta x$ is the Nyquist frequency, which corresponds to a wavelength of $2\\Delta x$ and a wavenumber of $k = \\pi/\\Delta x$. For this \"worst-case\" wavenumber, the term becomes $\\sin^2\\left(\\frac{(\\pi/\\Delta x) \\Delta x}{2}\\right) = \\sin^2(\\pi/2) = 1$.\n\nTherefore, the stability condition for all modes is:\n$$\n\\nu^2 \\le 1 \\implies |\\nu| \\le 1\n$$\nSince $\\nu = \\frac{c \\Delta t}{\\Delta x}$ is defined with positive quantities, the CFL stability limit is $\\nu \\le 1$.\n\n**Part 2: Grid Spacing for Adaptive Mesh Refinement**\n\nThe relationship between wavelength $\\lambda$, frequency $f$, and wave speed $c$ is $\\lambda = c/f$. To properly resolve wave phenomena, the spatial grid must be fine enough to sample the shortest wavelength of interest. The shortest wavelength, $\\lambda_{\\min}$, corresponds to the highest frequency, $f_{\\max}$:\n$$\n\\lambda_{\\min} = \\frac{c}{f_{\\max}}\n$$\nThe problem specifies that this shortest wavelength must be resolved by $N_{\\mathrm{ppw}}$ points per wavelength. This means that one wavelength $\\lambda_{\\min}$ must span $N_{\\mathrm{ppw}}$ grid cells of size $\\Delta x_{\\mathrm{fine}}$. Thus,\n$$\nN_{\\mathrm{ppw}} \\Delta x_{\\mathrm{fine}} = \\lambda_{\\min}\n$$\nSolving for the finest-grid spacing $\\Delta x_{\\mathrm{fine}}$ and substituting the expression for $\\lambda_{\\min}$:\n$$\n\\Delta x_{\\mathrm{fine}} = \\frac{\\lambda_{\\min}}{N_{\\mathrm{ppw}}} = \\frac{c}{f_{\\max} N_{\\mathrm{ppw}}}\n$$\n\n**Part 3: Maximum Allowable Global Time Step**\n\nIn an explicit time-stepping scheme with adaptive mesh refinement, the global time step $\\Delta t$ must be small enough to ensure stability on the finest mesh in the domain. The CFL condition must hold on the grid with spacing $\\Delta x_{\\mathrm{fine}}$:\n$$\n\\frac{c \\Delta t}{\\Delta x_{\\mathrm{fine}}} \\le 1\n$$\nThe maximum allowable time step, $\\Delta t_{\\max}$, is found when this condition is at its limit:\n$$\n\\frac{c \\Delta t_{\\max}}{\\Delta x_{\\mathrm{fine}}} = 1 \\implies \\Delta t_{\\max} = \\frac{\\Delta x_{\\mathrm{fine}}}{c}\n$$\nSubstituting the expression for $\\Delta x_{\\mathrm{fine}}$ derived in Part 2:\n$$\n\\Delta t_{\\max} = \\frac{1}{c} \\left( \\frac{c}{f_{\\max} N_{\\mathrm{ppw}}} \\right) = \\frac{1}{f_{\\max} N_{\\mathrm{ppw}}}\n$$\n\n**Part 4: Numerical Calculation**\n\nWe are given $c = 1500\\,\\mathrm{m/s}$, $f_{\\max} = 20000\\,\\mathrm{Hz}$, and $N_{\\mathrm{ppw}} = 12$. The value of $c$ is not needed for the final expression of $\\Delta t_{\\max}$ but was necessary for the intermediate derivation of $\\Delta x_{\\mathrm{fine}}$.\n$$\n\\Delta t_{\\max} = \\frac{1}{f_{\\max} N_{\\mathrm{ppw}}} = \\frac{1}{(20000) \\times 12} = \\frac{1}{240000}\\,\\mathrm{s}\n$$\nConverting this to a decimal value:\n$$\n\\Delta t_{\\max} = 0.0000041666... \\,\\mathrm{s} = 4.1666... \\times 10^{-6}\\,\\mathrm{s}\n$$\nRounding to four significant figures, we get $4.167 \\times 10^{-6}\\,\\mathrm{s}$.",
            "answer": "$$\n\\boxed{4.167 \\times 10^{-6}}\n$$"
        },
        {
            "introduction": "Knowing *that* fine grids are necessary is only half the battle; the core of AMR is deciding *where* to place them efficiently. This practical coding exercise  transitions from theory to implementation, tasking you with building a static AMR configuration for a wave packet interacting with a material interface. You will develop an algorithm that assigns refinement levels based on two essential criteria: resolving the local wavelength and limiting interpolation error in regions of high solution curvature, giving you hands-on experience with the decision-making logic at the heart of AMR.",
            "id": "4116078",
            "problem": "You are given a one-dimensional acoustic medium with spatially varying sound speed and asked to compute an adaptive mesh refinement configuration for a time-harmonic snapshot of the acoustic pressure. The goal is to capture critical small-scale effects due to short wavelengths and sharp amplitude variations while avoiding overrefinement elsewhere. The program must compute, for each test case, a refinement distribution based on first principles and produce an aggregate summary in the specified output format.\n\nThe physical model is the linear acoustic wave equation in one spatial dimension with variable sound speed,\n$$\n\\frac{\\partial^2 p}{\\partial t^2}(x,t) = c(x)^2 \\frac{\\partial^2 p}{\\partial x^2}(x,t),\n$$\nwhere $p(x,t)$ is the acoustic pressure and $c(x)$ is the sound speed. Consider a time-harmonic excitation of frequency $f$ (in $\\mathrm{Hz}$) and define the angular frequency $\\omega = 2\\pi f$. For a slowly varying medium, the local spatial wavenumber is $k(x) \\approx \\omega / c(x)$, and the local wavelength is $\\lambda(x) = c(x) / f$.\n\nWe consider a snapshot at $t=0$ with spatial profile\n$$\np(x) = g(x) \\cos(\\phi(x)),\n$$\nwhere\n$$\ng(x) = \\exp\\!\\left( -\\frac{(x-x_0)^2}{2\\sigma^2} \\right),\n\\quad\n\\phi(x) = \\omega s(x),\n\\quad\ns(x) = \\int_0^x \\frac{1}{c(\\xi)} \\,\\mathrm{d}\\xi,\n$$\nwith $x \\in [0,L]$, $L$ in $\\mathrm{m}$, center $x_0$ in $\\mathrm{m}$, and envelope width parameter $\\sigma$ in $\\mathrm{m}$. The medium is piecewise constant:\n$$\nc(x) =\n\\begin{cases}\nc_1, & 0 \\le x \\le x_s,\\\\\nc_2, & x_s < x \\le L,\n\\end{cases}\n$$\nwith $c_1$ and $c_2$ in $\\mathrm{m/s}$ and interface location $x_s$ in $\\mathrm{m}$. Consequently,\n$$\ns(x) =\n\\begin{cases}\n\\frac{x}{c_1}, & 0 \\le x \\le x_s,\\\\\n\\frac{x_s}{c_1} + \\frac{x-x_s}{c_2}, & x_s < x \\le L.\n\\end{cases}\n$$\n\nYou must construct a static adaptive mesh refinement configuration starting from a uniform base mesh of $N_0$ cells on $[0,L]$ (base cell size $h_0 = L / N_0$). Each base cell $i$ with center $x_i$ can be refined by bisecting into $2^{L_i}$ leaf cells, where $L_i \\in \\{0,1,2,\\dots\\}$ is the local refinement level. The refinement level $L_i$ is determined by the smallest level such that the refined cell size $h_i = h_0 / 2^{L_i}$ satisfies both of the following constraints:\n\n1. Wavelength resolution constraint ensuring at least $M_{\\min}$ points per local wavelength:\n$$\nh_i \\le \\frac{\\lambda(x_i)}{M_{\\min}} = \\frac{c(x_i)}{f\\, M_{\\min}}.\n$$\n\n2. Interpolation error constraint based on the Taylor remainder for a twice continuously differentiable function over a cell of size $h$, which is bounded by a constant times $h^2$ times the supremum of the second derivative. Using the classical bound for linear interpolation error,\n$$\nE_{\\text{lin}} \\le \\frac{h^2}{8} \\sup_{\\text{cell}} \\left| \\frac{\\mathrm{d}^2 p}{\\mathrm{d}x^2} \\right|,\n$$\nenforce\n$$\n\\frac{h_i^2}{8} \\left| p''(x_i) \\right| \\le \\tau,\n$$\nwhere $\\tau$ is a user-specified amplitude error tolerance (dimensionless), yielding the curvature-driven constraint\n$$\nh_i \\le \\sqrt{\\frac{8 \\tau}{\\left| p''(x_i) \\right| + \\varepsilon}},\n$$\nwith a small regularization $\\varepsilon > 0$ to avoid division by zero.\n\nTo avoid overrefinement in regions where the acoustic field is negligible, apply an amplitude guard: if the local amplitude satisfies $\\left| p(x_i) \\right| < A_{\\min}$ (dimensionless), then set $L_i = 0$ regardless of the above constraints. This guard prevents refinement in regions where the field is too small to be of interest.\n\nFor the purposes of this problem, treat $p''(x)$ away from the interface $x_s$ using the product rule with $\\phi''(x)=0$ almost everywhere (since $c(x)$ is piecewise constant). Using $g'(x) = -\\frac{x-x_0}{\\sigma^2} g(x)$ and $g''(x) = \\left( \\frac{(x-x_0)^2}{\\sigma^4} - \\frac{1}{\\sigma^2} \\right) g(x)$, and writing $a(x) = \\cos(\\phi(x))$ and $b(x) = \\sin(\\phi(x))$, one obtains\n$$\np''(x) = g''(x)\\, a(x) \\;-\\; 2 g'(x)\\, \\phi'(x)\\, b(x) \\;-\\; g(x)\\, \\left( \\phi'(x) \\right)^2 a(x),\n$$\nwith $\\phi'(x) = \\omega / c(x)$ and $\\phi''(x)=0$ for $x \\ne x_s$.\n\nDefine the following aggregate outputs per test case:\n- The total number of leaf cells,\n$$\nN_{\\text{leaf}} = \\sum_{i=0}^{N_0-1} 2^{L_i},\n$$\n- The maximum refinement level used,\n$$\nL_{\\max} = \\max_i L_i,\n$$\n- The hypothetical overrefinement ratio without the amplitude guard, computed as the fraction of leaf cells that would be refined in regions with $\\left| p(x_i) \\right| < A_{\\min}$ if the amplitude guard were not applied,\n$$\nR_{\\text{waste}} = \\frac{\\sum_{i: \\left| p(x_i) \\right| < A_{\\min}} 2^{\\widetilde{L}_i}}{\\sum_{i=0}^{N_0-1} 2^{\\widetilde{L}_i}},\n$$\nwhere $\\widetilde{L}_i$ is the refinement level obtained by the same constraints but ignoring the amplitude guard.\n\nAll physical quantities must be in the following units:\n- Domain length $L$ in $\\mathrm{m}$.\n- Sound speeds $c_1$ and $c_2$ in $\\mathrm{m/s}$.\n- Frequency $f$ in $\\mathrm{Hz}$.\n- Amplitude tolerance $\\tau$ is dimensionless.\n- Amplitude guard threshold $A_{\\min}$ is dimensionless.\n- Envelope width parameter $\\sigma$ and positions $x$, $x_0$, $x_s$ in $\\mathrm{m}$.\n\nUse angles in radians. No percentage signs should be used; ratios must be expressed as decimals.\n\nUse the following fixed domain and base mesh for all test cases:\n- Domain $[0,L]$ with $L = 1$.\n- Base number of cells $N_0 = 64$, so $h_0 = L / N_0$.\n- Sound speed values $c_1 = 1500$, $c_2 = 1800$, interface at $x_s = 0.6$.\n\nYour program must compute the adaptive refinement configuration for the four test cases specified below. For each case, use the given parameters and the rules above to compute $N_{\\text{leaf}}$, $L_{\\max}$, and $R_{\\text{waste}}$.\n\nTest suite (each tuple is $(f, \\sigma, M_{\\min}, A_{\\min}, \\tau, x_0)$):\n1. $(8000, 0.03, 12, 0.05, 0.005, 0.30)$\n2. $(20000, 0.02, 16, 0.01, 0.003, 0.40)$\n3. $(1500, 0.08, 10, 0.05, 0.008, 0.25)$\n4. $(12000, 0.025, 14, 0.02, 0.004, 0.58)$\n\nThe final output format must be a single line containing a list of the four results, one per test case, where each result is itself a list in the order $[N_{\\text{leaf}}, L_{\\max}, R_{\\text{waste}}]$. For example, the output must look like\n$$\n[ [N_1, L_{\\max,1}, R_1], [N_2, L_{\\max,2}, R_2], [N_3, L_{\\max,3}, R_3], [N_4, L_{\\max,4}, R_4] ].\n$$",
            "solution": "The problem requires the design of a static adaptive mesh refinement (AMR) configuration for a one-dimensional acoustic wave propagation scenario. The goal is to determine the local refinement level for a set of base cells on a domain, based on criteria that ensure resolution of both the local wavelength and regions of high solution curvature, while avoiding unnecessary refinement where the wave amplitude is negligible.\n\nThe physical model is the linear acoustic wave equation in a medium with a spatially varying sound speed $c(x)$:\n$$\n\\frac{\\partial^2 p}{\\partial t^2}(x,t) = c(x)^2 \\frac{\\partial^2 p}{\\partial x^2}(x,t)\n$$\nWe analyze a time-harmonic snapshot of the pressure field $p(x)$ at $t=0$, given by:\n$$\np(x) = g(x) \\cos(\\phi(x))\n$$\nwhere $g(x)$ is a Gaussian envelope and $\\phi(x)$ is the spatial phase. The components are defined as:\n- Envelope: $g(x) = \\exp\\!\\left( -\\frac{(x-x_0)^2}{2\\sigma^2} \\right)$\n- Phase: $\\phi(x) = \\omega s(x) = 2\\pi f s(x)$, where $s(x)$ is the acoustic travel time from the origin.\n\nThe domain is $x \\in [0, L]$ with $L=1 \\, \\mathrm{m}$. The sound speed $c(x)$ is piecewise constant:\n$$\nc(x) =\n\\begin{cases}\nc_1 = 1500 \\, \\mathrm{m/s}, & 0 \\le x \\le x_s = 0.6 \\, \\mathrm{m} \\\\\nc_2 = 1800 \\, \\mathrm{m/s}, & 0.6 \\, \\mathrm{m} < x \\le 1 \\, \\mathrm{m}\n\\end{cases}\n$$\nThis leads to the travel time function:\n$$\ns(x) = \\int_0^x \\frac{1}{c(\\xi)} \\,\\mathrm{d}\\xi =\n\\begin{cases}\n\\frac{x}{c_1}, & 0 \\le x \\le x_s \\\\\n\\frac{x_s}{c_1} + \\frac{x-x_s}{c_2}, & x_s < x \\le L\n\\end{cases}\n$$\nThe computational domain $[0, L]$ is initially discretized into a uniform base mesh of $N_0 = 64$ cells. The base cell size is $h_0 = L / N_0 = 1/64 \\, \\mathrm{m}$. The refinement criteria are evaluated at the center of each base cell $i$, located at $x_i = (i + 0.5)h_0$ for $i = 0, 1, \\dots, N_0-1$.\n\nFor each base cell $i$, we determine a refinement level $L_i \\in \\{0, 1, 2, \\dots\\}$, which corresponds to subdividing the cell into $2^{L_i}$ smaller leaf cells of size $h_i = h_0 / 2^{L_i}$. The level $L_i$ is the smallest non-negative integer that satisfies a set of conditions. The process begins by determining the required level without the amplitude guard, denoted $\\widetilde{L}_i$, and then applying the guard to find the final level $L_i$.\n\nFirst, we compute the required cell size $h_{i, \\text{req}}$ for cell $i$ based on two physical and numerical constraints:\n\n1.  **Wavelength Resolution Constraint**: To accurately represent the oscillatory nature of the wave, the local cell size $h_i$ must be a fraction of the local wavelength $\\lambda(x_i) = c(x_i)/f$. The constraint ensures at least $M_{\\min}$ grid points per wavelength:\n    $$\n    h_i \\le h_{i, \\text{wave}} = \\frac{\\lambda(x_i)}{M_{\\min}} = \\frac{c(x_i)}{f M_{\\min}}\n    $$\n\n2.  **Interpolation Error Constraint**: To limit the error from approximating the solution within a cell (e.g., with linear basis functions), the cell size must be controlled in regions of high curvature. The constraint is based on the Taylor series remainder, which relates the error to the second derivative of the solution, $p''(x_i)$.\n    $$\n    h_i \\le h_{i, \\text{curv}} = \\sqrt{\\frac{8 \\tau}{|p''(x_i)| + \\varepsilon}}\n    $$\n    Here, $\\tau$ is a specified tolerance, and $\\varepsilon$ is a small positive constant (e.g., $\\varepsilon=10^{-12}$) to prevent division by zero where the curvature is null. The second derivative $p''(x)$ for $x \\neq x_s$ is calculated using the product rule:\n    $$\n    p''(x) = g''(x) \\cos(\\phi(x)) - 2g'(x)\\phi'(x) \\sin(\\phi(x)) - g(x) (\\phi'(x))^2 \\cos(\\phi(x))\n    $$\n    with $\\phi'(x) = \\omega/c(x)$, $g'(x) = -\\frac{x-x_0}{\\sigma^2}g(x)$, and $g''(x) = \\left(\\frac{(x-x_0)^2}{\\sigma^4} - \\frac{1}{\\sigma^2}\\right)g(x)$.\n\nThe most restrictive of these two constraints determines the required cell size for cell $i$:\n$$\nh_{i, \\text{req}} = \\min(h_{i, \\text{wave}}, h_{i, \\text{curv}})\n$$\nFrom this, the refinement level $\\widetilde{L}_i$ (without the amplitude guard) is the smallest integer such that $h_0 / 2^{\\widetilde{L}_i} \\le h_{i, \\text{req}}$. This is computed as:\n$$\n\\widetilde{L}_i = \\max\\left(0, \\left\\lceil \\log_2\\left(\\frac{h_0}{h_{i, \\text{req}}}\\right)\\right\\rceil\\right)\n$$\nwhere the ceiling function $\\lceil \\cdot \\rceil$ ensures the inequality is met, and the max function ensures the level is non-negative.\n\nNext, the **Amplitude Guard** is applied. This rule prevents refinement in regions where the solution amplitude is negligible, thereby saving computational resources.\n$$\n\\text{If } |p(x_i)| < A_{\\min}, \\text{ then } L_i = 0. \\text{ Otherwise, } L_i = \\widetilde{L}_i.\n$$\nThis two-step process yields the final refinement level $L_i$ for each base cell.\n\nFinally, for each test case, we compute three aggregate metrics from the set of all levels $\\{L_i\\}$ and $\\{\\widetilde{L}_i\\}$:\n-   **Total Leaf Cells ($N_{\\text{leaf}}$)**: The total number of cells in the final adaptive mesh.\n    $$\n    N_{\\text{leaf}} = \\sum_{i=0}^{N_0-1} 2^{L_i}\n    $$\n-   **Maximum Refinement Level ($L_{\\max}$)**: The deepest level of refinement used anywhere in the domain.\n    $$\n    L_{\\max} = \\max_{i} L_i\n    $$\n-   **Overrefinement Ratio ($R_{\\text{waste}}$)**: The fraction of total cells (in the unguarded mesh) that are located in regions where the amplitude is below the threshold $A_{\\min}$. This quantifies the efficiency gain from the amplitude guard.\n    $$\n    R_{\\text{waste}} = \\frac{\\sum_{i: |p(x_i)| < A_{\\min}} 2^{\\widetilde{L}_i}}{\\sum_{j=0}^{N_0-1} 2^{\\widetilde{L}_j}}\n    $$\n\nThe computational procedure involves iterating through each of the four test cases, setting the corresponding parameters, evaluating the above quantities for all $N_0=64$ base cells, and then computing the final aggregate metrics.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes adaptive mesh refinement configurations for a 1D acoustic wave problem.\n    \"\"\"\n    \n    # Fixed domain and base mesh parameters\n    L = 1.0  # Domain length in m\n    N0 = 64  # Number of base cells\n    h0 = L / N0  # Base cell size in m\n    c1 = 1500.0  # Sound speed in first medium in m/s\n    c2 = 1800.0  # Sound speed in second medium in m/s\n    xs = 0.6  # Interface location in m\n    epsilon = 1e-12  # Regularization for curvature constraint\n\n    # Base cell centers\n    x = (np.arange(N0) + 0.5) * h0\n\n    # Test suite: (f, sigma, M_min, A_min, tau, x0)\n    test_cases = [\n        (8000.0, 0.03, 12, 0.05, 0.005, 0.30),\n        (20000.0, 0.02, 16, 0.01, 0.003, 0.40),\n        (1500.0, 0.08, 10, 0.05, 0.008, 0.25),\n        (12000.0, 0.025, 14, 0.02, 0.004, 0.58),\n    ]\n\n    results = []\n    \n    # Vectorized helper functions based on the problem description\n    def get_c(x_vals):\n        return np.where(x_vals <= xs, c1, c2)\n\n    def get_s(x_vals):\n        return np.where(x_vals <= xs, x_vals / c1, xs / c1 + (x_vals - xs) / c2)\n\n    for case in test_cases:\n        f, sigma, M_min, A_min, tau, x0 = case\n        \n        omega = 2.0 * np.pi * f\n        \n        # Calculate physical quantities at all cell centers\n        c_vals = get_c(x)\n        s_vals = get_s(x)\n                \n        # Wave profile\n        phi_vals = omega * s_vals\n        g_vals = np.exp(-((x - x0)**2) / (2.0 * sigma**2))\n        p_vals = g_vals * np.cos(phi_vals)\n        \n        # Second derivative p''(x)\n        g_prime_vals = -((x - x0) / sigma**2) * g_vals\n        g_prime_prime_vals = (((x - x0)**2 / sigma**4) - (1.0 / sigma**2)) * g_vals\n        phi_prime_vals = omega / c_vals\n        \n        cos_phi = np.cos(phi_vals)\n        sin_phi = np.sin(phi_vals)\n        \n        p_prime_prime_vals = (g_prime_prime_vals * cos_phi \n                              - 2.0 * g_prime_vals * phi_prime_vals * sin_phi \n                              - g_vals * phi_prime_vals**2 * cos_phi)\n\n        # 1. Wavelength resolution constraint\n        lambda_vals = c_vals / f\n        h_wave = lambda_vals / M_min\n        \n        # 2. Interpolation error (curvature) constraint\n        h_curv = np.sqrt(8.0 * tau / (np.abs(p_prime_prime_vals) + epsilon))\n        \n        # Required cell size (most restrictive)\n        h_req = np.minimum(h_wave, h_curv)\n        \n        # Refinement level without amplitude guard\n        # Use np.maximum with 1.0 to avoid log2 of numbers < 1 giving negative results\n        ratio = h0 / h_req\n        tilde_L = np.ceil(np.log2(np.maximum(1.0, ratio))).astype(int)\n\n        # Apply amplitude guard\n        L = np.where(np.abs(p_vals) < A_min, 0, tilde_L)\n        \n        # Calculate aggregate metrics\n        N_leaf = int(np.sum(2**L))\n        L_max = int(np.max(L) if L.size > 0 else 0)\n        \n        # Calculate waste ratio\n        tilde_leaf_cells = 2**tilde_L\n        total_tilde_cells = np.sum(tilde_leaf_cells)\n        \n        waste_mask = np.abs(p_vals) < A_min\n        wasted_cells = np.sum(tilde_leaf_cells[waste_mask])\n        \n        R_waste = wasted_cells / total_tilde_cells if total_tilde_cells > 0 else 0.0\n\n        results.append([N_leaf, L_max, round(R_waste, 8)])\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Adaptive mesh refinement truly demonstrates its power when faced with fields that have complex, spatially varying features. This advanced practice  presents such a scenario, where an acoustic wave passes through a focusing lens, creating a field with rapid phase oscillations. You will implement an adaptive numerical integration scheme that automatically concentrates computational effort in these challenging regions and quantify the significant accuracy gains compared to a uniform grid, highlighting the efficiency of AMR in practical applications.",
            "id": "4116221",
            "problem": "You are to design and implement a complete, runnable program that evaluates the impact of Adaptive Mesh Refinement (AMR) on the numerical accuracy of integrating a rapidly oscillatory phase arising from a thin focusing lens in scalar acoustic wave propagation. The scenario is strictly one-dimensional in the transverse coordinate and based on the scalar time-harmonic acoustics framework. All lengths must be in meters, and the wavelength in meters. The requested numerical outputs are dimensionless.\n\nStart from the scalar acoustic wave equation and its time-harmonic reduction. Use the following fundamental base: the scalar wave equation $\\nabla^2 p - \\dfrac{1}{c^2}\\dfrac{\\partial^2 p}{\\partial t^2} = 0$, the time-harmonic ansatz $p(\\mathbf{r},t) = \\Re\\{U(\\mathbf{r}) e^{-i \\omega t}\\}$ leading to the Helmholtz equation $\\nabla^2 U + k^2 n^2 U = 0$ with $k = \\dfrac{2\\pi}{\\lambda}$, and the Fresnel (paraxial) diffraction approximation for propagation from an aperture to an observation point on the optical axis (acoustic axis) at distance $z$. Model a thin quadratic focusing lens of focal length $f$ as imposing a spatially varying phase on an incident plane wave. Under the paraxial approximation, the on-axis field at distance $z$ behind the lens, transmitted through a one-dimensional aperture of half-width $a$, can be reduced to a single oscillatory integral over the aperture of the form of a quadratic-phase exponential. Derive, from these bases alone, the phase function $\\phi(y)$ and the corresponding curvature parameter which characterizes the local phase curvature as a function of $\\lambda$, $z$, and $f$, without using shortcut formulas.\n\nDefine the reference solution for the on-axis field as the exact value of this quadratic-phase integral over the finite aperture, which is analytically expressible via contour integration methods or standard complex Gaussian integrals in terms of the complex error function. You must implement this exact reference using a numerically reliable special function evaluation.\n\nDesign two numerical integration strategies for computing the same aperture integral:\n- A composite trapezoidal rule on a uniform grid with a specified number of intervals $N$.\n- An Adaptive Mesh Refinement (AMR) strategy in which the local cell size $h$ is determined by a phase-control criterion derived from the phase function $\\phi(y)$. Specifically, for a cell $[y_0,y_1]$ with width $h = y_1 - y_0$, enforce simultaneous bounds that control both the maximum phase gradient contribution and the phase curvature contribution across the cell to be no larger than a user-specified phase tolerance $\\varphi_{\\mathrm{tol}}$ (in radians). Use the first and second derivatives of the phase, $\\phi'(y)$ and $\\phi''(y)$, to design a sufficient refinement test of the form “refine if either a gradient-based bound or a curvature-based bound is violated.” The AMR algorithm must recursively bisect any interval failing this test until the bounds are satisfied. The final numerical integral on the adaptive mesh must use the composite trapezoidal rule.\n\nFor a fair comparison of accuracy at comparable computational cost, choose the number of intervals $N$ for the uniform composite trapezoidal rule to be exactly equal to the number of adaptive intervals produced by your AMR algorithm for the same parameter set.\n\nImplement the following test suite of parameter sets, each described by $(\\lambda, f, a, z)$, all in meters:\n- Case A (moderate phase curvature): $(\\lambda, f, a, z) = (0.008, 1.0, 0.05, 0.8)$.\n- Case B (near focus, minimal oscillations): $(\\lambda, f, a, z) = (0.008, 1.0, 0.05, 1.0)$.\n- Case C (high phase curvature): $(\\lambda, f, a, z) = (0.008, 1.0, 0.10, 0.2)$.\n\nFor each case, compute:\n- The exact complex aperture integral value (reference) derived from first principles.\n- The uniform-grid composite trapezoidal integral with $N$ equal to the number of adaptive intervals.\n- The adaptive-grid composite trapezoidal integral produced by your AMR strategy at a fixed phase tolerance $\\varphi_{\\mathrm{tol}}$.\n\nMeasure the absolute complex-valued integration error for both numerical strategies with respect to the reference. Then quantify the accuracy gain of AMR as the ratio of the uniform error to the adaptive error for each case. If either error is numerically zero, handle the ratio in a numerically robust way without producing infinities or NaNs.\n\nYour program must:\n- Use $\\varphi_{\\mathrm{tol}} = 0.3$ radians.\n- Treat all lengths in meters and wavelength in meters. The outputs are dimensionless error ratios.\n- Produce a single line of output containing a list of three floats, each the accuracy-gain ratio for Cases A, B, and C, in that order, formatted as a Python list literal, for example, $[r_A,r_B,r_C]$.\n\nYour derivation and implementation must be scientifically realistic and self-consistent. The program must be completely self-contained and require no user input. The final outputs must be floats.",
            "solution": "The problem requires the design and implementation of a numerical experiment to evaluate the effectiveness of an Adaptive Mesh Refinement (AMR) strategy compared to a uniform grid for integrating a highly oscillatory function. This function arises in the context of scalar acoustic wave propagation through a thin focusing lens. The derivation, numerical methods, and comparison are detailed below, following the strict principles of mathematical physics.\n\n### 1. Derivation of the Field Integral\n\nThe analysis begins with the scalar acoustic wave equation for pressure perturbation $p$:\n$$ \\nabla^2 p - \\frac{1}{c^2}\\frac{\\partial^2 p}{\\partial t^2} = 0 $$\nAssuming a time-harmonic solution of the form $p(\\mathbf{r}, t) = \\Re\\{U(\\mathbf{r}) e^{-i \\omega t}\\}$, where $U(\\mathbf{r})$ is the complex pressure amplitude, $\\omega$ is the angular frequency, and $i = \\sqrt{-1}$, the wave equation reduces to the Helmholtz equation:\n$$ \\nabla^2 U + k^2 n^2 U = 0 $$\nHere, $k = 2\\pi/\\lambda = \\omega/c$ is the wavenumber in vacuum (or a reference medium with speed of sound $c$), $\\lambda$ is the wavelength, and $n$ is the refractive index. For propagation in a homogeneous medium, we let $n=1$.\n\nWe consider the propagation of an initially planar wavefront through a one-dimensional aperture of half-width $a$ in the $y$-direction, located at the plane $z=0$. The field at an observation point on the optical axis, a distance $z$ away, is described by the Fresnel diffraction integral under the paraxial approximation. For a one-dimensional aperture, the field at $(0, z)$ is given by:\n$$ U(0, z) \\propto \\int_{-a}^{a} U(y, 0^+) e^{i k \\frac{y^2}{2z}} dy $$\nwhere $U(y, 0^+)$ is the complex field immediately after the aperture at $z=0$.\n\nA thin quadratic focusing lens of focal length $f$ located at $z=0$ imposes a phase transformation on an incident wave. For an incident plane wave with unit amplitude, $U_{inc}(y) = 1$, the field just after the lens is:\n$$ U(y, 0^+) = U_{inc}(y) \\cdot T_{lens}(y) = 1 \\cdot e^{-i k \\frac{y^2}{2f}} $$\nThe negative sign in the exponent corresponds to a converging lens that imparts a quadratic phase delay, which advances the phase off-axis to bring rays to a focus.\n\nSubstituting this field into the Fresnel integral, we obtain the expression for the on-axis complex amplitude, up to a proportionality constant:\n$$ I = \\int_{-a}^{a} e^{-i k \\frac{y^2}{2f}} e^{i k \\frac{y^2}{2z}} dy = \\int_{-a}^{a} e^{i \\frac{k}{2} \\left(\\frac{1}{z} - \\frac{1}{f}\\right) y^2} dy $$\nThe integral is defined by a quadratic phase function $\\phi(y)$. We can write the integrand as $e^{i\\phi(y)}$, where:\n$$ \\phi(y) = \\alpha y^2 $$\nThe parameter $\\alpha$ represents the effective quadratic phase curvature and is defined as:\n$$ \\alpha = \\frac{k}{2} \\left(\\frac{1}{z} - \\frac{1}{f}\\right) = \\frac{\\pi}{\\lambda} \\left(\\frac{1}{z} - \\frac{1}{f}\\right) $$\nThe problem thus reduces to the evaluation of the complex-valued integral $I = \\int_{-a}^{a} e^{i \\alpha y^2} dy$.\n\n### 2. Analytical Reference Solution\n\nThe integral $I = \\int_{-a}^{a} e^{i \\alpha y^2} dy$ is a form of the Fresnel integral and can be solved analytically using the complex error function, $\\mathrm{erf}(z) = \\frac{2}{\\sqrt{\\pi}} \\int_0^z e^{-t^2} dt$.\n\nFor the case where $\\alpha \\neq 0$, we perform a change of variables. Let $s = y\\sqrt{-i\\alpha}$, so $y = s/\\sqrt{-i\\alpha}$ and $dy = ds/\\sqrt{-i\\alpha}$. The limits of integration become $\\pm a\\sqrt{-i\\alpha}$.\n$$ I = \\int_{-a\\sqrt{-i\\alpha}}^{a\\sqrt{-i\\alpha}} e^{-s^2} \\frac{ds}{\\sqrt{-i\\alpha}} = \\frac{1}{\\sqrt{-i\\alpha}} \\left[ \\int_{-a\\sqrt{-i\\alpha}}^{0} e^{-s^2} ds + \\int_{0}^{a\\sqrt{-i\\alpha}} e^{-s^2} ds \\right] $$\nUsing the property $\\int_{-z}^0 = -\\int_0^{-z}$ and the definition of the error function, this simplifies to:\n$$ I = \\frac{1}{\\sqrt{-i\\alpha}} \\frac{\\sqrt{\\pi}}{2} \\left[ \\mathrm{erf}(a\\sqrt{-i\\alpha}) - \\mathrm{erf}(-a\\sqrt{-i\\alpha}) \\right] $$\nSince $\\mathrm{erf}(-z) = -\\mathrm{erf}(z)$, the exact solution is:\n$$ I_{exact} = \\sqrt{\\frac{\\pi}{-i\\alpha}} \\mathrm{erf}(a\\sqrt{-i\\alpha}) \\quad (\\text{for } \\alpha \\neq 0) $$\nThe principal branch of the complex square root must be used.\n\nFor the special case where $\\alpha = 0$ (which occurs at the focal plane, $z=f$), the integrand becomes unity:\n$$ I_{exact} = \\int_{-a}^{a} e^{0} dy = 2a \\quad (\\text{for } \\alpha = 0) $$\nThis case corresponds to the Fraunhofer diffraction limit at the focal plane, where the on-axis field is simply proportional to the aperture area (or width in 1D).\n\n### 3. Numerical Integration Strategies\n\n#### Composite Trapezoidal Rule\nFor a mesh defined by a set of points $\\{y_j\\}_{j=0}^M$, the integral is approximated by summing the areas of trapezoids over each subinterval $[y_j, y_{j+1}]$:\n$$ I_{trapz} = \\sum_{j=0}^{M-1} \\frac{f(y_j) + f(y_{j+1})}{2} (y_{j+1} - y_j) $$\nwhere $f(y) = e^{i\\alpha y^2}$. For a uniform grid with $N$ intervals over $[-a, a]$, the step size is constant, $h = 2a/N$, and the points are $y_j = -a + jh$.\n\n#### Adaptive Mesh Refinement (AMR)\nThe AMR strategy adapts the local cell size $h$ to maintain a specified level of accuracy. The refinement decision is based on the local behavior of the phase function $\\phi(y) = \\alpha y^2$. The derivatives are $\\phi'(y) = 2\\alpha y$ and $\\phi''(y) = 2\\alpha$. An interval $[y_0, y_1]$ of width $h=y_1-y_0$ is recursively bisected until it satisfies two conditions based on a phase tolerance $\\varphi_{\\mathrm{tol}}$.\n\n1.  **Gradient-based Criterion**: This condition ensures that the total phase change across an interval is bounded, which is necessary to accurately resolve the oscillations. The phase change across the interval is $|\\phi(y_1) - \\phi(y_0)|$. By the Mean Value Theorem, this equals $|\\phi'(\\xi)|h$ for some $\\xi \\in (y_0, y_1)$. To ensure this is less than $\\varphi_{\\mathrm{tol}}$, we enforce a stricter condition using the maximum gradient in the interval:\n    $$ h \\cdot \\max_{y \\in [y_0, y_1]} |\\phi'(y)| \\le \\varphi_{\\mathrm{tol}} $$\n    Since $\\phi'(y)$ is monotonic, the maximum occurs at the endpoint with the largest magnitude. The condition is: $h \\cdot |2\\alpha| \\cdot \\max(|y_0|, |y_1|) \\le \\varphi_{\\mathrm{tol}}$.\n\n2.  **Curvature-based Criterion**: This condition ensures that the phase function over the interval is well-approximated by a straight line. The maximum deviation of the quadratic phase from a chord connecting its endpoints occurs at the midpoint and is approximately $\\frac{h^2}{8}|\\phi''(y_c)|$, where $y_c$ is the interval center. We bound this deviation:\n    $$ \\frac{h^2}{8} |\\phi''(y)| \\le \\varphi_{\\mathrm{tol}} $$\n    Since $\\phi''(y) = 2\\alpha$ is constant, this simplifies to: $\\frac{|\\alpha|h^2}{4} \\le \\varphi_{\\mathrm{tol}}$.\n\nAn interval is bisected if either of these conditions is violated. The algorithm starts with the full interval $[-a, a]$ and proceeds until all generated subintervals satisfy both criteria. The final integral is computed using the composite trapezoidal rule on the resulting non-uniform mesh.\n\n### 4. Comparison and Implementation\nThe accuracy of the AMR method is compared against a uniform grid method with an equivalent number of function evaluations. This is achieved by setting the number of intervals for the uniform grid, $N_{uniform}$, to be equal to the total number of intervals generated by the AMR algorithm, $N_{adaptive}$, for a given set of parameters.\n\nThe accuracy gain is quantified by the ratio of the absolute errors:\n$$ R = \\frac{|\\text{Error}_{uniform}|}{|\\text{Error}_{adaptive}|} = \\frac{|I_{uniform} - I_{exact}|}{|I_{adaptive} - I_{exact}|} $$\nSpecial handling is implemented for cases where the adaptive error is numerically zero to avoid division by zero while correctly reflecting the performance gain.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import erf\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Solves the adaptive mesh refinement problem for acoustic wave propagation.\n    \"\"\"\n    \n    # Test cases defined as (lambda, f, a, z), all in meters.\n    test_cases = [\n        (0.008, 1.0, 0.05, 0.8),  # Case A: Moderate curvature\n        (0.008, 1.0, 0.05, 1.0),  # Case B: Near focus (zero curvature)\n        (0.008, 1.0, 0.10, 0.2),  # Case C: High curvature\n    ]\n    \n    # Phase tolerance for the AMR algorithm, in radians.\n    phi_tol = 0.3\n    \n    results = []\n\n    for lmbda, f, a, z in test_cases:\n        # 1. Calculate physical and integral parameters\n        k = 2 * np.pi / lmbda\n        \n        # Avoid division by zero if z is exactly 0\n        if np.abs(z) < 1e-15:\n            alpha = -np.inf # or handle as an error\n        else:\n            alpha = (np.pi / lmbda) * (1 / z - 1 / f)\n\n        # Integrand function\n        def integrand(y_vals, alpha_val):\n            if np.abs(alpha_val) < 1e-15:\n                return np.ones_like(y_vals, dtype=complex)\n            return np.exp(1j * alpha_val * y_vals**2)\n\n        # 2. Calculate the exact reference solution\n        if np.abs(alpha) < 1e-15:\n            # Special case for z = f, where alpha = 0.\n            I_exact = 2.0 * a\n        else:\n            # Use the complex error function for the general case.\n            # The argument to sqrt must be complex to use the principal branch correctly.\n            arg = a * np.sqrt(-1j * alpha)\n            I_exact = np.sqrt(np.pi / (-1j * alpha)) * erf(arg)\n        \n        # 3. Generate the adaptive mesh\n        final_intervals = []\n        if np.abs(alpha) < 1e-15:\n            # If alpha is zero, the integrand is constant, no refinement needed.\n            final_intervals.append((-a, a))\n        else:\n            work_queue = deque([(-a, a)])\n            mag_2_alpha = np.abs(2 * alpha)\n            mag_alpha_div_4 = np.abs(alpha) / 4.0\n\n            while work_queue:\n                y0, y1 = work_queue.popleft()\n                h = y1 - y0\n                \n                # Gradient-based refinement criterion\n                grad_term = h * mag_2_alpha * max(np.abs(y0), np.abs(y1))\n                # Curvature-based refinement criterion\n                curv_term = mag_alpha_div_4 * h**2\n\n                if grad_term > phi_tol or curv_term > phi_tol:\n                    # If either criterion fails, bisect the interval\n                    ym = (y0 + y1) / 2.0\n                    work_queue.append((y0, ym))\n                    work_queue.append((ym, y1))\n                else:\n                    # Interval is small enough, add to final list\n                    final_intervals.append((y0, y1))\n        \n        # Sort intervals to create a contiguous mesh (deque may alter order slightly)\n        final_intervals.sort()\n        adaptive_points = np.array([interval[0] for interval in final_intervals] + [final_intervals[-1][1]])\n        num_adaptive_intervals = len(final_intervals)\n\n        # 4. Compute integral on the adaptive mesh using composite trapezoidal rule\n        y_vals_adaptive = integrand(adaptive_points, alpha)\n        I_adaptive = 0.5 * np.sum((y_vals_adaptive[:-1] + y_vals_adaptive[1:]) * (adaptive_points[1:] - adaptive_points[:-1]))\n        \n        # 5. Compute integral on a uniform mesh with the same number of intervals\n        num_uniform_intervals = num_adaptive_intervals\n        uniform_points = np.linspace(-a, a, num_uniform_intervals + 1)\n        y_vals_uniform = integrand(uniform_points, alpha)\n        h_uniform = 2 * a / num_uniform_intervals\n        I_uniform = h_uniform * (0.5 * (y_vals_uniform[0] + y_vals_uniform[-1]) + np.sum(y_vals_uniform[1:-1]))\n        \n        # 6. Calculate errors and the accuracy gain ratio\n        err_adaptive = np.abs(I_adaptive - I_exact)\n        err_uniform = np.abs(I_uniform - I_exact)\n        \n        # Robustly handle the ratio calculation\n        if err_adaptive < 1e-15:\n            # If adaptive error is numerically zero:\n            # If uniform error is also zero, the methods are equally good, ratio is 1.\n            # If uniform error is non-zero, AMR is infinitely better; return a large number.\n            ratio = 1.0 if err_uniform < 1e-15 else 1e15\n        else:\n            ratio = err_uniform / err_adaptive\n            \n        results.append(ratio)\n\n    # Format the output as a list of floats\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}