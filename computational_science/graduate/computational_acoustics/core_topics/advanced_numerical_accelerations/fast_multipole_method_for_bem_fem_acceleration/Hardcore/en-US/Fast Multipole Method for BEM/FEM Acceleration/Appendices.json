{
    "hands_on_practices": [
        {
            "introduction": "Understanding the computational cost of an algorithm is the first step toward mastering its application. This exercise guides you through a foundational analysis of the Fast Multipole Method's complexity . By dissecting the algorithm into its core translation stages—Multipole-to-Multipole (M2M), Local-to-Local (L2L), and Multipole-to-Local (M2L)—you will derive the operational cost for each and identify the dominant term, providing a clear understanding of how FMM achieves its remarkable efficiency.",
            "id": "4123790",
            "problem": "Consider the three-dimensional exterior acoustic scattering problem governed by the Helmholtz equation with wavenumber $k$, discretized by the Boundary Element Method (BEM) and accelerated by the Fast Multipole Method (FMM). The FMM is built on a uniform octree covering a cubic computational domain, with tree depth $L \\geq 1$. Assume that at each level $l = 1, 2, \\dots, L$ the octree has $8^{l}$ interior, nonempty boxes. The FMM uses classical spherical harmonic multipole and local expansions truncated at angular order $p \\geq 1$.\n\nAssume the following physically and algorithmically standard conditions:\n- The Helmholtz Green’s function is $G(\\mathbf{x}, \\mathbf{y}) = \\dfrac{\\exp(\\mathrm{i} k |\\mathbf{x} - \\mathbf{y}|)}{4 \\pi |\\mathbf{x} - \\mathbf{y}|}$.\n- Multipole and local expansions are represented in a spherical harmonic basis truncated at order $p$.\n- For each interior box at level $l$, the cardinality of its well-separated interaction list (boxes at the same level that are not adjacent but are children of neighbors of the parent) is a fixed constant equal to $189$.\n- Each multipole-to-multipole (M2M) upward translation occurs once per child-to-parent relation, and each local-to-local (L2L) downward translation occurs once per parent-to-child relation.\n- Adopt a cost model in which the operation count for any translation (M2M, M2L, L2L) is proportional to the number of complex spherical harmonic coefficients involved, and count one complex multiply-add per coefficient as one operation unit.\n\nStarting from these assumptions and the fundamental properties of spherical harmonic expansions for the Helmholtz kernel, do the following:\n1. Derive the number of spherical harmonic coefficients retained per expansion as a function of $p$.\n2. Estimate the total number of multipole-to-local (M2L) interactions across all levels $l = 1, \\dots, L$.\n3. Estimate the total number of multipole-to-multipole (M2M) translations across all levels and the total number of local-to-local (L2L) translations across all levels.\n4. Using the above counts and the cost model, predict the asymptotically dominant term of the total operation count over the entire tree as a single closed-form expression in terms of $p$ and $L$.\n\nExpress your final answer as a single symbolic expression representing the dominant operation count in operation units. No rounding is required and no physical units are to be reported in the final expression.",
            "solution": "The user-provided problem will first be validated against the specified criteria before a solution is attempted.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\nThe givens extracted verbatim from the problem statement are:\n-   **Problem Domain:** Three-dimensional exterior acoustic scattering.\n-   **Governing Equation:** Helmholtz equation with wavenumber $k$.\n-   **Numerical Method:** Boundary Element Method (BEM) accelerated by the Fast Multipole Method (FMM).\n-   **FMM Tree Structure:** Uniform octree covering a cubic computational domain, with depth $L \\geq 1$.\n-   **Box Count:** At each level $l = 1, 2, \\dots, L$, the octree has $8^{l}$ interior, nonempty boxes.\n-   **Expansions:** Classical spherical harmonic multipole and local expansions, truncated at angular order $p \\geq 1$.\n-   **Green’s Function:** The Helmholtz Green’s function is $G(\\mathbf{x}, \\mathbf{y}) = \\dfrac{\\exp(\\mathrm{i} k |\\mathbf{x} - \\mathbf{y}|)}{4 \\pi |\\mathbf{x} - \\mathbf{y}|}$.\n-   **Basis:** Spherical harmonic basis truncated at order $p$.\n-   **Interaction List:** For each interior box at level $l$, the cardinality of its well-separated interaction list is a fixed constant equal to $189$.\n-   **Translation Rules:**\n    -   Multipole-to-multipole (M2M) upward translation occurs once per child-to-parent relation.\n    -   Local-to-local (L2L) downward translation occurs once per parent-to-child relation.\n-   **Cost Model:** The operation count for any translation (M2M, M2L, L2L) is proportional to the number of complex spherical harmonic coefficients, with one complex multiply-add per coefficient counted as one operation unit.\n\n**Step 2: Validate Using Extracted Givens**\n-   **Scientifically Grounded:** The problem is firmly grounded in computational acoustics and the theory of the Fast Multipole Method. The Helmholtz equation, its Green's function, spherical harmonic expansions, octree data structures, and the concepts of M2M, M2L, and L2L translations are all standard and fundamental elements of this field. The constant $189$ for the interaction list size is a known, specific value used in some FMM implementations for uniform grids, representing the number of non-adjacent boxes whose parents are neighbors.\n-   **Well-Posed:** The problem is well-posed. It provides a clear set of assumptions and asks for the derivation of operation counts, which leads to a unique analytical expression.\n-   **Objective:** The problem is stated in precise, objective, and technical language, free from ambiguity or subjective claims.\n-   **Completeness and Consistency:** The problem is self-contained. It provides all necessary parameters ($L$, $p$) and constants (interaction list size of $189$, box count scaling as $8^l$) to perform the analysis. The assumptions, such as a uniform tree with no empty boxes, are simplifying but explicitly stated and consistent for the purpose of algorithmic analysis.\n-   **Realism:** While the assumption of a perfectly uniform and completely filled octree is an idealization, it is a standard model used in textbooks and research papers to perform a \"best-case\" or average-case complexity analysis of the FMM algorithm.\n\n**Step 3: Verdict and Action**\nThe problem is valid. It is a standard, albeit simplified, exercise in the algorithmic analysis of the Fast Multipole Method. The solution will be provided as requested.\n\n### Solution Derivation\n\nThe problem requires a step-by-step derivation of the dominant operation count for the far-field computations in an FMM-accelerated BEM code.\n\n**1. Number of Spherical Harmonic Coefficients**\nA spherical harmonic expansion truncated at order (maximum degree) $p$ includes all spherical harmonics $Y_{n}^{m}$ for degrees $n = 0, 1, \\dots, p$. For each degree $n$, the order $m$ takes $2n+1$ integer values from $-n$ to $n$.\nThe total number of complex coefficients, $N_{\\text{coef}}$, is the sum of the number of harmonics for each degree up to $p$:\n$$N_{\\text{coef}}(p) = \\sum_{n=0}^{p} (2n+1)$$\nThis is the sum of an arithmetic progression. We can compute it as:\n$$N_{\\text{coef}}(p) = 2 \\sum_{n=0}^{p} n + \\sum_{n=0}^{p} 1 = 2 \\frac{p(p+1)}{2} + (p+1)$$\n$$N_{\\text{coef}}(p) = p(p+1) + (p+1) = (p+1)(p+1) = (p+1)^{2}$$\nSo, each multipole or local expansion is represented by $(p+1)^2$ complex coefficients.\n\n**2. Total Number of Multipole-to-Local (M2L) Interactions**\nM2L translations are performed for each box at a given level with all the boxes in its interaction list.\nAt any level $l$, where $l \\in \\{1, 2, \\dots, L\\}$, there are $N_{\\text{box}}(l) = 8^l$ non-empty boxes.\nFor each of these $8^l$ boxes, the size of the interaction list is given as a constant, $N_{\\text{int}} = 189$.\nThe number of M2L translation operations at level $l$ is $N_{\\text{M2L}}(l) = N_{\\text{box}}(l) \\times N_{\\text{int}} = 8^l \\times 189$.\nThe total number of M2L interactions, $C_{\\text{M2L}}$, is the sum over all levels from $l=1$ to $L$:\n$$C_{\\text{M2L}} = \\sum_{l=1}^{L} N_{\\text{M2L}}(l) = \\sum_{l=1}^{L} 189 \\cdot 8^l = 189 \\sum_{l=1}^{L} 8^l$$\nThis is a geometric series sum: $\\sum_{i=1}^{n} r^i = r \\frac{r^n - 1}{r-1}$. With $r=8$ and $n=L$:\n$$C_{\\text{M2L}} = 189 \\left( 8 \\frac{8^L - 1}{8-1} \\right) = 189 \\left( \\frac{8}{7} (8^L - 1) \\right)$$\nSince $189 = 27 \\times 7$, we can simplify the prefactor:\n$$C_{\\text{M2L}} = 27 \\times 7 \\times \\frac{8}{7} (8^L - 1) = 27 \\times 8 (8^L - 1) = 216(8^L - 1)$$\n\n**3. Total Number of M2M and L2L Translations**\n-   **Multipole-to-Multipole (M2M) Translations:** These occur in the upward pass of the FMM algorithm. An M2M translation happens for each child-parent pair. The children are all boxes at levels $l=1, \\dots, L$. The total number of M2M translations, $C_{\\text{M2M}}$, is the total number of children boxes in the tree (excluding the root at level $0$).\n    $$C_{\\text{M2M}} = \\sum_{l=1}^{L} N_{\\text{box}}(l) = \\sum_{l=1}^{L} 8^l$$\n    Using the same geometric series formula:\n    $$C_{\\text{M2M}} = \\frac{8}{7}(8^L - 1)$$\n-   **Local-to-Local (L2L) Translations:** These occur in the downward pass. An L2L translation happens for each parent-child pair. The logic is identical to the M2M case; the number of translations is the total number of children receiving the translated expansion.\n    $$C_{\\text{L2L}} = \\sum_{l=1}^{L} N_{\\text{box}}(l) = \\sum_{l=1}^{L} 8^l = \\frac{8}{7}(8^L - 1)$$\n\n**4. Asymptotically Dominant Term of the Total Operation Count**\nThe cost model states that the operation count for any single translation is equal to the number of coefficients, $N_{\\text{coef}} = (p+1)^2$.\nThe total operation count, $O$, for the far-field part is the sum of the costs of all M2M, L2L, and M2L translations.\n\n-   **Cost of M2M:** $O_{\\text{M2M}} = C_{\\text{M2M}} \\times N_{\\text{coef}} = \\frac{8}{7}(8^L - 1)(p+1)^2$.\n-   **Cost of L2L:** $O_{\\text{L2L}} = C_{\\text{L2L}} \\times N_{\\text{coef}} = \\frac{8}{7}(8^L - 1)(p+1)^2$.\n-   **Cost of M2L:** $O_{\\text{M2L}} = C_{\\text{M2L}} \\times N_{\\text{coef}} = 216(8^L - 1)(p+1)^2$.\n\nThe total operation count is $O_{\\text{total}} = O_{\\text{M2M}} + O_{\\text{L2L}} + O_{\\text{M2L}}$.\n$$O_{\\text{total}} = \\left( \\frac{8}{7} + \\frac{8}{7} + 216 \\right) (8^L - 1)(p+1)^2$$\n$$O_{\\text{total}} = \\left( \\frac{16}{7} + \\frac{1512}{7} \\right) (8^L - 1)(p+1)^2 = \\frac{1528}{7} (8^L - 1)(p+1)^2$$\nThe problem asks for the \"asymptotically dominant term\". The three components of the cost, $O_{\\text{M2M}}$, $O_{\\text{L2L}}$, and $O_{\\text{M2L}}$, all have the same dependence on $L$ and $p$, namely $\\propto (8^L - 1)(p+1)^2$. Therefore, the dominant term is the one with the largest constant prefactor.\n-   Prefactor for M2M: $\\frac{8}{7} \\approx 1.14$\n-   Prefactor for L2L: $\\frac{8}{7} \\approx 1.14$\n-   Prefactor for M2L: $216$\nClearly, $216$ is much larger than $\\frac{8}{7}$. The dominant contribution to the total operation count comes from the M2L translations. This is a standard result in FMM complexity analysis.\nThe expression for this dominant term is:\n$$O_{\\text{dominant}} = O_{\\text{M2L}} = 216(8^L - 1)(p+1)^2$$\nThis is a closed-form expression representing the dominant part of the operational cost under the given assumptions.",
            "answer": "$$\n\\boxed{216(8^{L} - 1)(p+1)^{2}}\n$$"
        },
        {
            "introduction": "While theoretical complexity provides insight into an algorithm's scaling, practical performance depends on constant factors, overhead, and hardware capabilities. This practice bridges the gap between theory and reality by asking a crucial engineering question: at what problem size does the FMM's higher initial overhead become justified by its superior scaling compared to a direct computation ? By building a performance model that incorporates realistic algorithmic costs and hardware parameters, you will calculate the practical \"break-even\" point, a key metric for deciding when to employ this advanced acceleration technique.",
            "id": "4123862",
            "problem": "Consider a three-dimensional acoustic Boundary Element Method (BEM) matrix-vector product associated with the Helmholtz equation, where the kernel is the free-space Green’s function given by $G(\\mathbf{r}) = \\exp(i k r) / (4 \\pi r)$ with $r = \\|\\mathbf{r}\\|$. You wish to accelerate this matrix-vector multiplication using the Fast Multipole Method (FMM) within a multipole expansion framework based on spherical harmonics. The target is to determine the break-even number of boundary elements $N^{\\star}$ at which the FMM-accelerated matrix-vector product becomes faster than a dense, direct matrix-vector product.\n\nAssume the following scientifically realistic and internally consistent setting:\n\n- Physics and discretization:\n  - The wavenumber is $k = 20 \\ \\mathrm{m}^{-1}$.\n  - The scatterer is approximately spherical with radius $a = 0.5 \\ \\mathrm{m}$, so $k a = 10$.\n  - The BEM employs a mesh of $N$ boundary elements.\n  - The target relative accuracy of the FMM is $10^{-3}$.\n  - The multipole expansion order is set by a conservative rule of thumb for the Helmholtz kernel: $p = \\lceil k a + p_{0} \\rceil$ with $p_{0} = 4$.\n\n- Algorithmic cost model (floating-point operations):\n  - For the dense direct matrix-vector product, the per-pair interaction requires $c_{\\mathrm{pair}} = 60$ floating-point operations (flops), covering distance evaluation, $1/r$, the complex exponential, complex scaling, and accumulation. Hence, the total flop count is $f_{\\mathrm{dense}}(N) = c_{\\mathrm{pair}} N^{2}$.\n  - For the Fast Multipole Method (FMM), use a standard low-frequency Helmholtz spherical-harmonic expansion model with the following costs:\n    - Each multipole or local expansion contains $(p+1)^{2}$ coefficients.\n    - Particle-to-multipole (P2M) and local-to-particle (L2P) costs are $8 (p+1)^{2}$ flops per particle, respectively.\n    - Multipole-to-local (M2L) translation cost uses rotation/factorization optimized implementation with $6 (p+1)^{3}$ flops per well-separated box interaction.\n    - Upward aggregation (M2M) and downward propagation (L2L) each cost $2 (p+1)^{3}$ flops per child contribution, and there are $8$ children per parent, resulting in $16 (p+1)^{3}$ flops per box for M2M and the same for L2L.\n    - Each leaf box contains $n_{0} = 64$ boundary elements.\n    - The well-separated interaction list size per box is $L = 189$.\n    - The average near-field interactions per particle (direct evaluation not handled by FMM) is $q = 40$ pairs, each at the dense per-pair cost $c_{\\mathrm{pair}}$.\n\n  Under these assumptions, the total FMM flop count is modeled as\n  $$f_{\\mathrm{FMM}}(N, p) = N \\big( 8 (p+1)^{2} + 8 (p+1)^{2} + q \\, c_{\\mathrm{pair}} \\big) + \\frac{N}{n_{0}} \\big( L \\cdot 6 (p+1)^{3} + 16 (p+1)^{3} + 16 (p+1)^{3} \\big).$$\n\n- Hardware model and arithmetic intensity:\n  - The processor has peak double-precision performance $R = 2.5 \\times 10^{12}$ flops/s and sustained memory bandwidth $B = 2.5 \\times 10^{11}$ bytes/s, so $R/B = 10$ flops/byte.\n  - Empirically, the arithmetic intensity of the dense kernel evaluation in this BEM setting is $I_{\\mathrm{dense}} \\approx 15$ flops/byte, and the arithmetic intensity of the FMM core translations is $I_{\\mathrm{FMM}} \\approx 20$ flops/byte. Because $I_{\\mathrm{dense}}  R/B$ and $I_{\\mathrm{FMM}}  R/B$, both methods are compute-bound on this hardware, so their execution times are dominated by floating-point operation counts: $T_{\\mathrm{dense}} \\approx f_{\\mathrm{dense}}(N) / R$ and $T_{\\mathrm{FMM}} \\approx f_{\\mathrm{FMM}}(N, p) / R$.\n\nTask:\n1. Using the data above, compute the break-even $N^{\\star}$ such that $T_{\\mathrm{FMM}}(N^{\\star}) = T_{\\mathrm{dense}}(N^{\\star})$.\n2. Express your final answer as a unitless count of boundary elements and round your answer to three significant figures.",
            "solution": "The problem asks for the break-even number of boundary elements, $N^{\\star}$, at which the computational time for a direct matrix-vector product, $T_{\\mathrm{dense}}$, equals that of a Fast Multipole Method (FMM) accelerated matrix-vector product, $T_{\\mathrm{FMM}}$. The break-even condition is thus $T_{\\mathrm{dense}}(N^{\\star}) = T_{\\mathrm{FMM}}(N^{\\star})$.\n\nThe problem provides a hardware model where both the dense and FMM computations are compute-bound. This is because their respective arithmetic intensities, $I_{\\mathrm{dense}} \\approx 15$ flops/byte and $I_{\\mathrm{FMM}} \\approx 20$ flops/byte, are greater than the machine's balance of $R/B = (2.5 \\times 10^{12}) / (2.5 \\times 10^{11}) = 10$ flops/byte. In this regime, the execution time, $T$, is determined by the total number of floating-point operations (flops), $f$, and the peak processor performance, $R$, such that $T \\approx f/R$.\n\nThe break-even condition $T_{\\mathrm{dense}}(N^{\\star}) = T_{\\mathrm{FMM}}(N^{\\star})$ can therefore be simplified by substituting the flop-based time models:\n$$ \\frac{f_{\\mathrm{dense}}(N^{\\star})}{R} = \\frac{f_{\\mathrm{FMM}}(N^{\\star})}{R} $$\nThe processor performance $R$ cancels out, reducing the problem to finding the $N^{\\star}$ that equalizes the total flop counts:\n$$ f_{\\mathrm{dense}}(N^{\\star}) = f_{\\mathrm{FMM}}(N^{\\star}) $$\n\nFirst, we must determine the multipole expansion order, $p$. The problem provides the rule of thumb $p = \\lceil k a + p_{0} \\rceil$. Using the given values $k = 20 \\ \\mathrm{m}^{-1}$, $a = 0.5 \\ \\mathrm{m}$, and $p_{0} = 4$:\n$$ k a = 20 \\times 0.5 = 10 $$\n$$ p = \\lceil 10 + 4 \\rceil = \\lceil 14 \\rceil = 14 $$\n\nNext, we substitute the given cost models for the total flop counts into our break-even equation.\nThe cost for the dense matrix-vector product is given by:\n$$ f_{\\mathrm{dense}}(N) = c_{\\mathrm{pair}} N^{2} $$\nwhere $c_{\\mathrm{pair}} = 60$.\n\nThe cost for the FMM-accelerated product is given by:\n$$ f_{\\mathrm{FMM}}(N, p) = N \\big( 8 (p+1)^{2} + 8 (p+1)^{2} + q \\, c_{\\mathrm{pair}} \\big) + \\frac{N}{n_{0}} \\big( L \\cdot 6 (p+1)^{3} + 16 (p+1)^{3} + 16 (p+1)^{3} \\big) $$\nThis expression can be simplified and written as $f_{\\mathrm{FMM}}(N, p) = C_{\\mathrm{FMM}} N$, where $C_{\\mathrm{FMM}}$ is a constant representing the effective work per element in the FMM:\n$$ C_{\\mathrm{FMM}} = 16 (p+1)^{2} + q \\, c_{\\mathrm{pair}} + \\frac{1}{n_{0}} \\left( 6L + 32 \\right) (p+1)^{3} $$\n\nThe break-even equation becomes:\n$$ c_{\\mathrm{pair}} (N^{\\star})^{2} = C_{\\mathrm{FMM}} N^{\\star} $$\nFor a non-trivial solution where $N^{\\star}  0$, we can divide by $N^{\\star}$:\n$$ c_{\\mathrm{pair}} N^{\\star} = C_{\\mathrm{FMM}} $$\n$$ N^{\\star} = \\frac{C_{\\mathrm{FMM}}}{c_{\\mathrm{pair}}} $$\n\nNow, we substitute the given numerical values to calculate $C_{\\mathrm{FMM}}$:\n$p = 14$, so $p+1 = 15$.\n$c_{\\mathrm{pair}} = 60$.\n$q = 40$.\n$n_{0} = 64$.\n$L = 189$.\n\nLet's calculate the components of $C_{\\mathrm{FMM}}$:\nThe direct and near-field interaction cost per particle is:\n$$ 16 (p+1)^{2} + q \\, c_{\\mathrm{pair}} = 16 (15)^{2} + 40 \\times 60 = 16 \\times 225 + 2400 = 3600 + 2400 = 6000 \\ \\text{flops} $$\n\nThe far-field (FMM translation) cost per particle is:\n$$ \\frac{1}{n_{0}} \\left( 6L + 32 \\right) (p+1)^{3} = \\frac{1}{64} \\left( 6 \\times 189 + 32 \\right) (15)^{3} $$\n$$ = \\frac{1}{64} \\left( 1134 + 32 \\right) (3375) $$\n$$ = \\frac{1}{64} \\left( 1166 \\right) (3375) $$\n$$ = \\frac{3935250}{64} = 61488.28125 \\ \\text{flops} $$\n\nThe total effective FMM cost per particle is the sum of these components:\n$$ C_{\\mathrm{FMM}} = 6000 + 61488.28125 = 67488.28125 $$\n\nFinally, we calculate the break-even number of elements $N^{\\star}$:\n$$ N^{\\star} = \\frac{C_{\\mathrm{FMM}}}{c_{\\mathrm{pair}}} = \\frac{67488.28125}{60} = 1124.8046875 $$\n\nThe problem requires the answer to be rounded to three significant figures. The number $1124.8046875$ is written in scientific notation as $1.1248046875 \\times 10^{3}$. Rounding the mantissa to two decimal places gives $1.12$. Therefore, the break-even number of elements is:\n$$ N^{\\star} \\approx 1.12 \\times 10^{3} $$\nThis corresponds to $1120$ boundary elements.",
            "answer": "$$\\boxed{1.12 \\times 10^3}$$"
        },
        {
            "introduction": "The final pillar of developing and using any numerical method is rigorous validation. This practice puts the FMM's accuracy to the test by comparing its results against a known analytical solution—the \"gold standard\" for acoustic scattering from a rigid sphere . By implementing the analytical series solution and calculating the error of a truncated, FMM-like expansion, you will gain hands-on experience in verifying code correctness and quantifying how the truncation order $p$ directly impacts the solution's near-field and far-field accuracy.",
            "id": "4123798",
            "problem": "Consider time-harmonic linear acoustics in three spatial dimensions, governed by the scalar Helmholtz equation for acoustic pressure. In the exterior of a rigid sphere of radius $a$, the total acoustic pressure $p_{\\text{tot}}$ satisfies the governing equation and boundary condition\n$$\\nabla^2 p_{\\text{tot}} + k^2 p_{\\text{tot}} = 0 \\quad \\text{for } r  a,$$\n$$\\frac{\\partial p_{\\text{tot}}}{\\partial n}\\Big|_{r=a} = 0,$$\nwhere $k$ is the acoustic wavenumber and $\\partial/\\partial n$ denotes the outward normal derivative. A plane wave of unit amplitude propagating along the $z$-axis is incident on the sphere, given by\n$$p_{\\text{inc}}(\\mathbf{x}) = e^{i k z} = e^{i k r \\cos\\theta},$$\nwhere $(r,\\theta,\\phi)$ are standard spherical coordinates and $\\theta$ is the polar angle measured from the $z$-axis.\n\nStarting from the above equations and boundary condition, use separation of variables and orthogonality of spherical harmonics to derive the analytical series representation for the total field outside the sphere,\n$$p_{\\text{tot}}(r,\\theta) = \\sum_{n=0}^{\\infty} i^n (2n+1) \\left[j_n(k r) + A_n h_n^{(1)}(k r)\\right] P_n(\\cos\\theta),$$\nwhere $j_n$ is the spherical Bessel function of the first kind of order $n$, $h_n^{(1)}$ is the spherical Hankel function of the first kind of order $n$, $P_n$ is the Legendre polynomial of degree $n$, and $A_n$ are unknown modal coefficients. Show that the Neumann boundary condition at $r=a$ yields\n$$A_n = -\\frac{j_n'(k a)}{h_n^{(1)\\prime}(k a)},$$\nwhere the prime denotes differentiation with respect to the argument. From the large-$r$ asymptotics of $h_n^{(1)}$, derive the far-field scattering amplitude $f(\\theta)$ defined by\n$$p_{\\text{sca}}(r,\\theta) \\sim \\frac{e^{i k r}}{r} f(\\theta) \\quad \\text{as } r \\to \\infty,$$\nand show that\n$$f(\\theta) = -\\frac{i}{k} \\sum_{n=0}^{\\infty} (2n+1) A_n P_n(\\cos\\theta).$$\n\nUse the above analytical solution to construct a validation for the Fast Multipole Method (FMM)-accelerated Boundary Element Method (BEM). In a multipole-based evaluation, truncation at order $p$ retains modes $n=0,1,\\dots,p$. Define the truncated total field and truncated far-field amplitude by\n$$p_{\\text{tot}}^{(p)}(r,\\theta) = \\sum_{n=0}^{p} i^n (2n+1) \\left[j_n(k r) + A_n h_n^{(1)}(k r)\\right] P_n(\\cos\\theta),$$\n$$f^{(p)}(\\theta) = -\\frac{i}{k} \\sum_{n=0}^{p} (2n+1) A_n P_n(\\cos\\theta).$$\nLet the reference solutions $p_{\\text{tot}}^{\\text{ref}}$ and $f^{\\text{ref}}$ use a sufficiently large truncation index $N_{\\text{ref}}$ to guarantee convergence. Define the near-field relative error at radius $r_{\\text{nf}} = a(1+\\delta)$ over a set of sample polar angles $\\{\\theta_m\\}$ by\n$$E_{\\text{nf}}(p) = \\frac{\\left(\\sum_m \\left|p_{\\text{tot}}^{(p)}(r_{\\text{nf}},\\theta_m) - p_{\\text{tot}}^{\\text{ref}}(r_{\\text{nf}},\\theta_m)\\right|^2\\right)^{1/2}}{\\left(\\sum_m \\left|p_{\\text{tot}}^{\\text{ref}}(r_{\\text{nf}},\\theta_m)\\right|^2\\right)^{1/2}},$$\nand the far-field relative error over sample angles $\\{\\theta_m\\}$ by\n$$E_{\\text{ff}}(p) = \\frac{\\left(\\sum_m \\left|f^{(p)}(\\theta_m) - f^{\\text{ref}}(\\theta_m)\\right|^2\\right)^{1/2}}{\\left(\\sum_m \\left|f^{\\text{ref}}(\\theta_m)\\right|^2\\right)^{1/2}}.$$\n\nImplement a program that:\n- Computes $A_n$ using the derived formula for a rigid sphere.\n- Evaluates $p_{\\text{tot}}^{(p)}$ at $r_{\\text{nf}}$ and $f^{(p)}(\\theta)$ for specified sets of sample angles.\n- Computes $E_{\\text{nf}}(p)$ and $E_{\\text{ff}}(p)$.\n\nUse dimensionless units by setting $a=1$, so that $k a$ is the single dimensionless parameter controlling frequency. Angles must be expressed in radians. You may assume that $N_{\\text{ref}}$ is sufficiently large to serve as a converged reference.\n\nTest suite specification:\n- Let the near-field sampling radius be $r_{\\text{nf}} = a(1+\\delta)$ with $\\delta = 0.05$.\n- Use the far-field sample angles $\\theta \\in \\{0, \\pi/3, \\pi/2, 2\\pi/3, \\pi\\}$.\n- Use near-field sample angles $\\theta$ equal to $16$ uniformly spaced points in $[0,\\pi]$.\n- Define the following test cases as pairs $(k a, p)$:\n    - Case $1$: $(1.0, 0)$, an extreme truncation edge case.\n    - Case $2$: $(1.0, 5)$, a moderate truncation at low frequency.\n    - Case $3$: $(5.0, 5)$, a moderate truncation at higher frequency.\n    - Case $4$: $(5.0, 15)$, a higher truncation at higher frequency.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[E_{\\text{nf}}(p_1), E_{\\text{ff}}(p_1), E_{\\text{nf}}(p_2), E_{\\text{ff}}(p_2), \\dots]$, where each entry is a floating-point number. Angles must be in radians, and no physical unit is required beyond the dimensionless specification $a=1$.",
            "solution": "The analytical solution is found by decomposing the total acoustic pressure $p_{\\text{tot}}$ into an incident field $p_{\\text{inc}}$ and a scattered field $p_{\\text{sca}}$, such that $p_{\\text{tot}} = p_{\\text{inc}} + p_{\\text{sca}}$. Both fields must satisfy the Helmholtz equation. The incident plane wave, $p_{\\text{inc}} = e^{ikz}$, has a standard expansion in spherical coordinates:\n$$p_{\\text{inc}}(r, \\theta) = \\sum_{n=0}^{\\infty} i^n (2n+1) j_n(k r) P_n(\\cos\\theta)$$\nThe scattered field $p_{\\text{sca}}$ must be an outgoing wave, so it is expanded using spherical Hankel functions of the first kind, $h_n^{(1)}$:\n$$p_{\\text{sca}}(r, \\theta) = \\sum_{n=0}^{\\infty} c_n h_n^{(1)}(k r) P_n(\\cos\\theta)$$\nThe total field is the sum $p_{\\text{tot}} = p_{\\text{inc}} + p_{\\text{sca}}$. Comparing this sum to the form given in the problem statement reveals the relationship between the coefficients: $c_n = i^n(2n+1)A_n$. These coefficients are determined by applying the Neumann boundary condition for a rigid sphere, $\\frac{\\partial p_{\\text{tot}}}{\\partial n}\\Big|_{r=a} = \\frac{\\partial p_{\\text{tot}}}{\\partial r}\\Big|_{r=a} = 0$. Applying this condition to the series term-by-term yields:\n$$\\frac{\\partial p_{\\text{tot}}}{\\partial r}\\bigg|_{r=a} = \\sum_{n=0}^{\\infty} k \\left[ i^n (2n+1) j_n'(k a) + c_n h_n^{(1)\\prime}(k a) \\right] P_n(\\cos\\theta) = 0$$\nwhere the prime denotes differentiation with respect to the argument. Due to the orthogonality of Legendre polynomials, the term in brackets must be zero for each $n$:\n$$i^n (2n+1) j_n'(k a) + c_n h_n^{(1)\\prime}(k a) = 0 \\implies c_n = -i^n (2n+1) \\frac{j_n'(k a)}{h_n^{(1)\\prime}(k a)}$$\nSubstituting $c_n = i^n(2n+1)A_n$ gives the expression for $A_n$:\n$$A_n = - \\frac{j_n'(k a)}{h_n^{(1)\\prime}(k a)}$$\nThe far-field scattering amplitude $f(\\theta)$ is derived from the asymptotic behavior of the scattered field, $p_{\\text{sca}}(r,\\theta) \\sim \\frac{e^{i k r}}{r} f(\\theta)$ as $r \\to \\infty$. Using the large-argument asymptotic form of the spherical Hankel function, $h_n^{(1)}(z) \\sim \\frac{1}{z}(-i)^{n+1}e^{iz}$, we find:\n$$p_{\\text{sca}}(r, \\theta) \\sim \\frac{e^{ikr}}{r} \\left[ \\frac{-i}{k} \\sum_{n=0}^{\\infty} c_n (-i)^n P_n(\\cos\\theta) \\right]$$\nBy comparison, $f(\\theta)$ is the term in brackets. Substituting $c_n = i^n(2n+1)A_n$ and simplifying gives the final expression:\n$$f(\\theta) = -\\frac{i}{k} \\sum_{n=0}^{\\infty} (2n+1) A_n P_n(\\cos\\theta)$$\nThe numerical task requires implementing these series solutions. The coefficients $A_n$ are computed first. Then, the truncated series for the total field $p_{\\text{tot}}^{(p)}$ and far-field amplitude $f^{(p)}$ are evaluated. This requires functions for spherical Bessel and Hankel functions and their derivatives, available in standard scientific libraries. A reference solution is computed using a sufficiently large truncation index, $N_{\\text{ref}}$, to ensure convergence. For each test case $(ka, p)$, the reference solution (truncated at $N_{\\text{ref}}$) and the approximate solution (truncated at $p$) are calculated. Finally, the relative $L^2$ errors are computed over the specified sample points for both near and far fields using the provided formulas.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import spherical_jn, spherical_yn, lpn\n\ndef compute_coefficients(ka, n_max):\n    \"\"\"\n    Computes scattering coefficients A_n for a rigid sphere.\n    \n    Args:\n        ka (float): The dimensionless wavenumber.\n        n_max (int): The maximum order to compute.\n        \n    Returns:\n        numpy.ndarray: Complex-valued coefficients A_n for n=0 to n_max.\n    \"\"\"\n    n = np.arange(n_max + 1)\n    \n    # Calculate derivatives of spherical Bessel functions j_n(ka) and y_n(ka)\n    jn_p_ka = spherical_jn(n, ka, derivative=True)\n    yn_p_ka = spherical_yn(n, ka, derivative=True)\n    \n    # Derivative of spherical Hankel function h_n^(1)'(z) = j_n'(z) + i*y_n'(z)\n    hn1_p_ka = jn_p_ka + 1j * yn_p_ka\n    \n    # Formula for A_n for a rigid sphere\n    # Handle potential division by zero, though unlikely for a physical ka > 0\n    with np.errstate(divide='ignore', invalid='ignore'):\n        A_n = -jn_p_ka / hn1_p_ka\n    # Replace any NaN/inf that might arise from 0/0\n    A_n = np.nan_to_num(A_n, nan=0.0, posinf=0.0, neginf=0.0)\n    \n    return A_n\n\ndef evaluate_series(ka, r_val, theta_vals, p_trunc, A_n_full):\n    \"\"\"\n    Evaluates the truncated series for total pressure and far-field amplitude.\n    \n    Args:\n        ka (float): The dimensionless wavenumber.\n        r_val (float): The radial distance for evaluation.\n        theta_vals (numpy.ndarray): Array of polar angles in radians.\n        p_trunc (int): The truncation index for the series.\n        A_n_full (numpy.ndarray): Precomputed coefficients up to a max order.\n        \n    Returns:\n        tuple[numpy.ndarray, numpy.ndarray]: Total pressure and far-field amplitude.\n    \"\"\"\n    if p_trunc  0:\n        return np.zeros_like(theta_vals, dtype=complex), np.zeros_like(theta_vals, dtype=complex)\n        \n    n = np.arange(p_trunc + 1)\n    A_n = A_n_full[:p_trunc + 1]\n    \n    cos_theta = np.cos(theta_vals)\n    \n    # lpn returns a tuple (Pn, Pn_derivatives). Pn has shape (p_trunc+1, len(theta_vals))\n    Pn_cos_theta, _ = lpn(p_trunc, cos_theta)\n    \n    # --- Total pressure p_tot calculation ---\n    a = 1.0\n    k = ka / a\n    kr = k * r_val\n    \n    jn_kr = spherical_jn(n, kr)\n    yn_kr = spherical_yn(n, kr)\n    hn1_kr = jn_kr + 1j * yn_kr\n    \n    # Coefficients for the p_tot sum, shape (p_trunc+1,)\n    ptot_coeffs = (1j**n) * (2*n + 1) * (jn_kr + A_n * hn1_kr)\n    \n    # Sum over n using matrix multiplication: p_total[m] = sum_n(coeffs[n] * P_nm)\n    p_total = ptot_coeffs @ Pn_cos_theta\n    \n    # --- Far-field amplitude f calculation ---\n    # Coefficients for the f sum, shape (p_trunc+1,)\n    f_coeffs = (-1j / ka) * (2*n + 1) * A_n\n    \n    # Sum over n\n    f_amplitude = f_coeffs @ Pn_cos_theta\n    \n    return p_total, f_amplitude\n\ndef solve():\n    \"\"\"\n    Main function to execute the validation test cases.\n    \"\"\"\n    # Define problem parameters\n    a = 1.0\n    delta = 0.05\n    r_nf = a * (1 + delta)\n    N_ref = 40  # Reference truncation index, sufficiently large\n    \n    # Define sample angles\n    theta_nf = np.linspace(0, np.pi, 16)\n    theta_ff = np.array([0, np.pi/3, np.pi/2, 2*np.pi/3, np.pi])\n    \n    # Define test cases\n    test_cases = [\n        (1.0, 0),\n        (1.0, 5),\n        (5.0, 5),\n        (5.0, 15),\n    ]\n    \n    results = []\n    A_n_cache = {}\n\n    for ka, p in test_cases:\n        # Pre-compute and cache A_n coefficients up to the reference order\n        if ka not in A_n_cache:\n            A_n_cache[ka] = compute_coefficients(ka, N_ref)\n        \n        A_n_full = A_n_cache[ka]\n        \n        # --- Reference solution (truncated at N_ref) ---\n        p_tot_ref_nf, _ = evaluate_series(ka, r_nf, theta_nf, N_ref, A_n_full)\n        _, f_ref_ff = evaluate_series(ka, r_nf, theta_ff, N_ref, A_n_full)\n        \n        # --- Truncated solution (truncated at p) ---\n        p_tot_p_nf, _ = evaluate_series(ka, r_nf, theta_nf, p, A_n_full)\n        _, f_p_ff = evaluate_series(ka, r_nf, theta_ff, p, A_n_full)\n        \n        # --- Compute relative errors ---\n        \n        # Near-field error E_nf\n        norm_p_diff = np.linalg.norm(p_tot_p_nf - p_tot_ref_nf)\n        norm_p_ref = np.linalg.norm(p_tot_ref_nf)\n        E_nf = norm_p_diff / norm_p_ref if norm_p_ref > 0 else 0.0\n            \n        # Far-field error E_ff\n        norm_f_diff = np.linalg.norm(f_p_ff - f_ref_ff)\n        norm_f_ref = np.linalg.norm(f_ref_ff)\n        E_ff = norm_f_diff / norm_f_ref if norm_f_ref > 0 else 0.0\n\n        results.extend([E_nf, E_ff])\n        \n    print(f\"[{','.join(f'{r:.7e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}