{
    "hands_on_practices": [
        {
            "introduction": "在深入研究复杂的多重网格方法之前，我们首先需要理解为什么标准方法在处理不定问题（如亥姆霍兹方程）时会失效。本练习将引导你使用局部傅里叶分析（Local Fourier Analysis, LFA）这一基本理论工具，来定量计算一个标准松弛法（加权雅可比法）的收敛因子。通过这个计算，你将亲眼见证并证明为什么简单的多重网格平滑器无法有效地衰减亥姆霍兹方程中的误差。",
            "id": "4130263",
            "problem": "考虑自由空间中的一维时谐线性声学问题，其频域压力满足亥姆霍兹方程 $-\\frac{\\mathrm{d}^{2}u}{\\mathrm{d}x^{2}} - k^{2} u = f$。该方程由线性状态下的质量守恒和动量守恒导出，其中 $u$ 是声压幅值，$k$ 是波数，$f$ 是源项。使用二阶中心差分对二阶导数进行近似，在间距为 $h$ 的无限均匀网格上对该算子进行离散化。将得到的离散算子记为 $A_{h}$，其作用于网格函数 $\\{u_{i}\\}_{i \\in \\mathbb{Z}}$。假设双网格方法使用权重为 $\\omega = \\frac{2}{3}$ 的加权雅可比法进行一次预平滑和一次后平滑，并采用理想的粗网格校正，该校正能精确消除细网格角度 $|\\theta| \\leq \\frac{\\pi}{2}$ 的傅里叶模式所张成的子空间中的低频误差分量。在局部傅里叶分析（LFA）框架下（局部傅里叶分析使用平面波误差模式和算子符号来预测多重网格性能），最坏情况下的双网格收敛因子定义为单步加权雅可比平滑符号的模平方在高频集 $\\frac{\\pi}{2} \\leq \\theta \\leq \\pi$ 上的上确界。\n\n从以下基础出发：\n- 二阶导数的二阶中心有限差分近似。\n- 亥姆霍兹算子及其在无限均匀网格上的离散符号的定义。\n- 从对角分裂 $A_{h} = D - (L + U)$ 和平滑算子 $S = I - \\omega D^{-1} A_{h}$ 导出的加权雅可比平滑形式。\n\n用无量纲参数 $q = k h$ 推导出离散亥姆霍兹符号 $a(\\theta)$、对角符号 $d$ 和加权雅可比平滑符号 $s(\\theta)$。然后，使用上述理想化的双网格LFA假设，将最坏情况下的双网格收敛因子表示为 $\\sup_{\\theta \\in [\\pi/2,\\pi]} |s(\\theta)|^{2}$。对于指定的参数 $q = 1.6$ 和 $\\omega = \\frac{2}{3}$，精确计算此上确界的值。\n\n你的最终答案必须是单个最坏情况下的双网格收敛因子，表示为一个精确的有理数。不需要四舍五入，也不需要单位。",
            "solution": "在进行求解之前，对问题进行验证。\n\n### 步骤 1：提取已知条件\n-   **控制方程**：一维时谐线性声学压力 $u$ 满足亥姆霍兹方程：$-\\frac{\\mathrm{d}^{2}u}{\\mathrm{d}x^{2}} - k^{2} u = f$。\n-   **离散化**：使用二阶中心差分近似二阶导数，在间距为 $h$ 的无限均匀网格上对算子进行离散化。\n-   **离散算子**：离散算子记为 $A_h$。\n-   **双网格方法**：该方法采用一次预平滑和一次后平滑步骤。\n-   **平滑器**：平滑器为加权雅可比法，权重为 $\\omega = \\frac{2}{3}$。\n-   **平滑算子**：平滑算子定义为 $S = I - \\omega D^{-1} A_{h}$，由分裂 $A_h = D - (L+U)$ 导出。\n-   **粗网格校正**：假设校正是理想的，能精确消除细网格角度 $|\\theta| \\leq \\frac{\\pi}{2}$ 的傅里叶模式的误差分量。\n-   **分析框架**：使用局部傅里叶分析（LFA）。\n-   **待计算量**：最坏情况下的双网格收敛因子定义为 $\\sup_{\\theta \\in [\\pi/2,\\pi]} |s(\\theta)|^{2}$，其中 $s(\\theta)$ 是单步加权雅可比平滑符号。\n-   **参数**：无量纲参数为 $q = kh$，其指定值为 $q=1.6$。\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **科学依据**：该问题基于波物理学的基石——亥姆霍兹方程，并采用标准的数值方法（有限差分、多重网格、加权雅可比法）和分析工具（局部傅里叶分析）。整个框架在科学上和数学上都是合理的。\n-   **适定性**：该问题是适定的。它要求基于一套完整的初始数据、参数和定义，计算一个特定的、定义明确的量（最坏情况下的平滑因子）。\n-   **客观性**：问题以精确、客观、形式化的数学语言陈述，没有任何主观性或模糊性。\n-   **完整性和一致性**：问题提供了所有必要的信息：微分方程、离散化方案、多重网格组件（平滑器、权重、理想校正）、分析方法（LFA）以及所有必需的数值参数（$\\omega$，$q$）。信息之间没有矛盾。\n\n### 步骤 3：结论与行动\n问题是有效的。将提供一个完整的、有理有据的解法。\n\n### 解法推导\n求解过程首先推导离散亥姆霍兹算子的符号，然后是加权雅可比平滑器的符号，最后计算其模平方在指定频率范围内的上确界。\n\n一维亥姆霍兹算子由 $A = -\\frac{\\mathrm{d}^2}{\\mathrm{d}x^2} - k^2$ 给出。\n在间距为 $h$ 的均匀网格上，对二阶导数使用二阶中心有限差分，离散算子 $A_h$ 作用于网格点 $i$ 上的网格函数 $\\{u_i\\}_{i \\in \\mathbb{Z}}$ 为：\n$$ (A_h u)_i = -\\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2} - k^2 u_i $$\n我们可以将其重写为应用于点 $i$ 的模板：\n$$ (A_h u)_i = \\frac{1}{h^2} \\left( -u_{i+1} + (2 - k^2 h^2)u_i - u_{i-1} \\right) $$\n\n为了进行局部傅里叶分析（LFA），我们分析算子 $A_h$ 对傅里叶模式 $u_j = \\exp(ij\\theta)$ 的作用，其中 $\\theta \\in [-\\pi, \\pi]$ 是傅里叶角。算子 $A_h$ 的符号 $a(\\theta)$ 由关系式 $(A_h \\exp(ij\\theta))_j = a(\\theta) \\exp(ij\\theta)$ 定义。\n$$ a(\\theta) = \\frac{1}{h^2} \\left( -e^{i\\theta} + (2 - k^2 h^2) - e^{-i\\theta} \\right) $$\n使用欧拉公式 $e^{i\\theta} + e^{-i\\theta} = 2\\cos(\\theta)$，符号变为：\n$$ a(\\theta) = \\frac{1}{h^2} \\left( 2 - 2\\cos(\\theta) - k^2 h^2 \\right) $$\n使用半角恒等式 $1 - \\cos(\\theta) = 2\\sin^2(\\frac{\\theta}{2})$ 和给定的无量纲参数 $q=kh$：\n$$ a(\\theta) = \\frac{1}{h^2} \\left( 4\\sin^2\\left(\\frac{\\theta}{2}\\right) - q^2 \\right) $$\n这就是离散亥姆霍兹算子 $A_h$ 的符号。\n\n加权雅可比法基于分裂 $A_h = D - (L+U)$，其中 $D$ 是 $A_h$ 的对角部分。从模板可知，对角算子 $D$ 由 $(Du)_i = \\frac{1}{h^2}(2 - q^2)u_i$ 给出。$D$ 的符号，记为 $d$，是常数系数：\n$$ d = \\frac{1}{h^2}(2 - q^2) $$\n\n加权雅可比平滑算子是 $S = I - \\omega D^{-1} A_h$。它的符号 $s(\\theta)$ 由下式给出：\n$$ s(\\theta) = 1 - \\omega \\frac{a(\\theta)}{d} $$\n代入 $a(\\theta)$ 和 $d$ 的表达式：\n$$ s(\\theta) = 1 - \\omega \\frac{\\frac{1}{h^2} \\left( 4\\sin^2\\left(\\frac{\\theta}{2}\\right) - q^2 \\right)}{\\frac{1}{h^2}(2 - q^2)} = 1 - \\omega \\frac{4\\sin^2\\left(\\frac{\\theta}{2}\\right) - q^2}{2 - q^2} $$\n这是平滑符号的一般表达式。\n\n我们给定了具体参数 $\\omega = \\frac{2}{3}$ 和 $q = 1.6$。我们将使用精确有理数运算。\n$q = 1.6 = \\frac{16}{10} = \\frac{8}{5}$。\n$q^2 = \\left(\\frac{8}{5}\\right)^2 = \\frac{64}{25}$。\n分数中的分母是 $2 - q^2 = 2 - \\frac{64}{25} = \\frac{50 - 64}{25} = -\\frac{14}{25}$。\n将这些值代入 $s(\\theta)$ 的表达式：\n$$ s(\\theta) = 1 - \\frac{2}{3} \\frac{4\\sin^2\\left(\\frac{\\theta}{2}\\right) - \\frac{64}{25}}{-\\frac{14}{25}} $$\n$$ s(\\theta) = 1 + \\left(\\frac{2}{3}\\right) \\left(\\frac{25}{14}\\right) \\left(4\\sin^2\\left(\\frac{\\theta}{2}\\right) - \\frac{64}{25}\\right) $$\n$$ s(\\theta) = 1 + \\frac{25}{21} \\left(4\\sin^2\\left(\\frac{\\theta}{2}\\right) - \\frac{64}{25}\\right) $$\n$$ s(\\theta) = 1 + \\frac{100}{21}\\sin^2\\left(\\frac{\\theta}{2}\\right) - \\frac{25}{21}\\frac{64}{25} $$\n$$ s(\\theta) = 1 + \\frac{100}{21}\\sin^2\\left(\\frac{\\theta}{2}\\right) - \\frac{64}{21} $$\n$$ s(\\theta) = \\frac{21 - 64}{21} + \\frac{100}{21}\\sin^2\\left(\\frac{\\theta}{2}\\right) = \\frac{1}{21}\\left(100\\sin^2\\left(\\frac{\\theta}{2}\\right) - 43\\right) $$\n\n问题要求最坏情况下的双网格收敛因子，定义为 $|s(\\theta)|^2$ 在高频范围 $\\theta \\in [\\frac{\\pi}{2}, \\pi]$ 上的上确界。\n令 $x = \\sin^2(\\frac{\\theta}{2})$。当 $\\theta$ 在区间 $[\\frac{\\pi}{2}, \\pi]$ 内变化时，其参数 $\\frac{\\theta}{2}$ 在 $[\\frac{\\pi}{4}, \\frac{\\pi}{2}]$ 内变化。\n在此区间上，$\\sin(\\frac{\\theta}{2})$ 是一个单调递增函数。\n最小值为 $\\sin(\\frac{\\pi}{4}) = \\frac{\\sqrt{2}}{2}$，最大值为 $\\sin(\\frac{\\pi}{2}) = 1$。\n因此，变量 $x = \\sin^2(\\frac{\\theta}{2})$ 在区间 $[(\\frac{\\sqrt{2}}{2})^2, 1^2] = [\\frac{2}{4}, 1] = [\\frac{1}{2}, 1]$ 内变化。\n\n我们需要找到当 $x \\in [\\frac{1}{2}, 1]$ 时 $|f(x)|^2$ 的上确界，其中 $f(x) = \\frac{1}{21}(100x - 43)$。\n函数 $f(x)$ 是一个关于 $x$ 的线性函数，其斜率为正 ($m = \\frac{100}{21}$)。因此，它在其定义域上是单调递增的。$f(x)$ 在区间 $[\\frac{1}{2}, 1]$ 上的极值必定出现在端点处。\n当 $x = \\frac{1}{2}$ (对应于 $\\theta = \\frac{\\pi}{2}$) 时：\n$$ f\\left(\\frac{1}{2}\\right) = \\frac{1}{21}\\left(100 \\cdot \\frac{1}{2} - 43\\right) = \\frac{1}{21}(50 - 43) = \\frac{7}{21} = \\frac{1}{3} $$\n当 $x = 1$ (对应于 $\\theta = \\pi$) 时：\n$$ f(1) = \\frac{1}{21}(100 \\cdot 1 - 43) = \\frac{57}{21} = \\frac{19 \\times 3}{7 \\times 3} = \\frac{19}{7} $$\n由于 $f(x)$ 在区间 $x \\in [\\frac{1}{2}, 1]$ 上从 $\\frac{1}{3}$ 单调递增至 $\\frac{19}{7}$，该函数始终为正。因此， $|f(x)| = f(x)$。\n$|f(x)|$ 在该区间上的最大值在 $x=1$ 处取得，为 $\\frac{19}{7}$。\n所求量是 $|s(\\theta)|^2 = |f(x)|^2$ 的上确界，即 $|f(x)|$ 最大值的平方。\n$$ \\sup_{\\theta \\in [\\pi/2, \\pi]} |s(\\theta)|^2 = \\left(\\frac{19}{7}\\right)^2 = \\frac{19^2}{7^2} = \\frac{361}{49} $$\n最坏情况下的双网格收敛因子是 $\\frac{361}{49}$。",
            "answer": "$$\\boxed{\\frac{361}{49}}$$"
        },
        {
            "introduction": "在上一个练习中，我们从理论上证明了标准平滑器的失效。现在，我们将通过一个编程实践来探究其根本原因，即离散亥姆霍兹算子本身的性质。本练习要求你构建一个二维亥姆霍兹矩阵，并计算其关键属性，从而直观地理解阻抗边界条件如何导致矩阵的非正规性（non-normality）和不定性（indefiniteness），这些特性正是设计高效求解器时需要克服的主要障碍。",
            "id": "4130286",
            "problem": "考虑一个方形域上的时谐声波，其受亥姆霍兹方程控制，声压场在内部满足偏微分方程 $\\nabla^2 u + k^2 u = 0$，在边界上满足阻抗（罗宾）边界条件 $\\partial u / \\partial n + i \\beta k u = 0$。其中，$u$ 表示复值声压，$k$ 表示无量纲波数，$\\beta$ 表示无量纲阻抗因子。从均匀网格上拉普拉斯算子的二阶中心有限差分近似出发，构建一个仅作用于与内部网格点相关的未知数的方形稀疏矩阵 $A$。使用以下方法消去邻近边界的网格点上的边界值，该方法由阻抗边界条件推导得出：在边界上，外法向导数由单边有限差分近似，从而得出边界值 $u_b$ 和相邻的内部值 $u_a$ 之间的关系 $u_a = (1 + i \\beta k h) u_b$，这意味着 $u_b = u_a / (1 + i \\beta k h)$，其中 $h$ 是网格间距。在内部点的离散亥姆霍兹算子中，将域外的每个缺失邻点替换为此边界值，以获得矩阵行。对于一个因边界而有 $m$ 个缺失邻点的内部网格点，这会在对角线上增加 $m \\alpha / h^2$（其中 $\\alpha = 1 / (1 + i \\beta k h)$），同时保持与内部邻点的标准 $1 / h^2$ 耦合；基准内部模板为对角线上的 $(-4 / h^2 + k^2)$ 以及到四个轴向邻点的 $1 / h^2$。\n\n您必须：\n- 对于给定的每个维度上的内部网格点数 $N$（因此未知向量有 $n = N^2$ 个分量）、网格间距 $h = 1/(N+1)$、波数 $k$ 和阻抗因子 $\\beta$，组装矩阵 $A \\in \\mathbb{C}^{n \\times n}$。\n- 计算 $A$ 的所有特征值。\n- 使用归一化弗罗贝尼乌斯度量 $\\delta(A) = \\lVert A^* A - A A^* \\rVert_F / \\lVert A \\rVert_F^2$ 来量化 $A$ 的非正规性程度，其中 $A^*$ 表示共轭转置，$\\lVert \\cdot \\rVert_F$ 表示弗罗贝尼乌斯范数。\n- 通过计算具有负实部的特征值的比例来量化不定性，定义为 $f_- = (\\#\\{\\lambda : \\mathrm{Re}(\\lambda)  0\\})/n$。\n- 计算加权雅可比迭代矩阵 $M = I - \\omega D^{-1} A$ 在固定权重 $\\omega$ 下的谱半径，其中 $I$ 是单位矩阵，$D$ 是 $A$ 的对角部分。使用 $\\omega = 0.6$。报告 $\\rho(M)$，即 $M$ 的特征值的最大模。\n\n您的程序必须为以下参数集 $(N, k, \\beta)$ 的测试套件计算上述量：\n- 案例 1：$(N, k, \\beta) = (8, 15.0, 1.0)$。\n- 案例 2：$(N, k, \\beta) = (8, 6.0, 0.5)$。\n- 案例 3：$(N, k, \\beta) = (6, 10.0, 2.0)$。\n- 案例 4：$(N, k, \\beta) = (4, 20.0, 1.0)$。\n\n所有量均为无量纲。对于每个案例，生成一个包含三个值的列表 $[\\delta(A), f_-, \\rho(M)]$，每个值都四舍五入到六位小数。您的程序应生成单行输出，其中包含结果，格式为方括号括起来的逗号分隔的列表的列表（例如，`[[x_1,y_1,z_1],[x_2,y_2,z_2],\\ldots]`），其中每个内部列表按上述顺序对应一个案例。\n\n该问题要求仔细的构建和分析，以揭示阻抗边界条件对离散亥姆霍兹算子非正规性的影响，并将此现象与用于不定系统的多重网格方法中相关简单平滑器的行为联系起来。",
            "solution": "该问题要求构建和分析一个表示带有阻抗边界条件的离散亥姆霍兹算子的矩阵。分析内容包括量化该矩阵的非正规性、不定性，以及相关迭代求解器的收敛特性。\n\n### 1. 亥姆霍兹方程的离散化\n\n控制偏微分方程是方形域上的亥姆霍兹方程：\n$$ \\nabla^2 u + k^2 u = 0 $$\n其中 $u$ 是复值声压，$k$ 是波数。边界条件是阻抗（或罗宾）条件：\n$$ \\frac{\\partial u}{\\partial n} + i \\beta k u = 0 $$\n其中 $\\partial/\\partial n$ 是外法向导数，$\\beta$ 是阻抗因子，$i$ 是虚数单位。\n\n我们在每个维度上有 $N$ 个内部点的均匀网格上离散化该系统。网格间距为 $h = 1/(N+1)$。未知数是 $n = N^2$ 个内部网格点上的 $u$ 值。我们对拉普拉斯算子 $\\nabla^2$ 使用二阶中心差分格式。对于一个远离边界的内部点 $(i,j)$，这得到：\n$$ \\frac{u_{i-1,j} + u_{i+1,j} + u_{i,j-1} + u_{i,j+1} - 4u_{i,j}}{h^2} + k^2 u_{i,j} = 0 $$\n该方程定义了矩阵 $A$ 中对应于不与任何边界相邻的点的行的元素。对角元为 $k^2 - 4/h^2$，对应于其四个邻点的非对角元为 $1/h^2$。\n\n### 2. 边界条件的消去\n\n对于邻近边界的内部点，其一个或多个邻点位于边界上或域外。问题指定了一种消去这些边界值的方法。外法向导数由一阶单边差分近似。对于邻近边界点 $u_b$ 的内部点 $u_a$，这导致了以下关系：\n$$ u_b = \\frac{u_a}{1 + i \\beta k h} = \\alpha u_a $$\n其中 $\\alpha = 1 / (1 + i \\beta k h)$。\n\n考虑一个内部点 $u_{i,j}$，它有一个邻点（比如 $u_{i-1,j}$）在边界上。我们在中心差分公式中用 $\\alpha u_{i,j}$ 替换 $u_{i-1,j}$。上述离散方程变为：\n$$ \\frac{\\alpha u_{i,j} + u_{i+1,j} + u_{i,j-1} + u_{i,j+1} - 4u_{i,j}}{h^2} + k^2 u_{i,j} = 0 $$\n为 $u_{i,j}$ 重排这些项，我们得到：\n$$ \\left( k^2 - \\frac{4}{h^2} + \\frac{\\alpha}{h^2} \\right) u_{i,j} + \\frac{1}{h^2} (u_{i+1,j} + u_{i,j-1} + u_{i,j+1}) = 0 $$\n如前所述，一个边界邻点的影响是在矩阵行的对角元素上增加一项 $\\alpha/h^2$。如果一个内部点在边界上有 $m$ 个邻点（例如，边点 $m=1$，角点 $m=2$），那么矩阵 $A$ 中该点对应行的对角元将是：\n$$ A_{p,p} = k^2 - \\frac{4}{h^2} + \\frac{m \\alpha}{h^2} $$\n其中 $p$ 是对应于二维网格点的一维索引。与内部邻点对应的非对角元保持为 $1/h^2$。复数项 $\\alpha$ 的存在使得矩阵 $A$ 非厄米特。\n\n### 3. 矩阵属性分析\n\n构建的矩阵 $A \\in \\mathbb{C}^{n \\times n}$ 通过三个指标进行分析：\n\n1.  **非正规性程度 ($\\delta(A)$)**：如果一个矩阵 $A$ 与其共轭转置 $A^*$ 可交换，即 $A A^* = A^* A$，则该矩阵是正规的。非正规性程度通过对易子的归一化弗罗贝尼乌斯范数量化：\n    $$ \\delta(A) = \\frac{\\lVert A^* A - A A^* \\rVert_F}{\\lVert A \\rVert_F^2} $$\n    其中 $\\lVert M \\rVert_F = \\sqrt{\\sum_{i,j} |M_{ij}|^2}$ 是弗罗贝尼乌斯范数。对于正规矩阵，$\\delta(A) = 0$。预计复阻抗项会使 $A$ 非正规，导致 $\\delta(A) > 0$。\n\n2.  **不定性 ($f_-$)**：亥姆霍兹算子是不定的，意味着其特征值可以同时具有正实部和负实部。这一性质对许多迭代求解器构成了挑战。我们通过具有负实部的特征值的比例来量化不定性：\n    $$ f_- = \\frac{|\\{\\lambda_j : \\mathrm{Re}(\\lambda_j)  0\\}|}{n} $$\n    其中 $\\lambda_j$ 是 $A$ 的特征值。\n\n3.  **加权雅可比平滑器的谱半径 ($\\rho(M)$)**：加权雅可比法是求解 $A\\mathbf{x}=\\mathbf{b}$ 的一种简单迭代格式（常在多重网格方法中用作平滑器）。迭代过程由 $\\mathbf{x}^{(k+1)} = (I - \\omega D^{-1} A)\\mathbf{x}^{(k)} + \\omega D^{-1}\\mathbf{b}$ 给出，其中 $D$ 是 $A$ 的对角部分，$\\omega$ 是松弛权重。该方法的收敛性由迭代矩阵 $M = I - \\omega D^{-1} A$ 的谱半径决定：\n    $$ \\rho(M) = \\max_j |\\lambda_j(M)| $$\n    当且仅当 $\\rho(M)  1$ 时，迭代收敛。我们为固定的权重 $\\omega = 0.6$ 计算此值，以评估这种基本平滑器的性能。\n\n### 4. 计算步骤\n\n对每个参数集 $(N, k, \\beta)$，执行以下步骤：\n1.  计算常数：$n=N^2$, $h=1/(N+1)$ 和 $\\alpha = 1/(1+i\\beta k h)$。\n2.  通过遍历 $N^2$ 个内部网格点中的每一个来组装 $n \\times n$ 复矩阵 $A$。对每个点，确定其邻点和边界邻接数 $m$，以构建 $A$ 的相应行。\n3.  使用标准数值库函数计算 $A$ 的特征值。\n4.  根据其定义计算 $\\delta(A)$, $f_-$ 和 $\\rho(M)$。\n5.  存储三个结果值，四舍五入到六位小数，以备最终输出格式化。\n对问题描述中提供的所有测试案例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test cases.\n    It assembles the discrete Helmholtz operator matrix, then computes\n    its non-normality, indefiniteness, and the spectral radius of the\n    weighted Jacobi iteration matrix.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, k, beta)\n        (8, 15.0, 1.0),\n        (8, 6.0, 0.5),\n        (6, 10.0, 2.0),\n        (4, 20.0, 1.0),\n    ]\n\n    results = []\n    for N, k, beta in test_cases:\n        # Step 1: Initialize parameters\n        n = N * N\n        h = 1.0 / (N + 1)\n        k_sq = k * k\n        h_sq = h * h\n        omega = 0.6\n        alpha = 1.0 / (1.0 + 1j * beta * k * h)\n\n        # Step 2: Assemble the matrix A\n        A = np.zeros((n, n), dtype=np.complex128)\n        \n        # Base values for diagonal and off-diagonal elements from FD stencil\n        diag_base = k_sq - 4.0 / h_sq\n        off_diag = 1.0 / h_sq\n\n        # Iterate over each interior grid point (i,j)\n        # i, j are 1-based grid indices from 1 to N\n        for i in range(1, N + 1):\n            for j in range(1, N + 1):\n                # Map 2D grid index (i,j) to 1D matrix index p (0-based)\n                p = (i - 1) * N + (j - 1)\n\n                # Set the base diagonal value\n                A[p, p] = diag_base\n                \n                # m counts the number of \"missing\" neighbors (on the boundary)\n                m = 0\n\n                # Check neighbor (i, j-1) - left\n                if j > 1:\n                    q = p - 1\n                    A[p, q] = off_diag\n                else:\n                    m += 1\n\n                # Check neighbor (i, j+1) - right\n                if j  N:\n                    q = p + 1\n                    A[p, q] = off_diag\n                else:\n                    m += 1\n\n                # Check neighbor (i-1, j) - up\n                if i > 1:\n                    q = p - N\n                    A[p, q] = off_diag\n                else:\n                    m += 1\n\n                # Check neighbor (i+1, j) - down\n                if i  N:\n                    q = p + N\n                    A[p, q] = off_diag\n                else:\n                    m += 1\n                \n                # Add the boundary condition contribution to the diagonal\n                if m > 0:\n                    A[p, p] += m * alpha / h_sq\n\n        # Step 3: Compute the required quantities\n        \n        # Eigenvalues of A\n        eig_A = np.linalg.eigvals(A)\n\n        # Departure from normality, delta(A)\n        A_H = A.conj().T\n        commutator = A_H @ A - A @ A_H\n        norm_commutator_F = np.linalg.norm(commutator, 'fro')\n        norm_A_F_sq = np.linalg.norm(A, 'fro')**2\n        delta_A = 0.0 if norm_A_F_sq == 0 else norm_commutator_F / norm_A_F_sq\n\n        # Indefiniteness fraction, f_minus\n        num_neg_real = np.sum(np.real(eig_A)  0)\n        f_minus = num_neg_real / n\n\n        # Spectral radius of weighted Jacobi iteration matrix, rho(M)\n        D_diag = np.diag(A)\n        # M = I - omega * D_inv * A\n        # To avoid creating full D_inv matrix, use broadcasting with its diagonal\n        M = np.identity(n, dtype=np.complex128) - omega * (A / D_diag[:, np.newaxis])\n        eig_M = np.linalg.eigvals(M)\n        rho_M = np.max(np.abs(eig_M))\n\n        # Step 4: Collect and round the results for the current case\n        case_results = [\n            round(delta_A, 6),\n            round(f_minus, 6),\n            round(rho_M, 6)\n        ]\n        results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # e.g., [[val1,val2,val3],[val4,val5,val6]]\n    list_of_strings = [f\"[{','.join(map(str, res))}]\" for res in results]\n    final_output_str = f\"[{','.join(list_of_strings)}]\"\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "理解了问题的本质之后，我们便可以着手设计更高级的解决方案。本练习将引导你超越简单的松弛法，构建一个基于切比雪夫多项式（Chebyshev polynomial）的定制化平滑器。通过这个实践，你将学会如何针对算子谱的特定分布（一个环形区域）来设计高效的平滑器，这是解决不定系统问题的一种强大而经典的技术。",
            "id": "4130235",
            "problem": "考虑时谐线性声学，其中声压场满足由声波方程导出的亥姆霍兹方程。从声波方程 $\\,\\partial_t^2 p - c^2 \\Delta p = s\\,$ 出发，并假设时谐场具有 $\\,p(\\mathbf{x},t) = \\Re\\{u(\\mathbf{x}) e^{-i \\omega t}\\}\\,$ 的形式，控制方程可简化为亥姆霍兹方程 $\\,(-\\Delta - k^2) u = f\\,$，其中 $\\,k = \\omega/c\\,$ 是波数，$\\,\\Delta\\,$ 是拉普拉斯算子，$\\,f\\,$ 是源项。在带有合适边界条件（例如，吸收层）的网格上进行离散化后，得到的解 $\\,\\mathbf{u}\\,$ 的线性系统为 $\\,A \\mathbf{u} = \\mathbf{f}\\,$，其中 $\\,A \\in \\mathbb{C}^{N \\times N}\\,$ 是不定的，且可能非正规。在计算声学的许多实际配置中，$\\,A\\,$ 的谱可以很好地近似为复平面上的一个环形区域 $\\,\\mathcal{A} = \\{\\lambda \\in \\mathbb{C} : r_{\\min} \\le |\\lambda| \\le r_{\\max}\\}\\,$，其中 $\\,r_{\\min}  0\\,$ 且 $\\,r_{\\max}  r_{\\min}\\,$。\n\n为了为此类不定系统构建一个鲁棒的多重网格光滑子，可以作用于正规方程 $\\,H = A^* A\\,$。在假设 $\\,A\\,$ 在相关子空间上是满秩的前提下，该方程是厄米半正定的。如果 $\\,A\\,$ 的谱位于环形区域 $\\,\\mathcal{A}\\,$ 内，那么 $\\,H\\,$ 的谱则位于实数区间 $\\,[\\alpha,\\beta]\\,$ 内，其中 $\\,\\alpha = r_{\\min}^2\\,$ 且 $\\,\\beta = r_{\\max}^2\\,$。然后可以设计一个多项式光滑子 $\\,p_n(H)\\,$，其中 $\\,p_n\\,$ 是一个 $n$ 次多项式，其选择旨在减小与特征值 $\\,\\mu \\in [\\alpha,\\beta]\\,$ 相关的误差分量。\n\n您的任务是构造一个复值 Chebyshev 多项式光滑子 $\\,p_n(H)\\,$，它能在谱区间 $\\,\\mu \\in [\\alpha,\\beta]\\,$ 上提供保证的衰减。具体来说，您必须：\n\n1. 从第一类 Chebyshev 多项式 $\\,T_n(x)\\,$ 的良好测试性质出发（该多项式在区间 $\\,[-1,1]\\,$ 上最小化最大偏差），并从 $\\,A\\,$ 的环形谱模型引起的 $\\,H\\,$ 到实数区间 $\\,[\\alpha,\\beta]\\,$ 的谱映射出发。仅使用这些基本依据，推导出一个关于标量变量 $\\,\\mu\\,$ 的多项式 $\\,p_n(\\mu)\\,$，使得在归一化条件 $\\,p_n(0) = 1\\,$ 的约束下，$\\,\\max_{\\mu \\in [\\alpha,\\beta]} |p_n(\\mu)|\\,$ 最小化。将 $\\,p_n(\\mu)\\,$ 明确表示为 $\\,\\mu\\,$ 的幂的多项式形式，即 $\\,p_n(\\mu) = \\sum_{j=0}^{n} c_j \\mu^j\\,$，并阐明为强制 $\\,p_n(0) = 1\\,$ 所需的归一化。\n\n2. 基于 Chebyshev 多项式的极小化极大性质以及一个将谱区间 $\\,\\mu \\in [\\alpha,\\beta]\\,$ 映射到 $\\,x \\in [-1,1]\\,$ 的合适仿射映射，推导出一个关于最小次数 $\\,n\\,$ 的明确判据，以保证目标衰减因子 $\\,\\delta \\in (0,1)\\,$，即 $\\,\\max_{\\mu \\in [\\alpha,\\beta]} |p_n(\\mu)| \\le \\delta\\,$。您的推导必须基于第一性原理以及关于自变量 $\\,x  1\\,$ 时 $\\,T_n(x)\\,$ 的良好测试事实。\n\n3. 实现一个完整的、可运行的程序，该程序：\n   - 对下面的每个测试用例，计算保证目标衰减 $\\,\\delta\\,$ 的最小多项式次数 $\\,n\\,$。\n   - 构造 $\\,p_n(\\mu)\\,$ 以 $\\,\\mu\\,$ 的幂表示的归一化多项式系数 $\\,\\{c_j\\}_{j=0}^n\\,$。\n   - 将所有测试用例的结果作为单行返回，格式严格遵循用方括号括起来的逗号分隔列表，其中每个测试用例的结果形式为 $\\, [n,[c_0,c_1,\\dots,c_n]]\\,$。\n\n您必须使用 $\\,\\mu\\,$ 的幂展开和从 $\\,\\mu$ 到 Chebyshev 自变量的仿射映射来实现多项式构造，并且必须通过适当的归一化来强制 $\\,p_n(0) = 1\\,$。\n\n测试套件：\n- 用例 1 (正常路径)：$\\,r_{\\min} = 10.0\\,$, $\\,r_{\\max} = 40.0\\,$, $\\,\\delta = 0.1\\,$.\n- 用例 2 (窄环形区域)：$\\,r_{\\min} = 20.0\\,$, $\\,r_{\\max} = 21.0\\,$, $\\,\\delta = 10^{-3}\\,$.\n- 用例 3 (宽环形区域)：$\\,r_{\\min} = 5.0\\,$, $\\,r_{\\max} = 100.0\\,$, $\\,\\delta = 0.2\\,$.\n- 用例 4 (靠近原点但不包括零)：$\\,r_{\\min} = 0.5\\,$, $\\,r_{\\max} = 2.0\\,$, $\\,\\delta = 10^{-2}\\,$.\n- 用例 5 (严格衰减)：$\\,r_{\\min} = 15.0\\,$, $\\,r_{\\max} = 25.0\\,$, $\\,\\delta = 10^{-4}\\,$.\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个元素对应一个测试用例，形式为 $\\, [n,[c_0,c_1,\\dots,c_n]]\\,$。例如：\n$\\,[[n_1,[c_{0,1},\\dots,c_{n_1,1}]],[n_2,[c_{0,2},\\dots,c_{n_2,2}]],\\dots]\\,$.\n所有数字必须以标准十进制表示法表示。本问题不要求任何物理单位或角度，所有数值输出必须是不带百分号的实数。",
            "solution": "该问题要求为时谐声波方程离散化所产生的不定线性系统设计一个多项式光滑子。该光滑子基于 Chebyshev 多项式，并针对矩阵 $\\,A\\,$ 的谱位于复平面环形区域 $\\,\\mathcal{A} = \\{\\lambda \\in \\mathbb{C} : r_{\\min} \\le |\\lambda| \\le r_{\\max}\\}\\,$ 内的系统进行了优化。该光滑子作用于正规方程矩阵 $\\,H = A^* A\\,$，其谱包含在实数区间 $\\,[\\alpha, \\beta]\\,$ 内，其中 $\\,\\alpha = r_{\\min}^2\\,$ 且 $\\,\\beta = r_{\\max}^2\\,$。\n\n我们的任务是推导并实现一个 $n$ 次多项式 $\\,p_n(\\mu)\\,$，它满足归一化条件 $\\,p_n(0) = 1\\,$，并在谱区间 $\\,[\\alpha, \\beta]\\,$ 上最小化其最大绝对值。这是一个经典的极小化极大逼近问题。解决方案基于第一类 Chebyshev 多项式 $\\,T_n(x)\\,$ 的性质。\n\n### 第 1 部分：最优多项式的推导\n\n目标是找到一个 $n$ 次多项式 $\\,p_n(\\mu)\\,$，在约束条件 $\\,p_n(0) = 1\\,$ 下最小化 $\\,\\max_{\\mu \\in [\\alpha, \\beta]} |p_n(\\mu)|\\,$。\n\n众所周知，Chebyshev 多项式 $\\,T_n(x)\\,$ 是一个相关极小化极大问题的唯一解：在所有 $n$ 次首一多项式中，$\\,2^{1-n} T_n(x)\\,$ 在区间 $\\,[-1, 1]\\,$ 上的最大绝对值最小。一个更普遍的性质是，对于区间 $\\,[-1, 1]\\,$ 外的任意点 $\\,x_0\\,$，多项式 $\\,q_n(x) = T_n(x) / T_n(x_0)\\,$ 在所有满足 $\\,q_n(x_0) = 1\\,$ 的 $n$ 次多项式 $\\,q_n\\,$ 中，最小化了 $\\,\\max_{x \\in [-1, 1]} |q_n(x)|\\,$。\n\n为了利用这个性质，我们首先应用一个仿射变换，将谱区间 $\\,[\\alpha, \\beta]\\,$ 映射到规范的 Chebyshev 区间 $\\,[-1, 1]\\,$：\n$$x(\\mu) = m\\mu + b$$\n我们要求 $\\,x(\\alpha) = -1\\,$ 且 $\\,x(\\beta) = 1\\,$。求解线性方程组：\n$$\n\\begin{cases}\n-1 = m\\alpha + b \\\\\n1 = m\\beta + b\n\\end{cases}\n$$\n得到映射参数：\n$$m = \\frac{2}{\\beta - \\alpha} \\quad \\text{and} \\quad b = -\\frac{\\beta + \\alpha}{\\beta - \\alpha}$$\n归一化约束施加在 $\\,\\mu = 0\\,$ 处。我们将此点映射到 $\\,x\\,$ 坐标：\n$$x_0 = x(0) = b = -\\frac{\\beta + \\alpha}{\\beta - \\alpha}$$\n由于问题陈述 $\\,r_{\\min}  0\\,$，我们有 $\\,\\alpha = r_{\\min}^2  0\\,$。因此，$\\,\\beta  \\alpha  0\\,$，这意味着 $\\,\\beta + \\alpha  \\beta - \\alpha  0\\,$。于是，$\\,x_0  -1\\,$，所以归一化点位于区间 $\\,[-1, 1]\\,$ 之外。\n\n在变换后的坐标中，最优多项式为 $\\,q_n(x) = T_n(x) / T_n(x_0)\\,$。用原始变量 $\\,\\mu\\,$ 表示，解为：\n$$p_n(\\mu) = \\frac{T_n(x(\\mu))}{T_n(x_0)} = \\frac{T_n\\left(\\frac{2\\mu - (\\alpha + \\beta)}{\\beta - \\alpha}\\right)}{T_n\\left(-\\frac{\\beta + \\alpha}{\\beta - \\alpha}\\right)}$$\n这个多项式满足 $\\,p_n(0) = T_n(x(0))/T_n(x_0) = 1\\,$。因此，多项式 $\\,p_n(\\mu) = \\sum_{j=0}^n c_j \\mu^j\\,$ 的常数项为 $\\,c_0 = 1\\,$。\n\n### 第 2 部分：目标衰减的最小次数\n\n我们需要找到保证衰减因子为 $\\,\\delta \\in (0, 1)\\,$ 的最小次数 $\\,n\\,$。这意味着我们需要：\n$$\\max_{\\mu \\in [\\alpha, \\beta]} |p_n(\\mu)| \\le \\delta$$\n对于 $\\,\\mu \\in [\\alpha, \\beta]\\,$，变量 $\\,x(\\mu)\\,$ 在 $\\,[-1, 1]\\,$ 区间内。在此区间内，$\\,T_n(x)\\,$ 的最大绝对值为 $\\,1\\,$。因此，$\\,|p_n(\\mu)|\\,$ 在 $\\,[\\alpha, \\beta]\\,$ 上的最大值为：\n$$\\max_{\\mu \\in [\\alpha, \\beta]} |p_n(\\mu)| = \\frac{\\max_{x \\in [-1, 1]} |T_n(x)|}{|T_n(x_0)|} = \\frac{1}{|T_n(x_0)|}$$\n条件变为 $\\,1 / |T_n(x_0)| \\le \\delta\\,$，或 $\\,|T_n(x_0)| \\ge 1/\\delta\\,$。\n\n令 $\\,\\kappa = -x_0 = \\frac{\\beta + \\alpha}{\\beta - \\alpha}\\,$。由于 $\\,\\kappa  1\\,$，我们对 $\\,x  1\\,$ 使用恒等式 $\\,T_n(x) = \\cosh(n \\operatorname{arccosh}(x))\\,$。此外，$\\,T_n(-x) = (-1)^n T_n(x)\\,$，所以 $\\,|T_n(x_0)| = |T_n(-\\kappa)| = T_n(\\kappa)\\,$。不等式为：\n$$T_n(\\kappa) \\ge 1/\\delta$$\n代入 $\\,T_n(\\kappa)\\,$ 的恒等式：\n$$\\cosh(n \\operatorname{arccosh}(\\kappa)) \\ge 1/\\delta$$\n由于 $\\,\\operatorname{arccosh}(y)\\,$ 对于 $\\,y \\ge 1\\,$ 是一个增函数，我们可以将其应用于不等式两边（注意 $\\,1/\\delta  1\\,$）：\n$$n \\operatorname{arccosh}(\\kappa) \\ge \\operatorname{arccosh}(1/\\delta)$$\n这得出了关于次数 $\\,n\\,$ 的判据：\n$$n \\ge \\frac{\\operatorname{arccosh}(1/\\delta)}{\\operatorname{arccosh}(\\kappa)}$$\n由于次数必须是整数，所需的最小次数为：\n$$n = \\left\\lceil \\frac{\\operatorname{arccosh}(1/\\delta)}{\\operatorname{arccosh}(\\kappa)} \\right\\rceil \\quad \\text{where} \\quad \\kappa = \\frac{r_{\\max}^2 + r_{\\min}^2}{r_{\\max}^2 - r_{\\min}^2}$$\n\n### 第 3 部分：多项式系数的构造\n\n为了找到 $\\,p_n(\\mu) = \\sum_{j=0}^{n} c_j \\mu^j\\,$ 的系数 $\\,\\{c_j\\}\\,$，我们首先构造未归一化多项式 $\\,P_n(\\mu) = T_n(m\\mu + b)\\,$ 的系数，其中 $\\,m = \\frac{2}{\\beta-\\alpha}\\,$ 且 $\\,b = -\\kappa\\,$。我们使用 Chebyshev 多项式的三项递推关系：\n$$T_{k+1}(x) = 2x T_k(x) - T_{k-1}(x), \\quad \\text{with } T_0(x)=1, T_1(x)=x$$\n代入 $\\,x = m\\mu+b\\,$，我们得到多项式 $\\,P_k(\\mu) = T_k(m\\mu+b)\\,$ 的递推关系：\n$$P_{k+1}(\\mu) = 2(m\\mu+b)P_k(\\mu) - P_{k-1}(\\mu)$$\n这个关系转化为多项式系数的递推关系。设 $\\,P_k(\\mu) = \\sum_{j=0}^{k} d_j^{(k)} \\mu^j\\,$。$\\,P_{k+1}(\\mu)\\,$ 的系数 $\\,\\{d_j^{(k+1)}\\}\\,$ 可以从 $\\,P_k(\\mu)\\,$ 和 $\\,P_{k-1}(\\mu)\\,$ 的系数计算得出。具体来说，我们从 $\\,P_0(\\mu) = 1\\,$（系数：$\\,[1]\\,$）和 $\\,P_1(\\mu) = m\\mu+b\\,$（系数：$\\,[b, m]\\,$）的系数向量开始，迭代计算直到 $\\,P_n(\\mu)\\,$ 的系数向量。\n\n最终系数 $\\,\\{c_j\\}\\,$ 通过将 $\\,P_n(\\mu)\\,$ 的系数除以归一化常数 $\\,C_n = T_n(b)\\,$ 的值来获得：\n$$c_j = \\frac{d_j^{(n)}}{T_n(b)}$$\n常数 $\\,T_n(b)\\,$ 可以使用递推关系的标量版本高效计算：$\\,T_{k+1}(b) = 2b T_k(b) - T_{k-1}(b)\\,$。由于 $\\,d_0^{(n)} = P_n(0) = T_n(b)\\,$，最终多项式的常数项为 $\\,c_0 = d_0^{(n)}/T_n(b) = 1\\,$，这符合归一化条件的要求。\n实现将按照算法遵循此过程。",
            "answer": "```python\nimport numpy as np\n\ndef format_num(x):\n    \"\"\"Formats a number into a standard decimal string, trimming trailing zeros.\"\"\"\n    if x == 0.0:\n        return '0.0'\n    s = \"{:.16f}\".format(x)\n    s = s.rstrip('0')\n    if s.endswith('.'):\n        s = s[:-1]\n    if s == '-0':\n        s = '0'\n    return s\n\ndef compute_chebyshev_smoother(r_min, r_max, delta):\n    \"\"\"\n    Computes the minimal degree and coefficients of the Chebyshev polynomial smoother.\n\n    Args:\n        r_min (float): The minimum radius of the spectral annulus.\n        r_max (float): The maximum radius of the spectral annulus.\n        delta (float): The target attenuation factor.\n\n    Returns:\n        tuple: A tuple containing:\n            - n (int): The minimal polynomial degree.\n            - coeffs (list): The list of polynomial coefficients [c_0, c_1, ..., c_n].\n    \"\"\"\n    alpha = r_min**2\n    beta = r_max**2\n\n    # Handle the case where the annulus is degenerate\n    if np.isclose(alpha, beta):\n        # A degree 0 polynomial p_0(mu) = 1 is sufficient.\n        # It has value 1 everywhere, attenuation is not possible unless delta = 1.\n        # Assuming delta  1 implies this case won't be a primary concern,\n        # but for robustness, return degree 0.\n        return 0, [1.0]\n\n    # Calculate kappa for the mapped interval\n    kappa = (beta + alpha) / (beta - alpha)\n\n    # Calculate the minimal degree n\n    # n = arccosh(1/delta) / arccosh(kappa)\n    # Use the identity arccosh(x) = log(x + sqrt(x^2 - 1))\n    n_float = np.arccosh(1.0 / delta) / np.arccosh(kappa)\n    n = int(np.ceil(n_float))\n\n    if n == 0:\n        return 0, [1.0]\n\n    # Parameters for the affine map x(mu) = m*mu + b\n    m = 2.0 / (beta - alpha)\n    b = -kappa\n\n    # Calculate the normalization constant C_n = T_n(b) using the recurrence\n    T_km1 = 1.0  # T_0(b)\n    T_k = b      # T_1(b)\n    for _ in range(1, n):\n        T_kp1 = 2.0 * b * T_k - T_km1\n        T_km1 = T_k\n        T_k = T_kp1\n    C_n = T_k\n\n    # Compute coefficients of the unnormalized polynomial P_n(mu) = T_n(m*mu + b)\n    # using a recurrence on the coefficient vectors.\n    P_km1_coeffs = np.array([1.0])                   # Coeffs for P_0\n    if n == 1:\n        P_n_coeffs = np.array([b, m])\n    else:\n        P_k_coeffs = np.array([b, m])                # Coeffs for P_1\n        for k in range(1, n):\n            # Recurrence: P_{k+1} = 2*(m*mu+b)*P_k - P_{k-1}\n            # Term 1: 2*b*P_k\n            term1 = 2.0 * b * P_k_coeffs\n            # Term 2: 2*m*mu*P_k (multiplication by mu is a right shift of coeffs)\n            term2 = 2.0 * m * np.pad(P_k_coeffs, (1, 0), 'constant')\n\n            # Combine terms to get P_{k+1}\n            # Note: The logic in the original prompt had a bug in combining terms.\n            # Correct combination:\n            P_kp1_coeffs = np.zeros(k + 2)\n            P_kp1_coeffs[:k + 1] += term1\n            P_kp1_coeffs += term2[:k+2] # Broadcasting from right shift\n            P_kp1_coeffs[:k] -= P_km1_coeffs\n\n            P_km1_coeffs = P_k_coeffs\n            P_k_coeffs = P_kp1_coeffs\n        P_n_coeffs = P_k_coeffs\n\n    # Normalize coefficients to get the final polynomial p_n(mu)\n    coeffs = P_n_coeffs / C_n\n\n    return n, coeffs.tolist()\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and print results.\n    \"\"\"\n    test_cases = [\n        (10.0, 40.0, 0.1),\n        (20.0, 21.0, 1e-3),\n        (5.0, 100.0, 0.2),\n        (0.5, 2.0, 1e-2),\n        (15.0, 25.0, 1e-4),\n    ]\n\n    results = []\n    for r_min, r_max, delta in test_cases:\n        n, coeffs = compute_chebyshev_smoother(r_min, r_max, delta)\n        \n        # Format the coefficients to strings\n        coeffs_str = '[' + ','.join(map(format_num, coeffs)) + ']'\n        \n        # Format the result for this case\n        case_result_str = f\"[{n},{coeffs_str}]\"\n        results.append(case_result_str)\n\n    # Final print statement must be a single line with the exact format\n    final_output = '[' + ','.join(results) + ']'\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}