{
    "hands_on_practices": [
        {
            "introduction": "在深入探讨分层矩阵的复杂细节之前，我们首先通过一个计算练习来直观感受其威力。这项练习将量化对比在处理大规模声学问题时，传统稠密矩阵与分层矩阵在存储和计算成本上的巨大差异。通过这个对比，您将清晰地理解为什么分层矩阵是求解大型边界积分方程不可或缺的工具。",
            "id": "4115706",
            "problem": "三维时谐声学亥姆霍兹方程的边界积分离散化产生一个具有 $N=10^{5}$ 个边界未知数的稠密线性系统。得到的系统矩阵是复数值的，单个矩阵元素以双精度复数格式存储，占用 $16$ 字节。考虑两种组装和存储策略：\n\n1. 稠密组装和存储：\n   - 通过对所有源-目标对计算格林函数核来完全组装矩阵。使用成对相互作用模型产生 $\\mathcal{O}(N^{2})$ 次核函数计算作为基本依据。\n   - 存储包含所有 $N^{2}$ 个矩阵元素。\n\n2. 采用自适应交叉近似（ACA）的分层矩阵：\n   - 区域被分层划分为深度为 $L=\\lceil \\log_{2} N \\rceil$ 的平衡二叉聚类树。\n   - 远场容许块通过自适应交叉近似（ACA）使用秩为 $r=30$ 的低秩分解进行压缩。在一个 $m \\times n$ 块的秩-$r$ 分解中，存储 $U \\in \\mathbb{C}^{m \\times r}$ 和 $V \\in \\mathbb{C}^{n \\times r}$，需要 $r(m+n)$ 个复数。\n   - 使用平衡二叉空间划分的一个经过充分检验的性质，即在固定层级 $\\ell$ 上，所有远场块的 $(m+n)$ 之和以 $2N$ 为界。因此，对所有 $L$ 个层级求和，存储所有远场低秩因子所需的复数总数以 $2 r N \\log_{2} N$ 为界。假设在 $N=10^{5}$ 和 $r=30$ 时，近场贡献与此项相比可以忽略不计。\n   - 假设 ACA 组装成本与存储的低秩自由度数量成正比，因此远场块的核函数计算总数也与 $2 r N \\log_{2} N$ 成正比。使用单位常数的比例关系来获得具体的计数值。\n\n任务：\n- 从这些依据和假设出发，推导以下各项的显式公式：\n  - 稠密存储（以字节为单位）和稠密组装成本（以核函数计算次数为单位）。\n  - 分层存储（以字节为单位）和分层组装成本（以核函数计算次数为单位）。\n- 然后，定义压缩因子\n  $$S \\equiv \\frac{\\text{稠密存储 (字节)}}{\\text{分层存储 (字节)}}。$$\n  计算当 $N=10^{5}$ 和 $r=30$ 时的 $S$ 值。\n- 为便于理解，您也可以用十进制单位吉字节（GB）表示中间的内存预算，其中 $1\\,\\mathrm{GB} = 10^{9}$ 字节。但是，您最终报告的值必须是压缩因子 $S$ 这个纯数。\n\n将您的最终答案 $S$ 四舍五入到四位有效数字。最终报告的数字不应包含任何单位。",
            "solution": "问题陈述经评估有效。其科学依据建立在计算声学中使用的边界元方法和分层矩阵近似（特别是自适应交叉近似，ACA）的既定原则之上。该问题提法恰当，提供了所有必要的数据、明确的假设和清晰的定义，确保可以推导出唯一且有意义的解。参数和背景对于一个大规模科学计算问题是切合实际的。\n\n我们继续进行推导和求解。\n\n边界未知数的数量为 $N=10^{5}$。单个矩阵元素以双精度复数形式存储，占用 $16$ 字节。\n\n首先，我们分析稠密组装和存储策略。\n系统矩阵的大小为 $N \\times N$。\n总元素数量为 $N^2$。\n稠密矩阵所需的存储量，记为 $D_{\\text{storage}}$，是总元素数乘以每个元素的存储量：\n$$D_{\\text{storage}} = N^2 \\times 16 \\text{ 字节}$$\n组装成本，定义为核函数计算的次数，基于成对相互作用模型，其成本记为 $D_{\\text{cost}}$：\n$$D_{\\text{cost}} = N^2 \\text{ 次核函数计算}$$\n\n接下来，我们分析采用自适应交叉近似（ACA）的分层矩阵策略。\n低秩近似的秩给定为 $r=30$。\n问题陈述指出，存储所有远场低秩因子所需的复数总数以 $2 r N \\log_{2} N$ 为界，并假设近场的贡献可以忽略不计。\n因此，分层矩阵的存储量，记为 $H_{\\text{storage}}$，由该数量乘以每个复数的存储量得出：\n$$H_{\\text{storage}} = (2 r N \\log_{2} N) \\times 16 \\text{ 字节}$$\n远场块的组装成本，记为 $H_{\\text{cost}}$，假设与存储量成正比（比例常数为1），并且再次忽略近场成本。\n$$H_{\\text{cost}} = 2 r N \\log_{2} N \\text{ 次核函数计算}$$\n\n现在，我们针对给定的参数 $N=10^5$ 和 $r=30$ 来计算这些量和压缩因子 $S$。\n\n对于稠密策略：\n$D_{\\text{storage}} = (10^5)^2 \\times 16 = 10^{10} \\times 16 = 1.6 \\times 10^{11}$ 字节。使用换算关系 $1\\,\\mathrm{GB} = 10^9$ 字节，这相当于 $160\\,\\mathrm{GB}$。\n$D_{\\text{cost}} = (10^5)^2 = 10^{10}$ 次核函数计算。\n\n对于分层策略，我们首先计算 $\\log_{2} N$ 的值：\n$$\\log_{2} N = \\log_{2}(10^5) = 5 \\log_{2}(10)$$\n使用换底公式，$\\log_{2}(10) = \\frac{\\ln(10)}{\\ln(2)}$。\n数值上，$\\log_{2}(10^5) \\approx 5 \\times \\frac{2.302585}{0.693147} \\approx 16.60964$。\n现在我们可以计算存储量和成本：\n$H_{\\text{storage}} = (2 \\times 30 \\times 10^5 \\times \\log_{2}(10^5)) \\times 16 \\approx (60 \\times 10^5 \\times 16.60964) \\times 16 \\approx 9.965784 \\times 10^7 \\times 16 \\approx 1.5945 \\times 10^9$ 字节。这大约是 $1.595\\,\\mathrm{GB}$。\n$H_{\\text{cost}} = 2 \\times 30 \\times 10^5 \\times \\log_{2}(10^5) \\approx 60 \\times 10^5 \\times 16.60964 \\approx 9.966 \\times 10^7$ 次核函数计算。\n\n压缩因子 $S$ 定义为稠密存储与分层存储之比：\n$$S \\equiv \\frac{D_{\\text{storage}}}{H_{\\text{storage}}}$$\n代入推导出的公式：\n$$S = \\frac{N^2 \\times 16}{(2 r N \\log_{2} N) \\times 16} = \\frac{N^2}{2 r N \\log_{2} N} = \\frac{N}{2 r \\log_{2} N}$$\n这个公式表明，压缩因子随问题规模 $N$ 线性改善，并随秩 $r$ 和 $N$ 的对数成反比下降。\n\n我们现在对给定值计算 $S$：\n$$S = \\frac{10^5}{2 \\times 30 \\times \\log_{2}(10^5)} = \\frac{10^5}{60 \\times \\log_{2}(10^5)}$$\n使用先前计算的 $\\log_{2}(10^5)$ 值：\n$$S \\approx \\frac{100000}{60 \\times 16.60964} \\approx \\frac{100000}{996.5784} \\approx 100.3433$$\n将结果四舍五入到四位有效数字，得到 $100.3$。\n这意味着，对于此问题规模，与稠密矩阵方法相比，分层矩阵方法将存储需求减少了约 $100.3$ 倍。",
            "answer": "$$\\boxed{100.3}$$"
        },
        {
            "introduction": "理解了分层矩阵的必要性后，我们来动手实现其核心几何划分机制。在这个实践中，您将为一个球面网格构建空间聚类树，并实现一个可容许性条件来区分近场和远场区块。这个练习旨在帮助您掌握将矩阵划分为可压缩和不可压缩部分的关键技术，这是自适应交叉近似（ACA）和H矩阵算法的基石。",
            "id": "4115730",
            "problem": "给定一个计算声学背景，其中，由时谐声学亥姆霍兹问题产生的稠密边界积分方程矩阵，在分层矩阵的框架内使用自适应交叉近似（ACA）进行压缩。该物理模型由亥姆霍兹方程控制，其边界积分形式会产生由自由空间格林函数填充的矩阵。分层矩阵结构要求将矩阵块进行几何可容许性分类，分为近场（不压缩）和远场（符合低秩表示条件）。您的任务是实现一个由用户选择的分离参数进行参数化的几何远场可容许性检验，并计算在用给定数量嵌板离散化的球体上，可容许块所占的比例。\n\n从以下基本依据出发：\n- 时谐声学场由亥姆霍兹方程 $ \\nabla^2 p(\\boldsymbol{x}) + k^2 p(\\boldsymbol{x}) = 0 $ 控制，其中 $ k $ 为波数。\n- 当源簇和目标簇相对于其自身尺寸在空间上充分分离时，亥姆霍兹方程的自由空间格林函数 $ G(\\boldsymbol{x},\\boldsymbol{y}) $ 是关于 $ \\boldsymbol{x} $ 和 $ \\boldsymbol{y} $ 的光滑函数，这种光滑性是远场相互作用中低秩近似的基础。\n- 分层矩阵将索引集划分为由几何边界框表示的簇。簇对之间的块使用一种几何准则分类为远场或近场，该准则与“如果两个簇的尺寸相对于它们的间距较小，则它们是远场”的原则相符。\n\n实现以下内容：\n1. 使用 $ N $ 个嵌板对半径为 $ R = 1 $ 的单位球进行离散化，由球面上的 $ N $ 个准均匀分布点 $ \\{\\boldsymbol{x}_i\\}_{i=1}^N $ 表示。使用经过良好测试的确定性方法（例如，斐波那契晶格）来定义满足 $ \\|\\boldsymbol{x}_i\\|_2 = R $ 的嵌板位置 $ \\boldsymbol{x}_i \\in \\mathbb{R}^3 $。最终结果中不需要物理单位，因为输出是无量纲的分数。\n2. 在点集上构建一个二元空间簇树，方法是沿着其轴对齐边界框的最长轴递归地分割簇，直到每个叶簇最多包含 $ m $ 个嵌板，其中 $ m $ 是一个固定的整数且 $ m \\geq 2 $。每个簇都与其在 $ \\mathbb{R}^3 $ 中的轴对齐边界框相关联，该边界框由最小和最大角点向量 $ \\boldsymbol{b}^{\\min} \\in \\mathbb{R}^3 $ 和 $ \\boldsymbol{b}^{\\max} \\in \\mathbb{R}^3 $ 定义。簇的大小使用从边界框导出的统一几何度量进行量化，而两个簇之间的间距则使用其轴对齐边界框之间的欧几里得距离进行量化。\n3. 在同一簇树上为行和列（由于源和目标的边界相同，因此是同一个集合）构建一个块-簇树。从由根簇与其自身组成的对开始，按如下方式递归生成块：如果一对簇满足一个形式化了“尺寸相对于间距较小”原则的几何条件，则声明此块为远场，并且不再进一步细分；否则，如果两个簇都是叶节点，则声明此块为近场；如果不可容许且至少有一个簇不是叶节点，则细分具有较大几何尺寸的一侧（如果两者都非叶节点），或细分非叶节点的一侧，并对子对进行递归，直到满足前述条件之一。递归过程必须将完整的交互矩阵索引划分为不相交的块集。\n4. 使用一个选定的分离参数 $ \\eta > 0 $，实现一个与上述原则一致且数学上合理的远场可容许性检验。使用每个簇的轴对齐边界框来定义其几何尺寸，并使用两个轴对齐边界框之间的欧几里得最小距离来定义间距。该检验必须由 $ \\eta $ 参数化，使得增加 $ \\eta $ 会使分类更加宽松。\n5. 计算块-簇树中可容许块的比例，定义为远场块的数量除以划分中块的总数。\n\n您的程序必须：\n- 使用 $ R = 1 $ 和一个固定的叶大小 $ m = 16 $ 个嵌板/叶簇。\n- 对于每个测试用例，构建簇树和块-簇树，并计算可容许块的比例，结果为一个在 $ [0,1] $ 区间内的实数，四舍五入到六位小数。\n- 生成单行输出，包含一个由方括号括起来的逗号分隔列表形式的结果。\n\n测试套件：\n- 案例 1: $ N = 64 $, $ \\eta = 0.5 $。\n- 案例 2: $ N = 64 $, $ \\eta = 1.0 $。\n- 案例 3: $ N = 64 $, $ \\eta = 2.0 $。\n- 案例 4: $ N = 8 $, $ \\eta = 0.5 $。\n- 案例 5: $ N = 256 $, $ \\eta = 0.5 $。\n\n最终输出格式：\n您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表形式的结果（例如，$ [r_1,r_2,r_3,r_4,r_5] $），其中每个 $ r_i $ 是对应测试用例的可容许块的比例，四舍五入到六位小数。",
            "solution": "该问题是有效的。它是一个明确定义的计算任务，基于用于加速边界元法的分层矩阵的既定原则。参数和目标清晰、一致且科学上合理。\n\n目标是计算分层矩阵划分中可容许（远场）块的比例，该矩阵划分针对由球面上点离散化的边界。这个比例是分层矩阵算法的一个关键性能指标，因为它代表了可以被压缩的矩阵块的比例，从而降低计算复杂性。该过程涉及计算科学中的几个标准步骤：几何离散化、分层数据结构化，以及基于几何可容许性准则的递归划分。\n\n解决方案通过以下步骤序列构建：\n1.  生成球面上的准均匀分布点，以表示离散化的边界。\n2.  构建空间簇树，以分层方式组织这些点。\n3.  定义并实现一个几何可容许性准则，以将簇对分类为近场或远场。\n4.  构建一个块-簇树，将矩阵划分为近场和远场块，并计算由此产生的可容许块的比例。\n\n**步骤 1：球体离散化**\n\n第一步是生成一组 $N$ 个点，$\\{\\boldsymbol{x}_i\\}_{i=1}^N$，这些点代表半径为 $R=1$ 的单位球面上的嵌板位置。为使结果具有确定性和代表性，这些点必须以准均匀的方式分布。斐波那契晶格为此提供了一种有效的方法。第 $i$ 个点（其中 $i \\in \\{0, 1, \\dots, N-1\\}$）的坐标是使用球坐标 $(\\rho, \\theta, \\phi)$ 生成的，其中 $\\rho$ 是径向距离，$\\theta$ 是方位角，$\\phi$ 是极角。对于单位球体，$\\rho=1$。角度由以下公式给出：\n$$ \\phi_i = \\arccos\\left(1 - \\frac{2(i+0.5)}{N}\\right) $$\n$$ \\theta_i = \\frac{2\\pi i}{\\Phi} $$\n其中 $\\Phi = \\frac{1+\\sqrt{5}}{2}$ 是黄金比例。然后通过标准变换获得笛卡尔坐标 $\\boldsymbol{x}_i = (x_i, y_i, z_i)$：\n$$ x_i = R \\sin(\\phi_i) \\cos(\\theta_i) $$\n$$ y_i = R \\sin(\\phi_i) \\sin(\\theta_i) $$\n$$ z_i = R \\cos(\\phi_i) $$\n给定 $R=1$，这些点位于单位球面上，满足 $\\|\\boldsymbol{x}_i\\|_2 = 1$。这 $N$ 个点构成了我们问题的索引集。\n\n**步骤 2：簇树构建**\n\n簇树是一种分层数据结构，用于在空间上组织点集。它是递归构建的。树中的每个节点，称为一个簇 $\\tau$，代表点索引的一个子集 $I_\\tau \\subseteq \\{0, 1, \\dots, N-1\\}$，并与一个轴对齐边界框 (AABB) $\\mathcal{B}_\\tau$ 相关联，该边界框包围所有点 $\\{\\boldsymbol{x}_i\\}_{i \\in I_\\tau}$。\n\n树的构建过程如下：\n-   根簇包含所有 $N$ 个点索引。\n-   对根簇应用一个递归函数。对于给定的簇 $\\tau$：\n    1.  如果簇中的点数 $|I_\\tau|$ 小于或等于叶大小参数 $m$（给定为 $m=16$），则该簇被声明为叶节点，该分支的递归终止。\n    2.  否则，该簇被分裂成两个子簇。分裂沿着簇的AABB $\\mathcal{B}_\\tau$ 的最长维度进行。根据点在这一维度上坐标的中位数将点划分为两组。这确保了平衡的空间划分。\n    3.  从这两组点创建两个新的子簇，并对每个子簇调用递归函数。\n\n此过程产生一个二叉树，其中每个叶簇最多包含 $m$ 个点。\n\n**步骤 3：几何可容许性准则**\n\n分层矩阵方法的核心是可容许性准则，它决定了两个簇 $\\tau$ 和 $\\sigma$ 之间的相互作用是否可以被近似。这基于格林函数对于良好分离的域是光滑的这一原理。一个标准的几何条件通过比较簇的大小与其间距来形式化这一点。\n\n对于两个簇 $\\tau$ 和 $\\sigma$，我们定义：\n-   **边界框 $\\mathcal{B}$**：一个簇 $\\tau$ 的 AABB 由其最小和最大角点向量 $\\boldsymbol{b}_\\tau^{\\min}$ 和 $\\boldsymbol{b}_\\tau^{\\max}$ 定义。\n-   **直径 $\\text{diam}(\\mathcal{B}_\\tau)$**：簇的大小由其 AABB 的直径量化，计算为框对角线的欧几里得范数：$\\text{diam}(\\mathcal{B}_\\tau) = \\|\\boldsymbol{b}_\\tau^{\\max} - \\boldsymbol{b}_\\tau^{\\min}\\|_2$。\n-   **距离 $\\text{dist}(\\mathcal{B}_\\tau, \\mathcal{B}_\\sigma)$**：两个簇之间的间距是其 AABB 之间的最小欧几里得距离。计算公式为 $\\text{dist}(\\mathcal{B}_\\tau, \\mathcal{B}_\\sigma) = \\left( \\sum_{j=1}^3 \\max(0, b_{\\tau,j}^{\\min} - b_{\\sigma,j}^{\\max}, b_{\\sigma,j}^{\\min} - b_{\\tau,j}^{\\max})^2 \\right)^{1/2}$。\n\n对应于簇对 $(\\tau, \\sigma)$ 的块被声明为**可容许**（远场），如果对于给定的分离参数 $\\eta > 0$ 满足以下条件：\n$$ \\max(\\text{diam}(\\mathcal{B}_\\tau), \\text{diam}(\\mathcal{B}_\\sigma)) \\le \\eta \\cdot \\text{dist}(\\mathcal{B}_\\tau, \\mathcal{B}_\\sigma) $$\n如果边界框接触或重叠，则 $\\text{dist}(\\mathcal{B}_\\tau, \\mathcal{B}_\\sigma) = 0$，条件不满足（除非簇是具有零直径的单点）。增加 $\\eta$ 会放宽此条件，允许在相同距离下将更大的簇视为“远场”，从而使可容许性更加宽松。\n\n**步骤 4：块-簇树与比例计算**\n\n块-簇树表示将整个矩阵乘积空间 $I \\times I$ 划分为不相交的块 $(\\tau, \\sigma)$。我们不需要显式地存储这棵树；我们可以递归地遍历它来计算可容许（远场）和不可容许（近场）叶块的数量。\n\n计数是通过一个递归算法执行的，使用一个栈来实现迭代以避免深度递归问题：\n1.  用初始块 `(root, root)` 初始化一个栈，其中 `root` 是簇树的根节点。初始化计数器 $N_{\\text{far}} = 0$ 和 $N_{\\text{near}} = 0$。\n2.  当栈不为空时，弹出一个块 $(\\tau, \\sigma)$。\n3.  使用步骤 3 中的准则检查该块是否可容许。\n    -   如果是，则增加 $N_{\\text{far}}$，并且不再进一步细分此块。\n    -   如果否，则继续下一步。\n4.  检查 $\\tau$ 和 $\\sigma$ 是否都是叶簇。\n    -   如果是，则此块是一个不可压缩的近场块。增加 $N_{\\text{near}}$。\n    -   如果否，则至少有一个簇不是叶簇，该块必须被细分。\n5.  要进行细分，选择直径较大的簇进行分裂。如果一个簇是叶节点，则必须分裂另一个（非叶）簇。\n    -   如果选择 $\\tau$ 进行分裂，则将其子对 $(\\tau_1, \\sigma)$ 和 $(\\tau_2, \\sigma)$ 推入栈中。\n    -   如果选择 $\\sigma$ 进行分裂，则将 $(\\tau, \\sigma_1)$ 和 $(\\tau, \\sigma_2)$ 推入栈中。\n6.  重复此过程直到栈为空。\n\n最后，可容许块的比例计算如下：\n$$ \\mathcal{F} = \\frac{N_{\\text{far}}}{N_{\\text{far}} + N_{\\text{near}}} $$\n此值是为问题陈述中指定的每个测试用例计算的，结果四舍五入到六位小数。对于 $N=8$ 和 $m=16$ 的特殊情况，簇树只有一个根节点（同时也是叶节点）。块 `(root, root)` 是不可容许的，且无法细分，导致 $N_{\\text{near}}=1$ 和 $N_{\\text{far}}=0$，得出比例为 $0.0$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the fraction of admissible blocks in a hierarchical matrix partition\n    for a sphere discretization.\n    \"\"\"\n\n    class Cluster:\n        \"\"\"Represents a cluster of points and its bounding box.\"\"\"\n        def __init__(self, indices, all_points):\n            self.indices = np.array(indices, dtype=int)\n            if self.indices.size > 0:\n                self.points = all_points[self.indices]\n                self.bbox_min = np.min(self.points, axis=0)\n                self.bbox_max = np.max(self.points, axis=0)\n                self.diameter = np.linalg.norm(self.bbox_max - self.bbox_min)\n            else:\n                self.points = np.empty((0, 3))\n                # Define a non-interfering default for empty clusters\n                self.bbox_min = np.full(3, np.inf)\n                self.bbox_max = np.full(3, -np.inf)\n                self.diameter = 0.0\n            self.children = None\n\n    def generate_sphere_points(N, R):\n        \"\"\"Generates N quasi-uniform points on a sphere of radius R using a Fibonacci lattice.\"\"\"\n        if N == 0:\n            return np.empty((0, 3))\n        \n        indices = np.arange(0, N, dtype=float) + 0.5\n        \n        phi = np.arccos(1 - 2 * indices / N)\n        golden_ratio = (1 + 5**0.5) / 2\n        theta = 2 * np.pi * indices / golden_ratio\n        \n        x = R * np.cos(theta) * np.sin(phi)\n        y = R * np.sin(theta) * np.sin(phi)\n        z = R * np.cos(phi)\n        \n        return np.stack([x, y, z], axis=1)\n\n    def build_cluster_tree(cluster, m, all_points):\n        \"\"\"Recursively builds a spatial cluster tree.\"\"\"\n        if len(cluster.indices) = m:\n            return  # This cluster is a leaf\n\n        # Find the longest dimension of the bounding box to split along\n        dims = cluster.bbox_max - cluster.bbox_min\n        split_dim = np.argmax(dims)\n        \n        # Partition points based on the median coordinate\n        coords = cluster.points[:, split_dim]\n        median = np.median(coords)\n        \n        left_indices = cluster.indices[coords  median]\n        right_indices = cluster.indices[coords >= median]\n\n        # Handle degenerate cases where one child would be empty\n        if len(left_indices) == 0 or len(right_indices) == 0:\n            mid_idx = len(cluster.indices) // 2\n            left_indices = cluster.indices[:mid_idx]\n            right_indices = cluster.indices[mid_idx:]\n\n        cluster.children = [\n            Cluster(left_indices, all_points),\n            Cluster(right_indices, all_points)\n        ]\n        \n        for child in cluster.children:\n            build_cluster_tree(child, m, all_points)\n\n    def is_admissible(c_tau, c_sigma, eta):\n        \"\"\"Checks if the block (c_tau, c_sigma) is admissible.\"\"\"\n        dist_sq = 0.0\n        for i in range(3):\n            d = max(0.0, c_tau.bbox_min[i] - c_sigma.bbox_max[i], c_sigma.bbox_min[i] - c_tau.bbox_max[i])\n            dist_sq += d * d\n        \n        if dist_sq == 0:\n            return False  # Bounding boxes overlap or touch\n        \n        dist = np.sqrt(dist_sq)\n        max_diam = max(c_tau.diameter, c_sigma.diameter)\n        \n        return max_diam = eta * dist\n\n    def count_blocks(root, eta):\n        \"\"\"Counts far-field and near-field blocks in the block-cluster tree.\"\"\"\n        far_count = 0\n        near_count = 0\n        \n        if root is None:\n            return 0, 0\n        \n        stack = [(root, root)]\n        \n        while stack:\n            c_tau, c_sigma = stack.pop()\n            \n            if is_admissible(c_tau, c_sigma, eta):\n                far_count += 1\n                continue\n            \n            # If not admissible, check if we must stop subdividing\n            if c_tau.children is None and c_sigma.children is None:\n                near_count += 1\n                continue\n                \n            # If we can subdivide, determine which cluster to split\n            split_tau = (c_tau.children is not None) and \\\n                        ((c_sigma.children is None) or (c_tau.diameter >= c_sigma.diameter))\n\n            if split_tau:\n                for child_tau in c_tau.children:\n                    stack.append((child_tau, c_sigma))\n            else:  # split_sigma\n                for child_sigma in c_sigma.children:\n                    stack.append((c_tau, child_sigma))\n\n        return far_count, near_count\n\n    R = 1.0\n    m = 16\n    \n    test_cases = [\n        (64, 0.5),\n        (64, 1.0),\n        (64, 2.0),\n        (8, 0.5),\n        (256, 0.5),\n    ]\n\n    results = []\n    for N, eta in test_cases:\n        points = generate_sphere_points(N, R)\n        \n        if N > 0:\n            root = Cluster(range(N), points)\n            build_cluster_tree(root, m, points)\n            far_blocks, near_blocks = count_blocks(root, eta)\n            total_blocks = far_blocks + near_blocks\n        \n            if total_blocks > 0:\n                fraction = far_blocks / total_blocks\n            else:\n                fraction = 0.0\n        else:\n            fraction = 0.0\n\n        results.append(round(fraction, 6))\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "我们已经知道如何划分矩阵，但一个远场区块的可压缩程度（即其数值秩）究竟由什么决定？这项练习将深入探讨可压缩性背后的物理原理。您将通过一个启发式模型来估计数值秩，并将其与通过奇异值分解（SVD）计算的精确秩进行比较，从而揭示问题的物理参数（如波数和几何分离度）是如何影响压缩效率的。",
            "id": "4115752",
            "problem": "考虑由波数为 $k$ 的亥姆霍兹方程所支配的三维时谐声场。自由空间格林函数由 $\\dfrac{\\exp(\\mathrm{i}k|\\mathbf{x}-\\mathbf{y}|)}{4\\pi|\\mathbf{x}-\\mathbf{y}|}$ 给出。在层次矩阵方法中，对应于两个良好分离的簇之间相互作用的块允许低秩可分离近似，自适应交叉近似（ACA）可以恢复这种低秩结构。我们关注两个边长为 $a$、轴对齐的立方体 $X$ 和 $Y$，它们的中心沿 $x$ 轴相距为 $d$；因此最近的面间距为 $d-a$。将这两个立方体均匀离散化为笛卡尔张量网格，以形成稠密的相互作用矩阵 $A \\in \\mathbb{C}^{n \\times n}$，其中 $A_{ij} = G(\\mathbf{x}_i,\\mathbf{y}_j)$，而 $\\{\\mathbf{x}_i\\}$、$\\{\\mathbf{y}_j\\}$ 分别是 $X$ 和 $Y$ 中的网格点。\n\n从亥姆霍兹格林函数可分离展开的加法定理以及层次矩阵的经典可容许性概念（良好分离的簇产生收敛的简并展开）出发，使用以下启发式方法来估计数值秩：\n- 令 $L$ 为同时满足分离尾部控制和振荡内容解析两个约束的最小整数：\n  1. 分离尾部控制：选择 $L$ 使得 $L \\ge \\left\\lceil \\dfrac{\\ln(1/\\varepsilon)}{\\ln(d/a)} \\right\\rceil$，\n  2. 振荡内容解析：选择 $L$ 使得 $L \\ge \\left\\lceil k a \\right\\rceil$。\n- 直到 $L$ 阶的球谐函数可分离展开包含 $(L+1)^2$ 个角模式；使用 $R_{\\text{heur}} = (L+1)^2$ 作为秩的估计值。\n\n这里 $\\varepsilon$ 表示弗罗贝尼乌斯范数中期望的相对误差容限。为了对该启发式方法进行数值验证，将每个立方体在每个空间维度上用 $N$ 个等距点进行离散化，每个立方体总共有 $n = N^3$ 个点。构建相互作用矩阵 $A$，并通过截断奇异值分解（SVD）来计算最小整数秩 $R_{\\text{svd}}$，使得截断近似 $A_R$ 的相对弗罗贝尼乌斯误差满足\n$$\n\\frac{\\|A - A_R\\|_F}{\\|A\\|_F} \\le \\varepsilon,\n$$\n其中 $\\|\\cdot\\|_F$ 是弗罗贝尼乌斯范数。使用面间距 $d-a$，并将立方体中心置于 $\\mathbf{c}_X = \\left(-\\dfrac{d}{2},\\,0,\\,0\\right)$ 和 $\\mathbf{c}_Y = \\left(\\dfrac{d}{2},\\,0,\\,0\\right)$。相对于其中心，每个立方体占据 $[-a/2,a/2]^3$ 的空间。\n\n您的程序必须为以下测试套件实现启发式秩估计和基于SVD的实测最小秩，所有测试均使用每个维度 $N=5$ 个点以及上述格林函数：\n- 测试用例 1 (理想情况): $k a = 2$, $d/a = 6$, $\\varepsilon = 10^{-6}$。\n- 测试用例 2 (更高频率): $k a = 10$, $d/a = 6$, $\\varepsilon = 10^{-6}$。\n- 测试用例 3 (接近可容许性边界): $k a = 2$, $d/a = 1.2$, $\\varepsilon = 10^{-6}$。\n- 测试用例 4 (低频): $k a = 0.5$, $d/a = 6$, $\\varepsilon = 10^{-6}$。\n\n对于所有测试用例，设置 $a=1$（单位为米），因此 $k = k a / a = k a$ 的单位是米^-1，而 $d = (d/a) \\cdot a$ 的单位是米。输出 $R_{\\text{heur}}$ 和 $R_{\\text{svd}}$ 是无单位的整数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素是对应一个测试用例的配对 $[R_{\\text{heur}},R_{\\text{svd}}]$，顺序如上所列。例如，输出格式必须严格为\n$$\n\\texttt{[[R\\_heur\\_1,R\\_svd\\_1],[R\\_heur\\_2,R\\_svd\\_2],[R\\_heur\\_3,R\\_svd\\_3],[R\\_heur\\_4,R\\_svd\\_4]]}。\n$$",
            "solution": "该问题要求对边界元矩阵的特定块的启发式估计秩和数值计算秩进行比较。该矩阵源于与三维亥姆霍兹方程相关的积分算子的离散化。分析过程分为两部分：启发式秩 $R_{\\text{heur}}$ 的推导和计算，以及基于 SVD 的秩 $R_{\\text{svd}}$ 的数值计算。\n\n首先，我们讨论启发式秩估计 $R_{\\text{heur}}$。此估计的基础在于波传播的物理学，特别是使用诸如球谐函数加法定理之类的可分离展开来表示自由空间格林函数 $G(\\mathbf{x},\\mathbf{y}) = \\frac{\\exp(\\mathrm{i}k|\\mathbf{x}-\\mathbf{y}|)}{4\\pi|\\mathbf{x}-\\mathbf{y}|} $。对于两个良好分离的点簇 $X$ 和 $Y$，相互作用块 $A$（其中 $A_{ij} = G(\\mathbf{x}_i, \\mathbf{y}_j)$）可以由一个低秩矩阵来近似。该近似的秩取决于展开的阶数 $L$。问题提供了两个物理约束来确定一个充分的阶数 $L$。\n\n1.  **分离尾部控制**：此约束源于积分算子奇异值的衰减，而奇异值的衰减与簇之间的分离程度有关。对于特征尺寸为 $a$、相距为 $d$ 的簇，多极展开误差随比率 $a/d$ 呈几何级数衰减。为达到期望的相对精度 $\\varepsilon$，阶数 $L$ 必须足够大，以充分抑制展开式被截断的“尾部”。这给出了第一个条件：\n    $$L \\ge L_{\\text{sep}} = \\left\\lceil \\frac{\\ln(1/\\varepsilon)}{\\ln(d/a)} \\right\\rceil$$\n    在低频下，对于良好分离的簇（$d/a \\gg 1$），此条件占主导地位。\n\n2.  **振荡内容解析**：此约束与应用于波场角分量的奈奎斯特-香农采样定理有关。为了在尺寸为 $a$ 的区域上精确表示波数为 $k$ 的波，基函数的数量必须与无量纲量 $ka$ 成正比。更高的频率（更大的 $k$）或更大的域（更大的 $a$）会引入更多必须被解析的振荡。在球谐函数的背景下，这导出了第二个条件：\n    $$L \\ge L_{\\text{osc}} = \\left\\lceil k a \\right\\rceil$$\n    在高频下，此条件变得占主导地位，此时核函数的振荡特性是限制可压缩性的主要因素。\n\n所需的总展开阶数 $L$ 必须同时满足两个约束，因此 $L = \\max(L_{\\text{sep}}, L_{\\text{osc}})$。一个 $L$ 阶的球谐函数展开包含 $(L+1)^2$ 个基函数。该数量为数值秩提供了一个直接的启发式估计：\n$$R_{\\text{heur}} = (L+1)^2$$\n\n其次，我们计算数值秩 $R_{\\text{svd}}$，作为基准真相。这包括以下步骤：\n1.  **离散化**：将两个立方体域 $X$ 和 $Y$ 进行离散化。每个立方体边长为 $a=1$，包含 $n=N^3$ 个点，其中每个维度上有 $N=5$ 个等距点。立方体的中心设置为 $\\mathbf{c}_X = (-d/2, 0, 0)$ 和 $\\mathbf{c}_Y = (d/2, 0, 0)$。\n2.  **矩阵组装**：构建稠密的 $n \\times n$ 相互作用矩阵 $A$，其元素为 $A_{ij} = G(\\mathbf{x}_i, \\mathbf{y}_j)$，适用于所有点 $\\mathbf{x}_i \\in X$ 和 $\\mathbf{y}_j \\in Y$。\n3.  **奇异值分解 (SVD)**：计算 $A$ 的 SVD，得到奇异值 $\\sigma_0 \\ge \\sigma_1 \\ge \\dots \\ge \\sigma_{n-1} \\ge 0$。SVD 在弗罗贝尼乌斯范数下提供最优的低秩近似。通过保留前 $R$ 个奇异值和奇异向量，构成一个秩为 $R$ 的近似 $A_R$。\n4.  **秩的确定**：秩为 $R$ 的近似误差由 $\\|A - A_R\\|_F = \\sqrt{\\sum_{i=R}^{n-1} \\sigma_i^2}$ 给出。相对弗罗贝尼乌斯误差是该误差与矩阵总范数 $\\|A\\|_F = \\sqrt{\\sum_{i=0}^{n-1} \\sigma_i^2}$ 的比值。我们寻求最小的整数秩 $R_{\\text{svd}}$，使得该相对误差不大于指定的容限 $\\varepsilon$：\n    $$\\frac{\\sqrt{\\sum_{i=R_{\\text{svd}}}^{n-1} \\sigma_i^2}}{\\sqrt{\\sum_{i=0}^{n-1} \\sigma_i^2}} \\le \\varepsilon$$\n    这等价于找到最小的 $R$，使得 $(\\sum_{i=R}^{n-1} \\sigma_i^2) \\le \\varepsilon^2 (\\sum_{i=0}^{n-1} \\sigma_i^2)$。这个值 $R$ 是通过从 $R=0$ 到 $n$ 遍历可能的秩，并选择第一个满足条件的秩来确定的。\n\n该程序为四个测试用例中的每一个都实现了这两个过程，从而提供了基于物理的启发式方法与精确数值秩之间的比较。",
            "answer": "```python\nimport numpy as np\n\ndef calculate_R_heur(ka, da_ratio, epsilon):\n    \"\"\"\n    基于物理约束计算启发式秩估计。\n\n    Args:\n        ka (float): 无量纲波数。\n        da_ratio (float): 中心间距与立方体边长的比值。\n        epsilon (float): 期望的相对误差容限。\n\n    Returns:\n        int: 启发式秩估计 R_heur。\n    \"\"\"\n    # 分离尾部控制约束\n    # 注意：np.log(da_ratio) 是安全的，因为所有测试用例的 da_ratio > 1\n    L_sep = np.ceil(np.log(1.0 / epsilon) / np.log(da_ratio))\n    \n    # 振荡内容解析约束\n    L_osc = np.ceil(ka)\n    \n    # L 是两个约束中的最大值\n    L = int(np.max([L_sep, L_osc]))\n    \n    # 基于 L 阶球谐函数展开的启发式秩\n    R_heur = (L + 1)**2\n    return R_heur\n\ndef calculate_R_svd(ka, da_ratio, epsilon, N, a):\n    \"\"\"\n    构建相互作用矩阵并计算基于 SVD 的最小秩。\n\n    Args:\n        ka (float): 无量纲波数。\n        da_ratio (float): 中心间距与立方体边长的比值。\n        epsilon (float): 期望的相对误差容限。\n        N (int): 每个维度的等距点数。\n        a (float): 立方体的边长。\n\n    Returns:\n        int: 基于 SVD 的最小秩 R_svd。\n    \"\"\"\n    # 导出的物理参数\n    k = ka / a\n    d = da_ratio * a\n    n = N**3\n    \n    # 1. 为以原点为中心的立方体生成网格点\n    coords_1d = np.linspace(-a / 2.0, a / 2.0, N)\n    # 为保持一致性使用'ij'索引，然后重塑为(x,y,z)点列表\n    grid_rel = np.array(np.meshgrid(coords_1d, coords_1d, coords_1d, indexing='ij')).T.reshape(-1, 3)\n\n    # 2. 将网格点平移到立方体 X 和 Y 的绝对位置\n    center_X = np.array([-d / 2.0, 0.0, 0.0])\n    center_Y = np.array([d / 2.0, 0.0, 0.0])\n    \n    points_X = grid_rel + center_X\n    points_Y = grid_rel + center_Y\n\n    # 3. 使用广播以提高效率来构建相互作用矩阵 A\n    # points_X 形状: (n, 3) -> (n, 1, 3)\n    # points_Y 形状: (n, 3) -> (1, n, 3)\n    # diff 形状: (n, n, 3)\n    diff = points_X[:, np.newaxis, :] - points_Y[np.newaxis, :, :]\n    \n    # dists 形状: (n, n)\n    dists = np.linalg.norm(diff, axis=2)\n    \n    # 计算所有点对的格林函数（亥姆霍兹核）\n    # 注意：dists 永远不为零，因为在所有测试用例中立方体都是分离的\n    A = np.exp(1j * k * dists) / (4.0 * np.pi * dists)\n    \n    # 4. 计算奇异值（我们只需要值，不需要向量）\n    s = np.linalg.svd(A, compute_uv=False)\n    \n    # 5. 找到满足误差容限的最小秩 R_svd\n    s_sq = s**2\n    total_norm_sq = np.sum(s_sq)\n    \n    # 如果矩阵在数值上为零，其秩为0。\n    if total_norm_sq == 0:\n        return 0\n\n    target_error_sq = epsilon**2 * total_norm_sq\n    \n    # 从 0 到 n 循环遍历可能的秩 R，以找到最小的一个\n    # 满足误差条件的秩。\n    R_svd = n # 如果没有更小的秩满足条件，则默认为满秩\n    for R in range(n):\n        # 秩为 R 的近似误差是尾随奇异值的平方和\n        error_sq = np.sum(s_sq[R:])\n        \n        if error_sq = target_error_sq:\n            R_svd = R\n            break\n            \n    return R_svd\n\ndef solve():\n    \"\"\"\n    运行测试套件并打印结果的主函数。\n    \"\"\"\n    # 将测试用例定义为 (ka, d/a, epsilon)\n    test_cases = [\n        (2.0, 6.0, 1e-6),   # 测试用例 1\n        (10.0, 6.0, 1e-6),  # 测试用例 2\n        (2.0, 1.2, 1e-6),   # 测试用例 3\n        (0.5, 6.0, 1e-6),   # 测试用例 4\n    ]\n\n    # 问题陈述中的全局参数\n    N = 5\n    a = 1.0\n\n    final_result_strings = []\n    for ka, da_ratio, epsilon in test_cases:\n        R_heur = calculate_R_heur(ka, da_ratio, epsilon)\n        R_svd = calculate_R_svd(ka, da_ratio, epsilon, N, a)\n        # 将每对格式化为 [R_heur,R_svd]，不含空格\n        final_result_strings.append(f\"[{R_heur},{R_svd}]\")\n\n    # 将所有结果合并为最终所需的格式\n    print(f\"[{','.join(final_result_strings)}]\")\n\nsolve()\n```"
        }
    ]
}