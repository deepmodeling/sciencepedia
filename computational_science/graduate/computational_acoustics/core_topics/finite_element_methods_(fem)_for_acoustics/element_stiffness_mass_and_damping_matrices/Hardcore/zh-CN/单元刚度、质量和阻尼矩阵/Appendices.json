{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握计算声学，理论推导必须与实际编程相结合。这项实践练习是实施有限元声学求解器的基石，它将带你走过从亥姆霍兹方程的弱形式到组装全局刚度矩阵 $K$ 和质量矩阵 $M$ 的完整过程。通过计算一个简单的矩形腔体的本征模态，并将其与解析解进行比较，你将亲身体验有限元方法的核心工作流程，并对离散误差的概念有更深刻的理解。",
            "id": "4122219",
            "problem": "您的任务是推导并数值实现一个二维刚性壁声腔的压力本征模态的有限元公式。计算域是一个边长分别为 $L_x$ 和 $L_y$（单位为 $\\mathrm{m}$）的矩形。假设声学特性为无损耗、无粘性、可压缩，并由压力 $p(\\mathbf{x},t)$ 的线性声波方程控制，同时假设壁面为刚性（边界上无垂直于壁面的质点速度）。使用双线性四边形单元对空间域进行离散化，并采用标准的伽辽金法来获得单元刚度、质量和阻尼矩阵。利用这些矩阵组装全局矩阵，并求解广义特征值问题，以获得最低的几个声腔本征对。将数值计算得到的波数与刚性壁矩形腔的解析模态进行比较，并量化离散误差。\n\n推导必须从基本原理开始。从均匀介质中声压的线性声波方程开始，其中声速为 $c$（单位为 $\\mathrm{m/s}$）：\n$$\n\\frac{1}{c^2}\\frac{\\partial^2 p}{\\partial t^2} - \\nabla^2 p = 0,\n$$\n该方程定义于一个矩形域 $\\Omega$ 内，其边界 $\\partial\\Omega$ 上的单位外法向量为 $\\mathbf{n}$。刚性壁边界条件要求法向质点速度为零。采用时谐拟设 $p(\\mathbf{x},t)=\\Re\\{ \\hat{p}(\\mathbf{x}) e^{\\mathrm{i}\\omega t} \\}$，推导空间亥姆霍兹方程、其弱形式，以及使用双线性形函数在参考正方形上通过等参映射到每个单元的有限元离散化。根据弱形式，通过在每个单元上对形函数及其梯度的适当乘积进行积分，推导单元刚度、质量和阻尼矩阵。您不能假设或引用任何预先推导出的有限元矩阵；相反，必须从弱形式、等参映射、雅可比矩阵和高斯求积出发进行推导。\n\n解析参考。对于具有诺伊曼边界条件的刚性壁矩形腔，其解析本征函数是余弦函数的可分离积，波数满足\n$$\nk_{n_x,n_y}^2 = \\left(\\frac{n_x\\pi}{L_x}\\right)^2 + \\left(\\frac{n_y\\pi}{L_y}\\right)^2,\n$$\n其中 $n_x\\ge 0$，$n_y\\ge 0$ 为整数。$n_x=n_y=0$ 的模态是均匀压力场，其 $k=0$，在比较非平凡模态时可以忽略。角频率为 $\\omega=c\\,k$，频率为 $f=\\omega/(2\\pi)$，但在此任务中，您必须比较波数 $k$（单位为 $\\mathrm{m}^{-1}$）。\n\n计算任务：\n- 推导弱形式和有限元矩阵。根据单元贡献组装全局刚度矩阵 $K$ 和质量矩阵 $M$。同时，推导一个与建模为与压力变化率成正比的线性体积损耗相一致的单元阻尼矩阵 $C$；然而，在进行本征对比较时，请使用零阻尼。\n- 求解广义对称定特征值问题\n$$\nK \\mathbf{p} = \\lambda M \\mathbf{p},\n$$\n其中 $\\lambda = k^2$，$k$ 是波数（单位为 $\\mathrm{m}^{-1}$）。通过对最小的几个正特征值 $\\lambda$ 取平方根，提取出最低的几个正波数 $k$。\n- 为相同的域生成解析的非平凡波数 $k_{n_x,n_y}$，并按索引将前几个与数值结果进行比较。\n- 对下面的每个测试用例，计算前 $m$ 个非平凡模态的平均绝对相对误差：\n$$\n\\mathrm{err} = \\frac{1}{m}\\sum_{i=1}^{m} \\left| \\frac{k_i^{\\mathrm{num}} - k_i^{\\mathrm{anal}}}{k_i^{\\mathrm{anal}}} \\right|,\n$$\n该误差是无量纲的，必须以小数形式报告。\n\n在等参参考正方形中使用标准的 $2\\times 2$ 高斯求积和双线性四边形单元。您的实现应具有足够的通用性，能够处理任何矩形尺寸和均匀网格。\n\n测试套件：\n- 用例 1：$L_x=1.0$ $\\mathrm{m}$，$L_y=0.8$ $\\mathrm{m}$，$x$ 方向 2 个单元，$y$ 方向 2 个单元，$c=343$ $\\mathrm{m/s}$，$m=4$ 个模态。\n- 用例 2：$L_x=1.0$ $\\mathrm{m}$，$L_y=0.8$ $\\mathrm{m}$，$N_x=4$，$N_y=4$，$c=343$ $\\mathrm{m/s}$，$m=4$ 个模态。\n- 用例 3：$L_x=1.0$ $\\mathrm{m}$，$L_y=0.8$ $\\mathrm{m}$，$N_x=8$，$N_y=8$，$c=343$ $\\mathrm{m/s}$，$m=4$ 个模态。\n- 用例 4：$L_x=1.0$ $\\mathrm{m}$，$L_y=0.8$ $\\mathrm{m}$，$N_x=16$，$N_y=16$，$c=343$ $\\mathrm{m/s}$，$m=4$ 个模态。\n\n单位和输出：\n- 所有长度单位必须是 $\\mathrm{m}$，声速单位是 $\\mathrm{m/s}$，波数单位是 $\\mathrm{m}^{-1}$。\n- 为每个测试用例报告无量纲的平均绝对相对误差（小数形式）。\n- 您的程序应生成单行输出，其中包含四个测试用例的平均误差，格式为逗号分隔的列表，并用方括号括起，例如 $[e_1,e_2,e_3,e_4]$，其中每个 $e_i$ 是一个小数。\n\n科学真实性和约束：\n- 仅使用概述的假设和推导，从给定的基本定律出发。不要使用任何单元矩阵的快捷公式。\n- 最终比较必须忽略平凡的零波数模态。\n- 在取平方根时，通过滤除低于某个小容差的特征值 $\\lambda$ 来确保数值稳定性。\n\n您的最终答案必须是一个完整的、可运行的程序，该程序执行这些步骤并以指定格式打印结果。",
            "solution": "用户提供了一个有效且定义明确的问题，要求推导并实现二维有限元方法（FEM），以求解刚性壁矩形腔的声学本征模态。推导将从基本的线性声波方程开始，进而得到亥姆霍兹方程及其对应的弱形式。随后，将推导等参双线性四边形单元的单元刚度、质量和阻尼矩阵。最后，这些单元将构成一个数值程序的基础，用于求解指定的特征值问题，并量化与已知解析解的离散误差。\n\n线性、无粘性和无损耗声学的控制方程是声压 $p(\\mathbf{x}, t)$ 的波动方程，其中 $\\mathbf{x} = (x, y)$ 是空间坐标，$t$ 是时间：\n$$\n\\frac{1}{c^2}\\frac{\\partial^2 p}{\\partial t^2} - \\nabla^2 p = 0\n$$\n这里，$c$ 是介质中的声速，$\\nabla^2$ 是拉普拉斯算子。计算域是一个矩形 $\\Omega = [0, L_x] \\times [0, L_y]$。边界壁是刚性的，意味着法向质点速度为零。根据线性化的欧拉方程 $\\rho_0 \\frac{\\partial \\mathbf{v}}{\\partial t} = -\\nabla p$，该边界条件转化为压力的齐次诺伊曼条件：\n$$\n\\frac{\\partial p}{\\partial n} = \\nabla p \\cdot \\mathbf{n} = 0 \\quad \\text{在 } \\partial\\Omega \\text{ 上}\n$$\n其中 $\\mathbf{n}$ 是边界 $\\partial\\Omega$ 上指向外部的单位法向量。\n\n为求声腔的本征模态（固有频率和模态振型），我们假设一个形式为 $p(\\mathbf{x},t) = \\Re\\{ \\hat{p}(\\mathbf{x}) e^{\\mathrm{i}\\omega t} \\}$ 的时谐解，其中 $\\hat{p}(\\mathbf{x})$ 是复压幅，$\\omega$ 是角频率，$\\mathrm{i} = \\sqrt{-1}$。将此时谐拟设代入波动方程，得到关于 $\\hat{p}(\\mathbf{x})$ 的不含时亥姆霍兹方程（为简化符号，下文省略帽子符号）：\n$$\n\\nabla^2 p + \\frac{\\omega^2}{c^2} p = 0 \\quad \\implies \\quad \\nabla^2 p + k^2 p = 0\n$$\n其中 $k = \\omega/c$ 是声学波数。\n\n为推导有限元公式，我们首先构建亥姆霍兹方程的弱形式。我们将其乘以一个足够光滑的试函数 $w(\\mathbf{x})$，并在域 $\\Omega$ 上积分：\n$$\n\\int_{\\Omega} w (\\nabla^2 p + k^2 p) \\,d\\Omega = 0\n$$\n对拉普拉斯项应用分部积分（格林第一恒等式）得到：\n$$\n\\int_{\\Omega} (-\\nabla w \\cdot \\nabla p + k^2 w p) \\,d\\Omega + \\int_{\\partial\\Omega} w (\\nabla p \\cdot \\mathbf{n}) \\,dS = 0\n$$\n由于刚性壁边界条件 $\\nabla p \\cdot \\mathbf{n} = 0$，边界积分项消失。这留下了问题的弱形式：寻找 $p \\in H^1(\\Omega)$，使得对于所有试函数 $w \\in H^1(\\Omega)$：\n$$\n\\int_{\\Omega} \\nabla w \\cdot \\nabla p \\,d\\Omega - k^2 \\int_{\\Omega} w p \\,d\\Omega = 0\n$$\n\n下一步是将域 $\\Omega$ 离散化为不重叠的有限元网格 $\\Omega_e$。在每个单元内，压力场 $p$ 通过节点值 $p_j$ 和形函数 $N_j(\\mathbf{x})$ 的线性组合来近似：\n$$\np(\\mathbf{x}) \\approx p_h(\\mathbf{x}) = \\sum_{j=1}^{N_{\\text{nodes}}} p_j N_j(\\mathbf{x})\n$$\n在伽辽金方法中，试函数 $w$ 从与试探函数相同的基函数中选取，即对于 $i=1, \\dots, N_{\\text{nodes}}$，有 $w = N_i(\\mathbf{x})$。将这些代入弱形式，我们得到一个关于节点压力值 $p_j$ 的线性方程组：\n$$\n\\sum_{j=1}^{N_{\\text{nodes}}} \\left( \\int_{\\Omega} \\nabla N_i \\cdot \\nabla N_j \\,d\\Omega \\right) p_j - k^2 \\sum_{j=1}^{N_{\\text{nodes}}} \\left( \\int_{\\Omega} N_i N_j \\,d\\Omega \\right) p_j = 0\n$$\n该方程必须对每个基函数 $i=1, \\dots, N_{\\text{nodes}}$ 都成立，从而导出矩阵特征值问题：\n$$\n\\mathbf{K} \\mathbf{p} = k^2 \\mathbf{M} \\mathbf{p}\n$$\n其中 $\\mathbf{p}$ 是节点压力向量，全局刚度矩阵 $\\mathbf{K}$ 和质量矩阵 $\\mathbf{M}$ 的元素为：\n$$\nK_{ij} = \\int_{\\Omega} \\nabla N_i \\cdot \\nabla N_j \\,d\\Omega \\quad \\text{和} \\quad M_{ij} = \\int_{\\Omega} N_i N_j \\,d\\Omega\n$$\n这些全局矩阵是通过对每个单元的贡献求和来组装的：\n$$\nK_{ij} = \\sum_e K_{ij}^e = \\sum_e \\int_{\\Omega_e} \\nabla N_i \\cdot \\nabla N_j \\,d\\Omega \\quad \\text{和} \\quad M_{ij} = \\sum_e M_{ij}^e = \\sum_e \\int_{\\Omega_e} N_i N_j \\,d\\Omega\n$$\n\n我们使用四节点等参四边形单元。几何形状和场变量使用相同的形函数进行插值。我们在一个具有局部坐标 $(\\xi, \\eta)$ 的标准参考方域 $\\hat{\\Omega} = [-1, 1] \\times [-1, 1]$ 中定义单元。双线性形函数为：\n$$\n\\begin{aligned}\nN_1(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta) \\\\\nN_2(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta) \\\\\nN_3(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta) \\\\\nN_4(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)\n\\end{aligned}\n$$\n从参考坐标 $(\\xi, \\eta)$ 到物理坐标 $(x, y)$ 的映射由 $\\mathbf{x}(\\xi, \\eta) = \\sum_{a=1}^4 \\mathbf{x}_a N_a(\\xi, \\eta)$ 给出，其中 $\\mathbf{x}_a$ 是单元四个节点的物理坐标。\n\n物理坐标中的导数通过变换的雅可比矩阵 $\\mathbf{J}$ 与参考坐标中的导数相关联：\n$$\n\\begin{pmatrix} \\partial/\\partial\\xi \\\\ \\partial/\\partial\\eta \\end{pmatrix} = \\begin{pmatrix} \\partial x/\\partial\\xi & \\partial y/\\partial\\xi \\\\ \\partial x/\\partial\\eta & \\partial y/\\partial\\eta \\end{pmatrix} \\begin{pmatrix} \\partial/\\partial x \\\\ \\partial/\\partial y \\end{pmatrix} = \\mathbf{J}^T \\begin{pmatrix} \\partial/\\partial x \\\\ \\partial/\\partial y \\end{pmatrix}\n$$\n雅可比矩阵的标准定义是 $\\mathbf{J} = \\begin{pmatrix} \\partial x/\\partial\\xi & \\partial x/\\partial\\eta \\\\ \\partial y/\\partial\\xi & \\partial y/\\partial\\eta \\end{pmatrix}$。因此 $\\nabla_{\\mathbf{x}} N_a = \\mathbf{J}^{-T} \\nabla_{\\boldsymbol{\\xi}} N_a$。形函数在物理坐标中的梯度为 $\\nabla N_a = (\\partial N_a/\\partial x, \\partial N_a/\\partial y)^T$。\n\n单元矩阵积分必须转换到参考域中。微分面积元变换为 $d\\Omega = dx\\,dy = \\det(\\mathbf{J}) d\\xi\\,d\\eta$。对于一个单元“e”，其局部节点索引为 $a, b \\in \\{1,2,3,4\\}$，单元刚度矩阵和质量矩阵为：\n$$\nK_{ab}^e = \\int_{-1}^1 \\int_{-1}^1 \\left( \\nabla_{\\mathbf{x}} N_a \\cdot \\nabla_{\\mathbf{x}} N_b \\right) \\det(\\mathbf{J}) \\,d\\xi\\,d\\eta\n$$\n$$\nM_{ab}^e = \\int_{-1}^1 \\int_{-1}^1 N_a N_b \\det(\\mathbf{J}) \\,d\\xi\\,d\\eta\n$$\n这些积分使用 $2 \\times 2$ 高斯求积进行数值计算。对于函数 $f(\\xi, \\eta)$，积分近似为 $\\int_{-1}^1 \\int_{-1}^1 f(\\xi, \\eta) \\,d\\xi\\,d\\eta \\approx \\sum_{g=1}^4 w_g f(\\xi_g, \\eta_g)$，其中 $(\\xi_g, \\eta_g)$ 是高斯点，$w_g$ 是对应的权重。对于 $2 \\times 2$ 求积，点是 $(\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$，所有权重都是 $1$。\n\n问题还要求推导一个阻尼矩阵。模拟与压力变化率成正比的线性体积损耗，会在波动方程中增加一个项 $\\beta \\frac{\\partial p}{\\partial t}$。\n$$\n\\frac{1}{c^2}\\frac{\\partial^2 p}{\\partial t^2} + \\beta \\frac{\\partial p}{\\partial t} - \\nabla^2 p = 0\n$$\n应用时谐拟设得到 $\\left(-\\frac{\\omega^2}{c^2} + \\mathrm{i}\\omega\\beta \\right) p - \\nabla^2 p = 0$。弱形式增加了一项 $\\int_\\Omega \\mathrm{i}\\omega\\beta w p \\,d\\Omega$。在无阻尼情况下，这会离散化为一个时域矩阵方程 $\\frac{1}{c^2}\\mathbf{M} \\ddot{\\mathbf{p}} + \\mathbf{C} \\dot{\\mathbf{p}} + \\mathbf{K} \\mathbf{p} = \\mathbf{0}$，其中单元阻尼矩阵 $\\mathbf{C}^e$ 由下式给出：\n$$\nC_{ab}^e = \\int_{\\Omega_e} c^2 \\beta N_a N_b \\, d\\Omega = c^2 \\beta \\int_{-1}^1 \\int_{-1}^1 N_a N_b \\det(\\mathbf{J}) \\,d\\xi\\,d\\eta = c^2 \\beta M_{ab}^e\n$$\n所以，阻尼矩阵与质量矩阵成正比。对于本征值分析，阻尼被忽略（$\\beta=0$）。\n\n最终的步骤是：从单元矩阵组装全局矩阵 $\\mathbf{K}$ 和 $\\mathbf{M}$，求解广义特征值问题 $\\mathbf{K} \\mathbf{p} = \\lambda \\mathbf{M} \\mathbf{p}$ 以得到特征值 $\\lambda_i = k_i^2$，然后计算波数 $k_i = \\sqrt{\\lambda_i}$。将计算出的数值波数与矩形腔的解析值 $k_{n_x, n_y} = \\sqrt{(\\frac{n_x\\pi}{L_x})^2 + (\\frac{n_y\\pi}{L_y})^2}$进行比较，以量化误差。在这个比较中，忽略 $k=0$（$n_x=n_y=0$）的平凡模态。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Solves the 2D acoustic eigenproblem for a rectangular cavity using FEM\n    and computes the error against the analytical solution for several mesh densities.\n    \"\"\"\n\n    test_cases = [\n        # (Lx, Ly, Nx, Ny, c, m)\n        (1.0, 0.8, 2, 2, 343.0, 4),\n        (1.0, 0.8, 4, 4, 343.0, 4),\n        (1.0, 0.8, 8, 8, 343.0, 4),\n        (1.0, 0.8, 16, 16, 343.0, 4),\n    ]\n\n    results = []\n    for case in test_cases:\n        Lx, Ly, Nx, Ny, c, m = case\n        error = compute_fem_error(Lx, Ly, Nx, Ny, m)\n        results.append(f\"{error:.8f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef get_analytical_wavenumbers(Lx, Ly, num_modes):\n    \"\"\"\n    Computes the analytical wavenumbers for a rigid-walled rectangular cavity.\n    \"\"\"\n    nx_max = num_modes + 4  # Search a larger space to ensure correct ordering\n    ny_max = num_modes + 4\n    \n    k_sq_anal = []\n    # Generate a set of modes to sort\n    for nx in range(nx_max):\n        for ny in range(ny_max):\n            # The mode (0,0) is the trivial k=0 mode\n            if nx == 0 and ny == 0:\n                continue\n            k_sq = (nx * np.pi / Lx)**2 + (ny * np.pi / Ly)**2\n            k_sq_anal.append(k_sq)\n    \n    # Get unique sorted squared wavenumbers and ignore the first (trivial) one\n    k_sq_anal = sorted(list(set(k_sq_anal)))\n    \n    # Return the first `num_modes` non-trivial wavenumbers\n    return np.sqrt(k_sq_anal[:num_modes])\n\ndef compute_fem_error(Lx, Ly, Nx, Ny, m):\n    \"\"\"\n    Computes the mean absolute relative error for a given FEM setup.\n    \n    Args:\n        Lx, Ly (float): Domain dimensions.\n        Nx, Ny (int): Number of elements in each direction.\n        m (int): Number of non-trivial modes to compare.\n\n    Returns:\n        float: The mean absolute relative error.\n    \"\"\"\n    \n    # 1. Mesh Generation\n    num_nodes_x = Nx + 1\n    num_nodes_y = Ny + 1\n    total_nodes = num_nodes_x * num_nodes_y\n    total_elements = Nx * Ny\n\n    x_coords = np.linspace(0, Lx, num_nodes_x)\n    y_coords = np.linspace(0, Ly, num_nodes_y)\n    nodes = np.array([[x, y] for y in y_coords for x in x_coords])\n\n    elements = np.zeros((total_elements, 4), dtype=int)\n    for iy in range(Ny):\n        for ix in range(Nx):\n            el_idx = iy * Nx + ix\n            n1 = iy * num_nodes_x + ix\n            n2 = n1 + 1\n            n3 = (iy + 1) * num_nodes_x + ix + 1\n            n4 = (iy + 1) * num_nodes_x + ix\n            elements[el_idx] = [n1, n2, n3, n4]\n\n    # 2. FEM Assembly\n    # Gauss quadrature points and weights for 2x2 scheme\n    gp = 1.0 / np.sqrt(3.0)\n    gauss_points = [(-gp, -gp), (gp, -gp), (gp, gp), (-gp, gp)]\n    gauss_weights = [1.0, 1.0, 1.0, 1.0]\n\n    # Shape functions and their derivatives in reference coordinates\n    def N_vals(xi, eta):\n        return 0.25 * np.array([(1-xi)*(1-eta), (1+xi)*(1-eta), (1+xi)*(1+eta), (1-xi)*(1+eta)])\n\n    def dN_dxi_eta(xi, eta):\n        return 0.25 * np.array([\n            [-(1-eta),  (1-eta), (1+eta), -(1+eta)],  # dN/dxi\n            [-(1-xi),  -(1+xi), (1+xi),  (1-xi)]   # dN/deta\n        ])\n\n    K_global = np.zeros((total_nodes, total_nodes))\n    M_global = np.zeros((total_nodes, total_nodes))\n\n    for el_nodes_indices in elements:\n        el_nodes_coords = nodes[el_nodes_indices]\n        Ke = np.zeros((4, 4))\n        Me = np.zeros((4, 4))\n\n        for i, (xi, eta) in enumerate(gauss_points):\n            w = gauss_weights[i]\n            \n            # Shape functions and their derivatives at the Gauss point\n            N = N_vals(xi, eta)\n            dN_dref = dN_dxi_eta(xi, eta)\n\n            # Jacobian\n            J = np.dot(dN_dref, el_nodes_coords)\n            detJ = np.linalg.det(J)\n            J_inv = np.linalg.inv(J)\n\n            # Derivatives in physical coordinates\n            dN_dphys = np.dot(J_inv, dN_dref)\n\n            # Accumulate element matrices\n            Ke += np.dot(dN_dphys.T, dN_dphys) * detJ * w\n            Me += np.outer(N, N) * detJ * w\n        \n        # Assemble into global matrices\n        ix = np.ix_(el_nodes_indices, el_nodes_indices)\n        K_global[ix] += Ke\n        M_global[ix] += Me\n\n    # 3. Solve Eigenvalue Problem\n    # K.p = lambda * M.p, where lambda = k^2\n    # eigh returns sorted eigenvalues\n    eigenvalues, _ = eigh(K_global, M_global)\n\n    # Filter out small numerical noise (physically, lambda >= 0)\n    # The first eigenvalue corresponds to the trivial k=0 mode.\n    # We are interested in the first m non-trivial modes.\n    positive_eigenvalues = eigenvalues[eigenvalues > 1e-9]\n    k_num = np.sqrt(positive_eigenvalues[:m])\n\n    # 4. Get Analytical Wavenumbers\n    k_anal = get_analytical_wavenumbers(Lx, Ly, m)\n\n    # 5. Compute Error\n    relative_errors = np.abs((k_num - k_anal) / k_anal)\n    mean_abs_relative_error = np.mean(relative_errors)\n\n    return mean_abs_relative_error\n\nsolve()\n```"
        },
        {
            "introduction": "在工程实践中，声学问题往往涉及与结构的相互作用，而不仅仅是简单的刚性或开放边界。这项实践将引导你学习如何将一个物理边界（例如弹性面板）建模为频率相关的声阻抗 $Z(\\omega)$，并将其作为边界矩阵贡献整合到有限元系统中。完成此练习将展示如何构建和实现更复杂、更符合物理实际的边界条件，这是振动声学建模中的一项关键技能。",
            "id": "4122202",
            "problem": "考虑一个薄弹性面板，它将一个静止的可压缩流体域与自由空间隔开。流体由线性时谐声场建模。在已知表面积上承受均匀声压载荷时，该面板表现出弹性行为，并产生微小的横向位移。您必须从第一性原理出发，推导该面板的有效声阻抗 $Z(\\omega)$，并使用有限元法（FEM）在声学域中将其实现为边界矩阵贡献。然后，您必须评估阻抗和所得边界矩阵对角频率的依赖性。角频率使用弧度/秒，任何需要物理单位的量均以指定单位表示。\n\n使用的基本原理：\n- 频率域中声学的线性动量平衡，其中环境密度为 $\\rho_0$ 的流体服从声压和质点速度之间的线性化关系。\n- 面板横向运动的小变形结构动力学，具有一致的单元质量、阻尼和刚度定义（如果载荷的对称性、面板的均匀性和薄性证明其合理，则允许模态降阶到单个广义坐标）。\n- 声阻抗的定义，即边界处声压与法向质点速度之间的复数比。\n\n任务：\n1. 从上述基本定律和定义出发，推导面板对流体所呈现的有效声阻抗 $Z(\\omega)$ 的表达式，明确显示单元质量、阻尼和刚度如何进入表达式。您的推导必须与通过面板区域上的均匀压力载荷实现的物理上有意义的耦合相一致。\n2. 使用流体中压力的亥姆霍兹方程的标准弱形式，推导在长度为 $L$ 的直边界段上使用双节点线性形函数施加阻抗边界条件所产生的边界矩阵的形式。边界内积的系数必须用 $\\omega$、$\\rho_0$ 和 $Z(\\omega)$ 表示，并且边界单元矩阵的条目必须通过在单元上对形函数乘积进行精确积分来获得。\n3. 实现一个程序，对于下面的每个测试用例，计算：\n   - $Z(\\omega)$ 的实部（单位：$\\mathrm{Pa\\cdot s/m}$）。\n   - $Z(\\omega)$ 的虚部（单位：$\\mathrm{Pa\\cdot s/m}$）。\n   - 对于具有双节点线性形函数的长度为 $L$ 的直段，所得 $2\\times 2$ 边界单元矩阵的弗罗贝尼乌斯范数（无单位）。\n   您的程序必须使用推导出的表达式，不得依赖外部数据。\n\n需采纳的假设：\n- 该面板很薄，在均匀压力作用下，其行为如同一个单自由度振子，具有广义质量 $m$、粘性阻尼 $c$、刚度 $k$ 和总受载面积 $A$。\n- 时间相关性为谐波形式 $\\mathrm{e}^{\\mathrm{i}\\omega t}$，其中 $\\mathrm{i}$ 是虚数单位。\n- 声学网格中的边界段是直的，长度为 $L$，并且在该段上阻抗是恒定的。\n\n单位：\n- 质量 $m$ 的单位为 $\\mathrm{kg}$。\n- 阻尼 $c$ 的单位为 $\\mathrm{N\\cdot s/m}$。\n- 刚度 $k$ 的单位为 $\\mathrm{N/m}$。\n- 面积 $A$ 的单位为 $\\mathrm{m^2}$。\n- 环境密度 $\\rho_0$ 的单位为 $\\mathrm{kg/m^3}$。\n- 边界段长度 $L$ 的单位为 $\\mathrm{m}$。\n- 角频率 $\\omega$ 的单位为 $\\mathrm{rad/s}$。\n- 阻抗 $Z(\\omega)$ 的单位为 $\\mathrm{Pa\\cdot s/m}$。\n- 边界矩阵的弗罗贝尼乌斯范数是无量纲的。\n\n测试套件：\n为以下参数集提供结果，这些参数集旨在覆盖一个代表性的“理想路径”、小阻尼下的近共振行为以及一个高频区：\n\n- 情况 $1$ (理想路径): $m=2.0$, $c=10.0$, $k=5000.0$, $A=0.5$, $\\rho_0=1.225$, $L=1.0$, $\\omega=10.0$。\n- 情况 $2$ (近共振，小阻尼): $m=2.0$, $c=0.1$, $k=5000.0$, $A=0.5$, $\\rho_0=1.225$, $L=1.0$, $\\omega=50.0$。\n- 情况 $3$ (高频): $m=2.0$, $c=10.0$, $k=5000.0$, $A=0.5$, $\\rho_0=1.225$, $L=0.2$, $\\omega=200.0$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例必须按顺序贡献一个包含三个浮点数的列表 $[\\Re(Z),\\Im(Z),\\|B\\|_F]$，其中 $\\Re(Z)$ 和 $\\Im(Z)$ 的单位是 $\\mathrm{Pa\\cdot s/m}$，$\\|B\\|_F$ 是无量纲的。将每个浮点数四舍五入到 $5$ 位小数。例如：$[[x_1,y_1,z_1],[x_2,y_2,z_2],[x_3,y_3,z_3]]$。",
            "solution": "用户提供的问题已根据指定标准进行了分析和验证。\n\n### 问题验证\n\n#### 第1步：提取已知条件\n- **物理系统**：一个薄弹性面板，将一个静止的可压缩流体域与自由空间隔开。\n- **流体模型**：线性时谐声场，由线性化动量平衡控制，环境流体密度为 $\\rho_0$。\n- **结构模型**：面板被建模为单自由度振子，具有广义质量 $m$、粘性阻尼 $c$ 和刚度 $k$，对其表面积 $A$ 上的均匀声压作出微小横向位移响应。\n- **时间约定**：谐波时间依赖性形式为 $\\mathrm{e}^{\\mathrm{i}\\omega t}$，其中 $\\mathrm{i}$ 是虚数单位，$\\omega$ 是角频率。\n- **声阻抗定义**：$Z(\\omega)$ 是流体-面板界面处声压与法向质点速度的复数比。\n- **有限元法（FEM）公式**：任务要求使用压力的亥姆霍兹方程的弱形式，并将阻抗条件施加在长度为 $L$ 的直边界段上。离散化使用双节点线性形函数。\n- **单位**：所有物理量都指定了其各自的国际单位制（SI）单位：$m$ 单位为 $\\mathrm{kg}$，$c$ 单位为 $\\mathrm{N\\cdot s/m}$，$k$ 单位为 $\\mathrm{N/m}$，$A$ 单位为 $\\mathrm{m^2}$，$\\rho_0$ 单位为 $\\mathrm{kg/m^3}$，$L$ 单位为 $\\mathrm{m}$，$\\omega$ 单位为 $\\mathrm{rad/s}$，$Z(\\omega)$ 单位为 $\\mathrm{Pa\\cdot s/m}$。\n- **测试数据**：提供了三个特定的参数集（测试用例）用于计算。\n\n#### 第2步：使用提取的已知条件进行验证\n- **科学基础（关键）**：该问题基于线性声学（亥姆霍兹方程）、结构动力学（单自由度振子模型）及其通过阻抗边界条件的耦合等基本原理。这些是计算振动声学中标准且成熟的概念。对于均匀载荷下面板的低频响应，单自由度模型是一种有效且常见的简化。\n- **适定性**：问题是适定的。它提供了一套完整的物理参数、模型假设和数学定义，足以推导阻抗及其相应边界矩阵的唯一解析表达式。计算任务定义明确。\n- **客观性（关键）**：问题以客观、精确和标准的科学语言表述，没有歧义或主观性陈述。\n- **完整性和一致性**：问题是自洽且内部一致的。没有缺失的参数或相互矛盾的约束。\n- **可行性**：物理模型和参数是现实的，并且在计算上是可处理的。\n- **结论**：问题没有表现出验证清单中列出的任何缺陷。它是一个有效、表述良好的计算声学问题。\n\n#### 第3步：结论与行动\n问题有效。将提供一个完整、合理的解决方案。\n\n### 推导与求解\n\n解决方案按要求分为三部分：面板声阻抗的推导、相应有限元边界矩阵的推导以及计算实现计划。\n\n#### 第1部分：声阻抗 $Z(\\omega)$ 的推导\n\n我们首先将弹性面板建模为单自由度（SDOF）系统。设 $u(t)$ 为面板的广义横向位移。该系统在外力 $F(t)$ 作用下的运动方程为：\n$$ m \\frac{d^2u}{dt^2} + c \\frac{du}{dt} + k u = F(t) $$\n面板受到均匀声压 $p(t)$ 在其表面积 $A$ 上的加载。因此，总力为 $F(t) = p(t)A$。运动方程变为：\n$$ m \\ddot{u} + c \\dot{u} + k u = p(t)A $$\n我们假设所有动态变量都具有 $\\mathrm{e}^{\\mathrm{i}\\omega t}$ 形式的时谐依赖性。位移和压力可以写为 $u(t) = \\hat{u}\\mathrm{e}^{\\mathrm{i}\\omega t}$ 和 $p(t) = \\hat{p}\\mathrm{e}^{\\mathrm{i}\\omega t}$，其中 $\\hat{u}$ 和 $\\hat{p}$ 是复振幅。时间导数为 $\\dot{u}(t) = \\mathrm{i}\\omega \\hat{u}\\mathrm{e}^{\\mathrm{i}\\omega t}$ 和 $\\ddot{u}(t) = -\\omega^2 \\hat{u}\\mathrm{e}^{\\mathrm{i}\\omega t}$。将这些代入运动方程并除以公因子 $\\mathrm{e}^{\\mathrm{i}\\omega t}$，得到频域方程：\n$$ (-\\omega^2 m + \\mathrm{i}\\omega c + k) \\hat{u} = \\hat{p}A $$\n求解复位移振幅 $\\hat{u}$ 得：\n$$ \\hat{u} = \\frac{\\hat{p}A}{k - \\omega^2 m + \\mathrm{i}\\omega c} $$\n流体-面板界面处的法向质点速度 $v_n(t)$ 是面板位移的时间导数，即 $v_n(t) = \\dot{u}(t)$。在频域中，速度的复振幅为 $\\hat{v}_n = \\mathrm{i}\\omega \\hat{u}$。代入 $\\hat{u}$ 的表达式：\n$$ \\hat{v}_n = \\frac{\\mathrm{i}\\omega \\hat{p}A}{k - \\omega^2 m + \\mathrm{i}\\omega c} $$\n声阻抗 $Z(\\omega)$ 定义为边界处复声压振幅与复法向质点速度振幅之比：\n$$ Z(\\omega) = \\frac{\\hat{p}}{\\hat{v}_n} $$\n代入 $\\hat{v}_n$ 的表达式，我们得到面板的阻抗：\n$$ Z(\\omega) = \\frac{\\hat{p}}{\\frac{\\mathrm{i}\\omega \\hat{p}A}{k - \\omega^2 m + \\mathrm{i}\\omega c}} = \\frac{k - \\omega^2 m + \\mathrm{i}\\omega c}{\\mathrm{i}\\omega A} $$\n为了求出实部和虚部，我们分离各项：\n$$ Z(\\omega) = \\frac{\\mathrm{i}\\omega c}{\\mathrm{i}\\omega A} + \\frac{k - \\omega^2 m}{\\mathrm{i}\\omega A} = \\frac{c}{A} - \\mathrm{i}\\frac{k - \\omega^2 m}{\\omega A} = \\frac{c}{A} + \\mathrm{i}\\left(\\frac{\\omega^2 m - k}{\\omega A}\\right) $$\n因此，阻抗的实部和虚部分别为：\n$$ \\Re(Z(\\omega)) = \\frac{c}{A} $$\n$$ \\Im(Z(\\omega)) = \\frac{\\omega m}{A} - \\frac{k}{\\omega A} $$\n\n#### 第2部分：FEM边界矩阵的推导\n\n线性声场由复压振幅 $\\hat{p}$ 的亥姆霍兹方程控制：\n$$ \\nabla^2 \\hat{p} + k_w^2 \\hat{p} = 0 $$\n其中 $k_w = \\omega/c_0$ 是声波数，$c_0$ 是流体中的声速。通过乘以一个检验函数 $w$ 并在流体域 $\\Omega$ 上积分得到弱形式：\n$$ \\int_{\\Omega} (\\nabla^2 \\hat{p} + k_w^2 \\hat{p})w \\,d\\Omega = 0 $$\n对拉普拉斯项应用格林第一恒等式得到：\n$$ \\int_{\\Omega} (-\\nabla \\hat{p} \\cdot \\nabla w + k_w^2 \\hat{p}w) \\,d\\Omega + \\int_{\\partial \\Omega} w \\frac{\\partial \\hat{p}}{\\partial n} \\,dS = 0 $$\n频域中的线性化动量方程为 $\\nabla \\hat{p} = -\\mathrm{i}\\omega\\rho_0 \\hat{\\mathbf{v}}$，其中 $\\hat{\\mathbf{v}}$ 是复质点速度矢量。压力的法向导数与法向质点速度 $\\hat{v}_n$ 的关系为：\n$$ \\frac{\\partial \\hat{p}}{\\partial n} = \\mathbf{n}\\cdot\\nabla \\hat{p} = -\\mathrm{i}\\omega\\rho_0 (\\mathbf{n}\\cdot\\hat{\\mathbf{v}}) = -\\mathrm{i}\\omega\\rho_0 \\hat{v}_n $$\n使用阻抗关系 $\\hat{p} = Z(\\omega)\\hat{v}_n$，我们可以将 $\\hat{v}_n$ 表示为 $\\hat{v}_n = \\hat{p}/Z(\\omega)$。将此代入压力梯度的表达式中得到：\n$$ \\frac{\\partial \\hat{p}}{\\partial n} = -\\mathrm{i}\\omega\\rho_0 \\frac{\\hat{p}}{Z(\\omega)} $$\n将此阻抗边界条件代入弱形式的边界积分中：\n$$ \\int_{\\partial \\Omega} w \\left(-\\mathrm{i}\\omega\\rho_0 \\frac{\\hat{p}}{Z(\\omega)}\\right) \\,dS = -\\mathrm{i}\\omega\\rho_0 \\int_{\\partial \\Omega} \\frac{1}{Z(\\omega)} \\hat{p}w \\,dS $$\n完整的弱形式为：\n$$ \\int_{\\Omega} (\\nabla \\hat{p} \\cdot \\nabla w - k_w^2 \\hat{p}w) \\,d\\Omega - \\mathrm{i}\\omega\\rho_0 \\int_{\\partial \\Omega_I} \\frac{1}{Z(\\omega)} \\hat{p}w \\,dS = 0 $$\n这里我们重新整理了各项，$\\partial\\Omega_I$ 是具有阻抗 $Z(\\omega)$ 的边界部分。边界积分项产生了边界矩阵的贡献。用形函数 $N_i$ 将压力离散化为 $\\hat{p} = \\sum_j P_j N_j$，并设置检验函数 $w = N_i$，边界矩阵 $\\mathbf{B}$ 的条目为：\n$$ B_{ij} = -\\mathrm{i}\\omega\\rho_0 \\int_{\\Gamma_e} \\frac{1}{Z(\\omega)} N_i N_j \\,dS $$\n注意：符号约定取决于边界项在弱形式中如何移动。在声学有限元法中，我们采用一种常见约定，将此项与刚度矩阵和质量矩阵一起放在左侧，这导致阻抗贡献项为正号（源于 $\\int \\nabla p \\cdot \\nabla w \\,d\\Omega = \\dots + \\int w \\frac{\\partial p}{\\partial n} dS$）。弱形式为 $\\int \\nabla p \\cdot \\nabla w - k_w^2 p w + \\int w \\frac{\\partial p}{\\partial n} = 0$。使用 $\\frac{\\partial p}{\\partial n} = -i\\omega\\rho_0 p / Z$，边界积分为 $\\int (-i\\omega\\rho_0/Z) p w$。这是不正确的。法线 $\\mathbf{n}$ 指向流体域外部。面板速度相对于流体是向内的。因此 $v_{n,fluid} = - \\dot{u}_{panel}$。这引入了一个符号变化。让我们重新评估。$v_{n,fluid} = \\hat{v}_{n,fluid} e^{i\\omega t}$，$u = \\hat{u} e^{i\\omega t}$。$v_{n,fluid} = -\\dot{u}$。$\\hat{v}_{n,fluid} = -i\\omega \\hat{u}$。流体感受到的阻抗是 $Z_{fluid} = \\hat{p}/\\hat{v}_{n,fluid} = \\hat{p}/(-i\\omega\\hat{u}) = -Z_{panel}$。然而，标准的阻抗定义几乎总是取为 $p/v_n$，其中 $v_n$ 是流体域的向外法向速度。我们假设问题使用标准定义，其中 $v_n$ 是流体域的向外法向速度。那么 $\\frac{\\partial \\hat{p}}{\\partial n} = -i\\omega\\rho_0 \\hat{v}_n = -i\\omega\\rho_0 \\frac{\\hat{p}}{Z(\\omega)}$。弱形式中的边界项是 $\\int w \\frac{\\partial \\hat{p}}{\\partial n} dS$。矩阵组装将此项添加到全局系统中。因此，边界矩阵条目确实是 $B_{ij} = \\int_{\\Gamma_e} N_i \\frac{\\partial \\hat{p}}{\\partial n_j} dS \\rightarrow \\int (-i\\omega\\rho_0/Z) N_i N_j dS$。问题要求的是贡献，这通常是被添加的。如果我们将最终系统定义为 $(\\mathbf{K} - \\omega^2 \\mathbf{M} - \\mathbf{C}) \\mathbf{P} = \\mathbf{F}$，则阻抗项是 $\\mathbf{C}$。让我们坚持导致要添加到左侧矩阵的项的推导：\n$$ \\mathbf{B}_{ij} = \\mathrm{i}\\omega\\rho_0 \\frac{1}{Z(\\omega)} \\int_{\\Gamma_e} N_i N_j \\,dS $$\n对于长度为 $L$ 的2节点线性单元，局部坐标 $\\xi \\in [-1, 1]$ 中的形函数为 $N_1 = (1-\\xi)/2$ 和 $N_2 = (1+\\xi)/2$。积分是在单元长度上进行的，$dS=dx = (L/2)d\\xi$。形函数乘积的积分矩阵为：\n$$ \\int_{\\Gamma_e} \\begin{pmatrix} N_1^2 & N_1 N_2 \\\\ N_2 N_1 & N_2^2 \\end{pmatrix} \\,dS = \\int_{-1}^1 \\begin{pmatrix} (\\frac{1-\\xi}{2})^2 & \\frac{1-\\xi^2}{4} \\\\ \\frac{1-\\xi^2}{4} & (\\frac{1+\\xi}{2})^2 \\end{pmatrix} \\frac{L}{2} \\,d\\xi = \\frac{L}{2} \\begin{pmatrix} 2/3 & 1/3 \\\\ 1/3 & 2/3 \\end{pmatrix} = \\frac{L}{6} \\begin{pmatrix} 2 & 1 \\\\ 1 & 2 \\end{pmatrix} $$\n最终的 $2 \\times 2$ 边界单元矩阵 $\\mathbf{B}$ 是：\n$$ \\mathbf{B}(\\omega) = \\frac{\\mathrm{i}\\omega\\rho_0}{Z(\\omega)} \\frac{L}{6} \\begin{pmatrix} 2 & 1 \\\\ 1 & 2 \\end{pmatrix} $$\n\n#### 第3部分：计算公式\n\n每个测试用例需要计算的量是 $\\Re(Z(\\omega))$、$\\Im(Z(\\omega))$ 和弗罗贝尼乌斯范数 $\\|\\mathbf{B}\\|_F$。\n阻抗分量在第1部分中已推导：\n$$ \\Re(Z) = \\frac{c}{A}, \\quad \\Im(Z) = \\frac{\\omega m - k/\\omega}{A} $$\n矩阵 $\\mathbf{B}$ 的弗罗贝尼乌斯范数定义为 $\\|\\mathbf{B}\\|_F = \\sqrt{\\sum_{i,j} |B_{ij}|^2}$。设标量前置因子为 $\\alpha = \\frac{\\mathrm{i}\\omega\\rho_0 L}{6Z(\\omega)}$。则 $\\mathbf{B} = \\alpha \\begin{pmatrix} 2 & 1 \\\\ 1 & 2 \\end{pmatrix}$。\n范数的平方为：\n$$ \\|\\mathbf{B}\\|_F^2 = |2\\alpha|^2 + |\\alpha|^2 + |\\alpha|^2 + |2\\alpha|^2 = (4+1+1+4)|\\alpha|^2 = 10|\\alpha|^2 $$\n范数为 $\\|\\mathbf{B}\\|_F = \\sqrt{10}|\\alpha|$。标量 $\\alpha$ 的模为：\n$$ |\\alpha| = \\left|\\frac{\\mathrm{i}\\omega\\rho_0 L}{6Z(\\omega)}\\right| = \\frac{|\\mathrm{i}|\\omega\\rho_0 L}{6|Z(\\omega)|} = \\frac{\\omega\\rho_0 L}{6|Z(\\omega)|} $$\n其中 $|Z(\\omega)| = \\sqrt{(\\Re(Z))^2 + (\\Im(Z))^2}$。\n因此，弗罗贝尼乌斯范数的最终公式为：\n$$ \\|\\mathbf{B}\\|_F = \\frac{\\sqrt{10} \\omega\\rho_0 L}{6 \\sqrt{(\\frac{c}{A})^2 + (\\frac{\\omega m - k/\\omega}{A})^2}} $$\n这些公式在提供的Python代码中实现，以生成指定测试用例的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the effective acoustic impedance and boundary matrix norm for a\n    panel-fluid interface based on a derived analytical model.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (m, c, k, A, rho0, L, omega)\n    test_cases = [\n        # Case 1 (happy path)\n        (2.0, 10.0, 5000.0, 0.5, 1.225, 1.0, 10.0),\n        # Case 2 (near resonance, small damping)\n        (2.0, 0.1, 5000.0, 0.5, 1.225, 1.0, 50.0),\n        # Case 3 (high frequency)\n        (2.0, 10.0, 5000.0, 0.5, 1.225, 0.2, 200.0),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Unpack parameters for the current test case\n        m, c, k, A, rho0, L, omega = case\n\n        # 1. Compute the real and imaginary parts of the acoustic impedance Z(omega)\n        # Re(Z) = c / A\n        # Im(Z) = (omega * m - k / omega) / A\n        \n        # Guard against omega being zero, although not in test cases\n        if omega == 0:\n            # At omega=0, Im(Z) is undefined. Handle as an error or special case.\n            # For this problem's constraints, we can assume omega > 0.\n            # As a practical matter, impedance would be stiffness dominated and very large.\n            # We'll proceed assuming omega > 0 as per the test suite.\n            pass\n\n        re_Z = c / A\n        im_Z = (omega * m - k / omega) / A\n\n        # 2. Compute the Frobenius norm of the boundary element matrix B\n        # ||B||_F = sqrt(10) * |alpha|\n        # alpha = i * omega * rho0 * L / (6 * Z)\n        # |alpha| = omega * rho0 * L / (6 * |Z|)\n        # |Z| = sqrt(Re(Z)^2 + Im(Z)^2)\n        \n        abs_Z = np.sqrt(re_Z**2 + im_Z**2)\n        \n        # Guard against zero impedance (pure resonance with zero damping)\n        if abs_Z == 0:\n            # The norm would be infinite. In the given cases, damping c > 0,\n            # so Re(Z) > 0 and thus abs_Z > 0.\n            frobenius_norm_B = float('inf')\n        else:\n            frobenius_norm_B = (np.sqrt(10) * omega * rho0 * L) / (6 * abs_Z)\n\n        # Store the results for this case, rounded to 5 decimal places\n        case_result = [\n            round(re_Z, 5), \n            round(im_Z, 5), \n            round(frobenius_norm_B, 5)\n        ]\n        results.append(case_result)\n\n    # Final print statement in the exact required format: [[r1,i1,n1],[r2,i2,n2],...]\n    # Using a custom formatter to prevent scientific notation and ensure consistency.\n    def format_list(lst):\n        return f\"[{','.join(f'{x:.5f}' for x in lst)}]\"\n\n    output_str = f\"[{','.join(format_list(res) for res in results)}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "有限元模拟的准确性在很大程度上取决于单元矩阵的精确计算，这对于几何形状扭曲或弯曲的单元来说尤其具有挑战性。本练习旨在设计一种自适应求积方案，该方案能够自动调整其精度，以处理由等参映射的雅可比行列式 $\\det J(\\boldsymbol{\\xi})$ 变化所反映的单元几何复杂性。这项高级实践将使你深入了解有限元方法的数值核心，并掌握确保模拟结果鲁棒性和准确性的关键技术。",
            "id": "4122169",
            "problem": "您的任务是为计算声学中的等参弯曲四边形有限元设计、实现并验证一种自适应数值求积方案，其明确目标是限制单元刚度矩阵 $K_e$ 和单元质量矩阵 $M_e$ 的相对误差。最终交付成果必须是一个完整、可运行的程序，该程序能够计算并报告对于给定的单元和容差测试套件，是否达到了有界相对误差目标。\n\n从以下物理和数学基础开始：\n\n- 在质量密度为 $\\rho$、体积模量为 $\\kappa$ 的均匀介质中，角频率为 $\\omega$ 的时谐声学由声压 $p$ 的标量 Helmholtz 方程控制：\n$$-\\nabla \\cdot \\left(\\frac{1}{\\rho} \\nabla p\\right) - \\frac{\\omega^2}{\\kappa} p = 0.$$\n\n- 使用有限元法 (FEM)，单个四边形等参单元的弱形式，其形函数为 $N_i$，得到单元刚度矩阵 $K_e$ 和质量矩阵 $M_e$ 的项：\n$$[K_e]_{ij} = \\int_{\\Omega_e} \\frac{1}{\\rho} \\nabla N_i \\cdot \\nabla N_j \\, d\\Omega,$$\n$$[M_e]_{ij} = \\int_{\\Omega_e} \\frac{\\omega^2}{\\kappa} N_i N_j \\, d\\Omega,$$\n其中 $\\Omega_e$ 是物理单元域。\n\n- 对于一个四节点等参双线性四边形单元，父（参考）坐标 $(\\xi,\\eta)$ 位于正方形 $[-1,1] \\times [-1,1]$ 内，到物理坐标 $(x,y)$ 的单元映射为：\n$$x(\\xi,\\eta) = \\sum_{a=1}^{4} N_a(\\xi,\\eta) x_a, \\quad y(\\xi,\\eta) = \\sum_{a=1}^{4} N_a(\\xi,\\eta) y_a,$$\n其中 $(x_a,y_a)$ 是节点的物理坐标，双线性形函数为：\n$$N_1(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta), \\quad N_2(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta),$$\n$$N_3(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta), \\quad N_4(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta).$$\n\n- 映射的雅可比矩阵是：\n$$J(\\xi,\\eta) = \\begin{bmatrix}\n\\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta} \\\\\n\\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta}\n\\end{bmatrix},$$\n其行列式为 $\\det J(\\xi,\\eta)$，逆矩阵为 $J^{-1}(\\xi,\\eta)$。物理梯度通过以下方式与父坐标梯度相关联：\n$$\\nabla N_i = J(\\xi,\\eta)^{-T} \\begin{bmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta} \\end{bmatrix}.$$\n积分通过在父正方形上进行计算：\n$$[K_e]_{ij} = \\int_{-1}^{1}\\int_{-1}^{1} \\frac{1}{\\rho} \\left(\\nabla N_i(\\xi,\\eta) \\cdot \\nabla N_j(\\xi,\\eta)\\right) \\, \\det J(\\xi,\\eta) \\, d\\xi \\, d\\eta,$$\n$$[M_e]_{ij} = \\int_{-1}^{1}\\int_{-1}^{1} \\frac{\\omega^2}{\\kappa} N_i(\\xi,\\eta) N_j(\\xi,\\eta) \\, \\det J(\\xi,\\eta) \\, d\\xi \\, d\\eta.$$\n\n您的求积方案必须满足以下要求：\n\n- 它必须在父域 $[-1,1] \\times [-1,1]$ 上操作，并支持雅可比行列式 $\\det J(\\boldsymbol{\\xi})$ 在整个域内变化剧烈的弯曲等参单元。\n\n- 它必须是自适应的：将父域递归地细分为 $(\\xi,\\eta)$ 中的轴对齐矩形片，并在每个片上应用阶数为 $n$ 的张量积高斯-勒让德求积以获得低阶近似，以及阶数为 $2n$ 的高斯-勒让德求积以获得高阶近似。使用低阶和高阶结果之间的差异作为误差估计器。\n\n- 使用基于全局低阶和高阶矩阵之差的弗罗贝尼乌斯范数的全局停止准则。用 $\\|\\cdot\\|_F$ 表示弗罗贝尼乌斯范数。定义刚度的全局相对误差为：\n$$r_K = \\frac{\\|K_e^{(2n)} - K_e^{(n)}\\|_F}{\\max\\{\\|K_e^{(2n)}\\|_F, \\varepsilon\\}},$$\n质量的全局相对误差类似：\n$$r_M = \\frac{\\|M_e^{(2n)} - M_e^{(n)}\\|_F}{\\max\\{\\|M_e^{(2n)}\\|_F, \\varepsilon\\}},$$\n其中 $\\varepsilon$ 是一个小的正则化参数（例如，$\\varepsilon=10^{-16}$）。当 $\\max\\{r_K, r_M\\} \\leq \\tau$（其中 $\\tau$ 是指定的容差）或达到最大细分深度时终止。\n\n- 在每次迭代中，细化对误差估计器绝对贡献之和最大的单个片，其中片级别的贡献通过以下方式衡量：\n$$e_{\\text{patch}} = \\|K_{\\text{patch}}^{(2n)} - K_{\\text{patch}}^{(n)}\\|_F + \\|M_{\\text{patch}}^{(2n)} - M_{\\text{patch}}^{(n)}\\|_F.$$\n\n验证协议：\n\n- 为了验证自适应方案对 $K_e$ 和 $M_e$ 均达到了有界相对误差目标，通过在整个父域上使用高阶均匀高斯-勒让德求积计算一个高保真参考值，并测量最终自适应结果与此参考值之间的相对误差：\n$$\\mathrm{rel}_K = \\frac{\\|K_e^{\\text{adaptive}} - K_e^{\\text{ref}}\\|_F}{\\|K_e^{\\text{ref}}\\|_F}, \\quad \\mathrm{rel}_M = \\frac{\\|M_e^{\\text{adaptive}} - M_e^{\\text{ref}}\\|_F}{\\|M_e^{\\text{ref}}\\|_F}.$$\n如果 $\\max\\{\\mathrm{rel}_K,\\mathrm{rel}_M\\} \\leq \\tau$，则声明成功。\n\n实现约束：\n\n- 在两个方向上均使用高斯-勒让德求积，并使用上述双线性形函数进行精确的等参映射。\n- 从一个初始求积阶数 $n$ 和一个最大细分深度开始；选择合理的固定值并在所有测试用例中一致地使用它们。\n- 处理 $\\det J(\\xi,\\eta)$ 变得很小但为正的情况；测试套件将避免反转单元（即在整个积分域内 $\\det J$ 为负）。\n\n测试套件：\n\n提供四个难度和扭曲程度递增的测试用例。对于每个测试用例，参数包括节点坐标 $\\{(x_a,y_a)\\}_{a=1}^4$、质量密度 $\\rho$（单位 $\\mathrm{kg/m^3}$）、体积模量 $\\kappa$（单位 $\\mathrm{Pa}$）和角频率 $\\omega$（单位 $\\mathrm{rad/s}$），以及容差 $\\tau$。使用以下值：\n\n- 测试用例 1（近似均匀映射，严格容差）：\n  - 节点：$(0,0)$, $(1,0)$, $(1,1)$, $(0,1)$。\n  - $\\rho = 1.225$, $\\kappa = 1.42\\times 10^{5}$, $\\omega = 2\\pi \\cdot 800$。\n  - 容差 $\\tau = 10^{-8}$。\n\n- 测试用例 2（强烈扭曲但凸的单元）：\n  - 节点：$(0,0)$, $(2,0.1)$, $(1.5,1.4)$, $(-0.2,1.0)$。\n  - $\\rho = 1.225$, $\\kappa = 1.42\\times 10^{5}$, $\\omega = 2\\pi \\cdot 3000$。\n  - 容差 $\\tau = 10^{-5}$。\n\n- 测试用例 3（高纵横比，轻度弯曲）：\n  - 节点：$(0,0)$, $(5.0,0.0)$, $(5.2,0.05)$, $(0.2,0.1)$。\n  - $\\rho = 1.225$, $\\kappa = 1.42\\times 10^{5}$, $\\omega = 2\\pi \\cdot 3000$。\n  - 容差 $\\tau = 10^{-4}$。\n\n- 测试用例 4（对扭曲单元的极严容差压力测试）：\n  - 节点：$(0,0)$, $(2.0,0.2)$, $(1.8,1.3)$, $(-0.1,0.9)$。\n  - $\\rho = 1.225$, $\\kappa = 1.42\\times 10^{5}$, $\\omega = 2\\pi \\cdot 3000$。\n  - 容差 $\\tau = 10^{-10}$。\n\n最终输出规范：\n\n- 对于每个测试用例，使用自适应方案计算 $K_e$ 和 $M_e$，计算高阶参考值，并根据上述验证协议报告自适应方案是否对 $K_e$ 和 $M_e$ 都达到了目标容差 $\\tau$。\n- 您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[result1,result2,result3,result4]$），其中每个 $result$ 是一个布尔值，表示相应测试用例的成功（$\\text{True}$）或失败（$\\text{False}$）。\n- 输出中不需要物理单位，因为结果是布尔值和无量纲的。",
            "solution": "所提出的问题是计算工程领域中一个明确定义的标准练习，特别是在将有限元法（FEM）应用于计算声学方面。它要求设计并实现一种自适应求积方案，以精确计算等参四边形单元的单元刚度矩阵和质量矩阵。所有物理原理、数学公式和算法要求都与该领域的既定理论和实践一致。因此，该问题被认为是有效的。\n\n解决方案首先建立等参单元的数学框架，然后详细说明用于计算所需矩阵的自适应数值积分算法，最后描述验证协议。\n\n**1. 等参有限元公式**\n\n均匀介质中的时谐声波传播由亥姆霍兹方程控制：\n$$-\\nabla \\cdot \\left(\\frac{1}{\\rho} \\nabla p\\right) - \\frac{\\omega^2}{\\kappa} p = 0$$\n其中 $p$ 是声压，$\\rho$ 是质量密度，$\\kappa$ 是体积模量，$\\omega$ 是角频率。当在单个有限元域 $\\Omega_e$ 上离散化时，其弱形式产生单元刚度矩阵 $[K_e]$ 和质量矩阵 $[M_e]$：\n$$[K_e]_{ij} = \\int_{\\Omega_e} \\frac{1}{\\rho} (\\nabla N_i \\cdot \\nabla N_j) \\, d\\Omega$$\n$$[M_e]_{ij} = \\int_{\\Omega_e} \\frac{\\omega^2}{\\kappa} N_i N_j \\, d\\Omega$$\n这里，$N_i$ 和 $N_j$ 是有限元形函数。对于一个四节点双线性四边形单元，形函数定义在父域 $(\\xi, \\eta) \\in [-1,1] \\times [-1,1]$ 上，如下所示：\n$$N_1(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta), \\quad N_2(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)$$\n$$N_3(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta), \\quad N_4(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)$$\n等参映射使用这些相同的形函数和单元四个节点的物理坐标 $(x_a, y_a)$，将父坐标 $(\\xi, \\eta)$ 与物理坐标 $(x,y)$ 关联起来：\n$$x(\\xi,\\eta) = \\sum_{a=1}^{4} N_a(\\xi,\\eta) x_a, \\quad y(\\xi,\\eta) = \\sum_{a=1}^{4} N_a(\\xi,\\eta) y_a$$\n为了将积分从物理域 $\\Omega_e$ 转换到父域，我们引入该变换的雅可比矩阵：\n$$J(\\xi,\\eta) = \\begin{bmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\xi} \\\\ \\frac{\\partial x}{\\partial \\eta} & \\frac{\\partial y}{\\partial \\eta} \\end{bmatrix}^T = \\begin{bmatrix} \\sum_a \\frac{\\partial N_a}{\\partial \\xi} x_a & \\sum_a \\frac{\\partial N_a}{\\partial \\xi} y_a \\\\ \\sum_a \\frac{\\partial N_a}{\\partial \\eta} x_a & \\sum_a \\frac{\\partial N_a}{\\partial \\eta} y_a \\end{bmatrix}^T$$\n微分面积元变换为 $d\\Omega = \\det J(\\xi,\\eta) \\, d\\xi \\, d\\eta$。物理梯度 $\\nabla N_i$ 通过雅可比矩阵的逆与父空间梯度相关联：\n$$\\nabla N_i = \\begin{pmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{pmatrix} = J(\\xi,\\eta)^{-T} \\begin{pmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta} \\end{pmatrix}$$\n单元矩阵的积分变为：\n$$[K_e]_{ij} = \\int_{-1}^{1}\\int_{-1}^{1} \\frac{1}{\\rho} \\left( \\left( J^{-T} \\nabla_\\xi N_i \\right) \\cdot \\left( J^{-T} \\nabla_\\xi N_j \\right) \\right) \\det J \\, d\\xi d\\eta$$\n$$[M_e]_{ij} = \\int_{-1}^{1}\\int_{-1}^{1} \\frac{\\omega^2}{\\kappa} N_i(\\xi,\\eta) N_j(\\xi,\\eta) \\, \\det J(\\xi,\\eta) \\, d\\xi d\\eta$$\n其中 $\\nabla_\\xi N_i = (\\partial N_i / \\partial \\xi, \\partial N_i / \\partial \\eta)^T$。对于一般的弯曲单元，被积函数不再是简单的多项式，因此需要数值求积。\n\n**2. 自适应数值求积**\n\n该解决方案的核心是一种旨在控制积分误差的自适应求积方案。该方案递归地将父域 $[-1,1] \\times [-1,1]$ 细分为更小的矩形片，在被积函数复杂的地方（即单元最扭曲的地方）投入更多的计算力。\n\n算法流程如下：\n1.  **初始化**：过程始于一个代表整个父域 $[-1,1] \\times [-1,1]$ 的单个片。使用一个优先队列（实现为最大堆）来管理这些片，按其积分误差的估计值排序。\n2.  **误差估计**：对于每个片，使用张量积高斯-勒让德求积法则计算两次 $[K_e]$ 和 $[M_e]$ 的积分。首先使用低阶（点数）$n$，得到 $K_{\\text{patch}}^{(n)}$ 和 $M_{\\text{patch}}^{(n)}$，然后使用高阶 $2n$，得到 $K_{\\text{patch}}^{(2n)}$ 和 $M_{\\text{patch}}^{(2n)}$。这些结果之间的差异作为误差估计器。一个片的标量误差定义为：\n    $$e_{\\text{patch}} = \\|K_{\\text{patch}}^{(2n)} - K_{\\text{patch}}^{(n)}\\|_F + \\|M_{\\text{patch}}^{(2n)} - M_{\\text{patch}}^{(n)}\\|_F$$\n    其中 $\\|\\cdot\\|_F$ 是弗罗贝尼乌斯范数。对于此实现，我们选择 $n=2$ 和 $2n=4$。\n3.  **细化循环**：算法迭代地细化域。在每个步骤中：\n    a. 从优先队列中选择误差 $e_{\\text{patch}}$ 最大的片。\n    b. 将该片细分为四个相等的、更小的、轴对齐的子片。\n    c. 为每个新的子片计算低阶和高阶积分以及误差 $e_{\\text{patch}}$。然后将该子片添加到优先队列中。\n    d. 通过减去父片的贡献并加上四个新子片的贡献来维护全局矩阵总计（$K_e^{(n)}, M_e^{(n)}, K_e^{(2n)}, M_e^{(2n)}$）。\n4.  **停止准则**：当估计的全局相对误差低于规定的容差 $\\tau$，或达到最大细化迭代次数时，循环终止。全局相对误差定义为：\n    $$r_K = \\frac{\\|K_e^{(2n)} - K_e^{(n)}\\|_F}{\\max\\{\\|K_e^{(2n)}\\|_F, \\varepsilon\\}}, \\quad r_M = \\frac{\\|M_e^{(2n)} - M_e^{(n)}\\|_F}{\\max\\{\\|M_e^{(2n)}\\|_F, \\varepsilon\\}}$$\n    当 $\\max\\{r_K, r_M\\} \\leq \\tau$ 时，算法停止。最终的“自适应”结果取自高阶计算，即 $K_e^{\\text{adaptive}} = K_e^{(2n)}$ 和 $M_e^{\\text{adaptive}} = M_e^{(2n)}$。一个小的正则化参数 $\\varepsilon=10^{-16}$ 确保数值稳定性。\n\n**3. 验证协议**\n\n为了验证自适应方案确实达到了目标精度，将其结果与高保真参考解进行比较。该参考解 $K_e^{\\text{ref}}$ 和 $M_e^{\\text{ref}}$ 是通过在整个父域上应用单一、非常高阶（$N_{\\text{ref}}=20$）的均匀高斯-勒让德求积来计算的。然后计算真实的相对误差：\n$$\\mathrm{rel}_K = \\frac{\\|K_e^{\\text{adaptive}} - K_e^{\\text{ref}}\\|_F}{\\|K_e^{\\text{ref}}\\|_F}, \\quad \\mathrm{rel}_M = \\frac{\\|M_e^{\\text{adaptive}} - M_e^{\\text{ref}}\\|_F}{\\|M_e^{\\text{ref}}\\|_F}$$\n如果计算结果满足与此可信参考的精度要求，即 $\\max\\{\\mathrm{rel}_K, \\mathrm{rel}_M\\} \\leq \\tau$，则认为该测试用例成功。该协议验证了自适应误差控制器的有效性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\nimport heapq\nimport itertools\n\n# --- Configuration ---\nN_LOW = 2\nN_HIGH = 4  # Should be 2 * N_LOW\nN_REF = 20\nMAX_ITERATIONS = 500\nEPS = 1e-16\n\n# --- Pre-compute Gauss-Legendre points and weights ---\nGL_POINTS, GL_WEIGHTS = {}, {}\nfor n in [N_LOW, N_HIGH, N_REF]:\n    points, weights = roots_legendre(n)\n    GL_POINTS[n] = points\n    GL_WEIGHTS[n] = weights\n\nclass Patch:\n    \"\"\"Represents a rectangular patch in the parent domain.\"\"\"\n    _ids = itertools.count()\n\n    def __init__(self, bounds, depth, K_low, M_low, K_high, M_high, error):\n        self.bounds = bounds  # (xi_min, xi_max, eta_min, eta_max)\n        self.depth = depth\n        self.K_low = K_low\n        self.M_low = M_low\n        self.K_high = K_high\n        self.M_high = M_high\n        self.error = error\n        self.id = next(self._ids)\n\n    def __lt__(self, other):\n        # heapq is a min-heap, so we compare IDs to break ties\n        return self.id  other.id\n\ndef get_shape_functions(xi, eta):\n    \"\"\"Computes shape functions and their gradients at (xi, eta).\"\"\"\n    N = 0.25 * np.array([\n        (1 - xi) * (1 - eta),\n        (1 + xi) * (1 - eta),\n        (1 + xi) * (1 + eta),\n        (1 - xi) * (1 + eta)\n    ])\n    \n    dN_dxi = 0.25 * np.array([\n        -(1 - eta),\n        (1 - eta),\n        (1 + eta),\n        -(1 + eta)\n    ])\n    \n    dN_deta = 0.25 * np.array([\n        -(1 - xi),\n        -(1 + xi),\n        (1 + xi),\n        (1 - xi)\n    ])\n    return N, dN_dxi, dN_deta\n\ndef compute_integrands(xi, eta, nodes, rho, kappa, omega):\n    \"\"\"Computes the matrix integrands for K and M at a point (xi, eta).\"\"\"\n    N, dN_dxi, dN_deta = get_shape_functions(xi, eta)\n    \n    # Jacobian matrix J\n    J = np.zeros((2, 2))\n    J[0, 0] = np.dot(dN_dxi, nodes[:, 0])  # dx/dxi\n    J[0, 1] = np.dot(dN_dxi, nodes[:, 1])  # dy/dxi\n    J[1, 0] = np.dot(dN_deta, nodes[:, 0]) # dx/deta\n    J[1, 1] = np.dot(dN_deta, nodes[:, 1]) # dy/deta\n    \n    det_J = np.linalg.det(J)\n    if det_J = 0:\n        raise ValueError(\"Jacobian determinant is non-positive.\")\n    \n    # Stiffness matrix integrand\n    # B = J^-T * [dN/dxi; dN/deta]\n    J_inv_T = np.linalg.inv(J).T\n    dN_dxi_eta = np.vstack((dN_dxi, dN_deta))\n    B = J_inv_T @ dN_dxi_eta # Shape (2, 4)\n    \n    k_integrand = (1.0 / rho) * (B.T @ B) * det_J\n    \n    # Mass matrix integrand\n    m_integrand = (omega**2 / kappa) * np.outer(N, N) * det_J\n    \n    return k_integrand, m_integrand\n\ndef integrate_on_patch(nodes, rho, kappa, omega, bounds, n_points):\n    \"\"\"Performs tensor-product Gauss quadrature on a patch.\"\"\"\n    xi_min, xi_max, eta_min, eta_max = bounds\n    K_patch = np.zeros((4, 4))\n    M_patch = np.zeros((4, 4))\n    \n    xi_pts = GL_POINTS[n_points]\n    xi_w = GL_WEIGHTS[n_points]\n    eta_pts = GL_POINTS[n_points]\n    eta_w = GL_WEIGHTS[n_points]\n    \n    # Map points and weights to the patch\n    xi_map_factor = 0.5 * (xi_max - xi_min)\n    xi_shift_factor = 0.5 * (xi_max + xi_min)\n    eta_map_factor = 0.5 * (eta_max - eta_min)\n    eta_shift_factor = 0.5 * (eta_max + eta_min)\n\n    for i in range(n_points):\n        for j in range(n_points):\n            xi = xi_map_factor * xi_pts[i] + xi_shift_factor\n            eta = eta_map_factor * eta_pts[j] + eta_shift_factor\n            \n            weight = xi_w[i] * eta_w[j] * xi_map_factor * eta_map_factor\n            \n            k_integrand, m_integrand = compute_integrands(xi, eta, nodes, rho, kappa, omega)\n            \n            K_patch += k_integrand * weight\n            M_patch += m_integrand * weight\n            \n    return K_patch, M_patch\n\ndef run_adaptive_quadrature(nodes, rho, kappa, omega, tau):\n    \"\"\"Computes K and M matrices using the adaptive quadrature scheme.\"\"\"\n    \n    # Initial patch\n    initial_bounds = (-1.0, 1.0, -1.0, 1.0)\n    K_low, M_low = integrate_on_patch(nodes, rho, kappa, omega, initial_bounds, N_LOW)\n    K_high, M_high = integrate_on_patch(nodes, rho, kappa, omega, initial_bounds, N_HIGH)\n\n    error = np.linalg.norm(K_high - K_low, 'fro') + np.linalg.norm(M_high - M_low, 'fro')\n    \n    initial_patch = Patch(initial_bounds, 0, K_low, M_low, K_high, M_high, error)\n    \n    # Priority queue (max-heap on error)\n    pq = [(-error, initial_patch)]\n    \n    # Global matrix totals\n    K_total_low, M_total_low = K_low.copy(), M_low.copy()\n    K_total_high, M_total_high = K_high.copy(), M_high.copy()\n\n    for iteration in range(MAX_ITERATIONS):\n        # Calculate global relative errors\n        norm_K_high = np.linalg.norm(K_total_high, 'fro')\n        norm_M_high = np.linalg.norm(M_total_high, 'fro')\n        \n        K_err_norm = np.linalg.norm(K_total_high - K_total_low, 'fro')\n        M_err_norm = np.linalg.norm(M_total_high - M_total_low, 'fro')\n        \n        r_K = K_err_norm / max(norm_K_high, EPS)\n        r_M = M_err_norm / max(norm_M_high, EPS)\n        \n        if max(r_K, r_M) = tau:\n            break\n            \n        if not pq:\n            break\n\n        # Get patch with largest error\n        neg_error, patch_to_refine = heapq.heappop(pq)\n        \n        # Subtract its contribution from totals\n        K_total_low -= patch_to_refine.K_low\n        M_total_low -= patch_to_refine.M_low\n        K_total_high -= patch_to_refine.K_high\n        M_total_high -= patch_to_refine.M_high\n\n        # Subdivide the patch\n        xi_min, xi_max, eta_min, eta_max = patch_to_refine.bounds\n        xi_mid = (xi_min + xi_max) / 2.0\n        eta_mid = (eta_min + eta_max) / 2.0\n        \n        sub_bounds = [\n            (xi_min, xi_mid, eta_min, eta_mid),\n            (xi_mid, xi_max, eta_min, eta_mid),\n            (xi_min, xi_mid, eta_mid, eta_max),\n            (xi_mid, xi_max, eta_mid, eta_max),\n        ]\n        \n        for bounds in sub_bounds:\n            K_low_sub, M_low_sub = integrate_on_patch(nodes, rho, kappa, omega, bounds, N_LOW)\n            K_high_sub, M_high_sub = integrate_on_patch(nodes, rho, kappa, omega, bounds, N_HIGH)\n            \n            sub_error = np.linalg.norm(K_high_sub - K_low_sub, 'fro') + \\\n                        np.linalg.norm(M_high_sub - M_low_sub, 'fro')\n                        \n            new_patch = Patch(bounds, patch_to_refine.depth + 1, K_low_sub, M_low_sub, K_high_sub, M_high_sub, sub_error)\n            heapq.heappush(pq, (-sub_error, new_patch))\n            \n            # Add new contributions to totals\n            K_total_low += K_low_sub\n            M_total_low += M_low_sub\n            K_total_high += K_high_sub\n            M_total_high += M_high_sub\n\n    return K_total_high, M_total_high\n\ndef solve_case(case_params):\n    \"\"\"Runs a single test case and verifies the result.\"\"\"\n    nodes, rho, kappa, omega, tau = case_params\n    nodes = np.array(nodes)\n\n    # Compute adaptive solution\n    K_adaptive, M_adaptive = run_adaptive_quadrature(nodes, rho, kappa, omega, tau)\n\n    # Compute high-fidelity reference solution\n    bounds = (-1.0, 1.0, -1.0, 1.0)\n    K_ref, M_ref = integrate_on_patch(nodes, rho, kappa, omega, bounds, N_REF)\n\n    # Verification\n    norm_K_ref = np.linalg.norm(K_ref, 'fro')\n    norm_M_ref = np.linalg.norm(M_ref, 'fro')\n    \n    rel_K = np.linalg.norm(K_adaptive - K_ref, 'fro') / max(norm_K_ref, EPS)\n    rel_M = np.linalg.norm(M_adaptive - M_ref, 'fro') / max(norm_M_ref, EPS)\n\n    return max(rel_K, rel_M) = tau\n\ndef solve():\n    \"\"\"Main function to run all test cases and print results.\"\"\"\n    test_cases = [\n        # Case 1: Near-uniform mapping, stringent tolerance\n        ([(0,0), (1,0), (1,1), (0,1)], 1.225, 1.42e5, 2 * np.pi * 800, 1e-8),\n        # Case 2: Strongly distorted but convex element\n        ([(0,0), (2,0.1), (1.5,1.4), (-0.2,1.0)], 1.225, 1.42e5, 2 * np.pi * 3000, 1e-5),\n        # Case 3: High aspect ratio, mild curvature\n        ([(0,0), (5.0,0.0), (5.2,0.05), (0.2,0.1)], 1.225, 1.42e5, 2 * np.pi * 3000, 1e-4),\n        # Case 4: Stress test with very tight tolerance\n        ([(0,0), (2.0,0.2), (1.8,1.3), (-0.1,0.9)], 1.225, 1.42e5, 2 * np.pi * 3000, 1e-10),\n    ]\n\n    results = []\n    for case in test_cases:\n        # The test case parameters use 'k' for kappa, so we unpack it as such.\n        nodes, rho, kappa, omega, tau = case\n        success = solve_case((nodes, rho, kappa, omega, tau))\n        results.append(success)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}