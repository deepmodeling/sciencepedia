{
    "hands_on_practices": [
        {
            "introduction": "The foundation of the Finite Element Method lies in approximating a continuous field, such as acoustic pressure, within small, simple domains called elements. This approximation is achieved using shape functions that interpolate values from the element's nodes. This first practice  provides a direct, hands-on calculation to see this process in action for a simple linear element and to quantify the resulting *interpolation error*, which is the fundamental source of inaccuracy in the method.",
            "id": "4121795",
            "problem": "In harmonic computational acoustics, the one-dimensional acoustic pressure field under time-harmonic excitation satisfies the Helmholtz equation $\\frac{d^{2}p}{dx^{2}}+k^{2}p=0$, where $k$ is the acoustic wavenumber and $p(x)$ is the complex amplitude of pressure. Over a single interval element $\\Omega_{e}=[0,h]$ with node locations at $x=0$ and $x=h$, the Finite Element Method (FEM) represents the field by interpolation using element shape functions that satisfy the Kronecker delta property at the nodes. For a linear element, the standard shape functions are $N_{1}(x)=1-\\frac{x}{h}$ and $N_{2}(x)=\\frac{x}{h}$. Let the exact field within $\\Omega_{e}$ be the function $p(x)=\\sin(kx)$, where the amplitude is dimensionless. Define the nodal interpolation operator $I_{h}$ that maps $p(x)$ to its linear interpolant $I_{h}[p](x)$ constructed from the nodal values at $x=0$ and $x=h$.\n\nStarting from the definitions above and the properties of the shape functions, derive $I_{h}[\\sin(kx)](x)$ on $[0,h]$ and then derive the pointwise interpolation error $e(x)=I_{h}[\\sin(kx)](x)-\\sin(kx)$ evaluated at the midpoint $x=\\frac{h}{2}$. Express your final answer as a single closed-form analytic expression in terms of $k$ and $h$. No numerical evaluation is required, and no rounding is needed.",
            "solution": "The one-dimensional acoustic pressure field under time-harmonic excitation obeys the Helmholtz equation $\\frac{d^{2}p}{dx^{2}}+k^{2}p=0$. A particular solution consistent with many boundary conditions on a segment is $p(x)=\\sin(kx)$, where $k$ is the acoustic wavenumber. In the Finite Element Method (FEM), the field on an element $\\Omega_{e}=[0,h]$ is approximated by an interpolation operator $I_{h}$ that uses shape functions to match nodal values. For a linear two-node element, the shape functions are $N_{1}(x)=1-\\frac{x}{h}$ and $N_{2}(x)=\\frac{x}{h}$, and they satisfy $N_{1}(0)=1$, $N_{2}(0)=0$, $N_{1}(h)=0$, $N_{2}(h)=1$, with the Kronecker delta property $N_{i}(x_{j})=\\delta_{ij}$.\n\nThe interpolation operator $I_{h}$ applied to a function $p(x)$ constructs the interpolant as\n$$\nI_{h}[p](x)=p(0)N_{1}(x)+p(h)N_{2}(x),\n$$\nby definition of nodal interpolation on the element.\n\nWe first compute the nodal values of $p(x)=\\sin(kx)$:\n$$\np(0)=\\sin(k\\cdot 0)=\\sin(0)=0,\\qquad p(h)=\\sin(kh).\n$$\nSubstituting these into the interpolation formula gives\n$$\nI_{h}[\\sin(kx)](x)=\\sin(0)\\,N_{1}(x)+\\sin(kh)\\,N_{2}(x)=0\\cdot\\left(1-\\frac{x}{h}\\right)+\\sin(kh)\\left(\\frac{x}{h}\\right)=\\frac{x}{h}\\,\\sin(kh).\n$$\n\nNext, we define the pointwise interpolation error\n$$\ne(x)=I_{h}[\\sin(kx)](x)-\\sin(kx)=\\frac{x}{h}\\,\\sin(kh)-\\sin(kx).\n$$\nWe are asked to evaluate this error at the midpoint $x=\\frac{h}{2}$. Substituting $x=\\frac{h}{2}$,\n$$\ne\\!\\left(\\frac{h}{2}\\right)=\\frac{\\frac{h}{2}}{h}\\,\\sin(kh)-\\sin\\!\\left(k\\frac{h}{2}\\right)=\\frac{1}{2}\\sin(kh)-\\sin\\!\\left(\\frac{kh}{2}\\right).\n$$\nThis is a closed-form analytic expression in terms of $k$ and $h$.\n\nFor additional insight, one can rewrite the error using trigonometric identities. Using $\\sin(kh)=2\\sin\\!\\left(\\frac{kh}{2}\\right)\\cos\\!\\left(\\frac{kh}{2}\\right)$, we find\n$$\ne\\!\\left(\\frac{h}{2}\\right)=\\sin\\!\\left(\\frac{kh}{2}\\right)\\cos\\!\\left(\\frac{kh}{2}\\right)-\\sin\\!\\left(\\frac{kh}{2}\\right)=\\sin\\!\\left(\\frac{kh}{2}\\right)\\left(\\cos\\!\\left(\\frac{kh}{2}\\right)-1\\right),\n$$\nand using $1-\\cos\\theta=2\\sin^{2}\\!\\left(\\frac{\\theta}{2}\\right)$, equivalently\n$$\ne\\!\\left(\\frac{h}{2}\\right)=-2\\,\\sin\\!\\left(\\frac{kh}{2}\\right)\\,\\sin^{2}\\!\\left(\\frac{kh}{4}\\right).\n$$\nEither form is exact. The requested final answer can be provided as $\\frac{1}{2}\\sin(kh)-\\sin\\!\\left(\\frac{kh}{2}\\right)$, which directly follows from the interpolation definition and evaluation at the midpoint.",
            "answer": "$$\\boxed{\\frac{1}{2}\\sin(kh)-\\sin\\!\\left(\\frac{kh}{2}\\right)}$$"
        },
        {
            "introduction": "After approximating the field within an element, the next step in FEM is to build the discrete system of equations by integrating expressions involving the shape functions and their derivatives. Since these integrations are typically performed numerically, a critical practical question arises: how can we ensure the integration itself does not introduce errors? This exercise  explores how to select the minimum-order Gauss-Legendre quadrature rule required to integrate the element stiffness matrix *exactly*, a key step in preserving the accuracy of the underlying polynomial approximation.",
            "id": "4121786",
            "problem": "In computational acoustics, the weak form of the acoustic Helmholtz equation yields a bilinear form whose discretization by the Finite Element Method (FEM) involves element-level matrix entries. Consider a one-dimensional, single element with an affine isoparametric mapping from a reference interval $\\xi \\in [-1, 1]$ to physical coordinates $x$, and let the stiffness matrix entry be defined by the bilinear form\n$$\nK_{ij}^{(e)} = \\int_{x_{e}} \\frac{\\mathrm{d}N_{i}}{\\mathrm{d}x} \\frac{\\mathrm{d}N_{j}}{\\mathrm{d}x} \\,\\mathrm{d}x,\n$$\nwhere $N_{i}$ and $N_{j}$ are degree-$p$ Lagrange shape functions constructed over the reference interval. Using the reference coordinate $\\xi$ and noting the affine mapping has a constant Jacobian determinant $J = \\frac{\\mathrm{d}x}{\\mathrm{d}\\xi}$, this integral can be expressed on the reference element as\n$$\nK_{ij}^{(e)} = \\int_{-1}^{1} \\left(\\frac{1}{J}\\frac{\\mathrm{d}N_{i}}{\\mathrm{d}\\xi}\\right)\\left(\\frac{1}{J}\\frac{\\mathrm{d}N_{j}}{\\mathrm{d}\\xi}\\right) J\\,\\mathrm{d}\\xi = \\frac{1}{J}\\int_{-1}^{1} \\frac{\\mathrm{d}N_{i}}{\\mathrm{d}\\xi} \\frac{\\mathrm{d}N_{j}}{\\mathrm{d}\\xi} \\,\\mathrm{d}\\xi.\n$$\nYou wish to evaluate $K_{ij}^{(e)}$ exactly using Gauss–Legendre quadrature on the reference interval.\n\nState the exactness condition for Gauss–Legendre quadrature when integrating a polynomial integrand of degree $d$, and, based on the polynomial structure of the integrand $\\frac{\\mathrm{d}N_{i}}{\\mathrm{d}\\xi} \\frac{\\mathrm{d}N_{j}}{\\mathrm{d}\\xi}$, derive the minimum number of Gauss–Legendre points $n_{\\min}$ required to exactly integrate $K_{ij}^{(e)}$ for degree-$p$ shape functions on an affine-mapped, one-dimensional element. Provide your final result as a closed-form expression in terms of $p$. No numerical rounding is required. Your final answer must be a single analytic expression.",
            "solution": "The problem requires determining the minimum number of Gauss–Legendre quadrature points, denoted as $n_{\\min}$, needed to exactly evaluate the element stiffness matrix entry $K_{ij}^{(e)}$ for degree-$p$ Lagrange shape functions on a one-dimensional, affine-mapped element.\n\nFirst, let us establish the given integral for the stiffness matrix entry on the reference element $\\xi \\in [-1, 1]$:\n$$\nK_{ij}^{(e)} = \\frac{1}{J}\\int_{-1}^{1} \\frac{\\mathrm{d}N_{i}}{\\mathrm{d}\\xi} \\frac{\\mathrm{d}N_{j}}{\\mathrm{d}\\xi} \\,\\mathrm{d}\\xi\n$$\nHere, $N_{i}(\\xi)$ and $N_{j}(\\xi)$ are Lagrange shape functions of degree $p$. The constant factor $\\frac{1}{J}$ does not affect the required quadrature rule for the integral itself. The core of the problem is to determine the polynomial degree of the integrand, which we denote as $I(\\xi)$:\n$$\nI(\\xi) = \\frac{\\mathrm{d}N_{i}}{\\mathrm{d}\\xi} \\frac{\\mathrm{d}N_{j}}{\\mathrm{d}\\xi}\n$$\nA Lagrange shape function $N_{k}(\\xi)$ of degree $p$ is, by definition, a polynomial in $\\xi$ of degree $p$. The derivative of a polynomial of degree $p$ with respect to its variable is a polynomial of degree $p-1$. Therefore, the terms $\\frac{\\mathrm{d}N_{i}}{\\mathrm{d}\\xi}$ and $\\frac{\\mathrm{d}N_{j}}{\\mathrm{d}\\xi}$ are both polynomials in $\\xi$ of degree $p-1$.\n\nThe integrand $I(\\xi)$ is the product of these two polynomials. The degree of the product of two polynomials is the sum of their individual degrees. Let $d$ be the degree of the integrand $I(\\xi)$.\n$$\nd = \\text{deg}(I(\\xi)) = \\text{deg}\\left(\\frac{\\mathrm{d}N_{i}}{\\mathrm{d}\\xi}\\right) + \\text{deg}\\left(\\frac{\\mathrm{d}N_{j}}{\\mathrm{d}\\xi}\\right)\n$$\nSubstituting the degree of each derivative, we find:\n$$\nd = (p-1) + (p-1) = 2p-2\n$$\nThus, the integrand is a polynomial of degree $2p-2$.\n\nNext, we state the exactness condition for Gauss–Legendre quadrature. An $n$-point Gauss–Legendre quadrature rule, applied over the interval $[-1, 1]$, can integrate any polynomial of degree up to $2n-1$ exactly. For our integral to be evaluated exactly using $n$ quadrature points, the degree of the integrand polynomial, $d$, must satisfy the following inequality:\n$$\nd \\le 2n - 1\n$$\nSubstituting the derived degree of our integrand, $d = 2p-2$, into this condition gives:\n$$\n2p-2 \\le 2n-1\n$$\nOur goal is to find the minimum integer number of points, $n_{\\min}$, that satisfies this condition. We solve the inequality for $n$:\n$$\n2p - 2 + 1 \\le 2n\n$$\n$$\n2p - 1 \\le 2n\n$$\n$$\nn \\ge \\frac{2p-1}{2}\n$$\nThis can be rewritten as:\n$$\nn \\ge p - \\frac{1}{2}\n$$\nSince the number of quadrature points, $n$, must be an integer, the minimum integer value of $n$ that satisfies this inequality is the smallest integer greater than or equal to $p - \\frac{1}{2}$. For any integer $p \\ge 1$, this smallest integer is $p$.\nFor example, if $p=1$, $n \\ge \\frac{1}{2}$, so $n_{\\min}=1$. If $p=2$, $n \\ge \\frac{3}{2}$, so $n_{\\min}=2$. If $p=3$, $n \\ge \\frac{5}{2}$, so $n_{\\min}=3$. This pattern demonstrates that $n_{\\min} = p$.\n\nTherefore, the minimum number of Gauss–Legendre points required to exactly integrate the stiffness matrix entry for degree-$p$ shape functions is $p$.",
            "answer": "$$\\boxed{p}$$"
        },
        {
            "introduction": "While low-order elements are robust, high-order elements promise greater accuracy, which is highly desirable for resolving complex acoustic wave fields. However, their effectiveness hinges on the choice of interpolation nodes, which governs the stability of the approximation. This computational practice  demonstrates this crucial concept by comparing the unstable behavior of equispaced nodes with the excellent stability of Gauss-Lobatto-Legendre nodes, highlighting why proper node placement is essential for reliable high-order simulations.",
            "id": "4121811",
            "problem": "Consider the interpolation of a one-dimensional acoustic pressure field on the reference finite element domain $[-1,1]$ using Lagrange polynomial shape functions of degree $p$, which are constructed from $p+1$ distinct nodal locations. In computational acoustics within the Finite Element Method (FEM), stable interpolation is critical for oscillatory fields arising from solutions to the Helmholtz equation, where high wavenumbers may lead to rapid spatial oscillations. Let the interpolation operator be defined by the Lagrange shape functions $\\ell_j(x)$ associated with nodal locations $\\{x_j\\}_{j=0}^{p}$, so that a function $f(x)$ is interpolated as $I[f](x) = \\sum_{j=0}^{p} f(x_j) \\,\\ell_j(x)$, with $\\ell_j(x_i) = \\delta_{ij}$ for all $i,j$. The Lebesgue constant $\\Lambda_{p}$ of the nodal set is defined by $\\Lambda_{p} = \\max_{x \\in [-1,1]} \\sum_{j=0}^{p} \\left| \\ell_j(x) \\right|$. The Lebesgue constant quantifies the worst-case amplification of nodal data during interpolation in the uniform norm and serves as a measure of interpolation stability. Two nodal distributions are considered: equispaced nodes and Gauss–Lobatto–Legendre (GLL) nodes. Equispaced nodes are the $p+1$ points $x_j = -1 + 2j/p$ for $j=0,\\dots,p$. Gauss–Lobatto–Legendre (GLL) nodes are defined as the union of the endpoints $x=-1$ and $x=1$ and the $p-1$ interior zeros of the derivative of the Legendre polynomial of degree $p$.\n\nStarting from the Lagrange interpolation definition and the shape function properties, implement a numerically stable algorithm to compute the Lebesgue constant $\\Lambda_{p}$ for both equispaced and Gauss–Lobatto–Legendre (GLL) nodes. Additionally, for the oscillatory acoustic field $f(x) = \\sin(k x)$, with the angle $k$ specified in radians, compute the empirical interpolation amplification $A_{p}(k) = \\max_{x \\in [-1,1]} \\left| I[f](x) \\right|$ on a uniform evaluation grid. Use a uniform evaluation grid of $20001$ points in $[-1,1]$ (including the endpoints), and use barycentric Lagrange interpolation to evaluate the shape functions and the interpolant stably. Your program must compute the Lebesgue constant by discretizing the supremum over the evaluation grid and similarly compute the empirical amplification of $f(x)=\\sin(kx)$.\n\nTest suite and output specification:\n- Use the following test cases, where angles are in radians and all outputs are dimensionless:\n    1. Case A: $p=8$, Gauss–Lobatto–Legendre nodes, $k=50$.\n    2. Case B: $p=8$, equispaced nodes, $k=50$.\n    3. Case C (boundary case): $p=1$, equispaced nodes, $k=50$.\n    4. Case D (edge case: higher oscillation): $p=8$, Gauss–Lobatto–Legendre nodes, $k=200$.\n    5. Case E (edge case: higher oscillation): $p=8$, equispaced nodes, $k=200$.\n- For each case, compute and return two quantities: the Lebesgue constant $\\Lambda_p$ and the empirical amplification $A_p(k)$. Express each numeric result as a float rounded to six decimal places.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order:\n$[\\Lambda_{8}^{\\mathrm{GLL}}, A_{8}^{\\mathrm{GLL}}(50), \\Lambda_{8}^{\\mathrm{EQ}}, A_{8}^{\\mathrm{EQ}}(50), \\Lambda_{1}^{\\mathrm{EQ}}, A_{1}^{\\mathrm{EQ}}(50), \\Lambda_{8}^{\\mathrm{GLL}}, A_{8}^{\\mathrm{GLL}}(200), \\Lambda_{8}^{\\mathrm{EQ}}, A_{8}^{\\mathrm{EQ}}(200)]$,\nwhere $\\mathrm{GLL}$ denotes Gauss–Lobatto–Legendre nodes and $\\mathrm{EQ}$ denotes equispaced nodes. For example, the output should look like $[x_1,x_2,x_3,x_4,x_5,x_6,x_7,x_8,x_9,x_{10}]$, where each $x_i$ is a float rounded to six decimal places.",
            "solution": "The problem requires the computation of two key metrics for one-dimensional polynomial interpolation on the reference interval $[-1, 1]$: the Lebesgue constant $\\Lambda_p$ and the empirical interpolation amplification $A_p(k)$ for a specific oscillatory function. These metrics are to be calculated for two different sets of interpolation nodes: equispaced nodes and Gauss-Lobatto-Legendre (GLL) nodes. The purpose is to analyze and compare the numerical stability of these two nodal distributions, a critical aspect in computational methods like the Finite Element Method (FEM), particularly for problems in acoustics involving high-wavenumber solutions to the Helmholtz equation.\n\nThe core of the problem lies in Lagrange interpolation. Given a set of $p+1$ distinct nodes $\\{x_j\\}_{j=0}^p$ in $[-1, 1]$, any continuous function $f(x)$ can be approximated by a unique polynomial of degree at most $p$, denoted $I[f](x)$, which interpolates $f(x)$ at these nodes, i.e., $I[f](x_j) = f(x_j)$. This interpolant can be expressed using Lagrange basis polynomials $\\ell_j(x)$ as:\n$$\nI[f](x) = \\sum_{j=0}^{p} f(x_j) \\ell_j(x), \\quad \\text{where} \\quad \\ell_j(x_i) = \\delta_{ij} = \\begin{cases} 1 & i = j \\\\ 0 & i \\neq j \\end{cases}\n$$\nThe stability of this interpolation process is quantified by the Lebesgue constant $\\Lambda_p$, defined as the maximum value of the Lebesgue function $\\lambda_p(x) = \\sum_{j=0}^{p} |\\ell_j(x)|$ over the interval:\n$$\n\\Lambda_p = \\max_{x \\in [-1, 1]} \\lambda_p(x) = \\max_{x \\in [-1, 1]} \\sum_{j=0}^{p} |\\ell_j(x)|\n$$\nThe Lebesgue constant provides an upper bound on the amplification of errors in the function values $f(x_j)$. A small $\\Lambda_p$ indicates a stable interpolation scheme.\n\nThe second metric, the empirical interpolation amplification $A_p(k)$, measures the maximum magnitude of the interpolant for a specific function $f(x) = \\sin(kx)$, where $k$ is a wavenumber. It is defined as:\n$$\nA_p(k) = \\max_{x \\in [-1, 1]} |I[\\sin(kx)](x)|\n$$\nThis metric provides a practical measure of how well the interpolation scheme handles a representative oscillatory function.\n\nTo compute these quantities reliably, direct evaluation of the classic formula for Lagrange polynomials, $\\ell_j(x) = \\prod_{i \\neq j} \\frac{x-x_i}{x_j-x_i}$, is numerically unstable, especially for high degrees $p$. A superior method is barycentric Lagrange interpolation. The second barycentric form expresses the interpolating polynomial as:\n$$\nI[f](x) = \\frac{\\sum_{j=0}^{p} \\frac{w_j}{x-x_j} f(x_j)}{\\sum_{j=0}^{p} \\frac{w_j}{x-x_j}}\n$$\nwhere $w_j$ are the barycentric weights, defined as $w_j = \\left( \\prod_{i \\neq j} (x_j - x_i) \\right)^{-1}$. These weights depend only on the nodal distribution and can be pre-computed. This formula is numerically stable and efficient. From this, expressions for the shape functions $\\ell_j(x)$ and the Lebesgue function $\\lambda_p(x)$ can be derived:\n$$\n\\ell_j(x) = \\frac{w_j/(x-x_j)}{\\sum_{k=0}^{p} w_k/(x-x_k)} \\quad \\implies \\quad \\lambda_p(x) = \\sum_{j=0}^{p} |\\ell_j(x)| = \\frac{\\sum_{j=0}^{p} |w_j/(x-x_j)|}{|\\sum_{k=0}^{p} w_k/(x-x_k)|}\n$$\nThese formulae are valid for $x$ not equal to any node $x_j$. If $x=x_j$, then $I[f](x_j) = f(x_j)$ and $\\lambda_p(x_j) = 1$.\n\nThe problem specifies two nodal distributions:\n1.  **Equispaced nodes**: The $p+1$ points are given by the formula $x_j = -1 + \\frac{2j}{p}$ for $j=0, 1, \\dots, p$. These nodes are known to lead to poor stability, with $\\Lambda_p$ growing exponentially with $p$.\n2.  **Gauss-Lobatto-Legendre (GLL) nodes**: These consist of the endpoints $x=-1$ and $x=1$, and the $p-1$ interior roots of the derivative of the Legendre polynomial of degree $p$, $P'_p(x)$. The roots of $P'_p(x)$ are identical to the roots of the Jacobi polynomial $P_{p-1}^{(1,1)}(x)$. These nodes cluster near the endpoints and yield excellent stability, with $\\Lambda_p$ growing only logarithmically with $p$.\n\nThe algorithm to solve the problem is as follows:\n1.  For each test case defined by $(p, \\text{node type}, k)$:\n2.  **Generate Nodes**:\n    *   For equispaced nodes, apply the formula $x_j = -1 + 2j/p$.\n    *   For GLL nodes with degree $p > 1$, compute the $p-1$ roots of the Jacobi polynomial $P_{p-1}^{(1,1)}(x)$ using a numerical library function (e.g., `scipy.special.roots_jacobi`). Combine these interior roots with the endpoints $\\{-1, 1\\}$ to form the full set of $p+1$ nodes. For $p=1$, the GLL nodes are simply $\\{-1, 1\\}$.\n3.  **Compute Barycentric Weights**: Calculate the weight $w_j$ for each node $x_j$ using the formula $w_j = (\\prod_{i \\neq j} (x_j - x_i))^{-1}$.\n4.  **Define Evaluation Grid**: Create a fine, uniform grid of $N=20001$ points, denoted $\\{x_{eval}\\}$, spanning the interval $[-1, 1]$.\n5.  **Evaluate at Nodes**: Compute the values of the function $f(x) = \\sin(kx)$ at the $p+1$ nodes: $f_j = \\sin(kx_j)$.\n6.  **Evaluate on Grid**: For each point $x$ in the evaluation grid $\\{x_{eval}\\}$:\n    *   If $x$ is numerically close to a node $x_j$, the interpolated value is $f_j$ and the Lebesgue function value is $1$.\n    *   Otherwise, use the barycentric formulae to compute $I[f](x)$ and $\\lambda_p(x)$.\n7.  **Determine Maximums**: Approximate $\\Lambda_p$ and $A_p(k)$ by finding the maximum of the computed values of $\\lambda_p(x)$ and $|I[f](x)|$ over the evaluation grid, respectively.\n8.  **Format Output**: Store the computed $\\Lambda_p$ and $A_p(k)$ for each test case, and format the final results as a single comma-separated list rounded to six decimal places.\n\nThis procedure will be implemented for all specified test cases to produce the required output, demonstrating the marked difference in interpolation stability between equispiced and GLL nodes.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import special\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem.\n    It computes Lebesgue constants and empirical amplifications for several test cases\n    and prints the results in the specified format.\n    \"\"\"\n\n    def compute_interpolation_metrics(p: int, node_type: str, k: float):\n        \"\"\"\n        Computes the Lebesgue constant and empirical amplification for a given\n        polynomial degree, node type, and wavenumber.\n\n        Args:\n            p (int): The degree of the Lagrange polynomial.\n            node_type (str): Type of nodes, 'equispaced' or 'gll'.\n            k (float): The wavenumber for the function sin(kx).\n\n        Returns:\n            tuple: A tuple containing the Lebesgue constant and the empirical amplification,\n                   both as floats.\n        \"\"\"\n        N_eval = 20001\n        x_eval = np.linspace(-1.0, 1.0, N_eval)\n\n        # Step 1: Generate interpolation nodes\n        if node_type == 'equispaced':\n            x_nodes = np.linspace(-1.0, 1.0, p + 1)\n        elif node_type == 'gll':\n            if p == 0:\n                x_nodes = np.array([0.0])\n            elif p == 1:\n                # For p=1, GLL nodes are the endpoints, same as equispaced\n                x_nodes = np.array([-1.0, 1.0])\n            else:\n                # Interior nodes are roots of P'_p(x), which are roots of Jacobi P_{p-1}^{(1,1)}(x)\n                # scipy.special.roots_jacobi requires n > 0.\n                interior_nodes, _ = special.roots_jacobi(p - 1, 1, 1)\n                x_nodes = np.concatenate(([-1.0], interior_nodes, [1.0]))\n                x_nodes.sort() # Ensure nodes are ordered\n        else:\n            raise ValueError(f\"Unknown node type: {node_type}\")\n\n        # Step 2: Compute barycentric weights\n        weights = np.ones(p + 1)\n        for j in range(p + 1):\n            # General formula for barycentric weights\n            other_nodes = np.delete(x_nodes, j)\n            weights[j] = 1.0 / np.prod(x_nodes[j] - other_nodes)\n\n        # Step 3: Evaluate function f(x) = sin(k*x) at nodes\n        f_nodes = np.sin(k * x_nodes)\n\n        # Step 4: Evaluate interpolant and Lebesgue function on the fine grid\n        lebesgue_func_vals = np.zeros(N_eval)\n        interp_vals = np.zeros(N_eval)\n\n        for i, x in enumerate(x_eval):\n            # Check if evaluation point x is very close to a node\n            is_node_mask = np.isclose(x, x_nodes)\n            if np.any(is_node_mask):\n                node_idx = np.where(is_node_mask)[0][0]\n                interp_vals[i] = f_nodes[node_idx]\n                lebesgue_func_vals[i] = 1.0\n            else:\n                # Use barycentric formulas for evaluation\n                terms = weights / (x - x_nodes)\n                sum_terms = np.sum(terms)\n                \n                # Interpolated value\n                interp_vals[i] = np.sum(terms * f_nodes) / sum_terms\n                \n                # Lebesgue function value\n                lebesgue_func_vals[i] = np.sum(np.abs(terms)) / np.abs(sum_terms)\n\n        # Step 5: Compute maximums to approximate the constants\n        lebesgue_constant = np.max(lebesgue_func_vals)\n        amplification = np.max(np.abs(interp_vals))\n\n        return lebesgue_constant, amplification\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'p': 8, 'node_type': 'gll', 'k': 50},       # Case A\n        {'p': 8, 'node_type': 'equispaced', 'k': 50}, # Case B\n        {'p': 1, 'node_type': 'equispaced', 'k': 50}, # Case C\n        {'p': 8, 'node_type': 'gll', 'k': 200},      # Case D\n        {'p': 8, 'node_type': 'equispaced', 'k': 200},# Case E\n    ]\n\n    results = []\n    for case in test_cases:\n        lambda_p, a_p_k = compute_interpolation_metrics(case['p'], case['node_type'], case['k'])\n        results.append(lambda_p)\n        results.append(a_p_k)\n\n    # Final print statement in the exact required format.\n    formatted_results = [format(r, '.6f') for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}