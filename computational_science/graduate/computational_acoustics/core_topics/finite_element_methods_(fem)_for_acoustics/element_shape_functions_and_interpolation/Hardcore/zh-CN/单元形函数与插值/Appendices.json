{
    "hands_on_practices": [
        {
            "introduction": "形函数在有限元方法中的核心作用是将连续的物理场（如声压）近似为分段多项式。这个练习将带你亲手实践最基本的插值过程。通过对一个代表声波的简谐函数（正弦波）进行线性插值，并精确计算其在单元中点的插值误差，你将直观地理解数值近似的来源及其与物理真实解之间的差异。",
            "id": "4121795",
            "problem": "在谐波计算声学中，时谐激励下的一维声压场满足亥姆霍兹方程 $\\frac{d^{2}p}{dx^{2}}+k^{2}p=0$，其中 $k$ 是声波数，$p(x)$ 是压力的复振幅。在单个区间单元 $\\Omega_{e}=[0,h]$ 上，节点位于 $x=0$ 和 $x=h$ 处，有限元法 (FEM) 使用在节点处满足克罗内克（Kronecker）$\\delta$ 性质的单元形函数通过插值来表示该场。对于线性单元，标准形函数为 $N_{1}(x)=1-\\frac{x}{h}$ 和 $N_{2}(x)=\\frac{x}{h}$。设 $\\Omega_{e}$ 内的精确场为函数 $p(x)=\\sin(kx)$，其中振幅是无量纲的。定义节点插值算子 $I_{h}$，它将 $p(x)$ 映射到由 $x=0$ 和 $x=h$ 处的节点值构造的线性插值函数 $I_{h}[p](x)$。\n\n从上述定义和形函数的性质出发，推导在 $[0,h]$ 上的 $I_{h}[\\sin(kx)](x)$，然后推导在中断点 $x=\\frac{h}{2}$ 处求值的逐点插值误差 $e(x)=I_{h}[\\sin(kx)](x)-\\sin(kx)$。将最终答案表示为关于 $k$ 和 $h$ 的单个闭式解析表达式。不需要进行数值计算，也不需要四舍五入。",
            "solution": "时谐激励下的一维声压场遵循亥姆霍兹方程 $\\frac{d^{2}p}{dx^{2}}+k^{2}p=0$。与线段上的许多边界条件一致的一个特解是 $p(x)=\\sin(kx)$，其中 $k$ 是声波数。在有限元法 (FEM) 中，单元 $\\Omega_{e}=[0,h]$ 上的场由一个插值算子 $I_{h}$ 近似，该算子使用形函数来匹配节点值。对于线性双节点单元，形函数为 $N_{1}(x)=1-\\frac{x}{h}$ 和 $N_{2}(x)=\\frac{x}{h}$，它们满足 $N_{1}(0)=1$，$N_{2}(0)=0$，$N_{1}(h)=0$，$N_{2}(h)=1$，具有克罗内克（Kronecker）$\\delta$ 性质 $N_{i}(x_{j})=\\delta_{ij}$。\n\n将插值算子 $I_{h}$ 应用于函数 $p(x)$，根据单元上节点插值的定义，构造插值函数为\n$$\nI_{h}[p](x)=p(0)N_{1}(x)+p(h)N_{2}(x),\n$$\n\n我们首先计算 $p(x)=\\sin(kx)$ 的节点值：\n$$\np(0)=\\sin(k\\cdot 0)=\\sin(0)=0,\\qquad p(h)=\\sin(kh).\n$$\n将这些值代入插值公式，得到\n$$\nI_{h}[\\sin(kx)](x)=\\sin(0)\\,N_{1}(x)+\\sin(kh)\\,N_{2}(x)=0\\cdot\\left(1-\\frac{x}{h}\\right)+\\sin(kh)\\left(\\frac{x}{h}\\right)=\\frac{x}{h}\\,\\sin(kh).\n$$\n\n接下来，我们定义逐点插值误差\n$$\ne(x)=I_{h}[\\sin(kx)](x)-\\sin(kx)=\\frac{x}{h}\\,\\sin(kh)-\\sin(kx).\n$$\n题目要求我们计算该误差在中点 $x=\\frac{h}{2}$ 处的值。代入 $x=\\frac{h}{2}$，\n$$\ne\\!\\left(\\frac{h}{2}\\right)=\\frac{\\frac{h}{2}}{h}\\,\\sin(kh)-\\sin\\!\\left(k\\frac{h}{2}\\right)=\\frac{1}{2}\\sin(kh)-\\sin\\!\\left(\\frac{kh}{2}\\right).\n$$\n这是一个关于 $k$ 和 $h$ 的闭式解析表达式。\n\n为了更深入地理解，可以使用三角恒等式重写误差。使用 $\\sin(kh)=2\\sin\\!\\left(\\frac{kh}{2}\\right)\\cos\\!\\left(\\frac{kh}{2}\\right)$，我们发现\n$$\ne\\!\\left(\\frac{h}{2}\\right)=\\sin\\!\\left(\\frac{kh}{2}\\right)\\cos\\!\\left(\\frac{kh}{2}\\right)-\\sin\\!\\left(\\frac{kh}{2}\\right)=\\sin\\!\\left(\\frac{kh}{2}\\right)\\left(\\cos\\!\\left(\\frac{kh}{2}\\right)-1\\right),\n$$\n并且使用 $1-\\cos\\theta=2\\sin^{2}\\!\\left(\\frac{\\theta}{2}\\right)$，等价地得到\n$$\ne\\!\\left(\\frac{h}{2}\\right)=-2\\,\\sin\\!\\left(\\frac{kh}{2}\\right)\\,\\sin^{2}\\!\\left(\\frac{kh}{4}\\right).\n$$\n两种形式都是精确的。所要求的最终答案可以提供为 $\\frac{1}{2}\\sin(kh)-\\sin\\!\\left(\\frac{kh}{2}\\right)$，这是从插值定义和在中点求值直接得出的。",
            "answer": "$$\\boxed{\\frac{1}{2}\\sin(kh)-\\sin\\!\\left(\\frac{kh}{2}\\right)}$$"
        },
        {
            "introduction": "在第一个练习的基础上，我们来探讨数值误差在波动问题中一个更深远、更关键的影响：数值色散。在离散的有限元网格上，波的传播速度会依赖于其波长和网格尺寸，这是一种在连续物理系统中不存在的数值伪影。本练习将引导你推导描述这一现象的数学关系式（离散色散关系），它揭示了计算声学中必须面对的一个核心挑战。",
            "id": "4121806",
            "problem": "考虑在一个具有恒定质量密度和体积模量的无界介质中的时间谐波、无损、一维声学问题，其声压场 $p(x)$ 在无穷直线上满足标量亥姆霍兹方程 $p''(x) + k^{2} p(x) = 0$，其中 $k$ 是精确波数。使用标准的连续伽辽金有限元方法 (FEM)，将直线均匀剖分为间距为 $h > 0$ 的节点 $\\{x_{j}\\}_{j \\in \\mathbb{Z}}$，并在每个单元 $[x_{j}, x_{j+1}]$ 上使用线性拉格朗日形函数，执行以下步骤：\n\n- 从亥姆霍兹方程的弱形式以及参考单元 $[-1,1]$ 上的线性形函数定义（即 $N_{1}(\\xi) = \\frac{1 - \\xi}{2}$ 和 $N_{2}(\\xi) = \\frac{1 + \\xi}{2}$）出发，并结合仿射映射 $x(\\xi) = \\frac{x_{j+1} + x_{j}}{2} + \\frac{h}{2} \\xi$。通过在参考单元上进行精确积分并映射到物理坐标，构建单元级刚度矩阵和质量矩阵。\n\n- 在均匀网格上组装全局半离散系统，并分析形式为 $p_{j} = \\exp(i j \\theta)$ 的离散平面波解，其中 $\\theta$ 是一个实相位增量。通过 $\\theta = k_{h} h$ 定义数值波数 $k_{h}$。\n\n- 从基本原理出发，推导连接 $k_{h}$、$k$ 和 $h$ 的离散色散关系，并对其进行显式求解，以获得 $k_{h}$ 作为 $k$ 和 $h$ 的函数的闭式表达式。\n\n您的最终答案必须是关于 $k_{h}$ 以 $k$ 和 $h$ 表示的单个闭式解析表达式。以米的倒数为单位报告 $k_{h}$。最终答案中不允许出现任何中间方程。如果您选择在推导过程中展示任何级数展开，必须从离散关系中给出合理的理由，但最终报告的答案必须保持精确的闭式形式。无需进行四舍五入。",
            "solution": "亥姆霍兹方程 $p''(x) + k^2 p(x) = 0$ 的弱形式是通过将其与一个检验函数 $v(x)$ 相乘，并在一个单元 $[x_j, x_{j+1}]$ 上积分得到的。通过分部积分，我们得到单元级的贡献：\n$$\n- \\int_{x_j}^{x_{j+1}} p'(x)v'(x) \\, dx + k^2 \\int_{x_j}^{x_{j+1}} p(x)v(x) \\, dx = \\text{边界项}\n$$\n在伽辽金方法中，我们使用相同的线性拉格朗日形函数来近似场 $p(x)$ 和检验函数 $v(x)$。这导出了单元刚度矩阵 $\\mathbf{K}^e$ 和质量矩阵 $\\mathbf{M}^e$：\n$$\nK^e_{ab} = \\int_{x_j}^{x_{j+1}} N'_a(x) N'_b(x) \\, dx, \\quad M^e_{ab} = \\int_{x_j}^{x_{j+1}} N_a(x) N_b(x) \\, dx\n$$\n其中 $a,b$ 是局部节点索引。为了计算这些积分，我们变换到参考单元 $\\xi \\in [-1, 1]$。映射为 $x(\\xi) = x_c + \\frac{h}{2}\\xi$，雅可比行列式为 $J = \\frac{dx}{d\\xi} = \\frac{h}{2}$。链式法则给出 $\\frac{dN}{dx} = \\frac{dN}{d\\xi} \\frac{d\\xi}{dx} = \\frac{2}{h} \\frac{dN}{d\\xi}$。\n\n参考单元上的形函数为 $N_1(\\xi) = (1-\\xi)/2$ 和 $N_2(\\xi) = (1+\\xi)/2$，其导数为 $N'_1(\\xi)=-1/2$ 和 $N'_2(\\xi)=1/2$。\n\n**单元刚度矩阵 $\\mathbf{K}^e$**:\n$$\nK^e_{11} = \\int_{-1}^{1} \\left(-\\frac{1}{h}\\right)^2 J \\,d\\xi = \\frac{1}{h^2} \\frac{h}{2} \\int_{-1}^{1} d\\xi = \\frac{1}{h}\n$$\n$$\nK^e_{12} = \\int_{-1}^{1} \\left(-\\frac{1}{h}\\right)\\left(\\frac{1}{h}\\right) J \\,d\\xi = -\\frac{1}{h^2} \\frac{h}{2} \\int_{-1}^{1} d\\xi = -\\frac{1}{h}\n$$\n因此，$\\mathbf{K}^e = \\frac{1}{h} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}$。\n\n**单元质量矩阵 $\\mathbf{M}^e$**:\n$$\nM^e_{11} = \\int_{-1}^{1} N_1(\\xi)^2 J \\,d\\xi = \\int_{-1}^{1} \\left(\\frac{1-\\xi}{2}\\right)^2 \\frac{h}{2} \\,d\\xi = \\frac{h}{3}\n$$\n$$\nM^e_{12} = \\int_{-1}^{1} N_1(\\xi)N_2(\\xi) J \\,d\\xi = \\int_{-1}^{1} \\frac{1-\\xi^2}{4} \\frac{h}{2} \\,d\\xi = \\frac{h}{6}\n$$\n因此，$\\mathbf{M}^e = \\frac{h}{6} \\begin{pmatrix} 2 & 1 \\\\ 1 & 2 \\end{pmatrix}$。\n\n对于一个通用内部节点 $j$，其离散方程是通过组合来自单元 $[x_{j-1}, x_j]$ 和 $[x_j, x_{j+1}]$ 的贡献得到的：\n$$\n\\left( -\\frac{1}{h} p_{j-1} + \\frac{2}{h} p_j - \\frac{1}{h} p_{j+1} \\right) - k^2 \\left( \\frac{h}{6} p_{j-1} + \\frac{4h}{6} p_j + \\frac{h}{6} p_{j+1} \\right) = 0\n$$\n我们代入一个形式为 $p_j = \\exp(i j \\theta)$ 的离散平面波解，其中 $\\theta = k_h h$ 是数值相移。这给出 $p_{j-1} = p_j \\exp(-i \\theta)$ 和 $p_{j+1} = p_j \\exp(i \\theta)$。代入并除以 $p_j$：\n$$\n\\frac{1}{h} (2 - (\\exp(i \\theta) + \\exp(-i \\theta))) - k^2 \\frac{h}{6} (4 + (\\exp(i \\theta) + \\exp(-i \\theta))) = 0\n$$\n使用恒等式 $\\cos(\\theta) = (\\exp(i \\theta) + \\exp(-i \\theta))/2$，方程变为：\n$$\n\\frac{2}{h} (1 - \\cos(\\theta)) - k^2 \\frac{h}{3} (2 + \\cos(\\theta)) = 0\n$$\n整理后得到离散色散关系：\n$$\n6(1 - \\cos(\\theta)) = (kh)^2 (2 + \\cos(\\theta))\n$$\n求解 $\\cos(\\theta)$：\n$$\n\\cos(\\theta) = \\frac{6 - 2(kh)^2}{6 + (kh)^2}\n$$\n最后，代入 $\\theta = k_h h$ 并求解 $k_h$：\n$$\nk_h h = \\arccos\\left( \\frac{6 - 2k^2h^2}{6 + k^2h^2} \\right)\n$$\n$$\nk_h = \\frac{1}{h} \\arccos\\left( \\frac{6 - 2k^2h^2}{6 + k^2h^2} \\right)\n$$",
            "answer": "$$\n\\boxed{\\frac{1}{h} \\arccos\\left( \\frac{6 - 2k^{2}h^{2}}{6 + k^{2}h^{2}} \\right)}\n$$"
        },
        {
            "introduction": "分析了误差的来源和后果之后，我们将焦点转向解决方案。高阶单元是提高计算精度的有效途径，但其稳定性在很大程度上取决于单元内节点（插值点）的分布。本计算练习将通过编程实践，比较两种不同的节点分布策略——均匀分布节点与高斯-洛巴托-勒让德（GLL）节点——的插值稳定性。你将通过计算勒贝格常数（Lebesgue constant）这一关键指标，来量化不同节点选择对模拟高频振荡声场稳定性的巨大影响。",
            "id": "4121811",
            "problem": "考虑在参考有限元域 $[-1,1]$ 上，使用由 $p+1$ 个不同节点位置构建的 $p$ 次拉格朗日多项式形函数，对一维声压场进行插值。在有限元方法 (FEM) 的计算声学中，稳定的插值对于亥姆霍兹方程解产生的振荡场至关重要，其中高波数可能导致快速的空间振荡。设插值算子由与节点位置 $\\{x_j\\}_{j=0}^{p}$ 相关联的拉格朗日形函数 $\\ell_j(x)$ 定义，因此函数 $f(x)$ 的插值表示为 $I[f](x) = \\sum_{j=0}^{p} f(x_j) \\,\\ell_j(x)$，其中对于所有 $i,j$，都有 $\\ell_j(x_i) = \\delta_{ij}$。节点集的勒贝格常数 $\\Lambda_{p}$ 定义为 $\\Lambda_{p} = \\max_{x \\in [-1,1]} \\sum_{j=0}^{p} \\left| \\ell_j(x) \\right|$。勒贝格常数在一致范数下量化了插值过程中节点数据的最坏情况放大率，并作为插值稳定性的一个度量。考虑两种节点分布：等距节点和高斯-洛巴托-勒让德 (GLL) 节点。等距节点是 $p+1$ 个点 $x_j = -1 + 2j/p$，其中 $j=0,\\dots,p$。高斯-洛巴托-勒让德 (GLL) 节点定义为端点 $x=-1$ 和 $x=1$ 以及 $p$ 次勒让德多项式导数的 $p-1$ 个内部零点的并集。\n\n从拉格朗日插值定义和形函数属性出发，实现一个数值稳定的算法来计算等距节点和高斯-洛巴托-勒让德 (GLL) 节点的勒贝格常数 $\\Lambda_{p}$。此外，对于振荡声场 $f(x) = \\sin(k x)$（其中角度 $k$ 以弧度为单位），在均匀评估网格上计算经验插值放大率 $A_{p}(k) = \\max_{x \\in [-1,1]} \\left| I[f](x) \\right|$。使用一个在 $[-1,1]$ 区间内包含 $20001$ 个点的均匀评估网格（包括端点），并使用重心拉格朗日插值来稳定地评估形函数和插值函数。您的程序必须通过在评估网格上离散化上确界来计算勒贝格常数，并同样计算 $f(x)=\\sin(kx)$ 的经验放大率。\n\n测试套件和输出规范：\n- 使用以下测试用例，其中角度以弧度为单位，所有输出均为无量纲：\n    1. 情况 A：$p=8$，高斯-洛巴托-勒让德节点，$k=50$。\n    2. 情况 B：$p=8$，等距节点，$k=50$。\n    3. 情况 C（边界情况）：$p=1$，等距节点，$k=50$。\n    4. 情况 D（边缘情况：更高振荡）：$p=8$，高斯-洛巴托-勒让德节点，$k=200$。\n    5. 情况 E（边缘情况：更高振荡）：$p=8$，等距节点，$k=200$。\n- 对于每种情况，计算并返回两个量：勒贝格常数 $\\Lambda_p$ 和经验放大率 $A_p(k)$。将每个数值结果表示为四舍五入到六位小数的浮点数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n$[\\Lambda_{8}^{\\mathrm{GLL}}, A_{8}^{\\mathrm{GLL}}(50), \\Lambda_{8}^{\\mathrm{EQ}}, A_{8}^{\\mathrm{EQ}}(50), \\Lambda_{1}^{\\mathrm{EQ}}, A_{1}^{\\mathrm{EQ}}(50), \\Lambda_{8}^{\\mathrm{GLL}}, A_{8}^{\\mathrm{GLL}}(200), \\Lambda_{8}^{\\mathrm{EQ}}, A_{8}^{\\mathrm{EQ}}(200)]$，\n其中 $\\mathrm{GLL}$ 表示高斯-洛巴托-勒让德节点，$\\mathrm{EQ}$ 表示等距节点。例如，输出应类似于 $[x_1,x_2,x_3,x_4,x_5,x_6,x_7,x_8,x_9,x_{10}]$，其中每个 $x_i$ 是一个四舍五入到六位小数的浮点数。",
            "solution": "该问题要求计算在一维参考区间 $[-1, 1]$ 上多项式插值的两个关键指标：勒贝格常数 $\\Lambda_p$ 和针对特定振荡函数的经验插值放大率 $A_p(k)$。这些指标需要针对两种不同的插值节点集进行计算：等距节点和高斯-洛巴托-勒让德 (GLL) 节点。其目的是分析和比较这两种节点分布的数值稳定性，这是计算方法（如有限元方法 FEM）中的一个关键方面，尤其对于声学问题中涉及亥姆霍兹方程高波数解的情况。\n\n问题的核心在于拉格朗日插值。给定 $[-1, 1]$ 区间内的 $p+1$ 个不同节点 $\\{x_j\\}_{j=0}^p$，任何连续函数 $f(x)$ 都可以通过一个唯一的、次数最多为 $p$ 的多项式 $I[f](x)$ 来近似，该多项式在这些节点上对 $f(x)$ 进行插值，即 $I[f](x_j) = f(x_j)$。这个插值多项式可以使用拉格朗日基多项式 $\\ell_j(x)$ 表示为：\n$$\nI[f](x) = \\sum_{j=0}^{p} f(x_j) \\ell_j(x), \\quad \\text{其中} \\quad \\ell_j(x_i) = \\delta_{ij} = \\begin{cases} 1  i = j \\\\ 0  i \\neq j \\end{cases}\n$$\n这个插值过程的稳定性由勒贝格常数 $\\Lambda_p$ 来量化，它定义为勒贝格函数 $\\lambda_p(x) = \\sum_{j=0}^{p} |\\ell_j(x)|$ 在该区间上的最大值：\n$$\n\\Lambda_p = \\max_{x \\in [-1, 1]} \\lambda_p(x) = \\max_{x \\in [-1, 1]} \\sum_{j=0}^{p} |\\ell_j(x)|\n$$\n勒贝格常数为函数值 $f(x_j)$ 中误差的放大提供了一个上界。较小的 $\\Lambda_p$ 表示一个稳定的插值方案。\n\n第二个指标是经验插值放大率 $A_p(k)$，它衡量了特定函数 $f(x) = \\sin(kx)$（其中 $k$ 是波数）的插值函数最大幅值。其定义为：\n$$\nA_p(k) = \\max_{x \\in [-1, 1]} |I[\\sin(kx)](x)|\n$$\n该指标提供了一个实用的度量，用以衡量插值方案处理代表性振荡函数的效果。\n\n为了可靠地计算这些量，直接评估拉格朗日多项式的经典公式 $\\ell_j(x) = \\prod_{i \\neq j} \\frac{x-x_i}{x_j-x_i}$ 在数值上是不稳定的，特别是对于高次 $p$。一种更优越的方法是重心拉格朗日插值。第二种重心形式将插值多项式表示为：\n$$\nI[f](x) = \\frac{\\sum_{j=0}^{p} \\frac{w_j}{x-x_j} f(x_j)}{\\sum_{j=0}^{p} \\frac{w_j}{x-x_j}}\n$$\n其中 $w_j$ 是重心权重，定义为 $w_j = \\left( \\prod_{i \\neq j} (x_j - x_i) \\right)^{-1}$。这些权重仅取决于节点分布，可以预先计算。这个公式在数值上是稳定且高效的。由此，可以推导出形函数 $\\ell_j(x)$ 和勒贝格函数 $\\lambda_p(x)$ 的表达式：\n$$\n\\ell_j(x) = \\frac{w_j/(x-x_j)}{\\sum_{k=0}^{p} w_k/(x-x_k)} \\quad \\implies \\quad \\lambda_p(x) = \\sum_{j=0}^{p} |\\ell_j(x)| = \\frac{\\sum_{j=0}^{p} |w_j/(x-x_j)|}{|\\sum_{k=0}^{p} w_k/(x-x_k)|}\n$$\n这些公式在 $x$ 不等于任何节点 $x_j$ 时有效。如果 $x=x_j$，那么 $I[f](x_j) = f(x_j)$ 且 $\\lambda_p(x_j) = 1$。\n\n问题指定了两种节点分布：\n1.  **等距节点**：$p+1$ 个点由公式 $x_j = -1 + \\frac{2j}{p}$ 给出，其中 $j=0, 1, \\dots, p$。已知这些节点会导致较差的稳定性，$\\Lambda_p$ 随 $p$ 指数增长。\n2.  **高斯-洛巴托-勒让德 (GLL) 节点**：这些节点包括端点 $x=-1$ 和 $x=1$，以及 $p$ 次勒让德多项式导数 $P'_p(x)$ 的 $p-1$ 个内部根。$P'_p(x)$ 的根与雅可比多项式 $P_{p-1}^{(1,1)}(x)$ 的根相同。这些节点在端点附近聚集，并产生极好的稳定性，$\\Lambda_p$ 仅随 $p$ 对数增长。\n\n解决该问题的算法如下：\n1.  对于由 $(p, \\text{节点类型}, k)$ 定义的每个测试用例：\n2.  **生成节点**：\n    *   对于等距节点，应用公式 $x_j = -1 + 2j/p$。\n    *   对于次数 $p > 1$ 的 GLL 节点，使用数值库函数（例如 `scipy.special.roots_jacobi`）计算雅可比多项式 $P_{p-1}^{(1,1)}(x)$ 的 $p-1$ 个根。将这些内部根与端点 $\\{-1, 1\\}$ 结合，形成完整的 $p+1$ 个节点集。对于 $p=1$，GLL 节点就是 $\\{-1, 1\\}$。\n3.  **计算重心权重**：使用公式 $w_j = (\\prod_{i \\neq j} (x_j - x_i))^{-1}$ 为每个节点 $x_j$ 计算权重 $w_j$。\n4.  **定义评估网格**：创建一个由 $N=20001$ 个点组成的精细、均匀的网格，记为 $\\{x_{eval}\\}$，覆盖区间 $[-1, 1]$。\n5.  **在节点处求值**：在 $p+1$ 个节点上计算函数 $f(x) = \\sin(kx)$ 的值：$f_j = \\sin(kx_j)$。\n6.  **在网格上求值**：对于评估网格 $\\{x_{eval}\\}$ 中的每个点 $x$：\n    *   如果 $x$ 在数值上接近某个节点 $x_j$，则插值结果为 $f_j$，勒贝格函数值为 $1$。\n    *   否则，使用重心公式计算 $I[f](x)$ 和 $\\lambda_p(x)$。\n7.  **确定最大值**：通过分别在评估网格上找到计算出的 $\\lambda_p(x)$ 和 $|I[f](x)|$ 的最大值来近似 $\\Lambda_p$ 和 $A_p(k)$。\n8.  **格式化输出**：存储每个测试用例计算出的 $\\Lambda_p$ 和 $A_p(k)$，并将最终结果格式化为单个逗号分隔的列表，四舍五入到六位小数。\n\n该过程将针对所有指定的测试用例实施，以生成所需的输出，从而展示等距节点和 GLL 节点在插值稳定性方面的显著差异。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import special\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem.\n    It computes Lebesgue constants and empirical amplifications for several test cases\n    and prints the results in the specified format.\n    \"\"\"\n\n    def compute_interpolation_metrics(p: int, node_type: str, k: float):\n        \"\"\"\n        Computes the Lebesgue constant and empirical amplification for a given\n        polynomial degree, node type, and wavenumber.\n\n        Args:\n            p (int): The degree of the Lagrange polynomial.\n            node_type (str): Type of nodes, 'equispaced' or 'gll'.\n            k (float): The wavenumber for the function sin(kx).\n\n        Returns:\n            tuple: A tuple containing the Lebesgue constant and the empirical amplification,\n                   both as floats.\n        \"\"\"\n        N_eval = 20001\n        x_eval = np.linspace(-1.0, 1.0, N_eval)\n\n        # Step 1: Generate interpolation nodes\n        if node_type == 'equispaced':\n            x_nodes = np.linspace(-1.0, 1.0, p + 1)\n        elif node_type == 'gll':\n            if p == 0:\n                x_nodes = np.array([0.0])\n            elif p == 1:\n                # For p=1, GLL nodes are the endpoints, same as equispaced\n                x_nodes = np.array([-1.0, 1.0])\n            else:\n                # Interior nodes are roots of P'_p(x), which are roots of Jacobi P_{p-1}^{(1,1)}(x)\n                # scipy.special.roots_jacobi requires n > 0.\n                interior_nodes, _ = special.roots_jacobi(p - 1, 1, 1)\n                x_nodes = np.concatenate(([-1.0], interior_nodes, [1.0]))\n                x_nodes.sort() # Ensure nodes are ordered\n        else:\n            raise ValueError(f\"Unknown node type: {node_type}\")\n\n        # Step 2: Compute barycentric weights\n        weights = np.ones(p + 1)\n        for j in range(p + 1):\n            # General formula for barycentric weights\n            other_nodes = np.delete(x_nodes, j)\n            weights[j] = 1.0 / np.prod(x_nodes[j] - other_nodes)\n\n        # Step 3: Evaluate function f(x) = sin(k*x) at nodes\n        f_nodes = np.sin(k * x_nodes)\n\n        # Step 4: Evaluate interpolant and Lebesgue function on the fine grid\n        lebesgue_func_vals = np.zeros(N_eval)\n        interp_vals = np.zeros(N_eval)\n\n        for i, x in enumerate(x_eval):\n            # Check if evaluation point x is very close to a node\n            is_node_mask = np.isclose(x, x_nodes)\n            if np.any(is_node_mask):\n                node_idx = np.where(is_node_mask)[0][0]\n                interp_vals[i] = f_nodes[node_idx]\n                lebesgue_func_vals[i] = 1.0\n            else:\n                # Use barycentric formulas for evaluation\n                terms = weights / (x - x_nodes)\n                sum_terms = np.sum(terms)\n                \n                # Interpolated value\n                interp_vals[i] = np.sum(terms * f_nodes) / sum_terms\n                \n                # Lebesgue function value\n                lebesgue_func_vals[i] = np.sum(np.abs(terms)) / np.abs(sum_terms)\n\n        # Step 5: Compute maximums to approximate the constants\n        lebesgue_constant = np.max(lebesgue_func_vals)\n        amplification = np.max(np.abs(interp_vals))\n\n        return lebesgue_constant, amplification\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'p': 8, 'node_type': 'gll', 'k': 50},       # Case A\n        {'p': 8, 'node_type': 'equispaced', 'k': 50}, # Case B\n        {'p': 1, 'node_type': 'equispaced', 'k': 50}, # Case C\n        {'p': 8, 'node_type': 'gll', 'k': 200},      # Case D\n        {'p': 8, 'node_type': 'equispaced', 'k': 200},# Case E\n    ]\n\n    results = []\n    for case in test_cases:\n        lambda_p, a_p_k = compute_interpolation_metrics(case['p'], case['node_type'], case['k'])\n        results.append(lambda_p)\n        results.append(a_p_k)\n\n    # Final print statement in the exact required format.\n    formatted_results = [format(r, '.6f') for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}