{
    "hands_on_practices": [
        {
            "introduction": "本练习是理解有限元方法（FEM）近似能力的基础。通过对单个线性单元上的标准正弦波进行插值，我们可以直接量化最基本的构建块所引入的局部插值误差 。这个计算不仅强化了对形函数和节点插值定义的理解，而且为分析整个有限元模型的整体精度奠定了基础。",
            "id": "4121795",
            "problem": "在谐波计算声学中，时谐激励下的一维（$1$-dimensional）声压场满足亥姆霍兹方程 $\\frac{d^{2}p}{dx^{2}}+k^{2}p=0$，其中 $k$ 是声波数，$p(x)$ 是压力的复振幅。在节点位置为 $x=0$ 和 $x=h$ 的单个区间单元 $\\Omega_{e}=[0,h]$ 上，有限元法 (FEM) 使用在节点处满足克罗内克δ性质的单元形函数，通过插值来表示该场。对于一个线性单元，其标准形函数为 $N_{1}(x)=1-\\frac{x}{h}$ 和 $N_{2}(x)=\\frac{x}{h}$。设 $\\Omega_{e}$ 内的精确场为函数 $p(x)=\\sin(kx)$，其中振幅是无量纲的。定义节点插值算子 $I_{h}$，它将 $p(x)$ 映射到由 $x=0$ 和 $x=h$ 处的节点值构造的线性插值 $I_{h}[p](x)$。\n\n从上述定义和形函数的性质出发，推导在 $[0,h]$ 上的 $I_{h}[\\sin(kx)](x)$，然后推导在其中点 $x=\\frac{h}{2}$ 处求值的逐点插值误差 $e(x)=I_{h}[\\sin(kx)](x)-\\sin(kx)$。将您的最终答案表示为关于 $k$ 和 $h$ 的单个闭式解析表达式。不需要进行数值计算，也不需要四舍五入。",
            "solution": "时谐激励下的一维（$1$-dimensional）声压场服从亥姆霍兹方程 $\\frac{d^{2}p}{dx^{2}}+k^{2}p=0$。与线段上的多种边界条件相符的一个特解是 $p(x)=\\sin(kx)$，其中 $k$ 是声波数。在有限元法 (FEM) 中，单元 $\\Omega_{e}=[0,h]$ 上的场由一个插值算子 $I_{h}$ 近似，该算子使用形函数来匹配节点值。对于一个线性双节点单元，其形函数为 $N_{1}(x)=1-\\frac{x}{h}$ 和 $N_{2}(x)=\\frac{x}{h}$，并且它们满足 $N_{1}(0)=1$, $N_{2}(0)=0$, $N_{1}(h)=0$, $N_{2}(h)=1$，具有克罗内克δ性质 $N_{i}(x_{j})=\\delta_{ij}$。\n\n根据单元上节点插值的定义，作用于函数 $p(x)$ 的插值算子 $I_{h}$ 构造插值函数如下：\n$$\nI_{h}[p](x)=p(0)N_{1}(x)+p(h)N_{2}(x),\n$$\n\n我们首先计算 $p(x)=\\sin(kx)$ 的节点值：\n$$\np(0)=\\sin(k\\cdot 0)=\\sin(0)=0,\\qquad p(h)=\\sin(kh).\n$$\n将这些值代入插值公式得到\n$$\nI_{h}[\\sin(kx)](x)=\\sin(0)\\,N_{1}(x)+\\sin(kh)\\,N_{2}(x)=0\\cdot\\left(1-\\frac{x}{h}\\right)+\\sin(kh)\\left(\\frac{x}{h}\\right)=\\frac{x}{h}\\,\\sin(kh).\n$$\n\n接下来，我们定义逐点插值误差\n$$\ne(x)=I_{h}[\\sin(kx)](x)-\\sin(kx)=\\frac{x}{h}\\,\\sin(kh)-\\sin(kx).\n$$\n我们需要计算该误差在其中点 $x=\\frac{h}{2}$ 处的值。代入 $x=\\frac{h}{2}$，\n$$\ne\\!\\left(\\frac{h}{2}\\right)=\\frac{\\frac{h}{2}}{h}\\,\\sin(kh)-\\sin\\!\\left(k\\frac{h}{2}\\right)=\\frac{1}{2}\\sin(kh)-\\sin\\!\\left(\\frac{kh}{2}\\right).\n$$\n这是一个关于 $k$ 和 $h$ 的闭式解析表达式。\n\n为了获得更深的见解，可以使用三角恒等式重写该误差。使用 $\\sin(kh)=2\\sin\\!\\left(\\frac{kh}{2}\\right)\\cos\\!\\left(\\frac{kh}{2}\\right)$，我们发现\n$$\ne\\!\\left(\\frac{h}{2}\\right)=\\sin\\!\\left(\\frac{kh}{2}\\right)\\cos\\!\\left(\\frac{kh}{2}\\right)-\\sin\\!\\left(\\frac{kh}{2}\\right)=\\sin\\!\\left(\\frac{kh}{2}\\right)\\left(\\cos\\!\\left(\\frac{kh}{2}\\right)-1\\right),\n$$\n并使用 $1-\\cos\\theta=2\\sin^{2}\\!\\left(\\frac{\\theta}{2}\\right)$，等价地\n$$\ne\\!\\left(\\frac{h}{2}\\right)=-2\\,\\sin\\!\\left(\\frac{kh}{2}\\right)\\,\\sin^{2}\\!\\left(\\frac{kh}{4}\\right).\n$$\n两种形式都是精确的。所要求的最终答案可以表示为 $\\frac{1}{2}\\sin(kh)-\\sin\\!\\left(\\frac{kh}{2}\\right)$，这是直接从插值定义和在中点处的求值得到的。",
            "answer": "$$\\boxed{\\frac{1}{2}\\sin(kh)-\\sin\\!\\left(\\frac{kh}{2}\\right)}$$"
        },
        {
            "introduction": "在理解了单个单元的局部误差之后，下一步自然是探究由这些单元组成的整个网格的集体行为。本练习旨在推导数值色散关系，这是计算声学中的一个核心概念 。通过该推导，您将揭示数值波速如何因网格尺寸而偏离物理波速，这一现象直接关系到仿真结果的准确性，尤其是在求解高频亥姆霍兹方程时。",
            "id": "4121806",
            "problem": "考虑在具有恒定质量密度和体积模量的无界介质中的时谐、无损、一维声学问题，其声压场 $p(x)$ 在无穷直线上满足标量亥姆霍兹方程 $p''(x) + k^{2} p(x) = 0$，其中 $k$ 是精确波数。使用标准的连续伽辽金有限元法 (FEM)，将直线均匀剖分为间距为 $h > 0$ 的节点 $\\{x_{j}\\}_{j \\in \\mathbb{Z}}$，并在每个单元 $[x_{j}, x_{j+1}]$ 上使用线性拉格朗日形函数，执行以下操作：\n\n- 从亥姆霍兹方程的弱形式以及参考单元 $[-1,1]$ 上的线性形函数定义（即 $N_{1}(\\xi) = \\frac{1 - \\xi}{2}$ 和 $N_{2}(\\xi) = \\frac{1 + \\xi}{2}$）出发，结合仿射映射 $x(\\xi) = \\frac{x_{j+1} + x_{j}}{2} + \\frac{h}{2} \\xi$。通过在参考单元上进行精确积分并映射到物理坐标，构建单元级的刚度矩阵和质量矩阵。\n\n- 在均匀网格上组装全局半离散系统，并分析形式为 $p_{j} = \\exp(i j \\theta)$ 的离散平面波解，其中 $\\theta$ 是一个实相位增量。通过 $\\theta = k_{h} h$ 定义数值波数 $k_{h}$。\n\n- 从第一性原理出发，推导连接 $k_{h}$、$k$ 和 $h$ 的离散色散关系，并对其进行显式求解，以获得 $k_{h}$ 作为 $k$ 和 $h$ 的函数的闭式表达式。\n\n你的最终答案必须是 $k_{h}$ 关于 $k$ 和 $h$ 的单一闭式解析表达式。以逆米为单位报告 $k_{h}$。最终答案中不允许出现任何中间方程。如果你在推导过程中选择使用任何级数展开，必须从离散关系中给出合理的论证，但最终报告的答案必须保持精确的闭式形式。无需四舍五入。",
            "solution": "我们从亥姆霍兹方程 $p''(x) + k^2 p(x) = 0$ 的弱形式开始。我们用一个试探函数 $v(x)$ 乘以该方程，并在长度为 $h=x_{j+1}-x_j$ 的单个有限元 $[x_j, x_{j+1}]$ 上积分。对二阶导数项进行分部积分，得到：\n$$\n\\left[ p'(x)v(x) \\right]_{x_j}^{x_{j+1}} - \\int_{x_j}^{x_{j+1}} p'(x)v'(x) \\, dx + k^2 \\int_{x_j}^{x_{j+1}} p(x)v(x) \\, dx = 0\n$$\n在伽辽金方法中，声压场 $p_h(x)$ 和试探函数 $v(x)$ 使用相同的形函数基进行近似，这导出了单元级方程 $(\\mathbf{K}^e - k^2 \\mathbf{M}^e) \\mathbf{p}^e = \\mathbf{f}^e$。其中，单元刚度矩阵 $\\mathbf{K}^e$ 和单元质量矩阵 $\\mathbf{M}^e$ 的分量为：\n$$\nK^e_{ab} = \\int_{x_j}^{x_{j+1}} N'_a(x) N'_b(x) \\, dx \\quad \\text{和} \\quad M^e_{ab} = \\int_{x_j}^{x_{j+1}} N_a(x) N_b(x) \\, dx\n$$\n我们通过变换到参考单元 $\\xi \\in [-1, 1]$ 来计算这些积分。映射为 $x(\\xi) = x_c + \\frac{h}{2}\\xi$，雅可比行列式为 $\\frac{dx}{d\\xi} = \\frac{h}{2}$。形函数导数为 $\\frac{dN_1}{dx} = -\\frac{1}{h}$ 和 $\\frac{dN_2}{dx} = \\frac{1}{h}$。积分后得到：\n$$\n\\mathbf{K}^e = \\frac{1}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}, \\quad \\mathbf{M}^e = \\frac{h}{6} \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix}\n$$\n接下来，我们通过叠加相邻单元的贡献来组装全局系统。对于一个典型的内部节点 $j$，其行方程由来自单元 $[x_{j-1}, x_j]$ 和 $[x_j, x_{j+1}]$ 的贡献构成：\n$$\n\\left( -\\frac{1}{h} p_{j-1} + \\frac{2}{h} p_j - \\frac{1}{h} p_{j+1} \\right) - k^2 \\left( \\frac{h}{6} p_{j-1} + \\frac{4h}{6} p_j + \\frac{h}{6} p_{j+1} \\right) = 0\n$$\n为了找到数值色散关系，我们代入离散平面波解 $p_j = \\exp(i j \\theta)$，其中 $\\theta = k_h h$。代入并使用恒等式 $\\cos(\\theta) = \\frac{\\exp(i \\theta) + \\exp(-i \\theta)}{2}$，方程变为：\n$$\n\\frac{1}{h} (2 - 2\\cos(\\theta)) - k^2 \\frac{h}{6} (4 + 2\\cos(\\theta)) = 0\n$$\n整理后得到离散色散关系：\n$$\n2(1 - \\cos(\\theta)) = k^2 \\frac{h^2}{3} (2 + \\cos(\\theta))\n$$\n求解 $\\cos(\\theta)$：\n$$\n\\cos(\\theta) = \\frac{6 - 2(kh)^2}{6 + (kh)^2}\n$$\n最后，代入 $\\theta = k_h h$ 并取反余弦，得到数值波数 $k_h$ 的闭式表达式：\n$$\nk_h = \\frac{1}{h} \\arccos\\left( \\frac{6 - 2k^2h^2}{6 + k^2h^2} \\right)\n$$",
            "answer": "$$\n\\boxed{\\frac{1}{h} \\arccos\\left( \\frac{6 - 2k^{2}h^{2}}{6 + k^{2}h^{2}} \\right)}\n$$"
        },
        {
            "introduction": "为了超越线性单元的限制并提高仿真精度，高阶方法至关重要，但其稳定性取决于节点分布。本计算练习通过勒贝格常数（Lebesgue constant）这一关键指标，深入探讨了插值的稳定性 。您将通过编程实现，直观地比较等距节点与高斯-洛巴托-勒让德（GLL）节点的性能差异，并理解为何后者在精确模拟复杂声场时表现出卓越的稳定性。",
            "id": "4121811",
            "problem": "考虑在参考有限元域 $[-1,1]$ 上，使用由 $p+1$ 个不同节点位置构建的 $p$ 次拉格朗日多项式形函数，对一维声压场进行插值。在有限元方法 (FEM) 的计算声学中，对于亥姆霍兹方程解产生的振荡场，稳定的插值至关重要，因为高波数可能导致快速的空间振荡。设插值算子由与节点位置 $\\{x_j\\}_{j=0}^{p}$ 相关的拉格朗日形函数 $\\ell_j(x)$ 定义，因此函数 $f(x)$ 的插值表示为 $I[f](x) = \\sum_{j=0}^{p} f(x_j) \\,\\ell_j(x)$，其中对于所有 $i,j$，有 $\\ell_j(x_i) = \\delta_{ij}$。节点集的勒贝格常数 $\\Lambda_{p}$ 定义为 $\\Lambda_{p} = \\max_{x \\in [-1,1]} \\sum_{j=0}^{p} \\left| \\ell_j(x) \\right|$。勒贝格常数在一致范数下量化了插值过程中节点数据的最坏情况放大率，并作为插值稳定性的一个度量。考虑两种节点分布：等距节点和高斯-洛巴托-勒让德 (GLL) 节点。等距节点是 $p+1$ 个点 $x_j = -1 + 2j/p$，其中 $j=0,\\dots,p$。高斯-洛巴托-勒让德 (GLL) 节点定义为端点 $x=-1$ 和 $x=1$ 以及 $p$ 次勒让德多项式导数的 $p-1$ 个内部零点的并集。\n\n从拉格朗日插值定义和形函数属性出发，实现一个数值稳定的算法来计算等距节点和高斯-洛巴托-勒让德 (GLL) 节点的勒贝格常数 $\\Lambda_{p}$。此外，对于振荡声场 $f(x) = \\sin(k x)$（其中角度 $k$ 以弧度为单位），在均匀评估网格上计算经验插值放大率 $A_{p}(k) = \\max_{x \\in [-1,1]} \\left| I[f](x) \\right|$。使用一个在 $[-1,1]$ 范围内包含 $20001$ 个点（包括端点）的均匀评估网格，并使用重心拉格朗日插值来稳定地评估形函数和插值函数。你的程序必须通过在评估网格上离散化上确界来计算勒贝格常数，并同样地计算 $f(x)=\\sin(kx)$ 的经验放大率。\n\n测试套件和输出规范：\n- 使用以下测试用例，其中角度以弧度为单位，所有输出均为无量纲：\n    1. 案例 A：$p=8$，高斯-洛巴托-勒让德节点，$k=50$。\n    2. 案例 B：$p=8$，等距节点，$k=50$。\n    3. 案例 C（边界情况）：$p=1$，等距节点，$k=50$。\n    4. 案例 D（边缘情况：更高振荡）：$p=8$，高斯-洛巴托-勒让德节点，$k=200$。\n    5. 案例 E（边缘情况：更高振荡）：$p=8$，等距节点，$k=200$。\n- 对于每个案例，计算并返回两个量：勒贝格常数 $\\Lambda_p$ 和经验放大率 $A_p(k)$。将每个数值结果表示为四舍五入到六位小数的浮点数。\n\n最终输出格式：\n- 你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n$[\\Lambda_{8}^{\\mathrm{GLL}}, A_{8}^{\\mathrm{GLL}}(50), \\Lambda_{8}^{\\mathrm{EQ}}, A_{8}^{\\mathrm{EQ}}(50), \\Lambda_{1}^{\\mathrm{EQ}}, A_{1}^{\\mathrm{EQ}}(50), \\Lambda_{8}^{\\mathrm{GLL}}, A_{8}^{\\mathrm{GLL}}(200), \\Lambda_{8}^{\\mathrm{EQ}}, A_{8}^{\\mathrm{EQ}}(200)]$,\n其中 $\\mathrm{GLL}$ 表示高斯-洛巴托-勒让德节点，$\\mathrm{EQ}$ 表示等距节点。例如，输出应类似于 $[x_1,x_2,x_3,x_4,x_5,x_6,x_7,x_8,x_9,x_{10}]$，其中每个 $x_i$ 是四舍五入到六位小数的浮点数。",
            "solution": "该问题要求计算在参考区间 $[-1, 1]$ 上进行一维多项式插值的两个关键指标：勒贝格常数 $\\Lambda_p$ 和针对特定振荡函数的经验插值放大率 $A_p(k)$。这些指标需要针对两种不同的插值节点集进行计算：等距节点和高斯-洛巴托-勒让德 (GLL) 节点。其目的是分析和比较这两种节点分布的数值稳定性，这是有限元方法 (FEM) 等计算方法中的一个关键方面，尤其对于涉及亥姆霍兹方程高波数解的声学问题。\n\n问题的核心在于拉格朗日插值。给定 $[-1, 1]$ 中的一组 $p+1$ 个不同节点 $\\{x_j\\}_{j=0}^p$，任何连续函数 $f(x)$ 都可以通过一个唯一的、次数最多为 $p$ 的多项式 $I[f](x)$ 来近似，该多项式在这些节点上插值 $f(x)$，即 $I[f](x_j) = f(x_j)$。这个插值多项式可以使用拉格朗日基多项式 $\\ell_j(x)$ 表示为：\n$$\nI[f](x) = \\sum_{j=0}^{p} f(x_j) \\ell_j(x), \\quad \\text{其中} \\quad \\ell_j(x_i) = \\delta_{ij} = \\begin{cases} 1  i = j \\\\ 0  i \\neq j \\end{cases}\n$$\n此插值过程的稳定性由勒贝格常数 $\\Lambda_p$ 量化，其定义为勒贝格函数 $\\lambda_p(x) = \\sum_{j=0}^{p} |\\ell_j(x)|$ 在该区间上的最大值：\n$$\n\\Lambda_p = \\max_{x \\in [-1, 1]} \\lambda_p(x) = \\max_{x \\in [-1, 1]} \\sum_{j=0}^{p} |\\ell_j(x)|\n$$\n勒贝格常数提供了函数值 $f(x_j)$ 中误差放大的一个上界。较小的 $\\Lambda_p$ 表示一个稳定的插值方案。\n\n第二个指标，经验插值放大率 $A_p(k)$，衡量了特定函数 $f(x) = \\sin(kx)$（其中 $k$ 是波数）的插值函数最大幅值。其定义为：\n$$\nA_p(k) = \\max_{x \\in [-1, 1]} |I[\\sin(kx)](x)|\n$$\n该指标提供了一个实用的度量，用于衡量插值方案处理代表性振荡函数的效果。\n\n为了可靠地计算这些量，直接评估拉格朗日多项式的经典公式 $\\ell_j(x) = \\prod_{i \\neq j} \\frac{x-x_i}{x_j-x_i}$ 在数值上是不稳定的，特别是对于高次 $p$。一种更优越的方法是重心拉格朗日插值。第二种重心形式将插值多项式表示为：\n$$\nI[f](x) = \\frac{\\sum_{j=0}^{p} \\frac{w_j}{x-x_j} f(x_j)}{\\sum_{j=0}^{p} \\frac{w_j}{x-x_j}}\n$$\n其中 $w_j$ 是重心权重，定义为 $w_j = \\left( \\prod_{i \\neq j} (x_j - x_i) \\right)^{-1}$。这些权重仅依赖于节点分布，可以预先计算。该公式数值稳定且高效。由此，可以推导出形函数 $\\ell_j(x)$ 和勒贝格函数 $\\lambda_p(x)$ 的表达式：\n$$\n\\ell_j(x) = \\frac{w_j/(x-x_j)}{\\sum_{k=0}^{p} w_k/(x-x_k)} \\quad \\implies \\quad \\lambda_p(x) = \\sum_{j=0}^{p} |\\ell_j(x)| = \\frac{\\sum_{j=0}^{p} |w_j/(x-x_j)|}{|\\sum_{k=0}^{p} w_k/(x-x_k)|}\n$$\n这些公式在 $x$ 不等于任何节点 $x_j$ 时有效。如果 $x=x_j$，则 $I[f](x_j) = f(x_j)$ 且 $\\lambda_p(x_j) = 1$。\n\n该问题指定了两种节点分布：\n1.  **等距节点**：这 $p+1$ 个点由公式 $x_j = -1 + \\frac{2j}{p}$ 给出，其中 $j=0, 1, \\dots, p$。已知这些节点会导致较差的稳定性，$\\Lambda_p$ 随 $p$呈指数增长。\n2.  **高斯-洛巴托-勒让德 (GLL) 节点**：这些节点由端点 $x=-1$ 和 $x=1$ 以及 $p$ 次勒让德多项式 $P_p(x)$ 的导数 $P'_p(x)$ 的 $p-1$ 个内部根组成。$P'_p(x)$ 的根与雅可比多项式 $P_{p-1}^{(1,1)}(x)$ 的根相同。这些节点在端点附近聚集，并产生出色的稳定性，$\\Lambda_p$ 仅随 $p$ 对数增长。\n\n解决该问题的算法如下：\n1.  对于由 $(p, \\text{节点类型}, k)$ 定义的每个测试用例：\n2.  **生成节点**：\n    *   对于等距节点，应用公式 $x_j = -1 + 2j/p$。\n    *   对于次数 $p  1$ 的 GLL 节点，使用数值库函数（例如 `scipy.special.roots_jacobi`）计算雅可比多项式 $P_{p-1}^{(1,1)}(x)$ 的 $p-1$ 个根。将这些内部根与端点 $\\{-1, 1\\}$ 结合，形成完整的 $p+1$ 个节点集。对于 $p=1$，GLL 节点就是 $\\{-1, 1\\}$。\n3.  **计算重心权重**：使用公式 $w_j = (\\prod_{i \\neq j} (x_j - x_i))^{-1}$ 计算每个节点 $x_j$ 的权重 $w_j$。\n4.  **定义评估网格**：创建一个由 $N=20001$ 个点组成的精细均匀网格，记为 $\\{x_{eval}\\}$，覆盖区间 $[-1, 1]$。\n5.  **在节点处求值**：在 $p+1$ 个节点上计算函数 $f(x) = \\sin(kx)$ 的值：$f_j = \\sin(kx_j)$。\n6.  **在网格上求值**：对于评估网格 $\\{x_{eval}\\}$ 中的每个点 $x$：\n    *   如果 $x$ 在数值上接近某个节点 $x_j$，则插值值为 $f_j$，勒贝格函数值为 $1$。\n    *   否则，使用重心公式计算 $I[f](x)$ 和 $\\lambda_p(x)$。\n7.  **确定最大值**：通过分别在评估网格上找到计算出的 $\\lambda_p(x)$ 和 $|I[f](x)|$ 值的最大值来近似 $\\Lambda_p$ 和 $A_p(k)$。\n8.  **格式化输出**：存储每个测试用例计算出的 $\\Lambda_p$ 和 $A_p(k)$，并将最终结果格式化为单个逗号分隔的列表，四舍五入到六位小数。\n\n此过程将为所有指定的测试用例实施，以生成所需的输出，从而展示等距节点和 GLL 节点在插值稳定性方面的显著差异。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import special\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem.\n    It computes Lebesgue constants and empirical amplifications for several test cases\n    and prints the results in the specified format.\n    \"\"\"\n\n    def compute_interpolation_metrics(p: int, node_type: str, k: float):\n        \"\"\"\n        Computes the Lebesgue constant and empirical amplification for a given\n        polynomial degree, node type, and wavenumber.\n\n        Args:\n            p (int): The degree of the Lagrange polynomial.\n            node_type (str): Type of nodes, 'equispaced' or 'gll'.\n            k (float): The wavenumber for the function sin(kx).\n\n        Returns:\n            tuple: A tuple containing the Lebesgue constant and the empirical amplification,\n                   both as floats.\n        \"\"\"\n        N_eval = 20001\n        x_eval = np.linspace(-1.0, 1.0, N_eval)\n\n        # Step 1: Generate interpolation nodes\n        if node_type == 'equispaced':\n            x_nodes = np.linspace(-1.0, 1.0, p + 1)\n        elif node_type == 'gll':\n            if p == 0:\n                x_nodes = np.array([0.0])\n            elif p == 1:\n                # For p=1, GLL nodes are the endpoints, same as equispaced\n                x_nodes = np.array([-1.0, 1.0])\n            else:\n                # Interior nodes are roots of P'_p(x), which are roots of Jacobi P_{p-1}^{(1,1)}(x)\n                # scipy.special.roots_jacobi requires n  0.\n                interior_nodes, _ = special.roots_jacobi(p - 1, 1, 1)\n                x_nodes = np.concatenate(([-1.0], interior_nodes, [1.0]))\n                x_nodes.sort() # Ensure nodes are ordered\n        else:\n            raise ValueError(f\"Unknown node type: {node_type}\")\n\n        # Step 2: Compute barycentric weights\n        weights = np.ones(p + 1)\n        for j in range(p + 1):\n            # General formula for barycentric weights\n            other_nodes = np.delete(x_nodes, j)\n            weights[j] = 1.0 / np.prod(x_nodes[j] - other_nodes)\n\n        # Step 3: Evaluate function f(x) = sin(k*x) at nodes\n        f_nodes = np.sin(k * x_nodes)\n\n        # Step 4: Evaluate interpolant and Lebesgue function on the fine grid\n        lebesgue_func_vals = np.zeros(N_eval)\n        interp_vals = np.zeros(N_eval)\n\n        for i, x in enumerate(x_eval):\n            # Check if evaluation point x is very close to a node\n            is_node_mask = np.isclose(x, x_nodes)\n            if np.any(is_node_mask):\n                node_idx = np.where(is_node_mask)[0][0]\n                interp_vals[i] = f_nodes[node_idx]\n                lebesgue_func_vals[i] = 1.0\n            else:\n                # Use barycentric formulas for evaluation\n                terms = weights / (x - x_nodes)\n                sum_terms = np.sum(terms)\n                \n                # Interpolated value\n                interp_vals[i] = np.sum(terms * f_nodes) / sum_terms\n                \n                # Lebesgue function value\n                lebesgue_func_vals[i] = np.sum(np.abs(terms)) / np.abs(sum_terms)\n\n        # Step 5: Compute maximums to approximate the constants\n        lebesgue_constant = np.max(lebesgue_func_vals)\n        amplification = np.max(np.abs(interp_vals))\n\n        return lebesgue_constant, amplification\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'p': 8, 'node_type': 'gll', 'k': 50},       # Case A\n        {'p': 8, 'node_type': 'equispaced', 'k': 50}, # Case B\n        {'p': 1, 'node_type': 'equispaced', 'k': 50}, # Case C\n        {'p': 8, 'node_type': 'gll', 'k': 200},      # Case D\n        {'p': 8, 'node_type': 'equispaced', 'k': 200},# Case E\n    ]\n\n    results = []\n    for case in test_cases:\n        lambda_p, a_p_k = compute_interpolation_metrics(case['p'], case['node_type'], case['k'])\n        results.append(lambda_p)\n        results.append(a_p_k)\n\n    # Final print statement in the exact required format.\n    formatted_results = [format(r, '.6f') for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}