{
    "hands_on_practices": [
        {
            "introduction": "This first practice exercise provides a foundational, pencil-and-paper walkthrough of the finite element assembly process. By calculating the local stiffness matrix for a simple heat diffusion problem and assembling a single row of the global system, you will gain a concrete understanding of how local element contributions build the full discrete operator. This manual approach demystifies the assembly algorithm before moving on to more complex, code-based implementations. ",
            "id": "4020951",
            "problem": "Consider steady heat diffusion in a thin inert liner segment adjacent to a premixed flame, modeled on the nondimensional unit square domain $\\Omega = [0,1] \\times [0,1]$ with isotropic thermal conductivity $k$ that is spatially constant and a vanishing volumetric heat source. The governing equation is the conservation of energy in steady state, $-\\nabla \\cdot \\left( k \\nabla T \\right) = 0$ in $\\Omega$, with Dirichlet boundary conditions on the outer boundary. Use the Finite Element (FE) method with piecewise linear Lagrange basis functions on triangles to discretize the weak form.\n\nThe computational mesh has nodes at the four corners and one interior node at the center: node $1$ at $(0,0)$, node $2$ at $(1,0)$, node $3$ at $(1,1)$, node $4$ at $(0,1)$, and node $5$ at $(0.5,0.5)$. The mesh is triangulated into four triangles by connecting the center node to each edge: triangles $(1,2,5)$, $(2,3,5)$, $(3,4,5)$, and $(4,1,5)$. The boundary nodal temperatures are prescribed as Dirichlet constraints: $T_{1} = 723.4 \\text{ K}$, $T_{2} = 921.7 \\text{ K}$, $T_{3} = 801.3 \\text{ K}$, and $T_{4} = 649.8 \\text{ K}$. The conductivity is $k = 1$.\n\nTasks:\n- Define the local piecewise linear Lagrange basis functions on an arbitrary triangle in terms of its barycentric coordinates and express their gradients in Cartesian coordinates.\n- Starting from the weak form of the diffusion equation, construct the local element stiffness matrix for an arbitrary triangle using these basis functions.\n- For the triangle $(1,2,5)$ with vertices $(0,0)$, $(1,0)$, and $(0.5,0.5)$, compute the gradients of the basis functions and all entries of its local stiffness matrix. Explain by symmetry what this implies for the other three triangles.\n- Assemble the global stiffness matrix row for the interior node $5$, and enforce the Dirichlet boundary conditions strongly (by elimination) to obtain a scalar linear equation for the unknown interior temperature $T_{5}$.\n- Solve this scalar equation for $T_{5}$ using the given boundary values.\n\nExpress the final answer as the value of $T_{5}$ in Kelvin. Round your answer to five significant figures. Do not include units in your final numeric answer.",
            "solution": "The user wants me to solve a steady-state heat diffusion problem on a square domain using the Finite Element Method (FEM).\n\n### Step 1: Extract Givens\n- **Governing Equation:** Steady-state heat diffusion $-\\nabla \\cdot (k \\nabla T) = 0$ in $\\Omega$.\n- **Domain:** $\\Omega = [0,1] \\times [0,1]$.\n- **Thermal Conductivity:** $k=1$ (constant and isotropic).\n- **Source Term:** $0$.\n- **Discretization Method:** Finite Element Method with piecewise linear Lagrange basis functions on triangles.\n- **Mesh Nodes:**\n  - Node $1$: $(0,0)$\n  - Node $2$: $(1,0)$\n  - Node $3$: $(1,1)$\n  - Node $4$: $(0,1)$\n  - Node $5$: $(0.5,0.5)$\n- **Mesh Elements (Triangles):**\n  - $\\Omega_1$: $(1,2,5)$\n  - $\\Omega_2$: $(2,3,5)$\n  - $\\Omega_3$: $(3,4,5)$\n  - $\\Omega_4$: $(4,1,5)$\n- **Boundary Conditions (Dirichlet):**\n  - $T_1 = 723.4$\n  - $T_2 = 921.7$\n  - $T_3 = 801.3$\n  - $T_4 = 649.8$\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded:** The problem describes steady-state heat conduction, governed by Laplace's equation for a constant thermal conductivity. This is a fundamental and well-established principle in heat transfer and physics. The setup is scientifically sound.\n2.  **Well-Posed:** The problem is a standard elliptic boundary value problem (Laplace's equation with Dirichlet boundary conditions on a closed domain). Such problems are known to be well-posed, admitting a unique and stable solution. The discretization with FEM is also a standard and valid procedure.\n3.  **Objective:** The problem is formulated with precise mathematical language and numerical data. There are no subjective or ambiguous statements.\n4.  **Completeness and Consistency:** The problem provides all necessary information to proceed: the governing equation, domain, mesh geometry, boundary conditions, and material properties. The data is self-consistent.\n5.  **Relevance:** The problem of heat diffusion in a solid liner is directly relevant to computational combustion, where conjugate heat transfer between hot gases and solid components is a critical phenomenon to model.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete solution will be provided.\n\n### Solution Derivation\nThe governing equation is the steady-state heat diffusion equation with no heat source, which for constant conductivity $k$ simplifies to Laplace's equation:\n$$ -k \\nabla^2 T = 0 $$\nThe weak form is derived by multiplying by a test function $v$ and integrating over the domain $\\Omega$. Using integration by parts (Green's first identity), we obtain:\n$$ \\int_{\\Omega} k (\\nabla v) \\cdot (\\nabla T) \\,d\\Omega - \\int_{\\partial\\Omega} v (k \\nabla T \\cdot \\mathbf{n}) \\,dS = 0 $$\nFor the Finite Element Method, we approximate the temperature field $T(x,y)$ as a linear combination of basis functions $N_j(x,y)$:\n$$ T_h(x,y) = \\sum_{j=1}^{5} T_j N_j(x,y) $$\nwhere $T_j$ are the unknown nodal temperatures. Using the Galerkin method, we choose the test functions $v$ to be the basis functions $N_i(x,y)$. Enforcing the Dirichlet boundary conditions strongly, the contribution from the boundary integral vanishes for test functions associated with interior nodes. The resulting system of linear equations is $K \\mathbf{T} = \\mathbf{F}$, where the entries of the global stiffness matrix $K$ are given by the assembly of element stiffness matrices $K^e$:\n$$ K_{ij} = \\sum_{e} K_{ij}^e = \\sum_{e} \\int_{\\Omega_e} k (\\nabla N_i) \\cdot (\\nabla N_j) \\,d\\Omega $$\nThe vector $\\mathbf{F}$ contains contributions from source terms and natural boundary conditions, which are zero in this problem.\n\n**Task 1: Basis Functions and Gradients**\nFor a triangular element with vertices $(x_1, y_1)$, $(x_2, y_2)$, and $(x_3, y_3)$, the piecewise linear Lagrange basis functions $N_i(x,y)$ are identical to the barycentric coordinates $\\lambda_i(x,y)$. A basis function $N_i$ is equal to $1$ at node $i$ and $0$ at the other two nodes. The function can be written as $N_i(x,y) = a_i + b_i x + c_i y$. The gradient of the basis function is a constant vector within the element:\n$$ \\nabla N_i = \\begin{pmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} b_i \\\\ c_i \\end{pmatrix} $$\nThe coefficients are given by:\n$$ b_1 = \\frac{y_2 - y_3}{2 A_e}, \\quad c_1 = \\frac{x_3 - x_2}{2 A_e} $$\n$$ b_2 = \\frac{y_3 - y_1}{2 A_e}, \\quad c_2 = \\frac{x_1 - x_3}{2 A_e} $$\n$$ b_3 = \\frac{y_1 - y_2}{2 A_e}, \\quad c_3 = \\frac{x_2 - x_1}{2 A_e} $$\nwhere $A_e$ is the area of the triangle.\n\n**Task 2: Local Element Stiffness Matrix**\nSince the basis function gradients and the conductivity $k$ are constant over a linear triangular element, the element stiffness matrix integral simplifies to:\n$$ K_{ij}^e = \\int_{\\Omega_e} k (\\nabla N_i) \\cdot (\\nabla N_j) \\,d\\Omega = k ((\\nabla N_i) \\cdot (\\nabla N_j)) \\int_{\\Omega_e} \\,d\\Omega = k A_e (\\nabla N_i \\cdot \\nabla N_j) $$\n$$ K_{ij}^e = k A_e (b_i b_j + c_i c_j) $$\n\n**Task 3: Computation for Triangle (1,2,5)**\nLet element $\\Omega_1$ be the triangle with global nodes $(1,2,5)$. We assign local node indices $1,2,3$ to global nodes $1,2,5$ respectively.\nThe vertices are: $(x_1,y_1) = (0,0)$, $(x_2,y_2) = (1,0)$, and $(x_3,y_3) = (0.5,0.5)$.\nThe area $A_e$ is calculated as:\n$$ 2 A_e = \\det \\begin{pmatrix} x_1 & y_1 & 1 \\\\ x_2 & y_2 & 1 \\\\ x_3 & y_3 & 1 \\end{pmatrix} = \\det \\begin{pmatrix} 0 & 0 & 1 \\\\ 1 & 0 & 1 \\\\ 0.5 & 0.5 & 1 \\end{pmatrix} = 1(1 \\cdot 0.5 - 0 \\cdot 0.5) = 0.5 $$\nSo, $A_e = 0.25$.\nThe gradients for the basis functions associated with the local nodes are:\n- For local node $1$ (global node $1$):\n  $b_1 = \\frac{0 - 0.5}{0.5} = -1$, $c_1 = \\frac{0.5 - 1}{0.5} = -1$.\n  $\\nabla N_1 = \\begin{pmatrix} -1 \\\\ -1 \\end{pmatrix}$.\n- For local node $2$ (global node $2$):\n  $b_2 = \\frac{0.5 - 0}{0.5} = 1$, $c_2 = \\frac{0 - 0.5}{0.5} = -1$.\n  $\\nabla N_2 = \\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix}$.\n- For local node $3$ (global node $5$):\n  $b_3 = \\frac{0 - 0}{0.5} = 0$, $c_3 = \\frac{1 - 0}{0.5} = 2$.\n  $\\nabla N_5 = \\begin{pmatrix} 0 \\\\ 2 \\end{pmatrix}$.\n\nWith $k=1$ and $A_e=0.25$, the entries of the local stiffness matrix $K^{(1,2,5)}$ are:\n$K_{11}^e = (1)(0.25)((-1)^2 + (-1)^2) = 0.25 \\times 2 = 0.5$\n$K_{12}^e = (1)(0.25)((-1)(1) + (-1)(-1)) = 0.25 \\times 0 = 0$\n$K_{15}^e = (1)(0.25)((-1)(0) + (-1)(2)) = 0.25 \\times (-2) = -0.5$\n$K_{22}^e = (1)(0.25)(1^2 + (-1)^2) = 0.25 \\times 2 = 0.5$\n$K_{25}^e = (1)(0.25)((1)(0) + (-1)(2)) = 0.25 \\times (-2) = -0.5$\n$K_{55}^e = (1)(0.25)(0^2 + 2^2) = 0.25 \\times 4 = 1.0$\nThe local stiffness matrix for element $(1,2,5)$, indexed by global node numbers, is:\n$$ K^{(1,2,5)} = \\begin{pmatrix} 0.5 & 0 & -0.5 \\\\ 0 & 0.5 & -0.5 \\\\ -0.5 & -0.5 & 1.0 \\end{pmatrix}_{\\text{rows/cols for nodes } 1,2,5} $$\nThe other three triangles $(2,3,5)$, $(3,4,5)$, and $(4,1,5)$ are congruent to triangle $(1,2,5)$ via rotation and reflection around the center of the domain. Since the local stiffness matrix formulation depends only on the geometry of the triangle (which is the same for all four), the numerical values of the entries in their respective local stiffness matrices will be identical, provided a consistent local node numbering scheme is used (e.g., mapping the center node to local node $3$ and the two boundary nodes to local nodes $1$ and $2$).\n\n**Task 4: Global Stiffness Matrix Assembly and Enforcement of BCs**\nWe need to find the equation for the unknown temperature $T_5$. This corresponds to the fifth row of the global system $K \\mathbf{T} = \\mathbf{F}$. Since there are no source terms, the initial equation is:\n$$ K_{51}T_1 + K_{52}T_2 + K_{53}T_3 + K_{54}T_4 + K_{55}T_5 = 0 $$\nThe coefficients $K_{5j}$ are assembled by summing contributions from all elements containing node $5$. Node $5$ is part of all four elements.\n- $K_{55}$: The diagonal term receives a contribution from the $(5,5)$ entry of each element's stiffness matrix. In our local notation, this corresponds to the $(3,3)$ entry of the local matrix.\n  $K_{55} = K_{55}^{(1,2,5)} + K_{55}^{(2,3,5)} + K_{55}^{(3,4,5)} + K_{55}^{(4,1,5)} = 1.0 + 1.0 + 1.0 + 1.0 = 4.0$.\n- $K_{51}$: This off-diagonal term gets contributions from elements containing both nodes $1$ and $5$. These are elements $(1,2,5)$ and $(4,1,5)$.\n  From $K^{(1,2,5)}$, the contribution is $K_{15}^e = -0.5$.\n  From $K^{(4,1,5)}$, the contribution is also $-0.5$ due to symmetry.\n  $K_{51} = -0.5 + (-0.5) = -1.0$.\n- $K_{52}$: This term gets contributions from elements $(1,2,5)$ and $(2,3,5)$.\n  From $K^{(1,2,5)}$, the contribution is $K_{25}^e = -0.5$.\n  From $K^{(2,3,5)}$, the contribution is also $-0.5$.\n  $K_{52} = -0.5 + (-0.5) = -1.0$.\n- By symmetry of the mesh, the remaining off-diagonal terms are also $-1.0$:\n  $K_{53} = -1.0$\n  $K_{54} = -1.0$\n\nThe assembled equation for node $5$ is:\n$$ -1.0 T_1 - 1.0 T_2 - 1.0 T_3 - 1.0 T_4 + 4.0 T_5 = 0 $$\nEnforcing the Dirichlet boundary conditions means substituting the known values of $T_1, T_2, T_3, T_4$ into this equation. This is a single linear equation for the single unknown $T_5$.\n\n**Task 5: Solve for $T_5$**\nRearranging the equation to solve for $T_5$:\n$$ 4.0 T_5 = T_1 + T_2 + T_3 + T_4 $$\n$$ T_5 = \\frac{T_1 + T_2 + T_3 + T_4}{4} $$\nThis result shows that for this specific symmetric grid, the FEM solution at the center is the arithmetic average of the corner temperatures, which is consistent with the discrete maximum principle and mimics the mean value property of harmonic functions.\nSubstituting the given boundary temperature values:\n$$ T_5 = \\frac{723.4 + 921.7 + 801.3 + 649.8}{4} $$\n$$ T_5 = \\frac{3096.2}{4} $$\n$$ T_5 = 774.05 $$\nThe problem requests the answer to five significant figures. The calculated value $774.05$ already has five significant figures.",
            "answer": "$$\\boxed{774.05}$$"
        },
        {
            "introduction": "A correct assembly routine is the bedrock of any finite element solver, and verifying its implementation is a critical skill. This practice challenges you to use the Method of Manufactured Solutions (MMS), a powerful technique for code verification, to test an assembly routine for a 1D Helmholtz problem. By ensuring your code can exactly reproduce a known, non-trivial solution, you build confidence in its correctness and learn to diagnose issues related to matrix properties and boundary condition enforcement. ",
            "id": "4117066",
            "problem": "Consider the one-dimensional frequency-domain acoustic model on the interval $x \\in (0,L)$ with unknown acoustic pressure $p(x)$ governed by the differential equation $p''(x) + k^2 p(x) = s(x)$ and boundary conditions $p(0) = p_D$ and $p'(L) + \\alpha p(L) = g$. All quantities are dimensionless. The goal is to verify the correctness of global system matrix assembly for the Galerkin finite element method using first-order (linear) elements.\n\nStarting from the governing differential equation and boundary conditions, derive the weak formulation by multiplying the equation with an arbitrary test function $v(x)$ and integrating by parts. Assemble the global system matrix by summing contributions of element stiffness and mass matrices, and incorporating the Robin boundary term at $x=L$. Enforce the Dirichlet condition $p(0) = p_D$ using elimination in the global system. Solve the resulting linear system to obtain the discrete solution $p_h(x)$ in the nodal basis.\n\nYour program must implement the following:\n\n- Use a uniform mesh of $N$ elements on $(0,L)$ with nodes $x_i = i h$ for $i = 0,1,\\dots,N$, where $h = L/N$.\n- Use first-order (linear) basis functions on each element and a two-point Gaussian quadrature rule to evaluate the element load vector from the source term $s(x)$.\n- Assemble the global system matrix corresponding to the weak form that combines the stiffness term, the negative mass contribution due to $k^2$, and the Robin boundary contribution at $x=L$. Add the boundary load due to $g$ to the global right-hand side.\n- Enforce the Dirichlet boundary condition at $x=0$ by elimination in the global matrix and right-hand side (i.e., alter the first row and column consistently so that $p(0) = p_D$ is imposed strongly).\n- Solve the global linear system for the nodal values and evaluate the specified verification quantities.\n\nTo ensure testability and coverage, use the Method of Manufactured Solutions: define a smooth exact pressure $p_{\\mathrm{exact}}(x)$ and set the source $s(x) = p_{\\mathrm{exact}}''(x) + k^2 p_{\\mathrm{exact}}(x)$ and the Robin data $g = p_{\\mathrm{exact}}'(L) + \\alpha p_{\\mathrm{exact}}(L)$; set the Dirichlet value $p_D = p_{\\mathrm{exact}}(0)$. This ensures that the exact solution satisfies the differential equation and boundary conditions.\n\nImplement the following three test cases:\n\n- Test Case 1 (general case): $L = 1$, $N = 16$, $k = 4$, $\\alpha = 1.3$, $p_{\\mathrm{exact}}(x) = \\sin(2 x) + 0.3 x$. Compute the $L^2$-norm of the error $||p_h - p_{\\mathrm{exact}}||_{L^2(0,L)}$ as a float.\n- Test Case 2 (impedance boundary symmetry check): $L = 1$, $N = 20$, $k = 8$, $\\alpha = 2 \\mathrm{i}$ (purely imaginary), $p_{\\mathrm{exact}}(x) = \\sin(1.5 x) + 0.1 x^2$. Assemble the global matrix $A$. Return a boolean that is true if $||A - A^T||_F < 10^{-12}$ and $||A - A^H||_F > 10^{-8}$, where $A^T$ denotes transpose, $A^H$ denotes conjugate transpose, and $||\\cdot||_F$ is the Frobenius norm.\n- Test Case 3 (boundary edge case with coarse mesh): $L = 1$, $N = 2$, $k = 1$, $\\alpha = 0$, $p_{\\mathrm{exact}}(x) = x (1 - x) + 0.05 \\sin(3 x)$. After solving, compute the Euclidean norm of the residual $||A u - b||_2$ as a float, where $u$ is the vector of nodal values, $A$ is the assembled matrix after Dirichlet enforcement, and $b$ is the right-hand side vector.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as follows: the $L^2$ error for Test Case 1 (float), the symmetry and Hermitian property boolean for Test Case 2 (boolean), and the residual norm for Test Case 3 (float). For example, the output format must be exactly \"[result1,result2,result3]\".",
            "solution": "The problem is valid as it presents a well-posed, scientifically grounded problem in computational acoustics, specifically the finite element solution of the one-dimensional Helmholtz equation. All necessary parameters, equations, and verification procedures are provided, and the task is a standard exercise in numerical methods for partial differential equations.\n\n### Derivation of the Weak Formulation\n\nThe governing strong form of the one-dimensional frequency-domain acoustic model is given by the differential equation\n$$ p''(x) + k^2 p(x) = s(x) \\quad \\text{for } x \\in (0, L) $$\nwith a Dirichlet boundary condition at $x=0$ and a Robin boundary condition at $x=L$:\n$$ p(0) = p_D $$\n$$ p'(L) + \\alpha p(L) = g $$\nHere, $p(x)$ is the unknown acoustic pressure, $k$ is the wavenumber, $s(x)$ is a source term, and $\\alpha$ and $g$ define the Robin boundary condition.\n\nTo derive the weak formulation, we multiply the differential equation by an arbitrary test function $v(x)$ belonging to a suitable function space and integrate over the domain $(0, L)$. The test functions must satisfy the homogeneous version of any essential (Dirichlet) boundary conditions, so we require $v(0)=0$.\n$$ \\int_0^L \\left( p''(x) + k^2 p(x) \\right) v(x) \\, dx = \\int_0^L s(x) v(x) \\, dx $$\nWe apply integration by parts to the second-derivative term:\n$$ \\int_0^L p''(x) v(x) \\, dx = \\left[ p'(x) v(x) \\right]_0^L - \\int_0^L p'(x) v'(x) \\, dx $$\nThe boundary term is $\\left[ p'(x) v(x) \\right]_0^L = p'(L)v(L) - p'(0)v(0)$. Since we chose $v(x)$ such that $v(0)=0$, this simplifies to $p'(L)v(L)$. Substituting this back into the integrated equation gives:\n$$ - \\int_0^L p'(x) v'(x) \\, dx + p'(L)v(L) + \\int_0^L k^2 p(x) v(x) \\, dx = \\int_0^L s(x) v(x) \\, dx $$\nNext, we incorporate the Robin boundary condition by substituting $p'(L) = g - \\alpha p(L)$:\n$$ - \\int_0^L p'(x) v'(x) \\, dx + \\left( g - \\alpha p(L) \\right) v(L) + \\int_0^L k^2 p(x) v(x) \\, dx = \\int_0^L s(x) v(x) \\, dx $$\nRearranging the terms to group all expressions involving the unknown $p(x)$ on the left-hand side (LHS) and known quantities on the right-hand side (RHS), we obtain the final weak formulation:\nFind the pressure $p(x)$ such that $p(0)=p_D$ and for all admissible test functions $v(x)$:\n$$ \\int_0^L p'(x) v'(x) \\, dx - k^2 \\int_0^L p(x) v(x) \\, dx + \\alpha p(L) v(L) = \\int_0^L s(x) v(x) \\, dx + g v(L) $$\nThis equation is of the form $a(p,v) = L(v)$, where $a(p,v)$ is a bilinear form and $L(v)$ is a linear functional.\n\n### Finite Element Discretization\n\nWe discretize the domain $(0, L)$ into $N$ uniform elements of length $h = L/N$. The nodes are at $x_i = ih$ for $i=0, 1, \\dots, N$. We approximate the pressure $p(x)$ using a linear combination of first-order (linear) basis functions $\\phi_j(x)$:\n$$ p_h(x) = \\sum_{j=0}^N u_j \\phi_j(x) $$\nwhere $u_j = p_h(x_j)$ are the unknown nodal values of the pressure and $\\phi_j(x)$ is the \"hat\" function, which is $1$ at node $x_j$ and $0$ at all other nodes.\n\nIn the Galerkin method, we use the basis functions as test functions, i.e., $v(x) = \\phi_i(x)$ for $i=1, \\dots, N$. The equation for $i=0$ is reserved for the Dirichlet condition. Substituting the expansion of $p_h(x)$ and $v(x)=\\phi_i(x)$ into the weak form yields a system of linear equations $A \\mathbf{u} = \\mathbf{b}$, where $\\mathbf{u} = [u_0, u_1, \\dots, u_N]^T$.\n\nThe entries of the global system matrix $A$ and right-hand side vector $\\mathbf{b}$ are given by:\n$$ A_{ij} = \\int_0^L \\phi_i'(x) \\phi_j'(x) \\, dx - k^2 \\int_0^L \\phi_i(x) \\phi_j(x) \\, dx + \\alpha \\phi_i(L) \\phi_j(L) $$\n$$ b_i = \\int_0^L s(x) \\phi_i(x) \\, dx + g \\phi_i(L) $$\n\nThese global matrices are assembled by summing up contributions from each element. For a generic element of length $h$, the element stiffness matrix $K^e$ and mass matrix $M^e$ are:\n$$ K^e = \\frac{1}{h} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}, \\quad M^e = \\frac{h}{6} \\begin{pmatrix} 2 & 1 \\\\ 1 & 2 \\end{pmatrix} $$\nThe element matrix is $A^e = K^e - k^2 M^e$.\n\nThe Robin boundary term $\\alpha p(L)v(L)$ only contributes when both $p(L)$ and $v(L)$ are non-zero. In our discretization, this occurs when $\\phi_i = \\phi_N$ and $\\phi_j = \\phi_N$. Thus, the value $\\alpha$ is added to the $A_{N,N}$ entry of the global matrix. Similarly, the term $g v(L)$ contributes only to the $N$-th equation, adding $g$ to $b_N$.\n\nThe source term contribution to the RHS, $\\int s(x) \\phi_i(x) dx$, is computed element-wise using a two-point Gaussian quadrature rule.\n\n### Boundary Condition Enforcement\n\nThe Dirichlet condition $p(0) = p_D$ is enforced by modifying the fully assembled linear system for $\\mathbf{u}$. This condition translates to $u_0 = p_D$. We use the elimination method:\n1. The first equation (row $0$) is replaced by $1 \\cdot u_0 = p_D$. This is achieved by setting $A_{00}=1$, $A_{0j}=0$ for $j>0$, and $b_0=p_D$.\n2. The influence of the known value $u_0$ is subtracted from the other equations. For each row $i > 0$, the term $A_{i0} u_0$ is moved to the RHS: $b_i \\leftarrow b_i - A_{i0} p_D$. The first column of the matrix (for $i>0$) is then zeroed out: $A_{i0}=0$.\n\nAfter these modifications, the resulting system is solved for the nodal values $\\mathbf{u}$.\n\n### Verification Quantities\n\n- **$L^2$-norm of the error**: $||p_h - p_{\\mathrm{exact}}||_{L^2} = (\\int_0^L |p_h(x) - p_{\\mathrm{exact}}(x)|^2 dx)^{1/2}$. This integral is computed numerically by summing contributions from each element, evaluated using a sufficiently accurate quadrature rule (e.g., 4-point Gaussian quadrature).\n- **Matrix Properties**: The matrix $A$ before Dirichlet enforcement is $A = K - k^2 M + B_\\alpha$, where $K$ and $M$ are the global stiffness and mass matrices, and $B_\\alpha$ is a matrix with $\\alpha$ at entry $(N,N)$. Since $K$ and $M$ are real and symmetric, $A$ is symmetric ($A=A^T$). Its conjugate transpose is $A^H = K - \\bar{k}^2 M + \\bar{B}_\\alpha$. For Test Case 2, $k$ is real and $\\alpha=2i$ is purely imaginary. Thus $A-A^H = B_\\alpha - \\bar{B}_\\alpha$, which is a matrix with $\\alpha - \\bar{\\alpha} = 4i$ at $(N,N)$ and zeros elsewhere. The Frobenius norm $||A-A^T||_F$ should be zero (within machine precision) and $||A-A^H||_F = \\sqrt{|4i|^2} = 4$, which is greater than $10^{-8}$.\n- **Residual Norm**: $||A_{\\text{mod}} \\mathbf{u} - \\mathbf{b}_{\\text{mod}}||_2$. This measures the accuracy of the linear solver. For a direct solver, this value should be close to machine precision.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to define, run, and report results for all test cases.\n    \"\"\"\n    # Define manufactured solutions and their derivatives for each test case.\n    # Test Case 1\n    p_exact_1 = lambda x: np.sin(2 * x) + 0.3 * x\n    dp_exact_1 = lambda x: 2 * np.cos(2 * x) + 0.3\n    d2p_exact_1 = lambda x: -4 * np.sin(2 * x)\n\n    # Test Case 2\n    p_exact_2 = lambda x: np.sin(1.5 * x) + 0.1 * x**2\n    dp_exact_2 = lambda x: 1.5 * np.cos(1.5 * x) + 0.2 * x\n    d2p_exact_2 = lambda x: -1.5**2 * np.sin(1.5 * x) + 0.2\n\n    # Test Case 3\n    p_exact_3 = lambda x: x * (1 - x) + 0.05 * np.sin(3 * x)\n    dp_exact_3 = lambda x: 1 - 2 * x + 0.15 * np.cos(3 * x)\n    d2p_exact_3 = lambda x: -2 - 0.45 * np.sin(3 * x)\n\n    test_cases = [\n        {\n            \"id\": 1,\n            \"L\": 1.0, \"N\": 16, \"k\": 4.0, \"alpha\": 1.3,\n            \"p_exact\": p_exact_1, \"dp_exact\": dp_exact_1, \"d2p_exact\": d2p_exact_1\n        },\n        {\n            \"id\": 2,\n            \"L\": 1.0, \"N\": 20, \"k\": 8.0, \"alpha\": 2j,\n            \"p_exact\": p_exact_2, \"dp_exact\": dp_exact_2, \"d2p_exact\": d2p_exact_2\n        },\n        {\n            \"id\": 3,\n            \"L\": 1.0, \"N\": 2, \"k\": 1.0, \"alpha\": 0.0,\n            \"p_exact\": p_exact_3, \"dp_exact\": dp_exact_3, \"d2p_exact\": d2p_exact_3\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_fem_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The default string representation of a boolean is 'True' or 'False'.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_fem_case(case_params):\n    \"\"\"\n    Solves the 1D Helmholtz problem for a single test case.\n    \"\"\"\n    L = case_params[\"L\"]\n    N = case_params[\"N\"]\n    k = case_params[\"k\"]\n    alpha = case_params[\"alpha\"]\n    p_exact = case_params[\"p_exact\"]\n    dp_exact = case_params[\"dp_exact\"]\n    d2p_exact = case_params[\"d2p_exact\"]\n    case_id = case_params[\"id\"]\n\n    h = L / N\n    nodes = np.linspace(0, L, N + 1)\n    \n    # Define source and boundary data from manufactured solution\n    s = lambda x: d2p_exact(x) + k**2 * p_exact(x)\n    p_D = p_exact(0)\n    g = dp_exact(L) + alpha * p_exact(L)\n\n    # Determine data type for matrices (complex if k or alpha are complex)\n    dtype = np.complex128 if isinstance(k, complex) or isinstance(alpha, complex) else np.float64\n\n    # Assembly of global matrix A and vector b\n    A = np.zeros((N + 1, N + 1), dtype=dtype)\n    b = np.zeros(N + 1, dtype=dtype)\n\n    # Element matrices\n    K_e = (1/h) * np.array([[1, -1], [-1, 1]])\n    M_e = (h/6) * np.array([[2, 1], [1, 2]])\n    A_e = K_e - k**2 * M_e\n\n    # 2-point Gaussian quadrature for source term\n    gauss_pts_f = np.array([0.5 - 0.5/np.sqrt(3), 0.5 + 0.5/np.sqrt(3)])\n    gauss_wts_f = np.array([0.5, 0.5])\n    \n    for i in range(N):\n        # Global indices for the two nodes of element i\n        idx = np.array([i, i+1])\n        \n        # Assemble element matrix into global matrix\n        A[np.ix_(idx, idx)] += A_e\n\n        # Assemble element force vector using Gaussian quadrature\n        f_e = np.zeros(2, dtype=dtype)\n        for q_pt, q_wt in zip(gauss_pts_f, gauss_wts_f):\n            x_q = nodes[i] + h * q_pt\n            # Linear basis functions on reference element [0,1]\n            N_vals = np.array([1 - q_pt, q_pt])\n            f_e += q_wt * s(x_q) * N_vals\n        b[idx] += h * f_e\n\n    # Apply Robin boundary condition\n    A[N, N] += alpha\n    b[N] += g\n\n    # --- Test Case 2: Check matrix properties before Dirichlet BCs ---\n    if case_id == 2:\n        A_unmodified = A.copy()\n        norm_sym = np.linalg.norm(A_unmodified - A_unmodified.T, 'fro')\n        norm_her = np.linalg.norm(A_unmodified - A_unmodified.conj().T, 'fro')\n        return (norm_sym < 1e-12) and (norm_her > 1e-8)\n        \n    # Apply Dirichlet BC (elimination method)\n    # Modify RHS first, before zeroing out the column\n    if N > 0: # Avoid this for a single element case if p_D is the only unknown\n        b[1:] -= A[1:, 0] * p_D\n    \n    # Modify matrix\n    A[0, :] = 0\n    A[:, 0] = 0\n    A[0, 0] = 1\n    b[0] = p_D\n\n    # Solve linear system\n    u = np.linalg.solve(A, b)\n\n    # --- Test Case 1: Compute L2 error norm ---\n    if case_id == 1:\n        # L2 error calculation using 4-point Gaussian quadrature for accuracy\n        gauss_pts_e, gauss_wts_e = np.polynomial.legendre.leggauss(4)\n        # Map points and weights from [-1, 1] to [0, 1]\n        gauss_pts_e = 0.5 * (gauss_pts_e + 1)\n        gauss_wts_e = 0.5 * gauss_wts_e\n        \n        l2_error_sq = 0.0\n        for i in range(N):\n            elem_error_sq = 0.0\n            for q_pt, q_wt in zip(gauss_pts_e, gauss_wts_e):\n                x_q = nodes[i] + h * q_pt\n                p_h_val = u[i] * (1 - q_pt) + u[i+1] * q_pt\n                error_val = p_h_val - p_exact(x_q)\n                elem_error_sq += q_wt * np.abs(error_val)**2\n            l2_error_sq += h * elem_error_sq\n        return np.sqrt(l2_error_sq)\n\n    # --- Test Case 3: Compute residual norm ---\n    if case_id == 3:\n        residual = A @ u - b\n        return np.linalg.norm(residual, 2)\n\n    return None # Should not be reached\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "Real-world physical systems are often anisotropic, meaning their properties vary with direction. This advanced practice explores how to assemble the stiffness matrix for an anisotropic diffusion problem, where the material's conductivity is described by a tensor $D$. You will not only implement the more complex element matrix calculation but also analyze how the physical anisotropy is imprinted onto the structure and connectivity of the final global matrix. ",
            "id": "3364897",
            "problem": "Consider the anisotropic diffusion problem in two spatial dimensions: find $u \\in H_0^1(\\Omega)$ satisfying the partial differential equation $-\\nabla \\cdot (D(x) \\nabla u) = f$ on the unit square domain $\\Omega = (0,1)^2$ with homogeneous Dirichlet boundary conditions $u|_{\\partial \\Omega} = 0$. Assume $f(x) = 1$. The anisotropy tensor $D(x)$ is symmetric positive definite and, for the purposes of this exercise, piecewise constant per element and parameterized as $D = R(\\theta) \\operatorname{diag}(\\lambda_1,\\lambda_2) R(\\theta)^\\top$ with $\\lambda_1 = r$, $\\lambda_2 = 1$, and $R(\\theta)$ the rotation matrix $R(\\theta) = \\begin{pmatrix} \\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{pmatrix}$. The angle $\\theta$ is given in radians.\n\nStarting from the weak formulation and the standard Continuous Galerkin Finite Element Method (CG-FEM) basis of continuous, piecewise-linear functions on a triangulation of $\\Omega$, derive the element stiffness matrix and element load vector for a single triangle by mapping gradients from the reference element via the Jacobian. Explicitly account for rotational mappings through the tensor $D$ acting on gradients and the reference-to-physical element transformation. Assemble the global stiffness matrix $A$ and the global load vector $b$ by summing contributions from all elements. For analysis, consider the submatrix of $A$ associated with interior (free) degrees of freedom, without applying boundary condition modifications.\n\nDefine a weighted adjacency matrix $W$ from the global matrix $A$ by $w_{ij} = \\max(0, -a_{ij})$ for $i \\neq j$ and $w_{ii} = 0$, i.e., off-diagonal diffusion couplings are treated as positive edge weights. For a threshold parameter $\\alpha \\in [0,1)$, form the thresholded weighted adjacency $W^\\alpha$ by setting entries below $\\tau = \\alpha \\cdot \\max_{i<j} w_{ij}$ to zero, leaving entries at least $\\tau$ unchanged. Measure:\n\n1. The weighted bandwidth $B_w$, defined as the maximum index difference $|i-j|$ over all pairs $(i,j)$ with $w^\\alpha_{ij} > 0$ in the interior-indexed ordering. If there are no such edges, define $B_w = 0$.\n2. The average weighted degree $\\overline{d}_w = \\frac{1}{N} \\sum_{i=1}^N \\sum_{j=1}^N w^\\alpha_{ij}$, where $N$ is the number of interior nodes.\n3. The Fiedler value $\\lambda_2$ of the graph Laplacian $L = \\operatorname{diag}(W^\\alpha \\mathbf{1}) - W^\\alpha$, defined as the second-smallest eigenvalue of $L$. If $N < 2$, define $\\lambda_2 = 0$; if the graph is disconnected, then $\\lambda_2 = 0$ naturally arises from multiple zero eigenvalues.\n\nYour derivation must begin with the weak form $a(u,v) = \\int_\\Omega \\nabla v^\\top D \\nabla u \\, dx$ and the mapping of gradients from the reference element via the Jacobian $J_e$ of the affine map for each triangle. For a triangle with vertices $x_0, x_1, x_2$ in physical coordinates, write the Jacobian $J_e = [x_1 - x_0 \\;\\; x_2 - x_0]$, the reference gradients of the hat functions $\\nabla \\hat{\\varphi}_0 = (-1,-1)^\\top$, $\\nabla \\hat{\\varphi}_1 = (1,0)^\\top$, $\\nabla \\hat{\\varphi}_2 = (0,1)^\\top$, and the physical gradients $\\nabla \\varphi_i = J_e^{-\\top} \\nabla \\hat{\\varphi}_i$. Use these to derive the element stiffness entries and load vector entries. Explain how the rotational anisotropy enters the element bilinear form through $D$ and interacts with $J_e^{-\\top}$ in a rotated mapping sense.\n\nThen, implement the assembly on a uniform structured triangulation of the unit square composed of $N_x \\times N_y$ rectangles, each split into two triangles along the $(i,j) \\to (i+1,j+1)$ diagonal. Number nodes lexicographically by $(i,j)$ with $i$ index varying fastest. Identify interior nodes as those with indices $1 \\le i \\le N_x-1$ and $1 \\le j \\le N_y-1$. Construct $A$ and $b$ for the entire mesh, and extract the interior submatrix of $A$ for the graph analysis.\n\nTest Suite and Input Parameters:\n- Use $N_x = 8$ and $N_y = 8$ for all cases.\n- The anisotropy ratio $r$ and principal angle $\\theta$ are set per test case; $\\theta$ is in radians.\n- The threshold parameter $\\alpha$ is set per test case.\n\nProvide four test cases that probe different aspects:\n1. Isotropic baseline: $(r, \\theta, \\alpha) = (1, 0, 0.2)$.\n2. Strong anisotropy aligned with the $x$-axis: $(r, \\theta, \\alpha) = (100, 0, 0.2)$.\n3. Strong anisotropy rotated by $\\pi/4$ radians: $(r, \\theta, \\alpha) = (100, \\pi/4, 0.2)$.\n4. Moderate anisotropy rotated by $\\pi/3$ radians with a stricter threshold: $(r, \\theta, \\alpha) = (10, \\pi/3, 0.3)$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case contributes a list of three floats $[B_w, \\overline{d}_w, \\lambda_2]$ in that order. The final line therefore has the form $[[B_w^{(1)},\\overline{d}_w^{(1)},\\lambda_2^{(1)}],[B_w^{(2)},\\overline{d}_w^{(2)},\\lambda_2^{(2)}],[B_w^{(3)},\\overline{d}_w^{(3)},\\lambda_2^{(3)}],[B_w^{(4)},\\overline{d}_w^{(4)},\\lambda_2^{(4)}]]$.",
            "solution": "The problem presented is valid. It concerns the numerical solution of a standard anisotropic diffusion partial differential equation using the Continuous Galerkin Finite Element Method (CG-FEM). All components, including the PDE, domain, boundary conditions, discretization method, and subsequent graph-theoretic analysis of the stiffness matrix, are well-defined, scientifically sound, and internally consistent.\n\nThe problem is to find $u \\in H_0^1(\\Omega)$ such that $-\\nabla \\cdot (D(\\mathbf{x}) \\nabla u) = f$ on the domain $\\Omega = (0,1)^2$, with $f(\\mathbf{x}) = 1$ and homogeneous Dirichlet boundary conditions. The anisotropy tensor $D$ is given by $D = R(\\theta) \\operatorname{diag}(r,1) R(\\theta)^\\top$.\n\n**1. Weak Formulation**\n\nMultiplying the PDE by a test function $v \\in H_0^1(\\Omega)$ and integrating over the domain $\\Omega$, we obtain:\n$$\n-\\int_{\\Omega} v (\\nabla \\cdot (D \\nabla u)) \\, d\\mathbf{x} = \\int_{\\Omega} v f \\, d\\mathbf{x}\n$$\nApplying integration by parts (Green's first identity) to the left-hand side yields:\n$$\n\\int_{\\Omega} \\nabla v^\\top (D \\nabla u) \\, d\\mathbf{x} - \\int_{\\partial\\Omega} v (D \\nabla u) \\cdot \\mathbf{n} \\, dS = \\int_{\\Omega} v f \\, d\\mathbf{x}\n$$\nSince $v \\in H_0^1(\\Omega)$, $v=0$ on the boundary $\\partial\\Omega$, so the boundary integral vanishes. This gives the weak formulation: find $u \\in H_0^1(\\Omega)$ such that for all $v \\in H_0^1(\\Omega)$,\n$$\na(u,v) = L(v)\n$$\nwhere the bilinear form $a(u,v)$ and the linear functional $L(v)$ are defined as:\n$$\na(u,v) = \\int_{\\Omega} \\nabla v^\\top D \\nabla u \\, d\\mathbf{x}\n$$\n$$\nL(v) = \\int_{\\Omega} v f \\, d\\mathbf{x} = \\int_{\\Omega} v \\, d\\mathbf{x}\n$$\n\n**2. Finite Element Discretization**\n\nWe discretize the domain $\\Omega$ into a set of non-overlapping triangular elements $K$. We approximate the solution $u$ by a function $u_h$ from a finite-dimensional space $V_h \\subset H_0^1(\\Omega)$, which consists of continuous, piecewise-linear functions. The solution $u_h$ can be written as a linear combination of basis functions $\\varphi_i(\\mathbf{x})$:\n$$\nu_h(\\mathbf{x}) = \\sum_{j=1}^{N_{dof}} u_j \\varphi_j(\\mathbf{x})\n$$\nwhere $u_j$ are the unknown coefficients (nodal values of $u_h$) and $\\varphi_j$ is the \"hat\" basis function which is $1$ at node $j$ and $0$ at all other nodes. Inserting this into the weak form and choosing the test functions $v_h$ to be the basis functions $\\varphi_i$, we obtain a linear system of equations $A\\mathbf{u} = \\mathbf{b}$, where $\\mathbf{u}$ is the vector of unknown coefficients $u_j$, and the entries of the global stiffness matrix $A$ and load vector $\\mathbf{b}$ are:\n$$\nA_{ij} = a(\\varphi_j, \\varphi_i) = \\int_{\\Omega} \\nabla \\varphi_i^\\top D \\nabla \\varphi_j \\, d\\mathbf{x}\n$$\n$$\nb_i = L(\\varphi_i) = \\int_{\\Omega} \\varphi_i f \\, d\\mathbf{x}\n$$\nThese global integrals are computed by summing contributions from each element $K$.\n\n**3. Element-Level Computations**\n\nTo compute the element stiffness matrix $A^e$ and element load vector $\\mathbf{b}^e$ for an element $K$, we map all calculations to a standard reference element $\\hat{K}$, which is a triangle with vertices $\\hat{\\mathbf{x}}_0=(0,0)^\\top$, $\\hat{\\mathbf{x}}_1=(1,0)^\\top$, and $\\hat{\\mathbf{x}}_2=(0,1)^\\top$. The linear basis functions on $\\hat{K}$ are:\n$$\n\\hat{\\varphi}_0(\\hat{\\mathbf{x}}) = 1 - \\hat{x} - \\hat{y} \\quad, \\quad \\hat{\\varphi}_1(\\hat{\\mathbf{x}}) = \\hat{x} \\quad, \\quad \\hat{\\varphi}_2(\\hat{\\mathbf{x}}) = \\hat{y}\n$$\nTheir gradients on the reference element are constant vectors:\n$$\n\\nabla \\hat{\\varphi}_0 = \\begin{pmatrix} -1 \\\\ -1 \\end{pmatrix} \\quad, \\quad \\nabla \\hat{\\varphi}_1 = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} \\quad, \\quad \\nabla \\hat{\\varphi}_2 = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}\n$$\nAn affine map $F_e: \\hat{K} \\to K$ transforms reference coordinates $\\hat{\\mathbf{x}}$ to physical coordinates $\\mathbf{x}$:\n$$\n\\mathbf{x} = F_e(\\hat{\\mathbf{x}}) = J_e \\hat{\\mathbf{x}} + \\mathbf{x}_0\n$$\nwhere $\\mathbf{x}_0, \\mathbf{x}_1, \\mathbf{x}_2$ are the vertices of the physical element $K$, and $J_e$ is the Jacobian of the map, given by $J_e = [\\mathbf{x}_1 - \\mathbf{x}_0 \\;\\; \\mathbf{x}_2 - \\mathbf{x}_0]$. The chain rule relates the gradients in the physical and reference frames:\n$$\n\\nabla \\varphi_i = (J_e^{-1})^\\top \\nabla \\hat{\\varphi}_i = J_e^{-\\top} \\nabla \\hat{\\varphi}_i\n$$\nThe differential area element transforms as $d\\mathbf{x} = |\\det(J_e)| d\\hat{\\mathbf{x}}$.\n\nThe entries of the $3 \\times 3$ element stiffness matrix $A^e$ are given by:\n$$\nA^e_{ij} = \\int_K \\nabla \\varphi_i^\\top D \\nabla \\varphi_j \\, d\\mathbf{x}\n$$\nSubstituting the transformations:\n$$\nA^e_{ij} = \\int_{\\hat{K}} (J_e^{-\\top} \\nabla \\hat{\\varphi}_i)^\\top D (J_e^{-\\top} \\nabla \\hat{\\varphi}_j) \\, |\\det(J_e)| d\\hat{\\mathbf{x}}\n$$\nSince $D$ is constant on the element and the gradients are constant vectors, we can pull them out of the integral:\n$$\nA^e_{ij} = (\\nabla \\hat{\\varphi}_i)^\\top J_e^{-1} D J_e^{-\\top} \\nabla \\hat{\\varphi}_j \\, |\\det(J_e)| \\int_{\\hat{K}} 1 \\, d\\hat{\\mathbf{x}}\n$$\nThe area of the reference element is $\\int_{\\hat{K}} 1 \\, d\\hat{\\mathbf{x}} = 1/2$. Therefore,\n$$\nA^e_{ij} = \\frac{1}{2}|\\det(J_e)| (\\nabla \\hat{\\varphi}_i)^\\top (J_e^{-1} D J_e^{-\\top}) \\nabla \\hat{\\varphi}_j\n$$\nThis expression shows the interaction between the material anisotropy $D$ and the geometric distortion encoded by the Jacobian $J_e$. The matrix $J_e^{-\\top}$ maps reference gradients $\\nabla\\hat{\\varphi}$ to physical space, where they are acted upon by the physics-defined tensor $D$.\n\nThe entries of the element load vector $\\mathbf{b}^e$ (with $f=1$) are:\n$$\nb^e_i = \\int_K f \\varphi_i \\, d\\mathbf{x} = \\int_{\\hat{K}} \\hat{\\varphi}_i(\\hat{\\mathbf{x}}) |\\det(J_e)| d\\hat{\\mathbf{x}} = |\\det(J_e)| \\int_{\\hat{K}} \\hat{\\varphi}_i \\, d\\hat{\\mathbf{x}}\n$$\nThe integral $\\int_{\\hat{K}} \\hat{\\varphi}_i \\, d\\hat{\\mathbf{x}}$ evaluates to $1/6$ for each $i \\in \\{0,1,2\\}$. Thus,\n$$\nb^e_i = \\frac{|\\det(J_e)|}{6} = \\frac{\\text{Area}(K)}{3}\n$$\nThe load is distributed equally among the element's three nodes.\n\n**4. Global Assembly and Graph Analysis**\n\nThe global stiffness matrix $A$ and load vector $\\mathbf{b}$ are formed by iterating through all elements, computing $A^e$ and $\\mathbf{b}^e$, and adding their entries to the corresponding global positions based on the element-to-global node index mapping.\n\nAfter assembly, the submatrix $A_{int}$ corresponding to the $N$ interior (free) degrees of freedom is extracted. For a diffusion problem, this matrix is symmetric positive-definite, and its off-diagonal entries $A_{int, ij}$ are non-positive for nodes $i, j$ sharing an element.\n\nFrom $A_{int}$, a weighted adjacency matrix $W$ is formed:\n$$\nw_{ij} = \\max(0, -A_{int,ij}) \\text{ for } i \\neq j, \\text{ and } w_{ii} = 0.\n$$\nThis matrix represents the strength of diffusive coupling between nodes. A thresholded matrix $W^\\alpha$ is then created by setting all weights $w_{ij}$ smaller than a threshold $\\tau = \\alpha \\cdot \\max_{k<l} w_{kl}$ to $0$.\n\nThe following metrics are then computed from $W^\\alpha$:\n1.  **Weighted Bandwidth $B_w$**: The maximum index separation $|i-j|$ over all pairs with $w^\\alpha_{ij} > 0$ using interior-node indexing.\n2.  **Average Weighted Degree $\\overline{d}_w$**: The sum of all entries in $W^\\alpha$ divided by the number of interior nodes, $\\overline{d}_w = \\frac{1}{N} \\sum_{i,j=1}^N w^\\alpha_{ij}$.\n3.  **Fiedler Value $\\lambda_2$**: The second-smallest eigenvalue of the graph Laplacian $L = \\operatorname{diag}(W^\\alpha \\mathbf{1}) - W^\\alpha$, which indicates the algebraic connectivity of the graph.\n\nThe implementation will perform these steps for the specified mesh parameters and test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It implements FEM assembly for an anisotropic diffusion problem and\n    performs graph analysis on the resulting stiffness matrix.\n    \"\"\"\n\n    test_cases = [\n        {'r': 1, 'theta': 0, 'alpha': 0.2},\n        {'r': 100, 'theta': 0, 'alpha': 0.2},\n        {'r': 100, 'theta': np.pi / 4, 'alpha': 0.2},\n        {'r': 10, 'theta': np.pi / 3, 'alpha': 0.3},\n    ]\n    Nx = 8\n    Ny = 8\n\n    results = []\n    for case in test_cases:\n        r, theta, alpha = case['r'], case['theta'], case['alpha']\n        result_metrics = compute_metrics(Nx, Ny, r, theta, alpha)\n        results.append(result_metrics)\n    \n    # Format the final output string carefully to avoid extra spaces\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef compute_metrics(Nx, Ny, r, theta, alpha):\n    \"\"\"\n    Computes the required metrics for a single parameter set.\n    \"\"\"\n    # 1. Mesh Generation\n    num_nodes_x = Nx + 1\n    num_nodes_y = Ny + 1\n    total_nodes = num_nodes_x * num_nodes_y\n    h_x = 1.0 / Nx\n    h_y = 1.0 / Ny\n\n    # Node coordinates, indexed lexicographically with x-index fastest\n    nodes = np.array([[i * h_x, j * h_y] for j in range(num_nodes_y) for i in range(num_nodes_x)])\n\n    # Element connectivity\n    elements = []\n    for j in range(Ny):\n        for i in range(Nx):\n            p00 = j * num_nodes_x + i\n            p10 = j * num_nodes_x + i + 1\n            p01 = (j + 1) * num_nodes_x + i\n            p11 = (j + 1) * num_nodes_x + i + 1\n            # Triangle 1 from splitting the rectangle\n            elements.append([p00, p10, p11])\n            # Triangle 2 from splitting the rectangle\n            elements.append([p00, p11, p01])\n\n    # 2. Anisotropy Tensor D\n    c, s = np.cos(theta), np.sin(theta)\n    R = np.array([[c, -s], [s, c]])\n    D_diag = np.diag([r, 1.0])\n    D = R @ D_diag @ R.T\n\n    # 3. Global Matrix Assembly\n    A = np.zeros((total_nodes, total_nodes))\n    \n    # Gradients of basis functions on the reference element, stored as columns in a 2x3 matrix.\n    grad_ref_basis = np.array([[-1.0, 1.0, 0.0], [-1.0, 0.0, 1.0]])\n\n    for element_nodes in elements:\n        v0, v1, v2 = nodes[element_nodes]\n        \n        # Jacobian of the affine map from reference to physical element\n        J = np.array([v1 - v0, v2 - v0]).T\n        detJ = np.linalg.det(J)\n        area_K = 0.5 * abs(detJ)\n        J_inv = np.linalg.inv(J)\n\n        # Transformation matrix for gradients\n        # grad_phys = J_inv.T @ grad_ref\n        J_inv_T = J_inv.T\n        \n        # Physical gradients of basis functions (as columns in a 2x3 matrix)\n        grad_phys_basis = J_inv_T @ grad_ref_basis\n\n        # Element stiffness matrix A^e = Area(K) * (grad_phys)^T * D * (grad_phys)\n        A_e = area_K * (grad_phys_basis.T @ D @ grad_phys_basis)\n        \n        # Assemble A^e into global matrix A\n        for i_local in range(3):\n            i_global = element_nodes[i_local]\n            for j_local in range(3):\n                j_global = element_nodes[j_local]\n                A[i_global, j_global] += A_e[i_local, j_local]\n\n    # 4. Extract Interior Submatrix\n    interior_nodes_indices = [j * num_nodes_x + i for j in range(1, Ny) for i in range(1, Nx)]\n    A_int = A[np.ix_(interior_nodes_indices, interior_nodes_indices)]\n    \n    # 5. Graph Analysis\n    N = len(interior_nodes_indices)\n    \n    # Adjacency matrix W from interior stiffness matrix A_int\n    W = -A_int\n    np.fill_diagonal(W, 0)\n    W[W < 0] = 0\n    \n    # Thresholded adjacency matrix W_alpha\n    if np.any(W > 0):\n        tau = alpha * np.max(W)\n    else:\n        tau = 0.0\n    \n    W_alpha = W.copy()\n    W_alpha[W_alpha < tau] = 0\n\n    # Metric 1: Weighted Bandwidth B_w\n    rows, cols = np.where(W_alpha > 0)\n    B_w = np.max(np.abs(rows - cols)) if rows.size > 0 else 0\n\n    # Metric 2: Average Weighted Degree d_w_bar\n    d_w_bar = np.sum(W_alpha) / N if N > 0 else 0.0\n\n    # Metric 3: Fiedler Value lambda_2\n    if N < 2:\n        lambda_2 = 0.0\n    else:\n        # Graph Laplacian L = Diag(degrees) - W_alpha\n        S = np.sum(W_alpha, axis=1)\n        L = np.diag(S) - W_alpha\n        # Eigenvalues of L (L is symmetric, use eigh for efficiency)\n        eigvals = eigh(L, eigvals_only=True)\n        lambda_2 = eigvals[1]\n\n    return [float(B_w), d_w_bar, lambda_2]\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}