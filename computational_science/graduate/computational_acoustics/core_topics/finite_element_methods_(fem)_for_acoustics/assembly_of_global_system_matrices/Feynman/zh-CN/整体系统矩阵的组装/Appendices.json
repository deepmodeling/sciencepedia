{
    "hands_on_practices": [
        {
            "introduction": "要真正理解全局系统矩阵是如何形成的，没有什么比亲手构建一个更有效了。本练习将引导您完成一个简单热扩散问题的有限元方法基本步骤。通过手动计算局部刚度矩阵的各项，并将其组装到全局系统中，您将对局部单元贡献如何结合形成整体问题表达式获得具体而深刻的理解。",
            "id": "4020951",
            "problem": "考虑在邻近预混火焰的薄惰性衬垫段中的稳态热扩散，该问题在无量纲单位正方形域 $\\Omega = [0,1] \\times [0,1]$ 上建模，其导热系数 $k$ 为各向同性的空间常数，且体积热源为零。控制方程为稳态能量守恒方程，即在 $\\Omega$ 中 $-\\nabla \\cdot \\left( k \\nabla T \\right) = 0$，并在外边界上施加狄利克雷边界条件。使用有限元(FE)法，在三角形上采用分段线性拉格朗日基函数对弱形式进行离散化。\n\n计算网格在四个角点处有节点，并在中心有一个内部节点：节点 $1$ 位于 $(0,0)$，节点 $2$ 位于 $(1,0)$，节点 $3$ 位于 $(1,1)$，节点 $4$ 位于 $(0,1)$，节点 $5$ 位于 $(0.5,0.5)$。通过将中心节点连接到每个角点，网格被三角剖分为四个三角形：三角形 $(1,2,5)$、$(2,3,5)$、$(3,4,5)$ 和 $(4,1,5)$。边界节点温度被指定为狄利克雷约束：$T_{1} = 723.4 \\text{ K}$，$T_{2} = 921.7 \\text{ K}$，$T_{3} = 801.3 \\text{ K}$ 及 $T_{4} = 649.8 \\text{ K}$。导热系数为 $k = 1$。\n\n任务：\n- 在任意三角形上，用其重心坐标定义局部分段线性拉格朗日基函数，并在笛卡尔坐标系中表示其梯度。\n- 从扩散方程的弱形式出发，使用这些基函数为任意三角形构建局部单元刚度矩阵。\n- 对于顶点为 $(0,0)$、$(1,0)$ 和 $(0.5,0.5)$ 的三角形 $(1,2,5)$，计算基函数的梯度及其局部刚度矩阵的所有条目。通过对称性解释这对其他三个三角形意味着什么。\n- 为内部节点 $5$ 组装全局刚度矩阵行，并强施加狄利克雷边界条件（通过消元法），以获得求解未知内部温度 $T_{5}$ 的标量线性方程。\n- 使用给定的边界值求解此标量方程以得到 $T_{5}$。\n\n将最终答案表示为 $T_{5}$ 的开尔文值。将答案四舍五入到五位有效数字。在最终的数值答案中不要包含单位。",
            "solution": "用户要求我使用有限元法(FEM)求解一个方形域上的稳态热扩散问题。\n\n### 步骤1：提取已知条件\n- **控制方程：** 稳态热扩散 $-\\nabla \\cdot (k \\nabla T) = 0$ 于 $\\Omega$ 中。\n- **域：** $\\Omega = [0,1] \\times [0,1]$。\n- **导热系数：** $k=1$ (恒定且各向同性)。\n- **源项：** $0$。\n- **离散化方法：** 有限元法，在三角形上使用分段线性拉格朗日基函数。\n- **网格节点：**\n  - 节点 $1$: $(0,0)$\n  - 节点 $2$: $(1,0)$\n  - 节点 $3$: $(1,1)$\n  - 节点 $4$: $(0,1)$\n  - 节点 $5$: $(0.5,0.5)$\n- **网格单元（三角形）：**\n  - $\\Omega_1$: $(1,2,5)$\n  - $\\Omega_2$: $(2,3,5)$\n  - $\\Omega_3$: $(3,4,5)$\n  - $\\Omega_4$: $(4,1,5)$\n- **边界条件（狄利克雷）：**\n  - $T_1 = 723.4$\n  - $T_2 = 921.7$\n  - $T_3 = 801.3$\n  - $T_4 = 649.8$\n\n### 步骤2：使用提取的已知条件进行验证\n1.  **科学依据：** 问题描述了稳态热传导，对于恒定的导热系数，该过程由拉普拉斯方程控制。这是热传递和物理学中的一个基本且公认的原理。该设置在科学上是合理的。\n2.  **适定性：** 该问题是一个标准的椭圆边界值问题（在闭合域上带有狄利克雷边界条件的拉普拉斯方程）。众所周知，此类问题是适定的，存在唯一且稳定的解。使用有限元法进行离散化也是一个标准且有效的程序。\n3.  **客观性：** 问题是用精确的数学语言和数值数据表述的。没有主观或模糊的陈述。\n4.  **完整性和一致性：** 问题提供了进行求解所需的所有必要信息：控制方程、域、网格几何形状、边界条件和材料属性。数据是自洽的。\n5.  **相关性：** 固体衬垫中的热扩散问题与计算燃烧学直接相关，在计算燃烧学中，热气体和固体部件之间的共轭传热是一个需要建模的关键现象。\n\n### 步骤3：结论与行动\n问题是有效的。将提供一个完整的解。\n\n### 解题推导\n控制方程是无热源的稳态热扩散方程，对于常数导热系数 $k$，该方程简化为拉普拉斯方程：\n$$ -k \\nabla^2 T = 0 $$\n通过乘以一个测试函数 $v$ 并在域 $\\Omega$ 上积分来导出弱形式。使用分部积分法（格林第一恒等式），我们得到：\n$$ \\int_{\\Omega} k (\\nabla v) \\cdot (\\nabla T) \\,d\\Omega - \\int_{\\partial\\Omega} v (k \\nabla T \\cdot \\mathbf{n}) \\,dS = 0 $$\n对于有限元法，我们将温度场 $T(x,y)$ 近似为基函数 $N_j(x,y)$ 的线性组合：\n$$ T_h(x,y) = \\sum_{j=1}^{5} T_j N_j(x,y) $$\n其中 $T_j$ 是未知的节点温度。使用伽辽金法，我们选择测试函数 $v$ 为基函数 $N_i(x,y)$。强施加狄利克雷边界条件时，对于与内部节点相关的测试函数，边界积分的贡献为零。得到的线性方程组为 $K \\mathbf{T} = \\mathbf{F}$，其中全局刚度矩阵 $K$ 的条目由单元刚度矩阵 $K^e$ 组装而成：\n$$ K_{ij} = \\sum_{e} K_{ij}^e = \\sum_{e} \\int_{\\Omega_e} k (\\nabla N_i) \\cdot (\\nabla N_j) \\,d\\Omega $$\n向量 $\\mathbf{F}$ 包含源项和自然边界条件的贡献，在本问题中这些都为零。\n\n**任务1：基函数和梯度**\n对于一个顶点为 $(x_1, y_1)$、$(x_2, y_2)$、$(x_3, y_3)$ 的三角形单元，分段线性拉格朗日基函数 $N_i(x,y)$ 与重心坐标 $\\lambda_i(x,y)$ 相同。基函数 $N_i$ 在节点 $i$ 处等于 $1$，在其他两个节点处等于 $0$。该函数可以写成 $N_i(x,y) = a_i + b_i x + c_i y$。基函数的梯度在单元内是一个常数向量：\n$$ \\nabla N_i = \\begin{pmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} b_i \\\\ c_i \\end{pmatrix} $$\n系数由下式给出：\n$$ b_1 = \\frac{y_2 - y_3}{2 A_e}, \\quad c_1 = \\frac{x_3 - x_2}{2 A_e} $$\n$$ b_2 = \\frac{y_3 - y_1}{2 A_e}, \\quad c_2 = \\frac{x_1 - x_3}{2 A_e} $$\n$$ b_3 = \\frac{y_1 - y_2}{2 A_e}, \\quad c_3 = \\frac{x_2 - x_1}{2 A_e} $$\n其中 $A_e$ 是三角形的面积。\n\n**任务2：局部单元刚度矩阵**\n由于基函数梯度和导热系数 $k$ 在线性三角形单元上是常数，单元刚度矩阵的积分简化为：\n$$ K_{ij}^e = \\int_{\\Omega_e} k (\\nabla N_i) \\cdot (\\nabla N_j) \\,d\\Omega = k ((\\nabla N_i) \\cdot (\\nabla N_j)) \\int_{\\Omega_e} \\,d\\Omega = k A_e (\\nabla N_i \\cdot \\nabla N_j) $$\n$$ K_{ij}^e = k A_e (b_i b_j + c_i c_j) $$\n\n**任务3：对三角形(1,2,5)进行计算**\n设单元 $\\Omega_1$ 为具有全局节点 $(1,2,5)$ 的三角形。我们分别将局部节点索引 $1,2,3$ 分配给全局节点 $1,2,5$。\n顶点为：$(x_1,y_1) = (0,0)$，$(x_2,y_2) = (1,0)$，以及 $(x_3,y_3) = (0.5,0.5)$。\n面积 $A_e$ 计算如下：\n$$ 2 A_e = \\det \\begin{pmatrix} x_1 & y_1 & 1 \\\\ x_2 & y_2 & 1 \\\\ x_3 & y_3 & 1 \\end{pmatrix} = \\det \\begin{pmatrix} 0 & 0 & 1 \\\\ 1 & 0 & 1 \\\\ 0.5 & 0.5 & 1 \\end{pmatrix} = 1(1 \\cdot 0.5 - 0 \\cdot 0.5) = 0.5 $$\n所以，$A_e = 0.25$。\n与局部节点相关的基函数的梯度为：\n- 对于局部节点 $1$ (全局节点 $1$):\n  $b_1 = \\frac{0 - 0.5}{0.5} = -1$, $c_1 = \\frac{0.5 - 1}{0.5} = -1$。\n  $\\nabla N_1 = \\begin{pmatrix} -1 \\\\ -1 \\end{pmatrix}$。\n- 对于局部节点 $2$ (全局节点 $2$):\n  $b_2 = \\frac{0.5 - 0}{0.5} = 1$, $c_2 = \\frac{0 - 0.5}{0.5} = -1$。\n  $\\nabla N_2 = \\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix}$。\n- 对于局部节点 $3$ (全局节点 $5$):\n  $b_3 = \\frac{0 - 0}{0.5} = 0$, $c_3 = \\frac{1 - 0}{0.5} = 2$。\n  $\\nabla N_5 = \\begin{pmatrix} 0 \\\\ 2 \\end{pmatrix}$。\n\n当 $k=1$ 且 $A_e=0.25$ 时，局部刚度矩阵 $K^{(1,2,5)}$ 的条目为：\n$K_{11}^e = (1)(0.25)((-1)^2 + (-1)^2) = 0.25 \\times 2 = 0.5$\n$K_{12}^e = (1)(0.25)((-1)(1) + (-1)(-1)) = 0.25 \\times 0 = 0$\n$K_{15}^e = (1)(0.25)((-1)(0) + (-1)(2)) = 0.25 \\times (-2) = -0.5$\n$K_{22}^e = (1)(0.25)(1^2 + (-1)^2) = 0.25 \\times 2 = 0.5$\n$K_{25}^e = (1)(0.25)((1)(0) + (-1)(2)) = 0.25 \\times (-2) = -0.5$\n$K_{55}^e = (1)(0.25)(0^2 + 2^2) = 0.25 \\times 4 = 1.0$\n对于单元 $(1,2,5)$，按全局节点编号索引的局部刚度矩阵为：\n$$ K^{(1,2,5)} = \\begin{pmatrix} 0.5 & 0 & -0.5 \\\\ 0 & 0.5 & -0.5 \\\\ -0.5 & -0.5 & 1.0 \\end{pmatrix}_{\\text{rows/cols for nodes } 1,2,5} $$\n其他三个三角形 $(2,3,5)$、$(3,4,5)$ 和 $(4,1,5)$ 通过围绕域中心的旋转和反射与三角形 $(1,2,5)$ 全等。由于局部刚度矩阵的公式仅取决于三角形的几何形状（对所有四个三角形都相同），因此只要使用一致的局部节点编号方案（例如，将中心节点映射到局部节点3，将两个边界节点映射到局部节点1和2），它们各自局部刚度矩阵中的条目数值将是相同的。\n\n**任务4：全局刚度矩阵组装和边界条件施加**\n我们需要找到未知温度 $T_5$ 的方程。这对应于全局系统 $K \\mathbf{T} = \\mathbf{F}$ 的第五行。由于没有源项，初始方程为：\n$$ K_{51}T_1 + K_{52}T_2 + K_{53}T_3 + K_{54}T_4 + K_{55}T_5 = 0 $$\n系数 $K_{5j}$ 是通过对包含节点 $5$ 的所有单元的贡献求和来组装的。节点 $5$ 是所有四个单元的一部分。\n- $K_{55}$：对角项从每个单元刚度矩阵的 $(5,5)$ 条目中获得贡献。在我们的局部表示法中，这对应于局部矩阵的 $(3,3)$ 条目。\n  $K_{55} = K_{55}^{(1,2,5)} + K_{55}^{(2,3,5)} + K_{55}^{(3,4,5)} + K_{55}^{(4,1,5)} = 1.0 + 1.0 + 1.0 + 1.0 = 4.0$。\n- $K_{51}$：这个非对角项从包含节点 $1$ 和 $5$ 的单元中获得贡献。这些是单元 $(1,2,5)$ 和 $(4,1,5)$。\n  从 $K^{(1,2,5)}$，贡献为 $K_{15}^e = -0.5$。\n  由于对称性，从 $K^{(4,1,5)}$ 的贡献也是 $-0.5$。\n  $K_{51} = -0.5 + (-0.5) = -1.0$。\n- $K_{52}$：该项从单元 $(1,2,5)$ 和 $(2,3,5)$ 获得贡献。\n  从 $K^{(1,2,5)}$，贡献为 $K_{25}^e = -0.5$。\n  从 $K^{(2,3,5)}$，贡献也是 $-0.5$。\n  $K_{52} = -0.5 + (-0.5) = -1.0$。\n- 根据网格的对称性，其余的非对角项也为 $-1.0$：\n  $K_{53} = -1.0$\n  $K_{54} = -1.0$\n\n为节点 $5$ 组装的方程是：\n$$ -1.0 T_1 - 1.0 T_2 - 1.0 T_3 - 1.0 T_4 + 4.0 T_5 = 0 $$\n施加狄利克雷边界条件意味着将已知的 $T_1, T_2, T_3, T_4$ 值代入此方程。这是一个关于单个未知数 $T_5$ 的单个线性方程。\n\n**任务5：求解 $T_5$**\n重新整理方程以求解 $T_5$：\n$$ 4.0 T_5 = T_1 + T_2 + T_3 + T_4 $$\n$$ T_5 = \\frac{T_1 + T_2 + T_3 + T_4}{4} $$\n这个结果表明，对于这个特定的对称网格，中心的有限元解是角点温度的算术平均值，这与离散最大值原理一致，并模仿了调和函数的平均值性质。\n代入给定的边界温度值：\n$$ T_5 = \\frac{723.4 + 921.7 + 801.3 + 649.8}{4} $$\n$$ T_5 = \\frac{3096.2}{4} $$\n$$ T_5 = 774.05 $$\n问题要求答案保留五位有效数字。计算值 $774.05$ 已经有五位有效数字。",
            "answer": "$$\\boxed{774.05}$$"
        },
        {
            "introduction": "掌握了手动组装过程后，下一步就是通过代码将其自动化。本练习将挑战您为一个一维声学问题实现一个有限元求解器，其中引入了亥姆霍兹方程和罗宾边界条件的复杂性。您将使用“制造解方法”（Method of Manufactured Solutions）——一种强大的代码验证技术——来测试您的实现，从而确保其准确性和鲁棒性。",
            "id": "4117066",
            "problem": "考虑在区间 $x \\in (0,L)$ 上的一维频域声学模型，其未知声压 $p(x)$ 由微分方程 $p''(x) + k^2 p(x) = s(x)$ 和边界条件 $p(0) = p_D$ 及 $p'(L) + \\alpha p(L) = g$ 控制。所有量均为无量纲。目标是使用一阶（线性）单元，验证伽辽金有限元法中全局系统矩阵组装的正确性。\n\n从控制微分方程和边界条件出发，通过将方程乘以任意测试函数 $v(x)$ 并进行分部积分来推导弱形式。通过对单元刚度矩阵和质量矩阵的贡献求和来组装全局系统矩阵，并并入 $x=L$ 处的 Robin 边界项。在全局系统中使用消元法施加狄利克雷条件 $p(0) = p_D$。求解所得的线性系统，以获得节点基上的离散解 $p_h(x)$。\n\n您的程序必须实现以下内容：\n\n- 在 $(0,L)$ 上使用一个包含 $N$ 个单元的均匀网格，节点为 $x_i = i h$，$i = 0,1,\\dots,N$，其中 $h = L/N$。\n- 在每个单元上使用一阶（线性）基函数，并使用两点高斯求积法则从源项 $s(x)$ 计算单元载荷向量。\n- 组装与弱形式相对应的全局系统矩阵，该矩阵结合了刚度项、由 $k^2$ 引起的负质量贡献以及在 $x=L$ 处的 Robin 边界贡献。将由 $g$ 引起的边加载荷添加到全局右端项。\n- 通过在全局矩阵和右端项中进行消元，在 $x=0$ 处施加狄利克雷边界条件（即，一致地修改第一行和第一列，以强加 $p(0) = p_D$）。\n- 求解全局线性系统以获得节点值，并计算指定的验证量。\n\n为确保可测试性和覆盖率，请使用人造解法：定义一个光滑的精确压力 $p_{\\mathrm{exact}}(x)$，并设置源项 $s(x) = p_{\\mathrm{exact}}''(x) + k^2 p_{\\mathrm{exact}}(x)$ 和 Robin 数据 $g = p_{\\mathrm{exact}}'(L) + \\alpha p_{\\mathrm{exact}}(L)$；设置狄利克雷值 $p_D = p_{\\mathrm{exact}}(0)$。这确保了精确解满足微分方程和边界条件。\n\n实现以下三个测试用例：\n\n- 测试用例 1 (一般情况): $L = 1$, $N = 16$, $k = 4$, $\\alpha = 1.3$, $p_{\\mathrm{exact}}(x) = \\sin(2 x) + 0.3 x$。计算误差的 $L^2$ 范数 $||p_h - p_{\\mathrm{exact}}||_{L^2(0,L)}$，结果为浮点数。\n- 测试用例 2 (阻抗边界对称性检查): $L = 1$, $N = 20$, $k = 8$, $\\alpha = 2 \\mathrm{i}$ (纯虚数), $p_{\\mathrm{exact}}(x) = \\sin(1.5 x) + 0.1 x^2$。组装全局矩阵 $A$。如果 $||A - A^T||_F < 10^{-12}$ 且 $||A - A^H||_F > 10^{-8}$，则返回布尔值 true，其中 $A^T$ 表示转置，$A^H$ 表示共轭转置，而 $||\\cdot||_F$ 是弗罗贝尼乌斯范数。\n- 测试用例 3 (粗网格下的边界边缘情况): $L = 1$, $N = 2$, $k = 1$, $\\alpha = 0$, $p_{\\mathrm{exact}}(x) = x (1 - x) + 0.05 \\sin(3 x)$。求解后，计算残差的欧几里得范数 $||A u - b||_2$，结果为浮点数，其中 $u$ 是节点值向量，$A$ 是施加狄利克雷条件后的组装矩阵，$b$ 是右端项向量。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，排序如下：测试用例 1 的 $L^2$ 误差（浮点数），测试用例 2 的对称性和埃尔米特属性布尔值（布尔值），以及测试用例 3 的残差范数（浮点数）。例如，输出格式必须严格为“[result1,result2,result3]”。",
            "solution": "该问题是有效的，因为它提出了一个计算声学领域中适定且有科学依据的问题，具体来说是一维亥姆霍兹方程的有限元解。所有必要的参数、方程和验证程序均已提供，该任务是偏微分方程数值方法中的一个标准练习。\n\n### 弱形式的推导\n\n一维频域声学模型的控制强形式由以下微分方程给出：\n$$ p''(x) + k^2 p(x) = s(x) \\quad \\text{for } x \\in (0, L) $$\n其在 $x=0$ 处有一个狄利克雷边界条件，在 $x=L$ 处有一个 Robin 边界条件：\n$$ p(0) = p_D $$\n$$ p'(L) + \\alpha p(L) = g $$\n这里，$p(x)$ 是未知声压，$k$ 是波数，$s(x)$ 是源项，$\\alpha$ 和 $g$ 定义了 Robin 边界条件。\n\n为了推导弱形式，我们将微分方程乘以一个属于合适函数空间的任意测试函数 $v(x)$，并在域 $(0, L)$ 上积分。测试函数必须满足任何本质（狄利克雷）边界条件的齐次形式，因此我们要求 $v(0)=0$。\n$$ \\int_0^L \\left( p''(x) + k^2 p(x) \\right) v(x) \\, dx = \\int_0^L s(x) v(x) \\, dx $$\n我们对二阶导数项使用分部积分：\n$$ \\int_0^L p''(x) v(x) \\, dx = \\left[ p'(x) v(x) \\right]_0^L - \\int_0^L p'(x) v'(x) \\, dx $$\n边界项为 $\\left[ p'(x) v(x) \\right]_0^L = p'(L)v(L) - p'(0)v(0)$。由于我们选择的 $v(x)$ 满足 $v(0)=0$，这简化为 $p'(L)v(L)$。将其代回积分方程得到：\n$$ - \\int_0^L p'(x) v'(x) \\, dx + p'(L)v(L) + \\int_0^L k^2 p(x) v(x) \\, dx = \\int_0^L s(x) v(x) \\, dx $$\n接下来，我们通过代入 $p'(L) = g - \\alpha p(L)$ 来引入 Robin 边界条件：\n$$ - \\int_0^L p'(x) v'(x) \\, dx + \\left( g - \\alpha p(L) \\right) v(L) + \\int_0^L k^2 p(x) v(x) \\, dx = \\int_0^L s(x) v(x) \\, dx $$\n重新整理各项，将所有包含未知量 $p(x)$ 的表达式分组到左側 (LHS)，并将已知量分组到右侧 (RHS)，我们得到最终的弱形式：\n寻找压力 $p(x)$，使其满足 $p(0)=p_D$ 且对于所有容许的测试函数 $v(x)$：\n$$ \\int_0^L p'(x) v'(x) \\, dx - k^2 \\int_0^L p(x) v(x) \\, dx + \\alpha p(L) v(L) = \\int_0^L s(x) v(x) \\, dx + g v(L) $$\n该方程的形式为 $a(p,v) = L(v)$，其中 $a(p,v)$ 是一个双线性形式，$L(v)$ 是一个线性泛函。\n\n### 有限元离散化\n\n我们将域 $(0, L)$ 离散化为 $N$ 个长度为 $h = L/N$ 的均匀单元。节点位于 $x_i = ih$，$i=0, 1, \\dots, N$。我们使用一阶（线性）基函数 $\\phi_j(x)$ 的线性组合来近似压力 $p(x)$：\n$$ p_h(x) = \\sum_{j=0}^N u_j \\phi_j(x) $$\n其中 $u_j = p_h(x_j)$ 是压力的未知节点值，$\\phi_j(x)$ 是“帽子”函数，它在节点 $x_j$ 处为 1，在所有其他节点处为 0。\n\n在伽辽金方法中，我们使用基函数作为测试函数，即 $v(x) = \\phi_i(x)$，$i=1, \\dots, N$。$i=0$ 的方程为狄利克雷条件保留。将 $p_h(x)$ 和 $v(x)=\\phi_i(x)$ 的展开式代入弱形式，得到一个线性方程组 $A \\mathbf{u} = \\mathbf{b}$，其中 $\\mathbf{u} = [u_0, u_1, \\dots, u_N]^T$。\n\n全局系统矩阵 $A$ 和右端项向量 $\\mathbf{b}$ 的项由以下公式给出：\n$$ A_{ij} = \\int_0^L \\phi_i'(x) \\phi_j'(x) \\, dx - k^2 \\int_0^L \\phi_i(x) \\phi_j(x) \\, dx + \\alpha \\phi_i(L) \\phi_j(L) $$\n$$ b_i = \\int_0^L s(x) \\phi_i(x) \\, dx + g \\phi_i(L) $$\n\n这些全局矩阵通过对每个单元的贡献求和来组装。对于长度为 $h$ 的一般单元，单元刚度矩阵 $K^e$ 和单元质量矩阵 $M^e$ 是：\n$$ K^e = \\frac{1}{h} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}, \\quad M^e = \\frac{h}{6} \\begin{pmatrix} 2 & 1 \\\\ 1 & 2 \\end{pmatrix} $$\n单元矩阵为 $A^e = K^e - k^2 M^e$。\n\nRobin 边界项 $\\alpha p(L)v(L)$ 仅当 $p(L)$ 和 $v(L)$ 都非零时才有贡献。在我们的离散化中，这在 $\\phi_i = \\phi_N$ 和 $\\phi_j = \\phi_N$ 时发生。因此，值 $\\alpha$ 被加到全局矩阵的 $A_{N,N}$ 项。类似地，项 $g v(L)$ 仅对第 $N$ 个方程有贡献，将 $g$ 加到 $b_N$。\n\n源项对右端项的贡献 $\\int s(x) \\phi_i(x) dx$ 使用两点高斯求积法则逐单元计算。\n\n### 边界条件施加\n\n狄利克雷条件 $p(0) = p_D$ 通过修改完全组装好的关于 $\\mathbf{u}$ 的线性系统来施加。该条件转化为 $u_0 = p_D$。我们使用消元法：\n1. 第一个方程（第 $0$ 行）被替换为 $1 \\cdot u_0 = p_D$。这通过设置 $A_{00}=1$，$A_{0j}=0$ for $j>0$ 和 $b_0=p_D$ 来实现。\n2. 已知值 $u_0$ 的影响从其他方程中减去。对于每一行 $i > 0$，项 $A_{i0} u_0$ 被移到右端项：$b_i \\leftarrow b_i - A_{i0} p_D$。然后将矩阵的第一列（对于 $i>0$）置零：$A_{i0}=0$。\n\n在这些修改之后，求解所得系统以获得节点值 $\\mathbf{u}$。\n\n### 验证量\n\n- **误差的 $L^2$ 范数**：$||p_h - p_{\\mathrm{exact}}||_{L^2} = (\\int_0^L |p_h(x) - p_{\\mathrm{exact}}(x)|^2 dx)^{1/2}$。该积分通过对每个单元的贡献求和来进行数值计算，并使用足够精确的求积法则（例如，4点高斯求积）进行评估。\n- **矩阵属性**：施加狄利克雷条件前的矩阵 $A$ 是 $A = K - k^2 M + B_\\alpha$，其中 $K$ 和 $M$ 是全局刚度矩阵和质量矩阵，$B_\\alpha$ 是一个在 $(N,N)$ 位置元素为 $\\alpha$ 的矩阵。由于 $K$ 和 $M$ 是实对称的，所以 $A$ 是对称的 ($A=A^T$)。它的共轭转置是 $A^H = K - \\bar{k}^2 M + \\bar{B}_\\alpha$。对于测试用例 2，$k$ 是实数，$\\alpha=2i$ 是纯虚数。因此 $A-A^H = B_\\alpha - \\bar{B}_\\alpha$，这是一个在 $(N,N)$ 位置元素为 $\\alpha - \\bar{\\alpha} = 4i$，其他位置为零的矩阵。弗罗贝尼乌斯范数 $||A-A^T||_F$ 应为零（在机器精度范围内），并且 $||A-A^H||_F = \\sqrt{|4i|^2} = 4$，它大于 $10^{-8}$。\n- **残差范数**：$||A_{\\text{mod}} \\mathbf{u} - \\mathbf{b}_{\\text{mod}}||_2$。这衡量了线性求解器的精度。对于直接求解器，这个值应该接近机器精度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to define, run, and report results for all test cases.\n    \"\"\"\n    # Define manufactured solutions and their derivatives for each test case.\n    # Test Case 1\n    p_exact_1 = lambda x: np.sin(2 * x) + 0.3 * x\n    dp_exact_1 = lambda x: 2 * np.cos(2 * x) + 0.3\n    d2p_exact_1 = lambda x: -4 * np.sin(2 * x)\n\n    # Test Case 2\n    p_exact_2 = lambda x: np.sin(1.5 * x) + 0.1 * x**2\n    dp_exact_2 = lambda x: 1.5 * np.cos(1.5 * x) + 0.2 * x\n    d2p_exact_2 = lambda x: -1.5**2 * np.sin(1.5 * x) + 0.2\n\n    # Test Case 3\n    p_exact_3 = lambda x: x * (1 - x) + 0.05 * np.sin(3 * x)\n    dp_exact_3 = lambda x: 1 - 2 * x + 0.15 * np.cos(3 * x)\n    d2p_exact_3 = lambda x: -2 - 0.45 * np.sin(3 * x)\n\n    test_cases = [\n        {\n            \"id\": 1,\n            \"L\": 1.0, \"N\": 16, \"k\": 4.0, \"alpha\": 1.3,\n            \"p_exact\": p_exact_1, \"dp_exact\": dp_exact_1, \"d2p_exact\": d2p_exact_1\n        },\n        {\n            \"id\": 2,\n            \"L\": 1.0, \"N\": 20, \"k\": 8.0, \"alpha\": 2j,\n            \"p_exact\": p_exact_2, \"dp_exact\": dp_exact_2, \"d2p_exact\": d2p_exact_2\n        },\n        {\n            \"id\": 3,\n            \"L\": 1.0, \"N\": 2, \"k\": 1.0, \"alpha\": 0.0,\n            \"p_exact\": p_exact_3, \"dp_exact\": dp_exact_3, \"d2p_exact\": d2p_exact_3\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_fem_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The default string representation of a boolean is 'True' or 'False'.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_fem_case(case_params):\n    \"\"\"\n    Solves the 1D Helmholtz problem for a single test case.\n    \"\"\"\n    L = case_params[\"L\"]\n    N = case_params[\"N\"]\n    k = case_params[\"k\"]\n    alpha = case_params[\"alpha\"]\n    p_exact = case_params[\"p_exact\"]\n    dp_exact = case_params[\"dp_exact\"]\n    d2p_exact = case_params[\"d2p_exact\"]\n    case_id = case_params[\"id\"]\n\n    h = L / N\n    nodes = np.linspace(0, L, N + 1)\n    \n    # Define source and boundary data from manufactured solution\n    s = lambda x: d2p_exact(x) + k**2 * p_exact(x)\n    p_D = p_exact(0)\n    g = dp_exact(L) + alpha * p_exact(L)\n\n    # Determine data type for matrices (complex if k or alpha are complex)\n    dtype = np.complex128 if isinstance(k, complex) or isinstance(alpha, complex) else np.float64\n\n    # Assembly of global matrix A and vector b\n    A = np.zeros((N + 1, N + 1), dtype=dtype)\n    b = np.zeros(N + 1, dtype=dtype)\n\n    # Element matrices\n    K_e = (1/h) * np.array([[1, -1], [-1, 1]])\n    M_e = (h/6) * np.array([[2, 1], [1, 2]])\n    A_e = K_e - k**2 * M_e\n\n    # 2-point Gaussian quadrature for source term\n    gauss_pts_f = np.array([0.5 - 0.5/np.sqrt(3), 0.5 + 0.5/np.sqrt(3)])\n    gauss_wts_f = np.array([0.5, 0.5])\n    \n    for i in range(N):\n        # Global indices for the two nodes of element i\n        idx = np.array([i, i+1])\n        \n        # Assemble element matrix into global matrix\n        A[np.ix_(idx, idx)] += A_e\n\n        # Assemble element force vector using Gaussian quadrature\n        f_e = np.zeros(2, dtype=dtype)\n        for q_pt, q_wt in zip(gauss_pts_f, gauss_wts_f):\n            x_q = nodes[i] + h * q_pt\n            # Linear basis functions on reference element [0,1]\n            N_vals = np.array([1 - q_pt, q_pt])\n            f_e += q_wt * s(x_q) * N_vals\n        b[idx] += h * f_e\n\n    # Apply Robin boundary condition\n    A[N, N] += alpha\n    b[N] += g\n\n    # --- Test Case 2: Check matrix properties before Dirichlet BCs ---\n    if case_id == 2:\n        A_unmodified = A.copy()\n        norm_sym = np.linalg.norm(A_unmodified - A_unmodified.T, 'fro')\n        norm_her = np.linalg.norm(A_unmodified - A_unmodified.conj().T, 'fro')\n        return (norm_sym  1e-12) and (norm_her > 1e-8)\n        \n    # Apply Dirichlet BC (elimination method)\n    # Modify RHS first, before zeroing out the column\n    if N > 0: # Avoid this for a single element case if p_D is the only unknown\n        b[1:] -= A[1:, 0] * p_D\n    \n    # Modify matrix\n    A[0, :] = 0\n    A[:, 0] = 0\n    A[0, 0] = 1\n    b[0] = p_D\n\n    # Solve linear system\n    u = np.linalg.solve(A, b)\n\n    # --- Test Case 1: Compute L2 error norm ---\n    if case_id == 1:\n        # L2 error calculation using 4-point Gaussian quadrature for accuracy\n        gauss_pts_e, gauss_wts_e = np.polynomial.legendre.leggauss(4)\n        # Map points and weights from [-1, 1] to [0, 1]\n        gauss_pts_e = 0.5 * (gauss_pts_e + 1)\n        gauss_wts_e = 0.5 * gauss_wts_e\n        \n        l2_error_sq = 0.0\n        for i in range(N):\n            elem_error_sq = 0.0\n            for q_pt, q_wt in zip(gauss_pts_e, gauss_wts_e):\n                x_q = nodes[i] + h * q_pt\n                p_h_val = u[i] * (1 - q_pt) + u[i+1] * q_pt\n                error_val = p_h_val - p_exact(x_q)\n                elem_error_sq += q_wt * np.abs(error_val)**2\n            l2_error_sq += h * elem_error_sq\n        return np.sqrt(l2_error_sq)\n\n    # --- Test Case 3: Compute residual norm ---\n    if case_id == 3:\n        residual = A @ u - b\n        return np.linalg.norm(residual, 2)\n\n    return None # Should not be reached\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "在您掌握了组装和验证的技能之后，这最后一个练习将探讨一个更高级的场景：各向异性扩散。您将看到有限元框架如何通过将扩散张量 $D$ 整合到单元刚度计算中，来优雅地处理与方向相关的材料属性。更重要的是，本练习通过将组装后的矩阵作为图进行分析，揭示了物理上的各向异性如何塑造离散算子的连通性和谱特性，从而在矩阵组装和线性代数之间架起了一座桥梁。",
            "id": "3364897",
            "problem": "考虑二维空间中的各向异性扩散问题：在单位正方形域 $\\Omega = (0,1)^2$ 上，求解满足偏微分方程 $-\\nabla \\cdot (D(x) \\nabla u) = f$ 和齐次狄利克雷边界条件 $u|_{\\partial \\Omega} = 0$ 的 $u \\in H_0^1(\\Omega)$。假设 $f(x) = 1$。各向异性张量 $D(x)$ 是对称正定的，并且在本练习中，它是逐单元分片常数，并参数化为 $D = R(\\theta) \\operatorname{diag}(\\lambda_1,\\lambda_2) R(\\theta)^\\top$，其中 $\\lambda_1 = r$，$\\lambda_2 = 1$，$R(\\theta)$ 是旋转矩阵 $R(\\theta) = \\begin{pmatrix} \\cos\\theta  -\\sin\\theta \\\\ \\sin\\theta  \\cos\\theta \\end{pmatrix}$。角度 $\\theta$ 以弧度为单位。\n\n从弱形式和基于 $\\Omega$ 三角剖分的连续分片线性函数构成的标准连续伽辽金有限元法 (CG-FEM) 基底出发，通过雅可比矩阵将梯度从参考单元映射，推导出单个三角形的单元刚度矩阵和单元载荷向量。明确地说明通过作用于梯度的张量 $D$ 和参考单元到物理单元的变换来解释旋转映射。通过对所有单元的贡献求和，组装全局刚度矩阵 $A$ 和全局载荷向量 $b$。为进行分析，考虑与内部（自由）自由度相关的 $A$ 的子矩阵，不施加边界条件修正。\n\n根据全局矩阵 $A$ 定义加权邻接矩阵 $W$，$w_{ij} = \\max(0, -a_{ij})$（当 $i \\neq j$ 时），且 $w_{ii} = 0$，即非对角线上的扩散耦合被视为正的边权重。对于阈值参数 $\\alpha \\in [0,1)$，通过将低于 $\\tau = \\alpha \\cdot \\max_{i \\neq j} w_{ij}$ 的所有边权重置为零，来创建一个阈值化的邻接矩阵 $W_\\alpha$。\n\n您的任务是编写一个Python程序，该程序使用$Nx \\times Ny$的正方形网格，每个正方形被对角线分割成两个三角形，从而对该问题进行离散化。对于以下每个测试用例，计算并报告一个包含三个值的列表：(1) $W_\\alpha$的加权带宽$B_w = \\max_{i,j: w_{ij}  0} |i-j|$，(2) 平均加权度$d_w^{bar} = (\\sum_{i,j} w_{ij})/N$，以及(3) $W_\\alpha$的图拉普拉斯矩阵的第二个最小特征值（Fiedler值）$\\lambda_2$。$N$是内部节点的数量，$i$和$j$是按字典序排列的内部节点的索引。\n\n- **测试用例 1:** $r = 1$, $\\theta = 0$, $\\alpha = 0.2$ (各向同性情况)\n- **测试用例 2:** $r = 100$, $\\theta = 0$, $\\alpha = 0.2$ (沿x轴的强各向异性)\n- **测试用例 3:** $r = 100$, $\\theta = \\pi/4$, $\\alpha = 0.2$ (沿对角线的强各向异性)\n- **测试用例 4:** $r = 10$, $\\theta = \\pi/3$, $\\alpha = 0.3$ (一般各向异性)\n\n使用固定的网格大小 $Nx = 8, Ny = 8$。您的程序应为每个测试用例生成一个包含三个指标的列表，并将这四个列表嵌套在一个外部列表中。输出应为一个字符串，其中包含按此顺序排列的四个内部列表，例如 `[[B_w1,d_w_bar1,lambda_21],[B_w2,d_w_bar2,lambda_22],...]`。",
            "solution": "所提出的问题是有效的。它涉及使用连续伽辽金有限元法（CG-FEM）对标准的各向异性扩散偏微分方程进行数值求解。所有组成部分，包括偏微分方程、域、边界条件、离散化方法以及随后对刚度矩阵的图论分析，都是定义明确、科学合理且内部一致的。\n\n问题是在域 $\\Omega = (0,1)^2$ 上找到 $u \\in H_0^1(\\Omega)$，使得 $-\\nabla \\cdot (D(\\mathbf{x}) \\nabla u) = f$，其中 $f(\\mathbf{x}) = 1$ 且边界为齐次狄利克雷条件。各向异性张量 $D$ 由 $D = R(\\theta) \\operatorname{diag}(r,1) R(\\theta)^\\top$ 给出。\n\n求解过程包括推导有限元公式，构建全局系统矩阵，并对得到的刚度矩阵执行所要求的图分析。\n\n**1. 弱形式**\n\n将偏微分方程乘以一个测试函数 $v \\in H_0^1(\\Omega)$ 并在域 $\\Omega$ 上积分，我们得到：\n$$\n-\\int_{\\Omega} v (\\nabla \\cdot (D \\nabla u)) \\, d\\mathbf{x} = \\int_{\\Omega} v f \\, d\\mathbf{x}\n$$\n对左侧应用分部积分（格林第一恒等式）可得：\n$$\n\\int_{\\Omega} \\nabla v^\\top (D \\nabla u) \\, d\\mathbf{x} - \\int_{\\partial\\Omega} v (D \\nabla u) \\cdot \\mathbf{n} \\, dS = \\int_{\\Omega} v f \\, d\\mathbf{x}\n$$\n由于 $v \\in H_0^1(\\Omega)$，在边界 $\\partial\\Omega$ 上 $v=0$，因此边界积分为零。这给出了弱形式：找到 $u \\in H_0^1(\\Omega)$，使得对于所有 $v \\in H_0^1(\\Omega)$，\n$$\na(u,v) = L(v)\n$$\n其中双线性形式 $a(u,v)$ 和线性泛函 $L(v)$ 定义为：\n$$\na(u,v) = \\int_{\\Omega} \\nabla v^\\top D \\nabla u \\, d\\mathbf{x}\n$$\n$$\nL(v) = \\int_{\\Omega} v f \\, d\\mathbf{x} = \\int_{\\Omega} v \\, d\\mathbf{x}\n$$\n\n**2. 有限元离散化**\n\n我们将域 $\\Omega$ 离散化为一组不重叠的三角形单元 $K$。我们用一个来自有限维空间 $V_h \\subset H_0^1(\\Omega)$ 的函数 $u_h$ 来近似解 $u$，该空间由连续的分片线性函数组成。解 $u_h$ 可以写成基函数 $\\varphi_i(\\mathbf{x})$ 的线性组合：\n$$\nu_h(\\mathbf{x}) = \\sum_{j=1}^{N_{dof}} u_j \\varphi_j(\\mathbf{x})\n$$\n其中 $u_j$ 是未知系数（$u_h$ 的节点值），$\\varphi_j$ 是“帽子”基函数，它在节点 $j$ 处为 1，在所有其他节点处为 0。将其代入弱形式，并选择测试函数 $v_h$ 为基函数 $\\varphi_i$，我们得到一个线性方程组 $A\\mathbf{u} = \\mathbf{b}$，其中 $\\mathbf{u}$ 是未知系数 $u_j$ 的向量，全局刚度矩阵 $A$ 和载荷向量 $\\mathbf{b}$ 的条目为：\n$$\nA_{ij} = a(\\varphi_j, \\varphi_i) = \\int_{\\Omega} \\nabla \\varphi_i^\\top D \\nabla \\varphi_j \\, d\\mathbf{x}\n$$\n$$\nb_i = L(\\varphi_i) = \\int_{\\Omega} \\varphi_i f \\, d\\mathbf{x}\n$$\n这些全局积分是通过对每个单元 $K$ 的贡献求和来计算的。\n\n**3. 单元级计算**\n\n为了计算一个单元 $K$ 的单元刚度矩阵 $A^e$ 和单元载荷向量 $\\mathbf{b}^e$，我们将所有计算映射到一个标准的参考单元 $\\hat{K}$，它是一个顶点为 $\\hat{\\mathbf{x}}_0=(0,0)^\\top$，$\\hat{\\mathbf{x}}_1=(1,0)^\\top$ 和 $\\hat{\\mathbf{x}}_2=(0,1)^\\top$ 的三角形。在 $\\hat{K}$ 上的线性基函数是：\n$$\n\\hat{\\varphi}_0(\\hat{\\mathbf{x}}) = 1 - \\hat{x} - \\hat{y} \\quad, \\quad \\hat{\\varphi}_1(\\hat{\\mathbf{x}}) = \\hat{x} \\quad, \\quad \\hat{\\varphi}_2(\\hat{\\mathbf{x}}) = \\hat{y}\n$$\n它们在参考单元上的梯度是常数向量：\n$$\n\\nabla \\hat{\\varphi}_0 = \\begin{pmatrix} -1 \\\\ -1 \\end{pmatrix} \\quad, \\quad \\nabla \\hat{\\varphi}_1 = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} \\quad, \\quad \\nabla \\hat{\\varphi}_2 = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}\n$$\n一个仿射映射 $F_e: \\hat{K} \\to K$ 将参考坐标 $\\hat{\\mathbf{x}}$ 变换为物理坐标 $\\mathbf{x}$：\n$$\n\\mathbf{x} = F_e(\\hat{\\mathbf{x}}) = J_e \\hat{\\mathbf{x}} + \\mathbf{x}_0\n$$\n其中 $\\mathbf{x}_0, \\mathbf{x}_1, \\mathbf{x}_2$ 是物理单元 $K$ 的顶点，$J_e$ 是该映射的雅可比矩阵，由 $J_e = [\\mathbf{x}_1 - \\mathbf{x}_0 \\;\\; \\mathbf{x}_2 - \\mathbf{x}_0]$ 给出。链式法则关联了物理坐标系和参考坐标系中的梯度：\n$$\n\\nabla \\varphi_i = (J_e^{-1})^\\top \\nabla \\hat{\\varphi}_i = J_e^{-\\top} \\nabla \\hat{\\varphi}_i\n$$\n微分面积元变换为 $d\\mathbf{x} = |\\det(J_e)| d\\hat{\\mathbf{x}}$。\n\n$3 \\times 3$ 单元刚度矩阵 $A^e$ 的条目由下式给出：\n$$\nA^e_{ij} = \\int_K \\nabla \\varphi_i^\\top D \\nabla \\varphi_j \\, d\\mathbf{x}\n$$\n代入变换关系：\n$$\nA^e_{ij} = \\int_{\\hat{K}} (J_e^{-\\top} \\nabla \\hat{\\varphi}_i)^\\top D (J_e^{-\\top} \\nabla \\hat{\\varphi}_j) \\, |\\det(J_e)| d\\hat{\\mathbf{x}}\n$$\n由于 $D$ 在单元上是常数，且梯度是常数向量，我们可以将它们从积分中提出：\n$$\nA^e_{ij} = (\\nabla \\hat{\\varphi}_i)^\\top J_e^{-1} D J_e^{-\\top} \\nabla \\hat{\\varphi}_j \\, |\\det(J_e)| \\int_{\\hat{K}} 1 \\, d\\hat{\\mathbf{x}}\n$$\n参考单元的面积为 $\\int_{\\hat{K}} 1 \\, d\\hat{\\mathbf{x}} = 1/2$。因此，\n$$\nA^e_{ij} = \\frac{1}{2}|\\det(J_e)| (\\nabla \\hat{\\varphi}_i)^\\top (J_e^{-1} D J_e^{-\\top}) \\nabla \\hat{\\varphi}_j\n$$\n这个表达式显示了材料各向异性 $D$ 和由雅可比矩阵 $J_e$ 编码的几何变形之间的相互作用。矩阵 $J_e^{-\\top}$ 将参考梯度 $\\nabla\\hat{\\varphi}$ 映射到物理空间，在那里它们受到物理定义的张量 $D$ 的作用。\n\n单元载荷向量 $\\mathbf{b}^e$ (当 $f=1$ 时) 的条目是：\n$$\nb^e_i = \\int_K f \\varphi_i \\, d\\mathbf{x} = \\int_{\\hat{K}} \\hat{\\varphi}_i(\\hat{\\mathbf{x}}) |\\det(J_e)| d\\hat{\\mathbf{x}} = |\\det(J_e)| \\int_{\\hat{K}} \\hat{\\varphi}_i \\, d\\hat{\\mathbf{x}}\n$$\n对于每个 $i \\in \\{0,1,2\\}$，积分 $\\int_{\\hat{K}} \\hat{\\varphi}_i \\, d\\hat{\\mathbf{x}}$ 的值为 $1/6$。因此，\n$$\nb^e_i = \\frac{|\\det(J_e)|}{6} = \\frac{\\text{Area}(K)}{3}\n$$\n载荷被平均分配到单元的三个节点上。\n\n**4. 全局组装与图分析**\n\n通过遍历所有单元，计算 $A^e$ 和 $\\mathbf{b}^e$，并根据单元到全局节点的索引映射，将其条目加到相应的全局位置，从而形成全局刚度矩阵 $A$ 和载荷向量 $\\mathbf{b}$。\n\n组装后，提取与 $N$ 个内部（自由）自由度对应的子矩阵 $A_{int}$。对于扩散问题，该矩阵是对称正定的，并且对于共享一个单元的节点 $i, j$，其非对角线条目 $A_{int, ij}$ 是非正的。\n\n从 $A_{int}$ 形成一个加权邻接矩阵 $W$：\n$$\nw_{ij} = \\max(0, -A_{int,ij}) \\text{ for } i \\neq j, \\text{ and } w_{ii} = 0.\n$$\n这个矩阵表示节点之间扩散耦合的强度。然后通过将所有小于阈值 $\\tau = \\alpha \\cdot \\max_{k \\neq l} w_{kl}$ 的边权重置为零，来创建一个阈值化的邻接矩阵 $W_\\alpha$。对这个稀疏图 $W_\\alpha$ 计算所要求的指标。\n\n**5. 指标计算**\n\n- **加权带宽 $B_w$**: $B_w = \\max_{i,j: w_{ij}  0} |i-j|$。它衡量节点索引相差很大的节点之间强连接的最大范围。\n- **平均加权度 $d_w^{\\text{bar}}$**: $d_w^{\\text{bar}} = \\frac{1}{N} \\sum_{i,j} w_{ij}$。它表示图中每个节点的平均总连接强度。\n- **Fiedler 值 $\\lambda_2$**: 它是图拉普拉斯矩阵 $L = \\text{Diag}(\\text{degrees}) - W_\\alpha$ 的第二个最小特征值。它衡量图的代数连通性。$\\lambda_2$ 较小表示图更容易被分割成两个独立的子图。\n\n这些指标的组合提供了对各向异性如何影响离散系统的结构和连通性的洞察。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It implements FEM assembly for an anisotropic diffusion problem and\n    performs graph analysis on the resulting stiffness matrix.\n    \"\"\"\n\n    test_cases = [\n        {'r': 1, 'theta': 0, 'alpha': 0.2},\n        {'r': 100, 'theta': 0, 'alpha': 0.2},\n        {'r': 100, 'theta': np.pi / 4, 'alpha': 0.2},\n        {'r': 10, 'theta': np.pi / 3, 'alpha': 0.3},\n    ]\n    Nx = 8\n    Ny = 8\n\n    results = []\n    for case in test_cases:\n        r, theta, alpha = case['r'], case['theta'], case['alpha']\n        result_metrics = compute_metrics(Nx, Ny, r, theta, alpha)\n        results.append(result_metrics)\n    \n    # Format the final output string carefully to avoid extra spaces\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef compute_metrics(Nx, Ny, r, theta, alpha):\n    \"\"\"\n    Computes the required metrics for a single parameter set.\n    \"\"\"\n    # 1. Mesh Generation\n    num_nodes_x = Nx + 1\n    num_nodes_y = Ny + 1\n    total_nodes = num_nodes_x * num_nodes_y\n    h_x = 1.0 / Nx\n    h_y = 1.0 / Ny\n\n    # Node coordinates, indexed lexicographically with x-index fastest\n    nodes = np.array([[i * h_x, j * h_y] for j in range(num_nodes_y) for i in range(num_nodes_x)])\n\n    # Element connectivity\n    elements = []\n    for j in range(Ny):\n        for i in range(Nx):\n            p00 = j * num_nodes_x + i\n            p10 = j * num_nodes_x + i + 1\n            p01 = (j + 1) * num_nodes_x + i\n            p11 = (j + 1) * num_nodes_x + i + 1\n            # Triangle 1 from splitting the rectangle\n            elements.append([p00, p10, p11])\n            # Triangle 2 from splitting the rectangle\n            elements.append([p00, p11, p01])\n\n    # 2. Anisotropy Tensor D\n    c, s = np.cos(theta), np.sin(theta)\n    R = np.array([[c, -s], [s, c]])\n    D_diag = np.diag([r, 1.0])\n    D = R @ D_diag @ R.T\n\n    # 3. Global Matrix Assembly\n    A = np.zeros((total_nodes, total_nodes))\n    \n    # Gradients of basis functions on the reference element, stored as columns in a 2x3 matrix.\n    grad_ref_basis = np.array([[-1.0, 1.0, 0.0], [-1.0, 0.0, 1.0]])\n\n    for element_nodes in elements:\n        v0, v1, v2 = nodes[element_nodes]\n        \n        # Jacobian of the affine map from reference to physical element\n        J = np.array([v1 - v0, v2 - v0]).T\n        detJ = np.linalg.det(J)\n        area_K = 0.5 * abs(detJ)\n        J_inv = np.linalg.inv(J)\n\n        # Transformation matrix for gradients\n        # grad_phys = J_inv.T @ grad_ref\n        J_inv_T = J_inv.T\n        \n        # Physical gradients of basis functions (as columns in a 2x3 matrix)\n        grad_phys_basis = J_inv_T @ grad_ref_basis\n\n        # Element stiffness matrix A^e = Area(K) * (grad_phys)^T * D * (grad_phys)\n        A_e = area_K * (grad_phys_basis.T @ D @ grad_phys_basis)\n        \n        # Assemble A^e into global matrix A\n        for i_local in range(3):\n            i_global = element_nodes[i_local]\n            for j_local in range(3):\n                j_global = element_nodes[j_local]\n                A[i_global, j_global] += A_e[i_local, j_local]\n\n    # 4. Extract Interior Submatrix\n    interior_nodes_indices = [j * num_nodes_x + i for j in range(1, Ny) for i in range(1, Nx)]\n    A_int = A[np.ix_(interior_nodes_indices, interior_nodes_indices)]\n    \n    # 5. Graph Analysis\n    N = len(interior_nodes_indices)\n    \n    # Adjacency matrix W from interior stiffness matrix A_int\n    W = -A_int\n    np.fill_diagonal(W, 0)\n    W[W  0] = 0\n    \n    # Thresholded adjacency matrix W_alpha\n    if np.any(W > 0):\n        tau = alpha * np.max(W)\n    else:\n        tau = 0.0\n    \n    W_alpha = W.copy()\n    W_alpha[W_alpha  tau] = 0\n\n    # Metric 1: Weighted Bandwidth B_w\n    rows, cols = np.where(W_alpha > 0)\n    B_w = np.max(np.abs(rows - cols)) if rows.size > 0 else 0\n\n    # Metric 2: Average Weighted Degree d_w_bar\n    d_w_bar = np.sum(W_alpha) / N if N > 0 else 0.0\n\n    # Metric 3: Fiedler Value lambda_2\n    if N  2:\n        lambda_2 = 0.0\n    else:\n        # Graph Laplacian L = Diag(degrees) - W_alpha\n        S = np.sum(W_alpha, axis=1)\n        L = np.diag(S) - W_alpha\n        # Eigenvalues of L (L is symmetric, use eigh for efficiency)\n        eigvals = eigh(L, eigvals_only=True)\n        lambda_2 = eigvals[1]\n\n    return [float(B_w), d_w_bar, lambda_2]\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}