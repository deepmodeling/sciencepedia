{
    "hands_on_practices": [
        {
            "introduction": "在深入研究复杂的有限元方法（FEM）实现之前，掌握控制声学模拟的基本物理和数值参数至关重要。本练习将重点计算关键的无量纲量，例如网格分辨率参数 $kh$ 和阻抗比 $Z_b/Z$。理解这些数值是设计有效且高效数值模型的第一步，因为它们直接影响网格密度的要求以及边界条件的正确表示。",
            "id": "4141647",
            "problem": "一个无粘、均匀、各向同性的流体域在小振幅假设下，使用有限元法（FEM）进行时谐声学建模。一个频率为 $f$ 的单色平面波在 $20^\\circ\\text{C}$ 的空气中传播，流体质量密度为 $\\rho$，声速为 $c$。计算网格使用特征尺寸为 $h$ 的线性单元。外部边界通过阻抗边界条件建模，该条件代表一个具有实数、与频率无关的特定声阻抗 $Z_b$ 的局部反应衬垫。分析重点关注无量纲量 $kh$（声波数 $k$ 与单元尺寸 $h$ 的乘积）和阻抗比 $Z_b/Z$，其中 $Z$ 是流体的平面波声阻抗。\n\n给定以下物理上一致的参数：$f=850\\,\\text{Hz}$，$\\rho=1.20\\,\\text{kg}\\,\\text{m}^{-3}$，$c=343\\,\\text{m}\\,\\text{s}^{-1}$，$h=0.030\\,\\text{m}$ 和 $Z_b=330\\,\\text{Pa}\\,\\text{s}\\,\\text{m}^{-1}$，利用基本的平面波声学原理来：\n- 确定波数 $k$ 和无量纲离散化参数 $kh$。\n- 确定流体平面波阻抗 $Z$ 和阻抗比 $Z_b/Z$。\n- 最后，在平面波垂直入射到阻抗边界的条件下，基于这些量计算垂直入射反射系数的幅值。\n\n将最终的反射系数幅值表示为一个纯数，并将您的答案四舍五入到四位有效数字。最终数值答案中不包含单位。",
            "solution": "首先对问题陈述进行验证。\n\n### 第一步：提取给定条件\n- 频率：$f=850\\,\\text{Hz}$\n- 流体质量密度：$\\rho=1.20\\,\\text{kg}\\,\\text{m}^{-3}$\n- 声速：$c=343\\,\\text{m}\\,\\text{s}^{-1}$\n- 特征单元尺寸：$h=0.030\\,\\text{m}$\n- 边界的特定声阻抗：$Z_b=330\\,\\text{Pa}\\,\\text{s}\\,\\text{m}^{-1}$\n- 问题涉及单色平面波垂直入射到阻抗边界。\n- 最终要求解的量是垂直入射反射系数的幅值，四舍五入到四位有效数字。\n\n### 第二步：使用提取的给定条件进行验证\n该问题具有科学依据，是适定的且客观的。\n- **科学与事实合理性：** 该问题基于线性声学的基本原理。提供的 $20^\\circ\\text{C}$ 空气属性值（密度 $\\rho$ 和声速 $c$）是标准的教科书值。波数、声阻抗和反射系数的概念是波动物理学的核心。单位是一致的：特征阻抗 $Z = \\rho c$ 的单位是 $(\\text{kg}\\,\\text{m}^{-3}) \\times (\\text{m}\\,\\text{s}^{-1}) = \\text{kg}\\,\\text{m}^{-2}\\,\\text{s}^{-1}$。压力单位帕斯卡为 $\\text{Pa} = \\text{N}\\,\\text{m}^{-2} = (\\text{kg}\\,\\text{m}\\,\\text{s}^{-2})\\,\\text{m}^{-2} = \\text{kg}\\,\\text{m}^{-1}\\,\\text{s}^{-2}$。因此，特定声阻抗的单位 $\\text{Pa}\\,\\text{s}\\,\\text{m}^{-1}$ 是 $(\\text{kg}\\,\\text{m}^{-1}\\,\\text{s}^{-2}) \\times \\text{s} \\times \\text{m}^{-1} = \\text{kg}\\,\\text{m}^{-2}\\,\\text{s}^{-1}$，这与 $Z$ 的量纲一致。\n- **适定性与完整性：** 问题提供了计算所求量所需的所有数据。所需的公式是标准的，并能得出唯一解。与有限元法（FEM）和参数 $kh$ 相关的背景为计算提供了一个现实的场景，但并未引入模糊性。\n- **客观性：** 问题陈述使用精确的技术语言表达，没有主观或含糊的术语。\n\n### 第三步：结论与行动\n该问题是有效的。将提供解答。\n\n解答按要求分三部分进行。\n\n**第一部分：波数 $k$ 和无量纲参数 $kh$**\n\n声波数 $k$ 与角频率 $\\omega$ 和声速 $c$ 相关。角频率为 $\\omega = 2\\pi f$。因此，波数由下式给出：\n$$\nk = \\frac{\\omega}{c} = \\frac{2\\pi f}{c}\n$$\n代入给定值 $f=850\\,\\text{Hz}$ 和 $c=343\\,\\text{m}\\,\\text{s}^{-1}$：\n$$\nk = \\frac{2\\pi(850)}{343} \\approx 15.587\\,\\text{rad}\\,\\text{m}^{-1}\n$$\n无量纲离散化参数 $kh$ 是波数 $k$ 与特征单元尺寸 $h=0.030\\,\\text{m}$ 的乘积：\n$$\nkh = \\left(\\frac{2\\pi f}{c}\\right) h = \\frac{2\\pi(850)(0.030)}{343} \\approx 0.4676\n$$\n该值表明，对于给定频率下的线性单元公式，网格分辨率是足够的，因为它遵守了每个波长至少需要 $10$ 个单元的通用经验法则。\n\n**第二部分：流体阻抗 $Z$ 和阻抗比 $Z_b/Z$**\n\n对于平面波，流体介质的特征特定声阻抗 $Z$ 是其密度 $\\rho$ 和声速 $c$ 的乘积：\n$$\nZ = \\rho c\n$$\n代入给定值 $\\rho=1.20\\,\\text{kg}\\,\\text{m}^{-3}$ 和 $c=343\\,\\text{m}\\,\\text{s}^{-1}$：\n$$\nZ = (1.20)\\,(343) = 411.6\\,\\text{Pa}\\,\\text{s}\\,\\text{m}^{-1}\n$$\n阻抗比是边界的特定声阻抗 $Z_b$ 与流体特征阻抗 $Z$ 的比值。给定值为 $Z_b=330\\,\\text{Pa}\\,\\text{s}\\,\\text{m}^{-1}$。\n$$\n\\frac{Z_b}{Z} = \\frac{330}{411.6} \\approx 0.80175\n$$\n\n**第三部分：垂直入射反射系数幅值 $|R|$**\n\n对于垂直入射到具有法向特定声阻抗 $Z_b$ 的表面上的平面波，其声压反射系数 $R$ 由下式给出：\n$$\nR = \\frac{Z_b - Z}{Z_b + Z}\n$$\n这可以用阻抗比 $\\frac{Z_b}{Z}$ 来表示：\n$$\nR = \\frac{\\frac{Z_b}{Z} - 1}{\\frac{Z_b}{Z} + 1}\n$$\n代入 $Z_b$ 和 $Z$ 的值：\n$$\nR = \\frac{330 - 411.6}{330 + 411.6} = \\frac{-81.6}{741.6} \\approx -0.110032\n$$\n题目要求解反射系数的幅值 $|R|$：\n$$\n|R| = \\left| \\frac{-81.6}{741.6} \\right| = \\frac{81.6}{741.6} \\approx 0.110032\n$$\n将此结果四舍五入到四位有效数字，得到 $0.1100$。",
            "answer": "$$\n\\boxed{0.1100}\n$$"
        },
        {
            "introduction": "可靠计算建模的基石是验证所实现的代码是否符合理论预测。本实践将指导您构建一个一维有限元求解器，用以解决声学中的基本模型——亥姆霍兹方程。通过使用“制造解”方法，您将计算数值误差并进行收敛率分析，以确保您的实现在 $L^2$ 范数和 $H^1$ 半范数下均能达到预期的精度阶数。",
            "id": "4141617",
            "problem": "考虑域 $\\Omega = (0,1)$ 上的一维时谐声腔，其边界条件为齐次狄利克雷边界条件 $p(0) = 0$ 和 $p(1) = 0$。在线性、无粘性声学的假设下，频域中的声压场 $p(x)$ 满足亥姆霍兹方程\n$$\n- \\frac{d^2 p}{dx^2} - k^2 p = f(x) \\quad \\text{in } \\Omega,\n$$\n其中 $k$ 是波数，$f(x)$ 是给定的源项。其弱形式为：求 $p \\in H_0^1(0,1)$，使得\n$$\n\\int_0^1 \\frac{dp}{dx} \\frac{dv}{dx} \\, dx - k^2 \\int_0^1 p v \\, dx = \\int_0^1 f v \\, dx \\quad \\text{for all } v \\in H_0^1(0,1).\n$$\n成立。使用有限元法 (FEM) 对此弱问题进行离散化，在由 $N$ 个尺寸为 $h=1/N$ 的单元组成的均匀网格上，采用连续分段线性基函数。组装离散系统矩阵 $A = K - k^2 M$，其中 $K$ 是标准刚度矩阵，其元素为 $K_{ij} = \\int_0^1 \\frac{d\\phi_i}{dx}\\frac{d\\phi_j}{dx}\\,dx$；$M$ 是标准质量矩阵，其元素为 $M_{ij} = \\int_0^1 \\phi_i \\phi_j \\, dx$。通过将系统限制在内部自由度来施加齐次狄利克雷边界条件。\n\n为了获得一个已知的精确解，考虑 $p_{\\text{exact}}(x) = \\sin(\\pi x)$。选择源项为 $f(x) = (\\pi^2 - k^2)\\sin(\\pi x)$，这样对于任意波数 $k$，$p_{\\text{exact}}$ 都满足微分方程和边界条件。\n\n将误差的 $L^2$-范数和 $H^1$-半范数分别定义为\n$$\n\\| p - p_h \\|_{L^2(0,1)} = \\left( \\int_0^1 \\left( p_{\\text{exact}}(x) - p_h(x) \\right)^2 \\, dx \\right)^{1/2}, \\quad\n| p - p_h |_{H^1(0,1)} = \\left( \\int_0^1 \\left( \\frac{d p_{\\text{exact}}}{dx}(x) - \\frac{d p_h}{dx}(x) \\right)^2 \\, dx \\right)^{1/2}.\n$$\n此处，$p_h$ 表示有限元解，$\\frac{d p_h}{dx}$ 表示其在每个单元上的分段常数导数。对于分段线性元，理论预测是，对于足够光滑的 $p_{\\text{exact}}$，$L^2$-误差的收敛阶为 $h^2$，$H^1$-半范数误差的收敛阶为 $h$。\n\n计算多种网格分辨率下的误差，通过对 $\\log(\\text{error})$ 与 $\\log(h)$ 进行最小二乘拟合来估计观测到的收敛率，并评估观测到的收敛率是否与理论预测相符。匹配定义如下：$L^2$ 收敛率必须至少为 $1.8$，$H^1$ 收敛率必须至少为 $0.9$。\n\n实现一个完整的、可运行的程序，对以下参数值的测试套件执行上述步骤，其中每个测试用例包含一个波数 $k$ 和一个网格分辨率列表 $N$：\n- 测试用例 1：$k = \\frac{\\pi}{2}$，$N \\in [20,40,80,160]$。\n- 测试用例 2：$k = 2.7 \\pi$，$N \\in [60,120,240,480]$。\n- 测试用例 3：$k = 3.1 \\pi$，$N \\in [30,60,120,240]$。\n- 测试用例 4 (边缘情况)：$k = 4.5 \\pi$，$N \\in [8,16,32,64]$。\n\n您的程序应：\n- 组装有限元系统 $A p_h = b$，其中 $b$ 是通过使用足够精确的数值积分计算 $f(x)$ 与基函数的乘积积分得到的载荷向量。\n- 对每个 $N$ 求解 $p_h$。\n- 使用精确的数值积分计算 $\\| p - p_h \\|_{L^2(0,1)}$ 和 $| p - p_h |_{H^1(0,1)}$。\n- 使用对 $(\\log(h), \\log(\\text{error}))$ 数据对的最小二乘回归，估计所提供的 $N$ 值对应的收敛率。\n- 对每个测试用例，返回一个布尔值，表示 $L^2$ 和 $H^1$ 收敛率是否都达到了上述阈值。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表，例如 $[{\\text{result}_1},{\\text{result}_2},{\\text{result}_3},{\\text{result}_4}]$，其中每个 ${\\text{result}_i}$ 是对应于测试用例 $i$ 的布尔值。",
            "solution": "该问题要求实现一维有限元法 (FEM) 来求解亥姆霍兹方程，并进行后续的收敛性研究以验证理论误差估计。该问题是适定的且科学上合理的，为数值方法的验证提供了一条清晰的路径。\n\n控制方程是一维亥姆霍兹方程，作用于域 $\\Omega = (0,1)$：\n$$\n- \\frac{d^2 p}{dx^2} - k^2 p = f(x)\n$$\n边界条件为齐次狄利克雷边界条件 $p(0)=0$ 和 $p(1)=0$。波数用 $k$ 表示，$f(x)$ 是给定的源项。\n\n有限元法的第一步是推导弱形式。我们将方程乘以一个测试函数 $v \\in H_0^1(0,1)$（这是一个在边界处为零且一阶导数平方可积的函数空间），并在域 $\\Omega$ 上积分：\n$$\n- \\int_0^1 \\frac{d^2 p}{dx^2} v \\, dx - k^2 \\int_0^1 p v \\, dx = \\int_0^1 f v \\, dx\n$$\n对第一项应用分部积分，并利用 $v(0)=v(1)=0$ 这一事实，我们得到弱形式：求 $p \\in H_0^1(0,1)$，使得\n$$\n\\int_0^1 \\frac{dp}{dx} \\frac{dv}{dx} \\, dx - k^2 \\int_0^1 p v \\, dx = \\int_0^1 f v \\, dx \\quad \\forall v \\in H_0^1(0,1).\n$$\n这可以写成抽象形式 $a(p,v) = L(v)$，其中 $a(\\cdot, \\cdot)$ 是一个双线性形式，$L(\\cdot)$ 是一个线性泛函。\n\n接下来，我们将域 $\\Omega$ 离散化为一个由 $N$ 个单元组成的均匀网格，每个单元的长度为 $h = 1/N$。节点位于 $x_i = i h$，其中 $i=0, 1, \\ldots, N$。我们在一个有限维子空间中寻求近似解 $p_h(x)$。对于此问题，我们使用连续的分段线性基函数，通常称为“帽”函数。有限元解表示为这些基函数的线性组合：\n$$\np_h(x) = \\sum_{j=1}^{N-1} p_j \\phi_j(x)\n$$\n其中 $\\phi_j(x)$ 是在节点 $x_j$ 处为 1、在所有其他节点处为 0 的帽函数，并在节点之间进行线性插值。求和是对 $N-1$ 个内部节点进行的，因为边界条件 $p_h(0) = p_h(1) = 0$ 是通过排除基函数 $\\phi_0$ 和 $\\phi_N$ 来施加的。系数 $p_j$ 是声压场的未知节点值。\n\n将 $p_h$ 代入弱形式，并选择测试函数 $v$ 为基函数 $\\phi_i$ 本身（伽辽金法），我们得到一个线性方程组：\n$$\n\\sum_{j=1}^{N-1} p_j \\left( \\int_0^1 \\frac{d\\phi_j}{dx}\\frac{d\\phi_i}{dx}\\,dx - k^2 \\int_0^1 \\phi_j \\phi_i \\,dx \\right) = \\int_0^1 f \\phi_i \\,dx \\quad \\text{for } i=1, \\ldots, N-1.\n$$\n这就是代数系统 $A \\mathbf{p} = \\mathbf{b}$，其中 $\\mathbf{p} = [p_1, \\ldots, p_{N-1}]^T$ 是未知节点值的向量。系统矩阵 $A$ 和载荷向量 $\\mathbf{b}$ 的元素为：\n$$\nA_{ij} = K_{ij} - k^2 M_{ij}, \\quad b_i = \\int_0^1 f(x) \\phi_i(x) \\, dx\n$$\n其中 $K_{ij} = \\int_0^1 \\frac{d\\phi_i}{dx}\\frac{d\\phi_j}{dx}\\,dx$ 是刚度矩阵 $K$ 的元素，$M_{ij} = \\int_0^1 \\phi_i \\phi_j \\,dx$ 是质量矩阵 $M$ 的元素。\n\n对于具有线性帽函数的均匀网格，长度为 $h$ 的单元的单元刚度矩阵和质量矩阵为：\n$$\nK^e = \\frac{1}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}, \\quad M^e = \\frac{h}{6} \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix}\n$$\n为 $N-1$ 个内部自由度组装这些矩阵，会得到对称三对角的全局矩阵 $K$ 和 $M$。对于 $i,j \\in \\{1,...,N-1\\}$：\n- $K_{i,i} = 2/h$, $K_{i, i\\pm 1} = -1/h$\n- $M_{i,i} = 2h/3$, $M_{i, i\\pm 1} = h/6$\n\n该问题使用精确解构造法，通过将源项定义为 $f(x) = (\\pi^2 - k^2)\\sin(\\pi x)$，来提供一个已知的精确解 $p_{\\text{exact}}(x) = \\sin(\\pi x)$。载荷向量 $\\mathbf{b}$ 和误差范数的积分涉及超越函数，必须使用数值积分（例如高斯-勒让德积分）进行计算，并使用足够多的积分点以确保积分误差可以忽略不计。\n\n一旦系统 $A \\mathbf{p} = \\mathbf{b}$ 被组装并求解出 $\\mathbf{p}$，有限元解 $p_h(x)$ 就已知了。然后使用 $L^2$-范数和 $H^1$-半范数计算误差。这些积分也通过对每个单元的贡献求和（使用高斯积分）来进行数值计算。在每个单元 $[x_{e-1}, x_e]$ 上，有限元解的导数是常数：$\\frac{dp_h}{dx} = (p_e - p_{e-1})/h$。\n\n最后一步是分析收敛率。对于一系列的网格细化（$h$ 减小），误差 $E$ 预计与 $E \\approx C h^\\alpha$ 成比例，其中 $\\alpha$ 是收敛率。取对数后得到一个线性关系：$\\log(E) \\approx \\log(C) + \\alpha \\log(h)$。收敛率 $\\alpha$ 可以通过对数据点 $(\\log(h), \\log(E))$ 进行线性最小二乘回归拟合直线的斜率来估计。线性元的理论收敛率是：$L^2$-误差为 $\\alpha=2$，$H^1$-半范数误差为 $\\alpha=1$。考虑到前渐近效应和数值精度，该问题设置了实际阈值 $\\alpha_{L^2} \\ge 1.8$ 和 $\\alpha_{H^1} \\ge 0.9$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef assemble_matrices_sparse(N):\n    \"\"\"\n    Assembles the global sparse stiffness (K) and mass (M) matrices for a 1D uniform\n    mesh with N elements, restricted to N-1 interior degrees of freedom.\n    \"\"\"\n    h = 1.0 / N\n    dof = N - 1\n    \n    # Stiffness matrix K\n    k_diag = np.full(dof, 2.0 / h)\n    k_offdiag = np.full(dof - 1, -1.0 / h)\n    K = sparse.diags([k_offdiag, k_diag, k_offdiag], [-1, 0, 1], shape=(dof, dof), format='csr')\n\n    # Mass matrix M\n    m_diag = np.full(dof, 2.0 * h / 3.0)\n    m_offdiag = np.full(dof - 1, h / 6.0)\n    M = sparse.diags([m_offdiag, m_diag, m_offdiag], [-1, 0, 1], shape=(dof, dof), format='csr')\n\n    return K, M\n\ndef assemble_load_vector(k, N, quad_points, quad_weights):\n    \"\"\"\n    Assembles the load vector b for N elements using Gauss-Legendre quadrature.\n    b_j = integral(f(x) * phi_j(x) dx)\n    \"\"\"\n    h = 1.0 / N\n    dof = N - 1\n    b = np.zeros(dof)\n    nodes = np.linspace(0, 1, N + 1)\n    \n    f = lambda x: (np.pi**2 - k**2) * np.sin(np.pi * x)\n    \n    for j in range(1, N):\n        # Integral over element [x_{j-1}, x_j]\n        integral1 = 0.0\n        for i in range(len(quad_points)):\n            xi = quad_points[i]\n            w = quad_weights[i]\n            x_val = (nodes[j-1] + nodes[j]) / 2.0 + h / 2.0 * xi\n            phi_j_val = (x_val - nodes[j-1]) / h\n            integral1 += f(x_val) * phi_j_val * w\n        \n        # Integral over element [x_j, x_{j+1}]\n        integral2 = 0.0\n        for i in range(len(quad_points)):\n            xi = quad_points[i]\n            w = quad_weights[i]\n            x_val = (nodes[j] + nodes[j+1]) / 2.0 + h / 2.0 * xi\n            phi_j_val = (nodes[j+1] - x_val) / h\n            integral2 += f(x_val) * phi_j_val * w\n            \n        b[j-1] = integral1 * (h / 2.0) + integral2 * (h / 2.0)\n        \n    return b\n\ndef calculate_errors(p_h_full, k, N, quad_points, quad_weights):\n    \"\"\"\n    Calculates L2 and H1-seminorm errors using Gauss-Legendre quadrature.\n    p_h_full is the vector of nodal solutions including boundary values.\n    \"\"\"\n    h = 1.0 / N\n    nodes = np.linspace(0, 1, N + 1)\n    \n    p_exact = lambda x: np.sin(np.pi * x)\n    dp_exact = lambda x: np.pi * np.cos(np.pi * x)\n\n    l2_error_sq = 0.0\n    h1_error_sq = 0.0\n    \n    for e in range(N):\n        p_node_left = p_h_full[e]\n        p_node_right = p_h_full[e+1]\n        \n        dp_h = (p_node_right - p_node_left) / h\n        \n        elem_l2_sq = 0.0\n        elem_h1_sq = 0.0\n        \n        for i in range(len(quad_points)):\n            xi = quad_points[i]\n            w = quad_weights[i]\n            x_val = (nodes[e] + nodes[e+1]) / 2.0 + h / 2.0 * xi\n            \n            p_h_val = p_node_left * (1.0 - xi) / 2.0 + p_node_right * (1.0 + xi) / 2.0\n            \n            l2_integrand = (p_exact(x_val) - p_h_val)**2\n            elem_l2_sq += l2_integrand * w\n\n            h1_integrand = (dp_exact(x_val) - dp_h)**2\n            elem_h1_sq += h1_integrand * w\n\n        l2_error_sq += elem_l2_sq * (h / 2.0)\n        h1_error_sq += elem_h1_sq * (h / 2.0)\n        \n    return np.sqrt(l2_error_sq), np.sqrt(h1_error_sq)\n\ndef estimate_rate(h_vals, error_vals):\n    \"\"\"\n    Estimates convergence rate by a least-squares fit on log(error) vs log(h).\n    \"\"\"\n    log_h = np.log(h_vals)\n    log_err = np.log(error_vals)\n    rate, _ = np.polyfit(log_h, log_err, 1)\n    return rate\n\ndef run_single_case(k, N_list):\n    \"\"\"\n    Runs the full simulation for a single test case (k, N_list) and checks convergence.\n    \"\"\"\n    h_vals = []\n    l2_errors = []\n    h1_errors = []\n    \n    # Use 5-point Gauss-Legendre quadrature. This is sufficiently accurate.\n    quad_points, quad_weights = np.polynomial.legendre.leggauss(5)\n\n    for N in N_list:\n        h = 1.0 / N\n        h_vals.append(h)\n        \n        K, M = assemble_matrices_sparse(N)\n        A = K - k**2 * M\n        \n        b = assemble_load_vector(k, N, quad_points, quad_weights)\n        \n        p_h_interior = spsolve(A, b)\n        \n        p_h_full = np.concatenate(([0.0], p_h_interior, [0.0]))\n        \n        l2_err, h1_err = calculate_errors(p_h_full, k, N, quad_points, quad_weights)\n        l2_errors.append(l2_err)\n        h1_errors.append(h1_err)\n\n    l2_rate = estimate_rate(h_vals, l2_errors)\n    h1_rate = estimate_rate(h_vals, h1_errors)\n    \n    return l2_rate = 1.8 and h1_rate = 0.9\n\ndef solve():\n    \"\"\"\n    Defines test cases, runs the convergence study for each, and prints results.\n    \"\"\"\n    test_cases = [\n        (np.pi / 2, [20, 40, 80, 160]),\n        (2.7 * np.pi, [60, 120, 240, 480]),\n        (3.1 * np.pi, [30, 60, 120, 240]),\n        (4.5 * np.pi, [8, 16, 32, 64])\n    ]\n\n    results = []\n    for case in test_cases:\n        k, N_list = case\n        result = run_single_case(k, N_list)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了有限元实现的基础知识后，本练习将进入一个具有重要实际意义的二维问题：声腔的模态分析。您将构建并求解广义特征值问题，以找到具有刚性壁面的矩形房间的固有频率和振型。本实践不仅将您的编程技能扩展到二维，还强调了将数值结果与已知解析解进行验证的关键过程，这是建立对仿真工具信心的标准程序。",
            "id": "4141646",
            "problem": "考虑一个二维矩形声腔，其域为 $\\Omega = (0,L_x)\\times(0,L_y)$，壁面为刚性。假设腔内为均匀无损耗流体，其特征为恒定的质量密度 $\\rho$ 和声速 $c$，且扰动很小，因此适用线性声学。从可压缩流体的基本线性化平衡定律和本构关系出发，声压 $p(x,y,t)$ 服从标量波动方程，对于角频率为 $\\omega$ 的时谐场 $p(x,y,t) = \\Re\\{\\phi(x,y)\\,e^{-i\\omega t}\\}$，空间场 $\\phi(x,y)$ 满足 Helmholtz 方程，并在边界 $\\partial\\Omega$ 上满足刚性壁边界条件。刚性壁施加了法向质点速度为零的条件，这对应于声压的齐次 Neumann 边界条件。请在 $\\Omega$ 上建立频域弱问题，并使用协调分片线性（仿射）形函数，通过有限元法 (FEM) 对其进行离散。其中，矩形域的三角剖分通过将结构化网格的每个矩形单元分裂成两个三角形而获得。组装全局对称刚度矩阵和质量矩阵，并求解所得的广义特征值问题，以近似计算腔体的最低非零特征频率。\n\n为进行验证，请推导刚性壁矩形腔的解析模态频率。解析波数由满足 Neumann 边界条件的组合给出，并得出依赖于 $(m,n)\\in\\mathbb{N}_0^2$ 的解析特征频率，其中不包括平凡的等压模式。\n\n您的任务是：\n- 根据指定的基本物理定律和边界条件，推导恰当的弱形式。\n- 实现一个协调线性三角形有限元法，在 $\\Omega$ 的结构化三角剖分上组装全局刚度矩阵和质量矩阵，并求解广义对称特征值问题以获得前 $N$ 个非零特征频率。\n- 计算同一腔体对应的前 $N$ 个解析刚性壁模态频率，并通过报告前 $N$ 个非零模态中的最大相对误差，将 FEM 结果与解析结果进行比较。\n\n请使用以下参数集测试套件，其中每个参数集是一个元组 $(L_x,L_y,c,N_x,N_y,N)$:\n- 测试用例 1: $(L_x,L_y,c,N_x,N_y,N) = (\\,1.2\\,\\text{m},\\,0.8\\,\\text{m},\\,343\\,\\text{m/s},\\,30,\\,20,\\,5\\,)$。\n- 测试用例 2: $(L_x,L_y,c,N_x,N_y,N) = (\\,1.0\\,\\text{m},\\,1.0\\,\\text{m},\\,343\\,\\text{m/s},\\,10,\\,10,\\,5\\,)$。\n- 测试用例 3: $(L_x,L_y,c,N_x,N_y,N) = (\\,2.0\\,\\text{m},\\,0.5\\,\\text{m},\\,343\\,\\text{m/s},\\,40,\\,10,\\,6\\,)$。\n- 测试用例 4: $(L_x,L_y,c,N_x,N_y,N) = (\\,1.0\\,\\text{m},\\,1.0\\,\\text{m},\\,343\\,\\text{m/s},\\,40,\\,40,\\,6\\,)$。\n\n在每个用例中，$L_x$ 和 $L_y$ 是以米为单位的长度，$c$ 是以米每秒为单位的声速，$(N_x,N_y)$ 指定了用于生成结构化网格的沿 $x$ 和 $y$ 方向的剖分数量（这将产生 $(N_x+1)\\times(N_y+1)$ 个节点），$N$ 是要比较的非零模态数量。您必须假设所有边界上均为刚性壁（Neumann）边界条件。\n\n物理单位：\n- 所有特征频率均以赫兹 (Hz) 表示。\n- 使用公式 $|f_{\\text{FEM}}-f_{\\text{analytical}}|/f_{\\text{analytical}}$ 计算相对误差，结果为十进制值（无单位）。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个条目对应一个测试用例，是该用例前 $N$ 个非零模态的最大相对误差，四舍五入到六位小数（例如，$[0.012345,0.001234,0.000567,0.045678]$）。",
            "solution": "所提出的问题是使用有限元法 (FEM) 确定具有刚性壁的二维矩形腔的声学特征频率，并将数值结果与解析解进行验证。该问题具有科学依据、提法恰当，并为完整求解提供了所有必要信息。我们着手进行推导和实现。\n\n该物理系统由声压 $p$ 的标量波动方程控制。对于形如 $p(x,y,t) = \\Re\\{\\phi(x,y)e^{-i\\omega t}\\}$ 的时谐解，域 $\\Omega = (0,L_x)\\times(0,L_y)$ 内的空间压力分布 $\\phi(x,y)$ 满足 Helmholtz 方程：\n$$ \\nabla^2 \\phi + k^2 \\phi = 0 $$\n其中 $k = \\omega/c$ 是波数，$\\omega$ 是角频率，$c$ 是恒定的声速。刚性壁施加了齐次 Neumann 边界条件，因为质点速度的法向分量为零，这转化为压力场的法向梯度为零：\n$$ \\frac{\\partial \\phi}{\\partial n} = \\nabla \\phi \\cdot \\mathbf{n} = 0 \\quad \\text{on } \\partial\\Omega $$\n这构成了关于波数平方 $k^2$ 的一个特征值问题。\n\n为了建立弱问题，我们采用加权余量法。将 Helmholtz 方程乘以一个来自 Sobolev 空间 $H^1(\\Omega)$ 的任意检验函数 $v$，并在域 $\\Omega$ 上积分，得到：\n$$ \\int_{\\Omega} v(\\nabla^2 \\phi + k^2 \\phi) \\, d\\Omega = 0 $$\n对拉普拉斯项应用格林第一恒等式，我们得到：\n$$ \\int_{\\Omega} (-\\nabla v \\cdot \\nabla \\phi + v k^2 \\phi) \\, d\\Omega + \\oint_{\\partial\\Omega} v \\frac{\\partial \\phi}{\\partial n} \\, dS = 0 $$\n由于齐次 Neumann 边界条件，边界积分 $\\oint_{\\partial\\Omega} v \\frac{\\partial \\phi}{\\partial n} \\, dS$ 为零。在此变分框架内，这是一个自然边界条件。由此产生的弱形式是：找到 $\\phi \\in H^1(\\Omega)$ 和 $k^2 \\in \\mathbb{R}$，使得对于所有 $v \\in H^1(\\Omega)$：\n$$ \\int_{\\Omega} \\nabla v \\cdot \\nabla \\phi \\, d\\Omega = k^2 \\int_{\\Omega} v \\phi \\, d\\Omega $$\n\n对于有限元离散，我们将域 $\\Omega$ 剖分成一个由三角形单元组成的网格。解 $\\phi$ 在有限维子空间 $V_h \\subset H^1(\\Omega)$ 中近似为节点基函数（或形函数）$N_j(x,y)$ 的线性组合：\n$$ \\phi_h(x,y) = \\sum_{j=1}^{N_{nodes}} \\phi_j N_j(x,y) $$\n其中 $\\phi_j$ 是未知系数，代表节点 $j$ 处的压力场值，$N_{nodes}$ 是网格中的总节点数。我们使用协调分片线性基函数，其中 $N_j$ 在节点 $j$ 处等于 $1$，在所有其他节点处等于 $0$。将此近似同时代入解 $\\phi$ 和检验函数 $v$（使用 Galerkin 方法，其中检验函数即为基函数本身，$v = N_i$），我们得到一个线性方程组：\n$$ \\sum_{j=1}^{N_{nodes}} \\left( \\int_{\\Omega} \\nabla N_i \\cdot \\nabla N_j \\, d\\Omega \\right) \\phi_j = k^2 \\sum_{j=1}^{N_{nodes}} \\left( \\int_{\\Omega} N_i N_j \\, d\\Omega \\right) \\phi_j \\quad \\text{for } i = 1, \\dots, N_{nodes} $$\n这可以写成广义特征值问题的矩阵形式：\n$$ \\mathbf{K} \\mathbf{\\Phi} = k^2 \\mathbf{M} \\mathbf{\\Phi} $$\n这里，$\\mathbf{\\Phi}$ 是节点未知数的向量，$\\lambda = k^2$ 是特征值，$\\mathbf{K}$ 和 $\\mathbf{M}$ 分别是全局刚度矩阵和质量矩阵。它们的元素由下式给出：\n$$ K_{ij} = \\int_{\\Omega} \\nabla N_i \\cdot \\nabla N_j \\, d\\Omega \\quad \\text{and} \\quad M_{ij} = \\int_{\\Omega} N_i N_j \\, d\\Omega $$\n这些全局矩阵是通过对每个单元的贡献求和来组装的。对于一个面积为 $A_e$、节点为 $(x_1, y_1), (x_2, y_2), (x_3, y_3)$ 的线性三角形单元 $e$，计算其局部的 $3 \\times 3$ 单元刚度矩阵 $\\mathbf{K}^e$ 和质量矩阵 $\\mathbf{M}^e$。线性形函数的梯度在单元上是常数。单元刚度矩阵的第 $(i,j)$ 个元素是 $K_{ij}^e = (\\nabla N_i \\cdot \\nabla N_j) A_e = (b_i b_j + c_i c_j) A_e$，其中梯度系数为 $b_k = (y_{k+1}-y_{k+2})/(2A_e)$ 和 $c_k = (x_{k+2}-x_{k+1})/(2A_e)$（使用循环索引置换）。线性三角形的单元质量矩阵由标准公式给出：\n$$ \\mathbf{M}^e = \\frac{A_e}{12} \\begin{pmatrix} 2  1  1 \\\\ 1  2  1 \\\\ 1  1  2 \\end{pmatrix} $$\n解出的特征值 $\\lambda_i = k_i^2$ 对应于波数的平方。第一个特征值 $\\lambda_0$ 为零（或数值上接近于零），对应于平凡的等压模式 $(k=0)$。我们感兴趣的是非零特征频率，它们由后续的特征值 $\\lambda_i > 0$ 通过关系式 $f_i = \\omega_i/(2\\pi) = c k_i/(2\\pi) = c\\sqrt{\\lambda_i}/(2\\pi)$ 计算得出。\n\n为了验证，我们推导解析解。在矩形 $\\Omega = (0,L_x)\\times(0,L_y)$ 上具有齐次 Neumann 边界条件的 Helmholtz 方程是可分离的。对于非负整数模态指数 $m$ 和 $n$，其特征函数形式为 $\\phi_{mn}(x,y) = \\cos(\\frac{m\\pi x}{L_x})\\cos(\\frac{n\\pi y}{L_y})$。相应的波数 $k_{mn}$ 必须满足：\n$$ k_{mn}^2 = \\left(\\frac{m\\pi}{L_x}\\right)^2 + \\left(\\frac{n\\pi}{L_y}\\right)^2 $$\n因此，以赫兹为单位的解析特征频率为：\n$$ f_{mn} = \\frac{c k_{mn}}{2\\pi} = \\frac{c}{2} \\sqrt{\\left(\\frac{m}{L_x}\\right)^2 + \\left(\\frac{n}{L_y}\\right)^2} $$\n平凡模式对应于 $(m,n)=(0,0)$，这导致 $f_{00}=0$。前 $N$ 个非零模态是通过计算不同 $(m,n)$ 对的 $f_{mn}$ 并将结果按升序排序找到的，同时注意处理不同 $(m,n)$ 对产生相同频率的简并模态。第 $i$ 个 FEM 频率 $f_{i, \\text{FEM}}$ 和第 $i$ 个解析频率 $f_{i, \\text{analytical}}$ 之间的比较使用相对误差进行，并报告前 $N$ 个非零模态中的最大误差。",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import eigsh\n\ndef compute_max_error(Lx, Ly, c, Nx, Ny, N):\n    \"\"\"\n    Computes the maximum relative error for acoustic eigenfrequencies in a 2D cavity.\n\n    This function performs the following steps:\n    1. Generates a structured triangular mesh for the rectangular domain.\n    2. Assembles the global stiffness (K) and mass (M) matrices using linear finite elements.\n    3. Solves the generalized eigenvalue problem K*phi = lambda*M*phi for the lowest eigenmodes.\n    4. Calculates the first N non-zero FEM eigenfrequencies.\n    5. Calculates the first N non-zero analytical eigenfrequencies.\n    6. Computes the maximum relative error between the FEM and analytical results.\n    \"\"\"\n    # 1. Mesh Generation\n    num_nodes = (Nx + 1) * (Ny + 1)\n    dx = Lx / Nx\n    dy = Ly / Ny\n    \n    nodes = np.zeros((num_nodes, 2))\n    node_map = np.zeros((Nx + 1, Ny + 1), dtype=int)\n    idx = 0\n    for iy in range(Ny + 1):\n        for ix in range(Nx + 1):\n            nodes[idx, 0] = ix * dx\n            nodes[idx, 1] = iy * dy\n            node_map[ix, iy] = idx\n            idx += 1\n\n    elements = []\n    for iy in range(Ny):\n        for ix in range(Nx):\n            n1 = node_map[ix, iy]      # Bottom-left\n            n2 = node_map[ix + 1, iy]  # Bottom-right\n            n3 = node_map[ix + 1, iy + 1] # Top-right\n            n4 = node_map[ix, iy + 1]   # Top-left\n            # Split rectangle into two triangles along the n1-n3 diagonal\n            elements.append((n1, n2, n3))\n            elements.append((n1, n3, n4))\n\n    # 2. FEM Assembly\n    K = lil_matrix((num_nodes, num_nodes))\n    M = lil_matrix((num_nodes, num_nodes))\n    \n    M_const = np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\n    \n    for el_nodes in elements:\n        p1_idx, p2_idx, p3_idx = el_nodes\n        p1, p2, p3 = nodes[p1_idx], nodes[p2_idx], nodes[p3_idx]\n        \n        # Element area and shape function gradients\n        area = 0.5 * np.abs(p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1]))\n        \n        b = np.array([p2[1]-p3[1], p3[1]-p1[1], p1[1]-p2[1]]) / (2 * area)\n        c_grad = np.array([p3[0]-p2[0], p1[0]-p3[0], p2[0]-p1[0]]) / (2 * area)\n        \n        # Element stiffness matrix\n        Ke = np.zeros((3, 3))\n        for i in range(3):\n            for j in range(3):\n                Ke[i, j] = (b[i] * b[j] + c_grad[i] * c_grad[j]) * area\n        \n        # Element mass matrix\n        Me = (area / 12.0) * M_const\n        \n        # Assembly (add element matrices to global matrices)\n        ix_ = np.ix_(el_nodes, el_nodes)\n        K[ix_] += Ke\n        M[ix_] += Me\n\n    # 3. Eigenvalue Solver\n    # Convert to CSR format for efficient computation\n    K_csr = K.tocsr()\n    M_csr = M.tocsr()\n\n    # Solve the generalized eigenvalue problem. Request N+1 smallest magnitude eigenvalues.\n    # The smallest should be the zero-frequency mode.\n    # Using sigma=-0.1 targets eigenvalues close to zero, which is more robust.\n    try:\n        eigenvalues, _ = eigsh(K_csr, k=N + 1, M=M_csr, sigma=-0.1, which='LM')\n    except Exception:\n        # Fallback to smallest magnitude if sigma method fails\n        eigenvalues, _ = eigsh(K_csr, k=N + 1, M=M_csr, which='SM')\n        \n    # 4. Post-processing FEM results\n    # Eigenvalues from eigsh with sigma are not guaranteed to be sorted.\n    eigenvalues = np.sort(eigenvalues)\n    # The first eigenvalue corresponds to the k=0 mode and should be close to 0. We discard it.\n    fem_lambdas = eigenvalues[1 : N + 1]\n    fem_freqs = (c / (2 * np.pi)) * np.sqrt(np.maximum(0, fem_lambdas))\n\n    # 5. Analytical Frequencies\n    analytical_freqs_list = []\n    # A generous search space for (m,n) pairs to ensure we find the first N modes\n    m_max = int(N * (Lx/Ly if Ly  0 else 1)) + 5\n    n_max = int(N * (Ly/Lx if Lx  0 else 1)) + 5\n    for m in range(m_max + 1):\n        for n in range(n_max + 1):\n            if m == 0 and n == 0:\n                continue\n            freq = (c / 2.0) * np.sqrt((m / Lx)**2 + (n / Ly)**2)\n            analytical_freqs_list.append(freq)\n    \n    # Sort frequencies to find the lowest N non-zero modes\n    analytical_freqs_list.sort()\n    analytical_freqs = np.array(analytical_freqs_list[:N])\n\n    # 6. Error Calculation\n    if len(fem_freqs) != N or len(analytical_freqs) != N:\n        raise ValueError(\"Could not find the required number of modes.\")\n        \n    relative_errors = np.abs(fem_freqs - analytical_freqs) / analytical_freqs\n    max_relative_error = np.max(relative_errors)\n    \n    return max_relative_error\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (1.2, 0.8, 343, 30, 20, 5),\n        (1.0, 1.0, 343, 10, 10, 5),\n        (2.0, 0.5, 343, 40, 10, 6),\n        (1.0, 1.0, 343, 40, 40, 6),\n    ]\n\n    results = []\n    for params in test_cases:\n        Lx, Ly, c, Nx, Ny, N = params\n        error = compute_max_error(Lx, Ly, c, Nx, Ny, N)\n        results.append(f\"{error:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}