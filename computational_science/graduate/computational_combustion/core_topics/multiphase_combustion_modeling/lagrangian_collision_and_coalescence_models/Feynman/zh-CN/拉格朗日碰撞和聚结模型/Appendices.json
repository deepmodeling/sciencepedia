{
    "hands_on_practices": [
        {
            "introduction": "“无时间计数器”（No-Time-Counter, NTC）方法是模拟粒子碰撞的随机算法的基石。本练习将通过引导您从第一性原理出发，揭开NTC方法的神秘面紗。您将从碰撞核的物理概念和泊松过程的统计假设开始，推导出常用的线性概率公式，并探索其局限性，最终得出一个更稳健、物理上一致的表达式。",
            "id": "4034271",
            "problem": "在一个用于计算燃烧学的拉格朗日喷雾模型中，考虑位于同一体积为 $V_{c}$ 的欧拉计算网格内的两个液滴包裹 $i$ 和 $j$。包裹 $i$ 代表 $N_{i}$ 个直径为 $d_{i}$ 的相同球形液滴，包裹 $j$ 代表 $N_{j}$ 个直径为 $d_{j}$ 的相同球形液滴。在时长为 $\\Delta t$ 的时间步内，这些包裹具有一个统计平稳的相对速度大小 $|u_{ij}|$，并且碰撞具有一个考虑了流体动力学相互作用的收集效率 $E_{c} \\in (0,1]$。假设单个液滴之间的碰撞可以被建模为一个稀疏、无记忆的泊松过程，并且碰撞即发生并合。\n\n每对液滴的几何碰撞核由经过充分检验的、用于直线接近的 Smoluchowski 形式定义，\n$$\nk_{ij} \\equiv E_{c} \\, \\pi \\left(d_{i} + d_{j}\\right)^{2} \\, |u_{ij}|,\n$$\n其单位为体积/时间。令包裹对事件率系数为\n$$\n\\beta_{ij} \\equiv N_{i} N_{j} \\, k_{ij}.\n$$\n从数密度、相对通量以及碰撞事件的泊松假设等基本定义出发，推导在时间步内包裹 $i$ 和 $j$ 之间至少发生一次碰撞的概率的无时间计数器（NTC）表达式，\n$$\nP_{ij} = \\frac{\\beta_{ij} \\, \\Delta t}{V_{c}},\n$$\n作为其领头阶近似。明确指出导致这种时间线性形式的建模假设。\n\n然后，分析为了随机抽样中的概率一致性而必须满足的约束条件 $P_{ij} \\leq 1$。讨论在实践中违反此约束的条件（例如，大的 $\\Delta t$、小的 $V_{c}$、大的 $N_{i}$、$N_{j}$ 或大的 $|u_{ij}|$），并概述既能保持质量和数量守恒又能避免对并合率产生偏差的物理上一致的修正方法。您的讨论应至少涵盖一种使用子步法的方法和一种使用与泊松过程一致的精确事件概率的方法。\n\n最后，提供一个修正后的碰撞概率 $\\widetilde{P}_{ij}$ 的单一闭式解析表达式，该表达式：\n- 对任意 $\\Delta t$ 均有效，\n- 自动满足 $\\widetilde{P}_{ij} \\leq 1$，\n- 并在 $\\beta_{ij} \\, \\Delta t / V_{c} \\ll 1$ 的极限下简化为 NTC 表达式 $P_{ij} = \\beta_{ij} \\, \\Delta t / V_{c}$。\n\n将最终修正概率表示为单个解析公式。无需进行数值评估，最终方框内的表达式中不应包含任何单位。",
            "solution": "该问题要求对计算燃烧学模拟中使用的碰撞模型进行三部分分析：首先，推导近似的无时间计数器（NTC）碰撞概率；其次，分析其局限性和潜在的修正方法；第三，推导一个修正后的、物理上一致的碰撞概率。对问题陈述的验证证实了其具有科学依据、是适定的，并且基于多相流建模中的既定原理。因此，我们可以着手求解。\n\n首先，我们推导碰撞概率 $P_{ij}$ 的 NTC 表达式。基本前提是，计算网格体积 $V_c$ 内的液滴碰撞构成一个泊松过程。此过程的速率 $\\lambda_{ij}$ 必须被确定。\n\n考虑一个来自包裹 $i$ 的液滴和一个来自包裹 $j$ 的液滴。问题定义了每对液滴的碰撞核 $k_{ij}$，其单位为体积/时间。该核代表一个液滴相对于另一个液滴在单位时间内扫过的体积，并经过收集效率校正。假设液滴在网格体积 $V_c$ 内均匀分布，那么这两个特定液滴碰撞的单位时间概率是扫过体积速率与总体积之比，即 $\\frac{k_{ij}}{V_c}$。这个量的单位是 T$^{-1}$，代表一个频率或速率。\n\n模型考虑包裹 $i$ 中有 $N_i$ 个液滴，包裹 $j$ 中有 $N_j$ 个液滴。两个包裹之间不同的相互作用对的总数为 $N_i N_j$。由于假设过程是稀疏的，不同液滴对之间的碰撞被视为独立事件。因此，来自包裹 $i$ 的任意液滴与来自包裹 $j$ 的任意液滴之间的总碰撞事件速率是每对的速率乘以总对数：\n$$\n\\lambda_{ij} = N_i N_j \\left( \\frac{k_{ij}}{V_c} \\right)\n$$\n使用问题中对包裹对事件率系数的定义 $\\beta_{ij} \\equiv N_i N_j k_{ij}$，总碰撞速率可以写为：\n$$\n\\lambda_{ij} = \\frac{\\beta_{ij}}{V_c}\n$$\n对于一个平均速率恒为 $\\lambda_{ij}$ 的泊松过程，在时间间隔 $\\Delta t$ 内观测到恰好 $k$ 个事件的概率由下式给出：\n$$\nP(k; \\lambda_{ij}, \\Delta t) = \\frac{(\\lambda_{ij} \\Delta t)^k \\exp(-\\lambda_{ij} \\Delta t)}{k!}\n$$\n至少发生一次碰撞的概率是 $P(k \\ge 1) = 1 - P(k=0)$。零次碰撞的概率是：\n$$\nP(k=0) = \\frac{(\\lambda_{ij} \\Delta t)^0 \\exp(-\\lambda_{ij} \\Delta t)}{0!} = \\exp(-\\lambda_{ij} \\Delta t)\n$$\n因此，在 $\\Delta t$ 内至少发生一次碰撞的精确概率是：\n$$\nP_{ij, \\text{exact}} = 1 - \\exp(-\\lambda_{ij} \\Delta t) = 1 - \\exp\\left(-\\frac{\\beta_{ij} \\Delta t}{V_c}\\right)\n$$\nNTC 表达式是此精确概率的领头阶近似，在期望事件数很小的极限下有效。令 $x = \\frac{\\beta_{ij} \\Delta t}{V_c}$。对于 $x \\ll 1$，我们可以使用指数函数的泰勒级数展开 $e^{-x} \\approx 1 - x$。将此式代入精确概率表达式，得到近似式：\n$$\nP_{ij} \\approx 1 - \\left(1 - \\frac{\\beta_{ij} \\Delta t}{V_c}\\right) = \\frac{\\beta_{ij} \\Delta t}{V_c}\n$$\n这就是所求的 NTC 表达式。导致这种时间线性形式的关键建模假设是：\n1.  碰撞被建模为无记忆的泊松过程，这意味着事件是独立和随机的，这适用于稀疏喷雾。\n2.  两个包裹中的液滴在网格体积 $V_c$ 内均匀分布，这为使用宏观数密度提供了依据。\n3.  碰撞速率 $\\lambda_{ij}$ 在时间步 $\\Delta t$ 内是恒定的。这一点由问题陈述中“统计平稳的相对速度大小 $|u_{ij}|$”的条件所支持，并意味着 $N_i$ 和 $N_j$ 在该时间步内不会因碰撞而发生显著变化。\n4.  时间步内的期望碰撞事件数远小于 1，即 $\\lambda_{ij} \\Delta t = \\frac{\\beta_{ij} \\Delta t}{V_c} \\ll 1$。这是验证指数函数线性化的关键数学假设。\n\n接下来，我们分析概率一致性约束 $P_{ij} \\le 1$。NTC 表达式 $P_{ij} = \\frac{\\beta_{ij} \\Delta t}{V_c}$ 是其参数的线性函数并且是无界的。它可以超过 1，这违反了概率的定义。在实践中，当假设 $\\lambda_{ij} \\Delta t \\ll 1$ 不成立时，就会发生这种违规情况。这发生在以下条件下：\n-   大的时间步 $\\Delta t$。\n-   小的计算网格体积 $V_c$。\n-   包裹中大量的液滴数 $N_i$ 和 $N_j$。\n-   大的碰撞核 $k_{ij}$，这可能是由大的液滴直径（$d_i, d_j$）或高的相对速度（$|u_{ij}|$）引起的。\n这些条件在浓密喷雾区域、喷嘴附近或计算网格高度加密的区域很常见。\n\n必须采用物理上一致的修正方法来处理 $P_{ij} > 1$ 的情况。这些方法应确保碰撞统计数据被正确处理而不引入偏差，并且质量和数量守恒。\n1.  **子步法：** 强制满足条件 $\\lambda_{ij} \\Delta t \\ll 1$ 的最直接方法是减小 $\\Delta t$。如果总的流体动力学时间步 $\\Delta t$ 太大，可以将其分成 $M$ 个更小的碰撞子步，时长为 $\\Delta t_s = \\Delta t / M$。选择子步数 $M$ 使得子步内的碰撞概率 $P_{ij,s} = \\frac{\\beta_{ij} \\Delta t_s}{V_c}$ 远小于 1。在每个子步之后，如果发生碰撞并合事件，则更新包裹的粒子数（$N_i, N_j$）。这种方法正确地模拟了在整个时间步 $\\Delta t$ 内反应物（碰撞液滴）布居的减少。然而，它显著增加了计算成本。\n2.  **使用精确事件概率：** 一种计算效率更高的修正方法是放弃线性的 NTC 近似，转而使用更精确的概率表达式。$P_{ij} > 1$ 的问题在于它意味着在一个时间步内平均发生超过一次碰撞事件。与其简单地将概率限制在 1（这会使碰撞率向下偏离），不如使用一种内在有界的公式。至少发生一次事件的精确泊松概率 $P_{ij, \\text{exact}} = 1 - \\exp(-\\lambda_{ij} \\Delta t)$ 是一个自然的选择。该表达式总是在 $[0, 1)$ 范围内，并正确表示发生一次或多次碰撞的概率。如果使用此概率抽样到一次碰撞，通常假设发生的是单个并合事件。这仍然是一个近似，因为它没有考虑在 $\\Delta t$ 内可能发生多个不同碰撞事件的可能性，但与 NTC 方法相比，这是一个显著的改进，并且避免了非物理的 $P_{ij} > 1$ 问题，同时没有子步法带来的成本。\n\n最后，我们被要求提供一个修正后的碰撞概率 $\\widetilde{P}_{ij}$ 的单一闭式解析表达式，该表达式满足三个条件：对任意 $\\Delta t$ 有效，自动满足 $\\widetilde{P}_{ij} \\le 1$，并在适当的极限下简化为 NTC 形式。\n\n如上文推导和讨论，泊松过程中至少发生一次事件的精确概率满足所有这些标准。我们将修正后的概率 $\\widetilde{P}_{ij}$ 定义为这个精确概率：\n$$\n\\widetilde{P}_{ij} = 1 - \\exp(-\\lambda_{ij} \\Delta t) = 1 - \\exp\\left(-\\frac{\\beta_{ij} \\Delta t}{V_c}\\right)\n$$\n让我们验证这些条件：\n1.  **对任意 $\\Delta t$ 有效**：指数函数对所有实数自变量都有定义。由于 $\\Delta t \\ge 0$，指数的参数总是非正的，并且函数是良态的。\n2.  **满足 $\\widetilde{P}_{ij} \\le 1$**：由于所有物理量（$\\beta_{ij}$、$\\Delta t$、$V_c$）都是非负的，指数的参数 $-\\frac{\\beta_{ij} \\Delta t}{V_c}$ 总是小于或等于 0。因此，$0  \\exp\\left(-\\frac{\\beta_{ij} \\Delta t}{V_c}\\right) \\le 1$。由此得出 $0 \\le 1 - \\exp\\left(-\\frac{\\beta_{ij} \\Delta t}{V_c}\\right)  1$。所以条件 $\\widetilde{P}_{ij} \\le 1$ 总是满足的。\n3.  **简化为 NTC 表达式**：在 $\\frac{\\beta_{ij} \\Delta t}{V_c} \\ll 1$ 的极限下，我们对小的 $x$ 使用泰勒展开 $\\exp(-x) \\approx 1-x$。\n    $$\n    \\widetilde{P}_{ij} = 1 - \\exp\\left(-\\frac{\\beta_{ij} \\Delta t}{V_c}\\right) \\approx 1 - \\left(1 - \\frac{\\beta_{ij} \\Delta t}{V_c}\\right) = \\frac{\\beta_{ij} \\Delta t}{V_c}\n    $$\n    这正是 NTC 表达式。\n\n因此，修正后的碰撞概率就是至少发生一次事件的精确泊松概率。",
            "answer": "$$\n\\boxed{1 - \\exp\\left(-\\frac{\\beta_{ij} \\Delta t}{V_{c}}\\right)}\n$$"
        },
        {
            "introduction": "当两个液滴合并时，它们的能量会发生什么变化？虽然线性动量是守恒的，但这个过程本质上是非弹性的，意味着动能并不守恒。本练习深入探讨了合并过程的能量学，要求您推导从宏观平动中耗散的动能大小，并将其与液滴的相对速度联系起来。 理解这种能量转换对于精确模拟新形成液滴的热物理状态至关重要。",
            "id": "4034296",
            "problem": "考虑高压燃烧室中的两个拉格朗日液体燃料包裹。包裹$1$的质量为$m_1$，速度为$\\boldsymbol{v}_1$；包裹$2$的质量为$m_2$，速度为$\\boldsymbol{v}_2$。它们经历一次聚并碰撞，合并成一个质量为$m = m_1 + m_2$的单一包裹。在拉格朗日碰撞-聚并更新中，线性动量是守恒的，合并后的包裹以一个由动量守恒决定的单一平均速度前进。然而，由于两个入射包裹的速度不同，存在着与它们运动相关的相对平动动能，这部分能量在聚并过程中通常会被耗散。\n\n在一个计算燃烧模型中，假设你希望通过将耗散的相对平动能归因于一个与合并包裹相关的、由伪速度$\\boldsymbol{u}$表示的储存的、各向同性的、零均值的扰动，从而在离散层面上保持包裹系综的总动能。这个伪速度以$\\tfrac{1}{2} m |\\boldsymbol{u}|^2$的形式贡献于包裹的动能，但不用于动量更新或平流计算，因此它不改变线性动量。\n\n仅从线性动量守恒、动能的定义以及矢量代数出发，推导出一个关于平方大小$|\\boldsymbol{u}|^2$的闭式解析表达式，该表达式是使合并包裹的总动能（平均动能加扰动动能）精确等于两个入射包裹平动动能之和的充分必要条件。你的推导应明确指出入射相对运动的作用，并根据表面张力能等基本概念，将耗散的能量与聚并过程中的物理上有意义的能量库（如内能模式（例如温度升高）和表面能）联系起来。\n\n用$m_1$、$m_2$、$\\boldsymbol{v}_1$和$\\boldsymbol{v}_2$表示$|\\boldsymbol{u}|^2$（单位为$\\mathrm{m^2/s^2}$），给出一个单一的解析表达式作为你的最终答案。不需要进行数值计算。",
            "solution": "该问题是有效的，因为它具有科学依据、提法明确且客观。它在一个明确定义的建模框架内描述了一个物理上一致的非弹性碰撞场景。问题提供了必要的信息，可以基于线性动量守恒原理和规定的能量守恒形式推导出一个唯一的解。\n\n推导过程从问题陈述中定义的基本原理——线性动量守恒和总能量平衡——出发。\n\n首先，我们确定合并后包裹的速度。该碰撞遵循线性动量守恒。碰撞前的总动量是两个包裹各自动量之和：\n$$\n\\boldsymbol{P}_{\\text{initial}} = m_1 \\boldsymbol{v}_1 + m_2 \\boldsymbol{v}_2\n$$\n碰撞后，两个包裹合并成一个质量为$m = m_1 + m_2$的单一包裹，以平均速度$\\boldsymbol{v}$运动。其动量为：\n$$\n\\boldsymbol{P}_{\\text{final}} = (m_1 + m_2) \\boldsymbol{v} = m \\boldsymbol{v}\n$$\n根据线性动量守恒，$\\boldsymbol{P}_{\\text{initial}} = \\boldsymbol{P}_{\\text{final}}$。因此：\n$$\nm_1 \\boldsymbol{v}_1 + m_2 \\boldsymbol{v}_2 = (m_1 + m_2) \\boldsymbol{v}\n$$\n求解最终的平均速度$\\boldsymbol{v}$可得：\n$$\n\\boldsymbol{v} = \\frac{m_1 \\boldsymbol{v}_1 + m_2 \\boldsymbol{v}_2}{m_1 + m_2}\n$$\n此速度是双包裹系统的质心速度，由于没有外力作用，在整个碰撞过程中保持不变。\n\n接下来，我们应用问题规定的能量守恒条件。碰撞前两个包裹的总动能是它们各自平动动能之和：\n$$\nK_{\\text{initial}} = \\frac{1}{2} m_1 |\\boldsymbol{v}_1|^2 + \\frac{1}{2} m_2 |\\boldsymbol{v}_2|^2\n$$\n碰撞后，问题陈述指出合并包裹的总动能是其平均平动动能$\\frac{1}{2} m |\\boldsymbol{v}|^2$和储存的扰动能$\\frac{1}{2} m |\\boldsymbol{u}|^2$之和。\n$$\nK_{\\text{final}} = \\frac{1}{2} m |\\boldsymbol{v}|^2 + \\frac{1}{2} m |\\boldsymbol{u}|^2\n$$\n问题要求总能量守恒，所以$K_{\\text{initial}} = K_{\\text{final}}$：\n$$\n\\frac{1}{2} m_1 |\\boldsymbol{v}_1|^2 + \\frac{1}{2} m_2 |\\boldsymbol{v}_2|^2 = \\frac{1}{2} m |\\boldsymbol{v}|^2 + \\frac{1}{2} m |\\boldsymbol{u}|^2\n$$\n我们想要找到$|\\boldsymbol{u}|^2$的表达式。重新整理方程以求解扰动能项，得到：\n$$\n\\frac{1}{2} m |\\boldsymbol{u}|^2 = \\left( \\frac{1}{2} m_1 |\\boldsymbol{v}_1|^2 + \\frac{1}{2} m_2 |\\boldsymbol{v}_2|^2 \\right) - \\frac{1}{2} m |\\boldsymbol{v}|^2\n$$\n此方程表明，扰动能项$\\frac{1}{2} m |\\boldsymbol{u}|^2$正是系统的初始动能与最终平均动能之差。这个差值是在非弹性聚并过程中从整体平动中“损失”或耗散掉的动能。\n\n为了求得$|\\boldsymbol{u}|^2$，我们首先求解耗散的能量。让我们代入$m$和$\\boldsymbol{v}$的表达式：\n$$\nm |\\boldsymbol{u}|^2 = m_1 |\\boldsymbol{v}_1|^2 + m_2 |\\boldsymbol{v}_2|^2 - (m_1 + m_2) \\left| \\frac{m_1 \\boldsymbol{v}_1 + m_2 \\boldsymbol{v}_2}{m_1 + m_2} \\right|^2\n$$\n最后一项可以使用性质$|\\boldsymbol{a}|^2 = \\boldsymbol{a} \\cdot \\boldsymbol{a}$展开：\n$$\n(m_1 + m_2) \\frac{(m_1 \\boldsymbol{v}_1 + m_2 \\boldsymbol{v}_2) \\cdot (m_1 \\boldsymbol{v}_1 + m_2 \\boldsymbol{v}_2)}{(m_1 + m_2)^2} = \\frac{m_1^2 |\\boldsymbol{v}_1|^2 + m_2^2 |\\boldsymbol{v}_2|^2 + 2 m_1 m_2 (\\boldsymbol{v}_1 \\cdot \\boldsymbol{v}_2)}{m_1 + m_2}\n$$\n将此代回关于$m |\\boldsymbol{u}|^2$的方程中：\n$$\nm |\\boldsymbol{u}|^2 = m_1 |\\boldsymbol{v}_1|^2 + m_2 |\\boldsymbol{v}_2|^2 - \\frac{m_1^2 |\\boldsymbol{v}_1|^2 + m_2^2 |\\boldsymbol{v}_2|^2 + 2 m_1 m_2 (\\boldsymbol{v}_1 \\cdot \\boldsymbol{v}_2)}{m_1 + m_2}\n$$\n为了简化，我们将所有项通分到共同分母$(m_1 + m_2)$上：\n$$\nm |\\boldsymbol{u}|^2 = \\frac{(m_1 + m_2)(m_1 |\\boldsymbol{v}_1|^2 + m_2 |\\boldsymbol{v}_2|^2) - (m_1^2 |\\boldsymbol{v}_1|^2 + m_2^2 |\\boldsymbol{v}_2|^2 + 2 m_1 m_2 (\\boldsymbol{v}_1 \\cdot \\boldsymbol{v}_2))}{m_1 + m_2}\n$$\n展开分子的第一部分：\n$$\n(m_1 + m_2)(m_1 |\\boldsymbol{v}_1|^2 + m_2 |\\boldsymbol{v}_2|^2) = m_1^2 |\\boldsymbol{v}_1|^2 + m_1 m_2 |\\boldsymbol{v}_2|^2 + m_2 m_1 |\\boldsymbol{v}_1|^2 + m_2^2 |\\boldsymbol{v}_2|^2\n$$\n将此代入分子表达式并简化：\n$$\n\\text{Numerator} = (m_1^2 |\\boldsymbol{v}_1|^2 + m_1 m_2 |\\boldsymbol{v}_2|^2 + m_1 m_2 |\\boldsymbol{v}_1|^2 + m_2^2 |\\boldsymbol{v}_2|^2) - (m_1^2 |\\boldsymbol{v}_1|^2 + m_2^2 |\\boldsymbol{v}_2|^2 + 2 m_1 m_2 (\\boldsymbol{v}_1 \\cdot \\boldsymbol{v}_2))\n$$\n$$\n\\text{Numerator} = m_1 m_2 |\\boldsymbol{v}_1|^2 + m_1 m_2 |\\boldsymbol{v}_2|^2 - 2 m_1 m_2 (\\boldsymbol{v}_1 \\cdot \\boldsymbol{v}_2)\n$$\n提出公因子$m_1 m_2$：\n$$\n\\text{Numerator} = m_1 m_2 (|\\boldsymbol{v}_1|^2 - 2 (\\boldsymbol{v}_1 \\cdot \\boldsymbol{v}_2) + |\\boldsymbol{v}_2|^2)\n$$\n括号中的表达式是相对速度矢量$(\\boldsymbol{v}_1 - \\boldsymbol{v}_2) \\cdot (\\boldsymbol{v}_1 - \\boldsymbol{v}_2) = |\\boldsymbol{v}_1 - \\boldsymbol{v}_2|^2$的平方大小的展开式。\n因此，分子简化为：\n$$\n\\text{Numerator} = m_1 m_2 |\\boldsymbol{v}_1 - \\boldsymbol{v}_2|^2\n$$\n这个结果明确指出了入射相对运动的核心作用，正如问题所要求。耗散的能量直接取决于包裹之间的相对速度。\n所以我们有：\n$$\nm |\\boldsymbol{u}|^2 = \\frac{m_1 m_2}{m_1 + m_2} |\\boldsymbol{v}_1 - \\boldsymbol{v}_2|^2\n$$\n项$\\frac{m_1 m_2}{m_1 + m_2}$是系统的折合质量，通常用$\\mu$表示。因此，耗散的能量为$\\frac{1}{2} \\mu |\\boldsymbol{v}_{\\text{rel}}|^2$，这是质心坐标系中与两个包裹相对运动相关的动能。\n\n最后，我们通过除以总质量$m = m_1 + m_2$来求解$|\\boldsymbol{u}|^2$：\n$$\n|\\boldsymbol{u}|^2 = \\frac{1}{m_1 + m_2} \\left(\\frac{m_1 m_2}{m_1 + m_2}\\right) |\\boldsymbol{v}_1 - \\boldsymbol{v}_2|^2 = \\frac{m_1 m_2}{(m_1 + m_2)^2} |\\boldsymbol{v}_1 - \\boldsymbol{v}_2|^2\n$$\n这就是伪速度平方大小的闭式解析表达式。\n\n在物理聚并过程中，耗散的动能$\\frac{1}{2} m |\\boldsymbol{u}|^2$被转化为其他形式的能量。伪速度$\\boldsymbol{u}$是一个用于追踪此能量的建模构造。这种能量的主要物理储存库是：\n1. 内能：在包裹的流体变形和合并过程中的粘性耗散将动能转化为热能，导致温度升高。\n2. 表面能：两个球形包裹的总表面积为$A_i \\propto (m_1^{2/3} + m_2^{2/3})$，而合并后的球形包裹的面积为$A_f \\propto (m_1+m_2)^{2/3}$。由于$x^{2/3}$是一个凹函数，所以$A_i > A_f$。表面积的减少释放了表面能$\\Delta E_s = \\sigma (A_i - A_f)$，其中$\\sigma$是表面张力。这部分能量也主要转化为内热。\n3. 振动能和转动能：合并后产生的包裹可能处于振荡的非球形状态或具有整体旋转，这代表了另一个临时的能量储存库。\n\n计算模型使用$\\frac{1}{2} m |\\boldsymbol{u}|^2$将这些复杂的物理效应集总为一个单一、易于处理的标量，确保在离散数值模拟中能量是守恒的。",
            "answer": "$$\n\\boxed{\\frac{m_1 m_2}{(m_1 + m_2)^2} |\\boldsymbol{v}_1 - \\boldsymbol{v}_2|^2}\n$$"
        },
        {
            "introduction": "对于任何计算科学家来说，弥合理论与模拟代码之间的鸿沟是一项至关重要的技能。这个动手编程问题解决了一个经典的实现挑战：在周期性域内准确地检测碰撞。您将实现并对比一种朴素方法和一种使用“最小镜像约定”的修正算法，从而展示细微的算法选择如何对模拟的准确性产生重大影响。",
            "id": "4034236",
            "problem": "考虑一个三维环形域，其在每个笛卡尔方向上的边长为 $L$，并具有周期性边界条件（PBC）。该域中分布着一组有限的、被视为刚性球体的拉格朗日液滴。每个液滴 $i$ 具有位置向量 $\\mathbf{x}_i$（单位：米），速度向量 $\\mathbf{v}_i$（单位：米每秒），以及半径 $r_i$（单位：米）。设域体积为 $V = L^3$（单位：立方米），并考虑一个固定的时间步长 $\\Delta t$（单位：秒）。假设在时间步长内速度恒定（无外力，无阻力变化），因此每个液滴的轨迹为 $\\mathbf{x}_i(t) = \\mathbf{x}_i(0) + \\mathbf{v}_i t$，其中 $t \\in [0,\\Delta t]$。\n\n我们关心用于碰撞-合并采样的算法性对计数。物理模型使用适用于刚性球形液滴的弹道碰撞核：如果两个液滴 $i$ 和 $j$ 以相对速率 $|\\mathbf{u}_{ij}| = \\|\\mathbf{v}_j - \\mathbf{v}_i\\|$ 相对运动，则每对的碰撞率与几何横截面积 $\\pi (r_i + r_j)^2$ 乘以相对速率成正比。在均匀体积近似下，在时间步长 $\\Delta t$ 内，由无序对 $(i,j)$ 贡献的期望碰撞次数为\n$$\np_{ij} = \\min\\left(1, \\frac{\\pi (r_i + r_j)^2 \\, |\\mathbf{u}_{ij}| \\, \\Delta t}{V}\\right),\n$$\n该值是无量纲的。为避免计算物理上不可能的碰撞，需执行以下从恒速运动推导出的运动学可行性检查：定义 $t=0$ 时的相对位置为 $\\mathbf{r}_{ij}(0) = \\mathbf{x}_j(0) - \\mathbf{x}_i(0)$，相对速度为 $\\mathbf{u}_{ij} = \\mathbf{v}_j - \\mathbf{v}_i$。在 $t \\in [0,\\Delta t]$ 范围内，间距演变为 $\\mathbf{r}_{ij}(t) = \\mathbf{r}_{ij}(0) + \\mathbf{u}_{ij} t$。令 $t^\\star = \\operatorname{clamp}\\left(-\\frac{\\mathbf{r}_{ij}(0)\\cdot \\mathbf{u}_{ij}}{\\|\\mathbf{u}_{ij}\\|^2}, 0, \\Delta t\\right)$ 为该区间内的最小间距时间，且 $d_{\\min} = \\|\\mathbf{r}_{ij}(t^\\star)\\|$。当且仅当 $d_{\\min} \\le r_i + r_j$ 时，一次碰撞在该时间步长内是运动学上可行的。\n\n在环形域中，位移 $\\mathbf{r}_{ij}(0)$ 必须使用最小镜像约定来计算，以使每个分量都位于区间 $[-L/2, L/2)$ 内。对于每个笛卡尔分量 $k \\in \\{x,y,z\\}$，\n$$\nr_{ij,k}^{\\text{MI}} = \\left(x_{j,k} - x_{i,k}\\right) - L \\cdot \\operatorname{round}\\left(\\frac{x_{j,k} - x_{i,k}}{L}\\right).\n$$\n使用最小镜像位移可确保对几何间距跨越周期性边界的液滴对进行无偏处理。无偏碰撞采样还要求对无序对只计数一次；重复计算有序对 $(i,j)$ 和 $(j,i)$ 会使远离边界区域的估计量产生两倍的偏差。\n\n你的任务是编写一个完整的程序，为每个提供的测试用例计算以下两个量：\n- 一个朴素的每时间步长期望碰撞次数，通过在运动学可行性检查中使用未经包裹的位移 $\\mathbf{x}_j - \\mathbf{x}_i$（无最小镜像校正），并对所有有序对 $i \\ne j$ 的 $p_{ij}$ 求和来计算。\n- 一个校正后的每时间步长期望碰撞次数，通过在运动学可行性检查中使用最小镜像位移，并对所有无序对 $i  j$ 的 $p_{ij}$ 求和来计算。\n\n对于这两种计数，当且仅当满足运动学可行性准则 $d_{\\min} \\le r_i + r_j$ 时，才计入该对的贡献 $p_{ij}$。由于周期性边界条件，所有位置必须对 $L$ 取模进行解释（即，每个分量的输入值可以位于 $[0,L)$ 区间内的任何位置）。使用国际单位制（SI）：位置单位为米，速度单位为米每秒，半径单位为米， $L$ 单位为米，$\\Delta t$ 单位为秒。期望碰撞次数是无量纲的，并且必须以十进制浮点数形式输出。\n\n测试套件：\n1. 情况 A（跨边界接近，边长 $L=0.01$ 米的 $3$-维环面）：两个液滴，\n   - 液滴 1：$\\mathbf{x}_1 = [0.0005, 0.0, 0.0]$ 米，$\\mathbf{v}_1 = [-0.5, 0.0, 0.0]$ 米/秒， $r_1 = 2\\times 10^{-4}$ 米。\n   - 液滴 2：$\\mathbf{x}_2 = [0.0095, 0.0, 0.0]$ 米，$\\mathbf{v}_2 = [0.5, 0.0, 0.0]$ 米/秒， $r_2 = 2\\times 10^{-4}$ 米。\n   - $\\Delta t = 0.002$ 秒。\n2. 情况 B（内部接近，重复计数检查，边长 $L=0.01$ 米的 $3$-维环面）：两个液滴，\n   - 液滴 1：$\\mathbf{x}_1 = [0.004, 0.0, 0.0]$ 米，$\\mathbf{v}_1 = [0.5, 0.0, 0.0]$ 米/秒， $r_1 = 2\\times 10^{-4}$ 米。\n   - 液滴 2：$\\mathbf{x}_2 = [0.006, 0.0, 0.0]$ 米，$\\mathbf{v}_2 = [-0.5, 0.0, 0.0]$ 米/秒， $r_2 = 2\\times 10^{-4}$ 米。\n   - $\\Delta t = 0.003$ 秒。\n3. 情况 C（包含一次跨边界接近的混合三液滴配置，边长 $L=0.02$ 米的 $3$-维环面）：三个液滴，\n   - 液滴 1：$\\mathbf{x}_1 = [0.0198, 0.001, 0.0]$ 米，$\\mathbf{v}_1 = [0.2, 0.0, 0.0]$ 米/秒， $r_1 = 2\\times 10^{-4}$ 米。\n   - 液滴 2：$\\mathbf{x}_2 = [0.0005, 0.001, 0.0]$ 米，$\\mathbf{v}_2 = [-0.2, 0.0, 0.0]$ 米/秒， $r_2 = 2\\times 10^{-4}$ 米。\n   - 液滴 3：$\\mathbf{x}_3 = [0.010, 0.010, 0.0]$ 米，$\\mathbf{v}_3 = [0.0, 0.0, 0.0]$ 米/秒， $r_3 = 1\\times 10^{-4}$ 米。\n   - $\\Delta t = 0.005$ 秒。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的六个十进制浮点数列表，顺序如下：\n$$\n[\\text{naive\\_A}, \\text{corrected\\_A}, \\text{naive\\_B}, \\text{corrected\\_B}, \\text{naive\\_C}, \\text{corrected\\_C}],\n$$\n其中每一项是指定用例和方法的期望碰撞次数。输出必须严格遵循 Python 列表字符串的形式，例如 $[\\text{float1},\\text{float2},\\ldots]$。",
            "solution": "问题陈述已经过验证，被认为是具有科学依据、适定且客观的。它基于在周期性域中进行拉格朗日粒子追踪和碰撞建模的既定原理，提出了一个清晰的计算任务。所有必需的参数、定义和方程均已提供，从而可以得出一个唯一且可验证的解。\n\n该问题要求计算在一个时间步长 $\\Delta t$ 内，三维环形域中一组球形液滴的期望碰撞次数。解决方案涉及实现两种不同的算法方法：“朴素”方法和“校正”方法，它们的区别在于对周期性边界条件和对计数的处理方式。\n\n计算的核心基于三个概念：碰撞概率、碰撞的运动学可行性以及对周期性的处理。\n\n1.  **碰撞概率 ($p_{ij}$)**：液滴对 $(i,j)$ 的碰撞概率由下式给出\n    $$p_{ij} = \\min\\left(1, \\frac{\\pi (r_i + r_j)^2 \\, |\\mathbf{u}_{ij}| \\, \\Delta t}{V}\\right)$$\n    此表达式表示液滴 $j$ 相对于液滴 $i$（反之亦然）扫过的体积，并由总域体积 $V = L^3$ 进行归一化。项 $\\pi (r_i + r_j)^2$ 是半径分别为 $r_i$ 和 $r_j$ 的两个球体的碰撞横截面。项 $|\\mathbf{u}_{ij}| \\Delta t$ 是在时间步长 $\\Delta t$ 内液滴相对移动的距离，其中 $\\mathbf{u}_{ij} = \\mathbf{v}_j - \\mathbf{v}_i$ 是相对速度。它们的乘积形成一个“碰撞体积”。$\\min(1, \\cdot)$ 函数确保结果保持为有效的概率值。\n\n2.  **运动学可行性**：只有当液滴的轨迹实际相交时，碰撞概率 $p_{ij}$ 才具有物理意义。假设速度恒定，相对位置向量演变为 $\\mathbf{r}_{ij}(t) = \\mathbf{r}_{ij}(0) + \\mathbf{u}_{ij} t$。间距的平方是时间的二次函数：$d(t)^2 = \\|\\mathbf{r}_{ij}(t)\\|^2 = \\|\\mathbf{r}_{ij}(0) + \\mathbf{u}_{ij} t\\|^2$。此函数在区间 $t \\in [0, \\Delta t]$ 内的最小值出现在时间 $t^\\star$ 处，该值可通过将导数 $\\frac{d}{dt}d(t)^2 = 0$ 设为零求得。这给出了在 $t = -\\frac{\\mathbf{r}_{ij}(0)\\cdot \\mathbf{u}_{ij}}{\\|\\mathbf{u}_{ij}\\|^2}$ 处的无约束最小值。问题将 $t^\\star$ 定义为此值被限制在区间 $[0, \\Delta t]$ 内的结果：\n    $$t^\\star = \\operatorname{clamp}\\left(-\\frac{\\mathbf{r}_{ij}(0)\\cdot \\mathbf{u}_{ij}}{\\|\\mathbf{u}_{ij}\\|^2}, 0, \\Delta t\\right)$$\n    如果 $\\|\\mathbf{u}_{ij}\\| = 0$，液滴之间没有相对运动，因此 $d_{\\min} = \\|\\mathbf{r}_{ij}(0)\\|$，并且 $p_{ij}$ 的表达式为零。最小间距为 $d_{\\min} = \\|\\mathbf{r}_{ij}(t^\\star)\\|$。当且仅当这个最小距离小于或等于半径之和，即 $d_{\\min} \\le r_i + r_j$ 时，碰撞才可能发生。必须满足此准则，才能将 $p_{ij}$ 计入总数。\n\n3.  **周期性边界条件 (PBC) 和求和方法**：环形域意味着一个液滴从一个面离开后会从对面重新进入。两个液滴之间的“真实”距离是考虑所有可能的周期性镜像后的最短距离。这通过使用最小镜像约定 (MIC) 来计算：对于每个笛卡尔分量 $k$，相对位移 $r_{ij,k}$ 被包裹到区间 $[-L/2, L/2)$ 内。\n    $$r_{ij,k}^{\\text{MI}} = \\left(x_{j,k} - x_{i,k}\\right) - L \\cdot \\operatorname{round}\\left(\\frac{x_{j,k} - x_{i,k}}{L}\\right)$$\n    “朴素”方法错误地使用未经包裹的位移 $\\mathbf{r}_{ij}(0) = \\mathbf{x}_j - \\mathbf{x}_i$ 进行运动学检查，并对所有有序对 ($i \\ne j$) 求和，这导致了因忽略周期性和重复计数而产生的错误。\n    “校正”方法正确地使用最小镜像位移 $\\mathbf{r}_{ij}^{\\text{MI}}(0)$ 进行运动学检查，并对唯一的无序对（通常是 $i  j$）求和，从而避免了重复计数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the computation for all test cases.\n    \"\"\"\n    \n    # Define test cases as per the problem statement\n    test_cases = [\n        # Case A\n        {\n            \"L\": 0.01, \"dt\": 0.002, \"droplets\": [\n                {\"x\": np.array([0.0005, 0.0, 0.0]), \"v\": np.array([-0.5, 0.0, 0.0]), \"r\": 2e-4},\n                {\"x\": np.array([0.0095, 0.0, 0.0]), \"v\": np.array([0.5, 0.0, 0.0]), \"r\": 2e-4}\n            ]\n        },\n        # Case B\n        {\n            \"L\": 0.01, \"dt\": 0.003, \"droplets\": [\n                {\"x\": np.array([0.004, 0.0, 0.0]), \"v\": np.array([0.5, 0.0, 0.0]), \"r\": 2e-4},\n                {\"x\": np.array([0.006, 0.0, 0.0]), \"v\": np.array([-0.5, 0.0, 0.0]), \"r\": 2e-4}\n            ]\n        },\n        # Case C\n        {\n            \"L\": 0.02, \"dt\": 0.005, \"droplets\": [\n                {\"x\": np.array([0.0198, 0.001, 0.0]), \"v\": np.array([0.2, 0.0, 0.0]), \"r\": 2e-4},\n                {\"x\": np.array([0.0005, 0.001, 0.0]), \"v\": np.array([-0.2, 0.0, 0.0]), \"r\": 2e-4},\n                {\"x\": np.array([0.010, 0.010, 0.0]), \"v\": np.array([0.0, 0.0, 0.0]), \"r\": 1e-4}\n            ]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        naive_count, corrected_count = compute_collision_counts(\n            case[\"L\"], case[\"dt\"], case[\"droplets\"]\n        )\n        all_results.extend([naive_count, corrected_count])\n        \n    # Format the final output as a Python list string\n    print(f\"[{','.join(f'{r:.17f}' for r in all_results)}]\")\n\ndef minimum_image_displacement(dr, L):\n    \"\"\"\n    Computes the displacement vector according to the minimum-image convention.\n    dr: The unwrapped displacement vector (x_j - x_i).\n    L: The side length of the cubic domain.\n    \"\"\"\n    return dr - L * np.round(dr / L)\n\ndef is_kinematically_feasible(r0, u, dt, r_sum):\n    \"\"\"\n    Checks if a collision is kinematically feasible within the time step.\n    r0: Initial relative position vector.\n    u: Relative velocity vector.\n    dt: Time step.\n    r_sum: Sum of the radii of the two droplets (r_i + r_j).\n    \"\"\"\n    u_norm_sq = np.dot(u, u)\n    \n    # Handle case of zero relative velocity\n    if u_norm_sq == 0.0:\n        d_min = np.linalg.norm(r0)\n    else:\n        # Time of closest approach (unconstrained)\n        t_unclamped = -np.dot(r0, u) / u_norm_sq\n        \n        # Clamp t to the interval [0, dt]\n        t_star = np.clip(t_unclamped, 0.0, dt)\n        \n        # Minimum separation distance within the interval\n        r_at_t_star = r0 + u * t_star\n        d_min = np.linalg.norm(r_at_t_star)\n\n    return d_min = r_sum\n\ndef compute_collision_counts(L, dt, droplets):\n    \"\"\"\n    Computes naive and corrected expected collision counts for a given case.\n    \"\"\"\n    V = L**3\n    num_droplets = len(droplets)\n    \n    naive_total_p = 0.0\n    corrected_total_p = 0.0\n    \n    # --- Naive Calculation (ordered pairs i != j, no MIC) ---\n    for i in range(num_droplets):\n        for j in range(num_droplets):\n            if i == j:\n                continue\n            \n            p_i = droplets[i]\n            p_j = droplets[j]\n            \n            # Unwrapped relative position and velocity\n            r_ij_0_unwrapped = p_j[\"x\"] - p_i[\"x\"]\n            u_ij = p_j[\"v\"] - p_i[\"v\"]\n            r_sum = p_i[\"r\"] + p_j[\"r\"]\n            \n            if is_kinematically_feasible(r_ij_0_unwrapped, u_ij, dt, r_sum):\n                u_norm = np.linalg.norm(u_ij)\n                p = (np.pi * r_sum**2 * u_norm * dt) / V\n                naive_total_p += min(1.0, p)\n                \n    # --- Corrected Calculation (unordered pairs i  j, with MIC) ---\n    for i in range(num_droplets):\n        for j in range(i + 1, num_droplets):\n            p_i = droplets[i]\n            p_j = droplets[j]\n            \n            # Unwrapped relative position (for MIC)\n            r_ij_0_unwrapped = p_j[\"x\"] - p_i[\"x\"]\n            # Corrected relative position using MIC\n            r_ij_0_mic = minimum_image_displacement(r_ij_0_unwrapped, L)\n            \n            u_ij = p_j[\"v\"] - p_i[\"v\"]\n            r_sum = p_i[\"r\"] + p_j[\"r\"]\n\n            if is_kinematically_feasible(r_ij_0_mic, u_ij, dt, r_sum):\n                u_norm = np.linalg.norm(u_ij)\n                p = (np.pi * r_sum**2 * u_norm * dt) / V\n                corrected_total_p += min(1.0, p)\n\n    return naive_total_p, corrected_total_p\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}