{
    "hands_on_practices": [
        {
            "introduction": "任何欧拉-欧拉模型的基础都是精确追踪各相的体积分数 $\\alpha_k$。本练习剥离了动量和能量交换等复杂性，专注于 $\\alpha_k$ 的基本输运方程。通过为这个基本的平流方程实现一个数值解，您将亲身体验守恒形式控制方程，并理解确保体积分数之和恒为一（$ \\sum_k \\alpha_k = 1 $）这一多相流模拟核心约束的至关重要性 。这项实践为您构建了进行更高级双流体建模所必需的核心编程和验证技能。",
            "id": "4023914",
            "problem": "考虑一个无反应、等温、无相间质量传递和无蒸发的液-气喷雾的一维欧拉-欧拉两流体表示。令液相由下标 $\\ell$ 表示，气相由下标 $g$ 表示。液体体积分数为 $\\alpha_{\\ell}(x,t)$，气体体积分数为 $\\alpha_{g}(x,t)$，且假设在 $t=0$ 时满足混合物体积填充约束 $\\alpha_{\\ell}(x,t)+\\alpha_{g}(x,t)=1$。液体和气体密度分别为常数 $\\rho_{\\ell}$ 和 $\\rho_{g}$。假设两相都由一个给定的、在空间和时间上恒定的均匀入流速度场 $u(x,t)=u_{0}$ 输运，并且两相都没有体积源。\n\n仅从相质量守恒定律和体积分数的定义出发，以守恒形式推导出一维空间中 $\\alpha_{\\ell}(x,t)$ 的控制输运方程，并明确陈述推导所需的所有假设。然后，在均匀网格上使用守恒的有限体积离散化和带有一阶迎风数值通量的 Courant–Friedrichs–Lewy (CFL) 稳定性条件，在相同的给定速度 $u_{0}$ 和边界条件下，将 $\\alpha_{\\ell}(x,t)$ 和 $\\alpha_{g}(x,t)$ 从 $t=0$ 独立演化到 $t=T$。在时间积分后，通过计算每个测试案例在最终时刻的最大绝对偏差来量化混合物体积分数约束的守恒性：\n$$\n\\varepsilon_{\\max}=\\max_{x\\in[0,L]}\\left|\\alpha_{\\ell}(x,T)+\\alpha_{g}(x,T)-1\\right|.\n$$\n所有空间坐标 $x$ 的单位必须是 $\\mathrm{m}$，时间 $t$ 的单位是 $\\mathrm{s}$，速度 $u_{0}$ 的单位是 $\\mathrm{m/s}$，而 $\\varepsilon_{\\max}$ 是无量纲的。密度 $\\rho_{\\ell}$ 和 $\\rho_{g}$ 必须以 $\\mathrm{kg/m^3}$ 为单位指定；然而，你的推导必须阐明在这种情况下它们是否以及如何影响 $\\alpha_{\\ell}$ 的输运。\n\n用一个单一的程序实现该算法，该程序：\n- 在长度为 $L$ 的域上构建一个具有 $N$ 个控制体积的均匀网格。\n- 使用满足用户指定库朗数 $\\mathrm{CFL}$ 的时间步长 $\\Delta t$，其中 $\\mathrm{CFL} = |u_{0}|\\Delta t/\\Delta x$，$\\Delta x=L/N$。\n- 将相同的数值通量分别应用于每个相方程，以在时间上推进 $\\alpha_{\\ell}$ 和 $\\alpha_{g}$，使用下面指定的周期性或入流-出流边界条件。\n- 在每个时间步后，将 $\\alpha_{\\ell}$ 和 $\\alpha_{g}$ 截断到物理允许的区间 $[0,1]$ 内。\n- 计算每个测试案例在 $t=T$ 时的 $\\varepsilon_{\\max}$。\n\n你的程序必须在没有用户输入的情况下运行以下测试套件。对于每个案例，只报告 $\\varepsilon_{\\max}$ 作为一个浮点数。\n\n测试套件：\n- 案例 A（周期性，平滑脉冲，常规情况）：$L=1.0\\,\\mathrm{m}$，$N=400$，$u_{0}=1.0\\,\\mathrm{m/s}$，$\\mathrm{CFL}=0.5$，$T=1.0\\,\\mathrm{s}$，周期性边界。液体体积分数的初始条件：\n$$\n\\alpha_{\\ell}(x,0)=0.3+0.2\\exp\\!\\left(-\\frac{(x-0.5L)^{2}}{2(0.05L)^{2}}\\right),\n$$\n且 $\\alpha_{g}(x,0)=1-\\alpha_{\\ell}(x,0)$。密度：$\\rho_{\\ell}=800\\,\\mathrm{kg/m^3}$，$\\rho_{g}=1.2\\,\\mathrm{kg/m^3}$。\n- 案例 B（周期性，零速度，边界条件边缘情况）：$L=1.0\\,\\mathrm{m}$，$N=400$，$u_{0}=0.0\\,\\mathrm{m/s}$，$\\mathrm{CFL}=0.5$，$T=0.8\\,\\mathrm{s}$，周期性边界。初始条件：\n$$\n\\alpha_{\\ell}(x,0)=\\begin{cases}\n0.8,  x  0.5L,\\\\\n0.2,  x \\ge 0.5L,\n\\end{cases}\n$$\n且 $\\alpha_{g}(x,0)=1-\\alpha_{\\ell}(x,0)$。密度：$\\rho_{\\ell}=800\\,\\mathrm{kg/m^3}$，$\\rho_{g}=1.2\\,\\mathrm{kg/m^3}$。\n- 案例 C（周期性，扩展运行，平滑波）：$L=1.0\\,\\mathrm{m}$，$N=600$，$u_{0}=0.5\\,\\mathrm{m/s}$，$\\mathrm{CFL}=0.7$，$T=1.7\\,\\mathrm{s}$，周期性边界。初始条件：\n$$\n\\alpha_{\\ell}(x,0)=0.5+0.3\\cos\\!\\left(\\frac{2\\pi x}{L}\\right),\n$$\n截断到 $[0,1]$，且 $\\alpha_{g}(x,0)=1-\\alpha_{\\ell}(x,0)$。密度：$\\rho_{\\ell}=800\\,\\mathrm{kg/m^3}$，$\\rho_{g}=1.2\\,\\mathrm{kg/m^3}$。\n- 案例 D（入流-出流，恒定入流，平滑波）：$L=1.0\\,\\mathrm{m}$，$N=400$，$u_{0}=1.0\\,\\mathrm{m/s}$，$\\mathrm{CFL}=0.5$，$T=0.5\\,\\mathrm{s}$，$x=0$ 处为入流，$x=L$ 处为对流出流。液相的入流边界条件：$\\alpha_{\\ell,\\mathrm{in}}=0.3$；气相使用 $\\alpha_{g,\\mathrm{in}}=1-\\alpha_{\\ell,\\mathrm{in}}$。初始条件：\n$$\n\\alpha_{\\ell}(x,0)=0.5+0.3\\cos\\!\\left(\\frac{2\\pi x}{L}\\right),\n$$\n截断到 $[0,1]$，且 $\\alpha_{g}(x,0)=1-\\alpha_{\\ell}(x,0)$。密度：$\\rho_{\\ell}=800\\,\\mathrm{kg/m^3}$，$\\rho_{g}=1.2\\,\\mathrm{kg/m^3}$。\n\n需要强制执行的数值细节：\n- 对每个相使用一阶迎风通量。对于面心速度 $u_{f}=u_{0}$，在面 $f$ 处对一个通用对流标量 $a$ 的数值通量为 $F_{f}=u_{f} a_{\\text{upwind}}$，其中 $a_{\\text{upwind}}$ 根据 $u_{f}$ 的符号从迎风单元中取值。\n- 对于周期性边界，环绕索引；对于 $u_{0}>0$ 的入流-出流，在 $x=0$ 处施加指定的入流值，并通过迎风格式在 $x=L$ 处施加零梯度出流。\n- 根据给定的 $\\mathrm{CFL}$ 选择 $\\Delta t$，但如果 $|u_{0}|=0$，则设置一个单步 $\\Delta t=T$。\n\n最终输出格式：\n你的程序应产生一行输出，包含案例 A、B、C 和 D 的四个 $\\varepsilon_{\\max}$ 值，形式为用方括号括起来的逗号分隔列表（例如，$[e_{A},e_{B},e_{C},e_{D}]$）。每个 $e_{\\cdot}$ 必须是普通十进制表示的浮点数。不应打印任何额外文本。",
            "solution": "问题陈述经评估是有效的。它在科学上基于多相流体动力学原理，参数和条件完备，问题设定良好，并且表述客观。因此，我们可以进行推导和求解。\n\n### 第1部分：体积分数输运方程的推导\n\n欧拉-欧拉两流体模型描述了相互渗透的连续介质的动力学。在一维域中，对于一个通用相 $k$（其中 $k$ 可以是液相 $\\ell$ 或气相 $g$），其质量守恒定律由下式给出：\n$$\n\\frac{\\partial (\\alpha_k \\rho_k)}{\\partial t} + \\frac{\\partial (\\alpha_k \\rho_k u_k)}{\\partial x} = \\Gamma_k\n$$\n这里，$\\alpha_k(x,t)$ 是相 $k$ 的体积分数，$\\rho_k$ 是其内禀密度， $u_k(x,t)$ 是其速度，$\\Gamma_k$ 表示单位体积内从其他相进入相 $k$ 的净质量传递率。\n\n问题提供了一组简化假设，我们将其应用于这个普适定律：\n1.  **无相间质量传递**：对于液相和气相，质量源项均为零。因此，$\\Gamma_{\\ell} = \\Gamma_{g} = 0$。\n2.  **内禀密度恒定**：密度 $\\rho_{\\ell}$ 和 $\\rho_g$ 在整个域和时间上都是常数。\n3.  **无滑移速度**：两相都由相同的、外部指定的、均匀的速度场 $u(x,t) = u_0$ 输运，其中 $u_0$ 是一个常数。这意味着 $u_{\\ell} = u_g = u_0$。\n4.  **无其他源**：问题陈述指出两相均无体积源，这与 $\\Gamma_k=0$ 一致。\n\n将这些假设应用于液相（$k=\\ell$）的质量守恒方程，得到：\n$$\n\\frac{\\partial (\\alpha_{\\ell} \\rho_{\\ell})}{\\partial t} + \\frac{\\partial (\\alpha_{\\ell} \\rho_{\\ell} u_0)}{\\partial x} = 0\n$$\n由于密度 $\\rho_{\\ell}$ 是一个非零常数，它可以移到偏导数之外：\n$$\n\\rho_{\\ell} \\frac{\\partial \\alpha_{\\ell}}{\\partial t} + \\rho_{\\ell} \\frac{\\partial (\\alpha_{\\ell} u_0)}{\\partial x} = 0\n$$\n然后我们可以用常数 $\\rho_{\\ell}$ 除以整个方程：\n$$\n\\frac{\\partial \\alpha_{\\ell}}{\\partial t} + \\frac{\\partial (u_0 \\alpha_{\\ell})}{\\partial x} = 0\n$$\n这即是所要求的、守恒形式的液相体积分数 $\\alpha_{\\ell}(x,t)$ 的控制输运方程。它是一个具有恒定对流速度 $u_0$ 的线性对流方程。相关的通量函数是 $F(\\alpha_{\\ell}) = u_0 \\alpha_{\\ell}$。\n\n对气相（$k=g$）进行相同的推导，会得到相同形式的方程：\n$$\n\\frac{\\partial \\alpha_{g}}{\\partial t} + \\frac{\\partial (u_0 \\alpha_{g})}{\\partial x} = 0\n$$\n这些假设的一个关键结果是，**相密度 $\\rho_{\\ell}$ 和 $\\rho_g$ 不影响体积分数的输运**。它们从 $\\alpha_{\\ell}$ 和 $\\alpha_g$ 的控制方程中消掉了。\n\n问题陈述指出，在 $t=0$ 时，体积填充约束 $\\alpha_{\\ell}(x,0) + \\alpha_{g}(x,0) = 1$ 成立。让我们检验这个约束的演化。定义和 $S(x,t) = \\alpha_{\\ell}(x,t) + \\alpha_{g}(x,t)$。将两个推导出的输运方程相加，得到一个关于 $S(x,t)$ 的方程：\n$$\n\\left(\\frac{\\partial \\alpha_{\\ell}}{\\partial t} + \\frac{\\partial \\alpha_{g}}{\\partial t}\\right) + \\left(\\frac{\\partial (u_0 \\alpha_{\\ell})}{\\partial x} + \\frac{\\partial (u_0 \\alpha_{g})}{\\partial x}\\right) = 0\n$$\n$$\n\\frac{\\partial (\\alpha_{\\ell} + \\alpha_{g})}{\\partial t} + \\frac{\\partial (u_0 (\\alpha_{\\ell} + \\alpha_{g}))}{\\partial x} = 0\n$$\n$$\n\\frac{\\partial S}{\\partial t} + \\frac{\\partial (u_0 S)}{\\partial x} = 0\n$$\n这表明体积分数之和 $S$ 受相同的线性对流方程控制。由于初始条件是 $S(x,0) = 1$（一个常数场），并且所有测试案例中的边界条件都与此和一致（例如，$\\alpha_{\\ell,\\mathrm{in}} + \\alpha_{g,\\mathrm{in}} = 1$），所以精确的解析解是 $S(x,t) = 1$ 对所有时间 $t \\ge 0$ 成立。\n\n### 第2部分：数值格式与分析\n\n问题要求使用守恒的有限体积离散化。对于单元宽度为 $\\Delta x$ 的均匀网格，将一个通用变量 $a$ 的守恒定律在单元 $i$（从 $x_{i-1/2}$ 到 $x_{i+1/2}$）上积分，得到半离散形式：\n$$\n\\frac{d\\bar{a}_i}{dt} + \\frac{F_{i+1/2} - F_{i-1/2}}{\\Delta x} = 0\n$$\n其中 $\\bar{a}_i$ 是单元平均值，而 $F_{i\\pm1/2}$ 是单元界面处的数值通量。使用一阶显式欧拉时间积分，我们得到：\n$$\n\\bar{a}_i^{n+1} = \\bar{a}_i^n - \\frac{\\Delta t}{\\Delta x} (F_{i+1/2}^n - F_{i-1/2}^n)\n$$\n对于 $F(a) = u_0 a$ 的一阶迎风通量是 $F_{f} = u_0 a_{\\text{upwind}}$。\n- 如果 $u_0 > 0$，流向从左到右。界面 $i+1/2$ 的迎风值是 $\\bar{a}_i^n$。更新公式变为：\n$$\n\\bar{a}_i^{n+1} = \\bar{a}_i^n - \\frac{u_0 \\Delta t}{\\Delta x} (\\bar{a}_i^n - \\bar{a}_{i-1}^n) = (1-C) \\bar{a}_i^n + C \\bar{a}_{i-1}^n\n$$\n其中 $C = u_0 \\Delta t / \\Delta x$ 是库朗数，在问题中被指定为 $\\mathrm{CFL}$。\n- 如果 $u_0  0$，流向从右到左。界面 $i+1/2$ 的迎风值是 $\\bar{a}_{i+1}^n$。更新公式变为：\n$$\n\\bar{a}_i^{n+1} = \\bar{a}_i^n - \\frac{u_0 \\Delta t}{\\Delta x} (\\bar{a}_{i+1}^n - \\bar{a}_i^n) = (1+C') \\bar{a}_i^n - C' \\bar{a}_{i+1}^n\n$$\n其中 $C' = u_0 \\Delta t / \\Delta x  0$。令 $C = |u_0| \\Delta t / \\Delta x = \\mathrm{CFL}$。那么 $C' = -C$，所以更新公式是 $(1-C)\\bar{a}_i^n + C\\bar{a}_{i+1}^n$。\n在这两种情况下，对于库朗数 $C \\in [0, 1]$，更新后的值是相邻单元值的凸组合。这个性质确保了该格式是单调的：如果时间 $n$ 的解是有界的（例如，$0 \\le \\bar{a}_i^n \\le 1$），那么在截断之前，时间 $n+1$ 的解也将保持在这些界限内。由于测试案例中所有的 CFL 值都 $\\le 1$，原则上，截断到 $[0,1]$ 的操作不应由数值格式本身的过冲或下冲触发。\n\n问题要求独立演化 $\\alpha_{\\ell}$ 和 $\\alpha_g$。由于数值格式是线性的（在截断之前）并且已被证明能完美地保持一个常数为 $1$ 的场，任何计算出的 $\\varepsilon_{\\max} = \\max_x |\\alpha_{\\ell}(x,T) + \\alpha_{g}(x,T) - 1|$ 大于零的值都必须源于模拟过程中浮点舍入误差的累积。对于 $u_0=0$ 的特殊情况，通量为零，解不演化，初始约束 $\\alpha_{\\ell}+\\alpha_g=1$ 被完美保持，因此预期误差为 $\\varepsilon_{\\max}=0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n\n    def run_simulation(L, N, u0, CFL, T, ic_l_func, bc_type, **kwargs):\n        \"\"\"\n        Runs a single simulation case for the 1D advection equation.\n        \"\"\"\n        dx = L / N\n        x_centers = np.linspace(dx / 2.0, L - dx / 2.0, N)\n\n        # Initial conditions\n        alpha_l = ic_l_func(x_centers, L)\n        # Clip initial condition if necessary as per problem spec (Cases C  D)\n        alpha_l = np.clip(alpha_l, 0.0, 1.0)\n        # Define alpha_g based on the (potentially clipped) alpha_l\n        alpha_g = 1.0 - alpha_l\n\n        # Handle the zero-velocity case\n        if u0 == 0.0:\n            # Per instructions, take one step of size T. With u0=0, the state does not change.\n            # Clipping is applied, but ICs are already in [0,1].\n            alpha_l_final = np.clip(alpha_l, 0.0, 1.0)\n            alpha_g_final = np.clip(alpha_g, 0.0, 1.0)\n            max_error = np.max(np.abs(alpha_l_final + alpha_g_final - 1.0))\n            return max_error\n        \n        dt = CFL * dx / abs(u0)\n        t = 0.0\n        \n        while t  T:\n            current_dt = min(dt, T - t)\n            # Recalculate courant for the current step, important if dt is adjusted at the end\n            courant_val = u0 * current_dt / dx\n            \n            # Evolve alpha_l independently\n            if u0 > 0:\n                alpha_l_upwind = np.roll(alpha_l, 1)\n                if bc_type == 'inflow-outflow':\n                    alpha_l_upwind[0] = kwargs['alpha_l_in']\n                alpha_l_new = alpha_l - courant_val * (alpha_l - alpha_l_upwind)\n            else:  # u0  0\n                alpha_l_upwind = np.roll(alpha_l, -1)\n                # Note: Inflow-outflow for u0  0 not tested, but would be:\n                # if bc_type == 'inflow-outflow':\n                #    alpha_l_upwind[-1] = kwargs['alpha_l_in']\n                alpha_l_new = alpha_l - courant_val * (alpha_l_upwind - alpha_l)\n            \n            # Evolve alpha_g independently\n            if u0 > 0:\n                alpha_g_upwind = np.roll(alpha_g, 1)\n                if bc_type == 'inflow-outflow':\n                    alpha_g_upwind[0] = kwargs['alpha_g_in']\n                alpha_g_new = alpha_g - courant_val * (alpha_g - alpha_g_upwind)\n            else:  # u0  0\n                alpha_g_upwind = np.roll(alpha_g, -1)\n                # Note: Inflow-outflow for u0  0 not tested\n                alpha_g_new = alpha_g - courant_val * (alpha_g_upwind - alpha_g)\n                \n            alpha_l = alpha_l_new\n            alpha_g = alpha_g_new\n\n            # Clip after each time step as per instructions\n            alpha_l = np.clip(alpha_l, 0.0, 1.0)\n            alpha_g = np.clip(alpha_g, 0.0, 1.0)\n            \n            t += current_dt\n\n        max_error = np.max(np.abs(alpha_l + alpha_g - 1.0))\n        return max_error\n\n    # Define test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"L\": 1.0, \"N\": 400, \"u0\": 1.0, \"CFL\": 0.5, \"T\": 1.0,\n            \"ic_l_func\": lambda x, L: 0.3 + 0.2 * np.exp(-(x - 0.5 * L)**2 / (2 * (0.05 * L)**2)),\n            \"bc_type\": \"periodic\",\n            \"rho_l\": 800.0, \"rho_g\": 1.2\n        },\n        {\n            \"name\": \"B\",\n            \"L\": 1.0, \"N\": 400, \"u0\": 0.0, \"CFL\": 0.5, \"T\": 0.8,\n            \"ic_l_func\": lambda x, L: np.where(x  0.5 * L, 0.8, 0.2),\n            \"bc_type\": \"periodic\",\n            \"rho_l\": 800.0, \"rho_g\": 1.2\n        },\n        {\n            \"name\": \"C\",\n            \"L\": 1.0, \"N\": 600, \"u0\": 0.5, \"CFL\": 0.7, \"T\": 1.7,\n            \"ic_l_func\": lambda x, L: 0.5 + 0.3 * np.cos(2 * np.pi * x / L),\n            \"bc_type\": \"periodic\",\n            \"rho_l\": 800.0, \"rho_g\": 1.2\n        },\n        {\n            \"name\": \"D\",\n            \"L\": 1.0, \"N\": 400, \"u0\": 1.0, \"CFL\": 0.5, \"T\": 0.5,\n            \"ic_l_func\": lambda x, L: 0.5 + 0.3 * np.cos(2 * np.pi * x / L),\n            \"bc_type\": \"inflow-outflow\",\n            \"alpha_l_in\": 0.3,\n            \"alpha_g_in\": 0.7,\n            \"rho_l\": 800.0, \"rho_g\": 1.2\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack case parameters, removing 'name' before passing to solver\n        params = case.copy()\n        del params['name']\n        result = run_simulation(**params)\n        results.append(result)\n    \n    # Format output as a list of floating-point numbers in plain decimal notation\n    formatted_results = [f\"{r:.18f}\".rstrip('0').rstrip('.') for r in results]\n    # Special handling for case B which should be exactly 0\n    if results[1] == 0.0:\n        formatted_results[1] = \"0.0\"\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了体积分数输运后，下一步是模拟相间的相互作用。本实践聚焦于相间动量交换，它决定了液滴如何响应周围的气体流动。您将从第一性原理出发，推导滑移松弛时间 $\\tau_p$，从而在单颗粒曳力物理学与双流体模型中使用的体积平均参数之间建立桥梁。计算斯托克斯数 $St$ 将为您提供一个强大的工具，用以表征喷雾的行为特性——即液滴是由惯性主导，还是能忠实地跟随气相湍流 。",
            "id": "4023923",
            "problem": "在计算燃烧学中，考虑一个使用欧拉-欧拉两流体框架建模的单分散喷雾，其中相间动量交换由一个与滑移速度成正比的线性曳力表示。从第一性原理出发，推导在低颗粒雷诺数条件下液相的滑移松弛时间。具体来说，从单个球形液滴的牛顿第二定律、斯托克斯曳力定律以及用体积分数表示的数密度的定义开始。利用这些来获得单位体积的相间动量交换系数，然后得到特征滑移松弛时间。\n\n假设一个稀疏的单分散喷雾，其体积分数为 $ \\alpha_{\\ell} $，液滴直径为 $ d_p $，悬浮在密度为 $ \\rho_g $、动力粘度为 $ \\mu_g $ 的气体中。液体密度为 $ \\rho_{\\ell} $。在体积平均的液相动量方程中，气-液相间动量交换被建模为 $ \\beta ( \\boldsymbol{u}_g - \\boldsymbol{u}_{\\ell} ) $，其中 $ \\beta $ 是单位体积的相间动量交换系数。假设颗粒雷诺数（定义为 $ Re_p = \\rho_g d_p | \\boldsymbol{u}_g - \\boldsymbol{u}_{\\ell} | / \\mu_g $）足够小，使得斯托克斯曳力定律适用，并忽略附加质量力、Basset历史力和升力。\n\n给定参数 $ \\alpha_{\\ell} = 1.0 \\times 10^{-3} $，$ d_p = 20\\,\\mu\\mathrm{m} $，$ \\rho_g = 1.2\\,\\mathrm{kg/m^3} $，$ \\mu_g = 1.8 \\times 10^{-5}\\,\\mathrm{Pa \\cdot s} $ 以及 $ \\rho_{\\ell} = 800\\,\\mathrm{kg/m^3} $，对于指定的剪切时间尺度 $ \\tau_{\\mathrm{flow}} = 2.0 \\times 10^{-3}\\,\\mathrm{s} $，根据 $ \\beta $ 计算滑移松弛时间 $ \\tau_p $，然后计算斯托克斯数 $ St = \\tau_p / \\tau_{\\mathrm{flow}} $。使用低雷诺数（斯托克斯）区域从第一性原理推导 $ \\beta $ 和 $ \\tau_p $，并假设 $ \\alpha_{\\ell} $ 的单分散性和空间均匀性。\n\n最后，将斯托克斯数 $ St $ 作为你的最终答案。将你的答案四舍五入到四位有效数字。最终答案不带单位。",
            "solution": "该问题是有效的，因为它科学地基于多相流体动力学的原理，问题提出得很好，有足够的信息得到唯一解，并且使用标准术语进行了客观陈述。\n\n主要目标是推导滑移松弛时间 $\\tau_p$，然后计算斯托克斯数 $St$。推导必须从第一性原理开始，将单个液滴的动力学与欧拉-欧拉两流体模型的体积平均公式联系起来。\n\n首先，我们考虑单个、孤立的球形液滴在静止气体中的运动。根据牛顿第二定律，液滴动量的变化率等于作用在其上的合力。忽略除曳力之外的所有力，这可以表示为：\n$$ m_p \\frac{d\\boldsymbol{u}_{\\ell}}{dt} = \\boldsymbol{F}_D $$\n其中 $m_p$ 是液滴的质量，$\\boldsymbol{u}_{\\ell}$ 是液滴的速度，$\\boldsymbol{F}_D$ 是气体施加的曳力。\n\n直径为 $d_p$、密度为 $\\rho_{\\ell}$ 的球形液滴的质量由下式给出：\n$$ m_p = \\rho_{\\ell} V_p = \\rho_{\\ell} \\left( \\frac{\\pi}{6} d_p^3 \\right) $$\n其中 $V_p$ 是液滴的体积。\n\n问题指明颗粒雷诺数 $Re_p$ 很低，这证明了使用斯托克斯曳力定律的合理性。作用在液滴上的曳力为：\n$$ \\boldsymbol{F}_D = 3 \\pi \\mu_g d_p (\\boldsymbol{u}_g - \\boldsymbol{u}_{\\ell}) $$\n其中 $\\mu_g$ 是气体的动力粘度，$(\\boldsymbol{u}_g - \\boldsymbol{u}_{\\ell})$ 是气相和液相之间的滑移速度。\n\n将 $m_p$ 和 $\\boldsymbol{F}_D$ 的表达式代入牛顿第二定律，得到：\n$$ \\rho_{\\ell} \\left( \\frac{\\pi}{6} d_p^3 \\right) \\frac{d\\boldsymbol{u}_{\\ell}}{dt} = 3 \\pi \\mu_g d_p (\\boldsymbol{u}_g - \\boldsymbol{u}_{\\ell}) $$\n这个方程可以重新整理，以描述液滴速度向气体速度松弛的过程：\n$$ \\frac{d\\boldsymbol{u}_{\\ell}}{dt} = \\frac{3 \\pi \\mu_g d_p}{\\rho_{\\ell} (\\frac{\\pi}{6} d_p^3)} (\\boldsymbol{u}_g - \\boldsymbol{u}_{\\ell}) $$\n$$ \\frac{d\\boldsymbol{u}_{\\ell}}{dt} = \\frac{18 \\mu_g}{\\rho_{\\ell} d_p^2} (\\boldsymbol{u}_g - \\boldsymbol{u}_{\\ell}) $$\n该方程的形式为 $\\frac{d\\boldsymbol{u}_{\\ell}}{dt} = \\frac{1}{\\tau_p}(\\boldsymbol{u}_g - \\boldsymbol{u}_{\\ell})$，其中 $\\tau_p$ 是特征颗粒松弛时间。通过比较，我们确定单个颗粒的松弛时间为：\n$$ \\tau_p = \\frac{\\rho_{\\ell} d_p^2}{18 \\mu_g} $$\n这个表达式给出了液滴速度调整到周围流体速度所需的时间尺度。\n\n接下来，我们从单个液滴（拉格朗日）的视角转换到体积平均（欧拉）的两流体模型。在这个框架中，相间动量交换在动量守恒方程中表示为一个源项。气体对液相施加的总曳力，按混合物的单位体积计，$\\boldsymbol{M}_{\\ell}$，是单个颗粒上的力乘以单位体积内的颗粒数 $n_p$：\n$$ \\boldsymbol{M}_{\\ell} = n_p \\boldsymbol{F}_D = n_p \\left[ 3 \\pi \\mu_g d_p (\\boldsymbol{u}_g - \\boldsymbol{u}_{\\ell}) \\right] $$\n问题陈述此相间动量交换被建模为 $\\beta (\\boldsymbol{u}_g - \\boldsymbol{u}_{\\ell})$。因此，单位体积的相间动量交换系数 $\\beta$ 为：\n$$ \\beta = 3 \\pi n_p \\mu_g d_p $$\n数密度 $n_p$ 可以与液体体积分数 $\\alpha_{\\ell}$ 相关联。对于单分散喷雾，$\\alpha_{\\ell}$ 是数密度与单个颗粒体积的乘积：\n$$ \\alpha_{\\ell} = n_p V_p = n_p \\left( \\frac{\\pi}{6} d_p^3 \\right) $$\n求解 $n_p$：\n$$ n_p = \\frac{6 \\alpha_{\\ell}}{\\pi d_p^3} $$\n将 $n_p$ 的这个表达式代入 $\\beta$ 的方程中：\n$$ \\beta = 3 \\pi \\left( \\frac{6 \\alpha_{\\ell}}{\\pi d_p^3} \\right) \\mu_g d_p = \\frac{18 \\alpha_{\\ell} \\mu_g}{d_p^2} $$\n这是从第一性原理推导出的相间动量交换系数的表达式。\n\n问题要求我们从 $\\beta$ 计算滑移松弛时间 $\\tau_p$。在平均液相动量方程的背景下，曳力项表现为 $\\beta(\\boldsymbol{u}_g - \\boldsymbol{u}_{\\ell})$。仅考虑质量和曳力，方程为：\n$$ \\frac{D}{Dt}(\\alpha_{\\ell} \\rho_{\\ell} \\boldsymbol{u}_{\\ell}) = \\beta (\\boldsymbol{u}_g - \\boldsymbol{u}_{\\ell}) $$\n假设 $\\alpha_{\\ell}$ 和 $\\rho_{\\ell}$ 是常数，左侧简化为 $\\alpha_{\\ell} \\rho_{\\ell} \\frac{D\\boldsymbol{u}_{\\ell}}{Dt}$。液相加速度的方程变为：\n$$ \\frac{D\\boldsymbol{u}_{\\ell}}{Dt} = \\frac{\\beta}{\\alpha_{\\ell} \\rho_{\\ell}} (\\boldsymbol{u}_g - \\boldsymbol{u}_{\\ell}) $$\n将其与单颗粒方程形式 $\\frac{D\\boldsymbol{u}_{\\ell}}{Dt} = \\frac{1}{\\tau_p}(\\boldsymbol{u}_g - \\boldsymbol{u}_{\\ell})$ 进行比较，我们定义两流体模型中的滑移松弛时间为：\n$$ \\tau_p = \\frac{\\alpha_{\\ell} \\rho_{\\ell}}{\\beta} $$\n代入我们推导出的 $\\beta$ 表达式，可以证实该框架的一致性：\n$$ \\tau_p = \\frac{\\alpha_{\\ell} \\rho_{\\ell}}{\\frac{18 \\alpha_{\\ell} \\mu_g}{d_p^2}} = \\frac{\\alpha_{\\ell} \\rho_{\\ell} d_p^2}{18 \\alpha_{\\ell} \\mu_g} = \\frac{\\rho_{\\ell} d_p^2}{18 \\mu_g} $$\n这个结果与单个颗粒的松弛时间相同，表明对于斯托克斯区域中的稀疏喷雾，松弛时间是颗粒-流体系统的内在属性，与颗粒浓度 $\\alpha_{\\ell}$ 无关。\n\n现在我们可以进行数值计算。给定的参数是：\n$\\rho_{\\ell} = 800\\,\\mathrm{kg/m^3}$\n$d_p = 20\\,\\mu\\mathrm{m} = 2.0 \\times 10^{-5}\\,\\mathrm{m}$\n$\\mu_g = 1.8 \\times 10^{-5}\\,\\mathrm{Pa \\cdot s}$\n$\\tau_{\\mathrm{flow}} = 2.0 \\times 10^{-3}\\,\\mathrm{s}$\n\n首先，我们计算滑移松弛时间 $\\tau_p$：\n$$ \\tau_p = \\frac{\\rho_{\\ell} d_p^2}{18 \\mu_g} = \\frac{(800) \\times (2.0 \\times 10^{-5})^2}{18 \\times (1.8 \\times 10^{-5})} $$\n$$ \\tau_p = \\frac{800 \\times 4.0 \\times 10^{-10}}{32.4 \\times 10^{-5}} = \\frac{3.2 \\times 10^{-7}}{3.24 \\times 10^{-4}} $$\n$$ \\tau_p \\approx 0.987654 \\times 10^{-3}\\,\\mathrm{s} $$\n最后，我们计算斯托克斯数 $St$，它是颗粒松弛时间与特征流动时间尺度的比值：\n$$ St = \\frac{\\tau_p}{\\tau_{\\mathrm{flow}}} = \\frac{0.987654 \\times 10^{-3}\\,\\mathrm{s}}{2.0 \\times 10^{-3}\\,\\mathrm{s}} $$\n$$ St \\approx 0.493827 $$\n根据要求将结果四舍五入到四位有效数字，我们得到：\n$$ St \\approx 0.4938 $$\n计算 $\\tau_p$ 或 $St$ 并不需要 $\\rho_g$ 和 $\\alpha_{\\ell}$ 的值，但它们是作为完整问题描述的一部分提供的，并且是推导 $\\beta$ 表达式这一中间步骤所必需的。",
            "answer": "$$\\boxed{0.4938}$$"
        },
        {
            "introduction": "对于燃烧系统中的喷雾，通过蒸发实现的相间质量传递是一个关键过程。本练习超越了动量范畴，旨在探索这些质量源项的建模与验证。您将面临一项计算科学家的挑战：开发一个数值诊断工具，以验证跨相质量守恒 。这项实践强调了计算流体动力学（CFD）的一个关键方面：确保源项 $\\Gamma_\\ell$ 的数值实现与最终得到的组分场相一致，这是构建可靠、具有预测能力的模拟工具的基础。",
            "id": "4023901",
            "problem": "考虑喷雾的欧拉-欧拉（EE）双流体模型中的一维稳态管道流，其中气相携带由分散液相的相间传质形成的蒸气组分。从液相到气相的相间质量源项用 $\\Gamma_\\ell(x)$ 表示，单位为 $\\mathrm{kg \\cdot m^{-3} \\cdot s^{-1}}$。气相具有恒定的密度 $\\rho_g$（单位 $\\mathrm{kg \\cdot m^{-3}}$）、恒定的轴向速度 $u_g$（单位 $\\mathrm{m \\cdot s^{-1}}$）以及蒸气组分的恒定二元扩散系数 $D$（单位 $\\mathrm{m^2 \\cdot s^{-1}}$）。管道长度为 $L$（单位 $\\mathrm{m}$），横截面积均匀为 $A$（单位 $\\mathrm{m^2}$）。气体中蒸气的质量分数是 $Y_v(x)$（无量纲），沿轴向坐标 $x\\in[0,L]$ 变化。\n\n从蒸气的稳态一维组分输运方程和 Fick 扩散定律出发，\n$$\n\\frac{d}{dx}\\Big(\\rho_g\\,u_g\\,Y_v(x)-\\rho_g\\,D\\,\\frac{dY_v}{dx}(x)\\Big)=\\Gamma_\\ell(x),\n$$\n对给定的模型化 $\\Gamma_\\ell(x)$，建立并实现一个诊断程序，该程序通过对管道体积积分组分输运方程来推断总蒸气产量，并检查 $\\Gamma_\\ell(x)$ 与其的一致性。具体来说，将一致性误差 $e$ 定义为模型化的总相间质量源（体积积分的 $\\Gamma_\\ell$）与通过积分组分方程得到的总蒸气产量之间的相对差异。误差 $e$ 必须是一个无量纲的小数。当基于组分的总蒸气产量在数值上为零时，在分母中使用一个小的正则化项 $\\delta$（单位 $\\mathrm{kg \\cdot s^{-1}}$）以避免除以零。\n\n您的程序必须：\n- 在 $x\\in[0,L]$ 上使用包含 $N=1001$ 个点的均匀网格。\n- 在内部点使用二阶中心差分，在 $x=0$ 和 $x=L$ 处使用一阶单边差分来近似 $\\frac{dY_v}{dx}$。\n- 计算组分通量 $F(x)=\\rho_g\\,u_g\\,Y_v(x)-\\rho_g\\,D\\,\\frac{dY_v}{dx}(x)$，并通过对管道体积积分组分方程，用它来获得基于组分的总蒸气产量。\n- 使用梯形法则对管道体积积分 $\\Gamma_\\ell(x)$ 来计算模型化的总相间质量源。\n- 报告每个测试案例的一致性误差 $e$，其中 $\\delta=10^{-12}\\ \\mathrm{kg \\cdot s^{-1}}$。\n\n单位：\n- $\\rho_g$ 的单位为 $\\mathrm{kg \\cdot m^{-3}}$，$u_g$ 为 $\\mathrm{m \\cdot s^{-1}}$，$D$ 为 $\\mathrm{m^2 \\cdot s^{-1}}$，$L$ 为 $\\mathrm{m}$，$A$ 为 $\\mathrm{m^2}$，$\\Gamma_\\ell$ 为 $\\mathrm{kg \\cdot m^{-3} \\cdot s^{-1}}$，总产量的单位为 $\\mathrm{kg \\cdot s^{-1}}$。\n- 最终误差 $e$ 表示为无量纲小数，并四舍五入到六位小数。\n\n测试套件：\n- 案例1（基线一致性）：\n  - $L=1\\ \\mathrm{m}$, $A=0.01\\ \\mathrm{m^2}$, $\\rho_g=1.2\\ \\mathrm{kg \\cdot m^{-3}}$, $u_g=5\\ \\mathrm{m \\cdot s^{-1}}$, $D=2\\times 10^{-5}\\ \\mathrm{m^2 \\cdot s^{-1}}$.\n  - $Y_v(x)=Y_0+\\alpha x$, with $Y_0=0.05$ and $\\alpha=0.02$.\n  - 模型化的 $\\Gamma_\\ell(x)$ 被选择为与给定 $Y_v(x)$ 和参数的稳态组分输运方程完全一致。\n- 案例2（有偏差的相间源）：\n  - 与案例1相同的 $L$、$A$、$\\rho_g$、$u_g$、$D$ 和 $Y_v(x)$。\n  - 模型化的 $\\Gamma_\\ell(x)$ 等于与组分一致的值乘以 $s$，其中 $s=1.2$。\n- 案例3（零产量）：\n  - $L=0.5\\ \\mathrm{m}$, $A=0.02\\ \\mathrm{m^2}$, $\\rho_g=0.9\\ \\mathrm{kg \\cdot m^{-3}}$, $u_g=3\\ \\mathrm{m \\cdot s^{-1}}$, $D=10^{-5}\\ \\mathrm{m^2 \\cdot s^{-1}}$.\n  - $Y_v(x)=Y_c$ 为常数，其中 $Y_c=0.1$。\n  - 模型化的 $\\Gamma_\\ell(x)=0$。\n- 案例4（仅扩散且带偏移不一致性）：\n  - $L=1\\ \\mathrm{m}$, $A=0.01\\ \\mathrm{m^2}$, $\\rho_g=1.0\\ \\mathrm{kg \\cdot m^{-3}}$, $u_g=0\\ \\mathrm{m \\cdot s^{-1}}$, $D=10^{-4}\\ \\mathrm{m^2 \\cdot s^{-1}}$.\n  - $Y_v(x)=Y_0+\\beta\\sin\\left(\\frac{2\\pi x}{L}\\right)$, with $Y_0=0.2$ and $\\beta=0.05$.\n  - 模型化的 $\\Gamma_\\ell(x)$ 等于与组分一致的值加上一个恒定的偏移量 $\\Delta\\Gamma$，其中 $\\Delta\\Gamma=10^{-5}\\ \\mathrm{kg \\cdot m^{-3} \\cdot s^{-1}}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个测试案例的一致性误差，格式为逗号分隔的列表并用方括号括起来，每个数字四舍五入到六位小数（例如，$[0.000000, 0.123456, 0.000001, 10.000000]$）。不应打印任何其他文本。",
            "solution": "该问题要求在喷雾的稳态一维欧拉-欧拉模型框架内，建立并实现一个诊断程序，以检查模型化的相间质量源 $\\Gamma_\\ell(x)$ 的一致性。该诊断程序是一个误差度量 $e$，定义为在长度为 $L$、横截面积为 $A$ 的管道中，计算总蒸气产生率的两种方法之间的相对差异。\n\n此分析的基本原理是气相中蒸气组分的质量守恒。控制方程以微分形式给出：\n$$\n\\frac{d}{dx}\\Big(\\rho_g\\,u_g\\,Y_v(x)-\\rho_g\\,D\\,\\frac{dY_v}{dx}(x)\\Big)=\\Gamma_\\ell(x)\n$$\n此处，$Y_v(x)$ 是蒸气质量分数，$\\rho_g$ 是气体密度，$u_g$ 是气体速度，$D$ 是二元扩散系数。左侧导数内的项是蒸气组分的总质量通量 $F(x)$，它由一个对流分量和一个扩散分量（Fick 定律）组成：\n$$\nF(x) = \\rho_g\\,u_g\\,Y_v(x) - \\rho_g\\,D\\,\\frac{dY_v}{dx}(x)\n$$\n因此，控制方程可以紧凑地写为 $\\frac{dF(x)}{dx} = \\Gamma_\\ell(x)$。\n\n计算总蒸气产生率的第一种方法，我们称之为“基于组分的”产量 $\\dot{m}_{v,\\text{species}}$，是通过在整个管道体积 $V = A \\cdot L$ 上对控制方程进行积分得出的。\n$$\n\\int_V \\Gamma_\\ell(x) \\,dV = \\int_0^L \\Gamma_\\ell(x) A \\,dx\n$$\n代入 $\\Gamma_\\ell(x) = \\frac{dF(x)}{dx}$：\n$$\n\\dot{m}_{v,\\text{species}} = \\int_0^L A \\frac{dF(x)}{dx} \\,dx\n$$\n根据微积分基本定理，此积分的计算结果为穿过区域边界的净通量：\n$$\n\\dot{m}_{v,\\text{species}} = A \\left[ F(x) \\right]_0^L = A \\left( F(L) - F(0) \\right)\n$$\n这个量代表了维持给定稳态组分剖面 $Y_v(x)$ 所需的总质量生产率（单位为 $\\mathrm{kg \\cdot s^{-1}}$）。\n\n第二种方法涉及将“模型化的”相间源项 $\\Gamma_\\ell(x)$ 直接在管道体积上积分。这个模型化的生产率 $\\dot{m}_{v,\\text{model}}$ 由以下公式给出：\n$$\n\\dot{m}_{v,\\text{model}} = \\int_V \\Gamma_\\ell(x) \\,dV = A \\int_0^L \\Gamma_\\ell(x) \\,dx\n$$\n对于一个完全一致的模型，$\\dot{m}_{v,\\text{species}}$ 必须等于 $\\dot{m}_{v,\\text{model}}$。任何差异都表明模型化的源项与由此产生的组分场之间存在不一致。\n\n一致性误差 $e$ 定义为这两个量之间的相对差异：\n$$\ne = \\frac{|\\dot{m}_{v,\\text{model}} - \\dot{m}_{v,\\text{species}}|}{\\max(|\\dot{m}_{v,\\text{species}}|, \\delta)}\n$$\n其中 $\\delta$ 是一个小的正则化参数（给定为 $10^{-12}\\,\\mathrm{kg \\cdot s^{-1}}$），用于在基于组分的产量为零时防止除以零。\n\n为了在数值上实现这个诊断程序，我们遵循以下步骤：\n$1$. 将空间域 $x \\in [0, L]$ 离散化为一个包含 $N=1001$ 个点的均匀网格 $x_i$，其中 $i=0, 1, \\dots, N-1$，间距为 $\\Delta x = L/(N-1)$。\n$2$. 在每个网格点上计算给定的蒸气质量分数剖面 $Y_v(x)$，以获得数组 $Y_{v,i} = Y_v(x_i)$。\n$3$. 在每个网格点上计算数值梯度 $\\frac{dY_v}{dx}$。根据规定，我们使用：\n   - 在入口处（$x_0=0$）使用一阶向前差分：$\\left(\\frac{dY_v}{dx}\\right)_0 \\approx \\frac{Y_{v,1} - Y_{v,0}}{\\Delta x}$。\n   - 在出口处（$x_{N-1}=L$）使用一阶向后差分：$\\left(\\frac{dY_v}{dx}\\right)_{N-1} \\approx \\frac{Y_{v,N-1} - Y_{v,N-2}}{\\Delta x}$。\n   - 对所有内部点（$i=1, \\dots, N-2$）使用二阶中心差分：$\\left(\\frac{dY_v}{dx}\\right)_i \\approx \\frac{Y_{v,i+1} - Y_{v,i-1}}{2\\Delta x}$。\n$4$. 使用边界通量计算 $\\dot{m}_{v,\\text{species}}$：\n   $$\n   \\dot{m}_{v,\\text{species}} = A \\left[ \\left(\\rho_g u_g Y_{v,N-1} - \\rho_g D \\left(\\frac{dY_v}{dx}\\right)_{N-1}\\right) - \\left(\\rho_g u_g Y_{v,0} - \\rho_g D \\left(\\frac{dY_v}{dx}\\right)_{0}\\right) \\right]\n   $$\n$5$. 对于每个测试案例，在每个网格点上确定模型化的源项 $\\Gamma_\\ell(x_i)$。这需要首先通过对通量 $F(x)$ 进行解析微分来找到“完全一致的”源项 $\\Gamma_{\\ell,\\text{consistent}}(x)$：\n   $$\n   \\Gamma_{\\ell,\\text{consistent}}(x) = \\frac{dF(x)}{dx} = \\rho_g u_g \\frac{dY_v}{dx} - \\rho_g D \\frac{d^2Y_v}{dx^2}\n   $$\n   对于每个案例，使用给定的 $Y_v(x)$ 剖面的解析一阶和二阶导数来定义 $\\Gamma_{\\ell,\\text{consistent}}(x)$，然后根据案例描述（例如，缩放或平移）对其进行修改以获得模型化的 $\\Gamma_\\ell(x)$。\n$6$. 使用梯形法则对模型化源项数组 $\\Gamma_{\\ell,i}$ 进行数值积分，并乘以面积 $A$，来计算 $\\dot{m}_{v,\\text{model}}$：\n   $$\n   \\dot{m}_{v,\\text{model}} = A \\cdot \\sum_{i=0}^{N-2} \\frac{\\Gamma_{\\ell,i} + \\Gamma_{\\ell,i+1}}{2} \\Delta x\n   $$\n$7$. 最后，使用提供的公式计算误差 $e$。对每个测试案例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef compute_consistency_error(\n    L, A, rho_g, u_g, D, Yv_func, dYv_dx_func, d2Yv_dx2_func, gamma_modifier_func\n):\n    \"\"\"\n    Computes the consistency error for a single test case.\n\n    Args:\n        L (float): Duct length [m].\n        A (float): Duct cross-sectional area [m^2].\n        rho_g (float): Gas density [kg/m^3].\n        u_g (float): Gas velocity [m/s].\n        D (float): Binary diffusion coefficient [m^2/s].\n        Yv_func (function): Function for Y_v(x).\n        dYv_dx_func (function): Function for the first derivative of Y_v(x).\n        d2Yv_dx2_func (function): Function for the second derivative of Y_v(x).\n        gamma_modifier_func (function): Function to modify the consistent Gamma_l.\n\n    Returns:\n        float: The dimensionless consistency error, e.\n    \"\"\"\n    N = 1001\n    delta = 1e-12  # kg/s\n\n    # 1. Create grid and evaluate Y_v\n    x = np.linspace(0.0, L, N)\n    dx = x[1] - x[0]\n    Yv_grid = Yv_func(x)\n\n    # 2. Compute numerical derivative of Y_v\n    dYv_dx_grid = np.zeros_like(x)\n    # First-order forward difference at x=0\n    dYv_dx_grid[0] = (Yv_grid[1] - Yv_grid[0]) / dx\n    # First-order backward difference at x=L\n    dYv_dx_grid[-1] = (Yv_grid[-1] - Yv_grid[-2]) / dx\n    # Second-order central difference for interior points\n    dYv_dx_grid[1:-1] = (Yv_grid[2:] - Yv_grid[:-2]) / (2 * dx)\n\n    # 3. Calculate species-based total production rate\n    F_0 = rho_g * u_g * Yv_grid[0] - rho_g * D * dYv_dx_grid[0]\n    F_L = rho_g * u_g * Yv_grid[-1] - rho_g * D * dYv_dx_grid[-1]\n    m_dot_species = A * (F_L - F_0)\n\n    # 4. Calculate modeled total production rate\n    # 4a. Find the analytically consistent Gamma_l(x)\n    dYv_dx_analytical = dYv_dx_func(x)\n    d2Yv_dx2_analytical = d2Yv_dx2_func(x)\n    gamma_consistent = (\n        rho_g * u_g * dYv_dx_analytical - rho_g * D * d2Yv_dx2_analytical\n    )\n    \n    # 4b. Apply the case-specific modification to get the modeled Gamma_l\n    gamma_modeled = gamma_modifier_func(gamma_consistent)\n\n    # 4c. Integrate modeled Gamma_l over volume using trapezoidal rule\n    integral_gamma = np.trapz(gamma_modeled, x)\n    m_dot_model = A * integral_gamma\n\n    # 5. Compute the consistency error\n    numerator = abs(m_dot_model - m_dot_species)\n    denominator = max(abs(m_dot_species), delta)\n    error = numerator / denominator\n    \n    return error\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Define test cases based on the problem statement\n    \n    # Case 1: Baseline consistency\n    Y0_1, alpha_1 = 0.05, 0.02\n    case1_params = {\n        'L': 1.0, 'A': 0.01, 'rho_g': 1.2, 'u_g': 5.0, 'D': 2e-5,\n        'Yv_func': lambda x: Y0_1 + alpha_1 * x,\n        'dYv_dx_func': lambda x: np.full_like(x, alpha_1),\n        'd2Yv_dx2_func': lambda x: np.zeros_like(x),\n        'gamma_modifier_func': lambda g: g # Identity\n    }\n\n    # Case 2: Biased interphase source\n    s = 1.2\n    case2_params = {\n        'L': 1.0, 'A': 0.01, 'rho_g': 1.2, 'u_g': 5.0, 'D': 2e-5,\n        'Yv_func': lambda x: Y0_1 + alpha_1 * x,\n        'dYv_dx_func': lambda x: np.full_like(x, alpha_1),\n        'd2Yv_dx2_func': lambda x: np.zeros_like(x),\n        'gamma_modifier_func': lambda g: s * g\n    }\n    \n    # Case 3: Zero production\n    Yc_3 = 0.1\n    case3_params = {\n        'L': 0.5, 'A': 0.02, 'rho_g': 0.9, 'u_g': 3.0, 'D': 1e-5,\n        'Yv_func': lambda x: np.full_like(x, Yc_3),\n        'dYv_dx_func': lambda x: np.zeros_like(x),\n        'd2Yv_dx2_func': lambda x: np.zeros_like(x),\n        'gamma_modifier_func': lambda g: np.zeros_like(g) # Modeled gamma is 0\n    }\n    \n    # Case 4: Diffusion-only with offset inconsistency\n    L_4 = 1.0\n    Y0_4, beta_4 = 0.2, 0.05\n    k_4 = 2 * math.pi / L_4\n    delta_gamma_4 = 1e-5\n    case4_params = {\n        'L': L_4, 'A': 0.01, 'rho_g': 1.0, 'u_g': 0.0, 'D': 1e-4,\n        'Yv_func': lambda x: Y0_4 + beta_4 * np.sin(k_4 * x),\n        'dYv_dx_func': lambda x: beta_4 * k_4 * np.cos(k_4 * x),\n        'd2Yv_dx2_func': lambda x: -beta_4 * k_4**2 * np.sin(k_4 * x),\n        'gamma_modifier_func': lambda g: g + delta_gamma_4\n    }\n\n    test_cases = [case1_params, case2_params, case3_params, case4_params]\n    \n    results = []\n    for case in test_cases:\n        error = compute_consistency_error(**case)\n        results.append(f\"{error:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}