{
    "hands_on_practices": [
        {
            "introduction": "爆轰波的模拟涉及巨大的物理尺度范围。在构建复杂的数值模拟之前，进行简单的尺度分析可以揭示根本性的挑战。本练习将使用像佩克莱数（Peclet number） $Pe$ 这样的无量纲数，来阐明为何在计算上完全解析所有物理过程（如分子扩散）常常是不可行的，从而为在大尺度爆轰现象模拟中使用无粘模型提供了理论依据。",
            "id": "4061400",
            "problem": "考虑在高温条件下，对预混反应气体中的爆轰胞格进行二维模拟。在反应区内，激波后的平均流场属性在一个特征胞格长度尺度 $L$ 上近似恒定。假设以下典型值代表了爆轰条件下强可压缩反应流的特性：特征对流速度 $U = 2000$ $\\mathrm{m/s}$，胞格长度尺度 $L = 5.0 \\times 10^{-3}$ $\\mathrm{m}$，热扩散率 $\\alpha = 3.0 \\times 10^{-4}$ $\\mathrm{m^2/s}$，运动粘度 $\\nu = 4.0 \\times 10^{-4}$ $\\mathrm{m^2/s}$，以及组分质量扩散率 $D = 1.2 \\times 10^{-3}$ $\\mathrm{m^2/s}$。该模拟采用均匀的笛卡尔网格，网格间距为 $\\Delta x = 1.0 \\times 10^{-5}$ $\\mathrm{m}$，并使用一种适用于可压缩反应流的激波捕捉方法。\n\n从以平流-扩散-反应平衡形式写出的组分输运方程和在可压缩纳维-斯托克斯（Navier–Stokes）框架下包含粘性应力的动量方程出发，进行第一性原理的无量纲化，以确定主导平流、热扩散、动量扩散和质量扩散相对强度的无量纲数群。使用这些数群来：\n- 推导与胞格长度尺度上的热输运相关的佩克莱数（Pe）和与动量-质量扩散比相关的施密特数（Sc）的表达式。\n- 在给定条件下，计算佩克莱数和施密特数的数值。\n- 利用这些数群所隐含的平流-扩散长度尺度，判断在给定的网格间距 $\\Delta x$ 上，热扩散层和组分扩散层是否物理上可解；你的判断应基于相关扩散长度与 $\\Delta x$ 的比较，并根据主导平衡关系进行论证。\n\n将佩克莱数和施密特数表示为无量纲数，并将两者均四舍五入至三位有效数字。最终答案必须只包含这两个计算值，并排列成一个行矩阵。最终答案中不应包含任何单位。",
            "solution": "题目陈述已经过评估并被确定为有效。它在科学上基于输运现象和计算流体动力学的既定原理，问题设定良好，具有充分且一致的数据以获得唯一解，并使用客观、精确的语言进行表述。所提供的物理参数对于研究反应气体中的爆轰波是符合实际的。因此，我们可以进行正式求解。\n\n该问题要求对主导输运方程进行无量纲分析，以推导关键的无量纲数群，计算它们的值，并评估在给定的计算网格上物理现象的可解性。\n\n首先，我们推导与热输运相关的佩克莱数 $\\text{Pe}$。佩克莱数表示流体对某一物理量的平流输运速率与由相应梯度驱动的同一物理量的扩散速率之比。对于热输运，这涉及热能的平流与热扩散的对比。平衡这两种效应的简化稳态能量方程可以按如下方式进行尺度分析。设 $U$ 为特征对流速度，$L$ 为特征长度尺度，$\\alpha$ 为热扩散率。平流热通量的尺度为 $\\rho c_p U \\Delta T$，其中 $\\rho$ 是密度，$c_p$ 是比热容，$\\Delta T$ 是特征温差。由傅里叶定律决定的扩散热通量的尺度为 $k \\frac{\\Delta T}{L} = \\rho c_p \\alpha \\frac{\\Delta T}{L}$。在微分控制体分析中，平流通量的散度尺度为 $\\frac{\\rho c_p U \\Delta T}{L}$，扩散通量的散度尺度为 $\\frac{\\rho c_p \\alpha \\Delta T}{L^2}$。\n\n这两项之比定义了传热的佩克莱数：\n$$\n\\text{Pe} = \\frac{\\text{Advective Transport}}{\\text{Diffusive Transport}} = \\frac{U L}{\\alpha}\n$$\n代入给定值：\n$$\n\\text{Pe} = \\frac{(2000 \\, \\mathrm{m/s}) (5.0 \\times 10^{-3} \\, \\mathrm{m})}{3.0 \\times 10^{-4} \\, \\mathrm{m^2/s}} = \\frac{10}{3.0 \\times 10^{-4}} \\approx 33333.\\overline{3}\n$$\n四舍五入至三位有效数字，佩克莱数为 $\\text{Pe} \\approx 3.33 \\times 10^{4}$。这个高数值表明，在胞格长度尺度 $L$ 上，与热扩散相比，平流是热输运的绝对主导机制。\n\n接下来，我们推导施密特数 $\\text{Sc}$。施密特数是一个无量纲数群，用于比较动量扩散率与质量扩散率。它定义为运动粘度 $\\nu$ 与组分质量扩散率 $D$ 之比。\n$$\n\\text{Sc} = \\frac{\\nu}{D}\n$$\n这个数对于比较流体动力学（动量）边界层和组分浓度边界层的相对厚度至关重要。使用所提供的值：\n$$\n\\text{Sc} = \\frac{4.0 \\times 10^{-4} \\, \\mathrm{m^2/s}}{1.2 \\times 10^{-3} \\, \\mathrm{m^2/s}} = \\frac{4.0}{12} = \\frac{1}{3} \\approx 0.3333\\overline{3}\n$$\n四舍五入至三位有效数字，施密特数为 $\\text{Sc} \\approx 0.333$。施密特数小于 $1$ 表明质量扩散率大于动量扩散率，这意味着组分浓度剖面将比动量剖面扩散得更快、范围更广。\n\n最后，我们必须评估在计算网格上热扩散层和组分扩散层是否物理上可解。扩散层 $\\delta$ 的特征厚度可以估算为平流和扩散处于同一数量级的长度尺度。这个尺度不同于全局的胞格尺度 $L$。\n\n对于热扩散层，其厚度 $\\delta_{th}$ 可以通过平衡平流项 $U \\frac{\\partial T}{\\partial x}$ 和扩散项 $\\alpha \\frac{\\partial^2 T}{\\partial x^2}$ 来找到。对这些项进行尺度分析得到 $U \\frac{\\Delta T}{\\delta_{th}} \\sim \\alpha \\frac{\\Delta T}{\\delta_{th}^2}$，从而得出：\n$$\n\\delta_{th} = \\frac{\\alpha}{U} = \\frac{3.0 \\times 10^{-4} \\, \\mathrm{m^2/s}}{2000 \\, \\mathrm{m/s}} = 1.5 \\times 10^{-7} \\, \\mathrm{m}\n$$\n\n对于组分扩散层，其厚度 $\\delta_{sp}$ 可以通过平衡平流项 $U \\frac{\\partial Y}{\\partial x}$ 和质量扩散项 $D \\frac{\\partial^2 Y}{\\partial x^2}$ 来找到。尺度分析得到 $U \\frac{\\Delta Y}{\\delta_{sp}} \\sim D \\frac{\\Delta Y}{\\delta_{sp}^2}$，从而得出：\n$$\n\\delta_{sp} = \\frac{D}{U} = \\frac{1.2 \\times 10^{-3} \\, \\mathrm{m^2/s}}{2000 \\, \\mathrm{m/s}} = 6.0 \\times 10^{-7} \\, \\mathrm{m}\n$$\n\n题目陈述网格间距为 $\\Delta x = 1.0 \\times 10^{-5} \\, \\mathrm{m}$。为了解析一个物理特征，网格间距必须显著小于该特征的特征尺寸。我们将 $\\Delta x$ 与扩散层厚度进行比较：\n- 对于热扩散层：$\\frac{\\Delta x}{\\delta_{th}} = \\frac{1.0 \\times 10^{-5} \\, \\mathrm{m}}{1.5 \\times 10^{-7} \\, \\mathrm{m}} \\approx 66.7$。\n- 对于组分扩散层：$\\frac{\\Delta x}{\\delta_{sp}} = \\frac{1.0 \\times 10^{-5} \\, \\mathrm{m}}{6.0 \\times 10^{-7} \\, \\mathrm{m}} \\approx 16.7$。\n\n在这两种情况下，网格间距 $\\Delta x$ 都远大于特征扩散长度（$\\Delta x \\gg \\delta_{th}$ 和 $\\Delta x \\gg \\delta_{sp}$）。网格过于粗糙，无法解析扩散起重要作用的薄层区域。仅仅为了在层厚度内放置一个网格点，热扩散层就需要大约 $67$ 倍更精细的网格，而组分扩散层则需要大约 $17$ 倍更精细的网格。一个适当的解析需要在每个层内设置几个网格点。\n\n因此，我们得出结论，在给定的网格间距 $\\Delta x = 1.0 \\times 10^{-5} \\, \\mathrm{m}$ 下，无论是热扩散层还是组分扩散层都无法被物理地解析。这些层代表了亚网格尺度现象。这凸显了计算燃烧学中的一个根本性挑战：大尺度流体结构（如爆轰胞格）与极薄的反应-扩散区之间的尺度差异，使得必须使用极其精细的网格，或者采用先进的激波捕捉方法和亚网格尺度模型来表征未被解析的物理过程。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n3.33 \\times 10^{4}  0.333\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "由于均匀的精细网格计算成本过高，我们必须将计算资源集中在最关键的区域。本练习演示了如何估算关键物理特征（如反应诱导区）的尺寸，并将这些物理分辨率要求转化为自适应网格加密（Adaptive Mesh Refinement, AMR）模拟的参数。这是设计高效且准确模拟的一项核心技能。",
            "id": "4061414",
            "problem": "使用自适应网格加密（AMR）技术，对一个由带有单步阿伦尼乌斯源项的反应欧拉方程所控制的可压缩反应流进行模拟，该流中存在一个具有明显胞状结构的二维爆轰波。为确保物理上正确的爆轰胞形态和良好的激波捕捉质量，需要对诱导区以及三波点后的剪切层进行精确解析。考虑以下设置以及从一个初步的粗网格解中获取的测量数据。\n\n自适应网格加密层级在相邻层级之间使用 $r=2$ 的加密比，因此在加密层级 $\\ell$ 上的空间步长为 $$\\Delta x_{\\ell} = \\frac{\\Delta x_{0}}{2^{\\ell}},$$ 其中 $\\Delta x_{0}$ 是基础网格间距。在三波点路径附近，反应诱导区通过反应进度变量 $\\lambda$ 来表征，其值从 $\\lambda=0$（未反应）变化到 $\\lambda=1$（完全反应）。沿附着于激波的流线上，该进度变量的局部流向梯度大小测量为 $$\\left|\\frac{\\partial \\lambda}{\\partial s}\\right| = 4.0 \\times 10^{3} \\ \\text{m}^{-1}.$$ 从三波点产生的滑移线表现出一个强剪切层，其流向速度的局部法向梯度测量为 $$\\left|\\frac{\\partial u}{\\partial n}\\right| = 2.5 \\times 10^{5} \\ \\text{s}^{-1},$$ 估计层两端的速度跳跃为 $$\\Delta u = 600 \\ \\text{m} \\ \\text{s}^{-1}.$$\n\n基础网格间距为 $$\\Delta x_{0} = 1.0 \\times 10^{-4} \\ \\text{m}.$$\n\n基于所提供的梯度，使用第一性原理估算诱导区 $L_{\\text{ind}}$ 和剪切层 $\\delta_{\\text{shear}}$ 的特征长度尺度。然后，确定最小的 AMR 加密层级 $\\ell_{\\min}$，使得以下两个数值分辨率标准同时得到满足：\n- 在诱导区厚度 $L_{\\text{ind}}$ 上至少有 $N_{\\text{ind}}=20$ 个网格点，\n- 在剪切层厚度 $\\delta_{\\text{shear}}$ 上至少有 $N_{\\text{shear}}=12$ 个网格点。\n\n假设诱导区局部跨越了进度变量从 $0$ 到 $1$ 的全部变化范围。将最终答案表示为单个整数 $\\ell_{\\min}$。在确定整数后无需四舍五入。答案是无量纲的，不包含单位。",
            "solution": "该问题陈述经评估有效。它在科学上基于计算流体力学和燃烧学的原理，特别是关于爆轰波的数值模拟。问题是适定的、客观的且自洽的，提供了所有必要的数据和明确的标准来确定唯一解。不存在科学缺陷、矛盾或模糊之处。\n\n第一步是估算所描述的两个物理特征的特征长度尺度：诱导区和剪切层。\n\n对于一个物理量 $\\phi$ 变化量为 $\\Delta \\phi$ 的特征，其特征长度尺度 $L$ 可以通过其空间梯度大小 $\\left|\\frac{\\partial \\phi}{\\partial x}\\right|$ 使用一阶近似来估算：\n$$L \\approx \\frac{\\Delta \\phi}{\\left|\\frac{\\partial \\phi}{\\partial x}\\right|}$$\n\n对于诱导区，相关物理量是反应进度变量 $\\lambda$。问题陈述该区域跨越了 $\\lambda$ 从 $\\lambda=0$ 到 $\\lambda=1$ 的全部变化范围，因此总变化量为 $\\Delta \\lambda = 1 - 0 = 1$。给定的流向梯度大小为 $\\left|\\frac{\\partial \\lambda}{\\partial s}\\right| = 4.0 \\times 10^{3} \\ \\text{m}^{-1}$。因此，诱导区的特征长度 $L_{\\text{ind}}$ 为：\n$$L_{\\text{ind}} \\approx \\frac{\\Delta \\lambda}{\\left|\\frac{\\partial \\lambda}{\\partial s}\\right|} = \\frac{1}{4.0 \\times 10^{3} \\ \\text{m}^{-1}} = 0.25 \\times 10^{-3} \\ \\text{m} = 2.5 \\times 10^{-4} \\ \\text{m}$$\n\n对于剪切层，相关物理量是流向速度 $u$。给定的层两端总速度跳跃为 $\\Delta u = 600 \\ \\text{m} \\ \\text{s}^{-1}$。速度的法向梯度为 $\\left|\\frac{\\partial u}{\\partial n}\\right| = 2.5 \\times 10^{5} \\ \\text{s}^{-1}$。剪切层的特征厚度 $\\delta_{\\text{shear}}$ 为：\n$$\\delta_{\\text{shear}} \\approx \\frac{\\Delta u}{\\left|\\frac{\\partial u}{\\partial n}\\right|} = \\frac{600 \\ \\text{m} \\ \\text{s}^{-1}}{2.5 \\times 10^{5} \\ \\text{s}^{-1}} = \\frac{6 \\times 10^2}{2.5 \\times 10^5} \\ \\text{m} = 2.4 \\times 10^{-3} \\ \\text{m}$$\n\n接下来，我们确定为满足每个特征的数值分辨率标准所需的网格间距。\n\n对于诱导区，标准是在其厚度 $L_{\\text{ind}}$ 上至少有 $N_{\\text{ind}}=20$ 个网格点。因此，所需的网格间距 $\\Delta x_{\\text{req, ind}}$ 为：\n$$\\Delta x_{\\text{req, ind}} = \\frac{L_{\\text{ind}}}{N_{\\text{ind}}} = \\frac{2.5 \\times 10^{-4} \\ \\text{m}}{20} = 1.25 \\times 10^{-5} \\ \\text{m}$$\n\n对于剪切层，标准是在其厚度 $\\delta_{\\text{shear}}$ 上至少有 $N_{\\text{shear}}=12$ 个网格点。所需的网格间距 $\\Delta x_{\\text{req, shear}}$ 为：\n$$\\Delta x_{\\text{req, shear}} = \\frac{\\delta_{\\text{shear}}}{N_{\\text{shear}}} = \\frac{2.4 \\times 10^{-3} \\ \\text{m}}{12} = 0.2 \\times 10^{-3} \\ \\text{m} = 2.0 \\times 10^{-4} \\ \\text{m}$$\n\n为同时满足两个分辨率标准，网格间距必须足够细，以满足更严格（更小）的要求。我们将总的所需网格间距 $\\Delta x_{\\text{req}}$ 定义为两者中的最小值：\n$$\\Delta x_{\\text{req}} = \\min(\\Delta x_{\\text{req, ind}}, \\Delta x_{\\text{req, shear}})$$\n$$\\Delta x_{\\text{req}} = \\min(1.25 \\times 10^{-5} \\ \\text{m}, 2.0 \\times 10^{-4} \\ \\text{m}) = 1.25 \\times 10^{-5} \\ \\text{m}$$\n诱导区的分辨率是约束性条件。\n\n最后，我们确定最小的自适应网格加密（AMR）层级 $\\ell_{\\min}$，该层级提供的网格间距 $\\Delta x_{\\ell}$ 小于或等于所需的网格间距 $\\Delta x_{\\text{req}}$。层级 $\\ell$ 的网格间距由以下公式给出：\n$$\\Delta x_{\\ell} = \\frac{\\Delta x_{0}}{r^{\\ell}},$$\n其中基础网格间距为 $\\Delta x_{0} = 1.0 \\times 10^{-4} \\ \\text{m}$，加密比为 $r=2$。\n\n我们必须找到满足以下不等式的最小整数 $\\ell$：\n$$\\Delta x_{\\ell} \\le \\Delta x_{\\text{req}}$$\n$$\\frac{\\Delta x_{0}}{2^{\\ell}} \\le \\Delta x_{\\text{req}}$$\n重新整理不等式以求解 $\\ell$：\n$$2^{\\ell} \\ge \\frac{\\Delta x_{0}}{\\Delta x_{\\text{req}}}$$\n代入数值：\n$$2^{\\ell} \\ge \\frac{1.0 \\times 10^{-4} \\ \\text{m}}{1.25 \\times 10^{-5} \\ \\text{m}}$$\n$$2^{\\ell} \\ge \\frac{10 \\times 10^{-5}}{1.25 \\times 10^{-5}} = \\frac{10}{1.25} = 8$$\n要找到满足 $2^{\\ell} \\ge 8$ 的最小整数 $\\ell$，我们可以对两边取以2为底的对数：\n$$\\ell \\ge \\log_{2}(8)$$\n$$\\ell \\ge 3$$\n由于 $\\ell$ 必须是整数，因此所需的最小加密层级为 $\\ell_{\\min} = 3$。在此层级，网格间距为 $\\Delta x_{3} = (1.0 \\times 10^{-4}) / 2^3 = 1.25 \\times 10^{-5} \\ \\text{m}$，这恰好满足了诱导区的分辨率要求。",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "高阶激波捕捉格式虽然精确，但有时会产生非物理结果，例如在间断附近出现负的质量分数。本练习通过实现一个稳健且有数学原理支持的修正程序来解决这个常见的数值问题。确保质量分数保持正值并总和为一是任何反应流模拟的稳定性和物理真实性的关键。",
            "id": "4061426",
            "problem": "考虑在爆轰胞格模拟的激波捕捉背景下，对可压缩反应流欧拉方程进行的有限体积离散化。假设一个计算单元包含一种混合物，其密度为 $\\rho$（单位为 $\\mathrm{kg/m^3}$），组分质量分数为 $Y_i$（$i=1,\\dots,N$）。组分质量分数定义为 $Y_i = \\rho_i / \\rho$，其中 $\\rho_i$ 是组分 $i$ 的分密度。物理约束要求对所有 $i$ 都有 $Y_i \\ge 0$ 且 $\\sum_{i=1}^N Y_i = 1$。在实践中，高阶激波捕捉格式可能会导致违反这些约束（例如，由于间断附近的数值过冲），必须检测并修正这些违规，以保持物理真实性和数值稳定性。\n\n你的任务是设计：\n1. 一个诊断程序，用于标记任何组分质量分数违反约束 $\\sum_{i=1}^N Y_i = 1$ 或正性约束 $Y_i \\ge 0$ 的单元。对求和约束使用一个容差 $\\tau$。\n2. 一个保守的重整化程序，它能恢复组分质量分数以满足 $Y_i^\\star \\ge 0$ 和 $\\sum_{i=1}^N Y_i^\\star = 1$，且不改变单元内混合物的总质量。该重整化必须保持 $\\rho$ 不变，并且应源自基于原则的投影，而非特设的启发式方法。\n\n你编写的程序必须：\n- 实现一个诊断程序，在 $\\left|\\sum_{i=1}^N Y_i - 1\\right|  \\tau$ 或 $\\min_i Y_i  0$ 之一成立时，将单元标记为违反约束。\n- 实现一个保守的重整化方法，将 $Y^\\star$ 计算为 $Y$ 在概率单纯形 $\\mathcal{S}_N = \\{ x \\in \\mathbb{R}^N \\mid x_i \\ge 0,\\ \\sum_{i=1}^N x_i = 1 \\}$ 上的欧几里得（最小二乘）投影，并保持密度 $\\rho$ 不变。重整化后，如果需要，可通过 $\\rho_i^\\star = \\rho\\,Y_i^\\star$ 更新分密度。重整化必须确保混合物总密度 $\\rho$ 保持不变。\n\n使用以下单元测试套件（每个单元包含 $(\\rho, Y, \\tau)$），其中所有数值均已明确给出：\n- 情况 A（中等偏差的正常路径）：$\\rho = 1.2\\,\\mathrm{kg/m^3}$，$Y = (0.2, 0.3, 0.25, 0.2, 0.1)$，$\\tau = 10^{-10}$。\n- 情况 B（接近容差的边界条件）：$\\rho = 0.9\\,\\mathrm{kg/m^3}$，$Y = (0.3, 0.3, 0.400000000001)$，$\\tau = 10^{-10}$。\n- 情况 C（带有负值的边缘情况）：$\\rho = 1.0\\,\\mathrm{kg/m^3}$，$Y = (0.7, -0.05, 0.4)$，$\\tau = 10^{-10}$。\n- 情况 D（和为零的边缘情况）：$\\rho = 2.0\\,\\mathrm{kg/m^3}$，$Y = (0, 0, 0, 0)$，$\\tau = 10^{-10}$。\n- 情况 E（某组分大于一的边缘情况）：$\\rho = 0.8\\,\\mathrm{kg/m^3}$，$Y = (1.2, -0.1, -0.1)$，$\\tau = 10^{-10}$。\n- 情况 F（与爆轰相关的三组分混合物，其总和偏离 1）：$\\rho = 1.3\\,\\mathrm{kg/m^3}$，$Y = (0.03, 0.22, 0.73)$，$\\tau = 10^{-10}$。\n\n对于每种情况，你的程序必须：\n- 在重整化之前应用诊断程序，生成一个指示是否违规的布尔标记。\n- 应用重整化程序计算 $Y^\\star$。\n- 计算重整化前后的绝对和误差：$e_{\\text{before}} = \\left|\\sum_i Y_i - 1\\right|$ 和 $e_{\\text{after}} = \\left|\\sum_i Y_i^\\star - 1\\right|$。\n- 验证混合物密度是否不变：一个布尔值 $b_\\rho$ 指示重整化后的 $\\rho$ 是否与重整化前的 $\\rho$ 完全相等。\n- 验证重整化后的正性：一个布尔值 $b_{+}$ 指示是否 $\\min_i Y_i^\\star \\ge 0$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含所有情况的结果，形式为一个由方括号括起来的逗号分隔列表。每个情况的结果是一个形如 $[\\text{flag}, e_{\\text{before}}, e_{\\text{after}}, b_\\rho, b_{+}]$ 的列表。\n- 例如，输出应如下所示：$[[\\text{flag}_A, e_{\\text{before},A}, e_{\\text{after},A}, b_{\\rho,A}, b_{+,A}], [\\text{flag}_B, \\dots], \\dots]$。\n\n不涉及角度或百分比；所有输出均为无量纲的布尔值或浮点数。密度在内部必须以 $\\mathrm{kg/m^3}$ 为单位处理，但不会在最终输出中打印。程序必须是完全自包含的，并且无需外部输入即可运行。",
            "solution": "问题陈述经评估是有效的。它在计算燃烧学领域具有科学依据，在数学上是适定的、客观的，并提供了制定解决方案所需的所有必要信息。没有发现不一致之处、不可靠的前提或歧义。\n\n该任务是开发并实现一个处理计算单元中组分质量分数的两部分程序，这是可压缩反应流模拟中的一个常见要求。首先，一个诊断程序必须标记出具有非物理质量分数的单元。其次，一个保守的重整化程序必须修正这些分数，使其在物理上是可接受的。\n\n设一个单元的状态由其混合物密度 $\\rho$ 和一个包含 $N$ 个组分质量分数的向量 $Y = (Y_1, Y_2, \\dots, Y_N)$ 定义。对 $Y$ 的物理约束是：\n1.  **正性：** 对所有 $i=1, \\dots, N$，有 $Y_i \\ge 0$。\n2.  **和为一：** $\\sum_{i=1}^N Y_i = 1$。\n\n这两个约束定义了 $N$ 维的标准单纯形（或概率单纯形），记为 $\\mathcal{S}_N$：\n$$ \\mathcal{S}_N = \\left\\{ x \\in \\mathbb{R}^N \\mid \\sum_{i=1}^N x_i = 1 \\text{ and } x_i \\ge 0 \\text{ for all } i \\right\\} $$\n\n### 第 1 部分：约束违规诊断\n\n诊断规则是明确定义的。如果给定质量分数向量 $Y$ 的分量不在单纯形上，并且对求和约束指定了容差 $\\tau$，则该向量被标记为违反物理约束。违规条件由以下逻辑析取给出：\n$$ \\left( \\left| \\sum_{i=1}^N Y_i - 1 \\right|  \\tau \\right) \\lor \\left( \\min_{i} Y_i  0 \\right) $$\n该检查在应用任何修正之前对输入状态 $(Y, \\tau)$ 执行。修正前总和的绝对误差计算为 $e_{\\text{before}} = \\left| \\sum_{i=1}^N Y_i - 1 \\right|$。\n\n### 第 2 部分：保守重整化程序\n\n重整化必须将一个任意向量 $Y \\in \\mathbb{R}^N$ 映射到一个向量 $Y^\\star \\in \\mathcal{S}_N$。问题强制要求此映射是“保守的”，意味着混合物总密度 $\\rho$ 不变。这是一个关键特性，因为它确保了单元体积内的总质量 $\\rho V$ 是守恒的。该程序仅在各组分之间重新分配质量。\n\n问题指定了一种有原则的方法：修正后的向量 $Y^\\star$ 必须是非物理向量 $Y$ 到概率单纯形 $\\mathcal{S}_N$ 上的欧几里得（或最小二乘）投影。这对应于求解以下二次规划问题：\n$$ \\begin{aligned} \\underset{Y^\\star}{\\text{minimize}} \\quad  \\frac{1}{2} \\| Y^\\star - Y \\|_2^2 = \\frac{1}{2} \\sum_{i=1}^N (Y_i^\\star - Y_i)^2 \\\\ \\text{subject to} \\quad  \\sum_{i=1}^N Y_i^\\star = 1 \\\\  Y_i^\\star \\ge 0, \\quad i=1, \\dots, N \\end{aligned} $$\n由于 $\\mathcal{S}_N$ 是一个闭凸集，对于任何 $Y \\in \\mathbb{R}^N$，这个投影问题都保证存在唯一解 $Y^\\star$。\n\n为了找到解，我们可以使用 Karush-Kuhn-Tucker (KKT) 条件。解 $Y^\\star$ 可以用一个标量变量 $\\theta$（与等式约束的拉格朗日乘子相关）表示为：\n$$ Y_i^\\star = \\max(0, Y_i - \\theta) $$\n这种形式巧妙地包含了正性约束。将其代入和为一的约束中，得到一个关于 $\\theta$ 的非线性方程：\n$$ \\sum_{i=1}^N \\max(0, Y_i - \\theta) = 1 $$\n函数 $f(\\theta) = \\sum_{i=1}^N \\max(0, Y_i - \\theta)$ 是连续、分段线性和单调递减的。可以高效地找到一个唯一的 $\\theta$ 来解 $f(\\theta) = 1$。一个用于此投影的成熟且快速的算法如下：\n\n1.  给定输入向量 $Y = (Y_1, \\dots, Y_N)$。\n2.  将 $Y$ 的分量按降序排序，创建一个新向量 $U$：$u_1 \\ge u_2 \\ge \\dots \\ge u_N$。\n3.  找到最大的整数索引 $\\rho_{\\text{idx}} \\in \\{1, \\dots, N\\}$，使得\n    $$ u_{\\rho_{\\text{idx}}} - \\frac{1}{\\rho_{\\text{idx}}} \\left( \\left( \\sum_{k=1}^{\\rho_{\\text{idx}}} u_k \\right) - 1 \\right)  0 $$\n    该索引确定了 $Y^\\star$ 中将为正的分量子集。\n4.  使用此索引 $\\rho_{\\text{idx}}$ 计算阈值 $\\theta$：\n    $$ \\theta = \\frac{1}{\\rho_{\\text{idx}}} \\left( \\left( \\sum_{k=1}^{\\rho_{\\text{idx}}} u_k \\right) - 1 \\right) $$\n5.  然后，通过将此阈值应用于原始未排序的向量 $Y$ 来计算投影向量 $Y^\\star$ 的分量：\n    $$ Y_i^\\star = \\max(0, Y_i - \\theta) \\quad \\text{for } i=1, \\dots, N $$\n\n### 第 3 部分：重整化后验证\n\n计算出 $Y^\\star$ 后，我们执行所需的验证步骤：\n1.  **最终和误差：** 计算 $e_{\\text{after}} = \\left| \\sum_{i=1}^N Y_i^\\star - 1 \\right|$。由于投影的性质和浮点运算的使用，该值应非常接近 $0$。\n2.  **密度守恒：** 布尔值 $b_\\rho$ 检查混合物密度是否不变。所描述的算法仅作用于质量分数向量 $Y$，不修改 $\\rho$。因此，根据设计，重整化后的密度与重整化前的密度相同，$b_\\rho$ 将为 `True`。\n3.  **正性：** 布尔值 $b_{+}$ 检查是否 $\\min_i Y_i^\\star \\ge 0$。操作 $Y_i^\\star = \\max(0, Y_i - \\theta)$ 保证了 $Y^\\star$ 的所有分量都是非负的。因此，$b_{+}$ 也将为 `True`。\n\n这就完成了诊断程序、保守重整化程序和验证步骤的设计。该框架是鲁棒的、非启发式的，并确保了组分质量分数的基本物理约束在数值上得到遵守。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef renormalize_mass_fractions(Y):\n    \"\"\"\n    Projects a vector Y onto the probability simplex using a fast projection algorithm.\n    This corresponds to finding Y_star that solves:\n    minimize ||Y_star - Y||_2^2\n    subject to sum(Y_star) = 1 and Y_star_i = 0.\n\n    Args:\n        Y (np.ndarray): The input vector of mass fractions.\n\n    Returns:\n        np.ndarray: The projected vector Y_star on the simplex.\n    \"\"\"\n    n_species = len(Y)\n    \n    # Sort the mass fractions in descending order\n    U = np.sort(Y)[::-1]\n    \n    # Compute the cumulative sum of the sorted values\n    cssv = np.cumsum(U)\n    \n    # Find the largest index rho such that the projection condition holds.\n    # The condition is u_j - (1/j) * (sum_{k=1 to j} u_k - 1)  0\n    # The 'j' in the formula is 1-based, so we use arange(1, n+1).\n    j_indices = np.arange(1, n_species + 1)\n    condition = U - (cssv - 1) / j_indices  0\n    \n    # Find the last index (which corresponds to the largest j) where condition is True.\n    # np.where returns a tuple of arrays; we take the first.\n    # If no element satisfies the condition (e.g., Y is a zero vector), this will be empty.\n    # In that edge case, the projection is uniform.\n    if np.any(condition):\n        rho = np.where(condition)[0][-1] + 1\n    else:\n        # This branch handles cases like Y=(0,0,0) where the condition is never strictly  0 for all u_j=0\n        # although mathematically it could be = 0. For Y=(0,0,0) u_j - ...  0 fails, but the projection is uniform.\n        # This can be seen by setting rho = n_species\n        rho = n_species\n\n    # Calculate the threshold theta\n    # cssv is 0-indexed, so we use rho-1\n    theta = (cssv[rho - 1] - 1) / rho\n    \n    # Compute the projection\n    Y_star = np.maximum(0, Y - theta)\n    \n    return Y_star\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and produce the required output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (rho, Y, tau)\n        (1.2, np.array([0.2, 0.3, 0.25, 0.2, 0.1]), 1e-10),     # Case A\n        (0.9, np.array([0.3, 0.3, 0.400000000001]), 1e-10),  # Case B\n        (1.0, np.array([0.7, -0.05, 0.4]), 1e-10),            # Case C\n        (2.0, np.array([0.0, 0.0, 0.0, 0.0]), 1e-10),           # Case D\n        (0.8, np.array([1.2, -0.1, -0.1]), 1e-10),            # Case E\n        (1.3, np.array([0.03, 0.22, 0.73]), 1e-10),         # Case F\n    ]\n\n    results = []\n    for case in test_cases:\n        rho, Y, tau = case\n\n        # 1. Apply the diagnostic before renormalization\n        sum_Y = np.sum(Y)\n        min_Y = np.min(Y)\n        flag = bool(np.abs(sum_Y - 1) > tau or min_Y  0)\n\n        # 2. Compute the sum error before renormalization\n        e_before = np.abs(sum_Y - 1)\n\n        # 3. Apply the renormalization to compute Y_star\n        Y_star = renormalize_mass_fractions(Y)\n\n        # 4. Compute the sum error after renormalization\n        e_after = np.abs(np.sum(Y_star) - 1)\n\n        # 5. Verify density is unchanged. By problem design, it is.\n        b_rho = True\n\n        # 6. Verify post-renormalization positivity. By algorithm design, it is.\n        b_plus = bool(np.min(Y_star) >= 0.0)\n\n        # Store the results for this case\n        case_result = [flag, e_before, e_after, b_rho, b_plus]\n        results.append(case_result)\n\n    # Format the final output string\n    # Python's bool `True` and `False` are used directly as specified by the problem's logic.\n    # The example output `[flag_A, ...]` is a generic placeholder.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    \n    # Final print statement in the exact required format.\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}