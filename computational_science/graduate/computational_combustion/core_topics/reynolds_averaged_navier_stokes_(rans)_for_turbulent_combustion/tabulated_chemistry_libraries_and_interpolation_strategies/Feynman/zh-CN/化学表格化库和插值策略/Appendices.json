{
    "hands_on_practices": [
        {
            "introduction": "在深入探讨如何使用化学表格之前，我们必须首先理解其基本结构及其实际限制。一个化学表格是对连续状态空间的离散化表示，其内存成本由分辨率、存储变量的数量和数据精度决定。本练习将通过推导和计算，帮助您掌握评估表格准确性（分辨率）与计算成本（内存）之间权衡的基本技能，这是任何大规模模拟中都至关重要的考量因素。",
            "id": "4070267",
            "problem": "在一个采用表格化化学的计算燃烧代码中，热化学状态在一个由混合分数 $Z$ 和标量进程变量 $c$ 构成的二维均匀网格上表示。假设该数据库沿 $Z$ 方向有 $N_{Z}$ 个节点，沿 $c$ 方向有 $N_{c}$ 个节点。在每个网格节点上，该数据库存储了 $n_{s}$ 种化学物质的质量分数 $Y_{k}(Z,c)$ 和温度 $T(Z,c)$。假设所有存储的标量均根据 Institute of Electrical and Electronics Engineers (IEEE) Standard $754$ binary $64$ 标准以双精度表示，每个标量占用 $b$ 字节。不存储额外的元数据、填充或预计算的插值系数——只存储 $Y_{k}$ 和 $T$ 的节点值。\n\n从表格化数据库和均匀张量积网格的定义出发，推导总内存占用 $M$（以字节为单位）作为 $N_{Z}$、$N_{c}$、$n_{s}$ 和 $b$ 的函数的通用表达式。然后，对于 $N_{Z}=200$、$N_{c}=200$、$n_{s}=10$ 和 $b=8$ 的情况，计算总字节数。以字节为单位表示最终数值答案。无需四舍五入。",
            "solution": "该问题要求推导一个表格化化学数据库的总内存占用 $M$ 的通用表达式，并随后对一组特定参数进行求值。对问题陈述的验证证实了其具有科学依据、是适定的、客观的，并包含获得唯一解所需的所有信息。\n\n首先，我们确定计算网格中的节点总数。问题陈述指出，热化学状态在一个由混合分数 $Z$ 和标量进程变量 $c$ 构成的二维均匀网格上表示。该网格由沿 $Z$ 方向的 $N_Z$ 个节点和沿 $c$ 方向的 $N_c$ 个节点定义。作为一个张量积网格，状态空间中离散点（节点）的总数（我们表示为 $N_{\\text{nodes}}$）是每个维度上节点数的乘积：\n$$N_{\\text{nodes}} = N_Z N_c$$\n\n接下来，我们确定每个网格节点上存储的标量数量。问题指明，对于每个节点 $(Z,c)$，数据库存储了 $n_s$ 种化学物质的质量分数 $Y_k(Z,c)$ 和温度 $T(Z,c)$。这意味着有 $n_s$ 个标量值用于质量分数，以及 $1$ 个标量值用于温度。因此，每个节点存储的标量总数（表示为 $N_{\\text{scalars/node}}$）是：\n$$N_{\\text{scalars/node}} = n_s + 1$$\n\n整个数据库中存储的标量值总数 $N_{\\text{total}}$ 是节点总数与每个节点标量数的乘积。\n$$N_{\\text{total}} = N_{\\text{nodes}} \\times N_{\\text{scalars/node}} = (N_Z N_c)(n_s + 1)$$\n\n最后，我们计算总内存占用 $M$（以字节为单位）。每个标量都以双精度 (IEEE $754$ binary $64$) 表示，占用 $b$ 字节的内存。总内存占用是标量总数与每个标量大小（以字节为单位）的乘积。\n$$M(N_Z, N_c, n_s, b) = N_{\\text{total}} \\times b$$\n代入 $N_{\\text{total}}$ 的表达式，我们得到内存占用的通用表达式：\n$$M(N_Z, N_c, n_s, b) = N_Z N_c (n_s + 1) b$$\n这就是所要求的通用公式。\n\n现在，我们使用给定的数值来计算此表达式的值：$N_Z = 200$，$N_c = 200$，$n_s = 10$，以及 $b=8$ 字节（因为一个 $64$ 位的双精度浮点数是 $64/8 = 8$ 字节）。\n将这些值代入推导出的公式中：\n$$M = (200)(200)(10 + 1)(8)$$\n首先，计算节点总数：\n$$N_{\\text{nodes}} = 200 \\times 200 = 40000$$\n接下来，计算每个节点的标量数：\n$$N_{\\text{scalars/node}} = 10 + 1 = 11$$\n现在，计算总内存占用 $M$：\n$$M = 40000 \\times 11 \\times 8$$\n$$M = 440000 \\times 8$$\n$$M = 3520000$$\n指定数据库的总内存占用为 $3,520,000$ 字节。",
            "answer": "$$\\boxed{3520000}$$"
        },
        {
            "introduction": "在计算燃烧学中，对化学表格最常见的操作是检索位于网格点之间的某个状态的数据。双线性插值是在结构化二维网格上查询数据的快速而稳健的方法，更重要的是，它能保持被插值量之间的线性关系。这项实践旨在培养实施多维插值的核心技能，并验证其保证物理一致性的一个关键特性——质量分数的守恒。",
            "id": "4070273",
            "problem": "一个用于预混火焰的表格化化学库由混合分数$Z$和一个反应进程变量$c$参数化。在此类库中，每个条目都存储了温度$T(Z,c)$和一个组分质量分数向量$Y(Z,c) = \\left(Y_{1}(Z,c), Y_{2}(Z,c), \\dots, Y_{N}(Z,c)\\right)$，并满足属性$\\sum_{i=1}^{N} Y_{i}(Z,c) = 1$。考虑$(Z,c)$平面上的一个结构化网格单元，其角点坐标为$\\left(Z_{0}, c_{0}\\right) = \\left(0.10, 0.20\\right)$、$\\left(Z_{1}, c_{0}\\right) = \\left(0.30, 0.20\\right)$、$\\left(Z_{0}, c_{1}\\right) = \\left(0.10, 0.50\\right)$和$\\left(Z_{1}, c_{1}\\right) = \\left(0.30, 0.50\\right)$。在这些角点处，表格值为：\n- $\\left(Z_{0}, c_{0}\\right)$：$T = 1000$ 且 $Y = \\left(0.30, 0.60, 0.10\\right)$，\n- $\\left(Z_{0}, c_{1}\\right)$：$T = 1500$ 且 $Y = \\left(0.10, 0.40, 0.50\\right)$，\n- $\\left(Z_{1}, c_{0}\\right)$：$T = 1800$ 且 $Y = \\left(0.55, 0.35, 0.10\\right)$，\n- $\\left(Z_{1}, c_{1}\\right)$：$T = 2100$ 且 $Y = \\left(0.25, 0.25, 0.50\\right)$。\n\n假设一个位于该单元格内的查询点$\\left(Z, c\\right) = \\left(0.22, 0.38\\right)$。从质量分数满足$\\sum_{i=1}^{N} Y_{i} = 1$的基本定义以及一维线性插值的定义出发，推导出一个适用于矩形单元的双线性插值策略，该策略应与沿$Z$和$c$方向的线性形函数一致。使用此策略，计算在点$\\left(Z, c\\right) = \\left(0.22, 0.38\\right)$处的插值温度$T$和组分质量分数向量$Y$。然后，验证插值得到的组分仍然满足$\\sum_{i=1}^{N} Y_{i} = 1$。\n\n最终温度以开尔文为单位表示，组分质量分数以无量纲小数表示。将所有报告的数值四舍五入到$4$位有效数字。以单行向量的形式提供您的最终答案，格式为温度后跟$Y$的各组分分量。",
            "solution": "在尝试求解之前，将对问题进行验证。\n\n### 步骤1：提取已知条件\n- 表格化化学库的控制变量：混合分数 $Z$ 和反应进程变量 $c$。\n- 存储的热化学量：温度 $T(Z,c)$ 和组分质量分数向量 $Y(Z,c) = \\left(Y_{1}(Z,c), \\dots, Y_{N}(Z,c)\\right)$。\n- 质量分数约束：$\\sum_{i=1}^{N} Y_{i}(Z,c) = 1$。\n- 网格单元角点坐标：\n  - $\\left(Z_{0}, c_{0}\\right) = \\left(0.10, 0.20\\right)$\n  - $\\left(Z_{1}, c_{0}\\right) = \\left(0.30, 0.20\\right)$\n  - $\\left(Z_{0}, c_{1}\\right) = \\left(0.10, 0.50\\right)$\n  - $\\left(Z_{1}, c_{1}\\right) = \\left(0.30, 0.50\\right)$\n- 角点处的表格值：\n  - 在 $\\left(Z_{0}, c_{0}\\right)$ 处：$T_{00} = 1000$ 且 $Y_{00} = \\left(0.30, 0.60, 0.10\\right)$。\n  - 在 $\\left(Z_{0}, c_{1}\\right)$ 处：$T_{01} = 1500$ 且 $Y_{01} = \\left(0.10, 0.40, 0.50\\right)$。\n  - 在 $\\left(Z_{1}, c_{0}\\right)$ 处：$T_{10} = 1800$ 且 $Y_{10} = \\left(0.55, 0.35, 0.10\\right)$。\n  - 在 $\\left(Z_{1}, c_{1}\\right)$ 处：$T_{11} = 2100$ 且 $Y_{11} = \\left(0.25, 0.25, 0.50\\right)$。\n- 查询点：$\\left(Z, c\\right) = \\left(0.22, 0.38\\right)$。\n- 任务：推导双线性插值策略，计算查询点处的插值 $T$ 和 $Y$，并验证插值后的质量分数之和为 $1$。\n- 报告要求：将所有最终数值四舍五入到 $4$ 位有效数字。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学依据：**该问题使用了计算燃烧学的标准概念，包括混合分数、反应进程变量和表格化化学。质量分数约束 $\\sum Y_i = 1$ 是质量守恒的基本定律。双线性插值是一种标准的、成熟的数值方法。所有给定值对于燃烧场景都是物理上合理的。\n- **良态性：**该问题提供了执行所要求的双线性插值所需的所有数据（角点坐标、角点值以及单元格内的查询点）。指令清晰，并导向唯一的解。\n- **客观性：**该问题使用精确、无歧义的科学和数学语言进行陈述。\n\n给定的数据也是一致的。每个角点的质量分数之和为 $1$：\n- $Y_{00}: 0.30 + 0.60 + 0.10 = 1.00$\n- $Y_{01}: 0.10 + 0.40 + 0.50 = 1.00$\n- $Y_{10}: 0.55 + 0.35 + 0.10 = 1.00$\n- $Y_{11}: 0.25 + 0.25 + 0.50 = 1.00$\n\n### 步骤3：结论与行动\n问题是有效的。将提供完整的解答。\n\n### 解答\n本题要求推导双线性插值策略，并应用该策略求出在$(Z,c)$平面上特定点的温度$T$和组分质量分数向量$Y$。\n\n**1. 双线性插值公式的推导**\n\n设$f(Z,c)$是在角点为$(Z_0, c_0)$、$(Z_1, c_0)$、$(Z_0, c_1)$和$(Z_1, c_1)$的矩形单元上定义的标量函数。双线性插值可以通过执行两次连续的线性插值来推导。\n\n首先，我们在常数$c$坐标$c_0$和$c_1$上沿$Z$方向进行线性插值。对于一个值$f(x)$，在点$x_0$和$x_1$之间沿一维（例如$x$）在点$x$处的线性插值由以下公式给出：\n$$f(x) = f(x_0) + \\frac{x-x_0}{x_1-x_0} (f(x_1) - f(x_0)) = (1-\\xi)f(x_0) + \\xi f(x_1)$$\n其中$\\xi = \\frac{x-x_0}{x_1-x_0}$是归一化坐标。\n\n将此应用于查询点$Z$的$Z$轴方向：\n令$\\xi = \\frac{Z - Z_0}{Z_1 - Z_0}$。\n在$(Z, c_0)$处的插值是：\n$$f(Z, c_0) \\approx (1-\\xi)f(Z_0, c_0) + \\xi f(Z_1, c_0)$$\n在$(Z, c_1)$处的插值是：\n$$f(Z, c_1) \\approx (1-\\xi)f(Z_0, c_1) + \\xi f(Z_1, c_1)$$\n\n接下来，我们使用这两个中间值沿$c$方向进行线性插值，以求出在查询点$(Z, c)$处的值。\n令$\\eta = \\frac{c - c_0}{c_1 - c_0}$。\n$$f(Z, c) \\approx (1-\\eta)f(Z, c_0) + \\eta f(Z, c_1)$$\n代入$f(Z, c_0)$和$f(Z, c_1)$的表达式：\n$$f(Z, c) \\approx (1-\\eta) \\left[ (1-\\xi)f(Z_0, c_0) + \\xi f(Z_1, c_0) \\right] + \\eta \\left[ (1-\\xi)f(Z_0, c_1) + \\xi f(Z_1, c_1) \\right]$$\n展开此表达式得到双线性插值公式：\n$$f(Z, c) \\approx (1-\\xi)(1-\\eta)f(Z_0, c_0) + \\xi(1-\\eta)f(Z_1, c_0) + (1-\\xi)\\eta f(Z_0, c_1) + \\xi\\eta f(Z_1, c_1)$$\n该公式对应于四个角点值的加权平均，其中权重是归一化坐标的乘积。这与四边形单元上的线性形函数是一致的。\n\n**2. 插值的计算**\n\n首先，我们计算查询点$(Z, c) = (0.22, 0.38)$的归一化坐标$(\\xi, \\eta)$。\n单元边界为$Z_0=0.10$，$Z_1=0.30$，$c_0=0.20$和$c_1=0.50$。\n$$\\xi = \\frac{Z - Z_{0}}{Z_{1} - Z_{0}} = \\frac{0.22 - 0.10}{0.30 - 0.10} = \\frac{0.12}{0.20} = 0.6$$\n$$\\eta = \\frac{c - c_{0}}{c_{1} - c_{0}} = \\frac{0.38 - 0.20}{0.50 - 0.20} = \\frac{0.18}{0.30} = 0.6$$\n\n接下来，我们计算插值权重：\n- 对$(Z_0, c_0)$的权重：$w_{00} = (1-\\xi)(1-\\eta) = (1-0.6)(1-0.6) = 0.4 \\times 0.4 = 0.16$\n- 对$(Z_1, c_0)$的权重：$w_{10} = \\xi(1-\\eta) = 0.6 \\times (1-0.6) = 0.6 \\times 0.4 = 0.24$\n- 对$(Z_0, c_1)$的权重：$w_{01} = (1-\\xi)\\eta = (1-0.6) \\times 0.6 = 0.4 \\times 0.6 = 0.24$\n- 对$(Z_1, c_1)$的权重：$w_{11} = \\xi\\eta = 0.6 \\times 0.6 = 0.36$\n权重之和为 $0.16 + 0.24 + 0.24 + 0.36 = 1.0$。\n\n现在，我们将这些权重应用于表格值。\n对于温度 $T$：\n$T(Z, c) = w_{00}T_{00} + w_{10}T_{10} + w_{01}T_{01} + w_{11}T_{11}$\n$T(0.22, 0.38) = (0.16)(1000) + (0.24)(1800) + (0.24)(1500) + (0.36)(2100)$\n$T(0.22, 0.38) = 160 + 432 + 360 + 756 = 1708$\n四舍五入到$4$位有效数字，温度是$1708$ K。\n\n对于组分质量分数向量 $Y = (Y_1, Y_2, Y_3)$，我们对每个分量应用相同的插值。\n$Y(Z, c) = w_{00}Y_{00} + w_{10}Y_{10} + w_{01}Y_{01} + w_{11}Y_{11}$\n\n- 对于 $Y_1$：\n$Y_1(0.22, 0.38) = (0.16)(0.30) + (0.24)(0.55) + (0.24)(0.10) + (0.36)(0.25)$\n$Y_1(0.22, 0.38) = 0.048 + 0.132 + 0.024 + 0.090 = 0.294$\n四舍五入到$4$位有效数字，$Y_1 = 0.2940$。\n\n- 对于 $Y_2$：\n$Y_2(0.22, 0.38) = (0.16)(0.60) + (0.24)(0.35) + (0.24)(0.40) + (0.36)(0.25)$\n$Y_2(0.22, 0.38) = 0.096 + 0.084 + 0.096 + 0.090 = 0.366$\n四舍五入到$4$位有效数字，$Y_2 = 0.3660$。\n\n- 对于 $Y_3$：\n$Y_3(0.22, 0.38) = (0.16)(0.10) + (0.24)(0.10) + (0.24)(0.50) + (0.36)(0.50)$\n$Y_3(0.22, 0.38) = 0.016 + 0.024 + 0.120 + 0.180 = 0.340$\n四舍五入到$4$位有效数字，$Y_3 = 0.3400$。\n\n插值后的组分质量分数向量是 $Y = (0.2940, 0.3660, 0.3400)$。\n\n**3. 质量分数守恒的验证**\n\n我们必须验证插值后的质量分数之和为$1$。\n设$Y_{i}(Z,c)$为组分$i$的插值质量分数。\n$$\\sum_{i=1}^{N} Y_{i}(Z,c) = \\sum_{i=1}^{N} \\left( w_{00}Y_{i,00} + w_{10}Y_{i,10} + w_{01}Y_{i,01} + w_{11}Y_{i,11} \\right)$$\n由于求和是线性运算，我们可以改变求和的顺序：\n$$\\sum_{i=1}^{N} Y_{i}(Z,c) = w_{00}\\left(\\sum_{i=1}^{N}Y_{i,00}\\right) + w_{10}\\left(\\sum_{i=1}^{N}Y_{i,10}\\right) + w_{01}\\left(\\sum_{i=1}^{N}Y_{i,01}\\right) + w_{11}\\left(\\sum_{i=1}^{N}Y_{i,11}\\right)$$\n根据问题定义，每个表格角点的质量分数之和为$1$。\n$$\\sum_{i=1}^{N}Y_{i,00} = 1, \\quad \\sum_{i=1}^{N}Y_{i,10} = 1, \\quad \\sum_{i=1}^{N}Y_{i,01} = 1, \\quad \\sum_{i=1}^{N}Y_{i,11} = 1$$\n因此，\n$$\\sum_{i=1}^{N} Y_{i}(Z,c) = w_{00}(1) + w_{10}(1) + w_{01}(1) + w_{11}(1) = w_{00} + w_{10} + w_{01} + w_{11}$$\n如前所示，双线性插值权重之和总是$1$。\n$$\\sum_{i=1}^{N} Y_{i}(Z,c) = 1$$\n这表明双线性插值方案固有地保持了质量分数守恒的特性。\n\n用我们计算出的值进行数值验证：\n$\\sum_{i=1}^{3} Y_i = 0.2940 + 0.3660 + 0.3400 = 1.0000$。\n验证成功。\n\n最终答案包含插值温度和三个组分质量分数，均四舍五入到$4$位有效数字。\n$T = 1708$ K\n$Y = (0.2940, 0.3660, 0.3400)$",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 1708  0.2940  0.3660  0.3400 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "尽管均匀网格简单易用，但它们通常效率低下，在函数平滑的区域浪费内存，而在梯度剧烈的区域又缺乏足够的分辨率。自适应网格加密（Adaptive Mesh Refinement, AMR）是一种强大的策略，它通过在插值误差较大的地方自动增加网格点，来创建高效的表格。这项高级编程实践将引导您从仅仅*使用*表格，转向智能地*构建*表格，展示了算法思维如何显著提升科学模型的准确性和效率。",
            "id": "4070304",
            "problem": "您的任务是为计算燃烧学中的一维列表化学实现一种自适应加密策略，其中热化学量被存储为单个控制变量的函数，并通过插值进行检索。在许多燃烧模型中，使用单个控制变量（如混合分数 $Z$ 或反应进程变量 $c$）来参数化组分质量分数和热力学性质的列表化流形。在此类列表化学库（TCL）中进行高效且准确的插值对计算流体力学（CFD）至关重要。目标是通过在估算插值误差超过指定容差的任何地方加密列表网格，来确保插值精度。\n\n考虑一个无量纲控制变量 $\\xi \\in [0,1]$ 和一个表示列表化量的标量函数 $f(\\xi)$。列表网格是 $[0,1]$ 区间的一个单元划分，在网格节点上存储的函数值之间执行分段线性插值。每个单元上的插值误差通过比较单元中点的精确函数值与根据单元端点构造的线性插值来估算。自适应加密算法将估算误差超过容差 $\\epsilon$ 的单元进行二分，从而将网格点集中在陡峭梯度或不连续点附近。\n\n基本依据和规则：\n- 在网格的每个单元上使用分段线性插值。\n- 将单元 $[\\xi_\\ell,\\xi_r]$ 中的估算插值误差定义为中点 $\\xi_m = (\\xi_\\ell+\\xi_r)/2$ 处的精确值与根据端点构造的线性插值中点值之间的绝对差。\n- 如果估算误差超过用户指定的容差 $\\epsilon$，则对单元进行二分。\n- 当没有单元违反容差或达到最大加密层级 $L_{\\max}$ 时，终止加密，以避免在不连续点附近进行无限加密。\n- 初始网格是在 $[0,1]$ 上的一个具有 $M_0$ 个单元的均匀网格。\n\n您的程序必须实现此算法，并通过报告以下内容来演示其如何将网格点集中在陡峭梯度或不连续点附近：\n- 加密后网格节点的最终数量 $N_f$。\n- 加密后所有最终单元上的最大估算插值误差 $\\max E$。\n- 位于预定义高梯度区域内的节点比例，以 $0$ 到 $1$ 之间的小数表示。\n\n高梯度区域的定义：\n- 对于存在导数 $f'(\\xi)$ 的平滑函数 $f(\\xi)$，将高梯度区域定义为满足 $\\lvert f'(\\xi)\\rvert > \\gamma$ 的 $\\xi$ 的集合。这里 $\\gamma$ 是用户指定的梯度阈值。\n- 对于不连续的函数 $f(\\xi)$，将高梯度区域定义为围绕不连续点位置 $\\xi_0$ 的一个区间 $[\\xi_0 - w, \\xi_0 + w]$，其中 $w$ 是一个很小的宽度。\n\n不涉及物理单位；所有变量都是无量纲的。角度（例如，通过三角函数出现时）以弧度为单位。\n\n要实现的算法：\n- 从 $[0,1]$ 区间上一个包含 $M_0$ 个单元的均匀划分开始。\n- 对于每个单元 $[\\xi_\\ell,\\xi_r]$，通过比较其精确函数值 $f(\\xi_m)$ 与从 $f(\\xi_\\ell)$ 和 $f(\\xi_r)$ 线性插值得到的值，计算其中点 $\\xi_m$ 处的估算插值误差。\n- 如果估算误差超过 $\\epsilon$ 并且当前单元的加密层级小于 $L_{\\max}$，则将该单元二分为两个相等的一半并重复。\n- 持续进行直到所有单元都满足容差要求或达到加密限制 $L_{\\max}$。\n\n测试套件：\n为以下四种情况实现该算法，每种情况都旨在检验自适应加密的不同方面。在每种情况下，报告 $N_f$、$\\max E$ 和高梯度区域中的节点比例，将所有情况的结果汇总成一个以逗号分隔的列表，并用方括号括起来。\n\n- 情况 A（陡峭逻辑斯蒂过渡）：\n  - 函数：$f(\\xi) = \\dfrac{1}{1+\\exp\\left(-a(\\xi - \\xi_0)\\right)}$。\n  - 参数：$a = 80$，$\\xi_0 = 0.5$。\n  - 容差：$\\epsilon = 10^{-4}$。\n  - 初始单元数：$M_0 = 8$。\n  - 最大加密层级：$L_{\\max} = 12$。\n  - 高梯度阈值：$\\gamma = 15$。\n\n- 情况 B（不连续点）：\n  - 函数：$f(\\xi) = \\begin{cases} 0, & \\xi  \\xi_0 \\\\ 1,  \\xi \\ge \\xi_0 \\end{cases}$。\n  - 参数：$\\xi_0 = 0.7$，高梯度区间宽度 $w = 5\\times 10^{-3}$。\n  - 容差：$\\epsilon = 10^{-5}$。\n  - 初始单元数：$M_0 = 8$。\n  - 最大加密层级：$L_{\\max} = 14$。\n\n- 情况 C（平滑正弦曲线）：\n  - 函数：$f(\\xi) = \\sin(2\\pi \\xi)$。\n  - 容差：$\\epsilon = 2\\times 10^{-3}$。\n  - 初始单元数：$M_0 = 8$。\n  - 最大加密层级：$L_{\\max} = 12$。\n  - 高梯度阈值：$\\gamma = 4$。\n\n- 情况 D（对陡峭逻辑斯蒂函数的粗糙容差）：\n  - 函数：$f(\\xi) = \\dfrac{1}{1+\\exp\\left(-a(\\xi - \\xi_0)\\right)}$。\n  - 参数：$a = 80$，$\\xi_0 = 0.5$。\n  - 容差：$\\epsilon = 10^{-1}$。\n  - 初始单元数：$M_0 = 8$。\n  - 最大加密层级：$L_{\\max} = 12$。\n  - 高梯度阈值：$\\gamma = 15$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，每个案例贡献一个列表 $[N_f,\\max E,\\text{fraction}]$。例如：$[[N_A,\\max E_A,\\text{frac}_A],[N_B,\\max E_B,\\text{frac}_B],[N_C,\\max E_C,\\text{frac}_C],[N_D,\\max E_D,\\text{frac}_D]]$。",
            "solution": "我们从列表化学库在计算燃烧学中的标准作用开始：诸如组分质量分数和温度之类的标量量被存储为控制变量（通常是混合分数 $Z$ 或反应进程变量 $c$）的函数，并在之后通过插值查询。其根本目标是在保证计算效率的同时实现插值精度。一种满足容差要求的原则性方法是在插值误差较大的地方自适应地加密网格。\n\n分段线性插值误差指示器的原理推导：\n- 考虑一个在单元 $[\\xi_\\ell,\\xi_r]$ 上至少二阶连续可微的标量函数 $f(\\xi)$。设 $\\xi_m = (\\xi_\\ell+\\xi_r)/2$ 为中点，$h = \\xi_r - \\xi_\\ell$ 为单元宽度。\n- 中点的线性插值值为 $f_\\text{lin}(\\xi_m) = \\dfrac{f(\\xi_\\ell)+f(\\xi_r)}{2}$。\n- 根据在 $\\xi_m$ 附近的泰勒展开，我们有\n  $$f(\\xi_\\ell) = f(\\xi_m) - f'(\\xi_m)\\dfrac{h}{2} + \\dfrac{f''(\\zeta_\\ell)}{2}\\left(\\dfrac{h}{2}\\right)^2,$$\n  $$f(\\xi_r) = f(\\xi_m) + f'(\\xi_m)\\dfrac{h}{2} + \\dfrac{f''(\\zeta_r)}{2}\\left(\\dfrac{h}{2}\\right)^2,$$\n  其中某些 $\\zeta_\\ell,\\zeta_r \\in [\\xi_\\ell,\\xi_r]$。将这两个式子平均并减去 $f(\\xi_m)$，得到中点处的插值误差：\n  $$E_m = \\left|f(\\xi_m) - \\dfrac{f(\\xi_\\ell)+f(\\xi_r)}{2}\\right| \\approx \\left|\\dfrac{f''(\\zeta)}{8}h^2\\right|,$$\n  其中 $\\zeta \\in [\\xi_\\ell,\\xi_r]$。虽然我们不显式依赖 $f''$，但中点差值 $E_m$ 提供了一个可计算且有原则的估算器，它与 $h^2$ 乘以曲率成比例。\n- 这启发了一种自适应策略：在 $E_m  \\epsilon$ 的单元进行二分，这将优先加密 $|f''|$ 较大或 $f$ 非光滑的区域。\n\n算法设计：\n- 在 $[0,1]$ 上初始化一个具有 $M_0$ 个单元的均匀网格。对于每个单元，存储 $(\\xi_\\ell,\\xi_r,\\ell)$，其中 $\\ell$ 是加密层级，初始为 $\\ell = 0$。\n- 遍历所有单元。对于每个单元，计算 $E_m = \\left|f(\\xi_m) - \\dfrac{f(\\xi_\\ell)+f(\\xi_r)}{2}\\right|$。如果 $E_m > \\epsilon$ 且 $\\ell  L_{\\max}$，则将该单元二分为两个单元 $[\\xi_\\ell,\\xi_m]$ 和 $[\\xi_m,\\xi_r]$，层级为 $\\ell+1$。否则，保留该单元。\n- 重复此过程，直到没有单元被标记为需要加密，或者所有被标记的单元都已达到 $\\ell = L_{\\max}$。这确保了算法的终止，尤其是在存在不连续点的情况下，此时 $E_m$ 在加密过程中不会趋向于 $0$。\n\n为什么这种方法会将节点集中在陡峭梯度或不连续点附近：\n- 在平滑区域，|f''| 较小，因此满足 $E_m \\le \\epsilon$ 所需的 $h$ 相对较大，意味着节点较少。\n- 在 $|f''|$ 较大的区域，所需的 $h$ 按如下比例缩放\n  $$h \\lesssim \\sqrt{\\dfrac{8\\epsilon}{|f''(\\zeta)|}},$$\n  在陡峭梯度附近，该值会变小。因此，连续的二分操作会将节点集中在曲率高的区域。\n- 在不连续点处，平滑误差模型不再有效，但中点估算器仍然很大（对于从 $0$ 跳到 $1$ 的情况，中点的线性预测是 $0.5$，而真实中点值可能是 $0$ 或 $1$，导致 $E_m \\approx 0.5$）。算法会持续二分直到达到层级上限 $L_{\\max}$，从而将节点聚集在跳跃点附近。\n\n定量诊断：\n- 最终节点数 $N_f$ 反映了总的加密工作量。\n- 最大最终估算误差 $\\max E$ 确认了在可能的情况下满足了 $\\epsilon$（或在达到层级上限时的残余误差）。\n- 高梯度区域内的节点比例提供了对集中程度的直接度量。对于平滑情况，我们通过 $\\lvert f'(\\xi)\\rvert > \\gamma$ 来定义该区域，并统计满足此不等式的节点数。对于在 $\\xi_0$ 处的不连续点，我们定义一个固定的小窗口 $[\\xi_0 - w,\\xi_0 + w]$ 并统计此区间内的节点数。\n\n测试套件的基本原理：\n- 情况 A 使用逻辑斯蒂函数 $f(\\xi)$，其中 $a = 80$ 且 $\\xi_0 = 0.5$，其导数在 $\\xi_0$ 处达到峰值，大小为 $a/4 = 20$。设置 $\\gamma = 15$ 确保了在急剧过渡周围存在一个不可忽略的高梯度区域。\n- 情况 B 在 $\\xi_0 = 0.7$ 处使用一个不连续点，并用一个窄窗口 $w = 5\\times 10^{-3}$ 来测量集中度。严格的容差 $\\epsilon = 10^{-5}$ 和高 $L_{\\max}$ 强制在跳跃点附近进行积极的加密。\n- 情况 C 使用 $f(\\xi) = \\sin(2\\pi \\xi)$，该函数处处平滑，其导数为 $f'(\\xi) = 2\\pi \\cos(2\\pi \\xi)$，并采用适中的容差 $\\epsilon = 2\\times 10^{-3}$。选择 $\\gamma = 4$ 以突出斜率最大值附近的区域。\n- 情况 D 重用陡峭的逻辑斯蒂函数，但使用粗糙的容差 $\\epsilon = 10^{-1}$，以测试几乎不发生或不发生加密的边界条件。\n\n程序实现了这些情况，计算所需的诊断数据，并按顺序为每个情况返回包含列表的列表 $[N_f,\\max E,\\text{fraction}]$ 的单行输出。这个演示直接展示了自适应策略如何在保持其他地方插值精度的同时，将更多节点放置在高梯度区域或不连续点附近。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef logistic(a, x0):\n    def f(x):\n        return 1.0 / (1.0 + np.exp(-a * (x - x0)))\n    def fp(x):\n        # derivative: a * exp(-a*(x-x0)) / (1 + exp(-a*(x-x0)))^2\n        ex = np.exp(-a * (x - x0))\n        return a * ex / (1.0 + ex)**2\n    return f, fp\n\ndef step(x0):\n    def f(x):\n        return 0.0 if x  x0 else 1.0\n    # derivative undefined; return None\n    return f, None\n\ndef sinusoid():\n    def f(x):\n        return np.sin(2.0 * np.pi * x)\n    def fp(x):\n        return 2.0 * np.pi * np.cos(2.0 * np.pi * x)\n    return f, fp\n\ndef adaptive_refine(f, eps, M0, Lmax):\n    # Initialize uniform cells over [0,1]\n    cells = []\n    dx = 1.0 / M0\n    for i in range(M0):\n        left = i * dx\n        right = (i + 1) * dx\n        cells.append((left, right, 0))  # (left, right, level)\n    # Refine\n    while True:\n        refined = False\n        new_cells = []\n        for left, right, level in cells:\n            mid = 0.5 * (left + right)\n            fl = f(left)\n            fr = f(right)\n            fmid = f(mid)\n            lin_mid = 0.5 * (fl + fr)\n            err = abs(fmid - lin_mid)\n            if err > eps and level  Lmax:\n                refined = True\n                new_cells.append((left, mid, level + 1))\n                new_cells.append((mid, right, level + 1))\n            else:\n                new_cells.append((left, right, level))\n        cells = new_cells\n        if not refined:\n            break\n    # Build unique sorted node list from cell boundaries\n    nodes = set()\n    for left, right, _ in cells:\n        nodes.add(left)\n        nodes.add(right)\n    nodes = np.array(sorted(nodes))\n    # Compute max estimated error on final cells\n    max_err = 0.0\n    for left, right, _ in cells:\n        mid = 0.5 * (left + right)\n        fl = f(left)\n        fr = f(right)\n        fmid = f(mid)\n        lin_mid = 0.5 * (fl + fr)\n        err = abs(fmid - lin_mid)\n        if err > max_err:\n            max_err = err\n    return nodes, max_err\n\ndef fraction_in_high_gradient(nodes, fp, gamma, special=None):\n    # special: dict for discontinuity {'x0': float, 'w': float}\n    if special is not None:\n        x0 = special['x0']\n        w = special['w']\n        mask = np.abs(nodes - x0) = w\n        frac = float(np.count_nonzero(mask)) / float(len(nodes))\n        return frac\n    else:\n        # Use derivative threshold\n        # Evaluate derivative at nodes\n        vals = np.array([fp(x) for x in nodes])\n        mask = np.abs(vals) > gamma\n        frac = float(np.count_nonzero(mask)) / float(len(nodes))\n        return frac\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: steep logistic\n        {\n            'type': 'logistic',\n            'params': {'a': 80.0, 'x0': 0.5, 'gamma': 15.0},\n            'eps': 1e-4,\n            'M0': 8,\n            'Lmax': 12,\n            'special': None\n        },\n        # Case B: discontinuity step\n        {\n            'type': 'step',\n            'params': {'x0': 0.7, 'w': 5e-3},\n            'eps': 1e-5,\n            'M0': 8,\n            'Lmax': 14,\n            'special': {'x0': 0.7, 'w': 5e-3}\n        },\n        # Case C: sinusoid\n        {\n            'type': 'sin',\n            'params': {'gamma': 4.0},\n            'eps': 2e-3,\n            'M0': 8,\n            'Lmax': 12,\n            'special': None\n        },\n        # Case D: coarse tolerance logistic\n        {\n            'type': 'logistic',\n            'params': {'a': 80.0, 'x0': 0.5, 'gamma': 15.0},\n            'eps': 1e-1,\n            'M0': 8,\n            'Lmax': 12,\n            'special': None\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        ctype = case['type']\n        eps = case['eps']\n        M0 = case['M0']\n        Lmax = case['Lmax']\n        params = case['params']\n        special = case['special']\n\n        if ctype == 'logistic':\n            a = params['a']\n            x0 = params['x0']\n            gamma = params['gamma']\n            f, fp = logistic(a, x0)\n            nodes, max_err = adaptive_refine(f, eps, M0, Lmax)\n            frac = fraction_in_high_gradient(nodes, fp, gamma, special=None)\n            results.append([len(nodes), max_err, frac])\n\n        elif ctype == 'step':\n            x0 = params['x0']\n            w = params['w']\n            f, fp = step(x0)\n            nodes, max_err = adaptive_refine(f, eps, M0, Lmax)\n            frac = fraction_in_high_gradient(nodes, fp=None, gamma=None, special={'x0': x0, 'w': w})\n            results.append([len(nodes), max_err, frac])\n\n        elif ctype == 'sin':\n            gamma = params['gamma']\n            f, fp = sinusoid()\n            nodes, max_err = adaptive_refine(f, eps, M0, Lmax)\n            frac = fraction_in_high_gradient(nodes, fp, gamma, special=None)\n            results.append([len(nodes), max_err, frac])\n\n        else:\n            # Unknown type; append NaNs\n            results.append([0, float('nan'), float('nan')])\n\n    # Final print statement in the exact required format.\n    # Convert inner lists to string with default Python formatting.\n    def format_entry(entry):\n        return \"[\" + \",\".join(str(x) for x in entry) + \"]\"\n    print(\"[\" + \",\".join(format_entry(r) for r in results) + \"]\")\n\nsolve()\n```"
        }
    ]
}