{
    "hands_on_practices": [
        {
            "introduction": "本练习为分析非预混火焰提供了一个基础起点。我们将计算化学计量混合分数 $Z_{st}$，这是一个关键参数，它标识了混合分数空间中燃料和氧化剂处于完全燃烧所需精确比例的位置 。掌握这一计算至关重要，因为 $Z_{st}$ 是定位火焰和理解扩散火焰整体结构的主要参考点。",
            "id": "4067429",
            "problem": "考虑一个在混合分数空间中由温度为 $T=300\\ \\mathrm{K}$、压力为 $p=1\\ \\mathrm{atm}$ 的逆流甲烷和干燥空气形成的稳态、非预混层流小火焰。燃料流为纯甲烷 $\\mathrm{CH_4}$，氧化剂流为氧气 $\\mathrm{O_2}$ 和氮气 $\\mathrm{N_2}$ 的二元理想混合物，其摩尔分数为 $x_{\\mathrm{O_2}}=0.21$ 和 $x_{\\mathrm{N_2}}=0.79$。假设氧化剂中不含碳或氢，燃料中不含氧。原子量为 $W_C=12$、$W_H=1$ 和 $W_O=16$，分子量为 $W_{\\mathrm{CH_4}}=16$、$W_{\\mathrm{O_2}}=32$ 和 $W_{\\mathrm{N_2}}=28$。\n\n利用元素守恒和甲烷完全氧化的化学计量关系，推导出一个在整个小火焰中保持不变的元素质量分数的守恒标量组合，并构建一个归一化方法来定义混合分数 $Z$，使得在氧化剂流中 $Z=0$，在燃料流中 $Z=1$。然后，计算给定流的化学计量混合分数 $Z_{st}$。对于燃料流，使用元素质量分数 $Y_C^{f}=12/16$、$Y_H^{f}=4/16$ 和 $Y_O^{f}=0$。对于氧化剂流，首先根据质量分数的定义 $Y_i = x_i W_i/\\sum_j x_j W_j$ 计算氧气组分的质量分数 $Y_{\\mathrm{O_2}}^{ox}$，并取氧元素的质量分数为 $Y_O^{ox}=Y_{\\mathrm{O_2}}^{ox}$，其中 $Y_C^{ox}=0$ 和 $Y_H^{ox}=0$。\n\n将 $Z_{st}$ 的最终数值表示为无量纲小数，并四舍五入到四位有效数字。",
            "solution": "该问题要求为甲烷在空气中的燃烧推导一个守恒标量，构建混合分数的定义，并计算化学计量混合分数 $Z_{st}$。求解过程分为三个部分：首先，基于守恒标量定义混合分数；其次，推导 $Z_{st}$ 的解析表达式；最后，计算其数值。\n\n**第一部分：守恒标量与混合分数定义**\n\n在非预混燃烧理论中，假设所有组分的质量扩散系数相等，任何化学元素 $k$ 的质量分数（表示为 $Y_k$）的输运方程没有源项，因为元素在化学反应中是守恒的。这样的量称为守恒标量。在稳态流中，$Y_k$ 的控制方程为：\n$$ \\rho \\mathbf{v} \\cdot \\nabla Y_k = \\nabla \\cdot (\\rho D \\nabla Y_k) $$\n其中 $\\rho$ 是密度，$\\mathbf{v}$ 是速度矢量，$D$ 是质量扩散系数，假设对所有组分和元素都相同。\n\n守恒标量的任意线性组合也是一个守恒标量。一个通用的守恒标量 $\\beta$ 可以由元素质量分数 $Y_C$、$Y_H$ 和 $Y_O$ 构成：\n$$ \\beta = \\alpha_C Y_C + \\alpha_H Y_H + \\alpha_O Y_O $$\n其中 $\\alpha_C$、$\\alpha_H$ 和 $\\alpha_O$ 是任意常数。一种广泛使用的形式，称为 Bilger 耦合函数，是：\n$$ \\beta = \\frac{2 Y_C}{W_C} + \\frac{Y_H}{2W_H} - \\frac{Y_O}{W_O} $$\n对于碳氢化合物完全燃烧的主要产物 $\\mathrm{CO_2}$ 和 $\\mathrm{H_2O}$，这个特定的组合为零。\n\n混合分数 $Z$ 是一个特定的守恒标量，它被归一化，使得在纯氧化剂流中其值为 $Z=0$，在纯燃料流中其值为 $Z=1$。这种归一化构建如下：\n$$ Z = \\frac{\\beta - \\beta_{ox}}{\\beta_f - \\beta_{ox}} $$\n其中 $\\beta_f$ 和 $\\beta_{ox}$ 分别是守恒标量 $\\beta$ 在燃料流和氧化剂流中的值。在等扩散系数假设下，该定义的一个关键推论是，流场中任意点处任何元素 $k$ 的质量分数是 $Z$ 的线性函数：\n$$ Y_k(Z) = Z Y_k^f + (1-Z) Y_k^{ox} $$\n其中 $Y_k^f$ 和 $Y_k^{ox}$ 是燃料流和氧化剂流中的元素质量分数。这个线性混合法则是小火焰分析的基础。任何有效的混合分数定义都将得出相同的化学计量混合分数 $Z_{st}$ 值。\n\n**第二部分：化学计量混合分数 ($Z_{st}$) 的推导**\n\n化学计量混合分数 $Z_{st}$ 对应于燃料和氧化剂处于完全燃烧所需完美比例的特定混合物成分。甲烷 ($\\mathrm{CH_4}$) 的完全燃烧由以下化学计量反应方程式描述：\n$$ \\mathrm{CH_4} + 2\\mathrm{O_2} \\rightarrow \\mathrm{CO_2} + 2\\mathrm{H_2O} $$\n在化学计量条件下，所有来自燃料的碳原子都转化为 $\\mathrm{CO_2}$，所有氢原子都转化为 $\\mathrm{H_2O}$。这意味着在化学计量混合物中，元素 C、H 和 O 的摩尔量之间存在特定关系。每摩尔碳原子（形成 $\\mathrm{CO_2}$）需要两摩尔氧原子。每两摩尔氢原子（形成 $\\mathrm{H_2O}$）需要一摩尔氧原子。这可以用单位质量混合物中元素的摩尔数 $n'_k = Y_k/W_k$ 在化学计量条件（下标 $st$）下表示：\n$$ n'_{O,st} = 2 n'_{C,st} + \\frac{1}{2} n'_{H,st} $$\n使用定义 $n'_k = Y_k/W_k$ 和给定的原子量 $W_C=12$、$W_H=1$ 和 $W_O=16$，我们可以用元素质量分数来表示这个条件：\n$$ \\frac{Y_{O,st}}{16} = 2 \\frac{Y_{C,st}}{12} + \\frac{1}{2} \\frac{Y_{H,st}}{1} $$\n现在，我们将线性混合法则应用于化学计量状态 $Z=Z_{st}$ 下的每个元素质量分数：\n$Y_{C,st} = Z_{st} Y_C^f + (1-Z_{st}) Y_C^{ox}$\n$Y_{H,st} = Z_{st} Y_H^f + (1-Z_{st}) Y_H^{ox}$\n$Y_{O,st} = Z_{st} Y_O^f + (1-Z_{st}) Y_O^{ox}$\n\n问题给出了燃料流和氧化剂流的元素组成：\n燃料流（纯 $\\mathrm{CH_4}$）：$Y_C^f = 12/16$，$Y_H^f = 4/16$，$Y_O^f = 0$。\n氧化剂流（空气）：$Y_C^{ox} = 0$，$Y_H^{ox} = 0$。$Y_O^{ox}$ 非零。\n将这些代入 $Z=Z_{st}$ 时的混合法则中：\n$Y_{C,st} = Z_{st} (12/16)$\n$Y_{H,st} = Z_{st} (4/16)$\n$Y_{O,st} = (1-Z_{st}) Y_O^{ox}$\n\n将这些表达式代回化学计量条件：\n$$ \\frac{(1-Z_{st}) Y_O^{ox}}{16} = 2 \\frac{Z_{st} (12/16)}{12} + \\frac{1}{2} \\frac{Z_{st} (4/16)}{1} $$\n$$ \\frac{(1-Z_{st}) Y_O^{ox}}{16} = 2 \\frac{Z_{st}}{16} + \\frac{1}{2} \\frac{4 Z_{st}}{16} $$\n$$ \\frac{(1-Z_{st}) Y_O^{ox}}{16} = \\frac{2 Z_{st}}{16} + \\frac{2 Z_{st}}{16} = \\frac{4 Z_{st}}{16} $$\n两边同乘以 $16$ 得：\n$$ (1-Z_{st}) Y_O^{ox} = 4 Z_{st} $$\n整理以求解 $Z_{st}$：\n$$ Y_O^{ox} - Z_{st} Y_O^{ox} = 4 Z_{st} $$\n$$ Y_O^{ox} = Z_{st} (4 + Y_O^{ox}) $$\n$$ Z_{st} = \\frac{Y_O^{ox}}{4 + Y_O^{ox}} $$\n\n**第三部分：数值计算**\n\n为了求出 $Z_{st}$ 的数值，我们必须首先计算氧化剂流中的氧元素质量分数 $Y_O^{ox}$。氧化剂是 $\\mathrm{O_2}$ 和 $\\mathrm{N_2}$ 的混合物，其摩尔分数为 $x_{\\mathrm{O_2}}=0.21$ 和 $x_{\\mathrm{N_2}}=0.79$。氧化剂的平均分子量 $W_{ox}$ 为：\n$$ W_{ox} = x_{\\mathrm{O_2}}W_{\\mathrm{O_2}} + x_{\\mathrm{N_2}}W_{\\mathrm{N_2}} = (0.21)(32) + (0.79)(28) = 6.72 + 22.12 = 28.84 $$\n氧化剂流中 $\\mathrm{O_2}$ 组分的质量分数 $Y_{\\mathrm{O_2}}^{ox}$ 为：\n$$ Y_{\\mathrm{O_2}}^{ox} = \\frac{x_{\\mathrm{O_2}}W_{\\mathrm{O_2}}}{W_{ox}} = \\frac{(0.21)(32)}{28.84} = \\frac{6.72}{28.84} $$\n问题说明，由于氧气是氧化剂流中唯一的含氧组分，因此取氧元素的质量分数 $Y_O^{ox}$ 等于 $Y_{\\mathrm{O_2}}^{ox}$。\n$$ Y_O^{ox} = \\frac{6.72}{28.84} $$\n现在，我们将这个值代入推导出的 $Z_{st}$ 表达式中：\n$$ Z_{st} = \\frac{\\frac{6.72}{28.84}}{4 + \\frac{6.72}{28.84}} = \\frac{6.72}{4(28.84) + 6.72} $$\n$$ Z_{st} = \\frac{6.72}{115.36 + 6.72} = \\frac{6.72}{122.08} $$\n进行除法运算得到：\n$$ Z_{st} \\approx 0.05504587... $$\n按要求四舍五入到四位有效数字：\n$$ Z_{st} \\approx 0.05505 $$",
            "answer": "$$\\boxed{0.05505}$$"
        },
        {
            "introduction": "在混合分数概念的基础上，本练习将探讨火焰片结构内部的输运特性。我们将展示元素守恒原理如何简化混合分数空间中的组分输运方程，证明元素质量分数为守恒标量 。通过推导和计算恒定的元素扩散通量，您将更深刻地理解为何混合分数坐标在模拟扩散火焰方面如此强大。",
            "id": "4067365",
            "problem": "考虑一个在混合分数坐标 $Z \\in [0,1]$ 中参数化的一维、稳态、非预混层流小火焰。假设Lewis数(Le)为1，密度$\\rho$恒定，标量耗散率$\\chi$恒定。令$Y_i(Z)$表示组分$i$的质量分数，$\\omega_i(Z)$为其单位体积的化学源项。混合分数空间中的稳态层流小火焰组分输运方程由下式给出：\n$$\n\\frac{d}{dZ}\\!\\left(\\frac{\\rho\\,\\chi}{2}\\,\\frac{dY_i}{dZ}\\right) + \\omega_i = 0 \\quad \\text{for each species } i.\n$$\n定义元素$k$的元素质量分数为\n$$\nb_k(Z) = \\sum_{i} \\alpha_{k,i}\\,Y_i(Z),\n$$\n其中$\\alpha_{k,i} = \\nu_{k,i}\\,W_k/W_i$，$\\nu_{k,i}$是组分$i$中元素$k$的原子数，$W_k$是元素$k$的原子量，$W_i$是组分$i$的分子量。化学反应中各元素守恒，因此源项的加权和满足\n$$\n\\sum_{i} \\alpha_{k,i}\\,\\omega_i(Z) = 0 \\quad \\text{for all } Z \\in [0,1].\n$$\n假设碳的元素质量分数的狄利克雷边界条件为：$b_{\\mathrm{C}}(0) = 0$（氧化剂流中不含碳）和$b_{\\mathrm{C}}(1) = 0.12$（燃料流被稀释，使得碳元素质量分数为$0.12$）。设密度为$\\rho = 1.2$，标量耗散率为$\\chi = 3.5$，其中$\\rho$的单位为$\\mathrm{kg/m^3}$，$\\chi$的单位为$\\mathrm{s^{-1}}$。仅使用组分控制方程、$b_k$的定义以及源项的元素守恒，推导$Z$空间中碳的元素扩散通量\n$$\nJ_{\\mathrm{C}}(Z) = -\\frac{\\rho\\,\\chi}{2}\\,\\frac{d b_{\\mathrm{C}}}{dZ},\n$$\n并证明它在$Z$上是常数。然后根据给定的边界条件和参数计算其常数值。将最终数值结果四舍五入到四位有效数字。以$\\mathrm{kg/(m^3\\cdot s)}$为单位表示最终通量。",
            "solution": "首先对问题进行验证，确认其在科学上是合理的、适定的、客观的和自洽的。所提供的方程、定义和假设在层流小火焰理论中是标准的。因此，我们可以开始求解。\n\n目标是推导元素质量分数$b_k(Z)$的控制方程，并用它来求出碳的元素扩散通量$J_{\\mathrm{C}}(Z)$。\n\n混合分数空间中的组分输运方程如下所示：\n$$\n\\frac{d}{dZ}\\!\\left(\\frac{\\rho\\,\\chi}{2}\\,\\frac{dY_i}{dZ}\\right) + \\omega_i = 0\n$$\n由于密度$\\rho$和标量耗散率$\\chi$被假定为常数，我们可以将该方程重写为：\n$$\n\\frac{\\rho\\,\\chi}{2}\\,\\frac{d^2Y_i}{dZ^2} + \\omega_i = 0\n$$\n可以重新整理该式，用组分质量分数梯度来表示化学源项$\\omega_i$：\n$$\n\\omega_i = -\\frac{\\rho\\,\\chi}{2}\\,\\frac{d^2Y_i}{dZ^2}\n$$\n元素$k$的元素质量分数定义为组分质量分数的线性组合：\n$$\nb_k(Z) = \\sum_{i} \\alpha_{k,i}\\,Y_i(Z)\n$$\n其中$\\alpha_{k,i}$是组分$i$中元素$k$的质量分数。\n\n我们可以通过对其定义应用扩散算子来推导$b_k(Z)$的控制方程。将$b_k(Z)$对$Z$求二阶导数，得到：\n$$\n\\frac{d^2b_k}{dZ^2} = \\frac{d^2}{dZ^2}\\left(\\sum_{i} \\alpha_{k,i}\\,Y_i(Z)\\right)\n$$\n由于求和与微分是线性运算，我们可以交换它们的顺序：\n$$\n\\frac{d^2b_k}{dZ^2} = \\sum_{i} \\alpha_{k,i}\\,\\frac{d^2Y_i}{dZ^2}\n$$\n现在，我们将方程乘以常数扩散系数项$\\frac{\\rho\\,\\chi}{2}$：\n$$\n\\frac{\\rho\\,\\chi}{2}\\,\\frac{d^2b_k}{dZ^2} = \\sum_{i} \\alpha_{k,i}\\left(\\frac{\\rho\\,\\chi}{2}\\,\\frac{d^2Y_i}{dZ^2}\\right)\n$$\n将源项表达式$\\omega_i = -\\frac{\\rho\\,\\chi}{2}\\,\\frac{d^2Y_i}{dZ^2}$代入右侧，得到：\n$$\n\\frac{\\rho\\,\\chi}{2}\\,\\frac{d^2b_k}{dZ^2} = \\sum_{i} \\alpha_{k,i} (-\\omega_i) = -\\sum_{i} \\alpha_{k,i}\\,\\omega_i\n$$\n题目指出化学反应中各元素守恒，其形式化表达为：\n$$\n\\sum_{i} \\alpha_{k,i}\\,\\omega_i(Z) = 0\n$$\n将此元素守恒约束代入我们推导的$b_k(Z)$方程中，得到：\n$$\n\\frac{\\rho\\,\\chi}{2}\\,\\frac{d^2b_k}{dZ^2} = 0\n$$\n由于$\\rho$和$\\chi$是非零常数，这可以简化为元素质量分数的齐次二阶常微分方程：\n$$\n\\frac{d^2b_k}{dZ^2} = 0\n$$\n该方程表明，对于任何元素$k$，其质量分数$b_k(Z)$是$Z$的线性函数。\n\n元素$k$的元素扩散通量定义为：\n$$\nJ_k(Z) = -\\frac{\\rho\\,\\chi}{2}\\,\\frac{d b_k}{dZ}\n$$\n将方程$\\frac{d^2b_k}{dZ^2} = 0$对$Z$积分一次，得到：\n$$\n\\frac{db_k}{dZ} = C_1\n$$\n其中$C_1$是积分常数。这表明元素质量分数的梯度在整个混合分数空间中是恒定的。因此，元素扩散通量$J_k(Z)$也是恒定的：\n$$\nJ_k(Z) = -\\frac{\\rho\\,\\chi}{2}\\,C_1 = \\text{constant}\n$$\n这就完成了问题的第一部分。\n\n接下来，我们利用给定的边界条件计算碳元素通量$J_{\\mathrm{C}}(Z)$的常数值。$\\frac{d^2b_{\\mathrm{C}}}{dZ^2} = 0$的通解是：\n$$\nb_{\\mathrm{C}}(Z) = C_1 Z + C_2\n$$\n我们应用边界条件来确定常数$C_1$和$C_2$。\n氧化剂流（$Z=0$）处的条件是$b_{\\mathrm{C}}(0) = 0$：\n$$\nb_{\\mathrm{C}}(0) = C_1(0) + C_2 = 0 \\quad \\implies \\quad C_2 = 0\n$$\n燃料流（$Z=1$）处的条件是$b_{\\mathrm{C}}(1) = 0.12$：\n$$\nb_{\\mathrm{C}}(1) = C_1(1) + C_2 = 0.12\n$$\n代入$C_2=0$，我们得到$C_1 = 0.12$。\n因此，碳的元素质量分数分布为$b_{\\mathrm{C}}(Z) = 0.12\\,Z$。其梯度为常数：\n$$\n\\frac{db_{\\mathrm{C}}}{dZ} = C_1 = 0.12\n$$\n现在我们可以计算碳元素通量$J_{\\mathrm{C}}$的值：\n$$\nJ_{\\mathrm{C}} = -\\frac{\\rho\\,\\chi}{2}\\,\\frac{d b_{\\mathrm{C}}}{dZ} = -\\frac{\\rho\\,\\chi}{2}\\,(0.12)\n$$\n代入给定的参数值$\\rho = 1.2\\,\\mathrm{kg/m^3}$和$\\chi = 3.5\\,\\mathrm{s^{-1}}$：\n$$\nJ_{\\mathrm{C}} = -\\frac{(1.2)\\,(3.5)}{2}\\,(0.12)\n$$\n$$\nJ_{\\mathrm{C}} = -\\frac{4.2}{2}\\,(0.12)\n$$\n$$\nJ_{\\mathrm{C}} = -(2.1)\\,(0.12)\n$$\n$$\nJ_{\\mathrm{C}} = -0.252\n$$\n单位是$\\mathrm{(kg/m^3) \\cdot (s^{-1}) = kg/(m^3 \\cdot s)}$，符合要求。题目要求将结果四舍五入到四位有效数字。\n$$\nJ_{\\mathrm{C}} = -0.2520\\,\\mathrm{kg/(m^3\\cdot s)}\n$$\n负号表示碳的净通量方向是沿着$Z$减小的方向，即从燃料侧（$Z=1$）到氧化剂侧（$Z=0$），这在物理上是正确的。",
            "answer": "$$\\boxed{-0.2520}$$"
        },
        {
            "introduction": "这最后一个练习将从解析推导过渡到全面的计算模拟，触及火焰片建模的核心。您将实现一个数值方案来求解非线性的稳态火焰片方程，并使用连续方法来追踪火焰对以标量耗散率 $\\chi_{st}$ 为代表的应变率变化的著名“S形曲线”响应 。这个高级练习将使您能够通过计算确定火焰熄火和再燃等关键燃烧现象，从而弥合理论与实用计算燃烧学之间的鸿沟。",
            "id": "4067400",
            "problem": "考虑在混合分数空间中针对单一反应进程变量的稳态层流小火焰公式。令 $z \\in [0,1]$ 表示混合分数，标量耗散率剖面由下式给出\n$$\n\\chi(z) = \\chi_{st} \\exp\\left(-2\\,\\operatorname{erf}^{-1}(1 - 2z)^2\\right),\n$$\n其中 $\\chi_{st}$ 是化学当量面上的标量耗散率，$\\operatorname{erf}^{-1}$ 是反误差函数。假设小火焰是稳态的，并考虑一个反应进程变量 $c(z)$，它在混合分数空间中满足分子扩散和化学反应之间的一维稳态平衡。在稳态小火焰假设下，控制方程可以建模为边值问题 (BVP)\n$$\n\\frac{\\chi(z)}{2}\\,\\frac{d^2 c}{dz^2} + R(c) = 0, \\quad z \\in (0,1),\n$$\n边界条件为\n$$\nc(0) = 0, \\quad c(1) = 0.\n$$\n反应源项 $R(c)$ 通过一个线性温度-进程关系，采用单步类阿伦尼乌斯形式进行近似，并耦合了热释放：\n$$\nR(c) = \\mathrm{Da}\\,\\exp\\left(-\\frac{E}{T_u + \\beta c}\\right)\\,c\\,(1-c),\n$$\n其中 $\\mathrm{Da}$ 是一个类丹柯勒数的前置因子，$E$ 是一个无量纲活化参数，$T_u$ 是一个无量纲未燃气体温度基线，$\\beta$ 是一个无量纲热释放耦合系数。对于给定的 $\\chi_{st}$，未知量是稳态剖面 $c(z)$。\n\n您的任务是：\n1. 从第一性原理出发，推导上述稳态小火焰 BVP 为何与稳态层流小火焰假设下反应标量在混合分数空间中的输运相一致。\n2. 设计并实现一个数值延拓程序，以跟踪稳态解 $c(z)$ 相对于参数 $\\chi_{st}$ 的变化，精确地定位解分支上指示熄火和再燃阈值的转折（折叠）点。使用伪弧长延拓方法来穿越折叠点。\n3. 在 $z \\in [0,1]$ 的均匀网格上，使用二阶中心差分格式对 BVP 进行离散化，并在每个延拓步中使用牛顿法求解非线性代数方程组。\n4. 通过对非线性系统 $F(\\mathbf{c}, \\chi_{st}) = \\mathbf{0}$ 增广一个与基于最后两个收敛解的割线预测器对齐的超平面约束，来实现伪弧长校正器。这里，$\\mathbf{c}$ 集合了 $c(z)$ 在内部网格点上的离散值。\n5. 通过识别沿收敛延拓路径的 $\\chi_{st}$ 值序列的局部极值来检测转折点。当三个连续的延拓点 $(\\chi_{st}^{k-1}, \\chi_{st}^{k}, \\chi_{st}^{k+1})$ 满足 $\\chi_{st}^{k-1} < \\chi_{st}^k > \\chi_{st}^{k+1}$ 或 $\\chi_{st}^{k-1} > \\chi_{st}^k < \\chi_{st}^{k+1}$ 其中之一时，即出现转折点，并使用一个显著性容差以避免假阳性。\n\n从混合分数空间中的组分输运和标量耗散率的定义出发，来论证该稳态 BVP 的合理性。明确陈述任何无量纲化假设，以确保科学上的一致性。使用 LaTeX 表示所有变量、算子和方程。\n\n数值要求：\n- 在 $z \\in [0,1]$ 上使用至少包含 $N=101$ 个点的均匀网格。\n- 对二阶导数使用二阶中心差分，并强制执行狄利克雷边界条件 $c(0)=0$ 和 $c(1)=0$。\n- 实现基于残差范数的停止准则的牛顿法，并在需要时使用简单的步长阻尼。\n- 实现具有固定弧长步长和割线预测器的伪弧长延拓。为校正器构建增广雅可比矩阵，并在每次迭代中求解得到的线性系统。\n- 转折点检测必须在延拓参数序列上使用带容差的有限差分检查。\n- 将所有 $\\chi_{st}$ 的转折点值四舍五入到六位小数。\n\n物理单位：\n- 以 $\\mathrm{s}^{-1}$ 为单位报告 $\\chi_{st}$，四舍五入到六位小数。假设进行了无量纲化，其中时间已被缩放，使得 $\\chi_{st}$ 的数值在报告时等于其以 $\\mathrm{s}^{-1}$ 为单位的值。\n\n测试套件：\n对于三组参数集，运行延拓并报告找到的 $\\chi_{st}$ 的转折点：\n- 情况1（一般情况）：$\\mathrm{Da} = 10$, $E = 10$, $T_u = 1$, $\\beta = 5$。\n- 情况2（化学反应较弱的边界情况）：$\\mathrm{Da} = 1$, $E = 12$, $T_u = 1$, $\\beta = 3$。\n- 情况3（强化学反应）：$\\mathrm{Da} = 20$, $E = 8$, $T_u = 1$, $\\beta = 6$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个条目本身是对应测试用例的 $\\chi_{st}$ 转折点值的列表，四舍五入到六位小数。例如，一种可能的输出格式是 “[[0.123456,0.234567],[],[0.345678]]”。如果某个情况没有找到转折点，则为该情况输出一个空列表（即 “[]”）。\n\n因此，最终输出必须是一个包含三个列表的列表，按情况1、情况2、情况3的固定顺序排列，其中包含以 $\\mathrm{s}^{-1}$ 为单位的 $\\chi_{st}$ 转折点值，每个值都四舍五入到六位小数。",
            "solution": "该问题经评估有效。它在科学上基于已建立的层流小火焰理论，在数学上对于数值延拓是良定的，并且其规定足够详细和清晰，可以采用唯一的求解方法。所有前提和参数都与计算燃烧领域一致。\n\n### 1. 稳态小火焰 BVP 的推导\n\n任务是从反应标量的基本输运方程出发，推导混合分数空间中反应进程变量 $c(z)$ 的一维控制方程。\n\n我们从物理空间坐标 $\\mathbf{x}$ 和时间 $t$ 中组分质量分数 $Y_k$ 的守恒方程开始：\n$$\n\\rho \\frac{\\partial Y_k}{\\partial t} + \\rho \\mathbf{v} \\cdot \\nabla Y_k = -\\nabla \\cdot \\mathbf{j}_k + \\dot{\\omega}_k\n$$\n其中 $\\rho$ 是流体密度，$\\mathbf{v}$ 是速度矢量，$\\mathbf{j}_k$ 是组分 $k$ 的扩散质量通量矢量，$\\dot{\\omega}_k$ 是其化学源项。\n\n我们引入一系列层流小火焰模型的典型简化假设：\n1.  **稳态**：假设小火焰在统计上是静止的，因此所有时间导数都为零 ($\\partial/\\partial t = 0$）。\n2.  **单位刘易斯数**：假设所有组分的热扩散系数等于其质量扩散系数 ($\\mathrm{Le}_k = 1$）。这使我们能够使用单一的代表性扩散系数 $D$ 通过菲克定律来模拟扩散通量：$\\mathbf{j}_k = -\\rho D \\nabla Y_k$。\n3.  **守恒标量**：我们引入混合分数 $z$ 作为一个守恒标量（即其源项为零）。其输运方程为：\n    $$\n    \\rho \\mathbf{v} \\cdot \\nabla z = \\nabla \\cdot (\\rho D \\nabla z)\n    $$\n4.  **小火焰假设**：火焰结构被认为在混合分数空间中是一维的。这意味着反应标量沿着 $z$ 等值面的梯度与穿过这些表面的梯度相比可以忽略不计。在数学上，梯度算子可以近似为 $\\nabla \\approx \\nabla z \\frac{\\partial}{\\partial z}$。\n\n将稳态和单位刘易斯数假设应用于组分输运方程，得到：\n$$\n\\rho \\mathbf{v} \\cdot \\nabla Y_k = \\nabla \\cdot (\\rho D \\nabla Y_k) + \\dot{\\omega}_k\n$$\n现在，我们执行一个坐标变换，从物理坐标 $\\mathbf{x}$ 转换到一个以 $z$ 为其中一个坐标的系统。应用小火焰假设 ($\\nabla \\approx \\nabla z \\frac{\\partial}{\\partial z}$)，$Y_k$ 的输运方程变为：\n$$\n\\rho \\mathbf{v} \\cdot (\\nabla z \\frac{\\partial Y_k}{\\partial z}) = \\nabla \\cdot \\left(\\rho D \\nabla z \\frac{\\partial Y_k}{\\partial z}\\right) + \\dot{\\omega}_k\n$$\n对右侧的散度项应用乘法法则：\n$$\n(\\rho \\mathbf{v} \\cdot \\nabla z) \\frac{\\partial Y_k}{\\partial z} = \\left(\\nabla \\cdot (\\rho D \\nabla z)\\right) \\frac{\\partial Y_k}{\\partial z} + (\\rho D \\nabla z \\cdot \\nabla z) \\frac{\\partial^2 Y_k}{\\partial z^2} + \\dot{\\omega}_k\n$$\n我们识别出项 $\\rho \\mathbf{v} \\cdot \\nabla z$ 是混合分数的对流项，根据其自身的输运方程，它等于扩散项 $\\nabla \\cdot (\\rho D \\nabla z)$。将此代入方程，我们发现左侧的第一项和右侧的第一项相互抵消：\n$$\n\\left(\\nabla \\cdot (\\rho D \\nabla z)\\right) \\frac{\\partial Y_k}{\\partial z} = \\left(\\nabla \\cdot (\\rho D \\nabla z)\\right) \\frac{\\partial Y_k}{\\partial z} + \\rho D |\\nabla z|^2 \\frac{\\partial^2 Y_k}{\\partial z^2} + \\dot{\\omega}_k\n$$\n这简化为组分 $Y_k$ 的小火焰方程：\n$$\n-\\rho D |\\nabla z|^2 \\frac{\\partial^2 Y_k}{\\partial z^2} = \\dot{\\omega}_k\n$$\n标量耗散率 $\\chi$ 被定义为混合分数梯度被分子扩散平滑掉的速率，由 $\\chi = 2D |\\nabla z|^2$ 给出。将此定义代入小火焰方程，得到：\n$$\n-\\frac{\\rho \\chi}{2} \\frac{\\partial^2 Y_k}{\\partial z^2} = \\dot{\\omega}_k\n$$\n让我们考虑一个单一的反应进程变量 $c$，它代表反应状态，从 $0$（未燃）变化到 $1$（完全燃烧）。假设其输运方式与组分质量分数的输运类似，并将化学源项和密度合并为一个函数 $R(c) = \\dot{\\omega}_c(c)/\\rho$，我们得到混合分数空间中的一维稳态小火焰方程：\n$$\n\\frac{\\chi(z)}{2} \\frac{d^2 c}{dz^2} + R(c) = 0\n$$\n至此，推导完成。因此，问题指定的 BVP 被证明是稳态层流小火焰模型基本假设的直接结果，这证实了其科学上的一致性。边界条件 $c(0)=0$ 和 $c(1)=0$ 代表在纯燃料 ($z=1$) 和纯氧化剂 ($z=0$) 股流处的未燃条件。\n\n### 2. 数值求解方法\n\n该控制 BVP 使用数值延拓方法求解，以追踪解曲线并识别转折点。\n\n#### 2.1. 离散化\n\n区域 $z \\in [0,1]$ 使用具有 $N$ 个点的均匀网格进行离散化，即 $z_j = j \\Delta z$，其中 $j = 0, 1, \\dots, N-1$，网格间距为 $\\Delta z = 1/(N-1)$。进程变量 $c(z)$ 由其在这些网格点上的值 $c_j = c(z_j)$ 表示。边界条件固定了 $c_0 = 0$ 和 $c_{N-1} = 0$。未知量是内部节点的值 $\\mathbf{c} = [c_1, c_2, \\dots, c_{N-2}]^T$。\n\n二阶导数项使用二阶中心差分格式进行近似：\n$$\n\\left. \\frac{d^2 c}{dz^2} \\right|_{z_j} \\approx \\frac{c_{j-1} - 2c_j + c_{j+1}}{\\Delta z^2}\n$$\n将此代入每个内部节点 $j=1, \\dots, N-2$ 的控制方程，得到一个包含 $N-2$ 个非线性代数方程的方程组：\n$$\nF_j(\\mathbf{c}, \\chi_{st}) = \\frac{\\chi(z_j)}{2} \\frac{c_{j-1} - 2c_j + c_{j+1}}{(\\Delta z)^2} + R(c_j) = 0\n$$\n该方程组可以紧凑地写为 $F(\\mathbf{c}, \\chi_{st}) = \\mathbf{0}$。\n\n#### 2.2. 伪弧长延拓\n\n为了追踪可能包含转折点（折叠点）的解曲线，我们采用伪弧长延拓方法。该方法通过弧长参数 $s$ 对解分支 $(\\mathbf{c}(s), \\chi_{st}(s))$ 进行参数化。状态向量被增广以包含延拓参数：$\\mathbf{u} = [\\mathbf{c}; \\chi_{st}]^T$，它有 $N-1$ 个分量。原始系统 $F(\\mathbf{u}) = \\mathbf{0}$ 现在是欠定的。我们添加一个约束方程 $N(\\mathbf{u})=0$ 来封闭系统。\n\n该方法以预测-校正的方式进行。\n\n**初始化**：为了开始延拓，需要解曲线上的两个初始点 $\\mathbf{u}^0$ 和 $\\mathbf{u}^1$。这两个点可以通过对两个略有不同的小 $\\chi_{st}$ 值（例如 $\\chi_{st}^0$ 和 $\\chi_{st}^1 = 1.1\\chi_{st}^0$）求解原始 BVP $F(\\mathbf{c}, \\chi_{st})=\\mathbf{0}$ 来找到，求解时使用标准的牛顿求解器，并为 $\\mathbf{c}$ 设置一个抛物线形的初始猜测。\n\n**预测器**：给定两个收敛点 $\\mathbf{u}^{k-1}$ 和 $\\mathbf{u}^k$，我们构造切向量的割线近似：\n$$\n\\mathbf{t}^k = \\frac{\\mathbf{u}^k - \\mathbf{u}^{k-1}}{\\|\\mathbf{u}^k - \\mathbf{u}^{k-1}\\|_2}\n$$\n曲线上下一个点通过沿此切线外插来预测：\n$$\n\\mathbf{u}^{k+1, p} = \\mathbf{u}^k + \\Delta s \\cdot \\mathbf{t}^k\n$$\n其中 $\\Delta s$ 是一个固定的弧长步长，$\\mathbf{u}^{k+1, p}$ 是预测点。\n\n**校正器**：预测点 $\\mathbf{u}^{k+1, p}$ 作为牛顿求解器的初始猜测，以找到曲线上的真实解 $\\mathbf{u}^{k+1}$。我们求解增广系统 $\\mathbf{G}(\\mathbf{u}) = \\mathbf{0}$：\n$$\n\\mathbf{G}(\\mathbf{u}) = \\begin{pmatrix} F(\\mathbf{c}, \\chi_{st}) \\\\ N(\\mathbf{c}, \\chi_{st}) \\end{pmatrix} = \\mathbf{0}\n$$\n约束 $N(\\mathbf{u})=0$ 定义了一个与割线预测器正交并穿过预测点的超平面：\n$$\nN(\\mathbf{u}) = (\\mathbf{u} - \\mathbf{u}^{k+1, p}) \\cdot \\mathbf{t}^k = 0\n$$\n校正步骤的牛顿迭代为 $\\mathbf{u}_{i+1} = \\mathbf{u}_i - [J_G(\\mathbf{u}_i)]^{-1} \\mathbf{G}(\\mathbf{u}_i)$，其中 $J_G$ 是增广雅可比矩阵：\n$$\nJ_G = \\begin{pmatrix} \\frac{\\partial F}{\\partial \\mathbf{c}} & \\frac{\\partial F}{\\partial \\chi_{st}} \\\\ \\frac{\\partial N}{\\partial \\mathbf{c}} & \\frac{\\partial N}{\\partial \\chi_{st}} \\end{pmatrix}\n$$\n$J_G$ 的分量是：\n-   $\\frac{\\partial F}{\\partial \\mathbf{c}}$：这是离散化 BVP 相对于内部解值 $\\mathbf{c}$ 的 $(N-2) \\times (N-2)$ 标准三对角雅可比矩阵。其元素为 $J_{ij} = \\frac{\\partial F_i}{\\partial c_j}$。\n-   $\\frac{\\partial F}{\\partial \\chi_{st}}$：一个 $(N-2) \\times 1$ 的列向量，表示残差对延拓参数的敏感度。根据 $F_j$ 和 $\\chi(z)$ 的定义，其元素为 $\\frac{\\partial F_j}{\\partial \\chi_{st}} = \\frac{1}{\\chi_{st}} \\frac{\\chi(z_j)}{2} \\frac{c_{j-1} - 2c_j + c_{j+1}}{(\\Delta z)^2}$。\n-   $\\frac{\\partial N}{\\partial \\mathbf{c}}$：一个 $1 \\times (N-2)$ 的行向量。根据约束方程，这是切向量的 $\\mathbf{c}$ 分量的转置，即 $(\\mathbf{t}^k_c)^T$。\n-   $\\frac{\\partial N}{\\partial \\chi_{st}}$：一个标量，即切向量的 $\\chi_{st}$ 分量 $t^k_\\chi$。\n\n在每次迭代中，我们求解线性系统 $J_G \\delta \\mathbf{u} = -\\mathbf{G}$ 以获得更新量 $\\delta \\mathbf{u}$。\n\n#### 2.3. 转折点检测\n\n解曲线中的转折点（折叠点）对应于延拓参数 $\\chi_{st}$ 相对于弧长 $s$ 的局部极值。随着延拓的进行，我们存储收敛的参数值序列 $\\{\\chi_{st}^k\\}$。如果在第 $k$ 步，该序列满足以下条件之一，则检测到转折点：\n-   熄火（最大值）：$\\chi_{st}^{k-1}  \\chi_{st}^k > \\chi_{st}^{k+1}$\n-   再燃（最小值）：$\\chi_{st}^{k-1} > \\chi_{st}^k  \\chi_{st}^{k+1}$\n\n应用一个小的容差以确保 $\\chi_{st}$ 的变化在数值上是显著的，从而防止因曲线上近乎平坦部分的浮点噪声而导致的假阳性。然后将值 $\\chi_{st}^k$ 记录为转折点。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import erfinv\nfrom scipy.linalg import solve as linsolve\n\ndef solve():\n    \"\"\"\n    Main solver function to run continuation for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1: General case\n        {'Da': 10.0, 'E': 10.0, 'Tu': 1.0, 'beta': 5.0},\n        # Case 2: Weak chemistry\n        {'Da': 1.0, 'E': 12.0, 'Tu': 1.0, 'beta': 3.0},\n        # Case 3: Strong chemistry\n        {'Da': 20.0, 'E': 8.0, 'Tu': 1.0, 'beta': 6.0},\n    ]\n\n    all_results = []\n    for params in test_cases:\n        turning_points = run_continuation(\n            params, N=101, ds=0.05, max_steps=600, chi_st_start=1e-4\n        )\n        all_results.append(turning_points)\n\n    # Format the final output string as specified\n    output_parts = []\n    for tps in all_results:\n        # Sort TPs for consistent output order\n        sorted_tps = sorted(tps)\n        # Round to 6 decimal places and convert to string\n        formatted_tps = [str(round(tp, 6)) for tp in sorted_tps]\n        output_parts.append(f\"[{','.join(formatted_tps)}]\")\n    \n    final_string = f\"[{','.join(output_parts)}]\"\n    print(final_string)\n\ndef run_continuation(params, N, ds, max_steps, chi_st_start):\n    \"\"\"\n    Performs pseudo-arclength continuation to find turning points.\n    \"\"\"\n    # --- Grid and Parameters ---\n    z = np.linspace(0, 1, N)\n    dz = 1.0 / (N - 1)\n    z_internal = z[1:-1]\n    M = N - 2  # Number of internal points\n    \n    # Precompute chi profile factor\n    # Handle endpoints for erfinv carefully, though they are not used in matrix construction\n    z_clipped = np.clip(z_internal, 1e-12, 1 - 1e-12)\n    chi_factor = np.exp(-2 * erfinv(1 - 2 * z_clipped)**2)\n\n    tol_newton = 1e-8\n    max_iter_newton = 10\n    turn_tol = 1e-9 # Significance tolerance for turning point detection\n\n    # --- Helper functions for this specific problem instance ---\n    def R_func(c, p):\n        # Avoid division by zero or log of non-positive if c makes T negative\n        T = p['Tu'] + p['beta'] * c\n        # Clip c away from 0 and 1 to prevent numerical issues\n        c = np.clip(c, 1e-12, 1-1e-12)\n        return p['Da'] * np.exp(-p['E'] / T) * c * (1 - c)\n\n    def dRdc_func(c, p):\n        T = p['Tu'] + p['beta'] * c\n        c = np.clip(c, 1e-12, 1-1e-12)\n        exp_term = np.exp(-p['E'] / T)\n        main_term = 1 - 2*c\n        temp_sens_term = -p['E'] * p['beta'] * c * (1 - c) / (T**2)\n        return p['Da'] * exp_term * (main_term + temp_sens_term)\n\n    # --- Initial Solution Finder (Standard Newton for a fixed chi_st) ---\n    def get_initial_solution(chi_st_val):\n        c_vec = 4.0 * z_internal * (1.0 - z_internal) # Initial guess\n        for _ in range(max_iter_newton):\n            c_full = np.concatenate(([0], c_vec, [0]))\n            \n            # Assemble residual F\n            laplacian = (c_full[:-2] - 2 * c_full[1:-1] + c_full[2:]) / dz**2\n            chi_profile = chi_st_val * chi_factor\n            F = 0.5 * chi_profile * laplacian + R_func(c_vec, params)\n\n            if np.linalg.norm(F)  tol_newton:\n                return c_vec\n\n            # Assemble Jacobian dF/dc\n            J = np.zeros((M, M))\n            dRdc_vals = dRdc_func(c_vec, params)\n            diag_term = -chi_profile / dz**2 + dRdc_vals\n            off_diag_term = 0.5 * chi_profile / dz**2\n            \n            np.fill_diagonal(J, diag_term)\n            if M > 1:\n                np.fill_diagonal(J[1:], off_diag_term[:-1], wrap=False)\n                np.fill_diagonal(J[:,1:], off_diag_term[:-1], wrap=False)\n\n            delta_c = linsolve(J, -F)\n            c_vec += delta_c\n        \n        raise RuntimeError(\"Initial solution failed to converge.\")\n\n    # --- Generate two starting points for continuation ---\n    try:\n        c0 = get_initial_solution(chi_st_start)\n        u0 = np.concatenate((c0, [chi_st_start]))\n        \n        c1 = get_initial_solution(chi_st_start * 1.01)\n        u1 = np.concatenate((c1, [chi_st_start * 1.01]))\n    except RuntimeError:\n        return [] # Cannot start, so no turning points\n\n    history = [u0, u1]\n    turning_points = []\n    \n    # --- Continuation Loop ---\n    for k in range(1, max_steps):\n        # --- Predictor ---\n        uk = history[k]\n        ukm1 = history[k-1]\n        \n        tangent = (uk - ukm1) / np.linalg.norm(uk - ukm1)\n        u_pred = uk + ds * tangent\n\n        # --- Corrector (Newton on Augmented System) ---\n        u_corr = u_pred.copy()\n        for i_newton in range(max_iter_newton):\n            c_vec = u_corr[:-1]\n            chi_st = u_corr[-1]\n            c_full = np.concatenate(([0], c_vec, [0]))\n            \n            # Assemble augmented residual G\n            G = np.zeros(M + 1)\n            \n            # F part\n            laplacian = (c_full[:-2] - 2 * c_full[1:-1] + c_full[2:]) / dz**2\n            chi_profile = chi_st * chi_factor\n            F = 0.5 * chi_profile * laplacian + R_func(c_vec, params)\n            G[:-1] = F\n            \n            # N part (constraint)\n            N = np.dot(u_corr - u_pred, tangent)\n            G[-1] = N\n\n            if np.linalg.norm(G)  tol_newton:\n                break\n            \n            # Assemble augmented Jacobian J_G\n            J_G = np.zeros((M + 1, M + 1))\n            \n            # dF/dc part\n            J_F_c = np.zeros((M, M))\n            dRdc_vals = dRdc_func(c_vec, params)\n            diag_term = -chi_profile / dz**2 + dRdc_vals\n            off_diag_term = 0.5 * chi_profile / dz**2\n            np.fill_diagonal(J_F_c, diag_term)\n            if M > 1:\n                np.fill_diagonal(J_F_c[1:], off_diag_term[:-1], wrap=False)\n                np.fill_diagonal(J_F_c[:,1:], off_diag_term[:-1], wrap=False)\n            J_G[:M, :M] = J_F_c\n\n            # dF/d(chi_st) part\n            dF_dchi = 0.5 * chi_factor * laplacian\n            J_G[:M, -1] = dF_dchi\n\n            # dN/du part\n            J_G[-1, :] = tangent\n            \n            delta_u = linsolve(J_G, -G)\n            u_corr += delta_u\n        else: # If Newton loop finishes without convergence\n            # In a real application, would implement step size reduction here.\n            # For this problem, we assume fixed step size is sufficient.\n            break\n\n        history.append(u_corr)\n\n        # --- Turning Point Detection ---\n        chi_st_km1 = history[k-1][-1]\n        chi_st_k = history[k][-1]\n        chi_st_kp1 = history[k+1][-1]\n        \n        is_max = chi_st_k > chi_st_km1 and chi_st_k > chi_st_kp1\n        is_min = chi_st_k  chi_st_km1 and chi_st_k  chi_st_kp1\n\n        if is_max or is_min:\n            # Check significance\n            sig_check1 = abs(chi_st_k - chi_st_km1) > turn_tol\n            sig_check2 = abs(chi_st_k - chi_st_kp1) > turn_tol\n            if sig_check1 and sig_check2:\n                 # Avoid adding duplicates if curve is very flat at the fold\n                if not turning_points or all(abs(chi_st_k - tp) / tp > 0.01 for tp in turning_points):\n                    turning_points.append(chi_st_k)\n\n    return turning_points\n\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}