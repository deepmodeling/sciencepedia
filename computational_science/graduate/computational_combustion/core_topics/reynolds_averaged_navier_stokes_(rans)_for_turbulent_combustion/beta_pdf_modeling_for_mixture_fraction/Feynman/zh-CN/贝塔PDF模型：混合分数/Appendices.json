{
    "hands_on_practices": [
        {
            "introduction": "在我们对混合分数 $Z$ 的统计特性进行建模之前，理解其物理意义至关重要。化学计量混合分数 $Z_{st}$ 是非预混火焰中的一个关键物理地标，代表了燃料和氧化剂恰好完全反应的混合状态。本练习将通过从元素守恒的第一性原理出发，推导 $Z_{st}$ 的表达式，从而巩固抽象标量 $Z$ 与具体燃烧化学之间的联系。",
            "id": "4009873",
            "problem": "考虑一个用于混合分数的假定贝塔概率密度函数 (PDF) 模型的经典非预混燃烧配置，该配置涉及两股逆向流动的流股。流股 $1$ 是燃料侧流股，流股 $2$ 是氧化剂侧流股。设混合分数 $Z$ 定义为局部混合物中源自流股 $1$ 的物质的质量分数，因此对于每种元素 $E\\in\\{C,H,O\\}$，在等扩散系数和直到化学计量表面的非反应混合的通常假设下，混合物中的元素质量分数满足 $W_{E}(Z)=Z\\,W_{E}^{(1)}+(1-Z)\\,W_{E}^{(2)}$。假设燃料结合的碳和氢完全氧化为二氧化碳和水，并忽略氮和次要组分在化学计量平衡中的参与。用 $M_{C}$、$M_{H}$ 和 $M_{O}$ 分别表示碳、氢和氧的原子质量。\n\n从元素守恒和化学计量比下混合反应物中存在的氧恰好等于将所有碳和氢转化为完全氧化产物所需氧量的要求出发，推导化学计量混合分数 $Z_{st}$ 的闭式解析表达式，该表达式用流股 $i=1,2$ 的元素质量分数 $W_{C}^{(i)}$、$W_{H}^{(i)}$ 和 $W_{O}^{(i)}$ 以及原子质量 $M_{C}$、$M_{H}$ 和 $M_{O}$ 表示。你的最终表达式必须是单个闭式公式。以无数值计算和无单位的形式表达答案。",
            "solution": "该问题要求基于元素守恒原理推导化学计量混合分数 $Z_{st}$ 的闭式表达式。该问题具有科学依据，提法恰当，并包含求解所需的所有信息。我们将着手进行推导。\n\n混合分数 $Z$ 定义为源自燃料流股（流股 $1$）的物质的质量分数。混合物中任何元素 $E$ 的元素质量分数 $W_E$ 由其在燃料流股中的质量分数 $W_E^{(1)}$ 和在氧化剂流股中的质量分数 $W_E^{(2)}$ 的线性组合给出：\n$$W_{E}(Z) = Z W_{E}^{(1)} + (1-Z) W_{E}^{(2)}$$\n考虑的元素是碳 ($C$)、氢 ($H$) 和氧 ($O$)。\n\n化学计量条件定义为反应物中存在的氧量恰好等于将所有碳完全氧化为二氧化碳 ($CO_2$) 和所有氢完全氧化为水 ($H_2O$) 所需的氧量。让我们用数学方式来表达这个条件。\n\n首先，我们确定每单位质量的燃料元素所需的氧气质量。\n1.  对于碳 ($C$)：完全氧化反应为 $C + O_2 \\rightarrow CO_2$。以原子质量为基础，一个质量为 $M_C$ 的碳原子与两个总质量为 $2 M_O$ 的氧原子反应。因此，每单位质量碳所需的氧气质量为比值 $\\frac{2 M_O}{M_C}$。\n\n2.  对于氢 ($H$)：完全氧化反应为 $2H_2 + O_2 \\rightarrow 2H_2O$。以原子为基础，两个总质量为 $2 M_H$ 的氢原子与一个质量为 $M_O$ 的氧原子反应。因此，每单位质量氢所需的氧气质量为比值 $\\frac{M_O}{2 M_H}$。\n\n现在，考虑在化学计量条件下的单位质量混合物，此时混合分数为 $Z_{st}$。在这个单位质量中，碳和氢的质量分数分别为 $W_C(Z_{st})$ 和 $W_H(Z_{st})$。该单位质量混合物中的燃料元素完全燃烧所需的总氧气质量为：\n$$m_{O, \\text{required}} = W_C(Z_{st}) \\left( \\frac{2 M_O}{M_C} \\right) + W_H(Z_{st}) \\left( \\frac{M_O}{2 M_H} \\right)$$\n在同一单位质量的混合物中，反应物中可用的氧气质量就是氧的元素质量分数 $W_O(Z_{st})$：\n$$m_{O, \\text{available}} = W_O(Z_{st})$$\n根据定义，在化学计量比下，可用氧等于所需氧：\n$$m_{O, \\text{available}} = m_{O, \\text{required}}$$\n$$W_O(Z_{st}) = W_C(Z_{st}) \\left( \\frac{2 M_O}{M_C} \\right) + W_H(Z_{st}) \\left( \\frac{M_O}{2 M_H} \\right)$$\n这个方程可以被重新整理，以定义化学计量表面为一个特定元素质量分数线性组合为零的轨迹：\n$$W_C(Z_{st}) \\left( \\frac{2 M_O}{M_C} \\right) + W_H(Z_{st}) \\left( \\frac{M_O}{2 M_H} \\right) - W_O(Z_{st}) = 0$$\n\n接下来，我们将用 $Z_{st}$ 表示的元素质量分数的定义代入这个化学计量条件中：\n$$\\left[ Z_{st}W_C^{(1)} + (1-Z_{st})W_C^{(2)} \\right] \\left( \\frac{2 M_O}{M_C} \\right) + \\left[ Z_{st}W_H^{(1)} + (1-Z_{st})W_H^{(2)} \\right] \\left( \\frac{M_O}{2 M_H} \\right) - \\left[ Z_{st}W_O^{(1)} + (1-Z_{st})W_O^{(2)} \\right] = 0$$\n为了求解 $Z_{st}$，我们可以将与 $Z_{st}$ 和 $(1-Z_{st})$ 相关的项分组：\n$$Z_{st} \\left[ W_C^{(1)} \\left( \\frac{2 M_O}{M_C} \\right) + W_H^{(1)} \\left( \\frac{M_O}{2 M_H} \\right) - W_O^{(1)} \\right] + (1-Z_{st}) \\left[ W_C^{(2)} \\left( \\frac{2 M_O}{M_C} \\right) + W_H^{(2)} \\left( \\frac{M_O}{2 M_H} \\right) - W_O^{(2)} \\right] = 0$$\n让我们为每个流股 $i \\in \\{1, 2\\}$ 定义一个辅助变量 $\\Phi_i$，它代表该流股的化学计量氧需求（如果为负则为盈余）：\n$$\\Phi_i = W_C^{(i)} \\left( \\frac{2 M_O}{M_C} \\right) + W_H^{(i)} \\left( \\frac{M_O}{2 M_H} \\right) - W_O^{(i)}$$\n使用这个定义，化学计量条件简化为：\n$$Z_{st} \\Phi_1 + (1-Z_{st}) \\Phi_2 = 0$$\n这是一个关于 $Z_{st}$ 的线性方程，我们现在可以求解它：\n$$Z_{st} \\Phi_1 + \\Phi_2 - Z_{st} \\Phi_2 = 0$$\n$$Z_{st} (\\Phi_1 - \\Phi_2) = -\\Phi_2$$\n$$Z_{st} = \\frac{-\\Phi_2}{\\Phi_1 - \\Phi_2}$$\n最后，我们将 $\\Phi_1$ 和 $\\Phi_2$ 的表达式代回这个结果中，以获得 $Z_{st}$ 的最终闭式表达式。\n分子是：\n$$-\\Phi_2 = -\\left[ W_C^{(2)} \\left( \\frac{2 M_O}{M_C} \\right) + W_H^{(2)} \\left( \\frac{M_O}{2 M_H} \\right) - W_O^{(2)} \\right] = W_O^{(2)} - W_C^{(2)} \\left( \\frac{2 M_O}{M_C} \\right) - W_H^{(2)} \\left( \\frac{M_O}{2 M_H} \\right)$$\n分母是：\n$$\\Phi_1 - \\Phi_2 = \\left[ W_C^{(1)} \\left( \\frac{2 M_O}{M_C} \\right) + W_H^{(1)} \\left( \\frac{M_O}{2 M_H} \\right) - W_O^{(1)} \\right] - \\left[ W_C^{(2)} \\left( \\frac{2 M_O}{M_C} \\right) + W_H^{(2)} \\left( \\frac{M_O}{2 M_H} \\right) - W_O^{(2)} \\right]$$\n$$= \\left( W_C^{(1)} - W_C^{(2)} \\right) \\left( \\frac{2 M_O}{M_C} \\right) + \\left( W_H^{(1)} - W_H^{(2)} \\right) \\left( \\frac{M_O}{2 M_H} \\right) - \\left( W_O^{(1)} - W_O^{(2)} \\right)$$\n将这些组合起来，就得到了化学计量混合分数的完整表达式。",
            "answer": "$$\n\\boxed{\nZ_{st} = \\frac{W_O^{(2)} - W_C^{(2)} \\left( \\frac{2 M_O}{M_C} \\right) - W_H^{(2)} \\left( \\frac{M_O}{2 M_H} \\right)}{\\left( W_C^{(1)} - W_C^{(2)} \\right) \\left( \\frac{2 M_O}{M_C} \\right) + \\left( W_H^{(1)} - W_H^{(2)} \\right) \\left( \\frac{M_O}{2 M_H} \\right) - \\left( W_O^{(1)} - W_O^{(2)} \\right)}\n}\n$$"
        },
        {
            "introduction": "掌握了混合分数的物理基础后，我们转向概率密度函数（PDF）建模的核心目的。在湍流燃烧中，我们需要计算高度非线性项（如阿伦尼乌斯反应速率）的平均值，而直接平均会导致巨大的误差。本练习演示了如何使用 Beta-PDF 模型，通过计算一个温度依赖函数的法夫尔平均值来“封闭”这些项，并揭示了平均反应速率对湍流强度（即混合分数方差）的敏感性。",
            "id": "4009901",
            "problem": "考虑一个统计平稳、不可压缩、非预混反应流，其中守恒标量混合分数 $Z \\in [0,1]$ 由贝塔概率密度函数（PDF）建模。设 $Z$ 的平均值和方差分别为 $\\tilde{Z}$ 和 $\\widetilde{Z''^2}$，并假设这些矩已知，可由输运计算得到。在湍流燃烧模型中，化学反应通常通过一个依赖于温度的阿伦尼乌斯因子引入。假设局部温度可以很好地用混合分数的仿射函数来近似，\n$$\nT(Z) = T_{u} + \\Delta T\\, Z,\n$$\n其中 $T_{u}$ 是未混合气流的温度，$\\Delta T$ 是混合引起的温度增量。考虑非线性函数\n$$\nf(Z) = \\exp\\!\\left(-\\frac{E}{R\\,T(Z)}\\right),\n$$\n其中 $E$ 是活化能，$R$ 是通用气体常数。在假定PDF方法下，该化学因子的法夫尔平均值为\n$$\n\\tilde{f(Z)} = \\int_{0}^{1} f(Z)\\,p(Z)\\,\\mathrm{d}Z,\n$$\n其中 $p(Z)$ 是在 $[0,1]$ 上的贝塔PDF，受给定的 $Z$ 的平均值和方差约束。\n\n使用第一性原理，推导 $\\tilde{f(Z)}$ 的小方差渐近近似式，该近似式与受 $\\tilde{Z}$ 和 $\\widetilde{Z''^2}$ 约束的贝塔PDF一致，展开式中保留至 $\\mathcal{O}\\!\\left(\\widetilde{Z''^2}\\right)$ 阶的项。从此推导中，求出 $\\tilde{f(Z)}$ 对方法变化的领先阶灵敏度，定义为\n$$\nS \\equiv \\frac{\\partial \\tilde{f(Z)}}{\\partial \\widetilde{Z''^2}}\\Bigg|_{\\text{leading order}}.\n$$\n\n然后，对以下物理上一致的参数集，数值计算该近似值和灵敏度：\n- $E = 1.20 \\times 10^{5}\\,\\mathrm{J/mol}$（焦耳/摩尔），\n- $R = 8.314\\,\\mathrm{J/(mol\\cdot K)}$（焦耳/(摩尔·开尔文)），\n- $T_{u} = 1100\\,\\mathrm{K}$（开），\n- $\\Delta T = 600\\,\\mathrm{K}$（开），\n- $\\tilde{Z} = 0.30$,\n- $\\widetilde{Z''^2} = 0.010$.\n\n将最终数值结果表示为两个无量纲量 $(\\tilde{f(Z)}, S)$，并将两者四舍五入至四位有效数字。按规定，使用LaTeX的 $\\mathrm{pmatrix}$ 环境将最终答案表示为单行向量。",
            "solution": "该问题要求推导法夫尔平均化学因子 $\\tilde{f(Z)}$ 的小方差渐近近似式，及其对混合分数方差的灵敏度。推导过程是通过将非线性函数 $f(Z)$ 在平均混合分数 $\\tilde{Z}$ 附近进行泰勒级数展开。混合分数的矩，特别是平均值 $\\tilde{Z}$ 和方差 $\\widetilde{Z''^2}$，被假定为已知。概率密度函数 $p(Z)$ 是一个贝塔PDF，只要方差足够小，即 $\\widetilde{Z''^2} \\ll \\tilde{Z}(1-\\tilde{Z})$，它就与给定的矩相一致。该分析不需要贝塔PDF的显式形式，因为展开式在只依赖于前两阶矩的阶次上被截断。\n\n设函数为 $f(Z)$。我们将 $f(Z)$ 在平均混合分数 $Z=\\tilde{Z}$ 处展开为泰勒级数：\n$$\nf(Z) = f(\\tilde{Z}) + (Z-\\tilde{Z})f'(\\tilde{Z}) + \\frac{1}{2}(Z-\\tilde{Z})^2 f''(\\tilde{Z}) + \\mathcal{O}((Z-\\tilde{Z})^3)\n$$\n其中撇号表示对 $Z$ 求导。法夫尔平均值 $\\tilde{f(Z)}$ 是 $f(Z)$ 关于PDF $p(Z)$ 的期望值：\n$$\n\\tilde{f(Z)} = \\int_{0}^{1} f(Z) p(Z) \\,\\mathrm{d}Z\n$$\n将泰勒级数代入积分并逐项积分，我们得到：\n$$\n\\tilde{f(Z)} = \\int_{0}^{1} \\left[ f(\\tilde{Z}) + (Z-\\tilde{Z})f'(\\tilde{Z}) + \\frac{1}{2}(Z-\\tilde{Z})^2 f''(\\tilde{Z}) + \\dots \\right] p(Z) \\,\\mathrm{d}Z\n$$\n使用平均值 $\\tilde{Z} = \\int_{0}^{1} Z p(Z) \\,\\mathrm{d}Z$ 和方差 $\\widetilde{Z''^2} = \\int_{0}^{1} (Z-\\tilde{Z})^2 p(Z) \\,\\mathrm{d}Z$ 的定义，积分得以简化。第一项的积分是 $f(\\tilde{Z})\\int_{0}^{1}p(Z)\\,\\mathrm{d}Z = f(\\tilde{Z})$。第二项的积分是 $f'(\\tilde{Z})\\int_{0}^{1}(Z-\\tilde{Z})p(Z)\\,\\mathrm{d}Z = f'(\\tilde{Z})(\\tilde{Z}-\\tilde{Z})=0$。第三项的积分是 $\\frac{1}{2}f''(\\tilde{Z})\\int_{0}^{1}(Z-\\tilde{Z})^2 p(Z)\\,\\mathrm{d}Z = \\frac{1}{2}f''(\\tilde{Z})\\widetilde{Z''^2}$。\n\n在此阶截断级数，可得到所需的小方差近似，有效期至 $\\mathcal{O}(\\widetilde{Z''^2})$：\n$$\n\\tilde{f(Z)} \\approx f(\\tilde{Z}) + \\frac{1}{2}\\widetilde{Z''^2} f''(\\tilde{Z})\n$$\n为了继续，我们必须计算函数 $f(Z) = \\exp\\left(-\\frac{E}{R\\,T(Z)}\\right)$ 的一阶和二阶导数，其中 $T(Z) = T_{u} + \\Delta T\\, Z$。设 $g(Z) = -\\frac{E}{R\\,T(Z)}$。则 $f(Z)=\\exp(g(Z))$。\n\n一阶导数使用链式法则求得：\n$$\nf'(Z) = \\frac{\\mathrm{d}f}{\\mathrm{d}Z} = \\exp(g(Z)) g'(Z) = f(Z) g'(Z)\n$$\n其中\n$$\ng'(Z) = \\frac{\\mathrm{d}}{\\mathrm{d}Z}\\left(-\\frac{E}{R(T_u + \\Delta T Z)}\\right) = - \\frac{E}{R} \\left( -(T_u + \\Delta T Z)^{-2} \\cdot \\Delta T \\right) = \\frac{E \\Delta T}{R(T_u + \\Delta T Z)^2} = \\frac{E \\Delta T}{R T(Z)^2}\n$$\n所以，\n$$\nf'(Z) = f(Z) \\frac{E \\Delta T}{R T(Z)^2}\n$$\n二阶导数通过对 $f'(Z) = f(Z) g'(Z)$ 使用乘积法则求得：\n$$\nf''(Z) = f'(Z)g'(Z) + f(Z)g''(Z) = \\left(f(Z)g'(Z)\\right)g'(Z) + f(Z)g''(Z) = f(Z)\\left[(g'(Z))^2 + g''(Z)\\right]\n$$\n我们需要 $g''(Z)$：\n$$\ng''(Z) = \\frac{\\mathrm{d}}{\\mathrm{d}Z}\\left(\\frac{E \\Delta T}{R} (T_u + \\Delta T Z)^{-2}\\right) = \\frac{E \\Delta T}{R} \\left( -2(T_u + \\Delta T Z)^{-3} \\cdot \\Delta T \\right) = -\\frac{2E(\\Delta T)^2}{R(T_u + \\Delta T Z)^3} = -\\frac{2E(\\Delta T)^2}{R T(Z)^3}\n$$\n将 $g'(Z)$ 和 $g''(Z)$ 代入 $f''(Z)$ 的表达式中：\n$$\nf''(Z) = f(Z) \\left[ \\left(\\frac{E \\Delta T}{R T(Z)^2}\\right)^2 - \\frac{2E(\\Delta T)^2}{R T(Z)^3} \\right] = f(Z) \\frac{E(\\Delta T)^2}{R T(Z)^3} \\left[ \\frac{E}{R T(Z)} - 2 \\right]\n$$\n在平均混合分数 $Z = \\tilde{Z}$ 处计算二阶导数，我们定义 $\\tilde{T} = T(\\tilde{Z}) = T_u + \\Delta T \\tilde{Z}$ 并求得：\n$$\nf''(\\tilde{Z}) = f(\\tilde{Z}) \\frac{E(\\Delta T)^2}{R \\tilde{T}^3} \\left[ \\frac{E}{R \\tilde{T}} - 2 \\right]\n$$\n将此代入 $\\tilde{f(Z)}$ 的近似式中：\n$$\n\\tilde{f(Z)} \\approx f(\\tilde{Z}) \\left[ 1 + \\frac{1}{2} \\widetilde{Z''^2} \\frac{E(\\Delta T)^2}{R \\tilde{T}^3} \\left( \\frac{E}{R \\tilde{T}} - 2 \\right) \\right]\n$$\n$\\tilde{f(Z)}$ 对方法 $\\widetilde{Z''^2}$ 变化的领先阶灵敏度定义为 $S \\equiv \\frac{\\partial \\tilde{f(Z)}}{\\partial \\widetilde{Z''^2}}\\Big|_{\\text{leading order}}$。对我们的 $\\tilde{f(Z)}$ 近似式关于 $\\widetilde{Z''^2}$ 求导（注意 $f(\\tilde{Z})$ 和 $f''(\\tilde{Z})$ 与 $\\widetilde{Z''^2}$ 无关）得到：\n$$\nS = \\frac{1}{2} f''(\\tilde{Z}) = \\frac{1}{2} f(\\tilde{Z}) \\frac{E(\\Delta T)^2}{R \\tilde{T}^3} \\left( \\frac{E}{R \\tilde{T}} - 2 \\right)\n$$\n现在我们用给定的参数数值计算这些表达式：\n- $E = 1.20 \\times 10^{5}\\,\\mathrm{J/mol}$（焦耳/摩尔）\n- $R = 8.314\\,\\mathrm{J/(mol\\cdot K)}$（焦耳/(摩尔·开尔文)）\n- $T_{u} = 1100\\,\\mathrm{K}$（开）\n- $\\Delta T = 600\\,\\mathrm{K}$（开）\n- $\\tilde{Z} = 0.30$\n- $\\widetilde{Z''^2} = 0.010$\n\n首先，计算平均混合分数处的温度：\n$$\n\\tilde{T} = T(\\tilde{Z}) = 1100\\,\\mathrm{K} + (600\\,\\mathrm{K})(0.30) = 1100\\,\\mathrm{K} + 180\\,\\mathrm{K} = 1280\\,\\mathrm{K}\n$$\n接下来，我们计算无量纲活化能，也称为泽尔多维奇数：\n$$\n\\beta \\equiv \\frac{E}{R\\tilde{T}} = \\frac{1.20 \\times 10^5\\,\\mathrm{J/mol}}{(8.314\\,\\mathrm{J/(mol\\cdot K)})(1280\\,\\mathrm{K})} \\approx 11.27607\n$$\n在平均值处计算的化学因子为：\n$$\nf(\\tilde{Z}) = \\exp(-\\beta) \\approx \\exp(-11.27607) \\approx 1.26733 \\times 10^{-5}\n$$\n现在，我们计算灵敏度 $S$：\n$$\nS = \\frac{1}{2} f(\\tilde{Z}) \\frac{\\beta R \\tilde{T} (\\Delta T)^2}{R \\tilde{T}^3} (\\beta - 2) = \\frac{1}{2} f(\\tilde{Z}) \\frac{\\beta (\\Delta T)^2}{\\tilde{T}^2} (\\beta - 2)\n$$\n$$\nS \\approx \\frac{1}{2} (1.26733 \\times 10^{-5}) \\frac{(11.27607)(600\\,\\mathrm{K})^2}{(1280\\,\\mathrm{K})^2} (11.27607 - 2)\n$$\n$$\nS \\approx \\frac{1}{2} (1.26733 \\times 10^{-5}) \\frac{(11.27607)(360000)}{1638400} (9.27607)\n$$\n$$\nS \\approx \\frac{1}{2} (1.26733 \\times 10^{-5}) (2.47764) (9.27607) \\approx 1.45521 \\times 10^{-4}\n$$\n最后，我们计算 $\\tilde{f(Z)}$ 的近似值：\n$$\n\\tilde{f(Z)} \\approx f(\\tilde{Z}) + \\widetilde{Z''^2} S\n$$\n$$\n\\tilde{f(Z)} \\approx 1.26733 \\times 10^{-5} + (0.010)(1.45521 \\times 10^{-4})\n$$\n$$\n\\tilde{f(Z)} \\approx 1.26733 \\times 10^{-5} + 1.45521 \\times 10^{-6} \\approx 1.41285 \\times 10^{-5}\n$$\n将结果四舍五入至四位有效数字：\n- $\\tilde{f(Z)} \\approx 1.413 \\times 10^{-5}$\n- $S \\approx 1.455 \\times 10^{-4}$\n\n最终结果是数对 $(\\tilde{f(Z)}, S)$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1.413 \\times 10^{-5}  1.455 \\times 10^{-4}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "本章的最后，我们将理论与应用付诸于实际的计算实现。计算法夫尔平均量需要对 Beta-PDF 加权的函数进行积分，正如上一个练习所示。本练习的核心是设计一种专门的数值方法（高斯-雅可比求积），该方法对于此类积分任务具有极高的效率和准确性，即使在 PDF 呈现奇异行为时也是如此（当 $\\alpha  1$ 或 $\\beta  1$ 时）。这突显了理解模型数学结构如何指导我们开发卓越数值算法的重要性。",
            "id": "4009851",
            "problem": "考虑一个定义在区间 $[0,1]$ 上的守恒标量混合分数 $Z$，其在湍流反应流中的统计变异性由 Beta 概率密度函数 (PDF) 建模，形状参数为 $\\alpha \\in \\mathbb{R}_{0}$ 和 $\\beta \\in \\mathbb{R}_{0}$。在 Beta-PDF 建模中，核心的数值任务是重复计算形如下式的加权积分：\n$$\n\\int_{0}^{1} f(Z)\\,Z^{\\alpha-1}(1-Z)^{\\beta-1}\\,\\mathrm{d}Z,\n$$\n其中 $f$ 是表示热化学性质映射、表格化封闭项或解析函数的光滑函数。你的目标是设计一种高斯型求积方案，该方案利用在适当权重下的正交性，来高效且准确地对上述表达式进行积分。\n\n从有限区间上具有非负权函数的正交多项式和高斯求积的基本定义出发，仅使用保持权重的变量替换和多项式精确性性质，推导一个针对权重 $w(Z)=Z^{\\alpha-1}(1-Z)^{\\beta-1}$ 在区间 $[0,1]$ 上的 $n$ 点求积公式。解释求积节点和权重如何由正交性确定，为什么这种构造对于 Beta 加权积分是高效的，以及当 $\\alpha$ 和 $\\beta$ 在大范围内变化时（包括当 $\\alpha  1$ 或 $\\beta  1$ 时出现的可积端点奇点），区间映射如何确保数值稳定性。不要在问题陈述中使用或引用任何预先推导的快捷公式；你的方法应基于第一性原理和关于正交多项式的经过充分检验的事实。\n\n然后，将推导出的方案实现为一个程序，该程序针对一个指定的测试套件，为每个案例计算积分的求积近似值，将其与参考值进行比较，并返回绝对误差。对于那些可以通过 Beta 函数 $\\mathrm{B}(\\cdot,\\cdot)$ 的基本性质知道精确积分值的测试案例，使用该精确值作为参考。否则，使用高精度一维数值积分来获得被积函数 $f(Z)\\,Z^{\\alpha-1}(1-Z)^{\\beta-1}$ 在 $[0,1]$ 上的参考值。当出现三角函数时，将角度解释为弧度。\n\n实现以下测试套件，每个案例由 $(\\alpha,\\beta,n,f)$ 指定，其中 $n$ 是求积阶数，$f$ 是被积函数：\n- 案例 1：$(\\alpha,\\beta,n,f)=(2,5,3, f(Z)=1)$；参考值为 $\\mathrm{B}(2,5)$。\n- 案例 2：$(\\alpha,\\beta,n,f)=(0.7,1.3,2, f(Z)=Z^{3})$；参考值为 $\\mathrm{B}(0.7+3,1.3)$。\n- 案例 3：$(\\alpha,\\beta,n,f)=(3.5,4.0,8, f(Z)=\\exp(-7Z))$；使用高精度数值积分。\n- 案例 4：$(\\alpha,\\beta,n,f)=(0.3,0.6,12, f(Z)=\\sqrt{Z})$；使用高精度数值积分。\n- 案例 5：$(\\alpha,\\beta,n,f)=(50.0,50.0,16, f(Z)=\\sin(\\pi Z))$; 使用高精度数值积分，参数为弧度。\n- 案例 6：$(\\alpha,\\beta,n,f)=(80.0,3.0,16, f(Z)=\\frac{Z^{2}}{0.1+Z})$; 使用高精度数值积分。\n\n你的程序必须产生单行输出，其中包含六个测试案例的绝对误差，形式为方括号括起来的逗号分隔列表（例如，“[e1,e2,e3,e4,e5,e6]”）。不涉及物理单位，所有量均为无量纲。程序必须是自包含的，且不得读取任何输入。",
            "solution": "该问题要求推导并实现一个针对由 Beta 概率密度函数 (PDF) 加权的积分的定制高斯求积方案。该积分的形式为：\n$$\nI = \\int_{0}^{1} f(Z)\\,Z^{\\alpha-1}(1-Z)^{\\beta-1}\\,\\mathrm{d}Z\n$$\n其中 $Z^{\\alpha-1}(1-Z)^{\\beta-1}$ 是 Beta 分布 PDF 的核心部分，$f(Z)$ 是一个光滑函数。\n\n解决方案的基础在于高斯求积理论。对于一个带有非负权函数 $w(x)$、形式为 $\\int_{a}^{b} g(x)w(x)\\,\\mathrm{d}x$ 的积分，一个 $n$ 点高斯求积公式提供如下近似：\n$$\n\\int_{a}^{b} g(x)w(x)\\,\\mathrm{d}x \\approx \\sum_{i=1}^{n} w_i g(x_i)\n$$\n构造此求积法则是为了使其对任何次数最高为 $2n-1$ 的多项式函数 $g(x)$ 都是精确的。当求积节点 $\\{x_i\\}_{i=1}^n$ 选为 $n$ 次多项式 $P_n(x)$ 的根时，可以达到这个最高的精确阶。该多项式 $P_n(x)$ 来自一个在区间 $[a,b]$ 上关于权函数 $w(x)$ 正交的多项式序列 $\\{P_k(x)\\}_{k=0}^{\\infty}$。也就是说，它们满足当 $k \\neq j$ 时 $\\int_{a}^{b} P_k(x)P_j(x)w(x)\\,\\mathrm{d}x = 0$。然后，权重 $\\{w_i\\}_{i=1}^n$ 由这些节点唯一确定。\n\n在我们的问题中，区间是 $[0,1]$，权函数是 $w(Z) = Z^{\\alpha-1}(1-Z)^{\\beta-1}$。与此权函数和区间相关的正交多项式是一种移位的 Jacobi 多项式。标准 Jacobi 多项式，记为 $P_n^{(a,b)}(x)$，在区间 $[-1,1]$ 上关于权函数 $(1-x)^a(1+x)^b$ 正交。为了利用成熟的算法来计算高斯-Jacobi 求积的节点和权重，我们进行变量替换，将我们的积分从 $[0,1]$ 映射到 $[-1,1]$。\n\n让我们应用线性变换 $Z = \\frac{x+1}{2}$。这将区间 $x \\in [-1,1]$ 映射到 $Z \\in [0,1]$。微分元为 $\\mathrm{d}Z = \\frac{1}{2}\\mathrm{d}x$。将此代入我们的积分 $I$：\n$$\nI = \\int_{-1}^{1} f\\left(\\frac{x+1}{2}\\right) \\left(\\frac{x+1}{2}\\right)^{\\alpha-1} \\left(1-\\frac{x+1}{2}\\right)^{\\beta-1} \\frac{1}{2}\\,\\mathrm{d}x\n$$\n化简各项：\n$$\n1 - \\frac{x+1}{2} = \\frac{2 - (x+1)}{2} = \\frac{1-x}{2}\n$$\n积分变为：\n$$\nI = \\int_{-1}^{1} f\\left(\\frac{x+1}{2}\\right) \\frac{(x+1)^{\\alpha-1}}{2^{\\alpha-1}} \\frac{(1-x)^{\\beta-1}}{2^{\\beta-1}} \\frac{1}{2}\\,\\mathrm{d}x\n$$\n$$\nI = \\frac{1}{2^{\\alpha+\\beta-1}} \\int_{-1}^{1} f\\left(\\frac{x+1}{2}\\right) (1-x)^{\\beta-1}(1+x)^{\\alpha-1}\\,\\mathrm{d}x\n$$\n这个变换后的积分现在是适用于区间 $[-1,1]$ 上标准高斯-Jacobi 求积的形式。待积函数为 $g(x) = f\\left(\\frac{x+1}{2}\\right)$，权函数为 $(1-x)^{\\beta-1}(1+x)^{\\alpha-1}$。这对应于标准 Jacobi 权重 $(1-x)^a(1+x)^b$，其参数为 $a = \\beta-1$ 和 $b = \\alpha-1$。\n\n令 $\\{x_i^{\\text{GJ}}\\}_{i=1}^n$ 为参数为 $a=\\beta-1$ 和 $b=\\alpha-1$ 的 $n$ 点高斯-Jacobi 求积的节点，$\\{w_i^{\\text{GJ}}\\}_{i=1}^n$ 为其权重。节点 $x_i^{\\text{GJ}}$ 是 Jacobi 多项式 $P_n^{(\\beta-1, \\alpha-1)}(x)$ 的根。在 $[-1,1]$ 上的积分的求积近似值为：\n$$\n\\int_{-1}^{1} g(x)(1-x)^{\\beta-1}(1+x)^{\\alpha-1}\\,\\mathrm{d}x \\approx \\sum_{i=1}^{n} w_i^{\\text{GJ}} g(x_i^{\\text{GJ}})\n$$\n代入我们的函数 $g(x) = f\\left(\\frac{x+1}{2}\\right)$ 并结合缩放因子，我们得到原始积分 $I$ 的近似值：\n$$\nI \\approx \\frac{1}{2^{\\alpha+\\beta-1}} \\sum_{i=1}^{n} w_i^{\\text{GJ}} f\\left(\\frac{x_i^{\\text{GJ}}+1}{2}\\right)\n$$\n这个公式提供了一个完整的算法。然而，直接为目标区间 $[0,1]$ 和 Beta-PDF 权重定义一组节点 $\\{Z_i\\}_{i=1}^n$ 和权重 $\\{w_i^{\\text{B}}\\}_{i=1}^n$ 在概念上更为清晰。节点就是映射后的 Jacobi 节点：\n$$\nZ_i = \\frac{x_i^{\\text{GJ}}+1}{2}\n$$\n对应的用于 $[0,1]$ 积分的权重是缩放后的 Jacobi 权重：\n$$\nw_i^{\\text{B}} = \\frac{w_i^{\\text{GJ}}}{2^{\\alpha+\\beta-1}}\n$$\n这种缩放确保了正确性。例如，当 $f(Z)=1$ 时，积分为 $\\mathrm{B}(\\alpha,\\beta)$。标准 Jacobi 权重的和为 $\\sum w_i^{\\text{GJ}} = \\int_{-1}^1 (1-x)^{\\beta-1}(1+x)^{\\alpha-1}\\,\\mathrm{d}x = 2^{\\alpha+\\beta-1}\\mathrm{B}(\\alpha,\\beta)$。我们的求积公式给出 $\\sum w_i^{\\text{B}} \\cdot 1 = \\frac{1}{2^{\\alpha+\\beta-1}}\\sum w_i^{\\text{GJ}} = \\mathrm{B}(\\alpha,\\beta)$，这正如所要求的那样是精确的。\n\n最终得到的用于 Beta-PDF 加权积分的求积法则是：\n$$\n\\int_{0}^{1} f(Z)\\,Z^{\\alpha-1}(1-Z)^{\\beta-1}\\,\\mathrm{d}Z \\approx \\sum_{i=1}^{n} w_i^{\\text{B}} f(Z_i)\n$$\n\n这种构造是高效的，因为它利用了高斯求积的高阶多项式精确性。在燃烧模型中，函数 $f(Z)$ 通常是光滑的，并且能被多项式很好地近似，从而随着 $n$ 的增加导致快速收敛。该方法特别强大，因为权函数 $w(Z)=Z^{\\alpha-1}(1-Z)^{\\beta-1}$（当 $\\alpha  1$ 或 $\\beta  1$ 时，它可能在端点包含可积奇点）被求积构造解析地处理了。求积节点和权重内在地适应了此权重，在 Beta-PDF 具有最大概率质量的地方对 $f(Z)$ 进行最密集的采样，而无需用户对奇点进行离散化。\n\n该方案的数值稳定性极佳。计算正交多项式的根和权重是数值分析中的一个经典问题。现代程序库使用稳定的算法，例如 Golub-Welsch 算法，该算法将问题与寻找一个对称三对角矩阵（Jacobi 矩阵）的特征值联系起来。这是一个良态计算。通过依赖这些用于规范区间 $[-1,1]$ 的稳健例程，然后应用一个简单的、非病态的线性映射来获得 $[0,1]$ 上的节点，我们继承了这种稳定性。这确保了即使对于大的 $n$ 或导致高度峰化或奇异 PDF 的参数 $\\alpha, \\beta$，计算仍然是可靠的。\n\n实现将按以下步骤进行：\n1. 对于一组给定的参数 $(\\alpha, \\beta, n, f)$，将 Jacobi 参数设置为 $a = \\beta-1$ 和 $b = \\alpha-1$。\n2. 使用标准库函数（例如，`scipy.special.roots_jacobi`）来计算区间 $[-1,1]$ 的 $n$ 个高斯-Jacobi 节点 $\\{x_i^{\\text{GJ}}\\}$ 和权重 $\\{w_i^{\\text{GJ}}\\}$。\n3. 通过 $Z_i = (x_i^{\\text{GJ}}+1)/2$ 将节点变换到目标区间 $[0,1]$。\n4. 通过 $w_i^{\\text{B}} = w_i^{\\text{GJ}} / 2^{\\alpha+\\beta-1}$ 缩放目标区间的权重。\n5. 在每个节点 $Z_i$ 处计算函数 $f$ 的值。\n6. 将积分近似值计算为加权和 $\\sum_{i=1}^{n} w_i^{\\text{B}} f(Z_i)$。\n7. 将此结果与参考值（通过 Beta 函数得到的精确值或通过高精度通用数值积分计算的值）进行比较，以求得绝对误差。\n对每个指定的测试案例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_jacobi, beta\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Derives and applies a Gauss-Jacobi quadrature scheme for Beta-PDF weighted\n    integrals, and computes the absolute error against reference values\n    for a suite of test cases.\n    \"\"\"\n\n    def gauss_beta_quadrature(alpha, beta_param, n, f):\n        \"\"\"\n        Computes the integral of f(Z) * Z^(alpha-1) * (1-Z)^(beta-1) from 0 to 1\n        using an n-point custom Gaussian quadrature.\n\n        Args:\n            alpha (float): Shape parameter of the Beta distribution.\n            beta_param (float): Shape parameter of the Beta distribution.\n            n (int): Number of quadrature points.\n            f (callable): A vectorized function f(Z).\n\n        Returns:\n            float: The approximated integral value.\n        \"\"\"\n        # The integral on [0,1] with weight w(Z) = Z^(alpha-1)*(1-Z)^(beta-1)\n        # is transformed to an integral on [-1,1] with a standard Jacobi weight.\n        # The Jacobi polynomial P_n^(a,b)(x) is orthogonal with respect to\n        # the weight (1-x)^a * (1+x)^b.\n        # The transformation Z = (x+1)/2 maps our weight to a form proportional\n        # to (1-x)^(beta-1) * (1+x)^(alpha-1).\n        # Thus, the required Jacobi parameters are a = beta-1 and b = alpha-1.\n        a_jacobi = beta_param - 1\n        b_jacobi = alpha - 1\n\n        # Get the standard Gauss-Jacobi nodes and weights for the interval [-1, 1].\n        # scipy.special.roots_jacobi provides these for the integral\n        # integral_{-1}^{1} g(x) (1-x)^a (1+x)^b dx approx sum(w_jacobi * g(x_nodes))\n        x_nodes, w_jacobi = roots_jacobi(n, a_jacobi, b_jacobi)\n\n        # Map the nodes from [-1, 1] to the target interval [0, 1].\n        z_nodes = (x_nodes + 1.0) / 2.0\n\n        # As derived, the integral I = (1/2**(alpha+beta-1)) * sum(w_jacobi_i * f(Z_i)).\n        # We can define weights for the [0,1] interval as w_beta = w_jacobi / 2**(a+b+1).\n        # This gives I = sum(w_beta_i * f(Z_i)).\n        \n        # Evaluate the function f at the transformed nodes.\n        f_vals = f(z_nodes)\n\n        # Scale the weights and compute the final sum.\n        # The scaling factor is 2**(a_jacobi + b_jacobi + 1) = 2**(alpha + beta_param - 1)\n        scaling_factor = 2.0**(alpha + beta_param - 1.0)\n        \n        integral_approx = np.sum(w_jacobi * f_vals) / scaling_factor\n\n        return integral_approx\n\n    # Define the test suite\n    # Each case: (alpha, beta, n, f, reference_type, reference_calculator)\n    test_cases = [\n        (2.0, 5.0, 3, lambda Z: 1.0, \n         'exact', lambda a,b: beta(a, b)),\n        \n        (0.7, 1.3, 2, lambda Z: Z**3, \n         'exact', lambda a,b: beta(a + 3.0, b)),\n\n        (3.5, 4.0, 8, lambda Z: np.exp(-7.0 * Z), \n         'numerical', None),\n\n        (0.3, 0.6, 12, lambda Z: np.sqrt(Z),\n         'numerical', None),\n\n        (50.0, 50.0, 16, lambda Z: np.sin(np.pi * Z),\n         'numerical', None),\n\n        (80.0, 3.0, 16, lambda Z: Z**2 / (0.1 + Z),\n         'numerical', None),\n    ]\n\n    absolute_errors = []\n\n    for case in test_cases:\n        alpha, beta_param, n, f, ref_type, ref_func = case\n\n        # Calculate the integral using the derived quadrature scheme\n        approx_val = gauss_beta_quadrature(alpha, beta_param, n, f)\n\n        # Calculate the reference value\n        if ref_type == 'exact':\n            ref_val = ref_func(alpha, beta_param)\n        else:  # 'numerical'\n            integrand = lambda Z: f(Z) * (Z**(alpha - 1.0)) * ((1.0 - Z)**(beta_param - 1.0))\n            ref_val, _ = quad(integrand, 0, 1, epsabs=1e-15, epsrel=1e-15)\n        \n        # Compute the absolute error\n        error = np.abs(approx_val - ref_val)\n        absolute_errors.append(f\"{error:.16e}\")\n\n    # Print the final result in the required format\n    print(f\"[{','.join(absolute_errors)}]\")\n\nsolve()\n```"
        }
    ]
}