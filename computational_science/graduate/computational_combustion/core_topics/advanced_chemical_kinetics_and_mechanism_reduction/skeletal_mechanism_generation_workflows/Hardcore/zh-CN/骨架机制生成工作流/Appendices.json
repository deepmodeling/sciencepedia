{
    "hands_on_practices": [
        {
            "introduction": "准稳态近似（Quasi-Steady-State Assumption, QSSA）是简化化学反应动力学中刚性系统的基石方法。本练习  将引导您将其应用于一个简单但具有代表性的链式支链反应机理。通过此实践，您将学习如何基于时间尺度分析来识别快反应物种，推导简化的代数-微分方程组，并通过比较完整模型与简化模型的着火延迟时间来量化近似所引入的误差。这是理解和应用模型简化的核心技能。",
            "id": "4063463",
            "problem": "给定一个空间均匀、恒压、绝热反应器中的基元链式支化燃烧机理。物种组为 $\\{A,B,R,P\\}$，其中 $A$ 是燃料，$B$ 是氧化剂，$R$ 是自由基，$P$ 是稳定产物。该机理包含以下遵循质量作用定律的基元反应：\n- $A + B \\xrightarrow{k_1(T)} R$ (链引发),\n- $R + B \\xrightarrow{k_2(T)} 2R$ (链支化),\n- $R + R \\xrightarrow{k_3(T)} P$ (链终止),\n- $A + R \\xrightarrow{k_4(T)} P + R$ (链增长).\n\n此处 $T$ 为混合物的温度，$k_i(T)$ 是依赖于温度的速率常数，由阿伦尼乌斯型表达式 $k_i(T) = A_i \\exp\\left(-\\dfrac{E_i}{R_u T}\\right)$（对于 $i \\in \\{1,2,4\\}$）给出，而 $k_3(T) = A_3$ 的活化能可忽略不计。通用气体常数为 $R_u = 8.314 \\,\\text{J}\\,\\text{mol}^{-1}\\,\\text{K}^{-1}$。浓度由 $[A] = a$、$[B] = b$、$[R] = r$ 和 $[P] = p$ 表示，单位为 $\\text{mol}\\,\\text{m}^{-3}$。各反应的摩尔反应热分别为 $Q_1,Q_2,Q_3,Q_4$，单位为 $\\text{J}\\,\\text{mol}^{-1}$。热力学参数包括密度 $\\rho$（单位为 $\\text{kg}\\,\\text{m}^{-3}$）和恒压定比热容 $C_p$（单位为 $\\text{J}\\,\\text{kg}^{-1}\\,\\text{K}^{-1}$）。\n\n从化学动力学（质量作用）和绝热恒压条件下的能量守恒基本定律出发，您必须：\n1. 基于初始状态下的局部时间尺度分离准则，识别准稳态（QSS）的候选自由基。对于浓度为 $c_i$ 的物种 $i$，根据初始时刻的完整常微分方程组计算其特征时间尺度，定义为 $\\tau_i = \\dfrac{c_i}{|dc_i/dt|}$。如果比值 $\\tau_R/\\tau_A$ 小于给定的阈值参数 $\\theta$，则声明 $R$ 为一个QSS自由基。\n2. 在对 $R$ 的QSS假设下，通过消除 $dr/dt$ 并将 $r$ 替换为一个代数函数 $r_{\\mathrm{QSS}}(a,b,T)$（该函数强制 $dr/dt \\approx 0$），推导出简化的常微分方程（ODE）组。\n3. 计算点火延迟时间 $\\tau_{\\mathrm{ign}}$，定义为温度 $T(t)$ 首次超过阈值 $T_{\\mathrm{ign}} = T_0 + \\Delta T$ 的时间，其中 $T_0$ 是初始温度，$\\Delta T$ 是指定的温升。如果在指定的结束时间 $t_{\\mathrm{end}}$ 之前没有超过该阈值，则设 $\\tau_{\\mathrm{ign}} = t_{\\mathrm{end}}$。\n4. 估算完整模型和简化模型之间点火延迟的绝对误差，即计算 $|\\tau_{\\mathrm{ign}}^{\\mathrm{full}} - \\tau_{\\mathrm{ign}}^{\\mathrm{red}}|$，以秒为单位。\n\n所有变量和常量必须遵循以下单位：$a,b,r,p$ 的单位为 $\\text{mol}\\,\\text{m}^{-3}$，$T$ 的单位为 $\\text{K}$，时间的单位为 $\\text{s}$，$k_1,k_2,k_4$ 的单位为 $\\text{m}^3\\,\\text{mol}^{-1}\\,\\text{s}^{-1}$，$k_3$ 的单位为 $\\text{m}^3\\,\\text{mol}^{-1}\\,\\text{s}^{-1}$，$Q_i$ 的单位为 $\\text{J}\\,\\text{mol}^{-1}$，$\\rho$ 的单位为 $\\text{kg}\\,\\text{m}^{-3}$，$C_p$ 的单位为 $\\text{J}\\,\\text{kg}^{-1}\\,\\text{K}^{-1}$。点火延迟误差以秒为单位作答。\n\n您必须实现一个完整的程序，该程序能够：\n- 在质量作用动力学和能量方程下，对 $(a,b,r,T)$ 的完整ODE系统进行积分，\n- 使用QSS准则来决定是否通过消除 $r$（借助 $dr/dt \\approx 0$）来简化系统；如果未对 $R$ 选择QSS，则简化系统与完整系统相同，\n- 计算两个模型的点火延迟并返回绝对误差。\n\n对动力学和热力学使用以下固定参数值：\n- $A_1 = 5\\times 10^7$, $E_1 = 7.0\\times 10^4 \\,\\text{J}\\,\\text{mol}^{-1}$,\n- $A_2 = 2\\times 10^8$, $E_2 = 6.0\\times 10^4 \\,\\text{J}\\,\\text{mol}^{-1}$,\n- $A_3 = 1\\times 10^4$,\n- $A_4 = 1\\times 10^7$, $E_4 = 5.0\\times 10^4 \\,\\text{J}\\,\\text{mol}^{-1}$,\n- $Q_1 = 0$, $Q_2 = 1.0\\times 10^5 \\,\\text{J}\\,\\text{mol}^{-1}$, $Q_3 = 0$, $Q_4 = 2.0\\times 10^4 \\,\\text{J}\\,\\text{mol}^{-1}$,\n- $\\rho = 1.0 \\,\\text{kg}\\,\\text{m}^{-3}$, $C_p = 1000 \\,\\text{J}\\,\\text{kg}^{-1}\\,\\text{K}^{-1}$,\n- $R_u = 8.314 \\,\\text{J}\\,\\text{mol}^{-1}\\,\\text{K}^{-1}$.\n\n您的程序必须应用以下初始条件和控制参数 $(a_0,b_0,r_0,T_0,\\Delta T,\\theta,t_{\\mathrm{end}})$ 的测试套件：\n- 案例1（基准链式支化点火）：$(1.0, 2.0, 1.0\\times 10^{-9}, 1000.0, 50.0, 0.2, 0.01)$,\n- 案例2（初始自由基浓度升高时的临界QSS）：$(1.0, 0.8, 5.0\\times 10^{-2}, 1000.0, 50.0, 0.05, 0.02)$,\n- 案例3（低温、慢动力学）：$(0.5, 0.5, 1.0\\times 10^{-9}, 800.0, 50.0, 0.2, 0.05)$.\n\n您的程序应生成单行输出，其中包含三个案例的点火延迟绝对误差，格式为方括号内以逗号分隔的列表（例如，“[$e_1,e_2,e_3$]”），其中每个 $e_i$ 是一个以秒为单位的浮点数。数值输出必须以秒为单位，并且必须能根据指定的输入确定性地计算出来，无需任何外部数据。",
            "solution": "该问题要求分析一个简化的链式支化燃烧机理，并比较完整动力学模型与在准稳态假设（QSSA）下推导出的简化模型。分析过程包括推导控制常微分方程（ODE），应用基于时间尺度的准则来验证QSSA的合理性，推导简化模型，并数值计算两个模型的点火延迟时间，以量化简化所引入的误差。\n\n### 1. 完整动力学模型\n\n反应机理涉及四种物种：燃料（$A$）、氧化剂（$B$）、自由基（$R$）和产物（$P$），由四个基元反应控制：\n1.  $A + B \\xrightarrow{k_1(T)} R$\n2.  $R + B \\xrightarrow{k_2(T)} 2R$\n3.  $R + R \\xrightarrow{k_3(T)} P$\n4.  $A + R \\xrightarrow{k_4(T)} P + R$\n\n速率常数 $k_i(T)$ 由阿伦尼乌斯型表达式 $k_i(T) = A_i \\exp(-E_i / (R_u T))$（对于 $i \\in \\{1, 2, 4\\}$）和 $k_3(T) = A_3$ 给出。这些反应的净反应速率（用 $\\omega_i$ 表示）由质量作用定律给出，其中浓度为 $[A]=a, [B]=b, [R]=r$：\n$$ \\omega_1 = k_1(T) a b $$\n$$ \\omega_2 = k_2(T) r b $$\n$$ \\omega_3 = k_3(T) r^2 $$\n$$ \\omega_4 = k_4(T) a r $$\n\n在空间均匀系统中，物种浓度随时间的演化由以下常微分方程组描述：\n$$ \\frac{da}{dt} = -\\omega_1 - \\omega_4 = -k_1(T)ab - k_4(T)ar $$\n$$ \\frac{db}{dt} = -\\omega_1 - \\omega_2 = -k_1(T)ab - k_2(T)rb $$\n$$ \\frac{dr}{dt} = +\\omega_1 + \\omega_2 - 2\\omega_3 = k_1(T)ab + k_2(T)rb - 2k_3(T)r^2 $$\n注意，反应4是一个链增长步骤，其中一个自由基 $R$ 被消耗，同时生成一个，导致 $R$ 的浓度没有净变化。\n\n对于恒压、绝热反应器，能量守恒方程为：\n$$ \\rho C_p \\frac{dT}{dt} = \\sum_{i=1}^{4} Q_i \\omega_i $$\n鉴于 $Q_1 = 0$ 和 $Q_3 = 0$，该方程简化为：\n$$ \\frac{dT}{dt} = \\frac{1}{\\rho C_p} (Q_2 \\omega_2 + Q_4 \\omega_4) = \\frac{r}{\\rho C_p} \\left( Q_2 k_2(T) b + Q_4 k_4(T) a \\right) $$\n\n这四个关于状态向量 $\\mathbf{y}(t) = [a(t), b(t), r(t), T(t)]^T$ 的耦合非线性常微分方程构成了完整的动力学模型。\n\n### 2. 准稳态（QSS）分析\n\nQSSA适用于反应活性极高的中间物种（自由基），其特征反应时间尺度远小于主要物种的特征反应时间尺度。我们在初始状态（$t=0$）下评估此条件。对于浓度为 $c_i$ 的物种 $i$，其特征时间尺度定义为 $\\tau_i = \\dfrac{c_i}{|dc_i/dt|}$。\n\n在 $t=0$ 时，使用初始条件 $(a_0, b_0, r_0, T_0)$，我们计算初始速率：\n$$ \\left(\\frac{da}{dt}\\right)_0 = -k_1(T_0)a_0b_0 - k_4(T_0)a_0r_0 $$\n$$ \\left(\\frac{dr}{dt}\\right)_0 = k_1(T_0)a_0b_0 + k_2(T_0)b_0r_0 - 2k_3(T_0)r_0^2 $$\n\n燃料 $A$ 和自由基 $R$ 的初始时间尺度为：\n$$ \\tau_A = \\frac{a_0}{\\left|\\left(\\frac{da}{dt}\\right)_0\\right|} = \\frac{a_0}{k_1(T_0)a_0b_0 + k_4(T_0)a_0r_0} = \\frac{1}{k_1(T_0)b_0 + k_4(T_0)r_0} $$\n$$ \\tau_R = \\frac{r_0}{\\left|\\left(\\frac{dr}{dt}\\right)_0\\right|} = \\frac{r_0}{\\left| k_1(T_0)a_0b_0 + k_2(T_0)b_0r_0 - 2k_3(T_0)r_0^2 \\right|} $$\n\n如果自由基 $R$ 的时间尺度与燃料 $A$ 的时间尺度之比小于预设阈值 $\\theta$，则认为对自由基 $R$ 的QSS假设是有效的：\n$$ \\frac{\\tau_R}{\\tau_A}  \\theta $$\n\n### 3. 简化动力学模型（QSS模型）\n\n如果满足QSS准则，我们可以通过假设自由基 $R$ 的净生成速率约等于零（即 $dr/dt \\approx 0$）来简化系统。这将关于 $r$ 的微分方程转化为一个代数方程：\n$$ k_1(T)ab + k_2(T)rb - 2k_3(T)r^2 = 0 $$\n整理后得到关于自由基的QSS浓度 $r_{\\mathrm{QSS}}$ 的二次方程：\n$$ 2k_3(T)r^2 - k_2(T)br - k_1(T)ab = 0 $$\n使用二次公式求解 $r$ 并选择具有物理意义的正根，得到：\n$$ r_{\\mathrm{QSS}}(a,b,T) = \\frac{k_2(T)b + \\sqrt{\\left(k_2(T)b\\right)^2 + 8k_1(T)k_3(T)ab}}{4k_3(T)} $$\n\n完整的ODE系统随后被简化为关于状态向量 $\\mathbf{y}_{\\mathrm{red}}(t) = [a(t), b(t), T(t)]^T$ 的三个ODE组成的系统。$R$ 的浓度不再是状态变量，而是在每个时间步通过 $r_{\\mathrm{QSS}}$ 的代数表达式来诊断计算：\n$$ \\frac{da}{dt} = -k_1(T)ab - k_4(T)a \\cdot r_{\\mathrm{QSS}}(a,b,T) $$\n$$ \\frac{db}{dt} = -k_1(T)ab - k_2(T)b \\cdot r_{\\mathrm{QSS}}(a,b,T) $$\n$$ \\frac{dT}{dt} = \\frac{r_{\\mathrm{QSS}}(a,b,T)}{\\rho C_p} \\left( Q_2 k_2(T) b + Q_4 k_4(T) a \\right) $$\n此简化系统使用初始条件 $(a_0, b_0, T_0)$ 进行积分。\n\n### 4. 数值解与点火延迟计算\n\n点火延迟时间 $\\tau_{\\mathrm{ign}}$ 定义为温度首次达到阈值 $T_{\\mathrm{ign}} = T_0 + \\Delta T$ 的时间 $t$。我们使用数值ODE求解器（具体为 `scipy.integrate.solve_ivp`）来求解完整系统和简化系统的初值问题。该函数的事件检测功能用于精确确定穿越阈值的时刻。事件由条件 $T(t) - T_{\\mathrm{ign}} = 0$ 定义。如果事件在指定的结束时间 $t_{\\mathrm{end}}$ 之前没有发生，则将 $\\tau_{\\mathrm{ign}}$ 设为 $t_{\\mathrm{end}}$。\n\n对于每个测试案例，我们通过积分完整系统来计算 $\\tau_{\\mathrm{ign}}^{\\mathrm{full}}$。然后，我们执行QSS检查。如果满足准则，我们通过积分简化系统来计算 $\\tau_{\\mathrm{ign}}^{\\mathrm{red}}$。如果不满足准则，则认为简化模型与完整模型相同，因此我们设置 $\\tau_{\\mathrm{ign}}^{\\mathrm{red}} = \\tau_{\\mathrm{ign}}^{\\mathrm{full}}$，从而导致建模误差为零。最后，计算绝对误差 $|\\tau_{\\mathrm{ign}}^{\\mathrm{full}} - \\tau_{\\mathrm{ign}}^{\\mathrm{red}}|$。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the combustion problem for a series of test cases, calculating the\n    error in ignition delay time between full and QSS-reduced models.\n    \"\"\"\n\n    # Fixed physical and chemical parameters\n    params = {\n        'A1': 5e7, 'E1': 7.0e4, 'Q1': 0.0,\n        'A2': 2e8, 'E2': 6.0e4, 'Q2': 1.0e5,\n        'A3': 1e4, 'E3': 0.0, 'Q3': 0.0,\n        'A4': 1e7, 'E4': 5.0e4, 'Q4': 2.0e4,\n        'rho': 1.0, 'Cp': 1000.0, 'Ru': 8.314\n    }\n\n    # Test cases: (a0, b0, r0, T0, delta_T, theta, t_end)\n    test_cases = [\n        # Case 1: baseline chain-branching ignition\n        (1.0, 2.0, 1.0e-9, 1000.0, 50.0, 0.2, 0.01),\n        # Case 2: borderline QSS with elevated initial radical\n        (1.0, 0.8, 5.0e-2, 1000.0, 50.0, 0.05, 0.02),\n        # Case 3: low-temperature, slow kinetics\n        (0.5, 0.5, 1.0e-9, 800.0, 50.0, 0.2, 0.05),\n    ]\n\n    simulator = CombustionSimulator(params)\n    results = []\n    for case in test_cases:\n        error = simulator.run_case(case)\n        results.append(error)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\n\nclass CombustionSimulator:\n    \"\"\"\n    A class to encapsulate the combustion model, parameters, and solution logic.\n    \"\"\"\n    def __init__(self, params):\n        self.p = params\n        self.eps = np.finfo(float).eps\n\n    def _calculate_k(self, T):\n        \"\"\"Calculates Arrhenius rate constants at a given temperature T.\"\"\"\n        k1 = self.p['A1'] * np.exp(-self.p['E1'] / (self.p['Ru'] * T))\n        k2 = self.p['A2'] * np.exp(-self.p['E2'] / (self.p['Ru'] * T))\n        k3 = self.p['A3']  # E3 = 0\n        k4 = self.p['A4'] * np.exp(-self.p['E4'] / (self.p['Ru'] * T))\n        return k1, k2, k3, k4\n\n    def _rhs_full(self, t, y):\n        \"\"\"Right-hand side function for the full ODE system.\"\"\"\n        a, b, r, T = y\n        k1, k2, k3, k4 = self._calculate_k(T)\n\n        # To prevent negative concentrations from numerical errors\n        a = max(0, a)\n        b = max(0, b)\n        r = max(0, r)\n\n        # Reaction rates\n        omega1 = k1 * a * b\n        omega2 = k2 * r * b\n        omega3 = k3 * r * r\n        omega4 = k4 * a * r\n\n        # Species ODEs\n        dadt = -omega1 - omega4\n        dbdt = -omega1 - omega2\n        drdt = omega1 + omega2 - 2 * omega3\n\n        # Energy ODE\n        dTdt = (self.p['Q2'] * omega2 + self.p['Q4'] * omega4) / (self.p['rho'] * self.p['Cp'])\n\n        return [dadt, dbdt, drdt, dTdt]\n\n    def _rhs_reduced(self, t, y):\n        \"\"\"Right-hand side function for the QSS-reduced ODE system.\"\"\"\n        a, b, T = y\n        k1, k2, k3, k4 = self._calculate_k(T)\n        \n        # To prevent negative concentrations from numerical errors\n        a = max(0, a)\n        b = max(0, b)\n\n        # QSS radical concentration r_qss\n        # 2*k3*r^2 - k2*b*r - k1*a*b = 0\n        term_sqrt = np.sqrt((k2 * b)**2 + 8 * k1 * k3 * a * b)\n        r_qss = (k2 * b + term_sqrt) / (4 * k3 + self.eps)\n        \n        # Species ODEs with r_qss\n        dadt = -k1 * a * b - k4 * a * r_qss\n        dbdt = -k1 * a * b - k2 * b * r_qss\n\n        # Energy ODE with r_qss\n        dTdt = (r_qss / (self.p['rho'] * self.p['Cp'])) * (self.p['Q2'] * k2 * b + self.p['Q4'] * k4 * a)\n\n        return [dadt, dbdt, dTdt]\n\n    def _check_qss(self, a0, b0, r0, T0, theta):\n        \"\"\"Checks if the QSS assumption is valid based on the timescale criterion.\"\"\"\n        k1_0, k2_0, k3_0, k4_0 = self._calculate_k(T0)\n\n        # Initial rate of change for A\n        dadt_0 = -k1_0 * a0 * b0 - k4_0 * a0 * r0\n        tau_A_denom = abs(dadt_0)\n        \n        # Initial rate of change for R\n        drdt_0 = k1_0 * a0 * b0 + k2_0 * b0 * r0 - 2 * k3_0 * r0**2\n        tau_R_denom = abs(drdt_0)\n\n        # Handle cases where concentration or rate is zero\n        if tau_A_denom  self.eps: return False # Major species not changing, no timescale separation\n        if r0  self.eps or tau_R_denom  self.eps:\n            tau_R = 0.0 # Zero concentration or zero time derivative means infinite/zero timescale. Zero timescale is QSS.\n        else:\n            tau_R = r0 / tau_R_denom\n\n        tau_A = a0 / tau_A_denom\n        \n        if tau_A  self.eps: return False\n        \n        return (tau_R / tau_A)  theta\n\n    def _solve_for_ignition(self, rhs_func, y0, t_span, T_ign):\n        \"\"\"Integrates an ODE system and finds ignition time.\"\"\"\n        \n        num_vars = len(y0)\n        temp_idx = num_vars - 1\n\n        def ignition_event(t, y):\n            return y[temp_idx] - T_ign\n        ignition_event.terminal = True\n        ignition_event.direction = 1\n\n        sol = solve_ivp(\n            fun=rhs_func,\n            t_span=t_span,\n            y0=y0,\n            method='Radau',\n            events=ignition_event,\n            dense_output=True\n        )\n\n        if sol.t_events[0].size > 0:\n            return sol.t_events[0][0]\n        else:\n            return t_span[1]\n\n    def run_case(self, case_params):\n        \"\"\"Runs a single test case and returns the ignition delay error.\"\"\"\n        a0, b0, r0, T0, delta_T, theta, t_end = case_params\n        T_ign = T0 + delta_T\n        t_span = (0, t_end)\n\n        # 1. Solve full model\n        y0_full = [a0, b0, r0, T0]\n        tau_full = self._solve_for_ignition(self._rhs_full, y0_full, t_span, T_ign)\n        \n        # 2. Check QSS validity\n        is_qss_valid = self._check_qss(a0, b0, r0, T0, theta)\n\n        if is_qss_valid:\n            # 3. Solve reduced model\n            y0_red = [a0, b0, T0]\n            tau_red = self._solve_for_ignition(self._rhs_reduced, y0_red, t_span, T_ign)\n        else:\n            # Per problem spec, if QSS is not applied, reduced model is identical\n            # to full model, so the error is zero.\n            tau_red = tau_full\n        \n        # 4. Calculate absolute error\n        error = abs(tau_full - tau_red)\n        return error\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "在简化反应机理后，验证其预测精度是关键步骤，尤其是在预测特定目标（如污染物排放）时。本练习  关注一个至关重要的方面：机理简化对关键目标的影响。您将通过一个代理模型，研究剪枝一个次要含氮物种对一氧化氮（NO）预测的影响，并探讨废气再循环（EGR）如何调节这一影响。这项实践突出了面向目标的验证在骨架机理开发中的重要性，并帮助您建立对简化可能带来的意外后果的直觉。",
            "id": "4063497",
            "problem": "给定一个简化的、但有科学依据的工作流模型，用于评估在有和没有废气再循环（EGR）的情况下，在层流预混火焰模拟中，剪除一种次要含氮自由基对一氧化氮形成的影响。任务是实现一个程序，计算由于剪除导致的一氧化氮摩尔分数峰值的变化，并为骨架机理的调整提供算法建议。\n\n基本原理和假设：\n- 在一维稳态层流预混火焰中，物种守恒可以写为质量分数为 $Y_i$ 的物种的输运-反应平衡：$$\\frac{d}{dx}\\left(\\rho u Y_i\\right) = \\omega_i,$$ 其中 $\\rho$ 是密度，$u$ 是轴向速度，$\\omega_i$ 是物种 $i$ 的净化学源项。通过 $x = u t$ 引入停留时间 $t$，得到常微分方程（ODE）$$\\frac{d Y_i}{d t} = \\frac{\\omega_i}{\\rho}。$$\n- 在骨架机理生成中，剪除操作会移除在特定目标和条件下被认为是次要的物种（及相关反应）。在这里，剪除次要含氮自由基“氮-氮-氢”自由基（NNH）会消除其对一氧化氮（NO）生成的贡献。\n- 在碳氢-空气火焰中，一氧化氮（NO）的生成通过多种途径进行。一个简化的替代模型包括一个热力学氮途径（通常与扩展的Zeldovich机理相关）和一个NNH介导的途径，同时通过反应消耗NO来降低其总量。我们考虑一个简化速率的替代模型进行分析，该模型能捕捉到随EGR变化的定性趋势。\n\n需要实现的模型定义：\n- 沿停留时间 $t$ 的温度分布由一个平滑的类火焰剖面给出：$$T(t) = T_u + \\left(T_b - T_u\\right)\\exp\\left(-\\left(\\frac{t - t_0}{\\sigma}\\right)^2\\right),$$ 其中 $T_u$ 是未燃温度，$T_b$ 是已燃温度，$t_0$ 是峰值温度的位置，$\\sigma$ 控制热厚度。废气再循环（EGR）会降低 $T_b$，如下所示$$T_b(f) = T_{b,0}\\left(1 - \\beta f\\right),$$ 其中 $f$ 是EGR分数。\n- 局部氧化剂水平受EGR和反应进程的调节。设基础氧气摩尔分数为 $y_{\\mathrm{O_2},0}$。EGR会减少氧气，关系为 $y_{\\mathrm{O_2}}(f) = y_{\\mathrm{O_2},0}(1 - f)$。局部氧气可用性随反应进程 $c(t)$ 进一步降低：$$c(t) = \\frac{T(t) - T_u}{\\max\\left(T_b - T_u, \\varepsilon\\right)}, \\quad y_{\\mathrm{O_2,local}}(t; f) = y_{\\mathrm{O_2}}(f)\\left(1 - s_{\\mathrm{O_2}} c(t)\\right),$$ 其中 $\\varepsilon$ 是一个小的正数以避免除以零，而 $s_{\\mathrm{O_2}}$ 是一个可调参数。\n- 替代自由基的伪浓度通过Arrhenius型依赖关系依赖于温度：$$[\\mathrm{N}](t) = C_{\\mathrm{N}} \\exp\\left(-\\frac{E_{\\mathrm{N}}}{R T(t)}\\right)\\phi, \\quad [\\mathrm{O}](t) = C_{\\mathrm{O}} \\exp\\left(-\\frac{E_{\\mathrm{O}}}{R T(t)}\\right), \\quad [\\mathrm{NNH}](t) = s_{\\mathrm{NNH}} C_{\\mathrm{NNH}} \\exp\\left(-\\frac{E_{\\mathrm{NNH}}}{R T(t)}\\right),$$ 其中 $R$ 是通用气体常数，$E_{\\mathrm{N}}, E_{\\mathrm{O}}, E_{\\mathrm{NNH}}$ 是有效活化能，$C_{\\mathrm{N}}, C_{\\mathrm{O}}, C_{\\mathrm{NNH}}$ 是指前尺度常数，$\\phi$ 是当量比，$s_{\\mathrm{NNH}}$ 是用户指定的NNH池的缩放因子。剪除操作通过设置 $s_{\\mathrm{NNH}} = 0$ 来建模。\n- NO的简化源项结合了生成和消耗：$$\\frac{d[\\mathrm{NO}]}{dt} = k_{\\mathrm{Z}}[\\mathrm{N}]\\,y_{\\mathrm{O_2,local}}(t; f) + k_{\\mathrm{NNH}}[\\mathrm{NNH}][\\mathrm{O}] - k_{\\mathrm{cons}}[\\mathrm{NO}][\\mathrm{N}],$$ 其中 $k_{\\mathrm{Z}}, k_{\\mathrm{NNH}}, k_{\\mathrm{cons}}$ 是有效速率系数。方括号表示无量纲的替代浓度。初始化 $[\\mathrm{NO}](t=0) = 0$ 并随时间向前积分。\n\n计算任务：\n- 在固定的时间窗口内，使用均匀的时间步长 $\\Delta t$，对上述关于 $[\\mathrm{NO}](t)$ 的ODE进行显式时间积分。在保持所有其他参数固定的情况下，计算两种条件下的峰值 $[\\mathrm{NO}]$：NNH存在时和NNH被剪除（$s_{\\mathrm{NNH}} = 0$）时。\n- 将由于剪除导致的一氧化氮峰值的分数变化量化为$$\\delta = \\frac{[\\mathrm{NO}]_{\\max}^{\\mathrm{pruned}} - [\\mathrm{NO}]_{\\max}^{\\mathrm{full}}}{[\\mathrm{NO}]_{\\max}^{\\mathrm{full}}}.$$ 负值表示剪除减少了峰值NO。\n- 为骨架机理的调整提供一个决策规则：如果 $|\\delta| \\le \\tau$，则剪除是可接受的，无需补偿；如果 $|\\delta|  \\tau$，则建议重新引入NNH路径或通过调整其他氮途径进行补偿。使用容差 $\\tau$ 作为一个固定的标量。\n\n要使用的参数值：\n- 通用气体常数：$R = 8.314\\,\\mathrm{J}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$。\n- 热剖面：$T_u = 300\\,\\mathrm{K}$，$T_{b,0} = 2100\\,\\mathrm{K}$，$\\beta = 0.5$，$t_0 = 0.002\\,\\mathrm{s}$，$\\sigma = 0.0005\\,\\mathrm{s}$。\n- 氧气参数：$y_{\\mathrm{O_2},0} = 0.21$，$s_{\\mathrm{O_2}} = 0.95$。\n- 动力学参数：$C_{\\mathrm{N}} = 1.0$，$C_{\\mathrm{O}} = 1.0$，$C_{\\mathrm{NNH}} = 1.0$，$E_{\\mathrm{N}} = 80000\\,\\mathrm{J}\\,\\mathrm{mol}^{-1}$，$E_{\\mathrm{O}} = 90000\\,\\mathrm{J}\\,\\mathrm{mol}^{-1}$，$E_{\\mathrm{NNH}} = 70000\\,\\mathrm{J}\\,\\mathrm{mol}^{-1}$，$k_{\\mathrm{Z}} = 0.001$，$k_{\\mathrm{NNH}} = 0.00005$，$k_{\\mathrm{cons}} = 0.002$，$\\phi = 1.0$。\n- 时间积分：总窗口 $t_{\\max} = 0.004\\,\\mathrm{s}$，时间步长 $\\Delta t = 0.0000005\\,\\mathrm{s}$。\n- 数值保护：$\\varepsilon = 10^{-9}$ 以避免除以零。\n- 决策容差：$\\tau = 0.1$。\n\n测试套件：\n为以下四种情况提供结果，每种情况由未剪除模型中的EGR分数 $f$ 和NNH缩放因子 $s_{\\mathrm{NNH}}$ 指定：\n1. 情况1：$f = 0.0$，$s_{\\mathrm{NNH}} = 0.5$。\n2. 情况2：$f = 0.15$，$s_{\\mathrm{NNH}} = 0.5$。\n3. 情况3：$f = 0.3$，$s_{\\mathrm{NNH}} = 0.5$。\n4. 情况4：$f = 0.1$，$s_{\\mathrm{NNH}} = 0.0$。\n\n答案规格和单位：\n- 将每种情况的分数变化 $\\delta$ 报告为十进制数（无单位）。\n- 建议应表示为布尔值：如果 $|\\delta| \\le \\tau$ 则为 $\\,\\mathrm{True}$（剪除可接受，无需补偿），否则为 $\\,\\mathrm{False}$（建议重新调整）。\n- 温度单位为 $\\mathrm{K}$，时间单位为 $\\mathrm{s}$，活化能单位为 $\\mathrm{J}\\,\\mathrm{mol}^{-1}$，通用气体常数 $R$ 的单位为 $\\mathrm{J}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含所有测试用例的汇总结果，格式为一个用方括号括起来的逗号分隔列表，其中每个测试用例的 $(\\delta, \\mathrm{boolean})$ 对被平展为两个连续的条目。要求的格式是\n$[\\delta_1,boolean_1,\\delta_2,boolean_2,\\delta_3,boolean_3,\\delta_4,boolean_4],$\n其中每个 $\\delta_i$ 四舍五入到六位小数。",
            "solution": "该问题要求实现一个计算模型，以评估在一个简化的一维火焰中，剪除NNH自由基路径对一氧化氮（NO）峰值生成的影响。分析将在不同水平的废气再循环（EGR）下进行。解决方案涉及对NO浓度 $[\\mathrm{NO}]$ 的常微分方程（ODE）进行数值积分，并根据结果应用决策规则。\n\n该模型的基础是物种输运方程，它简化为关于停留时间 $t$ 的常微分方程（ODE）：\n$$\n\\frac{d Y_i}{d t} = \\frac{\\omega_i}{\\rho}\n$$\n这里，$Y_i$ 是物种 $i$ 的质量分数，$\\omega_i$ 是其净化学源项，$\\rho$ 是密度。我们将求解该方程关于 $[\\mathrm{NO}]$ 的一个替代版本。\n\n对于由EGR分数 $f$ 和基线NNH缩放因子 $s_{\\mathrm{NNH}}$ 定义的每个测试用例，其计算过程如下：\n1.  使用提供的 $s_{\\mathrm{NNH}}$ 值，对“完整”化学机理执行数值模拟。这将产生 $[\\mathrm{NO}](t)$ 的时间历史，从中可以找到峰值 $[\\mathrm{NO}]_{\\max}^{\\mathrm{full}}$。\n2.  对“剪除后”的机理执行第二次数值模拟。这是通过将NNH路径的贡献设置为零来实现的，即使用有效NNH缩放因子为 $0$。该模拟产生峰值 $[\\mathrm{NO}]_{\\max}^{\\mathrm{pruned}}$。\n3.  计算NO浓度峰值的分数变化 $\\delta$。\n4.  根据 $\\delta$ 和容差 $\\tau$ 应用决策规则，以确定剪除是否可接受。\n\n数值积分将使用显式前向欧拉法，在从 $t=0\\,\\mathrm{s}$ 到 $t=t_{\\max}=0.004\\,\\mathrm{s}$ 的时间域内进行，均匀时间步长为 $\\Delta t=5 \\times 10^{-7}\\,\\mathrm{s}$。状态变量是 $[\\mathrm{NO}]$，初始条件为 $[\\mathrm{NO}](t=0)=0$。\n\n欧拉更新规则是：\n$$\n[\\mathrm{NO}]_{i+1} = [\\mathrm{NO}]_{i} + \\left(\\frac{d[\\mathrm{NO}]}{dt}\\right)_i \\Delta t\n$$\n其中下标 $i$ 表示在时间 $t_i = i \\Delta t$ 处的值。\n\n$[\\mathrm{NO}]$ 的导数（或源项）由替代动力学模型给出：\n$$\n\\frac{d[\\mathrm{NO}]}{dt} = k_{\\mathrm{Z}}[\\mathrm{N}]\\,y_{\\mathrm{O_2,local}}(t; f) + k_{\\mathrm{NNH}}[\\mathrm{NNH}][\\mathrm{O}] - k_{\\mathrm{cons}}[\\mathrm{NO}][\\mathrm{N}]\n$$\n右侧的项取决于温度和局部物种浓度，必须在每个时间步 $t_i$ 进行评估。\n\n在单次模拟运行中（对于给定的 $f$ 和有效的 $s_{\\mathrm{NNH}}$），算法步骤如下：\n首先，预先计算在整个模拟过程中保持不变的参数。已燃气体温度 $T_b$ 针对EGR进行调整：\n$$\nT_b(f) = T_{b,0}\\left(1 - \\beta f\\right)\n$$\n其中 $T_{b,0}=2100\\,\\mathrm{K}$ 且 $\\beta=0.5$。可用的基础氧气摩尔分数也因EGR而减少：\n$$\ny_{\\mathrm{O_2}}(f) = y_{\\mathrm{O_2},0}(1 - f)\n$$\n其中 $y_{\\mathrm{O_2},0}=0.21$。\n\n接下来，我们建立时间网格，并预先计算那些依赖于时间但不依赖于演变的 $[\\mathrm{NO}]$ 浓度的量。这是一种高效的矢量化策略。\n温度剖面 $T(t)$ 定义为：\n$$\nT(t) = T_u + \\left(T_b(f) - T_u\\right)\\exp\\left(-\\left(\\frac{t - t_0}{\\sigma}\\right)^2\\right)\n$$\n其中 $T_u = 300\\,\\mathrm{K}$，$t_0 = 0.002\\,\\mathrm{s}$，以及 $\\sigma = 0.0005\\,\\mathrm{s}$。\n\n反应进程变量 $c(t)$ 由温度剖面导出：\n$$\nc(t) = \\frac{T(t) - T_u}{\\max\\left(T_b(f) - T_u, \\varepsilon\\right)}\n$$\n其中 $\\varepsilon = 10^{-9}$ 是防止除以零的保护措施。随着反应的进行，局部氧气摩尔分数 $y_{\\mathrm{O_2,local}}$ 会被消耗：\n$$\ny_{\\mathrm{O_2,local}}(t; f) = y_{\\mathrm{O_2}}(f)\\left(1 - s_{\\mathrm{O_2}} c(t)\\right)\n$$\n其中 $s_{\\mathrm{O_2}} = 0.95$。\n\n自由基N、O和NNH的伪浓度通过Arrhenius型表达式依赖于瞬时温度 $T(t)$。我们使用通用气体常数 $R = 8.314\\,\\mathrm{J}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$。\n$$\n[\\mathrm{N}](t) = C_{\\mathrm{N}} \\exp\\left(-\\frac{E_{\\mathrm{N}}}{R T(t)}\\right)\\phi\n$$\n$$\n[\\mathrm{O}](t) = C_{\\mathrm{O}} \\exp\\left(-\\frac{E_{\\mathrm{O}}}{R T(t)}\\right)\n$$\n$$\n[\\mathrm{NNH}](t) = s_{\\mathrm{NNH,eff}} C_{\\mathrm{NNH}} \\exp\\left(-\\frac{E_{\\mathrm{NNH}}}{R T(t)}\\right)\n$$\n参数给定为 $C_{\\mathrm{N}} = C_{\\mathrm{O}} = C_{\\mathrm{NNH}} = 1.0$，$\\phi=1.0$，$E_{\\mathrm{N}} = 80000\\,\\mathrm{J}\\,\\mathrm{mol}^{-1}$，$E_{\\mathrm{O}} = 90000\\,\\mathrm{J}\\,\\mathrm{mol}^{-1}$，以及 $E_{\\mathrm{NNH}} = 70000\\,\\mathrm{J}\\,\\mathrm{mol}^{-1}$。项 $s_{\\mathrm{NNH,eff}}$ 对于“完整”模型是基线 $s_{\\mathrm{NNH}}$，对于“剪除后”模型是 $0$。\n\n在每个时间 $t_i$ 评估了所有中间量后，就可以进行 $[\\mathrm{NO}]$ 的时间积分循环。在每个步骤 $i$，我们使用 $[\\mathrm{N}]_i$, $[\\mathrm{O}]_i$, $[\\mathrm{NNH}]_i$, $y_{\\mathrm{O_2,local},i}$ 和当前的 $[\\mathrm{NO}]_i$ 的值来计算 $(d[\\mathrm{NO}]/dt)_i$。速率系数为 $k_{\\mathrm{Z}} = 0.001$，$k_{\\mathrm{NNH}} = 0.00005$ 和 $k_{\\mathrm{cons}} = 0.002$。然后我们通过欧拉步骤更新 $[\\mathrm{NO}]_{i+1}$。所得的 $[\\mathrm{NO}]$ 的时间历史被存储起来，并在积分完成后提取其最大值。\n\n在获得 $[\\mathrm{NO}]_{\\max}^{\\mathrm{full}}$ 和 $[\\mathrm{NO}]_{\\max}^{\\mathrm{pruned}}$ 后，计算分数变化 $\\delta$：\n$$\n\\delta = \\frac{[\\mathrm{NO}]_{\\max}^{\\mathrm{pruned}} - [\\mathrm{NO}]_{\\max}^{\\mathrm{full}}}{[\\mathrm{NO}]_{\\max}^{\\mathrm{full}}}\n$$\n如果 $[\\mathrm{NO}]_{\\max}^{\\mathrm{full}} = 0$，则 $\\delta$ 定义为 $0$。请注意，对于情况4，其中初始 $s_{\\mathrm{NNH}}=0.0$，“完整”模型和“剪除后”模型是相同的，导致 $[\\mathrm{NO}]_{\\max}^{\\mathrm{pruned}} = [\\mathrm{NO}]_{\\max}^{\\mathrm{full}}$，因此 $\\delta=0.0$。\n\n最后，应用决策规则：如果绝对分数变化 $|\\delta|$ 小于或等于容差 $\\tau=0.1$，则认为剪除是可接受的（结果：True）。否则，是不可接受的（结果：False）。\n\n对指定的四个测试用例中的每一个重复此整个过程。最终输出将 $(\\delta, \\mathrm{boolean})$ 对聚合到一个格式化的列表中。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the change in peak nitric oxide mole fraction due to pruning a minor radical\n    and provides a recommendation for skeletal mechanism adjustment.\n    \"\"\"\n    \n    # Define constants and parameters from the problem statement.\n    R = 8.314  # J mol^-1 K^-1\n    T_u = 300.0  # K\n    T_b0 = 2100.0  # K\n    beta = 0.5\n    t0 = 0.002  # s\n    sigma = 0.0005  # s\n    y_O2_0 = 0.21\n    s_O2 = 0.95\n    C_N = 1.0\n    C_O = 1.0\n    C_NNH = 1.0\n    E_N = 80000.0  # J mol^-1\n    E_O = 90000.0  # J mol^-1\n    E_NNH = 70000.0  # J mol^-1\n    k_Z = 0.001\n    k_NNH = 0.00005\n    k_cons = 0.002\n    phi = 1.0\n    t_max = 0.004  # s\n    dt = 0.0000005  # s\n    epsilon = 1e-9\n    tau = 0.1\n\n    # Test cases: (EGR fraction f, NNH scaling s_NNH)\n    test_cases = [\n        (0.0, 0.5),   # Case 1\n        (0.15, 0.5),  # Case 2\n        (0.3, 0.5),   # Case 3\n        (0.1, 0.0),   # Case 4\n    ]\n\n    def run_simulation(f: float, s_nnh_eff: float) -> float:\n        \"\"\"\n        Runs a single simulation for a given EGR fraction and NNH scaling factor.\n        Returns the peak NO concentration.\n        \"\"\"\n        # Time grid\n        t_grid = np.arange(0, t_max, dt)\n        num_steps = len(t_grid)\n        no_history = np.zeros(num_steps)\n\n        # Pre-calculate time-independent values for this run\n        T_b = T_b0 * (1 - beta * f)\n        y_O2_f = y_O2_0 * (1 - f)\n        \n        # Denominator for progress variable c(t), with safeguard\n        T_b_minus_T_u = T_b - T_u\n        denominator_c = np.maximum(T_b_minus_T_u, epsilon)\n\n        # Vectorized pre-calculation of time-dependent quantities\n        T_t = T_u + (T_b - T_u) * np.exp(-((t_grid - t0) / sigma)**2)\n        c_t = (T_t - T_u) / denominator_c\n        y_O2_local_t = y_O2_f * (1 - s_O2 * c_t)\n        \n        # Radical concentrations\n        RT_t = R * T_t\n        N_t = C_N * np.exp(-E_N / RT_t) * phi\n        O_t = C_O * np.exp(-E_O / RT_t)\n        NNH_t = s_nnh_eff * C_NNH * np.exp(-E_NNH / RT_t)\n        \n        # Time integration loop (Forward Euler)\n        NO_t = 0.0  # Initial condition [NO](t=0) = 0\n        no_history[0] = NO_t\n\n        for i in range(num_steps - 1):\n            # NO source term d[NO]/dt at time t_i\n            dNO_dt = (k_Z * N_t[i] * y_O2_local_t[i] +\n                      k_NNH * NNH_t[i] * O_t[i] -\n                      k_cons * NO_t * N_t[i])\n            \n            # Euler step\n            NO_t = NO_t + dNO_dt * dt\n            no_history[i+1] = NO_t\n\n        return np.max(no_history)\n\n    results = []\n    for f_case, s_nnh_case in test_cases:\n        # Run simulation for the \"full\" model\n        no_max_full = run_simulation(f=f_case, s_nnh_eff=s_nnh_case)\n        \n        # Run simulation for the \"pruned\" model (s_NNH = 0)\n        no_max_pruned = run_simulation(f=f_case, s_nnh_eff=0.0)\n\n        # Calculate fractional change delta\n        if no_max_full == 0.0:\n            # If no NO is formed in the full model, delta is 0. This\n            # handles cases where the numerator and denominator are both zero.\n            delta = 0.0\n        else:\n            delta = (no_max_pruned - no_max_full) / no_max_full\n            \n        # Apply decision rule\n        is_acceptable = abs(delta) = tau\n\n        results.append(f\"{delta:.6f}\")\n        results.append(str(is_acceptable))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "简单的机理剪枝可能会引入不可接受的误差，现代工作流程通常采用优化方法来校正这些偏差。本练习  介绍了一种高级技术：使用二次规划（Quadratic Programming, QP）来重新调整反应速率常数。您将构建并求解一个有界约束的 QP 问题，以使简化后的机理在物理约束下最佳地拟合一组训练数据，并探索模型准确性（偏差）与复杂性（方差）之间的权衡。这项实践让您接触到用于创建高保真骨架机理的前沿数据驱动技术。",
            "id": "4063478",
            "problem": "您的任务是形式化并求解一个小型凸二次规划（QP）问题，该问题出现在计算燃烧学骨架机理生成工作流中机理剪枝后的环节。在此类工作流中，剪枝后机理中的反应速率常数通常会被重新加权，以便在遵守容差和避免过拟合的同时，最好地拟合训练可观测量。您将建立一个在对数反应速率乘子和可观测量偏差之间的线性化代理映射，然后求解一个带边界约束的加权正则化最小二乘 QP 问题，并使用自由度代理来评估偏差-方差权衡。\n\n基本原理如下。在一个骨架机理中，考虑 $m$ 个保留的基元反应，其基准速率常数为 $\\{k_j\\}_{j=1}^m$。设乘法重加权因子为 $x \\in \\mathbb{R}^m$，应用于 $k_j \\mapsto x_j k_j$。对于 $x_j=1$ 附近的微小乘法偏差，在对数灵敏度框架下，可观测量的偏差的一阶线性化是有效的。将 $p$ 个训练可观测量的偏差（相对于剪枝后基准预测值）的向量表示为 $y \\in \\mathbb{R}^p$（每个分量是要匹配的目标偏差），并将灵敏度矩阵表示为 $A \\in \\mathbb{R}^{p \\times m}$，其元素 $A_{ij} = \\partial o_i / \\partial \\ln k_j$ 在基准点进行评估。那么，线性化预测为 $A x$，其中 $x$ 在对数坐标中被解释为围绕 1 的微小乘法因子，因此残差为 $A x - y$。\n\n每个可观测量都有一个相关的容差 $\\sigma_i  0$，这些容差集合在 $\\sigma \\in \\mathbb{R}^p$ 中，对角加权矩阵为 $W = \\mathrm{diag}(1/\\sigma_1, \\ldots, 1/\\sigma_p)$。为了惩罚 $x$ 与基准值 1 之间的偏差，引入一个岭正则化参数 $\\alpha  0$。QP 的目标函数为\n$$\nJ(x) = \\frac{1}{2} \\| W (A x - y) \\|_2^2 + \\frac{\\alpha}{2} \\| x - \\mathbf{1} \\|_2^2,\n$$\n其中 $\\mathbf{1} \\in \\mathbb{R}^m$ 表示全为 1 的向量。决策变量按分量由下界和上界限制，以反映物理上合理的重加权范围，即 $l \\le x \\le u$。\n\n您必须实现一个求解器，该求解器能够：\n- 在满足 $l \\le x \\le u$ 的约束条件下最小化 $J(x)$。\n- 返回优化后的 $x^\\star$ 并计算以下指标：\n  - 拟合的加权均方误差 (WMSE)，\n  $$\n  \\mathrm{WMSE}(x^\\star) = \\frac{1}{p} \\left\\| W (A x^\\star - y) \\right\\|_2^2,\n  $$\n  由于容差加权，该指标是无量纲的。\n  - 由正则化和边界引起的偏差大小，\n  $$\n  \\mathrm{Bias}(x^\\star) = \\| x^\\star - \\mathbf{1} \\|_2^2,\n  $$\n  该指标是无量纲的。\n  - 使用相应无约束加权岭回归线性算子的自由度作为方差代理。定义 $W^2 = \\mathrm{diag}(1/\\sigma_1^2, \\ldots, 1/\\sigma_p^2)$ 和 $G = A^\\top W^2 A + \\alpha I_m$，其中 $I_m$ 是 $m \\times m$ 的单位矩阵。在无约束岭回归下，将 $y$ 映射到拟合可观测量的帽子矩阵为\n  $$\n  H = A G^{-1} A^\\top W^2,\n  $$\n  自由度代理为\n  $$\n  \\mathrm{df} = \\mathrm{trace}(H),\n  $$\n  该指标是无量纲的。此代理随模型灵活性的增加而增加，并作为方差的指示器。\n\n您必须使用通用数值优化器来实现 QP 求解。用于无约束岭回归的量所需的线性代数运算必须显式计算。训练可观测量和容差的数值在下面的测试套件中提供。\n\n您的程序必须生成单行输出，其中包含所有测试用例的结果，格式为逗号分隔的列表的列表，每个内部列表对应一个测试用例，并按顺序包含三个十进制数 $[\\mathrm{WMSE}, \\mathrm{Bias}, \\mathrm{df}]$。例如，输出格式为 $[[a,b,c],[d,e,f],[g,h,i]]$。输出中不需要单位，因为上面定义的所有指标都是无量纲的。\n\n测试套件：\n- 案例 1（理想情况，良态）：\n  - $p = 6$, $m = 4$,\n  - $A = \\begin{bmatrix}\n  0.40  -0.20  0.10  0.00 \\\\\n  0.10  0.30  -0.25  0.05 \\\\\n  0.00  0.15  0.20  -0.10 \\\\\n  0.25  -0.05  0.00  0.30 \\\\\n  -0.10  0.05  0.35  0.10 \\\\\n  0.05  0.00  -0.15  0.20\n  \\end{bmatrix}$,\n  - $y = \\begin{bmatrix} 0.06  -0.08  0.12  0.03  0.07  -0.05 \\end{bmatrix}^\\top$,\n  - $\\sigma = \\begin{bmatrix} 0.05  0.05  0.08  0.04  0.06  0.05 \\end{bmatrix}^\\top$,\n  - $\\alpha = 0.20$,\n  - 边界 $l = 0.70$, $u = 1.50$ 应用于 $x$ 的每个分量。\n- 案例 2（触及边界，数据影响更强）：\n  - $p = 5$, $m = 3$,\n  - $A = \\begin{bmatrix}\n  0.60  -0.10  0.20 \\\\\n  -0.40  0.30  0.10 \\\\\n  0.20  0.40  -0.30 \\\\\n  0.10  -0.20  0.50 \\\\\n  -0.30  0.20  0.00\n  \\end{bmatrix}$,\n  - $y = \\begin{bmatrix} 0.50  -0.40  0.30  0.20  -0.10 \\end{bmatrix}^\\top$,\n  - $\\sigma = \\begin{bmatrix} 0.10  0.10  0.10  0.10  0.10 \\end{bmatrix}^\\top$,\n  - $\\alpha = 0.05$,\n  - 边界 $l = 0.50$, $u = 1.20$ 应用于 $x$ 的每个分量。\n- 案例 3（欠定，低正则化，方差主导）：\n  - $p = 3$, $m = 5$,\n  - $A = \\begin{bmatrix}\n  0.30  -0.20  0.10  0.00  0.05 \\\\\n  -0.10  0.40  0.00  0.20  -0.05 \\\\\n  0.20  0.00  0.30  -0.10  0.00\n  \\end{bmatrix}$,\n  - $y = \\begin{bmatrix} 0.15  -0.05  0.10 \\end{bmatrix}^\\top$,\n  - $\\sigma = \\begin{bmatrix} 0.05  0.07  0.06 \\end{bmatrix}^\\top$,\n  - $\\alpha = 0.01$,\n  - 边界 $l = 0.60$, $u = 2.00$ 应用于 $x$ 的每个分量。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个内部列表 $[\\mathrm{WMSE}, \\mathrm{Bias}, \\mathrm{df}]$，并按照测试套件的顺序排列。例如，您的输出必须看起来像 $[[r_1,s_1,t_1],[r_2,s_2,t_2],[r_3,s_3,t_3]]$，其中每个符号代表一个十进制数。",
            "solution": "The user has provided a problem that requires the formulation and solution of a convex Quadratic Program (QP) with box constraints. This QP arises in the context of computational combustion for reweighting reaction rate constants in a skeletal chemical mechanism. The task also includes the calculation of several performance metrics related to model fit, regularization bias, and model complexity.\n\n### Step 1: Problem Validation\n\nI will first validate the problem statement according to the specified criteria.\n\n**Extracted Givens:**\n- The number of reactions is $m$, and the number of observables is $p$.\n- The reweighting factors are a vector $x \\in \\mathbb{R}^m$.\n- The sensitivity matrix is $A \\in \\mathbb{R}^{p \\times m}$.\n- The target observable deviations are $y \\in \\mathbb{R}^p$.\n- The observable tolerances are $\\sigma \\in \\mathbb{R}^p$, with $\\sigma_i  0$.\n- The weighting matrix is $W = \\mathrm{diag}(1/\\sigma_1, \\ldots, 1/\\sigma_p)$.\n- The ridge regularization parameter is $\\alpha  0$.\n- The objective function to minimize is $J(x) = \\frac{1}{2} \\| W (A x - y) \\|_2^2 + \\frac{\\alpha}{2} \\| x - \\mathbf{1} \\|_2^2$.\n- The constraints are box constraints, $l \\le x \\le u$, applied componentwise.\n- The metrics to be computed from the optimal solution $x^\\star$ are:\n    1. Weighted Mean Squared Error: $\\mathrm{WMSE}(x^\\star) = \\frac{1}{p} \\left\\| W (A x^\\star - y) \\right\\|_2^2$.\n    2. Bias Magnitude: $\\mathrm{Bias}(x^\\star) = \\| x^\\star - \\mathbf{1} \\|_2^2$.\n    3. Degrees of Freedom Proxy: $\\mathrm{df} = \\mathrm{trace}(H)$, where the hat matrix is $H = A G^{-1} A^\\top W^2$, with $W^2 = \\mathrm{diag}(1/\\sigma_1^2, \\ldots, 1/\\sigma_p^2)$ and $G = A^\\top W^2 A + \\alpha I_m$.\n- Three test cases are provided with specific numerical values for $p, m, A, y, \\sigma, \\alpha, l,$ and $u$.\n\n**Validation Analysis:**\n1.  **Scientifically Grounded**: The problem is well-grounded in computational chemical kinetics and statistical modeling. The use of linearized sensitivity analysis, regularized least-squares (a form of ridge regression), and quadratic programming to optimize model parameters is a standard and rigorous methodology. All concepts are scientifically established.\n2.  **Well-Posed**: The objective function $J(x)$ is a sum of two squared Euclidean norms. It can be expressed in the standard quadratic form $\\frac{1}{2}x^\\top Q x + c^\\top x + \\text{constant}$. The Hessian matrix of $J(x)$ is $Q = A^\\top W^\\top W A + \\alpha I_m$. Since $W^\\top W$ is a diagonal matrix with positive entries ($1/\\sigma_i^2$), the matrix $A^\\top W^\\top W A$ is positive semi-definite. Since $\\alpha  0$, the matrix $\\alpha I_m$ is positive definite. The sum of a positive semi-definite and a positive definite matrix is positive definite. Therefore, the Hessian $Q$ is positive definite, which implies that $J(x)$ is a strictly convex function. The minimization of a strictly convex function over a non-empty, closed, convex set (the box defined by $l \\le x \\le u$) has a unique solution. The problem is therefore well-posed.\n3.  **Objective**: The problem is stated using precise mathematical notation and objective language, free of ambiguity or subjective claims.\n4.  **Flaw Checklist**: The problem does not violate any of the specified flaw criteria. It is scientifically sound, formal, complete, realistic, and well-posed.\n\n**Verdict:** The problem is valid. I will proceed with the solution.\n\n### Step 2: Solution Formulation\n\nThe provided task is to find the vector $x^\\star$ that minimizes the objective function $J(x)$ subject to box constraints, and then to compute the specified metrics.\n\n**Objective Function and Gradient**\nThe objective function is:\n$$\nJ(x) = \\frac{1}{2} \\| W (A x - y) \\|_2^2 + \\frac{\\alpha}{2} \\| x - \\mathbf{1} \\|_2^2\n$$\nThis is a quadratic function of $x$. To use a numerical optimization algorithm, it is highly advantageous to provide its analytical gradient (Jacobian). The gradient of $J(x)$ with respect to $x$ is:\n$$\n\\nabla J(x) = \\frac{\\partial}{\\partial x} \\left[ \\frac{1}{2} (Ax-y)^\\top W^\\top W (Ax-y) + \\frac{\\alpha}{2} (x-\\mathbf{1})^\\top (x-\\mathbf{1}) \\right]\n$$\nUsing standard rules of matrix calculus:\n$$\n\\nabla J(x) = A^\\top W^\\top W (Ax - y) + \\alpha (x - \\mathbf{1})\n$$\nSince $W$ is diagonal, $W^\\top W = W^2 = \\mathrm{diag}(1/\\sigma_1^2, \\ldots, 1/\\sigma_p^2)$. The gradient can be written as:\n$$\n\\nabla J(x) = A^\\top W^2 (Ax - y) + \\alpha (x - \\mathbf{1})\n$$\n\n**Optimization Procedure**\nThe problem is a box-constrained quadratic program. We can solve it using a quasi-Newton method that supports box constraints, such as the L-BFGS-B algorithm. This algorithm is available in the `scipy.optimize.minimize` library function. The optimization will be initialized with a feasible starting point, for which the vector $x_0 = \\mathbf{1}$ is a natural choice as it represents the baseline un-reweighted model and lies within the bounds for all test cases.\n\n**Metrics Calculation**\nOnce the optimal vector $x^\\star$ is found, the three required metrics are computed as follows:\n\n1.  **Weighted Mean Squared Error (WMSE)**: This metric measures the average squared residual, weighted by the inverse of the observable tolerances. It quantifies the goodness of fit.\n    $$\n    \\mathrm{WMSE}(x^\\star) = \\frac{1}{p} \\left\\| W (A x^\\star - y) \\right\\|_2^2\n    $$\n    This will be computed by first calculating the residual vector $r = A x^\\star - y$, then the weighted residual $W r$, and finally the squared Euclidean norm divided by $p$.\n\n2.  **Bias Magnitude (Bias)**: This metric measures the squared Euclidean distance of the optimal parameter vector $x^\\star$ from the baseline vector $\\mathbf{1}$. It quantifies the magnitude of the correction applied to the rate constants, which is influenced by the regularization term.\n    $$\n    \\mathrm{Bias}(x^\\star) = \\| x^\\star - \\mathbf{1} \\|_2^2\n    $$\n\n3.  **Degrees-of-Freedom Proxy (df)**: This metric serves as a proxy for the model's complexity or variance. It is derived from the trace of the hat matrix $H$ corresponding to the unconstrained version of the problem.\n    The required matrices are:\n    - The squared weight matrix: $W^2 = \\mathrm{diag}(1/\\sigma_1^2, \\ldots, 1/\\sigma_p^2)$.\n    - The Gram-like matrix: $G = A^\\top W^2 A + \\alpha I_m$, where $I_m$ is the $m \\times m$ identity matrix.\n    - The hat matrix: $H = A G^{-1} A^\\top W^2$.\n    The degrees of freedom is then the trace of $H$:\n    $$\n    \\mathrm{df} = \\mathrm{trace}(H)\n    $$\n    This calculation requires a matrix inversion of $G$ followed by several matrix multiplications.\n\n**Implementation Summary**\nThe overall algorithm will be implemented as a Python script. For each test case provided:\n1.  The input data ($A, y, \\sigma, \\alpha, l, u, p, m$) will be defined as `numpy` arrays.\n2.  The objective function $J(x)$ and its gradient $\\nabla J(x)$ will be defined as Python functions.\n3.  The `scipy.optimize.minimize` function will be called with the `L-BFGS-B` method, the objective and gradient functions, an initial guess $x_0 = \\mathbf{1}$, and the specified box constraints.\n4.  The returned optimal vector $x^\\star$ will be used to compute the $\\mathrm{WMSE}$, $\\mathrm{Bias}$, and $\\mathrm{df}$ metrics according to their definitions.\n5.  The results for all test cases will be collected and formatted into the required output string.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves the quadratic programming problem for each test case and computes the required metrics.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path, well-conditioned)\n        {\n            \"p\": 6, \"m\": 4,\n            \"A\": np.array([\n                [0.40, -0.20, 0.10, 0.00],\n                [0.10, 0.30, -0.25, 0.05],\n                [0.00, 0.15, 0.20, -0.10],\n                [0.25, -0.05, 0.00, 0.30],\n                [-0.10, 0.05, 0.35, 0.10],\n                [0.05, 0.00, -0.15, 0.20]\n            ]),\n            \"y\": np.array([0.06, -0.08, 0.12, 0.03, 0.07, -0.05]),\n            \"sigma\": np.array([0.05, 0.05, 0.08, 0.04, 0.06, 0.05]),\n            \"alpha\": 0.20,\n            \"l\": 0.70, \"u\": 1.50\n        },\n        # Case 2 (boundary-hitting, stronger data influence)\n        {\n            \"p\": 5, \"m\": 3,\n            \"A\": np.array([\n                [0.60, -0.10, 0.20],\n                [-0.40, 0.30, 0.10],\n                [0.20, 0.40, -0.30],\n                [0.10, -0.20, 0.50],\n                [-0.30, 0.20, 0.00]\n            ]),\n            \"y\": np.array([0.50, -0.40, 0.30, 0.20, -0.10]),\n            \"sigma\": np.array([0.10, 0.10, 0.10, 0.10, 0.10]),\n            \"alpha\": 0.05,\n            \"l\": 0.50, \"u\": 1.20\n        },\n        # Case 3 (underdetermined, low regularization, variance-dominated)\n        {\n            \"p\": 3, \"m\": 5,\n            \"A\": np.array([\n                [0.30, -0.20, 0.10, 0.00, 0.05],\n                [-0.10, 0.40, 0.00, 0.20, -0.05],\n                [0.20, 0.00, 0.30, -0.10, 0.00]\n            ]),\n            \"y\": np.array([0.15, -0.05, 0.10]),\n            \"sigma\": np.array([0.05, 0.07, 0.06]),\n            \"alpha\": 0.01,\n            \"l\": 0.60, \"u\": 2.00\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        p = case[\"p\"]\n        m = case[\"m\"]\n        A = case[\"A\"]\n        y = case[\"y\"]\n        sigma = case[\"sigma\"]\n        alpha = case[\"alpha\"]\n        l_bound = case[\"l\"]\n        u_bound = case[\"u\"]\n        \n        # Define weighting matrix W and W^2\n        W = np.diag(1.0 / sigma)\n        W2 = np.diag(1.0 / (sigma**2))\n\n        # Objective function J(x)\n        def objective(x, A, y, W, alpha):\n            residual = A @ x - y\n            weighted_residual = W @ residual\n            fit_term = 0.5 * np.dot(weighted_residual, weighted_residual)\n            reg_term = 0.5 * alpha * np.dot(x - 1, x - 1)\n            return fit_term + reg_term\n\n        # Gradient of J(x)\n        def jacobian(x, A, y, W, alpha):\n            W2_local = W @ W\n            grad_fit = A.T @ W2_local @ (A @ x - y)\n            grad_reg = alpha * (x - 1)\n            return grad_fit + grad_reg\n            \n        # Initial guess and bounds\n        x0 = np.ones(m)\n        bounds = [(l_bound, u_bound)] * m\n        \n        # Perform optimization\n        opt_result = minimize(\n            fun=objective,\n            x0=x0,\n            args=(A, y, W, alpha),\n            method='L-BFGS-B',\n            jac=jacobian,\n            bounds=bounds\n        )\n        x_star = opt_result.x\n\n        # Calculate metrics\n        # 1. WMSE\n        wmse_residual = W @ (A @ x_star - y)\n        wmse = (1.0 / p) * np.dot(wmse_residual, wmse_residual)\n\n        # 2. Bias\n        bias = np.dot(x_star - 1.0, x_star - 1.0)\n\n        # 3. Degrees of Freedom (df)\n        Id_m = np.identity(m)\n        G = A.T @ W2 @ A + alpha * Id_m\n        G_inv = np.linalg.inv(G)\n        H = A @ G_inv @ A.T @ W2\n        df = np.trace(H)\n\n        results.append([wmse, bias, df])\n\n    # Format the final output string\n    output_str = \"[\" + \",\".join([f\"[{r[0]:.6f},{r[1]:.6f},{r[2]:.6f}]\" for r in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}