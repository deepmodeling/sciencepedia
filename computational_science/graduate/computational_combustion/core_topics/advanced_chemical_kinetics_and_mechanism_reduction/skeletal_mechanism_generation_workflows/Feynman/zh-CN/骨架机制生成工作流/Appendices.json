{
    "hands_on_practices": [
        {
            "introduction": "本练习将介绍一种最基本的模型简化技术——准稳态假设 (Quasi-Steady-State Assumption, QSSA)。通过分析不同物种的特征时间尺度，我们可以识别出高活性中间体，并用代数方程替代它们的微分方程，从而显著简化系统。这项练习将引导您在一个假设的反应体系中识别 QSS 物种，并量化这种简化所引入的误差。",
            "id": "4063463",
            "problem": "给定一个用于空间均匀、恒压、绝热反应器的基元链式支化燃烧机理。物种集合为 $\\{A,B,R,P\\}$，其中 $A$ 是燃料， $B$ 是氧化剂， $R$ 是自由基， $P$ 是稳定的产物。该机理包含以下遵循质量作用定律的基元反应：\n- $A + B \\xrightarrow{k_1(T)} R$ (引发),\n- $R + B \\xrightarrow{k_2(T)} 2R$ (支化),\n- $R + R \\xrightarrow{k_3(T)} P$ (终止),\n- $A + R \\xrightarrow{k_4(T)} P + R$ (增长)。\n\n此处，$T$ 是混合物的温度，$k_i(T)$ 是与温度相关的速率常数，其表达式为阿伦尼乌斯类型，$k_i(T) = A_i \\exp\\left(-\\dfrac{E_i}{R_u T}\\right)$（对于 $i \\in \\{1,2,4\\}$），以及 $k_3(T) = A_3$（活化能可忽略不计）。普适气体常数为 $R_u = 8.314 \\,\\text{J}\\,\\text{mol}^{-1}\\,\\text{K}^{-1}$。浓度用 $[A] = a$、$[B] = b$、$[R] = r$ 和 $[P] = p$ 表示，单位为 $\\text{mol}\\,\\text{m}^{-3}$。各反应的每摩尔反应热分别为 $Q_1,Q_2,Q_3,Q_4$，单位为 $\\text{J}\\,\\text{mol}^{-1}$。热力学参数包括密度 $\\rho$（单位为 $\\text{kg}\\,\\text{m}^{-3}$）和恒压比热 $C_p$（单位为 $\\text{J}\\,\\text{kg}^{-1}\\,\\text{K}^{-1}$）。\n\n从化学动力学（质量作用）和绝热、恒压条件下的能量守恒基本定律出发，您必须：\n1. 基于初始状态下的局部时间尺度分离判据，识别准稳态（QSS）的候选自由基。对于浓度为 $c_i$ 的物种 $i$，定义特征时间尺度 $\\tau_i = \\dfrac{c_i}{|dc_i/dt|}$，该值由完整常微分方程系统在初始时刻计算得出。如果比率 $\\tau_R/\\tau_A$ 小于给定的阈值参数 $\\theta$，则声明 $R$ 为 QSS 自由基。\n2. 在对 $R$ 采用 QSS 假设的条件下，通过消除 $dr/dt$ 并用一个代数函数 $r_{\\mathrm{QSS}}(a,b,T)$（该函数强制 $dr/dt \\approx 0$）来替代 $r$，从而推导出简化的常微分方程（ODE）系统。\n3. 计算点火延迟时间 $\\tau_{\\mathrm{ign}}$，其定义为温度 $T(t)$ 首次达到阈值 $T_{\\mathrm{ign}} = T_0 + \\Delta T$ 的时间，其中 $T_0$ 是初始温度，$\\Delta T$ 是指定的温升。如果在指定的结束时间 $t_{\\mathrm{end}}$ 之前没有达到该阈值，则设 $\\tau_{\\mathrm{ign}} = t_{\\mathrm{end}}$。\n4. 估算完整模型和简化模型之间点火延迟的绝对误差，即计算 $|\\tau_{\\mathrm{ign}}^{\\mathrm{full}} - \\tau_{\\mathrm{ign}}^{\\mathrm{red}}|$，以秒为单位表示。\n\n所有变量和常数必须遵循以下单位：$a,b,r,p$ 为 $\\text{mol}\\,\\text{m}^{-3}$，$T$ 为 $\\text{K}$，时间为 $\\text{s}$，$k_1,k_2,k_4$ 为 $\\text{m}^3\\,\\text{mol}^{-1}\\,\\text{s}^{-1}$，$k_3$ 为 $\\text{m}^3\\,\\text{mol}^{-1}\\,\\text{s}^{-1}$，$Q_i$ 为 $\\text{J}\\,\\text{mol}^{-1}$，$\\rho$ 为 $\\text{kg}\\,\\text{m}^{-3}$，$C_p$ 为 $\\text{J}\\,\\text{kg}^{-1}\\,\\text{K}^{-1}$。点火延迟误差以秒为单位作答。\n\n您必须实现一个完整的程序，该程序能够：\n- 根据质量作用动力学和能量方程，对 $(a,b,r,T)$ 的完整 ODE 系统进行积分，\n- 使用 QSS 判据来决定是否通过消除 $r$（借助 $dr/dt \\approx 0$）来简化系统；如果未对 $R$ 选择 QSS，则简化系统与完整系统相同，\n- 计算两个模型的点火延迟并返回绝对误差。\n\n对动力学和热力学使用以下固定参数值：\n- $A_1 = 5\\times 10^7$, $E_1 = 7.0\\times 10^4 \\,\\text{J}\\,\\text{mol}^{-1}$,\n- $A_2 = 2\\times 10^8$, $E_2 = 6.0\\times 10^4 \\,\\text{J}\\,\\text{mol}^{-1}$,\n- $A_3 = 1\\times 10^4$,\n- $A_4 = 1\\times 10^7$, $E_4 = 5.0\\times 10^4 \\,\\text{J}\\,\\text{mol}^{-1}$,\n- $Q_1 = 0$, $Q_2 = 1.0\\times 10^5 \\,\\text{J}\\,\\text{mol}^{-1}$, $Q_3 = 0$, $Q_4 = 2.0\\times 10^4 \\,\\text{J}\\,\\text{mol}^{-1}$,\n- $\\rho = 1.0 \\,\\text{kg}\\,\\text{m}^{-3}$, $C_p = 1000 \\,\\text{J}\\,\\text{kg}^{-1}\\,\\text{K}^{-1}$,\n- $R_u = 8.314 \\,\\text{J}\\,\\text{mol}^{-1}\\,\\text{K}^{-1}$。\n\n您的程序必须应用以下包含初始条件和控制参数 $(a_0,b_0,r_0,T_0,\\Delta T,\\theta,t_{\\mathrm{end}})$ 的测试套件：\n- 案例 1 (基准链式支化点火): $(1.0, 2.0, 1.0\\times 10^{-9}, 1000.0, 50.0, 0.2, 0.01)$,\n- 案例 2 (初始自由基浓度升高时的临界 QSS): $(1.0, 0.8, 5.0\\times 10^{-2}, 1000.0, 50.0, 0.05, 0.02)$,\n- 案例 3 (低温、慢动力学): $(0.5, 0.5, 1.0\\times 10^{-9}, 800.0, 50.0, 0.2, 0.05)$。\n\n您的程序应生成单行输出，其中包含三个案例的绝对点火延迟误差，格式为逗号分隔的列表并用方括号括起（例如，“[$e_1,e_2,e_3$]”），其中每个 $e_i$ 是一个以秒为单位的浮点数。数值输出的单位必须是秒，并且必须能够根据指定的输入确定性地计算得出，无需任何外部数据。",
            "solution": "该问题要求分析一个简化的链式支化燃烧机理，并比较完整动力学模型与在准稳态假设（QSSA）下推导的简化模型。分析过程包括：推导控制常微分方程（ODE），应用基于时间尺度的判据来验证 QSSA 的合理性，推导简化模型，以及数值计算两种模型的点火延迟时间，以量化简化所引入的误差。\n\n### 1. 完整动力学模型\n\n反应机理涉及四种物种：燃料（$A$）、氧化剂（$B$）、自由基（$R$）和产物（$P$），由四个基元反应控制：\n1.  $A + B \\xrightarrow{k_1(T)} R$\n2.  $R + B \\xrightarrow{k_2(T)} 2R$\n3.  $R + R \\xrightarrow{k_3(T)} P$\n4.  $A + R \\xrightarrow{k_4(T)} P + R$\n\n速率常数 $k_i(T)$ 由阿伦尼乌斯型表达式 $k_i(T) = A_i \\exp(-E_i / (R_u T))$（对于 $i \\in \\{1, 2, 4\\}$）和 $k_3(T) = A_3$ 给出。这些反应的净反应速率（用 $\\omega_i$ 表示）由质量作用定律给出，其中浓度为 $[A]=a, [B]=b, [R]=r$：\n$$ \\omega_1 = k_1(T) a b $$\n$$ \\omega_2 = k_2(T) r b $$\n$$ \\omega_3 = k_3(T) r^2 $$\n$$ \\omega_4 = k_4(T) a r $$\n\n在空间均匀系统中，物种浓度的时间演化由以下常微分方程组描述：\n$$ \\frac{da}{dt} = -\\omega_1 - \\omega_4 = -k_1(T)ab - k_4(T)ar $$\n$$ \\frac{db}{dt} = -\\omega_1 - \\omega_2 = -k_1(T)ab - k_2(T)rb $$\n$$ \\frac{dr}{dt} = +\\omega_1 + \\omega_2 - 2\\omega_3 = k_1(T)ab + k_2(T)rb - 2k_3(T)r^2 $$\n注意，反应4是一个链增长步骤，其中一个自由基R被消耗，同时又生成一个，导致R的浓度没有净变化。\n\n对于恒压、绝热反应器，能量守恒方程为：\n$$ \\rho C_p \\frac{dT}{dt} = \\sum_{i=1}^{4} Q_i \\omega_i $$\n鉴于 $Q_1 = 0$ 和 $Q_3 = 0$，该方程简化为：\n$$ \\frac{dT}{dt} = \\frac{1}{\\rho C_p} (Q_2 \\omega_2 + Q_4 \\omega_4) = \\frac{r}{\\rho C_p} \\left( Q_2 k_2(T) b + Q_4 k_4(T) a \\right) $$\n\n这四个关于状态向量 $\\mathbf{y}(t) = [a(t), b(t), r(t), T(t)]^T$ 的耦合非线性常微分方程构成了完整的动力学模型。\n\n### 2. 准稳态（QSS）分析\n\nQSSA 适用于反应活性极高的中间物种（自由基），其特征反应时间尺度远小于主要物种的特征反应时间尺度。我们在初始状态（$t=0$）下评估此条件。对于浓度为 $c_i$ 的物种 $i$，其特征时间尺度定义为 $\\tau_i = \\dfrac{c_i}{|dc_i/dt|}$。\n\n在 $t=0$ 时，使用初始条件 $(a_0, b_0, r_0, T_0)$，我们计算初始速率：\n$$ \\left(\\frac{da}{dt}\\right)_0 = -k_1(T_0)a_0b_0 - k_4(T_0)a_0r_0 $$\n$$ \\left(\\frac{dr}{dt}\\right)_0 = k_1(T_0)a_0b_0 + k_2(T_0)b_0r_0 - 2k_3(T_0)r_0^2 $$\n\n燃料A和自由基R的初始时间尺度为：\n$$ \\tau_A = \\frac{a_0}{\\left|\\left(\\frac{da}{dt}\\right)_0\\right|} = \\frac{a_0}{k_1(T_0)a_0b_0 + k_4(T_0)a_0r_0} = \\frac{1}{k_1(T_0)b_0 + k_4(T_0)r_0} $$\n$$ \\tau_R = \\frac{r_0}{\\left|\\left(\\frac{dr}{dt}\\right)_0\\right|} = \\frac{r_0}{\\left| k_1(T_0)a_0b_0 + k_2(T_0)b_0r_0 - 2k_3(T_0)r_0^2 \\right|} $$\n\n如果自由基 R 的时间尺度与燃料 A 的时间尺度之比小于预设阈值 $\\theta$，则认为对自由基 R 的 QSS 假设有效：\n$$ \\frac{\\tau_R}{\\tau_A}  \\theta $$\n\n### 3. 简化动力学模型（QSS 模型）\n\n如果满足 QSS 判据，我们可以通过假设自由基 R 的净生成速率近似为零（即 $dr/dt \\approx 0$）来简化系统。这将关于 $r$ 的微分方程转化为一个代数方程：\n$$ k_1(T)ab + k_2(T)rb - 2k_3(T)r^2 = 0 $$\n整理后得到一个关于自由基 QSS 浓度 $r_{\\mathrm{QSS}}$ 的二次方程：\n$$ 2k_3(T)r^2 - k_2(T)br - k_1(T)ab = 0 $$\n使用二次公式求解 $r$ 并选择具有物理意义的正根，可得：\n$$ r_{\\mathrm{QSS}}(a,b,T) = \\frac{k_2(T)b + \\sqrt{\\left(k_2(T)b\\right)^2 + 8k_1(T)k_3(T)ab}}{4k_3(T)} $$\n\n然后，完整的 ODE 系统被简化为关于状态向量 $\\mathbf{y}_{\\mathrm{red}}(t) = [a(t), b(t), T(t)]^T$ 的三个 ODE 组成的系统。R 的浓度不再是状态变量，而是在每个时间步通过 $r_{\\mathrm{QSS}}$ 的代数表达式进行诊断计算：\n$$ \\frac{da}{dt} = -k_1(T)ab - k_4(T)a \\cdot r_{\\mathrm{QSS}}(a,b,T) $$\n$$ \\frac{db}{dt} = -k_1(T)ab - k_2(T)b \\cdot r_{\\mathrm{QSS}}(a,b,T) $$\n$$ \\frac{dT}{dt} = \\frac{r_{\\mathrm{QSS}}(a,b,T)}{\\rho C_p} \\left( Q_2 k_2(T) b + Q_4 k_4(T) a \\right) $$\n此简化系统使用初始条件 $(a_0, b_0, T_0)$ 进行积分。\n\n### 4. 数值求解与点火延迟计算\n\n点火延迟时间 $\\tau_{\\mathrm{ign}}$ 定义为温度首次达到阈值 $T_{\\mathrm{ign}} = T_0 + \\Delta T$ 的时间 $t$。我们使用数值 ODE 求解器（具体为 `scipy.integrate.solve_ivp`）来求解完整系统和简化系统的初值问题。该函数的事件检测功能可用于精确确定达到阈值的时刻。事件由条件 $T(t) - T_{\\mathrm{ign}} = 0$ 定义。如果事件在指定的结束时间 $t_{\\mathrm{end}}$ 之前未发生，则将 $\\tau_{\\mathrm{ign}}$ 设为 $t_{\\mathrm{end}}$。\n\n对于每个测试案例，我们通过积分完整系统来计算 $\\tau_{\\mathrm{ign}}^{\\mathrm{full}}$。然后，我们执行 QSS 检查。如果满足判据，我们通过积分简化系统来计算 $\\tau_{\\mathrm{ign}}^{\\mathrm{red}}$。如果不满足判据，则认为简化模型与完整模型相同，因此设 $\\tau_{\\mathrm{ign}}^{\\mathrm{red}} = \\tau_{\\mathrm{ign}}^{\\mathrm{full}}$，从而导致模型误差为零。最后，计算绝对误差 $|\\tau_{\\mathrm{ign}}^{\\mathrm{full}} - \\tau_{\\mathrm{ign}}^{\\mathrm{red}}|$。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the combustion problem for a series of test cases, calculating the\n    error in ignition delay time between full and QSS-reduced models.\n    \"\"\"\n\n    # Fixed physical and chemical parameters\n    params = {\n        'A1': 5e7, 'E1': 7.0e4, 'Q1': 0.0,\n        'A2': 2e8, 'E2': 6.0e4, 'Q2': 1.0e5,\n        'A3': 1e4, 'E3': 0.0, 'Q3': 0.0,\n        'A4': 1e7, 'E4': 5.0e4, 'Q4': 2.0e4,\n        'rho': 1.0, 'Cp': 1000.0, 'Ru': 8.314\n    }\n\n    # Test cases: (a0, b0, r0, T0, delta_T, theta, t_end)\n    test_cases = [\n        # Case 1: baseline chain-branching ignition\n        (1.0, 2.0, 1.0e-9, 1000.0, 50.0, 0.2, 0.01),\n        # Case 2: borderline QSS with elevated initial radical\n        (1.0, 0.8, 5.0e-2, 1000.0, 50.0, 0.05, 0.02),\n        # Case 3: low-temperature, slow kinetics\n        (0.5, 0.5, 1.0e-9, 800.0, 50.0, 0.2, 0.05),\n    ]\n\n    simulator = CombustionSimulator(params)\n    results = []\n    for case in test_cases:\n        error = simulator.run_case(case)\n        results.append(error)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\n\nclass CombustionSimulator:\n    \"\"\"\n    A class to encapsulate the combustion model, parameters, and solution logic.\n    \"\"\"\n    def __init__(self, params):\n        self.p = params\n        self.eps = np.finfo(float).eps\n\n    def _calculate_k(self, T):\n        \"\"\"Calculates Arrhenius rate constants at a given temperature T.\"\"\"\n        k1 = self.p['A1'] * np.exp(-self.p['E1'] / (self.p['Ru'] * T))\n        k2 = self.p['A2'] * np.exp(-self.p['E2'] / (self.p['Ru'] * T))\n        k3 = self.p['A3']  # E3 = 0\n        k4 = self.p['A4'] * np.exp(-self.p['E4'] / (self.p['Ru'] * T))\n        return k1, k2, k3, k4\n\n    def _rhs_full(self, t, y):\n        \"\"\"Right-hand side function for the full ODE system.\"\"\"\n        a, b, r, T = y\n        k1, k2, k3, k4 = self._calculate_k(T)\n\n        # To prevent negative concentrations from numerical errors\n        a = max(0, a)\n        b = max(0, b)\n        r = max(0, r)\n\n        # Reaction rates\n        omega1 = k1 * a * b\n        omega2 = k2 * r * b\n        omega3 = k3 * r * r\n        omega4 = k4 * a * r\n\n        # Species ODEs\n        dadt = -omega1 - omega4\n        dbdt = -omega1 - omega2\n        drdt = omega1 + omega2 - 2 * omega3\n\n        # Energy ODE\n        dTdt = (self.p['Q2'] * omega2 + self.p['Q4'] * omega4) / (self.p['rho'] * self.p['Cp'])\n\n        return [dadt, dbdt, drdt, dTdt]\n\n    def _rhs_reduced(self, t, y):\n        \"\"\"Right-hand side function for the QSS-reduced ODE system.\"\"\"\n        a, b, T = y\n        k1, k2, k3, k4 = self._calculate_k(T)\n        \n        # To prevent negative concentrations from numerical errors\n        a = max(0, a)\n        b = max(0, b)\n\n        # QSS radical concentration r_qss\n        # 2*k3*r^2 - k2*b*r - k1*a*b = 0\n        term_sqrt = np.sqrt((k2 * b)**2 + 8 * k1 * k3 * a * b)\n        r_qss = (k2 * b + term_sqrt) / (4 * k3 + self.eps)\n        \n        # Species ODEs with r_qss\n        dadt = -k1 * a * b - k4 * a * r_qss\n        dbdt = -k1 * a * b - k2 * b * r_qss\n\n        # Energy ODE with r_qss\n        dTdt = (r_qss / (self.p['rho'] * self.p['Cp'])) * (self.p['Q2'] * k2 * b + self.p['Q4'] * k4 * a)\n\n        return [dadt, dbdt, dTdt]\n\n    def _check_qss(self, a0, b0, r0, T0, theta):\n        \"\"\"Checks if the QSS assumption is valid based on the timescale criterion.\"\"\"\n        k1_0, k2_0, k3_0, k4_0 = self._calculate_k(T0)\n\n        # Initial rate of change for A\n        dadt_0 = -k1_0 * a0 * b0 - k4_0 * a0 * r0\n        tau_A_denom = abs(dadt_0)\n        \n        # Initial rate of change for R\n        drdt_0 = k1_0 * a0 * b0 + k2_0 * b0 * r0 - 2 * k3_0 * r0**2\n        tau_R_denom = abs(drdt_0)\n\n        # Handle cases where concentration or rate is zero\n        if tau_A_denom  self.eps: return False # Major species not changing, no timescale separation\n        if r0  self.eps or tau_R_denom  self.eps:\n            tau_R = 0.0 # Zero concentration or zero time derivative means infinite/zero timescale. Zero timescale is QSS.\n        else:\n            tau_R = r0 / tau_R_denom\n\n        tau_A = a0 / tau_A_denom\n        \n        return (tau_R / tau_A)  theta\n\n    def _solve_for_ignition(self, rhs_func, y0, t_span, T_ign):\n        \"\"\"Integrates an ODE system and finds ignition time.\"\"\"\n        \n        num_vars = len(y0)\n        temp_idx = num_vars - 1\n\n        def ignition_event(t, y):\n            return y[temp_idx] - T_ign\n        ignition_event.terminal = True\n        ignition_event.direction = 1\n\n        sol = solve_ivp(\n            fun=rhs_func,\n            t_span=t_span,\n            y0=y0,\n            method='Radau',\n            events=ignition_event,\n            dense_output=True\n        )\n\n        if sol.t_events[0].size > 0:\n            return sol.t_events[0][0]\n        else:\n            return t_span[1]\n\n    def run_case(self, case_params):\n        \"\"\"Runs a single test case and returns the ignition delay error.\"\"\"\n        a0, b0, r0, T0, delta_T, theta, t_end = case_params\n        T_ign = T0 + delta_T\n        t_span = (0, t_end)\n\n        # 1. Solve full model\n        y0_full = [a0, b0, r0, T0]\n        tau_full = self._solve_for_ignition(self._rhs_full, y0_full, t_span, T_ign)\n        \n        # 2. Check QSS validity\n        is_qss_valid = self._check_qss(a0, b0, r0, T0, theta)\n\n        if is_qss_valid:\n            # 3. Solve reduced model\n            y0_red = [a0, b0, T0]\n            tau_red = self._solve_for_ignition(self._rhs_reduced, y0_red, t_span, T_ign)\n        else:\n            # Per problem spec, if QSS is not applied, reduced model is identical\n            # to full model, so the error is zero.\n            tau_red = tau_full\n        \n        # 4. Calculate absolute error\n        error = abs(tau_full - tau_red)\n        return error\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "骨架机理通常通过将相似物种（如同分异构体）组合成单一的“伪物种”来简化化学系统。本练习旨在解决定义这种集总物种热力学性质的关键任务。您将通过一个实践程序，为一个同分异构体群体的摩尔分数平均性质拟合一组 NASA 多项式系数，这是机理构建中一个常见且必要的步骤。",
            "id": "4063502",
            "problem": "您的任务是实现一个在计算燃烧学中用于骨架机理生成工作流的计算程序，以表示一个聚合了一组异构体的集总伪物种。必须为该集总伪物种在指定的温度范围内分配一套单一的美国国家航空航天局（NASA）七系数多项式参数，使得该多项式能够以最小二乘法的方式同时拟合异构体聚合体的焓和等压热容数据。该程序必须从第一性原理推导，并实现为一个完整、可运行的程序。最终答案必须是代码。\n\n背景和基本原理：在理想气体的热化学中，摩尔焓 $h(T)$ 和等压摩尔热容 $c_p(T)$ 通过积分定义 $h(T) = \\int_{T_0}^{T} c_p(\\tau) \\, d\\tau + h(T_0)$（对于任意参考温度 $T_0$）以及定义 $c_p(T) = \\left(\\frac{\\partial h}{\\partial T}\\right)_p$ 相互关联。对于单个温度区间上的NASA七系数多项式形式，使用以下经过充分检验的表示方法：\n- 无量纲热容比为 $c_p(T)/R = a_1 + a_2 T + a_3 T^2 + a_4 T^3 + a_5 T^4$，其中 $R$ 是通用气体常数。\n- 无量纲焓为 $h(T)/(R T) = a_1 + a_2 \\frac{T}{2} + a_3 \\frac{T^2}{3} + a_4 \\frac{T^3}{4} + a_5 \\frac{T^4}{5} + a_6 \\frac{1}{T}$，其中 $a_6$ 是一个调整焓参考水平的积分常数。\n- 第七个系数 $a_7$ 与熵有关，在本任务中不使用。\n\n在骨架机理中代表一个伪物种的集总异构体组中，混合物的性质是通过对单个异构体性质进行摩尔分数加权平均来构建的。对于一组具有归一化权重 $w_i$（使得 $\\sum_{i=1}^{n} w_i = 1$）的 $n$ 种异构体，其集总性质为 $c_p^{\\mathrm{lump}}(T) = \\sum_{i=1}^{n} w_i \\, c_{p,i}(T)$ 和 $h^{\\mathrm{lump}}(T) = \\sum_{i=1}^{n} w_i \\, h_i(T)$。\n\n您的目标是计算六个NASA多项式系数 $\\{a_1,a_2,a_3,a_4,a_5,a_6\\}$，这些系数通过求解一个由NASA形式所隐含的基函数构建的线性系统，从而在指定的温度范围内以最小二乘法的方式，同时对 $c_p(T)$ 和 $h(T)$ 的集总性质进行最佳拟合。您必须通过将在给定范围内的一系列温度点上求值的 $c_p(T)/R$ 和 $h(T)/(R T)$ 方程进行堆叠，来构造设计矩阵，从而得出一个线性最小二乘问题。您不能对目标系数使用简化公式；您必须从给定的基本原理出发，推导并实现最小二乘法的构建过程。\n\n单位和数值约定：\n- 使用 $R = 8.31446261815324\\,\\mathrm{J\\,mol^{-1}\\,K^{-1}}$。\n- 所有输入焓 $h(T)$ 必须以 $\\mathrm{J\\,mol^{-1}}$ 为单位，所有输入热容 $c_p(T)$ 必须以 $\\mathrm{J\\,mol^{-1}\\,K^{-1}}$ 为单位。\n- 使用无量纲形式 $c_p(T)/R$ 和 $h(T)/(R T)$ 来构建最小二乘问题。\n- 不涉及角度。\n\n测试套件和参数：实现程序，根据已知的“真实”NASA系数在单个区间上为每种异构体计算 $c_{p,i}(T)$ 和 $h_i(T)$，然后形成集总性质，并通过最小二乘法拟合六个系数 $\\{a_1,\\dots,a_6\\}$。对于下面的每个测试用例，在闭区间上使用指定数量的点对温度进行均匀采样，并使用所提供的异构体数据。\n\n将每种异构体性质的计算定义为其给定系数 $\\{a_1,a_2,a_3,a_4,a_5,a_6\\}$ 的函数如下：\n- $c_{p,i}(T)/R = a_1 + a_2 T + a_3 T^2 + a_4 T^3 + a_5 T^4$，\n- $h_i(T)/(R T) = a_1 + a_2 \\frac{T}{2} + a_3 \\frac{T^2}{3} + a_4 \\frac{T^3}{4} + a_5 \\frac{T^4}{5} + a_6 \\frac{1}{T}$。\n\n测试套件包括四个用例：\n\n- 用例A（一般多异构体集总）：\n  - 异构体 $1$ 系数：$\\{3.500000, 1.200\\times 10^{-3}, -3.000\\times 10^{-7}, 4.000\\times 10^{-11}, -2.000\\times 10^{-15}, -1.000000\\}$。\n  - 异构体 $2$ 系数：$\\{3.750000, 0.800\\times 10^{-3}, -2.500\\times 10^{-7}, 3.500\\times 10^{-11}, -1.800\\times 10^{-15}, -0.800000\\}$。\n  - 权重：$\\{0.6, 0.4\\}$。\n  - 温度范围：$[300\\,\\mathrm{K}, 1500\\,\\mathrm{K}]$，在 $41$ 个点上采样。\n\n- 用例B（单异构体边界）：\n  - 异构体 $1$ 系数：$\\{3.500000, 1.200\\times 10^{-3}, -3.000\\times 10^{-7}, 4.000\\times 10^{-11}, -2.000\\times 10^{-15}, -1.000000\\}$。\n  - 权重：$\\{1.0\\}$。\n  - 温度范围：$[300\\,\\mathrm{K}, 1500\\,\\mathrm{K}]$，在 $41$ 个点上采样。\n\n- 用例C（三异构体集总，扩展范围）：\n  - 异构体 $1$ 系数：$\\{3.500000, 1.200\\times 10^{-3}, -3.000\\times 10^{-7}, 4.000\\times 10^{-11}, -2.000\\times 10^{-15}, -1.000000\\}$。\n  - 异构体 $2$ 系数：$\\{3.750000, 0.800\\times 10^{-3}, -2.500\\times 10^{-7}, 3.500\\times 10^{-11}, -1.800\\times 10^{-15}, -0.800000\\}$。\n  - 异构体 $3$ 系数：$\\{3.250000, 1.500\\times 10^{-3}, -3.200\\times 10^{-7}, 4.500\\times 10^{-11}, -2.200\\times 10^{-15}, -1.200000\\}$。\n  - 权重：$\\{0.5, 0.25, 0.25\\}$。\n  - 温度范围：$[500\\,\\mathrm{K}, 2000\\,\\mathrm{K}]$，在 $51$ 个点上采样。\n\n- 用例D（相同异构体一致性检查）：\n  - 异构体 $1$ 系数：$\\{3.750000, 0.800\\times 10^{-3}, -2.500\\times 10^{-7}, 3.500\\times 10^{-11}, -1.800\\times 10^{-15}, -0.800000\\}$。\n  - 异构体 $2$ 系数：$\\{3.750000, 0.800\\times 10^{-3}, -2.500\\times 10^{-7}, 3.500\\times 10^{-11}, -1.800\\times 10^{-15}, -0.800000\\}$。\n  - 权重：$\\{0.5, 0.5\\}$。\n  - 温度范围：$[300\\,\\mathrm{K}, 800\\,\\mathrm{K}]$，在 $21$ 个点上采样。\n\n算法规范：\n- 对于每个用例，使用上述NASA形式和指定的 $R$ 值，根据给定系数为每个异构体在所有采样温度点上计算 $c_{p,i}(T)$ 和 $h_i(T)$。\n- 使用提供的权重形成集总性质 $c_p^{\\mathrm{lump}}(T)$ 和 $h^{\\mathrm{lump}}(T)$。\n- 通过在所有采样温度上堆叠 $c_p(T)/R$ 行和 $h(T)/(R T)$ 行来构建并求解 $\\{a_1,\\dots,a_6\\}$ 的线性最小二乘系统，两种性质在误差范数中具有相同的权重。\n\n要求的最终输出：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素是对应测试用例（按用例A、用例B、用例C、用例D的顺序）的拟合系数列表 $\\{a_1,a_2,a_3,a_4,a_5,a_6\\}$。例如，输出格式必须与 $\\left[[a_1,a_2,a_3,a_4,a_5,a_6],[a_1,a_2,a_3,a_4,a_5,a_6],[a_1,a_2,a_3,a_4,a_5,a_6],[a_1,a_2,a_3,a_4,a_5,a_6]\\right]$ 完全一样，只是用数值代替符号。",
            "solution": "该问题是有效的。它在科学上基于化学热化学原理，被明确地表述为一个线性最小二乘问题，并且所有必要的数据和约束条件都已明确提供。\n\n目标是确定一组六个 National Aeronautics and Space Administration (NASA) 多项式系数 $\\{A_1, A_2, A_3, A_4, A_5, A_6\\}$，用以描述一个集总伪物种的热化学性质。该伪物种是多种异构体的聚合体，其性质是组分异构体性质的摩尔分数加权平均值。这些系数必须在最小二乘意义上，为在一组离散的 $N$ 个温度点 $T_j$ 上生成的集总摩尔等压热容 $c_p^{\\mathrm{lump}}(T)$ 和摩尔焓 $h^{\\mathrm{lump}}(T)$ 数据提供最佳拟合。\n\n首先，我们定义我们为集总物种寻求的无量纲热容和焓的函数形式，这些形式由未知系数向量 $\\mathbf{x} = [A_1, A_2, A_3, A_4, A_5, A_6]^T$ 参数化：\n$$ \\frac{c_p^{\\mathrm{fit}}(T)}{R} = A_1 + A_2 T + A_3 T^2 + A_4 T^3 + A_5 T^4 $$\n$$ \\frac{h^{\\mathrm{fit}}(T)}{RT} = A_1 + A_2 \\frac{T}{2} + A_3 \\frac{T^2}{3} + A_4 \\frac{T^3}{4} + A_5 \\frac{T^4}{5} + A_6 \\frac{1}{T} $$\n其中 $R$ 是通用气体常数。\n\n接下来，我们定义集总物种的“真实”或目标性质。对于一组 $n$ 种异构体，每种异构体都有给定的权重 $w_i$（其中 $\\sum_{i=1}^n w_i = 1$）和其自己的一套 NASA 系数 $\\{a_{1,i}, a_{2,i}, \\dots, a_{6,i}\\}$，每种异构体 $i$ 的热化学性质由下式给出：\n$$ \\frac{c_{p,i}(T)}{R} = a_{1,i} + a_{2,i} T + a_{3,i} T^2 + a_{4,i} T^3 + a_{5,i} T^4 = \\sum_{k=1}^{5} a_{k,i} T^{k-1} $$\n$$ \\frac{h_i(T)}{RT} = a_{1,i} + a_{2,i} \\frac{T}{2} + a_{3,i} \\frac{T^2}{3} + a_{4,i} \\frac{T^3}{4} + a_{5,i} \\frac{T^4}{5} + a_{6,i} \\frac{1}{T} = \\sum_{k=1}^{5} a_{k,i} \\frac{T^{k-1}}{k} + a_{6,i} \\frac{1}{T} $$\n集总性质是加权平均值：\n$$ \\frac{c_p^{\\mathrm{lump}}(T)}{R} = \\sum_{i=1}^n w_i \\frac{c_{p,i}(T)}{R} $$\n$$ \\frac{h^{\\mathrm{lump}}(T)}{RT} = \\sum_{i=1}^n w_i \\frac{h_i(T)}{RT} $$\n这些在离散的 $N$ 个温度点 $\\{T_1, T_2, \\dots, T_N\\}$ 上求值的集总物理量，作为我们最小二乘拟合的目标数据。\n\n问题在于找到一个系数向量 $\\mathbf{x}$，以最小化残差平方和 $S$，其中残差是拟合函数形式与目标集总数据之间的差异，该和是在所有 $N$ 个温度点上对热容和焓求和得到的。\n$$ S = \\sum_{j=1}^{N} \\left[ \\left( \\frac{c_p^{\\mathrm{lump}}(T_j)}{R} - \\frac{c_p^{\\mathrm{fit}}(T_j)}{R} \\right)^2 + \\left( \\frac{h^{\\mathrm{lump}}(T_j)}{RT_j} - \\frac{h^{\\mathrm{fit}}(T_j)}{RT_j} \\right)^2 \\right] $$\n这是一个线性最小二乘问题。我们可以将其表示为矩阵形式 $\\mathbf{A} \\mathbf{x} \\approx \\mathbf{b}$，其中我们寻求最小化残差向量的欧几里得范数 $||\\mathbf{A} \\mathbf{x} - \\mathbf{b}||_2$ 的向量 $\\mathbf{x}$。\n\n观测向量 $\\mathbf{b}$ 包含目标热化学数据。它是一个大小为 $2N \\times 1$ 的列向量，通过将 $N$ 个无量纲热容值与 $N$ 个无量纲焓值相继堆叠而构成：\n$$ \\mathbf{b} = \\begin{pmatrix} c_p^{\\mathrm{lump}}(T_1)/R \\\\ \\vdots \\\\ c_p^{\\mathrm{lump}}(T_N)/R \\\\ h^{\\mathrm{lump}}(T_1)/(RT_1) \\\\ \\vdots \\\\ h^{\\mathrm{lump}}(T_N)/(RT_N) \\end{pmatrix} $$\n设计矩阵 $\\mathbf{A}$ 包含了在每个温度点上求值的拟合多项式的基函数。它是一个 $2N \\times 6$ 的矩阵。顶部的 $N$ 行对应热容方程，底部的 $N$ 行对应焓方程。对于给定的温度 $T_j$，$c_p/R$ 对应的行为 $[1, T_j, T_j^2, T_j^3, T_j^4, 0]$，而 $h/(RT)$ 对应的行为 $[1, T_j/2, T_j^2/3, T_j^3/4, T_j^4/5, 1/T_j]$。完整的矩阵是：\n$$ \\mathbf{A} =\n\\begin{pmatrix}\n1  T_1  T_1^2  T_1^3  T_1^4  0 \\\\\n\\vdots  \\vdots  \\vdots  \\vdots  \\vdots  \\vdots \\\\\n1  T_N  T_N^2  T_N^3  T_N^4  0 \\\\\n\\hline\n1  T_1/2  T_1^2/3  T_1^3/4  T_1^4/5  1/T_1 \\\\\n\\vdots  \\vdots  \\vdots  \\vdots  \\vdots  \\vdots \\\\\n1  T_N/2  T_N^2/3  T_N^3/4  T_N^4/5  1/T_N\n\\end{pmatrix} $$\n最小二乘解 $\\mathbf{x}$ 是求解正规方程 $\\mathbf{A}^T \\mathbf{A} \\mathbf{x} = \\mathbf{A}^T \\mathbf{b}$ 的向量。该系统可以使用数值线性代数库稳健地求解，例如，通过QR分解或奇异值分解(SVD)，这些方法在像 `numpy.linalg.lstsq` 这样的函数中都有标准实现。\n\n对于每个测试用例，算法按以下步骤进行：\n1. 在指定范围 $[T_{\\text{min}}, T_{\\text{max}}]$ 内生成一个包含 $N$ 个等间距温度 $T_j$ 的数组。\n2. 对于每种异构体 $i$，计算在所有 $T_j$ 上的 $c_{p,i}(T_j)/R$ 和 $h_i(T_j)/(RT_j)$ 值的向量。\n3. 通过对异构体性质进行加权求和，计算目标集总性质向量 $c_p^{\\mathrm{lump}}(T_j)/R$ 和 $h^{\\mathrm{lump}}(T_j)/(RT_j)$。\n4. 通过垂直堆叠集总的 $c_p/R$ 向量和集总的 $h/(RT)$ 向量，构建 $2N \\times 1$ 的观测向量 $\\mathbf{b}$。\n5. 根据上面推导的温度幂次，构建 $2N \\times 6$ 的设计矩阵 $\\mathbf{A}$。\n6. 使用标准的最小二乘求解器求解线性系统 $\\mathbf{A} \\mathbf{x} \\approx \\mathbf{b}$，得到未知系数向量 $\\mathbf{x} = [A_1, \\dots, A_6]^T$。\n7. 得到的向量 $\\mathbf{x}$ 包含了所需的目标集总伪物种的六个NASA系数。\n将此过程应用于所提供的四个测试用例中的每一个。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes NASA polynomial coefficients for a lumped pseudo-species by\n    simultaneously fitting enthalpy and heat capacity data via linear least squares.\n    \"\"\"\n    # Universal gas constant in J mol^-1 K^-1\n    R = 8.31446261815324\n\n    # Test suite definition\n    test_cases = {\n        \"Case A\": {\n            \"isomers\": [\n                {\"coeffs\": [3.500000, 1.200e-3, -3.000e-7, 4.000e-11, -2.000e-15, -1.000000]},\n                {\"coeffs\": [3.750000, 0.800e-3, -2.500e-7, 3.500e-11, -1.800e-15, -0.800000]}\n            ],\n            \"weights\": [0.6, 0.4],\n            \"temp_range\": (300.0, 1500.0),\n            \"num_points\": 41\n        },\n        \"Case B\": {\n            \"isomers\": [\n                {\"coeffs\": [3.500000, 1.200e-3, -3.000e-7, 4.000e-11, -2.000e-15, -1.000000]}\n            ],\n            \"weights\": [1.0],\n            \"temp_range\": (300.0, 1500.0),\n            \"num_points\": 41\n        },\n        \"Case C\": {\n            \"isomers\": [\n                {\"coeffs\": [3.500000, 1.200e-3, -3.000e-7, 4.000e-11, -2.000e-15, -1.000000]},\n                {\"coeffs\": [3.750000, 0.800e-3, -2.500e-7, 3.500e-11, -1.800e-15, -0.800000]},\n                {\"coeffs\": [3.250000, 1.500e-3, -3.200e-7, 4.500e-11, -2.200e-15, -1.200000]}\n            ],\n            \"weights\": [0.5, 0.25, 0.25],\n            \"temp_range\": (500.0, 2000.0),\n            \"num_points\": 51\n        },\n        \"Case D\": {\n            \"isomers\": [\n                {\"coeffs\": [3.750000, 0.800e-3, -2.500e-7, 3.500e-11, -1.800e-15, -0.800000]},\n                {\"coeffs\": [3.750000, 0.800e-3, -2.500e-7, 3.500e-11, -1.800e-15, -0.800000]}\n            ],\n            \"weights\": [0.5, 0.5],\n            \"temp_range\": (300.0, 800.0),\n            \"num_points\": 21\n        }\n    }\n\n    all_results = []\n    \n    # The order of cases for the output must be A, B, C, D\n    case_order = [\"Case A\", \"Case B\", \"Case C\", \"Case D\"]\n\n    for case_name in case_order:\n        case = test_cases[case_name]\n        isomers = case[\"isomers\"]\n        weights = case[\"weights\"]\n        t_min, t_max = case[\"temp_range\"]\n        n_points = case[\"num_points\"]\n\n        # 1. Generate temperature points\n        T = np.linspace(t_min, t_max, n_points)\n\n        # 2. Calculate \"true\" lumped properties (to form the 'b' vector)\n        cp_lump_over_R = np.zeros(n_points)\n        h_lump_over_RT = np.zeros(n_points)\n\n        for i, isomer in enumerate(isomers):\n            coeffs = np.array(isomer[\"coeffs\"])\n            w = weights[i]\n            \n            # Powers of T: T^0, T^1, T^2, T^3, T^4\n            T_powers = np.vander(T, N=5, increasing=True)\n            \n            # c_p,i / R = sum_{k=1..5} a_k * T^(k-1)\n            cp_i_over_R = T_powers @ coeffs[:5]\n            \n            # h_i / RT = sum_{k=1..5} a_k * T^(k-1)/k + a_6/T\n            h_i_over_RT = (T_powers / np.arange(1, 6)) @ coeffs[:5] + coeffs[5] / T\n\n            cp_lump_over_R += w * cp_i_over_R\n            h_lump_over_RT += w * h_i_over_RT\n\n        # 3. Construct observation vector b\n        b = np.concatenate([cp_lump_over_R, h_lump_over_RT])\n\n        # 4. Construct design matrix A\n        A = np.zeros((2 * n_points, 6))\n        \n        # Basis functions for T\n        T_powers = np.vander(T, N=5, increasing=True) # T^0, T^1, ..., T^4\n\n        # Top part for c_p/R\n        A[:n_points, :5] = T_powers\n        # a6 coefficient is 0 for c_p\n        A[:n_points, 5] = 0\n\n        # Bottom part for h/RT\n        A[n_points:, :5] = T_powers / np.arange(1, 6)\n        A[n_points:, 5] = 1.0 / T\n\n        # 5. Solve the linear least squares system Ax = b\n        # rcond=None to use the machine-precision default\n        lumped_coeffs, _, _, _ = np.linalg.lstsq(A, b, rcond=None)\n        \n        all_results.append(lumped_coeffs.tolist())\n\n    # Format the output as a string to match the required format exactly\n    # e.g., [[c1,c2,...],[c1,c2,...]] without spaces after commas inside inner lists\n    \n    # Custom string formatting to avoid spaces introduced by default str(list)\n    formatted_results = []\n    for res in all_results:\n        # Format numbers to a reasonable precision for clean output\n        formatted_coeffs = [f\"{c:.15g}\" for c in res]\n        formatted_results.append(f\"[{','.join(formatted_coeffs)}]\")\n    \n    final_output_str = f\"[{','.join(formatted_results)}]\"\n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}