{
    "hands_on_practices": [
        {
            "introduction": "本练习深入探讨了求解 BDF 方法所产生的隐式方程的核心机制。通过为使用 BDF-2 的简单单组分反应推导牛顿法更新步骤，您将具体理解每个时间步的解是如何迭代计算的。这项基础技能对于理解刚性积分器的计算开销和行为至关重要。",
            "id": "4008896",
            "problem": "考虑计算燃烧学中的一个单物种单分子分解过程，其中质量分数 $y$ 遵循常微分方程 $y' = f(y) = -k(T)\\,y$ 演化，其中 $k(T)$ 是在恒定温度 $T$ 下的阿伦尼乌斯速率常数，$y$ 是一个无量纲的质量分数。时间积分采用二阶向后差分公式（BDF）方法，具体为 BDF-2 公式，在步长为 $h0$ 的均匀时间网格上进行。BDF-2 离散化是一个经过充分检验的公式，通过对穿过三个连续点的二次插值多项式求导得到，其关系式如下\n$$\n\\frac{3\\,y_{n} - 4\\,y_{n-1} + y_{n-2}}{2\\,h} = f(y_{n}) \\, ,\n$$\n该式定义了在已知值 $y_{n-1}$ 和 $y_{n-2}$ 的情况下，$y_{n}$ 在时间索引 $n$ 处必须满足的隐式代数方程。\n\n使用单次 Newton 迭代来求解在时间索引 $n$ 处的这个隐式方程。设 $y_{n}^{(m)}$ 表示当前的 Newton 迭代值。该隐式方程的残差为\n$$\nR\\!\\left(y_{n}^{(m)}\\right) = \\frac{3\\,y_{n}^{(m)} - 4\\,y_{n-1} + y_{n-2}}{2\\,h} - f\\!\\left(y_{n}^{(m)}\\right) \\, ,\n$$\n动力学方程关于 $y$ 的雅可比矩阵为 $J = \\frac{\\partial f}{\\partial y} = -k(T)$，由于温度 $T$ 恒定，它在整个步长内被视为常数。\n\n从这些基本原理出发，推导求解在当前迭代值 $y_{n}^{(m)}$ 处 BDF-2 隐式方程的线性化系统的标量 Newton 更新量 $\\Delta y_{n}^{(m)}$，其中使用 $J=-k(T)$。将 $\\Delta y_{n}^{(m)}$ 表示为 $y_{n}^{(m)}$、$y_{n-1}$、$y_{n-2}$、$h$ 和 $k(T)$ 的闭式函数。将最终答案表示为 $\\Delta y_{n}^{(m)}$ 的单个闭式解析表达式。不需要进行数值近似或四舍五入，并且由于 $y$ 是无量纲的，最终表达式中不应包含任何物理单位。",
            "solution": "动力学由常微分方程 $y' = f(y) = -k(T)\\,y$ 定义，其中由于温度 $T$ 恒定，$k(T)$ 在整个时间步长内被视为常数。在步长为 $h$ 的均匀时间网格上使用二阶向后差分公式（BDF-2），用 $y_{n-1}$ 和 $y_{n-2}$ 定义 $y_n$ 的隐式关系是一个经过充分检验的公式：\n$$\n\\frac{3\\,y_{n} - 4\\,y_{n-1} + y_{n-2}}{2\\,h} = f(y_{n}) \\, .\n$$\n重排此方程以定义残差函数 $R(y_{n})$，可得：\n$$\nR(y_{n}) = \\frac{3\\,y_{n} - 4\\,y_{n-1} + y_{n-2}}{2\\,h} - f(y_{n}) \\, .\n$$\n一次 Newton 迭代在当前迭代值 $y_{n}^{(m)}$ 处对残差进行线性化，并通过求解以下方程来计算更新量 $\\Delta y_{n}^{(m)}$：\n$$\n\\left(\\frac{\\partial R}{\\partial y}\\bigg|_{y=y_{n}^{(m)}}\\right)\\,\\Delta y_{n}^{(m)} = -R\\!\\left(y_{n}^{(m)}\\right) \\, .\n$$\n我们现在计算 $R(y)$ 在 $y_{n}^{(m)}$ 处关于 $y$ 的导数。残差是 $y_n$ 的一个线性项与非线性动力学项 $f(y_n)$ 之差，所以\n$$\n\\frac{\\partial R}{\\partial y}\\bigg|_{y=y_{n}^{(m)}} = \\frac{3}{2\\,h} - \\frac{\\partial f}{\\partial y}\\bigg|_{y=y_{n}^{(m)}} \\, .\n$$\n对于给定的动力学 $f(y) = -k(T)\\,y$，其关于 $y$ 的雅可比矩阵为\n$$\nJ = \\frac{\\partial f}{\\partial y} = -k(T) \\, .\n$$\n将 $J = -k(T)$ 代入 $\\frac{\\partial R}{\\partial y}$ 的表达式中，得到\n$$\n\\frac{\\partial R}{\\partial y}\\bigg|_{y=y_{n}^{(m)}} = \\frac{3}{2\\,h} - \\left(-k(T)\\right) = \\frac{3}{2\\,h} + k(T) \\, .\n$$\n在 $y_{n}^{(m)}$ 处计算的残差为\n$$\nR\\!\\left(y_{n}^{(m)}\\right) = \\frac{3\\,y_{n}^{(m)} - 4\\,y_{n-1} + y_{n-2}}{2\\,h} - \\left(-k(T)\\,y_{n}^{(m)}\\right) = \\frac{3\\,y_{n}^{(m)} - 4\\,y_{n-1} + y_{n-2}}{2\\,h} + k(T)\\,y_{n}^{(m)} \\, .\n$$\n因此，Newton 更新量 $\\Delta y_{n}^{(m)}$ 满足\n$$\n\\left(\\frac{3}{2\\,h} + k(T)\\right)\\,\\Delta y_{n}^{(m)} = -\\left[\\frac{3\\,y_{n}^{(m)} - 4\\,y_{n-1} + y_{n-2}}{2\\,h} + k(T)\\,y_{n}^{(m)}\\right] \\, .\n$$\n求解 $\\Delta y_{n}^{(m)}$，得到闭式标量更新量\n$$\n\\Delta y_{n}^{(m)} = -\\frac{\\frac{3\\,y_{n}^{(m)} - 4\\,y_{n-1} + y_{n-2}}{2\\,h} + k(T)\\,y_{n}^{(m)}}{\\frac{3}{2\\,h} + k(T)} \\, .\n$$\n此表达式是 Newton 修正量，当将其加到 $y_{n}^{(m)}$ 上时，便得到下一个迭代值 $y_{n}^{(m+1)} = y_{n}^{(m)} + \\Delta y_{n}^{(m)}$。由于 $f(y)$ 是关于 $y$ 的线性函数，Newton 迭代在一步之内即可收敛到精确的隐式解，但题目要求的是用 $y_{n}^{(m)}$、$y_{n-1}$、$y_{n-2}$、$h$ 和 $k(T)$ 表示的显式 Newton 更新量 $\\Delta y_{n}^{(m)}$，我们已在上面推导出了该表达式。",
            "answer": "$$\\boxed{-\\frac{\\frac{3\\,y_{n}^{(m)} - 4\\,y_{n-1} + y_{n-2}}{2\\,h} + k(T)\\,y_{n}^{(m)}}{\\frac{3}{2\\,h} + k(T)}}$$"
        },
        {
            "introduction": "为何 BDF 方法是求解刚性化学动力学问题的首选工具？本实践旨在探索绝对稳定性的概念，这是其有效性的关键。通过分析 BDF-3 方法对于一个具有巨大负实部特征值系统的稳定性，您将理解这些方法如何突破刚性所带来的严格时间步长限制，从而实现长时间尺度的高效模拟。",
            "id": "4008881",
            "problem": "在计算燃烧学中，刚性化学动力学的时间积分通常采用隐式线性多步法，例如三阶向后差分格式（BDF-3）。考虑一个均相、等温反应器模型，其化学源项在某个状态点附近进行线性化，得到一个雅可比矩阵，该矩阵在实轴上有一个主导特征值，记为 $\\lambda_{\\max} = -1.0 \\times 10^{7}\\ \\mathrm{s}^{-1}$。为了进行稳定性分析，我们将线性化系统的每个模态用线性测试方程 $\\frac{dy}{dt} = \\lambda y$（其中 $\\lambda \\in \\mathbb{C}$）来近似。回顾一下，当一个线性多步法应用于该测试方程时，其绝对稳定性是由所有满足以下条件的 $z \\in \\mathbb{C}$（其中 $z = h \\lambda$）的集合所定义的：该方法的特征根的模长小于或等于1。数值分析中一个经过充分检验的事实是，BDF-3是$A(\\alpha)$-稳定的，这意味着其绝对稳定域包含一个围绕负实轴、半角为 $\\alpha  0$ 的扇形区域，并且特别地，它包含了整个负实轴。\n\n假设步长 $h  0$，并且稳定性要求 $|R(h \\lambda_{\\max})| \\leq 1$ 在线性多步法绝对稳定性的意义下成立（即所有特征根的模长小于或等于1），请确定使BDF-3方法对于与 $\\lambda_{\\max}$ 相关的模态保持线性稳定的 $h$ 的上确界。请将最终答案以秒为单位表示，并对此结果给出一个简明的解释，说明在实践中是什么因素限制了此类模态的步长。",
            "solution": "该问题要求确定当三阶向后差分格式（BDF-3）应用于一个由大的负实特征值表征的系统模态时，使其保持稳定的时间步长 $h$ 的上确界。\n\n求解常微分方程的数值方法的稳定性通常使用线性测试方程进行分析：\n$$\n\\frac{dy}{dt} = \\lambda y\n$$\n其中 $\\lambda \\in \\mathbb{C}$ 是一个常数，代表了线性化系统雅可比矩阵的一个特征值。\n\n对于一个线性多步法，其绝对稳定性的条件由其特征多项式的根决定。对于给定的复数 $z = h \\lambda$，如果特征多项式 $\\rho(\\xi) - z \\sigma(\\xi) = 0$ 的所有根 $\\xi$ 都满足根条件：$|\\xi| \\le 1$，且任何模为1的根都必须是单根，那么该方法就被认为是绝对稳定的。所有使该方法稳定的此类 $z$ 的集合构成了复平面上的绝对稳定域。\n\n在这个问题中，我们已知：\n1.  数值方法是 BDF-3。\n2.  刚性模态的主导特征值是 $\\lambda_{\\max} = -1.0 \\times 10^{7}\\ \\mathrm{s}^{-1}$。这是一个严格为负的实数。\n3.  时间步长 $h$ 是一个正实数，$h  0$。\n4.  用于稳定性分析的参数是 $z = h \\lambda_{\\max}$。由于 $h  0$ 且 $\\lambda_{\\max}  0$，乘积 $z$ 将永远是一个严格为负的实数。$z$ 的所有可能值的集合是负实轴 $(-\\infty, 0)$。\n\n问题陈述中提供的一个关键信息是，BDF-3 方法是 $A(\\alpha)$-稳定的，并且具体来说，其绝对稳定域“包含整个负实轴”。这意味着对于任何满足 $z \\in (-\\infty, 0]$ 的 $z$ 值，BDF-3 方法都满足根条件，因此是稳定的。\n\n由于我们的参数 $z = h \\lambda_{\\max}$ 对于任何 $h  0$ 的选择都将位于负实轴上，并且该方法对于整个负实轴都是稳定的，因此对于该模态，无论 $h$ 的值是多少，该方法都是稳定的。对于所有 $h \\in (0, \\infty)$，稳定性条件都得到满足。\n\n问题要求使该方法线性稳定的 $h$ 的上确界。$h$ 的允许值集合是区间 $(0, \\infty)$。该集合的上确界（或最小上界）是无穷大。\n$$\n\\sup \\{ h \\in \\mathbb{R} \\mid h  0 \\} = \\infty\n$$\n\n这一结果的解释是，对于具有大的负实特征值的刚性模态（这在化学动力学中是典型的），BDF-3 方法的稳定性不会对步长 $h$ 施加任何上限。这也正是为何这类“刚性稳定”的隐式方法被用于解决此类问题的原因；它们克服了显式方法（例如，前向欧拉法）所施加的严格步长限制，显式方法会要求 $h |\\lambda_{\\max}|$ 的数量级为1。\n\n然而，在实践中，步长 $h$ 并不会被选得任意大。虽然对于这种刚性模态，一个非常大的步长在数值上是稳定的，但这可能会导致解出现较大的误差，从而无法准确捕捉系统的动力学行为。仿真的整体精度通常取决于解析系统*较慢*模态时间尺度的需求，而非最快（最刚性）模态。因此，在实际应用中，步长受到精度因素的限制，而不是最刚性分量的稳定性。",
            "answer": "$$\n\\boxed{\\infty}\n$$"
        },
        {
            "introduction": "最后的这项实践通过解决计算化学中的一个经典基准问题——Robertson 问题，将理论与应用联系起来。您将使用一个高质量的 BDF 求解器来模拟这个刚性系统，并观察其在极大差异的时间尺度上的行为。本练习展示了建立、求解和分析一个刚性常微分方程系统的完整工作流程，从而巩固您对 BDF 方法在真实科学背景下如何应用的理解。",
            "id": "2372608",
            "problem": "构建一个完整、可运行的程序，使用变阶、变步长的后向差分公式 (Backward Differentiation Formula, BDF) 来近似求解一个常微分方程 (Ordinary Differential Equations, ODEs) 刚性系统。目标模型是 Robertson 化学动力学系统，该系统由浓度 $y_1(t)$、$y_2(t)$ 和 $y_3(t)$ 定义如下：\n$$\n\\frac{d y_1}{d t} = -0.04\\, y_1 + 10^{4}\\, y_2\\, y_3,\\quad\n\\frac{d y_2}{d t} = 0.04\\, y_1 - 10^{4}\\, y_2\\, y_3 - 3\\times 10^{7}\\, y_2^{2},\\quad\n\\frac{d y_3}{d t} = 3\\times 10^{7}\\, y_2^{2},\n$$\n初始条件为\n$$\ny_1(0)=1,\\quad y_2(0)=0,\\quad y_3(0)=0,\n$$\n时间域为 $t\\in[0, T]$。所有因变量均为无量纲，时间 $t$ 以秒为单位。程序必须实现时间自适应和阶数自适应，以使数值近似在给定的容差下保持用户指定的精度。\n\n您的程序必须在三个不同的最终时间和精度要求下评估该系统。对于下方的每个测试用例，从给定的初始条件出发，使用指定的相对容差 $r_{\\mathrm{tol}}$ 和绝对容差 $a_{\\mathrm{tol}}$，将系统从 $t=0$ 积分到 $t=T$。将标量值 $y_3(T)$ 作为浮点数报告。\n\n测试套件：\n- 用例 A（早期刚性解析）：$T=10^{-6}$，$r_{\\mathrm{tol}}=10^{-6}$，$a_{\\mathrm{tol}}=10^{-14}$。\n- 用例 B（中期行为）：$T=1$，$r_{\\mathrm{tol}}=10^{-6}$，$a_{\\mathrm{tol}}=10^{-12}$。\n- 用例 C（长时渐近）：$T=10^{5}$，$r_{\\mathrm{tol}}=10^{-6}$，$a_{\\mathrm{tol}}=10^{-12}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果的顺序必须完全为 $[y_3(T\\text{ of Case A}), y_3(T\\text{ of Case B}), y_3(T\\text{ of Case C})]$。例如，输出必须如下所示：\n$$\n[\\text{value\\_A},\\text{value\\_B},\\text{value\\_C}],\n$$\n其中每个条目都是一个浮点数。\n\n该问题应纯粹在数学和计算层面进行求解和验证，除了要求以指定格式输出单行结果外，不依赖于任何特定的编程语言。不应读取任何外部输入。所有数值答案必须表示为不带单位或百分号的浮点数。",
            "solution": "对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- **常微分方程组 (ODEs):**\n$$\n\\frac{d y_1}{d t} = -0.04\\, y_1 + 10^{4}\\, y_2\\, y_3\n$$\n$$\n\\frac{d y_2}{d t} = 0.04\\, y_1 - 10^{4}\\, y_2\\, y_3 - 3\\times 10^{7}\\, y_2^{2}\n$$\n$$\n\\frac{d y_3}{d t} = 3\\times 10^{7}\\, y_2^{2}\n$$\n- **初始条件：** 在 $t=0$ 时，$y(0) = [y_1(0), y_2(0), y_3(0)] = [1, 0, 0]$。\n- **时间域：** $t \\in [0, T]$。\n- **实现要求：** 使用变阶、变步长的后向差分公式 (BDF) 进行近似。\n- **测试用例：**\n  - 用例 A: $T=10^{-6}$，$r_{\\mathrm{tol}}=10^{-6}$，$a_{\\mathrm{tol}}=10^{-14}$。\n  - 用例 B: $T=1$，$r_{\\mathrm{tol}}=10^{-6}$，$a_{\\mathrm{tol}}=10^{-12}$。\n  - 用例 C: $T=10^{5}$，$r_{\\mathrm{tol}}=10^{-6}$，$a_{\\mathrm{tol}}=10^{-12}$。\n- **要求输出：** 每个用例的 $y_3(T)$ 值，格式化为单行列表：`[value_A,value_B,value_C]`。\n\n**步骤 2：已知条件验证**\n该问题具有科学依据。Robertson 系统是源于化学动力学的刚性初值问题的典型基准。刚性系统的特点是存在多个、时间尺度相差悬殊的演化过程。速率常数从 $k_1=0.04$ 到 $k_3=3\\times 10^{7}$ 不等，这产生了刚性。该问题是适定的；作为一个具有光滑（多项式）右端项的初值问题，其存在唯一解。该问题是自包含的，为数值求解提供了所有必要的参数和条件。目标陈述清晰，没有歧义。\n\n**步骤 3：结论与行动**\n问题有效。将构建一个合理的解决方案。\n\n**求解推导**\n任务是求解一个刚性常微分方程组 ($ODEs$)。该系统的形式为 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(t, \\mathbf{y})$，其中 $\\mathbf{y}(t) = [y_1(t), y_2(t), y_3(t)]^T$ 是状态向量。由于其刚性，无法高效使用标准的显式数值方法（例如，Runge-Kutta），因为这些方法需要极小的时间步长才能维持数值稳定性。\n\n指定的方法是后向差分公式 (BDF)，这是一族适用于刚性问题的隐式多步法。$k$ 步 BDF 方法使用当前步的解 $\\mathbf{y}_{n+1}$ 和前 $k$ 步的解 $\\mathbf{y}_{n}, \\dots, \\mathbf{y}_{n+1-k}$ 来近似时间 $t_{n+1}$ 处的导数 $\\frac{d\\mathbf{y}}{dt}$。对于常数步长 $h$，通用公式为：\n$$\n\\sum_{j=0}^{k} \\alpha_j \\mathbf{y}_{n+1-j} = h \\beta \\mathbf{f}(t_{n+1}, \\mathbf{y}_{n+1})\n$$\n对于 BDF 方法，$\\beta=1$，且选择系数 $\\alpha_j$ 以最大化精度阶数。例如，BDF1（隐式欧拉）和 BDF2 公式为：\n$$\n\\text{BDF1 (order 1): } \\mathbf{y}_{n+1} - \\mathbf{y}_{n} = h \\mathbf{f}(t_{n+1}, \\mathbf{y}_{n+1})\n$$\n$$\n\\text{BDF2 (order 2): } \\frac{3}{2}\\mathbf{y}_{n+1} - 2\\mathbf{y}_{n} + \\frac{1}{2}\\mathbf{y}_{n-1} = h \\mathbf{f}(t_{n+1}, \\mathbf{y}_{n+1})\n$$\n由于 $\\mathbf{y}_{n+1}$ 出现在方程的两边（它是一般非线性函数 $\\mathbf{f}$ 的一个参数），因此在每个时间步都必须求解一个代数方程组。这通常通过使用拟牛顿法（例如牛顿法）来完成，该方法求解以下寻根问题：\n$$\n\\mathbf{G}(\\mathbf{y}_{n+1}) = \\mathbf{y}_{n+1} - h\\gamma \\mathbf{f}(t_{n+1}, \\mathbf{y}_{n+1}) - \\mathbf{\\Psi} = \\mathbf{0}\n$$\n这里，$\\gamma$ 是一个 BDF 系数，$\\mathbf{\\Psi}$ 包含已知过去值的总和。牛顿法的迭代更新公式为：\n$$\n\\mathbf{y}_{n+1}^{(m+1)} = \\mathbf{y}_{n+1}^{(m)} - [\\mathbf{I} - h\\gamma \\mathbf{J}]^{-1} \\mathbf{G}(\\mathbf{y}_{n+1}^{(m)})\n$$\n其中 $\\mathbf{I}$ 是单位矩阵，$\\mathbf{J}$ 是 $\\mathbf{f}$ 关于 $\\mathbf{y}$ 的雅可比矩阵，在 $(t_{n+1}, \\mathbf{y}_{n+1}^{(m)})$ 处求值。雅可比矩阵定义为 $J_{ij} = \\frac{\\partial f_i}{\\partial y_j}$。提供解析雅可比矩阵对于求解器的效率和鲁棒性至关重要。对于给定的 Robertson 系统，雅可比矩阵为：\n$$\n\\mathbf{J}(t, \\mathbf{y}) = \\begin{pmatrix}\n-0.04  10^4 y_3  10^4 y_2 \\\\\n0.04  -10^4 y_3 - 6 \\times 10^7 y_2  -10^4 y_2 \\\\\n0  6 \\times 10^7 y_2  0\n\\end{pmatrix}\n$$\n从基本原理实现一个变阶、变步长的 BDF 求解器是一项艰巨的任务，涉及误差估计（以调整步长 $h$ 和阶数 $k$）、步长变化时的插值以及鲁棒的非线性系统求解。一种科学严谨且实用的方法是使用提供此功能的高质量、专业实现的数值库。指定的执行环境允许使用 `scipy`，版本为 `1.11.4`。函数 `scipy.integrate.solve_ivp` 及其参数 `method='BDF'` 就是此类求解器的实现。它会自适应地选择公式阶数（$k$ 从 1 到 5）和步长 $h$，以满足给定的相对 ($r_{\\mathrm{tol}}$) 和绝对 ($a_{\\mathrm{tol}}$) 容差。\n\n因此，求解策略是定义 ODE 函数 $\\mathbf{f}(t, \\mathbf{y})$ 及其雅可比矩阵 $\\mathbf{J}(t, \\mathbf{y})$。然后，对于每个测试用例，我们使用指定的参数（`t_span`, `y0`, `method='BDF'`, `rtol`, `atol` 和雅可比函数）调用 `scipy.integrate.solve_ivp`。从结果中提取 $y_3$ 的最终值。此过程遵循问题陈述，同时确保数值上合理和正确的解。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the Robertson stiff ODE system using a variable-order, variable-step\n    Backward Differentiation Formula (BDF) method, as implemented in SciPy.\n    \"\"\"\n    \n    # Define the system of ODEs for the Robertson problem.\n    # y[0] corresponds to y_1, y[1] to y_2, y[2] to y_3.\n    def robertson_ode(t, y):\n        k1 = 0.04\n        k2 = 1.0e4\n        k3 = 3.0e7\n        \n        dy1dt = -k1 * y[0] + k2 * y[1] * y[2]\n        dy2dt = k1 * y[0] - k2 * y[1] * y[2] - k3 * y[1]**2\n        dy3dt = k3 * y[1]**2\n        \n        return [dy1dt, dy2dt, dy3dt]\n\n    # Define the analytical Jacobian of the ODE system.\n    # Providing the Jacobian significantly improves the performance of stiff solvers.\n    def robertson_jacobian(t, y):\n        k1 = 0.04\n        k2 = 1.0e4\n        k3 = 3.0e7\n        \n        # J_ij = df_i / dy_j\n        jac = np.zeros((3, 3))\n        \n        # Row 1: d(dy1/dt)/dy_j\n        jac[0, 0] = -k1\n        jac[0, 1] = k2 * y[2]\n        jac[0, 2] = k2 * y[1]\n        \n        # Row 2: d(dy2/dt)/dy_j\n        jac[1, 0] = k1\n        jac[1, 1] = -k2 * y[2] - 2 * k3 * y[1]\n        jac[1, 2] = -k2 * y[1]\n        \n        # Row 3: d(dy3/dt)/dy_j\n        jac[2, 0] = 0.0\n        jac[2, 1] = 2 * k3 * y[1]\n        jac[2, 2] = 0.0\n        \n        return jac\n\n    # Initial condition: y(0) = [1, 0, 0]\n    y0 = [1.0, 0.0, 0.0]\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (T, rtol, atol)\n    test_cases = [\n        (1.0e-6, 1.0e-6, 1.0e-14),  # Case A\n        (1.0, 1.0e-6, 1.0e-12),      # Case B\n        (1.0e5, 1.0e-6, 1.0e-12),    # Case C\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        T, rtol, atol = case\n        \n        # The time interval for integration\n        t_span = (0.0, T)\n        \n        # Solve the ODE system using the 'BDF' method\n        sol = solve_ivp(\n            fun=robertson_ode,\n            t_span=t_span,\n            y0=y0,\n            method='BDF',\n            jac=robertson_jacobian,\n            rtol=rtol,\n            atol=atol,\n        )\n        \n        # Check if the integration was successful\n        if not sol.success:\n            # This should not happen for a valid problem but is good practice\n            raise RuntimeError(f\"Solver failed for T={T}, rtol={rtol}, atol={atol}: {sol.message}\")\n            \n        # The solution at the final time T is sol.y[:, -1]\n        final_y = sol.y\n        # We need the value of y3(T), which is the third component\n        y3_at_T = final_y[2, -1]\n        \n        results.append(y3_at_T)\n\n    # Format the results as a string and print\n    # The output must be without any surrounding text, just the list.\n    # The `repr` function is used to ensure full floating-point precision in the output string.\n    print(f\"[{','.join(map(repr, results))}]\")\n\nsolve()\n```"
        }
    ]
}