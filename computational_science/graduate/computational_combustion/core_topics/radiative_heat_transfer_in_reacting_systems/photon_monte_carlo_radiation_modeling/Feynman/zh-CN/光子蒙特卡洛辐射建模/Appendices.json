{
    "hands_on_practices": [
        {
            "introduction": "在模拟光子输运之前，我们必须首先确定介质的光学特性，这些特性在燃烧等应用中取决于局部的温度和化学组分。这项练习将训练您如何基于基础组分数据计算关键的辐射属性，例如单次散射反照率（single-scattering albedo）。这是将辐射模型与计算流体动力学（CFD）仿真相结合时至关重要的第一步 。",
            "id": "4049622",
            "problem": "考虑在一个使用光子蒙特卡洛 (PMC) 方法建模的计算流体动力学 (CFD) 燃烧域内，频率为 $\\nu$ 的单色光子输运。在每个空间位置 $\\mathbf{x}$，热化学状态由温度 $T(\\mathbf{x})$（单位：开尔文）和组分 $i \\in \\{\\mathrm{CO_2}, \\mathrm{H_2O}, \\mathrm{N_2}, \\mathrm{soot}\\}$ 的质量分数 $Y_i(\\mathbf{x})$ 表示，其中 $\\sum_i Y_i(\\mathbf{x}) = 1$ 且 $Y_i(\\mathbf{x}) \\ge 0$。目标是利用测量的吸收和散射代理闭合模型，计算空间变化的单次散射反照率 $\\omega_\\nu(\\mathbf{x})$，该值定义为局部消光中可归因于散射的部分所占的比例。\n\n假设每个组分的每单位质量分数的单色吸收和散射系数具有以下科学上合理的代理模型：\n- 对于吸收，对于 $i \\in \\{\\mathrm{CO_2}, \\mathrm{H_2O}, \\mathrm{N_2}, \\mathrm{soot}\\}$，\n$$\n\\kappa_{\\nu,i}(T) = a_i \\left(\\frac{T}{1000}\\right)^{p_i} \\quad \\text{单位为 } \\mathrm{m}^{-1} \\text{ 每单位质量分数}。\n$$\n使用常数\n$$\na_{\\mathrm{CO_2}}=0.5,\\; p_{\\mathrm{CO_2}}=1.2;\\quad\na_{\\mathrm{H_2O}}=0.7,\\; p_{\\mathrm{H_2O}}=1.1;\\quad\na_{\\mathrm{N_2}}=0.02,\\; p_{\\mathrm{N_2}}=1.0;\\quad\na_{\\mathrm{soot}}=1.5,\\; p_{\\mathrm{soot}}=0.9.\n$$\n- 对于散射，\n$$\n\\sigma_{s,\\nu,\\mathrm{CO_2}}(T)=0,\\quad\n\\sigma_{s,\\nu,\\mathrm{H_2O}}(T)=0,\\quad\n\\sigma_{s,\\nu,\\mathrm{N_2}}(T)=b_{\\mathrm{N_2}}\\left(\\frac{1000}{T}\\right),\\quad\n\\sigma_{s,\\nu,\\mathrm{soot}}(T)=b_{\\mathrm{soot}}\\left(\\frac{T}{1500}\\right),\n$$\n常数 $b_{\\mathrm{N_2}}=0.003$ 和 $b_{\\mathrm{soot}}=2.5$，单位为 $\\mathrm{m}^{-1}$ 每单位质量分数。\n\n给定某点处状态为 $(T,Y)$ 的混合物，将混合物吸收和散射系数定义为质量分数加权和：\n$$\n\\kappa_\\nu(T,Y) = \\sum_{i} Y_i \\,\\kappa_{\\nu,i}(T), \\qquad\n\\sigma_{s,\\nu}(T,Y) = \\sum_{i} Y_i \\,\\sigma_{s,\\nu,i}(T).\n$$\n将消光系数定义为\n$$\n\\beta_\\nu(T,Y) = \\kappa_\\nu(T,Y) + \\sigma_{s,\\nu}(T,Y).\n$$\n将单次散射反照率 $\\omega_\\nu(T,Y)$ 定义为散射对总消光贡献的无量纲比率。为保证数值稳定性，使用以下约定：\n$$\n\\omega_\\nu(T,Y) =\n\\begin{cases}\n0,   \\text{如果 } \\beta_\\nu(T,Y)  \\varepsilon,\\\\\n\\dfrac{\\sigma_{s,\\nu}(T,Y)}{\\beta_\\nu(T,Y)},   \\text{其他情况},\n\\end{cases}\n$$\n其中 $\\varepsilon = 10^{-12}\\ \\mathrm{m}^{-1}$。\n\n实现一个程序，该程序对下方的每个测试用例，使用上述定义计算 $\\omega_\\nu$。在计算之前，通过将任何负的 $Y_i$ 截断为 0，并用其和对向量 $Y$ 进行重新归一化（如果和为严格正值），来强制执行约束 $Y_i \\ge 0$ 和 $\\sum_i Y_i = 1$；如果截断后和为零，则按约定将 $\\omega_\\nu$ 设置为 0。\n\n物理和数值单位：\n- 温度 $T$ 的单位必须是开尔文。\n- $\\kappa_\\nu$ 和 $\\sigma_{s,\\nu}$ 的单位是 $\\mathrm{m}^{-1}$。\n- $\\omega_\\nu$ 是无量纲的，并且必须报告为四舍五入到小数点后六位的小数。\n\n测试套件（每个用例是一个单一的空间位置）：\n1. $T=1800$, $Y_{\\mathrm{CO_2}}=0.12$, $Y_{\\mathrm{H_2O}}=0.18$, $Y_{\\mathrm{N_2}}=0.70$, $Y_{\\mathrm{soot}}=0.00$.\n2. $T=2000$, $Y_{\\mathrm{CO_2}}=0.10$, $Y_{\\mathrm{H_2O}}=0.15$, $Y_{\\mathrm{N_2}}=0.73$, $Y_{\\mathrm{soot}}=0.02$.\n3. $T=300$, $Y_{\\mathrm{CO_2}}=0.00$, $Y_{\\mathrm{H_2O}}=0.00$, $Y_{\\mathrm{N_2}}=0.999$, $Y_{\\mathrm{soot}}=0.001$.\n4. $T=800$, $Y_{\\mathrm{CO_2}}=0.05$, $Y_{\\mathrm{H_2O}}=0.10$, $Y_{\\mathrm{N_2}}=0.84$, $Y_{\\mathrm{soot}}=0.01$.\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表项按上述测试套件的顺序排列，例如“[result1,result2,result3,result4]”。每个结果必须是相应案例的 $\\omega_\\nu$ 值，四舍五入到小数点后六位，不带单位。",
            "solution": "该问题要求计算燃烧环境中特定空间位置处的单色单次散射反照率，记为 $\\omega_\\nu$。计算基于所提供的关于组成气体和烟尘组分的吸收和散射特性的代理模型。每个位置的热化学状态由温度 $T$ 和组分 $i \\in \\{\\mathrm{CO_2}, \\mathrm{H_2O}, \\mathrm{N_2}, \\mathrm{soot}\\}$ 的质量分数 $Y_i$ 定义。\n\n单次散射反照率 $\\omega_\\nu$ 是一个无量纲量，表示总消光中由散射引起的部分所占的比例。其定义为：\n$$\n\\omega_\\nu = \\frac{\\sigma_{s,\\nu}}{\\beta_\\nu}\n$$\n其中 $\\sigma_{s,\\nu}$ 是混合物散射系数，$\\beta_\\nu$ 是混合物消光系数。消光系数是混合物吸收系数 $\\kappa_\\nu$ 和混合物散射系数 $\\sigma_{s,\\nu}$ 的和：\n$$\n\\beta_\\nu(T,Y) = \\kappa_\\nu(T,Y) + \\sigma_{s,\\nu}(T,Y)\n$$\n问题提供了一个数值稳定性条件：如果 $\\beta_\\nu  \\varepsilon$（其中 $\\varepsilon = 10^{-12}\\ \\mathrm{m}^{-1}$），则反照率 $\\omega_\\nu$ 取为 0。\n\n混合物系数由单个组分系数的质量分数加权和确定：\n$$\n\\kappa_\\nu(T,Y) = \\sum_{i} Y_i \\,\\kappa_{\\nu,i}(T)\n$$\n$$\n\\sigma_{s,\\nu}(T,Y) = \\sum_{i} Y_i \\,\\sigma_{s,\\nu,i}(T)\n$$\n在进行这些计算之前，必须对质量分数向量 $Y$ 进行清理。任何负分量 $Y_i$ 都被截断为 0，如果各分量之和为正，则对该向量进行归一化，以确保其分量之和为 1。如果截断后的质量分数之和为零，则按约定将 $\\omega_\\nu$ 设置为 0。\n\n特定组分的系数由依赖于温度 $T$ 的代理模型给出。\n\n组分 $i$ 的吸收系数建模为：\n$$\n\\kappa_{\\nu,i}(T) = a_i \\left(\\frac{T}{1000}\\right)^{p_i} \\quad [\\mathrm{m}^{-1} \\text{ 每单位质量分数}]\n$$\n其中为 $\\mathrm{CO_2}$、$\\mathrm{H_2O}$、$\\mathrm{N_2}$ 和烟尘提供了常数 $(a_i, p_i)$。具体来说：\n- $i=\\mathrm{CO_2}$: $a_{\\mathrm{CO_2}}=0.5$, $p_{\\mathrm{CO_2}}=1.2$\n- $i=\\mathrm{H_2O}$: $a_{\\mathrm{H_2O}}=0.7$, $p_{\\mathrm{H_2O}}=1.1$\n- $i=\\mathrm{N_2}$: $a_{\\mathrm{N_2}}=0.02$, $p_{\\mathrm{N_2}}=1.0$\n- $i=\\mathrm{soot}$: $a_{\\mathrm{soot}}=1.5$, $p_{\\mathrm{soot}}=0.9$\n\n每个组分的散射系数为：\n$$\n\\sigma_{s,\\nu,\\mathrm{CO_2}}(T)=0 \\quad [\\mathrm{m}^{-1} \\text{ 每单位质量分数}]\n$$\n$$\n\\sigma_{s,\\nu,\\mathrm{H_2O}}(T)=0 \\quad [\\mathrm{m}^{-1} \\text{ 每单位质量分数}]\n$$\n$$\n\\sigma_{s,\\nu,\\mathrm{N_2}}(T)=b_{\\mathrm{N_2}}\\left(\\frac{1000}{T}\\right) \\quad [\\mathrm{m}^{-1} \\text{ 每单位质量分数}], \\text{ 其中 } b_{\\mathrm{N_2}}=0.003\n$$\n$$\n\\sigma_{s,\\nu,\\mathrm{soot}}(T)=b_{\\mathrm{soot}}\\left(\\frac{T}{1500}\\right) \\quad [\\mathrm{m}^{-1} \\text{ 每单位质量分数}], \\text{ 其中 } b_{\\mathrm{soot}}=2.5\n$$\n\n解决方案的实现首先是定义一个函数，该函数接收给定状态 $(T, Y)$ 并计算 $\\omega_\\nu$。该函数遵循以下步骤：\n1.  接收温度 $T$（单位：开尔文）和质量分数列表或元组 $Y = (Y_{\\mathrm{CO_2}}, Y_{\\mathrm{H_2O}}, Y_{\\mathrm{N_2}}, Y_{\\mathrm{soot}})$。\n2.  对质量分数 $Y$ 应用指定的预处理：将负值截断为 0，并在其和为正的情况下重新归一化向量，使其和为 1。按规定处理和为零的情况。\n3.  使用温度 $T$ 以及提供的公式和常数，计算四个特定组分的吸收系数 $\\kappa_{\\nu,i}(T)$。\n4.  计算四个特定组分的散射系数 $\\sigma_{s,\\nu,i}(T)$。注意，对于 $\\mathrm{CO_2}$ 和 $\\mathrm{H_2O}$，这些值为 0。\n5.  通过计算归一化质量分数向量与组分吸收系数向量的点积，来计算混合物吸收系数 $\\kappa_\\nu$。\n6.  类似地计算混合物散射系数 $\\sigma_{s,\\nu}$。\n7.  计算总消光系数 $\\beta_\\nu = \\kappa_\\nu + \\sigma_{s,\\nu}$。\n8.  应用稳定性检查：如果 $\\beta_\\nu  10^{-12}$，则设置 $\\omega_\\nu=0$。否则，计算 $\\omega_\\nu = \\sigma_{s,\\nu} / \\beta_\\nu$。\n9.  返回计算出的 $\\omega_\\nu$ 值。\n\n此过程应用于问题陈述中指定的每个测试用例。然后将得到的 $\\omega_\\nu$ 值四舍五入到小数点后六位，并格式化为所需的输出字符串。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It calculates the single-scattering albedo for each case and prints the results.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (T, (Y_CO2, Y_H2O, Y_N2, Y_soot))\n    test_cases = [\n        (1800, (0.12, 0.18, 0.70, 0.00)),\n        (2000, (0.10, 0.15, 0.73, 0.02)),\n        (300, (0.00, 0.00, 0.999, 0.001)),\n        (800, (0.05, 0.10, 0.84, 0.01)),\n    ]\n\n    # Constants for the surrogate models\n    # Species order: CO2, H2O, N2, soot\n    species = ['CO2', 'H2O', 'N2', 'soot']\n    \n    # Absorption coefficients constants\n    a = np.array([0.5, 0.7, 0.02, 1.5])  # a_i\n    p = np.array([1.2, 1.1, 1.0, 0.9])  # p_i\n\n    # Scattering coefficients constants\n    b_N2 = 0.003\n    b_soot = 2.5\n    \n    # Numerical stability threshold\n    epsilon = 1e-12\n\n    results = []\n    for T, Y in test_cases:\n        omega = calculate_omega(T, Y, species, a, p, b_N2, b_soot, epsilon)\n        results.append(f\"{omega:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_omega(T, Y, species, a, p, b_N2, b_soot, epsilon):\n    \"\"\"\n    Computes the single-scattering albedo for a given thermochemical state.\n\n    Args:\n        T (float): Temperature in Kelvin.\n        Y (tuple): Tuple of mass fractions for (CO2, H2O, N2, soot).\n        species (list): List of species names.\n        a (np.ndarray): Array of absorption constants a_i.\n        p (np.ndarray): Array of absorption constants p_i.\n        b_N2 (float): Scattering constant for N2.\n        b_soot (float): Scattering constant for soot.\n        epsilon (float): Threshold for numerical stability.\n\n    Returns:\n        float: The calculated single-scattering albedo, omega_nu.\n    \"\"\"\n    \n    Y_arr = np.array(Y, dtype=float)\n\n    # Step 1: Pre-process mass fractions\n    Y_clamped = np.maximum(Y_arr, 0.0)\n    Y_sum = np.sum(Y_clamped)\n    \n    if Y_sum == 0.0:\n        return 0.0\n        \n    Y_norm = Y_clamped / Y_sum\n\n    # Step 2: Calculate species-specific absorption coefficients\n    kappa_i = a * (T / 1000.0)**p\n\n    # Step 3: Calculate species-specific scattering coefficients\n    sigma_i = np.zeros_like(Y_arr)\n    idx_N2 = species.index('N2')\n    idx_soot = species.index('soot')\n    \n    if T > 0: # Avoid division by zero if T=0\n        sigma_i[idx_N2] = b_N2 * (1000.0 / T)\n\n    sigma_i[idx_soot] = b_soot * (T / 1500.0)\n\n    # Step 4: Compute mixture coefficients\n    kappa_mix = np.dot(Y_norm, kappa_i)\n    sigma_mix = np.dot(Y_norm, sigma_i)\n\n    # Step 5: Compute extinction coefficient and albedo\n    beta_mix = kappa_mix + sigma_mix\n    \n    if beta_mix  epsilon:\n        omega = 0.0\n    else:\n        omega = sigma_mix / beta_mix\n        \n    return omega\n\nsolve()\n```"
        },
        {
            "introduction": "光子蒙特卡洛模拟的核心任务之一是抽样光子的自由程，当介质属性在空间上不均匀时，这一过程会变得非常复杂。本练习将介绍“delta-tracking”（或称“虚碰撞”）算法，这是一种强大而高效的技术，可以在不进行复杂积分运算的情况下处理空间非均匀介质 。掌握此算法对于为实际应用开发稳健的PMC代码至关重要。",
            "id": "4049528",
            "problem": "考虑一个厚度为 $L$ 的一维平板，其消光系数 $ \\beta(x) $（单位为 $ \\mathrm{m}^{-1} $）随空间变化。一个光子在位置 $ x = 0 $ 处发射，并沿 $ +x $ 方向穿过该平板。$ x = L $ 处的边界是真空，因此如果光子到达 $ x = L $ 而未被吸收，它就会逸出。吸收是唯一真实的相互作用；散射和发射被忽略。目标是构建并应用 δ追踪（空碰撞）算法，以便在 $ \\beta(x) $ 随空间变化时，对自由程和相互作用事件进行抽样。\n\nδ追踪法使用一个常数主系数 $ \\beta^* $（单位为 $ \\mathrm{m}^{-1} $），其选择需满足对于所有 $ x \\in [0,L] $，都有 $ \\beta(x) \\le \\beta^* $。提议的自由程长度 $ s $ 从速率为 $ \\beta^* $ 的指数分布中抽样，即其概率密度函数为 $ f(s) = \\beta^* \\exp(-\\beta^* s) $（对于 $ s \\ge 0 $）。在前进到提议的相互作用位置后，该事件以概率 $ \\beta(x)/\\beta^* $ 被接受为真实吸收，否则被视为空碰撞，没有物理效应。此过程重复进行，直到光子逸出或被吸收。\n\n从辐射传输方程（RTE）的第一性原理和非均匀泊松过程的消光定义出发，为上述δ追踪接受-拒绝程序推导出一个有原则的算法原理，确保真实相互作用位置的分布与真实空间速率 $ \\beta(x) $ 一致。然后实现该算法并估计平板的透射率，透射率定义为发射的光子在从未经历真实吸收的情况下于 $ x = L $ 处逸出的概率。对每个测试用例使用 $ N $ 个独立的光子历史，并使用固定的随机数生成器种子以确保可复现性。将透射率表示为无量纲数。同时，计算每个发射光子的平均空碰撞次数，也表示为无量纲量。\n\n透射率的解析参考值由非均匀比尔-朗伯定律给出，该定律指出透射率等于 $ \\exp\\!\\left( - \\int_0^L \\beta(x) \\, dx \\right) $。您必须通过报告绝对误差（无量纲）来将您的蒙特卡洛估计值与此解析值进行比较。为保证数值可复现性，请使用 $ N = 100000 $ 个光子历史和固定的随机数生成器种子 $ 12345 $。\n\n实现您的程序以处理以下测试套件，其中 $ L $ 的单位为米，$ \\beta(x) $ 和 $ \\beta^* $ 的单位为米⁻¹：\n\n- 测试用例1：$ L = 0.5\\,\\mathrm{m} $，$ \\beta(x) = 1.0\\,\\mathrm{m}^{-1} $ 对于所有 $ x $，$ \\beta^* = 1.0\\,\\mathrm{m}^{-1} $。\n- 测试用例2：$ L = 1.0\\,\\mathrm{m} $，$ \\beta(x) = 0.5 + 0.5 x\\,\\mathrm{m}^{-1} $，$ \\beta^* = 1.0\\,\\mathrm{m}^{-1} $。\n- 测试用例3：$ L = 0.8\\,\\mathrm{m} $，$ \\beta(x) = \\begin{cases} 0\\,\\mathrm{m}^{-1},  0 \\le x  0.3\\,\\mathrm{m}, \\\\ 3.0\\,\\mathrm{m}^{-1},  0.3\\,\\mathrm{m} \\le x  0.5\\,\\mathrm{m}, \\\\ 0.2\\,\\mathrm{m}^{-1},  0.5\\,\\mathrm{m} \\le x \\le 0.8\\,\\mathrm{m}, \\end{cases} $，其中 $ \\beta^* = 3.0\\,\\mathrm{m}^{-1} $。\n- 测试用例4：$ L = 1.0\\,\\mathrm{m} $，$ \\beta(x) = 0.8 + 0.3 \\sin\\!\\left( 2\\pi x / L \\right)\\,\\mathrm{m}^{-1} $，$ \\beta^* = 1.1\\,\\mathrm{m}^{-1} $。\n\n对于每个测试用例，计算：\n- 透射率的蒙特卡洛估计值（无量纲）。\n- 蒙特卡洛估计值与解析透射率 $ \\exp\\!\\left( - \\int_0^L \\beta(x) \\, dx \\right) $ 之间的绝对误差（无量纲）。\n- 每个发射光子的平均空碰撞次数（无量纲）。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $ [T_1,\\mathrm{err}_1,\\bar{n}_{\\mathrm{null},1},T_2,\\mathrm{err}_2,\\bar{n}_{\\mathrm{null},2},T_3,\\mathrm{err}_3,\\bar{n}_{\\mathrm{null},3},T_4,\\mathrm{err}_4,\\bar{n}_{\\mathrm{null},4}] $，其中 $ T_i $ 表示蒙特卡洛透射率估计值，$ \\mathrm{err}_i $ 表示相对于解析值的绝对误差，$ \\bar{n}_{\\mathrm{null},i} $ 表示测试用例 $ i $ 中每个发射光子的平均空碰撞次数。",
            "solution": "该问题要求推导并实现一个δ追踪（空碰撞）蒙特卡洛算法，以模拟在一维平板中具有空间变化吸收系数的光子传输。目标是估计平板的透射率和平均空碰撞次数，并将透射率与解析解进行比较。\n\n### 第1部分：δ追踪算法的原理推导\n\n#### 1.1. 物理和数学基础：辐射传输方程（RTE）\n\n控制辐射在介质中传输的基本方程是辐射传输方程（RTE）。对于一维、无发射、无散射（纯吸收）的介质，辐射强度 $I$ 沿 $ +x $ 方向路径的变化由以下公式描述：\n$$\n\\frac{dI(x)}{dx} = -\\beta(x) I(x)\n$$\n其中 $\\beta(x)$ 是随空间变化的吸收系数，单位为 $\\mathrm{m}^{-1}$。项 $\\beta(x)$ 表示光子在位置 $x$ 处单位路径长度上被吸收的概率。\n\n#### 1.2. 概率解释与标准蒙特卡洛方法\n\n将RTE从 $x=0$ 积分到位置 $x=s$ 可得到解：\n$$\nI(s) = I(0) \\exp\\left(-\\int_0^s \\beta(x') \\, dx'\\right)\n$$\n项 $\\exp\\left(-\\int_0^s \\beta(x') \\, dx'\\right)$ 是从 $x=0$ 出发的光子在未被吸收的情况下行进至少距离 $s$ 的概率。这是存活概率。积分 $\\tau(s) = \\int_0^s \\beta(x') \\, dx'$ 是路径的光学厚度。\n\n*第一次*相互作用位置的概率密度函数（PDF）$p(s)$，可以通过考虑存活到 $s$ 然后在无穷小区间 $[s, s+ds]$ 内相互作用的概率来找到。这由以下公式给出：\n$$\np(s) = \\beta(s) \\exp\\left(-\\int_0^s \\beta(x') \\, dx'\\right)\n$$\n要直接模拟光子传输，必须从此PDF中抽样一个自由程长度 $s$。这通常通过逆变换采样法实现。累积分布函数（CDF）是：\n$$\nF(s) = \\int_0^s p(x') \\, dx' = 1 - \\exp\\left(-\\int_0^s \\beta(x') \\, dx'\\right)\n$$\n为了抽样 $s$，我们设 $F(s) = U$，其中 $U$ 是在 $[0, 1)$ 内的均匀随机数，然后解出 $s$：\n$$\n\\int_0^s \\beta(x') \\, dx' = -\\ln(1-U)\n$$\n如果 $\\beta(x)$ 是一个复杂函数，求解此积分方程以获得 $s$ 在计算上可能非常昂贵或解析上难以处理，这使得直接模拟效率低下。\n\n#### 1.3. δ追踪（空碰撞）方法\n\nδ追踪方法重新构建了问题，以避免直接对CDF求逆。它引入了一个虚构的“空碰撞”过程。选择一个常数主消光系数 $\\beta^*$，使得在所有感兴趣的域内的 $x$ 处，都有 $\\beta(x) \\le \\beta^*$。\n\n通过在RTE中加上和减去一个“空”系数 $\\beta_{\\text{null}}(x) = \\beta^* - \\beta(x)$，物理系统在概念上被修改。总相互作用系数变为 $\\beta(x) + \\beta_{\\text{null}}(x) = \\beta^*$，这是一个常数。修改后的RTE可以解释为：\n$$\n\\frac{dI(x)}{dx} = -\\beta^* I(x) + (\\beta^* - \\beta(x)) I(x)\n$$\n这描述了一个传输过程，其中光子与介质相互作用的单位长度总概率为常数 $\\beta^*$。相互作用事件可以是“真实”吸收（速率为 $\\beta(x)$），也可以是“空”碰撞（速率为 $\\beta^* - \\beta(x)$），空碰撞不影响光子的状态（它等效于完全前向散射）。\n\n在这个新公式下，介质是均匀的，具有恒定的消光系数 $\\beta^*$。到*下一次暂定相互作用*的自由程长度 $s$ 的PDF现在是一个简单的指数分布：\n$$\nf(s) = \\beta^* \\exp(-\\beta^* s)\n$$\n路径长度 $s$ 可以使用逆变换采样轻松地从此分布中抽样：\n$$\ns = -\\frac{1}{\\beta^*} \\ln(U)\n$$\n其中 $U$ 是 $(0, 1)$ 中的一个均匀随机数。\n\n#### 1.4. 接受-拒绝步骤\n\n在将光子推进距离 $s$ 到达新位置 $x$ 后，我们必须确定暂定相互作用是真实吸收还是空碰撞。此步骤的原理植根于稀疏化泊松过程理论。一个速率为 $\\lambda(t)$ 的非均匀泊松过程可以通过从一个主速率为 $\\lambda^* \\ge \\lambda(t)$ 的均匀泊松过程中生成事件，并以概率 $\\lambda(t)/\\lambda^*$ 接受每个事件来模拟。\n\n在我们的情境中，路径长度 $x$ 是过程变量，真实相互作用速率是 $\\beta(x)$，主速率是 $\\beta^*$。在相互作用位置 $x$，事件是真实吸收的条件概率是真实吸收速率与总相互作用速率之比：\n$$\nP(\\text{real} | \\text{interaction at } x) = \\frac{\\beta(x)}{\\beta^*}\n$$\n这导出了以下接受-拒绝程序：\n1.  抽样一个暂定路径长度 $s = -\\ln(U_1)/\\beta^*$。\n2.  将光子推进到提议的相互作用位置 $x' = x_{\\text{old}} + s$。\n3.  如果光子逸出介质（$x' \\ge L$），则其历史终止。\n4.  如果相互作用发生在介质内部（$x'  L$），则生成第二个均匀随机数 $U_2$。\n5.  如果 $U_2  \\beta(x')/\\beta^*$，该相互作用被接受为**真实吸收**。光子的历史终止。\n6.  如果 $U_2 \\ge \\beta(x')/\\beta^*$，该相互作用是**空碰撞**。光子的状态不变，其模拟从位置 $x'$ 继续，从步骤1开始重复。\n\n该算法能正确模拟原始物理过程，因为在任何点 $x$ 处真实相互作用的有效速率是暂定相互作用速率（$\\beta^*$）乘以接受概率（$\\beta(x)/\\beta^*$），其结果等于真实物理速率 $\\beta(x)$。\n\n### 第2部分：算法实现\n\n蒙特卡洛模拟是通过根据δ追踪算法追踪大量（$N$个）单个光子历史来实现的。\n\n1.  **初始化**：对于每个由 $L$、$\\beta(x)$ 和 $\\beta^*$ 定义的测试用例，我们将透射光子计数器和总空碰撞计数器初始化为零。\n2.  **光子循环**：对于 $N$ 个光子中的每一个：\n    a.  将光子位置初始化为 $x=0.0$，状态为“存活”。\n    b.  为此特定光子初始化一个空碰撞计数器。\n    c.  **追踪循环**：当光子存活时：\n        i.   从速率为 $\\beta^*$ 的指数分布中抽样一个暂定自由程长度 $s$。\n        ii.  计算新的提议位置 $x' = x + s$。\n        iii. 如果 $x' \\ge L$，光子逸出。增加透射光子计数器，更新总空碰撞计数，并终止此光子的历史。\n        iv. 如果 $x'  L$，将光子移动到这个新位置 $x = x'$。\n        v.  执行接受-拒绝测试：生成一个随机数 $U$ 并将其与比率 $\\beta(x)/\\beta^*$ 进行比较。\n        vi. 如果是真实碰撞（吸收），在更新总空碰撞计数后终止此光子的历史。\n        vii. 如果是空碰撞，增加此光子的空碰撞计数器，并从当前位置 $x$ 继续追踪循环。\n3.  **结果计算**：在所有 $N$ 个历史完成后：\n    a.  蒙特卡洛透射率估计值为 $T_{\\text{MC}} = (\\text{透射光子数}) / N$。\n    b.  平均空碰撞次数为 $\\bar{n}_{\\text{null}} = (\\text{总空碰撞次数}) / N$。\n    c.  解析透射率计算为 $T_{\\text{analytic}} = \\exp\\left(-\\int_0^L \\beta(x) \\, dx\\right)$。积分（光学厚度）使用 `scipy.integrate.quad` 进行数值计算。\n    d.  绝对误差计算为 $\\mathrm{err} = |T_{\\text{MC}} - T_{\\text{analytic}}|$。\n4.  **输出**：将所有测试用例的计算值 $(T_{\\text{MC}}, \\mathrm{err}, \\bar{n}_{\\text{null}})$ 收集并格式化为指定的单行输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Implements a delta-tracking Monte Carlo simulation for 1D photon transport,\n    computes transmittance, error, and mean null-collisions for specified test cases.\n    \"\"\"\n    # Global simulation parameters\n    N_PHOTONS = 100000\n    SEED = 12345\n    rng = np.random.default_rng(SEED)\n\n    # Test case definitions\n    def beta_1(x):\n        return 1.0\n\n    def beta_2(x):\n        return 0.5 + 0.5 * x\n\n    def beta_3(x):\n        if 0.3 = x  0.5:\n            return 3.0\n        elif 0.5 = x = 0.8:\n            return 0.2\n        else:\n            return 0.0\n    \n    # For case 4, L=1.0 is used in the sin term as specified in the problem\n    def beta_4(x):\n        return 0.8 + 0.3 * np.sin(2.0 * np.pi * x / 1.0)\n    \n    test_cases = [\n        {'L': 0.5, 'beta_func': beta_1, 'beta_star': 1.0},\n        {'L': 1.0, 'beta_func': beta_2, 'beta_star': 1.0},\n        {'L': 0.8, 'beta_func': beta_3, 'beta_star': 3.0},\n        {'L': 1.0, 'beta_func': beta_4, 'beta_star': 1.1},\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        L = case['L']\n        beta_func = case['beta_func']\n        beta_star = case['beta_star']\n\n        # Monte Carlo Simulation\n        transmitted_count = 0\n        total_null_collisions = 0\n\n        for _ in range(N_PHOTONS):\n            x = 0.0\n            photon_alive = True\n            num_null_this_photon = 0\n\n            while photon_alive:\n                # Sample distance to next tentative collision from the homogeneous medium\n                s = -np.log(rng.random()) / beta_star\n                \n                # New proposed position\n                x_new = x + s\n\n                if x_new >= L:\n                    # Photon escapes the slab (is transmitted)\n                    transmitted_count += 1\n                    photon_alive = False\n                else:\n                    # An interaction occurs within the slab\n                    x = x_new\n                    \n                    # Acceptance-rejection to determine if it is a real or null collision\n                    prob_real = beta_func(x) / beta_star\n                    if rng.random()  prob_real:\n                        # Real collision (absorption)\n                        photon_alive = False\n                    else:\n                        # Null collision\n                        num_null_this_photon += 1\n            \n            # Add this photon's null collision count to the total\n            total_null_collisions += num_null_this_photon\n\n        # Calculate Monte Carlo results statistics\n        T_mc = transmitted_count / N_PHOTONS\n        mean_null_collisions = total_null_collisions / N_PHOTONS\n\n        # Calculate analytic transmittance for error comparison\n        # The integral of beta(x) is the optical thickness\n        optical_thickness, _ = quad(beta_func, 0, L)\n        T_analytic = np.exp(-optical_thickness)\n\n        # Calculate absolute error\n        error = abs(T_mc - T_analytic)\n\n        # Store results for this case\n        all_results.extend([T_mc, error, mean_null_collisions])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个正确实现的数值模拟必须遵守基本的物理定律，对于热辐射而言，辐射平衡系统中的“细致平衡”原理就是其中之一。本练习将指导您构建一个完整（尽管简化）的模拟循环，以验证您对发射、传播和吸收的实现是否能正确再现细致平衡 。这类验证测试对于确保数值代码的物理保真度和准确性至关重要。",
            "id": "4049551",
            "problem": "考虑一个一维周期性平板，代表处于局部热力学平衡（LTE）状态的均匀燃烧气体体积。该平板长度为 $L$ 米，被离散化为 $N$ 个宽度为 $\\Delta x = L/N$ 的等大单元，并具有空间分段常数的吸收系数 $ \\kappa(x) $，单位为米$^{-1}$。在 LTE 条件下，光谱强度 $I$ 沿路径坐标 $s$ 的辐射传输方程（RTE）为 $ \\mathrm{d} I / \\mathrm{d} s = - \\kappa I + j $，其中发射系数 $j$ 满足 $ j = \\kappa B $，而 $B$ 是局部温度 $T$（假设在整个平板上均匀）下的 Planck 函数。辐射平衡要求每个单元中的发射率等于吸收率，因此每个单元的净辐射源为零。\n\n将使用蒙特卡洛光子包方法来验证能量守恒、互易性和细致平衡。每个光子包携带单位能量，沿平板轴线各向同性发射，以相等的概率沿 $+x$ 或 $-x$ 方向行进，其发射位置在所选源单元内均匀分布。发射单元的索引从与 $ \\kappa_i V_i $ 成正比的离散分布中采样，其中 $ \\kappa_i $ 是单元 $i$ 的吸收系数，$ V_i $ 是单元体积（在这个一维平板中，$ V_i \\propto \\Delta x $，因此 $ \\kappa_i V_i \\propto \\kappa_i $）。光子包在被吸收前的自由程光学深度 $ \\tau $ 从指数分布 $ p(\\tau) = e^{-\\tau} $ 中采样，其中 $ \\tau = - \\ln(u) $，$ u \\sim \\mathcal{U}(0,1) $。当光子包传播时，剩余的光学深度会因在每个单元内行进的距离 $ \\kappa(x) \\, \\mathrm{d} x $ 而减少，吸收事件发生在剩余光学深度耗尽的那个单元内。强制执行周期性边界条件，因此在 $x=L$ 处射出的光子包会从 $x=0$ 处重新进入，在 $x=0$ 处射出的光子包会从 $x=L$ 处重新进入。\n\n从 LTE RTE 的基本形式 $ \\mathrm{d} I / \\mathrm{d} s = - \\kappa I + \\kappa B $ 和空间周期性、均匀温度介质中的各向同性黑体解 $ I = B $ 出发，可以推断出每个单元的期望吸收等于其期望发射，即 $ \\langle A_i \\rangle = \\langle E_i \\rangle = \\kappa_i \\, 4 \\pi B \\, V_i $（相差一个常数因子，该因子已被光子包单位能量归一化所吸收）。互易性意味着，在没有各向异性散射的情况下，反转任何路径的行进方向不会改变吸收事件的分布。能量守恒要求吸收的光子包总数等于发射的光子包总数。\n\n您的任务是实现一个完整、可复现的蒙特卡洛程序，该程序：\n- 根据与 $ \\kappa_i $ 成正比的概率从单元中发射光子包。\n- 以相等的概率在 $ \\pm x $ 方向上采样各向同性方向，并在源单元内均匀分布发射位置。\n- 从 $ p(\\tau) = e^{-\\tau} $ 中采样一个吸收光学深度 $ \\tau $，并在各单元间传播光子包，强制执行周期性边界，直到发生吸收。\n- 统计每个单元的发射计数 $ E_i $ 和吸收计数 $ A_i $。\n- 通过检查每个单元的最大相对差异 $ \\max_i \\left| A_i - E_i \\right| / \\max \\left( E_i, 1 \\right) $ 不超过容差 $ \\epsilon $ 来局部验证细致平衡。\n- 通过检查 $ \\left| \\sum_i A_i - \\sum_i E_i \\right| = 0 $ 来验证全局能量守恒。\n\n如果引用了任何角度，必须以弧度为单位进行解释，尽管该算法仅需要在 $ \\pm x $ 方向上进行离散方向采样，而无需明确的角度值。\n\n使用以下具有指定参数和物理单位的测试套件，并以布尔值形式生成结果，指示每个案例是否同时通过了局部细致平衡和全局能量守恒的检验：\n- 测试用例1（理想路径，均匀介质）：$N = 10$， $L = 1$ 米，对所有 $i$ 都有 $ \\kappa_i = 2.0 $ 米$^{-1}$，$T = 1500$ 开尔文，光子包数量 $N_p = 50000$，容差 $ \\epsilon = 0.03 $，随机种子 $123$。\n- 测试用例2（光学厚边界条件）：$N = 10$， $L = 1$ 米，对所有 $i$ 都有 $ \\kappa_i = 100.0 $ 米$^{-1}$，$T = 1500$ 开尔文，光子包数量 $N_p = 50000$，容差 $ \\epsilon = 0.03 $，随机种子 $456$。\n- 测试用例3（非均匀介质互易性检查）：$N = 10$， $L = 1$ 米，对单元 $i=0,1,2,3,4$ 有 $ \\kappa_i = 0.5 $ 米$^{-1}$，对单元 $i=5,6,7,8,9$ 有 $ \\kappa_i = 2.0 $ 米$^{-1}$，$T = 1500$ 开尔文，光子包数量 $N_p = 50000$，容差 $ \\epsilon = 0.03 $，随机种子 $789$。\n\n您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[ \\text{结果1}, \\text{结果2}, \\text{结果3} ]$），其中每个结果都是一个布尔值，表示相应测试用例中局部细致平衡和全局能量守恒的综合通过情况。",
            "solution": "问题陈述经评估有效。它提出了一个在计算辐射传输领域中定义明确、有科学依据的问题。所有必要的参数、物理原理和数值程序都得到了清晰和正确的定义。任务是为一个一维、周期性、等温的参与介质实现一个标准的光子蒙特卡洛（PMC）模拟，以验证全局能量守恒和局部细致平衡的原理，这些都是此类系统中辐射平衡的基本推论。\n\n解决方案的核心是一个PMC算法，它模拟了大量能量包（光子）的生命周期。模拟域是一个长度为 $L$ 的平板，被离散化为 $N$ 个宽度为 $\\Delta x = L/N$ 的均匀单元。每个单元 $i$ 由一个恒定的吸收系数 $\\kappa_i$ 来表征。\n\n模拟通过追踪 $N_p$ 个独立光子包从发射到吸收的过程来进行。对每个光子包执行以下步骤：\n\n1.  **发射：** 发射过程基于局部热力学平衡（LTE）的原理进行建模。\n    -   **源单元选择：** 光子包从单元 $i$ 发射的概率与该单元的总发射量成正比。在LTE中，光谱发射系数为 $j = \\kappa B$，其中 $B$ 是 Planck 函数。对于均匀温度 $T$，$B$ 在整个平板上是恒定的。单元 $i$ 的总发射量与 $\\kappa_i V_i$ 成正比，其中 $V_i$ 是单元体积。在这个一维问题中，$V_i$ 与单元宽度 $\\Delta x$ 成正比，而 $\\Delta x$ 是恒定的。因此，从单元 $i$ 发射的概率 $P(i)$ 由下式给出：\n        $$\n        P(i) = \\frac{\\kappa_i}{\\sum_{j=0}^{N-1} \\kappa_j}\n        $$\n        从这个离散概率分布中采样一个源单元，其索引为 $i_{\\text{emit}}$。然后，该单元的发射计数器 $E_{i_{\\text{emit}}}$ 递增。\n    -   **位置和方向：** 发射位置 $x_{\\text{emit}}$ 从源单元边界 $[i_{\\text{emit}}\\Delta x, (i_{\\text{emit}}+1)\\Delta x]$ 内的均匀分布中采样。行进方向沿一维轴是各向同性的，意味着光子包有相等的概率向 $+x$ 或 $-x$ 方向行进。相应地采样一个方向变量 $d \\in \\{-1, 1\\}$。\n\n2.  **吸收路径采样：** 光子包在被吸收前行进的光学距离或光学深度 $\\tau$ 是一个随机变量。在参与介质中，光子包在穿过光学深度 $\\tau$ 后被吸收的概率遵循指数分布 $p(\\tau) = e^{-\\tau}$。这可以通过逆变换采样法高效地进行采样。从均匀分布 $\\mathcal{U}(0,1)$ 中抽取一个随机数 $u$，然后计算到吸收点的光学深度：\n    $$\n    \\tau_{\\text{abs}} = -\\ln(u)\n    $$\n    这个采样的 $\\tau_{\\text{abs}}$ 代表了光子包在被吸收前必须行进的总光学路径长度。\n\n3.  **传播和吸收：** 从发射点开始逐个单元地追踪光子包，直到其累积的光学路径等于 $\\tau_{\\text{abs}}$。\n    -   设光子包的当前状态由其位置 $x_{\\text{pos}}$、当前单元索引 $i_{\\text{cell}}$ 和剩余待行进的光学深度 $\\tau_{\\text{rem}}$（初始化为 $\\tau_{\\text{abs}}$）定义。\n    -   在传播的每一步中，计算沿行进方向到下一个单元边界的物理距离 $\\Delta s$。\n    -   该路径段的光学厚度为 $\\tau_{\\text{path}} = \\kappa_{i_{\\text{cell}}} \\Delta s$。\n    -   将该段的光学厚度与剩余光学深度进行比较：\n        -   如果 $\\tau_{\\text{rem}} \\le \\tau_{\\text{path}}$，光子包在当前单元 $i_{\\text{cell}}$ 内被吸收。该单元的吸收计数器 $A_{i_{\\text{cell}}}$ 递增，该光子包的模拟结束。\n        -   如果 $\\tau_{\\text{rem}} > \\tau_{\\text{path}}$，光子包穿过该路径段并到达单元边界。剩余光学深度减少 $\\tau_{\\text{path}}$：$\\tau_{\\text{rem}} \\leftarrow \\tau_{\\text{rem}} - \\tau_{\\text{path}}$。更新光子包的状态（$x_{\\text{pos}}$、$i_{\\text{cell}}$）以反映其在下一个单元边界的新位置。强制执行周期性边界条件：在 $x=L$ 处射出的光子包从 $x=0$ 处重新进入，在 $x=0$ 处射出的光子包会从 $x=L$ 处重新进入。重复此过程直到光子包被吸收。\n\n4.  **验证：** 在所有 $N_p$ 个光子包模拟完成后，分析统计的发射计数 $E_i$ 和吸收计数 $A_i$。\n    -   **全局能量守恒：** 根据构建，每个发射的光子包都会被追踪直到被吸收。因此，总吸收数必须等于总发射数：$\\sum_i A_i = \\sum_i E_i = N_p$。检查 $|\\sum_i A_i - \\sum_i E_i| = 0$ 作为对算法记账的基本健全性检查。\n    -   **局部细致平衡：** 辐射平衡中的细致平衡原理意味着，平均而言，每个单元的吸收率等于其发射率。在蒙特卡洛模拟中，这意味着吸收的期望计数 $\\langle A_i \\rangle$ 应等于发射的期望计数 $\\langle E_i \\rangle$。我们通过计算每个单元的最大相对差异来验证统计波动是否在给定的容差 $\\epsilon$ 之内：\n        $$\n        \\max_{i} \\left( \\frac{|A_i - E_i|}{\\max(E_i, 1)} \\right) \\le \\epsilon\n        $$\n        在分母中使用 $\\max(E_i, 1)$ 可以防止在单元发射数为零的罕见情况下出现除以零的错误。一个测试用例当且仅当全局和局部检查都满足时才算通过。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(N, L, kappa, N_p, epsilon, seed):\n    \"\"\"\n    Runs a 1D Photon Monte Carlo simulation for a periodic, isothermal slab.\n\n    Args:\n        N (int): Number of cells.\n        L (float): Length of the slab (m).\n        kappa (np.ndarray): Array of absorption coefficients for each cell (m^-1).\n        N_p (int): Number of photon packets to simulate.\n        epsilon (float): Tolerance for local detailed balance check.\n        seed (int): Random seed for reproducibility.\n\n    Returns:\n        bool: True if both global energy conservation and local detailed balance pass.\n    \"\"\"\n    np.random.seed(seed)\n\n    # 1. Setup\n    dx = L / N\n    E = np.zeros(N, dtype=np.int64)\n    A = np.zeros(N, dtype=np.int64)\n\n    # Pre-calculate emission probabilities and cell indices\n    kappa_sum = np.sum(kappa)\n    if kappa_sum == 0:\n        # If all kappa are zero, no emission can occur.\n        # This case is trivial and passes by definition.\n        return True\n    emission_probs = kappa / kappa_sum\n    cell_indices = np.arange(N)\n\n    # 2. Main Monte Carlo loop over all photon packets\n    for _ in range(N_p):\n        # 2a. Emission\n        # Select emission cell based on probabilities proportional to kappa\n        i_emit = np.random.choice(cell_indices, p=emission_probs)\n        E[i_emit] += 1\n\n        # Select random position within the cell\n        pos = (i_emit + np.random.rand()) * dx\n\n        # Select random direction (-1 for -x, +1 for +x)\n        direction = 1 if np.random.rand() > 0.5 else -1\n\n        # Sample optical depth to absorption from P(tau) = exp(-tau)\n        tau_remaining = -np.log(np.random.rand())\n\n        # 2b. Propagation until absorption\n        current_cell_idx = i_emit\n        current_pos = pos\n\n        while True:\n            kappa_current = kappa[current_cell_idx]\n\n            # Calculate distance to the next cell boundary along the direction of travel\n            if direction == 1:\n                dist_to_boundary = (current_cell_idx + 1) * dx - current_pos\n            else:  # direction == -1\n                dist_to_boundary = current_pos - current_cell_idx * dx\n            \n            # Clamp small negative distances that can arise from floating point issues\n            if dist_to_boundary  0:\n                dist_to_boundary = 0.0\n            \n            # Calculate optical thickness to the boundary\n            tau_to_boundary = kappa_current * dist_to_boundary\n\n            if tau_remaining = tau_to_boundary:\n                # Absorption occurs in the current cell\n                A[current_cell_idx] += 1\n                break  # End this packet's life\n            else:\n                # Packet traverses the cell and crosses the boundary\n                tau_remaining -= tau_to_boundary\n\n                # Update position and cell index, applying periodic boundaries\n                if direction == 1:\n                    pos_at_boundary = (current_cell_idx + 1) * dx\n                    current_cell_idx = (current_cell_idx + 1) % N\n                    # If we cross x=L, the new position is x=0\n                    current_pos = pos_at_boundary if pos_at_boundary  L else 0.0\n                else:  # direction == -1\n                    pos_at_boundary = current_cell_idx * dx\n                    current_cell_idx = (current_cell_idx - 1 + N) % N\n                    # If we cross x=0, the new position is x=L\n                    current_pos = pos_at_boundary if pos_at_boundary > 0.0 else L\n\n    # 3. Verification\n    # 3a. Global energy conservation (should always hold by construction)\n    global_pass = (np.sum(A) == np.sum(E))\n\n    # 3b. Local detailed balance\n    # Use np.maximum to avoid division by zero for cells with no emissions\n    rel_diff = np.abs(A - E) / np.maximum(E.astype(float), 1.0)\n    max_rel_diff = np.max(rel_diff)\n    local_pass = max_rel_diff = epsilon\n\n    return global_pass and local_pass\n\n\ndef solve():\n    \"\"\"\n    Sets up and runs the test cases specified in the problem statement.\n    \"\"\"\n    test_cases = [\n        # (N, L, kappa_def, N_p, epsilon, seed)\n        (10, 1.0, {\"type\": \"uniform\", \"val\": 2.0}, 50000, 0.03, 123),\n        (10, 1.0, {\"type\": \"uniform\", \"val\": 100.0}, 50000, 0.03, 456),\n        (10, 1.0, {\"type\": \"heterogeneous\", \"vals\": [0.5] * 5 + [2.0] * 5}, 50000, 0.03, 789),\n    ]\n\n    results = []\n    for N, L, kappa_def, N_p, epsilon, seed in test_cases:\n        if kappa_def[\"type\"] == \"uniform\":\n            kappa = np.full(N, kappa_def[\"val\"], dtype=float)\n        else: # \"heterogeneous\"\n            kappa = np.array(kappa_def[\"vals\"], dtype=float)\n        \n        # Run simulation and store the boolean result\n        result = run_simulation(N, L, kappa, N_p, epsilon, seed)\n        results.append(result)\n\n    # Format the final output as a single-line string\n    # Python's str(True) is \"True\", which is not what might be expected for some contexts,\n    # but for this problem it's fine. If lowercase were needed, map(str.lower, results) would be used.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}