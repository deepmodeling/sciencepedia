{
    "hands_on_practices": [
        {
            "introduction": "The fundamental property of any numerical quadrature scheme is its ability to integrate simple functions exactly. For the Discrete Ordinates Method (DOM), this means the sum of quadrature weights must correctly represent the total solid angle of the sphere. This exercise serves as a crucial sanity check to confirm your understanding of how DOM approximates angular integrals; by testing on an isotropic field where the analytical solution for the mean intensity $J$ is trivial, you can verify that your quadrature implementation correctly handles the most basic requirement of integrating a constant over the sphere. ",
            "id": "4020279",
            "problem": "You are to implement and analyze the Discrete Ordinates Method (DOM) for angular integration of gas radiation in an isotropic field using a level of quadrature denoted by $S_{N}$, where $N$ controls the number of polar nodes. You must start from the following fundamental bases:\n- The mean intensity $J$ is defined by the angular integral $J = \\dfrac{1}{4\\pi} \\int_{4\\pi} I(\\boldsymbol{\\Omega}) \\, \\mathrm{d}\\Omega$, where $I(\\boldsymbol{\\Omega})$ is the specific intensity as a function of the unit direction $\\boldsymbol{\\Omega}$.\n- In the Discrete Ordinates Method (DOM), an angular integral $\\int_{4\\pi} f(\\boldsymbol{\\Omega}) \\, \\mathrm{d}\\Omega$ is approximated by a weighted sum $\\sum_{m=1}^{M} w_{m} f(\\boldsymbol{\\Omega}_{m})$, where $\\{\\boldsymbol{\\Omega}_{m}, w_{m}\\}_{m=1}^{M}$ are a set of directions and corresponding nonnegative weights that approximate integration over the unit sphere.\n\nIn this problem, you will:\n- Consider an isotropic radiation field $I(\\boldsymbol{\\Omega}) = I_{0}$, where $I_{0}$ is a constant dimensionless intensity (normalized by a reference intensity), so $J$ has the same dimensionless units as $I_{0}$.\n- Use a product quadrature that defines $S_{N}$ as the tensor product of an $N$-point Gauss–Legendre quadrature in $\\mu = \\cos\\theta$ over $[-1,1]$ and an equally spaced trapezoidal quadrature in the azimuthal angle $\\phi$ over $[0,2\\pi)$ with $N_{\\phi} = 2N$ nodes. Let the Gauss–Legendre nodes and weights be $\\{\\mu_{i}, w^{(\\mu)}_{i}\\}_{i=1}^{N}$, and the azimuthal weights be $w^{(\\phi)} = \\dfrac{2\\pi}{N_{\\phi}}$, repeated for $j = 0,1,\\dots,N_{\\phi}-1$.\n- Approximate the mean intensity by\n$$\nJ_{S_{N}} \\approx \\frac{1}{4\\pi} \\sum_{i=1}^{N} \\sum_{j=0}^{N_{\\phi}-1} w^{(\\mu)}_{i}\\, w^{(\\phi)}\\, I(\\mu_{i},\\phi_{j}) .\n$$\n- Quantify the absolute error $\\varepsilon_{S_{N}} = \\left| J_{S_{N}} - J \\right|$ for each of $S_{4}$, $S_{8}$, and $S_{12}$.\n\nRelate the observed error to the concept of quadrature degree of exactness by reasoning from first principles: an isotropic field corresponds to a constant integrand over the sphere, which is a spherical harmonic of degree $l = 0$. A quadrature that is exact for degree $0$ (i.e., integrates constants exactly) yields zero error in exact arithmetic. Your derivation should explicitly connect the weight-sum property to the exactness for constants.\n\nYour program must implement the quadrature and compute the errors for the following test suite of constant intensities (dimensionless):\n- $I_{0} \\in \\{\\, 0.0,\\, 1.0,\\, 3.7,\\, 10^{6} \\,\\}$.\n\nFor each $I_{0}$ in the order listed above, compute and report the absolute errors for $S_{4}$, $S_{8}$, and $S_{12}$ in that order. Therefore, your program should output a single line with a comma-separated list enclosed in square brackets containing $12$ floating-point numbers in the following order:\n- $\\left[ \\varepsilon_{S_{4}}(I_{0}{=}0.0),\\, \\varepsilon_{S_{8}}(I_{0}{=}0.0),\\, \\varepsilon_{S_{12}}(I_{0}{=}0.0),\\, \\varepsilon_{S_{4}}(I_{0}{=}1.0),\\, \\varepsilon_{S_{8}}(I_{0}{=}1.0),\\, \\varepsilon_{S_{12}}(I_{0}{=}1.0),\\, \\varepsilon_{S_{4}}(I_{0}{=}3.7),\\, \\varepsilon_{S_{8}}(I_{0}{=}3.7),\\, \\varepsilon_{S_{12}}(I_{0}{=}3.7),\\, \\varepsilon_{S_{4}}(I_{0}{=}10^{6}),\\, \\varepsilon_{S_{8}}(I_{0}{=}10^{6}),\\, \\varepsilon_{S_{12}}(I_{0}{=}10^{6}) \\right]$.\n\nImportant implementation requirements:\n- Use $N_{\\phi} = 2N$ equally spaced azimuthal nodes and weights $w^{(\\phi)} = \\dfrac{2\\pi}{N_{\\phi}}$.\n- Use $N$-point Gauss–Legendre quadrature for $\\mu \\in [-1,1]$ with weights $w^{(\\mu)}_{i}$.\n- Compute $J_{S_{N}}$ from the definition above and then the absolute error $\\varepsilon_{S_{N}}$ for each $N \\in \\{4,8,12\\}$ and each $I_{0}$ in the test suite.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[x1,x2,...,x12]\").",
            "solution": "The problem statement has been critically validated and is deemed to be scientifically sound, well-posed, and complete. It presents a valid test of fundamental principles in numerical quadrature as applied to radiative transfer.\n\nThe objective is to compute the absolute error of the Discrete Ordinates Method (DOM) for a specified product quadrature, $S_N$, when applied to an isotropic radiation field. The analysis requires a derivation from first principles connecting the quadrature's properties to the observed error.\n\nFirst, we establish the exact value of the mean intensity, $J$. By definition,\n$$\nJ = \\frac{1}{4\\pi} \\int_{4\\pi} I(\\boldsymbol{\\Omega}) \\, \\mathrm{d}\\Omega\n$$\nThe problem specifies an isotropic radiation field, where the specific intensity $I(\\boldsymbol{\\Omega})$ is a constant, $I_0$, independent of direction $\\boldsymbol{\\Omega}$. Therefore, the integral becomes:\n$$\nJ = \\frac{1}{4\\pi} \\int_{4\\pi} I_0 \\, \\mathrm{d}\\Omega = \\frac{I_0}{4\\pi} \\int_{4\\pi} \\, \\mathrm{d}\\Omega\n$$\nThe integral of the differential solid angle $\\mathrm{d}\\Omega$ over the entire spherical surface ($4\\pi$ steradians) is, by definition, $4\\pi$.\n$$\n\\int_{4\\pi} \\, \\mathrm{d}\\Omega = 4\\pi\n$$\nSubstituting this into the expression for $J$ yields the exact value of the mean intensity:\n$$\nJ = \\frac{I_0}{4\\pi} (4\\pi) = I_0\n$$\nThus, for an isotropic radiation field, the mean intensity is identically equal to the constant specific intensity.\n\nNext, we analyze the numerical approximation $J_{S_N}$ provided by the DOM. The formula given is:\n$$\nJ_{S_{N}} = \\frac{1}{4\\pi} \\sum_{i=1}^{N} \\sum_{j=0}^{N_{\\phi}-1} w^{(\\mu)}_{i}\\, w^{(\\phi)}\\, I(\\mu_{i},\\phi_{j})\n$$\nwhere $\\{\\mu_{i}, w^{(\\mu)}_{i}\\}$ are the nodes and weights of an $N$-point Gauss-Legendre quadrature for the polar direction cosine $\\mu \\in [-1,1]$, and $w^{(\\phi)}$ is the weight for an $N_{\\phi}$-point trapezoidal quadrature for the azimuthal angle $\\phi \\in [0, 2\\pi)$. Since the radiation field is isotropic, $I(\\mu_{i},\\phi_{j}) = I_0$ for all directions. We can factor this constant out of the summation:\n$$\nJ_{S_{N}} = \\frac{I_0}{4\\pi} \\sum_{i=1}^{N} \\sum_{j=0}^{N_{\\phi}-1} w^{(\\mu)}_{i}\\, w^{(\\phi)}\n$$\nThe double summation can be separated into a product of two independent sums:\n$$\nJ_{S_{N}} = \\frac{I_0}{4\\pi} \\left( \\sum_{i=1}^{N} w^{(\\mu)}_{i} \\right) \\left( \\sum_{j=0}^{N_{\\phi}-1} w^{(\\phi)} \\right)\n$$\nThis expression demonstrates that the accuracy of the integration of a constant field depends entirely on the sum of the quadrature weights. We analyze each sum individually.\n\nThe first sum involves the weights of the $N$-point Gauss-Legendre quadrature. A fundamental property of any numerical quadrature rule designed to approximate $\\int_a^b f(x) \\, \\mathrm{d}x$ is its degree of exactness. An $N$-point Gauss-Legendre quadrature on the interval $[-1,1]$ is exact for all polynomials of degree up to $2N-1$. The function $f(\\mu) = 1$ is a polynomial of degree $0$. Since $N \\ge 1$ (the problem uses $N \\in \\{4, 8, 12\\}$), we have $2N-1 \\ge 1 > 0$. Therefore, the quadrature will integrate a constant function exactly.\n$$\n\\sum_{i=1}^{N} w^{(\\mu)}_{i} = \\int_{-1}^{1} 1 \\, \\mathrm{d}\\mu = [\\mu]_{-1}^{1} = 1 - (-1) = 2\n$$\n\nThe second sum involves the weights of the azimuthal quadrature. The problem specifies an equally spaced trapezoidal quadrature with $N_{\\phi} = 2N$ nodes on the interval $[0, 2\\pi)$. The weight for each node is constant, given by $w^{(\\phi)} = \\frac{2\\pi}{N_{\\phi}}$. The sum of these weights is:\n$$\n\\sum_{j=0}^{N_{\\phi}-1} w^{(\\phi)} = \\sum_{j=0}^{N_{\\phi}-1} \\frac{2\\pi}{N_{\\phi}} = N_{\\phi} \\times \\frac{2\\pi}{N_{\\phi}} = 2\\pi\n$$\nThis shows that the trapezoidal rule with these weights is also exact for constant functions over its domain.\n\nNow, we substitute the values of these weight sums back into the expression for $J_{S_N}$:\n$$\nJ_{S_{N}} = \\frac{I_0}{4\\pi} (2) (2\\pi) = \\frac{I_0}{4\\pi} (4\\pi) = I_0\n$$\nThis derivation proves that the numerical approximation $J_{S_N}$ is analytically identical to the exact value $J = I_0$. The chosen product quadrature integrates constant functions (spherical harmonics of degree $l=0$) over the sphere exactly.\n\nFinally, we compute the absolute error $\\varepsilon_{S_N}$:\n$$\n\\varepsilon_{S_{N}} = |J_{S_N} - J| = |I_0 - I_0| = 0\n$$\nIn exact arithmetic, the error is zero, regardless of the quadrature order $N$ or the intensity value $I_0$. Any non-zero error observed in a practical computation will solely be the result of floating-point precision limitations. For $I_0=0.0$, the error will be exactly $0.0$. For non-zero $I_0$, the computed error will be on the order of machine epsilon scaled by $I_0$.\n\nThe implementation will compute this error for the specified values of $I_0 \\in \\{0.0, 1.0, 3.7, 10^6\\}$ and $N \\in \\{4, 8, 12\\}$. We expect the results to be numerically indistinguishable from zero.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Implements the Discrete Ordinates Method (DOM) for an isotropic radiation\n    field and computes the absolute error for various quadrature levels (S_N)\n    and intensity values (I_0).\n    \"\"\"\n    # Define the test cases from the problem statement.\n    i0_values = [0.0, 1.0, 3.7, 10.0**6]\n    n_values = [4, 8, 12]\n\n    results = []\n\n    for i0 in i0_values:\n        for n in n_values:\n            # 1. Exact Mean Intensity Calculation\n            # For an isotropic radiation field I(Omega) = I_0, the mean\n            # intensity J = (1/4pi) * integral(I_0 dOmega) = I_0.\n            j_exact = float(i0)\n\n            # 2. Quadrature Setup\n            # The quadrature is a tensor product of Gauss-Legendre in the polar\n            # direction and an equally spaced trapezoidal rule in the azimuthal direction.\n\n            # Polar component: N-point Gauss-Legendre quadrature for mu in [-1, 1].\n            # scipy.special.roots_legendre returns nodes and weights.\n            _mu_nodes, mu_weights = roots_legendre(n)\n\n            # Azimuthal component: N_phi = 2N point trapezoidal rule for phi in [0, 2pi).\n            n_phi = 2 * n\n            phi_weight = 2.0 * np.pi / n_phi\n\n            # 3. Compute the Approximated Mean Intensity J_SN\n            # The integrand I(Omega) is a constant, I_0. The numerical integral is:\n            # J_SN = (1 / 4pi) * sum_i(sum_j(w_mu_i * w_phi * I_0))\n            # This simplifies to: J_SN = (I_0 / 4pi) * (sum_i w_mu_i) * (sum_j w_phi)\n\n            # The sum of Gauss-Legendre weights for an integral over [-1, 1] is exactly 2.\n            # This is because Gauss-Legendre is exact for polynomials of degree 2N-1,\n            # and the function f(mu)=1 is a polynomial of degree 0.\n            sum_mu_weights = np.sum(mu_weights)\n\n            # The sum of the equally spaced trapezoidal weights for an integral over [0, 2pi) is 2pi.\n            sum_phi_weights = n_phi * phi_weight\n\n            # The total sum of weights for the full spherical integral is the product.\n            total_weight_sum = sum_mu_weights * sum_phi_weights\n            \n            # As derived, for a constant integrand, the quadrature is exact.\n            # J_SN = I_0 * (total_weight_sum / (4.0 * np.pi))\n            # The ratio of weight sums should be 1.0 up to machine precision.\n            j_sn = j_exact / (4.0 * np.pi) * total_weight_sum\n\n            # 4. Compute the Absolute Error\n            # The error arises from floating-point arithmetic, as the analytical error is zero.\n            error = np.abs(j_sn - j_exact)\n            results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Real gases absorb and emit radiation in a highly non-uniform manner across the spectrum, a phenomenon that simplified \"gray\" models often fail to capture accurately. The Planck-mean absorption coefficient, $\\kappa_P$, provides a common method to define an equivalent gray gas, but its accuracy depends on the specific conditions. This practice provides hands-on experience in comparing a spectrally-resolved radiative heat flux calculation with its gray-gas counterpart, allowing you to quantify the error and develop a critical understanding of when such simplifications are justified. ",
            "id": "4020295",
            "problem": "Consider a one-dimensional, plane-parallel, isothermal, homogeneous gas slab of thickness $L$ in $\\text{m}$, filled with a water–carbon dioxide mixture at temperature $T=1800$ $\\text{K}$ and total pressure $P=1$ $\\text{atm}$. The slab is bounded on both sides by vacuum; the boundaries are non-reflecting and non-emitting. The refractive index is unity, the gas is non-scattering, and the only radiative interaction is absorption and emission. The goal is to quantify the error introduced by a gray approximation relative to a spectrally resolved Discrete Ordinates Method (DOM) solution.\n\nStart from the plane-parallel Radiative Transfer Equation (RTE) for spectral intensity $I_\\lambda(x,\\mu)$ in a non-scattering, isothermal, homogeneous medium,\n$$\n\\mu \\,\\frac{d I_\\lambda}{dx} \\;=\\; -\\kappa_\\lambda \\left(I_\\lambda - B_\\lambda(T)\\right),\n$$\nwhere $\\mu$ is the direction cosine with respect to the slab normal, $\\kappa_\\lambda$ is the spectral absorption coefficient in $\\text{m}^{-1}$, and $B_\\lambda(T)$ is the Planck spectral radiance in $\\text{W}\\,\\text{m}^{-3}\\,\\text{sr}^{-1}$,\n$$\nB_\\lambda(T) \\;=\\; \\frac{2 h c^2}{\\lambda^5} \\left[\\exp\\!\\left(\\frac{h c}{\\lambda k_B T}\\right) - 1\\right]^{-1},\n$$\nwith $h$ the Planck constant, $c$ the speed of light, and $k_B$ the Boltzmann constant. Assume the absorption coefficient of the mixture is additive in species mole fractions at $P=1$ $\\text{atm}$:\n$$\n\\kappa_\\lambda^{\\text{mix}} \\;=\\; y_{\\mathrm{H_2O}}\\,\\kappa_\\lambda^{\\mathrm{H_2O}} \\;+\\; y_{\\mathrm{CO_2}}\\,\\kappa_\\lambda^{\\mathrm{CO_2}},\n$$\nwhere $y_{\\mathrm{H_2O}}$ and $y_{\\mathrm{CO_2}}$ are the mole fractions. The following spectrally resolved tabulated data at $T=1800$ $\\text{K}$ and $P=1$ $\\text{atm}$ are provided for wavelength $\\lambda$ in micrometers and species absorption coefficient in $\\text{m}^{-1}$ per unit mole fraction:\n- Wavelengths in micrometers: $\\lambda \\in \\{2.0,\\,2.7,\\,4.3,\\,5.0,\\,10.0\\}$.\n- Water absorption coefficients: $\\kappa_\\lambda^{\\mathrm{H_2O}} \\in \\{0.2,\\,5.0,\\,0.5,\\,0.3,\\,0.1\\}$ $\\text{m}^{-1}$.\n- Carbon dioxide absorption coefficients: $\\kappa_\\lambda^{\\mathrm{CO_2}} \\in \\{0.1,\\,0.3,\\,8.0,\\,0.4,\\,0.2\\}$ $\\text{m}^{-1}$.\n\nFor the spectrally resolved solution, compute the outward hemispherical spectral heat flux at the left boundary $x=0$ using $S_4$ Discrete Ordinates Method (DOM), i.e., approximate the angular integral over $\\mu\\in[0,1]$ with four Gauss–Legendre points and weights on the half-range. For each wavelength, apply the exact characteristic solution for constant properties to obtain the boundary intensity in the outward directions $\\mu<0$,\n$$\nI_\\lambda(0,\\mu<0) \\;=\\; B_\\lambda(T)\\,\\left[1 - \\exp\\!\\left(-\\frac{\\kappa_\\lambda^{\\text{mix}}\\,L}{|\\mu|}\\right)\\right],\n$$\nand then compute the outward spectral heat flux\n$$\nq_\\lambda(0) \\;=\\; 2\\pi \\,\\int_{0}^{1} \\mu \\, I_\\lambda(0,-\\mu)\\, d\\mu,\n$$\napproximated by $S_4$ quadrature. The total outward heat flux $q_{\\text{spec}}$ in $\\text{W}\\,\\text{m}^{-2}$ is obtained by numerically integrating $q_\\lambda(0)$ over wavelength $\\lambda$ expressed in meters.\n\nFor the gray approximation, replace $\\kappa_\\lambda^{\\text{mix}}$ by its Planck-mean value at $T=1800$ $\\text{K}$,\n$$\n\\kappa_{\\text{P}} \\;=\\; \\frac{\\int_{0}^{\\infty} \\kappa_\\lambda^{\\text{mix}} \\, B_\\lambda(T)\\, d\\lambda}{\\int_{0}^{\\infty} B_\\lambda(T)\\, d\\lambda},\n$$\nand solve the gray RTE for the spectrally integrated intensity $I(x,\\mu)$,\n$$\n\\mu \\,\\frac{d I}{dx} \\;=\\; -\\kappa_{\\text{P}} \\left(I - B(T)\\right),\n$$\nwhere $B(T)=\\int_{0}^{\\infty} B_\\lambda(T)\\, d\\lambda$ in $\\text{W}\\,\\text{m}^{-2}\\,\\text{sr}^{-1}$, using the same $S_4$ quadrature and constant-property characteristic solution\n$$\nI(0,\\mu<0) \\;=\\; B(T)\\,\\left[1 - \\exp\\!\\left(-\\frac{\\kappa_{\\text{P}}\\,L}{|\\mu|}\\right)\\right],\n$$\nto compute the outward gray heat flux\n$$\nq_{\\text{gray}}(0) \\;=\\; 2\\pi \\,\\int_{0}^{1} \\mu \\, I(0,-\\mu)\\, d\\mu.\n$$\n\nDefine the relative gray error as\n$$\n\\varepsilon \\;=\\; \\frac{q_{\\text{gray}} - q_{\\text{spec}}}{q_{\\text{spec}}},\n$$\na dimensionless quantity to be reported as a decimal.\n\nImplement a program that carries out the above calculations using:\n- The provided spectral tabulation for $\\lambda$ in micrometers converted to meters.\n- The Discrete Ordinates Method (DOM) with $S_4$ half-range Gauss–Legendre quadrature for angular integration.\n- Numerical trapezoidal integration over the provided wavelength grid for all spectral integrals.\n\nUse the following test suite of parameter values, covering typical, optically thin, and optically thick cases:\n- Case $1$: $L=0.05$ $\\text{m}$, $y_{\\mathrm{H_2O}}=0.10$, $y_{\\mathrm{CO_2}}=0.10$.\n- Case $2$: $L=0.001$ $\\text{m}$, $y_{\\mathrm{H_2O}}=0.10$, $y_{\\mathrm{CO_2}}=0.05$.\n- Case $3$: $L=0.20$ $\\text{m}$, $y_{\\mathrm{H_2O}}=0.05$, $y_{\\mathrm{CO_2}}=0.20$.\n\nYour program should produce a single line of output containing the relative gray errors for the above three cases as a comma-separated list of decimal numbers enclosed in square brackets, for example, $[e_1,e_2,e_3]$. Angles, if any, must be treated in radians. The final answers must be expressed as decimals; physical fluxes are computed internally in $\\text{W}\\,\\text{m}^{-2}$, but the output is unitless.",
            "solution": "The fundamental base is the plane-parallel Radiative Transfer Equation (RTE) for a non-scattering, isothermal, homogeneous medium, the Planck spectral radiance, and energy conservation through angular and spectral integration. We consider a gas slab at temperature $T=1800$ $\\text{K}$, with refractive index unity, bounded by vacuum on each side, so there is no incident external radiation. The gas absorbs and emits but does not scatter. The boundary conditions are $I_\\lambda(0,\\mu>0)=0$ and $I_\\lambda(L,\\mu<0)=0$.\n\nWe begin with the RTE in one spatial dimension,\n$$\n\\mu \\,\\frac{d I_\\lambda}{dx} \\;=\\; -\\kappa_\\lambda \\left(I_\\lambda - B_\\lambda(T)\\right),\n$$\nwith constant $\\kappa_\\lambda$ and $B_\\lambda(T)$ because the slab is homogeneous and isothermal. This is a first-order linear ordinary differential equation along each direction $\\mu$. The homogeneous solution decays exponentially, and the particular solution is constant at $B_\\lambda(T)$. Applying the boundary condition at $x=L$ for $\\mu<0$ gives the characteristic solution at the left boundary $x=0$ in the outward directions $\\mu<0$:\n$$\nI_\\lambda(0,\\mu<0) \\;=\\; B_\\lambda(T)\\,\\left[1 - \\exp\\!\\left(-\\frac{\\kappa_\\lambda L}{|\\mu|}\\right)\\right].\n$$\nBy symmetry, the right boundary outward intensity is obtained similarly from the $x=0$ boundary condition for $\\mu>0$. We focus on the left boundary.\n\nThe outward hemispherical spectral heat flux at $x=0$ is\n$$\nq_\\lambda(0) \\;=\\; 2\\pi \\int_0^1 \\mu \\, I_\\lambda(0,-\\mu) \\, d\\mu,\n$$\nwhere the factor $2\\pi$ is the azimuthal integral for axisymmetry in a plane-parallel slab. Since we cannot analytically integrate $\\mu$ times the exponential term for an arbitrary discrete scheme, we invoke the Discrete Ordinates Method (DOM). The DOM replaces the angular integral by a quadrature over discrete direction cosines and weights. Specifically, we adopt the $S_4$ scheme on the half-range, using four Gauss–Legendre points $\\{\\mu_m\\}_{m=1}^4$ in $[0,1]$ and corresponding weights $\\{w_m\\}_{m=1}^4$. The quadrature approximates\n$$\n\\int_0^1 f(\\mu)\\, d\\mu \\;\\approx\\; \\sum_{m=1}^4 w_m \\, f(\\mu_m).\n$$\nThus,\n$$\nq_\\lambda(0) \\;\\approx\\; 2\\pi \\sum_{m=1}^4 w_m \\, \\mu_m \\, I_\\lambda(0,-\\mu_m).\n$$\nThe mixture absorption coefficient is additive in mole fractions under the given assumption:\n$$\n\\kappa_\\lambda^{\\text{mix}} \\;=\\; y_{\\mathrm{H_2O}}\\,\\kappa_\\lambda^{\\mathrm{H_2O}} \\;+\\; y_{\\mathrm{CO_2}}\\,\\kappa_\\lambda^{\\mathrm{CO_2}}.\n$$\nWe compute $I_\\lambda(0,-\\mu_m)$ for each wavelength and direction using the characteristic solution above.\n\nNext, we integrate $q_\\lambda(0)$ over wavelength to obtain the total outward heat flux,\n$$\nq_{\\text{spec}} \\;=\\; \\int q_\\lambda(0)\\, d\\lambda,\n$$\nwhich we evaluate via the trapezoidal rule on the provided wavelength grid (converted from micrometers to meters) to maintain consistency with the tabulated data.\n\nFor the gray approximation, we define the Planck-mean absorption coefficient, using the same tabulated spectral grid and trapezoidal rule,\n$$\n\\kappa_{\\text{P}} \\;=\\; \\frac{\\int \\kappa_\\lambda^{\\text{mix}} B_\\lambda(T)\\, d\\lambda}{\\int B_\\lambda(T)\\, d\\lambda}.\n$$\nWe introduce the spectrally integrated Planck radiance,\n$$\nB(T) \\;=\\; \\int B_\\lambda(T)\\, d\\lambda,\n$$\nin $\\text{W}\\,\\text{m}^{-2}\\,\\text{sr}^{-1}$. The gray RTE for the spectrally integrated intensity $I(x,\\mu)$ retains the same form:\n$$\n\\mu \\,\\frac{d I}{dx} \\;=\\; -\\kappa_{\\text{P}} \\left(I - B(T)\\right).\n$$\nWith the same boundary conditions (zero incident radiation from vacuum) and constant coefficients, the characteristic solution at $x=0$ for outward directions $\\mu<0$ is\n$$\nI(0,\\mu<0) \\;=\\; B(T)\\,\\left[1 - \\exp\\!\\left(-\\frac{\\kappa_{\\text{P}} L}{|\\mu|}\\right)\\right].\n$$\nUsing the same $S_4$ quadrature,\n$$\nq_{\\text{gray}}(0) \\;\\approx\\; 2\\pi \\sum_{m=1}^4 w_m \\, \\mu_m \\, I(0,-\\mu_m).\n$$\n\nFinally, the relative gray error is defined as\n$$\n\\varepsilon \\;=\\; \\frac{q_{\\text{gray}} - q_{\\text{spec}}}{q_{\\text{spec}}}.\n$$\nWe compute $\\varepsilon$ for each test case:\n- Case $1$: $L=0.05$ $\\text{m}$, $y_{\\mathrm{H_2O}}=0.10$, $y_{\\mathrm{CO_2}}=0.10$.\n- Case $2$: $L=0.001$ $\\text{m}$, $y_{\\mathrm{H_2O}}=0.10$, $y_{\\mathrm{CO_2}}=0.05$.\n- Case $3$: $L=0.20$ $\\text{m}$, $y_{\\mathrm{H_2O}}=0.05$, $y_{\\mathrm{CO_2}}=0.20$.\n\nAlgorithmic steps:\n- Convert wavelengths from micrometers to meters.\n- Compute $B_\\lambda(T)$ for each wavelength, using physical constants $h$, $c$, $k_B$.\n- Form $\\kappa_\\lambda^{\\text{mix}}$ from species mole fractions and tabulated $\\kappa_\\lambda$.\n- Construct $S_4$ half-range Gauss–Legendre nodes $\\mu_m$ and weights $w_m$.\n- Spectral DOM: For each wavelength, evaluate $I_\\lambda(0,-\\mu_m)$ and compute $q_\\lambda(0)$; then integrate over $\\lambda$ to obtain $q_{\\text{spec}}$.\n- Gray DOM: Compute $\\kappa_{\\text{P}}$ and $B(T)$ via trapezoidal integration; evaluate $I(0,-\\mu_m)$ and compute $q_{\\text{gray}}$.\n- Report $\\varepsilon$ for each case as decimals in the required single-line format.\n\nThis approach aligns with the Discrete Ordinates Method (DOM) for angular integration, uses the exact characteristic solution for the RTE under constant properties, and applies Planck weighting for the gray approximation. All quantities are computed in consistent units; the final reported errors are unitless decimals.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Physical constants\nh = 6.62607015e-34       # Planck constant, J*s\nc = 2.99792458e8         # speed of light, m/s\nkB = 1.380649e-23        # Boltzmann constant, J/K\n\nT = 1800.0  # K\n\n# Tabulated spectral data at T=1800 K, P=1 atm\n# Wavelengths in micrometers; will convert to meters\nlambda_um = np.array([2.0, 2.7, 4.3, 5.0, 10.0], dtype=float)\nlambda_m = lambda_um * 1e-6\n\n# Species absorption coefficients (per unit mole fraction) in 1/m\nkappa_H2O = np.array([0.2, 5.0, 0.5, 0.3, 0.1], dtype=float)\nkappa_CO2 = np.array([0.1, 0.3, 8.0, 0.4, 0.2], dtype=float)\n\ndef planck_lambda(lam, T):\n    \"\"\"\n    Planck spectral radiance B_lambda(T) [W m^-3 sr^-1] for wavelength lam [m].\n    \"\"\"\n    # Avoid overflow/underflow issues with large/small arguments\n    x = (h * c) / (lam * kB * T)\n    # Use expm1 for numerical stability: 1/(exp(x)-1) = 1/expm1(x)\n    return (2.0 * h * c**2) / (lam**5) / np.expm1(x)\n\ndef half_range_gauss_legendre(n):\n    \"\"\"\n    Half-range Gauss-Legendre quadrature on [0,1].\n    Returns nodes mu in [0,1] and weights w for integrating f(mu) over [0,1].\n    \"\"\"\n    # Legendre nodes/weights on [-1, 1]\n    xi, wi = np.polynomial.legendre.leggauss(n)\n    # Map to [0, 1]: mu = (xi + 1)/2, w = wi/2\n    mu = 0.5 * (xi + 1.0)\n    w = 0.5 * wi\n    return mu, w\n\ndef spectral_flux_left(L, y_H2O, y_CO2):\n    \"\"\"\n    Compute the spectrally resolved outward hemispherical heat flux at the left boundary.\n    \"\"\"\n    # Mixture absorption coefficient at each wavelength\n    kappa_mix = y_H2O * kappa_H2O + y_CO2 * kappa_CO2  # 1/m\n    # Planck spectral radiance at each wavelength\n    B_lam = planck_lambda(lambda_m, T)  # W m^-3 sr^-1\n\n    # S4 half-range quadrature\n    mu, w = half_range_gauss_legendre(4)\n\n    # For each wavelength, compute q_lambda via DOM:\n    # I_lambda(0, -mu) = B_lambda(T) * [1 - exp(-kappa_mix * L / mu)]\n    # q_lambda = 2*pi * sum_m w_m * mu_m * I_lambda(0, -mu_m)\n    I_boundary = B_lam[:, None] * (1.0 - np.exp(-(kappa_mix[:, None] * L) / mu[None, :]))\n    q_lambda = 2.0 * np.pi * np.sum(w[None, :] * mu[None, :] * I_boundary, axis=1)  # W m^-3\n\n    # Integrate q_lambda over wavelength to get total flux [W m^-2]\n    q_spec = np.trapz(q_lambda, lambda_m)\n    return q_spec\n\ndef gray_flux_left(L, y_H2O, y_CO2):\n    \"\"\"\n    Compute the gray outward hemispherical heat flux at the left boundary using Planck-mean kappa.\n    \"\"\"\n    kappa_mix = y_H2O * kappa_H2O + y_CO2 * kappa_CO2  # 1/m\n    B_lam = planck_lambda(lambda_m, T)  # W m^-3 sr^-1\n\n    # Spectrally integrated B(T) and Planck-mean kappa\n    B_total = np.trapz(B_lam, lambda_m)  # W m^-2 sr^-1\n    numerator = np.trapz(kappa_mix * B_lam, lambda_m)  # (1/m) * W m^-3 sr^-1 integrated -> W m^-2 sr^-1 / m\n    kappa_P = numerator / B_total  # 1/m\n\n    mu, w = half_range_gauss_legendre(4)\n\n    # I(0, -mu) = B_total * [1 - exp(-kappa_P * L / mu)]\n    I_gray_boundary = B_total * (1.0 - np.exp(-(kappa_P * L) / mu))\n    q_gray = 2.0 * np.pi * np.sum(w * mu * I_gray_boundary)  # W m^-2\n    return q_gray\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (L [m], y_H2O, y_CO2)\n    test_cases = [\n        (0.05, 0.10, 0.10),   # Case 1: typical\n        (0.001, 0.10, 0.05),  # Case 2: optically thin\n        (0.20, 0.05, 0.20),   # Case 3: optically thick, CO2-dominant band\n    ]\n\n    results = []\n    for L, yH2O, yCO2 in test_cases:\n        q_spec = spectral_flux_left(L, yH2O, yCO2)\n        q_gray = gray_flux_left(L, yH2O, yCO2)\n        # Relative error as decimal\n        err = (q_gray - q_spec) / q_spec\n        results.append(err)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "To make non-gray radiation computationally tractable, models like the Weighted-Sum-of-Gray-Gases (WSGG) are indispensable. These models require careful calibration, where their parameters, such as the temperature-dependent weights $a_i(T)$, are fitted to match high-fidelity spectral data. This exercise guides you through this process using a least-squares optimization, a key skill for advanced practitioners that bridges fundamental radiative transfer theory with practical numerical implementation. ",
            "id": "4020303",
            "problem": "You are calibrating a Weighted-Sum-of-Gray-Gases (WSGG) model to provide spectrally integrated gas emissivities for use in a Discrete Ordinates Method (DOM) solver in computational combustion. Start from the fundamental radiative transfer for a homogeneous, isothermal, non-scattering layer of thickness $L$ at uniform temperature $T$, with a gray absorption coefficient $k$. By the Beer–Lambert law, the spectral transmittance is $\\exp(-k U)$, where $U = p L$ is the pressure–path length. For a gray gas slab exchanging with a black isothermal enclosure at the same temperature, the hemispherical emissivity equals the absorptivity, and is given by\n$$\n\\varepsilon_\\text{gray}(U;k) = 1 - \\exp(-k U).\n$$\nThe WSGG model approximates the spectrally averaged emissivity of a real gas as a convex combination of $N_g$ fictitious gray gases (plus an implicit clear gas of zero absorption), each with a fixed absorption coefficient $k_i$ and temperature-dependent weight $a_i(T)$, satisfying $a_i(T) \\ge 0$ and $\\sum_{i=1}^{N_g} a_i(T) = 1$. The WSGG emissivity reads\n$$\n\\varepsilon_\\text{WSGG}(U;T,\\mathbf{a}) = \\sum_{i=1}^{N_g} a_i(T) \\left[1 - \\exp\\left(-k_i U\\right)\\right],\n$$\nwhere $\\mathbf{a} = \\left(a_1(T),\\dots,a_{N_g}(T)\\right)$.\n\nSuppose you have high-fidelity reference emissivity data (representing line-by-line integration) $\\varepsilon^\\text{ref}(U;T)$ for various $U$ and $T$. Your task is to construct and solve least-squares calibration problems to fit the WSGG weights $a_i(T)$ so that $\\varepsilon_\\text{WSGG}(U;T,\\mathbf{a})$ best matches $\\varepsilon^\\text{ref}(U;T)$ in the sense of the Euclidean $2$-norm of the residual vector. Specifically, define the residuals\n$$\nr_j(T;\\mathbf{a}) = \\varepsilon_\\text{WSGG}(U_j;T,\\mathbf{a}) - \\varepsilon^\\text{ref}(U_j;T),\n$$\nstacked over a set of pressure–path lengths $\\{U_j\\}_{j=1}^{M}$, and minimize the norm\n$$\n\\left\\| \\mathbf{r}(T;\\mathbf{a}) \\right\\|_2 = \\sqrt{ \\sum_{j=1}^{M} \\left[r_j(T;\\mathbf{a})\\right]^2 }.\n$$\nFor multi-temperature calibration, stack all residuals across all $(U_j,T_m)$ pairs into one vector and minimize the overall $2$-norm.\n\nAll variables must be used with the following units: $T$ in $\\text{K}$, $U$ in $\\text{atm}\\cdot\\text{m}$, $k_i$ in $\\text{(atm}\\cdot\\text{m)}^{-1}$, and emissivities are dimensionless.\n\nTo ensure the calibration problem is fully specified, use the following test suite in your program. In all cases, treat the given $\\varepsilon^\\text{ref}$ values as data, and fit the WSGG weights by least squares to minimize the specified Euclidean $2$-norm. You must enforce the sum-to-one constraint $\\sum_i a_i(T) = 1$ exactly by eliminating one weight variable per temperature (for example, set $a_{N_g}(T)=1-\\sum_{i=1}^{N_g-1} a_i(T)$), and you may ignore nonnegativity.\n\n- Case $1$ (single temperature, two gray gases):\n  - Parameters: $N_g = 2$, $T = 1200\\,\\text{K}$, $\\mathbf{k} = [0.5, 5.0]\\,\\text{(atm}\\cdot\\text{m)}^{-1}$, $U \\in \\{0.1, 0.5, 1.0, 2.0\\}\\,\\text{atm}\\cdot\\text{m}$.\n  - Synthetic truth for data generation: $\\mathbf{a}^\\star(T) = [0.3, 0.7]$.\n  - Data: $\\varepsilon^\\text{ref}(U;T) = \\sum_{i=1}^{2} a^\\star_i(T)\\left[1-\\exp(-k_i U)\\right]$ for each $U$.\n\n  Task: Fit the single unknown weight $a_1(T)$ with $a_2(T)=1-a_1(T)$ by least squares and report the fitted weights and the minimized residual $2$-norm.\n\n- Case $2$ (boundary coverage, two data points at extreme $U$):\n  - Parameters: $N_g = 2$, $T = 1200\\,\\text{K}$, $\\mathbf{k} = [0.5, 5.0]\\,\\text{(atm}\\cdot\\text{m)}^{-1}$, $U \\in \\{10^{-4}, 10.0\\}\\,\\text{atm}\\cdot\\text{m}$.\n  - Synthetic truth for data generation: $\\mathbf{a}^\\star(T) = [0.3, 0.7]$.\n  - Data: $\\varepsilon^\\text{ref}(U;T)$ constructed as in Case $1$.\n\n  Task: Fit as in Case $1$ and report the fitted weights and the minimized residual $2$-norm.\n\n- Case $3$ (multi-temperature, polynomial weights, three gray gases):\n  - Parameters: $N_g = 3$, $\\mathbf{k} = [0.2, 2.0, 15.0]\\,\\text{(atm}\\cdot\\text{m)}^{-1}$, $T \\in \\{800, 1200, 1800\\}\\,\\text{K}$, $U \\in \\{0.05, 0.2, 1.0, 3.0\\}\\,\\text{atm}\\cdot\\text{m}$.\n  - Define the normalized temperature $\\theta(T) = \\dfrac{T - T_0}{\\Delta T}$ with $T_0 = 1200\\,\\text{K}$ and $\\Delta T = 600\\,\\text{K}$.\n  - Synthetic truth for data generation, linear in $\\theta$:\n    $$\n    a_1^\\star(T) = 0.25 + 0.05\\,\\theta(T),\\quad\n    a_2^\\star(T) = 0.55 - 0.10\\,\\theta(T),\\quad\n    a_3^\\star(T) = 1 - a_1^\\star(T) - a_2^\\star(T).\n    $$\n  - Data: $\\varepsilon^\\text{ref}(U;T)$ computed from the above truth for each pair $(U,T)$.\n\n  Task: Calibrate a linear-in-$\\theta$ model for the first two weights and eliminate the third to enforce the sum-to-one constraint:\n    $$\n    a_1(T) = b_{10} + b_{11}\\,\\theta(T),\\quad\n    a_2(T) = b_{20} + b_{21}\\,\\theta(T),\\quad\n    a_3(T) = 1 - a_1(T) - a_2(T).\n    $$\n    Solve for the coefficients $b_{10}, b_{11}, b_{20}, b_{21}$ by minimizing the stacked residual $2$-norm across all $(U,T)$ samples. Then report the fitted weights evaluated at $T=800\\,\\text{K}$, $T=1200\\,\\text{K}$, and $T=1800\\,\\text{K}$, together with the minimized residual $2$-norm over the stacked dataset.\n\nYour program must output a single line containing a comma-separated Python-style list that aggregates the results in the following order:\n- Case $1$: fitted $a_1(T)$, fitted $a_2(T)$, minimized residual $2$-norm.\n- Case $2$: fitted $a_1(T)$, fitted $a_2(T)$, minimized residual $2$-norm.\n- Case $3$: fitted $[a_1(800\\,\\text{K}), a_2(800\\,\\text{K}), a_3(800\\,\\text{K}), a_1(1200\\,\\text{K}), a_2(1200\\,\\text{K}), a_3(1200\\,\\text{K}), a_1(1800\\,\\text{K}), a_2(1800\\,\\text{K}), a_3(1800\\,\\text{K})]$, followed by the minimized residual $2$-norm.\n\nThus, your program should produce a single line:\n\"[$r_1,r_2,\\dots,r_{16}$]\"\nwith $16$ floats in the exact order specified above. Emissivities are dimensionless; all inputs use the stated physical units; angles are not used. No percentage signs are permitted in the output; all numbers must be printed as decimal floats.",
            "solution": "The user has provided a problem that requires the calibration of a Weighted-Sum-of-Gray-Gases (WSGG) model. I will first validate the problem statement.\n\n### Step 1: Extract Givens\n\n- **WSGG Model**: The emissivity is given by $\\varepsilon_\\text{WSGG}(U;T,\\mathbf{a}) = \\sum_{i=1}^{N_g} a_i(T) \\left[1 - \\exp\\left(-k_i U\\right)\\right]$, with weights $a_i(T) \\ge 0$ and $\\sum_{i=1}^{N_g} a_i(T) = 1$.\n- **Least-Squares Objective**: Minimize the Euclidean $2$-norm of the residual vector, $\\| \\mathbf{r}(T;\\mathbf{a}) \\|_2 = \\sqrt{ \\sum_{j=1}^{M} \\left[r_j(T;\\mathbf{a})\\right]^2 }$, where $r_j(T;\\mathbf{a}) = \\varepsilon_\\text{WSGG}(U_j;T,\\mathbf{a}) - \\varepsilon^\\text{ref}(U_j;T)$.\n- **Constraints**: Enforce $\\sum_i a_i(T) = 1$ by elimination, e.g., $a_{N_g}(T)=1-\\sum_{i=1}^{N_g-1} a_i(T)$. Ignore nonnegativity $a_i(T) \\ge 0$.\n- **Units**: $T$ in $\\text{K}$, $U$ in $\\text{atm}\\cdot\\text{m}$, $k_i$ in $\\text{(atm}\\cdot\\text{m)}^{-1}$.\n\n- **Case 1**:\n  - $N_g = 2$, $T = 1200\\,\\text{K}$.\n  - $\\mathbf{k} = [0.5, 5.0]\\,\\text{(atm}\\cdot\\text{m)}^{-1}$.\n  - $U \\in \\{0.1, 0.5, 1.0, 2.0\\}\\,\\text{atm}\\cdot\\text{m}$.\n  - Reference data $\\varepsilon^\\text{ref}$ generated with true weights $\\mathbf{a}^\\star(T) = [0.3, 0.7]$.\n  - Task: Fit $a_1(T)$ with $a_2(T)=1-a_1(T)$ and report $[a_1, a_2, \\|\\mathbf{r}\\|_2]$.\n\n- **Case 2**:\n  - $N_g = 2$, $T = 1200\\,\\text{K}$.\n  - $\\mathbf{k} = [0.5, 5.0]\\,\\text{(atm}\\cdot\\text{m)}^{-1}$.\n  - $U \\in \\{10^{-4}, 10.0\\}\\,\\text{atm}\\cdot\\text{m}$.\n  - Reference data $\\varepsilon^\\text{ref}$ generated with true weights $\\mathbf{a}^\\star(T) = [0.3, 0.7]$.\n  - Task: Fit as in Case $1$ and report $[a_1, a_2, \\|\\mathbf{r}\\|_2]$.\n\n- **Case 3**:\n  - $N_g = 3$, $\\mathbf{k} = [0.2, 2.0, 15.0]\\,\\text{(atm}\\cdot\\text{m)}^{-1}$.\n  - $T \\in \\{800, 1200, 1800\\}\\,\\text{K}$, $U \\in \\{0.05, 0.2, 1.0, 3.0\\}\\,\\text{atm}\\cdot\\text{m}$.\n  - Normalized temperature: $\\theta(T) = \\dfrac{T - T_0}{\\Delta T}$ with $T_0 = 1200\\,\\text{K}$ and $\\Delta T = 600\\,\\text{K}$.\n  - True weights (linear in $\\theta$): $a_1^\\star(T) = 0.25 + 0.05\\,\\theta(T)$, $a_2^\\star(T) = 0.55 - 0.10\\,\\theta(T)$, $a_3^\\star(T) = 1 - a_1^\\star(T) - a_2^\\star(T)$.\n  - Reference data $\\varepsilon^\\text{ref}$ generated from these true weights.\n  - Model to fit: $a_1(T) = b_{10} + b_{11}\\,\\theta(T)$, $a_2(T) = b_{20} + b_{21}\\,\\theta(T)$, $a_3(T) = 1 - a_1(T) - a_2(T)$.\n  - Task: Solve for coefficients $b_{10}, b_{11}, b_{20}, b_{21}$. Report fitted weights at the three temperatures and the overall residual norm $\\|\\mathbf{r}\\|_2$.\n\n- **Output Format**: A single line containing a comma-separated list of $16$ floats.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem is a well-defined mathematical exercise in linear least-squares fitting applied to a standard engineering model (WSGG).\n1.  **Scientific or Factual Unsoundness**: None. The problem is based on established principles of radiative heat transfer and the WSGG model.\n2.  **Non-Formalizable or Irrelevant**: None. The problem is a formalizable numerical task squarely within the specified topic area.\n3.  **Incomplete or Contradictory Setup**: None. All necessary parameters, data generation procedures, and constraints are provided. The tasks are specific and unambiguous.\n4.  **Unrealistic or Infeasible**: None. The parameter values are physically plausible for gas radiation problems. The task of fitting is a standard procedure.\n5.  **Ill-Posed or Poorly Structured**: None. As will be shown, the problems translate into overdetermined linear systems with full-rank matrices, guaranteeing a unique least-squares solution.\n6.  **Pseudo-Profound, Trivial, or Tautological**: The problem is not trivial, as it requires the correct algebraic manipulation to set up the linear systems. The fact that the synthetic data allows for a perfect fit with zero residual makes it a verification case, but the setup itself is a substantive exercise.\n7.  **Outside Scientific Verifiability**: None. The results are mathematically verifiable.\n\n### Step 3: Verdict and Action\n\nThe problem statement is **valid**. I will proceed with providing a complete solution.\n\nThe core of the problem is to minimize the sum of squared residuals, which constitutes a linear least-squares problem. We first linearize the WSGG model with respect to the unknown parameters.\n\n**Linearization of the WSGG Model**\nThe WSGG emissivity is given by $\\varepsilon_\\text{WSGG} = \\sum_{i=1}^{N_g} a_i(T) \\left[1 - \\exp\\left(-k_i U\\right)\\right]$.\nEnforcing the constraint $\\sum_{i=1}^{N_g} a_i(T) = 1$ by eliminating $a_{N_g}(T) = 1 - \\sum_{i=1}^{N_g-1} a_i(T)$, the model becomes:\n$$ \\varepsilon_\\text{WSGG} = \\sum_{i=1}^{N_g-1} a_i(T) [1 - e^{-k_i U}] + \\left(1 - \\sum_{i=1}^{N_g-1} a_i(T)\\right) [1 - e^{-k_{N_g} U}] $$\nRearranging to isolate the unknown weights $a_i(T)$ for $i \\in \\{1, \\dots, N_g-1\\}$:\n$$ \\varepsilon_\\text{WSGG} - [1 - e^{-k_{N_g} U}] = \\sum_{i=1}^{N_g-1} a_i(T) \\left( [1 - e^{-k_i U}] - [1 - e^{-k_{N_g} U}] \\right) $$\n$$ \\varepsilon_\\text{WSGG} - [1 - e^{-k_{N_g} U}] = \\sum_{i=1}^{N_g-1} a_i(T) (e^{-k_{N_g} U} - e^{-k_i U}) $$\nThe residual for a data point $(U_j, T_m)$ is $r_{j,m} = \\varepsilon_\\text{WSGG}(U_j; T_m, \\mathbf{a}) - \\varepsilon^\\text{ref}(U_j; T_m)$. The equation for the residual can be written as:\n$$ \\sum_{i=1}^{N_g-1} a_i(T_m) (e^{-k_{N_g} U_j} - e^{-k_i U_j}) - \\left(\\varepsilon^\\text{ref}(U_j, T_m) - [1 - e^{-k_{N_g} U_j}]\\right) = r_{j,m} $$\nThis is a linear system. For a set of $M$ data points at a fixed temperature, we can write this in matrix form $\\mathbf{C} \\mathbf{x} - \\mathbf{y} = \\mathbf{r}$, where we want to find the vector of unknowns $\\mathbf{x}$ that minimizes $\\| \\mathbf{r} \\|_2$. For $N_g$ gray gases, $\\mathbf{x}$ is the $(N_g-1)$-dimensional vector of weights $[a_1, \\dots, a_{N_g-1}]^T$. The design matrix $\\mathbf{C}$ of size $M \\times (N_g-1)$ has entries $C_{ji} = e^{-k_{N_g} U_j} - e^{-k_i U_j}$, and the target vector $\\mathbf{y}$ of size $M$ has entries $y_j = \\varepsilon^\\text{ref}(U_j) - [1 - e^{-k_{N_g} U_j}]$.\nThe least-squares solution is found by solving the normal equations $(\\mathbf{C}^T \\mathbf{C}) \\mathbf{x} = \\mathbf{C}^T \\mathbf{y}$.\n\nIn all provided cases, the reference data $\\varepsilon^\\text{ref}$ is generated using a model identical in form to the one being fitted. This means a perfect fit is achievable, and the minimized residual norm will be zero (or numerically close to it). The least-squares procedure should recover the \"true\" parameters used for data generation.\n\n**Case 1: Single Temperature, Two Gray Gases**\nHere, $N_g=2$, so we solve for a single unknown, $a_1$. The vector of unknowns is $\\mathbf{x} = [a_1]$. We have $M=4$ data points. The design matrix $\\mathbf{C}$ is a $4 \\times 1$ column vector with elements $C_{j1} = e^{-k_2 U_j} - e^{-k_1 U_j}$, and $\\mathbf{y}$ is a $4 \\times 1$ vector.\nSince the problem is a verification case with noise-free synthetic data, the solution will be the true weight $a_1^\\star = 0.3$. Consequently, the fitted weight $a_2 = 1 - a_1 = 1 - 0.3 = 0.7$. The residual norm will be $0$.\n\n**Case 2: Boundary Coverage**\nThis case is identical in structure to Case $1$, with $N_g=2$ and one unknown $a_1$. The only difference lies in the choice of the $M=2$ pressure-path length points, $U \\in \\{10^{-4}, 10.0\\}$. The matrix $\\mathbf{C}$ is $2 \\times 1$. As long as its elements are non-zero (which they are for finite, distinct $k_i$), the problem is well-posed. The solution will again be the true weights $a_1 = 0.3$ and $a_2 = 0.7$, with a residual norm of $0$.\n\n**Case 3: Multi-temperature, Polynomial Weights**\nHere, the weights themselves are parameterized as linear functions of the normalized temperature $\\theta$:\n$a_1(T) = b_{10} + b_{11}\\,\\theta(T)$\n$a_2(T) = b_{20} + b_{21}\\,\\theta(T)$\nThe unknowns are the $4$ coefficients $\\mathbf{x} = [b_{10}, b_{11}, b_{20}, b_{21}]^T$. We have data at $3$ temperatures and $4$ path lengths, for a total of $M = 3 \\times 4 = 12$ data points. The residual equation for a point $(U_j, T_m)$ becomes:\n$$ r_{j,m} + y_{j,m} = (b_{10} + b_{11}\\theta_m)(e^{-k_3 U_j} - e^{-k_1 U_j}) + (b_{20} + b_{21}\\theta_m)(e^{-k_3 U_j} - e^{-k_2 U_j}) $$\nwhere $y_{j,m} = \\varepsilon^\\text{ref}(U_j, T_m) - (1 - e^{-k_3 U_j})$. This is linear in the coefficients $b_{ik}$. We assemble a $12 \\times 4$ design matrix $\\mathbf{C}$ and a $12 \\times 1$ target vector $\\mathbf{y}$ and solve the least-squares problem $\\min \\|\\mathbf{C}\\mathbf{x} - \\mathbf{y}\\|_2$. The columns of $\\mathbf{C}$ correspond to the terms multiplying each of the $4$ unknown coefficients.\nAgain, since the reference data is generated from this exact model structure, the fit will be perfect. The solution will recover the true coefficients used for data generation: $b_{10}=0.25$, $b_{11}=0.05$, $b_{20}=0.55$, $b_{21}=-0.10$. The overall residual norm will be $0$.\nThe required weights at each temperature are then calculated by substituting the fitted coefficients and the corresponding values of $\\theta (-2/3, 0, 1)$ into the polynomial expressions.\n\nThe numerical solution for each case is obtained using `numpy.linalg.lstsq` to solve the linear least-squares system. The minimized $2$-norm of the residual vector is the square root of the sum of squared residuals returned by this function.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the three least-squares calibration problems for the WSGG model.\n    \"\"\"\n    \n    # --- Case 1 ---\n    k1_case1 = np.array([0.5, 5.0])\n    U_case1 = np.array([0.1, 0.5, 1.0, 2.0])\n    a_star_case1 = np.array([0.3, 0.7])\n    \n    a1_case1, a2_case1, norm_case1 = solve_single_temp(k1_case1, U_case1, a_star_case1)\n    \n    # --- Case 2 ---\n    k2_case2 = np.array([0.5, 5.0])\n    U_case2 = np.array([1e-4, 10.0])\n    a_star_case2 = np.array([0.3, 0.7])\n    \n    a1_case2, a2_case2, norm_case2 = solve_single_temp(k2_case2, U_case2, a_star_case2)\n    \n    # --- Case 3 ---\n    weights_case3, norm_case3 = solve_multi_temp()\n    \n    # --- Aggregate results ---\n    results = [\n        a1_case1, a2_case1, norm_case1,\n        a1_case2, a2_case2, norm_case2,\n        *weights_case3,\n        norm_case3\n    ]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\ndef wsgg_emissivity(U, k, a):\n    \"\"\"Calculates WSGG emissivity for a set of U values.\"\"\"\n    eps = np.zeros_like(U)\n    for i in range(len(k)):\n        eps += a[i] * (1.0 - np.exp(-k[i] * U))\n    return eps\n\ndef solve_single_temp(k, U, a_star):\n    \"\"\"\n    Helper function for single-temperature WSGG fit (Cases 1 and 2).\n    Solves for a_1 where a_2 = 1 - a_1.\n    \"\"\"\n    Ng = len(k)\n    M = len(U)\n    \n    # Generate reference emissivity data\n    eps_ref = wsgg_emissivity(U, k, a_star)\n\n    # Set up the linear least-squares problem: C * x = y\n    # where x = [a_1]\n    \n    # Number of unknowns is Ng - 1 = 1\n    C = np.zeros((M, Ng - 1))\n    y = np.zeros(M)\n\n    k_elim = k[Ng - 1] # k_2 in this case\n    \n    for j in range(M):\n        y[j] = eps_ref[j] - (1.0 - np.exp(-k_elim * U[j]))\n        # Column for a_1\n        C[j, 0] = np.exp(-k_elim * U[j]) - np.exp(-k[0] * U[j])\n        \n    # Solve the least squares problem\n    solution, residuals, _, _ = np.linalg.lstsq(C, y, rcond=None)\n    \n    a1_fit = solution[0]\n    a2_fit = 1.0 - a1_fit\n    \n    # The problem asks for the norm of the final residual vector r_j,\n    # which is sqrt of the value returned by lstsq if it's not empty.\n    res_norm = np.sqrt(residuals[0]) if residuals.size > 0 else 0.0\n\n    return a1_fit, a2_fit, res_norm\n\ndef solve_multi_temp():\n    \"\"\"\n    Helper function for multi-temperature WSGG fit (Case 3).\n    \"\"\"\n    k = np.array([0.2, 2.0, 15.0])\n    T = np.array([800.0, 1200.0, 1800.0])\n    U = np.array([0.05, 0.2, 1.0, 3.0])\n    \n    T0, delta_T = 1200.0, 600.0\n    theta = (T - T0) / delta_T\n\n    # True model parameters for data generation\n    def a1_star_func(th): return 0.25 + 0.05 * th\n    def a2_star_func(th): return 0.55 - 0.10 * th\n    def a3_star_func(th): return 1.0 - a1_star_func(th) - a2_star_func(th)\n\n    # Generate reference data\n    U_grid, T_grid = np.meshgrid(U, T)\n    theta_grid = (T_grid - T0) / delta_T\n\n    a1_star = a1_star_func(theta_grid)\n    a2_star = a2_star_func(theta_grid)\n    a3_star = a3_star_func(theta_grid)\n    \n    eps_ref_grid = a1_star * (1-np.exp(-k[0]*U_grid)) + \\\n                   a2_star * (1-np.exp(-k[1]*U_grid)) + \\\n                   a3_star * (1-np.exp(-k[2]*U_grid))\n                   \n    # Flatten data for least squares\n    eps_ref_flat = eps_ref_grid.flatten()\n    U_flat = U_grid.flatten()\n    theta_flat = theta_grid.flatten()\n    \n    M = len(eps_ref_flat) # Total number of data points (12)\n    num_coeffs = 4 # b10, b11, b20, b21\n    \n    C = np.zeros((M, num_coeffs))\n    y = np.zeros(M)\n    \n    k_elim = k[2]\n\n    for p in range(M):\n        U_p, th_p = U_flat[p], theta_flat[p]\n        y[p] = eps_ref_flat[p] - (1.0 - np.exp(-k_elim * U_p))\n        \n        term1 = np.exp(-k_elim * U_p) - np.exp(-k[0] * U_p)\n        term2 = np.exp(-k_elim * U_p) - np.exp(-k[1] * U_p)\n        \n        # Columns for b10, b11, b20, b21\n        C[p, 0] = term1\n        C[p, 1] = th_p * term1\n        C[p, 2] = term2\n        C[p, 3] = th_p * term2\n\n    # Solve the least squares problem\n    solution, residuals, _, _ = np.linalg.lstsq(C, y, rcond=None)\n    b10, b11, b20, b21 = solution\n    \n    # Calculate fitted weights at specified temperatures\n    fitted_weights = []\n    for th_val in theta:\n        a1 = b10 + b11 * th_val\n        a2 = b20 + b21 * th_val\n        a3 = 1.0 - a1 - a2\n        fitted_weights.extend([a1, a2, a3])\n        \n    res_norm = np.sqrt(residuals[0]) if residuals.size > 0 else 0.0\n\n    return fitted_weights, res_norm\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}