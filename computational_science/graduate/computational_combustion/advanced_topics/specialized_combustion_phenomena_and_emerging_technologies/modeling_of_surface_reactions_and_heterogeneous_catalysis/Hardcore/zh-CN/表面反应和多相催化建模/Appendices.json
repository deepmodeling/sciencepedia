{
    "hands_on_practices": [
        {
            "introduction": "现代催化研究通常始于使用密度泛函理论（DFT）等第一性原理方法来计算反应路径。然而，为表面机理中的每一个基元步骤计算活化能（$E_a$）成本高昂，因此发展预测关系至关重要。本练习将指导您应用 Brønsted–Evans–Polanyi (BEP) 关系，这是一种将活化能与反应能（$\\Delta E$）相关联的强大线性模型，并学习如何利用加权最小二乘法进行稳健的参数拟合及量化预测不确定性 ()。",
            "id": "4042389",
            "problem": "考虑一系列与计算燃烧相关的基元催化表面反应。对于每个反应步骤，密度泛函理论（DFT）给出了以电子伏特（eV）为单位的反应能 $\\Delta E$，并为一部分步骤给出了以 eV 为单位的活化能 $E_a$。Brønsted–Evans–Polanyi（BEP）相关性通常将相似反应类别的活化能与反应能联系起来。从过渡态理论（TST）出发（其中速率常数由 $k = \\nu \\exp(-E_a/(k_B T))$ 给出，$k_B$ 为玻尔兹曼常数，$T$ 为绝对温度），并借鉴哈蒙德假说（该假说表明过渡态根据放热性接近反应物或产物），开发一个基于统计原理的线性估计器。该估计器使用已知 $E_a$ 的训练对将 $\\Delta E$ 映射到 $E_a$，然后应用它来预测那些缺少 $E_a$ 的步骤的 $E_a$ 值。假设测量的活化能误差呈高斯分布，且标准差已知；并通过一阶不确定性传播来考虑预测输入 $\\Delta E$ 的不确定性。\n\n任务：\n1. 从测量活化能的高斯噪声模型出发，推导用于将反应能线性映射到活化能的两个未知参数的估计器。使用由反应能构建的设计矩阵、一个对角权重矩阵和活化能向量来表示你的估计器。推导参数估计的协方差矩阵，以及一个基于约化卡方值的膨胀规则，以解释潜在的模型差异。\n2. 对于一个新的具有相关标准差的反应能，通过使用一阶 delta 方法传播参数不确定性和输入不确定性（变量误差），推导平均预测活化能及其一倍标准差不确定性。\n3. 在一个程序中实现该估计器和预测不确定性。对于下方的每个测试案例，该程序应在提供的训练集上拟合线性映射，并输出拟合的参数和预测结果。\n\n定义：\n- Brønsted–Evans–Polanyi (BEP) 关系：在给定表面上的一系列同系反应中，活化能与反应能之间的经验性线性相关关系。\n- 过渡态理论 (TST)：一种通过 $k = \\nu \\exp(-E_a/(k_B T))$ 将反应速率与活化自由能联系起来的理论。\n\n所有能量必须以 eV 为单位进行处理和报告。最终的程序输出必须是单行，包含所有测试案例的结果列表。每个结果由拟合的斜率和截距，后跟预测的活化能列表及其一倍标准差不确定性列表组成，所有值均以 eV 为单位。确切的最终输出格式必须是：\n- 打印为单个 Python 列表的一行，其中每个测试案例的结果是一个形式为 $[\\alpha, \\beta, [\\mu_1, \\mu_2, \\ldots], [\\sigma_1, \\sigma_2, \\ldots]]$ 的列表，其中 $\\alpha$ 和 $\\beta$ 是拟合参数，$\\mu_j$ 是第 $j$ 个缺失步骤的预测活化能，$\\sigma_j$ 是其不确定性。\n- 不会出现角度。\n- 不应打印百分比；一倍标准差不确定性是以 eV 为单位的浮点数。\n\n测试套件：\n- 案例 A（一般情况）：训练数据 $(\\Delta E_i, E_{a,i}, \\sigma_{y,i})$，其中\n  $\\Delta E$ 值为 $[-0.45, 0.10, 0.35, 0.80, 1.20, -0.10, 0.55, 0.95]$ eV，\n  $E_a$ 值为 $[0.62, 0.55, 0.60, 0.78, 0.92, 0.50, 0.72, 0.86]$ eV，\n  $\\sigma_y$ 值为 $[0.05, 0.04, 0.04, 0.05, 0.06, 0.04, 0.05, 0.05]$ eV。\n  预测 $\\Delta E^* = [0.00, 0.40, 1.00]$ eV 的情况，每个的 $\\sigma_x = 0.02$ eV。\n- 案例 B（接近热中性时的边界情况）：训练数据\n  $\\Delta E = [-0.80, -0.30, 0.00, 0.20, 0.50]$ eV，\n  $E_a = [0.70, 0.58, 0.56, 0.60, 0.68]$ eV，\n  $\\sigma_y = [0.07, 0.05, 0.04, 0.05, 0.06]$ eV。\n  预测 $\\Delta E^* = [0.00, -0.05, 0.05]$ eV 的情况，每个的 $\\sigma_x = 0.01$ eV。\n- 案例 C（训练数据最少的边缘情况）：训练数据\n  $\\Delta E = [0.20, 0.90]$ eV，\n  $E_a = [0.60, 0.85]$ eV，\n  $\\sigma_y = [0.08, 0.08]$ eV。\n  预测 $\\Delta E^* = [-0.10, 0.50, 1.20]$ eV 的情况，每个的 $\\sigma_x = 0.03$ eV。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表，例如 $[[\\alpha,\\beta,[\\mu_1,\\ldots],[\\sigma_1,\\ldots]], \\ldots]$，所有数值条目均以 eV 给出。浮点数必须使用标准十进制表示法打印。",
            "solution": "该问题要求开发并实现一种基于统计原理的方法，用于估计线性 Brønsted–Evans–Polanyi (BEP) 关系的参数，并以量化的不确定性预测新的活化能。我们将首先基于加权最小二乘法和一阶不确定性传播推导必要的统计框架，然后实现该框架以解决所提供的测试案例。\n\n### 1. 线性模型的参数估计\n\nBEP 关系假定活化能 $E_a$ 和反应能 $\\Delta E$ 之间存在线性关系。对于一组包含 $N$ 个训练反应的集合，该关系可建模为：\n$$\nE_{a,i} = \\alpha \\Delta E_i + \\beta + \\epsilon_i \\quad \\text{for } i = 1, \\ldots, N\n$$\n其中 $(\\alpha, \\beta)$ 是未知的线性参数（斜率和截距），$\\epsilon_i$ 代表第 $i$ 个观测的误差项。问题陈述指出，测量的活化能（我们记为 $y_i \\equiv E_{a,i}$）服从具有已知标准差 $\\sigma_{y,i}$ 的高斯分布误差。我们假设训练集的反应能（记为 $x_i \\equiv \\Delta E_i$）是精确已知的。因此，误差项 $\\epsilon_i$ 是独立的随机变量，满足 $\\epsilon_i \\sim \\mathcal{N}(0, \\sigma_{y,i}^2)$。\n\n该框架导出一个加权最小二乘（WLS）问题。最优参数 $(\\hat{\\alpha}, \\hat{\\beta})$ 是使加权残差平方和（也称为卡方（$\\chi^2$）统计量）最小化的参数：\n$$\n\\chi^2(\\alpha, \\beta) = \\sum_{i=1}^{N} \\left(\\frac{y_i - (\\alpha x_i + \\beta)}{\\sigma_{y,i}}\\right)^2\n$$\n在高斯误差模型下，最小化 $\\chi^2$ 等价于最大化数据的似然。为规范化解法，我们使用矩阵表示法。设参数向量为 $\\mathbf{\\theta} = [\\alpha, \\beta]^T$。模型可写为 $\\mathbf{y} \\approx \\mathbf{X}\\mathbf{\\theta}$，其中：\n- $\\mathbf{y} = [y_1, y_2, \\ldots, y_N]^T$ 是观测到的活化能向量。\n- $\\mathbf{X}$ 是 $N \\times 2$ 的设计矩阵：\n$$\n\\mathbf{X} = \\begin{pmatrix}\nx_1  1 \\\\\nx_2  1 \\\\\n\\vdots  \\vdots \\\\\nx_N  1\n\\end{pmatrix}\n$$\n$\\chi^2$ 统计量则为：\n$$\n\\chi^2(\\mathbf{\\theta}) = (\\mathbf{y} - \\mathbf{X}\\mathbf{\\theta})^T \\mathbf{W} (\\mathbf{y} - \\mathbf{X}\\mathbf{\\theta})\n$$\n其中 $\\mathbf{W}$ 是对角权重矩阵，其元素为 $W_{ii} = 1/\\sigma_{y,i}^2$。\n\n为找到最小化 $\\chi^2$ 的估计器 $\\hat{\\mathbf{\\theta}}$，我们将关于 $\\mathbf{\\theta}$ 的梯度设为零：\n$$\n\\frac{\\partial \\chi^2}{\\partial \\mathbf{\\theta}} = -2\\mathbf{X}^T \\mathbf{W} (\\mathbf{y} - \\mathbf{X}\\hat{\\mathbf{\\theta}}) = \\mathbf{0}\n$$\n这就得到了 WLS 的正规方程组：\n$$\n(\\mathbf{X}^T \\mathbf{W} \\mathbf{X}) \\hat{\\mathbf{\\theta}} = \\mathbf{X}^T \\mathbf{W} \\mathbf{y}\n$$\n假设矩阵 $(\\mathbf{X}^T \\mathbf{W} \\mathbf{X})$ 可逆（这要求至少有两个不同的 $x_i$ 值），则参数的估计器为：\n$$\n\\hat{\\mathbf{\\theta}} = (\\mathbf{X}^T \\mathbf{W} \\mathbf{X})^{-1} (\\mathbf{X}^T \\mathbf{W} \\mathbf{y})\n$$\n\n### 2. 参数估计的协方差与模型差异\n\n估计参数 $\\hat{\\mathbf{\\theta}}$ 的不确定性源于输入测量值 $\\mathbf{y}$ 的不确定性。$\\mathbf{y}$ 的协方差矩阵为 $\\mathbf{C}_y = \\mathbf{W}^{-1} = \\text{diag}(\\sigma_{y,1}^2, \\ldots, \\sigma_{y,N}^2)$。通过线性估计器方程传播此不确定性，得到参数的协方差矩阵 $\\mathbf{C}_{\\theta}$：\n$$\n\\mathbf{C}_{\\theta} = \\text{Cov}(\\hat{\\mathbf{\\theta}}) = ((\\mathbf{X}^T \\mathbf{W} \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{W}) \\mathbf{C}_y ((\\mathbf{X}^T \\mathbf{W} \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{W})^T\n$$\n代入 $\\mathbf{C}_y = \\mathbf{W}^{-1}$ 并注意到 $\\mathbf{W}$ 是对称的，可简化为：\n$$\n\\mathbf{C}_{\\theta} = (\\mathbf{X}^T \\mathbf{W} \\mathbf{X})^{-1}\n$$\n$\\mathbf{C}_{\\theta}$ 的对角元素是参数的方差 $\\sigma_\\alpha^2$ 和 $\\sigma_\\beta^2$，非对角元素是它们的协方差 $\\text{Cov}(\\alpha, \\beta)$。\n\n在 $\\hat{\\mathbf{\\theta}}$ 处的 $\\chi^2$ 最小值，记为 $\\chi^2_{\\text{min}}$，可作为拟合优度度量。约化卡方 $\\chi^2_{\\text{red}} = \\chi^2_{\\text{min}} / \\nu$（其中 $\\nu = N - p$ 是自由度，$N$ 个数据点，$p=2$ 个参数）在模型正确且误差估计 $\\sigma_{y,i}$ 准确的情况下，预期值约为 1。$\\chi^2_{\\text{red}} > 1$ 的值表明模型对数据的表征不佳，或者测量误差被低估。一种常见的做法是将参数协方差矩阵乘以该因子，以解释观测到的额外散布：\n$$\n\\mathbf{C}_{\\theta}^{\\text{inflated}} = S^2 \\cdot \\mathbf{C}_{\\theta} \\quad \\text{where} \\quad S^2 = \\max(1, \\chi^2_{\\text{red}})\n$$\n该膨胀规则确保了参数的不确定性反映了数据围绕拟合模型的实际散布情况，而不仅仅是报告的测量误差。在 $N=p$ 的特殊情况下（例如，用两个点拟合一条直线），$\\nu=0$ 且拟合是完美的，因此 $\\chi^2_{\\text{min}}=0$。分数 $\\chi^2_{\\text{red}}$ 变为 $0/0$。在这种情况下，我们没有信息来评估模型差异，因此按照惯例取 $S^2=1$。\n\n### 3. 新数据的预测与不确定性\n\n给定一个新的反应能 $\\Delta E^* \\equiv x^*$ 及其相关的不确定性 $\\sigma_x$，我们希望预测相应的活化能 $E_a^*$ 及其不确定性。\n\n平均预测活化能 $\\mu$ 通过在 $x^*$ 处简单地评估拟合的线性模型来获得：\n$$\n\\mu = \\hat{\\alpha} x^* + \\hat{\\beta} = [x^*, 1] \\hat{\\mathbf{\\theta}} = \\mathbf{x}^{*T} \\hat{\\mathbf{\\theta}}\n$$\n其中 $\\mathbf{x}^* = [x^*, 1]^T$。\n\n该预测的不确定性来自两个独立的来源：（1）拟合参数 $\\hat{\\mathbf{\\theta}}$ 的不确定性，以及（2）输入值 $x^*$ 的不确定性。我们使用一阶泰勒展开（delta 方法）来传播这些不确定性。预测的方差 $\\sigma_\\mu^2$ 由下式给出：\n$$\n\\sigma_\\mu^2 \\approx \\nabla f^T \\mathbf{C} \\nabla f\n$$\n其中 $f$ 是预测函数 $f(x^*, \\alpha, \\beta) = \\alpha x^* + \\beta$，$\\nabla f$ 是 $f$ 相对于其随机变量的梯度，$\\mathbf{C}$ 是它们的协方差矩阵。\n\n总方差 $\\sigma_{\\mu}^2$ 是参数不确定性和输入不确定性引起的方差之和：\n$$\n\\sigma_{\\mu}^2 = \\sigma_{\\text{param}}^2 + \\sigma_{\\text{input}}^2\n$$\n\n1.  **参数不确定性贡献**：由 $\\hat{\\mathbf{\\theta}}$ 的不确定性引起的方差为：\n    $$\n    \\sigma_{\\text{param}}^2 = \\mathbf{x}^{*T} \\mathbf{C}_{\\theta}^{\\text{inflated}} \\mathbf{x}^*\n    $$\n\n2.  **输入不确定性贡献（变量误差）**：由 $x^*$ 的不确定性引起的方差为：\n    $$\n    \\sigma_{\\text{input}}^2 = \\left(\\frac{\\partial f}{\\partial x^*}\\right)^2 \\sigma_x^2 = \\hat{\\alpha}^2 \\sigma_x^2\n    $$\n\n结合这些，预测的总方差为：\n$$\n\\sigma_{\\mu}^2 = \\mathbf{x}^{*T} \\mathbf{C}_{\\theta}^{\\text{inflated}} \\mathbf{x}^* + \\hat{\\alpha}^2 \\sigma_x^2\n$$\n预测的最终一倍标准差不确定性为 $\\sigma_{\\mu} = \\sqrt{\\sigma_{\\mu}^2}$。\n\n这就完成了所需估计器及其相关预测不确定性的推导。现在将实现该算法以解决给定的测试案例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef process_case(train_DE, train_Ea, train_sigma_y, pred_DE, pred_sigma_x):\n    \"\"\"\n    Fits a linear BEP model using weighted least squares and predicts Ea values.\n\n    Args:\n        train_DE (list): Training reaction energies (x-values).\n        train_Ea (list): Training activation barriers (y-values).\n        train_sigma_y (list): Standard deviations of training activation barriers.\n        pred_DE (list): Reaction energies for which to predict Ea.\n        pred_sigma_x (float or list): Standard deviation(s) of prediction reaction energies.\n\n    Returns:\n        tuple: (alpha, beta, mu_list, sigma_list)\n               - alpha (float): Fitted slope.\n               - beta (float): Fitted intercept.\n               - mu_list (list): Predicted mean activation barriers.\n               - sigma_list (list): Predicted one-sigma uncertainties.\n    \"\"\"\n    # Convert inputs to numpy arrays for vectorized operations\n    x = np.array(train_DE)\n    y = np.array(train_Ea)\n    sigma_y = np.array(train_sigma_y)\n    \n    # --- 1. Parameter Estimation via Weighted Least Squares ---\n    \n    # Number of training points\n    N = len(x)\n    \n    # Design matrix X\n    X = np.vstack((x, np.ones(N))).T\n    \n    # Weight matrix W (diagonal with 1/sigma_y^2)\n    W = np.diag(1.0 / sigma_y**2)\n    \n    # Calculate (X^T * W * X)\n    X_T_W = X.T @ W\n    X_T_W_X = X_T_W @ X\n    \n    # Inverse of (X^T * W * X)\n    try:\n        X_T_W_X_inv = np.linalg.inv(X_T_W_X)\n    except np.linalg.LinAlgError:\n        # This would happen if X is not full rank (e.g., all x are the same)\n        # Not expected for the given test cases\n        return float('nan'), float('nan'), [], []\n\n    # Calculate (X^T * W * y)\n    X_T_W_y = X_T_W @ y\n    \n    # Estimate parameters theta_hat = [alpha, beta]\n    theta_hat = X_T_W_X_inv @ X_T_W_y\n    alpha, beta = theta_hat[0], theta_hat[1]\n    \n    # --- 2. Covariance and Model Discrepancy ---\n\n    # Basic parameter covariance matrix\n    C_theta = X_T_W_X_inv\n    \n    # Calculate reduced chi-squared and inflation factor S^2\n    p = 2  # number of parameters (alpha, beta)\n    dof = N - p\n    \n    if dof > 0:\n        residuals = y - (alpha * x + beta)\n        chi_squared_min = np.sum((residuals / sigma_y)**2)\n        chi_squared_red = chi_squared_min / dof\n        inflation_factor_sq = max(1.0, chi_squared_red)\n    else:\n        # For N=p, dof=0. No information to assess goodness of fit.\n        # By convention, assume no model discrepancy, so inflation factor is 1.\n        inflation_factor_sq = 1.0\n\n    # Inflated covariance matrix\n    C_theta_inflated = inflation_factor_sq * C_theta\n    \n    # --- 3. Prediction and Uncertainty Propagation ---\n    \n    pred_x = np.array(pred_DE)\n    if isinstance(pred_sigma_x, (int, float)):\n        pred_sx = np.full_like(pred_x, pred_sigma_x)\n    else:\n        pred_sx = np.array(pred_sigma_x)\n\n    mu_list = []\n    sigma_list = []\n    \n    for x_star, sigma_x in zip(pred_x, pred_sx):\n        # Mean prediction\n        mu = alpha * x_star + beta\n        mu_list.append(mu)\n        \n        # Prediction vector\n        x_star_vec = np.array([x_star, 1.0])\n        \n        # Variance from parameter uncertainty\n        var_param = x_star_vec.T @ C_theta_inflated @ x_star_vec\n        \n        # Variance from input uncertainty\n        var_input = (alpha**2) * (sigma_x**2)\n        \n        # Total variance and standard deviation\n        total_var = var_param + var_input\n        sigma = np.sqrt(total_var)\n        sigma_list.append(sigma)\n        \n    return alpha, beta, mu_list, sigma_list\n    \ndef solve():\n    \"\"\"\n    Defines and runs the test cases, then prints the final result.\n    \"\"\"\n    test_cases = [\n        {\n            \"train_DE\": [-0.45, 0.10, 0.35, 0.80, 1.20, -0.10, 0.55, 0.95],\n            \"train_Ea\": [0.62, 0.55, 0.60, 0.78, 0.92, 0.50, 0.72, 0.86],\n            \"train_sigma_y\": [0.05, 0.04, 0.04, 0.05, 0.06, 0.04, 0.05, 0.05],\n            \"pred_DE\": [0.00, 0.40, 1.00],\n            \"pred_sigma_x\": 0.02,\n        },\n        {\n            \"train_DE\": [-0.80, -0.30, 0.00, 0.20, 0.50],\n            \"train_Ea\": [0.70, 0.58, 0.56, 0.60, 0.68],\n            \"train_sigma_y\": [0.07, 0.05, 0.04, 0.05, 0.06],\n            \"pred_DE\": [0.00, -0.05, 0.05],\n            \"pred_sigma_x\": 0.01,\n        },\n        {\n            \"train_DE\": [0.20, 0.90],\n            \"train_Ea\": [0.60, 0.85],\n            \"train_sigma_y\": [0.08, 0.08],\n            \"pred_DE\": [-0.10, 0.50, 1.20],\n            \"pred_sigma_x\": 0.03,\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, beta, mu_list, sigma_list = process_case(\n            case[\"train_DE\"],\n            case[\"train_Ea\"],\n            case[\"train_sigma_y\"],\n            case[\"pred_DE\"],\n            case[\"pred_sigma_x\"]\n        )\n        \n        # Format the result for the current case as required\n        case_result = [alpha, beta, mu_list, sigma_list]\n        results.append(case_result)\n\n    # Convert the list of results to the required string format\n    # The default str() on a list provides the correct '[...]' formatting.\n    # Joining these with ',' and enclosing in '[]' gives the final output.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    \n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在通过计算构建动力学模型后，将其与实验测量结果进行验证和校准是至关重要的一步。程序升温解吸（TPD）是表面科学中用于测定表面物种吸附强度的基本实验技术。本练习将带您深入分析 TPD 谱图，通过从 Polanyi–Wigner 方程出发，推导出从峰值解吸温度（$T_p$）等实验可观测量中提取解吸活化能（$E_{\\text{des}}$）的数学关系 ()。",
            "id": "4042357",
            "problem": "在铂表面上进行了一项与计算燃烧学相关的催化一氧化碳解吸实验，该实验采用程序升温解吸（TPD）技术，其中温度随时间线性升高。假设解吸动力学为一级，无再吸附，且吸附物之间的横向相互作用可忽略不计。解吸速率遵循 Polanyi–Wigner 形式，且解吸活化能垒与覆盖度无关。\n\n给定以下 TPD 可观测量和动力学指前因子：峰值温度 $T_{\\text{p}} = 540\\,\\mathrm{K}$，恒定升温速率 $\\beta = 2.0\\,\\mathrm{K\\,s^{-1}}$，以及与温度无关的指前因子（尝试频率）$\\nu = 1.0\\times 10^{13}\\,\\mathrm{s^{-1}}$。请从第一性原理出发，推导解吸活化能 $E_{\\text{des}}$ 关于 $T_{\\text{p}}$、$\\beta$ 和 $\\nu$ 的闭合形式解析表达式，并对其进行数值计算。使用通用气体常数 $R = 8.314462618\\,\\mathrm{J\\,mol^{-1}\\,K^{-1}}$。将最终能量以 $\\mathrm{kJ\\,mol^{-1}}$ 为单位表示，并四舍五入至四位有效数字。",
            "solution": "用户希望我扮演一位严谨的 STEM 教授，来解决一个关于程序升温解吸（TPD）的问题。第一步是验证问题陈述的有效性。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- **物理系统：** 从铂表面解吸一氧化碳。\n- **实验：** 程序升温解吸（TPD）。\n- **升温程序：** 线性升温，恒定升温速率 $\\beta = 2.0\\,\\mathrm{K\\,s^{-1}}$。\n- **动力学模型：** 一级解吸动力学（$n=1$），由 Polanyi–Wigner 方程描述。\n- **假设：** 无再吸附，吸附物之间的横向相互作用可忽略，解吸活化能 $E_{\\text{des}}$ 和指前因子 $\\nu$ 与覆盖度无关。\n- **可观测量：** 峰值解吸温度 $T_{\\text{p}} = 540\\,\\mathrm{K}$。\n- **常数：** 指前因子 $\\nu = 1.0\\times 10^{13}\\,\\mathrm{s^{-1}}$，通用气体常数 $R = 8.314462618\\,\\mathrm{J\\,mol^{-1}\\,K^{-1}}$。\n- **任务：**\n    1. 从第一性原理出发，推导解吸活化能 $E_{\\text{des}}$ 的闭合形式解析表达式。\n    2. 对 $E_{\\text{des}}$ 进行数值计算，结果以 $\\mathrm{kJ\\,mol^{-1}}$ 为单位表示，并四舍五入至四位有效数字。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据：** 该问题描述了一个标准的表面科学实验（TPD），并基于化学动力学和多相催化的基本原理。Polanyi-Wigner 方程是 TPD 分析的基石。所提供的值对于 CO/Pt 系统是物理上合理的。该问题在科学上是成立的。\n- **适定性：** 问题定义清晰，提供了所有必要信息，可以在给定参数与未知量 $E_{\\text{des}}$ 之间建立唯一的关系。推导过程会得出一个特定的解析表达式，其值可以被唯一确定。\n- **客观性：** 问题使用精确、标准的科学术语进行表述。没有歧义、主观性或偏见。\n\n**步骤 3：结论与行动**\n该问题是有效的，因为它具有科学依据、适定性和客观性，并且不包含内部矛盾或缺失信息。可以开始求解过程。\n\n### 求解过程\n\n解吸过程由 Polanyi–Wigner 方程描述，该方程给出了表面覆盖度 $\\theta$ 随时间 $t$ 的变化率：\n$$ r_{\\text{des}} = -\\frac{d\\theta}{dt} = \\nu \\theta^n \\exp\\left(-\\frac{E_{\\text{des}}}{RT}\\right) $$\n其中，$n$ 是解吸反应的级数，$\\nu$ 是指前因子，$E_{\\text{des}}$ 是解吸活化能，$R$ 是通用气体常数，$T$ 是绝对温度。\n\n问题陈述指明解吸为一级过程，因此我们设 $n=1$：\n$$ -\\frac{d\\theta}{dt} = \\nu \\theta \\exp\\left(-\\frac{E_{\\text{des}}}{RT}\\right) $$\n在 TPD 实验中，温度随时间线性升高，$T(t) = T_0 + \\beta t$，其中 $\\beta$ 是恒定的升温速率。这意味着 $\\frac{dT}{dt} = \\beta$，或 $dt = \\frac{dT}{\\beta}$。\n\n在 TPD 谱中测量的量是解吸速率，它在峰值温度 $T_{\\text{p}}$ 时达到最大值。为找到此最大值，我们必须将速率对时间（或温度）的导数设为零。让我们对速率方程求时间 $t$ 的导数：\n$$ \\frac{d}{dt}\\left(-\\frac{d\\theta}{dt}\\right) = \\frac{d}{dt}\\left[\\nu \\theta \\exp\\left(-\\frac{E_{\\text{des}}}{RT}\\right)\\right] = 0 \\quad \\text{at} \\quad T = T_{\\text{p}} $$\n对右侧应用乘积法则，得到：\n$$ \\nu \\left[ \\frac{d\\theta}{dt} \\exp\\left(-\\frac{E_{\\text{des}}}{RT}\\right) + \\theta \\frac{d}{dt}\\left(\\exp\\left(-\\frac{E_{\\text{des}}}{RT}\\right)\\right) \\right]_{T=T_{\\text{p}}} = 0 $$\n我们在峰值温度 $T_{\\text{p}}$ 处计算这些项。\n括号内的第一项包含 $\\frac{d\\theta}{dt}$，我们用速率方程本身代入：\n$$ \\frac{d\\theta}{dt} = -\\nu \\theta \\exp\\left(-\\frac{E_{\\text{des}}}{RT_{\\text{p}}}\\right) $$\n第二项包含指数因子的时间导数，我们使用链式法则对其求值：\n$$ \\frac{d}{dt}\\left(\\exp\\left(-\\frac{E_{\\text{des}}}{RT}\\right)\\right) = \\exp\\left(-\\frac{E_{\\text{des}}}{RT}\\right) \\cdot \\left(\\frac{E_{\\text{des}}}{RT^2}\\right) \\cdot \\frac{dT}{dt} = \\exp\\left(-\\frac{E_{\\text{des}}}{RT}\\right) \\cdot \\frac{E_{\\text{des}}\\beta}{RT^2} $$\n将这些表达式代回到最大速率的条件中（在 $T=T_{\\text{p}}$ 处取值），并除以非零量 $\\nu$：\n$$ \\left[ \\left(-\\nu \\theta \\exp\\left(-\\frac{E_{\\text{des}}}{RT_{\\text{p}}}\\right)\\right) \\exp\\left(-\\frac{E_{\\text{des}}}{RT_{\\text{p}}}\\right) + \\theta \\left(\\exp\\left(-\\frac{E_{\\text{des}}}{RT_{\\text{p}}}\\right) \\frac{E_{\\text{des}}\\beta}{RT_{\\text{p}}^2}\\right) \\right] = 0 $$\n我们可以提出公因式 $\\theta(T_{\\text{p}}) \\exp\\left(-\\frac{E_{\\text{des}}}{RT_{\\text{p}}}\\right)$，它在峰值处非零：\n$$ -\\nu \\exp\\left(-\\frac{E_{\\text{des}}}{RT_{\\text{p}}}\\right) + \\frac{E_{\\text{des}}\\beta}{RT_{\\text{p}}^2} = 0 $$\n重新整理该方程，得到著名的 Redhead 方程，它隐式地将 $E_{\\text{des}}$ 与实验可观测量联系起来：\n$$ \\frac{E_{\\text{des}}}{RT_{\\text{p}}^2} = \\frac{\\nu}{\\beta} \\exp\\left(-\\frac{E_{\\text{des}}}{RT_{\\text{p}}}\\right) $$\n为了找到 $E_{\\text{des}}$ 的闭合形式解析表达式，我们重新整理这个超越方程。令 $x = \\frac{E_{\\text{des}}}{RT_{\\text{p}}}$，方程变为：\n$$ \\frac{x RT_{\\text{p}}}{RT_{\\text{p}}^2} = \\frac{\\nu}{\\beta} \\exp(-x) $$\n$$ \\frac{x}{T_{\\text{p}}} = \\frac{\\nu}{\\beta} \\exp(-x) $$\n两边同乘以 $T_{\\text{p}} \\exp(x)$，得到：\n$$ x \\exp(x) = \\frac{\\nu T_{\\text{p}}}{\\beta} $$\n这个方程是 $z \\exp(z) = y$ 的标准形式，其中 $z$ 的解由 Lambert W 函数给出，$z = W(y)$。在我们的例子中，$z=x$ 且 $y = \\frac{\\nu T_{\\text{p}}}{\\beta}$。\n因此，$x$ 的解是：\n$$ x = W\\left(\\frac{\\nu T_{\\text{p}}}{\\beta}\\right) $$\n代回 $x = \\frac{E_{\\text{des}}}{RT_{\\text{p}}}$，我们得到解吸活化能的闭合形式解析表达式：\n$$ E_{\\text{des}} = RT_{\\text{p}} W\\left(\\frac{\\nu T_{\\text{p}}}{\\beta}\\right) $$\n现在，我们使用给定值对该表达式进行数值计算：\n$T_{\\text{p}} = 540\\,\\mathrm{K}$\n$\\beta = 2.0\\,\\mathrm{K\\,s^{-1}}$\n$\\nu = 1.0\\times 10^{13}\\,\\mathrm{s^{-1}}$\n$R = 8.314462618\\,\\mathrm{J\\,mol^{-1}\\,K^{-1}}$\n\n首先，我们计算 Lambert W 函数的自变量：\n$$ \\frac{\\nu T_{\\text{p}}}{\\beta} = \\frac{(1.0 \\times 10^{13}\\,\\mathrm{s^{-1}}) \\times (540\\,\\mathrm{K})}{2.0\\,\\mathrm{K\\,s^{-1}}} = 2.7 \\times 10^{15} $$\n接下来，我们计算该自变量对应的 Lambert W 函数值。对于大的自变量 $y$，$W(y) \\approx \\ln(y) - \\ln(\\ln(y))$。\n$$ W(2.7 \\times 10^{15}) \\approx 32.064299 $$\n现在，我们将此值代回 $E_{\\text{des}}$ 的表达式中：\n$$ E_{\\text{des}} = (8.314462618\\,\\mathrm{J\\,mol^{-1}\\,K^{-1}}) \\times (540\\,\\mathrm{K}) \\times (32.064299) $$\n$$ E_{\\text{des}} \\approx 143969.8\\,\\mathrm{J\\,mol^{-1}} $$\n问题要求答案以 $\\mathrm{kJ\\,mol^{-1}}$ 为单位，并四舍五入至四位有效数字。\n$$ E_{\\text{des}} = 143.9698\\,\\mathrm{kJ\\,mol^{-1}} $$\n四舍五入至四位有效数字，得到：\n$$ E_{\\text{des}} = 144.0\\,\\mathrm{kJ\\,mol^{-1}} $$",
            "answer": "$$\n\\boxed{144.0}\n$$"
        },
        {
            "introduction": "一旦获得了可靠的表面反应动力学模型，我们就可以将其用于预测和理解宏观反应器系统的复杂行为。催化系统常常表现出非线性现象，如稳态多重性和自持振荡，这对反应器设计与安全至关重要。本练习介绍了一种先进的数值方法——伪弧长连续法（Pseudo-Arclength Continuation），用于追踪反应器稳态解的分支，并结合雅可比矩阵分析来检测导致振荡行为的 Hopf 分岔点 ()。",
            "id": "4042372",
            "problem": "你的任务是为与计算燃烧学、表面反应和多相催化相关的简化催化壁反应器模型，构建并实现一种数值延拓与稳定性检测方法。从基本守恒定律和经过充分检验的原理出发：一个近壁控制体，其中有一种反应物进行一级放热表面反应。气相反应物浓度和壁面温度由两个耦合的常微分方程（ODEs）建模，这些方程源自质量和能量平衡，考虑了与主体和热浴的线性交换，以及一个阿伦尼乌斯型表面反应。状态向量为 $x = [c, T]$，其中 $c$ 是经入口值归一化的无量纲近壁反应物浓度，$T$ 是经热浴温度归一化的无量纲壁面温度。控制参数是丹姆科勒数（Da），记作 $D_a$，代表特征反应时间尺度与输运时间尺度的比值。活化参数为 $\\beta > 0$，放热参数为 $\\gamma > 0$。质量和热量交换的时间尺度分别为 $\\tau_m > 0$ 和 $\\tau_h > 0$。无量纲动力系统为：\n$$\n\\frac{dc}{dt} = \\frac{1 - c}{\\tau_m} - D_a \\exp\\!\\left(-\\frac{\\beta}{T}\\right) c,\n$$\n$$\n\\frac{dT}{dt} = \\frac{1 - T}{\\tau_h} + \\gamma D_a \\exp\\!\\left(-\\frac{\\beta}{T}\\right) c.\n$$\n稳态 $(c^\\ast, T^\\ast)$ 满足 $F(x, D_a) = 0$，其中\n$$\nF(x, D_a) =\n\\begin{bmatrix}\n\\frac{1 - c}{\\tau_m} - D_a \\exp\\!\\left(-\\frac{\\beta}{T}\\right) c \\\\\n\\frac{1 - T}{\\tau_h} + \\gamma D_a \\exp\\!\\left(-\\frac{\\beta}{T}\\right) c\n\\end{bmatrix}.\n$$\n线性稳定性由雅可比矩阵 $J(x^\\ast, D_a) = \\left.\\frac{\\partial F}{\\partial x}\\right|_{(x^\\ast, D_a)}$ 决定，其 $2 \\times 2$ 的元素为：\n$$\n\\frac{\\partial f_1}{\\partial c} = -\\frac{1}{\\tau_m} - D_a \\exp\\!\\left(-\\frac{\\beta}{T}\\right), \\quad\n\\frac{\\partial f_1}{\\partial T} = - D_a c \\exp\\!\\left(-\\frac{\\beta}{T}\\right) \\frac{\\beta}{T^2},\n$$\n$$\n\\frac{\\partial f_2}{\\partial c} = \\gamma D_a \\exp\\!\\left(-\\frac{\\beta}{T}\\right), \\quad\n\\frac{\\partial f_2}{\\partial T} = -\\frac{1}{\\tau_h} + \\gamma D_a c \\exp\\!\\left(-\\frac{\\beta}{T}\\right) \\frac{\\beta}{T^2}.\n$$\n当 $J$ 的一对共轭复数特征值穿过虚轴时，检测到霍普夫分岔。对于一个 $2 \\times 2$ 的雅可比矩阵，这可以通过以下条件检测：行列式 $\\det(J) > 0$，在穿越前后判别式 $\\Delta = \\operatorname{tr}(J)^2 - 4 \\det(J) < 0$，并且迹 $\\operatorname{tr}(J)$ 在连续的延拓点之间改变符号。使用这些准则来检测延拓路径上的第一个霍普夫分岔。\n\n实现一个伪弧长延拓（PAC）方案，以追踪当 $D_a$ 变化时稳态解分支 $x^\\ast(D_a)$。你的算法必须：\n- 从 $D_a = 0$ 和稳态 $x^\\ast = [1, 1]$ 开始初始化。\n- 通过求解 $J(x^\\ast, 0) \\frac{dx^\\ast}{d D_a} = - \\frac{\\partial F}{\\partial D_a}(x^\\ast, 0)$ 计算初始切线，其中\n$$\n\\frac{\\partial F}{\\partial D_a}(x, D_a) =\n\\begin{bmatrix}\n- \\exp\\!\\left(-\\frac{\\beta}{T}\\right) c \\\\\n\\gamma \\exp\\!\\left(-\\frac{\\beta}{T}\\right) c\n\\end{bmatrix}.\n$$\n- 使用一个沿切线的预测步，弧长增量为 $\\Delta s$，形成预测点 $(x_{\\text{pred}}, D_{a,\\text{pred}})$。\n- 应用牛顿校正法求解增广系统\n$$\nG(x, D_a) =\n\\begin{bmatrix}\nF(x, D_a) \\\\\nt_x^\\top (x - x_{\\text{prev}}) + t_{D_a} (D_a - D_{a,\\text{prev}}) - \\Delta s\n\\end{bmatrix} = 0,\n$$\n其中 $t = [t_x, t_{D_a}]$ 是前一个切向量，$(x_{\\text{prev}}, D_{a,\\text{prev}})$ 是前一个校正后的解。使用增广雅可比矩阵\n$$\n\\frac{\\partial G}{\\partial (x, D_a)} =\n\\begin{bmatrix}\nJ(x, D_a)  \\frac{\\partial F}{\\partial D_a}(x, D_a) \\\\\nt_x^\\top  t_{D_a}\n\\end{bmatrix}.\n$$\n- 每个校正解之后，通过求解 $J \\frac{dx^\\ast}{d D_a} = - \\frac{\\partial F}{\\partial D_a}$ 重新计算 $\\frac{dx^\\ast}{d D_a}$ 并归一化 $[t_x, t_{D_a}] = \\left[\\frac{dx^\\ast}{d D_a}, 1\\right]$ 来更新切向量。\n- 使用上述条件检测霍普夫分岔；通过在发生符号变化的连续点之间对 $\\operatorname{tr}(J)$ 进行线性插值来近似穿越点 $D_a$，且在这两点判别式均为负。\n\n所有变量和参数都是无量纲的。使用稳健的数值保护措施以避免除以零，例如将任何 $\\exp(-\\beta/T)$ 的计算替换为 $\\exp(-\\beta/\\max(T, \\epsilon))$，其中 $\\epsilon$ 是一个小的正数。校正器使用牛顿容差 $\\varepsilon$ 和最大迭代次数。如果在任何步骤中校正器未能收敛，则终止该测试用例的延拓。\n\n测试套件：\n为以下 $3$ 个参数集运行你的程序，每个参数集以 $(\\tau_m, \\tau_h, \\beta, \\gamma, D_{a,\\max}, \\Delta s, N_{\\text{steps}}, \\varepsilon)$ 的形式给出，其中 $N_{\\text{steps}}$ 是最大延拓步数。对于每个案例，从 $D_a = 0$ 开始，延拓直到 $D_a \\ge D_{a,\\max}$ 或达到 $N_{\\text{steps}}$，并报告检测到的第一个霍普夫分岔点 $D_a$（作为浮点值）。如果没有检测到霍普夫分岔，则对该测试用例输出 $-1.0$。\n- 案例 1：$(0.5, 5.0, 12.0, 8.0, 6.0, 0.02, 400, 10^{-10})$。\n- 案例 2（边缘情况，可能无霍普夫分岔）：$(2.0, 2.0, 8.0, 2.0, 10.0, 0.02, 500, 10^{-10})$。\n- 案例 3（边界情况，更高的活化和放热性）：$(0.1, 10.0, 15.0, 10.0, 3.0, 0.01, 500, 10^{-10})$。\n\n最终输出格式：\n你的程序应生成一行输出，包含 $3$ 个浮点数结果（每个测试用例一个），以逗号分隔并用方括号括起来，例如 $[r_1,r_2,r_3]$。不涉及物理单位；所有输出均为无量纲。",
            "solution": "该问题要求实现一种数值延拓和稳定性分析方法，以追踪一个催化壁反应器模型的稳态解，并检测霍普夫分岔。指定的方法是伪弧长延拓（PAC）方案，结合基于系统雅可比矩阵的线性稳定性分析。该问题被验证为科学上合理、适定，并包含了获得唯一数值解所需的所有信息。\n\n该物理系统由一对耦合常微分方程描述，分别针对无量纲近壁反应物浓度 $c$ 和无量纲壁面温度 $T$。状态向量为 $x = [c, T]^\\top$。系统的演化由以下方程控制：\n$$\n\\frac{d c}{dt} = f_1(c, T, D_a) = \\frac{1 - c}{\\tau_m} - D_a \\exp\\!\\left(-\\frac{\\beta}{T}\\right) c\n$$\n$$\n\\frac{d T}{dt} = f_2(c, T, D_a) = \\frac{1 - T}{\\tau_h} + \\gamma D_a \\exp\\!\\left(-\\frac{\\beta}{T}\\right) c\n$$\n其中 $\\tau_m$ 和 $\\tau_h$ 分别是质量和热量输运的时间尺度，$\\beta$ 是活化参数，$\\gamma$ 是放热参数，$D_a$ 是丹姆科勒数，作为延拓参数。\n\n稳态 $(c^\\ast, T^\\ast)$ 是代数系统 $F(x, D_a) = [f_1, f_2]^\\top = 0$ 的解。任务的核心是在状态-参数空间 $(x, D_a)$ 中追踪解曲线 $x^\\ast(D_a)$。\n\n实现过程如下：\n\n**1. 伪弧长延拓 (PAC)**\n采用 PAC 方法来追踪解分支，包括通过转折点（折叠点），在这些点上以参数 $D_a$ 为自变量的标准延拓会失败。\n\n**1.1. 初始化**\n延拓从一个已知解开始。在 $D_a = 0$ 时，系统简化为 $\\frac{1-c}{\\tau_m} = 0$ 和 $\\frac{1-T}{\\tau_h} = 0$，得到平凡稳态 $x^\\ast = [c^\\ast, T^\\ast] = [1, 1]$。这是我们解分支上的第一个点。\n\n**1.2. 切向量计算**\n解曲线的切向量为预测步提供了方向。它通过对稳态方程 $F(x(D_a), D_a) = 0$ 关于弧长参数 $s$ 求导得到。一个更直接的方法，如问题所述，是计算关于 $D_a$ 的导数。设切向量为 $t = [\\frac{dx^\\ast}{ds}, \\frac{dD_a}{ds}]$。根据链式法则，$\\frac{\\partial F}{\\partial x} \\frac{dx^\\ast}{dD_a} + \\frac{\\partial F}{\\partial D_a} = 0$。这给出了切向量状态空间分量的线性系统：\n$$\nJ(x^\\ast, D_a) \\frac{dx^\\ast}{dD_a} = - \\frac{\\partial F}{\\partial D_a}(x^\\ast, D_a)\n$$\n其中 $J$ 是雅可比矩阵，$\\frac{\\partial F}{\\partial D_a}$ 是系统函数关于参数的偏导数。问题指定将未归一化的切向量构造为 $[\\frac{dx^\\ast}{dD_a}, 1]$，然后将其归一化为单位长度，$t = [t_x, t_{D_a}]$。此过程在远离折叠分岔点时有效。\n所需的偏导数为：\n$$\nJ = \\begin{bmatrix} -\\frac{1}{\\tau_m} - R  -R \\frac{\\beta c}{T^2} \\\n$$1em] \\gamma R  -\\frac{1}{\\tau_h} + \\gamma R \\frac{\\beta c}{T^2} \\end{bmatrix}, \\quad \\frac{\\partial F}{\\partial D_a} = \\begin{bmatrix} -R/D_a \\\n$$1em] \\gamma R/D_a \\end{bmatrix}\n$$\n其中反应速率项为 $R = D_a \\exp(-\\beta/T) c$。在 $(x, D_a) = ([1,1], 0)$ 处的初始切向量使用该系统计算。在指数计算中使用数值保护措施 $T_{\\text{safe}} = \\max(T, \\epsilon)$（对于小的 $\\epsilon>0$），以防止当 $T$ 接近零时发生除零或浮点溢出。\n\n**1.3. 预测-校正步骤**\n延拓是迭代进行的。从一个已知解点 $(x_{\\text{prev}}, D_{a,\\text{prev}})$ 和其切向量 $t$ 出发，预测一个新点然后进行校正。\n\n*   **预测**：沿切线方向进行一个欧拉步，步长为固定的弧长 $\\Delta s$：\n    $$\n    (x_{\\text{pred}}, D_{a,\\text{pred}}) = (x_{\\text{prev}}, D_{a,\\text{prev}}) + \\Delta s \\cdot t\n    $$\n*   **校正**：通过使用牛顿法求解一个增广系统来精化预测点。该系统由原始稳态方程和一个约束条件组成，该约束迫使校正步与切平面正交，从而将解固定在所需弧长处解曲线上的特定点。要求解的校正点 $(x, D_a)$ 的系统是 $G(x, D_a) = 0$：\n    $$\n    G(x, D_a) =\n    \\begin{bmatrix}\n    F(x, D_a) \\\\\n    t_x^\\top (x - x_{\\text{prev}}) + t_{D_a} (D_a - D_{a,\\text{prev}}) - \\Delta s\n    \\end{bmatrix} = 0\n    $$\n    牛顿法迭代求解线性系统 $\\frac{\\partial G}{\\partial (x, D_a)} \\Delta z = -G(z)$ 以获得更新量 $\\Delta z = [\\Delta x, \\Delta D_a]^\\top$，其中增广雅可比矩阵为：\n    $$\n    \\frac{\\partial G}{\\partial (x, D_a)} =\n    \\begin{bmatrix}\n    J(x, D_a)  \\frac{\\partial F}{\\partial D_a}(x, D_a) \\\\\n    t_x^\\top  t_{D_a}\n    \\end{bmatrix}\n    $$\n\n**2. 稳定性分析和霍普夫分岔检测**\n在每个成功的校正步之后，评估新稳态解 $(x^\\ast, D_{a}^\\ast)$ 的稳定性。线性稳定性由雅可比矩阵 $J(x^\\ast, D_{a}^\\ast)$ 的特征值 $\\lambda_{1,2}$ 决定。\n\n对于一个 $2 \\times 2$ 系统，特征值由 $\\lambda_{1,2} = \\frac{\\operatorname{tr}(J) \\pm \\sqrt{\\operatorname{tr}(J)^2 - 4\\det(J)}}{2}$ 给出。当一对共轭复数特征值穿过虚轴时，发生霍普夫分岔。这对应于以下条件：\n1.  特征值的实部改变符号：$\\operatorname{Re}(\\lambda) = \\frac{\\operatorname{tr}(J)}{2}$ 穿过零。这意味着我们必须检测到迹 $\\operatorname{tr}(J)$ 的符号变化。\n2.  特征值在穿越点是复数：判别式必须为负，$\\Delta = \\operatorname{tr}(J)^2 - 4\\det(J) < 0$。由于在分岔点 $\\operatorname{tr}(J) = 0$，这简化为要求 $\\det(J) > 0$。\n\n在数值上，如果在两个连续的延拓点（索引为 $i$ 和 $i+1$）之间满足以下条件，则检测到霍普夫分岔：\n*   $\\operatorname{tr}(J_i) \\cdot \\operatorname{tr}(J_{i+1}) < 0$（符号改变）。\n*   $\\det(J_i) > 0$ 且 $\\det(J_{i+1}) > 0$。\n*   $\\operatorname{tr}(J_i)^2 - 4\\det(J_i) < 0$ 且 $\\operatorname{tr}(J_{i+1})^2 - 4\\det(J_{i+1}) < 0$。\n\n一旦找到包围分岔的一对点，分岔点处的 $D_a$ 值，$D_{a,Hopf}$，通过线性插值估计，即找到连接 $(\\operatorname{tr}(J_i), D_{a,i})$ 和 $(\\operatorname{tr}(J_{i+1}), D_{a,i+1})$ 的线段的根：\n$$\nD_{a,Hopf} = D_{a,i} - \\operatorname{tr}(J_i) \\frac{D_{a,i+1} - D_{a,i}}{\\operatorname{tr}(J_{i+1}) - \\operatorname{tr}(J_i)}\n$$\n报告第一个这样检测到的点。如果延拓完成而未满足这些条件，则未找到霍普夫分岔。对于给定的参数集，当检测到第一个霍普夫点、达到最大步数 $N_{\\text{steps}}$、超过最大参数值 $D_{a,\\max}$ 或牛顿校正器未能收敛时，过程终止。",
            "answer": "```python\nimport numpy as np\n\n# Global constants for numerical stability and convergence\nSAFEGUARD_EPSILON = 1e-12\nNEWTON_MAX_ITER = 20\n\ndef eval_F(x, Da, params):\n    \"\"\"Evaluates the steady-state system function F(x, Da).\"\"\"\n    c, T = x\n    tau_m, tau_h, beta, gamma, _, _, _, _ = params\n    \n    T_safe = np.maximum(T, SAFEGUARD_EPSILON)\n    \n    try:\n        exp_term = np.exp(-beta / T_safe)\n    except FloatingPointError:\n        exp_term = 0.0 # Effectively handles large beta/T\n\n    reaction_term = Da * exp_term * c\n    \n    f1 = (1.0 - c) / tau_m - reaction_term\n    f2 = (1.0 - T) / tau_h + gamma * reaction_term\n    \n    return np.array([f1, f2])\n\ndef eval_Jacobian(x, Da, params):\n    \"\"\"Evaluates the Jacobian matrix J = dF/dx.\"\"\"\n    c, T = x\n    tau_m, tau_h, beta, gamma, _, _, _, _ = params\n    \n    T_safe = np.maximum(T, SAFEGUARD_EPSILON)\n    \n    try:\n        exp_term = np.exp(-beta / T_safe)\n    except FloatingPointError:\n        exp_term = 0.0\n\n    R = Da * exp_term\n    R_prime_T = R * beta / (T_safe**2)\n\n    j11 = -1.0 / tau_m - R\n    j12 = -c * R_prime_T\n    j21 = gamma * R\n    j22 = -1.0 / tau_h + gamma * c * R_prime_T\n    \n    return np.array([[j11, j12], [j21, j22]])\n\ndef eval_F_Da(x, Da, params):\n    \"\"\"Evaluates the partial derivative dF/dDa.\"\"\"\n    c, T = x\n    _, _, beta, gamma, _, _, _, _ = params\n\n    T_safe = np.maximum(T, SAFEGUARD_EPSILON)\n\n    try:\n        exp_term = np.exp(-beta / T_safe)\n    except FloatingPointError:\n        exp_term = 0.0\n\n    f1_Da = -exp_term * c\n    f2_Da = gamma * exp_term * c\n    \n    return np.array([f1_Da, f2_Da])\n\ndef run_continuation(params):\n    \"\"\"\n    Performs pseudo-arclength continuation and Hopf bifurcation detection.\n    \"\"\"\n    _, _, _, _, Da_max, ds, N_steps, newton_tol = params\n    \n    # Initialization\n    x_curr = np.array([1.0, 1.0])\n    Da_curr = 0.0\n    \n    history_x = [x_curr]\n    history_Da = [Da_curr]\n    history_stability = []\n\n    # Initial tangent calculation\n    try:\n        J0 = eval_Jacobian(x_curr, Da_curr, params)\n        F_Da0 = eval_F_Da(x_curr, Da_curr, params)\n        dx_dDa = np.linalg.solve(J0, -F_Da0)\n    except np.linalg.LinAlgError:\n        return -1.0 # Should not happen at Da=0\n\n    # Form and normalize tangent\n    t_unnorm = np.append(dx_dDa, 1.0)\n    t_curr = t_unnorm / np.linalg.norm(t_unnorm)\n\n    # Initial stability\n    tr = np.trace(J0)\n    det = np.linalg.det(J0)\n    history_stability.append({'trace': tr, 'det': det})\n\n    for _ in range(N_steps):\n        # Store previous state for corrector and interpolation\n        x_prev, Da_prev = x_curr, Da_curr\n        t_prev = t_curr\n        \n        # Predictor step\n        x_pred = x_prev + ds * t_prev[:2]\n        Da_pred = Da_prev + ds * t_prev[2]\n\n        # Corrector (Newton's method)\n        x_new, Da_new = x_pred, Da_pred\n        \n        converged = False\n        for _ in range(NEWTON_MAX_ITER):\n            try:\n                # Build augmented system\n                F_val = eval_F(x_new, Da_new, params)\n                N_val = np.dot(t_prev[:2], x_new - x_prev) + t_prev[2] * (Da_new - Da_prev) - ds\n                G = np.append(F_val, N_val)\n\n                if np.linalg.norm(G)  newton_tol:\n                    converged = True\n                    break\n\n                J_new = eval_Jacobian(x_new, Da_new, params)\n                F_Da_new = eval_F_Da(x_new, Da_new, params)\n                \n                aug_J = np.zeros((3, 3))\n                aug_J[:2, :2] = J_new\n                aug_J[:2, 2] = F_Da_new\n                aug_J[2, :2] = t_prev[:2]\n                aug_J[2, 2] = t_prev[2]\n                \n                delta = np.linalg.solve(aug_J, -G)\n                x_new += delta[:2]\n                Da_new += delta[2]\n            except (np.linalg.LinAlgError, FloatingPointError):\n                return -1.0 # Corrector failed\n\n        if not converged:\n            return -1.0 # Corrector failed to converge\n\n        x_curr, Da_curr = x_new, Da_new\n        \n        # Check termination conditions\n        if Da_curr >= Da_max or Da_curr  0: # Stop if Da goes too high or negative\n            break\n\n        # Stability analysis and Hopf detection\n        J_curr = eval_Jacobian(x_curr, Da_curr, params)\n        tr_curr = np.trace(J_curr)\n        det_curr = np.linalg.det(J_curr)\n        \n        prev_stability = history_stability[-1]\n        tr_prev = prev_stability['trace']\n        det_prev = prev_stability['det']\n        \n        # Hopf conditions: tr sign change, det > 0, discriminant  0\n        if tr_curr * tr_prev  0:\n            if det_curr > 0 and det_prev > 0:\n                disc_curr = tr_curr**2 - 4 * det_curr\n                disc_prev = tr_prev**2 - 4 * det_prev\n                if disc_curr  0 and disc_prev  0:\n                    # Linearly interpolate to find Da where trace is zero\n                    Da_hopf = Da_prev - tr_prev * (Da_curr - Da_prev) / (tr_curr - tr_prev)\n                    return Da_hopf\n\n        # Store current state for next iteration\n        history_x.append(x_curr)\n        history_Da.append(Da_curr)\n        history_stability.append({'trace': tr_curr, 'det': det_curr})\n\n        # Update tangent\n        try:\n            dx_dDa = np.linalg.solve(J_curr, -eval_F_Da(x_curr, Da_curr, params))\n            t_unnorm = np.append(dx_dDa, 1.0)\n            \n            # The problem does not specify orientation check, but it's good practice.\n            # However, to be strict, we'll follow the exact wording.\n            t_new = t_unnorm / np.linalg.norm(t_unnorm)\n\n            # Ensure consistent direction of travel along the arc\n            # Check dot product with previous tangent. If it's negative, flip.\n            if np.dot(t_new, t_prev)  0:\n                t_new = -t_new\n\n            t_curr = t_new\n\n        except np.linalg.LinAlgError:\n            # At a turning point, the Jacobian is singular. We can't solve for dx/dDa.\n            # We must find the null space to get the tangent direction.\n            # However, for this problem, simply continuing should be sufficient\n            # as the PAC method handles the turn. We can re-use the old tangent direction\n            # if we are careful, but for this implementation, we will terminate on failure.\n            return -1.0\n\n    return -1.0 # No Hopf bifurcation found\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (tau_m, tau_h, beta, gamma, Da_max, ds, N_steps, newton_tol)\n        (0.5, 5.0, 12.0, 8.0, 6.0, 0.02, 400, 1e-10),\n        (2.0, 2.0, 8.0, 2.0, 10.0, 0.02, 500, 1e-10),\n        (0.1, 10.0, 15.0, 10.0, 3.0, 0.01, 500, 1e-10),\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_continuation(params)\n        results.append(f\"{result:.8f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}