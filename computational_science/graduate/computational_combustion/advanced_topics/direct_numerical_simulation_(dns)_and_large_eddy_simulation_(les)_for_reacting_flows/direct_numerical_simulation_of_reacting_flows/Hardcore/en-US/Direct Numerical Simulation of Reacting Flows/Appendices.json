{
    "hands_on_practices": [
        {
            "introduction": "An accurate Direct Numerical Simulation (DNS) of reacting flow is fundamentally dependent on the precise evaluation of species thermodynamic properties. This exercise focuses on a critical, practical skill: implementing the NASA 7-coefficient polynomials to compute species heat capacity, enthalpy, and entropy. By working through this problem, you will gain hands-on experience with the standard data format used in virtually all combustion codes and learn to verify the continuity of these properties across temperature ranges, a crucial step for ensuring the stability and accuracy of chemical source term calculations .",
            "id": "4019148",
            "problem": "Consider a reacting ideal-gas mixture typically modeled in Direct Numerical Simulation (DNS) of combustion, where species thermodynamic properties must be evaluated accurately and smoothly in temperature to avoid numerical artifacts in source terms. For each species, the National Aeronautics and Space Administration (NASA) seven-coefficient polynomial representation is used over disjoint temperature intervals. Let $T$ denote the absolute temperature in Kelvin, and let $R$ denote the universal gas constant in $\\mathrm{J}\\, \\mathrm{mol}^{-1}\\, \\mathrm{K}^{-1}$. The NASA representation provides, for a given temperature interval, a set of coefficients $\\{a_1,a_2,a_3,a_4,a_5,a_6,a_7\\}$ that must be used to compute the species isobaric heat capacity $c_{p,k}(T)$, enthalpy $h_k(T)$, and entropy $s_k(T)$.\n\nStarting from fundamental thermodynamic definitions and the ideal-gas assumption, derive expressions to compute $c_{p,k}(T)$ in $\\mathrm{J}\\, \\mathrm{mol}^{-1}\\, \\mathrm{K}^{-1}$, $h_k(T)$ in $\\mathrm{J}\\, \\mathrm{mol}^{-1}$, and $s_k(T)$ in $\\mathrm{J}\\, \\mathrm{mol}^{-1}\\, \\mathrm{K}^{-1}$, based on the NASA seven-coefficient polynomial representation over each interval. Then implement a computation over a specified temperature range that uses the low-temperature polynomial on $\\left[T_{\\min}^{\\text{low}},T_{\\max}^{\\text{low}}\\right]$, and the high-temperature polynomial on $\\left[T_{\\min}^{\\text{high}},T_{\\max}^{\\text{high}}\\right]$, with a breakpoint (also called mid-point) $T_{\\mathrm{mid}}$ satisfying $T_{\\min}^{\\text{low}} \\le T_{\\mathrm{mid}} \\le T_{\\max}^{\\text{low}}$ and $T_{\\min}^{\\text{high}} \\le T_{\\mathrm{mid}} \\le T_{\\max}^{\\text{high}}$. Verify continuity of $c_{p,k}(T)$, $h_k(T)$, and $s_k(T)$ across the breakpoint by checking that the values computed from the low-temperature polynomial and the high-temperature polynomial match at $T=T_{\\mathrm{mid}}$ within a specified tolerance. Report the absolute mismatches at $T_{\\mathrm{mid}}$ for each property, and return booleans indicating whether each property is continuous within tolerance.\n\nUse $R=8.314462618\\,\\mathrm{J}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$. For all outputs involving physical quantities, express $c_{p,k}$ in $\\mathrm{J}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$, $h_k$ in $\\mathrm{J}\\,\\mathrm{mol}^{-1}$, and $s_k$ in $\\mathrm{J}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$.\n\nTest suite of species and coefficients:\n- Species $k=$ Hydrogen ($\\mathrm{H}_2$). Temperature intervals: low $\\left[200,1000\\right]$ K, high $\\left[1000,6000\\right]$ K, breakpoint $T_{\\mathrm{mid}}=1000$ K. Low-temperature coefficients $(a_1,\\dots,a_7)$:\n  $\\left(2.34433112,\\, 7.98052075\\times 10^{-3},\\, -1.94781510\\times 10^{-5},\\, 2.01572094\\times 10^{-8},\\, -7.37611761\\times 10^{-12},\\, -9.17935173\\times 10^{2},\\, 6.83010238\\times 10^{-1}\\right)$.\n  High-temperature coefficients $(a_1,\\dots,a_7)$:\n  $\\left(3.33727920,\\, -4.94024731\\times 10^{-5},\\, 4.99456778\\times 10^{-7},\\, -1.79566394\\times 10^{-10},\\, 2.00255376\\times 10^{-14},\\, -9.50158922\\times 10^{2},\\, -3.20502331\\right)$.\n  Continuity tolerance: $\\epsilon = 10^{-6}$.\n- Species $k=$ Oxygen ($\\mathrm{O}_2$). Temperature intervals: low $\\left[200,1000\\right]$ K, high $\\left[1000,6000\\right]$ K, breakpoint $T_{\\mathrm{mid}}=1000$ K. Low-temperature coefficients:\n  $\\left(3.78245636,\\, -2.99673416\\times 10^{-3},\\, 9.84730201\\times 10^{-6},\\, -9.68129509\\times 10^{-9},\\, 3.24372837\\times 10^{-12},\\, -1.06394356\\times 10^{3},\\, 3.65767573\\right)$.\n  High-temperature coefficients:\n  $\\left(3.28253784,\\, 1.48308754\\times 10^{-3},\\, -7.57966669\\times 10^{-7},\\, 2.09470555\\times 10^{-10},\\, -2.16717794\\times 10^{-14},\\, -1.08845772\\times 10^{3},\\, 5.45323129\\right)$.\n  Continuity tolerance: $\\epsilon = 10^{-6}$.\n- Species $k=$ Water ($\\mathrm{H}_2\\mathrm{O}$). Temperature intervals: low $\\left[200,1000\\right]$ K, high $\\left[1000,6000\\right]$ K, breakpoint $T_{\\mathrm{mid}}=1000$ K. Low-temperature coefficients:\n  $\\left(4.19864056,\\, -2.03643410\\times 10^{-3},\\, 6.52040211\\times 10^{-6},\\, -5.48797062\\times 10^{-9},\\, 1.77197817\\times 10^{-12},\\, -3.02937267\\times 10^{4},\\, -8.49032208\\times 10^{-1}\\right)$.\n  High-temperature coefficients:\n  $\\left(3.03399249,\\, 2.17691804\\times 10^{-3},\\, -1.64072518\\times 10^{-7},\\, -9.70419870\\times 10^{-11},\\, 1.68200992\\times 10^{-14},\\, -3.00042971\\times 10^{4},\\, 4.96677010\\right)$.\n  Continuity tolerance: $\\epsilon = 10^{-6}$.\n- Species $k=$ Carbon dioxide ($\\mathrm{CO}_2$). Temperature intervals: low $\\left[200,1000\\right]$ K, high $\\left[1000,6000\\right]$ K, breakpoint $T_{\\mathrm{mid}}=1000$ K. Low-temperature coefficients:\n  $\\left(2.35677352,\\, 8.98459677\\times 10^{-3},\\, -7.12356269\\times 10^{-6},\\, 2.45919022\\times 10^{-9},\\, -1.43699548\\times 10^{-13},\\, -4.83719697\\times 10^{4},\\, 9.90105222\\right)$.\n  High-temperature coefficients:\n  $\\left(3.85796028,\\, 4.41437026\\times 10^{-3},\\, -2.21481404\\times 10^{-6},\\, 5.23490188\\times 10^{-10},\\, -4.72084164\\times 10^{-14},\\, -4.87591660\\times 10^{4},\\, 2.27163806\\right)$.\n  Continuity tolerance: $\\epsilon = 10^{-6}$.\n- Species $k=$ Oxygen-mismatched ($\\mathrm{O}_2$-bad). Temperature intervals: low $\\left[200,1000\\right]$ K, high $\\left[1000,6000\\right]$ K, breakpoint $T_{\\mathrm{mid}}=1000$ K. Low-temperature coefficients identical to $\\mathrm{O}_2$ low:\n  $\\left(3.78245636,\\, -2.99673416\\times 10^{-3},\\, 9.84730201\\times 10^{-6},\\, -9.68129509\\times 10^{-9},\\, 3.24372837\\times 10^{-12},\\, -1.06394356\\times 10^{3},\\, 3.65767573\\right)$.\n  High-temperature coefficients intentionally perturbed to break continuity:\n  $\\left(3.28353784,\\, 1.48308754\\times 10^{-3},\\, -7.57966669\\times 10^{-7},\\, 2.09470555\\times 10^{-10},\\, -2.16717794\\times 10^{-14},\\, -1.08845772\\times 10^{3},\\, 5.45323129\\right)$.\n  Continuity tolerance: $\\epsilon = 10^{-6}$.\n\nImplementation requirements:\n- Derive the expressions for $c_{p,k}(T)$, $h_k(T)$, and $s_k(T)$ from first principles for the NASA representation and implement their evaluation over each interval. Use the low-temperature polynomial on the low interval and the high-temperature polynomial on the high interval.\n- Evaluate, for each species, the values from both polynomials at $T=T_{\\mathrm{mid}}$ and compute the absolute mismatches $\\Delta c_p$, $\\Delta h$, $\\Delta s$ in the units specified above.\n- For each species, return three booleans indicating whether $\\Delta c_p \\le \\epsilon$, $\\Delta h \\le \\epsilon$, and $\\Delta s \\le \\epsilon$, respectively, along with the three mismatch magnitudes.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each result item should be a six-element list in the order $\\left[\\text{cp\\_continuous},\\text{h\\_continuous},\\text{s\\_continuous},\\Delta c_p,\\Delta h,\\Delta s\\right]$, where the first three entries are booleans and the last three are floats. The output therefore has the form $\\left[\\left[b_1,b_2,b_3,x_1,x_2,x_3\\right],\\dots\\right]$.\n\nThe temperature grid for computing $c_{p,k}(T)$, $h_k(T)$, and $s_k(T)$ can be any reasonable discretization of each interval (e.g., uniform spacing), but the continuity check must be performed exactly at the breakpoint $T_{\\mathrm{mid}}$. Angle units are not applicable. All physical quantities must be reported in the units specified above.",
            "solution": "The problem has been validated and is determined to be scientifically grounded, well-posed, and objective. It is based on standard principles of chemical thermodynamics and utilizes a widely accepted empirical model (the NASA 7-coefficient polynomial) for representing species properties in computational fluid dynamics and combustion simulations. All necessary data and constraints are provided. We may therefore proceed with the derivation and solution.\n\nThe core of the problem is to derive the expressions for the molar isobaric heat capacity ($c_{p,k}$), molar enthalpy ($h_k$), and molar entropy ($s_k$) for an ideal gas species $k$ from the NASA 7-coefficient polynomial representation. These polynomials define the dimensionless heat capacity, $\\frac{c_{p,k}(T)}{R}$, as a function of temperature $T$.\n\nLet the universal gas constant be $R = 8.314462618\\,\\mathrm{J}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$. For a given temperature interval, the NASA polynomial coefficients are $\\{a_1, a_2, a_3, a_4, a_5, a_6, a_7\\}$.\n\n**1. Derivation of Isobaric Heat Capacity, $c_{p,k}(T)$**\n\nThe standard NASA polynomial form for the dimensionless specific heat at constant pressure is a fourth-order polynomial in temperature $T$:\n$$\n\\frac{c_{p,k}(T)}{R} = a_1 + a_2 T + a_3 T^2 + a_4 T^3 + a_5 T^4\n$$\nTo obtain the molar isobaric heat capacity, $c_{p,k}(T)$, in units of $\\mathrm{J}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$, we simply multiply by the universal gas constant $R$:\n$$\nc_{p,k}(T) = R \\left( a_1 + a_2 T + a_3 T^2 + a_4 T^3 + a_5 T^4 \\right)\n$$\n\n**2. Derivation of Molar Enthalpy, $h_k(T)$**\n\nThe relationship between isobaric heat capacity and enthalpy for a substance undergoing a process at constant pressure is given by the fundamental thermodynamic definition:\n$$\nc_{p,k} = \\left( \\frac{\\partial h_k}{\\partial T} \\right)_P\n$$\nFor an ideal gas, enthalpy is a function of temperature only, so the partial derivative becomes an ordinary derivative, $c_{p,k}(T) = \\frac{dh_k}{dT}$. We can find the enthalpy $h_k(T)$ by integrating $c_{p,k}(T)$ with respect to temperature:\n$$\nh_k(T) = \\int c_{p,k}(T) \\,dT\n$$\nIt is conventional to perform this integration using the dimensionless forms:\n$$\n\\frac{h_k(T)}{R} = \\int \\frac{c_{p,k}(T)}{R} \\,dT + C_1 = \\int \\left( a_1 + a_2 T + a_3 T^2 + a_4 T^3 + a_5 T^4 \\right) \\,dT\n$$\nPerforming the integration yields:\n$$\n\\frac{h_k(T)}{R} = a_1 T + \\frac{a_2}{2} T^2 + \\frac{a_3}{3} T^3 + \\frac{a_4}{4} T^4 + \\frac{a_5}{5} T^5 + a_6\n$$\nHere, the sixth coefficient, $a_6$, is defined as the constant of integration, $C_1$. This is a standard convention for the NASA polynomials. To obtain the molar enthalpy, $h_k(T)$, in units of $\\mathrm{J}\\,\\mathrm{mol}^{-1}$, we multiply by $R$ and rearrange the expression to match the standard computational form:\n$$\nh_k(T) = R T \\left( a_1 + \\frac{a_2}{2} T + \\frac{a_3}{3} T^2 + \\frac{a_4}{4} T^3 + \\frac{a_5}{5} T^4 + \\frac{a_6}{T} \\right)\n$$\n\n**3. Derivation of Molar Entropy, $s_k(T)$**\n\nThe change in entropy at a reference pressure (standard state entropy, $s_k^0$) is related to the heat capacity by:\n$$\nds_k^0 = \\frac{c_{p,k}(T)}{T} \\,dT\n$$\nWe find the entropy $s_k^0(T)$ by integrating this expression:\n$$\ns_k^0(T) = \\int \\frac{c_{p,k}(T)}{T} \\,dT\n$$\nUsing the dimensionless forms:\n$$\n\\frac{s_k^0(T)}{R} = \\int \\frac{c_{p,k}(T)}{RT} \\,dT + C_2 = \\int \\left( \\frac{a_1}{T} + a_2 + a_3 T + a_4 T^2 + a_5 T^3 \\right) \\,dT\n$$\nPerforming the integration gives:\n$$\n\\frac{s_k^0(T)}{R} = a_1 \\ln(T) + a_2 T + \\frac{a_3}{2} T^2 + \\frac{a_4}{3} T^3 + \\frac{a_5}{4} T^4 + a_7\n$$\nHere, the seventh coefficient, $a_7$, is defined as the constant of integration, $C_2$. This is again the standard convention. The problem asks for $s_k(T)$, which in this context refers to the standard molar entropy. To obtain $s_k(T)$ in units of $\\mathrm{J}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$, we multiply by $R$:\n$$\ns_k(T) = R \\left( a_1 \\ln(T) + a_2 T + \\frac{a_3}{2} T^2 + \\frac{a_4}{3} T^3 + \\frac{a_5}{4} T^4 + a_7 \\right)\n$$\nThe coefficients $a_6$ and $a_7$ are specifically chosen for each temperature range such that the functions $h_k(T)$ and $s_k(T)$ are continuous at the breakpoint temperature $T_{\\mathrm{mid}}$. The heat capacity $c_{p,k}(T)$ is also expected to be continuous.\n\n**4. Continuity Verification**\n\nTo verify the continuity of these properties at the breakpoint $T_{\\mathrm{mid}}$, we compute the values using both the low-temperature coefficients ($a_{i, \\text{low}}$) and the high-temperature coefficients ($a_{i, \\text{high}}$) at $T = T_{\\mathrm{mid}}$.\n\nLet $c_{p,\\text{low}}(T_\\text{mid})$, $h_{\\text{low}}(T_\\text{mid})$, $s_{\\text{low}}(T_\\text{mid})$ be the values computed with the low-temperature polynomial coefficients, and $c_{p,\\text{high}}(T_\\text{mid})$, $h_{\\text{high}}(T_\\text{mid})$, $s_{\\text{high}}(T_\\text{mid})$ be the values from the high-temperature coefficients.\n\nThe absolute mismatches are calculated as:\n$$\n\\Delta c_p = |c_{p,\\text{high}}(T_\\text{mid}) - c_{p,\\text{low}}(T_\\text{mid})|\n$$\n$$\n\\Delta h = |h_{\\text{high}}(T_\\text{mid}) - h_{\\text{low}}(T_\\text{mid})|\n$$\n$$\n\\Delta s = |s_{\\text{high}}(T_\\text{mid}) - s_{\\text{low}}(T_\\text{mid})|\n$$\nContinuity is satisfied for each property if its respective mismatch is less than or equal to the specified tolerance $\\epsilon = 10^{-6}$.\n- $c_p$ is continuous if $\\Delta c_p \\le \\epsilon$.\n- $h$ is continuous if $\\Delta h \\le \\epsilon$.\n- $s$ is continuous if $\\Delta s \\le \\epsilon$.\n\nThe implementation will proceed by coding these derived formulae into a function, applying it to the provided test cases for each species, and reporting the continuity booleans and mismatch magnitudes.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes thermodynamic properties using NASA 7-coefficient polynomials\n    and checks for continuity at the breakpoint temperature.\n    \"\"\"\n    R = 8.314462618  # J / (mol * K)\n\n    test_cases = [\n        {\n            \"name\": \"H2\",\n            \"T_mid\": 1000.0,\n            \"epsilon\": 1.0e-6,\n            \"low_coeffs\": [\n                2.34433112e+00, 7.98052075e-03, -1.94781510e-05,\n                2.01572094e-08, -7.37611761e-12, -9.17935173e+02,\n                6.83010238e-01\n            ],\n            \"high_coeffs\": [\n                3.33727920e+00, -4.94024731e-05, 4.99456778e-07,\n                -1.79566394e-10, 2.00255376e-14, -9.50158922e+02,\n                -3.20502331e+00\n            ],\n        },\n        {\n            \"name\": \"O2\",\n            \"T_mid\": 1000.0,\n            \"epsilon\": 1.0e-6,\n            \"low_coeffs\": [\n                3.78245636e+00, -2.99673416e-03, 9.84730201e-06,\n                -9.68129509e-09, 3.24372837e-12, -1.06394356e+03,\n                3.65767573e+00\n            ],\n            \"high_coeffs\": [\n                3.28253784e+00, 1.48308754e-03, -7.57966669e-07,\n                2.09470555e-10, -2.16717794e-14, -1.08845772e+03,\n                5.45323129e+00\n            ],\n        },\n        {\n            \"name\": \"H2O\",\n            \"T_mid\": 1000.0,\n            \"epsilon\": 1.0e-6,\n            \"low_coeffs\": [\n                4.19864056e+00, -2.03643410e-03, 6.52040211e-06,\n                -5.48797062e-09, 1.77197817e-12, -3.02937267e+04,\n                -8.49032208e-01\n            ],\n            \"high_coeffs\": [\n                3.03399249e+00, 2.17691804e-03, -1.64072518e-07,\n                -9.70419870e-11, 1.68200992e-14, -3.00042971e+04,\n                4.96677010e+00\n            ],\n        },\n        {\n            \"name\": \"CO2\",\n            \"T_mid\": 1000.0,\n            \"epsilon\": 1.0e-6,\n            \"low_coeffs\": [\n                2.35677352e+00, 8.98459677e-03, -7.12356269e-06,\n                2.45919022e-09, -1.43699548e-13, -4.83719697e+04,\n                9.90105222e+00\n            ],\n            \"high_coeffs\": [\n                3.85796028e+00, 4.41437026e-03, -2.21481404e-06,\n                5.23490188e-10, -4.72084164e-14, -4.87591660e+04,\n                2.27163806e+00\n            ],\n        },\n        {\n            \"name\": \"O2-mismatched\",\n            \"T_mid\": 1000.0,\n            \"epsilon\": 1.0e-6,\n            \"low_coeffs\": [\n                3.78245636e+00, -2.99673416e-03, 9.84730201e-06,\n                -9.68129509e-09, 3.24372837e-12, -1.06394356e+03,\n                3.65767573e+00\n            ],\n            # High-temp coeffs intentionally perturbed from O2\n            \"high_coeffs\": [\n                3.28353784e+00, 1.48308754e-03, -7.57966669e-07,\n                2.09470555e-10, -2.16717794e-14, -1.08845772e+03,\n                5.45323129e+00\n            ],\n        }\n    ]\n\n    def calculate_properties(T, coeffs, R_gas):\n        \"\"\"\n        Calculates cp, h, and s from NASA 7-coefficient polynomial.\n        Args:\n            T (float): Temperature in Kelvin.\n            coeffs (list or np.ndarray): Array of 7 coefficients {a1..a7}.\n            R_gas (float): Universal gas constant.\n        Returns:\n            tuple: (cp, h, s)\n        \"\"\"\n        a1, a2, a3, a4, a5, a6, a7 = coeffs\n        \n        T_powers = np.array([1.0, T, T**2, T**3, T**4])\n        \n        # Dimensionless heat capacity: cp/R = sum(a_i * T^(i-1)) for i=1 to 5\n        cp_over_R = np.dot(coeffs[:5], T_powers)\n        \n        # Dimensionless enthalpy: h/RT = ...\n        h_over_RT = (\n            a1 + a2 * T / 2.0 + a3 * T**2 / 3.0 +\n            a4 * T**3 / 4.0 + a5 * T**4 / 5.0 + a6 / T\n        )\n        \n        # Dimensionless entropy: s/R = ...\n        s_over_R = (\n            a1 * np.log(T) + a2 * T + a3 * T**2 / 2.0 +\n            a4 * T**3 / 3.0 + a5 * T**4 / 4.0 + a7\n        )\n\n        cp = R_gas * cp_over_R\n        h = R_gas * T * h_over_RT\n        s = R_gas * s_over_R\n        \n        return cp, h, s\n\n    results = []\n    for case in test_cases:\n        T_mid = case[\"T_mid\"]\n        epsilon = case[\"epsilon\"]\n        \n        # Calculate properties at T_mid using both sets of coefficients\n        cp_low, h_low, s_low = calculate_properties(T_mid, case[\"low_coeffs\"], R)\n        cp_high, h_high, s_high = calculate_properties(T_mid, case[\"high_coeffs\"], R)\n\n        # Calculate absolute mismatches\n        delta_cp = abs(cp_high - cp_low)\n        delta_h = abs(h_high - h_low)\n        delta_s = abs(s_high - s_low)\n\n        # Check for continuity within tolerance\n        cp_continuous = delta_cp = epsilon\n        h_continuous = delta_h = epsilon\n        s_continuous = delta_s = epsilon\n        \n        results.append([\n            cp_continuous, h_continuous, s_continuous,\n            delta_cp, delta_h, delta_s\n        ])\n    \n    # Format the final output string as a list of lists.\n    # The `map(str, ...)` will use Python's default string conversion for lists,\n    # which is a valid and standard representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "The governing equations for reacting flows couple stiff chemical kinetics with transport phenomena like diffusion, posing a significant challenge for time integration. This practice delves into the core of numerical methods for DNS by comparing an unsplit Implicit-Explicit (IMEX) scheme with the widely used Strang splitting method. By implementing both approaches for a model reaction-diffusion problem, you will directly quantify the operator splitting error and develop a deeper understanding of how the choice of time-stepping algorithm affects solution accuracy, a central consideration in the design of high-fidelity solvers .",
            "id": "4019193",
            "problem": "Consider a one-dimensional reacting-diffusing scalar field for a single species mass fraction $u(x,t)$ in a periodic domain $x \\in [0,L)$ governed by the species conservation equation (derived from Fick’s law and a volumetric reaction source) without advection: \n$$\n\\frac{\\partial u}{\\partial t} = D \\frac{\\partial^2 u}{\\partial x^2} + \\omega(u),\n$$\nwhere $D$ is the constant diffusivity and $\\omega(u)$ is the reaction source term. For the purpose of isolating operator-splitting effects in a setting relevant to Direct Numerical Simulation (DNS) of reacting flows, use the nonlinear logistic reaction model \n$$\n\\omega(u) = k\\,u\\,(1-u),\n$$\nwhere $k$ is a constant reaction rate. Discretize space with second-order central finite differences on a uniform grid with $N$ points and periodic boundary conditions so that the discrete Laplacian operator is consistent with the continuous operator. The initial condition is \n$$\nu(x,0) = u_0(x) = 0.2 + 0.1\\sin(2\\pi x/L).\n$$\n\nImplement two time-integration strategies for the semi-discrete system:\n- An “unsplit” Implicit-Explicit (IMEX) scheme where diffusion is treated implicitly and reaction explicitly, using a second-order accurate combination of Crank–Nicolson for diffusion and Adams–Bashforth for reaction. Initialize the multistep part with a first step that is consistent with the overall IMEX strategy. Ensure that the implicit operator solve is performed accurately and stably at each time step.\n- A Strang splitting method (second-order operator splitting) that advances one full time step by composing a half-step of pure diffusion, a full-step of pure reaction, and a final half-step of pure diffusion. For the diffusion substeps, employ a second-order accurate implicit scheme consistent with the spatial discretization. For the reaction substep, employ a second-order accurate explicit method for integrating $\\dot{u}=\\omega(u)$.\n\nCompute the solution from $t=0$ to a final time $T$ for each method, starting from the same $u_0(x)$ and using identical spatial discretization. For each time step $\\Delta t$, quantify the splitting error at $t=T$ by computing the discrete $L_2$ norm of the difference between the unsplit IMEX solution $u_{\\mathrm{IMEX}}(x,T)$ and the Strang-split solution $u_{\\mathrm{Strang}}(x,T)$:\n$$\n\\|u_{\\mathrm{IMEX}}(\\cdot,T)-u_{\\mathrm{Strang}}(\\cdot,T)\\|_2 \\equiv \\left( \\int_0^L \\left[u_{\\mathrm{IMEX}}(x,T)-u_{\\mathrm{Strang}}(x,T)\\right]^2\\,dx \\right)^{1/2},\n$$\nand approximate this integral by the grid-based Riemann sum\n$$\n\\|u_{\\mathrm{IMEX}}(\\cdot,T)-u_{\\mathrm{Strang}}(\\cdot,T)\\|_{2,\\Delta x} \\equiv \\left( \\Delta x \\sum_{j=0}^{N-1} \\left[u_{\\mathrm{IMEX}}(x_j,T)-u_{\\mathrm{Strang}}(x_j,T)\\right]^2 \\right)^{1/2},\n$$\nwhere $x_j=j\\,\\Delta x$ and $\\Delta x=L/N$.\n\nUse the following scientifically consistent parameters to ensure a robust and representative computation:\n- Domain length $L=1$ (dimensionless).\n- Diffusivity $D=0.01$ (dimensionless).\n- Reaction rate $k=1$ (dimensionless).\n- Grid size $N=256$ (uniform spacing, periodic).\n- Final time $T=0.1$ (dimensionless).\n- Initial condition $u_0(x)=0.2+0.1\\sin(2\\pi x/L)$.\n\nImplement the two methods and compute the discrete $L_2$ norm of the difference at $t=T$ for each of the following time step sizes $\\Delta t$ (all chosen to exactly divide $T$):\n- $\\Delta t = 0.0025$,\n- $\\Delta t = 0.005$,\n- $\\Delta t = 0.01$,\n- $\\Delta t = 0.02$.\n\nAll quantities are nondimensional; express the final answers as dimensionless floating-point numbers. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\texttt{[result1,result2,result3,result4]}$), ordered to correspond to the listed $\\Delta t$ values. The computations must be self-contained and carry out the required operator solves and updates without external input. The test suite defined by these $\\Delta t$ values covers a typical case, moderate-to-large time step behavior, and an edge case for relatively small time steps. The objective is to reveal the $\\Delta t$-dependence of the splitting error by comparing the unsplit and Strang-split solutions under identical spatial discretization and physical parameters.",
            "solution": "The problem requires the numerical solution of a one-dimensional reaction-diffusion equation and a comparison of two different time integration schemes. The governing partial differential equation (PDE) for the species mass fraction $u(x,t)$ is:\n$$\n\\frac{\\partial u}{\\partial t} = D \\frac{\\partial^2 u}{\\partial x^2} + \\omega(u)\n$$\non a periodic domain $x \\in [0,L)$. The diffusivity $D$ and reaction rate $k$ are constants. The nonlinear reaction source term is given by the logistic model, $\\omega(u) = k\\,u\\,(1-u)$. The initial condition is specified as $u(x,0) = u_0(x) = 0.2 + 0.1\\sin(2\\pi x/L)$.\n\nTo solve this equation numerically, we first perform a spatial discretization, converting the PDE into a system of ordinary differential equations (ODEs), a method known as the method of lines.\n\n**1. Spatial Discretization and Semi-Discrete System**\n\nWe discretize the spatial domain $[0,L)$ using a uniform grid of $N$ points, $x_j = j \\Delta x$ for $j=0, 1, \\dots, N-1$, where the grid spacing is $\\Delta x = L/N$. The scalar field $u(x,t)$ is represented by a vector $\\mathbf{u}(t)$ where the $j$-th component, $u_j(t)$, approximates $u(x_j, t)$.\n\nThe second spatial derivative, or Laplacian operator $\\frac{\\partial^2}{\\partial x^2}$, is approximated using a second-order accurate central finite difference scheme. For a periodic function, the discrete Laplacian acting on $u_j$ is:\n$$\n\\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_j \\approx \\frac{u_{j+1} - 2u_j + u_{j-1}}{(\\Delta x)^2}\n$$\nwhere indices are taken modulo $N$ to enforce periodicity. This discretization can be represented by a matrix-vector product, $\\mathbf{L}\\mathbf{u}$, where $\\mathbf{L}$ is the discrete Laplacian matrix.\n\nThe semi-discrete system of ODEs can then be written as:\n$$\n\\frac{d\\mathbf{u}}{dt} = D \\mathbf{L} \\mathbf{u} + \\mathbf{\\Omega}(\\mathbf{u})\n$$\nwhere $(\\mathbf{\\Omega}(\\mathbf{u}))_j = \\omega(u_j) = k u_j (1-u_j)$. The matrix $\\mathbf{L}$ is a circulant matrix. A key property of circulant matrices is that they are diagonalized by the Discrete Fourier Transform (DFT). This allows for the efficient solution of linear systems involving $\\mathbf{L}$ in Fourier space, where matrix multiplication becomes element-wise multiplication. The eigenvalues of $\\mathbf{L}$ are given by $\\lambda_m = \\frac{2}{(\\Delta x)^2} (\\cos(2\\pi m/N) - 1)$ for integer wavenumbers $m = 0, 1, \\dots, N-1$.\n\n**2. Unsplit IMEX Scheme (Crank-Nicolson / Adams-Bashforth)**\n\nThe first method is a second-order accurate Implicit-Explicit (IMEX) scheme. The stiff diffusion term ($D \\mathbf{L} \\mathbf{u}$) is treated implicitly for stability, while the non-stiff reaction term ($\\mathbf{\\Omega}(\\mathbf{u})$) is treated explicitly for efficiency. We use the second-order Crank-Nicolson (CN) method for diffusion and the second-order Adams-Bashforth (AB2) method for reaction. The update from time step $n$ to $n+1$ is:\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = D \\mathbf{L} \\left( \\frac{\\mathbf{u}^{n+1} + \\mathbf{u}^n}{2} \\right) + \\left( \\frac{3}{2} \\mathbf{\\Omega}(\\mathbf{u}^n) - \\frac{1}{2} \\mathbf{\\Omega}(\\mathbf{u}^{n-1}) \\right)\n$$\nTo solve for $\\mathbf{u}^{n+1}$, we rearrange the equation to isolate implicit terms on the left-hand side:\n$$\n\\left(\\mathbf{I} - \\frac{D \\Delta t}{2} \\mathbf{L}\\right) \\mathbf{u}^{n+1} = \\left(\\mathbf{I} + \\frac{D \\Delta t}{2} \\mathbf{L}\\right) \\mathbf{u}^n + \\Delta t \\left( \\frac{3}{2} \\mathbf{\\Omega}(\\mathbf{u}^n) - \\frac{1}{2} \\mathbf{\\Omega}(\\mathbf{u}^{n-1}) \\right)\n$$\nThis is a linear system of the form $\\mathbf{A}\\mathbf{x} = \\mathbf{b}$ for $\\mathbf{x} = \\mathbf{u}^{n+1}$. Using the DFT (denoted by $\\mathcal{F}$), we transform this system into Fourier space:\n$$\n\\mathcal{F}\\left\\{ \\left(\\mathbf{I} - \\frac{D \\Delta t}{2} \\mathbf{L}\\right) \\mathbf{u}^{n+1} \\right\\} = \\mathcal{F}\\left\\{ \\text{RHS} \\right\\}\n$$\n$$\n\\left(\\mathbf{I} - \\frac{D \\Delta t}{2} \\mathbf{\\Lambda}_L\\right) \\hat{\\mathbf{u}}^{n+1} = \\hat{\\mathbf{b}}\n$$\nwhere $\\hat{\\mathbf{u}} = \\mathcal{F}\\{\\mathbf{u}\\}$, $\\mathbf{\\Lambda}_L$ is the diagonal matrix of eigenvalues of $\\mathbf{L}$, and $\\hat{\\mathbf{b}}$ is the DFT of the right-hand side vector. The solution is found by element-wise division $\\hat{u}_m^{n+1} = \\hat{b}_m / (1 - \\frac{D \\Delta t}{2}\\lambda_m)$, followed by an inverse DFT to recover $\\mathbf{u}^{n+1} = \\mathcal{F}^{-1}\\{\\hat{\\mathbf{u}}^{n+1}\\}$.\n\nThe two-step AB2 method requires a special startup procedure for the first time step. We use a first-order Forward Euler method for the reaction term, which, while only first-order for that single step, is sufficient to maintain overall second-order accuracy of the global solution at time $T$. The first step is:\n$$\n\\left(\\mathbf{I} - \\frac{D \\Delta t}{2} \\mathbf{L}\\right) \\mathbf{u}^{1} = \\left(\\mathbf{I} + \\frac{D \\Delta t}{2} \\mathbf{L}\\right) \\mathbf{u}^0 + \\Delta t \\mathbf{\\Omega}(\\mathbf{u}^0)\n$$\n\n**3. Strang Splitting Scheme**\n\nThe second method is Strang splitting, a second-order operator splitting technique. The evolution over one time step $\\Delta t$ is decomposed into three sequential substeps: a half-step of diffusion, a full step of reaction, and a final half-step of diffusion.\n$$\n\\mathbf{u}^{n+1} = \\mathcal{D}(\\Delta t/2) \\circ \\mathcal{R}(\\Delta t) \\circ \\mathcal{D}(\\Delta t/2) (\\mathbf{u}^n)\n$$\nwhere $\\mathcal{D}(\\delta t)$ is the operator for solving the pure diffusion equation $\\frac{\\partial u}{\\partial t} = D \\frac{\\partial^2 u}{\\partial x^2}$ over a time interval $\\delta t$, and $\\mathcal{R}(\\delta t)$ is the operator for solving the pure reaction equation $\\frac{du}{dt} = \\omega(u)$ over $\\delta t$.\n\n- **Diffusion Substep $\\mathcal{D}(\\delta t)$**: We use the second-order implicit Crank-Nicolson method. For a step of size $\\delta t$, the update is:\n  $$\n  \\left(\\mathbf{I} - \\frac{D \\delta t}{2} \\mathbf{L}\\right) \\mathbf{u}^{\\text{new}} = \\left(\\mathbf{I} + \\frac{D \\delta t}{2} \\mathbf{L}\\right) \\mathbf{u}^{\\text{old}}\n  $$\n  This linear system is solved efficiently in Fourier space, identically to the implicit part of the IMEX scheme, with $\\Delta t$ replaced by the substep duration $\\delta t = \\Delta t/2$.\n\n- **Reaction Substep $\\mathcal{R}(\\Delta t)$**: We solve the system of ODEs $\\frac{du_j}{dt} = k u_j(1-u_j)$ for each grid point $j$ over a time step $\\Delta t$. This is the logistic equation, which has an exact analytical solution:\n  $$\n  u_j(t) = \\frac{u_j(0)}{u_j(0) + (1-u_j(0))e^{-kt}}\n  $$\n  Using this exact solution for the reaction substep provides an update that is more accurate than any standard second-order explicit numerical method and avoids any potential stability constraints associated with the reaction term.\n\nThe complete Strang splitting step involves applying the diffusion operator for $\\Delta t/2$, then the reaction operator for $\\Delta t$, and finally the diffusion operator again for $\\Delta t/2$.\n\n**4. Error Calculation and Implementation**\n\nFor each specified time step $\\Delta t$, both schemes are integrated from $t=0$ to the final time $T=0.1$. The splitting error is then quantified by calculating the discrete $L_2$ norm of the difference between the final solutions from the two methods, $u_{\\mathrm{IMEX}}(x,T)$ and $u_{\\mathrm{Strang}}(x,T)$:\n$$\n\\|u_{\\mathrm{IMEX}}(\\cdot,T)-u_{\\mathrm{Strang}}(\\cdot,T)\\|_{2,\\Delta x} \\equiv \\left( \\Delta x \\sum_{j=0}^{N-1} \\left[u_{\\mathrm{IMEX}}(x_j,T)-u_{\\mathrm{Strang}}(x_j,T)\\right]^2 \\right)^{1/2}\n$$\nThe calculation is performed for $\\Delta t \\in \\{0.0025, 0.005, 0.01, 0.02\\}$. Since both schemes are second-order accurate, their difference, which is dominated by the splitting error of the Strang method, is expected to scale with $(\\Delta t)^2$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import fft\n\ndef solve():\n    \"\"\"\n    Computes and compares solutions of a 1D reaction-diffusion equation\n    using an unsplit IMEX scheme and a Strang splitting scheme.\n    \"\"\"\n    \n    # Define physical and numerical parameters from the problem statement.\n    L = 1.0       # Domain length\n    D = 0.01      # Diffusivity\n    k = 1.0       # Reaction rate\n    N = 256       # Grid size\n    T = 0.1       # Final time\n\n    # List of time step sizes to test\n    test_cases = [0.0025, 0.005, 0.01, 0.02]\n\n    # --- Setup common to all simulations ---\n    dx = L / N\n    x = np.arange(N) * dx\n    \n    # Initial condition u(x,0)\n    u0 = 0.2 + 0.1 * np.sin(2 * np.pi * x / L)\n\n    # Pre-compute eigenvalues of the discrete Laplacian operator for FFT-based solver.\n    # Wavenumber modes for the DFT.\n    modes = fft.fftfreq(N, d=1.0) * N\n    # Eigenvalues of the second-order central difference Laplacian matrix.\n    lap_eig = (2 / dx**2) * (np.cos(2 * np.pi * modes / N) - 1)\n\n    def reaction_term_func(u_vec):\n        \"\"\"Computes the logistic reaction term omega(u) = k*u*(1-u).\"\"\"\n        return k * u_vec * (1 - u_vec)\n\n    def run_imex(dt):\n        \"\"\"\n        Solves the system using the second-order IMEX scheme:\n        Crank-Nicolson for diffusion (implicit) and Adams-Bashforth for reaction (explicit).\n        \"\"\"\n        u = u0.copy()\n        num_steps = int(round(T / dt))\n        omega_prev = None\n\n        # Pre-compute operators in Fourier space for the implicit solve.\n        # This corresponds to the inverse of the matrix (I - D*dt/2 * L) in Fourier space.\n        imex_implicit_inv_op_hat = 1.0 / (1.0 - D * dt / 2.0 * lap_eig)\n        # This corresponds to the matrix (I + D*dt/2 * L) in Fourier space.\n        imex_explicit_op_hat = 1.0 + D * dt / 2.0 * lap_eig\n\n        for n in range(num_steps):\n            omega_curr = reaction_term_func(u)\n            \n            if n == 0:\n                # First step: Use first-order Forward Euler for the reaction term.\n                # This is a standard startup for a multi-step method.\n                explicit_reaction_part = dt * omega_curr\n            else:\n                # Subsequent steps: Use second-order Adams-Bashforth for the reaction.\n                explicit_reaction_part = dt * (1.5 * omega_curr - 0.5 * omega_prev)\n            \n            omega_prev = omega_curr\n\n            # Construct the full right-hand side (RHS) of the linear system.\n            # The diffusion part is calculated in Fourier space for precision.\n            diffusion_rhs = np.real(fft.ifft(imex_explicit_op_hat * fft.fft(u)))\n            rhs = diffusion_rhs + explicit_reaction_part\n            \n            # Solve for the next time step u^{n+1} in Fourier space.\n            rhs_hat = fft.fft(rhs)\n            u_next_hat = rhs_hat * imex_implicit_inv_op_hat\n            u = np.real(fft.ifft(u_next_hat))\n\n        return u\n\n    def run_strang(dt):\n        \"\"\"\n        Solves the system using second-order Strang splitting:\n        D(dt/2) - R(dt) - D(dt/2).\n        \"\"\"\n        u = u0.copy()\n        num_steps = int(round(T / dt))\n        \n        # --- Define sub-step operators ---\n\n        # Diffusion sub-step operator for a duration of dt/2.\n        # This is one Crank-Nicolson step.\n        dt_half = dt / 2.0\n        # The implicit operator corresponds to (I - D*(dt/2)/2 * L)^-1.\n        strang_implicit_inv_op_hat = 1.0 / (1.0 - D * dt_half / 2.0 * lap_eig)\n        # The explicit operator corresponds to (I + D*(dt/2)/2 * L).\n        strang_explicit_op_hat = 1.0 + D * dt_half / 2.0 * lap_eig\n        \n        def diffusion_substep(u_in):\n            \"\"\"Applies Crank-Nicolson for a half time step.\"\"\"\n            u_in_hat = fft.fft(u_in)\n            # Combine explicit and implicit parts in one multiplication\n            u_out_hat = u_in_hat * strang_explicit_op_hat * strang_implicit_inv_op_hat\n            return np.real(fft.ifft(u_out_hat))\n\n        def reaction_substep(u_in):\n            \"\"\"Applies the exact solution of the logistic ODE for a full time step.\"\"\"\n            # Use a small floor to prevent division by zero if u_in is exactly 0.\n            u_in_safe = np.where(u_in == 0, 1e-16, u_in)\n            return u_in_safe / (u_in_safe + (1 - u_in_safe) * np.exp(-k * dt))\n\n        # --- Main time-stepping loop ---\n        for _ in range(num_steps):\n            # Apply the three stages of Strang splitting\n            u = diffusion_substep(u)   # 1. Half-step diffusion\n            u = reaction_substep(u)    # 2. Full-step reaction\n            u = diffusion_substep(u)   # 3. Half-step diffusion\n            \n        return u\n\n    results = []\n    for dt in test_cases:\n        # Run both simulations for the current time step dt\n        u_final_imex = run_imex(dt)\n        u_final_strang = run_strang(dt)\n        \n        # Compute the discrete L2 norm of the difference between the two solutions.\n        diff_sq = (u_final_imex - u_final_strang)**2\n        l2_norm_of_difference = np.sqrt(dx * np.sum(diff_sq))\n        results.append(l2_norm_of_difference)\n\n    # Print the final results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "A robust numerical simulation must not only be accurate but also respect fundamental physical laws. In DNS, numerical errors can lead to unphysical species mass fractions—for instance, values below zero or above one—which can corrupt the solution and cause the simulation to fail. This advanced exercise tackles the critical issue of realizability by guiding you through the derivation and implementation of an algorithm to project a non-physical state back onto the valid physical state space, known as the probability simplex. This practice provides essential training in building numerically stable and physically consistent solvers .",
            "id": "4019173",
            "problem": "Consider a reacting flow discretized for Direct Numerical Simulation (DNS) of a multicomponent mixture, where each computational cell carries species mass fractions $Y_k$ for $k \\in \\{1,\\dots,N_s\\}$, with $N_s$ denoting the number of chemical species. By conservation of mass and the definition of species mass fraction, the physically realizable state must satisfy $Y_k \\ge 0$ for all $k$ and $\\sum_{k=1}^{N_s} Y_k = 1$. The admissible set is the probability simplex $\\mathcal{S} = \\{ \\mathbf{y} \\in \\mathbb{R}^{N_s} \\mid y_k \\ge 0, \\sum_{k=1}^{N_s} y_k = 1 \\}$. Numerical diffusion and dispersion from advection, diffusion, and reactive source term discretizations can produce violations of realizability, such as $Y_k  0$ and components $Y_k  1$ when other components are negative, or $\\sum_{k=1}^{N_s} Y_k \\neq 1$.\n\nYour task is to quantify the deviation of a given $\\mathbf{Y}$ from the simplex and apply a local renormalization that restores realizability. Use a deviation metric based on the Euclidean distance to the simplex, defined for any $\\mathbf{y} \\in \\mathbb{R}^{N_s}$ as $d(\\mathbf{y}) = \\left\\| \\mathbf{y} - \\mathbf{y}^\\star \\right\\|_2$, where $\\mathbf{y}^\\star$ is the Euclidean projection of $\\mathbf{y}$ onto $\\mathcal{S}$. The local renormalization operator $\\mathcal{R}$ must map $\\mathbf{y}$ to $\\mathbf{y}^\\star \\in \\mathcal{S}$ such that $0 \\le y^\\star_k \\le 1$ for all $k$ and $\\sum_{k=1}^{N_s} y_k^\\star = 1$. The implementation must be numerically stable for small negative violations and large overshoots.\n\nStart from fundamental laws and core definitions appropriate to computational combustion and DNS of reacting flows: mass conservation, the definition of species mass fraction, and the properties of the simplex. Do not use any shortcut formulas beyond what you derive from first principles and standard convex optimization optimality conditions.\n\nImplement a program that:\n- Computes $d(\\mathbf{y})$ for each cell in each test case.\n- Applies the local renormalization $\\mathcal{R}$ by projecting onto $\\mathcal{S}$.\n- Computes the total deviation reduction for each test case, defined as the sum of $d(\\mathbf{y})$ over all cells in the test case minus the sum of $d(\\mathcal{R}(\\mathbf{y}))$ over all cells (which should be zero in exact arithmetic).\n\nThe test suite comprises four test cases, each containing multiple cells. Each cell is a vector of species mass fractions:\n- Test Case 1 (valid and boundary realizable states, $N_s = 4$, three cells):\n  - $\\mathbf{y}^{(1)} = [0.1, 0.2, 0.3, 0.4]$\n  - $\\mathbf{y}^{(2)} = [0.0, 0.0, 1.0, 0.0]$\n  - $\\mathbf{y}^{(3)} = [10^{-15}, 0.5, 0.5 - 10^{-15}, 0.0]$\n- Test Case 2 (mild violations and sum errors, $N_s = 4$, three cells):\n  - $\\mathbf{y}^{(1)} = [0.2, -10^{-8}, 0.5, 0.3 + 10^{-8}]$\n  - $\\mathbf{y}^{(2)} = [0.25, 0.25, 0.25, 0.26]$\n  - $\\mathbf{y}^{(3)} = [-10^{-12}, 0.6, 0.4, 10^{-12}]$\n- Test Case 3 (severe overshoots and negativity, $N_s = 5$, two cells):\n  - $\\mathbf{y}^{(1)} = [1.2, -0.1, -0.05, -0.05, 0.0]$\n  - $\\mathbf{y}^{(2)} = [0.8, 0.3, -0.1, 0.0, 0.0]$\n- Test Case 4 (strong sum deviations with nonnegative components, $N_s = 3$, two cells):\n  - $\\mathbf{y}^{(1)} = [0.4, 0.4, 0.4]$\n  - $\\mathbf{y}^{(2)} = [0.3, 0.3, 0.3]$\n\nAll quantities are dimensionless. Angles are not used. Your program should produce a single line of output containing the total deviation reduction for each test case, expressed as a list of floats rounded to six decimal places, in the exact format: \"[r1,r2,r3,r4]\".\n\nYour implementation must be self-contained and must not require any user input. The algorithm should be robust and efficient for the given test suite and should reflect the logic of the derivation starting from conservation and the definition of $Y_k$ and the probability simplex.",
            "solution": "The problem requires the development of a procedure to enforce physical realizability on species mass fraction vectors, $\\mathbf{Y}$, which may be corrupted by numerical errors during Direct Numerical Simulation (DNS) of reacting flows. The core of the task is to project an arbitrary vector $\\mathbf{y} \\in \\mathbb{R}^{N_s}$ onto the standard, or probability, simplex $\\mathcal{S}$.\n\nFrom the fundamental principles of mass conservation and the definition of mass fractions, a physically realizable state $\\mathbf{Y}$ must reside within the simplex $\\mathcal{S}$, defined as:\n$$\n\\mathcal{S} = \\left\\{ \\mathbf{x} \\in \\mathbb{R}^{N_s} \\mid \\sum_{k=1}^{N_s} x_k = 1, \\text{ and } x_k \\ge 0 \\text{ for all } k=1, \\dots, N_s \\right\\}\n$$\nThe problem specifies using the Euclidean projection to map a given vector $\\mathbf{y}$ to its nearest point $\\mathbf{y}^\\star$ on the simplex $\\mathcal{S}$. The deviation is then quantified by the Euclidean distance $d(\\mathbf{y}) = \\| \\mathbf{y} - \\mathbf{y}^\\star \\|_2$. The renormalization operator is thus $\\mathcal{R}(\\mathbf{y}) = \\mathbf{y}^\\star$.\n\nThis projection can be formulated as a constrained quadratic optimization problem. We seek to find a vector $\\mathbf{x}$ that minimizes the squared Euclidean distance to $\\mathbf{y}$, subject to the constraints defining the simplex:\n$$\n\\begin{aligned}\n\\text{minimize} \\quad  f(\\mathbf{x}) = \\frac{1}{2} \\| \\mathbf{x} - \\mathbf{y} \\|_2^2 = \\frac{1}{2} \\sum_{k=1}^{N_s} (x_k - y_k)^2 \\\\\n\\text{subject to} \\quad  \\sum_{k=1}^{N_s} x_k = 1 \\\\\n\\text{and} \\quad  x_k \\ge 0, \\quad k=1, \\dots, N_s\n\\end{aligned}\n$$\nThis is a convex optimization problem, as the objective function is strictly convex and the feasible set $\\mathcal{S}$ is convex. Therefore, the Karush-Kuhn-Tucker (KKT) conditions are both necessary and sufficient for identifying the unique optimal solution $\\mathbf{x}^\\star = \\mathbf{y}^\\star$.\n\nTo apply the KKT conditions, we first construct the Lagrangian of the problem:\n$$\nL(\\mathbf{x}, \\lambda, \\boldsymbol{\\mu}) = \\frac{1}{2} \\sum_{k=1}^{N_s} (x_k - y_k)^2 - \\lambda \\left( \\sum_{k=1}^{N_s} x_k - 1 \\right) - \\sum_{k=1}^{N_s} \\mu_k x_k\n$$\nHere, $\\lambda$ is the Lagrange multiplier for the equality constraint, and $\\boldsymbol{\\mu} = (\\mu_1, \\dots, \\mu_{N_s})$ are the Lagrange multipliers for the non-negativity inequality constraints.\n\nThe KKT conditions for an optimal solution $\\mathbf{x}^\\star$ are:\n$1$. **Stationarity**: The gradient of the Lagrangian with respect to $\\mathbf{x}$ must vanish at $\\mathbf{x}^\\star$:\n$$\n\\frac{\\partial L}{\\partial x_k} = (x_k^\\star - y_k) - \\lambda - \\mu_k = 0 \\quad \\implies \\quad x_k^\\star = y_k + \\lambda + \\mu_k\n$$\n$2$. **Primal Feasibility**: The solution $\\mathbf{x}^\\star$ must satisfy the original constraints:\n$$\n\\sum_{k=1}^{N_s} x_k^\\star = 1 \\quad \\text{and} \\quad x_k^\\star \\ge 0\n$$\n$3$. **Dual Feasibility**: The inequality multipliers must be non-negative:\n$$\n\\mu_k \\ge 0\n$$\n$4$. **Complementary Slackness**: The product of each inequality multiplier and its corresponding constraint expression must be zero:\n$$\n\\mu_k x_k^\\star = 0\n$$\nFrom the complementary slackness condition, for each component $k$, either $x_k^\\star = 0$ or $\\mu_k = 0$.\n- If $x_k^\\star  0$, then we must have $\\mu_k = 0$. From the stationarity condition, this implies $x_k^\\star = y_k + \\lambda$.\n- If $x_k^\\star = 0$, then $\\mu_k \\ge 0$ is possible. From stationarity, $0 = y_k + \\lambda + \\mu_k$, which implies $\\mu_k = - (y_k + \\lambda)$. The dual feasibility condition $\\mu_k \\ge 0$ then requires $y_k + \\lambda \\le 0$.\n\nLet us define a scalar $\\theta = -\\lambda$. We can then combine these two cases into a single elegant expression. The condition $x_k^\\star = y_k + \\lambda$ becomes $x_k^\\star = y_k - \\theta$, and the condition $y_k + \\lambda \\le 0$ becomes $y_k - \\theta \\le 0$.\nThis allows us to express the optimal solution component-wise as:\n$$\nx_k^\\star = \\max(0, y_k - \\theta)\n$$\nThis expression elegantly enforces both non-negativity and the relationship derived from the stationarity and complementary slackness conditions. The remaining task is to determine the unknown scalar $\\theta$. This is accomplished by enforcing the final unsatisfied constraint, the primal feasibility condition $\\sum_{k=1}^{N_s} x_k^\\star = 1$:\n$$\n\\sum_{k=1}^{N_s} \\max(0, y_k - \\theta) = 1\n$$\nLet's define a function $g(\\theta) = \\sum_{k=1}^{N_s} \\max(0, y_k - \\theta)$. This function is continuous, piecewise-linear, and monotonically non-increasing. A unique value for $\\theta$ that solves $g(\\theta) = 1$ is guaranteed to exist.\n\nA direct search for $\\theta$ can be made highly efficient. Let us sort the components of the input vector $\\mathbf{y}$ in descending order: $y_{(1)} \\ge y_{(2)} \\ge \\dots \\ge y_{(N_s)}$. The function $g(\\theta)$ changes its linear form only at the values $\\theta = y_{(i)}$. Suppose we find an index $\\rho \\in \\{1, \\dots, N_s\\}$ such that for the optimal $\\theta$, we have $y_{(k)} - \\theta  0$ for $k \\le \\rho$ and $y_{(k)} - \\theta \\le 0$ for $k  \\rho$. Then the sum becomes:\n$$\n\\sum_{k=1}^{\\rho} (y_{(k)} - \\theta) = 1\n$$\nSolving for $\\theta$ yields:\n$$\n\\theta = \\frac{1}{\\rho} \\left( \\sum_{k=1}^{\\rho} y_{(k)} - 1 \\right)\n$$\nThe correct index $\\rho$ is the largest integer $j$ that satisfies the condition $y_{(j)} - \\theta_j  0$, where $\\theta_j$ is the value of $\\theta$ calculated using the first $j$ components. This leads to an efficient algorithm:\n\n$1$. Sort the input vector $\\mathbf{y}$ to get $\\mathbf{u}$ such that $u_1 \\ge u_2 \\ge \\dots \\ge u_{N_s}$.\n$2$. Compute the cumulative sums of $\\mathbf{u}$, let's say $\\text{csum}_j = \\sum_{i=1}^j u_i$.\n$3$. Find the largest index $\\rho \\in \\{1, \\dots, N_s\\}$ such that $u_\\rho - \\frac{1}{\\rho}(\\text{csum}_\\rho - 1)  0$.\n$4$. With this $\\rho$, calculate the optimal threshold $\\theta = \\frac{1}{\\rho}(\\text{csum}_\\rho - 1)$.\n$5$. The projected vector $\\mathbf{y}^\\star$ is then computed using the original (unsorted) vector $\\mathbf{y}$: $y_k^\\star = \\max(0, y_k - \\theta)$ for $k=1, \\dots, N_s$.\n\nOnce $\\mathbf{y}^\\star$ is computed, the deviation for a single cell is $d(\\mathbf{y}) = \\| \\mathbf{y} - \\mathbf{y}^\\star \\|_2$. The total deviation reduction for a test case is the sum of these deviations over all cells in that test case, since the deviation of the projected point from the simplex is, by definition, zero.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process test cases, compute projections, and report results.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1: valid and boundary realizable states\n        [\n            [0.1, 0.2, 0.3, 0.4],\n            [0.0, 0.0, 1.0, 0.0],\n            [1e-15, 0.5, 0.5 - 1e-15, 0.0]\n        ],\n        # Test Case 2: mild violations and sum errors\n        [\n            [0.2, -1e-8, 0.5, 0.3 + 1e-8],\n            [0.25, 0.25, 0.25, 0.26],\n            [-1e-12, 0.6, 0.4, 1e-12]\n        ],\n        # Test Case 3: severe overshoots and negativity\n        [\n            [1.2, -0.1, -0.05, -0.05, 0.0],\n            [0.8, 0.3, -0.1, 0.0, 0.0]\n        ],\n        # Test Case 4: strong sum deviations with nonnegative components\n        [\n            [0.4, 0.4, 0.4],\n            [0.3, 0.3, 0.3]\n        ]\n    ]\n\n    def project_to_simplex(y_in: np.ndarray) - np.ndarray:\n        \"\"\"\n        Projects a vector y_in onto the probability simplex.\n\n        The algorithm is derived from the KKT conditions for the Euclidean\n        projection onto the simplex, which results in finding a threshold\n        theta such that the projection is given by max(0, y - theta).\n\n        Args:\n            y_in: A 1D numpy array of species mass fractions.\n\n        Returns:\n            A 1D numpy array representing the projected vector on the simplex.\n        \"\"\"\n        n_s = len(y_in)\n        \n        # Vectors already on the simplex are common and can be checked quickly.\n        # This also handles the trivial case Ns=1 where y must be [1.0].\n        if np.all(y_in = 0) and np.isclose(np.sum(y_in), 1.0):\n            return y_in.copy()\n            \n        # Sort y in descending order.\n        u = np.sort(y_in)[::-1]\n        \n        # Compute cumulative sums.\n        cssv = np.cumsum(u)\n        \n        # Find the largest index rho for which the condition holds.\n        # The condition u_j - (1/j)(cssv_j - 1)  0 simplifies to\n        # j * u_j  cssv_j - 1 to avoid division inside the loop.\n        # We search from j=1 to Ns. In 0-based indexing, this is i=0 to Ns-1.\n        # 'indices' will contain all 0-based indices i that satisfy the condition.\n        indices = np.nonzero(u * np.arange(1, n_s + 1)  cssv - 1)[0]\n        \n        # The largest index rho corresponds to the last element in 'indices'.\n        rho_idx = indices[-1]\n        rho = rho_idx + 1\n        \n        # Compute the threshold theta.\n        theta = (cssv[rho_idx] - 1) / rho\n        \n        # Apply the threshold to the original vector.\n        y_star = np.maximum(0, y_in - theta)\n        \n        return y_star\n\n    total_reductions = []\n    for case in test_cases:\n        total_deviation_for_case = 0.0\n        for y_list in case:\n            y_vec = np.array(y_list, dtype=np.float64)\n            \n            # Project the vector onto the simplex.\n            y_star = project_to_simplex(y_vec)\n            \n            # Calculate the deviation d(y) = ||y - y*||_2. The deviation\n            # reduction is d(y) - d(y*), and since y* is on the simplex,\n            # its own projection is itself, so d(y*) = ||y* - y*||_2 = 0.\n            # Thus, the reduction is simply d(y).\n            deviation = np.linalg.norm(y_vec - y_star)\n            \n            total_deviation_for_case += deviation\n            \n        total_reductions.append(total_deviation_for_case)\n\n    # Format the final output string exactly as required.\n    formatted_results = [f\"{r:.6f}\" for r in total_reductions]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}