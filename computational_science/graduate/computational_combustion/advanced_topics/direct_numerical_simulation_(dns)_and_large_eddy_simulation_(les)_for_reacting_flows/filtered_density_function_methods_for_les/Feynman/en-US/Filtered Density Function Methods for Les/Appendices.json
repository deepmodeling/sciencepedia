{
    "hands_on_practices": [
        {
            "introduction": "The Filtered Density Function (FDF) method is fundamentally a statistical approach, representing subgrid scale distributions with a finite number of computational particles. A critical question for any practitioner is determining the number of particles $N$ required to achieve a desired level of accuracy. This exercise connects the number of particles to the statistical error of the simulation results by applying the Central Limit Theorem, providing a quantitative basis for balancing computational cost and precision in Large-Eddy Simulations .",
            "id": "4024881",
            "problem": "In a Large-Eddy Simulation (LES) of turbulent reacting flow, a particle-based Filtered Density Function (FDF) method is employed to estimate the Favre-filtered scalar field. The Favre-filtered scalar is defined by $\\tilde{\\phi} = \\overline{\\rho \\phi}/\\overline{\\rho}$, where $\\rho$ is the density, $\\phi$ is a scalar (e.g., mixture fraction), and the overbar denotes spatial filtering. Within a single LES control volume at a given time, you draw $N$ independent particle realizations $\\{\\phi_{i}\\}_{i=1}^{N}$ from the filtered density function, each representing equal mass and thus equal particle weight in the estimator. The Monte Carlo estimator of $\\tilde{\\phi}$, for equal masses, reduces to the simple sample mean $\\hat{\\tilde{\\phi}} = \\frac{1}{N}\\sum_{i=1}^{N}\\phi_{i}$.\n\nAssume the following scientifically justified conditions:\n- The particle samples are independent and identically distributed with finite variance, so that the Central Limit Theorem applies to $\\hat{\\tilde{\\phi}}$.\n- The subgrid scalar variance in this control volume, estimated from a prior step, is $\\operatorname{Var}(\\phi) = 2.5 \\times 10^{-3}$ (dimensionless).\n- You require a symmetric two-sided confidence interval for $\\tilde{\\phi}$ at confidence level $0.95$ whose half-width does not exceed $\\Delta = 1.0 \\times 10^{-3}$ (dimensionless).\n\nStarting from the Favre filtering definition and the Central Limit Theorem, derive how the statistical error of $\\hat{\\tilde{\\phi}}$ scales with $N$ and construct the corresponding normal-approximation confidence interval. Then determine the minimal integer $N$ such that the half-width of this interval is at most $\\Delta$ at confidence level $0.95$. Express your final answer as the single integer $N$.",
            "solution": "The problem requires determining the minimum number of particles, $N$, for a Monte Carlo estimation of a Favre-filtered scalar, $\\tilde{\\phi}$, to achieve a specified statistical precision. We begin by validating the problem statement.\n\n### Step 1: Extract Givens\n-   Favre-filtered scalar definition: $\\tilde{\\phi} = \\overline{\\rho \\phi}/\\overline{\\rho}$.\n-   Monte Carlo estimator for $\\tilde{\\phi}$: $\\hat{\\tilde{\\phi}} = \\frac{1}{N}\\sum_{i=1}^{N}\\phi_{i}$, where $\\{\\phi_{i}\\}_{i=1}^{N}$ are independent and identically distributed (i.i.d.) samples.\n-   The Central Limit Theorem (CLT) applies to $\\hat{\\tilde{\\phi}}$.\n-   Subgrid scalar variance: $\\operatorname{Var}(\\phi) = 2.5 \\times 10^{-3}$.\n-   Confidence level for a symmetric two-sided interval: $0.95$.\n-   Maximum allowed half-width of the confidence interval: $\\Delta = 1.0 \\times 10^{-3}$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded in the theory of Large-Eddy Simulation (LES) and Filtered Density Function (FDF) methods, a standard approach in computational combustion. The use of a Monte Carlo estimator and the application of the Central Limit Theorem are fundamental statistical principles correctly applied to this context. The problem is well-posed, providing all necessary information—the variance of the underlying distribution, the desired confidence level, and the required precision—to uniquely determine the sample size $N$. The language is objective and unambiguous. The problem is therefore deemed valid.\n\n### Step 3: Derivation and Solution\nThe Monte Carlo estimator for the Favre-filtered scalar $\\tilde{\\phi}$ is given as the sample mean of $N$ i.i.d. particle realizations $\\{\\phi_i\\}$:\n$$ \\hat{\\tilde{\\phi}} = \\frac{1}{N}\\sum_{i=1}^{N}\\phi_{i} $$\nThe samples $\\phi_i$ are drawn from a distribution whose mean is the true Favre-filtered scalar, $E[\\phi_i] = \\tilde{\\phi}$, and whose variance is the subgrid scalar variance, $\\sigma^2 = \\operatorname{Var}(\\phi)$.\n\nThe expected value of the estimator is:\n$$ E[\\hat{\\tilde{\\phi}}] = E\\left[\\frac{1}{N}\\sum_{i=1}^{N}\\phi_{i}\\right] = \\frac{1}{N}\\sum_{i=1}^{N}E[\\phi_{i}] = \\frac{1}{N}(N\\tilde{\\phi}) = \\tilde{\\phi} $$\nThis confirms that the estimator is unbiased.\n\nThe variance of the estimator, due to the independence of the samples, is:\n$$ \\operatorname{Var}(\\hat{\\tilde{\\phi}}) = \\operatorname{Var}\\left(\\frac{1}{N}\\sum_{i=1}^{N}\\phi_{i}\\right) = \\frac{1}{N^2}\\sum_{i=1}^{N}\\operatorname{Var}(\\phi_{i}) = \\frac{1}{N^2}(N\\sigma^2) = \\frac{\\sigma^2}{N} $$\nThe standard deviation of the estimator, known as the standard error, is $\\sigma_{\\hat{\\tilde{\\phi}}} = \\frac{\\sigma}{\\sqrt{N}}$. This demonstrates that the statistical error of the estimator scales with $N^{-1/2}$.\n\nAccording to the Central Limit Theorem, for a sufficiently large $N$, the distribution of the sample mean $\\hat{\\tilde{\\phi}}$ is approximately normal with mean $\\tilde{\\phi}$ and variance $\\frac{\\sigma^2}{N}$:\n$$ \\hat{\\tilde{\\phi}} \\sim \\mathcal{N}\\left(\\tilde{\\phi}, \\frac{\\sigma^2}{N}\\right) $$\nTo construct a confidence interval, we standardize the estimator to obtain a standard normal variable $Z$:\n$$ Z = \\frac{\\hat{\\tilde{\\phi}} - \\tilde{\\phi}}{\\sigma/\\sqrt{N}} \\sim \\mathcal{N}(0, 1) $$\nWe seek a symmetric two-sided confidence interval for $\\tilde{\\phi}$ at a confidence level of $1-\\alpha = 0.95$. This implies a significance level of $\\alpha = 0.05$. The interval is defined by:\n$$ P(-z_{\\alpha/2} \\le Z \\le z_{\\alpha/2}) = 1 - \\alpha $$\nwhere $z_{\\alpha/2}$ is the critical value from the standard normal distribution that leaves a tail probability of $\\alpha/2$. For our case, $\\alpha/2 = 0.025$. The corresponding critical value is $z_{0.025}$, which corresponds to a cumulative probability of $1 - 0.025 = 0.975$. The value is $z_{0.025} \\approx 1.96$.\n\nSubstituting the expression for $Z$ and rearranging the inequality to isolate $\\tilde{\\phi}$:\n$$ P\\left(\\hat{\\tilde{\\phi}} - z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{N}} \\le \\tilde{\\phi} \\le \\hat{\\tilde{\\phi}} + z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{N}}\\right) = 1 - \\alpha $$\nThe half-width of this confidence interval is the quantity added to and subtracted from the estimate $\\hat{\\tilde{\\phi}}$:\n$$ \\text{Half-width} = z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{N}} $$\nThe problem requires this half-width to be at most $\\Delta = 1.0 \\times 10^{-3}$:\n$$ z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{N}} \\le \\Delta $$\nWe can now solve this inequality for the minimum integer $N$. We are given:\n-   $\\operatorname{Var}(\\phi) = \\sigma^2 = 2.5 \\times 10^{-3}$\n-   $\\Delta = 1.0 \\times 10^{-3}$\n-   $z_{0.025} \\approx 1.96$\n\nFirst, we find the standard deviation $\\sigma$:\n$$ \\sigma = \\sqrt{\\sigma^2} = \\sqrt{2.5 \\times 10^{-3}} = \\sqrt{25 \\times 10^{-4}} = 5 \\times 10^{-2} = 0.05 $$\nSubstituting the known values into the inequality:\n$$ 1.96 \\times \\frac{0.05}{\\sqrt{N}} \\le 1.0 \\times 10^{-3} $$\nRearranging to solve for $\\sqrt{N}$:\n$$ \\sqrt{N} \\ge \\frac{1.96 \\times 0.05}{1.0 \\times 10^{-3}} $$\n$$ \\sqrt{N} \\ge \\frac{0.098}{10^{-3}} $$\n$$ \\sqrt{N} \\ge 98 $$\nSquaring both sides to find the condition on $N$:\n$$ N \\ge 98^2 $$\n$$ N \\ge 9604 $$\nSince $N$ must be an integer, the minimal number of particles required is $9604$.",
            "answer": "$$\\boxed{9604}$$"
        },
        {
            "introduction": "In FDF methods, particles must interact to model the physical process of micromixing, which drives scalars towards their mean value. This practice explores the Interaction by Exchange with the Mean (IEM) model, a foundational closure for scalar mixing. You will investigate a critical numerical artifact where a standard time-stepping scheme can produce unphysical scalar values, violating realizability, and then implement a common fix, highlighting the importance of robust numerical methods in computational modeling .",
            "id": "4024972",
            "problem": "You are tasked with constructing and analyzing a mathematically rigorous test to demonstrate that the Interaction by Exchange with the Mean (IEM) micromixing model used in Filtered Density Function (FDF) methods for Large-Eddy Simulation (LES) can violate realizability for a bounded scalar, and then showing how a modified IEM update with clipping enforces boundedness. The scalar of interest, denoted by $\\,\\xi\\,$, is physically bounded in the interval $\\,\\xi\\in[0,1]\\,$ (for example, a mixture fraction or a normalized progress variable). The analysis and computations must be performed in purely mathematical terms and must be understandable and implementable in software. All physical parameters must be given in units of seconds where appropriate.\n\nBegin from the following base:\n\n- The Large-Eddy Simulation (LES) filtered density function (FDF) framework represents the subfilter statistics of scalars by an ensemble of Lagrangian particles whose states sample the filtered density function in composition space.\n- The Interaction by Exchange with the Mean (IEM) micromixing model for a passive, bounded scalar $\\,\\xi\\,$ prescribes the continuous-in-time evolution for each Lagrangian sample as\n$$\n\\frac{d\\xi}{dt}=-\\frac{\\xi-\\tilde{\\xi}}{\\tau_{\\text{mix}}},\n$$\nwhere $\\,\\tilde{\\xi}\\,$ is the filtered (conditional) mean of $\\,\\xi\\,$ and $\\,\\tau_{\\text{mix}}\\,$ is the micromixing time scale expressed in seconds.\n\nYour tasks:\n\n1) Derive the explicit first-order time-discretized update for the IEM model applied to a single forward Euler step over a time increment $\\,\\Delta t\\,$ (in seconds). Use $\\,\\alpha=\\Delta t/\\tau_{\\text{mix}}\\,$ to express the update and identify the condition under which this discrete update remains a convex combination of the current sample value and the filtered mean, hence respecting realizability $\\,\\xi\\in[0,1]\\,$ for all samples initially in $\\, [0,1]\\,$ and $\\,\\tilde{\\xi}\\in[0,1]\\,$.\n\n2) Using only logic and algebra, and assuming the initial ensemble of particles has $\\,\\xi\\,$ uniformly distributed on $\\, [0,1]\\,$ and the filtered mean $\\,\\tilde{\\xi}=m\\in[0,1]\\,$ is constant over the time step, derive a closed-form expression for the fraction of samples that will lie outside $\\, [0,1]\\,$ after one explicit Euler IEM update when $\\,\\alpha>1\\,$. Your expression must separately account for the measure of samples that fall below $\\,0\\,$ and above $\\,1\\,$ and then combine them to produce the total fraction. No numerical integration or random sampling may be used in this derivation.\n\n3) Define a modified IEM update in which any sample value after the Euler update is clipped to the admissible interval $\\, [0,1]\\,$, i.e., replaced by $\\,\\max(0,\\min(1,\\xi^{\\text{new}}))\\,$. Explain why, under this modification, realizability is enforced for any $\\,\\alpha>0\\,$ and $\\,m\\in[0,1]\\,$ even though the unmodified explicit Euler update may violate realizability for $\\,\\alpha>1\\,$.\n\n4) Implement a program that, for each test case specified below, computes and outputs two quantities:\n   - The analytically derived fraction (as a decimal) of samples that violate $\\, [0,1]\\,$ after one unmodified explicit Euler IEM step.\n   - The fraction (as a decimal) of samples that violate $\\, [0,1]\\,$ after one modified IEM step with clipping.\n\nIn all cases use $\\,\\tau_{\\text{mix}}\\,$ and $\\,\\Delta t\\,$ in seconds, and express the final fractions as decimals.\n\nTest suite (each case provides $\\,(\\tau_{\\text{mix}},\\Delta t,m)\\,$):\n- Case 1 (happy path): $\\,\\tau_{\\text{mix}}=0.1\\,$ s, $\\,\\Delta t=0.01\\,$ s, $\\,m=0.5\\,$.\n- Case 2 (boundary condition): $\\,\\tau_{\\text{mix}}=0.02\\,$ s, $\\,\\Delta t=0.02\\,$ s, $\\,m=0.2\\,$.\n- Case 3 (lower-bound violation): $\\,\\tau_{\\text{mix}}=0.1\\,$ s, $\\,\\Delta t=0.2\\,$ s, $\\,m=0.3\\,$.\n- Case 4 (upper-bound violation): $\\,\\tau_{\\text{mix}}=0.05\\,$ s, $\\,\\Delta t=0.1\\,$ s, $\\,m=0.8\\,$.\n- Case 5 (both-side violation): $\\,\\tau_{\\text{mix}}=0.1\\,$ s, $\\,\\Delta t=0.3\\,$ s, $\\,m=0.5\\,$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, in order, for each case the two fractions $\\,[\\text{unmodified},\\text{modified}]\\,$ flattened across the five cases as\n$$\n[\\text{C1 unmodified},\\text{C1 modified},\\text{C2 unmodified},\\text{C2 modified},\\text{C3 unmodified},\\text{C3 modified},\\text{C4 unmodified},\\text{C4 modified},\\text{C5 unmodified},\\text{C5 modified}].\n$$\nAll numeric outputs must be decimals. No other text should be printed.",
            "solution": "This analysis addresses the realizability of the Interaction by Exchange with the Mean (IEM) micromixing model when integrated with an explicit first-order Euler scheme. The scalar $\\xi$ is bounded within the interval $[0,1]$. The continuous evolution of a Lagrangian sample $\\xi$ is given by the ordinary differential equation:\n$$\n\\frac{d\\xi}{dt}=-\\frac{\\xi-\\tilde{\\xi}}{\\tau_{\\text{mix}}}\n$$\nwhere $\\tilde{\\xi}$ is the filtered mean and $\\tau_{\\text{mix}}$ is the micromixing time scale.\n\n### 1. Discretization and Realizability Condition\n\nTo discretize the IEM equation, we apply a forward Euler scheme over a time step $\\Delta t$. Let $\\xi^n$ be the value of the scalar at time $t_n$ and $\\xi^{n+1}$ be the value at time $t_{n+1} = t_n + \\Delta t$. The time derivative is approximated as $\\frac{d\\xi}{dt} \\approx \\frac{\\xi^{n+1} - \\xi^n}{\\Delta t}$. Substituting this into the IEM equation gives:\n$$\n\\frac{\\xi^{n+1} - \\xi^n}{\\Delta t} = -\\frac{\\xi^n - \\tilde{\\xi}}{\\tau_{\\text{mix}}}\n$$\nSolving for $\\xi^{n+1}$, we obtain the explicit first-order update rule:\n$$\n\\xi^{n+1} = \\xi^n - \\frac{\\Delta t}{\\tau_{\\text{mix}}}(\\xi^n - \\tilde{\\xi})\n$$\nWe define the non-dimensional time step parameter $\\alpha = \\frac{\\Delta t}{\\tau_{\\text{mix}}}$. The update rule can then be written as:\n$$\n\\xi^{n+1} = \\xi^n - \\alpha(\\xi^n - \\tilde{\\xi})\n$$\nRearranging the terms to express $\\xi^{n+1}$ as a linear combination of $\\xi^n$ and $\\tilde{\\xi}$:\n$$\n\\xi^{n+1} = (1-\\alpha)\\xi^n + \\alpha\\tilde{\\xi}\n$$\nThis update represents a convex combination if the coefficients $(1-\\alpha)$ and $\\alpha$ are non-negative and sum to $1$. Their sum is $(1-\\alpha) + \\alpha = 1$. The non-negativity conditions are $\\alpha \\ge 0$ and $1-\\alpha \\ge 0$. Since $\\Delta t$ and $\\tau_{\\text{mix}}$ are both positive physical quantities, $\\alpha \\ge 0$ is always satisfied. The remaining condition for a convex combination is:\n$$\n1-\\alpha \\ge 0 \\implies \\alpha \\le 1\n$$\nIf this condition holds, i.e., $\\Delta t \\le \\tau_{\\text{mix}}$, and if both the current sample value $\\xi^n$ and the filtered mean $\\tilde{\\xi}$ are in the realizable interval $[0,1]$, then the new sample value $\\xi^{n+1}$ is guaranteed to also be in $[0,1]$. This is a fundamental property of convex combinations: they map a convex set (like the interval $[0,1]$) into itself. Thus, the condition $\\alpha \\le 1$ is sufficient to ensure realizability is respected by the discrete update.\n\n### 2. Analytical Fraction of Non-Realizable Samples\n\nWe now derive the fraction of samples that violate the bounds $[0,1]$ when $\\alpha > 1$. We assume the initial ensemble of particles has scalar values $\\xi_0$ that are uniformly distributed on $[0,1]$. The probability density function is $p(\\xi_0) = 1$ for $\\xi_0 \\in [0,1]$ and $p(\\xi_0) = 0$ otherwise. The filtered mean is constant, $\\tilde{\\xi} = m \\in [0,1]$.\nThe updated value is $\\xi_1 = (1-\\alpha)\\xi_0 + \\alpha m$. Since $\\alpha > 1$, the coefficient $(1-\\alpha)$ is negative.\n\nA sample becomes non-realizable if $\\xi_1 < 0$ or $\\xi_1 > 1$.\nThe fraction of samples violating the bounds is the measure of the set of $\\xi_0 \\in [0,1]$ for which $\\xi_1 \\notin [0,1]$.\n\n**Violation Below $0$**:\nThe condition is $\\xi_1 < 0$, which translates to:\n$$\n(1-\\alpha)\\xi_0 + \\alpha m < 0 \\implies (1-\\alpha)\\xi_0 < -\\alpha m\n$$\nSince $(1-\\alpha)$ is negative, dividing by it reverses the inequality:\n$$\n\\xi_0 > \\frac{-\\alpha m}{1-\\alpha} = \\frac{\\alpha m}{\\alpha-1}\n$$\nThe values of $\\xi_0$ in the initial $[0,1]$ range that cause this violation are those in the interval $(\\frac{\\alpha m}{\\alpha-1}, 1]$. The fraction of such samples, which is the length of this interval (as $p(\\xi_0)=1$), is non-zero only if $\\frac{\\alpha m}{\\alpha-1} < 1$. This fraction, $F_{<0}$, is:\n$$\nF_{<0} = \\max\\left(0, 1 - \\frac{\\alpha m}{\\alpha-1}\\right)\n$$\n\n**Violation Above $1$**:\nThe condition is $\\xi_1 > 1$, which translates to:\n$$\n(1-\\alpha)\\xi_0 + \\alpha m > 1 \\implies (1-\\alpha)\\xi_0 > 1 - \\alpha m\n$$\nAgain, dividing by the negative $(1-\\alpha)$ reverses the inequality:\n$$\n\\xi_0 < \\frac{1-\\alpha m}{1-\\alpha} = \\frac{\\alpha m-1}{\\alpha-1}\n$$\nThe values of $\\xi_0$ in $[0,1]$ that cause this violation are those in the interval $[0, \\frac{\\alpha m-1}{\\alpha-1})$. The fraction of such samples, $F_{>1}$, is non-zero only if $\\frac{\\alpha m-1}{\\alpha-1} > 0$. This fraction is:\n$$\nF_{>1} = \\max\\left(0, \\frac{\\alpha m-1}{\\alpha-1}\\right)\n$$\n\nThe two conditions on $\\xi_0$ are mutually exclusive, as $\\frac{\\alpha m}{\\alpha-1} > \\frac{\\alpha m-1}{\\alpha-1}$. Therefore, the total fraction of non-realizable samples, $F_{\\text{total}}$, is the sum of the fractions from the two cases:\n$$\nF_{\\text{total}}(\\alpha, m) = \\begin{cases} 0 & \\text{if } \\alpha \\le 1 \\\\ \\max\\left(0, 1 - \\frac{\\alpha m}{\\alpha-1}\\right) + \\max\\left(0, \\frac{\\alpha m - 1}{\\alpha-1}\\right) & \\text{if } \\alpha > 1 \\end{cases}\n$$\n\n### 3. Modified IEM Update with Clipping\n\nTo enforce realizability regardless of the value of $\\alpha$, the IEM update can be modified by applying a clipping operation. After computing the new value with the explicit Euler step, $\\xi^{\\text{new}} = (1-\\alpha)\\xi^n + \\alpha \\tilde{\\xi}$, it is forced back into the admissible interval $[0,1]$. The modified update is:\n$$\n\\xi^{\\text{new}}_{\\text{clipped}} = \\max(0, \\min(1, \\xi^{\\text{new}}))\n$$\nThis operation works in two steps:\n1. The inner function, $\\min(1, \\xi^{\\text{new}})$, ensures that any value greater than $1$ is replaced by $1$. The result of this step is always less than or equal to $1$.\n2. The outer function, $\\max(0, \\dots)$, ensures that any value less than $0$ is replaced by $0$. The result of this step is always greater than or equal to $0$.\n\nCombined, the clipping function maps any real number $\\xi^{\\text{new}}$ to the interval $[0,1]$. Consequently, for any positive $\\alpha$ and any initial $\\xi^n \\in [0,1]$ and $\\tilde{\\xi}=m \\in [0,1]$, the resulting scalar value $\\xi^{\\text{new}}_{\\text{clipped}}$ is guaranteed to be realizable. The fraction of samples that violate realizability after this modified step is, by definition, always $0$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_violation_fractions(tau_mix: float, delta_t: float, m: float) -> tuple[float, float]:\n    \"\"\"\n    Calculates the fraction of samples violating realizability for IEM model.\n\n    Args:\n        tau_mix: The micromixing time scale in seconds.\n        delta_t: The time step size in seconds.\n        m: The constant filtered mean, m = tilde{xi}.\n\n    Returns:\n        A tuple containing:\n        - The analytically derived fraction for the unmodified explicit Euler update.\n        - The fraction for the modified update with clipping.\n    \"\"\"\n    if tau_mix <= 0:\n        # Avoid division by zero, though problem constraints imply tau_mix > 0.\n        return 0.0, 0.0\n\n    alpha = delta_t / tau_mix\n    unmodified_fraction = 0.0\n\n    # The unmodified Euler step violates realizability only if alpha > 1.\n    if alpha > 1.0:\n        # Denominator for the violation expressions\n        denom = alpha - 1.0\n\n        # Fraction of samples that fall below 0\n        # This corresponds to initial xi_0 > (alpha * m) / (alpha - 1)\n        # The fraction is max(0, 1 - (alpha * m) / (alpha - 1))\n        frac_below_zero = np.maximum(0.0, 1.0 - (alpha * m) / denom)\n\n        # Fraction of samples that fall above 1\n        # This corresponds to initial xi_0 < (alpha * m - 1) / (alpha - 1)\n        # The fraction is max(0, (alpha * m - 1.0) / (alpha - 1))\n        frac_above_one = np.maximum(0.0, (alpha * m - 1.0) / denom)\n\n        # The two violation regions for initial xi_0 are disjoint,\n        # so the total fraction is their sum.\n        unmodified_fraction = frac_below_zero + frac_above_one\n\n    # The modified IEM update with clipping enforces realizability by construction.\n    # Therefore, the fraction of samples violating the bounds is always 0.\n    modified_fraction = 0.0\n\n    return unmodified_fraction, modified_fraction\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite and prints the results.\n    \"\"\"\n    # Test suite from the problem statement: (tau_mix, delta_t, m)\n    test_cases = [\n        (0.1, 0.01, 0.5),  # Case 1 (happy path, alpha < 1)\n        (0.02, 0.02, 0.2),  # Case 2 (boundary condition, alpha = 1)\n        (0.1, 0.2, 0.3),   # Case 3 (lower-bound violation, alpha > 1)\n        (0.05, 0.1, 0.8),   # Case 4 (upper-bound violation, alpha > 1)\n        (0.1, 0.3, 0.5),   # Case 5 (both-side violation, alpha > 1)\n    ]\n\n    results = []\n    for case in test_cases:\n        tau_mix, delta_t, m = case\n        unmod_frac, mod_frac = calculate_violation_fractions(tau_mix, delta_t, m)\n        results.append(unmod_frac)\n        results.append(mod_frac)\n\n    # Format the output as a single comma-separated list in brackets.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n\n```"
        },
        {
            "introduction": "Before a numerical solver can be trusted for complex simulations, it must be verified against known solutions. This practice guides you through a fundamental verification test for an FDF solver. By simulating the simple case of passive scalar transport, you will confirm that the filtered quantities calculated from the particle ensemble accurately reproduce the analytical solution, thereby building confidence in the core advection and filtering algorithms of your code .",
            "id": "4024992",
            "problem": "Consider a one-dimensional, periodic domain $[0,L]$ for a passive scalar field $\\phi(x,t)$ transported by a spatially uniform, divergence-free velocity $u$. The task is to verify that the particle-based Filtered Density Function (FDF) solver conserves filtered means by comparing the filtered scalar $\\tilde{\\phi}$ computed from a particle ensemble against the filtered scalar computed directly from the resolved Eulerian field in passive transport tests, within the framework of Large-Eddy Simulation (LES) and the Filtered Density Function (FDF) method.\n\nStart from the passive scalar transport equation under incompressible flow and passive advection,\n$$\\frac{\\partial \\phi}{\\partial t} + u \\frac{\\partial \\phi}{\\partial x} = 0,$$\nwith periodic boundary conditions on $[0,L]$ and an initial condition $\\phi_0(x)$ that is smooth and compatible with periodicity. The filtered scalar field is defined by spatial convolution with a homogeneous, normalized Gaussian filter kernel of standard deviation $\\sigma$,\n$$\\tilde{\\phi}(x,t) \\equiv \\int_{0}^{L} \\phi(\\xi,t)\\, G_{\\sigma}^{\\text{per}}(x-\\xi;L)\\, d\\xi,$$\nwhere $G_{\\sigma}^{\\text{per}}(r;L)$ is the periodized Gaussian,\n$$G_{\\sigma}^{\\text{per}}(r;L) = \\sum_{k\\in\\mathbb{Z}} \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac{(r + kL)^2}{2\\sigma^2}\\right),$$\nwhich is $L$-periodic in $r$ and integrates to $1$ over any interval of length $L$. The particle-based FDF estimate of the filtered scalar at $x$ is given by the Monte Carlo quadrature of the same convolution using $N$ particles, positions $X_p(t)$, scalar labels $\\phi_p(t)$, and quadrature weights $w_p$,\n$$\\tilde{\\phi}_{\\text{part}}(x,t) \\equiv \\sum_{p=1}^{N} w_p\\, \\phi_p(t)\\, G_{\\sigma}^{\\text{per}}(x - X_p(t);L).$$\nAssume uniform quadrature weights $w_p = L/N$, particle positions initialized to a uniform grid in $[0,L]$, and scalar labels set to the initial Eulerian field values at those positions. Under passive transport with uniform $u$, the particle positions evolve as $X_p(t) = X_p(0) + u t \\pmod{L}$, and scalar labels satisfy $d\\phi_p/dt = 0$ (no sources or sinks). The resolved Eulerian field satisfies $\\phi(x,t) = \\phi_0\\!\\big((x - u t) \\bmod L\\big)$.\n\nImplement a program that, for each test case, constructs:\n- A periodic domain of length $L$ and a uniform grid with $M$ points $x_i = iL/M$ for $i = 0,\\dots,M-1$.\n- An initial resolved field $\\phi_0(x) = \\sin(2\\pi n x/L) + c$, with integer mode $n$ and constant offset $c$.\n- A particle ensemble of $N$ uniformly spaced particles with initial positions $X_p(0) = (p + 1/2)\\,L/N$ for $p=0,\\dots,N-1$ and scalar labels $\\phi_p(0) = \\phi_0\\!\\big(X_p(0)\\big)$.\n- Uniform advection to time $t$ with velocity $u$, i.e., particle positions $X_p(t) = X_p(0) + u t \\pmod{L}$ and resolved field $\\phi(x_i,t) = \\phi_0\\!\\big((x_i - u t) \\bmod L\\big)$.\n- A normalized Gaussian filter with width parameter $\\Delta$ and standard deviation $\\sigma = \\Delta/2$, approximated by a truncated periodized form,\n$$G_{\\sigma,K}^{\\text{per}}(r;L) = \\sum_{k=-K}^{K} \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac{(r + kL)^2}{2\\sigma^2}\\right),$$\nwith $K$ chosen to ensure that terms outside $\\pm K$ contribute negligibly (for example, include all images within $\\pm 3\\sigma$).\n\nFor each test case, compute:\n- The filtered scalar from particles at all grid points $x_i$ as\n$$\\tilde{\\phi}_{\\text{part}}(x_i,t) \\approx \\sum_{p=1}^{N} \\frac{L}{N}\\,\\phi_p(0)\\, G_{\\sigma,K}^{\\text{per}}\\!\\big(x_i - X_p(t);L\\big).$$\n- The filtered scalar from the resolved field at all grid points $x_i$ as\n$$\\tilde{\\phi}_{\\text{field}}(x_i,t) \\approx \\sum_{j=0}^{M-1} \\frac{L}{M}\\,\\phi(x_j,t)\\, G_{\\sigma,K}^{\\text{per}}\\!\\big(x_i - x_j;L\\big).$$\n\nThen report, for each test case, the single scalar\n$$d_{\\max} = \\max_{i\\in\\{0,\\dots,M-1\\}} \\left| \\tilde{\\phi}_{\\text{part}}(x_i,t) - \\tilde{\\phi}_{\\text{field}}(x_i,t) \\right|,$$\nas a dimensionless float. This quantity should approach $0$ for sufficiently large $N$ and well-resolved filters and fields, reflecting conservation of the filtered mean under passive transport by the particle-based FDF solver.\n\nTest Suite:\nUse the following parameter sets, each expressed as an ordered tuple $(L,M,N,n,c,u,t,\\Delta)$.\n- Test $1$ (happy path): $(1,128,4096,3,0.2,0.3,0.1,0.1)$.\n- Test $2$ (small filter width): $(1,128,4096,5,0.0,0.25,0.2,0.01)$.\n- Test $3$ (wide filter): $(1,128,4096,7,0.5,0.1,0.3,0.5)$.\n- Test $4$ (zero velocity): $(1,128,4096,1,0.0,0.0,0.25,0.15)$.\n- Test $5$ (low particle count edge case): $(1,128,64,2,0.4,0.4,0.2,0.1)$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\dots]$), where each entry is the computed $d_{\\max}$ for the corresponding test case as a dimensionless float. No units or angle measures are required in the output. The program must be complete, deterministic, and runnable as is, without requiring any user input or external files.",
            "solution": "The verification is based on passive transport and the definition of filtering as a spatial convolution with a normalized kernel. The passive scalar satisfies the conservation law under uniform advection,\n$$\\frac{\\partial \\phi}{\\partial t} + u \\frac{\\partial \\phi}{\\partial x} = 0,$$\nwith domain $[0,L]$ periodic and $u$ constant. The solution advances by translation,\n$$\\phi(x,t) = \\phi_0\\!\\left((x - ut) \\bmod L\\right),$$\nwhich preserves the pointwise scalar magnitude along Lagrangian trajectories.\n\nThe filtered mean at $x$ and time $t$ is defined by a convolution with a normalized, homogeneous filter kernel. For a Gaussian filter of standard deviation $\\sigma$, the periodized kernel over $[0,L]$ is\n$$G_{\\sigma}^{\\text{per}}(r;L) = \\sum_{k\\in\\mathbb{Z}} \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac{(r + kL)^2}{2\\sigma^2}\\right),$$\nwhich is $L$-periodic and integrates to $1$ over any interval of length $L$. The filtered mean from the resolved field is\n$$\\tilde{\\phi}_{\\text{field}}(x,t) = \\int_{0}^{L} \\phi(\\xi,t)\\, G_{\\sigma}^{\\text{per}}(x-\\xi;L)\\, d\\xi.$$\n\nIn the particle-based Filtered Density Function (FDF) formulation, consider the empirical measure\n$$\\mu_N(t) = \\sum_{p=1}^{N} w_p\\, \\delta\\big(\\xi - X_p(t)\\big),$$\nwhere $X_p(t)$ are particle positions, $w_p$ are quadrature weights, and $\\delta$ is the Dirac delta distribution. The particle estimate of the filtered scalar is\n$$\\tilde{\\phi}_{\\text{part}}(x,t) = \\int_{0}^{L} \\phi(\\xi,t)\\, G_{\\sigma}^{\\text{per}}(x-\\xi;L)\\, d\\mu_N(t) = \\sum_{p=1}^{N} w_p\\, \\phi_p(t)\\, G_{\\sigma}^{\\text{per}}\\!\\big(x - X_p(t);L\\big),$$\nwhere $\\phi_p(t)$ is the scalar label on particle $p$. Under passive transport with uniform $u$, the label is conserved, $d\\phi_p/dt = 0$, and each particle is advected as $X_p(t) = X_p(0) + ut \\pmod{L}$. If the initial particle positions uniformly sample $[0,L]$ and $w_p = L/N$, the empirical measure $\\mu_N(0)$ converges weakly to the Lebesgue measure on $[0,L]$ as $N\\to\\infty$. Consequently, by the law of large numbers and the convergence of quadrature,\n$$\\lim_{N\\to\\infty} \\tilde{\\phi}_{\\text{part}}(x,t) = \\tilde{\\phi}_{\\text{field}}(x,t),$$\nfor each $x$ and $t$, provided $\\phi$ is sufficiently smooth and the filter kernel is normalized.\n\nAlgorithmic construction follows these principles:\n- Choose a smooth, periodic initial field $\\phi_0(x) = \\sin(2\\pi n x/L) + c$ on $[0,L]$.\n- Construct a uniform Eulerian grid $x_i = iL/M$ for $i=0,\\dots,M-1$ and a uniform particle grid $X_p(0) = (p+1/2)L/N$ for $p=0,\\dots,N-1$; set $\\phi_p(0) = \\phi_0\\!\\big(X_p(0)\\big)$.\n- Advect particles by $X_p(t) = X_p(0) + ut \\pmod{L}$ and compute the resolved Eulerian field at time $t$ by $\\phi(x_i,t) = \\phi_0\\!\\big((x_i - ut) \\bmod L\\big)$.\n- Approximate the periodized Gaussian filter by truncating its image sum to indices $k = -K,\\dots,K$ chosen to include images within $\\pm 3\\sigma$, which yields negligible truncation error for practical $\\sigma$ relative to $L$:\n$$G_{\\sigma,K}^{\\text{per}}(r;L) = \\sum_{k=-K}^{K} \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac{(r + kL)^2}{2\\sigma^2}\\right).$$\n- Compute the discrete filtered means by quadrature:\n$$\\tilde{\\phi}_{\\text{part}}(x_i,t) \\approx \\sum_{p=1}^{N} \\frac{L}{N}\\,\\phi_p(0)\\, G_{\\sigma,K}^{\\text{per}}\\!\\big(x_i - X_p(t);L\\big),$$\n$$\\tilde{\\phi}_{\\text{field}}(x_i,t) \\approx \\sum_{j=0}^{M-1} \\frac{L}{M}\\,\\phi(x_j,t)\\, G_{\\sigma,K}^{\\text{per}}\\!\\big(x_i - x_j;L\\big).$$\n- Measure the discrepancy as\n$$d_{\\max} = \\max_{i} \\left| \\tilde{\\phi}_{\\text{part}}(x_i,t) - \\tilde{\\phi}_{\\text{field}}(x_i,t) \\right|.$$\n\nUnder passive transport by uniform $u$, conservation of scalar labels and volume-preserving advection ensures that the particle-based estimator reproduces the filtered Eulerian field in the limit of sufficient resolution and particle count. The tests vary filter width $\\Delta$ (with $\\sigma = \\Delta/2$), wavenumber $n$, offset $c$, velocity $u$, advection time $t$, and particle count $N$, covering a general case, narrow and wide filters, zero velocity, and a low-particle edge case. The computed $d_{\\max}$ values are dimensionless floats, which should be near $0$ for well-resolved cases and can be larger for the low-particle edge case due to quadrature error.\n\nThe final program implements these steps deterministically and outputs a single line with the list $[d_{\\max}^{(1)}, d_{\\max}^{(2)}, d_{\\max}^{(3)}, d_{\\max}^{(4)}, d_{\\max}^{(5)}]$ for the specified test suite.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef periodized_gaussian_kernel_matrix(x, y, L, sigma):\n    \"\"\"\n    Compute the truncated periodized Gaussian kernel matrix G_sigma^per(x - y; L)\n    between arrays x (shape [M]) and y (shape [N]).\n    Uses images k in [-K, ..., K] where K = ceil(3*sigma/L).\n    Returns matrix of shape [M, N].\n    \"\"\"\n    # Ensure arrays\n    x = np.asarray(x, dtype=np.float64)\n    y = np.asarray(y, dtype=np.float64)\n    # Distances matrix\n    dist = x[:, None] - y[None, :]\n    # Choose number of images to include so that we cover +/- 3 sigma\n    K = max(1, int(np.ceil(3.0 * sigma / L)))\n    # Accumulate contributions from images\n    kernel = np.zeros_like(dist)\n    inv_norm = 1.0 / (np.sqrt(2.0 * np.pi) * sigma)\n    for k in range(-K, K + 1):\n        shifted = dist + k * L\n        kernel += np.exp(-0.5 * (shifted / sigma) ** 2)\n    kernel *= inv_norm\n    return kernel\n\ndef initial_field(x, L, n, c):\n    \"\"\"\n    Initial periodic scalar field phi0(x) = sin(2*pi*n*x/L) + c.\n    \"\"\"\n    return np.sin(2.0 * np.pi * n * x / L) + c\n\ndef advected_field_on_grid(x_grid, L, n, c, u, t):\n    \"\"\"\n    Resolved Eulerian field at time t: phi(x,t) = phi0((x - u t) mod L).\n    \"\"\"\n    shifted = (x_grid - u * t) % L\n    return initial_field(shifted, L, n, c)\n\ndef particle_positions_and_labels(L, N, n, c):\n    \"\"\"\n    Uniformly spaced particle initial positions and labels:\n    X_p(0) = (p + 1/2) * L / N, phi_p(0) = phi0(X_p(0)).\n    \"\"\"\n    p_indices = np.arange(N, dtype=np.float64)\n    X0 = (p_indices + 0.5) * L / N\n    phi_p0 = initial_field(X0, L, n, c)\n    return X0, phi_p0\n\ndef advect_particles(X0, L, u, t):\n    \"\"\"\n    Advect particle positions under uniform velocity u to time t with periodic wrap.\n    \"\"\"\n    return (X0 + u * t) % L\n\ndef filtered_from_particles(x_grid, X_t, phi_p0, L, sigma):\n    \"\"\"\n    Compute filtered scalar at grid points x_grid from particles at positions X_t with labels phi_p0.\n    Quadrature weight w_p = L / N.\n    \"\"\"\n    N = X_t.shape[0]\n    kernel = periodized_gaussian_kernel_matrix(x_grid, X_t, L, sigma)\n    weights = (L / N)\n    # Matrix-vector product (kernel @ phi_p0) then multiply by weights\n    return weights * (kernel @ phi_p0)\n\ndef filtered_from_field(x_grid, x_field, phi_field, L, sigma):\n    \"\"\"\n    Compute filtered scalar at grid points x_grid from resolved field samples (x_field, phi_field).\n    Quadrature weight w_j = L / M where M = len(x_field).\n    \"\"\"\n    M = x_field.shape[0]\n    kernel = periodized_gaussian_kernel_matrix(x_grid, x_field, L, sigma)\n    weights = (L / M)\n    return weights * (kernel @ phi_field)\n\ndef run_test_case(case):\n    \"\"\"\n    Run a single test case:\n    case = (L, M, N, n, c, u, t, Delta)\n    Returns d_max = max_i |phi_tilde_particles - phi_tilde_field|\n    \"\"\"\n    L, M, N, n, c, u, t, Delta = case\n    sigma = Delta / 2.0\n\n    # Grid points\n    x_grid = (np.arange(M, dtype=np.float64) * L) / M\n    # Field at time t on grid\n    phi_field_t = advected_field_on_grid(x_grid, L, n, c, u, t)\n\n    # Particle initial positions and labels\n    X0, phi_p0 = particle_positions_and_labels(L, N, n, c)\n    # Advect particles\n    X_t = advect_particles(X0, L, u, t)\n\n    # Compute filtered means\n    phi_tilde_particles = filtered_from_particles(x_grid, X_t, phi_p0, L, sigma)\n    phi_tilde_field = filtered_from_field(x_grid, x_grid, phi_field_t, L, sigma)\n\n    # Discrepancy\n    d_max = float(np.max(np.abs(phi_tilde_particles - phi_tilde_field)))\n    return d_max\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is (L, M, N, n, c, u, t, Delta)\n    test_cases = [\n        (1.0, 128, 4096, 3, 0.2, 0.3, 0.1, 0.1),   # Test 1: happy path\n        (1.0, 128, 4096, 5, 0.0, 0.25, 0.2, 0.01), # Test 2: small filter width\n        (1.0, 128, 4096, 7, 0.5, 0.1, 0.3, 0.5),   # Test 3: wide filter\n        (1.0, 128, 4096, 1, 0.0, 0.0, 0.25, 0.15), # Test 4: zero velocity\n        (1.0, 128, 64,   2, 0.4, 0.4, 0.2, 0.1),   # Test 5: low particle count edge case\n    ]\n\n    results = []\n    for case in test_cases:\n        d_max = run_test_case(case)\n        results.append(d_max)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}