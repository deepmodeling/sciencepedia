{
    "hands_on_practices": [
        {
            "introduction": "Before exploring complex physics, we must first build confidence in our numerical tools. This exercise  introduces the Method of Manufactured Solutions (MMS), a cornerstone of code verification in computational science. By inventing an analytical solution and deriving the corresponding source term, we can rigorously test whether our numerical solver accurately reproduces a known result. You will implement a finite difference solver for the 1D Artificially Thickened Flame (ATF) equations and quantify its error, ensuring your numerical framework is sound before applying it to more challenging problems.",
            "id": "4008204",
            "problem": "Consider a one-dimensional, steady, planar, premixed laminar flame in the flame-fixed frame, modeled by the Artificially Thickened Flame (ATF) approach. The ATF modifies physical transport and reaction to increase flame thickness by a thickening factor while preserving the laminar flame speed. In ATF, the effective diffusion is multiplied by a thickening factor $F1$, and the reaction rate is divided by $F$ and multiplied by a dynamic efficiency function $E$. In this problem, assume $E=1$ (constant efficiency equal to one). Let $x$ denote the spatial coordinate with units of meters, $t$ denote time with units of seconds, $T$ denote temperature with units of kelvin, and $\\tilde{c}$ denote a dimensionless progress variable that increases monotonically from the unburned state to the burned state.\n\nThe governing steady equations in the flame-fixed frame for the species progress variable and energy are, respectively:\n$$\n- S_L \\frac{d \\tilde{c}}{dx} = \\frac{d}{dx}\\left(F D \\frac{d \\tilde{c}}{dx}\\right) + \\frac{\\omega(x)}{F},\n$$\n$$\n- S_L \\rho c_p \\frac{d T}{dx} = \\frac{d}{dx}\\left(F k \\frac{d T}{dx}\\right) + \\frac{Q\\,\\omega(x)}{F},\n$$\nwhere $S_L$ is the laminar flame speed in $\\mathrm{m/s}$, $D$ is the molecular (species) diffusivity in $\\mathrm{m^2/s}$, $\\rho$ is the density in $\\mathrm{kg/m^3}$, $c_p$ is the specific heat at constant pressure in $\\mathrm{J/(kg\\,K)}$, $k$ is the thermal conductivity in $\\mathrm{W/(m\\,K)}$, $Q$ is the heat release per unit source rate in $\\mathrm{J/m^3}$, and $\\omega(x)$ is a volumetric source term in units consistent with the above equations.\n\nTo perform model verification via the Method of Manufactured Solutions (MMS), adopt the following manufactured analytic profiles over a symmetric domain $x \\in [-L/2, L/2]$:\n$$\n\\tilde{c}_{\\text{man}}(x) = \\frac{1}{2}\\left(1 + \\tanh\\!\\left(\\frac{x}{\\delta}\\right)\\right),\n\\quad\nT_{\\text{man}}(x) = T_u + (T_b - T_u)\\,\\tilde{c}_{\\text{man}}(x),\n$$\nwhere $\\delta$ is a prescribed characteristic thickness in meters, $T_u$ is the unburned temperature in kelvin, and $T_b$ is the burned temperature in kelvin. Let the thermal diffusivity satisfy the Lewis-number-equal-to-one constraint $k = \\rho c_p D$, and let $Q = \\rho c_p (T_b - T_u)$. Under these constraints, $T_{\\text{man}}(x)$ is consistent with the energy equation if $\\omega(x)$ is chosen to enforce the species equation for $\\tilde{c}_{\\text{man}}(x)$.\n\nTasks:\n1. Derive the source term $\\omega(x)$ that makes $\\tilde{c}_{\\text{man}}(x)$ satisfy the species equation for arbitrary $F1$ with the given constants $S_L$ and $D$.\n2. Using second-order central differences, discretize both the species and energy equations on a uniform grid with $N$ nodes over $[-L/2, L/2]$. Apply Dirichlet boundary conditions taken from the manufactured profiles at $x=-L/2$ and $x=+L/2$ for both $\\tilde{c}$ and $T$.\n3. Solve the resulting linear systems to obtain the numerical solutions $\\tilde{c}_{\\text{num}}(x_i)$ and $T_{\\text{num}}(x_i)$ at the grid nodes $\\{x_i\\}_{i=0}^{N-1}$ and compute the maximum absolute error for each field:\n$$\n\\varepsilon_{\\infty}^{(\\tilde{c})} = \\max_{0 \\le i \\le N-1} \\left|\\tilde{c}_{\\text{num}}(x_i) - \\tilde{c}_{\\text{man}}(x_i)\\right|,\n\\quad\n\\varepsilon_{\\infty}^{(T)} = \\max_{0 \\le i \\le N-1} \\left|T_{\\text{num}}(x_i) - T_{\\text{man}}(x_i)\\right|.\n$$\nReport $\\varepsilon_{\\infty}^{(\\tilde{c})}$ as a dimensionless float and $\\varepsilon_{\\infty}^{(T)}$ in kelvin.\n\nUse the following scientifically plausible constants in International System of Units (SI):\n- $S_L = 0.4$ in $\\mathrm{m/s}$,\n- $D = 1.0 \\times 10^{-4}$ in $\\mathrm{m^2/s}$,\n- $\\rho = 1.0$ in $\\mathrm{kg/m^3}$,\n- $c_p = 1000.0$ in $\\mathrm{J/(kg\\,K)}$,\n- $k = \\rho c_p D$ in $\\mathrm{W/(m\\,K)}$,\n- $T_u = 300.0$ in $\\mathrm{K}$,\n- $T_b = 1800.0$ in $\\mathrm{K}$,\n- $Q = \\rho c_p (T_b - T_u)$ in $\\mathrm{J/m^3}$,\n- $\\delta = 5.0 \\times 10^{-4}$ in $\\mathrm{m}$,\n- $L = 0.01$ in $\\mathrm{m}$.\n\nTest suite:\nEvaluate the program for the following parameter sets $(F,N)$ covering a typical case, near-minimal thickening, strong thickening, and coarse-grid resolution differences:\n- Case 1: $F=2.0$, $N=129$,\n- Case 2: $F=10.0$, $N=401$,\n- Case 3: $F=1.1$, $N=401$,\n- Case 4: $F=50.0$, $N=401$,\n- Case 5: $F=5.0$, $N=51$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, in order, the pair of floats for each case: the dimensionless $\\varepsilon_{\\infty}^{(\\tilde{c})}$ followed by the kelvin-valued $\\varepsilon_{\\infty}^{(T)}$. For example, the output format must be\n$$\n[\\varepsilon_{\\infty}^{(\\tilde{c})}(1),\\varepsilon_{\\infty}^{(T)}(1),\\varepsilon_{\\infty}^{(\\tilde{c})}(2),\\varepsilon_{\\infty}^{(T)}(2),\\dots,\\varepsilon_{\\infty}^{(\\tilde{c})}(5),\\varepsilon_{\\infty}^{(T)}(5)].\n$$",
            "solution": "The problem has been validated and is deemed scientifically grounded, well-posed, objective, and complete. All necessary data, equations, and conditions are provided, and they are consistent with established principles in computational combustion and numerical analysis. The Method of Manufactured Solutions (MMS) is a standard verification technique, and its application here is sound. The constants provided are physically realistic for a premixed flame. We may therefore proceed with the solution.\n\nThe solution involves three main tasks:\n1.  Deriving the analytical source term $\\omega(x)$ required by the Method of Manufactured Solutions.\n2.  Discretizing the governing partial differential equations using a finite difference method to obtain a system of linear algebraic equations.\n3.  Numerically solving these systems for the given test cases and computing the maximum absolute error against the manufactured solution.\n\n**1. Derivation of the Manufactured Source Term $\\omega(x)$**\n\nThe species progress variable equation in the Artificially Thickened Flame (ATF) model is given as:\n$$\n- S_L \\frac{d \\tilde{c}}{dx} = \\frac{d}{dx}\\!\\left(F D \\frac{d \\tilde{c}}{dx}\\right) + \\frac{\\omega(x)}{F}\n$$\nSince the thickening factor $F$ and the species diffusivity $D$ are constants, the equation simplifies to a constant-coefficient second-order ordinary differential equation (ODE):\n$$\n- S_L \\frac{d \\tilde{c}}{dx} = F D \\frac{d^2 \\tilde{c}}{dx^2} + \\frac{\\omega(x)}{F}\n$$\nThe Method of Manufactured Solutions requires us to find a source term $\\omega(x)$ that makes the manufactured profile $\\tilde{c}_{\\text{man}}(x)$ an exact solution to this ODE. We rearrange the equation to solve for $\\omega(x)$:\n$$\n\\frac{\\omega(x)}{F} = - S_L \\frac{d \\tilde{c}_{\\text{man}}}{dx} - F D \\frac{d^2 \\tilde{c}_{\\text{man}}}{dx^2}\n$$\n$$\n\\omega(x) = -F \\left( S_L \\frac{d \\tilde{c}_{\\text{man}}}{dx} + F D \\frac{d^2 \\tilde{c}_{\\text{man}}}{dx^2} \\right)\n$$\nThe manufactured solution is:\n$$\n\\tilde{c}_{\\text{man}}(x) = \\frac{1}{2}\\left(1 + \\tanh\\!\\left(\\frac{x}{\\delta}\\right)\\right)\n$$\nWe compute its first and second derivatives with respect to $x$:\nThe first derivative is:\n$$\n\\frac{d \\tilde{c}_{\\text{man}}}{dx} = \\frac{1}{2} \\cdot \\text{sech}^2\\!\\left(\\frac{x}{\\delta}\\right) \\cdot \\frac{1}{\\delta} = \\frac{1}{2\\delta} \\text{sech}^2\\!\\left(\\frac{x}{\\delta}\\right)\n$$\nThe second derivative is:\n$$\n\\frac{d^2 \\tilde{c}_{\\text{man}}}{dx^2} = \\frac{d}{dx}\\left(\\frac{1}{2\\delta} \\text{sech}^2\\!\\left(\\frac{x}{\\delta}\\right)\\right) = \\frac{1}{2\\delta} \\cdot 2\\,\\text{sech}\\!\\left(\\frac{x}{\\delta}\\right) \\cdot \\left(-\\text{sech}\\!\\left(\\frac{x}{\\delta}\\right)\\tanh\\!\\left(\\frac{x}{\\delta}\\right)\\right) \\cdot \\frac{1}{\\delta} = -\\frac{1}{\\delta^2} \\text{sech}^2\\!\\left(\\frac{x}{\\delta}\\right) \\tanh\\!\\left(\\frac{x}{\\delta}\\right)\n$$\nSubstituting these derivatives into the expression for $\\omega(x)$:\n$$\n\\omega(x) = -F \\left( S_L \\frac{1}{2\\delta} \\text{sech}^2\\!\\left(\\frac{x}{\\delta}\\right) - F D \\frac{1}{\\delta^2} \\text{sech}^2\\!\\left(\\frac{x}{\\delta}\\right) \\tanh\\!\\left(\\frac{x}{\\delta}\\right) \\right)\n$$\nFactoring out common terms, we obtain the final expression for the source term:\n$$\n\\omega(x) = F \\, \\text{sech}^2\\!\\left(\\frac{x}{\\delta}\\right) \\left( \\frac{F D}{\\delta^2} \\tanh\\!\\left(\\frac{x}{\\delta}\\right) - \\frac{S_L}{2\\delta} \\right)\n$$\nThis source term, when used in both the species and energy equations, ensures that $\\tilde{c}_{\\text{man}}(x)$ and $T_{\\text{man}}(x)$ are the exact analytical solutions to the continuous problem.\n\n**2. Discretization of the Governing Equations**\n\nWe discretize the domain $x \\in [-L/2, L/2]$ using a uniform grid with $N$ nodes, $x_i = -L/2 + i\\Delta x$ for $i = 0, 1, \\dots, N-1$, where the grid spacing is $\\Delta x = L/(N-1)$. We apply second-order central differences to approximate the derivatives at the interior nodes ($i=1, \\dots, N-2$):\n$$\n\\left(\\frac{d\\phi}{dx}\\right)_i \\approx \\frac{\\phi_{i+1} - \\phi_{i-1}}{2\\Delta x}, \\quad \\left(\\frac{d^2\\phi}{dx^2}\\right)_i \\approx \\frac{\\phi_{i+1} - 2\\phi_i + \\phi_{i-1}}{\\Delta x^2}\n$$\nwhere $\\phi$ can be either $\\tilde{c}$ or $T$.\n\n**Species Equation for $\\tilde{c}$:**\nSubstituting the finite difference approximations into the species equation $-S_L \\frac{d\\tilde{c}}{dx} = F D \\frac{d^2\\tilde{c}}{dx^2} + \\frac{\\omega(x)}{F}$ gives:\n$$\n-S_L \\left(\\frac{\\tilde{c}_{i+1} - \\tilde{c}_{i-1}}{2\\Delta x}\\right) = F D \\left(\\frac{\\tilde{c}_{i+1} - 2\\tilde{c}_i + \\tilde{c}_{i-1}}{\\Delta x^2}\\right) + \\frac{\\omega(x_i)}{F}\n$$\nGrouping the terms for $\\tilde{c}_{i-1}$, $\\tilde{c}_i$, and $\\tilde{c}_{i+1}$, we get a linear equation for each interior node $i$:\n$$\n\\left(\\frac{FD}{\\Delta x^2} - \\frac{S_L}{2\\Delta x}\\right)\\tilde{c}_{i-1} - \\left(\\frac{2FD}{\\Delta x^2}\\right)\\tilde{c}_i + \\left(\\frac{FD}{\\Delta x^2} + \\frac{S_L}{2\\Delta x}\\right)\\tilde{c}_{i+1} = -\\frac{\\omega(x_i)}{F}\n$$\nThis can be written as $a_c \\tilde{c}_{i-1} + b_c \\tilde{c}_i + d_c \\tilde{c}_{i+1} = r_{c,i}$ where:\n- $a_c = \\frac{FD}{\\Delta x^2} - \\frac{S_L}{2\\Delta x}$\n- $b_c = -\\frac{2FD}{\\Delta x^2}$\n- $d_c = \\frac{FD}{\\Delta x^2} + \\frac{S_L}{2\\Delta x}$\n- $r_{c,i} = -\\frac{\\omega(x_i)}{F}$\n\n**Energy Equation for $T$:**\nSimilarly, for the energy equation $- S_L \\rho c_p \\frac{dT}{dx} = F k \\frac{d^2T}{dx^2} + \\frac{Q\\,\\omega(x)}{F}$:\n$$\n-S_L \\rho c_p \\left(\\frac{T_{i+1} - T_{i-1}}{2\\Delta x}\\right) = F k \\left(\\frac{T_{i+1} - 2T_i + T_{i-1}}{\\Delta x^2}\\right) + \\frac{Q\\omega(x_i)}{F}\n$$\nGrouping terms:\n$$\n\\left(\\frac{Fk}{\\Delta x^2} - \\frac{S_L \\rho c_p}{2\\Delta x}\\right)T_{i-1} - \\left(\\frac{2Fk}{\\Delta x^2}\\right)T_i + \\left(\\frac{Fk}{\\Delta x^2} + \\frac{S_L \\rho c_p}{2\\Delta x}\\right)T_{i+1} = - \\frac{Q\\omega(x_i)}{F}\n$$\nThis can be written as $a_T T_{i-1} + b_T T_i + d_T T_{i+1} = r_{T,i}$ where:\n- $a_T = \\frac{Fk}{\\Delta x^2} - \\frac{S_L \\rho c_p}{2\\Delta x}$\n- $b_T = -\\frac{2Fk}{\\Delta x^2}$\n- $d_T = \\frac{Fk}{\\Delta x^2} + \\frac{S_L \\rho c_p}{2\\Delta x}$\n- $r_{T,i} = -\\frac{Q\\omega(x_i)}{F}$\n\n**3. Numerical Solution Procedure**\n\nFor both $\\tilde{c}$ and $T$, we have a system of $N-2$ linear equations for the $N-2$ unknown interior nodal values. These systems are tridiagonal. The boundary values are specified by Dirichlet conditions taken from the manufactured solutions: $\\tilde{c}_0=\\tilde{c}_{\\text{man}}(x_0)$, $\\tilde{c}_{N-1}=\\tilde{c}_{\\text{man}}(x_{N-1})$, and similarly for $T$.\n\nThe system for $\\tilde{c}$ takes the form $\\mathbf{A}_c \\mathbf{x}_c = \\mathbf{b}_c$, where $\\mathbf{x}_c = [\\tilde{c}_1, \\dots, \\tilde{c}_{N-2}]^T$. The first and last equations are modified to account for the boundary conditions:\n- For $i=1$: $b_c \\tilde{c}_1 + d_c \\tilde{c}_2 = r_{c,1} - a_c \\tilde{c}_0$\n- For $i=N-2$: $a_c \\tilde{c}_{N-3} + b_c \\tilde{c}_{N-2} = r_{c,N-2} - d_c \\tilde{c}_{N-1}$\n\nThe procedure for the temperature $T$ is identical. We construct the corresponding tridiagonal matrix $\\mathbf{A}_T$ and right-hand side vector $\\mathbf{b}_T$ and solve for the interior temperature values.\n\nAfter solving the linear systems for the interior nodes, the full numerical solutions $\\tilde{c}_{\\text{num}}$ and $T_{\\text{num}}$ are assembled. The maximum absolute errors are then computed as specified:\n$$\n\\varepsilon_{\\infty}^{(\\tilde{c})} = \\max_{i} |\\tilde{c}_{\\text{num}}(x_i) - \\tilde{c}_{\\text{man}}(x_i)|, \\quad \\varepsilon_{\\infty}^{(T)} = \\max_{i} |T_{\\text{num}}(x_i) - T_{\\text{man}}(x_i)|\n$$\nThis process is repeated for each pair of parameters $(F, N)$ provided in the test suite. The analytical relations $k = \\rho c_p D$ and $T_{\\text{man}}(x) = T_u + (T_b - T_u)\\tilde{c}_{\\text{man}}(x)$ imply that the numerical error in temperature should be related to the error in the progress variable by $\\varepsilon^{(T)} \\approx (T_b - T_u)\\varepsilon^{(\\tilde{c})}$, which serves as a robust check on the implementation.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D ATF equations using the Method of Manufactured Solutions.\n    \"\"\"\n    # Define physical and model constants\n    constants = {\n        'S_L': 0.4,       # m/s\n        'D': 1.0e-4,      # m^2/s\n        'rho': 1.0,       # kg/m^3\n        'c_p': 1000.0,    # J/(kg.K)\n        'T_u': 300.0,     # K\n        'T_b': 1800.0,    # K\n        'delta': 5.0e-4,  # m\n        'L': 0.01         # m\n    }\n    # Derived constants\n    constants['k'] = constants['rho'] * constants['c_p'] * constants['D']\n    constants['Q'] = constants['rho'] * constants['c_p'] * (constants['T_b'] - constants['T_u'])\n\n    # Test suite\n    test_cases = [\n        (2.0, 129),\n        (10.0, 401),\n        (1.1, 401),\n        (50.0, 401),\n        (5.0, 51),\n    ]\n\n    all_results = []\n    for F, N in test_cases:\n        error_c, error_T = solve_case(F, N, constants)\n        all_results.extend([error_c, error_T])\n\n    # Print results in the specified format\n    print(f\"[{','.join(map(str, all_results))}]\")\n\ndef solve_case(F, N, const):\n    \"\"\"\n    Solves for a single (F, N) case.\n    \"\"\"\n    # Grid setup\n    x = np.linspace(-const['L'] / 2.0, const['L'] / 2.0, N)\n    dx = const['L'] / (N - 1)\n\n    # Manufactured solutions\n    tanh_x_delta = np.tanh(x / const['delta'])\n    c_man = 0.5 * (1.0 + tanh_x_delta)\n    T_man = const['T_u'] + (const['T_b'] - const['T_u']) * c_man\n\n    # Calculate manufactured source term omega(x)\n    sech_sq_x_delta = (1.0 / np.cosh(x / const['delta']))**2\n    term1 = F * const['D'] / const['delta']**2 * tanh_x_delta\n    term2 = const['S_L'] / (2.0 * const['delta'])\n    omega = F * sech_sq_x_delta * (term1 - term2)\n\n    # --- Solve for progress variable c ---\n    \n    # Coefficients for the tridiagonal matrix for c\n    a_c = (F * const['D'] / dx**2) - (const['S_L'] / (2.0 * dx))\n    b_c = -2.0 * F * const['D'] / dx**2\n    d_c = (F * const['D'] / dx**2) + (const['S_L'] / (2.0 * dx))\n    \n    # Setup linear system Ac * x_c = bc for interior nodes\n    n_interior = N - 2\n    Ac = np.zeros((n_interior, n_interior))\n    np.fill_diagonal(Ac, b_c)\n    np.fill_diagonal(Ac[1:], a_c)\n    np.fill_diagonal(Ac[:, 1:], d_c)\n\n    # RHS vector for c\n    r_c_interior = -omega[1:-1] / F\n    bc = np.copy(r_c_interior)\n    bc[0] -= a_c * c_man[0]\n    bc[-1] -= d_c * c_man[-1]\n    \n    # Solve for interior c values\n    c_interior_num = np.linalg.solve(Ac, bc)\n    \n    # Assemble full numerical solution for c\n    c_num = np.concatenate(([c_man[0]], c_interior_num, [c_man[-1]]))\n    \n    # Compute max absolute error for c\n    error_c = np.max(np.abs(c_num - c_man))\n\n    # --- Solve for temperature T ---\n\n    # Coefficients for the tridiagonal matrix for T\n    a_T = (F * const['k'] / dx**2) - (const['S_L'] * const['rho'] * const['c_p'] / (2.0 * dx))\n    b_T = -2.0 * F * const['k'] / dx**2\n    d_T = (F * const['k'] / dx**2) + (const['S_L'] * const['rho'] * const['c_p'] / (2.0 * dx))\n\n    # Setup linear system AT * x_T = bT for interior nodes\n    AT = np.zeros((n_interior, n_interior))\n    np.fill_diagonal(AT, b_T)\n    np.fill_diagonal(AT[1:], a_T)\n    np.fill_diagonal(AT[:, 1:], d_T)\n\n    # RHS vector for T\n    r_T_interior = -const['Q'] * omega[1:-1] / F\n    bT = np.copy(r_T_interior)\n    bT[0] -= a_T * T_man[0]\n    bT[-1] -= d_T * T_man[-1]\n\n    # Solve for interior T values\n    T_interior_num = np.linalg.solve(AT, bT)\n\n    # Assemble full numerical solution for T\n    T_num = np.concatenate(([T_man[0]], T_interior_num, [T_man[-1]]))\n    \n    # Compute max absolute error for T\n    error_T = np.max(np.abs(T_num - T_man))\n\n    return error_c, error_T\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "A robust physical model must behave correctly in well-understood physical limits. For the Artificially Thickened Flame (ATF) model, it is crucial that as the thickening factor $F$ approaches one, the model's predictions revert to those of the baseline, unthickened flame. This practice  provides a framework to numerically test this fundamental consistency. You will investigate how the dynamic efficiency function $E$ and the modeled flame speed $c_{\\mathrm{ATF}}$ behave as $F \\to 1$, confirming that the model formulation correctly removes the artificial effects when they are no longer needed.",
            "id": "4008192",
            "problem": "Consider a one-dimensional premixed flame modeled at large scales by a reaction–diffusion equation of Kolmogorov–Petrovsky–Piskunov (KPP) type. In dimensionless form, the unthickened baseline model uses a molecular diffusivity $D_0$ and a linearized reaction rate $R_0$, for which the minimal traveling-wave speed is a well-tested result given by $c_{\\mathrm{KPP}} = 2 \\sqrt{D_0 R_0}$. In computations on a grid with spacing $dx$, numerical discretization induces an additional effective diffusion $D_{\\mathrm{num}}(dx)$ that can be modeled to leading order as $D_{\\mathrm{num}}(dx) = k_{\\mathrm{num}} \\, dx^2$, where $k_{\\mathrm{num}}$ is a dimensionless constant characterizing the scheme. Thus, the baseline effective wave speed is modeled as\n$$\nc_{\\mathrm{base}}(dx) = 2 \\, \\sqrt{ \\big( D_0 + D_{\\mathrm{num}}(dx) \\big) \\, R_0 }.\n$$\nIn an Artificially Thickened Flame (ATF) approach with thickening factor $F \\ge 1$, the diffusive term is multiplied by $F$ and the reaction term is divided by $F$ to preserve the laminar speed at the continuous level, but the discretization and filtering modify the outcome. We consider a dynamic efficiency function $E(F,dx,\\text{filter})$ that scales the reaction source to partially compensate the interaction of thickening with numerical diffusion and filtering. Let the model include a filter-induced diffusion $D_{\\mathrm{fil}}(F,dx,\\text{filter})$ determined by a user-chosen filter. We assume a partial compensation model for the dynamic efficiency,\n$$\nE(F,dx,\\text{filter}) \\;=\\; \\frac{F \\, \\big( D_0 + D_{\\mathrm{num}}(dx) \\big)}{F \\, D_0 + D_{\\mathrm{num}}(dx) + \\theta \\, D_{\\mathrm{fil}}(F,dx,\\text{filter})},\n$$\nwhere $0 \\le \\theta \\le 1$ is a dimensionless compensation factor. The modeled ATF wave speed is then\n$$\nc_{\\mathrm{ATF}}(F,dx,\\text{filter}) \\;=\\; 2 \\, \\sqrt{ \\Big( F \\, D_0 + D_{\\mathrm{num}}(dx) + D_{\\mathrm{fil}}(F,dx,\\text{filter}) \\Big) \\, \\frac{E(F,dx,\\text{filter}) \\, R_0}{F} }.\n$$\nFor consistency of the artificially thickened flame method with dynamic efficiency functions, as the thickening factor $F \\to 1$ and the filter is smoothly reduced with $F \\to 1$, one must have $E \\to 1$ and $c_{\\mathrm{ATF}} \\to c_{\\mathrm{base}}$. You will implement a numerical consistency test that explicitly demonstrates this limit under different choices of grid resolution, filter, and compensation level.\n\nYour task is to write a complete, runnable program that:\n- Implements the formulas above in dimensionless units (all quantities are dimensionless).\n- Uses the following base definitions and modeling assumptions:\n  - Baseline parameters: $D_0 = 1$, $R_0 = 1$.\n  - Numerical diffusion model: $D_{\\mathrm{num}}(dx) = k_{\\mathrm{num}} \\, dx^2$ with $k_{\\mathrm{num}}$ provided per test.\n  - Two filter choices are permitted:\n    - No filter: $D_{\\mathrm{fil}}(F,dx,\\text{none}) = 0$.\n    - Helmholtz filter: $D_{\\mathrm{fil}}(F,dx,\\text{helmholtz}) = \\alpha_0 \\, (F - 1) \\, dx^2$, where $\\alpha_0$ is a dimensionless constant and the filter is smoothly switched off as $F \\to 1$ by the factor $(F-1)$.\n  - Dynamic efficiency function: $E(F,dx,\\text{filter})$ defined by the formula above with a specified $\\theta \\in [0,1]$.\n- For each provided test case, evaluates a sequence of thickening factors $F_i$ that decreases toward $1$ and computes:\n  - The sequence $E(F_i,dx,\\text{filter})$.\n  - The relative wave-speed error sequence\n    $$\n    \\varepsilon_i \\;=\\; \\frac{\\big| c_{\\mathrm{ATF}}(F_i,dx,\\text{filter}) - c_{\\mathrm{base}}(dx) \\big|}{c_{\\mathrm{base}}(dx)}.\n    $$\n- Reports, for each test case, a triple of values:\n  - $E$ evaluated at $F=1$ (denoted $E_{F{=}1}$).\n  - The relative wave-speed error at $F=1$ (denoted $\\varepsilon_{F{=}1}$).\n  - A monotonicity flag $m$ equal to $1$ if the sequence $\\{\\varepsilon_i\\}$ is nonincreasing as $F_i \\downarrow 1$ and equal to $0$ otherwise.\n- All outputs are dimensionless.\n\nUse the following test suite, which covers a general case, a finer grid resolution, an edge case without filtering, and a stronger filter with more complete compensation:\n- Test case $1$ (general, moderate grid and partial compensation): $dx = 0.01$, $k_{\\mathrm{num}} = 0.5$, filter type $=$ Helmholtz with $\\alpha_0 = 3.0$, $\\theta = 0.6$, $F\\text{-list} = [5.0,\\,3.0,\\,2.0,\\,1.2,\\,1.0]$.\n- Test case $2$ (finer grid, partial compensation): $dx = 0.002$, $k_{\\mathrm{num}} = 0.5$, filter type $=$ Helmholtz with $\\alpha_0 = 3.0$, $\\theta = 0.6$, $F\\text{-list} = [4.0,\\,2.0,\\,1.5,\\,1.2,\\,1.0]$.\n- Test case $3$ (no filter): $dx = 0.01$, $k_{\\mathrm{num}} = 0.5$, filter type $=$ none, $\\theta = 0.6$ (unused here), $F\\text{-list} = [6.0,\\,3.0,\\,1.5,\\,1.1,\\,1.0]$.\n- Test case $4$ (stronger filter, higher compensation): $dx = 0.01$, $k_{\\mathrm{num}} = 0.5$, filter type $=$ Helmholtz with $\\alpha_0 = 8.0$, $\\theta = 0.9$, $F\\text{-list} = [5.0,\\,2.5,\\,1.5,\\,1.2,\\,1.0]$.\n\nYour program should:\n- Compute the triple $[E_{F{=}1},\\, \\varepsilon_{F{=}1},\\, m]$ for each of the $4$ test cases.\n- Produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a list formatted without spaces and with all floating-point numbers rounded to $10$ decimal places. The final output format must therefore be\n`[[r1_1,r1_2,r1_3],[r2_1,r2_2,r2_3],[r3_1,r3_2,r3_3],[r4_1,r4_2,r4_3]]`\nwhere each inner list is of the form\n`[E_F=1,err_F=1,m]`\nwith no spaces, for example\n`[[1.0000000000,0.0000000000,1],[...],[...],[...]]`.\n\nAll computations are to be performed in dimensionless units and all reported values are dimensionless floats except the monotonicity flag $m$, which is an integer.",
            "solution": "The user has provided a problem to validate and solve, concerning the numerical consistency of an Artificially Thickened Flame (ATF) model from the field of computational combustion. The validation and solution are presented below.\n\n### Step 1: Problem Validation\n\nThe problem is critically evaluated against the specified criteria.\n\n**Extracted Givens:**\n*   **Physical Model**: A one-dimensional Kolmogorov–Petrovsky–Piskunov (KPP) type reaction–diffusion equation for a premixed flame.\n*   **Baseline Parameters**: Dimensionless molecular diffusivity $D_0 = 1$, dimensionless linearized reaction rate $R_0 = 1$.\n*   **Discretization Parameters**: Grid spacing $dx$, numerical diffusion coefficient $k_{\\mathrm{num}}$.\n*   **Model Equations**:\n    *   Numerical Diffusion: $D_{\\mathrm{num}}(dx) = k_{\\mathrm{num}} \\, dx^2$.\n    *   Baseline Wave Speed: $c_{\\mathrm{base}}(dx) = 2 \\, \\sqrt{ ( D_0 + D_{\\mathrm{num}}(dx) ) \\, R_0 }$.\n    *   Thickening Factor: $F \\ge 1$.\n    *   Filter-Induced Diffusion models:\n        *   `none`: $D_{\\mathrm{fil}}(F,dx,\\text{none}) = 0$.\n        *   `helmholtz`: $D_{\\mathrm{fil}}(F,dx,\\text{helmholtz}) = \\alpha_0 \\, (F - 1) \\, dx^2$.\n    *   Dynamic Efficiency Function: $E(F,dx,\\text{filter}) = \\frac{F \\, ( D_0 + D_{\\mathrm{num}}(dx) )}{F \\, D_0 + D_{\\mathrm{num}}(dx) + \\theta \\, D_{\\mathrm{fil}}(F,dx,\\text{filter})}$, with compensation factor $0 \\le \\theta \\le 1$.\n    *   ATF Wave Speed: $c_{\\mathrm{ATF}}(F,dx,\\text{filter}) = 2 \\, \\sqrt{ ( F D_0 + D_{\\mathrm{num}}(dx) + D_{\\mathrm{fil}}(F,dx,\\text{filter}) ) \\, \\frac{E(F,dx,\\text{filter}) R_0}{F} }$.\n*   **Task Definition**:\n    *   Compute relative wave-speed error: $\\varepsilon_i = \\frac{| c_{\\mathrm{ATF}}(F_i,dx,\\text{filter}) - c_{\\mathrm{base}}(dx) |}{c_{\\mathrm{base}}(dx)}$ for a decreasing sequence of $F_i$ values.\n    *   For each test case, report the triple $[E_{F=1}, \\varepsilon_{F=1}, m]$, where $E_{F=1}$ and $\\varepsilon_{F=1}$ are the values at $F=1$, and $m$ is a monotonicity flag ($1$ for non-increasing error, $0$ otherwise).\n*   **Test Cases**:\n    1.  $dx = 0.01$, $k_{\\mathrm{num}} = 0.5$, filter=Helmholtz, $\\alpha_0 = 3.0$, $\\theta = 0.6$, $F\\text{-list} = [5.0, 3.0, 2.0, 1.2, 1.0]$.\n    2.  $dx = 0.002$, $k_{\\mathrm{num}} = 0.5$, filter=Helmholtz, $\\alpha_0 = 3.0$, $\\theta = 0.6$, $F\\text{-list} = [4.0, 2.0, 1.5, 1.2, 1.0]$.\n    3.  $dx = 0.01$, $k_{\\mathrm{num}} = 0.5$, filter=none, $\\theta = 0.6$, $F\\text{-list} = [6.0, 3.0, 1.5, 1.1, 1.0]$.\n    4.  $dx = 0.01$, $k_{\\mathrm{num}} = 0.5$, filter=Helmholtz, $\\alpha_0 = 8.0$, $\\theta = 0.9$, $F\\text{-list} = [5.0, 2.5, 1.5, 1.2, 1.0]$.\n\n**Validation Verdict:**\nThe problem is **valid**.\n*   **Scientifically Grounded**: The problem is based on established concepts in computational combustion, specifically Large Eddy Simulation (LES) using the Artificially Thickened Flame (ATF) model. The KPP equation and the modeling of numerical and sub-grid scale effects are standard in the field.\n*   **Well-Posed**: All necessary parameters, models, and equations are explicitly provided for each test case. The task is a direct computation that yields a unique result.\n*   **Objective**: The problem is stated in precise, quantitative, and unbiased technical language.\n*   The problem is free of any of the specified flaws (e.g., contradictions, ambiguity, infeasibility). The requirement for the filter to be \"smoothly reduced as $F \\to 1$\" is satisfied by the given filter models, as $D_{\\mathrm{fil}} \\to 0$ in both the `none` case (where it is always $0$) and the `helmholtz` case (where it is proportional to $F-1$).\n\n### Step 2: Solution\n\nThe task is to implement a numerical consistency test for the provided ATF model. The solution requires the systematic calculation of several quantities for a set of test parameters.\n\n**Theoretical Analysis of the Consistency Limit ($F \\to 1$)**\nBefore implementation, it is instructive to analyze the behavior of the model as the thickening factor $F$ approaches $1$. The consistency of the ATF method demands that the thickened flame speed $c_{\\mathrm{ATF}}$ reverts to the baseline discretized flame speed $c_{\\mathrm{base}}$.\n\n1.  **Filter Diffusion**: For both specified filter types, the filter-induced diffusion $D_{\\mathrm{fil}}$ vanishes as $F \\to 1$.\n    *   For the `none` filter, $D_{\\mathrm{fil}} = 0$ for all $F$.\n    *   For the Helmholtz filter, $D_{\\mathrm{fil}}(F, dx, \\text{helmholtz}) = \\alpha_0 (F - 1) dx^2$, which clearly approaches $0$ as $F \\to 1$.\n\n2.  **Efficiency Function**: We evaluate $E$ at $F=1$.\n    $$E(1, dx, \\text{filter}) = \\frac{1 \\cdot (D_0 + D_{\\mathrm{num}})}{1 \\cdot D_0 + D_{\\mathrm{num}} + \\theta \\cdot D_{\\mathrm{fil}}(1, dx, \\text{filter})}$$\n    Since $D_{\\mathrm{fil}}(1, dx, \\text{filter}) = 0$, the expression simplifies to:\n    $$E_{F=1} = \\frac{D_0 + D_{\\mathrm{num}}}{D_0 + D_{\\mathrm{num}}} = 1$$\n    This confirms that the efficiency function correctly limits to $1$.\n\n3.  **ATF Wave Speed**: We evaluate $c_{\\mathrm{ATF}}$ at $F=1$.\n    $$c_{\\mathrm{ATF}}(1, dx, \\text{filter}) = 2 \\, \\sqrt{ \\left( 1 \\cdot D_0 + D_{\\mathrm{num}} + D_{\\mathrm{fil}}(1, \\dots) \\right) \\, \\frac{E(1, \\dots) R_0}{1} }$$\n    Substituting $D_{\\mathrm{fil}}(1, \\dots) = 0$, $E(1, \\dots) = 1$, we get:\n    $$c_{\\mathrm{ATF}}(1, dx, \\text{filter}) = 2 \\, \\sqrt{ (D_0 + D_{\\mathrm{num}}) R_0 }$$\n    This is precisely the definition of the baseline wave speed, $c_{\\mathrm{base}}(dx)$.\n\n4.  **Relative Error**: From the above, at $F=1$, we have $c_{\\mathrm{ATF}} = c_{\\mathrm{base}}$. The relative error is therefore:\n    $$\\varepsilon_{F=1} = \\frac{|c_{\\mathrm{base}} - c_{\\mathrm{base}}|}{c_{\\mathrm{base}}} = 0$$\n\nThese theoretical results, $E_{F=1} = 1$ and $\\varepsilon_{F=1} = 0$, are expected for all test cases and serve as a sanity check for the numerical implementation.\n\n**Computational Algorithm**\nFor each test case defined by a set of parameters $(dx, k_{\\mathrm{num}}, \\text{filter type}, \\alpha_0, \\theta, F\\text{-list})$, the following steps are performed:\n1.  Set the baseline physical parameters $D_0=1$ and $R_0=1$.\n2.  Calculate the constant numerical diffusion for the given grid: $D_{\\mathrm{num}} = k_{\\mathrm{num}} \\, dx^2$.\n3.  Calculate the constant baseline wave speed: $c_{\\mathrm{base}} = 2 \\sqrt{(D_0 + D_{\\mathrm{num}}) R_0}$.\n4.  Initialize an empty list to store the relative errors, `error_sequence`.\n5.  Iterate through each thickening factor $F_i$ in the provided $F\\text{-list}$:\n    a. Calculate the filter-induced diffusion $D_{\\mathrm{fil},i}$ based on the filter type.\n    b. Calculate the dynamic efficiency function $E_i$ using its definition. It is numerically more stable to implement the formulas as given, without algebraic simplification, to avoid floating-point precision issues.\n    $$E_i = \\frac{F_i \\, (D_0 + D_{\\mathrm{num}})}{F_i D_0 + D_{\\mathrm{num}} + \\theta \\, D_{\\mathrm{fil},i}}$$\n    c. Calculate the ATF wave speed $c_{\\mathrm{ATF},i}$.\n    $$c_{\\mathrm{ATF},i} = 2 \\, \\sqrt{ \\left( F_i D_0 + D_{\\mathrm{num}} + D_{\\mathrm{fil},i} \\right) \\, \\frac{E_i R_0}{F_i} }$$\n    d. Compute the relative error $\\varepsilon_i = \\frac{|c_{\\mathrm{ATF},i} - c_{\\mathrm{base}}|}{c_{\\mathrm{base}}}$.\n    e. Append $\\varepsilon_i$ to `error_sequence`.\n6.  The values for $F=1$ are the final computed values in the sequences. Thus, $E_{F=1} = 1.0$ and $\\varepsilon_{F=1}$ is the last element of `error_sequence` (which should be $0.0$ or a value very close to it).\n7.  Determine the monotonicity flag $m$. Since the $F\\text{-list}$ is ordered with $F_i$ decreasing to $1$, we check if the computed `error_sequence` is non-increasing. This is true if $\\varepsilon_i \\ge \\varepsilon_{i+1}$ for all $i$ in the sequence. If the condition holds, $m=1$; otherwise, $m=0$.\n8.  The final result for the test case is the triple $[E_{F=1}, \\varepsilon_{F=1}, m]$. This process is repeated for all four test cases.\n\nNote: In the special case of `filter = 'none'`, we have $D_{\\mathrm{fil}} = 0$ for all $F$. A careful substitution into the equations for $E$ and $c_{\\mathrm{ATF}}$ shows that $c_{\\mathrm{ATF}}(F) = c_{\\mathrm{base}}$ for all $F \\geq 1$. Consequently, the relative error $\\varepsilon_i$ should be $0$ for all $F_i$ in this case. The implementation must be robust to floating-point arithmetic to correctly reflect this.\n\nThe final program will encapsulate this logic, process all test cases, and format the output as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Artificially Thickened Flame (ATF) model consistency problem.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            'info': \"Test case 1 (general)\",\n            'dx': 0.01,\n            'k_num': 0.5,\n            'filter_type': 'helmholtz',\n            'alpha_0': 3.0,\n            'theta': 0.6,\n            'F_list': [5.0, 3.0, 2.0, 1.2, 1.0]\n        },\n        {\n            'info': \"Test case 2 (finer grid)\",\n            'dx': 0.002,\n            'k_num': 0.5,\n            'filter_type': 'helmholtz',\n            'alpha_0': 3.0,\n            'theta': 0.6,\n            'F_list': [4.0, 2.0, 1.5, 1.2, 1.0]\n        },\n        {\n            'info': \"Test case 3 (no filter)\",\n            'dx': 0.01,\n            'k_num': 0.5,\n            'filter_type': 'none',\n            'alpha_0': 0.0,  # Not used, but set for completeness\n            'theta': 0.6,\n            'F_list': [6.0, 3.0, 1.5, 1.1, 1.0]\n        },\n        {\n            'info': \"Test case 4 (stronger filter)\",\n            'dx': 0.01,\n            'k_num': 0.5,\n            'filter_type': 'helmholtz',\n            'alpha_0': 8.0,\n            'theta': 0.9,\n            'F_list': [5.0, 2.5, 1.5, 1.2, 1.0]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters for the current test case\n        dx = case['dx']\n        k_num = case['k_num']\n        filter_type = case['filter_type']\n        alpha_0 = case['alpha_0']\n        theta = case['theta']\n        F_list = case['F_list']\n        \n        # Baseline parameters\n        D0 = 1.0\n        R0 = 1.0\n\n        # Pre-compute constant values for the case\n        D_num = k_num * dx**2\n        c_base = 2.0 * np.sqrt((D0 + D_num) * R0)\n        \n        error_sequence = []\n        \n        # Iterate through the sequence of thickening factors F\n        for F in F_list:\n            # Calculate filter-induced diffusion\n            D_fil = 0.0\n            if filter_type == 'helmholtz':\n                D_fil = alpha_0 * (F - 1.0) * dx**2\n            \n            # Calculate the dynamic efficiency function E\n            E_numerator = F * (D0 + D_num)\n            E_denominator = F * D0 + D_num + theta * D_fil\n            E = E_numerator / E_denominator\n            \n            # Calculate the ATF wave speed c_ATF\n            term_in_sqrt = (F * D0 + D_num + D_fil) * (E * R0 / F)\n            c_atf = 2.0 * np.sqrt(term_in_sqrt)\n            \n            # Calculate the relative error epsilon\n            error = np.abs(c_atf - c_base) / c_base\n            error_sequence.append(error)\n\n        # As derived, E at F=1 should be 1.0\n        # The calculation below confirms this.\n        E_F1 = (1.0 * (D0 + D_num)) / (1.0 * D0 + D_num + theta * 0.0)\n\n        # The relative error at F=1 is the last element of the sequence\n        err_F1 = error_sequence[-1]\n        \n        # Check if the error sequence is non-increasing\n        is_non_increasing = all(\n            error_sequence[i] >= error_sequence[i+1] for i in range(len(error_sequence) - 1)\n        )\n        m = 1 if is_non_increasing else 0\n        \n        results.append(f\"[{E_F1:.10f},{err_F1:.10f},{m:d}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The predictive power of many advanced combustion models hinges on constants that must be determined by comparing against high-fidelity data or experiments. This exercise  simulates this critical calibration process. Using synthetic data representative of a Direct Numerical Simulation (DNS), you will calibrate a model constant $C_{\\Xi}$ within the flame-wrinkling efficiency factor $\\Xi$. By minimizing the discrepancy between the model's predicted average reaction rate and the DNS target, you will engage in a practical task central to developing and deploying state-of-the-art turbulent combustion models.",
            "id": "4008207",
            "problem": "You are given a calibration task in the context of Large Eddy Simulation (LES) of premixed combustion using the Artificially Thickened Flame (ATF) method with a dynamic efficiency function. The goal is to design and implement a procedure to calibrate a dimensionless model constant in the flame-wrinkling efficiency factor $\\Xi$ using Direct Numerical Simulation (DNS) data of a statistically planar turbulent flame. The calibration must be based on matching the ensemble-averaged filtered progress-variable reaction rate $\\langle \\tilde{\\dot{\\omega}}_c \\rangle$ of the model to a DNS-provided target value. The procedure must use a scientifically justified metric to quantify the mismatch and produce a calibrated constant for each provided test dataset.\n\nStart from the following fundamental base:\n- The filtered progress-variable transport equation in Large Eddy Simulation (LES) for premixed flames admits a closure for the filtered reaction source of the form\n$$\n\\tilde{\\dot{\\omega}}_c = \\rho_u S_L^0 \\Sigma,\n$$\nwhere $\\rho_u$ is the fresh-gas density, $S_L^0$ is the unstrained laminar burning velocity, and $\\Sigma$ is the Flame Surface Density (FSD).\n- In the Flame Surface Density (FSD) approach, the resolved FSD is modeled as\n$$\n\\Sigma \\approx \\Xi \\left|\\nabla \\tilde{c}\\right|,\n$$\nwhere $\\tilde{c}$ is the filtered progress variable and $\\Xi$ is the flame-wrinkling efficiency factor that accounts for sub-filter flame surface wrinkling and for the ATF-induced smoothing. The magnitude $\\left|\\nabla \\tilde{c}\\right|$ has units of inverse meters ($\\text{m}^{-1}$).\n- In the Artificially Thickened Flame (ATF) method with thickening factor $F$, the filtering and thickening reduce the resolved gradient magnitude and the effective FSD closure for a physically consistent average heat release is implemented by using the corrected resolved gradient $\\left|\\nabla \\tilde{c}\\right|/F$ in the FSD source,\n$$\n\\tilde{\\dot{\\omega}}_c^{\\text{model}} = \\rho_u S_L^0 \\, \\Xi \\, \\frac{\\left|\\nabla \\tilde{c}\\right|}{F}.\n$$\n\nAdopt the following parametric form for the dynamic efficiency function:\n- The efficiency factor $\\Xi$ is modeled as\n$$\n\\Xi = 1 + C_{\\Xi} I,\n$$\nwhere $C_{\\Xi}$ is a dimensionless model constant to be calibrated, and $I$ is a dimensionless local indicator capturing sub-filter wrinkling propensity (for example, based on sub-filter Karlovitz number or filter-to-laminar thickness ratios). In this problem, you will be given $I$ values directly.\n\nDefine the calibration metric as follows:\n- Let $\\langle \\tilde{\\dot{\\omega}}_c \\rangle_{\\text{DNS}}$ denote the DNS-provided ensemble-averaged filtered reaction rate in units of kilograms per cubic meter per second ($\\text{kg}\\,\\text{m}^{-3}\\,\\text{s}^{-1}$).\n- Let $\\langle \\tilde{\\dot{\\omega}}_c \\rangle_{\\text{model}}(C_{\\Xi})$ denote the model-predicted ensemble-averaged filtered reaction rate under the above closure, also in units of $\\text{kg}\\,\\text{m}^{-3}\\,\\text{s}^{-1}$.\n- The mismatch metric to be minimized for calibration is the squared discrepancy\n$$\nJ(C_{\\Xi}) = \\left(\\langle \\tilde{\\dot{\\omega}}_c \\rangle_{\\text{model}}(C_{\\Xi}) - \\langle \\tilde{\\dot{\\omega}}_c \\rangle_{\\text{DNS}}\\right)^2,\n$$\nwith $J$ having units $\\left(\\text{kg}\\,\\text{m}^{-3}\\,\\text{s}^{-1}\\right)^2$.\n\nYour task is to implement a program that:\n1. For each dataset, computes the ensemble-averaged model prediction $\\langle \\tilde{\\dot{\\omega}}_c \\rangle_{\\text{model}}(C_{\\Xi})$ by averaging over the provided sample points.\n2. Calibrates $C_{\\Xi}$ by minimizing the metric $J(C_{\\Xi})$ subject to the physical bounds $C_{\\Xi} \\in [0, C_{\\max}]$, where $C_{\\max} = 4.0$ is prescribed.\n3. Handles edge cases robustly:\n   - If the sensitivity of the average with respect to $C_{\\Xi}$ vanishes (i.e., the average of $\\rho_u S_L^0 \\left|\\nabla \\tilde{c}\\right| I / F$ is zero), you must return $C_{\\Xi} = 0$.\n   - If the unconstrained minimizer yields $C_{\\Xi}  0$, return $C_{\\Xi} = 0$; if it yields $C_{\\Xi}  C_{\\max}$, return $C_{\\Xi} = C_{\\max}$.\n4. Uses all numerical values in International System of Units (SI): $\\rho_u$ in $\\text{kg}\\,\\text{m}^{-3}$, $S_L^0$ in $\\text{m}\\,\\text{s}^{-1}$, $\\left|\\nabla \\tilde{c}\\right|$ in $\\text{m}^{-1}$, $F$ dimensionless, $I$ dimensionless, and $\\langle \\tilde{\\dot{\\omega}}_c \\rangle_{\\text{DNS}}$ in $\\text{kg}\\,\\text{m}^{-3}\\,\\text{s}^{-1}$.\n5. Produces a single line of output containing the calibrated constants for all datasets as a comma-separated list enclosed in square brackets, for example, `[c1,c2,c3,c4]`, where each $c_i$ is a floating-point number.\n\nTest suite and data:\n- Dataset $\\#1$ (moderate turbulence; \"happy path\"):\n  - Number of samples: $12$.\n  - Fresh-gas density array $\\rho_u$ (in $\\text{kg}\\,\\text{m}^{-3}$): $[1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2]$.\n  - Unstrained laminar burning velocity $S_L^0$ (in $\\text{m}\\,\\text{s}^{-1}$): $0.4$.\n  - Thickening factor $F$: $5$.\n  - Resolved gradient magnitudes $\\left|\\nabla \\tilde{c}\\right|$ (in $\\text{m}^{-1}$): $[60, 58, 62, 65, 59, 61, 64, 63, 60, 58, 62, 66]$.\n  - Wrinkling indicator $I$ (dimensionless): $[0.3, 0.5, 0.7, 1.0, 0.8, 0.6, 0.9, 0.4, 1.2, 0.2, 0.3, 0.5]$.\n  - Target ensemble-averaged filtered reaction rate $\\langle \\tilde{\\dot{\\omega}}_c \\rangle_{\\text{DNS}}$ (in $\\text{kg}\\,\\text{m}^{-3}\\,\\text{s}^{-1}$): $8.83008$.\n- Dataset $\\#2$ (no turbulence; boundary condition):\n  - Number of samples: $8$.\n  - Fresh-gas density array $\\rho_u$ (in $\\text{kg}\\,\\text{m}^{-3}$): $[1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2]$.\n  - Unstrained laminar burning velocity $S_L^0$ (in $\\text{m}\\,\\text{s}^{-1}$): $0.4$.\n  - Thickening factor $F$: $5$.\n  - Resolved gradient magnitudes $\\left|\\nabla \\tilde{c}\\right|$ (in $\\text{m}^{-1}$): $[50, 50, 50, 50, 50, 50, 50, 50]$.\n  - Wrinkling indicator $I$ (dimensionless): $[0, 0, 0, 0, 0, 0, 0, 0]$.\n  - Target ensemble-averaged filtered reaction rate $\\langle \\tilde{\\dot{\\omega}}_c \\rangle_{\\text{DNS}}$ (in $\\text{kg}\\,\\text{m}^{-3}\\,\\text{s}^{-1}$): $4.8$.\n- Dataset $\\#3$ (near-zero sensitivity; saturation test):\n  - Number of samples: $6$.\n  - Fresh-gas density array $\\rho_u$ (in $\\text{kg}\\,\\text{m}^{-3}$): $[1.1, 1.1, 1.1, 1.1, 1.1, 1.1]$.\n  - Unstrained laminar burning velocity $S_L^0$ (in $\\text{m}\\,\\text{s}^{-1}$): $0.35$.\n  - Thickening factor $F$: $10$.\n  - Resolved gradient magnitudes $\\left|\\nabla \\tilde{c}\\right|$ (in $\\text{m}^{-1}$): $[80, 82, 78, 81, 79, 83]$.\n  - Wrinkling indicator $I$ (dimensionless): $[10^{-6}, 10^{-6}, 10^{-6}, 10^{-6}, 10^{-6}, 10^{-6}]$.\n  - Target ensemble-averaged filtered reaction rate $\\langle \\tilde{\\dot{\\omega}}_c \\rangle_{\\text{DNS}}$ (in $\\text{kg}\\,\\text{m}^{-3}\\,\\text{s}^{-1}$): $3.0982809825$.\n- Dataset $\\#4$ (varying parameters; general case):\n  - Number of samples: $10$.\n  - Fresh-gas density array $\\rho_u$ (in $\\text{kg}\\,\\text{m}^{-3}$): $[1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3]$.\n  - Unstrained laminar burning velocity $S_L^0$ (in $\\text{m}\\,\\text{s}^{-1}$): $0.5$.\n  - Thickening factor $F$: $3$.\n  - Resolved gradient magnitudes $\\left|\\nabla \\tilde{c}\\right|$ (in $\\text{m}^{-1}$): $[40, 42, 39, 41, 43, 45, 44, 38, 40, 42]$.\n  - Wrinkling indicator $I$ (dimensionless): $[0.2, 0.1, 0.3, 0.2, 0.4, 0.5, 0.3, 0.2, 0.1, 0.2]$.\n  - Target ensemble-averaged filtered reaction rate $\\langle \\tilde{\\dot{\\omega}}_c \\rangle_{\\text{DNS}}$ (in $\\text{kg}\\,\\text{m}^{-3}\\,\\text{s}^{-1}$): $9.6525$.\n\nImplementation requirements:\n- For each dataset with $N$ samples indexed by $i$, compute\n$$\n\\langle \\tilde{\\dot{\\omega}}_c \\rangle_{\\text{model}}(C_{\\Xi}) = \\frac{1}{N} \\sum_{i=1}^{N} \\rho_{u,i} \\, S_L^0 \\, \\frac{\\left|\\nabla \\tilde{c}\\right|_i}{F} \\, \\left(1 + C_{\\Xi} I_i\\right).\n$$\n- Minimize $J(C_{\\Xi})$ subject to $0 \\le C_{\\Xi} \\le C_{\\max}$ with $C_{\\max} = 4.0$ and the stated edge-case rules. You must perform this calibration independently for each dataset.\n\nFinal output format:\n- Your program should produce a single line of output containing the calibrated constants as a comma-separated list enclosed in square brackets, for example, `[c1,c2,c3,c4]`, where `c1` corresponds to Dataset $\\#1$, etc. Each $c_i$ must be a floating-point number.",
            "solution": "We begin from the filtered progress-variable source closure. In Large Eddy Simulation (LES) of premixed combustion, the filtered reaction source of the progress variable is modeled using the Flame Surface Density (FSD) approach,\n$$\n\\tilde{\\dot{\\omega}}_c = \\rho_u S_L^0 \\Sigma,\n$$\nwhere $\\rho_u$ is the fresh-gas density and $S_L^0$ is the unstrained laminar burning velocity. The Flame Surface Density (FSD) $\\Sigma$ is the area of flame surface per unit volume and connects the local consumption rate to the flame geometry.\n\nIn the Flame Surface Density (FSD) modeling of LES with the Artificially Thickened Flame (ATF) method, the filtered gradient of the progress variable is reduced by the thickening factor because the flame front is smoothed over a thickness increased by a factor $F$. A common resolved closure is\n$$\n\\Sigma \\approx \\Xi \\left|\\nabla \\tilde{c}\\right|,\n$$\nwith the understanding that the smoothing by ATF is compensated in the efficiency factor $\\Xi$. To ensure dimensional consistency and reflect the reduction of the resolved gradient magnitude with thickening $F$, we consider the corrected gradient $\\left|\\nabla \\tilde{c}\\right|/F$ in the source term,\n$$\n\\tilde{\\dot{\\omega}}_c^{\\text{model}} = \\rho_u S_L^0 \\, \\Xi \\, \\frac{\\left|\\nabla \\tilde{c}\\right|}{F}.\n$$\nThe units are consistent: $\\rho_u$ has units $\\text{kg}\\,\\text{m}^{-3}$, $S_L^0$ has units $\\text{m}\\,\\text{s}^{-1}$, $\\left|\\nabla \\tilde{c}\\right|$ has units $\\text{m}^{-1}$, and $F$ is dimensionless, so $\\tilde{\\dot{\\omega}}_c$ has units $\\text{kg}\\,\\text{m}^{-3}\\,\\text{s}^{-1}$.\n\nTo account for sub-filter flame wrinkling and the ATF-induced smoothing, we use a dynamic efficiency function $\\Xi$ parameterized as\n$$\n\\Xi = 1 + C_{\\Xi} I,\n$$\nwhere $C_{\\Xi}$ is a dimensionless model constant to be calibrated and $I$ is a dimensionless sub-filter wrinkling indicator provided by the DNS analysis (for example, a function of sub-filter Karlovitz number and filter width to laminar flame thickness ratio). The calibration must be based on matching the ensemble-averaged filtered reaction rate from the model to the DNS target. For a dataset containing $N$ samples (grid points, conditioned cells, or temporal samples), the ensemble average of the model prediction is\n$$\n\\langle \\tilde{\\dot{\\omega}}_c \\rangle_{\\text{model}}(C_{\\Xi}) = \\frac{1}{N} \\sum_{i=1}^{N} \\rho_{u,i} \\, S_L^0 \\, \\frac{\\left|\\nabla \\tilde{c}\\right|_i}{F} \\, \\left(1 + C_{\\Xi} I_i\\right).\n$$\nLet us define two ensemble averages that separate the dependence on $C_{\\Xi}$:\n$$\nA_0 \\equiv \\frac{1}{N} \\sum_{i=1}^{N} \\rho_{u,i} \\, S_L^0 \\, \\frac{\\left|\\nabla \\tilde{c}\\right|_i}{F}, \\quad\nA_1 \\equiv \\frac{1}{N} \\sum_{i=1}^{N} \\rho_{u,i} \\, S_L^0 \\, \\frac{\\left|\\nabla \\tilde{c}\\right|_i}{F} \\, I_i.\n$$\nUsing these, the ensemble-averaged model prediction is an affine function of $C_{\\Xi}$:\n$$\n\\langle \\tilde{\\dot{\\omega}}_c \\rangle_{\\text{model}}(C_{\\Xi}) = A_0 + C_{\\Xi} A_1.\n$$\nThe calibration metric is the squared discrepancy between the model and DNS averages,\n$$\nJ(C_{\\Xi}) = \\left(\\langle \\tilde{\\dot{\\omega}}_c \\rangle_{\\text{model}}(C_{\\Xi}) - \\langle \\tilde{\\dot{\\omega}}_c \\rangle_{\\text{DNS}}\\right)^2 = \\left(A_0 + C_{\\Xi} A_1 - \\langle \\tilde{\\dot{\\omega}}_c \\rangle_{\\text{DNS}}\\right)^2.\n$$\nMinimizing $J(C_{\\Xi})$ with respect to $C_{\\Xi}$ for an affine model is straightforward. The unconstrained minimizer satisfies\n$$\n\\frac{dJ}{dC_{\\Xi}} = 2 \\left(A_0 + C_{\\Xi} A_1 - \\langle \\tilde{\\dot{\\omega}}_c \\rangle_{\\text{DNS}}\\right) A_1 = 0,\n$$\nwhich yields the stationary point\n$$\nC_{\\Xi}^{\\star} = \\frac{\\langle \\tilde{\\dot{\\omega}}_c \\rangle_{\\text{DNS}} - A_0}{A_1},\n$$\nprovided $A_1 \\ne 0$. Physically, $A_1$ quantifies the sensitivity of the ensemble-averaged source to the model constant, weighted by the indicator $I$. If $A_1 = 0$, the average is insensitive to $C_{\\Xi}$, and the physically meaningful choice is $C_{\\Xi} = 0$, since $\\Xi = 1 + C_{\\Xi} I$ then reduces to $\\Xi = 1$. Additionally, we enforce the physical bounds $0 \\le C_{\\Xi} \\le C_{\\max}$ (with $C_{\\max} = 4.0$) to avoid unphysical amplification of $\\Xi$ in low-sensitivity regimes. Therefore, the constrained minimizer is\n$$\nC_{\\Xi}^{\\text{cal}} =\n\\begin{cases}\n0,  \\text{if } A_1 = 0, \\\\\n\\min\\left(\\max\\left(0, \\frac{\\langle \\tilde{\\dot{\\omega}}_c \\rangle_{\\text{DNS}} - A_0}{A_1}\\right), C_{\\max}\\right),  \\text{otherwise}.\n\\end{cases}\n$$\n\nAlgorithmic design:\n- For each dataset, compute $A_0$ and $A_1$ using the provided arrays of $\\rho_{u,i}$ (in $\\text{kg}\\,\\text{m}^{-3}$), $S_L^0$ (in $\\text{m}\\,\\text{s}^{-1}$), $F$ (dimensionless), $\\left|\\nabla \\tilde{c}\\right|_i$ (in $\\text{m}^{-1}$), and $I_i$ (dimensionless).\n- Evaluate $C_{\\Xi}^{\\star}$ when $A_1  0$; otherwise set $C_{\\Xi}^{\\text{cal}} = 0$.\n- Apply clipping to the interval $[0, C_{\\max}]$ to obtain $C_{\\Xi}^{\\text{cal}}$.\n- Return the list $[C_{\\Xi}^{\\text{cal}}(\\#1), C_{\\Xi}^{\\text{cal}}(\\#2), C_{\\Xi}^{\\text{cal}}(\\#3), C_{\\Xi}^{\\text{cal}}(\\#4)]$.\n\nVerification on the provided test suite:\n- Dataset $\\#1$: With the given data, compute $A_0$ and $A_1$. Using the provided target $\\langle \\tilde{\\dot{\\omega}}_c \\rangle_{\\text{DNS}} = 8.83008$, the calibration formula yields $C_{\\Xi}^{\\text{cal}} = 0.8$, which lies within the bounds.\n- Dataset $\\#2$: The indicator $I_i = 0$ for all samples implies $A_1 = 0$. The procedure returns $C_{\\Xi}^{\\text{cal}} = 0$.\n- Dataset $\\#3$: The indicator $I_i = 10^{-6}$ gives $A_1$ extremely small. The unconstrained minimizer is $C_{\\Xi}^{\\star} \\approx 10$, which exceeds $C_{\\max} = 4.0$. The bounded calibration returns $C_{\\Xi}^{\\text{cal}} = 4.0$.\n- Dataset $\\#4$: With the given data, the target $\\langle \\tilde{\\dot{\\omega}}_c \\rangle_{\\text{DNS}} = 9.6525$ yields $C_{\\Xi}^{\\text{cal}} = 0.3$, within bounds.\n\nThe program thus computes the calibrated constants by principled minimization of a physically motivated metric, with robust handling of edge cases and boundedness for numerical stability and physical realism. The final output is a single line, a list containing the four calibrated floating-point constants.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calibrate_C_xi(rho_u, S_L0, F, grad_mag, I, w_dns_avg, C_max=4.0, eps=1e-12):\n    \"\"\"\n    Calibrate the model constant C_xi for the efficiency function Xi = 1 + C_xi * I\n    by minimizing J(C_xi) = ( omega_model(C_xi) - w_dns_avg )^2,\n    where omega_model(C_xi) = mean( rho * S_L0 * (|grad c|/F) * (1 + C_xi * I) ).\n    \"\"\"\n    rho_u = np.asarray(rho_u, dtype=float)\n    grad_mag = np.asarray(grad_mag, dtype=float)\n    I = np.asarray(I, dtype=float)\n    # Compute A0 and A1\n    factor = rho_u * S_L0 * (grad_mag / F)\n    A0 = np.mean(factor)\n    A1 = np.mean(factor * I)\n    # Handle edge cases\n    if abs(A1)  eps:\n        return 0.0\n    C_unconstrained = (w_dns_avg - A0) / A1\n    # Enforce bounds\n    C_bounded = max(0.0, min(C_unconstrained, C_max))\n    return C_bounded\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Dataset #1\n    rho1 = [1.2]*12\n    S_L0_1 = 0.4\n    F1 = 5.0\n    grad1 = [60, 58, 62, 65, 59, 61, 64, 63, 60, 58, 62, 66]\n    I1 = [0.3, 0.5, 0.7, 1.0, 0.8, 0.6, 0.9, 0.4, 1.2, 0.2, 0.3, 0.5]\n    w_dns_1 = 8.83008\n\n    # Dataset #2\n    rho2 = [1.2]*8\n    S_L0_2 = 0.4\n    F2 = 5.0\n    grad2 = [50]*8\n    I2 = [0.0]*8\n    w_dns_2 = 4.8\n\n    # Dataset #3\n    rho3 = [1.1]*6\n    S_L0_3 = 0.35\n    F3 = 10.0\n    grad3 = [80, 82, 78, 81, 79, 83]\n    I3 = [1e-6]*6\n    w_dns_3 = 3.0982809825\n\n    # Dataset #4\n    rho4 = [1.3]*10\n    S_L0_4 = 0.5\n    F4 = 3.0\n    grad4 = [40, 42, 39, 41, 43, 45, 44, 38, 40, 42]\n    I4 = [0.2, 0.1, 0.3, 0.2, 0.4, 0.5, 0.3, 0.2, 0.1, 0.2]\n    w_dns_4 = 9.6525\n\n    test_cases = [\n        (rho1, S_L0_1, F1, grad1, I1, w_dns_1),\n        (rho2, S_L0_2, F2, grad2, I2, w_dns_2),\n        (rho3, S_L0_3, F3, grad3, I3, w_dns_3),\n        (rho4, S_L0_4, F4, grad4, I4, w_dns_4),\n    ]\n\n    results = []\n    for rho_u, S_L0, F, grad_mag, I, w_dns_avg in test_cases:\n        c_xi = calibrate_C_xi(rho_u, S_L0, F, grad_mag, I, w_dns_avg, C_max=4.0, eps=1e-12)\n        results.append(c_xi)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}