{
    "hands_on_practices": [
        {
            "introduction": "为了掌握G方程，我们首先从最简单的情景入手。本练习旨在通过求解一个在静止介质中传播的平面火焰的G方程，来建立一个基准的理解。通过这个过程，我们将看到水平集（level-set）方法如何自然地描述了火焰以恒定速度的传播，并练习使用特征线法求解哈密顿-雅可比（Hamilton-Jacobi）方程的基本技能。",
            "id": "4035876",
            "problem": "考虑一个由水平集函数 $G(\\mathbf{x},t)$ 表示的预混火焰锋面，其中锋面是零水平集 $G(\\mathbf{x},t)=0$。在静止流场中，对于一个恒定的法向传播速度 $S_L$，水平集公式中 $G$ 的演化由偏微分方程（PDE）$G_t + S_L |\\nabla G| = 0$ 给出。这是一个哈密顿-雅可比（HJ）型偏微分方程，它源于锋面沿其法线方向以速度 $S_L$ 移动的运动学定律。假设空间维度 $d \\geq 2$，初始条件为平面 $G(\\mathbf{x},0) = \\mathbf{n}\\cdot\\mathbf{x} - d_0$，其中 $\\mathbf{n} \\in \\mathbb{R}^d$ 是一个满足 $|\\mathbf{n}|=1$ 的单位法向量，$d_0 \\in \\mathbb{R}$ 是一个常数。\n\n从具有恒定法向速度的水平集锋面的基本定义出发，构建相关的哈密顿-雅可比特征系统，并针对给定的平面初始数据求解该偏微分方程 $G_t + S_L |\\nabla G| = 0$。使用基本原理，证明零水平集保持平面性并且平移时形状不变，并确定对所有 $\\mathbf{x} \\in \\mathbb{R}^d$ 和 $t \\geq 0$ 均有效的 $G(\\mathbf{x},t)$ 的显式闭式表达式。\n\n请以 $G(\\mathbf{x},t)$ 的单个解析表达式的形式给出您的最终答案。",
            "solution": "该问题要求解水平集函数 $G(\\mathbf{x},t)$ 的偏微分方程（PDE）$G_t + S_L |\\nabla G| = 0$，其初始条件为平面 $G(\\mathbf{x},0) = \\mathbf{n}\\cdot\\mathbf{x} - d_0$。此处，$S_L$ 是一个常数，$\\mathbf{n}$ 是一个单位向量，即 $|\\mathbf{n}|=1$。这是一个一阶、非线性的哈密顿-雅可比型偏微分方程。我们将使用特征线法来求解它。\n\n首先，我们将该偏微分方程写成标准的哈密顿-雅可比形式 $G_t + H(\\nabla G) = 0$。通过与给定方程比较，我们将哈密顿量 $H$ 确定为梯度向量 $\\mathbf{p} = \\nabla G$ 的函数：\n$$H(\\mathbf{p}) = S_L |\\mathbf{p}|$$\n特征线法将偏微分方程转化为一个常微分方程组（ODEs），该方程组描述了称为特征线的曲线，沿着这些曲线可以构造出解。这些常微分方程描述了位置 $\\mathbf{x}(t)$、梯度 $\\mathbf{p}(t) = \\nabla G(\\mathbf{x}(t),t)$ 以及函数值 $G(t) = G(\\mathbf{x}(t),t)$ 沿着由时间 $t$ 参数化的特征曲线的演化。\n\n对于一个哈密顿量 $H(\\mathbf{x}, \\mathbf{p}, t)$，其特征方程为：\n$$ \\frac{d\\mathbf{x}}{dt} = \\nabla_{\\mathbf{p}} H, \\quad \\frac{d\\mathbf{p}}{dt} = -\\nabla_{\\mathbf{x}} H, \\quad \\frac{dG}{dt} = G_t + \\nabla G \\cdot \\frac{d\\mathbf{x}}{dt} = -H + \\mathbf{p} \\cdot \\nabla_{\\mathbf{p}} H $$\n在我们的问题中，哈密顿量 $H(\\mathbf{p}) = S_L |\\mathbf{p}| = S_L \\sqrt{\\mathbf{p}\\cdot\\mathbf{p}}$ 仅依赖于 $\\mathbf{p}$，而不显式依赖于 $\\mathbf{x}$ 或 $t$。\n\n我们来计算 $H$ 的必要导数：\n1. $H$ 相对于 $\\mathbf{p}$ 的梯度：\n$$ \\nabla_{\\mathbf{p}} H = \\nabla_{\\mathbf{p}} (S_L |\\mathbf{p}|) = S_L \\frac{\\mathbf{p}}{|\\mathbf{p}|} $$\n2. $H$ 相对于 $\\mathbf{x}$ 的梯度：\n由于 $H$ 不显式依赖于 $\\mathbf{x}$，\n$$ \\nabla_{\\mathbf{x}} H = \\mathbf{0} $$\n\n将这些代入特征方程，我们得到此问题的特定常微分方程组：\n$$ (1) \\quad \\frac{d\\mathbf{x}}{dt} = S_L \\frac{\\mathbf{p}}{|\\mathbf{p}|} $$\n$$ (2) \\quad \\frac{d\\mathbf{p}}{dt} = \\mathbf{0} $$\n$$ (3) \\quad \\frac{dG}{dt} = -H(\\mathbf{p}) + \\mathbf{p} \\cdot \\nabla_{\\mathbf{p}} H = -(S_L |\\mathbf{p}|) + \\mathbf{p} \\cdot \\left(S_L \\frac{\\mathbf{p}}{|\\mathbf{p}|}\\right) = -S_L |\\mathbf{p}| + S_L \\frac{|\\mathbf{p}|^2}{|\\mathbf{p}|} = -S_L |\\mathbf{p}| + S_L |\\mathbf{p}| = 0 $$\n\n为了求解该方程组，我们需要初始条件。我们考虑一条在时间 $t=0$ 从空间中任意点 $\\mathbf{x}_0$ 出发的特征曲线。初始条件是：\n- 位置：$\\mathbf{x}(0) = \\mathbf{x}_0$。\n- $G$ 的值：$G(0) = G(\\mathbf{x}_0, 0) = \\mathbf{n} \\cdot \\mathbf{x}_0 - d_0$。\n- 梯度：$\\mathbf{p}(0) = \\nabla G(\\mathbf{x},0)|_{\\mathbf{x}=\\mathbf{x}_0}$。根据初始条件 $G(\\mathbf{x},0) = \\mathbf{n}\\cdot\\mathbf{x} - d_0$，我们计算梯度：$\\mathbf{p}(0) = \\nabla_{\\mathbf{x}} (\\mathbf{n}\\cdot\\mathbf{x} - d_0) = \\mathbf{n}$。\n\n现在我们可以求解这些常微分方程：\n根据方程 $(2)$，$\\frac{d\\mathbf{p}}{dt} = \\mathbf{0}$，以及初始条件 $\\mathbf{p}(0) = \\mathbf{n}$，我们发现梯度沿着每条特征线都是恒定的：\n$$ \\mathbf{p}(t) = \\mathbf{n} $$\n这个结果非常重要；它意味着梯度向量在我们沿着特征曲线移动时不会改变。\n\n接下来，我们使用方程 $(1)$ 求解位置 $\\mathbf{x}(t)$。代入 $\\mathbf{p}(t) = \\mathbf{n}$ 并利用已知事实 $|\\mathbf{n}|=1$：\n$$ \\frac{d\\mathbf{x}}{dt} = S_L \\frac{\\mathbf{n}}{|\\mathbf{n}|} = S_L \\mathbf{n} $$\n这是一个关于 $\\mathbf{x}(t)$ 的简单常微分方程。在初始条件为 $\\mathbf{x}(0) = \\mathbf{x}_0$ 的情况下，对时间从 $0$ 到 $t$ 进行积分：\n$$ \\mathbf{x}(t) - \\mathbf{x}(0) = \\int_0^t (S_L \\mathbf{n}) d\\tau = S_L \\mathbf{n} t $$\n$$ \\mathbf{x}(t) = \\mathbf{x}_0 + S_L \\mathbf{n} t $$\n这个方程描述了特征线上一点的轨迹，表明它以恒定速度 $S_L \\mathbf{n}$ 移动。\n\n最后，我们使用方程 $(3)$ 求解 $G(t)$：\n$$ \\frac{dG}{dt} = 0 $$\n这意味着 $G$ 沿着任何一条特征曲线都是恒定的。因此，它在任何时间 $t$ 的值都与其在 $t=0$ 时的初始值相同：\n$$ G(\\mathbf{x}(t), t) = G(\\mathbf{x}_0, 0) = \\mathbf{n} \\cdot \\mathbf{x}_0 - d_0 $$\n\n我们现在已经找到了沿特征曲线的解 $G$。为了获得对任意点 $(\\mathbf{x}, t)$ 的通解 $G(\\mathbf{x},t)$，我们必须用 $\\mathbf{x}$ 和 $t$ 来表示它，而不是用初始点 $\\mathbf{x}_0$。从 $\\mathbf{x}(t)$ 的解中，我们可以用稍后时间 $t$ 的位置 $\\mathbf{x}$ 来表示初始位置 $\\mathbf{x}_0$：\n$$ \\mathbf{x}_0 = \\mathbf{x} - S_L \\mathbf{n} t $$\n将这个 $\\mathbf{x}_0$ 的表达式代入 $G$ 的方程中：\n$$ G(\\mathbf{x}, t) = \\mathbf{n} \\cdot (\\mathbf{x} - S_L \\mathbf{n} t) - d_0 $$\n展开点积：\n$$ G(\\mathbf{x}, t) = \\mathbf{n} \\cdot \\mathbf{x} - S_L (\\mathbf{n} \\cdot \\mathbf{n}) t - d_0 $$\n由于 $\\mathbf{n}$ 是一个单位向量，$\\mathbf{n} \\cdot \\mathbf{n} = |\\mathbf{n}|^2 = 1^2 = 1$。这导出了该解的最终闭式表达式：\n$$ G(\\mathbf{x}, t) = \\mathbf{n} \\cdot \\mathbf{x} - S_L t - d_0 $$\n\n让我们验证这个解。\n- 初始条件：在 $t=0$ 时，$G(\\mathbf{x},0) = \\mathbf{n} \\cdot \\mathbf{x} - d_0$，这是正确的。\n- 偏微分方程：$G_t = \\frac{\\partial}{\\partial t}(\\mathbf{n} \\cdot \\mathbf{x} - S_L t - d_0) = -S_L$。梯度为 $\\nabla G = \\nabla_{\\mathbf{x}}(\\mathbf{n} \\cdot \\mathbf{x} - S_L t - d_0) = \\mathbf{n}$。那么 $|\\nabla G| = |\\mathbf{n}| = 1$。偏微分方程 $G_t + S_L |\\nabla G| = 0$ 变为 $-S_L + S_L(1) = 0$，这是正确的。\n\n最后，我们研究代表火焰锋面的零水平集的演化。锋面由条件 $G(\\mathbf{x},t) = 0$ 定义。\n$$ \\mathbf{n} \\cdot \\mathbf{x} - S_L t - d_0 = 0 $$\n$$ \\mathbf{n} \\cdot \\mathbf{x} = d_0 + S_L t $$\n对于任意固定的时间 $t$，这是 $\\mathbb{R}^d$ 中具有恒定法向量 $\\mathbf{n}$ 的超平面的方程。这表明火焰锋面对所有 $t \\geq 0$ 都保持平面性。在 $t=0$ 时的初始锋面是 $\\mathbf{n} \\cdot \\mathbf{x} = d_0$。在时间 $t$ 的锋面具有相同的法向量，这意味着它在平移时没有旋转或形状变化。该平面沿方向 $\\mathbf{n}$ 离原点的有向距离是 $D(t) = d_0 + S_L t$。锋面的速度由其位置向量的时间导数给出，可以表示为 $D(t)\\mathbf{n}$。速度为 $\\frac{d}{dt}(D(t)\\mathbf{n}) = \\frac{d}{dt}((d_0 + S_L t)\\mathbf{n}) = S_L \\mathbf{n}$。锋面的速率是该速度的大小，即 $|S_L \\mathbf{n}| = S_L|\\mathbf{n}| = S_L$。因此，平面锋面以恒定速率 $S_L$ 在其法向量 $\\mathbf{n}$ 的方向上平移，即向未燃气体区域传播，这是物理上正确的行为。\n$G(\\mathbf{x},t)$ 的显式闭式表达式提供了完整的解。",
            "answer": "$$\n\\boxed{\\mathbf{n} \\cdot \\mathbf{x} - S_L t - d_0}\n$$"
        },
        {
            "introduction": "真实的火焰很少是完全平坦的。本练习将引入火焰拉伸这一关键概念，特别是曲率对局部燃烧速度的影响。通过推导曲面火焰的传播速度，您将理解马克斯坦长度（Markstein length, $L_M$）如何模拟热扩散效应，以及这些效应如何导致局部熄火等现象。",
            "id": "4035874",
            "problem": "考虑一个二维预混火焰锋面，由水平集函数 $G(\\mathbf{x},t)$ 表示，火焰表面由 $G=0$ 给出，单位法向量 $\\mathbf{n}=\\nabla G/|\\nabla G|$ 从已燃产物指向未燃反应物。局部平均曲率定义为 $\\kappa=\\nabla\\cdot\\mathbf{n}$，当锋面朝向未燃气体凸出时，其值为正。假设为低马赫数条件，对单位路易斯数的偏离由一个正的马克斯坦长度 $L_M>0$ 来表征，沿锋面的切向应变和流动引起的拉伸可忽略不计，且曲率很小，使得 $|L_M\\,\\kappa|\\ll 1$。\n\n沿着参数化锋面的弧长 $s\\in[0,\\ell]$，曲率被指定为\n$$\n\\kappa(s)=\\kappa_0+\\kappa_1\\cos\\!\\left(\\frac{2\\pi s}{\\ell}\\right),\n$$\n其中参数 $\\kappa_0>0$, $\\kappa_1>0$, 且 $\\ell0$。令 $S_L^00$ 表示在相同混合物和热化学状态下的平面层流燃烧速度。使用基于第一性原理的、以具有曲率敏感法向速度的水平集传播表示的公式，推导沿锋面的法向传播速度 $S_n(s)$ 的空间分布的领先阶解析表达式，该表达式用 $S_L^0$、$L_M$、$\\kappa_0$、$\\kappa_1$ 和 $\\ell$ 表示。然后，基于此分布，确定沿 $s$ 的哪个位置锋面最容易发生局部熄火，并用 $L_M$、$\\kappa_0$ 和 $\\kappa_1$ 给出局部熄火发生的参数判据。\n\n请将您的最终答案表示为 $S_n(s)$ 关于给定参数的单个封闭形式表达式。无需进行数值计算或四舍五入，最终表达式中不应包含单位。所有的中间推理过程都应在您的解答中展示。",
            "solution": "本问题旨在推导在给定曲率分布下，受拉伸效应影响的预混火焰的局部传播速度。\n\n**1. 建立火焰速度与拉伸的关系**\n\n预混火焰锋面的局部传播速度（位移速度）$S_n$ 与总拉伸率 $\\mathcal{K}$ 之间的关系，在线性近似下由马克斯坦长度 $L_M$ 描述：\n$$ S_n = S_L^0 - L_M \\mathcal{K} $$\n其中 $S_L^0$ 是未受拉伸的平面层流火焰速度。\n\n**2. 分解总拉伸率**\n\n总拉伸率 $\\mathcal{K}$ 由两部分组成：由流场应变引起的拉伸 $a_t$ 和由锋面自身几何形状与传播引起的曲率拉伸。对于二维锋面，该关系为：\n$$ \\mathcal{K} = a_t + S_n \\kappa $$\n其中 $\\kappa$ 是锋面的局部曲率。根据问题陈述，“沿锋面的切向应变和流动引起的拉伸可忽略不计”，这意味着我们可以设置 $a_t = 0$。因此，总拉伸率完全由曲率贡献：\n$$ \\mathcal{K} = S_n \\kappa $$\n\n**3. 求解局部传播速度 $S_n$**\n\n将曲率拉伸的表达式代入火焰速度关系式中，我们得到一个关于 $S_n$ 的隐式方程：\n$$ S_n = S_L^0 - L_M (S_n \\kappa) $$\n通过代数方法求解 $S_n$：\n$$ S_n + L_M S_n \\kappa = S_L^0 $$\n$$ S_n(1 + L_M \\kappa) = S_L^0 $$\n$$ S_n = \\frac{S_L^0}{1 + L_M \\kappa} $$\n问题中假设曲率很小，满足 $|L_M \\kappa| \\ll 1$。这个条件允许我们使用泰勒级数展开来简化表达式。对于小 $x$，我们有 $(1+x)^{-1} \\approx 1-x$。应用此近似，我们得到 $S_n$ 的领先阶表达式：\n$$ S_n \\approx S_L^0 (1 - L_M \\kappa) $$\n\n**4. 代入给定的曲率分布**\n\n问题给出了沿锋面弧长 $s$ 的曲率分布：\n$$ \\kappa(s) = \\kappa_0 + \\kappa_1 \\cos\\left(\\frac{2\\pi s}{\\ell}\\right) $$\n将此分布代入 $S_n$ 的近似表达式中，我们得到法向传播速度的空间分布：\n$$ S_n(s) = S_L^0 \\left( 1 - L_M \\left( \\kappa_0 + \\kappa_1 \\cos\\left(\\frac{2\\pi s}{\\ell}\\right) \\right) \\right) $$\n这就是所要求的 $S_n(s)$ 的最终封闭形式表达式。\n\n**5. 熄火分析**\n\n局部熄火发生在燃烧速度 $S_n$ 降至零或变为负值时。因此，火焰最容易熄火的位置是 $S_n(s)$ 达到其最小值的地方。\n为了找到最小值，我们分析 $S_n(s)$ 的表达式。由于给定的参数 $S_L^0, L_M, \\kappa_1$ 均为正值， $S_n(s)$ 的值由 $\\cos\\left(\\frac{2\\pi s}{\\ell}\\right)$ 项决定。当 $\\cos\\left(\\frac{2\\pi s}{\\ell}\\right)$ 取其最大值 $+1$ 时，$S_n(s)$ 达到最小值。这发生在 $\\frac{2\\pi s}{\\ell} = 2k\\pi$（对于整数 $k$），即在 $s=0$ 和 $s=\\ell$ 的位置。\n在这些点，曲率达到最大值 $\\kappa_{\\text{max}} = \\kappa_0 + \\kappa_1$。物理上，这些是火焰锋面朝向未燃气体最凸出的点。对于 $L_M > 0$（对应于路易斯数大于1），凸出的锋面燃烧得更慢，因此最容易熄火。\n\n此时的最小传播速度为：\n$$ S_{n, \\text{min}} = S_L^0 (1 - L_M(\\kappa_0 + \\kappa_1)) $$\n局部熄火的判据是 $S_{n, \\text{min}} \\le 0$。由于 $S_L^0 > 0$，这等价于：\n$$ 1 - L_M(\\kappa_0 + \\kappa_1) \\le 0 $$\n$$ L_M(\\kappa_0 + \\kappa_1) \\ge 1 $$\n这个判据给出了发生局部熄火所需的参数条件。",
            "answer": "$$\n\\boxed{S_L^0 \\left( 1 - L_M \\left( \\kappa_0 + \\kappa_1 \\cos\\left(\\frac{2\\pi s}{\\ell}\\right) \\right) \\right)}\n$$"
        },
        {
            "introduction": "从理论走向计算，本练习旨在解决数值求解G方程的核心挑战：如何从离散数据中精确计算法向量和曲率等几何量。您将编写一个程序，评估不同的有限差分格式和网格各向异性对一个简单圆形火焰的几何计算的影响。这项实践将为您提供关于计算燃烧学模拟中误差来源的关键见解。",
            "id": "4035843",
            "problem": "考虑预混火焰锋面的二维水平集表示。该锋面被建模为一个以 $(x_0,y_0)$ 为中心、半径为 $R$ 的圆，由符号距离函数 $\\phi(x,y) = \\sqrt{(x-x_0)^2+(y-y_0)^2} - R$ 定义。在预混火焰的几何方程（G方程）的 Hamilton-Jacobi 表述中，锋面法线 $\\mathbf{n}$ 和几何曲率 $\\kappa$ 是进入传播定律的基本量。对于一个水平集函数 $\\phi$，这些量由核心几何恒等式定义\n$$\n\\mathbf{n} = \\frac{\\nabla \\phi}{\\lVert \\nabla \\phi \\rVert}, \\qquad \\kappa = \\nabla \\cdot \\left( \\frac{\\nabla \\phi}{\\lVert \\nabla \\phi \\rVert} \\right),\n$$\n并且，在光滑点上等价地由基于 Hessian 矩阵的公式定义\n$$\n\\kappa = \\frac{\\phi_{xx}\\,\\phi_y^2 - 2\\,\\phi_x\\,\\phi_y\\,\\phi_{xy} + \\phi_{yy}\\,\\phi_x^2}{\\left(\\phi_x^2+\\phi_y^2\\right)^{3/2}}.\n$$\n在间距 $dx$ 和 $dy$ 可能不相等（各向异性网格）的笛卡尔网格上，这些导数使用有限差分格式进行近似。即使对于像圆这样完全各向同性的几何形状，网格的各向异性也会在计算出的 $\\mathbf{n}$ 和 $\\kappa$ 中引入方向性误差。\n\n从上述定义出发，在各向异性网格上使用以下方法推导 $\\phi_x$、$\\phi_y$、$\\phi_{xx}$、$\\phi_{yy}$ 和 $\\phi_{xy}$ 的适当离散近似：\n- 二阶中心差分格式，以及\n- 四阶中心差分格式，\n\n两者都必须正确处理不相等的 $dx$ 和 $dy$。对于混合导数，通过先在 $x$ 方向再在 $y$ 方向上顺序应用所选阶数的导数算子来构建 $\\phi_{xy}$。\n\n实现一个程序，对于每个网格计算：\n1. 单位法线 $\\mathbf{n}$ 及其相对于精确向外径向法线 $\\mathbf{n}_{\\mathrm{exact}} = \\left( \\frac{x-x_0}{\\sqrt{(x-x_0)^2+(y-y_0)^2}}, \\frac{y-y_0}{\\sqrt{(x-x_0)^2+(y-y_0)^2}} \\right)$ 的方向误差，以弧度为单位的角度差来衡量，\n2. 使用上述 Hessian 公式计算的曲率 $\\kappa$ 及其相对于精确界面曲率 $1/R$ 的绝对误差。\n\n将误差计算限制在满足 $|\\phi| \\le \\frac{1}{2}\\min(dx,dy)$ 的网格节点的窄带内，并且限制在格式有效的节点上（即，对于所选格式具有足够邻居节点的内部节点）。使用均方根（RMS）范数汇总带内的误差。\n\n使用以下科学上一致的参数：\n- 计算域：$[0,L_x]\\times[0,L_y]$，其中 $L_x = L_y = 0.2$ 米，\n- 圆心：$(x_0,y_0) = (0.1,0.1)$ 米，\n- 圆半径：$R = 0.05$ 米。\n\n评估以下网格测试套件以探究各向异性效应：\n- 案例 1（各向同性基准）：$(N_x,N_y) = (257,257)$，\n- 案例 2（各向异性，$x$ 方向加密）：$(N_x,N_y) = (513,257)$，\n- 案例 3（各向异性，$y$ 方向加密）：$(N_x,N_y) = (257,513)$，\n- 案例 4（强各向异性，$x$ 方向更密）：$(N_x,N_y) = (1025,129)$，\n- 案例 5（强各向异性，$y$ 方向更密）：$(N_x,N_y) = (129,1025)$。\n\n对于每个案例，计算并报告四个量：\n- 使用二阶格式的均方根法线方向误差（弧度），\n- 使用四阶格式的均方根法线方向误差（弧度），\n- 使用二阶格式的均方根曲率误差（$1/\\mathrm{m}$），\n- 使用四阶格式的均方根曲率误差（$1/\\mathrm{m}$）。\n\n最终输出格式要求：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果。该列表必须按顺序包含案例1的上述四个量，然后是案例2的，依此类推，最终形成一个包含 $20$ 个浮点数的列表。角度必须以弧度表示。曲率误差必须以逆米（$1/\\mathrm{m}$）表示。例如，输出格式的形式为\n$[e_{1,\\mathrm{angle},2}, e_{1,\\mathrm{angle},4}, e_{1,\\kappa,2}, e_{1,\\kappa,4}, e_{2,\\mathrm{angle},2}, \\dots, e_{5,\\kappa,4}]$\n其中下标分别表示案例编号、物理量和格式阶数。",
            "solution": "所提出的问题是有效的，因为它在科学上基于计算燃烧学的原理，在数学上是适定的、客观的且自洽的。它呈现了一个标准的数值分析任务，涉及水平集方法和在各向异性网格上的有限差分近似。我们将进行完整的求解。\n\n这个问题的核心是评估从水平集函数 $\\phi$ 导出的几何量（法向量 $\\mathbf{n}$ 和曲率 $\\kappa$）的有限差分近似的准确性。分析是在一个简单的、已知的几何形状——一个圆上进行的，对于该圆，$\\mathbf{n}$ 和 $\\kappa$ 的精确解析值是可用的，这允许对数值误差进行精确量化。使用各向异性网格（$dx \\neq dy$）是一个关键要素，因为它通常会降低为各向同性网格设计的数值方案的准确性。\n\n以 $(x_0, y_0)$ 为中心、半径为 $R$ 的圆的水平集函数由符号距离函数给出：\n$$ \\phi(x,y) = \\sqrt{(x-x_0)^2 + (y-y_0)^2} - R $$\n界面是零等值线，$\\phi(x,y) = 0$。基本的几何量由 $\\phi$ 的偏导数计算得出。\n\n圆上一点 $(x,y)$ 的精确向外单位法向量 $\\mathbf{n}_{\\mathrm{exact}}$ 从中心 $(x_0,y_0)$ 径向指出：\n$$ \\mathbf{n}_{\\mathrm{exact}}(x,y) = \\frac{(x-x_0, y-y_0)}{\\sqrt{(x-x_0)^2 + (y-y_0)^2}} $$\n一个圆的精确曲率 $\\kappa_{\\mathrm{exact}}$ 是其半径的倒数：\n$$ \\kappa_{\\mathrm{exact}} = \\frac{1}{R} $$\n\n在数值上，我们首先在离散网格上计算 $\\phi$ 的偏导数，然后用它们来计算 $\\mathbf{n}$ 和 $\\kappa$ 的近似值。该问题要求在具有间距 $dx$ 和 $dy$ 的各向异性笛卡尔网格上，推导并实现二阶和四阶精度的中心差分格式。\n\n令 $\\phi_{i,j} = \\phi(i \\cdot dx, j \\cdot dy)$ 为网格节点 $(i,j)$ 上的水平集函数值。\n\n**1. 二阶有限差分格式**\n\n基于泰勒级数展开，各向异性网格上一阶和二阶偏导数的标准二阶中心差分近似为：\n- 一阶导数（$O(dx^2), O(dy^2)$）：\n$$ (\\phi_x)_{i,j} = \\frac{\\partial\\phi}{\\partial x}\\bigg|_{i,j} \\approx \\frac{\\phi_{i+1,j} - \\phi_{i-1,j}}{2\\,dx} $$\n$$ (\\phi_y)_{i,j} = \\frac{\\partial\\phi}{\\partial y}\\bigg|_{i,j} \\approx \\frac{\\phi_{i,j+1} - \\phi_{i,j-1}}{2\\,dy} $$\n- 二阶导数（$O(dx^2), O(dy^2)$）：\n$$ (\\phi_{xx})_{i,j} = \\frac{\\partial^2\\phi}{\\partial x^2}\\bigg|_{i,j} \\approx \\frac{\\phi_{i+1,j} - 2\\phi_{i,j} + \\phi_{i-1,j}}{dx^2} $$\n$$ (\\phi_{yy})_{i,j} = \\frac{\\partial^2\\phi}{\\partial y^2}\\bigg|_{i,j} \\approx \\frac{\\phi_{i,j+1} - 2\\phi_{i,j} + \\phi_{i,j-1}}{dy^2} $$\n- 混合二阶导数（$O(dx^2, dy^2)$），通过顺序应用一阶导数算子（例如 $\\frac{\\partial}{\\partial y}(\\frac{\\partial \\phi}{\\partial x})$）计算得出：\n$$ (\\phi_{xy})_{i,j} = \\frac{\\partial^2\\phi}{\\partial x \\partial y}\\bigg|_{i,j} \\approx \\frac{1}{2\\,dy} \\left[ \\frac{\\phi_{i+1,j+1} - \\phi_{i-1,j+1}}{2\\,dx} - \\frac{\\phi_{i+1,j-1} - \\phi_{i-1,j-1}}{2\\,dx} \\right] $$\n$$ (\\phi_{xy})_{i,j} \\approx \\frac{\\phi_{i+1,j+1} - \\phi_{i-1,j+1} - \\phi_{i+1,j-1} + \\phi_{i-1,j-1}}{4\\,dx\\,dy} $$\n\n**2. 四阶有限差分格式**\n\n高阶格式以更宽的模板（需要更多邻近点）为代价，为光滑函数提供了更高的精度。四阶中心差分格式为：\n- 一阶导数（$O(dx^4), O(dy^4)$）：\n$$ (\\phi_x)_{i,j} \\approx \\frac{-\\phi_{i+2,j} + 8\\phi_{i+1,j} - 8\\phi_{i-1,j} + \\phi_{i-2,j}}{12\\,dx} $$\n$$ (\\phi_y)_{i,j} \\approx \\frac{-\\phi_{i,j+2} + 8\\phi_{i,j+1} - 8\\phi_{i,j-1} + \\phi_{i,j-2}}{12\\,dy} $$\n- 二阶导数（$O(dx^4), O(dy^4)$）：\n$$ (\\phi_{xx})_{i,j} \\approx \\frac{-\\phi_{i+2,j} + 16\\phi_{i+1,j} - 30\\phi_{i,j} + 16\\phi_{i-1,j} - \\phi_{i-2,j}}{12\\,dx^2} $$\n$$ (\\phi_{yy})_{i,j} \\approx \\frac{-\\phi_{i,j+2} + 16\\phi_{i,j+1} - 30\\phi_{i,j} + 16\\phi_{i,j-1} - \\phi_{i,j-2}}{12\\,dy^2} $$\n- 混合二阶导数（$O(dx^4, dy^4)$），同样通过顺序应用（例如使用四阶格式的 $\\frac{\\partial}{\\partial y}(\\frac{\\partial \\phi}{\\partial x})$）计算得出：\n$$ (\\phi_{xy})_{i,j} \\approx \\frac{1}{12\\,dy} \\left[ (\\phi_x)_{i,j+2}(-1) + (\\phi_x)_{i,j+1}(8) - (\\phi_x)_{i,j-1}(8) + (\\phi_x)_{i,j-2}(1) \\right] $$\n其中每个 $(\\phi_x)$ 项都使用 $x$ 导数的四阶格式进行评估。这导致 $\\phi_{xy}$ 的计算需要一个 $5 \\times 5$ 的模板。\n\n**3. 数值评估程序**\n对于每个测试案例网格以及每种精度阶数（二阶和四阶），执行以下步骤：\n1.  **网格与场生成**：在计算域 $[0, L_x] \\times [0, L_y]$ 上创建一个 $N_x \\times N_y$ 网格。网格间距为 $dx = L_x / (N_x - 1)$ 和 $dy = L_y / (N_y - 1)$。在每个网格节点上计算精确的符号距离函数 $\\phi$。\n2.  **导数计算**：使用相应阶数的格式在整个网格上计算偏导数 $\\phi_x, \\phi_y, \\phi_{xx}, \\phi_{yy}, \\phi_{xy}$。\n3.  **几何量计算**：使用提供的公式在每个网格节点上计算数值法向量 $\\mathbf{n}$ 和曲率 $\\kappa$：\n    $$ \\mathbf{n} = \\frac{(\\phi_x, \\phi_y)}{\\sqrt{\\phi_x^2 + \\phi_y^2}}, \\qquad \\kappa = \\frac{\\phi_{xx}\\,\\phi_y^2 - 2\\,\\phi_x\\,\\phi_y\\,\\phi_{xy} + \\phi_{yy}\\,\\phi_x^2}{(\\phi_x^2+\\phi_y^2)^{3/2}} $$\n    在分母上添加一个小的 epsilon 以防止除以零。\n4.  **误差分析域**：仅对网格节点的一个子集进行误差分析。我们定义一个掩码，选择满足两个条件的节点：\n    a.  **窄带**：节点必须靠近真实界面，即 $|\\phi| \\le \\frac{1}{2}\\min(dx,dy)$。\n    b.  **内部节点**：节点必须有足够的邻居以使格式有效。对于二阶格式，这意味着排除一个 $1$ 单元的边界层。对于四阶格式，则排除一个 $2$ 单元的边界层。\n5.  **误差计算**：\n    a.  **法线方向误差**：误差是数值法线 $\\mathbf{n}$ 和精确法线 $\\mathbf{n}_{\\mathrm{exact}}$ 之间的夹角（以弧度为单位）。通过 $\\theta = \\arccos(\\mathbf{n} \\cdot \\mathbf{n}_{\\mathrm{exact}})$ 计算。\n    b.  **曲率误差**：误差是数值曲率 $\\kappa$ 与精确曲率 $\\kappa_{\\mathrm{exact}} = 1/R$ 之间的差值。\n6.  **误差汇总**：在掩码选择的所有节点上计算每种误差类型的均方根（RMS）。对于一个误差场 $e$，RMS 误差为 $\\sqrt{\\langle e^2 \\rangle}$。\n\n这个系统性的程序可以直接比较格式阶数和网格各向异性对火焰模拟中至关重要的几何量精度的影响。",
            "answer": "```python\nimport numpy as np\n\ndef compute_derivatives(phi, dx, dy, order):\n    \"\"\"\n    Computes partial derivatives of a 2D field using finite differences.\n    NOTE: Assumes 'ij' indexing for phi, where axis 0 is x and axis 1 is y.\n    \"\"\"\n    if order == 2:\n        # First derivatives (2nd-order central)\n        phi_x = (np.roll(phi, -1, axis=0) - np.roll(phi, 1, axis=0)) / (2 * dx)\n        phi_y = (np.roll(phi, -1, axis=1) - np.roll(phi, 1, axis=1)) / (2 * dy)\n        \n        # Second derivatives (2nd-order central)\n        phi_xx = (np.roll(phi, -1, axis=0) - 2 * phi + np.roll(phi, 1, axis=0)) / (dx**2)\n        phi_yy = (np.roll(phi, -1, axis=1) - 2 * phi + np.roll(phi, 1, axis=1)) / (dy**2)\n        \n        # Mixed derivative by sequential application\n        phi_xy = (np.roll(phi_x, -1, axis=1) - np.roll(phi_x, 1, axis=1)) / (2 * dy)\n\n    elif order == 4:\n        # First derivatives (4th-order central)\n        phi_x = (-np.roll(phi, -2, axis=0) + 8 * np.roll(phi, -1, axis=0) - 8 * np.roll(phi, 1, axis=0) + np.roll(phi, 2, axis=0)) / (12 * dx)\n        phi_y = (-np.roll(phi, -2, axis=1) + 8 * np.roll(phi, -1, axis=1) - 8 * np.roll(phi, 1, axis=1) + np.roll(phi, 2, axis=1)) / (12 * dy)\n        \n        # Second derivatives (4th-order central)\n        phi_xx = (-np.roll(phi, -2, axis=0) + 16 * np.roll(phi, -1, axis=0) - 30 * phi + 16 * np.roll(phi, 1, axis=0) - np.roll(phi, 2, axis=0)) / (12 * dx**2)\n        phi_yy = (-np.roll(phi, -2, axis=1) + 16 * np.roll(phi, -1, axis=1) - 30 * phi + 16 * np.roll(phi, 1, axis=1) - np.roll(phi, 2, axis=1)) / (12 * dy**2)\n\n        # Mixed derivative by sequential application\n        phi_xy = (-np.roll(phi_x, -2, axis=1) + 8 * np.roll(phi_x, -1, axis=1) - 8 * np.roll(phi_x, 1, axis=1) + np.roll(phi_x, 2, axis=1)) / (12 * dy)\n    else:\n        raise ValueError(\"Order must be 2 or 4\")\n        \n    return phi_x, phi_y, phi_xx, phi_yy, phi_xy\n\ndef compute_metrics_for_case(case_params, constants):\n    \"\"\"\n    Computes the four required error metrics for a single grid configuration.\n    \"\"\"\n    Nx, Ny = case_params\n    Lx, Ly, x0, y0, R = constants.values()\n\n    # Grid setup\n    dx = Lx / (Nx - 1)\n    dy = Ly / (Ny - 1)\n    x = np.linspace(0, Lx, Nx)\n    y = np.linspace(0, Ly, Ny)\n    # Use 'ij' indexing so that the first axis (0) corresponds to x\n    # and the second axis (1) corresponds to y.\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # Level-set field\n    phi = np.sqrt((X - x0)**2 + (Y - y0)**2) - R\n    \n    errors = {}\n\n    for order in [2, 4]:\n        # Compute derivatives\n        phi_x, phi_y, phi_xx, phi_yy, phi_xy = compute_derivatives(phi, dx, dy, order)\n        \n        # Define masks\n        # Interior mask to exclude boundaries where stencils are invalid\n        interior_mask = np.zeros_like(phi, dtype=bool)\n        stencil_width = order // 2 # 1 for 2nd order, 2 for 4th order\n        interior_mask[stencil_width:Nx-stencil_width, stencil_width:Ny-stencil_width] = True\n        \n        # Narrow band mask\n        band_width = 0.5 * min(dx, dy)\n        band_mask = np.abs(phi) = band_width\n        \n        # Final mask for analysis\n        mask = interior_mask  band_mask\n\n        # Numerical normal and curvature\n        grad_phi_norm_sq = phi_x**2 + phi_y**2\n        \n        epsilon = 1e-15\n        grad_phi_norm = np.sqrt(grad_phi_norm_sq + epsilon)\n        \n        nx = phi_x / grad_phi_norm\n        ny = phi_y / grad_phi_norm\n        \n        kappa_num = (phi_xx * phi_y**2 - 2 * phi_x * phi_y * phi_xy + phi_yy * phi_x**2)\n        kappa_den = (grad_phi_norm_sq)**(1.5)\n        kappa = kappa_num / (kappa_den + epsilon)\n\n        # Exact quantities\n        r = np.sqrt((X - x0)**2 + (Y - y0)**2)\n        r_safe = np.where(r == 0, epsilon, r)\n        nx_exact = (X - x0) / r_safe\n        ny_exact = (Y - y0) / r_safe\n        kappa_exact = 1.0 / R\n\n        # Compute errors\n        # Normal vector orientation error\n        dot_product = np.clip(nx * nx_exact + ny * ny_exact, -1.0, 1.0)\n        angle_error = np.arccos(dot_product)\n        \n        # Curvature error\n        curvature_error = kappa - kappa_exact\n        \n        # RMS errors over the masked region\n        rms_angle_error = np.sqrt(np.mean(angle_error[mask]**2))\n        rms_kappa_error = np.sqrt(np.mean(curvature_error[mask]**2))\n        \n        errors[f'angle_{order}'] = rms_angle_error\n        errors[f'kappa_{order}'] = rms_kappa_error\n        \n    return [errors['angle_2'], errors['angle_4'], errors['kappa_2'], errors['kappa_4']]\n\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases and print the results.\n    \"\"\"\n    # Define constants\n    constants = {\n        'Lx': 0.2, 'Ly': 0.2,\n        'x0': 0.1, 'y0': 0.1,\n        'R': 0.05\n    }\n    \n    # Define test cases from the problem statement\n    test_cases = [\n        (257, 257),   # Case 1: Isotropic baseline\n        (513, 257),   # Case 2: Anisotropic, refined in x\n        (257, 513),   # Case 3: Anisotropic, refined in y\n        (1025, 129),  # Case 4: Strong anisotropy, x much finer\n        (129, 1025)   # Case 5: Strong anisotropy, y much finer\n    ]\n    \n    results = []\n    for case in test_cases:\n        case_results = compute_metrics_for_case(case, constants)\n        results.extend(case_results)\n        \n    print(f\"[{','.join(f'{r:.12e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}