{
    "hands_on_practices": [
        {
            "introduction": "To build a solid understanding of the G-equation, we begin with the most fundamental scenario: a premixed flame propagating into a quiescent, or still, gas. This idealized case allows us to isolate the intrinsic kinematic behavior of the flame front, as described by the Hamilton-Jacobi equation $G_t = S_L |\\nabla G|$. This exercise challenges you to solve this equation analytically for a planar front using the method of characteristics, providing a rigorous demonstration of how the level-set formulation captures the constant-speed translation of a simple flame. ",
            "id": "4035876",
            "problem": "Consider a premixed flame front represented by a level-set function $G(\\mathbf{x},t)$, where the front is the zero level set $G(\\mathbf{x},t)=0$. The evolution of $G$ in the Level-Set formulation for a constant normal propagation speed $S_L$ in a quiescent flow is given by the Partial Differential Equation (PDE) $G_t = S_L |\\nabla G|$, which is a Hamilton-Jacobi (HJ) type PDE derived from the kinematic law that the front moves along its normal direction with speed $S_L$. Assume a spatial dimension $d \\geq 2$ and a planar initial condition $G(\\mathbf{x},0) = \\mathbf{n}\\cdot\\mathbf{x} - d_0$, where $\\mathbf{n} \\in \\mathbb{R}^d$ is a unit normal vector satisfying $|\\mathbf{n}|=1$ and $d_0 \\in \\mathbb{R}$ is a constant.\n\nStarting from the fundamental definition of a level-set front with constant normal speed, formulate the associated Hamilton-Jacobi characteristic system and solve the PDE $G_t = S_L |\\nabla G|$ for the given planar initial data. Using first principles, demonstrate that the zero level set remains planar and translates without shape change, and determine the explicit closed-form expression for $G(\\mathbf{x},t)$ valid for all $\\mathbf{x} \\in \\mathbb{R}^d$ and $t \\geq 0$.\n\nProvide your final answer as a single analytic expression for $G(\\mathbf{x},t)$.",
            "solution": "The problem requires solving the partial differential equation (PDE) for the level-set function $G(\\mathbf{x},t)$, given by $G_t = S_L |\\nabla G|$, with a planar initial condition $G(\\mathbf{x},0) = \\mathbf{n}\\cdot\\mathbf{x} - d_0$. Here, $S_L$ is a constant, and $\\mathbf{n}$ is a unit vector, i.e., $|\\mathbf{n}|=1$. This is a first-order, non-linear PDE of the Hamilton-Jacobi type. We will solve it using the method of characteristics.\n\nFirst, we rewrite the PDE in the standard Hamilton-Jacobi form, $G_t + H(\\nabla G) = 0$. By comparing with the given equation, we identify the Hamiltonian $H$ as a function of the gradient vector $\\mathbf{p} = \\nabla G$:\n$$H(\\mathbf{p}) = -S_L |\\mathbf{p}|$$\nThe method of characteristics transforms the PDE into a system of ordinary differential equations (ODEs) that describe curves, called characteristics, along which the solution can be constructed. These ODEs describe the evolution of the position $\\mathbf{x}(t)$, the gradient $\\mathbf{p}(t) = \\nabla G(\\mathbf{x}(t),t)$, and the value of the function $G(t) = G(\\mathbf{x}(t),t)$ along a characteristic curve parameterized by time $t$.\n\nThe characteristic equations for a Hamiltonian $H(\\mathbf{x}, \\mathbf{p}, t)$ are:\n$$ \\frac{d\\mathbf{x}}{dt} = \\nabla_{\\mathbf{p}} H, \\quad \\frac{d\\mathbf{p}}{dt} = -\\nabla_{\\mathbf{x}} H, \\quad \\frac{dG}{dt} = G_t + \\nabla G \\cdot \\frac{d\\mathbf{x}}{dt} = -H + \\mathbf{p} \\cdot \\nabla_{\\mathbf{p}} H $$\nIn our case, the Hamiltonian $H(\\mathbf{p}) = -S_L |\\mathbf{p}| = -S_L \\sqrt{\\mathbf{p}\\cdot\\mathbf{p}}$ depends only on $\\mathbf{p}$, not explicitly on $\\mathbf{x}$ or $t$.\n\nLet's compute the necessary derivatives of $H$:\n1. The gradient of $H$ with respect to $\\mathbf{p}$:\n$$ \\nabla_{\\mathbf{p}} H = \\nabla_{\\mathbf{p}} (-S_L |\\mathbf{p}|) = -S_L \\frac{\\mathbf{p}}{|\\mathbf{p}|} $$\n2. The gradient of $H$ with respect to $\\mathbf{x}$:\nSince $H$ has no explicit dependence on $\\mathbf{x}$,\n$$ \\nabla_{\\mathbf{x}} H = \\mathbf{0} $$\n\nSubstituting these into the characteristic equations, we obtain the specific system of ODEs for this problem:\n$$ (1) \\quad \\frac{d\\mathbf{x}}{dt} = -S_L \\frac{\\mathbf{p}}{|\\mathbf{p}|} $$\n$$ (2) \\quad \\frac{d\\mathbf{p}}{dt} = \\mathbf{0} $$\n$$ (3) \\quad \\frac{dG}{dt} = -H(\\mathbf{p}) + \\mathbf{p} \\cdot \\nabla_{\\mathbf{p}} H = -(-S_L |\\mathbf{p}|) + \\mathbf{p} \\cdot \\left(-S_L \\frac{\\mathbf{p}}{|\\mathbf{p}|}\\right) = S_L |\\mathbf{p}| - S_L \\frac{|\\mathbf{p}|^2}{|\\mathbf{p}|} = S_L |\\mathbf{p}| - S_L |\\mathbf{p}| = 0 $$\n\nTo solve this system, we need initial conditions. We consider a characteristic curve that originates at an arbitrary point $\\mathbf{x}_0$ in space at time $t=0$. The initial conditions are:\n- Position: $\\mathbf{x}(0) = \\mathbf{x}_0$.\n- Value of $G$: $G(0) = G(\\mathbf{x}_0, 0) = \\mathbf{n} \\cdot \\mathbf{x}_0 - d_0$.\n- Gradient: $\\mathbf{p}(0) = \\nabla G(\\mathbf{x},0)|_{\\mathbf{x}=\\mathbf{x}_0}$. From the initial condition $G(\\mathbf{x},0) = \\mathbf{n}\\cdot\\mathbf{x} - d_0$, we compute the gradient: $\\mathbf{p}(0) = \\nabla_{\\mathbf{x}} (\\mathbf{n}\\cdot\\mathbf{x} - d_0) = \\mathbf{n}$.\n\nNow we can solve the ODEs:\nFrom equation $(2)$, $\\frac{d\\mathbf{p}}{dt} = \\mathbf{0}$ with the initial condition $\\mathbf{p}(0) = \\mathbf{n}$, we find that the gradient is constant along each characteristic:\n$$ \\mathbf{p}(t) = \\mathbf{n} $$\nThis result is significant; it implies that the gradient vector does not change as we move along a characteristic curve.\n\nNext, we solve for the position $\\mathbf{x}(t)$ using equation $(1)$. Substituting $\\mathbf{p}(t) = \\mathbf{n}$ and using the given fact that $|\\mathbf{n}|=1$:\n$$ \\frac{d\\mathbf{x}}{dt} = -S_L \\frac{\\mathbf{n}}{|\\mathbf{n}|} = -S_L \\mathbf{n} $$\nThis is a simple ODE for $\\mathbf{x}(t)$. Integrating with respect to time from $0$ to $t$ with initial condition $\\mathbf{x}(0) = \\mathbf{x}_0$:\n$$ \\mathbf{x}(t) - \\mathbf{x}(0) = \\int_0^t (-S_L \\mathbf{n}) d\\tau = -S_L \\mathbf{n} t $$\n$$ \\mathbf{x}(t) = \\mathbf{x}_0 - S_L \\mathbf{n} t $$\nThis equation describes the trajectory of a point on the characteristic, showing that it moves with a constant velocity $-S_L \\mathbf{n}$.\n\nFinally, we solve for $G(t)$ using equation $(3)$:\n$$ \\frac{dG}{dt} = 0 $$\nThis implies that $G$ is constant along any characteristic curve. Therefore, its value at any time $t$ is the same as its initial value at $t=0$:\n$$ G(\\mathbf{x}(t), t) = G(\\mathbf{x}_0, 0) = \\mathbf{n} \\cdot \\mathbf{x}_0 - d_0 $$\n\nWe have now found the solution $G$ along the characteristic curves. To obtain the general solution $G(\\mathbf{x},t)$ for any point $(\\mathbf{x}, t)$, we must express it in terms of $\\mathbf{x}$ and $t$ instead of the initial point $\\mathbf{x}_0$. From the solution for $\\mathbf{x}(t)$, we can express the initial position $\\mathbf{x}_0$ in terms of the position $\\mathbf{x}$ at a later time $t$:\n$$ \\mathbf{x}_0 = \\mathbf{x} + S_L \\mathbf{n} t $$\nSubstituting this expression for $\\mathbf{x}_0$ into the equation for $G$:\n$$ G(\\mathbf{x}, t) = \\mathbf{n} \\cdot (\\mathbf{x} + S_L \\mathbf{n} t) - d_0 $$\nExpanding the dot product:\n$$ G(\\mathbf{x}, t) = \\mathbf{n} \\cdot \\mathbf{x} + S_L (\\mathbf{n} \\cdot \\mathbf{n}) t - d_0 $$\nSince $\\mathbf{n}$ is a unit vector, $\\mathbf{n} \\cdot \\mathbf{n} = |\\mathbf{n}|^2 = 1^2 = 1$. This leads to the final closed-form expression for the solution:\n$$ G(\\mathbf{x}, t) = \\mathbf{n} \\cdot \\mathbf{x} + S_L t - d_0 $$\n\nLet us verify this solution.\n- Initial condition: at $t=0$, $G(\\mathbf{x},0) = \\mathbf{n} \\cdot \\mathbf{x} - d_0$, which is correct.\n- PDE: $G_t = \\frac{\\partial}{\\partial t}(\\mathbf{n} \\cdot \\mathbf{x} + S_L t - d_0) = S_L$. The gradient is $\\nabla G = \\nabla_{\\mathbf{x}}(\\mathbf{n} \\cdot \\mathbf{x} + S_L t - d_0) = \\mathbf{n}$. Then $|\\nabla G| = |\\mathbf{n}| = 1$. The right-hand side of the PDE is $S_L |\\nabla G| = S_L(1) = S_L$. Since $G_t = S_L$, the PDE $G_t = S_L |\\nabla G|$ is satisfied.\n\nFinally, we examine the evolution of the zero level set, which represents the flame front. The front is defined by the condition $G(\\mathbf{x},t) = 0$.\n$$ \\mathbf{n} \\cdot \\mathbf{x} + S_L t - d_0 = 0 $$\n$$ \\mathbf{n} \\cdot \\mathbf{x} = d_0 - S_L t $$\nFor any fixed time $t$, this is the equation of a hyperplane in $\\mathbb{R}^d$ with a constant normal vector $\\mathbf{n}$. This demonstrates that the flame front remains planar for all $t \\geq 0$. The initial front at $t=0$ is $\\mathbf{n} \\cdot \\mathbf{x} = d_0$. The front at time $t$ has the same normal vector, meaning it translates without rotation or change in shape. The signed distance of the plane from the origin along the direction $\\mathbf{n}$ is $D(t) = d_0 - S_L t$. The velocity of the front is given by the time derivative of its position vector, which can be expressed as $D(t)\\mathbf{n}$. The velocity is $\\frac{d}{dt}(D(t)\\mathbf{n}) = \\frac{d}{dt}((d_0 - S_L t)\\mathbf{n}) = -S_L \\mathbf{n}$. The speed of the front is the magnitude of this velocity, $|-S_L \\mathbf{n}| = S_L|\\mathbf{n}| = S_L$. Thus, the planar front translates with a constant speed $S_L$ in the direction opposite to its normal vector $\\mathbf{n}$.\nThe explicit closed-form expression for $G(\\mathbf{x},t)$ provides the complete solution.",
            "answer": "$$\n\\boxed{G(\\mathbf{x},t) = \\mathbf{n} \\cdot \\mathbf{x} + S_L t - d_0}\n$$"
        },
        {
            "introduction": "Moving from a quiescent medium to a flowing one, we now explore how a flame front interacts with a uniform flow field, a common configuration in many practical burners. When the flow velocity balances the flame's propagation speed, a steady flame can be stabilized, or \"anchored,\" in place. This practice focuses on the steady-state Eikonal form of the G-equation, guiding you to derive the characteristic angle of an oblique flame, a result that directly links the theory to observable flame structures. ",
            "id": "4035858",
            "problem": "Consider a two-dimensional, steady, premixed flame represented by a level-set function $G(x,y)$, whose zero level set $G=0$ coincides with the flame front. The $G$-equation in steady state reduces to the Eikonal form\n$$\n\\mathbf{u}\\cdot\\nabla G \\;=\\; S_L\\,\\lvert \\nabla G\\rvert,\n$$\nwhere $\\mathbf{u}=(U,0)$ is a uniform inlet velocity with $U>0$ and $S_L>0$ is the constant laminar burning speed of the mixture. The domain is the half-plane $y\\ge 0$, and the boundary condition along the line $y=0$ is\n$G(x,0)=x$.\nAssume $U\\ge S_L$ so that a steady attached flame is possible. Solve the steady Eikonal equation subject to the boundary condition. Then, define the flame angle $\\alpha$ as the angle (in radians) between the unit normal $\\mathbf{n}=\\nabla G/\\lvert \\nabla G\\rvert$ (pointing in the direction of increasing $G$) and the positive $x$-axis. Express $\\alpha$ in terms of $U$ and $S_L$, and report $\\alpha$ (in radians) as your final answer. If multiple branches arise, select the branch with $\\partial G/\\partial y>0$.",
            "solution": "The problem asks for the angle $\\alpha$ of a steady, oblique flame in a uniform flow. We must solve the steady-state G-equation, also known as the Eikonal equation, subject to the given boundary conditions.\n\nThe governing partial differential equation (PDE) is:\n$$ \\mathbf{u}\\cdot\\nabla G = S_L \\lvert \\nabla G \\rvert $$\nIn two-dimensional Cartesian coordinates, with the velocity field $\\mathbf{u} = (U, 0)$ and the gradient $\\nabla G = (\\frac{\\partial G}{\\partial x}, \\frac{\\partial G}{\\partial y})$, the equation becomes:\n$$ (U, 0) \\cdot \\left(\\frac{\\partial G}{\\partial x}, \\frac{\\partial G}{\\partial y}\\right) = S_L \\sqrt{\\left(\\frac{\\partial G}{\\partial x}\\right)^2 + \\left(\\frac{\\partial G}{\\partial y}\\right)^2} $$\n$$ U \\frac{\\partial G}{\\partial x} = S_L \\sqrt{\\left(\\frac{\\partial G}{\\partial x}\\right)^2 + \\left(\\frac{\\partial G}{\\partial y}\\right)^2} $$\nThe uniform flow and linear boundary condition suggest a linear trial solution for the level-set function $G(x,y)$ of the form:\n$$ G(x,y) = ax + by + c $$\nwhere $a$, $b$, and $c$ are constants to be determined.\n\nWe apply the boundary condition $G(x,0) = x$:\n$$ G(x,0) = a(x) + b(0) + c = ax+c $$\nFor this to hold for all $x$, we must have $a=1$ and $c=0$. The trial solution simplifies to:\n$$ G(x,y) = x + by $$\nThe partial derivatives of this solution are:\n$$ \\frac{\\partial G}{\\partial x} = 1, \\quad \\frac{\\partial G}{\\partial y} = b $$\nSubstitute these constant derivatives back into the PDE:\n$$ U (1) = S_L \\sqrt{(1)^2 + (b)^2} $$\n$$ U = S_L \\sqrt{1 + b^2} $$\nNow we solve for the constant $b$. Since the problem states $U \\ge S_L > 0$, we can square both sides without introducing extraneous solutions:\n$$ U^2 = S_L^2 (1 + b^2) $$\n$$ \\frac{U^2}{S_L^2} = 1 + b^2 $$\n$$ b^2 = \\left(\\frac{U}{S_L}\\right)^2 - 1 $$\nThis yields two possible values for $b$:\n$$ b = \\pm \\sqrt{\\left(\\frac{U}{S_L}\\right)^2 - 1} $$\nThe problem provides a branch selection criterion: we must choose the solution with $\\partial G / \\partial y > 0$. Since $\\partial G / \\partial y = b$, we must select the positive root:\n$$ b = \\sqrt{\\left(\\frac{U}{S_L}\\right)^2 - 1} $$\nThis solution for $b$ is real because of the given physical constraint $U \\ge S_L$.\n\nThe flame angle $\\alpha$ is defined as the angle between the unit normal vector $\\mathbf{n}$ and the positive $x$-axis. The normal vector $\\mathbf{n}$ is given by $\\mathbf{n} = \\nabla G / \\lvert\\nabla G\\rvert$.\nFirst, we find the gradient vector $\\nabla G$:\n$$ \\nabla G = \\left(\\frac{\\partial G}{\\partial x}, \\frac{\\partial G}{\\partial y}\\right) = (1, b) = \\left(1, \\sqrt{\\left(\\frac{U}{S_L}\\right)^2 - 1}\\right) $$\nNext, we find its magnitude, $\\lvert\\nabla G\\rvert$. From the PDE itself, we have $\\lvert\\nabla G\\rvert = U/S_L$.\nSo, the unit normal vector is:\n$$ \\mathbf{n} = \\frac{\\nabla G}{\\lvert\\nabla G\\rvert} = \\frac{\\left(1, \\sqrt{\\left(\\frac{U}{S_L}\\right)^2 - 1}\\right)}{U/S_L} = \\left(\\frac{S_L}{U}, \\frac{S_L}{U}\\sqrt{\\left(\\frac{U}{S_L}\\right)^2 - 1}\\right) $$\n$$ \\mathbf{n} = \\left(\\frac{S_L}{U}, \\sqrt{1 - \\left(\\frac{S_L}{U}\\right)^2}\\right) $$\nThe angle $\\alpha$ between $\\mathbf{n}=(n_x, n_y)$ and the positive $x$-axis unit vector $\\mathbf{e}_x = (1,0)$ is given by $\\cos(\\alpha) = \\mathbf{n} \\cdot \\mathbf{e}_x = n_x$.\n$$ \\cos(\\alpha) = \\frac{S_L}{U} $$\nSince we chose $b>0$, the $y$-component of the normal, $n_y$, is positive. This means $\\sin(\\alpha) > 0$. The condition $U \\ge S_L > 0$ implies $0  S_L/U \\le 1$, which places the angle $\\alpha$ in the first quadrant, i.e., $\\alpha \\in [0, \\pi/2]$. Therefore, the angle is uniquely determined by the arccosine function.\n$$ \\alpha = \\arccos\\left(\\frac{S_L}{U}\\right) $$",
            "answer": "$$\n\\boxed{\\arccos\\left(\\frac{S_L}{U}\\right)}\n$$"
        },
        {
            "introduction": "While analytical solutions provide essential physical insight, most real-world applications require solving the G-equation numerically on a discrete grid. The accuracy of these simulations depends critically on how well we compute geometric properties like the normal vector $\\mathbf{n}$ and curvature $\\kappa$ from the level-set field. This computational exercise tasks you with implementing and testing finite difference schemes to quantify how grid characteristics, especially anisotropy ($dx \\neq dy$), can introduce errors and impact the fidelity of a flame simulation. ",
            "id": "4035843",
            "problem": "Consider a two-dimensional level-set representation of a premixed flame front. The front is modeled as a circle of radius $R$ centered at $(x_0,y_0)$, defined by the signed distance function $\\phi(x,y) = \\sqrt{(x-x_0)^2+(y-y_0)^2} - R$. In the Hamilton-Jacobi formulation of the Geometric Equation (G-equation) for premixed flames, the front normal $\\mathbf{n}$ and geometric curvature $\\kappa$ are fundamental quantities that enter the propagation law. For a level-set function $\\phi$, these quantities are defined by the core geometric identities\n$$\n\\mathbf{n} = \\frac{\\nabla \\phi}{\\lVert \\nabla \\phi \\rVert}, \\qquad \\kappa = \\nabla \\cdot \\left( \\frac{\\nabla \\phi}{\\lVert \\nabla \\phi \\rVert} \\right),\n$$\nand, equivalently at points of smoothness, by the Hessian-based formula\n$$\n\\kappa = \\frac{\\phi_{xx}\\,\\phi_y^2 - 2\\,\\phi_x\\,\\phi_y\\,\\phi_{xy} + \\phi_{yy}\\,\\phi_x^2}{\\left(\\phi_x^2+\\phi_y^2\\right)^{3/2}}.\n$$\nOn a Cartesian grid with spacings $dx$ and $dy$ that may be unequal (an anisotropic grid), these derivatives are approximated using finite difference stencils. Grid anisotropy can induce directional errors in the computed $\\mathbf{n}$ and $\\kappa$ even for a perfectly isotropic geometry like a circle.\n\nStarting from the above definitions, derive appropriate discrete approximations for $\\phi_x$, $\\phi_y$, $\\phi_{xx}$, $\\phi_{yy}$, and $\\phi_{xy}$ on anisotropic grids using:\n- A second-order central difference stencil, and\n- A fourth-order central difference stencil,\n\nboth of which must correctly account for unequal $dx$ and $dy$. For mixed derivatives, construct $\\phi_{xy}$ by sequentially applying the chosen-order derivative operators first in $x$ and then in $y$.\n\nImplement a program that, for each grid, computes:\n1. The unit normal $\\mathbf{n}$ and its orientation error with respect to the exact outward radial normal $\\mathbf{n}_{\\mathrm{exact}} = \\left( \\frac{x-x_0}{\\sqrt{(x-x_0)^2+(y-y_0)^2}}, \\frac{y-y_0}{\\sqrt{(x-x_0)^2+(y-y_0)^2}} \\right)$, measured as the angle difference in radians,\n2. The curvature $\\kappa$ using the Hessian formula above and its absolute error with respect to the exact interface curvature $1/R$.\n\nRestrict error computations to a narrow band of grid nodes satisfying $|\\phi| \\le \\frac{1}{2}\\min(dx,dy)$ and to nodes where the stencils are valid (i.e., interior nodes with sufficient neighbors for the chosen stencil). Aggregate the errors in the band using root-mean-square (RMS) norms.\n\nUse the following scientifically consistent parameters:\n- Domain: $[0,L_x]\\times[0,L_y]$ with $L_x = L_y = 0.2$ meters,\n- Circle center: $(x_0,y_0) = (0.1,0.1)$ meters,\n- Circle radius: $R = 0.05$ meters.\n\nEvaluate the following test suite of grids to probe anisotropy effects:\n- Case 1 (isotropic baseline): $(N_x,N_y) = (257,257)$,\n- Case 2 (anisotropic, refined in $x$): $(N_x,N_y) = (513,257)$,\n- Case 3 (anisotropic, refined in $y$): $(N_x,N_y) = (257,513)$,\n- Case 4 (strong anisotropy, $x$ much finer): $(N_x,N_y) = (1025,129)$,\n- Case 5 (strong anisotropy, $y$ much finer): $(N_x,N_y) = (129,1025)$.\n\nFor each case, compute and report four quantities:\n- RMS normal orientation error in radians using the second-order stencil,\n- RMS normal orientation error in radians using the fourth-order stencil,\n- RMS curvature error in $1/\\mathrm{m}$ using the second-order stencil,\n- RMS curvature error in $1/\\mathrm{m}$ using the fourth-order stencil.\n\nFinal output format requirement:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain the above four quantities in order for Case 1, then for Case 2, and so on, resulting in a list of $20$ floats. Angles must be expressed in radians. Curvature errors must be expressed in inverse meters ($1/\\mathrm{m}$). For example, an output format of the form\n$[e_{1,\\mathrm{angle},2}, e_{1,\\mathrm{angle},4}, e_{1,\\kappa,2}, e_{1,\\kappa,4}, e_{2,\\mathrm{angle},2}, \\dots, e_{5,\\kappa,4}]$\nwhere the subscripts indicate case number, quantity, and stencil order is required.",
            "solution": "The posed problem is valid as it is scientifically grounded in the principles of computational combustion, mathematically well-posed, objective, and self-contained. It presents a standard numerical analysis task involving the level-set method and finite difference approximations on anisotropic grids. We will proceed with a full solution.\n\nThe core of this problem is to evaluate the accuracy of finite difference approximations for geometric quantities (normal vector $\\mathbf{n}$ and curvature $\\kappa$) derived from a level-set function $\\phi$. The analysis is performed on a simple, known geometry—a circle—for which exact analytical values of $\\mathbf{n}$ and $\\kappa$ are available, allowing for a precise quantification of numerical errors. The use of anisotropic grids ($dx \\neq dy$) is a key element, as it often degrades the accuracy of numerical schemes designed for isotropic grids.\n\nThe level-set function for a circle of radius $R$ centered at $(x_0, y_0)$ is given as the signed distance function:\n$$ \\phi(x,y) = \\sqrt{(x-x_0)^2 + (y-y_0)^2} - R $$\nThe interface is the zero-contour, $\\phi(x,y) = 0$. The fundamental geometric quantities are computed from the partial derivatives of $\\phi$.\n\nThe exact outward unit normal vector $\\mathbf{n}_{\\mathrm{exact}}$ at a point $(x,y)$ on the circle is directed radially from the center $(x_0,y_0)$:\n$$ \\mathbf{n}_{\\mathrm{exact}}(x,y) = \\frac{(x-x_0, y-y_0)}{\\sqrt{(x-x_0)^2 + (y-y_0)^2}} $$\nThe exact curvature $\\kappa_{\\mathrm{exact}}$ of a circle is the reciprocal of its radius:\n$$ \\kappa_{\\mathrm{exact}} = \\frac{1}{R} $$\n\nNumerically, we first compute the partial derivatives of $\\phi$ on a discrete grid, then use these to compute approximations of $\\mathbf{n}$ and $\\kappa$. The problem requires the derivation and implementation of second-order and fourth-order accurate central difference stencils on an anisotropic Cartesian grid with spacings $dx$ and $dy$.\n\nLet $\\phi_{i,j} = \\phi(i \\cdot dx, j \\cdot dy)$ be the value of the level-set function at grid node $(i,j)$.\n\n**1. Second-Order Finite Difference Stencils**\n\nBased on Taylor series expansions, the standard second-order central difference approximations for the first and second partial derivatives on an anisotropic grid are:\n- First derivatives ($O(dx^2), O(dy^2)$):\n$$ (\\phi_x)_{i,j} = \\frac{\\partial\\phi}{\\partial x}\\bigg|_{i,j} \\approx \\frac{\\phi_{i+1,j} - \\phi_{i-1,j}}{2\\,dx} $$\n$$ (\\phi_y)_{i,j} = \\frac{\\partial\\phi}{\\partial y}\\bigg|_{i,j} \\approx \\frac{\\phi_{i,j+1} - \\phi_{i,j-1}}{2\\,dy} $$\n- Second derivatives ($O(dx^2), O(dy^2)$):\n$$ (\\phi_{xx})_{i,j} = \\frac{\\partial^2\\phi}{\\partial x^2}\\bigg|_{i,j} \\approx \\frac{\\phi_{i+1,j} - 2\\phi_{i,j} + \\phi_{i-1,j}}{dx^2} $$\n$$ (\\phi_{yy})_{i,j} = \\frac{\\partial^2\\phi}{\\partial y^2}\\bigg|_{i,j} \\approx \\frac{\\phi_{i,j+1} - 2\\phi_{i,j} + \\phi_{i,j-1}}{dy^2} $$\n- Mixed second derivative ($O(dx^2, dy^2)$), computed by sequential application of first-derivative operators (e.g., $\\frac{\\partial}{\\partial y}(\\frac{\\partial \\phi}{\\partial x})$):\n$$ (\\phi_{xy})_{i,j} = \\frac{\\partial^2\\phi}{\\partial x \\partial y}\\bigg|_{i,j} \\approx \\frac{1}{2\\,dy} \\left[ \\frac{\\phi_{i+1,j+1} - \\phi_{i-1,j+1}}{2\\,dx} - \\frac{\\phi_{i+1,j-1} - \\phi_{i-1,j-1}}{2\\,dx} \\right] $$\n$$ (\\phi_{xy})_{i,j} \\approx \\frac{\\phi_{i+1,j+1} - \\phi_{i-1,j+1} - \\phi_{i+1,j-1} + \\phi_{i-1,j-1}}{4\\,dx\\,dy} $$\n\n**2. Fourth-Order Finite Difference Stencils**\n\nHigher-order stencils provide greater accuracy for smooth functions at the cost of a wider stencil, requiring more neighboring points. The fourth-order central difference stencils are:\n- First derivatives ($O(dx^4), O(dy^4)$):\n$$ (\\phi_x)_{i,j} \\approx \\frac{-\\phi_{i+2,j} + 8\\phi_{i+1,j} - 8\\phi_{i-1,j} + \\phi_{i-2,j}}{12\\,dx} $$\n$$ (\\phi_y)_{i,j} \\approx \\frac{-\\phi_{i,j+2} + 8\\phi_{i,j+1} - 8\\phi_{i,j-1} + \\phi_{i,j-2}}{12\\,dy} $$\n- Second derivatives ($O(dx^4), O(dy^4)$):\n$$ (\\phi_{xx})_{i,j} \\approx \\frac{-\\phi_{i+2,j} + 16\\phi_{i+1,j} - 30\\phi_{i,j} + 16\\phi_{i-1,j} - \\phi_{i-2,j}}{12\\,dx^2} $$\n$$ (\\phi_{yy})_{i,j} \\approx \\frac{-\\phi_{i,j+2} + 16\\phi_{i,j+1} - 30\\phi_{i,j} + 16\\phi_{i,j-1} - \\phi_{i,j-2}}{12\\,dy^2} $$\n- Mixed second derivative ($O(dx^4, dy^4)$), again computed by sequential application (e.g., $\\frac{\\partial}{\\partial y}(\\frac{\\partial \\phi}{\\partial x})$ using fourth-order stencils):\n$$ (\\phi_{xy})_{i,j} \\approx \\frac{1}{12\\,dy} \\left[ (\\phi_x)_{i,j+2}(-1) + (\\phi_x)_{i,j+1}(8) - (\\phi_x)_{i,j-1}(8) + (\\phi_x)_{i,j-2}(1) \\right] $$\nwhere each $(\\phi_x)$ term is evaluated using the fourth-order stencil for the $x$-derivative. This results in a $5 \\times 5$ stencil for $\\phi_{xy}$.\n\n**3. Numerical Evaluation Procedure**\nFor each test case grid and for each order of accuracy (2nd and 4th), the following steps are performed:\n1.  **Grid and Field Generation**: An $N_x \\times N_y$ grid is created over the domain $[0, L_x] \\times [0, L_y]$. The grid spacings are $dx = L_x / (N_x - 1)$ and $dy = L_y / (N_y - 1)$. The exact signed distance function $\\phi$ is evaluated at each grid node.\n2.  **Derivative Calculation**: The partial derivatives $\\phi_x, \\phi_y, \\phi_{xx}, \\phi_{yy}, \\phi_{xy}$ are computed over the entire grid using the appropriate-order stencils.\n3.  **Geometric Quantity Calculation**: The numerical normal vector $\\mathbf{n}$ and curvature $\\kappa$ are computed at each grid node using the provided formulas:\n    $$ \\mathbf{n} = \\frac{(\\phi_x, \\phi_y)}{\\sqrt{\\phi_x^2 + \\phi_y^2}}, \\qquad \\kappa = \\frac{\\phi_{xx}\\,\\phi_y^2 - 2\\,\\phi_x\\,\\phi_y\\,\\phi_{xy} + \\phi_{yy}\\,\\phi_x^2}{(\\phi_x^2+\\phi_y^2)^{3/2}} $$\n    A small epsilon is added to the denominators to prevent division by zero.\n4.  **Error Analysis Domain**: The errors are analyzed only for a subset of grid nodes. We define a mask that selects nodes satisfying two conditions:\n    a.  **Narrow Band**: Nodes must be close to the true interface, $|\\phi| \\le \\frac{1}{2}\\min(dx,dy)$.\n    b.  **Interior Nodes**: Nodes must have sufficient neighbors for the stencil to be valid. For a second-order stencil, this means excluding a $1$-cell boundary layer. For a fourth-order stencil, a $2$-cell boundary layer is excluded.\n5.  **Error Calculation**:\n    a.  **Normal Orientation Error**: The error is the angle (in radians) between the numerical normal $\\mathbf{n}$ and the exact normal $\\mathbf{n}_{\\mathrm{exact}}$. This is computed via $\\theta = \\arccos(\\mathbf{n} \\cdot \\mathbf{n}_{\\mathrm{exact}})$.\n    b.  **Curvature Error**: The error is the difference between the numerical curvature $\\kappa$ and the exact curvature $\\kappa_{\\mathrm{exact}} = 1/R$.\n6.  **Error Aggregation**: The root-mean-square (RMS) of each error type is computed over all nodes selected by the mask. For an error field $e$, the RMS error is $\\sqrt{\\langle e^2 \\rangle}$.\n\nThis systematic procedure allows for a direct comparison of the impact of stencil order and grid anisotropy on the accuracy of geometric quantities crucial for flame simulations.",
            "answer": "```python\nimport numpy as np\n\ndef compute_derivatives(phi, dx, dy, order):\n    \"\"\"\n    Computes partial derivatives of a 2D field using finite differences.\n    NOTE: Assumes 'ij' indexing for phi, where axis 0 is x and axis 1 is y.\n    \"\"\"\n    if order == 2:\n        # First derivatives (2nd-order central)\n        phi_x = (np.roll(phi, -1, axis=0) - np.roll(phi, 1, axis=0)) / (2 * dx)\n        phi_y = (np.roll(phi, -1, axis=1) - np.roll(phi, 1, axis=1)) / (2 * dy)\n        \n        # Second derivatives (2nd-order central)\n        phi_xx = (np.roll(phi, -1, axis=0) - 2 * phi + np.roll(phi, 1, axis=0)) / (dx**2)\n        phi_yy = (np.roll(phi, -1, axis=1) - 2 * phi + np.roll(phi, 1, axis=1)) / (dy**2)\n        \n        # Mixed derivative by sequential application\n        phi_xy = (np.roll(phi_x, -1, axis=1) - np.roll(phi_x, 1, axis=1)) / (2 * dy)\n\n    elif order == 4:\n        # First derivatives (4th-order central)\n        phi_x = (-np.roll(phi, -2, axis=0) + 8 * np.roll(phi, -1, axis=0) - 8 * np.roll(phi, 1, axis=0) + np.roll(phi, 2, axis=0)) / (12 * dx)\n        phi_y = (-np.roll(phi, -2, axis=1) + 8 * np.roll(phi, -1, axis=1) - 8 * np.roll(phi, 1, axis=1) + np.roll(phi, 2, axis=1)) / (12 * dy)\n        \n        # Second derivatives (4th-order central)\n        phi_xx = (-np.roll(phi, -2, axis=0) + 16 * np.roll(phi, -1, axis=0) - 30 * phi + 16 * np.roll(phi, 1, axis=0) - np.roll(phi, 2, axis=0)) / (12 * dx**2)\n        phi_yy = (-np.roll(phi, -2, axis=1) + 16 * np.roll(phi, -1, axis=1) - 30 * phi + 16 * np.roll(phi, 1, axis=1) - np.roll(phi, 2, axis=1)) / (12 * dy**2)\n\n        # Mixed derivative by sequential application\n        phi_xy = (-np.roll(phi_x, -2, axis=1) + 8 * np.roll(phi_x, -1, axis=1) - 8 * np.roll(phi_x, 1, axis=1) + np.roll(phi_x, 2, axis=1)) / (12 * dy)\n    else:\n        raise ValueError(\"Order must be 2 or 4\")\n        \n    return phi_x, phi_y, phi_xx, phi_yy, phi_xy\n\ndef compute_metrics_for_case(case_params, constants):\n    \"\"\"\n    Computes the four required error metrics for a single grid configuration.\n    \"\"\"\n    Nx, Ny = case_params\n    Lx, Ly, x0, y0, R = constants.values()\n\n    # Grid setup\n    dx = Lx / (Nx - 1)\n    dy = Ly / (Ny - 1)\n    x = np.linspace(0, Lx, Nx)\n    y = np.linspace(0, Ly, Ny)\n    # Use 'ij' indexing so that the first axis (0) corresponds to x\n    # and the second axis (1) corresponds to y.\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # Level-set field\n    phi = np.sqrt((X - x0)**2 + (Y - y0)**2) - R\n    \n    errors = {}\n\n    for order in [2, 4]:\n        # Compute derivatives\n        phi_x, phi_y, phi_xx, phi_yy, phi_xy = compute_derivatives(phi, dx, dy, order)\n        \n        # Define masks\n        # Interior mask to exclude boundaries where stencils are invalid\n        interior_mask = np.zeros_like(phi, dtype=bool)\n        stencil_width = order // 2 # 1 for 2nd order, 2 for 4th order\n        interior_mask[stencil_width:Nx-stencil_width, stencil_width:Ny-stencil_width] = True\n        \n        # Narrow band mask\n        band_width = 0.5 * min(dx, dy)\n        band_mask = np.abs(phi) = band_width\n        \n        # Final mask for analysis\n        mask = interior_mask  band_mask\n\n        # Numerical normal and curvature\n        grad_phi_norm_sq = phi_x**2 + phi_y**2\n        \n        epsilon = 1e-15\n        grad_phi_norm = np.sqrt(grad_phi_norm_sq + epsilon)\n        \n        nx = phi_x / grad_phi_norm\n        ny = phi_y / grad_phi_norm\n        \n        kappa_num = (phi_xx * phi_y**2 - 2 * phi_x * phi_y * phi_xy + phi_yy * phi_x**2)\n        kappa_den = (grad_phi_norm_sq)**(1.5)\n        kappa = kappa_num / (kappa_den + epsilon)\n\n        # Exact quantities\n        r = np.sqrt((X - x0)**2 + (Y - y0)**2)\n        r_safe = np.where(r == 0, epsilon, r)\n        nx_exact = (X - x0) / r_safe\n        ny_exact = (Y - y0) / r_safe\n        kappa_exact = 1.0 / R\n\n        # Compute errors\n        # Normal vector orientation error\n        dot_product = np.clip(nx * nx_exact + ny * ny_exact, -1.0, 1.0)\n        angle_error = np.arccos(dot_product)\n        \n        # Curvature error\n        curvature_error = kappa - kappa_exact\n        \n        # RMS errors over the masked region\n        rms_angle_error = np.sqrt(np.mean(angle_error[mask]**2))\n        rms_kappa_error = np.sqrt(np.mean(curvature_error[mask]**2))\n        \n        errors[f'angle_{order}'] = rms_angle_error\n        errors[f'kappa_{order}'] = rms_kappa_error\n        \n    return [errors['angle_2'], errors['angle_4'], errors['kappa_2'], errors['kappa_4']]\n\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases and print the results.\n    \"\"\"\n    # Define constants\n    constants = {\n        'Lx': 0.2, 'Ly': 0.2,\n        'x0': 0.1, 'y0': 0.1,\n        'R': 0.05\n    }\n    \n    # Define test cases from the problem statement\n    test_cases = [\n        (257, 257),   # Case 1: Isotropic baseline\n        (513, 257),   # Case 2: Anisotropic, refined in x\n        (257, 513),   # Case 3: Anisotropic, refined in y\n        (1025, 129),  # Case 4: Strong anisotropy, x much finer\n        (129, 1025)   # Case 5: Strong anisotropy, y much finer\n    ]\n    \n    results = []\n    for case in test_cases:\n        case_results = compute_metrics_for_case(case, constants)\n        results.extend(case_results)\n        \n    print(f\"[{','.join(f'{r:.12e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}