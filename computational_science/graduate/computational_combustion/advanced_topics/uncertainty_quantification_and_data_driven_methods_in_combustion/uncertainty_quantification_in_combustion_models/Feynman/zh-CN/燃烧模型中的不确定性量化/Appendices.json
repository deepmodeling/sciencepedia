{
    "hands_on_practices": [
        {
            "introduction": "在燃烧模型中，阿伦尼乌斯定律是描述化学反应速率的核心。这个实践练习将引导你分析该定律中两个关键参数——指前因子 $A$ 和活化能 $E$ ——的不确定性是如何传播并最终影响反应速率常数 $k$ 的 。通过解析推导，你将掌握不确定性传播的基础方法，并理解输入参数的不确定性如何转化为模型输出的不确定性分布。",
            "id": "4075374",
            "problem": "在一个单步不可逆气相反应中，随温度变化的速率系数由阿伦尼乌斯定律建模，$k(T)=A\\exp(-E/(R T))$，其中 $A$ 是指前因子，$E$ 是活化能，$R$ 是普适气体常数，$T$ 是绝对温度。在固定温度 $T>0$ 下，假设 $A$ 和 $E$ 的不确定性源于未解析的多尺度物理和测量变异性，并建模如下：$\\ln A$ 服从均值为 $\\mu_A$、方差为 $\\sigma_A^2$ 的正态分布，$E$ 服从均值为 $\\mu_E$、方差为 $\\sigma_E^2$ 的正态分布。假设 $A$ 和 $E$ 是统计独立的。您的任务是通过阿伦尼乌斯关系式转换这些不确定性，并推导在固定温度 $T$ 下，$k$ 中引起的的不确定性。\n\n从阿伦尼乌斯定律和概率变换的基本原理出发，推导在固定温度下 $k$ 的概率密度函数。用 $\\mu_A$、$\\sigma_A$、$\\mu_E$、$\\sigma_E$、$R$ 和 $T$ 以闭式解的形式表示您的最终结果。不需要进行数值评估。请以单一解析表达式的形式给出 $k$ 的最终概率密度函数。最终答案中不要包含单位。不需要进行四舍五入。",
            "solution": "首先根据指定标准对问题进行验证。\n\n**步骤1：提取已知条件**\n- 阿伦尼乌斯定律：$k(T)=A\\exp(-E/(R T))$\n- 温度 $T$ 是一个固定的正常数，$T>0$。\n- 普适气体常数是 $R$。\n- 指前因子的对数 $\\ln A$ 是一个随机变量，服从均值为 $\\mu_A$、方差为 $\\sigma_A^2$ 的正态分布。这可以写作 $\\ln A \\sim \\mathcal{N}(\\mu_A, \\sigma_A^2)$。\n- 活化能 $E$ 是一个随机变量，服从均值为 $\\mu_E$、方差为 $\\sigma_E^2$ 的正态分布。这可以写作 $E \\sim \\mathcal{N}(\\mu_E, \\sigma_E^2)$。\n- 随机变量 $A$ 和 $E$ 是统计独立的。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据：** 该问题使用了阿伦尼乌斯方程，这是化学动力学的基本原理。使用概率分布（特别是对 $A$ 使用对数正态分布，对 $E$ 使用正态分布）对参数不确定性进行建模，是在燃烧和化学系统不确定性量化中的一种标准且物理上合理的做法。该问题是科学合理的。\n- **适定性：** 该问题提供了清晰的函数关系和输入随机变量的完整概率描述。要求推导输出的概率密度函数（PDF）是概率论（随机变量的变换）中的一个标准问题，并且有唯一的解。\n- **客观性：** 问题以精确的数学语言陈述，没有任何主观性或歧义。\n- **一致性和完整性：** 提供了所有必要的信息。统计独立性的假设至关重要且已明确说明。没有矛盾之处。条件 $T>0$ 确保了表达式的良定义性。\n- **可行性：** 该情景是计算模型中不确定性分析的现实表示。\n\n**结论：** 问题有效。\n\n**步骤3：求解推导**\n目标是推导速率系数 $k$ 的概率密度函数（PDF），记为 $f_k(k)$。速率系数由阿伦尼乌斯定律给出：\n$$k = A \\exp\\left(-\\frac{E}{RT}\\right)$$\n为简化乘积和指数形式，我们对 $k$ 取自然对数：\n$$\\ln k = \\ln\\left(A \\exp\\left(-\\frac{E}{RT}\\right)\\right)$$\n利用对数的性质，我们得到：\n$$\\ln k = \\ln A - \\frac{E}{RT}$$\n我们定义一个新的随机变量 $Y = \\ln k$。我们可以将 $Y$ 表示为两个随机变量的差，$Y = X_1 - X_2$，其中：\n$$X_1 = \\ln A$$\n$$X_2 = \\frac{E}{RT}$$\n我们已知 $X_1$ 的分布。因为 $\\ln A$ 服从均值为 $\\mu_A$、方差为 $\\sigma_A^2$ 的正态分布，所以我们有：\n$$X_1 \\sim \\mathcal{N}(\\mu_A, \\sigma_A^2)$$\n接下来，我们确定 $X_2$ 的分布。$X_2$ 是随机变量 $E$ 的线性变换，缩放因子为 $1/(RT)$。由于 $E$ 服从正态分布，$E \\sim \\mathcal{N}(\\mu_E, \\sigma_E^2)$，随机变量 $X_2$ 也服从正态分布。其均值和方差为：\n$$\\mathbb{E}[X_2] = \\mathbb{E}\\left[\\frac{E}{RT}\\right] = \\frac{1}{RT}\\mathbb{E}[E] = \\frac{\\mu_E}{RT}$$\n$$\\mathrm{Var}(X_2) = \\mathrm{Var}\\left(\\frac{E}{RT}\\right) = \\left(\\frac{1}{RT}\\right)^2 \\mathrm{Var}(E) = \\frac{\\sigma_E^2}{R^2 T^2}$$\n因此，$X_2$ 的分布为：\n$$X_2 \\sim \\mathcal{N}\\left(\\frac{\\mu_E}{RT}, \\frac{\\sigma_E^2}{R^2 T^2}\\right)$$\n问题陈述 $A$ 和 $E$ 是统计独立的。这意味着这两个变量的任何函数，例如 $X_1 = \\ln A$ 和 $X_2 = E/(RT)$，也都是统计独立的。\n随机变量 $Y = \\ln k$ 是两个独立正态随机变量 $X_1$ 和 $X_2$ 的差。独立正态随机变量的和或差本身也是一个正态随机变量。$Y$ 的均值，记为 $\\mu_Y$，是 $X_1$ 和 $X_2$ 均值的差：\n$$\\mu_Y = \\mathbb{E}[Y] = \\mathbb{E}[X_1 - X_2] = \\mathbb{E}[X_1] - \\mathbb{E}[X_2] = \\mu_A - \\frac{\\mu_E}{RT}$$\n$Y$ 的方差，记为 $\\sigma_Y^2$，是 $X_1$ 和 $X_2$ 方差的和（因为它们是独立的）：\n$$\\sigma_Y^2 = \\mathrm{Var}(Y) = \\mathrm{Var}(X_1 - X_2) = \\mathrm{Var}(X_1) + \\mathrm{Var}(X_2) = \\sigma_A^2 + \\frac{\\sigma_E^2}{R^2 T^2}$$\n所以，随机变量 $Y = \\ln k$ 服从正态分布：\n$$Y = \\ln k \\sim \\mathcal{N}\\left(\\mu_A - \\frac{\\mu_E}{RT}, \\sigma_A^2 + \\frac{\\sigma_E^2}{R^2 T^2}\\right)$$\n一个随机变量 $k$，如果其自然对数服从正态分布，则称该变量服从对数正态分布。对于 $\\ln k \\sim \\mathcal{N}(\\mu_Y, \\sigma_Y^2)$，对数正态随机变量 $k$ 的概率密度函数（PDF）由以下通用公式给出：\n$$f_k(k) = \\frac{1}{k \\sigma_Y \\sqrt{2\\pi}} \\exp\\left(-\\frac{(\\ln k - \\mu_Y)^2}{2\\sigma_Y^2}\\right), \\quad \\text{for } k>0$$\n将我们推导出的 $\\mu_Y$ 和 $\\sigma_Y^2$ 的表达式代入此公式，得到 $k$ 的概率密度函数：\n$$f_k(k) = \\frac{1}{k \\sqrt{2\\pi \\left(\\sigma_A^2 + \\frac{\\sigma_E^2}{R^2 T^2}\\right)}} \\exp\\left(-\\frac{\\left(\\ln k - \\left(\\mu_A - \\frac{\\mu_E}{RT}\\right)\\right)^2}{2\\left(\\sigma_A^2 + \\frac{\\sigma_E^2}{R^2 T^2}\\right)}\\right)$$\n这可以更清晰地写为：\n$$f_k(k) = \\frac{1}{k \\sqrt{2\\pi\\left(\\sigma_A^2 + \\frac{\\sigma_E^2}{R^2T^2}\\right)}} \\exp\\left( - \\frac{\\left( \\ln k - \\mu_A + \\frac{\\mu_E}{RT} \\right)^2}{2\\left(\\sigma_A^2 + \\frac{\\sigma_E^2}{R^2T^2}\\right)} \\right)$$\n这就是速率系数 $k$ 的概率密度函数的最终闭式表达式。",
            "answer": "$$\n\\boxed{\n\\frac{1}{k \\sqrt{2\\pi\\left(\\sigma_A^2 + \\frac{\\sigma_E^2}{R^2T^2}\\right)}} \\exp\\left( - \\frac{\\left( \\ln k - \\mu_A + \\frac{\\mu_E}{RT} \\right)^2}{2\\left(\\sigma_A^2 + \\frac{\\sigma_E^2}{R^2T^2}\\right)} \\right)\n}\n$$"
        },
        {
            "introduction": "准确确定阿伦尼乌斯参数对于建立可靠的燃烧模型至关重要，但这往往面临着“非唯一性”的挑战。本练习通过一个参数辨识问题，让你亲手实践如何诊断这一难题，即在有限的实验数据下，$\\ln A$ 和 $E$ 往往高度相关，难以被独立确定 。你将学习如何通过分析参数的置信椭圆来量化这种不确定性，并理解实验设计（如温度范围的选择）对参数精度的决定性影响。",
            "id": "4075321",
            "problem": "考虑一个均相混合物中的单步基元反应，其由阿伦尼乌斯速率表达式建模。设速率常数为 $k(T) = A \\exp\\!\\left(-\\frac{E}{R T}\\right)$，其中 $A$ 是指前因子，$E$ 是活化能，$R$ 是通用气体常数，单位为 $\\mathrm{J/(mol\\cdot K)}$，$T$ 是绝对温度，单位为 $\\mathrm{K}$。为了生成适用于统计推断的无量纲参数，定义变换后的参数向量 $\\boldsymbol{\\theta} = (\\theta_1, \\theta_2)$，其中 $\\theta_1 = \\ln A$ 和 $\\theta_2 = \\dfrac{E}{R T_0}$，$T_0$ 是一个固定的参考温度，单位为 $\\mathrm{K}$。在此参数重整下，速率常数的对数为\n$$\n\\ln k(T) = \\theta_1 - \\theta_2 \\frac{T_0}{T}.\n$$\n假设在对数空间中的测量模型是加性高斯噪声：对于每个温度 $T_i$，观测值 $y_i$ 满足\n$$\ny_i = \\ln k(T_i) + \\varepsilon_i,\\quad \\varepsilon_i \\sim \\mathcal{N}(0, \\sigma_y^2),\n$$\n其中 $\\sigma_y$ 是已知的且与 $i$ 无关。对 $\\boldsymbol{\\theta}$ 采用均匀先验，因此后验概率与似然函数成正比。目标是量化参数对 $(\\theta_1,\\theta_2)$ 的不确定性，并展示当温度集跨度很窄时出现的不可辨识性问题。\n\n从阿伦尼乌斯定律和高斯噪声假设出发，在变换后的参数空间中推导线性回归表示，并计算 $\\boldsymbol{\\theta}$ 的最大似然估计 (MLE)。使用 MLE 周围的拉普拉斯近似来逼近后验概率，将联合后验表征为二元正态分布，其协方差矩阵由线性模型的设计矩阵导出。根据此协方差，构建 $(\\theta_1,\\theta_2)$ 的 $95\\%$ 联合置信（可信）椭圆，并提取以下可量化的特征：\n- $95\\%$ 椭圆的半长轴长度 $a$ 和半短轴长度 $b$（均为无量纲），\n- 长轴相对于 $\\theta_1$ 轴的取向角 $\\alpha$，单位为弧度（角度单位必须是弧度），\n- $\\theta_1$ 和 $\\theta_2$ 之间的后验相关系数 $\\rho$（无量纲），\n- 轴比 $\\kappa = a/b$（无量纲），\n- 法向矩阵的条件数 $\\mathrm{cond}((X^\\top X))$（无量纲），它可作为可辨识性的一个诊断指标。\n\n使用 $R = 8.314\\,\\mathrm{J/(mol\\cdot K)}$ 和 $T_0 = 1000\\,\\mathrm{K}$。通过对给定的真值 $(\\theta_1^\\star, \\theta_2^\\star)$ 计算 $\\ln k(T_i)$ 来生成无噪声的合成观测值，从而使得最大似然估计等于真值。不确定性特征取决于设计矩阵和 $\\sigma_y$，而不取决于噪声的具体实现。使用与 $A^\\star = 10^{12}\\,\\mathrm{s}^{-1}$ 和 $E^\\star = 1.5\\times 10^5\\,\\mathrm{J/mol}$ 对应的真值。这意味着 $\\theta_1^\\star = \\ln A^\\star$ 和 $\\theta_2^\\star = \\dfrac{E^\\star}{R T_0}$。\n\n您的程序必须为以下每个测试用例计算上述五个量，这些测试用例探索了不同的温度范围和噪声水平以评估可辨识性：\n\n- 测试用例 1（宽温度跨度，中等噪声）：温度 $T_i = [800, 900, 1000, 1200, 1400, 1600, 1800, 2000]$（单位 $\\mathrm{K}$），$\\sigma_y = 0.1$（无量纲）。\n- 测试用例 2（窄温度跨度，中等噪声）：温度 $T_i = [1100, 1120, 1140, 1160, 1180, 1200]$（单位 $\\mathrm{K}$），$\\sigma_y = 0.1$（无量纲）。\n- 测试用例 3（宽温度跨度，较高噪声）：温度 $T_i = [800, 900, 1000, 1200, 1400, 1600, 1800, 2000]$（单位 $\\mathrm{K}$），$\\sigma_y = 0.25$（无量纲）。\n- 测试用例 4（近简并温度跨度，中等噪声）：温度 $T_i = [995, 998, 1000, 1002, 1005]$（单位 $\\mathrm{K}$），$\\sigma_y = 0.1$（无量纲）。\n\n对于所有计算，角度均以弧度处理。所有报告值都必须是无量纲的，因为它们是在 $(\\theta_1,\\theta_2)$ 空间中导出的。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果本身必须是按 $[a, b, \\alpha, \\rho, \\kappa, \\mathrm{cond}]$ 顺序排列的列表，每个浮点数四舍五入到六位小数，并且总输出必须是这些按测试用例排列的列表的列表；例如，\"[[a1,b1,alpha1,rho1,kappa1,cond1],[a2,b2,alpha2,rho2,kappa2,cond2],...]\"。",
            "solution": "用户提供了一个关于化学动力学中阿伦尼乌斯速率表达式参数不确定性量化的问题陈述。第一步是验证该问题。\n\n### 步骤 1：提取已知条件\n- **速率常数表达式：** $k(T) = A \\exp\\!\\left(-\\frac{E}{R T}\\right)$\n- **常数：** 通用气体常数 $R = 8.314\\,\\mathrm{J/(mol\\cdot K)}$，参考温度 $T_0 = 1000\\,\\mathrm{K}$。\n- **变换后的参数：** $\\boldsymbol{\\theta} = (\\theta_1, \\theta_2)$ 其中 $\\theta_1 = \\ln A$ 和 $\\theta_2 = \\frac{E}{R T_0}$。\n- **对数线性模型：** $\\ln k(T) = \\theta_1 - \\theta_2 \\frac{T_0}{T}$。\n- **测量模型：** $y_i = \\ln k(T_i) + \\varepsilon_i$，噪声为 $\\varepsilon_i \\sim \\mathcal{N}(0, \\sigma_y^2)$。噪声方差 $\\sigma_y^2$ 已知。\n- **先验分布：** 对 $\\boldsymbol{\\theta}$ 采用均匀先验，$p(\\boldsymbol{\\theta}) \\propto \\text{constant}$。这意味着后验分布与似然函数成正比。\n- **近似方法：** 后验概率将通过以最大似然估计 (MLE) 为中心的拉普拉斯近似，用一个二元正态分布来近似。\n- **数据生成：** 合成数据在没有噪声的情况下生成，即使用真值参数 $y_i = \\ln k(T_i)$。这确保了最大似然估计 $\\hat{\\boldsymbol{\\theta}}$ 与真值 $\\boldsymbol{\\theta}^\\star$ 相同。\n- **真值参数：** $A^\\star = 10^{12}\\,\\mathrm{s}^{-1}$，$E^\\star = 1.5\\times 10^5\\,\\mathrm{J/mol}$。\n- **待计算量：**\n    1. $a$：$95\\%$ 置信椭圆的半长轴长度。\n    2. $b$：$95\\%$ 置信椭圆的半短轴长度。\n    3. $\\alpha$：长轴相对于 $\\theta_1$ 轴的取向角（单位为弧度）。\n    4. $\\rho$：$\\theta_1$ 和 $\\theta_2$ 之间的后验相关系数。\n    5. $\\kappa = a/b$：椭圆的轴比。\n    6. $\\mathrm{cond}((X^\\top X))$：法向矩阵的条件数。\n- **测试用例：**\n    1. $T_i = [800, 900, 1000, 1200, 1400, 1600, 1800, 2000]\\,\\mathrm{K}$，$\\sigma_y = 0.1$。\n    2. $T_i = [1100, 1120, 1140, 1160, 1180, 1200]\\,\\mathrm{K}$，$\\sigma_y = 0.1$。\n    3. $T_i = [800, 900, 1000, 1200, 1400, 1600, 1800, 2000]\\,\\mathrm{K}$，$\\sigma_y = 0.25$。\n    4. $T_i = [995, 998, 1000, 1002, 1005]\\,\\mathrm{K}$，$\\sigma_y = 0.1$。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据：** 该问题基于阿伦尼乌斯方程（化学动力学的基石），并采用标准统计方法（线性回归、最大似然估计、使用拉普拉斯近似的贝叶斯推断）进行不确定性量化。整个设置在科学和数学上都是合理的。\n- **适定性：** 该问题是适定的。它提供了所有必要的信息（模型、参数、数据点、噪声水平）来唯一确定所要求的统计量。目标定义明确。\n- **客观性：** 问题以精确、客观的语言陈述。所有量都有数学定义，任务是计算它们，没有主观解释的余地。\n- **未检测到缺陷：** 该问题不违反任何无效性标准。它在科学上是合理的，自洽的，并且可以形式化。所提供的数据是一致的，所需的计算虽然复杂，但是是可行的，并且对于评估计算燃烧模型中的参数可辨识性具有重要意义。该问题是灵敏度分析和不确定性量化中的一个标准练习。\n\n### 步骤 3：结论与行动\n问题是**有效的**。将提供解决方案。\n\n### 解答推导\n\n分析过程通过将问题表述为线性回归来进行，所有期望的量都可以由此推导得出。\n\n**1. 线性模型构建**\n测量模型由下式给出：\n$$\ny_i = \\theta_1 - \\theta_2 \\frac{T_0}{T_i} + \\varepsilon_i\n$$\n这可以写成标准线性模型形式 $\\mathbf{y} = X\\boldsymbol{\\theta} + \\boldsymbol{\\varepsilon}$。对于一组 $N$ 个温度测量值 $\\{T_i\\}_{i=1}^N$，模型为：\n$$\n\\begin{pmatrix} y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_N \\end{pmatrix} = \\begin{pmatrix} 1 & -T_0/T_1 \\\\ 1 & -T_0/T_2 \\\\ \\vdots & \\vdots \\\\ 1 & -T_0/T_N \\end{pmatrix} \\begin{pmatrix} \\theta_1 \\\\ \\theta_2 \\end{pmatrix} + \\begin{pmatrix} \\varepsilon_1 \\\\ \\varepsilon_2 \\\\ \\vdots \\\\ \\varepsilon_N \\end{pmatrix}\n$$\n这里，$\\mathbf{y}$ 是观测向量，$X$ 是 $N \\times 2$ 的设计矩阵，$\\boldsymbol{\\theta}$ 是参数向量，$\\boldsymbol{\\varepsilon}$ 是独立同分布 (i.i.d.) 的高斯噪声项向量，满足 $\\boldsymbol{\\varepsilon} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma_y^2 I)$，其中 $I$ 是 $N \\times N$ 的单位矩阵。\n\n**2. 通过拉普拉斯近似获得后验分布**\n给定均匀先验 $p(\\boldsymbol{\\theta}) \\propto 1$，后验分布与似然函数成正比：\n$$\np(\\boldsymbol{\\theta} | \\mathbf{y}) \\propto L(\\boldsymbol{\\theta}; \\mathbf{y}) \\propto \\exp\\left( -\\frac{1}{2\\sigma_y^2} (\\mathbf{y} - X\\boldsymbol{\\theta})^\\top (\\mathbf{y} - X\\boldsymbol{\\theta}) \\right)\n$$\n拉普拉斯近似指出，后验分布可以用一个以其众数 $\\hat{\\boldsymbol{\\theta}}$ 为中心，协方差矩阵等于负对数后验概率在众数处的海森矩阵的逆矩阵的多元正态分布来近似。对于这个线性高斯问题，该近似是精确的。众数 $\\hat{\\boldsymbol{\\theta}}$ 是最大似然估计 (MLE)，由标准最小二乘解给出：\n$$\n\\hat{\\boldsymbol{\\theta}} = (X^\\top X)^{-1} X^\\top \\mathbf{y}\n$$\n负对数似然函数的海森矩阵是 $H = \\frac{1}{\\sigma_y^2} X^\\top X$。\n因此，$\\boldsymbol{\\theta}$ 的后验分布的协方差矩阵是：\n$$\n\\Sigma_{\\boldsymbol{\\theta}} = H^{-1} = \\left(\\frac{1}{\\sigma_y^2} X^\\top X\\right)^{-1} = \\sigma_y^2 (X^\\top X)^{-1}\n$$\n因此，后验分布被近似为 $\\boldsymbol{\\theta} | \\mathbf{y} \\sim \\mathcal{N}(\\hat{\\boldsymbol{\\theta}}, \\Sigma_{\\boldsymbol{\\theta}})$。\n\n**3. 置信椭圆的特征**\n$\\boldsymbol{\\theta}$ 的 $95\\%$ 置信（或可信）区域是一个由方程定义的椭圆：\n$$\n(\\boldsymbol{\\theta} - \\hat{\\boldsymbol{\\theta}})^\\top \\Sigma_{\\boldsymbol{\\theta}}^{-1} (\\boldsymbol{\\theta} - \\hat{\\boldsymbol{\\theta}}) \\le s^2\n$$\n其中 $s^2$ 是自由度为 $k=2$ 的卡方分布的第 $95$ 百分位数，即 $s^2 = \\chi^2_{2; 0.95} \\approx 5.9915$。\n\n- **半轴 ($a, b$) 和轴比 ($\\kappa$)：** 设 $\\lambda_1, \\lambda_2$ 是协方差矩阵 $\\Sigma_{\\boldsymbol{\\theta}}$ 的特征值，且 $\\lambda_{\\text{max}} \\ge \\lambda_{\\text{min}}$。椭圆的半长轴和半短轴由下式给出：\n$$\na = \\sqrt{s^2 \\lambda_{\\text{max}}}, \\quad b = \\sqrt{s^2 \\lambda_{\\text{min}}}\n$$\n轴比为 $\\kappa = a/b = \\sqrt{\\lambda_{\\text{max}} / \\lambda_{\\text{min}}}$。\n\n- **取向角 ($\\alpha$)：** 椭圆的取向由 $\\Sigma_{\\boldsymbol{\\theta}}$ 的特征向量决定。长轴与最大特征值 $\\lambda_{\\text{max}}$ 对应的特征向量对齐。如果该特征向量为 $\\mathbf{v}_{\\text{max}} = [v_x, v_y]^\\top$，则相对于 $\\theta_1$ 轴的角度 $\\alpha$ 为：\n$$\n\\alpha = \\mathrm{atan2}(v_y, v_x)\n$$\n\n**4. 派生的统计量**\n- **后验相关性 ($\\rho$)：** $\\theta_1$ 和 $\\theta_2$ 之间的相关系数由协方差矩阵 $\\Sigma_{\\boldsymbol{\\theta}} = \\begin{pmatrix} \\Sigma_{11} & \\Sigma_{12} \\\\ \\Sigma_{21} & \\Sigma_{22} \\end{pmatrix}$ 的分量导出：\n$$\n\\rho = \\frac{\\Sigma_{12}}{\\sqrt{\\Sigma_{11} \\Sigma_{22}}}\n$$\n\n- **条件数 ($\\mathrm{cond}(X^\\top X)$):** 法向矩阵 $M = X^\\top X$ 的条件数是衡量其对求逆敏感性的指标，反映了 $X$ 列向量的共线性。对于对称正定矩阵，2-范数条件数是其最大特征值与最小特征值之比：\n$$\n\\mathrm{cond}_2(X^\\top X) = \\frac{\\lambda_{\\text{max}}(X^\\top X)}{\\lambda_{\\text{min}}(X^\\top X)}\n$$\n轴比 $\\kappa$ 和条件数之间存在直接关系：\n$$\n\\kappa^2 = \\frac{\\lambda_{\\text{max}}(\\Sigma_{\\boldsymbol{\\theta}})}{\\lambda_{\\text{min}}(\\Sigma_{\\boldsymbol{\\theta}})} = \\frac{\\sigma_y^2 \\lambda_{\\text{max}}((X^\\top X)^{-1})}{\\sigma_y^2 \\lambda_{\\text{min}}((X^\\top X)^{-1})} = \\frac{1/\\lambda_{\\text{min}}(X^\\top X)}{1/\\lambda_{\\text{max}}(X^\\top X)} = \\frac{\\lambda_{\\text{max}}(X^\\top X)}{\\lambda_{\\text{min}}(X^\\top X)} = \\mathrm{cond}_2(X^\\top X)\n$$\n因此，$\\kappa = \\sqrt{\\mathrm{cond}_2(X^\\top X)}$。这提供了一个有价值的一致性检验。\n\n**5. 算法**\n对于每个具有给定温度集 $\\{T_i\\}$ 和噪声标准差 $\\sigma_y$ 的测试用例：\n1. 构建 $N \\times 2$ 的设计矩阵 $X$，其中第 $i$ 行为 $[1, -T_0/T_i]$。\n2. 计算法向矩阵 $M = X^\\top X$。\n3. 使用标准数值库函数计算 $M$ 的条件数 $\\mathrm{cond}(M)$。\n4. 计算后验协方差矩阵 $\\Sigma_{\\boldsymbol{\\theta}} = \\sigma_y^2 M^{-1}$。\n5. 计算 $\\Sigma_{\\boldsymbol{\\theta}}$ 的特征值 $\\lambda_{\\text{min}}, \\lambda_{\\text{max}}$ 和对应的特征向量。Numpy 的 `linalg.eigh` 函数适用于对称矩阵，并返回排序后的特征值。\n6. 从 $\\chi^2_2$ 分布中检索 $95\\%$ 置信水平的临界值 $s^2$。\n7. 计算半轴：$a = \\sqrt{s^2 \\lambda_{\\text{max}}}$ 和 $b = \\sqrt{s^2 \\lambda_{\\text{min}}}$。\n8. 计算轴比 $\\kappa = a/b$。\n9. 使用 `atan2` 对与 $\\lambda_{\\text{max}}$ 相关的特征向量的分量计算取向角 $\\alpha$。\n10. 从 $\\Sigma_{\\boldsymbol{\\theta}}$ 的元素计算相关系数 $\\rho$。\n11. 收集结果 $[a, b, \\alpha, \\rho, \\kappa, \\mathrm{cond}(M)]$ 并按要求格式化。对所有指定的测试用例重复此过程。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Computes uncertainty quantification metrics for the Arrhenius parameters\n    based on a linear regression model.\n    \"\"\"\n    \n    # Define constants\n    R = 8.314  # J/(mol*K)\n    T0 = 1000.0  # K\n\n    # Test cases: (list of temperatures in K, noise std dev sigma_y)\n    test_cases_data = [\n        (np.array([800, 900, 1000, 1200, 1400, 1600, 1800, 2000]), 0.1),\n        (np.array([1100, 1120, 1140, 1160, 1180, 1200]), 0.1),\n        (np.array([800, 900, 1000, 1200, 1400, 1600, 1800, 2000]), 0.25),\n        (np.array([995, 998, 1000, 1002, 1005]), 0.1),\n    ]\n\n    # Level for 95% confidence interval for a 2D problem\n    s_squared = chi2.ppf(0.95, df=2)\n\n    all_results = []\n\n    for temperatures, sigma_y in test_cases_data:\n        # 1. Construct the design matrix X\n        N = len(temperatures)\n        x_col = -T0 / temperatures\n        # Design matrix X has columns [1, x_col]\n        X = np.vstack((np.ones(N), x_col)).T\n\n        # 2. Compute the normal matrix M = X^T * X\n        M = X.T @ X\n\n        # 3. Calculate the condition number of M\n        cond_M = np.linalg.cond(M)\n\n        # 4. Calculate the posterior covariance matrix Sigma_theta\n        try:\n            M_inv = np.linalg.inv(M)\n        except np.linalg.LinAlgError:\n            # Handle singular matrix case, though not expected for these test cases\n            all_results.append([np.inf] * 6)\n            continue\n            \n        Sigma_theta = sigma_y**2 * M_inv\n\n        # 5. Compute eigenvalues and eigenvectors of Sigma_theta\n        # np.linalg.eigh is for symmetric matrices and returns sorted eigenvalues\n        eigenvalues, eigenvectors = np.linalg.eigh(Sigma_theta)\n        lambda_min, lambda_max = eigenvalues[0], eigenvalues[1]\n        \n        # Eigenvector for lambda_max is the second column\n        v_max = eigenvectors[:, 1]\n\n        # 6. Critical value s_squared is already computed\n        \n        # 7. Calculate semi-axes\n        a = np.sqrt(s_squared * lambda_max)\n        b = np.sqrt(s_squared * lambda_min)\n\n        # 8. Calculate axis ratio\n        kappa = a / b\n\n        # 9. Determine orientation angle alpha\n        # angle of the major axis eigenvector with respect to the theta1 axis\n        alpha = np.arctan2(v_max[1], v_max[0])\n\n        # 10. Calculate correlation coefficient rho\n        Sigma_11 = Sigma_theta[0, 0]\n        Sigma_22 = Sigma_theta[1, 1]\n        Sigma_12 = Sigma_theta[0, 1]\n        rho = Sigma_12 / np.sqrt(Sigma_11 * Sigma_22)\n        \n        # 11. Collect results\n        case_results = [a, b, alpha, rho, kappa, cond_M]\n        all_results.append(case_results)\n\n    # Format output\n    output_str = \"[\"\n    for i, res in enumerate(all_results):\n        formatted_res = [f\"{val:.6f}\" for val in res]\n        output_str += f\"[{','.join(formatted_res)}]\"\n        if i  len(all_results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    \n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "不确定性量化不仅是分析误差，更是为了做出更可靠的工程决策。本练习将 UQ 应用于一个实际的工程安全问题：评估点火延迟时间超过安全阈值的风险，并指导实验设计 。你将使用强大的蒙特卡洛方法来处理复杂的多参数模型，并学习如何运用贝叶斯更新来评估不同测量方案的价值，从而选择最能有效降低风险的实验。",
            "id": "4075234",
            "problem": "考虑一个化学反应混合物，其点火延迟时间使用计算燃烧学中常用的单步 Arrhenius 型替代模型进行建模。设点火延迟时间由以下参数模型给出\n$$\n\\tau_{\\mathrm{ign}} = C \\exp\\left(\\frac{E}{R T_0}\\right)\\left(\\phi\\right)^{\\gamma}\\left(\\frac{p_{\\mathrm{ref}}}{p_0}\\right)^{\\beta},\n$$\n其中，$C$ 是一个常数参数，单位为毫秒 (ms)，$E$ 是有效活化能，单位为焦耳/摩尔，$R$ 是通用气体常数，单位为焦耳/摩尔·开尔文，$T_0$ 是初始温度，单位为开尔文，$\\phi$ 是当量比（无量纲），$p_0$ 是初始压力，单位为大气压，$p_{\\mathrm{ref}}$ 是参考压力，单位为大气压，$\\gamma$ 和 $\\beta$ 是无量纲的灵敏度指数，而 $\\tau_{\\mathrm{ign}}$ 是点火延迟时间，单位为毫秒 (ms)。该替代模型通过 Arrhenius 定律反映了对温度的指数级敏感性，以及对当量比和压力的单调依赖性。\n\n通过将参数 $C$、$E$、$T_0$、$\\phi$ 和 $p_0$ 视为随机变量来执行不确定性量化 (UQ)。具体来说，假设 $C$ 和 $p_0$ 通过其自然对数被建模为对数正态随机变量，而 $E$、$T_0$ 和 $\\phi$ 被建模为正态随机变量。目标是在给定的不确定性下，计算 $\\tau_{\\mathrm{ign}}$ 超过指定安全阈值 $\\tau_s$（单位为毫秒 ms）的概率。此外，设计一个实验，通过在加性高斯测量噪声下，从集合 $\\{T_0, E, \\phi\\}$ 中选择一个量进行测量，以降低该超出概率。使用正态-正态共轭模型下的贝叶斯更新来减少被测量量的方差：如果正态分布量 $X$ 的先验方差为 $\\sigma_X^2$，测量噪声方差为 $\\sigma_{X,\\mathrm{meas}}^2$，则后验方差为\n$$\n\\sigma_{X,\\mathrm{post}}^2 = \\left(\\frac{1}{\\sigma_X^2} + \\frac{1}{\\sigma_{X,\\mathrm{meas}}^2}\\right)^{-1}.\n$$\n假设在对所有可能的测量结果进行平均时，期望后验均值等于先验均值。通过将被选量的先验方差替换为 $\\sigma_{X,\\mathrm{post}}^2$ 并从其余量的先验分布中抽样，来近似执行测量后的期望超出概率。\n\n从理想气体定律和 Arrhenius 定律出发，上述替代模型的形式与 $\\tau_{\\mathrm{ign}}$ 同反应速率成反比（反应速率与 $\\exp\\left(-E/(R T)\\right)$ 成正比）以及与混合物参数成单调关系是一致的。使用蒙特卡洛估计器计算先验模型和每种实验设计方案的超出概率。输出必须是包含所有测试用例聚合结果的单行，其中每个测试用例的结果是列表 $[\\text{prob\\_prior}, \\text{prob\\_post\\_T}, \\text{prob\\_post\\_E}, \\text{prob\\_post\\_phi}, i]$，其中 $\\text{prob\\_prior}$ 是以小数表示的先验超出概率，$\\text{prob\\_post\\_T}$、$\\text{prob\\_post\\_E}$ 和 $\\text{prob\\_post\\_phi}$ 是在各自测量选项下的期望超出概率，而 $i \\in \\{1,2,3\\}$ 是最小化期望超出概率的选项索引（若出现平局，则选择最小的索引）。您的程序应生成一行输出，其中包含一个逗号分隔的列表，用方括号括起来，且不含空格。\n\n所有点火延迟阈值均以毫秒 (ms) 表示。概率以小数形式表示，不带百分号。本问题不涉及角度。\n\n使用以下通用常数：\n- $R = 8.314$。\n\n使用以下参数集测试套件。对于每个测试用例，必须使用指定的样本数量 $N$ 从先验分布中进行抽样。当对正态分布的 $\\phi$ 进行抽样时，将抽样值裁剪到物理上合理的区间 $[0.6, 1.4]$ 以确保真实性。对于对数正态变量 $C$ 和 $p_0$，通过其自然对数进行抽样。\n\n测试用例 1 (正常情况):\n- $\\mu_{\\ln C} = \\ln(10^{-6})$，$\\sigma_{\\ln C} = 0.4$。\n- $\\mu_{E} = 140000$，$\\sigma_{E} = 8000$。\n- $\\mu_{T_0} = 1200$，$\\sigma_{T_0} = 60$。\n- $\\mu_{\\phi} = 1.0$，$\\sigma_{\\phi} = 0.05$。\n- $\\mu_{\\ln p_0} = \\ln(10)$，$\\sigma_{\\ln p_0} = 0.2$。\n- $\\beta = 1.0$，$\\gamma = 0.3$，$p_{\\mathrm{ref}} = 1.0$。\n- $\\tau_s = 0.2$ (ms)。\n- $N = 50000$。\n- 测量噪声: $\\sigma_{T_0,\\mathrm{meas}} = 10$，$\\sigma_{E,\\mathrm{meas}} = 5000$，$\\sigma_{\\phi,\\mathrm{meas}} = 0.02$。\n\n测试用例 2 (边界低阈值):\n- $\\mu_{\\ln C} = \\ln(10^{-6})$，$\\sigma_{\\ln C} = 0.4$。\n- $\\mu_{E} = 140000$，$\\sigma_{E} = 8000$。\n- $\\mu_{T_0} = 1200$，$\\sigma_{T_0} = 60$。\n- $\\mu_{\\phi} = 1.0$，$\\sigma_{\\phi} = 0.05$。\n- $\\mu_{\\ln p_0} = \\ln(10)$，$\\sigma_{\\ln p_0} = 0.2$。\n- $\\beta = 1.0$，$\\gamma = 0.3$，$p_{\\mathrm{ref}} = 1.0$。\n- $\\tau_s = 0.01$ (ms)。\n- $N = 50000$。\n- 测量噪声: $\\sigma_{T_0,\\mathrm{meas}} = 10$，$\\sigma_{E,\\mathrm{meas}} = 5000$，$\\sigma_{\\phi,\\mathrm{meas}} = 0.02$。\n\n测试用例 3 (高不确定性边缘情况):\n- $\\mu_{\\ln C} = \\ln(10^{-6})$，$\\sigma_{\\ln C} = 0.8$。\n- $\\mu_{E} = 140000$，$\\sigma_{E} = 15000$。\n- $\\mu_{T_0} = 1200$，$\\sigma_{T_0} = 120$。\n- $\\mu_{\\phi} = 1.0$，$\\sigma_{\\phi} = 0.10$。\n- $\\mu_{\\ln p_0} = \\ln(10)$，$\\sigma_{\\ln p_0} = 0.3$。\n- $\\beta = 1.0$，$\\gamma = 0.3$，$p_{\\mathrm{ref}} = 1.0$。\n- $\\tau_s = 0.5$ (ms)。\n- $N = 50000$。\n- 测量噪声: $\\sigma_{T_0,\\mathrm{meas}} = 10$，$\\sigma_{E,\\mathrm{meas}} = 5000$，$\\sigma_{\\phi,\\mathrm{meas}} = 0.02$。\n\n您的程序必须为每个测试用例实现以下步骤：\n- 从指定的先验分布中抽样 $C$、$E$、$T_0$、$\\phi$ 和 $p_0$，并使用蒙特卡洛估计器估计先验超出概率 $\\mathbb{P}(\\tau_{\\mathrm{ign}}  \\tau_s)$。\n- 对于测量 $T_0$、$E$ 或 $\\phi$ 的每个实验选项，使用正态-正态共轭公式计算后验方差，并通过从被测量量的更新分布（方差为 $\\sigma_{X,\\mathrm{post}}^2$，均值等于先验均值）中抽样，同时从其余量的先验分布中抽样，来估计期望超出概率。\n- 选择最小化期望超出概率的实验选项索引 $i \\in \\{1,2,3\\}$，若出现平局则选择最小的索引。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，且不含空格。顶层列表的每个元素对应一个测试用例，格式为 $[\\text{prob\\_prior}, \\text{prob\\_post\\_T}, \\text{prob\\_post\\_E}, \\text{prob\\_post\\_phi}, i]$，其中所有概率均为小数，$i$ 为整数。例如：\n$[[0.123456,0.111111,0.098765,0.110000,2],[\\dots]]$。",
            "solution": "从反应速率的 Arrhenius 定律开始，该定律指出反应速率 $k$ 可以写成 $k = A \\exp\\left(-\\frac{E}{R T}\\right)$，其中 $A$ 是指前因子，$E$ 是活化能，$R$ 是通用气体常数，$T$ 是温度。在点火现象中，点火延迟时间 $\\tau_{\\mathrm{ign}}$ 与反应速率和热化学时间尺度的某些组合成反比。一个广泛使用的、能够捕捉对温度的强敏感性和对混合物参数的单调依赖性的替代模型是\n$$\n\\tau_{\\mathrm{ign}} = C \\exp\\left(\\frac{E}{R T_0}\\right)\\left(\\phi\\right)^{\\gamma}\\left(\\frac{p_{\\mathrm{ref}}}{p_0}\\right)^{\\beta},\n$$\n其中 $C$ 将各种尺度因子整合为一个时间单位，$p_{\\mathrm{ref}}$ 是用于形成无量纲比率的参考压力，而 $\\gamma$ 和 $\\beta$ 分别编码了对当量比和压力的敏感性。$\\tau_{\\mathrm{ign}}$ 中的指数敏感性源于对反应速率指数依赖性的反转：$T_0$ 的增加会减小 $\\frac{E}{R T_0}$，从而减少 $\\tau_{\\mathrm{ign}}$，这与物理行为一致。类似地，对于正的 $\\beta$，较高的 $p_0$ 会减少 $\\tau_{\\mathrm{ign}}$，这代表了压力加速的动力学或点火延迟的减少。\n\n为了量化不确定性，我们通过其自然对数将 $C$ 和 $p_0$ 建模为对数正态分布，即 $\\ln C \\sim \\mathcal{N}\\left(\\mu_{\\ln C}, \\sigma_{\\ln C}^2\\right)$ 和 $\\ln p_0 \\sim \\mathcal{N}\\left(\\mu_{\\ln p_0}, \\sigma_{\\ln p_0}^2\\right)$。我们将 $E$、$T_0$ 和 $\\phi$ 建模为正态变量：$E \\sim \\mathcal{N}\\left(\\mu_{E}, \\sigma_{E}^2\\right)$，$T_0 \\sim \\mathcal{N}\\left(\\mu_{T_0}, \\sigma_{T_0}^2\\right)$，以及 $\\phi \\sim \\mathcal{N}\\left(\\mu_{\\phi}, \\sigma_{\\phi}^2\\right)$。为了强制当量比的物理真实性，我们将抽样得到的 $\\phi$ 裁剪到 $[0.6, 1.4]$。点火延迟阈值 $\\tau_s$ 以毫秒 (ms) 为单位指定。超出概率定义为 $\\mathbb{P}\\left(\\tau_{\\mathrm{ign}}  \\tau_s\\right)$。\n\n蒙特卡洛估计：对于给定的测试用例，从它们的分布中抽取 $N$ 个独立的 $(C,E,T_0,\\phi,p_0)$ 样本。为每个样本计算 $\\tau_{\\mathrm{ign}}$，并使用 $\\tau_{\\mathrm{ign}}  \\tau_s$ 的样本的经验分数来估计概率 $\\mathbb{P}\\left(\\tau_{\\mathrm{ign}}  \\tau_s\\right)$。\n\n通过贝叶斯方差缩减进行实验设计：假设我们可以测量一个量 $X \\in \\{T_0, E, \\phi\\}$，其加性高斯噪声建模为 $Y = X + \\epsilon$，其中 $\\epsilon \\sim \\mathcal{N}(0, \\sigma_{X,\\mathrm{meas}}^2)$ 与 $X$ 无关。在正态先验 $X \\sim \\mathcal{N}(\\mu_X, \\sigma_X^2)$ 下，给定一次测量的 $X$ 的正态-正态共轭后验分布也是正态的，其方差为\n$$\n\\sigma_{X,\\mathrm{post}}^2 = \\left(\\frac{1}{\\sigma_X^2} + \\frac{1}{\\sigma_{X,\\mathrm{meas}}^2}\\right)^{-1},\n$$\n均值为\n$$\n\\mu_{X,\\mathrm{post}}(y) = \\sigma_{X,\\mathrm{post}}^2 \\left(\\frac{\\mu_X}{\\sigma_X^2} + \\frac{y}{\\sigma_{X,\\mathrm{meas}}^2}\\right).\n$$\n当对所有可能的测量结果 $y$ 进行平均时，期望后验均值等于先验均值：$\\mathbb{E}[\\mu_{X,\\mathrm{post}}(Y)] = \\mu_X$。因此，在计划一次测量后，$X$ 的期望后验分布可以通过保持先验均值并将方差替换为 $\\sigma_{X,\\mathrm{post}}^2$ 来很好地近似。为了近似每个测量计划下的期望超出概率，我们从 $\\mathcal{N}(\\mu_X, \\sigma_{X,\\mathrm{post}}^2)$ 中抽样 $X$，并从其余参数的先验分布中抽样，为每个样本计算 $\\tau_{\\mathrm{ign}}$，并估计超出概率。这个过程为执行一次带噪测量后所获得的期望超出概率提供了一个实用的近似。\n\n选择标准：对于每个测试用例，计算先验超出概率以及在测量 $T_0$、$E$ 或 $\\phi$ 下的期望超出概率。选择对应于最小化期望超出概率的测量索引 $i \\in \\{1,2,3\\}$，若出现平局则选择最小的索引（即，如果所有选项的期望概率相等，则优先测量 $T_0$ 而不是 $E$ 和 $\\phi$，依此类推）。\n\n算法设计：\n- 固定 $R = 8.314$。\n- 对于给定的测试用例，抽取 $N$ 个样本：\n  - 抽取 $\\ln C \\sim \\mathcal{N}(\\mu_{\\ln C}, \\sigma_{\\ln C}^2)$ 并设 $C = \\exp(\\ln C)$。\n  - 抽取 $E \\sim \\mathcal{N}(\\mu_E, \\sigma_E^2)$。\n  - 抽取 $T_0 \\sim \\mathcal{N}(\\mu_{T_0}, \\sigma_{T_0}^2)$。\n  - 抽取 $\\phi \\sim \\mathcal{N}(\\mu_{\\phi}, \\sigma_{\\phi}^2)$ 并裁剪到 $[0.6, 1.4]$。\n  - 抽取 $\\ln p_0 \\sim \\mathcal{N}(\\mu_{\\ln p_0}, \\sigma_{\\ln p_0}^2)$ 并设 $p_0 = \\exp(\\ln p_0)$。\n- 计算 $\\tau_{\\mathrm{ign}} = C \\exp\\left(\\frac{E}{R T_0}\\right)\\left(\\phi\\right)^{\\gamma}\\left(\\frac{p_{\\mathrm{ref}}}{p_0}\\right)^{\\beta}$。\n- 使用超过 $\\tau_s$ 的样本比例来估计 $\\mathbb{P}\\left(\\tau_{\\mathrm{ign}}  \\tau_s\\right)$。\n- 对于每个测量选项 $X \\in \\{T_0, E, \\phi\\}$：\n  - 使用 $\\sigma_{X}^2$ 和 $\\sigma_{X,\\mathrm{meas}}^2$ 计算 $\\sigma_{X,\\mathrm{post}}^2$。\n  - 使用 $X \\sim \\mathcal{N}(\\mu_X, \\sigma_{X,\\mathrm{post}}^2)$ 进行重采样，其他变量从其先验分布中抽样，以估计期望超出概率。\n- 选择最小化期望超出概率的选项索引 $i$，若出现平局则选择最小索引。\n\n数值考虑：使用足够大的 $N$ 来减少蒙特卡洛抽样误差，同时确保计算的可行性。所有点火延迟阈值均以毫秒 (ms) 指定，计算出的概率是无单位的小数。\n\n程序将实现上述内容，并生成所需的单行、逗号分隔、方括号括起来的列表，不含空格，其中每个测试用例包含一个列表，格式为 $[\\text{prob\\_prior}, \\text{prob\\_post\\_T}, \\text{prob\\_post\\_E}, \\text{prob\\_post\\_phi}, i]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Set a global random seed for reproducibility\nnp.random.seed(42)\n\ndef monte_carlo_exceedance(mu_lnC, sigma_lnC,\n                           mu_E, sigma_E,\n                           mu_T, sigma_T,\n                           mu_phi, sigma_phi,\n                           mu_lnp, sigma_lnp,\n                           beta, gamma, p_ref,\n                           tau_s_ms,\n                           N,\n                           override_sigma_T=None,\n                           override_sigma_E=None,\n                           override_sigma_phi=None):\n    \"\"\"\n    Estimate P(tau_ign  tau_s_ms) by Monte Carlo under specified priors.\n    Optionally override the variances of T, E, or phi to represent posterior variance\n    after a measurement (means kept at prior means).\n    \"\"\"\n    # Sample ln C and construct C in ms\n    lnC = np.random.normal(mu_lnC, sigma_lnC, size=N)\n    C = np.exp(lnC)  # ms\n\n    # Sample E (J/mol)\n    sigma_E_use = sigma_E if override_sigma_E is None else override_sigma_E\n    E = np.random.normal(mu_E, sigma_E_use, size=N)\n\n    # Sample T0 (K)\n    sigma_T_use = sigma_T if override_sigma_T is None else override_sigma_T\n    T0 = np.random.normal(mu_T, sigma_T_use, size=N)\n    # Prevent non-physical very small or negative T by clipping to  1 K\n    T0 = np.clip(T0, 1.0, None)\n\n    # Sample phi (dimensionless) and clip to [0.6, 1.4]\n    sigma_phi_use = sigma_phi if override_sigma_phi is None else override_sigma_phi\n    phi = np.random.normal(mu_phi, sigma_phi_use, size=N)\n    phi = np.clip(phi, 0.6, 1.4)\n\n    # Sample ln p0 and construct p0 in atm\n    lnp0 = np.random.normal(mu_lnp, sigma_lnp, size=N)\n    p0 = np.exp(lnp0)  # atm\n\n    # Universal gas constant R (J/mol/K)\n    R = 8.314\n\n    # Compute ignition delay in ms\n    # tau = C * exp(E/(R*T0)) * phi^gamma * (p_ref/p0)^beta\n    tau_ms = C * np.exp(E / (R * T0)) * (phi ** gamma) * ((p_ref / p0) ** beta)\n\n    # Probability of exceedance tau_ms  tau_s_ms\n    exceed = (tau_ms  tau_s_ms)\n    prob = exceed.mean()\n    return prob\n\ndef posterior_variance_normal(sig_prior, sig_meas):\n    \"\"\"Compute posterior variance under normal-normal conjugacy.\"\"\"\n    return 1.0 / (1.0 / (sig_prior ** 2) + 1.0 / (sig_meas ** 2))\n\ndef format_compact(obj):\n    \"\"\"\n    Format Python lists/numbers to a compact string with no spaces.\n    Floats formatted to 6 decimal places.\n    \"\"\"\n    if isinstance(obj, list):\n        return \"[\" + \",\".join(format_compact(x) for x in obj) + \"]\"\n    elif isinstance(obj, float):\n        return f\"{obj:.6f}\"\n    elif isinstance(obj, (int, np.integer)):\n        return str(int(obj))\n    else:\n        # For numpy floats or other numeric types\n        try:\n            return f\"{float(obj):.6f}\"\n        except Exception:\n            return str(obj)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1 (happy path)\n        {\n            \"mu_lnC\": np.log(1e-6), \"sigma_lnC\": 0.4,\n            \"mu_E\": 140000.0, \"sigma_E\": 8000.0,\n            \"mu_T\": 1200.0, \"sigma_T\": 60.0,\n            \"mu_phi\": 1.0, \"sigma_phi\": 0.05,\n            \"mu_lnp\": np.log(10.0), \"sigma_lnp\": 0.2,\n            \"beta\": 1.0, \"gamma\": 0.3, \"p_ref\": 1.0,\n            \"tau_s_ms\": 0.2, \"N\": 50000,\n            \"sigma_T_meas\": 10.0, \"sigma_E_meas\": 5000.0, \"sigma_phi_meas\": 0.02\n        },\n        # Test Case 2 (boundary low threshold)\n        {\n            \"mu_lnC\": np.log(1e-6), \"sigma_lnC\": 0.4,\n            \"mu_E\": 140000.0, \"sigma_E\": 8000.0,\n            \"mu_T\": 1200.0, \"sigma_T\": 60.0,\n            \"mu_phi\": 1.0, \"sigma_phi\": 0.05,\n            \"mu_lnp\": np.log(10.0), \"sigma_lnp\": 0.2,\n            \"beta\": 1.0, \"gamma\": 0.3, \"p_ref\": 1.0,\n            \"tau_s_ms\": 0.01, \"N\": 50000,\n            \"sigma_T_meas\": 10.0, \"sigma_E_meas\": 5000.0, \"sigma_phi_meas\": 0.02\n        },\n        # Test Case 3 (edge case with high uncertainty)\n        {\n            \"mu_lnC\": np.log(1e-6), \"sigma_lnC\": 0.8,\n            \"mu_E\": 140000.0, \"sigma_E\": 15000.0,\n            \"mu_T\": 1200.0, \"sigma_T\": 120.0,\n            \"mu_phi\": 1.0, \"sigma_phi\": 0.10,\n            \"mu_lnp\": np.log(10.0), \"sigma_lnp\": 0.3,\n            \"beta\": 1.0, \"gamma\": 0.3, \"p_ref\": 1.0,\n            \"tau_s_ms\": 0.5, \"N\": 50000,\n            \"sigma_T_meas\": 10.0, \"sigma_E_meas\": 5000.0, \"sigma_phi_meas\": 0.02\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        mu_lnC = case[\"mu_lnC\"]; sigma_lnC = case[\"sigma_lnC\"]\n        mu_E = case[\"mu_E\"]; sigma_E = case[\"sigma_E\"]\n        mu_T = case[\"mu_T\"]; sigma_T = case[\"sigma_T\"]\n        mu_phi = case[\"mu_phi\"]; sigma_phi = case[\"sigma_phi\"]\n        mu_lnp = case[\"mu_lnp\"]; sigma_lnp = case[\"sigma_lnp\"]\n        beta = case[\"beta\"]; gamma = case[\"gamma\"]; p_ref = case[\"p_ref\"]\n        tau_s_ms = case[\"tau_s_ms\"]; N = case[\"N\"]\n        sigma_T_meas = case[\"sigma_T_meas\"]\n        sigma_E_meas = case[\"sigma_E_meas\"]\n        sigma_phi_meas = case[\"sigma_phi_meas\"]\n\n        # Prior exceedance probability\n        prob_prior = monte_carlo_exceedance(\n            mu_lnC, sigma_lnC,\n            mu_E, sigma_E,\n            mu_T, sigma_T,\n            mu_phi, sigma_phi,\n            mu_lnp, sigma_lnp,\n            beta, gamma, p_ref,\n            tau_s_ms,\n            N\n        )\n\n        # Posterior variances for measurement options (means remain the same)\n        sigma_T_post = np.sqrt(posterior_variance_normal(sigma_T, sigma_T_meas))\n        sigma_E_post = np.sqrt(posterior_variance_normal(sigma_E, sigma_E_meas))\n        sigma_phi_post = np.sqrt(posterior_variance_normal(sigma_phi, sigma_phi_meas))\n\n        # Expected exceedance probabilities after each measurement option\n        prob_post_T = monte_carlo_exceedance(\n            mu_lnC, sigma_lnC,\n            mu_E, sigma_E,\n            mu_T, sigma_T,\n            mu_phi, sigma_phi,\n            mu_lnp, sigma_lnp,\n            beta, gamma, p_ref,\n            tau_s_ms,\n            N,\n            override_sigma_T=sigma_T_post\n        )\n        prob_post_E = monte_carlo_exceedance(\n            mu_lnC, sigma_lnC,\n            mu_E, sigma_E,\n            mu_T, sigma_T,\n            mu_phi, sigma_phi,\n            mu_lnp, sigma_lnp,\n            beta, gamma, p_ref,\n            tau_s_ms,\n            N,\n            override_sigma_E=sigma_E_post\n        )\n        prob_post_phi = monte_carlo_exceedance(\n            mu_lnC, sigma_lnC,\n            mu_E, sigma_E,\n            mu_T, sigma_T,\n            mu_phi, sigma_phi,\n            mu_lnp, sigma_lnp,\n            beta, gamma, p_ref,\n            tau_s_ms,\n            N,\n            override_sigma_phi=sigma_phi_post\n        )\n\n        # Choose best experiment (minimize expected exceedance probability), tie-break by smallest index\n        post_probs = [prob_post_T, prob_post_E, prob_post_phi]\n        min_val = min(post_probs)\n        # Determine first index where min occurs (1-based index)\n        best_index = 1 + post_probs.index(min_val)\n\n        results.append([prob_prior, prob_post_T, prob_post_E, prob_post_phi, best_index])\n\n    # Final print statement in the exact required format (no spaces).\n    print(format_compact(results))\n\nsolve()\n```"
        }
    ]
}