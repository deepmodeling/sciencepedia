{
    "hands_on_practices": [
        {
            "introduction": "在为化学动力学开发机器学习代理模型时，一个首要目标是确保模型遵守基本的物理定律。质量守恒定律规定所有组分的质量生成率之和必须为零，这是一项至关重要的约束。本练习将通过推导一种必要的输出参数化方法，向您展示一种强大的“构造法”，将该定律直接嵌入到神经网络的架构中，从而保证所有预测在这方面都与物理相符 。",
            "id": "4037295",
            "problem": "考虑一个用于计算燃烧学的均匀、恒定密度的反应混合物，其中包含 $N_s$ 种化学物质。设混合物的密度为 $\\rho$，温度为 $T$，物种质量分数为 $\\mathbf{Y} = (Y_1,\\dots,Y_{N_s})$。在一个化学平衡的机理中，质量守恒定律要求所有物种的质量源项之和满足 $\\sum_{i=1}^{N_s} \\dot{\\omega}_i = 0$，其中 $\\dot{\\omega}_i$ 表示物种 $i$ 的质量生成速率。您的任务是构建一个用于化学建表和加速的机器学习代理模型，该模型将热化学状态 $(T, \\mathbf{Y})$ 映射到物种源项。该代理模型预测 $N_s - 1$ 个原始输出 $\\{r_i\\}_{i=1}^{N_s-1}$，其中每个 $r_i \\in \\mathbb{R}$ 都是无约束的。为了获得具有正确尺度的物理源项，将前 $N_s - 1$ 个物种的源项定义为 $\\dot{\\omega}_i = \\alpha s_i r_i$，其中 $i = 1,\\dots,N_s-1$。这里 $\\alpha > 0$ 是一个共享的标量缩放因子，它可能依赖于 $(T, \\mathbf{Y})$，而每个 $s_i > 0$ 是一个由数据集归一化产生的固定的、针对各物种的缩放常数。\n\n为最后一个物种推导一个约束输出参数化方法，以精确地强制执行总质量生成速率守恒。具体来说，给出一个关于 $\\alpha$、$\\{s_i\\}_{i=1}^{N_s-1}$ 和 $\\{r_i\\}_{i=1}^{N_s-1}$ 的 $\\dot{\\omega}_{N_s}$ 的封闭形式解析表达式，使得对于所有的代理模型输出 $\\{r_i\\}$，$\\sum_{i=1}^{N_s} \\dot{\\omega}_i = 0$ 都成立。您的最终答案必须是单个解析表达式；不要包含任何单位。",
            "solution": "该问题是有效的，因为它科学地基于化学动力学和计算燃烧学的原理，问题陈述清晰且信息充分，可得唯一解，并使用正式的科学语言进行客观陈述。\n\n目标是为最后一个物种的质量生成速率 $\\dot{\\omega}_{N_s}$ 推导一个封闭形式的表达式，从而精确满足质量守恒定律。其支配性的物理原理是化学反应系统中的总质量守恒，该原理规定所有物种的质量生成速率（源项）之和必须为零。这由以下方程给出：\n$$\n\\sum_{i=1}^{N_s} \\dot{\\omega}_i = 0\n$$\n其中 $N_s$ 是混合物中物种的总数。\n\n为了推导 $\\dot{\\omega}_{N_s}$ 的表达式，我们可以将此项从总和中分离出来。该求和可以展开为：\n$$\n\\left( \\sum_{i=1}^{N_s-1} \\dot{\\omega}_i \\right) + \\dot{\\omega}_{N_s} = 0\n$$\n通过重新排列这个方程，我们可以将 $\\dot{\\omega}_{N_s}$ 单独置于一边：\n$$\n\\dot{\\omega}_{N_s} = - \\sum_{i=1}^{N_s-1} \\dot{\\omega}_i\n$$\n这个方程通过将最后一个物种的源项定义为所有其他物种源项之和的负值来强制执行守恒定律。\n\n问题陈述一个机器学习代理模型被用来预测前 $N_s-1$ 个物种的源项。该模型的原始输出 $\\{r_i\\}_{i=1}^{N_s-1}$ 通过以下参数化方法转换为物理源项，其中 $i = 1, \\dots, N_s-1$：\n$$\n\\dot{\\omega}_i = \\alpha s_i r_i\n$$\n这里，$\\alpha$ 是一个共享的正标量缩放因子，而每个 $s_i$ 是一个固定的、针对各物种的正缩放常数。\n\n现在，我们将 $\\dot{\\omega}_i$ 的这个定义代入 $\\dot{\\omega}_{N_s}$ 的表达式中：\n$$\n\\dot{\\omega}_{N_s} = - \\sum_{i=1}^{N_s-1} (\\alpha s_i r_i)\n$$\n由于缩放因子 $\\alpha$ 是一个共享标量，它相对于求和索引 $i$ 是一个常数。因此，可以将其从求和中提取出来：\n$$\n\\dot{\\omega}_{N_s} = - \\alpha \\sum_{i=1}^{N_s-1} s_i r_i\n$$\n这就是关于共享缩放因子 $\\alpha$、各物种缩放常数 $\\{s_i\\}_{i=1}^{N_s-1}$ 以及代理模型原始输出 $\\{r_i\\}_{i=1}^{N_s-1}$ 的 $\\dot{\\omega}_{N_s}$ 的最终封闭形式解析表达式。这种参数化方法保证了对于代理模型输出的任何一组无约束实数值 $\\{r_i\\}$，$\\sum_{i=1}^{N_s} \\dot{\\omega}_i = 0$ 都成立，从而将物理守恒定律直接嵌入到模型的输出层中。热化学状态的变量，如温度 $T$ 和物种质量分数 $\\mathbf{Y}$，是机器学习模型的输入，模型据此产生 $\\{r_i\\}$ 值并可能确定 $\\alpha$，但它们不出现在强制执行守恒约束本身的最终代数关系式中。",
            "answer": "$$\n\\boxed{- \\alpha \\sum_{i=1}^{N_s-1} s_i r_i}\n$$"
        },
        {
            "introduction": "尽管架构约束可以强制执行某些物理定律，但机器学习模型仍可能产生非物理预测，例如负的组分浓度。一个稳健的代理模型必须包含一种策略来纠正这些违规，同时不破坏其他基本定律，如元素守恒。本练习提供了一个动手计算，以实现一个两步校正：首先裁剪非物理值，然后求解一个小型线性系统以恢复元素平衡，展示了一种确保模型输出物理真实性的实用且数学上合理的方法 。",
            "id": "4037315",
            "problem": "考虑一个恒压、等温、空间均匀的反应器步骤，在该步骤中，使用机器学习（ML）代理模型通过预测部分物种的浓度增量来加速化学建表。物种组成为 $\\{\\mathrm{H_2}, \\mathrm{O_2}, \\mathrm{H_2O}\\}$。设该步骤开始时的摩尔浓度为 $\\mathbf{c} = [c_{\\mathrm{H_2}}, c_{\\mathrm{O_2}}, c_{\\mathrm{H_2O}}]^{\\top} = [\\,0.03,\\, 0.20,\\, 0.01\\,]^{\\top}$，单位为 $\\mathrm{mol}\\,\\mathrm{m}^{-3}$。对于此时间步，ML代理模型预测的原始浓度更新量为 $\\Delta \\hat{\\mathbf{c}} = [\\,\\Delta \\hat{c}_{\\mathrm{H_2}},\\, \\Delta \\hat{c}_{\\mathrm{O_2}},\\, \\Delta \\hat{c}_{\\mathrm{H_2O}}\\,]^{\\top} = [\\,-0.08,\\,-0.04,\\,+0.08\\,]^{\\top}$，单位为 $\\mathrm{mol}\\,\\mathrm{m}^{-3}$。\n\n假设代理模型在其原始输出中遵守元素守恒，因此氢原子和氧原子的总数在机器精度内是守恒的。将物种映射到原子计数的元素关联矩阵为\n$$\nA \\;=\\; \\begin{bmatrix}\n2  0  2 \\\\\n0  2  1\n\\end{bmatrix},\n$$\n其中第 $1$ 行是氢原子，第 $2$ 行是氧原子。\n\n由于预测的更新将使 $\\mathrm{H_2}$ 浓度变为负值，因此通过仅裁剪 $\\mathrm{H_2}$ 的更新来强制实施正值性，使得更新后的 $\\mathrm{H_2}$ 浓度恰好为零，即，设 $\\Delta c_{\\mathrm{H_2}} = -c_{\\mathrm{H_2}}$，同时保留 $\\Delta c_{\\mathrm{O_2}}$ 和 $\\Delta c_{\\mathrm{H_2O}}$ 以待校正。为了在这次裁剪后精确地恢复元素守恒，计算一个应用于剩余物种更新的校正量 $\\mathbf{x} = [\\,x_{\\mathrm{O_2}},\\, x_{\\mathrm{H_2O}}\\,]^{\\top}$，使得最终的校正满足 $A \\Delta \\mathbf{c} = \\mathbf{0}$，其中 $\\Delta \\mathbf{c} = [\\,\\Delta c_{\\mathrm{H_2}},\\, \\Delta \\hat{c}_{\\mathrm{O_2}} + x_{\\mathrm{O_2}},\\, \\Delta \\hat{c}_{\\mathrm{H_2O}} + x_{\\mathrm{H_2O}}\\,]^{\\top}$。\n\n仅使用所述的物理定律和定义（浓度的非负性和元素守恒），确定在应用正值性裁剪和守恒校正后的校正氧气浓度 $c_{\\mathrm{O_2}}^{\\mathrm{new}} = c_{\\mathrm{O_2}} + \\Delta \\hat{c}_{\\mathrm{O_2}} + x_{\\mathrm{O_2}}$。用 $\\mathrm{mol}\\,\\mathrm{m}^{-3}$ 单位表示你的最终答案，并四舍五入到四位有效数字。",
            "solution": "该问题要求我们确定在对机器学习模型预测的原始浓度更新应用一个两步校正过程后，氧气的最终浓度 $c_{\\mathrm{O_2}}^{\\mathrm{new}}$。这两个步骤是：首先，通过裁剪强制实现浓度的非负性；其次，通过对其余物种应用校正来恢复元素守恒。\n\n首先，我们重述给定的条件。\n物种为 $\\mathrm{H_2}$、$\\mathrm{O_2}$ 和 $\\mathrm{H_2O}$。\n初始摩尔浓度由向量 $\\mathbf{c}$ 给出：\n$$\n\\mathbf{c} = \\begin{bmatrix} c_{\\mathrm{H_2}} \\\\ c_{\\mathrm{O_2}} \\\\ c_{\\mathrm{H_2O}} \\end{bmatrix} = \\begin{bmatrix} 0.03 \\\\ 0.20 \\\\ 0.01 \\end{bmatrix} \\, \\mathrm{mol}\\,\\mathrm{m}^{-3}\n$$\nML代理模型预测的原始浓度更新由向量 $\\Delta \\hat{\\mathbf{c}}$ 给出：\n$$\n\\Delta \\hat{\\mathbf{c}} = \\begin{bmatrix} \\Delta \\hat{c}_{\\mathrm{H_2}} \\\\ \\Delta \\hat{c}_{\\mathrm{O_2}} \\\\ \\Delta \\hat{c}_{\\mathrm{H_2O}} \\end{bmatrix} = \\begin{bmatrix} -0.08 \\\\ -0.04 \\\\ 0.08 \\end{bmatrix} \\, \\mathrm{mol}\\,\\mathrm{m}^{-3}\n$$\n元素关联矩阵 $A$ 将物种浓度映射到原子浓度（第1行：H，第2行：O）：\n$$\nA = \\begin{bmatrix} 2  0  2 \\\\ 0  2  1 \\end{bmatrix}\n$$\n问题陈述原始更新 $\\Delta \\hat{\\mathbf{c}}$ 保持元素守恒，即 $A \\Delta \\hat{\\mathbf{c}} = \\mathbf{0}$。\n\n第一步是强制实施正值性。$\\mathrm{H_2}$ 的预测浓度将是 $c_{\\mathrm{H_2}} + \\Delta \\hat{c}_{\\mathrm{H_2}} = 0.03 + (-0.08) = -0.05 \\, \\mathrm{mol}\\,\\mathrm{m}^{-3}$。由于这是不符合物理规律的，$\\mathrm{H_2}$ 的更新被裁剪，使得 $\\mathrm{H_2}$ 的最终浓度恰好为零。因此，裁剪后的更新 $\\Delta c_{\\mathrm{H_2}}$ 为：\n$$\n\\Delta c_{\\mathrm{H_2}} = -c_{\\mathrm{H_2}} = -0.03 \\, \\mathrm{mol}\\,\\mathrm{m}^{-3}\n$$\n这个裁剪操作违反了元素守恒。为了恢复守恒，我们引入一个校正向量 $\\mathbf{x} = [\\,x_{\\mathrm{O_2}},\\, x_{\\mathrm{H_2O}}\\,]^{\\top}$，它被应用于其他物种的更新。最终的、校正后的浓度更新向量 $\\Delta \\mathbf{c}$ 是：\n$$\n\\Delta \\mathbf{c} = \\begin{bmatrix} \\Delta c_{\\mathrm{H_2}} \\\\ \\Delta \\hat{c}_{\\mathrm{O_2}} + x_{\\mathrm{O_2}} \\\\ \\Delta \\hat{c}_{\\mathrm{H_2O}} + x_{\\mathrm{H_2O}} \\end{bmatrix} = \\begin{bmatrix} -0.03 \\\\ -0.04 + x_{\\mathrm{O_2}} \\\\ 0.08 + x_{\\mathrm{H_2O}} \\end{bmatrix}\n$$\n这个最终的更新向量必须满足元素守恒定律，$A \\Delta \\mathbf{c} = \\mathbf{0}$。我们可以将其写成一个线性方程组：\n$$\n\\begin{bmatrix} 2  0  2 \\\\ 0  2  1 \\end{bmatrix}\n\\begin{bmatrix} -0.03 \\\\ -0.04 + x_{\\mathrm{O_2}} \\\\ 0.08 + x_{\\mathrm{H_2O}} \\end{bmatrix}\n= \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}\n$$\n这为我们的两个未知数 $x_{\\mathrm{O_2}}$ 和 $x_{\\mathrm{H_2O}}$ 提供了两个方程。\n\n第一行对应于氢原子的守恒：\n$$\n2(-0.03) + 0(-0.04 + x_{\\mathrm{O_2}}) + 2(0.08 + x_{\\mathrm{H_2O}}) = 0\n$$\n$$\n-0.06 + 0.16 + 2x_{\\mathrm{H_2O}} = 0\n$$\n$$\n0.10 + 2x_{\\mathrm{H_2O}} = 0\n$$\n$$\n2x_{\\mathrm{H_2O}} = -0.10 \\implies x_{\\mathrm{H_2O}} = -0.05\n$$\n第二行对应于氧原子的守恒：\n$$\n0(-0.03) + 2(-0.04 + x_{\\mathrm{O_2}}) + 1(0.08 + x_{\\mathrm{H_2O}}) = 0\n$$\n$$\n-0.08 + 2x_{\\mathrm{O_2}} + 0.08 + x_{\\mathrm{H_2O}} = 0\n$$\n$$\n2x_{\\mathrm{O_2}} + x_{\\mathrm{H_2O}} = 0\n$$\n代入我们找到的 $x_{\\mathrm{H_2O}}$ 的值：\n$$\n2x_{\\mathrm{O_2}} + (-0.05) = 0\n$$\n$$\n2x_{\\mathrm{O_2}} = 0.05 \\implies x_{\\mathrm{O_2}} = 0.025\n$$\n所以，对氧气更新的校正量是 $x_{\\mathrm{O_2}} = 0.025 \\, \\mathrm{mol}\\,\\mathrm{m}^{-3}$。\n\n问题要求的是最终校正后的氧气浓度 $c_{\\mathrm{O_2}}^{\\mathrm{new}}$。这可以通过将校正后的更新量加到初始浓度上来计算：\n$$\nc_{\\mathrm{O_2}}^{\\mathrm{new}} = c_{\\mathrm{O_2}} + \\Delta c_{\\mathrm{O_2}} = c_{\\mathrm{O_2}} + (\\Delta \\hat{c}_{\\mathrm{O_2}} + x_{\\mathrm{O_2}})\n$$\n代入数值：\n$$\nc_{\\mathrm{O_2}}^{\\mathrm{new}} = 0.20 + (-0.04 + 0.025)\n$$\n$$\nc_{\\mathrm{O_2}}^{\\mathrm{new}} = 0.20 - 0.015\n$$\n$$\nc_{\\mathrm{O_2}}^{\\mathrm{new}} = 0.185 \\, \\mathrm{mol}\\,\\mathrm{m}^{-3}\n$$\n问题要求答案四舍五入到四位有效数字。\n$$\n0.1850 \\, \\mathrm{mol}\\,\\mathrm{m}^{-3}\n$$",
            "answer": "$$\n\\boxed{0.1850}\n$$"
        },
        {
            "introduction": "用机器学习代理模型替代传统的化学动力学求解器，会从根本上改变控制常微分方程（ODEs）的数学特性，特别是其刚性。理解这些变化对于确保整个燃烧模拟的数值稳定性和效率至关重要。在这个编程练习中，您将使用自动微分计算神经网络代理模型的雅可比矩阵，分析其特征值，并确定显式求解器的最大稳定时间步长。这个高级练习将机器学习模型的内部工作原理与该技术的“加速”前景直接联系起来，突显了机器学习与数值分析之间的关键相互作用 。",
            "id": "4037322",
            "problem": "考虑一个降阶的刚性化学系统，其中组分质量分数向量 $\\mathbf{Y} \\in \\mathbb{R}^{n_s}$ 的演化遵循形式为 $\\dot{\\mathbf{Y}} = \\boldsymbol{\\omega}(\\mathbf{Y})$ 的常微分方程 (ODE)，$\\boldsymbol{\\omega}(\\mathbf{Y})$ 代表化学源项。为了加速化学反应计算并实现列表化，可以用一个经过训练以近似 $\\boldsymbol{\\omega}(\\mathbf{Y})$ 的人工神经网络 (ANN) 代理模型来替代精确的源项。设该代理模型为一个双层前馈人工神经网络，使用双曲正切激活函数，对于输入 $\\mathbf{Y} \\in \\mathbb{R}^{3}$ 定义为\n$$\n\\boldsymbol{f}(\\mathbf{Y}) = \\mathbf{W}_2 \\, \\tanh(\\mathbf{W}_1 \\mathbf{Y} + \\mathbf{b}_1) + \\mathbf{b}_2,\n$$\n其中 $\\mathbf{W}_1 \\in \\mathbb{R}^{m \\times 3}$，$\\mathbf{b}_1 \\in \\mathbb{R}^{m}$，$\\mathbf{W}_2 \\in \\mathbb{R}^{3 \\times m}$，以及 $\\mathbf{b}_2 \\in \\mathbb{R}^{3}$，且 $m=3$。该代理模型的输出近似于 $\\dot{\\mathbf{Y}}$，在适当缩放后单位为 $\\text{s}^{-1}$。该代理模型的雅可比矩阵 $\\mathbf{J}(\\mathbf{Y})$ 定义为\n$$\n\\mathbf{J}(\\mathbf{Y}) = \\frac{\\partial \\boldsymbol{f}(\\mathbf{Y})}{\\partial \\mathbf{Y}},\n$$\n其元素的单位为 $\\text{s}^{-1}$。应使用自动微分 (AD) 技术，基于应用于指定 ANN 结构的链式法则来计算 $\\mathbf{J}(\\mathbf{Y})$。\n\n从刚性 ODE 的线性化原理和显式 Euler 方法出发，回顾标量线性测试方程 $\\dot{y} = \\lambda y$ 的基本稳定性考量，即当放大因子满足 $|1 + h \\lambda| \\leq 1$ 时，显式 Euler 步长 $y_{n+1} = y_n + h \\lambda y_n$ 是线性稳定的。通过分析雅可比矩阵 $\\mathbf{J}(\\mathbf{Y})$ 的特征值，将此考量推广到矩阵情况，并确定当特征值具有大的负实部时，稳定显式 Euler 时间步长 $h$ 的一个保守界限。您必须以秒为单位表示稳定步长界限 $h_{\\max}$。\n\n实现一个完整的程序，该程序：\n- 构建指定的 ANN 代理模型 $\\boldsymbol{f}(\\mathbf{Y})$。\n- 应用自动微分到 ANN 各层和激活函数上，以计算在指定 $\\mathbf{Y}$ 处的雅可比矩阵 $\\mathbf{J}(\\mathbf{Y})$。\n- 计算 $\\mathbf{J}(\\mathbf{Y})$ 的特征值。\n- 基于特征值，使用推广到每个可能具有非零虚部的特征值的标量稳定性条件，确定一个保守的最大稳定显式 Euler 时间步长 $h_{\\max}$（以秒为单位）。\n- 通过检查单步放大矩阵 $\\mathbf{A}(h) = \\mathbf{I} + h \\mathbf{J}(\\mathbf{Y})$ 的谱半径并测试其是否小于或等于 $1$，来为一组指定的显式 Euler 时间步长 $h$ 评估线性稳定性。\n\n您必须考虑三个测试案例。对于每个案例，您将获得网络参数、评估点 $\\mathbf{Y}$ 以及三个以秒为单位的显式 Euler 步长 $h$。使用与上述描述相同的 ANN 架构，其中 $m=3$。参数如下：\n\n案例 1 (具有非对角耦合的刚性系统):\n- $\\mathbf{W}_1 = \\begin{bmatrix} 3.0  -1.0  0.5 \\\\ -2.0  4.0  -0.5 \\\\ 1.0  1.0  -3.0 \\end{bmatrix}$,\n- $\\mathbf{b}_1 = \\begin{bmatrix} 0.1 \\\\ -0.2 \\\\ 0.3 \\end{bmatrix}$,\n- $\\mathbf{W}_2 = \\begin{bmatrix} -1000.0  50.0  0.0 \\\\ 0.0  -50.0  20.0 \\\\ 10.0  -5.0  -1.0 \\end{bmatrix}$,\n- $\\mathbf{b}_2 = \\begin{bmatrix} 0.0 \\\\ 0.0 \\\\ 0.0 \\end{bmatrix}$,\n- $\\mathbf{Y} = \\begin{bmatrix} 0.1 \\\\ 0.3 \\\\ 0.6 \\end{bmatrix}$,\n- 步长 $h \\in \\{10^{-5} \\, \\text{s}, 10^{-3} \\, \\text{s}, 10^{-2} \\, \\text{s}\\}$。\n\n案例 2 (中等刚性系统):\n- $\\mathbf{W}_1 = \\begin{bmatrix} 1.0  0.2  -0.3 \\\\ 0.5  -0.1  0.4 \\\\ -0.7  0.8  -0.2 \\end{bmatrix}$,\n- $\\mathbf{b}_1 = \\begin{bmatrix} 0.05 \\\\ -0.05 \\\\ 0.02 \\end{bmatrix}$,\n- $\\mathbf{W}_2 = \\begin{bmatrix} -10.0  1.0  0.0 \\\\ 0.5  -5.0  0.5 \\\\ 0.0  0.2  -1.0 \\end{bmatrix}$,\n- $\\mathbf{b}_2 = \\begin{bmatrix} 0.0 \\\\ 0.0 \\\\ 0.0 \\end{bmatrix}$,\n- $\\mathbf{Y} = \\begin{bmatrix} 0.9 \\\\ 0.05 \\\\ 0.05 \\end{bmatrix}$,\n- 步长 $h \\in \\{10^{-3} \\, \\text{s}, 5 \\cdot 10^{-2} \\, \\text{s}, 10^{-1} \\, \\text{s}\\}$。\n\n案例 3 (具有激活饱和效应的极端刚性系统):\n- $\\mathbf{W}_1 = \\begin{bmatrix} 8.0  -6.0  4.0 \\\\ -9.0  5.0  -7.0 \\\\ 6.5  -8.0  10.0 \\end{bmatrix}$,\n- $\\mathbf{b}_1 = \\begin{bmatrix} 0.5 \\\\ -0.3 \\\\ 0.1 \\end{bmatrix}$,\n- $\\mathbf{W}_2 = \\begin{bmatrix} -5000.0  200.0  0.0 \\\\ 0.0  -100.0  40.0 \\\\ 30.0  -10.0  -20.0 \\end{bmatrix}$,\n- $\\mathbf{b}_2 = \\begin{bmatrix} 0.0 \\\\ 0.0 \\\\ 0.0 \\end{bmatrix}$,\n- $\\mathbf{Y} = \\begin{bmatrix} 0.33 \\\\ 0.33 \\\\ 0.34 \\end{bmatrix}$,\n- 步长 $h \\in \\{10^{-5} \\, \\text{s}, 10^{-4} \\, \\text{s}, 10^{-3} \\, \\text{s}\\}$。\n\n对于每个案例：\n1. 使用 AD 计算 ANN 的雅可比矩阵 $\\mathbf{J}(\\mathbf{Y})$。\n2. 计算 $\\mathbf{J}(\\mathbf{Y})$ 的所有特征值 $\\{\\lambda_i\\}$。\n3. 根据应用于每个 $\\lambda_i$ 的标量稳定性条件，确定一个保守的界限 $h_{\\max}$ (以秒为单位)，以确保对所有特征值同时满足 $|1 + h \\lambda_i| \\leq 1$。\n4. 对于案例中每个指定的 $h$，计算谱半径 $\\rho(\\mathbf{I} + h \\mathbf{J}(\\mathbf{Y}))$ 并报告该步长是否线性稳定，即 $\\rho(\\mathbf{I} + h \\mathbf{J}(\\mathbf{Y})) \\leq 1$ 是否成立。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个元素对应一个案例，应为一个形式为 $[h_{\\max}, s_1, s_2, s_3]$ 的列表，其中 $h_{\\max}$ 是一个以秒为单位的浮点数，$s_k$ 是布尔值，表示该案例第 $k$ 个步长的稳定性。例如，最终输出必须如下所示\n$$\n[\\,[h_{\\max}^{(1)}, s_1^{(1)}, s_2^{(1)}, s_3^{(1)}],[h_{\\max}^{(2)}, s_1^{(2)}, s_2^{(2)}, s_3^{(2)}],[h_{\\max}^{(3)}, s_1^{(3)}, s_2^{(3)}, s_3^{(3)}]\\,].\n$$\n所有 $h_{\\max}$ 值必须以秒为单位表示，并且不应打印任何其他文本。",
            "solution": "首先验证问题，以确保其科学上合理、自洽且适定。\n\n### 第 1 步：提取已知条件\n- **控制方程：** 组分质量分数向量 $\\mathbf{Y} \\in \\mathbb{R}^{n_s}$ 的演化遵循常微分方程 (ODE) $\\dot{\\mathbf{Y}} = \\boldsymbol{\\omega}(\\mathbf{Y})$。\n- **ANN 代理模型：** 源项 $\\boldsymbol{\\omega}(\\mathbf{Y})$ 由一个双层前馈人工神经网络 (ANN) $\\boldsymbol{f}(\\mathbf{Y})$ 近似，其中 $\\mathbf{Y} \\in \\mathbb{R}^{3}$。\n- **ANN 架构：** $\\boldsymbol{f}(\\mathbf{Y}) = \\mathbf{W}_2 \\, \\tanh(\\mathbf{W}_1 \\mathbf{Y} + \\mathbf{b}_1) + \\mathbf{b}_2$。\n- **ANN 参数：** $\\mathbf{W}_1 \\in \\mathbb{R}^{m \\times 3}$，$\\mathbf{b}_1 \\in \\mathbb{R}^{m}$，$\\mathbf{W}_2 \\in \\mathbb{R}^{3 \\times m}$，$\\mathbf{b}_2 \\in \\mathbb{R}^{3}$，隐藏层大小 $m=3$。\n- **雅可比矩阵：** $\\mathbf{J}(\\mathbf{Y}) = \\frac{\\partial \\boldsymbol{f}(\\mathbf{Y})}{\\partial \\mathbf{Y}}$。\n- **稳定性条件 (标量)：** 对于 $\\dot{y} = \\lambda y$，如果 $|1 + h \\lambda| \\leq 1$，则显式 Euler 步长是稳定的。\n- **稳定性条件 (系统)：** 对于给定的时间步长 $h$，通过检查放大矩阵的谱半径 $\\rho(\\mathbf{I} + h \\mathbf{J}(\\mathbf{Y}))$ 是否小于或等于 $1$ 来评估稳定性。\n- **目标：** 对三个测试案例，计算：\n    1. 使用自动微分 (AD) 计算雅可比矩阵 $\\mathbf{J}(\\mathbf{Y})$。\n    2. $\\mathbf{J}(\\mathbf{Y})$ 的特征值。\n    3. 一个保守的最大稳定显式 Euler 时间步长 $h_{\\max}$。\n    4. 对一组给定的时间步长 $h$ 的稳定性。\n- **测试案例：** 提供了三个案例，每个案例都包含特定的矩阵 $\\mathbf{W}_1, \\mathbf{W}_2$，向量 $\\mathbf{b}_1, \\mathbf{b}_2, \\mathbf{Y}$，以及一组要测试的时间步长 $h$。\n\n### 第 2 步：使用提取的已知条件进行验证\n- **科学依据：** 该问题基于数值分析（ODE 求解器的稳定性）、线性代数（特征值分析）和标准机器学习模型（前馈神经网络）的基本原理。其应用背景——加速计算燃烧学中的刚性化学动力学——是一个成熟且活跃的科学研究领域。\n- **适定性：** 问题定义清晰，具有唯一的可计算解。ANN 架构、参数和评估点均已指定，从而可以确定性地得到雅可比矩阵和后续的稳定性分析。\n- **目标：** 问题以精确、定量且无偏的数学语言陈述。\n- **完整性与一致性：** 提供了所有必要信息（网络参数、评估点、稳定性准则）。所有矩阵和向量的维度对于规定的运算都是一致的。\n- **现实性：** 该设定是现实的。刚性化学系统很常见，使用 ANN 代理模型是一种现代技术。权重矩阵中的大负值（例如，-1000.0, -5000.0）是刚性现象模型的特征，这正确地暗示了需要非常小的显式时间步长。\n- **非平凡性：** 这是一个实质性问题，需要应用矩阵微积分（雅可比矩阵的链式法则）、数值线性代数（特征值计算）以及 ODE 系统数值稳定性理论。\n\n### 第 3 步：结论与行动\n问题被判定为**有效**。这是一个在应用数学和计算科学领域中定义明确、有科学依据的问题。现在将继续进行求解过程。\n\n---\n\n### 基于原理的求解\n\n问题的核心是评估显式 Euler 数值积分方案在应用于一个常微分方程 (ODE) 系统时的稳定性，该系统的右侧由人工神经网络 (ANN) 近似。\n\n**1. 通过自动微分 (AD) 计算 ANN 的雅可比矩阵**\n\nANN 作为化学源项的代理模型，即 $\\dot{\\mathbf{Y}} \\approx \\boldsymbol{f}(\\mathbf{Y})$。该系统的局部行为由其线性化决定，这需要雅可比矩阵 $\\mathbf{J}(\\mathbf{Y}) = \\frac{\\partial \\boldsymbol{f}}{\\partial \\mathbf{Y}}$。我们使用链式法则来计算它，这是反向模式自动微分的基石。\n\n网络定义为 $\\boldsymbol{f}(\\mathbf{Y}) = \\mathbf{W}_2 \\, \\tanh(\\mathbf{W}_1 \\mathbf{Y} + \\mathbf{b}_1) + \\mathbf{b}_2$。让我们将其分解为中间步骤：\n1.  隐藏层的预激活：$\\mathbf{z}_1 = \\mathbf{W}_1 \\mathbf{Y} + \\mathbf{b}_1$。\n2.  隐藏层的激活：$\\mathbf{a}_1 = \\tanh(\\mathbf{z}_1)$。\n3.  网络的输出：$\\boldsymbol{f} = \\mathbf{W}_2 \\mathbf{a}_1 + \\mathbf{b}_2$。\n\n应用链式求导法则：\n$$\n\\mathbf{J}(\\mathbf{Y}) = \\frac{\\partial \\boldsymbol{f}}{\\partial \\mathbf{Y}} = \\frac{\\partial \\boldsymbol{f}}{\\partial \\mathbf{a}_1} \\frac{\\partial \\mathbf{a}_1}{\\partial \\mathbf{z}_1} \\frac{\\partial \\mathbf{z}_1}{\\partial \\mathbf{Y}}\n$$\n我们来评估每个偏导数：\n-   $\\frac{\\partial \\mathbf{z}_1}{\\partial \\mathbf{Y}}$：从线性变换 $\\mathbf{z}_1 = \\mathbf{W}_1 \\mathbf{Y} + \\mathbf{b}_1$ 可知，关于 $\\mathbf{Y}$ 的导数就是权重矩阵 $\\mathbf{W}_1$。\n-   $\\frac{\\partial \\boldsymbol{f}}{\\partial \\mathbf{a}_1}$：从输出变换 $\\boldsymbol{f} = \\mathbf{W}_2 \\mathbf{a}_1 + \\mathbf{b}_2$ 可知，关于 $\\mathbf{a}_1$ 的导数是权重矩阵 $\\mathbf{W}_2$。\n-   $\\frac{\\partial \\mathbf{a}_1}{\\partial \\mathbf{z}_1}$：激活函数 $\\tanh$ 是逐元素应用的。因此，其导数是一个对角矩阵。$\\tanh(x)$ 的导数是 $1 - \\tanh^2(x)$。该层的雅可比矩阵是 $\\mathbf{D} = \\text{diag}(1 - \\tanh^2(z_{1,i}))$，其中 $z_{1,i}$ 是向量 $\\mathbf{z}_1$ 的元素。\n\n结合这些分量，得到 ANN 雅可比矩阵的解析表达式：\n$$\n\\mathbf{J}(\\mathbf{Y}) = \\mathbf{W}_2 \\cdot \\text{diag}(1 - \\tanh^2(\\mathbf{W}_1 \\mathbf{Y} + \\mathbf{b}_1)) \\cdot \\mathbf{W}_1\n$$\n该公式被实现用于计算在给定状态 $\\mathbf{Y}$ 下的雅可比矩阵。\n\n**2. 显式 Euler 稳定性分析**\n\n显式 Euler 方法通过将系统局部线性化为 $\\dot{\\boldsymbol{\\eta}} = \\mathbf{J}(\\mathbf{Y}_n) \\boldsymbol{\\eta}$ 来近似 $\\dot{\\mathbf{Y}} = \\boldsymbol{f}(\\mathbf{Y})$ 的解，其中 $\\boldsymbol{\\eta}$ 是对 $\\mathbf{Y}_n$ 的扰动。更新步骤为：\n$$\n\\mathbf{Y}_{n+1} = \\mathbf{Y}_n + h \\boldsymbol{f}(\\mathbf{Y}_n)\n$$\n为了进行稳定性分析，我们考虑扰动如何演化。在第 $n$ 步的扰动 $\\boldsymbol{\\epsilon}_n$ 演化到第 $n+1$ 步的 $\\boldsymbol{\\epsilon}_{n+1}$，遵循：\n$$\n\\mathbf{Y}_{n+1} + \\boldsymbol{\\epsilon}_{n+1} = (\\mathbf{Y}_n + \\boldsymbol{\\epsilon}_n) + h \\boldsymbol{f}(\\mathbf{Y}_n + \\boldsymbol{\\epsilon}_n) \\approx \\mathbf{Y}_n + \\boldsymbol{\\epsilon}_n + h (\\boldsymbol{f}(\\mathbf{Y}_n) + \\mathbf{J}(\\mathbf{Y}_n) \\boldsymbol{\\epsilon}_n)\n$$\n减去未受扰动的方程，我们得到扰动的演化：\n$$\n\\boldsymbol{\\epsilon}_{n+1} = (\\mathbf{I} + h \\mathbf{J}(\\mathbf{Y}_n)) \\boldsymbol{\\epsilon}_n\n$$\n矩阵 $\\mathbf{A}(h) = \\mathbf{I} + h \\mathbf{J}$ 是放大矩阵。为使方法稳定，扰动不能增长，这要求 $\\mathbf{A}(h)$ 的谱半径不大于 $1$：\n$$\n\\rho(\\mathbf{A}(h)) \\le 1\n$$\n$\\mathbf{A}(h)$ 的特征值（记为 $\\mu_i$）与 $\\mathbf{J}$ 的特征值（记为 $\\lambda_i$）通过 $\\mu_i = 1 + h \\lambda_i$ 相关联。因此，稳定性条件变为对雅可比矩阵 $\\mathbf{J}$ 的所有特征值 $\\lambda_i$ 都满足 $|1 + h \\lambda_i| \\leq 1$。\n\n**3. 最大稳定时间步长 $h_{\\max}$**\n\n设 $\\mathbf{J}$ 的一个特征值为复数 $\\lambda = x + iy$。稳定性条件为 $|1 + h(x+iy)|^2 \\leq 1$，展开为：\n$$\n(1 + hx)^2 + (hy)^2 \\leq 1 \\implies 1 + 2hx + h^2x^2 + h^2y^2 \\leq 1 \\implies h(2x + h(x^2+y^2)) \\leq 0\n$$\n由于时间步长 $h$ 必须为正，我们需要 $2x + h(x^2+y^2) \\leq 0$。对于刚性系统，我们期望特征值的实部为负，即 $x = \\text{Re}(\\lambda) < 0$。如果任何 $\\text{Re}(\\lambda) > 0$，则系统局部不稳定，没有正的显式时间步长可以是稳定的，因此 $h_{\\max} = 0$。对于 $\\text{Re}(\\lambda) < 0$，对 $h$ 的条件是：\n$$\nh \\leq \\frac{-2x}{x^2+y^2} = \\frac{-2 \\text{Re}(\\lambda)}{|\\lambda|^2}\n$$\n为确保系统所有模式的稳定性，$h$ 必须对每个特征值都满足此条件。因此，最大稳定时间步长是这些界限中最严格的一个：\n$$\nh_{\\max} = \\min_{\\lambda_i : \\text{Re}(\\lambda_i) < 0} \\left( \\frac{-2 \\text{Re}(\\lambda_i)}{|\\lambda_i|^2} \\right)\n$$\n\n**4. 算法流程**\n\n对每个测试案例，执行以下步骤：\n1.  构建网络参数 $\\mathbf{W}_1, \\mathbf{b}_1, \\mathbf{W}_2, \\mathbf{b}_2$ 和状态向量 $\\mathbf{Y}$ 的 NumPy 表示。向量的形状为列向量。\n2.  使用推导的解析公式计算在 $\\mathbf{Y}$ 处的雅可比矩阵 $\\mathbf{J}$。\n3.  使用 `numpy.linalg.eigvals` 计算 $\\mathbf{J}$ 的特征值 $\\{\\lambda_i\\}$。\n4.  通过遍历特征值并应用上述公式来计算 $h_{\\max}$。最小化搜索使用无穷大作为初始值。如果任何特征值具有正实部，则将 $h_{\\max}$ 设置为 $0$。\n5.  对于测试案例中每个指定的时间步长 $h$：\n    a. 形成放大矩阵 $\\mathbf{A}(h) = \\mathbf{I} + h \\mathbf{J}$。\n    b. 计算 $\\mathbf{A}(h)$ 的特征值。\n    c. 通过找到这些特征值中的最大绝对值来计算谱半径 $\\rho(\\mathbf{A}(h))$。\n    d. 如果 $\\rho(\\mathbf{A}(h)) \\leq 1$，则步长 $h$ 被认为是稳定的，否则是不稳定的。\n6.  收集每个案例的结果（$h_{\\max}$ 和三个稳定性的布尔值）并格式化为所需的最终输出字符串。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of determining explicit Euler stability for an ANN-surrogated ODE system.\n    \"\"\"\n    test_cases = [\n        {\n            \"W1\": np.array([[3.0, -1.0, 0.5], [-2.0, 4.0, -0.5], [1.0, 1.0, -3.0]]),\n            \"b1\": np.array([0.1, -0.2, 0.3]),\n            \"W2\": np.array([[-1000.0, 50.0, 0.0], [0.0, -50.0, 20.0], [10.0, -5.0, -1.0]]),\n            \"b2\": np.array([0.0, 0.0, 0.0]),\n            \"Y\": np.array([0.1, 0.3, 0.6]),\n            \"h_steps\": [1e-5, 1e-3, 1e-2]\n        },\n        {\n            \"W1\": np.array([[1.0, 0.2, -0.3], [0.5, -0.1, 0.4], [-0.7, 0.8, -0.2]]),\n            \"b1\": np.array([0.05, -0.05, 0.02]),\n            \"W2\": np.array([[-10.0, 1.0, 0.0], [0.5, -5.0, 0.5], [0.0, 0.2, -1.0]]),\n            \"b2\": np.array([0.0, 0.0, 0.0]),\n            \"Y\": np.array([0.9, 0.05, 0.05]),\n            \"h_steps\": [1e-3, 5e-2, 1e-1]\n        },\n        {\n            \"W1\": np.array([[8.0, -6.0, 4.0], [-9.0, 5.0, -7.0], [6.5, -8.0, 10.0]]),\n            \"b1\": np.array([0.5, -0.3, 0.1]),\n            \"W2\": np.array([[-5000.0, 200.0, 0.0], [0.0, -100.0, 40.0], [30.0, -10.0, -20.0]]),\n            \"b2\": np.array([0.0, 0.0, 0.0]),\n            \"Y\": np.array([0.33, 0.33, 0.34]),\n            \"h_steps\": [1e-5, 1e-4, 1e-3]\n        }\n    ]\n\n    all_case_results = []\n\n    for case in test_cases:\n        W1, b1, W2, b2, Y, h_steps = case.values()\n        \n        # Ensure vectors are column vectors (N, 1) for matrix operations\n        Y_col = Y.reshape(-1, 1)\n        b1_col = b1.reshape(-1, 1)\n\n        # 1. Compute Jacobian J(Y) using Automatic Differentiation formula\n        z1 = W1 @ Y_col + b1_col\n        a1 = np.tanh(z1)\n        \n        # Derivative of tanh is 1 - tanh^2, forms a diagonal matrix\n        d_tanh_dz1 = 1 - a1**2\n        D = np.diag(d_tanh_dz1.flatten())\n        \n        J = W2 @ D @ W1\n\n        # 2. Compute eigenvalues of J(Y)\n        eigs_J = np.linalg.eigvals(J)\n\n        # 3. Determine max stable time step h_max\n        h_max = np.inf\n        unstable_mode_found = False\n        for lam in eigs_J:\n            re_lam = lam.real\n            abs_lam_sq = np.abs(lam)**2\n            \n            if re_lam > 1e-12: # Check for positive real part (instability)\n                unstable_mode_found = True\n                break\n            \n            if re_lam < -1e-12 and abs_lam_sq > 1e-12:\n                h_bound = -2.0 * re_lam / abs_lam_sq\n                if h_bound < h_max:\n                    h_max = h_bound\n        \n        if unstable_mode_found:\n            h_max = 0.0\n\n        # 4. Check stability for each specified h\n        I = np.identity(J.shape[0])\n        stability_results = []\n        for h in h_steps:\n            # Amplification matrix A = I + hJ\n            A = I + h * J\n            # Eigenvalues of A\n            eigs_A = np.linalg.eigvals(A)\n            # Spectral radius of A\n            spectral_radius = np.max(np.abs(eigs_A))\n            is_stable = spectral_radius <= 1.0\n            stability_results.append(is_stable)\n\n        # Format results for the current case\n        case_result_list = [h_max] + stability_results\n        all_case_results.append(case_result_list)\n\n    # Format the final output string to match the required format without spaces\n    # Example: [[h1,True,False,False],[h2,True,True,False]]\n    formatted_results = []\n    for res_list in all_case_results:\n        # Convert each item to its string representation and join with commas\n        res_str = \",\".join(map(str, res_list))\n        formatted_results.append(f\"[{res_str}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}