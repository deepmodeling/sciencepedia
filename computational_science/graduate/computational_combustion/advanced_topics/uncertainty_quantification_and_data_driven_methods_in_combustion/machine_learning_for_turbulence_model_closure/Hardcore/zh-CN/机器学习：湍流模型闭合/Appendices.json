{
    "hands_on_practices": [
        {
            "introduction": "机器学习模型需要精心设计的、能够遵循底层物理原理的特征，例如旋转不变性。第一个练习将指导您完成一个基本过程：将模拟产生的原始速度场和密度场，转换为一组标准化的标量不变量。掌握这种数据处理流程是构建稳健的湍流模型中至关重要的第一步 。",
            "id": "4037707",
            "problem": "您将获得代表在均匀笛卡尔网格上的变密度湍流燃烧的合成直接数值模拟（DNS）场。您的任务是实现一个从原始DNS场到一组标量不变量特征的完整映射，这些特征适合作为计算燃烧学中湍流封闭的机器学习模型的输入。具体来说，您必须计算质量加权（法沃滤波）速度、其梯度，并由此计算对称应变率张量和反对称旋转率张量，然后计算一组标准化的标量不变量。该映射必须在数学上是一致的，具有旋转不变性，并且必须产生具有正确物理单位的值。\n\n从以下定义和要求开始：\n\n- 使用一个尺寸为 $3\\times 3 \\times 3$ 的均匀网格，其笛卡尔坐标为 $(x,y,z)$，间距相等 $\\Delta x=\\Delta y=\\Delta z=1\\,\\mathrm{m}$。所有空间操作都必须使用周期性边界条件。\n- 质量加权（法沃）滤波速度定义为 $\\tilde{u}_i=\\overline{\\rho u_i}/\\overline{\\rho}$，其中 $\\overline{\\cdot}$ 表示使用紧凑对称核的局部空间平均。将 $\\overline{\\cdot}$ 实现为以每个网格单元为中心的 $3\\times 3 \\times 3$ 邻域上的离散顶帽平均（应用周期性环绕），即 27 个相邻值的算术平均值。\n- 速度梯度张量定义为 $\\nabla \\tilde{\\mathbf{u}}$，其分量为 $\\partial_i \\tilde{u}_j=\\frac{\\partial \\tilde{u}_j}{\\partial x_i}$，通过带周期性边界条件的二阶中心差分近似：\n$$\n\\partial_i \\tilde{u}_j(\\mathbf{x}_{pqr})\\approx \\frac{\\tilde{u}_j(\\mathbf{x}_{pqr}+\\Delta x_i \\mathbf{e}_i)-\\tilde{u}_j(\\mathbf{x}_{pqr}-\\Delta x_i \\mathbf{e}_i)}{2\\Delta x_i},\n$$\n其中 $\\mathbf{x}_{pqr}$ 是索引为 $(p,q,r)$ 的单元，$\\mathbf{e}_i$ 是沿轴 $i\\in\\{x,y,z\\}$ 的单位向量，并且对于所有 $i$，$\\Delta x_i=\\Delta x$。\n\n- 将速度梯度分解为其对称和反对称部分：\n$$\nS_{ij}=\\frac{1}{2}\\left(\\partial_i \\tilde{u}_j+\\partial_j \\tilde{u}_i\\right),\\qquad\nR_{ij}=\\frac{1}{2}\\left(\\partial_i \\tilde{u}_j-\\partial_j \\tilde{u}_i\\right),\n$$\n其中 $\\mathbf{S}$ 是应变率张量，$\\mathbf{R}$ 是旋转率张量。\n\n从 $\\mathbf{S}$ 和 $\\mathbf{R}$ 计算中心网格索引 $(p,q,r)=(1,1,1)$ 处的以下标量不变量：\n\n- $I_1=\\mathrm{tr}(\\mathbf{S})$，单位为 $\\mathrm{s}^{-1}$，\n- $I_2=\\det(\\mathbf{S})$，单位为 $\\mathrm{s}^{-3}$，\n- $I_3=\\mathrm{tr}(\\mathbf{S}^2)$，单位为 $\\mathrm{s}^{-2}$，\n- $I_4=\\mathrm{tr}(\\mathbf{R}^2)$，单位为 $\\mathrm{s}^{-2}$，\n- $I_5=\\mathrm{tr}(\\mathbf{S}^3)$，单位为 $\\mathrm{s}^{-3}$，\n- $I_6=\\mathrm{tr}(\\mathbf{R}^2\\mathbf{S})$，单位为 $\\mathrm{s}^{-3}$，\n- $I_7=\\mathrm{tr}(\\mathbf{R}^2\\mathbf{S}^2)$，单位为 $\\mathrm{s}^{-4}$。\n\n所有不变量都必须直接从在指定索引处由法沃滤波速度梯度构建的离散 $\\mathbf{S}$ 和 $\\mathbf{R}$ 张量计算得出。不要调用任何预先制表的公式，并确保在滤波和微分中都一致地执行周期性边界条件。\n\n测试套件：\n在以下四种情况下实施并评估该映射。在每种情况下，使用指定的参数在 $3\\times 3\\times 3$ 网格上定义速度分量 $(u,v,w)$ 和密度 $\\rho$，其中坐标为 $x=i\\Delta x, y=j\\Delta y, z=k\\Delta z$，索引 $i,j,k\\in\\{0,1,2\\}$。\n\n$1.$ 具有均匀密度的均匀剪切流：\n- 参数：$a=2.0\\,\\mathrm{s}^{-1}$，$\\rho_0=1.0\\,\\mathrm{kg/m^3}$。\n- 场：$u=a\\,y$, $v=0$, $w=0$, $\\rho=\\rho_0$。\n\n$2.$ 绕 $z$ 轴的具有均匀密度的刚体旋转：\n- 参数：$\\omega=1.5\\,\\mathrm{s}^{-1}$，$\\rho_0=1.0\\,\\mathrm{kg/m^3}$。\n- 场：$u=-\\omega\\,y$, $v=\\omega\\,x$, $w=0$, $\\rho=\\rho_0$。\n\n$3.$ 在 $x$ 方向上具有密度分层的可压缩滞止型流：\n- 参数：$a=0.5\\,\\mathrm{s}^{-1}$, $b=0.75\\,\\mathrm{s}^{-1}$, $c=-0.25\\,\\mathrm{s}^{-1}$, $\\rho_0=1.2\\,\\mathrm{kg/m^3}$, $\\epsilon=0.05\\,\\mathrm{m}^{-1}$。\n- 场：$u=a\\,x$, $v=b\\,y$, $w=c\\,z$, $\\rho=\\rho_0\\,(1+\\epsilon\\,x)$。\n\n$4.$ 空间常数场：\n- 参数：$\\rho_0=1.0\\,\\mathrm{kg/m^3}$。\n- 场：$u=0$, $v=0$, $w=0$, $\\rho=\\rho_0$。\n\n单位：\n以 $\\mathrm{s}^{-1}$ 表示 $I_1$，以 $\\mathrm{s}^{-3}$ 表示 $I_2$、$I_5$ 和 $I_6$，以 $\\mathrm{s}^{-2}$ 表示 $I_3$ 和 $I_4$，以 $\\mathrm{s}^{-4}$ 表示 $I_7$。仅输出数值；不要附加单位字符串。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素对应一个测试用例，并且其本身是按顺序 $[I_1,I_2,I_3,I_4,I_5,I_6,I_7]$ 排列的七个不变量的列表。例如，输出应如下所示：\n$[\\,[i_{1,1},i_{1,2},\\dots,i_{1,7}],\\,[i_{2,1},\\dots,i_{2,7}],\\,[i_{3,1},\\dots,i_{3,7}],\\,[i_{4,1},\\dots,i_{4,7}]\\,]$，\n其中 $i_{m,n}$ 表示第 $m$ 个测试用例的第 $n$ 个不变量，为一个浮点数。",
            "solution": "该问题要求使用来自合成直接数值模拟（DNS）场的数据，计算从速度梯度张量导出的一组标量不变量。该过程涉及多个步骤：生成原始速度场和密度场、空间滤波、计算法沃滤波速度场、通过数值微分获得速度梯度张量、分解为对称和反对称部分，最后计算张量不变量。整个程序的有效性和结果严重依赖于数值算子和网格配置的精确定义。\n\n首先，让我们建立问题陈述中定义的计算网格和算子。网格是一个尺寸为 $3 \\times 3 \\times 3$ 的均匀笛卡尔网格，网格间距为 $\\Delta x = \\Delta y = \\Delta z = 1\\,\\mathrm{m}$。我们可以用整数索引 $(i,j,k)$ 表示网格点，其中 $i,j,k \\in \\{0, 1, 2\\}$，对应于空间坐标 $x=i\\Delta x, y=j\\Delta y, z=k\\Delta z$。包括滤波和微分在内的所有空间操作都必须采用周期性边界条件。\n\n核心操作是空间平均，用 $\\overline{\\cdot}$ 表示。它被定义为在一个 $3 \\times 3 \\times 3$ 邻域上的离散顶帽平均，包含 27 个单元值的均值。让我们分析这个定义在我们特定网格上的结果。一个索引为 $(i,j,k)$ 的点，其邻居的索引为 $(i+di, j+dj, k+dk)$，其中 $di, dj, dk \\in \\{-1, 0, 1\\}$。在每个维度大小为 3 的网格上使用周期性边界条件，索引需要对 3 取模。对于任何点 $(i,j,k)$，对于所有 $di,dj,dk \\in \\{-1,0,1\\}$，其邻居索引集合 $\\{ (i+di)\\%3, (j+dj)\\%3, (k+dk)\\%3 \\}$ 跨越了所有可能的索引集合 $\\{0,1,2\\} \\times \\{0,1,2\\} \\times \\{0,1,2\\}$。例如，对于中心单元 $(1,1,1)$，其邻居的索引从 $(0,0,0)$ 到 $(2,2,2)$，覆盖了整个网格。对于像 $(0,0,0)$ 这样的角单元，其邻居在每个维度上的索引为 $\\{(-1)\\%3, 0\\%3, 1\\%3\\}$，这对应于索引 $\\{2,0,1\\}$。同样，邻域就是整个网格。\n\n这个分析揭示了一个关键属性：对于指定的具有周期性边界的 $3 \\times 3 \\times 3$ 网格， $3 \\times 3 \\times 3$ 的顶帽滤波器等同于对域中所有 27 个点进行全局平均。因此，对于任何场 $f(x,y,z)$，滤波后的场 $\\overline{f}$ 将在空间上是恒定的，其值等于 $f$ 在整个域上的平均值。\n\n法沃滤波速度 $\\tilde{u}_i$ 定义为 $\\tilde{u}_i = \\overline{\\rho u_i} / \\overline{\\rho}$。滤波操作应用于密度场 $\\rho$ 和动量场 $\\rho u_i$。这将产生空间上恒定的场 $\\overline{\\rho}$ 和 $\\overline{\\rho u_i}$。它们的比值 $\\tilde{u}_i$ 因此对于每个分量 $i \\in \\{1,2,3\\}$ 也是一个空间上恒定的标量值。让我们将这些恒定值表示为 $\\tilde{u}_c$, $\\tilde{v}_c$ 和 $\\tilde{w}_c$。因此，法沃滤波速度场为 $\\tilde{\\mathbf{u}}(\\mathbf{x}) = (\\tilde{u}_c, \\tilde{v}_c, \\tilde{w}_c)$，它在整个域上是均匀的。\n\n下一步是计算速度梯度张量 $\\nabla \\tilde{\\mathbf{u}}$，其分量为 $\\partial_i \\tilde{u}_j = \\frac{\\partial \\tilde{u}_j}{\\partial x_i}$。这些分量是在中心网格点 $(1,1,1)$ 处使用二阶中心差分方案计算的。例如，分量 $\\partial_x \\tilde{u}$ 为：\n$$\n\\partial_x \\tilde{u}(1,1,1) \\approx \\frac{\\tilde{u}(x_2, y_1, z_1) - \\tilde{u}(x_0, y_1, z_1)}{2\\Delta x}\n$$\n由于场 $\\tilde{u}$ 是恒定的，$\\tilde{u}(x_2, y_1, z_1) = \\tilde{u}(x_0, y_1, z_1) = \\tilde{u}_c$。因此分子为零。这适用于梯度的所有分量。因此，速度梯度张量 $\\nabla \\tilde{\\mathbf{u}}$ 是零张量：\n$$\n\\nabla \\tilde{\\mathbf{u}} = \\begin{pmatrix} 0 & 0 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix}\n$$\n只要平均密度 $\\overline{\\rho}$ 非零，从而可以计算 $\\tilde{u}_i$，这个结论就成立。对于所提供的所有四个测试用例，密度 $\\rho$ 在任何地方都严格为正，确保了 $\\overline{\\rho} > 0$。\n\n从零速度梯度，我们得到应变率张量 $\\mathbf{S}$ 和旋转率张量 $\\mathbf{R}$：\n$$\nS_{ij} = \\frac{1}{2}\\left(\\partial_i \\tilde{u}_j + \\partial_j \\tilde{u}_i\\right) = \\frac{1}{2}(0 + 0) = 0\n$$\n$$\nR_{ij} = \\frac{1}{2}\\left(\\partial_i \\tilde{u}_j - \\partial_j \\tilde{u}_i\\right) = \\frac{1}{2}(0 - 0) = 0\n$$\n$\\mathbf{S}$ 和 $\\mathbf{R}$ 都是 $3 \\times 3$ 的零张量 $\\mathbf{0}$。\n\n最后，我们从这些零张量计算七个标量不变量：\n- $I_1 = \\mathrm{tr}(\\mathbf{S}) = \\mathrm{tr}(\\mathbf{0}) = 0$\n- $I_2 = \\det(\\mathbf{S}) = \\det(\\mathbf{0}) = 0$\n- $I_3 = \\mathrm{tr}(\\mathbf{S}^2) = \\mathrm{tr}(\\mathbf{0}) = 0$\n- $I_4 = \\mathrm{tr}(\\mathbf{R}^2) = \\mathrm{tr}(\\mathbf{0}) = 0$\n- $I_5 = \\mathrm{tr}(\\mathbf{S}^3) = \\mathrm{tr}(\\mathbf{0}) = 0$\n- $I_6 = \\mathrm{tr}(\\mathbf{R}^2\\mathbf{S}) = \\mathrm{tr}(\\mathbf{0} \\cdot \\mathbf{0}) = 0$\n- $I_7 = \\mathrm{tr}(\\mathbf{R}^2\\mathbf{S}^2) = \\mathrm{tr}(\\mathbf{0} \\cdot \\mathbf{0}) = 0$\n\n由于滤波算子的性质，这个推理是通用的，适用于在指定网格上定义的任何初始场 $\\rho$ 和 $u_i$ 集合。因此，对于所有四个测试用例，计算出的七个不变量集合将是 $[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]$。所提供的数值实现将正式执行这些步骤以确认此结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes scalar invariants from synthetic DNS fields for four test cases.\n    The problem setup leads to all invariants being zero due to the specific\n    choice of grid size and filter kernel which results in a constant\n    Favre-filtered velocity field.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"name\": \"Homogeneous shear flow\",\n            \"params\": {\"a\": 2.0, \"rho0\": 1.0},\n            \"fields\": {\n                \"u\": lambda x, y, z, p: p[\"a\"] * y,\n                \"v\": lambda x, y, z, p: 0.0,\n                \"w\": lambda x, y, z, p: 0.0,\n                \"rho\": lambda x, y, z, p: p[\"rho0\"],\n            },\n        },\n        {\n            \"name\": \"Solid-body rotation\",\n            \"params\": {\"omega\": 1.5, \"rho0\": 1.0},\n            \"fields\": {\n                \"u\": lambda x, y, z, p: -p[\"omega\"] * y,\n                \"v\": lambda x, y, z, p: p[\"omega\"] * x,\n                \"w\": lambda x, y, z, p: 0.0,\n                \"rho\": lambda x, y, z, p: p[\"rho0\"],\n            },\n        },\n        {\n            \"name\": \"Compressible stagnation flow\",\n            \"params\": {\n                \"a\": 0.5, \"b\": 0.75, \"c\": -0.25, \"rho0\": 1.2, \"epsilon\": 0.05\n            },\n            \"fields\": {\n                \"u\": lambda x, y, z, p: p[\"a\"] * x,\n                \"v\": lambda x, y, z, p: p[\"b\"] * y,\n                \"w\": lambda x, y, z, p: p[\"c\"] * z,\n                \"rho\": lambda x, y, z, p: p[\"rho0\"] * (1 + p[\"epsilon\"] * x),\n            },\n        },\n        {\n            \"name\": \"Spatially constant fields\",\n            \"params\": {\"rho0\": 1.0},\n            \"fields\": {\n                \"u\": lambda x, y, z, p: 0.0,\n                \"v\": lambda x, y, z, p: 0.0,\n                \"w\": lambda x, y, z, p: 0.0,\n                \"rho\": lambda x, y, z, p: p[\"rho0\"],\n            },\n        },\n    ]\n\n    results = []\n    \n    # Grid properties\n    grid_size = (3, 3, 3)\n    dx = dy = dz = 1.0\n    deltas = [dx, dy, dz]\n\n    for case in test_cases:\n        params = case[\"params\"]\n        field_funcs = case[\"fields\"]\n\n        # 1. Generate Raw Fields\n        # Grid coordinates (indices i, j, k are used as coordinates as delta=1)\n        k_coords, j_coords, i_coords = np.mgrid[0:grid_size[2], 0:grid_size[1], 0:grid_size[0]]\n        x_coords, y_coords, z_coords = i_coords * dx, j_coords * dy, k_coords * dz\n\n        rho = np.full(grid_size, fill_value=0.0, dtype=float)\n        u = np.full(grid_size, fill_value=0.0, dtype=float)\n        v = np.full(grid_size, fill_value=0.0, dtype=float)\n        w = np.full(grid_size, fill_value=0.0, dtype=float)\n        \n        rho = field_funcs[\"rho\"](x_coords, y_coords, z_coords, params)\n        u = field_funcs[\"u\"](x_coords, y_coords, z_coords, params)\n        v = field_funcs[\"v\"](x_coords, y_coords, z_coords, params)\n        w = field_funcs[\"w\"](x_coords, y_coords, z_coords, params)\n\n        # 2. Compute Favre-Filtered Velocity\n        # In a 3x3x3 periodic grid, a 3x3x3 top-hat filter is a global average.\n        rho_bar = np.mean(rho)\n        rhou_bar = np.mean(rho * u)\n        rhov_bar = np.mean(rho * v)\n        rhow_bar = np.mean(rho * w)\n\n        u_tilde_scalar = rhou_bar / rho_bar\n        v_tilde_scalar = rhov_bar / rho_bar\n        w_tilde_scalar = rhow_bar / rho_bar\n\n        u_tilde_field = np.full(grid_size, u_tilde_scalar)\n        v_tilde_field = np.full(grid_size, v_tilde_scalar)\n        w_tilde_field = np.full(grid_size, w_tilde_scalar)\n        \n        tilde_vels = [u_tilde_field, v_tilde_field, w_tilde_field]\n\n        # 3. Compute Velocity Gradient Tensor at center (1,1,1)\n        grad_u_tilde = np.zeros((3, 3))\n        center_idx = (1, 1, 1) # p,q,r -> z,y,x indices in numpy\n\n        for j in range(3): # component of velocity (u_j)\n            for i in range(3): # direction of derivative (d/dx_i)\n                # Central difference: (f(x+h) - f(x-h)) / 2h\n                # Indices must be wrapped due to periodicity\n                \n                # neighbor index +1\n                p1_idx = list(center_idx)\n                p1_idx[2-i] = (center_idx[2-i] + 1) % 3\n                \n                # neighbor index -1\n                m1_idx = list(center_idx)\n                m1_idx[2-i] = (center_idx[2-i] - 1 + 3) % 3\n\n                val_p1 = tilde_vels[j][tuple(p1_idx)]\n                val_m1 = tilde_vels[j][tuple(m1_idx)]\n                \n                grad_u_tilde[i, j] = (val_p1 - val_m1) / (2.0 * deltas[i])\n\n        # 4. Decompose into Strain-Rate and Rotation-Rate Tensors\n        S = 0.5 * (grad_u_tilde + grad_u_tilde.T)\n        R = 0.5 * (grad_u_tilde - grad_u_tilde.T)\n\n        # 5. Compute Scalar Invariants\n        S2 = S @ S\n        S3 = S2 @ S\n        R2 = R @ R\n\n        I1 = np.trace(S)\n        I2 = np.linalg.det(S)\n        I3 = np.trace(S2)\n        I4 = np.trace(R2)\n        I5 = np.trace(S3)\n        I6 = np.trace(R2 @ S)\n        I7 = np.trace(R2 @ S2)\n        \n        invariants = [I1, I2, I3, I4, I5, I6, I7]\n        results.append(invariants)\n\n    # Final print statement in the exact required format.\n    # We construct the string representation manually to match the required format.\n    result_strings = []\n    for inv_list in results:\n        # Format each list to avoid spaces and use one decimal place for floats.\n        inv_str = f\"[{','.join(f'{x:.1f}' for x in inv_list)}]\"\n        result_strings.append(inv_str)\n\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "湍流建模中的一个关键挑战是确保模型的预测在物理上是“可实现的”，并且不违反基本原理。本练习关注于雷诺应力各向异性张量，这是许多湍流模型的关键输出，并演示了如何使用特征值分析来验证其物理有效性。这种检查对于防止模拟中出现非物理结果和确保数值方案的稳定性至关重要 。",
            "id": "4037715",
            "problem": "考虑一个计算燃烧模拟中的反应剪切层，其中雷诺应力各向异性张量 $b_{ij}$ 使用张量基神经网络（TBNN）进行建模。TBNN 通过不变量标量函数以及由平均应变率张量 $S_{ij}$ 和平均旋转率张量 $R_{ij}$ 构建的张量基，从平均速度梯度 $A_{ij}$ 构造 $b_{ij}$。基本定义如下：\n- 应变率张量 $S_{ij}$ 和旋转率张量 $R_{ij}$ 定义为 $S_{ij} = \\tfrac{1}{2}\\left(A_{ij} + A_{ji}\\right)$ 和 $R_{ij} = \\tfrac{1}{2}\\left(A_{ij} - A_{ji}\\right)$。\n- 在 TBNN 框架中，各向异性张量 $b_{ij}$ 通过构造是对称且无迹的，并被建模为基张量 $T^{(m)}_{ij}$ 的线性组合，其标量系数函数 $g_{m}$ 依赖于 $S_{ij}$ 和 $R_{ij}$ 的不变量。\n\n对于一个不可压缩的平面非预混火焰段，假设局部平均速度梯度为\n$$\nA_{ij} = \\begin{pmatrix}\n0  2  0 \\\\\n0  0  0 \\\\\n0  0  0\n\\end{pmatrix}.\n$$\nTBNN 使用以下三个由 $S_{ij}$ 和 $R_{ij}$ 构造的基张量：\n$$\nT^{(1)}_{ij} = S_{ij}, \\quad T^{(2)}_{ij} = S_{ik}R_{kj} - R_{ik}S_{kj}, \\quad T^{(3)}_{ij} = S_{ik}S_{kj} - \\tfrac{1}{3}\\,\\mathrm{tr}\\!\\left(S^{2}\\right)\\delta_{ij}.\n$$\n网络使用的标量不变量是 $I_{1} = \\mathrm{tr}\\!\\left(S^{2}\\right)$ 和 $I_{2} = \\mathrm{tr}\\!\\left(R^{2}\\right)$。对于该流动，训练好的网络指定的系数函数为\n$$\ng_{1} = \\alpha_{1}\\,\\frac{I_{1}}{1 + |I_{2}|}, \\quad g_{2} = \\frac{\\alpha_{2}}{1 + I_{1}}, \\quad g_{3} = \\frac{\\alpha_{3}}{1 - I_{2}},\n$$\n其中常数 $\\alpha_{1} = \\tfrac{3}{40}$，$\\alpha_{2} = \\tfrac{3}{10}$，以及 $\\alpha_{3} = \\tfrac{3}{4}$。预测的各向异性为\n$$\nb_{ij} = \\sum_{m=1}^{3} g_{m}\\,T^{(m)}_{ij}.\n$$\n\n任务：\n1. 使用上述定义，为给定的 $A_{ij}$ 计算 $S_{ij}$、$R_{ij}$ 以及不变量 $I_{1}$ 和 $I_{2}$。\n2. 计算 $g_{1}$、$g_{2}$ 和 $g_{3}$，然后根据指定的基张量组合出 $b_{ij}$。\n3. 计算 $b_{ij}$ 的有序特征值 $\\lambda_{1} \\ge \\lambda_{2} \\ge \\lambda_{3}$ 和重心坐标\n$$\nC_{1\\mathrm{C}} = \\lambda_{1} - \\lambda_{2}, \\quad C_{2\\mathrm{C}} = 2\\left(\\lambda_{2} - \\lambda_{3}\\right), \\quad C_{3\\mathrm{C}} = 3\\lambda_{3} + 1.\n$$\n验证 $C_{1\\mathrm{C}}$、$C_{2\\mathrm{C}}$ 和 $C_{3\\mathrm{C}}$ 均非负且总和为 $1$，以确保可实现性。\n\n将由以下公式定义的可实现性余量作为你的最终答案报告：\n$$\n\\Delta = \\min\\!\\left(C_{1\\mathrm{C}},\\,C_{2\\mathrm{C}},\\,C_{3\\mathrm{C}}\\right),\n$$\n表示为单一的、简化的、无单位的封闭形式解析表达式。无需四舍五入；提供精确表达式。",
            "solution": "该问题被验证为具有科学依据、问题明确且客观。它展示了在湍流建模领域中使用张量基神经网络 (TBNN) 的一个标准计算。所有必要的定义和数据都已提供，并且没有内部矛盾。\n\n求解过程按照问题陈述的要求分步进行。\n\n首先，我们根据给定的平均速度梯度张量 $A_{ij}$ 计算平均应变率张量 $S_{ij}$ 和平均旋转率张量 $R_{ij}$。\n平均速度梯度由下式给出\n$$\nA_{ij} = \\begin{pmatrix}\n0  2  0 \\\\\n0  0  0 \\\\\n0  0  0\n\\end{pmatrix}\n$$\n其转置为\n$$\nA_{ji} = \\begin{pmatrix}\n0  0  0 \\\\\n2  0  0 \\\\\n0  0  0\n\\end{pmatrix}\n$$\n应变率张量 $S_{ij}$ 是 $A_{ij}$ 的对称部分：\n$$\nS_{ij} = \\frac{1}{2}\\left(A_{ij} + A_{ji}\\right) = \\frac{1}{2}\\left( \\begin{pmatrix}\n0  2  0 \\\\\n0  0  0 \\\\\n0  0  0\n\\end{pmatrix} + \\begin{pmatrix}\n0  0  0 \\\\\n2  0  0 \\\\\n0  0  0\n\\end{pmatrix} \\right) = \\frac{1}{2}\\begin{pmatrix}\n0  2  0 \\\\\n2  0  0 \\\\\n0  0  0\n\\end{pmatrix} = \\begin{pmatrix}\n0  1  0 \\\\\n1  0  0 \\\\\n0  0  0\n\\end{pmatrix}\n$$\n旋转率张量 $R_{ij}$ 是 $A_{ij}$ 的反对称部分：\n$$\nR_{ij} = \\frac{1}{2}\\left(A_{ij} - A_{ji}\\right) = \\frac{1}{2}\\left( \\begin{pmatrix}\n0  2  0 \\\\\n0  0  0 \\\\\n0  0  0\n\\end{pmatrix} - \\begin{pmatrix}\n0  0  0 \\\\\n2  0  0 \\\\\n0  0  0\n\\end{pmatrix} \\right) = \\frac{1}{2}\\begin{pmatrix}\n0  2  0 \\\\\n-2  0  0 \\\\\n0  0  0\n\\end{pmatrix} = \\begin{pmatrix}\n0  1  0 \\\\\n-1  0  0 \\\\\n0  0  0\n\\end{pmatrix}\n$$\n接下来，我们计算标量不变量 $I_{1} = \\mathrm{tr}(S^{2})$ 和 $I_{2} = \\mathrm{tr}(R^{2})$。\n$$\nS^{2} = S_{ik}S_{kj} = \\begin{pmatrix}\n0  1  0 \\\\\n1  0  0 \\\\\n0  0  0\n\\end{pmatrix} \\begin{pmatrix}\n0  1  0 \\\\\n1  0  0 \\\\\n0  0  0\n\\end{pmatrix} = \\begin{pmatrix}\n1  0  0 \\\\\n0  1  0 \\\\\n0  0  0\n\\end{pmatrix}\n$$\n$$\nI_{1} = \\mathrm{tr}(S^{2}) = 1 + 1 + 0 = 2\n$$\n$$\nR^{2} = R_{ik}R_{kj} = \\begin{pmatrix}\n0  1  0 \\\\\n-1  0  0 \\\\\n0  0  0\n\\end{pmatrix} \\begin{pmatrix}\n0  1  0 \\\\\n-1  0  0 \\\\\n0  0  0\n\\end{pmatrix} = \\begin{pmatrix}\n-1  0  0 \\\\\n0  -1  0 \\\\\n0  0  0\n\\end{pmatrix}\n$$\n$$\nI_{2} = \\mathrm{tr}(R^{2}) = -1 + (-1) + 0 = -2\n$$\n现在，我们使用给定的常数 $\\alpha_{1} = \\frac{3}{40}$、$\\alpha_{2} = \\frac{3}{10}$ 和 $\\alpha_{3} = \\frac{3}{4}$ 计算标量系数函数 $g_{1}$、$g_{2}$ 和 $g_{3}$。\n$$\ng_{1} = \\alpha_{1}\\frac{I_{1}}{1 + |I_{2}|} = \\frac{3}{40} \\frac{2}{1 + |-2|} = \\frac{3}{40} \\frac{2}{3} = \\frac{1}{20}\n$$\n$$\ng_{2} = \\frac{\\alpha_{2}}{1 + I_{1}} = \\frac{3/10}{1 + 2} = \\frac{3/10}{3} = \\frac{1}{10}\n$$\n$$\ng_{3} = \\frac{\\alpha_{3}}{1 - I_{2}} = \\frac{3/4}{1 - (-2)} = \\frac{3/4}{3} = \\frac{1}{4}\n$$\n然后我们计算基张量 $T^{(1)}_{ij}$、$T^{(2)}_{ij}$ 和 $T^{(3)}_{ij}$。\n$T^{(1)}_{ij} = S_{ij} = \\begin{pmatrix}\n0  1  0 \\\\\n1  0  0 \\\\\n0  0  0\n\\end{pmatrix}$。\n对于 $T^{(2)}_{ij} = S_{ik}R_{kj} - R_{ik}S_{kj}$：\n$$\nS R = \\begin{pmatrix}\n0  1  0 \\\\\n1  0  0 \\\\\n0  0  0\n\\end{pmatrix} \\begin{pmatrix}\n0  1  0 \\\\\n-1  0  0 \\\\\n0  0  0\n\\end{pmatrix} = \\begin{pmatrix}\n-1  0  0 \\\\\n0  1  0 \\\\\n0  0  0\n\\end{pmatrix}\n$$\n$$\nR S = \\begin{pmatrix}\n0  1  0 \\\\\n-1  0  0 \\\\\n0  0  0\n\\end{pmatrix} \\begin{pmatrix}\n0  1  0 \\\\\n1  0  0 \\\\\n0  0  0\n\\end{pmatrix} = \\begin{pmatrix}\n1  0  0 \\\\\n0  -1  0 \\\\\n0  0  0\n\\end{pmatrix}\n$$\n$$\nT^{(2)}_{ij} = SR - RS = \\begin{pmatrix}\n-2  0  0 \\\\\n0  2  0 \\\\\n0  0  0\n\\end{pmatrix}\n$$\n对于 $T^{(3)}_{ij} = S_{ik}S_{kj} - \\frac{1}{3}\\mathrm{tr}(S^{2})\\delta_{ij}$：\n$$\nT^{(3)}_{ij} = S^{2} - \\frac{1}{3}I_{1}\\delta_{ij} = \\begin{pmatrix}\n1  0  0 \\\\\n0  1  0 \\\\\n0  0  0\n\\end{pmatrix} - \\frac{2}{3}\\begin{pmatrix}\n1  0  0 \\\\\n0  1  0 \\\\\n0  0  1\n\\end{pmatrix} = \\begin{pmatrix}\n1/3  0  0 \\\\\n0  1/3  0 \\\\\n0  0  -2/3\n\\end{pmatrix}\n$$\n我们组合各向异性张量 $b_{ij} = \\sum_{m=1}^{3} g_{m}T^{(m)}_{ij}$：\n$$\nb_{ij} = \\frac{1}{20}\\begin{pmatrix}\n0  1  0 \\\\\n1  0  0 \\\\\n0  0  0\n\\end{pmatrix} + \\frac{1}{10}\\begin{pmatrix}\n-2  0  0 \\\\\n0  2  0 \\\\\n0  0  0\n\\end{pmatrix} + \\frac{1}{4}\\begin{pmatrix}\n1/3  0  0 \\\\\n0  1/3  0 \\\\\n0  0  -2/3\n\\end{pmatrix}\n$$\n$$\nb_{ij} = \\begin{pmatrix}\n0 - \\frac{2}{10} + \\frac{1}{12} & \\frac{1}{20} & 0 \\\\\n\\frac{1}{20} & 0 + \\frac{2}{10} + \\frac{1}{12} & 0 \\\\\n0 & 0 & 0 + 0 - \\frac{2}{12}\n\\end{pmatrix} = \\begin{pmatrix}\n-\\frac{1}{5} + \\frac{1}{12} & \\frac{1}{20} & 0 \\\\\n\\frac{1}{20} & \\frac{1}{5} + \\frac{1}{12} & 0 \\\\\n0 & 0 & -\\frac{1}{6}\n\\end{pmatrix}\n$$\n$$\nb_{ij} = \\begin{pmatrix}\n\\frac{-12+5}{60} & \\frac{3}{60} & 0 \\\\\n\\frac{3}{60} & \\frac{12+5}{60} & 0 \\\\\n0 & 0 & -\\frac{10}{60}\n\\end{pmatrix} = \\frac{1}{60}\\begin{pmatrix}\n-7 & 3 & 0 \\\\\n3 & 17 & 0 \\\\\n0 & 0 & -10\n\\end{pmatrix}\n$$\n为了找到特征值，我们观察到该矩阵是块对角矩阵。一个特征值立即可得 $\\lambda = -\\frac{10}{60} = -\\frac{1}{6}$。另外两个是子矩阵 $M = \\frac{1}{60}\\begin{pmatrix} -7 & 3 \\\\ 3 & 17 \\end{pmatrix}$ 的特征值。设 $\\begin{pmatrix} -7 & 3 \\\\ 3 & 17 \\end{pmatrix}$ 的特征值为 $\\mu$。特征方程为 $(-7-\\mu)(17-\\mu) - (3)(3) = 0$，化简为 $\\mu^2 - 10\\mu - 119 - 9 = 0$，即 $\\mu^2 - 10\\mu - 128 = 0$。\n使用二次公式：\n$$\n\\mu = \\frac{10 \\pm \\sqrt{(-10)^2 - 4(1)(-128)}}{2} = \\frac{10 \\pm \\sqrt{100 + 512}}{2} = \\frac{10 \\pm \\sqrt{612}}{2}\n$$\n由于 $612 = 36 \\times 17$，$\\sqrt{612} = 6\\sqrt{17}$。\n$$\n\\mu = \\frac{10 \\pm 6\\sqrt{17}}{2} = 5 \\pm 3\\sqrt{17}\n$$\n$b_{ij}$ 的特征值为 $\\lambda = \\mu/60$，因此我们得到特征值集合 $\\left\\{ \\frac{5+3\\sqrt{17}}{60}, \\frac{5-3\\sqrt{17}}{60}, -\\frac{10}{60} \\right\\}$。\n我们将它们排序为 $\\lambda_{1} \\ge \\lambda_{2} \\ge \\lambda_{3}$。\n因为 $\\sqrt{17} > \\sqrt{25/9} = 5/3$，所以 $3\\sqrt{17} > 5$，因此 $\\frac{5-3\\sqrt{17}}{60}$ 是负数。\n为了比较 $\\frac{5-3\\sqrt{17}}{60}$ 和 $-\\frac{10}{60}$，我们比较 $5-3\\sqrt{17}$ 和 $-10$。这等价于比较 $15$ 和 $3\\sqrt{17}$，或者 $5$ 和 $\\sqrt{17}$。由于 $5^2 = 25 > 17$，我们有 $5 > \\sqrt{17}$，这意味着 $15 > 3\\sqrt{17}$，因此 $5-3\\sqrt{17} > -10$。\n排序后的特征值为：\n$$\n\\lambda_{1} = \\frac{5 + 3\\sqrt{17}}{60}, \\quad \\lambda_{2} = \\frac{5 - 3\\sqrt{17}}{60}, \\quad \\lambda_{3} = -\\frac{10}{60} = -\\frac{1}{6}\n$$\n接下来，我们计算重心坐标并验证可实现性。\n$$\nC_{1\\mathrm{C}} = \\lambda_{1} - \\lambda_{2} = \\frac{5 + 3\\sqrt{17}}{60} - \\frac{5 - 3\\sqrt{17}}{60} = \\frac{6\\sqrt{17}}{60} = \\frac{\\sqrt{17}}{10}\n$$\n$$\nC_{2\\mathrm{C}} = 2\\left(\\lambda_{2} - \\lambda_{3}\\right) = 2\\left(\\frac{5 - 3\\sqrt{17}}{60} - \\frac{-10}{60}\\right) = 2\\left(\\frac{15 - 3\\sqrt{17}}{60}\\right) = \\frac{15 - 3\\sqrt{17}}{30} = \\frac{5 - \\sqrt{17}}{10}\n$$\n$$\nC_{3\\mathrm{C}} = 3\\lambda_{3} + 1 = 3\\left(-\\frac{1}{6}\\right) + 1 = -\\frac{1}{2} + 1 = \\frac{1}{2} = \\frac{5}{10}\n$$\n所有坐标都是非负的：$C_{1\\mathrm{C}} > 0$；$C_{2\\mathrm{C}} > 0$ 因为 $5 > \\sqrt{17}$；$C_{3\\mathrm{C}} > 0$。\n它们的和是 $C_{1\\mathrm{C}} + C_{2\\mathrm{C}} + C_{3\\mathrm{C}} = \\frac{\\sqrt{17}}{10} + \\frac{5 - \\sqrt{17}}{10} + \\frac{5}{10} = \\frac{\\sqrt{17} + 5 - \\sqrt{17} + 5}{10} = \\frac{10}{10} = 1$。可实现性条件得到满足。\n\n最后，我们求出可实现性余量 $\\Delta = \\min(C_{1\\mathrm{C}}, C_{2\\mathrm{C}}, C_{3\\mathrm{C}})$。我们必须比较 $\\frac{\\sqrt{17}}{10}$、$\\frac{5 - \\sqrt{17}}{10}$ 和 $\\frac{5}{10}$。\n比较 $C_{1\\mathrm{C}}$ 和 $C_{2\\mathrm{C}}$：$\\sqrt{17}$ vs $5 - \\sqrt{17} \\implies 2\\sqrt{17}$ vs $5 \\implies \\sqrt{68}$ vs $\\sqrt{25}$。因此 $C_{1\\mathrm{C}} > C_{2\\mathrm{C}}$。\n比较 $C_{2\\mathrm{C}}$ 和 $C_{3\\mathrm{C}}$：$5 - \\sqrt{17}$ vs $5 \\implies -\\sqrt{17}$ vs $0$。因此 $C_{3\\mathrm{C}} > C_{2\\mathrm{C}}$。\n最小值为 $C_{2\\mathrm{C}}$。\n$$\n\\Delta = \\frac{5 - \\sqrt{17}}{10}\n$$",
            "answer": "$$\n\\boxed{\\frac{5 - \\sqrt{17}}{10}}\n$$"
        },
        {
            "introduction": "高度非线性项（例如化学反应速率）的封闭是湍流燃烧模拟中误差的主要来源。本练习提供了一种具体的方法，通过应用二阶矩展开来量化这种封闭误差。通过计算真实滤波速率与在滤波平均值下计算的速率之间的差异，您将更深入地理解亚格子尺度脉动对系统宏观行为的影响 。",
            "id": "4037717",
            "problem": "给定一个反应混合物的微观动力学机理，它将一个反应进度变量源项速率定义为两个基元反应速率之和。考虑用 $\\tilde{\\dot{\\omega}}_c$ 表示的大涡模拟 (LES) 滤波后的反应进度变量源项。由于非线性和亚格子协方差的存在，滤波后的源项 $\\tilde{\\dot{\\omega}}_c$ 通常不等于在滤波平均值处计算的源项，从而产生了封闭问题。您的任务是通过在滤波平均值处计算源项来计算建模的滤波源项，并通过二阶矩展开来量化由非线性和协方差引起的模型误差。\n\n使用的基本原理：\n- 在大涡模拟 (LES) 中的滤波输运方程包含一个源项 $\\tilde{\\dot{\\omega}}_c$，它是微观源项 $\\dot{\\omega}_c(\\mathbf{Y},T)$ 的滤波结果，其中 $\\mathbf{Y}$ 表示组分质量分数，$T$ 表示温度。\n- 在小涨落条件下，一个非线性函数的期望值可以进行二阶泰勒展开：对于一个足够光滑的函数 $f$，随机向量 $\\mathbf{X}$ 的均值为 $\\boldsymbol{\\mu}$，协方差为 $\\boldsymbol{\\Sigma}$，则 $\\mathbb{E}[f(\\mathbf{X})] \\approx f(\\boldsymbol{\\mu}) + \\frac{1}{2}\\,\\mathrm{tr}\\left(\\mathbf{H}_f(\\boldsymbol{\\mu})\\,\\boldsymbol{\\Sigma}\\right)$，其中 $\\mathbf{H}_f$ 是 $f$ 关于其输入的二阶导数的海森矩阵。\n\n机理定义：\n- 设反应系统包含的组分质量分数为 $\\mathbf{Y} = (Y_F, Y_{O_2}, Y_R)$，分别代表燃料、氧化剂和一种中间自由基，以及温度 $T$（单位：开尔文）。\n- 两个基元反应对进度变量源项有贡献：\n  1. 反应 1: $F + O_2 \\rightarrow P + R$，速率为\n     $$r_1(Y_F, Y_{O_2}, T) = A_1\\,Y_F^{a_1}\\,Y_{O_2}^{b_1}\\,\\exp\\!\\left(-\\frac{E_1}{R_u\\,T}\\right),$$\n  2. 反应 2: $R + O_2 \\rightarrow P$，速率为\n     $$r_2(Y_R, Y_{O_2}, T) = A_2\\,Y_R^{a_2}\\,Y_{O_2}^{b_2}\\,\\exp\\!\\left(-\\frac{E_2}{R_u\\,T}\\right),$$\n  其中 $A_1$ 和 $A_2$ 是指前因子，单位为 $\\mathrm{s}^{-1}$；$a_1$、$a_2$、$b_1$、$b_2$ 是反应级数（无量纲）；$E_1$ 和 $E_2$ 是活化能，单位为 $\\mathrm{J/mol}$；$R_u$ 是通用气体常数，$R_u = 8.314\\,\\mathrm{J/(mol\\,K)}$。\n- 将微观进度变量源项速率定义为\n  $$\\dot{\\omega}_c(\\mathbf{Y},T) = r_1(Y_F, Y_{O_2}, T) + r_2(Y_R, Y_{O_2}, T)。$$\n\n待评估的封闭定义：\n- 建模的滤波源项（使用平均值的朴素封闭）：\n  $$\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{model}} = \\dot{\\omega}_c\\!\\left(\\tilde{\\mathbf{Y}}, \\tilde{T}\\right) = \\dot{\\omega}_c\\!\\left(\\boldsymbol{\\mu}_{\\mathbf{Y}}, \\mu_T\\right),$$\n  其中 $(\\boldsymbol{\\mu}_{\\mathbf{Y}}, \\mu_T)$ 是 $(\\mathbf{Y},T)$ 的滤波平均值。\n- 真实滤波源项的二阶近似：\n  $$\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{approx}} \\approx \\dot{\\omega}_c(\\boldsymbol{\\mu}_{\\mathbf{Y}}, \\mu_T) + \\frac{1}{2}\\,\\mathrm{tr}\\!\\left(\\mathbf{H}_{\\dot{\\omega}_c}(\\boldsymbol{\\mu}_{\\mathbf{Y}},\\mu_T)\\,\\boldsymbol{\\Sigma}\\right),$$\n  其中 $\\boldsymbol{\\Sigma}$ 是 $(Y_F, Y_{O_2}, Y_R, T)$ 的协方差矩阵，$\\mathbf{H}_{\\dot{\\omega}_c}$ 是 $\\dot{\\omega}_c$ 关于 $(Y_F, Y_{O_2}, Y_R, T)$ 的海森矩阵。\n\n每个测试用例需计算的输出：\n- 建模的滤波源项 $\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{model}}$，单位为 $\\mathrm{s}^{-1}$。\n- 二阶近似 $\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{approx}}$，单位为 $\\mathrm{s}^{-1}$。\n- 由非线性和协方差引起的相对模型偏差，定义为\n  $$b_{\\mathrm{rel}} = \\frac{\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{approx}} - \\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{model}}}{\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{approx}}},$$\n  以小数形式表示（无单位）。\n\n物理单位：\n- 温度 $T$ 必须使用开尔文。\n- 源项速率必须以 $\\mathrm{s}^{-1}$ 表示。\n\n角度单位：\n- 此问题不涉及角度。\n\n测试套件：\n对于每个测试用例 $i \\in \\{1,2,3,4\\}$，为您提供 $(A_1, E_1, a_1, b_1, A_2, E_2, a_2, b_2)$、滤波平均值 $(\\mu_{Y_F}, \\mu_{Y_{O_2}}, \\mu_{Y_R}, \\mu_T)$ 以及变量排序为 $(Y_F, Y_{O_2}, Y_R, T)$ 的协方差矩阵 $\\boldsymbol{\\Sigma}$。\n\n- 测试用例 1:\n  - 机理参数: $A_1 = 5.0\\times 10^{6}\\,\\mathrm{s}^{-1}$， $E_1 = 1.2\\times 10^{5}\\,\\mathrm{J/mol}$， $a_1 = 1.0$， $b_1 = 1.0$；$A_2 = 2.5\\times 10^{7}\\,\\mathrm{s}^{-1}$， $E_2 = 1.8\\times 10^{5}\\,\\mathrm{J/mol}$， $a_2 = 1.0$，$b_2 = 0.5$。\n  - 平均值: $\\mu_{Y_F} = 0.02$, $\\mu_{Y_{O_2}} = 0.21$, $\\mu_{Y_R} = 0.001$, $\\mu_T = 1500$。\n  - 协方差矩阵:\n    $$\\boldsymbol{\\Sigma} = \\begin{bmatrix}\n    1.0\\times 10^{-6} & -5.0\\times 10^{-7} & 1.0\\times 10^{-8} & 5.0\\times 10^{-2} \\\\\n    -5.0\\times 10^{-7} & 2.0\\times 10^{-6} & -3.0\\times 10^{-8} & -1.0\\times 10^{-1} \\\\\n    1.0\\times 10^{-8} & -3.0\\times 10^{-8} & 5.0\\times 10^{-8} & 0.0 \\\\\n    5.0\\times 10^{-2} & -1.0\\times 10^{-1} & 0.0 & 4.0\\times 10^{2}\n    \\end{bmatrix}.$$\n\n- 测试用例 2:\n  - 机理参数: $A_1 = 4.0\\times 10^{6}\\,\\mathrm{s}^{-1}$， $E_1 = 1.0\\times 10^{5}\\,\\mathrm{J/mol}$， $a_1 = 1.0$，$b_1 = 1.0$；$A_2 = 1.5\\times 10^{7}\\,\\mathrm{s}^{-1}$， $E_2 = 1.6\\times 10^{5}\\,\\mathrm{J/mol}$， $a_2 = 1.0$，$b_2 = 0.7$。\n  - 平均值: $\\mu_{Y_F} = 0.001$, $\\mu_{Y_{O_2}} = 0.23$, $\\mu_{Y_R} = 0.0005$, $\\mu_T = 1200$。\n  - 协方差矩阵:\n    $$\\boldsymbol{\\Sigma} = \\begin{bmatrix}\n    1.0\\times 10^{-8} & -2.0\\times 10^{-8} & 0.0 & 1.0\\times 10^{-2} \\\\\n    -2.0\\times 10^{-8} & 1.5\\times 10^{-6} & -1.0\\times 10^{-8} & -2.0\\times 10^{-2} \\\\\n    0.0 & -1.0\\times 10^{-8} & 1.0\\times 10^{-8} & 0.0 \\\\\n    1.0\\times 10^{-2} & -2.0\\times 10^{-2} & 0.0 & 2.25\\times 10^{2}\n    \\end{bmatrix}.$$\n\n- 测试用例 3:\n  - 机理参数: $A_1 = 6.0\\times 10^{6}\\,\\mathrm{s}^{-1}$， $E_1 = 1.4\\times 10^{5}\\,\\mathrm{J/mol}$， $a_1 = 1.0$，$b_1 = 1.2$；$A_2 = 3.0\\times 10^{7}\\,\\mathrm{s}^{-1}$， $E_2 = 2.0\\times 10^{5}\\,\\mathrm{J/mol}$， $a_2 = 1.0$，$b_2 = 0.6$。\n  - 平均值: $\\mu_{Y_F} = 0.015$, $\\mu_{Y_{O_2}} = 0.20$, $\\mu_{Y_R} = 0.002$, $\\mu_T = 2000$。\n  - 协方差矩阵:\n    $$\\boldsymbol{\\Sigma} = \\begin{bmatrix}\n    5.0\\times 10^{-7} & -3.0\\times 10^{-7} & 3.0\\times 10^{-8} & 1.0\\times 10^{-1} \\\\\n    -3.0\\times 10^{-7} & 2.0\\times 10^{-6} & -1.0\\times 10^{-7} & -1.5\\times 10^{-1} \\\\\n    3.0\\times 10^{-8} & -1.0\\times 10^{-7} & 2.0\\times 10^{-7} & 2.0\\times 10^{-1} \\\\\n    1.0\\times 10^{-1} & -1.5\\times 10^{-1} & 2.0\\times 10^{-1} & 9.0\\times 10^{2}\n    \\end{bmatrix}.$$\n\n- 测试用例 4:\n  - 机理参数: $A_1 = 3.0\\times 10^{6}\\,\\mathrm{s}^{-1}$， $E_1 = 0.9\\times 10^{5}\\,\\mathrm{J/mol}$， $a_1 = 1.0$，$b_1 = 1.0$；$A_2 = 2.2\\times 10^{7}\\,\\mathrm{s}^{-1}$， $E_2 = 1.7\\times 10^{5}\\,\\mathrm{J/mol}$， $a_2 = 1.0$，$b_2 = 0.5$。\n  - 平均值: $\\mu_{Y_F} = 1.0\\times 10^{-5}$, $\\mu_{Y_{O_2}} = 0.25$, $\\mu_{Y_R} = 1.0\\times 10^{-6}$, $\\mu_T = 1400$。\n  - 协方差矩阵:\n    $$\\boldsymbol{\\Sigma} = \\begin{bmatrix}\n    1.0\\times 10^{-7} & -1.0\\times 10^{-7} & 5.0\\times 10^{-9} & 2.0\\times 10^{-2} \\\\\n    -1.0\\times 10^{-7} & 1.0\\times 10^{-6} & -2.0\\times 10^{-8} & -3.0\\times 10^{-2} \\\\\n    5.0\\times 10^{-9} & -2.0\\times 10^{-8} & 1.0\\times 10^{-8} & 0.0 \\\\\n    2.0\\times 10^{-2} & -3.0\\times 10^{-2} & 0.0 & 4.0\\times 10^{2}\n    \\end{bmatrix}.$$\n\n要求的最终输出格式：\n- 您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表。\n- 对于四个测试用例，按以下顺序输出十二个值：\n  $$[\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{model}}(1),\\,\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{approx}}(1),\\,b_{\\mathrm{rel}}(1),\\,\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{model}}(2),\\,\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{approx}}(2),\\,b_{\\mathrm{rel}}(2),\\,\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{model}}(3),\\,\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{approx}}(3),\\,b_{\\mathrm{rel}}(3),\\,\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{model}}(4),\\,\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{approx}}(4),\\,b_{\\mathrm{rel}}(4)],$$\n  其中每个 $\\tilde{\\dot{\\omega}}_c$ 的单位为 $\\mathrm{s}^{-1}$，每个 $b_{\\mathrm{rel}}$ 是一个小数（无单位）。",
            "solution": "本任务是评估一个用于反应流大涡模拟(LES)中滤波后反应进度变量源项的简单封闭模型，并使用二阶矩展开来量化其误差。该问题定义明确，科学上基于化学动力学和湍流模型的基本原理，并且解决问题所需的所有参数和数据均已提供。我将逐步进行推导和计算。\n\n系统的状态由一组变量 $\\mathbf{x}$ 及其对应的滤波平均值 $\\boldsymbol{\\mu}$ 描述。这些变量是燃料（$Y_F$）、氧化剂（$Y_{O_2}$）、一种自由基组分（$Y_R$）的质量分数，以及温度（$T$）。我们将状态向量定义为 $\\mathbf{x} = (x_1, x_2, x_3, x_4)^T = (Y_F, Y_{O_2}, Y_R, T)^T$，其平均值定义为 $\\boldsymbol{\\mu} = (\\mu_1, \\mu_2, \\mu_3, \\mu_4)^T = (\\tilde{Y}_F, \\tilde{Y}_{O_2}, \\tilde{Y}_R, \\tilde{T})^T$。\n\n进度变量的微观源项速率 $\\dot{\\omega}_c$ 由两个阿伦尼乌斯型反应速率 $r_1$ 和 $r_2$ 之和给出：\n$$\n\\dot{\\omega}_c(\\mathbf{x}) = r_1(x_1, x_2, x_4) + r_2(x_3, x_2, x_4)\n$$\n其中\n$$\nr_1(x_1, x_2, x_4) = A_1\\,x_1^{a_1}\\,x_2^{b_1}\\,\\exp\\!\\left(-\\frac{E_1}{R_u\\,x_4}\\right)\n$$\n$$\nr_2(x_3, x_2, x_4) = A_2\\,x_3^{a_2}\\,x_2^{b_2}\\,\\exp\\!\\left(-\\frac{E_2}{R_u\\,x_4}\\right)\n$$\n通用气体常数为 $R_u = 8.314\\,\\mathrm{J/(mol\\,K)}$。\n\n首先，我们计算建模的滤波源项 $\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{model}}$，即在状态变量的滤波平均值处计算的源项速率：\n$$\n\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{model}} = \\dot{\\omega}_c(\\boldsymbol{\\mu}) = r_1(\\mu_1, \\mu_2, \\mu_4) + r_2(\\mu_3, \\mu_2, \\mu_4)\n$$\n\n接下来，我们寻求真实滤波源项 $\\tilde{\\dot{\\omega}}_c = \\widetilde{\\dot{\\omega}_c(\\mathbf{x})}$ 的一个更精确的近似，方法是围绕平均值进行二阶泰勒展开。这考虑了亚格子涨落（协方差）和源项函数非线性的影响：\n$$\n\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{approx}} = \\dot{\\omega}_c(\\boldsymbol{\\mu}) + \\frac{1}{2}\\,\\mathrm{tr}\\!\\left(\\mathbf{H}_{\\dot{\\omega}_c}(\\boldsymbol{\\mu})\\,\\boldsymbol{\\Sigma}\\right)\n$$\n这里，$\\boldsymbol{\\Sigma}$ 是状态变量的 $4 \\times 4$ 协方差矩阵，每个测试用例均有提供。$\\mathbf{H}_{\\dot{\\omega}_c}(\\boldsymbol{\\mu})$ 是源函数 $\\dot{\\omega}_c$ 在平均值 $\\boldsymbol{\\mu}$ 处计算的海森矩阵。海森矩阵是一个对称的二阶偏导数矩阵，$H_{ij} = \\frac{\\partial^2 \\dot{\\omega}_c}{\\partial x_i \\partial x_j}$。\n\n由非线性和协方差引起的修正项是 $\\Delta = \\frac{1}{2}\\,\\mathrm{tr}(\\mathbf{H}_{\\dot{\\omega}_c}\\,\\boldsymbol{\\Sigma})$。迹运算由 $\\mathrm{tr}(\\mathbf{A}\\mathbf{B}) = \\sum_i \\sum_j A_{ij} B_{ji}$ 给出。由于协方差矩阵 $\\boldsymbol{\\Sigma}$ 是对称的（$\\Sigma_{ji} = \\Sigma_{ij}$），这简化为元素乘积之和：$\\mathrm{tr}(\\mathbf{H}_{\\dot{\\omega}_c}\\,\\boldsymbol{\\Sigma}) = \\sum_{i,j} H_{ij} \\Sigma_{ij}$。\n\n为了计算该修正项，我们必须首先推导海森矩阵 $\\mathbf{H}_{\\dot{\\omega}_c} = \\mathbf{H}_{r_1} + \\mathbf{H}_{r_2}$ 的分量。以下推导假设所有平均质量分数和温度均为正值，这在物理上是一致的，并且对所有测试用例都成立。设所有函数和导数都在 $\\boldsymbol{\\mu}$ 处求值。\n\n$r_1$ 的二阶偏导数为：\n$$ \\frac{\\partial^2 r_1}{\\partial x_1^2} = r_1 \\frac{a_1(a_1-1)}{x_1^2} \\quad , \\quad \\frac{\\partial^2 r_1}{\\partial x_2^2} = r_1 \\frac{b_1(b_1-1)}{x_2^2} \\quad , \\quad \\frac{\\partial^2 r_1}{\\partial x_4^2} = r_1 \\frac{E_1}{R_u x_4^3} \\left(\\frac{E_1}{R_u x_4} - 2\\right) $$\n$$ \\frac{\\partial^2 r_1}{\\partial x_1 \\partial x_2} = r_1 \\frac{a_1 b_1}{x_1 x_2} \\quad , \\quad \\frac{\\partial^2 r_1}{\\partial x_1 \\partial x_4} = r_1 \\frac{a_1 E_1}{x_1 R_u x_4^2} \\quad , \\quad \\frac{\\partial^2 r_1}{\\partial x_2 \\partial x_4} = r_1 \\frac{b_1 E_1}{x_2 R_u x_4^2} $$\n$r_1$ 关于 $x_3$ (即 $Y_R$) 的所有导数均为零。\n\n$r_2$ 的二阶偏导数类似：\n$$ \\frac{\\partial^2 r_2}{\\partial x_3^2} = r_2 \\frac{a_2(a_2-1)}{x_3^2} \\quad , \\quad \\frac{\\partial^2 r_2}{\\partial x_2^2} = r_2 \\frac{b_2(b_2-1)}{x_2^2} \\quad , \\quad \\frac{\\partial^2 r_2}{\\partial x_4^2} = r_2 \\frac{E_2}{R_u x_4^3} \\left(\\frac{E_2}{R_u x_4} - 2\\right) $$\n$$ \\frac{\\partial^2 r_2}{\\partial x_2 \\partial x_3} = r_2 \\frac{a_2 b_2}{x_2 x_3} \\quad , \\quad \\frac{\\partial^2 r_2}{\\partial x_3 \\partial x_4} = r_2 \\frac{a_2 E_2}{x_3 R_u x_4^2} \\quad , \\quad \\frac{\\partial^2 r_2}{\\partial x_2 \\partial x_4} = r_2 \\frac{b_2 E_2}{x_2 R_u x_4^2} $$\n$r_2$ 关于 $x_1$ (即 $Y_F$) 的所有导数均为零。\n\n总海森矩阵 $\\mathbf{H}_{\\dot{\\omega}_c}$ 的分量是 $\\mathbf{H}_{r_1}$ 和 $\\mathbf{H}_{r_2}$ 对应分量的和。例如，$H_{22} = \\frac{\\partial^2 r_1}{\\partial x_2^2} + \\frac{\\partial^2 r_2}{\\partial x_2^2}$，而 $H_{11} = \\frac{\\partial^2 r_1}{\\partial x_1^2}$ 因为 $r_2$ 不依赖于 $x_1$。\n\n海森矩阵 $H_{ij}$ 的非零分量为：\n- $H_{11} = r_1 \\frac{a_1(a_1-1)}{x_1^2}$\n- $H_{22} = r_1 \\frac{b_1(b_1-1)}{x_2^2} + r_2 \\frac{b_2(b_2-1)}{x_2^2}$\n- $H_{33} = r_2 \\frac{a_2(a_2-1)}{x_3^2}$\n- $H_{44} = r_1 \\frac{E_1}{R_u x_4^3}\\left(\\frac{E_1}{R_u x_4}-2\\right) + r_2 \\frac{E_2}{R_u x_4^3}\\left(\\frac{E_2}{R_u x_4}-2\\right)$\n- $H_{12} = r_1 \\frac{a_1 b_1}{x_1 x_2}$\n- $H_{13} = 0$\n- $H_{14} = r_1 \\frac{a_1 E_1}{x_1 R_u x_4^2}$\n- $H_{23} = r_2 \\frac{a_2 b_2}{x_2 x_3}$\n- $H_{24} = r_1 \\frac{b_1 E_1}{x_2 R_u x_4^2} + r_2 \\frac{b_2 E_2}{x_2 R_u x_4^2}$\n- $H_{34} = r_2 \\frac{a_2 E_2}{x_3 R_u x_4^2}$\n\n计算出海森矩阵后，我们得到二阶近似：\n$$\n\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{approx}} = \\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{model}} + \\frac{1}{2}\\sum_{i=1}^4 \\sum_{j=1}^4 H_{ij} \\Sigma_{ij}\n$$\n\n最后，相对模型偏差 $b_{\\mathrm{rel}}$ 量化了朴素封闭模型相对于二阶近似的误差。其定义为：\n$$\nb_{\\mathrm{rel}} = \\frac{\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{approx}} - \\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{model}}}{\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{approx}}} = \\frac{\\Delta}{\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{approx}}}\n$$\n此过程将应用于每个测试用例，以计算所需的三元组值：$(\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{model}}, \\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{approx}}, b_{\\mathrm{rel}})$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the final result.\n    \"\"\"\n    # Universal Gas Constant in J/(mol K)\n    Ru = 8.314\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"mech_params\": (5.0e6, 1.2e5, 1.0, 1.0, 2.5e7, 1.8e5, 1.0, 0.5), # A1, E1, a1, b1, A2, E2, a2, b2\n            \"means\": (0.02, 0.21, 0.001, 1500), # mu_YF, mu_YO2, mu_YR, mu_T\n            \"Sigma\": np.array([\n                [1.0e-6, -5.0e-7, 1.0e-8, 5.0e-2],\n                [-5.0e-7, 2.0e-6, -3.0e-8, -1.0e-1],\n                [1.0e-8, -3.0e-8, 5.0e-8, 0.0],\n                [5.0e-2, -1.0e-1, 0.0, 4.0e2]\n            ])\n        },\n        {\n            \"mech_params\": (4.0e6, 1.0e5, 1.0, 1.0, 1.5e7, 1.6e5, 1.0, 0.7),\n            \"means\": (0.001, 0.23, 0.0005, 1200),\n            \"Sigma\": np.array([\n                [1.0e-8, -2.0e-8, 0.0, 1.0e-2],\n                [-2.0e-8, 1.5e-6, -1.0e-8, -2.0e-2],\n                [0.0, -1.0e-8, 1.0e-8, 0.0],\n                [1.0e-2, -2.0e-2, 0.0, 2.25e2]\n            ])\n        },\n        {\n            \"mech_params\": (6.0e6, 1.4e5, 1.0, 1.2, 3.0e7, 2.0e5, 1.0, 0.6),\n            \"means\": (0.015, 0.20, 0.002, 2000),\n            \"Sigma\": np.array([\n                [5.0e-7, -3.0e-7, 3.0e-8, 1.0e-1],\n                [-3.0e-7, 2.0e-6, -1.0e-7, -1.5e-1],\n                [3.0e-8, -1.0e-7, 2.0e-7, 2.0e-1],\n                [1.0e-1, -1.5e-1, 2.0e-1, 9.0e2]\n            ])\n        },\n        {\n            \"mech_params\": (3.0e6, 0.9e5, 1.0, 1.0, 2.2e7, 1.7e5, 1.0, 0.5),\n            \"means\": (1.0e-5, 0.25, 1.0e-6, 1400),\n            \"Sigma\": np.array([\n                [1.0e-7, -1.0e-7, 5.0e-9, 2.0e-2],\n                [-1.0e-7, 1.0e-6, -2.0e-8, -3.0e-2],\n                [5.0e-9, -2.0e-8, 1.0e-8, 0.0],\n                [2.0e-2, -3.0e-2, 0.0, 4.0e2]\n            ])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack data for the current case\n        A1, E1, a1, b1, A2, E2, a2, b2 = case[\"mech_params\"]\n        mu_YF, mu_YO2, mu_YR, mu_T = case[\"means\"]\n        Sigma = case[\"Sigma\"]\n        \n        # State vector of means: YF, YO2, YR, T\n        x = np.array([mu_YF, mu_YO2, mu_YR, mu_T])\n\n        # Step 1: Compute modeled source rate at mean values\n        exp_term1 = np.exp(-E1 / (Ru * x[3]))\n        r1_mean = A1 * (x[0]**a1) * (x[1]**b1) * exp_term1\n        \n        exp_term2 = np.exp(-E2 / (Ru * x[3]))\n        r2_mean = A2 * (x[2]**a2) * (x[1]**b2) * exp_term2\n\n        omega_model = r1_mean + r2_mean\n\n        # Step 2: Compute the Hessian matrix H\n        H = np.zeros((4, 4))\n        \n        # Diagonal components\n        H[0, 0] = r1_mean * a1 * (a1 - 1) / x[0]**2 if x[0] > 0 else 0\n        H[1, 1] = r1_mean * b1 * (b1 - 1) / x[1]**2 + r2_mean * b2 * (b2 - 1) / x[1]**2\n        H[2, 2] = r2_mean * a2 * (a2 - 1) / x[2]**2 if x[2] > 0 else 0\n        \n        term_T_r1 = r1_mean * (E1 / (Ru * x[3]**2))**2 - r1_mean * 2 * E1 / (Ru * x[3]**3)\n        term_T_r2 = r2_mean * (E2 / (Ru * x[3]**2))**2 - r2_mean * 2 * E2 / (Ru * x[3]**3)\n        H[3, 3] = term_T_r1 + term_T_r2\n\n        # Off-diagonal components\n        H[0, 1] = r1_mean * a1 * b1 / (x[0] * x[1]) if x[0] > 0 else 0\n        # H[0, 2] is 0\n        H[0, 3] = r1_mean * a1 * E1 / (x[0] * Ru * x[3]**2) if x[0] > 0 else 0\n        \n        H[1, 2] = r2_mean * a2 * b2 / (x[1] * x[2]) if x[2] > 0 else 0\n        H[1, 3] = r1_mean * b1 * E1 / (x[1] * Ru * x[3]**2) + r2_mean * b2 * E2 / (x[1] * Ru * x[3]**2)\n        \n        H[2, 3] = r2_mean * a2 * E2 / (x[2] * Ru * x[3]**2) if x[2] > 0 else 0\n\n        # Symmetrize the Hessian\n        H[1, 0] = H[0, 1]\n        H[2, 0] = H[0, 2]\n        H[3, 0] = H[0, 3]\n        H[2, 1] = H[1, 2]\n        H[3, 1] = H[1, 3]\n        H[3, 2] = H[2, 3]\n        \n        # Step 3: Compute the correction term and the approximate source rate\n        # tr(H * Sigma) simplifies to sum of element-wise product because Sigma is symmetric\n        correction = 0.5 * np.sum(H * Sigma)\n        omega_approx = omega_model + correction\n        \n        # Step 4: Compute the relative modeling bias\n        if omega_approx == 0:\n            # This case is unlikely; the bias would be undefined or infinite.\n            # For this problem, assume omega_approx is non-zero.\n            b_rel = 0.0 if correction == 0 else np.nan\n        else:\n            b_rel = correction / omega_approx\n            \n        results.extend([omega_model, omega_approx, b_rel])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.7g}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}