{
    "hands_on_practices": [
        {
            "introduction": "To effectively apply adaptive mesh refinement (AMR), we must first translate the physical concepts of a \"flame front\" and \"reaction zone\" into concrete, computable metrics. This foundational exercise focuses on this translation for a one-dimensional flame. You will implement standard definitions to localize the flame front using a temperature-based progress variable and to quantify the reaction zone thickness from the heat release rate profile, providing a first essential step in identifying where grid resolution is most needed.",
            "id": "4057465",
            "problem": "You are given smooth one-dimensional fields representing a premixed laminar flame: temperature $T(x)$ in kelvin and a single-step mass reaction rate per unit volume $\\dot{\\omega}(x)$ in $\\mathrm{kg\\,m^{-3}\\,s^{-1}}$, both defined on a bounded spatial interval with uniform grid. Using accepted definitions from computational combustion, implement a program that, for each provided test case, computes two refinement metrics associated with a flame front and reaction zone: (i) the flame front location $x_f$ defined by a temperature-based progress variable at $c=0.5$, and (ii) the reaction zone thickness $\\Delta_R$ defined as the full-width at half-maximum (FWHM) of the magnitude of the volumetric heat release rate $\\lvert \\dot{q}(x) \\rvert$. All outputs must be expressed in meters as decimal floats.\n\nFundamental bases and definitions to use:\n\n- The temperature-based progress variable is normalized as $c(x) = \\dfrac{T(x) - T_u}{T_b - T_u}$, where $T_u$ and $T_b$ are the unburned and burned temperatures, respectively. For the purpose of this problem, define $T_u = \\min_{x} T(x)$ and $T_b = \\max_{x} T(x)$ over the given domain.\n\n- The flame front location $x_f$ is the unique $x$ such that $c(x_f) = 0.5$. In discrete data, determine $x_f$ by linear interpolation between the two grid points that straddle $c=0.5$.\n\n- The volumetric heat release rate for a single-step global reaction is modeled as $\\dot{q}(x) = Q\\,\\dot{\\omega}(x)$, where $Q$ is the heat of reaction per unit mass. Use $Q = 5.0 \\times 10^{7}\\,\\mathrm{J\\,kg^{-1}}$. Compute the magnitude $\\lvert \\dot{q}(x) \\rvert$ and identify the dominant peak nearest to $x_f$. Define the reaction zone thickness $\\Delta_R$ as the FWHM around that peak: i.e., the distance between the two positions on either side of the peak where $\\lvert \\dot{q}(x) \\rvert$ equals half of the peak value, computed via linear interpolation on the discrete grid.\n\nAlgorithmic requirements:\n\n- Interpolate linearly for both $x_f$ and the half-maximum crossing points that define $\\Delta_R$.\n\n- If multiple local maxima of $\\lvert \\dot{q}(x) \\rvert$ exist, choose the one with minimal absolute distance to $x_f$.\n\n- Ensure scientific realism by working on smooth profiles; the provided test cases satisfy monotonic $T(x)$ trends and localized reaction zones.\n\nUnits and output format:\n\n- Express $x_f$ and $\\Delta_R$ in meters as decimal floats.\n\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list of lists enclosed in square brackets, with each inner list containing $[x_f,\\Delta_R]$ for one test case. For example: $[\\,[x_{f,1},\\Delta_{R,1}],\\,[x_{f,2},\\Delta_{R,2}]\\,]$. Format all floats with six digits after the decimal point.\n\nTest suite:\n\nFor each test case, construct a uniform grid $x$ and define $T(x)$ and $\\dot{\\omega}(x)$ as follows. All parameters are in standard units with $x$ in meters.\n\n- Test case $1$ (happy path, single Gaussian reaction zone):\n  - Domain: $x \\in [-5\\times 10^{-3},\\,5\\times 10^{-3}]$ with $N=2001$ points.\n  - Temperature: $T_u = 300$, $T_b = 2200$, $L_T = 5.0\\times 10^{-4}$, $T(x) = T_u + (T_b - T_u)\\,\\dfrac{1}{2}\\left(1 + \\tanh\\left(\\dfrac{x}{L_T}\\right)\\right)$.\n  - Reaction rate: amplitude $A = 1.2$, center $x_0 = 0$, width $\\sigma = 2.5\\times 10^{-4}$, $\\dot{\\omega}(x) = A \\exp\\!\\left(-\\dfrac{(x - x_0)^2}{2\\sigma^2}\\right)$.\n\n- Test case $2$ (two peaks, select peak nearest to front):\n  - Domain: $x \\in [-6\\times 10^{-3},\\,6\\times 10^{-3}]$ with $N=2401$ points.\n  - Temperature: $T_u = 300$, $T_b = 2200$, $L_T = 6.0\\times 10^{-4}$, offset $x_f^{(0)} = -1.0\\times 10^{-3}$,\n    $T(x) = T_u + (T_b - T_u)\\,\\dfrac{1}{2}\\left(1 + \\tanh\\left(\\dfrac{x - x_f^{(0)}}{L_T}\\right)\\right)$.\n  - Reaction rate: two Gaussians with $A_1 = 0.8$, $x_1 = -1.0\\times 10^{-3}$, $\\sigma_1 = 2.0\\times 10^{-4}$, and $A_2 = 0.5$, $x_2 = 1.5\\times 10^{-3}$, $\\sigma_2 = 3.5\\times 10^{-4}$,\n    $\\dot{\\omega}(x) = A_1 \\exp\\!\\left(-\\dfrac{(x - x_1)^2}{2\\sigma_1^2}\\right) + A_2 \\exp\\!\\left(-\\dfrac{(x - x_2)^2}{2\\sigma_2^2}\\right)$.\n\n- Test case $3$ (non-Gaussian, compact parabolic reaction zone):\n  - Domain: $x \\in [-3\\times 10^{-3},\\,3\\times 10^{-3}]$ with $N=1201$ points.\n  - Temperature: $T_u = 300$, $T_b = 2200$, $L_T = 3.0\\times 10^{-4}$, $T(x) = T_u + (T_b - T_u)\\,\\dfrac{1}{2}\\left(1 + \\tanh\\left(\\dfrac{x}{L_T}\\right)\\right)$.\n  - Reaction rate: amplitude $A = 0.6$, center $x_0 = 5.0\\times 10^{-4}$, half-width parameter $\\sigma = 6.0\\times 10^{-4}$,\n    $\\dot{\\omega}(x) = \\max\\!\\left\\{0,\\;A\\left(1 - \\left(\\dfrac{x - x_0}{\\sigma}\\right)^2\\right)\\right\\}$.\n\nYour program must compute, for each test case, the pair $[x_f,\\Delta_R]$ and produce a single line of output containing the list of these pairs, in meters, each float formatted with six digits after the decimal point, as in $[[x_{f,1},\\Delta_{R,1}],[x_{f,2},\\Delta_{R,2}],[x_{f,3},\\Delta_{R,3}]]$.",
            "solution": "The user-provided problem statement has been analyzed and is deemed valid. It is scientifically grounded in the principles of computational combustion, well-posed with clear definitions and constraints, and objective in its formulation. All necessary data for a unique and verifiable solution are provided.\n\nThe task is to compute two metrics for a one-dimensional laminar flame profile: the flame front location $x_f$ and the reaction zone thickness $\\Delta_R$. The solution for each test case proceeds in two main stages.\n\n### Stage 1: Determination of the Flame Front Location ($x_f$)\n\nThe flame front location is defined based on the progress of the reaction, which is quantified by a normalized temperature field.\n\n**1.1. Progress Variable Definition**\nThe temperature-based progress variable, $c(x)$, is defined as:\n$$c(x) = \\frac{T(x) - T_u}{T_b - T_u}$$\nwhere $T(x)$ is the temperature field. The unburned temperature, $T_u$, and the burned temperature, $T_b$, are defined as the global minimum and maximum of the temperature profile over the spatial domain, respectively:\n$$T_u = \\min_{x} T(x)$$\n$$T_b = \\max_{x} T(x)$$\nBy this definition, the progress variable is bounded, $c(x) \\in [0, 1]$.\n\n**1.2. Flame Front Location ($x_f$)**\nThe flame front, $x_f$, is defined as the unique spatial coordinate where the progress variable is equal to $0.5$:\n$$c(x_f) = 0.5$$\nGiven that the data are provided on a discrete, uniform grid $x_i$, the location $x_f$ is determined via linear interpolation. First, we identify two adjacent grid points, $x_i$ and $x_{i+1}$, that straddle the value $c = 0.5$. That is, we find an index $i$ such that $c(x_i) \\le 0.5  c(x_{i+1})$ or $c(x_i) \\ge 0.5 > c(x_{i+1})$. For the monotonically increasing temperature profiles provided, the former case applies.\n\nThe linear interpolation formula to find $x_f$ is:\n$$x_f = x_i + (x_{i+1} - x_i) \\frac{0.5 - c(x_i)}{c(x_{i+1}) - c(x_i)}$$\n\n### Stage 2: Determination of the Reaction Zone Thickness ($\\Delta_R$)\n\nThe reaction zone thickness is defined as the full-width at half-maximum (FWHM) of the magnitude of the volumetric heat release rate, centered around the dominant peak.\n\n**2.1. Volumetric Heat Release Rate**\nThe volumetric heat release rate, $\\dot{q}(x)$, is given by:\n$$\\dot{q}(x) = Q \\cdot \\dot{\\omega}(x)$$\nwhere $\\dot{\\omega}(x)$ is the mass reaction rate per unit volume and $Q$ is the heat of reaction per unit mass, provided as $Q = 5.0 \\times 10^7 \\, \\mathrm{J\\,kg^{-1}}$. The analysis is performed on the magnitude of this quantity, $|\\dot{q}(x)|$. Since the provided reaction rate profiles $\\dot{\\omega}(x)$ are non-negative, $|\\dot{q}(x)| = \\dot{q}(x)$.\n\n**2.2. Peak Identification and Selection**\nThe profile $|\\dot{q}(x)|$ may have one or more local maxima. We must identify all such peaks in the discrete data. A point $x_j$ is a local maximum if $|\\dot{q}(x_j)| > |\\dot{q}(x_{j-1})|$ and $|\\dot{q}(x_j)| > |\\dot{q}(x_{j+1})|$.\n\nIf multiple peaks exist, the problem specifies selecting the one whose location, $x_{\\text{peak}}$, is closest to the previously determined flame front location, $x_f$. We select the peak that minimizes the distance $|x_{\\text{peak}} - x_f|$.\n\n**2.3. Full-Width at Half-Maximum (FWHM) Calculation**\nLet the value of the selected peak be $|\\dot{q}|_{\\text{max}}$. The half-maximum value is $0.5 \\cdot |\\dot{q}|_{\\text{max}}$. The reaction zone thickness, $\\Delta_R$, is the distance between the two points, $x_L$ and $x_R$, on the left and right sides of the peak, respectively, where the heat release rate equals this half-maximum value.\n$$\\Delta_R = x_R - x_L$$\nwhere $|\\dot{q}(x_L)| = |\\dot{q}(x_R)| = 0.5 \\cdot |\\dot{q}|_{\\text{max}}$.\n\nThese points, $x_L$ and $x_R$, are found by linear interpolation on the discrete grid.\n- To find $x_L$, we search for two adjacent grid points $x_j$ and $x_{j+1}$ to the left of the peak ($x_j, x_{j+1}  x_{\\text{peak}}$) that straddle the half-maximum value. The interpolation is:\n$$x_L = x_j + (x_{j+1} - x_j) \\frac{0.5 |\\dot{q}|_{\\text{max}} - |\\dot{q}(x_j)|}{|\\dot{q}(x_{j+1})| - |\\dot{q}(x_j)|}$$\n- To find $x_R$, we search for two adjacent grid points $x_k$ and $x_{k+1}$ to the right of the peak ($x_k, x_{k+1} > x_{\\text{peak}}$) that satisfy the same condition. The interpolation is:\n$$x_R = x_k + (x_{k+1} - x_k) \\frac{0.5 |\\dot{q}|_{\\text{max}} - |\\dot{q}(x_k)|}{|\\dot{q}(x_{k+1})| - |\\dot{q}(x_k)|}$$\n\nThis systematic procedure is applied to each test case to derive the required metrics.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import find_peaks\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the calculation for all test cases and print the final result.\n    \"\"\"\n    \n    # Heat of reaction per unit mass in J/kg\n    Q = 5.0e7\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"domain\": (-5e-3, 5e-3), \"N\": 2001,\n            \"T_params\": {\"Tu\": 300.0, \"Tb\": 2200.0, \"L_T\": 5.0e-4},\n            \"T_func\": lambda x, p: p[\"Tu\"] + (p[\"Tb\"] - p[\"Tu\"]) * 0.5 * (1 + np.tanh(x / p[\"L_T\"])),\n            \"omega_params\": {\"A\": 1.2, \"x0\": 0.0, \"sigma\": 2.5e-4},\n            \"omega_func\": lambda x, p: p[\"A\"] * np.exp(-(x - p[\"x0\"])**2 / (2 * p[\"sigma\"]**2))\n        },\n        {\n            \"domain\": (-6e-3, 6e-3), \"N\": 2401,\n            \"T_params\": {\"Tu\": 300.0, \"Tb\": 2200.0, \"L_T\": 6.0e-4, \"x_f0\": -1.0e-3},\n            \"T_func\": lambda x, p: p[\"Tu\"] + (p[\"Tb\"] - p[\"Tu\"]) * 0.5 * (1 + np.tanh((x - p[\"x_f0\"]) / p[\"L_T\"])),\n            \"omega_params\": {\"A1\": 0.8, \"x1\": -1.0e-3, \"sigma1\": 2.0e-4, \"A2\": 0.5, \"x2\": 1.5e-3, \"sigma2\": 3.5e-4},\n            \"omega_func\": lambda x, p: (p[\"A1\"] * np.exp(-(x - p[\"x1\"])**2 / (2 * p[\"sigma1\"]**2)) +\n                                       p[\"A2\"] * np.exp(-(x - p[\"x2\"])**2 / (2 * p[\"sigma2\"]**2)))\n        },\n        {\n            \"domain\": (-3e-3, 3e-3), \"N\": 1201,\n            \"T_params\": {\"Tu\": 300.0, \"Tb\": 2200.0, \"L_T\": 3.0e-4},\n            \"T_func\": lambda x, p: p[\"Tu\"] + (p[\"Tb\"] - p[\"Tu\"]) * 0.5 * (1 + np.tanh(x / p[\"L_T\"])),\n            \"omega_params\": {\"A\": 0.6, \"x0\": 5.0e-4, \"sigma\": 6.0e-4},\n            \"omega_func\": lambda x, p: np.maximum(0, p[\"A\"] * (1 - ((x - p[\"x0\"]) / p[\"sigma\"])**2))\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _calculate_metrics(case, Q)\n        results.append(result)\n\n    # Format the final output string.\n    formatted_results = [f\"[{res[0]:.6f},{res[1]:.6f}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef _linear_interpolate(x_target, y_data, x_data):\n    \"\"\"General linear interpolation function.\"\"\"\n    # Find the index where y_target would be inserted in a sorted y_data\n    # This identifies the interval for interpolation.\n    i = np.searchsorted(y_data, x_target)\n    \n    # Handle edge cases where target is outside data range, though not expected here\n    if i == 0 or i == len(y_data):\n        # Fallback to direct search if searchsorted fails due to non-monotonicity\n        # around the target (not expected for c(x)).\n        for k in range(len(y_data) - 1):\n             if (y_data[k] = x_target  y_data[k+1]) or (y_data[k] = x_target  y_data[k+1]):\n                 i = k + 1\n                 break\n        else: # This else belongs to the for-loop\n             return np.nan # Target not found in any interval\n\n    y1, y2 = y_data[i - 1], y_data[i]\n    x1, x2 = x_data[i - 1], x_data[i]\n\n    return x1 + (x2 - x1) * (x_target - y1) / (y2 - y1)\n    \ndef _calculate_metrics(case, Q):\n    \"\"\"\n    Computes [x_f, Delta_R] for a single test case.\n    \"\"\"\n    # 1. Generate grid and profiles\n    x = np.linspace(case[\"domain\"][0], case[\"domain\"][1], case[\"N\"])\n    T = case[\"T_func\"](x, case[\"T_params\"])\n    omega_dot = case[\"omega_func\"](x, case[\"omega_params\"])\n\n    # 2. Calculate flame front location x_f\n    Tu = np.min(T)\n    Tb = np.max(T)\n    c = (T - Tu) / (Tb - Tu)\n    \n    # Find indices straddling c=0.5\n    # np.searchsorted is efficient for monotonic arrays\n    idx = np.searchsorted(c, 0.5)\n    \n    # Perform linear interpolation for x_f\n    c1, c2 = c[idx - 1], c[idx]\n    x1, x2 = x[idx - 1], x[idx]\n    xf = x1 + (x2 - x1) * (0.5 - c1) / (c2 - c1)\n\n    # 3. Calculate heat release rate and find dominant peak\n    q_dot_mag = np.abs(Q * omega_dot)\n    \n    # Find all peaks in the heat release rate profile\n    peak_indices, _ = find_peaks(q_dot_mag)\n    \n    if len(peak_indices) == 0: # Should not happen with given test cases\n        return [xf, np.nan]\n    elif len(peak_indices) == 1:\n        chosen_peak_idx = peak_indices[0]\n    else:\n        # Choose the peak closest to xf\n        peak_locations = x[peak_indices]\n        distances = np.abs(peak_locations - xf)\n        chosen_peak_idx = peak_indices[np.argmin(distances)]\n\n    # 4. Calculate reaction zone thickness Delta_R (FWHM)\n    q_dot_max = q_dot_mag[chosen_peak_idx]\n    half_max = 0.5 * q_dot_max\n\n    # Find left crossing point x_L\n    x_L = 0.0\n    for i in range(chosen_peak_idx, 0, -1):\n        if q_dot_mag[i-1]  half_max = q_dot_mag[i]:\n            y1, y2 = q_dot_mag[i-1], q_dot_mag[i]\n            x_L = x[i-1] + (x[i] - x[i-1]) * (half_max - y1) / (y2 - y1)\n            break\n            \n    # Find right crossing point x_R\n    x_R = 0.0\n    for i in range(chosen_peak_idx, len(q_dot_mag) - 1):\n        if q_dot_mag[i] = half_max  q_dot_mag[i+1]:\n            y1, y2 = q_dot_mag[i], q_dot_mag[i+1]\n            x_R = x[i] + (x[i+1] - x[i]) * (half_max - y1) / (y2 - y1)\n            break\n    \n    delta_R = x_R - x_L\n\n    return [xf, delta_R]\n\nsolve()\n```"
        },
        {
            "introduction": "While resolving flame thickness is crucial, realistic multi-dimensional flames are highly anisotropic structures, meaning they are thin in one direction (normal) but can be extensive in others (tangential). Isotropic refinement is therefore highly inefficient. This practice introduces the powerful concept of anisotropic adaptation, where the mesh is selectively refined based on local flame geometry. You will use the gradient $\\nabla T$ and Hessian matrix $H(T)$ of the temperature field to compute the flame's curvature and orientation, enabling the design of a metric that directs fine resolution normal to the front while permitting coarser cells along it .",
            "id": "4057404",
            "problem": "You are given a two-dimensional temperature field $T(\\mathbf{x})$ defined on a rectangular domain with Cartesian coordinates $\\mathbf{x} = (x,y)$. The field contains a premixed flame front modeled as an isotherm. Your tasks are: compute the Hessian $H(T)$ of the temperature field, estimate the curvature of the flame front from $H(T)$, and design an anisotropic adaptation metric that guarantees $N$ points along the local normal direction and $M$ points along the local tangential direction of the flame front. The adaptation should be specified as direction-dependent spacings $h_n$ and $h_t$ at points on the flame front, and these spacings must be reported in meters.\n\nFundamental base and definitions to use:\n- The temperature field $T(x,y)$ is a smooth scalar function. The gradient is $\\nabla T = (T_x, T_y)$, where $T_x = \\partial T / \\partial x$ and $T_y = \\partial T / \\partial y$. The Hessian $H(T)$ is the $2 \\times 2$ matrix of second derivatives,\n$$\nH(T) = \\begin{bmatrix}\nT_{xx}  T_{xy} \\\\\nT_{yx}  T_{yy}\n\\end{bmatrix},\n$$\nwith $T_{xx} = \\partial^2 T / \\partial x^2$, $T_{yy} = \\partial^2 T / \\partial y^2$, and $T_{xy} = T_{yx} = \\partial^2 T / (\\partial x \\partial y)$.\n- The flame front is defined as the isotherm $T(x,y) = T_f$, where $T_f$ is given. At points on the flame front, define the unit normal $\\mathbf{n} = \\nabla T / \\|\\nabla T\\|$ and a unit tangential vector $\\mathbf{t}$ orthogonal to $\\mathbf{n}$ by $\\mathbf{t} = (-n_y, n_x)$.\n- The curvature $\\kappa$ of a level set $T(x,y) = \\text{constant}$ can be computed from first and second derivatives by\n$$\n\\kappa = \\frac{T_x^2 T_{yy} - 2 T_x T_y T_{xy} + T_y^2 T_{xx}}{\\|\\nabla T\\|^3}.\n$$\n- The local thermal thickness along the normal direction is approximated by\n$$\nL_n = \\frac{\\Delta T}{\\|\\nabla T\\|},\n$$\nwhere $\\Delta T = T_b - T_u$ is the temperature rise from unburnt ($T_u$) to burnt ($T_b$) mixture across the reaction zone.\n- The local tangential length scale is taken to be the local radius of curvature $R = 1/|\\kappa|$, clipped by a maximum tangential scale $L_{\\max}$ to avoid unbounded values when $|\\kappa|$ is near zero. Specifically,\n$$\nL_t = \\min\\left(\\frac{1}{\\max(|\\kappa|,\\kappa_{\\min})}, L_{\\max}\\right),\n$$\nwhere $\\kappa_{\\min}  0$ is a small threshold.\n- To guarantee $N$ points resolved along the normal and $M$ points along the tangential direction, choose spacings\n$$\nh_n = \\frac{L_n}{N}, \\qquad h_t = \\frac{L_t}{M}.\n$$\n- The anisotropic metric tensor $G$ at the flame front can be specified to align with $\\mathbf{n}$ and $\\mathbf{t}$, with eigenvalues $1/h_n^2$ and $1/h_t^2$ along $\\mathbf{n}$ and $\\mathbf{t}$, respectively.\n\nNumerical construction of $T(x,y)$ for each test case:\n- The domain is a rectangle of dimensions $L_x \\times L_y$ in meters, discretized on a uniform grid of $N_x \\times N_y$ points.\n- The temperature field is constructed using a smooth transition across the flame front based on a hyperbolic tangent profile,\n$$\nT(x,y) = T_u + \\Delta T \\cdot \\frac{1}{2}\\left(1 + \\tanh\\left(\\frac{x - x_0(y)}{\\delta}\\right)\\right),\n$$\nwhere $x_0(y)$ is the flame front location modulated in the $y$-direction, and $\\delta$ is the thermal thickness parameter controlling the steepness.\n\nEstimation and output requirements:\n- Compute $T_x, T_y, T_{xx}, T_{yy}, T_{xy}$ using second-order central differences on the uniform grid.\n- Define the flame front isotherm $T_f = (T_u + T_b)/2$. Identify grid points in a narrow band around the front using $|T - T_f| \\le \\epsilon$ with $\\epsilon = 0.01 \\Delta T$.\n- At these band points, compute $\\|\\nabla T\\|$, $H(T)$, $\\kappa$, $L_n$, $L_t$, $h_n$, and $h_t$ using the formulas above.\n- Report the average $h_n$ and average $h_t$ across the band points for each test case. These averages must be expressed in meters as decimal numbers. Do not include unit symbols in the output; only numeric values are allowed in the final printed list.\n\nTest suite:\nProvide results for the following four parameter sets. All quantities are in meters or Kelvins as applicable.\n1. Case $1$: A planar front.\n   - $L_x = 0.02$, $L_y = 0.02$, $N_x = 301$, $N_y = 301$.\n   - $T_u = 300$, $T_b = 2000$, $\\delta = 0.0005$.\n   - $x_0(y) = L_x/2$, i.e., no modulation ($a = 0$, $\\lambda$ unused).\n   - $N = 10$, $M = 20$, $L_{\\max} = 0.01$, $\\kappa_{\\min} = 10^{-6}$.\n\n2. Case $2$: A weakly curved front.\n   - $L_x = 0.02$, $L_y = 0.02$, $N_x = 301$, $N_y = 301$.\n   - $T_u = 300$, $T_b = 2000$, $\\delta = 0.0003$.\n   - $x_0(y) = L_x/2 + a \\sin(2\\pi y/\\lambda)$ with $a = 0.001$ and $\\lambda = L_y$.\n   - $N = 12$, $M = 24$, $L_{\\max} = 0.01$, $\\kappa_{\\min} = 10^{-6}$.\n\n3. Case $3$: A more strongly curved front.\n   - $L_x = 0.02$, $L_y = 0.02$, $N_x = 301$, $N_y = 301$.\n   - $T_u = 300$, $T_b = 2000$, $\\delta = 0.0002$.\n   - $x_0(y) = L_x/2 + a \\sin(2\\pi y/\\lambda)$ with $a = 0.003$ and $\\lambda = L_y$.\n   - $N = 16$, $M = 32$, $L_{\\max} = 0.01$, $\\kappa_{\\min} = 10^{-6}$.\n\n4. Case $4$: A thicker reaction zone, planar front (edge case for small gradients).\n   - $L_x = 0.02$, $L_y = 0.02$, $N_x = 301$, $N_y = 301$.\n   - $T_u = 300$, $T_b = 2000$, $\\delta = 0.002$.\n   - $x_0(y) = L_x/2$.\n   - $N = 6$, $M = 12$, $L_{\\max} = 0.01$, $\\kappa_{\\min} = 10^{-6}$.\n\nAnswer specification:\n- For each test case, your program must compute and return the list $[h_n^{\\text{avg}}, h_t^{\\text{avg}}]$ in meters, where $h_n^{\\text{avg}}$ and $h_t^{\\text{avg}}$ are the averages of $h_n$ and $h_t$ over the front band points.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with one sublist per test case in order, for example, $[[h_{n,1},h_{t,1}],[h_{n,2},h_{t,2}],\\ldots]$.",
            "solution": "The problem as stated is valid. It is scientifically grounded in the principles of computational combustion and fluid dynamics, specifically concerning adaptive mesh refinement for resolving flame fronts. The problem is well-posed, with all necessary parameters and definitions provided for a unique numerical solution. The language is objective and the setup is consistent. We may therefore proceed with the solution.\n\nThe objective is to design an anisotropic mesh adaptation metric for resolving a premixed flame front in a two-dimensional domain. This is accomplished by calculating the desired mesh spacings, denoted as $h_n$ and $h_t$, in the directions normal and tangential to the flame front, respectively. These spacings are determined based on local physical length scales of the flame. The procedure involves the following principal steps:\n\n1.  **Temperature Field Construction**: A continuous and differentiable temperature field $T(x,y)$ is first constructed on a uniform Cartesian grid. This field represents a premixed flame, with a smooth transition from unburnt temperature $T_u$ to burnt temperature $T_b$.\n2.  **Numerical Differentiation**: The first and second partial derivatives of the temperature field ($T_x, T_y, T_{xx}, T_{yy}, T_{xy}$) are computed numerically. These derivatives are essential for characterizing the local geometry of the flame front.\n3.  **Flame Front Localization**: The flame front is identified as an isotherm $T(x,y) = T_f$. In practice, we operate on a narrow band of grid points around this isotherm to ensure robust numerical evaluation.\n4.  **Calculation of Geometric and Physical Properties**: At each point within the flame front band, we compute key quantities:\n    *   The magnitude of the temperature gradient, $\\|\\nabla T\\|$, which is inversely proportional to the flame's local thickness.\n    *   The curvature, $\\kappa$, of the temperature iso-contours, which quantifies the local bending of the flame front.\n5.  **Determination of Characteristic Length Scales**: From the computed properties, we define two characteristic length scales:\n    *   The normal length scale, $L_n$, represents the thermal thickness of the flame.\n    *   The tangential length scale, $L_t$, is based on the local radius of curvature.\n6.  **Computation of Mesh Spacings**: Finally, the desired mesh spacings $h_n$ and $h_t$ are calculated by requiring a specific number of grid points, $N$ and $M$, to resolve the normal and tangential length scales, respectively.\n\nWe will now detail the implementation of each step.\n\n**1. Grid and Temperature Field Generation**\n\nThe computational domain is a rectangle of size $L_x \\times L_y$, discretized by a uniform grid of $N_x \\times N_y$ points. The grid spacings are $\\Delta x = L_x / (N_x-1)$ and $\\Delta y = L_y / (N_y-1)$. The temperature field $T(x,y)$ is given by the analytical expression:\n$$\nT(x,y) = T_u + \\Delta T \\cdot \\frac{1}{2}\\left(1 + \\tanh\\left(\\frac{x - x_0(y)}{\\delta}\\right)\\right)\n$$\nwhere $\\Delta T = T_b - T_u$ is the total temperature rise, $\\delta$ is a parameter controlling the flame thickness, and $x_0(y)$ defines the position of the flame front center. For a planar front, $x_0(y)$ is a constant. For a curved front, it is a sinusoidal function $x_0(y) = L_x/2 + a \\sin(2\\pi y/\\lambda)$.\n\n**2. Numerical Differentiation**\n\nTo evaluate the geometric properties of the flame, we need the partial derivatives of $T(x,y)$. We employ second-order central difference schemes, which are suitable for a uniform grid. For a function $f(x,y)$ discretized on the grid as $f_{i,j} = f(i\\Delta x, j\\Delta y)$, the derivatives are approximated as:\n$$\n\\frac{\\partial f}{\\partial x}\\bigg|_{i,j} \\approx \\frac{f_{i+1,j} - f_{i-1,j}}{2 \\Delta x}\n$$\n$$\n\\frac{\\partial^2 f}{\\partial x^2}\\bigg|_{i,j} \\approx \\frac{f_{i+1,j} - 2f_{i,j} + f_{i-1,j}}{(\\Delta x)^2}\n$$\n$$\n\\frac{\\partial^2 f}{\\partial x \\partial y}\\bigg|_{i,j} \\approx \\frac{f_{i+1,j+1} - f_{i+1,j-1} - f_{i-1,j+1} + f_{i-1,j-1}}{4 \\Delta x \\Delta y}\n$$\nAnalogous formulas apply for $T_y$ and $T_{yy}$. These computations are performed across the entire grid.\n\n**3. Flame Front Localization**\n\nThe flame front is defined by the isotherm $T_f = (T_u + T_b) / 2$. We select all grid points $(x_i, y_j)$ where the temperature $T(x_i, y_j)$ is within a small tolerance $\\epsilon$ of $T_f$. The condition is:\n$$\n|T(x,y) - T_f| \\le \\epsilon\n$$\nwhere $\\epsilon$ is set to $0.01 \\Delta T$. This identifies a thin band of points that effectively sample the flame structure.\n\n**4. Calculation of Physical Quantities**\n\nAt each grid point identified in the previous step, we proceed to compute the following quantities.\n\nThe magnitude of the temperature gradient is fundamental, given by:\n$$\n\\|\\nabla T\\| = \\sqrt{T_x^2 + T_y^2}\n$$\nThe curvature $\\kappa$ of the level sets of $T(x,y)$ is calculated using the established formula involving first and second derivatives:\n$$\n\\kappa = \\frac{T_x^2 T_{yy} - 2 T_x T_y T_{xy} + T_y^2 T_{xx}}{\\|\\nabla T\\|^3}\n$$\n\n**5. Determination of Characteristic Length Scales**\n\nThe local normal length scale, $L_n$, is the thermal thickness, which is inversely proportional to the maximum temperature gradient. It is defined as:\n$$\nL_n = \\frac{\\Delta T}{\\|\\nabla T\\|}\n$$\nThe local tangential length scale, $L_t$, is related to the flame's geometry. It is taken as the radius of curvature, $R = 1/|\\kappa|$. To handle regions of low curvature (where $R \\to \\infty$) and to maintain a reasonable aspect ratio, $L_t$ is clipped by a minimum curvature $\\kappa_{\\min}$ and a maximum length scale $L_{\\max}$:\n$$\nL_t = \\min\\left(\\frac{1}{\\max(|\\kappa|,\\kappa_{\\min})}, L_{\\max}\\right)\n$$\nThis formulation ensures that the tangential length scale remains bounded and physically meaningful.\n\n**6. Computation of Anisotropic Mesh Spacings**\n\nThe final goal is to determine the mesh spacings $h_n$ and $h_t$ that ensure the flame is adequately resolved. The requirement is to place $N$ grid points across the normal length scale $L_n$ and $M$ points across the tangential length scale $L_t$. This directly leads to the definitions:\n$$\nh_n = \\frac{L_n}{N}, \\qquad h_t = \\frac{L_t}{M}\n$$\nThese values are computed for every point in the flame front band.\n\n**7. Averaging and Final Output**\n\nFor each test case, the problem requires reporting a single representative value for $h_n$ and $h_t$. We achieve this by computing the arithmetic mean of all $h_n$ and $h_t$ values calculated over the points in the flame front band. This provides the average required normal spacing, $h_n^{\\text{avg}}$, and average tangential spacing, $h_t^{\\text{avg}}$, for resolving the flame front according to the specified criteria. The process is then repeated for each test case provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes anisotropic mesh spacings for resolving a premixed flame front\n    for a series of test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1: Planar front\n        {'Lx': 0.02, 'Ly': 0.02, 'Nx': 301, 'Ny': 301, 'Tu': 300.0, 'Tb': 2000.0,\n         'delta': 0.0005, 'a': 0.0, 'lambda_y': 0.02, 'N': 10, 'M': 20,\n         'Lmax': 0.01, 'kappa_min': 1e-6},\n        # Case 2: Weakly curved front\n        {'Lx': 0.02, 'Ly': 0.02, 'Nx': 301, 'Ny': 301, 'Tu': 300.0, 'Tb': 2000.0,\n         'delta': 0.0003, 'a': 0.001, 'lambda_y': 0.02, 'N': 12, 'M': 24,\n         'Lmax': 0.01, 'kappa_min': 1e-6},\n        # Case 3: More strongly curved front\n        {'Lx': 0.02, 'Ly': 0.02, 'Nx': 301, 'Ny': 301, 'Tu': 300.0, 'Tb': 2000.0,\n         'delta': 0.0002, 'a': 0.003, 'lambda_y': 0.02, 'N': 16, 'M': 32,\n         'Lmax': 0.01, 'kappa_min': 1e-6},\n        # Case 4: Thicker reaction zone, planar front\n        {'Lx': 0.02, 'Ly': 0.02, 'Nx': 301, 'Ny': 301, 'Tu': 300.0, 'Tb': 2000.0,\n         'delta': 0.002, 'a': 0.0, 'lambda_y': 0.02, 'N': 6, 'M': 12,\n         'Lmax': 0.01, 'kappa_min': 1e-6}\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        # Unpack parameters from the dictionary\n        Lx, Ly, Nx, Ny = case['Lx'], case['Ly'], case['Nx'], case['Ny']\n        Tu, Tb, delta = case['Tu'], case['Tb'], case['delta']\n        a, lambda_y = case['a'], case['lambda_y']\n        N, M, Lmax, kappa_min = case['N'], case['M'], case['Lmax'], case['kappa_min']\n\n        # 1. Create grid and compute grid spacings\n        x_vec = np.linspace(0, Lx, Nx)\n        y_vec = np.linspace(0, Ly, Ny)\n        dx = x_vec[1] - x_vec[0]\n        dy = y_vec[1] - y_vec[0]\n        # meshgrid with 'xy' indexing creates arrays of shape (Ny, Nx)\n        x, y = np.meshgrid(x_vec, y_vec, indexing='xy')\n\n        # 2. Generate the temperature field\n        delta_T = Tb - Tu\n        if a == 0.0:\n            x0_y = Lx / 2.0\n        else:\n            x0_y = Lx / 2.0 + a * np.sin(2.0 * np.pi * y / lambda_y)\n        \n        arg_tanh = (x - x0_y) / delta\n        T = Tu + delta_T * 0.5 * (1.0 + np.tanh(arg_tanh))\n\n        # 3. Compute first and second derivatives using second-order central differences\n        # np.gradient assumes first axis is y and second is x for (Ny, Nx) arrays\n        Ty, Tx = np.gradient(T, dy, dx)\n        \n        # Second derivatives are computed from gradients of first derivatives\n        _, Txx = np.gradient(Tx, dy, dx)  # d(Tx)/dx\n        Tyy, Txy = np.gradient(Ty, dy, dx)  # d(Ty)/dy and d(Ty)/dx\n\n        # 4. Identify flame front band\n        Tf = (Tu + Tb) / 2.0\n        epsilon = 0.01 * delta_T\n        band_indices = np.where(np.abs(T - Tf) = epsilon)\n\n        if band_indices[0].size == 0:\n            # Handle the case where no points are found in the band\n            all_results.append([float('nan'), float('nan')])\n            continue\n\n        # Extract derivatives at the band points\n        Tx_band = Tx[band_indices]\n        Ty_band = Ty[band_indices]\n        Txx_band = Txx[band_indices]\n        Tyy_band = Tyy[band_indices]\n        Txy_band = Txy[band_indices]\n\n        # 5. Compute physical quantities at band points\n        # Gradient magnitude\n        grad_T_norm_sq = Tx_band**2 + Ty_band**2\n        grad_T_norm = np.sqrt(grad_T_norm_sq)\n\n        # Curvature\n        kappa_numerator = (Tx_band**2 * Tyy_band -\n                           2 * Tx_band * Ty_band * Txy_band +\n                           Ty_band**2 * Txx_band)\n        kappa_denominator = grad_T_norm**3\n        \n        # Use np.divide to safely handle potential division by zero\n        kappa = np.divide(kappa_numerator, kappa_denominator, \n                          out=np.zeros_like(kappa_numerator, dtype=float), \n                          where=kappa_denominator != 0)\n\n        # 6. Determine characteristic length scales\n        # Normal length scale (thermal thickness)\n        Ln = delta_T / grad_T_norm\n        \n        # Tangential length scale (based on radius of curvature)\n        abs_kappa = np.abs(kappa)\n        inv_kappa_clipped = 1.0 / np.maximum(abs_kappa, kappa_min)\n        Lt = np.minimum(inv_kappa_clipped, Lmax)\n        \n        # 7. Compute required spacings\n        hn = Ln / N\n        ht = Lt / M\n\n        # 8. Average results\n        hn_avg = np.mean(hn)\n        ht_avg = np.mean(ht)\n\n        all_results.append([hn_avg, ht_avg])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A sophisticated AMR scheme must do more than just resolve small length scales; it must also preserve the physical topology of the simulated structures. In turbulent combustion, an under-resolved flame front can artificially break apart or merge, leading to fundamentally incorrect simulation outcomes. This advanced practice addresses this challenge by asking you to quantify the topological integrity of a wrinkled flame front. By implementing a curvature-based refinement criterion and comparing the number of connected flame components against a \"truth\" solution, you will directly evaluate the effectiveness of an AMR strategy in preventing such topological errors .",
            "id": "4057471",
            "problem": "Consider a two-dimensional nondimensional domain $[0,1]\\times[0,1]$ containing a premixed flame represented by a smooth progress variable field $c(x,y)\\in[0,1]$, where $c(x,y)\\approx 1$ denotes fully burned gas and $c(x,y)\\approx 0$ denotes unburned gas. The flame front topology is defined by the isocontour $c(x,y)=0.5$, which is equivalent to the zero level set of a signed distance-like function $d(x,y)$ when $c(x,y)$ is constructed from $d(x,y)$. Assume the wrinkled flame front is generated by a graph $y=y_f(x)$ that models a highly wrinkled premixed flame subjected to turbulence. The synthetic front is given by\n$$\ny_f(x)=\\frac{1}{2}+A\\sin\\left(2\\pi K x\\right)+\\frac{A}{2}\\sin\\left(4\\pi K x+\\phi\\right),\n$$\nwhere $A$ is a nondimensional amplitude, $K$ is a nondimensional wavenumber, and $\\phi$ is a fixed phase offset set to $\\phi=\\pi/3$. The signed distance-like function is defined by\n$$\nd(x,y)=y-y_f(x),\n$$\nand the progress variable is constructed as\n$$\nc(x,y)=\\frac{1}{2}\\left(1+\\tanh\\left(-\\frac{d(x,y)}{\\delta}\\right)\\right),\n$$\nwhere $\\delta0$ is a nondimensional flame thickness parameter. The flame front curvature for a generic level-set field $c(x,y)$ is defined by\n$$\n\\kappa(x,y)=\\nabla\\cdot\\left(\\frac{\\nabla c(x,y)}{\\left\\lVert \\nabla c(x,y)\\right\\rVert}\\right),\n$$\nevaluated in a narrow band around the isocontour $c(x,y)=0.5$. A curvature-dependent refinement criterion flags a coarse-grid cell centered at $(x_i,y_j)$ for refinement if both conditions hold:\n$$\n\\left|\\kappa(x_i,y_j)\\right|\\ge \\kappa_{\\mathrm{th}}\n\\quad\\text{and}\\quad\n\\left|c(x_i,y_j)-\\frac{1}{2}\\right|\\le \\eta,\n$$\nwhere $\\kappa_{\\mathrm{th}}0$ is a curvature threshold and $\\eta0$ is a narrow-band half-width proportional to the flame thickness.\n\nYou must evaluate the effect of curvature-dependent refinement on preserving flame front topology. To make this quantitative and reproducible, proceed as follows.\n\n1. Construct a high-resolution \"truth\" raster of size $N_{\\mathrm{truth}}\\times N_{\\mathrm{truth}}$ with $N_{\\mathrm{truth}}=r_{\\mathrm{truth}}N$, where $N$ is the coarse resolution per coordinate direction and $r_{\\mathrm{truth}}$ is a fixed integer refinement factor. Evaluate $c(x,y)$ at the centers of the truth pixels, threshold at $c\\ge 0.5$, and form a binary mask $M_{\\mathrm{truth}}(p,q)\\in\\{0,1\\}$. Compute the number of eight-connected components of $M_{\\mathrm{truth}}$, denoted $C_{\\mathrm{truth}}\\in\\mathbb{Z}_{\\ge 0}$.\n\n2. Construct a coarse representation on an $N\\times N$ grid by sampling $c(x,y)$ at cell centers $(x_i,y_j)$, thresholding at $c\\ge 0.5$ to obtain $M_{\\mathrm{coarse}}(i,j)\\in\\{0,1\\}$. Upscale this coarse mask to the truth raster by assigning each coarse cell's binary value uniformly to its corresponding $r_{\\mathrm{truth}}\\times r_{\\mathrm{truth}}$ block, yielding a high-resolution raster $M_{\\mathrm{coarse}\\uparrow}$. Compute its number of eight-connected components $C_{\\mathrm{coarse}}\\in\\mathbb{Z}_{\\ge 0}$.\n\n3. Apply curvature-dependent refinement on the coarse grid using the criterion above. For each flagged coarse cell, subdivide its corresponding $r_{\\mathrm{truth}}\\times r_{\\mathrm{truth}}$ block into $r_{\\mathrm{fine}}\\times r_{\\mathrm{fine}}$ subblocks, where $r_{\\mathrm{fine}}=2^{L}$ and $L\\in\\mathbb{Z}_{\\ge 1}$ is the maximum refinement level. For each subblock, evaluate $c(x,y)$ at the subcell center and threshold at $c\\ge 0.5$, writing this refined value into the high-resolution raster at the pixels of that subblock. For unflagged coarse cells, keep their uniform coarse assignment. The result is an adaptively refined high-resolution raster $M_{\\mathrm{refined}}$. Compute its number of eight-connected components $C_{\\mathrm{refined}}\\in\\mathbb{Z}_{\\ge 0}$.\n\n4. Define the topology-preserving errors\n$$\nE_{\\mathrm{coarse}}=\\left|C_{\\mathrm{coarse}}-C_{\\mathrm{truth}}\\right|,\\quad\nE_{\\mathrm{refined}}=\\left|C_{\\mathrm{refined}}-C_{\\mathrm{truth}}\\right|.\n$$\nAssess the effect of curvature-dependent refinement by the improvement\n$$\n\\Delta E=E_{\\mathrm{coarse}}-E_{\\mathrm{refined}}.\n$$\n\nAll quantities are nondimensional. Use eight-connectivity when counting connected components. Implement finite differences on the coarse grid to approximate $\\nabla c$ and $\\nabla\\cdot(\\cdot)$, using central differences for interior points and one-sided differences at boundaries. Use a small regularization parameter $\\varepsilon=10^{-12}$ in the denominator of $\\left\\lVert \\nabla c\\right\\rVert$ to avoid division by zero. Set the narrow-band parameter to $\\eta=3\\delta$.\n\nYour program must implement the steps above and produce results for the following test suite, where each test case is a tuple $(A,K,\\delta,N,\\kappa_{\\mathrm{th}},L)$:\n\n- Case $1$: $(0.00,\\,3,\\,0.010,\\,64,\\,10,\\,2)$\n- Case $2$: $(0.06,\\,12,\\,0.005,\\,64,\\,50,\\,2)$\n- Case $3$: $(0.08,\\,16,\\,0.003,\\,48,\\,100,\\,3)$\n- Case $4$: $(0.06,\\,12,\\,0.005,\\,64,\\,1000,\\,2)$\n- Case $5$: $(0.06,\\,12,\\,0.020,\\,32,\\,50,\\,2)$\n\nUse $r_{\\mathrm{truth}}=16$ for all cases and $\\phi=\\pi/3$. For each case, output a list $[E_{\\mathrm{coarse}},E_{\\mathrm{refined}},\\Delta E]$ of integers. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,r_3]$ where each $r_i$ is the list for case $i$).",
            "solution": "The user-specified problem requires a multi-step numerical evaluation of an adaptive mesh refinement strategy for a synthetic premixed flame front. The problem statement is validated to be scientifically grounded, well-posed, and objective. It is based on standard principles of computational combustion and numerical methods, including level-set representations of interfaces, curvature calculation, and adaptive refinement criteria. All necessary parameters, functions, and evaluation procedures are explicitly defined, permitting a unique and verifiable solution.\n\nThe solution proceeds by implementing the specified four-step algorithm.\n\nFirst, the analytical representation of the flame front must be established. The front is defined by the graph $y = y_f(x)$, where:\n$y_f(x) = \\frac{1}{2} + A\\sin(2\\pi K x) + \\frac{A}{2}\\sin(4\\pi K x + \\phi)$\nA signed distance-like function, $d(x,y) = y - y_f(x)$, is used to construct the progress variable field $c(x,y)$:\n$c(x,y) = \\frac{1}{2}\\left(1 + \\tanh\\left(-\\frac{d(x,y)}{\\delta}\\right)\\right)$\nWith this definition, the region where $c(x,y) \\ge 0.5$ corresponds to $y \\le y_f(x)$, which represents the burned gas region.\n\nThe core of the problem involves comparing the topology of this flame front, characterized by the number of connected components, at three different levels of resolution:\n1.  A high-resolution \"truth\" grid ($N_{\\mathrm{truth}} \\times N_{\\mathrm{truth}}$).\n2.  A uniform coarse grid ($N \\times N$), upscaled to the truth resolution.\n3.  An adaptively refined grid, where refinement is applied to coarse cells exhibiting high curvature near the flame front.\n\nTo implement this, we first discretize the domain $[0,1]\\times[0,1]$ and evaluate the functions.\n\n**Step 1: Truth Grid Evaluation**\nA high-resolution grid of size $N_{\\mathrm{truth}} \\times N_{\\mathrm{truth}}$ is generated, where $N_{\\mathrm{truth}} = r_{\\mathrm{truth}}N$. The cell centers are defined as $(x_p, y_q) = ((p+0.5)/N_{\\mathrm{truth}}, (q+0.5)/N_{\\mathrm{truth}})$ for $p, q \\in \\{0, ..., N_{\\mathrm{truth}}-1\\}$. The progress variable field $c(x_p, y_q)$ is evaluated at these centers. A binary mask $M_{\\mathrm{truth}}$ is created by thresholding: $M_{\\mathrm{truth}}(p,q) = 1$ if $c(x_p, y_q) \\ge 0.5$, and $0$ otherwise. The number of eight-connected components, $C_{\\mathrm{truth}}$, is then computed from $M_{\\mathrm{truth}}$ using a labeling algorithm. Since $y_f(x)$ is a single-valued function, the region $y \\le y_f(x)$ forms a single connected domain, thus we expect $C_{\\mathrm{truth}}=1$ for all test cases.\n\n**Step 2: Coarse Grid Evaluation**\nSimilarly, a coarse grid of size $N \\times N$ is defined with cell centers $(x_i, y_j)$. The progress variable is sampled at these points to obtain a coarse field $C_{\\mathrm{coarse}}$. This is thresholded to form a coarse binary mask $M_{\\mathrm{coarse}}$. To compare its topology with the truth, $M_{\\mathrm{coarse}}$ is upscaled to the truth resolution by replacing each coarse cell value with an $r_{\\mathrm{truth}} \\times r_{\\mathrm{truth}}$ block of the same value, resulting in the mask $M_{\\mathrm{coarse}\\uparrow}$. The number of components, $C_{\\mathrm{coarse}}$, is counted on this upscaled mask. Due to undersampling of the thin, wrinkled flame front, this coarse representation may exhibit artificial breaks, leading to $C_{\\mathrm{coarse}} > C_{\\mathrm{truth}}$.\n\n**Step 3: Adaptive Refinement**\nThis step refines the coarse representation based on a local, curvature-dependent criterion. The curvature $\\kappa$ of the progress variable field is computed on the coarse grid. The formula for curvature of a level-set function $c$ is $\\kappa = \\nabla \\cdot (\\nabla c / \\|\\nabla c\\|)$. The gradients and divergence are approximated using second-order finite differences on the coarse grid. A small regularization parameter $\\varepsilon$ is added to the norm $\\|\\nabla c\\|$ to prevent division by zero.\n\nA coarse cell at $(x_i, y_j)$ is flagged for refinement if it meets two conditions:\n$|\\kappa(x_i, y_j)| \\ge \\kappa_{\\mathrm{th}}$ and $|c(x_i, y_j) - 0.5| \\le \\eta = 3\\delta$.\nThe first condition targets regions of high curvature, while the second restricts refinement to a narrow band around the flame front.\n\nAn adaptively refined mask, $M_{\\mathrm{refined}}$, is initialized as a copy of $M_{\\mathrm{coarse}\\uparrow}$. For each flagged coarse cell $(i, j)$, its corresponding $r_{\\mathrm{truth}} \\times r_{\\mathrm{truth}}$ block in $M_{\\mathrm{refined}}$ is recomputed. The coarse cell is subdivided into an $r_{\\mathrm{fine}} \\times r_{\\mathrm{fine}}$ grid of subcells, where $r_{\\mathrm{fine}}=2^L$. The progress variable $c(x,y)$ is evaluated at the center of each subcell and thresholded. The resulting $r_{\\mathrm{fine}} \\times r_{\\mathrm{fine}}$ binary mask is then scaled up to fill the $r_{\\mathrm{truth}} \\times r_{\\mathrm{truth}}$ block in $M_{\\mathrm{refined}}$. Unflagged cells retain their coarse, uniform values. Finally, the number of components, $C_{\\mathrm{refined}}$, is counted on the completed $M_{\\mathrm{refined}}$ mask.\n\n**Step 4: Error Calculation**\nThe effectiveness of the refinement is quantified by the topology-preserving errors, $E_{\\mathrm{coarse}} = |C_{\\mathrm{coarse}} - C_{\\mathrm{truth}}|$ and $E_{\\mathrm{refined}} = |C_{\\mathrm{refined}} - C_{\\mathrm{truth}}|$. The improvement due to refinement is $\\Delta E = E_{\\mathrm{coarse}} - E_{\\mathrm{refined}}$. A positive $\\Delta E$ indicates that the adaptive refinement successfully repaired topological defects present in the coarse representation.\n\nThe implementation encapsulates these steps and applies them to each test case specified in the problem statement. The use of `numpy` allows for efficient, vectorized calculations on the grids, and `scipy.ndimage.label` provides the necessary tool for counting connected components.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.ndimage import label\n\ndef process_case(A, K, delta, N, kappa_th, L):\n    \"\"\"\n    Processes a single test case for the flame front refinement problem.\n    \"\"\"\n    # 0. Setup and Definitions\n    phi = np.pi / 3.0\n    r_truth = 16\n    epsilon = 1.0e-12\n    eta = 3.0 * delta\n    r_fine = 2**L\n    N_truth = r_truth * N\n    \n    h_truth = 1.0 / N_truth\n    h_coarse = 1.0 / N\n\n    # Helper functions\n    def y_f(x):\n        return 0.5 + A * np.sin(2.0 * np.pi * K * x) + (A / 2.0) * np.sin(4.0 * np.pi * K * x + phi)\n\n    def c_func(x, y):\n        d = y - y_f(x)\n        return 0.5 * (1.0 + np.tanh(-d / delta))\n\n    def count_components(mask):\n        structure = np.ones((3, 3), dtype=int)\n        _, num_components = label(mask, structure=structure)\n        return num_components\n\n    # 1. High-Resolution \"Truth\" Calculation\n    p_coords = (np.arange(N_truth) + 0.5) * h_truth\n    q_coords = (np.arange(N_truth) + 0.5) * h_truth\n    X_truth, Y_truth = np.meshgrid(p_coords, q_coords, indexing='xy')\n    \n    C_truth_grid = c_func(X_truth, Y_truth)\n    M_truth = (C_truth_grid = 0.5)\n    C_truth = count_components(M_truth)\n\n    # 2. Coarse Representation Calculation\n    i_coords = (np.arange(N) + 0.5) * h_coarse\n    j_coords = (np.arange(N) + 0.5) * h_coarse\n    X_coarse, Y_coarse = np.meshgrid(i_coords, j_coords, indexing='xy')\n    \n    C_coarse_grid = c_func(X_coarse, Y_coarse)\n    M_coarse = (C_coarse_grid = 0.5)\n    \n    # Upscale coarse mask to truth resolution\n    sub_block_ones = np.ones((r_truth, r_truth), dtype=bool)\n    M_coarse_upscaled = np.kron(M_coarse, sub_block_ones)\n    C_coarse = count_components(M_coarse_upscaled)\n\n    # 3. Curvature-Dependent Refined Calculation\n    # Note: numpy arrays are (row, col) indexed, which corresponds to (y, x)\n    # C_coarse_grid[j,i] corresponds to (x_i, y_j)\n    grad_c_y, grad_c_x = np.gradient(C_coarse_grid.T, h_coarse)\n\n    norm_grad_c = np.sqrt(grad_c_x**2 + grad_c_y**2)\n    \n    nx = grad_c_x / (norm_grad_c + epsilon)\n    ny = grad_c_y / (norm_grad_c + epsilon)\n    \n    grad_nx_y, grad_nx_x = np.gradient(nx, h_coarse)\n    grad_ny_y, grad_ny_x = np.gradient(ny, h_coarse)\n    \n    kappa_grid = (grad_nx_x + grad_ny_y).T\n\n    # Identify cells for refinement\n    refinement_mask = (np.abs(kappa_grid) = kappa_th)  (np.abs(C_coarse_grid - 0.5) = eta)\n    \n    # Construct the refined mask\n    M_refined = M_coarse_upscaled.copy()\n    sub_block_size = r_truth // r_fine\n    sub_block_kron = np.ones((sub_block_size, sub_block_size), dtype=bool)\n\n    # Get indices of cells to refine using argwhere\n    refine_indices_ij = np.argwhere(refinement_mask)\n\n    for i, j in refine_indices_ij:\n        # Coarse cell (i, j) needs refinement. i is x-index, j is y-index.\n        p_start, q_start = i * r_truth, j * r_truth\n\n        # Create sub-grid within the coarse cell\n        k_sub_coords = (i + (np.arange(r_fine) + 0.5) / r_fine) * h_coarse\n        l_sub_coords = (j + (np.arange(r_fine) + 0.5) / r_fine) * h_coarse\n        x_sub_centers, y_sub_centers = np.meshgrid(k_sub_coords, l_sub_coords, indexing='xy')\n\n        # Evaluate progress variable and threshold on the sub-grid\n        c_sub_grid = c_func(x_sub_centers, y_sub_centers)\n        m_sub = (c_sub_grid = 0.5)\n        \n        # Upscale the sub-mask to an r_truth x r_truth block\n        # m_sub is (y,x) indexed, so no transpose needed for kron\n        refined_block = np.kron(m_sub, sub_block_kron)\n        \n        # Place the block into the refined mask\n        # M_refined is indexed (q, p) which is (y, x)\n        M_refined[q_start : q_start + r_truth, p_start : p_start + r_truth] = refined_block\n\n    C_refined = count_components(M_refined)\n    \n    # 4. Calculate Errors and Improvement\n    E_coarse = abs(C_coarse - C_truth)\n    E_refined = abs(C_refined - C_truth)\n    Delta_E = E_coarse - E_refined\n    \n    return [E_coarse, E_refined, Delta_E]\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (A,     K,  delta,   N,  kappa_th, L)\n        (0.00,   3,  0.010,  64,  10,       2),\n        (0.06,  12,  0.005,  64,  50,       2),\n        (0.08,  16,  0.003,  48, 100,       3),\n        (0.06,  12,  0.005,  64, 1000,      2),\n        (0.06,  12,  0.020,  32,  50,       2)\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}