{
    "hands_on_practices": [
        {
            "introduction": "在计算燃烧学中，精确捕捉火焰结构至关重要，而这始于对火焰位置及其关键长度尺度的量化识别。本练习 () 提供了实践机会，您将学习如何基于常见的定义，通过温度衍生的过程变量 $c$ 来定位火焰锋面，并利用热释放率 $\\lvert \\dot{q}(x) \\rvert$ 的剖面来确定反应区的厚度 $\\Delta_R$。掌握这些基本指标的计算是设计和评估网格加密策略的基石。",
            "id": "4057465",
            "problem": "给定代表预混层流火焰的光滑一维场：温度 $T(x)$（单位为开尔文）和单位体积的单步质量反应速率 $\\dot{\\omega}(x)$（单位为 $\\mathrm{kg\\,m^{-3}\\,s^{-1}}$），两者都定义在具有均匀网格的有界空间区间上。请使用计算燃烧学中的公认定义，实现一个程序，为每个提供的测试用例计算与火焰锋面和反应区相关的两个特征度量：(i) 由 $c=0.5$ 处的基于温度的反应进程变量定义的火焰锋面位置 $x_f$，以及 (ii) 由体积放热率的绝对值 $\\lvert \\dot{q}(x) \\rvert$ 的半峰全宽 (FWHM) 定义的反应区厚度 $\\Delta_R$。所有输出必须以米为单位，表示为十进制浮点数。\n\n使用的基本原理和定义：\n\n- 基于温度的反应进程变量归一化为 $c(x) = \\dfrac{T(x) - T_u}{T_b - T_u}$，其中 $T_u$ 和 $T_b$ 分别是未燃区温度和已燃区温度。对于本问题，将 $T_u$ 和 $T_b$ 定义为给定域上的 $T_u = \\min_{x} T(x)$ 和 $T_b = \\max_{x} T(x)$。\n\n- 火焰锋面位置 $x_f$ 是满足 $c(x_f) = 0.5$ 的唯一 $x$。在离散数据中，通过在跨越 $c=0.5$ 的两个网格点之间进行线性插值来确定 $x_f$。\n\n- 单步总包反应的体积放热率建模为 $\\dot{q}(x) = Q\\,\\dot{\\omega}(x)$，其中 $Q$ 是单位质量反应热。使用 $Q = 5.0 \\times 10^{7}\\,\\mathrm{J\\,kg^{-1}}$。计算其绝对值 $\\lvert \\dot{q}(x) \\rvert$ 并识别最接近 $x_f$ 的主峰。将反应区厚度 $\\Delta_R$ 定义为该峰周围的半峰全宽（FWHM）：即，在峰值两侧，$\\lvert \\dot{q}(x) \\rvert$ 等于峰值一半的两个位置之间的距离，该距离通过在离散网格上进行线性插值计算得出。\n\n算法要求：\n\n- 对 $x_f$ 和定义 $\\Delta_R$ 的半峰值交叉点均使用线性插值。\n\n- 如果 $\\lvert \\dot{q}(x) \\rvert$ 存在多个局部极大值，选择与 $x_f$ 绝对距离最小的那个。\n\n- 通过处理光滑的剖面来确保科学真实性；所提供的测试用例满足单调的 $T(x)$ 趋势和局域化的反应区。\n\n单位和输出格式：\n\n- 将 $x_f$ 和 $\\Delta_R$ 以米为单位，表示为十进制浮点数。\n\n- 您的程序应生成单行输出，其中包含所有测试用例的结果。结果格式为用方括号括起来的列表的逗号分隔列表，每个内部列表包含一个测试用例的 $[x_f,\\Delta_R]$。例如：$[\\,[x_{f,1},\\Delta_{R,1}],\\,[x_{f,2},\\Delta_{R,2}]\\,]$。所有浮点数格式化为小数点后六位。\n\n测试套件：\n\n对于每个测试用例，按如下方式构建均匀网格 $x$ 并定义 $T(x)$ 和 $\\dot{\\omega}(x)$。所有参数均采用标准单位，其中 $x$ 的单位为米。\n\n- 测试用例 1（正常路径，单高斯反应区）：\n  - 域：$x \\in [-5\\times 10^{-3},\\,5\\times 10^{-3}]$，有 $N=2001$ 个点。\n  - 温度：$T_u = 300$, $T_b = 2200$, $L_T = 5.0\\times 10^{-4}$, $T(x) = T_u + (T_b - T_u)\\,\\dfrac{1}{2}\\left(1 + \\tanh\\left(\\dfrac{x}{L_T}\\right)\\right)$。\n  - 反应速率：振幅 $A = 1.2$，中心 $x_0 = 0$，宽度 $\\sigma = 2.5\\times 10^{-4}$，$\\dot{\\omega}(x) = A \\exp\\!\\left(-\\dfrac{(x - x_0)^2}{2\\sigma^2}\\right)$。\n\n- 测试用例 2（两个峰值，选择最接近锋面的峰值）：\n  - 域：$x \\in [-6\\times 10^{-3},\\,6\\times 10^{-3}]$，有 $N=2401$ 个点。\n  - 温度：$T_u = 300$, $T_b = 2200$, $L_T = 6.0\\times 10^{-4}$，偏移量 $x_f^{(0)} = -1.0\\times 10^{-3}$，\n    $T(x) = T_u + (T_b - T_u)\\,\\dfrac{1}{2}\\left(1 + \\tanh\\left(\\dfrac{x - x_f^{(0)}}{L_T}\\right)\\right)$。\n  - 反应速率：两个高斯函数，参数分别为 $A_1 = 0.8$, $x_1 = -1.0\\times 10^{-3}$, $\\sigma_1 = 2.0\\times 10^{-4}$，以及 $A_2 = 0.5$, $x_2 = 1.5\\times 10^{-3}$, $\\sigma_2 = 3.5\\times 10^{-4}$，\n    $\\dot{\\omega}(x) = A_1 \\exp\\!\\left(-\\dfrac{(x - x_1)^2}{2\\sigma_1^2}\\right) + A_2 \\exp\\!\\left(-\\dfrac{(x - x_2)^2}{2\\sigma_2^2}\\right)$。\n\n- 测试用例 3（非高斯，紧凑抛物线反应区）：\n  - 域：$x \\in [-3\\times 10^{-3},\\,3\\times 10^{-3}]$，有 $N=1201$ 个点。\n  - 温度：$T_u = 300$, $T_b = 2200$, $L_T = 3.0\\times 10^{-4}$, $T(x) = T_u + (T_b - T_u)\\,\\dfrac{1}{2}\\left(1 + \\tanh\\left(\\dfrac{x}{L_T}\\right)\\right)$。\n  - 反应速率：振幅 $A = 0.6$，中心 $x_0 = 5.0\\times 10^{-4}$，半宽参数 $\\sigma = 6.0\\times 10^{-4}$，\n    $\\dot{\\omega}(x) = \\max\\!\\left\\{0,\\;A\\left(1 - \\left(\\dfrac{x - x_0}{\\sigma}\\right)^2\\right)\\right\\}$。\n\n您的程序必须为每个测试用例计算对 $[x_f,\\Delta_R]$，并生成一行输出，其中包含这些对的列表，单位为米，每个浮点数格式化为小数点后六位，如 $[[x_{f,1},\\Delta_{R,1}],[x_{f,2},\\Delta_{R,2}],[x_{f,3},\\Delta_{R,3}]]$。",
            "solution": "用户提供的问题陈述已经过分析，被认为是有效的。它在科学上基于计算燃烧学原理，定义和约束清晰，问题适定，并且其表述是客观的。为获得唯一且可验证的解所需的所有必要数据均已提供。\n\n任务是为一维层流火焰剖面计算两个度量：火焰锋面位置 $x_f$ 和反应区厚度 $\\Delta_R$。每个测试用例的求解过程分两个主要阶段进行。\n\n### 阶段1：确定火焰锋面位置 ($x_f$)\n\n火焰锋面位置是根据反应进程定义的，而反应进程由一个归一化的温度场量化。\n\n**1.1. 反应进程变量的定义**\n基于温度的反应进程变量 $c(x)$ 定义为：\n$$c(x) = \\frac{T(x) - T_u}{T_b - T_u}$$\n其中 $T(x)$ 是温度场。未燃区温度 $T_u$ 和已燃区温度 $T_b$ 分别定义为空间域上温度剖面的全局最小值和最大值：\n$$T_u = \\min_{x} T(x)$$\n$$T_b = \\max_{x} T(x)$$\n根据此定义，反应进程变量是有界的，$c(x) \\in [0, 1]$。\n\n**1.2. 火焰锋面位置 ($x_f$)**\n火焰锋面 $x_f$ 定义为反应进程变量等于 $0.5$ 的唯一空间坐标：\n$$c(x_f) = 0.5$$\n鉴于数据是在离散的均匀网格 $x_i$ 上提供的，位置 $x_f$ 通过线性插值确定。首先，我们识别出跨越值 $c = 0.5$ 的两个相邻网格点 $x_i$ 和 $x_{i+1}$。也就是说，我们找到一个索引 $i$，使得 $c(x_i) \\le 0.5 \\le c(x_{i+1})$ 或 $c(x_i) \\ge 0.5 > c(x_{i+1})$。对于所提供的单调递增的温度剖面，适用前一种情况。\n\n用于寻找 $x_f$ 的线性插值公式是：\n$$x_f = x_i + (x_{i+1} - x_i) \\frac{0.5 - c(x_i)}{c(x_{i+1}) - c(x_i)}$$\n\n### 阶段2：确定反应区厚度 ($\\Delta_R$)\n\n反应区厚度定义为以主峰为中心的体积放热率绝对值的半峰全宽（FWHM）。\n\n**2.1. 体积放热率**\n体积放热率 $\\dot{q}(x)$ 由下式给出：\n$$\\dot{q}(x) = Q \\cdot \\dot{\\omega}(x)$$\n其中 $\\dot{\\omega}(x)$ 是单位体积质量反应速率，而 $Q$ 是单位质量反应热，给定值为 $Q = 5.0 \\times 10^7 \\, \\mathrm{J\\,kg^{-1}}$。分析是针对该量的绝对值 $|\\dot{q}(x)|$ 进行的。由于提供的反应速率剖面 $\\dot{\\omega}(x)$ 是非负的，因此 $|\\dot{q}(x)| = \\dot{q}(x)$。\n\n**2.2. 峰值识别与选择**\n剖面 $|\\dot{q}(x)|$ 可能有一个或多个局部极大值。我们必须在离散数据中识别所有这些峰值。如果 $|\\dot{q}(x_j)| > |\\dot{q}(x_{j-1})|$ 且 $|\\dot{q}(x_j)| > |\\dot{q}(x_{j+1})|$，则点 $x_j$ 是一个局部极大值。\n\n如果存在多个峰值，问题指定选择其位置 $x_{\\text{peak}}$ 最接近先前确定的火焰锋面位置 $x_f$ 的那个。我们选择使距离 $|x_{\\text{peak}} - x_f|$ 最小化的峰值。\n\n**2.3. 半峰全宽（FWHM）计算**\n设所选峰值为 $|\\dot{q}|_{\\text{max}}$。半峰值为 $0.5 \\cdot |\\dot{q}|_{\\text{max}}$。反应区厚度 $\\Delta_R$ 是峰值左侧和右侧两点 $x_L$ 和 $x_R$ 之间的距离，在这两点上放热率等于此半峰值。\n$$\\Delta_R = x_R - x_L$$\n其中 $|\\dot{q}(x_L)| = |\\dot{q}(x_R)| = 0.5 \\cdot |\\dot{q}|_{\\text{max}}$。\n\n这些点 $x_L$ 和 $x_R$ 是通过在离散网格上进行线性插值找到的。\n- 为了找到 $x_L$，我们在峰值左侧（$x_j, x_{j+1}  x_{\\text{peak}}$）搜索跨越半峰值的两个相邻网格点 $x_j$ 和 $x_{j+1}$。插值公式为：\n$$x_L = x_j + (x_{j+1} - x_j) \\frac{0.5 |\\dot{q}|_{\\text{max}} - |\\dot{q}(x_j)|}{|\\dot{q}(x_{j+1})| - |\\dot{q}(x_j)|}$$\n- 为了找到 $x_R$，我们在峰值右侧（$x_k, x_{k+1} > x_{\\text{peak}}$）搜索满足相同条件的两个相邻网格点 $x_k$ 和 $x_{k+1}$。插值公式为：\n$$x_R = x_k + (x_{k+1} - x_k) \\frac{0.5 |\\dot{q}|_{\\text{max}} - |\\dot{q}(x_k)|}{|\\dot{q}(x_{k+1})| - |\\dot{q}(x_k)|}$$\n\n将此系统性步骤应用于每个测试用例，以得出所需的度量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import find_peaks\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the calculation for all test cases and print the final result.\n    \"\"\"\n    \n    # Heat of reaction per unit mass in J/kg\n    Q = 5.0e7\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"domain\": (-5e-3, 5e-3), \"N\": 2001,\n            \"T_params\": {\"Tu\": 300.0, \"Tb\": 2200.0, \"L_T\": 5.0e-4},\n            \"T_func\": lambda x, p: p[\"Tu\"] + (p[\"Tb\"] - p[\"Tu\"]) * 0.5 * (1 + np.tanh(x / p[\"L_T\"])),\n            \"omega_params\": {\"A\": 1.2, \"x0\": 0.0, \"sigma\": 2.5e-4},\n            \"omega_func\": lambda x, p: p[\"A\"] * np.exp(-(x - p[\"x0\"])**2 / (2 * p[\"sigma\"]**2))\n        },\n        {\n            \"domain\": (-6e-3, 6e-3), \"N\": 2401,\n            \"T_params\": {\"Tu\": 300.0, \"Tb\": 2200.0, \"L_T\": 6.0e-4, \"x_f0\": -1.0e-3},\n            \"T_func\": lambda x, p: p[\"Tu\"] + (p[\"Tb\"] - p[\"Tu\"]) * 0.5 * (1 + np.tanh((x - p[\"x_f0\"]) / p[\"L_T\"])),\n            \"omega_params\": {\"A1\": 0.8, \"x1\": -1.0e-3, \"sigma1\": 2.0e-4, \"A2\": 0.5, \"x2\": 1.5e-3, \"sigma2\": 3.5e-4},\n            \"omega_func\": lambda x, p: (p[\"A1\"] * np.exp(-(x - p[\"x1\"])**2 / (2 * p[\"sigma1\"]**2)) +\n                                       p[\"A2\"] * np.exp(-(x - p[\"x2\"])**2 / (2 * p[\"sigma2\"]**2)))\n        },\n        {\n            \"domain\": (-3e-3, 3e-3), \"N\": 1201,\n            \"T_params\": {\"Tu\": 300.0, \"Tb\": 2200.0, \"L_T\": 3.0e-4},\n            \"T_func\": lambda x, p: p[\"Tu\"] + (p[\"Tb\"] - p[\"Tu\"]) * 0.5 * (1 + np.tanh(x / p[\"L_T\"])),\n            \"omega_params\": {\"A\": 0.6, \"x0\": 5.0e-4, \"sigma\": 6.0e-4},\n            \"omega_func\": lambda x, p: np.maximum(0, p[\"A\"] * (1 - ((x - p[\"x0\"]) / p[\"sigma\"])**2))\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _calculate_metrics(case, Q)\n        results.append(result)\n\n    # Format the final output string.\n    formatted_results = [f\"[{res[0]:.6f},{res[1]:.6f}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef _linear_interpolate(x_target, y_data, x_data):\n    \"\"\"General linear interpolation function.\"\"\"\n    # Find the index where y_target would be inserted in a sorted y_data\n    # This identifies the interval for interpolation.\n    i = np.searchsorted(y_data, x_target)\n    \n    # Handle edge cases where target is outside data range, though not expected here\n    if i == 0 or i == len(y_data):\n        # Fallback to direct search if searchsorted fails due to non-monotonicity\n        # around the target (not expected for c(x)).\n        for k in range(len(y_data) - 1):\n             if (y_data[k] = x_target and x_target = y_data[k+1]) or (y_data[k] >= x_target and x_target > y_data[k+1]):\n                 i = k + 1\n                 break\n        else: # This else belongs to the for-loop\n             return np.nan # Target not found in any interval\n\n    y1, y2 = y_data[i - 1], y_data[i]\n    x1, x2 = x_data[i - 1], x_data[i]\n\n    return x1 + (x2 - x1) * (x_target - y1) / (y2 - y1)\n    \ndef _calculate_metrics(case, Q):\n    \"\"\"\n    Computes [x_f, Delta_R] for a single test case.\n    \"\"\"\n    # 1. Generate grid and profiles\n    x = np.linspace(case[\"domain\"][0], case[\"domain\"][1], case[\"N\"])\n    T = case[\"T_func\"](x, case[\"T_params\"])\n    omega_dot = case[\"omega_func\"](x, case[\"omega_params\"])\n\n    # 2. Calculate flame front location x_f\n    Tu = np.min(T)\n    Tb = np.max(T)\n    c = (T - Tu) / (Tb - Tu)\n    \n    # Find indices straddling c=0.5\n    # np.searchsorted is efficient for monotonic arrays\n    idx = np.searchsorted(c, 0.5)\n    \n    # Perform linear interpolation for x_f\n    c1, c2 = c[idx - 1], c[idx]\n    x1, x2 = x[idx - 1], x[idx]\n    xf = x1 + (x2 - x1) * (0.5 - c1) / (c2 - c1)\n\n    # 3. Calculate heat release rate and find dominant peak\n    q_dot_mag = np.abs(Q * omega_dot)\n    \n    # Find all peaks in the heat release rate profile\n    peak_indices, _ = find_peaks(q_dot_mag)\n    \n    if len(peak_indices) == 0: # Should not happen with given test cases\n        return [xf, np.nan]\n    elif len(peak_indices) == 1:\n        chosen_peak_idx = peak_indices[0]\n    else:\n        # Choose the peak closest to xf\n        peak_locations = x[peak_indices]\n        distances = np.abs(peak_locations - xf)\n        chosen_peak_idx = peak_indices[np.argmin(distances)]\n\n    # 4. Calculate reaction zone thickness Delta_R (FWHM)\n    q_dot_max = q_dot_mag[chosen_peak_idx]\n    half_max = 0.5 * q_dot_max\n\n    # Find left crossing point x_L\n    x_L = 0.0\n    for i in range(chosen_peak_idx, 0, -1):\n        if q_dot_mag[i-1]  half_max and half_max = q_dot_mag[i]:\n            y1, y2 = q_dot_mag[i-1], q_dot_mag[i]\n            x_L = x[i-1] + (x[i] - x[i-1]) * (half_max - y1) / (y2 - y1)\n            break\n            \n    # Find right crossing point x_R\n    x_R = 0.0\n    for i in range(chosen_peak_idx, len(q_dot_mag) - 1):\n        if q_dot_mag[i] >= half_max and half_max > q_dot_mag[i+1]:\n            y1, y2 = q_dot_mag[i], q_dot_mag[i+1]\n            x_R = x[i] + (x[i+1] - x[i]) * (half_max - y1) / (y2 - y1)\n            break\n    \n    delta_R = x_R - x_L\n\n    return [xf, delta_R]\n\nsolve()\n```"
        },
        {
            "introduction": "虽然温度 $T$、关键组分（如 $Y_{\\mathrm{OH}}$）浓度或热释放率 $|\\dot{q}|$ 等多个物理量都可以作为火焰的标志，但它们在空间上的峰值位置可能不完全重合，并且对噪声的敏感度也各不相同。一个鲁棒的加密策略不应过度依赖于单个可能存在噪声的指示器。本练习 () 将引导您比较不同火焰标志物的定位差异，并构建一个更稳定、更可靠的组合指示器 $C(x)$，这对于在复杂的模拟环境中开发稳健的自适应网格加密（AMR）算法至关重要。",
            "id": "4057428",
            "problem": "考虑使用多种标记物在一维预混火焰中定位火焰锋面和反应区，并为自适应网格加密（AMR）设计一个鲁棒的加密指示器的问题。计算域沿空间坐标 $x$ 展开，单位为米。提供的合成数据集近似一个统计稳态的一维预混火焰。物理场包括温度 $T$（单位：Kelvin）、羟基质量分数 $Y_{\\mathrm{OH}}$（无量纲）以及体积热释放率的量值 $|\\dot{q}|$（单位：瓦特/立方米）。您必须基于第一性原理计算定位度量，并提出一个鲁棒的组合加密判据。所有距离必须以米为单位表示。\n\n使用的基本原理和定义：\n- 从反应流中的能量和组分守恒出发。在一个稳态的一维预混火焰中，热传导与化学反应相平衡，形成一个具有大温度梯度的薄区域，该区域通常用于定义火焰锋面。令 $T(x)$ 表示温度，$Y_{\\mathrm{OH}}(x)$ 表示指示强烈反应活性的羟基质量分数，$|\\dot{q}(x)|$ 表示热释放率的量值。对于组分和能量，局部生成率会在反应区附近引起 $Y_{\\mathrm{OH}}$ 和 $|\\dot{q}|$ 的峰值。热释放率定义为 $|\\dot{q}| = \\left| -\\sum_k h_k \\dot{\\omega}_k \\right|$，其中 $h_k$ 是组分焓，$\\dot{\\omega}_k$ 是组分净生成率；然而，对于此合成数据集，$|\\dot{q}|(x)$ 是直接给定的。\n- 通过最大温度梯度量值的位置定义火焰锋面位置，即 $|\\partial T/\\partial x|$ 达到其最大值的 $x$ 处。通过 $|\\dot{q}(x)|$ 的最大值定义反应区位置。羟基质量分数既可以通过其梯度 $|\\partial Y_{\\mathrm{OH}}/\\partial x|$ 用作锋面指示器，也可以通过其峰值 $Y_{\\mathrm{OH}}$ 用作反应指示器。\n- 定义热厚度 $\\delta_{\\mathrm{th}}$ 为位置 $x_{0.1}$ 和 $x_{0.9}$ 之间的距离，在这些位置上，$T(x)$ 分别达到 $T_u + 0.1\\,(T_b - T_u)$ 和 $T_u + 0.9\\,(T_b - T_u)$，其中 $T_u$ 是未燃区温度，$T_b$ 是已燃区温度。该厚度用于归一化定位灵敏度。\n\n合成数据集（所有参数均为精确值，必须按给定值使用）：\n- 数据集 1（“理想情况”）：域长度 $L = 0.02$，网格点数 $N = 400$，因此均匀间距为 $\\Delta x = L/(N-1)$。未燃区温度 $T_u = 300$，已燃区温度 $T_b = 2100$，名义锋面中心 $x_0 = 0.010$，热过渡参数 $\\delta_T = 0.0005$。温度分布：$T(x) = T_u + (T_b - T_u)\\,\\frac{1}{2}\\left(1 + \\tanh\\left(\\frac{x - x_0}{\\delta_T}\\right)\\right)$。羟基分布：$Y_{\\mathrm{OH}}(x) = Y_{\\text{peak}}\\exp\\left(-\\frac{(x - x_0 - s_{\\mathrm{OH}})^2}{2\\sigma_{\\mathrm{OH}}^2}\\right)$，其中 $Y_{\\text{peak}} = 0.01$，$s_{\\mathrm{OH}} = 0.0001$，$\\sigma_{\\mathrm{OH}} = 0.0003$。热释放分布：$|\\dot{q}|(x) = q_{\\text{peak}}\\exp\\left(-\\frac{(x - x_0 - s_q)^2}{2\\sigma_q^2}\\right)$，其中 $q_{\\text{peak}} = 5\\times 10^9$，$s_q = 0.00015$，$\\sigma_q = 0.00025$。\n- 数据集 2（“薄锋面边界”）：域长度 $L = 0.01$，网格点数 $N = 60$，$T_u = 300$，$T_b = 2100$，$x_0 = 0.005$，$\\delta_T = 0.0002$。羟基：$Y_{\\text{peak}} = 0.01$，$s_{\\mathrm{OH}} = 0.00006$，$\\sigma_{\\mathrm{OH}} = 0.00015$。热释放：$q_{\\text{peak}} = 3\\times 10^9$，$s_q = 0.00008$，$\\sigma_q = 0.00012$。温度 $T(x)$、羟基 $Y_{\\mathrm{OH}}(x)$ 和热释放 $|\\dot{q}|(x)$ 的定义与数据集 1 中的参数相同。\n- 数据集 3（“噪声信号边缘情况”）：与数据集 1 相同，但添加零均值高斯噪声。对于 $Y_{\\mathrm{OH}}$，添加标准差为 $0.05\\,Y_{\\text{peak}}$ 的噪声 $\\eta_Y$。对于 $|\\dot{q}|$，添加标准差为 $0.05\\,q_{\\text{peak}}$ 的噪声 $\\eta_q$。对于 $T$，添加标准差为 $0.005\\,(T_b - T_u)$ 的可忽略噪声 $\\eta_T$。所有噪声应独立且可通过固定随机种子（具体使用种子 12345）进行复现。\n\n任务：\n- 对于每个数据集，使用二阶中心差分计算内部点的空间导数，并使用一阶单边差分计算边界点的空间导数。确定 $|\\partial T/\\partial x|$ 最大的火焰锋面位置 $x_{T'}$， $|\\partial Y_{\\mathrm{OH}}/\\partial x|$ 最大的羟基梯度锋面位置 $x_{Y'}$， $Y_{\\mathrm{OH}}$ 最大的羟基峰值位置 $x_{Y}$，以及 $|\\dot{q}|$ 最大的热释放峰值位置 $x_{q}$。\n- 按照规定，通过对离散的 $T(x)$ 分布进行插值，计算 $x_{0.1}$ 和 $x_{0.9}$，从而计算热厚度 $\\delta_{\\mathrm{th}}$。\n- 评估定位灵敏度，即以米为单位的距离除以 $\\delta_{\\mathrm{th}}$ 进行归一化：$s_{Tq} = |x_{T'} - x_q|/\\delta_{\\mathrm{th}}$，$s_{Yq} = |x_{Y} - x_q|/\\delta_{\\mathrm{th}}$，以及 $s_{TY} = |x_{T'} - x_{Y'}|/\\delta_{\\mathrm{th}}$。\n- 提出一个由归一化标记物构建的鲁棒组合加密指示器 $C(x)$。定义归一化指示器 $S_T(x) = |\\partial T/\\partial x|/\\max_{x}|\\partial T/\\partial x|$，$S_Y(x) = |\\partial Y_{\\mathrm{OH}}/\\partial x|/\\max_{x}|\\partial Y_{\\mathrm{OH}}/\\partial x|$ 和 $S_q(x) = |\\dot{q}(x)|/\\max_{x}|\\dot{q}(x)|$。将组合指示器定义为调和平均数 $C(x) = \\frac{3}{\\frac{1}{S_T(x)} + \\frac{1}{S_Y(x)} + \\frac{1}{S_q(x)}}$，并约定当任何分母为零时，将相应项视为 $+\\infty$，从而使 $C(x)$ 变为零。使用阈值 $\\tau = 0.5$，如果 $C(x) \\ge \\tau$，则标记该点进行加密。令 $N_{\\text{ref}}$ 为被标记点的数量。\n- 计算组合指示器 $C(x)$ 达到最大值的峰值位置 $x_C$，并计算 $s_{Cq} = |x_C - x_q|/\\delta_{\\mathrm{th}}$，即以 $\\delta_{\\mathrm{th}}$ 归一化的距离（以米为单位）。\n\n要求的输出和单位：\n- 对于每个数据集，按顺序输出一个包含以下内容的列表：$s_{Tq}$, $s_{Yq}$, $s_{TY}$, $s_{Cq}$, $x_{T'}$, $x_q$ 和 $N_{\\text{ref}}$。所有 $x$ 值必须以米为单位，所有 $s$ 值均为无量纲。$N_{\\text{ref}}$ 是一个整数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，该列表按数据集 1、2、3 的顺序包含三个对应于每个数据集的列表，例如 $[[\\dots],[\\dots],[\\dots]]$。\n\n测试套件覆盖范围：\n- 数据集 1 测试一个解析良好的光滑火焰。\n- 数据集 2 探测一个接近网格分辨率的锋面，以测试边界敏感性。\n- 数据集 3 包含噪声，以测试组合指示器对虚假极值的鲁棒性。",
            "solution": "该问题要求分析合成的一维预混火焰数据，以确定关键特征的位置，并为自适应网格加密（AMR）设计一个鲁棒的加密指示器。解决方案涉及多个计算步骤，这些步骤将应用于代表解析良好的火焰、解析不足的火焰以及带有噪声信号的火焰的三个不同数据集。\n\n首先，我们建立计算域并生成物理场数据。对于每个数据集，在长度为 $L$ 的域上创建一个包含 $N$ 个点的一维空间网格 $x$，从而得到均匀的网格间距 $\\Delta x = L/(N-1)$。使用提供的解析函数在每个网格点上计算温度分布 $T(x)$、羟基质量分数 $Y_{\\mathrm{OH}}(x)$ 和热释放率的量值 $|\\dot{q}(x)|$：\n$$T(x) = T_u + (T_b - T_u)\\,\\frac{1}{2}\\left(1 + \\tanh\\left(\\frac{x - x_0}{\\delta_T}\\right)\\right)$$\n$$Y_{\\mathrm{OH}}(x) = Y_{\\text{peak}}\\exp\\left(-\\frac{(x - x_0 - s_{\\mathrm{OH}})^2}{2\\sigma_{\\mathrm{OH}}^2}\\right)$$\n$$|\\dot{q}|(x) = q_{\\text{peak}}\\exp\\left(-\\frac{(x - x_0 - s_q)^2}{2\\sigma_q^2}\\right)$$\n对于数据集 3，向每个场添加零均值高斯噪声。具体来说，令 $T_{clean}(x)$、$Y_{\\mathrm{OH,clean}}(x)$ 和 $|\\dot{q}|_{clean}(x)$ 为通过公式生成的分布。那么带噪声的分布为 $T(x) = T_{clean}(x) + \\eta_T(x)$、$Y_{\\mathrm{OH}}(x) = Y_{\\mathrm{OH,clean}}(x) + \\eta_Y(x)$ 和 $|\\dot{q}|(x) = |\\dot{q}|_{clean}(x) + \\eta_q(x)$，其中 $\\eta_T$、$\\eta_Y$ 和 $\\eta_q$ 是分别从标准差为 $0.005\\,(T_b - T_u)$、$0.05\\,Y_{\\text{peak}}$ 和 $0.05\\,q_{\\text{peak}}$ 的正态分布中抽取的随机变量。\n\n其次，通过数值方法计算空间导数以识别基于梯度的特征。导数 $\\partial T/\\partial x$ 和 $\\partial Y_{\\mathrm{OH}}/\\partial x$ 使用二阶中心差分格式计算内部网格点 $i \\in [1, N-2]$：\n$$ \\left(\\frac{\\partial f}{\\partial x}\\right)_i \\approx \\frac{f_{i+1} - f_{i-1}}{2\\Delta x} $$\n以及使用一阶单边差分格式计算边界点 $i=0$ 和 $i=N-1$：\n$$ \\left(\\frac{\\partial f}{\\partial x}\\right)_0 \\approx \\frac{f_1 - f_0}{\\Delta x}, \\quad \\left(\\frac{\\partial f}{\\partial x}\\right)_{N-1} \\approx \\frac{f_{N-1} - f_{N-2}}{\\Delta x} $$\n\n第三，从离散数据中确定主要火焰特征的位置。火焰锋面位置 $x_{T'}$ 是温度梯度量值 $|\\partial T/\\partial x|$ 最大的网格点 $x$。类似地，羟基梯度锋面位置 $x_{Y'}$ 是 $|\\partial Y_{\\mathrm{OH}}/\\partial x|$ 最大的地方。羟基峰值位置 $x_{Y}$ 和热释放峰值位置 $x_{q}$ 分别在 $Y_{\\mathrm{OH}}(x)$ 和 $|\\dot{q}(x)|$ 最大的地方找到。这些都是通过在相应数组中找到最大值的索引来确定的。\n\n第四，计算热厚度 $\\delta_{\\mathrm{th}}$。该度量表征了主温度过渡区的宽度。它定义为 $\\delta_{\\mathrm{th}} = |x_{0.9} - x_{0.1}|$，其中 $x_{0.1}$ 和 $x_{0.9}$ 分别是温度等于 $T_{0.1} = T_u + 0.1(T_b - T_u)$ 和 $T_{0.9} = T_u + 0.9(T_b - T_u)$ 的空间坐标。这些位置是通过在离散的 $T(x)$ 分布上进行线性插值来确定的。对于数据集 3 中的带噪声温度分布（可能不是单调的），在插值前将温度和对应的坐标数组一起排序，以确保其正确性。\n\n第五，评估定位灵敏度。这些无量纲量衡量了不同特征检测标记物之间的空间间隔，并用火焰的热厚度 $\\delta_{\\mathrm{th}}$ 进行归一化。这些度量计算如下：\n$$s_{Tq} = \\frac{|x_{T'} - x_q|}{\\delta_{\\mathrm{th}}}, \\quad s_{Yq} = \\frac{|x_{Y} - x_q|}{\\delta_{\\mathrm{th}}}, \\quad s_{TY} = \\frac{|x_{T'} - x_{Y'}|}{\\delta_{\\mathrm{th}}}$$\n\n第六，设计并评估一个鲁棒的组合加密指示器 $C(x)$。此步骤旨在为 AMR 创建一个单一、可靠的标记物，该标记物对噪声或解析不足的敏感性低于任何单个标记物。首先，将各个指示器归一化到 $[0, 1]$ 区间：\n$$S_T(x) = \\frac{|\\partial T/\\partial x|}{\\max_{x}|\\partial T/\\partial x|}, \\quad S_Y(x) = \\frac{|\\partial Y_{\\mathrm{OH}}/\\partial x|}{\\max_{x}|\\partial Y_{\\mathrm{OH}}/\\partial x|}, \\quad S_q(x) = \\frac{|\\dot{q}(x)|}{\\max_{x}|\\dot{q}(x)|}$$\n组合指示器 $C(x)$ 定义为这些归一化指示器的调和平均数：\n$$C(x) = \\frac{3}{\\frac{1}{S_T(x)} + \\frac{1}{S_Y(x)} + \\frac{1}{S_q(x)}}$$\n按照约定，如果任何单个指示器 $S(x)$ 为零，则项 $1/S(x)$ 被视为无穷大，这导致 $C(x) = 0$。此属性确保组合指示器仅在所有三个底层标记物均显著的区域才较大，从而赋予其鲁棒性。如果 $C(x) \\ge \\tau$，则将网格点标记为需要加密，其中阈值给定为 $\\tau = 0.5$。这类点的总数记为 $N_{\\text{ref}}$。还确定了此组合指示器的峰值位置 $x_C$，并将其与热释放峰值的间隔量化为 $s_{Cq} = |x_C - x_q|/\\delta_{\\mathrm{th}}$。\n\n最后，对三个数据集中的每一个执行此完整过程，并将计算出的值（$s_{Tq}$, $s_{Yq}$, $s_{TY}$, $s_{Cq}$, $x_{T'}$, $x_q$ 和 $N_{\\text{ref}}$）收集起来用于最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that defines datasets, processes them,\n    and prints the results in the required format.\n    \"\"\"\n\n    def compute_derivative(f, dx):\n        \"\"\"\n        Computes the spatial derivative of a 1D array f with spacing dx.\n        Uses second-order centered differences for the interior and\n        first-order one-sided differences for the boundaries.\n        \"\"\"\n        N = len(f)\n        if N  2:\n            return np.zeros_like(f)\n        \n        df_dx = np.zeros(N, dtype=float)\n        \n        # Interior points (second-order centered)\n        if N > 2:\n            df_dx[1:-1] = (f[2:] - f[:-2]) / (2 * dx)\n        \n        # Boundary points (first-order one-sided)\n        df_dx[0] = (f[1] - f[0]) / dx\n        df_dx[-1] = (f[-1] - f[-2]) / dx\n        \n        return df_dx\n\n    def process_dataset(params):\n        \"\"\"\n        Processes a single dataset to compute all required metrics.\n        \"\"\"\n        # 1. Unpack parameters and generate grid\n        L, N = params['L'], params['N']\n        Tu, Tb = params['T_u'], params['T_b']\n        x0, dT = params['x_0'], params['delta_T']\n        Yp, sOH, sigOH = params['Y_peak'], params['s_OH'], params['sigma_OH']\n        qp, sq, sigq = params['q_peak'], params['s_q'], params['sigma_q']\n\n        x = np.linspace(0, L, N)\n        dx = x[1] - x[0]\n\n        # 2. Generate clean profiles\n        T = Tu + (Tb - Tu) * 0.5 * (1 + np.tanh((x - x0) / dT))\n        Y_OH = Yp * np.exp(-((x - x0 - sOH)**2) / (2 * sigOH**2))\n        q_dot = qp * np.exp(-((x - x0 - sq)**2) / (2 * sigq**2))\n\n        # 3. Add noise if specified (Dataset 3)\n        if params.get('noise', False):\n            rng = np.random.default_rng(params['seed'])\n            \n            noise_T = rng.normal(0, 0.005 * (Tb - Tu), N)\n            T += noise_T\n            \n            noise_Y = rng.normal(0, 0.05 * Yp, N)\n            Y_OH += noise_Y\n\n            noise_q = rng.normal(0, 0.05 * qp, N)\n            q_dot += noise_q\n\n        # 4. Compute derivatives\n        dT_dx = compute_derivative(T, dx)\n        dYOH_dx = compute_derivative(Y_OH, dx)\n        abs_dT_dx = np.abs(dT_dx)\n        abs_dYOH_dx = np.abs(dYOH_dx)\n\n        # 5. Determine feature locations\n        x_T_prime = x[np.argmax(abs_dT_dx)]\n        x_Y_prime = x[np.argmax(abs_dYOH_dx)]\n        x_Y = x[np.argmax(Y_OH)]\n        x_q = x[np.argmax(q_dot)]\n\n        # 6. Compute thermal thickness\n        T_01 = Tu + 0.1 * (Tb - Tu)\n        T_09 = Tu + 0.9 * (Tb - Tu)\n        \n        # For noisy data, ensure T is monotonic for interpolation\n        if params.get('noise', False):\n            sort_indices = np.argsort(T)\n            T_sorted = T[sort_indices]\n            x_sorted = x[sort_indices]\n            x_01 = np.interp(T_01, T_sorted, x_sorted)\n            x_09 = np.interp(T_09, T_sorted, x_sorted)\n        else: # For clean data, T is monotonic\n            x_01 = np.interp(T_01, T, x)\n            x_09 = np.interp(T_09, T, x)\n\n        delta_th = np.abs(x_09 - x_01)\n        if delta_th == 0: delta_th = 1e-12 # Avoid division by zero\n\n        # 7. Evaluate localization sensitivities\n        s_Tq = np.abs(x_T_prime - x_q) / delta_th\n        s_Yq = np.abs(x_Y - x_q) / delta_th\n        s_TY = np.abs(x_T_prime - x_Y_prime) / delta_th\n\n        # 8. Compute combined refinement indicator\n        max_abs_dT_dx = np.max(abs_dT_dx)\n        if max_abs_dT_dx == 0: max_abs_dT_dx = 1e-12\n        S_T = abs_dT_dx / max_abs_dT_dx\n\n        max_abs_dYOH_dx = np.max(abs_dYOH_dx)\n        if max_abs_dYOH_dx == 0: max_abs_dYOH_dx = 1e-12\n        S_Y = abs_dYOH_dx / max_abs_dYOH_dx\n        \n        max_q_dot = np.max(q_dot)\n        if max_q_dot = 0: max_q_dot = 1e-12 # Handle potential negative noisy values\n        S_q = q_dot / max_q_dot\n        S_q[S_q  0] = 0 # Magnitudes cannot be negative\n\n        C = np.zeros_like(x)\n        inv_S_T = np.divide(1.0, S_T, out=np.full_like(S_T, np.inf), where=S_T!=0)\n        inv_S_Y = np.divide(1.0, S_Y, out=np.full_like(S_Y, np.inf), where=S_Y!=0)\n        inv_S_q = np.divide(1.0, S_q, out=np.full_like(S_q, np.inf), where=S_q!=0)\n        \n        denominator_sum = inv_S_T + inv_S_Y + inv_S_q\n        mask = np.isfinite(denominator_sum)\n        C[mask] = 3.0 / denominator_sum[mask]\n\n        tau = 0.5\n        N_ref = np.sum(C >= tau)\n\n        # 9. Compute C peak location and sensitivity\n        x_C = x[np.argmax(C)]\n        s_Cq = np.abs(x_C - x_q) / delta_th\n\n        return [s_Tq, s_Yq, s_TY, s_Cq, x_T_prime, x_q, N_ref]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"L\": 0.02, \"N\": 400, \"T_u\": 300, \"T_b\": 2100, \"x_0\": 0.010,\n            \"delta_T\": 0.0005, \"Y_peak\": 0.01, \"s_OH\": 0.0001, \"sigma_OH\": 0.0003,\n            \"q_peak\": 5e9, \"s_q\": 0.00015, \"sigma_q\": 0.00025\n        },\n        {\n            \"L\": 0.01, \"N\": 60, \"T_u\": 300, \"T_b\": 2100, \"x_0\": 0.005,\n            \"delta_T\": 0.0002, \"Y_peak\": 0.01, \"s_OH\": 0.00006, \"sigma_OH\": 0.00015,\n            \"q_peak\": 3e9, \"s_q\": 0.00008, \"sigma_q\": 0.00012\n        },\n        {\n            \"L\": 0.02, \"N\": 400, \"T_u\": 300, \"T_b\": 2100, \"x_0\": 0.010,\n            \"delta_T\": 0.0005, \"Y_peak\": 0.01, \"s_OH\": 0.0001, \"sigma_OH\": 0.0003,\n            \"q_peak\": 5e9, \"s_q\": 0.00015, \"sigma_q\": 0.00025,\n            \"noise\": True, \"seed\": 12345\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_dataset(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    formatted_sublists = []\n    for res_list in results:\n        # The last element N_ref must be an integer\n        str_list = [f\"{val}\" for val in res_list[:-1]] + [f\"{int(res_list[-1])}\"]\n        formatted_sublists.append(f\"[{','.join(str_list)}]\")\n    \n    print(f\"[{','.join(formatted_sublists)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在多维空间中，火焰锋面沿其法向和切向的特征尺度差异巨大，导致各向同性加密（即在所有方向上使用相同的小网格）效率低下。一个更优越的策略是各向异性网格自适应，它根据解在不同方向上的变化特性来调整分辨率。这项高级实践 () 将您带入二维领域，展示如何利用温度场的Hessian矩阵 $H(T)$ 来提取局部几何信息（如曲率 $\\kappa$），并据此设计出高效的各向异性网格加密方案，确定沿火焰法向和切向所需的不同网格间距 $h_n$ 和 $h_t$。",
            "id": "4057404",
            "problem": "给定一个在具有笛卡尔坐标 $\\mathbf{x} = (x,y)$ 的矩形域上定义的二维温度场 $T(\\mathbf{x})$。该场包含一个被建模为等温线的预混火焰锋面。您的任务是：计算温度场的Hessian矩阵 $H(T)$，根据 $H(T)$ 估算火焰锋面的曲率，并设计一个各向异性自适应度量，以保证沿火焰锋面的局部法向有 $N$ 个点，沿局部切向有 $M$ 个点。自适应应通过火焰锋面上各点的方向相关间距 $h_n$ 和 $h_t$ 来指定，且这些间距必须以米为单位报告。\n\n使用的基本原理和定义：\n- 温度场 $T(x,y)$ 是一个光滑标量函数。其梯度为 $\\nabla T = (T_x, T_y)$，其中 $T_x = \\partial T / \\partial x$，$T_y = \\partial T / \\partial y$。Hessian矩阵 $H(T)$ 是由二阶导数组成的 $2 \\times 2$ 矩阵，\n$$\nH(T) = \\begin{bmatrix}\nT_{xx}  T_{xy} \\\\\nT_{yx}  T_{yy}\n\\end{bmatrix},\n$$\n其中 $T_{xx} = \\partial^2 T / \\partial x^2$，$T_{yy} = \\partial^2 T / \\partial y^2$，$T_{xy} = T_{yx} = \\partial^2 T / (\\partial x \\partial y)$。\n- 火焰锋面定义为等温线 $T(x,y) = T_f$，其中 $T_f$ 是给定的。在火焰锋面上的点，定义单位法向量 $\\mathbf{n} = \\nabla T / \\|\\nabla T\\|$ 和一个与 $\\mathbf{n}$ 正交的单位切向量 $\\mathbf{t}$，其定义为 $\\mathbf{t} = (-n_y, n_x)$。\n- 水平集 $T(x,y) = \\text{constant}$ 的曲率 $\\kappa$ 可以通过一阶和二阶导数计算得出：\n$$\n\\kappa = \\frac{T_x^2 T_{yy} - 2 T_x T_y T_{xy} + T_y^2 T_{xx}}{\\|\\nabla T\\|^3}.\n$$\n- 沿法向的局部热厚度近似为：\n$$\nL_n = \\frac{\\Delta T}{\\|\\nabla T\\|},\n$$\n其中 $\\Delta T = T_b - T_u$ 是混合物穿过反应区时从未燃 ($T_u$) 到已燃 ($T_b$) 的温升。\n- 局部切向长度尺度取为局部曲率半径 $R = 1/|\\kappa|$，并通过一个最大切向尺度 $L_{\\max}$ 进行截断，以避免当 $|\\kappa|$ 接近零时出现无界值。具体来说：\n$$\nL_t = \\min\\left(\\frac{1}{\\max(|\\kappa|,\\kappa_{\\min})}, L_{\\max}\\right),\n$$\n其中 $\\kappa_{\\min} > 0$ 是一个小的阈值。\n- 为保证沿法向解析 $N$ 个点，沿切向解析 $M$ 个点，选择间距为：\n$$\nh_n = \\frac{L_n}{N}, \\qquad h_t = \\frac{L_t}{M}.\n$$\n- 火焰锋面上的各向异性度量张量 $G$ 可以指定为与 $\\mathbf{n}$ 和 $\\mathbf{t}$ 对齐，其沿 $\\mathbf{n}$ 和 $\\mathbf{t}$ 方向的特征值分别为 $1/h_n^2$ 和 $1/h_t^2$。\n\n每个测试案例中 $T(x,y)$ 的数值构造：\n- 域是一个尺寸为 $L_x \\times L_y$ 米的矩形，离散在 $N_x \\times N_y$ 个点的均匀网格上。\n- 温度场是基于双曲正切剖面，通过火焰锋面的光滑过渡构建的，\n$$\nT(x,y) = T_u + \\Delta T \\cdot \\frac{1}{2}\\left(1 + \\tanh\\left(\\frac{x - x_0(y)}{\\delta}\\right)\\right),\n$$\n其中 $x_0(y)$ 是在 $y$ 方向上调制的火焰锋面位置，$\\delta$ 是控制陡度的热厚度参数。\n\n估算与输出要求：\n- 在均匀网格上使用二阶中心差分计算 $T_x, T_y, T_{xx}, T_{yy}, T_{xy}$。\n- 定义火焰锋面等温线 $T_f = (T_u + T_b)/2$。使用 $|T - T_f| \\le \\epsilon$（其中 $\\epsilon = 0.01 \\Delta T$）来识别锋面周围窄带内的网格点。\n- 在这些带内点上，使用上述公式计算 $\\|\\nabla T\\|$、$H(T)$、$\\kappa$、$L_n$、$L_t$、$h_n$ 和 $h_t$。\n- 报告每个测试案例中带内点的平均 $h_n$ 和平均 $h_t$。这些平均值必须以米为单位，表示为十进制数。输出中不要包含单位符号；最终打印的列表中只允许出现数值。\n\n测试套件：\n提供以下四个参数集的结果。所有量纲单位适用米或开尔文。\n1. 案例 $1$：平面锋面。\n   - $L_x = 0.02$, $L_y = 0.02$, $N_x = 301$, $N_y = 301$。\n   - $T_u = 300$, $T_b = 2000$, $\\delta = 0.0005$。\n   - $x_0(y) = L_x/2$，即无调制（$a = 0$，$\\lambda$ 未使用）。\n   - $N = 10$, $M = 20$, $L_{\\max} = 0.01$, $\\kappa_{\\min} = 10^{-6}$。\n\n2. 案例 $2$：弱弯曲锋面。\n   - $L_x = 0.02$, $L_y = 0.02$, $N_x = 301$, $N_y = 301$。\n   - $T_u = 300$, $T_b = 2000$, $\\delta = 0.0003$。\n   - $x_0(y) = L_x/2 + a \\sin(2\\pi y/\\lambda)$，其中 $a = 0.001$，$\\lambda = L_y$。\n   - $N = 12$, $M = 24$, $L_{\\max} = 0.01$, $\\kappa_{\\min} = 10^{-6}$。\n\n3. 案例 $3$：更强弯曲的锋面。\n   - $L_x = 0.02$, $L_y = 0.02$, $N_x = 301$, $N_y = 301$。\n   - $T_u = 300$, $T_b = 2000$, $\\delta = 0.0002$。\n   - $x_0(y) = L_x/2 + a \\sin(2\\pi y/\\lambda)$，其中 $a = 0.003$，$\\lambda = L_y$。\n   - $N = 16$, $M = 32$, $L_{\\max} = 0.01$, $\\kappa_{\\min} = 10^{-6}$。\n\n4. 案例 $4$：较厚反应区，平面锋面（小梯度的边界情况）。\n   - $L_x = 0.02$, $L_y = 0.02$, $N_x = 301$, $N_y = 301$。\n   - $T_u = 300$, $T_b = 2000$, $\\delta = 0.002$。\n   - $x_0(y) = L_x/2$。\n   - $N = 6$, $M = 12$, $L_{\\max} = 0.01$, $\\kappa_{\\min} = 10^{-6}$。\n\n答案规范：\n- 对于每个测试案例，您的程序必须计算并返回列表 $[h_n^{\\text{avg}}, h_t^{\\text{avg}}]$（单位：米），其中 $h_n^{\\text{avg}}$ 和 $h_t^{\\text{avg}}$ 是 $h_n$ 和 $h_t$ 在锋面带内点上的平均值。\n- 您的程序应生成单行输出，其中包含结果，格式为一个逗号分隔的列表，并用方括号括起来，每个测试案例一个子列表，按顺序排列，例如 $[[h_{n,1},h_{t,1}],[h_{n,2},h_{t,2}],\\ldots]$。",
            "solution": "所述问题是有效的。它在科学上基于计算燃烧学和流体动力学的原理，特别是关于解析火焰锋面的自适应网格加密。该问题是适定的，为获得唯一的数值解提供了所有必需的参数和定义。其语言客观，设置一致。因此，我们可以着手求解。\n\n目标是设计一个各向异性网格自适应度量，用于解析二维域中的预混火焰锋面。这通过计算火焰锋面法向和切向所需的网格间距（分别表示为 $h_n$ 和 $h_t$）来实现。这些间距是根据火焰的局部物理长度尺度确定的。该过程包括以下主要步骤：\n\n1.  **温度场构建**：首先在均匀的笛卡尔网格上构建一个连续可微的温度场 $T(x,y)$。该场代表一个预混火焰，具有从未燃温度 $T_u$到已燃温度 $T_b$ 的光滑过渡。\n2.  **数值微分**：对温度场的一阶和二阶偏导数（$T_x, T_y, T_{xx}, T_{yy}, T_{xy}$）进行数值计算。这些导数对于表征火焰锋面的局部几何形状至关重要。\n3.  **火焰锋面定位**：火焰锋面被识别为等温线 $T(x,y) = T_f$。在实践中，我们在此等温线周围的一个窄带网格点上进行操作，以确保数值评估的稳健性。\n4.  **几何与物理属性计算**：在火焰锋面带内的每个点上，我们计算以下关键量：\n    *   温度梯度的模 $\\|\\nabla T\\|$，它与火焰的局部厚度成反比。\n    *   温度等值线的曲率 $\\kappa$，它量化了火焰锋面的局部弯曲程度。\n5.  **特征长度尺度的确定**：根据计算出的属性，我们定义两个特征长度尺度：\n    *   法向长度尺度 $L_n$ 代表火焰的热厚度。\n    *   切向长度尺度 $L_t$ 基于局部曲率半径。\n6.  **网格间距的计算**：最后，通过要求特定数量的网格点（分别为 $N$ 和 $M$）来解析法向和切向长度尺度，计算出所需的网格间距 $h_n$ 和 $h_t$。\n\n现在我们将详细说明每个步骤的实现。\n\n**1. 网格与温度场生成**\n\n计算域是一个尺寸为 $L_x \\times L_y$ 的矩形，由 $N_x \\times N_y$ 个点的均匀网格离散化。网格间距为 $\\Delta x = L_x / (N_x-1)$ 和 $\\Delta y = L_y / (N_y-1)$。温度场 $T(x,y)$ 由以下解析表达式给出：\n$$\nT(x,y) = T_u + \\Delta T \\cdot \\frac{1}{2}\\left(1 + \\tanh\\left(\\frac{x - x_0(y)}{\\delta}\\right)\\right)\n$$\n其中 $\\Delta T = T_b - T_u$ 是总温升，$\\delta$ 是控制火焰厚度的参数，$x_0(y)$ 定义了火焰锋面中心的位置。对于平面锋面，$x_0(y)$ 是一个常数。对于弯曲锋面，它是一个正弦函数 $x_0(y) = L_x/2 + a \\sin(2\\pi y/\\lambda)$。\n\n**2. 数值微分**\n\n为了评估火焰的几何特性，我们需要 $T(x,y)$ 的偏导数。我们采用二阶中心差分格式，该格式适用于均匀网格。对于在网格上离散为 $f_{i,j} = f(i\\Delta x, j\\Delta y)$ 的函数 $f(x,y)$，其导数近似为：\n$$\n\\frac{\\partial f}{\\partial x}\\bigg|_{i,j} \\approx \\frac{f_{i+1,j} - f_{i-1,j}}{2 \\Delta x}\n$$\n$$\n\\frac{\\partial^2 f}{\\partial x^2}\\bigg|_{i,j} \\approx \\frac{f_{i+1,j} - 2f_{i,j} + f_{i-1,j}}{(\\Delta x)^2}\n$$\n$$\n\\frac{\\partial^2 f}{\\partial x \\partial y}\\bigg|_{i,j} \\approx \\frac{f_{i+1,j+1} - f_{i+1,j-1} - f_{i-1,j+1} + f_{i-1,j-1}}{4 \\Delta x \\Delta y}\n$$\n类似公式适用于 $T_y$ 和 $T_{yy}$。这些计算在整个网格上执行。\n\n**3. 火焰锋面定位**\n\n火焰锋面由等温线 $T_f = (T_u + T_b) / 2$ 定义。我们选择所有温度 $T(x_i, y_j)$ 在 $T_f$ 的一个小的容差 $\\epsilon$ 范围内的网格点 $(x_i, y_j)$。条件是：\n$$\n|T(x,y) - T_f| \\le \\epsilon\n$$\n其中 $\\epsilon$ 被设为 $0.01 \\Delta T$。这可以识别出一个有效采样火焰结构的薄带点集。\n\n**4. 物理量计算**\n\n在上一步中识别出的每个网格点上，我们继续计算以下量。\n\n温度梯度的模是基础量，由下式给出：\n$$\n\\|\\nabla T\\| = \\sqrt{T_x^2 + T_y^2}\n$$\n$T(x,y)$ 水平集的曲率 $\\kappa$ 使用包含一阶和二阶导数的既定公式计算：\n$$\n\\kappa = \\frac{T_x^2 T_{yy} - 2 T_x T_y T_{xy} + T_y^2 T_{xx}}{\\|\\nabla T\\|^3}\n$$\n\n**5. 特征长度尺度的确定**\n\n局部法向长度尺度 $L_n$ 是热厚度，与最大温度梯度成反比。其定义为：\n$$\nL_n = \\frac{\\Delta T}{\\|\\nabla T\\|}\n$$\n局部切向长度尺度 $L_t$ 与火焰的几何形状有关。它被取为曲率半径 $R = 1/|\\kappa|$。为了处理低曲率区域（其中 $R \\to \\infty$）并保持合理的纵横比，$L_t$ 被最小曲率 $\\kappa_{\\min}$ 和最大长度尺度 $L_{\\max}$ 截断：\n$$\nL_t = \\min\\left(\\frac{1}{\\max(|\\kappa|,\\kappa_{\\min})}, L_{\\max}\\right)\n$$\n这种表述确保了切向长度尺度保持有界且具有物理意义。\n\n**6. 各向异性网格间距的计算**\n\n最终目标是确定网格间距 $h_n$ 和 $h_t$，以确保火焰得到充分解析。要求是在法向长度尺度 $L_n$ 上放置 $N$ 个网格点，在切向长度尺度 $L_t$ 上放置 $M$ 个网格点。这直接引出以下定义：\n$$\nh_n = \\frac{L_n}{N}, \\qquad h_t = \\frac{L_t}{M}\n$$\n这些值是在火焰锋面带中的每个点上计算的。\n\n**7. 平均与最终输出**\n\n对于每个测试案例，问题要求报告 $h_n$ 和 $h_t$ 的单个代表值。我们通过计算在火焰锋面带内所有点上计算出的所有 $h_n$ 和 $h_t$ 值的算术平均值来实现这一点。这提供了根据指定标准解析火焰锋面所需的平均法向间距 $h_n^{\\text{avg}}$ 和平均切向间距 $h_t^{\\text{avg}}$。然后对每个给定的测试案例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes anisotropic mesh spacings for resolving a premixed flame front\n    for a series of test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1: Planar front\n        {'Lx': 0.02, 'Ly': 0.02, 'Nx': 301, 'Ny': 301, 'Tu': 300.0, 'Tb': 2000.0,\n         'delta': 0.0005, 'a': 0.0, 'lambda_y': 0.02, 'N': 10, 'M': 20,\n         'Lmax': 0.01, 'kappa_min': 1e-6},\n        # Case 2: Weakly curved front\n        {'Lx': 0.02, 'Ly': 0.02, 'Nx': 301, 'Ny': 301, 'Tu': 300.0, 'Tb': 2000.0,\n         'delta': 0.0003, 'a': 0.001, 'lambda_y': 0.02, 'N': 12, 'M': 24,\n         'Lmax': 0.01, 'kappa_min': 1e-6},\n        # Case 3: More strongly curved front\n        {'Lx': 0.02, 'Ly': 0.02, 'Nx': 301, 'Ny': 301, 'Tu': 300.0, 'Tb': 2000.0,\n         'delta': 0.0002, 'a': 0.003, 'lambda_y': 0.02, 'N': 16, 'M': 32,\n         'Lmax': 0.01, 'kappa_min': 1e-6},\n        # Case 4: Thicker reaction zone, planar front\n        {'Lx': 0.02, 'Ly': 0.02, 'Nx': 301, 'Ny': 301, 'Tu': 300.0, 'Tb': 2000.0,\n         'delta': 0.002, 'a': 0.0, 'lambda_y': 0.02, 'N': 6, 'M': 12,\n         'Lmax': 0.01, 'kappa_min': 1e-6}\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        # Unpack parameters from the dictionary\n        Lx, Ly, Nx, Ny = case['Lx'], case['Ly'], case['Nx'], case['Ny']\n        Tu, Tb, delta = case['Tu'], case['Tb'], case['delta']\n        a, lambda_y = case['a'], case['lambda_y']\n        N, M, Lmax, kappa_min = case['N'], case['M'], case['Lmax'], case['kappa_min']\n\n        # 1. Create grid and compute grid spacings\n        x_vec = np.linspace(0, Lx, Nx)\n        y_vec = np.linspace(0, Ly, Ny)\n        dx = x_vec[1] - x_vec[0]\n        dy = y_vec[1] - y_vec[0]\n        # meshgrid with 'xy' indexing creates arrays of shape (Ny, Nx)\n        x, y = np.meshgrid(x_vec, y_vec, indexing='xy')\n\n        # 2. Generate the temperature field\n        delta_T = Tb - Tu\n        if a == 0.0:\n            x0_y = Lx / 2.0\n        else:\n            x0_y = Lx / 2.0 + a * np.sin(2.0 * np.pi * y / lambda_y)\n        \n        arg_tanh = (x - x0_y) / delta\n        T = Tu + delta_T * 0.5 * (1.0 + np.tanh(arg_tanh))\n\n        # 3. Compute first and second derivatives using second-order central differences\n        # np.gradient assumes first axis is y and second is x for (Ny, Nx) arrays\n        Ty, Tx = np.gradient(T, dy, dx)\n        \n        # Second derivatives are computed from gradients of first derivatives\n        _, Txx = np.gradient(Tx, dy, dx)  # d(Tx)/dx\n        Tyy, Txy = np.gradient(Ty, dy, dx)  # d(Ty)/dy and d(Ty)/dx\n\n        # 4. Identify flame front band\n        Tf = (Tu + Tb) / 2.0\n        epsilon = 0.01 * delta_T\n        band_indices = np.where(np.abs(T - Tf) = epsilon)\n\n        if band_indices[0].size == 0:\n            # Handle the case where no points are found in the band\n            all_results.append([float('nan'), float('nan')])\n            continue\n\n        # Extract derivatives at the band points\n        Tx_band = Tx[band_indices]\n        Ty_band = Ty[band_indices]\n        Txx_band = Txx[band_indices]\n        Tyy_band = Tyy[band_indices]\n        Txy_band = Txy[band_indices]\n\n        # 5. Compute physical quantities at band points\n        # Gradient magnitude\n        grad_T_norm_sq = Tx_band**2 + Ty_band**2\n        grad_T_norm = np.sqrt(grad_T_norm_sq)\n\n        # Curvature\n        kappa_numerator = (Tx_band**2 * Tyy_band -\n                           2 * Tx_band * Ty_band * Txy_band +\n                           Ty_band**2 * Txx_band)\n        kappa_denominator = grad_T_norm**3\n        \n        # Use np.divide to safely handle potential division by zero\n        kappa = np.divide(kappa_numerator, kappa_denominator, \n                          out=np.zeros_like(kappa_numerator, dtype=float), \n                          where=kappa_denominator != 0)\n\n        # 6. Determine characteristic length scales\n        # Normal length scale (thermal thickness)\n        Ln = delta_T / grad_T_norm\n        \n        # Tangential length scale (based on radius of curvature)\n        abs_kappa = np.abs(kappa)\n        inv_kappa_clipped = 1.0 / np.maximum(abs_kappa, kappa_min)\n        Lt = np.minimum(inv_kappa_clipped, Lmax)\n        \n        # 7. Compute required spacings\n        hn = Ln / N\n        ht = Lt / M\n\n        # 8. Average results\n        hn_avg = np.mean(hn)\n        ht_avg = np.mean(ht)\n\n        all_results.append([hn_avg, ht_avg])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}