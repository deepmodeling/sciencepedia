{
    "hands_on_practices": [
        {
            "introduction": "反应流的降阶建模（ROM）的核心思想是利用化学反应系统中存在的巨大时间尺度差异。这个实践练习  将指导您完成一项基本任务：通过对系统雅可比矩阵进行线性化和特征值分析，来识别系统的“快”动态和“慢”动态。理解如何区分这些时间尺度至关重要，因为它为我们将复杂化学系统简化为仅由少数几个慢变量描述的“慢流形”提供了计算依据。",
            "id": "4057113",
            "problem": "您需要实现一个完整、可运行的程序，该程序针对一个均相、绝热、恒压反应器，其中包含单一不可逆反应，且详细的热化学性质被简化为恒定热容，在指定状态下构建其线性化动力学，并将谱划分为与不变流形方法相关的快子空间和慢子空间。您的程序必须计算源项相对于状态的雅可比矩阵，提取特征值和特征向量，并根据指定的时间尺度阈值，报告每个测试案例中慢子空间的维度。\n\n起始点与建模假设：\n- 考虑一个均相、绝热、恒压反应器的零维质量和能量平衡。设状态向量为 $x = [T, Y_F, Y_O]^T$，其中 $T$ 是温度（单位：开尔文），$Y_F$ 是燃料的质量分数， $Y_O$ 是氧化剂的质量分数。产物的质量分数为 $Y_P = 1 - Y_F - Y_O$。所有质量分数必须满足 $Y_F \\ge 0$, $Y_O \\ge 0$, 且 $Y_F + Y_O \\le 1$。\n- 使用理想气体定律和混合物平均分子性质。混合物密度由 $\\rho = \\dfrac{p \\, \\bar{W}}{R_u T}$ 给出，其中 $p$ 是压力， $R_u$ 是普适气体常数， $\\bar{W}$ 是根据 $Y_i$ 和各组分分子量计算出的混合物平均分子量。\n- 化学反应是形式为 $\\mathrm{F} + s\\,\\mathrm{O} \\to \\mathrm{P}$ 的单步不可逆反应，其中 $s = 0.5$（基于摩尔的化学计量）。\n- 摩尔反应速率为 $w = k(T)\\, C_F \\, C_O$，其中 $k(T) = A \\exp\\!\\left(-\\dfrac{E_a}{R_u T}\\right)$ 是阿伦尼乌斯速率常数， $C_i = \\dfrac{\\rho Y_i}{W_i}$ 是分子量为 $W_i$ 的组分 $i$ 的摩尔浓度。\n- 以质量单位表示的组分源项为 $\\dot{\\omega}_F = - W_F w$ 和 $\\dot{\\omega}_O = - s W_O w$。在绝热、恒压条件下的能量方程为 $\\rho \\, c_p \\, \\dfrac{dT}{dt} = Q \\, w$，其中 $Q$ 是所写反应式每摩尔反应的放热量， $c_p$ 是混合物定压比热，取为 $c_p = Y_F c_{p,F} + Y_O c_{p,O} + Y_P c_{p,P}$，其中各组分热容 $c_{p,i}$ 为常数。\n\n运动方程：\n- 状态的常微分方程 (ODE) 为\n$$\n\\frac{dY_F}{dt} = \\frac{\\dot{\\omega}_F}{\\rho} \\,, \\quad\n\\frac{dY_O}{dt} = \\frac{\\dot{\\omega}_O}{\\rho} \\,, \\quad\n\\frac{dT}{dt} = \\frac{Q \\, w}{\\rho \\, c_p} \\,.\n$$\n这些方程定义了向量场 $f(x)$，其分量为 $f_1 = \\dfrac{dT}{dt}$、$f_2 = \\dfrac{dY_F}{dt}$ 和 $f_3 = \\dfrac{dY_O}{dt}$。\n\n线性化与谱划分：\n- 对于给定的状态 $x^\\star$，定义雅可比矩阵 $J(x^\\star) = \\left.\\dfrac{\\partial f}{\\partial x}\\right|_{x^\\star}$。\n- 计算满足 $J v_j = \\lambda_j v_j$ 的 $J(x^\\star)$ 的特征值 $\\lambda_j$ 和右特征向量 $v_j$。\n- 定义模态 $j$ 的特征时间尺度：如果 $\\Re(\\lambda_j) = 0$，则 $\\tau_j = \\infty$；否则 $\\tau_j = \\dfrac{1}{|\\Re(\\lambda_j)|}$。\n- 给定一个用户指定的分离时间尺度 $\\tau_{\\text{split}}$，将慢子空间定义为由满足 $\\tau_j \\ge \\tau_{\\text{split}}$ （等价于 $|\\Re(\\lambda_j)| \\le \\dfrac{1}{\\tau_{\\text{split}}}$）的特征向量所张成的空间，并将快子空间定义为由其余特征向量所张成的空间。报告慢子空间的整数维度。\n\n待使用的参数值：\n- 普适气体常数：$R_u = 8.314$ J/(mol·K)。\n- 压力：$p = 101325$ Pa。\n- 分子量 (kg/mol)：$W_F = 0.002016$（氢气），$W_O = 0.031999$（氧气），$W_P = 0.018015$（水）。\n- 组分恒定热容 (J/(kg·K))：$c_{p,F} = 14300$，$c_{p,O} = 918$，$c_{p,P} = 1864$。\n- 反应化学计量系数：$s = 0.5$（无量纲，摩尔基准）。\n- 阿伦尼乌斯参数：指前因子 $A = 5\\times 10^{6}$ m$^3$/ (mol·s)，活化能 $E_a = 1.5\\times 10^{5}$ J/mol，温度指数 $n = 0$（无量纲）。\n- 每摩尔反应放热量：$Q = 2.418\\times 10^{5}$ J/mol。\n- 时间尺度阈值：$\\tau_{\\text{split}} = 10^{-3}$ s。\n\n测试套件（每个案例为一个状态 $x^\\star = [T, Y_F, Y_O]$）：\n- 案例 1：$T = 900$ K, $Y_F = 0.1119$, $Y_O = 0.8881$。\n- 案例 2：$T = 1150$ K, $Y_F = 0.1119$, $Y_O = 0.8881$。\n- 案例 3：$T = 1800$ K, $Y_F = 0.01$, $Y_O = 0.05$。\n- 案例 4：$T = 1500$ K, $Y_F = 10^{-6}$, $Y_O = 0.2$。\n\n您必须实现的内容：\n- 根据上述第一性原理构建 $f(x)$，并遵循所有参数值和单位。\n- 在每个测试案例中，使用与定义 $J_{ij} = \\dfrac{\\partial f_i}{\\partial x_j}$ 一致的数值稳定且精确的方法，数值计算 $J(x^\\star)$。\n- 计算 $J(x^\\star)$ 的特征值，并使用上述准则和 $\\tau_{\\text{split}}$ 确定慢子空间的整数维度。\n\n最终输出要求：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试案例的条目是慢子空间的整数维度。例如，格式必须像 $[r_1,r_2,r_3,r_4]$，其中每个 $r_k$ 都是一个整数。\n\n角度单位不适用。所有物理量必须以上述指定单位处理。不允许外部输入；所有参数和测试案例均在此处列出。代码必须是自包含的且可直接运行。",
            "solution": "该问题被评估为有效。它在科学上基于化学动力学和热力学原理，问题本身是适定的，具有明确的目标和充足的数据，并且代表了反应流分析中的一项标准任务。所有参数和条件在物理上都是真实的，在数学上是一致的。\n\n任务是确定一个简化的化学系统在几个指定状态下的慢子空间维度。这需要线性化系统的控制常微分方程 (ODE)，计算所得雅可比矩阵的特征值，并根据时间尺度准则对它们进行划分。\n\n均相、绝热、恒压反应器的状态由向量 $x = [T, Y_F, Y_O]^T$ 描述，其中 $T$ 是温度， $Y_F$ 和 $Y_O$ 分别是燃料和氧化剂的质量分数。控制常微分方程定义了向量场 $f(x) = \\frac{d x}{d t}$：\n$$\nf(x) = \\begin{bmatrix} f_1 \\\\ f_2 \\\\ f_3 \\end{bmatrix} =\n\\begin{bmatrix}\n\\frac{dT}{dt} \\\\\n\\frac{dY_F}{dt} \\\\\n\\frac{dY_O}{dt}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\frac{Q \\, w}{\\rho \\, c_p} \\\\\n\\frac{-W_F w}{\\rho} \\\\\n\\frac{-s W_O w}{\\rho}\n\\end{bmatrix}\n$$\n这些方程中的各项对状态 $x$ 的依赖关系如下：\n产物质量分数为 $Y_P = 1 - Y_F - Y_O$。\n混合物平均分子量 $\\bar{W}$ 由 $\\bar{W} = \\left( \\frac{Y_F}{W_F} + \\frac{Y_O}{W_O} + \\frac{Y_P}{W_P} \\right)^{-1}$ 给出。\n混合物密度 $\\rho$ 来自理想气体定律：$\\rho = \\frac{p \\bar{W}}{R_u T}$。\n混合物平均比热容 $c_p$ 为 $c_p = Y_F c_{p,F} + Y_O c_{p,O} + Y_P c_{p,P}$。\n对于单步反应 $\\mathrm{F} + s\\,\\mathrm{O} \\to \\mathrm{P}$，摩尔反应速率 $w$ 由下式给出：\n$$\nw = k(T)\\, C_F \\, C_O = k(T) \\left(\\frac{\\rho Y_F}{W_F}\\right) \\left(\\frac{\\rho Y_O}{W_O}\\right) = \\frac{k(T) \\rho^2 Y_F Y_O}{W_F W_O}\n$$\n其中阿伦尼乌斯速率常数是 $k(T) = A \\exp\\left(-\\frac{E_a}{R_u T}\\right)$。所有符号均对应问题陈述中提供的参数。\n\n问题的核心是在每个指定状态 $x^\\star$ 下计算雅可比矩阵 $J(x^\\star)$：\n$$\nJ(x^\\star) = \\left. \\frac{\\partial f}{\\partial x} \\right|_{x^\\star} = \\begin{bmatrix}\n\\frac{\\partial f_1}{\\partial T} & \\frac{\\partial f_1}{\\partial Y_F} & \\frac{\\partial f_1}{\\partial Y_O} \\\\\n\\frac{\\partial f_2}{\\partial T} & \\frac{\\partial f_2}{\\partial Y_F} & \\frac{\\partial f_2}{\\partial Y_O} \\\\\n\\frac{\\partial f_3}{\\partial T} & \\frac{\\partial f_3}{\\partial Y_F} & \\frac{\\partial f_3}{\\partial Y_O}\n\\end{bmatrix}_{x=x^\\star}\n$$\n虽然雅可比矩阵的解析推导是可能的，但由于 $\\rho$、$c_p$ 和 $w$ 对状态变量 $T$、 $Y_F$ 和 $Y_O$ 的复杂相互依赖关系，其代数计算量大且容易出错。该问题要求进行数值计算，对此，有限差分法是一种稳健且标准的方法。为保证精度，采用二阶中心差分格式：\n$$\n\\frac{\\partial f_i}{\\partial x_j}(x^\\star) \\approx \\frac{f_i(x^\\star + h_j e_j) - f_i(x^\\star - h_j e_j)}{2 h_j}\n$$\n此处，$e_j$ 是状态向量第 $j$ 个分量的标准基向量，$h_j$ 是一个κος扰动。一个合适的扰动是相对和绝对步长的组合，$h_j = \\epsilon_{\\text{rel}} |x_j^\\star| + \\epsilon_{\\text{abs}}$，以确保在不同尺度的状态变量值上都具有稳定性和准确性。\n\n一旦计算出给定状态下的雅可比矩阵 $J(x^\\star)$，便可使用标准的数值线性代数库确定其特征值 $\\{\\lambda_j\\}$。这些特征值表征了系统的局部动力学。正实部 $\\Re(\\lambda_j) > 0$ 表示一个不稳定的模态（例如，点火），而负实部 $\\Re(\\lambda_j) < 0$ 表示一个衰减至稳态的稳定模态。\n\n对于 $\\Re(\\lambda_j) \\neq 0$ 的情况，每个模态 $j$ 的特征时间尺度定义为 $\\tau_j = \\frac{1}{|\\Re(\\lambda_j)|}$。该时间尺度代表相应模态的振幅改变 $e$ 倍所需的时间。\n然后，根据给定的分离时间尺度 $\\tau_{\\text{split}} = 10^{-3} \\, \\text{s}$，将特征值谱划分为“快”和“慢”子空间。\n如果一个模态 $j$ 的时间尺度 $\\tau_j$ 大于或等于分离时间尺度，则认为该模态是慢的：\n$$\n\\tau_j \\ge \\tau_{\\text{split}} \\iff \\frac{1}{|\\Re(\\lambda_j)|} \\ge \\tau_{\\text{split}} \\iff |\\Re(\\lambda_j)| \\le \\frac{1}{\\tau_{\\text{split}}}\n$$\n慢子空间的维度是满足此条件的特征值的数量。这个计数是每个测试案例的最终结果。此过程是诸如本征低维流形 (Intrinsic Low-Dimensional Manifolds, ILDM) 等降阶建模技术的基础，这些技术旨在通过仅沿系统的慢模态演化来近似全系统的动力学。\n\n实现过程如下：首先定义一个函数来计算任意给定状态 $x$ 下的向量场 $f(x)$。然后，第二个函数使用此向量场函数和中心差分格式来数值构造雅可比矩阵。最后，对于每个测试案例，计算雅可比矩阵，找到其特征值，并根据定义的准则统计慢模态的数量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the problem of finding the dimension of the slow subspace for a\n    reacting flow system at different states.\n    \"\"\"\n    #\n    # --- GLOBAL CONSTANTS ---\n    #\n    # Universal gas constant in J/(mol.K)\n    RU = 8.314\n    # Pressure in Pa\n    P = 101325.0\n    # Molecular weights in kg/mol\n    W_F = 0.002016  # Fuel (H2)\n    W_O = 0.031999  # Oxidizer (O2)\n    W_P = 0.018015  # Product (H2O)\n    # Species constant heat capacities in J/(kg.K)\n    CP_F = 14300.0\n    CP_O = 918.0\n    CP_P = 1864.0\n    # Reaction stoichiometric coefficient (molar basis)\n    S = 0.5\n    # Arrhenius parameters\n    A = 5.0e6  # Pre-exponential factor in m^3/(mol.s)\n    EA = 1.5e5 # Activation energy in J/mol\n    # Heat release per mole of reaction in J/mol\n    Q = 2.418e5\n    # Timescale threshold for splitting fast/slow subspaces in s\n    TAU_SPLIT = 1.0e-3\n    \n    # Store constants in a dictionary for easy passing\n    params = {\n        \"RU\": RU, \"P\": P, \"W_F\": W_F, \"W_O\": W_O, \"W_P\": W_P,\n        \"CP_F\": CP_F, \"CP_O\": CP_O, \"CP_P\": CP_P,\n        \"S\": S, \"A\": A, \"EA\": EA, \"Q\": Q\n    }\n    \n    #\n    # --- TEST CASES ---\n    #\n    # Each case is a state vector x_star = [T, Y_F, Y_O]\n    test_cases = [\n        np.array([900.0, 0.1119, 0.8881]),      # Case 1\n        np.array([1150.0, 0.1119, 0.8881]),     # Case 2\n        np.array([1800.0, 0.01, 0.05]),        # Case 3\n        np.array([1500.0, 1.0e-6, 0.2]),       # Case 4\n    ]\n\n    def compute_rhs(x, p_):\n        \"\"\"\n        Computes the right-hand side (RHS) of the ODE system, f(x).\n        x: state vector [T, Y_F, Y_O]\n        p_: dictionary of physical and chemical parameters\n        \"\"\"\n        T, Y_F, Y_O = x[0], x[1], x[2]\n        \n        # Ensure mass fractions are physically plausible for calculation\n        Y_F = max(0.0, Y_F)\n        Y_O = max(0.0, Y_O)\n        if Y_F + Y_O > 1.0:\n            Y_P = 0.0\n        else:\n            Y_P = 1.0 - Y_F - Y_O\n\n        # Mixture-averaged molecular weight\n        W_inv = Y_F / p_[\"W_F\"] + Y_O / p_[\"W_O\"] + Y_P / p_[\"W_P\"] if Y_P > 0 else Y_F / p_[\"W_F\"] + Y_O / p_[\"W_O\"]\n        if W_inv == 0: return np.zeros(3)\n        W_bar = 1.0 / W_inv\n\n        # Density from ideal gas law\n        rho = (p_[\"P\"] * W_bar) / (p_[\"RU\"] * T)\n\n        # Mixture specific heat\n        cp_mix = Y_F * p_[\"CP_F\"] + Y_O * p_[\"CP_O\"] + Y_P * p_[\"CP_P\"]\n        \n        # Arrhenius rate constant\n        k = p_[\"A\"] * math.exp(-p_[\"EA\"] / (p_[\"RU\"] * T))\n\n        # Molar concentrations\n        C_F = rho * Y_F / p_[\"W_F\"]\n        C_O = rho * Y_O / p_[\"W_O\"]\n\n        # Molar reaction rate\n        w_mole = k * C_F * C_O\n        \n        # Avoid division by zero if rho or cp_mix is zero\n        if rho == 0.0 or cp_mix == 0.0:\n            return np.zeros(3)\n\n        # ODE RHS components\n        dT_dt = (p_[\"Q\"] * w_mole) / (rho * cp_mix)\n        dYF_dt = (-p_[\"W_F\"] * w_mole) / rho\n        dYO_dt = (-p_[\"S\"] * p_[\"W_O\"] * w_mole) / rho\n        \n        return np.array([dT_dt, dYF_dt, dYO_dt])\n\n    def compute_jacobian_numerical(x_star, p_):\n        \"\"\"\n        Computes the Jacobian matrix numerically using a central difference scheme.\n        x_star: state vector at which to evaluate the Jacobian\n        p_: dictionary of parameters\n        \"\"\"\n        n = len(x_star)\n        J = np.zeros((n, n))\n        \n        eps_rel = 1e-6\n        eps_abs = 1e-9\n\n        for j in range(n):\n            h_j = eps_rel * abs(x_star[j]) + eps_abs\n            \n            x_plus = np.copy(x_star)\n            x_plus[j] += h_j\n            \n            x_minus = np.copy(x_star)\n            x_minus[j] -= h_j\n            \n            f_plus = compute_rhs(x_plus, p_)\n            f_minus = compute_rhs(x_minus, p_)\n            \n            j_col = (f_plus - f_minus) / (2.0 * h_j)\n            J[:, j] = j_col\n            \n        return J\n\n    results = []\n    inv_tau_split = 1.0 / TAU_SPLIT\n\n    for state in test_cases:\n        # 1. Compute the Jacobian at the given state\n        J = compute_jacobian_numerical(state, params)\n        \n        # 2. Compute the eigenvalues of the Jacobian\n        eigenvalues = np.linalg.eigvals(J)\n        \n        # 3. Count the number of slow modes\n        slow_modes_count = 0\n        for lam in eigenvalues:\n            if abs(lam.real) = inv_tau_split:\n                slow_modes_count += 1\n        \n        results.append(slow_modes_count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在确定了系统的慢变量之后，下一步通常是为那些被忽略的快动态对慢变量的影响建立模型，这便是“封闭模型”的作用。此练习  关注于一个关键的实际步骤：从高保真数据中校准封闭模型参数。您将学习如何构建并求解一个有约束的最小二乘法问题，其目标是在保证物理定律（如组分质量分数的有界性）的前提下，最小化模型预测与数据之间的失配，从而创建一个既准确又符合物理规律的模型。",
            "id": "4057083",
            "problem": "考虑一个简化的降阶模型，用于表示一个反应标量，该标量代表无量纲化的组分质量分数，记为 $y \\in [0,1]$。设高保真直接数值模拟 (DNS) 数据在均匀间隔的时间点上提供了一系列快照 $\\{y^{\\mathrm{DNS}}_k\\}_{k=0}^{K}$，时间步长为 $\\Delta t$。用于描述具有线性衰减和未解析闭合项的单步反应的降阶模型 (ROM)，由以下显式欧拉离散给出\n$$\n\\widehat{y}_{k+1}(\\theta) \\;=\\; y^{\\mathrm{DNS}}_k \\;+\\; \\Delta t \\,\\Big( -\\lambda \\, y^{\\mathrm{DNS}}_k \\;+\\; s \\, y^{\\mathrm{DNS}}_k \\big(1 - y^{\\mathrm{DNS}}_k\\big) \\;+\\; \\theta \\, y^{\\mathrm{DNS}}_k \\big(1 - y^{\\mathrm{DNS}}_k\\big) \\Big),\n$$\n其中 $s$ 和 $\\lambda$ 是已知的非负参数，$\\theta$ 是一个待标定的标量闭合系数。闭合项被选为 $\\tau(y;\\theta) = \\theta \\, y(1-y)$ 以满足边界守恒特性 $\\tau(0;\\theta)=0$ 和 $\\tau(1;\\theta)=0$，确保纯态在闭合项的贡献下保持不变。\n\n标定问题被构建为一个约束优化问题：找到 $\\theta$ 以最小化单步预测与DNS的总平方失配，\n$$\nJ(\\theta) \\;=\\; \\sum_{k=0}^{K-1} \\left(\\widehat{y}_{k+1}(\\theta) - y^{\\mathrm{DNS}}_{k+1}\\right)^2,\n$$\n并受有界性约束的限制，该约束强制从DNS状态出发的单步ROM预测值保持在物理上允许的区间内，\n$$\n0 \\;\\le\\; \\widehat{y}_{k+1}(\\theta) \\;\\le\\; 1 \\quad \\text{for all } k \\in \\{0,\\dots,K-1\\}.\n$$\n\n从组分守恒和反应动力学的第一性原理出发，其基本原理是组分质量分数满足生成速率和消耗速率之间的平衡。ROM使用此平衡的一个低阶表示，其中包括一个logistic生成项 $s \\, y(1-y)$ 和一个线性消耗项 $-\\lambda y$，而未解析的子网格贡献则由闭合项 $\\tau(y;\\theta) = \\theta \\, y(1-y)$ 参数化，该闭合项在纯态时为零，以在边界处保持组分守恒。\n\n您的任务是编写一个完整的程序，为每个指定的测试用例（参数和DNS生成协议如下），构建关于 $\\theta$ 的约束最小二乘标定问题，求解该问题，并返回每个用例的最优 $\\theta$。所有量均为无量纲。不出现角度。不出现百分比。\n\n必需的算法规格：\n- 对于每个用例，必须使用上面给出的显式欧拉更新，通过模拟带有真实闭合参数 $\\theta^\\star$ 的相同ROM来生成DNS数据 $\\{y^{\\mathrm{DNS}}_k\\}_{k=0}^{K}$。具体来说，对于给定的初始条件 $y^{\\mathrm{DNS}}_0$，使用测试用例中提供的真实闭合参数 $\\theta^\\star$，为 $k \\in \\{0,\\dots,K-1\\}$ 迭代计算 $y^{\\mathrm{DNS}}_{k+1}$。\n- 标定过程必须仅使用生成的DNS序列和已知参数 $(s,\\lambda,\\Delta t)$，并且除了生成DNS数据外，不得使用 $\\theta^\\star$。优化变量是单个标量 $\\theta$。\n- 对每个 $k$ 的有界性约束必须完全按照上述方式施加于 $\\widehat{y}_{k+1}(\\theta)$。\n- 每个测试用例的最终答案必须是作为浮点数的最优 $\\theta$。您必须按照下面指定的格式，将所有用例的结果作为单个列表输出在单行上。\n\n测试套件：\n- 用例 A (理想情况): $s = 2.0$, $\\lambda = 0.5$, $\\Delta t = 0.1$, $K = 10$, $y^{\\mathrm{DNS}}_0 = 0.2$, $\\theta^\\star = 0.3$.\n- 用例 B (近边界增长): $s = 1.5$, $\\lambda = 0.2$, $\\Delta t = 0.2$, $K = 8$, $y^{\\mathrm{DNS}}_0 = 0.05$, $\\theta^\\star = 0.8$.\n- 用例 C (近边界衰减): $s = 3.0$, $\\lambda = 1.2$, $\\Delta t = 0.05$, $K = 12$, $y^{\\mathrm{DNS}}_0 = 0.9$, $\\theta^\\star = -0.4$.\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个用例的估计闭合系数，格式为用方括号括起来的逗号分隔列表（例如，$[\\theta_A,\\theta_B,\\theta_C]$）。\n- 每个 $\\theta$ 必须打印并精确到 $6$ 位小数。\n\n关于科学真实性和数值稳健性的说明：\n- 所选择的闭合项 $\\tau(y;\\theta) = \\theta\\,y(1-y)$ 通过其构造保证了边界守恒特性，这对于取值在 $[0,1]$ 范围内的组分质量分数至关重要。\n- 有界性约束 $0 \\le \\widehat{y}_{k+1}(\\theta) \\le 1$ 强制了在标定闭合项下，从DNS状态做出的单步预测的物理可容许性。\n- 您可以使用任何数学上等价的方法来求解关于 $\\theta$ 的约束最小二乘问题。因为对于固定的 $\\{y^{\\mathrm{DNS}}_k\\}$，约束在 $\\theta$ 上是线性的，所以可以将闭式无约束最小二乘解投影到通过对每步边界取交集得到的可行区间上，这种方法是可接受的。\n\n您的程序必须仅以上述确切格式生成所需的单行输出。",
            "solution": "该问题要求在一个用于反应性组分质量分数 $y$ 的降阶模型 (ROM) 中，对一个标量闭合系数 $\\theta$ 进行标定。此标定被表述为一个约束最小二乘问题，我们将对此进行分析和求解。\n\nROM由显式欧拉离散给出：\n$$\n\\widehat{y}_{k+1}(\\theta) \\;=\\; y^{\\mathrm{DNS}}_k \\;+\\; \\Delta t \\,\\Big( -\\lambda \\, y^{\\mathrm{DNS}}_k \\;+\\; s \\, y^{\\mathrm{DNS}}_k \\big(1 - y^{\\mathrm{DNS}}_k\\big) \\;+\\; \\theta \\, y^{\\mathrm{DNS}}_k \\big(1 - y^{\\mathrm{DNS}}_k\\big) \\Big)\n$$\n其中 $\\{y^{\\mathrm{DNS}}_k\\}_{k=0}^{K}$ 是一系列高保真数据，$s$、$\\lambda$ 和 $\\Delta t$ 是已知参数。\n\n目标是找到能最小化目标函数 $J(\\theta)$ 的 $\\theta$，\n$$\nJ(\\theta) \\;=\\; \\sum_{k=0}^{K-1} \\left(\\widehat{y}_{k+1}(\\theta) - y^{\\mathrm{DNS}}_{k+1}\\right)^2\n$$\n并满足物理有界性约束：\n$$\n0 \\;\\le\\; \\widehat{y}_{k+1}(\\theta) \\;\\le\\; 1 \\quad \\text{for all } k \\in \\{0,\\dots,K-1\\}.\n$$\n\n首先，我们将单步预测 $\\widehat{y}_{k+1}(\\theta)$ 表示为一种能分离含 $\\theta$ 项的形式。为简化表示，我们令 $y_k \\equiv y^{\\mathrm{DNS}}_k$。\n我们可以将预测写为：\n$$\n\\widehat{y}_{k+1}(\\theta) = \\left[ y_k + \\Delta t \\Big( -\\lambda y_k + s y_k(1 - y_k) \\Big) \\right] + \\theta \\left[ \\Delta t \\, y_k(1-y_k) \\right]\n$$\n我们为每个时间步 $k \\in \\{0, \\dots, K-1\\}$ 定义以下量：\n1.  基础模型（不含闭合项）的预测：\n    $$\n    c_k = y_k + \\Delta t \\Big( -\\lambda y_k + s y_k(1-y_k) \\Big)\n    $$\n2.  $\\theta$ 的系数：\n    $$\n    a_k = \\Delta t \\, y_k(1-y_k)\n    $$\n根据这些定义，ROM预测为 $\\widehat{y}_{k+1}(\\theta) = c_k + a_k \\theta$。\n\n目标函数 $J(\\theta)$ 是残差的平方和，其中第 $k$ 步的残差是 $r_k(\\theta) = \\widehat{y}_{k+1}(\\theta) - y_{k+1}$。\n$$\nr_k(\\theta) = (c_k + a_k \\theta) - y_{k+1} = a_k \\theta - (y_{k+1} - c_k)\n$$\n我们定义 $b_k = y_{k+1} - c_k$。目标函数变为：\n$$\nJ(\\theta) = \\sum_{k=0}^{K-1} (a_k \\theta - b_k)^2\n$$\n这是关于 $\\theta$ 的一个二次函数。为了找到无约束最小值，我们对 $J(\\theta)$ 求关于 $\\theta$ 的导数，并令其结果为零：\n$$\n\\frac{dJ}{d\\theta} = \\sum_{k=0}^{K-1} 2(a_k \\theta - b_k) a_k = 2\\theta \\left(\\sum_{k=0}^{K-1} a_k^2\\right) - 2\\left(\\sum_{k=0}^{K-1} a_k b_k\\right) = 0\n$$\n假设 $\\sum a_k^2 \\neq 0$（除非所有 $y_k$ 都是平凡值，即 $0$ 或 $1$，否则该条件成立），则 $\\theta$ 的无约束最小二乘解为：\n$$\n\\theta_{\\mathrm{unc}} = \\frac{\\sum_{k=0}^{K-1} a_k b_k}{\\sum_{k=0}^{K-1} a_k^2}\n$$\n\n接下来，我们分析有界性约束。对于每个 $k \\in \\{0, \\dots, K-1\\}$，我们必须有：\n$$\n0 \\le c_k + a_k \\theta \\le 1\n$$\n这就得到了一对关于 $\\theta$ 的线性不等式：\n$$\n-c_k \\le a_k \\theta \\quad \\text{and} \\quad a_k \\theta \\le 1 - c_k\n$$\n由于 $y \\in [0,1]$，项 $y_k(1-y_k)$ 是非负的。又因为 $\\Delta t  0$，我们有 $a_k = \\Delta t \\, y_k(1-y_k) \\ge 0$。\n如果 $a_k  0$，我们可以用它来除，从而得到关于 $\\theta$ 的界限：\n$$\n-\\frac{c_k}{a_k} \\le \\theta \\quad \\text{and} \\quad \\theta \\le \\frac{1-c_k}{a_k}\n$$\n令 $L_k = -c_k/a_k$ 和 $U_k = (1-c_k)/a_k$。对于每个 $a_k  0$ 的步长 $k$，约束要求 $\\theta \\in [L_k, U_k]$。\n如果 $a_k = 0$（即，如果 $y_k=0$ 或 $y_k=1$），约束变为 $0 \\le c_k \\le 1$。这是对基础模型参数的一个条件，并不约束 $\\theta$。问题参数的选择保证了此条件得到满足。这些步骤不提供对 $\\theta$ 的界限，在确定可行集时可以忽略。\n\n$\\theta$ 的总可行集是所有单步约束区间的交集：\n$$\n\\theta \\in \\bigcap_{k \\text{ with } a_k0} [L_k, U_k]\n$$\n这个交集是一个单一区间 $[L, U]$，其中：\n$$\nL = \\max_{\\{k \\,|\\, a_k0\\}} \\{L_k\\} \\quad \\text{and} \\quad U = \\min_{\\{k \\,|\\, a_k0\\}} \\{U_k\\}\n$$\n如果索引集 $\\{k \\,|\\, a_k0\\}$ 为空，则可行集为 $(-\\infty, \\infty)$。\n\n问题现在简化为在区间 $[L, U]$ 上最小化凸二次函数 $J(\\theta)$。通过将无约束最小值 $\\theta_{\\mathrm{unc}}$ 投影到这个区间上找到解：\n$$\n\\theta_{\\mathrm{opt}} = \n\\begin{cases} \nL  \\text{如果 } \\theta_{\\mathrm{unc}}  L \\\\\n\\theta_{\\mathrm{unc}}  \\text{如果 } L \\le \\theta_{\\mathrm{unc}} \\le U \\\\\nU  \\text{如果 } \\theta_{\\mathrm{unc}}  U\n\\end{cases}\n$$\n这可以用一个裁剪函数紧凑地写成：$\\theta_{\\mathrm{opt}} = \\mathrm{clip}(\\theta_{\\mathrm{unc}}, L, U)$。\n\n问题还指明，DNS数据 $\\{y^{\\mathrm{DNS}}_k\\}$ 是使用具有“真实”参数 $\\theta^\\star$ 的相同模型结构生成的。这意味着：\n$$\ny_{k+1} = y_k + \\Delta t \\left( -\\lambda y_k + s y_k(1-y_k) + \\theta^\\star y_k(1-y_k) \\right) = c_k + a_k \\theta^\\star\n$$\n由此，我们得到 $y_{k+1} - c_k = a_k \\theta^\\star$。将此代入 $b_k$ 的定义，我们得到 $b_k = a_k \\theta^\\star$。现在，如果我们将此代入无约束最优解的表达式中：\n$$\n\\theta_{\\mathrm{unc}} = \\frac{\\sum a_k (a_k \\theta^\\star)}{\\sum a_k^2} = \\frac{\\theta^\\star \\sum a_k^2}{\\sum a_k^2} = \\theta^\\star\n$$\n这表明，在这种理想化的“孪生实验”设置中，无约束最小二乘解恰好是真实参数 $\\theta^\\star$。由于数据是用 $\\theta^\\star$ 生成的，其轨迹必须是物理上有界的，这意味着 $\\theta^\\star$ 本身满足所有约束，即 $L \\le \\theta^\\star \\le U$。因此，假设没有数值精度误差，最终的最优解 $\\theta_{\\mathrm{opt}}$ 将等于 $\\theta^\\star$。\n\n最终的算法如下：\n1.  对于每个测试用例，通过使用给定的 $\\theta^\\star$ 迭代应用更新规则来生成数据序列 $\\{y_k^{\\mathrm{DNS}}\\}_{k=0}^{K}$。\n2.  使用生成的序列，计算 $k=0, \\dots, K-1$ 的向量 $a_k$、$b_k$ 和 $c_k$。\n3.  计算无约束解 $\\theta_{\\mathrm{unc}}$。\n4.  根据有界性约束确定可行区间 $[L, U]$。\n5.  通过将 $\\theta_{\\mathrm{unc}}$ 裁剪到区间 $[L, U]$ 来计算最优约束解 $\\theta_{\\mathrm{opt}}$。\n6.  收集每个用例得到的 $\\theta_{\\mathrm{opt}}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the constrained least-squares calibration problem for the closure coefficient theta\n    for a set of test cases.\n    \"\"\"\n    \n    # Test suite defined in the problem statement.\n    test_cases = [\n        # Case A (happy path)\n        {'s': 2.0, 'lam': 0.5, 'dt': 0.1, 'K': 10, 'y0': 0.2, 'theta_star': 0.3},\n        # Case B (near-boundary growth)\n        {'s': 1.5, 'lam': 0.2, 'dt': 0.2, 'K': 8, 'y0': 0.05, 'theta_star': 0.8},\n        # Case C (near-boundary decay)\n        {'s': 3.0, 'lam': 1.2, 'dt': 0.05, 'K': 12, 'y0': 0.9, 'theta_star': -0.4},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        s = case['s']\n        lam = case['lam']\n        dt = case['dt']\n        K = case['K']\n        y0 = case['y0']\n        theta_star = case['theta_star']\n\n        # Step 1: Generate DNS data using the model with the true parameter theta_star.\n        y_dns = np.zeros(K + 1)\n        y_dns[0] = y0\n        for k in range(K):\n            y_k = y_dns[k]\n            # Production/destruction term: s * y(1-y) - lambda * y\n            # Combined closure term: theta_star * y(1-y)\n            # The model can be grouped as: -lambda * y + (s + theta_star) * y(1-y)\n            source_term = -lam * y_k + (s + theta_star) * y_k * (1 - y_k)\n            y_dns[k+1] = y_k + dt * source_term\n            \n        # Extract y_k and y_{k+1} sequences for calibration\n        y_k_seq = y_dns[:-1]\n        y_k_plus_1_seq = y_dns[1:]\n\n        # Step 2: Set up the least-squares problem AX=B where X is theta\n        # A_k = a_k = dt * y_k * (1 - y_k)\n        # B_k = b_k = y_{k+1} - c_k, where c_k is the base model prediction\n        \n        # Coefficient of theta\n        a_k_vec = dt * y_k_seq * (1 - y_k_seq)\n        \n        # Base model prediction (without closure term)\n        c_k_vec = y_k_seq + dt * (-lam * y_k_seq + s * y_k_seq * (1 - y_k_seq))\n        \n        # Target vector\n        b_k_vec = y_k_plus_1_seq - c_k_vec\n\n        # Step 3: Solve for the unconstrained optimal theta\n        sum_a_sq = np.sum(a_k_vec**2)\n        sum_a_b = np.sum(a_k_vec * b_k_vec)\n        \n        if sum_a_sq  1e-15: # Avoid division by zero in degenerate cases\n            # If all a_k are zero, theta is unconstrained by the objective.\n            # Any value is optimal. We can pick 0 or handle it as an error.\n            # However, problem setup guarantees this won't be the primary path.\n            theta_unc = 0.0\n        else:\n            theta_unc = sum_a_b / sum_a_sq\n\n        # Step 4: Determine the feasible interval [L, U] from boundedness constraints\n        # 0 = c_k + a_k * theta = 1\n        \n        # We only consider steps where a_k > 0, as a_k=0 provides no constraint on theta\n        mask = a_k_vec > 1e-15\n        \n        if np.any(mask):\n            a_k_masked = a_k_vec[mask]\n            c_k_masked = c_k_vec[mask]\n            \n            # Lower bounds: L_k = -c_k / a_k\n            lower_bounds_k = -c_k_masked / a_k_masked\n            # Upper bounds: U_k = (1 - c_k) / a_k\n            upper_bounds_k = (1 - c_k_masked) / a_k_masked\n            \n            # The overall bounds are the tightest of these\n            L_bound = np.max(lower_bounds_k)\n            U_bound = np.min(upper_bounds_k)\n        else:\n            # If no a_k > 0, theta is unconstrained by bounds\n            L_bound = -np.inf\n            U_bound = np.inf\n            \n        # Step 5: Project the unconstrained solution onto the feasible interval\n        theta_opt = np.clip(theta_unc, L_bound, U_bound)\n        \n        results.append(theta_opt)\n\n    # Final print statement in the exact required format.\n    # Each theta must be rounded to exactly 6 decimal places.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "对于许多工程问题，系统运行参数（如入口温度或压力）会发生变化，这意味着一个固定的降阶基可能无法在整个参数空间内都保持最优。这个高级实践  探讨了当参数变化时，如何在代表不同状态的降阶基之间进行插值。此练习引入了一个现代几何视角，将所有可能的基视为格拉斯曼流形上的点，并比较了简单的线性插值与更精确的测地线插值（代表在该弯曲空间上的“最短路径”）。掌握如何正确地插值基函数，是构建在不同工况下都能保持高精度的参数化降阶模型的关键。",
            "id": "4057100",
            "problem": "考虑计算燃烧学中反应流的降阶模型，其中在参数值 $\\mu$ 处的每个火焰状态由 $\\mathbb{R}^n$ 的一个 $r$ 维子空间表示，该子空间由正交矩阵 $U \\in \\mathbb{R}^{n \\times r}$ 的列张成。这种抽象与通过本征正交分解 (Proper Orthogonal Decomposition, POD) 获得的基是一致的。$\\mathbb{R}^n$ 的所有 $r$ 维子空间的集合构成了格拉斯曼流形 (Grassmann manifold) $G(r,n)$。给定两个参数值 $\\mu_0$ 和 $\\mu_1$ 及其关联的子空间 $U_0$ 和 $U_1$，需要寻求一个对于 $t \\in [0,1]$ 的插值 $U(t)$（其中 $t=0$ 对应 $\\mu_0$，$t=1$ 对应 $\\mu_1$）。\n\n从黎曼几何和矩阵分析中的定义开始：\n- 格拉斯曼流形 $G(r,n)$ 具有从斯蒂费尔流形 (Stiefel manifold) 继承的自然黎曼结构。在点 $U \\in G(r,n)$ 处的切空间可以等同于 $\\{ \\Xi \\in \\mathbb{R}^{n \\times r} \\mid U^\\top \\Xi = 0 \\}$。\n- 奇异值分解 (Single Value Decomposition, SVD) 是实矩阵 $A$ 的一种分解 $A = X \\Sigma Y^\\top$，其中 $X$ 和 $Y$ 是正交矩阵，$\\Sigma$ 是具有非负元素的对角矩阵。\n- 两个具有正交基 $U_0$ 和 $U_1$ 的子空间之间的主夹角是通过 $U_0^\\top U_1$ 的奇异值分解定义的，它们位于 $[0,\\pi/2]$ 区间内。\n- 两个具有正交基 $U$ 和 $V$ 的子空间之间的投影距离是 $d_{\\mathrm{proj}}(U,V) = \\lVert U U^\\top - V V^\\top \\rVert_F$，其中 $\\lVert \\cdot \\rVert_F$ 是弗罗贝尼乌斯范数 (Frobenius norm)。\n\n您必须实现并比较 $U_0$ 和 $U_1$ 之间的两种插值策略：\n1. 一种基于切空间的插值，它使用从 $U_0$ 处的对数映射构造的一阶收缩，并在切空间中进行线性插值，然后进行正交规范化。具体来说，计算一个在 $U_0$ 处指向 $U_1$ 的切向量 $\\Xi$，然后通过将 $t \\Xi$ 加到 $U_0$ 上来定义 $U_{\\mathrm{tan}}(t)$，并对结果的列进行重新正交规范化以获得 $G(r,n)$ 的一个元素。\n2. 一种在 $G(r,n)$ 上基于测地线的插值，它使用根据 $U_0$ 和 $U_1$ 之间的主夹角定义的格拉斯曼测地线以及流形上主向量的平行传输。\n\n为评估插值精度，请定义一个沿着 $U_0$ 和 $U_1$ 之间真实格拉斯曼测地线的基准子空间 $U^\\star(t)$，并计算投影距离误差 $e_{\\mathrm{tan}}(t) = d_{\\mathrm{proj}}(U_{\\mathrm{tan}}(t),U^\\star(t))$ 和 $e_{\\mathrm{geo}}(t) = d_{\\mathrm{proj}}(U_{\\mathrm{geo}}(t),U^\\star(t))$。\n\n您的程序必须实现以下参数化案例的测试套件，每个案例由 $(n,r,\\text{angles},t,\\text{seed})$ 完全指定，其中 $\\text{angles}$ 是一个包含 $r$ 个主夹角的列表（以弧度为单位），这些主夹角定义了 $U_0$ 和 $U_1$ 之间的测地线位移，$t \\in [0,1]$ 是插值分数，$\\text{seed}$ 是一个用于为伪随机数生成器提供种子的整数，以构造可复现的正交基：\n- 案例 1：$(n,r,\\text{angles},t,\\text{seed}) = (40,5,[0.05,0.08,0.10,0.06,0.04],0.5,1234)$。\n- 案例 2：$(n,r,\\text{angles},t,\\text{seed}) = (50,6,[0.50,0.45,0.40,0.35,0.30,0.25],0.7,5678)$。\n- 案例 3：$(n,r,\\text{angles},t,\\text{seed}) = (60,5,[1.20,1.10,1.00,0.90,0.80],0.5,91011)$。\n- 案例 4：$(n,r,\\text{angles},t,\\text{seed}) = (30,4,[0.00,0.00,0.00,0.00],0.3,31415)$。\n- 案例 5：$(n,r,\\text{angles},t,\\text{seed}) = (25,1,[1.00],0.5,27182)$。\n\n对于每个案例，通过对给定 $\\text{seed}$ 生成的 $\\mathbb{R}^{n \\times r}$ 中的随机高斯矩阵进行正交规范化来构造 $U_0$。构造一个正交法向基 $L \\in \\mathbb{R}^{n \\times r}$，它是投影到 $U_0$ 列空间的正交补上的随机高斯矩阵的 QR 分解的 Q 因子。构造 $V \\in \\mathbb{R}^{r \\times r}$，它是 $\\mathbb{R}^{r \\times r}$ 中随机高斯矩阵的 QR 分解的正交因子。定义一个切向位移 $\\Xi = L S V^\\top$，其中 $S = \\mathrm{diag}(\\text{angles})$。通过从 $U_0$ 沿 $\\Xi$ 在 $t=1$ 处的格拉斯曼测地线定义端点子空间 $U_1$，并使用相同公式在给定的 $t$ 处定义基准测地线 $U^\\star(t)$。\n\n对于每个案例，计算：\n- 基于切空间的插值 $U_{\\mathrm{tan}}(t)$，通过使用在 $U_0$ 处的格拉斯曼对数映射获得指向 $U_1$ 的切向量，执行一阶收缩 $U_0 + t \\Xi$，并对结果进行正交规范化。\n- 基于测地线的插值 $U_{\\mathrm{geo}}(t)$，通过使用 $U_0$ 和 $U_1$ 之间的主夹角和格拉斯曼测地线表达式。\n- 误差 $e_{\\mathrm{tan}}(t)$ 和 $e_{\\mathrm{geo}}(t)$，每个都表示为四舍五入到 $10^{-8}$ 的浮点数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个项目对应一个案例，是一个包含两个浮点数 $[e_{\\mathrm{tan}}(t),e_{\\mathrm{geo}}(t)]$ 的列表，因此最终输出格式为 $[[e_{\\mathrm{tan},1},e_{\\mathrm{geo},1}],[e_{\\mathrm{tan},2},e_{\\mathrm{geo},2}],\\ldots,[e_{\\mathrm{tan},5},e_{\\mathrm{geo},5}]]$.",
            "solution": "用户提供了有效的问题陈述。\n\n### 1. 问题阐述与验证\n该问题要求实现并比较两种在 $\\mathbb{R}^n$ 的两个 $r$ 维子空间之间进行插值的方法，这两个子空间由正交矩阵 $U_0, U_1 \\in \\mathbb{R}^{n \\times r}$ 表示。所有此类子空间的集合构成了格拉斯曼流形 (Grassmann manifold) $G(r,n)$。插值由 $t \\in [0,1]$ 参数化。问题指定了一系列测试案例，其中给定了初始子空间 $U_0$ 和分离“距离”（通过主夹角），并由此构造第二个子空间 $U_1$ 和基准测地线路径 $U^\\star(t)$。然后将两种插值方法与此基准进行比较。\n\n该问题在黎曼几何 (Riemannian geometry) 和数值线性代数方面具有坚实的数学和科学基础，并在计算科学中有直接应用。指令具体、自成体系，并为生成输入和计算输出提供了清晰的流程，使得问题适定且算法上易于处理。因此，该问题是有效的。\n\n### 2. 测试案例和基准的构建\n对于由参数 $(n, r, \\text{angles}, t, \\text{seed})$ 指定的每个测试案例，子空间按以下方式构造：\n- **初始子空间 $U_0$**：使用提供的种子生成一个随机矩阵 $A \\in \\mathbb{R}^{n \\times r}$，其元素来自标准正态分布。使用 QR 分解 $A=QR$ 对其列进行正交规范化，得到 $U_0 = Q \\in \\mathbb{R}^{n \\times r}$，使得 $U_0^\\top U_0 = I_r$。\n- **辅助基 $L$ 和 $V$**：\n    - 构造一个在 $U_0$ 列空间的正交补中的子空间的正交基 $L \\in \\mathbb{R}^{n \\times r}$。这是通过生成一个随机矩阵 $G \\in \\mathbb{R}^{n \\times r}$ 并对其在正交补上的投影 $G_\\perp = (I - U_0 U_0^\\top)G$ 进行正交规范化来完成的。\n    - 构造一个正交矩阵 $V \\in \\mathbb{R}^{r \\times r}$，作为 $\\mathbb{R}^{r \\times r}$ 中一个随机矩阵的 QR 分解的 Q 因子。\n- **测地线路径和端点**：$U_0$ 和 $U_1$ 之间的主夹角 $\\theta_i$ 作为列表 `angles` 提供。设 $S = \\mathrm{diag}(\\theta_1, \\dots, \\theta_r)$。从 $U_0$ 开始，初始速度为 $\\Xi = L S V^\\top$（一个在 $U_0$ 处的切向量，因为 $U_0^\\top L = 0$）的格拉斯曼测地线 $U(\\tau)$ 由以下公式给出：\n$$ U(\\tau) = (U_0 V \\cos(S\\tau) + L \\sin(S\\tau)) V^\\top $$\n其中 $\\cos(S\\tau)$ 和 $\\sin(S\\tau)$ 是对角矩阵，其元素为 $\\cos(\\theta_i \\tau)$ 和 $\\sin(\\theta_i \\tau)$。\n对于给定的插值分数 $t$，基准路径是 $U^\\star(t) = U(t)$。第二个子空间 $U_1$ 定义为该测地线在 $\\tau=1$ 处的端点，即 $U_1 = U(1)$。\n\n### 3. 基于测地线的插值 ($U_{\\mathrm{geo}}(t)$)\n此方法旨在仅使用端点子空间 $U_0$ 和 $U_1$ 重构精确的测地线路径。\n1.  **主夹角和主向量**：计算矩阵乘积 $U_0^\\top U_1 = P C Q^\\top$ 的奇异值分解 (SVD)。奇异值是 $C$ 的对角元素，它们是主夹角的余弦值，即 $\\Theta = \\arccos(C)$。矩阵 $P, Q \\in \\mathbb{R}^{r \\times r}$ 是正交的，包含主向量的系数。\n2.  **正交主方向**：计算在 $U_0$ 列空间的正交补中的正交主方向矩阵 $L_{\\text{comp}}$。这些方向由 $U_1$ 主向量中与 $U_0$ 主向量正交的部分确定。关系式为 $L_{\\text{comp}} \\sin(\\Theta) = (U_1 Q - U_0 P C)$。我们可以通过对 $\\sin(\\Theta)$ 求逆来解出 $L_{\\text{comp}}$，并小心处理任何 $\\sin(\\theta_i) = 0$ 的情况。\n3.  **测地线公式**：然后，测地线路径被重构为：\n    $$ U_{\\mathrm{geo}}(t) = (U_0 P \\cos(\\Theta t) + L_{\\text{comp}} \\sin(\\Theta t)) Q^\\top $$\n根据我们测试案例的构造方式，计算出的角度 $\\Theta$ 将与输入 `angles` $S$ 匹配，矩阵 $P$ 和 $Q$ 将对应于 $V$，并且 $L_{\\text{comp}}$ 将与 $L$ 相同。因此，$U_{\\mathrm{geo}}(t)$ 将与基准 $U^\\star(t)$ 相同，相关的误差 $e_{\\mathrm{geo}}(t)$ 预期为零（在浮点精度范围内）。\n\n### 4. 基于切空间的插值 ($U_{\\mathrm{tan}}(t)$)\n该方法是一阶近似。它涉及在 $U_0$ 的切空间中进行线性插值，然后通过收缩映射将结果映射回格拉斯曼流形。\n1.  **对数映射**：我们计算在 $U_0$ 处“指向”$U_1$ 的切向量 $\\Xi \\in \\mathbb{R}^{n \\times r}$。该向量由格拉斯曼对数映射给出，$\\Xi = \\log_{U_0}(U_1)$。对数映射的一个标准公式是 $\\log_{U_0}(U_1) = A' \\arctan(\\Sigma') (B')^\\top$，它源自矩阵 $(U_1 - U_0(U_0^\\top U_1))(U_0^\\top U_1)^{-1} = A'\\Sigma'(B')^\\top$ 的 SVD 分解。\n2.  **线性插值**：通过从 $U_0$ 沿着方向 $\\Xi$ 移动一小部分 $t$ 来计算切空间中的一个点：\n    $$ U_{\\text{approx}} = U_0 + t \\Xi $$\n    注意，$U_{\\text{approx}}$ 的列不保证是正交规范的。\n3.  **收缩**：为了将 $U_{\\text{approx}}$ 映射回流形 $G(r,n)$，我们应用一个收缩。一个常用且有效的收缩是简单地使用 QR 分解对 $U_{\\text{approx}}$ 的列进行正交规范化。得到的正交基 $U_{\\mathrm{tan}}(t)$ 就是最终的插值子空间。\n\n该方法用切空间中的直线来近似弯曲的测地线路径。对于 $U_0$ 和 $U_1$ 之间的小距离（即小的主夹角）和小的 $t$ 值，该近似是准确的，但随着路径偏离切线，误差会增大。\n\n### 5. 误差计算\n每种插值方法的准确性通过到基准子空间 $U^\\star(t)$ 的投影距离来量化。到正交矩阵 $U$ 列空间上的投影算子是 $P_U = UU^\\top$。投影距离是两个此类投影算子之差的弗罗贝尼乌斯范数：\n$$ d_{\\mathrm{proj}}(U, V) = \\lVert UU^\\top - VV^\\top \\rVert_F $$\n基于切空间和基于测地线的插值的误差分别为：\n- $e_{\\mathrm{tan}}(t) = d_{\\mathrm{proj}}(U_{\\mathrm{tan}}(t), U^\\star(t))$\n- $e_{\\mathrm{geo}}(t) = d_{\\mathrm{proj}}(U_{\\mathrm{geo}}(t), U^\\star(t))$\n\n最终的实现将为每个指定的测试案例计算这两个误差值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import qr, svd\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (40, 5, [0.05, 0.08, 0.10, 0.06, 0.04], 0.5, 1234),\n        (50, 6, [0.50, 0.45, 0.40, 0.35, 0.30, 0.25], 0.7, 5678),\n        (60, 5, [1.20, 1.10, 1.00, 0.90, 0.80], 0.5, 91011),\n        (30, 4, [0.00, 0.00, 0.00, 0.00], 0.3, 31415),\n        (25, 1, [1.00], 0.5, 27182),\n    ]\n\n    results = []\n    for case in test_cases:\n        n, r, angles_list, t, seed = case\n        errors = run_case(n, r, angles_list, t, seed)\n        results.append(errors)\n\n    # Format the final output string as specified\n    result_str = \"[\" + \",\".join([f\"[{e1:.8f},{e2:.8f}]\" for e1, e2 in results]) + \"]\"\n    print(result_str)\n\ndef d_proj(U, V):\n    \"\"\"\n    Computes the projection distance between two subspaces.\n    \"\"\"\n    proj_U = U @ U.T\n    proj_V = V @ V.T\n    return np.linalg.norm(proj_U - proj_V, 'fro')\n\ndef run_case(n, r, angles_list, t, seed):\n    \"\"\"\n    Executes a single test case for Grassmann manifold interpolation.\n    \"\"\"\n    np.random.seed(seed)\n    angles = np.array(angles_list)\n\n    # Step 1: Construct U0, L, and V\n    U0, _ = qr(np.random.randn(n, r), mode='economic')\n    \n    G = np.random.randn(n, r)\n    G_perp = G - U0 @ (U0.T @ G)\n    L, _ = qr(G_perp, mode='economic')\n\n    V, _ = qr(np.random.randn(r, r), mode='economic')\n\n    # Step 2: Define the ground-truth geodesic path U_star(t) and endpoint U1\n    \n    # Ground truth U_star(t)\n    cos_St = np.diag(np.cos(angles * t))\n    sin_St = np.diag(np.sin(angles * t))\n    U_star_t = (U0 @ V @ cos_St + L @ sin_St) @ V.T\n\n    # Endpoint U1 (t=1)\n    cos_S = np.diag(np.cos(angles))\n    sin_S = np.diag(np.sin(angles))\n    U1 = (U0 @ V @ cos_S + L @ sin_S) @ V.T\n\n    # --- Interpolation Methods ---\n\n    # Method 1: Geodesic-based interpolation U_geo(t)\n    # Reconstruct the geodesic path from U0 and U1\n    M = U0.T @ U1\n    P, s_cos, QT = svd(M, full_matrices=False)\n    Q = QT.T\n    theta_comp = np.arccos(np.clip(s_cos, -1.0, 1.0))\n\n    s_cos_mat = np.diag(s_cos)\n    M_ortho = U1 @ Q - U0 @ P @ s_cos_mat\n    s_sin = np.sin(theta_comp)\n    \n    L_comp = np.zeros_like(M_ortho)\n    # Normalize columns where sin(theta) is not zero\n    non_zero_sines = s_sin > 1e-12\n    if np.any(non_zero_sines):\n        L_comp[:, non_zero_sines] = M_ortho[:, non_zero_sines] / s_sin[non_zero_sines]\n\n    cos_thetat = np.diag(np.cos(theta_comp * t))\n    sin_thetat = np.diag(np.sin(theta_comp * t))\n    U_geo_t = (U0 @ P @ cos_thetat + L_comp @ sin_thetat) @ Q.T\n\n    # Method 2: Tangent-based interpolation U_tan(t)\n    # Compute tangent vector via logarithm map at U0\n    M = U0.T @ U1\n    try:\n        M_inv = np.linalg.inv(M)\n        U1_perp = U1 - U0 @ M\n        temp_mat = U1_perp @ M_inv\n        \n        Lp, s_tan, QTp = svd(temp_mat, full_matrices=False, check_finite=False)\n        Vp = QTp.T\n        \n        theta_p = np.arctan(s_tan)\n        Xi = Lp @ np.diag(theta_p) @ Vp.T\n    except np.linalg.LinAlgError:\n        # Handle cases where M is singular (e.g., angles are pi/2)\n        # or for the zero-angle case where U1=U0.\n        Xi = np.zeros((n,r))\n\n    # Linear interpolation in tangent space and retraction (QR)\n    U_approx = U0 + t * Xi\n    U_tan_t, _ = qr(U_approx, mode='economic')\n\n    # --- Error Calculation ---\n    e_tan = d_proj(U_tan_t, U_star_t)\n    e_geo = d_proj(U_geo_t, U_star_t)\n    \n    return [e_tan, e_geo]\n\nsolve()\n```"
        }
    ]
}