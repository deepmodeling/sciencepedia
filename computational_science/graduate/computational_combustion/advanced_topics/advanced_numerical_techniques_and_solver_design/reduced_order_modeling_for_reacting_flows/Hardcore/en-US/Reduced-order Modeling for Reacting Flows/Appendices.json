{
    "hands_on_practices": [
        {
            "introduction": "Reduced-order models often gain efficiency by simplifying the underlying physical laws, such as the complex temperature-dependence of fluid properties. This first exercise provides analytical practice in this fundamental technique by replacing exact transport property models with simpler polynomial and rational function approximations. By working through this problem , you will not only derive these approximations but also quantify the resulting error in a physically meaningful quantity—viscous dissipation—providing a clear measure of the trade-off between model fidelity and simplicity.",
            "id": "4057133",
            "problem": "Consider a steady, laminar, incompressible, planar Couette flow of a single-species reacting gas between two infinite parallel plates separated by distance $H$. The bottom plate at $y=0$ is stationary, and the top plate at $y=H$ moves in the $x$-direction with constant speed $U$, producing a uniform shear rate $du/dy = U/H$. Assume the velocity field is $u(y) = Uy/H$ and all other velocity components vanish. The temperature field is prescribed as\n$$\nT(y) = T_{0} + \\Delta T \\cos\\!\\left(\\frac{\\pi y}{H}\\right),\n$$\nwith constants $T_{0}  0$ and $|\\Delta T|  T_{0}$. The dynamic viscosity and thermal conductivity are temperature-dependent according to the following well-tested models:\n- Exact viscosity: $\\mu_{\\text{ex}}(T) = \\mu_{0} \\exp\\!\\big(\\beta\\,(T/T_{0} - 1)\\big)$ with $\\mu_{0}  0$ and $\\beta  0$.\n- Exact thermal conductivity: $k_{\\text{ex}}(T) = k_{0} \\left(T/T_{0}\\right)^{m}$ with $k_{0}  0$ and real exponent $m$.\n\nA reduced-order model (ROM) is to be constructed by:\n- Approximating viscosity with a first-order polynomial about $T=T_{0}$:\n$$\n\\mu_{\\text{rom}}(T) = \\mu_{0}\\left[1 + \\beta\\left(\\frac{T}{T_{0}} - 1\\right)\\right].\n$$\n- Approximating thermal conductivity with a rational $[1/1]$ Padé approximation in the variable $x = T/T_{0} - 1$:\n$$\nk_{\\text{rom}}(T) = k_{0}\\,\\frac{1 + p x}{1 + q x},\n$$\nwhere the coefficients $p$ and $q$ are chosen so that the Taylor expansion of $k_{\\text{rom}}(T)$ about $x=0$ matches that of $k_{\\text{ex}}(T)$ up to and including $\\mathcal{O}(x^{2})$.\n\nUsing the Newtonian viscous dissipation per unit volume for incompressible flow,\n$$\n\\phi(y) = \\mu(T(y))\\left(\\frac{du}{dy}\\right)^{2},\n$$\ndefine the domain-integrated viscous energy dissipation per unit area as\n$$\n\\mathcal{D} = \\int_{0}^{H} \\phi(y)\\,dy.\n$$\nLet $\\mathcal{D}_{\\text{ex}}$ denote the dissipation computed with $\\mu_{\\text{ex}}(T(y))$ and $\\mathcal{D}_{\\text{rom}}$ denote the dissipation computed with $\\mu_{\\text{rom}}(T(y))$. Define the relative error in dissipation as\n$$\n\\varepsilon = \\frac{\\mathcal{D}_{\\text{rom}} - \\mathcal{D}_{\\text{ex}}}{\\mathcal{D}_{\\text{ex}}}.\n$$\n\nDerive $p$ and $q$ for $k_{\\text{rom}}(T)$ by matching $k_{\\text{ex}}(T)$ to $\\mathcal{O}(x^{2})$, construct $\\mu_{\\text{rom}}(T)$, and then evaluate $\\varepsilon$ exactly for the given $T(y)$ and $u(y)$ in terms of the dimensionless parameter\n$$\n\\alpha \\equiv \\beta\\,\\frac{\\Delta T}{T_{0}}.\n$$\nProvide your final result for $\\varepsilon$ as a single closed-form analytic expression in terms of $\\alpha$ and standard special functions if necessary. Report your answer as a dimensionless expression. Do not include any units. No numerical evaluation is required.",
            "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the principles of fluid mechanics and computational modeling, well-posed with all necessary information provided, and phrased in objective, unambiguous language. The setup, while idealized, represents a standard canonical problem in the study of shear flows. The task is multipart but logically consistent, requiring the derivation of Padé approximant coefficients and the calculation of an error metric for a reduced-order model of viscous dissipation.\n\nThe solution proceeds in two main parts. First, we derive the coefficients $p$ and $q$ for the rational approximation of the thermal conductivity, $k_{\\text{rom}}(T)$. Second, we compute the relative error $\\varepsilon$ between the viscous dissipation calculated with the reduced-order viscosity model, $\\mathcal{D}_{\\text{rom}}$, and the exact viscosity model, $\\mathcal{D}_{\\text{ex}}$.\n\nPart 1: Derivation of Padé approximant coefficients for $k_{\\text{rom}}(T)$.\n\nThe task is to find coefficients $p$ and $q$ for the $[1/1]$ Padé approximant $k_{\\text{rom}}(T)$ such that it matches the exact model $k_{\\text{ex}}(T)$ up to order $\\mathcal{O}(x^2)$, where $x = T/T_{0} - 1$.\n\nThe exact thermal conductivity is given by:\n$$\nk_{\\text{ex}}(T) = k_{0} \\left(\\frac{T}{T_{0}}\\right)^{m} = k_{0} (1+x)^{m}\n$$\nThe Taylor series expansion of $k_{\\text{ex}}(T)/k_{0}$ around $x=0$ is:\n$$\n(1+x)^{m} = 1 + mx + \\frac{m(m-1)}{2}x^{2} + \\mathcal{O}(x^{3})\n$$\n\nThe reduced-order model for thermal conductivity is given by:\n$$\nk_{\\text{rom}}(T) = k_{0}\\,\\frac{1 + p x}{1 + q x}\n$$\nThe Taylor series expansion of $k_{\\text{rom}}(T)/k_{0}$ around $x=0$ is found using the geometric series expansion for $(1+qx)^{-1}$:\n$$\n\\frac{1 + p x}{1 + q x} = (1+px)(1 - qx + q^{2}x^{2} - \\mathcal{O}(x^{3})) = 1 + (p-q)x + (q^{2}-pq)x^{2} + \\mathcal{O}(x^{3})\n$$\n$$\n= 1 + (p-q)x - q(p-q)x^{2} + \\mathcal{O}(x^{3})\n$$\n\nTo match the two expansions up to $\\mathcal{O}(x^2)$, we equate the coefficients of the powers of $x$:\nCoefficient of $x^{1}$:\n$$\np - q = m\n$$\nCoefficient of $x^{2}$:\n$$\n-q(p-q) = \\frac{m(m-1)}{2}\n$$\nSubstituting the first equation into the second gives:\n$$\n-q(m) = \\frac{m(m-1)}{2}\n$$\nAssuming $m \\neq 0$, we can divide by m to find $q$:\n$$\n-q = \\frac{m-1}{2} \\implies q = \\frac{1-m}{2}\n$$\nNow, we solve for $p$ using $p = m+q$:\n$$\np = m + \\frac{1-m}{2} = \\frac{2m + 1 - m}{2} = \\frac{m+1}{2}\n$$\nThese formulas are also valid for the special cases $m=0$ and $m=1$. Thus, the Padé coefficients are $p = (m+1)/2$ and $q = (1-m)/2$. Note that this part of the problem is independent of the calculation of $\\varepsilon$.\n\nPart 2: Evaluation of the relative error $\\varepsilon$.\n\nThe relative error in the domain-integrated viscous dissipation is defined as:\n$$\n\\varepsilon = \\frac{\\mathcal{D}_{\\text{rom}} - \\mathcal{D}_{\\text{ex}}}{\\mathcal{D}_{\\text{ex}}} = \\frac{\\mathcal{D}_{\\text{rom}}}{\\mathcal{D}_{\\text{ex}}} - 1\n$$\nThe integrated dissipation $\\mathcal{D}$ is given by:\n$$\n\\mathcal{D} = \\int_{0}^{H} \\mu(T(y))\\left(\\frac{du}{dy}\\right)^{2}\\,dy\n$$\nGiven the velocity field $u(y) = Uy/H$, the shear rate is a constant:\n$$\n\\frac{du}{dy} = \\frac{U}{H}\n$$\nLet's denote this constant shear rate by $S = U/H$. The dissipation integrals become:\n$$\n\\mathcal{D}_{\\text{ex}} = S^{2} \\int_{0}^{H} \\mu_{\\text{ex}}(T(y))\\,dy\n$$\n$$\n\\mathcal{D}_{\\text{rom}} = S^{2} \\int_{0}^{H} \\mu_{\\text{rom}}(T(y))\\,dy\n$$\nThe expression for the error simplifies to:\n$$\n\\varepsilon = \\frac{\\int_{0}^{H} \\mu_{\\text{rom}}(T(y))\\,dy}{\\int_{0}^{H} \\mu_{\\text{ex}}(T(y))\\,dy} - 1\n$$\n\nNext, we express the viscosity models as functions of $y$. The temperature-dependent term in the viscosity functions is:\n$$\n\\frac{T(y)}{T_{0}} - 1 = \\frac{T_{0} + \\Delta T \\cos(\\frac{\\pi y}{H})}{T_{0}} - 1 = \\frac{\\Delta T}{T_{0}} \\cos\\left(\\frac{\\pi y}{H}\\right)\n$$\nUsing the given dimensionless parameter $\\alpha = \\beta (\\Delta T / T_{0})$, we can write the viscosity models:\nThe exact viscosity model is:\n$$\n\\mu_{\\text{ex}}(T(y)) = \\mu_{0} \\exp\\left[\\beta\\left(\\frac{T(y)}{T_{0}} - 1\\right)\\right] = \\mu_{0} \\exp\\left[\\beta \\frac{\\Delta T}{T_{0}} \\cos\\left(\\frac{\\pi y}{H}\\right)\\right] = \\mu_{0} \\exp\\left[\\alpha \\cos\\left(\\frac{\\pi y}{H}\\right)\\right]\n$$\nThe reduced-order viscosity model is:\n$$\n\\mu_{\\text{rom}}(T(y)) = \\mu_{0}\\left[1 + \\beta\\left(\\frac{T(y)}{T_{0}} - 1\\right)\\right] = \\mu_{0}\\left[1 + \\alpha \\cos\\left(\\frac{\\pi y}{H}\\right)\\right]\n$$\n\nNow we evaluate the two integrals. Let's define $I_{\\text{ex}} = \\int_{0}^{H} \\mu_{\\text{ex}}(T(y))\\,dy$ and $I_{\\text{rom}} = \\int_{0}^{H} \\mu_{\\text{rom}}(T(y))\\,dy$.\n\nThe integral for the ROM is:\n$$\nI_{\\text{rom}} = \\int_{0}^{H} \\mu_{0}\\left[1 + \\alpha \\cos\\left(\\frac{\\pi y}{H}\\right)\\right]\\,dy = \\mu_{0}\\left[ \\int_{0}^{H} dy + \\alpha \\int_{0}^{H} \\cos\\left(\\frac{\\pi y}{H}\\right)\\,dy \\right]\n$$\n$$\nI_{\\text{rom}} = \\mu_{0}\\left[ [y]_{0}^{H} + \\alpha \\left[\\frac{H}{\\pi}\\sin\\left(\\frac{\\pi y}{H}\\right)\\right]_{0}^{H} \\right] = \\mu_{0}\\left[ H + \\alpha \\frac{H}{\\pi}(\\sin(\\pi) - \\sin(0)) \\right] = \\mu_{0}H\n$$\n\nThe integral for the exact model is:\n$$\nI_{\\text{ex}} = \\int_{0}^{H} \\mu_{0} \\exp\\left[\\alpha \\cos\\left(\\frac{\\pi y}{H}\\right)\\right]\\,dy\n$$\nWe use the substitution $\\theta = \\pi y/H$, which implies $dy = (H/\\pi)d\\theta$. The integration limits change from $y=0$ to $\\theta=0$ and from $y=H$ to $\\theta=\\pi$.\n$$\nI_{\\text{ex}} = \\mu_{0} \\int_{0}^{\\pi} \\exp(\\alpha \\cos\\theta) \\frac{H}{\\pi}\\,d\\theta = \\frac{\\mu_{0}H}{\\pi} \\int_{0}^{\\pi} \\exp(\\alpha \\cos\\theta)\\,d\\theta\n$$\nThis integral is a standard integral representation of the modified Bessel function of the first kind of order zero, $I_{0}(z)$:\n$$\nI_{0}(z) = \\frac{1}{\\pi} \\int_{0}^{\\pi} \\exp(z\\cos\\theta)\\,d\\theta\n$$\nTherefore, the integral for $I_{\\text{ex}}$ evaluates to:\n$$\nI_{\\text{ex}} = \\frac{\\mu_{0}H}{\\pi} \\left( \\pi I_{0}(\\alpha) \\right) = \\mu_{0}H I_{0}(\\alpha)\n$$\n\nFinally, we compute the relative error $\\varepsilon$:\n$$\n\\varepsilon = \\frac{I_{\\text{rom}}}{I_{\\text{ex}}} - 1 = \\frac{\\mu_{0}H}{\\mu_{0}H I_{0}(\\alpha)} - 1 = \\frac{1}{I_{0}(\\alpha)} - 1\n$$\nThis is the final closed-form expression for the relative error in terms of the parameter $\\alpha$ and the modified Bessel function $I_{0}$.\nThe result is dimensionless, as required.",
            "answer": "$$\\boxed{\\frac{1}{I_{0}(\\alpha)} - 1}$$"
        },
        {
            "introduction": "Moving from individual properties to entire systems, the immense computational cost of reacting flow simulations stems from the stiffness of the governing chemical kinetics, which involve a vast range of timescales. This computational exercise  delves into the core of chemistry reduction: timescale analysis. You will develop a program to linearize the kinetic equations and analyze the spectrum of the system Jacobian, learning how to computationally partition dynamics into fast and slow subspaces, a foundational skill for building advanced manifold-based reduced-order models.",
            "id": "4057113",
            "problem": "You are to implement a complete, runnable program that, for a homogeneous, adiabatic, constant-pressure reactor with a single irreversible reaction and detailed thermochemistry reduced to constant heat capacities, constructs the linearized dynamics at specified states and partitions the spectrum into fast and slow subspaces relevant for invariant manifold methods. Your program must compute the Jacobian of the source term with respect to the state, extract eigenvalues and eigenvectors, and report the dimension of the slow subspace for each test case based on a specified timescale threshold.\n\nStarting point and modeling assumptions:\n- Consider the zero-dimensional mass and energy balances for a homogeneous, adiabatic, constant-pressure reactor. Let the state vector be $x = [T, Y_F, Y_O]^T$, where $T$ is the temperature in kelvin, $Y_F$ is the mass fraction of fuel, and $Y_O$ is the mass fraction of oxidizer. The product mass fraction is $Y_P = 1 - Y_F - Y_O$. All mass fractions must satisfy $Y_F \\ge 0$, $Y_O \\ge 0$, and $Y_F + Y_O \\le 1$.\n- Use the ideal gas law and mixture-averaged molecular properties. The mixture density is given by $\\rho = \\dfrac{p \\, \\bar{W}}{R_u T}$, where $p$ is the pressure, $R_u$ is the universal gas constant, and $\\bar{W}$ is the mixture-averaged molecular weight computed from $Y_i$ and species molecular weights.\n- The chemical reaction is a single-step irreversible reaction of the form $\\mathrm{F} + s\\,\\mathrm{O} \\to \\mathrm{P}$, with $s = 0.5$ (stoichiometry on a molar basis).\n- The molar reaction rate is $w = k(T)\\, C_F \\, C_O$, where $k(T) = A \\exp\\!\\left(-\\dfrac{E_a}{R_u T}\\right)$ is the Arrhenius rate constant, and $C_i = \\dfrac{\\rho Y_i}{W_i}$ is the molar concentration of species $i$ with molecular weight $W_i$.\n- The species source terms in mass units are $\\dot{\\omega}_F = - W_F w$ and $\\dot{\\omega}_O = - s W_O w$. The energy equation under adiabatic, constant-pressure conditions reads $\\rho \\, c_p \\, \\dfrac{dT}{dt} = Q \\, w$, where $Q$ is the heat release per mole of reaction as written, and $c_p$ is the mixture specific heat at constant pressure, taken as $c_p = Y_F c_{p,F} + Y_O c_{p,O} + Y_P c_{p,P}$ with constant species heat capacities $c_{p,i}$.\n\nEquations of motion:\n- The ordinary differential equations (ODEs) for the state are\n$$\n\\frac{dY_F}{dt} = \\frac{\\dot{\\omega}_F}{\\rho} \\,, \\quad\n\\frac{dY_O}{dt} = \\frac{\\dot{\\omega}_O}{\\rho} \\,, \\quad\n\\frac{dT}{dt} = \\frac{Q \\, w}{\\rho \\, c_p} \\,.\n$$\nThese define the vector field $f(x)$ with components $f_1 = \\dfrac{dT}{dt}$, $f_2 = \\dfrac{dY_F}{dt}$, and $f_3 = \\dfrac{dY_O}{dt}$.\n\nLinearization and spectral partition:\n- For a given state $x^\\star$, define the Jacobian matrix $J(x^\\star) = \\left.\\dfrac{\\partial f}{\\partial x}\\right|_{x^\\star}$.\n- Compute the eigenvalues $\\lambda_j$ and right eigenvectors $v_j$ of $J(x^\\star)$ satisfying $J v_j = \\lambda_j v_j$.\n- Define the characteristic timescale for mode $j$ as $\\tau_j = \\infty$ if $\\Re(\\lambda_j) = 0$, and otherwise $\\tau_j = \\dfrac{1}{|\\Re(\\lambda_j)|}$.\n- Given a user-specified split timescale $\\tau_{\\text{split}}$, define the slow subspace as the span of eigenvectors with $\\tau_j \\ge \\tau_{\\text{split}}$ (equivalently, $|\\Re(\\lambda_j)| \\le \\dfrac{1}{\\tau_{\\text{split}}}$), and define the fast subspace as the span of the remaining eigenvectors. Report the integer dimension of the slow subspace.\n\nParameter values to be used:\n- Universal gas constant: $R_u = 8.314$ J/(mol·K).\n- Pressure: $p = 101325$ Pa.\n- Molecular weights in kg/mol: $W_F = 0.002016$ (hydrogen), $W_O = 0.031999$ (oxygen), $W_P = 0.018015$ (water).\n- Species constant heat capacities in J/(kg·K): $c_{p,F} = 14300$, $c_{p,O} = 918$, $c_{p,P} = 1864$.\n- Reaction stoichiometric coefficient: $s = 0.5$ (dimensionless, molar basis).\n- Arrhenius parameters: pre-exponential $A = 5\\times 10^{6}$ m$^3$/ (mol·s), activation energy $E_a = 1.5\\times 10^{5}$ J/mol, temperature exponent $n = 0$ (dimensionless).\n- Heat release per mole of reaction: $Q = 2.418\\times 10^{5}$ J/mol.\n- Timescale threshold: $\\tau_{\\text{split}} = 10^{-3}$ s.\n\nTest suite (each case is a state $x^\\star = [T, Y_F, Y_O]$):\n- Case $1$: $T = 900$ K, $Y_F = 0.1119$, $Y_O = 0.8881$.\n- Case $2$: $T = 1150$ K, $Y_F = 0.1119$, $Y_O = 0.8881$.\n- Case $3$: $T = 1800$ K, $Y_F = 0.01$, $Y_O = 0.05$.\n- Case $4$: $T = 1500$ K, $Y_F = 10^{-6}$, $Y_O = 0.2$.\n\nWhat you must implement:\n- Construct $f(x)$ from first principles as above, honoring all parameter values and units.\n- Compute $J(x^\\star)$ numerically at each test case using a numerically stable and accurate method consistent with the definition $J_{ij} = \\dfrac{\\partial f_i}{\\partial x_j}$.\n- Compute the eigenvalues of $J(x^\\star)$ and determine the integer dimension of the slow subspace using the criterion above with $\\tau_{\\text{split}}$.\n\nRequired final output:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The entry for each test case is the integer dimension of the slow subspace. For example, the format must be like $[r_1,r_2,r_3,r_4]$ where each $r_k$ is an integer.\n\nAngle units are not applicable. All physical quantities must be handled in the units specified above. No external input is permitted; all parameters and test cases are those listed here. The code must be self-contained and directly runnable.",
            "solution": "The problem is assessed to be valid. It is scientifically grounded in the principles of chemical kinetics and thermodynamics, well-posed with a clear objective and sufficient data, and represents a standard task in the analysis of reacting flows. All parameters and conditions are physically realistic and mathematically consistent.\n\nThe task is to determine the dimension of the slow subspace for a simplified chemical system at several specified states. This requires linearizing the system's governing ordinary differential equations (ODEs), computing the eigenvalues of the resulting Jacobian matrix, and partitioning them based on a timescale criterion.\n\nThe state of the homogeneous, adiabatic, constant-pressure reactor is described by the vector $x = [T, Y_F, Y_O]^T$, where $T$ is temperature, and $Y_F$ and $Y_O$ are the mass fractions of fuel and oxidizer, respectively. The governing ODEs define the vector field $f(x) = \\frac{d x}{d t}$:\n$$\nf(x) = \\begin{bmatrix} f_1 \\\\ f_2 \\\\ f_3 \\end{bmatrix} =\n\\begin{bmatrix}\n\\frac{dT}{dt} \\\\\n\\frac{dY_F}{dt} \\\\\n\\frac{dY_O}{dt}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\frac{Q \\, w}{\\rho \\, c_p} \\\\\n\\frac{-W_F w}{\\rho} \\\\\n\\frac{-s W_O w}{\\rho}\n\\end{bmatrix}\n$$\nThe terms in these equations depend on the state $x$ as follows:\nThe product mass fraction is $Y_P = 1 - Y_F - Y_O$.\nThe mixture-averaged molecular weight, $\\bar{W}$, is given by $\\bar{W} = \\left( \\frac{Y_F}{W_F} + \\frac{Y_O}{W_O} + \\frac{Y_P}{W_P} \\right)^{-1}$.\nThe mixture density, $\\rho$, is from the ideal gas law: $\\rho = \\frac{p \\bar{W}}{R_u T}$.\nThe mixture-averaged specific heat capacity, $c_p$, is $c_p = Y_F c_{p,F} + Y_O c_{p,O} + Y_P c_{p,P}$.\nThe molar reaction rate, $w$, for the single-step reaction $\\mathrm{F} + s\\,\\mathrm{O} \\to \\mathrm{P}$ is given by:\n$$\nw = k(T)\\, C_F \\, C_O = k(T) \\left(\\frac{\\rho Y_F}{W_F}\\right) \\left(\\frac{\\rho Y_O}{W_O}\\right) = \\frac{k(T) \\rho^2 Y_F Y_O}{W_F W_O}\n$$\nwhere the Arrhenius rate constant is $k(T) = A \\exp\\left(-\\frac{E_a}{R_u T}\\right)$. All symbols correspond to the parameters provided in the problem statement.\n\nThe core of the problem is to compute the Jacobian matrix $J(x^\\star)$ at each specified state $x^\\star$:\n$$\nJ(x^\\star) = \\left. \\frac{\\partial f}{\\partial x} \\right|_{x^\\star} = \\begin{bmatrix}\n\\frac{\\partial f_1}{\\partial T}  \\frac{\\partial f_1}{\\partial Y_F}  \\frac{\\partial f_1}{\\partial Y_O} \\\\\n\\frac{\\partial f_2}{\\partial T}  \\frac{\\partial f_2}{\\partial Y_F}  \\frac{\\partial f_2}{\\partial Y_O} \\\\\n\\frac{\\partial f_3}{\\partial T}  \\frac{\\partial f_3}{\\partial Y_F}  \\frac{\\partial f_3}{\\partial Y_O}\n\\end{bmatrix}_{x=x^\\star}\n$$\nWhile an analytical derivation of the Jacobian is possible, it is algebraically intensive and prone to error due to the complex interdependencies of $\\rho$, $c_p$, and $w$ on the state variables $T$, $Y_F$, and $Y_O$. The problem asks for numerical computation, for which the finite difference method is a robust and standard approach. A second-order central difference scheme is employed for accuracy:\n$$\n\\frac{\\partial f_i}{\\partial x_j}(x^\\star) \\approx \\frac{f_i(x^\\star + h_j e_j) - f_i(x^\\star - h_j e_j)}{2 h_j}\n$$\nHere, $e_j$ is the standard basis vector for the $j$-th component of the state vector, and $h_j$ is a small perturbation. A suitable perturbation is a combination of relative and absolute step sizes, $h_j = \\epsilon_{\\text{rel}} |x_j^\\star| + \\epsilon_{\\text{abs}}$, to ensure stability and accuracy across different scales of state variable values.\n\nOnce the Jacobian matrix $J(x^\\star)$ is computed for a given state, its eigenvalues $\\{\\lambda_j\\}$ are determined using a standard numerical linear algebra library. These eigenvalues characterize the local dynamics of the system. A positive real part $\\Re(\\lambda_j)  0$ indicates an unstable mode (e.g., ignition), while a negative real part $\\Re(\\lambda_j)  0$ signifies a stable mode that decays towards a steady state.\n\nThe characteristic timescale of each mode $j$ is defined as $\\tau_j = \\frac{1}{|\\Re(\\lambda_j)|}$ for $\\Re(\\lambda_j) \\neq 0$. This timescale represents the time required for the amplitude of the corresponding mode to change by a factor of $e$.\nThe spectrum of eigenvalues is then partitioned into \"fast\" and \"slow\" subspaces based on the given split timescale, $\\tau_{\\text{split}} = 10^{-3} \\, \\text{s}$.\nA mode $j$ is considered slow if its timescale $\\tau_j$ is greater than or equal to the split timescale:\n$$\n\\tau_j \\ge \\tau_{\\text{split}} \\iff \\frac{1}{|\\Re(\\lambda_j)|} \\ge \\tau_{\\text{split}} \\iff |\\Re(\\lambda_j)| \\le \\frac{1}{\\tau_{\\text{split}}}\n$$\nThe dimension of the slow subspace is the number of eigenvalues that satisfy this condition. This count is the final result for each test case. This procedure is fundamental to reduced-order modeling techniques like Intrinsic Low-Dimensional Manifolds (ILDM), which aim to approximate the full system dynamics by evolving the system only along its slow modes.\n\nThe implementation proceeds by first defining a function to calculate the vector field $f(x)$ for any given state $x$. Then, a second function numerically constructs the Jacobian matrix using this vector field function and the central difference scheme. Finally, for each test case, the Jacobian is computed, its eigenvalues are found, and the number of slow modes is counted according to the defined criterion.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the problem of finding the dimension of the slow subspace for a\n    reacting flow system at different states.\n    \"\"\"\n    #\n    # --- GLOBAL CONSTANTS ---\n    #\n    # Universal gas constant in J/(mol.K)\n    RU = 8.314\n    # Pressure in Pa\n    P = 101325.0\n    # Molecular weights in kg/mol\n    W_F = 0.002016  # Fuel (H2)\n    W_O = 0.031999  # Oxidizer (O2)\n    W_P = 0.018015  # Product (H2O)\n    # Species constant heat capacities in J/(kg.K)\n    CP_F = 14300.0\n    CP_O = 918.0\n    CP_P = 1864.0\n    # Reaction stoichiometric coefficient (molar basis)\n    S = 0.5\n    # Arrhenius parameters\n    A = 5.0e6  # Pre-exponential factor in m^3/(mol.s)\n    EA = 1.5e5 # Activation energy in J/mol\n    # Heat release per mole of reaction in J/mol\n    Q = 2.418e5\n    # Timescale threshold for splitting fast/slow subspaces in s\n    TAU_SPLIT = 1.0e-3\n    \n    # Store constants in a dictionary for easy passing\n    params = {\n        \"RU\": RU, \"P\": P, \"W_F\": W_F, \"W_O\": W_O, \"W_P\": W_P,\n        \"CP_F\": CP_F, \"CP_O\": CP_O, \"CP_P\": CP_P,\n        \"S\": S, \"A\": A, \"EA\": EA, \"Q\": Q\n    }\n    \n    #\n    # --- TEST CASES ---\n    #\n    # Each case is a state vector x_star = [T, Y_F, Y_O]\n    test_cases = [\n        np.array([900.0, 0.1119, 0.8881]),      # Case 1\n        np.array([1150.0, 0.1119, 0.8881]),     # Case 2\n        np.array([1800.0, 0.01, 0.05]),        # Case 3\n        np.array([1500.0, 1.0e-6, 0.2]),       # Case 4\n    ]\n\n    def compute_rhs(x, p_):\n        \"\"\"\n        Computes the right-hand side (RHS) of the ODE system, f(x).\n        x: state vector [T, Y_F, Y_O]\n        p_: dictionary of physical and chemical parameters\n        \"\"\"\n        T, Y_F, Y_O = x[0], x[1], x[2]\n        \n        # Ensure mass fractions are physically plausible for calculation\n        Y_F = max(0.0, Y_F)\n        Y_O = max(0.0, Y_O)\n        Y_P = 1.0 - Y_F - Y_O\n        Y_P = max(0.0, Y_P)\n\n        # Mixture-averaged molecular weight\n        W_inv = Y_F / p_[\"W_F\"] + Y_O / p_[\"W_O\"] + Y_P / p_[\"W_P\"]\n        W_bar = 1.0 / W_inv\n\n        # Density from ideal gas law\n        rho = (p_[\"P\"] * W_bar) / (p_[\"RU\"] * T)\n\n        # Mixture specific heat\n        cp_mix = Y_F * p_[\"CP_F\"] + Y_O * p_[\"CP_O\"] + Y_P * p_[\"CP_P\"]\n        \n        # Arrhenius rate constant\n        k = p_[\"A\"] * math.exp(-p_[\"EA\"] / (p_[\"RU\"] * T))\n\n        # Molar concentrations\n        C_F = rho * Y_F / p_[\"W_F\"]\n        C_O = rho * Y_O / p_[\"W_O\"]\n\n        # Molar reaction rate\n        w_mole = k * C_F * C_O\n        \n        # Avoid division by zero if rho or cp_mix is zero\n        if rho == 0.0 or cp_mix == 0.0:\n            return np.zeros(3)\n\n        # ODE RHS components\n        dT_dt = (p_[\"Q\"] * w_mole) / (rho * cp_mix)\n        dYF_dt = (-p_[\"W_F\"] * w_mole) / rho\n        dYO_dt = (-p_[\"S\"] * p_[\"W_O\"] * w_mole) / rho\n        \n        return np.array([dT_dt, dYF_dt, dYO_dt])\n\n    def compute_jacobian_numerical(x_star, p_):\n        \"\"\"\n        Computes the Jacobian matrix numerically using a central difference scheme.\n        x_star: state vector at which to evaluate the Jacobian\n        p_: dictionary of parameters\n        \"\"\"\n        n = len(x_star)\n        J = np.zeros((n, n))\n        \n        eps_rel = 1e-6\n        eps_abs = 1e-9\n\n        for j in range(n):\n            h_j = eps_rel * abs(x_star[j]) + eps_abs\n            \n            x_plus = np.copy(x_star)\n            x_plus[j] += h_j\n            \n            x_minus = np.copy(x_star)\n            x_minus[j] -= h_j\n            \n            f_plus = compute_rhs(x_plus, p_)\n            f_minus = compute_rhs(x_minus, p_)\n            \n            j_col = (f_plus - f_minus) / (2.0 * h_j)\n            J[:, j] = j_col\n            \n        return J\n\n    results = []\n    inv_tau_split = 1.0 / TAU_SPLIT\n\n    for state in test_cases:\n        # 1. Compute the Jacobian at the given state\n        J = compute_jacobian_numerical(state, params)\n        \n        # 2. Compute the eigenvalues of the Jacobian\n        eigenvalues = np.linalg.eigvals(J)\n        \n        # 3. Count the number of slow modes\n        slow_modes_count = 0\n        for lam in eigenvalues:\n            if abs(lam.real) = inv_tau_split:\n                slow_modes_count += 1\n        \n        results.append(slow_modes_count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A key challenge in projection-based ROMs is that truncating the basis leaves unresolved physics, requiring a 'closure model' to account for the missing dynamics. This final practice  introduces a powerful, data-driven approach to this problem, where a closure model is calibrated using high-fidelity data. You will implement a constrained optimization to determine the model's free parameter, ensuring that the resulting ROM not only matches the data but also adheres to fundamental physical constraints like species boundedness, a crucial step toward building robust and predictive models.",
            "id": "4057083",
            "problem": "Consider a simplified reduced-order model for a single reacting scalar representing a species mass fraction, denoted by $y \\in [0,1]$ and nondimensionalized. Let the high-fidelity Direct Numerical Simulation (DNS) data provide a sequence of snapshots $\\{y^{\\mathrm{DNS}}_k\\}_{k=0}^{K}$ at uniformly spaced times with time step $\\Delta t$. The reduced-order model (ROM) for the one-step reaction with a linear decay and an unresolved closure is given by the explicit Euler discretization\n$$\n\\widehat{y}_{k+1}(\\theta) \\;=\\; y^{\\mathrm{DNS}}_k \\;+\\; \\Delta t \\,\\Big( -\\lambda \\, y^{\\mathrm{DNS}}_k \\;+\\; s \\, y^{\\mathrm{DNS}}_k \\big(1 - y^{\\mathrm{DNS}}_k\\big) \\;+\\; \\theta \\, y^{\\mathrm{DNS}}_k \\big(1 - y^{\\mathrm{DNS}}_k\\big) \\Big),\n$$\nwhere $s$ and $\\lambda$ are known nonnegative parameters, and $\\theta$ is a scalar closure coefficient to be calibrated. The closure is chosen as $\\tau(y;\\theta) = \\theta \\, y(1-y)$ to satisfy the conservation-at-bounds property $\\tau(0;\\theta)=0$ and $\\tau(1;\\theta)=0$, ensuring that pure states remain invariant under the closure contribution.\n\nCalibration is posed as a constrained optimization problem: find $\\theta$ that minimizes the total squared one-step prediction mismatch with DNS,\n$$\nJ(\\theta) \\;=\\; \\sum_{k=0}^{K-1} \\left(\\widehat{y}_{k+1}(\\theta) - y^{\\mathrm{DNS}}_{k+1}\\right)^2,\n$$\nsubject to boundedness constraints enforcing that the one-step ROM predictions from the DNS states remain within the physically admissible interval,\n$$\n0 \\;\\le\\; \\widehat{y}_{k+1}(\\theta) \\;\\le\\; 1 \\quad \\text{for all } k \\in \\{0,\\dots,K-1\\}.\n$$\n\nStarting from first principles of species conservation and reaction kinetics, the foundational base is that the species mass fraction satisfies a balance between production and destruction rates. The ROM uses a low-order representation of this balance with a logistic production term $s \\, y(1-y)$ and a linear destruction term $-\\lambda y$, while the unresolved subgrid contribution is parameterized by the closure $\\tau(y;\\theta) = \\theta \\, y(1-y)$ that vanishes at pure states to conserve species at the bounds.\n\nYour task is to write a complete program that, for each specified test case (parameters and DNS generation protocol below), constructs the constrained least-squares calibration problem for $\\theta$, solves it, and returns the optimal $\\theta$ for each case. All quantities are nondimensional. Angles do not appear. No percentages appear.\n\nRequired algorithmic specifications:\n- For each case, the DNS data $\\{y^{\\mathrm{DNS}}_k\\}_{k=0}^{K}$ must be generated by simulating the same ROM with the true closure $\\theta^\\star$ using the explicit Euler update given above. Specifically, for a given initial condition $y^{\\mathrm{DNS}}_0$, compute $y^{\\mathrm{DNS}}_{k+1}$ iteratively for $k \\in \\{0,\\dots,K-1\\}$ with the true closure parameter $\\theta^\\star$ supplied in the test case.\n- The calibration must use only the generated DNS sequence and the known parameters $(s,\\lambda,\\Delta t)$, and it must not use $\\theta^\\star$ except to generate DNS data. The optimization variable is the single scalar $\\theta$.\n- The boundedness constraints for each $k$ must be imposed on $\\widehat{y}_{k+1}(\\theta)$ exactly as stated above.\n- The final answer for each test case must be the optimal $\\theta$ as a floating-point number. You must output the results for all cases as a single list on a single line as specified below.\n\nTest suite:\n- Case A (happy path): $s = 2.0$, $\\lambda = 0.5$, $\\Delta t = 0.1$, $K = 10$, $y^{\\mathrm{DNS}}_0 = 0.2$, $\\theta^\\star = 0.3$.\n- Case B (near-boundary growth): $s = 1.5$, $\\lambda = 0.2$, $\\Delta t = 0.2$, $K = 8$, $y^{\\mathrm{DNS}}_0 = 0.05$, $\\theta^\\star = 0.8$.\n- Case C (near-boundary decay): $s = 3.0$, $\\lambda = 1.2$, $\\Delta t = 0.05$, $K = 12$, $y^{\\mathrm{DNS}}_0 = 0.9$, $\\theta^\\star = -0.4$.\n\nFinal output format:\n- Your program should produce a single line of output containing the estimated closure coefficients for the three cases as a comma-separated list enclosed in square brackets (for example, $[\\theta_A,\\theta_B,\\theta_C]$).\n- Each $\\theta$ must be printed rounded to exactly $6$ decimal places.\n\nNotes for scientific realism and numerical soundness:\n- The chosen closure $\\tau(y;\\theta) = \\theta\\,y(1-y)$ guarantees the conservation-at-bounds property by construction, which is essential for species mass fractions taking values in $[0,1]$.\n- The boundedness constraints $0 \\le \\widehat{y}_{k+1}(\\theta) \\le 1$ enforce physical admissibility of one-step predictions made from DNS states under the calibrated closure.\n- You may use any mathematically equivalent approach to solve the constrained least-squares problem for $\\theta$. Because the constraints are linear in $\\theta$ for fixed $\\{y^{\\mathrm{DNS}}_k\\}$, a closed-form unconstrained least-squares solution projected onto the feasible interval obtained by intersecting the per-step bounds is acceptable.\n\nYour program must produce only the single required line of output in the exact format described above.",
            "solution": "The problem requires the calibration of a scalar closure coefficient $\\theta$ in a reduced-order model (ROM) for a reacting species mass fraction $y$. The calibration is formulated as a constrained least-squares problem, which we will analyze and solve.\n\nThe ROM is given by the explicit Euler discretization:\n$$\n\\widehat{y}_{k+1}(\\theta) \\;=\\; y^{\\mathrm{DNS}}_k \\;+\\; \\Delta t \\,\\Big( -\\lambda \\, y^{\\mathrm{DNS}}_k \\;+\\; s \\, y^{\\mathrm{DNS}}_k \\big(1 - y^{\\mathrm{DNS}}_k\\big) \\;+\\; \\theta \\, y^{\\mathrm{DNS}}_k \\big(1 - y^{\\mathrm{DNS}}_k\\big) \\Big)\n$$\nwhere $\\{y^{\\mathrm{DNS}}_k\\}_{k=0}^{K}$ is a sequence of high-fidelity data, and $s$, $\\lambda$, and $\\Delta t$ are known parameters.\n\nThe goal is to find $\\theta$ that minimizes the objective function,\n$$\nJ(\\theta) \\;=\\; \\sum_{k=0}^{K-1} \\left(\\widehat{y}_{k+1}(\\theta) - y^{\\mathrm{DNS}}_{k+1}\\right)^2\n$$\nsubject to the physical boundedness constraints:\n$$\n0 \\;\\le\\; \\widehat{y}_{k+1}(\\theta) \\;\\le\\; 1 \\quad \\text{for all } k \\in \\{0,\\dots,K-1\\}.\n$$\n\nFirst, we express the one-step prediction $\\widehat{y}_{k+1}(\\theta)$ in a form that separates the term containing $\\theta$. Let us simplify the notation by letting $y_k \\equiv y^{\\mathrm{DNS}}_k$.\nWe can write the prediction as:\n$$\n\\widehat{y}_{k+1}(\\theta) = \\left[ y_k + \\Delta t \\Big( -\\lambda y_k + s y_k(1 - y_k) \\Big) \\right] + \\theta \\left[ \\Delta t \\, y_k(1-y_k) \\right]\n$$\nLet us define the following quantities for each time step $k \\in \\{0, \\dots, K-1\\}$:\n1.  The prediction of the base model (without the closure term):\n    $$\n    c_k = y_k + \\Delta t \\Big( -\\lambda y_k + s y_k(1-y_k) \\Big)\n    $$\n2.  The coefficient of $\\theta$:\n    $$\n    a_k = \\Delta t \\, y_k(1-y_k)\n    $$\nWith these definitions, the ROM prediction is $\\widehat{y}_{k+1}(\\theta) = c_k + a_k \\theta$.\n\nThe objective function $J(\\theta)$ is the sum of squared residuals, where the residual for step $k$ is $r_k(\\theta) = \\widehat{y}_{k+1}(\\theta) - y_{k+1}$.\n$$\nr_k(\\theta) = (c_k + a_k \\theta) - y_{k+1} = a_k \\theta - (y_{k+1} - c_k)\n$$\nLet's define $b_k = y_{k+1} - c_k$. The objective function becomes:\n$$\nJ(\\theta) = \\sum_{k=0}^{K-1} (a_k \\theta - b_k)^2\n$$\nThis is a quadratic function of $\\theta$. To find the unconstrained minimum, we differentiate $J(\\theta)$ with respect to $\\theta$ and set the result to zero:\n$$\n\\frac{dJ}{d\\theta} = \\sum_{k=0}^{K-1} 2(a_k \\theta - b_k) a_k = 2\\theta \\left(\\sum_{k=0}^{K-1} a_k^2\\right) - 2\\left(\\sum_{k=0}^{K-1} a_k b_k\\right) = 0\n$$\nAssuming $\\sum a_k^2 \\neq 0$ (which holds unless all $y_k$ are trivial, i.e., $0$ or $1$), the unconstrained least-squares solution for $\\theta$ is:\n$$\n\\theta_{\\mathrm{unc}} = \\frac{\\sum_{k=0}^{K-1} a_k b_k}{\\sum_{k=0}^{K-1} a_k^2}\n$$\n\nNext, we analyze the boundedness constraints. For each $k \\in \\{0, \\dots, K-1\\}$, we must have:\n$$\n0 \\le c_k + a_k \\theta \\le 1\n$$\nThis yields a pair of linear inequalities in $\\theta$:\n$$\n-c_k \\le a_k \\theta \\quad \\text{and} \\quad a_k \\theta \\le 1 - c_k\n$$\nSince $y \\in [0,1]$, the term $y_k(1-y_k)$ is non-negative. As $\\Delta t  0$, we have $a_k = \\Delta t \\, y_k(1-y_k) \\ge 0$.\nIf $a_k  0$, we can divide by it to get bounds on $\\theta$:\n$$\n-\\frac{c_k}{a_k} \\le \\theta \\quad \\text{and} \\quad \\theta \\le \\frac{1-c_k}{a_k}\n$$\nLet $L_k = -c_k/a_k$ and $U_k = (1-c_k)/a_k$. For each step $k$ where $a_k  0$, the constraint imposes $\\theta \\in [L_k, U_k]$.\nIf $a_k = 0$ (i.e., if $y_k=0$ or $y_k=1$), the constraint becomes $0 \\le c_k \\le 1$. This is a condition on the base model parameters and does not constrain $\\theta$. The problem parameters are chosen such that this condition is met. These steps provide no bounds on $\\theta$ and can be ignored when determining the feasible set.\n\nThe overall feasible set for $\\theta$ is the intersection of all per-step constraint intervals:\n$$\n\\theta \\in \\bigcap_{k \\text{ with } a_k0} [L_k, U_k]\n$$\nThis intersection is a single interval $[L, U]$, where:\n$$\nL = \\max_{\\{k \\,|\\, a_k0\\}} \\{L_k\\} \\quad \\text{and} \\quad U = \\min_{\\{k \\,|\\, a_k0\\}} \\{U_k\\}\n$$\nIf the set of indices $\\{k \\,|\\, a_k0\\}$ is empty, the feasible set is $(-\\infty, \\infty)$.\n\nThe problem is now reduced to minimizing the convex quadratic function $J(\\theta)$ over the interval $[L, U]$. The solution is found by projecting the unconstrained minimum $\\theta_{\\mathrm{unc}}$ onto this interval:\n$$\n\\theta_{\\mathrm{opt}} = \n\\begin{cases} \nL  \\text{if } \\theta_{\\mathrm{unc}}  L \\\\\n\\theta_{\\mathrm{unc}}  \\text{if } L \\le \\theta_{\\mathrm{unc}} \\le U \\\\\nU  \\text{if } \\theta_{\\mathrm{unc}}  U\n\\end{cases}\n$$\nThis can be written compactly using a clipping function: $\\theta_{\\mathrm{opt}} = \\mathrm{clip}(\\theta_{\\mathrm{unc}}, L, U)$.\n\nThe problem also specifies that the DNS data $\\{y^{\\mathrm{DNS}}_k\\}$ is generated using the same model structure with a \"true\" parameter $\\theta^\\star$. This means:\n$$\ny_{k+1} = y_k + \\Delta t \\left( -\\lambda y_k + s y_k(1-y_k) + \\theta^\\star y_k(1-y_k) \\right) = c_k + a_k \\theta^\\star\n$$\nFrom this, we have $y_{k+1} - c_k = a_k \\theta^\\star$. Substituting this into the definition of $b_k$, we get $b_k = a_k \\theta^\\star$. Now, if we substitute this into the expression for the unconstrained optimum:\n$$\n\\theta_{\\mathrm{unc}} = \\frac{\\sum a_k (a_k \\theta^\\star)}{\\sum a_k^2} = \\frac{\\theta^\\star \\sum a_k^2}{\\sum a_k^2} = \\theta^\\star\n$$\nThis demonstrates that in this idealized \"twin experiment\" setup, the unconstrained least-squares solution is exactly the true parameter $\\theta^\\star$. Since the data was generated with $\\theta^\\star$, the trajectory must be physically bounded, which implies that $\\theta^\\star$ itself satisfies all constraints, i.e., $L \\le \\theta^\\star \\le U$. Therefore, the final optimal solution $\\theta_{\\mathrm{opt}}$ will be equal to $\\theta^\\star$, assuming no numerical precision errors.\n\nThe final algorithm is as follows:\n1.  For each test case, generate the data sequence $\\{y_k^{\\mathrm{DNS}}\\}_{k=0}^{K}$ by iteratively applying the update rule with the given $\\theta^\\star$.\n2.  Using the generated sequence, compute the vectors $a_k$, $b_k$, and $c_k$ for $k=0, \\dots, K-1$.\n3.  Calculate the unconstrained solution $\\theta_{\\mathrm{unc}}$.\n4.  Determine the feasible interval $[L, U]$ from the boundedness constraints.\n5.  Compute the optimal constrained solution $\\theta_{\\mathrm{opt}}$ by clipping $\\theta_{\\mathrm{unc}}$ to the interval $[L, U]$.\n6.  Collect the resulting $\\theta_{\\mathrm{opt}}$ for each case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the constrained least-squares calibration problem for the closure coefficient theta\n    for a set of test cases.\n    \"\"\"\n    \n    # Test suite defined in the problem statement.\n    test_cases = [\n        # Case A (happy path)\n        {'s': 2.0, 'lam': 0.5, 'dt': 0.1, 'K': 10, 'y0': 0.2, 'theta_star': 0.3},\n        # Case B (near-boundary growth)\n        {'s': 1.5, 'lam': 0.2, 'dt': 0.2, 'K': 8, 'y0': 0.05, 'theta_star': 0.8},\n        # Case C (near-boundary decay)\n        {'s': 3.0, 'lam': 1.2, 'dt': 0.05, 'K': 12, 'y0': 0.9, 'theta_star': -0.4},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        s = case['s']\n        lam = case['lam']\n        dt = case['dt']\n        K = case['K']\n        y0 = case['y0']\n        theta_star = case['theta_star']\n\n        # Step 1: Generate DNS data using the model with the true parameter theta_star.\n        y_dns = np.zeros(K + 1)\n        y_dns[0] = y0\n        for k in range(K):\n            y_k = y_dns[k]\n            # Production/destruction term: s * y(1-y) - lambda * y\n            # Combined closure term: theta_star * y(1-y)\n            # The model can be grouped as: -lambda * y + (s + theta_star) * y(1-y)\n            source_term = -lam * y_k + (s + theta_star) * y_k * (1 - y_k)\n            y_dns[k+1] = y_k + dt * source_term\n            \n        # Extract y_k and y_{k+1} sequences for calibration\n        y_k_seq = y_dns[:-1]\n        y_k_plus_1_seq = y_dns[1:]\n\n        # Step 2: Set up the least-squares problem AX=B where X is theta\n        # A_k = a_k = dt * y_k * (1 - y_k)\n        # B_k = b_k = y_{k+1} - c_k, where c_k is the base model prediction\n        \n        # Coefficient of theta\n        a_k_vec = dt * y_k_seq * (1 - y_k_seq)\n        \n        # Base model prediction (without closure term)\n        c_k_vec = y_k_seq + dt * (-lam * y_k_seq + s * y_k_seq * (1 - y_k_seq))\n        \n        # Target vector\n        b_k_vec = y_k_plus_1_seq - c_k_vec\n\n        # Step 3: Solve for the unconstrained optimal theta\n        sum_a_sq = np.sum(a_k_vec**2)\n        sum_a_b = np.sum(a_k_vec * b_k_vec)\n        \n        if sum_a_sq  1e-15: # Avoid division by zero in degenerate cases\n            # If all a_k are zero, theta is unconstrained by the objective.\n            # Any value is optimal. We can pick 0 or handle it as an error.\n            # However, problem setup guarantees this won't be the primary path.\n            theta_unc = 0.0\n        else:\n            theta_unc = sum_a_b / sum_a_sq\n\n        # Step 4: Determine the feasible interval [L, U] from boundedness constraints\n        # 0 = c_k + a_k * theta = 1\n        \n        # We only consider steps where a_k > 0, as a_k=0 provides no constraint on theta\n        mask = a_k_vec  1e-15\n        \n        if np.any(mask):\n            a_k_masked = a_k_vec[mask]\n            c_k_masked = c_k_vec[mask]\n            \n            # Lower bounds: L_k = -c_k / a_k\n            lower_bounds_k = -c_k_masked / a_k_masked\n            # Upper bounds: U_k = (1 - c_k) / a_k\n            upper_bounds_k = (1 - c_k_masked) / a_k_masked\n            \n            # The overall bounds are the tightest of these\n            L_bound = np.max(lower_bounds_k)\n            U_bound = np.min(upper_bounds_k)\n        else:\n            # If no a_k > 0, theta is unconstrained by bounds\n            L_bound = -np.inf\n            U_bound = np.inf\n            \n        # Step 5: Project the unconstrained solution onto the feasible interval\n        theta_opt = np.clip(theta_unc, L_bound, U_bound)\n        \n        results.append(theta_opt)\n\n    # Final print statement in the exact required format.\n    # Each theta must be rounded to exactly 6 decimal places.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```"
        }
    ]
}