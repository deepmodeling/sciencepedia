{
    "hands_on_practices": [
        {
            "introduction": "有效的降阶建模通常始于对系统组分的简化，即简化控制系统的复杂物理定律。本练习将指导您近似模拟反应流中常见的随温度变化的输运性质。通过应用泰勒级数和Padé近似等经典近似技术，您不仅将为粘度和导热系数构建更简单的模型，还将学会如何定量分析这些近似所引入的误差，这是评估模型保真度的关键技能。",
            "id": "4057133",
            "problem": "考虑在两个相距为 $H$ 的无限大平行板之间的单组分反应气体的稳态、层流、不可压缩、平面库埃特流。位于 $y=0$ 的底板静止，位于 $y=H$ 的顶板以恒定速度 $U$ 沿 $x$ 方向移动，产生均匀的剪切率 $du/dy = U/H$。假设速度场为 $u(y) = Uy/H$，所有其他速度分量为零。温度场规定为\n$$\nT(y) = T_{0} + \\Delta T \\cos\\!\\left(\\frac{\\pi y}{H}\\right),\n$$\n其中常数 $T_{0} > 0$ 且 $|\\Delta T|  T_{0}$。动力黏度和热导率随温度变化，遵循以下经过充分检验的模型：\n- 精确黏度：$\\mu_{\\text{ex}}(T) = \\mu_{0} \\exp\\!\\big(\\beta\\,(T/T_{0} - 1)\\big)$，其中 $\\mu_{0}  0$ 且 $\\beta  0$。\n- 精确热导率：$k_{\\text{ex}}(T) = k_{0} \\left(T/T_{0}\\right)^{m}$，其中 $k_{0}  0$ 且指数 $m$ 为实数。\n\n将通过以下方式构建一个降阶模型（ROM）：\n- 在 $T=T_{0}$ 附近用一阶多项式近似黏度：\n$$\n\\mu_{\\text{rom}}(T) = \\mu_{0}\\left[1 + \\beta\\left(\\frac{T}{T_{0}} - 1\\right)\\right].\n$$\n- 在变量 $x = T/T_{0} - 1$ 中用有理 $[1/1]$ 帕德近似来近似热导率：\n$$\nk_{\\text{rom}}(T) = k_{0}\\,\\frac{1 + p x}{1 + q x},\n$$\n其中系数 $p$ 和 $q$ 的选择应使 $k_{\\text{rom}}(T)$ 在 $x=0$ 附近的泰勒展开式与 $k_{\\text{ex}}(T)$ 的展开式匹配至 $\\mathcal{O}(x^{2})$（包括此项）。\n\n使用不可压缩流的单位体积牛顿黏性耗散，\n$$\n\\phi(y) = \\mu(T(y))\\left(\\frac{du}{dy}\\right)^{2},\n$$\n定义单位面积上的区域积分黏性能量耗散为\n$$\n\\mathcal{D} = \\int_{0}^{H} \\phi(y)\\,dy.\n$$\n令 $\\mathcal{D}_{\\text{ex}}$ 表示用 $\\mu_{\\text{ex}}(T(y))$ 计算的耗散，$\\mathcal{D}_{\\text{rom}}$ 表示用 $\\mu_{\\text{rom}}(T(y))$ 计算的耗散。定义耗散的相对误差为\n$$\n\\varepsilon = \\frac{\\mathcal{D}_{\\text{rom}} - \\mathcal{D}_{\\text{ex}}}{\\mathcal{D}_{\\text{ex}}}.\n$$\n\n通过将 $k_{\\text{rom}}(T)$ 与 $k_{\\text{ex}}(T)$ 匹配至 $\\mathcal{O}(x^{2})$ 来推导 $p$ 和 $q$，构建 $\\mu_{\\text{rom}}(T)$，然后根据给定的 $T(y)$ 和 $u(y)$，用无量纲参数\n$$\n\\alpha \\equiv \\beta\\,\\frac{\\Delta T}{T_{0}}.\n$$\n精确计算 $\\varepsilon$。\n将 $\\varepsilon$ 的最终结果表示为关于 $\\alpha$ 和（如有必要）标准特殊函数的单一闭式解析表达式。以无量纲表达式报告你的答案。不要包含任何单位。不需要进行数值计算。",
            "solution": "问题陈述经评估有效。它科学地基于流体力学和计算建模的原理，问题提法恰当，提供了所有必要信息，并以客观、明确的语言表述。该设置虽然理想化，但代表了剪切流研究中的一个标准典范问题。该任务包含多个部分但逻辑一致，要求推导帕德近似系数并计算黏性耗散降阶模型的误差度量。\n\n求解过程分为两个主要部分。首先，我们推导热导率 $k_{\\text{rom}}(T)$ 的有理近似的系数 $p$ 和 $q$。其次，我们计算用降阶黏度模型计算的黏性耗散 $\\mathcal{D}_{\\text{rom}}$ 与用精确黏度模型计算的黏性耗散 $\\mathcal{D}_{\\text{ex}}$ 之间的相对误差 $\\varepsilon$。\n\n第 1 部分：$k_{\\text{rom}}(T)$ 的帕德近似系数的推导。\n\n任务是找到 $[1/1]$ 帕德近似式 $k_{\\text{rom}}(T)$ 的系数 $p$ 和 $q$，使其与精确模型 $k_{\\text{ex}}(T)$ 在 $x = T/T_{0} - 1$ 的情况下匹配到 $\\mathcal{O}(x^2)$ 阶。\n\n精确热导率由下式给出：\n$$\nk_{\\text{ex}}(T) = k_{0} \\left(\\frac{T}{T_{0}}\\right)^{m} = k_{0} (1+x)^{m}\n$$\n$k_{\\text{ex}}(T)/k_{0}$ 在 $x=0$ 附近的泰勒级数展开为：\n$$\n(1+x)^{m} = 1 + mx + \\frac{m(m-1)}{2}x^{2} + \\mathcal{O}(x^{3})\n$$\n\n热导率的降阶模型由下式给出：\n$$\nk_{\\text{rom}}(T) = k_{0}\\,\\frac{1 + p x}{1 + q x}\n$$\n$k_{\\text{rom}}(T)/k_{0}$ 在 $x=0$ 附近的泰勒级数展开式可以通过使用 $(1+qx)^{-1}$ 的几何级数展开得到：\n$$\n\\frac{1 + p x}{1 + q x} = (1+px)(1 - qx + q^{2}x^{2} - \\mathcal{O}(x^{3})) = 1 + (p-q)x + (q^{2}-pq)x^{2} + \\mathcal{O}(x^{3})\n$$\n$$\n= 1 + (p-q)x - q(p-q)x^{2} + \\mathcal{O}(x^{3})\n$$\n\n为了使两个展开式匹配到 $\\mathcal{O}(x^2)$，我们令 $x$ 的各次幂的系数相等：\n$x^{1}$ 的系数：\n$$\np - q = m\n$$\n$x^{2}$ 的系数：\n$$\n-q(p-q) = \\frac{m(m-1)}{2}\n$$\n将第一个方程代入第二个方程得到：\n$$\n-q(m) = \\frac{m(m-1)}{2}\n$$\n假设 $m \\neq 0$，我们可以两边除以 m 来求 $q$：\n$$\n-q = \\frac{m-1}{2} \\implies q = \\frac{1-m}{2}\n$$\n现在，我们用 $p = m+q$ 来解 $p$：\n$$\np = m + \\frac{1-m}{2} = \\frac{2m + 1 - m}{2} = \\frac{m+1}{2}\n$$\n这些公式对于 $m=0$ 和 $m=1$ 的特殊情况也有效。因此，帕德系数为 $p = (m+1)/2$ 和 $q = (1-m)/2$。注意，问题的这一部分与 $\\varepsilon$ 的计算无关。\n\n第 2 部分：相对误差 $\\varepsilon$ 的评估。\n\n区域积分黏性耗散的相对误差定义为：\n$$\n\\varepsilon = \\frac{\\mathcal{D}_{\\text{rom}} - \\mathcal{D}_{\\text{ex}}}{\\mathcal{D}_{\\text{ex}}} = \\frac{\\mathcal{D}_{\\text{rom}}}{\\mathcal{D}_{\\text{ex}}} - 1\n$$\n积分耗散 $\\mathcal{D}$ 由下式给出：\n$$\n\\mathcal{D} = \\int_{0}^{H} \\mu(T(y))\\left(\\frac{du}{dy}\\right)^{2}\\,dy\n$$\n给定速度场 $u(y) = Uy/H$，剪切率为常数：\n$$\n\\frac{du}{dy} = \\frac{U}{H}\n$$\n我们用 $S = U/H$ 表示这个恒定的剪切率。耗散积分变为：\n$$\n\\mathcal{D}_{\\text{ex}} = S^{2} \\int_{0}^{H} \\mu_{\\text{ex}}(T(y))\\,dy\n$$\n$$\n\\mathcal{D}_{\\text{rom}} = S^{2} \\int_{0}^{H} \\mu_{\\text{rom}}(T(y))\\,dy\n$$\n误差的表达式简化为：\n$$\n\\varepsilon = \\frac{\\int_{0}^{H} \\mu_{\\text{rom}}(T(y))\\,dy}{\\int_{0}^{H} \\mu_{\\text{ex}}(T(y))\\,dy} - 1\n$$\n\n接下来，我们将黏度模型表示为 $y$ 的函数。黏度函数中与温度相关的项是：\n$$\n\\frac{T(y)}{T_{0}} - 1 = \\frac{T_{0} + \\Delta T \\cos(\\frac{\\pi y}{H})}{T_{0}} - 1 = \\frac{\\Delta T}{T_{0}} \\cos\\left(\\frac{\\pi y}{H}\\right)\n$$\n使用给定的无量纲参数 $\\alpha = \\beta (\\Delta T / T_{0})$，我们可以写出黏度模型：\n精确黏度模型是：\n$$\n\\mu_{\\text{ex}}(T(y)) = \\mu_{0} \\exp\\left[\\beta\\left(\\frac{T(y)}{T_{0}} - 1\\right)\\right] = \\mu_{0} \\exp\\left[\\beta \\frac{\\Delta T}{T_{0}} \\cos\\left(\\frac{\\pi y}{H}\\right)\\right] = \\mu_{0} \\exp\\left[\\alpha \\cos\\left(\\frac{\\pi y}{H}\\right)\\right]\n$$\n降阶黏度模型是：\n$$\n\\mu_{\\text{rom}}(T(y)) = \\mu_{0}\\left[1 + \\beta\\left(\\frac{T(y)}{T_{0}} - 1\\right)\\right] = \\mu_{0}\\left[1 + \\alpha \\cos\\left(\\frac{\\pi y}{H}\\right)\\right]\n$$\n\n现在我们计算这两个积分。我们定义 $I_{\\text{ex}} = \\int_{0}^{H} \\mu_{\\text{ex}}(T(y))\\,dy$ 和 $I_{\\text{rom}} = \\int_{0}^{H} \\mu_{\\text{rom}}(T(y))\\,dy$。\n\nROM 的积分是：\n$$\nI_{\\text{rom}} = \\int_{0}^{H} \\mu_{0}\\left[1 + \\alpha \\cos\\left(\\frac{\\pi y}{H}\\right)\\right]\\,dy = \\mu_{0}\\left[ \\int_{0}^{H} dy + \\alpha \\int_{0}^{H} \\cos\\left(\\frac{\\pi y}{H}\\right)\\,dy \\right]\n$$\n$$\nI_{\\text{rom}} = \\mu_{0}\\left[ [y]_{0}^{H} + \\alpha \\left[\\frac{H}{\\pi}\\sin\\left(\\frac{\\pi y}{H}\\right)\\right]_{0}^{H} \\right] = \\mu_{0}\\left[ H + \\alpha \\frac{H}{\\pi}(\\sin(\\pi) - \\sin(0)) \\right] = \\mu_{0}H\n$$\n\n精确模型的积分是：\n$$\nI_{\\text{ex}} = \\int_{0}^{H} \\mu_{0} \\exp\\left[\\alpha \\cos\\left(\\frac{\\pi y}{H}\\right)\\right]\\,dy\n$$\n我们使用换元法 $\\theta = \\pi y/H$，这意味着 $dy = (H/\\pi)d\\theta$。积分上下限从 $y=0$ 变为 $\\theta=0$，从 $y=H$ 变为 $\\theta=\\pi$。\n$$\nI_{\\text{ex}} = \\mu_{0} \\int_{0}^{\\pi} \\exp(\\alpha \\cos\\theta) \\frac{H}{\\pi}\\,d\\theta = \\frac{\\mu_{0}H}{\\pi} \\int_{0}^{\\pi} \\exp(\\alpha \\cos\\theta)\\,d\\theta\n$$\n这个积分是零阶第一类修正贝塞尔函数 $I_{0}(z)$ 的标准积分表示：\n$$\nI_{0}(z) = \\frac{1}{\\pi} \\int_{0}^{\\pi} \\exp(z\\cos\\theta)\\,d\\theta\n$$\n因此，$I_{\\text{ex}}$ 的积分计算结果为：\n$$\nI_{\\text{ex}} = \\frac{\\mu_{0}H}{\\pi} \\left( \\pi I_{0}(\\alpha) \\right) = \\mu_{0}H I_{0}(\\alpha)\n$$\n\n最后，我们计算相对误差 $\\varepsilon$：\n$$\n\\varepsilon = \\frac{I_{\\text{rom}}}{I_{\\text{ex}}} - 1 = \\frac{\\mu_{0}H}{\\mu_{0}H I_{0}(\\alpha)} - 1 = \\frac{1}{I_{0}(\\alpha)} - 1\n$$\n这是相对误差关于参数 $\\alpha$ 和修正贝塞尔函数 $I_{0}$ 的最终闭式表达式。\n结果是无量纲的，符合要求。",
            "answer": "$$\\boxed{\\frac{1}{I_{0}(\\alpha)} - 1}$$"
        },
        {
            "introduction": "从单个组分转向整个系统，许多强大模型降阶技术的基础在于识别控制动态中的自然时间尺度分离。本计算实践聚焦于这一关键步骤：分析均相反应器的局部动态。通过数值计算系统的雅可比矩阵及其特征谱，您将学会区分快速达到平衡的过程和决定系统演化的慢速限速动态，这是构建基于流形的降阶模型的关键。",
            "id": "4057113",
            "problem": "您需要实现一个完整、可运行的程序，该程序针对具有单一不可逆反应且详细热化学性质简化为恒定热容的均相、绝热、恒压反应器，在指定状态下构建线性化动力学，并将谱划分为与不变流形方法相关的快、慢子空间。您的程序必须计算源项相对于状态的雅可比矩阵，提取特征值和特征向量，并根据指定的时间尺度阈值为每个测试用例报告慢子空间的维度。\n\n起点和建模假设：\n- 考虑一个均相、绝热、恒压反应器的零维质量和能量平衡。设状态向量为 $x = [T, Y_F, Y_O]^T$，其中 $T$ 是温度（单位：开尔文），$Y_F$ 是燃料的质量分数，$Y_O$ 是氧化剂的质量分数。产物的质量分数为 $Y_P = 1 - Y_F - Y_O$。所有质量分数必须满足 $Y_F \\ge 0$，$Y_O \\ge 0$ 以及 $Y_F + Y_O \\le 1$。\n- 使用理想气体定律和混合物平均分子性质。混合物密度由 $\\rho = \\dfrac{p \\, \\bar{W}}{R_u T}$ 给出，其中 $p$ 是压力，$R_u$ 是普适气体常数，$\\bar{W}$ 是根据 $Y_i$ 和各组分分子量计算出的混合物平均分子量。\n- 化学反应为形式为 $\\mathrm{F} + s\\,\\mathrm{O} \\to \\mathrm{P}$ 的单步不可逆反应，其中 $s = 0.5$（基于摩尔的化学计量）。\n- 摩尔反应速率为 $w = k(T)\\, C_F \\, C_O$，其中 $k(T) = A \\exp\\!\\left(-\\dfrac{E_a}{R_u T}\\right)$ 是 Arrhenius 速率常数，而 $C_i = \\dfrac{\\rho Y_i}{W_i}$ 是分子量为 $W_i$ 的组分 $i$ 的摩尔浓度。\n- 以质量为单位的组分源项为 $\\dot{\\omega}_F = - W_F w$ 和 $\\dot{\\omega}_O = - s W_O w$。绝热、恒压条件下的能量方程为 $\\rho \\, c_p \\, \\dfrac{dT}{dt} = Q \\, w$，其中 $Q$ 是所写反应式中每摩尔反应的放热量，$c_p$ 是混合物定压比热，取为 $c_p = Y_F c_{p,F} + Y_O c_{p,O} + Y_P c_{p,P}$，其中各组分热容 $c_{p,i}$ 为常数。\n\n运动方程：\n- 状态的常微分方程 (ODEs) 为\n$$\n\\frac{dY_F}{dt} = \\frac{\\dot{\\omega}_F}{\\rho} \\,, \\quad\n\\frac{dY_O}{dt} = \\frac{\\dot{\\omega}_O}{\\rho} \\,, \\quad\n\\frac{dT}{dt} = \\frac{Q \\, w}{\\rho \\, c_p} \\,.\n$$\n这些方程定义了向量场 $f(x)$，其分量为 $f_1 = \\dfrac{dT}{dt}$、$f_2 = \\dfrac{dY_F}{dt}$ 和 $f_3 = \\dfrac{dY_O}{dt}$。\n\n线性化与谱划分：\n- 对于给定状态 $x^\\star$，定义雅可比矩阵 $J(x^\\star) = \\left.\\dfrac{\\partial f}{\\partial x}\\right|_{x^\\star}$。\n- 计算满足 $J v_j = \\lambda_j v_j$ 的 $J(x^\\star)$ 的特征值 $\\lambda_j$ 和右特征向量 $v_j$。\n- 定义模态 $j$ 的特征时间尺度为：如果 $\\Re(\\lambda_j) = 0$，则 $\\tau_j = \\infty$；否则 $\\tau_j = \\dfrac{1}{|\\Re(\\lambda_j)|}$。\n- 给定用户指定的划分时间尺度 $\\tau_{\\text{split}}$，将慢子空间定义为满足 $\\tau_j \\ge \\tau_{\\text{split}}$（等价于 $|\\Re(\\lambda_j)| \\le \\dfrac{1}{\\tau_{\\text{split}}}$）的特征向量所张成的空间，并将快子空间定义为其余特征向量所张成的空间。报告慢子空间的整数维度。\n\n待使用的参数值：\n- 普适气体常数: $R_u = 8.314$ 焦耳/(摩尔·开尔文)。\n- 压力: $p = 101325$ 帕。\n- 分子量，单位 kg/mol: $W_F = 0.002016$ (氢气), $W_O = 0.031999$ (氧气), $W_P = 0.018015$ (水)。\n- 组分恒定热容，单位 J/(kg·K): $c_{p,F} = 14300$, $c_{p,O} = 918$, $c_{p,P} = 1864$。\n- 反应化学计量系数: $s = 0.5$ (无量纲，摩尔基准)。\n- Arrhenius 参数: 指前因子 $A = 5\\times 10^{6}$ 立方米/(摩尔·秒), 活化能 $E_a = 1.5\\times 10^{5}$ 焦耳/摩尔, 温度指数 $n = 0$ (无量纲)。\n- 每摩尔反应放热量: $Q = 2.418\\times 10^{5}$ 焦耳/摩尔。\n- 时间尺度阈值: $\\tau_{\\text{split}} = 10^{-3}$ 秒。\n\n测试套件（每个用例是一个状态 $x^\\star = [T, Y_F, Y_O]$）：\n- 用例 1: $T = 900$ K, $Y_F = 0.1119$, $Y_O = 0.8881$。\n- 用例 2: $T = 1150$ K, $Y_F = 0.1119$, $Y_O = 0.8881$。\n- 用例 3: $T = 1800$ K, $Y_F = 0.01$, $Y_O = 0.05$。\n- 用例 4: $T = 1500$ K, $Y_F = 10^{-6}$, $Y_O = 0.2$。\n\n您必须实现的内容：\n- 根据上述第一性原理构建 $f(x)$，并遵守所有参数值和单位。\n- 在每个测试用例中，使用与定义 $J_{ij} = \\dfrac{\\partial f_i}{\\partial x_j}$ 一致的数值稳定且精确的方法，数值计算 $J(x^\\star)$。\n- 计算 $J(x^\\star)$ 的特征值，并使用上述准则和 $\\tau_{\\text{split}}$ 确定慢子空间的整数维度。\n\n要求的最终输出：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。每个测试用例的条目是慢子空间的整数维度。例如，格式必须类似于 $[r_1,r_2,r_3,r_4]$，其中每个 $r_k$ 都是一个整数。\n\n角度单位不适用。所有物理量必须以上述指定单位处理。不允许外部输入；所有参数和测试用例均为本文所列。代码必须是自包含且可直接运行的。",
            "solution": "此问题经评估为有效。它在科学上基于化学动力学和热力学原理，问题设定良好，目标明确，数据充分，并且代表了反应流分析中的一项标准任务。所有参数和条件在物理上都是现实的，在数学上也是一致的。\n\n任务是确定一个简化的化学系统在几个指定状态下慢子空间的维度。这需要对系统的控制常微分方程 (ODEs) 进行线性化，计算所得雅可比矩阵的特征值，并根据一个时间尺度准则对它们进行划分。\n\n均相、绝热、恒压反应器的状态由向量 $x = [T, Y_F, Y_O]^T$ 描述，其中 $T$ 是温度，$Y_F$ 和 $Y_O$ 分别是燃料和氧化剂的质量分数。控制 ODE 定义了向量场 $f(x) = \\frac{d x}{d t}$：\n$$\nf(x) = \\begin{bmatrix} f_1 \\\\ f_2 \\\\ f_3 \\end{bmatrix} =\n\\begin{bmatrix}\n\\frac{dT}{dt} \\\\\n\\frac{dY_F}{dt} \\\\\n\\frac{dY_O}{dt}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\frac{Q \\, w}{\\rho \\, c_p} \\\\\n\\frac{-W_F w}{\\rho} \\\\\n\\frac{-s W_O w}{\\rho}\n\\end{bmatrix}\n$$\n这些方程中的各项对状态 $x$ 的依赖关系如下：\n产物质量分数为 $Y_P = 1 - Y_F - Y_O$。\n混合物平均分子量 $\\bar{W}$ 由 $\\bar{W} = \\left( \\frac{Y_F}{W_F} + \\frac{Y_O}{W_O} + \\frac{Y_P}{W_P} \\right)^{-1}$ 给出。\n混合物密度 $\\rho$ 来自理想气体定律：$\\rho = \\frac{p \\bar{W}}{R_u T}$。\n混合物平均比热容 $c_p$ 为 $c_p = Y_F c_{p,F} + Y_O c_{p,O} + Y_P c_{p,P}$。\n对于单步反应 $\\mathrm{F} + s\\,\\mathrm{O} \\to \\mathrm{P}$，其摩尔反应速率 $w$ 由下式给出：\n$$\nw = k(T)\\, C_F \\, C_O = k(T) \\left(\\frac{\\rho Y_F}{W_F}\\right) \\left(\\frac{\\rho Y_O}{W_O}\\right) = \\frac{k(T) \\rho^2 Y_F Y_O}{W_F W_O}\n$$\n其中 Arrhenius 速率常数为 $k(T) = A \\exp\\left(-\\frac{E_a}{R_u T}\\right)$。所有符号与问题描述中提供的参数相对应。\n\n问题的核心是在每个指定状态 $x^\\star$ 计算雅可比矩阵 $J(x^\\star)$：\n$$\nJ(x^\\star) = \\left. \\frac{\\partial f}{\\partial x} \\right|_{x^\\star} = \\begin{bmatrix}\n\\frac{\\partial f_1}{\\partial T}  \\frac{\\partial f_1}{\\partial Y_F}  \\frac{\\partial f_1}{\\partial Y_O} \\\\\n\\frac{\\partial f_2}{\\partial T}  \\frac{\\partial f_2}{\\partial Y_F}  \\frac{\\partial f_2}{\\partial Y_O} \\\\\n\\frac{\\partial f_3}{\\partial T}  \\frac{\\partial f_3}{\\partial Y_F}  \\frac{\\partial f_3}{\\partial Y_O}\n\\end{bmatrix}_{x=x^\\star}\n$$\n虽然雅可比矩阵的解析推导是可能的，但由于 $\\rho$、$c_p$ 和 $w$ 对状态变量 $T$、$Y_F$ 和 $Y_O$ 的复杂相互依赖关系，其代数计算量大且容易出错。该问题要求进行数值计算，对此，有限差分法是一种稳健且标准的方法。为保证精度，采用二阶中心差分格式：\n$$\n\\frac{\\partial f_i}{\\partial x_j}(x^\\star) \\approx \\frac{f_i(x^\\star + h_j e_j) - f_i(x^\\star - h_j e_j)}{2 h_j}\n$$\n此处，$e_j$ 是状态向量第 $j$ 个分量的标准基向量，$h_j$ 是一个小的扰动。一个合适的扰动是相对步长和绝对步长的组合，$h_j = \\epsilon_{\\text{rel}} |x_j^\\star| + \\epsilon_{\\text{abs}}$，以确保在不同数量级的状态变量值上都能保持稳定性和准确性。\n\n一旦计算出给定状态的雅可比矩阵 $J(x^\\star)$，就可以使用标准的数值线性代数库来确定其特征值 $\\{\\lambda_j\\}$。这些特征值表征了系统的局部动力学。正实部 $\\Re(\\lambda_j)  0$ 表示一个不稳定的模态（例如，点火），而负实部 $\\Re(\\lambda_j)  0$ 表示一个衰减并趋向稳态的稳定模态。\n\n对于 $\\Re(\\lambda_j) \\neq 0$ 的每个模态 $j$，其特征时间尺度定义为 $\\tau_j = \\frac{1}{|\\Re(\\lambda_j)|}$。这个时间尺度代表了相应模态的振幅变化一个 $e$ 因子所需的时间。\n然后，根据给定的划分时间尺度 $\\tau_{\\text{split}} = 10^{-3} \\, \\text{s}$，将特征值谱划分为“快”和“慢”子空间。\n如果模态 $j$ 的时间尺度 $\\tau_j$ 大于或等于划分时间尺度，则认为该模态是慢的：\n$$\n\\tau_j \\ge \\tau_{\\text{split}} \\iff \\frac{1}{|\\Re(\\lambda_j)|} \\ge \\tau_{\\text{split}} \\iff |\\Re(\\lambda_j)| \\le \\frac{1}{\\tau_{\\text{split}}}\n$$\n慢子空间的维度是满足此条件的特征值的数量。这个计数是每个测试用例的最终结果。此过程是像“内在低维流形”(Intrinsic Low-Dimensional Manifolds, ILDM) 这类降阶建模技术的基础，这些技术旨在通过仅沿着系统的慢模态进行演化来近似完整的系统动力学。\n\n实现过程如下：首先定义一个函数，用于计算任何给定状态 $x$ 的向量场 $f(x)$。然后，定义第二个函数，使用此向量场函数和中心差分格式来数值构建雅可比矩阵。最后，对每个测试用例，计算雅可比矩阵，找到其特征值，并根据定义的准则计算慢模态的数量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the problem of finding the dimension of the slow subspace for a\n    reacting flow system at different states.\n    \"\"\"\n    #\n    # --- GLOBAL CONSTANTS ---\n    #\n    # Universal gas constant in J/(mol.K)\n    RU = 8.314\n    # Pressure in Pa\n    P = 101325.0\n    # Molecular weights in kg/mol\n    W_F = 0.002016  # Fuel (H2)\n    W_O = 0.031999  # Oxidizer (O2)\n    W_P = 0.018015  # Product (H2O)\n    # Species constant heat capacities in J/(kg.K)\n    CP_F = 14300.0\n    CP_O = 918.0\n    CP_P = 1864.0\n    # Reaction stoichiometric coefficient (molar basis)\n    S = 0.5\n    # Arrhenius parameters\n    A = 5.0e6  # Pre-exponential factor in m^3/(mol.s)\n    EA = 1.5e5 # Activation energy in J/mol\n    # Heat release per mole of reaction in J/mol\n    Q = 2.418e5\n    # Timescale threshold for splitting fast/slow subspaces in s\n    TAU_SPLIT = 1.0e-3\n    \n    # Store constants in a dictionary for easy passing\n    params = {\n        \"RU\": RU, \"P\": P, \"W_F\": W_F, \"W_O\": W_O, \"W_P\": W_P,\n        \"CP_F\": CP_F, \"CP_O\": CP_O, \"CP_P\": CP_P,\n        \"S\": S, \"A\": A, \"EA\": EA, \"Q\": Q\n    }\n    \n    #\n    # --- TEST CASES ---\n    #\n    # Each case is a state vector x_star = [T, Y_F, Y_O]\n    test_cases = [\n        np.array([900.0, 0.1119, 0.8881]),      # Case 1\n        np.array([1150.0, 0.1119, 0.8881]),     # Case 2\n        np.array([1800.0, 0.01, 0.05]),        # Case 3\n        np.array([1500.0, 1.0e-6, 0.2]),       # Case 4\n    ]\n\n    def compute_rhs(x, p_):\n        \"\"\"\n        Computes the right-hand side (RHS) of the ODE system, f(x).\n        x: state vector [T, Y_F, Y_O]\n        p_: dictionary of physical and chemical parameters\n        \"\"\"\n        T, Y_F, Y_O = x[0], x[1], x[2]\n        \n        # Ensure mass fractions are physically plausible for calculation\n        Y_F = max(0.0, Y_F)\n        Y_O = max(0.0, Y_O)\n        Y_P = 1.0 - Y_F - Y_O\n        Y_P = max(0.0, Y_P)\n\n        # Mixture-averaged molecular weight\n        W_inv = Y_F / p_[\"W_F\"] + Y_O / p_[\"W_O\"] + Y_P / p_[\"W_P\"]\n        W_bar = 1.0 / W_inv\n\n        # Density from ideal gas law\n        rho = (p_[\"P\"] * W_bar) / (p_[\"RU\"] * T)\n\n        # Mixture specific heat\n        cp_mix = Y_F * p_[\"CP_F\"] + Y_O * p_[\"CP_O\"] + Y_P * p_[\"CP_P\"]\n        \n        # Arrhenius rate constant\n        k = p_[\"A\"] * math.exp(-p_[\"EA\"] / (p_[\"RU\"] * T))\n\n        # Molar concentrations\n        C_F = rho * Y_F / p_[\"W_F\"]\n        C_O = rho * Y_O / p_[\"W_O\"]\n\n        # Molar reaction rate\n        w_mole = k * C_F * C_O\n        \n        # Avoid division by zero if rho or cp_mix is zero\n        if rho == 0.0 or cp_mix == 0.0:\n            return np.zeros(3)\n\n        # ODE RHS components\n        dT_dt = (p_[\"Q\"] * w_mole) / (rho * cp_mix)\n        dYF_dt = (-p_[\"W_F\"] * w_mole) / rho\n        dYO_dt = (-p_[\"S\"] * p_[\"W_O\"] * w_mole) / rho\n        \n        return np.array([dT_dt, dYF_dt, dYO_dt])\n\n    def compute_jacobian_numerical(x_star, p_):\n        \"\"\"\n        Computes the Jacobian matrix numerically using a central difference scheme.\n        x_star: state vector at which to evaluate the Jacobian\n        p_: dictionary of parameters\n        \"\"\"\n        n = len(x_star)\n        J = np.zeros((n, n))\n        \n        eps_rel = 1e-6\n        eps_abs = 1e-9\n\n        for j in range(n):\n            h_j = eps_rel * abs(x_star[j]) + eps_abs\n            \n            x_plus = np.copy(x_star)\n            x_plus[j] += h_j\n            \n            x_minus = np.copy(x_star)\n            x_minus[j] -= h_j\n            \n            f_plus = compute_rhs(x_plus, p_)\n            f_minus = compute_rhs(x_minus, p_)\n            \n            j_col = (f_plus - f_minus) / (2.0 * h_j)\n            J[:, j] = j_col\n            \n        return J\n\n    results = []\n    inv_tau_split = 1.0 / TAU_SPLIT\n\n    for state in test_cases:\n        # 1. Compute the Jacobian at the given state\n        J = compute_jacobian_numerical(state, params)\n        \n        # 2. Compute the eigenvalues of the Jacobian\n        eigenvalues = np.linalg.eigvals(J)\n        \n        # 3. Count the number of slow modes\n        slow_modes_count = 0\n        for lam in eigenvalues:\n            if abs(lam.real) = inv_tau_split:\n                slow_modes_count += 1\n        \n        results.append(slow_modes_count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "降阶模型通常依赖于简化的物理原理，这会引入结构性不确定性，必须使用数据进行补偿。本练习让您扮演模型开发者的角色，执行数据驱动的封闭，这是现代降阶模型开发中的一项关键任务。您将通过求解一个带约束的优化问题来校准一个简单反应模型中的封闭项，旨在最小化模型预测与高保真“DNS”数据之间的失配，同时强制施加物理约束（例如物种浓度的有界性）。",
            "id": "4057083",
            "problem": "考虑一个简化的降阶模型，用于表示一个无量纲化的反应标量，该标量代表物种质量分数，记为 $y \\in [0,1]$。设高保真度的直接数值模拟 (DNS) 数据提供了一系列在均匀时间间隔（时间步长为 $\\Delta t$）下的快照 $\\{y^{\\mathrm{DNS}}_k\\}_{k=0}^{K}$。对于带有线性衰减和未解析闭合项的单步反应，其降阶模型 (ROM) 由以下显式 Euler 离散化给出\n$$\n\\widehat{y}_{k+1}(\\theta) \\;=\\; y^{\\mathrm{DNS}}_k \\;+\\; \\Delta t \\,\\Big( -\\lambda \\, y^{\\mathrm{DNS}}_k \\;+\\; s \\, y^{\\mathrm{DNS}}_k \\big(1 - y^{\\mathrm{DNS}}_k\\big) \\;+\\; \\theta \\, y^{\\mathrm{DNS}}_k \\big(1 - y^{\\mathrm{DNS}}_k\\big) \\Big),\n$$\n其中 $s$ 和 $\\lambda$ 是已知的非负参数，$\\theta$ 是一个待标定的标量闭合系数。闭合项被选为 $\\tau(y;\\theta) = \\theta \\, y(1-y)$ 以满足边界守恒性质 $\\tau(0;\\theta)=0$ 和 $\\tau(1;\\theta)=0$，确保纯态在闭合项贡献下保持不变。\n\n标定问题被构建为一个约束优化问题：找到能最小化单步预测与 DNS 之间总平方误差的 $\\theta$ 值，\n$$\nJ(\\theta) \\;=\\; \\sum_{k=0}^{K-1} \\left(\\widehat{y}_{k+1}(\\theta) - y^{\\mathrm{DNS}}_{k+1}\\right)^2,\n$$\n同时满足有界性约束，该约束强制要求从 DNS 状态出发的单步 ROM 预测值保持在物理上允许的区间内，\n$$\n0 \\;\\le\\; \\widehat{y}_{k+1}(\\theta) \\;\\le\\; 1 \\quad \\text{for all } k \\in \\{0,\\dots,K-1\\}.\n$$\n\n从物种守恒和反应动力学的第一性原理出发，其基本依据是物种质量分数满足生成速率和消耗速率之间的平衡。该 ROM 使用此平衡的低阶表示，其中包含一个 logistic 生成项 $s \\, y(1-y)$ 和一个线性消耗项 $-\\lambda y$，而未解析的亚格子贡献则由闭合项 $\\tau(y;\\theta) = \\theta \\, y(1-y)$ 参数化，该闭合项在纯态时为零，以在边界处保持物种守恒。\n\n您的任务是编写一个完整的程序，该程序为每个指定的测试用例（参数和 DNS 生成协议如下），构建关于 $\\theta$ 的约束最小二乘标定问题，求解该问题，并返回每个用例的最优 $\\theta$。所有量均为无量纲。不出现角度。不出现百分比。\n\n必需的算法规范：\n- 对于每个用例，DNS 数据 $\\{y^{\\mathrm{DNS}}_k\\}_{k=0}^{K}$ 必须通过使用真实的闭合项 $\\theta^\\star$ 模拟相同的 ROM 生成，采用上述显式 Euler 更新。具体来说，对于给定的初始条件 $y^{\\mathrm{DNS}}_0$，使用测试用例中提供的真实闭合参数 $\\theta^\\star$，为 $k \\in \\{0,\\dots,K-1\\}$ 迭代计算 $y^{\\mathrm{DNS}}_{k+1}$。\n- 标定过程必须仅使用生成的 DNS 序列和已知参数 $(s,\\lambda,\\Delta t)$，并且除了生成 DNS 数据外，不得使用 $\\theta^\\star$。优化变量是单个标量 $\\theta$。\n- 对每个 $k$ 的有界性约束必须严格按照上述规定施加于 $\\widehat{y}_{k+1}(\\theta)$。\n- 每个测试用例的最终答案必须是浮点数形式的最优 $\\theta$。您必须将所有用例的结果作为单个列表在单行上输出，具体格式如下所述。\n\n测试套件：\n- 用例 A (理想路径): $s = 2.0$, $\\lambda = 0.5$, $\\Delta t = 0.1$, $K = 10$, $y^{\\mathrm{DNS}}_0 = 0.2$, $\\theta^\\star = 0.3$。\n- 用例 B (近边界增长): $s = 1.5$, $\\lambda = 0.2$, $\\Delta t = 0.2$, $K = 8$, $y^{\\mathrm{DNS}}_0 = 0.05$, $\\theta^\\star = 0.8$。\n- 用例 C (近边界衰减): $s = 3.0$, $\\lambda = 1.2$, $\\Delta t = 0.05$, $K = 12$, $y^{\\mathrm{DNS}}_0 = 0.9$, $\\theta^\\star = -0.4$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个用例的估计闭合系数，形式为逗号分隔的列表并用方括号括起（例如，$[\\theta_A,\\theta_B,\\theta_C]$）。\n- 每个 $\\theta$ 值必须打印并精确到 $6$ 位小数。\n\n关于科学真实性和数值稳健性的说明：\n- 所选的闭合项 $\\tau(y;\\theta) = \\theta\\,y(1-y)$ 通过其构造保证了边界守恒性质，这对于取值在 $[0,1]$ 区间内的物种质量分数至关重要。\n- 有界性约束 $0 \\le \\widehat{y}_{k+1}(\\theta) \\le 1$ 强制要求在使用标定后的闭合项时，从 DNS 状态出发的单步预测具有物理可容许性。\n- 您可以使用任何数学上等效的方法来解决关于 $\\theta$ 的约束最小二乘问题。由于对于固定的 $\\{y^{\\mathrm{DNS}}_k\\}$，约束是 $\\theta$ 的线性函数，因此将无约束最小二乘问题的闭式解投影到由各步约束之交集所形成的可行区间上是可接受的方法。",
            "solution": "该问题要求在一个反应物种质量分数 $y$ 的降阶模型 (ROM) 中，标定一个标量闭合系数 $\\theta$。标定过程被构建为一个约束最小二乘问题，我们将对其进行分析和求解。\n\nROM 由以下显式 Euler 离散化给出：\n$$\n\\widehat{y}_{k+1}(\\theta) \\;=\\; y^{\\mathrm{DNS}}_k \\;+\\; \\Delta t \\,\\Big( -\\lambda \\, y^{\\mathrm{DNS}}_k \\;+\\; s \\, y^{\\mathrm{DNS}}_k \\big(1 - y^{\\mathrm{DNS}}_k\\big) \\;+\\; \\theta \\, y^{\\mathrm{DNS}}_k \\big(1 - y^{\\mathrm{DNS}}_k\\big) \\Big)\n$$\n其中 $\\{y^{\\mathrm{DNS}}_k\\}_{k=0}^{K}$ 是一个高保真度数据序列，$s$、$\\lambda$ 和 $\\Delta t$ 是已知参数。\n\n目标是找到 $\\theta$ 以最小化目标函数，\n$$\nJ(\\theta) \\;=\\; \\sum_{k=0}^{K-1} \\left(\\widehat{y}_{k+1}(\\theta) - y^{\\mathrm{DNS}}_{k+1}\\right)^2\n$$\n同时满足物理有界性约束：\n$$\n0 \\;\\le\\; \\widehat{y}_{k+1}(\\theta) \\;\\le\\; 1 \\quad \\text{for all } k \\in \\{0,\\dots,K-1\\}.\n$$\n\n首先，我们将单步预测 $\\widehat{y}_{k+1}(\\theta)$ 表示为一种能分离含 $\\theta$ 项的形式。为简化表示，我们令 $y_k \\equiv y^{\\mathrm{DNS}}_k$。\n我们可以将预测写为：\n$$\n\\widehat{y}_{k+1}(\\theta) = \\left[ y_k + \\Delta t \\Big( -\\lambda y_k + s y_k(1 - y_k) \\Big) \\right] + \\theta \\left[ \\Delta t \\, y_k(1-y_k) \\right]\n$$\n我们为每个时间步 $k \\in \\{0, \\dots, K-1\\}$ 定义以下量：\n1.  基础模型（不含闭合项）的预测：\n    $$\n    c_k = y_k + \\Delta t \\Big( -\\lambda y_k + s y_k(1-y_k) \\Big)\n    $$\n2.  $\\theta$ 的系数：\n    $$\n    a_k = \\Delta t \\, y_k(1-y_k)\n    $$\n根据这些定义，ROM 预测为 $\\widehat{y}_{k+1}(\\theta) = c_k + a_k \\theta$。\n\n目标函数 $J(\\theta)$ 是残差的平方和，其中第 $k$ 步的残差为 $r_k(\\theta) = \\widehat{y}_{k+1}(\\theta) - y_{k+1}$。\n$$\nr_k(\\theta) = (c_k + a_k \\theta) - y_{k+1} = a_k \\theta - (y_{k+1} - c_k)\n$$\n我们定义 $b_k = y_{k+1} - c_k$。目标函数变为：\n$$\nJ(\\theta) = \\sum_{k=0}^{K-1} (a_k \\theta - b_k)^2\n$$\n这是关于 $\\theta$ 的二次函数。为求无约束最小值，我们将 $J(\\theta)$ 对 $\\theta$ 求导并令其为零：\n$$\n\\frac{dJ}{d\\theta} = \\sum_{k=0}^{K-1} 2(a_k \\theta - b_k) a_k = 2\\theta \\left(\\sum_{k=0}^{K-1} a_k^2\\right) - 2\\left(\\sum_{k=0}^{K-1} a_k b_k\\right) = 0\n$$\n假设 $\\sum a_k^2 \\neq 0$（除非所有 $y_k$ 都为平凡值，即 $0$ 或 $1$，否则此条件成立），则 $\\theta$ 的无约束最小二乘解为：\n$$\n\\theta_{\\mathrm{unc}} = \\frac{\\sum_{k=0}^{K-1} a_k b_k}{\\sum_{k=0}^{K-1} a_k^2}\n$$\n\n接下来，我们分析有界性约束。对于每个 $k \\in \\{0, \\dots, K-1\\}$，必须满足：\n$$\n0 \\le c_k + a_k \\theta \\le 1\n$$\n这产生了一对关于 $\\theta$ 的线性不等式：\n$$\n-c_k \\le a_k \\theta \\quad \\text{and} \\quad a_k \\theta \\le 1 - c_k\n$$\n由于 $y \\in [0,1]$，项 $y_k(1-y_k)$ 是非负的。又因为 $\\Delta t  0$，我们有 $a_k = \\Delta t \\, y_k(1-y_k) \\ge 0$。\n如果 $a_k  0$，我们可以用它来除，得到关于 $\\theta$ 的界：\n$$\n-\\frac{c_k}{a_k} \\le \\theta \\quad \\text{and} \\quad \\theta \\le \\frac{1-c_k}{a_k}\n$$\n令 $L_k = -c_k/a_k$ 和 $U_k = (1-c_k)/a_k$。对于每个 $a_k  0$ 的步 $k$，约束要求 $\\theta \\in [L_k, U_k]$。\n如果 $a_k = 0$（即，如果 $y_k=0$ 或 $y_k=1$），约束变为 $0 \\le c_k \\le 1$。这是对基础模型参数的一个条件，并不约束 $\\theta$。问题参数的选择会确保该条件得到满足。这些步骤对 $\\theta$ 不提供界，在确定可行集时可以忽略。\n\n$\\theta$ 的总可行集是所有单步约束区间的交集：\n$$\n\\theta \\in \\bigcap_{k \\text{ with } a_k0} [L_k, U_k]\n$$\n该交集是一个单一区间 $[L, U]$，其中：\n$$\nL = \\max_{\\{k \\,|\\, a_k0\\}} \\{L_k\\} \\quad \\text{and} \\quad U = \\min_{\\{k \\,|\\, a_k0\\}} \\{U_k\\}\n$$\n如果索引集合 $\\{k \\,|\\, a_k0\\}$ 为空，则可行集为 $(-\\infty, \\infty)$。\n\n问题现在简化为在区间 $[L, U]$ 上最小化凸二次函数 $J(\\theta)$。其解可通过将无约束最小值 $\\theta_{\\mathrm{unc}}$ 投影到该区间上来找到：\n$$\n\\theta_{\\mathrm{opt}} = \n\\begin{cases} \nL  \\text{if } \\theta_{\\mathrm{unc}}  L \\\\\n\\theta_{\\mathrm{unc}}  \\text{if } L \\le \\theta_{\\mathrm{unc}} \\le U \\\\\nU  \\text{if } \\theta_{\\mathrm{unc}}  U\n\\end{cases}\n$$\n这可以使用一个裁剪函数紧凑地写成：$\\theta_{\\mathrm{opt}} = \\mathrm{clip}(\\theta_{\\mathrm{unc}}, L, U)$。\n\n问题还规定 DNS 数据 $\\{y^{\\mathrm{DNS}}_k\\}$ 是使用具有“真实”参数 $\\theta^\\star$ 的相同模型结构生成的。这意味着：\n$$\ny_{k+1} = y_k + \\Delta t \\left( -\\lambda y_k + s y_k(1-y_k) + \\theta^\\star y_k(1-y_k) \\right) = c_k + a_k \\theta^\\star\n$$\n由此，我们有 $y_{k+1} - c_k = a_k \\theta^\\star$。将此代入 $b_k$ 的定义，我们得到 $b_k = a_k \\theta^\\star$。现在，如果我们将此代入无约束最优解的表达式中：\n$$\n\\theta_{\\mathrm{unc}} = \\frac{\\sum a_k (a_k \\theta^\\star)}{\\sum a_k^2} = \\frac{\\theta^\\star \\sum a_k^2}{\\sum a_k^2} = \\theta^\\star\n$$\n这表明，在这种理想化的“孪生实验”设置中，无约束最小二乘解恰好是真实参数 $\\theta^\\star$。由于数据是用 $\\theta^\\star$ 生成的，轨迹必须是物理有界的，这意味着 $\\theta^\\star$ 本身满足所有约束，即 $L \\le \\theta^\\star \\le U$。因此，假设没有数值精度误差，最终的最优解 $\\theta_{\\mathrm{opt}}$ 将等于 $\\theta^\\star$。\n\n最终的算法如下：\n1.  对每个测试用例，通过使用给定的 $\\theta^\\star$ 迭代应用更新规则，生成数据序列 $\\{y_k^{\\mathrm{DNS}}\\}_{k=0}^{K}$。\n2.  使用生成的序列，计算 $k=0, \\dots, K-1$ 的向量 $a_k$、$b_k$ 和 $c_k$。\n3.  计算无约束解 $\\theta_{\\mathrm{unc}}$。\n4.  根据有界性约束确定可行区间 $[L, U]$。\n5.  通过将 $\\theta_{\\mathrm{unc}}$ 裁剪到区间 $[L, U]$ 来计算最优约束解 $\\theta_{\\mathrm{opt}}$。\n6.  收集每个用例得到的 $\\theta_{\\mathrm{opt}}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the constrained least-squares calibration problem for the closure coefficient theta\n    for a set of test cases.\n    \"\"\"\n    \n    # Test suite defined in the problem statement.\n    test_cases = [\n        # Case A (happy path)\n        {'s': 2.0, 'lam': 0.5, 'dt': 0.1, 'K': 10, 'y0': 0.2, 'theta_star': 0.3},\n        # Case B (near-boundary growth)\n        {'s': 1.5, 'lam': 0.2, 'dt': 0.2, 'K': 8, 'y0': 0.05, 'theta_star': 0.8},\n        # Case C (near-boundary decay)\n        {'s': 3.0, 'lam': 1.2, 'dt': 0.05, 'K': 12, 'y0': 0.9, 'theta_star': -0.4},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        s = case['s']\n        lam = case['lam']\n        dt = case['dt']\n        K = case['K']\n        y0 = case['y0']\n        theta_star = case['theta_star']\n\n        # Step 1: Generate DNS data using the model with the true parameter theta_star.\n        y_dns = np.zeros(K + 1)\n        y_dns[0] = y0\n        for k in range(K):\n            y_k = y_dns[k]\n            # Production/destruction term: s * y(1-y) - lambda * y\n            # Combined closure term: theta_star * y(1-y)\n            # The model can be grouped as: -lambda * y + (s + theta_star) * y(1-y)\n            source_term = -lam * y_k + (s + theta_star) * y_k * (1 - y_k)\n            y_dns[k+1] = y_k + dt * source_term\n            \n        # Extract y_k and y_{k+1} sequences for calibration\n        y_k_seq = y_dns[:-1]\n        y_k_plus_1_seq = y_dns[1:]\n\n        # Step 2: Set up the least-squares problem AX=B where X is theta\n        # A_k = a_k = dt * y_k * (1 - y_k)\n        # B_k = b_k = y_{k+1} - c_k, where c_k is the base model prediction\n        \n        # Coefficient of theta\n        a_k_vec = dt * y_k_seq * (1 - y_k_seq)\n        \n        # Base model prediction (without closure term)\n        c_k_vec = y_k_seq + dt * (-lam * y_k_seq + s * y_k_seq * (1 - y_k_seq))\n        \n        # Target vector\n        b_k_vec = y_k_plus_1_seq - c_k_vec\n\n        # Step 3: Solve for the unconstrained optimal theta\n        sum_a_sq = np.sum(a_k_vec**2)\n        sum_a_b = np.sum(a_k_vec * b_k_vec)\n        \n        if sum_a_sq  1e-15: # Avoid division by zero in degenerate cases\n            # If all a_k are zero, theta is unconstrained by the objective.\n            # Any value is optimal. We can pick 0 or handle it as an error.\n            # However, problem setup guarantees this won't be the primary path.\n            theta_unc = 0.0\n        else:\n            theta_unc = sum_a_b / sum_a_sq\n\n        # Step 4: Determine the feasible interval [L, U] from boundedness constraints\n        # 0 = c_k + a_k * theta = 1\n        \n        # We only consider steps where a_k > 0, as a_k=0 provides no constraint on theta\n        mask = a_k_vec > 1e-15\n        \n        if np.any(mask):\n            a_k_masked = a_k_vec[mask]\n            c_k_masked = c_k_vec[mask]\n            \n            # Lower bounds: L_k = -c_k / a_k\n            lower_bounds_k = -c_k_masked / a_k_masked\n            # Upper bounds: U_k = (1 - c_k) / a_k\n            upper_bounds_k = (1 - c_k_masked) / a_k_masked\n            \n            # The overall bounds are the tightest of these\n            L_bound = np.max(lower_bounds_k)\n            U_bound = np.min(upper_bounds_k)\n        else:\n            # If no a_k > 0, theta is unconstrained by bounds\n            L_bound = -np.inf\n            U_bound = np.inf\n            \n        # Step 5: Project the unconstrained solution onto the feasible interval\n        theta_opt = np.clip(theta_unc, L_bound, U_bound)\n        \n        results.append(theta_opt)\n\n    # Final print statement in the exact required format.\n    # Each theta must be rounded to exactly 6 decimal places.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```"
        }
    ]
}