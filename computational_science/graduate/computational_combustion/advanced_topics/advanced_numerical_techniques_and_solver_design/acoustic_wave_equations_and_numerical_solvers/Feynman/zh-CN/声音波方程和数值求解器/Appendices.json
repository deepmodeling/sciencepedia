{
    "hands_on_practices": [
        {
            "introduction": "在计算科学中，任何模拟的第一步都是确保我们编写的代码是正确的。本练习将指导您使用“制造解方法”（Method of Manufactured Solutions, MMS）——一种用于验证数值求解器精度的黄金标准技术 。通过将数值解与已知的精确解进行比较，并进行网格加密研究，我们可以定量地验证我们的实现是否达到了其理论收敛阶。",
            "id": "4005931",
            "problem": "考虑在等熵和无粘性近似下，均匀反应混合物中的一维小振幅声学问题。其线性化方程将周期性域 $x \\in [0,1]$ 上的无量纲压力 $p(x,t)$ 和无量纲速度 $u(x,t)$ 耦合如下：\n$$\n\\frac{\\partial p}{\\partial t} + \\frac{\\partial u}{\\partial x} = S_p(x,t), \\qquad \\frac{\\partial u}{\\partial t} + \\frac{\\partial p}{\\partial x} = S_u(x,t),\n$$\n其中，制造解方法 (Method of Manufactured Solutions, MMS) 指定了一个精确解，并且源项 $S_p(x,t)$ 和 $S_u(x,t)$ 的选择使得该精确解恒满足这些方程。假设已经使用特征密度 $\\rho_0 = 1$ 和声速 $c = 1$ 进行了无量纲化，因此所有变量都是无量纲的，并且三角函数中使用的角度以弧度为单位。\n\n从可压缩流体的质量和动量守恒出发，在具有恒定基准密度的静止状态附近进行线性化，并结合等熵关系 $p = c^2 \\rho$，可以导出上述耦合关系作为基本基础。对于MMS，取制造场为：\n$$\np^{\\star}(x,t) = \\sin(\\kappa x)\\cos(\\omega t), \\qquad u^{\\star}(x,t) = \\sin(\\kappa x)\\sin(\\omega t),\n$$\n其中 $\\kappa = 2\\pi m$（$m$ 为域上的整数波数），$\\omega = 2\\pi$（因此时间周期为 $1$）。推导源项 $S_p(x,t)$ 和 $S_u(x,t)$，以确保 $p^{\\star}$ 和 $u^{\\star}$ 精确满足偏微分方程。在具有 $N$ 个点的均匀网格上，为一阶导数实现两种空间离散化方法：\n- 二阶中心差分格式，\n- 四阶中心差分格式。\n\n使用显式经典四阶 Runge–Kutta 时间步进法，并通过 Courant–Friedrichs–Lewy 数 $\\nu$ 来选择时间步长，即 $\\Delta t = \\nu \\Delta x$，其中 $\\Delta x = 1/N$ 且 $\\nu = 0.2$。使用周期性边界条件，从 $t=0$ 积分到最终时间 $t=T$（其中 $T = 0.3$）。使用 $p(x,0) = p^{\\star}(x,0)$ 和 $u(x,0) = u^{\\star}(x,0)$ 进行初始化。\n\n对于每种空间格式，计算在 $t=T$ 时 $p$ 和 $u$ 在网格加密下的离散相对 $L_2$ 误差。场 $f$ 的离散相对 $L_2$ 误差定义为：\n$$\n\\varepsilon_{L_2}(f) = \\frac{\\left( \\Delta x \\sum_{i=0}^{N-1} \\left[f_i^{\\text{num}}(T) - f_i^{\\star}(T)\\right]^2 \\right)^{1/2}}{\\left( \\Delta x \\sum_{i=0}^{N-1} \\left[f_i^{\\star}(T)\\right]^2 \\right)^{1/2}}.\n$$\n通过对不同网格尺寸下的 $\\log(\\varepsilon_{L_2})$ 与 $\\log(\\Delta x)$ 的关系进行直线拟合，并取其斜率，来估计每个场和每种格式的观测收敛阶 $p_{\\text{obs}}$。\n\n您的程序必须实现上述要求，并使用以下测试套件，为每种空间格式生成 $p$ 和 $u$ 的观测收敛阶：\n- 二阶格式，$m=1$，$N \\in \\{32,64,128,256\\}$，\n- 四阶格式，$m=1$，$N \\in \\{32,64,128,256\\}$。\n\n所有量均为无量纲，角度以弧度为单位。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[p_{\\text{obs}}^{(2)}, u_{\\text{obs}}^{(2)}, p_{\\text{obs}}^{(4)}, u_{\\text{obs}}^{(4)}]$，其中上标表示空间格式的阶数。每个条目必须是四舍五入到三位小数的浮点数。",
            "solution": "在尝试求解之前，该问题需经过正式的验证过程。\n\n### 步骤1：提取给定信息\n\n问题陈述中提供了以下信息：\n-   **控制方程**：\n    $$\n    \\frac{\\partial p}{\\partial t} + \\frac{\\partial u}{\\partial x} = S_p(x,t), \\qquad \\frac{\\partial u}{\\partial t} + \\frac{\\partial p}{\\partial x} = S_u(x,t)\n    $$\n-   **域**：周期性，$x \\in [0,1]$。\n-   **无量纲常数**：特征密度 $\\rho_0 = 1$，声速 $c = 1$。\n-   **制造解**：\n    $$\n    p^{\\star}(x,t) = \\sin(\\kappa x)\\cos(\\omega t), \\qquad u^{\\star}(x,t) = \\sin(\\kappa x)\\sin(\\omega t)\n    $$\n-   **制造解参数**：$\\kappa = 2\\pi m$（$m$ 为整数波数），$\\omega = 2\\pi$。\n-   **数值网格**：具有 $N$ 个点的均匀网格，网格间距 $\\Delta x = 1/N$。\n-   **空间离散格式**：\n    1.  二阶中心差分。\n    2.  四阶中心差分。\n-   **时间离散格式**：经典四阶 Runge-Kutta (RK4)。\n-   **时间步长**：$\\Delta t = \\nu \\Delta x$，Courant–Friedrichs–Lewy (CFL) 数 $\\nu = 0.2$。\n-   **模拟时间**：从 $t=0$ 积分到 $T=0.3$。\n-   **初始条件**：$p(x,0) = p^{\\star}(x,0)$，$u(x,0) = u^{\\star}(x,0)$。\n-   **误差度量**：场 $f$ 的离散相对 $L_2$ 误差：\n    $$\n    \\varepsilon_{L_2}(f) = \\frac{\\left( \\Delta x \\sum_{i=0}^{N-1} \\left[f_i^{\\text{num}}(T) - f_i^{\\star}(T)\\right]^2 \\right)^{1/2}}{\\left( \\Delta x \\sum_{i=0}^{N-1} \\left[f_i^{\\star}(T)\\right]^2 \\right)^{1/2}}\n    $$\n-   **收敛阶估计**：观测到的收敛阶 $p_{\\text{obs}}$ 是 $\\log(\\varepsilon_{L_2})$ 相对于 $\\log(\\Delta x)$ 的线性拟合斜率。\n-   **测试套件**：\n    -   二阶格式：$m=1$，$N \\in \\{32, 64, 128, 256\\}$。\n    -   四阶格式：$m=1$，$N \\in \\{32, 64, 128, 256\\}$。\n-   **输出格式**：一个逗号分隔的列表 $[p_{\\text{obs}}^{(2)}, u_{\\text{obs}}^{(2)}, p_{\\text{obs}}^{(4)}, u_{\\text{obs}}^{(4)}]$，数值四舍五入到三位小数。\n\n### 步骤2：使用提取的给定信息进行验证\n\n根据验证标准对问题进行评估：\n-   **科学基础**：该问题建立在线性化声学方程之上，这是流体动力学中的一个基本模型。制造解方法（MMS）是验证数值代码实现正确性的标准且严谨的技术。所有方面均符合计算物理学的既定原则。\n-   **适定性**：该问题描述了一个针对双曲型偏微分方程（PDE）组的适定初边值问题。初始条件、周期性边界条件和源项（待推导）都已明确指定，确保存在唯一解。所提出的数值方法是解决此类问题的标准方法。\n-   **客观性**：问题以精确、无歧义的数学和技术语言陈述，不含主观或基于意见的元素。\n\n该问题没有表现出任何列出的缺陷，如科学上不健全、不完整、矛盾或含糊不清。\n\n### 步骤3：结论与行动\n\n问题陈述被判定为**有效**。将按照指定要求制定解决方案。\n\n### 解的推导与方法论\n\n解决方案需要几个步骤：为制造解方法（MMS）推导源项，实现数值离散格式，以及分析模拟结果以确定收敛阶。\n\n**1. 源项的推导**\n\n源项 $S_p(x,t)$ 和 $S_u(x,t)$ 的定义是使得制造解 $p^{\\star}(x,t)$ 和 $u^{\\star}(x,t)$ 精确满足控制偏微分方程。我们将 $p^{\\star}$ 和 $u^{\\star}$ 代入偏微分方程中。\n\n首先，我们计算制造解的必要偏导数：\n$$\np^{\\star}(x,t) = \\sin(\\kappa x)\\cos(\\omega t) \\\\\nu^{\\star}(x,t) = \\sin(\\kappa x)\\sin(\\omega t)\n$$\n导数为：\n$$\n\\frac{\\partial p^{\\star}}{\\partial t} = -\\omega \\sin(\\kappa x)\\sin(\\omega t) \\\\\n\\frac{\\partial p^{\\star}}{\\partial x} = \\kappa \\cos(\\kappa x)\\cos(\\omega t) \\\\\n\\frac{\\partial u^{\\star}}{\\partial t} = \\omega \\sin(\\kappa x)\\cos(\\omega t) \\\\\n\\frac{\\partial u^{\\star}}{\\partial x} = \\kappa \\cos(\\kappa x)\\sin(\\omega t)\n$$\n将这些导数代入控制方程，得到源项：\n$$\nS_p(x,t) = \\frac{\\partial p^{\\star}}{\\partial t} + \\frac{\\partial u^{\\star}}{\\partial x} = -\\omega \\sin(\\kappa x)\\sin(\\omega t) + \\kappa \\cos(\\kappa x)\\sin(\\omega t) = \\left( \\kappa \\cos(\\kappa x) - \\omega \\sin(\\kappa x) \\right) \\sin(\\omega t)\n$$\n$$\nS_u(x,t) = \\frac{\\partial u^{\\star}}{\\partial t} + \\frac{\\partial p^{\\star}}{\\partial x} = \\omega \\sin(\\kappa x)\\cos(\\omega t) + \\kappa \\cos(\\kappa x)\\cos(\\omega t) = \\left( \\omega \\sin(\\kappa x) + \\kappa \\cos(\\kappa x) \\right) \\cos(\\omega t)\n$$\n必须在数值求解器中实现 $S_p$ 和 $S_u$ 的这些表达式。\n\n**2. 数值离散化**\n\n该问题使用线方法求解，即首先对空间导数进行离散化，将偏微分方程组（PDEs）转换为一个大的关于时间的常微分方程组（ODEs）。\n\n空间域 $x \\in [0,1]$ 被离散化为 $N$ 个网格点 $x_i = i \\Delta x$，其中 $i = 0, 1, \\dots, N-1$，网格间距为 $\\Delta x = 1/N$。解场 $p(x,t)$ 和 $u(x,t)$ 由网格函数 $p_i(t) \\approx p(x_i,t)$ 和 $u_i(t) \\approx u(x_i,t)$ 近似。\n\n半离散化的常微分方程组为：\n$$\n\\frac{d p_i}{dt} = -(\\mathcal{D}_x u)_i + S_p(x_i, t) \\\\\n\\frac{d u_i}{dt} = -(\\mathcal{D}_x p)_i + S_u(x_i, t)\n$$\n其中 $\\mathcal{D}_x$ 是空间导数 $\\frac{\\partial}{\\partial x}$ 的有限差分算子。\n\n-   **二阶中心差分 ($\\mathcal{D}_x^{(2)}$)**：对于网格函数 $f_i$，二阶精度的中心差分为：\n    $$\n    (\\mathcal{D}_x^{(2)} f)_i = \\frac{f_{i+1} - f_{i-1}}{2\\Delta x}\n    $$\n    周期性边界条件意味着索引对 $N$ 取模，即 $f_{-1} = f_{N-1}$ 且 $f_{N} = f_0$。\n\n-   **四阶中心差分 ($\\mathcal{D}_x^{(4)}$)**：四阶精度的中心差分为：\n    $$\n    (\\mathcal{D}_x^{(4)} f)_i = \\frac{-f_{i+2} + 8 f_{i+1} - 8 f_{i-1} + f_{i-2}}{12\\Delta x}\n    $$\n    同样地，周期性边界条件应用于索引。\n\n然后，该常微分方程组使用经典的四阶 Runge-Kutta (RK4) 方法进行时间积分。对于一个常微分方程组 $\\frac{d\\mathbf{V}}{dt} = \\mathbf{F}(t, \\mathbf{V})$，其中 $\\mathbf{V}(t) = [p_0, \\dots, p_{N-1}, u_0, \\dots, u_{N-1}]^T$，从时间 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的 RK4 更新为：\n$$\n\\mathbf{k}_1 = \\mathbf{F}(t_n, \\mathbf{V}_n) \\\\\n\\mathbf{k}_2 = \\mathbf{F}(t_n + \\frac{\\Delta t}{2}, \\mathbf{V}_n + \\frac{\\Delta t}{2}\\mathbf{k}_1) \\\\\n\\mathbf{k}_3 = \\mathbf{F}(t_n + \\frac{\\Delta t}{2}, \\mathbf{V}_n + \\frac{\\Delta t}{2}\\mathbf{k}_2) \\\\\n\\mathbf{k}_4 = \\mathbf{F}(t_n + \\Delta t, \\mathbf{V}_n + \\Delta t \\mathbf{k}_3) \\\\\n\\mathbf{V}_{n+1} = \\mathbf{V}_n + \\frac{\\Delta t}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\n时间步长由 CFL 条件固定：$\\Delta t = \\nu \\Delta x = 0.2 \\Delta x$。\n\n**3. 验证过程**\n\n模拟从 $t=0$ 时的初始条件开始：\n$$\np(x,0) = p^{\\star}(x,0) = \\sin(\\kappa x)\\cos(0) = \\sin(\\kappa x) \\\\\nu(x,0) = u^{\\star}(x,0) = \\sin(\\kappa x)\\sin(0) = 0\n$$\n对于每个网格分辨率 $N \\in \\{32, 64, 128, 256\\}$，模拟运行至最终时间 $T=0.3$。在 $t=T$ 时，通过比较网格点上的数值解 $f^{\\text{num}}$ 和精确解 $f^{\\star}$，计算 $p$ 和 $u$ 的离散相对 $L_2$ 误差 $\\varepsilon_{L_2}$。\n\n收敛阶由误差行为假设 $\\varepsilon_{L_2} \\approx C (\\Delta x)^{p_{\\text{obs}}}$ (其中 $C$ 为某个常数) 确定。对此关系取对数可得：\n$$\n\\log(\\varepsilon_{L_2}) \\approx \\log(C) + p_{\\text{obs}} \\log(\\Delta x)\n$$\n这表明 $\\log(\\varepsilon_{L_2})$ 和 $\\log(\\Delta x)$ 之间存在线性关系。这条线的斜率即为观测到的收敛阶 $p_{\\text{obs}}$。通过对从不同网格分辨率 $N_j$ 获得的数据点集 $(\\log(\\Delta x_j), \\log(\\varepsilon_{j}))$ 进行线性最小二乘回归来估计该斜率。对两个场（$p$，$u$）和两种空间格式（二阶和四阶）重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the Method of Manufactured Solutions for the 1D linearized\n    acoustic equations, computes grid refinement errors, and determines\n    the observed order of convergence for 2nd and 4th-order spatial schemes.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    M_WAVENUMBER = 1\n    NU_CFL = 0.2\n    T_FINAL = 0.3\n    N_VALS = [32, 64, 128, 256]\n    SCHEMES = [2, 4]\n    \n    KAPPA = 2.0 * np.pi * M_WAVENUMBER\n    OMEGA = 2.0 * np.pi\n\n    # --- Manufactured Solution and Source Terms ---\n    def p_exact(x, t):\n        return np.sin(KAPPA * x) * np.cos(OMEGA * t)\n\n    def u_exact(x, t):\n        return np.sin(KAPPA * x) * np.sin(OMEGA * t)\n\n    def Sp_source(x, t):\n        term1 = KAPPA * np.cos(KAPPA * x)\n        term2 = -OMEGA * np.sin(KAPPA * x)\n        return (term1 + term2) * np.sin(OMEGA * t)\n\n    def Su_source(x, t):\n        term1 = OMEGA * np.sin(KAPPA * x)\n        term2 = KAPPA * np.cos(KAPPA * x)\n        return (term1 + term2) * np.cos(OMEGA * t)\n\n    # --- Spatial Derivative Operators ---\n    def deriv_2nd(f, dx):\n        \"\"\"Computes 2nd-order centered difference with periodic BCs.\"\"\"\n        f_im1 = np.roll(f, 1)\n        f_ip1 = np.roll(f, -1)\n        return (f_ip1 - f_im1) / (2.0 * dx)\n\n    def deriv_4th(f, dx):\n        \"\"\"Computes 4th-order centered difference with periodic BCs.\"\"\"\n        f_im2 = np.roll(f, 2)\n        f_im1 = np.roll(f, 1)\n        f_ip1 = np.roll(f, -1)\n        f_ip2 = np.roll(f, -2)\n        return (-f_ip2 + 8.0 * f_ip1 - 8.0 * f_im1 + f_im2) / (12.0 * dx)\n\n    # --- RHS of the ODE system dV/dt = F(t, V) ---\n    def compute_rhs(t, p_vec, u_vec, x_grid, dx, scheme_order):\n        if scheme_order == 2:\n            dp_dx = deriv_2nd(p_vec, dx)\n            du_dx = deriv_2nd(u_vec, dx)\n        elif scheme_order == 4:\n            dp_dx = deriv_4th(p_vec, dx)\n            du_dx = deriv_4th(u_vec, dx)\n        else:\n            raise ValueError(\"Unsupported scheme order\")\n            \n        rhs_p = -du_dx + Sp_source(x_grid, t)\n        rhs_u = -dp_dx + Su_source(x_grid, t)\n        \n        return rhs_p, rhs_u\n\n    # --- Main simulation runner ---\n    def run_simulation(N, scheme_order):\n        # Grid and time step setup\n        dx = 1.0 / N\n        dt = NU_CFL * dx\n        x_grid = np.linspace(0.0, 1.0, N, endpoint=False)\n\n        # Initial conditions\n        p = p_exact(x_grid, 0.0)\n        u = u_exact(x_grid, 0.0)\n        t = 0.0\n\n        # Time integration loop (RK4)\n        while t  T_FINAL:\n            # Prevent overstepping final time\n            dt_current = min(dt, T_FINAL - t)\n            \n            # k1\n            k1_p, k1_u = compute_rhs(t, p, u, x_grid, dx, scheme_order)\n            \n            # k2\n            p_temp = p + 0.5 * dt_current * k1_p\n            u_temp = u + 0.5 * dt_current * k1_u\n            k2_p, k2_u = compute_rhs(t + 0.5 * dt_current, p_temp, u_temp, x_grid, dx, scheme_order)\n\n            # k3\n            p_temp = p + 0.5 * dt_current * k2_p\n            u_temp = u + 0.5 * dt_current * k2_u\n            k3_p, k3_u = compute_rhs(t + 0.5 * dt_current, p_temp, u_temp, x_grid, dx, scheme_order)\n            \n            # k4\n            p_temp = p + dt_current * k3_p\n            u_temp = u + dt_current * k3_u\n            k4_p, k4_u = compute_rhs(t + dt_current, p_temp, u_temp, x_grid, dx, scheme_order)\n            \n            # Update solution\n            p += (dt_current / 6.0) * (k1_p + 2.0 * k2_p + 2.0 * k3_p + k4_p)\n            u += (dt_current / 6.0) * (k1_u + 2.0 * k2_u + 2.0 * k3_u + k4_u)\n            \n            t += dt_current\n\n        # --- Error Calculation ---\n        p_sol_exact = p_exact(x_grid, T_FINAL)\n        u_sol_exact = u_exact(x_grid, T_FINAL)\n        \n        # Using np.linalg.norm is equivalent to the formula since sqrt(dx) cancels.\n        error_p = np.linalg.norm(p - p_sol_exact) / np.linalg.norm(p_sol_exact)\n        error_u = np.linalg.norm(u - u_sol_exact) / np.linalg.norm(u_sol_exact)\n        \n        return error_p, error_u\n\n    # --- Convergence Analysis ---\n    all_results = []\n    dx_vals = 1.0 / np.array(N_VALS)\n    log_dx = np.log(dx_vals)\n    \n    for order in SCHEMES:\n        errors_p = []\n        errors_u = []\n        for n_val in N_VALS:\n            err_p, err_u = run_simulation(n_val, order)\n            errors_p.append(err_p)\n            errors_u.append(err_u)\n            \n        # Fit log(error) vs log(dx) to find the slope (order of convergence)\n        log_err_p = np.log(np.array(errors_p))\n        log_err_u = np.log(np.array(errors_u))\n        \n        # polyfit returns [slope, intercept] for degree 1\n        p_obs_p = np.polyfit(log_dx, log_err_p, 1)[0]\n        p_obs_u = np.polyfit(log_dx, log_err_u, 1)[0]\n        \n        all_results.append(p_obs_p)\n        all_results.append(p_obs_u)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.3f}' for r in all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一旦我们验证了求解器的正确性，下一个关键问题就是效率：对于给定的问题，哪种数值方法能以最低的计算成本达到所需的精度？本练习通过比较两种强大的空间离散化技术——谱方法和高阶有限差分法，来直接解决这个问题 。您将亲手实现并评估它们在模拟声脉冲传播时的性能权衡，从而深入理解计算成本与数值精度之间的关系。",
            "id": "4005955",
            "problem": "考虑计算燃烧室中的一维小振幅声学状态，在该均匀介质中，线性化可压缩欧拉方程可简化为关于压力扰动 $p(x,t)$ 和粒子速度 $u(x,t)$ 的一阶声学系统，\n$$\n\\frac{\\partial p}{\\partial t} + \\rho_0 c^2 \\frac{\\partial u}{\\partial x} = 0, \\qquad\n\\frac{\\partial u}{\\partial t} + \\frac{1}{\\rho_0} \\frac{\\partial p}{\\partial x} = 0,\n$$\n其中背景密度 $\\rho_0$ 和声速 $c$ 为常数。假设在长度为 $L$ 的空间域上采用周期性边界条件，并根据向右移动的黎曼不变量初始化一个向右传播的声脉冲：选择一个初始压力场 $p(x,0)$，并通过 $u(x,0) = p(x,0)/(\\rho_0 c)$ 设置初始速度场 $u(x,0)$，使得解向右传播而不产生向左传播的波。\n\n您的任务是，在将此声脉冲传播 $100$ 个波长的距离上，比较两种数值空间离散化方法的计算成本和精度：\n- 使用快速傅里叶变换 (FFT) 计算空间导数的傅里叶伪谱法。\n- 使用一阶空间导数的显式模板的高阶中心有限差分法。\n\n为确保公平比较，两种方法的时间积分均应使用相同的显式四阶龙格－库塔 (RK4) 方案。域设置为 $L = 100 \\lambda$，其中 $\\lambda$ 是脉冲定义中使用的载波声波长。使用代表空气的常数声速 $c$ 和密度 $\\rho_0$，具体为 $\\rho_0 = 1\\,\\mathrm{kg/m^3}$ 和 $c = 340\\,\\mathrm{m/s}$。在 $[0,L]$ 上使用周期性边界条件。\n\n将初始脉冲定义为高斯调制的余弦，\n$$\np(x,0) = A \\cos\\left(\\frac{2\\pi x}{\\lambda}\\right) \\exp\\left(-\\frac{(x-x_0)^2}{2\\sigma^2}\\right),\n$$\n其振幅为 $A$，中心为 $x_0$，宽度为 $\\sigma$。设置 $A=1\\,\\mathrm{Pa}$，$x_0 = L/4$，以及 $\\sigma = 3\\lambda$。定义 $u(x,0) = p(x,0)/(\\rho_0 c)$ 以产生纯粹的向右传播的波。\n\n对于这两种方法，将系统从 $t=0$ 演化到 $t=T$，$T = L/c$（一次全域传播），使用的时间步长 $\\Delta t$ 满足 $\\Delta t = \\mathrm{CFL}\\,\\Delta x / c$，其中 $\\mathrm{CFL} = 0.5$ 且 $\\Delta x = L/N$，$N$ 是空间网格点的数量。这样的选择确保 $T/\\Delta t$ 为整数，使得结束时间恰好与一次完整的传播对齐。有限差分法应使用一阶导数的中心模板；根据测试用例，使用四阶精度的 $5$ 点模板或六阶精度的 $7$ 点模板。\n\n精度指标：在演化到 $t=T$ 后，计算压力场的相对离散 $L^2$ 误差，\n$$\n\\varepsilon = \\frac{\\left\\|p(\\cdot,T) - p(\\cdot,0)\\right\\|_2}{\\left\\|p(\\cdot,0)\\right\\|_2},\n$$\n其中离散范数定义为 $\\|f\\|_2 = \\sqrt{\\Delta x \\sum_{i=0}^{N-1} f_i^2}$。\n\n计算成本指标：\n- 对于谱方法，报告在整个模拟过程中用于计算空间导数的一维快速傅里叶变换的总调用次数。将每次正向和逆向变换计为一次 FFT 调用。在所述的伪谱实现中，在龙格－库塔的每个阶段计算每个场的 $\\partial_x$ 需要一次正向 FFT 和一次逆向 FFT；因此，在每个龙格－库塔阶段，计算 $\\partial_x p$ 和 $\\partial_x u$ 共需要 $4$ 次 FFT 调用。每个时间步有 $4$ 个阶段，共有 $T/\\Delta t$ 个时间步，总次数可以量化为一个整数。\n- 对于有限差分法，报告在整个模拟过程中用于计算空间导数的模板乘加运算的总次数。使用中心 $5$ 点模板（四个非零权重）在每个网格点每次求导时需要 $4$ 次乘法和 $3$ 次加法，即每个网格点 $7$ 次乘加运算。使用中心 $7$ 点模板（六个非零权重）在每个网格点每次求导时需要 $6$ 次乘法和 $5$ 次加法，即每个网格点 $11$ 次乘加运算。在每个龙格－库塔阶段，都需要计算 $\\partial_x p$ 和 $\\partial_x u$，并且每个时间步有 $4$ 个阶段。\n\n您必须实现这两种方法并生成所要求的指标。所有空间变量必须以米为单位，时间以秒为单位，压力以帕斯卡为单位，速度以米/秒为单位。将最终精度指标报告为无量纲浮点数。将计算成本指标报告为整数。\n\n测试套件：\n- 用例 1 (标准情况)：$N=1024$，有限差分阶数 $6$（七点模板）。\n- 用例 2 (粗网格)：$N=256$，有限差分阶数 $4$（五点模板）。\n- 用例 3 (细网格)：$N=2048$，有限差分阶数 $6$（七点模板）。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表的列表形式的结果，每个内部列表按 $[\\varepsilon_{\\mathrm{spec}}, \\mathrm{FFT}_{\\mathrm{calls}}, \\varepsilon_{\\mathrm{FD}}, \\mathrm{MADD}_{\\mathrm{ops}}]$ 的顺序为相应测试用例排列。例如，输出必须如下所示\n$$\n\\left[\\left[\\varepsilon_1,\\mathrm{FFT}_1,\\varepsilon_2,\\mathrm{MADD}_2\\right],\\left[\\varepsilon_3,\\mathrm{FFT}_3,\\varepsilon_4,\\mathrm{MADD}_4\\right],\\left[\\varepsilon_5,\\mathrm{FFT}_5,\\varepsilon_6,\\mathrm{MADD}_6\\right]\\right],\n$$\n其中所有 $\\varepsilon$ 条目均为浮点数（无量纲），所有成本条目均为整数。",
            "solution": "经评估，用户提供的问题是有效的。它具有科学依据、适定性，并包含进行唯一且有意义的求解所需的所有必要信息。\n\n该问题要求比较两种用于求解一维一阶声学系统的数值方法，该系统源自线性化可压缩欧拉方程。关于压力扰动 $p(x,t)$ 和粒子速度 $u(x,t)$ 的系统由以下公式给出：\n$$\n\\frac{\\partial p}{\\partial t} + \\rho_0 c^2 \\frac{\\partial u}{\\partial x} = 0 \\\\\n\\frac{\\partial u}{\\partial t} + \\frac{1}{\\rho_0} \\frac{\\partial p}{\\partial x} = 0\n$$\n其中 $\\rho_0$ 是常数背景密度，$c$ 是常数声速。该系统可以写成向量形式 $\\frac{\\partial \\mathbf{Q}}{\\partial t} + \\mathbf{A} \\frac{\\partial \\mathbf{Q}}{\\partial x} = \\mathbf{0}$，其中 $\\mathbf{Q} = [p, u]^T$。因此，时间积分的右侧项为：\n$$\n\\frac{\\partial \\mathbf{Q}}{\\partial t} = \\mathbf{F}(\\mathbf{Q}) = -\\mathbf{A} \\frac{\\partial \\mathbf{Q}}{\\partial x} = \\begin{pmatrix} -\\rho_0 c^2 \\frac{\\partial u}{\\partial x} \\\\ -\\frac{1}{\\rho_0} \\frac{\\partial p}{\\partial x} \\end{pmatrix}\n$$\n\n问题定义在周期性空间域 $[0, L]$ 上。初始条件是压力的一个高斯调制余弦脉冲，速度设置为匹配向右传播的黎曼不变量，$u(x,0) = p(x,0)/(\\rho_0 c)$。这确保了初始脉冲纯粹向右传播。在时间 $T = L/c$ 时，对应于周期域上的一次完整传播，其精确解与初始条件相同：$p(x,T) = p(x,0)$。这提供了一个精确解，可用于与数值结果进行比较。\n\n时间积分使用显式四阶龙格－库塔 (RK4) 方法对两种空间离散化方案进行。对于半离散系统 $\\frac{d\\mathbf{Q}}{dt} = \\mathbf{F}(\\mathbf{Q})$，从 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的单个时间步计算如下：\n$$\n\\mathbf{k}_1 = \\mathbf{F}(\\mathbf{Q}_n) \\\\\n\\mathbf{k}_2 = \\mathbf{F}(\\mathbf{Q}_n + \\frac{\\Delta t}{2} \\mathbf{k}_1) \\\\\n\\mathbf{k}_3 = \\mathbf{F}(\\mathbf{Q}_n + \\frac{\\Delta t}{2} \\mathbf{k}_2) \\\\\n\\mathbf{k}_4 = \\mathbf{F}(\\mathbf{Q}_n + \\Delta t \\mathbf{k}_3) \\\\\n\\mathbf{Q}_{n+1} = \\mathbf{Q}_n + \\frac{\\Delta t}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\n函数 $\\mathbf{F}(\\mathbf{Q})$ 表示空间导数的计算，这在两种方法中是不同的。\n\n**1. 傅里叶伪谱法**\n\n该方法利用了物理空间中的微分等价于在傅里叶空间中乘以虚数单位 $i$ 和波数 $k$ 的性质。函数 $f(x)$ 在离散网格 $x_j=j\\Delta x$ 上的空间导数计算如下：\n1. 计算网格函数 $f_j$ 的离散傅里叶变换 (DFT)：$\\hat{f}_m = \\mathcal{F}[f_j]$。\n2. 乘以 $i k_m$，其中 $k_m$ 是离散波数。对于长度为 $L$、有 $N$ 个点的域，$k_m = 2\\pi m / L$，其中 $m$ 在适当的范围内。\n3. 计算逆离散傅里叶变换 (IDFT)：$(\\partial f / \\partial x)_j = \\mathcal{F}^{-1}[i k_m \\hat{f}_m]$。\n快速傅里叶变换 (FFT) 算法用于高效计算 DFT 和 IDFT。该方法具有谱精度，意味着对于光滑函数，误差随网格点数的增加而指数级减小。\n\n**2. 有限差分法**\n\n该方法使用邻近点函数值的加权和（一个模板）来近似网格点上的空间导数。问题指定了用于一阶导数的中心模板。\n- 四阶精度的 $5$ 点模板为：\n$$ \\left(\\frac{\\partial f}{\\partial x}\\right)_i \\approx \\frac{+f_{i-2} - 8f_{i-1} + 8f_{i+1} - f_{i+2}}{12 \\Delta x} $$\n- 六阶精度的 $7$ 点模板为：\n$$ \\left(\\frac{\\partial f}{\\partial x}\\right)_i \\approx \\frac{-f_{i-3} + 9f_{i-2} - 45f_{i-1} + 45f_{i+1} - 9f_{i+2} + f_{i+3}}{60 \\Delta x} $$\n由于是周期性边界条件，索引会在域上循环处理，例如 $f_{-1} = f_{N-1}$。\n\n**仿真参数和指标**\n\n对每个测试用例运行仿真，参数如下：$\\rho_0 = 1\\,\\mathrm{kg/m^3}$，$c = 340\\,\\mathrm{m/s}$，$A=1\\,\\mathrm{Pa}$。我们不失一般性地选择载波波长 $\\lambda=1.0\\,\\mathrm{m}$，这使得 $L=100\\,\\mathrm{m}$，$x_0=25\\,\\mathrm{m}$，以及 $\\sigma=3\\,\\mathrm{m}$。仿真运行至 $T=L/c$。时间步长为 $\\Delta t = \\mathrm{CFL}\\,\\Delta x / c$，其中 $\\mathrm{CFL}=0.5$ 且 $\\Delta x=L/N$。总时间步数为 $N_{\\text{steps}} = T/\\Delta t = 2N$。\n\n- **精度指标**：相对离散 $L^2$ 误差，$\\varepsilon = \\frac{\\left\\|p_{\\text{num}}(\\cdot,T) - p(\\cdot,0)\\right\\|_2}{\\left\\|p(\\cdot,0)\\right\\|_2}$，其中范数为 $\\|f\\|_2 = \\sqrt{\\Delta x \\sum_{i=0}^{N-1} f_i^2}$。\n\n- **成本指标**：\n    - 谱方法：FFT 调用总次数。每个 RK4 阶段需要计算 $p$ 和 $u$ 的导数，而每次求导需要一次正向和一次逆向 FFT。这导致每个阶段需要 4 次 FFT。总次数为 $4 \\text{ (FFT/阶段)} \\times 4 \\text{ (阶段/步)} \\times 2N \\text{ (步)} = 32N$。\n    - 有限差分法：乘加 (MADD) 运算总次数。$5$ 点模板需要 $4$ 次乘法和 $3$ 次加法（$7$ 次 MADD），而 $7$ 点模板需要 $6$ 次乘法和 $5$ 次加法（$11$ 次 MADD），每次计算一个网格点的导数。总次数为 $C_{\\text{MADD}} \\times N \\text{ (点)} \\times 2 \\text{ (场)} \\times 4 \\text{ (阶段/步)} \\times 2N \\text{ (步)} = 16 C_{\\text{MADD}} N^2$。\n\n实现过程通过遍历每个测试用例，运行两种仿真，并计算指定的指标。",
            "answer": "```python\nimport numpy as np\nfrom scipy.fft import fft, ifft, fftfreq\n\ndef solve():\n    \"\"\"\n    主函数，用于运行模拟并生成最终输出。\n    \"\"\"\n    \n    # --- 物理与仿真常数 ---\n    rho0 = 1.0  # kg/m^3\n    c = 340.0   # m/s\n    A = 1.0     # Pa\n    cfl = 0.5\n\n    # --- 初始条件脉冲参数 (相对于波长 lambda) ---\n    # 我们可以不失一般性地选择 lambda=1.0 米。\n    lmbda = 1.0\n    L_norm = 100.0   # 以波长为单位的域长度\n    x0_norm = 25.0   # 以波长为单位的脉冲中心\n    sigma_norm = 3.0 # 以波长为单位的脉冲宽度\n    \n    L = L_norm * lmbda\n    x0 = x0_norm * lmbda\n    sigma = sigma_norm * lmbda\n\n    test_cases = [\n        {'N': 1024, 'fd_order': 6},\n        {'N': 256, 'fd_order': 4},\n        {'N': 2048, 'fd_order': 6},\n    ]\n\n    results = []\n\n    # --- 空间导数函数 ---\n    def spectral_derivative(f, L_domain):\n        \"\"\"使用 FFT 计算导数。\"\"\"\n        N_pts = len(f)\n        k_wavenum = 2 * np.pi * fftfreq(N_pts, d=L_domain / N_pts)\n        f_hat = fft(f)\n        df_hat = 1j * k_wavenum * f_hat\n        return ifft(df_hat).real\n\n    def fd_derivative(f, dx, order):\n        \"\"\"使用有限差分模板计算导数。\"\"\"\n        if order == 4: # 5点模板\n            # 模板: (+1, -8, 0, +8, -1) / 12h\n            df = ( 1.0/12.0 * np.roll(f, 2)\n                  - 8.0/12.0 * np.roll(f, 1)\n                  + 8.0/12.0 * np.roll(f, -1)\n                  - 1.0/12.0 * np.roll(f, -2) )\n            return df / dx\n        elif order == 6: # 7点模板\n            # 模板: (-1, +9, -45, 0, +45, -9, +1) / 60h\n            df = ( -1.0/60.0 * np.roll(f, 3)\n                  + 9.0/60.0 * np.roll(f, 2)\n                  - 45.0/60.0 * np.roll(f, 1)\n                  + 45.0/60.0 * np.roll(f, -1)\n                  - 9.0/60.0 * np.roll(f, -2)\n                  + 1.0/60.0 * np.roll(f, -3) )\n            return df / dx\n        else:\n            raise ValueError(\"FD order must be 4 or 6.\")\n\n    # --- 用于 RK4 的右侧项(RHS)函数 ---\n    def rhs_spectral(Q, L_domain, rho_const, c_sound):\n        p, u = Q[0, :], Q[1, :]\n        dp_dx = spectral_derivative(p, L_domain)\n        du_dx = spectral_derivative(u, L_domain)\n        dp_dt = -rho_const * c_sound**2 * du_dx\n        du_dt = -1.0 / rho_const * dp_dx\n        return np.array([dp_dt, du_dt])\n\n    def rhs_fd(Q, dx, order, rho_const, c_sound):\n        p, u = Q[0, :], Q[1, :]\n        dp_dx = fd_derivative(p, dx, order)\n        du_dx = fd_derivative(u, dx, order)\n        dp_dt = -rho_const * c_sound**2 * du_dx\n        du_dt = -1.0 / rho_const * dp_dx\n        return np.array([dp_dt, du_dt])\n\n    # --- RK4 时间步进器 ---\n    def rk4_step(Q, dt, rhs_func, **kwargs):\n        k1 = rhs_func(Q, **kwargs)\n        k2 = rhs_func(Q + 0.5 * dt * k1, **kwargs)\n        k3 = rhs_func(Q + 0.5 * dt * k2, **kwargs)\n        k4 = rhs_func(Q + dt * k3, **kwargs)\n        return Q + (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    for case in test_cases:\n        N = case['N']\n        fd_order = case['fd_order']\n        \n        # --- 网格与时间步长设置 ---\n        dx = L / N\n        x = np.linspace(0, L, N, endpoint=False)\n        dt = cfl * dx / c\n        T_final = L / c\n        num_steps = int(round(T_final / dt))\n\n        # --- 初始条件 ---\n        p0 = A * np.cos(2 * np.pi * x / lmbda) * np.exp(-(x - x0)**2 / (2 * sigma**2))\n        u0 = p0 / (rho0 * c)\n        Q0 = np.array([p0, u0])\n\n        # --- 谱方法模拟 ---\n        Q_spec = Q0.copy()\n        for _ in range(num_steps):\n            Q_spec = rk4_step(Q_spec, dt, rhs_spectral, L_domain=L, rho_const=rho0, c_sound=c)\n\n        # --- 有限差分法模拟 ---\n        Q_fd = Q0.copy()\n        for _ in range(num_steps):\n            Q_fd = rk4_step(Q_fd, dt, rhs_fd, dx=dx, order=fd_order, rho_const=rho0, c_sound=c)\n\n        # --- 指标计算 ---\n        p_initial = Q0[0, :]\n        p_final_spec = Q_spec[0, :]\n        p_final_fd = Q_fd[0, :]\n\n        # 精度\n        norm_p0 = np.sqrt(dx * np.sum(p_initial**2))\n        err_spec = np.sqrt(dx * np.sum((p_final_spec - p_initial)**2)) / norm_p0\n        err_fd = np.sqrt(dx * np.sum((p_final_fd - p_initial)**2)) / norm_p0\n\n        # 成本\n        cost_spec = 32 * N\n        if fd_order == 4:\n            madd_per_point = 7\n        else: # fd_order == 6\n            madd_per_point = 11\n        cost_fd = 16 * madd_per_point * N**2\n\n        results.append([err_spec, cost_spec, err_fd, cost_fd])\n\n    # 将输出格式化为列表的列表的字符串表示形式。\n    # 这样可以避免任何 numpy 特定的格式。\n    output_str = \"[\"\n    for i, res in enumerate(results):\n        output_str += f\"[{res[0]},{res[1]},{res[2]},{res[3]}]\"\n        if i  len(results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    \n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "精确的模拟不仅依赖于核心求解算法，还同样依赖于对物理边界的准确建模。本练习将引导您解决一个高级但至关重要的课题：为声学阻抗边界实现一个时域模型 。通过将频域中的阻抗定义转换为时域中的微分方程并对其进行离散化，您将掌握在计算模拟中实现复杂、物理上准确的边界条件的关键技能。",
            "id": "4005980",
            "problem": "您的任务是为单极点声阻抗推导并实现一个时间上二阶精确的时间域阻抗边界条件 (TDIBC)。考虑燃烧室中一维线性声场内的一个平面边界，其中壁面法向脉动速度表示为 $u_n'(t)$，壁面处的脉动声压为 $p'(t)$。频域阻抗由复振幅之比定义为 $Z(\\omega)=\\hat{p}/\\hat{u}_n$，并被建模为单极点、质量-阻尼元件，\n$$\nZ(\\omega)=R+i\\,\\omega M,\n$$\n其中 $R$ 是阻尼，单位为 $\\mathrm{Pa\\,s/m}$，$M$ 是单位面积的声质量，单位为 $\\mathrm{kg/m^2}$。对于振幅为 $P_0$（单位 $\\mathrm{Pa}$）、角频率为 $\\omega$（单位 $\\mathrm{rad/s}$）的谐波激励 $p'(t)=P_0\\cos(\\omega t)$，此阻抗所隐含的时域边界关系是一个耦合 $p'(t)$ 和 $u_n'(t)$ 的常微分方程。\n\n任务：\n1. 从声阻抗的定义 $Z(\\omega)=\\hat{p}/\\hat{u}_n$ 和给定的单极点模型 $Z(\\omega)=R+i\\,\\omega M$ 出发，推导适用于一般 $p'(t)$ 和 $u_n'(t)$ 的时域关系。\n2. 基于此时域关系，使用梯形法则（也称为 Crank-Nicolson 方法）推导一个时间上二阶精确的离散更新方案，将壁面法向速度从时间 $t^n$ 推进到 $t^{n+1}=t^n+\\Delta t$。您的离散更新必须能用 $u_n'^{\\,n}$、$p'^{\\,n}$ 和 $p'^{\\,n+1}$ 表示 $u_n'^{\\,n+1}$，并且对任意 $R\\ge 0$ 和 $M\\ge 0$ 都有效。\n3. 实现一个程序，使用您推导的离散更新方案，在谐波激励 $p'(t)=P_0\\cos(\\omega t)$ 的几个周期内对 $u_n'^{\\,n}$ 进行时间推进。选择一个时间步长 $\\Delta t$ 以提供每个周期指定的点数。初始化 $u_n'^{\\,0}$ 时，应与稳态谐波解保持一致，以便当 $M=0$ 时，在 $t=0$ 处满足代数约束。\n4. 为进行验证，计算该阻抗模型所隐含的 $u_n'(t)$ 的精确稳态谐波解，即找到其振幅 $C_{\\mathrm{exact}}$ 和相位 $\\phi_{\\mathrm{exact}}$，使得 $u_n'(t)=C_{\\mathrm{exact}}\\cos(\\omega t-\\phi_{\\mathrm{exact}})$，并用它来计算离散时间点的参考 $u_n'(t)$。\n5. 对于每个测试用例，将 $u_n'^{\\,n}$ 推进指定的周期数，然后计算最后一个完整周期内的相对 $\\ell^2$ 误差，\n$$\n\\varepsilon=\\frac{\\left\\|u_n'^{\\,\\mathrm{num}}-u_n'^{\\,\\mathrm{exact}}\\right\\|_2}{\\left\\|u_n'^{\\,\\mathrm{exact}}\\right\\|_2},\n$$\n该误差是无量纲的。\n\n科学和数值假设：\n- 在小振幅、线性声学范围内工作，并假设平均流为静态。\n- 所有量均采用一致的国际单位制 (SI)：$R$ 的单位为 $\\mathrm{Pa\\,s/m}$，$M$ 的单位为 $\\mathrm{kg/m^2}$，$P_0$ 的单位为 $\\mathrm{Pa}$，$\\omega$ 的单位为 $\\mathrm{rad/s}$，时间 $t$ 的单位为 $\\mathrm{s}$。\n- 角度必须以弧度处理。\n\n测试套件：\n使用以下测试用例，每个用例以元组 $(R,M,f,P_0,N_{\\mathrm{pp}},N_{\\mathrm{per}})$ 的形式给出，其中 $f$ 是频率（单位 $\\mathrm{Hz}$），$P_0$ 是压力振幅（单位 $\\mathrm{Pa}$），$N_{\\mathrm{pp}}$ 是每周期点数，$N_{\\mathrm{per}}$ 是模拟的周期数。角频率为 $\\omega=2\\pi f$，时间步长为 $\\Delta t=\\frac{1}{f\\,N_{\\mathrm{pp}}}$。\n\n- 用例 1（一般质量-阻尼，正常路径）：$(150.0,\\,0.20,\\,300.0,\\,500.0,\\,200,\\,8)$\n- 用例 2（纯声抗质量，边界情况）：$(0.0,\\,0.05,\\,300.0,\\,500.0,\\,200,\\,8)$\n- 用例 3（纯阻尼，边界情况）：$(200.0,\\,0.0,\\,300.0,\\,500.0,\\,200,\\,8)$\n- 用例 4（更高频率，中等质量）：$(80.0,\\,0.02,\\,1500.0,\\,500.0,\\,150,\\,10)$\n- 用例 5（更粗的时间步长，压力测试）：$(100.0,\\,0.05,\\,400.0,\\,500.0,\\,30,\\,10)$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含五个测试用例的相对 $\\ell^2$ 误差，形式为方括号内的逗号分隔列表，每个浮点数采用科学记数法，并四舍五入到六位有效数字，例如，$$[1.234567\\mathrm{e}{-03},2.345678\\mathrm{e}{-04},\\dots].$$",
            "solution": "用户提供了一个问题，要求为单极点声阻抗模型推导并实现一个时间上二阶精确的时间域阻抗边界条件 (TDIBC)。该问题定义明确，科学上合理，并包含了完整解决方案所需的所有信息。\n\n### 1. 时域关系的推导\n声阻抗 $Z(\\omega)$ 关联了频域中声压的复振幅 $\\hat{p}$ 和壁面法向速度的复振幅 $\\hat{u}_n$：\n$$\nZ(\\omega) = \\frac{\\hat{p}(\\omega)}{\\hat{u}_n(\\omega)}\n$$\n问题指定了一个单极点、质量-阻尼阻抗模型：\n$$\nZ(\\omega) = R + i\\,\\omega M\n$$\n其中 $R$ 是声阻，$M$ 是单位面积的声质量，$\\omega$ 是角频率，$i = \\sqrt{-1}$。结合这两个方程得到：\n$$\n\\hat{p}(\\omega) = (R + i\\,\\omega M) \\hat{u}_n(\\omega) = R\\,\\hat{u}_n(\\omega) + i\\,\\omega M\\,\\hat{u}_n(\\omega)\n$$\n为了将此关系转换到时域，我们应用傅里叶逆变换。乘积 $i\\omega\\hat{f}(\\omega)$ 的傅里叶逆变换对应于时间导数 $\\frac{d f(t)}{dt}$。将此规则逐项应用于方程，我们得到时域脉动压力 $p'(t)$ 和脉动速度 $u_n'(t)$ 之间的关系：\n$$\np'(t) = R\\,u_n'(t) + M\\,\\frac{d u_n'(t)}{dt}\n$$\n这是一个一阶线性常微分方程 (ODE)，它控制了边界上压力和速度在时域中的关系。至此完成第一个任务。\n\n### 2. 使用梯形法则 (Crank-Nicolson 方法) 进行离散化\n第二个任务是为 $u_n'(t)$ 推导一个时间上二阶精确的离散更新。我们将该常微分方程重新排列为：\n$$\nM\\,\\frac{d u_n'}{dt} + R\\,u_n' = p'(t)\n$$\n我们对此常微分方程应用梯形法则（也称为 Crank-Nicolson 方法）。该方法在时间上是二阶精确的。它涉及用跨越区间 $[t^n, t^{n+1}]$ 的中心差分来近似时间导数，并将其他项作为它们在 $t^n$ 和 $t^{n+1}$ 处值的平均值进行评估：\n$$\nM \\left( \\frac{u_n'^{\\,n+1} - u_n'^{\\,n}}{\\Delta t} \\right) + R \\left( \\frac{u_n'^{\\,n+1} + u_n'^{\\,n}}{2} \\right) = \\frac{p'^{\\,n+1} + p'^{\\,n}}{2}\n$$\n其中 $\\Delta t = t^{n+1} - t^n$ 是时间步长，上标表示时间层级。为了找到 $u_n'^{\\,n+1}$ 的更新规则，我们重排方程以求解此项。首先，我们乘以 $\\Delta t$：\n$$\nM (u_n'^{\\,n+1} - u_n'^{\\,n}) + \\frac{R\\Delta t}{2} (u_n'^{\\,n+1} + u_n'^{\\,n}) = \\frac{\\Delta t}{2} (p'^{\\,n+1} + p'^{\\,n})\n$$\n接下来，我们将所有含 $u_n'^{\\,n+1}$ 的项收集到左侧，所有其他项移到右侧：\n$$\nM u_n'^{\\,n+1} + \\frac{R\\Delta t}{2} u_n'^{\\,n+1} = M u_n'^{\\,n} - \\frac{R\\Delta t}{2} u_n'^{\\,n} + \\frac{\\Delta t}{2} (p'^{\\,n+1} + p'^{\\,n})\n$$\n对 $u_n'^{\\,n+1}$ 和 $u_n'^{\\,n}$ 进行因式分解：\n$$\nu_n'^{\\,n+1} \\left( M + \\frac{R\\Delta t}{2} \\right) = u_n'^{\\,n} \\left( M - \\frac{R\\Delta t}{2} \\right) + \\frac{\\Delta t}{2} (p'^{\\,n+1} + p'^{\\,n})\n$$\n最后，分离出 $u_n'^{\\,n+1}$ 得到显式更新公式：\n$$\nu_n'^{\\,n+1} = \\frac{\\left( M - \\frac{R\\Delta t}{2} \\right) u_n'^{\\,n} + \\frac{\\Delta t}{2} (p'^{\\,n+1} + p'^{\\,n})}{M + \\frac{R\\Delta t}{2}}\n$$\n此公式对任意 $R \\ge 0$ 和 $M \\ge 0$ 均有效，只要 $R$ 和 $M$ 不同时为零。对于纯阻尼情况 ($M=0$)，公式正确简化；对于纯声抗情况 ($R=0$)，它也给出了正确的梯形更新。\n\n### 3. 精确谐波解和初始条件\n为了进行验证，我们需要在压力激励为谐波 $p'(t) = P_0 \\cos(\\omega t)$ 时的精确稳态解 $u_n'(t)$。在频域中，复压力振幅为 $\\hat{p} = P_0$。则复速度振幅为：\n$$\n\\hat{u}_n = \\frac{\\hat{p}}{Z(\\omega)} = \\frac{P_0}{R + i\\omega M}\n$$\n为了找到相应的时域信号，我们将 $\\hat{u}_n$ 表示为极坐标形式 $|\\hat{u}_n| e^{-i\\phi_{\\mathrm{exact}}}$。时域速度是 $\\hat{u}_n e^{i\\omega t}$ 的实部：\n$$\nu_n'(t) = \\mathrm{Re}\\left\\{ |\\hat{u}_n| e^{i(\\omega t - \\phi_{\\mathrm{exact}})} \\right\\} = |\\hat{u}_n| \\cos(\\omega t - \\phi_{\\mathrm{exact}})\n$$\n这符合 $C_{\\mathrm{exact}}\\cos(\\omega t-\\phi_{\\mathrm{exact}})$ 的形式，其振幅 $C_{\\mathrm{exact}}$ 和相位滞后 $\\phi_{\\mathrm{exact}}$ 由下式给出：\n$$\nC_{\\mathrm{exact}} = |\\hat{u}_n| = \\frac{|P_0|}{|R + i\\omega M|} = \\frac{P_0}{\\sqrt{R^2 + (\\omega M)^2}}\n$$\n$$\n\\phi_{\\mathrm{exact}} = \\arg(R + i\\omega M) = \\arctan_2(\\omega M, R)\n$$\n问题要求初始化模拟，使 $u_n'(0)$ 与稳态谐波解一致。在 $t=0$ 时，精确解为：\n$$\nu_n'(0) = C_{\\mathrm{exact}} \\cos(-\\phi_{\\mathrm{exact}}) = C_{\\mathrm{exact}} \\cos(\\phi_{\\mathrm{exact}}) = \\frac{P_0}{\\sqrt{R^2 + (\\omega M)^2}} \\cdot \\frac{R}{\\sqrt{R^2 + (\\omega M)^2}} = \\frac{P_0 R}{R^2 + (\\omega M)^2}\n$$\n该值将用作初始条件 $u_n'^{\\,0}$。\n\n### 4. 误差计算\n数值解 $u_n'^{\\,\\mathrm{num}}$ 从 $t=0$ 开始进行时间推进，持续指定的周期数。误差是在模拟的最后一个完整周期内计算的，以确保任何初始瞬态效应已经衰减，并且数值解已达到周期性稳态。相对 $\\ell^2$ 误差 $\\varepsilon$ 计算如下：\n$$\n\\varepsilon=\\frac{\\left\\|u_n'^{\\,\\mathrm{num}}-u_n'^{\\,\\mathrm{exact}}\\right\\|_2}{\\left\\|u_n'^{\\,\\mathrm{exact}}\\right\\|_2}\n$$\n其中向量包含了跨越最后一个周期的离散时间点的数值解和精确解。具有 $N$ 个元素的向量 $v$ 的 $\\ell^2$ 范数为 $\\|v\\|_2 = \\sqrt{\\sum_{i=1}^N v_i^2}$。\n\n实现将通过为每个测试用例计算这些量并报告最终的误差 $\\varepsilon$ 来进行。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_tdibc_error(R, M, f, P0, N_pp, N_per):\n    \"\"\"\n    Calculates the relative l2 error for the TDIBC problem.\n\n    Args:\n        R (float): Acoustic resistance (Pa*s/m).\n        M (float): Acoustic mass per unit area (kg/m^2).\n        f (float): Frequency (Hz).\n        P0 (float): Pressure amplitude (Pa).\n        N_pp (int): Number of points per period.\n        N_per (int): Number of periods to simulate.\n\n    Returns:\n        float: The relative l2 error.\n    \"\"\"\n    # 1. Define simulation parameters\n    omega = 2.0 * np.pi * f\n    dt = 1.0 / (f * N_pp)\n    num_steps = N_pp * N_per\n    \n    # Create time vector and pressure forcing function\n    t = np.linspace(0.0, num_steps * dt, num_steps + 1)\n    p_prime = P0 * np.cos(omega * t)\n\n    # 2. Derive the exact analytical solution\n    # The absolute value of the impedance Z(omega) = R + i*omega*M\n    Z_abs = np.sqrt(R**2 + (omega * M)**2)\n    # Amplitude of the velocity u_n'(t)\n    C_exact = P0 / Z_abs if Z_abs > 1e-15 else 0.0\n    # Phase lag of u_n'(t) with respect to p'(t)\n    phi_exact = np.arctan2(omega * M, R)\n    # The exact velocity solution u_n'(t)\n    u_n_exact = C_exact * np.cos(omega * t - phi_exact)\n\n    # 3. Perform the numerical time marching\n    u_n_num = np.zeros(num_steps + 1)\n    \n    # Set the initial condition consistent with the steady harmonic solution\n    # u_n'(0) = C_exact * cos(phi_exact) = P0*R / (R^2 + (omega*M)^2)\n    denominator_ic = R**2 + (omega * M)**2\n    if denominator_ic > 1e-15:\n        u_n_num[0] = (P0 * R) / denominator_ic\n    else:\n        # This case (R=0, M=0) is not in the test suite. Z=0 means p'=0.\n        # If P0 is non-zero, the problem is ill-defined.\n        u_n_num[0] = 0.0\n\n    # Define coefficients for the Crank-Nicolson update scheme\n    # u_n'^{n+1} = coeff1 * u_n'^{n} + coeff2 * (p'^{n} + p'^{n+1})\n    den_update = M + R * dt / 2.0\n    \n    # This denominator is only zero if R=0 and M=0, not in test cases.\n    if abs(den_update)  1e-15:\n        return np.nan # Avoid division by zero\n\n    coeff1 = (M - R * dt / 2.0) / den_update\n    coeff2 = (dt / 2.0) / den_update\n    \n    # Time-marching loop\n    for n in range(num_steps):\n        u_n_num[n+1] = coeff1 * u_n_num[n] + coeff2 * (p_prime[n] + p_prime[n+1])\n\n    # 4. Compute the relative l2 error over the last period\n    start_index = num_steps - N_pp\n    \n    # Extract the solutions over the last full period (N_pp+1 points)\n    u_n_num_last_period = u_n_num[start_index:]\n    u_n_exact_last_period = u_n_exact[start_index:]\n    \n    # Calculate the L2 norms\n    norm_error = np.linalg.norm(u_n_num_last_period - u_n_exact_last_period)\n    norm_exact = np.linalg.norm(u_n_exact_last_period)\n    \n    if norm_exact  1e-15:\n        # This occurs if the exact solution is zero (e.g., P0=0).\n        # If the numerical solution is also zero, the error is 0.\n        return 0.0 if norm_error  1e-15 else np.inf\n\n    relative_error = norm_error / norm_exact\n    return relative_error\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple is (R, M, f, P0, N_pp, N_per)\n    test_cases = [\n        (150.0, 0.20, 300.0, 500.0, 200, 8),   # Case 1: General\n        (0.0, 0.05, 300.0, 500.0, 200, 8),    # Case 2: Purely reactive\n        (200.0, 0.0, 300.0, 500.0, 200, 8),    # Case 3: Purely resistive\n        (80.0, 0.02, 1500.0, 500.0, 150, 10),  # Case 4: High frequency\n        (100.0, 0.05, 400.0, 500.0, 30, 10),   # Case 5: Coarse time step\n    ]\n\n    results = []\n    for case in test_cases:\n        R, M, f, P0, N_pp, N_per = case\n        error = calculate_tdibc_error(R, M, f, P0, N_pp, N_per)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    # Scientific notation with 6 significant digits (1 digit before '.', 5 after).\n    formatted_results = [f\"{res:.5e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}