{
    "hands_on_practices": [
        {
            "introduction": "第一个实践是基础性的。它深入探讨了作为弧长延拓方法引擎的“预测-校正”法的核心机制。通过为一个连续搅拌釜反应器（CSTR）模型实现单个延拓步，你将获得计算解流形切线以及使用牛顿法将预测点校正回曲线的实践经验。这个练习对于理解算法如何导航解分支至关重要，尤其是在传统方法会失效的转折点附近 ()。",
            "id": "4007867",
            "problem": "一个维持单一不可逆放热反应的连续搅拌釜反应器（CSTR）在稳态下通过两个由物种守恒和能量守恒推导出的无量纲代数平衡方程进行建模。反应速率由 Frank-Kamenetskii 形式近似，这是燃烧学中热驱动反应的 Arrhenius 动力学的一种广泛使用的简化形式，其中无量纲速率随无量纲温度呈指数增长。设未知数为无量纲温度 $T$ 和无量纲反应物浓度 $c$，控制参数为 Damköhler 数 $\\text{Da}$，该数用于缩放停留时间和本征动力学。反应速率为 $r(T,c) = c \\exp(\\gamma T)$，其中 $\\gamma  0$ 是无量纲活化参数。稳态方程为\n$$\nF_1(T,c,\\text{Da}) = (1 - c) - \\text{Da} \\, c \\exp(\\gamma T) = 0,\n$$\n$$\nF_2(T,c,\\text{Da}) = (1 + h)(1 - T) + \\beta \\, \\text{Da} \\, c \\exp(\\gamma T) = 0,\n$$\n其中 $\\beta  0$ 是无量纲放热参数， $h  0$ 是无量纲热移除系数；进料和冷却剂温度以及入口浓度已被缩放为 1。\n\n弧长延拓法增广这些非线性方程，以追踪跨越参数 $\\text{Da}$ 中转折点的稳态解分支。定义变量向量 $\\mathbf{u} = (T,c,\\text{Da})$ 和残差向量 $\\mathbf{F}(\\mathbf{u}) = (F_1, F_2)$。在满足 $\\mathbf{F}(\\mathbf{u}_0) = \\mathbf{0}$ 的一个操作点 $\\mathbf{u}_0 = (T_0, c_0, \\text{Da}_0)$，解流形的切线方向 $\\boldsymbol{\\tau} = (\\tau_T, \\tau_c, \\tau_{\\text{Da}})$ 通过对 $\\mathbf{F}(\\mathbf{u}) = \\mathbf{0}$ 关于弧长参数 $s$ 求导并施加归一化来确定。对于给定的弧长步长 $\\Delta s$，一个预测步前进到 $\\mathbf{u}_{\\text{pred}} = \\mathbf{u}_0 + \\Delta s \\, \\boldsymbol{\\tau}$。然后，一个校正步求解由两个反应器残差和一个伪弧长约束组成的增广系统，以返回到 $\\mathbf{u}_{\\text{pred}}$ 附近的流形上。\n\n您的任务是，从上述基本定义出发，不依赖任何预先提供的公式，实现以下内容：\n1. 对于每个指定的操作点，通过求解 $F_1(T,c,\\text{Da}_0) = 0$ 和 $F_2(T,c,\\text{Da}_0) = 0$ 来计算在给定 $\\text{Da}_0$ 下的稳态解 $(T_0,c_0)$。\n2. 在 $\\mathbf{u}_0$ 处，计算与单位欧几里得范数一致的切线方向 $\\boldsymbol{\\tau}$，使用给定的 $\\Delta s$ 执行预测步，并计算反应器残差的 2-范数 $\\|\\mathbf{F}(\\mathbf{u}_{\\text{pred}})\\|_2$。\n3. 使用牛顿法对由两个反应器方程和一个伪弧长约束组成的增广系统执行校正步。报告校正后的 $(T,\\text{Da})$、反应器残差的 2-范数 $\\|\\mathbf{F}(\\mathbf{u}_{\\text{corr}})\\|_2$ 和增广残差的 2-范数 $\\|\\mathbf{G}(\\mathbf{u}_{\\text{corr}})\\|_2$，其中 $\\mathbf{G}$ 堆叠了反应器残差和弧长约束。\n4. 所有计算使用参数值 $\\gamma = 3$, $\\beta = 2$, $h = 3$。变量 $T$、$c$ 和 $\\text{Da}$ 都是无量纲的，因此不需要进行物理单位转换。\n\n测试套件：\n- 情况 A（一般情况）：$\\text{Da}_0 = 0.05$，初始猜测值 $(T,c) = (1.0, 0.9)$，且 $\\Delta s = 0.02$。\n- 情况 B（接近转折点检测）：在区间 $[0.01, 0.5]$ 上用 $N = 200$ 个网格点均匀扫描 $\\text{Da}$。在每个网格点，从前一个解作为初始猜测值开始求解 $(T,c)$，并选择雅可比矩阵 $\\partial \\mathbf{F}/\\partial (T,c)$ 的最小奇异值所对应的操作点，然后设置 $\\Delta s = 0.01$。在第一个网格点使用 $(T,c) = (1.0, 0.8)$ 作为起始猜测值。\n- 情况 C（小步长边界情况）：$\\text{Da}_0 = 0.20$，初始猜测值 $(T,c) = (1.1, 0.5)$，且 $\\Delta s = 10^{-4}$。\n\n对于每种情况，程序必须返回一个包含七个浮点数的列表：\n- $T_{\\text{pred}}$, $\\text{Da}_{\\text{pred}}$, $\\|\\mathbf{F}(\\mathbf{u}_{\\text{pred}})\\|_2$, $T_{\\text{corr}}$, $\\text{Da}_{\\text{corr}}$, $\\|\\mathbf{F}(\\mathbf{u}_{\\text{corr}})\\|_2$, $\\|\\mathbf{G}(\\mathbf{u}_{\\text{corr}})\\|_2$。\n将每个数字四舍五入到小数点后六位。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个条目是对应测试用例的七个数字列表，顺序与测试套件中的顺序相同，例如，\n$[$$[T_{\\text{pred}}^{(A)},\\text{Da}_{\\text{pred}}^{(A)},\\dots]$$,$$[T_{\\text{pred}}^{(B)},\\text{Da}_{\\text{pred}}^{(B)},\\dots]$$,$$[T_{\\text{pred}}^{(C)},\\text{Da}_{\\text{pred}}^{(C)},\\dots]$$$]$。",
            "solution": "连续搅拌釜反应器（CSTR）模型是基于稳态物种和能量平衡建立的。在入口值被缩放以使进料浓度和进料温度为 1，并且无量纲热移除和放热参数为 $h$ 和 $\\beta$ 的情况下，平衡方程如下：\n$$\nF_1(T,c,\\text{Da}) = (1 - c) - \\text{Da} \\, c \\exp(\\gamma T) = 0,\n\\quad\nF_2(T,c,\\text{Da}) = (1 + h)(1 - T) + \\beta \\,\\text{Da}\\, c \\exp(\\gamma T) = 0.\n$$\n这些方程是通过将流入减去流出加上反应消耗（对物种而言）以及冷却减去加热加上反应放热（对能量而言）设为零，并经过无量纲化处理后得到的。Frank-Kamenetskii 近似 $r(T,c) = c \\exp(\\gamma T)$ 是 Arrhenius 速率 $r \\propto c \\exp(-E/(R T_{\\text{phys}}))$ 在用合适的无量纲温差表示时的一个经过充分检验的简化；此处 $\\gamma$ 是一个有效活化参数。\n\n为了执行弧长延拓，我们考虑解流形 $\\{(T,c,\\text{Da}) : \\mathbf{F}(T,c,\\text{Da}) = \\mathbf{0}\\}$ 并引入一个弧长参数 $s$，使得 $(T,c,\\text{Da}) = \\mathbf{u}(s)$ 追踪该曲线。对 $\\mathbf{F}(\\mathbf{u}(s)) = \\mathbf{0}$ 关于 $s$ 求导，得到线性关系\n$$\n\\frac{\\partial \\mathbf{F}}{\\partial (T,c)} \\begin{bmatrix}\\dfrac{dT}{ds} \\\\ \\dfrac{dc}{ds} \\end{bmatrix} + \\frac{\\partial \\mathbf{F}}{\\partial \\text{Da}} \\, \\frac{d\\,\\text{Da}}{ds} = \\mathbf{0}.\n$$\n在一个解点 $\\mathbf{u}_0 = (T_0,c_0,\\text{Da}_0)$，令 $J = \\partial \\mathbf{F}/\\partial (T,c)$ 为 $2\\times 2$ 的雅可比矩阵，令 $F_{\\text{Da}} = \\partial \\mathbf{F}/\\partial \\text{Da}$ 为 $2\\times 1$ 的参数导数，两者都在 $\\mathbf{u}_0$ 处取值。一种实用的镶边策略设置 $\\dfrac{d\\,\\text{Da}}{ds} = \\tau_{\\text{Da}} = 1$，得到线性系统\n$$\nJ \\begin{bmatrix}\\tau_T \\\\ \\tau_c \\end{bmatrix} = - F_{\\text{Da}},\n$$\n该系统可以求解出切向量的 $(T,c)$ 分量。然后将完整的切向量 $\\boldsymbol{\\tau} = (\\tau_T,\\tau_c,\\tau_{\\text{Da}})$ 归一化为单位欧几里得长度：\n$$\n\\boldsymbol{\\tau} \\leftarrow \\frac{\\boldsymbol{\\tau}}{\\|\\boldsymbol{\\tau}\\|_2}.\n$$\n一个预测步前进到\n$$\n\\mathbf{u}_{\\text{pred}} = \\mathbf{u}_0 + \\Delta s \\, \\boldsymbol{\\tau}.\n$$\n预测步通常会离开流形，因此我们通过求解一个包含三个未知数 $(T,c,\\text{Da})$ 的三个方程的增广系统来校正回来：\n$$\n\\mathbf{G}(\\mathbf{u}) = \n\\begin{bmatrix}\nF_1(T,c,\\text{Da}) \\\\[4pt]\nF_2(T,c,\\text{Da}) \\\\[4pt]\ng(T,c,\\text{Da})\n\\end{bmatrix}\n= \\mathbf{0},\n\\quad\ng(T,c,\\text{Da}) = \\boldsymbol{\\tau}^\\top \\big( \\mathbf{u} - \\mathbf{u}_0 \\big) - \\Delta s,\n$$\n这施加了伪弧长约束，使得校正后的解位于与预测点和基点之差正交的超平面上，同时沿着切线方向距离 $\\mathbf{u}_0$ 的弧长为 $\\Delta s$。牛顿法通过以下方式更新 $\\mathbf{u}$\n$$\n\\mathbf{u}^{(k+1)} = \\mathbf{u}^{(k)} - \\left[ \\frac{\\partial \\mathbf{G}}{\\partial \\mathbf{u}}(\\mathbf{u}^{(k)}) \\right]^{-1} \\mathbf{G}(\\mathbf{u}^{(k)}),\n$$\n其中 $\\mathbf{G}$ 的 $3\\times 3$ 雅可比矩阵为\n$$\n\\frac{\\partial \\mathbf{G}}{\\partial \\mathbf{u}} =\n\\begin{bmatrix}\n\\frac{\\partial F_1}{\\partial T}  \\frac{\\partial F_1}{\\partial c}  \\frac{\\partial F_1}{\\partial \\text{Da}} \\\\[4pt]\n\\frac{\\partial F_2}{\\partial T}  \\frac{\\partial F_2}{\\partial c}  \\frac{\\partial F_2}{\\partial \\text{Da}} \\\\[4pt]\n\\tau_T  \\tau_c  \\tau_{\\text{Da}}\n\\end{bmatrix}.\n$$\n我们模型的导数可从 $F_1$ 和 $F_2$ 的定义中获得：\n$$\n\\frac{\\partial F_1}{\\partial T} = - \\text{Da} \\, c \\, \\gamma \\exp(\\gamma T),\n\\quad\n\\frac{\\partial F_1}{\\partial c} = -1 - \\text{Da} \\exp(\\gamma T),\n\\quad\n\\frac{\\partial F_1}{\\partial \\text{Da}} = - c \\exp(\\gamma T),\n$$\n$$\n\\frac{\\partial F_2}{\\partial T} = - (1 + h) + \\beta \\, \\text{Da} \\, c \\, \\gamma \\exp(\\gamma T),\n\\quad\n\\frac{\\partial F_2}{\\partial c} = \\beta \\, \\text{Da} \\exp(\\gamma T),\n\\quad\n\\frac{\\partial F_2}{\\partial \\text{Da}} = \\beta \\, c \\exp(\\gamma T).\n$$\n我们采用带简单回溯线搜索的牛顿法，以确保在可能的情况下每次迭代中 $\\|\\mathbf{G}\\|_2$ 范数都会减小。当 $\\|\\mathbf{G}\\|_2$ 低于某个容差时，校正终止，表明在弧长约束下已收敛到流形。\n\n对于每个测试用例：\n1. 求解稳态方程以获得 $\\mathbf{u}_0$。在情况 B 中，通过扫描 $\\text{Da}$ 并选择 $J$ 的最小奇异值对应的点，可以找到一个接近转折点的点，此时 $J$ 近乎奇异，这强调了弧长延拓的优势。\n2. 通过求解 $\\tau_{\\text{Da}} = 1$ 的镶边线性系统来计算切向量 $\\boldsymbol{\\tau}$ 并将其归一化。\n3. 预测 $\\mathbf{u}_{\\text{pred}}$，并计算 $\\|\\mathbf{F}(\\mathbf{u}_{\\text{pred}})\\|_2$。\n4. 通过在 $\\mathbf{G}$ 上使用牛顿法校正到 $\\mathbf{u}_{\\text{corr}}$，并计算 $\\|\\mathbf{F}(\\mathbf{u}_{\\text{corr}})\\|_2$ 和 $\\|\\mathbf{G}(\\mathbf{u}_{\\text{corr}})\\|_2$。\n\n最后，我们为每种情况报告包含七个数字的列表 $[T_{\\text{pred}}, \\text{Da}_{\\text{pred}}, \\|\\mathbf{F}(\\mathbf{u}_{\\text{pred}})\\|_2, T_{\\text{corr}}, \\text{Da}_{\\text{corr}}, \\|\\mathbf{F}(\\mathbf{u}_{\\text{corr}})\\|_2, \\|\\mathbf{G}(\\mathbf{u}_{\\text{corr}})\\|_2]$，四舍五入到小数点后六位，以单行形式输出，其中包含按 A、B、C 顺序排列的三个这样的列表。这个过程实践了计算燃烧学中针对转折点曲线的弧长延拓的核心原理，展示了即使在常规参数延拓法在奇异雅可比矩阵附近失效时，也能对热敏反应器的稳态解进行稳健追踪。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root\n\n# Model parameters (dimensionless)\ngamma = 3.0  # activation parameter in Frank-Kamenetskii approximation\nbeta = 2.0   # heat-release parameter\nh = 3.0      # heat-removal coefficient\n\ndef reaction_rate(T, c):\n    return c * np.exp(gamma * T)\n\ndef F_vec(T, c, Da):\n    r = reaction_rate(T, c)\n    F1 = (1.0 - c) - Da * r\n    F2 = (1.0 + h) * (1.0 - T) + beta * Da * r\n    return np.array([F1, F2])\n\ndef J_mat(T, c, Da):\n    r = reaction_rate(T, c)\n    dF1_dT = -Da * gamma * r\n    dF1_dc = -1.0 - Da * np.exp(gamma * T)\n    dF2_dT = -(1.0 + h) + beta * Da * gamma * r\n    dF2_dc = beta * Da * np.exp(gamma * T)\n    return np.array([[dF1_dT, dF1_dc],\n                     [dF2_dT, dF2_dc]])\n\ndef F_lambda(T, c, Da):\n    r = reaction_rate(T, c)\n    dF1_dDa = -r\n    dF2_dDa = beta * r\n    return np.array([dF1_dDa, dF2_dDa])\n\ndef solve_steady(Da, T_guess, c_guess):\n    # First attempt with provided guess\n    def fun(z):\n        return F_vec(z[0], z[1], Da)\n    z0 = np.array([T_guess, c_guess])\n    sol = root(fun, z0, method='hybr')\n    if sol.success and np.linalg.norm(sol.fun)  1e-8:\n        return sol.x[0], sol.x[1], True\n    # Second attempt: heuristic guess based on species balance ignoring energy coupling\n    T_guess2 = 1.0\n    c_guess2 = 1.0 / (1.0 + Da * np.exp(gamma * T_guess2))\n    z0b = np.array([T_guess2, c_guess2])\n    sol2 = root(fun, z0b, method='hybr')\n    if sol2.success and np.linalg.norm(sol2.fun)  1e-8:\n        return sol2.x[0], sol2.x[1], True\n    return sol2.x[0], sol2.x[1], False\n\ndef compute_tangent(T0, c0, Da0):\n    J = J_mat(T0, c0, Da0)\n    Fl = F_lambda(T0, c0, Da0)\n    # Set t_lambda = 1 and solve for (t_T, t_c): J * t_x = -F_lambda\n    try:\n        t_x = np.linalg.solve(J, -Fl)\n    except np.linalg.LinAlgError:\n        # Use least squares if singular\n        t_x, *_ = np.linalg.lstsq(J, -Fl, rcond=None)\n    tau_T, tau_c = t_x[0], t_x[1]\n    tau_Da = 1.0\n    tau = np.array([tau_T, tau_c, tau_Da])\n    # Normalize to unit Euclidean norm\n    norm_tau = np.linalg.norm(tau)\n    if norm_tau == 0.0:\n        # Fallback: choose parameter-only direction\n        tau = np.array([0.0, 0.0, 1.0])\n        norm_tau = 1.0\n    tau /= norm_tau\n    return tau\n\ndef predictor(u0, tau, ds):\n    u_pred = u0 + ds * tau\n    T_pred, c_pred, Da_pred = u_pred\n    F_norm = np.linalg.norm(F_vec(T_pred, c_pred, Da_pred))\n    return u_pred, F_norm\n\ndef corrector(u0, u_pred, tau, tol=1e-10, max_iter=25):\n    # Newton corrector for augmented system G = [F; g] = 0 with g = tau^T (u - u0) - ds\n    ds = np.dot(tau, u_pred - u0)  # nominal arc-length step used in constraint\n    u = u_pred.copy()\n    for k in range(max_iter):\n        T, c, Da = u\n        F = F_vec(T, c, Da)\n        g = np.dot(tau, u - u0) - ds\n        G = np.array([F[0], F[1], g])\n        G_norm = np.linalg.norm(G)\n        if G_norm  tol:\n            break\n        # Build Jacobian of G\n        J = J_mat(T, c, Da)\n        Fl = F_lambda(T, c, Da)\n        A = np.zeros((3, 3))\n        A[0, 0:2] = J[0, :]\n        A[1, 0:2] = J[1, :]\n        A[0, 2] = Fl[0]\n        A[1, 2] = Fl[1]\n        A[2, :] = tau\n        # Solve for Newton step\n        try:\n            step = np.linalg.solve(A, G)\n        except np.linalg.LinAlgError:\n            step, *_ = np.linalg.lstsq(A, G, rcond=None)\n        # Backtracking line search to reduce ||G||\n        alpha = 1.0\n        u_new = u - alpha * step\n        G_new = np.array([F_vec(u_new[0], u_new[1], u_new[2])[0],\n                          F_vec(u_new[0], u_new[1], u_new[2])[1],\n                          np.dot(tau, u_new - u0) - ds])\n        while np.linalg.norm(G_new) = G_norm and alpha  1e-6:\n            alpha *= 0.5\n            u_new = u - alpha * step\n            G_new = np.array([F_vec(u_new[0], u_new[1], u_new[2])[0],\n                              F_vec(u_new[0], u_new[1], u_new[2])[1],\n                              np.dot(tau, u_new - u0) - ds])\n        u = u_new\n    # Final norms\n    F_corr = F_vec(u[0], u[1], u[2])\n    g_corr = np.dot(tau, u - u0) - ds\n    F_norm = np.linalg.norm(F_corr)\n    G_norm = np.linalg.norm(np.array([F_corr[0], F_corr[1], g_corr]))\n    return u, F_norm, G_norm\n\ndef find_near_turning(Da_min, Da_max, N, T_start, c_start):\n    Das = np.linspace(Da_min, Da_max, N)\n    best = None\n    # Continuation-like scanning to improve robustness: use previous solution as next guess\n    T_guess, c_guess = T_start, c_start\n    prev_sol = None\n    for Da in Das:\n        T_sol, c_sol, ok = solve_steady(Da, T_guess, c_guess)\n        if not ok:\n            # If failed, reset guesses\n            T_guess, c_guess = 1.0, 1.0 / (1.0 + Da * np.exp(gamma * 1.0))\n            T_sol, c_sol, ok = solve_steady(Da, T_guess, c_guess)\n            if not ok:\n                continue\n        # Compute Jacobian singular values\n        J = J_mat(T_sol, c_sol, Da)\n        svals = np.linalg.svd(J, compute_uv=False)\n        smin = np.min(svals)\n        if (best is None) or (smin  best[0]):\n            best = (smin, Da, T_sol, c_sol)\n        # Update guesses for next Da\n        T_guess, c_guess = T_sol, c_sol\n        prev_sol = (T_sol, c_sol)\n    if best is None:\n        # Fallback: pick middle of range and solve\n        Da_mid = 0.5 * (Da_min + Da_max)\n        T_sol, c_sol, ok = solve_steady(Da_mid, T_start, c_start)\n        if not ok:\n            T_sol, c_sol, _ = solve_steady(Da_mid, 1.0, 1.0 / (1.0 + Da_mid * np.exp(gamma)))\n        best = (np.min(np.linalg.svd(J_mat(T_sol, c_sol, Da_mid), compute_uv=False)),\n                Da_mid, T_sol, c_sol)\n    _, Da_sel, T_sel, c_sel = best\n    return Da_sel, T_sel, c_sel\n\ndef run_case_direct(Da0, T_guess, c_guess, ds):\n    # Solve for operating point\n    T0, c0, ok = solve_steady(Da0, T_guess, c_guess)\n    # Compute tangent, predictor, corrector\n    tau = compute_tangent(T0, c0, Da0)\n    u0 = np.array([T0, c0, Da0])\n    u_pred, Fp_norm = predictor(u0, tau, ds)\n    u_corr, Fc_norm, Gc_norm = corrector(u0, u_pred, tau)\n    # Results: [T_pred, Da_pred, ||F_pred||, T_corr, Da_corr, ||F_corr||, ||G_corr||]\n    return [u_pred[0], u_pred[2], Fp_norm, u_corr[0], u_corr[2], Fc_norm, Gc_norm]\n\ndef run_case_scan(Da_min, Da_max, N, T_start, c_start, ds):\n    Da0, T0, c0 = find_near_turning(Da_min, Da_max, N, T_start, c_start)\n    tau = compute_tangent(T0, c0, Da0)\n    u0 = np.array([T0, c0, Da0])\n    u_pred, Fp_norm = predictor(u0, tau, ds)\n    u_corr, Fc_norm, Gc_norm = corrector(u0, u_pred, tau)\n    return [u_pred[0], u_pred[2], Fp_norm, u_corr[0], u_corr[2], Fc_norm, Gc_norm]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"direct\", {\"Da0\": 0.05, \"T_guess\": 1.0, \"c_guess\": 0.9, \"ds\": 0.02}),\n        (\"scan\",   {\"Da_min\": 0.01, \"Da_max\": 0.5, \"N\": 200, \"T_start\": 1.0, \"c_start\": 0.8, \"ds\": 0.01}),\n        (\"direct\", {\"Da0\": 0.20, \"T_guess\": 1.1, \"c_guess\": 0.5, \"ds\": 1e-4}),\n    ]\n\n    results = []\n    for kind, params in test_cases:\n        if kind == \"direct\":\n            res = run_case_direct(params[\"Da0\"], params[\"T_guess\"], params[\"c_guess\"], params[\"ds\"])\n        else:\n            res = run_case_scan(params[\"Da_min\"], params[\"Da_max\"], params[\"N\"],\n                                params[\"T_start\"], params[\"c_start\"], params[\"ds\"])\n        # Round each float to six decimals\n        res_rounded = [float(f\"{x:.6f}\") for x in res]\n        results.append(res_rounded)\n\n    # Final print statement in the exact required format.\n    # Single line: list of lists with comma-separated floats rounded to six decimals\n    def format_list(lst):\n        return \"[\" + \",\".join(f\"{x:.6f}\" for x in lst) + \"]\"\n    print(\"[\" + \",\".join(format_list(r) for r in results) + \"]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在单步实现的基础上，本练习将转向更宏观的目标：跟踪完整的解曲线。你将应用伪弧长法到一个经典的CSTR模型上，以绘制出其完整的点火-熄火“S形曲线”()。更重要的是，这个实践将数值路径跟踪与物理上的稳定性概念联系起来，要求你分析在探测到的转折点（折叠点）处稳定性如何变化，这是解读分岔图和理解化学反应器中“迟滞”等现象的关键。",
            "id": "4007878",
            "problem": "考虑一个在单步放热反应和阿伦尼乌斯动力学条件下运行的连续搅拌釜反应器（CSTR, Continuous Stirred Tank Reactor）。假设反应器温度的无量纲能量平衡由以下常微分方程给出\n$$\n\\frac{dT}{dt} \\;=\\; \\left(t_f - T\\right) + \\beta\\,\\lambda\\,\\exp\\!\\left(\\!-\\frac{E}{T}\\!\\right) - \\delta\\,\\left(T - t_c\\right),\n$$\n其中 $T$ 是无量纲反应器温度，$t_f$ 是无量纲进料温度，$t_c$ 是无量纲冷却剂温度，$\\beta$ 是无量纲放热系数，$\\lambda$ 是无量纲丹姆科勒数， $E$ 是无量纲活化能，$\\delta$ 是无量纲散热系数。在稳态下，温度满足代数残差\n$$\nF(T,\\lambda) \\;=\\; \\left(t_f - T\\right) + \\beta\\,\\lambda\\,\\exp\\!\\left(\\!-\\frac{E}{T}\\!\\right) - \\delta\\,\\left(T - t_c\\right) \\;=\\; 0.\n$$\n计算燃烧学中经典的“点火-熄火”S形曲线对应于满足 $F(T,\\lambda)=0$ 的点对 $(T,\\lambda)$ 集合，该曲线上存在多个转折点（折叠点），在这些点上分支相对于 $\\lambda$ 改变方向。稳态的局部线性稳定性由在稳态点处计算的右侧函数的雅可比矩阵的特征值决定。在这个单变量设置中，特征值等于导数\n$$\n\\frac{\\partial F}{\\partial T}(T,\\lambda) \\;=\\; -1 - \\delta + \\beta\\,\\lambda\\,\\exp\\!\\left(\\!-\\frac{E}{T}\\!\\right)\\,\\frac{E}{T^2}.\n$$\n若 $\\frac{\\partial F}{\\partial T}  0$，则稳态是局部稳定的；若 $\\frac{\\partial F}{\\partial T}  0$，则稳态是局部不稳定的。在 $(T,\\lambda)$ 平面上的S形曲线上的转折点（折叠点）出现在 $\\frac{d\\lambda}{dT}=0$ 处，根据应用于 $F(T,\\lambda)=0$ 的隐函数定理，这与 $\\frac{\\partial F}{\\partial T}(T,\\lambda)=0$ 一致，前提是 $\\frac{\\partial F}{\\partial \\lambda}(T,\\lambda)\\neq 0$。\n\n您的任务是实现伪弧长延拓方法，以数值方式追踪稳态曲线 $F(T,\\lambda)=0$ 穿过转折点，沿曲线计算 $\\frac{\\partial F}{\\partial T}$，并检测在折叠点处的稳定性变化。使用以下预测-校正结构：曲线上一点 $(T,\\lambda)$ 的切线方向是单位化向量 $(\\,-\\frac{\\partial F}{\\partial \\lambda},\\,\\frac{\\partial F}{\\partial T}\\,)$，预测器按固定弧长步长前进，校正器求解增广系统\n$$\n\\begin{cases}\nF(T,\\lambda) \\;=\\; 0,\\\\\nv_T\\,(T-T_{\\mathrm{prev}}) + v_\\lambda\\,(\\lambda - \\lambda_{\\mathrm{prev}}) - \\Delta s \\;=\\; 0,\n\\end{cases}\n$$\n其中 $(v_T,v_\\lambda)$ 是前一个切线，$(T_{\\mathrm{prev}},\\lambda_{\\mathrm{prev}})$ 是前一个解，$\\Delta s$ 是规定的弧长步长。\n\n从初始温度 $T_0$ 开始，根据代数约束 $F(T_0,\\lambda_0)=0$ 计算相应的 $\\lambda_0$：\n$$\n\\lambda_0 \\;=\\; \\frac{(1+\\delta)\\,T_0 - (t_f + \\delta\\,t_c)}{\\beta\\,\\exp\\!\\left(\\!-\\frac{E}{T_0}\\!\\right)}.\n$$\n从这一点出发，沿两个切线方向（沿曲线向前和向后）执行伪弧长延拓，以确保覆盖所有折叠点。沿着追踪的曲线，通过 $\\frac{\\partial F}{\\partial T}$ 对稳态稳定性进行分类，并在连续校正点之间 $\\frac{\\partial F}{\\partial T}$ 的符号发生变化或其值足够接近零时检测折叠点。对于每个检测到的折叠点，指明稳定性是否在该点发生变化。\n\n设计您的程序，为每个测试用例生成一个形式为 $[n_{\\mathrm{folds}}, [b_1, b_2, \\dots, b_{n_{\\mathrm{folds}}}]]]$ 的结果，其中 $n_{\\mathrm{folds}}$ 是合并在前向和后向延拓中发现的重复项后检测到的唯一折叠点的整数数量，$b_i$ 是布尔值，当且仅当稳定性在相应的折叠点上发生变化时为真。将所有测试用例的结果汇总到一行输出中，该输出包含一个用方括号括起来的逗号分隔列表。\n\n为以下参数集测试套件实现您的解决方案，每个参数集指定为 $(\\beta,\\delta,E,t_f,t_c,T_0,\\Delta s,N)$:\n- 情况 $1$（理想情况，两个分离良好的折叠点）：$\\beta = 5.0$, $\\delta = 0.4$, $E = 10.0$, $t_f = 0.1$, $t_c = 4.0$, $T_0 = 2.0$, $\\Delta s = 0.05$, $N = 200$。\n- 情况 $2$（具有两个在不同温度下折叠点的备用参数）：$\\beta = 3.0$, $\\delta = 0.2$, $E = 8.0$, $t_f = 0.2$, $t_c = 3.0$, $T_0 = 1.0$, $\\Delta s = 0.05$, $N = 200$。\n- 情况 $3$（通过相对于热偏移的低活化能设计，无折叠点）：$\\beta = 1.0$, $\\delta = 1.0$, $E = 1.0$, $t_f = 1.0$, $t_c = 1.0$, $T_0 = 1.5$, $\\Delta s = 0.05$, $N = 150$。\n\n所有变量都是无量纲的，不需要物理单位。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如，$[[2,[\\mathrm{True},\\mathrm{True}]],[2,[\\mathrm{True},\\mathrm{True}]],[0,[]]]$。",
            "solution": "该问题要求实现一种伪弧长延拓方法，以追踪 CSTR 稳态热平衡方程的解曲线，识别转折点（折叠点），并分析在这些点上的稳定性变化。\n\n**1. 控制方程与稳定性**\nCSTR 的稳态由代数残差方程 $F(T, \\lambda) = 0$ 定义，其中：\n$$\nF(T,\\lambda) \\;=\\; \\left(t_f - T\\right) + \\beta\\,\\lambda\\,\\exp\\!\\left(\\!-\\frac{E}{T}\\!\\right) - \\delta\\,\\left(T - t_c\\right) \\;=\\; 0\n$$\n变量 $(T, \\lambda)$ 分别代表无量纲温度和丹姆科勒数。稳态解的稳定性由 $F$ 对 $T$ 的偏导数的符号决定：\n$$\n\\frac{\\partial F}{\\partial T}(T,\\lambda) \\;=\\; -1 - \\delta + \\beta\\,\\lambda\\,\\exp\\!\\left(\\!-\\frac{E}{T}\\!\\right)\\,\\frac{E}{T^2}\n$$\n若 $\\frac{\\partial F}{\\partial T}  0$，则状态是稳定的；若 $\\frac{\\partial F}{\\partial T}  0$，则状态是不稳定的。转折点或折叠点出现在 $\\frac{\\partial F}{\\partial T} = 0$ 的地方，这标志着稳定性的改变。\n\n**2. 伪弧长延拓**\n为了追踪解曲线 $(T(\\cdot), \\lambda(\\cdot))$ 穿过在标准参数延拓 $\\lambda$ 中会失败的折叠点，我们使用预测-校正伪弧长方法。\n\n*   **预测步**：给定曲线上的一点 $(T_k, \\lambda_k)$，我们首先计算单位化切向量 $\\mathbf{v}_k = (v_T, v_\\lambda)$。根据问题描述，切线源于与梯度 $\\nabla F = (\\frac{\\partial F}{\\partial T}, \\frac{\\partial F}{\\partial \\lambda})$ 的正交条件，产生一个与 $(-\\frac{\\partial F}{\\partial \\lambda}, \\frac{\\partial F}{\\partial T})$ 成比例的向量。单位化后，我们通过沿该切线方向前进一个步长 $\\Delta s$ 来预测下一个点 $(T_p, \\lambda_p)$：\n    $$\n    (T_p, \\lambda_p) = (T_k, \\lambda_k) + \\Delta s \\cdot \\mathbf{v}_k\n    $$\n\n*   **校正步**：预测点 $(T_p, \\lambda_p)$ 是一个近似值。我们对其进行校正，通过求解一个包含两个非线性方程的增广系统来找到曲线上真正的下一个点 $(T_{k+1}, \\lambda_{k+1})$。第一个方程确保该点在解曲线上，第二个方程约束该点与前一个点的弧长距离为 $\\Delta s$（沿切线方向测量）。对于未知数 $(T, \\lambda)$ 的系统是：\n    $$\n    \\begin{cases}\n    F(T,\\lambda) \\;=\\; 0 \\\\\n    N(T,\\lambda) \\equiv v_T\\,(T-T_{k}) + v_\\lambda\\,(\\lambda - \\lambda_{k}) - \\Delta s \\;=\\; 0\n    \\end{cases}\n    $$\n    这个 $2 \\times 2$ 系统使用牛顿法迭代求解，初始猜测值为 $(T_p, \\lambda_p)$。增广系统的雅可比矩阵为：\n    $$\n    \\mathbf{J_G}(T, \\lambda) = \\begin{bmatrix} \\frac{\\partial F}{\\partial T}  \\frac{\\partial F}{\\partial \\lambda} \\\\ v_T  v_\\lambda \\end{bmatrix}\n    $$\n\n**3. 整体算法**\n每个测试用例的完整流程如下：\n1.  **初始化**：给定初始温度 $T_0$，从稳态方程 $F(T_0, \\lambda_0)=0$ 计算出相应的丹姆科勒数 $\\lambda_0$。\n2.  **双向追踪**：在 $(T_0, \\lambda_0)$ 处计算初始切向量 $\\mathbf{v}_0$。为确保追踪到整个S形曲线，从起点开始进行两次独立的延拓运行：一次以切线 $\\mathbf{v}_0$ 开始（“前向”），另一次以 $-\\mathbf{v}_0$ 开始（“后向”），每次运行 $N$ 步。\n3.  **切线方向控制**：在延拓过程中，每一步之后都会计算新的切向量。为防止路径反转，会调整其方向，使其与上一步的切向量的点积为正。\n4.  **折叠点检测**：通过连接后向（逆序）、初始和前向点来构建完整的解路径。我们遍历此路径，检查连续点之间稳定性指标 $\\frac{\\partial F}{\\partial T}$ 的符号变化。符号变化表示存在一个折叠点。使用线性插值可以更精确地估计折叠点的位置。\n5.  **稳定性分析**：$\\frac{\\partial F}{\\partial T}$ 的符号变化本质上意味着稳定和不稳定状态之间的转换。因此，对于通过此方法检测到的每个折叠点，都确认稳定性发生了变化。\n6.  **结果聚合**：在前向和后向追踪期间检测到的折叠点可能是重复的。通过对所有找到的折叠点进行排序（例如，按温度排序），并合并任何距离小于指定容差（量级与步长 $\\Delta s$ 相当）的点，来精简折叠点列表。最终输出是唯一折叠点的数量以及一个布尔值列表，表示在每个折叠点处稳定性是否发生变化。\n\n这种结构化方法确保了对S形曲线的稳健遍历、转折点的精确检测以及根据问题要求的正确稳定性分类。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the execution for all test cases.\n    It processes each case, collects the results, and prints them in the specified format.\n    \"\"\"\n\n    def format_results(results):\n        \"\"\"Helper to format the final output string according to problem specification.\"\"\"\n        inner_results_str = []\n        for res in results:\n            n_folds, bool_list = res\n            bool_str = '[' + ','.join(str(b).lower() for b in bool_list) + ']'\n            inner_results_str.append(f'[{n_folds},{bool_str}]')\n        return '[' + ','.join(inner_results_str) + ']'\n\n    def F_func(T, lam, params):\n        \"\"\"The steady-state residual function F(T, lambda).\"\"\"\n        beta, delta, E, tf, tc = params['beta'], params['delta'], params['E'], params['tf'], params['tc']\n        if T = 0: return np.inf\n        return (tf - T) + beta * lam * np.exp(-E / T) - delta * (T - tc)\n\n    def dF_dT_func(T, lam, params):\n        \"\"\"The partial derivative dF/dT, which determines stability.\"\"\"\n        beta, delta, E = params['beta'], params['delta'], params['E']\n        if T = 0: return np.inf\n        return -1.0 - delta + beta * lam * np.exp(-E / T) * (E / T**2)\n\n    def dF_dlam_func(T, lam, params):\n        \"\"\"The partial derivative dF/dlambda.\"\"\"\n        beta, E = params['beta'], params['E']\n        if T = 0: return 0.0\n        return beta * np.exp(-E / T)\n\n    def newton_corrector(initial_guess, prev_point, prev_tangent, ds, params):\n        \"\"\"\n        Solves the augmented system using Newton's method to find the corrected point on the curve.\n        \"\"\"\n        T, lam = initial_guess\n        T_prev, lam_prev = prev_point\n        vT, vlam = prev_tangent\n        \n        max_iter = 15\n        tol = 1e-9\n        \n        for _ in range(max_iter):\n            # Calculate residual vector G(x) = [F(x), N(x)]\n            F_val = F_func(T, lam, params)\n            N_val = vT * (T - T_prev) + vlam * (lam - lam_prev) - ds\n            residual = np.array([F_val, N_val])\n\n            if np.linalg.norm(residual)  tol:\n                return T, lam\n\n            # Calculate Jacobian of the augmented system J_G\n            dFdT = dF_dT_func(T, lam, params)\n            dFdlam = dF_dlam_func(T, lam, params)\n            \n            jac_det = dFdT * vlam - dFdlam * vT\n            if abs(jac_det)  1e-12: # Jacobian is singular or near-singular\n                return None, None\n                \n            # Analytically compute inverse of 2x2 Jacobian and update step\n            delta_T = (-vlam * F_val + dFdlam * N_val) / jac_det\n            delta_lam = (vT * F_val - dFdT * N_val) / jac_det\n                \n            T -= delta_T\n            lam -= delta_lam\n            \n            if T = 0: return None, None # Non-physical temperature\n\n        return None, None # Did not converge\n\n    def trace_curve(start_point, start_tangent, N, ds, params):\n        \"\"\"\n        Traces one branch of the solution curve using predictor-corrector continuation.\n        \"\"\"\n        path = []\n        current_point = np.array(start_point)\n        current_tangent = np.array(start_tangent)\n\n        for _ in range(N):\n            prev_point = current_point\n            prev_tangent = current_tangent\n            \n            # Predictor step\n            predictor_point = prev_point + ds * prev_tangent\n            \n            # Corrector step\n            corrected_point_tuple = newton_corrector(\n                predictor_point, prev_point, prev_tangent, ds, params\n            )\n            \n            if corrected_point_tuple[0] is None:\n                break # Stop if corrector fails\n\n            current_point = np.array(corrected_point_tuple)\n            \n            # Compute new tangent and ensure consistent direction\n            T, lam = current_point\n            s_val = dF_dT_func(T, lam, params)\n            raw_tangent = np.array([-dF_dlam_func(T, lam, params), s_val])\n            \n            norm_raw_tangent = np.linalg.norm(raw_tangent)\n            if norm_raw_tangent  1e-9: # Near a fold, tangent is unstable\n                 current_tangent = prev_tangent # Reuse previous tangent to step over\n            else:\n                 current_tangent = raw_tangent / norm_raw_tangent\n\n            # Ensure consistent direction of traversal\n            if np.dot(current_tangent, prev_tangent)  0:\n                current_tangent = -current_tangent\n            \n            path.append((current_point, s_val))\n\n        return path\n    \n    def find_folds(path):\n        \"\"\"Detects folds by looking for sign changes in dF/dT along the path.\"\"\"\n        folds = []\n        for i in range(len(path) - 1):\n            p_i, s_i = path[i]\n            p_i_plus_1, s_i_plus_1 = path[i+1]\n            \n            if s_i * s_i_plus_1  0:\n                # Linear interpolation to find where s=0\n                if abs(s_i_plus_1 - s_i)  1e-12: continue\n                alpha = -s_i / (s_i_plus_1 - s_i)\n                fold_point = p_i + alpha * (p_i_plus_1 - p_i)\n                # Detection via sign change implies stability changes.\n                stability_change = True\n                folds.append((fold_point, stability_change))\n        return folds\n\n    def merge_folds(folds, ds):\n        \"\"\"Merges duplicate folds found during forward/backward tracing.\"\"\"\n        if not folds:\n            return []\n        \n        # Sort folds by T-coordinate to group them\n        sorted_folds = sorted(folds, key=lambda x: x[0][0])\n        \n        unique_folds = [sorted_folds[0]]\n        for i in range(1, len(sorted_folds)):\n            current_fold_pt, _ = sorted_folds[i]\n            last_unique_fold_pt, _ = unique_folds[-1]\n            \n            dist = np.linalg.norm(current_fold_pt - last_unique_fold_pt)\n            # Merge if closer than the arclength step (heuristic for uniqueness)\n            if dist  ds:\n                unique_folds.append(sorted_folds[i])\n        \n        return unique_folds\n    \n    def process_case(case_params):\n        \"\"\"Processes a single test case from start to finish.\"\"\"\n        beta, delta, E, tf, tc, T0, ds, N = case_params\n        params = {'beta': beta, 'delta': delta, 'E': E, 'tf': tf, 'tc': tc}\n\n        # Calculate initial lambda from F(T0, lam0) = 0\n        numerator = (1.0 + delta) * T0 - (tf + delta * tc)\n        denominator = beta * np.exp(-E / T0)\n        if abs(denominator)  1e-12: return [0, []]\n        lam0 = numerator / denominator\n\n        start_point = np.array([T0, lam0])\n        \n        # Calculate initial tangent and stability\n        s0 = dF_dT_func(T0, lam0, params)\n        initial_raw_tangent = np.array([-dF_dlam_func(T0, lam0, params), s0])\n        norm_init_tangent = np.linalg.norm(initial_raw_tangent)\n        if norm_init_tangent  1e-9: return [0, []] # Cannot start at a fold\n        initial_tangent = initial_raw_tangent / norm_init_tangent\n\n        # Trace curve in both forward and backward directions\n        forward_path = trace_curve(start_point, initial_tangent, N, ds, params)\n        backward_path = trace_curve(start_point, -initial_tangent, N, ds, params)\n        \n        # Combine paths for a full curve traversal\n        full_path = list(reversed(backward_path)) + [(start_point, s0)] + forward_path\n        \n        # Detect and merge folds from the full path\n        all_folds = find_folds(full_path)\n        unique_folds = merge_folds(all_folds, ds)\n        \n        n_folds = len(unique_folds)\n        stability_changes = [b for _, b in unique_folds]\n        \n        return [n_folds, stability_changes]\n\n    # --- Test Suite ---\n    test_cases = [\n        # (beta, delta, E, tf, tc, T0, ds, N)\n        (5.0, 0.4, 10.0, 0.1, 4.0, 2.0, 0.05, 200), # Case 1\n        (3.0, 0.2, 8.0, 0.2, 3.0, 1.0, 0.05, 200), # Case 2\n        (1.0, 1.0, 1.0, 1.0, 1.0, 1.5, 0.05, 150), # Case 3\n    ]\n\n    results = [process_case(case) for case in test_cases]\n\n    # The problem asks for JSON-like boolean literals, so we convert python's True/False to 'true'/'false'\n    def format_bool_list(bl):\n        return '[' + ','.join([str(b).lower() for b in bl]) + ']'\n    \n    formatted_results = []\n    for n_folds, bools in results:\n        formatted_results.append(f'[{n_folds},{format_bool_list(bools)}]')\n        \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "一个鲁棒的延拓算法不仅要精确，还必须高效，尤其是在处理具有急剧转弯的曲线时。这个高级实践通过引入自适应步长控制策略来应对这一挑战。你将实现一个比例-积分（PI）控制器来自动调节弧长步长 $\\Delta s$，目标是维持一个恒定的校正迭代次数 ()。这个练习模拟了现代数值求解器的“智能”，展示了如何构建一个能够自主导航具有不同曲率的复杂解流形的工具。",
            "id": "4007914",
            "problem": "考虑一个理想搅拌的反应系统（连续搅拌釜式反应器），其中发生不可逆、一级、放热反应，并采用恒定密度和恒定热容的近似。在无量纲化公式中，给定 Damköhler 数 $\\lambda$ 时，无量纲浓度 $x$ 和无量纲温度 $y$ 的稳态平衡由以下非线性代数方程组建模：\n$$\nF(x,y,\\lambda) =\n\\begin{bmatrix}\n(1 - x) - \\lambda\\,x\\,\\exp(\\gamma\\,y) \\\\\n(1 - y) + \\beta\\,\\lambda\\,x\\,\\exp(\\gamma\\,y) - h\\,(y - y_c)\n\\end{bmatrix} = \\mathbf{0},\n$$\n其中 $\\beta$ 是无量纲放热参数，$\\gamma$ 是由 Arrhenius 依赖关系产生的无量纲活化参数，$h$ 是无量纲热损失系数，$y_c$ 是无量纲冷却剂温度。对于足够大的 $\\beta$ 和 $\\gamma$ 以及适中的 $h$，该模型会在 $(x,y,\\lambda)$ 空间中产生一个 $S$ 形平衡流形，其转折点（折叠点）与点火和熄灭现象相关。你的任务是实现一个稳健的伪弧长延拓算法来追踪该转折点曲线，并使用比例-积分控制器来调节弧长步长 $\\Delta s$，以达到固定的校正器 Newton 迭代次数目标。\n\n从通过 Newton 法在 $\\lambda_0$ 处找到的初始稳态开始，使用带有标准超平面约束的预测-校正伪弧长延拓方法，沿着 $(x,y,\\lambda)$ 中的解曲线前进。在每个延拓步骤中，执行：\n- 一个基于单位切线 $\\mathbf{t} = \\left[\\dfrac{dx}{ds}, \\dfrac{dy}{ds}, \\dfrac{d\\lambda}{ds}\\right]^T$ 的切线预测器。\n- 对由平衡方程 $F(x,y,\\lambda)=\\mathbf{0}$ 和由前一切线定义的超平面约束组成的增广系统进行 Newton 校正。\n\n用比例-积分定律调节步长 $\\Delta s$，以固定数量的校正器 Newton 迭代次数 $n_\\mathrm{targ}$ 为目标。设 $e_k = n_k - n_\\mathrm{targ}$ 为第 $k$ 个已接受步的迭代次数误差，并设 $E_k$ 为 $e_k$ 的运行积分。通过 $\\Delta s \\leftarrow \\Delta s \\,\\exp(-k_p\\,e_k - k_i\\,E_k)$ 乘法更新步长，其中增益为 $k_p$ 和 $k_i$，并将 $\\Delta s$ 限制在 $[\\Delta s_{\\min}, \\Delta s_{\\max}]$ 范围内。如果校正器在 $n_{\\max}$ 次迭代内未能收敛或违反了残差单调下降的保障措施，则拒绝该步，减小 $\\Delta s \\leftarrow r_\\mathrm{fail}\\,\\Delta s$，并从最后一个已接受的状态重试。如果 $\\Delta s  \\Delta s_{\\min}$，则提前终止运行。\n\n数值要求：\n- 实现关于 $(x,y)$ 和 $\\lambda$ 的 $F(x,y,\\lambda)$ 的解析 Jacobian 矩阵，并使用直接线性求解器求解带边线性系统。\n- 在校正器更新上使用线搜索阻尼，以确保增广残差范数不增加，在宣布失败前，最多可进行有限次数的回溯，每次回溯因子为 $1/2$。\n- 将预测器切线归一化为单位弧长，并通过翻转其符号使其与连续接受点之间的割线对齐来保持一致的方向。\n\n测试套件：\n实现一个单一程序，执行三个案例，使用以下参数并报告量化指标。所有量均为无量纲。\n\n所有案例通用的数值设置：\n- 初始 Damköhler 数 $\\lambda_0 = 0.01$。\n- 初始稳态的初始猜测值 $(x,y) = (1,0)$。\n- 平衡方程的 Newton 容差 $\\|F\\|_2 \\le 10^{-10}$ 以及超平面残差的容差 $\\le 10^{-12}$。\n- 最大校正器 Newton 迭代次数 $n_{\\max} = 20$。\n- 阻尼回溯限制 $n_{\\mathrm{ls}} = 10$。\n- 初始步长 $\\Delta s_0 = 0.02$，界限 $\\Delta s_{\\min} = 10^{-4}$ 和 $\\Delta s_{\\max} = 0.2$。\n- 失败缩减因子 $r_{\\mathrm{fail}} = 0.5$。\n- 尝试的延拓接受步数 $N_{\\mathrm{acc}} = 40$（如果 $\\Delta s  \\Delta s_{\\min}$ 则提前终止）。\n\n案例 A（基准平滑 S 形曲线）：\n- 参数 $(\\beta,\\gamma,h,y_c) = (8,6,1,0)$。\n- 控制器目标 $n_\\mathrm{targ} = 4$，增益 $(k_p,k_i) = (0.25,0.05)$。\n- 运行期间无参数变化。\n- 要求的输出指标 $m_A$：已接受步的校正器迭代次数与目标值的最大绝对偏差，\n$$\nm_A = \\max_{1 \\le k \\le K} \\left| n_k - n_\\mathrm{targ} \\right|,\n$$\n其中 $K$ 是已接受的步数。\n\n案例 B（曲率突然增加）：\n- 从 $(\\beta,\\gamma,h,y_c) = (8,6,1,0)$ 开始。\n- 控制器目标 $n_\\mathrm{targ} = 4$，增益 $(k_p,k_i) = (0.25,0.05)$。\n- 在恰好 $k_{\\mathrm{sw}} = 12$ 个已接受步后，瞬时改变活化参数为 $\\gamma \\leftarrow 9$ 并在此后保持固定；所有其他参数不变。\n- 要求的输出指标 $m_B$：在改变后的接下来 $K_{\\mathrm{win}} = 8$ 个已接受步内，迭代次数超出目标值的最大正向超调量，\n$$\nm_B = \\max_{k_{\\mathrm{sw}}  k \\le \\min(k_{\\mathrm{sw}}+K_{\\mathrm{win}},K)} \\max\\!\\left(0,\\, n_k - n_\\mathrm{targ} \\right).\n$$\n\n案例 C（更陡峭的折叠点，更严格的调节压力测试）：\n- 参数 $(\\beta,\\gamma,h,y_c) = (10,9,0.5,0)$。\n- 控制器目标 $n_\\mathrm{targ} = 3$，增益 $(k_p,k_i) = (0.2,0.04)$。\n- 运行期间无参数变化。\n- 要求的输出指标 $m_C$：在接受或提前终止之前，因校正器不收敛而被拒绝的总步数。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含结果，形式为方括号内的逗号分隔列表，顺序为 $[m_A,m_B,m_C]$。每个指标必须打印为 Python 字面量数字，$m_A$ 和 $m_B$ 为浮点数，$m_C$ 为整数。不应打印任何其他文本。",
            "solution": "用户提供的问题是有效的，因为它构成了一个适定、有科学依据且严格定义的数值任务。它描述了应用伪弧长延拓方法来追踪连续搅拌釜式反应器（CSTR）这一经典模型的平衡流形，这是化学工程和分岔分析中的一个标准问题。所有必要的参数、初始条件和数值规范都已明确无误地提供，没有任何歧义或矛盾。\n\n我们的目标是追踪非线性代数方程组 $F(\\mathbf{z}) = \\mathbf{0}$ 的解曲线 $\\mathbf{z}(s) = [x(s), y(s), \\lambda(s)]^T$，其中 $s$ 是弧长。该系统定义为：\n$$\nF(x,y,\\lambda) =\n\\begin{bmatrix}\nF_1 \\\\\nF_2\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n(1 - x) - \\lambda\\,x\\,\\exp(\\gamma\\,y) \\\\\n(1 - y) + \\beta\\,\\lambda\\,x\\,\\exp(\\gamma\\,y) - h\\,(y - y_c)\n\\end{bmatrix} = \\mathbf{0}\n$$\n标准参数延拓，其中 $\\lambda$ 是自变量，在解分支折回的转折点会失败。在这些点上，系统关于状态变量 $(x, y)$ 的 Jacobian 矩阵（记为 $J_{F,\\mathbf{v}}$）变为奇异，解不再是 $\\lambda$ 的单值函数。伪弧长延拓通过弧长 $s$ 对曲线进行参数化，并将 $\\lambda$ 视为因变量，作为状态向量 $\\mathbf{z} = [x, y, \\lambda]^T$ 的一部分，从而解决了这个问题。该算法通过一系列预测-校正步骤进行。\n\n首先，我们必须在解曲线上找到一个起始点。对于给定的初始 Damköhler 数 $\\lambda_0 = 0.01$，我们使用带有线搜索阻尼的标准 Newton-Raphson 方法，从猜测值 $(x,y)=(1,0)$ 开始，求解系统 $F(x, y, \\lambda_0) = \\mathbf{0}$ 以获得 $(x_0, y_0)$。这给出了初始状态 $\\mathbf{z}_0 = [x_0, y_0, \\lambda_0]^T$。\n\n延拓算法的核心是一个迭代循环。在每个已接受的步骤 $k$（在状态 $\\mathbf{z}_k$），我们执行以下操作：\n\n**1. 预测步**\n预测步从当前点 $\\mathbf{z}_k$ 沿着曲线的切线方向 $\\mathbf{t}_k$ 外插，以找到一个试验点 $\\mathbf{z}_{k+1}^p$。\n$$\n\\mathbf{z}_{k+1}^p = \\mathbf{z}_k + \\Delta s_k \\, \\mathbf{t}_k\n$$\n其中 $\\Delta s_k$ 是当前的弧长步长。切向量 $\\mathbf{t}_k$ 是一个单位向量，它张成了在 $\\mathbf{z}_k$ 处求值的完整 Jacobian 矩阵 $J_{F,\\mathbf{z}} = \\left[ \\frac{\\partial F}{\\partial x} \\quad \\frac{\\partial F}{\\partial y} \\quad \\frac{\\partial F}{\\partial \\lambda} \\right]$ 的一维零空间。\n$$\nJ_{F,\\mathbf{z}}(\\mathbf{z}_k) \\, \\mathbf{t}_k = \\mathbf{0}, \\quad \\|\\mathbf{t}_k\\|_2 = 1\n$$\n这个向量可以使用 $J_{F,\\mathbf{z}}$ 的奇异值分解 (SVD) 稳健地计算，`scipy.linalg.null_space` 为此提供了一个方便的实现。切向量的符号是任意的；为确保对曲线的一致遍历，我们强制一个方向。对于第一步 ($k=0$)，我们定向 $\\mathbf{t}_0$ 使其 $\\lambda$ 分量为正 ($t_\\lambda  0$)。对于所有后续步骤 ($k  0$)，我们定向 $\\mathbf{t}_k$ 使其在前一步的割线向量上的投影为正，即 $\\mathbf{t}_k \\cdot (\\mathbf{z}_k - \\mathbf{z}_{k-1})  0$。\n\n**2. 校正步**\n预测点 $\\mathbf{z}_{k+1}^p$ 偏离了真实的解流形。校正步找到一个满足控制方程的邻近点 $\\mathbf{z}_{k+1}$。这是通过使用 Newton 法求解一个增广方程组来实现的。该系统包括原始的平衡方程和一个约束，该约束强制校正后的点位于一个与切向量 $\\mathbf{t}_k$ 正交且通过预测点 $\\mathbf{z}_{k+1}^p$ 的超平面上。增广系统 $G(\\mathbf{z}) = \\mathbf{0}$ 是：\n$$\nG(\\mathbf{z}) =\n\\begin{bmatrix}\nF(x,y,\\lambda) \\\\\nN(\\mathbf{z})\n\\end{{bmatrix}\n=\n\\begin{bmatrix}\n(1 - x) - \\lambda\\,x\\,\\exp(\\gamma\\,y) \\\\\n(1 - y) + \\beta\\,\\lambda\\,x\\,\\exp(\\gamma\\,y) - h\\,(y - y_c) \\\\\n\\mathbf{t}_k \\cdot (\\mathbf{z} - \\mathbf{z}_{k+1}^p)\n\\end{bmatrix}\n= \\mathbf{0}\n$$\n这个 $(3 \\times 3)$ 系统从猜测值 $\\mathbf{z}^{(0)} = \\mathbf{z}_{k+1}^p$ 开始，通过迭代求解 $\\mathbf{z}$。增广系统的 Jacobian 矩阵 $J_G$ 是一个带边矩阵：\n$$\nJ_G =\n\\begin{bmatrix}\nJ_{F,\\mathbf{z}} \\\\\n\\mathbf{t}_k^T\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\frac{\\partial F_1}{\\partial x}  \\frac{\\partial F_1}{\\partial y}  \\frac{\\partial F_1}{\\partial \\lambda} \\\\\n\\frac{\\partial F_2}{\\partial x}  \\frac{\\partial F_2}{\\partial y}  \\frac{\\partial F_2}{\\partial \\lambda} \\\\\nt_x  t_y  t_\\lambda\n\\end{bmatrix}\n$$\nNewton 更新量 $\\delta \\mathbf{z}^{(j)}$ 通过求解线性系统 $J_G(\\mathbf{z}^{(j)}) \\, \\delta \\mathbf{z}^{(j)} = -G(\\mathbf{z}^{(j)})$ 得到。为确保稳健收敛，更新量通过线搜索进行阻尼：$\\mathbf{z}^{(j+1)} = \\mathbf{z}^{(j)} + \\alpha \\, \\delta \\mathbf{z}^{(j)}$，其中通过回溯选择阻尼因子 $\\alpha \\in (0, 1]$ 以确保增广残差的范数减小，即 $\\|G(\\mathbf{z}^{(j+1)})\\|_2  \\|G(\\mathbf{z}^{(j)})\\|_2$。如果 $\\|F\\|_2$ 和 $|N|$ 在 $n_{\\max}$ 次迭代内降至各自的容差以下，则校正器成功收敛。\n\nJacobian 矩阵 $J_{F,\\mathbf{z}}$ 所需的解析导数如下：\n令 $R = \\lambda x \\exp(\\gamma y)$，我们有：\n$\\frac{\\partial F_1}{\\partial x} = -1 - \\lambda \\exp(\\gamma y)$, $\\frac{\\partial F_1}{\\partial y} = -\\gamma R$, $\\frac{\\partial F_1}{\\partial \\lambda} = -x \\exp(\\gamma y)$\n$\\frac{\\partial F_2}{\\partial x} = \\beta \\lambda \\exp(\\gamma y)$, $\\frac{\\partial F_2}{\\partial y} = -1 + \\beta \\gamma R - h$, $\\frac{\\partial F_2}{\\partial \\lambda} = \\beta x \\exp(\\gamma y)$\n\n**3. 步长控制与失败处理**\n为了有效地遍历解曲线，穿过高曲率和低曲率的区域，弧长步长 $\\Delta s$ 是自适应的。一个比例-积分 (PI) 控制器调整 $\\Delta s$ 以维持目标校正器迭代次数 $n_\\mathrm{targ}$。在一个步骤 $k$ 以 $n_k$ 次迭代成功接受后，计算误差 $e_k = n_k - n_\\mathrm{targ}$ 及其运行积分 $E_k = E_{k-1} + e_k$。下一步长通过乘法更新：\n$$\n\\Delta s_{k+1} = \\Delta s_k \\exp(-k_p e_k - k_i E_k)\n$$\n然后将结果限制在区间 $[\\Delta s_{\\min}, \\Delta s_{\\max}]$ 内。如果校正器未能收敛，则该步被拒绝，步长乘以因子 $r_{\\mathrm{fail}}$ 减小，并从最后一个已接受的点 $\\mathbf{z}_k$ 重试该步。如果 $\\Delta s$ 降至 $\\Delta s_{\\min}$ 以下，则提前终止延拓。这种自适应方案在计算效率和稳健性之间提供了平衡。",
            "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to execute the three test cases and print the results.\n    \"\"\"\n\n    common_settings = {\n        'lambda0': 0.01,\n        'initial_guess': np.array([1.0, 0.0]),\n        'tol_F': 1e-10,\n        'tol_N': 1e-12,\n        'n_max': 20,\n        'n_ls': 10,\n        'ds0': 0.02,\n        'ds_min': 1e-4,\n        'ds_max': 0.2,\n        'r_fail': 0.5,\n        'N_acc': 40,\n    }\n\n    # Case A\n    case_A_params = {\n        'case_id': 'A',\n        'beta': 8.0, 'gamma': 6.0, 'h': 1.0, 'yc': 0.0,\n        'n_targ': 4, 'kp': 0.25, 'ki': 0.05,\n    }\n    params_A = {**common_settings, **case_A_params}\n    result_A = run_case(params_A)\n    m_A = compute_metric_A(result_A, params_A['n_targ'])\n\n    # Case B\n    case_B_params = {\n        'case_id': 'B',\n        'beta': 8.0, 'gamma': 6.0, 'h': 1.0, 'yc': 0.0,\n        'n_targ': 4, 'kp': 0.25, 'ki': 0.05,\n        'k_sw': 12, 'gamma_new': 9.0, 'K_win': 8,\n    }\n    params_B = {**common_settings, **case_B_params}\n    result_B = run_case(params_B)\n    m_B = compute_metric_B(result_B, params_B['n_targ'], params_B['k_sw'], params_B['K_win'])\n\n    # Case C\n    case_C_params = {\n        'case_id': 'C',\n        'beta': 10.0, 'gamma': 9.0, 'h': 0.5, 'yc': 0.0,\n        'n_targ': 3, 'kp': 0.2, 'ki': 0.04,\n    }\n    params_C = {**common_settings, **case_C_params}\n    result_C = run_case(params_C)\n    m_C = compute_metric_C(result_C)\n\n    print(f\"[{float(m_A)},{float(m_B)},{int(m_C)}]\")\n\ndef F_vec(z, p):\n    \"\"\"Computes the residual vector F of the CSTR equations.\"\"\"\n    x, y, lam = z\n    R = lam * x * np.exp(p['gamma'] * y)\n    F1 = (1.0 - x) - R\n    F2 = (1.0 - y) + p['beta'] * R - p['h'] * (y - p['yc'])\n    return np.array([F1, F2])\n\ndef J_F_z(z, p):\n    \"\"\"Computes the Jacobian of F with respect to z = [x, y, lambda].\"\"\"\n    x, y, lam = z\n    if x == 0.0 or lam == 0.0: # Avoid division by zero\n        exp_gy = np.exp(p['gamma'] * y)\n        R = lam * x * exp_gy\n        dR_dx = lam * exp_gy\n        dR_dy = lam * x * p['gamma'] * exp_gy\n        dR_dlam = x * exp_gy\n    else:\n        R = lam * x * np.exp(p['gamma'] * y)\n        dR_dx = R / x\n        dR_dy = p['gamma'] * R\n        dR_dlam = R / lam\n\n    J11 = -1.0 - dR_dx\n    J12 = -dR_dy\n    J13 = -dR_dlam\n    \n    J21 = p['beta'] * dR_dx\n    J22 = -1.0 + p['beta'] * dR_dy - p['h']\n    J23 = p['beta'] * dR_dlam\n\n    return np.array([[J11, J12, J13], [J21, J22, J23]])\n\ndef find_initial_point(p):\n    \"\"\"Finds the initial steady state (x, y) at lambda0 using Newton's method.\"\"\"\n    lam0 = p['lambda0']\n    v = p['initial_guess'].copy()\n\n    for _ in range(p['n_max']):\n        z_fixed_lam = np.array([v[0], v[1], lam0])\n        F = F_vec(z_fixed_lam, p)\n        if linalg.norm(F)  p['tol_F']:\n            return np.array([v[0], v[1], lam0])\n        \n        J_Fv = J_F_z(z_fixed_lam, p)[:, :2]\n        delta_v = linalg.solve(J_Fv, -F)\n        \n        alpha = 1.0\n        norm_F = linalg.norm(F)\n        for _ in range(p['n_ls']):\n            v_new = v + alpha * delta_v\n            z_new = np.array([v_new[0], v_new[1], lam0])\n            if linalg.norm(F_vec(z_new, p))  norm_F:\n                v = v_new\n                break\n            alpha /= 2.0\n        else: # Line search failed\n            return None\n    return None\n\ndef run_case(p):\n    \"\"\"Performs the pseudo-arclength continuation for a given set of parameters.\"\"\"\n    z_current = find_initial_point(p)\n    if z_current is None:\n        return {'n_iters_list': [], 'rejected_steps': 0, 'total_accepted': 0}\n\n    # Make a mutable copy of parameters for Case B\n    p_run = p.copy()\n\n    accepted_steps = 0\n    rejected_steps = 0\n    n_iters_list = []\n    \n    ds = p['ds0']\n    E_integral = 0.0\n    z_previous = None\n\n    while accepted_steps  p['N_acc']:\n        if p['case_id'] == 'B' and accepted_steps == p['k_sw']:\n             p_run['gamma'] = p['gamma_new']\n\n        # Retry loop for the current step\n        step_accepted = False\n        while not step_accepted:\n            J_fz = J_F_z(z_current, p_run)\n            tangent = linalg.null_space(J_fz).ravel()\n            \n            # Orient tangent\n            if accepted_steps == 0:\n                if tangent[2]  0:\n                    tangent = -tangent\n            else:\n                secant = z_current - z_previous\n                if np.dot(tangent, secant)  0:\n                    tangent = -tangent\n\n            z_pred = z_current + ds * tangent\n            \n            # Newton corrector loop\n            z_corr = z_pred.copy()\n            converged = False\n            n_iter = 0\n            for i in range(p['n_max']):\n                n_iter = i + 1\n                F_res = F_vec(z_corr, p_run)\n                N_res = np.dot(tangent, z_corr - z_pred)\n                \n                if linalg.norm(F_res)  p['tol_F'] and abs(N_res)  p['tol_N']:\n                    converged = True\n                    break\n\n                G_res = np.append(F_res, N_res)\n                J_G = np.vstack([J_F_z(z_corr, p_run), tangent])\n                \n                # Check for singular Jacobian\n                if abs(linalg.det(J_G))  1e-12: break\n\n                delta_z = linalg.solve(J_G, -G_res)\n                \n                # Line search\n                alpha = 1.0\n                norm_G = linalg.norm(G_res)\n                ls_success = False\n                for _ in range(p['n_ls']):\n                    z_next = z_corr + alpha * delta_z\n                    G_next = np.append(F_vec(z_next, p_run), np.dot(tangent, z_next - z_pred))\n                    if linalg.norm(G_next)  norm_G:\n                        z_corr = z_next\n                        ls_success = True\n                        break\n                    alpha /= 2.0\n                \n                if not ls_success:\n                    break\n            \n            if converged:\n                step_accepted = True\n                n_iters_list.append(n_iter)\n                \n                z_previous = z_current\n                z_current = z_corr\n                accepted_steps += 1\n                \n                # PI Controller update\n                error = n_iter - p['n_targ']\n                E_integral += error\n                ds_factor = np.exp(-p['kp'] * error - p['ki'] * E_integral)\n                ds = np.clip(ds * ds_factor, p['ds_min'], p['ds_max'])\n            else: # Corrector failed\n                rejected_steps += 1\n                ds *= p['r_fail']\n                if ds  p['ds_min']:\n                    break # Terminate run\n        \n        if ds  p['ds_min']:\n            break # Terminate from outer loop\n\n    return {\n        'n_iters_list': n_iters_list,\n        'rejected_steps': rejected_steps,\n        'total_accepted': accepted_steps,\n    }\n\ndef compute_metric_A(result, n_targ):\n    n_iters = np.array(result['n_iters_list'])\n    if len(n_iters) == 0:\n        return 0.0\n    return np.max(np.abs(n_iters - n_targ))\n\ndef compute_metric_B(result, n_targ, k_sw, K_win):\n    n_iters = result['n_iters_list']\n    K = result['total_accepted']\n    if K = k_sw:\n        return 0.0\n    \n    window = n_iters[k_sw : min(k_sw + K_win, K)]\n    if not window:\n        return 0.0\n\n    overshoots = np.array(window) - n_targ\n    return np.max(np.maximum(0, overshoots))\n\ndef compute_metric_C(result):\n    return result['rejected_steps']\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}