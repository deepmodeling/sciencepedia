{
    "hands_on_practices": [
        {
            "introduction": "本章的第一个实践将指导你构建弧长延拓方法的核心引擎。我们将以一个实际的连续搅拌釜反应器（CSTR）模型为例，完整地实现一个预测-校正步骤。通过这个练习，你将掌握该方法的基本机制：计算切线、进行预测，以及使用增广牛顿系统将解校正回解流形。",
            "id": "4007867",
            "problem": "一个维持单次不可逆放热反应的连续搅拌釜反应器（CSTR）在稳态下通过两个源于物种守恒和能量守恒的无量纲代数平衡方程进行建模。反应速率由 Frank-Kamenetskii 形式近似，这是对燃烧中热驱动反应的阿伦尼乌斯动力学的一种广泛使用的简化，其中无量纲速率随无量纲温度呈指数增长。设未知数为无量纲温度 $T$ 和无量纲反应物浓度 $c$，控制参数为 Damköhler 数 $\\text{Da}$，它标度了停留时间和本征动力学。反应速率为 $r(T,c) = c \\exp(\\gamma T)$，其中 $\\gamma  0$ 是无量纲活化参数。稳态方程为\n$$\nF_1(T,c,\\text{Da}) = (1 - c) - \\text{Da} \\, c \\exp(\\gamma T) = 0,\n$$\n$$\nF_2(T,c,\\text{Da}) = (1 + h)(1 - T) + \\beta \\, \\text{Da} \\, c \\exp(\\gamma T) = 0,\n$$\n其中 $\\beta  0$ 是无量纲放热参数， $h  0$ 是无量纲散热系数；进料和冷却剂的温度以及入口浓度已被标度为1。\n\n弧长延拓方法通过增广这些非线性方程来追踪稳态解分支，使其能够跨越参数 $\\text{Da}$ 的转折点。定义变量向量 $\\mathbf{u} = (T,c,\\text{Da})$ 和残差向量 $\\mathbf{F}(\\mathbf{u}) = (F_1, F_2)$。在一个满足 $\\mathbf{F}(\\mathbf{u}_0) = \\mathbf{0}$ 的操作点 $\\mathbf{u}_0 = (T_0, c_0, \\text{Da}_0)$ 处，通过对 $\\mathbf{F}(\\mathbf{u}) = \\mathbf{0}$ 关于弧长参数 $s$ 求导并施加归一化，可以确定解流形的切线方向 $\\boldsymbol{\\tau} = (\\tau_T, \\tau_c, \\tau_{\\text{Da}})$。对于给定的弧长步长 $\\Delta s$，预测步前进到 $\\mathbf{u}_{\\text{pred}} = \\mathbf{u}_0 + \\Delta s \\, \\boldsymbol{\\tau}$。然后，校正步求解由两个反应器残差和一个伪弧长约束组成的增广系统，以返回到 $\\mathbf{u}_{\\text{pred}}$附近的解流形上。\n\n您的任务是基于上述基本定义，不依赖任何预先提供的公式，实现以下内容：\n1. 对于每个指定的操作点，通过求解 $F_1(T,c,\\text{Da}_0) = 0$ 和 $F_2(T,c,\\text{Da}_0) = 0$，在给定的 $\\text{Da}_0$ 处计算一个稳态解 $(T_0,c_0)$。\n2. 在 $\\mathbf{u}_0$ 处，计算与单位欧几里得范数一致的切线方向 $\\boldsymbol{\\tau}$，使用给定的 $\\Delta s$ 执行一个预测步，并计算反应器残差的2-范数 $\\|\\mathbf{F}(\\mathbf{u}_{\\text{pred}})\\|_2$。\n3. 应用牛顿法于由两个反应器方程和一个伪弧长约束组成的增广系统，执行一个校正步。报告校正后的 $(T,\\text{Da})$、反应器残差的2-范数 $\\|\\mathbf{F}(\\mathbf{u}_{\\text{corr}})\\|_2$ 以及增广残差的2-范数 $\\|\\mathbf{G}(\\mathbf{u}_{\\text{corr}})\\|_2$，其中 $\\mathbf{G}$ 叠加了反应器残差和弧长约束。\n4. 所有计算均使用参数值 $\\gamma = 3$、$\\beta = 2$、 $h = 3$。变量 $T$、$c$ 和 $\\text{Da}$ 都是无量纲的，因此不需要进行物理单位转换。\n\n测试套件：\n- 情况 A（一般情况）：$\\text{Da}_0 = 0.05$，初始猜测值 $(T,c) = (1.0, 0.9)$，以及 $\\Delta s = 0.02$。\n- 情况 B（邻近转折点检测）：在区间 $[0.01, 0.5]$ 上均匀扫描 $\\text{Da}$，使用 $N = 200$ 个网格点。在每个网格点上，从前一个解作为初始猜测值开始求解 $(T,c)$，并选择雅可比矩阵 $\\partial \\mathbf{F}/\\partial (T,c)$ 奇异值最小的操作点，然后设置 $\\Delta s = 0.01$。在第一个网格点使用 $(T,c) = (1.0, 0.8)$ 作为起始猜测值。\n- 情况 C（小步长边缘情况）：$\\text{Da}_0 = 0.20$，初始猜测值 $(T,c) = (1.1, 0.5)$，以及 $\\Delta s = 10^{-4}$。\n\n对于每个情况，程序必须返回一个包含七个浮点数的列表：\n- $T_{\\text{pred}}$、$\\text{Da}_{\\text{pred}}$、$\\|\\mathbf{F}(\\mathbf{u}_{\\text{pred}})\\|_2$、 $T_{\\text{corr}}$、$\\text{Da}_{\\text{corr}}$、$\\|\\mathbf{F}(\\mathbf{u}_{\\text{corr}})\\|_2$、$\\|\\mathbf{G}(\\mathbf{u}_{\\text{corr}})\\|_2$。\n将每个数字四舍五入到六位小数。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个由方括号括起来的逗号分隔列表。列表中的每个条目是对应测试用例的七个数字的列表，顺序与测试套件相同，例如：\n$[$$[T_{\\text{pred}}^{(A)},\\text{Da}_{\\text{pred}}^{(A)},\\dots]$$,$$[T_{\\text{pred}}^{(B)},\\text{Da}_{\\text{pred}}^{(B)},\\dots]$$,$$[T_{\\text{pred}}^{(C)},\\text{Da}_{\\text{pred}}^{(C)},\\dots]$$$]$。",
            "solution": "连续搅拌釜反应器（CSTR）模型是根据稳态下的物种和能量平衡建立的。在入口值被标度为单位1（即进料浓度和进料温度为1）以及无量纲散热和放热参数分别为 $h$ 和 $\\beta$ 的情况下，平衡方程如下：\n$$\nF_1(T,c,\\text{Da}) = (1 - c) - \\text{Da} \\, c \\exp(\\gamma T) = 0,\n\\quad\nF_2(T,c,\\text{Da}) = (1 + h)(1 - T) + \\beta \\,\\text{Da}\\, c \\exp(\\gamma T) = 0.\n$$\n这些方程是在无量纲化之后，将（对物种而言）流入减去流出加上反应消耗，以及（对能量而言）冷却减去加热加上反应放热设为零得出的。Frank-Kamenetskii 近似 $r(T,c) = c \\exp(\\gamma T)$ 是对阿伦尼乌斯速率 $r \\propto c \\exp(-E/(R T_{\\text{phys}}))$ 在用合适的无量纲温度偏差表示时的一种经过充分检验的简化；此处 $\\gamma$ 是一个有效活化参数。\n\n为执行弧长延拓，我们考虑解的流形 $\\{(T,c,\\text{Da}) : \\mathbf{F}(T,c,\\text{Da}) = \\mathbf{0}\\}$ 并引入弧长参数 $s$，使得 $(T,c,\\text{Da}) = \\mathbf{u}(s)$ 追踪该曲线。将 $\\mathbf{F}(\\mathbf{u}(s)) = \\mathbf{0}$ 对 $s$ 求导，得到线性关系：\n$$\n\\frac{\\partial \\mathbf{F}}{\\partial (T,c)} \\begin{bmatrix}\\dfrac{dT}{ds} \\\\ \\dfrac{dc}{ds} \\end{bmatrix} + \\frac{\\partial \\mathbf{F}}{\\partial \\text{Da}} \\, \\frac{d\\,\\text{Da}}{ds} = \\mathbf{0}.\n$$\n在一个解点 $\\mathbf{u}_0 = (T_0,c_0,\\text{Da}_0)$ 处，令 $J = \\partial \\mathbf{F}/\\partial (T,c)$ 为 $2\\times 2$ 的雅可比矩阵， $F_{\\text{Da}} = \\partial \\mathbf{F}/\\partial \\text{Da}$ 为 $2\\times 1$ 的参数导数，两者均在 $\\mathbf{u}_0$ 处求值。一种实用的镶边策略是设置 $\\dfrac{d\\,\\text{Da}}{ds} = \\tau_{\\text{Da}} = 1$，从而得到线性系统\n$$\nJ \\begin{bmatrix}\\tau_T \\\\ \\tau_c \\end{bmatrix} = - F_{\\text{Da}},\n$$\n由此可以解出切线的 $(T,c)$ 分量。然后将完整的切线 $\\boldsymbol{\\tau} = (\\tau_T,\\tau_c,\\tau_{\\text{Da}})$ 归一化为单位欧几里得长度：\n$$\n\\boldsymbol{\\tau} \\leftarrow \\frac{\\boldsymbol{\\tau}}{\\|\\boldsymbol{\\tau}\\|_2}.\n$$\n预测步前进到\n$$\n\\mathbf{u}_{\\text{pred}} = \\mathbf{u}_0 + \\Delta s \\, \\boldsymbol{\\tau}.\n$$\n预测点通常会偏离流形，因此我们通过求解一个包含三个未知数 $(T,c,\\text{Da})$ 的三方程增广系统来校正回流形：\n$$\n\\mathbf{G}(\\mathbf{u}) = \n\\begin{bmatrix}\nF_1(T,c,\\text{Da}) \\\\\nF_2(T,c,\\text{Da}) \\\\\ng(T,c,\\text{Da})\n\\end{bmatrix}\n= \\mathbf{0},\n\\quad\ng(T,c,\\text{Da}) = \\boldsymbol{\\tau}^\\top \\big( \\mathbf{u} - \\mathbf{u}_0 \\big) - \\Delta s,\n$$\n这施加了伪弧长约束，以使校正后的解位于一个超平面上，该超平面正交于预测点和基点之间的差值，同时沿切线方向与 $\\mathbf{u}_0$ 的弧长距离为 $\\Delta s$。牛顿法通过以下方式更新 $\\mathbf{u}$\n$$\n\\mathbf{u}^{(k+1)} = \\mathbf{u}^{(k)} - \\left[ \\frac{\\partial \\mathbf{G}}{\\partial \\mathbf{u}}(\\mathbf{u}^{(k)}) \\right]^{-1} \\mathbf{G}(\\mathbf{u}^{(k)}),\n$$\n其中 $\\mathbf{G}$ 的 $3\\times 3$ 雅可比矩阵为\n$$\n\\frac{\\partial \\mathbf{G}}{\\partial \\mathbf{u}} =\n\\begin{bmatrix}\n\\frac{\\partial F_1}{\\partial T}  \\frac{\\partial F_1}{\\partial c}  \\frac{\\partial F_1}{\\partial \\text{Da}} \\\\\n\\frac{\\partial F_2}{\\partial T}  \\frac{\\partial F_2}{\\partial c}  \\frac{\\partial F_2}{\\partial \\text{Da}} \\\\\n\\tau_T  \\tau_c  \\tau_{\\text{Da}}\n\\end{bmatrix}.\n$$\n我们模型的导数由 $F_1$ 和 $F_2$ 的定义得到：\n$$\n\\frac{\\partial F_1}{\\partial T} = - \\text{Da} \\, c \\, \\gamma \\exp(\\gamma T),\n\\quad\n\\frac{\\partial F_1}{\\partial c} = -1 - \\text{Da} \\exp(\\gamma T),\n\\quad\n\\frac{\\partial F_1}{\\partial \\text{Da}} = - c \\exp(\\gamma T),\n$$\n$$\n\\frac{\\partial F_2}{\\partial T} = - (1 + h) + \\beta \\, \\text{Da} \\, c \\, \\gamma \\exp(\\gamma T),\n\\quad\n\\frac{\\partial F_2}{\\partial c} = \\beta \\, \\text{Da} \\exp(\\gamma T),\n\\quad\n\\frac{\\partial F_2}{\\partial \\text{Da}} = \\beta \\, c \\exp(\\gamma T).\n$$\n我们使用带有简单回溯线搜索的牛顿法，以确保在可能的情况下每次迭代都减小范数 $\\|\\mathbf{G}\\|_2$。当 $\\|\\mathbf{G}\\|_2$ 低于一个容差时，校正终止，这表明在弧长约束下已收敛到流形。\n\n对于每个测试用例：\n1. 求解稳态方程以获得 $\\mathbf{u}_0$。在情况B中，扫描 $\\text{Da}$ 并选择 $J$ 的最小奇异值对应的点，旨在找到一个 $J$ 近乎奇异的邻近转折点，这凸显了弧长延拓的优势。\n2. 通过求解 $\\tau_{\\text{Da}} = 1$ 的镶边线性系统来计算切线 $\\boldsymbol{\\tau}$ 并将其归一化。\n3. 预测 $\\mathbf{u}_{\\text{pred}}$，并计算 $\\|\\mathbf{F}(\\mathbf{u}_{\\text{pred}})\\|_2$。\n4. 通过对 $\\mathbf{G}$ 使用牛顿法校正到 $\\mathbf{u}_{\\text{corr}}$，并计算 $\\|\\mathbf{F}(\\mathbf{u}_{\\text{corr}})\\|_2$ 和 $\\|\\mathbf{G}(\\mathbf{u}_{\\text{corr}})\\|_2$。\n\n最后，我们为每个用例报告一个包含七个数字的列表 $[T_{\\text{pred}}, \\text{Da}_{\\text{pred}}, \\|\\mathbf{F}(\\mathbf{u}_{\\text{pred}})\\|_2, T_{\\text{corr}}, \\text{Da}_{\\text{corr}}, \\|\\mathbf{F}(\\mathbf{u}_{\\text{corr}})\\|_2, \\|\\mathbf{G}(\\mathbf{u}_{\\text{corr}})\\|_2]$，每个数字保留六位小数，所有三个用例的列表按 A, B, C 的顺序放在一个单行中。这个过程实践了计算燃烧学中针对转折点曲线的弧长延拓的核心原理，展示了即使在常规参数延拓方法在奇异雅可比矩阵附近失效时，该方法也能稳健地追踪热敏反应器的稳态解。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root\n\n# Model parameters (dimensionless)\ngamma = 3.0  # activation parameter in Frank-Kamenetskii approximation\nbeta = 2.0   # heat-release parameter\nh = 3.0      # heat-removal coefficient\n\ndef reaction_rate(T, c):\n    return c * np.exp(gamma * T)\n\ndef F_vec(T, c, Da):\n    r = reaction_rate(T, c)\n    F1 = (1.0 - c) - Da * r\n    F2 = (1.0 + h) * (1.0 - T) + beta * Da * r\n    return np.array([F1, F2])\n\ndef J_mat(T, c, Da):\n    r = reaction_rate(T, c)\n    dF1_dT = -Da * gamma * r\n    dF1_dc = -1.0 - Da * np.exp(gamma * T)\n    dF2_dT = -(1.0 + h) + beta * Da * gamma * r\n    dF2_dc = beta * Da * np.exp(gamma * T)\n    return np.array([[dF1_dT, dF1_dc],\n                     [dF2_dT, dF2_dc]])\n\ndef F_lambda(T, c, Da):\n    r = reaction_rate(T, c)\n    dF1_dDa = -r\n    dF2_dDa = beta * r\n    return np.array([dF1_dDa, dF2_dDa])\n\ndef solve_steady(Da, T_guess, c_guess):\n    # First attempt with provided guess\n    def fun(z):\n        return F_vec(z[0], z[1], Da)\n    z0 = np.array([T_guess, c_guess])\n    sol = root(fun, z0, method='hybr')\n    if sol.success and np.linalg.norm(sol.fun)  1e-8:\n        return sol.x[0], sol.x[1], True\n    # Second attempt: heuristic guess based on species balance ignoring energy coupling\n    T_guess2 = 1.0\n    c_guess2 = 1.0 / (1.0 + Da * np.exp(gamma * T_guess2))\n    z0b = np.array([T_guess2, c_guess2])\n    sol2 = root(fun, z0b, method='hybr')\n    if sol2.success and np.linalg.norm(sol2.fun)  1e-8:\n        return sol2.x[0], sol2.x[1], True\n    return sol2.x[0], sol2.x[1], False\n\ndef compute_tangent(T0, c0, Da0):\n    J = J_mat(T0, c0, Da0)\n    Fl = F_lambda(T0, c0, Da0)\n    # Set t_lambda = 1 and solve for (t_T, t_c): J * t_x = -F_lambda\n    try:\n        t_x = np.linalg.solve(J, -Fl)\n    except np.linalg.LinAlgError:\n        # Use least squares if singular\n        t_x, *_ = np.linalg.lstsq(J, -Fl, rcond=None)\n    tau_T, tau_c = t_x[0], t_x[1]\n    tau_Da = 1.0\n    tau = np.array([tau_T, tau_c, tau_Da])\n    # Normalize to unit Euclidean norm\n    norm_tau = np.linalg.norm(tau)\n    if norm_tau == 0.0:\n        # Fallback: choose parameter-only direction\n        tau = np.array([0.0, 0.0, 1.0])\n        norm_tau = 1.0\n    tau /= norm_tau\n    return tau\n\ndef predictor(u0, tau, ds):\n    u_pred = u0 + ds * tau\n    T_pred, c_pred, Da_pred = u_pred\n    F_norm = np.linalg.norm(F_vec(T_pred, c_pred, Da_pred))\n    return u_pred, F_norm\n\ndef corrector(u0, u_pred, tau, tol=1e-10, max_iter=25):\n    # Newton corrector for augmented system G = [F; g] = 0 with g = tau^T (u - u0) - ds\n    ds = np.dot(tau, u_pred - u0)  # nominal arc-length step used in constraint\n    u = u_pred.copy()\n    for k in range(max_iter):\n        T, c, Da = u\n        F = F_vec(T, c, Da)\n        g = np.dot(tau, u - u0) - ds\n        G = np.array([F[0], F[1], g])\n        G_norm = np.linalg.norm(G)\n        if G_norm  tol:\n            break\n        # Build Jacobian of G\n        J = J_mat(T, c, Da)\n        Fl = F_lambda(T, c, Da)\n        A = np.zeros((3, 3))\n        A[0, 0:2] = J[0, :]\n        A[1, 0:2] = J[1, :]\n        A[0, 2] = Fl[0]\n        A[1, 2] = Fl[1]\n        A[2, :] = tau\n        # Solve for Newton step\n        try:\n            step = np.linalg.solve(A, G)\n        except np.linalg.LinAlgError:\n            step, *_ = np.linalg.lstsq(A, G, rcond=None)\n        # Backtracking line search to reduce ||G||\n        alpha = 1.0\n        u_new = u - alpha * step\n        G_new = np.array([F_vec(u_new[0], u_new[1], u_new[2])[0],\n                          F_vec(u_new[0], u_new[1], u_new[2])[1],\n                          np.dot(tau, u_new - u0) - ds])\n        while np.linalg.norm(G_new) = G_norm and alpha  1e-6:\n            alpha *= 0.5\n            u_new = u - alpha * step\n            G_new = np.array([F_vec(u_new[0], u_new[1], u_new[2])[0],\n                              F_vec(u_new[0], u_new[1], u_new[2])[1],\n                              np.dot(tau, u_new - u0) - ds])\n        u = u_new\n    # Final norms\n    F_corr = F_vec(u[0], u[1], u[2])\n    g_corr = np.dot(tau, u - u0) - ds\n    F_norm = np.linalg.norm(F_corr)\n    G_norm = np.linalg.norm(np.array([F_corr[0], F_corr[1], g_corr]))\n    return u, F_norm, G_norm\n\ndef find_near_turning(Da_min, Da_max, N, T_start, c_start):\n    Das = np.linspace(Da_min, Da_max, N)\n    best = None\n    # Continuation-like scanning to improve robustness: use previous solution as next guess\n    T_guess, c_guess = T_start, c_start\n    prev_sol = None\n    for Da in Das:\n        T_sol, c_sol, ok = solve_steady(Da, T_guess, c_guess)\n        if not ok:\n            # If failed, reset guesses\n            T_guess, c_guess = 1.0, 1.0 / (1.0 + Da * np.exp(gamma * 1.0))\n            T_sol, c_sol, ok = solve_steady(Da, T_guess, c_guess)\n            if not ok:\n                continue\n        # Compute Jacobian singular values\n        J = J_mat(T_sol, c_sol, Da)\n        svals = np.linalg.svd(J, compute_uv=False)\n        smin = np.min(svals)\n        if (best is None) or (smin  best[0]):\n            best = (smin, Da, T_sol, c_sol)\n        # Update guesses for next Da\n        T_guess, c_guess = T_sol, c_sol\n        prev_sol = (T_sol, c_sol)\n    if best is None:\n        # Fallback: pick middle of range and solve\n        Da_mid = 0.5 * (Da_min + Da_max)\n        T_sol, c_sol, ok = solve_steady(Da_mid, T_start, c_start)\n        if not ok:\n            T_sol, c_sol, _ = solve_steady(Da_mid, 1.0, 1.0 / (1.0 + Da_mid * np.exp(gamma)))\n        best = (np.min(np.linalg.svd(J_mat(T_sol, c_sol, Da_mid), compute_uv=False)),\n                Da_mid, T_sol, c_sol)\n    _, Da_sel, T_sel, c_sel = best\n    return Da_sel, T_sel, c_sel\n\ndef run_case_direct(Da0, T_guess, c_guess, ds):\n    # Solve for operating point\n    T0, c0, ok = solve_steady(Da0, T_guess, c_guess)\n    # Compute tangent, predictor, corrector\n    tau = compute_tangent(T0, c0, Da0)\n    u0 = np.array([T0, c0, Da0])\n    u_pred, Fp_norm = predictor(u0, tau, ds)\n    u_corr, Fc_norm, Gc_norm = corrector(u0, u_pred, tau)\n    # Results: [T_pred, Da_pred, ||F_pred||, T_corr, Da_corr, ||F_corr||, ||G_corr||]\n    return [u_pred[0], u_pred[2], Fp_norm, u_corr[0], u_corr[2], Fc_norm, Gc_norm]\n\ndef run_case_scan(Da_min, Da_max, N, T_start, c_start, ds):\n    Da0, T0, c0 = find_near_turning(Da_min, Da_max, N, T_start, c_start)\n    tau = compute_tangent(T0, c0, Da0)\n    u0 = np.array([T0, c0, Da0])\n    u_pred, Fp_norm = predictor(u0, tau, ds)\n    u_corr, Fc_norm, Gc_norm = corrector(u0, u_pred, tau)\n    return [u_pred[0], u_pred[2], Fp_norm, u_corr[0], u_corr[2], Fc_norm, Gc_norm]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"direct\", {\"Da0\": 0.05, \"T_guess\": 1.0, \"c_guess\": 0.9, \"ds\": 0.02}),\n        (\"scan\",   {\"Da_min\": 0.01, \"Da_max\": 0.5, \"N\": 200, \"T_start\": 1.0, \"c_start\": 0.8, \"ds\": 0.01}),\n        (\"direct\", {\"Da0\": 0.20, \"T_guess\": 1.1, \"c_guess\": 0.5, \"ds\": 1e-4}),\n    ]\n\n    results = []\n    for kind, params in test_cases:\n        if kind == \"direct\":\n            res = run_case_direct(params[\"Da0\"], params[\"T_guess\"], params[\"c_guess\"], params[\"ds\"])\n        else:\n            res = run_case_scan(params[\"Da_min\"], params[\"Da_max\"], params[\"N\"],\n                                params[\"T_start\"], params[\"c_start\"], params[\"ds\"])\n        # Round each float to six decimals\n        res_rounded = [float(f\"{x:.6f}\") for x in res]\n        results.append(res_rounded)\n\n    # Final print statement in the exact required format.\n    # Single line: list of lists with comma-separated floats rounded to six decimals\n    def format_list(lst):\n        return \"[\" + \",\".join(f\"{x:.6f}\" for x in lst) + \"]\"\n    print(\"[\" + \",\".join(format_list(r) for r in results) + \"]\")\n\nsolve()\n```"
        },
        {
            "introduction": "仅仅追踪解曲线通常是不够的，我们往往需要精确地知道转折点的位置。本练习将介绍一种诊断技术，用于检测与转折点的接近程度，并启动一个专门的牛顿求解器来高精度地定位转折点。为了集中于概念本身，我们将使用一个简化的模型来展示如何为我们的延拓引擎增加精确的定位能力。",
            "id": "4007925",
            "problem": "考虑一个与计算燃烧学相关的均相反应器的简化无量纲模型，其中在 Frank–Kamenetskii 近似下，稳态热平衡导出一个非线性残差方程\n$$F(u,\\lambda) = \\lambda e^{u} - u,$$\n其中未知标量 $u \\in \\mathbb{R}$ 代表无量纲温升，标量参数 $\\lambda \\in \\mathbb{R}$ 代表产热与散热的无量纲比率。\n\n$F(u,\\lambda)=0$ 解曲线上的一个转折点（折叠点）满足方程组\n$$F(u,\\lambda) = 0,\\quad \\frac{\\partial F}{\\partial u}(u,\\lambda) = 0.$$\n弧长延拓法用于追踪穿过此类折叠点的解分支。该延拓方法基于基本的隐函数定理以及构造一个满足正交条件的切线方向 $[t_u, t_\\lambda]^T$\n$$\\frac{\\partial F}{\\partial u}(u,\\lambda)\\, t_u + \\frac{\\partial F}{\\partial \\lambda}(u,\\lambda)\\, t_\\lambda = 0,$$\n并进行归一化 $\\sqrt{t_u^2 + t_\\lambda^2} = 1$，然后是一个预测-校正步，该步骤强制施加一个线性化的弧长约束。\n\n开发一个诊断机制，该机制沿延拓分支追踪以下量：\n- 关于 $u$ 的雅可比矩阵的最小奇异值，即绝对值\n$$\\sigma_{\\min} = \\left|\\frac{\\partial F}{\\partial u}(u,\\lambda)\\right|,$$\n- 以及标量\n$$d = w^T \\frac{\\partial F}{\\partial \\lambda}(u,\\lambda),$$\n其中 $w$ 是与 $\\frac{\\partial F}{\\partial u}(u,\\lambda)$ 的最小奇异值相关联的单位左奇异向量。在标量情况下，这简化为 $w = 1$ 和 $d = \\frac{\\partial F}{\\partial \\lambda}(u,\\lambda)$。\n\n当分支接近折叠点时，$\\sigma_{\\min}$ 会变小。为确保折叠点是简单的（非退化的），要求 $|d|$ 保持有界且不为零。你的任务是实现：\n1. 对标量残差 $F(u,\\lambda)$ 进行伪弧长延拓，从一个可行的初始解开始，使用基于切线方向的预测-校正步和一个牛顿校正器，该校正器同时强制 $F(u,\\lambda)=0$ 和线性化弧长条件。\n2. 一个诊断机制，当 $\\sigma_{\\min}$ 低于阈值 $\\sigma_{\\mathrm{th}}$ 并且同时 $|d| \\ge \\gamma_{\\min}$ 时，触发精确的折叠点定位。\n3. 一个精化过程，该过程使用牛顿法求解折叠点方程组\n$$G(u,\\lambda) = \\begin{bmatrix}F(u,\\lambda)\\\\ \\frac{\\partial F}{\\partial u}(u,\\lambda)\\end{bmatrix} = \\begin{bmatrix}\\lambda e^{u} - u\\\\ \\lambda e^{u} - 1\\end{bmatrix} = 0$$\n以精确地定位折叠点。\n\n使用以下基本事实和定义：\n- 雅可比矩阵的元素为 $\\frac{\\partial F}{\\partial u}(u,\\lambda) = \\lambda e^{u} - 1$ 和 $\\frac{\\partial F}{\\partial \\lambda}(u,\\lambda) = e^{u}$。\n- 对于弧长预测器，一个有效的单位切向量是\n$$\\begin{bmatrix}t_u\\\\ t_\\lambda\\end{bmatrix} = \\frac{1}{\\sqrt{\\left(\\frac{\\partial F}{\\partial u}\\right)^2 + \\left(\\frac{\\partial F}{\\partial \\lambda}\\right)^2}} \\begin{bmatrix} -\\frac{\\partial F}{\\partial \\lambda} \\\\ \\frac{\\partial F}{\\partial u} \\end{bmatrix},$$\n它满足与 $F$ 的梯度的正交条件。\n\n你的程序必须：\n- 从 $\\lambda_0 = 0.05$ 和初始猜测值 $u_{\\mathrm{init}} = 0.05$ 开始初始化，使用牛顿法求解 $F(u,\\lambda_0)=0$ 以获得分支上的起始点。\n- 使用固定步长 $\\Delta s$ 和最大步数 $N$ 执行伪弧长延拓；在每一步中，使用基于切线的预测器和一个牛顿校正器，该校正器同时强制 $F(u,\\lambda)=0$ 和线性化弧长约束 $(u-u_p) t_u + (\\lambda - \\lambda_p) t_\\lambda = 0$，其中 $(u_p,\\lambda_p)$ 是预测点。\n- 在每个接受的校正点上，计算 $\\sigma_{\\min} = \\left|\\frac{\\partial F}{\\partial u}(u,\\lambda)\\right|$ 和 $d = w^T \\frac{\\partial F}{\\partial \\lambda}(u,\\lambda)$（对于此标量情况 $w=1$），并且如果 $\\sigma_{\\min} \\le \\sigma_{\\mathrm{th}}$ 和 $|d| \\ge \\gamma_{\\min}$，则触发折叠点精化。\n- 触发后，从当前点开始通过牛顿法求解 $G(u,\\lambda)=0$，以计算折叠点参数 $\\lambda^\\star$ 的一个精确估计值。\n\n测试套件：\n针对以下参数集 $(\\Delta s, N, \\sigma_{\\mathrm{th}}, \\gamma_{\\min})$ 运行算法：\n1. $(0.05, 60, 10^{-4}, 10^{-6})$。\n2. $(0.2, 30, 10^{-3}, 10^{-6})$。\n3. $(0.05, 60, 10^{-6}, 3.0)$。\n\n对于每种情况，返回：\n- 如果触发了精化，则返回精化的折叠点参数 $\\lambda^\\star$（作为浮点数）。\n- 否则，返回浮点数 $-1.0$。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3]”）。由于所有变量都是无量纲的，因此不涉及物理单位。本问题中不使用角度。将所有数值结果表示为浮点数。",
            "solution": "用户提供了一个来自数值分析领域的有效问题陈述，具体涉及应用伪弧长延拓来定位一个源于计算燃烧学模型的非线性系统中的转折点。该问题在科学上是合理的，在数学上是适定的，并且为数值求解提供了所有必要的组成部分。分析将首先详细介绍数学和算法框架，然后是实现。\n\n问题的核心是非线性残差方程：\n$$F(u, \\lambda) = \\lambda e^u - u = 0$$\n其中 $u$ 是无量纲温度，$\\lambda$ 是系统参数。我们的目标是追踪解曲线 $(u(\\lambda), \\lambda)$ 并精确地定位转折点（折叠点），该点由同时满足两个条件来定义：\n$$F(u,\\lambda) = 0 \\quad \\text{and} \\quad \\frac{\\partial F}{\\partial u}(u, \\lambda) = 0$$\n\n数值程序分为三个主要阶段：初始化、弧长延拓和折叠点精化。\n\n**1. 初始化：寻找起始点**\n延拓过程从解曲线上的一个已知点开始。给定初始参数值 $\\lambda_0 = 0.05$ 和状态的初始猜测值 $u_{\\text{init}} = 0.05$。第一步是求解非线性方程 $F(u, \\lambda_0) = 0$ 以得到 $u$，从而找到一个精确的起始点 $(u_0, \\lambda_0)$。这可以通过单变量牛顿法来完成。迭代公式为：\n$$u^{(k+1)} = u^{(k)} - \\frac{F(u^{(k)}, \\lambda_0)}{\\frac{\\partial F}{\\partial u}(u^{(k)}, \\lambda_0)}$$\n其中 $\\frac{\\partial F}{\\partial u}(u, \\lambda) = \\lambda e^u - 1$。迭代从 $u^{(0)} = u_{\\text{init}}$ 开始，并持续进行直到变化量 $|u^{(k+1)} - u^{(k)}|$ 小于预设的容差。收敛解记为 $u_0$。\n\n**2. 伪弧长延拓**\n从 $(u_0, \\lambda_0)$ 开始，我们通过取长度为 $\\Delta s$ 的离散步来追踪解曲线。每一步都包含一个预测器和一个校正器。\n\n**2.1. 切向量计算**\n在曲线上的一个已知点 $(u_k, \\lambda_k)$，我们计算切向量 $[t_u, t_\\lambda]^T$。该切向量与 $F$ 的梯度 $\\nabla F = [\\frac{\\partial F}{\\partial u}, \\frac{\\partial F}{\\partial \\lambda}]^T$ 正交。一个有效的、归一化的切向量由下式给出：\n$$\\begin{bmatrix}t_u\\\\ t_\\lambda\\end{bmatrix} = \\frac{1}{\\sqrt{\\left(\\frac{\\partial F}{\\partial u}\\right)^2 + \\left(\\frac{\\partial F}{\\partial \\lambda}\\right)^2}} \\begin{bmatrix} -\\frac{\\partial F}{\\partial \\lambda} \\\\ \\frac{\\partial F}{\\partial u} \\end{bmatrix}$$\n其中 $\\frac{\\partial F}{\\partial u} = \\lambda_k e^{u_k} - 1$ 且 $\\frac{\\partial F}{\\partial \\lambda} = e^{u_k}$。为确保延拓沿着曲线一致地进行，必须管理切线的方向。对于从 $(u_0, \\lambda_0)$ 开始的第一步，我们要求延拓朝向 $\\lambda$ 增大的方向移动，因为已知折叠点发生在 $\\lambda^\\star = 1/e \\approx 0.36788  \\lambda_0$。因此，我们检查 $t_\\lambda$ 的符号；如果 $t_\\lambda  0$，我们就翻转整个切向量的符号。对于所有后续步骤，我们确保新的切向量 $[t_u, t_\\lambda]_k$ 与前一个切向量 $[t_u, t_\\lambda]_{k-1}$ 的点积为正，必要时翻转其符号。\n\n**2.2. 预测步**\n预测步通过从当前点 $(u_k, \\lambda_k)$ 沿着切线方向移动距离 $\\Delta s$ 来计算一个新的点 $(u_p, \\lambda_p)$：\n$$u_p = u_k + \\Delta s \\cdot t_u$$\n$$\\lambda_p = \\lambda_k + \\Delta s \\cdot t_\\lambda$$\n\n**2.3. 校正步**\n预测点 $(u_p, \\lambda_p)$ 是一个近似值，并不精确地位于解曲线上。校正步精化这个猜测值，以找到曲线上的下一个点 $(u_{k+1}, \\lambda_{k+1})$。这通过使用牛顿法求解一个关于 $(u, \\lambda)$ 的 $2 \\times 2$ 非线性方程组来实现：\n$$ H(u, \\lambda) = \\begin{bmatrix} F(u,\\lambda) \\\\ N(u,\\lambda) \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix} $$\n第一个方程 $F(u, \\lambda) = 0$ 确保该点在解曲线上。第二个方程 $N(u, \\lambda) = (u-u_p) t_u + (\\lambda - \\lambda_p) t_\\lambda = 0$ 是线性化弧长约束。它强制解位于通过 $(u_p, \\lambda_p)$ 且与用于预测步的切向量正交的超平面上（在此二维情况下是一条直线）。\n\n该系统的牛顿迭代从猜测值 $(u_p, \\lambda_p)$ 开始，并通过以下方式更新解向量 $x = [u, \\lambda]^T$：\n$$x^{(j+1)} = x^{(j)} - [J_H(x^{(j)})]^{-1} H(x^{(j)})$$\n系统 $H$ 的雅可比矩阵是：\n$$ J_H(u, \\lambda) = \\begin{bmatrix} \\frac{\\partial F}{\\partial u}  \\frac{\\partial F}{\\partial \\lambda} \\\\ t_u  t_\\lambda \\end{bmatrix} = \\begin{bmatrix} \\lambda e^u - 1  e^u \\\\ t_u  t_\\lambda \\end{bmatrix} $$\n迭代持续进行，直到校正量小于给定容差。收敛点为 $(u_{k+1}, \\lambda_{k+1})$。\n\n**3. 折叠点检测与精化**\n在每个成功计算出的点 $(u_k, \\lambda_k)$，我们评估诊断量以检测其与折叠点的邻近性。\n\n**3.1. 诊断量**\n问题指定追踪两个量：\n- 雅可比矩阵 $\\frac{\\partial F}{\\partial u}$ 的最小奇异值，对于此标量情况，即为 $\\sigma_{\\min} = \\left|\\frac{\\partial F}{\\partial u}(u_k,\\lambda_k)\\right| = |\\lambda_k e^{u_k} - 1|$。当曲线接近折叠点时，$\\frac{\\partial F}{\\partial u} \\to 0$，因此 $\\sigma_{\\min} \\to 0$。\n- 一个标量 $d = w^T \\frac{\\partial F}{\\partial \\lambda}$，其中 $w$ 是对应于 $\\sigma_{\\min}$ 的左奇异向量。对于此标量问题，$w=1$，因此 $d = \\frac{\\partial F}{\\partial \\lambda}(u_k,\\lambda_k) = e^{u_k}$。为使折叠点是简单的（非退化的），此值必须有界且不为零。\n\n**3.2. 精化触发**\n如果给定点 $(u_k, \\lambda_k)$ 同时满足以下两个条件，则触发折叠点精化：\n$$ \\sigma_{\\min} \\le \\sigma_{\\mathrm{th}} \\quad \\text{and} \\quad |d| \\ge \\gamma_{\\min} $$\n其中 $\\sigma_{\\mathrm{th}}$ 和 $\\gamma_{\\min}$ 是指定的阈值。\n\n**3.3. 折叠点精化**\n触发后，我们切换到一种更直接的方法来精确定位折叠点的位置 $(u^\\star, \\lambda^\\star)$。这涉及使用牛顿法求解折叠点的定义方程组：\n$$ G(u, \\lambda) = \\begin{bmatrix} F(u,\\lambda) \\\\ \\frac{\\partial F}{\\partial u}(u,\\lambda) \\end{bmatrix} = \\begin{bmatrix} \\lambda e^u - u \\\\ \\lambda e^u - 1 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix} $$\n此牛顿求解的初始猜测值是触发精化的点 $(u_k, \\lambda_k)$。系统 $G$ 的雅可比矩阵是：\n$$ J_G(u, \\lambda) = \\begin{bmatrix} \\frac{\\partial F}{\\partial u}  \\frac{\\partial F}{\\partial \\lambda} \\\\ \\frac{\\partial^2 F}{\\partial u^2}  \\frac{\\partial^2 F}{\\partial u \\partial \\lambda} \\end{bmatrix} = \\begin{bmatrix} \\lambda e^u - 1  e^u \\\\ \\lambda e^u  e^u \\end{bmatrix} $$\n牛顿迭代进行直到收敛，解的 $\\lambda$ 分量即为精化后的折叠点参数 $\\lambda^\\star$。如果延拓循环完成其最大步数 $N$ 而未触发精化，则返回 $-1.0$ 以表示未能定位折叠点。解析地，折叠点位于 $(u, \\lambda) = (1, 1/e)$，因此精化后的值 $\\lambda^\\star$ 应接近 $1/e \\approx 0.36787944$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        (0.05, 60, 1e-4, 1e-6),\n        (0.2, 30, 1e-3, 1e-6),\n        (0.05, 60, 1e-6, 3.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        ds, N, sigma_th, gamma_min = case\n        lambda_fold = run_case(ds, N, sigma_th, gamma_min)\n        results.append(lambda_fold)\n\n    print(f\"[{','.join(f'{r:.7f}' for r in results)}]\")\n\n\ndef run_case(ds, N, sigma_th, gamma_min, u_init=0.05, lambda_init=0.05, tol=1e-9, max_iter=10):\n    \"\"\"\n    Executes the arc-length continuation and fold refinement for a single parameter set.\n    \"\"\"\n    # Helper functions for the residual and its derivatives\n    F = lambda u, lam: lam * np.exp(u) - u\n    F_u = lambda u, lam: lam * np.exp(u) - 1.0\n    F_l = lambda u, lam: np.exp(u)\n\n    # --- Step 1: Find the initial point (u0, lambda0) ---\n    u_curr = u_init\n    for _ in range(max_iter):\n        residual = F(u_curr, lambda_init)\n        if abs(residual)  tol:\n            break\n        u_curr -= residual / F_u(u_curr, lambda_init)\n    \n    lambda_curr = lambda_init\n    \n    # --- Step 2: Arc-length continuation ---\n    tangent_old = None\n    for step in range(N):\n        # --- Tangent calculation ---\n        fu = F_u(u_curr, lambda_curr)\n        fl = F_l(u_curr, lambda_curr)\n        norm = np.sqrt(fu**2 + fl**2)\n        \n        # Guard against division by zero if we land exactly on the fold\n        if norm  tol:\n            break\n            \n        t_u = -fl / norm\n        t_l = fu / norm\n        tangent = np.array([t_u, t_l])\n\n        # --- Tangent orientation ---\n        # For the first step, ensure we move towards increasing lambda\n        if step == 0 and tangent[1]  0:\n            tangent *= -1.0\n        # For subsequent steps, maintain direction\n        if tangent_old is not None and np.dot(tangent, tangent_old)  0:\n            tangent *= -1.0\n        \n        tangent_old = tangent\n\n        # --- Predictor step ---\n        u_p = u_curr + ds * tangent[0]\n        lambda_p = lambda_curr + ds * tangent[1]\n\n        # --- Corrector step (Newton's method for 2x2 system) ---\n        u_corr, lambda_corr = u_p, lambda_p\n        for _ in range(max_iter):\n            # Form the residual H and Jacobian J_H\n            h1 = F(u_corr, lambda_corr)\n            h2 = (u_corr - u_p) * tangent[0] + (lambda_corr - lambda_p) * tangent[1]\n            H = np.array([h1, h2])\n\n            jh_11 = F_u(u_corr, lambda_corr)\n            jh_12 = F_l(u_corr, lambda_corr)\n            jh_21 = tangent[0]\n            jh_22 = tangent[1]\n            J_H = np.array([[jh_11, jh_12], [jh_21, jh_22]])\n\n            # Solve J_H * delta = -H\n            try:\n                delta = np.linalg.solve(J_H, -H)\n            except np.linalg.LinAlgError:\n                # Corrector fails, stop continuation\n                return -1.0\n                \n            u_corr += delta[0]\n            lambda_corr += delta[1]\n\n            if np.linalg.norm(delta)  tol:\n                break\n        \n        u_curr, lambda_curr = u_corr, lambda_corr\n\n        # --- Step 3: Fold detection ---\n        sigma_min = abs(F_u(u_curr, lambda_curr))\n        d_val = F_l(u_curr, lambda_curr)\n\n        if sigma_min = sigma_th and abs(d_val) = gamma_min:\n            # --- Fold refinement ---\n            u_fold, lambda_fold = u_curr, lambda_curr\n            for _ in range(max_iter):\n                # Form the residual G and Jacobian J_G\n                g1 = F(u_fold, lambda_fold)\n                g2 = F_u(u_fold, lambda_fold)\n                G = np.array([g1, g2])\n\n                # Jacobian of the fold system G\n                jg_11 = F_u(u_fold, lambda_fold)\n                jg_12 = F_l(u_fold, lambda_fold)\n                jg_21 = lambda_fold * np.exp(u_fold) # d(F_u)/du\n                jg_22 = np.exp(u_fold)              # d(F_u)/d_lambda\n                J_G = np.array([[jg_11, jg_12], [jg_21, jg_22]])\n\n                try:\n                    delta_fold = np.linalg.solve(J_G, -G)\n                except np.linalg.LinAlgError:\n                    return -1.0\n\n                u_fold += delta_fold[0]\n                lambda_fold += delta_fold[1]\n\n                if np.linalg.norm(delta_fold)  tol:\n                    return lambda_fold\n            \n            # If refinement Newton loop finishes without converging, return last value\n            return lambda_fold\n\n    # If loop finishes without triggering refinement\n    return -1.0\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "实际问题的解曲线其曲率变化很大，采用固定的步长效率低下，甚至可能在曲率剧烈变化的区域失败。本练习将为我们的延拓引擎添加一个“智能”控制系统。我们将实现一个比例-积分（PI）控制器来自动调整步长，以期将校正迭代次数维持在一个目标值，从而使延拓过程在处理具有尖锐转折点的刚性问题时更加鲁棒和高效。",
            "id": "4007914",
            "problem": "考虑一个理想搅拌反应系统（连续搅拌釜式反应器），其中发生不可逆、一级、放热反应，并采用常密度和常热容假设。在无量纲化形式中，对于给定的 Damköhler 数 $\\lambda$，无量纲浓度 $x$ 和无量纲温度 $y$ 的稳态平衡由以下非线性代数方程组建模：\n$$\nF(x,y,\\lambda) =\n\\begin{bmatrix}\n(1 - x) - \\lambda\\,x\\,\\exp(\\gamma\\,y) \\\\\n(1 - y) + \\beta\\,\\lambda\\,x\\,\\exp(\\gamma\\,y) - h\\,(y - y_c)\n\\end{bmatrix} = \\mathbf{0},\n$$\n其中 $\\beta$ 是无量纲放热参数，$\\gamma$ 是源于 Arrhenius 依赖关系的无量纲活化参数， $h$ 是无量纲热损失系数，$y_c$ 是无量纲冷却剂温度。对于足够大的 $\\beta$ 和 $\\gamma$ 以及适中的 $h$，该模型会在 $(x,y,\\lambda)$ 空间中产生一个 S 形平衡流形，其转折点（折叠点）与点燃和熄灭现象相关。您的任务是实现一个鲁棒的伪弧长延拓算法来追踪此转折点曲线，并使用一个比例-积分控制器来调节弧长步长 $\\Delta s$，以达到一个固定的校正器牛顿迭代次数目标。\n\n从牛顿法在 $\\lambda_0$ 处找到的初始稳态开始，使用带有标准超平面约束的预测-校正伪弧长延拓方法，沿解曲线在 $(x,y,\\lambda)$ 空间中前进。在每个延拓步中，执行以下操作：\n- 使用单位切线 $\\mathbf{t} = \\left[\\dfrac{dx}{ds}, \\dfrac{dy}{ds}, \\dfrac{d\\lambda}{ds}\\right]^T$ 进行基于切线的预测。\n- 对由平衡方程 $F(x,y,\\lambda)=\\mathbf{0}$ 和由前一步切线定义的超平面约束组成的增广系统进行牛顿校正。\n\n使用比例-积分定律调节步长 $\\Delta s$，以达到目标校正器牛顿迭代次数 $n_\\mathrm{targ}$。设 $e_k = n_k - n_\\mathrm{targ}$ 为第 $k$ 个已接受步的迭代次数误差，并设 $E_k$ 为 $e_k$ 的累积积分。通过 $\\Delta s \\leftarrow \\Delta s \\,\\exp(-k_p\\,e_k - k_i\\,E_k)$ 的乘法方式更新步长，其中 $k_p$ 和 $k_i$ 是增益，并将 $\\Delta s$ 限制在 $[\\Delta s_{\\min}, \\Delta s_{\\max}]$ 范围内。如果校正器在 $n_{\\max}$ 次迭代内未能收敛或违反了残差单调下降的保障措施，则拒绝该步，将步长缩减为 $\\Delta s \\leftarrow r_\\mathrm{fail}\\,\\Delta s$，并从最后一个已接受的状态重试；如果 $\\Delta s  \\Delta s_{\\min}$，则提前终止运行。\n\n数值要求：\n- 实现关于 $(x,y)$ 和 $\\lambda$ 的 $F(x,y,\\lambda)$ 的解析雅可比矩阵，并使用直接线性求解器求解加边线性系统。\n- 对校正更新量使用线搜索阻尼，以确保增广残差范数不增，在宣布失败前最多可回溯有限次数，每次回溯因子为 $1/2$。\n- 将预测器切线归一化至单位弧长，并通过翻转其符号使其与连续接受点之间的割线对齐，以保持一致的方向。\n\n测试套件：\n实现一个单一程序，该程序执行三个案例，使用以下参数并报告量化指标。所有量均为无量纲。\n\n所有案例的通用数值设置：\n- 初始 Damköhler 数 $\\lambda_0 = 0.01$。\n- 初始稳态的初始猜测值 $(x,y) = (1,0)$。\n- 平衡方程的牛顿法容差 $\\|F\\|_2 \\le 10^{-10}$，超平面残差容差 $\\le 10^{-12}$。\n- 最大校正器牛顿迭代次数 $n_{\\max} = 20$。\n- 阻尼回溯限制 $n_{\\mathrm{ls}} = 10$。\n- 初始步长 $\\Delta s_0 = 0.02$，界限为 $\\Delta s_{\\min} = 10^{-4}$ 和 $\\Delta s_{\\max} = 0.2$。\n- 失败缩减因子 $r_{\\mathrm{fail}} = 0.5$。\n- 尝试接受的延拓步数 $N_{\\mathrm{acc}} = 40$（如果 $\\Delta s  \\Delta s_{\\min}$ 则提前终止）。\n\n案例 A（基准平滑S形曲线）：\n- 参数 $(\\beta,\\gamma,h,y_c) = (8,6,1,0)$。\n- 控制器目标 $n_\\mathrm{targ} = 4$，增益 $(k_p,k_i) = (0.25,0.05)$。\n- 运行期间无参数变化。\n- 要求的输出指标 $m_A$：已接受步的校正器迭代次数与目标值的最大绝对偏差，\n$$\nm_A = \\max_{1 \\le k \\le K} \\left| n_k - n_\\mathrm{targ} \\right|,\n$$\n其中 $K$ 是已接受的步数。\n\n案例 B（曲率突然增加）：\n- 从 $(\\beta,\\gamma,h,y_c) = (8,6,1,0)$ 开始。\n- 控制器目标 $n_\\mathrm{targ} = 4$，增益 $(k_p,k_i) = (0.25,0.05)$。\n- 在恰好 $k_{\\mathrm{sw}} = 12$ 个已接受的步之后，瞬时将活化参数更改为 $\\gamma \\leftarrow 9$ 并在此后保持不变；所有其他参数不变。\n- 要求的输出指标 $m_B$：在参数改变后的接下来 $K_{\\mathrm{win}} = 8$ 个已接受步中，迭代次数超出目标值的最大正向过冲，\n$$\nm_B = \\max_{k_{\\mathrm{sw}}  k \\le \\min(k_{\\mathrm{sw}}+K_{\\mathrm{win}},K)} \\max\\!\\left(0,\\, n_k - n_\\mathrm{targ} \\right).\n$$\n\n案例 C（更尖锐的折叠点，更严格的调节压力测试）：\n- 参数 $(\\beta,\\gamma,h,y_c) = (10,9,0.5,0)$。\n- 控制器目标 $n_\\mathrm{targ} = 3$，增益 $(k_p,k_i) = (0.2,0.04)$。\n- 运行期间无参数变化。\n- 要求的输出指标 $m_C$：在接受或提前终止之前，因校正器不收敛而被拒绝的总步数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，顺序为 $[m_A,m_B,m_C]$。每个指标必须打印为 Python 字面量数字，其中 $m_A$ 和 $m_B$ 为浮点数，$m_C$ 为整数。不应打印任何其他文本。",
            "solution": "用户提供的问题是有效的，因为它构成了一个适定、有科学依据且严格定义的数值任务。它描述了应用伪弧长延拓方法来追踪连续搅拌釜式反应器（CSTR）经典模型的平衡流形，这是化学工程和分岔分析中的一个标准问题。所有必要的参数、初始条件和数值规格都已明确无误地提供。\n\n我们的目标是追踪非线性代数方程组 $F(\\mathbf{z}) = \\mathbf{0}$ 的解曲线 $\\mathbf{z}(s) = [x(s), y(s), \\lambda(s)]^T$，其中 $s$ 是弧长。该方程组定义为：\n$$\nF(x,y,\\lambda) =\n\\begin{bmatrix}\nF_1 \\\\\nF_2\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n(1 - x) - \\lambda\\,x\\,\\exp(\\gamma\\,y) \\\\\n(1 - y) + \\beta\\,\\lambda\\,x\\,\\exp(\\gamma\\,y) - h\\,(y - y_c)\n\\end{bmatrix} = \\mathbf{0}\n$$\n标准的参数延拓法（其中 $\\lambda$ 是自变量）在转折点处会失效，因为在这些点上解分支会折回。在这些点，系统关于状态变量 $(x, y)$ 的雅可比矩阵（记为 $J_{F,\\mathbf{v}}$）会变得奇异，并且解不再是 $\\lambda$ 的单值函数。伪弧长延拓通过将曲线用弧长 $s$ 参数化，并将 $\\lambda$ 视为一个因变量（状态向量 $\\mathbf{z} = [x, y, \\lambda]^T$ 的一部分），从而解决了这个问题。该算法通过一系列预测-校正步骤进行。\n\n首先，我们必须在解曲线上找到一个起始点。对于给定的初始 Damköhler 数 $\\lambda_0 = 0.01$，我们从猜测值 $(x,y)=(1,0)$ 开始，使用带有线搜索阻尼的标准牛顿-拉夫逊方法求解系统 $F(x, y, \\lambda_0) = \\mathbf{0}$ 以得到 $(x_0, y_0)$。这会产生初始状态 $\\mathbf{z}_0 = [x_0, y_0, \\lambda_0]^T$。\n\n延拓算法的核心是一个迭代循环。在每个已接受的步骤 $k$（在状态 $\\mathbf{z}_k$），我们执行以下操作：\n\n**1. 预测步 (Predictor Step)**\n预测步从当前点 $\\mathbf{z}_k$ 沿曲线的切线方向 $\\mathbf{t}_k$ 进行外插，以找到一个试验点 $\\mathbf{z}_{k+1}^p$。\n$$\n\\mathbf{z}_{k+1}^p = \\mathbf{z}_k + \\Delta s_k \\, \\mathbf{t}_k\n$$\n其中 $\\Delta s_k$ 是当前的弧长步长。切向量 $\\mathbf{t}_k$ 是一个单位向量，它张成了在 $\\mathbf{z}_k$ 处评估的完整雅可比矩阵 $J_{F,\\mathbf{z}} = \\left[ \\frac{\\partial F}{\\partial x} \\quad \\frac{\\partial F}{\\partial y} \\quad \\frac{\\partial F}{\\partial \\lambda} \\right]$ 的一维零空间。\n$$\nJ_{F,\\mathbf{z}}(\\mathbf{z}_k) \\, \\mathbf{t}_k = \\mathbf{0}, \\quad \\|\\mathbf{t}_k\\|_2 = 1\n$$\n这个向量可以通过对 $J_{F,\\mathbf{z}}$ 进行奇异值分解 (SVD) 来稳健地计算，`scipy.linalg.null_space` 为此提供了一个便捷的实现。切向量的符号是任意的；为确保沿曲线的一致遍历，我们强制其方向。对于第一步 ($k=0$)，我们定向 $\\mathbf{t}_0$ 使其 $\\lambda$ 分量为正 ($t_\\lambda  0$)。对于所有后续步骤 ($k  0$)，我们定向 $\\mathbf{t}_k$ 以使其在上一步的割线向量上的投影为正，即 $\\mathbf{t}_k \\cdot (\\mathbf{z}_k - \\mathbf{z}_{k-1})  0$。\n\n**2. 校正步 (Corrector Step)**\n预测点 $\\mathbf{z}_{k+1}^p$ 偏离了真实的解流形。校正步通过求解一个增广方程组，找到一个满足控制方程的邻近点 $\\mathbf{z}_{k+1}$。该系统包括原始的平衡方程和一个约束条件，该约束强制校正后的点位于一个通过预测点 $\\mathbf{z}_{k+1}^p$ 且与切向量 $\\mathbf{t}_k$ 正交的超平面上。增广系统 $G(\\mathbf{z}) = \\mathbf{0}$ 为：\n$$\nG(\\mathbf{z}) =\n\\begin{bmatrix}\nF(x,y,\\lambda) \\\\\nN(\\mathbf{z})\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n(1 - x) - \\lambda\\,x\\,\\exp(\\gamma\\,y) \\\\\n(1 - y) + \\beta\\,\\lambda\\,x\\,\\exp(\\gamma\\,y) - h\\,(y - y_c) \\\\\n\\mathbf{t}_k \\cdot (\\mathbf{z} - \\mathbf{z}_{k+1}^p)\n\\end{bmatrix}\n= \\mathbf{0}\n$$\n这个 $(3 \\times 3)$ 的系统从猜测值 $\\mathbf{z}^{(0)} = \\mathbf{z}_{k+1}^p$ 开始，对 $\\mathbf{z}$ 进行迭代求解。增广系统的雅可比矩阵 $J_G$ 是一个加边矩阵：\n$$\nJ_G =\n\\begin{bmatrix}\nJ_{F,\\mathbf{z}} \\\\\n\\mathbf{t}_k^T\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\frac{\\partial F_1}{\\partial x}  \\frac{\\partial F_1}{\\partial y}  \\frac{\\partial F_1}{\\partial \\lambda} \\\\\n\\frac{\\partial F_2}{\\partial x}  \\frac{\\partial F_2}{\\partial y}  \\frac{\\partial F_2}{\\partial \\lambda} \\\\\nt_x  t_y  t_\\lambda\n\\end{bmatrix}\n$$\n牛顿更新量 $\\delta \\mathbf{z}^{(j)}$ 通过求解线性系统 $J_G(\\mathbf{z}^{(j)}) \\, \\delta \\mathbf{z}^{(j)} = -G(\\mathbf{z}^{(j)})$ 得到。为确保稳健收敛，更新量通过线搜索进行阻尼：$\\mathbf{z}^{(j+1)} = \\mathbf{z}^{(j)} + \\alpha \\, \\delta \\mathbf{z}^{(j)}$，其中阻尼因子 $\\alpha \\in (0, 1]$ 通过回溯选择，以确保增广残差的范数减小，即 $\\|G(\\mathbf{z}^{(j+1)})\\|_2  \\|G(\\mathbf{z}^{(j)})\\|_2$。如果在 $n_{\\max}$ 次迭代内，$\\|F\\|_2$ 和 $|N|$ 均低于各自的容差，则校正器成功收敛。\n\n雅可比矩阵 $J_{F,\\mathbf{z}}$ 所需的解析导数为：\n令 $R = \\lambda x \\exp(\\gamma y)$，我们有：\n$\\frac{\\partial F_1}{\\partial x} = -1 - \\lambda \\exp(\\gamma y)$，$\\frac{\\partial F_1}{\\partial y} = -\\gamma R$，$\\frac{\\partial F_1}{\\partial \\lambda} = -x \\exp(\\gamma y)$\n$\\frac{\\partial F_2}{\\partial x} = \\beta \\lambda \\exp(\\gamma y)$，$\\frac{\\partial F_2}{\\partial y} = -1 + \\beta \\gamma R - h$，$\\frac{\\partial F_2}{\\partial \\lambda} = \\beta x \\exp(\\gamma y)$\n\n**3. 步长控制与失败处理 (Step-Size Control and Failure Handling)**\n为了有效地遍历解曲线，穿过高曲率和低曲率的区域，弧长步长 $\\Delta s$ 需要自适应调整。一个比例-积分 (PI) 控制器会调整 $\\Delta s$ 以维持一个目标校正器迭代次数 $n_\\mathrm{targ}$。在一个步骤 $k$ 以 $n_k$ 次迭代成功被接受后，计算误差 $e_k = n_k - n_\\mathrm{targ}$ 及其累积积分 $E_k = E_{k-1} + e_k$。下一步的步长通过乘法方式更新：\n$$\n\\Delta s_{k+1} = \\Delta s_k \\exp(-k_p e_k - k_i E_k)\n$$\n然后将结果限制在区间 $[\\Delta s_{\\min}, \\Delta s_{\\max}]$ 内。如果校正器未能收敛，则拒绝该步，将步长按因子 $r_{\\mathrm{fail}}$ 缩小，并从上一个接受的点 $\\mathbf{z}_k$ 重试。如果 $\\Delta s$ 低于 $\\Delta s_{\\min}$，则提前终止延拓。这种自适应方案在计算效率和鲁棒性之间提供了平衡。",
            "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to execute the three test cases and print the results.\n    \"\"\"\n\n    common_settings = {\n        'lambda0': 0.01,\n        'initial_guess': np.array([1.0, 0.0]),\n        'tol_F': 1e-10,\n        'tol_N': 1e-12,\n        'n_max': 20,\n        'n_ls': 10,\n        'ds0': 0.02,\n        'ds_min': 1e-4,\n        'ds_max': 0.2,\n        'r_fail': 0.5,\n        'N_acc': 40,\n    }\n\n    # Case A\n    case_A_params = {\n        'case_id': 'A',\n        'beta': 8.0, 'gamma': 6.0, 'h': 1.0, 'yc': 0.0,\n        'n_targ': 4, 'kp': 0.25, 'ki': 0.05,\n    }\n    params_A = {**common_settings, **case_A_params}\n    result_A = run_case(params_A)\n    m_A = compute_metric_A(result_A, params_A['n_targ'])\n\n    # Case B\n    case_B_params = {\n        'case_id': 'B',\n        'beta': 8.0, 'gamma': 6.0, 'h': 1.0, 'yc': 0.0,\n        'n_targ': 4, 'kp': 0.25, 'ki': 0.05,\n        'k_sw': 12, 'gamma_new': 9.0, 'K_win': 8,\n    }\n    params_B = {**common_settings, **case_B_params}\n    result_B = run_case(params_B)\n    m_B = compute_metric_B(result_B, params_B['n_targ'], params_B['k_sw'], params_B['K_win'])\n\n    # Case C\n    case_C_params = {\n        'case_id': 'C',\n        'beta': 10.0, 'gamma': 9.0, 'h': 0.5, 'yc': 0.0,\n        'n_targ': 3, 'kp': 0.2, 'ki': 0.04,\n    }\n    params_C = {**common_settings, **case_C_params}\n    result_C = run_case(params_C)\n    m_C = compute_metric_C(result_C)\n\n    print(f\"[{float(m_A)},{float(m_B)},{int(m_C)}]\")\n\ndef F_vec(z, p):\n    \"\"\"Computes the residual vector F of the CSTR equations.\"\"\"\n    x, y, lam = z\n    R = lam * x * np.exp(p['gamma'] * y)\n    F1 = (1.0 - x) - R\n    F2 = (1.0 - y) + p['beta'] * R - p['h'] * (y - p['yc'])\n    return np.array([F1, F2])\n\ndef J_F_z(z, p):\n    \"\"\"Computes the Jacobian of F with respect to z = [x, y, lambda].\"\"\"\n    x, y, lam = z\n    if x == 0.0 or lam == 0.0: # Avoid division by zero\n        # This case is physically unlikely on the solution branch\n        # but good for robustness if the solver strays.\n        exp_gy = np.exp(p['gamma'] * y)\n        R = lam * x * exp_gy\n        dR_dx = lam * exp_gy\n        dR_dy = lam * x * p['gamma'] * exp_gy\n        dR_dlam = x * exp_gy\n    else:\n        R = lam * x * np.exp(p['gamma'] * y)\n        dR_dx = R / x\n        dR_dy = p['gamma'] * R\n        dR_dlam = R / lam\n\n    J11 = -1.0 - dR_dx\n    J12 = -dR_dy\n    J13 = -dR_dlam\n    \n    J21 = p['beta'] * dR_dx\n    J22 = -1.0 + p['beta'] * dR_dy - p['h']\n    J23 = p['beta'] * dR_dlam\n\n    return np.array([[J11, J12, J13], [J21, J22, J23]])\n\ndef find_initial_point(p):\n    \"\"\"Finds the initial steady state (x, y) at lambda0 using Newton's method.\"\"\"\n    lam0 = p['lambda0']\n    v = p['initial_guess'].copy()\n\n    for _ in range(p['n_max']):\n        z_fixed_lam = np.array([v[0], v[1], lam0])\n        F = F_vec(z_fixed_lam, p)\n        if linalg.norm(F)  p['tol_F']:\n            return np.array([v[0], v[1], lam0])\n        \n        J_Fv = J_F_z(z_fixed_lam, p)[:, :2]\n        delta_v = linalg.solve(J_Fv, -F)\n        \n        alpha = 1.0\n        norm_F = linalg.norm(F)\n        for _ in range(p['n_ls']):\n            v_new = v + alpha * delta_v\n            z_new = np.array([v_new[0], v_new[1], lam0])\n            if linalg.norm(F_vec(z_new, p))  norm_F:\n                v = v_new\n                break\n            alpha /= 2.0\n        else: # Line search failed\n            return None\n    return None\n\ndef run_case(p):\n    \"\"\"Performs the pseudo-arclength continuation for a given set of parameters.\"\"\"\n    z_current = find_initial_point(p)\n    if z_current is None:\n        return {'n_iters_list': [], 'rejected_steps': 0, 'total_accepted': 0}\n\n    # Make a mutable copy of parameters for Case B\n    p_run = p.copy()\n\n    accepted_steps = 0\n    rejected_steps = 0\n    n_iters_list = []\n    \n    ds = p['ds0']\n    E_integral = 0.0\n    z_previous = None\n\n    while accepted_steps  p['N_acc']:\n        if p.get('case_id') == 'B' and accepted_steps == p.get('k_sw'):\n             p_run['gamma'] = p['gamma_new']\n\n        # Retry loop for the current step\n        step_accepted = False\n        while not step_accepted:\n            J_fz = J_F_z(z_current, p_run)\n            tangent = linalg.null_space(J_fz).ravel()\n            \n            # Orient tangent\n            if accepted_steps == 0:\n                if tangent[2]  0:\n                    tangent = -tangent\n            else:\n                secant = z_current - z_previous\n                if np.dot(tangent, secant)  0:\n                    tangent = -tangent\n\n            z_pred = z_current + ds * tangent\n            \n            # Newton corrector loop\n            z_corr = z_pred.copy()\n            converged = False\n            n_iter = 0\n            for i in range(p['n_max']):\n                n_iter = i + 1\n                F_res = F_vec(z_corr, p_run)\n                N_res = np.dot(tangent, z_corr - z_pred)\n                \n                if linalg.norm(F_res)  p['tol_F'] and abs(N_res)  p['tol_N']:\n                    converged = True\n                    break\n\n                G_res = np.append(F_res, N_res)\n                J_G = np.vstack([J_F_z(z_corr, p_run), tangent])\n                \n                # Check for singular Jacobian\n                if abs(linalg.det(J_G))  1e-12: break\n\n                delta_z = linalg.solve(J_G, -G_res)\n                \n                # Line search\n                alpha = 1.0\n                norm_G = linalg.norm(G_res)\n                ls_success = False\n                for _ in range(p['n_ls']):\n                    z_next = z_corr + alpha * delta_z\n                    G_next = np.append(F_vec(z_next, p_run), np.dot(tangent, z_next - z_pred))\n                    if linalg.norm(G_next)  norm_G:\n                        z_corr = z_next\n                        ls_success = True\n                        break\n                    alpha /= 2.0\n                \n                if not ls_success:\n                    break\n            \n            if converged:\n                step_accepted = True\n                n_iters_list.append(n_iter)\n                \n                z_previous = z_current\n                z_current = z_corr\n                accepted_steps += 1\n                \n                # PI Controller update\n                error = n_iter - p['n_targ']\n                E_integral += error\n                ds_factor = np.exp(-p['kp'] * error - p['ki'] * E_integral)\n                ds = np.clip(ds * ds_factor, p['ds_min'], p['ds_max'])\n            else: # Corrector failed\n                rejected_steps += 1\n                ds *= p['r_fail']\n                if ds  p['ds_min']:\n                    break # Terminate run\n        \n        if ds  p['ds_min']:\n            break # Terminate from outer loop\n\n    return {\n        'n_iters_list': n_iters_list,\n        'rejected_steps': rejected_steps,\n        'total_accepted': accepted_steps,\n    }\n\ndef compute_metric_A(result, n_targ):\n    n_iters = np.array(result['n_iters_list'])\n    if len(n_iters) == 0:\n        return 0.0\n    return np.max(np.abs(n_iters - n_targ))\n\ndef compute_metric_B(result, n_targ, k_sw, K_win):\n    n_iters = result['n_iters_list']\n    K = result['total_accepted']\n    if K = k_sw:\n        return 0.0\n    \n    window = n_iters[k_sw : min(k_sw + K_win, K)]\n    if not window:\n        return 0.0\n\n    overshoots = np.array(window) - n_targ\n    return np.max(np.maximum(0, overshoots))\n\ndef compute_metric_C(result):\n    return result['rejected_steps']\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}