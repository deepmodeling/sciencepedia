{
    "hands_on_practices": [
        {
            "introduction": "并行计算的一个主要目标是使用更多处理器来更快地解决固定规模的问题，这一过程被称为“强标度”（strong scaling）。然而，性能的提升很少是完美的线性关系。本练习旨在通过一个实际案例，演示如何量化和分析并行计算中的性能瓶颈。通过将总运行时间分解为可并行计算、通信、负载不均衡和串行部分，你将学会计算加速比和效率，并识别出限制可扩展性的关键因素，这直接关系到著名的阿姆达尔定律（Amdahl's Law）的实际应用。",
            "id": "4030436",
            "problem": "一个反应流求解器推进一个固定的工作负载，该工作负载包括在一个固定的空间网格上进行的 $N_{\\mathrm{t}}$ 个时间步的详细化学、可压缩流模拟。空间离散化和化学机理保持不变，因此总工作量不随计算节点数的增加而改变。该代码使用消息传递接口（MPI）进行区域分解和最近邻通信（晕圈交换），并在化学例程中偶尔进行全局归约。\n\n对于这个固定的工作负载，在不同计算节点数 $P$ 下测量的壁钟时间被分解为四类：一个可并行的计算部分，主要由每个单元的化学和输运主导；一个由 MPI 晕圈交换和全局归约引起的通信部分；一个由同步点的负载不平衡引起的空闲时间部分；以及一个目前在没有并行化的情况下执行的化学雅可比预条件子装配例程中的串行部分。总时间 $T(P)$ 及其分解的测量结果如下：\n\n- 在 $P=1$ 时：$T(1)=1810\\,\\mathrm{s}$，由 $1740\\,\\mathrm{s}$ 的可并行化计算部分、$10\\,\\mathrm{s}$ 的通信、$0\\,\\mathrm{s}$ 的负载不平衡和 $60\\,\\mathrm{s}$ 的串行化学例程组成。\n- 在 $P=2$ 时：$T(2)=960\\,\\mathrm{s}$，其中可并行化计算部分测量为相对于 $P=1$ 时的一半，通信为 $25\\,\\mathrm{s}$，负载不平衡为 $5\\,\\mathrm{s}$，以及相同的 $60\\,\\mathrm{s}$ 串行化学例程。\n- 在 $P=4$ 时：$T(4)=545\\,\\mathrm{s}$，其中可并行化计算部分测量为 $P=1$ 时的四分之一，通信为 $40\\,\\mathrm{s}$，负载不平衡为 $10\\,\\mathrm{s}$，以及相同的 $60\\,\\mathrm{s}$ 串行化学例程。\n- 在 $P=8$ 时：$T(8)=347.5\\,\\mathrm{s}$，其中可并行化计算部分测量为 $P=1$ 时的八分之一，通信为 $55\\,\\mathrm{s}$，负载不平衡为 $15\\,\\mathrm{s}$，以及相同的 $60\\,\\mathrm{s}$ 串行化学例程。\n- 在 $P=16$ 时：$T(16)=258.75\\,\\mathrm{s}$，其中可并行化计算部分测量为 $P=1$ 时的十六分之一，通信为 $70\\,\\mathrm{s}$，负载不平衡为 $20\\,\\mathrm{s}$，以及相同的 $60\\,\\mathrm{s}$ 串行化学例程。\n- 在 $P=32$ 时：$T(32)=224.375\\,\\mathrm{s}$，其中可并行化计算部分测量为 $P=1$ 时的三十二分之一，通信为 $85\\,\\mathrm{s}$，负载不平衡为 $25\\,\\mathrm{s}$，以及相同的 $60\\,\\mathrm{s}$ 串行化学例程。\n- 在 $P=64$ 时：$T(64)=217.1875\\,\\mathrm{s}$，其中可并行化计算部分测量为 $P=1$ 时的六十四分之一，通信为 $100\\,\\mathrm{s}$，负载不平衡为 $30\\,\\mathrm{s}$，以及相同的 $60\\,\\mathrm{s}$ 串行化学例程。\n\n使用固定工作负载下强标度的加速比和效率的第一性原理定义，确定在 $P=64$ 时的强标度效率。将效率表示为一个无单位的纯数，并将您的答案四舍五入到四位有效数字。\n\n此外，在您的推理中，请从并行程序的基本性能建模概念出发，指出在 $P=64$ 时哪些测量部分主导了效率损失，并解释原因。",
            "solution": "首先对问题进行验证，以确保其科学上合理、良构且自洽。\n\n### 步骤1：提取已知条件\n- 一个固定的工作负载（强标度）在 $P$ 个计算节点上运行。\n- 总执行时间 $T(P)$ 是四个部分之和：可并行化计算时间 $T_{\\text{compute,parallel}}(P)$、通信时间 $T_{\\text{comm}}(P)$、因负载不平衡导致的空闲时间 $T_{\\text{idle}}(P)$ 和串行部分时间 $T_{\\text{serial}}(P)$。\n- 可并行化计算部分完美标度：$T_{\\text{compute,parallel}}(P) = T_{\\text{compute,parallel}}(1) / P$。\n- 串行部分是恒定的：对于所有 $P$，$T_{\\text{serial}}(P) = 60\\,\\mathrm{s}$。\n- $P=1$ 时的数据：$T(1)=1810\\,\\mathrm{s}$，其中 $T_{\\text{compute,parallel}}(1)=1740\\,\\mathrm{s}$，$T_{\\text{comm}}(1)=10\\,\\mathrm{s}$，$T_{\\text{idle}}(1)=0\\,\\mathrm{s}$，$T_{\\text{serial}}(1)=60\\,\\mathrm{s}$。\n- $P=64$ 时的数据：$T(64)=217.1875\\,\\mathrm{s}$，其中 $T_{\\text{compute,parallel}}(64) = T_{\\text{compute,parallel}}(1)/64$，$T_{\\text{comm}}(64)=100\\,\\mathrm{s}$，$T_{\\text{idle}}(64)=30\\,\\mathrm{s}$，$T_{\\text{serial}}(64)=60\\,\\mathrm{s}$。\n- 其他数据点（$P=2, 4, 8, 16, 32$）为上下文和一致性而提供。\n\n### 步骤2：使用提取的已知条件进行验证\n检查问题陈述的有效性。\n- **科学依据**：该问题使用了一个标准的、简化的并行应用程序性能模型，与 Amdahl 定律和高性能计算中的开销分析等概念一致。时间分量的描述行为（计算部分标度、串行部分恒定、开销增加）对于区域分解模拟来说在物理上是现实的。上下文是计算燃烧学，这是恰当的。该问题在科学上是合理的。\n- **良构性**：该问题要求根据所提供的数据计算一个特定的、可计算的量（强标度效率）。定义是标准的。存在唯一解。\n- **一致性**：每个数据点的总时间是其各部分之和。对于 $P=1$：$1740 + 10 + 0 + 60 = 1810$，与 $T(1)$ 匹配。对于 $P=64$：$T_{\\text{compute,parallel}}(64) = 1740/64 = 27.1875$。总和为 $27.1875 + 100 + 30 + 60 = 217.1875$，与 $T(64)$ 匹配。数据内部是一致的。\n- **完整性**：计算所需效率的所有必要数据均已提供。\n\n### 步骤3：结论与行动\n问题有效。将提供解答。\n\n### 解题推导\n\n对于固定规模问题，强标度加速比 $S(P)$ 定义为在单个处理器上执行的时间 $T(1)$ 与在 $P$ 个处理器上执行的时间 $T(P)$ 之比。\n$$S(P) = \\frac{T(1)}{T(P)}$$\n强标度效率 $E(P)$ 衡量了相对于理想线性加速比，并行资源被有效利用的程度。它定义为加速比除以处理器数量 $P$。\n$$E(P) = \\frac{S(P)}{P} = \\frac{T(1)}{P \\cdot T(P)}$$\n问题要求计算在 $P=64$ 时的强标度效率。给定的数据值为：\n- 基准执行时间：$T(1) = 1810\\,\\mathrm{s}$\n- 在 $P=64$ 个节点上的执行时间：$T(64) = 217.1875\\,\\mathrm{s}$\n- 节点数：$P = 64$\n\n将这些值代入效率公式：\n$$E(64) = \\frac{1810}{64 \\cdot 217.1875}$$\n首先，我们计算分母中的乘积：\n$$64 \\cdot 217.1875 = 13900$$\n现在，我们计算效率：\n$$E(64) = \\frac{1810}{13900} = \\frac{181}{1390} \\approx 0.1302158...$$\n将结果四舍五入到四位有效数字，我们得到：\n$$E(64) \\approx 0.1302$$\n\n### 效率损失分析\n\n为了确定效率损失的主要来源，我们必须分析总执行时间 $T(64)$ 的构成。并行性能的基本原则是，加速比受到那些不能随处理器数量完美标度的工作部分的限制。这些非标度或标度性差的部分被称为并行开销。\n\n总时间建模为：\n$$T(P) = T_{\\text{compute,parallel}}(P) + T_{\\text{comm}}(P) + T_{\\text{idle}}(P) + T_{\\text{serial}}(P)$$\n在 $P=64$ 时，我们评估每个部分：\n1.  **可并行化计算时间**：这是完美标度的“有效”工作。\n    $$T_{\\text{compute,parallel}}(64) = \\frac{T_{\\text{compute,parallel}}(1)}{64} = \\frac{1740}{64} = 27.1875\\,\\mathrm{s}$$\n2.  **通信开销**：\n    $$T_{\\text{comm}}(64) = 100\\,\\mathrm{s}$$\n3.  **空闲时间开销**：\n    $$T_{\\text{idle}}(64) = 30\\,\\mathrm{s}$$\n4.  **串行瓶颈**：\n    $$T_{\\text{serial}}(64) = 60\\,\\mathrm{s}$$\n\n总时间是各部分之和：$T(64) = 27.1875 + 100 + 30 + 60 = 217.1875\\,\\mathrm{s}$，这与给定的数据一致。\n\n在 $P=64$ 时的总并行开销是非计算部分的总和：\n$$T_{\\text{overhead}}(64) = T_{\\text{comm}}(64) + T_{\\text{idle}}(64) + T_{\\text{serial}}(64) = 100 + 30 + 60 = 190\\,\\mathrm{s}$$\n我们现在可以比较有效工作与开销的大小：\n-   有效计算时间：$27.1875\\,\\mathrm{s}$\n-   总开销时间：$190\\,\\mathrm{s}$\n\n在 $P=64$ 时的效率损失是严重的，因为用于开销的时间（$190\\,\\mathrm{s}$）大约是用于有效、可并行化计算时间（$27.1875\\,\\mathrm{s}$）的 $7$ 倍。\n\n为了确定这种效率损失的主要组成部分，我们检查总时间 $T(64)$ 的分解：\n-   通信的贡献：$\\frac{100}{217.1875} \\approx 46.0\\%$\n-   串行例程的贡献：$\\frac{60}{217.1875} \\approx 27.6\\%$\n-   空闲时间的贡献：$\\frac{30}{217.1875} \\approx 13.8\\%$\n-   有效计算的贡献：$\\frac{27.1875}{217.1875} \\approx 12.5\\%$\n\n从这个分析中，可以明确地看出，**通信开销是导致 $P=64$ 时效率损失的最主要因素**，消耗了 $100\\,\\mathrm{s}$，几乎占总壁钟时间的一半。这在强标度中是一个常见现象，将问题划分到更多处理器上会减少每个处理器的计算工作量，但会增加通信的相对成本（例如，跨越更大总面积的子域表面的晕圈交换）。\n\n**第二个最主要的因素是固定的串行部分**（$60\\,\\mathrm{s}$）。正如 Amdahl 定律所描述的，这代表了可扩展性的一个硬性限制。随着 $P$ 的增加，任务的并行部分缩小，但这个串行时间保持不变，因此在总时间中占据越来越大的比例。在 $P=64$ 时，它占用了超过四分之一的运行时间。通信和串行例程共同占了总执行时间的近四分之三，这解释了为什么效率如此之低，仅约为 $13\\%$。",
            "answer": "$$\n\\boxed{0.1302}\n$$"
        },
        {
            "introduction": "在理解了宏观的并行标度规律后，我们需要深入到单个计算节点的微观架构层面来优化性能。“屋顶线”（Roofline）模型是一个强大的可视化工具，它揭示了一个计算核心（kernel）的性能是被内存带宽限制，还是被处理器的峰值计算能力限制。本练习将通过计算燃烧模拟中两种典型计算核心——扩散项和化学反应项——的算术强度（arithmetic intensity），让你学会如何利用屋顶线模型来诊断性能瓶颈，从而为代码优化指明方向。",
            "id": "4030448",
            "problem": "考虑一个在高性能计算（HPC）的单个高端节点上执行的、用于计算燃烧学领域的三维反应流求解器。目标机器的峰值双精度计算吞吐量为 $C = 1.92 \\times 10^{13}$ 次浮点运算/秒，可持续主存带宽为 $B = 1.20 \\times 10^{12}$ 字节/秒。网格是具有 $N_x = N_y = N_z = 256$ 个单元的均匀笛卡尔网格，每个时间步包含两个主要的计算核心：\n\n- 一个扩散核，它使用7点模板更新每个单元的 $8$ 个输运标量。对于给定单元的每个标量，更新过程会访问中心单元及其 $6$ 个面相邻单元，并执行 $20$ 次双精度浮点运算。假设为双精度（每个值 $8$ 字节），为估算计算强度，假定每次内存访问都来自或去往主存，并且在此计算中没有数据复用。更新操作会将 $8$ 个新的标量值写回中心单元。\n\n- 一个化学反应核，它通过显式方法推进每个单元的热化学状态，每个单元执行 $25{,}000$ 次双精度浮点运算。化学反应的内存移动主要包括读取 $36$ 个双精度状态变量（组分加温度）以及写回 $36$ 个更新后的双精度状态变量。\n\n任务：\n1. 使用计算强度的定义（处理器与主存之间每移动一字节数据所执行的浮点运算次数），计算扩散核和化学反应核的计算强度。\n2. 使用 Roofline 模型和给定的机器参数，通过计算两个核的预测可达双精度性能，将它们放置在 Roofline 图上。将预测性能以 $\\text{GFLOP/s}$ 为单位表示。\n3. 根据它们在 Roofline 图上的位置，推断每个核在此机器上是受限于内存带宽、内存延迟还是计算能力，并从第一性原理和问题规模出发证明你的推断。\n4. 最后，计算化学反应核的预测性能与扩散核的预测性能之比。将此比率表示为一个纯数，并将最终答案四舍五入到四位有效数字。",
            "solution": "用户提供了一个问题陈述，在尝试解答之前，必须首先验证其科学和逻辑上的合理性。\n\n### 步骤 1：提取给定条件\n逐字提取问题陈述中提供的所有数据和条件：\n-   峰值双精度计算吞吐量：$C = 1.92 \\times 10^{13}$ 次浮点运算/秒。\n-   可持续主存带宽：$B = 1.20 \\times 10^{12}$ 字节/秒。\n-   网格维度：$N_x = N_y = N_z = 256$ 个单元。\n-   数据精度：双精度，对应每个值为 $S_{DP} = 8$ 字节。\n-   **扩散核：**\n    -   每个单元更新 $8$ 个输运标量。\n    -   使用一个 7 点模板（中心单元及其 6 个面相邻单元）。\n    -   每个单元的每个标量执行 $20$ 次双精度浮点运算。\n    -   单个标量更新的内存访问涉及读取 $7$ 个值。\n    -   一个单元更新的内存访问涉及写回 $8$ 个新的标量值。\n    -   假设：为计算计算强度，不考虑数据复用。\n-   **化学反应核：**\n    -   每个单元执行 $25{,}000$ 次双精度浮点运算。\n    -   内存访问涉及每个单元读取 $36$ 个双精度状态变量。\n    -   内存访问涉及每个单元写回 $36$ 个更新后的双精度状态变量。\n\n### 步骤 2：使用提取的给定条件进行验证\n根据验证标准对问题进行评估：\n-   **科学上成立：** 该问题牢固地植根于计算科学与工程领域，特别是计算燃烧学。基于模板的扩散求解器、局部化学反应源项积分以及使用 Roofline 模型进行性能分析等概念都是该领域的标准和基础。所提供的机器性能数值（$C$ 和 $B$）代表了现代高性能计算（HPC）节点（例如，一个高端 GPU）的典型性能。\n-   **问题适定：** 该问题是完整定义的。它提供了计算所需量（计算强度、预测性能及其比率）的所有必要数据和定义。各项任务清晰且逻辑有序。可以从所提供的信息中推导出唯一、稳定且有意义的解。网格尺寸（$N_x, N_y, N_z$）是为了提供背景信息，但对于所要求的基于单个单元的分析而言并非必需，这不会使问题变得不适定，反而证实了局部的、单个单元的分析是足够的。\n-   **客观性：** 问题陈述以精确、量化且无偏见的语言表达。没有主观论断或歧义。\n\n### 步骤 3：结论与行动\n该问题被认为是**有效的**，因为它是科学上成立、适定且客观的。它没有违反任何指定的无效标准。因此，将提供完整的解答。\n\n### 解答\n\n解答过程按顺序处理四个任务。分析基于 Roofline 性能模型，该模型将应用程序的计算强度与机器的峰值性能和内存带宽联系起来。\n\n#### 任务 1：计算每个核的计算强度。\n计算强度，用 $I$ 表示，定义为执行的浮点运算次数（FLOPs）与处理器和主存之间移动的总字节数之比。\n$I = \\frac{\\text{浮点运算次数}}{\\text{传输的字节数}}$\n\n**扩散核：**\n首先，我们计算单个单元更新所涉及的总浮点运算次数和传输的字节数。\n-   **每个单元的浮点运算次数 ($F_{\\text{diff}}$):** 该核更新 $8$ 个标量，每次更新需要 $20$ 次浮点运算。\n    $$F_{\\text{diff}} = 8 \\text{ 标量} \\times 20 \\frac{\\text{FLOPs}}{\\text{标量}} = 160 \\text{ FLOPs}$$\n-   **每个单元传输的字节数 ($M_{\\text{diff}}$):** 计算基于无数据复用的既定假设。\n    -   **读取：** 对于 $8$ 个标量中的每一个，从中心单元及其 $6$ 个相邻单元读取值，构成一个 7 点模板。读取的总值数 = $8 \\text{ 标量} \\times 7 \\frac{\\text{值}}{\\text{标量}} = 56$ 个值。\n    -   **写入：** 将 $8$ 个更新后的标量值写回中心单元的内存中。写入的总值数 = $8$ 个值。\n    -   在双精度（$S_{DP} = 8$ 字节/值）下，总数据移动量（以字节为单位）：\n        $$M_{\\text{diff}} = (56 \\text{ 读取} + 8 \\text{ 写入}) \\times 8 \\frac{\\text{字节}}{\\text{值}} = 64 \\text{ 值} \\times 8 \\frac{\\text{字节}}{\\text{值}} = 512 \\text{ 字节}$$\n-   **计算强度 ($I_{\\text{diff}}$):**\n    $$I_{\\text{diff}} = \\frac{F_{\\text{diff}}}{M_{\\text{diff}}} = \\frac{160 \\text{ FLOPs}}{512 \\text{ 字节}} = 0.3125 \\frac{\\text{FLOP}}{\\text{字节}}$$\n\n**化学反应核：**\n-   **每个单元的浮点运算次数 ($F_{\\text{chem}}$):** 这是直接给出的。\n    $$F_{\\text{chem}} = 25{,}000 \\text{ FLOPs}$$\n-   **每个单元传输的字节数 ($M_{\\text{chem}}$):**\n    -   **读取：** 读取 $36$ 个状态变量。\n    -   **写入：** 写入 $36$ 个更新后的状态变量。\n    -   总数据移动量（以字节为单位）：\n        $$M_{\\text{chem}} = (36 \\text{ 读取} + 36 \\text{ 写入}) \\times 8 \\frac{\\text{字节}}{\\text{值}} = 72 \\text{ 值} \\times 8 \\frac{\\text{字节}}{\\text{值}} = 576 \\text{ 字节}$$\n-   **计算强度 ($I_{\\text{chem}}$):**\n    $$I_{\\text{chem}} = \\frac{F_{\\text{chem}}}{M_{\\text{chem}}} = \\frac{25{,}000 \\text{ FLOPs}}{576 \\text{ 字节}} \\approx 43.4028 \\frac{\\text{FLOP}}{\\text{字节}}$$\n\n#### 任务 2：计算每个核的预测可达性能。\nRoofline 模型将性能 $P$ 预测为计算强度 $I$、峰值计算吞吐量 $C$ 和内存带宽 $B$ 的函数。\n$$P(I) = \\min(C, B \\times I)$$\n“脊点”或“机器平衡点”($I_{\\text{ridge}}$) 是性能从内存受限转变为计算受限的计算强度。它是计算吞吐量与内存带宽之比。\n$$I_{\\text{ridge}} = \\frac{C}{B} = \\frac{1.92 \\times 10^{13} \\text{ FLOP/s}}{1.20 \\times 10^{12} \\text{ bytes/s}} = 16 \\frac{\\text{FLOP}}{\\text{byte}}$$\n\n**扩散核性能 ($P_{\\text{diff}}$):**\n我们将其强度 $I_{\\text{diff}}$ 与 $I_{\\text{ridge}}$ 进行比较。\n$I_{\\text{diff}} = 0.3125  I_{\\text{ridge}} = 16$。\n由于计算强度小于机器平衡点，该核是内存受限的。其预测性能受限于内存带宽。\n$$P_{\\text{diff}} = B \\times I_{\\text{diff}} = (1.20 \\times 10^{12} \\text{ bytes/s}) \\times (0.3125 \\text{ FLOP/byte}) = 0.375 \\times 10^{12} \\text{ FLOP/s}$$\n转换为 GFLOP/s（其中 $1 \\text{ GFLOP/s} = 10^9 \\text{ FLOP/s}$）：\n$$P_{\\text{diff}} = \\frac{0.375 \\times 10^{12}}{10^9} \\text{ GFLOP/s} = 375 \\text{ GFLOP/s}$$\n\n**化学反应核性能 ($P_{\\text{chem}}$):**\n我们将其强度 $I_{\\text{chem}}$ 与 $I_{\\text{ridge}}$ 进行比较。\n$I_{\\text{chem}} \\approx 43.4028 > I_{\\text{ridge}} = 16$。\n由于计算强度大于机器平衡点，该核是计算受限的。其预测性能受限于机器的峰值计算吞吐量。\n$$P_{\\text{chem}} = C = 1.92 \\times 10^{13} \\text{ FLOP/s}$$\n转换为 GFLOP/s：\n$$P_{\\text{chem}} = \\frac{1.92 \\times 10^{13}}{10^9} \\text{ GFLOP/s} = 19{,}200 \\text{ GFLOP/s}$$\n\n#### 任务 3：推断每个核的限制因素。\n该推断是 Roofline 分析的直接结果。\n-   **扩散核：** 其计算强度 $I_{\\text{diff}} = 0.3125$ 远小于脊点 $I_{\\text{ridge}} = 16$，位于 Roofline 图的倾斜部分。这表明其性能**受限于内存带宽**。处理器有足够的计算能力来执行所需的操作，但却因数据供给不足而处于“饥饿”状态，大部分时间都在等待从主存中获取数据。\n-   **化学反应核：** 其计算强度 $I_{\\text{chem}} \\approx 43.4$ 大于脊点 $I_{\\text{ridge}} = 16$，位于模型的平坦“屋顶”部分。这表明其性能**受限于处理器的计算能力**。内存系统能够提供数据的速度快于处理器执行每个单元 $25{,}000$ 次浮点运算的速度。\n\n问题还提到了内存延迟。对于作为一种模板计算的扩散核，内存延迟也可能成为一个瓶颈，特别是在存在非连续内存访问模式的情况下。然而，Roofline 模型主要捕捉由带宽施加的限制。鉴于其极低的计算强度，带宽限制是主导因素。\n\n#### 任务 4：计算性能之比。\n我们需要计算化学反应核的预测性能与扩散核的预测性能之比。\n$$\\text{比率} = \\frac{P_{\\text{chem}}}{P_{\\text{diff}}}$$\n使用以 FLOP/s 为单位的性能值：\n$$\\text{比率} = \\frac{1.92 \\times 10^{13} \\text{ FLOP/s}}{0.375 \\times 10^{12} \\text{ FLOP/s}} = \\frac{19.2}{0.375} = 51.2$$\n问题要求将此比率四舍五入到四位有效数字。\n$$\\text{比率} = 51.20$$\n这一结果意味着，在这台特定硬件上，化学反应核的预测运行速度（以 FLOP/s 衡量）比扩散核快 $50$ 倍以上，突显了扩散计算所面临的严重内存带宽瓶颈。",
            "answer": "$$\\boxed{51.20}$$"
        },
        {
            "introduction": "理论知识的最终目的是指导实践。这个综合性练习将引导你将并行计算的理论概念应用于一个具体的算法设计中。你将为一个典型的反应-扩散系统设计一个多层次的混合并行计算方案，它结合了用于分布式内存的MPI、用于共享内存的OpenMP以及用于指令级并行的SIMD。通过这个练习，你将直面并行编程中的实际挑战，如处理“晕轮交换”（halo exchange）和避免“数据竞争”（data race），从而掌握构建高效、正确混合并行程序的关键技能。",
            "id": "4030416",
            "problem": "您的任务是为二维反应流模型中的显式单元更新设计并实现一个混合并行循环嵌套。该混合策略必须结合消息传递接口（MPI）的域分解、开放多处理（OpenMP）的团队以及单指令多数据（SIMD）的向量化。为了本次练习的目的，MPI 和 OpenMP 将在单进程程序中作为算法结构实现，但循环嵌套和内存访问模式必须能代表一个正确的混合设计，并且必须包含防止数据竞争和伪共享的保障措施。\n\n物理模型包含一个用于燃料质量分数和温度的单步反应扩散系统。令 $Y_F(x,y,t)$ 表示燃料质量分数，$T(x,y,t)$ 表示温度。控制偏微分方程组（PDE）如下：\n$$\n\\frac{\\partial Y_F}{\\partial t} = D \\nabla^2 Y_F - \\omega, \\quad\n\\frac{\\partial T}{\\partial t} = \\alpha \\nabla^2 T + \\frac{Q}{\\rho c_p} \\omega,\n$$\n其中 $D$ 是物质扩散系数，单位为 $\\mathrm{m^2/s}$；$\\alpha$ 是热扩散率，单位为 $\\mathrm{m^2/s}$；$Q$ 是单位质量热释放，单位为 $\\mathrm{J/kg}$；$\\rho$ 是密度，单位为 $\\mathrm{kg/m^3}$；$c_p$ 是定压比热，单位为 $\\mathrm{J/(kg\\cdot K)}$；$\\omega$ 是反应速率，单位为 $\\mathrm{s^{-1}}$，由单步 Arrhenius 形式定义：\n$$\n\\omega = A \\exp\\left(-\\frac{E}{R T}\\right) Y_F,\n$$\n其中 $A$ 是指前因子，单位为 $\\mathrm{s^{-1}}$；$E$ 是活化能，单位为 $\\mathrm{J/mol}$；$R$ 是普适气体常数，单位为 $\\mathrm{J/(mol\\cdot K)}$。\n\n在齐次诺伊曼边界条件（法向梯度为零）下，使用显式前向欧拉时间积分器和二阶中心差分来处理空间导数，因此在时间步长 $\\Delta t$ 下，内部单元索引 $(i,j)$ 的离散更新为\n$$\nY_F^{n+1}(i,j) = Y_F^{n}(i,j) + \\Delta t \\left( D \\left[\\frac{Y_F^{n}(i+1,j)-2Y_F^{n}(i,j)+Y_F^{n}(i-1,j)}{\\Delta x^2} + \\frac{Y_F^{n}(i,j+1)-2Y_F^{n}(i,j)+Y_F^{n}(i,j-1)}{\\Delta y^2} \\right] - \\omega^{n}(i,j) \\right),\n$$\n$$\nT^{n+1}(i,j) = T^{n}(i,j) + \\Delta t \\left( \\alpha \\left[\\frac{T^{n}(i+1,j)-2T^{n}(i,j)+T^{n}(i-1,j)}{\\Delta x^2} + \\frac{T^{n}(i,j+1)-2T^{n}(i,j)+T^{n}(i,j-1)}{\\Delta y^2} \\right] + \\frac{Q}{\\rho c_p} \\omega^{n}(i,j) \\right),\n$$\n其中 $\\omega^{n}(i,j)=A\\exp(-E/(R T^{n}(i,j))) Y_F^{n}(i,j)$。诺伊曼边界条件通过将边界值镜像到幽灵层来实现，使得在边界处有 $Y_F(i_{\\mathrm{edge}}, j-1) = Y_F(i_{\\mathrm{edge}}, j)$，其他边界以及对 $T$ 的处理也类似。\n\n为了实现高性能计算，您必须实现一个具有以下设计的混合并行循环嵌套：\n\n- 消息传递接口（MPI）域分解：沿 $x$ 维度将域划分为 $P$ 个连续的子域（“进程”），每个子域两侧各有一个幽灵层用于光环交换。\n- 开放多处理（OpenMP）团队：在每个 MPI 进程内，将 $y$ 维度划分为 $T$ 个不相交的团队块，每个团队更新其自己的连续列范围。\n- 单指令多数据（SIMD）：在每个团队内部，以向量长度 $V$ 为块处理列，以模拟向量通道并在内层循环中实现连续内存访问。\n\n您必须指定并强制执行保障措施，以确保正确性和性能的真实性：\n\n- 数据竞争预防：使用双缓冲，以便更新写入与“当前”数组不同的“下一个”数组；确保每个团队写入不相交的内存范围；并在更新前实现光环交换。\n- 伪共享缓解：确保团队块由非重叠的写入范围分隔，并且每个团队的累加器是私有化的；如果使用填充，请确保填充行或列不会被多个团队写入。\n\n算法要求：\n\n1. 将 $Y_F$ 初始化为以域中心为中心、振幅为 $0.1$（无量纲）的高斯分布，并将 $T$ 统一初始化为 $900\\,\\mathrm{K}$。空间网格是均匀的，间距在米为单位的 $\\Delta x$ 和 $\\Delta y$。时间步长 $\\Delta t$ 的选择必须满足从显式方案推导出的扩散稳定性约束。您的程序必须使用从扩散算子推导出的保守准则来计算 $\\Delta t$；使用单个时间步。\n2. 实现上述的串行基线更新和混合循环嵌套更新。两者都必须应用相同的物理和边界条件。\n3. 进程之间的光环交换必须在更新前逻辑上执行：沿分解维度的幽灵层应由相邻子域的内部数据填充；在全局边界处，通过将边缘内部值复制到幽灵层来强制执行诺伊曼条件。\n4. 归约和累加器（如有）必须按团队私有化，并在更新后合并。\n\n通用常数和参数必须以国际单位制（SI单位）设置。使用以下参数：\n- $R = 8.314\\,\\mathrm{J/(mol\\cdot K)}$, $A = 10^6\\,\\mathrm{s^{-1}}$, $E = 10^5\\,\\mathrm{J/mol}$,\n- $Q = 5\\times 10^6\\,\\mathrm{J/kg}$, $\\rho = 1.0\\,\\mathrm{kg/m^3}$, $c_p = 1000\\,\\mathrm{J/(kg\\cdot K)}$,\n- $D = 10^{-5}\\,\\mathrm{m^2/s}$, $\\alpha = 10^{-5}\\,\\mathrm{m^2/s}$,\n- $\\Delta x = 10^{-3}\\,\\mathrm{m}$, $\\Delta y = 10^{-3}\\,\\mathrm{m}$.\n根据扩散稳定性，选择一个保守的显式步长 $\\Delta t$（单位为秒）；您必须在程序内部，使用从显式中心差分拉普拉斯算子的稳定性推导出的有原则的公式来计算它。\n\n测试套件规范：\n\n您的程序必须评估三个测试用例，每个用例由元组 $(N_x,N_y,P,T,V)$ 定义：\n- 用例1（理想路径）：$(64, 64, 4, 2, 8)$。\n- 用例2（边缘情况：向量余数和小域）：$(4, 10, 2, 1, 3)$。\n- 用例3（边缘情况：单进程多团队）：$(32, 48, 1, 4, 16)$。\n\n对于每个用例，对串行基线和混合循环嵌套实现各运行一个显式时间步，并计算两个结果在两个场上的最大绝对差异。将一个用例的差异定义为\n$$\n\\delta = \\max\\left(\\|Y_F^{n+1}_{\\mathrm{hyb}} - Y_F^{n+1}_{\\mathrm{ser}}\\|_{\\infty},\\ \\|T^{n+1}_{\\mathrm{hyb}} - T^{n+1}_{\\mathrm{ser}}\\|_{\\infty}\\right),\n$$\n对于 $Y_F$ 是无量纲的，对于 $T$ 单位是 $\\mathrm{K}$；将 $\\delta$ 报告为一个无单位的浮点值（您报告的是数值差异，而不是物理状态）。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3]”），其中每个条目按顺序对应于上述用例的 $\\delta$ 值。不得打印任何额外文本。此问题不涉及角度。计算中的所有物理单位必须是 SI 单位；报告的差异是无单位的原始数值差异。\n\n您的实现必须是自包含的，不得从外部文件读取或写入，并且必须能够直接运行。",
            "solution": "该问题要求设计并实现一个混合并行算法来求解二维反应扩散系统，并根据串行实现来验证其正确性。并行化策略结合了用于域分解的消息传递接口（MPI）、用于共享内存线程的开放多处理（OpenMP）以及用于向量化的单指令多数据（SIMD）。该实现将在单进程程序中模拟这种并行性，重点关注循环结构和数据处理的正确性。\n\n### 1. 物理模型与离散化\n\n燃料质量分数 $Y_F$ 和温度 $T$ 的控制偏微分方程组（PDE）为：\n$$\n\\frac{\\partial Y_F}{\\partial t} = D \\nabla^2 Y_F - \\omega\n$$\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\nabla^2 T + \\frac{Q}{\\rho c_p} \\omega\n$$\n反应速率 $\\omega$ 由 Arrhenius 表达式 $\\omega = A \\exp\\left(-E/(R T)\\right) Y_F$ 给出。\n\n我们在间距为 $\\Delta x$ 和 $\\Delta y$ 的均匀笛卡尔网格上对这些方程进行离散化。时间上使用显式前向欧拉方法推进，拉普拉斯算子 $\\nabla^2$ 使用二阶中心差分模板进行近似。这得到从时间步 $n$ 到 $n+1$、索引为 $(i,j)$ 的网格单元的以下更新方程：\n$$\nY_F^{n+1}(i,j) = Y_F^{n}(i,j) + \\Delta t \\left( D \\mathcal{L}(Y_F^n) - \\omega^n \\right)_{i,j}\n$$\n$$\nT^{n+1}(i,j) = T^{n}(i,j) + \\Delta t \\left( \\alpha \\mathcal{L}(T^n) + \\frac{Q}{\\rho c_p} \\omega^n \\right)_{i,j}\n$$\n其中 $\\mathcal{L}(\\phi)$ 是离散拉普拉斯算子：\n$$\n\\mathcal{L}(\\phi)_{i,j} = \\frac{\\phi(i+1,j)-2\\phi(i,j)+\\phi(i-1,j)}{\\Delta x^2} + \\frac{\\phi(i,j+1)-2\\phi(i,j)+\\phi(i,j-1)}{\\Delta y^2}\n$$\n齐次诺伊曼边界条件（$\\partial \\phi / \\partial n = 0$）通过将单层幽灵单元中的值设置为其相邻内部单元的值来实现。\n\n### 2. 稳定性与时间步长选择\n\n前向欧拉时间积分与用于扩散项的中心差分（FTCS 方案）是条件稳定的。对于二维扩散方程，时间步长 $\\Delta t$ 的稳定性约束为：\n$$\n\\Delta t \\le \\frac{1}{2K \\left(\\frac{1}{\\Delta x^2} + \\frac{1}{\\Delta y^2}\\right)}\n$$\n其中 $K$ 是扩散系数。我们的系统有两个耦合方程，扩散系数分别为 $D$ 和 $\\alpha$。为确保整个系统的稳定性，我们必须满足最严格的条件。由于给定参数 $D = \\alpha = 10^{-5}\\,\\mathrm{m^2/s}$，两个场的约束是相同的。问题要求一个保守的选择，因此我们引入一个安全因子 $C_s  1.0$。我们将使用 $C_s = 0.5$。因此，时间步长计算如下：\n$$\n\\Delta t = C_s \\left[ 2 \\max(D, \\alpha) \\left(\\frac{1}{\\Delta x^2} + \\frac{1}{\\Delta y^2}\\right) \\right]^{-1}\n$$\n\n### 3. 初始条件\n\n温度场 $T$ 初始化为均匀值 $900\\,\\mathrm{K}$。燃料质量分数场 $Y_F$ 初始化为以域中心为中心的高斯分布：\n$$\nY_F(x,y) = A_{gauss} \\exp\\left( - \\frac{(x-x_c)^2}{2\\sigma_x^2} - \\frac{(y-y_c)^2}{2\\sigma_y^2} \\right)\n$$\n振幅 $A_{gauss}=0.1$。域的大小为 $L_x = N_x \\Delta x$ 和 $L_y = N_y \\Delta y$。中心点为 $(x_c, y_c) = (L_x/2, L_y/2)$。标准差选择为域尺寸的一部分，这是一种常见做法：$\\sigma_x = L_x/8$ 和 $\\sigma_y = L_y/8$。\n\n### 4. 串行和混合求解器的算法设计\n\n**串行基线求解器：**\n串行求解器为验证提供基准。\n1.  **数据结构**：使用两对二维数组 `(YF_current, T_current)` 和 `(YF_next, T_next)` 进行双缓冲。每个数组都用一个单元宽度的幽灵层进行填充，使其大小为 $(N_x+2, N_y+2)$。\n2.  **执行流程**：\n    a. 将初始条件复制到 `_current` 数组的内部。\n    b. 通过填充所有幽灵单元来应用诺伊曼边界条件。\n    c. 遍历所有内部单元 $(i,j)$，其中 $i \\in [1, N_x]$ 且 $j \\in [1, N_y]$。\n    d. 在循环中，使用 `_current` 数组中的数据计算离散拉普拉斯算子和反应速率 $\\omega$。\n    e. 计算新值 $Y_F^{n+1}(i,j)$ 和 $T^{n+1}(i,j)$ 并将它们存储在 `_next` 数组中。\n    f. 循环结束后，`_next` 数组包含下一个时间步的完整解。\n\n**模拟混合并行求解器：**\n该实现以算法方式模拟混合 MPI/OpenMP/SIMD 策略。\n1.  **MPI 域分解**：将 $N_x \\times N_y$ 单元的全局域沿 $x$ 轴分解为 $P$ 个子域（进程）。每个进程负责一个包含 $N_x/P$ 列的连续块。为了模拟独立的内存空间，为每个进程 $p \\in [0, P-1]$ 分配其自己的数据结构：`YF_curr`、`T_curr`、`YF_next`、`T_next`，每个的大小为 $(N_x/P + 2, N_y + 2)$。初始数据被复制到每个进程的 `_curr` 数组的内部。\n2.  **模拟光环交换**：在计算之前，交换幽灵单元数据。这通过直接内存复制来模拟：\n    -   进程 $p$ 的左侧幽灵层用进程 $p-1$ 的最右侧内部列的数据填充。\n    -   进程 $p$ 的右侧幽灵层用进程 $p+1$ 的最左侧内部列的数据填充。\n    -   对于全局边界（进程 $0$ 的左侧和进程 $P-1$ 的右侧）以及所有顶部/底部边界，通过从相邻内部单元复制来应用诺伊曼条件。\n3.  **OpenMP 团队并行**：在每个进程内，对 $y$ 维度的工作由 $T$ 个团队划分。团队 $t \\in [0, T-1]$ 被分配一个不相交的、连续的 $N_y/T$ 行（或列，取决于数据布局；此处为列带）的块。这种分区确保没有两个团队写入相同的内存位置，从而防止数据竞争。\n4.  **SIMD 向量化**：最内层循环遍历分配给一个团队的单元。为模拟 SIMD，此循环以大小为 $V$（向量长度）的块处理单元。在 Python 和 NumPy 中，这通过使用数组切片来实现。对于给定的模板操作，对长度为 $V$ 的切片上的计算表示为向量操作，这是对 SIMD 执行的精确模拟。实现必须正确处理团队块中的单元数不是 $V$ 的整数倍的情况。\n5.  **循环嵌套结构**：整体结构是一组表示并行层次结构的嵌套循环。这确保了逻辑与真实的并行代码相同。\n    ```\n    for p in 0..P-1:             // MPI Ranks\n        // (Halo Exchange is performed before this loop for all ranks)\n        for i in 1..Nx_local:        // Loop over x-indices in rank p\n            for t in 0..T-1:         // OpenMP Teams\n                // Determine team's y-range [j_start, j_end)\n                for j in j_start..j_end step V: // SIMD chunks\n                    // Process a vector of V cells using slicing\n                    ...\n    ```\n6.  **验证**：在两个求解器都完成一个时间步后，将混合求解器各个进程的内部数据收集到一个全局数组中。最终差异 $\\delta$ 计算为串行和混合结果在 $Y_F$ 和 $T$ 两个场上的最大绝对差：\n    $$\n    \\delta = \\max\\left(\\|Y_F^{n+1}_{\\mathrm{hyb}} - Y_F^{n+1}_{\\mathrm{ser}}\\|_{\\infty},\\ \\|T^{n+1}_{\\mathrm{hyb}} - T^{n+1}_{\\mathrm{ser}}\\|_{\\infty}\\right)\n    $$\n    鉴于浮点运算以相同的顺序执行，我们预期 $\\delta=0.0$（在机器精度范围内）。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the hybrid parallel simulation.\n    \"\"\"\n    test_cases = [\n        (64, 64, 4, 2, 8),   # Happy path\n        (4, 10, 2, 1, 3),   # Edge: vector remainder and small domain\n        (32, 48, 1, 4, 16),  # Edge: single rank with multiple teams\n    ]\n\n    # Physical and numerical constants\n    R = 8.314        # J/(mol.K)\n    A = 1.0e6        # s^-1\n    E = 1.0e5        # J/mol\n    Q = 5.0e6        # J/kg\n    rho = 1.0        # kg/m^3\n    cp = 1000.0      # J/(kg.K)\n    D = 1.0e-5       # m^2/s\n    alpha = 1.0e-5   # m^2/s\n    dx = 1.0e-3      # m\n    dy = 1.0e-3      # m\n\n    # Stability criterion for time step\n    # dt = 1 / (2 * K * (1/dx^2 + 1/dy^2))\n    # Using a conservative safety factor of 0.5\n    diffusion_term = 2.0 * max(D, alpha) * (1.0 / dx**2 + 1.0 / dy**2)\n    dt = 0.5 / diffusion_term\n    \n    Q_term = Q / (rho * cp)\n\n    results = []\n    for case in test_cases:\n        Nx, Ny, P, T, V = case\n\n        # --- INITIAL CONDITIONS ---\n        YF0 = np.zeros((Nx, Ny))\n        T0 = np.full((Nx, Ny), 900.0)\n\n        Lx, Ly = Nx * dx, Ny * dy\n        xc, yc = Lx / 2.0, Ly / 2.0\n        sigma_x, sigma_y = Lx / 8.0, Ly / 8.0\n        \n        x = (np.arange(Nx) + 0.5) * dx\n        y = (np.arange(Ny) + 0.5) * dy\n        X, Y = np.meshgrid(x, y, indexing='ij')\n\n        YF0 = 0.1 * np.exp(-((X - xc)**2 / (2 * sigma_x**2) + (Y - yc)**2 / (2 * sigma_y**2)))\n\n        # --- SERIAL SOLVER ---\n        YF_ser, T_ser = serial_solver(YF0, T0, dt, dx, dy, D, alpha, A, E, R, Q_term)\n        \n        # --- HYBRID SOLVER ---\n        YF_hyb, T_hyb = hybrid_solver(YF0, T0, P, T, V, dt, dx, dy, D, alpha, A, E, R, Q_term)\n\n        # --- VERIFICATION ---\n        discrepancy_YF = np.max(np.abs(YF_hyb - YF_ser))\n        discrepancy_T = np.max(np.abs(T_hyb - T_ser))\n        delta = max(discrepancy_YF, discrepancy_T)\n        results.append(delta)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef apply_neumann_bc(field):\n    \"\"\"Applies Neumann BC to a padded 2D field.\"\"\"\n    field[0, :] = field[1, :]      # Left\n    field[-1, :] = field[-2, :]    # Right\n    field[:, 0] = field[:, 1]      # Bottom\n    field[:, -1] = field[:, -2]    # Top\n\ndef serial_solver(YF0, T0, dt, dx, dy, D, alpha, A, E, R, Q_term):\n    \"\"\"Computes one time step using a serial implementation.\"\"\"\n    Nx, Ny = YF0.shape\n    \n    YF_curr = np.zeros((Nx + 2, Ny + 2))\n    T_curr = np.zeros((Nx + 2, Ny + 2))\n    \n    YF_curr[1:-1, 1:-1] = YF0\n    T_curr[1:-1, 1:-1] = T0\n    \n    YF_next = np.copy(YF_curr)\n    T_next = np.copy(T_curr)\n    \n    apply_neumann_bc(YF_curr)\n    apply_neumann_bc(T_curr)\n\n    dx2, dy2 = dx**2, dy**2\n\n    for i in range(1, Nx + 1):\n        for j in range(1, Ny + 1):\n            # Stencil values\n            YF_c = YF_curr[i, j]\n            T_c = T_curr[i, j]\n\n            # Reaction rate\n            omega = A * np.exp(-E / (R * T_c)) * YF_c if T_c > 0 else 0.0\n\n            # Laplacians\n            lap_YF = (YF_curr[i+1, j] - 2*YF_c + YF_curr[i-1, j]) / dx2 + \\\n                     (YF_curr[i, j+1] - 2*YF_c + YF_curr[i, j-1]) / dy2\n            lap_T = (T_curr[i+1, j] - 2*T_c + T_curr[i-1, j]) / dx2 + \\\n                    (T_curr[i, j+1] - 2*T_c + T_curr[i, j-1]) / dy2\n\n            # Update\n            YF_next[i, j] = YF_c + dt * (D * lap_YF - omega)\n            T_next[i, j] = T_c + dt * (alpha * lap_T + Q_term * omega)\n    \n    return YF_next[1:-1, 1:-1], T_next[1:-1, 1:-1]\n\n\ndef hybrid_solver(YF0, T0, P, T, V, dt, dx, dy, D, alpha, A, E, R, Q_term):\n    \"\"\"Simulates one time step using the hybrid parallel algorithm.\"\"\"\n    Nx, Ny = YF0.shape\n    nx_per_rank = Nx // P\n\n    dx2, dy2 = dx**2, dy**2\n\n    # 1. Decompose domain and initialize ranks\n    ranks = []\n    for p in range(P):\n        i_start_global = p * nx_per_rank\n        i_end_global = (p + 1) * nx_per_rank\n        \n        local_YF_curr = np.zeros((nx_per_rank + 2, Ny + 2))\n        local_T_curr = np.zeros((nx_per_rank + 2, Ny + 2))\n        \n        local_YF_curr[1:-1, 1:-1] = YF0[i_start_global:i_end_global, :]\n        local_T_curr[1:-1, 1:-1] = T0[i_start_global:i_end_global, :]\n        \n        ranks.append({\n            'YF_curr': local_YF_curr, 'T_curr': local_T_curr,\n            'YF_next': np.copy(local_YF_curr), 'T_next': np.copy(local_T_curr)\n        })\n\n    # 2. Simulate Halo Exchange\n    for p in range(P):\n        # Top/Bottom BCs (Neumann)\n        ranks[p]['YF_curr'][:, 0] = ranks[p]['YF_curr'][:, 1]\n        ranks[p]['YF_curr'][:, -1] = ranks[p]['YF_curr'][:, -2]\n        ranks[p]['T_curr'][:, 0] = ranks[p]['T_curr'][:, 1]\n        ranks[p]['T_curr'][:, -1] = ranks[p]['T_curr'][:, -2]\n        \n        # Left/Right Halo Exchange\n        if P > 1:\n            if p > 0: # Get from left neighbor\n                ranks[p]['YF_curr'][0, :] = ranks[p-1]['YF_curr'][-2, :]\n                ranks[p]['T_curr'][0, :] = ranks[p-1]['T_curr'][-2, :]\n            else: # Global left boundary (Neumann)\n                ranks[p]['YF_curr'][0, :] = ranks[p]['YF_curr'][1, :]\n                ranks[p]['T_curr'][0, :] = ranks[p]['T_curr'][1, :]\n\n            if p  P - 1: # Get from right neighbor\n                ranks[p]['YF_curr'][-1, :] = ranks[p+1]['YF_curr'][1, :]\n                ranks[p]['T_curr'][-1, :] = ranks[p+1]['T_curr'][1, :]\n            else: # Global right boundary (Neumann)\n                ranks[p]['YF_curr'][-1, :] = ranks[p]['YF_curr'][-2, :]\n                ranks[p]['T_curr'][-1, :] = ranks[p]['T_curr'][-2, :]\n        else: # Single rank case (P=1)\n            ranks[p]['YF_curr'][0, :] = ranks[p]['YF_curr'][1, :]\n            ranks[p]['YF_curr'][-1, :] = ranks[p]['YF_curr'][-2, :]\n            ranks[p]['T_curr'][0, :] = ranks[p]['T_curr'][1, :]\n            ranks[p]['T_curr'][-1, :] = ranks[p]['T_curr'][-2, :]\n\n    # 3. Compute update (loop over ranks, teams, vectors)\n    for p in range(P):\n        rank = ranks[p]\n        YF_read, T_read = rank['YF_curr'], rank['T_curr']\n        YF_write, T_write = rank['YF_next'], rank['T_next']\n\n        # Loop over local interior x-indices\n        for i in range(1, nx_per_rank + 1):\n            ny_per_team = Ny // T\n            # OpenMP Team loop\n            for t in range(T):\n                j_start_team = t * ny_per_team\n                j_end_team = (t + 1) * ny_per_team\n                \n                # SIMD loop\n                for j_offset in range(0, j_end_team - j_start_team, V):\n                    chunk_size = min(V, (j_end_team - j_start_team) - j_offset)\n                    j_padded_start = j_start_team + j_offset + 1\n                    s = slice(j_padded_start, j_padded_start + chunk_size)\n\n                    # Stencil values\n                    YF_c = YF_read[i, s]\n                    T_c = T_read[i, s]\n                    \n                    # Reaction rate\n                    # Avoid division by zero warnings for T_c=0\n                    omega = np.zeros_like(T_c)\n                    safe_T = T_c > 0\n                    if np.any(safe_T):\n                         omega[safe_T] = A * np.exp(-E / (R * T_c[safe_T])) * YF_c[safe_T]\n\n                    # Laplacians\n                    YF_n, YF_s = YF_read[i, s.start+1:s.stop+1], YF_read[i, s.start-1:s.stop-1]\n                    YF_e, YF_w = YF_read[i+1, s], YF_read[i-1, s]\n                    lap_YF = (YF_e - 2*YF_c + YF_w) / dx2 + (YF_n - 2*YF_c + YF_s) / dy2\n\n                    T_n, T_s = T_read[i, s.start+1:s.stop+1], T_read[i, s.start-1:s.stop-1]\n                    T_e, T_w = T_read[i+1, s], T_read[i-1, s]\n                    lap_T = (T_e - 2*T_c + T_w) / dx2 + (T_n - 2*T_c + T_s) / dy2\n                    \n                    # Update\n                    YF_write[i, s] = YF_c + dt * (D * lap_YF - omega)\n                    T_write[i, s] = T_c + dt * (alpha * lap_T + Q_term * omega)\n\n    # 4. Gather results\n    YF_hyb_final = np.zeros((Nx, Ny))\n    T_hyb_final = np.zeros((Nx, Ny))\n    for p in range(P):\n        i_start_global = p * nx_per_rank\n        i_end_global = (p + 1) * nx_per_rank\n        YF_hyb_final[i_start_global:i_end_global, :] = ranks[p]['YF_next'][1:-1, 1:-1]\n        T_hyb_final[i_start_global:i_end_global, :] = ranks[p]['T_next'][1:-1, 1:-1]\n\n    return YF_hyb_final, T_hyb_final\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}