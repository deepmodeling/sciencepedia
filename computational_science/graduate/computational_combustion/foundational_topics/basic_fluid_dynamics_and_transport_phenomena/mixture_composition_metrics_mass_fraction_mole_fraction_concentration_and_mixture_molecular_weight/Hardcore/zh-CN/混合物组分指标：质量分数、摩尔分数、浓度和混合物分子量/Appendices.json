{
    "hands_on_practices": [
        {
            "introduction": "在计算燃烧学中，我们通常求解基于质量的输运方程（例如质量分数 $Y_i$），而化学动力学和热力学关系则更自然地用摩尔量（例如摩尔分数 $X_i$ 或摩尔浓度 $c_i$）来表示。因此，熟练地在这些表示之间进行转换并理解它们的等价性是一项基本技能。本练习将通过理论推导和数值验证来巩固这一核心概念 ，确保您能从根本上连接质量和摩尔这两个世界。",
            "id": "4040326",
            "problem": "您需要设计并实现一个完整的算法工作流程，该流程根据计算燃烧学的相关基本定义和定律来计算气体混合物中各组分的摩尔浓度。目标是从不同的组分度量推导出组分浓度的表达式，在指定条件下证明它们的等价性，然后在一套测试用例上对这种等价性进行数值验证。\n\n起点和定义：\n- 设 $i$ 为化学组分的索引。设 $n_i$ 表示组分 $i$ 的摩尔数，$m_i$ 为其质量，$W_i$ 为其摩尔质量，单位为 $\\mathrm{kg/mol}$。设 $n = \\sum_i n_i$ 和 $m = \\sum_i m_i$ 分别表示混合物的总摩尔数和总质量。设 $V$ 表示混合物的总体积，单位为 $\\mathrm{m^3}$，$\\rho$ 为其质量密度，单位为 $\\mathrm{kg/m^3}$，$p$ 为其压力，单位为 $\\mathrm{Pa}$，$T$ 为其温度，单位为 $\\mathrm{K}$。普适气体常数为 $R_u$，单位为 $\\mathrm{J/(mol\\cdot K)}$。\n- 质量分数定义为 $Y_i = m_i/m$。\n- 摩尔分数定义为 $X_i = n_i/n$。\n- 组分摩尔浓度定义为 $c_i = n_i/V$，单位为 $\\mathrm{mol/m^3}$。\n- 混合物摩尔质量定义为 $W = m/n$。\n- 在理想气体条件下，理想气体定律成立：$pV = n R_u T$。\n\n任务：\n1. 从上述 $Y_i$、$X_i$、$c_i$、$\\rho$、$W$、$m_i=n_i W_i$ 的定义以及理想气体定律出发，推导一个用 $Y_i$、$\\rho$ 和 $W_i$ 表示 $c_i$ 的表达式。另外，在理想气体条件下，推导一个用 $X_i$、$p$ 和 $T$ 表示 $c_i$ 的表达式。当混合物遵循理想气体定律，并且 $Y_i$、$X_i$ 和 $W$ 的定义得到一致应用时，严格证明这些表达式是等价的。\n2. 设计并实现一个步骤清晰的算法，该算法能够：\n   - 使用定义在质量分数 $Y_i$ 和摩尔分数 $X_i$ 之间进行转换。\n   - 从 $X_i$ 和 $W_i$ 计算混合物摩尔质量 $W$。\n   - 在理想气体条件下，从 $p$、$T$ 和 $W$ 计算 $\\rho$。\n   - 仅使用基本定义，从 $\\rho$ 和 $Y_i$ 计算 $c_i$。\n   - 使用理想气体定律，从 $X_i$、$p$ 和 $T$ 计算 $c_i$。\n   - 通过报告每个测试用例中各组分之间最大的绝对差异，来验证两种 $c_i$ 计算方法的数值等价性。\n\n物理单位和报告：\n- 摩尔质量 $W_i$ 和混合物摩尔质量 $W$ 必须以 $\\mathrm{kg/mol}$ 为单位处理。\n- 压力 $p$ 必须以 $\\mathrm{Pa}$ 为单位，温度 $T$ 以 $\\mathrm{K}$ 为单位，密度 $\\rho$ 以 $\\mathrm{kg/m^3}$ 为单位，浓度 $c_i$ 以 $\\mathrm{mol/m^3}$ 为单位。\n- 您的程序必须为每个测试用例计算并报告一个实数，该实数等于最大绝对差 $\\max_i |c_i^{(\\text{mass})} - c_i^{(\\text{mole})}|$，单位为 $\\mathrm{mol/m^3}$。\n\n测试套件：\n使用以下科学上一致的测试用例。对于每个用例，混合物是理想的，您必须根据所提供的参数在内部构建所有必要的量。\n\n- 用例 A (类似甲烷-空气的多组分混合物):\n  - 组分: $\\mathrm{CH_4}$, $\\mathrm{O_2}$, $\\mathrm{N_2}$\n  - $W_i$: $[0.016043, 0.031998, 0.0280134]$ $\\mathrm{kg/mol}$\n  - 摩尔分数 $X_i$: $[0.05, 0.21, 0.74]$\n  - $p = 101325$ $\\mathrm{Pa}$, $T = 1000$ $\\mathrm{K}$\n- 用例 B (单组分氧气):\n  - 组分: $\\mathrm{O_2}$\n  - $W_i$: $[0.031998]$ $\\mathrm{kg/mol}$\n  - 摩尔分数 $X_i$: $[1.0]$\n  - $p = 5 \\times 101325$ $\\mathrm{Pa}$, $T = 300$ $\\mathrm{K}$\n- 用例 C (低压高温下空气中的痕量氢气):\n  - 组分: $\\mathrm{H_2}$, $\\mathrm{O_2}$, $\\mathrm{N_2}$\n  - $W_i$: $[0.00201588, 0.031998, 0.0280134]$ $\\mathrm{kg/mol}$\n  - 摩尔分数 $X_i$: $[10^{-6}, 0.21, 0.789999]$\n  - $p = 50000$ $\\mathrm{Pa}$, $T = 1500$ $\\mathrm{K}$\n- 用例 D (燃烧产物混合物):\n  - 组分: $\\mathrm{CO_2}$, $\\mathrm{H_2O}$\n  - $W_i$: $[0.0440095, 0.01801528]$ $\\mathrm{kg/mol}$\n  - 摩尔分数 $X_i$: $[0.3, 0.7]$\n  - $p = 2 \\times 101325$ $\\mathrm{Pa}$, $T = 2300$ $\\mathrm{K}$\n\n答案规范：\n- 对于每个用例，计算两组组分浓度，然后输出一个浮点数，等于各组分间的最大绝对差，单位为 $\\mathrm{mol/m^3}$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，并保持用例的列出顺序：例如，$[r_A,r_B,r_C,r_D]$，其中每个 $r_\\cdot$ 是一个实数。\n\n不允许用户输入；所有数据必须如上所述进行硬编码。您的代码必须是一个完整的、可运行的程序，实现所有步骤并只打印指定的最后一行。",
            "solution": "我们已仔细审查了问题陈述，并确定其是有效的。它在科学上是合理的、提法得当、客观，并提供了一套完整且一致的定义和数据。因此，我们可以进行完整的解答。\n\n这个问题的核心包括两个部分：首先是对两种计算组分摩尔浓度方法的理论推导和等价性证明，然后是设计并实现一个算法来数值验证这种等价性。\n\n### 任务1：理论推导与等价性证明\n\n我们的任务是推导组分 $i$ 的摩尔浓度（表示为 $c_i$）的两个不同表达式，然后在理想气体条件下证明它们的等价性。\n\n**推导1：从质量分数、密度和摩尔质量计算浓度**\n\n这个推导，我们将用它来计算 $c_i^{(\\text{mass})}$，源于所提供的基本定义。\n\n1.  组分摩尔浓度的定义是 $c_i = n_i / V$，其中 $n_i$ 是组分 $i$ 的摩尔数，而 $V$ 是混合物的总体积。\n2.  组分 $i$ 的质量 $m_i$ 与其摩尔量 $n_i$ 和摩尔质量 $W_i$ 的关系式为 $m_i = n_i W_i$。这可以重排以表示 $n_i$ 为 $n_i = m_i / W_i$。\n3.  将这个 $n_i$ 的表达式代入 $c_i$ 的定义中，得到：\n    $$c_i = \\frac{(m_i / W_i)}{V} = \\frac{m_i}{V W_i}$$\n4.  组分 $i$ 的质量分数 $Y_i$ 定义为 $Y_i = m_i / m$，其中 $m$ 是混合物的总质量。这可以重排以表示 $m_i$ 为 $m_i = Y_i m$。\n5.  将这个 $m_i$ 的表达式代入我们的 $c_i$ 表达式中：\n    $$c_i = \\frac{Y_i m}{V W_i} = \\frac{Y_i}{W_i} \\left(\\frac{m}{V}\\right)$$\n6.  项 $(m/V)$ 是混合物质质量密度 $\\rho$ 的定义。\n7.  因此，我们得到了组分摩尔浓度的第一个表达式：\n    $$c_i^{(\\text{mass})} = \\frac{\\rho Y_i}{W_i}$$\n\n**推导2：从摩尔分数、压力和温度计算浓度（理想气体）**\n\n这第二个推导，我们将用它来计算 $c_i^{(\\text{mole})}$，它引入了理想气体定律。\n\n1.  我们再次从摩尔浓度的定义开始，$c_i = n_i / V$。\n2.  组分 $i$ 的摩尔分数 $X_i$ 定义为 $X_i = n_i / n$，其中 $n$ 是混合物中的总摩尔数。这可以重排为 $n_i = X_i n$。\n3.  将这个 $n_i$ 的表达式代入 $c_i$ 的定义中：\n    $$c_i = \\frac{X_i n}{V} = X_i \\left(\\frac{n}{V}\\right)$$\n4.  对于表现为理想气体的混合物，理想气体定律指出 $pV = n R_u T$，其中 $p$ 是压力，$T$ 是温度，$R_u$ 是普适气体常数。\n5.  我们可以重排理想气体定律来解出项 $(n/V)$，它代表混合物的总摩尔浓度：\n    $$\\frac{n}{V} = \\frac{p}{R_u T}$$\n6.  将此结果代入我们的 $c_i$ 表达式中，得到第二个所需的公式：\n    $$c_i^{(\\text{mole})} = X_i \\frac{p}{R_u T}$$\n\n**等价性证明**\n\n为了证明在理想气体条件下 $c_i^{(\\text{mass})} = c_i^{(\\text{mole})}$，我们必须通过一致地应用给定的定义来证明 $\\rho Y_i / W_i = X_i p / (R_u T)$。我们将从 $c_i^{(\\text{mass})}$ 的表达式开始，并证明它可以转化为 $c_i^{(\\text{mole})}$ 的表达式。\n\n1.  从 $c_i^{(\\text{mass})}$ 的表达式开始：\n    $$c_i^{(\\text{mass})} = \\frac{\\rho Y_i}{W_i}$$\n2.  我们需要用基于摩尔的量和状态变量（$p$、$T$）来表示基于质量的量 $\\rho$ 和 $Y_i$。\n3.  首先，让我们建立质量分数 $Y_i$ 和摩尔分数 $X_i$ 之间的关系。\n    -   根据定义，$Y_i = m_i / m$。\n    -   代入 $m_i = n_i W_i$ 和 $m = \\sum_j m_j = \\sum_j (n_j W_j)$：\n        $$Y_i = \\frac{n_i W_i}{\\sum_j n_j W_j}$$\n    -   将分子和分母都除以总摩尔数 $n = \\sum_j n_j$：\n        $$Y_i = \\frac{(n_i/n) W_i}{\\sum_j (n_j/n) W_j} = \\frac{X_i W_i}{\\sum_j X_j W_j}$$\n    -   分母 $\\sum_j X_j W_j$ 是混合物平均摩尔质量 $W$ 的定义。这可以从 $W=m/n$ 的主定义中得出：$W = (\\sum_j m_j)/n = (\\sum_j n_j W_j)/n = \\sum_j (n_j/n) W_j = \\sum_j X_j W_j$。\n    -   因此，转换公式为 $Y_i = (X_i W_i)/W$。\n4.  接下来，让我们表示理想气体的混合物密度 $\\rho$。\n    -   根据定义，$\\rho = m/V$。\n    -   使用理想气体定律 $V = n R_u T / p$：\n        $$\\rho = \\frac{m}{n R_u T / p} = \\frac{m}{n} \\frac{p}{R_u T}$$\n    -   认识到 $W = m/n$，我们找到了密度的状态方程：$\\rho = W p / (R_u T)$。\n5.  现在，将推导出的 $Y_i$ 和 $\\rho$ 的表达式代回到 $c_i^{(\\text{mass})}$ 的公式中：\n    $$c_i^{(\\text{mass})} = \\left( \\frac{W p}{R_u T} \\right) \\left( \\frac{X_i W_i}{W} \\right) \\left( \\frac{1}{W_i} \\right)$$\n6.  分子和分母中的混合物摩尔质量 $W$ 相互抵消。组分摩尔质量 $W_i$ 也相互抵消。\n    $$c_i^{(\\text{mass})} = \\frac{p}{R_u T} X_i$$\n7.  这个最终表达式与 $c_i^{(\\text{mole})}$ 的表达式相同。这完成了证明：\n    $$c_i^{(\\text{mass})} = c_i^{(\\text{mole})}$$\n这个严格的证明证实了，对于任何遵循理想气体定律的气体混合物，这两种公式在理论上是等价的。\n\n### 任务2：用于数值验证的算法工作流程\n\n现在我们将对理论等价性进行数值验证。对于每个提供的测试用例，算法按以下步骤进行。每个用例的输入是组分摩尔质量集合 $\\{W_i\\}$、组分摩尔分数集合 $\\{X_i\\}$、混合物压力 $p$ 和混合物温度 $T$。普适气体常数 $R_u = 8.314462618 \\, \\mathrm{J/(mol \\cdot K)}$ 是一个必需的物理常数。\n\n**步骤1：通过摩尔分数路径计算浓度**\n这是最直接的计算方法。\n- 计算混合物的总摩尔浓度，$c = p / (R_u T)$。\n- 使用先前推导的公式计算每个组分 $i$ 的浓度：$c_i^{(\\text{mole})} = X_i \\cdot c = X_i (p / (R_u T))$。\n\n**步骤2：通过质量分数路径计算浓度**\n此路径涉及几个中间计算。\n- **2(a) 计算混合物摩尔质量 ($W$):** 将混合物的平均摩尔质量计算为组分摩尔质量的摩尔分数加权平均值：\n  $$W = \\sum_i X_i W_i$$\n- **2(b) 将摩尔分数转换为质量分数 ($\\{X_i\\} \\to \\{Y_i\\}$):** 对于每个组分，使用转换公式计算其质量分数：\n  $$Y_i = \\frac{X_i W_i}{W}$$\n- **2(c) 计算混合物密度 ($\\rho$):** 使用理想气体状态方程，从压力、温度和混合物摩尔质量求出混合物质质量密度：\n  $$\\rho = \\frac{p W}{R_u T}$$\n- **2(d) 计算组分浓度 ($c_i^{(\\text{mass})}$):** 使用基于质量的公式计算每个组分的浓度：\n  $$c_i^{(\\text{mass})} = \\frac{\\rho Y_i}{W_i}$$\n\n**步骤3：比较结果并报告差异**\n- 对于每个测试用例，已计算出一组浓度 $\\{c_i^{(\\text{mole})}\\}$ 和 $\\{c_i^{(\\text{mass})}\\}$。\n- 计算这两组之间的逐元素绝对差：$\\Delta c_i = |c_i^{(\\text{mass})} - c_i^{(\\text{mole})}|$。\n- 测试用例的最终结果是在绝对差集合中找到的最大值：\n  $$\\text{差异} = \\max_i(\\Delta c_i)$$\n这个差异应该接近于零，仅受浮点运算的有限精度限制。该算法的实现在最终答案中提供。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and validates species molar concentrations in gas mixtures.\n\n    This function implements the algorithmic workflow to:\n    1. Calculate species molar concentrations from mole fractions, pressure, and temperature.\n    2. Calculate the same concentrations via an alternative path involving mass fractions\n       and density.\n    3. Numerically validate the equivalence of the two methods by computing the maximum\n       absolute difference in the results for several test cases.\n    \"\"\"\n    # Universal gas constant in J/(mol·K)\n    R_u = 8.31446261815324\n\n    # Define the test cases from the problem statement.\n    # Each case is a dictionary containing species names, molecular weights (W_i),\n    # mole fractions (X_i), pressure (p), and temperature (T).\n    test_cases = [\n        {\n            \"name\": \"Case A (methane–air-like mixture)\",\n            \"species\": [\"CH4\", \"O2\", \"N2\"],\n            \"W_i\": np.array([0.016043, 0.031998, 0.0280134]),  # kg/mol\n            \"X_i\": np.array([0.05, 0.21, 0.74]),\n            \"p\": 101325.0,  # Pa\n            \"T\": 1000.0,  # K\n        },\n        {\n            \"name\": \"Case B (single-species oxygen)\",\n            \"species\": [\"O2\"],\n            \"W_i\": np.array([0.031998]),  # kg/mol\n            \"X_i\": np.array([1.0]),\n            \"p\": 5.0 * 101325.0,  # Pa\n            \"T\": 300.0,  # K\n        },\n        {\n            \"name\": \"Case C (trace hydrogen in air)\",\n            \"species\": [\"H2\", \"O2\", \"N2\"],\n            \"W_i\": np.array([0.00201588, 0.031998, 0.0280134]),  # kg/mol\n            \"X_i\": np.array([1e-6, 0.21, 0.789999]),\n            \"p\": 50000.0,  # Pa\n            \"T\": 1500.0,  # K\n        },\n        {\n            \"name\": \"Case D (combustion products)\",\n            \"species\": [\"CO2\", \"H2O\"],\n            \"W_i\": np.array([0.0440095, 0.01801528]),  # kg/mol\n            \"X_i\": np.array([0.3, 0.7]),\n            \"p\": 2.0 * 101325.0,  # Pa\n            \"T\": 2300.0,  # K\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        W_i = case[\"W_i\"]\n        X_i = case[\"X_i\"]\n        p = case[\"p\"]\n        T = case[\"T\"]\n\n        # --- Calculation Path 1: Mole Fraction Based ---\n        # c_i = X_i * (p / (R_u * T))\n        total_molar_concentration = p / (R_u * T)\n        c_i_mole = X_i * total_molar_concentration\n\n        # --- Calculation Path 2: Mass Fraction Based ---\n        # 1. Compute mixture molecular weight (W)\n        # W = sum(X_i * W_i)\n        W_mixture = np.dot(X_i, W_i)\n\n        # 2. Convert mole fractions (X_i) to mass fractions (Y_i)\n        # Y_i = X_i * W_i / W_mixture\n        # Adding a small epsilon to W_mixture to avoid division by zero in edge cases,\n        # although not strictly necessary with the given test data.\n        Y_i = (X_i * W_i) / (W_mixture + 1e-30)\n\n        # 3. Compute mixture density (rho) using the ideal gas law\n        # rho = p * W_mixture / (R_u * T)\n        rho_mixture = p * W_mixture / (R_u * T)\n\n        # 4. Compute species concentrations (c_i) from mass-based quantities\n        # c_i = rho * Y_i / W_i\n        c_i_mass = (rho_mixture * Y_i) / (W_i + 1e-30)\n\n        # --- Validation ---\n        # Compute the maximum absolute difference between the two computed concentration vectors.\n        # This value should be near machine precision (~0.0).\n        max_abs_diff = np.max(np.abs(c_i_mass - c_i_mole))\n        results.append(max_abs_diff)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在数值模拟中，由于浮点误差的累积，计算得到的质量分数向量 $\\tilde{Y}$ 可能不再满足物理约束，例如各组分之和不为1或出现微小的负值。简单地进行裁剪或归一化可能会引入无法控制的误差。本练习  将指导您应用优化理论，将非物理的质量分数向量投影到标准单纯形 $\\Delta^{n-1}$ 上，从而在最小化扰动的同时，系统性地恢复其物理真实性。",
            "id": "4040311",
            "problem": "给定一个反应混合物中的有限化学物种集合，以 $i \\in \\{1,\\dots,n\\}$ 为索引。物种 $i$ 的质量分数记为 $Y_i$，摩尔分数记为 $X_i$，物种 $i$ 的分子量（每摩尔的质量）记为 $W_i$。在数值燃烧模拟中，由于浮点舍入和算法截断，人们常会得到一个受扰动的质量分数向量 $\\tilde{Y} \\in \\mathbb{R}^n$，该向量可能不满足质量分数的两个核心约束，即 $\\sum_{i=1}^n Y_i = 1$ 和对所有 $i$ 都有 $Y_i \\ge 0$。混合物的分子量 $W_{\\mathrm{mix}}$ 由质量分数和各物种分子量定义为 $$W_{\\mathrm{mix}} = \\left(\\sum_{i=1}^n \\frac{Y_i}{W_i}\\right)^{-1},$$ 当对所有 $i$ 都有 $Y_i \\ge 0$、$\\sum_i Y_i = 1$ 且 $W_i > 0$ 时，该定义是良定义的。您的任务是，从第一性原理出发，推导一种归一化策略，该策略能处理任何由浮点计算产生的 $\\tilde{Y}$，并返回一个修正后的向量 $Y^\\star$，使其在满足质量分数约束的同时，在适当的度量下具有尽可能小的扰动。您必须从质量分数的质量守恒基本约束（非负性和总和为一）以及最小化与 $\\tilde{Y}$ 之间物理上有意义的偏差这一基本优化原理出发，并推理出一个具体的算法。然后，您必须证明该策略在单纯形 $$\\Delta^{n-1} = \\left\\{Y \\in \\mathbb{R}^n \\;\\middle|\\; \\sum_{i=1}^n Y_i = 1,\\; Y_i \\ge 0 \\;\\forall i\\right\\}$$上是可行的。在您的证明中，您应确立解的存在性、唯一性，并证明所构造的 $Y^\\star$ 位于 $\\Delta^{n-1}$ 内，同时论证在所选度量下扰动是最小的。\n\n编程要求：在一个程序中实现您的归一化策略，并将其应用于下面的测试套件。对于每个测试用例，使用修正后的 $Y^\\star$ 计算修正的质量分数 $Y^\\star$ 和相应的混合物分子量 $W_{\\mathrm{mix}}$。质量分数是无量纲的，而分子量必须以 $\\mathrm{kg}/\\mathrm{kmol}$ 为单位处理，您的程序必须以 $\\mathrm{kg}/\\mathrm{kmol}$ 为单位报告 $W_{\\mathrm{mix}}$。您必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果本身应该是一个包含两个元素的列表，其第一个元素是修正后的质量分数列表 $Y^\\star$（物种顺序与给定顺序相同），第二个元素是标量 $W_{\\mathrm{mix}}$（单位为 $\\mathrm{kg}/\\mathrm{kmol}$）。最终输出必须具有以下形式：$$\\left[\\left[Y^\\star_{(1)}, W_{\\mathrm{mix},(1)}\\right], \\left[Y^\\star_{(2)}, W_{\\mathrm{mix},(2)}\\right], \\dots \\right],$$ 其中 $Y^\\star_{(k)}$ 是一个包含 $n$ 个浮点数的列表，$W_{\\mathrm{mix},(k)}$ 是一个浮点数。\n\n允许用于推导的基本依据：\n- 质量分数约束 $\\sum_{i=1}^n Y_i = 1$ 和对所有 $i$ 都有 $Y_i \\ge 0$。\n- 根据 $\\mathbb{R}^n$ 中范数诱导的距离最小化偏差的原理（在此背景下，从第一性原理选择并论证一个合适的范数）。\n- 基于质量分数和各物种分子量的混合物分子量 $W_{\\mathrm{mix}}$ 的定义。\n\n测试套件：\n- 物种和分子量：考虑 $n = 5$ 个物种，其分子量（单位为 $\\mathrm{kg}/\\mathrm{kmol}$）按以下固定顺序列出：氮气 ($\\mathrm{N}_2$) $W_1 = 28.0134$，氧气 ($\\mathrm{O}_2$) $W_2 = 31.9988$，二氧化碳 ($\\mathrm{CO}_2$) $W_3 = 44.0095$，水 ($\\mathrm{H}_2\\mathrm{O}$) $W_4 = 18.01528$，甲烷 ($\\mathrm{CH}_4$) $W_5 = 16.04246$。\n- 测试用例按相同的物种顺序列出 $\\tilde{Y}$ 如下：\n    1. 理想情况下的扰动：$\\tilde{Y}^{(1)} = [0.755, 0.205, 0.001, 0.039, 0.0009]$。\n    2. 因舍入误差导致微小负值，且总和接近1：$\\tilde{Y}^{(2)} = [0.7000000001, 0.2099999999, -10^{-12}, 0.09, 0]$。\n    3. 极端舍入崩溃（边界压力测试）：$\\tilde{Y}^{(3)} = [0, 0, 0, 0, 0]$。\n    4. 已接近可行，但总和有微小误差：$\\tilde{Y}^{(4)} = [0.7800000000001, 0.2099999999999, 0, 0.01, 0]$。\n    5. 高度倾斜且有微小负值：$\\tilde{Y}^{(5)} = [1 + 10^{-9}, -10^{-9}, 0, 0, 0]$。\n\n答案规范：\n- 对于每个测试用例，返回修正后的 $Y^\\star$ 和相应的 $W_{\\mathrm{mix}}$，如上所述。所有数字必须在输出行中以纯十进制浮点数形式报告，不带单位，但您的推导和程序必须将 $W_i$ 视为以 $\\mathrm{kg}/\\mathrm{kmol}$ 为单位，并以 $\\mathrm{kg}/\\mathrm{kmol}$ 为单位解释 $W_{\\mathrm{mix}}$。\n- 您的程序必须精确地生成一行，其中包含列表 $$\\left[\\left[Y^\\star_{(1)}, W_{\\mathrm{mix},(1)}\\right],\\left[Y^\\star_{(2)}, W_{\\mathrm{mix},(2)}\\right],\\left[Y^\\star_{(3)}, W_{\\mathrm{mix},(3)}\\right],\\left[Y^\\star_{(4)}, W_{\\mathrm{mix},(4)}\\right],\\left[Y^\\star_{(5)}, W_{\\mathrm{mix},(5)}\\right]\\right].$$\n\n可行性与覆盖范围：\n- 您的测试套件包括一般情况、含有微小负值的情况、完全崩溃的边界情况以及高度倾斜的情况。您必须确保您的归一化策略在所有情况下都能返回有效的质量分数 $Y^\\star$，满足 $\\sum_i Y^\\star_i = 1$ 和 $Y^\\star_i \\ge 0$。\n- 每个测试用例的输出必须是一个由浮点数列表和单个浮点数组成的列表，如规范所述，以确保每个测试用例的答案都是可量化且可自动验证的。",
            "solution": "修正受扰动的质量分数向量 $\\tilde{Y} \\in \\mathbb{R}^n$ 以满足物理约束的问题是计算建模中的一个经典问题，尤其在燃烧等质量守恒至关重要的领域。目标是找到一个修正后的向量 $Y^\\star$，它既要遵守定义标准单纯形 $\\Delta^{n-1}$ 的约束，又要与原始的受扰动向量 $\\tilde{Y}$ 尽可能“接近”。\n\n质量分数向量 $Y = [Y_1, \\dots, Y_n]^T$ 的约束条件是：\n1. 总和为一约束：$\\sum_{i=1}^n Y_i = 1$。\n2. 非负性约束：对所有 $i \\in \\{1, \\dots, n\\}$ 都有 $Y_i \\ge 0$。\n\n任务是找到一个向量 $Y^\\star$，在满足这些约束的条件下，使其与 $\\tilde{Y}$ 的偏差最小化。这可以正式地表述为一个优化问题。\n\n首先，我们必须选择一个度量来量化偏差 $\\|Y^\\star - \\tilde{Y}\\|$。最自然且数学上最方便的选择是标准欧几里得距离（或 $L_2$ 范数）。最小化距离 $\\|Y^\\star - \\tilde{Y}\\|_2$ 等价于最小化其平方 $\\|Y^\\star - \\tilde{Y}\\|_2^2$。这一选择是合理的，因为它产生了一个严格凸的二次目标函数，从而保证了解的唯一性。它平等地对待所有物种分数的扰动，而没有引入任何任意的加权。\n\n因此，优化问题就变成了在单纯形 $\\Delta^{n-1}$ 上寻找 $\\tilde{Y}$ 的欧几里得投影：\n$$\n\\begin{align*}\n\\underset{Y^\\star \\in \\mathbb{R}^n}{\\text{最小化}}  \\quad f(Y^\\star) = \\frac{1}{2} \\|Y^\\star - \\tilde{Y}\\|_2^2 = \\frac{1}{2} \\sum_{i=1}^n (Y^\\star_i - \\tilde{Y}_i)^2 \\\\\n\\text{约束条件}  \\quad \\sum_{i=1}^n Y^\\star_i = 1 \\\\\n \\quad Y^\\star_i \\ge 0 \\quad \\text{for } i = 1, \\dots, n\n\\end{align*}\n$$\n因子 $\\frac{1}{2}$ 的引入是为了在求导时便于代数计算。这是一个凸优化问题（一个二次规划问题），因为目标函数是严格凸的，且约束集是凸的。\n\n我们使用 Karush-Kuhn-Tucker (KKT) 条件来求解此问题。该问题的拉格朗日函数 $\\mathcal{L}$ 为：\n$$ \\mathcal{L}(Y^\\star, \\mu, \\lambda) = \\frac{1}{2} \\sum_{i=1}^n (Y^\\star_i - \\tilde{Y}_i)^2 - \\mu \\left( \\sum_{i=1}^n Y^\\star_i - 1 \\right) - \\sum_{i=1}^n \\lambda_i Y^\\star_i $$\n其中 $\\mu$ 是等式约束的拉格朗日乘子，$\\lambda_i$ 是非负性不等式约束的乘子。\n\n最优性的 KKT 条件如下：\n1. **平稳性 (Stationarity):** 对所有 $i \\in \\{1,\\dots,n\\}$，$\\frac{\\partial \\mathcal{L}}{\\partial Y^\\star_i} = Y^\\star_i - \\tilde{Y}_i - \\mu - \\lambda_i = 0$。这意味着 $Y^\\star_i = \\tilde{Y}_i + \\mu + \\lambda_i$。\n2. **原始可行性 (Primal Feasibility):** $\\sum_{i=1}^n Y^\\star_i = 1$ 且对所有 $i$ 都有 $Y^\\star_i \\ge 0$。\n3. **对偶可行性 (Dual Feasibility):** 对所有 $i$ 都有 $\\lambda_i \\ge 0$。\n4. **互补松弛性 (Complementary Slackness):** 对所有 $i$ 都有 $\\lambda_i Y^\\star_i = 0$。\n\n根据互补松弛性条件，对于每个物种 $i$，要么 $\\lambda_i=0$，要么 $Y^\\star_i=0$。\n- 如果 $Y^\\star_i > 0$，那么必须有 $\\lambda_i = 0$。平稳性条件简化为 $Y^\\star_i = \\tilde{Y}_i + \\mu$。$Y^\\star_i > 0$ 的条件意味着 $\\tilde{Y}_i + \\mu > 0$。\n- 如果 $Y^\\star_i = 0$，那么 $\\lambda_i \\ge 0$。平稳性条件给出 $0 = \\tilde{Y}_i+\\mu+\\lambda_i$。由于 $\\lambda_i \\ge 0$，这要求 $\\tilde{Y}_i + \\mu \\le 0$。\n\n结合这两种情况，我们得到解 $Y^\\star_i$ 的一个紧凑表达式：\n$$ Y^\\star_i = \\max(0, \\tilde{Y}_i + \\mu) $$\n这个简洁的结果表明，解可以通过对原始向量 $\\tilde{Y}$ 进行一个值为 $\\mu$ 的统一平移，然后进行零点截断得到。唯一未知的是拉格朗日乘子 $\\mu$。\n\n为了找到 $\\mu$，我们应用原始可行性约束 $\\sum_{i=1}^n Y^\\star_i = 1$：\n$$ \\sum_{i=1}^n \\max(0, \\tilde{Y}_i + \\mu) = 1 $$\n我们定义一个函数 $g(\\mu) = \\sum_{i=1}^n \\max(0, \\tilde{Y}_i + \\mu)$。我们需要找到 $g(\\mu) = 1$ 的根。函数 $g(\\mu)$ 是连续、分段线性且单调不减的。这保证了 $\\mu$ 的解存在且唯一。\n\n为了高效地求解 $\\mu$，我们将 $\\tilde{Y}$ 的分量按降序排序：$u_1 \\ge u_2 \\ge \\dots \\ge u_n$。条件 $\\tilde{Y}_i + \\mu > 0$ 对于那些 $\\tilde{Y}_i$ 值最大的分量将会成立。设 $\\rho$ 是满足此条件的元素数量。这 $\\rho$ 个元素构成了“激活集”，它们在最终解中的值将是正数。对于这 $\\rho$ 个元素，$Y^\\star_i = u_i + \\mu$，而对于剩下的 $n-\\rho$ 个元素，$Y^\\star_i = 0$。\n\n总和约束变为：\n$$ \\sum_{j=1}^\\rho (u_j + \\mu) = 1 \\implies \\left(\\sum_{j=1}^\\rho u_j\\right) + \\rho \\mu = 1 $$\n求解 $\\mu$ 可得：\n$$ \\mu = \\frac{1 - \\sum_{j=1}^\\rho u_j}{\\rho} $$\n正确的 $\\rho$ 值应使激活集保持一致，即对于 $j \\le \\rho$ 有 $u_j + \\mu > 0$，而对于 $j > \\rho$ 有 $u_j + \\mu \\le 0$。临界条件位于激活集的边界，即 $j=\\rho$。我们需要找到满足以下条件的最大整数 $\\rho \\in \\{1, \\dots, n\\}$：\n$$ u_\\rho + \\frac{1 - \\sum_{j=1}^\\rho u_j}{\\rho} > 0 $$\n这个不等式可以重写为 $\\rho u_\\rho + 1 - \\sum_{j=1}^\\rho u_j > 0$，或 $\\rho u_\\rho > \\left(\\sum_{j=1}^\\rho u_j\\right) - 1$。\n\n这导出了以下算法：\n1. 给定输入向量 $\\tilde{Y} \\in \\mathbb{R}^n$。\n2. 将 $\\tilde{Y}$ 按降序排序，得到新向量 $u = [u_1, u_2, \\dots, u_n]$。\n3. 计算 $u$ 的累积和，$S_j = \\sum_{i=1}^j u_i$。\n4. 找到最大的整数 $\\rho \\in \\{1,\\dots,n\\}$，使得对于 $j=1, \\dots, \\rho$，条件 $j u_j > S_j - 1$ 都成立。\n5. 利用这个 $\\rho$ 值，计算平移参数 $\\mu = (1 - S_\\rho) / \\rho$。\n6. 最终的修正向量 $Y^\\star$ 通过逐元素计算 $Y^\\star_i = \\max(0, \\tilde{Y}_i + \\mu)$ 得到。\n\n此算法的正确性证明必须确立解 $Y^\\star$ 的存在性、唯一性和可行性。\n- **存在性与唯一性：** 目标函数 $f(Y^\\star)$ 是严格凸且连续的。约束集，即单纯形 $\\Delta^{n-1}$，是 $\\mathbb{R}^n$ 中的一个非空、闭合、凸（因此是紧致）的子集。根据 Weierstrass 极值定理，最小值必然存在。目标函数 $f$ 的严格凸性保证了此最小值是唯一的。\n- **可行性：** 根据构造，$Y^\\star_i = \\max(0, \\tilde{Y}_i + \\mu)$ 保证了 $Y^\\star_i \\ge 0$。总和为 $\\sum_{i=1}^n Y^\\star_i = \\sum_{i=1}^n \\max(0, \\tilde{Y}_i + \\mu) = \\sum_{j=1}^\\rho (u_j + \\mu)$，其中第二个和是对应于激活集的已排序向量 $u$ 的元素之和。其计算结果为 $(\\sum_{j=1}^\\rho u_j) + \\rho \\mu = S_\\rho + \\rho \\frac{1 - S_\\rho}{\\rho} = S_\\rho + 1 - S_\\rho = 1$。因此，解 $Y^\\star$ 位于单纯形 $\\Delta^{n-1}$ 上。\n- **最优性：** 由于该优化问题是凸的，KKT 条件是全局最优解的充分必要条件。我们的推导找到了一个满足这些条件的唯一解，因此它就是唯一的全局最优解。\n\n最后，利用修正后的质量分数 $Y^\\star$，根据其定义计算混合物分子量 $W_\\mathrm{mix}$：\n$$ W_{\\mathrm{mix}} = \\left(\\sum_{i=1}^n \\frac{Y^\\star_i}{W_i}\\right)^{-1} $$\n其中 $W_i > 0$ 是各物种的分子量。由于 $Y^\\star_i \\ge 0$ 且 $\\sum_i Y^\\star_i=1$，并且不可能所有 $Y^\\star_i$ 都为0，因此分母是良定义且为正，从而确保 $W_\\mathrm{mix}$ 也是良定义且为正的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the mass fraction normalization problem for a suite of test cases.\n    \"\"\"\n\n    # Define the species molecular weights (kg/kmol) in a fixed order.\n    # N2, O2, CO2, H2O, CH4\n    molecular_weights = np.array([\n        28.0134,    # W_1 (N2)\n        31.9988,    # W_2 (O2)\n        44.0095,    # W_3 (CO2)\n        18.01528,   # W_4 (H2O)\n        16.04246    # W_5 (CH4)\n    ])\n\n    # Define the test cases for the perturbed mass fraction vector tilde_Y.\n    test_cases = [\n        # 1. Happy-path perturbation\n        np.array([0.755, 0.205, 0.001, 0.039, 0.0009]),\n        # 2. Tiny negative entry due to roundoff\n        np.array([0.7000000001, 0.2099999999, -1e-12, 0.09, 0.0]),\n        # 3. Extreme rounding collapse (boundary stress test)\n        np.array([0.0, 0.0, 0.0, 0.0, 0.0]),\n        # 4. Already near-feasible with tiny sum error\n        np.array([0.7800000000001, 0.2099999999999, 0.0, 0.01, 0.0]),\n        # 5. Highly skewed with a tiny negative entry\n        np.array([1.0 + 1e-9, -1e-9, 0.0, 0.0, 0.0])\n    ]\n\n    results = []\n    for y_tilde in test_cases:\n        # Normalize the mass fraction vector\n        y_star = _project_to_simplex(y_tilde)\n        \n        # Calculate the mixture molecular weight using the corrected mass fractions\n        # W_mix = (sum(Y_i / W_i))^-1\n        # To avoid division by zero if a W_i is zero (not the case here),\n        # we can filter. Since W_i are all > 0, this is robust.\n        # Likewise, if a Y_i is zero, its term is zero.\n        w_mix = 1.0 / np.sum(y_star / molecular_weights)\n        \n        # Store the results for this case. y_star is converted to a list for formatting.\n        results.append([y_star.tolist(), w_mix])\n\n    # Format the final output string exactly as specified in the problem statement.\n    # The format is [[Y*_1, W_mix_1], [Y*_2, W_mix_2], ...]\n    # where each Y* is a list of floats.\n    output_str = f\"[{','.join(f'[{str(y)},{w}]' for y, w in results)}]\"\n    print(output_str)\n\ndef _project_to_simplex(y_tilde: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Projects a vector onto the standard simplex using a fast projection algorithm.\n\n    This algorithm finds the Euclidean projection of a vector y_tilde onto the\n    simplex {x | sum(x) = 1, x_i >= 0}, which is equivalent to solving the\n    optimization problem:\n    \n    minimize   0.5 * ||x - y_tilde||^2\n    subject to sum(x) = 1, x_i >= 0\n    \n    Args:\n        y_tilde: A numpy array representing the vector to be projected.\n\n    Returns:\n        A numpy array representing the projected vector on the simplex.\n    \"\"\"\n    n = y_tilde.shape[0]\n    \n    # Sort the input vector in descending order.\n    u = np.sort(y_tilde)[::-1]\n    \n    # Calculate the cumulative sum of the sorted vector.\n    s = np.cumsum(u)\n    \n    # Find the largest index rho such that u_rho + (1 - s_rho) / rho > 0.\n    # This is implemented by finding all j that satisfy the condition and taking the max.\n    # The condition is vectorized as: u_j > (s_j - 1) / j for j=1...n\n    # Using 1-based indexing for j in the formula corresponds to 0-based index `j-1` in arrays.\n    j_indices = np.arange(1, n + 1)\n    condition = u > (s - 1) / j_indices\n    \n    # The set of indices j for which the condition holds is never empty because for j=1,\n    # u_1 > (u_1 - 1)/1 is 0 > -1, which is always true.\n    # So we can safely access the last element.\n    rho = np.where(condition)[0][-1] + 1\n    \n    # Calculate the Lagrange multiplier (the shift value mu).\n    # mu = (1 - s[rho-1]) / rho, where s[rho-1] is the sum of the top rho elements.\n    mu = (1 - s[rho - 1]) / rho\n    \n    # Apply the shift and clip at zero to get the projected vector.\n    y_star = np.maximum(0, y_tilde + mu)\n    \n    return y_star\n\nsolve()\n```"
        }
    ]
}