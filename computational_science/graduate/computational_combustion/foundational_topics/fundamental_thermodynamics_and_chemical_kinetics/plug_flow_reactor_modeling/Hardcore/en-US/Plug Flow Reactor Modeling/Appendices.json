{
    "hands_on_practices": [
        {
            "introduction": "Mastering Plug Flow Reactor (PFR) modeling begins with a firm grasp of its foundational design equation. This exercise reinforces first principles by guiding you through the derivation of the PFR mole balance in terms of conversion, starting from a differential slice of the reactor. By applying this equation to simple first-order and second-order irreversible reactions, you will gain crucial intuition on how reaction kinetics directly impacts the required reactor volume for a target conversion .",
            "id": "3872934",
            "problem": "A liquid-phase, isothermal, irreversible isomerization of species $A$ to $B$ is carried out in a Plug Flow Reactor (PFR). The feed contains only $A$ at a molar flow rate $F_{A0}$ and concentration $C_{A0}$. The density is constant, volumetric flow is constant, there are no side reactions, and axial dispersion is negligible. Depending on the candidate microkinetic mechanism, the rate-of-disappearance of $A$ may be first-order or second-order in $A$:\n- First-order hypothesis: $-r_{A} = k_{1} C_{A}$ with $k_{1}$ a constant.\n- Second-order hypothesis: $-r_{A} = k_{2} C_{A}^{2}$ with $k_{2}$ a constant.\n\nStarting from the steady-state mole balance on a differential reactor slice and the definition of conversion, derive the PFR design equation $\\mathrm{d}X/\\mathrm{d}V = -r_{A}/F_{A0}$. Then, using the liquid-phase, constant-density relation $C_{A} = C_{A0}(1-X)$, integrate to obtain the reactor volume $V$ as a function of conversion $X$ under each kinetic hypothesis. For a target conversion $X = 0.85$ at $T$ constant, feed molar flow $F_{A0} = 10\\ \\mathrm{kmol}/\\mathrm{h}$, feed concentration $C_{A0} = 1.0\\ \\mathrm{kmol}/\\mathrm{m}^{3}$, first-order rate constant $k_{1} = 0.75\\ \\mathrm{h}^{-1}$, and second-order rate constant $k_{2} = 1.6\\ \\mathrm{m}^{3}/(\\mathrm{kmol}\\cdot\\mathrm{h})$, compute the dimensionless ratio of reactor volumes $V_{\\text{second}}/V_{\\text{first}}$ required to achieve $X = 0.85$ under the two kinetic hypotheses. Round your final ratio to four significant figures and report it as a pure number with no units.",
            "solution": "The problem statement is evaluated to be scientifically grounded, well-posed, objective, complete, and consistent. It represents a standard problem in chemical reactor design. Therefore, a full solution is warranted.\n\nThe solution proceeds in three stages as requested: first, the derivation of the Plug Flow Reactor (PFR) design equation in terms of conversion; second, the integration of this equation for first-order and second-order kinetics to find the required reactor volume $V$ as a function of conversion $X$; and third, the calculation of the numerical ratio of the volumes for the two kinetic models under the specified conditions.\n\n**1. Derivation of the PFR Design Equation**\n\nWe begin with a mole balance on species $A$ over a differential volume element $\\mathrm{d}V$ of the PFR operating at steady state. The general mole balance equation is:\n$$\n\\text{Flow in} - \\text{Flow out} + \\text{Generation} = \\text{Accumulation}\n$$\nFor a differential slice from volume $V$ to $V + \\mathrm{d}V$, and for species $A$, this translates to:\n$$\nF_{A}|_{V} - F_{A}|_{V+\\mathrm{d}V} + r_{A} \\mathrm{d}V = 0\n$$\nwhere $F_A$ is the molar flow rate of $A$ and $r_A$ is the rate of formation of $A$ per unit volume. The accumulation term is zero due to the steady-state assumption.\nThe term $F_{A}|_{V+\\mathrm{d}V}$ can be expressed as a Taylor series expansion around $V$: $F_{A}|_{V+\\mathrm{d}V} = F_{A}|_{V} + \\frac{\\mathrm{d}F_A}{\\mathrm{d}V}\\mathrm{d}V + \\dots$. Neglecting higher-order terms, the balance becomes:\n$$\nF_{A}|_{V} - \\left( F_{A}|_{V} + \\frac{\\mathrm{d}F_A}{\\mathrm{d}V}\\mathrm{d}V \\right) + r_{A} \\mathrm{d}V = 0\n$$\n$$\n-\\frac{\\mathrm{d}F_A}{\\mathrm{d}V}\\mathrm{d}V + r_{A} \\mathrm{d}V = 0\n$$\nDividing by $\\mathrm{d}V$ gives the PFR design equation in terms of molar flow rate:\n$$\n\\frac{\\mathrm{d}F_A}{\\mathrm{d}V} = r_A\n$$\nThe fractional conversion $X$ of reactant $A$ is defined as the fraction of the initial moles of $A$ that have reacted:\n$$\nX = \\frac{F_{A0} - F_A}{F_{A0}}\n$$\nwhere $F_{A0}$ is the molar feed rate of $A$ at the reactor inlet ($V=0$). Rearranging for $F_A$ gives:\n$$\nF_A = F_{A0}(1-X)\n$$\nSince $F_{A0}$ is a constant, differentiating $F_A$ with respect to the reactor volume $V$ yields:\n$$\n\\frac{\\mathrm{d}F_A}{\\mathrm{d}V} = \\frac{\\mathrm{d}}{\\mathrm{d}V}[F_{A0}(1-X)] = -F_{A0}\\frac{\\mathrm{d}X}{\\mathrm{d}V}\n$$\nSubstituting this result into the mole balance $\\frac{\\mathrm{d}F_A}{\\mathrm{d}V} = r_A$ gives:\n$$\n-F_{A0}\\frac{\\mathrm{d}X}{\\mathrm{d}V} = r_A\n$$\nFinally, we rearrange to obtain the requested form of the PFR design equation in terms of conversion $X$ and the rate of disappearance of $A$, $-r_A = -r_{A, \\text{formation}} = r_{A, \\text{disappearance}}$:\n$$\n\\frac{\\mathrm{d}X}{\\mathrm{d}V} = \\frac{-r_A}{F_{A0}}\n$$\nThis completes the first part of the derivation.\n\n**2. Reactor Volume as a Function of Conversion**\n\nFor a liquid-phase reaction with constant density, the volumetric flow rate $v$ is constant. The concentration of species $A$, $C_A$, is related to its molar flow rate $F_A$ by $C_A = F_A/v$. At the inlet, $C_{A0} = F_{A0}/v_{0}$. Since $v=v_0$, we can write:\n$$\nC_A = \\frac{F_A}{v_0} = \\frac{F_{A0}(1-X)}{v_0} = C_{A0}(1-X)\n$$\nThis confirms the relation provided in the problem statement. Now we integrate the design equation for each kinetic hypothesis.\n\nThe design equation can be separated and integrated to find the volume $V$ required to achieve a conversion $X$:\n$$\nV = F_{A0} \\int_{0}^{X} \\frac{1}{-r_A} \\mathrm{d}X'\n$$\n\n**First-Order Hypothesis:**\nThe rate law is $-r_A = k_1 C_A$. Substituting the concentration expression, we get:\n$$\n-r_A = k_1 C_{A0}(1-X)\n$$\nSubstituting this into the integral form of the design equation:\n$$\nV_{\\text{first}} = F_{A0} \\int_{0}^{X} \\frac{1}{k_1 C_{A0}(1-X')} \\mathrm{d}X'\n$$\nSince $F_{A0}$, $k_1$, and $C_{A0}$ are constants, we can take them out of the integral:\n$$\nV_{\\text{first}} = \\frac{F_{A0}}{k_1 C_{A0}} \\int_{0}^{X} \\frac{1}{1-X'} \\mathrm{d}X' = \\frac{F_{A0}}{k_1 C_{A0}} [-\\ln(1-X')]_{0}^{X}\n$$\n$$\nV_{\\text{first}} = \\frac{F_{A0}}{k_1 C_{A0}} [-\\ln(1-X) - (-\\ln(1-0))] = -\\frac{F_{A0}}{k_1 C_{A0}} \\ln(1-X) = \\frac{F_{A0}}{k_1 C_{A0}} \\ln\\left(\\frac{1}{1-X}\\right)\n$$\n\n**Second-Order Hypothesis:**\nThe rate law is $-r_A = k_2 C_A^2$. Substituting the concentration expression:\n$$\n-r_A = k_2 (C_{A0}(1-X))^2 = k_2 C_{A0}^2 (1-X)^2\n$$\nSubstituting this into the integral design equation:\n$$\nV_{\\text{second}} = F_{A0} \\int_{0}^{X} \\frac{1}{k_2 C_{A0}^2 (1-X')^2} \\mathrm{d}X'\n$$\nTaking the constants out of the integral:\n$$\nV_{\\text{second}} = \\frac{F_{A0}}{k_2 C_{A0}^2} \\int_{0}^{X} (1-X')^{-2} \\mathrm{d}X' = \\frac{F_{A0}}{k_2 C_{A0}^2} \\left[\\frac{1}{1-X'}\\right]_{0}^{X}\n$$\n$$\nV_{\\text{second}} = \\frac{F_{A0}}{k_2 C_{A0}^2} \\left(\\frac{1}{1-X} - \\frac{1}{1-0}\\right) = \\frac{F_{A0}}{k_2 C_{A0}^2} \\left(\\frac{1 - (1-X)}{1-X}\\right)\n$$\n$$\nV_{\\text{second}} = \\frac{F_{A0}}{k_2 C_{A0}^2} \\left(\\frac{X}{1-X}\\right)\n$$\n\n**3. Calculation of the Ratio of Reactor Volumes**\n\nWe now compute the ratio $V_{\\text{second}}/V_{\\text{first}}$ using the derived expressions:\n$$\n\\frac{V_{\\text{second}}}{V_{\\text{first}}} = \\frac{\\frac{F_{A0}}{k_2 C_{A0}^2} \\left(\\frac{X}{1-X}\\right)}{\\frac{F_{A0}}{k_1 C_{A0}} \\ln\\left(\\frac{1}{1-X}\\right)}\n$$\nSimplifying the expression by canceling terms ($F_{A0}$ and one factor of $C_{A0}$):\n$$\n\\frac{V_{\\text{second}}}{V_{\\text{first}}} = \\frac{k_1}{k_2 C_{A0}} \\frac{\\left(\\frac{X}{1-X}\\right)}{\\ln\\left(\\frac{1}{1-X}\\right)}\n$$\nThis is the final symbolic expression for the ratio. Now, we substitute the given numerical values:\n- Target conversion $X = 0.85$.\n- First-order rate constant $k_1 = 0.75\\ \\mathrm{h}^{-1}$.\n- Second-order rate constant $k_2 = 1.6\\ \\mathrm{m}^{3}/(\\mathrm{kmol}\\cdot\\mathrm{h})$.\n- Feed concentration $C_{A0} = 1.0\\ \\mathrm{kmol}/\\mathrm{m}^{3}$.\n\nFirst, calculate the intermediate terms:\n$$\n1 - X = 1 - 0.85 = 0.15\n$$\n$$\n\\frac{X}{1-X} = \\frac{0.85}{0.15} = \\frac{17}{3}\n$$\n$$\n\\frac{1}{1-X} = \\frac{1}{0.15} = \\frac{20}{3}\n$$\n$$\n\\ln\\left(\\frac{1}{1-X}\\right) = \\ln\\left(\\frac{20}{3}\\right)\n$$\nNow, substitute these into the ratio expression along with the constants:\n$$\n\\frac{V_{\\text{second}}}{V_{\\text{first}}} = \\frac{0.75\\ \\mathrm{h}^{-1}}{(1.6\\ \\mathrm{m}^{3}/(\\mathrm{kmol}\\cdot\\mathrm{h})) (1.0\\ \\mathrm{kmol}/\\mathrm{m}^{3})} \\frac{\\frac{17}{3}}{\\ln\\left(\\frac{20}{3}\\right)}\n$$\nThe units in the first term cancel out, as expected for a dimensionless ratio:\n$$\n\\frac{V_{\\text{second}}}{V_{\\text{first}}} = \\frac{0.75}{1.6} \\frac{\\frac{17}{3}}{\\ln\\left(\\frac{20}{3}\\right)} = 0.46875 \\times \\frac{5.666...}{1.8971199...}\n$$\n$$\n\\frac{V_{\\text{second}}}{V_{\\text{first}}} = 0.46875 \\times 2.986980... \\approx 1.399678...\n$$\nRounding the final result to four significant figures gives $1.400$.",
            "answer": "$$\n\\boxed{1.400}\n$$"
        },
        {
            "introduction": "Real-world chemical reactors are rarely isothermal, making the coupling of mass and energy balances a critical skill in computational modeling. This practice moves beyond simplified assumptions by exploring an adiabatic PFR where a reversible, endothermic reaction occurs, introducing the interplay between reaction kinetics and thermodynamics via the van't Hoff equation. Numerically solving this coupled system of ordinary differential equations will allow you to predict the temperature profile and identify phenomena like an equilibrium-limited \"stall,\" where the reaction progress is limited by the falling temperature .",
            "id": "3894917",
            "problem": "Consider a steady-state, adiabatic Plug Flow Reactor (PFR) performing a single, elementary, reversible, endothermic reaction between two gas-phase species, where $A \\rightleftharpoons B$. The reactor has constant cross-sectional area and operates at constant pressure. The feed may contain an inert species $I$. The total molar flow $F_{\\text{tot}}$ is the sum of the molar flows of $A$, $B$, and $I$. The following fundamental bases must be used to derive the model:\n- The one-dimensional, steady-state molar balance for species $i$ in a PFR is $dF_i/dz = \\nu_i r V'$ where $z$ is the axial coordinate in meters, $\\nu_i$ is the stoichiometric coefficient of species $i$, $r$ is the rate of progress of reaction in $\\text{mol}/(\\text{m}^3\\cdot\\text{s})$, and $V' = A_c$ is the reactor cross-sectional area in $\\text{m}^2$.\n- The one-dimensional, steady-state energy balance for an adiabatic PFR is $dT/dz = -\\Delta H_{\\text{rxn}}\\, r\\, A_c / \\left(\\sum_j F_j C_{p,j}\\right)$, where $T$ is temperature in $\\text{K}$, $\\Delta H_{\\text{rxn}}  0$ is the endothermic reaction enthalpy in $\\text{J}/\\text{mol}$, $C_{p,j}$ is the constant-pressure molar heat capacity of species $j$ in $\\text{J}/(\\text{mol}\\cdot\\text{K})$, and the sum runs over all species present.\n- The ideal gas law implies $C_{\\text{tot}} = P/(R T)$ for the total molar concentration in $\\text{mol}/\\text{m}^3$, with $P$ in $\\text{Pa}$ and the universal gas constant $R$ in $\\text{J}/(\\text{mol}\\cdot\\text{K})$. The partial concentrations are $C_i = y_i C_{\\text{tot}}$ with $y_i = F_i/F_{\\text{tot}}$.\n- The rate law for an elementary reversible reaction is $r = k_f(T) C_A - k_r(T) C_B$ with Arrhenius kinetics $k_f(T) = k_{0,f} \\exp\\!\\left(-E_f/(R T)\\right)$, where $k_{0,f}$ is a pre-exponential factor in $\\text{s}^{-1}$ and $E_f$ is the forward activation energy in $\\text{J}/\\text{mol}$. Thermodynamic consistency requires $k_r(T) = k_f(T)/K_{\\text{eq}}(T)$.\n- The van't Hoff relation for the equilibrium constant $K_{\\text{eq}}(T)$ is $d\\ln K_{\\text{eq}}/dT = \\Delta H_{\\text{rxn}}/(R T^2)$, which integrates to $\\ln K_{\\text{eq}}(T) = \\ln K_{\\text{ref}} + \\Delta H_{\\text{rxn}}/R \\left(1/T_{\\text{ref}} - 1/T\\right)$ when $K_{\\text{eq}}(T_{\\text{ref}}) = K_{\\text{ref}}$ is known at a reference temperature $T_{\\text{ref}}$.\n- The reaction quotient under the ideal gas approximation is $Q = y_B/y_A$.\n\nDefine a \"near-equilibrium stall\" position $z^\\star$ as the smallest axial position where the dimensionless closeness metric satisfies $\\left|\\ln\\!\\left(Q/K_{\\text{eq}}(T)\\right)\\right| \\le \\tau$, with a prescribed tolerance $\\tau  0$. If no such position occurs within the reactor length, report $z^\\star = -1.0$.\n\nYour task is to:\n1. Derive the coupled differential equations from these bases for $F_A(z)$, $F_B(z)$, and $T(z)$ in terms of the parameters, and articulate how the temperature-dependent equilibrium impacts the reverse rate through $k_r(T) = k_f(T)/K_{\\text{eq}}(T)$.\n2. Implement a robust numerical solver that integrates the coupled system along $z$ from the inlet to a specified maximum length, detecting the first axial position $z^\\star$ where $\\left|\\ln\\!\\left(Q/K_{\\text{eq}}(T)\\right)\\right| \\le \\tau$. Use an event detection strategy that is numerically well-posed when $y_A$ or $y_B$ are very small.\n3. For each test case below, compute $z^\\star$ in meters, rounded to six decimal places. If no stall is detected within the reactor length, return $-1.000000$.\n\nUse the universal gas constant $R = 8.31446261815324\\,\\text{J}/(\\text{mol}\\cdot\\text{K})$.\n\nTest Suite:\n- Case 1 (endothermic with inert, strong temperature drop):\n  - $A_c = 0.01\\,\\text{m}^2$\n  - $P = 2.0\\times 10^5\\,\\text{Pa}$\n  - $T_{\\text{in}} = 800.0\\,\\text{K}$\n  - $F_{A,0} = 1.0\\,\\text{mol}/\\text{s}$, $F_{B,0} = 0.0\\,\\text{mol}/\\text{s}$, $F_{I,0} = 2.0\\,\\text{mol}/\\text{s}$\n  - $C_{p,A} = 35.0\\,\\text{J}/(\\text{mol}\\cdot\\text{K})$, $C_{p,B} = 35.0\\,\\text{J}/(\\text{mol}\\cdot\\text{K})$, $C_{p,I} = 30.0\\,\\text{J}/(\\text{mol}\\cdot\\text{K})$\n  - $\\Delta H_{\\text{rxn}} = 5.0\\times 10^4\\,\\text{J}/\\text{mol}$\n  - $k_{0,f} = 2.0\\times 10^5\\,\\text{s}^{-1}$, $E_f = 8.0\\times 10^4\\,\\text{J}/\\text{mol}$\n  - $K_{\\text{ref}} = 3.0$ at $T_{\\text{ref}} = 800.0\\,\\text{K}$\n  - $\\tau = 0.02$\n  - $z_{\\max} = 5.0\\,\\text{m}$\n- Case 2 (endothermic but mild temperature dependence, no inert):\n  - $A_c = 0.02\\,\\text{m}^2$\n  - $P = 1.5\\times 10^5\\,\\text{Pa}$\n  - $T_{\\text{in}} = 700.0\\,\\text{K}$\n  - $F_{A,0} = 2.0\\,\\text{mol}/\\text{s}$, $F_{B,0} = 0.5\\,\\text{mol}/\\text{s}$, $F_{I,0} = 0.0\\,\\text{mol}/\\text{s}$\n  - $C_{p,A} = 33.0\\,\\text{J}/(\\text{mol}\\cdot\\text{K})$, $C_{p,B} = 33.0\\,\\text{J}/(\\text{mol}\\cdot\\text{K})$, $C_{p,I} = 0.0\\,\\text{J}/(\\text{mol}\\cdot\\text{K})$\n  - $\\Delta H_{\\text{rxn}} = 8.0\\times 10^3\\,\\text{J}/\\text{mol}$\n  - $k_{0,f} = 1.0\\times 10^5\\,\\text{s}^{-1}$, $E_f = 7.0\\times 10^4\\,\\text{J}/\\text{mol}$\n  - $K_{\\text{ref}} = 2.0$ at $T_{\\text{ref}} = 700.0\\,\\text{K}$\n  - $\\tau = 0.02$\n  - $z_{\\max} = 10.0\\,\\text{m}$\n- Case 3 (same as Case 1 but stringent stall tolerance):\n  - $A_c = 0.01\\,\\text{m}^2$\n  - $P = 2.0\\times 10^5\\,\\text{Pa}$\n  - $T_{\\text{in}} = 800.0\\,\\text{K}$\n  - $F_{A,0} = 1.0\\,\\text{mol}/\\text{s}$, $F_{B,0} = 0.0\\,\\text{mol}/\\text{s}$, $F_{I,0} = 2.0\\,\\text{mol}/\\text{s}$\n  - $C_{p,A} = 35.0\\,\\text{J}/(\\text{mol}\\cdot\\text{K})$, $C_{p,B} = 35.0\\,\\text{J}/(\\text{mol}\\cdot\\text{K})$, $C_{p,I} = 30.0\\,\\text{J}/(\\text{mol}\\cdot\\text{K})$\n  - $\\Delta H_{\\text{rxn}} = 5.0\\times 10^4\\,\\text{J}/\\text{mol}$\n  - $k_{0,f} = 2.0\\times 10^5\\,\\text{s}^{-1}$, $E_f = 8.0\\times 10^4\\,\\text{J}/\\text{mol}$\n  - $K_{\\text{ref}} = 3.0$ at $T_{\\text{ref}} = 800.0\\,\\text{K}$\n  - $\\tau = 1.0\\times 10^{-4}$\n  - $z_{\\max} = 5.0\\,\\text{m}$\n\nYour program should produce a single line of output containing the three computed stall positions in meters as a comma-separated list enclosed in square brackets (e.g., \"[z1,z2,z3]\"), with each number rounded to six decimal places and expressed in meters. The output must be exactly in this format.",
            "solution": "The user has requested the derivation and implementation of a numerical model for a steady-state, adiabatic plug flow reactor (PFR) to determine a \"near-equilibrium stall\" position, $z^\\star$.\n\n### Step 1: Problem Validation\n\nThe problem statement has been critically evaluated against the specified criteria.\n\n-   **Givens Extraction**: All data, variables, and governing equations have been extracted verbatim from the problem description. These include the molar balance, energy balance, ideal gas law, rate law, Arrhenius kinetics, van't Hoff relation, and the definition of the stall condition. All parameters for three distinct test cases are provided.\n-   **Validation**:\n    1.  **Scientific Grounding**: The problem is based on fundamental and universally accepted principles of chemical reaction engineering. The PFR model equations, kinetic expressions (Arrhenius), and thermodynamic relationships (van't Hoff) are standard and correctly stated. The problem is scientifically sound.\n    2.  **Well-Posedness**: The problem describes a system of coupled, first-order ordinary differential equations (ODEs) with well-defined initial conditions. This constitutes a standard initial value problem (IVP). The functions defining the ODEs are continuous, ensuring that a unique solution exists. The \"stall\" condition is defined as a precise event for the ODE solver, making the overall problem well-posed.\n    3.  **Objectivity**: The problem is formulated using precise, unambiguous mathematical and scientific language. It is free from subjective claims.\n    4.  **Completeness and Consistency**: The problem is self-contained. All necessary parameters, constants, and initial conditions for each test case are provided. There are no contradictions in the provided information.\n    5.  **Numerical Considerations**: The problem correctly anticipates a potential numerical issue with the event function $\\left|\\ln(Q/K_{\\text{eq}})\\right|$ when a species concentration is zero (e.g., at the inlet). It specifically requests a \"numerically well-posed\" strategy. This is a standard challenge in reactor modeling, and handling it is part of a robust solution.\n\n-   **Verdict**: The problem is **valid**. It is a well-formulated, non-trivial problem in computational chemical engineering that requires the application of established principles and numerical methods.\n\n### Step 2: Derivation of the Governing Equations\n\nThe state of the system along the axial coordinate $z$ can be described by the molar flow rates $F_i(z)$ and the temperature $T(z)$. For the reaction $A \\rightleftharpoons B$, the stoichiometric coefficients are $\\nu_A = -1$ and $\\nu_B = +1$. The inert species $I$ has $\\nu_I = 0$.\n\n1.  **Molar Balances and Stoichiometry**:\n    The molar balance for species $i$ is $dF_i/dz = \\nu_i r A_c$.\n    -   For species A: $dF_A/dz = (-1) r A_c$\n    -   For species B: $dF_B/dz = (+1) r A_c$\n    -   For species I: $dF_I/dz = (0) r A_c = 0$, which implies $F_I(z) = F_{I,0}$ (constant).\n\n    Summing the balances for $A$ and $B$ gives $d(F_A + F_B)/dz = 0$. Integrating yields $F_A(z) + F_B(z) = F_{A,0} + F_{B,0}$, a constant. This allows us to express $F_B$ algebraically in terms of $F_A$:\n    $$F_B(z) = F_{A,0} + F_{B,0} - F_A(z)$$\n    The total molar flow rate is also constant: $F_{\\text{tot}} = F_A(z) + F_B(z) + F_I(z) = F_{A,0} + F_{B,0} + F_{I,0}$.\n\n    Therefore, we only need to solve one ODE for the molar flows, for instance, for $F_A$:\n    $$ \\frac{dF_A}{dz} = -r A_c $$\n\n2.  **Reaction Rate ($r$) Expression**:\n    The rate law is $r = k_f(T) C_A - k_r(T) C_B$. Using thermodynamic consistency, $k_r(T) = k_f(T)/K_{\\text{eq}}(T)$, the rate becomes:\n    $$ r = k_f(T) \\left( C_A - \\frac{C_B}{K_{\\text{eq}}(T)} \\right) $$\n    Under the ideal gas law, the concentration of species $j$ is $C_j = y_j C_{\\text{tot}} = \\frac{F_j}{F_{\\text{tot}}} \\frac{P}{RT}$. Substituting this into the rate expression:\n    $$ r = k_f(T) \\frac{P}{RT F_{\\text{tot}}} \\left( F_A - \\frac{F_B}{K_{\\text{eq}}(T)} \\right) $$\n    where:\n    -   The forward rate constant $k_f(T)$ is given by the Arrhenius equation: $k_f(T) = k_{0,f} \\exp\\left(-\\frac{E_f}{RT}\\right)$.\n    -   The equilibrium constant $K_{\\text{eq}}(T)$ is given by the integrated van't Hoff equation: $K_{\\text{eq}}(T) = \\exp\\left( \\ln K_{\\text{ref}} + \\frac{\\Delta H_{\\text{rxn}}}{R} \\left(\\frac{1}{T_{\\text{ref}}} - \\frac{1}{T}\\right) \\right)$.\n\n3.  **Energy Balance**:\n    The energy balance for an adiabatic PFR is given as:\n    $$ \\frac{dT}{dz} = -\\frac{\\Delta H_{\\text{rxn}}\\, r\\, A_c}{\\sum_j F_j C_{p,j}} $$\n    The denominator is the total heat capacity flow rate: $\\sum_j F_j C_{p,j} = F_A C_{p,A} + F_B C_{p,B} + F_I C_{p,I}$. This term depends on the state variables $F_A$ (since $F_B$ depends on $F_A$).\n\n4.  **Final System of ODEs**:\n    We have a system of two coupled first-order ODEs for the state vector $\\mathbf{y}(z) = [F_A(z), T(z)]^T$:\n    $$ \\frac{dF_A}{dz} = -r A_c $$\n    $$ \\frac{dT}{dz} = -\\frac{\\Delta H_{\\text{rxn}}\\, r\\, A_c}{F_A C_{p,A} + (F_{A,0} + F_{B,0} - F_A) C_{p,B} + F_{I,0} C_{p,I}} $$\n    where $r$ is a function of $F_A$ and $T$ as defined above. The initial conditions are $F_A(0) = F_{A,0}$ and $T(0) = T_{\\text{in}}$.\n\n### Step 3: Numerical Implementation Strategy\n\n1.  **ODE Solver**: The problem will be solved by numerically integrating the system of ODEs using `scipy.integrate.solve_ivp`. This function is well-suited for this task as it is robust and provides a mechanism for event detection.\n\n2.  **State Vector**: The state vector used by the solver will be `y = [F_A, T]`.\n\n3.  **Event Detection for Stall Condition**: The stall position $z^\\star$ is defined by the condition $|\\ln(Q/K_{\\text{eq}})| \\le \\tau$, where $Q = y_B/y_A = F_B/F_A$. This is equivalent to finding the smallest root $z  0$ of the event function:\n    $$ g(z, \\mathbf{y}) = \\left|\\ln\\left(\\frac{F_B(z)}{F_A(z)} / K_{\\text{eq}}(T(z))\\right)\\right| - \\tau = 0 $$\n    -   **Numerical Stability**: At the reactor inlet ($z=0$), if $F_{B,0}=0$, then $Q=0$ and $\\ln(Q)$ is undefined. The event function must be implemented to handle this case gracefully. A simple guard, checking if $F_B$ is effectively zero and, if so, returning a large positive value, prevents the function from being triggered at the start.\n    -   **Event Direction**: As the reaction proceeds from an initial state far from equilibrium, the term $|\\ln(Q/K_{\\text{eq}})|$ decreases from a large value. The event occurs when this value crosses $\\tau$ from above. Therefore, the solver should look for a zero-crossing in the negative direction (`direction = -1`).\n    -   **Terminal Event**: Once the stall condition is met, the integration should stop. This is accomplished by setting the `terminal` attribute of the event function to `True`.\n\n4.  **Algorithm**:\n    -   For each test case, all parameters are collected.\n    -   An ODE function `dydz(z, y, params)` is defined to compute the derivatives $[dF_A/dz, dT/dz]$.\n    -   An event function `event_stall(z, y, params)` is defined to compute $g(z, \\mathbf{y})$.\n    -   `solve_ivp` is called with the initial conditions `y0 = [F_A0, T_in]`, integration span `[0, z_max]`, the ODE and event functions, and appropriate numerical tolerances.\n    -   If the solver successfully finds an event, the first event time `sol.t_events[0][0]` is taken as $z^\\star$.\n    -   If no event is found within $[0, z_{\\max}]$, $z^\\star$ is assigned the value $-1.0$.\n    -   The result is rounded to six decimal places and stored.\n\nThe final Python implementation encapsulates this logic.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves for the near-equilibrium stall position in a PFR for given test cases.\n    \"\"\"\n    R_GAS = 8.31446261815324\n\n    test_cases = [\n        # Case 1 (endothermic with inert, strong temperature drop):\n        {\n            \"Ac\": 0.01, \"P\": 2.0e5, \"T_in\": 800.0,\n            \"F_A0\": 1.0, \"F_B0\": 0.0, \"F_I0\": 2.0,\n            \"CpA\": 35.0, \"CpB\": 35.0, \"CpI\": 30.0,\n            \"dH_rxn\": 5.0e4, \"k0f\": 2.0e5, \"Ef\": 8.0e4,\n            \"K_ref\": 3.0, \"T_ref\": 800.0,\n            \"tau\": 0.02, \"z_max\": 5.0\n        },\n        # Case 2 (endothermic but mild temperature dependence, no inert):\n        {\n            \"Ac\": 0.02, \"P\": 1.5e5, \"T_in\": 700.0,\n            \"F_A0\": 2.0, \"F_B0\": 0.5, \"F_I0\": 0.0,\n            \"CpA\": 33.0, \"CpB\": 33.0, \"CpI\": 0.0,\n            \"dH_rxn\": 8.0e3, \"k0f\": 1.0e5, \"Ef\": 7.0e4,\n            \"K_ref\": 2.0, \"T_ref\": 700.0,\n            \"tau\": 0.02, \"z_max\": 10.0\n        },\n        # Case 3 (same as Case 1 but stringent stall tolerance):\n        {\n            \"Ac\": 0.01, \"P\": 2.0e5, \"T_in\": 800.0,\n            \"F_A0\": 1.0, \"F_B0\": 0.0, \"F_I0\": 2.0,\n            \"CpA\": 35.0, \"CpB\": 35.0, \"CpI\": 30.0,\n            \"dH_rxn\": 5.0e4, \"k0f\": 2.0e5, \"Ef\": 8.0e4,\n            \"K_ref\": 3.0, \"T_ref\": 800.0,\n            \"tau\": 1.0e-4, \"z_max\": 5.0\n        }\n    ]\n\n    def dydz(z, y, p):\n        \"\"\"\n        Defines the system of ordinary differential equations for the PFR model.\n        y = [F_A, T]\n        \"\"\"\n        F_A, T = y\n\n        # State variable protection\n        if T = 0: return [0.0, 0.0]\n        F_A = max(0.0, F_A)\n        \n        # Algebraic relations\n        F_B = p[\"F_A0\"] + p[\"F_B0\"] - F_A\n        F_B = max(0.0, F_B)\n        F_tot = p[\"F_A0\"] + p[\"F_B0\"] + p[\"F_I0\"]\n\n        # Temperature-dependent parameters\n        k_f = p[\"k0f\"] * np.exp(-p[\"Ef\"] / (R_GAS * T))\n        \n        log_K_ref = np.log(p[\"K_ref\"])\n        ln_K_eq = log_K_ref + (p[\"dH_rxn\"] / R_GAS) * (1.0 / p[\"T_ref\"] - 1.0 / T)\n        K_eq = np.exp(ln_K_eq)\n\n        # Rate of reaction\n        r = k_f * (p[\"P\"] / (R_GAS * T * F_tot)) * (F_A - F_B / K_eq)\n\n        # Derivatives\n        dFA_dz = -r * p[\"Ac\"]\n        \n        sum_FCp = F_A * p[\"CpA\"] + F_B * p[\"CpB\"] + p[\"F_I0\"] * p[\"CpI\"]\n        if abs(sum_FCp)  1e-12:\n            dT_dz = 0.0\n        else:\n            dT_dz = -p[\"dH_rxn\"] * r * p[\"Ac\"] / sum_FCp\n        \n        return [dFA_dz, dT_dz]\n\n    def event_stall(z, y, p):\n        \"\"\"\n        Event function to detect near-equilibrium stall.\n        Triggers when |ln(Q/K_eq)| - tau = 0.\n        \"\"\"\n        F_A, T = y\n        \n        # Guard against undefined logs at z=0 or due to numerical error\n        if F_A = 1e-20 or T = 0: return 1.0\n        \n        F_B = p[\"F_A0\"] + p[\"F_B0\"] - F_A\n        if F_B = 1e-20: return 1.0\n        \n        # Reaction quotient\n        Q = F_B / F_A\n        \n        # Equilibrium constant\n        log_K_ref = np.log(p[\"K_ref\"])\n        ln_K_eq = log_K_ref + (p[\"dH_rxn\"] / R_GAS) * (1.0 / p[\"T_ref\"] - 1.0 / T)\n        K_eq = np.exp(ln_K_eq)\n\n        # Event function value\n        value = np.abs(np.log(Q / K_eq)) - p[\"tau\"]\n        return value\n\n    event_stall.terminal = True\n    event_stall.direction = -1\n\n    results = []\n    for params in test_cases:\n        y0 = [params[\"F_A0\"], params[\"T_in\"]]\n        z_span = [0, params[\"z_max\"]]\n        \n        # Use tighter tolerances for higher accuracy, especially for Case 3\n        rtol = 1e-9\n        atol = 1e-12\n\n        sol = solve_ivp(\n            dydz, \n            z_span, \n            y0, \n            args=(params,),\n            method='RK45', \n            events=event_stall, \n            dense_output=True,\n            rtol=rtol,\n            atol=atol\n        )\n\n        if sol.status == 1 and len(sol.t_events[0]) > 0:\n            z_star = sol.t_events[0][0]\n        else:\n            z_star = -1.0\n            \n        results.append(f\"{z_star:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The simulation of combustion chemistry is dominated by the numerical challenge of \"stiffness,\" where reaction rates span many orders of magnitude. This problem delves into the core of advanced numerical solvers by tasking you with the analytical derivation of the chemical source term Jacobian, $\\mathbf{J}_{ij} = \\partial \\dot{\\omega}_i / \\partial C_j$. Understanding how to construct this matrix and exploit its inherent sparsity is fundamental to implementing the robust, implicit integration methods necessary to efficiently solve the governing equations for realistic combustion mechanisms .",
            "id": "4051573",
            "problem": "Consider a one-dimensional steady Plug Flow Reactor (PFR) with axial coordinate $z$ and bulk velocity $u$ in meters per second. The molar concentration vector of $N$ species is $C \\in \\mathbb{R}^N$ with components $C_i$ in moles per cubic meter. The species production rates per unit volume are $\\dot{\\omega}_i(C,T)$ in moles per cubic meter per second, determined by a mechanism of $M$ elementary reactions under the law of mass action. Assume isothermal conditions at temperature $T$ in kelvin. The PFR species conservation equations are\n$$\nu \\frac{d C_i}{d z} = \\dot{\\omega}_i(C,T), \\quad i = 1,\\dots,N.\n$$\nEach elementary reaction $r$ has reactant stoichiometric coefficients $\\nu^{\\mathrm{reac}}_{i,r} \\in \\{0,1,2,\\dots\\}$ and product stoichiometric coefficients $\\nu^{\\mathrm{prod}}_{i,r} \\in \\{0,1,2,\\dots\\}$ for species $i$, defining the net stoichiometric coefficient $\\nu^{\\mathrm{net}}_{i,r} = \\nu^{\\mathrm{prod}}_{i,r} - \\nu^{\\mathrm{reac}}_{i,r}$. The forward and backward Arrhenius rate coefficients are\n$$\nk^{\\mathrm{f}}_r(T) = A^{\\mathrm{f}}_r T^{n^{\\mathrm{f}}_r} \\exp\\left(-\\frac{E^{\\mathrm{f}}_r}{R_{\\mathrm{u}} T}\\right), \\quad\nk^{\\mathrm{b}}_r(T) = A^{\\mathrm{b}}_r T^{n^{\\mathrm{b}}_r} \\exp\\left(-\\frac{E^{\\mathrm{b}}_r}{R_{\\mathrm{u}} T}\\right),\n$$\nwhere $A^{\\mathrm{f}}_r$, $A^{\\mathrm{b}}_r$ are pre-exponential factors, $n^{\\mathrm{f}}_r$, $n^{\\mathrm{b}}_r$ temperature exponents, $E^{\\mathrm{f}}_r$, $E^{\\mathrm{b}}_r$ activation energies in joules per mole, and $R_{\\mathrm{u}}$ is the universal gas constant in joules per mole per kelvin. The forward and backward reaction rates for elementary reactions are\n$$\nR^{\\mathrm{f}}_r(C,T) = k^{\\mathrm{f}}_r(T) \\prod_{i=1}^N C_i^{\\nu^{\\mathrm{reac}}_{i,r}}, \\quad\nR^{\\mathrm{b}}_r(C,T) = k^{\\mathrm{b}}_r(T) \\prod_{i=1}^N C_i^{\\nu^{\\mathrm{prod}}_{i,r}},\n$$\nwith net rate $R_r(C,T) = R^{\\mathrm{f}}_r(C,T) - R^{\\mathrm{b}}_r(C,T)$ (for irreversible reactions, set $A^{\\mathrm{b}}_r = 0$, $n^{\\mathrm{b}}_r = 0$, $E^{\\mathrm{b}}_r = 0$). The species production rates satisfy\n$$\n\\dot{\\omega}_i(C,T) = \\sum_{r=1}^M \\nu^{\\mathrm{net}}_{i,r} \\, R_r(C,T).\n$$\n\nTask:\n1. Starting from these definitions, derive the Jacobian matrix entries\n$$\nJ_{i j}(C,T) = \\frac{\\partial \\dot{\\omega}_i}{\\partial C_j}(C,T),\n$$\nexpressed in terms of $\\nu^{\\mathrm{reac}}_{i,r}$, $\\nu^{\\mathrm{prod}}_{i,r}$, $\\nu^{\\mathrm{net}}_{i,r}$, $k^{\\mathrm{f}}_r(T)$, $k^{\\mathrm{b}}_r(T)$, and $C$. The derivation must use only the mass action forms and Arrhenius rate coefficients given above and fundamental rules of calculus. Explain which entries of $J$ are exactly zero and why, and discuss the sparsity pattern in relation to the reaction graph.\n\n2. Design an algorithm that constructs $J(C,T)$ exploiting sparsity by assembling only the nonzero entries implied by the mechanism definition, and outline how such sparsity can be leveraged within Newton-based implicit time-stepping for stiff Ordinary Differential Equations (ODEs) or spatial marching in PFRs (for example, solving linear systems of the form $(I - \\Delta t \\, J) \\delta = r$ using sparse direct or iterative methods).\n\n3. Implement the algorithm as a complete, runnable program (see the final answer requirements) that:\n   - Builds the analytic sparse Jacobian $J$ in compressed sparse row (CSR) format for each test case.\n   - Validates it by comparing to a numerically approximated dense Jacobian using finite differences, reporting the maximum absolute entrywise difference.\n   - Reports the sparsity fraction, defined as the number of nonzero entries divided by $N^2$.\n   - Uses the universal gas constant $R_{\\mathrm{u}} = 8.314462618$ joules per mole per kelvin.\n   - Uses the International System of Units (SI units): concentrations $C_i$ in moles per cubic meter, rate coefficients in consistent units (e.g., per second, meters cubed per mole per second, meters to the sixth power per mole squared per second), temperature $T$ in kelvin, production rates $\\dot{\\omega}_i$ in moles per cubic meter per second.\n\nTest suite:\nProvide the following four mechanistic test cases as inputs within your program. For each case, the mechanism is specified by $N$, reaction definitions, $T$, and an initial concentration vector $C$.\n\n- Case $1$ (happy path: irreversible bimolecular):\n  - $N = 3$ species with indices $0,1,2$ representing $A,B,C$.\n  - Reactions $M = 1$: $A + B \\to C$ with $\\nu^{\\mathrm{reac}}_{\\cdot,1} = [1,1,0]$, $\\nu^{\\mathrm{prod}}_{\\cdot,1} = [0,0,1]$.\n  - Forward Arrhenius parameters: $A^{\\mathrm{f}}_1 = 1.0$, $n^{\\mathrm{f}}_1 = 0$, $E^{\\mathrm{f}}_1 = 0$; backward set to zero as described.\n  - Temperature $T = 1000$.\n  - Concentrations $C = [2.0, 1.0, 0.0]$.\n\n- Case $2$ (reversible unimolecular equilibrium dynamics):\n  - $N = 2$ species $C,D$ with indices $0,1$.\n  - Reactions $M = 1$: $C \\rightleftharpoons D$ with $\\nu^{\\mathrm{reac}}_{\\cdot,1} = [1,0]$, $\\nu^{\\mathrm{prod}}_{\\cdot,1} = [0,1]$.\n  - Forward Arrhenius parameters: $A^{\\mathrm{f}}_1 = 0.5$, $n^{\\mathrm{f}}_1 = 0$, $E^{\\mathrm{f}}_1 = 0$; backward Arrhenius parameters: $A^{\\mathrm{b}}_1 = 0.1$, $n^{\\mathrm{b}}_1 = 0$, $E^{\\mathrm{b}}_1 = 0$.\n  - Temperature $T = 1000$.\n  - Concentrations $C = [1.5, 0.5]$.\n\n- Case $3$ (edge case: inert species and higher stoichiometry):\n  - $N = 4$ species $A,B,C,D$ with indices $0,1,2,3$.\n  - Reactions $M = 1$: $2A + B \\to C$ with $\\nu^{\\mathrm{reac}}_{\\cdot,1} = [2,1,0,0]$, $\\nu^{\\mathrm{prod}}_{\\cdot,1} = [0,0,1,0]$.\n  - Forward Arrhenius parameters: $A^{\\mathrm{f}}_1 = 0.2$, $n^{\\mathrm{f}}_1 = 0$, $E^{\\mathrm{f}}_1 = 0$; backward set to zero.\n  - Temperature $T = 900$.\n  - Concentrations $C = [1.0, 0.5, 0.0, 10.0]$.\n\n- Case $4$ (sparse chain with radical species and multiple reactions):\n  - $N = 5$ species $A,R,B,C,D$ with indices $0,1,2,3,4$.\n  - Reactions $M = 3$:\n    - $r1$: $A + R \\to 2R$ with $\\nu^{\\mathrm{reac}}_{\\cdot,1} = [1,1,0,0,0]$, $\\nu^{\\mathrm{prod}}_{\\cdot,1} = [0,2,0,0,0]$, forward Arrhenius parameters $A^{\\mathrm{f}}_1 = 1.0 \\times 10^{-3}$, $n^{\\mathrm{f}}_1 = 0$, $E^{\\mathrm{f}}_1 = 20000$, backward set to zero.\n    - $r2$: $R + B \\to C$ with $\\nu^{\\mathrm{reac}}_{\\cdot,2} = [0,1,1,0,0]$, $\\nu^{\\mathrm{prod}}_{\\cdot,2} = [0,0,0,1,0]$, forward Arrhenius parameters $A^{\\mathrm{f}}_2 = 1.0 \\times 10^{-2}$, $n^{\\mathrm{f}}_2 = 0$, $E^{\\mathrm{f}}_2 = 0$, backward set to zero.\n    - $r3$: $C \\to D$ with $\\nu^{\\mathrm{reac}}_{\\cdot,3} = [0,0,0,1,0]$, $\\nu^{\\mathrm{prod}}_{\\cdot,3} = [0,0,0,0,1]$, forward Arrhenius parameters $A^{\\mathrm{f}}_3 = 100.0$, $n^{\\mathrm{f}}_3 = 0$, $E^{\\mathrm{f}}_3 = 0$, backward set to zero.\n  - Temperature $T = 1200$.\n  - Concentrations $C = [2.0, 1.0 \\times 10^{-6}, 1.0, 0.0, 0.0]$.\n\nAnswer specification:\n- For each test case, compute:\n  - The maximum absolute difference between the analytic Jacobian entries and a finite-difference Jacobian approximation as a float (dimensionless).\n  - The sparsity fraction $\\,\\mathrm{nnz}/N^2\\,$ as a float (dimensionless), where $\\,\\mathrm{nnz}\\,$ is the number of stored nonzero entries in the CSR matrix.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, one sublist per test case in order, each sublist containing two floats in the order described. For example: \"[[v_1,w_1],[v_2,w_2],[v_3,w_3],[v_4,w_4]]\".",
            "solution": "The problem asks for the derivation, algorithmic design, and implementation for computing the Jacobian matrix of the species production rates in a chemically reacting flow, modeled by a Plug Flow Reactor (PFR). The validation of the problem statement confirms that it is scientifically sound, well-posed, and complete. We can therefore proceed with the solution.\n\n### Part 1: Derivation of the Jacobian Matrix\n\nThe Jacobian matrix of the species production rate vector $\\dot{\\omega}(C,T)$ with respect to the species concentration vector $C$ is defined by its entries:\n$$\nJ_{i j}(C,T) = \\frac{\\partial \\dot{\\omega}_i}{\\partial C_j}(C,T)\n$$\nwhere $i$ is the index for the species whose production rate is being differentiated (row index) and $j$ is the index for the concentration variable (column index).\n\nThe species production rate for species $i$ is given by a sum over all $M$ reactions:\n$$\n\\dot{\\omega}_i(C,T) = \\sum_{r=1}^M \\nu^{\\mathrm{net}}_{i,r} \\, R_r(C,T)\n$$\nwhere $\\nu^{\\mathrm{net}}_{i,r}$ is the net stoichiometric coefficient of species $i$ in reaction $r$, and $R_r$ is the net rate of progress for reaction $r$.\n\nBy linearity of the differentiation operator, we can write the Jacobian entry as:\n$$\nJ_{i j} = \\frac{\\partial}{\\partial C_j} \\left( \\sum_{r=1}^M \\nu^{\\mathrm{net}}_{i,r} R_r \\right) = \\sum_{r=1}^M \\nu^{\\mathrm{net}}_{i,r} \\frac{\\partial R_r}{\\partial C_j}\n$$\nThe net rate of progress $R_r$ is the difference between the forward and backward rates, $R_r = R^{\\mathrm{f}}_r - R^{\\mathrm{b}}_r$. Thus, we have:\n$$\nJ_{i j} = \\sum_{r=1}^M \\nu^{\\mathrm{net}}_{i,r} \\left( \\frac{\\partial R^{\\mathrm{f}}_r}{\\partial C_j} - \\frac{\\partial R^{\\mathrm{b}}_r}{\\partial C_j} \\right)\n$$\nNow we must find the partial derivatives of the forward and backward reaction rates, which are defined by the law of mass action. The forward rate for an elementary reaction $r$ is:\n$$\nR^{\\mathrm{f}}_r(C,T) = k^{\\mathrm{f}}_r(T) \\prod_{k=1}^N C_k^{\\nu^{\\mathrm{reac}}_{k,r}}\n$$\nTo compute the partial derivative with respect to $C_j$, we apply the product rule. The derivative is non-zero only for the term in the product corresponding to $k=j$:\n$$\n\\frac{\\partial R^{\\mathrm{f}}_r}{\\partial C_j} = k^{\\mathrm{f}}_r(T) \\left( \\prod_{k \\neq j} C_k^{\\nu^{\\mathrm{reac}}_{k,r}} \\right) \\frac{\\partial}{\\partial C_j} \\left( C_j^{\\nu^{\\mathrm{reac}}_{j,r}} \\right)\n$$\nApplying the power rule for differentiation, $\\frac{d}{dx} x^n = nx^{n-1}$, we get:\n$$\n\\frac{\\partial}{\\partial C_j} \\left( C_j^{\\nu^{\\mathrm{reac}}_{j,r}} \\right) = \\nu^{\\mathrm{reac}}_{j,r} \\, C_j^{\\nu^{\\mathrm{reac}}_{j,r}-1}\n$$\nThis derivative is zero if $\\nu^{\\mathrm{reac}}_{j,r}=0$. If $\\nu^{\\mathrm{reac}}_{j,r} \\geq 1$, we can express the derivative of the rate as:\n$$\n\\frac{\\partial R^{\\mathrm{f}}_r}{\\partial C_j} = k^{\\mathrm{f}}_r(T) \\, \\nu^{\\mathrm{reac}}_{j,r} \\, C_j^{\\nu^{\\mathrm{reac}}_{j,r}-1} \\prod_{k \\neq j} C_k^{\\nu^{\\mathrm{reac}}_{k,r}}\n$$\nThis form encounters a computational issue if $C_j=0$. A more convenient form, valid for $C_j  0$, is obtained by noting that $R^{\\mathrm{f}}_r = \\left( k^{\\mathrm{f}}_r \\prod_{k \\neq j} C_k^{\\nu^{\\mathrm{reac}}_{k,r}} \\right) C_j^{\\nu^{\\mathrm{reac}}_{j,r}}$. This gives:\n$$\n\\frac{\\partial R^{\\mathrm{f}}_r}{\\partial C_j} = \\nu^{\\mathrm{reac}}_{j,r} \\frac{R^{\\mathrm{f}}_r}{C_j} \\quad (\\text{for } C_j  0 \\text{ and } \\nu^{\\mathrm{reac}}_{j,r} \\ge 1)\n$$\nIf $C_j=0$, the derivative must be evaluated carefully. If $\\nu^{\\mathrm{reac}}_{j,r}  1$, the derivative is $0$. If $\\nu^{\\mathrm{reac}}_{j,r} = 1$, the derivative is $k^{\\mathrm{f}}_r \\prod_{k \\neq j} C_k^{\\nu^{\\mathrm{reac}}_{k,r}}$. If $\\nu^{\\mathrm{reac}}_{j,r} = 0$, the derivative is $0$.\n\nAn analogous derivation holds for the backward reaction rate $R^{\\mathrm{b}}_r(C,T) = k^{\\mathrm{b}}_r(T) \\prod_{k=1}^N C_k^{\\nu^{\\mathrm{prod}}_{k,r}}$:\n$$\n\\frac{\\partial R^{\\mathrm{b}}_r}{\\partial C_j} = \\nu^{\\mathrm{prod}}_{j,r} \\frac{R^{\\mathrm{b}}_r}{C_j} \\quad (\\text{for } C_j  0 \\text{ and } \\nu^{\\mathrm{prod}}_{j,r} \\ge 1)\n$$\nSpecial care is also needed for $C_j=0$.\n\nCombining these results, the final expression for the Jacobian entries is:\n$$\nJ_{i j} = \\sum_{r=1}^M \\nu^{\\mathrm{net}}_{i,r} \\left( \\nu^{\\mathrm{reac}}_{j,r} \\frac{R^{\\mathrm{f}}_r}{C_j} - \\nu^{\\mathrm{prod}}_{j,r} \\frac{R^{\\mathrm{b}}_r}{C_j} \\right)\n$$\nThis formula is computationally efficient for $C_j  0$, as the rates of progress $R^{\\mathrm{f}}_r$ and $R^{\\mathrm{b}}_r$ are typically computed anyway. The cases where $C_j = 0$ must be handled by direct evaluation of the derivative, as described above.\n\n**Sparsity of the Jacobian**\n\nThe entry $J_{ij} = \\partial \\dot{\\omega}_i / \\partial C_j$ is non-zero only if a change in the concentration of species $j$ affects the production rate of species $i$. From the derived formula, we can see that for a contribution from reaction $r$ to $J_{ij}$ to be non-zero, two conditions must be met simultaneously:\n1.  Species $i$ must participate in reaction $r$ (i.e., its net production is non-zero, $\\nu^{\\mathrm{net}}_{i,r} \\neq 0$).\n2.  The rate of reaction $r$ must depend on the concentration of species $j$. For elementary reactions under mass action law, this means species $j$ must be either a reactant or a product in reaction $r$ (i.e., $\\nu^{\\mathrm{reac}}_{j,r}  0$ or $\\nu^{\\mathrm{prod}}_{j,r}  0$).\n\nTherefore, $J_{ij}$ will be exactly zero if, for every reaction $r$ in the mechanism, either species $i$ does not participate in reaction $r$ OR species $j$ is not a reactant or product in reaction $r$.\n\nThe sparsity pattern of the Jacobian is thus determined by the connectivity of the reaction network. In a reaction graph where species are nodes, an interaction link can be drawn from species $j$ to species $i$ if they are both involved in a common reaction. The adjacency matrix of this interaction graph corresponds to the sparsity pattern of $J$. For large chemical mechanisms, where each reaction typically involves only a few species out of hundreds or thousands, the resulting Jacobian matrix is very sparse, i.e., most of its entries are zero.\n\n### Part 2: Algorithmic Design and Application\n\n**Algorithm to Construct the Sparse Jacobian**\n\nThe structure of the Jacobian can be exploited to construct it efficiently. A reaction-centric algorithm is ideal:\n\n1.  **Pre-computation:** Given temperature $T$ and concentrations $C$, calculate all forward and backward rate coefficients ($k^{\\mathrm{f}}_r, k^{\\mathrm{b}}_r$) and all forward and backward rates of progress ($R^{\\mathrm{f}}_r, R^{\\mathrm{b}}_r$).\n2.  **Sparsity and Value Assembly:** Initialize a data structure for storing sparse matrix entries in coordinate (COO) format, i.e., lists for values, row indices, and column indices.\n3.  **Iterate over Reactions:** For each reaction $r = 1, \\dots, M$:\n    a. Identify the set of species $\\{i\\}$ that are affected by this reaction (where $\\nu^{\\mathrm{net}}_{i,r} \\neq 0$).\n    b. Identify the set of species $\\{j\\}$ whose concentration influences the rate of this reaction (where $\\nu^{\\mathrm{reac}}_{j,r}  0$ or $\\nu^{\\mathrm{prod}}_{j,r}  0$).\n    c. For each pair $(i, j)$ from these sets:\n        i. Calculate the partial derivative of the rate of progress for reaction $r$ with respect to $C_j$: $\\frac{\\partial R_r}{\\partial C_j} = \\frac{\\partial R^{\\mathrm{f}}_r}{\\partial C_j} - \\frac{\\partial R^{\\mathrm{b}}_r}{\\partial C_j}$. Use the robust method that checks if $C_j=0$.\n        ii. Calculate the contribution to the Jacobian: $\\Delta J_{ij} = \\nu^{\\mathrm{net}}_{i,r} \\frac{\\partial R_r}{\\partial C_j}$.\n        iii. Append this value and its indices $(i, j)$ to the COO lists.\n4.  **Finalize Matrix:** After iterating through all reactions, construct a sparse matrix (e.g., `scipy.sparse.coo_matrix`) from the collected lists. The COO format straightforwardly handles multiple contributions to the same $(i,j)$ entry, which can be summed up to get the final value. Convert the matrix to Compressed Sparse Row (CSR) format for efficient subsequent algebraic operations.\n\n**Leveraging Sparsity in Numerical Solvers**\n\nThe governing equations for a PFR, $u \\frac{dC}{dz} = \\dot{\\omega}(C,T)$, form a system of ordinary differential equations (ODEs). Chemical kinetic systems are notoriously stiff, meaning they contain vastly different time scales. This necessitates the use of implicit numerical integration methods for stability.\n\nAn implicit backward Euler step for marching from $z_n$ to $z_{n+1} = z_n + \\Delta z$ is:\n$$\nC_{n+1} = C_n + \\frac{\\Delta z}{u} \\dot{\\omega}(C_{n+1}, T)\n$$\nThis is a nonlinear algebraic system for $C_{n+1}$. It can be solved using Newton's method. Let $G(C) = C - C_n - \\frac{\\Delta z}{u} \\dot{\\omega}(C,T) = 0$. The Newton iteration is:\n$$\n[G'(C^k)] (C^{k+1} - C^k) = -G(C^k)\n$$\nwhere $G'(C)$ is the Jacobian of the function $G$. The Jacobian is:\n$$\nG'(C) = I - \\frac{\\Delta z}{u} \\frac{\\partial \\dot{\\omega}}{\\partial C} = I - \\frac{\\Delta z}{u} J\n$$\nAt each Newton step, we must solve a linear system of the form $(I - \\gamma J) \\delta = r$, where $\\gamma = \\Delta z/u$ is related to the step size. Since $J$ is very sparse, the matrix $(I - \\gamma J)$ is also sparse with the same pattern (plus the identity on the diagonal).\n\nStoring and factorizing this matrix using dense linear algebra would have a memory cost of $O(N^2)$ and a computational cost of $O(N^3)$, which is prohibitive for large $N$. By using sparse matrix formats (like CSR) and specialized solvers, these costs are dramatically reduced:\n- **Sparse Direct Solvers:** Libraries like UMFPACK or SuperLU perform an LU factorization on the sparse matrix. The cost depends on the number of non-zeros ($\\mathrm{nnz}$) and \"fill-in\" during factorization, but is often much better than $O(N^3)$.\n- **Iterative Solvers:** Methods like GMRES or BiCGSTAB solve the system by repeatedly applying matrix-vector products. For a sparse matrix, a matrix-vector product costs $O(\\mathrm{nnz})$, which is much cheaper than the $O(N^2)$ cost for a dense matrix. These methods are highly effective when combined with a good preconditioner (e.g., an incomplete LU factorization), which also leverages sparsity.\n\nIn summary, the ability to construct the analytic sparse Jacobian is fundamental to the efficiency of modern stiff ODE solvers used in computational combustion.\n\n### Part 3: Implementation\n\nThe provided Python code implements the sparse Jacobian calculation and validation for the four given test cases.\n- `compute_omega`: Calculates the vector of species production rates, $\\dot{\\omega}$.\n- `compute_analytical_jacobian`: Implements the reaction-centric algorithm to build the sparse Jacobian in CSR format. It carefully handles the case where concentrations are zero.\n- `compute_numerical_jacobian`: Computes a dense Jacobian using a central finite-difference scheme (with a forward-difference fallback for near-zero concentrations) for validation.\n- The main `solve` function iterates through the test cases, calls these functions, compares the results to compute the maximum absolute error, calculates the sparsity fraction, and formats the output as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import coo_matrix\n\ndef solve():\n    \"\"\"\n    Solves the problem by computing and validating sparse Jacobians for four test cases.\n    \"\"\"\n    R_u = 8.314462618  # Universal gas constant in J/(molÂ·K)\n\n    # Define test cases as specified in the problem statement\n    test_cases = [\n        {\n            \"name\": \"Case 1: Irreversible bimolecular\",\n            \"N\": 3,\n            \"T\": 1000.0,\n            \"C\": np.array([2.0, 1.0, 0.0]),\n            \"reactions\": [\n                {\n                    \"nu_reac\": np.array([1, 1, 0]),\n                    \"nu_prod\": np.array([0, 0, 1]),\n                    \"A_f\": 1.0, \"n_f\": 0.0, \"E_f\": 0.0,\n                    \"A_b\": 0.0, \"n_b\": 0.0, \"E_b\": 0.0,\n                }\n            ],\n        },\n        {\n            \"name\": \"Case 2: Reversible unimolecular equilibrium\",\n            \"N\": 2,\n            \"T\": 1000.0,\n            \"C\": np.array([1.5, 0.5]),\n            \"reactions\": [\n                {\n                    \"nu_reac\": np.array([1, 0]),\n                    \"nu_prod\": np.array([0, 1]),\n                    \"A_f\": 0.5, \"n_f\": 0.0, \"E_f\": 0.0,\n                    \"A_b\": 0.1, \"n_b\": 0.0, \"E_b\": 0.0,\n                }\n            ],\n        },\n        {\n            \"name\": \"Case 3: Inert species and higher stoichiometry\",\n            \"N\": 4,\n            \"T\": 900.0,\n            \"C\": np.array([1.0, 0.5, 0.0, 10.0]),\n            \"reactions\": [\n                {\n                    \"nu_reac\": np.array([2, 1, 0, 0]),\n                    \"nu_prod\": np.array([0, 0, 1, 0]),\n                    \"A_f\": 0.2, \"n_f\": 0.0, \"E_f\": 0.0,\n                    \"A_b\": 0.0, \"n_b\": 0.0, \"E_b\": 0.0,\n                }\n            ],\n        },\n        {\n            \"name\": \"Case 4: Sparse chain reaction\",\n            \"N\": 5,\n            \"T\": 1200.0,\n            \"C\": np.array([2.0, 1.0e-6, 1.0, 0.0, 0.0]),\n            \"reactions\": [\n                {\n                    \"nu_reac\": np.array([1, 1, 0, 0, 0]),\n                    \"nu_prod\": np.array([0, 2, 0, 0, 0]),\n                    \"A_f\": 1.0e-3, \"n_f\": 0.0, \"E_f\": 20000.0,\n                    \"A_b\": 0.0, \"n_b\": 0.0, \"E_b\": 0.0,\n                },\n                {\n                    \"nu_reac\": np.array([0, 1, 1, 0, 0]),\n                    \"nu_prod\": np.array([0, 0, 0, 1, 0]),\n                    \"A_f\": 1.0e-2, \"n_f\": 0.0, \"E_f\": 0.0,\n                    \"A_b\": 0.0, \"n_b\": 0.0, \"E_b\": 0.0,\n                },\n                {\n                    \"nu_reac\": np.array([0, 0, 0, 1, 0]),\n                    \"nu_prod\": np.array([0, 0, 0, 0, 1]),\n                    \"A_f\": 100.0, \"n_f\": 0.0, \"E_f\": 0.0,\n                    \"A_b\": 0.0, \"n_b\": 0.0, \"E_b\": 0.0,\n                },\n            ],\n        },\n    ]\n\n    def compute_omega(T, C, reactions, N, R_u):\n        omega_dot = np.zeros(N)\n        for r_def in reactions:\n            k_f = r_def[\"A_f\"] * T**r_def[\"n_f\"] * np.exp(-r_def[\"E_f\"] / (R_u * T))\n            k_b = r_def[\"A_b\"] * T**r_def[\"n_b\"] * np.exp(-r_def[\"E_b\"] / (R_u * T))\n            \n            R_f, R_b = k_f, k_b\n            for i in range(N):\n                if r_def[\"nu_reac\"][i] > 0:\n                    R_f *= C[i]**r_def[\"nu_reac\"][i]\n                if r_def[\"nu_prod\"][i] > 0:\n                    R_b *= C[i]**r_def[\"nu_prod\"][i]\n            \n            nu_net = r_def[\"nu_prod\"] - r_def[\"nu_reac\"]\n            R_net = R_f - R_b\n            omega_dot += nu_net * R_net\n        return omega_dot\n\n    def compute_analytical_jacobian(T, C, reactions, N, R_u):\n        data, row, col = [], [], []\n        \n        for r_def in reactions:\n            k_f = r_def[\"A_f\"] * T**r_def[\"n_f\"] * np.exp(-r_def[\"E_f\"] / (R_u * T))\n            k_b = r_def[\"A_b\"] * T**r_def[\"n_b\"] * np.exp(-r_def[\"E_b\"] / (R_u * T))\n            \n            R_f, R_b = k_f, k_b\n            for i in range(N):\n                if r_def[\"nu_reac\"][i] > 0: R_f *= C[i]**r_def[\"nu_reac\"][i]\n                if r_def[\"nu_prod\"][i] > 0: R_b *= C[i]**r_def[\"nu_prod\"][i]\n\n            nu_net = r_def[\"nu_prod\"] - r_def[\"nu_reac\"]\n            \n            affected_species = np.where(nu_net != 0)[0]\n            participant_species = np.where(r_def[\"nu_reac\"] + r_def[\"nu_prod\"] > 0)[0]\n\n            for i in affected_species:\n                for j in participant_species:\n                    # Forward rate derivative\n                    dRf_dCj = 0.0\n                    nu_reac_j = r_def[\"nu_reac\"][j]\n                    if nu_reac_j > 0:\n                        if C[j] > 1e-40: # Numerically stable path for C > 0\n                            dRf_dCj = nu_reac_j * R_f / C[j]\n                        else: # C == 0 case\n                            if nu_reac_j == 1:\n                                term = k_f\n                                for k in range(N):\n                                    if k != j and r_def[\"nu_reac\"][k] > 0:\n                                        term *= C[k] ** r_def[\"nu_reac\"][k]\n                                dRf_dCj = term\n                            # else (nu_reac_j > 1), derivative is 0\n                    \n                    # Backward rate derivative\n                    dRb_dCj = 0.0\n                    nu_prod_j = r_def[\"nu_prod\"][j]\n                    if nu_prod_j > 0:\n                        if C[j] > 1e-40: # Numerically stable path for C > 0\n                            dRb_dCj = nu_prod_j * R_b / C[j]\n                        else: # C == 0 case\n                            if nu_prod_j == 1:\n                                term = k_b\n                                for k in range(N):\n                                    if k != j and r_def[\"nu_prod\"][k] > 0:\n                                        term *= C[k] ** r_def[\"nu_prod\"][k]\n                                dRb_dCj = term\n                            # else (nu_prod_j > 1), derivative is 0\n\n                    J_ij_contrib = nu_net[i] * (dRf_dCj - dRb_dCj)\n                    if J_ij_contrib != 0.0:\n                        data.append(J_ij_contrib)\n                        row.append(i)\n                        col.append(j)\n\n        if not data:\n            return coo_matrix((N, N)).tocsr()\n            \n        coo = coo_matrix((data, (row, col)), shape=(N, N))\n        coo.sum_duplicates()\n        return coo.tocsr()\n\n    def compute_numerical_jacobian(T, C, reactions, N, R_u):\n        h = 1e-8\n        J_num = np.zeros((N, N))\n        \n        for j in range(N):\n            C_plus = C.copy()\n            C_minus = C.copy()\n            \n            C_plus[j] += h\n            C_minus[j] -= h\n            \n            omega_plus = compute_omega(T, C_plus, reactions, N, R_u)\n            \n            # Use forward difference if central difference would use negative conc\n            if C[j]  h:\n                omega_base = compute_omega(T, C, reactions, N, R_u)\n                J_num[:, j] = (omega_plus - omega_base) / h\n            else:\n                omega_minus = compute_omega(T, C_minus, reactions, N, R_u)\n                J_num[:, j] = (omega_plus - omega_minus) / (2.0 * h)\n                \n        return J_num\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        T = case[\"T\"]\n        C = case[\"C\"]\n        reactions = case[\"reactions\"]\n        \n        J_analytic = compute_analytical_jacobian(T, C, reactions, N, R_u)\n        J_numerical = compute_numerical_jacobian(T, C, reactions, N, R_u)\n        \n        diff = np.max(np.abs(J_analytic.toarray() - J_numerical))\n        \n        sparsity_frac = J_analytic.nnz / (N * N)\n        \n        results.append([diff, sparsity_frac])\n\n    # Format the final output string\n    output_str = \"[\" + \",\".join([str(res) for res in results]) + \"]\"\n    print(output_str)\n\nsolve()\n\n```"
        }
    ]
}