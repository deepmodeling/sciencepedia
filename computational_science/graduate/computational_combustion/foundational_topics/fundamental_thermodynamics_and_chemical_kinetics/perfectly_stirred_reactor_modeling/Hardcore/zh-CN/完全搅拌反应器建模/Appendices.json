{
    "hands_on_practices": [
        {
            "introduction": "本练习旨在巩固对完美搅拌反应器（PSR）模型中核心变量之间相互耦合关系的理解。通过从理想气体定律出发，您将推导反应器出口密度和质量流率，并揭示它们如何通过停留时间 $\\tau$ 与组分质量平衡方程紧密相连。这个练习强调了热力学状态、流动特性和化学反应动力学之间密不可分的反馈循环，这是理解和求解PSR模型的基础。",
            "id": "4049170",
            "problem": "一个完美搅拌反应器 (PSR) 在稳态下运行，整个反应器内性质均匀。出口（等于反应器状态）压力为 $p = 2.50$ $\\text{atm}$，温度为 $T = 1100$ $\\text{K}$，出口混合物组成由各物种的摩尔分数给出：$\\text{CO}_{2}$ 的摩尔分数为 $X_{\\text{CO}_{2}} = 0.09$，$\\text{H}_{2}\\text{O}$ 的摩尔分数为 $X_{\\text{H}_{2}\\text{O}} = 0.11$，$\\text{N}_{2}$ 的摩尔分数为 $X_{\\text{N}_{2}} = 0.76$，以及 $\\text{O}_{2}$ 的摩尔分数为 $X_{\\text{O}_{2}} = 0.04$。反应器体积为 $V = 0.050$ $\\text{m}^{3}$，在反应器条件下的停留时间为 $\\tau = 0.20$ $\\text{s}$。假设为理想气体混合物且无累积，入口和出口质量流量相等。\n\n仅使用第一性原理和公认的定义，推导出以 $p$、$T$ 和混合物平均摩尔质量 $M_{\\text{mix}}$ 表示的出口密度 $\\rho$ 的表达式，并根据停留时间的定义用该表达式求得质量流量 $\\dot{m}$。然后，阐明 $\\rho$ 和 $\\dot{m}$ 如何通过 $\\tau$ 耦合回稳态物种平衡方程。\n\n使用以下分子量对质量流量 $\\dot{m}$ 进行数值计算：$M_{\\text{CO}_{2}} = 44.01$ $\\text{g/mol}$，$M_{\\text{H}_{2}\\text{O}} = 18.01528$ $\\text{g/mol}$，$M_{\\text{N}_{2}} = 28.0134$ $\\text{g/mol}$，$M_{\\text{O}_{2}} = 31.998$ $\\text{g/mol}$，以及普适气体常数 (UGC) $R_{u} = 8.314462618$ $\\text{J/mol/K}$。将压力转换为帕斯卡。以 $\\text{kg/s}$ 为单位表示最终的质量流量，并将您的答案四舍五入到四位有效数字。",
            "solution": "该问题已经过验证，被认为是有效的。它具有科学依据，问题提出得当，客观，并包含足够的信息以获得唯一解。\n\n该问题要求推导出口密度 $\\rho$ 的表达式，用它来确定质量流量 $\\dot{m}$，并解释这些量与完美搅拌反应器 (PSR) 中物种守恒方程之间的耦合关系。最后，需要计算 $\\dot{m}$ 的数值。\n\n首先，我们推导混合物密度 $\\rho$ 的表达式。我们从混合物的理想气体定律开始：\n$$p V = n R_{u} T$$\n其中 $p$ 是压力，$V$ 是体积，$n$ 是体积内气体的总摩尔数，$R_{u}$ 是普适气体常数，$T$ 是温度。\n\n体积 $V$ 内的总质量 $m$ 通过混合物平均摩尔质量 $M_{\\text{mix}}$ 与总摩尔数 $n$ 相关：\n$$m = n M_{\\text{mix}}$$\n解出 $n$ 得到 $n = \\frac{m}{M_{\\text{mix}}}$。将此代入理想气体定律：\n$$p V = \\left(\\frac{m}{M_{\\text{mix}}}\\right) R_{u} T$$\n密度 $\\rho$ 定义为单位体积的质量，即 $\\rho = \\frac{m}{V}$。我们可以重排上述方程以分离出这一项：\n$$p = \\left(\\frac{m}{V}\\right) \\frac{R_{u} T}{M_{\\text{mix}}} = \\rho \\frac{R_{u} T}{M_{\\text{mix}}}$$\n解出密度 $\\rho$ 得到所需的表达式：\n$$\\rho = \\frac{p M_{\\text{mix}}}{R_{u} T}$$\n该表达式将理想气体混合物的密度与其压力、温度和平均摩尔质量联系起来。\n\n接下来，我们使用这个表达式来求质量流量 $\\dot{m}$。PSR 中的停留时间 $\\tau$ 定义为流体元在反应器中停留的平均时间。对于稳流系统，它是反应器内流体的质量 $m$ 与通过反应器的质量流量 $\\dot{m}$ 之比：\n$$\\tau = \\frac{m}{\\dot{m}}$$\n反应器体积 $V$ 内的质量 $m$ 由 $m = \\rho V$ 给出。将此代入停留时间的定义：\n$$\\tau = \\frac{\\rho V}{\\dot{m}}$$\n解出质量流量 $\\dot{m}$：\n$$\\dot{m} = \\frac{\\rho V}{\\tau}$$\n现在，我们代入先前推导的 $\\rho$ 表达式：\n$$\\dot{m} = \\left(\\frac{p M_{\\text{mix}}}{R_{u} T}\\right) \\frac{V}{\\tau} = \\frac{p V M_{\\text{mix}}}{R_{u} T \\tau}$$\n\n问题还问到 $\\rho$ 和 $\\dot{m}$ 如何耦合回稳态物种平衡方程。PSR 中物种 k 的稳态质量平衡为：\n$$(\\text{质量流入}) - (\\text{质量流出}) + (\\text{反应产生的质量}) = 0$$\n$$\\dot{m} Y_{k,in} - \\dot{m} Y_{k} + V \\dot{\\omega}_{k} M_{k} = 0$$\n其中 $Y_{k,in}$ 和 $Y_{k}$ 是物种 k 的入口和出口（反应器）质量分数，$\\dot{\\omega}_{k}$ 是物种 k 的单位体积摩尔生成速率，$M_k$ 是物种 k 的摩尔质量。重新整理以求解组成的变化：\n$$\\dot{m} (Y_{k} - Y_{k,in}) = V \\dot{\\omega}_{k} M_{k}$$\n$$Y_{k} - Y_{k,in} = \\frac{V}{\\dot{m}} \\dot{\\omega}_{k} M_{k}$$\n根据停留时间的定义 $\\tau = \\frac{\\rho V}{\\dot{m}}$，我们可以将比率 $\\frac{V}{\\dot{m}}$ 写为 $\\frac{\\tau}{\\rho}$。将此代入重新整理的物种平衡方程，得到：\n$$Y_{k} - Y_{k,in} = \\frac{\\tau}{\\rho} \\dot{\\omega}_{k} M_{k}$$\n这个最终方程明确地显示了耦合关系。物种在反应器两端的质量分数变化与停留时间 $\\tau$ 和化学源项成正比，与密度 $\\rho$ 成反比。由于 $\\dot{m}$ 通过 $\\dot{m} = \\rho V / \\tau$ 与 $\\rho$ 和 $\\tau$ 相关，因此这三个量在反应器的控制方程中是内在地联系在一起的。\n\n最后，我们对质量流量 $\\dot{m}$ 进行数值计算。\n给定数据如下：\n$p = 2.50$ $\\text{atm}$\n$T = 1100$ $\\text{K}$\n$V = 0.050$ $\\text{m}^{3}$\n$\\tau = 0.20$ $\\text{s}$\n$X_{\\text{CO}_{2}} = 0.09$\n$X_{\\text{H}_{2}\\text{O}} = 0.11$\n$X_{\\text{N}_{2}} = 0.76$\n$X_{\\text{O}_{2}} = 0.04$\n摩尔质量 ($M_k$): $M_{\\text{CO}_{2}} = 44.01$ $\\text{g/mol}$，$M_{\\text{H}_{2}\\text{O}} = 18.01528$ $\\text{g/mol}$，$M_{\\text{N}_{2}} = 28.0134$ $\\text{g/mol}$，$M_{\\text{O}_{2}} = 31.998$ $\\text{g/mol}$。\n普适气体常数: $R_{u} = 8.314462618$ $\\text{J/(mol}\\cdot\\text{K)}$。\n\n首先，我们计算混合物平均摩尔质量 $M_{\\text{mix}}$，它是各组分物种的摩尔分数加权摩尔质量之和：\n$$M_{\\text{mix}} = \\sum_{k} X_{k} M_{k}$$\n$$M_{\\text{mix}} = X_{\\text{CO}_{2}}M_{\\text{CO}_{2}} + X_{\\text{H}_{2}\\text{O}}M_{\\text{H}_{2}\\text{O}} + X_{\\text{N}_{2}}M_{\\text{N}_{2}} + X_{\\text{O}_{2}}M_{\\text{O}_{2}}$$\n$$M_{\\text{mix}} = (0.09)(44.01) + (0.11)(18.01528) + (0.76)(28.0134) + (0.04)(31.998) \\text{ g/mol}$$\n$$M_{\\text{mix}} = 3.9609 + 1.9816808 + 21.290184 + 1.27992 \\text{ g/mol}$$\n$$M_{\\text{mix}} = 28.5126848 \\text{ g/mol}$$\n为了在国际单位制 (SI) 中使用，我们将其转换为千克每摩尔：\n$$M_{\\text{mix}} = 0.0285126848 \\text{ kg/mol}$$\n\n接下来，我们使用标准转换 $1$ $\\text{atm}$ $= 101325$ $\\text{Pa}$ 将压力从大气压转换为帕斯卡：\n$$p = 2.50 \\text{ atm} \\times \\frac{101325 \\text{ Pa}}{1 \\text{ atm}} = 253312.5 \\text{ Pa}$$\n\n现在我们可以将所有值代入 $\\dot{m}$ 的表达式中：\n$$\\dot{m} = \\frac{p V M_{\\text{mix}}}{R_{u} T \\tau}$$\n$$\\dot{m} = \\frac{(253312.5 \\text{ Pa})(0.050 \\text{ m}^{3})(0.0285126848 \\text{ kg/mol})}{(8.314462618 \\text{ J/(mol}\\cdot\\text{K)})(1100 \\text{ K})(0.20 \\text{ s})}$$\n$$\\dot{m} = \\frac{361.161048}{1829.18177596} \\text{ kg/s}$$\n$$\\dot{m} \\approx 0.19744005 \\text{ kg/s}$$\n按照要求四舍五入到四位有效数字，质量流量为：\n$$\\dot{m} = 0.1974 \\text{ kg/s}$$",
            "answer": "$$\\boxed{0.1974}$$"
        },
        {
            "introduction": "掌握了PSR的控制方程后，下一个挑战是如何高效且稳健地求解这组非线性方程。本练习将探讨数值求解策略，特别是初始猜测值的选取，这对于牛顿法等求解器的收敛性至关重要。通过分析不同初始猜测方案的物理一致性，您将理解为什么基于化学平衡状态的猜测值能够显著提高求解器在处理刚性化学动力学问题时的收敛成功率。",
            "id": "4049158",
            "problem": "考虑一个在恒定压力 $P$、恒定体积 $V$ 和停留时间 $\\tau = \\rho V / \\dot{m}$ 下运行的稳态绝热理想搅拌反应器 (PSR)，其中 $\\rho$ 是混合物密度，$\\dot{m}$ 是入口质量流率。入口状态由组分质量分数 $\\{Y_{i,\\mathrm{in}}\\}_{i=1}^{N_s}$、温度 $T_{\\mathrm{in}}$ 和混合物焓 $h_{\\mathrm{in}}$ 表征。反应器是理想混合的，因此出口状态等于反应器状态，其混合物温度 $T$ 和组分质量分数 $\\{Y_i\\}_{i=1}^{N_s}$ 是未知的。\n\n对于每个组分索引 $i \\in \\{1,\\dots,N_s\\}$ 的稳态组分守恒方程以及轴功可忽略不计的绝热反应器的稳态能量守恒方程，均可由稳流设备的质量守恒和热力学第一定律推导得出。组分守恒方程可写为如下形式\n$$\n0 = \\dot{m}\\,\\left(Y_{i,\\mathrm{in}} - Y_i\\right) + \\omega_i(T,\\boldsymbol{Y})\\,V,\n$$\n其中 $\\omega_i(T,\\boldsymbol{Y})$ 是单位体积内组分 $i$ 的净化学生成速率，且 $\\boldsymbol{Y} = (Y_1,\\dots,Y_{N_s})^\\top$。绝热PSR的能量守恒意味着稳态下的混合物焓与入口焓相同：\n$$\nh(\\boldsymbol{Y},T) = h_{\\mathrm{in}}.\n$$\n假设为理想气体混合物，其组分焓是温度的函数，并包含生成焓，因此化学热释放包含在 $h(\\boldsymbol{Y},T)$ 中。\n\n为计算稳态，通常使用 Newton-Raphson 方法求解未知向量 $\\boldsymbol{U} = (T, Y_1,\\dots,Y_{N_s-1})^\\top$ 的非线性代数方程组 $F(\\boldsymbol{U}) = \\boldsymbol{0}$，同时强制满足 $Y_{N_s} = 1 - \\sum_{i=1}^{N_s-1} Y_i$ 和元素守恒约束。Newton-Raphson 方法的收敛性取决于初始猜测值 $\\boldsymbol{U}^0$ 是否物理上一致且足够接近一个根，以及雅可比矩阵在迭代点附近是否为良态的。\n\n以下哪种初始猜测值策略在物理上与绝热PSR的能量守恒和元素约束一致，并且最能直接解释为何它能改进计算PSR稳态时 Newton-Raphson 方法的收敛性？选择所有适用的选项。\n\nA. 计算在压力 $P$ 和焓约束 $h(\\boldsymbol{Y},T) = h_{\\mathrm{in}}$ 条件下的化学平衡状态，即通过在恒定压力 $P$ 下最小化吉布斯自由能并调整 $T$ 直到满足焓约束，来找到满足元素守恒、$\\sum_{i=1}^{N_s} Y_i^{\\mathrm{eq}} = 1$ 和 $h(\\boldsymbol{Y}^{\\mathrm{eq}},T^{\\mathrm{eq}}) = h_{\\mathrm{in}}$ 的 $(\\boldsymbol{Y}^{\\mathrm{eq}}, T^{\\mathrm{eq}})$；然后设置 $T^0 = T^{\\mathrm{eq}}$ 和 $Y_i^0 = Y_i^{\\mathrm{eq}}$。这将初始迭代点置于绝热PSR的正确热力学流形上，使能量残差为零，并将迭代点与刚性化学动力学的慢流形对齐，从而改善 Newton-Raphson 方法的收敛性。\n\nB. 设置 $T^0 = T_{\\mathrm{in}}$ 和 $Y_i^0 = Y_{i,\\mathrm{in}}$（冻结入口状态）。该策略满足正值性、元素守恒和 $h(\\boldsymbol{Y}^0,T^0) = h_{\\mathrm{in}}$，因此在改善 Newton-Raphson 方法的收敛性方面与选项A同样有效。\n\nC. 计算一个与入口焓无关的参考混合物在压力 $P$ 和化学计量绝热火焰温度 $T_{\\mathrm{st}}$ 下的化学平衡组分，并设置 $T^0 = T_{\\mathrm{st}}$, $Y_i^0 = Y_i^{\\mathrm{eq}}(T_{\\mathrm{st}},P)$。这会产生一个高反应活性的初始状态，通过最大化反应速率来加速 Newton-Raphson 方法的收敛。\n\nD. 在压力 $P$ 和入口温度 $T_{\\mathrm{in}}$ 下计算化学平衡组分，但不强制满足 $h(\\boldsymbol{Y},T) = h_{\\mathrm{in}}$，即设置 $T^0 = T_{\\mathrm{in}}$, $Y_i^0 = Y_i^{\\mathrm{eq}}(T_{\\mathrm{in}},P)$。Newton-Raphson 方法会在第一次迭代中修正能量残差，因此这是可以接受的。\n\nE. 选择任意正值组分，进行归一化以强制满足 $\\sum_{i=1}^{N_s} Y_i^0 = 1$，并选择一个 $T^0$ 使得仅理想气体显焓（不包括生成焓）与 $h_{\\mathrm{in}}$ 相匹配。这提供了足够的物理一致性，并且通常能改善 Newton-Raphson 方法的收敛性。",
            "solution": "首先对问题陈述的科学性和逻辑合理性进行验证。\n\n### 步骤 1：提取已知条件\n\n-   反应器类型：稳态绝热理想搅拌反应器 (PSR)。\n-   操作条件：恒定压力 $P$，恒定体积 $V$。\n-   停留时间定义：$\\tau = \\rho V / \\dot{m}$，其中 $\\rho$ 是混合物密度，$\\dot{m}$ 是入口质量流率。\n-   入口状态：组分质量分数 $\\{Y_{i,\\mathrm{in}}\\}_{i=1}^{N_s}$、温度 $T_{\\mathrm{in}}$ 和混合物焓 $h_{\\mathrm{in}}$。\n-   反应器状态（出口状态）：温度 $T$ 和组分质量分数 $\\{Y_i\\}_{i=1}^{N_s}$。\n-   稳态组分守恒方程 ($i \\in \\{1,\\dots,N_s\\}$)：\n    $$0 = \\dot{m}\\,\\left(Y_{i,\\mathrm{in}} - Y_i\\right) + \\omega_i(T,\\boldsymbol{Y})\\,V$$\n    其中 $\\omega_i(T,\\boldsymbol{Y})$ 是单位体积内组分 $i$ 的净化学生成速率，且 $\\boldsymbol{Y} = (Y_1,\\dots,Y_{N_s})^\\top$。\n-   稳态绝热能量守恒方程：\n    $$h(\\boldsymbol{Y},T) = h_{\\mathrm{in}}$$\n-   混合物模型：理想气体混合物，其组分焓是温度的函数，并包含生成焓。\n-   数值方法：使用 Newton-Raphson 方法求解非线性系统 $F(\\boldsymbol{U}) = \\boldsymbol{0}$，未知向量为 $\\boldsymbol{U} = (T, Y_1,\\dots,Y_{N_s-1})^\\top$。\n-   约束条件：$Y_{N_s} = 1 - \\sum_{i=1}^{N_s-1} Y_i$ 和元素守恒。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n问题陈述描述了稳态绝热理想搅拌反应器的经典模型。\n\n-   **具有科学依据**：控制方程是质量守恒和热力学第一定律在稳流开放系统中的直接应用。组分守恒将流出反应器的组分净流量与其在反应器内的净化学生成速率联系起来。能量守恒 $h = h_{\\mathrm{in}}$，对于动能和势能变化可忽略不计且无轴功的绝热稳流设备是正确的形式。使用绝对焓（包括生成焓）来解释热释放是标准做法。该问题牢固地植根于化学动力学、热力学和流体力学。\n-   **适定的**：由 $N_s$ 个组分方程和 1 个能量方程组成的方程组，加上归一化条件 $\\sum Y_i = 1$，为求解 $N_s$ 个未知质量分数 $Y_i$ 和未知温度 $T$ 构成了一个定解系统。寻找稳态的问题是适定的，尽管可能存在多个解（例如，点燃和熄火分支），这是PSR的一个已知物理特性。该问题探讨了求解这个适定系统的一个实践方面。\n-   **客观性**：语言精确，并使用了计算燃烧学的标准术语。问题陈述客观且无偏见。\n\n未发现任何缺陷。该问题在科学上不是不合理的、不完整的、矛盾的或不适定的。它是计算燃烧学领域一个有效且相关的问题。\n\n### 步骤 3：结论与行动\n\n问题陈述有效。将推导完整解。\n\n### 推导与选项分析\n\n任务是为 Newton-Raphson 方法确定一种初始猜测值策略，该策略既要物理上一致，又要为收敛提供坚实的基础。对于此问题，一个物理上一致的初始猜测值 $(\\boldsymbol{Y}^0, T^0)$ 必须满足从问题陈述中推导出的三个基本约束：\n1.  **能量守恒**：状态必须位于由入口条件定义的等焓面上。混合物总焓必须等于入口焓：$h(\\boldsymbol{Y}^0, T^0) = h_{\\mathrm{in}}$。\n2.  **元素守恒**：初始猜测值混合物 $\\boldsymbol{Y}^0$ 的元素组成必须与入口混合物 $\\boldsymbol{Y}_{\\mathrm{in}}$ 的元素组成相同。这是每个元素质量守恒的结果，因为没有元素被创造或毁灭。\n3.  **质量分数属性**：质量分数必须为非负值，$Y_i^0 \\ge 0$，且总和为一，$\\sum_{i=1}^{N_s} Y_i^0 = 1$。\n\n除了物理一致性，一个好的策略还应该“解释为何能改进 Newton-Raphson 方法的收敛性”。这通常意味着初始猜测值将迭代点 $\\boldsymbol{U}^0 = (T^0, Y_1^0, \\dots, Y_{N_s-1}^0)^\\top$ 置于状态空间的一个区域内，从此区域出发，该方法很可能收敛到一个物理上有意义的解。对于化学动力学特有的刚性系统，这通常意味着在系统的慢流形上或其附近进行初始化。\n\n现在根据这些标准评估每个选项。\n\n**A. 计算在压力 $P$ 和焓约束 $h(\\boldsymbol{Y},T) = h_{\\mathrm{in}}$ 条件下的化学平衡状态...**\n\n该策略涉及执行一个定压、定焓 (HP) 的化学平衡计算。\n-   **物理一致性**:\n    1.  **能量守恒**：HP平衡计算专门用于寻找一个状态 $(\\boldsymbol{Y}^{\\mathrm{eq}}, T^{\\mathrm{eq}})$，使得 $h(\\boldsymbol{Y}^{\\mathrm{eq}}, T^{\\mathrm{eq}})$ 等于一个指定的目标焓，此处该目标焓被设为 $h_{\\mathrm{in}}$。该约束根据定义得到满足。\n    2.  **元素守恒**：化学平衡计算会保持每种元素的原子总数守恒。所得混合物 $\\boldsymbol{Y}^{\\mathrm{eq}}$ 的元素组成与初始混合物（即入口流）的元素组成相同。该约束得到满足。\n    3.  **质量分数属性**：一个有效的平衡求解器将返回一个组分，其满足 $Y_i^{\\mathrm{eq}} \\ge 0$ 和 $\\sum Y_i^{\\mathrm{eq}} = 1$。该约束得到满足。\n-   **收敛性改进**：这个猜测值对应于停留时间无限大（$\\tau \\to \\infty$）极限下反应器的物理状态，此时化学反应有无限的时间进行，从而达到化学平衡。所有可能的平衡状态集合构成了反应系统的慢流形。从这一点开始，初始迭代点被置于该流形上，这对于刚性系统是一种高效的策略，因为它避免了从远离该流形的点开始时可能发生的、有问题的大幅度初始更新。“将迭代点与慢流形对齐”这一论断是对该策略成功的一个正确且深入的解释，尤其对于寻找点燃解而言。它还正确地指出，能量残差从一开始就为零。\n\n该选项既物理上一致，又为其为何能改善收敛性提供了正确且高级的解释。\n**结论：正确。**\n\n**B. 设置 $T^0 = T_{\\mathrm{in}}$ 和 $Y_i^0 = Y_{i,\\mathrm{in}}$（冻结入口状态）...**\n\n该策略使用入口状态作为初始猜测值。\n-   **物理一致性**:\n    1.  **能量守恒**：根据定义，入口状态的焓为 $h_{\\mathrm{in}}$，因此 $h(\\boldsymbol{Y}_{\\mathrm{in}}, T_{\\mathrm{in}}) = h_{\\mathrmin}$ 得到满足。\n    2.  **元素守恒**：元素组成被平凡地保持。\n    3.  **质量分数属性**：入口质量分数满足这些属性。\n-   **收敛性改进**：这个猜测值对应于停留时间为零（$\\tau \\to 0$）极限下的物理状态。对于非反应或“熄火”解分支，这是一个极好的猜测值。然而，对于点燃解（其中 $T \\gg T_{\\mathrm{in}}$ 且 $\\boldsymbol{Y}$ 与 $\\boldsymbol{Y}_{\\mathrm{in}}$ 非常不同），这个猜测值可能离解很远，导致大的初始步长和 Newton 方法可能的发散。该选项声称此策略“在改善 Newton-Raphson 方法的收敛性方面与选项A同样有效”。这在事实上是错误的。选项A是寻找点燃（$\\tau \\to \\infty$）极限的策略，而选项B是寻找熄火（$\\tau \\to 0$）极限的策略。它们在不同且互斥的区域内有效。对于寻找通常更具挑战性的点燃解，选项A要稳健得多。所提供的理由是有缺陷的。\n\n因为该选项的理由中包含一个错误的声明，所以它是不正确的。\n**结论：不正确。**\n\n**C. 计算一个与入口焓无关的参考混合物在压力 $P$ 和化学计量绝热火焰温度 $T_{\\mathrm{st}}$ 下的化学平衡组分...**\n\n此策略使用一个参考平衡状态。\n-   **物理一致性**:\n    1.  **能量守恒**：化学计量绝热火焰温度 $T_{\\mathrm{st}}$ 是为化学计量混合物计算的，其元素组成和入口温度通常与PSR的实际入口不同。因此，该状态的焓 $h(\\boldsymbol{Y}^{\\mathrm{eq}}(T_{\\mathrm{st}},P), T_{\\mathrm{st}})$ 通常不等于 $h_{\\mathrm{in}}$。能量约束被违反。\n    2.  **元素守恒**：根据定义，化学计量混合物的元素组成与非化学计量入口混合物的元素组成不同。元素守恒约束被违反。\n-   **收敛性改进**：从一个违反系统基本守恒定律的猜测值开始是一种糟糕的数值实践。它会引入大的初始残差，这对收敛是不利的。\n\n该选项在物理上不一致。\n**结论：不正确。**\n\n**D. 在压力 $P$ 和入口温度 $T_{\\mathrm{in}}$ 下计算化学平衡组分，但不强制满足 $h(\\boldsymbol{Y},T) = h_{\\mathrm{in}}$...**\n\n该策略涉及在 $T_{\\mathrm{in}}$ 下进行定压、定温 (TP) 平衡计算。\n-   **物理一致性**:\n    1.  **能量守恒**：该计算寻找在 $(T_{\\mathrm{in}}, P)$ 下使吉布斯自由能最小化的组分 $\\boldsymbol{Y}^{\\mathrm{eq}}(T_{\\mathrm{in}},P)$。这个过程是等温的，而不是等焓的。在恒定温度下，从 $\\boldsymbol{Y}_{\\mathrm{in}}$ 反应到 $\\boldsymbol{Y}^{\\mathrm{eq}}$ 涉及化学焓的变化。因此，通常情况下，$h(\\boldsymbol{Y}^{\\mathrm{eq}}(T_{\\mathrmin},P), T_{\\mathrm{in}}) \\neq h(\\boldsymbol{Y}_{\\mathrm{in}}, T_{\\mathrm{in}}) = h_{\\mathrm{in}}$。能量约束被违反。\n-   **收敛性改进**：声称 Newton-Raphson 方法“会修正能量残差”是一种一厢情愿的说法，而不是一个合理的策略。从一个关键守恒方程中的大残差开始是失败的根源。\n\n该选项在物理上不一致。\n**结论：不正确。**\n\n**E. 选择任意正值组分，进行归一化...，并选择一个 $T^0$ 使得仅理想气体显焓（不包括生成焓）与 $h_{\\mathrm{in}}$ 相匹配...**\n\n该策略是临时的，并且误解了物理原理。\n-   **物理一致性**:\n    1.  **能量守恒**：控制能量守恒是 $h(\\boldsymbol{Y},T) = h_{\\mathrm{in}}$，其中 $h$ 是*总*焓，包括生成焓。该选项建议将显焓与总焓相等，这在量纲上和物理上都是不正确的。它从根本上违反了为该问题所建立的热力学第一定律。\n    2.  **元素守恒**：“选择任意正值组分”的指令完全忽略了元素守恒约束。\n-   **收敛性改进**：一个违反两项基本守恒定律的猜测值是极差的，并且预计不会改善收敛性。\n\n该选项在物理上不一致。\n**结论：不正确。**\n\n基于以上分析，只有选项A提出了一种策略，该策略既完全符合问题的物理化学约束，又为其在改善数值方法收敛性方面的有效性提供了正确、实质性的解释。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "本练习是一个综合性的计算实践，旨在将PSR建模和数值求解技术应用于燃烧稳定性分析的核心问题。您将设计一个高级的连续算法，以追踪反应器在不同操作参数下的完整稳态解曲线（即著名的“S形曲线”）。通过监测系统雅可比矩阵的奇异值，您将能够自动识别点燃和熄火等关键的临界点（折叠分岔点），这是高级反应器分析和设计中的一项核心技能。",
            "id": "4049184",
            "problem": "您的任务是为计算燃烧学中的理想搅拌反应器（PSR）稳态建模实现一个鲁棒的延拓算法。PSR被建模为一个处于稳态的零维反应器，其中燃料和氧化剂之间发生单一的不可逆放热反应：反应速率由阿伦尼乌斯定律和质量作用动力学控制。您必须从基本平衡方程中推导出稳态的控制代数系统，设计一个在停留时间 $\\,\\tau\\,$ 或当量比 $\\,\\phi\\,$ 上的预测-校正延拓算法，并通过监测残差关于状态变量的雅可比矩阵 $\\,J\\,$ 的行列式或最小奇异值来检测鞍结分岔。您的最终程序必须计算三个指定测试用例中检测到的分岔事件的整数计数，并以单行列表格式输出它们。\n\n从以下基本定律和核心定义开始：\n- 理想搅拌反应器中每个物种 $\\,i\\,$ 的稳态摩尔平衡：\n$$\\frac{c_{i,\\mathrm{in}} - c_i}{\\tau} + \\omega_i = 0,$$\n其中 $\\,c_{i,\\mathrm{in}}\\,$ 是物种 $\\,i\\,$ 的入口摩尔浓度，$\\,c_i\\,$ 是出口（即反应器内）摩尔浓度，$\\,\\tau\\,$ 是停留时间，$\\,\\omega_i\\,$ 是化学反应导致的物种 $\\,i\\,$ 的体积摩尔生成速率。\n- 绝热反应器的稳态能量平衡：\n$$\\frac{T_{\\mathrm{in}} - T}{\\tau} + q\\, r = 0,$$\n其中 $\\,T_{\\mathrm{in}}\\,$ 是入口温度，$\\,T\\,$ 是反应器温度，$\\,q = \\frac{-\\Delta H}{\\rho C_p}\\,$ 是一个正的放热参数（其中 $\\,\\Delta H\\,$ 是放热反应焓，$\\,\\rho\\,$ 是混合物密度，$\\,C_p\\,$ 是混合物定压比热），$\\,r\\,$ 是体积反应速率。\n- 使用阿伦尼乌斯和质量作用动力学的单步燃料-氧化剂反应的反应速率：\n$$r = k_0 \\exp\\!\\left(-\\frac{E_a}{R\\, T}\\right) c_F^n c_O^m,$$\n其中 $\\,k_0\\,$ 是指前因子，$\\,E_a\\,$ 是活化能，$\\,R\\,$ 是普适气体常数，$\\,c_F\\,$ 和 $\\,c_O\\,$ 是燃料和氧化剂的摩尔浓度，$\\,n, m\\,$ 是反应级数（假设 $\\,n=m=1\\,$）。\n- 化学计量为 $\\,\\nu_F = 1\\,$ 和 $\\,\\nu_O = s\\,$，因此燃料和氧化剂的消耗速率为 $\\,\\omega_F = - r\\,$ 和 $\\,\\omega_O = - s\\, r\\,$。\n\n令状态向量为 $\\,\\mathbf{x} = [c_F, c_O, T]^\\top\\,$。使用平衡方程，残差方程组为\n$$\n\\begin{aligned}\nR_1(\\mathbf{x}, \\tau, \\phi) = \\frac{c_{F,\\mathrm{in}} - c_F}{\\tau} - r = 0, \\\\\nR_2(\\mathbf{x}, \\tau, \\phi) = \\frac{c_{O,\\mathrm{in}}(\\phi) - c_O}{\\tau} - s\\, r = 0, \\\\\nR_3(\\mathbf{x}, \\tau, \\phi) = \\frac{T_{\\mathrm{in}} - T}{\\tau} + q\\, r = 0,\n\\end{aligned}\n$$\n其中 $\\,c_{O,\\mathrm{in}}(\\phi) = \\frac{s\\, c_{F,\\mathrm{in}}}{\\phi}\\,$，且 $\\,r = k_0 \\exp\\!\\left(-\\frac{E_a}{R\\, T}\\right) c_F c_O\\,$。所有量的单位如下：$\\,c_F, c_O\\,$ 单位为 $\\mathrm{mol}/\\mathrm{m}^3$，$\\,\\tau\\,$ 单位为 $\\mathrm{s}$，$\\,T, T_{\\mathrm{in}}\\,$ 单位为 $\\mathrm{K}$，$\\,k_0\\,$ 单位为 $\\mathrm{s}^{-1}\\, (\\mathrm{mol}/\\mathrm{m}^3)^{-(n+m-1)}$，$\\,E_a\\,$ 单位为 $\\mathrm{J}/\\mathrm{mol}$，$\\,R\\,$ 单位为 $\\mathrm{J}/(\\mathrm{mol}\\,\\mathrm{K})$，$\\,q\\,$ 单位为 $\\mathrm{K}\\, \\mathrm{m}^3/\\mathrm{mol}$。化学计量系数 $\\,s\\,$ 是无量纲的。\n\n将雅可比矩阵 $\\,J(\\mathbf{x}; \\tau, \\phi)\\,$ 定义为 $[R_1,R_2,R_3]^\\top$ 关于 $\\,\\mathbf{x}\\,$ 的偏导数矩阵。当 $\\,\\det(J)\\,$ 趋近于 $\\,0\\,$ 时，或者等效地，当最小奇异值 $\\,\\sigma_{\\min}(J)\\,$ 趋近于 $\\,0\\,$ 时，会发生鞍结分岔和稳态分支的正则性丧失。您的算法必须沿分支监测 $\\,\\sigma_{\\min}(J)\\,$，并在 $\\,\\sigma_{\\min}(J)\\,$ 低于给定阈值时检测分岔。\n\n您必须：\n- 在标量参数 $\\,p \\in \\{\\tau,\\phi\\}\\,$ 上实现一个预测-校正伪弧长延拓。对由残差和弧长约束组成的增广系统使用基于割线的切线预测器和类牛顿校正器。具体来说，在每一步强制执行 $\\,\\mathbf{v}^\\top ([\\mathbf{x}; p] - [\\mathbf{x}^{(k)}; p^{(k)}]) - \\Delta s = 0\\,$，其中 $\\,\\mathbf{v}\\,$ 是归一化为单位长度的基于割线的切线，$\\,\\Delta s\\,$ 是弧长步长。\n- 使用通用求根器求解非线性系统以获得稳态解；通过从基于入口状态的初始猜测开始并使用延拓来追踪分支，确保解在物理上有意义。\n- 在每个收敛步计算 $\\,\\sigma_{\\min}(J)\\,$，并在 $\\,\\sigma_{\\min}(J)\\,$ 低于指定阈值时检测到一个事件。将每个 $\\,\\sigma_{\\min}(J)\\,$ 持续偏低的区间计为一个单独的分岔事件。\n\n物理单位：\n- 输入和内部计算中，浓度使用 $\\,\\mathrm{mol}/\\mathrm{m}^3\\,$，时间使用 $\\,\\mathrm{s}\\,$，温度使用 $\\,\\mathrm{K}\\,$。\n- 最终输出是检测到的分岔事件的无单位计数。\n\n测试套件：\n为以下参数集实现并运行您的算法。在所有集合中，使用 $\\,n=m=s=1\\,$，$\\,R = 8.314\\,\\mathrm{J}/(\\mathrm{mol}\\,\\mathrm{K})\\,$，$\\,c_{F,\\mathrm{in}} = 0.01\\,\\mathrm{mol}/\\mathrm{m}^3\\,$，$\\,T_{\\mathrm{in}} = 500\\,\\mathrm{K}\\,$，以及 $\\,q = 300\\,\\mathrm{K}\\,\\mathrm{m}^3/\\mathrm{mol}\\,$。\n1. $\\,\\tau\\,$ 中的常规延拓：\n   - 参数：$\\,k_0 = 3\\times 10^6\\,\\mathrm{s}^{-1}\\,$，$\\,E_a = 8.0\\times 10^4\\,\\mathrm{J}/\\mathrm{mol}\\,$，固定的 $\\,\\phi = 0.8\\,$。\n   - 延拓设置：起始于 $\\,\\tau_0 = 0.05\\,\\mathrm{s}\\,$，初始自然步长 $\\,\\Delta p_{\\mathrm{nat}} = 0.05\\,\\mathrm{s}\\,$ 以获得割线，弧长步长 $\\,\\Delta s = 0.05\\,$，最多 $\\,120\\,$ 个校正步，奇异值阈值 $\\,\\varepsilon_{\\sigma} = 10^{-6}\\,$。\n   - 输出：检测到的分岔的整数计数。\n2. $\\,\\tau\\,$ 中的低活化能边界情况：\n   - 参数：与用例 $\\,1\\,$ 相同，除了 $\\,E_a = 1.0\\times 10^4\\,\\mathrm{J}/\\mathrm{mol}\\,$。\n   - 延拓设置：与用例 $\\,1\\,$ 相同。\n   - 输出：检测到的分岔的整数计数。\n3. $\\,\\phi\\,$ 中的当量比延拓：\n   - 参数：与用例 $\\,1\\,$ 相同，固定的 $\\,\\tau = 2.5\\,\\mathrm{s}\\,$。\n   - 延拓设置：起始于 $\\,\\phi_0 = 0.6\\,$，初始自然步长 $\\,\\Delta p_{\\mathrm{nat}} = 0.05\\,$ 以获得割线，弧长步长 $\\,\\Delta s = 0.05\\,$，最多 $\\,120\\,$ 个校正步，奇异值阈值 $\\,\\varepsilon_{\\sigma} = 10^{-6}\\,$。\n   - 输出：检测到的分岔的整数计数。\n\n您的程序应生成一行输出，其中包含三个测试用例的计数，格式为方括号括起来的逗号分隔列表（例如，$[N_1,N_2,N_3]$）。结果必须是整数。",
            "solution": "该问题要求实现一种伪弧长延拓算法，以追踪理想搅拌反应器（PSR）的稳态解并检测鞍结分岔。该问题具有科学依据、是适定的，并为完整求解提供了所有必要信息。因此，该问题被认为是有效的。\n\n求解过程分为两个主要阶段：首先，对控制方程、雅可比矩阵和用于延拓的增广系统进行详细的数学建模；其次，设计并实现数值算法。\n\n### 数学建模\n\nPSR 的状态由物种浓度和温度的向量 $\\mathbf{x} = [c_F, c_O, T]^\\top$ 描述，其中 $c_F$ 是燃料浓度，$c_O$ 是氧化剂浓度，$T$ 是温度。控制方程构成一个非线性代数方程组 $\\mathbf{R}(\\mathbf{x}, p) = \\mathbf{0}$，其中 $p$ 是一个标量延拓参数，即停留时间 $\\tau$ 或当量比 $\\phi$。\n\n**1. 残差方程：**\n从稳态质量和能量平衡中导出的残差方程组如下：\n$$\n\\begin{aligned}\nR_1(\\mathbf{x}, p) = \\frac{c_{F,\\mathrm{in}} - c_F}{\\tau} - r(\\mathbf{x}) = 0 \\\\\nR_2(\\mathbf{x}, p) = \\frac{c_{O,\\mathrm{in}}(\\phi) - c_O}{\\tau} - s\\, r(\\mathbf{x}) = 0 \\\\\nR_3(\\mathbf{x}, p) = \\frac{T_{\\mathrm{in}} - T}{\\tau} + q\\, r(\\mathbf{x}) = 0\n\\end{aligned}\n$$\n其中反应速率 $r(\\mathbf{x})$ 由反应级数 $n=m=1$ 的阿伦尼乌斯定律和质量作用动力学给出：\n$$ r(\\mathbf{x}) = k_0 \\exp\\left(-\\frac{E_a}{R T}\\right) c_F c_O $$\n入口氧化剂浓度取决于当量比 $\\phi$：\n$$ c_{O,\\mathrm{in}}(\\phi) = \\frac{s\\, c_{F,\\mathrm{in}}}{\\phi} $$\n\n**2. 雅可比矩阵：**\n当系统的雅可比矩阵 $J = \\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{x}}$ 变为奇异时，会发生鞍结分岔。这通过监测其最小奇异值 $\\sigma_{\\min}(J)$ 来检测。解析雅可比矩阵对于基于牛顿法的校正步至关重要。其元素 $J_{ij} = \\frac{\\partial R_i}{\\partial x_j}$ 推导如下。\n\n首先，我们求出反应速率 $r$ 关于状态变量的偏导数：\n$$ \\frac{\\partial r}{\\partial c_F} = \\frac{r}{c_F}, \\quad \\frac{\\partial r}{\\partial c_O} = \\frac{r}{c_O}, \\quad \\frac{\\partial r}{\\partial T} = r \\frac{E_a}{R T^2} $$\n利用这些，雅可比矩阵 $J$ 的元素为：\n$$\nJ = \\begin{bmatrix}\n-\\frac{1}{\\tau} - \\frac{\\partial r}{\\partial c_F}  -\\frac{\\partial r}{\\partial c_O}  -\\frac{\\partial r}{\\partial T} \\\\\n-s \\frac{\\partial r}{\\partial c_F}  -\\frac{1}{\\tau} - s \\frac{\\partial r}{\\partial c_O}  -s \\frac{\\partial r}{\\partial T} \\\\\nq \\frac{\\partial r}{\\partial c_F}  q \\frac{\\partial r}{\\partial c_O}  -\\frac{1}{\\tau} + q \\frac{\\partial r}{\\partial T}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-\\frac{1}{\\tau} - \\frac{r}{c_F}  -\\frac{r}{c_O}  -r \\frac{E_a}{R T^2} \\\\\n-s \\frac{r}{c_F}  -\\frac{1}{\\tau} - s \\frac{r}{c_O}  -s r \\frac{E_a}{R T^2} \\\\\nq \\frac{r}{c_F}  q \\frac{r}{c_O}  -\\frac{1}{\\tau} + q r \\frac{E_a}{R T^2}\n\\end{bmatrix}\n$$\n\n**3. 伪弧长延拓：**\n为了追踪通过鞍结分岔的解曲线，我们用延拓参数增广状态向量，$\\mathbf{z} = [\\mathbf{x}; p]^\\top$，并添加一个约束方程。这样就得到了一个包含 $N+1$ 个未知数的 $N+1$ 个方程的增广系统。\n\n预测-校正算法对每一步 $k$ 的过程如下：\n- **预测器：** 给定收敛点 $\\mathbf{z}_{k-1}$ 和 $\\mathbf{z}_k$，计算基于割线的切向量 $\\mathbf{v}$：\n$$ \\mathbf{v} = \\frac{\\mathbf{z}_k - \\mathbf{z}_{k-1}}{\\|\\mathbf{z}_k - \\mathbf{z}_{k-1}\\|_2} $$\n通过从当前点 $\\mathbf{z}_k$ 沿切线方向前进一个弧长步长 $\\Delta s$ 来找到预测点 $\\mathbf{z}_p$：\n$$ \\mathbf{z}_p = \\mathbf{z}_k + \\Delta s \\, \\mathbf{v} $$\n- **校正器：** 从 $\\mathbf{z}_p$ 开始，我们使用类牛顿法对增广系统 $\\mathbf{G}(\\mathbf{z}) = \\mathbf{0}$ 求解曲线上的下一个点 $\\mathbf{z}_{k+1}$：\n$$\n\\mathbf{G}(\\mathbf{z}) = \\begin{bmatrix} \\mathbf{R}(\\mathbf{x}, p) \\\\ N(\\mathbf{z}) \\end{bmatrix} = \\begin{bmatrix} \\mathbf{R}(\\mathbf{x}, p) \\\\ \\mathbf{v}^\\top(\\mathbf{z} - \\mathbf{z}_k) - \\Delta s \\end{bmatrix} = \\mathbf{0}\n$$\n牛顿法需要这个增广系统的雅可比矩阵 $\\mathcal{J} = \\frac{\\partial \\mathbf{G}}{\\partial \\mathbf{z}}$：\n$$\n\\mathcal{J} = \\begin{bmatrix}\n\\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{x}}  \\frac{\\partial \\mathbf{R}}{\\partial p} \\\\\n\\frac{\\partial N}{\\partial \\mathbf{x}}  \\frac{\\partial N}{\\partial p}\n\\end{bmatrix} = \\begin{bmatrix}\nJ  \\mathbf{R}_p \\\\\n\\mathbf{v}_x^\\top  v_p\n\\end{bmatrix}\n$$\n其中 $\\mathbf{v} = [\\mathbf{v}_x; v_p]^\\top$ 且 $\\mathbf{R}_p = \\frac{\\partial \\mathbf{R}}{\\partial p}$。导数 $\\mathbf{R}_p$ 取决于哪个参数在变化：\n- 如果 $p = \\tau$：\n$$ \\mathbf{R}_\\tau = \\frac{\\partial \\mathbf{R}}{\\partial \\tau} = \\begin{bmatrix} (c_F - c_{F,\\mathrm{in}})/\\tau^2 \\\\ (c_O - c_{O,\\mathrm{in}}(\\phi))/\\tau^2 \\\\ (T - T_{\\mathrm{in}})/\\tau^2 \\end{bmatrix} $$\n- 如果 $p = \\phi$：\n$$ \\mathbf{R}_\\phi = \\frac{\\partial \\mathbf{R}}{\\partial \\phi} = \\begin{bmatrix} 0 \\\\ (1/\\tau) (\\partial c_{O,\\mathrm{in}}/\\partial \\phi) \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ -s c_{F,\\mathrm{in}}/(\\tau \\phi^2) \\\\ 0 \\end{bmatrix} $$\n\n### 算法实现\n\n该算法使用 Python 实现，其中 `numpy` 库用于数值线性代数，`scipy.optimize.root` 用作非线性求解器。\n\n1.  **初始化：** 对于每个测试用例，我们首先在解分支上找到两个初始点。\n    -   第一个点 $\\mathbf{z}_0 = [\\mathbf{x}_0; p_0]^\\top$ 是通过求解 $\\mathbf{R}(\\mathbf{x}, p_0) = \\mathbf{0}$ 得到的，其中 $p_0$ 设为其起始值。一个物理上合理的 $\\mathbf{x}$ 初始猜测是入口状态：$[c_{F,\\mathrm{in}}, c_{O,\\mathrm{in}}(p_0), T_{\\mathrm{in}}]^\\top$。\n    -   第二个点 $\\mathbf{z}_1 = [\\mathbf{x}_1; p_1]^\\top$ 是通过一个“自然参数”步长得到的，即求解 $\\mathbf{R}(\\mathbf{x}, p_1) = \\mathbf{0}$，其中 $p_1 = p_0 + \\Delta p_{\\mathrm{nat}}$，并使用 $\\mathbf{x}_0$ 作为初始猜测。\n\n2.  **延拓循环：** 主循环迭代指定的最多步数。在每一步中：\n    -   计算割线切向量 $\\mathbf{v}$ 和预测点 $\\mathbf{z}_p$。\n    -   调用 `scipy.optimize.root` 函数从 $\\mathbf{z}_p$ 开始求解增广系统 $\\mathbf{G}(\\mathbf{z}) = \\mathbf{0}$。我们同时提供残差函数及其解析雅可比矩阵，以确保鲁棒和高效的收敛。\n    -   将收敛点接受为 $\\mathbf{z}_{k+1}$。\n\n3.  **分岔检测：**\n    -   在每个收敛点 $\\mathbf{z}_{k+1}$，计算原始系统的雅可比矩阵 $J$。\n    -   使用 `scipy.linalg.svdvals` 计算其奇异值。提取最小奇异值 $\\sigma_{\\min}(J)$。\n    -   如果 $\\sigma_{\\min}(J)$ 低于给定阈值 $\\varepsilon_{\\sigma}$，则计为一个分岔事件。为了将一个连续的区间计为单个事件，使用一个状态标志（`in_bifurcation_zone`）。计数器仅在首次进入低于阈值的区域时增加。\n\n此过程应用于问题陈述中指定的三个测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root\nfrom scipy.linalg import svdvals\n\ndef solve():\n    \"\"\"\n    Main function to run the PSR continuation for all test cases and print results.\n    \"\"\"\n    # Common physical constants and parameters\n    R = 8.314  # J/(mol K)\n    C_F_IN = 0.01  # mol/m^3\n    T_IN = 500.0  # K\n    Q = 300.0  # K m^3/mol\n    S = 1.0  # stoichiometric coefficient (dimensionless)\n\n    # Test case definitions\n    test_cases = [\n        {\n            \"case_id\": 1,\n            \"k0\": 3.0e6, \"Ea\": 8.0e4, \"p_name\": \"tau\", \"fixed_param_val\": 0.8,\n            \"p_start\": 0.05, \"dp_nat\": 0.05, \"ds\": 0.05,\n            \"max_steps\": 120, \"eps_sigma\": 1e-6\n        },\n        {\n            \"case_id\": 2,\n            \"k0\": 3.0e6, \"Ea\": 1.0e4, \"p_name\": \"tau\", \"fixed_param_val\": 0.8,\n            \"p_start\": 0.05, \"dp_nat\": 0.05, \"ds\": 0.05,\n            \"max_steps\": 120, \"eps_sigma\": 1e-6\n        },\n        {\n            \"case_id\": 3,\n            \"k0\": 3.0e6, \"Ea\": 8.0e4, \"p_name\": \"phi\", \"fixed_param_val\": 2.5,\n            \"p_start\": 0.6, \"dp_nat\": 0.05, \"ds\": 0.05,\n            \"max_steps\": 120, \"eps_sigma\": 1e-6\n        },\n    ]\n\n    class PSRContinuationSolver:\n        \"\"\"\n        Encapsulates the PSR model and the continuation algorithm.\n        \"\"\"\n        def __init__(self, k0, Ea, p_name, fixed_param_val):\n            self.k0 = k0\n            self.Ea = Ea\n            self.p_name = p_name\n            if p_name == 'tau':\n                self.fixed_phi = fixed_param_val\n                self.fixed_tau = None\n            else: # p_name == 'phi'\n                self.fixed_tau = fixed_param_val\n                self.fixed_phi = None\n\n            # Corrector state variables, set during each step\n            self.z_k = None\n            self.v = None\n            self.ds = None\n\n        def _get_params(self, p):\n            if self.p_name == 'tau':\n                return p, self.fixed_phi\n            return self.fixed_tau, p\n\n        def c_o_in(self, phi):\n            return S * C_F_IN / phi\n\n        def reaction_rate(self, c_f, c_o, T):\n            if T = 0 or c_f = 0 or c_o = 0:\n                return 0.0\n            return self.k0 * np.exp(-self.Ea / (R * T)) * c_f * c_o\n\n        def residuals(self, x, p):\n            c_f, c_o, T = x\n            tau, phi = self._get_params(p)\n            r_val = self.reaction_rate(c_f, c_o, T)\n            \n            res1 = (C_F_IN - c_f) / tau - r_val\n            res2 = (self.c_o_in(phi) - c_o) / tau - S * r_val\n            res3 = (T_IN - T) / tau + Q * r_val\n            return np.array([res1, res2, res3])\n\n        def jacobian(self, x, p):\n            c_f, c_o, T = x\n            tau, _ = self._get_params(p)\n            \n            if T = 0 or c_f = 0 or c_o = 0:\n                # Return a non-singular matrix for stability if state is non-physical\n                return -np.identity(3) / tau\n\n            r_val = self.reaction_rate(c_f, c_o, T)\n            dr_dcf = r_val / c_f\n            dr_dco = r_val / c_o\n            dr_dT = r_val * self.Ea / (R * T**2)\n\n            J = np.zeros((3, 3))\n            J[0, 0] = -1.0/tau - dr_dcf\n            J[0, 1] = -dr_dco\n            J[0, 2] = -dr_dT\n            J[1, 0] = -S * dr_dcf\n            J[1, 1] = -1.0/tau - S * dr_dco\n            J[1, 2] = -S * dr_dT\n            J[2, 0] = Q * dr_dcf\n            J[2, 1] = Q * dr_dco\n            J[2, 2] = -1.0/tau + Q * dr_dT\n            return J\n\n        def R_p(self, x, p):\n            c_f, c_o, T = x\n            tau, phi = self._get_params(p)\n            \n            if self.p_name == 'tau':\n                dr_p1 = (c_f - C_F_IN) / tau**2\n                dr_p2 = (c_o - self.c_o_in(phi)) / tau**2\n                dr_p3 = (T - T_IN) / tau**2\n                return np.array([dr_p1, dr_p2, dr_p3])\n            else: # p_name == 'phi'\n                dr_p1 = 0.0\n                dr_p2 = (1.0 / tau) * (-S * C_F_IN / phi**2)\n                dr_p3 = 0.0\n                return np.array([dr_p1, dr_p2, dr_p3])\n\n        def _augmented_system(self, z):\n            x, p = z[:3], z[3]\n            x_k, p_k = self.z_k[:3], self.z_k[3]\n\n            G = np.zeros(4)\n            G[:3] = self.residuals(x, p)\n            G[3] = self.v.T @ (z - self.z_k) - self.ds\n            return G\n\n        def _augmented_jacobian(self, z):\n            x, p = z[:3], z[3]\n            J_aug = np.zeros((4, 4))\n            \n            J_aug[:3, :3] = self.jacobian(x, p)\n            J_aug[:3, 3] = self.R_p(x, p)\n            J_aug[3, :] = self.v\n            return J_aug\n\n        def run(self, p_start, dp_nat, ds, max_steps, eps_sigma):\n            # 1. Find the first point on the curve\n            p0 = p_start\n            _, phi_0 = self._get_params(p0)\n            x_guess_0 = np.array([C_F_IN * 0.99, self.c_o_in(phi_0) * 0.99, T_IN + 10])\n            sol_0 = root(self.residuals, x_guess_0, args=(p0,), jac=self.jacobian, method='hybr')\n            if not sol_0.success: return -1 # Error code\n            x0 = sol_0.x\n            z0 = np.append(x0, p0)\n\n            # 2. Find the second point by natural parameter stepping\n            p1 = p0 + dp_nat\n            sol_1 = root(self.residuals, x0, args=(p1,), jac=self.jacobian, method='hybr')\n            if not sol_1.success: return -1 # Error code\n            x1 = sol_1.x\n            z1 = np.append(x1, p1)\n            \n            z_current, z_prev = z1, z0\n            bifurcation_count = 0\n            in_bifurcation_zone = False\n\n            for _ in range(max_steps):\n                # 3. Predictor step\n                tangent = z_current - z_prev\n                v = tangent / np.linalg.norm(tangent)\n                z_pred = z_current + ds * v\n\n                # 4. Corrector step\n                self.z_k, self.v, self.ds = z_current, v, ds\n                corrector_sol = root(self._augmented_system, z_pred, jac=self._augmented_jacobian, method='hybr')\n                \n                if not corrector_sol.success:\n                    break # Stop continuation if corrector fails\n                \n                z_next = corrector_sol.x\n\n                # 5. Bifurcation detection\n                x_next, p_next = z_next[:3], z_next[3]\n                J_next = self.jacobian(x_next, p_next)\n                \n                try:\n                    singular_values = svdvals(J_next)\n                    sigma_min = np.min(singular_values)\n                except np.linalg.LinAlgError:\n                    sigma_min = 0.0\n\n                is_low = sigma_min  eps_sigma\n                if is_low and not in_bifurcation_zone:\n                    bifurcation_count += 1\n                    in_bifurcation_zone = True\n                elif not is_low:\n                    in_bifurcation_zone = False\n\n                # 6. Update for next step\n                z_prev, z_current = z_current, z_next\n                \n            return bifurcation_count\n\n    results = []\n    for case in test_cases:\n        solver = PSRContinuationSolver(\n            k0=case[\"k0\"],\n            Ea=case[\"Ea\"],\n            p_name=case[\"p_name\"],\n            fixed_param_val=case[\"fixed_param_val\"]\n        )\n        count = solver.run(\n            p_start=case[\"p_start\"],\n            dp_nat=case[\"dp_nat\"],\n            ds=case[\"ds\"],\n            max_steps=case[\"max_steps\"],\n            eps_sigma=case[\"eps_sigma\"]\n        )\n        results.append(count)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}