{
    "hands_on_practices": [
        {
            "introduction": "In practical applications, a reactor is often fed by multiple distinct streams, such as separate fuel, oxidizer, and diluent lines. This exercise builds from the first principle of mass conservation to derive the 'effective' inlet composition for a multi-inlet system. Mastering this allows you to correctly formulate the boundary conditions for a PSR model, a foundational skill for accurate simulation.",
            "id": "4049169",
            "problem": "Consider a Perfectly Stirred Reactor (PSR), defined as a reactor in which the contents are ideally and instantaneously mixed to spatial uniformity, operating at steady state with a single outlet and two ($2$) distinct inlet streams. Each inlet $i \\in \\{1,2\\}$ supplies a mass flow rate $\\dot{m}_{i}$ and carries a uniform species mass fraction $Y_{k,i}$ for a species $k$. The reactor is well-mixed, so all inflowing material is combined before any reaction processes within the control volume are modeled. Let the combined inlet be replaced by an equivalent single inflow of total mass flow rate $\\dot{m}_{\\text{in}}$ and an effective inlet mass fraction $Y_{k,\\text{in}}$ for the same species $k$, defined to produce the same total species $k$ inflow as the original two inlets.\n\nStarting from the species conservation principle for a control volume and the definition of species mass fraction as the ratio of species mass flow to total mass flow, derive the closed-form analytic expression for the effective inlet composition $Y_{k,\\text{in}}$ in terms of $\\dot{m}_{1}$, $\\dot{m}_{2}$, $Y_{k,1}$, and $Y_{k,2}$. State any assumptions you use, and ensure that your derivation is consistent with steady-state operation and mass conservation. Your final answer must be a single closed-form analytic expression (dimensionless). No numerical evaluation is required.",
            "solution": "The derivation of the effective inlet mass fraction for a multi-inlet Perfectly Stirred Reactor (PSR) is predicated on the fundamental principle of mass conservation for both the total mixture and for each individual species. The problem statement establishes a clear equivalence criterion: the mass flow of a given species $k$ supplied by a hypothetical single inlet must be identical to the sum of the mass flows of that same species from the actual multiple inlets. We shall proceed by formalizing this criterion.\n\nLet us begin by defining the relationship between total mass flow rate, species mass flow rate, and species mass fraction. For any given stream, the mass fraction of species $k$, denoted by $Y_k$, is the ratio of the mass flow rate of that species, $\\dot{m}_k$, to the total mass flow rate of the stream, $\\dot{m}$.\n$$Y_k = \\frac{\\dot{m}_k}{\\dot{m}}$$\nFrom this definition, the mass flow rate of species $k$ can be expressed as:\n$$\\dot{m}_k = Y_k \\dot{m}$$\nThis relationship is the cornerstone of our derivation.\n\nThe system described has two distinct inlet streams, indexed by $i \\in \\{1, 2\\}$.\nFor the first inlet stream ($i=1$), the total mass flow rate is $\\dot{m}_{1}$ and the mass fraction of species $k$ is $Y_{k,1}$. Therefore, the mass flow rate of species $k$ entering the reactor from this stream is:\n$$\\dot{m}_{k,1} = Y_{k,1} \\dot{m}_{1}$$\nFor the second inlet stream ($i=2$), the total mass flow rate is $\\dot{m}_{2}$ and the mass fraction of species $k$ is $Y_{k,2}$. The mass flow rate of species $k$ from this stream is:\n$$\\dot{m}_{k,2} = Y_{k,2} \\dot{m}_{2}$$\nThe reactor operates at steady state. A necessary condition for steady-state operation is the conservation of mass. The total mass of species $k$ entering the reactor control volume per unit time, $\\dot{m}_{k,\\text{total in}}$, is the sum of the species mass flow rates from all inlet streams.\n$$\\dot{m}_{k,\\text{total in}} = \\sum_{i=1}^{2} \\dot{m}_{k,i} = \\dot{m}_{k,1} + \\dot{m}_{k,2}$$\nSubstituting the expressions for $\\dot{m}_{k,1}$ and $\\dot{m}_{k,2}$, we get:\n$$\\dot{m}_{k,\\text{total in}} = Y_{k,1} \\dot{m}_{1} + Y_{k,2} \\dot{m}_{2}$$\nSimilarly, the total mass flow rate entering the reactor, $\\dot{m}_{\\text{in}}$, is the sum of the individual inlet mass flow rates:\n$$\\dot{m}_{\\text{in}} = \\dot{m}_{1} + \\dot{m}_{2}$$\nThe problem posits an equivalent single inlet stream designed to replace the two original streams. This equivalent stream has a total mass flow rate of $\\dot{m}_{\\text{in}}$ and an effective inlet mass fraction for species $k$ of $Y_{k,\\text{in}}$. The mass flow rate of species $k$ from this equivalent inlet, $\\dot{m}_{k,\\text{in}}$, is defined as:\n$$\\dot{m}_{k,\\text{in}} = Y_{k,\\text{in}} \\dot{m}_{\\text{in}}$$\nThe core condition for equivalence, as stated in the problem, is that the total species inflow remains the same.\n$$\\dot{m}_{k,\\text{in}} = \\dot{m}_{k,\\text{total in}}$$\nWe can now equate the expressions for these two quantities:\n$$Y_{k,\\text{in}} \\dot{m}_{\\text{in}} = Y_{k,1} \\dot{m}_{1} + Y_{k,2} \\dot{m}_{2}$$\nTo solve for $Y_{k,\\text{in}}$, we substitute the expression for the total inlet mass flow rate, $\\dot{m}_{\\text{in}} = \\dot{m}_{1} + \\dot{m}_{2}$, into the left-hand side of the equation:\n$$Y_{k,\\text{in}} (\\dot{m}_{1} + \\dot{m}_{2}) = Y_{k,1} \\dot{m}_{1} + Y_{k,2} \\dot{m}_{2}$$\nFinally, we isolate $Y_{k,\\text{in}}$ by dividing both sides by the total mass flow rate, $(\\dot{m}_{1} + \\dot{m}_{2})$. This is permissible as mass flow rates are non-negative, and for a physical system with inflow, their sum must be positive.\n$$Y_{k,\\text{in}} = \\frac{Y_{k,1} \\dot{m}_{1} + Y_{k,2} \\dot{m}_{2}}{\\dot{m}_{1} + \\dot{m}_{2}}$$\nThis expression represents the mass-weighted average of the individual inlet mass fractions.\n\nThe primary assumptions underpinning this derivation are:\n$1$. The system is at steady state, meaning all flow rates and compositions at the inlets are constant over time.\n$2$. The principle of mass conservation applies to both the total mass and the mass of each individual species.\n$3$. The definitions of mass flow rate and mass fraction are applied consistently.\n\nThe resulting expression is a closed-form, dimensionless quantity that depends only on the given inlet properties, as required. It is the analytic expression for the effective inlet composition used in modeling multi-inlet reactor systems as a simplified single-inlet system.",
            "answer": "$$\\boxed{\\frac{\\dot{m}_{1} Y_{k,1} + \\dot{m}_{2} Y_{k,2}}{\\dot{m}_{1} + \\dot{m}_{2}}}$$"
        },
        {
            "introduction": "The behavior of a Perfectly Stirred Reactor is governed by the tight coupling between thermodynamics, chemical kinetics, and fluid dynamics. This problem demonstrates this interdependence by tasking you to relate the reactor's density and mass flow rate to its temperature, pressure, and composition using the ideal gas law and the definition of residence time. Understanding this coupling is key to interpreting PSR model results and diagnosing the interplay between physical and chemical processes.",
            "id": "4049170",
            "problem": "A Perfectly Stirred Reactor (PSR) operates at steady state with uniform properties throughout the reactor. The outlet (equal to reactor state) pressure is $p = 2.50$ $\\text{atm}$, the temperature is $T = 1100$ $\\text{K}$, and the outlet mixture composition is given by species mole fractions: $\\text{CO}_{2}$ with $X_{\\text{CO}_{2}} = 0.09$, $\\text{H}_{2}\\text{O}$ with $X_{\\text{H}_{2}\\text{O}} = 0.11$, $\\text{N}_{2}$ with $X_{\\text{N}_{2}} = 0.76$, and $\\text{O}_{2}$ with $X_{\\text{O}_{2}} = 0.04$. The reactor volume is $V = 0.050$ $\\text{m}^{3}$, and the residence time at reactor conditions is $\\tau = 0.20$ $\\text{s}$. Assume an ideal gas mixture and no accumulation, with inlet and outlet mass flow rates equal.\n\nUsing only first principles and well-established definitions, derive an expression for the outlet density $\\rho$ in terms of $p$, $T$, and the mixture-average molar mass $M_{\\text{mix}}$, and use it to obtain the mass flow rate $\\dot{m}$ via the residence time definition. Then, articulate how $\\rho$ and $\\dot{m}$ couple back into the steady-state species balances through $\\tau$.\n\nNumerically evaluate the mass flow rate $\\dot{m}$ using the following molecular masses: $M_{\\text{CO}_{2}} = 44.01$ $\\text{g/mol}$, $M_{\\text{H}_{2}\\text{O}} = 18.01528$ $\\text{g/mol}$, $M_{\\text{N}_{2}} = 28.0134$ $\\text{g/mol}$, $M_{\\text{O}_{2}} = 31.998$ $\\text{g/mol}$, and the Universal Gas Constant (UGC) $R_{u} = 8.314462618$ $\\text{J/mol/K}$. Convert pressure to Pascals. Express the final mass flow rate in $\\text{kg/s}$ and round your answer to four significant figures.",
            "solution": "The problem requires the derivation of an expression for the outlet density $\\rho$, its use in determining the mass flow rate $\\dot{m}$, and an explanation of the coupling between these quantities and the species conservation equations in a Perfectly Stirred Reactor (PSR). Finally, a numerical value for $\\dot{m}$ is to be calculated.\n\nFirst, we derive the expression for the mixture density, $\\rho$. We begin with the ideal gas law for a mixture:\n$$p V = n R_{u} T$$\nwhere $p$ is the pressure, $V$ is the volume, $n$ is the total number of moles of gas in the volume, $R_{u}$ is the universal gas constant, and $T$ is the temperature.\n\nThe total mass $m$ in the volume $V$ is related to the total number of moles $n$ through the mixture-average molar mass $M_{\\text{mix}}$:\n$$m = n M_{\\text{mix}}$$\nSolving for $n$ gives $n = \\frac{m}{M_{\\text{mix}}}$. Substituting this into the ideal gas law:\n$$p V = \\left(\\frac{m}{M_{\\text{mix}}}\\right) R_{u} T$$\nDensity $\\rho$ is defined as mass per unit volume, $\\rho = \\frac{m}{V}$. We can rearrange the equation above to isolate this term:\n$$p = \\left(\\frac{m}{V}\\right) \\frac{R_{u} T}{M_{\\text{mix}}} = \\rho \\frac{R_{u} T}{M_{\\text{mix}}}$$\nSolving for the density $\\rho$ yields the desired expression:\n$$\\rho = \\frac{p M_{\\text{mix}}}{R_{u} T}$$\nThis expression relates the density of the ideal gas mixture to its pressure, temperature, and average molar mass.\n\nNext, we use this expression to find the mass flow rate $\\dot{m}$. The residence time $\\tau$ in a PSR is defined as the average time a fluid element spends in the reactor. For a steady-flow system, it is the ratio of the mass of the fluid inside the reactor, $m$, to the mass flow rate $\\dot{m}$ through the reactor:\n$$\\tau = \\frac{m}{\\dot{m}}$$\nThe mass $m$ in the reactor volume $V$ is given by $m = \\rho V$. Substituting this into the definition of residence time:\n$$\\tau = \\frac{\\rho V}{\\dot{m}}$$\nSolving for the mass flow rate $\\dot{m}$:\n$$\\dot{m} = \\frac{\\rho V}{\\tau}$$\nNow, we substitute our previously derived expression for $\\rho$:\n$$\\dot{m} = \\left(\\frac{p M_{\\text{mix}}}{R_{u} T}\\right) \\frac{V}{\\tau} = \\frac{p V M_{\\text{mix}}}{R_{u} T \\tau}$$\n\nThe problem also asks how $\\rho$ and $\\dot{m}$ couple back into the steady-state species balances. The steady-state mass balance for a species $k$ in a PSR is:\n$$(\\text{mass flow in}) - (\\text{mass flow out}) + (\\text{mass production by reaction}) = 0$$\n$$\\dot{m} Y_{k,in} - \\dot{m} Y_{k} + V \\dot{\\omega}_{k} M_{k} = 0$$\nwhere $Y_{k,in}$ and $Y_{k}$ are the inlet and outlet (reactor) mass fractions of species $k$, $\\dot{\\omega}_{k}$ is the molar production rate of species $k$ per unit volume, and $M_k$ is the molar mass of species $k$. Rearranging to solve for the change in composition:\n$$\\dot{m} (Y_{k} - Y_{k,in}) = V \\dot{\\omega}_{k} M_{k}$$\n$$Y_{k} - Y_{k,in} = \\frac{V}{\\dot{m}} \\dot{\\omega}_{k} M_{k}$$\nFrom the residence time definition, $\\tau = \\frac{\\rho V}{\\dot{m}}$, we can write the ratio $\\frac{V}{\\dot{m}}$ as $\\frac{\\tau}{\\rho}$. Substituting this into the rearranged species balance equation gives:\n$$Y_{k} - Y_{k,in} = \\frac{\\tau}{\\rho} \\dot{\\omega}_{k} M_{k}$$\nThis final equation explicitly shows the coupling. The change in a species' mass fraction across the reactor is proportional to the residence time $\\tau$ and the chemical source term, and inversely proportional to the density $\\rho$. Since $\\dot{m}$ is related to $\\rho$ and $\\tau$ via $\\dot{m} = \\rho V / \\tau$, all three quantities are intrinsically linked within the governing equations of the reactor.\n\nFinally, we perform the numerical calculation for the mass flow rate $\\dot{m}$.\nThe given data are:\n$p = 2.50$ $\\text{atm}$\n$T = 1100$ $\\text{K}$\n$V = 0.050$ $\\text{m}^{3}$\n$\\tau = 0.20$ $\\text{s}$\n$X_{\\text{CO}_{2}} = 0.09$\n$X_{\\text{H}_{2}\\text{O}} = 0.11$\n$X_{\\text{N}_{2}} = 0.76$\n$X_{\\text{O}_{2}} = 0.04$\nMolar masses ($M_k$): $M_{\\text{CO}_{2}} = 44.01$ $\\text{g/mol}$, $M_{\\text{H}_{2}\\text{O}} = 18.01528$ $\\text{g/mol}$, $M_{\\text{N}_{2}} = 28.0134$ $\\text{g/mol}$, $M_{\\text{O}_{2}} = 31.998$ $\\text{g/mol}$.\nUniversal Gas Constant: $R_{u} = 8.314462618$ $\\text{J/mol/K}$.\n\nFirst, we calculate the mixture-average molar mass, $M_{\\text{mix}}$, which is the sum of the mole-fraction-weighted molar masses of the constituent species:\n$$M_{\\text{mix}} = \\sum_{k} X_{k} M_{k}$$\n$$M_{\\text{mix}} = X_{\\text{CO}_{2}}M_{\\text{CO}_{2}} + X_{\\text{H}_{2}\\text{O}}M_{\\text{H}_{2}\\text{O}} + X_{\\text{N}_{2}}M_{\\text{N}_{2}} + X_{\\text{O}_{2}}M_{\\text{O}_{2}}$$\n$$M_{\\text{mix}} = (0.09)(44.01) + (0.11)(18.01528) + (0.76)(28.0134) + (0.04)(31.998) \\text{ g/mol}$$\n$$M_{\\text{mix}} = 3.9609 + 1.9816808 + 21.290184 + 1.27992 \\text{ g/mol}$$\n$$M_{\\text{mix}} = 28.5126848 \\text{ g/mol}$$\nFor use in SI units, we convert this to kilograms per mole:\n$$M_{\\text{mix}} = 0.0285126848 \\text{ kg/mol}$$\n\nNext, we convert the pressure from atmospheres to Pascals, using the standard conversion $1$ $\\text{atm}$ $= 101325$ $\\text{Pa}$:\n$$p = 2.50 \\text{ atm} \\times \\frac{101325 \\text{ Pa}}{1 \\text{ atm}} = 253312.5 \\text{ Pa}$$\n\nNow we can substitute all values into the expression for $\\dot{m}$:\n$$\\dot{m} = \\frac{p V M_{\\text{mix}}}{R_{u} T \\tau}$$\n$$\\dot{m} = \\frac{(253312.5 \\text{ Pa})(0.050 \\text{ m}^{3})(0.0285126848 \\text{ kg/mol})}{(8.314462618 \\text{ J/mol/K})(1100 \\text{ K})(0.20 \\text{ s})}$$\n$$\\dot{m} = \\frac{361.161048}{1829.18177596} \\text{ kg/s}$$\n$$\\dot{m} \\approx 0.19744005 \\text{ kg/s}$$\nRounding to four significant figures as requested, the mass flow rate is:\n$$\\dot{m} = 0.1974 \\text{ kg/s}$$",
            "answer": "$$\\boxed{0.1974}$$"
        },
        {
            "introduction": "Perfectly Stirred Reactors are famous for exhibiting complex nonlinear behavior, including multiple steady states and sudden transitions like ignition and extinction. This advanced practice moves beyond solving for a single steady state and challenges you to implement a continuation algorithm to trace the entire solution curve and pinpoint these critical bifurcation points. This powerful numerical technique is a cornerstone of stability analysis in chemical engineering and combustion science, providing a complete picture of a reactor's operational map.",
            "id": "4049184",
            "problem": "You are tasked with implementing a robust continuation algorithm for steady-state modeling of a Perfectly Stirred Reactor (PSR) in computational combustion. The PSR is modeled as a zeroth-dimensional reactor at steady state with one irreversible exothermic reaction between a fuel and an oxidizer: the reaction rate is governed by an Arrhenius law and mass-action kinetics. You must derive the governing algebraic system for steady state from fundamental balances, design a predictor-corrector continuation algorithm in either the residence time $\\,\\tau\\,$ or the equivalence ratio $\\,\\phi\\,$, and detect fold bifurcations by monitoring the determinant or the smallest singular value of the Jacobian $\\,J\\,$ of the residuals with respect to the state variables. Your final program must compute integer counts of detected bifurcation events for three specified test cases and output them in a single line list format.\n\nStart from the following fundamental laws and core definitions:\n- Steady-state species molar balance for each species $\\,i\\,$ in a perfectly stirred reactor: \n$$\\frac{c_{i,\\mathrm{in}} - c_i}{\\tau} + \\omega_i = 0,$$\nwhere $\\,c_{i,\\mathrm{in}}\\,$ is the inlet molar concentration of species $\\,i\\,$, $\\,c_i\\,$ is the outlet (and in-reactor) molar concentration, $\\,\\tau\\,$ is the residence time, and $\\,\\omega_i\\,$ is the volumetric molar production rate of species $\\,i\\,$ due to chemical reaction.\n- Steady-state energy balance for an adiabatic reactor:\n$$\\frac{T_{\\mathrm{in}} - T}{\\tau} + q\\, r = 0,$$\nwhere $\\,T_{\\mathrm{in}}\\,$ is the inlet temperature, $\\,T\\,$ is the reactor temperature, $\\,q = \\frac{-\\Delta H}{\\rho C_p}\\,$ is a positive heat-release parameter (with $\\,\\Delta H\\,$ the exothermic reaction enthalpy, $\\,\\rho\\,$ the mixture density, and $\\,C_p\\,$ the mixture specific heat at constant pressure), and $\\,r\\,$ is the volumetric reaction rate.\n- Reaction rate for a single-step fuel-oxidizer reaction using Arrhenius and mass-action kinetics:\n$$r = k_0 \\exp\\!\\left(-\\frac{E_a}{R\\, T}\\right) c_F^n c_O^m,$$\nwhere $\\,k_0\\,$ is the pre-exponential factor, $\\,E_a\\,$ is the activation energy, $\\,R\\,$ is the universal gas constant, $\\,c_F\\,$ and $\\,c_O\\,$ are the molar concentrations of fuel and oxidizer, and $\\,n, m\\,$ are reaction orders (assume $\\,n=m=1\\,$).\n- Stoichiometry is $\\,\\nu_F = 1\\,$ and $\\,\\nu_O = s\\,$, so fuel and oxidizer are consumed as $\\,\\omega_F = - r\\,$ and $\\,\\omega_O = - s\\, r\\,$.\n\nLet the state vector be $\\,\\mathbf{x} = [c_F, c_O, T]^\\top\\,$. Using the balances, the residual equations are\n$$\n\\begin{aligned}\nR_1(\\mathbf{x}, \\tau, \\phi) &= \\frac{c_{F,\\mathrm{in}} - c_F}{\\tau} - r = 0, \\\\\nR_2(\\mathbf{x}, \\tau, \\phi) &= \\frac{c_{O,\\mathrm{in}}(\\phi) - c_O}{\\tau} - s\\, r = 0, \\\\\nR_3(\\mathbf{x}, \\tau, \\phi) &= \\frac{T_{\\mathrm{in}} - T}{\\tau} + q\\, r = 0,\n\\end{aligned}\n$$\nwith $\\,c_{O,\\mathrm{in}}(\\phi) = \\frac{s\\, c_{F,\\mathrm{in}}}{\\phi}\\,$, and $\\,r = k_0 \\exp\\!\\left(-\\frac{E_a}{R\\, T}\\right) c_F c_O\\,$. All quantities are in the following units: $\\,c_F, c_O\\,$ in $\\mathrm{mol}/\\mathrm{m}^3$, $\\,\\tau\\,$ in $\\mathrm{s}$, $\\,T, T_{\\mathrm{in}}\\,$ in $\\mathrm{K}$, $\\,k_0\\,$ in $\\mathrm{s}^{-1}\\, (\\mathrm{mol}/\\mathrm{m}^3)^{-(n+m-1)}$, $\\,E_a\\,$ in $\\mathrm{J}/\\mathrm{mol}$, $\\,R\\,$ in $\\mathrm{J}/(\\mathrm{mol}\\,\\mathrm{K})$, and $\\,q\\,$ in $\\mathrm{K}\\, \\mathrm{m}^3/\\mathrm{mol}$. The stoichiometric coefficient $\\,s\\,$ is dimensionless.\n\nDefine the Jacobian $\\,J(\\mathbf{x}; \\tau, \\phi)\\,$ as the matrix of partial derivatives of $[R_1,R_2,R_3]^\\top$ with respect to $\\,\\mathbf{x}\\,$. A fold bifurcation and loss of regularity of the steady-state branch occurs when $\\,\\det(J)\\,$ approaches $\\,0\\,$, equivalently when the smallest singular value $\\,\\sigma_{\\min}(J)\\,$ approaches $\\,0\\,$. Your algorithm must monitor $\\,\\sigma_{\\min}(J)\\,$ along the branch and detect bifurcations when $\\,\\sigma_{\\min}(J)\\,$ falls below a given threshold.\n\nYou must:\n- Implement a predictor-corrector pseudo-arclength continuation in the scalar parameter $\\,p \\in \\{\\tau,\\phi\\}\\,$. Use a secant-based tangent predictor and a Newton-like corrector on the augmented system consisting of the residuals and an arclength constraint. Explicitly, at each step enforce $\\,\\mathbf{v}^\\top ([\\mathbf{x}; p] - [\\mathbf{x}^{(k)}; p^{(k)}]) - \\Delta s = 0\\,$, where $\\,\\mathbf{v}\\,$ is the secant-based tangent normalized to unit length and $\\,\\Delta s\\,$ is the arclength step.\n- Solve the nonlinear systems to obtain steady states using a general-purpose root finder; ensure physically meaningful solutions by starting from inlet-based initial guesses and using continuation to trace branches.\n- Compute $\\,\\sigma_{\\min}(J)\\,$ at each converged step and detect an event whenever $\\,\\sigma_{\\min}(J)\\,$ drops below a specified threshold. Count each contiguous episode of low $\\,\\sigma_{\\min}(J)\\,$ as a single bifurcation event.\n\nPhysical units:\n- Input and internal computations use $\\,\\mathrm{mol}/\\mathrm{m}^3\\,$ for concentrations, $\\,\\mathrm{s}\\,$ for time, and $\\,\\mathrm{K}\\,$ for temperature.\n- The final output is unitless counts of detected bifurcation events.\n\nTest Suite:\nImplement and run your algorithm for the following parameter sets. In all sets, use $\\,n=m=s=1\\,$, $\\,R = 8.314\\,\\mathrm{J}/(\\mathrm{mol}\\,\\mathrm{K})\\,$, $\\,c_{F,\\mathrm{in}} = 0.01\\,\\mathrm{mol}/\\mathrm{m}^3\\,$, $\\,T_{\\mathrm{in}} = 500\\,\\mathrm{K}\\,$, and $\\,q = 300\\,\\mathrm{K}\\,\\mathrm{m}^3/\\mathrm{mol}\\,$.\n1. Happy-path continuation in $\\,\\tau\\,$:\n   - Parameters: $\\,k_0 = 3\\times 10^6\\,\\mathrm{s}^{-1}\\,$, $\\,E_a = 8.0\\times 10^4\\,\\mathrm{J}/\\mathrm{mol}\\,$, fixed $\\,\\phi = 0.8\\,$.\n   - Continuation settings: start at $\\,\\tau_0 = 0.05\\,\\mathrm{s}\\,$, initial natural step $\\,\\Delta p_{\\mathrm{nat}} = 0.05\\,\\mathrm{s}\\,$ to obtain a secant, arclength step $\\,\\Delta s = 0.05\\,$, maximum of $\\,120\\,$ corrected steps, and singular-value threshold $\\,\\varepsilon_{\\sigma} = 10^{-6}\\,$.\n   - Output: an integer count of detected bifurcations.\n2. Low-activation-energy edge case in $\\,\\tau\\,$:\n   - Parameters: identical to case $\\,1\\,$ except $\\,E_a = 1.0\\times 10^4\\,\\mathrm{J}/\\mathrm{mol}\\,$.\n   - Continuation settings: identical to case $\\,1\\,$.\n   - Output: an integer count of detected bifurcations.\n3. Equivalence-ratio continuation in $\\,\\phi\\,$:\n   - Parameters: identical to case $\\,1\\,$ with fixed $\\,\\tau = 2.5\\,\\mathrm{s}\\,$.\n   - Continuation settings: start at $\\,\\phi_0 = 0.6\\,$, initial natural step $\\,\\Delta p_{\\mathrm{nat}} = 0.05\\,$ to obtain a secant, arclength step $\\,\\Delta s = 0.05\\,$, maximum of $\\,120\\,$ corrected steps, and singular-value threshold $\\,\\varepsilon_{\\sigma} = 10^{-6}\\,$.\n   - Output: an integer count of detected bifurcations.\n\nYour program should produce a single line of output containing the counts for the three test cases as a comma-separated list enclosed in square brackets (e.g., $[N_1,N_2,N_3]$). The results must be integers.",
            "solution": "The solution proceeds in two main stages: first, a detailed mathematical formulation of the governing equations, the Jacobian, and the augmented system for continuation; second, the design and implementation of the numerical algorithm.\n\n### Mathematical Formulation\n\nThe state of the PSR is described by the vector of species concentrations and temperature, $\\mathbf{x} = [c_F, c_O, T]^\\top$, where $c_F$ is the fuel concentration, $c_O$ is the oxidizer concentration, and $T$ is the temperature. The governing equations form a system of nonlinear algebraic equations, $\\mathbf{R}(\\mathbf{x}, p) = \\mathbf{0}$, where $p$ is a scalar continuation parameter, either the residence time $\\tau$ or the equivalence ratio $\\phi$.\n\n**1. Residual Equations:**\nThe system of residual equations, derived from steady-state mass and energy balances, is given as:\n$$\n\\begin{aligned}\nR_1(\\mathbf{x}, p) &= \\frac{c_{F,\\mathrm{in}} - c_F}{\\tau} - r(\\mathbf{x}) = 0 \\\\\nR_2(\\mathbf{x}, p) &= \\frac{c_{O,\\mathrm{in}}(\\phi) - c_O}{\\tau} - s\\, r(\\mathbf{x}) = 0 \\\\\nR_3(\\mathbf{x}, p) &= \\frac{T_{\\mathrm{in}} - T}{\\tau} + q\\, r(\\mathbf{x}) = 0\n\\end{aligned}\n$$\nwhere the reaction rate $r(\\mathbf{x})$ is given by the Arrhenius law with mass-action kinetics for reaction orders $n=m=1$:\n$$ r(\\mathbf{x}) = k_0 \\exp\\left(-\\frac{E_a}{R T}\\right) c_F c_O $$\nThe inlet oxidizer concentration depends on the equivalence ratio $\\phi$:\n$$ c_{O,\\mathrm{in}}(\\phi) = \\frac{s\\, c_{F,\\mathrm{in}}}{\\phi} $$\n\n**2. Jacobian Matrix:**\nA fold bifurcation occurs when the system's Jacobian matrix, $J = \\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{x}}$, becomes singular. This is detected by monitoring its smallest singular value, $\\sigma_{\\min}(J)$. The analytical Jacobian is essential for the Newton-based corrector step. Its elements $J_{ij} = \\frac{\\partial R_i}{\\partial x_j}$ are derived as follows.\n\nFirst, we find the partial derivatives of the reaction rate $r$ with respect to the state variables:\n$$ \\frac{\\partial r}{\\partial c_F} = \\frac{r}{c_F}, \\quad \\frac{\\partial r}{\\partial c_O} = \\frac{r}{c_O}, \\quad \\frac{\\partial r}{\\partial T} = r \\frac{E_a}{R T^2} $$\nUsing these, the elements of the Jacobian $J$ are:\n$$\nJ = \\begin{bmatrix}\n-\\frac{1}{\\tau} - \\frac{\\partial r}{\\partial c_F} & -\\frac{\\partial r}{\\partial c_O} & -\\frac{\\partial r}{\\partial T} \\\\\n-s \\frac{\\partial r}{\\partial c_F} & -\\frac{1}{\\tau} - s \\frac{\\partial r}{\\partial c_O} & -s \\frac{\\partial r}{\\partial T} \\\\\nq \\frac{\\partial r}{\\partial c_F} & q \\frac{\\partial r}{\\partial c_O} & -\\frac{1}{\\tau} + q \\frac{\\partial r}{\\partial T}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-\\frac{1}{\\tau} - \\frac{r}{c_F} & -\\frac{r}{c_O} & -r \\frac{E_a}{R T^2} \\\\\n-s \\frac{r}{c_F} & -\\frac{1}{\\tau} - s \\frac{r}{c_O} & -s r \\frac{E_a}{R T^2} \\\\\nq \\frac{r}{c_F} & q \\frac{r}{c_O} & -\\frac{1}{\\tau} + q r \\frac{E_a}{R T^2}\n\\end{bmatrix}\n$$\n\n**3. Pseudo-Arclength Continuation:**\nTo trace the solution curve through fold bifurcations, we augment the state vector with the continuation parameter, $\\mathbf{z} = [\\mathbf{x}; p]^\\top$, and add a constraint equation. This results in an augmented system of $N+1$ equations for $N+1$ unknowns.\n\nThe predictor-corrector algorithm proceeds as follows for each step $k$:\n- **Predictor:** Given converged points $\\mathbf{z}_{k-1}$ and $\\mathbf{z}_k$, a secant-based tangent vector $\\mathbf{v}$ is computed:\n$$ \\mathbf{v} = \\frac{\\mathbf{z}_k - \\mathbf{z}_{k-1}}{\\|\\mathbf{z}_k - \\mathbf{z}_{k-1}\\|_2} $$\nA predictor point $\\mathbf{z}_p$ is found by advancing from the current point $\\mathbf{z}_k$ along the tangent direction by an arclength step $\\Delta s$:\n$$ \\mathbf{z}_p = \\mathbf{z}_k + \\Delta s \\, \\mathbf{v} $$\n- **Corrector:** Starting from $\\mathbf{z}_p$, we solve for the next point on the curve, $\\mathbf{z}_{k+1}$, using a Newton-like method on the augmented system $\\mathbf{G}(\\mathbf{z}) = \\mathbf{0}$:\n$$\n\\mathbf{G}(\\mathbf{z}) = \\begin{bmatrix} \\mathbf{R}(\\mathbf{x}, p) \\\\ N(\\mathbf{z}) \\end{bmatrix} = \\begin{bmatrix} \\mathbf{R}(\\mathbf{x}, p) \\\\ \\mathbf{v}^\\top(\\mathbf{z} - \\mathbf{z}_k) - \\Delta s \\end{bmatrix} = \\mathbf{0}\n$$\nThe Jacobian of this augmented system, $\\mathcal{J} = \\frac{\\partial \\mathbf{G}}{\\partial \\mathbf{z}}$, is required for Newton's method:\n$$\n\\mathcal{J} = \\begin{bmatrix}\n\\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{x}} & \\frac{\\partial \\mathbf{R}}{\\partial p} \\\\\n\\frac{\\partial N}{\\partial \\mathbf{x}} & \\frac{\\partial N}{\\partial p}\n\\end{bmatrix} = \\begin{bmatrix}\nJ & \\mathbf{R}_p \\\\\n\\mathbf{v}_x^\\top & v_p\n\\end{bmatrix}\n$$\nwhere $\\mathbf{v} = [\\mathbf{v}_x; v_p]^\\top$ and $\\mathbf{R}_p = \\frac{\\partial \\mathbf{R}}{\\partial p}$. The derivatives $\\mathbf{R}_p$ depend on which parameter is being varied:\n- If $p = \\tau$:\n$$ \\mathbf{R}_\\tau = \\frac{\\partial \\mathbf{R}}{\\partial \\tau} = \\begin{bmatrix} (c_F - c_{F,\\mathrm{in}})/\\tau^2 \\\\ (c_O - c_{O,\\mathrm{in}}(\\phi))/\\tau^2 \\\\ (T - T_{\\mathrm{in}})/\\tau^2 \\end{bmatrix} $$\n- If $p = \\phi$:\n$$ \\mathbf{R}_\\phi = \\frac{\\partial \\mathbf{R}}{\\partial \\phi} = \\begin{bmatrix} 0 \\\\ (1/\\tau) (\\partial c_{O,\\mathrm{in}}/\\partial \\phi) \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ -s c_{F,\\mathrm{in}}/(\\tau \\phi^2) \\\\ 0 \\end{bmatrix} $$\n\n### Algorithm Implementation\n\nThe algorithm is implemented in Python using the `numpy` library for numerical linear algebra and `scipy.optimize.root` as the nonlinear solver.\n\n1.  **Initialization:** For each test case, we first find two initial points on the solution branch.\n    -   The first point, $\\mathbf{z}_0 = [\\mathbf{x}_0; p_0]^\\top$, is found by solving $\\mathbf{R}(\\mathbf{x}, p_0) = \\mathbf{0}$ with $p_0$ set to its starting value. A physically reasonable initial guess for $\\mathbf{x}$ is the inlet state: $[c_{F,\\mathrm{in}}, c_{O,\\mathrm{in}}(p_0), T_{\\mathrm{in}}]^\\top$.\n    -   The second point, $\\mathbf{z}_1 = [\\mathbf{x}_1; p_1]^\\top$, is found by a \"natural parameter\" step, solving $\\mathbf{R}(\\mathbf{x}, p_1) = \\mathbf{0}$ for $p_1 = p_0 + \\Delta p_{\\mathrm{nat}}$, using $\\mathbf{x}_0$ as the initial guess.\n\n2.  **Continuation Loop:** The main loop iterates for a specified maximum number of steps. In each step:\n    -   The secant tangent $\\mathbf{v}$ and the predictor point $\\mathbf{z}_p$ are calculated.\n    -   The `scipy.optimize.root` function is called to solve the augmented system $\\mathbf{G}(\\mathbf{z}) = \\mathbf{0}$, starting from $\\mathbf{z}_p$. We supply both the residual function and its analytical Jacobian to ensure robust and efficient convergence.\n    -   The converged point is accepted as $\\mathbf{z}_{k+1}$.\n\n3.  **Bifurcation Detection:**\n    -   At each converged point $\\mathbf{z}_{k+1}$, the Jacobian $J$ of the original system is computed.\n    -   Its singular values are calculated using `scipy.linalg.svdvals`. The smallest singular value, $\\sigma_{\\min}(J)$, is extracted.\n    -   A bifurcation event is counted if $\\sigma_{\\min}(J)$ drops below a given threshold $\\varepsilon_{\\sigma}$. To count a contiguous episode as a single event, a state flag (`in_bifurcation_zone`) is used. The counter is incremented only on the first entry into the sub-threshold region.\n\nThis procedure is applied to the three test cases specified in the problem statement.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root\nfrom scipy.linalg import svdvals\n\ndef solve():\n    \"\"\"\n    Main function to run the PSR continuation for all test cases and print results.\n    \"\"\"\n    # Common physical constants and parameters\n    R = 8.314  # J/(mol K)\n    C_F_IN = 0.01  # mol/m^3\n    T_IN = 500.0  # K\n    Q = 300.0  # K m^3/mol\n    S = 1.0  # stoichiometric coefficient (dimensionless)\n\n    # Test case definitions\n    test_cases = [\n        {\n            \"case_id\": 1,\n            \"k0\": 3.0e6, \"Ea\": 8.0e4, \"p_name\": \"tau\", \"fixed_param_val\": 0.8,\n            \"p_start\": 0.05, \"dp_nat\": 0.05, \"ds\": 0.05,\n            \"max_steps\": 120, \"eps_sigma\": 1e-6\n        },\n        {\n            \"case_id\": 2,\n            \"k0\": 3.0e6, \"Ea\": 1.0e4, \"p_name\": \"tau\", \"fixed_param_val\": 0.8,\n            \"p_start\": 0.05, \"dp_nat\": 0.05, \"ds\": 0.05,\n            \"max_steps\": 120, \"eps_sigma\": 1e-6\n        },\n        {\n            \"case_id\": 3,\n            \"k0\": 3.0e6, \"Ea\": 8.0e4, \"p_name\": \"phi\", \"fixed_param_val\": 2.5,\n            \"p_start\": 0.6, \"dp_nat\": 0.05, \"ds\": 0.05,\n            \"max_steps\": 120, \"eps_sigma\": 1e-6\n        },\n    ]\n\n    class PSRContinuationSolver:\n        \"\"\"\n        Encapsulates the PSR model and the continuation algorithm.\n        \"\"\"\n        def __init__(self, k0, Ea, p_name, fixed_param_val):\n            self.k0 = k0\n            self.Ea = Ea\n            self.p_name = p_name\n            if p_name == 'tau':\n                self.fixed_phi = fixed_param_val\n                self.fixed_tau = None\n            else: # p_name == 'phi'\n                self.fixed_tau = fixed_param_val\n                self.fixed_phi = None\n\n            # Corrector state variables, set during each step\n            self.z_k = None\n            self.v = None\n            self.ds = None\n\n        def _get_params(self, p):\n            if self.p_name == 'tau':\n                return p, self.fixed_phi\n            return self.fixed_tau, p\n\n        def c_o_in(self, phi):\n            return S * C_F_IN / phi\n\n        def reaction_rate(self, c_f, c_o, T):\n            if T <= 0 or c_f < 0 or c_o < 0:\n                return 0.0\n            return self.k0 * np.exp(-self.Ea / (R * T)) * c_f * c_o\n\n        def residuals(self, x, p):\n            c_f, c_o, T = x\n            tau, phi = self._get_params(p)\n            r_val = self.reaction_rate(c_f, c_o, T)\n            \n            res1 = (C_F_IN - c_f) / tau - r_val\n            res2 = (self.c_o_in(phi) - c_o) / tau - S * r_val\n            res3 = (T_IN - T) / tau + Q * r_val\n            return np.array([res1, res2, res3])\n\n        def jacobian(self, x, p):\n            c_f, c_o, T = x\n            tau, _ = self._get_params(p)\n            \n            if T <= 0 or c_f <= 0 or c_o <= 0:\n                # Return a non-singular matrix for stability if state is non-physical\n                return -np.identity(3) / tau\n\n            r_val = self.reaction_rate(c_f, c_o, T)\n            dr_dcf = r_val / c_f\n            dr_dco = r_val / c_o\n            dr_dT = r_val * self.Ea / (R * T**2)\n\n            J = np.zeros((3, 3))\n            J[0, 0] = -1.0/tau - dr_dcf\n            J[0, 1] = -dr_dco\n            J[0, 2] = -dr_dT\n            J[1, 0] = -S * dr_dcf\n            J[1, 1] = -1.0/tau - S * dr_dco\n            J[1, 2] = -S * dr_dT\n            J[2, 0] = Q * dr_dcf\n            J[2, 1] = Q * dr_dco\n            J[2, 2] = -1.0/tau + Q * dr_dT\n            return J\n\n        def R_p(self, x, p):\n            c_f, c_o, T = x\n            tau, phi = self._get_params(p)\n            \n            if self.p_name == 'tau':\n                dr_p1 = (c_f - C_F_IN) / tau**2\n                dr_p2 = (c_o - self.c_o_in(phi)) / tau**2\n                dr_p3 = (T - T_IN) / tau**2\n                return np.array([dr_p1, dr_p2, dr_p3])\n            else: # p_name == 'phi'\n                dr_p1 = 0.0\n                dr_p2 = (1.0 / tau) * (-S * C_F_IN / phi**2)\n                dr_p3 = 0.0\n                return np.array([dr_p1, dr_p2, dr_p3])\n\n        def _augmented_system(self, z):\n            x, p = z[:3], z[3]\n            x_k, p_k = self.z_k[:3], self.z_k[3]\n\n            G = np.zeros(4)\n            G[:3] = self.residuals(x, p)\n            G[3] = self.v.T @ (z - self.z_k) - self.ds\n            return G\n\n        def _augmented_jacobian(self, z):\n            x, p = z[:3], z[3]\n            J_aug = np.zeros((4, 4))\n            \n            J_aug[:3, :3] = self.jacobian(x, p)\n            J_aug[:3, 3] = self.R_p(x, p)\n            J_aug[3, :] = self.v\n            return J_aug\n\n        def run(self, p_start, dp_nat, ds, max_steps, eps_sigma):\n            # 1. Find the first point on the curve\n            p0 = p_start\n            _, phi_0 = self._get_params(p0)\n            x_guess_0 = np.array([C_F_IN * 0.99, self.c_o_in(phi_0) * 0.99, T_IN + 10])\n            sol_0 = root(self.residuals, x_guess_0, args=(p0,), jac=self.jacobian, method='hybr')\n            if not sol_0.success: return -1 # Error code\n            x0 = sol_0.x\n            z0 = np.append(x0, p0)\n\n            # 2. Find the second point by natural parameter stepping\n            p1 = p0 + dp_nat\n            sol_1 = root(self.residuals, x0, args=(p1,), jac=self.jacobian, method='hybr')\n            if not sol_1.success: return -1 # Error code\n            x1 = sol_1.x\n            z1 = np.append(x1, p1)\n            \n            z_current, z_prev = z1, z0\n            bifurcation_count = 0\n            in_bifurcation_zone = False\n\n            for _ in range(max_steps):\n                # 3. Predictor step\n                tangent = z_current - z_prev\n                v = tangent / np.linalg.norm(tangent)\n                z_pred = z_current + ds * v\n\n                # 4. Corrector step\n                self.z_k, self.v, self.ds = z_current, v, ds\n                corrector_sol = root(self._augmented_system, z_pred, jac=self._augmented_jacobian, method='hybr')\n                \n                if not corrector_sol.success:\n                    break # Stop continuation if corrector fails\n                \n                z_next = corrector_sol.x\n\n                # 5. Bifurcation detection\n                x_next, p_next = z_next[:3], z_next[3]\n                J_next = self.jacobian(x_next, p_next)\n                \n                try:\n                    singular_values = svdvals(J_next)\n                    sigma_min = np.min(singular_values)\n                except np.linalg.LinAlgError:\n                    sigma_min = 0.0\n\n                is_low = sigma_min < eps_sigma\n                if is_low and not in_bifurcation_zone:\n                    bifurcation_count += 1\n                    in_bifurcation_zone = True\n                elif not is_low:\n                    in_bifurcation_zone = False\n\n                # 6. Update for next step\n                z_prev, z_current = z_current, z_next\n                \n            return bifurcation_count\n\n    results = []\n    for case in test_cases:\n        solver = PSRContinuationSolver(\n            k0=case[\"k0\"],\n            Ea=case[\"Ea\"],\n            p_name=case[\"p_name\"],\n            fixed_param_val=case[\"fixed_param_val\"]\n        )\n        count = solver.run(\n            p_start=case[\"p_start\"],\n            dp_nat=case[\"dp_nat\"],\n            ds=case[\"ds\"],\n            max_steps=case[\"max_steps\"],\n            eps_sigma=case[\"eps_sigma\"]\n        )\n        results.append(count)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}