{
    "hands_on_practices": [
        {
            "introduction": "在构建完美搅拌反应器（PSR）模型时，首要任务是正确地定义进入反应器的物料流。虽然基本的PSR方程通常假设单个入口，但许多实际应用，如燃气轮机的燃烧室，涉及多个独立的入口流（例如，燃料和氧化剂分开注入）。本练习将指导您基于质量守恒的基本原则，推导出一个等效的单一入口组分，这是将复杂的多入口系统简化为标准PSR模型的关键一步。",
            "id": "4049169",
            "problem": "考虑一个完全混合反应器 (Perfectly Stirred Reactor, PSR)，其定义为一个内部物质在空间上理想且瞬时混合均匀的反应器，该反应器在稳态下运行，有一个出口和两个 ($2$) 独立的入口流。每个入口 $i \\in \\{1,2\\}$ 提供质量流率 $\\dot{m}_{i}$，并携带组分 $k$ 的均匀质量分数 $Y_{k,i}$。反应器是充分混合的，因此在模拟控制体内的任何反应过程之前，所有流入的物料都会混合在一起。假设将合并的入口替换为一个等效的单一入口流，其总质量流率为 $\\dot{m}_{\\text{in}}$，对于同一组分 $k$ 的有效入口质量分数为 $Y_{k,\\text{in}}$，该等效入口的定义是使其产生的组分 $k$ 的总流入量与原始两个入口相同。\n\n从控制体的组分守恒原理和组分质量分数（定义为组分质量流率与总质量流率之比）出发，推导有效入口组分 $Y_{k,\\text{in}}$ 关于 $\\dot{m}_{1}$、$\\dot{m}_{2}$、 $Y_{k,1}$ 和 $Y_{k,2}$ 的闭式解析表达式。说明您使用的任何假设，并确保您的推导与稳态运行和质量守恒一致。您的最终答案必须是单一的闭式解析表达式（无量纲）。无需进行数值计算。",
            "solution": "对于多入口完全混合反应器 (PSR) 的有效入口质量分数的推导，是基于总混合物和每个独立组分的质量守恒基本原理。问题陈述建立了一个明确的等效标准：由一个假想的单一入口所提供的给定组分 $k$ 的质量流率，必须等于来自实际多个入口的同一组分的质量流率之和。我们将通过形式化该标准来进行推导。\n\n我们首先定义总质量流率、组分质量流率和组分质量分数之间的关系。对于任何给定的流，组分 $k$ 的质量分数（记为 $Y_k$）是该组分的质量流率 $\\dot{m}_k$ 与该流的总质量流率 $\\dot{m}$ 之比。\n$$Y_k = \\frac{\\dot{m}_k}{\\dot{m}}$$\n根据此定义，组分 $k$ 的质量流率可以表示为：\n$$\\dot{m}_k = Y_k \\dot{m}$$\n这个关系是我们推导的基石。\n\n所描述的系统有两个独立的入口流，索引为 $i \\in \\{1, 2\\}$。\n对于第一个入口流 ($i=1$)，总质量流率为 $\\dot{m}_{1}$，组分 $k$ 的质量分数为 $Y_{k,1}$。因此，从该流进入反应器的组分 $k$ 的质量流率为：\n$$\\dot{m}_{k,1} = Y_{k,1} \\dot{m}_{1}$$\n对于第二个入口流 ($i=2$)，总质量流率为 $\\dot{m}_{2}$，组分 $k$ 的质量分数为 $Y_{k,2}$。来自该流的组分 $k$ 的质量流率为：\n$$\\dot{m}_{k,2} = Y_{k,2} \\dot{m}_{2}$$\n反应器在稳态下运行。稳态运行的一个必要条件是质量守恒。单位时间内进入反应器控制体的组分 $k$ 的总质量，即 $\\dot{m}_{k,\\text{total in}}$，是所有入口流的组分质量流率之和。\n$$\\dot{m}_{k,\\text{total in}} = \\sum_{i=1}^{2} \\dot{m}_{k,i} = \\dot{m}_{k,1} + \\dot{m}_{k,2}$$\n代入 $\\dot{m}_{k,1}$ 和 $\\dot{m}_{k,2}$ 的表达式，我们得到：\n$$\\dot{m}_{k,\\text{total in}} = Y_{k,1} \\dot{m}_{1} + Y_{k,2} \\dot{m}_{2}$$\n同样，进入反应器的总质量流率 $\\dot{m}_{\\text{in}}$ 是各个入口质量流率之和：\n$$\\dot{m}_{\\text{in}} = \\dot{m}_{1} + \\dot{m}_{2}$$\n问题假设存在一个等效的单一入口流来替代原来的两个入口流。这个等效流的总质量流率为 $\\dot{m}_{\\text{in}}$，组分 $k$ 的有效入口质量分数为 $Y_{k,\\text{in}}$。来自该等效入口的组分 $k$ 的质量流率 $\\dot{m}_{k,\\text{in}}$ 定义为：\n$$\\dot{m}_{k,\\text{in}} = Y_{k,\\text{in}} \\dot{m}_{\\text{in}}$$\n如问题所述，等效的核心条件是总的组分流入量保持不变。\n$$\\dot{m}_{k,\\text{in}} = \\dot{m}_{k,\\text{total in}}$$\n我们现在可以令这两个量的表达式相等：\n$$Y_{k,\\text{in}} \\dot{m}_{\\text{in}} = Y_{k,1} \\dot{m}_{1} + Y_{k,2} \\dot{m}_{2}$$\n为求解 $Y_{k,\\text{in}}$，我们将总入口质量流率的表达式 $\\dot{m}_{\\text{in}} = \\dot{m}_{1} + \\dot{m}_{2}$ 代入方程的左侧：\n$$Y_{k,\\text{in}} (\\dot{m}_{1} + \\dot{m}_{2}) = Y_{k,1} \\dot{m}_{1} + Y_{k,2} \\dot{m}_{2}$$\n最后，我们通过将方程两边同时除以总质量流率 $(\\dot{m}_{1} + \\dot{m}_{2})$ 来分离出 $Y_{k,\\text{in}}$。这是允许的，因为质量流率是非负的，对于有流入的物理系统，其和必须为正。\n$$Y_{k,\\text{in}} = \\frac{Y_{k,1} \\dot{m}_{1} + Y_{k,2} \\dot{m}_{2}}{\\dot{m}_{1} + \\dot{m}_{2}}$$\n该表达式代表了各个入口质量分数的质量加权平均值。\n\n支撑此推导的主要假设是：\n$1$. 系统处于稳态，意味着所有入口的流率和组分随时间保持不变。\n$2$. 质量守恒原理适用于总质量和每个独立组分的质量。\n$3$. 质量流率和质量分数的定义得到了一致的应用。\n\n最终得到的表达式是一个闭式的、无量纲的量，仅依赖于给定的入口属性，符合题目要求。它是在将多入口反应器系统建模为简化的单入口系统时所使用的有效入口组分的解析表达式。",
            "answer": "$$\\boxed{\\frac{\\dot{m}_{1} Y_{k,1} + \\dot{m}_{2} Y_{k,2}}{\\dot{m}_{1} + \\dot{m}_{2}}}$$"
        },
        {
            "introduction": "掌握了如何设定模型输入后，下一步是理解反应器内部状态变量之间的相互关系。在PSR模型中，热力学性质（如密度）、流动参数（如质量流率）和反应时间（停留时间）是紧密耦合的。本练习将通过一个具体的计算任务，向您展示如何利用理想气体定律和停留时间的定义，从已知的反应器状态（温度、压力和组分）出发，反推出关键的流动参数，并阐明它们如何耦合在物种守恒方程中。",
            "id": "4049170",
            "problem": "一个理想搅拌反应器（PSR）在稳态下运行，反应器内部各处性质均匀。出口（等于反应器状态）压力为 $p = 2.50$ $\\text{atm}$，温度为 $T = 1100$ $\\text{K}$，出口混合物组分由各物质的摩尔分数给出：$\\text{CO}_{2}$ 为 $X_{\\text{CO}_{2}} = 0.09$，$\\text{H}_{2}\\text{O}$ 为 $X_{\\text{H}_{2}\\text{O}} = 0.11$，$\\text{N}_{2}$ 为 $X_{\\text{N}_{2}} = 0.76$，$\\text{O}_{2}$ 为 $X_{\\text{O}_{2}} = 0.04$。反应器体积为 $V = 0.050$ $\\text{m}^{3}$，在反应器条件下的停留时间为 $\\tau = 0.20$ $\\text{s}$。假设为理想气体混合物且无累积，入口和出口质量流量相等。\n\n仅使用第一性原理和公认的定义，推导出用 $p$、$T$ 和混合物平均摩尔质量 $M_{\\text{mix}}$ 表示的出口密度 $\\rho$ 的表达式，并利用停留时间的定义求出质量流量 $\\dot{m}$。然后，阐明 $\\rho$ 和 $\\dot{m}$ 如何通过 $\\tau$ 耦合回稳态物质平衡方程。\n\n使用以下分子量进行数值计算质量流量 $\\dot{m}$：$M_{\\text{CO}_{2}} = 44.01$ $\\text{g/mol}$，$M_{\\text{H}_{2}\\text{O}} = 18.01528$ $\\text{g/mol}$，$M_{\\text{N}_{2}} = 28.0134$ $\\text{g/mol}$，$M_{\\text{O}_{2}} = 31.998$ $\\text{g/mol}$，以及通用气体常数 (UGC) $R_{u} = 8.314462618$ $\\text{J/mol/K}$。将压力转换为帕斯卡。以 $\\text{kg/s}$ 为单位表示最终的质量流量，并将答案四舍五入到四位有效数字。",
            "solution": "该问题要求推导出口密度 $\\rho$ 的表达式，利用该表达式确定质量流量 $\\dot{m}$，并解释这些量与理想搅拌反应器（PSR）中物质守恒方程之间的耦合关系。最后，需要计算 $\\dot{m}$ 的数值。\n\n首先，我们推导混合物密度 $\\rho$ 的表达式。我们从混合物的理想气体定律开始：\n$$p V = n R_{u} T$$\n其中 $p$ 是压力，$V$ 是体积，$n$ 是体积内气体的总摩尔数，$R_{u}$ 是通用气体常数，$T$ 是温度。\n\n体积 $V$ 中的总质量 $m$ 通过混合物平均摩尔质量 $M_{\\text{mix}}$ 与总摩尔数 $n$ 相关联：\n$$m = n M_{\\text{mix}}$$\n解出 $n$ 得到 $n = \\frac{m}{M_{\\text{mix}}}$。将其代入理想气体定律：\n$$p V = \\left(\\frac{m}{M_{\\text{mix}}}\\right) R_{u} T$$\n密度 $\\rho$ 定义为单位体积的质量，即 $\\rho = \\frac{m}{V}$。我们可以重新排列上述方程以分离出这一项：\n$$p = \\left(\\frac{m}{V}\\right) \\frac{R_{u} T}{M_{\\text{mix}}} = \\rho \\frac{R_{u} T}{M_{\\text{mix}}}$$\n解出密度 $\\rho$ 得到所需的表达式：\n$$\\rho = \\frac{p M_{\\text{mix}}}{R_{u} T}$$\n该表达式将理想气体混合物的密度与其压力、温度和平均摩尔质量联系起来。\n\n接下来，我们使用这个表达式来求质量流量 $\\dot{m}$。在理想搅拌反应器中，停留时间 $\\tau$ 定义为流体单元在反应器中停留的平均时间。对于稳流系统，它是反应器内流体质量 $m$ 与通过反应器的质量流量 $\\dot{m}$ 之比：\n$$\\tau = \\frac{m}{\\dot{m}}$$\n反应器体积 $V$ 中的质量 $m$ 由 $m = \\rho V$ 给出。将其代入停留时间的定义：\n$$\\tau = \\frac{\\rho V}{\\dot{m}}$$\n解出质量流量 $\\dot{m}$：\n$$\\dot{m} = \\frac{\\rho V}{\\tau}$$\n现在，我们代入之前推导出的 $\\rho$ 的表达式：\n$$\\dot{m} = \\left(\\frac{p M_{\\text{mix}}}{R_{u} T}\\right) \\frac{V}{\\tau} = \\frac{p V M_{\\text{mix}}}{R_{u} T \\tau}$$\n\n问题还问到 $\\rho$ 和 $\\dot{m}$ 如何耦合回稳态物质平衡方程。在理想搅拌反应器中，物种 $k$ 的稳态质量平衡方程为：\n$$(\\text{质量流入速率}) - (\\text{质量流出速率}) + (\\text{化学生成速率}) = 0$$\n$$\\dot{m} Y_{k,in} - \\dot{m} Y_{k} + V \\dot{\\omega}_{k} = 0$$\n其中，$Y_{k,in}$ 和 $Y_{k}$ 分别是物种 $k$ 的入口和出口（反应器）质量分数，$\\dot{\\omega}_{k}$ 是物种 $k$ 的单位体积质量生成速率，与文章主体部分的定义一致。重新整理以求解组分的变化：\n$$\\dot{m} (Y_{k} - Y_{k,in}) = V \\dot{\\omega}_{k}$$\n$$Y_{k} - Y_{k,in} = \\frac{V}{\\dot{m}} \\dot{\\omega}_{k}$$\n根据停留时间的定义 $\\tau = \\frac{\\rho V}{\\dot{m}}$，我们可以将比率 $\\frac{V}{\\dot{m}}$ 写成 $\\frac{\\tau}{\\rho}$。将其代入重新整理后的物质平衡方程，得到：\n$$Y_{k} - Y_{k,in} = \\frac{\\tau}{\\rho} \\dot{\\omega}_{k}$$\n这个最终方程明确地显示了耦合关系。反应器中物质质量分数的变化与停留时间 $\\tau$ 和化学源项 $\\dot{\\omega}_{k}$ 成正比，与密度 $\\rho$ 成反比。由于 $\\dot{m}$ 通过 $\\dot{m} = \\rho V / \\tau$ 与 $\\rho$ 和 $\\tau$ 相关，这三个量在反应器的控制方程中是内在关联的。\n\n最后，我们进行质量流量 $\\dot{m}$ 的数值计算。\n给定数据如下：\n$p = 2.50$ $\\text{atm}$\n$T = 1100$ $\\text{K}$\n$V = 0.050$ $\\text{m}^{3}$\n$\\tau = 0.20$ $\\text{s}$\n$X_{\\text{CO}_{2}} = 0.09$\n$X_{\\text{H}_{2}\\text{O}} = 0.11$\n$X_{\\text{N}_{2}} = 0.76$\n$X_{\\text{O}_{2}} = 0.04$\n摩尔质量 ($M_k$): $M_{\\text{CO}_{2}} = 44.01$ $\\text{g/mol}$, $M_{\\text{H}_{2}\\text{O}} = 18.01528$ $\\text{g/mol}$, $M_{\\text{N}_{2}} = 28.0134$ $\\text{g/mol}$, $M_{\\text{O}_{2}} = 31.998$ $\\text{g/mol}$。\n通用气体常数: $R_{u} = 8.314462618$ $\\text{J/(mol}\\cdot\\text{K)}$.\n\n首先，我们计算混合物平均摩尔质量 $M_{\\text{mix}}$，它是各组分物质的摩尔分数加权摩尔质量之和：\n$$M_{\\text{mix}} = \\sum_{k} X_{k} M_{k}$$\n$$M_{\\text{mix}} = X_{\\text{CO}_{2}}M_{\\text{CO}_{2}} + X_{\\text{H}_{2}\\text{O}}M_{\\text{H}_{2}\\text{O}} + X_{\\text{N}_{2}}M_{\\text{N}_{2}} + X_{\\text{O}_{2}}M_{\\text{O}_{2}}$$\n$$M_{\\text{mix}} = (0.09)(44.01) + (0.11)(18.01528) + (0.76)(28.0134) + (0.04)(31.998) \\text{ g/mol}$$\n$$M_{\\text{mix}} = 3.9609 + 1.9816808 + 21.290184 + 1.27992 \\text{ g/mol}$$\n$$M_{\\text{mix}} = 28.5126848 \\text{ g/mol}$$\n为了在国际单位制（SI）中使用，我们将其转换为千克每摩尔：\n$$M_{\\text{mix}} = 0.0285126848 \\text{ kg/mol}$$\n\n接下来，我们使用标准转换 $1$ $\\text{atm}$ $= 101325$ $\\text{Pa}$ 将压力从大气压转换为帕斯卡：\n$$p = 2.50 \\text{ atm} \\times \\frac{101325 \\text{ Pa}}{1 \\text{ atm}} = 253312.5 \\text{ Pa}$$\n\n现在我们可以将所有值代入 $\\dot{m}$ 的表达式中：\n$$\\dot{m} = \\frac{p V M_{\\text{mix}}}{R_{u} T \\tau}$$\n$$\\dot{m} = \\frac{(253312.5 \\text{ Pa})(0.050 \\text{ m}^{3})(0.0285126848 \\text{ kg/mol})}{(8.314462618 \\text{ J/(mol}\\cdot\\text{K)})(1100 \\text{ K})(0.20 \\text{ s})}$$\n$$\\dot{m} = \\frac{361.161048}{1829.18177596} \\text{ kg/s}$$\n$$\\dot{m} \\approx 0.19744005 \\text{ kg/s}$$\n按要求四舍五入到四位有效数字，质量流量为：\n$$\\dot{m} = 0.1974 \\text{ kg/s}$$",
            "answer": "$$\\boxed{0.1974}$$"
        },
        {
            "introduction": "完美搅拌反应器模型的核心魅力和挑战在于其固有的非线性行为，这常常导致多重稳态和滞后现象，例如点火和熄火。这些现象对燃烧稳定性至关重要，但简单的求解器难以捕捉。本练习是一个综合性的高级实践，旨在引导您实现一个连续算法，这是一种强大的数值技术，用于追踪整个解的分支，并精确识别标志着稳定性改变的折叠分岔点（fold bifurcations），从而深入探索PSR模型的丰富动态特性。",
            "id": "4049184",
            "problem": "您的任务是为计算燃烧学中的理想搅拌反应器 (PSR) 的稳态建模实现一个稳健的连续算法。PSR 被建模为一个处于稳态的零维反应器，其中燃料和氧化剂之间发生单一不可逆放热反应：反应速率由阿伦尼乌斯定律和质量作用动力学控制。您必须从基本平衡方程推导出稳态的控制代数方程组，设计一个在停留时间 $\\,\\tau\\,$ 或当量比 $\\,\\phi\\,$ 上的预测-校正连续算法，并通过监测残差关于状态变量的雅可比矩阵 $\\,J\\,$ 的行列式或最小奇异值来检测折叠分岔。您的最终程序必须计算三个指定测试案例中检测到的分岔事件的整数计数，并以单行列表格式输出。\n\n从以下基本定律和核心定义开始：\n- 理想搅拌反应器中每个物种 $\\,i\\,$ 的稳态物种摩尔平衡：\n$$\\frac{c_{i,\\mathrm{in}} - c_i}{\\tau} + \\omega_i = 0,$$\n其中 $\\,c_{i,\\mathrm{in}}\\,$ 是物种 $\\,i\\,$ 的入口摩尔浓度，$\\,c_i\\,$ 是出口（也是反应器内）摩尔浓度，$\\,\\tau\\,$ 是停留时间，$\\,\\omega_i\\,$ 是由于化学反应引起的物种 $\\,i\\,$ 的体积摩尔生成速率。\n- 绝热反应器的稳态能量平衡：\n$$\\frac{T_{\\mathrm{in}} - T}{\\tau} + q\\, r = 0,$$\n其中 $\\,T_{\\mathrm{in}}\\,$ 是入口温度，$\\,T\\,$ 是反应器温度，$\\,q = \\frac{-\\Delta H}{\\rho C_p}\\,$ 是一个正的放热参数（其中 $\\,\\Delta H\\,$ 是放热反应焓，$\\,\\rho\\,$ 是混合物密度，$\\,C_p\\,$ 是混合物定压比热），$\\,r\\,$ 是体积反应速率。\n- 使用阿伦尼乌斯和质量作用动力学的单步燃料-氧化剂反应的反应速率：\n$$r = k_0 \\exp\\!\\left(-\\frac{E_a}{R\\, T}\\right) c_F^n c_O^m,$$\n其中 $\\,k_0\\,$ 是指前因子，$\\,E_a\\,$ 是活化能，$\\,R\\,$ 是通用气体常数，$\\,c_F\\,$ 和 $\\,c_O\\,$ 是燃料和氧化剂的摩尔浓度，$\\,n, m\\,$ 是反应级数（假设 $\\,n=m=1\\,$）。\n- 化学计量为 $\\,\\nu_F = 1\\,$ 和 $\\,\\nu_O = s\\,$，因此燃料和氧化剂的消耗速率为 $\\,\\omega_F = - r\\,$ 和 $\\,\\omega_O = - s\\, r\\,$.\n\n令状态向量为 $\\,\\mathbf{x} = [c_F, c_O, T]^\\top\\,$。使用平衡方程，残差方程为\n$$\n\\begin{aligned}\nR_1(\\mathbf{x}, \\tau, \\phi) = \\frac{c_{F,\\mathrm{in}} - c_F}{\\tau} - r = 0, \\\\\nR_2(\\mathbf{x}, \\tau, \\phi) = \\frac{c_{O,\\mathrm{in}}(\\phi) - c_O}{\\tau} - s\\, r = 0, \\\\\nR_3(\\mathbf{x}, \\tau, \\phi) = \\frac{T_{\\mathrm{in}} - T}{\\tau} + q\\, r = 0,\n\\end{aligned}\n$$\n其中 $\\,c_{O,\\mathrm{in}}(\\phi) = \\frac{s\\, c_{F,\\mathrm{in}}}{\\phi}\\,$，且 $\\,r = k_0 \\exp\\!\\left(-\\frac{E_a}{R\\, T}\\right) c_F c_O\\,$. 所有量的单位如下：$\\,c_F, c_O\\,$ 的单位为 $\\mathrm{mol}/\\mathrm{m}^3$，$\\,\\tau\\,$ 的单位为 $\\mathrm{s}$，$\\,T, T_{\\mathrm{in}}\\,$ 的单位为 $\\mathrm{K}$，$\\,k_0\\,$ 的单位为 $\\mathrm{s}^{-1}\\, (\\mathrm{mol}/\\mathrm{m}^3)^{-(n+m-1)}$，$\\,E_a\\,$ 的单位为 $\\mathrm{J}/\\mathrm{mol}$，$\\,R\\,$ 的单位为 $\\mathrm{J}/(\\mathrm{mol}\\,\\mathrm{K})$，$\\,q\\,$ 的单位为 $\\mathrm{K}\\, \\mathrm{m}^3/\\mathrm{mol}$。化学计量系数 $\\,s\\,$ 是无量纲的。\n\n将雅可比矩阵 $\\,J(\\mathbf{x}; \\tau, \\phi)\\,$ 定义为 $[R_1,R_2,R_3]^\\top$ 关于 $\\,\\mathbf{x}\\,$ 的偏导数矩阵。当 $\\,\\det(J)\\,$ 趋近于 $\\,0\\,$ 时，会发生折叠分岔和稳态分支的正则性丧失，这等价于最小奇异值 $\\,\\sigma_{\\min}(J)\\,$ 趋近于 $\\,0\\,$. 您的算法必须沿着分支监测 $\\,\\sigma_{\\min}(J)\\,$，并在 $\\,\\sigma_{\\min}(J)\\,$ 低于给定阈值时检测分岔。\n\n您必须：\n- 在标量参数 $\\,p \\in \\{\\tau,\\phi\\}\\,$ 上实现一个预测-校正伪弧长连续算法。使用基于割线的切向预测器和对包含残差和弧长约束的增广系统使用类牛顿校正器。具体来说，在每一步强制执行 $\\,\\mathbf{v}^\\top ([\\mathbf{x}; p] - [\\mathbf{x}^{(k)}; p^{(k)}]) - \\Delta s = 0\\,$，其中 $\\,\\mathbf{v}\\,$ 是归一化为单位长度的基于割线的切线，$\\,\\Delta s\\,$ 是弧长步长。\n- 使用通用求根器求解非线性系统以获得稳态解；通过从基于入口状态的初始猜测开始并使用连续法追踪分支来确保解具有物理意义。\n- 在每个收敛步计算 $\\,\\sigma_{\\min}(J)\\,$，并在 $\\,\\sigma_{\\min}(J)\\,$ 低于指定阈值时检测到一个事件。将每个 $\\,\\sigma_{\\min}(J)\\,$ 值较低的连续区间计为一个分岔事件。\n\n物理单位：\n- 输入和内部计算对浓度使用 $\\,\\mathrm{mol}/\\mathrm{m}^3\\,$，对时间使用 $\\,\\mathrm{s}\\,$，对温度使用 $\\,\\mathrm{K}\\,$。\n- 最终输出是检测到的分岔事件的无单位计数。\n\n测试套件：\n为以下参数集实现并运行您的算法。在所有集合中，使用 $\\,n=m=s=1\\,$，$\\,R = 8.314\\,\\mathrm{J}/(\\mathrm{mol}\\,\\mathrm{K})\\,$，$\\,c_{F,\\mathrm{in}} = 0.01\\,\\mathrm{mol}/\\mathrm{m}^3\\,$，$\\,T_{\\mathrm{in}} = 500\\,\\mathrm{K}\\,$，和 $\\,q = 300\\,\\mathrm{K}\\,\\mathrm{m}^3/\\mathrm{mol}\\,$.\n1. 在 $\\,\\tau\\,$ 上的正常路径连续：\n   - 参数：$\\,k_0 = 3\\times 10^6\\,\\mathrm{s}^{-1}\\,$，$\\,E_a = 8.0\\times 10^4\\,\\mathrm{J}/\\mathrm{mol}\\,$，固定 $\\,\\phi = 0.8\\,$.\n   - 连续设置：从 $\\,\\tau_0 = 0.05\\,\\mathrm{s}\\,$ 开始，初始自然步长 $\\,\\Delta p_{\\mathrm{nat}} = 0.05\\,\\mathrm{s}\\,$ 以获得割线，弧长步长 $\\,\\Delta s = 0.05\\,$，最多 $\\,120\\,$ 个校正步，奇异值阈值 $\\,\\varepsilon_{\\sigma} = 10^{-6}\\,$.\n   - 输出：检测到的分岔的整数计数。\n2. 在 $\\,\\tau\\,$ 上的低活化能边缘情况：\n   - 参数：与案例 $\\,1\\,$ 相同，除了 $\\,E_a = 1.0\\times 10^4\\,\\mathrm{J}/\\mathrm{mol}\\,$.\n   - 连续设置：与案例 $\\,1\\,$ 相同。\n   - 输出：检测到的分岔的整数计数。\n3. 在 $\\,\\phi\\,$ 上的当量比连续：\n   - 参数：与案例 $\\,1\\,$ 相同，固定 $\\,\\tau = 2.5\\,\\mathrm{s}\\,$.\n   - 连续设置：从 $\\,\\phi_0 = 0.6\\,$ 开始，初始自然步长 $\\,\\Delta p_{\\mathrm{nat}} = 0.05\\,$ 以获得割线，弧长步长 $\\,\\Delta s = 0.05\\,$，最多 $\\,120\\,$ 个校正步，奇异值阈值 $\\,\\varepsilon_{\\sigma} = 10^{-6}\\,$.\n   - 输出：检测到的分岔的整数计数。\n\n您的程序应生成一行输出，其中包含三个测试案例的计数，格式为方括号括起来的逗号分隔列表（例如，$[N_1,N_2,N_3]$）。结果必须是整数。",
            "solution": "解决方案主要分为两个阶段：首先，详细阐述控制方程、雅可比矩阵和用于连续的增广系统的数学公式；其次，设计并实现数值算法。\n\n### 数学公式化\n\nPSR 的状态由物种浓度和温度的向量描述，$\\mathbf{x} = [c_F, c_O, T]^\\top$，其中 $c_F$ 是燃料浓度，$c_O$ 是氧化剂浓度，$T$ 是温度。控制方程构成一个非线性代数方程组，$\\mathbf{R}(\\mathbf{x}, p) = \\mathbf{0}$，其中 $p$ 是一个标量连续参数，即停留时间 $\\tau$ 或当量比 $\\phi$。\n\n**1. 残差方程：**\n由稳态质量和能量平衡导出的残差方程组如下：\n$$\n\\begin{aligned}\nR_1(\\mathbf{x}, p) = \\frac{c_{F,\\mathrm{in}} - c_F}{\\tau} - r(\\mathbf{x}) = 0 \\\\\nR_2(\\mathbf{x}, p) = \\frac{c_{O,\\mathrm{in}}(\\phi) - c_O}{\\tau} - s\\, r(\\mathbf{x}) = 0 \\\\\nR_3(\\mathbf{x}, p) = \\frac{T_{\\mathrm{in}} - T}{\\tau} + q\\, r(\\mathbf{x}) = 0\n\\end{aligned}\n$$\n其中反应速率 $r(\\mathbf{x})$ 由阿伦尼乌斯定律和反应级数 $n=m=1$ 的质量作用动力学给出：\n$$ r(\\mathbf{x}) = k_0 \\exp\\left(-\\frac{E_a}{R T}\\right) c_F c_O $$\n入口氧化剂浓度取决于当量比 $\\phi$：\n$$ c_{O,\\mathrm{in}}(\\phi) = \\frac{s\\, c_{F,\\mathrm{in}}}{\\phi} $$\n\n**2. 雅可比矩阵：**\n当系统的雅可比矩阵 $J = \\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{x}}$ 变为奇异时，发生折叠分岔。这可以通过监测其最小奇异值 $\\sigma_{\\min}(J)$ 来检测。解析雅可比矩阵对于基于牛顿法的校正步骤至关重要。其元素 $J_{ij} = \\frac{\\partial R_i}{\\partial x_j}$ 推导如下。\n\n首先，我们求出反应速率 $r$ 对状态变量的偏导数：\n$$ \\frac{\\partial r}{\\partial c_F} = \\frac{r}{c_F}, \\quad \\frac{\\partial r}{\\partial c_O} = \\frac{r}{c_O}, \\quad \\frac{\\partial r}{\\partial T} = r \\frac{E_a}{R T^2} $$\n利用这些，雅可比矩阵 $J$ 的元素为：\n$$\nJ = \\begin{bmatrix}\n-\\frac{1}{\\tau} - \\frac{\\partial r}{\\partial c_F} & -\\frac{\\partial r}{\\partial c_O} & -\\frac{\\partial r}{\\partial T} \\\\\n-s \\frac{\\partial r}{\\partial c_F} & -\\frac{1}{\\tau} - s \\frac{\\partial r}{\\partial c_O} & -s \\frac{\\partial r}{\\partial T} \\\\\nq \\frac{\\partial r}{\\partial c_F} & q \\frac{\\partial r}{\\partial c_O} & -\\frac{1}{\\tau} + q \\frac{\\partial r}{\\partial T}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-\\frac{1}{\\tau} - \\frac{r}{c_F} & -\\frac{r}{c_O} & -r \\frac{E_a}{R T^2} \\\\\n-s \\frac{r}{c_F} & -\\frac{1}{\\tau} - s \\frac{r}{c_O} & -s r \\frac{E_a}{R T^2} \\\\\nq \\frac{r}{c_F} & q \\frac{r}{c_O} & -\\frac{1}{\\tau} + q r \\frac{E_a}{R T^2}\n\\end{bmatrix}\n$$\n\n**3. 伪弧长连续：**\n为了追踪通过折叠分岔的解曲线，我们将状态向量与连续参数增广，$\\mathbf{z} = [\\mathbf{x}; p]^\\top$，并增加一个约束方程。这导致一个包含 $N+1$ 个方程和 $N+1$ 个未知数的增广系统。\n\n预测-校正算法在每一步 $k$ 中按以下方式进行：\n- **预测器：** 给定收敛点 $\\mathbf{z}_{k-1}$ 和 $\\mathbf{z}_k$，计算一个基于割线的切向量 $\\mathbf{v}$：\n$$ \\mathbf{v} = \\frac{\\mathbf{z}_k - \\mathbf{z}_{k-1}}{\\|\\mathbf{z}_k - \\mathbf{z}_{k-1}\\|_2} $$\n通过从当前点 $\\mathbf{z}_k$ 沿着切线方向前进一个弧长步长 $\\Delta s$ 来找到预测点 $\\mathbf{z}_p$：\n$$ \\mathbf{z}_p = \\mathbf{z}_k + \\Delta s \\, \\mathbf{v} $$\n- **校正器：** 从 $\\mathbf{z}_p$ 开始，我们使用类牛顿法求解增广系统 $\\mathbf{G}(\\mathbf{z}) = \\mathbf{0}$，以找到曲线上的下一个点 $\\mathbf{z}_{k+1}$：\n$$\n\\mathbf{G}(\\mathbf{z}) = \\begin{bmatrix} \\mathbf{R}(\\mathbf{x}, p) \\\\ N(\\mathbf{z}) \\end{bmatrix} = \\begin{bmatrix} \\mathbf{R}(\\mathbf{x}, p) \\\\ \\mathbf{v}^\\top(\\mathbf{z} - \\mathbf{z}_k) - \\Delta s \\end{bmatrix} = \\mathbf{0}\n$$\n牛顿法需要该增广系统的雅可比矩阵 $\\mathcal{J} = \\frac{\\partial \\mathbf{G}}{\\partial \\mathbf{z}}$：\n$$\n\\mathcal{J} = \\begin{bmatrix}\n\\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{x}} & \\frac{\\partial \\mathbf{R}}{\\partial p} \\\\\n\\frac{\\partial N}{\\partial \\mathbf{x}} & \\frac{\\partial N}{\\partial p}\n\\end{bmatrix} = \\begin{bmatrix}\nJ & \\mathbf{R}_p \\\\\n\\mathbf{v}_x^\\top & v_p\n\\end{bmatrix}\n$$\n其中 $\\mathbf{v} = [\\mathbf{v}_x; v_p]^\\top$ 且 $\\mathbf{R}_p = \\frac{\\partial \\mathbf{R}}{\\partial p}$。导数 $\\mathbf{R}_p$ 取决于变化的参数：\n- 如果 $p = \\tau$：\n$$ \\mathbf{R}_\\tau = \\frac{\\partial \\mathbf{R}}{\\partial \\tau} = \\begin{bmatrix} (c_F - c_{F,\\mathrm{in}})/\\tau^2 \\\\ (c_O - c_{O,\\mathrm{in}}(\\phi))/\\tau^2 \\\\ (T - T_{\\mathrm{in}})/\\tau^2 \\end{bmatrix} $$\n- 如果 $p = \\phi$：\n$$ \\mathbf{R}_\\phi = \\frac{\\partial \\mathbf{R}}{\\partial \\phi} = \\begin{bmatrix} 0 \\\\ (1/\\tau) (\\partial c_{O,\\mathrm{in}}/\\partial \\phi) \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ -s c_{F,\\mathrm{in}}/(\\tau \\phi^2) \\\\ 0 \\end{bmatrix} $$\n\n### 算法实现\n\n该算法使用 Python 实现，借助 `numpy` 库进行数值线性代数计算，并使用 `scipy.optimize.root` 作为非线性求解器。\n\n1.  **初始化：** 对于每个测试用例，我们首先在解分支上找到两个初始点。\n    -   第一个点 $\\mathbf{z}_0 = [\\mathbf{x}_0; p_0]^\\top$ 是通过求解 $\\mathbf{R}(\\mathbf{x}, p_0) = \\mathbf{0}$ 得到的，其中 $p_0$ 设置为其起始值。一个物理上合理的 $\\mathbf{x}$ 初始猜测是入口状态：$[c_{F,\\mathrm{in}}, c_{O,\\mathrm{in}}(p_0), T_{\\mathrm{in}}]^\\top$。\n    -   第二个点 $\\mathbf{z}_1 = [\\mathbf{x}_1; p_1]^\\top$ 是通过一个“自然参数”步长得到的，即求解 $\\mathbf{R}(\\mathbf{x}, p_1) = \\mathbf{0}$，其中 $p_1 = p_0 + \\Delta p_{\\mathrm{nat}}$，并使用 $\\mathbf{x}_0$ 作为初始猜测。\n\n2.  **连续循环：** 主循环迭代指定的最大步数。在每一步中：\n    -   计算割线切向量 $\\mathbf{v}$ 和预测点 $\\mathbf{z}_p$。\n    -   调用 `scipy.optimize.root` 函数来求解增广系统 $\\mathbf{G}(\\mathbf{z}) = \\mathbf{0}$，从 $\\mathbf{z}_p$ 开始。我们同时提供残差函数及其解析雅可比矩阵，以确保稳健高效的收敛。\n    -   接受收敛点作为 $\\mathbf{z}_{k+1}$。\n\n3.  **分岔检测：**\n    -   在每个收敛点 $\\mathbf{z}_{k+1}$，计算原始系统的雅可比矩阵 $J$。\n    -   使用 `scipy.linalg.svdvals` 计算其奇异值。提取最小奇异值 $\\sigma_{\\min}(J)$。\n    -   如果 $\\sigma_{\\min}(J)$ 低于给定阈值 $\\varepsilon_{\\sigma}$，则计为一个分岔事件。为了将连续的区间计为单个事件，使用一个状态标志（`in_bifurcation_zone`）。计数器仅在首次进入低于阈值的区域时增加。\n\n此过程应用于问题陈述中指定的三个测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root\nfrom scipy.linalg import svdvals\n\ndef solve():\n    \"\"\"\n    Main function to run the PSR continuation for all test cases and print results.\n    \"\"\"\n    # Common physical constants and parameters\n    R = 8.314  # J/(mol K)\n    C_F_IN = 0.01  # mol/m^3\n    T_IN = 500.0  # K\n    Q = 300.0  # K m^3/mol\n    S = 1.0  # stoichiometric coefficient (dimensionless)\n\n    # Test case definitions\n    test_cases = [\n        {\n            \"case_id\": 1,\n            \"k0\": 3.0e6, \"Ea\": 8.0e4, \"p_name\": \"tau\", \"fixed_param_val\": 0.8,\n            \"p_start\": 0.05, \"dp_nat\": 0.05, \"ds\": 0.05,\n            \"max_steps\": 120, \"eps_sigma\": 1e-6\n        },\n        {\n            \"case_id\": 2,\n            \"k0\": 3.0e6, \"Ea\": 1.0e4, \"p_name\": \"tau\", \"fixed_param_val\": 0.8,\n            \"p_start\": 0.05, \"dp_nat\": 0.05, \"ds\": 0.05,\n            \"max_steps\": 120, \"eps_sigma\": 1e-6\n        },\n        {\n            \"case_id\": 3,\n            \"k0\": 3.0e6, \"Ea\": 8.0e4, \"p_name\": \"phi\", \"fixed_param_val\": 2.5,\n            \"p_start\": 0.6, \"dp_nat\": 0.05, \"ds\": 0.05,\n            \"max_steps\": 120, \"eps_sigma\": 1e-6\n        },\n    ]\n\n    class PSRContinuationSolver:\n        \"\"\"\n        Encapsulates the PSR model and the continuation algorithm.\n        \"\"\"\n        def __init__(self, k0, Ea, p_name, fixed_param_val):\n            self.k0 = k0\n            self.Ea = Ea\n            self.p_name = p_name\n            if p_name == 'tau':\n                self.fixed_phi = fixed_param_val\n                self.fixed_tau = None\n            else: # p_name == 'phi'\n                self.fixed_tau = fixed_param_val\n                self.fixed_phi = None\n\n            # Corrector state variables, set during each step\n            self.z_k = None\n            self.v = None\n            self.ds = None\n\n        def _get_params(self, p):\n            if self.p_name == 'tau':\n                return p, self.fixed_phi\n            return self.fixed_tau, p\n\n        def c_o_in(self, phi):\n            return S * C_F_IN / phi\n\n        def reaction_rate(self, c_f, c_o, T):\n            if T = 0 or c_f = 0 or c_o = 0:\n                return 0.0\n            return self.k0 * np.exp(-self.Ea / (R * T)) * c_f * c_o\n\n        def residuals(self, x, p):\n            c_f, c_o, T = x\n            tau, phi = self._get_params(p)\n            r_val = self.reaction_rate(c_f, c_o, T)\n            \n            res1 = (C_F_IN - c_f) / tau - r_val\n            res2 = (self.c_o_in(phi) - c_o) / tau - S * r_val\n            res3 = (T_IN - T) / tau + Q * r_val\n            return np.array([res1, res2, res3])\n\n        def jacobian(self, x, p):\n            c_f, c_o, T = x\n            tau, _ = self._get_params(p)\n            \n            if T = 0 or c_f = 0 or c_o = 0:\n                # Return a non-singular matrix for stability if state is non-physical\n                return -np.identity(3) / tau\n\n            r_val = self.reaction_rate(c_f, c_o, T)\n            dr_dcf = r_val / c_f\n            dr_dco = r_val / c_o\n            dr_dT = r_val * self.Ea / (R * T**2)\n\n            J = np.zeros((3, 3))\n            J[0, 0] = -1.0/tau - dr_dcf\n            J[0, 1] = -dr_dco\n            J[0, 2] = -dr_dT\n            J[1, 0] = -S * dr_dcf\n            J[1, 1] = -1.0/tau - S * dr_dco\n            J[1, 2] = -S * dr_dT\n            J[2, 0] = Q * dr_dcf\n            J[2, 1] = Q * dr_dco\n            J[2, 2] = -1.0/tau + Q * dr_dT\n            return J\n\n        def R_p(self, x, p):\n            c_f, c_o, T = x\n            tau, phi = self._get_params(p)\n            \n            if self.p_name == 'tau':\n                dr_p1 = (c_f - C_F_IN) / tau**2\n                dr_p2 = (c_o - self.c_o_in(phi)) / tau**2\n                dr_p3 = (T - T_IN) / tau**2\n                return np.array([dr_p1, dr_p2, dr_p3])\n            else: # p_name == 'phi'\n                dr_p1 = 0.0\n                dr_p2 = (1.0 / tau) * (-S * C_F_IN / phi**2)\n                dr_p3 = 0.0\n                return np.array([dr_p1, dr_p2, dr_p3])\n\n        def _augmented_system(self, z):\n            x, p = z[:3], z[3]\n            x_k, p_k = self.z_k[:3], self.z_k[3]\n\n            G = np.zeros(4)\n            G[:3] = self.residuals(x, p)\n            G[3] = self.v.T @ (z - self.z_k) - self.ds\n            return G\n\n        def _augmented_jacobian(self, z):\n            x, p = z[:3], z[3]\n            J_aug = np.zeros((4, 4))\n            \n            J_aug[:3, :3] = self.jacobian(x, p)\n            J_aug[:3, 3] = self.R_p(x, p)\n            J_aug[3, :] = self.v\n            return J_aug\n\n        def run(self, p_start, dp_nat, ds, max_steps, eps_sigma):\n            # 1. Find the first point on the curve\n            p0 = p_start\n            _, phi_0 = self._get_params(p0)\n            x_guess_0 = np.array([C_F_IN * 0.99, self.c_o_in(phi_0) * 0.99, T_IN + 10])\n            sol_0 = root(self.residuals, x_guess_0, args=(p0,), jac=self.jacobian, method='hybr')\n            if not sol_0.success: return -1 # Error code\n            x0 = sol_0.x\n            z0 = np.append(x0, p0)\n\n            # 2. Find the second point by natural parameter stepping\n            p1 = p0 + dp_nat\n            sol_1 = root(self.residuals, x0, args=(p1,), jac=self.jacobian, method='hybr')\n            if not sol_1.success: return -1 # Error code\n            x1 = sol_1.x\n            z1 = np.append(x1, p1)\n            \n            z_current, z_prev = z1, z0\n            bifurcation_count = 0\n            in_bifurcation_zone = False\n\n            for _ in range(max_steps):\n                # 3. Predictor step\n                tangent = z_current - z_prev\n                v = tangent / np.linalg.norm(tangent)\n                z_pred = z_current + ds * v\n\n                # 4. Corrector step\n                self.z_k, self.v, self.ds = z_current, v, ds\n                corrector_sol = root(self._augmented_system, z_pred, jac=self._augmented_jacobian, method='hybr')\n                \n                if not corrector_sol.success:\n                    break # Stop continuation if corrector fails\n                \n                z_next = corrector_sol.x\n\n                # 5. Bifurcation detection\n                x_next, p_next = z_next[:3], z_next[3]\n                J_next = self.jacobian(x_next, p_next)\n                \n                try:\n                    singular_values = svdvals(J_next)\n                    sigma_min = np.min(singular_values)\n                except np.linalg.LinAlgError:\n                    sigma_min = 0.0\n\n                is_low = sigma_min  eps_sigma\n                if is_low and not in_bifurcation_zone:\n                    bifurcation_count += 1\n                    in_bifurcation_zone = True\n                elif not is_low:\n                    in_bifurcation_zone = False\n\n                # 6. Update for next step\n                z_prev, z_current = z_current, z_next\n                \n            return bifurcation_count\n\n    results = []\n    for case in test_cases:\n        solver = PSRContinuationSolver(\n            k0=case[\"k0\"],\n            Ea=case[\"Ea\"],\n            p_name=case[\"p_name\"],\n            fixed_param_val=case[\"fixed_param_val\"]\n        )\n        count = solver.run(\n            p_start=case[\"p_start\"],\n            dp_nat=case[\"dp_nat\"],\n            ds=case[\"ds\"],\n            max_steps=case[\"max_steps\"],\n            eps_sigma=case[\"eps_sigma\"]\n        )\n        results.append(count)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}