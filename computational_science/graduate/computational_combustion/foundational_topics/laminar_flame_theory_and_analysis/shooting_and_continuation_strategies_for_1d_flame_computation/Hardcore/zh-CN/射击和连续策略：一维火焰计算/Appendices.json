{
    "hands_on_practices": [
        {
            "introduction": "在着手进行火焰计算之前，一个基本问题是确定问题是否适定。本练习将火焰结构视为一个连接未燃和已燃平衡点的异宿轨道，这是一种强大的动力系统观点。通过应用不变流形的维数计数原理，您将推导出成功进行打靶计算所需的自由参数（如火焰速度）的最小数量，这项实践旨在帮助您掌握在数值求解之前，如何从理论上分析并确保问题的适定性。",
            "id": "4062376",
            "problem": "考虑一个一维、稳态、平面的自由传播预混火焰，其参考系相对于实验室参考系以未知速度 $s$ 运动。控制方程是在移动参考系下编写的稳态组分和能量守恒定律，其中包含分子扩散和单步反应。经过无量纲化并为梯度引入一阶变量后，该稳态边值问题可简化为以下形式的自治一阶常微分方程（ODE）系统：\n$$\n\\frac{d\\mathbf{u}}{dx}=\\mathbf{f}(\\mathbf{u};s), \\quad \\mathbf{u}\\in\\mathbb{R}^{n},\n$$\n其中 $n=4$ 来自两个二阶标量平衡方程（组分和能量）。远场边界条件为 $x\\to -\\infty$ 时的未燃态 $\\mathbf{u}^{-}$ 和 $x\\to +\\infty$ 时的已燃态 $\\mathbf{u}^{+}$。假设对于固定的 $s$，$\\mathbf{u}^{-}$ 和 $\\mathbf{u}^{+}$ 是该 ODE 的双曲平衡点，并且围绕这些平衡点的线性化谱为：\n$$\n\\sigma\\big(D_{\\mathbf{u}}\\mathbf{f}(\\mathbf{u}^{-};s)\\big)=\\{\\,0.38,\\;1.27,\\;-0.19,\\;-2.41\\,\\},\n$$\n$$\n\\sigma\\big(D_{\\mathbf{u}}\\mathbf{f}(\\mathbf{u}^{+};s)\\big)=\\{\\,-0.81,\\;-0.22,\\;0.36,\\;0.59\\,\\}。\n$$\n在动力学系统意义上，将 $x$ 视为自变量。你的目标是使用打靶法计算火焰，该方法从未燃平衡点的不稳定流形出发，射向已燃平衡点的稳定流形。在一个延拓框架中，你可以改变一组 $p$ 个标量延拓参数（包括但不限于波速 $s$）。由于问题在 $x$ 方向上具有平移不变性，你需要施加一个标量相位条件来在打靶过程中固定空间位移。\n\n从守恒定律结构和动力学系统中稳定与不稳定流形的定义出发，推导维数计数条件，以确定在使用一个标量相位条件消除平移不变性的情况下，通过打靶法找到从 $\\mathbf{u}^{-}$ 到 $\\mathbf{u}^{+}$ 的横截异宿连接所需的最小标量延拓参数数量 $p$。然后，利用给定的谱，计算此 $n=4$ 火焰模型的最小 $p$ 值。最终答案以一个无单位的整数形式给出。",
            "solution": "该问题要求推导一个维数计数条件，以确定使用打靶法计算一维稳态火焰结构所需的最小延拓参数数量 $p$。该结构对应于在 $n$ 维状态空间中连接未燃平衡态 $\\mathbf{u}^{-}$ 和已燃平衡态 $\\mathbf{u}^{+}$ 的一条异宿轨道。\n\n设控制自治常微分方程（ODE）系统为\n$$\n\\frac{d\\mathbf{u}}{dx} = \\mathbf{f}(\\mathbf{u}; \\mathbf{q}),\n$$\n其中 $\\mathbf{u} \\in \\mathbb{R}^n$ 是状态向量，$\\mathbf{q} \\in \\mathbb{R}^p$ 是 $p$ 个标量延拓参数组成的向量。代表火焰剖面的解是一条连接两个平衡点的轨迹：$\\lim_{x\\to-\\infty} \\mathbf{u}(x) = \\mathbf{u}^{-}$ 和 $\\lim_{x\\to+\\infty} \\mathbf{u}(x) = \\mathbf{u}^{+}$。在动力学系统的语言中，这条轨迹是一条异宿轨道。\n\n这样的轨道必须位于起始平衡点的不稳定流形 $W^u(\\mathbf{u}^{-})$ 和终点平衡点的稳定流形 $W^s(\\mathbf{u}^{+})$ 的交集上。这些不变流形的维数由平衡点处线性化系统的谱确定。令 $J^{-} = D_{\\mathbf{u}}\\mathbf{f}(\\mathbf{u}^{-}; \\mathbf{q})$ 和 $J^{+} = D_{\\mathbf{u}}\\mathbf{f}(\\mathbf{u}^{+}; \\mathbf{q})$ 分别为未燃态和已燃态处的雅可比矩阵。一个平衡点的不稳定流形的维数是其雅可比矩阵具有正实部的特征值的数量。稳定流形的维数是具有负实部的特征值的数量。问题指出平衡点是双曲的，这意味着没有实部为零的特征值。\n\n令 $d_u^{-} = \\dim(W^u(\\mathbf{u}^{-}))$ 为 $J^{-}$ 的特征值中满足 $\\Re(\\lambda) > 0$ 的数量。\n令 $d_s^{+} = \\dim(W^s(\\mathbf{u}^{+}))$ 为 $J^{+}$ 的特征值中满足 $\\Re(\\lambda) < 0$ 的数量。\n\n异宿轨道作为自治 ODE 的解，由于系统在自变量 $x$ 上的平移不变性，它不是一个孤立的点，而是一条一维曲线。如果 $\\mathbf{u}(x)$ 是一个解，那么对于任意常数位移 $c$，$\\mathbf{u}(x+c)$ 也是一个解。因此，一个鲁棒地找到的异宿连接应该对应于 $W^u(\\mathbf{u}^{-})$ 和 $W^s(\\mathbf{u}^{+})$ 的一维交集。\n\n根据横截性理论，在环境空间 $A$ 中两个流形 $M_1$ 和 $M_2$ 交集的维数由 $\\dim(M_1 \\cap M_2) = \\dim(M_1) + \\dim(M_2) - \\dim(A)$ 给出，前提是交集是横截的。对我们的问题，流形是 $W^u(\\mathbf{u}^{-})$ 和 $W^s(\\mathbf{u}^{+})$，环境空间是状态空间 $\\mathbb{R}^n$。对于一组固定的参数 $\\mathbf{q}$，一维横截交集的条件是：\n$$\n1 = d_u^{-} + d_s^{+} - n.\n$$\n重新整理得到在不需要可调参数的情况下，存在结构稳定的异宿轨道的条件：\n$$\nd_u^{-} + d_s^{+} = n+1.\n$$\n如果此等式不成立，则流形通常不会以所需的一维方式相交。这个所需交集的余维数，代表未满足的约束条件的数量，由 $C = (n+1) - (d_u^{-} + d_s^{+})$ 给出。为了满足这些约束并迫使流形以适当的方式相交，我们必须引入数量等于该余维数的自由参数。因此，所需的最小延拓参数数量 $p$ 是：\n$$\np = n+1 - (d_u^{-} + d_s^{+}).\n$$\n这假设了 $p \\ge 0$。如果维数之和已经足够大，则不需要参数，所以更正式地，$p = \\max(0, n+1 - (d_u^{-} + d_s^{+}))$。\n\n从数值打靶法的角度也可以推导出相同的结果。在打靶法中，我们的目标是求解一个代数方程组，其中变量的数量等于方程的数量。\n变量包括：\n1.  用于在 $d_u^{-}$ 维不稳定流形 $W^u(\\mathbf{u}^{-})$ 上指定初始条件的参数。这提供了 $d_u^{-}$ 个变量。\n2.  $p$ 个延拓参数 $\\mathbf{q}$。\n变量总数 = $d_u^{-} + p$。\n\n方程包括：\n1.  确保计算出的轨迹落在 $d_s^{+}$ 维稳定流形 $W^s(\\mathbf{u}^{+})$ 上所需的条件。这个流形可以在 $\\mathbb{R}^n$ 中由 $n - d_s^{+}$ 个方程定义。\n2.  一个标量相位条件，用于消除平移自由度并从一参数族的平移解中选择一个唯一的解。这提供了 1 个方程。\n方程总数 = $(n - d_s^{+}) + 1$。\n\n为一个适定的求根问题，令变量数等于方程数：\n$$\nd_u^{-} + p = n - d_s^{+} + 1.\n$$\n解出 $p$，我们得到相同的维数计数条件：\n$$\np = n+1 - d_u^{-} - d_s^{+}.\n$$\n现在，我们将此条件应用于具体问题。给定的参数是：\n状态空间的维数是 $n=4$。\n\n未燃态 $\\mathbf{u}^{-}$ 处的雅可比矩阵的谱为 $\\sigma\\big(D_{\\mathbf{u}}\\mathbf{f}(\\mathbf{u}^{-};s)\\big)=\\{\\,0.38,\\;1.27,\\;-0.19,\\;-2.41\\,\\}$。\n具有正实部的特征值是 $0.38$ 和 $1.27$。因此，$\\mathbf{u}^{-}$ 处不稳定流形的维数是 $d_u^{-} = 2$。\n\n已燃态 $\\mathbf{u}^{+}$ 处的雅可比矩阵的谱为 $\\sigma\\big(D_{\\mathbf{u}}\\mathbf{f}(\\mathbf{u}^{+};s)\\big)=\\{\\,-0.81,\\;-0.22,\\;0.36,\\;0.59\\,\\}$。\n具有负实部的特征值是 $-0.81$ 和 $-0.22$。因此，$\\mathbf{u}^{+}$ 处稳定流形的维数是 $d_s^{+} = 2$。\n\n我们有了所有必要的值：\n$n = 4$\n$d_u^{-} = 2$\n$d_s^{+} = 2$\n\n将这些值代入推导出的最小延拓参数数量 $p$ 的公式中：\n$$\np = n+1 - (d_u^{-} + d_s^{+})\n$$\n$$\np = 4+1 - (2 + 2)\n$$\n$$\np = 5 - 4\n$$\n$$\np = 1\n$$\n所需的最小延拓参数数量为 $1$。这与自由传播火焰的物理性质相符，其中火焰速度 $s$ 通常是问题的一个未知本征值，必须与解剖面一同确定，因此充当了所需的唯一延拓参数。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "火焰的响应，如点燃和熄灭，通常与分岔现象有关，即解的结构随参数发生质的变化。本练习通过一个典型的反应扩散模型，让您亲手实践如何检测这些关键的分岔点。您将通过编写代码来定位打靶法雅可比矩阵的奇异点，这直接对应于新解分支的出现，从而掌握参数连续化方法中的核心技术。",
            "id": "4062369",
            "problem": "考虑一个在无量纲空间区间 $x \\in [0,1]$ 上定义的、用于描述热扩散区中预混火焰的典型一维稳态反应扩散模型。在近起始区，经过适当的无量纲化处理，能量和物质守恒方程的振幅约化导出了一个标量场 $u(x)$ 的范式边值问题，该问题捕捉了点火-熄灭的平衡：\n$$\n\\frac{d^2 u}{dx^2} + \\mu\\,u - u^3 = 0,\\quad x \\in (0,1),\n$$\n其狄利克雷边界条件为\n$$\nu(0) = 0,\\quad u(1) = 0.\n$$\n此处，$u(x)$ 是一个无量纲温度或反应进程变量的振幅，$\\mu$ 是一个无量纲控制参数，概括了反应与扩散传输之间的竞争。该约化方程是临界点附近燃烧理论中一个经过充分检验的模型，并且在数学上与小振幅展开下的一维稳态反应扩散系统相一致。\n\n标准的打靶法策略将该边值问题重构为一个具有未知初始斜率的初值问题。引入 $v(x) = du/dx$，该系统可写为\n$$\n\\frac{du}{dx} = v,\\qquad \\frac{dv}{dx} = -\\mu\\,u + u^3,\n$$\n其初始条件为 $u(0) = 0$ 和 $v(0) = s$，其中 $s$ 是一个为满足终点边界条件 $u(1) = 0$ 而选择的未知标量。定义打靶残差\n$$\nR(s;\\mu) = u(1; s, \\mu),\n$$\n即在初始斜率为 $s$、参数为 $\\mu$ 的条件下，将初值问题从 $x=0$ 积分到 $x=1$ 所得到的在 $x=1$ 处的 $u$ 值。\n\n平凡分支 $u(x)\\equiv 0$ 对所有 $\\mu$ 都满足边界条件，并对应于 $s=0$。产生非平凡分支的分岔可以通过打靶映射在 $s=0$ 处的不可逆性来检测，这等价于打靶雅可比矩阵为零\n$$\n\\frac{\\partial R}{\\partial s}(0;\\mu) = \\lim_{s\\to 0} \\frac{R(s;\\mu)}{s}.\n$$\n通过在 $u=0$ 处对系统进行线性化（这将抑制三次项），导数 $\\partial R/\\partial s$ 可简化为线性常微分方程 $\\tfrac{d^2 u}{dx^2} + \\mu u = 0$ 在初始条件 $u(0)=0$、$u'(0)=1$ 下的解在边界上的取值。这给出了显式公式\n$$\n\\frac{\\partial R}{\\partial s}(0;\\mu) = \\frac{\\sin(\\sqrt{\\mu})}{\\sqrt{\\mu}}.\n$$\n分支点出现在使 $\\frac{\\partial R}{\\partial s}(0;\\mu) = 0$ 的参数值处，即\n$$\n\\mu_n = n^2 \\pi^2,\\quad n \\in \\mathbb{N}.\n$$\n\n您的任务是实现一个程序，该程序使用基于打靶的分岔检测和通过区间套分进行参数延拓的方法，执行以下计算：\n\n1. 对于给定的单个参数值 $\\,\\mu\\,$，计算并返回打靶雅可比矩阵的模的绝对值\n$$\nD(\\mu) = \\left|\\frac{\\partial R}{\\partial s}(0;\\mu)\\right| = \\left|\\frac{\\sin(\\sqrt{\\mu})}{\\sqrt{\\mu}}\\right|.\n$$\n\n2. 对于给定的参数区间 $[\\mu_a,\\mu_b]$（其中 $\\mu_a < \\mu_b$），使用区间套分延拓策略，通过寻找标量函数 $\\tfrac{\\partial R}{\\partial s}(0;\\mu)$ 的一个根来定位一个分支点 $\\mu^\\star \\in [\\mu_a,\\mu_b]$，即，\n$$\n\\frac{\\partial R}{\\partial s}(0;\\mu^\\star) = 0,\n$$\n并以浮点数形式返回 $\\mu^\\star$ 的值。\n\n您必须使用一个鲁棒的区间套分求解器应用于函数 $\\tfrac{\\partial R}{\\partial s}(0;\\mu)$ 来实现求根步骤，分岔的检测等同于检测该函数在区间两端的符号变化，然后向根进行精化。这体现了一种简单而有效的参数延拓策略。\n\n使用以下参数值测试套件：\n\n- 测试用例 1 (单个值): $\\mu = 8.0$。\n- 测试用例 2 (区间): $[\\mu_a,\\mu_b] = [9.0, 10.5]$。\n- 测试用例 3 (单个值): $\\mu = 12.0$。\n- 测试用例 4 (区间): $[\\mu_a,\\mu_b] = [38.0, 40.0]$。\n\n所有量都是无量纲的，因此不适用任何物理单位。未使用角度，因此不需要角度单位。您的程序应生成单行输出，其中包含按测试用例顺序排列的结果，结果为用方括号括起来的逗号分隔列表，输出值为浮点数：\n$$\n[\\;D(8.0),\\ \\mu^\\star \\text{ from } [9.0,10.5],\\ D(12.0),\\ \\mu^{\\star} \\text{ from } [38.0,40.0]\\;].\n$$\n不强制要求舍入规则；输出您的计算所产生的原生浮点表示。",
            "solution": "问题陈述已经过验证，并被确定为是合理的。它在科学上基于应用于典型燃烧模型的分岔和动力系统理论，问题定义明确，提供了所有必要信息，并且没有矛盾或含糊之处。任务以数学精度进行了规定。\n\n该问题要求实现与一维反应扩散方程分岔分析相关的两个不同计算任务。该分析基于平凡解分支上的打靶雅可比，由以下函数给出：\n$$\n\\frac{\\partial R}{\\partial s}(0;\\mu) = \\frac{\\sin(\\sqrt{\\mu})}{\\sqrt{\\mu}}\n$$\n其中 $\\mu$ 是控制参数。\n\n第一个任务是为特定的 $\\mu$ 值计算该雅可比矩阵的绝对值，记为 $D(\\mu)$。公式为：\n$$\nD(\\mu) = \\left|\\frac{\\sin(\\sqrt{\\mu})}{\\sqrt{\\mu}}\\right|\n$$\n这是一个直接的函数求值。对于提供单个参数值的测试用例，将执行此计算。\n- 对于测试用例 $1$，我们在 $\\mu = 8.0$ 处计算 $D(\\mu)$：\n$$\nD(8.0) = \\left|\\frac{\\sin(\\sqrt{8.0})}{\\sqrt{8.0}}\\right|\n$$\n- 对于测试用例 $3$，我们在 $\\mu = 12.0$ 处计算 $D(\\mu)$：\n$$\nD(12.0) = \\left|\\frac{\\sin(\\sqrt{12.0})}{\\sqrt{12.0}}\\right|\n$$\n\n第二个任务是使用区间套分延拓策略在给定的参数区间 $[\\mu_a, \\mu_b]$ 内定位一个分支点 $\\mu^\\star$。当雅可比矩阵为零时，会出现从平凡解出发的分支点，这使得从平凡解分岔出的非平凡解得以存在。这对应于寻找雅可比函数的根：\n$$\n\\frac{\\partial R}{\\partial s}(0;\\mu^\\star) = \\frac{\\sin(\\sqrt{\\mu^\\star})}{\\sqrt{\\mu^\\star}} = 0\n$$\n对于 $\\mu > 0$，该函数的根由分子 $\\sin(\\sqrt{\\mu^\\star}) = 0$ 的零点确定。当 $\\sqrt{\\mu^\\star} = n\\pi$（对于任何非零整数 $n \\in \\mathbb{N}$）时，此条件得到满足，从而得到众所周知的位于 $\\mu^\\star_n = n^2\\pi^2$ 的分岔点。\n\n问题指定使用鲁棒的区间套分求解器。这意味着对函数 $f(\\mu) = \\frac{\\sin(\\sqrt{\\mu})}{\\sqrt{\\mu}}$ 在给定区间 $[\\mu_a, \\mu_b]$ 上应用数值求根算法，例如布伦特法（Brent's method）。该方法是合适的，因为如果区间端点处的函数值 $f(\\mu_a)$ 和 $f(\\mu_b)$ 异号，它能保证收敛到一个根。\n- 对于测试用例 $2$，区间是 $[\\mu_a, \\mu_b] = [9.0, 10.5]$。我们寻找第一个分岔点 $\\mu^\\star_1 = (1\\cdot\\pi)^2 = \\pi^2 \\approx 9.8696$。我们验证该区间套住了这个根：\n  - 在 $\\mu_a = 9.0$ 处，函数自变量是 $\\sqrt{9.0} = 3.0$。函数值为 $f(9.0) = \\sin(3.0)/3.0 > 0$。\n  - 在 $\\mu_b = 10.5$ 处，自变量是 $\\sqrt{10.5} \\approx 3.24$。由于 $\\pi \\approx 3.14159$，该自变量位于区间 $(\\pi, 2\\pi)$ 内，其中正弦函数为负。因此，$f(10.5) = \\sin(\\sqrt{10.5})/\\sqrt{10.5} < 0$。\n  由于 $f(\\mu_a) \\cdot f(\\mu_b) < 0$，区间内存在一个根。数值求解器将找到 $\\mu^\\star \\approx 9.8696044$。\n\n- 对于测试用例 $4$，区间是 $[\\mu_a, \\mu_b] = [38.0, 40.0]$。我们寻找第二个分岔点 $\\mu^\\star_2 = (2\\cdot\\pi)^2 = 4\\pi^2 \\approx 39.4784$。我们验证该区间套住了根：\n  - 在 $\\mu_a = 38.0$ 处，自变量是 $\\sqrt{38.0} \\approx 6.164$。由于 $2\\pi \\approx 6.283$，该自变量位于区间 $(\\pi, 2\\pi)$ 内，其中正弦函数为负。因此，$f(38.0) < 0$。\n  - 在 $\\mu_b = 40.0$ 处，自变量是 $\\sqrt{40.0} \\approx 6.325$，略大于 $2\\pi$。该自变量位于 $(2\\pi, 3\\pi)$ 区间内，其中正弦函数为正。因此，$f(40.0) > 0$。\n  由于 $f(\\mu_a) \\cdot f(\\mu_b) < 0$，存在一个根，并将通过数值方法定位在 $\\mu^\\star \\approx 39.4784176$。\n\n实现将包括一个 Python 脚本，该脚本利用 `numpy` 库进行所需的数学函数计算，并使用 `scipy.optimize.brentq` 作为求根任务的鲁棒区间套分求解器。该脚本将按顺序处理每个测试用例，并按要求将结果格式化为单个逗号分隔的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating Jacobian magnitudes and finding bifurcation points\n    for the given test cases.\n    \"\"\"\n\n    # Define the shooting Jacobian function dR/ds(0, mu).\n    # This function is the one whose roots are the bifurcation points.\n    def shooting_jacobian(mu: float) -> float:\n        \"\"\"\n        Calculates the shooting Jacobian at the trivial branch for a given parameter mu.\n        The formula is sin(sqrt(mu)) / sqrt(mu).\n        \"\"\"\n        # The problem scope implies mu > 0. The test cases all satisfy this.\n        # For mu=0, the limit is 1. We handle mu > 0 as per the problem.\n        if mu < 0:\n            # This case is not hit by the provided test suite.\n            # Returning NaN or raising an error are valid options for mu  0.\n            # The limit as mu -> 0+ is 1.0.\n            return np.nan\n        elif mu == 0.0:\n            return 1.0\n        \n        sqrt_mu = np.sqrt(mu)\n        return np.sin(sqrt_mu) / sqrt_mu\n\n    # Define the tasks based on the problem description.\n    # Task 1: Compute D(mu) = |shooting_jacobian(mu)|\n    def calculate_D(mu: float) - float:\n        \"\"\"\n        Calculates the absolute magnitude of the shooting Jacobian.\n        \"\"\"\n        return np.abs(shooting_jacobian(mu))\n\n    # Task 2: Find the root mu* in a given interval [mu_a, mu_b].\n    # This is done by finding the root of the shooting_jacobian function.\n    # scipy.optimize.brentq is a robust bracketed root-finding algorithm.\n    def find_bifurcation_point(mu_a: float, mu_b: float) - float:\n        \"\"\"\n        Finds a root of the shooting_jacobian function within the interval [mu_a, mu_b].\n        \"\"\"\n        root = brentq(shooting_jacobian, mu_a, mu_b)\n        return root\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'type': 'single', 'value': 8.0},\n        {'type': 'interval', 'bounds': [9.0, 10.5]},\n        {'type': 'single', 'value': 12.0},\n        {'type': 'interval', 'bounds': [38.0, 40.0]},\n    ]\n    \n    results = []\n    \n    # Process each test case.\n    for case in test_cases:\n        if case['type'] == 'single':\n            # This is Task 1: compute D(mu).\n            mu = case['value']\n            result = calculate_D(mu)\n            results.append(result)\n        elif case['type'] == 'interval':\n            # This is Task 2: find mu*.\n            mu_a, mu_b = case['bounds']\n            result = find_bifurcation_point(mu_a, mu_b)\n            results.append(result)\n\n    # Final print statement in the exact required format.\n    # The format is a comma-separated list of native float representations in brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "将火焰控制方程离散化后，我们得到一个大型的刚性非线性方程组，直接求解该方程组是现代火焰计算的核心。本练习要求您实现并比较两种强大的求解器：经典的牛顿法和更为稳健的伪瞬态连续法（PTC）。通过处理不同刚度等级的火焰问题，您将亲身体验到为何对于燃烧这类具有陡峭锋面的问题，需要如PTC这样具有全局收敛性的方法来保证计算的成功。",
            "id": "3966595",
            "problem": "考虑一个定义在空间区间 $z \\in [0,1]$ 上的、Lewis数为1的一维、稳态、无量纲的层流预混自由火焰反应-扩散模型。未知量为无量纲温度 $\\theta(z)$ 和无量纲燃料质量分数 $y(z)$。对于 $z \\in (0,1)$，控制方程为：\n$$\n0 = \\frac{d^2 \\theta}{dz^2} + \\mathrm{Da}\\, y\\, \\exp\\!\\left(-\\frac{\\beta}{1+\\gamma \\theta}\\right),\n$$\n$$\n0 = \\mathrm{Le}\\, \\frac{d^2 y}{dz^2} - \\mathrm{Da}\\, y\\, \\exp\\!\\left(-\\frac{\\beta}{1+\\gamma \\theta}\\right),\n$$\n附带Dirichlet边界条件\n$$\n\\theta(0)=0,\\quad \\theta(1)=\\Theta_{\\mathrm{ad}},\\quad y(0)=1,\\quad y(1)=0.\n$$\n这里，$\\mathrm{Da}$ 是Damköhler数（反应时间尺度与扩散时间尺度之比），$\\beta$ 是无量纲活化能参数，$\\gamma$ 是热释放耦合系数，$\\mathrm{Le}$ 是Lewis数（热扩散率与质量扩散率之比），$\\Theta_{\\mathrm{ad}}$ 是无量纲绝热温升。这些参数控制着刚性：大的 $\\beta$ 和大的 $\\mathrm{Da}$ 会产生指数级尖锐的反应区。\n\n您的任务是使用二阶中心差分，在 $N$ 个等距网格点（$N=50$）上对这些方程进行离散化。设网格定义为 $z_i = i\\,\\Delta z$，其中 $i=0,1,\\dots,N-1$，$\\Delta z = 1/(N-1)$。将离散未知量记为 $\\theta_i \\approx \\theta(z_i)$ 和 $y_i \\approx y(z_i)$。为包含 $2N$ 个未知量的向量 $\\mathbf{U} = [\\theta_0,\\theta_1,\\dots,\\theta_{N-1},y_0,y_1,\\dots,y_{N-1}]^\\top$ 构建非线性残差向量 $\\mathbf{F}(\\mathbf{U})=\\mathbf{0}$，具体如下：\n\n- 对于内部节点 $i=1,2,\\dots,N-2$：\n$$\nF_{\\theta,i} = \\frac{\\theta_{i-1} - 2\\theta_i + \\theta_{i+1}}{\\Delta z^2} + \\mathrm{Da}\\, y_i\\, \\exp\\!\\left(-\\frac{\\beta}{1+\\gamma \\theta_i}\\right),\n$$\n$$\nF_{y,i} = \\mathrm{Le}\\, \\frac{y_{i-1} - 2 y_i + y_{i+1}}{\\Delta z^2} - \\mathrm{Da}\\, y_i\\, \\exp\\!\\left(-\\frac{\\beta}{1+\\gamma \\theta_i}\\right).\n$$\n\n- 对于边界节点：\n$$\nF_{\\theta,0} = \\theta_0 - 0,\\quad F_{\\theta,N-1} = \\theta_{N-1} - \\Theta_{\\mathrm{ad}},\n$$\n$$\nF_{y,0} = y_0 - 1,\\quad F_{y,N-1} = y_{N-1} - 0.\n$$\n\n将残差范数定义为完整的 $2N$ 维向量 $\\mathbf{F}(\\mathbf{U})$ 的欧几里得范数，即：\n$$\n\\|\\mathbf{F}(\\mathbf{U})\\|_2 = \\left( \\sum_{j=1}^{2N} F_j^2 \\right)^{1/2}.\n$$\n\n您必须实现并比较两种非线性求解器：\n\n1. 直接牛顿法（也称为牛顿-拉夫逊法）：从一个初始猜测值开始，在每次迭代 $k$ 中，构建雅可比矩阵 $\\mathbf{J}(\\mathbf{U}^{(k)}) = \\partial \\mathbf{F}/\\partial \\mathbf{U}$ 并求解线性系统\n$$\n\\mathbf{J}(\\mathbf{U}^{(k)})\\, \\delta^{(k)} = -\\mathbf{F}(\\mathbf{U}^{(k)}),\n$$\n然后更新\n$$\n\\mathbf{U}^{(k+1)} = \\mathbf{U}^{(k)} + \\delta^{(k)}.\n$$\n当 $\\|\\mathbf{F}(\\mathbf{U}^{(k+1)})\\|_2 \\le 10^{-8}$ 或迭代次数达到最大值50时终止。\n\n2. 伪瞬态延拓法（PTC）：引入伪时间，并使用带有自适应伪时间步长的向后欧拉线性化方法向稳态推进。在迭代 $k$ 中，对于当前的伪时间步长 $\\Delta t^{(k)}$，求解\n$$\n\\left( \\frac{1}{\\Delta t^{(k)}} \\mathbf{I} + \\mathbf{J}(\\mathbf{U}^{(k)}) \\right)\\, \\delta^{(k)} = -\\mathbf{F}(\\mathbf{U}^{(k)}),\n$$\n并更新\n$$\n\\mathbf{U}^{(k+1)} = \\mathbf{U}^{(k)} + \\delta^{(k)}.\n$$\n使用以下伪时间步长控制策略：\n- 初始化 $\\Delta t^{(0)} = 10^{-4}$，其下界和上界分别为 $10^{-6}$ 和 $10^{2}$。\n- 计算出 $\\mathbf{U}^{(k+1)}$ 后，令 $r^{(k)} = \\|\\mathbf{F}(\\mathbf{U}^{(k+1)})\\|_2 / \\|\\mathbf{F}(\\mathbf{U}^{(k)})\\|_2$。如果 $r^{(k)}  0.7$，则通过 $\\Delta t^{(k+1)} = \\min( 2\\, \\Delta t^{(k)}, 10^{2} )$ 增大步长；否则，通过 $\\Delta t^{(k+1)} = \\max( 0.5\\, \\Delta t^{(k)}, 10^{-6} )$ 减小步长。\n当 $\\|\\mathbf{F}(\\mathbf{U}^{(k+1)})\\|_2 \\le 10^{-8}$ 或迭代次数达到最大值200时终止。\n\n两种方法均使用相同的初始猜测值：\n$$\n\\theta_i^{(0)} = \\Theta_{\\mathrm{ad}}\\, z_i,\\qquad y_i^{(0)} = 1 - z_i.\n$$\n\n为了提高效率，请推导并实现解析的雅可比矩阵项。对于每个内部节点 $i$，反应项 $R_i = \\mathrm{Da}\\, y_i\\, \\exp\\!\\left(-\\frac{\\beta}{1+\\gamma \\theta_i}\\right)$ 的偏导数为\n$$\n\\frac{\\partial R_i}{\\partial \\theta_i} = \\mathrm{Da}\\, y_i\\, \\exp\\!\\left(-\\frac{\\beta}{1+\\gamma \\theta_i}\\right)\\, \\frac{\\beta \\gamma}{(1+\\gamma \\theta_i)^2},\\qquad \\frac{\\partial R_i}{\\partial y_i} = \\mathrm{Da}\\, \\exp\\!\\left(-\\frac{\\beta}{1+\\gamma \\theta_i}\\right).\n$$\n\n测试套件：在以下参数集上运行您的程序，所有情况均设置 $\\Theta_{\\mathrm{ad}}=1$ 和 $\\mathrm{Le}=1$：\n- 情况A（中等刚性）：$\\mathrm{Da}=10$, $\\beta=5$, $\\gamma=4$。\n- 情况B（刚性）：$\\mathrm{Da}=50$, $\\beta=12$, $\\gamma=4$。\n- 情况C（非常刚性）：$\\mathrm{Da}=100$, $\\beta=20$, $\\gamma=4$。\n\n对于每种情况，请分别报告直接牛顿法和伪瞬态延拓法的四个量：最终的残差范数和终止时的迭代次数。如果一种方法因线性求解错误而失败，或在最大迭代次数内未达到容差，则报告终止时所达到的残差范数和使用的迭代次数。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个由逗号分隔并用方括号括起来的结果列表，排序如下\n$$\n[\\; r^{\\mathrm{N}}_{\\mathrm{A}},\\; i^{\\mathrm{N}}_{\\mathrm{A}},\\; r^{\\mathrm{P}}_{\\mathrm{A}},\\; i^{\\mathrm{P}}_{\\mathrm{A}},\\; r^{\\mathrm{N}}_{\\mathrm{B}},\\; i^{\\mathrm{N}}_{\\mathrm{B}},\\; r^{\\mathrm{P}}_{\\mathrm{B}},\\; i^{\\mathrm{P}}_{\\mathrm{B}},\\; r^{\\mathrm{N}}_{\\mathrm{C}},\\; i^{\\mathrm{N}}_{\\mathrm{C}},\\; r^{\\mathrm{P}}_{\\mathrm{C}},\\; i^{\\mathrm{P}}_{\\mathrm{C}} \\;],\n$$\n其中 $r$ 表示最终残差范数（浮点数），$i$ 表示迭代次数（整数）。由于公式是无量纲的，因此不涉及物理单位。不涉及角度。不使用百分比。",
            "solution": "该问题要求对一个模拟一维层流预混火焰的耦合非线性边值问题系统进行数值求解。连续的控制方程在均匀网格上使用二阶中心有限差分格式进行离散化，从而得到一个形如 $\\mathbf{F}(\\mathbf{U}) = \\mathbf{0}$ 的大型非线性代数方程组。\n\n未知量向量 $\\mathbf{U}$ 是通过串联所有网格点 $i=0, 1, \\dots, N-1$ 的离散温度值 $\\theta_i$ 和离散燃料质量分数值 $y_i$ 来构建的。具体来说，$\\mathbf{U} = [\\theta_0, \\dots, \\theta_{N-1}, y_0, \\dots, y_{N-1}]^\\top$，得到一个大小为 $2N$ 的向量。残差向量 $\\mathbf{F}(\\mathbf{U})$ 的结构类似，其前 $N$ 个分量对应温度的离散方程，后 $N$ 个分量对应燃料质量分数的离散方程。对于内部网格点 $i=1, \\dots, N-2$，残差方程由离散化的控制方程给出。对于边界点 $i=0$ 和 $i=N-1$，残差代表了对Dirichlet边界条件的强制施加。\n\n需要实现两种迭代数值方法来寻找满足 $\\mathbf{F}(\\mathbf{U}) = \\mathbf{0}$ 的根 $\\mathbf{U}$。\n\n首先，直接牛顿法（牛顿-拉夫逊法）是一种求根算法，它从一个初始猜测值 $\\mathbf{U}^{(0)}$ 开始，并对其进行迭代优化。在每次迭代 $k$ 中，非线性函数 $\\mathbf{F}(\\mathbf{U})$ 在当前迭代点 $\\mathbf{U}^{(k)}$ 附近通过其一阶泰勒展开进行近似：\n$$ \\mathbf{F}(\\mathbf{U}) \\approx \\mathbf{F}(\\mathbf{U}^{(k)}) + \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{U}}\\bigg|_{\\mathbf{U}^{(k)}} (\\mathbf{U} - \\mathbf{U}^{(k)}) $$\n通过设置 $\\mathbf{F}(\\mathbf{U}) = \\mathbf{0}$ 来寻找下一个迭代点 $\\mathbf{U}^{(k+1)}$，并定义雅可比矩阵为 $\\mathbf{J}(\\mathbf{U}^{(k)}) = \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{U}}\\big|_{\\mathbf{U}^{(k)}}$，我们得到了用于求解更新步长 $\\delta^{(k)} = \\mathbf{U}^{(k+1)} - \\mathbf{U}^{(k)}$ 的线性系统：\n$$ \\mathbf{J}(\\mathbf{U}^{(k)})\\, \\delta^{(k)} = -\\mathbf{F}(\\mathbf{U}^{(k)}) $$\n求解出 $\\delta^{(k)}$ 后，通过 $\\mathbf{U}^{(k+1)} = \\mathbf{U}^{(k)} + \\delta^{(k)}$ 更新解。当猜测值足够接近根时，该方法表现出二次收敛性，但如果初始猜测值不佳，它可能会发散，特别是对于吸引盆较小的刚性系统。\n\n其次，伪瞬态延拓法（PTC）是一种旨在提高牛顿法鲁棒性的全局化技术。它将稳态问题 $\\mathbf{F}(\\mathbf{U})=\\mathbf{0}$ 重新表述为伪瞬态问题 $\\frac{d\\mathbf{U}}{dt} = -\\mathbf{F}(\\mathbf{U})$ 的长时间解。在伪时间上应用步长为 $\\Delta t$ 的隐式（向后）欧拉离散法可得：\n$$ \\frac{\\mathbf{U}^{(k+1)} - \\mathbf{U}^{(k)}}{\\Delta t^{(k)}} = -\\mathbf{F}(\\mathbf{U}^{(k+1)}) $$\n将项 $\\mathbf{F}(\\mathbf{U}^{(k+1)})$ 在当前迭代点 $\\mathbf{U}^{(k)}$ 附近线性化为 $\\mathbf{F}(\\mathbf{U}^{(k+1)}) \\approx \\mathbf{F}(\\mathbf{U}^{(k)}) + \\mathbf{J}(\\mathbf{U}^{(k)})(\\mathbf{U}^{(k+1)} - \\mathbf{U}^{(k)})$，并重新整理，得到用于求解更新量 $\\delta^{(k)}$ 的线性系统：\n$$ \\left( \\frac{1}{\\Delta t^{(k)}} \\mathbf{I} + \\mathbf{J}(\\mathbf{U}^{(k)}) \\right)\\, \\delta^{(k)} = -\\mathbf{F}(\\mathbf{U}^{(k)}) $$\n其中 $\\mathbf{I}$ 是单位矩阵。项 $\\frac{1}{\\Delta t^{(k)}}\\mathbf{I}$ 加在雅可比矩阵的对角线上，增强了对角占优性，从而改善了线性系统的条件数，尤其是在 $\\Delta t^{(k)}$ 很小时。这使得该方法对不良的初始猜测值更具鲁棒性。自适应时间步长策略允许该方法在收敛缓慢时采取小的、谨慎的步长（通过减小 $\\Delta t^{(k)}$），在收敛快速时采取大的、更激进的类牛顿步长（通过增大 $\\Delta t^{(k)}$）。\n\n对于这两种方法，都必须构建解析的雅可比矩阵 $\\mathbf{J}$。雅可比矩阵具有一个 $2 \\times 2$ 的块结构，对应于 $\\theta$ 和 $y$ 的残差相对于 $\\theta$ 和 $y$ 变量的导数。这些矩阵项是通过将残差方程 $F_{\\theta,i}$ 和 $F_{y,i}$ 对变量 $\\theta_j$ 和 $y_j$ 求导得出的。对于内部节点，这会产生一个由有限差分模板带来的带状结构，以及由非线性反应耦合产生的非对角项。反应项 $R_i = \\mathrm{Da}\\, y_i\\, \\exp(-\\frac{\\beta}{1+\\gamma \\theta_i})$ 的导数如下：\n$$ \\frac{\\partial R_i}{\\partial \\theta_i} = R_i \\frac{\\beta \\gamma}{(1+\\gamma \\theta_i)^2}, \\qquad \\frac{\\partial R_i}{\\partial y_i} = \\frac{R_i}{y_i} = \\mathrm{Da}\\, \\exp\\!\\left(-\\frac{\\beta}{1+\\gamma \\theta_i}\\right) $$\n对于边界节点，残差方程是线性的，这导致雅可比矩阵对角线上的元素为常数1。\n\n整体实现过程首先是定义用于计算任意给定状态 $\\mathbf{U}$ 下的残差向量 $\\mathbf{F}(\\mathbf{U})$ 和雅可比矩阵 $\\mathbf{J}(\\mathbf{U})$ 的函数。然后，两个独立的求解器函数分别实现牛顿法和PTC方法的迭代循环，包括它们各自的终止准则和逻辑。初始猜测值由给定的线性剖面构造。程序遍历三个指定的测试用例，为每个用例运行两种求解器，并收集最终的残差范数和迭代次数以供报告。这一比较突显了牛顿法的快速收敛性与PTC方法的优越鲁棒性之间的权衡，特别是当问题刚性随参数 $\\mathrm{Da}$ 和 $\\beta$ 增加时。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a 1D premixed flame problem using Newton and PTC methods.\n    \"\"\"\n    # --- Problem Constants ---\n    N = 50\n    DZ = 1.0 / (N - 1)\n    DZ2 = DZ * DZ\n    Z = np.linspace(0, 1, N)\n    TOL = 1e-8\n\n    # --- Test Cases ---\n    test_cases = [\n        # Case A (moderate stiffness)\n        {'Da': 10, 'beta': 5, 'gamma': 4, 'Le': 1, 'The_ad': 1},\n        # Case B (stiff)\n        {'Da': 50, 'beta': 12, 'gamma': 4, 'Le': 1, 'The_ad': 1},\n        # Case C (very stiff)\n        {'Da': 100, 'beta': 20, 'gamma': 4, 'Le': 1, 'The_ad': 1},\n    ]\n\n    # --- Helper Functions for Residual and Jacobian ---\n    \n    def compute_residual(U, params):\n        Da, beta, gamma, Le, The_ad = params['Da'], params['beta'], params['gamma'], params['Le'], params['The_ad']\n        theta = U[:N]\n        y = U[N:]\n        F = np.zeros(2 * N)\n\n        # Interior nodes\n        for i in range(1, N - 1):\n            # The reaction term argument can become large positive if (1+gamma*theta) is small or negative,\n            # leading to overflow in np.exp. Clamp the argument to a reasonable max value.\n            arg = -beta / (1.0 + gamma * theta[i]) if (1.0 + gamma * theta[i]) != 0 else np.inf\n            exp_term = np.exp(min(arg, 700)) if y[i] > 0 else 0\n            R = Da * y[i] * exp_term\n            \n            F[i] = (theta[i-1] - 2*theta[i] + theta[i+1]) / DZ2 + R\n            F[N + i] = Le * (y[i-1] - 2*y[i] + y[i+1]) / DZ2 - R\n            \n        # Boundary conditions\n        F[0] = theta[0] - 0.0\n        F[N-1] = theta[N-1] - The_ad\n        F[N] = y[0] - 1.0\n        F[2*N-1] = y[N-1] - 0.0\n        \n        return F\n\n    def compute_jacobian(U, params):\n        Da, beta, gamma, Le = params['Da'], params['beta'], params['gamma'], params['Le']\n        theta = U[:N]\n        y = U[N:]\n        J = np.zeros((2 * N, 2 * N))\n\n        # Interior nodes\n        for i in range(1, N - 1):\n            denom = 1.0 + gamma * theta[i]\n            if denom == 0 or y[i] = 0:\n                dRd_theta, dRd_y = 0.0, 0.0\n            else:\n                arg = -beta / denom\n                exp_term = np.exp(min(arg, 700))\n                dRd_theta = Da * y[i] * exp_term * (beta * gamma) / (denom * denom)\n                dRd_y = Da * exp_term\n\n            # Block dF_theta / d_theta\n            J[i, i-1] = 1.0 / DZ2\n            J[i, i] = -2.0 / DZ2 + dRd_theta\n            J[i, i+1] = 1.0 / DZ2\n            \n            # Block dF_theta / d_y\n            J[i, N + i] = dRd_y\n            \n            # Block dF_y / d_theta\n            J[N + i, i] = -dRd_theta\n            \n            # Block dF_y / d_y\n            J[N + i, N + i - 1] = Le / DZ2\n            J[N + i, N + i]     = -2.0 * Le / DZ2 - dRd_y\n            J[N + i, N + i + 1] = Le / DZ2\n\n        # Boundary conditions\n        J[0, 0] = 1.0\n        J[N-1, N-1] = 1.0\n        J[N, N] = 1.0\n        J[2*N-1, 2*N-1] = 1.0\n        \n        return J\n\n    # --- Solver Implementations ---\n    \n    def solve_newton(U_init, params):\n        max_iter = 50\n        U = U_init.copy()\n        \n        for k in range(max_iter):\n            F = compute_residual(U, params)\n            norm_F = np.linalg.norm(F)\n            \n            if norm_F = TOL:\n                return norm_F, k\n            \n            J = compute_jacobian(U, params)\n            \n            try:\n                delta = np.linalg.solve(J, -F)\n            except np.linalg.LinAlgError:\n                return norm_F, k\n            \n            U += delta\n            \n        final_norm = np.linalg.norm(compute_residual(U, params))\n        return final_norm, max_iter\n\n    def solve_ptc(U_init, params):\n        max_iter = 200\n        U = U_init.copy()\n        \n        dt = 1e-4\n        dt_min, dt_max = 1e-6, 1e2\n        \n        F_current = compute_residual(U, params)\n        norm_F_current = np.linalg.norm(F_current)\n\n        for k in range(max_iter):\n            if norm_F_current = TOL:\n                return norm_F_current, k\n            \n            J = compute_jacobian(U, params)\n            A = np.identity(2 * N) * (1.0 / dt) + J\n            \n            try:\n                delta = np.linalg.solve(A, -F_current)\n            except np.linalg.LinAlgError:\n                return norm_F_current, k\n            \n            U += delta\n            \n            F_next = compute_residual(U, params)\n            norm_F_next = np.linalg.norm(F_next)\n            \n            ratio = norm_F_next / norm_F_current if norm_F_current > 1e-12 else 0.0\n            \n            if ratio  0.7:\n                dt = min(2.0 * dt, dt_max)\n            else:\n                dt = max(0.5 * dt, dt_min)\n            \n            F_current = F_next\n            norm_F_current = norm_F_next\n\n        return norm_F_current, max_iter\n\n    # --- Main Execution Logic ---\n    results = []\n    for case in test_cases:\n        theta0 = case['The_ad'] * Z\n        y0 = 1.0 - Z\n        U0 = np.concatenate([theta0, y0])\n        \n        res_N, iter_N = solve_newton(U0, case)\n        results.extend([res_N, iter_N])\n        \n        res_P, iter_P = solve_ptc(U0, case)\n        results.extend([res_P, iter_P])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}