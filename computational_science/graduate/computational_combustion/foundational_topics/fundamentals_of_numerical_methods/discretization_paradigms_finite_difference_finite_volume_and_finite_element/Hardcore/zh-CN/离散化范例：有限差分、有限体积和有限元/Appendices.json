{
    "hands_on_practices": [
        {
            "introduction": "在选择离散化方法时，我们不仅关心其精度，还关心数值解的定性属性。本练习探讨一个关键属性——离散极值原理 (Discrete Maximum Principle, DMP)，它确保了像温度或组分浓度这类物理量的数值解能保持在物理现实的界限内。通过使用有限差分法、有限体积法和有限元法实现一个简单的反应-扩散问题，您将直接观察到这些范式在行为上的差异，并理解在何种条件下某些方法可能会产生非物理结果。",
            "id": "4020797",
            "problem": "考虑在区间 $[0,1]$ 上的单个无量纲反应标量的一维稳态反应-扩散平衡，介质均匀且具有指定的狄利克雷边界数据。控制方程源于物种守恒和菲克扩散，其形式为\n$$\n- \\frac{d}{dx}\\left(D(x)\\,\\frac{du}{dx}\\right) + k\\,u(x) = 0,\\quad x\\in(0,1),\n$$\n边界条件为\n$$\nu(0) = 1,\\quad u(1) = 0,\n$$\n其中 $D(x) > 0$ 是扩散系数，$k \\ge 0$ 是反应（吸收）系数。所有物理量均为无量纲。\n\n你的任务是编写一个完整、可运行的程序，该程序：\n- 在包含 $N$ 个单元（$N+1$ 个节点）的均匀网格上构建三种离散近似，实现：\n  1. 有限差分法（FD; Finite Difference），对变化的 $D(x)$ 使用基于保守通量的中心近似。\n  2. 有限体积法（FV; Finite Volume），使用两点通量近似，即平衡控制体面上的通量。\n  3. 有限元法（FE; Finite Element），使用线性元，组装扩散刚度矩阵，并对反应项使用一致质量矩阵。\n- 在每种范式中，求解所得的线性系统以获得离散内部解，并强行施加狄利克雷边界条件 $u(0)=1$ 和 $u(1)=0$。\n- 对每种方法，检查是否满足离散极值原理（DMP; Discrete Maximum Principle），此处定义为：在数值容差范围内，每个内部离散值都位于闭区间 $[0,1]$ 内。形式上，如果 $u_i$ 表示一个内部自由度，则测试为\n$$\n\\min_i u_i \\ge 0 - \\varepsilon\\quad\\text{and}\\quad \\max_i u_i \\le 1 + \\varepsilon,\n$$\n容差为 $\\varepsilon = 10^{-12}$。\n- 针对每个测试用例，报告三个布尔值，分别表示 FD、FV 和 FE 离散解是否满足 DMP。\n\n在所有离散化中，使用包含 $N$ 个单元的均匀划分，$x_j = j\\,\\Delta x$，其中 $j=0,1,\\dots,N$，$\\Delta x = 1/N$。对于变化的扩散系数，根据每个测试用例的指示逐点定义 $D(x)$。在 FD 和 FV 中，计算面心扩散系数 $D_{j+\\frac{1}{2}} = D\\!\\left(x_{j+\\frac{1}{2}}\\right)$，其中 $x_{j+\\frac{1}{2}} = \\left(j+\\frac{1}{2}\\right)\\Delta x$。在 FE 中，逐单元组装，每个单元的扩散系数取为常数 $D_e = D\\!\\left(x_{e+\\frac{1}{2}}\\right)$，并使用一致的反应质量矩阵。\n\n测试套件：\n- 案例 1（理想情况，仅扩散）：$N=50$, $k=0$, $D(x)\\equiv 1$。\n- 案例 2（反应主导，粗网格）：$N=10$, $k=5000$, $D(x)\\equiv 1$。\n- 案例 3（扩散主导）：$N=50$, $k=1$, $D(x)\\equiv 10$。\n- 案例 4（强扩散跳跃带反应）：$N=20$, $k=100$, \n  $D(x) = \\begin{cases}\n  1, & x < 0.3, \\\\\n  0.01, & x \\ge 0.3.\n  \\end{cases}$\n- 案例 5（边界主导，粗网格）：$N=3$, $k=0$, $D(x)\\equiv 1$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表，不含空格，按上述测试用例的顺序排列。每个内部列表包含三个条目，对应于 $(\\text{FD},\\text{FV},\\text{FE})$ 的 DMP 指示符。例如，打印的行应如下所示：\n$$\n[[\\text{True},\\text{True},\\text{False}],[\\text{True},\\text{True},\\text{True}],\\dots]\n$$\n但其中的布尔值应由你的实现计算得出。输出必须是单行，并且必须与此结构完全匹配。",
            "solution": "用户提供的问题经评估有效。该问题具有科学依据、良定、客观，并包含足够的信息以获得唯一解。该问题要求针对一维稳态反应-扩散方程（输运现象和计算科学中的一个典型问题）实现并比较三种数值方法。\n\n在域 $x \\in [0,1]$ 上，反应标量 $u(x)$ 的控制方程由下式给出：\n$$\n- \\frac{d}{dx}\\left(D(x)\\,\\frac{du}{dx}\\right) + k\\,u(x) = 0\n$$\n边界条件为狄利克雷边界条件 $u(0) = 1$ 和 $u(1) = 0$。此处，$D(x) > 0$ 是扩散系数，$k \\ge 0$ 是反应速率系数。\n\n我们将在一个包含 $N$ 个单元和 $N+1$ 个节点的均匀网格上离散化该方程，其中 $x_j = j\\,\\Delta x$，$j=0, 1, \\dots, N$，网格间距为 $\\Delta x = 1/N$。节点 $x_j$ 处的离散解记为 $u_j$。$N-1$ 个内部节点值 $u_1, u_2, \\dots, u_{N-1}$ 是待求解的未知数。\n\n### 1. 有限差分法（FD）\nFD 方法在离散节点处近似导数。对于可变的扩散系数，采用保守格式。在内部节点 $x_j$ 处，扩散通量的散度 $-\\frac{d}{dx}(D \\frac{du}{dx})$ 在以 $x_j$ 为中心、长度为 $\\Delta x$ 的控制体上使用中心差分进行近似：\n$$\n-\\left.\\frac{d}{dx}\\left(D(x)\\,\\frac{du}{dx}\\right)\\right|_{x_j} \\approx -\\frac{1}{\\Delta x} \\left[ \\left(D\\frac{du}{dx}\\right)_{j+\\frac{1}{2}} - \\left(D\\frac{du}{dx}\\right)_{j-\\frac{1}{2}} \\right]\n$$\n位于 $x_{j\\pm\\frac{1}{2}} = (j\\pm\\frac{1}{2})\\Delta x$ 的单元面上的通量也通过中心差分进行近似：\n$$\n\\left(D\\frac{du}{dx}\\right)_{j+\\frac{1}{2}} \\approx D(x_{j+\\frac{1}{2}}) \\frac{u_{j+1} - u_j}{\\Delta x} = D_{j+\\frac{1}{2}} \\frac{u_{j+1} - u_j}{\\Delta x}\n$$\n将这些代入控制方程，并将反应项近似为 $k\\,u_j$，得到内部节点 $j \\in \\{1, \\dots, N-1\\}$ 的离散方程：\n$$\n-\\frac{1}{\\Delta x} \\left( D_{j+\\frac{1}{2}} \\frac{u_{j+1} - u_j}{\\Delta x} - D_{j-\\frac{1}{2}} \\frac{u_j - u_{j-1}}{\\Delta x} \\right) + k\\,u_j = 0\n$$\n两边乘以 $\\Delta x^2$ 并按未知数 $u_j$ 对各项进行分组，我们得到代数模板：\n$$\n-D_{j-\\frac{1}{2}} u_{j-1} + \\left(D_{j-\\frac{1}{2}} + D_{j+\\frac{1}{2}} + k\\,\\Delta x^2\\right)u_j - D_{j+\\frac{1}{2}} u_{j+1} = 0\n$$\n\n### 2. 有限体积法（FV）\nFV 方法首先将控制方程在一个控制体（CV）上积分。对于节点中心格式，节点 $j$ 的控制体是 $[x_{j-\\frac{1}{2}}, x_{j+\\frac{1}{2}}]$，其体积为 $\\Delta x$。\n$$\n\\int_{x_{j-\\frac{1}{2}}}^{x_{j+\\frac{1}{2}}} \\left( - \\frac{d}{dx}\\left(D\\,\\frac{du}{dx}\\right) + k\\,u \\right) dx = 0\n$$\n对散度项应用微积分基本定理，得到控制体面上的通量平衡：\n$$\n- \\left[ D\\,\\frac{du}{dx} \\right]_{x_{j-\\frac{1}{2}}}^{x_{j+\\frac{1}{2}}} + \\int_{x_{j-\\frac{1}{2}}}^{x_{j+\\frac{1}{2}}} k\\,u(x) dx = 0\n$$\n$$\n\\left(D\\,\\frac{du}{dx}\\right)_{j-\\frac{1}{2}} - \\left(D\\,\\frac{du}{dx}\\right)_{j+\\frac{1}{2}} + \\int_{x_{j-\\frac{1}{2}}}^{x_{j+\\frac{1}{2}}} k\\,u(x) dx = 0\n$$\n使用指定的两点通量近似（这与 FD 格式中使用的相同），并将源项积分近似为 $k\\,u_j\\,\\Delta x$，我们得到：\n$$\nD_{j-\\frac{1}{2}} \\frac{u_j - u_{j-1}}{\\Delta x} - D_{j+\\frac{1}{2}} \\frac{u_{j+1} - u_j}{\\Delta x} + k\\,u_j\\,\\Delta x = 0\n$$\n两边乘以 $\\Delta x$ 表明该方程在代数上与 FD 方程相同。因此，对于指定的近似方法，FD 和 FV 方法产生相同的线性系统。\n\n### 3. 有限元法（FE）\nFE 方法基于问题的弱形式。我们寻求一个近似解 $u_h(x) = \\sum_{j=0}^{N} u_j \\phi_j(x)$，其中 $\\phi_j(x)$是一组分段线性的“帽”函数基。伽辽金法（Galerkin method）要求残差与每个内部节点 $i=1, \\dots, N-1$ 的基函数 $\\phi_i(x)$ 正交。\n$$\n\\int_0^1 \\left( - \\frac{d}{dx}\\left(D\\frac{du_h}{dx}\\right) + k\\,u_h \\right) \\phi_i(x) dx = 0\n$$\n对扩散项进行分部积分得到：\n$$\n\\int_0^1 D(x)\\,\\frac{du_h}{dx}\\frac{d\\phi_i}{dx} dx + \\int_0^1 k\\,u_h(x)\\,\\phi_i(x) dx = \\left[-D\\frac{du_h}{dx}\\phi_i\\right]_0^1\n$$\n由于内部节点的 $\\phi_i(0)=\\phi_i(1)=0$，边界项消失。代入 $u_h$ 得到一个线性系统 $(S+M)\\mathbf{u} = \\mathbf{f}$，其中 $S$ 是刚度矩阵，$M$ 是质量矩阵。\n这些项是逐单元组装的。对于一个跨越 $[x_e, x_{e+1}]$ 的单元 $e$，其扩散系数为常数 $D_e = D(x_{e+\\frac{1}{2}})$，单元刚度矩阵 $S^e$ 和一致质量矩阵 $M^e$ 分别为：\n$$\nS^e = \\frac{D_e}{\\Delta x} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}, \\quad M^e = k \\frac{\\Delta x}{6} \\begin{pmatrix} 2 & 1 \\\\ 1 & 2 \\end{pmatrix}\n$$\n内部节点 $i$ 的方程由单元 $i-1$ 和单元 $i$ 的贡献组装而成。这产生了代数模板：\n$$\n\\left(-\\frac{D_{i-\\frac{1}{2}}}{\\Delta x} + k\\frac{\\Delta x}{6}\\right)u_{i-1} + \\left(\\frac{D_{i-\\frac{1}{2}} + D_{i+\\frac{1}{2}}}{\\Delta x} + k\\frac{2\\Delta x}{3}\\right)u_i + \\left(-\\frac{D_{i+\\frac{1}{2}}}{\\Delta x} + k\\frac{\\Delta x}{6}\\right)u_{i+1} = 0\n$$\n\n### 线性系统和边界条件\n对于每种方法，都为内部未知数向量 $\\mathbf{u}_{\\text{int}} = [u_1, \\dots, u_{N-1}]^T$ 构建一个三对角线性系统 $A\\mathbf{u}_{\\text{int}} = \\mathbf{b}$。通过修改第一个和最后一个方程来强行施加狄利克雷条件。\n对于 $j=1$（第一个内部节点），涉及已知值 $u_0=1$ 的项被移到右侧。\n- 对于 FD/FV：第一个方程的右侧（RHS）变为 $b_1 = D_{1/2} u_0 = D_{1/2}$。\n- 对于 FE：右侧（RHS）变为 $b_1 = -(-\\frac{D_{1/2}}{\\Delta x} + k\\frac{\\Delta x}{6})u_0 = \\frac{D_{1/2}}{\\Delta x} - k\\frac{\\Delta x}{6}$。\n对于 $j=N-1$（最后一个内部节点），涉及 $u_N=0$ 的项直接为零，对系统没有贡献。\n\n### 离散极值原理（DMP）\n连续问题满足极值原理：对于 $k \\ge 0$，解 $u(x)$ 必须位于边界值的极值之间，即 $u(x) \\in [0,1]$。如果一个数值格式的离散解也遵守这些界限，则称该格式满足 DMP。如果系统矩阵 $A$ 是一个 M-矩阵，则可以保证这一点，这要求（除其他性质外）非对角元素为非正值（对于 $i \\ne j$，$A_{ij} \\le 0$）且对角元素为正值（$A_{ii} > 0$）。\n- FD/FV 矩阵的非对角项（缩放前）形如 $-D_{j\\pm\\frac{1}{2}}$，由于 $D>0$，这些项总是非正的。因此，FD/FV 将满足 DMP。\n- 然而，FE 矩阵的非对角项形如 $-\\frac{D}{\\Delta x} + k\\frac{\\Delta x}{6}$。如果反应项很大，此项可能变为正值。具体来说，如果 $k\\frac{\\Delta x^2}{6D} > 1$，M-矩阵的性质就会丧失，可能会出现非物理振荡（过冲或下冲），从而违反 DMP。这是在反应主导区域中使用一致质量矩阵格式的一个已知问题。\n\n该实现将为每个测试用例构建并求解这些系统，并验证每个所得解向量是否满足 DMP。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and generate the final output.\n    \"\"\"\n\n    def check_dmp(u_interior):\n        \"\"\"\n        Checks if the discrete solution satisfies the Discrete Maximum Principle.\n        For an empty set of interior nodes, it is trivially satisfied.\n        \"\"\"\n        epsilon = 1e-12\n        if u_interior.size == 0:\n            return True\n        min_u = np.min(u_interior)\n        max_u = np.max(u_interior)\n        return min_u >= -epsilon and max_u = 1.0 + epsilon\n\n    def solve_fd_fv(N, k, D_func):\n        \"\"\"\n        Solves the reaction-diffusion equation using the Finite Difference /\n        Finite Volume method. The two are algebraically identical for this problem.\n        \"\"\"\n        if N = 1:\n            return np.array([])\n            \n        num_interior = N - 1\n        dx = 1.0 / N\n        u0, uN = 1.0, 0.0\n\n        A = np.zeros((num_interior, num_interior))\n        b = np.zeros(num_interior)\n\n        for i in range(num_interior):\n            j = i + 1  # Node index\n            \n            # Diffusion coefficients at cell faces\n            D_minus = D_func((j - 0.5) * dx)\n            D_plus = D_func((j + 0.5) * dx)\n\n            # Diagonal entry\n            A[i, i] = D_minus + D_plus + k * dx**2\n            \n            # Off-diagonal entries\n            if i > 0:\n                A[i, i - 1] = -D_minus\n            if i  num_interior - 1:\n                A[i, i + 1] = -D_plus\n\n            # Boundary conditions\n            if j == 1:\n                b[i] += D_minus * u0\n            # if j == N - 1, uN term is zero\n\n        u_interior = np.linalg.solve(A, b)\n        return u_interior\n\n    def solve_fe(N, k, D_func):\n        \"\"\"\n        Solves the reaction-diffusion equation using the Finite Element method\n        with linear basis functions and a consistent mass matrix.\n        \"\"\"\n        if N = 1:\n            return np.array([])\n            \n        num_interior = N - 1\n        dx = 1.0 / N\n        u0, uN = 1.0, 0.0\n\n        A = np.zeros((num_interior, num_interior))\n        b = np.zeros(num_interior)\n\n        for i in range(num_interior):\n            j = i + 1  # Node index\n            \n            # Diffusion coefficients (constant per element)\n            D_left_elem = D_func((j - 0.5) * dx) # For element j-1\n            D_right_elem = D_func((j + 0.5) * dx) # For element j\n            \n            # Stiffness part\n            stiff_diag = (D_left_elem + D_right_elem) / dx\n            stiff_off_diag_left = -D_left_elem / dx\n            stiff_off_diag_right = -D_right_elem / dx\n\n            # Mass part (consistent)\n            mass_diag = k * 2.0 * dx / 3.0\n            mass_off_diag = k * dx / 6.0\n\n            # Assemble matrix A\n            A[i, i] = stiff_diag + mass_diag\n            if i > 0:\n                A[i, i - 1] = stiff_off_diag_left + mass_off_diag\n            if i  num_interior - 1:\n                A[i, i + 1] = stiff_off_diag_right + mass_off_diag\n\n            # Assemble RHS vector b with boundary conditions\n            if j == 1:\n                # Contribution from u0=1 term\n                b[i] += -(stiff_off_diag_left + mass_off_diag) * u0\n            # if j == N - 1, uN term is zero\n\n        u_interior = np.linalg.solve(A, b)\n        return u_interior\n\n    test_cases = [\n        # Case 1 (happy path, diffusion only)\n        (50, 0.0, lambda x: 1.0),\n        # Case 2 (reaction-dominated, coarse mesh)\n        (10, 5000.0, lambda x: 1.0),\n        # Case 3 (diffusion-dominated)\n        (50, 1.0, lambda x: 10.0),\n        # Case 4 (strong diffusion jump with reaction)\n        (20, 100.0, lambda x: 1.0 if x  0.3 else 0.01),\n        # Case 5 (boundary-dominated coarse grid)\n        (3, 0.0, lambda x: 1.0),\n    ]\n\n    all_results = []\n    for N, k, D_func in test_cases:\n        # Solve using each method\n        u_fd = solve_fd_fv(N, k, D_func)\n        u_fv = u_fd  # As derived, FD and FV are identical for this problem setup\n        u_fe = solve_fe(N, k, D_func)\n\n        # Check Discrete Maximum Principle for each solution\n        dmp_results = [\n            check_dmp(u_fd),\n            check_dmp(u_fv),\n            check_dmp(u_fe)\n        ]\n        all_results.append(dmp_results)\n\n    # Format the output as specified\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "模拟的准确性和物理真实性在很大程度上取决于边界条件的正确实施。本练习聚焦于应用广泛的有限体积法，并着手处理罗宾（或混合）边界条件的实现，该边界条件用于模拟如壁面处的对流热损失等现象。通过从能量守恒的基本原理出发，您将推导出一个自洽的边界热通量表达式，这对于任何计算传热学 (CHT) 或计算流体动力学 (CFD) 的实际应用都是一项至关重要的技能。",
            "id": "4020935",
            "problem": "考虑一个计算燃烧学中的一维边界邻近控制体，其中对壁面附近的固体或静态气体内的导热过程进行建模。您需要为一个边界面上的热损失实现罗宾（混合）边界条件，其表达式为 $-\\lambda \\, \\partial_n T = h \\, (T - T_\\infty)$，其中 $\\lambda$ 是热导率，$h$ 是传热系数，$T$ 是在边界上求得的温度，$T_\\infty$ 是环境温度。向外的单位法向量 $\\mathbf{n}$ 从控制体内部指向环境。目标是使用有限体积法（FVM）计算基于面的能量平衡贡献项，并确保其与能量守恒和傅里叶导热定律一致。\n\n您的推导和实现必须严格基于以下基本定律和定义：\n- 控制体的能量守恒：通过控制面的净向外热通量等于该控制体因边界传导而产生的能量损失率。\n- 傅里叶导热定律：法向导热热通量为 $q_n = -\\lambda \\, \\partial_n T$。\n- 牛顿冷却定律（罗宾边界条件形式）：在边界面上，$q_n = h \\, (T_b - T_\\infty)$，其中 $T_b$ 是界面上的边界温度。\n\n假设边界面为面积为 $A$ 的平面，且其上的属性是均匀的。使用基于网格中心温度 $T_p$ 和边界温度 $T_b$ 的线性单边有限体积重构，来近似计算垂直于边界的温度梯度，其中网格中心与边界面之间的距离为 $d$。您的任务是推导一个一致的、可包含在网格能量平衡中的基于面的热流表达式，并用代码实现它。\n\n您的程序必须为每个测试用例计算标量 $Q_{\\text{face,out}}$（单位为瓦特，$\\mathrm{W}$），该值定义为通过边界面的向外热流：$Q_{\\text{face,out}} = q_n \\, A$。符号约定为：正值对应于能量通过边界离开网格。\n\n使用以下参数集测试套件 $(\\lambda, h, d, A, T_p, T_\\infty)$，所有参数均采用国际单位制（SI）单位：热导率 $\\lambda$ 单位为 $\\mathrm{W}/(\\mathrm{m}\\cdot \\mathrm{K})$，传热系数 $h$ 单位为 $\\mathrm{W}/(\\mathrm{m}^2\\cdot \\mathrm{K})$，距离 $d$ 单位为 $\\mathrm{m}$，面积 $A$ 单位为 $\\mathrm{m}^2$，温度 $T_p$ 和 $T_\\infty$ 单位为 $\\mathrm{K}$。\n\n- 案例 1：$(\\lambda, h, d, A, T_p, T_\\infty) = (0.08, 25.0, 0.005, 0.01, 1200.0, 300.0)$。\n- 案例 2：$(\\lambda, h, d, A, T_p, T_\\infty) = (0.08, 0.0, 0.005, 0.01, 800.0, 300.0)$。\n- 案例 3：$(\\lambda, h, d, A, T_p, T_\\infty) = (0.08, 100000.0, 0.005, 0.01, 800.0, 300.0)$。\n- 案例 4：$(\\lambda, h, d, A, T_p, T_\\infty) = (10.0, 100.0, 0.0001, 0.02, 400.0, 350.0)$。\n- 案例 5：$(\\lambda, h, d, A, T_p, T_\\infty) = (0.2, 50.0, 0.5, 0.05, 450.0, 300.0)$。\n- 案例 6：$(\\lambda, h, d, A, T_p, T_\\infty) = (0.000001, 100.0, 0.01, 0.01, 600.0, 300.0)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $[r_1,r_2,\\dots,r_6]$，其中每个 $r_i$ 是一个浮点数，代表案例 $i$ 的 $Q_{\\text{face,out}}$（单位为 $\\mathrm{W}$），并遵循上述符号约定。不应打印任何其他文本。",
            "solution": "该问题是有效的。它在科学上基于传热学原理，在数学上是适定的，并且为获得唯一解提供了所有必要的参数。推导和实现过程如下。\n\n目标是确定通过控制体边界面的向外热流 $Q_{\\text{face,out}}$。这个量是网格离散能量守恒方程中的一个源项。我们已知网格中心温度 $T_p$、环境温度 $T_\\infty$、材料的热导率 $\\lambda$、对流传热系数 $h$、面的面积 $A$ 以及从网格中心到面的法向距离 $d$。\n\n推导基于三个物理和数值原理：\n1.  **傅里叶导热定律**：从控制体内部传导到边界面的热通量 $q_n$ 由下式给出：\n    $$ q_n = -\\lambda \\, \\partial_n T $$\n    其中 $\\partial_n T$ 是在面上求值的、垂直于面的温度梯度。问题指定了使用网格中心温度 $T_p$ 和未知的边界面温度 $T_b$ 对该梯度进行单边线性近似，两者相距为 $d$。\n    $$ \\partial_n T \\approx \\frac{T_b - T_p}{d} $$\n    将此近似代入傅里叶定律，得到从网格内部到边界的导热通量：\n    $$ q_{\\text{n,cond}} = -\\lambda \\left( \\frac{T_b - T_p}{d} \\right) = \\frac{\\lambda}{d} (T_p - T_b) $$\n\n2.  **牛顿冷却定律**：从温度为 $T_b$ 的边界面到温度为 $T_\\infty$ 的周围环境的热通量由罗宾边界条件给出：\n    $$ q_{\\text{n,conv}} = h (T_b - T_\\infty) $$\n\n3.  **边界面上的能量守恒**：在稳态下，从内部传导到面的热量必须等于从面对流到环境的热量。这确保了跨边界的热通量是连续的。因此，我们可以令这两个通量表达式相等：\n    $$ q_n = q_{\\text{n,cond}} = q_{\\text{n,conv}} $$\n    $$ \\frac{\\lambda}{d} (T_p - T_b) = h (T_b - T_\\infty) $$\n\n上述方程包含未知的边界温度 $T_b$。为了推导出一个可用的通量源项表达式，我们必须首先用已知量来求解 $T_b$。\n重新整理方程以分离出 $T_b$：\n$$ \\frac{\\lambda}{d} T_p + h T_\\infty = T_b \\left( h + \\frac{\\lambda}{d} \\right) $$\n$$ T_b = \\frac{\\frac{\\lambda}{d} T_p + h T_\\infty}{h + \\frac{\\lambda}{d}} $$\n该表达式表明，边界温度 $T_b$ 是内部温度 $T_p$ 和外部环境温度 $T_\\infty$ 的加权平均值。权重由导热热阻与对流热阻之比确定。\n\n现在，我们将 $T_b$ 的表达式代回到其中一个通量方程中。使用对流通量方程 $q_n = h (T_b - T_\\infty)$ 在代数上更为直接：\n$$ q_n = h \\left( \\left[ \\frac{\\frac{\\lambda}{d} T_p + h T_\\infty}{h + \\frac{\\lambda}{d}} \\right] - T_\\infty \\right) $$\n为简化起见，我们对括号内的项进行通分：\n$$ q_n = h \\left( \\frac{\\frac{\\lambda}{d} T_p + h T_\\infty - T_\\infty \\left(h + \\frac{\\lambda}{d}\\right)}{h + \\frac{\\lambda}{d}} \\right) $$\n$$ q_n = h \\left( \\frac{\\frac{\\lambda}{d} T_p + h T_\\infty - h T_\\infty - \\frac{\\lambda}{d} T_\\infty}{h + \\frac{\\lambda}{d}} \\right) $$\n$$ q_n = h \\left( \\frac{\\frac{\\lambda}{d} (T_p - T_\\infty)}{h + \\frac{\\lambda}{d}} \\right) $$\n将组合系数的分子和分母同乘以 $d$，可得到一个更简洁的形式：\n$$ q_n = \\frac{h \\lambda}{h d + \\lambda} (T_p - T_\\infty) $$\n这个法向热通量 $q_n$ 的表达式仅依赖于已知参数。\n\n最后，通过面的总向外热流 $Q_{\\text{face,out}}$ 是热通量乘以面的面积 $A$：\n$$ Q_{\\text{face,out}} = q_n A = \\left( \\frac{h \\lambda}{h d + \\lambda} \\right) A (T_p - T_\\infty) $$\n这就是要实现的最终方程。符号约定与问题陈述一致：如果 $T_p  T_\\infty$，热量流出该区域，$Q_{\\text{face,out}}$ 为正。\n\n我们可以检验两种极限情况来验证该公式的正确性：\n-   **绝热边界 ($h \\to 0$)**：公式变为 $Q_{\\text{face,out}} = \\left( \\frac{0 \\cdot \\lambda}{0 \\cdot d + \\lambda} \\right) A (T_p - T_\\infty) = 0$，这正确地表示了一个零热通量的绝热表面。\n-   **狄利克雷边界 ($h \\to \\infty$)**：公式可重写为 $Q_{\\text{face,out}} = \\left( \\frac{\\lambda}{d + \\lambda/h} \\right) A (T_p - T_\\infty)$。当 $h \\to \\infty$ 时，项 $\\lambda/h \\to 0$，表达式趋近于 $Q_{\\text{face,out}} \\to \\frac{\\lambda}{d} A (T_p - T_\\infty)$。这对应于固定边界温度 $T_b=T_\\infty$ 时导热热通量的标准有限体积近似。\n\n对于所有非负的输入 $\\lambda$ 和 $h$，推导出的公式在物理上是一致且鲁棒的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the outward heat flow through a boundary face for several test cases,\n    based on a Finite Volume Method implementation of a Robin boundary condition.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (lambda, h, d, A, T_p, T_infinity) in SI units.\n    # lambda: thermal conductivity [W/(m.K)]\n    # h: heat transfer coefficient [W/(m^2.K)]\n    # d: distance from cell center to boundary [m]\n    # A: area of the boundary face [m^2]\n    # T_p: cell-center temperature [K]\n    # T_infinity: ambient temperature [K]\n    test_cases = [\n        (0.08, 25.0, 0.005, 0.01, 1200.0, 300.0),\n        (0.08, 0.0, 0.005, 0.01, 800.0, 300.0),\n        (0.08, 100000.0, 0.005, 0.01, 800.0, 300.0),\n        (10.0, 100.0, 0.0001, 0.02, 400.0, 350.0),\n        (0.2, 50.0, 0.5, 0.05, 450.0, 300.0),\n        (0.000001, 100.0, 0.01, 0.01, 600.0, 300.0)\n    ]\n\n    results = []\n    for case in test_cases:\n        lambda_val, h, d, A, T_p, T_infinity = case\n\n        # The derived formula for the outward heat flow Q_face_out is:\n        # Q_face_out = (h * lambda / (h * d + lambda)) * A * (T_p - T_infinity)\n        \n        # This formula handles the h=0 (adiabatic) and lambda=0 (perfectly insulating)\n        # cases correctly, resulting in a flux of 0.\n        # If both h and lambda are zero, the physical result is 0 flux. The formula\n        # would lead to 0/0, so we handle that case explicitly for robustness,\n        # though it is not present in the test suite.\n        if h == 0.0 and lambda_val == 0.0:\n            q_face_out = 0.0\n        else:\n            # Numerator of the coefficient\n            num_coeff = h * lambda_val\n            # Denominator of the coefficient\n            den_coeff = h * d + lambda_val\n            \n            # Temperature difference driving the heat transfer\n            delta_T = T_p - T_infinity\n            \n            # Handle case where denominator is zero (only if h=0 and lambda=0, already checked)\n            if den_coeff == 0.0:\n                 q_face_out = 0.0\n            else:\n                q_face_out = (num_coeff / den_coeff) * A * delta_T\n\n        results.append(q_face_out)\n\n    # Format the final output string exactly as required.\n    # The map(str, results) converts each float in the list to its string representation.\n    # The ','.join(...) concatenates these strings with a comma.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "计算科学中的一项基本任务是确保代码没有错误，并且正确地实现了预期的数学模型。本练习将向您介绍人造解方法 (Method of Manufactured Solutions, MMS)，这是一种严谨且被广泛应用的程序验证技术。您将为一个模型问题构建一个精确解，并用它来系统性地测试您的有限差分代码，通过量化计算其收敛阶来验证它是否达到了理论预期。",
            "id": "4020756",
            "problem": "考虑计算燃烧学中的一个稳态一维被动标量对流-扩散-反应模型，该模型定义在域 $[0,1]$ 上，并使用无量纲量。其控制方程为\n$$\n-\\nu \\,\\frac{d^2 u}{dx^2} + a \\,\\frac{du}{dx} + r\\,u = s(x),\n$$\n其中 $u(x)$ 是标量场，$\\nu  0$ 是扩散系数， $a$ 是恒定对流速度， $r \\ge 0$ 是反应速率， $s(x)$ 是一个源项。施加的狄利克雷边界条件为\n$$\nu(0) = u_{\\text{exact}}(0), \\quad u(1) = u_{\\text{exact}}(1).\n$$\n使用人工解法：选择一个光滑的解析函数 $u_{\\text{exact}}(x)$ 并设置\n$$\ns(x) = -\\nu\\,u_{\\text{exact}}''(x) + a\\,u_{\\text{exact}}'(x) + r\\,u_{\\text{exact}}(x)\n$$\n使得 $u_{\\text{exact}}(x)$ 是该连续问题的精确解。使用 $M$ 个均匀分布的网格点（包括边界）对 $[0,1]$ 进行离散化，网格间距为 $h = \\frac{1}{M-1}$。在内部节点处，使用二阶中心有限差分来近似 $\\frac{d^2 u}{dx^2}$ 和 $\\frac{du}{dx}$，组装得到的线性系统，并强施加狄利克雷边界条件。求解该线性系统，以获得网格点上的离散近似解 $u_h$。\n\n计算误差的离散 $L^2$ 范数\n$$\n\\|e\\|_{L^2_h} = \\left(h \\sum_{i=0}^{M-1} \\big(u_h(x_i) - u_{\\text{exact}}(x_i)\\big)^2 \\right)^{1/2}\n$$\n其中 $x_i = i\\,h$。通过逐次将 $h$ 减半进行网格加密研究，以估计观测到的精度阶\n$$\np = \\frac{\\log\\left(\\|e\\|_{L^2_{h_1}} / \\|e\\|_{L^2_{h_2}}\\right)}{\\log\\left(h_1 / h_2\\right)}\n$$\n在每对连续的网格之间。\n\n为以下测试套件实现上述过程。对于每个测试用例，使用指定的系数 $(\\nu,a,r)$、人工解 $u_{\\text{exact}}(x)$ 以及网格尺寸列表 $M$：\n\n测试用例1（一般光滑解，中等对流与反应）：\n- $(\\nu,a,r) = (0.1,\\,0.5,\\,1.0)$,\n- $u_{\\text{exact}}(x) = \\sin(2\\pi x) + x(1-x)$,\n- $M \\in \\{21,\\,41,\\,81,\\,161\\}$。\n\n测试用例2（反应主导情况，指数解）：\n- $(\\nu,a,r) = (0.01,\\,0.1,\\,10.0)$,\n- $u_{\\text{exact}}(x) = e^{x}$,\n- $M \\in \\{21,\\,41,\\,81,\\,161\\}$。\n\n测试用例3（对流主导情况，由反应稳定）：\n- $(\\nu,a,r) = (0.001,\\,1.0,\\,20.0)$,\n- $u_{\\text{exact}}(x) = \\sin(\\pi x)$,\n- $M \\in \\{51,\\,101,\\,201,\\,401\\}$。\n\n所有量均为无量纲，因此不需要物理单位。你的程序必须：\n- 对于每个测试用例，计算每个网格上的离散 $L^2$ 误差 $\\|e\\|_{L^2_h}$，然后计算每对连续网格之间的观测阶 $p$。\n- 将每个测试用例的观测阶聚合为一个浮点数列表，该列表对应于给定的连续 $M$ 值对，顺序与给定顺序相同。\n- 生成单行输出，其中包含所有测试用例的观测阶列表，格式为用方括号括起来的逗号分隔列表，例如\n$$\n[ [p_{1,1},p_{1,2},p_{1,3}], [p_{2,1},p_{2,2},p_{2,3}], [p_{3,1},p_{3,2},p_{3,3}] ].\n$$\n每个 $p$ 都必须以小数（浮点数）形式打印。不得打印任何额外文本。",
            "solution": "推导始于稳态一维被动标量的对流、扩散和反应守恒，其无量纲形式可写为\n$$\n-\\nu \\,\\frac{d^2 u}{dx^2} + a \\,\\frac{du}{dx} + r\\,u = s(x),\n$$\n其中常数 $\\nu  0$、$a$ 和 $r \\ge 0$。人工解法指定一个解析函数 $u_{\\text{exact}}(x)$，并通过将其代入微分算子来定义源项，即\n$$\ns(x) = -\\nu\\,u_{\\text{exact}}''(x) + a\\,u_{\\text{exact}}'(x) + r\\,u_{\\text{exact}}(x).\n$$\n通过这种构造，$u_{\\text{exact}}(x)$ 在给定的边界条件 $u(0)=u_{\\text{exact}}(0)$ 和 $u(1)=u_{\\text{exact}}(1)$ 下，求解了该连续问题。\n\n为离散化该域，选择包括端点在内的 $M$ 个网格点，因此网格间距为 $h = \\frac{1}{M-1}$ 且 $x_i = i\\,h$，其中 $i=0,1,\\dots,M-1$。在索引为 $i$ ($1 \\le i \\le M-2$) 的内部节点处，使用从泰勒展开导出的二阶中心有限差分来近似导数。二阶导数为\n$$\n\\frac{d^2 u}{dx^2}\\bigg|_{x_i} \\approx \\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2} + O(h^2),\n$$\n一阶导数为\n$$\n\\frac{du}{dx}\\bigg|_{x_i} \\approx \\frac{u_{i+1} - u_{i-1}}{2h} + O(h^2).\n$$\n将这些近似代入强形式，得到每个内部节点处的离散方程：\n$$\n-\\nu \\left(\\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2}\\right) + a \\left(\\frac{u_{i+1} - u_{i-1}}{2h}\\right) + r\\,u_i = s(x_i).\n$$\n收集系数，形成一个关于内部未知数 $\\mathbf{u} = [u_1,\\dots,u_{M-2}]^\\top$ 的三对角线性系统 $A \\mathbf{u} = \\mathbf{b}$：\n$$\nA_{i,i} = \\frac{2\\nu}{h^2} + r, \\quad A_{i,i-1} = -\\frac{\\nu}{h^2} - \\frac{a}{2h}, \\quad A_{i,i+1} = -\\frac{\\nu}{h^2} + \\frac{a}{2h}.\n$$\n狄利克雷边界值通过在 $i=1$ 和 $i=M-2$ 处的非对角耦合项进入右端项，具体为\n$$\nb_i = s(x_i) - A_{i,i-1}\\,u_0 \\ \\text{if } i=1, \\quad b_i = s(x_i) - A_{i,i+1}\\,u_{M-1} \\ \\text{if } i=M-2,\n$$\n其他情况下 $b_i = s(x_i)$，其中 $u_0 = u_{\\text{exact}}(0)$ 且 $u_{M-1} = u_{\\text{exact}}(1)$。求解该线性系统可得到内部近似值，并通过在边界处插入狄利克雷值来构造完整网格解 $u_h(x_i)$。\n\n为评估精度，使用离散 $L^2$ 范数作为连续 $L^2$ 范数的基于求积的近似，\n$$\n\\|e\\|_{L^2_h} = \\left(h \\sum_{i=0}^{M-1} \\left(u_h(x_i) - u_{\\text{exact}}(x_i)\\right)^2 \\right)^{1/2}.\n$$\n由于狄利克雷边界条件被精确施加，边界处的贡献为零，包含它们不会改变误差范数。对于每次将 $h$ 减半的一系列网格，连续网格之间的观测精度阶计算如下\n$$\np = \\frac{\\log\\left(\\|e\\|_{L^2_{h_1}} / \\|e\\|_{L^2_{h_2}}\\right)}{\\log\\left(h_1 / h_2\\right)}.\n$$\n二阶中心有限差分对一阶和二阶导数均产生 $O(h^2)$ 阶的截断误差，因此在光滑系数和人工精确解的条件下，只要线性系统是良态的，离散格式预计在 $L^2$ 范数下会表现出接近 $p \\approx 2$ 的观测阶。对流-扩散-反应的平衡关系影响系统的条件数；反应项 $r$ 有助于对角占优，而相对于 $\\nu$ 和 $h$ 而言适中的 $a$ 有助于避免中心差分格式的伪振荡。在测试套件中，所选参数确保了在所有加密网格上系统都是可解的。算法流程如下：对于每个测试用例，定义 $u_{\\text{exact}}(x)$ 及其导数 $u_{\\text{exact}}'(x)$ 和 $u_{\\text{exact}}''(x)$；在网格上计算 $s(x)$；组装 $A$ 和 $\\mathbf{b}$；求解 $\\mathbf{u}$；在每个网格上计算 $\\|e\\|_{L^2_h}$；为每对连续网格计算 $p$；并以指定的单行格式输出所有测试用例的观测阶列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_tridiagonal_matrix_and_rhs(M, nu, a, r, u_exact, du_exact, d2u_exact):\n    \"\"\"\n    Build the tridiagonal matrix A and right-hand side b for the interior unknowns\n    using second-order centered finite differences for:\n        -nu * u'' + a * u' + r * u = s(x),\n    with Dirichlet boundary conditions u(0)=u_exact(0), u(1)=u_exact(1).\n    \"\"\"\n    h = 1.0 / (M - 1)\n    x = np.linspace(0.0, 1.0, M)\n\n    # Precompute source term s at interior nodes using manufactured solution\n    s = -nu * d2u_exact(x) + a * du_exact(x) + r * u_exact(x)\n\n    n_interior = M - 2\n    A = np.zeros((n_interior, n_interior))\n    b = np.zeros(n_interior)\n\n    # Coefficients for tridiagonal stencil\n    diag = 2.0 * nu / (h**2) + r\n    off_left = -nu / (h**2) - a / (2.0 * h)\n    off_right = -nu / (h**2) + a / (2.0 * h)\n\n    u0 = u_exact(0.0)\n    uN = u_exact(1.0)\n\n    for i in range(n_interior):\n        # Global index of the interior node\n        gi = i + 1\n        # Fill diagonal\n        A[i, i] = diag\n        # Left off-diagonal\n        if i - 1 >= 0:\n            A[i, i - 1] = off_left\n        else:\n            # Contribution from boundary u0\n            b[i] -= off_left * u0\n        # Right off-diagonal\n        if i  n_interior - 1:\n            A[i, i + 1] = off_right\n        else:\n            # Contribution from boundary uN\n            b[i] -= off_right * uN\n        # Source term at this node\n        b[i] += s[gi]\n\n    return A, b, x\n\ndef solve_fd(M, nu, a, r, u_exact, du_exact, d2u_exact):\n    \"\"\"\n    Solve the finite difference discretization and return the grid, numerical solution,\n    and L2 error against the manufactured exact solution.\n    \"\"\"\n    A, b, x = build_tridiagonal_matrix_and_rhs(M, nu, a, r, u_exact, du_exact, d2u_exact)\n\n    # Solve for interior unknowns\n    u_interior = np.linalg.solve(A, b)\n\n    # Assemble full solution with Dirichlet boundaries\n    u_h = np.zeros(M)\n    u_h[0] = u_exact(0.0)\n    u_h[-1] = u_exact(1.0)\n    u_h[1:-1] = u_interior\n\n    # Compute discrete L2 error\n    h = 1.0 / (M - 1)\n    u_ex = u_exact(x)\n    err = u_h - u_ex\n    l2_err = np.sqrt(h * np.sum(err**2))\n    return x, u_h, l2_err\n\ndef observed_orders(M_list, nu, a, r, u_exact, du_exact, d2u_exact):\n    \"\"\"\n    Compute observed orders between consecutive grids in M_list.\n    \"\"\"\n    errors = []\n    hs = []\n    for M in M_list:\n        _, _, l2_err = solve_fd(M, nu, a, r, u_exact, du_exact, d2u_exact)\n        h = 1.0 / (M - 1)\n        errors.append(l2_err)\n        hs.append(h)\n\n    orders = []\n    for i in range(len(M_list) - 1):\n        e1 = errors[i]\n        e2 = errors[i + 1]\n        h1 = hs[i]\n        h2 = hs[i + 1]\n        # Guard against any potential divide-by-zero or zero error\n        if e1 > 0 and e2 > 0 and h1 > 0 and h2 > 0:\n            p = np.log(e1 / e2) / np.log(h1 / h2)\n        else:\n            p = float('nan')\n        orders.append(p)\n    return orders\n\n# Manufactured solutions and derivatives\ndef ms1_u(x):\n    return np.sin(2.0 * np.pi * x) + x * (1.0 - x)\n\ndef ms1_du(x):\n    return 2.0 * np.pi * np.cos(2.0 * np.pi * x) + (1.0 - 2.0 * x)\n\ndef ms1_d2u(x):\n    return -(2.0 * np.pi)**2 * np.sin(2.0 * np.pi * x) - 2.0\n\ndef ms2_u(x):\n    return np.exp(x)\n\ndef ms2_du(x):\n    return np.exp(x)\n\ndef ms2_d2u(x):\n    return np.exp(x)\n\ndef ms3_u(x):\n    return np.sin(np.pi * x)\n\ndef ms3_du(x):\n    return np.pi * np.cos(np.pi * x)\n\ndef ms3_d2u(x):\n    return -(np.pi**2) * np.sin(np.pi * x)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"nu\": 0.1,\n            \"a\": 0.5,\n            \"r\": 1.0,\n            \"u\": ms1_u,\n            \"du\": ms1_du,\n            \"d2u\": ms1_d2u,\n            \"M_list\": [21, 41, 81, 161],\n        },\n        # Test case 2\n        {\n            \"nu\": 0.01,\n            \"a\": 0.1,\n            \"r\": 10.0,\n            \"u\": ms2_u,\n            \"du\": ms2_du,\n            \"d2u\": ms2_d2u,\n            \"M_list\": [21, 41, 81, 161],\n        },\n        # Test case 3\n        {\n            \"nu\": 0.001,\n            \"a\": 1.0,\n            \"r\": 20.0,\n            \"u\": ms3_u,\n            \"du\": ms3_du,\n            \"d2u\": ms3_d2u,\n            \"M_list\": [51, 101, 201, 401],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        nu = case[\"nu\"]\n        a = case[\"a\"]\n        r = case[\"r\"]\n        u = case[\"u\"]\n        du = case[\"du\"]\n        d2u = case[\"d2u\"]\n        M_list = case[\"M_list\"]\n\n        orders = observed_orders(M_list, nu, a, r, u, du, d2u)\n        # Round for neat output (not required mathematically, purely formatting)\n        orders_rounded = [float(f\"{p:.6f}\") for p in orders]\n        results.append(orders_rounded)\n\n    # Final print statement in the exact required format.\n    # Construct the single-line output with lists.\n    def list_to_str(lst):\n        return \"[\" + \",\".join(map(str, lst)) + \"]\"\n\n    print(\"[\" + \",\".join(list_to_str(r) for r in results) + \"]\")\n\nsolve()\n```"
        }
    ]
}