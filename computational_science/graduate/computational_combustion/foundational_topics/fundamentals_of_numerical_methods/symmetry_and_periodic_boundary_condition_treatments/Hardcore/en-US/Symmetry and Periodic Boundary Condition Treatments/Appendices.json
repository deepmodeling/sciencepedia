{
    "hands_on_practices": [
        {
            "introduction": "This first exercise goes to the heart of implementing periodic boundary conditions: correctly discretizing spatial derivatives. You will derive and implement a finite-difference stencil for the Laplacian operator on a non-uniform, periodic grid. This practice is crucial for accurately modeling diffusive processes in combustion and demonstrates how to maintain numerical accuracy and respect the domain's symmetry at the implementation level .",
            "id": "4070015",
            "problem": "Consider the one-dimensional Laplacian operator, which in this setting reduces to the second derivative, acting on a smooth scalar field $u(x)$ defined on a periodic domain $[0,L]$ with period $L$. In computational combustion, diffusion operators are discretized using finite differences and require careful treatment of symmetry and periodic boundary conditions. On a grid with $N$ nodes that is nonuniform but periodic, the wrap-around (periodic) boundary condition must be enforced so that the discrete stencil at the endpoints uses neighbors across the periodic boundary, preserving discrete translational symmetry of the periodic domain.\n\nStarting from first principles, use the Taylor series of $u(x)$ about $x_i$ to construct a three-point, centered finite-difference approximation to the second derivative $u''(x_i)$ on a nonuniform grid with local spacings $h_{i-1}=x_i-x_{i-1}$ and $h_i=x_{i+1}-x_i$, where indices are taken modulo $N$ to enforce periodicity. The construction must be derived by matching Taylor series coefficients (i.e., by solving for stencil weights so that the approximation is exact for polynomials up to quadratic order). Use the result to obtain a second-order accurate discrete Laplacian on a smoothly varying nonuniform periodic grid. All angles must be measured in radians. The domain length $L$ is dimensionless in this problem.\n\nYou must write a complete program that:\n- Builds a smoothly varying nonuniform periodic grid by mapping a uniform computational grid $\\xi_j = j\\,L/N$, for $j\\in\\{0,1,\\dots,N-1\\}$, to physical space via a smooth, monotone mapping $x(\\xi) = \\xi + \\varepsilon \\,\\frac{L}{2\\pi}\\,\\sin\\!\\left(\\frac{2\\pi \\xi}{L}\\right)$, with a given distortion parameter $\\varepsilon \\in (0,1)$, so that $x(0)=0$ and $x(L)=L$.\n- Enforces periodic wrap-around for the discrete stencil by defining $h_{i-1}$ and $h_i$ using modular indexing and distances across the periodic boundary: for $i=0$, the backward spacing is $h_{-1} = x_0 - x_{N-1} + L$, and for $i=N-1$, the forward spacing is $h_{N-1} = (x_0 + L) - x_{N-1}$.\n- Applies the resulting discrete Laplacian to a smooth periodic test function\n  $$\n  u(x) = \\sin\\!\\left(\\frac{2\\pi m x}{L}\\right) + 0.1\\,\\cos\\!\\left(\\frac{4\\pi m x}{L}\\right),\n  $$\n  where $m$ is a positive integer, and compares it pointwise to the exact second derivative\n  $$\n  u''(x) = -\\left(\\frac{2\\pi m}{L}\\right)^2 \\sin\\!\\left(\\frac{2\\pi m x}{L}\\right) - 0.1\\left(\\frac{4\\pi m}{L}\\right)^2 \\cos\\!\\left(\\frac{4\\pi m x}{L}\\right).\n  $$\n- Computes the maximum-norm error (the discrete $\\ell_\\infty$ norm) defined as\n  $$\n  E_\\infty(N) = \\max_{0\\le i \\le N-1} \\left| (\\Delta_h u)_i - u''(x_i) \\right|,\n  $$\n  where $(\\Delta_h u)_i$ denotes your discrete Laplacian at node $i$.\n- Demonstrates second-order accuracy by computing the observed convergence orders\n  $$\n  p_{N\\to 2N} = \\frac{\\log\\!\\left( E_\\infty(N) / E_\\infty(2N) \\right)}{\\log(2)}.\n  $$\n\nDesign your program to run the following test suite:\n- Test case A: $L=1.0$, $m=3$, $\\varepsilon=0.3$, $N=32$.\n- Test case B: $L=1.0$, $m=3$, $\\varepsilon=0.3$, $N=64$.\n- Test case C: $L=1.0$, $m=3$, $\\varepsilon=0.3$, $N=128$.\n- Symmetry test D (discrete translational invariance under periodic wrap-around): with $L=1.0$, $\\varepsilon=0.3$, $m=3$, $N=37$, construct the grid and data as above, compute the discrete Laplacian on $(x,u(x))$, then cyclically shift indices by $s=7$ to obtain $(\\tilde{x}, u(\\tilde{x}))$, recompute the discrete Laplacian on the shifted pair, and verify that the shifted result matches the original to within a tight tolerance in the maximum norm. Report a boolean that is true if the maximum absolute difference is less than $10^{-10}$ and false otherwise.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order:\n- The observed order $p_{32\\to 64}$ from Test cases A and B, rounded to three decimal places.\n- The observed order $p_{64\\to 128}$ from Test cases B and C, rounded to three decimal places.\n- The boolean result of the symmetry test D.\n\nFor example, the required format is of the form\n\"[p32_64,p64_128,flagD]\"\nwhere $p32\\_64$ and $p64\\_128$ are floats rounded to three decimal places, and $flagD$ is either True or False.\n\nAngles must be in radians; there are no physical units to report in this problem, and all dimensionful constants are treated as dimensionless.\n\nThe final program must be complete and runnable with no user input and no external files. The only allowed libraries are the Python standard library and the specified numerical libraries. The output must be exactly one line in the specified format.",
            "solution": "The user wants me to solve a computational problem.\n\n### Step 1: Extract Givens\n- **Operator**: One-dimensional Laplacian, $\\frac{d^2}{dx^2}$, acting on a scalar field $u(x)$.\n- **Domain**: Periodic, $[0,L]$, with period $L$.\n- **Grid**: $N$ nodes, nonuniform but periodic.\n- **Indices**: Taken modulo $N$ to enforce periodicity.\n- **Local Spacings**: $h_{i-1}=x_i-x_{i-1}$ and $h_i=x_{i+1}-x_i$.\n- **Approximation**: Three-point, centered finite-difference for $u''(x_i)$.\n- **Derivation Method**: Matching Taylor series coefficients to be exact for polynomials up to quadratic order.\n- **Grid Generation**:\n    - Uniform grid: $\\xi_j = j\\,L/N$, for $j\\in\\{0,1,\\dots,N-1\\}$.\n    - Mapping: $x(\\xi) = \\xi + \\varepsilon \\,\\frac{L}{2\\pi}\\,\\sin\\!\\left(\\frac{2\\pi \\xi}{L}\\right)$.\n    - Distortion parameter: $\\varepsilon \\in (0,1)$.\n- **Periodic Boundary Conditions for Spacings**:\n    - For $i=0$: $h_{-1} = x_0 - x_{N-1} + L$.\n    - For $i=N-1$: $h_{N-1} = x_0 - x_{N-1} + L$.\n- **Test Function**: $u(x) = \\sin\\!\\left(\\frac{2\\pi m x}{L}\\right) + 0.1\\,\\cos\\!\\left(\\frac{4\\pi m x}{L}\\right)$, with $m$ a positive integer.\n- **Exact Second Derivative**: $u''(x) = -\\left(\\frac{2\\pi m}{L}\\right)^2 \\sin\\!\\left(\\frac{2\\pi m x}{L}\\right) - 0.1\\left(\\frac{4\\pi m}{L}\\right)^2 \\cos\\!\\left(\\frac{4\\pi m x}{L}\\right)$.\n- **Error Metric**: Maximum-norm error, $E_\\infty(N) = \\max_{0\\le i \\le N-1} \\left| (\\Delta_h u)_i - u''(x_i) \\right|$.\n- **Convergence Order Formula**: $p_{N\\to 2N} = \\frac{\\log\\!\\left( E_\\infty(N) / E_\\infty(2N) \\right)}{\\log(2)}$.\n- **Test Case A**: $L=1.0$, $m=3$, $\\varepsilon=0.3$, $N=32$.\n- **Test Case B**: $L=1.0$, $m=3$, $\\varepsilon=0.3$, $N=64$.\n- **Test Case C**: $L=1.0$, $m=3$, $\\varepsilon=0.3$, $N=128$.\n- **Symmetry Test D**:\n    - Parameters: $L=1.0$, $\\varepsilon=0.3$, $m=3$, $N=37$.\n    - Procedure: Compute Laplacian on $(x, u(x))$, cyclically shift indices by $s=7$ to $(\\tilde{x}, u(\\tilde{x}))$, recompute Laplacian on shifted pair, verify shifted result matches original.\n    - Output: Boolean, `True` if max absolute difference is less than $10^{-10}$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is subjected to validation against the specified criteria.\n- **Scientifically Grounded**: The problem is rooted in fundamental principles of numerical analysis, specifically the derivation and application of finite difference methods using Taylor series analysis. This is a standard and well-established topic in computational science and engineering, including computational combustion. All mathematical formulations are correct. The problem is scientifically sound.\n- **Well-Posed**: The problem is clearly defined with all necessary givens. It requests the derivation of a specific numerical scheme, its implementation, and its evaluation through a prescribed set of test cases. The objectives—calculating convergence orders and testing for discrete symmetry—are unambiguous. A unique and meaningful solution can be determined.\n- **Objective**: The problem is stated in precise, formal language, free of ambiguity, subjectivity, or opinion. All parameters and test procedures are explicitly defined.\n- **Other Flaws**:\n    1.  **Scientific Unsoundness**: None. The mathematics is standard and correct.\n    2.  **Non-Formalizable or Irrelevant**: The problem is highly formalizable and directly relevant to the specified topic of treating diffusion operators with symmetry and periodic boundary conditions in computational fields.\n    3.  **Incomplete or Contradictory Setup**: The setup is complete. All functions, parameters, boundary condition rules, and test cases are provided without contradiction. The definition of $h_{N-1}$ for the stencil at $i=N-1$ is the same as the distance from $x_{N-1}$ to the periodic image of $x_0$, which is consistent.\n    4.  **Unrealistic or Infeasible**: The problem describes a standard numerical experiment. The conditions are computationally feasible and physically plausible as a model problem.\n    5.  **Ill-Posed or Poorly Structured**: The problem is well-structured and leads to a unique, stable solution for each part of the task.\n    6.  **Pseudo-Profound, Trivial, or Tautological**: The problem is a standard but non-trivial exercise in numerical methods, requiring careful derivation and implementation. It tests genuine understanding of finite differences on nonuniform periodic grids.\n    7.  **Outside Scientific Verifiability**: The results are fully verifiable through independent calculation and code execution.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete solution will be provided.\n\n**Derivation of the Finite Difference Scheme**\n\nThe objective is to find a three-point approximation for the second derivative $u''(x_i)$ of the form\n$$(\\Delta_h u)_i = c_{i-1}u(x_{i-1}) + c_i u(x_i) + c_{i+1}u(x_{i+1})$$\non a nonuniform grid. Let the grid spacings be $h_{i-1} = x_i - x_{i-1}$ and $h_i = x_{i+1} - x_i$. We expand $u(x_{i-1})$ and $u(x_{i+1})$ in Taylor series around $x_i$:\n$$u(x_{i-1}) = u(x_i - h_{i-1}) = u(x_i) - h_{i-1}u'(x_i) + \\frac{h_{i-1}^2}{2}u''(x_i) - \\frac{h_{i-1}^3}{6}u'''(x_i) + \\mathcal{O}(h_{i-1}^4)$$\n$$u(x_{i+1}) = u(x_i + h_i) = u(x_i) + h_i u'(x_i) + \\frac{h_i^2}{2}u''(x_i) + \\frac{h_i^3}{6}u'''(x_i) + \\mathcal{O}(h_i^4)$$\nSubstituting these into the stencil expression gives:\n$$(\\Delta_h u)_i = c_{i-1}\\left(u_i - h_{i-1}u'_i + \\frac{h_{i-1}^2}{2}u''_i + \\dots\\right) + c_i u_i + c_{i+1}\\left(u_i + h_i u'_i + \\frac{h_i^2}{2}u''_i + \\dots\\right)$$\nwhere we use the shorthand $u_j^{(k)}$ for $u^{(k)}(x_j)$. Grouping terms by the order of the derivative at $x_i$:\n$$(\\Delta_h u)_i = (c_{i-1} + c_i + c_{i+1})u_i + (-c_{i-1}h_{i-1} + c_{i+1}h_i)u'_i + \\left(c_{i-1}\\frac{h_{i-1}^2}{2} + c_{i+1}\\frac{h_i^2}{2}\\right)u''_i + \\dots$$\nTo have $(\\Delta_h u)_i = u''_i + \\text{error}$, we must match the coefficients of the low-order derivatives. This requires the stencil to be exact for polynomials $p(x) = 1$, $p(x) = x-x_i$, and $p(x) = (x-x_i)^2$, leading to the following system of linear equations for the weights $c_{i-1}$, $c_i$, $c_{i+1}$:\n1.  Coefficient of $u_i$: $c_{i-1} + c_i + c_{i+1} = 0$\n2.  Coefficient of $u'_i$: $-c_{i-1}h_{i-1} + c_{i+1}h_i = 0$\n3.  Coefficient of $u''_i$: $c_{i-1}\\frac{h_{i-1}^2}{2} + c_{i+1}\\frac{h_i^2}{2} = 1$\n\nFrom equation (2), we find $c_{i+1} = c_{i-1} \\frac{h_{i-1}}{h_i}$. Substituting this into equation (3):\n$$c_{i-1}\\frac{h_{i-1}^2}{2} + \\left(c_{i-1} \\frac{h_{i-1}}{h_i}\\right)\\frac{h_i^2}{2} = 1 \\implies c_{i-1}\\left(\\frac{h_{i-1}^2 + h_{i-1}h_i}{2}\\right) = 1$$\nSolving for $c_{i-1}$ yields:\n$$c_{i-1} = \\frac{2}{h_{i-1}(h_{i-1}+h_i)}$$\nThe other weights are then found to be:\n$$c_{i+1} = \\frac{h_{i-1}}{h_i} c_{i-1} = \\frac{h_{i-1}}{h_i} \\frac{2}{h_{i-1}(h_{i-1}+h_i)} = \\frac{2}{h_i(h_{i-1}+h_i)}$$\n$$c_i = -c_{i-1} - c_{i+1} = -\\frac{2}{h_{i-1}(h_{i-1}+h_i)} - \\frac{2}{h_i(h_{i-1}+h_i)} = -\\frac{2(h_i+h_{i-1})}{h_{i-1}h_i(h_{i-1}+h_i)} = -\\frac{2}{h_{i-1}h_i}$$\nThe resulting finite difference approximation is:\n$$(\\Delta_h u)_i = \\frac{2}{h_{i-1}(h_{i-1}+h_i)}u_{i-1} - \\frac{2}{h_{i-1}h_i}u_i + \\frac{2}{h_i(h_{i-1}+h_i)}u_{i+1}$$\nThe leading term of the truncation error is found by examining the coefficient of $u'''_i$, which is $\\frac{1}{3}(h_i - h_{i-1})u'''_i$. For a smoothly varying grid, where the grid point locations $x_j$ are a smooth function of the index $j$, the difference in adjacent spacings $h_i - h_{i-1}$ is proportional to the square of the average spacing, i.e., $\\mathcal{O}(h^2)$. Thus, the leading error term behaves as $\\mathcal{O}(h)$, making the scheme formally first-order. However, the next term in the error expansion is of order $\\mathcal{O}(h^2)$, and it is this term that dominates, yielding second-order accuracy in practice for smooth functions and grids, which is what is to be verified numerically.\n\n**Algorithmic Design**\n\nThe problem is solved by implementing a set of functions to perform the specified tests.\n\n1.  **Grid and Function Generation**: A function creates the nonuniform physical grid $x$ by first defining a uniform computational grid $\\xi_j = jL/N$ for $j \\in \\{0, \\dots, N-1\\}$ and then applying the smooth mapping $x(\\xi) = \\xi + \\varepsilon \\frac{L}{2\\pi}\\sin(2\\pi \\xi/L)$. The test function $u(x)$ and its exact second derivative $u''(x)$ are evaluated on this grid.\n\n2.  **Discrete Laplacian Calculation**: A core function calculates the discrete Laplacian.\n    - It first computes the forward grid spacings $h_i = x_{i+1} - x_i$ for all nodes $i$. To enforce periodicity, indices are treated modulo $N$. For the node $i=N-1$, the next node $i=N$ is equivalent to $i=0$ in the next periodic block, located at $x_0+L$. Thus, the spacing is $h_{N-1} = (x_0+L) - x_{N-1}$. This is handled by first calculating differences between cyclically shifted coordinates and then adding $L$ to the wrap-around element.\n    - Two arrays representing forward spacing ($h_i$) and backward spacing ($h_{i-1}$) for each node are created.\n    - The weights $c_{i-1}$, $c_i$, $c_{i+1}$ are computed for each node $i$ using the derived formulas and the local spacings.\n    - The discrete Laplacian is then computed as a vectorized operation: $(\\Delta_h u)_i = c_{i-1,i}u_{i-1} + c_{i,i}u_i + c_{i+1,i}u_{i+1}$, where periodic shifts are used to access $u_{i-1}$ and $u_{i+1}$.\n\n3.  **Convergence Study**:\n    - The errors $E_\\infty(N)$ are computed for $N=32$, $N=64$, and $N=128$ by finding the maximum absolute difference between the discrete Laplacian $(\\Delta_h u)_i$ and the exact $u''(x_i)$.\n    - The observed convergence orders $p_{32\\to 64}$ and $p_{64\\to 128}$ are calculated using the provided logarithmic formula. The expected value is approximately $2$, confirming second-order accuracy.\n\n4.  **Symmetry Test**:\n    - For $N=37$, the grid $x$, function values $u$, and discrete Laplacian $(\\Delta_h u)_{\\text{orig}}$ are computed.\n    - The grid and function arrays are cyclically shifted by $s=7$: $\\tilde{x}_i = x_{i-s}$ and $\\tilde{u}_i = u_{i-s}$.\n    - The discrete Laplacian is recomputed from scratch using the shifted grid $\\tilde{x}$ and shifted function values $\\tilde{u}$, yielding $(\\Delta_h \\tilde{u})_{\\text{recomp}}$.\n    - The original discrete Laplacian result is also shifted: $((\\Delta_h u)_{\\text{orig}})_{\\text{shifted}, i} = ((\\Delta_h u)_{\\text{orig}})_{i-s}$.\n    - Discrete translational invariance is verified by checking if the maximum absolute difference between $(\\Delta_h \\tilde{u})_{\\text{recomp}}$ and $((\\Delta_h u)_{\\text{orig}})_{\\text{shifted}}$ is below a tight tolerance of $10^{-10}$. This confirms that the operator's implementation respects the periodic symmetry of the discrete domain.\n\nThe final program collates the results from these tests into the specified output format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_discrete_laplacian(x: np.ndarray, u: np.ndarray, L: float) -> np.ndarray:\n    \"\"\"\n    Computes the 3-point finite difference approximation to the second derivative\n    on a nonuniform periodic grid.\n\n    Args:\n        x: The array of grid point coordinates.\n        u: The array of function values at each grid point.\n        L: The period of the domain.\n\n    Returns:\n        The discrete Laplacian of u at each grid point.\n    \"\"\"\n    N = len(x)\n    \n    # Calculate forward spacings h_i = x_{i+1} - x_i with periodic wrap-around\n    h_fwd = np.roll(x, -1) - x\n    # Correct the wrap-around distance for the last element\n    h_fwd[-1] = (x[0] + L) - x[-1]\n\n    # Calculate backward spacings h_{i-1} = x_i - x_{i-1}\n    # This is equivalent to a cyclically shifted version of the forward spacings\n    h_bwd = np.roll(h_fwd, 1)\n\n    # Get function values at neighboring points using periodic roll\n    u_m1 = np.roll(u, 1)   # u_{i-1}\n    u_p1 = np.roll(u, -1)  # u_{i+1}\n\n    # Stencil weights for the approximation at each point i\n    # c_m1 corresponds to u_{i-1}, c_0 to u_i, c_p1 to u_{i+1}\n    c_m1 = 2.0 / (h_bwd * (h_bwd + h_fwd))\n    c_0  = -2.0 / (h_bwd * h_fwd)\n    c_p1 = 2.0 / (h_fwd * (h_bwd + h_fwd))\n\n    # Apply the stencil across all points in a vectorized manner\n    lap_u = c_m1 * u_m1 + c_0 * u + c_p1 * u_p1\n    \n    return lap_u\n\ndef run_convergence_case(L: float, N: int, epsilon: float, m: int):\n    \"\"\"\n    Runs a single case for the convergence study. Generates the grid,\n    computes the discrete and exact Laplacians, and returns the max-norm error\n    and the computed discrete Laplacian.\n\n    Args:\n        L: The period of the domain.\n        N: The number of grid points.\n        epsilon: The grid distortion parameter.\n        m: The wavenumber parameter for the test function.\n\n    Returns:\n        A tuple containing:\n        - The max-norm error.\n        - The computed discrete Laplacian array.\n        - The grid coordinate array.\n        - The test function value array.\n    \"\"\"\n    # 1. Grid Generation\n    xi = np.arange(N) * L / N\n    x = xi + epsilon * (L / (2.0 * np.pi)) * np.sin(2.0 * np.pi * xi / L)\n\n    # 2. Test Function and its Exact Second Derivative\n    u_x = np.sin(2.0 * np.pi * m * x / L) + 0.1 * np.cos(4.0 * np.pi * m * x / L)\n    \n    term1_sin = -((2.0 * np.pi * m / L)**2) * np.sin(2.0 * np.pi * m * x / L)\n    term2_cos = -0.1 * ((4.0 * np.pi * m / L)**2) * np.cos(4.0 * np.pi * m * x / L)\n    u_xx_exact = term1_sin + term2_cos\n\n    # 3. Compute Discrete Laplacian\n    lap_u_discrete = compute_discrete_laplacian(x, u_x, L)\n\n    # 4. Compute Maximum-Norm Error\n    error_inf = np.max(np.abs(lap_u_discrete - u_xx_exact))\n    \n    return error_inf, lap_u_discrete, x, u_x\n\ndef run_symmetry_test(L: float, N: int, epsilon: float, m: int, s: int) -> bool:\n    \"\"\"\n    Performs the discrete translational invariance test.\n\n    Args:\n        L: The period of the domain.\n        N: The number of grid points (must be prime for a good test).\n        epsilon: The grid distortion parameter.\n        m: The wavenumber parameter for the test function.\n        s: The number of indices to shift by.\n\n    Returns:\n        True if the operator is invariant to within a tolerance, False otherwise.\n    \"\"\"\n    # Compute the Laplacian on the original grid and data\n    _, lap_u_orig, x_orig, u_orig = run_convergence_case(L, N, epsilon, m)\n\n    # Cyclically shift the grid and function data\n    x_shifted = np.roll(x_orig, s)\n    u_shifted = np.roll(u_orig, s)\n    \n    # Recompute the Laplacian on the shifted grid/data\n    lap_u_recomputed = compute_discrete_laplacian(x_shifted, u_shifted, L)\n    \n    # Shift the original result for comparison\n    lap_u_orig_shifted = np.roll(lap_u_orig, s)\n\n    # Check for discrete translational invariance\n    diff = np.max(np.abs(lap_u_recomputed - lap_u_orig_shifted))\n    \n    return diff < 1e-10\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    # Test cases defined in the problem\n    test_cases = [\n        # (L, m, epsilon, N)\n        (1.0, 3, 0.3, 32),   # Test case A\n        (1.0, 3, 0.3, 64),   # Test case B\n        (1.0, 3, 0.3, 128),  # Test case C\n    ]\n    \n    # Run convergence study\n    E_32, _, _, _ = run_convergence_case(L=test_cases[0][0], N=test_cases[0][3], epsilon=test_cases[0][2], m=test_cases[0][1])\n    E_64, _, _, _ = run_convergence_case(L=test_cases[1][0], N=test_cases[1][3], epsilon=test_cases[1][2], m=test_cases[1][1])\n    E_128, _, _, _ = run_convergence_case(L=test_cases[2][0], N=test_cases[2][3], epsilon=test_cases[2][2], m=test_cases[2][1])\n\n    # Compute observed orders of convergence\n    p32_64 = np.log(E_32 / E_64) / np.log(2.0)\n    p64_128 = np.log(E_64 / E_128) / np.log(2.0)\n\n    # Run symmetry test D\n    symmetry_test_params = {'L': 1.0, 'epsilon': 0.3, 'm': 3, 'N': 37, 's': 7}\n    sym_flag = run_symmetry_test(**symmetry_test_params)\n    \n    # Format and print the final output\n    print(f\"[{p32_64:.3f},{p64_128:.3f},{sym_flag}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "With the foundation of correct stencil implementation, we now turn to verifying the global properties of the numerical scheme. This practice tasks you with creating a diagnostic tool to detect errors in the mapping of data across periodic boundaries by tracking the conservation of mass and species . This is a vital skill in developing robust computational codes, as failure to conserve quantities can lead to unphysical results.",
            "id": "4069994",
            "problem": "You are tasked with constructing, implementing, and validating a diagnostic for detecting mismatched periodic mapping across paired periodic faces by tracking conservation errors in mass and chemical species over time. The context is computational combustion with periodic boundary condition treatments. All quantities are nondimensional.\n\nFundamental base: Start from the integral conservation laws for total mass and for each chemical species. For a spatial domain $\\Omega$ with boundary $\\partial \\Omega$, density field $\\rho$, velocity field $\\boldsymbol{u}$, and species mass fraction $Y_{s}$ for species index $s$, the integral conservation laws (with zero volumetric sources) are\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t} \\int_{\\Omega} \\rho \\,\\mathrm{d}V \\;=\\; - \\int_{\\partial \\Omega} \\rho \\,\\boldsymbol{u}\\cdot \\boldsymbol{n} \\,\\mathrm{d}S,\n\\qquad\n\\frac{\\mathrm{d}}{\\mathrm{d}t} \\int_{\\Omega} \\rho Y_{s} \\,\\mathrm{d}V \\;=\\; - \\int_{\\partial \\Omega} \\rho Y_{s} \\,\\boldsymbol{u}\\cdot \\boldsymbol{n} \\,\\mathrm{d}S.\n$$\nFor a pair of periodic faces $\\Gamma_{L}$ and $\\Gamma_{R}$ with outward unit normals $\\boldsymbol{n}_{L}$ and $\\boldsymbol{n}_{R}$, a correct periodic mapping $M$ pairs each point on $\\Gamma_{L}$ to a point on $\\Gamma_{R}$ with the property that the pointwise normal fluxes cancel:\n$$\n\\left.\\rho\\,\\boldsymbol{u}\\cdot\\boldsymbol{n}_{L}\\right|_{\\boldsymbol{x}\\in\\Gamma_{L}} \\;+\\; \\left.\\rho\\,\\boldsymbol{u}\\cdot\\boldsymbol{n}_{R}\\right|_{M(\\boldsymbol{x})\\in\\Gamma_{R}} \\;=\\; 0,\n$$\nand similarly for $\\rho Y_{s}$. A mismatched mapping violates this pairwise cancellation even if the global net flux over $\\Gamma_{L}\\cup\\Gamma_{R}$ integrates to zero. Therefore, a robust detection test must evaluate pairwise cancellations rather than only global net flux.\n\nDiscretization and diagnostic to implement: Consider a two-dimensional domain that is periodic in the $x$-direction. Discretize the periodic direction along a uniform set of $N_{y}$ segments of length $\\Delta y$, indexed by $j\\in\\{0,\\dots,N_{y}-1\\}$ with segment centers at $y_{j}=\\left(j+\\tfrac{1}{2}\\right)\\Delta y$, where $\\Delta y = 1/N_{y}$. The left and right periodic faces are $\\Gamma_{L}$ at $x=0$ and $\\Gamma_{R}$ at $x=1$. Assume a constant velocity field $\\boldsymbol{u}=(U,0)$ with $U\\ge 0$, and fields that depend only on $y$: density $\\rho(y)$ and two species mass fractions $Y_{1}(y)$ and $Y_{2}(y)$ satisfying $Y_{1}(y)+Y_{2}(y)=1$. The outward normals satisfy $\\boldsymbol{n}_{L}=(-1,0)$ and $\\boldsymbol{n}_{R}=(+1,0)$. Define the discrete outward normal mass flux densities per segment as\n$$\nf^{\\text{mass}}_{L}(j) \\;=\\; \\rho(y_{j})\\,\\boldsymbol{u}\\cdot \\boldsymbol{n}_{L} \\;=\\; -U\\,\\rho(y_{j}),\\qquad\nf^{\\text{mass}}_{R}(k) \\;=\\; \\rho(y_{k})\\,\\boldsymbol{u}\\cdot \\boldsymbol{n}_{R} \\;=\\; +U\\,\\rho(y_{k}),\n$$\nand for species $s\\in\\{1,2\\}$,\n$$\nf^{(s)}_{L}(j) \\;=\\; -U\\,\\rho(y_{j})\\,Y_{s}(y_{j}),\\qquad f^{(s)}_{R}(k) \\;=\\; +U\\,\\rho(y_{k})\\,Y_{s}(y_{k}).\n$$\nA mapping is represented discretely by an index map $M:\\{0,\\dots,N_{y}-1\\}\\to\\{0,\\dots,N_{y}-1\\}$. For a correct periodic mapping, the pairwise cancellations satisfy $f_{L}(j)+f_{R}(M(j))=0$ for every $j$ and for both mass and each species. To detect mismatches, define the cumulative pairwise conservation error over a time interval $[0,T]$ with a uniform time step $\\Delta t$ and $N_{t}=T/\\Delta t$ steps as\n$$\nE_{\\text{mass}} \\;=\\; \\sum_{n=0}^{N_{t}-1} \\Delta t \\sum_{j=0}^{N_{y}-1} \\left| f^{\\text{mass}}_{L}(j) + f^{\\text{mass}}_{R}(M(j)) \\right|\\,\\Delta y,\n$$\n$$\nE_{s} \\;=\\; \\sum_{n=0}^{N_{t}-1} \\Delta t \\sum_{j=0}^{N_{y}-1} \\left| f^{(s)}_{L}(j) + f^{(s)}_{R}(M(j)) \\right|\\,\\Delta y,\\quad s\\in\\{1,2\\}.\n$$\nWith fields that are steady in time, the errors scale linearly with $T$; for a correct mapping, all errors are exactly zero in exact arithmetic.\n\nYour task: Write a complete, runnable program that implements this diagnostic. Use the following fixed field definitions and test suite, and decide pass/fail for each case by comparing each of $E_{\\text{mass}},E_{1},E_{2}$ to a specified tolerance $\\varepsilon$.\n\nField definitions to use:\n- $N_{y}$ segments with $y_{j}=\\left(j+\\tfrac{1}{2}\\right)/N_{y}$.\n- $\\rho(y) \\;=\\; 1 \\;+\\; 0.2\\,\\sin(2\\pi y) \\;+\\; 0.1\\,\\cos(4\\pi y)$.\n- $Y_{1}(y) \\;=\\; 0.5 \\;+\\; 0.3\\,\\sin(2\\pi y)$, and $Y_{2}(y) \\;=\\; 1 - Y_{1}(y)$.\n\nMapping definition per test case:\n- A mapping offset $s$ specifies $M(j) \\equiv (j+s)\\bmod N_{y}$.\n\nTime integration parameters:\n- Total time $T=1$ and number of time steps $N_{t}=100$, so $\\Delta t = T/N_{t}$.\n\nDecision rule:\n- A case passes if and only if $E_{\\text{mass}}\\le \\varepsilon$ and $E_{1}\\le \\varepsilon$ and $E_{2}\\le \\varepsilon$.\n\nTest suite:\n- Case $1$: $N_{y}=64$, $U=0.5$, $s=0$, $\\varepsilon=10^{-11}$.\n- Case $2$: $N_{y}=64$, $U=0$, $s=13$, $\\varepsilon=10^{-12}$.\n- Case $3$: $N_{y}=64$, $U=0.5$, $s=1$, $\\varepsilon=10^{-6}$.\n- Case $4$: $N_{y}=64$, $U=10^{-8}$, $s=1$, $\\varepsilon=10^{-6}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of Python boolean literals enclosed in square brackets, in the order of the test suite, for example, \"[True,False,True,True]\".",
            "solution": "The problem statement has been validated and is determined to be sound. It is scientifically grounded in the principles of continuum mechanics, specifically integral conservation laws, and presents a well-posed numerical problem relevant to computational combustion. All necessary data, equations, and conditions are provided, allowing for the construction of a unique and verifiable solution.\n\nThe task is to implement a diagnostic tool to detect errors in the periodic mapping of boundary conditions in a numerical simulation. The diagnostic is based on quantifying the local, pairwise conservation error for mass and species mass fractions across two periodic faces.\n\nThe fundamental principle is the integral conservation law for a quantity $\\phi$ within a domain $\\Omega$, which states that the time rate of change of the total amount of $\\phi$ in the volume is equal to the net flux of $\\phi$ across the boundary $\\partial\\Omega$. For density $\\rho$ and species mass fraction $Y_s$, with a velocity field $\\boldsymbol{u}$, and neglecting diffusive transport and source terms, these laws are:\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t} \\int_{\\Omega} \\rho \\,\\mathrm{d}V \\;=\\; - \\int_{\\partial \\Omega} \\rho \\,\\boldsymbol{u}\\cdot \\boldsymbol{n} \\,\\mathrm{d}S\n$$\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t} \\int_{\\Omega} \\rho Y_{s} \\,\\mathrm{d}V \\;=\\; - \\int_{\\partial \\Omega} \\rho Y_{s} \\,\\boldsymbol{u}\\cdot \\boldsymbol{n} \\,\\mathrm{d}S\n$$\nFor a domain with periodic boundaries, say a pair of faces $\\Gamma_{L}$ and $\\Gamma_{R}$, global conservation requires that the total flux into $\\Gamma_{L}$ equals the total flux out of $\\Gamma_{R}$. However, a correct numerical implementation requires a stronger, pointwise condition. If $M$ is the mapping that pairs a point $\\boldsymbol{x} \\in \\Gamma_{L}$ with a point $M(\\boldsymbol{x}) \\in \\Gamma_{R}$, then the local fluxes must cancel. With outward normals $\\boldsymbol{n}_{L}$ and $\\boldsymbol{n}_{R}$, this means the convective flux densities must satisfy:\n$$\n\\left(\\rho\\,\\boldsymbol{u}\\cdot\\boldsymbol{n}_{L}\\right)\\big|_{\\boldsymbol{x}} \\;+\\; \\left(\\rho\\,\\boldsymbol{u}\\cdot\\boldsymbol{n}_{R}\\right)\\big|_{M(\\boldsymbol{x})} \\;=\\; 0\n$$\nA mismatched mapping $M$ will violate this local cancellation, leading to numerical errors. The proposed diagnostic quantifies this violation.\n\nThe problem simplifies this to a two-dimensional domain, periodic in the $x$-direction between $x=0$ ($\\Gamma_{L}$) and $x=1$ ($\\Gamma_{R}$). The faces are discretized into $N_y$ segments of length $\\Delta y = 1/N_y$. The segment centers are $y_j = (j+1/2)\\Delta y$ for $j \\in \\{0, \\dots, N_y-1\\}$. The velocity is constant, $\\boldsymbol{u}=(U,0)$, and the fields $\\rho(y)$ and $Y_s(y)$ depend only on $y$. The outward normals are $\\boldsymbol{n}_{L}=(-1,0)$ and $\\boldsymbol{n}_{R}=(+1,0)$.\n\nThe discrete outward normal mass flux densities for a segment $j$ on the left face and a segment $k$ on the right face are:\n$$\nf^{\\text{mass}}_{L}(j) = -U\\,\\rho(y_{j}), \\qquad f^{\\text{mass}}_{R}(k) = +U\\,\\rho(y_{k})\n$$\nThe corresponding species fluxes for species $s \\in \\{1, 2\\}$ are:\n$$\nf^{(s)}_{L}(j) = -U\\,\\rho(y_{j})\\,Y_{s}(y_{j}), \\qquad f^{(s)}_{R}(k) = +U\\,\\rho(y_{k})\\,Y_{s}(y_{k})\n$$\nFor a discrete mapping $M(j)$ that maps segment $j$ on $\\Gamma_L$ to segment $M(j)$ on $\\Gamma_R$, the local cancellation error for mass is $|f^{\\text{mass}}_{L}(j) + f^{\\text{mass}}_{R}(M(j))|$. The diagnostic error metric $E$ is the cumulative sum of these local errors over the entire boundary and over time. Given that the fields are steady, the summation over $N_t$ time steps of size $\\Delta t$ simplifies to a multiplication by the total time $T = N_t \\Delta t$. The error for total mass is:\n$$\nE_{\\text{mass}} \\;=\\; \\sum_{n=0}^{N_{t}-1} \\Delta t \\sum_{j=0}^{N_{y}-1} \\left| f^{\\text{mass}}_{L}(j) + f^{\\text{mass}}_{R}(M(j)) \\right|\\,\\Delta y \\;=\\; T \\cdot \\Delta y \\sum_{j=0}^{N_{y}-1} \\left| -U\\,\\rho(y_{j}) + U\\,\\rho(y_{M(j)}) \\right|\n$$\nSince $U \\ge 0$, this simplifies to:\n$$\nE_{\\text{mass}} \\;=\\; T \\cdot U \\cdot \\Delta y \\sum_{j=0}^{N_{y}-1} \\left| \\rho(y_{M(j)}) - \\rho(y_j) \\right|\n$$\nSimilarly, for species $s$:\n$$\nE_{s} \\;=\\; T \\cdot U \\cdot \\Delta y \\sum_{j=0}^{N_{y}-1} \\left| \\rho(y_{M(j)})Y_s(y_{M(j)}) - \\rho(y_j)Y_s(y_j) \\right|\n$$\nThe implementation will proceed as follows. For each test case defined by ($N_y, U, s, \\varepsilon$):\n$1$. The grid of $N_y$ points $\\{y_j\\}$ is constructed.\n$2$. The field values for $\\rho(y_j)$, $Y_1(y_j)$, and $Y_2(y_j)$ are computed and stored in arrays. The mass-flux-like quantity $\\phi_s(y_j)=\\rho(y_j)Y_s(y_j)$ is also computed.\n$3$. The discrete mapping $M(j) = (j+s)\\bmod N_y$ is applied. Computationally, this is equivalent to a periodic shift of the field arrays. An array `q` of values $q(y_j)$ is mapped to an array `q_mapped` where `q_mapped`$[j] = q(y_{M(j)})$. This is achieved efficiently using a circular shift operation on the arrays. For an offset $s$, this corresponds to a left circular shift by $s$ positions.\n$4$. The errors $E_{\\text{mass}}$, $E_1$, and $E_2$ are calculated using the simplified formulas. Vectorized operations are used for efficiency.\n$5$. The test case is marked as 'pass' (`True`) if all three errors $E_{\\text{mass}}$, $E_1$, and $E_2$ are less than or equal to the specified tolerance $\\varepsilon$, and 'fail' (`False`) otherwise.\n\nThe field definitions are:\n- $\\rho(y) \\;=\\; 1 \\;+\\; 0.2\\,\\sin(2\\pi y) \\;+\\; 0.1\\,\\cos(4\\pi y)$\n- $Y_{1}(y) \\;=\\; 0.5 \\;+\\; 0.3\\,\\sin(2\\pi y)$\n- $Y_{2}(y) \\;=\\; 1 - Y_{1}(y)$\n\nThe fixed parameters are $T = 1$ and $\\Delta t = T/100 = 0.01$. The value of $N_t=100$ and $\\Delta t$ are not explicitly needed in the simplified formulation, only their product $T$.\nThe implementation will be carried out in Python, using the `numpy` library for numerical computations.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and validates a diagnostic for mismatched periodic boundary\n    conditions in a computational combustion context.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Ny, U, s, epsilon)\n        (64, 0.5, 0, 1e-11),   # Case 1: Perfect mapping, should pass.\n        (64, 0.0, 13, 1e-12),  # Case 2: Zero velocity, no flux, should pass.\n        (64, 0.5, 1, 1e-6),    # Case 3: Mismatched mapping, should fail.\n        (64, 1e-8, 1, 1e-6),   # Case 4: Mismatched, but tiny velocity, should pass.\n    ]\n\n    T = 1.0  # Total simulation time.\n\n    results = []\n    for Ny, U, s, epsilon in test_cases:\n        # Step 1: Discretize the domain in the y-direction.\n        dy = 1.0 / Ny\n        y = (np.arange(Ny) + 0.5) * dy\n\n        # Step 2: Define and evaluate the spatially varying fields.\n        rho = 1.0 + 0.2 * np.sin(2 * np.pi * y) + 0.1 * np.cos(4 * np.pi * y)\n        Y1 = 0.5 + 0.3 * np.sin(2 * np.pi * y)\n        \n        # The species mass fractions must sum to 1.\n        # This implies rho*Y1 + rho*Y2 = rho.\n        phi1 = rho * Y1\n        phi2 = rho - phi1\n\n        # Step 3: Apply the periodic mapping M(j) = (j+s) mod Ny.\n        # This corresponds to a circular left shift by 's' positions.\n        # np.roll(arr, -s) shifts elements to the left.\n        rho_mapped = np.roll(rho, -s)\n        phi1_mapped = np.roll(phi1, -s)\n        phi2_mapped = np.roll(phi2, -s)\n\n        # A more numerically robust way to calculate phi2_mapped to enforce\n        # the conservation property rho = phi1 + phi2 exactly.\n        # phi2_mapped_alt = rho_mapped - phi1_mapped\n        # The results are identical in this case.\n\n        # Step 4: Calculate the cumulative pairwise conservation errors.\n        # The formulas are simplified for steady fields: E = T * U * dy * sum(|diff|).\n        \n        # Mass conservation error\n        diff_rho = rho_mapped - rho\n        E_mass = T * U * dy * np.sum(np.abs(diff_rho))\n\n        # Species 1 conservation error\n        diff_phi1 = phi1_mapped - phi1\n        E1 = T * U * dy * np.sum(np.abs(diff_phi1))\n\n        # Species 2 conservation error\n        # Can be derived from mass and species 1 differences\n        # diff_phi2 = phi2_mapped - phi2\n        #           = (rho_mapped - phi1_mapped) - (rho - phi1)\n        #           = (rho_mapped - rho) - (phi1_mapped - phi1)\n        #           = diff_rho - diff_phi1\n        diff_phi2 = diff_rho - diff_phi1\n        E2 = T * U * dy * np.sum(np.abs(diff_phi2))\n\n        # Step 5: Apply the decision rule.\n        # A case passes if and only if all three errors are within the tolerance.\n        passed = (E_mass <= epsilon) and (E1 <= epsilon) and (E2 <= epsilon)\n        results.append(passed)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Our final practice explores the subtle but profound impact of numerical discretization on physical predictions. You will analyze how numerical dispersion, an artifact of discretizing the wave equation on a grid, alters the predicted growth rate of thermoacoustic instabilities in a periodic combustor . This exercise bridges the gap between numerical methods and physical interpretation, showing why mesh-convergence studies are essential for reliable simulation results.",
            "id": "4069956",
            "problem": "Consider a one-dimensional, premixed, periodic combustor of length $L$ with constant base-state sound speed $c$ and base-state density $\\rho_0$. The flow is assumed to be quiescent with no mean flow. Small-amplitude thermoacoustic perturbations are modeled by linearized acoustics with a time-delayed heat-release closure. Denote acoustic pressure perturbation by $p'(x,t)$ and acoustic velocity perturbation by $u'(x,t)$. The fundamental base comprises: (i) the linearized continuity equation $ \\partial \\rho'/\\partial t + \\rho_0 \\, \\partial u'/\\partial x = 0 $, (ii) the linearized momentum equation $ \\rho_0 \\, \\partial u'/\\partial t + \\partial p'/\\partial x = 0 $, (iii) the ideal-gas acoustic closure $ p' = c^2 \\rho' $, and (iv) a compact (spatially localized) heat-release perturbation model with time delay $ \\tau$ defined by $ q'(t) = \\kappa \\, u'(x_f, t - \\tau) $, where $x_f$ is the flame location and $\\kappa$ is a proportionality constant. You may treat $x_f$ as arbitrary in a homogeneous periodic domain. The Rayleigh criterion states that the modal growth rate is proportional to the cycle-averaged product of $p'$ and $q'$, with damping $D$ accounting for viscous, thermal, and radiation losses. In the small-amplitude limit, the modal dynamics can be approximated by a dispersion relation between angular frequency $\\omega$ and wavenumber $k$, and an explicit expression for the modal growth rate $ \\sigma $ in terms of the time delay and the phase between $q'$ and $p'$.\n\nA periodic boundary condition implies that spatial eigenmodes are harmonics on the interval $[0,L)$ and that discrete approximations to spatial derivatives must enforce periodic wrapping. Consider a uniform grid of $N$ points with spacing $\\Delta x = L/N$ and the standard second-order central-difference approximation to $\\partial^2/\\partial x^2$ closed with periodic boundary conditions. Let $m \\in \\{1,2,\\dots\\}$ index the mode number. The finite-difference approximation induces a discrete dispersion relation that deviates from the continuous relation. The symmetry of the periodic domain yields discrete eigenvectors that are grid harmonics and eigenvalues that depend on $N$ and $m$. This numerical dispersion impacts the phase in the time-delay closure and thus the thermoacoustic growth rate. \n\nTask 1 (derivation): Starting from the fundamental base above and assuming a single Fourier mode ansatz $ p'(x,t) = \\Re\\{ P_m \\exp(i k x - i \\omega t) \\} $ with amplitude $P_m$ and mode index $m$, derive the continuous dispersion relation and then derive the discrete dispersion relation for the second-order central-difference Laplacian with periodic boundary conditions on a uniform grid of $N$ points. Use the fact that the discrete eigenvectors are $ \\exp(i 2 \\pi m j / N) $ at grid index $ j \\in \\{0,1,\\dots,N-1\\} $ to obtain the discrete angular frequency $ \\omega_m(N) $ as a function of $L$, $c$, $m$, and $N$. Then, express the modal growth rate $ \\sigma_m(N) $ in terms of a coupling gain $G$ and damping $D$ using the time-delay closure. Justify every step using the stated fundamental laws. Ensure all variables and operators are presented in radians for angular quantities, and all derived growth rates are expressed in $ \\mathrm{s}^{-1} $.\n\nTask 2 (algorithm and sensitivity): Design a numerical experiment that quantifies the sensitivity of $ \\sigma_m(N) $ to the discretization of periodic boundary conditions, by varying $N$ and comparing $ \\sigma_m(N) $ to a high-resolution reference $ \\sigma_m(N_{\\mathrm{ref}}) $. Define the relative error for each mode $m$ and grid size $N$ as $ \\varepsilon_{m}(N) = \\left| \\sigma_m(N) - \\sigma_m(N_{\\mathrm{ref}}) \\right| / \\max\\left(\\left| \\sigma_m(N_{\\mathrm{ref}}) \\right|, \\epsilon_0 \\right) $, where $ \\epsilon_0 $ is a small, positive regularization constant to avoid division by zero. Aggregate the sensitivity by taking the maximum over selected modes and grid sizes $ \\varepsilon_{\\max} = \\max_{m,N} \\varepsilon_m(N) $. Propose a tolerance $ \\varepsilon_{\\mathrm{tol}} $ and define mesh independence as the condition $ \\varepsilon_{\\max} \\le \\varepsilon_{\\mathrm{tol}} $. Your program must compute $ \\varepsilon_{\\max} $ for each test case and produce them as dimensionless floats.\n\nTask 3 (implementation and test suite): Implement a complete, runnable program that carries out the derivation-based formulas and the sensitivity study. Use the following test suite with physically plausible parameters. All angles must be in radians, all times in seconds, $L$ in meters, $c$ in meters per second, and $G$ and $D$ in $ \\mathrm{s}^{-1} $. Report only dimensionless relative errors in your final output. For each test case, compute modes $m = 1,2,\\dots,M$.\n\n- Test Case A (general case): $ L = 1.0\\,\\mathrm{m} $, $ c = 600.0\\,\\mathrm{m/s} $, $ G = 100.0\\,\\mathrm{s}^{-1} $, $ D = 20.0\\,\\mathrm{s}^{-1} $, $ \\tau = 0.0020\\,\\mathrm{s} $, $ M = 4 $, $ N \\in \\{32,64,128,256,512\\} $, $ N_{\\mathrm{ref}} = 4096 $, $ \\varepsilon_{\\mathrm{tol}} = 10^{-4} $, $ \\epsilon_0 = 10^{-12} $.\n\n- Test Case B (zero-delay boundary case): $ L = 1.0\\,\\mathrm{m} $, $ c = 340.0\\,\\mathrm{m/s} $, $ G = 50.0\\,\\mathrm{s}^{-1} $, $ D = 5.0\\,\\mathrm{s}^{-1} $, $ \\tau = 0.0\\,\\mathrm{s} $, $ M = 3 $, $ N \\in \\{8,16,32,64\\} $, $ N_{\\mathrm{ref}} = 4096 $, $ \\varepsilon_{\\mathrm{tol}} = 10^{-10} $, $ \\epsilon_0 = 10^{-12} $. In this case, the time-delay phase is zero, so growth rates should be independent of $N$ if periodic boundary conditions are enforced correctly.\n\n- Test Case C (phase-sensitive case): $ L = 1.5\\,\\mathrm{m} $, $ c = 650.0\\,\\mathrm{m/s} $, $ G = 80.0\\,\\mathrm{s}^{-1} $, $ D = 10.0\\,\\mathrm{s}^{-1} $, $ \\tau = 0.0006\\,\\mathrm{s} $, $ M = 6 $, $ N \\in \\{16,24,32,48,64,96,128,256,512,1024\\} $, $ N_{\\mathrm{ref}} = 4096 $, $ \\varepsilon_{\\mathrm{tol}} = 10^{-4} $, $ \\epsilon_0 = 10^{-12} $.\n\nFinal output format specification: Your program should produce a single line of output containing the maximum relative errors for the three test cases as a comma-separated list enclosed in square brackets, for example $ [\\varepsilon_{\\max}^{(A)},\\varepsilon_{\\max}^{(B)},\\varepsilon_{\\max}^{(C)}] $, where each entry is a dimensionless float. No other text may be printed. The program must be self-contained and execute without user input.",
            "solution": "The problem is valid as it is scientifically grounded in the principles of linearized acoustics and computational physics, well-posed with a clear objective and sufficient data, and free of contradictions or ambiguities. We may therefore proceed with the derivation and solution.\n\nThe analysis is structured into three parts as requested: derivation of the governing analytical and numerical relations, formulation of the sensitivity analysis algorithm, and implementation of the complete program.\n\nFirst, we derive the governing wave equation from the fundamental principles provided. The linearized continuity and momentum equations are:\n$$\n\\frac{\\partial \\rho'}{\\partial t} + \\rho_0 \\frac{\\partial u'}{\\partial x} = 0 \\quad \\text{(i)}\n$$\n$$\n\\rho_0 \\frac{\\partial u'}{\\partial t} + \\frac{\\partial p'}{\\partial x} = 0 \\quad \\text{(ii)}\n$$\nWe differentiate equation (i) with respect to time $t$ and equation (ii) with respect to space $x$:\n$$\n\\frac{\\partial^2 \\rho'}{\\partial t^2} + \\rho_0 \\frac{\\partial^2 u'}{\\partial t \\partial x} = 0\n$$\n$$\n\\rho_0 \\frac{\\partial^2 u'}{\\partial x \\partial t} + \\frac{\\partial^2 p'}{\\partial x^2} = 0\n$$\nAssuming sufficient continuity of the fields, the mixed partial derivatives are equal. We can thus equate the terms involving the acoustic velocity $u'$:\n$$\n\\rho_0 \\frac{\\partial^2 u'}{\\partial t \\partial x} = -\\frac{\\partial^2 \\rho'}{\\partial t^2} = \\rho_0 \\frac{\\partial^2 u'}{\\partial x \\partial t} = -\\frac{\\partial^2 p'}{\\partial x^2}\n$$\nThis yields a relationship between the pressure $p'$ and density $\\rho'$ fluctuations:\n$$\n\\frac{\\partial^2 \\rho'}{\\partial t^2} = \\frac{\\partial^2 p'}{\\partial x^2}\n$$\nUsing the ideal-gas acoustic closure $p' = c^2 \\rho'$, which implies $\\rho' = p'/c^2$, and substituting this into the equation above, we obtain the one-dimensional homogeneous wave equation for acoustic pressure:\n$$\n\\frac{1}{c^2} \\frac{\\partial^2 p'}{\\partial t^2} - \\frac{\\partial^2 p'}{\\partial x^2} = 0\n$$\nThis equation governs the propagation of sound waves in the absence of source terms and dissipation, which determine the natural modes and frequencies of the system.\n\nNext, we derive the continuous dispersion relation. We consider a single Fourier mode ansatz of the form $p'(x,t) = \\Re\\{ P_m \\exp(i k x - i \\omega t) \\}$, where $P_m$ is the complex amplitude, $k$ is the wavenumber, and $\\omega$ is the angular frequency. Substituting this into the wave equation gives:\n$$\n\\frac{1}{c^2} (-i \\omega)^2 P_m e^{i(kx-\\omega t)} - (ik)^2 P_m e^{i(kx-\\omega t)} = 0\n$$\n$$\n-\\frac{\\omega^2}{c^2} + k^2 = 0 \\implies \\omega^2 = c^2 k^2\n$$\nThis yields the continuous dispersion relation $\\omega = \\pm c k$. For a periodic domain of length $L$, the wavenumber $k$ is quantized to ensure periodicity, i.e., $p'(x+L,t) = p'(x,t)$. This requires $kL = 2\\pi m$ for an integer mode number $m \\in \\{1, 2, ...\\}$. The mode $m=0$ corresponds to a spatially uniform pressure fluctuation and is not an acoustic wave. The continuous natural angular frequencies are therefore:\n$$\n\\omega_{m, \\text{cont}} = c |k_m| = \\frac{2 \\pi c m}{L}\n$$\n\nWe now derive the discrete dispersion relation resulting from spatial discretization. The domain of length $L$ is discretized into $N$ uniform grid intervals, with grid spacing $\\Delta x = L/N$. The semi-discretized wave equation at grid point $j$ is obtained by replacing the spatial derivative $\\partial^2/\\partial x^2$ with its second-order central-difference approximation:\n$$\n\\frac{d^2 p'_j(t)}{dt^2} = c^2 \\frac{p'_{j+1}(t) - 2p'_j(t) + p'_{j-1}(t)}{(\\Delta x)^2}\n$$\nwhere periodic boundary conditions imply $p'_{N} = p'_{0}$ and $p'_{-1} = p'_{N-1}$. The problem states that the discrete eigenvectors are grid harmonics of the form $\\exp(i 2 \\pi m j / N)$. Let us apply the discrete Laplacian operator to this eigenvector:\n$$\n\\frac{e^{i 2 \\pi m (j+1)/N} - 2e^{i 2 \\pi m j/N} + e^{i 2 \\pi m (j-1)/N}}{(\\Delta x)^2} = \\frac{e^{i 2 \\pi m j/N}}{(\\Delta x)^2} \\left( e^{i 2 \\pi m / N} - 2 + e^{-i 2 \\pi m / N} \\right)\n$$\nUsing the identity $2\\cos\\theta = e^{i\\theta} + e^{-i\\theta}$, this simplifies to:\n$$\n\\frac{e^{i 2 \\pi m j/N}}{(\\Delta x)^2} \\left( 2\\cos\\left(\\frac{2\\pi m}{N}\\right) - 2 \\right) = \\frac{e^{i 2 \\pi m j/N}}{(\\Delta x)^2} \\left( -4\\sin^2\\left(\\frac{\\pi m}{N}\\right) \\right)\n$$\nThe eigenvalue of the discrete Laplacian for mode $m$ is thus $\\lambda_m = -\\frac{4}{(\\Delta x)^2} \\sin^2(\\frac{\\pi m}{N})$. Substituting the ansatz $p'_j(t) = P_m \\exp(-i \\omega_m(N) t)$ into the semi-discretized wave equation, where $\\omega_m(N)$ is the discrete angular frequency, we get:\n$$\n(-i \\omega_m(N))^2 = c^2 \\lambda_m \\implies -\\omega_m(N)^2 = -c^2 \\frac{4}{(\\Delta x)^2} \\sin^2\\left(\\frac{\\pi m}{N}\\right)\n$$\nSolving for $\\omega_m(N)$ and substituting $\\Delta x = L/N$ yields the discrete dispersion relation:\n$$\n\\omega_m(N) = \\frac{2c}{\\Delta x} \\left| \\sin\\left(\\frac{\\pi m}{N}\\right) \\right| = \\frac{2cN}{L} \\sin\\left(\\frac{\\pi m}{N}\\right)\n$$\nwhere we take the positive root for frequency and assume $m \\le N/2$ such that the sine term is positive. This numerical frequency $\\omega_m(N)$ deviates from the continuous frequency $\\omega_{m, \\text{cont}}$, an effect known as numerical dispersion.\n\nFinally, we derive the expression for the modal growth rate $\\sigma_m(N)$. The Rayleigh criterion states that the growth rate is proportional to the cycle-averaged product of pressure $p'$ and heat release rate $q'$. For a time-delay model $q'(t) = \\kappa \\, u'(x_f, t-\\tau)$, the growth rate is determined by the phase difference between pressure and heat release. From the linearized momentum equation (ii), assuming a single traveling wave component $\\tilde{p}=P_m e^{i(kx-\\omega t)}$, the complex velocity is $\\tilde{u} = \\frac{k}{\\rho_0 \\omega}\\tilde{p}$. Since $k$ and $\\omega$ are real, $\\tilde{u}$ and $\\tilde{p}$ are in phase. The complex heat release rate is $\\tilde{q}(t) = \\kappa \\tilde{u}(x_f, t-\\tau) \\propto e^{-i\\omega(t-\\tau)} = e^{-i\\omega t} e^{i\\omega\\tau}$. The phase difference between $\\tilde{q}(t)$ and $\\tilde{p}(x_f, t)$ is therefore $\\phi = \\omega\\tau$. The simplified form of the growth rate, incorporating the flame-acoustic coupling gain $G$ and system-level damping $D$, is then $\\sigma = G \\cos(\\phi) - D$. Using the discrete frequency $\\omega_m(N)$, the growth rate for mode $m$ on a grid of size $N$ is:\n$$\n\\sigma_m(N) = G \\cos(\\omega_m(N) \\tau) - D\n$$\nCombining our results, the final expression is:\n$$\n\\sigma_m(N) = G \\cos\\left( \\left[ \\frac{2cN}{L} \\sin\\left(\\frac{\\pi m}{N}\\right) \\right] \\tau \\right) - D\n$$\nThis expression demonstrates that the numerical dispersion in $\\omega_m(N)$ directly impacts the calculated thermoacoustic growth rate by altering the phase of the feedback loop.\n\nThe numerical sensitivity study is designed to quantify this impact. The algorithm, as specified, is as follows. For each test case:\n1.  For each mode $m \\in \\{1, 2, \\dots, M\\}$, calculate the reference growth rate $\\sigma_m(N_{\\mathrm{ref}})$ using the derived formula with a high-resolution grid $N_{\\mathrm{ref}}$.\n2.  Iterate through each specified grid size $N$. For each $N$, iterate through each mode $m \\in \\{1, \\dots, M\\}$.\n3.  Calculate the growth rate $\\sigma_m(N)$ for the current grid size.\n4.  Compute the relative error $\\varepsilon_m(N) = \\left| \\sigma_m(N) - \\sigma_m(N_{\\mathrm{ref}}) \\right| / \\max\\left(\\left| \\sigma_m(N_{\\mathrm{ref}}) \\right|, \\epsilon_0 \\right)$.\n5.  The aggregate sensitivity for the test case, $\\varepsilon_{\\max}$, is the maximum of all computed relative errors $\\varepsilon_m(N)$ over all specified $m$ and $N$.\nThis procedure systematically evaluates the convergence of the numerical solution towards the high-resolution reference, providing a quantitative measure of discretization error.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef calculate_max_error(params: dict) -> float:\n    \"\"\"\n    Calculates the maximum relative error for a given test case.\n\n    Args:\n        params (dict): A dictionary containing all parameters for the test case.\n\n    Returns:\n        float: The maximum relative error over all specified modes and grid sizes.\n    \"\"\"\n    L = params[\"L\"]\n    c = params[\"c\"]\n    G = params[\"G\"]\n    D = params[\"D\"]\n    tau = params[\"tau\"]\n    M = params[\"M\"]\n    N_list = params[\"N\"]\n    N_ref = params[\"N_ref\"]\n    epsilon_0 = params[\"epsilon_0\"]\n\n    modes = np.arange(1, M + 1)\n    all_errors = []\n\n    # Define the functions for angular frequency and growth rate based on the derivation.\n    # omega_m(N) = (2*c*N/L) * sin(pi*m/N)\n    def calculate_omega(m_vals, N_val, c_val, L_val):\n        return (2 * c_val * N_val / L_val) * np.sin(np.pi * m_vals / N_val)\n\n    # sigma_m(N) = G * cos(omega_m(N) * tau) - D\n    def calculate_sigma(omega_vals, G_val, D_val, tau_val):\n        return G_val * np.cos(omega_vals * tau_val) - D_val\n\n    # 1. Calculate the reference growth rates sigma_m(N_ref) for all modes.\n    omega_ref = calculate_omega(modes, N_ref, c, L)\n    sigma_ref = calculate_sigma(omega_ref, G, D, tau)\n\n    # Denominator for the relative error calculation\n    # max(|sigma_m(N_ref)|, epsilon_0)\n    denominators = np.maximum(np.abs(sigma_ref), epsilon_0)\n\n    # 2. Iterate through grid sizes and modes to calculate errors.\n    for N in N_list:\n        # Calculate omega and sigma for the current grid size N for all modes\n        omega_N = calculate_omega(modes, N, c, L)\n        sigma_N = calculate_sigma(omega_N, G, D, tau)\n        \n        # Calculate relative error for all modes for the current N\n        # ε_m(N) = |sigma_m(N) - sigma_m(N_ref)| / max(|sigma_m(N_ref)|, ε_0)\n        errors = np.abs(sigma_N - sigma_ref) / denominators\n        \n        all_errors.extend(errors)\n\n    # 3. Find the maximum error over all computations for this case.\n    if not all_errors:\n        return 0.0\n    \n    return np.max(all_errors)\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case A\n        {\n            \"name\": \"A\",\n            \"L\": 1.0, \"c\": 600.0, \"G\": 100.0, \"D\": 20.0, \"tau\": 0.0020,\n            \"M\": 4, \"N\": [32, 64, 128, 256, 512], \"N_ref\": 4096,\n            \"epsilon_0\": 1e-12\n        },\n        # Test Case B\n        {\n            \"name\": \"B\",\n            \"L\": 1.0, \"c\": 340.0, \"G\": 50.0, \"D\": 5.0, \"tau\": 0.0,\n            \"M\": 3, \"N\": [8, 16, 32, 64], \"N_ref\": 4096,\n            \"epsilon_0\": 1e-12\n        },\n        # Test Case C\n        {\n            \"name\": \"C\",\n            \"L\": 1.5, \"c\": 650.0, \"G\": 80.0, \"D\": 10.0, \"tau\": 0.0006,\n            \"M\": 6, \"N\": [16, 24, 32, 48, 64, 96, 128, 256, 512, 1024],\n            \"N_ref\": 4096, \"epsilon_0\": 1e-12\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        max_error = calculate_max_error(case)\n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}