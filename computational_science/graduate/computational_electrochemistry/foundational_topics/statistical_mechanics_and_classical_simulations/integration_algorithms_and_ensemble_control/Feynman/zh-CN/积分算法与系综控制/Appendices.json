{
    "hands_on_practices": [
        {
            "introduction": "在可极化模型（如用于电化学模拟的Drude振子模型）中，高频振动的存在对分子动力学积分算法的稳定性构成了严峻挑战。这个练习旨在通过推导和分析隐式中点积分法的稳定性，揭示其处理“刚性”动力学问题的优势。通过完成这项实践，你将深入理解显式与隐式积分方案在面对高频振荡时的根本差异，并掌握评估数值积分器稳定性的核心方法。",
            "id": "4248837",
            "problem": "在分子动力学模拟中，一个可极化Drude对被建模为通过谐振弹簧连接的两个点质量：一个位于位置$\\mathbf{R}_{\\mathrm{C}}$的大质量核心核（质量为$m_{\\mathrm{C}}$）和一个位于位置$\\mathbf{R}_{\\mathrm{D}}$的带质量的Drude粒子（质量为$m_{\\mathrm{D}}$），它们通过劲度系数为$k_{\\mathrm{D}}$的弹簧耦合。在没有外场和温控力的情况下，质心运动可以分离出来，相对坐标$\\mathbf{r} \\equiv \\mathbf{R}_{\\mathrm{D}} - \\mathbf{R}_{\\mathrm{C}}$遵循牛顿第二定律，其约化质量为$\\mu \\equiv \\frac{m_{\\mathrm{C}} m_{\\mathrm{D}}}{m_{\\mathrm{C}} + m_{\\mathrm{D}}}$，角频率为$\\omega \\equiv \\sqrt{k_{\\mathrm{D}}/\\mu}$：\n$$\n\\mu \\,\\ddot{\\mathbf{r}} = -k_{\\mathrm{D}}\\,\\mathbf{r}.\n$$\n定义状态向量$\\mathbf{y} \\equiv \\begin{pmatrix} \\mathbf{r} \\\\ \\mathbf{v} \\end{pmatrix}$，其中$\\mathbf{v} \\equiv \\dot{\\mathbf{r}}$，这样动力学可以写成一阶形式$\\dot{\\mathbf{y}} = A \\mathbf{y}$，其中$A$是一个常数矩阵。考虑为该Drude振子设计一个隐式中点时间积分器，该积分器适用于在正则系综控制（如Nosé–Hoover链温控器）下的分子动力学（MD）中使用，但在这里我们分析未温控（零摩擦）的线性动力学，以分离出该方案的内在稳定性。\n\n从牛顿第二定律和一阶表示出发，执行以下操作：\n- 推导线性系统的隐式中点单步映射，形式为$\\mathbf{y}_{n+1} = M(h)\\,\\mathbf{y}_{n}$，其中$h$是时间步长，$M(h)$是依赖于$h$和$A$的矩阵。\n- 从此线性映射中，推导出应用于标量测试方程$\\dot{y} = \\lambda y$的隐式中点法的标量稳定性函数$R(z)$，其中$z \\equiv \\lambda h$。\n- 使用$R(z)$来论证该方法对于所有$\\Re(z) \\le 0$的$z$是否无条件稳定，并解释与具有纯虚特征值$z = \\mathrm{i}\\,\\omega h$的无阻尼Drude振子相关的特殊情况。\n- 在相同的标量测试问题上，简要比较该隐式中点法与显式前向欧拉法和速度Verlet算法在$h$变化时的稳定性特征，重点关注$\\omega$很大的刚性区域。\n\n报告最终答案，形式为稳定性函数$R(z)$关于$z$的显式解析表达式。无需进行数值计算。不要包含单位。",
            "solution": "提交分析的问题陈述被认为是有效的。它在科学上基于Drude振子的标准物理模型和数值积分的数学原理。该问题是适定的、客观的和自洽的，提供了执行所要求的推导和分析所需的所有必要定义和方程。没有矛盾、歧义或事实不准确之处。因此，我们可以进行正式的求解。\n\n该问题通过二阶常微分方程（ODE）描述了Drude振子的相对运动：\n$$\n\\mu \\,\\ddot{\\mathbf{r}} = -k_{\\mathrm{D}}\\,\\mathbf{r}\n$$\n引入角频率$\\omega \\equiv \\sqrt{k_{\\mathrm{D}}/\\mu}$，上式变为$\\ddot{\\mathbf{r}} = -\\omega^2 \\mathbf{r}$。为了将其表述为一阶系统，我们定义状态向量$\\mathbf{y} \\equiv \\begin{pmatrix} \\mathbf{r} \\\\ \\mathbf{v} \\end{pmatrix}$，其中$\\mathbf{v} \\equiv \\dot{\\mathbf{r}}$。该常微分方程组为：\n$$\n\\dot{\\mathbf{r}} = \\mathbf{v}\n$$\n$$\n\\dot{\\mathbf{v}} = -\\omega^2 \\mathbf{r}\n$$\n这可以写成矩阵形式$\\dot{\\mathbf{y}} = A \\mathbf{y}$，其中矩阵$A$由下式给出：\n$$\nA = \\begin{pmatrix} 0  1 \\\\ -\\omega^2  0 \\end{pmatrix}\n$$\n注意，对于三维向量$\\mathbf{r}$和$\\mathbf{v}$，矩阵$A$中的元素$1$和$0$应理解为$1 \\cdot I_3$和$0 \\cdot I_3$，其中$I_3$是$3 \\times 3$的单位矩阵。形式分析保持不变。\n\n隐式中点法是用于常微分方程$\\dot{\\mathbf{y}} = f(\\mathbf{y}, t)$的单步积分器，其规则定义如下：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\, f\\left(\\frac{\\mathbf{y}_n + \\mathbf{y}_{n+1}}{2}, t_n + \\frac{h}{2}\\right)\n$$\n其中$h$是时间步长。对于我们的线性、时不变系统，$f(\\mathbf{y}) = A \\mathbf{y}$。将其代入中点法则得到：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\, A \\left(\\frac{\\mathbf{y}_n + \\mathbf{y}_{n+1}}{2}\\right)\n$$\n这是一个关于$\\mathbf{y}_{n+1}$的隐式方程。我们重新整理它，以$\\mathbf{y}_n$的形式求解$\\mathbf{y}_{n+1}$：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{2} A \\mathbf{y}_n + \\frac{h}{2} A \\mathbf{y}_{n+1}\n$$\n$$\n\\mathbf{y}_{n+1} - \\frac{h}{2} A \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{2} A \\mathbf{y}_n\n$$\n$$\n\\left(I - \\frac{h}{2} A\\right) \\mathbf{y}_{n+1} = \\left(I + \\frac{h}{2} A\\right) \\mathbf{y}_n\n$$\n其中$I$是与$A$相同维度的单位矩阵。求解$\\mathbf{y}_{n+1}$得到单步映射：\n$$\n\\mathbf{y}_{n+1} = \\left(I - \\frac{h}{2} A\\right)^{-1} \\left(I + \\frac{h}{2} A\\right) \\mathbf{y}_n\n$$\n该映射的形式为$\\mathbf{y}_{n+1} = M(h)\\,\\mathbf{y}_{n}$，其中传播矩阵$M(h) = \\left(I - \\frac{h}{2} A\\right)^{-1} \\left(I + \\frac{h}{2} A\\right)$。\n\n为了推导标量稳定性函数$R(z)$，我们将相同的方法应用于标量测试方程$\\dot{y} = \\lambda y$，其中$\\lambda \\in \\mathbb{C}$。在这种情况下，矩阵$A$就是标量$\\lambda$。单步映射变为：\n$$\ny_{n+1} = \\left(1 - \\frac{h}{2} \\lambda\\right)^{-1} \\left(1 + \\frac{h}{2} \\lambda\\right) y_n\n$$\n稳定性函数$R(z)$由关系式$y_{n+1} = R(z) y_n$定义，其中$z \\equiv \\lambda h$。通过比较，我们找到$R(z)$的表达式：\n$$\nR(z) = \\frac{1 + z/2}{1 - z/2} = \\frac{2+z}{2-z}\n$$\n\n接下来，我们分析该方法的稳定性。如果一个数值方法的绝对稳定域包含整个复平面左半平面，即对于所有$\\Re(z) \\le 0$的$z$都有$|R(z)| \\le 1$，则该方法被称为A-稳定。令$z = x + iy$，其中$x, y \\in \\mathbb{R}$且$x \\le 0$。我们计算$R(z)$的模：\n$$\n|R(z)|^2 = \\left| \\frac{1 + (x+iy)/2}{1 - (x+iy)/2} \\right|^2 = \\frac{|(1+x/2) + i(y/2)|^2}{|(1-x/2) - i(y/2)|^2} = \\frac{(1+x/2)^2 + (y/2)^2}{(1-x/2)^2 + (y/2)^2}\n$$\n$$\n|R(z)|^2 = \\frac{1 + x + x^2/4 + y^2/4}{1 - x + x^2/4 + y^2/4}\n$$\n由于我们考虑$\\Re(z) = x \\le 0$，分母中的项$-x$是非负的。\n- 如果$x  0$，那么$1+x  1-x$，这意味着分子严格小于分母。因此，$|R(z)|  1$。\n- 如果$x = 0$，分子和分母相同，这意味着$|R(z)| = 1$。\n因此，对于所有$\\Re(z) \\le 0$的$z$，我们有$|R(z)| \\le 1$。隐式中点法是A-稳定的。\n\n无阻尼Drude振子的特殊情况对应于一个具有纯虚特征值的系统。矩阵$A$的特征值由特征方程$\\det(A - \\lambda I) = \\lambda^2 + \\omega^2 = 0$的根给出，即$\\lambda = \\pm i\\omega$。对于标量测试问题，这对应于$z = \\lambda h = \\pm i\\omega h$。这是一个纯虚数，所以其实部为$\\Re(z) = 0$。如上所述，对于虚轴上的任何$z$，$|R(z)| = 1$。这意味着当应用于无阻尼谐振子时，无论时间步长$h$如何，隐式中点法产生的数值轨迹的振幅既不增长也不衰减。该方法精确地保持了系统能量的一个离散模拟，这一性质被称为辛性。这使其非常适合像Drude模型这样的哈密顿系统的长时间模拟。\n\n最后，我们在刚性区域（大$\\omega$）中比较隐式中点法与其他常用积分器的稳定性。\n- **隐式中点法：** 如前所示，它是A-稳定的。对于振子（$z = i\\omega h$），对所有$h$都有$|R_{IM}(i\\omega h)| = 1$。该方法是无条件稳定的，使其对于刚性高频振荡是稳健的。\n- **显式前向欧拉法：** 稳定性函数为$R_{FE}(z) = 1+z$。对于振子，我们有$|R_{FE}(i\\omega h)| = |1 + i\\omega h| = \\sqrt{1 + (\\omega h)^2}$。对于任何$h>0$和$\\omega>0$，该值都严格大于$1$。数值解的振幅将呈指数增长，意味着该方法对于纯振荡系统是无条件不稳定的。\n- **速度Verlet算法：** 这是一种在MD中广泛使用的显式的二阶辛积分器。它在同等意义上不是单步方法，但其对于谐振子问题的稳定性可以被分析。分析表明，速度Verlet算法仅在时间步长$h$满足条件$\\omega h \\le 2$时才是稳定的。它是条件稳定的。\n\n在$\\omega$很大的刚性区域，速度Verlet算法的稳定性约束（$h \\le 2/\\omega$）变得极其严格，迫使使用非常小的时间步长。显式欧拉法从不稳定。相比之下，隐式中点法对于任何时间步长$h$的选择都保持稳定，这在高效地积分Drude振子的刚性内运动方面是一个决定性的优势。",
            "answer": "$$\\boxed{\\frac{1 + \\frac{z}{2}}{1 - \\frac{z}{2}}}$$"
        },
        {
            "introduction": "在解决了积分算法的核心稳定性问题后，我们转向分子动力学中处理内部自由度的另一种常用技术：约束算法。像SHAKE和RATTLE这样的算法通过固定高频振动的键长或键角，允许使用更大的时间步长。然而，这些算法的效率和鲁棒性在很大程度上取决于求解约束力所涉及的线性系统的条件数，该练习将指导你通过编程实践来量化这种依赖关系，从而深入理解约束网络拓扑结构如何影响模拟的性能。",
            "id": "4248797",
            "problem": "考虑在正则系综（粒子数、体积和温度恒定）中，金属电极附近电解质的约束分子动力学。该系统具有一个密集的氢键网络，其中某些位点间的距离被强制作为完整约束。从以下基本原理开始：\n\n- 粒子 $i$ 的牛顿第二运动定律：$m_i \\ddot{\\mathbf{r}}_i = \\mathbf{F}_i + \\sum_{k=1}^{m} \\lambda_k \\nabla_{\\mathbf{r}_i} g_k(\\mathbf{q})$，其中 $m_i$ 是质量，$\\mathbf{r}_i \\in \\mathbb{R}^3$ 是位置，$\\mathbf{F}_i$ 是非约束力，$\\lambda_k$ 是拉格朗日乘子，而 $g_k(\\mathbf{q}) = 0$ 是完整约束，其中 $\\mathbf{q} = (\\mathbf{r}_1,\\dots,\\mathbf{r}_N)$。\n- 位点 $i$ 和 $j$ 之间的完整距离约束形式为 $g_{(i,j)}(\\mathbf{q}) = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2 - d_{ij}^2 = 0$，其中 $d_{ij}  0$ 是目标距离。\n- 约束雅可比矩阵 $\\mathbf{J}(\\mathbf{q}) \\in \\mathbb{R}^{m \\times 3N}$ 的第 $k=(i,j)$ 行由 $g_k(\\mathbf{q})$ 相对于所有坐标的梯度给出：对于对应于位点 $i$ 的列，$\\frac{\\partial g_k}{\\partial \\mathbf{r}_i} = 2(\\mathbf{r}_i - \\mathbf{r}_j)$；对于位点 $j$ 的列，$\\frac{\\partial g_k}{\\partial \\mathbf{r}_j} = -2(\\mathbf{r}_i - \\mathbf{r}_j)$；其他位置为零。\n- 在**对称双曲分析动能（SHAKE）算法**和**关联拉格朗日轨迹局部误差算法（RATTLE）**中，线性化约束投影步骤需要求解对称正定系统 $\\mathbf{A} \\boldsymbol{\\lambda} = \\mathbf{b}$，其中 $\\mathbf{A} = \\mathbf{J} \\mathbf{M}^{-1} \\mathbf{J}^\\top$，$\\mathbf{M} = \\operatorname{diag}(m_1 \\mathbf{I}_3,\\dots,m_N \\mathbf{I}_3)$ 是块对角质量矩阵。\n- 矩阵 $\\mathbf{B}$ 的 $2$-范数条件数为 $\\kappa_2(\\mathbf{B}) = \\|\\mathbf{B}\\|_2 \\|\\mathbf{B}^{-1}\\|_2$，对于 $\\mathbf{J}$，该值等于最大奇异值与最小奇异值之比；对于对称正定矩阵 $\\mathbf{A}$，该值等于最大特征值与最小特征值之比。\n- 共轭梯度法求解 $\\mathbf{A} \\boldsymbol{\\lambda} = \\mathbf{b}$ 的收敛性受 $\\kappa_2(\\mathbf{A})$ 的影响，其误差界为 $\\|\\mathbf{e}_k\\|_{\\mathbf{A}} \\leq 2 \\left( \\frac{\\sqrt{\\kappa_2(\\mathbf{A})} - 1}{\\sqrt{\\kappa_2(\\mathbf{A})} + 1} \\right)^k \\|\\mathbf{e}_0\\|_{\\mathbf{A}}$，其中 $\\mathbf{e}_k$ 是 $k$ 次迭代后的误差。\n\n任务：实现一个程序，对于给定的一组代表电极附近电解质中类氢键连接的位点位置、质量和距离约束，构建约束雅可比矩阵 $\\mathbf{J}$，计算 $\\kappa_2(\\mathbf{J})$，构建 $\\mathbf{A} = \\mathbf{J} \\mathbf{M}^{-1} \\mathbf{J}^\\top$，计算 $\\kappa_2(\\mathbf{A})$，并使用上述误差界估计将误差的 $\\mathbf{A}$-范数减小一个因子 $\\epsilon$ 所需的共轭梯度迭代的最少次数。使用 $\\epsilon = 10^{-8}$。\n\n科学真实性：氢键供体-受体距离通常在 $0.28\\,\\mathrm{nm}$ 到 $0.32\\,\\mathrm{nm}$ 的范围内，电极附近的位置的 $z$ 坐标在 $0.2\\,\\mathrm{nm}$ 到 $0.4\\,\\mathrm{nm}$ 的量级。使用代表水和常见离子的原子质量：氢 $1\\,\\mathrm{amu}$，氧 $16\\,\\mathrm{amu}$，钠 $23\\,\\mathrm{amu}$，氯 $35.5\\,\\mathrm{amu}$。\n\n本问题不使用角度单位。所有位置和距离的单位均为纳米，质量单位为原子质量单位。输出（条件数和迭代次数）是无量纲的。\n\n测试套件：使用以下四个参数集，以探究条件数和求解器行为的不同方面。在每种情况下，定义位置 $\\mathbf{r}_i$（单位为 $\\mathrm{nm}$）、质量 $m_i$（单位为 $\\mathrm{amu}$）以及约束 $(i,j,d_{ij})$，其中 $d_{ij}$ 等于当前位点间距离，以表示已满足的类氢键约束。\n\n- 案例 1 (电极附近中等连接度的环状结构):\n  - $N = 6$ 个位点，位置如下\n    - $\\mathbf{r}_0 = (0.000, 0.000, 0.300)$\n    - $\\mathbf{r}_1 = (0.280, 0.000, 0.310)$\n    - $\\mathbf{r}_2 = (0.140, 0.240, 0.290)$\n    - $\\mathbf{r}_3 = (-0.140, 0.240, 0.320)$\n    - $\\mathbf{r}_4 = (-0.280, 0.000, 0.300)$\n    - $\\mathbf{r}_5 = (-0.140, -0.240, 0.280)$\n  - 质量: 对所有 $i$，$m_i = 18.0$。\n  - 约束: $(0,1)$、$(1,2)$、$(2,3)$、$(3,4)$、$(4,5)$、$(5,0)$、$(0,2)$、$(2,4)$，其中 $d_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|$。\n\n- 案例 2 (电极附近带有冗余长程连接的近共线链):\n  - $N = 5$ 个位点，位置如下\n    - $\\mathbf{r}_0 = (-0.400, 0.000, 0.220)$\n    - $\\mathbf{r}_1 = (-0.200, 0.000, 0.210)$\n    - $\\mathbf{r}_2 = (0.000, 0.000, 0.200)$\n    - $\\mathbf{r}_3 = (0.200, 0.000, 0.210)$\n    - $\\mathbf{r}_4 = (0.400, 0.000, 0.220)$\n  - 质量: 对所有 $i$，$m_i = 18.0$。\n  - 约束: $(0,1)$、$(1,2)$、$(2,3)$、$(3,4)$、$(0,4)$、$(1,3)$，其中 $d_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|$。\n\n- 案例 3 (中等连接度网络中的质量异质性):\n  - $N = 6$ 个位点，位置与案例 1 相同。\n  - 质量: 分别为 $(16.0, 1.0, 23.0, 35.5, 16.0, 1.0)$ amu。\n  - 约束: 与案例 1 相同，其中 $d_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|$。\n\n- 案例 4 (电极附近良态稀疏的类四面体簇):\n  - $N = 4$ 个位点，位置如下\n    - $\\mathbf{r}_0 = (0.000, 0.000, 0.250)$\n    - $\\mathbf{r}_1 = (0.200, 0.100, 0.300)$\n    - $\\mathbf{r}_2 = (-0.150, 0.200, 0.280)$\n    - $\\mathbf{r}_3 = (0.050, -0.180, 0.220)$\n  - 质量: 对所有 $i$，$m_i = 18.0$。\n  - 约束: $(0,1)$、$(1,2)$、$(2,3)$，其中 $d_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|$。\n\n算法要求:\n1. 通过为每个约束 $k=(i,j)$ 堆叠行来构建 $\\mathbf{J}$：仅在第 $i$ 对应的 3 列中填充 $2(\\mathbf{r}_i - \\mathbf{r}_j)$，在第 $j$ 对应的 3 列中填充 $-2(\\mathbf{r}_i - \\mathbf{r}_j)$。\n2. 使用 $\\mathbf{J}$ 的奇异值分解，通过最大奇异值与最小奇异值之比计算 $\\kappa_2(\\mathbf{J})$。如果最小奇异值在数值上低于 $10^{-12}$，则将条件数视为极端病态，使用一个大的哨兵值（例如 $10^{12}$），同时继续计算。\n3. 构建 $\\mathbf{A} = \\mathbf{J} \\mathbf{M}^{-1} \\mathbf{J}^\\top$。将其最大特征值与最小特征值之比作为 $\\kappa_2(\\mathbf{A})$。如果最小特征值在数值上低于 $10^{-12}$，使用相同的哨兵值 $10^{12}$。\n4. 使用以下界限估计达到 $\\|\\mathbf{e}_k\\|_{\\mathbf{A}} \\leq \\epsilon \\|\\mathbf{e}_0\\|_{\\mathbf{A}}$（其中 $\\epsilon = 10^{-8}$）所需的最小共轭梯度迭代次数 $k$：\n   $$k \\ge \\frac{\\ln(\\epsilon/2)}{\\ln\\!\\left(\\frac{\\sqrt{\\kappa_2(\\mathbf{A})} - 1}{\\sqrt{\\kappa_2(\\mathbf{A})} + 1}\\right)}.$$\n   使用满足该不等式的最小整数 $k$（向上取整）。如果 $\\kappa_2(\\mathbf{A}) \\le 1$，则取 $k=1$。\n5. 为保证数值稳健性，必须小心处理所有浮点阈值，以避免除以零。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试案例贡献一个子列表 $[\\kappa_2(\\mathbf{J}), \\kappa_2(\\mathbf{A}), k]$。将每个条件数格式化为保留六位小数的浮点数，将每个迭代次数 $k$ 格式化为整数，例如：[[1.234567,987.654321,42],[...],...].",
            "solution": "手头的问题是计算物理学领域中一个明确定义的练习，具体来说，是在采用完整约束的分子动力学模拟领域。任务是分析在使用 SHAKE 或 RATTLE 等算法强制施加此类约束时产生的线性系统的数值稳定性和收敛特性。该分析的核心是计算两个关键矩阵的条件数，即约束雅可比矩阵 $\\mathbf{J}$ 和对称正定矩阵 $\\mathbf{A} = \\mathbf{J} \\mathbf{M}^{-1} \\mathbf{J}^\\top$，并随后估计共轭梯度 (CG) 方法求解相关线性系统的性能。\n\n该问题在科学上和数学上是合理的。它正确地表述了受约束力学系统的运动方程，引入了距离约束的标准定义，并准确地定义了雅可比矩阵。矩阵 $\\mathbf{A}$ 是 SHAKE 和 RATTLE 中用于确定约束力（通过拉格朗日乘子 $\\boldsymbol{\\lambda}$）的投影方法的核心。条件数 $\\kappa_2(\\mathbf{A})$ 是决定像 CG 这样的迭代求解器收敛速度的关键因素，而所提供的误差界是标准的教科书结果。物理参数和测试案例是现实的，并经过精心设计，以探究约束网络拓扑和质量分布的不同情景，已知这些情景会影响数值条件。因此，该问题是有效的，并且可以按所述方式解决。\n\n该解决方案通过为每个提供的测试案例实施以下步骤序列来推进。\n\n首先，我们建立基本的数学对象。该系统由 $N$ 个粒子组成，其状态由一个 $3N$ 维的位置向量 $\\mathbf{q} = (\\mathbf{r}_1, \\dots, \\mathbf{r}_N)$ 描述。我们给定 $m$ 个形式为 $g_k(\\mathbf{q}) = 0$ 的完整约束。对于粒子 $i$ 和 $j$ 之间的距离约束，其形式为 $g_{(i,j)}(\\mathbf{q}) = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2 - d_{ij}^2 = 0$。\n\n算法流程如下：\n\n1.  **构建约束雅可比矩阵 $\\mathbf{J}$**：\n    雅可比矩阵 $\\mathbf{J}$ 是一个 $m \\times 3N$ 的矩阵，其中每行 $k$ 对应于单个约束函数 $g_k$ 的梯度。对于距离约束 $g_{(i,j)}$，梯度 $\\nabla_{\\mathbf{q}} g_{(i,j)}$ 仅在关于粒子 $i$ 和 $j$ 坐标的分量上非零。具体来说，$\\nabla_{\\mathbf{r}_i} g_{(i,j)} = 2(\\mathbf{r}_i - \\mathbf{r}_j)$ 且 $\\nabla_{\\mathbf{r}_j} g_{(i,j)} = 2(\\mathbf{r}_j - \\mathbf{r}_i) = -2(\\mathbf{r}_i - \\mathbf{r}_j)$。为了构建 $\\mathbf{J}$，我们初始化一个 $m \\times 3N$ 的零矩阵。对于粒子 $i$ 和 $j$ 之间的每个约束 $k$（从 $0$ 到 $m-1$），我们计算向量差 $\\mathbf{\\Delta r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$。子向量 $2\\mathbf{\\Delta r}_{ij}$ 被放置在第 $k$ 行的第 $3i$ 到 $3i+2$ 列，而子向量 $-2\\mathbf{\\Delta r}_{ij}$ 被放置在同一行的第 $3j$ 到 $3j+2$ 列。\n\n2.  **计算雅可比矩阵条件数 $\\kappa_2(\\mathbf{J})$**：\n    一个非方阵 $\\mathbf{J}$ 的 $2$-范数条件数是其最大奇异值与最小奇异值之比，即 $\\kappa_2(\\mathbf{J}) = \\sigma_{\\max} / \\sigma_{\\min}$。奇异值通过奇异值分解 (SVD) 计算。如果最小奇异值 $\\sigma_{\\min}$ 接近于零（低于指定的阈值 $10^{-12}$），这表示约束是线性相关或近似线性相关的。这标志着一个不适定的物理情况，例如冗余约束。在这种情况下，$\\kappa_2(\\mathbf{J})$ 被赋予一个大的哨兵值 $10^{12}$。否则，它直接由该比率计算得出。\n\n3.  **构建 SHAKE/RATTLE 矩阵 $\\mathbf{A}$**：\n    矩阵 $\\mathbf{A}$ 定义为 $\\mathbf{A} = \\mathbf{J} \\mathbf{M}^{-1} \\mathbf{J}^\\top$。矩阵 $\\mathbf{M}^{-1}$ 是一个 $3N \\times 3N$ 的对角矩阵，其对角线元素是粒子质量的倒数，即 $\\mathbf{M}^{-1} = \\operatorname{diag}(m_1^{-1}, m_1^{-1}, m_1^{-1}, \\dots, m_N^{-1}, m_N^{-1}, m_N^{-1})$。该乘积通过一系列矩阵乘法计算。首先，我们可以通过将 $\\mathbf{J}$ 右乘 $\\mathbf{M}^{-1}$ 来形成中间矩阵 $\\mathbf{J}_{\\text{mod}} = \\mathbf{J}\\mathbf{M}^{-1}$。由于 $\\mathbf{M}^{-1}$ 是对角矩阵，这等效于缩放 $\\mathbf{J}$ 的列：第 $3k+c$ 列（对于 $c \\in \\{0,1,2\\}$）被乘以 $m_k^{-1}$。然后，$\\mathbf{A}$ 通过 $\\mathbf{A} = \\mathbf{J}_{\\text{mod}} \\mathbf{J}^\\top$ 计算。得到的矩阵 $\\mathbf{A}$ 是一个 $m \\times m$ 的对称矩阵。\n\n4.  **计算条件数 $\\kappa_2(\\mathbf{A})$**：\n    由于 $\\mathbf{A}$ 是对称的，并且对于非冗余约束是正定的，其 $2$-范数条件数是其最大特征值与最小特征值之比，即 $\\kappa_2(\\mathbf{A}) = \\lambda_{\\max} / \\lambda_{\\min}$。特征值使用针对对称矩阵的高效算法计算。与雅可比矩阵类似，如果最小特征值 $\\lambda_{\\min}$ 低于数值阈值 $10^{-12}$，我们将 $\\kappa_2(\\mathbf{A})$ 赋值为 $10^{12}$ 以表示严重的病态条件。\n\n5.  **估计共轭梯度迭代次数 $k$**：\n    将误差的 $\\mathbf{A}$-范数减小一个因子 $\\epsilon = 10^{-8}$ 所需的 CG 迭代次数 $k$，使用给定的不等式进行估计：\n    $$ \\|\\mathbf{e}_k\\|_{\\mathbf{A}} \\le 2 \\left( \\frac{\\sqrt{\\kappa_2(\\mathbf{A})} - 1}{\\sqrt{\\kappa_2(\\mathbf{A})} + 1} \\right)^k \\|\\mathbf{e}_0\\|_{\\mathbf{A}} $$\n    我们求解最小的整数 $k$，使得 $2 \\left( \\frac{\\sqrt{\\kappa_2(\\mathbf{A})} - 1}{\\sqrt{\\kappa_2(\\mathbf{A})} + 1} \\right)^k \\le \\epsilon$。取自然对数并重新整理可得：\n    $$ k \\ge \\frac{\\ln(\\epsilon/2)}{\\ln\\left(\\frac{\\sqrt{\\kappa} - 1}{\\sqrt{\\kappa} + 1}\\right)} $$\n    其中 $\\kappa = \\kappa_2(\\mathbf{A})$。我们计算该值的向上取整以找到最小整数 $k$。对于一个条件数为 $\\kappa \\le 1.0$ 的理想条件矩阵，存在一个特殊情况。在这种情况下，CG 方法理论上在一次迭代中收敛，因此我们设置 $k=1$。此过程应用于指定的四个测试案例中的每一个。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It constructs the Jacobian J, computes its condition number,\n    constructs the SHAKE/RATTLE matrix A, computes its condition number,\n    and estimates the number of Conjugate Gradient iterations.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: Moderately connected near-electrode ring\n        {\n            \"positions\": np.array([\n                [0.000, 0.000, 0.300], [0.280, 0.000, 0.310], [0.140, 0.240, 0.290],\n                [-0.140, 0.240, 0.320], [-0.280, 0.000, 0.300], [-0.140, -0.240, 0.280]\n            ]),\n            \"masses\": np.full(6, 18.0),\n            \"constraints\": [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0), (0, 2), (2, 4)],\n        },\n        # Case 2: Near-collinear chain with redundant long links\n        {\n            \"positions\": np.array([\n                [-0.400, 0.000, 0.220], [-0.200, 0.000, 0.210], [0.000, 0.000, 0.200],\n                [0.200, 0.000, 0.210], [0.400, 0.000, 0.220]\n            ]),\n            \"masses\": np.full(5, 18.0),\n            \"constraints\": [(0, 1), (1, 2), (2, 3), (3, 4), (0, 4), (1, 3)],\n        },\n        # Case 3: Mass heterogeneity\n        {\n            \"positions\": np.array([\n                [0.000, 0.000, 0.300], [0.280, 0.000, 0.310], [0.140, 0.240, 0.290],\n                [-0.140, 0.240, 0.320], [-0.280, 0.000, 0.300], [-0.140, -0.240, 0.280]\n            ]),\n            \"masses\": np.array([16.0, 1.0, 23.0, 35.5, 16.0, 1.0]),\n            \"constraints\": [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0), (0, 2), (2, 4)],\n        },\n        # Case 4: Well-conditioned sparse tetrahedral-like cluster\n        {\n            \"positions\": np.array([\n                [0.000, 0.000, 0.250], [0.200, 0.100, 0.300],\n                [-0.150, 0.200, 0.280], [0.050, -0.180, 0.220]\n            ]),\n            \"masses\": np.full(4, 18.0),\n            \"constraints\": [(0, 1), (1, 2), (2, 3)],\n        }\n    ]\n\n    results = []\n    \n    # Numerical thresholds and parameters\n    SINGULAR_TOL = 1e-12\n    EIGEN_TOL = 1e-12\n    SENTINEL_KAPPA = 1e12\n    EPSILON_CG = 1e-8\n\n    for case in test_cases:\n        positions = case[\"positions\"]\n        masses = case[\"masses\"]\n        constraints = case[\"constraints\"]\n        \n        N = len(positions)\n        m = len(constraints)\n\n        # 1. Construct the Jacobian J\n        J = np.zeros((m, 3 * N))\n        for k, (i, j) in enumerate(constraints):\n            r_i = positions[i]\n            r_j = positions[j]\n            grad_r_i = 2 * (r_i - r_j)\n            \n            J[k, 3*i : 3*i+3] = grad_r_i\n            J[k, 3*j : 3*j+3] = -grad_r_i\n\n        # 2. Compute kappa_2(J)\n        singular_values = np.linalg.svd(J, compute_uv=False)\n        s_min = singular_values[-1] if len(singular_values)  0 else 0\n        \n        if s_min  SINGULAR_TOL:\n            kappa_J = SENTINEL_KAPPA\n        else:\n            s_max = singular_values[0]\n            kappa_J = s_max / s_min\n\n        # 3. Construct A = J M^-1 J^T\n        # Create the diagonal of M^-1\n        inv_mass_diag = np.repeat(1.0 / masses, 3)\n        M_inv = np.diag(inv_mass_diag)\n        A = J @ M_inv @ J.T\n\n        # 4. Compute kappa_2(A)\n        # Use eigvalsh for symmetric matrices, it's faster and more stable\n        eigenvalues = np.linalg.eigvalsh(A)\n        lambda_min = eigenvalues[0] if len(eigenvalues)  0 else 0\n\n        if lambda_min  EIGEN_TOL:\n            kappa_A = SENTINEL_KAPPA\n        else:\n            lambda_max = eigenvalues[-1]\n            kappa_A = lambda_max / lambda_min\n            \n        # 5. Estimate CG iterations k\n        if kappa_A = 1.0:\n            k = 1\n        else:\n            sqrt_kappa_A = np.sqrt(kappa_A)\n            ratio = (sqrt_kappa_A - 1) / (sqrt_kappa_A + 1)\n            # Handle the case where ratio is extremely close to 1 due to large kappa\n            if ratio  1.0 - 1e-15:\n                # Use Taylor expansion for ln(x) around x=1, ln(1-y) approx -y\n                # ratio = 1 - 2/(sqrt_kappa_A+1) approx 1 - 2/sqrt_kappa_A\n                # log(ratio) approx -2/sqrt_kappa_A\n                log_ratio = -2.0 / sqrt_kappa_A\n            else:\n                log_ratio = np.log(ratio)\n\n            k_float = np.log(EPSILON_CG / 2.0) / log_ratio\n            k = int(np.ceil(k_float))\n\n        results.append([kappa_J, kappa_A, k])\n\n    # Format the final output string\n    formatted_results = []\n    for res_set in results:\n        kappa_J_str = f\"{res_set[0]:.6f}\"\n        kappa_A_str = f\"{res_set[1]:.6f}\"\n        k_str = str(res_set[2])\n        formatted_results.append(f\"[{kappa_J_str},{kappa_A_str},{k_str}]\")\n        \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "对于电化学体系的模拟，准确处理长程静电相互作用，尤其是在导电界面附近，是至关重要的。恒定电势模拟通常需要使用特殊的边界条件，例如“锡箔”边界条件，来模拟理想导体电极。这项实践提供了一个宝贵的机会，让你通过编程实现一个简化的模型来验证这种先进的静电方法，将数值计算结果与经典的镜像电荷法得出的解析解进行比较，从而检验静电方法和周期性校正的正确性。",
            "id": "4248855",
            "problem": "考虑一个在计算电化学中建模的点电荷，该点电荷是一个电荷量为 $q$ 的单个粒子，位于 $(x,y,z) = (0,0,z_0)$ 位置，在一个位于 $z=0$ 的无限大理想导电电极平面的上方。为验证板层几何结构中导电边界下的**Particle-Particle Particle-Mesh（PPPM）**或**Particle Mesh Ewald（PME）**静电学方法，您将构建一个数值上可处理的晶格求和模拟，并将其预测的力与从经典静电学推导出的精确镜像电荷结果进行比较。其基本依据是库仑定律和下文所述的理想导体泊松方程的边值解。\n\n您必须实现一个程序，该程序能够：\n- 在一个尺寸为 $L_x$、$L_y$、$L_z$ 的模拟单元中，计算位于 $(0,0,z_0)$ 的测试电荷 $q$ 所受静电力的 $z$ 分量。该模拟单元在所有三个方向上均采用周期性边界条件，但在 Ewald 意义下使用导电边界条件（锡箔边界）。\n- 通过经典的镜像法来表示位于 $z=0$ 的导电平面：对于真实电荷的每一个周期性副本，都在平面下方的镜像反射位置放置一个电荷量为 $-q$ 的镜像电荷。\n- 通过对整数副本索引 $m \\in [-N_x, N_x]$、$n \\in [-N_y, N_y]$ 和 $p \\in [-N_z, N_z]$ 进行截断求和，来近似无限的镜像电荷晶格。每个镜像电荷位于 $(x,y,z) = (m L_x, n L_y, -z_0 + p L_z)$。\n- 使用形式为 $\\mathbf{F} = k_e \\, q_1 q_2 \\, \\mathbf{r} / \\|\\mathbf{r}\\|^3$ 的库仑定律，其中 $k_e = 1/(4\\pi \\varepsilon_0)$，$\\varepsilon_0$ 为真空介电常数。计算并累加每个镜像电荷对真实电荷的作用力贡献。您的推导和实现中的所有数学实体都必须遵循此定律。\n- 应用适用于锡箔边界条件的板层校正，以消除沿 $z$ 方向的周期性板层之间的伪耦合。该校正必须用模拟单元的总偶极矩分量 $M_z$ 和单元体积 $V = L_x L_y L_z$ 来表示，并从使用基本静电学和泊松方程处理板层几何结构 Ewald 求和中的零波矢（$k=0$）模式推导得出。您必须按照您的解答中推导出的方式，实现这个沿 $z$ 方向的均匀校正力。\n- 将数值计算的总 $z$ 方向力（截断晶格求和加板层校正）与点电荷在无限大理想导电平面附近的解析镜像电荷力进行比较，并返回定义为 $(F_{z}^{\\text{num}} - F_{z}^{\\text{exact}})/|F_{z}^{\\text{exact}}|$ 的相对误差，该误差为一个无量纲浮点数。\n\n所有量都必须在国际单位制（SI）中处理。距离（如 $z_0$、$L_x$、$L_y$ 和 $L_z$）必须以米为单位，电荷 $q$ 以库仑为单位，力以牛顿为单位。周期性副本以位于 $(0,0,z_0)$ 的真实电荷为中心，截断求和应严格按照规定实现。本问题不涉及角度，因此不需要角度单位。\n\n测试套件：\n实现您的程序，以评估以下四个科学上一致的参数集的相对误差，这些参数集探测了不同的数值和物理区域（理想路径、薄真空层/板层强耦合、远场和紧凑的横向周期性）：\n\n- 案例 1：$q = 1.602176634\\times 10^{-19}$ C, $z_0 = 1.0\\times 10^{-9}$ m, $L_x = 5.0\\times 10^{-9}$ m, $L_y = 5.0\\times 10^{-9}$ m, $L_z = 1.0\\times 10^{-7}$ m, $N_x = 2$, $N_y = 2$, $N_z = 2$.\n- 案例 2：$q = 1.602176634\\times 10^{-19}$ C, $z_0 = 2.0\\times 10^{-9}$ m, $L_x = 3.0\\times 10^{-9}$ m, $L_y = 3.0\\times 10^{-9}$ m, $L_z = 2.0\\times 10^{-8}$ m, $N_x = 3$, $N_y = 3$, $N_z = 3$.\n- 案例 3：$q = 1.602176634\\times 10^{-19}$ C, $z_0 = 5.0\\times 10^{-9}$ m, $L_x = 2.0\\times 10^{-8}$ m, $L_y = 2.0\\times 10^{-8}$ m, $L_z = 1.0\\times 10^{-6}$ m, $N_x = 1$, $N_y = 1$, $N_z = 1$.\n- 案例 4：$q = 1.602176634\\times 10^{-19}$ C, $z_0 = 1.5\\times 10^{-9}$ m, $L_x = 1.5\\times 10^{-9}$ m, $L_y = 1.5\\times 10^{-9}$ m, $L_z = 1.5\\times 10^{-7}$ m, $N_x = 1$, $N_y = 1$, $N_z = 2$.\n\n最终输出格式：\n您的程序应生成单行输出，其中包含所有案例的相对误差，形式为逗号分隔的列表，并用方括号括起来（例如，$ [e_1,e_2,e_3,e_4] $），其中每个 $e_i$ 是对应于案例 $i$ 的无量纲相对误差浮点数。",
            "solution": "该问题要求计算在导电平面附近的一个点电荷所受力的数值近似解与精确解析解之间的相对误差。数值近似涉及对周期性镜像电荷的截断晶格求和，并包含针对锡箔边界条件的板层校正项。\n\n解答分三个阶段展开：\n1.  使用镜像法推导精确的静电力。\n2.  构建数值力，包括对镜像电荷的截断直接求和以及针对周期性边界条件的校正项。\n3.  定义和计算相对误差。\n\n所有物理量均以国际单位制（SI）表示。库仑常数为 $k_e = 1/(4\\pi\\varepsilon_0)$，其中 $\\varepsilon_0$ 是真空介电常数。\n\n**1. 解析力 ($F_{z}^{\\text{exact}}$)**\n\n物理系统由一个位于 $z=0$ 的无限大理想导电平面上方的点电荷 $q$ 组成，其位置为 $\\mathbf{r}_q = (0, 0, z_0)$。镜像法为 $z  0$ 区域的静电势和电场提供了精确解。理想导体的边界条件是其表面电势恒定；我们可以将其设为 $\\phi(x,y,0) = 0$。通过移除导电平面并在镜像位置 $\\mathbf{r}_{\\text{im}} = (0, 0, -z_0)$ 引入一个电荷量为 $-q$ 的镜像电荷，可以满足此条件。\n\n此时，真实电荷 $q$ 所受的静电力完全来自于与该镜像电荷的库仑相互作用。从镜像电荷指向真实电荷的位置矢量为：\n$$ \\mathbf{r} = \\mathbf{r}_q - \\mathbf{r}_{\\text{im}} = (0, 0, z_0) - (0, 0, -z_0) = (0, 0, 2z_0) $$\n两个电荷之间的距离为 $\\|\\mathbf{r}\\| = 2z_0$。根据库仑定律，力为：\n$$ \\mathbf{F}_{\\text{exact}} = k_e \\frac{q(-q)}{\\|\\mathbf{r}\\|^3} \\mathbf{r} = -k_e q^2 \\frac{1}{(2z_0)^3} (0, 0, 2z_0) = -k_e q^2 \\frac{2z_0}{8z_0^3} \\hat{\\mathbf{k}} $$\n这个精确力的 $z$ 分量是：\n$$ F_{z}^{\\text{exact}} = -\\frac{k_e q^2}{4z_0^2} $$\n负号表示这是一个吸引力，将电荷 $q$ 拉向该平面。\n\n**2. 数值力 ($F_{z}^{\\text{num}}$)**\n\n数值模型使用一个尺寸为 $L_x, L_y, L_z$ 且带有周期性边界条件的模拟单元来近似无限系统。该力是两个分量的和：一个直接的、截断的晶格求和 ($F_{z}^{\\text{sum}}$) 和一个板层校正项 ($F_{z}^{\\text{corr}}$)。\n\n**2.1. 截断晶格求和 ($F_{z}^{\\text{sum}}$)**\n位于 $z=0$ 的导电平面通过为真实电荷的每个周期性副本创建一个镜像电荷来建模。问题规定，对于整数索引 $m, n, p$，镜像电荷位于位置 $\\mathbf{r}_{mnp}^{\\text{im}} = (mL_x, nL_y, -z_0 + pL_z)$。位于 $\\mathbf{r}_q = (0,0,z_0)$ 的真实电荷所受的力是这些镜像电荷施加的力的总和。求和被截断为 $m \\in [-N_x, N_x]$，$n \\in [-N_y, N_y]$ 和 $p \\in [-N_z, N_z]$。\n\n从一个镜像电荷 $(m,n,p)$ 指向真实电荷的矢量是：\n$$ \\mathbf{r}_{mnp} = \\mathbf{r}_q - \\mathbf{r}_{mnp}^{\\text{im}} = (0, 0, z_0) - (mL_x, nL_y, -z_0 + pL_z) = (-mL_x, -nL_y, 2z_0 - pL_z) $$\n来自该镜像电荷的力的 $z$ 分量贡献是：\n$$ F_{z,mnp} = k_e \\frac{q(-q)}{\\|\\mathbf{r}_{mnp}\\|^3} (\\mathbf{r}_{mnp})_z = -k_e q^2 \\frac{2z_0 - pL_z}{\\left( (mL_x)^2 + (nL_y)^2 + (2z_0 - pL_z)^2 \\right)^{3/2}} $$\n来自截断晶格求和的总力是所有指定索引的和：\n$$ F_{z}^{\\text{sum}} = \\sum_{m=-N_x}^{N_x} \\sum_{n=-N_y}^{N_y} \\sum_{p=-N_z}^{N_z} F_{z,mnp} $$\n\n**2.2. 板层校正力 ($F_{z}^{\\text{corr}}$)**\n在采用 Ewald 求和及锡箔边界条件的 3D 周期性模拟中，单元中的净偶极矩 $\\mathbf{M}$ 会产生一个伪均匀电场。这种人为效应源于倒易空间求和中的 $k=0$（零波矢）项。周期性排列的单元可以被视为一个连续的极化介质，其极化强度为 $\\mathbf{P} = \\mathbf{M}/V$，其中 $V = L_x L_y L_z$ 是单元体积。对于锡箔边界条件，这种极化在介质内部会感应出一个退极化场 $\\mathbf{E}_{\\text{dep}} = -\\mathbf{P}/\\varepsilon_0$。该电场会对电荷施加一个伪力，必须予以校正。\n\n对电荷 $q$ 的校正力为 $\\mathbf{F}^{\\text{corr}} = q(-\\mathbf{E}_{\\text{dep}}) = -q\\mathbf{E}_{\\text{dep}} = q(\\mathbf{P}/\\varepsilon_0) = q\\mathbf{M}/(\\varepsilon_0 V)$。指令要求推导校正力，并且该力必须从计算出的力中*减去*。因此，需要加上的力为 $\\mathbf{F}_{\\text{add}}^{\\text{corr}} = - \\frac{q \\mathbf{M}}{\\varepsilon_0 V}$。\n\n主单元的偶极矩 $\\mathbf{M}$ 由位于 $z_0$ 的真实电荷 $q$ 和位于 $-z_0$ 的其主镜像 $-q$ 计算得出，因为这对电荷代表了产生板层偶极子的基本单元。\n$$ M_z = \\sum_i q_i z_i = q(z_0) + (-q)(-z_0) = 2qz_0 $$\n$x$ 和 $y$ 分量为零。因此，校正力纯粹在 $z$ 方向上：\n$$ F_{z}^{\\text{corr}} = -\\frac{q M_z}{\\varepsilon_0 V} = -\\frac{q(2qz_0)}{\\varepsilon_0 L_x L_y L_z} = -\\frac{2q^2 z_0}{\\varepsilon_0 V} $$\n使用 $k_e = 1/(4\\pi\\varepsilon_0)$，这可以重写为：\n$$ F_{z}^{\\text{corr}} = -8\\pi k_e \\frac{q^2 z_0}{L_x L_y L_z} $$\n总数值力是截断晶格求和与此校正项的和：\n$$ F_{z}^{\\text{num}} = F_{z}^{\\text{sum}} + F_{z}^{\\text{corr}} $$\n\n**3. 相对误差计算**\n\n数值力与精确力之间的相对误差定义为：\n$$ \\text{RelErr} = \\frac{F_{z}^{\\text{num}} - F_{z}^{\\text{exact}}}{|F_{z}^{\\text{exact}}|} $$\n为确保计算稳定性，我们可以注意到晶格求和中索引为 $(m,n,p)=(0,0,0)$ 的项是：\n$$ F_{z,000} = -k_e q^2 \\frac{2z_0}{\\left( (2z_0)^2 \\right)^{3/2}} = -k_e q^2 \\frac{2z_0}{8z_0^3} = -\\frac{k_e q^2}{4z_0^2} = F_{z}^{\\text{exact}} $$\n因此，误差是所有其他贡献的总和：\n$$ F_{z}^{\\text{num}} - F_{z}^{\\text{exact}} = \\left( \\sum_{(m,n,p) \\neq (0,0,0)} F_{z,mnp} \\right) + F_{z}^{\\text{corr}} $$\n相对误差则计算为：\n$$ \\text{RelErr} = \\frac{\\left( \\sum_{m=-N_x}^{N_x} \\sum_{n=-N_y}^{N_y} \\sum_{p=-N_z}^{N_z} \\text{ where } (m,n,p)\\neq(0,0,0) \\right) F_{z,mnp} + F_{z}^{\\text{corr}}}{|F_{z}^{\\text{exact}}|} $$\n这种表述方式避免了两个相近大数的相减问题，并直接计算偏差。实现将遵循这一最终表达式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import constants\n\ndef solve():\n    \"\"\"\n    Computes the relative error in the electrostatic force on a point charge\n    near a conducting plane, comparing a truncated lattice sum with a slab\n    correction to the exact analytical result.\n    \"\"\"\n    # Define physical constants from scipy.constants for high precision.\n    # The problem specifies using k_e = 1/(4*pi*epsilon_0).\n    q_val = constants.physical_constants['elementary charge'][0]\n    epsilon_0 = constants.physical_constants['vacuum electric permittivity'][0]\n    k_e = 1 / (4 * np.pi * epsilon_0)\n\n    # Test cases as defined in the problem statement.\n    # Each case is a tuple: (q, z_0, L_x, L_y, L_z, N_x, N_y, N_z)\n    test_cases = [\n        (q_val, 1.0e-9, 5.0e-9, 5.0e-9, 1.0e-7, 2, 2, 2),\n        (q_val, 2.0e-9, 3.0e-9, 3.0e-9, 2.0e-8, 3, 3, 3),\n        (q_val, 5.0e-9, 2.0e-8, 2.0e-8, 1.0e-6, 1, 1, 1),\n        (q_val, 1.5e-9, 1.5e-9, 1.5e-9, 1.5e-7, 1, 1, 2),\n    ]\n\n    results = []\n    for case in test_cases:\n        q, z_0, L_x, L_y, L_z, N_x, N_y, N_z = case\n        \n        # 1. Calculate the exact analytical force\n        f_z_exact = -k_e * q**2 / (4 * z_0**2)\n\n        # 2. Calculate the numerical force\n        # 2.1. Truncated lattice sum part\n        f_z_sum = 0.0\n        \n        # Sum over all image charges in the truncated lattice\n        for m in range(-N_x, N_x + 1):\n            for n in range(-N_y, N_y + 1):\n                for p in range(-N_z, N_z + 1):\n                    x_dist_sq = (m * L_x)**2\n                    y_dist_sq = (n * L_y)**2\n                    z_dist = 2 * z_0 - p * L_z\n                    \n                    r_sq = x_dist_sq + y_dist_sq + z_dist**2\n                    \n                    # The denominator can only be zero if x, y, and z distances are all zero.\n                    # This is not possible for z_0  0 and integer replica indices.\n                    if r_sq == 0:\n                        continue\n                    \n                    r = np.sqrt(r_sq)\n                    \n                    f_z_mnp = -k_e * q**2 * z_dist / (r**3)\n                    f_z_sum += f_z_mnp\n\n        # 2.2. Slab correction part\n        V = L_x * L_y * L_z  # Volume of the simulation cell\n        # Dipole moment of the primary cell (charge q at z_0 and image -q at -z_0)\n        M_z = 2 * q * z_0\n        f_z_corr = - (q * M_z) / (epsilon_0 * V)\n        \n        # 2.3. Total numerical force\n        f_z_num = f_z_sum + f_z_corr\n\n        # 3. Calculate the relative error\n        relative_error = (f_z_num - f_z_exact) / abs(f_z_exact)\n        results.append(relative_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}