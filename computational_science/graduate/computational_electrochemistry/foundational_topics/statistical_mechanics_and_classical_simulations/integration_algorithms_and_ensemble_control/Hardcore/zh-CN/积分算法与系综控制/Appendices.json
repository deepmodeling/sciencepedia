{
    "hands_on_practices": [
        {
            "introduction": "分子模型，例如杜德（Drude）振子，常常包含给数值积分带来巨大挑战的刚性谐波键。本练习将引导你推导隐式中点积分器，通过解析证明其对于振荡运动的无条件稳定性，从而理解为何在处理此类刚性系统时它优于显式方法 。",
            "id": "4248837",
            "problem": "在分子动力学模拟中，单个可极化 Drude 对被建模为由谐振弹簧连接的两个点质量：一个位于位置 $\\mathbf{R}_{\\mathrm{C}}$ 的大质量原子核（质量为 $m_{\\mathrm{C}}$）和一个位于位置 $\\mathbf{R}_{\\mathrm{D}}$ 的携带质量的 Drude 粒子（质量为 $m_{\\mathrm{D}}$），它们通过刚度为 $k_{\\mathrm{D}}$ 的弹簧耦合。在没有外场和恒温器力的情况下，质心运动可以分离，相对坐标 $\\mathbf{r} \\equiv \\mathbf{R}_{\\mathrm{D}} - \\mathbf{R}_{\\mathrm{C}}$ 遵循牛顿第二定律，其约化质量为 $\\mu \\equiv \\frac{m_{\\mathrm{C}} m_{\\mathrm{D}}}{m_{\\mathrm{C}} + m_{\\mathrm{D}}}$，角频率为 $\\omega \\equiv \\sqrt{k_{\\mathrm{D}}/\\mu}$：\n$$\n\\mu \\,\\ddot{\\mathbf{r}} = -k_{\\mathrm{D}}\\,\\mathbf{r}.\n$$\n定义状态向量 $\\mathbf{y} \\equiv \\begin{pmatrix} \\mathbf{r} \\\\ \\mathbf{v} \\end{pmatrix}$，其中 $\\mathbf{v} \\equiv \\dot{\\mathbf{r}}$，这样动力学可以写成一阶形式 $\\dot{\\mathbf{y}} = A \\mathbf{y}$，其中 $A$ 是一个常数矩阵。考虑为该 Drude 振子设计一个隐式中点时间积分器，该积分器适用于在正则系综控制（例如 Nosé–Hoover 链式恒温器）下的分子动力学（MD）中使用，但在此我们分析无恒温器（摩擦为 $\\mathbf{0}$）的线性动力学，以分离该方案的内在稳定性。\n\n从牛顿第二定律和一阶表示出发，执行以下操作：\n- 推导线性系统的隐式中点单步映射，形式为 $\\mathbf{y}_{n+1} = M(h)\\,\\mathbf{y}_{n}$，其中 $h$ 是时间步长，$M(h)$ 是一个依赖于 $h$ 和 $A$ 的矩阵。\n- 从这个线性映射中，推导出应用于标量测试方程 $\\dot{y} = \\lambda y$ 的隐式中点方法的标量稳定性函数 $R(z)$，其中 $z \\equiv \\lambda h$。\n- 使用 $R(z)$ 论证该方法对于所有满足 $\\Re(z) \\le 0$ 的 $z$ 是否无条件稳定，并解释与具有纯虚数特征值 $z = \\mathrm{i}\\,\\omega h$ 的无阻尼 Drude 振子相关的特殊情况。\n- 在相同的标量测试问题上，简要比较此隐式中点方法与显式前向 Euler 和速度 Verlet 方法在 $h$ 变化时的稳定性特征，重点关注 $\\omega$ 很大的刚性区域。\n\n将你的最终答案报告为稳定性函数 $R(z)$ 关于 $z$ 的显式解析表达式。不需要进行数值计算。不要包含单位。",
            "solution": "提交分析的问题陈述被认为是有效的。它在科学上基于 Drude 振子的标准物理模型和数值积分的数学原理。该问题提法恰当、客观且自洽，提供了执行所需推导和分析的所有必要定义和方程。其中没有矛盾、歧义或事实不准确之处。因此，我们可以进行形式化的求解。\n\n问题通过二阶常微分方程（ODE）描述了 Drude 振子的相对运动：\n$$\n\\mu \\,\\ddot{\\mathbf{r}} = -k_{\\mathrm{D}}\\,\\mathbf{r}\n$$\n引入角频率 $\\omega \\equiv \\sqrt{k_{\\mathrm{D}}/\\mu}$，方程变为 $\\ddot{\\mathbf{r}} = -\\omega^2 \\mathbf{r}$。为了将其表述为一阶系统，我们定义状态向量 $\\mathbf{y} \\equiv \\begin{pmatrix} \\mathbf{r} \\\\ \\mathbf{v} \\end{pmatrix}$，其中 $\\mathbf{v} \\equiv \\dot{\\mathbf{r}}$。该常微分方程组为：\n$$\n\\dot{\\mathbf{r}} = \\mathbf{v}\n$$\n$$\n\\dot{\\mathbf{v}} = -\\omega^2 \\mathbf{r}\n$$\n这可以写成矩阵形式 $\\dot{\\mathbf{y}} = A \\mathbf{y}$，其中矩阵 $A$ 由下式给出：\n$$\nA = \\begin{pmatrix} 0  1 \\\\ -\\omega^2  0 \\end{pmatrix}\n$$\n注意，对于三维向量 $\\mathbf{r}$ 和 $\\mathbf{v}$， $A$ 中的条目 $1$ 和 $0$ 应理解为 $1 \\cdot I_3$ 和 $0 \\cdot I_3$，其中 $I_3$ 是 $3 \\times 3$ 单位矩阵。形式分析保持不变。\n\n隐式中点法是求解常微分方程 $\\dot{\\mathbf{y}} = f(\\mathbf{y}, t)$ 的一种单步积分器，其规则定义为：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\, f\\left(\\frac{\\mathbf{y}_n + \\mathbf{y}_{n+1}}{2}, t_n + \\frac{h}{2}\\right)\n$$\n其中 $h$ 是时间步长。对于我们的线性、时不变系统，$f(\\mathbf{y}) = A \\mathbf{y}$。将此代入中点法则，得到：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\, A \\left(\\frac{\\mathbf{y}_n + \\mathbf{y}_{n+1}}{2}\\right)\n$$\n这是关于 $\\mathbf{y}_{n+1}$ 的一个隐式方程。我们对其进行重排以用 $\\mathbf{y}_n$ 来求解 $\\mathbf{y}_{n+1}$：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{2} A \\mathbf{y}_n + \\frac{h}{2} A \\mathbf{y}_{n+1}\n$$\n$$\n\\mathbf{y}_{n+1} - \\frac{h}{2} A \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{2} A \\mathbf{y}_n\n$$\n$$\n\\left(I - \\frac{h}{2} A\\right) \\mathbf{y}_{n+1} = \\left(I + \\frac{h}{2} A\\right) \\mathbf{y}_n\n$$\n其中 $I$ 是与 $A$ 维度相同的单位矩阵。求解 $\\mathbf{y}_{n+1}$ 可得单步映射：\n$$\n\\mathbf{y}_{n+1} = \\left(I - \\frac{h}{2} A\\right)^{-1} \\left(I + \\frac{h}{2} A\\right) \\mathbf{y}_n\n$$\n其形式为 $\\mathbf{y}_{n+1} = M(h)\\,\\mathbf{y}_{n}$，传播矩阵为 $M(h) = \\left(I - \\frac{h}{2} A\\right)^{-1} \\left(I + \\frac{h}{2} A\\right)$。\n\n为了推导标量稳定性函数 $R(z)$，我们将相同的方法应用于标量测试方程 $\\dot{y} = \\lambda y$，其中 $\\lambda \\in \\mathbb{C}$。在这种情况下，矩阵 $A$ 就是标量 $\\lambda$。单步映射变为：\n$$\ny_{n+1} = \\left(1 - \\frac{h}{2} \\lambda\\right)^{-1} \\left(1 + \\frac{h}{2} \\lambda\\right) y_n\n$$\n稳定性函数 $R(z)$ 由关系式 $y_{n+1} = R(z) y_n$ 定义，其中 $z \\equiv \\lambda h$。通过比较，我们得到 $R(z)$ 的表达式：\n$$\nR(z) = \\frac{1 + z/2}{1 - z/2} = \\frac{2+z}{2-z}\n$$\n\n接下来，我们分析该方法的稳定性。如果一个数值方法的绝对稳定区域包含整个复平面的左半平面，即对于所有 $\\Re(z) \\le 0$ 的 $z$ 都有 $|R(z)| \\le 1$，则该方法被称为 A-稳定。令 $z = x + iy$，其中 $x, y \\in \\mathbb{R}$ 且 $x \\le 0$。我们计算 $R(z)$ 的模：\n$$\n|R(z)|^2 = \\left| \\frac{1 + (x+iy)/2}{1 - (x+iy)/2} \\right|^2 = \\frac{|(1+x/2) + i(y/2)|^2}{|(1-x/2) - i(y/2)|^2} = \\frac{(1+x/2)^2 + (y/2)^2}{(1-x/2)^2 + (y/2)^2}\n$$\n$$\n|R(z)|^2 = \\frac{1 + x + x^2/4 + y^2/4}{1 - x + x^2/4 + y^2/4}\n$$\n由于我们考虑 $\\Re(z) = x \\le 0$，分母中的项 $-x$ 是非负的。\n- 如果 $x  0$，则 $1+x  1-x$，这意味着分子严格小于分母。因此， $|R(z)|  1$。\n- 如果 $x = 0$，则分子和分母相同，这意味着 $|R(z)| = 1$。\n因此，对于所有满足 $\\Re(z) \\le 0$ 的 $z$，我们有 $|R(z)| \\le 1$。隐式中点法是 A-稳定的。\n\n无阻尼 Drude 振子的特殊情况对应于一个具有纯虚数特征值的系统。矩阵 $A$ 的特征值由特征方程 $\\det(A - \\lambda I) = \\lambda^2 + \\omega^2 = 0$ 的根给出，即 $\\lambda = \\pm i\\omega$。对于标量测试问题，这对应于 $z = \\lambda h = \\pm i\\omega h$。这是一个纯虚数，因此其实部为 $\\Re(z) = 0$。如上所述，对于虚轴上的任何 $z$ ，都有 $|R(z)| = 1$。这意味着，当应用于无阻尼谐振子时，无论时间步长 $h$ 如何，隐式中点法产生的数值轨迹的振幅既不增长也不衰减。该方法精确地保持了系统能量的一个离散模拟量，这个性质被称为辛性（symplecticity）。这使其非常适合于像 Drude 模型这样的哈密顿系统的长时间模拟。\n\n最后，我们比较隐式中点法与其他常见积分器在刚性区域（大 $\\omega$）的稳定性。\n- **隐式中点法：** 如前所示，它是 A-稳定的。对于振子（$z = i\\omega h$），对所有 $h$ 都有 $|R_{IM}(i\\omega h)| = 1$。该方法是无条件稳定的，这使其对于刚性高频振荡具有鲁棒性。\n- **显式前向 Euler 法：** 稳定性函数为 $R_{FE}(z) = 1+z$。对于振子，我们有 $|R_{FE}(i\\omega h)| = |1 + i\\omega h| = \\sqrt{1 + (\\omega h)^2}$。对于任何 $h>0$ 和 $\\omega>0$，该值都严格大于 $1$。数值解的振幅将呈指数增长，这意味着该方法对于纯振荡系统是无条件不稳定的。\n- **速度 Verlet 算法：** 这是一种在 MD 中广泛使用的显式、二阶、辛积分器。它在同样意义上不是单步法，但可以分析其对谐振子问题的稳定性。分析表明，速度 Verlet 算法仅在时间步长 $h$ 满足条件 $\\omega h \\le 2$ 时才稳定。它是条件稳定的。\n\n在刚性区域，即 $\\omega$ 很大时，速度 Verlet 算法的稳定性约束（$h \\le 2/\\omega$）变得极其严格，迫使使用非常小的时间步长。显式 Euler 方法永远不稳定。相比之下，隐式中点法对于任何时间步长 $h$ 的选择都保持稳定，这在高效地积分 Drude 振子的刚性内部运动方面具有决定性优势。",
            "answer": "$$ \\boxed{\\frac{1 + \\frac{z}{2}}{1 - \\frac{z}{2}}} $$"
        },
        {
            "introduction": "为维持刚性分子几何构型，SHAKE 和 RATTLE 等约束算法至关重要，但其效率严重依赖于系统的具体构型。本练习要求你亲手实践，通过编程分析真实氢键网络的约束雅可比矩阵的条件数，从而将分子结构与约束求解器的数值性能直接联系起来 。",
            "id": "4248797",
            "problem": "考虑在正则系综（粒子数、体积和温度恒定）中，金属电极附近电解质的约束分子动力学。该系统具有一个密集的氢键网络，其中某些位点间的距离被作为完整约束强制执行。从以下基本基础开始：\n\n- 粒子 $i$ 的牛顿第二运动定律：$m_i \\ddot{\\mathbf{r}}_i = \\mathbf{F}_i + \\sum_{k=1}^{m} \\lambda_k \\nabla_{\\mathbf{r}_i} g_k(\\mathbf{q})$，其中 $m_i$ 是质量，$\\mathbf{r}_i \\in \\mathbb{R}^3$ 是位置，$\\mathbf{F}_i$ 是非约束力，$\\lambda_k$ 是拉格朗日乘子，而 $g_k(\\mathbf{q}) = 0$ 是完整约束，其中 $\\mathbf{q} = (\\mathbf{r}_1,\\dots,\\mathbf{r}_N)$。\n- 位点 $i$ 和 $j$ 之间的一个完整距离约束形式为 $g_{(i,j)}(\\mathbf{q}) = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2 - d_{ij}^2 = 0$，其中 $d_{ij}  0$ 是目标距离。\n- 约束雅可比矩阵 $\\mathbf{J}(\\mathbf{q}) \\in \\mathbb{R}^{m \\times 3N}$ 的第 $k=(i,j)$ 行由 $g_k(\\mathbf{q})$ 关于所有坐标的梯度给出：对于对应于位点 $i$ 的列，$\\frac{\\partial g_k}{\\partial \\mathbf{r}_i} = 2(\\mathbf{r}_i - \\mathbf{r}_j)$；对于位点 $j$ 的列，$\\frac{\\partial g_k}{\\partial \\mathbf{r}_j} = -2(\\mathbf{r}_i - \\mathbf{r}_j)$；其他列的元素为零。\n- 在 Symmetric Hyperbolic Analytical Kinetic Energy (SHAKE) 算法和 Related Algorithms for Lagrangian Trajectories with Local Errors (RATTLE) 算法中，线性化约束投影步骤需要求解对称正定系统 $\\mathbf{A} \\boldsymbol{\\lambda} = \\mathbf{b}$，其中 $\\mathbf{A} = \\mathbf{J} \\mathbf{M}^{-1} \\mathbf{J}^\\top$，而 $\\mathbf{M} = \\operatorname{diag}(m_1 \\mathbf{I}_3,\\dots,m_N \\mathbf{I}_3)$ 是块对角质量矩阵。\n- 矩阵 $\\mathbf{B}$ 的 2-范数条件数是 $\\kappa_2(\\mathbf{B}) = \\|\\mathbf{B}\\|_2 \\|\\mathbf{B}^{-1}\\|_2$，对于 $\\mathbf{J}$ 而言，它等于最大奇异值与最小奇异值之比；对于对称正定矩阵 $\\mathbf{A}$，它等于最大特征值与最小特征值之比。\n- 对于 $\\mathbf{A} \\boldsymbol{\\lambda} = \\mathbf{b}$，共轭梯度法的收敛性受到 $\\kappa_2(\\mathbf{A})$ 的影响，其误差界为 $\\|\\mathbf{e}_k\\|_{\\mathbf{A}} \\leq 2 \\left( \\frac{\\sqrt{\\kappa_2(\\mathbf{A})} - 1}{\\sqrt{\\kappa_2(\\mathbf{A})} + 1} \\right)^k \\|\\mathbf{e}_0\\|_{\\mathbf{A}}$，其中 $\\mathbf{e}_k$ 是 $k$ 次迭代后的误差。\n\n任务：实现一个程序，该程序针对给定的一组位点位置、质量和距离约束（代表电极附近电解质中的类氢键连接），构建约束雅可比矩阵 $\\mathbf{J}$，计算 $\\kappa_2(\\mathbf{J})$，构建矩阵 $\\mathbf{A} = \\mathbf{J} \\mathbf{M}^{-1} \\mathbf{J}^\\top$，计算 $\\kappa_2(\\mathbf{A})$，并使用上述误差界估计将误差的 $\\mathbf{A}$-范数减小一个因子 $\\epsilon$ 所需的共轭梯度迭代的最小次数。使用 $\\epsilon = 10^{-8}$。\n\n科学真实性：氢键供体-受体距离通常在 $0.28\\,\\mathrm{nm}$ 到 $0.32\\,\\mathrm{nm}$ 的范围内，电极附近位置的 $z$ 坐标在 $0.2\\,\\mathrm{nm}$ 到 $0.4\\,\\mathrm{nm}$ 的量级。使用代表水和常见离子的原子质量：氢 $1\\,\\mathrm{amu}$，氧 $16\\,\\mathrm{amu}$，钠 $23\\,\\mathrm{amu}$，氯 $35.5\\,\\mathrm{amu}$。\n\n本问题不使用角度单位。所有位置和距离的单位均为纳米，质量单位为原子质量单位。输出（条件数和迭代次数）是无量纲的。\n\n测试套件：使用以下四组参数集，以探究条件和求解器行为的不同方面。在每种情况下，定义以 $\\mathrm{nm}$ 为单位的位置 $\\mathbf{r}_i$、以 $\\mathrm{amu}$ 为单位的质量 $m_i$，以及约束 $(i,j,d_{ij})$，其中 $d_{ij}$ 等于当前的位点间距离，以表示已满足的类氢键约束。\n\n- 情况1（电极附近中等连接度的环）：\n  - $N = 6$ 个位点，位置如下\n    - $\\mathbf{r}_0 = (0.000, 0.000, 0.300)$\n    - $\\mathbf{r}_1 = (0.280, 0.000, 0.310)$\n    - $\\mathbf{r}_2 = (0.140, 0.240, 0.290)$\n    - $\\mathbf{r}_3 = (-0.140, 0.240, 0.320)$\n    - $\\mathbf{r}_4 = (-0.280, 0.000, 0.300)$\n    - $\\mathbf{r}_5 = (-0.140, -0.240, 0.280)$\n  - 质量：所有 $i$ 的 $m_i = 18.0$。\n  - 约束：$(0,1)$、$(1,2)$、$(2,3)$、$(3,4)$、$(4,5)$、$(5,0)$、$(0,2)$、$(2,4)$，其中 $d_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|$。\n\n- 情况2（电极附近带有冗余长程连接的近共线链）：\n  - $N = 5$ 个位点，位置如下\n    - $\\mathbf{r}_0 = (-0.400, 0.000, 0.220)$\n    - $\\mathbf{r}_1 = (-0.200, 0.000, 0.210)$\n    - $\\mathbf{r}_2 = (0.000, 0.000, 0.200)$\n    - $\\mathbf{r}_3 = (0.200, 0.000, 0.210)$\n    - $\\mathbf{r}_4 = (0.400, 0.000, 0.220)$\n  - 质量：所有 $i$ 的 $m_i = 18.0$。\n  - 约束：$(0,1)$、$(1,2)$、$(2,3)$、$(3,4)$、$(0,4)$、$(1,3)$，其中 $d_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|$。\n\n- 情况3（中等连接度网络中的质量异质性）：\n  - $N = 6$ 个位点，位置与情况1相同。\n  - 质量：分别为 $(16.0, 1.0, 23.0, 35.5, 16.0, 1.0)$ amu。\n  - 约束：与情况1相同，其中 $d_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|$。\n\n- 情况4（电极附近条件良好的稀疏类四面体簇）：\n  - $N = 4$ 个位点，位置如下\n    - $\\mathbf{r}_0 = (0.000, 0.000, 0.250)$\n    - $\\mathbf{r}_1 = (0.200, 0.100, 0.300)$\n    - $\\mathbf{r}_2 = (-0.150, 0.200, 0.280)$\n    - $\\mathbf{r}_3 = (0.050, -0.180, 0.220)$\n  - 质量：所有 $i$ 的 $m_i = 18.0$。\n  - 约束：$(0,1)$、$(1,2)$、$(2,3)$，其中 $d_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|$。\n\n算法要求：\n1. 对每个约束 $k=(i,j)$ 堆叠行来构建 $\\mathbf{J}$：仅用 $2(\\mathbf{r}_i - \\mathbf{r}_j)$ 填充 $i$ 的 $3$ 个列，用 $-2(\\mathbf{r}_i - \\mathbf{r}_j)$ 填充 $j$ 的 $3$ 个列。\n2. 使用 $\\mathbf{J}$ 的奇异值分解，计算 $\\kappa_2(\\mathbf{J})$ 作为最大奇异值与最小奇异值之比。如果最小奇异值在数值上低于 $10^{-12}$，则使用一个大的哨兵值（例如 $10^{12}$）将条件数视为极端病态，并继续进行计算。\n3. 构建 $\\mathbf{A} = \\mathbf{J} \\mathbf{M}^{-1} \\mathbf{J}^\\top$。计算 $\\kappa_2(\\mathbf{A})$ 作为其最大特征值与最小特征值之比。如果最小特征值在数值上低于 $10^{-12}$，则使用相同的哨兵值 $10^{12}$。\n4. 估计最小共轭梯度迭代次数 $k$，以达到 $\\|\\mathbf{e}_k\\|_{\\mathbf{A}} \\leq \\epsilon \\|\\mathbf{e}_0\\|_{\\mathbf{A}}$（其中 $\\epsilon = 10^{-8}$），使用以下不等式界：\n   $$k \\ge \\frac{\\ln(\\epsilon/2)}{\\ln\\!\\left(\\frac{\\sqrt{\\kappa_2(\\mathbf{A})} - 1}{\\sqrt{\\kappa_2(\\mathbf{A})} + 1}\\right)}.$$\n   使用满足该不等式的最小整数 $k$（向上取整）。如果 $\\kappa_2(\\mathbf{A}) \\le 1$，则取 $k=1$。\n5. 为确保数值鲁棒性，必须小心处理所有浮点阈值，以避免除以零。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个子列表 $[\\kappa_2(\\mathbf{J}), \\kappa_2(\\mathbf{A}), k]$。将每个条件数格式化为具有六位小数的浮点数，并将每个迭代次数 $k$ 格式化为整数，例如：[[1.234567,987.654321,42],[...],...]。",
            "solution": "当前的问题是计算物理学领域中的一个明确定义的练习，具体涉及采用完整约束的分子动力学模拟。任务是分析在使用 SHAKE 或 RATTLE 等算法施加此类约束时产生的线性系统的数值稳定性和收敛特性。此分析的核心是计算两个关键矩阵——约束雅可比矩阵 $\\mathbf{J}$ 和对称正定矩阵 $\\mathbf{A} = \\mathbf{J} \\mathbf{M}^{-1} \\mathbf{J}^\\top$——的条件数，并随后估计使用共轭梯度 (CG) 法求解相关线性系统的性能。\n\n该问题在科学和数学上是合理的。它正确地构建了受约束力学系统的运动方程，引入了距离约束的标准定义，并准确地定义了雅可比矩阵。矩阵 $\\mathbf{A}$ 是 SHAKE 和 RATTLE 中用于确定约束力（通过拉格朗日乘子 $\\boldsymbol{\\lambda}$）的投影方法的核心。条件数 $\\kappa_2(\\mathbf{A})$ 是决定像 CG 这样的迭代求解器收敛速度的关键因素，而所提供的误差界是一个标准的教科书结果。物理参数和测试用例是现实的，并经过精心设计，旨在探究约束网络拓扑和质量分布的不同情况，这些情况已知会影响数值条件。因此，该问题是有效的，可以按所述方法求解。\n\n解决方案通过为每个提供的测试用例实施以下步骤序列来展开。\n\n首先，我们建立基本的数学对象。系统由 $N$ 个粒子组成，其状态由一个 $3N$ 维的位置向量 $\\mathbf{q} = (\\mathbf{r}_1, \\dots, \\mathbf{r}_N)$ 描述。给定 $m$ 个形式为 $g_k(\\mathbf{q}) = 0$ 的完整约束。对于粒子 $i$ 和 $j$ 之间的一个距离约束，其形式为 $g_{(i,j)}(\\mathbf{q}) = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2 - d_{ij}^2 = 0$。\n\n算法流程如下：\n\n1.  **约束雅可比矩阵 $\\mathbf{J}$ 的构建**：\n    雅可比矩阵 $\\mathbf{J}$ 是一个 $m \\times 3N$ 的矩阵，其中每一行 $k$ 对应于单个约束函数 $g_k$ 的梯度。对于一个距离约束 $g_{(i,j)}$，其梯度 $\\nabla_{\\mathbf{q}} g_{(i,j)}$ 仅在关于粒子 $i$ 和 $j$ 的坐标上具有非零分量。具体而言，$\\nabla_{\\mathbf{r}_i} g_{(i,j)} = 2(\\mathbf{r}_i - \\mathbf{r}_j)$ 且 $\\nabla_{\\mathbf{r}_j} g_{(i,j)} = 2(\\mathbf{r}_j - \\mathbf{r}_i) = -2(\\mathbf{r}_i - \\mathbf{r}_j)$。为构建 $\\mathbf{J}$，我们初始化一个 $m \\times 3N$ 的零矩阵。对于粒子 $i$ 和 $j$ 之间的每个约束 $k$（从 $0$ 到 $m-1$），我们计算向量差 $\\mathbf{\\Delta r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$。子向量 $2\\mathbf{\\Delta r}_{ij}$ 被放置在第 $k$ 行的第 $3i$ 到 $3i+2$ 列，而子向量 $-2\\mathbf{\\Delta r}_{ij}$ 被放置在同一行的第 $3j$ 到 $3j+2$ 列。\n\n2.  **雅可比矩阵条件数 $\\kappa_2(\\mathbf{J})$ 的计算**：\n    非方阵 $\\mathbf{J}$ 的 2-范数条件数是其最大奇异值与最小奇异值之比，即 $\\kappa_2(\\mathbf{J}) = \\sigma_{\\max} / \\sigma_{\\min}$。奇异值通过奇异值分解 (SVD) 计算。如果最小奇异值 $\\sigma_{\\min}$ 接近于零（低于指定的阈值 $10^{-12}$），则表明约束是线性相关的或近似线性相关。这标志着一个病态的物理情景，例如冗余约束。在这种情况下，$\\kappa_2(\\mathbf{J})$ 被赋予一个大的哨兵值 $10^{12}$。否则，它将直接通过该比率计算。\n\n3.  **SHAKE/RATTLE 矩阵 $\\mathbf{A}$ 的构建**：\n    矩阵 $\\mathbf{A}$ 定义为 $\\mathbf{A} = \\mathbf{J} \\mathbf{M}^{-1} \\mathbf{J}^\\top$。矩阵 $\\mathbf{M}^{-1}$ 是一个 $3N \\times 3N$ 的对角矩阵，其对角元素是粒子质量的倒数，即 $\\mathbf{M}^{-1} = \\operatorname{diag}(m_1^{-1}, m_1^{-1}, m_1^{-1}, \\dots, m_N^{-1}, m_N^{-1}, m_N^{-1})$。该乘积通过一系列矩阵乘法计算。首先，我们可以通过将 $\\mathbf{J}$ 右乘 $\\mathbf{M}^{-1}$ 来形成中间矩阵 $\\mathbf{J}_{\\text{mod}} = \\mathbf{J}\\mathbf{M}^{-1}$。由于 $\\mathbf{M}^{-1}$ 是对角矩阵，这等效于缩放 $\\mathbf{J}$ 的列：第 $3k+c$ 列（对于 $c \\in \\{0,1,2\\}$）被乘以 $m_k^{-1}$。然后，$\\mathbf{A}$ 计算为 $\\mathbf{A} = \\mathbf{J}_{\\text{mod}} \\mathbf{J}^\\top$。结果矩阵 $\\mathbf{A}$ 是一个 $m \\times m$ 的对称矩阵。\n\n4.  **条件数 $\\kappa_2(\\mathbf{A})$ 的计算**：\n    由于 $\\mathbf{A}$ 是对称的，并且对于非冗余约束是正定的，其 2-范数条件数是其最大特征值与最小特征值之比，即 $\\kappa_2(\\mathbf{A}) = \\lambda_{\\max} / \\lambda_{\\min}$。特征值使用针对对称矩阵的高效算法进行计算。与雅可比矩阵类似，如果最小特征值 $\\lambda_{\\min}$ 低于数值阈值 $10^{-12}$，我们赋予定 $\\kappa_2(\\mathbf{A}) = 10^{12}$ 以表示严重的病态条件。\n\n5.  **共轭梯度迭代次数 $k$ 的估计**：\n    将误差的 $\\mathbf{A}$-范数减小一个因子 $\\epsilon = 10^{-8}$ 所需的 CG 迭代次数 $k$ 使用所提供的不等式进行估计：\n    $$ \\|\\mathbf{e}_k\\|_{\\mathbf{A}} \\le 2 \\left( \\frac{\\sqrt{\\kappa_2(\\mathbf{A})} - 1}{\\sqrt{\\kappa_2(\\mathbf{A})} + 1} \\right)^k \\|\\mathbf{e}_0\\|_{\\mathbf{A}} $$\n    我们求解满足 $2 \\left( \\frac{\\sqrt{\\kappa_2(\\mathbf{A})} - 1}{\\sqrt{\\kappa_2(\\mathbf{A})} + 1} \\right)^k \\le \\epsilon$ 的最小整数 $k$。取自然对数并重新排列可得：\n    $$ k \\ge \\frac{\\ln(\\epsilon/2)}{\\ln\\left(\\frac{\\sqrt{\\kappa} - 1}{\\sqrt{\\kappa} + 1}\\right)} $$\n    其中 $\\kappa = \\kappa_2(\\mathbf{A})$。我们计算该值的向上取整以找到最小整数 $k$。对于 $\\kappa \\le 1.0$ 的完美条件矩阵存在一个特例。在这种情况下，CG 方法理论上在一次迭代中收敛，因此我们设置 $k=1$。此过程将应用于指定的四个测试用例中的每一个。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It constructs the Jacobian J, computes its condition number,\n    constructs the SHAKE/RATTLE matrix A, computes its condition number,\n    and estimates the number of Conjugate Gradient iterations.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: Moderately connected near-electrode ring\n        {\n            \"positions\": np.array([\n                [0.000, 0.000, 0.300], [0.280, 0.000, 0.310], [0.140, 0.240, 0.290],\n                [-0.140, 0.240, 0.320], [-0.280, 0.000, 0.300], [-0.140, -0.240, 0.280]\n            ]),\n            \"masses\": np.full(6, 18.0),\n            \"constraints\": [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0), (0, 2), (2, 4)],\n        },\n        # Case 2: Near-collinear chain with redundant long links\n        {\n            \"positions\": np.array([\n                [-0.400, 0.000, 0.220], [-0.200, 0.000, 0.210], [0.000, 0.000, 0.200],\n                [0.200, 0.000, 0.210], [0.400, 0.000, 0.220]\n            ]),\n            \"masses\": np.full(5, 18.0),\n            \"constraints\": [(0, 1), (1, 2), (2, 3), (3, 4), (0, 4), (1, 3)],\n        },\n        # Case 3: Mass heterogeneity\n        {\n            \"positions\": np.array([\n                [0.000, 0.000, 0.300], [0.280, 0.000, 0.310], [0.140, 0.240, 0.290],\n                [-0.140, 0.240, 0.320], [-0.280, 0.000, 0.300], [-0.140, -0.240, 0.280]\n            ]),\n            \"masses\": np.array([16.0, 1.0, 23.0, 35.5, 16.0, 1.0]),\n            \"constraints\": [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0), (0, 2), (2, 4)],\n        },\n        # Case 4: Well-conditioned sparse tetrahedral-like cluster\n        {\n            \"positions\": np.array([\n                [0.000, 0.000, 0.250], [0.200, 0.100, 0.300],\n                [-0.150, 0.200, 0.280], [0.050, -0.180, 0.220]\n            ]),\n            \"masses\": np.full(4, 18.0),\n            \"constraints\": [(0, 1), (1, 2), (2, 3)],\n        }\n    ]\n\n    results = []\n    \n    # Numerical thresholds and parameters\n    SINGULAR_TOL = 1e-12\n    EIGEN_TOL = 1e-12\n    SENTINEL_KAPPA = 1e12\n    EPSILON_CG = 1e-8\n\n    for case in test_cases:\n        positions = case[\"positions\"]\n        masses = case[\"masses\"]\n        constraints = case[\"constraints\"]\n        \n        N = len(positions)\n        m = len(constraints)\n\n        # 1. Construct the Jacobian J\n        J = np.zeros((m, 3 * N))\n        for k, (i, j) in enumerate(constraints):\n            r_i = positions[i]\n            r_j = positions[j]\n            grad_r_i = 2 * (r_i - r_j)\n            \n            J[k, 3*i : 3*i+3] = grad_r_i\n            J[k, 3*j : 3*j+3] = -grad_r_i\n\n        # 2. Compute kappa_2(J)\n        singular_values = np.linalg.svd(J, compute_uv=False)\n        s_min = singular_values[-1] if len(singular_values) > 0 else 0\n        \n        if s_min  SINGULAR_TOL:\n            kappa_J = SENTINEL_KAPPA\n        else:\n            s_max = singular_values[0]\n            kappa_J = s_max / s_min\n\n        # 3. Construct A = J M^-1 J^T\n        # Create the diagonal of M^-1\n        inv_mass_diag = np.repeat(1.0 / masses, 3)\n        M_inv = np.diag(inv_mass_diag)\n        A = J @ M_inv @ J.T\n\n        # 4. Compute kappa_2(A)\n        # Use eigvalsh for symmetric matrices, it's faster and more stable\n        eigenvalues = np.linalg.eigvalsh(A)\n        lambda_min = eigenvalues[0] if len(eigenvalues) > 0 else 0\n\n        if lambda_min  EIGEN_TOL:\n            kappa_A = SENTINEL_KAPPA\n        else:\n            lambda_max = eigenvalues[-1]\n            kappa_A = lambda_max / lambda_min\n            \n        # 5. Estimate CG iterations k\n        if kappa_A = 1.0:\n            k = 1\n        else:\n            sqrt_kappa_A = np.sqrt(kappa_A)\n            ratio = (sqrt_kappa_A - 1) / (sqrt_kappa_A + 1)\n            # Handle the case where ratio is extremely close to 1 due to large kappa\n            if ratio > 1.0 - 1e-15:\n                # Use Taylor expansion for ln(x) around x=1, ln(1-y) approx -y\n                # ratio = 1 - 2/(sqrt_kappa_A+1) approx 1 - 2/sqrt_kappa_A\n                # log(ratio) approx -2/sqrt_kappa_A\n                log_ratio = -2.0 / sqrt_kappa_A\n            else:\n                log_ratio = np.log(ratio)\n\n            k_float = np.log(EPSILON_CG / 2.0) / log_ratio\n            k = int(np.ceil(k_float))\n\n        results.append([kappa_J, kappa_A, k])\n\n    # Format the final output string\n    formatted_results = []\n    for res_set in results:\n        kappa_J_str = f\"{res_set[0]:.6f}\"\n        kappa_A_str = f\"{res_set[1]:.6f}\"\n        k_str = str(res_set[2])\n        formatted_results.append(f\"[{kappa_J_str},{kappa_A_str},{k_str}]\")\n        \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "电化学界面的精确模拟需要在非周期性板状几何结构中谨慎处理长程静电相互作用，这通常通过埃瓦尔德（Ewald）方法及其板状几何校正来完成。本练习提供了一个关键的验证测试，你将为一个导电边界实现一个简化的晶格求和，并将包含关键的板状几何校正项在内的数值计算力与精确的解析镜像电荷势进行比较和验证 。",
            "id": "4248855",
            "problem": "考虑一个在计算电化学中建模的点电荷，该点电荷是一个电量为 $q$ 的单个粒子，位于 $z=0$ 处的无限大理想导体电极平面上方的位置 $(x,y,z) = (0,0,z_0)$。为了在平板几何结构中验证导体边界条件下的粒子-粒子/粒子-网格 (PPPM) 或粒子网格 Ewald (PME) 静电学方法，您需要构建一个数值上易于处理的晶格求和模拟，并将其预测的力与从经典静电学推导出的精确镜像电荷结果进行比较。其基本依据是库仑定律和针对理想导体的泊松方程边值解，具体规定如下。\n\n您必须实现一个程序，该程序能够：\n- 在一个尺寸为 $L_x, L_y, L_z$ 的模拟单元中，计算位于 $(0,0,z_0)$ 的测试电荷 $q$所受静电力的 $z$ 分量。该模拟在所有三个方向上均采用周期性边界条件，但在 Ewald 意义上使用导体边界条件（锡箔边界条件）。\n- 通过经典镜像法表示位于 $z=0$ 的导体平面：对于真实电荷的每一个周期性副本，都在平面下方的镜像反射位置放置一个电量为 $-q$ 的镜像电荷。\n- 通过对整数副本索引 $m \\in [-N_x, N_x]$，$n \\in [-N_y, N_y]$ 和 $p \\in [-N_z, N_z]$ 进行截断求和，来近似无限的镜像电荷晶格。每个镜像电荷位于 $(x,y,z) = (m L_x, n L_y, -z_0 + p L_z)$。\n- 使用形式为 $\\mathbf{F} = k_e \\, q_1 q_2 \\, \\mathbf{r} / \\|\\mathbf{r}\\|^3$ 的库仑定律，其中 $k_e = 1/(4\\pi \\varepsilon_0)$，$\\varepsilon_0$ 为真空介电常数。计算并累加每个镜像电荷作用在真实电荷上的力的贡献。您的推导和实现中的所有数学实体都必须遵循此定律。\n- 应用适用于锡箔边界条件的平板校正，以消除沿 $z$ 方向周期性平板之间的伪耦合。该校正必须用模拟单元的总偶极矩分量 $M_z$ 和单元体积 $V = L_x L_y L_z$ 来表示，并且需要通过基本静电学和泊松方程，从处理平板几何结构 Ewald 求和中的零波矢 ($k=0$) 模式推导得出。您必须按照您的解答中推导出的方式，实现这个沿 $z$ 方向的均匀校正力。\n- 将数值计算得到的总 $z$ 方向力（截断晶格和加平板校正）与点电荷在无限大理想导体平面附近的解析镜像电荷力进行比较，并返回定义为 $(F_{z}^{\\text{num}} - F_{z}^{\\text{exact}})/|F_{z}^{\\text{exact}}|$ 的相对误差，该误差为一个无量纲浮点数。\n\n所有量都必须在国际单位制 (SI) 中处理。距离如 $z_0, L_x, L_y, L_z$ 必须以米为单位，电荷 $q$ 以库仑为单位，力以牛顿为单位。周期性副本以位于 $(0,0,z_0)$ 的真实电荷为中心，截断求和应严格按照规定实现。本问题不涉及角度，因此不需要角度单位。\n\n测试套件：\n实现您的程序，以评估以下四个科学上一致的参数集的相对误差。这些参数集用于探测不同的数值和物理区域（理想路径、薄真空层/平板强耦合、远场和紧凑的横向周期性）：\n\n- 情况 1：$q = 1.602176634\\times 10^{-19}$ C, $z_0 = 1.0\\times 10^{-9}$ m, $L_x = 5.0\\times 10^{-9}$ m, $L_y = 5.0\\times 10^{-9}$ m, $L_z = 1.0\\times 10^{-7}$ m, $N_x = 2$, $N_y = 2$, $N_z = 2$。\n- 情况 2：$q = 1.602176634\\times 10^{-19}$ C, $z_0 = 2.0\\times 10^{-9}$ m, $L_x = 3.0\\times 10^{-9}$ m, $L_y = 3.0\\times 10^{-9}$ m, $L_z = 2.0\\times 10^{-8}$ m, $N_x = 3$, $N_y = 3$, $N_z = 3$。\n- 情况 3：$q = 1.602176634\\times 10^{-19}$ C, $z_0 = 5.0\\times 10^{-9}$ m, $L_x = 2.0\\times 10^{-8}$ m, $L_y = 2.0\\times 10^{-8}$ m, $L_z = 1.0\\times 10^{-6}$ m, $N_x = 1$, $N_y = 1$, $N_z = 1$。\n- 情况 4：$q = 1.602176634\\times 10^{-19}$ C, $z_0 = 1.5\\times 10^{-9}$ m, $L_x = 1.5\\times 10^{-9}$ m, $L_y = 1.5\\times 10^{-9}$ m, $L_z = 1.5\\times 10^{-7}$ m, $N_x = 1$, $N_y = 1$, $N_z = 2$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含所有情况的相对误差，格式为逗号分隔的列表，并用方括号括起来（例如 $[e_1,e_2,e_3,e_4]$），其中每个 $e_i$ 是对应于情况 $i$ 的无量纲相对误差浮点数。",
            "solution": "该问题要求计算在导体平面附近点电荷所受力的数值近似解与精确解析解之间的相对误差。数值近似涉及对周期性镜像电荷的截断晶格求和，并包含一个针对锡箔边界条件的平板校正项。\n\n解决方案分三个阶段展开：\n1.  使用镜像法推导精确的静电力。\n2.  构建数值计算的力，包括对镜像电荷的截断直接求和以及针对周期性边界条件的校正项。\n3.  定义和计算相对误差。\n\n所有物理量均以国际单位制 (SI) 表示。库仑常数为 $k_e = 1/(4\\pi\\varepsilon_0)$，其中 $\\varepsilon_0$ 是真空介电常数。\n\n**1. 解析力 ($F_{z}^{\\text{exact}}$)**\n\n物理系统由一个位于 $z=0$ 的无限大理想导体平面上方的点电荷 $q$ 组成，其位置为 $\\mathbf{r}_q = (0, 0, z_0)$。镜像法为 $z > 0$ 区域的静电势和电场提供了精确解。理想导体的边界条件是其表面电势恒定；我们可以将其设为 $\\phi(x,y,0) = 0$。通过移除导体平面并在镜像位置 $\\mathbf{r}_{\\text{im}} = (0, 0, -z_0)$ 引入一个电量为 $-q$ 的镜像电荷，可以满足此条件。\n\n此时，真实电荷 $q$ 所受的静电力完全来自于与该镜像电荷的库仑相互作用。从镜像电荷指向真实电荷的位置矢量为：\n$$ \\mathbf{r} = \\mathbf{r}_q - \\mathbf{r}_{\\text{im}} = (0, 0, z_0) - (0, 0, -z_0) = (0, 0, 2z_0) $$\n两个电荷之间的距离为 $\\|\\mathbf{r}\\| = 2z_0$。根据库仑定律，力为：\n$$ \\mathbf{F}_{\\text{exact}} = k_e \\frac{q(-q)}{\\|\\mathbf{r}\\|^3} \\mathbf{r} = -k_e q^2 \\frac{1}{(2z_0)^3} (0, 0, 2z_0) = -k_e q^2 \\frac{2z_0}{8z_0^3} \\hat{\\mathbf{k}} $$\n这个精确力的 $z$ 分量是：\n$$ F_{z}^{\\text{exact}} = -\\frac{k_e q^2}{4z_0^2} $$\n负号表示这是一个吸引力，将电荷 $q$ 拉向该平面。\n\n**2. 数值力 ($F_{z}^{\\text{num}}$)**\n\n数值模型使用一个尺寸为 $L_x, L_y, L_z$ 且带有周期性边界条件的模拟单元来近似无限系统。力是两个分量的和：一个直接的、截断的晶格和 ($F_{z}^{\\text{sum}}$) 以及一个平板校正项 ($F_{z}^{\\text{corr}}$)。\n\n**2.1. 截断晶格和 ($F_{z}^{\\text{sum}}$)**\n位于 $z=0$ 的导体平面通过为真实电荷的每个周期性副本创建一个镜像电荷来建模。问题规定，对于整数索引 $m, n, p$，镜像电荷位于位置 $\\mathbf{r}_{mnp}^{\\text{im}} = (mL_x, nL_y, -z_0 + pL_z)$。位于 $\\mathbf{r}_q = (0,0,z_0)$ 的真实电荷所受的力是这些镜像电荷所施加力的总和。求和被截断在 $m \\in [-N_x, N_x]$，$n \\in [-N_y, N_y]$ 和 $p \\in [-N_z, N_z]$ 的范围内。\n\n从一个镜像电荷 $(m,n,p)$ 指向真实电荷的矢量为：\n$$ \\mathbf{r}_{mnp} = \\mathbf{r}_q - \\mathbf{r}_{mnp}^{\\text{im}} = (0, 0, z_0) - (mL_x, nL_y, -z_0 + pL_z) = (-mL_x, -nL_y, 2z_0 - pL_z) $$\n来自该镜像电荷的力的 $z$ 分量贡献为：\n$$ F_{z,mnp} = k_e \\frac{q(-q)}{\\|\\mathbf{r}_{mnp}\\|^3} (\\mathbf{r}_{mnp})_z = -k_e q^2 \\frac{2z_0 - pL_z}{\\left( (mL_x)^2 + (nL_y)^2 + (2z_0 - pL_z)^2 \\right)^{3/2}} $$\n来自截断晶格和的总力是所有指定索引的和：\n$$ F_{z}^{\\text{sum}} = \\sum_{m=-N_x}^{N_x} \\sum_{n=-N_y}^{N_y} \\sum_{p=-N_z}^{N_z} F_{z,mnp} $$\n\n**2.2. 平板校正力 ($F_{z}^{\\text{corr}}$)**\n在采用 Ewald 求和和锡箔边界条件的三维周期性模拟中，单位晶胞中的净偶极矩 $\\mathbf{M}$ 会产生一个伪、均匀的电场。这个假象源于倒易空间求和中的 $k=0$（零波矢）项。单位晶胞的周期性阵列可以被视为一个连续的极化介质，其极化强度为 $\\mathbf{P} = \\mathbf{M}/V$，其中 $V = L_x L_y L_z$ 是晶胞体积。对于锡箔边界条件，这种极化在介质内部感生出一个退极化场 $\\mathbf{E}_{\\text{dep}} = -\\mathbf{P}/\\varepsilon_0$。该场会对电荷施加一个伪力，必须予以校正。\n\n作用于电荷 $q$ 上的校正力为 $\\mathbf{F}^{\\text{corr}} = q(-\\mathbf{E}_{\\text{dep}}) = -q\\mathbf{E}_{\\text{dep}} = q(\\mathbf{P}/\\varepsilon_0) = q\\mathbf{M}/(\\varepsilon_0 V)$。指令指定要推导该校正力，并且该力必须从计算出的力中*减去*。因此，需要加上的力是 $\\mathbf{F}_{\\text{add}}^{\\text{corr}} = + \\frac{q \\mathbf{M}}{\\varepsilon_0 V}$。\n\n主晶胞的偶极矩 $\\mathbf{M}$ 是由位于 $z_0$ 的真实电荷 $q$ 及其位于 $-z_0$ 的主镜像 $-q$ 计算得出的，因为这对电荷代表了产生平板偶极子的基本单元。\n$$ M_z = \\sum_i q_i z_i = q(z_0) + (-q)(-z_0) = 2qz_0 $$\n$x$ 和 $y$ 分量为零。因此，校正力纯粹沿 $z$ 方向：\n$$ F_{z}^{\\text{corr}} = \\frac{q M_z}{\\varepsilon_0 V} = \\frac{q(2qz_0)}{\\varepsilon_0 L_x L_y L_z} = \\frac{2q^2 z_0}{\\varepsilon_0 V} $$\n使用 $k_e = 1/(4\\pi\\varepsilon_0)$，这可以重写为：\n$$ F_{z}^{\\text{corr}} = 8\\pi k_e \\frac{q^2 z_0}{L_x L_y L_z} $$\n总的数值力是截断晶格和与此校正项的和：\n$$ F_{z}^{\\text{num}} = F_{z}^{\\text{sum}} + F_{z}^{\\text{corr}} $$\n\n**3. 相对误差计算**\n\n数值力与精确力之间的相对误差定义为：\n$$ \\text{RelErr} = \\frac{F_{z}^{\\text{num}} - F_{z}^{\\text{exact}}}{|F_{z}^{\\text{exact}}|} $$\n为了计算稳定性，我们可以注意到晶格和中索引为 $(m,n,p)=(0,0,0)$ 的项是：\n$$ F_{z,000} = -k_e q^2 \\frac{2z_0}{\\left( (2z_0)^2 \\right)^{3/2}} = -k_e q^2 \\frac{2z_0}{8z_0^3} = -\\frac{k_e q^2}{4z_0^2} = F_{z}^{\\text{exact}} $$\n因此，误差是所有其他贡献的总和：\n$$ F_{z}^{\\text{num}} - F_{z}^{\\text{exact}} = \\left( \\sum_{(m,n,p) \\neq (0,0,0)} F_{z,mnp} \\right) + F_{z}^{\\text{corr}} $$\n相对误差则计算为：\n$$ \\text{RelErr} = \\frac{\\left( \\sum_{m=-N_x}^{N_x} \\sum_{n=-N_y}^{N_y} \\sum_{p=-N_z}^{N_z} \\text{ where } (m,n,p)\\neq(0,0,0) \\right) F_{z,mnp} + F_{z}^{\\text{corr}}}{|F_{z}^{\\text{exact}}|} $$\n这种表述方式避免了两个大而相近的数相减，从而直接计算偏差。实现将遵循此最终表达式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import constants\n\ndef solve():\n    \"\"\"\n    Computes the relative error in the electrostatic force on a point charge\n    near a conducting plane, comparing a truncated lattice sum with a slab\n    correction to the exact analytical result.\n    \"\"\"\n    # Define physical constants from scipy.constants for high precision.\n    # The problem specifies using k_e = 1/(4*pi*epsilon_0).\n    q_val = constants.physical_constants['elementary charge'][0]\n    epsilon_0 = constants.physical_constants['vacuum electric permittivity'][0]\n    k_e = 1 / (4 * np.pi * epsilon_0)\n\n    # Test cases as defined in the problem statement.\n    # Each case is a tuple: (q, z_0, L_x, L_y, L_z, N_x, N_y, N_z)\n    test_cases = [\n        (q_val, 1.0e-9, 5.0e-9, 5.0e-9, 1.0e-7, 2, 2, 2),\n        (q_val, 2.0e-9, 3.0e-9, 3.0e-9, 2.0e-8, 3, 3, 3),\n        (q_val, 5.0e-9, 2.0e-8, 2.0e-8, 1.0e-6, 1, 1, 1),\n        (q_val, 1.5e-9, 1.5e-9, 1.5e-9, 1.5e-7, 1, 1, 2),\n    ]\n\n    results = []\n    for case in test_cases:\n        q, z_0, L_x, L_y, L_z, N_x, N_y, N_z = case\n        \n        # 1. Calculate the exact analytical force\n        f_z_exact = -k_e * q**2 / (4 * z_0**2)\n\n        # 2. Calculate the numerical force\n        # 2.1. Truncated lattice sum part\n        f_z_sum = 0.0\n        \n        # Sum over all image charges in the truncated lattice\n        for m in range(-N_x, N_x + 1):\n            for n in range(-N_y, N_y + 1):\n                for p in range(-N_z, N_z + 1):\n                    x_dist_sq = (m * L_x)**2\n                    y_dist_sq = (n * L_y)**2\n                    z_dist = 2 * z_0 - p * L_z\n                    \n                    r_sq = x_dist_sq + y_dist_sq + z_dist**2\n                    \n                    # The denominator can only be zero if x, y, and z distances are all zero.\n                    # This is not possible for z_0 > 0 and integer replica indices.\n                    if r_sq == 0:\n                        continue\n                    \n                    r = np.sqrt(r_sq)\n                    \n                    f_z_mnp = -k_e * q**2 * z_dist / (r**3)\n                    f_z_sum += f_z_mnp\n\n        # 2.2. Slab correction part (Corrected sign)\n        V = L_x * L_y * L_z  # Volume of the simulation cell\n        # Dipole moment of the primary cell (charge q at z_0 and image -q at -z_0)\n        M_z = 2 * q * z_0\n        f_z_corr = (q * M_z) / (epsilon_0 * V)\n        \n        # 2.3. Total numerical force\n        f_z_num = f_z_sum + f_z_corr\n\n        # 3. Calculate the relative error\n        relative_error = (f_z_num - f_z_exact) / abs(f_z_exact)\n        results.append(relative_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}