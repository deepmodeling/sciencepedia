{
    "hands_on_practices": [
        {
            "introduction": "Janak 定理是密度泛函理论中的一个基本结论，它将 Kohn-Sham 轨道能量与总能量对电子占有数的导数联系起来。这个关系对于理解和计算电化学中的电荷转移过程至关重要，因为它为电子亲和能和电离能等关键物理量提供了理论基础。本练习通过一个简化的吸附体系模型，让您亲手在数值上验证该定理的正确性，从而加深对轨道能量物理意义的理解 。",
            "id": "4241335",
            "problem": "考虑一个用于模拟吸附在金属表面上的分子的简单双轨道体系的最小Kohn–Sham密度泛函理论 (DFT) 公式。该体系在一个由两个局域轨道组成的最小正交基组中表示：一个以吸附物位点为中心，另一个以金属位点为中心。为简化起见，电子被视为无自旋的，占据的Kohn–Sham轨道数量为两个，其中能量最低的轨道被占据数 $f_1 = 1$ 填满，而能量较高的轨道带有分数占据数 $f_2 \\in [0,1]$。总能量泛函和有效Kohn–Sham哈密顿量应使用以下要素从第一性原理构建。\n\n基础理论：\n- 来自密度泛函理论（DFT）的Kohn–Sham能量泛函由无相互作用动能、离子（赝势）外势能、经典Hartree能量和交换关联能的总和给出。\n- 离散格点上的Hartree能量被建模为局域二次型。交换关联能则在局域密度近似（LDA）框架内使用简化的纯交换形式进行建模。\n\n定义和模型假设：\n- 有效Kohn–Sham哈密顿量 $H_{\\mathrm{KS}}$ 是一个在正交基组中的 $2 \\times 2$ 实对称矩阵，由在位项和耦合项组成。设吸附物和金属位点的在位离子赝势能分别为 $v_{\\mathrm{ion},A}$ 和 $v_{\\mathrm{ion},M}$。设吸附物-金属耦合为 $t$。\n- 位点密度 $n_A$ 和 $n_M$ 通过占据的Kohn–Sham轨道自洽计算得出：$n_s = \\sum_{k=1}^{2} f_k |\\langle s | \\psi_k \\rangle|^2$ 对于 $s \\in \\{A,M\\}$，其中 $|\\psi_k\\rangle$ 是 $H_{\\mathrm{KS}}$ 的归一化本征矢量，$f_k$ 是相应的占据数。\n- Hartree能量为 $E_H[n] = \\frac{1}{2} U \\left(n_A^2 + n_M^2\\right)$，其中 $U > 0$ 是一个局域库仑相互作用参数。相应的Hartree势为 $v_{H,s}(n_s) = \\frac{\\partial E_H}{\\partial n_s} = U n_s$，对于 $s \\in \\{A,M\\}$。\n- 交换能通过局域密度近似（LDA）的纯交换项 $E_x[n] = -\\alpha \\left(n_A^{4/3} + n_M^{4/3}\\right)$ 进行建模，其中 $\\alpha > 0$。交换势为 $v_{x,s}(n_s) = \\frac{\\partial E_x}{\\partial n_s} = -\\frac{4}{3} \\alpha n_s^{1/3}$。\n- 有效Kohn–Sham哈密顿量为\n$$\nH_{\\mathrm{KS}}(n_A,n_M) =\n\\begin{pmatrix}\nv_{\\mathrm{ion},A} + U n_A + v_{x,A}(n_A)  t \\\\\nt  v_{\\mathrm{ion},M} + U n_M + v_{x,M}(n_M)\n\\end{pmatrix}.\n$$\n- 总能量是根据Kohn–Sham本征值 $\\{\\epsilon_k\\}$ 和位点密度 $\\{n_A,n_M\\}$，使用标准的双重计算校正来计算的：\n$$\nE_{\\mathrm{tot}}[n] = \\sum_{k=1}^{2} f_k \\epsilon_k - E_H[n] - \\sum_{s \\in \\{A,M\\}} n_s v_{x,s}(n_s) + E_x[n].\n$$\n- 自洽性：对于每个给定的分数占据数 $f_2$，位点密度 $\\{n_A,n_M\\}$ 必须通过迭代从密度到哈密顿量，再到本征矢量和占据数，最后回到密度的映射来确定，直到在数值容差范围内达到一个不动点。\n\n目标：\n- 通过计算数值导数 $\\frac{dE_{\\mathrm{tot}}}{df_2}$ 并将其与一系列分数占据数下的 $\\epsilon_2$ 进行比较，数值上验证总能量 $E_{\\mathrm{tot}}$ 对分数占据数 $f_2$ 的敏感度与分数占据态相关的Kohn–Sham本征值 $\\epsilon_2$ 之间的关系。该比较应通过在指定的 $f_2$ 值网格上计算 $\\frac{dE_{\\mathrm{tot}}}{df_2}$ 和 $\\epsilon_2$ 之间的最大绝对偏差来量化。\n\n计算电化学背景：\n- 吸附物-金属模型模拟了在电化学环境中吸附到金属表面上的分子。赝势项 $v_{\\mathrm{ion},A}$ 和 $v_{\\mathrm{ion},M}$ 代表了适用于最小基组处理的有效离子势。局域密度近似（LDA）交换项模仿了在实际的金属和吸附物密度泛函理论（DFT）计算中常用的交换贡献，而Hartree项则模拟了因吸附时电荷重新分布而产生的经典静电相互作用。\n\n待实现的任务：\n- 为每个指定的 $f_2$ 和参数集，构建并求解该双轨道体系的自洽Kohn–Sham方程。\n- 使用指定的表达式计算总能量 $E_{\\mathrm{tot}}(f_2)$。\n- 使用小增量 $\\delta f$ 通过有限差分法计算数值导数 $\\frac{dE_{\\mathrm{tot}}}{df_2}$；在可能的情况下使用中心差分，在边界 $f_2=0$ 和 $f_2=1$ 处使用单边差分。\n- 对于每个 $f_2$ 值，计算绝对偏差 $|\\frac{dE_{\\mathrm{tot}}}{df_2}-\\epsilon_2|$，并报告每个参数集在整个网格上的最大偏差。\n- 所有能量必须以电子伏特（缩写为eV）表示。最终偏差必须以eV报告。\n\n测试套件：\n- 使用分数占据数网格 $f_2 \\in \\{0.0, 0.25, 0.5, 0.75, 1.0\\}$ 和有限差分增量 $\\delta f = 10^{-3}$。\n- 提供以下参数集，每个参数集都是一个eV单位的元组 $(v_{\\mathrm{ion},A}, v_{\\mathrm{ion},M}, t, U, \\alpha)$：\n    1. $( -5.0, 0.0, 0.8, 1.0, 0.5 )$ 代表能量低于金属能级的典型吸附物，具有中等耦合和中等相互作用。\n    2. $( -2.0, 0.0, 0.1, 1.0, 0.5 )$ 代表弱吸附物-金属耦合。\n    3. $( -1.0, 0.5, 1.2, 0.0, 0.0 )$ 代表用于测试基线行为的无相互作用极限。\n    4. $( -3.0, 0.0, 1.5, 4.0, 1.0 )$ 代表强静电和交换相互作用。\n- 自洽循环的收敛容差应设置为绝对密度 $10^{-10}$，可以采用简单的线性混合方案，混合参数在 $(0,1)$ 范围内，最大迭代次数至少为 $1000$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含四个参数集的最大偏差，形式为用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”）。每个结果必须是eV单位的浮点数。\n\n- 不应读取任何外部输入；所有常量和参数必须在程序内部定义。代码必须是自包含的，并且能够在任何遵循给定库限制的标准Python环境中运行。",
            "solution": "问题陈述已经过严格审查，并被确定为有效。它在科学上基于密度泛函理论（DFT）的原理，问题适定，具有清晰且可实现的目标，并且自包含，明确了所有必要的定义、参数和计算步骤。该问题代表了电子结构理论中一个标准的、尽管简化的计算练习，旨在测试一个被称为Janak定理的基本DFT结果的数值有效性。\n\n任务是为一个在Kohn-Sham（KS）DFT框架内描述的模型双轨道体系，数值上验证关系式 $\\frac{dE_{\\mathrm{tot}}}{df_2} = \\epsilon_2$。这里，$E_{\\mathrm{tot}}$ 是总能量，$f_2$ 是第二个KS轨道的占据数，$\\epsilon_2$ 是相应的KS本征值。这个关系是Janak定理的一种形式，该定理指出，总能量对某个轨道占据数的导数等于该轨道的能量。这个验证过程需要实现一个自洽场（SCF）程序来求解不同 $f_2$ 值下的KS方程。\n\n问题的核心在于对吸附物和金属位点的位点密度 $\\{n_A, n_M\\}$ 进行自洽确定。该过程从对密度的初始猜测开始，这些密度用于构建KS哈密顿量 $H_{\\mathrm{KS}}$。哈密顿量通过Hartree势 $v_{H,s}(n_s) = U n_s$ 和交换势 $v_{x,s}(n_s) = -\\frac{4}{3} \\alpha n_s^{1/3}$ 依赖于密度。$2 \\times 2$ 的KS哈密顿矩阵由下式给出：\n$$\nH_{\\mathrm{KS}}(n_A,n_M) =\n\\begin{pmatrix}\nv_{\\mathrm{ion},A} + U n_A - \\frac{4}{3} \\alpha n_A^{1/3}  t \\\\\nt  v_{\\mathrm{ion},M} + U n_M - \\frac{4}{3} \\alpha n_M^{1/3}\n\\end{pmatrix}\n$$\n对角化这个哈密顿量会得到两个本征值 $\\epsilon_1 \\le \\epsilon_2$ 及其对应的归一化本征矢量 $|\\psi_1\\rangle$ 和 $|\\psi_2\\rangle$。这些本征矢量用于根据以下公式计算新的位点密度：\n$$\nn_s = \\sum_{k=1}^{2} f_k |\\langle s | \\psi_k \\rangle|^2 = (1.0) \\cdot |\\langle s | \\psi_1 \\rangle|^2 + f_2 \\cdot |\\langle s | \\psi_2 \\rangle|^2 \\quad \\text{for } s \\in \\{A,M\\}\n$$\n其中 $f_1=1$ 且 $f_2$ 是一个给定参数。然后将新密度与旧密度混合，并迭代此过程，直到密度收敛到一个不动点，即输入和输出密度之间的差异低于指定的容差。这个迭代过程被称为自洽场（SCF）循环。\n\n一旦对于给定的 $f_2$，密度和KS轨道收敛，就可以计算总能量 $E_{\\mathrm{tot}}$。问题提供了总能量的标准表达式，该表达式校正了本征值总和中电子-电子相互作用的双重计算：\n$$\nE_{\\mathrm{tot}}[n] = \\sum_{k=1}^{2} f_k \\epsilon_k - E_H[n] - \\sum_{s \\in \\{A,M\\}} n_s v_{x,s}(n_s) + E_x[n]\n$$\n将给定的Hartree和纯交换LDA能量和势的形式 $E_H[n] = \\frac{1}{2} U (n_A^2 + n_M^2)$、$E_x[n] = -\\alpha (n_A^{4/3} + n_M^{4/3})$ 和 $v_{x,s}(n_s) = -\\frac{4}{3} \\alpha n_s^{1/3}$ 代入，可以简化能量表达式：\n$$\n\\begin{align*}\nE_{\\mathrm{tot}}[n] = \\sum_{k=1}^{2} f_k \\epsilon_k - \\frac{1}{2} U(n_A^2 + n_M^2) - \\left[ n_A \\left(-\\frac{4}{3}\\alpha n_A^{1/3}\\right) + n_M \\left(-\\frac{4}{3}\\alpha n_M^{1/3}\\right) \\right] + \\left[ -\\alpha(n_A^{4/3} + n_M^{4/3}) \\right] \\\\\n= \\sum_{k=1}^{2} f_k \\epsilon_k - \\frac{1}{2} U(n_A^2 + n_M^2) + \\frac{4}{3}\\alpha(n_A^{4/3} + n_M^{4/3}) - \\alpha(n_A^{4/3} + n_M^{4/3}) \\\\\n= \\sum_{k=1}^{2} f_k \\epsilon_k - \\frac{1}{2} U(n_A^2 + n_M^2) + \\frac{1}{3}\\alpha(n_A^{4/3} + n_M^{4/3})\n\\end{align*}\n$$\n这种简化形式在计算上更直接和稳健。\n\n为了验证Janak定理，我们需要计算导数 $\\frac{dE_{\\mathrm{tot}}}{df_2}$。这是通过使用有限差分法数值计算的。对于指定网格 $\\{0.0, 0.25, 0.5, 0.75, 1.0\\}$ 中的每个点 $f_{2,i}$，导数近似为：\n- 在 $f_{2,i}=0.0$ 处的向前差分：$\\frac{E_{\\mathrm{tot}}(f_{2,i}+\\delta f) - E_{\\mathrm{tot}}(f_{2,i})}{\\delta f}$\n- 在 $f_{2,i}=1.0$ 处的向后差分：$\\frac{E_{\\mathrm{tot}}(f_{2,i}) - E_{\\mathrm{tot}}(f_{2,i}-\\delta f)}{\\delta f}$\n- 对于内部点的中心差分：$\\frac{E_{\\mathrm{tot}}(f_{2,i}+\\delta f) - E_{\\mathrm{tot}}(f_{2,i}-\\delta f)}{2\\delta f}$\n其中 $\\delta f = 10^{-3}$ 是一个小增量。计算每个 $E_{\\mathrm{tot}}$ 值都需要运行一个完整的SCF循环。\n\n最后，对于网格中的每个 $f_{2,i}$，我们计算绝对偏差 $|\\frac{dE_{\\mathrm{tot}}}{df_2} - \\epsilon_2(f_{2,i})|$，其中 $\\epsilon_2(f_{2,i})$ 是在占据数 $f_2 = f_{2,i}$ 下通过收敛的SCF计算得到的第二个KS轨道的本征值。这些偏差在整个网格上的最大值就是每个参数集的最终结果。\n\n该算法针对每个提供的参数集实现，并报告最大偏差。无相互作用的情况（其中 $U=0, \\alpha=0$）作为一个关键基线，在这种情况下，Janak定理预计会精确成立，任何偏差都纯粹来自于数值精度和有限差分近似误差。其他测试用例则检验了该定理在不断增强的相互作用强度下的有效性。",
            "answer": "```python\nimport numpy as np\n\ndef solve_scf(f2, params, mixing_beta=0.5, tol=1e-10, max_iter=1000):\n    \"\"\"\n    Solves the Kohn-Sham equations self-consistently for a given\n    fractional occupation f2 and parameter set.\n\n    Args:\n        f2 (float): Fractional occupation of the second KS orbital.\n        params (tuple): (v_ion_a, v_ion_m, t, U, alpha).\n        mixing_beta (float): Linear mixing parameter for SCF iterations.\n        tol (float): Convergence tolerance for the site densities.\n        max_iter (int): Maximum number of SCF iterations.\n\n    Returns:\n        tuple: (epsilon_2, E_total) where epsilon_2 is the eigenvalue of the\n               second KS orbital and E_total is the total energy.\n    \"\"\"\n    v_ion_a, v_ion_m, t, U, alpha = params\n    f1 = 1.0\n\n    # Initial guess for densities, preserving the total number of electrons\n    total_electrons = f1 + f2\n    n_a = 0.5 * total_electrons\n    n_m = 0.5 * total_electrons\n\n    for _ in range(max_iter):\n        n_a_old, n_m_old = n_a, n_m\n\n        # Exchange potentials. Use np.cbrt for cubic root.\n        vx_a = -4/3 * alpha * np.cbrt(n_a) if n_a > 0 else 0.0\n        vx_m = -4/3 * alpha * np.cbrt(n_m) if n_m > 0 else 0.0\n\n        # Construct the Kohn-Sham Hamiltonian\n        h_ks = np.array([\n            [v_ion_a + U * n_a + vx_a, t],\n            [t, v_ion_m + U * n_m + vx_m]\n        ])\n\n        # Diagonalize H_KS to get eigenvalues and eigenvectors\n        eigenvalues, eigenvectors = np.linalg.eigh(h_ks)\n        eps1, eps2 = eigenvalues\n        psi1, psi2 = eigenvectors[:, 0], eigenvectors[:, 1]\n        \n        # Components of eigenvectors: psi_k = (c_Ak, c_Mk)^T\n        # numpy eigenvectors are columns: eigenvectors = [[c_A1, c_A2], [c_M1, c_M2]]\n        c_a1_sq = psi1[0]**2\n        c_m1_sq = psi1[1]**2\n        c_a2_sq = psi2[0]**2\n        c_m2_sq = psi2[1]**2\n\n        # Calculate new densities from occupied orbitals\n        n_a_new = f1 * c_a1_sq + f2 * c_a2_sq\n        n_m_new = f1 * c_m1_sq + f2 * c_m2_sq\n\n        # Check for convergence\n        density_diff = max(abs(n_a_new - n_a), abs(n_m_new - n_m))\n        if density_diff  tol:\n            n_a, n_m = n_a_new, n_m_new\n            break\n\n        # Linear mixing of densities for next iteration\n        n_a = (1 - mixing_beta) * n_a + mixing_beta * n_a_new\n        n_m = (1 - mixing_beta) * n_m + mixing_beta * n_m_new\n    else:\n        # This block executes if the loop finishes without converging\n        # For this problem, we assume convergence is always reached\n        pass\n\n    # Calculate total energy using the simplified expression\n    # E_tot = sum(f_k*eps_k) - 0.5*U*sum(n_s^2) + (1/3)*alpha*sum(n_s^(4/3))\n    # Using np.power for n_s^(4/3) is robust for n_s=0.\n    e_tot = (f1 * eps1 + f2 * eps2) - 0.5 * U * (n_a**2 + n_m**2) \\\n            + (1/3) * alpha * (np.power(n_a, 4/3) + np.power(n_m, 4/3))\n\n    return eps2, e_tot\n\ndef solve():\n    \"\"\"\n    Main function to run the DFT calculation for all test cases and print the result.\n    \"\"\"\n    # Parameter sets: (v_ion_A, v_ion_M, t, U, alpha) in eV\n    test_cases = [\n        (-5.0, 0.0, 0.8, 1.0, 0.5),\n        (-2.0, 0.0, 0.1, 1.0, 0.5),\n        (-1.0, 0.5, 1.2, 0.0, 0.0),\n        (-3.0, 0.0, 1.5, 4.0, 1.0)\n    ]\n\n    f2_grid = [0.0, 0.25, 0.5, 0.75, 1.0]\n    delta_f = 1e-3\n    \n    all_max_deviations = []\n\n    for params in test_cases:\n        deviations = []\n        for f2_val in f2_grid:\n            # Get the KS eigenvalue at the grid point f2_val\n            eps2_at_f2, _ = solve_scf(f2_val, params)\n\n            # Compute numerical derivative dE_tot/df2\n            if f2_val == 0.0:\n                # Forward difference at the lower boundary\n                _, e_tot_0 = solve_scf(f2_val, params)\n                _, e_tot_p = solve_scf(f2_val + delta_f, params)\n                dE_df2 = (e_tot_p - e_tot_0) / delta_f\n            elif f2_val == 1.0:\n                # Backward difference at the upper boundary\n                _, e_tot_0 = solve_scf(f2_val, params)\n                _, e_tot_m = solve_scf(f2_val - delta_f, params)\n                dE_df2 = (e_tot_0 - e_tot_m) / delta_f\n            else:\n                # Central difference for interior points\n                _, e_tot_p = solve_scf(f2_val + delta_f, params)\n                _, e_tot_m = solve_scf(f2_val - delta_f, params)\n                dE_df2 = (e_tot_p - e_tot_m) / (2 * delta_f)\n\n            # Calculate and store the deviation\n            dev = abs(dE_df2 - eps2_at_f2)\n            deviations.append(dev)\n        \n        # Find the maximum deviation for the current parameter set\n        all_max_deviations.append(max(deviations))\n\n    # Print results in the required format\n    print(f\"[{','.join(f'{dev:.12f}' for dev in all_max_deviations)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在计算电化学中，获得可靠的能量和性质是首要任务，而这依赖于计算参数的收敛性。平面波 DFT 计算中两个最关键的数值参数是动能截断能 $E_{\\mathrm{cut}}$ 和布里渊区 $k$ 点取样。本练习将指导您建立一个系统性的收敛性测试流程，通过对一系列计算数据进行拟合与外推，来评估吸附能的收敛情况，并最终确定满足精度要求所需的计算设置 。",
            "id": "4241387",
            "problem": "你的任务是构建一个程序，用于在计算电化学的背景下，评估平面波密度泛函理论 (DFT) 计算中吸附能相对于平面波动能截断和 $k$ 点采样的收敛性。首先从密度泛函理论 (DFT) 的基础 Kohn-Sham 方程出发，该理论指出，对于一个相互作用的电子系统，其基态能量可以通过一个在有效势下由 Kohn-Sham 方程控制的无相互作用参考体系来获得。在一个标准的、使用模守恒或投影缀加波赝势的平面波实现中，总能量取决于在动能截断 $E_{\\mathrm{cut}}$ 处的平面波基组截断，以及通过基数为 $N_k$ 的离散 $k$ 点集来近似的布里渊区积分。吸附能定义为 $E_{\\mathrm{ads}} = E_{\\mathrm{tot}}(\\mathrm{slab}+\\mathrm{adsorbate}) - E_{\\mathrm{tot}}(\\mathrm{slab}) - E_{\\mathrm{tot}}(\\mathrm{adsorbate})$，以 $\\mathrm{eV}$ 为单位表示。\n\n从第一性原理出发，使用截断平面波基组的 Kohn-Sham 方法的变分性质意味着，随着基组完备性的增加，误差会减小；随着 $k$ 点密度的增加，布里渊区积分误差也会减小。在平面波赝势计算中，所包含的最高倒格子矢量受 $G_{\\max}$ 限制，而 $G_{\\max}$ 与 $E_{\\mathrm{cut}}$ 相关；对布里渊区的积分引入了取决于 $N_k$ 的采样误差。基于被积函数的平滑度和高 $G$ 傅里叶分量的衰减特性，这两种误差源可以渐进地用关于 $E_{\\mathrm{cut}}$ 和 $N_k$ 的可分离依赖关系来建模。利用这些物理基础，构建一个线性最小二乘估计器，从在有限 $E_{\\mathrm{cut}}$ 和 $N_k$ 下的测量值中，生成一个无限截断和无限 $k$ 点的吸附能 $E_{\\infty}$。然后，通过评估估计器在该点对与 $E_{\\infty}$ 的偏差，来估计在最佳可用 $(E_{\\mathrm{cut,max}}, N_{k,\\mathrm{max}})$ 下的残余误差，并确定这是否满足指定的电化学精度容差。\n\n你的程序必须：\n- 对于每个测试用例，拟合一个包含特征 $x_1 = E_{\\mathrm{cut}}^{-p}$ 和 $x_2 = N_k^{-q}$ 以及一个常数项的线性模型，其中 $p$ 和 $q$ 是给定的。使用线性最小二乘法来估计参数，并提取 $E_{\\infty}$ 作为常数项。\n- 计算估计的绝对偏差 $\\Delta = \\left|E_{\\mathrm{ads}}^{\\mathrm{est}}(E_{\\mathrm{cut,max}}, N_{k,\\mathrm{max}}) - E_{\\infty}\\right|$，单位为 $\\mathrm{eV}$，其中 $(E_{\\mathrm{cut,max}}, N_{k,\\mathrm{max}})$ 是测试用例数据中存在的 $E_{\\mathrm{cut}}$ 和 $N_k$ 的最大值。\n- 将 $\\Delta$ 与为每个案例指定的容差 $\\tau$（单位为 $\\mathrm{eV}$）进行比较。如果 $\\Delta \\le \\tau$，则该案例输出布尔值 $True$；否则输出 $False$。\n\n物理单位：\n- 所有能量单位均为 $\\mathrm{eV}$。\n- $E_{\\mathrm{cut}}$ 的单位为 $\\mathrm{eV}$。\n- $N_k$ 是无单位的（采样格点的基数）。\n- 所有输出均为布尔值，无单位。\n\n测试套件：\n提供以下测量的吸附能和参数。每个测试用例都是一个三元组 $(E_{\\mathrm{cut}}, N_k, E_{\\mathrm{ads}})$ 的列表，以及指数 $(p,q)$ 和容差 $\\tau$（单位为 $\\mathrm{eV}$）。\n\n- 案例 1（绝缘氧化物表面；相对于 $E_{\\mathrm{cut}}$ 和 $k$ 点收敛良好）：\n  数据点（单位 $\\mathrm{eV}$）：\n  $(300, 4, -0.4974774955135062)$,\n  $(400, 4, -0.50155)$,\n  $(400, 9, -0.5110808641975309)$,\n  $(500, 9, -0.513158728243)$,\n  $(600, 16, -0.5158166809128011)$。\n  指数：$p = 1.5$, $q = 2$。\n  容差：$\\tau = 0.03$ $\\mathrm{eV}$。\n\n- 案例 2（金属表面；$k$ 点收敛慢）：\n  数据点（单位 $\\mathrm{eV}$）：\n  $(400, 2, -0.08795)$,\n  $(500, 3, -0.1728500517603336)$,\n  $(700, 4, -0.215280751)$,\n  $(700, 6, -0.257047418)$。\n  指数：$p = 1.5$, $q = 1$。\n  容差：$\\tau = 0.03$ $\\mathrm{eV}$。\n\n- 案例 3（分子吸附物；数据集点少但已充分收敛）：\n  数据点（单位 $\\mathrm{eV}$）：\n  $(300, 6, -0.1071666667)$,\n  $(400, 8, -0.11069375)$,\n  $(500, 12, -0.112893889)$。\n  指数：$p = 2$, $q = 2$。\n  容差：$\\tau = 0.03$ $\\mathrm{eV}$。\n\n- 案例 4（挑战性的金属收敛；$k$ 网格采样不足）：\n  数据点（单位 $\\mathrm{eV}$）：\n  $(300, 2, -0.1418019964108)$,\n  $(350, 3, -0.3108561)$,\n  $(400, 3, -0.3114667)$,\n  $(450, 4, -0.39581038)$。\n  指数：$p = 1.5$, $q = 1$。\n  容差：$\\tau = 0.03$ $\\mathrm{eV}$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，例如 $[result_1, result_2, result_3, result_4]$，其中每个 $result_i$ 是按上述顺序列出的案例 $i$ 的布尔值。",
            "solution": "该问题要求评估使用平面波密度泛函理论 (DFT) 计算的吸附能 $E_{\\mathrm{ads}}$ 相对于动能截断 $E_{\\mathrm{cut}}$ 和 k 点数量 $N_k$ 的收敛性。评估基于一个有物理动机的外推模型和一个指定的数值容差 $\\tau$。\n\n基本原理是 DFT 的 Kohn-Sham 方程，其中相互作用电子系统的基态性质通过一个非相互作用的辅助系统来确定。在实际的平面波基组实现中，Kohn-Sham 轨道在一个平面波基组中展开，该基组在最大动能 $E_{\\mathrm{cut}} = \\frac{\\hbar^2}{2m_e} G_{\\max}^2$ 处被截断。这种截断引入了基组不完备性误差。此外，对于周期性系统所必需的、对第一布里渊区的积分，通过在一个 $k$ 点网格上进行离散求和来近似，这引入了采样误差。\n\n根据变分原理，计算出的基态能量是真实基態能量的一个上限，并且随着 $E_{\\mathrm{cut}}$ 的增加，它会单调地向精确的基组极限能量逼近。总能量中的误差通常表现出关于 $E_{\\mathrm{cut}}$ 的渐进幂律衰减，通常建模为 $A \\cdot E_{\\mathrm{cut}}^{-p}$。类似地，来自布里渊区积分的误差随着 $k$ 点网格密度（此处由其基数 $N_k$ 表示）的增加而减小。这种误差也可以用幂律 $B \\cdot N_k^{-q}$ 来建模。指数 $p$ 和 $q$ 取决于系统的性质，例如赝势的平滑度以及系统是金属性还是绝缘性。\n\n对于吸附能 $E_{\\mathrm{ads}} = E_{\\mathrm{tot}}(\\mathrm{slab}+\\mathrm{adsorbate}) - E_{\\mathrm{tot}}(\\mathrm{slab}) - E_{\\mathrm{tot}}(\\mathrm{adsorbate})$，我们假设各组分能量中的误差相结合，使得 $E_{\\mathrm{ads}}$ 本身也遵循类似的渐进行为。通过假设误差的可分离性，我们可以为在有限 $E_{\\mathrm{cut}}$ 和 $N_k$下计算的吸附能建立一个模型：\n$$\nE_{\\mathrm{ads}}(E_{\\mathrm{cut}}, N_k) \\approx E_{\\infty} + c_1 E_{\\mathrm{cut}}^{-p} + c_2 N_k^{-q}\n$$\n在这里，$E_{\\infty}$ 代表期望的、完全收敛的吸附能，即外推到无限基组（$E_{\\mathrm{cut}} \\to \\infty$）和无限密集 $k$ 点网格（$N_k \\to \\infty$）时的值。$c_1 E_{\\mathrm{cut}}^{-p}$ 和 $c_2 N_k^{-q}$ 项分别代表由基组和 $k$ 点采样限制引起的主导阶残余误差。\n\n该模型在参数 $\\beta_0 = E_{\\infty}$、$\\beta_1 = c_1$ 和 $\\beta_2 = c_2$ 上是线性的。给定一组 $m$ 个计算数据点 $(E_{\\mathrm{cut},i}, N_{k,i}, E_{\\mathrm{ads},i})$，我们可以通过线性最小二乘法确定这些参数。我们定义特征 $x_{1,i} = E_{\\mathrm{cut},i}^{-p}$ 和 $x_{2,i} = N_{k,i}^{-q}$，以及响应变量 $y_i = E_{\\mathrm{ads},i}$。该模型变成一个标准的多重线性回归问题：\n$$\ny_i = \\beta_0 \\cdot 1 + \\beta_1 x_{1,i} + \\beta_2 x_{2,i} + \\epsilon_i\n$$\n这可以表示为矩阵形式 $\\mathbf{y} = \\mathbf{A}\\beta + \\epsilon$，其中 $\\mathbf{y}$ 是观测到的能量向量，$\\beta = [\\beta_0, \\beta_1, \\beta_2]^T$ 是待估计的参数向量，$\\mathbf{A}$ 是 $m \\times 3$ 的设计矩阵，其行为 $[1, x_{1,i}, x_{2,i}]$。$\\beta$ 的最小二乘估计（记为 $\\hat{\\beta}$）通过最小化残差平方和得到，可通过求解正规方程 $(\\mathbf{A}^T\\mathbf{A})\\hat{\\beta} = \\mathbf{A}^T\\mathbf{y}$ 来找到。这可以使用数值线性代数库高效地求解。\n\n一旦确定了参数 $\\hat{\\beta} = [\\hat{\\beta}_0, \\hat{\\beta}_1, \\hat{\\beta}_2]^T$，外推能量即为 $\\hat{E}_{\\infty} = \\hat{\\beta}_0$。问题接着要求在所提供数据集中可用的最高理论水平（由 $(E_{\\mathrm{cut,max}}, N_{k,\\mathrm{max}})$ 标识）下估计残余误差。模型在这些参数下的估计吸附能为：\n$$\nE_{\\mathrm{ads}}^{\\mathrm{est}}(E_{\\mathrm{cut,max}}, N_{k,\\mathrm{max}}) = \\hat{\\beta}_0 + \\hat{\\beta}_1 E_{\\mathrm{cut,max}}^{-p} + \\hat{\\beta}_2 N_{k,\\mathrm{max}}^{-q}\n$$\n与外推极限的绝对偏差是衡量剩余收敛误差的指标：\n$$\n\\Delta = \\left|E_{\\mathrm{ads}}^{\\mathrm{est}}(E_{\\mathrm{cut,max}}, N_{k,\\mathrm{max}}) - \\hat{E}_{\\infty}\\right| = \\left|\\hat{\\beta}_1 E_{\\mathrm{cut,max}}^{-p} + \\hat{\\beta}_2 N_{k,\\mathrm{max}}^{-q}\\right|\n$$\n最后，将此偏差 $\\Delta$ 与给定的电化学精度容差 $\\tau$ 进行比较。如果 $\\Delta \\le \\tau$，则认为计算已充分收敛；否则，则未收敛。该过程包括，对于每个测试用例，根据给定的数据和指数构建设计矩阵 $\\mathbf{A}$ 和响应向量 $\\mathbf{y}$，求解系数向量 $\\hat{\\beta}$，使用数据中的最大 $E_{\\mathrm{cut}}$ 和 $N_k$ 值计算 $\\Delta$，并将 $\\Delta$ 与 $\\tau$ 进行比较。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DFT convergence problem for a suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"id\": 1,\n            \"data\": [\n                (300, 4, -0.4974774955135062),\n                (400, 4, -0.50155),\n                (400, 9, -0.5110808641975309),\n                (500, 9, -0.513158728243),\n                (600, 16, -0.5158166809128011),\n            ],\n            \"p\": 1.5,\n            \"q\": 2.0,\n            \"tau\": 0.03,\n        },\n        {\n            \"id\": 2,\n            \"data\": [\n                (400, 2, -0.08795),\n                (500, 3, -0.1728500517603336),\n                (700, 4, -0.215280751),\n                (700, 6, -0.257047418),\n            ],\n            \"p\": 1.5,\n            \"q\": 1.0,\n            \"tau\": 0.03,\n        },\n        {\n            \"id\": 3,\n            \"data\": [\n                (300, 6, -0.1071666667),\n                (400, 8, -0.11069375),\n                (500, 12, -0.112893889),\n            ],\n            \"p\": 2.0,\n            \"q\": 2.0,\n            \"tau\": 0.03,\n        },\n        {\n            \"id\": 4,\n            \"data\": [\n                (300, 2, -0.1418019964108),\n                (350, 3, -0.3108561),\n                (400, 3, -0.3114667),\n                (450, 4, -0.39581038),\n            ],\n            \"p\": 1.5,\n            \"q\": 1.0,\n            \"tau\": 0.03,\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        data = case[\"data\"]\n        p = case[\"p\"]\n        q = case[\"q\"]\n        tau = case[\"tau\"]\n\n        # Unpack data into separate lists/arrays\n        E_cuts = np.array([d[0] for d in data])\n        N_ks = np.array([d[1] for d in data])\n        E_ads_vals = np.array([d[2] for d in data])\n\n        # Construct the design matrix A for the linear model\n        # E_ads = beta_0 + beta_1 * E_cut**(-p) + beta_2 * N_k**(-q)\n        num_points = len(data)\n        A = np.zeros((num_points, 3))\n        A[:, 0] = 1.0  # Constant term for beta_0 (E_infinity)\n        A[:, 1] = E_cuts ** (-p)  # Feature for beta_1\n        A[:, 2] = N_ks ** (-q)    # Feature for beta_2\n        \n        # Define the response vector y\n        y = E_ads_vals\n\n        # Solve the linear least squares problem A*beta = y for beta\n        # np.linalg.lstsq returns (solution, residuals, rank, singular values)\n        # We need the solution vector, which are the coefficients [beta_0, beta_1, beta_2]\n        coeffs = np.linalg.lstsq(A, y, rcond=None)[0]\n        \n        # The coefficients are:\n        # beta_0 = E_infinity (extrapolated energy)\n        # beta_1 = c1 (coefficient for E_cut term)\n        # beta_2 = c2 (coefficient for N_k term)\n        beta_1 = coeffs[1]\n        beta_2 = coeffs[2]\n\n        # Find the maximum E_cut and N_k from the dataset\n        E_cut_max = np.max(E_cuts)\n        N_k_max = np.max(N_ks)\n\n        # Calculate the estimated absolute deviation Delta\n        # Delta = |E_ads_est(E_cut_max, N_k_max) - E_infinity|\n        # Delta = |(beta_0 + beta_1*x1_max + beta_2*x2_max) - beta_0|\n        # Delta = |beta_1*E_cut_max**(-p) + beta_2*N_k_max**(-q)|\n        delta = abs(beta_1 * (E_cut_max ** (-p)) + beta_2 * (N_k_max ** (-q)))\n\n        # Compare Delta to the tolerance tau\n        is_converged = delta = tau\n        results.append(is_converged)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "当使用局域基组（如高斯基组）进行计算时，一个常见的系统误差是基组重叠误差（Basis Set Superposition Error, BSSE），它会人为地增强分子间的相互作用能。对于研究离子吸附等弱相互作用体系，准确处理 BSSE 至关重要。本练习将介绍 Boys-Bernardi 衡消校正法，这是一种量化并校正 BSSE 的标准方法，通过它您可以得到更物理真实的吸附能，并学会如何根据 BSSE 的大小来选择合适的计算策略 。",
            "id": "4241332",
            "problem": "您的任务是在 Kohn–Sham 密度泛函理论 (DFT) 的框架内，形式化并实现一个计算方案，以量化和减轻离子在导电表面有限簇模型上吸附的基组重叠误差 (BSSE)。该方案必须从第一性原理出发，以 Kohn–Sham DFT 的变分结构和片段基组的概念为起点进行推导。然后，您必须将推导出的表达式实现为一个可运行的程序，该程序能对一个小型测试套件评估使用和不使用平衡校正的吸附能，量化 BSSE，并返回一个用于最小化 BSSE 的编码建议。\n\n基本依据和设置：\n- 在 Kohn–Sham 密度泛函理论中，电子密度 $n(\\mathbf{r})$ 的基态能量泛函为 $E[n] = T_{\\mathrm{s}}[n] + E_{\\mathrm{H}}[n] + E_{\\mathrm{xc}}[n] + \\int v_{\\mathrm{ext}}(\\mathbf{r}) n(\\mathbf{r}) \\, d\\mathbf{r}$，其中 $T_{\\mathrm{s}}$ 是无相互作用动能，$E_{\\mathrm{H}}$ 是 Hartree 能量，$E_{\\mathrm{xc}}$ 是交换相关能，$v_{\\mathrm{ext}}$ 是由原子核和任何外加场引起的外势。变分原理意味着，对于任何从不完备基组获得的近似密度 $n_{\\mathrm{approx}}$，都有 $E[n_{\\mathrm{approx}}] \\ge E[n_{\\mathrm{exact}}]$。\n- 在定域基组表示中，当两个片段 $A$ 和 $B$ 相互靠近时，组合基组 $\\mathcal{B}_A \\cup \\mathcal{B}_B$ 会人为地降低在另一方基组（作为鬼函数）存在下计算的各片段能量，从而导致基组重叠误差。这个误差可以通过 Boys–Bernardi 平衡校正方法，在吸附构型下使用鬼基函数计算片段能量来评估。\n\n需要实现的定义：\n- 令 $E_{AB}$ 为在吸附构型下，使用选定的交换相关近似和赝势设置计算出的吸附体系的总能量。\n- 令 $E_A$ 和 $E_B$ 为孤立片段 $A$ 和 $B$ 在相同构型下（片段被分离至无限远作为其孤立参考态）使用各自基组计算的能量。\n- 令 $E_A^{AB}$ 为在吸附构型下，使用其自身基组并增补 B 的鬼函数（即 B 的不带电子或原子核的基函数）计算的片段 A 的能量；$E_B^{AB}$ 的定义与此类似。\n- 未校正的吸附能为 $E_{\\mathrm{ads}}^{\\mathrm{un}} = E_{AB} - E_A - E_B$。\n- 经平衡校正的吸附能为 $E_{\\mathrm{ads}}^{\\mathrm{CP}} = E_{AB} - E_A^{AB} - E_B^{AB}$。\n- BSSE 的大小为 $\\Delta_{\\mathrm{BSSE}} = (E_A - E_A^{AB}) + (E_B - E_B^{AB})$。\n- 必须生成一个策略代码，以根据计算出的 $\\Delta_{\\mathrm{BSSE}}$ 相对于 $|E_{\\mathrm{ads}}^{\\mathrm{un}}|$ 的大小以及 $E_{\\mathrm{ads}}^{\\mathrm{CP}}$ 的行为来推荐如何最小化 BSSE：\n  - 策略代码 $0$：BSSE 小到可以接受；无需进一步操作。\n  - 策略代码 $1$：为更具离子性的片段的定域基组添加弥散函数并重新评估；使用平衡校正。\n  - 策略代码 $2$：增加基组基数（例如，升级到至少带极化的三希腊字母基组），并在生产性计算中使用平衡校正。\n  - 策略代码 $3$：严重的 BSSE（例如，校正后吸附能符号反转或较大的 BSSE 分数）；倾向于使用带赝势的平面波或大幅扩大簇和基组。\n\n需要实现的决策协议：\n- 定义绝对 BSSE 阈值 $\\epsilon_{\\mathrm{abs}} = 0.02$ eV 和相对阈值 $\\rho_{\\mathrm{rel}} = 0.05$。\n- 如果 $|E_{\\mathrm{ads}}^{\\mathrm{un}}|  10^{-8}$ eV，则计算 $f = \\Delta_{\\mathrm{BSSE}} / |E_{\\mathrm{ads}}^{\\mathrm{un}}|$；否则将 $f$ 视为有效大值。\n- 如果 $E_{\\mathrm{ads}}^{\\mathrm{un}}$ 和 $E_{\\mathrm{ads}}^{\\mathrm{CP}}$ 的符号相反（不包括精确为零的情况），则设置策略代码为 $3$。\n- 否则，如果基组类型为平面波（编码为 $1$），则设置策略代码为 $0$（BSSE 可忽略不计）。\n- 否则，如果 $\\Delta_{\\mathrm{BSSE}} \\le \\epsilon_{\\mathrm{abs}}$ 且 $f \\le \\rho_{\\mathrm{rel}}$，则设置策略代码为 $0$。\n- 否则，如果 $f \\le 0.10$ 或 $\\Delta_{\\mathrm{BSSE}} \\le 0.05$ eV，则设置策略代码为 $1$。\n- 否则，设置策略代码为 $2$。\n\n单位和数值输出：\n- 所有能量必须以电子伏特 (eV) 为单位处理和报告。\n- 您的程序必须为每个测试用例计算 $E_{\\mathrm{ads}}^{\\mathrm{un}}$、$E_{\\mathrm{ads}}^{\\mathrm{CP}}$、$\\Delta_{\\mathrm{BSSE}}$ 和策略代码。\n- 将所有浮点输出四舍五入到 $6$ 位小数。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个用方括号括起来的逗号分隔列表，每个测试用例的结果本身就是一个列表，格式为 $[E_{\\mathrm{ads}}^{\\mathrm{un}}, E_{\\mathrm{ads}}^{\\mathrm{CP}}, \\Delta_{\\mathrm{BSSE}}, \\text{strategy\\_code}]$。例如，$[[\\dots],[\\dots],[\\dots],[\\dots]]$。\n\n测试套件：\n提供以下科学上一致的参数集；所有能量单位均为 eV，并且都是在吸附构型下使用指定的相同交换相关泛函和赝势类型计算的。元数据包括基组类型代码（$0$ 代表定域高斯型轨道基组，$1$ 代表平面波基组）、基组基数指示符 $z$（希腊字母级别）、弥散函数标志 $d$（$0$ 或 $1$）和赝势类型代码 $p$（$0$ 代表模守恒，$1$ 代表超软，$2$ 代表投影缀加波）。这些元数据用于提供解释性上下文；只有基组类型代码被决策协议使用。\n\n- 测试用例 $1$ (定域双希腊字母基组，不含弥散函数，模守恒赝势)：\n  - $E_{AB} = -500.000$\n  - $E_A = -400.000$\n  - $E_B = -99.100$\n  - $E_A^{AB} = -400.080$\n  - $E_B^{AB} = -99.130$\n  - 基组类型代码 $b = 0$，希腊字母级别 $z = 2$，弥散函数 $d = 0$，赝势 $p = 0$。\n\n- 测试用例 $2$ (平面波，使用投影缀加波赝势，高完备性)：\n  - $E_{AB} = -500.850$\n  - $E_A = -400.400$\n  - $E_B = -100.200$\n  - $E_A^{AB} = -400.401$\n  - $E_B^{AB} = -100.201$\n  - 基组类型代码 $b = 1$，希腊字母级别 $z = 0$ (不适用)，弥散函数 $d = 0$，赝势 $p = 2$。\n\n- 测试用例 $3$ (定域最小基组，有严重 BSSE，模守恒赝势)：\n  - $E_{AB} = -600.020$\n  - $E_A = -500.000$\n  - $E_B = -100.000$\n  - $E_A^{AB} = -500.100$\n  - $E_B^{AB} = -100.020$\n  - 基组类型代码 $b = 0$，希腊字母级别 $z = 1$，弥散函数 $d = 0$，赝势 $p = 0$。\n\n- 测试用例 $4$ (定域三希腊字母基组，有中等 BSSE，超软赝势)：\n  - $E_{AB} = -350.900$\n  - $E_A = -250.000$\n  - $E_B = -100.600$\n  - $E_A^{AB} = -250.050$\n  - $E_B^{AB} = -100.610$\n  - 基组类型代码 $b = 0$，希腊字母级别 $z = 3$，弥散函数 $d = 0$，赝势 $p = 1$。\n\n您的程序必须实现所述协议，数值输出四舍五入到 $6$ 位小数，并且最终打印仅生成一行精确格式的输出：一个包含四个列表的列表，对应四个测试用例，每个内部列表包含 $4$ 个条目 $[E_{\\mathrm{ads}}^{\\mathrm{un}}, E_{\\mathrm{ads}}^{\\mathrm{CP}}, \\Delta_{\\mathrm{BSSE}}, \\text{strategy\\_code}]$。",
            "solution": "该问题在科学上和计算上都是有效的。它要求在计算化学中实现一个标准协议，即针对基组重叠误差 (BSSE) 的平衡校正，以及一个基于结果的决策算法。所有定义、数据和逻辑步骤都是自洽、一致的，并基于密度泛函理论 (DFT) 的原理。\n\n解决方案首先形式化所需的量，然后应用一个已定义的决策协议。\n\n**1. 吸附能和 BSSE 的形式化定义**\n\n问题的核心在于 Kohn–Sham DFT 的变分性质。当使用不完备的定域基组（例如高斯型轨道）时，如果附近片段的基函数（“鬼”函数）可用于更好地描述其电子密度，那么该分子片段的能量就会被人为地降低。这种非物理的稳定化效应就是基组重叠误差。\n\n设两个片段为吸附物 $A$ 和表面簇 $B$。所需的能量量为：\n- $E_{AB}$：在吸附构型下，用全基组 $\\mathcal{B}_{AB} = \\mathcal{B}_A \\cup \\mathcal{B}_B$ 计算的组合体系 A+B 的总能量。\n- $E_A$：仅用其自身基组 $\\mathcal{B}_A$ 计算的孤立片段 A 的能量。\n- $E_B$：仅用其自身基组 $\\mathcal{B}_B$ 计算的孤立片段 B 的能量。\n\n未校正的吸附能 $E_{\\mathrm{ads}}^{\\mathrm{un}}$ 是复合物与孤立片段之间的简单能量差：\n$$\nE_{\\mathrm{ads}}^{\\mathrm{un}} = E_{AB} - (E_A + E_B)\n$$\n这个量被 BSSE 所污染，因为能量 $E_A$ 和 $E_B$ 在变分上高于它们在完整 A+B 基组背景下的能量。\n\nBoys–Bernardi 平衡校正通过计算在另一片段基函数（鬼函数）存在下的片段能量来解决此问题。\n- $E_A^{AB}$：在吸附构型下，用全基组 $\\mathcal{B}_{AB}$ 计算的片段 A 的能量。\n- $E_B^{AB}$：在吸附构型下，用全基组 $\\mathcal{B}_{AB}$ 计算的片段 B 的能量。\n\n经平衡校正的吸附能 $E_{\\mathrm{ads}}^{\\mathrm{CP}}$ 则为：\n$$\nE_{\\mathrm{ads}}^{\\mathrm{CP}} = E_{AB} - (E_A^{AB} + E_B^{AB})\n$$\n根据定义，由于变分原理，$E_A \\ge E_A^{AB}$ 且 $E_B \\ge E_B^{AB}$。这意味着 BSSE 总是对结合能提供一个人为的、非物理的贡献。\n\nBSSE 的大小是未校正和校正后的片段能量之和的差值：\n$$\n\\Delta_{\\mathrm{BSSE}} = (E_A - E_A^{AB}) + (E_B - E_B^{AB})\n$$\n注意 $\\Delta_{\\mathrm{BSSE}} \\ge 0$。一个有用的恒等式是 $\\Delta_{\\mathrm{BSSE}} = E_{\\mathrm{ads}}^{\\mathrm{CP}} - E_{\\mathrm{ads}}^{\\mathrm{un}}$。\n\n**2. BSSE 减轻决策协议**\n\n需要一个策略来评估 BSSE 的严重性并推荐相应措施。该协议是一个基于计算出的能量和预定义阈值的确定性算法。\n\n设阈值为 $\\epsilon_{\\mathrm{abs}} = 0.02 \\text{ eV}$ 和 $\\rho_{\\mathrm{rel}} = 0.05$。\n设 BSSE 分数为 $f = \\Delta_{\\mathrm{BSSE}} / |E_{\\mathrm{ads}}^{\\mathrm{un}}|$，仅在 $|E_{\\mathrm{ads}}^{\\mathrm{un}}|  10^{-8} \\text{ eV}$ 时计算。\n\n策略代码根据以下层级分配：\n1.  若 $E_{\\mathrm{ads}}^{\\mathrm{un}}$ 和 $E_{\\mathrm{ads}}^{\\mathrm{CP}}$ 符号相反（且均不为零，即 $\\mathrm{sign}(E_{\\mathrm{ads}}^{\\mathrm{un}}) \\times \\mathrm{sign}(E_{\\mathrm{ads}}^{\\mathrm{CP}})  0$），则 BSSE 极其严重，以至于颠覆了对吸附的定性预测。设置策略代码为 $3$。\n2.  否则，若基组为平面波类型（代码 $b=1$），则 BSSE 在构造上可忽略不计。设置策略代码为 $0$。\n3.  否则（对于定域基组），若 $\\Delta_{\\mathrm{BSSE}} \\le \\epsilon_{\\mathrm{abs}}$ 且 $f \\le \\rho_{\\mathrm{rel}}$，则 BSSE 小到可以接受。设置策略代码为 $0$。\n4.  否则，若 $f \\le 0.10$ 或 $\\Delta_{\\mathrm{BSSE}} \\le 0.05 \\text{ eV}$，则 BSSE 为中等程度。设置策略代码为 $1$。\n5.  否则，BSSE 显著。设置策略代码为 $2$。\n\n**3. 应用于测试用例**\n\n我们现在将此协议应用于所提供的测试用例。所有能量单位均为 eV。\n\n**测试用例 1:**\n- 给定：$E_{AB} = -500.000$，$E_A = -400.000$，$E_B = -99.100$，$E_A^{AB} = -400.080$，$E_B^{AB} = -99.130$，$b = 0$。\n- $E_{\\mathrm{ads}}^{\\mathrm{un}} = -500.000 - (-400.000 - 99.100) = -0.900 \\text{ eV}$。\n- $E_{\\mathrm{ads}}^{\\mathrm{CP}} = -500.000 - (-400.080 - 99.130) = -0.790 \\text{ eV}$。\n- $\\Delta_{\\mathrm{BSSE}} = (-400.000 - (-400.080)) + (-99.100 - (-99.130)) = 0.080 + 0.030 = 0.110 \\text{ eV}$。\n- 协议：\n    1.  $E_{\\mathrm{ads}}^{\\mathrm{un}}$（负）和 $E_{\\mathrm{ads}}^{\\mathrm{CP}}$（负）的符号相同。\n    2.  基组不是平面波（$b=0$）。\n    3.  $f = 0.110 / |-0.900| \\approx 0.122$。我们检查 $\\Delta_{\\mathrm{BSSE}}(0.110) \\le 0.02$ 且 $f(0.122) \\le 0.05$ 是否成立。此条件为假。\n    4.  我们检查 $f(0.122) \\le 0.10$ 或 $\\Delta_{\\mathrm{BSSE}}(0.110) \\le 0.05$ 是否成立。此条件为假。\n    5.  触发最后的 'else' 分支。策略代码为 $2$。\n- 结果：$[-0.900000, -0.790000, 0.110000, 2]$。\n\n**测试用例 2:**\n- 给定：$E_{AB} = -500.850$，$E_A = -400.400$，$E_B = -100.200$，$E_A^{AB} = -400.401$，$E_B^{AB} = -100.201$，$b = 1$。\n- $E_{\\mathrm{ads}}^{\\mathrm{un}} = -500.850 - (-400.400 - 100.200) = -0.250 \\text{ eV}$。\n- $E_{\\mathrm{ads}}^{\\mathrm{CP}} = -500.850 - (-400.401 - 100.201) = -0.248 \\text{ eV}$。\n- $\\Delta_{\\mathrm{BSSE}} = (-400.400 - (-400.401)) + (-100.200 - (-100.201)) = 0.001 + 0.001 = 0.002 \\text{ eV}$。\n- 协议：\n    1.  符号相同。\n    2.  基组是平面波（$b=1$）。策略代码为 $0$。\n- 结果：$[-0.250000, -0.248000, 0.002000, 0]$。\n\n**测试用例 3:**\n- 给定：$E_{AB} = -600.020$，$E_A = -500.000$，$E_B = -100.000$，$E_A^{AB} = -500.100$，$E_B^{AB} = -100.020$，$b = 0$。\n- $E_{\\mathrm{ads}}^{\\mathrm{un}} = -600.020 - (-500.000 - 100.000) = -0.020 \\text{ eV}$。\n- $E_{\\mathrm{ads}}^{\\mathrm{CP}} = -600.020 - (-500.100 - 100.020) = +0.100 \\text{ eV}$。\n- $\\Delta_{\\mathrm{BSSE}} = (-500.000 - (-500.100)) + (-100.000 - (-100.020)) = 0.100 + 0.020 = 0.120 \\text{ eV}$。\n- 协议：\n    1.  $E_{\\mathrm{ads}}^{\\mathrm{un}}$ 为负，$E_{\\mathrm{ads}}^{\\mathrm{CP}}$ 为正。符号相反。策略代码为 $3$。\n- 结果：$[-0.020000, 0.100000, 0.120000, 3]$。\n\n**测试用例 4:**\n- 给定：$E_{AB} = -350.900$，$E_A = -250.000$，$E_B = -100.600$，$E_A^{AB} = -250.050$，$E_B^{AB} = -100.610$，$b = 0$。\n- $E_{\\mathrm{ads}}^{\\mathrm{un}} = -350.900 - (-250.000 - 100.600) = -0.300 \\text{ eV}$。\n- $E_{\\mathrm{ads}}^{\\mathrm{CP}} = -350.900 - (-250.050 - 100.610) = -0.240 \\text{ eV}$。\n- $\\Delta_{\\mathrm{BSSE}} = (-250.000 - (-250.050)) + (-100.600 - (-100.610)) = 0.050 + 0.010 = 0.060 \\text{ eV}$。\n- 协议：\n    1.  $E_{\\mathrm{ads}}^{\\mathrm{un}}$（负）和 $E_{\\mathrm{ads}}^{\\mathrm{CP}}$（负）的符号相同。\n    2.  基组不是平面波（$b=0$）。\n    3.  $f = 0.060 / |-0.300| = 0.20$。我们检查 $\\Delta_{\\mathrm{BSSE}}(0.060) \\le 0.02$ 且 $f(0.20) \\le 0.05$ 是否成立。此条件为假。\n    4.  我们检查 $f(0.20) \\le 0.10$ 或 $\\Delta_{\\mathrm{BSSE}}(0.060) \\le 0.05$ 是否成立。此条件为假。\n    5.  触发最后的 'else' 分支。策略代码为 $2$。\n- 结果：$[-0.300000, -0.240000, 0.060000, 2]$。\n\n该实现将把这些计算和决策树编码成一个可运行的程序。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other non-standard libraries are used.\n\ndef solve():\n    \"\"\"\n    Computes BSSE-corrected adsorption energies and a mitigation strategy\n    code for a given test suite of DFT energy calculations.\n    \"\"\"\n    \n    # Test suite data:\n    # Each tuple contains:\n    # (E_AB, E_A, E_B, E_A_AB, E_B_AB, basis_type_code)\n    # All energies are in eV.\n    test_cases = [\n        # Test case 1\n        (-500.000, -400.000, -99.100, -400.080, -99.130, 0),\n        # Test case 2\n        (-500.850, -400.400, -100.200, -400.401, -100.201, 1),\n        # Test case 3\n        (-600.020, -500.000, -100.000, -500.100, -100.020, 0),\n        # Test case 4\n        (-350.900, -250.000, -100.600, -250.050, -100.610, 0)\n    ]\n\n    results_for_printing = []\n\n    # Constants for the decision protocol\n    epsilon_abs = 0.02  # eV\n    rho_rel = 0.05      # dimensionless\n\n    for case in test_cases:\n        E_AB, E_A, E_B, E_A_AB, E_B_AB, basis_type = case\n        \n        # --- 1. Compute energies and BSSE ---\n        \n        # Uncorrected adsorption energy\n        E_ads_un = E_AB - (E_A + E_B)\n        \n        # Counterpoise-corrected adsorption energy\n        E_ads_CP = E_AB - (E_A_AB + E_B_AB)\n        \n        # BSSE magnitude\n        # Note: Delta_BSSE = (E_A - E_A_AB) + (E_B - E_B_AB) also equals E_ads_CP - E_ads_un\n        Delta_BSSE = (E_A - E_A_AB) + (E_B - E_B_AB)\n\n        # --- 2. Implement the decision protocol to find the strategy code ---\n        \n        strategy_code = -1 # Initialize with a sentinel value\n\n        # Rule 1: Check for sign flip\n        # np.sign handles 0 correctly. The rule is for opposite non-zero signs.\n        sign_un = np.sign(E_ads_un)\n        sign_cp = np.sign(E_ads_CP)\n        if sign_un != 0 and sign_cp != 0 and sign_un != sign_cp:\n            strategy_code = 3\n        \n        # Rule 2: Check for plane-wave basis\n        elif basis_type == 1:\n            strategy_code = 0\n            \n        else: # Localized basis logic\n            # Calculate fractional BSSE, f\n            if abs(E_ads_un) > 1e-8:\n                f = Delta_BSSE / abs(E_ads_un)\n            else:\n                # Treat f as effectively large if denominator is near zero\n                f = float('inf')\n\n            # Rule 3: BSSE is acceptably small\n            if Delta_BSSE = epsilon_abs and f = rho_rel:\n                strategy_code = 0\n            \n            # Rule 4: Moderate BSSE\n            elif f = 0.10 or Delta_BSSE = 0.05:\n                strategy_code = 1\n            \n            # Rule 5: Significant BSSE\n            else:\n                strategy_code = 2\n\n        # --- 3. Format the results for the current test case ---\n        \n        # Round floating point values to 6 decimal places\n        E_ads_un_rounded = round(E_ads_un, 6)\n        E_ads_CP_rounded = round(E_ads_CP, 6)\n        Delta_BSSE_rounded = round(Delta_BSSE, 6)\n        \n        # The output format requires f-strings with a specific precision\n        # for consistent formatting (e.g., trailing zeros).\n        formatted_case_result = (\n            f\"[{E_ads_un_rounded:.6f},\"\n            f\"{E_ads_CP_rounded:.6f},\"\n            f\"{Delta_BSSE_rounded:.6f},\"\n            f\"{strategy_code}]\"\n        )\n        results_for_printing.append(formatted_case_result)\n\n    # --- 4. Final print statement in the exact required format ---\n    final_output = f\"[{','.join(results_for_printing)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}