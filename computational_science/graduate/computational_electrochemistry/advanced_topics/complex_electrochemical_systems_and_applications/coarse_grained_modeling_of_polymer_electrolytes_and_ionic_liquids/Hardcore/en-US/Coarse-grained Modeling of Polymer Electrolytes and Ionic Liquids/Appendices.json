{
    "hands_on_practices": [
        {
            "introduction": "The foundation of any molecular simulation is the correct integration of the equations of motion. When modeling systems driven out of equilibrium, such as polymer electrolytes under an electric field, selecting a proper thermostat is critical to dissipate the work done by the field without introducing severe numerical artifacts. This practice () demonstrates why naive temperature control methods fail and how a physically-grounded Langevin thermostat correctly separates collective drift from thermal fluctuations, enabling accurate prediction of transport properties.",
            "id": "4238685",
            "problem": "A developer is tasked with diagnosing numerical artifacts in a minimal coarse-grained model of a polymer electrolyte or ionic liquid under a uniform external electric field using three distinct thermostat strategies and recommending which strategy minimizes bias. The investigation must be grounded in fundamental laws and well-tested facts, without relying on shortcut formulas provided in the problem statement.\n\nA one-dimensional system of $N$ identical coarse-grained charged beads is modeled. Each bead has mass $m$, charge $q$, and moves along a single spatial dimension under a spatially uniform electric field $E$ producing an electric force $F_\\text{el} = q E$. The motion is influenced by linear friction characterized by a friction coefficient $\\gamma$ (Stokes-like drag), and thermal fluctuations at target temperature $T_0$ mediated by a thermostat, interpreted as an implicit solvent coupling. The numerical experiment must use the following foundational bases:\n\n- Newton’s second law of motion: $m \\,\\frac{dv}{dt} = F$.\n- Equipartition theorem for kinetic temperature estimation in one dimension: if the instantaneous total kinetic energy is $K_\\text{tot}(t)$, then the instantaneous kinetic temperature estimated from all velocities is $T_\\text{raw}(t) = \\frac{2 K_\\text{tot}(t)}{N k_\\mathrm{B}}$, where $k_\\mathrm{B}$ is the Boltzmann constant.\n- Peculiar (thermal) velocity defined by subtracting the instantaneous center-of-mass velocity $v_\\mathrm{com}(t)$: $u_i(t) = v_i(t) - v_\\mathrm{com}(t)$, where $v_\\mathrm{com}(t) = \\frac{1}{N}\\sum_{i=1}^N v_i(t)$. The corresponding instantaneous peculiar kinetic temperature is $T_\\text{pec}(t) = \\frac{m}{k_\\mathrm{B}} \\left( \\frac{1}{N} \\sum_{i=1}^N u_i(t)^2 \\right)$.\n\nThe three thermostat strategies to be implemented are:\n\n1. No thermostat (denoted by code $0$): purely deterministic motion under the electric field, without friction or noise.\n2. Global Langevin thermostat (denoted by code $1$): friction and stochastic thermal noise act on each bead’s velocity consistent with the fluctuation-dissipation relation at $T_0$.\n3. Naive global velocity-rescaling thermostat (denoted by code $2$): at each time step, after deterministic field-and-friction update without noise, rescale the entire velocity vector by a single factor so that the instantaneous total kinetic temperature $T_\\text{raw}(t)$ is exactly $T_0$.\n\nThe developer must:\n\n- Derive from first principles the expected steady-state mean drift velocity along the field for a bead subject to linear friction and a constant electric force.\n- Design a discrete-time integrator for each strategy that is scientifically sound, specifying how to update velocities in time step $\\Delta t$ using only the stated laws and facts.\n- Simulate $N$ beads initialized from a one-dimensional Maxwell-Boltzmann distribution at temperature $T_0$, and evolve the system for a specified number of steps for each thermostat strategy.\n- Diagnose numerical artifacts using the following metrics:\n  - Temperature drift rate computed from the raw kinetic temperature: fit a line $T_\\text{raw}(t) \\approx a t + b$ over the full simulation and extract the slope $a$ (units of $\\mathrm{K/s}$).\n  - Peculiar temperature bias: the absolute deviation $\\left| \\overline{T_\\text{pec}} - T_0 \\right|$, where $\\overline{T_\\text{pec}}$ is the time-average over the final half of the trajectory (units of $\\mathrm{K}$).\n  - Drift bias: the absolute deviation between the measured mean center-of-mass drift velocity (averaged over the final $10\\%$ of steps) and the theoretically derived steady-state value (units of $\\mathrm{m/s}$).\n- Construct a dimensionless composite bias score for each strategy:\n  $$\\mathcal{C} = \\frac{\\left| \\overline{T_\\text{pec}} - T_0 \\right|}{T_0} + \\frac{\\left| \\overline{v_\\mathrm{com}} - v_\\mathrm{th} \\right|}{\\max\\left(|v_\\mathrm{th}|, \\varepsilon\\right)} + \\frac{|a|\\, T_\\mathrm{sim}}{T_0},$$\n  where $v_\\mathrm{th}$ is the theoretically derived steady-state drift velocity, $T_\\mathrm{sim}$ is the total simulated time, and $\\varepsilon$ is a small positive number to avoid division by zero in edge cases.\n\nAll quantities must be carried in International System of Units (SI units). Report any velocity in $\\mathrm{m/s}$ and temperature in $\\mathrm{K}$. The Boltzmann constant must be $k_\\mathrm{B} = 1.380649 \\times 10^{-23}\\,\\mathrm{J/K}$.\n\nInitial conditions:\n- Number of beads $N = 200$.\n- Mass $m = 1.0 \\times 10^{-24}\\,\\mathrm{kg}$.\n- Charge $q = 1.602176634 \\times 10^{-19}\\,\\mathrm{C}$.\n- Friction coefficient $\\gamma = 1.0 \\times 10^{-12}\\,\\mathrm{kg/s}$.\n- Target temperature $T_0 = 300\\,\\mathrm{K}$.\n- Initialize velocities $v_i(0)$ by sampling independently from a normal distribution with mean $0$ and variance $\\sigma_v^2 = \\frac{k_\\mathrm{B} T_0}{m}$.\n\nTest suite:\nEach test case specifies the electric field $E$ (in $\\mathrm{V/m}$), the time step $\\Delta t$ (in $\\mathrm{s}$), and the number of steps $n_\\mathrm{steps}$. Use the following four cases:\n- Case A (happy path): $E = 1.0 \\times 10^{6}\\,\\mathrm{V/m}$, $\\Delta t = 1.0 \\times 10^{-12}\\,\\mathrm{s}$, $n_\\mathrm{steps} = 6000$.\n- Case B (zero field boundary): $E = 0.0\\,\\mathrm{V/m}$, $\\Delta t = 1.0 \\times 10^{-12}\\,\\mathrm{s}$, $n_\\mathrm{steps} = 6000$.\n- Case C (strong field): $E = 5.0 \\times 10^{6}\\,\\mathrm{V/m}$, $\\Delta t = 1.0 \\times 10^{-12}\\,\\mathrm{s}$, $n_\\mathrm{steps} = 6000$.\n- Case D (coarse time step edge): $E = 1.0 \\times 10^{6}\\,\\mathrm{V/m}$, $\\Delta t = 5.0 \\times 10^{-12}\\,\\mathrm{s}$, $n_\\mathrm{steps} = 3000$.\n\nProgram requirements:\n- Implement the three thermostat strategies as described.\n- For each test case, compute the composite bias score $\\mathcal{C}$ for each strategy and choose the recommended strategy as the one minimizing $\\mathcal{C}$.\n- Your program must produce a single line of output containing the recommended strategy codes for the four test cases as a comma-separated list enclosed in square brackets (e.g., \"[1,1,1,1]\").\n\nNo external input or files may be used. The random number generation must be seeded for reproducibility. Angles do not appear; no angle unit specification is required. The final outputs are integers representing the recommended strategy codes per test case; no units are needed for these integers. All internal computations must consistently use SI units.",
            "solution": "The user-provided problem has been critically validated and is determined to be sound. It is a well-posed, scientifically grounded computational physics problem that is free of contradictions, pseudo-science, and ambiguity. The task is to analyze three different thermostatting algorithms for a simple one-dimensional model of charged particles in an electric field, a standard exercise in computational statistical mechanics. The problem provides all necessary physical constants, initial conditions, system parameters, and explicit definitions for the diagnostic metrics. A minor ambiguity regarding the small parameter $\\varepsilon$ in the composite score is a standard feature in such definitions to prevent division by zero and can be resolved by choosing any reasonably small positive value. A division-by-zero that arises as a consequence of one thermostat's definition under a specific test case is interpreted as a feature, not a flaw, designed to expose the algorithm's naivete. Therefore, proceeding with a full solution is warranted.\n\nThe solution will be developed through the following reasoned steps, adhering to the principles stipulated in the problem statement.\n\n### 1. Theoretical Steady-State Drift Velocity ($v_\\text{th}$)\n\nWe are asked to derive the steady-state mean drift velocity from first principles. For a single coarse-grained bead of mass $m$ and charge $q$, subject to a uniform electric field $E$, a linear friction force with coefficient $\\gamma$, and a stochastic thermal force $R(t)$, Newton's second law is:\n$$m \\frac{dv}{dt} = qE - \\gamma v + R(t)$$\nThe stochastic force $R(t)$ represents thermal fluctuations from an implicit solvent and has a zero mean, $\\langle R(t) \\rangle = 0$. To find the mean steady-state velocity, we take the ensemble average of the entire equation:\n$$\\left\\langle m \\frac{dv}{dt} \\right\\rangle = \\langle qE \\rangle - \\langle \\gamma v \\rangle + \\langle R(t) \\rangle$$\nSince $m$, $q$, $E$, and $\\gamma$ are constants, this simplifies to:\n$$m \\frac{d\\langle v \\rangle}{dt} = qE - \\gamma \\langle v \\rangle$$\nIn the steady state, the system's average properties are constant in time, which implies that the average velocity $\\langle v \\rangle$ is constant. Therefore, its time derivative is zero: $\\frac{d\\langle v \\rangle}{dt} = 0$. This leads to:\n$$0 = qE - \\gamma \\langle v \\rangle_\\text{ss}$$\nSolving for the steady-state average velocity, which we denote as the theoretical drift velocity $v_\\text{th}$, yields:\n$$v_\\text{th} = \\frac{qE}{\\gamma}$$\nThis result is fundamental for systems described by Langevin dynamics and serves as the benchmark against which the simulated drift velocity will be compared.\n\n### 2. Numerical Integration Schemes\n\nWe will design a discrete-time integrator for each of the three thermostat strategies using a time step $\\Delta t$. The velocity of particle $i$ at time step $n$ is $v_i^n$. We use a simple forward Euler scheme as implied by the problem's structure.\n\n**Strategy 0: No thermostat**\nThe motion is governed solely by the constant electric force.\n$$m \\frac{dv_i}{dt} = qE$$\nThe discretized update rule is:\n$$v_i^{n+1} = v_i^n + \\frac{qE}{m} \\Delta t$$\nThis strategy neglects both friction and thermal noise.\n\n**Strategy 1: Global Langevin thermostat**\nThe equation of motion includes the electric field, friction, and a stochastic force satisfying the fluctuation-dissipation theorem.\n$$m \\frac{dv_i}{dt} = qE - \\gamma v_i + R_i(t)$$\nThe Euler-Maruyama discretization for this stochastic differential equation is:\n$$v_i^{n+1} = v_i^n + \\left(\\frac{qE}{m} - \\frac{\\gamma}{m}v_i^n\\right)\\Delta t + \\frac{\\sqrt{2\\gamma k_\\mathrm{B} T_0 \\Delta t}}{m} Z_i^n$$\nwhere $Z_i^n$ are independent random variables drawn from a standard normal distribution $\\mathcal{N}(0,1)$. This can be rearranged as:\n$$v_i^{n+1} = \\left(1 - \\frac{\\gamma \\Delta t}{m}\\right)v_i^n + \\frac{qE \\Delta t}{m} + \\sqrt{\\frac{2\\gamma k_\\mathrm{B} T_0 \\Delta t}{m^2}} Z_i^n$$\n\n**Strategy 2: Naive global velocity-rescaling thermostat**\nThis is a two-step procedure.\nStep (a): A deterministic velocity update incorporating the electric field and friction, but no stochastic term.\n$$v'_i = \\left(1 - \\frac{\\gamma \\Delta t}{m}\\right)v_i^n + \\frac{qE \\Delta t}{m}$$\nStep (b): All velocities $v'_i$ are rescaled by a common factor $\\lambda$ to force the instantaneous raw kinetic temperature to be $T_0$. The target total kinetic energy is $K_\\text{target} = \\frac{N k_\\mathrm{B} T_0}{2}$. The kinetic energy after Step (a) is $K'_\\text{tot} = \\frac{1}{2}m \\sum_i (v'_i)^2$. The scaling factor $\\lambda$ must satisfy $\\lambda^2 K'_\\text{tot} = K_\\text{target}$.\n$$\\lambda = \\sqrt{\\frac{K_\\text{target}}{K'_\\text{tot}}} = \\sqrt{\\frac{N k_\\mathrm{B} T_0}{m \\sum_i (v'_i)^2}}$$\nThe final updated velocities are:\n$$v_i^{n+1} = \\lambda v'_i$$\nA critical flaw arises if $\\sum_i (v'_i)^2 = 0$, which occurs in test case B ($E=0$) where the parameters make $v'_i = 0$. In this case, the scaling factor is undefined. This is a failure of the \"naive\" algorithm, and such a case will be assigned an infinite bias score.\n\n### 3. Simulation Protocol and Metric Calculation\n\nFor each test case and each strategy, a simulation is performed.\n- **Initialization**: Velocities $v_i(0)$ are drawn from a 1D Maxwell-Boltzmann distribution, which is a normal distribution $\\mathcal{N}(\\mu, \\sigma^2)$ with mean $\\mu=0$ and variance $\\sigma^2 = k_\\mathrm{B} T_0 / m$. A fixed seed is used for the random number generator to ensure reproducibility.\n- **Time Evolution**: The system of $N=200$ beads is evolved for $n_\\text{steps}$ using the appropriate integrator. At each step, we calculate and record:\n  - Center-of-mass velocity: $v_\\mathrm{com}(t) = \\frac{1}{N}\\sum_{i=1}^N v_i(t)$\n  - Raw temperature: $T_\\text{raw}(t) = \\frac{m}{N k_\\mathrm{B}}\\sum_{i=1}^N v_i(t)^2$\n  - Peculiar temperature: $T_\\text{pec}(t) = \\frac{m}{N k_\\mathrm{B}}\\sum_{i=1}^N (v_i(t) - v_\\mathrm{com}(t))^2$\n- **Metric Calculation**: After the simulation, three diagnostic metrics are computed from the time-series data.\n  1.  **Temperature drift rate ($a$)**: A linear regression $T_\\text{raw}(t) = at + b$ is performed on the entire raw temperature trajectory. The slope $a$ is extracted.\n  2.  **Peculiar temperature bias**: The peculiar temperature $T_\\text{pec}(t)$ is averaged over the final half of the simulation trajectory to find $\\overline{T_\\text{pec}}$. The bias is $|\\overline{T_\\text{pec}} - T_0|$.\n  3.  **Drift bias**: The center-of-mass velocity $v_\\mathrm{com}(t)$ is averaged over the final $10\\%$ of the trajectory to find $\\overline{v_\\mathrm{com}}$. The bias is $|\\overline{v_\\mathrm{com}} - v_\\text{th}|$.\n\n### 4. Composite Bias Score and Strategy Recommendation\n\nThe three metrics are combined into a single dimensionless composite bias score $\\mathcal{C}$ for each strategy:\n$$\\mathcal{C} = \\frac{\\left| \\overline{T_\\text{pec}} - T_0 \\right|}{T_0} + \\frac{\\left| \\overline{v_\\mathrm{com}} - v_\\mathrm{th} \\right|}{\\max\\left(|v_\\mathrm{th}|, \\varepsilon\\right)} + \\frac{|a|\\, T_\\mathrm{sim}}{T_0}$$\nwhere $T_\\mathrm{sim} = n_\\text{steps} \\Delta t$ is the total simulation time and $\\varepsilon$ is a small velocity (e.g., $10^{-9}\\,\\mathrm{m/s}$) to handle the case where $v_\\text{th}=0$. For each test case, the strategy with the minimum composite score $\\mathcal{C}$ is identified as the recommended one. This procedure objectively quantifies the performance of each thermostat according to the specified criteria, revealing artifacts such as energy drift (high $|a|$), incorrect thermal distribution (high $|\\overline{T_\\text{pec}} - T_0|$), or incorrect response to external fields (high $|\\overline{v_\\mathrm{com}} - v_\\text{th}|$). The Python program below implements this complete validation and analysis pipeline.",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Solves the thermostat validation problem by simulating a 1D system of charged beads\n    under three different thermostat strategies and recommending the one that minimizes\n    a composite bias score for each of four test cases.\n    \"\"\"\n\n    # --- Constants and Initial Conditions ---\n    CONSTANTS = {\n        'N': 200,  # Number of beads\n        'm': 1.0e-24,  # Mass (kg)\n        'q': 1.602176634e-19,  # Charge (C)\n        'gamma': 1.0e-12,  # Friction coefficient (kg/s)\n        'T0': 300.0,  # Target temperature (K)\n        'k_B': 1.380649e-23,  # Boltzmann constant (J/K)\n        'epsilon': 1.0e-9, # Small velocity for stabilizing denominator (m/s)\n    }\n\n    # --- Test Suite ---\n    TEST_CASES = [\n        # Case A: Happy path\n        {'E': 1.0e6, 'dt': 1.0e-12, 'n_steps': 6000},\n        # Case B: Zero field boundary\n        {'E': 0.0, 'dt': 1.0e-12, 'n_steps': 6000},\n        # Case C: Strong field\n        {'E': 5.0e6, 'dt': 1.0e-12, 'n_steps': 6000},\n        # Case D: Coarse time step edge\n        {'E': 1.0e6, 'dt': 5.0e-12, 'n_steps': 3000},\n    ]\n    \n    # Use a seeded random number generator for reproducibility\n    RNG = np.random.default_rng(seed=0)\n\n    def run_simulation(params, strategy_code, consts):\n        \"\"\"\n        Runs a single simulation for a given set of parameters and thermostat strategy.\n        Returns the composite bias score.\n        \"\"\"\n        E = params['E']\n        dt = params['dt']\n        n_steps = params['n_steps']\n        \n        N = consts['N']\n        m = consts['m']\n        q = consts['q']\n        gamma = consts['gamma']\n        T0 = consts['T0']\n        k_B = consts['k_B']\n        epsilon = consts['epsilon']\n\n        # --- Initialization ---\n        v_sigma = np.sqrt(k_B * T0 / m)\n        velocities = RNG.normal(loc=0.0, scale=v_sigma, size=N)\n\n        # --- Data Storage ---\n        times = np.arange(n_steps) * dt\n        T_raw_hist = np.zeros(n_steps)\n        T_pec_hist = np.zeros(n_steps)\n        v_com_hist = np.zeros(n_steps)\n\n        # --- Pre-calculations for the integrators ---\n        force_el_term = (q * E / m) * dt\n        friction_factor = 1.0 - (gamma * dt / m)\n        noise_std_dev = np.sqrt(2 * gamma * k_B * T0 * dt) / m if gamma > 0 else 0.0\n\n        # --- Simulation Loop ---\n        for i in range(n_steps):\n            if strategy_code == 0:  # No thermostat\n                velocities += force_el_term\n            \n            elif strategy_code == 1:  # Global Langevin thermostat\n                noise = RNG.normal(loc=0.0, scale=noise_std_dev, size=N)\n                velocities = friction_factor * velocities + force_el_term + noise\n\n            elif strategy_code == 2:  # Naive global velocity-rescaling\n                # Step 1: Deterministic update\n                v_prime = friction_factor * velocities + force_el_term\n                \n                # Step 2: Rescale\n                sum_sq_v_prime = np.sum(v_prime**2)\n                if sum_sq_v_prime == 0:\n                    # This case results in division by zero for the scaling factor.\n                    # It's a fatal flaw of the algorithm under these conditions.\n                    return np.inf\n\n                scaling_factor = np.sqrt(N * k_B * T0 / (m * sum_sq_v_prime))\n                velocities = scaling_factor * v_prime\n            \n            # --- Calculate and store metrics for the current step ---\n            v_com = np.mean(velocities)\n            v_com_hist[i] = v_com\n            \n            T_raw_hist[i] = m * np.sum(velocities**2) / (N * k_B)\n            \n            peculiar_velocities = velocities - v_com\n            T_pec_hist[i] = m * np.sum(peculiar_velocities**2) / (N * k_B)\n\n        # --- Post-simulation Analysis ---\n        # 1. Temperature drift rate 'a'\n        slope, _, _, _, _ = linregress(times, T_raw_hist)\n        a = slope\n\n        # 2. Peculiar temperature bias\n        final_half_start_idx = n_steps // 2\n        T_pec_mean = np.mean(T_pec_hist[final_half_start_idx:])\n        pec_temp_bias = np.abs(T_pec_mean - T0)\n        \n        # 3. Drift bias\n        v_th = (q * E / gamma) if gamma > 0 else 0.0\n        final_10_percent_idx = int(0.9 * n_steps)\n        v_com_mean = np.mean(v_com_hist[final_10_percent_idx:])\n        drift_bias = np.abs(v_com_mean - v_th)\n\n        # --- Composite Bias Score ---\n        T_sim = n_steps * dt\n        \n        term1 = pec_temp_bias / T0\n        term2 = drift_bias / max(np.abs(v_th), epsilon)\n        term3 = np.abs(a) * T_sim / T0\n        \n        composite_score = term1 + term2 + term3\n        \n        return composite_score\n\n    recommended_strategies = []\n    for params in TEST_CASES:\n        scores = []\n        for strategy_code in [0, 1, 2]:\n            score = run_simulation(params, strategy_code, CONSTANTS)\n            scores.append(score)\n        \n        # Find the strategy with the minimum composite bias score\n        best_strategy = np.argmin(scores)\n        recommended_strategies.append(best_strategy)\n    \n    print(f\"[{','.join(map(str, recommended_strategies))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Analyzing particle configurations to understand structure is a core task in molecular simulation. While the radial distribution function, $g(r)$, is the standard tool for quantifying pairwise structure, it cannot fully describe the complex three-dimensional arrangements of molecules in dense systems like ionic liquids. This exercise () introduces a three-body angular distribution function to probe the local geometry of ion coordination shells, highlighting the crucial fact that a coarse-grained model matching $g(r)$ does not necessarily capture these essential higher-order correlations.",
            "id": "4238726",
            "problem": "Consider a binary ionic system of cations and anions confined in a cubic periodic box of edge length $L$ with number of cations $N_{\\mathrm{C}}$ and number of anions $N_{\\mathrm{A}}$. Let $\\mathbf{r}_i^{\\mathrm{C}} \\in \\mathbb{R}^3$ denote cation positions and $\\mathbf{r}_j^{\\mathrm{A}} \\in \\mathbb{R}^3$ denote anion positions. Distances are computed under periodic boundary conditions using the minimal image convention. The aim is to define and compute a three-body angular distribution function for cation–anion–anion triplets and to evaluate whether coarse-grained models that reproduce the cation–anion radial distribution function also capture angular correlations indicative of ion cages.\n\nStart from the fundamental definition of the cation–anion radial distribution function $g_{\\mathrm{CA}}(r)$ in a homogeneous system,\n$$\ng_{\\mathrm{CA}}(r) = \\frac{1}{\\rho_{\\mathrm{A}}} \\frac{1}{4\\pi r^2} \\frac{1}{N_{\\mathrm{C}}} \\left\\langle \\sum_{i=1}^{N_{\\mathrm{C}}} \\sum_{j=1}^{N_{\\mathrm{A}}} \\delta\\!\\left(r - \\left\\|\\mathbf{r}_i^{\\mathrm{C}} - \\mathbf{r}_j^{\\mathrm{A}}\\right\\|_{\\mathrm{MI}}\\right) \\right\\rangle,\n$$\nwhere $\\rho_{\\mathrm{A}} = N_{\\mathrm{A}}/V$ is the anion number density, $V=L^3$ is the volume, and $\\|\\cdot\\|_{\\mathrm{MI}}$ denotes the minimal-image norm in the periodic box.\n\nDefine a cation-centered three-body angle $\\theta$ for an anion–cation–anion triplet $(j,i,k)$ as the angle between the vectors $\\mathbf{r}_{ij} = \\mathbf{r}_j^{\\mathrm{A}} - \\mathbf{r}_i^{\\mathrm{C}}$ and $\\mathbf{r}_{ik} = \\mathbf{r}_k^{\\mathrm{A}} - \\mathbf{r}_i^{\\mathrm{C}}$ reduced by the minimal image map:\n$$\n\\theta_{jik} = \\arccos\\!\\left( \\frac{\\mathbf{r}_{ij} \\cdot \\mathbf{r}_{ik}}{\\|\\mathbf{r}_{ij}\\|\\, \\|\\mathbf{r}_{ik}\\|} \\right), \\quad \\theta_{jik} \\in [0,\\pi].\n$$\nFrom the set of all such angles formed by unordered anion pairs $(j,k)$ in the first coordination shell around each cation, construct the angle probability density $p(\\theta)$ by histogramming angles over $[0,\\pi]$ and normalizing such that $\\int_0^\\pi p(\\theta)\\, d\\theta = 1$. To remove the geometric bias that arises from uniform sampling over the sphere, define the geometry-corrected angular distribution function\n$$\nA(\\theta) = \\frac{p(\\theta)}{\\frac{1}{2}\\sin\\theta} \\Bigg/ \\left( \\int_0^\\pi \\frac{p(\\vartheta)}{\\frac{1}{2}\\sin\\vartheta}\\, d\\vartheta \\right),\n$$\nso that if the anion directions are uniformly distributed around cations then $A(\\theta)$ is approximately constant over $\\theta \\in [0,\\pi]$. Ion cages correspond to angular correlations that produce pronounced peaks in $A(\\theta)$.\n\nThe first coordination shell is operationally identified by the first minimum $r_{\\min}$ of $g_{\\mathrm{CA}}(r)$ following its first peak $r_{\\mathrm{peak}}$, and anions within the shell satisfy $\\|\\mathbf{r}_{ij}\\| \\le r_{\\min}$.\n\nYou must implement an algorithm that:\n1. Computes $g_{\\mathrm{CA}}(r)$ from positions using periodic minimal images and estimates $r_{\\mathrm{peak}}$ and $r_{\\min}$ by locating the first local maximum and subsequent first local minimum of a lightly smoothed $g_{\\mathrm{CA}}(r)$.\n2. Computes the geometry-corrected angular distribution $A(\\theta)$ from all cation–anion–anion triplets where both anions lie within $r_{\\min}$ of the cation. Angles must be measured in radians.\n3. Compares a coarse-grained model (CG) against an atomistic reference (AT) by two metrics:\n   - A radial metric defined as the squared $L^2$ norm between the two normalized $g_{\\mathrm{CA}}(r)$ curves over the histogram bin centers,\n     $$\n     \\Delta_r = \\left\\| g_{\\mathrm{CA}}^{\\mathrm{CG}} - g_{\\mathrm{CA}}^{\\mathrm{AT}} \\right\\|_2,\n     $$\n     and declare the radial match satisfied if $\\Delta_r \\le \\varepsilon_r$.\n   - An angular metric defined as the squared $L^2$ norm between the geometry-corrected distributions over angle bin centers,\n     $$\n     \\Delta_\\theta = \\left\\| A^{\\mathrm{CG}} - A^{\\mathrm{AT}} \\right\\|_2,\n     $$\n     and declare the angular match satisfied if $\\Delta_\\theta \\le \\varepsilon_\\theta$.\n4. Returns a boolean for each test case that is true if and only if both the radial and angular matches are satisfied and there is sufficient statistics, quantified by requiring at least $M_{\\min}$ angles in both AT and CG datasets; otherwise return false.\n\nAngles must be handled in radians. Distances must be computed in nanometers. No physical unit conversion is required in the output because the final result is boolean.\n\nTest suite. Use the following four test cases, each specified by a tuple of parameters that direct the synthetic system generation and comparison:\n- Case 1 (happy path): $(L, N_{\\mathrm{C}}, N_{\\mathrm{A}}, r_0, \\sigma_r, \\text{seed}) = (4.0\\,\\mathrm{nm}, 32, 256, 0.45\\,\\mathrm{nm}, 0.02\\,\\mathrm{nm}, 123)$. Construct AT by placing $N_{\\mathrm{C}}$ cations uniformly in the box and, for each cation, $8$ anions near the cation at distance $r_0$ in directions $\\{\\pm \\hat{x}, \\pm \\hat{y}, \\pm \\hat{z}\\}$ with independent Gaussian radial noise of standard deviation $\\sigma_r$; distribute remaining anions uniformly in the box to represent a bulk environment. Construct CG by copying AT cation positions and generating anions with the same radial distances and directions but with additional small Gaussian noise of standard deviation $0.01\\,\\mathrm{nm}$ applied to both radius and direction via a small random displacement. Expect the result to be true.\n- Case 2 (angular mismatch): $(L, N_{\\mathrm{C}}, N_{\\mathrm{A}}, r_0, \\sigma_r, \\text{seed}) = (4.0\\,\\mathrm{nm}, 32, 256, 0.45\\,\\mathrm{nm}, 0.02\\,\\mathrm{nm}, 456)$. Construct AT as in Case 1. Construct CG by preserving the same set of radial distances around each cation but assigning random independent directions uniformly on the unit sphere. Expect the result to be false.\n- Case 3 (radial mismatch): $(L, N_{\\mathrm{C}}, N_{\\mathrm{A}}, r_0, \\sigma_r, \\text{seed}) = (4.0\\,\\mathrm{nm}, 32, 256, 0.45\\,\\mathrm{nm}, 0.02\\,\\mathrm{nm}, 789)$. Construct AT as in Case 1. Construct CG by scaling all anion–cation target radial distances in the first shell by a factor of $1.25$ while keeping directions as in AT. Expect the result to be false.\n- Case 4 (insufficient statistics boundary): $(L, N_{\\mathrm{C}}, N_{\\mathrm{A}}, r_0, \\sigma_r, \\text{seed}) = (4.0\\,\\mathrm{nm}, 12, 24, 0.45\\,\\mathrm{nm}, 0.02\\,\\mathrm{nm}, 13579)$. Construct AT by placing $N_{\\mathrm{C}}$ cations and for a subset of cations place only one nearby anion within distance $r_0$; distribute other anions uniformly far from cations, so many cations have fewer than two anions within the first shell. Construct CG to preserve the same radial distribution but with random directions. Expect the result to be false due to insufficient angles.\n\nAlgorithmic and numerical details:\n- Use the minimal image convention with box length $L$ to compute $\\|\\cdot\\|_{\\mathrm{MI}}$.\n- Use $n_r=200$ radial bins between $0$ and $L/2$ and $n_\\theta=60$ angular bins between $0$ and $\\pi$.\n- Smooth $g_{\\mathrm{CA}}(r)$ via a short moving-average window of width $w=5$ bins before peak and minimum detection.\n- Use tolerances $\\varepsilon_r = 0.08$, $\\varepsilon_\\theta = 0.12$, and minimum angles $M_{\\min} = 50$.\n- If no clear first minimum is found after the first peak in $g_{\\mathrm{CA}}(r)$, set the cutoff $r_{\\min}$ to the radial bin center just after the peak plus a margin of $0.1\\,\\mathrm{nm}$, capped at $L/2$.\n\nYour program should implement the synthetic data generation based on the above instructions deterministically from the provided seeds, perform the analysis described, and produce a single line of output containing the boolean results for all four cases as a comma-separated list enclosed in square brackets (e.g., \"[True,False,False,False]\").",
            "solution": "The user-provided problem is valid. It is a well-defined task in computational statistical mechanics, grounded in standard principles of molecular simulation data analysis. It requires the implementation of algorithms to compute radial and angular distribution functions to compare coarse-grained and atomistic models of an ionic system. The problem is self-contained, scientifically sound, and algorithmically specified.\n\nThe solution is structured around a sequence of physically-motivated computational steps designed to extract structural information from particle configurations and compare different models based on that information. The core of the analysis involves quantifying both radial and angular correlations between ions.\n\n### Principle 1: System Representation and Periodic Boundary Conditions\n\nThe system is a collection of $N_{\\mathrm{C}}$ cations and $N_{\\mathrm{A}}$ anions in a cubic box of side length $L$. To simulate a bulk-like environment and minimize surface effects, periodic boundary conditions (PBC) are employed. This means the box is replicated infinitely in all three spatial dimensions. When computing the distance or the vector between two particles, we use the minimal image convention (MIC). The displacement vector $\\mathbf{v}$ between two particles is mapped to its shortest periodic image $\\mathbf{v}_{\\mathrm{MI}}$ by:\n$$\n\\mathbf{v}_{\\mathrm{MI}} = \\mathbf{v} - L \\cdot \\mathrm{round}(\\mathbf{v} / L)\n$$\nThe distance is then the Euclidean norm of this minimal image vector, $\\|\\mathbf{v}_{\\mathrm{MI}}\\|$. All spatial calculations must adhere strictly to this convention.\n\n### Principle 2: Radial and Angular Correlation Functions\n\nTo characterize the structure of the ionic liquid, we employ two types of correlation functions:\n\n1.  **Cation–Anion Radial Distribution Function, $g_{\\mathrm{CA}}(r)$**: This function describes the probability of finding an anion at a distance $r$ from a given cation, relative to the probability for a completely random (ideal gas) distribution. The provided definition is:\n    $$\n    g_{\\mathrm{CA}}(r) = \\frac{V}{N_{\\mathrm{C}} N_{\\mathrm{A}}} \\left\\langle \\sum_{i=1}^{N_{\\mathrm{C}}} \\sum_{j=1}^{N_{\\mathrm{A}}} \\frac{\\delta(r - \\|\\mathbf{r}_i^{\\mathrm{C}} - \\mathbf{r}_j^{\\mathrm{A}}\\|_{\\mathrm{MI}})}{4\\pi r^2} \\right\\rangle\n    $$\n    where $V=L^3$ is the volume. In a discrete implementation, we compute a histogram of cation-anion distances. For each bin $k$ with center $r_k$ and width $\\Delta r$, the value is calculated as:\n    $$\n    g_{\\mathrm{CA}}(r_k) = \\frac{\\text{counts}(r_k)}{N_{\\mathrm{C}}} \\frac{V}{N_{\\mathrm{A}}} \\frac{1}{4\\pi r_k^2 \\Delta r}\n    $$\n    Peaks in $g_{\\mathrm{CA}}(r)$ indicate preferred packing distances, forming coordination shells. The first minimum after the first peak, $r_{\\min}$, is a standard, operationally-defined boundary for the first coordination shell.\n\n2.  **Geometry-Corrected Angular Distribution, $A(\\theta)$**: While $g_{\\mathrm{CA}}(r)$ captures radial order, it is blind to the three-dimensional arrangement of anions around a cation. The function $A(\\theta)$ is designed to probe this local geometry. It measures the probability distribution of angles $\\theta_{jik}$ formed by anion-cation-anion triplets, where both anions $j$ and $k$ are within the first coordination shell (i.e., distance $\\le r_{\\min}$) of cation $i$.\n\n    To remove the trivial geometric bias where there are more ways to form large angles than small angles on a sphere, the raw angle probability density $p(\\theta)$ is divided by $\\frac{1}{2}\\sin\\theta$. The resulting function is then normalized to have unit integral over $[0, \\pi]$, yielding $A(\\theta)$.\n    $$\n    A(\\theta) = \\frac{p(\\theta)/\\left(\\frac{1}{2}\\sin\\theta\\right)}{\\int_0^\\pi \\left[ p(\\vartheta)/\\left(\\frac{1}{2}\\sin\\vartheta\\right) \\right] d\\vartheta}\n    $$\n    For a system with no angular preference (anions uniformly distributed on a sphere around the cation), $p(\\theta)$ is proportional to $\\sin\\theta$, making $A(\\theta)$ a constant. Peaks in $A(\\theta)$ reveal specific, preferred local geometries, such as tetrahedral or octahedral \"cages\".\n\n### Principle 3: Algorithmic Implementation and Model Comparison\n\nThe algorithm proceeds as follows for each test case, which provides a reference \"atomistic\" (AT) model and a \"coarse-grained\" (CG) model to be tested.\n\n1.  **Data Generation**: Synthetic particle configurations for AT and CG models are generated deterministically using the provided seeds and parameters for each test case. This step simulates the output of a molecular dynamics simulation.\n\n2.  **Structural Analysis**: Both AT and CG configurations are processed to compute their respective $g_{\\mathrm{CA}}(r)$ and $A(\\theta)$ distributions.\n    *   $g_{\\mathrm{CA}}(r)$ is calculated by histogramming all minimal-image cation-anion distances into $n_r=200$ bins and applying the normalization formula.\n    *   To robustly find the coordination shell cutoff $r_{\\min}$, the calculated $g_{\\mathrm{CA}}(r)$ is smoothed using a moving average filter of width $w=5$. The first significant peak and the subsequent first minimum are located in the smoothed data.\n    *   All anion-cation-anion angles for triplets within the $r_{\\min}$ cutoff are computed. The total number of angles is counted. If this count is below a threshold $M_{\\min}=50$, the statistics are deemed insufficient.\n    *   If statistics are sufficient, the angles are histogrammed into $n_\\theta=60$ bins to form $p(\\theta)$, which is then used to compute the normalized, geometry-corrected distribution $A(\\theta)$.\n\n3.  **Quantitative Comparison**: The fidelity of the CG model to the AT reference is assessed using two metrics based on the $L^2$ norm, which measures the integrated difference between the distributions:\n    *   **Radial Metric $\\Delta_r$**: The discrepancy in radial structure is $\\Delta_r = \\| g_{\\mathrm{CA}}^{\\mathrm{CG}} - g_{\\mathrm{CA}}^{\\mathrm{AT}} \\|_2$. A match is declared if $\\Delta_r \\le \\varepsilon_r = 0.08$.\n    *   **Angular Metric $\\Delta_\\theta$**: The discrepancy in angular structure is $\\Delta_\\theta = \\| A^{\\mathrm{CG}} - A^{\\mathrm{AT}} \\|_2$. A match is declared if $\\Delta_\\theta \\le \\varepsilon_\\theta = 0.12$.\n\n4.  **Final Verdict**: A test case is declared successful (evaluates to `True`) if and only if three conditions are met simultaneously: the number of angles for both AT and CG models is sufficient ($\\ge M_{\\min}$), the radial match is satisfied ($\\Delta_r \\le \\varepsilon_r$), and the angular match is satisfied ($\\Delta_\\theta \\le \\varepsilon_\\theta$). Otherwise, it fails (`False`). This rigorous, multi-faceted comparison ensures that a successful CG model reproduces not just pairwise distances but also the crucial higher-order angular correlations that define local ionic environments.",
            "answer": "```python\nimport numpy as np\nfrom scipy.signal import find_peaks\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for comparing coarse-grained vs. atomistic models.\n    \"\"\"\n    \n    # Define problem parameters\n    N_R_BINS = 200\n    N_THETA_BINS = 60\n    SMOOTH_W = 5\n    EPSILON_R = 0.08\n    EPSILON_theta = 0.12\n    M_MIN = 50\n\n    # Define test cases\n    test_cases = [\n        # (L, Nc, Na, r0, sigma_r, seed, case_type)\n        (4.0, 32, 256, 0.45, 0.02, 123, 'happy_path'),\n        (4.0, 32, 256, 0.45, 0.02, 456, 'angular_mismatch'),\n        (4.0, 32, 256, 0.45, 0.02, 789, 'radial_mismatch'),\n        (4.0, 12, 24, 0.45, 0.02, 13579, 'insufficient_stats'),\n    ]\n\n    results = []\n    for L, Nc, Na, r0, sigma_r, seed, case_type in test_cases:\n        \n        at_pos_c, at_pos_a, cg_pos_c, cg_pos_a = generate_configurations(\n            L, Nc, Na, r0, sigma_r, seed, case_type\n        )\n\n        g_at, A_at, n_angles_at, _, _ = analyze_system(\n            at_pos_c, at_pos_a, L, N_R_BINS, N_THETA_BINS, SMOOTH_W\n        )\n        \n        g_cg, A_cg, n_angles_cg, _, _ = analyze_system(\n            cg_pos_c, cg_pos_a, L, N_R_BINS, N_THETA_BINS, SMOOTH_W\n        )\n\n        stats_ok = (n_angles_at >= M_MIN) and (n_angles_cg >= M_MIN)\n\n        if not stats_ok:\n            results.append(False)\n            continue\n            \n        delta_r = np.linalg.norm(g_cg - g_at)\n        delta_theta = np.linalg.norm(A_cg - A_at)\n\n        radial_ok = delta_r = EPSILON_R\n        angular_ok = delta_theta = EPSILON_theta\n        \n        results.append(radial_ok and angular_ok)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef mic_vector(v, L):\n    \"\"\"Computes minimal image vector(s) in a cubic box of length L.\"\"\"\n    return v - L * np.round(v / L)\n\ndef generate_configurations(L, Nc, Na, r0, sigma_r, seed, case_type):\n    \"\"\"Generates AT and CG configurations based on the test case type.\"\"\"\n    rng = np.random.default_rng(seed)\n    \n    # Generate AT configuration\n    at_pos_c = rng.uniform(0, L, size=(Nc, 3))\n    at_pos_a = np.zeros((Na, 3))\n    \n    if case_type in ['happy_path', 'angular_mismatch', 'radial_mismatch']:\n        anions_per_cation = Na // Nc\n        directions = np.array([[1,0,0], [-1,0,0], [0,1,0], [0,-1,0], [0,0,1], [0,0,-1]])\n        idx = 0\n        for i in range(Nc):\n            # Place anions around cations\n            for j in range(anions_per_cation):\n                if j  6: # Octahedral placement first\n                    direction = directions[j]\n                else: # Add more in random directions if Na/Nc > 6\n                    u = rng.normal(size=3)\n                    direction = u / np.linalg.norm(u)\n\n                radius = rng.normal(r0, sigma_r)\n                at_pos_a[idx] = at_pos_c[i] + radius * direction\n                idx += 1\n        # Distribute remaining anions uniformly if Na is not a multiple of Nc\n        for k in range(idx, Na):\n            at_pos_a[k] = rng.uniform(0, L, size=3)\n\n    elif case_type == 'insufficient_stats':\n        anions_placed = 0\n        for i in range(Nc):\n            # Place one anion near each cation\n            if anions_placed  Na:\n                u = rng.normal(size=3)\n                direction = u / np.linalg.norm(u)\n                radius = rng.normal(r0, sigma_r)\n                at_pos_a[anions_placed] = at_pos_c[i] + radius * direction\n                anions_placed += 1\n        # Place remaining anions uniformly\n        for i in range(anions_placed, Na):\n            at_pos_a[i] = rng.uniform(0, L, size=3)\n\n    at_pos_a = np.mod(at_pos_a, L)\n\n    # Generate CG configuration\n    cg_pos_c = np.copy(at_pos_c)\n    cg_pos_a = np.zeros((Na, 3))\n\n    if case_type == 'happy_path':\n        noise = rng.normal(0, 0.01, size=at_pos_a.shape)\n        cg_pos_a = at_pos_a + noise\n\n    elif case_type == 'angular_mismatch':\n        idx = 0\n        anions_per_cation = Na // Nc\n        for i in range(Nc):\n            cation_pos = at_pos_c[i]\n            for _ in range(anions_per_cation):\n                # Preserve radial distance, randomize direction\n                disp_at = mic_vector(at_pos_a[idx] - cation_pos, L)\n                dist_at = np.linalg.norm(disp_at)\n                u_rand = rng.normal(size=3)\n                dir_rand = u_rand / np.linalg.norm(u_rand)\n                cg_pos_a[idx] = cation_pos + dist_at * dir_rand\n                idx += 1\n        for k in range(idx, Na):\n             cg_pos_a[k] = rng.uniform(0, L, size=3)\n\n\n    elif case_type == 'radial_mismatch':\n        idx = 0\n        anions_per_cation = Na // Nc\n        for i in range(Nc):\n            cation_pos = at_pos_c[i]\n            for _ in range(anions_per_cation):\n                # Scale radial distance\n                disp_at = mic_vector(at_pos_a[idx] - cation_pos, L)\n                cg_pos_a[idx] = cation_pos + 1.25 * disp_at\n                idx += 1\n        for k in range(idx, Na):\n             cg_pos_a[k] = at_pos_a[k]\n\n    elif case_type == 'insufficient_stats':\n        # Preserve radial dist, randomize direction, as in angular mismatch\n        anions_placed = 0\n        for i in range(Nc):\n            if anions_placed  Na:\n                disp_at = mic_vector(at_pos_a[anions_placed] - cg_pos_c[i], L)\n                dist_at = np.linalg.norm(disp_at)\n                u_rand = rng.normal(size=3)\n                dir_rand = u_rand / np.linalg.norm(u_rand)\n                cg_pos_a[anions_placed] = cg_pos_c[i] + dist_at * dir_rand\n                anions_placed += 1\n        for i in range(anions_placed, Na):\n            cg_pos_a[i] = at_pos_a[i]\n\n    cg_pos_a = np.mod(cg_pos_a, L)\n    \n    return at_pos_c, at_pos_a, cg_pos_c, cg_pos_a\n\ndef analyze_system(cat_pos, an_pos, L, n_r, n_theta, w):\n    \"\"\"Computes g(r), A(theta), and number of angles for a given system.\"\"\"\n    Nc, Na = len(cat_pos), len(an_pos)\n    V = L**3\n    rho_A = Na / V\n\n    # --- 1. Compute g(r) ---\n    r_max = L / 2\n    dr = r_max / n_r\n    r_bins = np.linspace(0, r_max, n_r + 1)\n    r_centers = (r_bins[:-1] + r_bins[1:]) / 2\n    counts = np.zeros(n_r, dtype=int)\n\n    for i in range(Nc):\n        disps = an_pos - cat_pos[i]\n        disps_mic = mic_vector(disps, L)\n        dists = np.linalg.norm(disps_mic, axis=1)\n        \n        valid_dists = dists[dists  r_max]\n        bin_indices = (valid_dists / dr).astype(int)\n        np.add.at(counts, bin_indices, 1)\n\n    shell_volumes = 4 * np.pi * r_centers**2 * dr\n    # Avoid division by zero at r=0\n    g_ca = np.zeros_like(shell_volumes)\n    non_zero_vols = shell_volumes > 1e-9\n    g_ca[non_zero_vols] = (counts[non_zero_vols] / Nc) / (rho_A * shell_volumes[non_zero_vols])\n\n    # --- 2. Find r_min ---\n    g_smooth = np.convolve(g_ca, np.ones(w)/w, mode='same')\n    peaks, _ = find_peaks(g_smooth)\n    if not len(peaks): # No peak found\n        first_peak_idx = np.argmax(g_smooth)\n    else:\n        first_peak_idx = peaks[0]\n\n    minima, _ = find_peaks(-g_smooth[first_peak_idx:])\n    if not len(minima):\n        r_peak_center = r_centers[first_peak_idx]\n        r_min = min(r_peak_center + 0.1, r_max)\n    else:\n        first_min_idx = minima[0] + first_peak_idx\n        r_min = r_centers[first_min_idx]\n\n    # --- 3. Compute A(theta) ---\n    theta_max = np.pi\n    dtheta = theta_max / n_theta\n    theta_bins = np.linspace(0, theta_max, n_theta + 1)\n    theta_centers = (theta_bins[:-1] + theta_bins[1:]) / 2\n    \n    angles = []\n    for i in range(Nc):\n        disps = an_pos - cat_pos[i]\n        disps_mic = mic_vector(disps, L)\n        dists = np.linalg.norm(disps_mic, axis=1)\n        \n        neighbor_indices = np.where(dists = r_min)[0]\n        if len(neighbor_indices)  2:\n            continue\n            \n        neighbor_vectors = disps_mic[neighbor_indices]\n        num_neighbors = len(neighbor_indices)\n        \n        for j1 in range(num_neighbors):\n            for j2 in range(j1 + 1, num_neighbors):\n                v1 = neighbor_vectors[j1]\n                v2 = neighbor_vectors[j2]\n                \n                cos_theta = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2))\n                cos_theta = np.clip(cos_theta, -1.0, 1.0)\n                angle = np.arccos(cos_theta)\n                angles.append(angle)\n\n    n_angles = len(angles)\n    if n_angles == 0:\n        return g_ca, np.zeros(n_theta), 0, r_centers, theta_centers\n\n    p_counts, _ = np.histogram(angles, bins=theta_bins)\n    p_theta = p_counts / (n_angles * dtheta)\n\n    sin_factor = 0.5 * np.sin(theta_centers)\n    \n    A_theta_raw = np.zeros_like(p_theta)\n    non_zero_sin = sin_factor > 1e-9\n    A_theta_raw[non_zero_sin] = p_theta[non_zero_sin] / sin_factor[non_zero_sin]\n\n    norm_const = np.sum(A_theta_raw) * dtheta\n    A_theta = A_theta_raw / norm_const if norm_const > 1e-9 else np.zeros_like(A_theta_raw)\n    \n    return g_ca, A_theta, n_angles, r_centers, theta_centers\n\nif __name__ == '__main__':\n    solve()\n\n```"
        },
        {
            "introduction": "A primary goal of molecular modeling is to predict macroscopic thermodynamic properties from the simulated microscopic behavior. Kirkwood-Buff theory provides a powerful and exact statistical mechanical framework for connecting the microscopic structure of a solution to its thermodynamic properties. This practice () guides you through applying this theory to compute the mean ionic activity coefficient, a key measure of non-ideality, directly from a set of concentration-dependent radial distribution functions for a polymer electrolyte model.",
            "id": "4238706",
            "problem": "You are given a coarse-grained model for Poly(ethylene oxide) (PEO)–Lithium (Li) polymer electrolytes in which each chemical species is represented by a single site type: solvent PEO segments $(i=1)$, lithium cations $(i=2)$, and anions $(i=3)$. The structural information is provided through analytic radial distribution functions (RDFs) $g_{ij}(r;c)$ that depend on separation distance $r$ and bulk salt concentration $c$ in moles per liter (M). Using Kirkwood–Buff theory, compute the mean ionic activity coefficient $\\gamma_{\\pm}(c)$ as a function of salt concentration for a specified set of test concentrations. Validate the computed trend against the expected experimental behavior for polymer electrolytes, namely a decrease at low concentrations due to favorable solvation followed by an increase at higher concentrations due to ion pairing and reduced solvation.\n\nFundamental base to use:\n- Statistical mechanics of solutions in the grand canonical ensemble.\n- Definition of the radial distribution function $g_{ij}(r)$ and its total correlation function $h_{ij}(r) = g_{ij}(r) - 1$.\n- Kirkwood–Buff integrals:\n$$\nG_{ij}(c) = 4\\pi \\int_{0}^{\\infty} \\left[g_{ij}(r;c) - 1\\right] r^2 \\, dr,\n$$\nwhich have units of volume.\n- Fluctuation–response relation (grand canonical): the matrix of concentration fluctuations\n$$\nC_{ij}(\\boldsymbol{\\rho}, c) = \\rho_i \\delta_{ij} + \\rho_i \\rho_j G_{ij}(c),\n$$\nand the derivative of the chemical potentials with respect to densities\n$$\n\\frac{\\partial \\mu_i}{\\partial \\rho_j} = k_{\\mathrm{B}} T \\left[C^{-1}(\\boldsymbol{\\rho}, c)\\right]_{ij},\n$$\nwhere $k_{\\mathrm{B}}$ is the Boltzmann constant, $T$ is the absolute temperature, and $\\boldsymbol{\\rho} = (\\rho_1,\\rho_2,\\rho_3)$ are number densities. For an ideal mixture (no correlations), $G_{ij}=0$ and $C_{ij}^{\\mathrm{id}} = \\rho_i \\delta_{ij}$, hence $\\left[C^{\\mathrm{id}}\\right]^{-1}_{ij} = \\delta_{ij}/\\rho_i$, so the excess derivative is\n$$\n\\left(\\frac{\\partial \\mu_i}{\\partial \\rho_j}\\right)^{\\mathrm{ex}} = k_{\\mathrm{B}} T \\left\\{\\left[C^{-1}\\right]_{ij} - \\frac{\\delta_{ij}}{\\rho_i}\\right\\}.\n$$\nBy integrating these excess derivatives along a path in density space from zero salt to the target densities, one obtains the excess chemical potentials $\\mu_i^{\\mathrm{ex}}(\\boldsymbol{\\rho})$ and thus the activity coefficients.\n\nDefinitions, parameters, and units:\n- Distance $r$ in nanometers (nm), number densities $\\rho_i$ in nm$^{-3}$, temperature $T = 298\\,\\mathrm{K}$, Boltzmann constant $k_{\\mathrm{B}} = 1.380649\\times 10^{-23}\\,\\mathrm{J/K}$.\n- Avogadro’s number $N_{\\mathrm{A}} = 6.02214076\\times 10^{23}\\,\\mathrm{mol}^{-1}$.\n- Conversion from molar concentration to number density: $\\rho = c\\,N_{\\mathrm{A}}/10^{24}$ nm$^{-3}$, because $1\\,\\mathrm{L} = 10^{24}\\,\\mathrm{nm}^3$. Numerically, $\\rho \\approx 0.602214076 \\, c$ nm$^{-3}$.\n- Solvent (PEO segment) number density is fixed at $\\rho_1 = 10.0$ nm$^{-3}$ for all test cases.\n- Electroneutrality implies $\\rho_2 = \\rho_3 = \\rho_{\\mathrm{salt}} = 0.602214076 \\, c$ nm$^{-3}$.\n- RDFs $g_{ij}(r;c)$ are provided below and are scientifically plausible coarse-grained forms that yield convergent Kirkwood–Buff integrals and capture solvation and ion-pairing trends:\n\nFor $i=j$ (like species):\n- PEO–PEO $(i=j=1)$:\n$$\ng_{11}(r) = 1 + S_{11}\\,\\exp\\!\\left(-\\frac{r}{\\lambda_{11}}\\right), \\quad S_{11} = 0.10,\\ \\lambda_{11} = 0.80 \\ \\mathrm{nm}.\n$$\n- Li–Li $(i=j=2)$ and anion–anion $(i=j=3)$:\n$$\ng_{22}(r;c) = 1 - H_{22}(c)\\,\\exp\\!\\left(-\\frac{r}{\\lambda_{22}}\\right), \\quad H_{22}(c) = \\frac{0.60}{1 + 0.30\\,c},\\ \\lambda_{22} = 0.25 \\ \\mathrm{nm},\n$$\n$$\ng_{33}(r;c) = 1 - H_{33}(c)\\,\\exp\\!\\left(-\\frac{r}{\\lambda_{33}}\\right), \\quad H_{33}(c) = \\frac{0.50}{1 + 0.30\\,c},\\ \\lambda_{33} = 0.25 \\ \\mathrm{nm}.\n$$\n\nFor $i\\neq j$ (cross correlations):\n- Li–PEO $(i=2,j=1)$:\n$$\ng_{12}(r;c) = 1 + A_{12}(c)\\,\\exp\\!\\left(-\\frac{(r-r_{0,12})^2}{2\\sigma_{12}^2}\\right) - D_{12}\\,\\exp\\!\\left(-\\frac{r}{\\lambda_{d,12}}\\right),\n$$\nwith $A_{12}(c) = \\dfrac{4.0}{1 + 1.5\\,c}$, $r_{0,12} = 0.35\\,\\mathrm{nm}$, $\\sigma_{12} = 0.06\\,\\mathrm{nm}$, $D_{12} = 0.30$, $\\lambda_{d,12} = 0.50\\,\\mathrm{nm}$.\n- Anion–PEO $(i=3,j=1)$:\n$$\ng_{13}(r;c) = 1 + A_{13}(c)\\,\\exp\\!\\left(-\\frac{(r-r_{0,13})^2}{2\\sigma_{13}^2}\\right) - D_{13}\\,\\exp\\!\\left(-\\frac{r}{\\lambda_{d,13}}\\right),\n$$\nwith $A_{13}(c) = \\dfrac{2.0}{1 + 1.0\\,c}$, $r_{0,13} = 0.40\\,\\mathrm{nm}$, $\\sigma_{13} = 0.08\\,\\mathrm{nm}$, $D_{13} = 0.20$, $\\lambda_{d,13} = 0.60\\,\\mathrm{nm}$.\n- Li–anion $(i=2,j=3)$:\n$$\ng_{23}(r;c) = 1 + P_{23}(c)\\,\\exp\\!\\left(-\\frac{r}{\\lambda_{23}}\\right), \\quad P_{23}(c) = 0.20 + 0.50\\,c,\\ \\lambda_{23} = 0.20 \\ \\mathrm{nm}.\n$$\nSymmetry implies $g_{ij} = g_{ji}$, and thus $G_{ij} = G_{ji}$.\n\nAlgorithmic task to compute $\\gamma_{\\pm}(c)$:\n1. For a given $c$, construct a radial grid $r \\in [0, R_{\\max}]$ with $R_{\\max} = 5.0\\,\\mathrm{nm}$ and a uniform grid spacing $\\Delta r$ sufficiently small to ensure numerical accuracy.\n2. Evaluate each $g_{ij}(r;c)$ on the grid and compute $G_{ij}(c) = 4\\pi \\int_0^{R_{\\max}} [g_{ij}(r;c) - 1]\\,r^2\\,dr$ using a numerically stable quadrature such as the trapezoidal rule.\n3. Convert $c$ to number densities $(\\rho_1,\\rho_2,\\rho_3)$ using the rules given above, with $\\rho_1$ fixed and $\\rho_2=\\rho_3=0.602214076\\,c$ nm$^{-3}$.\n4. Form the matrix $C_{ij}(\\boldsymbol{\\rho},c) = \\rho_i \\delta_{ij} + \\rho_i \\rho_j G_{ij}(c)$.\n5. Compute $M_{ij}(\\boldsymbol{\\rho},c) = k_{\\mathrm{B}} T\\,\\left[C^{-1}(\\boldsymbol{\\rho},c)\\right]_{ij}$ and the excess derivative matrix $M^{\\mathrm{ex}}_{ij} = M_{ij} - k_{\\mathrm{B}} T\\,\\delta_{ij}/\\rho_i$.\n6. Integrate along the electroneutral path where $\\rho_1$ is constant, $\\rho_2 = \\rho_3 = \\rho_{\\mathrm{salt}}$ increases from $0$ to its target value. Using a discretization $\\rho_{\\mathrm{salt}}^{(0)} \\approx 10^{-8}\\,\\mathrm{nm}^{-3}$ to avoid division by zero, compute for $i=2,3$:\n$$\n\\mu_i^{\\mathrm{ex}} = \\int_{\\rho_{\\mathrm{salt}}=0}^{\\rho_{\\mathrm{salt}}^{\\mathrm{target}}} \\left[M^{\\mathrm{ex}}_{i2}(\\boldsymbol{\\rho},c) + M^{\\mathrm{ex}}_{i3}(\\boldsymbol{\\rho},c)\\right] d\\rho_{\\mathrm{salt}}.\n$$\n7. Compute the mean ionic activity coefficient\n$$\n\\gamma_{\\pm}(c) = \\exp\\!\\left(\\frac{\\mu_2^{\\mathrm{ex}} + \\mu_3^{\\mathrm{ex}}}{2 k_{\\mathrm{B}} T}\\right),\n$$\nwhich is dimensionless.\n\nTest suite and validation:\n- Use the following salt concentrations $c$ in moles per liter (M): $c \\in \\{0.01,\\ 0.10,\\ 0.50,\\ 1.00\\}$.\n- For each $c$, compute $\\gamma_{\\pm}(c)$ rounded to four decimal places.\n- Validation against experimental trends: Polymer electrolytes typically exhibit $\\gamma_{\\pm}$ that decreases from near unity at very low concentrations due to favorable solvation, then increases at higher concentrations due to significant ion pairing and reduced solvation. Define the boolean flag $\\mathrm{trend\\_ok}$ to be true if and only if the sequence satisfies both $\\gamma_{\\pm}(0.01)  \\gamma_{\\pm}(0.10)$ and $\\gamma_{\\pm}(1.00)  \\gamma_{\\pm}(0.50)$ and the minimum of the list occurs at either $c=0.10$ or $c=0.50$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain the four rounded activity coefficients followed by the boolean validation flag, in this order. For example: \"[0.9876,0.9543,1.1032,1.2541,True]\".",
            "solution": "The user wants to compute the mean ionic activity coefficient, $\\gamma_{\\pm}(c)$, for a coarse-grained model of a polymer electrolyte using Kirkwood–Buff theory. The problem is deemed valid as it is scientifically grounded in statistical mechanics, well-posed with all necessary definitions and parameters, and objectively formulated. The provided analytical forms for the radial distribution functions $g_{ij}(r;c)$ are plausible and allow for a complete numerical solution.\n\nThe solution proceeds by implementing the multi-step algorithm detailed in the problem statement.\n\nFirst, we define all physical constants and model parameters.\n-   Boltzmann constant: $k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}\\,\\mathrm{J/K}$\n-   Temperature: $T = 298\\,\\mathrm{K}$\n-   Avogadro's number: $N_{\\mathrm{A}} = 6.02214076 \\times 10^{23}\\,\\mathrm{mol}^{-1}$\n-   Conversion from molarity (M) to number density (nm$^{-3}$): $\\rho = c \\cdot (N_{\\mathrm{A}} / 10^{24})$, as $1\\,\\mathrm{L} = 10^{3}\\,\\mathrm{cm}^3 = 10^{24}\\,\\mathrm{nm}^3$. Let this conversion factor be $k_c = N_{\\mathrm{A}}/10^{24} \\approx 0.602214\\,\\mathrm{nm}^{-3}\\,\\mathrm{M}^{-1}$.\n-   Number density of PEO segments (species 1): $\\rho_1 = 10.0\\,\\mathrm{nm}^{-3}$.\n-   Number densities of cation (species 2) and anion (species 3): $\\rho_2 = \\rho_3 = \\rho_{\\mathrm{salt}} = k_c \\cdot c$.\n\nThe core of the calculation involves the Kirkwood–Buff integrals (KBIs), $G_{ij}(c)$, defined as:\n$$\nG_{ij}(c) = 4\\pi \\int_{0}^{\\infty} h_{ij}(r;c) r^2 \\, dr\n$$\nwhere $h_{ij}(r;c) = g_{ij}(r;c) - 1$ is the total correlation function. The problem provides analytical expressions for all $g_{ij}(r;c)$, which depend on the salt concentration $c$. These integrals are computed numerically using the trapezoidal rule on a fine radial grid from $r=0$ to $R_{\\max} = 5.0\\,\\mathrm{nm}$. This cutoff is justified as all correlation functions decay exponentially to negligible values by this distance.\n\nWith the KBIs, we construct the concentration fluctuation matrix, $C_{ij}$, a $3 \\times 3$ matrix for our three-component system:\n$$\nC_{ij}(\\boldsymbol{\\rho}, c) = \\rho_i \\delta_{ij} + \\rho_i \\rho_j G_{ij}(c)\n$$\nwhere $\\boldsymbol{\\rho} = (\\rho_1, \\rho_2, \\rho_3)$ is the vector of number densities.\n\nThe derivatives of the chemical potentials with respect to number densities are related to the inverse of this matrix: $\\partial \\mu_i / \\partial \\rho_j = k_{\\mathrm{B}} T [C^{-1}]_{ij}$. The excess part of this derivative, which accounts for non-ideal interactions, is given by:\n$$\n\\left(\\frac{\\partial \\mu_i}{\\partial \\rho_j}\\right)^{\\mathrm{ex}} = M^{\\mathrm{ex}}_{ij} = k_{\\mathrm{B}} T \\left( [C^{-1}]_{ij} - \\frac{\\delta_{ij}}{\\rho_i} \\right)\n$$\nThe excess chemical potential $\\mu_i^{\\mathrm{ex}}$ for the ionic species ($i=2,3$) is obtained by integrating these derivatives along a specified thermodynamic path. The path is at a constant solvent density $\\rho_1$ while the salt densities $\\rho_2$ and $\\rho_3$ are increased together from $0$ to their final values, i.e., $\\rho_2 = \\rho_3 = \\rho_{\\mathrm{salt}}$. The differential of the excess chemical potential is $d\\mu_i^{\\mathrm{ex}} = \\sum_j (\\partial\\mu_i^{\\mathrm{ex}}/\\partial\\rho_j) d\\rho_j$. Along our path, $d\\rho_1=0$ and $d\\rho_2 = d\\rho_3 = d\\rho_{\\mathrm{salt}}$. This leads to the integral:\n$$\n\\mu_i^{\\mathrm{ex}}(\\rho_{\\mathrm{salt}}^{\\mathrm{target}}) = \\int_{0}^{\\rho_{\\mathrm{salt}}^{\\mathrm{target}}} \\left[ M^{\\mathrm{ex}}_{i2}(\\rho_{\\mathrm{salt}}) + M^{\\mathrm{ex}}_{i3}(\\rho_{\\mathrm{salt}}) \\right] d\\rho_{\\mathrm{salt}}\n$$\nThis integral is also computed numerically using the trapezoidal rule over a grid of $\\rho_{\\mathrm{salt}}$ values. The lower integration limit is set to a small positive number ($\\approx 10^{-8}\\,\\mathrm{nm}^{-3}$) to avoid numerical issues with the $1/\\rho_i$ term at $\\rho_{\\mathrm{salt}}=0$.\n\nFinally, the mean ionic activity coefficient $\\gamma_{\\pm}(c)$ is calculated from the excess chemical potentials of the cation and anion:\n$$\n\\gamma_{\\pm}(c) = \\exp\\left(\\frac{\\mu_2^{\\mathrm{ex}} + \\mu_3^{\\mathrm{ex}}}{2 k_{\\mathrm{B}} T}\\right)\n$$\n\nThis entire procedure is repeated for each target concentration $c \\in \\{0.01, 0.10, 0.50, 1.00\\}$. The resulting sequence of $\\gamma_{\\pm}$ values is then validated against the expected experimental trend: an initial decrease followed by an increase, with the minimum occurring at an intermediate concentration. A boolean flag, $\\mathrm{trend\\_ok}$, is set based on this validation. The final output is a list containing the four computed $\\gamma_{\\pm}$ values (rounded to four decimal places) and the boolean flag.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the mean ionic activity coefficient for a polymer electrolyte model\n    using Kirkwood-Buff theory and validates the concentration trend.\n    \"\"\"\n    # Physical and model constants\n    K_B = 1.380649e-23  # J/K\n    T = 298.0  # K\n    N_A = 6.02214076e23  # mol^-1\n    C_TO_RHO = N_A / 1e24  # (mol/L) to (nm^-3) conversion factor\n    RHO1 = 10.0  # nm^-3, fixed solvent density\n\n    # Parameters for RDFs\n    params = {\n        'g11': {'S11': 0.10, 'lambda11': 0.80},\n        'g22': {'H22_num': 0.60, 'H22_den': 0.30, 'lambda22': 0.25},\n        'g33': {'H33_num': 0.50, 'H33_den': 0.30, 'lambda33': 0.25},\n        'g12': {'A12_num': 4.0, 'A12_den': 1.5, 'r0_12': 0.35, 'sigma12': 0.06, 'D12': 0.30, 'lambda_d12': 0.50},\n        'g13': {'A13_num': 2.0, 'A13_den': 1.0, 'r0_13': 0.40, 'sigma13': 0.08, 'D13': 0.20, 'lambda_d13': 0.60},\n        'g23': {'P23_base': 0.20, 'P23_c': 0.50, 'lambda23': 0.20}\n    }\n\n    # Numerical integration settings\n    R_MAX = 5.0\n    N_R = 10001\n    r_grid = np.linspace(0, R_MAX, N_R)\n\n    def get_G_matrix(c, r):\n        \"\"\"Calculates the 3x3 matrix of Kirkwood-Buff integrals G_ij for a given concentration c.\"\"\"\n        # Calculate h_ij(r) = g_ij(r) - 1\n        p = params\n        h = np.zeros((3, 3, len(r)))\n\n        h[0, 0, :] = p['g11']['S11'] * np.exp(-r / p['g11']['lambda11'])\n        \n        H22_c = p['g22']['H22_num'] / (1 + p['g22']['H22_den'] * c)\n        h[1, 1, :] = -H22_c * np.exp(-r / p['g22']['lambda22'])\n\n        H33_c = p['g33']['H33_num'] / (1 + p['g33']['H33_den'] * c)\n        h[2, 2, :] = -H33_c * np.exp(-r / p['g33']['lambda33'])\n\n        A12_c = p['g12']['A12_num'] / (1 + p['g12']['A12_den'] * c)\n        h[0, 1, :] = (A12_c * np.exp(-(r - p['g12']['r0_12'])**2 / (2 * p['g12']['sigma12']**2))\n                    - p['g12']['D12'] * np.exp(-r / p['g12']['lambda_d12']))\n        \n        A13_c = p['g13']['A13_num'] / (1 + p['g13']['A13_den'] * c)\n        h[0, 2, :] = (A13_c * np.exp(-(r - p['g13']['r0_13'])**2 / (2 * p['g13']['sigma13']**2))\n                    - p['g13']['D13'] * np.exp(-r / p['g13']['lambda_d13']))\n\n        P23_c = p['g23']['P23_base'] + p['g23']['P23_c'] * c\n        h[1, 2, :] = P23_c * np.exp(-r / p['g23']['lambda23'])\n\n        # Create integrands and compute G_ij\n        G = np.zeros((3, 3))\n        r_sq = r**2\n        integrand_factor = 4 * np.pi\n        for i in range(3):\n            for j in range(i, 3):\n                integrand = integrand_factor * h[i, j, :] * r_sq\n                G[i, j] = np.trapz(integrand, r)\n                if i != j:\n                    G[j, i] = G[i, j]\n        return G\n\n    def get_mu_ex_integrand(rho_salt):\n        \"\"\"Calculates the integrand for the excess chemical potential integral.\"\"\"\n        c = rho_salt / C_TO_RHO\n        G = get_G_matrix(c, r_grid)\n        rhos = np.array([RHO1, rho_salt, rho_salt])\n\n        # Construct the fluctuation matrix C\n        C = np.diag(rhos) + np.outer(rhos, rhos) * G\n\n        # Invert C and calculate M_ex matrix\n        C_inv = np.linalg.inv(C)\n        M_ex = np.zeros((3, 3))\n        for i in range(3):\n            for j in range(3):\n                delta_ij = 1.0 if i == j else 0.0\n                M_ex[i, j] = K_B * T * (C_inv[i, j] - delta_ij / rhos[i])\n\n        # Integrand for mu_2^ex and mu_3^ex\n        integrand_mu2 = M_ex[1, 1] + M_ex[1, 2]\n        integrand_mu3 = M_ex[2, 1] + M_ex[2, 2]\n        return integrand_mu2, integrand_mu3\n\n    # Main calculation loop for each test concentration\n    test_cs = [0.01, 0.10, 0.50, 1.00]\n    gamma_results = []\n\n    for c_target in test_cs:\n        rho_target = c_target * C_TO_RHO\n        rho_min = 1e-8\n        N_rho = 1001\n        rho_grid = np.linspace(rho_min, rho_target, N_rho)\n        \n        vec_integrand_mu2 = np.zeros(N_rho)\n        vec_integrand_mu3 = np.zeros(N_rho)\n\n        for i, rho_s in enumerate(rho_grid):\n            ig2, ig3 = get_mu_ex_integrand(rho_s)\n            vec_integrand_mu2[i] = ig2\n            vec_integrand_mu3[i] = ig3\n        \n        mu2_ex = np.trapz(vec_integrand_mu2, rho_grid)\n        mu3_ex = np.trapz(vec_integrand_mu3, rho_grid)\n        \n        gamma_pm = np.exp((mu2_ex + mu3_ex) / (2 * K_B * T))\n        gamma_results.append(round(gamma_pm, 4))\n\n    # Trend validation\n    g = np.array(gamma_results)\n    min_idx = np.argmin(g)\n    trend_ok = (g[0] > g[1]) and (g[3] > g[2]) and (min_idx in [1, 2])\n\n    # Format final output\n    output_str = f\"[{','.join(map(str, gamma_results))},{trend_ok}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}