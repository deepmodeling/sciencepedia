{
    "hands_on_practices": [
        {
            "introduction": "在深入研究复杂的表面过程模拟之前，我们必须首先掌握动力学蒙特卡洛（KMC）算法的核心机制。这个练习将带你从第一性原理出发，推导任何“无拒绝”KMC模拟中的两个基本要素：事件之间的时间步长以及在多个竞争性事件中选择哪一个发生的概率。通过解决这个问题，你将对KMC算法中时间如何推进以及系统状态如何演变的随机过程建立起坚实的数学基础。",
            "id": "4249483",
            "problem": "在电化学表面过程的无拒绝动力学蒙特卡罗（KMC）模拟中，单个表面位点可以经历三个互斥且独立的事件：阳离子吸附、表面扩散和电子转移驱动的解吸。将此动力学过程建模为连续时间马尔可夫链（CTMC），其中每个事件表示为一个具有恒定风险率（速率）的独立泊松过程。这些事件的速率分别为 $r_1=10\\,\\text{s}^{-1}$（吸附）、$r_2=1\\,\\text{s}^{-1}$（扩散）和 $r_3=0.1\\,\\text{s}^{-1}$（电子转移解吸）。仅使用独立泊松过程的基本性质和指数分布的无记忆性，从第一性原理推导连续KMC事件之间的平均等待时间 $\\langle \\Delta t \\rangle$以及每个通道的事件选择概率。然后计算此状态下的这些值。\n\n将最终答案以单个行向量的形式给出，其中依次包含平均等待时间 $\\langle \\Delta t \\rangle$ 和三个选择概率 $r_i/R$（其中 $R=\\sum_{i=1}^{3} r_i$），并使用精确的解析表达式。平均等待时间以秒为单位表示，概率以无量纲分数表示。不要使用百分号。无需四舍五入。",
            "solution": "该问题涉及三个独立的竞争性泊松过程，其速率分别为 $r_1, r_2, r_3$。每个过程 $i$ 的发生时间 $T_i$ 是一个独立的指数随机变量，其参数为 $r_i$。$T_i$ 的概率密度函数（PDF）为 $f_{T_i}(t) = r_i e^{-r_i t}$（$t \\ge 0$），累积分布函数（CDF）为 $F_{T_i}(t) = P(T_i \\le t) = 1 - e^{-r_i t}$。\n\n**1. 等待时间 $\\Delta t$ 的推导**\n\n下一个事件（无论类型）发生前的等待时间是所有单个事件等待时间的最小值，即 $\\Delta t = \\min(T_1, T_2, T_3)$。为了求出 $\\Delta t$ 的分布，我们首先计算其生存函数 $P(\\Delta t > t)$：\n$$\nP(\\Delta t > t) = P(\\min(T_1, T_2, T_3) > t)\n$$\n这个事件等价于所有三个独立事件的发生时间都大于 $t$：\n$$\nP(\\Delta t > t) = P(T_1 > t \\text{ and } T_2 > t \\text{ and } T_3 > t)\n$$\n由于事件是独立的，我们得到：\n$$\nP(\\Delta t > t) = P(T_1 > t) P(T_2 > t) P(T_3 > t)\n$$\n利用指数分布的性质 $P(T_i > t) = 1 - F_{T_i}(t) = e^{-r_i t}$，我们有：\n$$\nP(\\Delta t > t) = e^{-r_1 t} e^{-r_2 t} e^{-r_3 t} = e^{-(r_1+r_2+r_3)t}\n$$\n定义总速率 $R = \\sum_{i=1}^3 r_i$，则 $P(\\Delta t > t) = e^{-Rt}$。因此，$\\Delta t$ 的累积分布函数为 $F_{\\Delta t}(t) = P(\\Delta t \\le t) = 1 - P(\\Delta t > t) = 1 - e^{-Rt}$。这表明，多个独立泊松过程的叠加仍然是一个泊松过程，其总速率是各速率之和，而事件间的等待时间服从以总速率 $R$ 为参数的指数分布。\n\n**2. 平均等待时间 $\\langle \\Delta t \\rangle$ 的计算**\n\n一个速率参数为 $R$ 的指数分布随机变量的期望值（平均值）是 $1/R$。因此，平均等待时间为：\n$$\n\\langle \\Delta t \\rangle = \\frac{1}{R} = \\frac{1}{r_1 + r_2 + r_3}\n$$\n\n**3. 事件选择概率 $P_j$ 的推导**\n\n事件 $j$ 作为下一个发生的事件的概率，等于其等待时间 $T_j$ 在所有等待时间中最小的概率，即 $P(T_j = \\min(T_1, T_2, T_3))$。在一个“竞争过程”模型中，可以直观地证明，过程 $j$“获胜”的概率等于其速率占总速率的比例：\n$$\nP_j = P(\\text{事件 } j \\text{ 接下来发生}) = \\frac{r_j}{\\sum_{i=1}^3 r_i} = \\frac{r_j}{R}\n$$\n\n**4. 代入数值进行计算**\n\n给定的速率为 $r_1=10\\,\\text{s}^{-1}$，$r_2=1\\,\\text{s}^{-1}$，和 $r_3=0.1\\,\\text{s}^{-1}$。\n总速率：\n$$\nR = r_1 + r_2 + r_3 = 10 + 1 + 0.1 = 11.1\\,\\text{s}^{-1} = \\frac{111}{10}\\,\\text{s}^{-1}\n$$\n平均等待时间：\n$$\n\\langle \\Delta t \\rangle = \\frac{1}{R} = \\frac{1}{11.1} = \\frac{10}{111}\\,\\text{s}\n$$\n事件选择概率（以精确分数表示）：\n$$\nP_1 = \\frac{r_1}{R} = \\frac{10}{11.1} = \\frac{100}{111}\n$$\n$$\nP_2 = \\frac{r_2}{R} = \\frac{1}{11.1} = \\frac{10}{111}\n$$\n$$\nP_3 = \\frac{r_3}{R} = \\frac{0.1}{11.1} = \\frac{1}{111}\n$$\n因此，所求的向量 $(\\langle \\Delta t \\rangle, P_1, P_2, P_3)$ 为 $\\left( \\frac{10}{111}, \\frac{100}{111}, \\frac{10}{111}, \\frac{1}{111} \\right)$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{10}{111}  \\frac{100}{111}  \\frac{10}{111}  \\frac{1}{111}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "掌握了单步KMC的原理后，我们现在将其应用于一个经典的物理过程：表面吸附物的扩散。本练习要求你构建一个KMC模拟，追踪单个粒子在二维晶格上的随机游走，并通过分析其均方位移来提取宏观扩散系数$D$。这个实践将理论与模拟相结合，直观地展示了微观层面的随机跳跃事件如何涌现出宏观上可预测的扩散行为。",
            "id": "4249524",
            "problem": "考虑在计算电化学背景下，单个吸附物在无限二维方格晶格上的扩散，该过程通过动力学蒙特卡洛（KMC）方法建模。每次跳跃是长度为 $a$ 的最近邻移动，朝四个等效方向之一移动的概率相等。每个方向的微观扩散速率由阿伦尼乌斯形式给出：$k_{\\text{diff}}=\\nu \\exp\\!\\left(-E_a/(k_B T)\\right)$，其中 $\\nu$ 是尝试频率，$E_a$ 是活化能，$k_B$ 是玻尔兹曼常数，$T$ 是温度。从任何位点逃逸的总速率为 $R=4\\,k_{\\text{diff}}$。在连续时间 KMC 中，连续两次跳跃之间的等待时间 $\\Delta t$ 从参数为 $R$ 的指数分布中采样，跳跃方向在四个邻居中均匀选择。\n\n从基础的统计力学和随机过程原理出发，即用于阿伦尼乌斯速率的过渡态理论和连续时间随机行走与扩散的映射关系，实现一个 KMC 模拟，该模拟能够：\n- 通过对等待时间和跳跃方向的采样，演化粒子在晶格上的位置 $(x(t),y(t))$。\n- 计算均方位移 $\\langle r^2(t)\\rangle$ 的时间序列，其中 $r^2(t)=x(t)^2+y(t)^2$。\n- 通过拟合二维情况下 $\\langle r^2(t)\\rangle$ 与 $t$ 之间的大时间线性关系 $\\langle r^2(t)\\rangle = 4 D t$ 来提取扩散系数 $D$。\n\n为确保普遍适用性，请遵守以下定义和要求：\n- 使用以电子伏特每开尔文为单位的玻尔兹曼常数，$k_B = 8.617333262145\\times 10^{-5}\\ \\text{eV/K}$。\n- 将 $k_{\\text{diff}}$ 视为每个方向的速率，因此总速率为 $R=4\\,k_{\\text{diff}}$。\n- 每次跳跃使位置沿坐标轴之一精确改变一个晶格间距 $a$，即 $(\\pm a,0)$ 或 $(0,\\pm a)$，概率相等。\n- KMC 时钟按参数为 $R$ 的指数分布等待时间推进。\n- 通过对 $\\langle r^2(t)\\rangle$ 与 $t$ 进行约束通过原点的最小二乘拟合来计算 $D$ 的估计值。\n\n物理和数值单位：\n- 所有输入参数必须按以下单位解释：$T$ 单位为开尔文，$\\nu$ 单位为 $\\text{s}^{-1}$，$E_a$ 单位为电子伏特，$a$ 单位为纳米。\n- 最终的扩散系数需以国际单位制（SI）表示，即 $\\text{m}^2/\\text{s}$，四舍五入并以六位有效数字的科学记数法报告。\n\n测试套件和覆盖范围：\n实现您的程序，为以下每组参数计算 KMC 提取的扩散系数。对于每种情况，精确运行 $N_{\\text{events}}=120{,}000$ 次 KMC 跳跃以累积统计数据。使用固定的随机种子以使结果可复现。\n- 情况 1：$T=300$，$\\nu=1.0\\times 10^{13}$，$E_a=0.50$，$a=0.30$。\n- 情况 2：$T=300$，$\\nu=1.0\\times 10^{13}$，$E_a=0.05$，$a=0.30$。\n- 情况 3：$T=300$，$\\nu=1.0\\times 10^{13}$，$E_a=0.90$，$a=0.30$。\n- 情况 4：$T=350$，$\\nu=5.0\\times 10^{12}$，$E_a=0.50$，$a=0.25$。\n- 情况 5：$T=300$，$\\nu=1.0\\times 10^{13}$，$E_a=0.00$，$a=0.30$。\n\n所有五种情况共享相同的 KMC 事件数 $N_{\\text{events}}=120{,}000$。对于每种情况，通过对 $\\langle r^2(t)\\rangle$ 与 $t$ 进行约束通过原点的线性拟合来推断 $D$。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，格式如下：\n- 一个包含五个浮点数的列表，按顺序对应情况 1 到 5 的 KMC 提取的扩散系数。\n- 每个数字必须格式化为具有六位有效数字的科学记数法（例如，$1.234560\\text{e-07}$）。\n例如，输出格式必须完全像 [$d_1$,$d_2$,$d_3$,$d_4$,$d_5$]，其中每个 $d_i$ 是以指定格式书写的 $\\text{m}^2/\\text{s}$ 单位的数字。",
            "solution": "问题陈述已经过分析，并被确定为有效。它在科学上基于统计力学和随机过程的原理，采用标准的动力学蒙特卡洛（KMC）模型来模拟表面扩散。该问题定义明确，提供了所有必要的参数、初始条件（隐含在原点）以及清晰的数据分析流程。语言客观，参数符合物理实际。因此，将提供一个解决方案。\n\n### 理论框架\n\n该问题要求我们模拟吸附物在二维方格晶格上的扩散，并提取扩散系数 $D$。这个过程的基础在于微观随机行走与宏观扩散之间的对应关系。\n\n扩散过程被建模为连续时间随机行走（CTRW）。在任何给定的晶格位点，吸附物可以跳跃到四个最近邻位点之一。特定方向的跳跃速率由过渡态理论的阿伦尼乌斯表达式给出：\n$$\nk_{\\text{diff}} = \\nu \\exp\\left(-\\frac{E_a}{k_B T}\\right)\n$$\n其中 $\\nu$ 是尝试频率，$E_a$ 是扩散活化能，$k_B$ 是玻尔兹曼常数，$T$ 是绝对温度。由于存在四个等效、独立的逃逸路径，从任何位点逃逸的总速率是各个速率之和：\n$$\nR = 4 k_{\\text{diff}}\n$$\n在晶格间距为 $a$ 的方格晶格上的随机行走中，每次跳跃使粒子的位置矢量 $\\vec{r}$ 改变一个位移矢量 $\\Delta\\vec{r}$，其中 $\\Delta\\vec{r}$ 是 $(\\pm a, 0)$ 或 $(0, \\pm a)$ 之一。经过 $N$ 次跳跃后，总位移为 $\\vec{r}_N = \\sum_{i=1}^{N} \\Delta\\vec{r}_i$。均方位移（MSD）由下式给出：\n$$\n\\langle r^2(N) \\rangle = \\langle \\vec{r}_N \\cdot \\vec{r}_N \\rangle = \\left\\langle \\left( \\sum_{i=1}^{N} \\Delta\\vec{r}_i \\right) \\cdot \\left( \\sum_{j=1}^{N} \\Delta\\vec{r}_j \\right) \\right\\rangle\n$$\n由于每次跳跃的方向是独立选择的，交叉项的平均值为零（对于 $i \\neq j$，$\\langle \\Delta\\vec{r}_i \\cdot \\Delta\\vec{r}_j \\rangle = 0$）。这简化了表达式为：\n$$\n\\langle r^2(N) \\rangle = \\sum_{i=1}^{N} \\langle |\\Delta\\vec{r}_i|^2 \\rangle = \\sum_{i=1}^{N} a^2 = N a^2\n$$\nKMC 方法模拟系统的时间演化。连续跳跃之间的等待时间 $\\Delta t$ 是一个随机变量，从总速率为 $R$ 的指数分布中抽取，即 $P(\\Delta t) = R \\exp(-R\\Delta t)$。单次跳跃的平均等待时间为 $\\langle \\Delta t \\rangle = 1/R$。$N$ 次跳跃后的总流逝时间为 $t_N = \\sum_{i=1}^N \\Delta t_i$，其期望值为 $\\langle t_N \\rangle = N \\langle \\Delta t \\rangle = N/R$。\n\n通过将 $N = R t$ 代入 MSD 方程，我们得到 MSD 与时间之间的关系：\n$$\n\\langle r^2(t) \\rangle = (R a^2) t\n$$\n二维扩散的爱因斯坦关系将 MSD 与扩散系数 $D$ 联系起来：\n$$\n\\langle r^2(t) \\rangle = 4 D t\n$$\n比较这两个 MSD 的表达式，我们推导出该模型的理论扩散系数：\n$$\n4 D t = (R a^2) t \\implies D = \\frac{1}{4} R a^2\n$$\n代入 $R = 4 k_{\\text{diff}}$，我们得到最终的理论表达式：\n$$\nD = \\frac{1}{4} (4 k_{\\text{diff}}) a^2 = k_{\\text{diff}} a^2 = a^2 \\nu \\exp\\left(-\\frac{E_a}{k_B T}\\right)\n$$\nKMC 模拟将数值生成一条轨迹 $(x(t), y(t))$，从中我们可以计算平方位移 $r^2(t) = x(t)^2 + y(t)^2$ 的时间序列。然后，该数值数据将用于估计 $D$。\n\n### 动力学蒙特卡洛（KMC）算法\n\n对于每组参数，执行以下 KMC 算法：\n1.  **初始化**:\n    -   将粒子的初始位置设置在晶格原点，$(x, y) = (0, 0)$。\n    -   将初始模拟时间设置为 $t = 0$。\n    -   初始化数据结构，以存储 $N_{\\text{events}}$ 个步骤中每个步骤的模拟时间 $t_i$ 和相应的平方位移 $r^2_i$ 的历史记录。\n    -   为伪随机数生成器设置一个固定的种子，以确保结果的可复现性。\n\n2.  **速率计算**:\n    -   使用提供的参数 $T$、$\\nu$、$E_a$ 和常数 $k_B$ 计算每个方向的跳跃速率 $k_{\\text{diff}}$。\n    -   计算总速率 $R = 4 k_{\\text{diff}}$。\n\n3.  **模拟循环**:\n    -   共迭代 $N_{\\text{events}}$ 步。在每一步 $i$ 中：\n        a. **推进时间**: 从速率参数为 $R$ 的指数分布中采样一个等待时间 $\\Delta t$。一种常用方法是使用逆变换采样：$\\Delta t = -\\ln(u)/R$，其中 $u$ 是一个在 $(0, 1]$ 区间内均匀分布的随机数。模拟时钟按此量推进：$t \\leftarrow t + \\Delta t$。\n        b. **选择事件**: 选择一个跳跃方向。由于所有四个最近邻跳跃的概率相等（每个速率为 $k_{\\text{diff}}$），我们以 $1/4$ 的均匀概率选择四个方向之一（例如，+x, -x, +y, -y）。\n        c. **更新状态**: 通过加上与所选方向对应的位移矢量 $(\\pm a, 0)$ 或 $(0, \\pm a)$ 来更新粒子的坐标 $(x, y)$。\n        d. **记录数据**: 存储新的时间 $t$ 和新的平方位移 $r^2 = x^2 + y^2$。\n\n### 数据分析与参数提取\n\n模拟完成后，我们得到一个平方位移的时间序列 $\\{ (t_i, r^2_i) \\}_{i=1}^{N_{\\text{events}}}$。为了提取扩散系数，我们将此数据拟合到线性模型 $\\langle r^2(t) \\rangle = m t$，该模型被约束通过原点 $(0, 0)$。这条线的斜率是 $m = 4D$。\n\n对于约束通过原点的拟合，使误差平方和 $\\sum_i (r^2_i - m t_i)^2$ 最小化的斜率 $m$ 由解析解给出：\n$$\nm = \\frac{\\sum_{i=1}^{N_{\\text{events}}} t_i r^2_i}{\\sum_{i=1}^{N_{\\text{events}}} t_i^2}\n$$\n此计算使用记录的时间和位移平方数据进行。一旦确定了斜率 $m$，扩散系数 $D$ 的计算方法如下：\n$$\nD = \\frac{m}{4}\n$$\n参数 $a$ 和时间的单位分别为纳米和秒。这意味着计算出的 $D$ 的单位将是 $\\text{nm}^2/\\text{s}$。然后必须使用转换因子 $1 \\text{ nm}^2 = 10^{-18} \\text{ m}^2$ 将此值转换为所需的 SI 单位 $\\text{m}^2/\\text{s}$。最终结果随后被格式化为指定的精度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs Kinetic Monte Carlo simulations of surface diffusion for five test cases\n    and extracts the diffusion coefficient for each.\n    \"\"\"\n    # Define physical constant\n    KB_EV_K = 8.617333262145e-5  # Boltzmann constant in eV/K\n\n    # Define simulation parameters\n    N_EVENTS = 120000\n    RANDOM_SEED = 42\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (T, nu, Ea, a)\n    # Units: T in K, nu in 1/s, Ea in eV, a in nm\n    test_cases = [\n        (300.0, 1.0e13, 0.50, 0.30),  # Case 1\n        (300.0, 1.0e13, 0.05, 0.30),  # Case 2\n        (300.0, 1.0e13, 0.90, 0.30),  # Case 3\n        (350.0, 5.0e12, 0.50, 0.25),  # Case 4\n        (300.0, 1.0e13, 0.00, 0.30),  # Case 5\n    ]\n\n    results = []\n\n    # Set the random seed for reproducibility\n    np.random.seed(RANDOM_SEED)\n\n    for case in test_cases:\n        T, nu, Ea, a = case\n\n        # --- 1. Calculate Rates ---\n        # Arrhenius rate for a single direction\n        k_diff = nu * np.exp(-Ea / (KB_EV_K * T))\n        # Total escape rate from a site\n        R = 4.0 * k_diff\n\n        # --- 2. KMC Simulation ---\n        # Initialize simulation state in lattice units\n        ix, iy = 0, 0  # Integer lattice coordinates\n        time = 0.0\n\n        # Arrays to store the history of time and squared displacement\n        # +1 to include the initial state (t=0, r^2=0)\n        t_history = np.zeros(N_EVENTS + 1, dtype=float)\n        r2_history = np.zeros(N_EVENTS + 1, dtype=float)\n\n        # Define possible hops in lattice units\n        # (0: +x, 1: -x, 2: +y, 3: -y)\n        hops = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n        for i in range(1, N_EVENTS + 1):\n            # Advance time: sample from exponential distribution with rate R\n            # scale parameter is 1/lambda, which is 1/R\n            dt = np.random.exponential(scale=1.0/R)\n            time += dt\n\n            # Choose a hop direction uniformly from the 4 options\n            direction = np.random.randint(0, 4)\n            dix, diy = hops[direction]\n\n            # Update particle position in lattice units\n            ix += dix\n            iy += diy\n\n            # Store history\n            t_history[i] = time\n            # Convert lattice displacement squared to real units (nm^2)\n            r2_history[i] = (ix**2 + iy**2) * (a**2)\n\n        # --- 3. Extract Diffusion Coefficient ---\n        # The model is r^2 = m*t, where m = 4*D\n        # For a fit through the origin, m = sum(t_i * r2_i) / sum(t_i^2)\n        \n        # Using np.dot for efficient summation of products\n        # We include the full history, as t_history[0]=0 and r2_history[0]=0,\n        # which correctly contributes zero to the sums.\n        numerator = np.dot(t_history, r2_history)\n        denominator = np.dot(t_history, t_history)\n        \n        if denominator == 0:\n            # This case should not happen with N_EVENTS  0\n            # If it did, it would mean all dt were 0, which is impossible.\n            D_nm2_s = 0.0\n        else:\n            m = numerator / denominator\n            # D = m/4\n            D_nm2_s = m / 4.0\n\n        # --- 4. Unit Conversion ---\n        # Convert D from nm^2/s to m^2/s\n        # 1 nm = 1e-9 m - 1 nm^2 = 1e-18 m^2\n        D_m2_s = D_nm2_s * 1e-18\n\n        results.append(D_m2_s)\n\n    # Final print statement in the exact required format.\n    # The format \"{:.6e}\" produces a coefficient with 1 digit before the decimal\n    # and 6 digits after, matching the example's precision (7 sig figs total).\n    formatted_results = [f\"{res:.6e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后，我们将挑战一个更全面的模拟，它更接近于真实的计算电化学研究。在这个练习中，你将为一个包含大量独立活性位点的电极表面建模，其中涉及吸附、脱附和电荷转移等多种相互竞争的反应。通过实现这个多过程KMC模拟并计算法拉第电流，你不仅能应用前面学到的技能，还能通过将时间平均结果与系综平均理论值进行比较，来验证遍历性假设的有效性。",
            "id": "4249495",
            "problem": "实现一个连续时间动力学蒙特卡洛程序，以证明一个稳态、遍历的表面过程的时间平均法拉第电流收敛于其系综平均值。考虑一个由$N$个相同、独立的无相互作用表面位点组成的晶格。每个位点都是一个连续时间马尔可夫链，具有三个表面状态，由$s \\in \\{0,1,2\\}$索引，分别代表$0$：空位，$1$：吸附的氧化物种$\\mathrm{Ox}_{\\mathrm{ads}}$，以及$2$：吸附的还原物种$\\mathrm{Red}_{\\mathrm{ads}}$。每个位点允许的跃迁及其速率定义如下：\n- 与溶液库的吸附和解吸：\n  - $0 \\to 1$，速率为 $k_{01} = k^{\\mathrm{Ox}}_{\\mathrm{ads}}\\, c_{\\mathrm{Ox}}$，\n  - $1 \\to 0$，速率为 $k_{10} = k^{\\mathrm{Ox}}_{\\mathrm{des}}$，\n  - $0 \\to 2$，速率为 $k_{02} = k^{\\mathrm{Red}}_{\\mathrm{ads}}\\, c_{\\mathrm{Red}}$，\n  - $2 \\to 0$，速率为 $k_{20} = k^{\\mathrm{Red}}_{\\mathrm{des}}$。\n- 表面上的电子转移（类Butler–Volmer）相互转化：\n  - $1 \\to 2$（还原），速率为 $k_{12} = k_0 \\exp\\!\\left(\\alpha \\beta F \\Delta E \\right)$，\n  - $2 \\to 1$（氧化），速率为 $k_{21} = k_0 \\exp\\!\\left(-(1-\\alpha)\\, \\beta F \\Delta E \\right)$，\n其中 $\\Delta E = E - E^0$，$\\beta = 1/(R T)$，$F$是法拉第常数，$R$是气体常数，$T$是绝对温度，$\\alpha$是转移系数，$k_0$是电子转移指前因子，$k^{\\mathrm{Ox}}_{\\mathrm{ads}}$和$k^{\\mathrm{Red}}_{\\mathrm{ads}}$是吸附系数，$k^{\\mathrm{Ox}}_{\\mathrm{des}}$和$k^{\\mathrm{Red}}_{\\mathrm{des}}$是解吸系数，$c_{\\mathrm{Ox}}$和$c_{\\mathrm{Red}}$是本体浓度。所有速率的单位为$\\mathrm{s}^{-1}$，浓度的单位为$\\mathrm{mol}\\,\\mathrm{L}^{-1}$，电势的单位为$\\mathrm{V}$。处理为每个$1 \\leftrightarrow 2$事件转移$n=1$个电子。设基本电荷为$q$，单位为$\\mathrm{C}$。\n\n使用的基本原理：\n- 一个具有生成元矩阵$Q$的连续时间马尔可夫链是稳态的，如果稳态分布$\\boldsymbol{\\pi}$满足$\\boldsymbol{\\pi} Q = \\boldsymbol{0}$且$\\sum_i \\pi_i = 1$。\n- 对于一个稳态、遍历的马尔可夫过程和一个可积的可观测量$A(t)$，Birkhoff遍历定理保证长时间平均$\\lim_{T \\to \\infty} \\frac{1}{T}\\int_0^T A(t)\\, \\mathrm{d}t$几乎必然存在且等于系综平均$\\mathbb{E}_{\\boldsymbol{\\pi}}[A]$。\n- 系综平均法拉第电流是沿电子转移边的预期净电子通量乘以$q$和位点数$N$。在长度为$T$的有限时间窗口内的带符号时间平均电流是$1 \\leftrightarrow 2$事件的净计数乘以$q$，再除以$T$。\n\n要实现的任务：\n- 根据上述速率为一个位点构建$3 \\times 3$的生成元矩阵$Q$，并通过求解$\\boldsymbol{\\pi} Q = \\boldsymbol{0}$及归一化条件$\\sum_i \\pi_i = 1$来计算稳态分布$\\boldsymbol{\\pi}$。\n- 从第一性原理出发，将系综平均法拉第电流表示为稳态下预期的带符号电子转移速率乘以$q$和$N$。最终电流以$\\mathrm{A}$为单位表示。\n- 设计一个在位点计数状态$(n_0,n_1,n_2)$（其中$n_0+n_1+n_2=N$）上使用精确随机模拟算法（Gillespie直接法）的动力学蒙特卡洛模拟，其倾向是单位点速率乘以当前位点计数。通过从具有概率$\\boldsymbol{\\pi}$的多项分布中抽样来初始化$(n_0,n_1,n_2)$，以在稳态下开始。对每个测试案例模拟到所请求的最大观测时间，并记录净电子数$N_e(t)$作为$1 \\leftrightarrow 2$事件的带符号计数（对$1 \\to 2$还原赋+1，对$2 \\to 1$氧化赋-1）。\n- 对于每个请求的观测时间$T$，计算有限时间的时间平均电流$I_T = q\\, N_e(T)/T$（单位为$\\mathrm{A}$）和有限时间偏差$B_T = I_T - I_{\\mathrm{ens}}$（单位为$\\mathrm{A}$），其中$I_{\\mathrm{ens}}$是系综平均电流。使用固定的随机种子以使结果可复现。\n\n使用的物理常数：\n- $F = 96485\\,\\mathrm{C}\\,\\mathrm{mol}^{-1}$，\n- $R = 8.314\\,\\mathrm{J}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$，\n- $T = 298.15\\,\\mathrm{K}$，\n- $q = 1.602176634\\times 10^{-19}\\,\\mathrm{C}$。\n\n使用以下参数集测试套件：\n- 案例 A（平衡，接近细致平衡）：\n  - $N = 200$，\n  - $E = 0.20\\,\\mathrm{V}$，$E^0 = 0.20\\,\\mathrm{V}$，因此$\\Delta E = 0.00\\,\\mathrm{V}$，\n  - $\\alpha = 0.50$，$k_0 = 50.0\\,\\mathrm{s}^{-1}$，\n  - $k^{\\mathrm{Ox}}_{\\mathrm{ads}} = 20.0\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$，$k^{\\mathrm{Ox}}_{\\mathrm{des}} = 2.0\\,\\mathrm{s}^{-1}$，\n  - $k^{\\mathrm{Red}}_{\\mathrm{ads}} = 20.0\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$，$k^{\\mathrm{Red}}_{\\mathrm{des}} = 2.0\\,\\mathrm{s}^{-1}$，\n  - $c_{\\mathrm{Ox}} = 0.010\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$，$c_{\\mathrm{Red}} = 0.010\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$，\n  - 观测时间 $T \\in \\{0.010\\,\\mathrm{s}, 0.100\\,\\mathrm{s}, 1.000\\,\\mathrm{s}\\}$。\n- 案例 B（驱动还原）：\n  - $N = 200$，\n  - $E = 0.22\\,\\mathrm{V}$，$E^0 = 0.20\\,\\mathrm{V}$，因此$\\Delta E = 0.02\\,\\mathrm{V}$，\n  - $\\alpha = 0.50$，$k_0 = 50.0\\,\\mathrm{s}^{-1}$，\n  - $k^{\\mathrm{Ox}}_{\\mathrm{ads}} = 20.0\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$，$k^{\\mathrm{Ox}}_{\\mathrm{des}} = 2.0\\,\\mathrm{s}^{-1}$，\n  - $k^{\\mathrm{Red}}_{\\mathrm{ads}} = 20.0\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$，$k^{\\mathrm{Red}}_{\\mathrm{des}} = 2.0\\,\\mathrm{s}^{-1}$，\n  - $c_{\\mathrm{Ox}} = 0.015\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$，$c_{\\mathrm{Red}} = 0.005\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$，\n  - 观测时间 $T \\in \\{0.010\\,\\mathrm{s}, 0.100\\,\\mathrm{s}, 1.000\\,\\mathrm{s}\\}$。\n- 案例 C（驱动氧化，位点数较少以突显有限时间偏差）：\n  - $N = 50$，\n  - $E = 0.18\\,\\mathrm{V}$，$E^0 = 0.20\\,\\mathrm{V}$，因此$\\Delta E = -0.02\\,\\mathrm{V}$，\n  - $\\alpha = 0.50$，$k_0 = 50.0\\,\\mathrm{s}^{-1}$，\n  - $k^{\\mathrm{Ox}}_{\\mathrm{ads}} = 20.0\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$，$k^{\\mathrm{Ox}}_{\\mathrm{des}} = 2.0\\,\\mathrm{s}^{-1}$，\n  - $k^{\\mathrm{Red}}_{\\mathrm{ads}} = 20.0\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$，$k^{\\mathrm{Red}}_{\\mathrm{des}} = 2.0\\,\\mathrm{s}^{-1}$，\n  - $c_{\\mathrm{Ox}} = 0.005\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$，$c_{\\mathrm{Red}} = 0.015\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$，\n  - 观测时间 $T \\in \\{0.010\\,\\mathrm{s}, 0.050\\,\\mathrm{s}, 0.200\\,\\mathrm{s}\\}$。\n\n您的程序必须：\n- 根据稳态分布和净电子转移通量定义，为每个案例计算系综平均电流$I_{\\mathrm{ens}}$（单位为$\\mathrm{A}$）。\n- 对每个案例运行一个从稳态分布开始的动力学蒙特卡洛模拟，使用固定的伪随机种子，并为该案例中每个指定的$T$计算有限时间的时间平均电流$I_T$和偏差$B_T = I_T - I_{\\mathrm{ens}}$。所有电流和偏差必须以$\\mathrm{A}$为单位。\n- 生成一行输出，其中包含所有案例和时间点的偏差序列，按案例A时间升序、然后案例B时间升序、最后案例C时间升序的顺序，以逗号分隔的列表形式，并用方括号括起来，例如$[\\dots]$。\n\n重要提示：不使用角度。将所有电流和偏差以浮点数形式表示，单位为$\\mathrm{A}$。最终输出必须是包含指定列表的单行文本。",
            "solution": "该问题是有效的。这是一个在计算电化学领域中适定、有科学依据的问题，要求实现一个连续时间动力学蒙特卡洛（kMC）模拟，并将其与解析系综平均进行比较，从而证明一个稳态随机过程的遍历性假说。所有必要的参数和常数都已提供，并且模型在物理上和数学上都是一致的。\n\n解决方案分两部分展开：首先，法拉第电流的系综平均值的解析计算；其次，设计一个动力学蒙特卡洛模拟来计算时间平均电流。\n\n**1. 系综平均法拉第电流**\n\n系统由$N$个独立且相同的表面位点组成，每个位点的行为如同一个具有三种状态的连续时间马尔可夫链：$0$（空位）、$1$（$\\mathrm{Ox}_{\\mathrm{ads}}$）和$2$（$\\mathrm{Red}_{\\mathrm{ads}}$）。单个位点的动力学由一个$3 \\times 3$的生成元矩阵$Q$控制，其中当$i \\neq j$时，$Q_{ij}$是从状态$i$到状态$j$的跃迁速率，且$Q_{ii} = -\\sum_{j \\neq i} Q_{ij}$。速率由以下公式给出：\n$k_{01} = k^{\\mathrm{Ox}}_{\\mathrm{ads}}\\, c_{\\mathrm{Ox}}$\n$k_{10} = k^{\\mathrm{Ox}}_{\\mathrm{des}}$\n$k_{02} = k^{\\mathrm{Red}}_{\\mathrm{ads}}\\, c_{\\mathrm{Red}}$\n$k_{20} = k^{\\mathrm{Red}}_{\\mathrm{des}}$\n$k_{12} = k_0 \\exp(\\alpha \\beta F \\Delta E)$\n$k_{21} = k_0 \\exp(-(1-\\alpha) \\beta F \\Delta E)$\n\n因此，生成元矩阵$Q$为：\n$$\nQ = \\begin{pmatrix}\n-(k_{01} + k_{02})  k_{01}  k_{02} \\\\\nk_{10}  -(k_{10} + k_{12})  k_{12} \\\\\nk_{20}  k_{21}  -(k_{20} + k_{21})\n\\end{pmatrix}\n$$\n该过程是遍历的，因此存在一个唯一的稳态分布向量$\\boldsymbol{\\pi} = (\\pi_0, \\pi_1, \\pi_2)$，它分别代表一个位点处于状态$0$、$1$或$2$的长期概率。该分布是稳态下主方程$\\boldsymbol{\\pi} Q = \\boldsymbol{0}$的解，并满足归一化条件$\\sum_i \\pi_i = 1$。这个线性方程组可以通过找到$Q^T$对应于特征值$0$的特征向量，然后将所得向量归一化使其总和为$1$来数值求解。\n\n法拉第电流由$1 \\leftrightarrow 2$跃迁中的净电子流产生。对于单个位点，还原事件（$1 \\to 2$）相对于氧化事件（$2 \\to 1$）的净速率为$(k_{12} - k_{21})$。在稳态系综中，预期的净还原速率由通量平衡给出，同时考虑了处于前提状态的概率：$k_{12}\\pi_1 - k_{21}\\pi_2$。由于每个净还原事件对应于转移单个基本电荷$q$（因为$n=1$），因此整个$N$位点系统的系综平均法拉第电流$I_{\\mathrm{ens}}$为：\n$$\nI_{\\mathrm{ens}} = N \\cdot q \\cdot (k_{12}\\pi_1 - k_{21}\\pi_2)\n$$\n按照惯例，净还原电流为正。\n\n**2. 通过动力学蒙特卡洛模拟计算时间平均法拉第电流**\n\n动力学蒙特卡洛（kMC）模拟对整个$N$位点系统的随机演化进行建模。系统的状态由每种位点类型的布居数$(n_0, n_1, n_2)$描述，其中$n_0+n_1+n_2 = N$。存在六种可能的事件类型（或反应通道），对应于六个基本跃迁。由于位点之间无相互作用，每种事件类型的总速率（倾向）是单位点速率乘以可进行该跃迁的位点数：\n\\begin{itemize}\n    \\item $0 \\to 1$: $a_1 = k_{01}n_0$\n    \\item $1 \\to 0$: $a_2 = k_{10}n_1$\n    \\item $0 \\to 2$: $a_3 = k_{02}n_0$\n    \\item $2 \\to 0$: $a_4 = k_{20}n_2$\n    \\item $1 \\to 2$ (还原): $a_5 = k_{12}n_1$\n    \\item $2 \\to 1$ (氧化): $a_6 = k_{21}n_2$\n\\end{itemize}\n模拟使用精确随机模拟算法（Gillespie直接法）实现：\n\n1.  **初始化**：在时间$t=0$时，系统被置于与稳态分布一致的状态。位点布居数$(n_0, n_1, n_2)$通过从具有$N$次试验和概率$\\boldsymbol{\\pi} = (\\pi_0, \\pi_1, \\pi_2)$的多项分布中抽取一个样本来初始化。净电子计数初始化为$N_e(0) = 0$。\n\n2.  **迭代**：模拟以离散的随机步骤进行。在每一步：\n    a. 根据当前状态$(n_0, n_1, n_2)$计算六个倾向$a_j$。\n    b. 计算总倾向，$A = \\sum_{j=1}^6 a_j$。\n    c. 从均匀分布$U(0,1)$中抽取两个独立的随机数$r_1, r_2$。\n    d. 将模拟时间推进一个随机增量$\\Delta t = -\\frac{1}{A} \\ln(r_1)$。\n    e. 选择发生的事件。选择事件$j$，使得$\\sum_{i=1}^{j-1} a_i  r_2 A \\le \\sum_{i=1}^j a_i$。\n    f. 更新系统状态。对于所选事件$j$，更新布居数$(n_0, n_1, n_2)$。如果事件是还原（$1 \\to 2$），则净电子计数增加：$N_e \\leftarrow N_e + 1$。如果是氧化（$2 \\to 1$），则减少：$N_e \\leftarrow N_e - 1$。\n\n3.  **数据记录**：模拟运行至每个测试案例的最大观测时间$T_{\\max}$。当模拟时间$t$越过每个指定的观测时间$T$时，计算瞬时时间平均电流。净电子数$N_e(t)$是时间的分段常数函数。其在观测时间$T$时的值，表示为$N_e(T)$，是到该点为止转移的电子总净数。时间平均电流为：\n    $$\n    I_T = \\frac{q \\cdot N_e(T)}{T}\n    $$\n    Birkhoff遍历定理指出，对于一个稳态遍历过程，$\\lim_{T \\to \\infty} I_T = I_{\\mathrm{ens}}$。有限时间偏差$B_T = I_T - I_{\\mathrm{ens}}$量化了在有限观测窗口和单个随机轨迹下，时间平均值与系综平均值的偏差。预期该偏差会随着$T$的增加而减小。使用固定的随机种子来确保随机轨迹和所得偏差的可复现性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import null_space\n\ndef solve():\n    \"\"\"\n    Implements a kMC simulation for an electrochemical surface process and\n    calculates the bias between the time-averaged and ensemble-averaged\n    faradaic current.\n    \"\"\"\n    # Use a fixed random seed for reproducibility.\n    np.random.seed(42)\n\n    # Physical constants\n    F = 96485.0  # C/mol\n    R = 8.314  # J/(mol*K)\n    T_K = 298.15  # K\n    q = 1.602176634e-19  # C\n\n    # Test suite of parameter sets\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"N\": 200, \"E\": 0.20, \"E0\": 0.20, \"alpha\": 0.50, \"k0\": 50.0,\n            \"k_ox_ads\": 20.0, \"k_ox_des\": 2.0,\n            \"k_red_ads\": 20.0, \"k_red_des\": 2.0,\n            \"c_ox\": 0.010, \"c_red\": 0.010,\n            \"times\": [0.010, 0.100, 1.000]\n        },\n        {\n            \"name\": \"Case B\",\n            \"N\": 200, \"E\": 0.22, \"E0\": 0.20, \"alpha\": 0.50, \"k0\": 50.0,\n            \"k_ox_ads\": 20.0, \"k_ox_des\": 2.0,\n            \"k_red_ads\": 20.0, \"k_red_des\": 2.0,\n            \"c_ox\": 0.015, \"c_red\": 0.005,\n            \"times\": [0.010, 0.100, 1.000]\n        },\n        {\n            \"name\": \"Case C\",\n            \"N\": 50, \"E\": 0.18, \"E0\": 0.20, \"alpha\": 0.50, \"k0\": 50.0,\n            \"k_ox_ads\": 20.0, \"k_ox_des\": 2.0,\n            \"k_red_ads\": 20.0, \"k_red_des\": 2.0,\n            \"c_ox\": 0.005, \"c_red\": 0.015,\n            \"times\": [0.010, 0.050, 0.200]\n        }\n    ]\n\n    all_biases = []\n    \n    # Pre-calculate beta * F\n    beta_F = F / (R * T_K)\n\n    for case in test_cases:\n        N = case[\"N\"]\n        delta_E = case[\"E\"] - case[\"E0\"]\n        \n        # 1. Calculate per-site transition rates\n        k01 = case[\"k_ox_ads\"] * case[\"c_ox\"]\n        k10 = case[\"k_ox_des\"]\n        k02 = case[\"k_red_ads\"] * case[\"c_red\"]\n        k20 = case[\"k_red_des\"]\n        k12 = case[\"k0\"] * np.exp(case[\"alpha\"] * beta_F * delta_E)\n        k21 = case[\"k0\"] * np.exp(-(1.0 - case[\"alpha\"]) * beta_F * delta_E)\n        \n        # 2. Compute stationary distribution pi\n        Q = np.array([\n            [-(k01 + k02), k01, k02],\n            [k10, -(k10 + k12), k12],\n            [k20, k21, -(k20 + k21)]\n        ])\n        \n        # Find the null space of Q.T, which corresponds to the stationary distribution\n        pi_unnormalized = null_space(Q.T).flatten()\n        # Ensure positivity and normalize\n        pi = np.abs(pi_unnormalized) / np.sum(np.abs(pi_unnormalized))\n\n        # 3. Calculate ensemble-averaged current\n        I_ens = N * q * (k12 * pi[1] - k21 * pi[2])\n\n        # 4. Run kMC simulation\n        # Initialize state from multinomial distribution\n        n_counts = np.random.multinomial(N, pi)\n        \n        t = 0.0\n        Ne = 0 # Net electron count (+1 for reduction, -1 for oxidation)\n        \n        obs_times = sorted(case[\"times\"])\n        max_T = obs_times[-1]\n        case_biases = [0.0] * len(obs_times)\n        obs_idx = 0\n        \n        # State update vector (n0, n1, n2) changes for each reaction\n        updates = np.array([\n            [-1, 1, 0], [1, -1, 0], [-1, 0, 1],\n            [1, 0, -1], [0, -1, 1], [0, 1, -1]\n        ])\n        # Ne change for each reaction\n        Ne_updates = np.array([0, 0, 0, 0, 1, -1])\n\n        while t  max_T:\n            # Calculate propensities\n            propensities = np.array([\n                k01 * n_counts[0],\n                k10 * n_counts[1],\n                k02 * n_counts[0],\n                k20 * n_counts[2],\n                k12 * n_counts[1],\n                k21 * n_counts[2]\n            ])\n            A_total = np.sum(propensities)\n            \n            if A_total == 0:\n                break\n                \n            # Draw random numbers for time step and reaction choice\n            r1, r2 = np.random.rand(2)\n            dt = -np.log(r1) / A_total\n            t_next = t + dt\n\n            # Record data if an observation time is crossed\n            while obs_idx  len(obs_times) and t_next = obs_times[obs_idx]:\n                T_obs = obs_times[obs_idx]\n                I_T = q * Ne / T_obs\n                bias = I_T - I_ens\n                case_biases[obs_idx] = bias\n                obs_idx += 1\n\n            if obs_idx == len(obs_times):\n                break\n\n            # Choose and execute the reaction\n            reaction_idx = np.searchsorted(np.cumsum(propensities), r2 * A_total)\n            \n            # Update state\n            n_counts += updates[reaction_idx]\n            Ne += Ne_updates[reaction_idx]\n            t = t_next\n            \n        all_biases.extend(case_biases)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_biases))}]\")\n\nsolve()\n```"
        }
    ]
}