{
    "hands_on_practices": [
        {
            "introduction": "任何动力学蒙特卡洛（KMC）模拟的核心都在于其算法基础。本练习将深入探讨 KMC 方法的两个基本组成部分：如何推进模拟时间以及如何根据竞争速率选择下一个发生的事件。通过从第一性原理推导这些要素，您将加深对 KMC 如何将系统演化精确地建模为一系列竞争性泊松过程的理解 。",
            "id": "4249483",
            "problem": "在一个模拟电化学表面过程的无拒绝动力学蒙特卡洛 (KMC) 仿真中，单个表面位点可以经历三个相互排斥的独立事件：阳离子吸附、表面扩散和电子转移驱动的解吸。将该动力学过程建模为一个连续时间马尔可夫链 (CTMC)，其中每个事件表示为一个具有恒定风险率（速率）的独立泊松过程。这些事件的速率分别为 $r_1=10\\,\\text{s}^{-1}$（吸附）、$r_2=1\\,\\text{s}^{-1}$（扩散）和 $r_3=0.1\\,\\text{s}^{-1}$（电子转移解吸）。仅利用独立泊松过程的基本性质和指数分布的无记忆性，从第一性原理推导出连续 KMC 事件之间的平均等待时间 $\\langle \\Delta t \\rangle$ 以及每个通道的事件选择概率。然后计算此状态下的这些值。\n\n使用精确的解析表达式，将最终答案以单行向量的形式给出，其中按顺序包含平均等待时间 $\\langle \\Delta t \\rangle$ 和三个选择概率 $r_i/R$，其中 $R=\\sum_{i=1}^{3} r_i$。以秒为单位表示平均等待时间，并将概率表示为无量纲分数。不要使用百分号。无需四舍五入。",
            "solution": "该问题要求我们从第一性原理推导KMC模拟中的两个核心量：平均等待时间 $\\langle \\Delta t \\rangle$ 和事件选择概率 $P_j$。基本假设是，每个事件都是一个独立的泊松过程。\n\n### 推导过程\n\n设事件 $i$ 的等待时间为随机变量 $T_i$。由于每个事件都是一个速率为 $r_i$ 的泊松过程，因此等待时间 $T_i$ 服从参数为 $r_i$ 的指数分布。其概率密度函数 (PDF) 为 $f_{T_i}(t) = r_i e^{-r_i t}$ (当 $t \\ge 0$)，累积分布函数 (CDF) 为 $F_{T_i}(t) = P(T_i \\le t) = 1 - e^{-r_i t}$。\n\nKMC 模拟中的下一个事件发生在时间 $\\Delta t$，该时间是所有可能事件等待时间的最小值：\n$$\n\\Delta t = \\min(T_1, T_2, T_3)\n$$\n等待时间 $\\Delta t$ 大于某个时间 $t$ 的概率，等同于所有独立事件的等待时间都大于 $t$ 的概率：\n$$\nP(\\Delta t > t) = P(T_1 > t \\text{ and } T_2 > t \\text{ and } T_3 > t)\n$$\n由于泊松过程的独立性，这变为：\n$$\nP(\\Delta t > t) = P(T_1 > t) \\cdot P(T_2 > t) \\cdot P(T_3 > t)\n$$\n利用 CDF，我们知道 $P(T_i > t) = 1 - F_{T_i}(t) = e^{-r_i t}$。因此：\n$$\nP(\\Delta t > t) = e^{-r_1 t} \\cdot e^{-r_2 t} \\cdot e^{-r_3 t} = e^{-(r_1+r_2+r_3)t}\n$$\n令总速率 $R = \\sum_{i=1}^3 r_i$。则 $P(\\Delta t > t) = e^{-Rt}$。$\\Delta t$ 的 CDF 是 $F_{\\Delta t}(t) = P(\\Delta t \\le t) = 1 - P(\\Delta t > t) = 1 - e^{-Rt}$。这表明 $\\Delta t$ 也服从指数分布，其速率参数为总速率 $R$。速率参数为 $R$ 的指数分布的平均值为 $1/R$。因此，平均等待时间为：\n$$\n\\langle \\Delta t \\rangle = \\frac{1}{R} = \\frac{1}{r_1 + r_2 + r_3}\n$$\n接下来，我们推导选择概率。特定事件（例如事件 $j$）发生的概率是其等待时间 $T_j$ 在所有等待时间中最小的概率。这个概率可以通过对 $T_j$ 的所有可能值进行积分来计算。事件 $j$ 在时间 $t$ 发生且是第一个事件的概率，是 $T_j=t$ 并且对于所有 $k \\neq j$ 都有 $T_k > t$ 的概率。\n$$\nP_j = \\int_0^{\\infty} f_{T_j}(t) \\left( \\prod_{k \\neq j} P(T_k > t) \\right) dt = \\int_0^{\\infty} (r_j e^{-r_j t}) \\left( \\prod_{k \\neq j} e^{-r_k t} \\right) dt\n$$\n$$\nP_j = \\int_0^{\\infty} r_j e^{-(\\sum_{i=1}^3 r_i)t} dt = r_j \\int_0^{\\infty} e^{-Rt} dt = r_j \\cdot \\frac{1}{R} = \\frac{r_j}{R}\n$$\n这证实了选择一个事件的概率是其速率占总速率的比例这一直观结果。\n\n### 数值计算\n\n代入给定数值：\n- $r_1=10\\,\\text{s}^{-1}$\n- $r_2=1\\,\\text{s}^{-1}$\n- $r_3=0.1\\,\\text{s}^{-1}$\n\n总速率 $R = 10 + 1 + 0.1 = 11.1\\,\\text{s}^{-1}$。\n\n**平均等待时间**:\n$$\n\\langle \\Delta t \\rangle = \\frac{1}{11.1} = \\frac{10}{111} \\, \\text{s}\n$$\n\n**选择概率**:\n$$\nP_1 = \\frac{r_1}{R} = \\frac{10}{11.1} = \\frac{100}{111}\n$$\n$$\nP_2 = \\frac{r_2}{R} = \\frac{1}{11.1} = \\frac{10}{111}\n$$\n$$\nP_3 = \\frac{r_3}{R} = \\frac{0.1}{11.1} = \\frac{1}{111}\n$$\n最终结果向量为 $(\\langle \\Delta t \\rangle, P_1, P_2, P_3)$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{10}{111} & \\frac{100}{111} & \\frac{10}{111} & \\frac{1}{111}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在掌握了 KMC 算法的核心机制后，一个典型的应用便是模拟粒子在晶格上的扩散。宏观的扩散现象源于微观层面上一系列由阿伦尼乌斯式速率控制的随机跳跃。本实践将指导您从零开始实现一个完整的 KMC 模拟，并通过分析模拟出的粒子轨迹来提取宏观输运性质——扩散系数 $D$，从而展示 KMC 在连接微观动力学与宏观可观测量方面的强大能力 。",
            "id": "4249524",
            "problem": "考虑在计算电化学背景下，单个吸附质在无限二维方格晶格上的扩散，该过程通过动力学蒙特卡洛（KMC）方法进行建模。每次跳跃是长度为 $a$ 的最近邻移动，以相等的概率向四个等效方向之一移动。每个方向的微观扩散速率由 Arrhenius 形式给出：$k_{\\text{diff}}=\\nu \\exp\\!\\left(-E_a/(k_B T)\\right)$，其中 $\\nu$ 是尝试频率，$E_a$ 是活化能，$k_B$ 是 Boltzmann 常数，$T$ 是温度。从任意位点出发的总逃逸速率为 $R=4\\,k_{\\text{diff}}$。在连续时间 KMC 中，连续跳跃之间的等待时间 $\\Delta t$ 从参数为 $R$ 的指数分布中抽样，并且从四个邻居中均匀选择跳跃方向。\n\n从基础的统计力学和随机过程原理出发，即用于 Arrhenius 速率的过渡态理论以及连续时间随机行走与扩散的映射关系，实现一个 KMC 模拟，该模拟需要：\n- 通过对等待时间和跳跃方向进行抽样，演化粒子在晶格上的位置 $(x(t),y(t))$。\n- 计算均方位移 $\\langle r^2(t)\\rangle$ 的时间序列，其中 $r^2(t)=x(t)^2+y(t)^2$。\n- 通过拟合二维情况下长时间下 $\\langle r^2(t)\\rangle$ 与 $t$ 之间的线性关系来提取扩散系数 $D$，该关系的形式为 $\\langle r^2(t)\\rangle = 4 D t$。\n\n为确保普遍适用性，请遵循以下定义和要求：\n- 使用以电子伏特每开尔文为单位的 Boltzmann 常数，$k_B = 8.617333262145\\times 10^{-5}\\ \\text{eV/K}$。\n- 将 $k_{\\text{diff}}$ 视为单方向速率，因此总速率为 $R=4\\,k_{\\text{diff}}$。\n- 每次跳跃使位置沿其中一个坐标轴精确改变一个晶格间距 $a$，即 $(\\pm a,0)$ 或 $(0,\\pm a)$，且概率相等。\n- KMC 时钟通过以 $R$ 为参数的指数分布等待时间来推进。\n- 通过对 $\\langle r^2(t)\\rangle$ 与 $t$ 的关系进行约束通过原点的最小二乘拟合，计算 $D$ 的估计值。\n\n物理和数值单位：\n- 所有输入参数必须按以下单位进行解释：$T$ 单位为开尔文，$\\nu$ 单位为 $\\text{s}^{-1}$，$E_a$ 单位为电子伏特，$a$ 单位为纳米。\n- 最终的扩散系数需以国际单位制（SI）表示，即 $\\text{m}^2/\\text{s}$，并以保留六位有效数字的科学记数法进行四舍五入和报告。\n\n测试套件和覆盖范围：\n实现您的程序，为以下每一组参数计算 KMC 提取的扩散系数。对于每种情况，运行恰好 $N_{\\text{events}}=120{,}000$ 次 KMC 跳跃以累积统计数据。使用固定的随机种子以确保结果可复现。\n- 情况 $1$：$T=300$, $\\nu=1.0\\times 10^{13}$, $E_a=0.50$, $a=0.30$。\n- 情况 $2$：$T=300$, $\\nu=1.0\\times 10^{13}$, $E_a=0.05$, $a=0.30$。\n- 情况 $3$：$T=300$, $\\nu=1.0\\times 10^{13}$, $E_a=0.90$, $a=0.30$。\n- 情况 $4$：$T=350$, $\\nu=5.0\\times 10^{12}$, $E_a=0.50$, $a=0.25$。\n- 情况 $5$：$T=300$, $\\nu=1.0\\times 10^{13}$, $E_a=0.00$, $a=0.30$。\n\n所有五种情况共享相同的 KMC 事件数 $N_{\\text{events}}=120{,}000$。对于每种情况，通过对 $\\langle r^2(t)\\rangle$ 与 $t$ 的关系进行约束通过原点的线性拟合来推断 $D$。您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表，格式如下：\n- 一个包含五个浮点数的列表，按顺序对应情况 1 到 5 的 KMC 提取的扩散系数。\n- 每个数字必须格式化为具有六位有效数字的科学记数法（例如，$1.234560\\text{e-07}$）。\n例如，输出格式必须与 [$d_1$,$d_2$,$d_3$,$d_4$,$d_5$] 完全相同，其中每个 $d_i$ 是以指定格式书写的以 $\\text{m}^2/\\text{s}$ 为单位的数字。",
            "solution": "问题陈述已被分析并确定为有效。它在科学上基于统计力学和随机过程的原理，并采用标准的动力学蒙特卡洛（KMC）模型来模拟表面扩散。该问题是适定的，提供了所有必要的参数、初始条件（隐式地在原点）以及清晰的数据分析步骤。语言客观，参数在物理上是现实的。因此，将提供一个解决方案。\n\n### 理论框架\n\n该问题要求我们模拟吸附质在二维方格晶格上的扩散，并提取扩散系数 $D$。该过程的基础在于微观随机行走与宏观扩散之间的对应关系。\n\n扩散过程被建模为连续时间随机行走（CTRW）。在任意给定的晶格位点上，吸附质可以跳跃到四个最近邻位点之一。特定方向跳跃的速率由过渡态理论的 Arrhenius 表达式给出：\n$$\nk_{\\text{diff}} = \\nu \\exp\\left(-\\frac{E_a}{k_B T}\\right)\n$$\n其中 $\\nu$ 是尝试频率，$E_a$ 是扩散活化能，$k_B$ 是 Boltzmann 常数，$T$ 是绝对温度。由于存在四个等效、独立的逃逸路径，因此从任何位点出发的总逃逸速率是各个速率的总和：\n$$\nR = 4 k_{\\text{diff}}\n$$\n在晶格间距为 $a$ 的方格晶格上进行随机行走时，每次跳跃使粒子的位置矢量 $\\vec{r}$ 改变一个位移矢量 $\\Delta\\vec{r}$，其中 $\\Delta\\vec{r}$ 是 $(\\pm a, 0)$ 或 $(0, \\pm a)$ 中的一个。经过 $N$ 次跳跃后，总位移为 $\\vec{r}_N = \\sum_{i=1}^{N} \\Delta\\vec{r}_i$。均方位移 (MSD) 由以下公式给出：\n$$\n\\langle r^2(N) \\rangle = \\langle \\vec{r}_N \\cdot \\vec{r}_N \\rangle = \\left\\langle \\left( \\sum_{i=1}^{N} \\Delta\\vec{r}_i \\right) \\cdot \\left( \\sum_{j=1}^{N} \\Delta\\vec{r}_j \\right) \\right\\rangle\n$$\n由于每次跳跃的方向是独立选择的，交叉项的平均值为零（对于 $i \\neq j$ 有 $\\langle \\Delta\\vec{r}_i \\cdot \\Delta\\vec{r}_j \\rangle = 0$）。这将表达式简化为：\n$$\n\\langle r^2(N) \\rangle = \\sum_{i=1}^{N} \\langle |\\Delta\\vec{r}_i|^2 \\rangle = \\sum_{i=1}^{N} a^2 = N a^2\n$$\nKMC 方法模拟系统的时间演化。连续跳跃之间的等待时间 $\\Delta t$ 是从总速率为 $R$ 的指数分布中抽取的随机变量，即 $P(\\Delta t) = R \\exp(-R\\Delta t)$。单次跳跃的平均等待时间是 $\\langle \\Delta t \\rangle = 1/R$。$N$ 次跳跃后经过的总时间是 $t_N = \\sum_{i=1}^N \\Delta t_i$，其期望值为 $\\langle t_N \\rangle = N \\langle \\Delta t \\rangle = N/R$。\n\n将 $N = R t$ 代入 MSD 方程，我们得到 MSD 与时间之间的关系：\n$$\n\\langle r^2(t) \\rangle = (R a^2) t\n$$\n二维扩散的 Einstein 关系将 MSD 与扩散系数 $D$ 联系起来：\n$$\n\\langle r^2(t) \\rangle = 4 D t\n$$\n比较这两个 MSD 的表达式，我们推导出该模型的理论扩散系数：\n$$\n4 D t = (R a^2) t \\implies D = \\frac{1}{4} R a^2\n$$\n代入 $R = 4 k_{\\text{diff}}$，我们得到最终的理论表达式：\n$$\nD = \\frac{1}{4} (4 k_{\\text{diff}}) a^2 = k_{\\text{diff}} a^2 = a^2 \\nu \\exp\\left(-\\frac{E_a}{k_B T}\\right)\n$$\nKMC 模拟将在数值上生成一个轨迹 $(x(t), y(t))$，我们可以从中计算位移平方 $r^2(t) = x(t)^2 + y(t)^2$ 的时间序列。这个数值数据随后将用于估计 $D$。\n\n### 动力学蒙特卡洛（KMC）算法\n\n对于每组参数，执行以下 KMC 算法：\n1.  **初始化**：\n    - 将粒子的初始位置设置在晶格的原点，即 $(x, y) = (0, 0)$。\n    - 将初始模拟时间设置为 $t = 0$。\n    - 初始化数据结构，用于存储 $N_{\\text{events}}$ 个步骤中每一步的模拟时间 $t_i$ 和对应的位移平方 $r^2_i$ 的历史记录。\n    - 为伪随机数生成器设置一个固定的种子以确保可复现性。\n\n2.  **速率计算**：\n    - 使用给定的参数 $T$、$\\nu$、$E_a$ 和常数 $k_B$ 计算单方向跳跃速率 $k_{\\text{diff}}$。\n    - 计算总速率 $R = 4 k_{\\text{diff}}$。\n\n3.  **模拟循环**：\n    - 总共迭代 $N_{\\text{events}}$ 步。在每一步 $i$ 中：\n        a. **时间推进**：从速率参数为 $R$ 的指数分布中抽样等待时间 $\\Delta t$。一种常用方法是使用逆变换采样：$\\Delta t = -\\ln(u)/R$，其中 $u$ 是在 $(0, 1]$ 上均匀分布的随机数。模拟时钟按此量推进：$t \\leftarrow t + \\Delta t$。\n        b. **选择事件**：选择一个跳跃方向。由于所有四个最近邻跳跃的概率相等（每个速率为 $k_{\\text{diff}}$），我们以 $1/4$ 的均匀概率选择四个方向之一（例如，+x, -x, +y, -y）。\n        c. **更新状态**：通过加上与所选方向对应的位移矢量 $(\\pm a, 0)$ 或 $(0, \\pm a)$ 来更新粒子的坐标 $(x, y)$。\n        d. **记录数据**：存储新的时间 $t$ 和新的位移平方 $r^2 = x^2 + y^2$。\n\n### 数据分析和参数提取\n\n模拟完成后，我们得到一个位移平方的时间序列 $\\{ (t_i, r^2_i) \\}_{i=1}^{N_{\\text{events}}}$。为了提取扩散系数，我们将此数据拟合到线性模型 $\\langle r^2(t) \\rangle = m t$，该模型被约束通过原点 $(0, 0)$。这条线的斜率是 $m = 4D$。\n\n对于约束通过原点的拟合，使平方误差和 $\\sum_i (r^2_i - m t_i)^2$ 最小化的斜率 $m$ 由以下解析解给出：\n$$\nm = \\frac{\\sum_{i=1}^{N_{\\text{events}}} t_i r^2_i}{\\sum_{i=1}^{N_{\\text{events}}} t_i^2}\n$$\n此计算使用记录的时间和位移平方数据进行。一旦斜率 $m$ 被确定，扩散系数 $D$ 的计算方法如下：\n$$\nD = \\frac{m}{4}\n$$\n参数 $a$ 和时间的单位分别为纳米和秒。这意味着计算出的 $D$ 的单位将是 $\\text{nm}^2/\\text{s}$。然后必须使用转换因子 $1 \\text{ nm}^2 = 10^{-18} \\text{ m}^2$ 将该值转换为所需的国际单位制单位 $\\text{m}^2/\\text{s}$。最终结果随后被格式化为指定的精度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs Kinetic Monte Carlo simulations of surface diffusion for five test cases\n    and extracts the diffusion coefficient for each.\n    \"\"\"\n    # Define physical constant\n    KB_EV_K = 8.617333262145e-5  # Boltzmann constant in eV/K\n\n    # Define simulation parameters\n    N_EVENTS = 120000\n    RANDOM_SEED = 42\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (T, nu, Ea, a)\n    # Units: T in K, nu in 1/s, Ea in eV, a in nm\n    test_cases = [\n        (300.0, 1.0e13, 0.50, 0.30),  # Case 1\n        (300.0, 1.0e13, 0.05, 0.30),  # Case 2\n        (300.0, 1.0e13, 0.90, 0.30),  # Case 3\n        (350.0, 5.0e12, 0.50, 0.25),  # Case 4\n        (300.0, 1.0e13, 0.00, 0.30),  # Case 5\n    ]\n\n    results = []\n\n    # Set the random seed for reproducibility\n    np.random.seed(RANDOM_SEED)\n\n    for case in test_cases:\n        T, nu, Ea, a = case\n\n        # --- 1. Calculate Rates ---\n        # Arrhenius rate for a single direction\n        k_diff = nu * np.exp(-Ea / (KB_EV_K * T))\n        # Total escape rate from a site\n        R = 4.0 * k_diff\n\n        # --- 2. KMC Simulation ---\n        # Initialize simulation state in lattice units\n        ix, iy = 0, 0  # Integer lattice coordinates\n        time = 0.0\n\n        # Arrays to store the history of time and squared displacement\n        # +1 to include the initial state (t=0, r^2=0)\n        t_history = np.zeros(N_EVENTS + 1, dtype=float)\n        r2_history = np.zeros(N_EVENTS + 1, dtype=float)\n\n        # Define possible hops in lattice units\n        # (0: +x, 1: -x, 2: +y, 3: -y)\n        hops = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n        for i in range(1, N_EVENTS + 1):\n            # Advance time: sample from exponential distribution with rate R\n            # scale parameter is 1/lambda, which is 1/R\n            dt = np.random.exponential(scale=1.0/R)\n            time += dt\n\n            # Choose a hop direction uniformly from the 4 options\n            direction = np.random.randint(0, 4)\n            dix, diy = hops[direction]\n\n            # Update particle position in lattice units\n            ix += dix\n            iy += diy\n\n            # Store history\n            t_history[i] = time\n            # Convert lattice displacement squared to real units (nm^2)\n            r2_history[i] = (ix**2 + iy**2) * (a**2)\n\n        # --- 3. Extract Diffusion Coefficient ---\n        # The model is r^2 = m*t, where m = 4*D\n        # For a fit through the origin, m = sum(t_i * r2_i) / sum(t_i^2)\n        \n        # Using np.dot for efficient summation of products\n        # We include the full history, as t_history[0]=0 and r2_history[0]=0,\n        # which correctly contributes zero to the sums.\n        numerator = np.dot(t_history, r2_history)\n        denominator = np.dot(t_history, t_history)\n        \n        if denominator == 0:\n            # This case should not happen with N_EVENTS > 0\n            # If it did, it would mean all dt were 0, which is impossible.\n            D_nm2_s = 0.0\n        else:\n            m = numerator / denominator\n            # D = m/4\n            D_nm2_s = m / 4.0\n\n        # --- 4. Unit Conversion ---\n        # Convert D from nm^2/s to m^2/s\n        # 1 nm = 1e-9 m -> 1 nm^2 = 1e-18 m^2\n        D_m2_s = D_nm2_s * 1e-18\n\n        results.append(D_m2_s)\n\n    # Final print statement in the exact required format.\n    # The format \"{:.6e}\" produces a coefficient with 1 digit before the decimal\n    # and 6 digits after, matching the example's precision (7 sig figs total).\n    formatted_results = [f\"{res:.6e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "动力学蒙特卡洛方法在模拟电化学中复杂的多步骤表面过程时尤为强大。遍历性假说是统计力学中的一个基石，它指出对于一个平稳系统，某个可观测量的时间平均值等于其系综平均值。这个高级练习将模拟一个包含吸附、脱附和电子转移等竞争性过程的完整电化学体系，通过将单次 KMC 轨迹得到的时间平均法拉第电流与解析计算的系综平均值进行比较，为遍历性假说提供一个切实的检验 。",
            "id": "4249495",
            "problem": "实现一个连续时间动力学蒙特卡洛程序，以证明一个平稳、遍历的表面过程的时间平均法拉第电流收敛于其系综平均值。考虑一个由$N$个相同、独立的无相互作用表面位点组成的晶格。每个位点是一个具有三个表面状态的连续时间马尔可夫链，状态由$s \\in \\{0,1,2\\}$索引，分别代表$0$：空位，$1$：吸附的氧化态物种$\\mathrm{Ox}_{\\mathrm{ads}}$，以及$2$：吸附的还原态物种$\\mathrm{Red}_{\\mathrm{ads}}$。每个位点允许的跃迁及其速率定义如下：\n- 与溶液储库之间的吸附和脱附：\n  - $0 \\to 1$，速率为 $k_{01} = k^{\\mathrm{Ox}}_{\\mathrm{ads}}\\, c_{\\mathrm{Ox}}$，\n  - $1 \\to 0$，速率为 $k_{10} = k^{\\mathrm{Ox}}_{\\mathrm{des}}$，\n  - $0 \\to 2$，速率为 $k_{02} = k^{\\mathrm{Red}}_{\\mathrm{ads}}\\, c_{\\mathrm{Red}}$，\n  - $2 \\to 0$，速率为 $k_{20} = k^{\\mathrm{Red}}_{\\mathrm{des}}$。\n- 表面上的电子转移（类Butler–Volmer）相互转化：\n  - $1 \\to 2$（还原），速率为 $k_{12} = k_0 \\exp\\!\\left(\\alpha \\beta F \\Delta E \\right)$，\n  - $2 \\to 1$（氧化），速率为 $k_{21} = k_0 \\exp\\!\\left(-(1-\\alpha)\\, \\beta F \\Delta E \\right)$，\n其中 $\\Delta E = E - E^0$，$\\beta = 1/(R T)$，$F$是法拉第常数，$R$是气体常数，$T$是绝对温度，$\\alpha$是转移系数，$k_0$是电子转移指前因子，$k^{\\mathrm{Ox}}_{\\mathrm{ads}}$和$k^{\\mathrm{Red}}_{\\mathrm{ads}}$是吸附系数，$k^{\\mathrm{Ox}}_{\\mathrm{des}}$和$k^{\\mathrm{Red}}_{\\mathrm{des}}$是脱附系数，$c_{\\mathrm{Ox}}$和$c_{\\mathrm{Red}}$是本体浓度。所有速率的单位为$\\mathrm{s}^{-1}$，浓度的单位为$\\mathrm{mol}\\,\\mathrm{L}^{-1}$，电势的单位为$\\mathrm{V}$。处理为每个 $1 \\leftrightarrow 2$ 事件转移 $n=1$ 个电子。设元电荷为 $q$，单位为 $\\mathrm{C}$。\n\n使用的基本原理：\n- 一个生成元矩阵为 $Q$ 的连续时间马尔可夫链是平稳的，如果其平稳分布 $\\boldsymbol{\\pi}$ 满足 $\\boldsymbol{\\pi} Q = \\boldsymbol{0}$ 和 $\\sum_i \\pi_i = 1$。\n- 对于一个平稳、遍历的马尔可夫过程和一个可积的可观测量 $A(t)$，Birkhoff遍历定理确保长时间平均 $\\lim_{T \\to \\infty} \\frac{1}{T}\\int_0^T A(t)\\, \\mathrm{d}t$ 几乎必然存在，且等于系综平均 $\\mathbb{E}_{\\boldsymbol{\\pi}}[A]$。\n- 系综平均法拉第电流是沿电子转移边的单位时间期望净电子通量，乘以 $q$ 和位点数 $N$。在长度为 $T$ 的有限时间窗口内的带符号时间平均电流是 $1 \\leftrightarrow 2$ 事件的净计数乘以 $q$，再除以 $T$。\n\n需要实现的任务：\n- 根据上述速率为一个位点构建 $3 \\times 3$ 的生成元矩阵 $Q$，并通过求解 $\\boldsymbol{\\pi} Q = \\boldsymbol{0}$ 及归一化条件 $\\sum_i \\pi_i = 1$ 来计算平稳分布 $\\boldsymbol{\\pi}$。\n- 从第一性原理出发，将系综平均法拉第电流表示为平稳状态下的期望带符号电子转移速率乘以 $q$ 和 $N$。最终电流以 $\\mathrm{A}$ 为单位表示。\n- 设计一个动力学蒙特卡洛模拟，对位点计数状态 $(n_0,n_1,n_2)$（其中 $n_0+n_1+n_2=N$）使用精确随机模拟算法（Gillespie直接法）。其倾向是单位点速率乘以当前位点计数。通过从概率为 $\\boldsymbol{\\pi}$ 的多项分布中抽样来初始化 $(n_0,n_1,n_2)$，以在平稳状态下启动。对每个测试案例，模拟直至请求的最大观测时间，并记录净电子计数 $N_e(t)$，即 $1 \\leftrightarrow 2$ 事件的带符号计数（为 $1 \\to 2$ 还原分配 $+1$，为 $2 \\to 1$ 氧化分配 $-1$）。\n- 对于每个请求的观测时间 $T$，计算有限时间的时间平均电流 $I_T = q\\, N_e(T)/T$（单位为$\\mathrm{A}$）和有限时间偏差 $B_T = I_T - I_{\\mathrm{ens}}$（单位为$\\mathrm{A}$），其中 $I_{\\mathrm{ens}}$ 是系综平均电流。使用固定的随机种子以使结果可复现。\n\n使用的物理常数：\n- $F = 96485\\,\\mathrm{C}\\,\\mathrm{mol}^{-1}$,\n- $R = 8.314\\,\\mathrm{J}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$,\n- $T = 298.15\\,\\mathrm{K}$,\n- $q = 1.602176634\\times 10^{-19}\\,\\mathrm{C}$.\n\n使用以下参数集测试套件：\n- A案例（平衡，接近细致平衡）：\n  - $N = 200$,\n  - $E = 0.20\\,\\mathrm{V}$, $E^0 = 0.20\\,\\mathrm{V}$ 因此 $\\Delta E = 0.00\\,\\mathrm{V}$,\n  - $\\alpha = 0.50$, $k_0 = 50.0\\,\\mathrm{s}^{-1}$,\n  - $k^{\\mathrm{Ox}}_{\\mathrm{ads}} = 20.0\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$, $k^{\\mathrm{Ox}}_{\\mathrm{des}} = 2.0\\,\\mathrm{s}^{-1}$,\n  - $k^{\\mathrm{Red}}_{\\mathrm{ads}} = 20.0\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$, $k^{\\mathrm{Red}}_{\\mathrm{des}} = 2.0\\,\\mathrm{s}^{-1}$,\n  - $c_{\\mathrm{Ox}} = 0.010\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$, $c_{\\mathrm{Red}} = 0.010\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$,\n  - 观测时间 $T \\in \\{0.010\\,\\mathrm{s}, 0.100\\,\\mathrm{s}, 1.000\\,\\mathrm{s}\\}$。\n- B案例（驱动还原）：\n  - $N = 200$,\n  - $E = 0.22\\,\\mathrm{V}$, $E^0 = 0.20\\,\\mathrm{V}$ 因此 $\\Delta E = 0.02\\,\\mathrm{V}$,\n  - $\\alpha = 0.50$, $k_0 = 50.0\\,\\mathrm{s}^{-1}$,\n  - $k^{\\mathrm{Ox}}_{\\mathrm{ads}} = 20.0\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$, $k^{\\mathrm{Ox}}_{\\mathrm{des}} = 2.0\\,\\mathrm{s}^{-1}$,\n  - $k^{\\mathrm{Red}}_{\\mathrm{ads}} = 20.0\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$, $k^{\\mathrm{Red}}_{\\mathrm{des}} = 2.0\\,\\mathrm{s}^{-1}$,\n  - $c_{\\mathrm{Ox}} = 0.015\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$, $c_{\\mathrm{Red}} = 0.005\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$,\n  - 观测时间 $T \\in \\{0.010\\,\\mathrm{s}, 0.100\\,\\mathrm{s}, 1.000\\,\\mathrm{s}\\}$。\n- C案例（驱动氧化，较少位点以突显有限时间偏差）：\n  - $N = 50$,\n  - $E = 0.18\\,\\mathrm{V}$, $E^0 = 0.20\\,\\mathrm{V}$ 因此 $\\Delta E = -0.02\\,\\mathrm{V}$,\n  - $\\alpha = 0.50$, $k_0 = 50.0\\,\\mathrm{s}^{-1}$,\n  - $k^{\\mathrm{Ox}}_{\\mathrm{ads}} = 20.0\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$, $k^{\\mathrm{Ox}}_{\\mathrm{des}} = 2.0\\,\\mathrm{s}^{-1}$,\n  - $k^{\\mathrm{Red}}_{\\mathrm{ads}} = 20.0\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$, $k^{\\mathrm{Red}}_{\\mathrm{des}} = 2.0\\,\\mathrm{s}^{-1}$,\n  - $c_{\\mathrm{Ox}} = 0.005\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$, $c_{\\mathrm{Red}} = 0.015\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$,\n  - 观测时间 $T \\in \\{0.010\\,\\mathrm{s}, 0.050\\,\\mathrm{s}, 0.200\\,\\mathrm{s}\\}$。\n\n您的程序必须：\n- 对于每个案例，根据平稳分布和净电子转移通量定义计算系综平均电流 $I_{\\mathrm{ens}}$（单位为$\\mathrm{A}$）。\n- 对每个案例，从平稳分布开始运行动力学蒙特卡洛模拟，使用固定的伪随机种子，并为该案例中每个指定的 $T$ 计算有限时间的时间平均电流 $I_T$ 和偏差 $B_T = I_T - I_{\\mathrm{ens}}$。所有电流和偏差必须以 $\\mathrm{A}$ 为单位。\n- 生成单行输出，其中包含所有案例和时间的偏差序列，按A案例时间升序、然后B案例时间升序、最后C案例时间升序的顺序排列，格式为用方括号括起来的逗号分隔列表，例如 $[\\dots]$。\n\n重要提示：不使用角度。将所有电流和偏差以 $\\mathrm{A}$ 为单位表示为浮点数。最终输出必须是包含指定列表的单行。",
            "solution": "该问题是有效的。这是一个在计算电化学领域中适定且有科学依据的问题，要求实现一个连续时间动力学蒙特卡洛（kMC）模拟，并将其与解析的系综平均值进行比较，从而为一个平稳随机过程验证遍历假设。所有必要的参数和常数都已提供，且模型在物理上和数学上都是一致的。\n\n解决方案分两部分展开：首先，解析计算系综平均法拉第电流；其次，设计一个动力学蒙特卡洛模拟来计算时间平均电流。\n\n**1. 系综平均法拉第电流**\n\n该系统由$N$个独立且相同的表面位点组成，每个位点的行为如同一个具有三个状态的连续时间马尔可夫链：$0$（空位）、$1$（$\\mathrm{Ox}_{\\mathrm{ads}}$）和$2$（$\\mathrm{Red}_{\\mathrm{ads}}$）。单个位点的动力学由一个$3 \\times 3$的生成元矩阵$Q$控制，其中当$i \\neq j$时，$Q_{ij}$是从状态$i$到状态$j$的跃迁速率，而$Q_{ii} = -\\sum_{j \\neq i} Q_{ij}$。速率由以下公式给出：\n$k_{01} = k^{\\mathrm{Ox}}_{\\mathrm{ads}}\\, c_{\\mathrm{Ox}}$\n$k_{10} = k^{\\mathrm{Ox}}_{\\mathrm{des}}$\n$k_{02} = k^{\\mathrm{Red}}_{\\mathrm{ads}}\\, c_{\\mathrm{Red}}$\n$k_{20} = k^{\\mathrm{Red}}_{\\mathrm{des}}$\n$k_{12} = k_0 \\exp(\\alpha \\beta F \\Delta E)$\n$k_{21} = k_0 \\exp(-(1-\\alpha) \\beta F \\Delta E)$\n\n因此，生成元矩阵$Q$为：\n$$\nQ = \\begin{pmatrix}\n-(k_{01} + k_{02}) & k_{01} & k_{02} \\\\\nk_{10} & -(k_{10} + k_{12}) & k_{12} \\\\\nk_{20} & k_{21} & -(k_{20} + k_{21})\n\\end{pmatrix}\n$$\n该过程是遍历的，因此存在一个唯一的平稳分布向量 $\\boldsymbol{\\pi} = (\\pi_0, \\pi_1, \\pi_2)$，它分别代表了单个位点处于状态$0$、$1$或$2$的长期概率。该分布是稳态下主方程 $\\boldsymbol{\\pi} Q = \\boldsymbol{0}$ 在归一化条件 $\\sum_i \\pi_i = 1$ 下的解。这个线性方程组通过找到$Q^T$对应于特征值$0$的特征向量，然后将所得向量归一化使其和为$1$来进行数值求解。\n\n法拉第电流由 $1 \\leftrightarrow 2$ 跃迁中的电子净流产生。对于单个位点，还原事件（$1 \\to 2$）相对于氧化事件（$2 \\to 1$）的净速率是 $(k_{12} - k_{21})$。在平稳系综中，期望的净还原速率由通量平衡给出，并考虑了处于相应前提状态的概率：$k_{12}\\pi_1 - k_{21}\\pi_2$。由于每个净还原事件对应于转移单个元电荷 $q$（因为 $n=1$），因此整个$N$位点系统的系综平均法拉第电流 $I_{\\mathrm{ens}}$ 为：\n$$\nI_{\\mathrm{ens}} = N \\cdot q \\cdot (k_{12}\\pi_1 - k_{21}\\pi_2)\n$$\n按照惯例，净还原电流为正。\n\n**2. 通过动力学蒙特卡洛模拟计算时间平均法拉第电流**\n\n动力学蒙特卡洛（kMC）模拟对整个$N$位点系统的随机演化进行建模。系统的状态由每种位点类型的布局数 $(n_0, n_1, n_2)$ 描述，其中 $n_0+n_1+n_2 = N$。存在六种可能的事件类型（或反应通道），对应于六个基元跃迁。由于位点之间无相互作用，每种事件类型的总速率（倾向）是单位点速率乘以可进行该跃迁的位点数：\n\\begin{itemize}\n    \\item $0 \\to 1$: $a_1 = k_{01}n_0$\n    \\item $1 \\to 0$: $a_2 = k_{10}n_1$\n    \\item $0 \\to 2$: $a_3 = k_{02}n_0$\n    \\item $2 \\to 0$: $a_4 = k_{20}n_2$\n    \\item $1 \\to 2$ (还原): $a_5 = k_{12}n_1$\n    \\item $2 \\to 1$ (氧化): $a_6 = k_{21}n_2$\n\\end{itemize}\n该模拟使用精确随机模拟算法（Gillespie直接法）实现：\n\n1.  **初始化**：在时间 $t=0$ 时，将系统准备到与平稳分布一致的状态。通过从具有 $N$ 次试验和概率 $\\boldsymbol{\\pi} = (\\pi_0, \\pi_1, \\pi_2)$ 的多项分布中抽取一个样本来初始化位点布局数 $(n_0, n_1, n_2)$。净电子计数初始化为 $N_e(0) = 0$。\n\n2.  **迭代**：模拟以离散的随机步长进行。在每一步：\n    a. 根据当前状态 $(n_0, n_1, n_2)$ 计算六个倾向 $a_j$。\n    b. 计算总倾向 $A = \\sum_{j=1}^6 a_j$。\n    c. 从均匀分布 $U(0,1)$ 中抽取两个独立的随机数 $r_1, r_2$。\n    d. 将模拟时间推进一个随机增量 $\\Delta t = -\\frac{1}{A} \\ln(r_1)$。\n    e. 选择发生的事件。选择事件 $j$ 使得 $\\sum_{i=1}^{j-1} a_i  r_2 A \\le \\sum_{i=1}^j a_i$。\n    f. 更新系统状态。对于所选事件 $j$，更新布局数 $(n_0, n_1, n_2)$。如果事件是还原（$1 \\to 2$），则净电子计数增加：$N_e \\leftarrow N_e + 1$。如果是氧化（$2 \\to 1$），则减少：$N_e \\leftarrow N_e - 1$。\n\n3.  **数据记录**：对每个测试案例，模拟运行至最大观测时间 $T_{\\max}$。当模拟时间 $t$ 越过每个指定的观测时间 $T$ 时，计算时间平均电流。净电子计数 $N_e(t)$ 是一个分段常数函数。其在观测时间 $T$ 时的值，记为 $N_e(T)$，是到该点为止转移的净电子总数。时间平均电流为：\n    $$\n    I_T = \\frac{q \\cdot N_e(T)}{T}\n    $$\n    Birkhoff遍历定理指出，对于一个平稳遍历过程，$\\lim_{T \\to \\infty} I_T = I_{\\mathrm{ens}}$。有限时间偏差 $B_T = I_T - I_{\\mathrm{ens}}$ 量化了对于有限观测窗口和单个随机轨迹，时间平均值与系综平均值之间的偏差。该偏差预计会随着 $T$ 的增加而减小。使用固定的随机种子以确保随机轨迹和所得偏差的可复现性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import null_space\n\ndef solve():\n    \"\"\"\n    Implements a kMC simulation for an electrochemical surface process and\n    calculates the bias between the time-averaged and ensemble-averaged\n    faradaic current.\n    \"\"\"\n    # Use a fixed random seed for reproducibility.\n    np.random.seed(42)\n\n    # Physical constants\n    F = 96485.0  # C/mol\n    R = 8.314  # J/(mol*K)\n    T_K = 298.15  # K\n    q = 1.602176634e-19  # C\n\n    # Test suite of parameter sets\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"N\": 200, \"E\": 0.20, \"E0\": 0.20, \"alpha\": 0.50, \"k0\": 50.0,\n            \"k_ox_ads\": 20.0, \"k_ox_des\": 2.0,\n            \"k_red_ads\": 20.0, \"k_red_des\": 2.0,\n            \"c_ox\": 0.010, \"c_red\": 0.010,\n            \"times\": [0.010, 0.100, 1.000]\n        },\n        {\n            \"name\": \"Case B\",\n            \"N\": 200, \"E\": 0.22, \"E0\": 0.20, \"alpha\": 0.50, \"k0\": 50.0,\n            \"k_ox_ads\": 20.0, \"k_ox_des\": 2.0,\n            \"k_red_ads\": 20.0, \"k_red_des\": 2.0,\n            \"c_ox\": 0.015, \"c_red\": 0.005,\n            \"times\": [0.010, 0.100, 1.000]\n        },\n        {\n            \"name\": \"Case C\",\n            \"N\": 50, \"E\": 0.18, \"E0\": 0.20, \"alpha\": 0.50, \"k0\": 50.0,\n            \"k_ox_ads\": 20.0, \"k_ox_des\": 2.0,\n            \"k_red_ads\": 20.0, \"k_red_des\": 2.0,\n            \"c_ox\": 0.005, \"c_red\": 0.015,\n            \"times\": [0.010, 0.050, 0.200]\n        }\n    ]\n\n    all_biases = []\n    \n    # Pre-calculate beta * F\n    beta_F = F / (R * T_K)\n\n    for case in test_cases:\n        N = case[\"N\"]\n        delta_E = case[\"E\"] - case[\"E0\"]\n        \n        # 1. Calculate per-site transition rates\n        k01 = case[\"k_ox_ads\"] * case[\"c_ox\"]\n        k10 = case[\"k_ox_des\"]\n        k02 = case[\"k_red_ads\"] * case[\"c_red\"]\n        k20 = case[\"k_red_des\"]\n        k12 = case[\"k0\"] * np.exp(case[\"alpha\"] * beta_F * delta_E)\n        k21 = case[\"k0\"] * np.exp(-(1.0 - case[\"alpha\"]) * beta_F * delta_E)\n        \n        # 2. Compute stationary distribution pi\n        Q = np.array([\n            [-(k01 + k02), k01, k02],\n            [k10, -(k10 + k12), k12],\n            [k20, k21, -(k20 + k21)]\n        ])\n        \n        # Find the null space of Q.T, which corresponds to the stationary distribution\n        pi_unnormalized = null_space(Q.T).flatten()\n        # Ensure positivity and normalize\n        pi = np.abs(pi_unnormalized) / np.sum(np.abs(pi_unnormalized))\n\n        # 3. Calculate ensemble-averaged current\n        I_ens = N * q * (k12 * pi[1] - k21 * pi[2])\n\n        # 4. Run kMC simulation\n        # Initialize state from multinomial distribution\n        n_counts = np.random.multinomial(N, pi)\n        \n        t = 0.0\n        Ne = 0 # Net electron count (+1 for reduction, -1 for oxidation)\n        \n        obs_times = sorted(case[\"times\"])\n        max_T = obs_times[-1]\n        case_biases = [0.0] * len(obs_times)\n        obs_idx = 0\n        \n        # State update vector (n0, n1, n2) changes for each reaction\n        updates = np.array([\n            [-1, 1, 0], [1, -1, 0], [-1, 0, 1],\n            [1, 0, -1], [0, -1, 1], [0, 1, -1]\n        ])\n        # Ne change for each reaction\n        Ne_updates = np.array([0, 0, 0, 0, 1, -1])\n\n        while t  max_T:\n            # Calculate propensities\n            propensities = np.array([\n                k01 * n_counts[0],\n                k10 * n_counts[1],\n                k02 * n_counts[0],\n                k20 * n_counts[2],\n                k12 * n_counts[1],\n                k21 * n_counts[2]\n            ])\n            A_total = np.sum(propensities)\n            \n            if A_total == 0:\n                break\n                \n            # Draw random numbers for time step and reaction choice\n            r1, r2 = np.random.rand(2)\n            dt = -np.log(r1) / A_total\n            t_next = t + dt\n\n            # Record data if an observation time is crossed\n            while obs_idx  len(obs_times) and t_next >= obs_times[obs_idx]:\n                T_obs = obs_times[obs_idx]\n                I_T = q * Ne / T_obs\n                bias = I_T - I_ens\n                case_biases[obs_idx] = bias\n                obs_idx += 1\n\n            if obs_idx == len(obs_times):\n                break\n\n            # Choose and execute the reaction\n            reaction_idx = np.searchsorted(np.cumsum(propensities), r2 * A_total)\n            \n            # Update state\n            n_counts += updates[reaction_idx]\n            Ne += Ne_updates[reaction_idx]\n            t = t_next\n            \n        all_biases.extend(case_biases)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_biases))}]\")\n\nsolve()\n```"
        }
    ]
}