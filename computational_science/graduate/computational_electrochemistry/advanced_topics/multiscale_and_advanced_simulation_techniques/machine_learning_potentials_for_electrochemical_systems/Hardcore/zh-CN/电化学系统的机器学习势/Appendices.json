{
    "hands_on_practices": [
        {
            "introduction": "对于原子模拟而言，机器学习势的一个基本要求是尊重物理对称性。这意味着模型的预测（如力和能量）必须随着输入原子坐标的旋转和平移而进行一致的变换。本练习  将指导您构建一个简单的消息传递层，该层通过使用不可约张量特征来确保对三维欧几里得群（$E(3)$）的等变性，这是构建现代几何感知机器学习势的关键第一步。",
            "id": "4250488",
            "problem": "您的任务是在计算电化学框架内，为离子液体构建并验证一个三维欧几里得群 (E(3)) 等变的消息传递架构。目标是实现一个算法流程，以展示不可约张量特征在空间旋转下的传播。三维欧几里得群 (E(3)) 由作用于三维空间的旋转和平移组成。旋转等变性定义为将输入构型旋转一个旋转矩阵 $\\mathbf{R} \\in \\mathrm{SO}(3)$，其输出特征也相应地通过 $\\mathbf{R}$ 的一致表示进行旋转；而平移不变性则通过使用相对位置矢量构建操作来强制实现。您必须在一个图上制定一个消息传递方案，其中节点对应离子，边对应由距离截断决定的邻居关系。\n\n您的架构必须使用不可约特征类型，这些特征在旋转下根据以下规则进行变换：\n- 标量（球谐度 $l=0$）：特征 $s_i$ 在旋转 $\\mathbf{R}$ 下满足 $s_i' = s_i$。\n- 矢量（球谐度 $l=1$）：特征 $\\mathbf{v}_i$ 在旋转 $\\mathbf{R}$ 下满足 $\\mathbf{v}_i' = \\mathbf{R}\\mathbf{v}_i$。\n- 对称无迹二阶张量（球谐度 $l=2$）：特征 $\\mathbf{T}_i$ 在旋转 $\\mathbf{R}$ 下满足 $\\mathbf{T}_i' = \\mathbf{R}\\mathbf{T}_i\\mathbf{R}^{\\top}$。\n\n从以下概念基础开始：\n- 欧几里得群通过旋转 $\\mathbf{R}$ 和平移 $\\mathbf{a}$ 对位置 $\\mathbf{r}_i$ 的作用，使用旋转后的位置 $\\mathbf{r}_i' = \\mathbf{R}\\mathbf{r}_i + \\mathbf{a}$。通过仅使用相对位置 $\\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i$ 和单位方向矢量 $\\hat{\\mathbf{r}}_{ij} = \\mathbf{r}_{ij}/\\|\\mathbf{r}_{ij}\\|$ 来强制实现平移不变性。\n- 旋转等变性要求任何由 $\\hat{\\mathbf{r}}_{ij}$ 和 $\\|\\mathbf{r}_{ij}\\|$ 的各向同性（径向）函数构建的操作在 $\\mathbf{R}$ 作用下进行一致的变换。$\\|\\mathbf{r}_{ij}\\|$ 的各向同性函数是旋转不变的标量。\n- 二阶张量 $\\mathbf{M}$ 的对称无迹投影定义为 $\\mathrm{STT}(\\mathbf{M}) = \\tfrac{1}{2}(\\mathbf{M} + \\mathbf{M}^{\\top}) - \\tfrac{\\mathrm{tr}(\\mathbf{M})}{3}\\mathbf{I}$，其中 $\\mathbf{I}$ 是单位矩阵。\n\n实现一个单一的消息传递层，该层：\n- 使用邻居的 $\\|\\mathbf{r}_{ij}\\|$ 的各向同性径向函数乘以由 $\\hat{\\mathbf{r}}_{ij}$ 和离子电荷 $q_j$ 构建的适当几何协变量，对节点特征 $s_i$（标量）、$\\mathbf{v}_i$（矢量）和 $\\mathbf{T}_i$（对称无迹张量）进行求和初始化。\n- 通过聚合来自邻居 $j$ 的消息来更新特征 $s_i$、$\\mathbf{v}_i$ 和 $\\mathbf{T}_i$，仅使用从 $\\hat{\\mathbf{r}}_{ij}$、$s_j$、$\\mathbf{v}_j$ 和 $\\mathbf{T}_j$ 导出的旋转一致的收缩和投影。更新必须保持 E(3)-等变性：在全局旋转 $\\mathbf{R}$ 下，更新后的特征必须与上述的 $s_i'$、$\\mathbf{v}_i'$ 和 $\\mathbf{T}_i'$ 完全一致地变换。\n- 在更新中使用各向同性标量权重（常数）以避免引入任何优选方向，确保旋转对称性。\n\n通过对每个测试用例执行以下验证，来数值化地展示旋转等变性：\n- 计算原始位置和电荷构型的更新后特征。\n- 对所有位置应用旋转 $\\mathbf{R}$，重新计算更新后的特征，并分别通过每种不可约类型（$l=0$、$l=1$、$l=2$）的适当表示来旋转原始计算出的更新后特征。\n- 报告重新计算的特征与旋转后的特征之间所有节点上的最大差异：对于标量，是绝对差；对于矢量，是差异的欧几里得范数；对于张量，是差异的弗罗贝尼乌斯范数。差异必须表示为无量纲浮点数。\n\n物理和数值约定：\n- 位置以纳米（nm）为单位给出。\n- 旋转角度必须以弧度为单位解释。\n- 所有距离都以纳米为单位计算，径向函数必须仅依赖于以纳米为单位测量的 $\\|\\mathbf{r}_{ij}\\|$。\n- 最终输出是表示数值残差的无量纲浮点数；输出中不要包含物理单位。\n\n测试套件：\n使用以下参数集作为输入构型。对于每种情况，程序必须应用由旋转轴和角度指定的单次旋转，并按所述计算残差。\n\n情况 1（一般离子液体团簇，正常路径）：\n- 位置 (nm): $[\\,[0.0,\\,0.0,\\,0.0],\\,[0.4,\\,0.1,\\,-0.2],\\,[-0.3,\\,0.5,\\,0.2],\\,[0.2,\\,-0.4,\\,0.3],\\,[-0.5,\\,-0.1,\\,-0.4],\\,[0.1,\\,0.6,\\,-0.3]\\,]$\n- 电荷 (基本电荷单位): $[\\,1.0,\\,-1.0,\\,1.0,\\,-1.0,\\,1.0,\\,-1.0\\,]$\n- 截断半径 (nm): $0.8$\n- 旋转轴: $[\\,0.3,\\,0.7,\\,0.6\\,]$\n- 旋转角度 (弧度): $0.6$\n\n情况 2（共线邻居，结构简并）：\n- 位置 (nm): $[\\,[\\,-0.5,\\,0.0,\\,0.0],\\,[\\,0.0,\\,0.0,\\,0.0],\\,[\\,0.5,\\,0.0,\\,0.0]\\,]$\n- 电荷 (基本电荷单位): $[\\,1.0,\\,-1.0,\\,1.0\\,]$\n- 截断半径 (nm): $1.0$\n- 旋转轴: $[\\,0.0,\\,0.0,\\,1.0\\,]$\n- 旋转角度 (弧度): $\\pi/3$\n\n情况 3（由于截断半径非常小而没有邻居，边界情况）：\n- 位置 (nm): $[\\,[0.0,\\,0.0,\\,0.0],\\,[0.4,\\,0.1,\\,-0.2],\\,[-0.3,\\,0.5,\\,0.2],\\,[0.2,\\,-0.4,\\,0.3],\\,[-0.5,\\,-0.1,\\,-0.4],\\,[0.1,\\,0.6,\\,-0.3]\\,]$\n- 电荷 (基本电荷单位): $[\\,1.0,\\,-1.0,\\,1.0,\\,-1.0,\\,1.0,\\,-1.0\\,]$\n- 截断半径 (nm): $0.05$\n- 旋转轴: $[\\,0.2,\\,-0.4,\\,0.9\\,]$\n- 旋转角度 (弧度): $1.2$\n\n情况 4（零旋转角度，边界条件）：\n- 位置 (nm): $[\\,[0.2,\\,0.2,\\,0.2],\\,[\\,-0.2,\\,-0.2,\\,-0.2],\\,[\\,0.3,\\,-0.1,\\,0.4]\\,]$\n- 电荷 (基本电荷单位): $[\\,1.0,\\,-1.0,\\,1.0\\,]$\n- 截断半径 (nm): $0.5$\n- 旋转轴: $[\\,1.0,\\,0.0,\\,0.0\\,]$\n- 旋转角度 (弧度): $0.0$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，列表被方括号包围，每个测试用例贡献一个包含三个浮点数的列表，对应于 $[\\,\\text{scalar\\_error},\\,\\text{vector\\_error},\\,\\text{tensor\\_error}\\,]$。例如：$[[e_{s,1},e_{v,1},e_{T,1}],[e_{s,2},e_{v,2},e_{T,2}],[e_{s,3},e_{v,3},e_{T,3}],[e_{s,4},e_{v,4},e_{T,4}]]$。",
            "solution": "该问题是有效的。它在科学上基于 E(3) 等变深度学习的原理，特别是关于构建尊重欧几里得对称性的消息传递层。该问题是良构的，为获得唯一且可验证的解提供了所有必要的数据和定义。语言客观且正式。\n\n问题的核心是为离子图实现一个单一的消息传递层，并数值验证其旋转等变性。图的节点是离子，由其位置 $\\mathbf{r}_i$ 和电荷 $q_i$ 表征。边由距离截断 $r_{\\text{cut}}$ 定义。每个节点 $i$ 上的特征是旋转群 $\\mathrm{SO}(3)$ 的一个不可约表示，由一个标量 $s_i$（类型 $l=0$）、一个矢量 $\\mathbf{v}_i$（类型 $l=1$）和一个对称无迹二阶张量 $\\mathbf{T}_i$（类型 $l=2$）组成。\n\n在旋转 $\\mathbf{R} \\in \\mathrm{SO}(3)$ 下，这些特征必须按如下方式变换：\n- $s_i' = s_i$\n- $\\mathbf{v}_i' = \\mathbf{R}\\mathbf{v}_i$\n- $\\mathbf{T}_i' = \\mathbf{R}\\mathbf{T}_i\\mathbf{R}^{\\top}$\n\n通过从相对位置矢量 $\\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i$ 构建所有操作来保证平移不变性。通过确保所有组合几何信息（从 $\\mathbf{r}_{ij}$ 导出）与节点特征的操作在群论意义上是有效的张量积，来实现旋转等变性。\n\n该过程包括两个主要阶段：特征初始化和特征更新。\n\n**步骤 1：特征初始化**\n\n首先，为每个离子 $i$ 计算初始特征（$s_i^{(0)}, \\mathbf{v}_i^{(0)}, \\mathbf{T}_i^{(0)}$），方法是将其邻居 $j$（其中 $\\|\\mathbf{r}_{ij}\\| < r_{\\text{cut}}$）的贡献相加。这些初始特征由最基本的可用的等变数量构建：标量电荷 $q_j$ 和矢量单位方向矢量 $\\hat{\\mathbf{r}}_{ij} = \\mathbf{r}_{ij} / \\|\\mathbf{r}_{ij}\\|$。\n\n- **标量初始化 ($l=0$)：** 一个标量可以通过将其他标量相加形成。我们使用邻居的电荷 $q_j$。\n$$s_i^{(0)} = \\sum_{j \\in \\mathcal{N}(i)} q_j$$\n由于 $q_j$ 是一个标量，所以 $s_i^{(0)}$ 也是一个标量并且变换正确（即，是不变的）。\n\n- **矢量初始化 ($l=1$)：** 一个矢量可以通过将一个标量 ($q_j$) 乘以一个矢量 ($\\hat{\\mathbf{r}}_{ij}$) 形成。\n$$\\mathbf{v}_i^{(0)} = \\sum_{j \\in \\mathcal{N}(i)} q_j \\hat{\\mathbf{r}}_{ij}$$\n在旋转下，$\\hat{\\mathbf{r}}_{ij} \\rightarrow \\mathbf{R}\\hat{\\mathbf{r}}_{ij}$，所以 $\\mathbf{v}_i^{(0)} \\rightarrow \\mathbf{R}\\mathbf{v}_i^{(0)}$，这是矢量的正确变换。\n\n- **张量初始化 ($l=2$)：** 一个对称无迹二阶张量可以由单位矢量与其自身的外积 $\\hat{\\mathbf{r}}_{ij} \\hat{\\mathbf{r}}_{ij}^{\\top}$ 构建，然后进行投影。$\\hat{\\mathbf{r}}_{ij} \\hat{\\mathbf{r}}_{ij}^{\\top}$ 的对称无迹部分是 $\\hat{\\mathbf{r}}_{ij} \\hat{\\mathbf{r}}_{ij}^{\\top} - \\frac{1}{3}\\mathbf{I}$，因为 $\\mathrm{tr}(\\hat{\\mathbf{r}}_{ij} \\hat{\\mathbf{r}}_{ij}^{\\top}) = \\|\\hat{\\mathbf{r}}_{ij}\\|^2 = 1$。\n$$\\mathbf{T}_i^{(0)} = \\sum_{j \\in \\mathcal{N}(i)} q_j \\left( \\hat{\\mathbf{r}}_{ij} \\hat{\\mathbf{r}}_{ij}^{\\top} - \\frac{1}{3}\\mathbf{I} \\right)$$\n这种构造正确地变换为一个类型 $l=2$ 的张量。\n\n**步骤 2：特征更新**\n\n接下来，我们定义一个消息传递更新规则，以根据邻居节点的初始特征计算下一层特征（$s_i^{(1)}, \\mathbf{v}_i^{(1)}, \\mathbf{T}_i^{(1)}$）。每种特征类型的更新必须是所有项的总和，这些项都根据该特征的类型进行变换。这是通过在邻居节点 $j$ 的特征和从 $\\hat{\\mathbf{r}}_{ij}$ 导出的几何量之间形成有效的收缩（张量积）来实现的。为简单起见和演示目的，我们为每次更新选择一个或两个代表性的相互作用项。\n\n- **标量更新 ($l=0 \\leftarrow (l=0 \\otimes l=0) \\oplus (l=1 \\otimes l=1)$)：**\n一个标量可以由邻居的标量 $s_j^{(0)}$（一个平凡积）或两个矢量 $\\mathbf{v}_j^{(0)}$ 和 $\\hat{\\mathbf{r}}_{ij}$ 的点积形成。\n$$s_i^{(1)} = \\sum_{j \\in \\mathcal{N}(i)} \\left( s_j^{(0)} + \\mathbf{v}_j^{(0)} \\cdot \\hat{\\mathbf{r}}_{ij} \\right)$$\n\n- **矢量更新 ($l=1 \\leftarrow (l=0 \\otimes l=1) \\oplus (l=1 \\otimes l=0) \\oplus (l=2 \\otimes l=1)$)：**\n一个矢量可以通过将一个标量乘以一个矢量（例如 $s_j^{(0)}\\hat{\\mathbf{r}}_{ij}$）、一个矢量乘以一个标量（例如 $\\mathbf{v}_j^{(0)}$）或通过将一个张量与一个矢量收缩（例如 $\\mathbf{T}_j^{(0)}\\hat{\\mathbf{r}}_{ij}$）形成。\n$$\\mathbf{v}_i^{(1)} = \\sum_{j \\in \\mathcal{N}(i)} \\left( s_j^{(0)}\\hat{\\mathbf{r}}_{ij} + \\mathbf{v}_j^{(0)} + \\mathbf{T}_j^{(0)}\\hat{\\mathbf{r}}_{ij} \\right)$$\n\n- **张量更新 ($l=2 \\leftarrow (l=0 \\otimes l=2) \\oplus (l=1 \\otimes l=1)$)：**\n一个类型 $l=2$ 的张量可以由一个标量乘以一个张量（例如 $s_j^{(0)}(\\hat{\\mathbf{r}}_{ij}\\hat{\\mathbf{r}}_{ij}^\\top - \\frac{1}{3}\\mathbf{I})$）或由两个矢量的外积的对称无迹部分形成。\n$$\\mathbf{T}_i^{(1)} = \\sum_{j \\in \\mathcal{N}(i)} \\left( s_j^{(0)}\\left(\\hat{\\mathbf{r}}_{ij}\\hat{\\mathbf{r}}_{ij}^\\top - \\frac{1}{3}\\mathbf{I}\\right) + \\mathrm{STT}\\left(\\mathbf{v}_j^{(0)}\\hat{\\mathbf{r}}_{ij}^\\top + \\hat{\\mathbf{r}}_{ij}(\\mathbf{v}_j^{(0)})^\\top\\right) \\right)$$\n其中 $\\mathrm{STT}(\\mathbf{M}) = \\frac{1}{2}(\\mathbf{M} + \\mathbf{M}^{\\top}) - \\frac{\\mathrm{tr}(\\mathbf{M})}{3}\\mathbf{I}$ 是对称无迹投影算子。\n\n**步骤 3：数值验证**\n\n为了验证等变性，我们执行以下过程：\n1.  为原始离子位置计算更新后的特征 $\\{s_i^{(1)}, \\mathbf{v}_i^{(1)}, \\mathbf{T}_i^{(1)}\\}_{\\text{orig}}$。\n2.  从给定的轴和角度构建旋转矩阵 $\\mathbf{R}$。\n3.  将旋转应用于原始位置：$\\mathbf{r}_i' = \\mathbf{R}\\mathbf{r}_i$。\n4.  使用这些新位置重新计算更新后的特征 $\\{s_i^{(1)}, \\mathbf{v}_i^{(1)}, \\mathbf{T}_i^{(1)}\\}_{\\text{recomputed}}$。\n5.  另外，使用定义的变换规则转换原始结果：\n    - $s_{i, \\text{transformed}}^{(1)} = s_{i, \\text{orig}}^{(1)}$\n    - $\\mathbf{v}_{i, \\text{transformed}}^{(1)} = \\mathbf{R} \\mathbf{v}_{i, \\text{orig}}^{(1)}$\n    - $\\mathbf{T}_{i, \\text{transformed}}^{(1)} = \\mathbf{R} \\mathbf{T}_{i, \\text{orig}}^{(1)} \\mathbf{R}^{\\top}$\n6.  E(3)-等变属性要求重新计算的特征必须等于转换后的特征，即 $\\{h\\}_{\\text{recomputed}} = \\{h\\}_{\\text{transformed}}$。由于浮点运算，我们通过计算每种特征类型在所有离子上的最大差异来检查这一点。误差计算为标量的绝对差、矢量差异的欧几里得范数和张量差异的弗罗贝尼乌斯范数。\n\n提供的 Python 代码实现了这整个流程。`rotation_matrix_from_axis_angle` 函数使用罗德里格斯公式生成旋转矩阵 $\\mathbf{R}$。`equivariant_pipeline` 函数封装了特征初始化和更新步骤。主函数 `solve` 遍历测试用例，执行数值验证，并按规定格式化生成的误差值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef rotation_matrix_from_axis_angle(axis: np.ndarray, angle: float) -> np.ndarray:\n    \"\"\"\n    Computes a 3x3 rotation matrix from a rotation axis and angle using Rodrigues' formula.\n    \"\"\"\n    axis = np.asarray(axis)\n    if np.isclose(angle, 0.0):\n        return np.eye(3)\n    \n    # Normalize the rotation axis\n    norm = np.linalg.norm(axis)\n    if np.isclose(norm, 0.0):\n        # A zero axis with non-zero angle is ill-defined; return identity.\n        return np.eye(3)\n    axis = axis / norm\n    \n    # Skew-symmetric cross-product matrix\n    K = np.array([[0, -axis[2], axis[1]],\n                  [axis[2], 0, -axis[0]],\n                  [-axis[1], axis[0], 0]])\n    \n    I = np.eye(3)\n    # Rodrigues' rotation formula\n    R = I + np.sin(angle) * K + (1 - np.cos(angle)) * (K @ K)\n    \n    return R\n\ndef stt_projection(M: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the Symmetric Traceless Tensor (STT) projection of a 3x3 matrix.\n    STT(M) = 1/2(M + M^T) - tr(M)/3 * I\n    \"\"\"\n    return 0.5 * (M + M.T) - (np.trace(M) / 3.0) * np.eye(3)\n\ndef equivariant_pipeline(positions: np.ndarray, charges: np.ndarray, cutoff: float) -> tuple[np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"\n    Executes one layer of the E(3)-equivariant message passing architecture.\n    \"\"\"\n    num_atoms = positions.shape[0]\n    I = np.eye(3)\n    epsilon = 1e-9 # For numerical stability when normalizing vectors\n\n    # Step 1: Find neighbors for each atom\n    adj = []\n    for i in range(num_atoms):\n        neighbors = []\n        for j in range(num_atoms):\n            if i == j:\n                continue\n            dist = np.linalg.norm(positions[i] - positions[j])\n            if dist  cutoff:\n                neighbors.append(j)\n        adj.append(neighbors)\n\n    # Step 2: Initialize features (h_0)\n    s_0 = np.zeros(num_atoms)\n    v_0 = np.zeros((num_atoms, 3))\n    T_0 = np.zeros((num_atoms, 3, 3))\n\n    for i in range(num_atoms):\n        if not adj[i]: continue\n        for j in adj[i]:\n            r_ij = positions[j] - positions[i]\n            dist_ij = np.linalg.norm(r_ij)\n            hat_r_ij = r_ij / (dist_ij + epsilon)\n            \n            s_0[i] += charges[j]\n            v_0[i] += charges[j] * hat_r_ij\n            outer_prod = np.outer(hat_r_ij, hat_r_ij)\n            T_0[i] += charges[j] * (outer_prod - (1.0 / 3.0) * I)\n\n    # Step 3: Update features (h_1) by message passing\n    s_1 = np.zeros(num_atoms)\n    v_1 = np.zeros((num_atoms, 3))\n    T_1 = np.zeros((num_atoms, 3, 3))\n\n    for i in range(num_atoms):\n        if not adj[i]: continue\n        for j in adj[i]:\n            r_ij = positions[j] - positions[i]\n            dist_ij = np.linalg.norm(r_ij)\n            hat_r_ij = r_ij / (dist_ij + epsilon)\n\n            # Scalar update\n            s_1[i] += s_0[j] + np.dot(v_0[j], hat_r_ij)\n\n            # Vector update\n            v_1[i] += s_0[j] * hat_r_ij + v_0[j] + T_0[j] @ hat_r_ij\n\n            # Tensor update\n            term1_T = s_0[j] * (np.outer(hat_r_ij, hat_r_ij) - (1.0 / 3.0) * I)\n            \n            v_outer_r = np.outer(v_0[j], hat_r_ij)\n            M_vj_rij = v_outer_r + v_outer_r.T\n            term2_T = stt_projection(M_vj_rij) # Simplified from STT(v_j*r_ij_T + r_ij*v_j_T)\n            \n            T_1[i] += term1_T + term2_T\n\n    return s_1, v_1, T_1\n\ndef format_nested_list(data: list) -> str:\n    \"\"\"\n    Recursively formats a nested list into a string without spaces after commas.\n    \"\"\"\n    if isinstance(data, list):\n        return f\"[{','.join(format_nested_list(item) for item in data)}]\"\n    else:\n        return f\"{data:.15e}\" if isinstance(data, float) else str(data)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and verify equivariance.\n    \"\"\"\n    test_cases = [\n        {\n            \"positions\": [[0.0, 0.0, 0.0], [0.4, 0.1, -0.2], [-0.3, 0.5, 0.2], [0.2, -0.4, 0.3], [-0.5, -0.1, -0.4], [0.1, 0.6, -0.3]],\n            \"charges\": [1.0, -1.0, 1.0, -1.0, 1.0, -1.0],\n            \"cutoff\": 0.8,\n            \"rot_axis\": [0.3, 0.7, 0.6],\n            \"rot_angle\": 0.6\n        },\n        {\n            \"positions\": [[-0.5, 0.0, 0.0], [0.0, 0.0, 0.0], [0.5, 0.0, 0.0]],\n            \"charges\": [1.0, -1.0, 1.0],\n            \"cutoff\": 1.0,\n            \"rot_axis\": [0.0, 0.0, 1.0],\n            \"rot_angle\": np.pi / 3\n        },\n        {\n            \"positions\": [[0.0, 0.0, 0.0], [0.4, 0.1, -0.2], [-0.3, 0.5, 0.2], [0.2, -0.4, 0.3], [-0.5, -0.1, -0.4], [0.1, 0.6, -0.3]],\n            \"charges\": [1.0, -1.0, 1.0, -1.0, 1.0, -1.0],\n            \"cutoff\": 0.05,\n            \"rot_axis\": [0.2, -0.4, 0.9],\n            \"rot_angle\": 1.2\n        },\n        {\n            \"positions\": [[0.2, 0.2, 0.2], [-0.2, -0.2, -0.2], [0.3, -0.1, 0.4]],\n            \"charges\": [1.0, -1.0, 1.0],\n            \"cutoff\": 0.5,\n            \"rot_axis\": [1.0, 0.0, 0.0],\n            \"rot_angle\": 0.0\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        positions_orig = np.array(case[\"positions\"], dtype=float)\n        charges = np.array(case[\"charges\"], dtype=float)\n        cutoff = float(case[\"cutoff\"])\n        rot_axis = np.array(case[\"rot_axis\"], dtype=float)\n        rot_angle = float(case[\"rot_angle\"])\n\n        # 1. Compute updated features for the original configuration\n        s_orig, v_orig, T_orig = equivariant_pipeline(positions_orig, charges, cutoff)\n\n        # 2. Build rotation matrix and rotate positions\n        R = rotation_matrix_from_axis_angle(rot_axis, rot_angle)\n        positions_rot = (R @ positions_orig.T).T\n\n        # 3. Compute updated features for the rotated configuration\n        s_recomputed, v_recomputed, T_recomputed = equivariant_pipeline(positions_rot, charges, cutoff)\n\n        # 4. Transform the original results using the rotation matrix\n        s_transformed = s_orig\n        v_transformed = (R @ v_orig.T).T\n        T_transformed = np.zeros_like(T_orig)\n        for i in range(T_orig.shape[0]):\n            T_transformed[i] = R @ T_orig[i] @ R.T\n\n        # 5. Calculate maximum discrepancy (error)\n        num_atoms = positions_orig.shape[0]\n        if num_atoms == 0:\n            scalar_error, vector_error, tensor_error = 0.0, 0.0, 0.0\n        else:\n            scalar_error = np.max(np.abs(s_recomputed - s_transformed)) if s_orig.size > 0 else 0.0\n            vector_error = np.max(np.linalg.norm(v_recomputed - v_transformed, axis=1)) if v_orig.size > 0 else 0.0\n            tensor_error = np.max(np.linalg.norm(T_recomputed - T_transformed, axis=(1, 2))) if T_orig.size > 0 else 0.0\n\n        all_results.append([scalar_error, vector_error, tensor_error])\n    \n    # Custom formatter to match the output format specification precisely\n    def format_results(results_list):\n        outer_parts = []\n        for inner_list in results_list:\n            inner_parts = [f\"{x:.6e}\" for x in inner_list]\n            outer_parts.append(f\"[{','.join(inner_parts)}]\")\n        return f\"[{','.join(outer_parts)}]\"\n\n    print(format_results(all_results))\n\nsolve()\n```"
        },
        {
            "introduction": "仅有等变性是不够的，一个有效的原子间势还必须对应一个保守力场，即力必须是标量势能的负梯度。本练习  探讨了一种在训练过程中强制施加此物理约束的有效方法，即在损失函数中加入一个基于预测力旋度的惩罚项。通过这种方式，我们可以确保学到的模型在物理上是有意义的，并避免在分子动力学模拟中出现非物理的能量漂移。",
            "id": "4250465",
            "problem": "考虑一个用于平衡态电化学系统的机器学习原子间势（MLIP）的二维力场模型，其中预测的力是坐标的线性函数。设该模型由一个矩阵参数 $\\mathbf{W} \\in \\mathbb{R}^{2 \\times 2}$ 定义，对于 $\\mathbf{x} \\in \\mathbb{R}^2$，预测的力为 $\\hat{\\mathbf{F}}(\\mathbf{x}) = \\mathbf{W}\\mathbf{x}$。假设真实力是保守的，源于一个二次可微的标量势 $U(\\mathbf{x})$，因此 $\\mathbf{F}(\\mathbf{x}) = -\\nabla U(\\mathbf{x})$。在此设定下，保守场意味着在单连通域上的旋度为零。\n\n训练目标结合了力匹配项和旋度惩罚正则化器。设独立同分布样本 $\\{\\mathbf{x}_n, \\mathbf{F}_n\\}_{n=1}^N$ 上的力匹配损失为\n$$\n\\mathcal{L}_{\\mathrm{FM}}(\\mathbf{W}) = \\frac{1}{N}\\sum_{n=1}^{N} \\left\\| \\mathbf{W}\\mathbf{x}_n - \\mathbf{F}_n \\right\\|_2^2.\n$$\n设旋度惩罚为二维空间中标量旋度的均方值。对于线性模型，标量旋度在空间中是恒定的，等于\n$$\n\\omega = \\frac{\\partial \\hat{F}_y}{\\partial x} - \\frac{\\partial \\hat{F}_x}{\\partial y} = W_{21} - W_{12}.\n$$\n定义正则化器为\n$$\n\\mathcal{R}_{\\mathrm{curl}}(\\mathbf{W}) = \\omega^2 = \\left(W_{21} - W_{12}\\right)^2.\n$$\n总损失为\n$$\n\\mathcal{L}(\\mathbf{W}) = \\mathcal{L}_{\\mathrm{FM}}(\\mathbf{W}) + \\lambda \\,\\mathcal{R}_{\\mathrm{curl}}(\\mathbf{W}),\n$$\n其中正则化权重 $\\lambda \\ge 0$。\n\n你需要从基本原理出发，说明旋度惩罚如何强制实现保守性，并计算在学习率为 $\\eta  0$ 的梯度下降法下，它对训练动力学的影响。假设：\n- 输入的样本协方差是各向同性的，即对于某个 $\\sigma^2  0$，有 $\\boldsymbol{\\Sigma} = \\mathbb{E}[\\mathbf{x}\\mathbf{x}^\\top] = \\sigma^2 \\mathbf{I}_2$。\n- 真实力是保守的，其对称矩阵为 $\\mathbf{W}_{\\star}$，即 $\\mathbf{F}(\\mathbf{x}) = \\mathbf{W}_{\\star}\\mathbf{x}$ 且 $\\mathbf{W}_{\\star}^\\top = \\mathbf{W}_{\\star}$。\n\n引入 $\\mathbf{W}$ 的对称和反对称分量：\n$$\n\\mathbf{C} = \\frac{1}{2}\\left(\\mathbf{W} + \\mathbf{W}^\\top\\right), \\quad \\mathbf{S} = \\frac{1}{2}\\left(\\mathbf{W} - \\mathbf{W}^\\top\\right).\n$$\n注意，旋度仅取决于 $\\mathbf{S}$。推导在一个训练步下 $\\mathbf{S}$ 的梯度下降更新，并证明在各向同性协方差的假设下，反对称部分每步被乘以一个标量收缩因子\n$$\n\\phi_{\\lambda} = 1 - 2\\eta\\left(\\sigma^2 + 2\\lambda\\right)\n$$\n而在没有正则化器的情况下，它被乘以\n$$\n\\phi_{0} = 1 - 2\\eta \\sigma^2.\n$$\n设 $a_0$ 表示反对称分量的初始振幅（例如，在基 $\\{\\mathbf{e}_1,\\mathbf{e}_2\\}$ 中，$S_{12}$ 的非对角项）。经过 $K$ 步后，振幅按 $|a_K| = |a_0|\\,|\\phi|^K$ 的比例变化。\n\n你的任务是实现一个程序，对于给定的一小组参数集 $(\\eta, \\sigma^2, \\lambda, a_0, K)$，为每个测试用例计算比率\n$$\nr = \\frac{|\\phi_{\\lambda}|^K}{|\\phi_0|^K},\n$$\n该比率量化了有旋度惩罚与没有旋度惩罚时反对称分量的相对衰减（或增长）。该比率为无量纲。\n\n使用以下测试集，其设计旨在覆盖一般情况、边界情况、因固定学习率导致收缩较慢的边缘情况以及临界阻尼情况：\n- 测试 1：$(\\eta, \\sigma^2, \\lambda, a_0, K) = (0.05, 1.0, 0.5, 1.0, 10)$。\n- 测试 2：$(\\eta, \\sigma^2, \\lambda, a_0, K) = (0.05, 1.0, 0.0, 1.0, 10)$。\n- 测试 3：$(\\eta, \\sigma^2, \\lambda, a_0, K) = (0.45, 1.0, 0.2, 1.0, 10)$。\n- 测试 4：$(\\eta, \\sigma^2, \\lambda, a_0, K) = (0.4, 0.5, 0.375, 1.0, 1)$。\n\n你的程序必须：\n- 完全按照上述定义为每个测试用例计算 $r$。\n- 生成单行输出，其中包含按测试顺序排列的结果，形式为逗号分隔的列表，并用方括号括起，无空格，例如 `[r_1,r_2,r_3,r_4]`。",
            "solution": "经评估，问题陈述是有效的。它在科学上基于计算物理和机器学习的原理，问题设定良好，目标明确，且内部逻辑一致。\n\n任务是推导线性力场模型中权重矩阵 $\\mathbf{W}$ 反对称分量的梯度下降动力学，然后计算一个比率，以量化基于旋度的正则化器的效果。\n\n首先，我们建立理论框架。总损失函数由下式给出：\n$$\n\\mathcal{L}(\\mathbf{W}) = \\mathcal{L}_{\\mathrm{FM}}(\\mathbf{W}) + \\lambda \\,\\mathcal{R}_{\\mathrm{curl}}(\\mathbf{W})\n$$\n其中 $\\mathcal{L}_{\\mathrm{FM}}$ 是力匹配损失，$\\mathcal{R}_{\\mathrm{curl}}$ 是旋度正则化项。在大样本极限 ($N \\to \\infty$) 下，我们可以用数据分布上的期望替换 $\\mathcal{L}_{\\mathrm{FM}}$ 中的求和：\n$$\n\\mathcal{L}_{\\mathrm{FM}}(\\mathbf{W}) = \\mathbb{E}_{\\mathbf{x}} \\left[ \\left\\| \\mathbf{W}\\mathbf{x} - \\mathbf{F}(\\mathbf{x}) \\right\\|_2^2 \\right]\n$$\n鉴于真实力为 $\\mathbf{F}(\\mathbf{x}) = \\mathbf{W}_{\\star}\\mathbf{x}$，上式变为：\n$$\n\\mathcal{L}_{\\mathrm{FM}}(\\mathbf{W}) = \\mathbb{E}_{\\mathbf{x}} \\left[ \\left\\| (\\mathbf{W} - \\mathbf{W}_{\\star})\\mathbf{x} \\right\\|_2^2 \\right]\n$$\n令 $\\Delta\\mathbf{W} = \\mathbf{W} - \\mathbf{W}_{\\star}$。期望可以写作：\n$$\n\\mathbb{E}_{\\mathbf{x}} \\left[ \\mathbf{x}^\\top (\\Delta\\mathbf{W})^\\top (\\Delta\\mathbf{W}) \\mathbf{x} \\right]\n$$\n利用属性 $\\mathbb{E}[\\mathbf{z}^\\top \\mathbf{A} \\mathbf{z}] = \\text{Tr}(\\mathbf{A} \\mathbb{E}[\\mathbf{z}\\mathbf{z}^\\top])$，我们有：\n$$\n\\mathcal{L}_{\\mathrm{FM}}(\\mathbf{W}) = \\text{Tr}\\left( (\\Delta\\mathbf{W})^\\top (\\Delta\\mathbf{W}) \\mathbb{E}[\\mathbf{x}\\mathbf{x}^\\top] \\right)\n$$\n使用各向同性输入协方差的假设 $\\mathbb{E}[\\mathbf{x}\\mathbf{x}^\\top] = \\sigma^2 \\mathbf{I}_2$：\n$$\n\\mathcal{L}_{\\mathrm{FM}}(\\mathbf{W}) = \\text{Tr}\\left( (\\Delta\\mathbf{W})^\\top (\\Delta\\mathbf{W}) \\sigma^2 \\mathbf{I}_2 \\right) = \\sigma^2 \\text{Tr}\\left( (\\Delta\\mathbf{W})^\\top \\Delta\\mathbf{W} \\right) = \\sigma^2 \\|\\mathbf{W} - \\mathbf{W}_{\\star}\\|_F^2\n$$\n其中 $\\|\\cdot\\|_F$ 表示弗罗贝尼乌斯范数。\n\n接下来，我们将权重矩阵 $\\mathbf{W}$ 和误差 $\\Delta\\mathbf{W}$ 分解为对称和反对称分量。设 $\\mathbf{W} = \\mathbf{C} + \\mathbf{S}$ 和 $\\mathbf{W}_{\\star} = \\mathbf{C}_{\\star}$，其中 $\\mathbf{C} = \\frac{1}{2}(\\mathbf{W} + \\mathbf{W}^\\top)$ 和 $\\mathbf{C}_{\\star} = \\mathbf{W}_{\\star}$ 是对称的，而 $\\mathbf{S} = \\frac{1}{2}(\\mathbf{W} - \\mathbf{W}^\\top)$ 是反对称的。真实权重矩阵 $\\mathbf{W}_{\\star}$ 是对称的，因此其反对称部分为零。误差为 $\\Delta\\mathbf{W} = (\\mathbf{C} - \\mathbf{C}_{\\star}) + \\mathbf{S}$。\n矩阵的弗罗贝尼乌斯范数是其元素平方和的平方根。对于一个对称矩阵与一个反对称矩阵之和的矩阵，其弗罗贝尼乌斯范数的平方由于正交性而解耦：\n$$\n\\|\\Delta\\mathbf{W}\\|_F^2 = \\|\\mathbf{C} - \\mathbf{C}_{\\star}\\|_F^2 + \\|\\mathbf{S}\\|_F^2\n$$\n因此，力匹配损失为：\n$$\n\\mathcal{L}_{\\mathrm{FM}}(\\mathbf{W}) = \\sigma^2 \\left( \\|\\mathbf{C} - \\mathbf{C}_{\\star}\\|_F^2 + \\|\\mathbf{S}\\|_F^2 \\right)\n$$\n旋度正则化器为 $\\mathcal{R}_{\\mathrm{curl}}(\\mathbf{W}) = (W_{21} - W_{12})^2$。反对称部分 $\\mathbf{S}$ 的分量为 $S_{11}=S_{22}=0$, $S_{21} = \\frac{1}{2}(W_{21}-W_{12})$ 和 $S_{12} = \\frac{1}{2}(W_{12}-W_{21}) = -S_{21}$。\n正则化器可以用 $\\mathbf{S}$ 的分量表示：\n$$\n\\mathcal{R}_{\\mathrm{curl}}(\\mathbf{W}) = (2 S_{21})^2 = 4S_{21}^2 = 2 (S_{21}^2 + S_{12}^2) = 2 \\|\\mathbf{S}\\|_F^2\n$$\n因此，总损失函数在对称和反对称分量上是解耦的：\n$$\n\\mathcal{L}(\\mathbf{W}) = \\sigma^2 \\|\\mathbf{C} - \\mathbf{C}_{\\star}\\|_F^2 + \\sigma^2 \\|\\mathbf{S}\\|_F^2 + \\lambda (2 \\|\\mathbf{S}\\|_F^2)\n$$\n$$\n\\mathcal{L}(\\mathbf{W}) = \\sigma^2 \\|\\mathbf{C} - \\mathbf{C}_{\\star}\\|_F^2 + (\\sigma^2 + 2\\lambda) \\|\\mathbf{S}\\|_F^2\n$$\n为了进行梯度下降更新，需要计算损失相对于矩阵 $\\mathbf{W}$ 的梯度。一般求导法则是 $\\nabla_{\\mathbf{X}} \\|\\mathbf{X}-\\mathbf{A}\\|_F^2 = 2(\\mathbf{X}-\\mathbf{A})$ 和 $\\nabla_{\\mathbf{X}} \\|\\mathbf{S}_{\\mathbf{X}}\\|_F^2 = 2\\mathbf{S}_{\\mathbf{X}}$，其中 $\\mathbf{S}_{\\mathbf{X}}$ 是 $\\mathbf{X}$ 的反对称部分。应用这些法则：\n$$\n\\nabla_{\\mathbf{W}} \\mathcal{L}(\\mathbf{W}) = \\nabla_{\\mathbf{W}} \\left( \\sigma^2 \\|\\mathbf{W} - \\mathbf{W}_{\\star}\\|_F^2 \\right) + \\nabla_{\\mathbf{W}} \\left( 2\\lambda \\|\\mathbf{S}\\|_F^2 \\right)\n$$\n第一项得到 $2\\sigma^2(\\mathbf{W} - \\mathbf{W}_{\\star})$。正则化器的梯度是 $\\nabla_{\\mathbf{W}}(2\\lambda \\|\\mathbf{S}\\|_F^2) = 4\\lambda \\mathbf{S}$。将它们合并：\n$$\n\\nabla_{\\mathbf{W}} \\mathcal{L}(\\mathbf{W}) = 2\\sigma^2 (\\mathbf{W} - \\mathbf{W}_{\\star}) + 4\\lambda \\mathbf{S}\n$$\n代入 $\\mathbf{W} = \\mathbf{C} + \\mathbf{S}$ 和 $\\mathbf{W}_{\\star} = \\mathbf{C}_{\\star}$：\n$$\n\\nabla_{\\mathbf{W}} \\mathcal{L}(\\mathbf{W}) = 2\\sigma^2 ((\\mathbf{C} - \\mathbf{C}_{\\star}) + \\mathbf{S}) + 4\\lambda \\mathbf{S} = 2\\sigma^2 (\\mathbf{C} - \\mathbf{C}_{\\star}) + (2\\sigma^2 + 4\\lambda) \\mathbf{S}\n$$\n在第 $k$ 步，$\\mathbf{W}$ 的梯度下降更新规则是 $\\mathbf{W}_{k+1} = \\mathbf{W}_k - \\eta \\nabla_{\\mathbf{W}} \\mathcal{L}(\\mathbf{W}_k)$。反对称分量 $\\mathbf{S}$ 的更新是 $\\mathbf{W}$ 更新的反对称部分：\n$$\n\\mathbf{S}_{k+1} = \\text{antisymm}(\\mathbf{W}_{k+1}) = \\mathbf{S}_k - \\eta \\, \\text{antisymm}\\left( \\nabla_{\\mathbf{W}} \\mathcal{L}(\\mathbf{W}_k) \\right)\n$$\n梯度的对称部分是 $2\\sigma^2 (\\mathbf{C}_k - \\mathbf{C}_{\\star})$，其反对称部分是 $(2\\sigma^2 + 4\\lambda) \\mathbf{S}_k$。因此，$\\mathbf{S}$ 的更新为：\n$$\n\\mathbf{S}_{k+1} = \\mathbf{S}_k - \\eta (2\\sigma^2 + 4\\lambda) \\mathbf{S}_k = (1 - 2\\eta(\\sigma^2 + 2\\lambda)) \\mathbf{S}_k\n$$\n这表明，反对称分量 $\\mathbf{S}$ 在每一步都被乘以一个标量收缩因子 $\\phi_{\\lambda} = 1 - 2\\eta(\\sigma^2 + 2\\lambda)$。在没有正则化器的情况下（$\\lambda=0$），该因子为 $\\phi_0 = 1 - 2\\eta\\sigma^2$。前提是学习率 $\\eta$ 的选择要适当以确保 $|\\phi_{\\lambda}|  1$，正则化器会加速非保守分量 $\\mathbf{S}$ 向零衰减的速率。\n\n用于量化 $K$ 步后相对衰减的比率 $r$ 是：\n$$\nr = \\frac{|\\phi_{\\lambda}|^K}{|\\phi_0|^K} = \\left( \\frac{|\\phi_{\\lambda}|}{|\\phi_0|} \\right)^K\n$$\n将为提供的测试用例计算此比率。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the relative decay ratio of the antisymmetric component of a \n    weight matrix in a linear MLIP model, with and without a curl penalty.\n    \"\"\"\n    \n    # Test suite of parameters: (eta, sigma^2, lambda, a_0, K)\n    # a_0 is not needed for the calculation of the ratio r.\n    test_cases = [\n        # Test 1: General case\n        (0.05, 1.0, 0.5, 1.0, 10),\n        # Test 2: Boundary case (lambda = 0)\n        (0.05, 1.0, 0.0, 1.0, 10),\n        # Test 3: Edge case (slower contraction)\n        (0.45, 1.0, 0.2, 1.0, 10),\n        # Test 4: Critically damped case\n        (0.4, 0.5, 0.375, 1.0, 1),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        eta, sigma_sq, lam, a0, K = case\n        \n        # Contraction factor with the curl regularizer\n        # phi_lambda = 1 - 2*eta*(sigma^2 + 2*lambda)\n        phi_lambda = 1 - 2 * eta * (sigma_sq + 2 * lam)\n        \n        # Contraction factor without the regularizer (lambda = 0)\n        # phi_0 = 1 - 2*eta*sigma^2\n        phi_0 = 1 - 2 * eta * sigma_sq\n        \n        # The ratio r quantifies the relative decay (or growth) of the \n        # antisymmetric component after K steps.\n        # r = (|phi_lambda|^K) / (|phi_0|^K)\n        # Handle the case where phi_0 is zero to avoid division by zero.\n        # This case is not present in the test suite but is good practice.\n        if abs(phi_0) == 0:\n            # If phi_0 is 0, the unregularized component vanishes in one step.\n            # If phi_lambda is also 0, the ratio is indeterminate, but 1.0 is a\n            # reasonable interpretation (both vanish instantly).\n            # If phi_lambda is not 0, the regularized component does not vanish,\n            # so the relative decay is infinite. For the scope of this problem,\n            # we assume phi_0 is non-zero.\n            if abs(phi_lambda) == 0:\n                r = 1.0\n            else:\n                r = float('inf')\n        else:\n            r = (abs(phi_lambda)**K) / (abs(phi_0)**K)\n            \n        results.append(r)\n\n    # Format the final output as a comma-separated list in brackets,\n    # with no spaces.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "构建了符合物理规律的模型后，我们必须在实际应用中评估其性能。对于电化学系统，一个关键的考验是机器学习势能否准确捕捉能量如何随电极电势变化。本练习  要求您量化并比较一个简单的、与电势无关的纯机器学习模型和一个更复杂的混合量子力学/机器学习（QM/ML）模型在预测吸附能时的表现。这个练习突显了为精确模拟电化学现象而显式地包含长程静电效应的重要性。",
            "id": "4250456",
            "problem": "考虑一个在恒定电极电势下建模的、与电化学界面相互作用的吸附质。其吸附能由基本热力学差值定义：$$E_{\\mathrm{ads}}(U) = E_{\\mathrm{tot}}^{\\mathrm{slab+ads}}(U) - E_{\\mathrm{tot}}^{\\mathrm{slab}}(U) - \\mu_{\\mathrm{adsorbate}}(U),$$ 其中，$U$ 是电极电势，$E_{\\mathrm{tot}}^{\\mathrm{slab+ads}}(U)$ 是带有吸附质的平板的总能量，$E_{\\mathrm{tot}}^{\\mathrm{slab}}(U)$ 是洁净平板的总能量，$\\mu_{\\mathrm{adsorbate}}(U)$ 是吸附质的化学势，所有能量均以电子伏特 (eV) 表示。在恒定电势条件下，界面能量对电场的响应在主导阶上可以由一个线性项和一个二次极化项表示，从而得到一个参考吸附能模型：$$E_{\\mathrm{ref}}(U) = E_0 + \\alpha U + \\gamma U^2,$$ 其中，$E_0$ 是在 $U=0$ 时的基线吸附能（单位 eV），$\\alpha$（单位 eV/V）包含了与电荷转移和偶极矩变化相关的有效线性耦合，$\\gamma$（单位 eV/V$^2$）代表了来自界面环境的电容性或非线性极化贡献。\n\n一个忽略了显式静电耦合的纯机器学习 (ML) 界面势预测为：$$E_{\\mathrm{ML}}(U) = E_0 + b_{\\mathrm{ML}},$$ 其中 $b_{\\mathrm{ML}}$ 是一个以 eV 为单位的系统性偏差。一种量子力学/机器学习 (QM/ML) 嵌入模型，此处定义为量子力学/机器学习 (QM/ML) 嵌入，它将化学活性位点的量子力学区域与机器学习环境相结合，并捕捉一部分静电响应：$$E_{\\mathrm{QM/ML}}(U) = E_0 + b_{\\mathrm{QM/ML}} + s\\,\\alpha\\,U + t\\,\\gamma\\,U^2,$$ 其中 $b_{\\mathrm{QM/ML}}$ 是一个较小的系统性偏差（单位 eV），$s \\in [0,1]$ 是恢复的线性响应部分，而 $t \\in [0,1]$ 是恢复的二次极化部分。\n\n对于一组电极电势 $\\{U_i\\}_{i=1}^N$，定义预测误差为：$$\\varepsilon_{\\mathrm{ML},i} = E_{\\mathrm{ML}}(U_i) - E_{\\mathrm{ref}}(U_i), \\quad \\varepsilon_{\\mathrm{QM/ML},i} = E_{\\mathrm{QM/ML}}(U_i) - E_{\\mathrm{ref}}(U_i).$$ 一个模型的偏差（平均误差）为 $$\\mathrm{Bias} = \\frac{1}{N}\\sum_{i=1}^N \\varepsilon_i,$$ 均方根误差 (RMSE) 为 $$\\mathrm{RMSE} = \\sqrt{\\frac{1}{N}\\sum_{i=1}^N \\varepsilon_i^2},$$ 误差相对于电势的最小二乘斜率（用于量化系统性且依赖于电势的差异）为 $$m = \\frac{\\sum_{i=1}^N \\left(U_i - \\bar{U}\\right)\\left(\\varepsilon_i - \\bar{\\varepsilon}\\right)}{\\sum_{i=1}^N \\left(U_i - \\bar{U}\\right)^2},$$ 其中 $\\bar{U} = \\frac{1}{N}\\sum_{i=1}^N U_i$ 且 $\\bar{\\varepsilon} = \\frac{1}{N}\\sum_{i=1}^N \\varepsilon_i$。斜率 $m$ 的单位是 eV/V。\n\n实现一个程序，该程序针对下述每个测试用例，在指定的电势网格上构建 $E_{\\mathrm{ref}}(U)$、$E_{\\mathrm{ML}}(U)$ 和 $E_{\\mathrm{QM/ML}}(U)$，计算 ML 和 QM/ML 模型的误差度量 $\\mathrm{RMSE}$、$\\mathrm{Bias}$ 和 $m$，并输出结果。\n\n所有能量单位必须是 eV，电势 $U$ 的单位是伏特 (V)，斜率单位是 eV/V。最终输出必须是单行，包含一个用方括号括起来的逗号分隔列表，该列表由按顺序连接每个测试用例的序列 $$[\\mathrm{RMSE}_{\\mathrm{ML}}, \\mathrm{RMSE}_{\\mathrm{QM/ML}}, \\mathrm{Bias}_{\\mathrm{ML}}, \\mathrm{Bias}_{\\mathrm{QM/ML}}, m_{\\mathrm{ML}}, m_{\\mathrm{QM/ML}}],$$ 构成，其中每个浮点数四舍五入到 $6$ 位小数。\n\n使用以下测试套件：\n\n- 测试用例 $1$ (具有中等线性和二次响应的一般情况): $E_0 = -0.60$ eV, $\\alpha = 0.30$ eV/V, $\\gamma = 0.10$ eV/V$^2$, $b_{\\mathrm{ML}} = 0.04$ eV, $b_{\\mathrm{QM/ML}} = 0.01$ eV, $s = 0.80$, $t = 0.50$, 电势 $U \\in \\{-0.40, -0.20, 0.00, 0.20, 0.40\\}$ V。\n- 测试用例 $2$ (在零电荷电势附近，线性响应可忽略): $E_0 = -0.30$ eV, $\\alpha = 0.00$ eV/V, $\\gamma = 0.02$ eV/V$^2$, $b_{\\mathrm{ML}} = 0.03$ eV, $b_{\\mathrm{QM/ML}} = 0.015$ eV, $s = 0.80$, $t = 0.50$, 电势 $U \\in \\{-0.20, 0.00, 0.20\\}$ V。\n- 测试用例 $3$ (强线性和二次响应的高场情况): $E_0 = -0.85$ eV, $\\alpha = 0.50$ eV/V, $\\gamma = 0.20$ eV/V$^2$, $b_{\\mathrm{ML}} = 0.05$ eV, $b_{\\mathrm{QM/ML}} = 0.02$ eV, $s = 0.70$, $t = 0.30$, 电势 $U \\in \\{-0.60, -0.30, 0.00, 0.30, 0.60\\}$ V。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如 $[x_1,x_2,\\dots,x_M]$），该列表是所有测试用例结果按上述指定顺序连接而成的。每个数值必须四舍五入到 $6$ 位小数。",
            "solution": "该问题要求针对一个已定义的参考模型，计算两种不同的电化学界面吸附能计算模型——纯机器学习 (ML) 模型和混合量子力学/机器学习 (QM/ML) 模型——的若干误差度量。解决方案涉及对给定的一组参数和电极电势，系统地、逐步地应用所提供的数学公式。\n\n首先，我们为每个模型在特定电势 $U_i$ 下建立预测误差 $\\varepsilon_i$ 的解析表达式。误差定义为模型的预测值与参考能量 $E_{\\mathrm{ref}}(U_i)$ 之间的差值。\n\n吸附能的参考模型由电极电势 $U$ 的二次函数给出：\n$$E_{\\mathrm{ref}}(U) = E_0 + \\alpha U + \\gamma U^2$$\n其中 $E_0$ 是零电势下的能量，$\\alpha$ 是线性耦合系数，$\\gamma$ 是二次极化系数。\n\n纯 ML 模型提供一个与电势无关的预测：\n$$E_{\\mathrm{ML}}(U) = E_0 + b_{\\mathrm{ML}}$$\n其中 $b_{\\mathrm{ML}}$ 是一个系统性偏差。因此，ML 模型在电势 $U_i$ 下的预测误差 $\\varepsilon_{\\mathrm{ML},i}$ 为：\n$$\\varepsilon_{\\mathrm{ML},i} = E_{\\mathrm{ML}}(U_i) - E_{\\mathrm{ref}}(U_i) = (E_0 + b_{\\mathrm{ML}}) - (E_0 + \\alpha U_i + \\gamma U_i^2)$$\n简化此表达式，我们发现基线能量 $E_0$ 被消掉了：\n$$\\varepsilon_{\\mathrm{ML},i} = b_{\\mathrm{ML}} - \\alpha U_i - \\gamma U_i^2$$\n\nQM/ML 嵌入模型包含了对静电响应的部分描述：\n$$E_{\\mathrm{QM/ML}}(U) = E_0 + b_{\\mathrm{QM/ML}} + s\\,\\alpha\\,U + t\\,\\gamma\\,U^2$$\n其中 $b_{\\mathrm{QM/ML}}$ 是 QM/ML 的偏差，s 和 t 分别是恢复的线性响应和二次响应的比例。QM/ML 模型的预测误差 $\\varepsilon_{\\mathrm{QM/ML},i}$ 为：\n$$\\varepsilon_{\\mathrm{QM/ML},i} = E_{\\mathrm{QM/ML}}(U_i) - E_{\\mathrm{ref}}(U_i) = (E_0 + b_{\\mathrm{QM/ML}} + s\\alpha U_i + t\\gamma U_i^2) - (E_0 + \\alpha U_i + \\gamma U_i^2)$$\n同样，$E_0$ 被消掉。通过组合项，我们得到：\n$$\\varepsilon_{\\mathrm{QM/ML},i} = b_{\\mathrm{QM/ML}} - (1-s)\\alpha U_i - (1-t)\\gamma U_i^2$$\n\n有了在每个电势 $U_i$ 下误差的这些解析形式，我们就可以着手计算所需的统计度量：偏差 (Bias)、均方根误差 (RMSE) 和误差与电势的斜率 ($m$)。对于每个测试用例，我们都有一组 $N$ 个离散电势 $\\{U_i\\}_{i=1}^N$。我们首先计算相应的误差向量 $\\boldsymbol{\\varepsilon}_{\\mathrm{ML}} = \\{\\varepsilon_{\\mathrm{ML},i}\\}_{i=1}^N$ 和 $\\boldsymbol{\\varepsilon}_{\\mathrm{QM/ML}} = \\{\\varepsilon_{\\mathrm{QM/ML},i}\\}_{i=1}^N$。\n\n然后按如下方式计算这些度量：\n1.  **偏差 (Bias)**：这是平均误差 $\\bar{\\varepsilon}$。对于一个通用的误差向量 $\\boldsymbol{\\varepsilon}$，其计算方式为：\n    $$\\mathrm{Bias} = \\bar{\\varepsilon} = \\frac{1}{N}\\sum_{i=1}^N \\varepsilon_i$$\n\n2.  **均方根误差 (RMSE)**：该度量量化了误差的大小。它是误差平方均值的平方根：\n    $$\\mathrm{RMSE} = \\sqrt{\\frac{1}{N}\\sum_{i=1}^N \\varepsilon_i^2}$$\n\n3.  **误差与电势的斜率 ($m$)**：该度量衡量误差中系统性的、与电势相关的趋势。它被计算为 $\\varepsilon_i$ 对 $U_i$ 绘图的最佳拟合线的斜率：\n    $$m = \\frac{\\sum_{i=1}^N \\left(U_i - \\bar{U}\\right)\\left(\\varepsilon_i - \\bar{\\varepsilon}\\right)}{\\sum_{i=1}^N \\left(U_i - \\bar{U}\\right)^2}$$\n    其中 $\\bar{U}$ 是电势的平均值，$\\bar{U} = \\frac{1}{N}\\sum_{i=1}^N U_i$，而 $\\bar{\\varepsilon}$ 是误差的平均值（即偏差）。此计算等效于求 $U$ 和 $\\varepsilon$ 的协方差除以 $U$ 的方差。\n\n每个测试用例的算法步骤如下：\n1.  将电势集合 $\\{U_i\\}$ 定义为一个数值数组。\n2.  使用测试用例的参数（$\\alpha, \\gamma, b_{\\mathrm{ML}}, b_{\\mathrm{QM/ML}}, s, t$），利用推导出的简化表达式计算误差数组 $\\boldsymbol{\\varepsilon}_{\\mathrm{ML}}$ 和 $\\boldsymbol{\\varepsilon}_{\\mathrm{QM/ML}}$。\n3.  对于每个模型（ML 和 QM/ML），使用其误差数组和电势数组来计算三个度量：$\\mathrm{RMSE}$、$\\mathrm{Bias}$ 和 $m$。\n4.  按指定顺序存储六个计算值：$[\\mathrm{RMSE}_{\\mathrm{ML}}, \\mathrm{RMSE}_{\\mathrm{QM/ML}}, \\mathrm{Bias}_{\\mathrm{ML}}, \\mathrm{Bias}_{\\mathrm{QM/ML}}, m_{\\mathrm{ML}}, m_{\\mathrm{QM/ML}}]$。\n\n对所有测试用例重复此过程，并将生成的度量列表连接起来形成最终输出，每个值都格式化为六位小数。该实现使用 `numpy` 库进行高效的基于数组的计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates error metrics for ML and QM/ML models of adsorption energy\n    at an electrochemical interface for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1: general case\n        {\n            'params': {'alpha': 0.30, 'gamma': 0.10, 'b_ml': 0.04, 'b_qmml': 0.01, 's': 0.80, 't': 0.50},\n            'potentials': [-0.40, -0.20, 0.00, 0.20, 0.40]\n        },\n        # Test Case 2: near potential of zero charge\n        {\n            'params': {'alpha': 0.00, 'gamma': 0.02, 'b_ml': 0.03, 'b_qmml': 0.015, 's': 0.80, 't': 0.50},\n            'potentials': [-0.20, 0.00, 0.20]\n        },\n        # Test Case 3: high-field case\n        {\n            'params': {'alpha': 0.50, 'gamma': 0.20, 'b_ml': 0.05, 'b_qmml': 0.02, 's': 0.70, 't': 0.30},\n            'potentials': [-0.60, -0.30, 0.00, 0.30, 0.60]\n        },\n    ]\n\n    def calculate_metrics(potentials_arr, errors_arr):\n        \"\"\"\n        Computes RMSE, Bias, and slope m for a given set of errors and potentials.\n        \n        Args:\n            potentials_arr (np.ndarray): Array of electrode potentials U.\n            errors_arr (np.ndarray): Array of prediction errors.\n            \n        Returns:\n            tuple: A tuple containing (RMSE, Bias, m).\n        \"\"\"\n        # Bias (mean error)\n        bias = np.mean(errors_arr)\n        \n        # Root-Mean-Square Error\n        rmse = np.sqrt(np.mean(errors_arr**2))\n        \n        # Least-squares slope of error vs. potential\n        u_mean = np.mean(potentials_arr)\n        denominator = np.sum((potentials_arr - u_mean)**2)\n        \n        # Handle the case where all potentials are the same to avoid division by zero\n        if np.isclose(denominator, 0):\n            slope_m = 0.0\n        else:\n            # Note: err_mean is the same as bias\n            err_mean = np.mean(errors_arr)\n            numerator = np.sum((potentials_arr - u_mean) * (errors_arr - err_mean))\n            slope_m = numerator / denominator\n            \n        return rmse, bias, slope_m\n\n    all_results = []\n    for case in test_cases:\n        params = case['params']\n        U = np.array(case['potentials'])\n        \n        alpha, gamma = params['alpha'], params['gamma']\n        b_ml, b_qmml = params['b_ml'], params['b_qmml']\n        s, t = params['s'], params['t']\n\n        # Calculate error vectors for ML and QM/ML models\n        # eps_ml = b_ml - alpha*U - gamma*U^2\n        errors_ml = b_ml - alpha * U - gamma * U**2\n        \n        # eps_qmml = b_qmml - (1-s)*alpha*U - (1-t)*gamma*U^2\n        errors_qmml = b_qmml - (1 - s) * alpha * U - (1 - t) * gamma * U**2\n        \n        # Calculate metrics for the ML model\n        rmse_ml, bias_ml, m_ml = calculate_metrics(U, errors_ml)\n        \n        # Calculate metrics for the QM/ML model\n        rmse_qmml, bias_qmml, m_qmml = calculate_metrics(U, errors_qmml)\n        \n        # Extend the final list with results for the current case in the specified order\n        all_results.extend([rmse_ml, rmse_qmml, bias_ml, bias_qmml, m_ml, m_qmml])\n\n    # Format the final output string as a comma-separated list\n    # with each number rounded to 6 decimal places.\n    formatted_results = [f\"{x:.6f}\" for x in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}