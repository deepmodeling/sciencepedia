{
    "hands_on_practices": [
        {
            "introduction": "在启动大规模的伞形采样计算之前，设计一个高效的窗口分布方案至关重要。本练习将演示如何利用初步的平均力势（PMF）来非均匀地设置伞形窗口，从而将采样集中在高能量区域，并确保在整个反应坐标上获得一致的统计质量 。通过根据潜在的自由能形貌定制窗口位置和弹簧常数，您可以显著提高模拟的效率和准确性。",
            "id": "4244627",
            "problem": "给定一个一维反应坐标 $\\xi \\in [0,1]$，用于描述计算电化学中的界面电子转移。在一个均匀网格上，有一个初步的平均力势 (PMF)，以千焦耳/摩尔为单位提供了 $F(\\xi)$。目标是设计一个非均匀的伞形采样窗口方案，通过适当地选择窗口中心位置 $\\{\\xi_i\\}$ 和谐波力常数 $\\{k_i\\}$，在每个窗口采样时间固定且相等的情况下，使沿 $\\xi$ 的预期统计误差均衡。\n\n仅使用以下基本原理和定义来推导您的方法：\n\n- 平衡统计力学：沿反应坐标的无偏概率密度满足 $P(\\xi) \\propto \\exp\\left(-\\beta F(\\xi)\\right)$，其中 $\\beta = 1/(k_\\mathrm{B} T)$，$k_\\mathrm{B}$ 是玻尔兹曼常数，$T$ 是绝对温度。\n- 伞形采样对窗口 $i$ 使用的偏置势为 $U_i(\\xi) = \\frac{1}{2} k_i (\\xi - \\xi_i)^2$。\n- 窗口 $i$ 的有偏稳态分布正比于 $\\exp\\left(-\\beta \\left[F(\\xi) + U_i(\\xi)\\right]\\right)$。\n- 假设每个窗口的采样持续时间相等，并使用加权直方图分析方法 (WHAM) 或多态贝内特接受率 (MBAR) 进行相同的后处理，自由能估计中的局部统计误差与所有窗口在每个 $\\xi$ 附近共同贡献的局部有效采样密度成反比。您必须根据这些事实，在不使用任何预先指定的快捷公式的情况下，制定一个有原则的准则来平衡沿 $\\xi$ 的预期误差。\n\n设计一个算法，对于给定的初步 PMF $F(\\xi)$ 和一个指定的目标均方根采样宽度 $\\sigma$（在 $\\xi$ 的坐标单位中是无量纲的），计算：\n\n1. 一组在 $[0,1]$ 上的窗口中心 $\\{\\xi_i\\}_{i=1}^M$，其间距非均匀分布，以均衡沿 $\\xi$ 的预期统计误差。\n2. 一组谐波力常数 $\\{k_i\\}_{i=1}^M$，单位为千焦耳/摩尔/反应坐标平方，其选择应使每个中心附近的局部涨落宽度与 PMF 的曲率结合后，近似恒定并等于目标值。\n\n为了评估，在 $\\xi$ 值的网格上定义聚合偏置采样密度 $S(\\xi) = \\sum_{i=1}^M \\exp\\left(-\\beta \\left[F(\\xi) + \\frac{1}{2}k_i(\\xi - \\xi_i)^2\\right]\\right)$。使用该网格，计算 $S(\\xi)$ 在整个定义域上的变异系数，即标准差除以平均值。较小的变异系数表示预期统计误差更加均衡。\n\n常数和单位：\n- 使用 $T = 298$ 开尔文和 $k_\\mathrm{B} = 0.008314462618$ 千焦耳/摩尔/开尔文，因此 $k_\\mathrm{B}T$ 的单位是千焦耳/摩尔，$\\beta$ 的单位是 (千焦耳/摩尔) 的倒数。\n- PMF 值 $F(\\xi)$ 的单位是千焦耳/摩尔，力常数 $k_i$ 的单位必须是千焦耳/摩尔/反应坐标平方。坐标 $\\xi$ 是无量纲的。\n\n假设在 $[0,1]$ 上为 $\\xi$ 设置一个包含 $N$ 个点的均匀网格，间距为 $\\Delta \\xi = 1/(N-1)$，并使用离散的 $F(\\xi)$ 值通过有限差分估计 PMF 曲率 $F''(\\xi)$，以指导 $k_i$ 的选择。您的方法必须在边界处具有鲁棒性。\n\n测试套件：\n- 案例 1（“陡峭不对称双势阱”）：令 $N = 1001$，$M = 24$，且 $\\sigma = 0.05$。定义\n$$\nF_1(\\xi) = 12 \\exp\\left(-\\left(\\frac{\\xi - 0.5}{0.18}\\right)^2\\right) - 20 \\exp\\left(-\\left(\\frac{\\xi - 0.2}{0.06}\\right)^2\\right) - 30 \\exp\\left(-\\left(\\frac{\\xi - 0.8}{0.03}\\right)^2\\right).\n$$\n- 案例 2（“窄边界势阱和远端势垒”）：令 $N = 1001$，$M = 30$，且 $\\sigma = 0.04$。定义\n$$\nF_2(\\xi) = 8 \\exp\\left(-\\left(\\frac{\\xi - 0.85}{0.08}\\right)^2\\right) - 35 \\exp\\left(-\\left(\\frac{\\xi - 0.05}{0.02}\\right)^2\\right) + 3 \\xi.\n$$\n- 案例 3（“近乎平坦，带单个势垒和缓和势阱”）：令 $N = 1001$，$M = 16$，且 $\\sigma = 0.07$。定义\n$$\nF_3(\\xi) = 2 + 6 \\exp\\left(-\\left(\\frac{\\xi - 0.6}{0.15}\\right)^2\\right) - 8 \\exp\\left(-\\left(\\frac{\\xi - 0.3}{0.10}\\right)^2\\right).\n$$\n\n算法要求：\n- 在网格上使用中心有限差分（如适用）和在边界处使用单边有限差分来估计 $F''(\\xi)$。\n- 提出一种有原则的方法，该方法源于上述基本原理，用于在无偏概率低的区域放置更多的窗口中心，在无偏概率高的区域放置较少的窗口中心，并选择 $k_i$ 以使 $\\xi_i$ 附近的有效曲率产生的局部涨落宽度接近目标 $\\sigma$。\n- 通过构造确保 $k_i$ 为非负值，并对 $F''(\\xi)$ 中的大的正或负曲率具有鲁棒性。\n\n您的程序必须为每个测试案例计算方案 $(\\{\\xi_i\\},\\{k_i\\})$，在网格上评估 $S(\\xi)$，并将 $S(\\xi)$ 的变异系数作为浮点数输出。最终输出必须是一行文本，包含三个测试案例的三个变异系数，格式为方括号内以逗号分隔的列表，如 $[\\text{result}_1,\\text{result}_2,\\text{result}_3]$。\n\n输出的数字是无量纲的，必须以纯十进制浮点数打印。不应打印任何其他文本。",
            "solution": "该问题要求为一维反应坐标 $\\xi \\in [0,1]$ 设计一个最优的伞形采样窗口方案，该方案由窗口中心 $\\{\\xi_i\\}$ 和谐波力常数 $\\{k_i\\}$ 组成。目标是均衡整个坐标上的预期统计误差，这等同于实现一个最大程度均匀的聚合采样密度 $S(\\xi)$。推导过程从统计力学的第一性原理出发。\n\n首先，我们确定必要的物理常数和网格。热能为 $k_\\mathrm{B} T$，其中 $T = 298 \\, \\text{K}$，$k_\\mathrm{B} = 0.008314462618 \\, \\text{kJ} \\cdot \\text{mol}^{-1} \\cdot \\text{K}^{-1}$。逆温度为 $\\beta = 1/(k_\\mathrm{B} T)$。反应坐标 $\\xi$ 在一个包含 $N$ 个点的均匀网格 $\\{\\xi_j\\}_{j=0}^{N-1}$ 上被离散化，网格间距为 $\\Delta\\xi = 1/(N-1)$。\n\n解决方案分两个主要部分进行：首先确定力常数 $\\{k_i\\}$，然后确定窗口中心位置 $\\{\\xi_i\\}$。\n\n**1. 谐波力常数 $\\{k_i\\}$ 的确定**\n\n目标是选择每个力常数 $k_i$，使得系统在窗口 $i$ 内的局部涨落宽度与目标宽度 $\\sigma$ 相匹配。对于中心位于 $\\xi_i$、力常数为 $k_i$ 的窗口 $i$，其偏置势由下式给出：\n$$\nF_i^\\text{biased}(\\xi) = F(\\xi) + U_i(\\xi) = F(\\xi) + \\frac{1}{2} k_i (\\xi - \\xi_i)^2\n$$\n在此窗口的模拟中，概率分布为 $P_i(\\xi) \\propto \\exp(-\\beta F_i^\\text{biased}(\\xi))$。为了分析中心 $\\xi_i$ 周围的局部涨落，我们对无偏平均力势 (PMF) $F(\\xi)$ 在 $\\xi_i$ 附近进行泰勒展开：\n$$\nF(\\xi) \\approx F(\\xi_i) + F'(\\xi_i)(\\xi - \\xi_i) + \\frac{1}{2} F''(\\xi_i)(\\xi - \\xi_i)^2\n$$\n将此式代入偏置势表达式，得到 $\\xi_i$ 附近的有效势：\n$$\nF_i^\\text{biased}(\\xi) \\approx F(\\xi_i) + F'(\\xi_i)(\\xi - \\xi_i) + \\frac{1}{2} \\left( F''(\\xi_i) + k_i \\right) (\\xi - \\xi_i)^2\n$$\n这描述了一个谐波势，其有效力常数为 $k_i^\\text{eff} = F''(\\xi_i) + k_i$。相应的概率分布近似为高斯分布，$P_i(\\xi) \\propto \\exp\\left(-\\frac{\\beta k_i^\\text{eff}}{2}(\\xi - \\xi_i)^2\\right)$。这个高斯分布的方差是 $\\sigma_i^2 = 1/(\\beta k_i^\\text{eff})$。\n\n给定一个目标均方根采样宽度 $\\sigma$。通过将局部宽度 $\\sigma_i$ 与此目标 $\\sigma$ 相等，我们得到了有效力常数的一个条件：\n$$\n\\sigma^2 = \\frac{1}{\\beta (F''(\\xi_i) + k_i)}\n$$\n解出我们所求的伞形力常数 $k_i$：\n$$\nk_i = \\frac{1}{\\beta \\sigma^2} - F''(\\xi_i)\n$$\n此处，$F''(\\xi_i)$ 是无偏 PMF 在窗口中心 $\\xi_i$ 处的局部曲率。项 $1/(\\beta \\sigma^2)$ 代表偏置势的目标总曲率。为确保偏置势是约束性的，力常数 $k_i$ 必须为非负。这导出了选择 $k_i$ 的鲁棒规则：\n$$\nk_i = \\max\\left(0, \\frac{1}{\\beta \\sigma^2} - F''(\\xi_i)\\right)\n$$\n这个规则意味着，如果 PMF 的自然曲率 $F''(\\xi_i)$ 已经足够大，能将涨落限制在小于或等于 $\\sigma$ 的宽度内，则不需要额外的偏置力 ($k_i = 0$)。否则，选择 $k_i$ 来增强自然曲率以达到目标。曲率 $F''(\\xi)$ 是在离散网格上使用有限差分估计的。我们对内部点使用二阶中心差分，对边界点使用指定的二阶单边公式，以保持在整个定义域内的准确性。\n\n**2. 窗口中心位置 $\\{\\xi_i\\}$ 的确定**\n\n主要目标是使聚合采样密度 $S(\\xi)$ 在定义域 $\\xi \\in [0,1]$ 上尽可能均匀。密度 $S(\\xi)$ 是所有 $M$ 个窗口贡献的总和：\n$$\nS(\\xi) = \\sum_{i=1}^M \\exp\\left(-\\beta \\left[F(\\xi) + \\frac{1}{2}k_i(\\xi - \\xi_i)^2\\right]\\right) = e^{-\\beta F(\\xi)} \\sum_{i=1}^M e^{-\\frac{\\beta k_i}{2}(\\xi - \\xi_i)^2}\n$$\n目标是使 $S(\\xi) \\approx C$，其中 $C$ 是一个常数。这意味着：\n$$\n\\sum_{i=1}^M e^{-\\frac{\\beta k_i}{2}(\\xi - \\xi_i)^2} \\approx C \\cdot e^{\\beta F(\\xi)}\n$$\n如果窗口数量 $M$ 足够大，我们可以用一个关于连续窗口密度 $\\rho(\\xi')$ 的积分来近似这个和，其中 $\\xi'$ 是窗口中心坐标。在一个无穷小区间 $d\\xi'$ 内的窗口数量是 $\\rho(\\xi') d\\xi'$。这个和变为：\n$$\n\\int_0^1 \\rho(\\xi') e^{-\\frac{\\beta k(\\xi')}{2}(\\xi - \\xi')^2} d\\xi' \\approx C \\cdot e^{\\beta F(\\xi)}\n$$\n其中 $k(\\xi')$ 是位于 $\\xi'$ 处的窗口的力常数。高斯项 $e^{-\\frac{\\beta k(\\xi')}{2}(\\xi - \\xi')^2}$ 在 $\\xi' \\approx \\xi$ 处有尖峰。因此，该积分局部地探测了密度 $\\rho(\\xi')$。积分在 $\\xi$ 处的值近似正比于 $\\rho(\\xi)$。这导出了一个关键的见解：为了使左侧与 $e^{\\beta F(\\xi)}$ 成正比，窗口密度 $\\rho(\\xi)$ 的选择必须与 PMF 的玻尔兹曼因子成正比。\n$$\n\\rho(\\xi) \\propto e^{\\beta F(\\xi)}\n$$\n这一原则确保了在自由能高的区域（无偏概率低的区域）放置更多的窗口，以补偿系统避免这些区域的自然趋势。\n\n为了对离散数量的窗口 $M$ 以算法方式实现这一原则，我们使用累积分布函数 (CDF) 方法。我们在网格上定义一个权重函数 $\\omega(\\xi) = e^{\\beta F(\\xi)}$。\n1.  计算此权重函数的累积积分：$W(\\xi) = \\int_0^\\xi \\omega(x) dx$。这是通过在离散的网格值 $\\omega(\\xi_j)$ 上使用梯形法则进行数值计算的。\n2.  总积分为 $W_\\text{total} = W(1)$。我们将区间 $[0, W_\\text{total}]$ 分成 $M$ 个相等的子区间。目标累积权重选择在这些子区间的中点：$W_{\\text{target},i} = \\frac{i - 0.5}{M} W_\\text{total}$，对于 $i = 1, \\dots, M$。\n3.  然后通过反转累积函数来找到窗口中心 $\\{\\xi_i\\}$：$\\xi_i = W^{-1}(W_{\\text{target},i})$。这可以通过线性插值高效地完成，即找到与目标累积权重相对应的 $\\xi$ 值。\n\n**算法总结：**\n1.  **初始化：** 定义常数 $T$、$k_\\mathrm{B}$，并计算 $\\beta$。在 $[0,1]$ 上建立包含 $N$ 个点 $\\{\\xi_j\\}$ 的网格。对于给定的测试案例，在此网格上评估 PMF $F(\\xi)$ 以获得 $\\{F_j\\}$。\n2.  **PMF 曲率：** 使用二阶有限差分公式（内部点使用中心差分，边界点使用指定的单边差分）在网格上计算二阶导数 $F''(\\xi)$，得到 $\\{F''_j\\}$。\n3.  **窗口中心 $\\{\\xi_i\\}$：**\n    a. 在网格上计算权重函数：$\\omega_j = \\exp(\\beta F_j)$。\n    b. 数值计算累积积分 $W_j = \\int_0^{\\xi_j} \\omega(x) dx$。\n    c. 在累积积分的范围内生成 $M$ 个等间距的目标值 $\\{W_{\\text{target},i}\\}$。\n    d. 使用线性插值找到与 $\\{W_{\\text{target},i}\\}$ 对应的 $\\xi$ 坐标，从而确定 $M$ 个窗口中心 $\\{\\xi_i\\}$。\n4.  **力常数 $\\{k_i\\}$：**\n    a. 对于每个窗口中心 $\\xi_i$，通过插值网格值 $\\{F''_j\\}$ 来找到局部 PMF 曲率 $F''(\\xi_i)$。\n    b. 计算相应的力常数 $k_i = \\max(0, 1/(\\beta\\sigma^2) - F''(\\xi_i))$。\n5.  **评估：**\n    a. 使用确定的方案 $(\\{\\xi_i\\}, \\{k_i\\})$，在每个网格点 $\\xi_j$ 上计算聚合采样密度 $S(\\xi_j)$。\n    b. 计算所得数组 $\\{S_j\\}$ 的平均值和标准差。\n    c. 最终结果是变异系数，$\\text{CV} = \\text{std}(S) / \\text{mean}(S)$。\n\n这个有原则的两阶段过程确保了窗口的位置及其各自的约束力都被系统地选择，以平坦化整体采样剖面，从而优化伞形采样模拟的效率。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import cumulative_trapezoid\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the final results.\n    \"\"\"\n    \n    # Define physical constants\n    T = 298.0  # Kelvin\n    KB = 0.008314462618  # kJ/mol/K\n    BETA = 1.0 / (KB * T)\n\n    # Define test case PMF functions\n    def F1(xi):\n        return (12.0 * np.exp(-((xi - 0.5) / 0.18)**2) -\n                20.0 * np.exp(-((xi - 0.2) / 0.06)**2) -\n                30.0 * np.exp(-((xi - 0.8) / 0.03)**2))\n\n    def F2(xi):\n        return (8.0 * np.exp(-((xi - 0.85) / 0.08)**2) -\n                35.0 * np.exp(-((xi - 0.05) / 0.02)**2) +\n                3.0 * xi)\n\n    def F3(xi):\n        return (2.0 + 6.0 * np.exp(-((xi - 0.6) / 0.15)**2) -\n                8.0 * np.exp(-((xi - 0.3) / 0.10)**2))\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\"F_func\": F1, \"N\": 1001, \"M\": 24, \"sigma\": 0.05},\n        {\"F_func\": F2, \"N\": 1001, \"M\": 30, \"sigma\": 0.04},\n        {\"F_func\": F3, \"N\": 1001, \"M\": 16, \"sigma\": 0.07},\n    ]\n\n    results = []\n    for case in test_cases:\n        cv = compute_schedule_and_cv(\n            case[\"F_func\"], case[\"N\"], case[\"M\"], case[\"sigma\"], BETA\n        )\n        results.append(cv)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_f_double_prime(F, dx):\n    \"\"\"\n    Computes the second derivative of a function F on a grid using\n    second-order finite differences.\n    \"\"\"\n    N = len(F)\n    F_pp = np.zeros_like(F)\n    dx2 = dx * dx\n\n    # Interior points: central difference\n    F_pp[1:-1] = (F[2:] - 2*F[1:-1] + F[:-2]) / dx2\n\n    # Boundary points: one-sided differences\n    if N >= 4:\n        # Left boundary (forward difference)\n        F_pp[0] = (2*F[0] - 5*F[1] + 4*F[2] - F[3]) / dx2\n        # Right boundary (backward difference)\n        F_pp[-1] = (2*F[-1] - 5*F[-2] + 4*F[-3] - F[-4]) / dx2\n    elif N >= 3: # Fallback for smaller N\n        F_pp[0] = (F[2] - 2*F[1] + F[0]) / dx2\n        F_pp[-1] = (F[-1] - 2*F[-2] + F[-3]) / dx2\n    # For N3, boundaries are same as interior, which is empty. Handled.\n    \n    return F_pp\n\ndef compute_schedule_and_cv(F_func, N, M, sigma, beta):\n    \"\"\"\n    Computes the umbrella sampling schedule and the coefficient of variation\n    of the aggregate sampling density for a given case.\n    \"\"\"\n    # 1. Grid and PMF\n    xi_grid = np.linspace(0.0, 1.0, N)\n    delta_xi = 1.0 / (N - 1)\n    F_grid = F_func(xi_grid)\n\n    # 2. PMF Curvature\n    F_double_prime_grid = compute_f_double_prime(F_grid, delta_xi)\n\n    # 3. Place Window Centers {xi_i}\n    weights = np.exp(beta * F_grid)\n    cum_weights = cumulative_trapezoid(weights, x=xi_grid, initial=0.0)\n    \n    total_weight = cum_weights[-1]\n    target_weights = (np.arange(1, M + 1) - 0.5) / M * total_weight\n    \n    xi_centers = np.interp(target_weights, cum_weights, xi_grid)\n\n    # 4. Calculate Force Constants {k_i}\n    F_double_prime_at_centers = np.interp(xi_centers, xi_grid, F_double_prime_grid)\n    \n    target_curvature = 1.0 / (beta * sigma**2)\n    k_constants = target_curvature - F_double_prime_at_centers\n    k_constants = np.maximum(0.0, k_constants)\n\n    # 5. Evaluate Performance Metric\n    S_grid = np.zeros(N)\n    for i in range(M):\n        U_i = 0.5 * k_constants[i] * (xi_grid - xi_centers[i])**2\n        S_grid += np.exp(-beta * (F_grid + U_i))\n\n    mean_S = np.mean(S_grid)\n    std_S = np.std(S_grid)\n    \n    if mean_S == 0:\n        return 0.0 # Or handle as an error, but for this problem should not happen\n        \n    cv = std_S / mean_S\n    return cv\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        },
        {
            "introduction": "一个理想的模拟方案通常需要根据分子体系的复杂现实进行调整，例如电极界面附近的高摩擦力。本练习探讨了“粘滞延迟”这一实际挑战，即采样窗口内的缓慢弛豫可能会给结果带来偏差 。解决这个问题需要学习使用自相关分析等工具来诊断不充分的平衡过程，并实施自适应的模拟时间策略，以确保收集到的数据来自真实的平衡态。",
            "id": "4244601",
            "problem": "在一个锂阳离子在电解质中接近石墨电极的恒定电势分子动力学模型中，您希望沿着一个测量离子-电极接近距离的标量集体变量 $\\xi$ 求解其平均力势。您使用劲度系数为 $k$、中心位于目标 $\\{\\xi_i\\}$ 的谐波限制进行伞形采样，并从以速度 $v_{\\mathrm{SMD}}$ 拉动的引导分子动力学（SMD）轨迹中为每个窗口提供种子。由于电极附近的高界面摩擦和缓慢极化，界面附近的几个窗口表现出显著的粘性滞后：受限时间序列最初向局部受限平均值漂移，并且其松弛速度远慢于类体相窗口。您希望分配窗口特定的平衡和生产时间，以在固定的总计算成本下，既能消除SMD引起的非稳态偏差，又能实现所有窗口间均匀的统计质量。\n\n您可以获取每个窗口中受限集体变量 $\\xi(t)$ 和偏置力的时间序列。您可以计算稳态可观测量（stationary observables）的自相关函数（ACF）并估算积分自相关时间（IAT）。加权直方图分析方法（WHAM）将用于合并各个窗口。\n\n以下哪种策略正确地阐述了如何通过分配额外的采样时间给松弛缓慢的窗口来纠正SMD种子伞形采样中的粘性滞后，并基于第一性原理的自相关分析为该规定提供了理由？\n\nA. 对每个窗口 $i$，从松弛后段估算稳态可观测量（例如 $\\xi$ 或无偏力）的积分自相关时间 $\\tau_{\\mathrm{int},i}$；舍弃一个长度为 $c\\,\\tau_{\\mathrm{int},i}$（其中 $c$ 约为5-10）的初始平衡段，以消除SMD引起的瞬态；然后选择生产长度 $T_i$ 与 $\\tau_{\\mathrm{int},i}$ 成正比，以便每个窗口贡献相当数量的有效非相关样本，从而确保WHAM输入具有均匀的方差。其理由是：将谐波限制下的 $\\xi$ 建模为过阻尼朗之万过程，其松弛时间由摩擦与有效曲率之比决定；并且相关数据的样本均值方差与有效非相关样本数成反比，而后者由 $\\tau_{\\mathrm{int},i}$ 控制。\n\nB. 对每个窗口 $i$，估算 $\\tau_{\\mathrm{int},i}$ 并舍弃一个对所有窗口都相等的固定时长 $T_0$ 的初始段；然后选择 $T_i$ 与 $\\tau_{\\mathrm{int},i}$ 成反比，这样慢窗口就不会被过度代表。其理由是：去相关更快的数据在单位时间内产生更多样本，因此为了平衡贡献，应给予慢窗口更少的时间。\n\nC. 保持所有窗口的平衡和生产长度相同以维持统一性；依靠WHAM重加权自动消除由SMD种子和粘性滞后带来的任何偏差。其理由是：WHAM会考虑偏置势，因此能校正历史依赖性和非稳态性。\n\nD. 在慢窗口中增加谐波劲度系数 $k$ 以加速局部松弛，同时保持所有窗口的平衡和生产长度相同；其理由是：更强的限制将样本集中在目标 $\\xi_i$ 附近，这既能加速平衡，又能改善直方图重叠，从而无需在粘性区域使用更长的轨迹。",
            "solution": "该问题考察了如何处理伞形采样中因物理系统（如高粘滞性界面）的缓慢弛豫而导致的采样效率和准确性问题。正确的策略必须同时解决两个问题：1) 确保每个窗口的采样数据都来自平衡态；2) 在有限的总计算资源下，使所有窗口对最终PMF的贡献具有相似的统计质量。\n\n**1. 平衡阶段 (Equilibration)**\n\n伞形采样的核心分析工具，如WHAM或MBAR，都基于一个基本假设：输入的数据来自每个偏置势下的平衡（稳态）分布。使用引导分子动力学（SMD）等非平衡方法生成的初始构象，意味着每个窗口的模拟开始于一个远离其局部平衡态的状态。系统需要一定的时间来“忘记”这个初始状态并弛豫到其受限的平衡分布。这个时间就是平衡时间 $T_{\\mathrm{eq},i}$。\n\n在具有高摩擦（粘滞）的区域，动力学过程缓慢，因此弛豫时间也更长。积分自相关时间 $\\tau_{\\mathrm{int},i}$ 正是衡量系统“记忆”持续时间或相关性的尺度，因此它是局部弛豫时间尺度的一个极好指标。为了可靠地消除初始偏差，必须舍弃一段与该时间尺度成正比的初始轨迹。一个普遍接受的经验法则是，平衡时间应为积分自相关时间的数倍，即 $T_{\\mathrm{eq},i} = c \\cdot \\tau_{\\mathrm{int},i}$，其中 $c$ 通常取5到10。因此，对弛豫慢的窗口（$\\tau_{\\mathrm{int},i}$ 值大）必须分配更长的平衡时间。\n\n**2. 生产阶段 (Production)**\n\n在平衡之后，我们收集用于分析的生产数据。为了从这些数据中获得具有可比统计质量的估计，我们需要从每个窗口收集大致相同数量的“有效独立样本”。对于一个长度为 $T_{\\mathrm{prod},i}$ 的时间序列，其有效独立样本数 $N_{\\mathrm{eff},i}$ 由下式估算：$N_{\\mathrm{eff},i} \\approx T_{\\mathrm{prod},i} / (2\\tau_{\\mathrm{int},i})$。\n\n为了使所有窗口的统计质量均匀（即，对最终PMF的贡献具有相似的方差），我们需要使所有窗口的 $N_{\\mathrm{eff},i}$ 大致相等。\n$$ N_{\\mathrm{eff},1} \\approx N_{\\mathrm{eff},2} \\approx \\dots \\approx N_{\\mathrm{eff},M} $$\n$$ \\frac{T_{\\mathrm{prod},1}}{2\\tau_{\\mathrm{int},1}} \\approx \\frac{T_{\\mathrm{prod},2}}{2\\tau_{\\mathrm{int},2}} \\approx \\dots $$\n这直接导出结论：生产模拟的时长 $T_{\\mathrm{prod},i}$ 必须与该窗口的积分自相关时间 $\\tau_{\\mathrm{int},i}$ 成正比。\n$$ T_{\\mathrm{prod},i} \\propto \\tau_{\\mathrm{int},i} $$\n这意味着，弛豫慢的窗口不仅需要更长的平衡，还需要更长的生产运行，以收集足够数量的独立数据点，从而达到与其他窗口相当的统计精度。\n\n**选项分析：**\n\n*   **A**: 此选项完全符合上述推导。它主张平衡时间和生产时间都应与 $\\tau_{\\mathrm{int},i}$ 成正比，并给出了正确的物理理由：确保充分平衡和获得均匀数量的有效样本。这是处理此问题的标准最佳实践。\n*   **B**: 此选项建议生产时间与 $\\tau_{\\mathrm{int},i}$ 成反比，这与我们的目标背道而驰。这将导致在最需要采样的“困难”区域（慢窗口）采样最少，从而大大降低整体结果的质量。\n*   **C**: 此选项错误地假设WHAM可以纠正非平衡数据。WHAM是一个平衡态的后处理方法，它无法弥补因平衡不充分而引入的系统性偏差。使用相同的模拟时长会导致统计质量的严重不均匀。\n*   **D**: 增加力常数 $k$ 虽然可以加速沿 $\\xi$ 的局部振荡，但它并不能解决潜在的、可能与其他自由度相关的物理弛豫缓慢问题（例如溶剂重组）。此外，更强的 $k$ 会导致直方图变窄，这通常会恶化相邻窗口之间的重叠，对WHAM/MBAR分析不利。\n\n因此，选项A是唯一正确且有充分物理依据的策略。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "伞形采样分析的原始输出（通常是反应坐标上不同点的平均力）总是会受到统计噪声的影响。最后一个练习聚焦于一个关键的后处理步骤：如何对这些含噪的力进行积分，以重建一个平滑且具有物理意义的PMF 。您将实现一种称为吉洪诺夫正则化（Tikhonov regularization）的强大数值技术，该技术提供了一种有原则的方法来抑制噪声并防止在积分过程中误差累积。",
            "id": "4244617",
            "problem": "您的任务是设计并实现一种数值正则化方案，以便在计算电化学背景下，从沿反应坐标的含噪平均力数据中重建平均力势。在伞形采样中，平均力势是沿着选定的反应坐标定义的，并且从有偏窗口中估计出的平均力被用于通过数值积分来恢复平均力势。本任务分离出此恢复过程中的数值方面，并明确侧重于通过正则化来控制噪声传播。您编写的程序必须是一个独立的、自包含的 Python 脚本，该脚本执行下述任务，并按指定格式打印所需的最终输出。\n\n推导的基本依据：使用平均力势 $F(\\xi)$ 作为反应坐标 $\\xi$ 的函数的定义，以及导数 $dF/d\\xi$（平均力）与势 $F(\\xi)$ 之间的关系。所提供的数据是 $dF/d\\xi$ 的含噪估计值，目标是通过正则化积分获得 $F(\\xi)$ 的稳定估计，以控制统计误差的传播。引入通过惩罚曲率（二阶导数）来控制平滑度的概念。从以下经过充分检验的事实开始：在均匀网格上的离散化可以产生一阶和二阶导数的一致有限差分近似，并且 Tikhonov 型正则化通过在数据保真度与平滑度之间进行权衡来稳定反问题。不要依赖捷径公式或预先推导的矩阵正规方程：从离散导数和平滑度的基本定义出发，推导您的离散算子构造和优化问题。\n\n在区间 $\\xi \\in [0,L]$ 上为反应坐标 $\\xi$ 建立一个一维均匀网格，其中 $L = 1.0$ 纳米 (nm)。令 $N$ 表示网格点的数量，网格间距为 $h = L/(N-1)$。将潜在的“真实”平均力势 $F_{\\mathrm{true}}(\\xi)$ 定义为\n$$\nF_{\\mathrm{true}}(\\xi) = A \\sin\\left(\\frac{2\\pi \\xi}{L}\\right) + B \\xi^2,\n$$\n其中 $A = 5.0$ 千焦每摩尔 (kJ/mol)，$B = 2.0$ 千焦每摩尔每平方纳米 (kJ/mol/nm$^2$)。相应的“真实”平均力（导数）是\n$$\n\\frac{dF_{\\mathrm{true}}}{d\\xi}(\\xi) = A \\frac{2\\pi}{L} \\cos\\left(\\frac{2\\pi \\xi}{L}\\right) + 2B \\xi,\n$$\n单位为千焦每摩尔每纳米 (kJ/mol/nm)。\n\n通过向真实导数值添加独立的高斯噪声，在网格点 $\\xi_i$ 处生成合成的含噪平均力数据 $g_i$：\n$$\ng_i = \\left.\\frac{dF_{\\mathrm{true}}}{d\\xi}\\right|_{\\xi=\\xi_i} + \\varepsilon_i,\n$$\n其中 $\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$，$\\sigma$ 是指定的标准差，单位为千焦每摩尔每纳米 (kJ/mol/nm)。使用固定的伪随机生成器种子以确保可复现性。\n\n在网格上构造离散线性算子：\n- 一个一阶导数算子 $D$，作用于函数 $f$ 的网格值，以产生 $df/d\\xi$ 的近似值，使用标准的有限差分。对于内部点 $i$（$1 \\le i \\le N-2$），使用中心差分近似\n$$\n\\left(D f\\right)_i = \\frac{f_{i+1} - f_{i-1}}{2h}.\n$$\n对于边界点，使用单边差分：\n$$\n\\left(D f\\right)_0 = \\frac{f_{1} - f_{0}}{h}, \\quad \\left(D f\\right)_{N-1} = \\frac{f_{N-1} - f_{N-2}}{h}.\n$$\n- 一个二阶导数算子 $L$，通过离散二阶差分近似内部点的曲率\n$$\n\\left(L f\\right)_i = \\frac{f_{i+1} - 2 f_i + f_{i-1}}{h^2} \\quad \\text{for } 1 \\le i \\le N-2,\n$$\n且 $\\left(L f\\right)_0 = 0$，$\\left(L f\\right)_{N-1} = 0$，以避免在边界处施加曲率惩罚。\n\n通过 Tikhonov 正则化设计正则化积分：通过最小化一个由离散算子和含噪数据构建的二次目标函数来找到 $f$（$F(\\xi)$ 的一个估计）：\n$$\nJ(f) = \\left\\| D f - g \\right\\|_2^2 + \\alpha \\left\\| L f \\right\\|_2^2,\n$$\n其中 $g$ 是含噪导数样本的向量，而 $\\alpha  0$ 是控制平滑度的正则化参数。由于从导数进行积分会留下一个任意的加法常数，因此施加锚定条件\n$$\nf(\\xi_0) = 0,\n$$\n以固定左边界处的势能参考点。在优化中将此锚定实现为硬等式约束。\n\n您的程序必须：\n1. 构建网格以及真实势 $F_{\\mathrm{true}}(\\xi)$ 和其导数 $dF_{\\mathrm{true}}/d\\xi$。\n2. 使用指定的 $\\sigma$ 和种子生成含噪平均力数据 $g$。\n3. 构建离散算子 $D$ 和 $L$。\n4. 求解带约束的正则化最小二乘问题，以生成在 $f(\\xi_0)=0$ 约束下最小化 $J(f)$ 的 $f$。使用一种有原则的方法，例如 Karush–Kuhn–Tucker (KKT) 条件，来精确执行该等式约束。\n5. 计算恢复的 $f$ 与 $F_{\\mathrm{true}}$ 之间的均方根误差 (RMSE)，定义为\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{i=0}^{N-1} \\left(f_i - F_{\\mathrm{true}}(\\xi_i)\\right)^2},\n$$\n单位为千焦每摩尔 (kJ/mol)。\n\n明确的单位要求：所有势 $F(\\xi)$ 必须以千焦每摩尔 (kJ/mol) 为单位处理，反应坐标 $\\xi$ 以纳米 (nm) 为单位，导数 $dF/d\\xi$ 以千焦每摩尔每纳米 (kJ/mol/nm) 为单位。您的程序的最终数值输出是无单位的数字，但必须可解释为以千焦每摩尔 (kJ/mol) 为单位的 RMSE 值。不使用角度。不使用百分比。\n\n测试套件：您的程序必须为以下测试案例评估 RMSE，每个案例由一个元组 $(N,\\sigma,\\alpha,\\text{seed})$ 定义：\n- 案例 1：$(101, 0.5, 10^{-2}, 0)$，代表中等噪声和中等正则化的“理想路径”。\n- 案例 2：$(101, 0.05, 10^{-6}, 1)$，代表几乎没有正则化积分的低噪声场景。\n- 案例 3：$(101, 2.0, 10^{-1}, 2)$，代表具有更强正则化的高噪声场景。\n- 案例 4：$(21, 1.0, 5 \\times 10^{-2}, 3)$，代表具有中等噪声和正则化的粗糙网格。\n\n最终输出格式：您的程序应生成一行输出，其中包含四个测试案例的 RMSE 结果，形式为用方括号括起来的逗号分隔列表，顺序与上文列出的一致。例如，输出必须采用以下形式\n$$\n[\\mathrm{rmse}_1,\\mathrm{rmse}_2,\\mathrm{rmse}_3,\\mathrm{rmse}_4],\n$$\n其中每个 $\\mathrm{rmse}_i$ 是一个十进制数，对应于案例 $i$ 的 RMSE，单位为千焦每摩尔 (kJ/mol)。",
            "solution": "该问题是有效的。它提出了一个在计算化学中应用的数值分析领域内，定义良好且具有科学依据的任务。所有常数、函数形式和所需的数值方法都已明确指定，且问题是自包含的。\n\n问题的核心是从一组关于反应坐标 $\\xi$ 的导数的含噪测量值中，重建平均力势 (PMF)，记为 $F(\\xi)$。给定数据 $g$ 是真实平均力 $dF_{\\mathrm{true}}/d\\xi$ 的离散样本，受高斯噪声污染。任务是通过对含噪数据 $g$ 进行数值积分，找到真实势 $F_{\\mathrm{true}}$ 的一个稳定估计 $f$。一个简单的数值积分（例如，梯形法则）会累积并放大 $g$ 中的噪声，导致对 $f$ 的估计很差。因此，采用一种正则化方法来确保解是平滑的，这对于势能面来说是一个物理上合理的假设。\n\n指定的方法是 Tikhonov 正则化。我们寻求一个离散函数 $f$（表示为在网格点 $\\xi_i$ 上的值 $f_i$ 的向量），它能最小化以下目标泛函：\n$$\nJ(f) = \\left\\| D f - g \\right\\|_2^2 + \\alpha \\left\\| L f \\right\\|_2^2\n$$\n这里，$f$ 是在一个包含 $N$ 个点的均匀网格上未知势值的向量 $[f_0, f_1, \\dots, f_{N-1}]^T$。向量 $g = [g_0, g_1, \\dots, g_{N-1}]^T$ 包含含噪的平均力数据。算子 $D$ 是一阶导数 $d/d\\xi$ 的离散近似，而 $L$ 是二阶导数（曲率） $d^2/d\\xi^2$ 的离散近似。第一项 $\\|Df - g\\|_2^2$ 是数据保真项，它强制要求我们的解 $f$ 的导数应与观测数据 $g$ 相匹配。第二项 $\\|Lf\\|_2^2$ 是一个正则化（或惩罚）项，它惩罚具有高曲率的解，从而促进平滑性。正则化参数 $\\alpha  0$ 是一个标量，它控制着拟合数据与解的平滑度之间的权衡。\n\n由于微分和积分的定义允许相差一个任意的加法常数，因此所述问题是不适定的。为了获得唯一解，我们必须固定势在某一点的值。问题指定了一个锚定条件 $f(\\xi_0) = 0$，这对我们的离散解向量来说，转化为了硬约束 $f_0 = 0$。\n\n我们使用 $N$ 个点对区间 $[0, L]$ 上的反应坐标 $\\xi$ 进行离散化，均匀间距为 $h = L/(N-1)$。网格点为 $\\xi_i = i \\cdot h$，其中 $i = 0, 1, \\dots, N-1$。离散算子 $D$ 和 $L$ 根据所提供的有限差分公式构造为 $N \\times N$ 矩阵。\n\n一阶导数算子 $D$ 的构造如下：\n- 对于第一个点（索引 $i=0$），前向差分：$(Df)_0 = (f_1 - f_0)/h$。这对应于矩阵 $D$ 的第一行具有 $D_{0,0} = -1/h$，$D_{0,1} = 1/h$。\n- 对于内部点（$1 \\le i \\le N-2$），中心差分：$(Df)_i = (f_{i+1} - f_{i-1})/(2h)$。这意味着 $D$ 的第 $i$ 行具有 $D_{i, i-1} = -1/(2h)$ 和 $D_{i, i+1} = 1/(2h)$。\n- 对于最后一个点（索引 $i=N-1$），后向差分：$(Df)_{N-1} = (f_{N-1} - f_{N-2})/h$。$D$ 的最后一行具有 $D_{N-1, N-2} = -1/h$，$D_{N-1, N-1} = 1/h$。\n\n二阶导数算子 $L$ 的构造如下：\n- 对于内部点（$1 \\le i \\le N-2$）：$(Lf)_i = (f_{i+1} - 2f_i + f_{i-1})/h^2$。$L$ 的第 $i$ 行具有 $L_{i, i-1} = 1/h^2$，$L_{i, i} = -2/h^2$，以及 $L_{i, i+1} = 1/h^2$。\n- 对于边界点（$i=0$ 和 $i=N-1$），曲率设为零：$(Lf)_0=0$ 和 $(Lf)_{N-1}=0$。矩阵 $L$ 的第一行和最后一行完全为零。\n\n问题是在线性约束 $f_0=0$ 的条件下，最小化二次目标函数 $J(f)$。这是一个约束最小二乘问题。解决这个问题的一个原则性方法，正如对 KKT 条件的引用所建议的，是精确地施加约束。最直接的方法是通过变量消除。我们要求解的向量是 $f = [f_0, f_1, \\dots, f_{N-1}]^T$。给定约束 $f_0=0$，唯一的未知数位于大小为 $N-1$ 的子向量 $f' = [f_1, \\dots, f_{N-1}]^T$ 中。\n\n我们可以用未知向量 $f'$ 来表示完整的向量 $f$：$f_0=0$ 且对于 $i=1, \\dots, N-1$ 有 $f_i = f'_{i-1}$。这个关系使我们能够重写目标函数中的项。令 $D_{:, 1:}$ 为去掉第一列的矩阵 $D$（一个 $N \\times (N-1)$ 矩阵），对 $L_{:, 1:}$ 也做同样处理。那么 $Df = D_{:, 1:} f'$ 且 $Lf = L_{:, 1:} f'$。\n未知向量 $f'$ 的目标函数变为：\n$$\nJ(f') = \\left\\| D_{:, 1:} f' - g \\right\\|_2^2 + \\alpha \\left\\| L_{:, 1:} f' \\right\\|_2^2\n$$\n现在这是一个无约束的线性最小二乘问题。为了找到最小值，我们将 $J(f')$ 对 $f'$ 的梯度设为零。展开范数的平方项：\n$$\nJ(f') = (D_{:, 1:}f' - g)^T(D_{:, 1:}f' - g) + \\alpha (L_{:, 1:}f')^T(L_{:, 1:}f')\n$$\n$$\nJ(f') = f'^T D_{:, 1:}^T D_{:, 1:} f' - 2g^T D_{:, 1:} f' + g^T g + \\alpha f'^T L_{:, 1:}^T L_{:, 1:} f'\n$$\n对 $f'$ 的梯度是：\n$$\n\\nabla_{f'} J(f') = 2 D_{:, 1:}^T D_{:, 1:} f' - 2 D_{:, 1:}^T g + 2 \\alpha L_{:, 1:}^T L_{:, 1:} f'\n$$\n将梯度设为零，得到 $f'$ 的正规方程：\n$$\n(D_{:, 1:}^T D_{:, 1:} + \\alpha L_{:, 1:}^T L_{:, 1:}) f' = D_{:, 1:}^T g\n$$\n这是一个 $A x = b$ 形式的标准线性系统，其中 $A = D_{:, 1:}^T D_{:, 1:} + \\alpha L_{:, 1:}^T L_{:, 1:}$，$x = f'$，以及 $b = D_{:, 1:}^T g$。矩阵 $A$ 是一个 $(N-1) \\times (N-1)$ 的对称正定矩阵，保证了 $f'$ 有唯一解。\n\n算法流程如下：\n1. 对于每个测试案例 $(N, \\sigma, \\alpha, \\text{seed})$，设置网格 $\\xi$ 和常数 $L, A, B$。\n2. 在网格上计算真实势 $F_{\\mathrm{true}}$ 及其导数 $dF_{\\mathrm{true}}/d\\xi$。\n3. 通过向 $dF_{\\mathrm{true}}/d\\xi$ 添加标准差为 $\\sigma$ 的高斯噪声来生成含噪数据向量 $g$，使用指定的随机种子以保证可复现性。\n4. 根据有限差分方案构造 $N \\times N$ 矩阵 $D$ 和 $L$。\n5. 如上所述，构建简化的 $(N-1) \\times (N-1)$ 线性系统 $A f' = b$。\n6. 求解该系统以得到未知向量 $f'$。\n7. 通过在 $f'$ 前面加上 $f_0=0$ 来重建完整的解向量 $f$。\n8. 参考势 $F_{\\mathrm{true}}(\\xi)$ 的定义使得 $F_{\\mathrm{true}}(0)=0$，这与我们的锚定条件相匹配。因此，我们可以直接计算恢复的势 $f$ 与真实势 $F_{\\mathrm{true}}$ 之间的均方根误差 (RMSE)：\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{i=0}^{N-1} \\left(f_i - F_{\\mathrm{true}}(\\xi_i)\\right)^2}\n$$\n该过程提供了一种鲁棒且有原则的平均力势重建方法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(N, sigma, alpha, seed):\n    \"\"\"\n    Solves a single instance of the PMF reconstruction problem.\n    \n    Args:\n        N (int): Number of grid points.\n        sigma (float): Standard deviation of the Gaussian noise.\n        alpha (float): Tikhonov regularization parameter.\n        seed (int): Seed for the pseudorandom number generator.\n\n    Returns:\n        float: The root-mean-square error (RMSE) of the reconstruction.\n    \"\"\"\n    # 1. Construct the grid and the true potential and its derivative.\n    L_val = 1.0  # nm\n    A_val = 5.0  # kJ/mol\n    B_val = 2.0  # kJ/mol/nm^2\n\n    xi = np.linspace(0, L_val, N)\n    h = L_val / (N - 1)\n\n    F_true = A_val * np.sin(2 * np.pi * xi / L_val) + B_val * xi**2\n    dF_true_dxi = (A_val * (2 * np.pi / L_val) * np.cos(2 * np.pi * xi / L_val) + \n                   2 * B_val * xi)\n\n    # 2. Generate noisy mean force data.\n    rng = np.random.default_rng(seed)\n    noise = rng.normal(loc=0.0, scale=sigma, size=N)\n    g = dF_true_dxi + noise\n\n    # 3. Build the discrete operators D and L.\n    D = np.zeros((N, N))\n    # Forward difference at the start\n    D[0, 0] = -1.0 / h\n    D[0, 1] = 1.0 / h\n    # Central differences for interior\n    for i in range(1, N - 1):\n        D[i, i-1] = -1.0 / (2.0 * h)\n        D[i, i+1] = 1.0 / (2.0 * h)\n    # Backward difference at the end\n    D[N-1, N-2] = -1.0 / h\n    D[N-1, N-1] = 1.0 / h\n    \n    L_op = np.zeros((N, N))\n    # Standard 3-point stencil for second derivative for interior\n    for i in range(1, N - 1):\n        L_op[i, i-1] = 1.0 / h**2\n        L_op[i, i]   = -2.0 / h**2\n        L_op[i, i+1] = 1.0 / h**2\n    # Boundary curvature penalty is zero as specified.\n\n    # 4. Solve the constrained regularized least-squares problem.\n    # We enforce f[0] = 0 by solving for f_rest = f[1:].\n    # This transforms the problem to an unconstrained system for f_rest.\n    \n    # Take sub-matrices corresponding to f_rest\n    D_tilde = D[:, 1:]  # Shape (N, N-1)\n    L_tilde = L_op[:, 1:] # Shape (N, N-1)\n\n    # Form the normal equations for the unconstrained system: A * f_rest = b\n    # A has shape (N-1, N-1), b has shape (N-1,)\n    A_mat = D_tilde.T @ D_tilde + alpha * (L_tilde.T @ L_tilde)\n    b_vec = D_tilde.T @ g\n\n    # Solve the linear system\n    f_rest = np.linalg.solve(A_mat, b_vec)\n\n    # Reconstruct the full potential vector f, with f[0]=0\n    f = np.concatenate(([0.0], f_rest))\n\n    # 5. Compute the root-mean-square error (RMSE).\n    # The true potential is already anchored at F_true(0)=0.\n    rmse = np.sqrt(np.mean((f - F_true)**2))\n    \n    return rmse\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, sigma, alpha, seed)\n        (101, 0.5, 1e-2, 0),\n        (101, 0.05, 1e-6, 1),\n        (101, 2.0, 1e-1, 2),\n        (21, 1.0, 5e-2, 3),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, sigma, alpha, seed = case\n        result = solve_case(N, sigma, alpha, seed)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}