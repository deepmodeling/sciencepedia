{
    "hands_on_practices": [
        {
            "introduction": "贝叶斯推断的核心是利用数据证据（似然）来更新我们先前的知识（先验），从而形成新的认知（后验）。本练习提供了一个具体的、解析性的视角来审视这一过程。通过使用高斯分布的理想化假设，我们可以推导出后验分布的解析形式，这清晰地揭示了先验信息和数据信息是如何通过它们各自的精度（方差的倒数）进行加权组合的 。这个基础练习有助于我们直观地理解贝叶斯更新机制。",
            "id": "4237021",
            "problem": "考虑一个计算电化学推断任务，其中从电化学阻抗谱 (EIS) 推断出的电荷转移反应的交换电流密度 $i_{0}$ 被建模为对数正态分布。定义 $\\theta \\equiv \\ln i_{0}$。$\\theta$ 的先验是均值为 $\\mu_{0}$、方差为 $\\sigma_{0}^{2}$ 的高斯分布，即 $\\theta \\sim \\mathcal{N}(\\mu_{0}, \\sigma_{0}^{2})$，这等价于 $i_{0}$ 的对数正态先验。一个 EIS 数据集 $y$ 通过非线性最小二乘法拟合到一个机理阻抗模型，得到的 $\\theta$ 的对数似然在其最大似然估计 $\\hat{\\theta}_{L}$ 附近是局部高斯的，观测曲率为 $\\kappa>0$，这意味着二阶泰勒展开得到\n$$\n\\ln p(y \\mid \\theta) \\approx \\ln p(y \\mid \\hat{\\theta}_{L}) - \\frac{1}{2}\\,\\kappa\\,(\\theta - \\hat{\\theta}_{L})^{2}.\n$$\n使用贝叶斯定理和关于最大后验 (MAP) 估计量的拉普拉斯近似，推导后验 $p(\\theta \\mid y)$ 的高斯近似，并报告：\n- 近似后验均值（在拉普拉斯近似下等于 MAP），以及\n- 近似后验方差（在 MAP 处的对数后验的负二阶导数的倒数），\n作为关于 $\\mu_{0}$、$\\sigma_{0}^{2}$、$\\hat{\\theta}_{L}$ 和 $\\kappa$ 的闭式解析表达式。将您的最终答案表示为一个包含均值和方差的行矩阵，并按此顺序排列。无需进行数值计算。最终答案必须是单个无单位的解析表达式。",
            "solution": "该问题要求解后验概率分布 $p(\\theta \\mid y)$ 的高斯近似的均值和方差，其中 $\\theta \\equiv \\ln i_{0}$ 且 $i_{0}$ 是交换电流密度。推导将基于贝叶斯定理以及为先验和似然提供的高斯近似。\n\n验证问题陈述是第一个关键步骤。\n已知条件如下：\n1.  目标参数为 $\\theta \\equiv \\ln i_{0}$。\n2.  先验分布是高斯分布：$p(\\theta) = \\mathcal{N}(\\mu_{0}, \\sigma_{0}^{2})$。\n3.  对数似然函数由一个二次型近似：$\\ln p(y \\mid \\theta) \\approx \\ln p(y \\mid \\hat{\\theta}_{L}) - \\frac{1}{2}\\kappa(\\theta - \\hat{\\theta}_{L})^{2}$，其中 $\\kappa > 0$。\n\n该问题在科学上和数学上都是合理的。它描述了一个标准的贝叶斯推断任务，这是计算电化学中用于参数估计和不确定性量化的常见应用。对经过对数变换的参数使用高斯先验（这意味着对原始的严格正参数 $i_0$ 使用对数正态先验）是一种标准且有效的技术。对数似然的二次近似（拉普拉斯近似）是统计学中用于近似后验分布的一种成熟方法。所有术语都定义清晰，问题是自洽且适定的，容许唯一的解析解。因此，该问题被认为是有效的，并将构建一个解。\n\n根据贝叶斯定理，后验概率密度函数 $p(\\theta \\mid y)$ 正比于似然 $p(y \\mid \\theta)$ 和先验 $p(\\theta)$ 的乘积：\n$$\np(\\theta \\mid y) \\propto p(y \\mid \\theta) p(\\theta)\n$$\n处理后验的对数，即对数后验，会更方便：\n$$\n\\ln p(\\theta \\mid y) = \\ln p(y \\mid \\theta) + \\ln p(\\theta) + C\n$$\n其中 $C$ 是一个不依赖于 $\\theta$ 的比例常数。\n\n$\\theta$ 的先验分布是高斯分布，$\\theta \\sim \\mathcal{N}(\\mu_{0}, \\sigma_{0}^{2})$。其概率密度函数为：\n$$\np(\\theta) = \\frac{1}{\\sqrt{2\\pi\\sigma_{0}^{2}}} \\exp\\left(-\\frac{(\\theta - \\mu_{0})^{2}}{2\\sigma_{0}^{2}}\\right)\n$$\n因此，对数先验为：\n$$\n\\ln p(\\theta) = -\\frac{1}{2}\\ln(2\\pi\\sigma_{0}^{2}) - \\frac{(\\theta - \\mu_{0})^{2}}{2\\sigma_{0}^{2}} = C_{\\text{prior}} - \\frac{(\\theta - \\mu_{0})^{2}}{2\\sigma_{0}^{2}}\n$$\n其中 $C_{\\text{prior}}$ 是一个常数。\n\n问题提供了对数似然近似：\n$$\n\\ln p(y \\mid \\theta) \\approx \\ln p(y \\mid \\hat{\\theta}_{L}) - \\frac{1}{2}\\kappa(\\theta - \\hat{\\theta}_{L})^{2} = C_{\\text{like}} - \\frac{1}{2}\\kappa(\\theta - \\hat{\\theta}_{L})^{2}\n$$\n其中 $C_{\\text{like}}$ 是一个关于 $\\theta$ 的常数。\n\n综合这些，对数后验 $L(\\theta) = \\ln p(\\theta \\mid y)$ 为：\n$$\nL(\\theta) \\approx \\left(C_{\\text{prior}} + C_{\\text{like}}\\right) - \\frac{(\\theta - \\mu_{0})^{2}}{2\\sigma_{0}^{2}} - \\frac{\\kappa}{2}(\\theta - \\hat{\\theta}_{L})^{2}\n$$\n该表达式是 $\\theta$ 的一个二次函数。一个其对数是二次函数的概率分布是高斯分布。因此，得到的后验近似是高斯的，我们可以通过分析这个二次型来找到其均值和方差。\n\n拉普拉斯近似指出，后验可以用一个以最大后验 (MAP) 估计 $\\hat{\\theta}_{\\text{MAP}}$ 为中心的高斯分布来近似。MAP 估计是使 $L(\\theta)$ 最大化的 $\\theta$ 值。我们通过将 $L(\\theta)$ 关于 $\\theta$ 的一阶导数设为零来找到它：\n$$\n\\frac{dL}{d\\theta} = -\\frac{\\theta - \\mu_{0}}{\\sigma_{0}^{2}} - \\kappa(\\theta - \\hat{\\theta}_{L}) = 0\n$$\n求解 $\\theta$ 得到 MAP 估计，我们将其记为 $\\mu_{\\text{post}}$：\n$$\n-\\frac{\\mu_{\\text{post}}}{\\sigma_{0}^{2}} + \\frac{\\mu_{0}}{\\sigma_{0}^{2}} - \\kappa\\mu_{\\text{post}} + \\kappa\\hat{\\theta}_{L} = 0\n$$\n$$\n\\mu_{\\text{post}}\\left(\\frac{1}{\\sigma_{0}^{2}} + \\kappa\\right) = \\frac{\\mu_{0}}{\\sigma_{0}^{2}} + \\kappa\\hat{\\theta}_{L}\n$$\n$$\n\\mu_{\\text{post}} = \\frac{\\frac{\\mu_{0}}{\\sigma_{0}^{2}} + \\kappa\\hat{\\theta}_{L}}{\\frac{1}{\\sigma_{0}^{2}} + \\kappa}\n$$\n分子和分母同乘以 $\\sigma_{0}^{2}$，得到后验均值的最终表达式：\n$$\n\\mu_{\\text{post}} = \\frac{\\mu_{0} + \\kappa \\sigma_{0}^{2} \\hat{\\theta}_{L}}{1 + \\kappa \\sigma_{0}^{2}}\n$$\n这表明后验均值是先验均值 $\\mu_{0}$ 和最大似然估计 $\\hat{\\theta}_{L}$ 的精度加权平均值。先验精度是 $1/\\sigma_{0}^{2}$，似然精度（来自数据）是 $\\kappa$。\n\n高斯近似的方差 $\\sigma_{\\text{post}}^{2}$ 由在 MAP 估计处求值的对数后验的负二阶导数的倒数给出。让我们计算 $L(\\theta)$ 的二阶导数：\n$$\n\\frac{d^{2}L}{d\\theta^{2}} = \\frac{d}{d\\theta}\\left(-\\frac{\\theta - \\mu_{0}}{\\sigma_{0}^{2}} - \\kappa(\\theta - \\hat{\\theta}_{L})\\right) = -\\frac{1}{\\sigma_{0}^{2}} - \\kappa\n$$\n由于二阶导数是常数，我们无需在 $\\mu_{\\text{post}}$ 处对其求值。二阶导数的负值是后验精度：\n$$\n\\frac{1}{\\sigma_{\\text{post}}^{2}} = -\\frac{d^{2}L}{d\\theta^{2}} = \\frac{1}{\\sigma_{0}^{2}} + \\kappa\n$$\n这表明后验精度是先验精度和似然精度的和。后验方差 $\\sigma_{\\text{post}}^{2}$ 是这个量的倒数：\n$$\n\\sigma_{\\text{post}}^{2} = \\left(\\frac{1}{\\sigma_{0}^{2}} + \\kappa\\right)^{-1} = \\frac{1}{\\frac{1 + \\kappa\\sigma_{0}^{2}}{\\sigma_{0}^{2}}} = \\frac{\\sigma_{0}^{2}}{1 + \\kappa\\sigma_{0}^{2}}\n$$\n因此，近似后验分布为 $p(\\theta \\mid y) \\approx \\mathcal{N}(\\mu_{\\text{post}}, \\sigma_{\\text{post}}^{2})$。所求的量是后验均值 $\\mu_{\\text{post}}$ 和后验方差 $\\sigma_{\\text{post}}^{2}$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{\\mu_{0} + \\kappa \\sigma_{0}^{2} \\hat{\\theta}_{L}}{1 + \\kappa \\sigma_{0}^{2}} & \\frac{\\sigma_{0}^{2}}{1 + \\kappa \\sigma_{0}^{2}} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在后验近似的基础上，本实践将我们带入一个更具实用性的领域：实验设计。在电化学建模中，我们常常遇到这样的情况：当前的实验方案无法唯一地确定模型中的所有参数，这个问题被称为参数不可辨识性。这个练习将指导你使用灵敏度分析和费雪信息矩阵（Fisher Information Matrix）等工具，通过比较不同实验设计方案，来诊断并解决参数的不可辨识性问题 。这展示了如何运用贝叶斯不确定性量化的思想来指导和优化实验。",
            "id": "4237034",
            "problem": "在计算电化学中，考虑一个一维（1D）多孔电极-电解质系统，该系统处于稳态恒电流实验条件下。多孔结构中电解质的有效离子传导通过曲折度校正的欧姆定律和简单的扩散时间标度进行建模。设未知参数为多孔电极的曲折度 $\\tau$（无量纲）和体电解质电导率 $\\kappa$（单位为 $\\mathrm{S}/\\mathrm{m}$）。多孔介质中的有效离子电导率为 $\\kappa_{\\mathrm{eff}} = \\kappa / \\tau$。电解质厚度为 $L$（单位为 $\\mathrm{m}$），施加的电流密度为 $j$（单位为 $\\mathrm{A}/\\mathrm{m}^2$）。\n\n基本原理：\n- 一维欧姆定律意味着电解质两端的电势降 $V$（单位为 $\\mathrm{V}$）满足 $V = (L/\\kappa_{\\mathrm{eff}})\\, j$。使用 $\\kappa_{\\mathrm{eff}} = \\kappa/\\tau$，该式变为 $V = L\\, (\\tau/\\kappa)\\, j$。\n- 多孔介质中浓度弛豫的简单扩散时间标度意味着一个特征时间 $T$（单位为 $\\mathrm{s}$），其形式为 $T = (\\tau L^2)/D$，其中 $D$（单位为 $\\mathrm{m}^2/\\mathrm{s}$）是视为已知的有效电解质扩散系数。\n\n贝叶斯不确定性量化设置：\n- 定义变换后的参数 $s = \\ln \\tau$ 和 $r = \\ln \\kappa$。\n- 假设 $s$ 和 $r$ 服从独立的高斯先验分布：$s \\sim \\mathcal{N}(\\mu_s,\\sigma_s^2)$ 和 $r \\sim \\mathcal{N}(\\mu_r,\\sigma_r^2)$。\n- 测量值用独立的高斯噪声建模。对于电流密度为 $j_k$ 时的电压测量值 $V_k$，其似然函数为 $V_k \\sim \\mathcal{N}(f_V(s,r;j_k),\\sigma_V^2)$，其中 $f_V(s,r;j) = L\\, e^{s-r}\\, j$。对于扩散时间测量值 $T$，其似然函数为 $T \\sim \\mathcal{N}(f_T(s),\\sigma_T^2)$，其中 $f_T(s) = e^{s}\\, L^2/D$。\n\n局部灵敏度和可辨识性：\n- 白化灵敏度（雅可比）矩阵 $\\mathbf{J}_w$ 是通过将每个测量值关于 $(s,r)$ 的梯度（每个梯度除以其噪声标准差）堆叠而成的。对于电流密度为 $j_k$ 时的电压测量，梯度行为 $\\left[\\partial f_V/\\partial s,\\, \\partial f_V/\\partial r\\right]/\\sigma_V = \\left[f_V(s,r;j_k),\\, -f_V(s,r;j_k)\\right]/\\sigma_V$。对于扩散时间测量，梯度行为 $\\left[\\partial f_T/\\partial s,\\, \\partial f_T/\\partial r\\right]/\\sigma_T = \\left[f_T(s),\\, 0\\right]/\\sigma_T$。\n- 数据费雪信息矩阵为 $\\mathbf{F} = \\mathbf{J}_w^\\top \\mathbf{J}_w$。在最大后验概率点附近的后验分布的 Laplace 近似会加上先验精度，得到一个 Hessian 矩阵 $\\mathbf{H} = \\mathbf{F} + \\boldsymbol{\\Lambda}$，其中在 $(s,r)$ 坐标系中 $\\boldsymbol{\\Lambda} = \\mathrm{diag}(1/\\sigma_s^2, 1/\\sigma_r^2)$。近似的后验协方差为 $\\boldsymbol{\\Sigma} \\approx \\mathbf{H}^{-1}$。\n- 可辨识性可以通过以下方式进行探究：（i）$\\mathbf{J}_w$ 的最小奇异值，这是一个无量纲数，当其接近于零时表示秩亏；以及（ii）$s$ 和 $r$ 之间的后验相关系数，计算公式为 $\\rho = \\boldsymbol{\\Sigma}_{sr}/\\sqrt{\\boldsymbol{\\Sigma}_{ss}\\,\\boldsymbol{\\Sigma}_{rr}}$，该系数是无量纲的，在强不可辨识性下会趋近于 $\\pm 1$。\n\n任务：\n- 基于上述原理，在三种实验设计下建立 $(s,r)$ 的联合后验分布。对于所有设计，使用相同的真值参数 $\\tau_{\\mathrm{true}}$ 和 $\\kappa_{\\mathrm{true}}$，并在 $(s,r) = (\\ln \\tau_{\\mathrm{true}}, \\ln \\kappa_{\\mathrm{true}})$ 处构建灵敏度和后验度量。\n- 使用以下固定的物理常数和先验分布：\n  - $L = 1.0\\times 10^{-4}\\ \\mathrm{m}$, $D = 1.5\\times 10^{-9}\\ \\mathrm{m}^2/\\mathrm{s}$。\n  - $\\tau_{\\mathrm{true}} = 2.5$（无量纲），$\\kappa_{\\mathrm{true}} = 1.0\\ \\mathrm{S}/\\mathrm{m}$。\n  - $s$ 和 $r$ 的先验分布：$\\mu_s = \\ln(2.5)$，$\\mu_r = \\ln(1.0)$，标准差为 $\\sigma_s = 2.0$ 和 $\\sigma_r = 2.0$。\n- 实验设计（每个都是一个测试用例）：\n  1. 纯欧姆设计：在电流密度 $j = [100, 200, 300]\\ \\mathrm{A}/\\mathrm{m}^2$ 下进行三次电压测量，电压噪声标准差为 $\\sigma_V = 1.0\\times 10^{-3}\\ \\mathrm{V}$。无扩散时间测量。\n  2. 组合设计：与测试用例1相同的三次电压测量，$\\sigma_V = 1.0\\times 10^{-3}\\ \\mathrm{V}$，外加一次扩散时间测量，$\\sigma_T = 1.0\\times 10^{-2}\\ \\mathrm{s}$。\n  3. 弱时间信息设计：与测试用例1相同的电压测量，$\\sigma_V = 1.0\\times 10^{-3}\\ \\mathrm{V}$，外加一次具有较大噪声的扩散时间测量，$\\sigma_T = 1.0\\ \\mathrm{s}$。\n- 对每个测试用例，计算：\n  - $s$ 和 $r$ 之间的后验相关系数 $\\rho$（无量纲）。\n  - 白化灵敏度矩阵 $\\mathbf{J}_w$ 的最小奇异值 $s_{\\min}$（无量纲）。\n- 要求的最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3]”）。在此问题中，单行输出必须是“[\\rho_1,s_{\\min,1},\\rho_2,s_{\\min,2},\\rho_3,s_{\\min,3}]”，其中索引 1, 2, 3 对应于测试用例 1, 2 和 3。所有输出均为浮点数。此问题中不涉及角度和百分比。\n\n通过使用指定的单位确保科学真实性：$L$ 的单位为 $\\mathrm{m}$，$D$ 的单位为 $\\mathrm{m}^2/\\mathrm{s}$，$\\kappa$ 的单位为 $\\mathrm{S}/\\mathrm{m}$，$\\tau$ 为无量纲，$j$ 的单位为 $\\mathrm{A}/\\mathrm{m}^2$，$V$ 的单位为 $\\mathrm{V}$，$T$ 的单位为 $\\mathrm{s}$。计算出的度量 $\\rho$ 和 $s_{\\min}$ 是无量纲的浮点数。您的程序必须是自包含的，并且不得要求任何输入。它应完全按照规定汇总三个测试用例的结果。",
            "solution": "该问题被评估为有效。它在科学上是合理的、自包含的且适定的，提供了在计算电化学背景下执行所要求的参数可辨识性分析所需的所有物理常数、数学模型和实验条件。\n\n目标是在三种不同的实验设计下，量化一个简化的多孔电极模型的参数可辨识性。未知参数是曲折度 $\\tau$ 和体电解质电导率 $\\kappa$。我们使用它们的自然对数 $s = \\ln \\tau$ 和 $r = \\ln \\kappa$ 进行计算。分析以参数的真值为中心，这些真值与先验均值重合。我们将为每种设计计算两个度量：白化灵敏度矩阵 $\\mathbf{J}_w$ 的最小奇异值 $s_{\\min}$，以及从 Laplace 近似导出的 $s$ 和 $r$ 之间的后验相关系数 $\\rho$。\n\n首先，我们确定常数和真值。\n物理常数为：\n- 电解质厚度, $L = 1.0 \\times 10^{-4}\\ \\mathrm{m}$\n- 有效电解质扩散系数, $D = 1.5 \\times 10^{-9}\\ \\mathrm{m}^2/\\mathrm{s}$\n\n真值参数为：\n- 曲折度, $\\tau_{\\mathrm{true}} = 2.5$\n- 电导率, $\\kappa_{\\mathrm{true}} = 1.0\\ \\mathrm{S}/\\mathrm{m}$\n\n分析在相应的变换后参数点上进行：\n- $s_{\\mathrm{true}} = \\ln(\\tau_{\\mathrm{true}}) = \\ln(2.5)$\n- $r_{\\mathrm{true}} = \\ln(\\kappa_{\\mathrm{true}}) = \\ln(1.0) = 0$\n\n$s$ 和 $r$ 上的独立高斯先验由 $\\mu_s = \\ln(2.5)$，$\\mu_r = \\ln(1.0)$ 以及标准差 $\\sigma_s = 2.0$ 和 $\\sigma_r = 2.0$ 给出。先验精度矩阵 $\\boldsymbol{\\Lambda}$ 是一个对角矩阵，其对角线元素为 $1/\\sigma^2$，对于所有测试用例都是恒定的：\n$$\n\\boldsymbol{\\Lambda} = \\begin{pmatrix} 1/\\sigma_s^2 & 0 \\\\ 0 & 1/\\sigma_r^2 \\end{pmatrix} = \\begin{pmatrix} 1/2.0^2 & 0 \\\\ 0 & 1/2.0^2 \\end{pmatrix} = \\begin{pmatrix} 0.25 & 0 \\\\ 0 & 0.25 \\end{pmatrix}\n$$\n\n在真值点 $(s_{\\mathrm{true}}, r_{\\mathrm{true}})$ 处评估的模型函数为：\n- 电压模型：$f_V(s,r;j) = L e^{s-r} j$。在真值点处，$f_V(s_{\\mathrm{true}}, r_{\\mathrm{true}}; j) = L e^{s_{\\mathrm{true}}-r_{\\mathrm{true}}} j = L (\\tau_{\\mathrm{true}}/\\kappa_{\\mathrm{true}}) j = (1.0 \\times 10^{-4}\\ \\mathrm{m}) (2.5 / 1.0\\ \\mathrm{S}/\\mathrm{m}) j = (2.5 \\times 10^{-4})\\, j$。\n- 时间模型：$f_T(s) = (L^2/D) e^s$。在真值点处，$f_T(s_{\\mathrm{true}}) = (L^2/D) e^{s_{\\mathrm{true}}} = (L^2/D) \\tau_{\\mathrm{true}} = \\frac{(1.0 \\times 10^{-4}\\ \\mathrm{m})^2}{1.5 \\times 10^{-9}\\ \\mathrm{m}^2/\\mathrm{s}} \\times 2.5 = \\frac{1.0 \\times 10^{-8}}{1.5 \\times 10^{-9}} \\times 2.5\\ \\mathrm{s} = \\frac{10}{1.5} \\times 2.5\\ \\mathrm{s} = \\frac{50}{3}\\ \\mathrm{s}$。\n\n白化灵敏度矩阵 $\\mathbf{J}_w$ 的梯度行由模型函数导出：\n- 对于电流密度为 $j_k$ 的电压测量 $V_k$：\n$$\n\\mathbf{g}_{V,k} = \\frac{1}{\\sigma_V} \\left[ \\frac{\\partial f_V}{\\partial s}, \\frac{\\partial f_V}{\\partial r} \\right] = \\frac{1}{\\sigma_V} [f_V, -f_V]\n$$\n- 对于扩散时间测量 $T$：\n$$\n\\mathbf{g}_{T} = \\frac{1}{\\sigma_T} \\left[ \\frac{\\partial f_T}{\\partial s}, \\frac{\\partial f_T}{\\partial r} \\right] = \\frac{1}{\\sigma_T} [f_T, 0]\n$$\n\n我们现在对每个测试用例进行处理。\n\n**测试用例 1：纯欧姆设计**\n该设计涉及在 $j = [100, 200, 300]\\ \\mathrm{A}/\\mathrm{m}^2$ 下进行三次电压测量，$\\sigma_V = 1.0 \\times 10^{-3}\\ \\mathrm{V}$。无扩散时间测量。\n\n模型预测值 $f_V(j_k)$ 为：\n- $f_V(100) = (2.5 \\times 10^{-4}) \\times 100 = 0.025\\ \\mathrm{V}$\n- $f_V(200) = (2.5 \\times 10^{-4}) \\times 200 = 0.050\\ \\mathrm{V}$\n- $f_V(300) = (2.5 \\times 10^{-4}) \\times 300 = 0.075\\ \\mathrm{V}$\n\n白化灵敏度矩阵 $\\mathbf{J}_w$ 的行为：\n- $\\mathbf{g}_{V,1} = \\frac{1}{1.0 \\times 10^{-3}} [0.025, -0.025] = [25, -25]$\n- $\\mathbf{g}_{V,2} = \\frac{1}{1.0 \\times 10^{-3}} [0.050, -0.050] = [50, -50]$\n- $\\mathbf{g}_{V,3} = \\frac{1}{1.0 \\times 10^{-3}} [0.075, -0.075] = [75, -75]$\n\n因此，灵敏度矩阵为：\n$$\n\\mathbf{J}_{w,1} = \\begin{pmatrix} 25 & -25 \\\\ 50 & -50 \\\\ 75 & -75 \\end{pmatrix}\n$$\n$\\mathbf{J}_{w,1}$ 的列是线性相关的，这意味着该矩阵是秩亏的（秩为1）。因此，其最小奇异值为 $s_{\\min,1} = 0$。这表明仅从电压数据来看，参数 $s$ 和 $r$ 是不可辨识的，因为它们仅通过组合 $s-r$ 影响测量结果。\n\n数据费雪信息矩阵（FIM）为 $\\mathbf{F}_1 = \\mathbf{J}_{w,1}^\\top \\mathbf{J}_{w,1}$：\n$$\n\\mathbf{F}_1 = \\begin{pmatrix} 25 & 50 & 75 \\\\ -25 & -50 & -75 \\end{pmatrix} \\begin{pmatrix} 25 & -25 \\\\ 50 & -50 \\\\ 75 & -75 \\end{pmatrix} = \\begin{pmatrix} 8750 & -8750 \\\\ -8750 & 8750 \\end{pmatrix}\n$$\nHessian 矩阵为 $\\mathbf{H}_1 = \\mathbf{F}_1 + \\boldsymbol{\\Lambda}$：\n$$\n\\mathbf{H}_1 = \\begin{pmatrix} 8750 & -8750 \\\\ -8750 & 8750 \\end{pmatrix} + \\begin{pmatrix} 0.25 & 0 \\\\ 0 & 0.25 \\end{pmatrix} = \\begin{pmatrix} 8750.25 & -8750 \\\\ -8750 & 8750.25 \\end{pmatrix}\n$$\n后验协方差为 $\\boldsymbol{\\Sigma}_1 = \\mathbf{H}_1^{-1}$：\n$$\n\\boldsymbol{\\Sigma}_1 = \\frac{1}{8750.25^2 - (-8750)^2} \\begin{pmatrix} 8750.25 & 8750 \\\\ 8750 & 8750.25 \\end{pmatrix} \\approx \\frac{1}{4375.125} \\begin{pmatrix} 8750.25 & 8750 \\\\ 8750 & 8750.25 \\end{pmatrix}\n$$\n后验相关系数为 $\\rho_1 = \\boldsymbol{\\Sigma}_{1,sr} / \\sqrt{\\boldsymbol{\\Sigma}_{1,ss} \\boldsymbol{\\Sigma}_{1,rr}}$：\n$$\n\\rho_1 = \\frac{8750 / 4375.125}{\\sqrt{(8750.25 / 4375.125) \\times (8750.25 / 4375.125)}} = \\frac{8750}{8750.25} \\approx 0.999971\n$$\n这个值非常接近 1，证实了强的不可辨识性。它不完全等于 1 的唯一原因是先验分布的正则化效应。\n\n**测试用例 2：组合设计**\n该设计在用例1的测量基础上增加了一次扩散时间测量，$\\sigma_T = 1.0 \\times 10^{-2}\\ \\mathrm{s}$。\n时间的模型预测值为 $f_T = 50/3\\ \\mathrm{s}$。相应的梯度行为：\n$$\n\\mathbf{g}_{T} = \\frac{1}{1.0 \\times 10^{-2}} [50/3, 0] = [5000/3, 0] \\approx [1666.67, 0]\n$$\n新的灵敏度矩阵 $\\mathbf{J}_{w,2}$ 增加了一行：\n$$\n\\mathbf{J}_{w,2} = \\begin{pmatrix} 25 & -25 \\\\ 50 & -50 \\\\ 75 & -75 \\\\ 5000/3 & 0 \\end{pmatrix}\n$$\n由于新行打破了列之间的线性相关性，该矩阵现在是满秩的（秩为2）。最小奇异值 $s_{\\min,2}$ 将不为零。\nFIM 为 $\\mathbf{F}_2 = \\mathbf{J}_{w,2}^\\top \\mathbf{J}_{w,2} = \\mathbf{F}_1 + \\mathbf{g}_{T}^\\top \\mathbf{g}_{T}$：\n$$\n\\mathbf{F}_2 = \\begin{pmatrix} 8750 & -8750 \\\\ -8750 & 8750 \\end{pmatrix} + \\begin{pmatrix} (5000/3)^2 & 0 \\\\ 0 & 0 \\end{pmatrix} = \\begin{pmatrix} 8750 + 25000000/9 & -8750 \\\\ -8750 & 8750 \\end{pmatrix}\n$$\nHessian 矩阵为 $\\mathbf{H}_2 = \\mathbf{F}_2 + \\boldsymbol{\\Lambda}$：\n$$\n\\mathbf{H}_2 = \\begin{pmatrix} 8750.25 + 25000000/9 & -8750 \\\\ -8750 & 8750.25 \\end{pmatrix} \\approx \\begin{pmatrix} 2786528.03 & -8750 \\\\ -8750 & 8750.25 \\end{pmatrix}\n$$\n将 $\\mathbf{H}_2$ 求逆得到 $\\boldsymbol{\\Sigma}_2$，然后计算 $\\rho_2 = \\boldsymbol{\\Sigma}_{2,sr} / \\sqrt{\\boldsymbol{\\Sigma}_{2,ss} \\boldsymbol{\\Sigma}_{2,rr}}$ 将得到一个显著降低的相关性，因为时间测量提供了关于 $s$ 的独特信息。\n\n**测试用例 3：弱时间信息设计**\n此用例与用例2相同，但时间测量的噪声要大得多：$\\sigma_T = 1.0\\ \\mathrm{s}$。\n现在，时间测量的梯度行为：\n$$\n\\mathbf{g}_{T} = \\frac{1}{1.0} [50/3, 0] = [50/3, 0] \\approx [16.67, 0]\n$$\n灵敏度矩阵为：\n$$\n\\mathbf{J}_{w,3} = \\begin{pmatrix} 25 & -25 \\\\ 50 & -50 \\\\ 75 & -75 \\\\ 50/3 & 0 \\end{pmatrix}\n$$\n该矩阵仍然是满秩的，但新行的数量级远小于用例2，这意味着它为区分 $s$ 和 $r$ 提供了较少的信息。因此，我们预期 $s_{\\min,3}$ 会小于 $s_{\\min,2}$ 但大于 $s_{\\min,1}$。\nFIM 为 $\\mathbf{F}_3 = \\mathbf{F}_1 + \\mathbf{g}_{T}^\\top \\mathbf{g}_{T}$：\n$$\n\\mathbf{F}_3 = \\begin{pmatrix} 8750 & -8750 \\\\ -8750 & 8750 \\end{pmatrix} + \\begin{pmatrix} (50/3)^2 & 0 \\\\ 0 & 0 \\end{pmatrix} = \\begin{pmatrix} 8750 + 2500/9 & -8750 \\\\ -8750 & 8750 \\end{pmatrix}\n$$\nHessian 矩阵为 $\\mathbf{H}_3 = \\mathbf{F}_3 + \\boldsymbol{\\Lambda}$：\n$$\n\\mathbf{H}_3 = \\begin{pmatrix} 8750.25 + 2500/9 & -8750 \\\\ -8750 & 8750.25 \\end{pmatrix} \\approx \\begin{pmatrix} 9028.03 & -8750 \\\\ -8750 & 8750.25 \\end{pmatrix}\n$$\n由于附加的信息较弱，我们预期最终的相关系数 $\\rho_3$ 会低于 $\\rho_1$，但显著高于 $\\rho_2$。\n\n最终的数值将由实现程序计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes parameter identifiability metrics for a porous electrode model\n    under three different experimental designs.\n    \"\"\"\n    # Define fixed physical constants and ground-truth parameters\n    L = 1.0e-4  # m\n    D = 1.5e-9  # m^2/s\n    tau_true = 2.5  # dimensionless\n    kappa_true = 1.0  # S/m\n\n    # Define prior distribution parameters\n    sigma_s = 2.0\n    sigma_r = 2.0\n\n    # Test cases representing the three experimental designs\n    test_cases = [\n        {\n            \"name\": \"Ohmic-only\",\n            \"j_values\": np.array([100.0, 200.0, 300.0]),\n            \"sigma_V\": 1.0e-3,\n            \"sigma_T\": None  # No diffusion time measurement\n        },\n        {\n            \"name\": \"Combined\",\n            \"j_values\": np.array([100.0, 200.0, 300.0]),\n            \"sigma_V\": 1.0e-3,\n            \"sigma_T\": 1.0e-2\n        },\n        {\n            \"name\": \"Weak time-information\",\n            \"j_values\": np.array([100.0, 200.0, 300.0]),\n            \"sigma_V\": 1.0e-3,\n            \"sigma_T\": 1.0\n        }\n    ]\n\n    results = []\n\n    # Transformed ground-truth parameters\n    s_true = np.log(tau_true)\n    r_true = np.log(kappa_true)\n\n    # Prior precision matrix (same for all cases)\n    prior_precision = np.diag([1.0/sigma_s**2, 1.0/sigma_r**2])\n\n    for case in test_cases:\n        # --- Step 1: Construct the whitened sensitivity matrix J_w ---\n        \n        jw_rows = []\n\n        # Add rows for voltage measurements\n        if case[\"j_values\"] is not None and case[\"sigma_V\"] is not None:\n            sigma_V = case[\"sigma_V\"]\n            for j in case[\"j_values\"]:\n                # Model function for voltage\n                f_V = L * np.exp(s_true - r_true) * j\n                # Whitened gradient row: [dfV/ds, dfV/dr] / sigma_V\n                grad_row_v = np.array([f_V, -f_V]) / sigma_V\n                jw_rows.append(grad_row_v)\n\n        # Add row for diffusion time measurement\n        if case[\"sigma_T\"] is not None:\n            sigma_T = case[\"sigma_T\"]\n            # Model function for time\n            f_T = (L**2 / D) * np.exp(s_true)\n            # Whitened gradient row: [dfT/ds, dfT/dr] / sigma_T\n            grad_row_t = np.array([f_T, 0.0]) / sigma_T\n            jw_rows.append(grad_row_t)\n\n        J_w = np.array(jw_rows)\n\n        # --- Step 2: Compute the smallest singular value of J_w ---\n        \n        if J_w.shape[0]  J_w.shape[1]:\n            # This case won't happen here, but for completeness\n            # pad with zero rows to make it square or tall\n            zero_padding = np.zeros((J_w.shape[1] - J_w.shape[0], J_w.shape[1]))\n            J_w_svd = np.vstack((J_w, zero_padding))\n        else:\n            J_w_svd = J_w\n\n        singular_values = np.linalg.svd(J_w_svd, compute_uv=False)\n        s_min = np.min(singular_values)\n\n        # --- Step 3: Compute the posterior correlation coefficient rho ---\n\n        # Data Fisher Information Matrix\n        F = J_w.T @ J_w\n        \n        # Hessian of the negative log-posterior\n        H = F + prior_precision\n\n        # Posterior covariance matrix (inverse of Hessian)\n        Sigma = np.linalg.inv(H)\n\n        Sigma_ss = Sigma[0, 0]\n        Sigma_rr = Sigma[1, 1]\n        Sigma_sr = Sigma[0, 1]\n        \n        # Posterior correlation coefficient\n        rho = Sigma_sr / np.sqrt(Sigma_ss * Sigma_rr)\n\n        results.extend([rho, s_min])\n    \n    # Format and print the final output string\n    print(f\"[{','.join(f'{x:.8f}' for x in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "前面的练习处理的是行为良好或可以解析处理的后验分布，但现实世界的问题常常呈现出具有多个峰值的复杂后验分布（即多模态性）。当多个不同的模型或参数组合都能很好地解释同一组数据时，就会出现这种情况。本高级实践通过实现并行回火马尔可夫链蒙特卡洛（Parallel Tempering MCMC）算法来应对这一挑战 。该算法能有效地探索多模态分布，防止采样器陷入单个局部最优解，这对于稳健的模型选择和不确定性量化至关重要。",
            "id": "4237115",
            "problem": "给定一个由等效电路生成的合成电化学阻抗谱（EIS）数据集。目标是实现用于贝叶斯推断的并行回火马尔可夫链蒙特卡洛（MCMC）算法，以量化模型参数和离散模型拓扑指数的不确定性。由于存在相互竞争的电路拓扑（它们都能对同一EIS数据提供合理的解释），后验分布呈现多峰性。您必须通过计算冷链中的拓扑切换事件数量，来证明不同温度的链之间的交换（swap）移动如何改善对多峰后验分布的探索。\n\n从以下基础开始：\n- 贝叶斯定理：对于数据 $D$、参数 $\\theta$ 和模型指数 $m$，后验分布满足 $p(\\theta,m \\mid D) \\propto p(D \\mid \\theta,m) p(\\theta \\mid m) p(m)$。\n- 对于电化学阻抗谱（EIS），频域中的阻抗使用电路元件进行建模，其中 $Z_R = R$，$Z_C = \\frac{1}{j \\omega C}$，串联组合 $Z_{\\mathrm{series}} = \\sum_i Z_i$，并联组合 $Z_{\\mathrm{parallel}} = \\left(\\sum_i \\frac{1}{Z_i}\\right)^{-1}$，其中 $j=\\sqrt{-1}$，$\\omega$ 是角频率，单位为 $\\mathrm{rad/s}$。\n- 假设在每个频率下，阻抗的实部和虚部都存在方差相等的独立高斯误差，即复高斯噪声。如果 $\\sigma^2$ 是每个分量的方差，则参数-模型对 $(\\theta,m)$ 的（未归一化）对数似然为\n$$\n\\log p(D \\mid \\theta,m) = -\\frac{1}{2 \\sigma^2} \\sum_{k=1}^{K} \\left(\\Re(Z_k^{\\mathrm{pred}}(\\theta,m)) - \\Re(Z_k^{\\mathrm{obs}})\\right)^2 - \\frac{1}{2 \\sigma^2} \\sum_{k=1}^{K} \\left(\\Im(Z_k^{\\mathrm{pred}}(\\theta,m)) - \\Im(Z_k^{\\mathrm{obs}})\\right)^2 + \\mathrm{const}.\n$$\n- 使用温度阶梯 $\\{T_\\ell\\}_{\\ell=1}^L$，其中 $T_1 = 1$ 且 $T_\\ell \\ge 1$。对于回火链，温度 $T$ 下的目标分布是\n$$\n\\pi_T(\\theta,m) \\propto \\left[p(D \\mid \\theta,m)\\right]^{1/T} p(\\theta \\mid m) p(m),\n$$\n并且在温度 $T$ 下的 Metropolis–Hastings 更新使用回火对数后验\n$$\n\\Lambda_T(\\theta,m) = \\frac{1}{T} \\log p(D \\mid \\theta,m) + \\log p(\\theta \\mid m) + \\log p(m).\n$$\n- 对于相邻温度 $T_i$ 和 $T_j$（其中 $T_i  T_j$）之间的状态交换，交换状态 $x_i=(\\theta_i,m_i)$ 和 $x_j=(\\theta_j,m_j)$ 的 Metropolis–Hastings 接受概率为\n$$\n\\alpha_{\\mathrm{swap}} = \\min \\left\\{1, \\exp\\left[\\left(\\frac{1}{T_i} - \\frac{1}{T_j}\\right) \\left(\\log p(D \\mid x_j) - \\log p(D \\mid x_i)\\right)\\right]\\right\\},\n$$\n此时先验 $p(\\theta \\mid m)p(m)$ 未被回火，因此先验项在比率中被抵消。\n\n电路模型：\n- 模型 $m=0$ (Randles 电路): $Z(\\omega;\\theta_0) = R_s + \\left(\\frac{1}{R_{ct}} + j \\omega C\\right)^{-1}$，参数为 $\\theta_0 = (R_s, R_{ct}, C)$。\n- 模型 $m=1$ (带常相位角元件(CPE)的 Randles 电路): $Z(\\omega;\\theta_1) = R_s + \\left(\\frac{1}{R_{ct}} + Q (j\\omega)^{\\alpha}\\right)^{-1}$，其中指数 $\\alpha = 0.9$ 固定，参数为 $\\theta_1 = (R_s, R_{ct}, Q)$。将 $Q$ 解释为在 $1\\,\\mathrm{rad/s}$ 处的类赝电容尺度参数，以确保其量级与 $C$ 一致。\n\n合成数据生成：\n- 使用在 $f_{\\min} = 1\\,\\mathrm{Hz}$ 和 $f_{\\max} = 1000\\,\\mathrm{Hz}$ 之间的 $K = 25$ 个对数间隔的频率。使用 $\\omega_k = 2\\pi f_k$。\n- 真实数据由模型 $m=1$ 生成，其中 $\\alpha = 0.9$，参数向量为 $\\theta_1^{\\mathrm{true}} = (R_s^{\\mathrm{true}}, R_{ct}^{\\mathrm{true}}, Q^{\\mathrm{true}})$，具体值为 $R_s^{\\mathrm{true}} = 5$, $R_{ct}^{\\mathrm{true}} = 20$, $Q^{\\mathrm{true}} = 10^{-3}$。在实部和虚部上均添加标准差为 $\\sigma = 0.35$ 的独立高斯噪声，单位为 $\\Omega$。所有阻抗单位为 $\\Omega$，频率单位为 $\\mathrm{Hz}$。\n- 对每个正参数使用对数正态先验。等价地，对于 $x \\in \\{R_s, R_{ct}, C, Q\\}$，令 $\\log x \\sim \\mathcal{N}(\\mu_x, \\tau_x^2)$。使用 $\\mu_{R_s} = \\log 5$, $\\mu_{R_{ct}} = \\log 20$, $\\mu_C = \\log 10^{-3}$, $\\mu_Q = \\log 10^{-3}$，以及标准差 $\\tau_{R_s} = 0.5$, $\\tau_{R_{ct}} = 0.7$, $\\tau_C = 1.0$, $\\tau_Q = 1.0$。对模型指数使用均匀先验，即 $p(m=0)=p(m=1)=\\frac{1}{2}$。\n\n设计一个包含以下元素的并行回火 MCMC 算法：\n- 在对数参数空间中进行随机游走提议，使用高斯增量进行连续更新。\n- 偶尔进行离散提议，将模型指数 $m$ 在 $0$ 和 $1$ 之间翻转，同时在共享的对数空间 $(\\log R_s, \\log R_{ct}, \\log X)$ 中保持相同的参数向量，其中当 $m=0$ 时 $X$ 为 $C$，当 $m=1$ 时 $X$ 为 $Q$。\n- 根据上述接受概率，在固定的迭代间隔尝试在相邻温度之间进行交换（swap）提议。\n\n您的程序必须实现以上内容，并计算冷链（$T=1$）在链的后半部分（老化期后）的拓扑切换事件数。该事件数定义为在仅限于老化期后样本的冷链轨迹中，满足 $m_t \\ne m_{t-1}$ 的索引 $t$ 的数量。\n\n测试套件：\n在以下三个测试用例上运行您的算法，每个用例由元组 $(\\text{temperatures}, \\text{iterations}, \\text{swap\\_period}, \\text{swap\\_enabled}, \\text{seed})$ 定义：\n- 测试 A (带交换的正常路径): temperatures $[1.0, 1.5, 2.25, 3.375]$, iterations $3000$, swap\\_period $10$, swap\\_enabled True, seed $12345$.\n- 测试 B (不带交换的对照组): temperatures $[1.0, 1.5, 2.25, 3.375]$, iterations $3000$, swap\\_period $10$, swap\\_enabled False, seed $12345$.\n- 测试 C (边界情况，单温度): temperatures $[1.0]$, iterations $3000$, swap\\_period $10$, swap\\_enabled True, seed $67890$.\n\n所有频率必须以 $\\mathrm{Hz}$ 为单位处理，阻抗以 $\\Omega$ 为单位，角频率 $\\omega$ 以 $\\mathrm{rad/s}$ 为单位。根据 $\\omega$ 的定义，复数求幂的角度使用弧度。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果。具体来说，按顺序输出测试 A、测试 B 和测试 C 在老化期后冷链中的拓扑切换事件的整数计数，例如：\"[12,4,1]\"。",
            "solution": "该问题要求实现并行回火马尔可夫链蒙特卡洛（PT-MCMC）算法，以对合成的电化学阻抗谱（EIS）数据集进行贝叶斯推断。目标是量化连续模型参数 $\\theta$ 和离散模型指数 $m$ 的不确定性，并通过计算最冷链中的模型拓扑切换次数，来展示 PT 如何增强在多峰后验分布中的采样。\n\n### 1. 贝叶斯框架与模型规范\n\n推断的基础是贝叶斯定理，该定理指出，在给定观测数据 $D$ 的情况下，参数 $\\theta$ 和模型指数 $m$ 的联合后验分布为：\n$$\np(\\theta, m \\mid D) \\propto p(D \\mid \\theta, m) p(\\theta \\mid m) p(m)\n$$\n其中 $p(D \\mid \\theta, m)$ 是似然， $p(\\theta \\mid m)$ 是参数先验，而 $p(m)$ 是模型先验。\n\n考虑了两种相互竞争的电化学模型：\n- **模型 $m=0$ (Randles 电路)：** 阻抗 $Z$ 作为角频率 $\\omega$ 的函数由 $Z(\\omega;\\theta_0) = R_s + \\left(\\frac{1}{R_{ct}} + j \\omega C\\right)^{-1}$ 给出，其参数向量为 $\\theta_0 = (R_s, R_{ct}, C)$。\n- **模型 $m=1$ (带常相位角元件(CPE)的 Randles 电路)：** 阻抗为 $Z(\\omega;\\theta_1) = R_s + \\left(\\frac{1}{R_{ct}} + Q (j\\omega)^{\\alpha}\\right)^{-1}$，其指数 $\\alpha = 0.9$ 固定，参数向量为 $\\theta_1 = (R_s, R_{ct}, Q)$。项 $(j\\omega)^{\\alpha}$ 计算为 $\\omega^{\\alpha} e^{j\\alpha\\pi/2}$。\n\n参数空间以对数形式定义以确保正性：$(\\log R_s, \\log R_{ct}, \\log X)$，其中当 $m=0$ 时 $X$ 为 $C$，当 $m=1$ 时 $X$ 为 $Q$。这种共享结构对于设计在模型之间切换的提议至关重要。\n\n先验指定如下：\n- 模型指数的均匀先验：$p(m=0) = p(m=1) = 0.5$。\n- 所有连续参数的对数正态先验，这等同于其对数的正态先验。对于一个通用参数 $x$，$\\log x \\sim \\mathcal{N}(\\mu_x, \\tau_x^2)$。具体均值 $(\\mu)$ 和标准差 $(\\tau)$ 在问题描述中已提供。一个状态 $(\\theta, m)$ 的对数先验是其组成对数参数的对数概率密度函数（log-pdf）与对数模型先验 $\\log p(m)$ 的总和。\n\n### 2. 似然与数据生成\n\n合成数据 $D = \\{Z_k^{\\mathrm{obs}}\\}_{k=1}^K$ 是在从 $f=1\\,\\mathrm{Hz}$ 到 $f=1000\\,\\mathrm{Hz}$ 的 $K=25$ 个对数间隔频率上生成的。数据由模型 $m=1$ 生成，真实参数为 $\\theta_1^{\\mathrm{true}} = (R_s=5, R_{ct}=20, Q=10^{-3})$ 且 $\\alpha=0.9$。在每个频率下，阻抗的实部和虚部都添加了标准差为 $\\sigma=0.35$ 的独立高斯噪声。\n\n假设采用此复高斯噪声模型，对数似然由下式给出：\n$$\n\\log p(D \\mid \\theta, m) = -\\frac{1}{2\\sigma^2} \\sum_{k=1}^{K} |Z_k^{\\mathrm{pred}}(\\theta, m) - Z_k^{\\mathrm{obs}}|^2\n$$\n其中常数项被省略，因为它们在 Metropolis-Hastings 比率中会抵消。这种设定创造了一种情况，即模型 $m=0$（带有理想电容器，等效于 $\\alpha=1$）是真实模型 $m=1$（$\\alpha=0.9$）的一个相近但错误的竞争者，导致产生了一个双峰后验分布，这对于标准的 MCMC 采样器来说难以探索。\n\n### 3. 并行回火 MCMC 算法设计\n\n采用并行回火（也称为副本交换 MCMC）来克服多峰后验分布的挑战。该算法并行运行 $L$ 条 MCMC 链，每条链从一个回火后验分布中采样，其温度 $T_\\ell$ 来自一个温度阶梯 $\\{T_1, T_2, \\ldots, T_L\\}$，其中 $1 = T_1  T_2  \\dots  T_L$。\n\n在温度 $T$ 下的链的回火对数后验为：\n$$\n\\Lambda_T(\\theta, m) = \\frac{1}{T} \\log p(D \\mid \\theta, m) + \\log p(\\theta \\mid m) + \\log p(m)\n$$\n更高的温度（$T1$）会“压平”后验景观，使链更容易跨越模式之间的低概率壁垒。该算法在两种类型的移动之间交替进行：\n\n**a) 链内更新：** 每条链都进行标准的 Metropolis-Hastings 更新。从当前状态 $(\\theta, m)$ 提议一个移动到新状态 $(\\theta', m')$。在此实现中，提议可以是：\n- 参数更新：在对数参数空间中进行随机游走步骤，$\\log \\theta' = \\log \\theta + \\epsilon$，其中 $\\epsilon \\sim \\mathcal{N}(\\mathbf{0}, \\Sigma_{\\text{prop}})$。\n- 模型更新：模型指数被翻转，$m' = 1-m$，而共享的对数参数保持不变。\n该提议以概率 $\\alpha = \\min\\left\\{1, \\exp(\\Lambda_T(\\theta', m') - \\Lambda_T(\\theta, m))\\right\\}$ 被接受。\n\n**b) 交换（Swap）移动：** 在固定间隔，提议在相邻链之间交换状态。对于温度为 $T_i$ 和 $T_j$（$T_i  T_j$）且当前状态为 $x_i = (\\theta_i, m_i)$ 和 $x_j = (\\theta_j, m_j)$ 的链，交换以以下概率被接受：\n$$\n\\alpha_{\\mathrm{swap}} = \\min \\left\\{1, \\exp\\left[\\left(\\frac{1}{T_i} - \\frac{1}{T_j}\\right) \\left(\\log p(D \\mid x_j) - \\log p(D \\mid x_i)\\right)\\right]\\right\\}\n$$\n这使得由高温的、探索性强的链发现的拟合良好的状态能够传递给冷链（$T_1=1$），而冷链则从真实的后验分布中采样。该机制极大地改善了所有相关模式的混合和探索。\n\n### 4. 实现与分析\n\n该算法使用 Python 实现。对于由一组温度、迭代次数、交换周期、交换启用/禁用标志和随机种子定义的每个测试用例，执行 MCMC 模拟。每条链的状态（参数、模型指数、对数似然和对数先验）都会被维护。\n\n模拟结束后，分析冷链（$T=1$）的模型指数历史 $\\{m_t\\}$。计算链的后半部分（老化期后）的拓扑切换事件数。如果在迭代 $t$ 时 $m_t \\ne m_{t-1}$，则计为一个切换事件。该计数可作为评估采样器在两个模型模式之间导航能力的量化指标。比较测试 A（启用交换）与测试 B/C（禁用或不存在交换）之间的切换计数，可以直接证明并行回火交换机制的有效性。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Implements and runs the Parallel Tempering MCMC for EIS model selection.\n    \"\"\"\n\n    # --- Problem Constants and Definitions ---\n    ALPHA_CPE = 0.9\n    SIGMA_NOISE = 0.35\n    K_FREQS = 25\n    F_MIN, F_MAX = 1.0, 1000.0\n    FREQS = np.logspace(np.log10(F_MIN), np.log10(F_MAX), K_FREQS)\n    OMEGAS = 2 * np.pi * FREQS\n\n    TRUE_PARAMS = {'Rs': 5.0, 'Rct': 20.0, 'Q': 1e-3}\n\n    PRIOR_MEANS = {\n        'log_Rs': np.log(5.0), 'log_Rct': np.log(20.0),\n        'log_C': np.log(1e-3), 'log_Q': np.log(1e-3)\n    }\n    PRIOR_STDS = {\n        'log_Rs': 0.5, 'log_Rct': 0.7,\n        'log_C': 1.0, 'log_Q': 1.0\n    }\n    LOG_MODEL_PRIOR = np.log(0.5)\n\n    LOG_PROPOSAL_STD = np.array([0.05, 0.05, 0.1])\n    MODEL_FLIP_PROB = 0.1\n\n    # --- Helper Functions ---\n\n    def impedance_model_0(params, omegas):\n        Rs, Rct, C = params\n        return Rs + 1.0 / (1.0 / Rct + 1j * omegas * C)\n\n    def impedance_model_1(params, omegas):\n        Rs, Rct, Q = params\n        alpha = ALPHA_CPE\n        j_omega_alpha = (omegas**alpha) * (np.cos(alpha * np.pi / 2) + 1j * np.sin(alpha * np.pi / 2))\n        return Rs + 1.0 / (1.0 / Rct + Q * j_omega_alpha)\n\n    def generate_data():\n        true_impedance = impedance_model_1(\n            (TRUE_PARAMS['Rs'], TRUE_PARAMS['Rct'], TRUE_PARAMS['Q']),\n            OMEGAS\n        )\n        noise_real = np.random.normal(0, SIGMA_NOISE, K_FREQS)\n        noise_imag = np.random.normal(0, SIGMA_NOISE, K_FREQS)\n        return true_impedance + noise_real + 1j * noise_imag\n\n    def log_prior(log_params, model_idx):\n        log_Rs, log_Rct, log_X = log_params\n        lp_Rs = norm.logpdf(log_Rs, loc=PRIOR_MEANS['log_Rs'], scale=PRIOR_STDS['log_Rs'])\n        lp_Rct = norm.logpdf(log_Rct, loc=PRIOR_MEANS['log_Rct'], scale=PRIOR_STDS['log_Rct'])\n        if model_idx == 0:\n            lp_X = norm.logpdf(log_X, loc=PRIOR_MEANS['log_C'], scale=PRIOR_STDS['log_C'])\n        else:\n            lp_X = norm.logpdf(log_X, loc=PRIOR_MEANS['log_Q'], scale=PRIOR_STDS['log_Q'])\n        return lp_Rs + lp_Rct + lp_X + LOG_MODEL_PRIOR\n\n    def log_likelihood(params, model_idx, Z_obs):\n        if model_idx == 0:\n            Z_pred = impedance_model_0(params, OMEGAS)\n        else:\n            Z_pred = impedance_model_1(params, OMEGAS)\n        sum_sq_err = np.sum((Z_pred.real - Z_obs.real)**2 + (Z_pred.imag - Z_obs.imag)**2)\n        return -0.5 * sum_sq_err / (SIGMA_NOISE**2)\n\n    def run_simulation_for_case(case_params):\n        temperatures, iterations, swap_period, swap_enabled, seed = case_params\n        \n        np.random.seed(seed)\n        Z_obs = generate_data()\n        \n        num_chains = len(temperatures)\n        chains = []\n\n        for _ in range(num_chains):\n            if np.random.rand() > 0.5:\n                model_idx_init = 0\n                log_X_init = np.random.normal(PRIOR_MEANS['log_C'], PRIOR_STDS['log_C'])\n            else:\n                model_idx_init = 1\n                log_X_init = np.random.normal(PRIOR_MEANS['log_Q'], PRIOR_STDS['log_Q'])\n            \n            log_params_init = np.array([\n                np.random.normal(PRIOR_MEANS['log_Rs'], PRIOR_STDS['log_Rs']),\n                np.random.normal(PRIOR_MEANS['log_Rct'], PRIOR_STDS['log_Rct']),\n                log_X_init\n            ])\n            params_init = np.exp(log_params_init)\n            \n            chains.append({\n                'log_params': log_params_init,\n                'model_idx': model_idx_init,\n                'log_L': log_likelihood(params_init, model_idx_init, Z_obs),\n                'log_P': log_prior(log_params_init, model_idx_init)\n            })\n\n        cold_chain_model_history = np.zeros(iterations, dtype=int)\n        \n        for i in range(iterations):\n            for chain_idx, temp in enumerate(temperatures):\n                current_state = chains[chain_idx]\n                \n                if np.random.rand()  MODEL_FLIP_PROB:\n                    log_params_prop = current_state['log_params']\n                    model_idx_prop = 1 - current_state['model_idx']\n                else:\n                    model_idx_prop = current_state['model_idx']\n                    proposal_step = np.random.normal(0, LOG_PROPOSAL_STD)\n                    log_params_prop = current_state['log_params'] + proposal_step\n\n                params_prop = np.exp(log_params_prop)\n                log_L_prop = log_likelihood(params_prop, model_idx_prop, Z_obs)\n                log_P_prop = log_prior(log_params_prop, model_idx_prop)\n                \n                log_post_curr = (1.0 / temp) * current_state['log_L'] + current_state['log_P']\n                log_post_prop = (1.0 / temp) * log_L_prop + log_P_prop\n                \n                log_acceptance_ratio = log_post_prop - log_post_curr\n                \n                if log_acceptance_ratio >= 0 or np.log(np.random.rand())  log_acceptance_ratio:\n                    chains[chain_idx] = {\n                        'log_params': log_params_prop, 'model_idx': model_idx_prop,\n                        'log_L': log_L_prop, 'log_P': log_P_prop\n                    }\n                    \n            cold_chain_model_history[i] = chains[0]['model_idx']\n            \n            if swap_enabled and (i + 1) % swap_period == 0 and num_chains > 1:\n                for j in range(num_chains - 2, -1, -1):\n                    chain1_idx, chain2_idx = j, j + 1\n                    state1, state2 = chains[chain1_idx], chains[chain2_idx]\n                    temp1, temp2 = temperatures[chain1_idx], temperatures[chain2_idx]\n                    \n                    log_swap_prob = (1.0/temp1 - 1.0/temp2) * (state2['log_L'] - state1['log_L'])\n                    \n                    if log_swap_prob >= 0 or np.log(np.random.rand())  log_swap_prob:\n                        chains[chain1_idx], chains[chain2_idx] = chains[chain2_idx], chains[chain1_idx]\n\n        burn_in = iterations // 2\n        post_burnin_trace = cold_chain_model_history[burn_in:]\n        previous_trace = cold_chain_model_history[burn_in-1:-1]\n        switches = np.sum(post_burnin_trace != previous_trace)\n        \n        return int(switches)\n\n    # --- Main Execution ---\n    test_cases = [\n        # (temperatures, iterations, swap_period, swap_enabled, seed)\n        ([1.0, 1.5, 2.25, 3.375], 3000, 10, True, 12345),  # Test A\n        ([1.0, 1.5, 2.25, 3.375], 3000, 10, False, 12345), # Test B\n        ([1.0], 3000, 10, True, 67890),                    # Test C\n    ]\n    \n    results = [run_simulation_for_case(case) for case in test_cases]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}