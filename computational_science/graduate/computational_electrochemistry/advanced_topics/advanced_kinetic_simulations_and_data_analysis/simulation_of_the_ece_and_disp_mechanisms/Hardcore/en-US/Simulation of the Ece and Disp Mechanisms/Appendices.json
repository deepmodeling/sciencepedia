{
    "hands_on_practices": [
        {
            "introduction": "This first exercise provides foundational practice in translating a complex reaction network into a solvable mathematical model. You will implement a system of ordinary differential equations (ODEs) describing competing ECE and DISP pathways, using the Butler-Volmer equation to capture potential-dependent kinetics . This simulation allows you to explore how experimental parameters, such as the potential scan rate $\\nu$, can be tuned to control the final product distribution in a hypothetical thin-layer cell.",
            "id": "4258366",
            "problem": "You are given a model for competing mechanistic pathways in electrochemical systems: Electrochemical–Chemical–Electrochemical (ECE) and Disproportionation (DISP). Under a thin-layer electrode approximation, assume spatially uniform concentrations and represent electrochemical steps as effective first-order bulk reactions with potential-dependent rate constants determined by the Butler–Volmer relation. Your task is to write a complete, runnable program that simulates the time-dependent product distribution for the species produced by ECE versus DISP during a triangular potential scan, and that outputs the final fraction of a desired product as a decimal number for each test case.\n\nStart from the following foundational bases: mass conservation, the law of mass action, and the Butler–Volmer relation. Consider a species $A$ that undergoes the following sequence and competition:\n- First electrochemical step: $A + e^- \\rightleftharpoons B$,\n- Chemical step: $B \\rightarrow C$,\n- Second electrochemical step: $C + e^- \\rightleftharpoons D$,\n- Disproportionation (DISP): $2B \\rightarrow A + C$.\n\nAssume a thin-layer electrode of sufficiently small thickness such that spatial gradients of concentration are negligible. Represent the electrochemical steps using effective homogeneous first-order rate constants $k_{1,f}(E)$, $k_{1,b}(E)$ for the first step, and $k_{2,f}(E)$, $k_{2,b}(E)$ for the second step, where $E$ is the applied potential. Use the Butler–Volmer form for each electron transfer step:\n$$\nk_{i,f}(E) = k_{0,i}\\,\\exp\\!\\left(-\\alpha_i \\frac{F\\,(E - E_{0,i})}{R\\,T}\\right),\\qquad\nk_{i,b}(E) = k_{0,i}\\,\\exp\\!\\left((1-\\alpha_i) \\frac{F\\,(E - E_{0,i})}{R\\,T}\\right),\n$$\nwhere $i \\in \\{1,2\\}$ indexes the first and second electron transfer steps, $k_{0,i}$ are effective standard rate constants in $\\mathrm{s}^{-1}$, $E_{0,i}$ are standard potentials in $\\mathrm{V}$, $\\alpha_i$ are transfer coefficients (dimensionless), $F$ is the Faraday constant in $\\mathrm{C\\,mol^{-1}}$, $R$ is the ideal gas constant in $\\mathrm{J\\,mol^{-1}\\,K^{-1}}$, and $T$ is the absolute temperature in $\\mathrm{K}$. The chemical step is first-order with rate constant $k_c$ in $\\mathrm{s}^{-1}$, and the disproportionation is second-order with rate constant $k_{\\mathrm{disp}}$ in $\\mathrm{m^3\\,mol^{-1}\\,s^{-1}}$.\n\nLet the bulk concentrations be $c_A(t)$, $c_B(t)$, $c_C(t)$, $c_D(t)$ with units of $\\mathrm{mol\\,m^{-3}}$. Under the mass-action assumption and stoichiometry noted above, the governing ordinary differential equations are:\n$$\n\\frac{d c_A}{d t} = -k_{1,f}(E(t))\\,c_A + k_{1,b}(E(t))\\,c_B + k_{\\mathrm{disp}}\\,c_B^2,\n$$\n$$\n\\frac{d c_B}{d t} = k_{1,f}(E(t))\\,c_A - k_{1,b}(E(t))\\,c_B - k_c\\,c_B - 2\\,k_{\\mathrm{disp}}\\,c_B^2,\n$$\n$$\n\\frac{d c_C}{d t} = k_c\\,c_B + k_{\\mathrm{disp}}\\,c_B^2 - k_{2,f}(E(t))\\,c_C + k_{2,b}(E(t))\\,c_D,\n$$\n$$\n\\frac{d c_D}{d t} = k_{2,f}(E(t))\\,c_C - k_{2,b}(E(t))\\,c_D.\n$$\n\nUse a triangular potential program defined by a start potential $E_{\\mathrm{start}}$ in $\\mathrm{V}$, a vertex potential $E_{\\mathrm{vertex}}$ in $\\mathrm{V}$, an end potential $E_{\\mathrm{end}}$ in $\\mathrm{V}$, and a scan rate $\\nu$ in $\\mathrm{V\\,s^{-1}}$. The potential $E(t)$ increases or decreases linearly from $E_{\\mathrm{start}}$ to $E_{\\mathrm{vertex}}$ at rate $\\nu$, then reverses and scans linearly from $E_{\\mathrm{vertex}}$ to $E_{\\mathrm{end}}$ at the same rate $\\nu$. Thus,\n$$\nt_1 = \\frac{|E_{\\mathrm{vertex}} - E_{\\mathrm{start}}|}{\\nu},\\quad\nt_2 = \\frac{|E_{\\mathrm{end}} - E_{\\mathrm{vertex}}|}{\\nu},\\quad\nT_{\\mathrm{end}} = t_1 + t_2,\n$$\nand\n$$\nE(t) = \\begin{cases}\nE_{\\mathrm{start}} + \\mathrm{sgn}(E_{\\mathrm{vertex}} - E_{\\mathrm{start}})\\,\\nu\\,t, & 0 \\le t \\le t_1 \\\\\nE_{\\mathrm{vertex}} + \\mathrm{sgn}(E_{\\mathrm{end}} - E_{\\mathrm{vertex}})\\,\\nu\\,(t - t_1), & t_1 < t \\le T_{\\mathrm{end}}\n\\end{cases}\n$$\n\nInitial conditions are $c_A(0) = c_{A,0}$ in $\\mathrm{mol\\,m^{-3}}$ and $c_B(0) = c_C(0) = c_D(0) = 0$. Use $F = 96485\\,\\mathrm{C\\,mol^{-1}}$, $R = 8.314\\,\\mathrm{J\\,mol^{-1}\\,K^{-1}}$, and $T = 298\\,\\mathrm{K}$. For each test case, simulate until $t = T_{\\mathrm{end}}$ and report the final fraction of the desired product $D$,\n$$\nf_D = \\frac{c_D(T_{\\mathrm{end}})}{c_A(T_{\\mathrm{end}}) + c_B(T_{\\mathrm{end}}) + c_C(T_{\\mathrm{end}}) + c_D(T_{\\mathrm{end}})},\n$$\nas a decimal rounded to six decimal places (unitless). The objective is to identify conditions that maximize $f_D$ by tuning $E(t)$ (via $E_{\\mathrm{start}}$, $E_{\\mathrm{vertex}}$, $E_{\\mathrm{end}}$) and the scan rate $\\nu$.\n\nYour program must implement a numerically stable integrator suitable for stiff systems and must not require any external input. It must iterate over the following test suite, where all quantities are given in International System of Units:\n\n- Test case $1$ (ECE-favorable baseline):\n  - $c_{A,0} = 1.0\\,\\mathrm{mol\\,m^{-3}}$,\n  - $E_{\\mathrm{start}} = 0.0\\,\\mathrm{V}$, $E_{\\mathrm{vertex}} = -1.2\\,\\mathrm{V}$, $E_{\\mathrm{end}} = 0.0\\,\\mathrm{V}$,\n  - $\\nu = 0.1\\,\\mathrm{V\\,s^{-1}}$,\n  - $E_{0,1} = -0.2\\,\\mathrm{V}$, $E_{0,2} = -0.8\\,\\mathrm{V}$,\n  - $k_{0,1} = 5.0\\,\\mathrm{s^{-1}}$, $k_{0,2} = 5.0\\,\\mathrm{s^{-1}}$,\n  - $\\alpha_1 = 0.5$, $\\alpha_2 = 0.5$,\n  - $k_c = 2.0\\,\\mathrm{s^{-1}}$,\n  - $k_{\\mathrm{disp}} = 0.01\\,\\mathrm{m^3\\,mol^{-1}\\,s^{-1}}$.\n\n- Test case $2$ (DISP-dominant competition):\n  - $c_{A,0} = 1.0\\,\\mathrm{mol\\,m^{-3}}$,\n  - $E_{\\mathrm{start}} = 0.0\\,\\mathrm{V}$, $E_{\\mathrm{vertex}} = -1.2\\,\\mathrm{V}$, $E_{\\mathrm{end}} = 0.0\\,\\mathrm{V}$,\n  - $\\nu = 0.1\\,\\mathrm{V\\,s^{-1}}$,\n  - $E_{0,1} = -0.2\\,\\mathrm{V}$, $E_{0,2} = -0.8\\,\\mathrm{V}$,\n  - $k_{0,1} = 5.0\\,\\mathrm{s^{-1}}$, $k_{0,2} = 5.0\\,\\mathrm{s^{-1}}$,\n  - $\\alpha_1 = 0.5$, $\\alpha_2 = 0.5$,\n  - $k_c = 0.1\\,\\mathrm{s^{-1}}$,\n  - $k_{\\mathrm{disp}} = 0.5\\,\\mathrm{m^3\\,mol^{-1}\\,s^{-1}}$.\n\n- Test case $3$ (very fast scan rate):\n  - $c_{A,0} = 1.0\\,\\mathrm{mol\\,m^{-3}}$,\n  - $E_{\\mathrm{start}} = 0.0\\,\\mathrm{V}$, $E_{\\mathrm{vertex}} = -1.2\\,\\mathrm{V}$, $E_{\\mathrm{end}} = 0.0\\,\\mathrm{V}$,\n  - $\\nu = 10.0\\,\\mathrm{V\\,s^{-1}}$,\n  - $E_{0,1} = -0.2\\,\\mathrm{V}$, $E_{0,2} = -0.8\\,\\mathrm{V}$,\n  - $k_{0,1} = 5.0\\,\\mathrm{s^{-1}}$, $k_{0,2} = 5.0\\,\\mathrm{s^{-1}}$,\n  - $\\alpha_1 = 0.5$, $\\alpha_2 = 0.5$,\n  - $k_c = 2.0\\,\\mathrm{s^{-1}}$,\n  - $k_{\\mathrm{disp}} = 0.01\\,\\mathrm{m^3\\,mol^{-1}\\,s^{-1}}$.\n\n- Test case $4$ (incomplete potential window for second reduction):\n  - $c_{A,0} = 1.0\\,\\mathrm{mol\\,m^{-3}}$,\n  - $E_{\\mathrm{start}} = 0.0\\,\\mathrm{V}$, $E_{\\mathrm{vertex}} = -0.5\\,\\mathrm{V}$, $E_{\\mathrm{end}} = 0.0\\,\\mathrm{V}$,\n  - $\\nu = 0.1\\,\\mathrm{V\\,s^{-1}}$,\n  - $E_{0,1} = -0.2\\,\\mathrm{V}$, $E_{0,2} = -0.8\\,\\mathrm{V}$,\n  - $k_{0,1} = 5.0\\,\\mathrm{s^{-1}}$, $k_{0,2} = 5.0\\,\\mathrm{s^{-1}}$,\n  - $\\alpha_1 = 0.5$, $\\alpha_2 = 0.5$,\n  - $k_c = 2.0\\,\\mathrm{s^{-1}}$,\n  - $k_{\\mathrm{disp}} = 0.01\\,\\mathrm{m^3\\,mol^{-1}\\,s^{-1}}$.\n\n- Test case $5$ (no disproportionation, pure ECE):\n  - $c_{A,0} = 1.0\\,\\mathrm{mol\\,m^{-3}}$,\n  - $E_{\\mathrm{start}} = 0.0\\,\\mathrm{V}$, $E_{\\mathrm{vertex}} = -1.2\\,\\mathrm{V}$, $E_{\\mathrm{end}} = 0.0\\,\\mathrm{V}$,\n  - $\\nu = 0.1\\,\\mathrm{V\\,s^{-1}}$,\n  - $E_{0,1} = -0.2\\,\\mathrm{V}$, $E_{0,2} = -0.8\\,\\mathrm{V}$,\n  - $k_{0,1} = 5.0\\,\\mathrm{s^{-1}}$, $k_{0,2} = 5.0\\,\\mathrm{s^{-1}}$,\n  - $\\alpha_1 = 0.5$, $\\alpha_2 = 0.5$,\n  - $k_c = 2.0\\,\\mathrm{s^{-1}}$,\n  - $k_{\\mathrm{disp}} = 0.0\\,\\mathrm{m^3\\,mol^{-1}\\,s^{-1}}$.\n\nAngle units do not apply. Physical units are specified above and must be adhered to. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[0.123456,0.654321,0.000001]$), where each entry is the rounded decimal $f_D$ for the corresponding test case in the order given.",
            "solution": "The user-provided problem is a well-defined initial value problem in the domain of computational electrochemistry, suitable for numerical simulation. It is scientifically grounded, self-contained, and objective. There are no contradictions, ambiguities, or instances of factual unsoundness. Thus, I will proceed with a full solution.\n\nThe problem requires the simulation of a system of coupled chemical reactions involving both electrochemical and homogeneous chemical steps. The species involved are $A$, $B$, $C$, and $D$. The reaction network is given by:\n1. First electrochemical step: $A + e^- \\rightleftharpoons B$\n2. Chemical step (ECE pathway): $B \\rightarrow C$\n3. Second electrochemical step (ECE pathway): $C + e^- \\rightleftharpoons D$\n4. Disproportionation (DISP pathway): $2B \\rightarrow A + C$\n\nThe system is modeled under a thin-layer approximation, which implies that all concentrations, $c_A(t)$, $c_B(t)$, $c_C(t)$, and $c_D(t)$, are spatially uniform and depend only on time $t$. The dynamics of these concentrations are governed by the law of mass action, leading to a system of four coupled ordinary differential equations (ODEs). Let $\\vec{y}(t) = [c_A(t), c_B(t), c_C(t), c_D(t)]^T$. The system can be written in vector form as $\\frac{d\\vec{y}}{dt} = \\vec{f}(t, \\vec{y})$. The components of $\\vec{f}$ are derived from the stoichiometry of the reactions:\n$$\n\\frac{d c_A}{d t} = -k_{1,f}(E(t))\\,c_A + k_{1,b}(E(t))\\,c_B + k_{\\mathrm{disp}}\\,c_B^2\n$$\n$$\n\\frac{d c_B}{d t} = k_{1,f}(E(t))\\,c_A - k_{1,b}(E(t))\\,c_B - k_c\\,c_B - 2\\,k_{\\mathrm{disp}}\\,c_B^2\n$$\n$$\n\\frac{d c_C}{d t} = k_c\\,c_B + k_{\\mathrm{disp}}\\,c_B^2 - k_{2,f}(E(t))\\,c_C + k_{2,b}(E(t))\\,c_D\n$$\n$$\n\\frac{d c_D}{d t} = k_{2,f}(E(t))\\,c_C - k_{2,b}(E(t))\\,c_D\n$$\nThese ODEs are coupled and nonlinear due to the second-order disproportionation term $k_{\\mathrm{disp}}\\,c_B^2$.\n\nThe rate constants for the electrochemical steps, $k_{i,f}$ and $k_{i,b}$ for $i \\in \\{1,2\\}$, are dependent on the applied electrode potential $E$, which itself is a function of time, $E(t)$. This dependence is described by the Butler-Volmer equation:\n$$\nk_{i,f}(E) = k_{0,i}\\,\\exp\\!\\left(-\\alpha_i \\frac{F\\,(E - E_{0,i})}{R\\,T}\\right)\n$$\n$$\nk_{i,b}(E) = k_{0,i}\\,\\exp\\!\\left((1-\\alpha_i) \\frac{F\\,(E - E_{0,i})}{R\\,T}\\right)\n$$\nHere, $k_{0,i}$ are the standard heterogeneous rate constants (with units of $\\mathrm{s^{-1}}$ under the thin-layer model), $\\alpha_i$ are the charge transfer coefficients, $E_{0,i}$ are the standard reduction potentials, $F$ is the Faraday constant, $R$ is the ideal gas constant, and $T$ is the temperature.\n\nThe potential $E(t)$ follows a triangular waveform defined by a start potential $E_{\\mathrm{start}}$, a vertex potential $E_{\\mathrm{vertex}}$, an end potential $E_{\\mathrm{end}}$, and a constant scan rate $\\nu$. The total duration of the experiment, $T_{\\mathrm{end}}$, is the sum of the time for the forward scan ($t_1$) and the reverse scan ($t_2$). The function $E(t)$ is piecewise linear.\n\nA crucial property of the reaction system is the conservation of the total number of moles of the core species. Summing the four ODEs yields:\n$$\n\\frac{d}{dt}(c_A + c_B + c_C + c_D) = 0\n$$\nThis indicates that the total concentration $C_{\\mathrm{tot}} = c_A(t) + c_B(t) + c_C(t) + c_D(t)$ is a constant of motion. Given the initial conditions $c_A(0) = c_{A,0}$ and $c_B(0)=c_C(0)=c_D(0)=0$, we have $C_{\\mathrm{tot}}(t) = c_{A,0}$ for all $t \\ge 0$. This simplifies the calculation of the final fraction of product $D$:\n$$\nf_D = \\frac{c_D(T_{\\mathrm{end}})}{c_A(T_{\\mathrm{end}}) + c_B(T_{\\mathrm{end}}) + c_C(T_{\\mathrm{end}}) + c_D(T_{\\mathrm{end}})} = \\frac{c_D(T_{\\mathrm{end}})}{c_{A,0}}\n$$\n\nThe exponential dependence of the rate constants on potential can lead to a wide disparity in their magnitudes over the course of the potential scan. This often results in a \"stiff\" system of ODEs, where the timescales of different processes vary by many orders of magnitude. For such systems, standard explicit numerical integration methods (like Euler's or the classic Runge-Kutta method) are computationally inefficient, requiring extremely small time steps to maintain numerical stability. The problem therefore correctly specifies the need for a numerically stable integrator suitable for stiff systems.\n\nOur strategy is to use a high-quality numerical ODE solver from a standard scientific library. The `scipy.integrate.solve_ivp` function in Python's SciPy library provides access to several advanced solvers. We will select the 'BDF' (Backward Differentiation Formulas) method, which is an implicit multi-step method well-suited for stiff ODEs.\n\nThe algorithm is as follows:\n1. Define all physical constants ($F$, $R$, $T$) and the parameters for each test case.\n2. For each test case, define a function for the time-dependent potential, $E(t)$, based on the given scan parameters.\n3. Implement a function, say `dydt(t, y, params)`, that takes the current time $t$, the state vector of concentrations $\\vec{y}$, and the system parameters. This function calculates $E(t)$, then computes all rate constants, and finally returns the vector of derivatives $\\frac{d\\vec{y}}{dt}$ according to the governing ODEs.\n4. Set the initial conditions, $\\vec{y}(0) = [c_{A,0}, 0, 0, 0]^T$, and the integration time interval $[0, T_{\\mathrm{end}}]$.\n5. Call `scipy.integrate.solve_ivp` with the 'BDF' method, passing it the `dydt` function, the time interval, and the initial conditions. We will use suitably small relative and absolute tolerances (e.g., $10^{-8}$ and $10^{-10}$, respectively) to ensure high accuracy.\n6. Once the integration is complete, extract the final concentration of species $D$, $c_D(T_{\\mathrm{end}})$, from the solver's output.\n7. Calculate the final fraction $f_D = c_D(T_{\\mathrm{end}}) / c_{A,0}$.\n8. Round the result to six decimal places and format the output as specified.\n\nThis procedure will be repeated for each of the five test cases provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Simulates the ECE/DISP mechanism for a series of test cases and\n    calculates the final fraction of product D.\n    \"\"\"\n    # Define physical constants\n    F = 96485.0  # Faraday constant in C/mol\n    R = 8.314   # Ideal gas constant in J/(mol*K)\n    T = 298.0   # Temperature in K\n    FRT = F / (R * T)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (ECE-favorable baseline)\n        {\n            'cA0': 1.0, 'E_start': 0.0, 'E_vertex': -1.2, 'E_end': 0.0,\n            'nu': 0.1, 'E01': -0.2, 'E02': -0.8, 'k01': 5.0, 'k02': 5.0,\n            'alpha1': 0.5, 'alpha2': 0.5, 'kc': 2.0, 'k_disp': 0.01\n        },\n        # Test case 2 (DISP-dominant competition)\n        {\n            'cA0': 1.0, 'E_start': 0.0, 'E_vertex': -1.2, 'E_end': 0.0,\n            'nu': 0.1, 'E01': -0.2, 'E02': -0.8, 'k01': 5.0, 'k02': 5.0,\n            'alpha1': 0.5, 'alpha2': 0.5, 'kc': 0.1, 'k_disp': 0.5\n        },\n        # Test case 3 (very fast scan rate)\n        {\n            'cA0': 1.0, 'E_start': 0.0, 'E_vertex': -1.2, 'E_end': 0.0,\n            'nu': 10.0, 'E01': -0.2, 'E02': -0.8, 'k01': 5.0, 'k02': 5.0,\n            'alpha1': 0.5, 'alpha2': 0.5, 'kc': 2.0, 'k_disp': 0.01\n        },\n        # Test case 4 (incomplete potential window)\n        {\n            'cA0': 1.0, 'E_start': 0.0, 'E_vertex': -0.5, 'E_end': 0.0,\n            'nu': 0.1, 'E01': -0.2, 'E02': -0.8, 'k01': 5.0, 'k02': 5.0,\n            'alpha1': 0.5, 'alpha2': 0.5, 'kc': 2.0, 'k_disp': 0.01\n        },\n        # Test case 5 (no disproportionation, pure ECE)\n        {\n            'cA0': 1.0, 'E_start': 0.0, 'E_vertex': -1.2, 'E_end': 0.0,\n            'nu': 0.1, 'E01': -0.2, 'E02': -0.8, 'k01': 5.0, 'k02': 5.0,\n            'alpha1': 0.5, 'alpha2': 0.5, 'kc': 2.0, 'k_disp': 0.0\n        }\n    ]\n\n    results = []\n    _FRT = FRT  # Local alias for performance in the inner loop\n\n    for params in test_cases:\n        # Calculate timing for the potential scan\n        t1 = abs(params['E_vertex'] - params['E_start']) / params['nu']\n        t2 = abs(params['E_end'] - params['E_vertex']) / params['nu']\n        T_end = t1 + t2\n\n        sign1 = np.sign(params['E_vertex'] - params['E_start'])\n        sign2 = np.sign(params['E_end'] - params['E_vertex'])\n\n        def potential_E(t):\n            \"\"\"Calculates the potential E at a given time t.\"\"\"\n            if t <= t1:\n                return params['E_start'] + sign1 * params['nu'] * t\n            else:\n                return params['E_vertex'] + sign2 * params['nu'] * (t - t1)\n\n        def dydt(t, y, p):\n            \"\"\"\n            Defines the system of ordinary differential equations.\n            y = [cA, cB, cC, cD]\n            \"\"\"\n            cA, cB, cC, cD = y\n\n            # Get potential at time t\n            E = potential_E(t)\n\n            # Calculate potential-dependent rate constants (Butler-Volmer)\n            E_minus_E01 = E - p['E01']\n            E_minus_E02 = E - p['E02']\n            \n            k1f = p['k01'] * np.exp(-p['alpha1'] * _FRT * E_minus_E01)\n            k1b = p['k01'] * np.exp((1 - p['alpha1']) * _FRT * E_minus_E01)\n            k2f = p['k02'] * np.exp(-p['alpha2'] * _FRT * E_minus_E02)\n            k2b = p['k02'] * np.exp((1 - p['alpha2']) * _FRT * E_minus_E02)\n\n            # System of ODEs\n            dcAdt = -k1f * cA + k1b * cB + p['k_disp'] * cB**2\n            dcBdt = k1f * cA - k1b * cB - p['kc'] * cB - 2 * p['k_disp'] * cB**2\n            dcCdt = p['kc'] * cB + p['k_disp'] * cB**2 - k2f * cC + k2b * cD\n            dcDdt = k2f * cC - k2b * cD\n\n            return [dcAdt, dcBdt, dcCdt, dcDdt]\n\n        # Initial conditions\n        y0 = [params['cA0'], 0.0, 0.0, 0.0]\n\n        # Time span for integration\n        t_span = [0, T_end]\n\n        # Solve the stiff ODE system\n        sol = solve_ivp(\n            fun=dydt,\n            t_span=t_span,\n            y0=y0,\n            method='BDF',\n            args=(params,),\n            rtol=1e-8,\n            atol=1e-10\n        )\n\n        # Extract the final concentration of product D\n        cD_final = sol.y[3, -1]\n\n        # Calculate the final fraction f_D\n        # The total concentration is conserved, so the denominator is cA0.\n        fD = cD_final / params['cA0']\n        \n        # Format result to 6 decimal places and add to list\n        results.append(f\"{fD:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving from purely kinetic models to systems with spatial variations requires solving partial differential equations (PDEs), where ensuring the accuracy of your code is paramount. This practice introduces the Method of Manufactured Solutions (MMS), a rigorous code verification technique for reaction-diffusion problems . By quantifying the error of your numerical implementation against a known analytical solution, you will develop essential skills for building reliable and trustworthy scientific software.",
            "id": "4258373",
            "problem": "You are asked to verify a reaction–diffusion implementation for two canonical electrochemical reaction mechanisms, Electrochemical–Chemical–Electrochemical (ECE) and Disproportionation (DISP), using the Method of Manufactured Solutions (MMS). Work in strictly dimensionless variables. Consider a one-dimensional, dimensionless spatial domain $x \\in [\\,0,\\,1\\,]$ and a dimensionless time domain $t \\in [\\,0,\\,1\\,]$. The governing equations for each species $c_i(x,t)$ are the reaction–diffusion equations derived from Fick’s second law and mass-action kinetics, augmented by a manufactured source term $s_i(x,t)$:\n$$\n\\frac{\\partial c_i}{\\partial t} \\;=\\; D_i \\,\\frac{\\partial^2 c_i}{\\partial x^2} \\;+\\; R_i\\!\\left(\\{c_j\\}\\right) \\;+\\; s_i(x,t),\n$$\nwhere $D_i$ is the dimensionless diffusion coefficient for species $i$, $R_i$ is the dimensionless reaction term given by the mechanism, and $s_i(x,t)$ is chosen to make a prescribed manufactured solution an exact solution of the continuous partial differential equation.\n\nDefine homogeneous Neumann boundary conditions so that $\\partial c_i/\\partial x = 0$ at $x=0$ and $x=1$, and choose a smooth manufactured solution that satisfies these boundary conditions:\n$$\nc_i(x,t) \\;=\\; \\alpha_i \\;+\\; \\beta_i \\,\\cos\\!\\left(2\\pi x\\right)\\,\\sin\\!\\left(\\pi t\\right),\n$$\nwith constants $\\alpha_i > 0$ and $\\beta_i > 0$ specified in the test suite below.\n\nFor the ECE mechanism, use four species with the following bulk reaction terms that emulate sequential reversible–irreversible–reversible steps:\n$$\nR_A \\;=\\; -k_{1f}\\,c_A \\;+\\; k_{1b}\\,c_B,\n$$\n$$\nR_B \\;=\\; k_{1f}\\,c_A \\;-\\; k_{1b}\\,c_B \\;-\\; k_2\\,c_B,\n$$\n$$\nR_C \\;=\\; k_2\\,c_B \\;-\\; k_{3f}\\,c_C \\;+\\; k_{3b}\\,c_D,\n$$\n$$\nR_D \\;=\\; k_{3f}\\,c_C \\;-\\; k_{3b}\\,c_D,\n$$\nwith dimensionless rate constants $k_{1f}$, $k_{1b}$, $k_2$, $k_{3f}$, and $k_{3b}$.\n\nFor the Disproportionation (DISP) mechanism, use three species with a reversible interconversion and a bimolecular disproportionation of the intermediate:\n$$\nR_A \\;=\\; -k_{1f}\\,c_A \\;+\\; k_{1b}\\,c_B \\;+\\; k_{\\mathrm{disp}}\\,c_B^2,\n$$\n$$\nR_B \\;=\\; k_{1f}\\,c_A \\;-\\; k_{1b}\\,c_B \\;-\\; 2\\,k_{\\mathrm{disp}}\\,c_B^2,\n$$\n$$\nR_C \\;=\\; k_{\\mathrm{disp}}\\,c_B^2,\n$$\nwith dimensionless rate constants $k_{1f}$, $k_{1b}$, and $k_{\\mathrm{disp}}$.\n\nUsing the manufactured solution $c_i(x,t)$, define the source term $s_i(x,t)$ that makes $c_i(x,t)$ an exact continuous solution:\n$$\ns_i(x,t) \\;=\\; \\frac{\\partial c_i}{\\partial t} \\;-\\; D_i \\,\\frac{\\partial^2 c_i}{\\partial x^2} \\;-\\; R_i\\!\\left(\\{c_j\\}\\right),\n$$\nwhere\n$$\n\\frac{\\partial c_i}{\\partial t} \\;=\\; \\beta_i\\,\\pi\\,\\cos\\!\\left(2\\pi x\\right)\\,\\cos\\!\\left(\\pi t\\right),\n\\quad\n\\frac{\\partial^2 c_i}{\\partial x^2} \\;=\\; -4\\pi^2\\,\\beta_i\\,\\cos\\!\\left(2\\pi x\\right)\\,\\sin\\!\\left(\\pi t\\right).\n$$\n\nDiscretize the domain with a uniform grid: $x_m = m\\,\\Delta x$ for $m = 0,1,\\dots,N_x-1$ and $t_n = n\\,\\Delta t$ for $n = 0,1,\\dots,N_t-1$, with $\\Delta x = 1/(N_x-1)$ and $\\Delta t = 1/(N_t-1)$. At interior points $(t_n,x_m)$ for $n \\in \\{1,\\dots,N_t-2\\}$ and $m \\in \\{1,\\dots,N_x-2\\}$, form the second-order centered finite-difference residual for each species $i$:\n$$\n\\mathcal{R}_i^{n,m} \\;=\\; \n\\frac{c_i^{n+1,m} - c_i^{n-1,m}}{2\\,\\Delta t}\n\\;-\\;\nD_i\\,\\frac{c_i^{n,m+1} - 2\\,c_i^{n,m} + c_i^{n,m-1}}{\\Delta x^2}\n\\;-\\;\nR_i\\!\\left(\\{c_j^{n,m}\\}\\right)\n\\;-\\;\ns_i^{n,m}.\n$$\nCompute the root-mean-square residual across all interior space–time points and all species:\n$$\n\\mathrm{RMS} \\;=\\; \\sqrt{\\frac{1}{N_{\\mathrm{samples}}}\\,\\sum_{n=1}^{N_t-2}\\sum_{m=1}^{N_x-2}\\sum_{i} \\left(\\mathcal{R}_i^{n,m}\\right)^2},\n$$\nwhere $N_{\\mathrm{samples}}$ is the total number of summed terms.\n\nImplement a program that, for each test case below, constructs the manufactured solution, computes $s_i(x,t)$, forms the discrete residuals $\\mathcal{R}_i^{n,m}$, and outputs the RMS residual as a single floating-point number. All variables are dimensionless. Use the following test suite:\n\n- Test Case $1$ (ECE, coarse grid):\n  - Species and manufactured parameters: $(\\alpha_A,\\beta_A)=(\\,1.20,\\,0.10\\,)$, $(\\alpha_B,\\beta_B)=(\\,0.80,\\,0.07\\,)$, $(\\alpha_C,\\beta_C)=(\\,0.50,\\,0.05\\,)$, $(\\alpha_D,\\beta_D)=(\\,0.60,\\,0.04\\,)$.\n  - Diffusion coefficients: $(D_A,D_B,D_C,D_D)=(\\,0.010,\\,0.015,\\,0.008,\\,0.012\\,)$.\n  - Rate constants: $(k_{1f},k_{1b},k_2,k_{3f},k_{3b})=(\\,1.00,\\,0.50,\\,0.70,\\,0.80,\\,0.40\\,)$.\n  - Grid: $N_x=33$, $N_t=33$.\n\n- Test Case $2$ (ECE, medium grid):\n  - Same species and parameters as Test Case $1$.\n  - Grid: $N_x=65$, $N_t=65$.\n\n- Test Case $3$ (ECE, fine grid):\n  - Same species and parameters as Test Case $1$.\n  - Grid: $N_x=129$, $N_t=129$.\n\n- Test Case $4$ (DISP, medium grid):\n  - Species and manufactured parameters: $(\\alpha_A,\\beta_A)=(\\,1.00,\\,0.08\\,)$, $(\\alpha_B,\\beta_B)=(\\,0.90,\\,0.06\\,)$, $(\\alpha_C,\\beta_C)=(\\,0.70,\\,0.04\\,)$.\n  - Diffusion coefficients: $(D_A,D_B,D_C)=(\\,0.012,\\,0.011,\\,0.009\\,)$.\n  - Rate constants: $(k_{1f},k_{1b},k_{\\mathrm{disp}})=(\\,0.90,\\,0.60,\\,0.30\\,)$.\n  - Grid: $N_x=129$, $N_t=101$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test cases above (for example, $[\\,\\mathrm{r}_1,\\mathrm{r}_2,\\mathrm{r}_3,\\mathrm{r}_4\\,]$). Each $\\mathrm{r}_k$ must be a floating-point number. All computations must be carried out in dimensionless units, and angles are implied in the trigonometric functions to be in radians.",
            "solution": "The user has requested the implementation and execution of a Method of Manufactured Solutions (MMS) verification for two reaction-diffusion systems, ECE and DISP, on a discretized domain. The task requires calculating the root-mean-square (RMS) of the finite-difference residual for several test cases.\n\n### Problem Validation\n\nFirst, the problem statement is validated against the required criteria.\n\n**Step 1: Extracted Givens**\n-   **Governing Equation**: $\\frac{\\partial c_i}{\\partial t} = D_i \\frac{\\partial^2 c_i}{\\partial x^2} + R_i(\\{c_j\\}) + s_i(x,t)$\n-   **Domain**: $x \\in [0, 1]$, $t \\in [0, 1]$\n-   **Boundary Conditions**: $\\partial c_i/\\partial x = 0$ at $x=0$ and $x=1$ (homogeneous Neumann).\n-   **Manufactured Solution**: $c_i(x,t) = \\alpha_i + \\beta_i \\cos(2\\pi x) \\sin(\\pi t)$\n-   **Derivatives of $c_i$**: $\\frac{\\partial c_i}{\\partial t} = \\beta_i\\pi\\cos(2\\pi x)\\cos(\\pi t)$, $\\frac{\\partial^2 c_i}{\\partial x^2} = -4\\pi^2\\beta_i\\cos(2\\pi x)\\sin(\\pi t)$\n-   **Source Term**: $s_i(x,t) = \\frac{\\partial c_i}{\\partial t} - D_i \\frac{\\partial^2 c_i}{\\partial x^2} - R_i(\\{c_j\\})$\n-   **ECE Reaction Terms**:\n    $R_A = -k_{1f}c_A + k_{1b}c_B$\n    $R_B = k_{1f}c_A - k_{1b}c_B - k_2c_B$\n    $R_C = k_2c_B - k_{3f}c_C + k_{3b}c_D$\n    $R_D = k_{3f}c_C - k_{3b}c_D$\n-   **DISP Reaction Terms**:\n    $R_A = -k_{1f}c_A + k_{1b}c_B + k_{\\mathrm{disp}}c_B^2$\n    $R_B = k_{1f}c_A - k_{1b}c_B - 2k_{\\mathrm{disp}}c_B^2$\n    $R_C = k_{\\mathrm{disp}}c_B^2$\n-   **Discretization**: Uniform grid with $N_x, N_t$ points, $\\Delta x = 1/(N_x-1)$, $\\Delta t = 1/(N_t-1)$.\n-   **Finite-Difference Residual**: $\\mathcal{R}_i^{n,m} = \\frac{c_i^{n+1,m} - c_i^{n-1,m}}{2\\Delta t} - D_i\\frac{c_i^{n,m+1} - 2c_i^{n,m} + c_i^{n,m-1}}{\\Delta x^2} - R_i(\\{c_j^{n,m}\\}) - s_i^{n,m}$\n-   **RMS Calculation**: $\\mathrm{RMS} = \\sqrt{\\frac{1}{N_{\\mathrm{samples}}}\\sum_{n=1}^{N_t-2}\\sum_{m=1}^{N_x-2}\\sum_{i} (\\mathcal{R}_i^{n,m})^2}$\n-   **Test Cases**: Four test cases with specified mechanisms, parameters $(\\alpha_i, \\beta_i, D_i, \\{k\\})$, and grid sizes $(N_x, N_t)$.\n\n**Step 2: Validation of Givens**\n-   **Scientific Grounding**: The problem is well-grounded in computational science. It applies the Method of Manufactured Solutions, a standard code verification technique, to Fickian diffusion equations with mass-action kinetics. The ECE and DISP mechanisms are canonical in electrochemistry. The mathematical framework is sound.\n-   **Well-Posedness**: The problem is an evaluation task, not a boundary-value problem to be solved. It asks for the computation of a specific value (RMS residual) based on a complete set of equations, parameters, and numerical procedures. The task is unambiguous and leads to a unique result.\n-   **Objectivity**: The problem is stated in precise mathematical terms, free from subjective language.\n-   **Consistency Check**:\n    -   The manufactured solution $c_i(x,t) = \\alpha_i + \\beta_i \\cos(2\\pi x) \\sin(\\pi t)$ is smooth and twice-differentiable.\n    -   Its spatial derivative, $\\partial c_i/\\partial x = -2\\pi\\beta_i\\sin(2\\pi x)\\sin(\\pi t)$, is zero at $x=0$ and $x=1$, correctly satisfying the specified homogeneous Neumann boundary conditions.\n    -   The provided expressions for $\\partial c_i/\\partial t$ and $\\partial^2 c_i/\\partial x^2$ are correct.\n    -   The parameters $\\alpha_i > 0$ and $\\beta_i > 0$ with $\\alpha_i > \\beta_i$ (as given in the test cases) ensure that the concentrations $c_i(x,t)$ remain positive, which is physically consistent.\n    -   All necessary information for all four test cases is provided. The problem is self-contained and free of contradictions.\n\n**Step 3: Verdict**\nThe problem is valid as it is scientifically sound, well-posed, objective, and internally consistent.\n\n### Solution Design\n\nThe solution involves a direct implementation of the procedure described in the problem statement. For each test case, the following sequence of operations will be performed:\n\n1.  **Grid Generation**: A uniform spacetime grid of size $N_t \\times N_x$ is created for the domain $[0,1] \\times [0,1]$. Grid spacings $\\Delta t$ and $\\Delta x$ are calculated.\n\n2.  **Evaluation of Continuous Terms**:\n    -   The manufactured solution $c_i(x,t)$ is evaluated at every grid point for all species $i$, yielding a 3D array $C$ of shape $(N_{\\text{species}}, N_t, N_x)$.\n    -   The continuous derivatives $\\partial c_i/\\partial t$ and $\\partial^2 c_i/\\partial x^2$ are computed analytically and evaluated at all grid points.\n    -   The reaction terms $R_i(\\{c_j\\})$ are computed at all grid points using the array $C$. The specific form of $R_i$ depends on the mechanism (ECE or DISP).\n    -   The source term $s_i(x,t)$ is then calculated for all species at all grid points using its definition: $s_i = (\\partial c_i/\\partial t) - D_i (\\partial^2 c_i/\\partial x^2) - R_i$.\n\n3.  **Residual Calculation**:\n    -   The core of the task is to compute the discrete residual $\\mathcal{R}_i^{n,m}$ at all *interior* grid points, i.e., for $n \\in \\{1, \\dots, N_t-2\\}$ and $m \\in \\{1, \\dots, N_x-2\\}$.\n    -   The temporal derivative term is approximated using a second-order central difference: $(\\mathbf{c}^{n+1,m} - \\mathbf{c}^{n-1,m}) / (2\\Delta t)$.\n    -   The spatial diffusion term is approximated using a second-order central difference: $D_i(\\mathbf{c}^{n,m+1} - 2\\mathbf{c}^{n,m} + \\mathbf{c}^{n,m-1}) / (\\Delta x^2)$.\n    -   The reaction term $R_i(\\{c_j^{n,m}\\})$ and source term $s_i^{n,m}$ are taken from the arrays evaluated in the previous step, but indexed only at the interior points.\n    -   The residual $\\mathcal{R}_i^{n,m}$ is the difference between the discretized PDE operator and the evaluated source term, as defined in the problem.\n\n4.  **RMS Computation**:\n    -   The RMS value is calculated by taking the square root of the mean of all squared residual terms $(\\mathcal{R}_i^{n,m})^2$, summed over all species $i$ and all interior grid points $(n,m)$.\n\nThis procedure is implemented using the `numpy` library to perform array operations efficiently, avoiding explicit loops over the grid points for better performance. A single function orchestrates the calculation for a given set of parameters, and this function is called for each of the four test cases. The results are collected and formatted as specified. As the finite difference scheme is second-order accurate, we anticipate that the RMS residual for the ECE test cases will decrease by a factor of approximately $4$ as the grid spacing is halved (from Case 1 to 2, and from 2 to 3), affirming the correctness of the implementation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_rms(\n    mechanism_type: str,\n    Nx: int,\n    Nt: int,\n    alphas: tuple,\n    betas: tuple,\n    Ds: tuple,\n    ks: tuple,\n) -> float:\n    \"\"\"\n    Calculates the Root-Mean-Square (RMS) residual for a single test case\n    of the Method of Manufactured Solutions (MMS).\n\n    Args:\n        mechanism_type: The reaction mechanism ('ECE' or 'DISP').\n        Nx: Number of spatial grid points.\n        Nt: Number of temporal grid points.\n        alphas: Tuple of alpha parameters for the manufactured solution.\n        betas: Tuple of beta parameters for the manufactured solution.\n        Ds: Tuple of diffusion coefficients for each species.\n        ks: Tuple of rate constants for the reaction mechanism.\n\n    Returns:\n        The calculated RMS residual as a float.\n    \"\"\"\n    # 1. Setup Grid and Parameters\n    num_species = len(alphas)\n    x_grid = np.linspace(0.0, 1.0, Nx)\n    t_grid = np.linspace(0.0, 1.0, Nt)\n    dx = 1.0 / (Nx - 1)\n    dt = 1.0 / (Nt - 1)\n\n    # Use numpy arrays with added axes for broadcasting\n    alphas_np = np.array(alphas)[:, np.newaxis, np.newaxis]\n    betas_np = np.array(betas)[:, np.newaxis, np.newaxis]\n    Ds_np = np.array(Ds)\n\n    xx, tt = np.meshgrid(x_grid, t_grid)\n\n    # 2. Construct Analytical Terms on the Full Grid\n    # Evaluate trigonometric components once for efficiency\n    cos_2pix = np.cos(2 * np.pi * xx)\n    sin_pit = np.sin(np.pi * tt)\n\n    # Manufactured solution C(i, t, x)\n    C = alphas_np + betas_np * cos_2pix * sin_pit\n\n    # Continuous derivatives\n    dcdt_cont = betas_np * np.pi * cos_2pix * np.cos(np.pi * tt)\n    d2cdx2_cont = -4 * np.pi**2 * betas_np * cos_2pix * sin_pit\n\n    # Reaction term R(i, t, x)\n    R = np.zeros_like(C)\n    if mechanism_type == 'ECE':\n        k1f, k1b, k2, k3f, k3b = ks\n        cA, cB, cC, cD = C[0], C[1], C[2], C[3]\n        R[0] = -k1f * cA + k1b * cB\n        R[1] =  k1f * cA - k1b * cB - k2 * cB\n        R[2] =  k2  * cB - k3f * cC + k3b * cD\n        R[3] =  k3f * cC - k3b * cD\n    elif mechanism_type == 'DISP':\n        k1f, k1b, k_disp = ks\n        cA, cB, _ = C[0], C[1], C[2]\n        R[0] = -k1f * cA + k1b * cB + k_disp * cB**2\n        R[1] =  k1f * cA - k1b * cB - 2 * k_disp * cB**2\n        R[2] =  k_disp * cB**2\n    \n    # Source term S(i, t, x)\n    S = dcdt_cont - Ds_np[:, np.newaxis, np.newaxis] * d2cdx2_cont - R\n\n    # 3. Calculate Discrete Residual on the Interior Grid\n    # The residual is evaluated for n in [1, Nt-2] and m in [1, Nx-2].\n    # We use numpy slicing to operate on the interior grid efficiently.\n\n    # Discrete time derivative: (c(n+1) - c(n-1)) / (2*dt)\n    dcdt_disc = (C[:, 2:, 1:-1] - C[:, :-2, 1:-1]) / (2 * dt)\n\n    # Discrete spatial derivative: (c(m+1) - 2c(m) + c(m-1)) / dx^2\n    d2cdx2_disc = (C[:, 1:-1, 2:] - 2 * C[:, 1:-1, 1:-1] + C[:, 1:-1, :-2]) / (dx**2)\n\n    # Reaction and Source terms, sliced to match the interior grid\n    R_interior = R[:, 1:-1, 1:-1]\n    S_interior = S[:, 1:-1, 1:-1]\n\n    # Assemble the residual for all species on the interior grid\n    residual_grid = dcdt_disc - Ds_np[:, np.newaxis, np.newaxis] * d2cdx2_disc - R_interior - S_interior\n\n    # 4. Compute Final RMS Value\n    num_samples = residual_grid.size\n    rms = np.sqrt(np.sum(residual_grid**2) / num_samples)\n    \n    return rms\n\ndef solve():\n    \"\"\"\n    Defines the test cases, calculates the RMS residual for each,\n    and prints the results in the specified format.\n    \"\"\"\n    # Define common parameters for ECE test cases\n    ece_params = {\n        'mechanism_type': 'ECE',\n        'alphas': (1.20, 0.80, 0.50, 0.60),\n        'betas': (0.10, 0.07, 0.05, 0.04),\n        'Ds': (0.010, 0.015, 0.008, 0.012),\n        'ks': (1.00, 0.50, 0.70, 0.80, 0.40)\n    }\n\n    test_cases = [\n        # Test Case 1 (ECE, coarse grid)\n        {**ece_params, 'Nx': 33, 'Nt': 33},\n        # Test Case 2 (ECE, medium grid)\n        {**ece_params, 'Nx': 65, 'Nt': 65},\n        # Test Case 3 (ECE, fine grid)\n        {**ece_params, 'Nx': 129, 'Nt': 129},\n        # Test Case 4 (DISP, medium grid)\n        {\n            'mechanism_type': 'DISP',\n            'Nx': 129,\n            'Nt': 101,\n            'alphas': (1.00, 0.90, 0.70),\n            'betas': (0.08, 0.06, 0.04),\n            'Ds': (0.012, 0.011, 0.009),\n            'ks': (0.90, 0.60, 0.30)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        rms = calculate_rms(**case)\n        results.append(rms)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Simulating chemical kinetics often involves dealing with \"stiff\" systems, where different processes occur on vastly different timescales, posing a significant challenge for numerical solvers. This exercise demonstrates how to diagnose and quantify stiffness by analyzing the eigenvalues of the system's Jacobian matrix, $\\mathbf{J}$ . Understanding stiffness is crucial for selecting appropriate numerical methods, such as Backward Differentiation Formulas (BDF), that ensure stable and efficient simulations.",
            "id": "4258386",
            "problem": "Consider a one-dimensional diffusion–reaction model on a finite interval with homogeneous Dirichlet boundary conditions, representing a planar electrode at $x=0$ and a bulk reservoir at $x=L$. The fundamental base is Fick’s second law of diffusion and the law of mass action for chemical kinetics. Let species $B$ undergo diffusion with diffusion coefficient $D_B$ and participate in a Disproportionation (DISP) reaction, $2B \\rightarrow C$, with a second-order rate constant $k_d$. Under the Method of Lines (MOL), the spatial domain is discretized into $N$ interior points with uniform spacing $\\Delta x = L/(N+1)$, yielding a system of ordinary differential equations for the nodal concentrations $y_i(t) \\equiv C_B(x_i,t)$, $i=1,\\dots,N$:\n$$\n\\frac{dy_i}{dt} = D_B \\frac{y_{i-1} - 2 y_i + y_{i+1}}{\\Delta x^2} - 2 k_d y_i^2,\n$$\nwith the standard second-difference discretization and homogeneous Dirichlet conditions $C_B(0,t)=0$ and $C_B(L,t)=0$ implemented by excluding boundary nodes.\n\nThe Jacobian matrix $\\mathbf{J}$ of the MOL system evaluated at a uniform steady profile $y_i = C_{B,0}$ is the sum of the discretized diffusion operator and the diagonal reaction Jacobian:\n$$\n\\mathbf{J} = \\frac{D_B}{\\Delta x^2} \\mathbf{L}_D - 4 k_d C_{B,0} \\mathbf{I},\n$$\nwhere $\\mathbf{L}_D$ is the $N \\times N$ tridiagonal matrix with $-2$ on the diagonal and $+1$ on the first sub- and super-diagonals, and $\\mathbf{I}$ is the identity matrix. All eigenvalues of $\\mathbf{J}$ have strictly negative real parts for $D_B>0$ and $k_d \\ge 0$.\n\nDefine the stiffness index $\\kappa$ of the system at the specified state as the ratio between the largest and smallest magnitude of the real parts of the Jacobian eigenvalues:\n$$\n\\kappa = \\frac{\\max_i \\left| \\Re(\\lambda_i) \\right|}{\\min_i \\left| \\Re(\\lambda_i) \\right|},\n$$\nwhere $\\lambda_i$ are the eigenvalues of $\\mathbf{J}$ and $\\Re(\\cdot)$ denotes the real part. The Forward Euler explicit scheme is stable for the linearized system $y'=\\mathbf{J}y$ if the time step satisfies\n$$\n\\Delta t_{\\mathrm{FE,max}} = \\frac{2}{\\rho(\\mathbf{J})},\n$$\nwhere $\\rho(\\mathbf{J}) = \\max_i \\left| \\Re(\\lambda_i) \\right|$ is the spectral radius of $\\mathbf{J}$ (taken over real parts). Also define the characteristic diffusion timescale\n$$\nT_D = \\frac{L^2}{D_B}.\n$$\nA large ratio $R = T_D / \\Delta t_{\\mathrm{FE,max}}$ indicates inefficiency of explicit schemes and motivates using Backward Differentiation Formula (BDF) methods, which are $A$-stable for low orders and handle stiff systems robustly. For comparison, an Electrochemical–Chemical–Electrochemical (ECE) surrogate with a first-order homogeneous chemical step $B \\rightarrow C$ having rate constant $k_c$ yields a Jacobian\n$$\n\\mathbf{J}_{\\mathrm{ECE}} = \\frac{D_B}{\\Delta x^2} \\mathbf{L}_D - k_c \\mathbf{I},\n$$\nwhich lacks the nonlinear $C_B^2$ dependence and typically exhibits reduced stiffness.\n\nImplement a complete, runnable program that:\n- Constructs $\\mathbf{L}_D$ for the given $N$ and $L$, assembles $\\mathbf{J}$ for the DISP case at a uniform $C_{B,0}$, computes its eigenvalues, and evaluates $\\kappa$, $\\Delta t_{\\mathrm{FE,max}}$ (in seconds), and $\\rho(\\mathbf{J})$ (in $\\mathrm{s}^{-1}$). Also compute $R = T_D / \\Delta t_{\\mathrm{FE,max}}$ (dimensionless).\n- Optionally, assembles $\\mathbf{J}_{\\mathrm{ECE}}$ for a test case with a first-order rate constant $k_c$ (set $k_d=0$ in that case) and computes the same metrics to contrast stiffness with DISP.\n- Classifies a case as stiff if $\\kappa > 100$.\n\nYour test suite must include the following parameter sets, each expressed in International System of Units (SI):\n1. DISP, “happy path”: $N=50$, $L=10^{-5}\\ \\mathrm{m}$, $D_B=10^{-9}\\ \\mathrm{m}^2/\\mathrm{s}$, $k_d=10^{6}\\ \\mathrm{m}^3/(\\mathrm{mol}\\cdot\\mathrm{s})$, $C_{B,0}=10\\ \\mathrm{mol}/\\mathrm{m}^3$.\n2. DISP, diffusion-dominated edge: $N=50$, $L=10^{-5}\\ \\mathrm{m}$, $D_B=10^{-9}\\ \\mathrm{m}^2/\\mathrm{s}$, $k_d=10^{6}\\ \\mathrm{m}^3/(\\mathrm{mol}\\cdot\\mathrm{s})$, $C_{B,0}=10^{-6}\\ \\mathrm{mol}/\\mathrm{m}^3$.\n3. DISP, grid-refined: $N=200$, $L=10^{-5}\\ \\mathrm{m}$, $D_B=10^{-9}\\ \\mathrm{m}^2/\\mathrm{s}$, $k_d=10^{6}\\ \\mathrm{m}^3/(\\mathrm{mol}\\cdot\\mathrm{s})$, $C_{B,0}=10\\ \\mathrm{mol}/\\mathrm{m}^3$.\n4. ECE surrogate, linear reaction: $N=50$, $L=10^{-5}\\ \\mathrm{m}$, $D_B=10^{-9}\\ \\mathrm{m}^2/\\mathrm{s}$, $k_d=0$, $k_c=100\\ \\mathrm{s}^{-1}$.\n\nFor each test case, your program must output four values in the following order: $\\kappa$ (dimensionless), $\\Delta t_{\\mathrm{FE,max}}$ in $\\mathrm{s}$, $\\rho(\\mathbf{J})$ in $\\mathrm{s}^{-1}$, and a boolean indicating stiffness ($\\kappa>100$). Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\left[\\text{result1},\\text{result2},\\dots\\right]$). Numerical values must be in base SI units as specified; booleans are permitted.",
            "solution": "The problem statement has been rigorously validated and found to be scientifically sound, well-posed, and self-contained. It presents a standard problem in computational chemical kinetics and numerical analysis, using established principles and realistic physical parameters. All required information is provided, and the objectives are clear and unambiguous. We may therefore proceed with a complete solution.\n\nThe core of the problem is to analyze the stiffness of a system of ordinary differential equations (ODEs) arising from the Method of Lines (MOL) discretization of a one-dimensional reaction-diffusion partial differential equation (PDE). The stiffness is characterized by the spectrum of the system's Jacobian matrix, $\\mathbf{J}$. The analysis will be performed for two reaction mechanisms, Disproportionation (DISP) and a first-order Electrochemical-Chemical-Electrochemical (ECE) surrogate, under various parameter regimes.\n\nThe Jacobian matrix for the MOL system evaluated at a uniform profile $y_i = C_{B,0}$ is given by:\n$$ \\mathbf{J} = \\frac{D_B}{\\Delta x^2} \\mathbf{L}_D - C \\cdot \\mathbf{I} $$\nwhere $D_B$ is the diffusion coefficient, $\\Delta x = L/(N+1)$ is the spatial grid spacing with $L$ being the domain length and $N$ the number of interior grid points, $\\mathbf{L}_D$ is the $N \\times N$ tridiagonal matrix representing the second-order central difference operator for diffusion, and $\\mathbf{I}$ is the $N \\times N$ identity matrix. The constant $C$ represents the contribution from the linearized reaction kinetics.\nFor the DISP mechanism, $2B \\rightarrow C$, the reaction term in the ODE is $-2 k_d y_i^2$. Its derivative with respect to $y_i$ evaluated at $y_i = C_{B,0}$ is $-4 k_d C_{B,0}$. Thus, for DISP, $C = 4 k_d C_{B,0}$.\nFor the ECE surrogate mechanism, $B \\rightarrow C$, the reaction term is $-k_c y_i$. Its derivative with respect to $y_i$ is $-k_c$. Thus, for ECE, $C = k_c$.\n\nThe eigenvalues of the Jacobian matrix $\\mathbf{J}$ determine the stability and stiffness properties of the ODE system. Since the matrices $\\mathbf{L}_D$ and $\\mathbf{I}$ commute, the eigenvalues of their sum, $\\mathbf{J}$, are the sums of their individual eigenvalues. The eigenvalues of the matrix $\\mathbf{L}_D$ for an $N$-point discretization with homogeneous Dirichlet boundary conditions are known analytically:\n$$ \\mu_j(\\mathbf{L}_D) = -4 \\sin^2\\left(\\frac{j\\pi}{2(N+1)}\\right), \\quad \\text{for } j=1, 2, \\dots, N $$\nTherefore, the eigenvalues of the Jacobian $\\mathbf{J}$ are:\n$$ \\lambda_j(\\mathbf{J}) = \\frac{D_B}{\\Delta x^2} \\mu_j(\\mathbf{L}_D) - C = -\\frac{4 D_B}{\\Delta x^2} \\sin^2\\left(\\frac{j\\pi}{2(N+1)}\\right) - C $$\nGiven that all physical parameters ($D_B$, $k_d$, $C_{B,0}$, $k_c$) are non-negative, the constant $C$ is non-negative. Consequently, all eigenvalues $\\lambda_j$ are real and non-positive. This simplifies the analysis, as the real part $\\Re(\\lambda_j)$ is simply $\\lambda_j$, and its magnitude $|\\Re(\\lambda_j)|$ is $|\\lambda_j|$.\n\nThe requested metrics can now be expressed in terms of these eigenvalues:\n1.  **Spectral Radius** $\\rho(\\mathbf{J})$: This is the maximum magnitude of the real parts of the eigenvalues, which dictates the stability limit of explicit time-stepping schemes.\n    $$ \\rho(\\mathbf{J}) = \\max_{j} |\\Re(\\lambda_j)| = \\max_{j} |\\lambda_j| $$\n    The function $\\sin^2(x)$ is monotonically increasing on the interval relevant to our index $j$. Thus, the maximum magnitude occurs when $j=N$:\n    $$ |\\lambda_N| = \\frac{4 D_B}{\\Delta x^2} \\sin^2\\left(\\frac{N\\pi}{2(N+1)}\\right) + C $$\n    So, $\\rho(\\mathbf{J}) = |\\lambda_N|$.\n\n2.  **Maximum Forward Euler Time Step** $\\Delta t_{\\mathrm{FE,max}}$: The stability criterion for the Forward Euler method is $\\Delta t \\le 2 / \\rho(\\mathbf{J})$.\n    $$ \\Delta t_{\\mathrm{FE,max}} = \\frac{2}{\\rho(\\mathbf{J})} = \\frac{2}{|\\lambda_N|} $$\n\n3.  **Stiffness Index** $\\kappa$: This is the ratio of the largest to smallest magnitude of the real parts of the eigenvalues. It quantifies the spread of timescales in the system.\n    $$ \\kappa = \\frac{\\max_{j} |\\Re(\\lambda_j)|}{\\min_{j} |\\Re(\\lambda_j)|} = \\frac{\\max_{j} |\\lambda_j|}{\\min_{j} |\\lambda_j|} $$\n    The minimum magnitude corresponds to $j=1$:\n    $$ |\\lambda_1| = \\frac{4 D_B}{\\Delta x^2} \\sin^2\\left(\\frac{\\pi}{2(N+1)}\\right) + C $$\n    Therefore, the stiffness index is:\n    $$ \\kappa = \\frac{|\\lambda_N|}{|\\lambda_1|} = \\frac{\\frac{4 D_B}{\\Delta x^2} \\sin^2\\left(\\frac{N\\pi}{2(N+1)}\\right) + C}{\\frac{4 D_B}{\\Delta x^2} \\sin^2\\left(\\frac{\\pi}{2(N+1)}\\right) + C} $$\n\n4.  **Stiffness Classification**: The system is classified as stiff if $\\kappa > 100$.\n\nThe algorithm implemented in the program proceeds as follows for each test case:\n1.  Identify the reaction type (DISP or ECE) and retrieve the parameters $N$, $L$, $D_B$, $k_d$, $C_{B,0}$, and $k_c$.\n2.  Calculate the reaction kinetics constant $C$. If $k_d > 0$, $C=4 k_d C_{B,0}$. If $k_c > 0$, $C=k_c$.\n3.  Calculate the spatial step $\\Delta x = L/(N+1)$.\n4.  Compute the minimum and maximum eigenvalue magnitudes, $|\\lambda_1|$ and $|\\lambda_N|$, using the analytical formulas derived above.\n5.  Calculate $\\rho(\\mathbf{J}) = |\\lambda_N|$, $\\Delta t_{\\mathrm{FE,max}} = 2/\\rho(\\mathbf{J})$, and $\\kappa = |\\lambda_N|/|\\lambda_1|$.\n6.  Determine the boolean stiffness classification based on whether $\\kappa > 100$.\n7.  Store the four resulting values: $\\kappa$, $\\Delta t_{\\mathrm{FE,max}}$, $\\rho(\\mathbf{J})$, and the stiffness boolean.\n\nThis procedure is repeated for all specified test cases, and the results are aggregated into a single flat list for output, adhering to the specified format. The use of analytical eigenvalue expressions ensures high accuracy and computational efficiency, bypassing the need for explicit matrix construction and numerical eigenvalue solvers.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases and print results.\n    \"\"\"\n    \n    # Each tuple represents a test case with parameters:\n    # (type, N, L, D_B, k_d, C_B0, k_c) in SI units.\n    test_cases = [\n        # 1. DISP, “happy path”\n        ('DISP', 50, 1e-5, 1e-9, 1e6, 10.0, 0.0),\n        # 2. DISP, diffusion-dominated edge\n        ('DISP', 50, 1e-5, 1e-9, 1e6, 1e-6, 0.0),\n        # 3. DISP, grid-refined\n        ('DISP', 200, 1e-5, 1e-9, 1e6, 10.0, 0.0),\n        # 4. ECE surrogate, linear reaction\n        ('ECE', 50, 1e-5, 1e-9, 0.0, 0.0, 100.0)\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        case_type, N, L, D_B, k_d, C_B0, k_c = case\n        \n        # Calculate the relevant constant C from the linearized reaction kinetics\n        if case_type == 'DISP':\n            # For 2B -> C, reaction term is -2*kd*C^2, derivative is -4*kd*C\n            reaction_const = 4.0 * k_d * C_B0\n        elif case_type == 'ECE':\n            # For B -> C, reaction term is -kc*C, derivative is -kc\n            reaction_const = k_c\n        else:\n            # Should not happen with the defined test cases\n            raise ValueError(f\"Unknown case type: {case_type}\")\n\n        # Calculate metrics for the current case\n        kappa, dt_fe_max, rho_J, is_stiff = compute_stiffness_metrics(\n            N, L, D_B, reaction_const\n        )\n        \n        # Append the four required values to the flat results list\n        results.extend([kappa, dt_fe_max, rho_J, is_stiff])\n\n    # Format the final output as a single line: [res1,res2,...]\n    # The map(str, ...) function correctly handles floats and booleans.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef compute_stiffness_metrics(N, L, D_B, reaction_const):\n    \"\"\"\n    Computes stiffness metrics based on the analytical eigenvalues of the Jacobian.\n    \n    Parameters:\n    - N (int): Number of interior spatial grid points.\n    - L (float): Length of the spatial domain in meters.\n    - D_B (float): Diffusion coefficient in m^2/s.\n    - reaction_const (float): The constant C in the Jacobian formula J = (D_B/dx^2)L_D - C*I.\n    \n    Returns:\n    - tuple: (kappa, dt_fe_max, rho_J, is_stiff)\n    \"\"\"\n    \n    # Calculate spatial step size\n    dx = L / (N + 1.0)\n    \n    # The eigenvalues of the Jacobian are lambda_j = -A * sin^2(j*pi/(2(N+1))) - C\n    # where A = 4 * D_B / dx^2 and C = reaction_const.\n    # All eigenvalues are real and negative. Their magnitudes are:\n    # |lambda_j| = A * sin^2(j*pi/(2(N+1))) + C\n    \n    diffusion_multiplier = 4.0 * D_B / (dx**2)\n    \n    # Smallest magnitude eigenvalue corresponds to j=1\n    j_min_arg = np.pi / (2.0 * (N + 1.0))\n    eig_mag_min = diffusion_multiplier * np.sin(j_min_arg)**2 + reaction_const\n    \n    # Largest magnitude eigenvalue corresponds to j=N\n    j_max_arg = N * np.pi / (2.0 * (N + 1.0))\n    eig_mag_max = diffusion_multiplier * np.sin(j_max_arg)**2 + reaction_const\n    \n    # 1. Spectral radius rho(J) is the max eigenvalue magnitude\n    rho_J = eig_mag_max\n    \n    # 2. Stiffness index kappa\n    # Avoid division by zero if all eigenvalues are zero (non-physical case here)\n    if eig_mag_min == 0.0:\n        kappa = np.inf\n    else:\n        kappa = eig_mag_max / eig_mag_min\n        \n    # 3. Max stable time step for Forward Euler\n    # Avoid division by zero if rho_J is zero\n    if rho_J == 0.0:\n        dt_fe_max = np.inf\n    else:\n        dt_fe_max = 2.0 / rho_J\n        \n    # 4. Stiffness classification\n    is_stiff = kappa > 100.0\n    \n    return kappa, dt_fe_max, rho_J, is_stiff\n\n# Execute the main function\nsolve()\n```"
        }
    ]
}