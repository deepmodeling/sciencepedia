{
    "hands_on_practices": [
        {
            "introduction": "固相扩散系数 $D_s$ 是决定锂离子电池倍率性能的关键参数之一。本练习将指导你通过求解多伊尔-福勒-纽曼（DFN）模型中的核心方程之一——球形扩散方程——来参数化这一重要过程。你将从第一性原理出发，构建一个偏微分方程的数值求解器，并利用该求解器拟合模拟的实验数据，从而估算出 $D_s$ 的值。这项实践不仅能加深你对电极颗粒内部传质过程的理解，还能锻炼你解决偏微分方程和处理逆问题的能力。",
            "id": "4242979",
            "problem": "您的任务是在 Doyle-Fuller-Newman (DFN) 模型背景下，通过求解和反演电极颗粒的球形固相扩散方程，来估算锂离子电池的固相扩散系数。该估算应通过拟合在小恒流阶跃下生成的瞬态电压数据来执行，此时电压响应主要由固相扩散决定。推导和计算必须从质量守恒和菲克扩散定律的第一性原理出发，而不依赖于预先指定的简化公式。\n\n考虑一个半径为 $R$ 的球形活性材料颗粒，正在进行锂嵌入。固相浓度 $c(r,t)$ 由球坐标系下的菲克第二定律控制，该定律由质量守恒和本构通量定律推导而来。局部浓度的控制平衡方程为偏微分方程\n$$\n\\frac{\\partial c}{\\partial t} = D \\left( \\frac{\\partial^2 c}{\\partial r^2} + \\frac{2}{r} \\frac{\\partial c}{\\partial r} \\right),\n$$\n其中 $D$ 是待估算的固相扩散系数。初始条件为均匀浓度\n$$\nc(r,0) = c_0,\n$$\n边界条件为中心对称\n$$\n\\left. \\frac{\\partial c}{\\partial r} \\right|_{r=0} = 0,\n$$\n以及与质量守恒通过锂嵌入关联的表面指定摩尔通量 $J$（向内嵌入为正），\n$$\n- D \\left. \\frac{\\partial c}{\\partial r} \\right|_{r=R} = J.\n$$\n\n假设端电压主要由开路电位随表面浓度的变化决定，并围绕初始状态将其线性化为\n$$\nU(t) = U_0 + k \\left( c(R,t) - c_0 \\right),\n$$\n其中 $k$ 是开路电位相对于固相浓度的局部斜率，单位为伏特乘以立方米每摩尔，$U_0$ 是初始开路电压，$c(R,t)$ 是表面浓度。在所考虑的瞬态时间内，对于小电流，当动力学和电解质对电压的贡献可忽略不计时，此近似有效。\n\n您的程序必须：\n- 使用在空间和时间上稳定的隐式离散化方法，为球形扩散方程实现一个时间步进求解器，该求解器需强制执行对称性和通量边界条件。使用均匀的径向网格。求解器必须能为给定的 $D$、$R$、$J$、$c_0$、最终时间 $T$ 和时间步长 $\\Delta t$ 计算出 $c(R,t)$。\n- 使用已知的“真实”扩散系数 $D_{\\text{true}}$ 从模型生成合成电压时间序列数据 $U_{\\text{meas}}(t)$，并添加指定标准差的零均值高斯小噪声。\n- 通过最小化测量电压与模型预测电压在时间网格上的平方差之和，来构建并求解反问题以估算 $D$，\n$$\n\\min_{D_{\\min} \\le D \\le D_{\\max}} \\sum_{n=1}^{N_t} \\left( U_{\\text{model}}(t_n; D) - U_{\\text{meas}}(t_n) \\right)^2,\n$$\n其中 $N_t$ 是时间点数，$D_{\\min}$ 和 $D_{\\max}$ 是对 $D$ 的物理上合理的界限。使用稳健的有界标量最小化方法。\n\n所有物理量和常数必须使用国际单位制（SI）。将最终估算的扩散系数以米平方每秒（m^2/s）为单位，表示为浮点数。\n\n在以下离散近似要求下实现求解器：\n- 为保证稳定性，使用后向欧拉时间离散。\n- 在具有节点 $r_i = i \\Delta r$（其中 $i = 0, 1, \\dots, N$，$N$ 是径向区间数）的均匀网格上，对球形拉普拉斯算子使用二阶有限差分空间离散。使用适当的离散近似来强制执行中心对称条件，并通过引入一个鬼点将表面通量边界条件转换为表面节点方程中的源项来处理。\n- 确保数值稳定性和足够的准确性，以解析所提供参数集的瞬态响应。\n\n测试套件：\n为以下三个参数集运行您的程序。在每种情况下，使用指定的 $D_{\\text{true}}$ 生成合成数据，估算 $D$，并返回估算值。最终输出必须是包含三种情况下估算的 $D$ 值的单行文本，格式如指定。\n\n案例 1（一般情况）：\n- 颗粒半径 $R = 5 \\times 10^{-6}$ 米。\n- 真实固相扩散系数 $D_{\\text{true}} = 2 \\times 10^{-13}$ 米平方每秒。\n- 表面恒定摩尔通量 $J = 1 \\times 10^{-6}$ 摩尔每平方米每秒。\n- 初始浓度 $c_0 = 20000$ 摩尔每立方米。\n- 开路电压参数：$U_0 = 3.7$ 伏特，$k = -1 \\times 10^{-4}$ 伏特乘以立方米每摩尔。\n- 最终时间 $T = 100$ 秒，时间步长 $\\Delta t = 0.2$ 秒。\n- 径向区间数 $N = 30$（即 31 个节点）。\n- 附加高斯电压噪声标准差 $\\sigma = 5 \\times 10^{-4}$ 伏特。\n\n案例 2（慢扩散，较大颗粒）：\n- 颗粒半径 $R = 1.0 \\times 10^{-5}$ 米。\n- 真实固相扩散系数 $D_{\\text{true}} = 1 \\times 10^{-14}$ 米平方每秒。\n- 表面恒定摩尔通量 $J = 5 \\times 10^{-7}$ 摩尔每平方米每秒。\n- 初始浓度 $c_0 = 15000$ 摩尔每立方米。\n- 开路电压参数：$U_0 = 3.8$ 伏特，$k = -8 \\times 10^{-5}$ 伏特乘以立方米每摩尔。\n- 最终时间 $T = 300$ 秒，时间步长 $\\Delta t = 0.5$ 秒。\n- 径向区间数 $N = 40$。\n- 附加高斯电压噪声标准差 $\\sigma = 1 \\times 10^{-3}$ 伏特。\n\n案例 3（快扩散，较小颗粒）：\n- 颗粒半径 $R = 2 \\times 10^{-6}$ 米。\n- 真实固相扩散系数 $D_{\\text{true}} = 5 \\times 10^{-11}$ 米平方每秒。\n- 表面恒定摩尔通量 $J = 2 \\times 10^{-6}$ 摩尔每平方米每秒。\n- 初始浓度 $c_0 = 22000$ 摩尔每立方米。\n- 开路电压参数：$U_0 = 3.6$ 伏特，$k = -1.2 \\times 10^{-4}$ 伏特乘以立方米每摩尔。\n- 最终时间 $T = 10$ 秒，时间步长 $\\Delta t = 0.02$ 秒。\n- 径向区间数 $N = 25$。\n- 附加高斯电压噪声标准差 $\\sigma = 2 \\times 10^{-4}$ 伏特。\n\n所有情况下反问题中扩散系数的界限必须为 $D_{\\min} = 1 \\times 10^{-15}$ 米平方每秒和 $D_{\\max} = 1 \\times 10^{-9}$ 米平方每秒。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 $[d_1,d_2,d_3]$，其中 $d_i$ 是案例 $i$ 的估算扩散系数，以米平方每秒（m^2/s）为单位，表示为浮点数。",
            "solution": "该问题要求估算球形电极颗粒的固相扩散系数 $D$，这是使用 Doyle-Fuller-Newman (DFN) 框架对锂离子电池进行建模的一个基本问题。该方法包括两个主要部分：首先，为扩散的控制偏微分方程（PDE）开发一个数值求解器（正问题）；其次，在优化程序中使用该求解器，将模型预测与合成的含噪声电压数据进行拟合（反问题）。\n\n### I. 正问题：求解球形扩散方程\n\n半径为 $R$ 的球形颗粒内锂的浓度 $c(r,t)$ 由球坐标系下的菲克第二定律控制：\n$$\n\\frac{\\partial c}{\\partial t} = \\frac{1}{r^2} \\frac{\\partial}{\\partial r} \\left( D r^2 \\frac{\\partial c}{\\partial r} \\right) = D \\left( \\frac{\\partial^2 c}{\\partial r^2} + \\frac{2}{r} \\frac{\\partial c}{\\partial r} \\right) \\quad \\text{for } 0  r  R, t > 0\n$$\n其中 $D$ 是恒定的固相扩散系数。\n\n初始和边界条件为：\n1.  **初始条件**：在 $t=0$ 时浓度均匀为 $c_0$。\n    $$ c(r,0) = c_0 $$\n2.  **中心对称**：由于对称性，颗粒中心无通量。\n    $$ \\left. \\frac{\\partial c}{\\partial r} \\right|_{r=0} = 0 $$\n3.  **表面通量**：表面有恒定的摩尔通量 $J$，代表锂的嵌入/脱出。\n    $$ -D \\left. \\frac{\\partial c}{\\partial r} \\right|_{r=R} = J $$\n\n为了数值求解此偏微分方程，我们采用有限差分法。我们将空间域 $r \\in [0, R]$ 离散为 $N$ 个宽度为 $\\Delta r = R/N$ 的区间，节点为 $r_i = i \\Delta r$，其中 $i=0, 1, \\dots, N$。时间域用恒定的步长 $\\Delta t$ 进行离散，时间点为 $t_k = k \\Delta t$。令 $c_i^k \\approx c(r_i, t_k)$。\n\n我们对时间导数使用后向欧拉法，该方法是无条件稳定的：\n$$\n\\frac{\\partial c}{\\partial t} \\approx \\frac{c_i^{k+1} - c_i^k}{\\Delta t}\n$$\n\n对于空间导数，我们使用二阶中心差分：\n$$\n\\frac{\\partial c}{\\partial r} \\bigg|_{r_i} \\approx \\frac{c_{i+1}^{k+1} - c_{i-1}^{k+1}}{2 \\Delta r}\n$$\n$$\n\\frac{\\partial^2 c}{\\partial r^2} \\bigg|_{r_i} \\approx \\frac{c_{i+1}^{k+1} - 2c_i^{k+1} + c_{i-1}^{k+1}}{(\\Delta r)^2}\n$$\n\n#### 离散化方程\n\n**对于内部节点（$1 \\le i \\le N-1$）：**\n将有限差分近似代入偏微分方程得到：\n$$\n\\frac{c_i^{k+1} - c_i^k}{\\Delta t} = D \\left( \\frac{c_{i+1}^{k+1} - 2c_i^{k+1} + c_{i-1}^{k+1}}{(\\Delta r)^2} + \\frac{2}{i \\Delta r} \\frac{c_{i+1}^{k+1} - c_{i-1}^{k+1}}{2 \\Delta r} \\right)\n$$\n令 $\\alpha = D \\Delta t / (\\Delta r)^2$，我们可以将其整理成一个线性方程，关联了步骤 $k+1$ 的未知浓度与步骤 $k$ 的已知浓度：\n$$\n-\\alpha \\left(1 - \\frac{1}{i}\\right) c_{i-1}^{k+1} + (1+2\\alpha) c_i^{k+1} - \\alpha \\left(1 + \\frac{1}{i}\\right) c_{i+1}^{k+1} = c_i^k\n$$\n\n**对于中心节点（$r_0=0$, $i=0$）：**\n$2/r$ 项产生一个奇点。我们使用洛必达法则来证明，当 $r \\to 0$ 时，球形拉普拉斯算子简化为 $3D \\frac{\\partial^2 c}{\\partial r^2}$。对称条件意味着 $c_{-1}^{k+1} = c_{1}^{k+1}$。中心处的离散方程为：\n$$\n\\frac{c_0^{k+1} - c_0^k}{\\Delta t} = 3D \\frac{c_1^{k+1} - 2c_0^{k+1} + c_{-1}^{k+1}}{(\\Delta r)^2} = 6D \\frac{c_1^{k+1} - c_0^{k+1}}{(\\Delta r)^2}\n$$\n整理后得到：\n$$\n(1+6\\alpha) c_0^{k+1} - 6\\alpha c_1^{k+1} = c_0^k\n$$\n\n**对于表面节点（$r_N=R$, $i=N$）：**\n为保持二阶精度，我们使用一个位于 $r_{N+1} = R + \\Delta r$ 的鬼点。通量边界条件在 $r_N=R$ 处使用中心差分进行离散：\n$$\n-D \\frac{c_{N+1}^{k+1} - c_{N-1}^{k+1}}{2 \\Delta r} = J  \\implies c_{N+1}^{k+1} = c_{N-1}^{k+1} - \\frac{2J\\Delta r}{D}\n$$\n将此代入节点 $i=N$ 处的离散偏微分方程：\n$$\n\\frac{c_N^{k+1} - c_N^k}{\\Delta t} = D \\left( \\frac{c_{N+1}^{k+1} - 2c_N^{k+1} + c_{N-1}^{k+1}}{(\\Delta r)^2} + \\frac{2}{R} \\frac{c_{N+1}^{k+1} - c_{N-1}^{k+1}}{2 \\Delta r} \\right)\n$$\n代入 $c_{N+1}^{k+1}$ 的表达式可以进行简化。一个更稳健的方法是直接将通量表达式代入第二项：\n$$\n\\frac{c_N^{k+1} - c_N^k}{\\Delta t} = D \\frac{c_{N+1}^{k+1} - 2c_N^{k+1} + c_{N-1}^{k+1}}{(\\Delta r)^2} - \\frac{2J}{R}\n$$\n现在，代入鬼点 $c_{N+1}^{k+1}$：\n$$\n\\frac{c_N^{k+1} - c_N^k}{\\Delta t} = D \\frac{2c_{N-1}^{k+1} - 2c_N^{k+1}}{(\\Delta r)^2} - \\frac{2J}{\\Delta r} - \\frac{2J}{R}\n$$\n整理并使用 $R=N\\Delta r$ 得到：\n$$\n-2\\alpha c_{N-1}^{k+1} + (1+2\\alpha) c_N^{k+1} = c_N^k - \\frac{2J\\Delta t}{\\Delta r} \\left(1 + \\frac{1}{N}\\right)\n$$\n\n关于 $c_i^{k+1}$（$i=0, \\dots, N$）的 $N+1$ 个线性方程组构成了一个三对角矩阵系统 $\\mathbf{M} \\mathbf{c}^{k+1} = \\mathbf{d}^k$，可以在每个时间步长高效求解。矩阵 $\\mathbf{M}$ 不随时间变化，因此只需组装一次。我们为此使用 `scipy.linalg.solve_banded`。\n\n### II. 反问题：参数估计\n\n目标是估算 $D$。我们首先使用一个已知的真实扩散系数 $D_{\\text{true}}$ 通过正演模型生成合成的“测量”电压数据 $U_{\\text{meas}}(t)$，并添加高斯噪声：\n$$\nU_{\\text{meas}}(t_n) = U_{\\text{true}}(t_n) + \\mathcal{N}(0, \\sigma^2)\n$$\n其中 $U_{\\text{true}}(t_n) = U_0 + k(c(R, t_n; D_{\\text{true}}) - c_0)$，而 $\\mathcal{N}(0, \\sigma^2)$ 是一个均值为 0、标准差为 $\\sigma$ 的正态分布随机变量。\n\n$D$ 的估计被构建为一个最小二乘最小化问题。我们在一个合理的范围 $[D_{\\min}, D_{\\max}]$ 内寻找 $D$ 的值，该值能最小化模型预测电压与合成数据之间的平方差之和：\n$$\n\\min_{D_{\\min} \\le D \\le D_{\\max}} \\mathcal{L}(D) = \\sum_{n=1}^{N_t} \\left( U_{\\text{model}}(t_n; D) - U_{\\text{meas}}(t_n) \\right)^2\n$$\n其中 $U_{\\text{model}}(t_n; D) = U_0 + k(c(R, t_n; D) - c_0)$ 是正演模型对一个试验系数 $D$ 预测的电压。这是一个标量有界优化问题，我们使用 `scipy.optimize.minimize_scalar` 并配合 'bounded' 方法来求解。\n\n### III. 实现细节\n\n该实现包含两个主要函数：\n1.  `solve_pde`：此函数实现正演模型。它接收包括试验 $D$ 在内的物理参数和数值参数（$T$, $\\Delta t$, $N$）作为输入。它组装三对角系统矩阵 $\\mathbf{M}$，并随时间迭代求解浓度分布，返回表面浓度时间序列 $c(R,t)$。\n2.  `solve`：这个主函数遍历所提供的三个测试案例。对于每个案例，它：\n    a. 使用 `solve_pde` 和 $D_{\\text{true}}$ 生成合成的含噪声电压数据 $U_{\\text{meas}}(t)$。为了可复现性，使用固定的随机种子。\n    b. 定义一个目标函数，该函数接收一个试验 $D$，调用 `solve_pde` 以获得模型预测的电压，并返回与 $U_{\\text{meas}}(t)$ 的平方误差和。\n    c. 调用 `scipy.optimize.minimize_scalar` 来寻找最小化目标函数的最优 $D$。\n    d. 收集估算的 $D$ 值，并将其格式化以用于最终输出。\n\n为每个案例选择的数值参数（$N$, $\\Delta t$）确保了数值稳定性和对不同时间尺度下扩散动力学的充分解析。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize_scalar\nfrom scipy.linalg import solve_banded\n\ndef solve_pde(D, R, J, c0, T, dt, N):\n    \"\"\"\n    Solves the spherical diffusion PDE using an implicit finite difference method.\n\n    Args:\n        D (float): Solid diffusion coefficient (m^2/s).\n        R (float): Particle radius (m).\n        J (float): Molar flux at the surface (mol/m^2/s).\n        c0 (float): Initial uniform concentration (mol/m^3).\n        T (float): Final time (s).\n        dt (float): Time step (s).\n        N (int): Number of radial intervals.\n\n    Returns:\n        tuple: A tuple containing:\n            - time_points (np.ndarray): Array of time points.\n            - c_surface (np.ndarray): Array of surface concentrations over time.\n    \"\"\"\n    dr = R / N\n    alpha = D * dt / (dr**2)\n    num_nodes = N + 1\n    \n    # Set up the tridiagonal matrix M in banded form for solve_banded.\n    # The matrix ab has shape (3, num_nodes) for kl=1, ku=1.\n    # ab[0,:] = super-diagonal (A[i, i+1])\n    # ab[1,:] = main diagonal (A[i, i])\n    # ab[2,:] = sub-diagonal (A[i, i-1])\n    ab = np.zeros((3, num_nodes))\n    \n    # Main diagonal\n    ab[1, 0] = 1.0 + 6.0 * alpha\n    ab[1, 1:] = 1.0 + 2.0 * alpha\n    \n    # Upper diagonal\n    ab[0, 1] = -6.0 * alpha\n    i_upper = np.arange(1, N)\n    ab[0, i_upper + 1] = -alpha * (1.0 + 1.0 / i_upper)\n    \n    # Lower diagonal\n    i_lower = np.arange(1, N)\n    # The j-th element of the i-th sub-diagonal is ab[i+ku, j]\n    # For sub-diagonal 1 (i=1), A[j+1, j] is ab[1+1, j].\n    # solve_banded expects ab[ku + i - j, j] = A[i,j].\n    # Lower diag: j = i-1 = ab[1 + i - (i-1), i-1] = ab[2, i-1] = A[i, i-1]\n    ab[2, i_lower - 1] = -alpha * (1.0 - 1.0 / i_lower)\n    # Surface node term A[N, N-1]\n    ab[2, N-1] = -2.0 * alpha\n\n    # Constant part of the RHS from the flux boundary condition\n    b_const = np.zeros(num_nodes)\n    if N > 0:\n        b_const[-1] = - (2.0 * J * dt / dr) * (1.0 + 1.0 / N)\n\n    # Time stepping\n    time_points = np.arange(0, T + dt, dt)\n    c = np.full(num_nodes, c0)\n    c_surface = np.zeros(len(time_points))\n    c_surface[0] = c0\n\n    for k in range(1, len(time_points)):\n        rhs = c + b_const\n        c = solve_banded((1, 1), ab, rhs, check_finite=False)\n        c_surface[k] = c[-1]\n    \n    return time_points, c_surface\n\ndef solve():\n    \"\"\"\n    Main function to run test cases for estimating the diffusion coefficient.\n    \"\"\"\n    # Use a fixed random seed for reproducible results\n    np.random.seed(0)\n\n    # Common parameters for optimization\n    D_min = 1e-15\n    D_max = 1e-9\n\n    test_cases = [\n        # Case 1 (general case)\n        {\n            \"R\": 5e-6, \"D_true\": 2e-13, \"J\": 1e-6, \"c0\": 20000,\n            \"U0\": 3.7, \"k\": -1e-4, \"T\": 100, \"dt\": 0.2, \"N\": 30,\n            \"sigma\": 5e-4\n        },\n        # Case 2 (slow diffusion, larger particle)\n        {\n            \"R\": 1.0e-5, \"D_true\": 1e-14, \"J\": 5e-7, \"c0\": 15000,\n            \"U0\": 3.8, \"k\": -8e-5, \"T\": 300, \"dt\": 0.5, \"N\": 40,\n            \"sigma\": 1e-3\n        },\n        # Case 3 (fast diffusion, smaller particle)\n        {\n            \"R\": 2e-6, \"D_true\": 5e-11, \"J\": 2e-6, \"c0\": 22000,\n            \"U0\": 3.6, \"k\": -1.2e-4, \"T\": 10, \"dt\": 0.02, \"N\": 25,\n            \"sigma\": 2e-4\n        }\n    ]\n\n    estimated_Ds = []\n\n    for params in test_cases:\n        # 1. Generate synthetic \"measured\" data\n        time_points, c_surf_true = solve_pde(\n            params[\"D_true\"], params[\"R\"], params[\"J\"], params[\"c0\"], \n            params[\"T\"], params[\"dt\"], params[\"N\"]\n        )\n        U_true = params[\"U0\"] + params[\"k\"] * (c_surf_true - params[\"c0\"])\n        noise = np.random.normal(0, params[\"sigma\"], len(U_true))\n        U_meas = U_true + noise\n\n        # 2. Define the objective function for minimization\n        def objective_func(D_trial):\n            _, c_surf_model = solve_pde(\n                D_trial, params[\"R\"], params[\"J\"], params[\"c0\"], \n                params[\"T\"], params[\"dt\"], params[\"N\"]\n            )\n            U_model = params[\"U0\"] + params[\"k\"] * (c_surf_model - params[\"c0\"])\n            return np.sum((U_model - U_meas)**2)\n\n        # 3. Perform bounded scalar minimization\n        result = minimize_scalar(\n            objective_func,\n            bounds=(D_min, D_max),\n            method='bounded'\n        )\n        estimated_Ds.append(result.x)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{d:.6e}' for d in estimated_Ds)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "电池的电压曲线深刻地反映了电极材料的热力学特性。例如，某些电极材料（如磷酸铁锂）在嵌锂过程中会发生相分离，这在宏观上表现为恒电流充放电过程中的一个恒压平台。本练习将探讨这一现象，要求你使用一个正则溶体模型来描述电极材料的自由能，并从热力学第一性原理出发，计算电压平台的持续时间。通过将材料的微观自由能与电池的宏观电化学响应联系起来，这项实践有助于你更深入地理解DFN模型的热力学基础。",
            "id": "4242973",
            "problem": "在一个锂离子电池中，一个球形正极颗粒在 Doyle–Fuller–Newman 框架下，采用单颗粒简化进行建模，该模型在恒电流操作下，并忽略电解质和电子的欧姆损耗。目标是对比固溶体热力学与相分离热力学对于嵌入主体的不同影响，并量化当存在互溶间隙时，放电过程中的电压平台持续时间。\n\n假设以下物理上一致的设定。令嵌入分数 $\\,\\theta \\in (0,1)\\,$ 定义为 $\\,\\theta = c_s/c_{\\max}\\,$，其中 $\\,c_s\\,$ 是固相锂浓度，$\\,c_{\\max}\\,$ 是最大位点浓度。该颗粒是一个半径为 $\\,R\\,$、表面积为 $\\,S\\,$、体积为 $\\,V\\,$ 的球体，满足 $\\,S/V = 3/R\\,$。在颗粒表面施加恒定的界面电流密度 $\\,j\\,$（单位为 $\\mathrm{A/m^2}$）时，摩尔嵌入通量 $\\,j_n\\,$（单位为 $\\mathrm{mol/(m^2\\cdot s)}$）遵循 $\\,j = F\\, j_n\\,$，其中 $\\,F\\,$ 是法拉第常数。质量守恒意味着空间平均的固相浓度演变遵循以下公式：\n$$\n\\frac{d c_s}{dt} = \\frac{S}{V}\\, j_n = \\frac{3}{R}\\, j_n,\n$$\n因此，嵌入分数遵循：\n$$\n\\frac{d \\theta}{dt} = \\frac{1}{c_{\\max}} \\frac{d c_s}{dt} = \\frac{3 j}{R\\,F\\,c_{\\max}}.\n$$\n考虑在温度 $\\,T\\,$ 下的等温操作，并在评估在任何热力学定义的两相区域内停留的时间时，忽略任何动力学限制。正极的电化学热力学由每个嵌入位点的摩尔自由能密度 $\\,g(\\theta)\\,$ 描述。需要检验两种不同的模型：\n\n- 固溶体模型：一个凸的理想溶液自由能，\n$$\ng_{\\mathrm{ss}}(\\theta) = R_g T\\left[\\theta \\ln \\theta + (1-\\theta)\\ln (1-\\theta)\\right],\n$$\n其中 $\\,R_g\\,$ 是普适气体常数。\n\n- 相分离模型：一个具有对称相互作用参数 $\\,\\Omega\\,$ 的正则溶液自由能，\n$$\ng_{\\mathrm{rs}}(\\theta) = R_g T\\left[\\theta \\ln \\theta + (1-\\theta)\\ln (1-\\theta)\\right] + \\Omega\\, \\theta(1-\\theta).\n$$\n\n相关的化学势由热力学恒等式定义：\n$$\n\\mu(\\theta) = \\frac{\\partial g(\\theta)}{\\partial \\theta}.\n$$\n当 $\\,\\Omega \\le 2 R_g T\\,$ 时，自由能 $\\,g_{\\mathrm{rs}}(\\theta)\\,$ 是凸的，材料表现为固溶体。当 $\\,\\Omega > 2 R_g T\\,$ 时，存在互溶间隙。在互溶间隙中，公切线构造定义了两个共存的组分 $\\,\\theta_1\\,$ 和 $\\,\\theta_2\\,$ 以及一个平台化学势 $\\,\\mu_t\\,$，使得：\n$$\n\\mu(\\theta_1) = \\mu(\\theta_2) = \\mu_t,\n\\qquad\ng(\\theta_2) - g(\\theta_1) = \\mu_t\\,(\\theta_2 - \\theta_1),\n$$\n且 $\\,\\theta_1  \\theta_2\\,$。在恒电流放电过程中，当空间平均 $\\,\\theta\\,$ 穿过区间 $[\\theta_1,\\theta_2]$ 时，电池电压被锁定在一个平台上（此处为计算平台持续时间而忽略了动力学过电势），在平台上的停留时间等于平均组分扫过放电窗口所重叠的区间所需的时间。\n\n你的任务是实现一个程序，针对一组测试用例，使用上述第一性原理热力学定义和质量守恒，计算相分离正则溶液模型在放电过程中的电压平台持续时间（以秒为单位），如果不存在互溶间隙，则报告平台持续时间为零。在所有计算中，使用以下常数：$\\,T = 298.15\\,\\mathrm{K}$，$\\,R_g = 8.314462618\\,\\mathrm{J/(mol\\cdot K)}$，$\\,F = 96485.33212\\,\\mathrm{C/mol}$，$\\,c_{\\max} = 25000\\,\\mathrm{mol/m^3}$。放电从初始嵌入分数 $\\,\\theta_0 = 0.10\\,$ 到最终分数 $\\,\\theta_f = 0.90\\,$。\n\n对于每个测试用例，你必须：\n1. 通过评估条件 $\\,\\Omega > 2 R_g T\\,$ 来确定是否存在互溶间隙。\n2. 如果存在互溶间隙，严格基于 $\\,g_{\\mathrm{rs}}(\\theta)\\,$，使用上面给出的公切线条件计算共存组分 $\\,\\theta_1\\,$ 和 $\\,\\theta_2\\,$。\n3. 计算区间 $[\\theta_1,\\theta_2]$ 与放电窗口 $[\\theta_0,\\theta_f]$ 的重叠部分 $\\,\\Delta \\theta\\,$。\n4. 使用质量守恒速率计算平台持续时间：\n$$\nt_{\\mathrm{plateau}} = \\frac{\\Delta \\theta}{\\frac{3 j}{R\\,F\\,c_{\\max}}}.\n$$\n如果没有互溶间隙或重叠 $\\,\\Delta \\theta = 0\\,$，则设 $\\,t_{\\mathrm{plateau}} = 0\\,$。将每个平台持续时间以秒表示，并四舍五入到六位小数。\n\n测试套件：\n- 案例 1（正常路径，清晰的相分离）：$\\,\\Omega = 7000\\,\\mathrm{J/mol}\\,$, $\\,j = 5\\,\\mathrm{A/m^2}\\,$, $\\,R = 5\\times 10^{-6}\\,\\mathrm{m}\\,$.\n- 案例 2（固溶体，无相分离）：$\\,\\Omega = 0\\,\\mathrm{J/mol}\\,$, $\\,j = 5\\,\\mathrm{A/m^2}\\,$, $\\,R = 5\\times 10^{-6}\\,\\mathrm{m}\\,$.\n- 案例 3（边界，起始阈值）：$\\,\\Omega = 2 R_g T\\,\\mathrm{J/mol}\\,$, $\\,j = 20\\,\\mathrm{A/m^2}\\,$, $\\,R = 5\\times 10^{-6}\\,\\mathrm{m}\\,$.\n\n最终输出格式：\n你的程序应生成一行输出，其中包含三个案例的平台持续时间，格式为一个逗号分隔的列表，用方括号括起来，单位为秒，每个值四舍五入到六位小数（例如，\"[t1,t2,t3]\"）。",
            "solution": "该问题要求计算在锂离子电池中，一个球形正极颗粒在恒电流放电过程中的电压平台持续时间。该计算采用 Doyle-Fuller-Newman 框架的单颗粒简化模型。分析对比了固溶体材料与相分离材料，后者通过正则溶液模型描述其自由能。\n\n我们分析的第一步是建立施加电流与颗粒充电状态变化之间的关系，充电状态由平均嵌入分数 $\\,\\theta\\,$ 量化。问题给出了在恒定界面电流密度 $\\,j\\,$ 下 $\\,\\theta\\,$ 变化率的控制方程：\n$$\n\\frac{d\\theta}{dt} = \\frac{3 j}{R\\,F\\,c_{\\max}}\n$$\n其中 $\\,R\\,$ 是颗粒半径，$\\,F\\,$ 是法拉第常数，$\\,c_{\\max}\\,$ 是最大固相浓度。由于变化率 $\\,d\\theta/dt\\,$ 是恒定的，平均嵌入分数扫过宽度为 $\\,\\Delta\\theta\\,$ 的区间所需的时间 $\\,t_{\\mathrm{plateau}}\\,$ 由下式给出：\n$$\nt_{\\mathrm{plateau}} = \\frac{\\Delta\\theta}{\\frac{d\\theta}{dt}} = \\frac{\\Delta\\theta \\cdot R\\,F\\,c_{\\max}}{3j}\n$$\n问题的核心在于确定与电压平台对应的区间宽度 $\\,\\Delta\\theta\\,$。\n\n电压平台是电极材料中两相共存的直接热力学结果。问题给出了相分离正则溶液模型的摩尔自由能密度：\n$$\ng_{\\mathrm{rs}}(\\theta) = R_g T\\left[\\theta \\ln \\theta + (1-\\theta)\\ln (1-\\theta)\\right] + \\Omega\\, \\theta(1-\\theta)\n$$\n这里，$\\,R_g\\,$ 是普适气体常数，$\\,T\\,$ 是绝对温度，$\\,\\Omega\\,$ 是相互作用参数。相关的化学势 $\\,\\mu(\\theta)\\,$ 通过对 $\\,\\theta\\,$ 求导得到：\n$$\n\\mu(\\theta) = \\frac{\\partial g_{\\mathrm{rs}}}{\\partial \\theta} = R_g T \\ln\\left(\\frac{\\theta}{1-\\theta}\\right) + \\Omega(1 - 2\\theta)\n$$\n当且仅当自由能函数 $\\,g_{\\mathrm{rs}}(\\theta)\\,$ 在定义域 $\\,\\theta \\in (0,1)\\,$ 内不处处为凸时，存在导致相分离的互溶间隙。此条件在相互作用参数 $\\,\\Omega\\,$ 超过一个临界值时满足，即 $\\,\\Omega > 2 R_g T\\,$。如果 $\\,\\Omega \\le 2 R_g T\\,$，材料表现为固溶体，不形成互溶间隙，平台持续时间为零。\n\n当 $\\,\\Omega > 2 R_g T\\,$ 时，系统分离成两个共存的相，其锂浓度对应于嵌入分数 $\\,\\theta_1\\,$ 和 $\\,\\theta_2\\,$（$\\,\\theta_1  \\theta_2\\,$）。这些组分被称为双节线点，由自由能曲线上的公切线构造确定。其两个条件是：\n1.  相等的化学势：$\\,\\mu(\\theta_1) = \\mu(\\theta_2)\\,$\n2.  共同的切线斜率：$\\,\\displaystyle \\frac{g_{\\mathrm{rs}}(\\theta_2) - g_{\\mathrm{rs}}(\\theta_1)}{\\theta_2 - \\theta_1} = \\mu(\\theta_1)\\,$\n\n对于对称的正则溶液模型，双节线组分关于 $\\,\\theta = 0.5\\,$ 对称，这意味着 $\\,\\theta_2 = 1 - \\theta_1\\,$。将此对称性代入第一个条件 $\\,\\mu(\\theta_1) = \\mu(1-\\theta_1)\\,$，得到：\n$$\nR_g T \\ln\\left(\\frac{\\theta_1}{1-\\theta_1}\\right) + \\Omega(1 - 2\\theta_1) = R_g T \\ln\\left(\\frac{1 - \\theta_1}{\\theta_1}\\right) + \\Omega(1 - 2(1 - \\theta_1))\n$$\n$$\nR_g T \\ln\\left(\\frac{\\theta_1}{1-\\theta_1}\\right) + \\Omega(1 - 2\\theta_1) = -R_g T \\ln\\left(\\frac{\\theta_1}{1-\\theta_1}\\right) - \\Omega(1 - 2\\theta_1)\n$$\n这简化为关于 $\\,\\theta_1\\,$ 的单个超越方程：\n$$\n\\ln\\left(\\frac{\\theta_1}{1-\\theta_1}\\right) = \\frac{\\Omega}{R_g T}(2\\theta_1 - 1)\n$$\n可以证明，将对称条件 $\\,\\theta_2 = 1-\\theta_1\\,$ 应用于第二个公切线条件会得到相同的方程。对于 $\\,\\Omega > 2 R_g T\\,$，该方程在 $\\,\\theta_1 \\in (0, 0.5)\\,$ 中有一个非平凡根，必须通过数值方法求解。\n\n一旦确定了 $\\,\\theta_1\\,$ 和 $\\,\\theta_2\\,$，当平均嵌入分数 $\\,\\theta\\,$ 扫过区间 $\\,[\\theta_1, \\theta_2]\\,$ 时，材料会展现出恒定的化学势（因此有恒定的开路电压）。问题指定了一个从初始状态 $\\,\\theta_0 = 0.10\\,$ 到最终状态 $\\,\\theta_f = 0.90\\,$ 的放电过程。平台持续时间对应于穿过互溶间隙与该放电窗口重叠部分所花费的时间。这个重叠部分的宽度 $\\,\\Delta\\theta\\,$ 由两个区间 $\\,[\\theta_1, \\theta_2]\\,$ 和 $\\,[\\theta_0, \\theta_f]\\,$ 的交集长度给出：\n$$\n\\Delta\\theta = \\max(0, \\min(\\theta_2, \\theta_f) - \\max(\\theta_1, \\theta_0))\n$$\n如果 $\\,\\Delta\\theta = 0\\,$ 或者不存在互溶间隙，则平台持续时间 $\\,t_{\\mathrm{plateau}}\\,$ 为 $\\,0\\,$。\n\n每个测试用例的步骤如下：\n1.  定义常数：$\\,T = 298.15\\,\\mathrm{K}$，$\\,R_g = 8.314462618\\,\\mathrm{J/(mol\\cdot K)}$，$\\,F = 96485.33212\\,\\mathrm{C/mol}$，$\\,c_{\\max} = 25000\\,\\mathrm{mol/m^3}\\,$，$\\,\\theta_0 = 0.10\\,$，$\\,\\theta_f = 0.90\\,$。\n2.  对于一组给定的参数 $\\,(\\Omega, j, R)\\,$，计算临界相互作用能 $\\,E_{crit} = 2 R_g T\\,$。\n3.  如果 $\\,\\Omega \\le E_{crit}\\,$，设置 $\\,t_{\\mathrm{plateau}} = 0\\,$。\n4.  如果 $\\,\\Omega > E_{crit}\\,$，数值求解超越方程以得到 $\\,\\theta_1 \\in (0, 0.5)\\,$。然后，设置 $\\,\\theta_2 = 1 - \\theta_1\\,$。\n5.  如上定义，计算重叠宽度 $\\,\\Delta\\theta\\,$。\n6.  使用质量守恒公式计算平台持续时间：$\\,t_{\\mathrm{plateau}} = (\\Delta\\theta \\cdot R\\,F\\,c_{\\max}) / (3j)\\,$。\n7.  以秒为单位报告结果，四舍五入到六位小数。\n这种系统化的方法为问题提供了严谨且有物理基础的解决方案。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves for the voltage plateau duration in a phase-separating electrode particle\n    for a given set of test cases.\n    \"\"\"\n    \n    # Define physical constants and problem parameters\n    T = 298.15  # Temperature [K]\n    R_g = 8.314462618  # Universal gas constant [J/(mol·K)]\n    F = 96485.33212  # Faraday constant [C/mol]\n    C_MAX = 25000.0  # Maximum site concentration [mol/m^3]\n    THETA_0 = 0.10  # Initial intercalation fraction (start of discharge)\n    THETA_F = 0.90  # Final intercalation fraction (end of discharge)\n\n    # Test suite from the problem statement\n    test_cases = [\n        # Case 1: Happy path, clear phase separation\n        {\"Omega\": 7000.0, \"j\": 5.0, \"R\": 5e-6},\n        # Case 2: Solid solution, no phase separation\n        {\"Omega\": 0.0, \"j\": 5.0, \"R\": 5e-6},\n        # Case 3: Boundary, onset threshold\n        {\"Omega\": 2 * R_g * T, \"j\": 20.0, \"R\": 5e-6},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        Omega = case[\"Omega\"]\n        j = case[\"j\"]\n        R = case[\"R\"]\n        \n        t_plateau = calculate_plateau_duration(Omega, j, R, T, R_g, F, C_MAX, THETA_0, THETA_F)\n        results.append(f\"{t_plateau:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_plateau_duration(Omega, j, R, T, R_g, F, c_max, theta_0, theta_f):\n    \"\"\"\n    Calculates the plateau duration for a single set of parameters.\n\n    Args:\n        Omega (float): Regular solution interaction parameter [J/mol].\n        j (float): Applied current density [A/m^2].\n        R (float): Particle radius [m].\n        T (float): Temperature [K].\n        R_g (float): Universal gas constant [J/(mol·K)].\n        F (float): Faraday constant [C/mol].\n        c_max (float): Maximum site concentration [mol/m^3].\n        theta_0 (float): Initial intercalation fraction.\n        theta_f (float): Final intercalation fraction.\n\n    Returns:\n        float: The calculated plateau duration in seconds.\n    \"\"\"\n    \n    # Step 1: Determine whether a miscibility gap exists.\n    e_crit = 2 * R_g * T\n    if Omega = e_crit:\n        # No miscibility gap, so plateau duration is zero.\n        return 0.0\n\n    # Step 2: If a miscibility gap exists, compute the coexisting compositions.\n    # The transcendental equation to solve for theta_1 is:\n    # ln(theta/(1-theta)) - (Omega/(R_g*T))*(2*theta - 1) = 0\n    # We define a function whose root we seek in the interval (0, 0.5).\n    A = Omega / (R_g * T)\n    def root_func(theta):\n        return np.log(theta / (1 - theta)) - A * (2 * theta - 1)\n\n    # Use a robust numerical root-finder (Brent's method) to find theta_1.\n    # The search interval is (0, 0.5), but we use a small epsilon to avoid division by zero.\n    try:\n        # theta_1 is the root in the lower half of the composition range\n        theta_1 = brentq(root_func, 1e-9, 0.5 - 1e-9)\n        # Due to symmetry of the regular solution model, theta_2 = 1 - theta_1.\n        theta_2 = 1 - theta_1\n    except ValueError:\n        # Should not happen for Omega  e_crit, but included for robustness.\n        return 0.0\n\n    # Step 3: Compute the overlap Delta_theta of the miscibility gap with the discharge window.\n    # Miscibility gap interval: [theta_1, theta_2]\n    # Discharge window interval: [theta_0, theta_f]\n    overlap_start = max(theta_1, theta_0)\n    overlap_end = min(theta_2, theta_f)\n    \n    Delta_theta = max(0, overlap_end - overlap_start)\n\n    if Delta_theta == 0:\n        return 0.0\n\n    # Step 4: Compute the plateau duration.\n    # d(theta)/dt = (3 * j) / (R * F * c_max)\n    d_theta_dt = (3 * j) / (R * F * c_max)\n    \n    t_plateau = Delta_theta / d_theta_dt\n    \n    return t_plateau\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "可靠的计算模型不仅需要正确地实现物理方程，还需要验证数值解法的准确性。本练习聚焦于一个具有精确解析解的简化扩散问题，旨在培养严谨的数值验证习惯。你将实现一个标准的数值格式（Crank–Nicolson方法），并通过在不同网格密度下计算其与解析解的误差，来验证该格式的理论收敛阶。这是代码验证中的一个基本步骤，对于确保模拟结果的可靠性至关重要。",
            "id": "4242995",
            "problem": "考虑在零界面反应电流和恒定温度条件下，锂离子电池Doyle-Fuller-Newman模型中的电解质质量平衡。在此极限情况下，电解质盐浓度的控制方程简化为菲克扩散。令 $c(x,t)$ 表示电解质盐浓度（单位：$\\mathrm{mol/m^3}$），$D$ 表示电解质中的盐扩散系数（单位：$\\mathrm{m^2/s}$），$x \\in [0,L]$ 表示贯穿电池的坐标（单位：$\\mathrm{m}$），$t \\ge 0$ 表示时间（单位：$\\mathrm{s}$）。控制方程和边界条件为\n$$\n\\frac{\\partial c}{\\partial t} = D \\frac{\\partial^2 c}{\\partial x^2}, \\quad \\frac{\\partial c}{\\partial x}(0,t) = 0, \\quad \\frac{\\partial c}{\\partial x}(L,t) = 0,\n$$\n初始条件由单一余弦模态指定：\n$$\nc(x,0) = c_{\\mathrm{ref}} + a \\cos\\left(\\frac{\\pi x}{L}\\right),\n$$\n其中，$c_{\\mathrm{ref}}$ 是一个恒定的参考浓度（单位：$\\mathrm{mol/m^3}$），$a$ 是一个振幅（单位：$\\mathrm{mol/m^3}$）。\n\n仅从质量守恒和菲克扩散定律出发，使用带有无通量（诺伊曼）边界条件的二阶、均匀网格、中心差分格式对空间算子进行离散化，并使用二阶隐式Crank-Nicolson方法对时间进行离散化。将所得格式在计算机程序中实现，并通过与从第一性原理推导出的精确解进行比较，来量化最终时刻的离散化误差。然后，对于一系列网格细化，通过对数据 $\\log(e(\\Delta x))$ 与 $\\log(\\Delta x)$ 进行线性拟合，来估计观测到的空间收敛阶 $p$，其中 $e(\\Delta x)$ 是在最终时刻用连续 $\\mathrm{L^2}$ 范数测量的数值误差。\n\n您必须遵守以下要求：\n- 空间域为 $[0,L]$，使用包含 $M$ 个区间的均匀网格，因此 $\\Delta x = L/M$，其中对于每个测试用例，$M \\in \\{20, 40, 80, 160\\}$。\n- 通过在离散拉普拉斯算子中对边界节点进行适当处理，以二阶精度施加诺伊曼边界，使其与物理上的无通量条件一致。\n- 使用Crank-Nicolson方法，时间步长 $\\Delta t$ 根据 $\\Delta t = \\beta \\, \\Delta x^2 / D$ 选择，所有测试中固定 $\\beta = 2.0$。计算推进至 $t_{\\mathrm{final}} = N_t \\Delta t$，其中 $N_t$ 是最接近 $T/\\Delta t$ 的整数。\n- 精确解应通过分离变量法推导，并用于计算在 $t_{\\mathrm{final}}$ 时的误差。使用由矩形法则近似的连续 $\\mathrm{L^2}$ 范数来测量误差 $e(\\Delta x)$：\n$$\ne(\\Delta x) = \\left( \\Delta x \\sum_{i=0}^{M} \\left[c_i^{\\mathrm{num}}(t_{\\mathrm{final}}) - c^{\\mathrm{exact}}(x_i,t_{\\mathrm{final}})\\right]^2 \\right)^{1/2},\n$$\n其中 $x_i = i \\Delta x$，$c_i^{\\mathrm{num}}(t_{\\mathrm{final}})$ 是在网格点上的数值解。\n- 对于每个测试用例，通过对网格序列 $\\{20, 40, 80, 160\\}$ 上的 $\\log(e(\\Delta x))$ 与 $\\log(\\Delta x)$ 进行线性拟合来估计 $p$，并报告保留三位小数的 $p$ 值。\n\n物理单位和常数：\n- 所有带物理单位的量报告如下：$D$ 的单位为 $\\mathrm{m^2/s}$，$L$ 的单位为 $\\mathrm{m}$，$T$ 的单位为 $\\mathrm{s}$，$c_{\\mathrm{ref}}$ 和 $a$ 的单位为 $\\mathrm{mol/m^3}$。\n- 不涉及角度；无需角度单位。\n- 不要使用百分比；所有比率必须是小数或分数。\n\n测试套件：\n- 案例A（理想路径）：$D = 1.0 \\times 10^{-10}\\ \\mathrm{m^2/s}$，$L = 100 \\times 10^{-6}\\ \\mathrm{m}$，$T = 10\\ \\mathrm{s}$，$c_{\\mathrm{ref}} = 1000\\ \\mathrm{mol/m^3}$，$a = 100\\ \\mathrm{mol/m^3}$。\n- 案例B（快速扩散）：$D = 5.0 \\times 10^{-10}\\ \\mathrm{m^2/s}$，$L = 50 \\times 10^{-6}\\ \\mathrm{m}$，$T = 2\\ \\mathrm{s}$，$c_{\\mathrm{ref}} = 1200\\ \\mathrm{mol/m^3}$，$a = 50\\ \\mathrm{mol/m^3}$。\n- 案例C（慢速扩散，更长时间范围）：$D = 1.0 \\times 10^{-11}\\ \\mathrm{m^2/s}$，$L = 200 \\times 10^{-6}\\ \\mathrm{m}$，$T = 50\\ \\mathrm{s}$，$c_{\\mathrm{ref}} = 1000\\ \\mathrm{mol/m^3}$，$a = 200\\ \\mathrm{mol/m^3}$。\n- 案例D（小区域，刚性问题）：$D = 2.0 \\times 10^{-9}\\ \\mathrm{m^2/s}$，$L = 20 \\times 10^{-6}\\ \\mathrm{m}$，$T = 0.02\\ \\mathrm{s}$，$c_{\\mathrm{ref}} = 1000\\ \\mathrm{mol/m^3}$，$a = 150\\ \\mathrm{mol/m^3}$。\n\n您的程序应产生单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如 $[p_A,p_B,p_C,p_D]$），其中每个 $p$ 是对应测试用例的观测收敛阶，并保留三位小数。",
            "solution": "用户提供了一个计算科学领域的适定问题，要求对一维扩散方程进行数值求解，并分析数值格式的收敛性。\n\n### **问题验证**\n\n**步骤 1：提取已知条件**\n\n*   **控制方程**：$\\frac{\\partial c}{\\partial t} = D \\frac{\\partial^2 c}{\\partial x^2}$\n*   **区域**：$x \\in [0,L]$，$t \\ge 0$。\n*   **边界条件 (BCs)**：两端无通量（诺伊曼）：$\\frac{\\partial c}{\\partial x}(0,t) = 0$ 和 $\\frac{\\partial c}{\\partial x}(L,t) = 0$。\n*   **初始条件 (IC)**：$c(x,0) = c_{\\mathrm{ref}} + a \\cos\\left(\\frac{\\pi x}{L}\\right)$。\n*   **数值方法**：包含 $M$ 个区间的均匀网格 ($\\Delta x = L/M$)，用于空间离散化的二阶中心差分，以及用于时间步进的二阶隐式Crank–Nicolson方法。\n*   **时间步长**：$\\Delta t = \\beta \\, \\Delta x^2 / D$，固定常数 $\\beta = 2.0$。\n*   **最终时间**：计算执行至 $t_{\\mathrm{final}} = N_t \\Delta t$，其中 $N_t$ 是最接近 $T/\\Delta t$ 的整数。\n*   **网格细化**：对 $M \\in \\{20, 40, 80, 160\\}$ 重复仿真。\n*   **误差度量**：连续 $\\mathrm{L^2}$ 范数，通过特定的求积规则近似：$e(\\Delta x) = \\left( \\Delta x \\sum_{i=0}^{M} \\left[c_i^{\\mathrm{num}}(t_{\\mathrm{final}}) - c^{\\mathrm{exact}}(x_i,t_{\\mathrm{final}})\\right]^2 \\right)^{1/2}$。\n*   **收敛阶估计**：阶数 $p$ 是对一系列网格细化上的 $\\log(e(\\Delta x))$ 与 $\\log(\\Delta x)$ 进行线性拟合的斜率。\n*   **物理参数**：提供了四个不同的测试用例（A, B, C, D），每个用例都给定了 $D, L, T, c_{\\mathrm{ref}}, a$ 的值。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n根据验证标准对问题进行评估：\n\n*   **科学依据**：该问题基于传质基本原理——菲克第二扩散定律。其背景是一个简化的电解质模型，具有科学有效性。所有参数都具有物理意义。\n*   **适定性**：带有给定初始条件和诺伊曼边界条件的扩散方程是一个经典的、适定的初边值问题。\n*   **目标明确**：问题以精确的数学语言陈述，所有要求、方法和参数都有明确定义。\n*   **完整性和一致性**：问题是自洽的，并提供了所有必要信息。所要求的数值方法、误差度量和分析程序在数值分析领域是一致且标准的。\n\n**步骤 3：结论与行动**\n\n问题陈述是 **有效的**。这是一个关于偏微分方程数值方法的标准的、非平凡的问题，它具有科学合理性、适定性和完整性。将提供完整的解决方案。\n\n### **基于原理的求解设计**\n\n#### **1. 解析解**\n该问题可以使用分离变量法进行解析求解。控制方程是一个线性偏微分方程(PDE)，初始条件表示为带有给定诺伊曼边界条件的空间算子的特征函数的和。\n特征函数 $\\cos(n \\pi x / L)$ 的通解为：\n$$\nc(x,t) = \\sum_{n=0}^{\\infty} A_n \\cos\\left(\\frac{n \\pi x}{L}\\right) \\exp\\left(-D \\left(\\frac{n \\pi}{L}\\right)^2 t\\right)\n$$\n系数 $A_n$ 由初始条件 $c(x,0)$ 确定。通过观察，给定的初始条件 $c(x,0) = c_{\\mathrm{ref}} + a \\cos\\left(\\frac{\\pi x}{L}\\right)$ 对应一个只有两个非零项的傅里叶余弦级数：\n*   $A_0 = c_{\\mathrm{ref}}$ (对于 $n=0$)\n*   $A_1 = a$ (对于 $n=1$)\n*   对于 $n > 1$，$A_n = 0$。\n\n代入这些系数，精确解析解为：\n$$\nc^{\\mathrm{exact}}(x,t) = c_{\\mathrm{ref}} + a \\cos\\left(\\frac{\\pi x}{L}\\right) \\exp\\left(-D \\left(\\frac{\\pi}{L}\\right)^2 t\\right)\n$$\n该解将作为衡量数值格式准确性的基准。\n\n#### **2. 数值离散化**\n我们将区域离散化为 $M+1$ 个网格点 $x_i = i \\Delta x$（$i = 0, 1, \\dots, M$），其中 $\\Delta x = L/M$。令 $c_i(t)$ 为 $c(x_i, t)$ 的数值近似。\n\n**2.1. 空间离散化（二阶）**\n二阶空间导数使用二阶中心差分进行近似：\n$$\n\\frac{\\partial^2 c}{\\partial x^2}\\bigg|_{x_i} \\approx \\frac{c_{i-1}(t) - 2c_i(t) + c_{i+1}(t)}{\\Delta x^2} \\quad \\text{for } i = 1, \\dots, M-1\n$$\n为了在边界处保持二阶精度，我们引入“虚拟点”$c_{-1}$ 和 $c_{M+1}$。无通量边界条件 $\\frac{\\partial c}{\\partial x}=0$ 使用二阶中心差分进行近似：\n$$\n\\frac{c_1 - c_{-1}}{2\\Delta x} = 0 \\implies c_{-1} = c_1\n\\qquad \\text{and} \\qquad\n\\frac{c_{M+1} - c_{M-1}}{2\\Delta x} = 0 \\implies c_{M+1} = c_{M-1}\n$$\n在边界处应用空间格式并代入虚拟点关系式，可得：\n$$\n\\frac{d c_0}{dt} = D \\frac{c_{-1} - 2c_0 + c_1}{\\Delta x^2} = D \\frac{2c_1 - 2c_0}{\\Delta x^2}\n$$\n$$\n\\frac{d c_M}{dt} = D \\frac{c_{M-1} - 2c_M + c_{M+1}}{\\Delta x^2} = D \\frac{2c_{M-1} - 2c_M}{\\Delta x^2}\n$$\n\n**2.2. 时间离散化（Crank–Nicolson）**\nCrank-Nicolson方法在时间区间 $[t_j, t_{j+1}]$ 的中点处近似时间导数，并在两个时间层级上对空间导数取平均值：\n$$\n\\frac{c_i^{j+1} - c_i^j}{\\Delta t} = \\frac{D}{2} \\left( \\left(\\frac{\\partial^2 c}{\\partial x^2}\\right)_i^{j+1} + \\left(\\frac{\\partial^2 c}{\\partial x^2}\\right)_i^{j} \\right)\n$$\n令 $\\vec{c}^j$ 为时间 $t_j$ 时的浓度向量，$\\mathbf{L}$ 为离散拉普拉斯矩阵算子，则该格式为：\n$$\n\\frac{\\vec{c}^{j+1} - \\vec{c}^j}{\\Delta t} = \\frac{D}{2} \\left( \\mathbf{L} \\vec{c}^{j+1} + \\mathbf{L} \\vec{c}^{j} \\right)\n$$\n重新整理各项，将已知项（在时间 $j$）和未知项（在时间 $j+1$）分组，得到每个时间步需要求解的线性系统：\n$$\n\\left(\\mathbf{I} - \\frac{D \\Delta t}{2} \\mathbf{L}\\right) \\vec{c}^{j+1} = \\left(\\mathbf{I} + \\frac{D \\Delta t}{2} \\mathbf{L}\\right) \\vec{c}^{j}\n$$\n令 $\\alpha = \\frac{D \\Delta t}{2 \\Delta x^2}$。问题指定 $\\Delta t = \\beta \\frac{\\Delta x^2}{D}$ 且 $\\beta=2.0$，这可以方便地将 $\\alpha$ 固定为 $\\alpha = \\frac{D}{2\\Delta x^2} \\left(2.0 \\frac{\\Delta x^2}{D}\\right) = 1.0$。\n\n#### **3. 矩阵系统实现**\n当 $\\alpha=1.0$ 时，网格点 $i=0, \\dots, M$ 的方程组为：\n$$\n\\mathbf{A} \\vec{c}^{j+1} = \\mathbf{B} \\vec{c}^{j}\n$$\n其中对于 $\\alpha=1.0$ 有 $\\mathbf{A} = (\\mathbf{I} - \\mathbf{L})$ 和 $\\mathbf{B} = (\\mathbf{I} + \\mathbf{L})$。矩阵 $\\mathbf{A}$ 和 $\\mathbf{B}$ 是三对角矩阵，具有以下结构：\n$$\n\\mathbf{A} = \\begin{pmatrix}\n3  -2                \\\\\n-1  3  -1          \\\\\n    \\ddots  \\ddots  \\ddots \\\\\n          -1  3  -1 \\\\\n              -2 3\n\\end{pmatrix}, \\quad\n\\mathbf{B} = \\begin{pmatrix}\n-1  2                \\\\\n1   -1  1          \\\\\n    \\ddots  \\ddots  \\ddots \\\\\n          1   -1 1  \\\\\n              2  -1\n\\end{pmatrix}\n$$\n每个时间步都需求解这个三对角系统。由于矩阵是恒定的，因此计算效率很高。为此，我们使用 `scipy.linalg.solve_banded`。\n\n#### **4. 收敛性分析**\nCrank-Nicolson格式在时间（$\\mathcal{O}(\\Delta t^2)$）和空间（$\\mathcal{O}(\\Delta x^2)$）上都是二阶精度的。总误差预计按 $e \\propto \\mathcal{O}(\\Delta t^2 + \\Delta x^2)$ 比例变化。由于 $\\Delta t \\propto \\Delta x^2$，截断误差由空间项主导：\n$$\ne(\\Delta x) \\propto \\mathcal{O}((\\Delta x^2)^2 + \\Delta x^2) = \\mathcal{O}(\\Delta x^4 + \\Delta x^2) \\approx C \\Delta x^2\n$$\n取对数后，我们期望得到一个线性关系：$\\log(e) \\approx 2 \\log(\\Delta x) + \\log(C)$。对 $\\log(e)$ 与 $\\log(\\Delta x)$ 数据进行线性拟合的斜率应得出观测到的收敛阶，$p \\approx 2$。该实现将使用 `numpy.polyfit` 对为 $M \\in \\{20, 40, 80, 160\\}$ 计算出的误差进行处理来计算此斜率。误差 $e(\\Delta x)$ 是在最终时间 $t_{\\mathrm{final}}$ 使用所提供的L2范数定义计算的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve_diffusion_case(D, L, T, c_ref, a):\n    \"\"\"\n    Solves the 1D diffusion equation for a given set of parameters and computes\n    the observed order of convergence.\n    \"\"\"\n    M_values = [20, 40, 80, 160]\n    beta = 2.0\n    \n    log_dx_list = []\n    log_err_list = []\n    \n    for M in M_values:\n        # 1. Grid and time step setup\n        dx = L / M\n        dt = beta * dx**2 / D\n        \n        # Determine number of time steps. Ensure Nt > 0.\n        if dt > 0:\n            Nt = int(round(T / dt))\n        else: # This case should not be reached with the given parameters\n            Nt = 0\n            \n        t_final = Nt * dt\n        \n        # 2. Grid and Initial Condition\n        x = np.linspace(0, L, M + 1)\n        c = c_ref + a * np.cos(np.pi * x / L)\n        \n        # 3. Crank-Nicolson matrices\n        # The choice beta=2.0 leads to a constant alpha = D*dt/(2*dx**2) = 1.0.\n        # The system is A * c_new = B * c_old.\n        \n        # Matrix A (LHS) in banded format for solve_banded.\n        # (l=1, u=1) -> shape (3, M+1)\n        A_banded = np.zeros((3, M + 1))\n        # Diagonals for alpha = 1.0\n        A_banded[0, 1:] = -1.0      # Super-diagonal: -alpha\n        A_banded[1, :] = 3.0        # Main-diagonal: 1 + 2*alpha\n        A_banded[2, :-1] = -1.0     # Sub-diagonal: -alpha\n        # Boundary conditions (2nd order Neumann)\n        A_banded[0, 1] = -2.0       # Corresponds to A[0,1] = -2*alpha\n        A_banded[2, M - 1] = -2.0   # Corresponds to A[M,M-1] = -2*alpha\n        \n        # Matrix B (RHS)\n        B = np.zeros((M + 1, M + 1))\n        # Diagonals for alpha = 1.0\n        diag_main = -np.ones(M + 1)   # 1 - 2*alpha\n        diag_upper = np.ones(M)     # +alpha\n        diag_lower = np.ones(M)     # +alpha\n        \n        np.fill_diagonal(B, diag_main)\n        np.fill_diagonal(B[1:, :], diag_lower)\n        np.fill_diagonal(B[:, 1:], diag_upper)\n\n        # Boundary conditions (2nd order Neumann)\n        B[0, 1] = 2.0               # B[0,1] = 2*alpha\n        B[M, M - 1] = 2.0           # B[M,M-1] = 2*alpha\n        \n        # 4. Time stepping\n        for _ in range(Nt):\n            b_rhs = B @ c\n            c = solve_banded((1, 1), A_banded, b_rhs)\n            \n        c_numerical = c\n        \n        # 5. Exact solution at t_final\n        decay_term = np.exp(-D * (np.pi/L)**2 * t_final)\n        c_exact = c_ref + a * np.cos(np.pi * x / L) * decay_term\n        \n        # 6. Error calculation (L2 norm as specified)\n        err_vec = c_numerical - c_exact\n        error_L2 = np.sqrt(dx * np.sum(err_vec**2))\n        \n        # Store for regression\n        if error_L2 > 0: # Avoid log(0)\n            log_dx_list.append(np.log(dx))\n            log_err_list.append(np.log(error_L2))\n        \n    # 7. Linear regression to find order of convergence p\n    # log(error) = p * log(dx) + const\n    if len(log_dx_list) > 1:\n        p, _ = np.polyfit(log_dx_list, log_err_list, 1)\n    else: # Should not happen with M_values sequence\n        p = np.nan\n\n    return p\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (happy path)\n        (1.0e-10, 100e-6, 10.0, 1000.0, 100.0),\n        # Case B (rapid diffusion)\n        (5.0e-10, 50e-6, 2.0, 1200.0, 50.0),\n        # Case C (slow diffusion, longer horizon)\n        (1.0e-11, 200e-6, 50.0, 1000.0, 200.0),\n        # Case D (small domain, stiff)\n        (2.0e-9, 20e-6, 0.02, 1000.0, 150.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        p = solve_diffusion_case(*case)\n        results.append(p)\n\n    # Final print statement in the exact required format.\n    # Format each result rounded to three decimal places.\n    print(f\"[{','.join(f'{r:.3f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}