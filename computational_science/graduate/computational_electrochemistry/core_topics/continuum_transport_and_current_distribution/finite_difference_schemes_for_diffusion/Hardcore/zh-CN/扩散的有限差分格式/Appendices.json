{
    "hands_on_practices": [
        {
            "introduction": "在深入研究数值实现之前，理解一个方案的内在稳定性至关重要。本练习通过推导前向欧拉法、后向欧拉法和Crank-Nicolson法这三种常见时间步进格式的放大因子，剖析了它们如何放大或衰减数值误差。通过分析这些方案对傅里叶模式的影响，我们可以获得预测其行为的理论工具，为选择合适的方案和参数奠定坚实的基础。",
            "id": "4246127",
            "problem": "考虑一种稀薄的电中性电解质，其中盐浓度场 $c(x,t)$ 的时空演化由 Fick 扩散第二定律决定，\n$$\n\\frac{\\partial c}{\\partial t} \\;=\\; D\\,\\frac{\\partial^{2} c}{\\partial x^{2}},\n$$\n其中扩散系数 $D>0$ 为常数。将空间域离散化到一个具有 $N$ 个节点、间距为 $\\Delta x$ 的均匀一维网格上，并施加周期性边界条件。在该网格上使用标准二阶中心差分近似二阶导数，从而形成一个形如下式的常微分方程半离散系统\n$$\n\\frac{d \\mathbf{c}}{dt} \\;=\\; \\frac{D}{\\Delta x^{2}}\\,\\mathbf{L}\\,\\mathbf{c},\n$$\n其中 $\\mathbf{c}\\in\\mathbb{C}^{N}$ 叠加了 $c$ 的节点值，而 $\\mathbf{L}\\in\\mathbb{R}^{N\\times N}$ 是在周期性环绕条件下具有模板 $(1,-2,1)$ 的循环离散拉普拉斯算子。由于 $\\mathbf{L}$ 是循环矩阵，其特征向量是由整数 $m\\in\\{0,1,\\dots,N-1\\}$ 索引的离散傅里叶模式，每个傅里叶特征模式都作为一个形如下式的标量线性常微分方程独立演化\n$$\ny'(t) \\;=\\; \\lambda\\,y(t),\n$$\n其中 $\\lambda$ 等于 $\\frac{D}{\\Delta x^{2}}\\mathbf{L}$ 的相应特征值。考虑使用以下格式进行步长为 $\\Delta t$ 的单步时间积分：Forward Euler (FE)、Backward Euler (BE) 和 Crank–Nicolson (CN)。对于每种格式，单步演化会将傅里叶特征模式的振幅乘以一个取决于 $\\lambda$ 和 $\\Delta t$ 的放大因子。\n\n从控制扩散定律及其有限差分半离散化出发，推导 $\\mathbf{L}$ 的离散傅里叶特征值，并用它们来表示在 FE、BE 和 CN 时间步进下第 $m$ 个扩散特征模式的放大因子，每个放大因子都应表示为 $D$、$\\Delta x$、$\\Delta t$、$N$ 和 $m$ 的闭式解析函数。按 (FE, BE, CN) 的顺序，将这三个放大因子以单个行矩阵的形式报告。最终答案必须是单一的解析表达式；不要在最终表达式中包含单位。",
            "solution": "此问题有效。这是一个适定的、有科学依据的问题，源于应用于偏微分方程的数值分析领域。所有必要信息都已提供，目标也已明确陈述。我们可以开始推导。\n\n浓度场 $c(x,t)$ 的时空演化由 Fick 第二定律决定：\n$$\n\\frac{\\partial c}{\\partial t} = D\\,\\frac{\\partial^{2} c}{\\partial x^{2}}\n$$\n在间距为 $\\Delta x$ 且具有周期性边界条件的均匀网格上进行空间离散化后，关于 $x$ 的二阶偏导数由二阶中心差分算子近似。对于网格节点 $j$，这表示为 $\\frac{c_{j+1} - 2c_j + c_{j-1}}{\\Delta x^2}$。这导出了常微分方程（ODEs）的半离散系统：\n$$\n\\frac{d \\mathbf{c}}{dt} = \\frac{D}{\\Delta x^{2}}\\,\\mathbf{L}\\,\\mathbf{c}\n$$\n这里，$\\mathbf{c}$ 是 $N$ 个网格节点上浓度值的向量，$\\mathbf{L}$ 是 $N \\times N$ 的离散拉普拉斯矩阵。给定模板 $(1, -2, 1)$ 和周期性边界条件，$\\mathbf{L}$ 是一个循环矩阵。$\\mathbf{L}$ 的第一行是 $(-2, 1, 0, \\dots, 0, 1)$。\n\n第一行为 $(c_0, c_1, \\dots, c_{N-1})$ 的循环矩阵的特征值由公式 $\\mu_m = \\sum_{k=0}^{N-1} c_k \\omega^{mk}$ 给出，其中 $\\omega = \\exp(i 2\\pi / N)$ 是一个 $N$ 次单位主根，索引 $m$ 的范围从 $0$ 到 $N-1$。\n对于矩阵 $\\mathbf{L}$，第一行中唯一的非零元素是 $c_0 = -2$，$c_1 = 1$ 和 $c_{N-1} = 1$。因此，$\\mathbf{L}$ 的特征值 $\\mu_m$ 为：\n$$\n\\mu_m = c_0 \\omega^{m \\cdot 0} + c_1 \\omega^{m \\cdot 1} + c_{N-1} \\omega^{m(N-1)}\n$$\n$$\n\\mu_m = -2 + \\exp\\left(i\\frac{2\\pi m}{N}\\right) + \\exp\\left(i\\frac{2\\pi m(N-1)}{N}\\right)\n$$\n使用性质 $\\exp(i\\frac{2\\pi m(N-1)}{N}) = \\exp(i(2\\pi m - \\frac{2\\pi m}{N})) = \\exp(i 2\\pi m)\\exp(-i\\frac{2\\pi m}{N}) = \\exp(-i\\frac{2\\pi m}{N})$，表达式得以简化。\n$$\n\\mu_m = -2 + \\exp\\left(i\\frac{2\\pi m}{N}\\right) + \\exp\\left(-i\\frac{2\\pi m}{N}\\right)\n$$\n应用 Euler 公式 $\\cos(\\theta) = \\frac{\\exp(i\\theta) + \\exp(-i\\theta)}{2}$，我们得到：\n$$\n\\mu_m = -2 + 2\\cos\\left(\\frac{2\\pi m}{N}\\right)\n$$\n使用半角恒等式 $1 - \\cos(2\\theta) = 2\\sin^2(\\theta)$，这变成：\n$$\n\\mu_m = -2\\left(1 - \\cos\\left(\\frac{2\\pi m}{N}\\right)\\right) = -4\\sin^2\\left(\\frac{\\pi m}{N}\\right)\n$$\n在 $\\mathbf{L}$ 的特征向量（离散傅里叶模式）基中，该半离散系统解耦。对于每个模式 $m$，系统的行为类似于一个标量常微分方程 $y'(t) = \\lambda_m y(t)$，其中 $\\lambda_m$ 是完整矩阵算子 $\\frac{D}{\\Delta x^2}\\mathbf{L}$ 的相应特征值。\n$$\n\\lambda_m = \\frac{D}{\\Delta x^2}\\mu_m = -\\frac{4D}{\\Delta x^2}\\sin^2\\left(\\frac{\\pi m}{N}\\right)\n$$\n我们现在分析应用于此模型方程的时间步进格式的稳定性。设 $y^n$ 是在时间 $t_n = n\\Delta t$ 的数值解。放大因子 $G_m$ 由关系式 $y^{n+1} = G_m y^n$ 定义。\n\n1.  **Forward Euler (FE)**：该格式为 $\\frac{y^{n+1} - y^n}{\\Delta t} = \\lambda_m y^n$。\n    $$\n    y^{n+1} = y^n + \\lambda_m \\Delta t y^n = (1 + \\lambda_m \\Delta t)y^n\n    $$\n    第 $m$ 个模式的放大因子为 $G_{FE,m} = 1 + \\lambda_m \\Delta t$。代入 $\\lambda_m$ 的表达式：\n    $$\n    G_{FE,m} = 1 - \\frac{4 D \\Delta t}{\\Delta x^2}\\sin^2\\left(\\frac{\\pi m}{N}\\right)\n    $$\n\n2.  **Backward Euler (BE)**：该格式为 $\\frac{y^{n+1} - y^n}{\\Delta t} = \\lambda_m y^{n+1}$。\n    $$\n    y^n = y^{n+1}(1 - \\lambda_m \\Delta t) \\implies y^{n+1} = \\frac{1}{1 - \\lambda_m \\Delta t}y^n\n    $$\n    放大因子为 $G_{BE,m} = (1 - \\lambda_m \\Delta t)^{-1}$。代入 $\\lambda_m$ 的表达式：\n    $$\n    G_{BE,m} = \\frac{1}{1 - (-\\frac{4D}{\\Delta x^2}\\sin^2(\\frac{\\pi m}{N})) \\Delta t} = \\frac{1}{1 + \\frac{4 D \\Delta t}{\\Delta x^2}\\sin^2\\left(\\frac{\\pi m}{N}\\right)}\n    $$\n\n3.  **Crank–Nicolson (CN)**：该格式为 $\\frac{y^{n+1} - y^n}{\\Delta t} = \\frac{1}{2}(\\lambda_m y^n + \\lambda_m y^{n+1})$。\n    $$\n    y^{n+1}\\left(1 - \\frac{\\lambda_m \\Delta t}{2}\\right) = y^n\\left(1 + \\frac{\\lambda_m \\Delta t}{2}\\right) \\implies y^{n+1} = \\frac{1 + \\lambda_m \\Delta t/2}{1 - \\lambda_m \\Delta t/2}y^n\n    $$\n    放大因子为 $G_{CN,m} = \\frac{1 + \\lambda_m \\Delta t/2}{1 - \\lambda_m \\Delta t/2}$。代入 $\\lambda_m$ 的表达式：\n    $$\n    G_{CN,m} = \\frac{1 + \\frac{\\Delta t}{2}(-\\frac{4D}{\\Delta x^2}\\sin^2(\\frac{\\pi m}{N}))}{1 - \\frac{\\Delta t}{2}(-\\frac{4D}{\\Delta x^2}\\sin^2(\\frac{\\pi m}{N}))} = \\frac{1 - \\frac{2 D \\Delta t}{\\Delta x^2}\\sin^2\\left(\\frac{\\pi m}{N}\\right)}{1 + \\frac{2 D \\Delta t}{\\Delta x^2}\\sin^2\\left(\\frac{\\pi m}{N}\\right)}\n    $$\n\n根据要求，将第 $m$ 个特征模式的三个放大因子表示为 $D$、$\\Delta x$、$\\Delta t$、$N$ 和 $m$ 的函数，并汇集成一个单行矩阵。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 1 - \\frac{4 D \\Delta t}{\\Delta x^2}\\sin^2\\left(\\frac{\\pi m}{N}\\right)  \\frac{1}{1 + \\frac{4 D \\Delta t}{\\Delta x^2}\\sin^2\\left(\\frac{\\pi m}{N}\\right)}  \\frac{1 - \\frac{2 D \\Delta t}{\\Delta x^2}\\sin^2\\left(\\frac{\\pi m}{N}\\right)}{1 + \\frac{2 D \\Delta t}{\\Delta x^2}\\sin^2\\left(\\frac{\\pi m}{N}\\right)} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "本练习将理论付诸实践，要求您首次动手实现一个扩散模拟。您将使用最简单的显式方法——时间前向中心差分 (FTCS) 格式——将离散化的扩散方程转化为可执行代码。这个过程不仅能让您直观地感受显式格式如何工作，还能让您亲身体验在理论分析中探讨的稳定性条件（例如 $r = D \\Delta t / \\Delta x^2 \\le 1/2$）的实际影响。",
            "id": "4246161",
            "problem": "考虑一种中性离子在等温、均匀电解质板中的一维扩散。该动力学过程由菲克 (Fick) 第二扩散定律决定，该定律指出浓度 $c(x,t)$ 的演化遵循以下偏微分方程 (PDE)：$$\\frac{\\partial c}{\\partial t} = D \\frac{\\partial^2 c}{\\partial x^2},$$ 其中 $D$ 是扩散系数。假设在板的两端均为零通量（诺伊曼 (Neumann)）边界条件，即浓度的空间导数在边界处为零。\n\n您需要实现显式前向时间中心空间 (FTCS) 有限差分格式，并遵守其稳定性约束，以模拟初始阶跃浓度的演化，并估计浓度分布达到指定的“平滑水平”所需的时间。FTCS 格式使用以下公式来推进在网格索引 $i$ 和时间步长 $n$ 处的离散浓度 $c_i^n$：$$c_i^{n+1} = c_i^n + r \\left(c_{i+1}^n - 2 c_i^n + c_{i-1}^n\\right),$$ 其中，无量纲参数 $r = D \\Delta t / \\Delta x^2$ 必须满足稳定性条件 $r \\le \\frac{1}{2}$。零通量边界条件通过要求以下条件来施加：$$\\left.\\frac{\\partial c}{\\partial x}\\right|_{x=0} = 0 \\quad \\text{and} \\quad \\left.\\frac{\\partial c}{\\partial x}\\right|_{x=L} = 0,$$ 在有限差分实现中，这可以通过镜像虚拟值或等效的单侧更新来施加。\n\n将初始条件定义为在长度为 $L$ 的区域中心的一个阶跃浓度：$$c(x,0) = \\begin{cases} c_0,  x  \\frac{L}{2} \\\\ 0,  x \\ge \\frac{L}{2} \\end{cases}$$ 使用一个包含 $N$ 个点、间距为 $\\Delta x = L/(N-1)$ 的均匀空间网格，并选择一个时间步长 $\\Delta t$ 以满足 FTCS 稳定性约束。“平滑水平”定义为整个区域上的最大绝对空间梯度幅值降至指定阈值 $g_{\\mathrm{thr}}$ 以下，即：$$\\max_{x \\in [0,L]} \\left|\\frac{\\partial c}{\\partial x}(x,t)\\right| \\le g_{\\mathrm{thr}}.$$ 在离散设置中，使用中心差分估计内部点的梯度，使用单侧差分估计边界点的梯度：\n- 内部点：$\\left.\\frac{\\partial c}{\\partial x}\\right|_{x_i} \\approx \\frac{c_{i+1} - c_{i-1}}{2 \\Delta x}$,\n- 左边界：$\\left.\\frac{\\partial c}{\\partial x}\\right|_{x_0} \\approx \\frac{c_1 - c_0}{\\Delta x}$,\n- 右边界：$\\left.\\frac{\\partial c}{\\partial x}\\right|_{x_{N-1}} \\approx \\frac{c_{N-1} - c_{N-2}}{\\Delta x}$.\n\n实现一个程序，该程序：\n1. 在中点网格索引处构建阶跃初始条件，\n2. 使用带有零通量边界条件的 FTCS 格式推进浓度演化，通过选择一个 $r \\le \\frac{1}{2}$ 并设置 $\\Delta t = r \\Delta x^2 / D$ 来强制执行稳定性约束，\n3. 在每个时间步，计算整个区域上的最大绝对梯度，\n4. 返回最大绝对梯度小于或等于 $g_{\\mathrm{thr}}$ 的最早时间 $t$（以秒为单位），\n5. 如果在 $t=0$ 时就已经达到了平滑水平，则返回 $0$ 秒，\n6. 如果在指定的最大模拟时间 $t_{\\max}$ 内未达到平滑水平，则返回 $-1.0$。\n\n所有物理量必须使用其标准单位处理：$L$ 的单位是米 ($\\mathrm{m}$)，$D$ 的单位是平方米每秒 ($\\mathrm{m}^2/\\mathrm{s}$)，$c_0$ 的单位是摩尔每立方米 ($\\mathrm{mol}/\\mathrm{m}^3$)，$g_{\\mathrm{thr}}$ 的单位是摩尔每四次方米 ($\\mathrm{mol}/\\mathrm{m}^4$)，时间单位是秒 ($\\mathrm{s}$)。每个测试用例的输出必须是一个表示时间的浮点数（以秒为单位）。\n\n测试套件：\n提供一组四个参数元组 $(L, N, D, c_0, r_{\\mathrm{choose}}, g_{\\mathrm{thr}}, t_{\\max})$ 进行独立模拟：\n- 情况1（一般情况）：$(1.0 \\times 10^{-3}, 801, 1.0 \\times 10^{-9}, 1000.0, 0.45, 5.0 \\times 10^{6}, 2.0)$。\n- 情况2（稳定性边界）：$(2.0 \\times 10^{-3}, 1001, 2.0 \\times 10^{-9}, 500.0, 0.50, 1.0 \\times 10^{6}, 0.5)$。\n- 情况3（初始时刻已平滑）：$(1.0 \\times 10^{-3}, 501, 1.0 \\times 10^{-9}, 1000.0, 0.49, 3.0 \\times 10^{8}, 1.0)$。\n- 情况4（在 $t_{\\max}$ 内未达到）：$(1.0 \\times 10^{-3}, 601, 1.0 \\times 10^{-9}, 1000.0, 0.45, 1.0 \\times 10^{2}, 0.05)$。\n\n您的程序应生成单行输出，其中包含这四个测试用例的结果，结果为逗号分隔的列表，并用方括号括起来（例如，“[result1,result2,result3,result4]”），每个结果都是表示时间的浮点数（以秒为单位）。不允许有任何额外的输出或注释。",
            "solution": "该问题要求实现一个数值模拟，以求解一维扩散方程，并找出初始浓度分布平滑到指定水平所需的时间。对问题陈述的验证证实了其具有科学依据、是适定的且内部一致。因此，我们可以继续详细描述求解方法。\n\n控制性偏微分方程 (PDE) 是菲克 (Fick) 第二扩散定律，描述了浓度为 $c(x,t)$、扩散系数为 $D$ 的物质：\n$$\n\\frac{\\partial c}{\\partial t} = D \\frac{\\partial^2 c}{\\partial x^2}\n$$\n模拟区域是一个长度为 $L$ 的板，范围从 $x=0$ 到 $x=L$。两端的边界条件为零通量（诺伊曼 (Neumann)）类型：\n$$\n\\left.\\frac{\\partial c}{\\partial x}\\right|_{x=0} = 0 \\quad \\text{and} \\quad \\left.\\frac{\\partial c}{\\partial x}\\right|_{x=L} = 0\n$$\n初始浓度分布是区域中心的一个阶跃函数：\n$$\nc(x,0) = \\begin{cases} c_0,  x  \\frac{L}{2} \\\\ 0,  x \\ge \\frac{L}{2} \\end{cases}\n$$\n\n为数值求解此偏微分方程，我们采用前向时间中心空间 (FTCS) 有限差分法。首先，我们对时空域进行离散化。空间域 $[0, L]$被划分为一个由 $N$ 个点组成的均匀网格，索引为 $i = 0, 1, \\dots, N-1$。空间网格间距为 $\\Delta x = L/(N-1)$，每个网格点的位置是 $x_i = i \\Delta x$。时间被离散化为大小为 $\\Delta t$ 的步长，即 $t_n = n \\Delta t$。网格点 $i$ 和时间步 $n$ 处的浓度表示为 $c_i^n$。\n\nFTCS 格式用前向差分近似时间导数，用中心差分近似空间二阶导数。这得到了内部网格点（$i=1, \\dots, N-2$）的显式更新规则：\n$$\n\\frac{c_i^{n+1} - c_i^n}{\\Delta t} = D \\frac{c_{i+1}^n - 2c_i^n + c_{i-1}^n}{\\Delta x^2}\n$$\n对 $c_i^{n+1}$ 进行整理，得到问题中提供的更新方程：\n$$\nc_i^{n+1} = c_i^n + r \\left(c_{i+1}^n - 2c_i^n + c_{i-1}^n\\right)\n$$\n其中 $r = D \\Delta t / \\Delta x^2$ 是一个无量纲参数。为使此显式格式数值稳定，$r$ 必须满足冯·诺伊曼 (von Neumann) 稳定性条件 $r \\le 1/2$。问题指定选择一个值 $r_{\\mathrm{choose}} \\le 1/2$，由此确定时间步长为 $\\Delta t = r_{\\mathrm{choose}} \\Delta x^2 / D$。\n\n零通量诺伊曼 (Neumann) 边界条件需要特殊处理。我们可以使用“虚拟点”来施加该条件。在左边界 ($i=0$)，零通量条件 $\\partial c / \\partial x = 0$ 的中心差分近似为 $(c_1^n - c_{-1}^n)/(2\\Delta x) = 0$，这意味着虚拟点的值 $c_{-1}^n$ 等于 $c_1^n$。将此代入 $i=0$ 处的通用 FTCS 公式：\n$$\nc_0^{n+1} = c_0^n + r(c_1^n - 2c_0^n + c_{-1}^n) = c_0^n + r(c_1^n - 2c_0^n + c_1^n) = c_0^n + 2r(c_1^n - c_0^n)\n$$\n类似地，在右边界 ($i=N-1$)，零通量条件意味着虚拟点的值 $c_N^n = c_{N-2}^n$。更新规则变为：\n$$\nc_{N-1}^{n+1} = c_{N-1}^n + r(c_N^n - 2c_{N-1}^n + c_{N-2}^n) = c_{N-1}^n + r(c_{N-2}^n - 2c_{N-1}^n + c_{N-2}^n) = c_{N-1}^n + 2r(c_{N-2}^n - c_{N-1}^n)\n$$\n这三个更新规则（用于内部点、左边界和右边界）使得浓度分布可以随时间演化。\n\n通过将阶跃函数映射到网格上，对初始条件进行离散化。对于给定的测试用例，$N$ 始终是一个奇数。设 $N=2k+1$。网格索引为 $0, \\dots, 2k$。中点网格索引是 $k=(N-1)/2$，对应于物理位置 $x_k = k \\Delta x = \\frac{N-1}{2} \\frac{L}{N-1} = L/2$。因此，离散的初始条件是：\n$$\nc_i^0 = c_0 \\quad \\text{for } i=0, \\dots, k-1\n$$\n$$\nc_i^0 = 0 \\quad \\text{for } i=k, \\dots, N-1\n$$\n\n当达到“平滑水平”时，模拟停止。这被定义为整个区域上的最大绝对空间梯度降至一个阈值 $g_{\\mathrm{thr}}$ 以下。在每个时间步 $n$，使用指定的有限差分公式在每个网格点 $i$ 处估计梯度：\n-   左边界 ($i=0$)：$g_0^n = \\frac{c_1^n - c_0^n}{\\Delta x}$\n-   内部点 ($i=1, \\dots, N-2$)：$g_i^n = \\frac{c_{i+1}^n - c_{i-1}^n}{2\\Delta x}$\n-   右边界 ($i=N-1$)：$g_{N-1}^n = \\frac{c_{N-1}^n - c_{N-2}^n}{\\Delta x}$\n要检查的条件是 $\\max_{i} |g_i^n| \\le g_{\\mathrm{thr}}$。\n\n总体算法如下：\n1.  给定参数 $(L, N, D, c_0, r_{\\mathrm{choose}}, g_{\\mathrm{thr}}, t_{\\max})$，计算常量 $\\Delta x = L/(N-1)$ 和 $\\Delta t = r_{\\mathrm{choose}} \\Delta x^2 / D$。\n2.  根据离散阶跃函数初始条件，初始化一个包含 $N$ 个元素的浓度数组 $c$。\n3.  计算初始最大绝对梯度。如果它小于或等于 $g_{\\mathrm{thr}}$，则过程终止并返回 $t=0$。\n4.  进入时间步进循环。一个管理循环直到 $t_{\\max}$ 的安全方法是确定最大整数步数 `num_steps = floor(t_max / dt)`。\n5.  对于从 $1$ 到 `num_steps` 的每一步：\n    a. 使用所有网格点的 FTCS 更新方程，从当前分布 $c^n$ 计算下一个浓度分布 $c^{n+1}$。\n    b. 更新当前时间：$t_n = n \\Delta t$。\n    c. 计算新分布 $c^{n+1}$ 的最大绝对梯度。\n    d. 如果梯度小于或等于 $g_{\\mathrm{thr}}$，则模拟完成，并返回当前时间 $t_n$。\n6.  如果循环结束仍未满足阈值条件，则意味着在任何时间 $t \\le t_{\\max}$ 内条件都未满足。在这种情况下，返回一个值 $-1.0$。\n将为提供的每个测试用例实现此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D diffusion equation using the FTCS method to find the time\n    to reach a specified smoothing level for a set of test cases.\n    \"\"\"\n    \n    # Test Suite: (L, N, D, c0, r_choose, g_thr, t_max)\n    test_cases = [\n        # Case 1 (general case)\n        (1.0e-3, 801, 1.0e-9, 1000.0, 0.45, 5.0e6, 2.0),\n        # Case 2 (boundary of stability)\n        (2.0e-3, 1001, 2.0e-9, 500.0, 0.50, 1.0e6, 0.5),\n        # Case 3 (already smooth at initial time)\n        (1.0e-3, 501, 1.0e-9, 1000.0, 0.49, 3.0e8, 1.0),\n        # Case 4 (not achieved within t_max)\n        (1.0e-3, 601, 1.0e-9, 1000.0, 0.45, 1.0e2, 0.05),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        L, N, D, c0, r_choose, g_thr, t_max = case\n\n        # 1. Discretization parameters\n        dx = L / (N - 1)\n        dt = r_choose * dx**2 / D\n        \n        # 2. Initial Condition\n        c = np.zeros(N)\n        mid_idx = (N - 1) // 2\n        c[:mid_idx] = c0\n\n        # 3. Function to compute maximum absolute gradient\n        def calculate_max_grad(conc, delta_x):\n            grad = np.zeros_like(conc)\n            # Left boundary: one-sided forward difference\n            grad[0] = (conc[1] - conc[0]) / delta_x\n            # Right boundary: one-sided backward difference\n            grad[-1] = (conc[-1] - conc[-2]) / delta_x\n            # Interior points: central difference\n            grad[1:-1] = (conc[2:] - conc[:-2]) / (2 * delta_x)\n            return np.max(np.abs(grad))\n\n        # 4. Check condition at t=0\n        initial_max_grad = calculate_max_grad(c, dx)\n        if initial_max_grad = g_thr:\n            results.append(0.0)\n            continue\n        \n        # 5. Time-stepping loop\n        found_time = -1.0\n        \n        # Use integer steps to avoid floating point issues in loop termination\n        if dt > 0:\n            num_steps = int(t_max / dt)\n        else:\n            num_steps = 0\n            \n        current_time = 0.0\n        c_new = np.copy(c)\n\n        for step in range(1, num_steps + 1):\n            current_time = step * dt\n            \n            # FTCS Update (vectorized)\n            # Interior points\n            c_new[1:-1] = c[1:-1] + r_choose * (c[2:] - 2 * c[1:-1] + c[:-2])\n            \n            # Boundary points (zero-flux)\n            c_new[0] = c[0] + 2 * r_choose * (c[1] - c[0])\n            c_new[-1] = c[-1] + 2 * r_choose * (c[-2] - c[-1])\n            \n            c = np.copy(c_new)\n\n            # Check for smoothing level\n            max_grad = calculate_max_grad(c, dx)\n            if max_grad = g_thr:\n                found_time = current_time\n                break\n        \n        results.append(found_time)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基础实现之后，是时候转向更成熟、更可靠的方法了。这个高级练习不仅介绍了强大的Crank-Nicolson格式，更重要的是，它教授了科学计算中的一项关键技能：代码验证。通过运用理查森外推法 (Richardson extrapolation)，您不仅能计算出更精确的解，还能通过数值方式验证您的代码是否达到了其理论上的收敛阶，这是计算研究中不可或缺的一步。",
            "id": "4246157",
            "problem": "考虑溶解物质向平面电极的一维扩散，该过程通过在有限区间上使用菲克第二定律建模，以近似半无限域。设 $x \\in [0,L]$ 且 $t \\ge 0$。浓度场 $c(x,t)$ 满足偏微分方程 $c_t = D c_{xx}$，其中 $D$ 是扩散系数。初始条件和边界条件模拟了均匀的初始浓度、位于原点的吸收电极以及远场浓度保持为初始值的情况：对于 $x \\in (0,L]$，$c(x,0) = c_0$；对于 $t \\ge 0$，$c(0,t) = 0$；以及对于 $t \\ge 0$，$c(L,t) = c_0$。在计算电化学中，此设置近似了向一个完美吸收的平面电极的半无限扩散，其中在 $x=L$ 处有一个固定浓度的储备库。\n\n您的任务是实现空间上的二阶中心有限差分，并结合 Crank-Nicolson (CN) 时间步进方法（Crank-Nicolson (CN) 是一种经典的无条件稳定、二阶精度的隐式时间离散方法），使用两种网格间距 $h$ 和 $h/2$ 来计算在时间 $T$ 的数值解。使用此边界值问题的精确半无限解作为参考来计算绝对误差（您必须在您的解答中推导并陈述精确解）。然后：\n\n1. 在指定位置 $x_\\star$ 处，结合在 $h$ 和 $h/2$ 网格间距下得到的数值，计算理查森外推估计值。\n2. 使用在两种网格间距下计算出的绝对误差的以 2 为底的对数比，评估关于空间细化的观测精度阶 $p$。\n\n所有量必须使用物理上一致的单位：$D$ 的单位为 $\\mathrm{m^2/s}$，$x$ 和 $L$ 的单位为 $\\mathrm{m}$，$t$ 和 $T$ 的单位为 $\\mathrm{s}$，$c$ 的单位为 $\\mathrm{mol/m^3}$。所有浓度以 $\\mathrm{mol/m^3}$ 报告，观测阶数为无量纲数。不涉及角度。不要使用百分比；任何比率都必须以小数形式报告。\n\n实现该算法并将其应用于以下参数值的测试套件。对于每种情况，两个网格都使用相同的时间步长 $\\,\\Delta t\\,$，以使时间误差不会掩盖空间阶数。将使用的两个空间网格间距为 $h$ 和 $h/2$。\n\n- 情况 A（一般精度，远场边界无影响）：\n  - $D = 1.0 \\times 10^{-9}\\ \\mathrm{m^2/s}$,\n  - $c_0 = 1.0\\ \\mathrm{mol/m^3}$,\n  - $L = 1.0 \\times 10^{-3}\\ \\mathrm{m}$,\n  - $T = 0.1\\ \\mathrm{s}$,\n  - $x_\\star = 5.0 \\times 10^{-5}\\ \\mathrm{m}$,\n  - $h = 2.0 \\times 10^{-5}\\ \\mathrm{m}$,\n  - $\\Delta t = 5.0 \\times 10^{-4}\\ \\mathrm{s}$.\n\n- 情况 B（短时扩散层，较慢的物质）：\n  - $D = 1.0 \\times 10^{-10}\\ \\mathrm{m^2/s}$,\n  - $c_0 = 1.0\\ \\mathrm{mol/m^3}$,\n  - $L = 1.0 \\times 10^{-3}\\ \\mathrm{m}$,\n  - $T = 0.01\\ \\mathrm{s}$,\n  - $x_\\star = 1.0 \\times 10^{-5}\\ \\mathrm{m}$,\n  - $h = 5.0 \\times 10^{-5}\\ \\mathrm{m}$,\n  - $\\Delta t = 5.0 \\times 10^{-5}\\ \\mathrm{s}$.\n\n- 情况 C（远场边界更近，可能因有限域而导致精度下降）：\n  - $D = 1.0 \\times 10^{-9}\\ \\mathrm{m^2/s}$,\n  - $c_0 = 1.0\\ \\mathrm{mol/m^3}$,\n  - $L = 1.0 \\times 10^{-4}\\ \\mathrm{m}$,\n  - $T = 0.1\\ \\mathrm{s}$,\n  - $x_\\star = 5.0 \\times 10^{-5}\\ \\mathrm{m}$,\n  - $h = 2.0 \\times 10^{-6}\\ \\mathrm{m}$,\n  - $\\Delta t = 5.0 \\times 10^{-4}\\ \\mathrm{s}$.\n\n对于每种情况：\n- 计算在两个网格下，$x_\\star$ 处和 $t=T$ 时的数值浓度。\n- 计算在 $t=T$ 时，$x_\\star$ 处相对于精确半无限解的绝对误差。\n- 根据与 $h$ 和 $h/2$ 相关联的误差对，计算观测阶数 $p$。\n- 使用两个网格值和观测阶数，计算在 $x_\\star$ 处的理查森外推浓度估计值。\n\n最终输出格式：\n您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表，其中每种情况的结果本身是一个双元素列表。这两个元素按顺序分别是：在 $x_\\star$ 处的理查森外推浓度（单位为 $\\mathrm{mol/m^3}$，四舍五入到六位小数）和观测精度阶 $p$（四舍五入到六位小数）。例如，输出格式必须完全如下所示：\n\"[[c_A,p_A],[c_B,p_B],[c_C,p_C]]\"\n前后无任何附加文本。",
            "solution": "在进行求解之前，需要对问题进行验证。\n\n### 第 1 步：提取已知条件\n- **控制方程**：$c_t = D c_{xx}$，对于 $x \\in [0,L]$ 和 $t \\ge 0$。\n- **初始条件**：$c(x,0) = c_0$，对于 $x \\in (0,L]$。\n- **边界条件**：$c(0,t) = 0$ 对于 $t \\ge 0$ 且 $c(L,t) = c_0$ 对于 $t \\ge 0$。\n- **数值方法**：空间上采用二阶中心有限差分；时间步进采用 Crank-Nicolson (CN) 方法。\n- **分析任务**：\n  1. 对于网格间距 $h$ 和 $h/2$，计算在时间 $T$ 的数值解，保持时间步长 $\\Delta t$ 不变。\n  2. 使用精确的半无限解作为误差计算的参考。\n  3. 使用来自网格 $h$ 和 $h/2$ 的结果，计算在 $x_\\star$ 处的理查森外推估计值。\n  4. 从两个网格的绝对误差计算观测精度阶 $p$。\n- **数据单位**：$D$ 的单位为 $\\mathrm{m^2/s}$，$x, L, h$ 的单位为 $\\mathrm{m}$，$t, T, \\Delta t$ 的单位为 $\\mathrm{s}$，$c, c_0$ 的单位为 $\\mathrm{mol/m^3}$。\n- **测试用例**：\n  - **情况 A**：$D = 1.0 \\times 10^{-9}\\ \\mathrm{m^2/s}$, $c_0 = 1.0\\ \\mathrm{mol/m^3}$, $L = 1.0 \\times 10^{-3}\\ \\mathrm{m}$, $T = 0.1\\ \\mathrm{s}$, $x_\\star = 5.0 \\times 10^{-5}\\ \\mathrm{m}$, $h = 2.0 \\times 10^{-5}\\ \\mathrm{m}$, $\\Delta t = 5.0 \\times 10^{-4}\\ \\mathrm{s}$。\n  - **情况 B**：$D = 1.0 \\times 10^{-10}\\ \\mathrm{m^2/s}$, $c_0 = 1.0\\ \\mathrm{mol/m^3}$, $L = 1.0 \\times 10^{-3}\\ \\mathrm{m}$, $T = 0.01\\ \\mathrm{s}$, $x_\\star = 1.0 \\times 10^{-5}\\ \\mathrm{m}$, $h = 5.0 \\times 10^{-5}\\ \\mathrm{m}$, $\\Delta t = 5.0 \\times 10^{-5}\\ \\mathrm{s}$。\n  - **情况 C**：$D = 1.0 \\times 10^{-9}\\ \\mathrm{m^2/s}$, $c_0 = 1.0\\ \\mathrm{mol/m^3}$, $L = 1.0 \\times 10^{-4}\\ \\mathrm{m}$, $T = 0.1\\ \\mathrm{s}$, $x_\\star = 5.0 \\times 10^{-5}\\ \\mathrm{m}$, $h = 2.0 \\times 10^{-6}\\ \\mathrm{m}$, $\\Delta t = 5.0 \\times 10^{-4}\\ \\mathrm{s}$。\n\n### 第 2 步：使用提取的已知条件进行验证\n1.  **科学依据**：该问题描述了由菲克第二定律建模的一维扩散，这是传质学和电化学中的一个基本原理。边界条件对应于标准的计时电流法实验。数值方法（Crank-Nicolson）是处理抛物型偏微分方程的标准、成熟的技术。使用有限域来近似半无限域是一种常见且有效的计算策略。参数是物理上现实的。该问题在科学上是合理的。\n2.  **适定性**：该问题是一个具有明确初始条件和狄利克雷边界条件的线性抛物型偏微分方程。这构成了一个适定的初边值问题，保证了唯一且稳定解的存在。\n3.  **客观性**：该问题以精确的数学和物理术语陈述，没有主观性或歧义。\n4.  **完整性**：为每种情况提供了所有必要的参数（$D, c_0, L, T, x_\\star, h, \\Delta t$）。问题是自洽的。\n5.  **一致性**：没有内部矛盾。例如，将半无限精确解用作有限域模拟的基准，是数值分析练习中一个刻意且有效的部分，旨在研究有限边界的影响。在情况 A 和 B 中，扩散长度 $\\delta \\approx \\sqrt{Dt}$ 远小于 $L$，这使得半无限近似非常出色。在情况 C 中，$\\delta$ 是 $L$ 的一个不可忽略的部分，这是一个有效的情景，用于测试问题中所述的近似的局限性。\n\n### 第 3 步：结论与行动\n该问题是**有效的**。这是一个在计算电化学领域中定义明确、科学上合理的题目。将提供完整的解答。\n\n### 解答\n该问题要求对一维扩散方程进行数值求解，然后使用理查森外推进行误差分析。\n\n**1. 控制方程与精确解**\n\n向平面电极扩散的物质浓度 $c(x,t)$ 由菲克第二定律控制：\n$$\n\\frac{\\partial c}{\\partial t} = D \\frac{\\partial^2 c}{\\partial x^2}\n$$\n问题定义在有限域 $x \\in [0, L]$ 上，具有以下初始和边界条件：\n$$\nc(x,0) = c_0, \\quad x \\in (0, L]\n$$\n$$\nc(0,t) = 0, \\quad t \\ge 0\n$$\n$$\nc(L,t) = c_0, \\quad t \\ge 0\n$$\n此设置是半无限域问题（$L \\to \\infty$）的数值近似，在半无限域问题中，远场浓度保持不变。对于半无限情况，边界条件 $c(L,t)=c_0$ 被替换为 $\\lim_{x\\to\\infty} c(x,t) = c_0$。这个半无限问题的精确解析解，通常使用拉普拉斯变换或相似变换推导得出，由科特雷尔方程给出：\n$$\nc_{\\text{exact}}(x,t) = c_0 \\text{erf}\\left(\\frac{x}{2\\sqrt{Dt}}\\right)\n$$\n其中 $\\text{erf}$ 是误差函数。该精确解将作为我们比较数值结果的基准。有限域上的数值解与此精确解之间的差异将包括数值离散误差和有限域近似带来的建模误差。\n\n**2. 数值方法：Crank-Nicolson 格式**\n\n我们在空间和时间上对域进行离散化。设 $x_j = j h$ 对于 $j=0, 1, \\dots, N_x$，其中 $h$ 是空间步长且 $N_x h = L$。设 $t_n = n \\Delta t$ 对于 $n=0, 1, \\dots, N_t$，其中 $\\Delta t$ 是时间步长且 $N_t \\Delta t = T$。设 $c_j^n$ 表示 $c(x_j, t_n)$ 的数值近似。\n\n空间二阶导数使用二阶中心差分进行近似：\n$$\n\\frac{\\partial^2 c}{\\partial x^2}\\bigg|_{x_j, t_n} \\approx \\frac{c_{j-1}^n - 2c_j^n + c_{j+1}^n}{h^2}\n$$\nCrank-Nicolson 方法是一种隐式格式，它对当前时间步 $n$ 和下一个时间步 $n+1$ 的空间有限差分进行平均。这在时间上能达到二阶精度。\n$$\n\\frac{c_j^{n+1} - c_j^n}{\\Delta t} = \\frac{D}{2} \\left( \\frac{c_{j-1}^{n+1} - 2c_j^{n+1} + c_{j+1}^{n+1}}{h^2} + \\frac{c_{j-1}^n - 2c_j^n + c_{j+1}^n}{h^2} \\right)\n$$\n这适用于内部网格点，$j = 1, 2, \\dots, N_x-1$。\n\n我们定义扩散数 $\\alpha = \\frac{D \\Delta t}{2h^2}$。我们重新整理方程，将未知项（在时间步 $n+1$）分组到左侧（LHS），将已知项（在时间步 $n$）分组到右侧（RHS）：\n$$\n-\\alpha c_{j-1}^{n+1} + (1+2\\alpha)c_j^{n+1} - \\alpha c_{j+1}^{n+1} = \\alpha c_{j-1}^n + (1-2\\alpha)c_j^n + \\alpha c_{j+1}^n\n$$\n该方程为未知内部浓度 $\\{c_j^{n+1}\\}_{j=1}^{N_x-1}$ 构成了一个包含 $N_x-1$ 个线性方程的方程组。该系统可以写成矩阵形式 $\\mathbf{A} \\mathbf{c}^{n+1} = \\mathbf{d}^n$，其中 $\\mathbf{A}$ 是一个 $(N_x-1) \\times (N_x-1)$ 的三对角矩阵，$\\mathbf{d}^n$ 是右侧向量。\n\n边界条件为 $c_0^n = c(0, t_n) = 0$ 和 $c_{N_x}^n = c(L, t_n) = c_0$ 对于所有 $n$。这些值被并入第一个（$j=1$）和最后一个（$j=N_x-1$）内部点的方程中：\n\n对于 $j=1$：\n$$\n(1+2\\alpha)c_1^{n+1} - \\alpha c_2^{n+1} = \\alpha c_0^n + (1-2\\alpha)c_1^n + \\alpha c_2^n = (1-2\\alpha)c_1^n + \\alpha c_2^n\n$$\n（因为 $c_0^n=0$ 和 $c_0^{n+1}=0$）\n\n对于 $j=N_x-1$：\n$$\n-\\alpha c_{N_x-2}^{n+1} + (1+2\\alpha)c_{N_x-1}^{n+1} = \\alpha c_{N_x-2}^n + (1-2\\alpha)c_{N_x-1}^n + \\alpha c_{N_x}^n + \\alpha c_{N_x}^{n+1}\n$$\n由于 $c_{N_x}^n=c_{N_x}^{n+1}=c_0$，右侧变为：\n$$\n\\text{RHS}_{N_x-1} = \\alpha c_{N_x-2}^n + (1-2\\alpha)c_{N_x-1}^n + 2\\alpha c_0\n$$\n在每个时间步求解得到的三对角系统。由于矩阵 $\\mathbf{A}$ 是常数，这在计算上是高效的，特别是在使用像托马斯算法这样的专用三对角求解器时。\n\n**3. 误差分析与外推**\n\n我们对每种情况进行两次模拟，一次使用空间步长 $h$，另一次使用 $h/2$，同时保持 $\\Delta t$ 不变。这样可以分离出由空间离散化引起的误差贡献。\n\n**观测精度阶 ($p$)**：\n空间离散误差的主导项形式为 $E_h \\approx K h^p$，其中 $K$ 是一个常数，$p$ 是精度阶。对于我们的二阶中心差分格式，我们期望 $p \\approx 2$。给定步长为 $h$ 和 $h/2$ 时的数值误差 $E_h$ 和 $E_{h/2}$，我们可以估计 $p$：\n$$\n\\frac{E_h}{E_{h/2}} \\approx \\frac{K h^p}{K (h/2)^p} = 2^p \\implies p \\approx \\log_2\\left(\\frac{E_h}{E_{h/2}}\\right)\n$$\n其中 $E_h = |c_h(x_\\star,T) - c_{\\text{exact}}(x_\\star,T)|$。\n\n**理查森外推**：\n该技术通过结合来自两个不同网格间距的结果，提供了一个更精确的解的估计值。设 $C_h$ 和 $C_{h/2}$ 分别为步长为 $h$ 和 $h/2$ 时在 $x_\\star$ 处的数值解，而 $C_{\\text{exact}}$ 为真实解。我们有：\n$$\nC_h \\approx C_{\\text{exact}} + K h^p\n$$\n$$\nC_{h/2} \\approx C_{\\text{exact}} + K (h/2)^p\n$$\n消去误差项 $K h^p$，我们得到一个改进的估计值 $C_{RE}$：\n$$\nC_{RE} = \\frac{2^p C_{h/2} - C_h}{2^p - 1} = C_{h/2} + \\frac{C_{h/2} - C_h}{2^p-1}\n$$\n根据题目要求，我们在此公式中使用数值观测到的精度阶 $p$。\n\n**4. 计算策略**\n\n对于每个测试用例，算法如下：\n1.  为粗网格（$h$）和细网格（$h/2$）定义物理和数值参数。\n2.  对于每个网格：\n    a. 确定空间点数 $N_x$ 和时间步数 $N_t$。\n    b. 根据初始条件 $x0$ 时 $c(x,0)=c_0$ 以及 $c(0,0)=0$ 初始化浓度向量 $c$。\n    c. 以适用于 `scipy.linalg.solve_banded` 的带状格式构造三对角矩阵 $\\mathbf{A}$。\n    d. 从 $n=0$ 到 $N_t-1$ 进行循环：\n        i. 基于时间 $t_n$ 的浓度构造右侧向量 $\\mathbf{d}^n$。\n        ii. 求解线性系统 $\\mathbf{A} \\mathbf{c}^{n+1} = \\mathbf{d}^n$ 以找到时间 $t_{n+1}$ 的浓度。\n    e. 时间步进循环结束后，如果特定点 $x_\\star$ 不落在网格节点上，则使用线性插值来找到该点的浓度。\n3.  计算在 $(x_\\star, T)$ 处的精确解 $c_{\\text{exact}}$。\n4.  计算绝对误差 $E_h$ 和 $E_{h/2}$。\n5.  计算观测精度阶 $p$。\n6.  计算理查森外推浓度 $C_{RE}$。\n7.  存储对 $[C_{RE}, p]$ 以用于最终输出。\n8.  对所有测试用例重复此过程，并按规定格式化最终输出。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import erf\nfrom scipy.linalg import solve_banded\n\ndef run_simulation(D, c0, L, T, h, dt, x_star):\n    \"\"\"\n    Solves the 1D diffusion equation using the Crank-Nicolson method.\n\n    Returns:\n        float: The numerical concentration at position x_star and time T.\n    \"\"\"\n    # Grid setup\n    if not np.isclose(L/h, round(L/h)):\n        raise ValueError(\"L must be an integer multiple of h.\")\n    Nx = int(round(L / h))\n    Nt = int(round(T / dt))\n\n    # Grid points in space\n    x = np.linspace(0, L, Nx + 1)\n    \n    # Diffusion number\n    alpha = D * dt / (2.0 * h**2)\n\n    # Initial condition\n    c = np.full(Nx + 1, c0)\n    c[0] = 0.0\n\n    # Number of interior points\n    N_int = Nx - 1\n    if N_int = 0:\n        # Handle trivial case of no interior points\n        if x_star == 0: return 0.0\n        if x_star == L: return c0\n        return (c0/L) * x_star # Linear interp if no simulation happens\n\n    # Tridiagonal matrix A for the LHS, in banded format for solve_banded\n    ab = np.zeros((3, N_int))\n    ab[0, 1:] = -alpha\n    ab[1, :] = 1.0 + 2.0 * alpha\n    ab[2, :-1] = -alpha\n\n    # Time stepping loop\n    for _ in range(Nt):\n        # Construct the RHS vector rhs\n        rhs = np.zeros(N_int)\n        \n        # Vectorized calculation for internal part of RHS\n        if N_int > 2:\n            rhs[1:-1] = alpha * c[1:-3] + (1.0 - 2.0 * alpha) * c[2:-2] + alpha * c[3:-1]\n\n        # Handle endpoints of the RHS vector\n        # RHS for j=1 (index 0)\n        if N_int > 0:\n           rhs[0] = alpha * c[0] + (1.0 - 2.0 * alpha) * c[1] + alpha * c[2]\n        \n        # RHS for j=Nx-1 (index N_int-1)\n        if N_int > 1:\n           rhs[N_int-1] = alpha * c[Nx-2] + (1.0 - 2.0 * alpha) * c[Nx-1] + alpha * c[Nx]\n        \n        # Add boundary condition source terms for next time step\n        # Left BC c[0] is 0, no term to add.\n        # Right BC c[Nx] is c0, term alpha*c[Nx] is already in rhs[-1] from previous step\n        # We need to add alpha*c_new[Nx] = alpha*c0\n        if N_int > 0:\n            rhs[-1] += alpha * c0\n\n        # Solve the tridiagonal system for the next time step's interior points\n        c_new_int = solve_banded((1, 1), ab, rhs)\n        c[1:Nx] = c_new_int\n\n    # Interpolate to find concentration at x_star\n    if not (0 = x_star = L):\n        raise ValueError(\"x_star must be within the domain [0, L]\")\n    \n    pos = x_star / h\n    j = int(np.floor(pos))\n    \n    if np.isclose(pos, j):\n        return c[j]\n    elif j + 1 = Nx:\n        frac = pos - j\n        return c[j] * (1.0 - frac) + c[j+1] * frac\n    else: \n        return c[Nx]\n\ndef solve():\n    test_cases = [\n        # Case A\n        {'D': 1.0e-9, 'c0': 1.0, 'L': 1.0e-3, 'T': 0.1, 'x_star': 5.0e-5, 'h': 2.0e-5, 'dt': 5.0e-4},\n        # Case B\n        {'D': 1.0e-10, 'c0': 1.0, 'L': 1.0e-3, 'T': 0.01, 'x_star': 1.0e-5, 'h': 5.0e-5, 'dt': 5.0e-5},\n        # Case C\n        {'D': 1.0e-9, 'c0': 1.0, 'L': 1.0e-4, 'T': 0.1, 'x_star': 5.0e-5, 'h': 2.0e-6, 'dt': 5.0e-4},\n    ]\n\n    results = []\n    for params in test_cases:\n        D, c0, L, T = params['D'], params['c0'], params['L'], params['T']\n        x_star, h, dt = params['x_star'], params['h'], params['dt']\n\n        # Run for coarse grid (h)\n        c_h = run_simulation(D, c0, L, T, h, dt, x_star)\n\n        # Run for fine grid (h/2)\n        c_h2 = run_simulation(D, c0, L, T, h / 2.0, dt, x_star)\n\n        # Calculate exact solution for semi-infinite domain\n        c_exact = c0 * erf(x_star / (2.0 * np.sqrt(D * T)))\n\n        # Calculate errors\n        error_h = abs(c_h - c_exact)\n        error_h2 = abs(c_h2 - c_exact)\n\n        # Calculate observed order of accuracy, p\n        if error_h2 == 0 or error_h == 0:\n            p = np.inf if error_h > 0 else 0\n        else:\n            p = np.log2(error_h / error_h2)\n\n        # Calculate Richardson extrapolation\n        if np.isclose(2**p, 1.0):\n            c_richardson = c_h2\n        else:\n            c_richardson = c_h2 + (c_h2 - c_h) / (2.0**p - 1.0)\n        \n        results.append([c_richardson, p])\n\n    # Format output string\n    formatted_results = []\n    for res in results:\n        p_val = res[1] if np.isfinite(res[1]) else 0.0\n        formatted_results.append(f\"[{res[0]:.6f},{p_val:.6f}]\")\n    \n    final_output = f\"[[{','.join(formatted_results)}]]\"\n    # The output format is [[c_A,p_A],[c_B,p_B],[c_C,p_C]]\n    # My joiner is creating [[c_A,p_A],[c_B,p_B],[c_C,p_C]] - which is almost correct\n    # The requirement is \"[[c_A,p_A],[c_B,p_B],[c_C,p_C]]\"\n    # A single join with comma is needed.\n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}