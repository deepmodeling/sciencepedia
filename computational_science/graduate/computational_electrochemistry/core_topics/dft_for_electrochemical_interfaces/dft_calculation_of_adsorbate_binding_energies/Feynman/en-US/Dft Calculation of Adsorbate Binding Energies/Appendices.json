{
    "hands_on_practices": [
        {
            "introduction": "The reliability of any result from a plane-wave Density Functional Theory (DFT) calculation hinges on its convergence with respect to key numerical parameters. This first exercise guides you through the essential practice of performing a convergence study for the plane-wave energy cutoff, $E_{\\text{cut}}$, a parameter that dictates the size of the basis set. By working with a realistic (though synthetic) error model, you will implement a protocol to systematically determine the minimum cutoff required to achieve a desired accuracy for the adsorption energy, a foundational skill for producing robust and reproducible computational results .",
            "id": "4241951",
            "problem": "You are asked to design and implement a complete, runnable program that, based on first-principles definitions and widely accepted numerical error behavior in plane-wave Density Functional Theory (DFT), analyzes how the plane-wave basis set cutoff and the real-space grid density impact the computed adsorption energy and then constructs a systematic convergence protocol for the plane-wave cutoff. The adsorption energy for an adsorbate bound to a surface is defined by the difference of total energies, namely $E_{\\text{ads}} = E_{\\text{slab+ads}} - E_{\\text{slab}} - E_{\\text{adsorbate}}$, where each total energy is computed by a plane-wave DFT method. In a plane-wave method, the plane-wave basis truncation is governed by an energy cutoff parameter $E_{\\text{cut}}$ which sets the maximum reciprocal-space vector magnitude for the plane-wave basis. The real-space grid used to represent charge density and potentials is related to the maximum reciprocal-space frequency by a characteristic grid spacing $h$. In the simplest idealization consistent with Fourier analysis of periodic functions, the largest included reciprocal-space vector magnitude scales as $G_{\\max} \\propto \\sqrt{E_{\\text{cut}}}$, and a representative real-space grid spacing scales inversely as $h \\propto \\frac{1}{G_{\\max}}$. Introducing a dimensionless grid density factor $s \\geq 1$ that multiplies the reciprocal-space resolution (with larger $s$ meaning denser real-space grid), we adopt the relation $h(E_{\\text{cut}},s) = \\frac{\\alpha}{\\sqrt{E_{\\text{cut}}}\\, s}$, where $\\alpha$ is a positive constant fixed for the study. \n\nConsistent with truncation and discretization error theory for Fourier representations of sufficiently smooth functions, we assume leading-order numerical errors for each total energy (slab with adsorbate, slab alone, adsorbate alone) to be the sum of two positive contributions: a basis-set truncation error that decays as a power law in $E_{\\text{cut}}$ and a grid discretization error that decays as a power law in $h$. For an entity $X \\in \\{\\text{slab+ads}, \\text{slab}, \\text{adsorbate}\\}$, we model the computed total energy as \n$$\nE_X(E_{\\text{cut}}, s) = E_X^{\\text{true}} + B_X\\, E_{\\text{cut}}^{-p_X} + G_X\\, h(E_{\\text{cut}},s)^{q_X},\n$$\nwhere $E_X^{\\text{true}}$ is the true total energy, $B_X$ and $G_X$ are positive error prefactors, and $p_X > 0$ and $q_X > 0$ are convergence exponents. The adsorption energy then follows from the above definition and the cancellation of some errors when forming the energy difference:\n$$\nE_{\\text{ads}}(E_{\\text{cut}},s) = E_{\\text{slab+ads}}(E_{\\text{cut}},s) - E_{\\text{slab}}(E_{\\text{cut}},s) - E_{\\text{adsorbate}}(E_{\\text{cut}},s).\n$$\nFor the purposes of this programming challenge, you will use the above error model to generate synthetic data and then implement a convergence protocol. The convergence protocol must: \n- estimate the asymptotic adsorption energy $E_{\\text{ads}}^{\\infty}$ corresponding to $E_{\\text{cut}} \\to \\infty$ and a sufficiently dense grid, by fitting $E_{\\text{ads}}(E_{\\text{cut}}, s_{\\max})$ at the densest grid $s_{\\max}$ to an inverse power-law model of the form \n$$\nE_{\\text{ads}}(E_{\\text{cut}}, s_{\\max}) \\approx E_{\\text{ads}}^{\\infty} + K\\, E_{\\text{cut}}^{-p},\n$$\nwhere $K$ and $p$ are parameters to be determined by nonlinear least squares. \n- define and compute a recommended minimal plane-wave cutoff $E_{\\text{cut}}^{\\text{rec}}$ such that the remaining basis-set truncation error magnitude $|K| E_{\\text{cut}}^{-p}$ is below a given tolerance $\\varepsilon > 0$, i.e., \n$$\nE_{\\text{cut}}^{\\text{rec}} \\ge \\left(\\frac{|K|}{\\varepsilon}\\right)^{1/p}.\n$$\n- determine the minimal grid density factor $s^{\\text{rec}}$ at the recommended cutoff $E_{\\text{cut}}^{\\text{rec}}$ such that the difference $|E_{\\text{ads}}(E_{\\text{cut}}^{\\text{rec}}, s) - E_{\\text{ads}}(E_{\\text{cut}}^{\\text{rec}}, s_{\\max})|$ is not greater than $\\varepsilon$, choosing the smallest $s$ that satisfies this condition. \n- return, for each test case, the recommended cutoff $E_{\\text{cut}}^{\\text{rec}}$, the recommended grid density factor $s^{\\text{rec}}$, the estimated converged adsorption energy $E_{\\text{ads}}^{\\infty}$, and a boolean flag indicating whether convergence targets are achievable within the provided discrete sets of cutoffs and grid factors.\n\nYou must implement your protocol in code and apply it to the following explicit test suite scenarios. Energies are in $\\mathrm{eV}$, cutoffs are in $\\mathrm{eV}$, and grid spacing is in $\\mathrm{\\AA}$; the final adsorption energies must be expressed in $\\mathrm{eV}$. Use the discrete sets of cutoffs and grid factors given below; when selecting a recommended cutoff, you must choose the smallest element of the provided cutoff set that satisfies the inequality above, or the maximum available cutoff if the inequality cannot be satisfied. When selecting a recommended grid density factor, you must choose the smallest element of the provided grid factor set that satisfies the grid tolerance criterion, or the maximum available grid factor if none satisfy the criterion. The tolerance $\\varepsilon$ should be applied in $\\mathrm{eV}$. \n\nAdopt the grid spacing model \n$$\nh(E_{\\text{cut}},s) = \\frac{\\alpha}{\\sqrt{E_{\\text{cut}}}\\, s}.\n$$\n\nDefine the test suite with three scenarios, each providing $(E_X^{\\text{true}}, B_X, p_X, G_X, q_X)$ for $X \\in \\{\\text{slab+ads}, \\text{slab}, \\text{adsorbate}\\}$, along with the shared constants $\\alpha$, the discrete cutoff set, the discrete grid factor set, and the tolerance $\\varepsilon$:\n\n- Scenario $1$ (general \"happy path\"): \n  - $E_{\\text{slab+ads}}^{\\text{true}} = -100.0\\,\\mathrm{eV}$, $E_{\\text{slab}}^{\\text{true}} = -99.3\\,\\mathrm{eV}$, $E_{\\text{adsorbate}}^{\\text{true}} = -0.2\\,\\mathrm{eV}$.\n  - $B_{\\text{slab+ads}} = 12.0$, $p_{\\text{slab+ads}} = 1.8$; $B_{\\text{slab}} = 11.4$, $p_{\\text{slab}} = 1.8$; $B_{\\text{adsorbate}} = 0.3$, $p_{\\text{adsorbate}} = 1.8$.\n  - $G_{\\text{slab+ads}} = 0.20$, $q_{\\text{slab+ads}} = 2.0$; $G_{\\text{slab}} = 0.18$, $q_{\\text{slab}} = 2.0$; $G_{\\text{adsorbate}} = 0.01$, $q_{\\text{adsorbate}} = 2.0$.\n  - $\\alpha = 20.0$.\n  - Discrete cutoff set: $\\{300.0, 400.0, 500.0, 600.0\\}\\,\\mathrm{eV}$.\n  - Discrete grid factor set: $\\{1.0, 1.5, 2.0\\}$.\n  - Tolerance: $\\varepsilon = 0.01\\,\\mathrm{eV}$.\n\n- Scenario $2$ (boundary case with slow basis convergence):\n  - $E_{\\text{slab+ads}}^{\\text{true}} = -250.0\\,\\mathrm{eV}$, $E_{\\text{slab}}^{\\text{true}} = -249.0\\,\\mathrm{eV}$, $E_{\\text{adsorbate}}^{\\text{true}} = -0.8\\,\\mathrm{eV}$.\n  - $B_{\\text{slab+ads}} = 20.0$, $p_{\\text{slab+ads}} = 0.8$; $B_{\\text{slab}} = 5.0$, $p_{\\text{slab}} = 1.6$; $B_{\\text{adsorbate}} = 2.0$, $p_{\\text{adsorbate}} = 1.2$.\n  - $G_{\\text{slab+ads}} = 0.10$, $q_{\\text{slab+ads}} = 2.0$; $G_{\\text{slab}} = 0.10$, $q_{\\text{slab}} = 2.0$; $G_{\\text{adsorbate}} = 0.05$, $q_{\\text{adsorbate}} = 2.0$.\n  - $\\alpha = 20.0$.\n  - Discrete cutoff set: $\\{300.0, 400.0, 500.0, 600.0\\}\\,\\mathrm{eV}$.\n  - Discrete grid factor set: $\\{1.0, 1.5, 2.0\\}$.\n  - Tolerance: $\\varepsilon = 0.01\\,\\mathrm{eV}$.\n\n- Scenario $3$ (edge case with strong error cancellation in $E_{\\text{ads}}$):\n  - $E_{\\text{slab+ads}}^{\\text{true}} = -150.0\\,\\mathrm{eV}$, $E_{\\text{slab}}^{\\text{true}} = -149.4\\,\\mathrm{eV}$, $E_{\\text{adsorbate}}^{\\text{true}} = -0.4\\,\\mathrm{eV}$.\n  - $B_{\\text{slab+ads}} = 8.0$, $p_{\\text{slab+ads}} = 1.6$; $B_{\\text{slab}} = 7.98$, $p_{\\text{slab}} = 1.6$; $B_{\\text{adsorbate}} = 0.01$, $p_{\\text{adsorbate}} = 1.6$.\n  - $G_{\\text{slab+ads}} = 0.08$, $q_{\\text{slab+ads}} = 2.0$; $G_{\\text{slab}} = 0.079$, $q_{\\text{slab}} = 2.0$; $G_{\\text{adsorbate}} = 0.001$, $q_{\\text{adsorbate}} = 2.0$.\n  - $\\alpha = 20.0$.\n  - Discrete cutoff set: $\\{300.0, 400.0, 500.0, 600.0\\}\\,\\mathrm{eV}$.\n  - Discrete grid factor set: $\\{1.0, 1.5, 2.0\\}$.\n  - Tolerance: $\\varepsilon = 0.01\\,\\mathrm{eV}$.\n\nYour program must, for each scenario, generate $E_{\\text{ads}}(E_{\\text{cut}}, s)$ at every combination of $E_{\\text{cut}}$ in the provided discrete cutoff set and $s$ in the provided discrete grid factor set, perform the cutoff convergence fit at the densest grid $s_{\\max} = \\max\\{s\\}$, estimate $E_{\\text{ads}}^{\\infty}$, compute $E_{\\text{cut}}^{\\text{rec}}$ subject to the discrete cutoff set, find $s^{\\text{rec}}$ subject to the discrete grid factor set, and determine whether the targets are achievable under the given discrete sets. \n\nFinal output format requirement: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with one entry per scenario. Each scenario’s entry must itself be a list of the form $[E_{\\text{cut}}^{\\text{rec}}, s^{\\text{rec}}, E_{\\text{ads}}^{\\infty}, \\text{is\\_converged}]$, where $E_{\\text{cut}}^{\\text{rec}}$ and $E_{\\text{ads}}^{\\infty}$ are floats in $\\mathrm{eV}$, $s^{\\text{rec}}$ is a float, and $\\text{is\\_converged}$ is a boolean. For example, the output format should look like $[[x_1,y_1,z_1,b_1],[x_2,y_2,z_2,b_2],[x_3,y_3,z_3,b_3]]$ with no additional text.",
            "solution": "The user has provided a well-defined computational problem grounded in the principles of plane-wave Density Functional Theory (DFT). The problem is to implement a convergence-testing protocol for two key numerical parameters: the plane-wave cutoff energy, $E_{\\text{cut}}$, and a real-space grid density factor, $s$. The protocol is to be applied to synthetic data generated from a plausible error model for the adsorption energy, $E_{\\text{ads}}$, of a species on a surface.\n\nThe problem is valid as it is scientifically grounded, self-contained, and algorithmically specified. It represents a common and crucial workflow in computational materials science and chemistry. We will proceed with a step-by-step solution.\n\nFirst, we formalize the data generation process. The total energy of any component $X \\in \\{\\text{slab+ads}, \\text{slab}, \\text{adsorbate}\\}$ is modeled as a function of $E_{\\text{cut}}$ and $s$:\n$$\nE_X(E_{\\text{cut}}, s) = E_X^{\\text{true}} + B_X E_{\\text{cut}}^{-p_X} + G_X h(E_{\\text{cut}},s)^{q_X}\n$$\nThe term $E_X^{\\text{true}}$ is the exact, fully converged energy. The second term, $B_X E_{\\text{cut}}^{-p_X}$, represents the basis set truncation error, which decays as a power law of the cutoff energy. The third term, $G_X h(E_{\\text{cut}},s)^{q_X}$, represents the real-space grid discretization error, which decays as a power law of the grid spacing $h$. The grid spacing $h$ is itself a function of $E_{\\text{cut}}$ and the dimensionless grid density factor $s$:\n$$\nh(E_{\\text{cut}},s) = \\frac{\\alpha}{\\sqrt{E_{\\text{cut}}}\\, s}\n$$\nThe adsorption energy, $E_{\\text{ads}}$, is the quantity of interest, defined as the difference in total energies:\n$$\nE_{\\text{ads}}(E_{\\text{cut}},s) = E_{\\text{slab+ads}}(E_{\\text{cut}},s) - E_{\\text{slab}}(E_{\\text{cut}},s) - E_{\\text{adsorbate}}(E_{\\text{cut}},s)\n$$\nBy substituting the expressions for each total energy, we obtain the model for the calculated adsorption energy. For each scenario, we will use these equations to generate a table of $E_{\\text{ads}}$ values for every combination of the provided discrete $E_{\\text{cut}}$ and $s$ values.\n\nThe convergence protocol consists of four main steps, which we will implement for each test scenario.\n\n1.  **Estimate the Asymptotic Adsorption Energy, $E_{\\text{ads}}^{\\infty}$**:\n    The first step is to estimate the adsorption energy in the limit of an infinite basis set ($E_{\\text{cut}} \\to \\infty$). The protocol specifies using the data from the densest available real-space grid, i.e., at $s_{\\max} = \\max\\{s_i\\}$, where $\\{s_i\\}$ is the set of provided grid density factors. The calculated values $E_{\\text{ads}}(E_{\\text{cut}}, s_{\\max})$ are fitted to the following simplified model using the method of nonlinear least squares:\n    $$\n    E_{\\text{ads}}(E_{\\text{cut}}, s_{\\max}) \\approx E_{\\text{ads}}^{\\infty} + K\\, E_{\\text{cut}}^{-p}\n    $$\n    The fit yields the parameters $E_{\\text{ads}}^{\\infty}$, $K$, and $p$. We will employ the `scipy.optimize.curve_fit` function for this purpose. The function requires an initial guess for the parameters; we will use the theoretically known true adsorption energy, $E_{\\text{ads}}^{\\text{true}} = E_{\\text{slab+ads}}^{\\text{true}} - E_{\\text{slab}}^{\\text{true}} - E_{\\text{adsorbate}}^{\\text{true}}$, as a guess for $E_{\\text{ads}}^{\\infty}$, and reasonable starting values for $K$ and $p$.\n\n2.  **Determine the Recommended Plane-Wave Cutoff, $E_{\\text{cut}}^{\\text{rec}}$**:\n    Using the parameters from the fit, we estimate the remaining basis-set error at a given cutoff as $|K| E_{\\text{cut}}^{-p}$. The protocol requires finding a recommended cutoff, $E_{\\text{cut}}^{\\text{rec}}$, such that this error is less than or equal to a specified tolerance, $\\varepsilon$. This condition is expressed as:\n    $$\n    |K|\\,(E_{\\text{cut}}^{\\text{rec}})^{-p} \\le \\varepsilon \\quad \\Longleftrightarrow \\quad E_{\\text{cut}}^{\\text{rec}} \\ge \\left(\\frac{|K|}{\\varepsilon}\\right)^{1/p}\n    $$\n    We must choose $E_{\\text{cut}}^{\\text{rec}}$ from the discrete set of available cutoffs. The rule is to select the smallest cutoff from the set that satisfies this inequality. If no cutoff in the set satisfies the condition, $E_{\\text{cut}}^{\\text rec}$ is set to the maximum available cutoff.\n\n3.  **Determine the Recommended Grid Density Factor, $s^{\\text{rec}}$**:\n    Next, we fix the cutoff at the value $E_{\\text{cut}}^{\\text{rec}}$ and determine the minimum grid density factor, $s^{\\text{rec}}$, needed to converge the grid-dependent error. The convergence is measured against the result at the densest available grid, $s_{\\max}$. The condition is:\n    $$\n    |E_{\\text{ads}}(E_{\\text{cut}}^{\\text{rec}}, s^{\\text{rec}}) - E_{\\text{ads}}(E_{\\text{cut}}^{\\text{rec}}, s_{\\max})| \\le \\varepsilon\n    $$\n    We must choose $s^{\\text{rec}}$ from the discrete set of available grid factors. The rule is to select the smallest factor $s$ that satisfies this condition. If no factor in the set satisfies it, $s^{\\textrec}$ is set to the maximum available factor.\n\n4.  **Assess Convergence Achievability, `is_converged`**:\n    A boolean flag, `is_converged`, is determined to report whether the convergence targets for both $E_{\\text{cut}}$ and $s$ were achieved within the provided discrete sets. This flag will be `True` only if a candidate value satisfying the tolerance was found for *both* $E_{\\text{cut}}^{\\text{rec}}$ and $s^{\\text{rec}}$. If for either parameter we had to default to the maximum available value because the tolerance could not be met, the flag will be `False`.\n\nThe implementation will process each of the three scenarios, execute this four-step protocol, and collate the results ($E_{\\text{cut}}^{\\text{rec}}$, $s^{\\text{rec}}$, $E_{\\text{ads}}^{\\infty}$, `is_converged`) into a final list.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef solve():\n    \"\"\"\n    Implements and runs a convergence analysis protocol for plane-wave DFT calculations\n    based on a provided error model and test scenarios.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Scenario 1: General \"happy path\"\n        {\n            \"params\": {\n                \"slab+ads\": {\"E_true\": -100.0, \"B\": 12.0, \"p\": 1.8, \"G\": 0.20, \"q\": 2.0},\n                \"slab\":     {\"E_true\": -99.3,  \"B\": 11.4, \"p\": 1.8, \"G\": 0.18, \"q\": 2.0},\n                \"adsorbate\":{\"E_true\": -0.2,   \"B\": 0.3, \"p\": 1.8, \"G\": 0.01, \"q\": 2.0}\n            },\n            \"alpha\": 20.0,\n            \"cutoffs\": np.array([300.0, 400.0, 500.0, 600.0]),\n            \"s_factors\": np.array([1.0, 1.5, 2.0]),\n            \"epsilon\": 0.01\n        },\n        # Scenario 2: Boundary case with slow basis convergence\n        {\n            \"params\": {\n                \"slab+ads\": {\"E_true\": -250.0, \"B\": 20.0, \"p\": 0.8, \"G\": 0.10, \"q\": 2.0},\n                \"slab\":     {\"E_true\": -249.0, \"B\": 5.0,  \"p\": 1.6, \"G\": 0.10, \"q\": 2.0},\n                \"adsorbate\":{\"E_true\": -0.8,   \"B\": 2.0,  \"p\": 1.2, \"G\": 0.05, \"q\": 2.0}\n            },\n            \"alpha\": 20.0,\n            \"cutoffs\": np.array([300.0, 400.0, 500.0, 600.0]),\n            \"s_factors\": np.array([1.0, 1.5, 2.0]),\n            \"epsilon\": 0.01\n        },\n        # Scenario 3: Edge case with strong error cancellation\n        {\n            \"params\": {\n                \"slab+ads\": {\"E_true\": -150.0, \"B\": 8.0,  \"p\": 1.6, \"G\": 0.08,  \"q\": 2.0},\n                \"slab\":     {\"E_true\": -149.4, \"B\": 7.98, \"p\": 1.6, \"G\": 0.079, \"q\": 2.0},\n                \"adsorbate\":{\"E_true\": -0.4,   \"B\": 0.01, \"p\": 1.6, \"G\": 0.001, \"q\": 2.0}\n            },\n            \"alpha\": 20.0,\n            \"cutoffs\": np.array([300.0, 400.0, 500.0, 600.0]),\n            \"s_factors\": np.array([1.0, 1.5, 2.0]),\n            \"epsilon\": 0.01\n        }\n    ]\n\n    def h_spacing(E_cut, s, alpha):\n        return alpha / (np.sqrt(E_cut) * s)\n\n    def total_energy(E_cut, s, E_true, B, p, G, q, alpha):\n        h = h_spacing(E_cut, s, alpha)\n        return E_true + B * E_cut**(-p) + G * h**q\n\n    def ads_energy(E_cut, s, params, alpha):\n        E_sad = total_energy(E_cut, s, **params[\"slab+ads\"], alpha=alpha)\n        E_sl = total_energy(E_cut, s, **params[\"slab\"], alpha=alpha)\n        E_ad = total_energy(E_cut, s, **params[\"adsorbate\"], alpha=alpha)\n        return E_sad - E_sl - E_ad\n\n    def fit_model(E_cut, E_ads_inf, K, p):\n        return E_ads_inf + K * E_cut**(-p)\n\n    results = []\n    for case in test_cases:\n        params = case[\"params\"]\n        alpha = case[\"alpha\"]\n        cutoffs = case[\"cutoffs\"]\n        s_factors = case[\"s_factors\"]\n        epsilon = case[\"epsilon\"]\n\n        # Step 1: Fit for asymptotic energy E_ads_inf\n        s_max = np.max(s_factors)\n        E_ads_at_s_max = np.array([ads_energy(ec, s_max, params, alpha) for ec in cutoffs])\n        \n        true_E_ads_inf = params[\"slab+ads\"][\"E_true\"] - params[\"slab\"][\"E_true\"] - params[\"adsorbate\"][\"E_true\"]\n        p0 = [true_E_ads_inf, 1.0, 1.5] # Initial guess for E_ads_inf, K, p\n        \n        try:\n            popt, _ = curve_fit(fit_model, cutoffs, E_ads_at_s_max, p0=p0, maxfev=5000)\n            E_ads_inf, K, p_fit = popt\n            fit_valid = p_fit > 0 and not np.isinf(K) and not np.isnan(K)\n        except RuntimeError:\n            fit_valid = False\n\n        if not fit_valid:\n            E_cut_rec = np.max(cutoffs)\n            s_rec = np.max(s_factors)\n            is_converged = False\n            results.append([float(E_cut_rec), float(s_rec), np.nan, is_converged])\n            continue\n\n        # Step 2: Determine recommended cutoff E_cut_rec\n        E_cut_thresh = (np.abs(K) / epsilon)**(1 / p_fit)\n        E_cut_candidates = cutoffs[cutoffs >= E_cut_thresh]\n        \n        if E_cut_candidates.size > 0:\n            E_cut_rec = np.min(E_cut_candidates)\n            cutoff_converged = True\n        else:\n            E_cut_rec = np.max(cutoffs)\n            cutoff_converged = False\n\n        # Step 3: Determine recommended grid factor s_rec\n        E_ads_target_grid = ads_energy(E_cut_rec, s_max, params, alpha)\n        s_rec_candidates = []\n        for s_val in s_factors:\n            E_ads_current_s = ads_energy(E_cut_rec, s_val, params, alpha)\n            if np.abs(E_ads_current_s - E_ads_target_grid) = epsilon:\n                s_rec_candidates.append(s_val)\n\n        if s_rec_candidates:\n            s_rec = np.min(s_rec_candidates)\n            grid_converged = True\n        else:\n            s_rec = np.max(s_factors)\n            grid_converged = False\n\n        # Step 4: Determine final convergence status\n        is_converged = cutoff_converged and grid_converged\n\n        results.append([float(E_cut_rec), float(s_rec), E_ads_inf, is_converged])\n\n    # Final print statement in the exact required format.\n    # Manually construct string to match example format [[a,b,c,d],[e,f,g,h]] with no spaces.\n    outer_parts = []\n    for res_list in results:\n        # Format boolean as lowercase true/false\n        inner_parts = [str(v) for v in res_list[:-1]] + [str(res_list[-1]).lower()]\n        outer_parts.append(f\"[{','.join(inner_parts)}]\")\n    \n    print(f\"[{','.join(outer_parts)}]\")\n    \nsolve()\n```"
        },
        {
            "introduction": "Having established how to obtain a numerically converged binding energy, we now turn to incorporating the complexities of the electrochemical environment. This practice introduces the powerful Computational Hydrogen Electrode (CHE) model, a cornerstone of modern computational electrochemistry that allows us to relate the energy of a surface reaction to a measurable electrode potential, $U$. You will construct a complete thermodynamic cycle from first principles to compute the potential- and pH-dependent adsorption free energy of a hydroxyl radical ($\\mathrm{OH}^*$), transforming a raw DFT energy difference into a physically meaningful quantity that can predict electrochemical behavior .",
            "id": "4241853",
            "problem": "You are to construct a complete computational protocol, expressed as a runnable program, to compute the adsorption free energy $E_{\\text{ads}}$ of hydroxyl on a surface ($\\mathrm{OH^*}$) using Density Functional Theory (DFT)-level energies of water $\\mathrm{H_2O}$ and hydrogen $\\mathrm{H_2}$ as references, and to compare these results to those obtained via the Computational Hydrogen Electrode (CHE) framework at specified electrode potentials and acidity. The program must implement the protocol from first principles, not by invoking a ready-made formula, and must output the results in a strictly defined format as described below.\n\nFoundational bases to be used:\n- The thermodynamic free energy of a species is $G = E_{\\text{elec}} + E_{\\text{ZPE}} - T S$, where $E_{\\text{elec}}$ is the electronic energy, $E_{\\text{ZPE}}$ is the zero-point energy, $T$ is the absolute temperature, and $S$ is the entropy.\n- The adsorption reaction to be considered is $\\mathrm{H_2O(l)} + * \\rightarrow \\mathrm{OH^*} + \\mathrm{H^+} + \\mathrm{e^-}$, where $*$ denotes an empty surface site. The stoichiometric combination of free energies for initial and final states defines the adsorption free energy relative to the $\\mathrm{H_2O}$ and $\\mathrm{H_2}$ references at standard conditions.\n- In the Computational Hydrogen Electrode (CHE) framework, the chemical potential of the proton–electron pair is set by an equilibrium with molecular hydrogen at a given electrode potential and acidity (pH). You must incorporate the effect of the electrode potential and pH consistently using Boltzmann statistics at finite temperature, where the thermal factor $k_B T$ appears, with $k_B$ the Boltzmann constant.\n\nThermodynamic and physical constants to use:\n- Temperature $T = 298.15$ K.\n- Boltzmann constant $k_B = 8.617333262145\\times 10^{-5}$ eV/K.\n- Natural logarithm of ten $\\ln(10)$.\n- Avogadro’s number $N_A = 6.02214076\\times 10^{23}$ mol$^{-1}$.\n- Elementary charge $e = 1.602176634\\times 10^{-19}$ C.\n- When converting molar entropy to per-particle energy units, use $T S$ in $\\mathrm{J/mol}$, convert to $\\mathrm{J}$ per particle via division by $N_A$, and then convert to $\\mathrm{eV}$ by division by $e$.\n\nProtocol requirements:\n1. Compute the free energies $G(\\mathrm{H_2})$ and $G(\\mathrm{H_2O})$ using the given DFT electronic energies, zero-point energies, and molar entropies. All energies and outputs must be reported in electronvolts (eV).\n2. For the surface, compute $G(\\mathrm{OH^*}) - G(*)$ from the given DFT electronic energies of the slab with $\\mathrm{OH^*}$ and the bare slab, including the zero-point energy and entropy of the adsorbed hydroxyl (assume the adsorbed hydroxyl entropy is negligible and take $S(\\mathrm{OH^*}) = 0$ J/mol/K).\n3. Construct the adsorption free energy relative to the $\\mathrm{H_2O}$ and $\\mathrm{H_2}$ references at standard conditions ($U = 0$ V versus the Reversible Hydrogen Electrode, $\\mathrm{pH} = 0$), denoted $E_{\\text{ads}}^{\\mathrm{ref0}}$.\n4. Using the CHE framework, adjust the adsorption free energy for finite $U$ and $\\mathrm{pH}$ to obtain $E_{\\text{ads}}^{\\mathrm{CHE}}(U,\\mathrm{pH})$ by replacing the proton–electron chemical potential with its equilibrium form against $\\mathrm{H_2}$ at the specified $U$ and $\\mathrm{pH}$, ensuring that the dependence on $U$ and $\\mathrm{pH}$ enters via $k_B T$ and $\\ln(10)$ as appropriate for acidity.\n5. All final numerical answers must be floats in eV, rounded to three decimal places.\n\nAngle units are not involved in this task.\n\nTest suite:\nFor each test case, you are given the DFT electronic energies $E_{\\text{DFT}}$ (in eV), zero-point energies $E_{\\text{ZPE}}$ (in eV), molar entropies $S$ (in J/mol/K), and the electrochemical state ($U$ in V, $\\mathrm{pH}$). Assume $S(\\mathrm{OH^*}) = 0$ J/mol/K for all cases. The temperature is $T = 298.15$ K for all cases.\n\n- Test Case 1 (happy path; equality check):\n  - $E_{\\text{DFT}}(\\text{slab}) = -100.000$ eV\n  - $E_{\\text{DFT}}(\\text{slab}+\\mathrm{OH^*}) = -101.180$ eV\n  - $E_{\\text{DFT}}(\\mathrm{H_2O}) = -0.560$ eV, $E_{\\text{ZPE}}(\\mathrm{H_2O}) = 0.560$ eV, $S(\\mathrm{H_2O}) = 69.95$ J/mol/K\n  - $E_{\\text{DFT}}(\\mathrm{H_2}) = -0.270$ eV, $E_{\\text{ZPE}}(\\mathrm{H_2}) = 0.270$ eV, $S(\\mathrm{H_2}) = 130.68$ J/mol/K\n  - $E_{\\text{ZPE}}(\\mathrm{OH^*}) = 0.360$ eV\n  - $U = 0.0$ V, $\\mathrm{pH} = 0.0$\n- Test Case 2 (boundary potential; acidic):\n  - $E_{\\text{DFT}}(\\text{slab}) = -220.000$ eV\n  - $E_{\\text{DFT}}(\\text{slab}+\\mathrm{OH^*}) = -221.050$ eV\n  - $E_{\\text{DFT}}(\\mathrm{H_2O}) = -0.600$ eV, $E_{\\text{ZPE}}(\\mathrm{H_2O}) = 0.560$ eV, $S(\\mathrm{H_2O}) = 69.95$ J/mol/K\n  - $E_{\\text{DFT}}(\\mathrm{H_2}) = -0.310$ eV, $E_{\\text{ZPE}}(\\mathrm{H_2}) = 0.270$ eV, $S(\\mathrm{H_2}) = 130.68$ J/mol/K\n  - $E_{\\text{ZPE}}(\\mathrm{OH^*}) = 0.360$ eV\n  - $U = 1.23$ V, $\\mathrm{pH} = 0.0$\n- Test Case 3 (alkaline; moderate potential):\n  - $E_{\\text{DFT}}(\\text{slab}) = -150.000$ eV\n  - $E_{\\text{DFT}}(\\text{slab}+\\mathrm{OH^*}) = -150.650$ eV\n  - $E_{\\text{DFT}}(\\mathrm{H_2O}) = -0.580$ eV, $E_{\\text{ZPE}}(\\mathrm{H_2O}) = 0.560$ eV, $S(\\mathrm{H_2O}) = 69.95$ J/mol/K\n  - $E_{\\text{DFT}}(\\mathrm{H_2}) = -0.280$ eV, $E_{\\text{ZPE}}(\\mathrm{H_2}) = 0.270$ eV, $S(\\mathrm{H_2}) = 130.68$ J/mol/K\n  - $E_{\\text{ZPE}}(\\mathrm{OH^*}) = 0.360$ eV\n  - $U = 0.50$ V, $\\mathrm{pH} = 13.0$\n- Test Case 4 (weak binding; negative potential; neutral pH):\n  - $E_{\\text{DFT}}(\\text{slab}) = -180.000$ eV\n  - $E_{\\text{DFT}}(\\text{slab}+\\mathrm{OH^*}) = -180.100$ eV\n  - $E_{\\text{DFT}}(\\mathrm{H_2O}) = -0.620$ eV, $E_{\\text{ZPE}}(\\mathrm{H_2O}) = 0.560$ eV, $S(\\mathrm{H_2O}) = 69.95$ J/mol/K\n  - $E_{\\text{DFT}}(\\mathrm{H_2}) = -0.290$ eV, $E_{\\text{ZPE}}(\\mathrm{H_2}) = 0.270$ eV, $S(\\mathrm{H_2}) = 130.68$ J/mol/K\n  - $E_{\\text{ZPE}}(\\mathrm{OH^*}) = 0.360$ eV\n  - $U = -0.10$ V, $\\mathrm{pH} = 7.0$\n\nTasks for each test case:\n- Compute $E_{\\text{ads}}^{\\mathrm{ref0}}$ in eV at $U = 0$ V and $\\mathrm{pH} = 0$ using stoichiometric free energies derived from the reaction $\\mathrm{H_2O(l)} + * \\rightarrow \\mathrm{OH^*} + \\mathrm{H^+} + \\mathrm{e^-}$ with the proton–electron pair eliminated by referencing to $\\mathrm{H_2}$ and $\\mathrm{H_2O}$.\n- Compute $E_{\\text{ads}}^{\\mathrm{CHE}}(U,\\mathrm{pH})$ in eV by incorporating the CHE dependence on $U$ and $\\mathrm{pH}$ via the finite-temperature chemical potentials.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, in order, for each test case: the two floats $[E_{\\text{ads}}^{\\mathrm{ref0}}, E_{\\text{ads}}^{\\mathrm{CHE}}]$ rounded to three decimal places, flattened into a single list across all cases. For example, the output should look like $[r_{1,\\mathrm{ref0}}, r_{1,\\mathrm{CHE}}, r_{2,\\mathrm{ref0}}, r_{2,\\mathrm{CHE}}, \\dots]$, where each $r$ is in eV.",
            "solution": "The computational protocol is constructed from first principles as follows.\n\n1. Free Energy of Individual Species\nThe Gibbs free energy $G$ of any species is given by its electronic energy $E_{\\text{elec}}$, zero-point vibrational energy $E_{\\text{ZPE}}$, and entropy $S$ at a given temperature $T$:\n$$ G = E_{\\text{elec}} + E_{\\text{ZPE}} - T S $$\nThe electronic energy $E_{\\text{elec}}$ is taken to be the energy from the Density Functional Theory (DFT) calculation, $E_{\\text{DFT}}$. All energies must be in electronvolts ($\\mathrm{eV}$) for consistency. The problem provides molar entropies $S$ in units of $\\mathrm{J/mol/K}$. The term $TS$ must be converted from $\\mathrm{J/mol}$ to $\\mathrm{eV}$. This conversion is performed by dividing by Avogadro's number $N_A$ to get energy per particle in Joules, and then by the elementary charge $e$ to get energy in $\\mathrm{eV}$:\n$$ T S \\ [\\mathrm{eV}] = \\frac{T S \\ [\\mathrm{J/mol}]}{N_A e} $$\nwhere $N_A e$ is the Faraday constant $F$.\n\nThe free energies of the reference molecules, water ($\\mathrm{H_2O}$) and hydrogen ($\\mathrm{H_2}$), are thus:\n$$ G(\\mathrm{H_2O}) = E_{\\text{DFT}}(\\mathrm{H_2O}) + E_{\\text{ZPE}}(\\mathrm{H_2O}) - \\frac{T S(\\mathrm{H_2O})}{N_A e} $$\n$$ G(\\mathrm{H_2}) = E_{\\text{DFT}}(\\mathrm{H_2}) + E_{\\text{ZPE}}(\\mathrm{H_2}) - \\frac{T S(\\mathrm{H_2})}{N_A e} $$\n\n2. Free Energy of the Adsorbed State\nThe free energy of the hydroxyl adsorbate on the surface, $\\mathrm{OH^*}$, is calculated relative to the bare surface, denoted by $*$. This relative free energy is the difference between the free energy of the slab with the adsorbate and the free energy of the bare slab:\n$$ G(\\mathrm{OH^*}) - G(*) = [G(\\text{slab}+\\mathrm{OH^*})] - [G(\\text{slab})] $$\n$$ G(\\mathrm{OH^*}) - G(*) = (E_{\\text{DFT}}(\\text{slab}+\\mathrm{OH^*}) - E_{\\text{DFT}}(\\text{slab})) + (E_{\\text{ZPE}}(\\text{slab}+\\mathrm{OH^*}) - E_{\\text{ZPE}}(\\text{slab})) - T(S(\\text{slab}+\\mathrm{OH^*}) - S(\\text{slab})) $$\nThe vibrational contribution is isolated to the adsorbate, so $E_{\\text{ZPE}}(\\text{slab}+\\mathrm{OH^*}) - E_{\\text{ZPE}}(\\text{slab}) = E_{\\text{ZPE}}(\\mathrm{OH^*})$. The problem specifies to neglect the entropy of the adsorbed hydroxyl, $S(\\mathrm{OH^*}) = 0 \\ \\mathrm{J/mol/K}$, which is a common approximation, simplifying the entropy term to zero. Thus, the relative free energy of the adsorbate is:\n$$ G(\\mathrm{OH^*}) - G(*) = (E_{\\text{DFT}}(\\text{slab}+\\mathrm{OH^*}) - E_{\\text{DFT}}(\\text{slab})) + E_{\\text{ZPE}}(\\mathrm{OH^*}) $$\n\n3. Adsorption Free Energy at Standard Conditions ($E_{\\text{ads}}^{\\mathrm{ref0}}$)\nThe adsorption reaction is:\n$$ \\mathrm{H_2O(l)} + * \\rightarrow \\mathrm{OH^*} + \\mathrm{H^+} + \\mathrm{e^-} $$\nThe free energy change for this reaction, $\\Delta G_{\\text{ads}}$, is the difference between the free energies of the products and reactants:\n$$ \\Delta G_{\\text{ads}} = (G(\\mathrm{OH^*}) - G(*)) + \\mu(\\mathrm{H^+}) + \\mu(\\mathrm{e^-}) - G(\\mathrm{H_2O}) $$\nwhere $\\mu$ denotes the chemical potential.\nThe Computational Hydrogen Electrode (CHE) model sets the chemical potential of the proton-electron pair, $\\mu(\\mathrm{H^+}) + \\mu(\\mathrm{e^-})$, in equilibrium with molecular hydrogen at a pressure of $p=1$ bar:\n$$ \\mathrm{H^+} + e^- \\rightleftharpoons \\frac{1}{2}\\mathrm{H_2(g)} $$\nAt standard conditions ($U=0 \\ \\mathrm{V}$ vs. RHE, $\\mathrm{pH}=0$), this equilibrium dictates that a proton-electron pair has the same chemical potential as half a hydrogen molecule:\n$$ \\mu(\\mathrm{H^+}) + \\mu(e^-) = \\frac{1}{2}G(\\mathrm{H_2}) $$\nSubstituting this into the expression for $\\Delta G_{\\text{ads}}$ gives the adsorption free energy at standard conditions, which the problem denotes as $E_{\\text{ads}}^{\\mathrm{ref0}}$:\n$$ E_{\\text{ads}}^{\\mathrm{ref0}} = \\Delta G_{\\text{ads}}(U=0, \\mathrm{pH}=0) = (G(\\mathrm{OH^*}) - G(*)) + \\frac{1}{2}G(\\mathrm{H_2}) - G(\\mathrm{H_2O}) $$\n\n4. Adsorption Free Energy at Finite Potential and Acidity ($E_{\\text{ads}}^{\\mathrm{CHE}}$)\nTo find the adsorption free energy at an arbitrary electrode potential $U$ and $\\mathrm{pH}$, we must adjust the chemical potential of the proton-electron pair. The chemical potential of an electron is shifted by $-eU$ relative to the standard hydrogen electrode. The chemical potential of a proton is shifted from its standard state (activity $a_{\\mathrm{H^+}}=1$) by a concentration-dependent term. The $\\mathrm{pH}$ is defined as $\\mathrm{pH} = -\\log_{10}(a_{\\mathrm{H^+}})$, which implies $\\ln(a_{\\mathrm{H^+}}) = -\\mathrm{pH}\\ln(10)$.\nThe total chemical potential of the pair becomes:\n$$ \\mu(\\mathrm{H^+}) + \\mu(e^-) = \\frac{1}{2}G(\\mathrm{H_2}) - eU + k_B T \\ln(a_{\\mathrm{H^+}}) $$\n$$ \\mu(\\mathrm{H^+}) + \\mu(e^-) = \\frac{1}{2}G(\\mathrm{H_2}) - eU - k_B T \\ln(10) \\times \\mathrm{pH} $$\nHere, the term $eU$ is in $\\mathrm{eV}$ if $U$ is in Volts, so for calculation, we can simply subtract the numerical value of $U$. The term $k_B T$ is the thermal energy in $\\mathrm{eV}$.\nSubstituting this adjusted chemical potential into the expression for $\\Delta G_{\\text{ads}}$ gives $E_{\\text{ads}}^{\\mathrm{CHE}}(U, \\mathrm{pH})$:\n$$ E_{\\text{ads}}^{\\mathrm{CHE}}(U, \\mathrm{pH}) = (G(\\mathrm{OH^*}) - G(*)) + \\left( \\frac{1}{2}G(\\mathrm{H_2}) - U - k_B T \\ln(10) \\times \\mathrm{pH} \\right) - G(\\mathrm{H_2O}) $$\nBy comparing with the expression for $E_{\\text{ads}}^{\\mathrm{ref0}}$, we arrive at the final relation:\n$$ E_{\\text{ads}}^{\\mathrm{CHE}}(U, \\mathrm{pH}) = E_{\\text{ads}}^{\\mathrm{ref0}} - U - k_B T \\ln(10) \\times \\mathrm{pH} $$\nThe program will implement these equations for each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the adsorption free energy of hydroxyl on a surface using DFT-level energies\n    and the Computational Hydrogen Electrode (CHE) framework.\n    \"\"\"\n\n    # Thermodynamic and physical constants\n    T = 298.15  # Temperature in Kelvin\n    KB = 8.617333262145e-5  # Boltzmann constant in eV/K\n    NA = 6.02214076e23  # Avogadro's number in mol^-1\n    E_CHARGE = 1.602176634e-19  # Elementary charge in C\n    LN_10 = np.log(10) # Natural logarithm of 10\n\n    # Faraday constant in C/mol, for unit conversion\n    FARADAY_CONSTANT = NA * E_CHARGE\n\n    # Test suite from the problem statement\n    test_cases = [\n        # Test Case 1\n        {\n            \"E_dft_slab\": -100.000, \"E_dft_slab_OH\": -101.180,\n            \"E_dft_h2o\": -0.560, \"E_zpe_h2o\": 0.560, \"S_h2o\": 69.95,\n            \"E_dft_h2\": -0.270, \"E_zpe_h2\": 0.270, \"S_h2\": 130.68,\n            \"E_zpe_oh\": 0.360, \"S_oh\": 0.0,\n            \"U\": 0.0, \"pH\": 0.0\n        },\n        # Test Case 2\n        {\n            \"E_dft_slab\": -220.000, \"E_dft_slab_OH\": -221.050,\n            \"E_dft_h2o\": -0.600, \"E_zpe_h2o\": 0.560, \"S_h2o\": 69.95,\n            \"E_dft_h2\": -0.310, \"E_zpe_h2\": 0.270, \"S_h2\": 130.68,\n            \"E_zpe_oh\": 0.360, \"S_oh\": 0.0,\n            \"U\": 1.23, \"pH\": 0.0\n        },\n        # Test Case 3\n        {\n            \"E_dft_slab\": -150.000, \"E_dft_slab_OH\": -150.650,\n            \"E_dft_h2o\": -0.580, \"E_zpe_h2o\": 0.560, \"S_h2o\": 69.95,\n            \"E_dft_h2\": -0.280, \"E_zpe_h2\": 0.270, \"S_h2\": 130.68,\n            \"E_zpe_oh\": 0.360, \"S_oh\": 0.0,\n            \"U\": 0.50, \"pH\": 13.0\n        },\n        # Test Case 4\n        {\n            \"E_dft_slab\": -180.000, \"E_dft_slab_OH\": -180.100,\n            \"E_dft_h2o\": -0.620, \"E_zpe_h2o\": 0.560, \"S_h2o\": 69.95,\n            \"E_dft_h2\": -0.290, \"E_zpe_h2\": 0.270, \"S_h2\": 130.68,\n            \"E_zpe_oh\": 0.360, \"S_oh\": 0.0,\n            \"U\": -0.10, \"pH\": 7.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Step 1: Compute free energies G = E_elec + E_ZPE - T*S\n        \n        # Free energy of H2O\n        ts_h2o_ev = (T * case[\"S_h2o\"]) / FARADAY_CONSTANT\n        g_h2o = case[\"E_dft_h2o\"] + case[\"E_zpe_h2o\"] - ts_h2o_ev\n        \n        # Free energy of H2\n        ts_h2_ev = (T * case[\"S_h2\"]) / FARADAY_CONSTANT\n        g_h2 = case[\"E_dft_h2\"] + case[\"E_zpe_h2\"] - ts_h2_ev\n        \n        # Step 2: Compute relative free energy of adsorbed OH*\n        # G(OH*) - G(*) = (E_DFT(slab+OH*) - E_DFT(slab)) + E_ZPE(OH*) - T*S(OH*)\n        # S(OH*) is assumed to be 0.\n        g_oh_rel = (case[\"E_dft_slab_OH\"] - case[\"E_dft_slab\"]) + case[\"E_zpe_oh\"]\n\n        # Step 3: Compute adsorption free energy at standard conditions (U=0, pH=0)\n        # E_ads^ref0 = (G(OH*) - G(*)) + 0.5*G(H2) - G(H2O)\n        e_ads_ref0 = g_oh_rel + 0.5 * g_h2 - g_h2o\n\n        # Step 4: Compute adsorption free energy at given U and pH using CHE\n        # E_ads^CHE = E_ads^ref0 - U - k_B*T*ln(10)*pH\n        ph_correction = KB * T * LN_10 * case[\"pH\"]\n        e_ads_che = e_ads_ref0 - case[\"U\"] - ph_correction\n        \n        # Step 5: Round results to three decimal places and append\n        results.append(round(e_ads_ref0, 3))\n        results.append(round(e_ads_che, 3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.3f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The final step in our practical journey is to move from quantitative prediction to qualitative chemical insight. While knowing the value of a binding energy is crucial, understanding its electronic origins is what enables true chemical intuition and design. This exercise introduces the Crystal Orbital Hamilton Population (COHP) analysis, a method for decomposing the total binding energy into stabilizing (bonding) and destabilizing (antibonding) contributions. By implementing a COHP workflow on a model Hamiltonian, you will learn how to dissect the calculated interaction energy and rationalize its magnitude in terms of familiar chemical bonding concepts .",
            "id": "4241821",
            "problem": "You are asked to design and implement a computational workflow for crystal orbital Hamilton population (COHP) analysis to decompose bonding and antibonding contributions to the adsorbate binding energy on a surface within the framework of Kohn–Sham density functional theory (DFT). Work in a minimal localized, orthogonal tight-binding basis that represents the Kohn–Sham Hamiltonian projected onto a set of atom-centered orbitals. Start from the following principles and definitions, and derive an algorithm that calculates the decomposition.\n\nFundamental base:\n- The Kohn–Sham effective single-particle Hamiltonian is represented in a localized basis as a matrix $H$ with elements $H_{ij}$.\n- In the orthogonal basis approximation (overlap matrix $S=I$), the band energy is $E_{\\text{band}}=\\sum_{n \\in \\text{occ}} \\epsilon_n$, where $\\epsilon_n$ are eigenvalues of $H$.\n- The density matrix is $P = \\sum_{n \\in \\text{occ}} \\mathbf{c}^{(n)} \\mathbf{c}^{(n)\\top}$, where $\\mathbf{c}^{(n)}$ is the normalized eigenvector of $H$ for eigenstate $n$.\n- The energy contribution associated with a pair of basis functions (or atoms) $i$ and $j$ in the orthogonal basis can be related to $P_{ij} H_{ij}$.\n- Crystal Orbital Hamilton Population (COHP) is defined energy-resolved for a pair $(i,j)$ by $-\\mathrm{COHP}_{ij}(E) = -\\sum_n c_i^{(n)} c_j^{(n)} H_{ij} \\, \\delta(E - \\epsilon_n)$, where $c_i^{(n)}$ is the $i$-th component of $\\mathbf{c}^{(n)}$. The sign convention is such that negative values of $-\\mathrm{COHP}$ indicate bonding contributions and positive values indicate antibonding contributions.\n- The integrated COHP up to the Fermi level $E_{\\mathrm{F}}$ is $\\mathrm{ICOHP}_{ij} = \\int_{-\\infty}^{E_{\\mathrm{F}}} \\left(-\\mathrm{COHP}_{ij}(E)\\right)\\, dE$. In a spin-degenerate, zero-temperature model the occupation is a step function and each occupied state contributes a factor of $g=2$.\n- In the orthogonal basis, the change in band energy due to bond formation between an adsorbate and a substrate can be approximated by the sum of integrated pairwise $-\\mathrm{COHP}$ terms over adsorbate–substrate pairs. The decomposition into bonding and antibonding contributions is performed by separating the negative and positive parts of $-\\mathrm{COHP}_{ij}(E)$ over the occupied spectrum.\n\nYour task:\n- Given a real symmetric Hamiltonian matrix $H$ (in electronvolts) representing a surface with an adsorbate, a Fermi level $E_{\\mathrm{F}}$ (in electronvolts), and a list of adsorbate–substrate pairs $(i,j)$ (zero-based indices into $H$) that define interfacial bonds, construct an algorithm to compute:\n  1. The bonding contribution $E_{\\text{bond}}$ in electronvolts defined as the sum over occupied eigenstates of the negative part of $-\\sum_{(i,j)} c_i^{(n)} c_j^{(n)} H_{ij}$ multiplied by the spin degeneracy $g=2$.\n  2. The antibonding contribution $E_{\\text{antibond}}$ in electronvolts defined as the sum over occupied eigenstates of the positive part of $-\\sum_{(i,j)} c_i^{(n)} c_j^{(n)} H_{ij}$ multiplied by $g=2$.\n  3. The net adsorbate binding energy surrogate $E_{\\text{ads}}$ in electronvolts approximated by $E_{\\text{bond}} + E_{\\text{antibond}}$.\n  4. The antibonding fraction $r$ expressed as a decimal defined by $r = \\frac{E_{\\text{antibond}}}{|E_{\\text{bond}}|}$ if $|E_{\\text{bond}}|0$, and $r=0$ otherwise.\n\nAssumptions and constraints:\n- Use zero temperature ($T=0$) and spin degeneracy $g=2$.\n- Treat the basis as orthogonal ($S=I$) and real symmetric $H$.\n- Occupation is a step function: a state with $\\epsilon_n \\le E_{\\mathrm{F}}$ is occupied, otherwise unoccupied.\n- All energies must be reported in electronvolts (eV).\n- The program must be self-contained and must not rely on any external files or inputs.\n\nTest suite:\nImplement your workflow on the following four test cases. Each case provides $H$, $E_{\\mathrm{F}}$, and the adsorbate–substrate pair list. The indices 0 and 1 denote two substrate sites, and index 2 denotes the adsorbate site.\n\n- Case 1 (general happy path, moderate coupling):\n  - $$H = \\begin{bmatrix}\n  0.0  -2.0  -1.0 \\\\\n  -2.0  0.0  -0.5 \\\\\n  -1.0  -0.5  -5.0\n  \\end{bmatrix}\\ \\text{eV},\\quad E_{\\mathrm{F}} = -0.5\\ \\text{eV},\\quad \\text{pairs} = [(2,0),(2,1)].$$\n- Case 2 (weak coupling edge case):\n  - $$H = \\begin{bmatrix}\n  0.0  -2.0  -0.1 \\\\\n  -2.0  0.0  -0.05 \\\\\n  -0.1  -0.05  -5.0\n  \\end{bmatrix}\\ \\text{eV},\\quad E_{\\mathrm{F}} = -0.5\\ \\text{eV},\\quad \\text{pairs} = [(2,0),(2,1)].$$\n- Case 3 (occupied antibonding due to high Fermi level):\n  - $$H = \\begin{bmatrix}\n  0.0  -2.0  -1.5 \\\\\n  -2.0  0.0  -1.0 \\\\\n  -1.5  -1.0  -5.0\n  \\end{bmatrix}\\ \\text{eV},\\quad E_{\\mathrm{F}} = 1.0\\ \\text{eV},\\quad \\text{pairs} = [(2,0),(2,1)].$$\n- Case 4 (no coupling boundary condition):\n  - $$H = \\begin{bmatrix}\n  0.0  -2.0  0.0 \\\\\n  -2.0  0.0  0.0 \\\\\n  0.0  0.0  -5.0\n  \\end{bmatrix}\\ \\text{eV},\\quad E_{\\mathrm{F}} = -0.5\\ \\text{eV},\\quad \\text{pairs} = [(2,0),(2,1)].$$\n\nRequired output:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets.\n- Each test case result must be a list of four floating-point numbers in electronvolts rounded to six decimal places, in the order $[E_{\\text{bond}}, E_{\\text{antibond}}, E_{\\text{ads}}, r]$.\n- The final output must be a single list containing the four case results, for example:\n  $$[[E_{\\text{bond}}^{(1)}, E_{\\text{antibond}}^{(1)}, E_{\\text{ads}}^{(1)}, r^{(1)}],[E_{\\text{bond}}^{(2)}, E_{\\text{antibond}}^{(2)}, E_{\\text{ads}}^{(2)}, r^{(2)}],[E_{\\text{bond}}^{(3)}, E_{\\text{antibond}}^{(3)}, E_{\\text{ads}}^{(3)}, r^{(3)}],[E_{\\text{bond}}^{(4)}, E_{\\text{antibond}}^{(4)}, E_{\\text{ads}}^{(4)}, r^{(4)}]].$$",
            "solution": "The problem statement is valid. It presents a scientifically grounded, well-posed, and objective task rooted in the principles of computational quantum chemistry. Specifically, it asks for the implementation of a Crystal Orbital Hamilton Population (COHP) analysis, a standard technique for dissecting chemical bonds, within a simplified orthogonal tight-binding framework derived from Density Functional Theory (DFT). All necessary data, definitions, and constraints are provided, allowing for the construction of a unique and verifiable algorithmic solution.\n\nThe objective is to decompose the interaction energy between an adsorbate and a substrate into stabilizing (bonding) and destabilizing (antibonding) contributions. This is accomplished by analyzing the eigenstates of a given Kohn-Sham Hamiltonian matrix, $H$, which represents the system.\n\nThe theoretical foundation is based on the representation of the single-particle Hamiltonian in a basis of localized atomic orbitals. In the specified orthogonal basis approximation, the overlap matrix is the identity matrix, $S = I$. The electronic structure of the system is described by the eigenvalues $\\epsilon_n$ and eigenvectors $\\mathbf{c}^{(n)}$ of the Hamiltonian matrix, which are solutions to the time-independent Schrödinger equation in matrix form:\n$$\nH\\mathbf{c}^{(n)} = \\epsilon_n \\mathbf{c}^{(n)}\n$$\nHere, $\\epsilon_n$ represents the energy of the $n$-th molecular orbital (or crystal orbital in a periodic system), and the eigenvector $\\mathbf{c}^{(n)}$ contains the coefficients $c_i^{(n)}$ that describe the contribution of the $i$-th atomic orbital to the $n$-th molecular orbital.\n\nThe core of COHP analysis is to partition the band energy, $E_{\\text{band}} = \\sum_{n \\in \\text{occ}} \\epsilon_n$, into pairwise orbital contributions. The energy contribution associated with the interaction between orbitals $i$ and $j$ is given by the population-weighted Hamiltonian matrix element, $P_{ij}H_{ij}$, where $P$ is the density matrix. For a single eigenstate $n$, this contribution is $c_i^{(n)} c_j^{(n)} H_{ij}$. The COHP is defined with a negative sign, $-\\mathrm{COHP}_{ij}(E)$, such that negative values (from $c_i^{(n)} c_j^{(n)} H_{ij} > 0$ for a typically negative off-diagonal $H_{ij}$) indicate bonding interactions, and positive values indicate antibonding interactions.\n\nThe problem asks for an integrated analysis up to the Fermi level, $E_{\\mathrm{F}}$, under the zero-temperature approximation ($T=0$). This means we consider only the occupied eigenstates, i.e., those with energy $\\epsilon_n \\le E_{\\mathrm{F}}$. The algorithm to compute the requested quantities—$E_{\\text{bond}}$, $E_{\\text{antibond}}$, $E_{\\text{ads}}$, and $r$—proceeds as follows.\n\n1.  **Diagonalization**: The first step is to solve the eigenvalue problem for the given real symmetric Hamiltonian matrix $H$. This yields a complete set of real eigenvalues $\\{\\epsilon_n\\}$ and a corresponding set of orthonormal eigenvectors $\\{\\mathbf{c}^{(n)}\\}$.\n\n2.  **State-Resolved Interaction Sum**: For each eigenstate $n$, we compute a quantity, let's call it $Y_n$, which represents the total contribution from all specified adsorbate-substrate interactions $(i,j)$ to the energy of that state. This is defined as the sum of the individual COHP-like terms over the given pairs:\n    $$\n    Y_n = -\\sum_{(i,j) \\in \\text{pairs}} c_i^{(n)} c_j^{(n)} H_{ij}\n    $$\n    Here, a negative value of $Y_n$ signifies a net bonding character for the state $n$ with respect to the adsorbate-substrate interface, while a positive value signifies a net antibonding character.\n\n3.  **Accumulation over Occupied States**: We initialize the total bonding energy, $E_{\\text{bond}}$, and antibonding energy, $E_{\\text{antibond}}$, to zero. We then iterate through each eigenstate $n$. If a state is occupied ($\\epsilon_n \\le E_{\\mathrm{F}}$), we analyze its contribution:\n    -   The bonding contribution is the sum of the negative parts of $Y_n$ over all occupied states.\n    -   The antibonding contribution is the sum of the positive parts of $Y_n$ over all occupied states.\n    The total energies are obtained by multiplying these sums by the spin degeneracy factor $g=2$.\n    The algorithm is as follows:\n    For each eigenstate $n=0, \\dots, N-1$:\n    If $\\epsilon_n \\le E_{\\mathrm{F}}$:\n        Calculate $Y_n = -\\sum_{(i,j) \\in \\text{pairs}} c_i^{(n)} c_j^{(n)} H_{ij}$.\n        If $Y_n  0$:\n            $E_{\\text{bond}} \\leftarrow E_{\\text{bond}} + g \\cdot Y_n$\n        If $Y_n > 0$:\n            $E_{\\text{antibond}} \\leftarrow E_{\\text{antibond}} + g \\cdot Y_n$\n\n4.  **Calculation of Final Metrics**: Upon completing the summation over all occupied states, the final quantities are calculated:\n    -   The net adsorbate binding energy surrogate, $E_{\\text{ads}}$, is the sum of the bonding and antibonding components:\n        $$\n        E_{\\text{ads}} = E_{\\text{bond}} + E_{\\text{antibond}}\n        $$\n    -   The antibonding fraction, $r$, which quantifies the relative importance of destabilizing interactions, is defined as:\n        $$\n        r = \\begin{cases} \\frac{E_{\\text{antibond}}}{|E_{\\text{bond}}|}  \\text{if } |E_{\\text{bond}}| > 0 \\\\ 0  \\text{if } |E_{\\text{bond}}| = 0 \\end{cases}\n        $$\n\nThis procedure provides a quantitative decomposition of the adsorbate-substrate interaction energy, offering insight into the nature of the chemical bonding at the interface.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the COHP analysis problem for a given set of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"H\": np.array([\n                [0.0, -2.0, -1.0],\n                [-2.0, 0.0, -0.5],\n                [-1.0, -0.5, -5.0]\n            ]),\n            \"E_F\": -0.5,\n            \"pairs\": [(2, 0), (2, 1)]\n        },\n        {\n            \"H\": np.array([\n                [0.0, -2.0, -0.1],\n                [-2.0, 0.0, -0.05],\n                [-0.1, -0.05, -5.0]\n            ]),\n            \"E_F\": -0.5,\n            \"pairs\": [(2, 0), (2, 1)]\n        },\n        {\n            \"H\": np.array([\n                [0.0, -2.0, -1.5],\n                [-2.0, 0.0, -1.0],\n                [-1.5, -1.0, -5.0]\n            ]),\n            \"E_F\": 1.0,\n            \"pairs\": [(2, 0), (2, 1)]\n        },\n        {\n            \"H\": np.array([\n                [0.0, -2.0, 0.0],\n                [-2.0, 0.0, 0.0],\n                [0.0, 0.0, -5.0]\n            ]),\n            \"E_F\": -0.5,\n            \"pairs\": [(2, 0), (2, 1)]\n        }\n    ]\n\n    all_results = []\n    g = 2.0  # Spin degeneracy factor\n\n    for case in test_cases:\n        H = case[\"H\"]\n        E_F = case[\"E_F\"]\n        pairs = case[\"pairs\"]\n\n        # Step 1: Diagonalize the Hamiltonian\n        # np.linalg.eigh is used for Hermitian (or real symmetric) matrices.\n        # It returns eigenvalues in ascending order and corresponding normalized eigenvectors.\n        eigenvalues, eigenvectors = np.linalg.eigh(H)\n        \n        # Initialize accumulators\n        E_bond = 0.0\n        E_antibond = 0.0\n        \n        # Step 2  3: Iterate over eigenstates, check occupation, and accumulate contributions\n        num_states = H.shape[0]\n        for n in range(num_states):\n            epsilon_n = eigenvalues[n]\n            \n            # Check if the state is occupied\n            if epsilon_n = E_F:\n                c_n = eigenvectors[:, n] # nth eigenvector as a column\n                \n                # Calculate the state-resolved interaction sum Y_n\n                Y_n = 0.0\n                for i, j in pairs:\n                    # H is symmetric, so H_ij = H_ji\n                    Y_n -= c_n[i] * c_n[j] * H[i, j]\n                \n                # Decompose into bonding and antibonding contributions\n                if Y_n  0:\n                    E_bond += g * Y_n\n                elif Y_n > 0:\n                    E_antibond += g * Y_n\n        \n        # Step 4: Final calculations\n        E_ads = E_bond + E_antibond\n        \n        if abs(E_bond) > 1e-9: # Use a small tolerance for floating point comparison\n            r = E_antibond / abs(E_bond)\n        else:\n            r = 0.0\n            \n        result_tuple = [\n            round(E_bond, 6), \n            round(E_antibond, 6), \n            round(E_ads, 6), \n            round(r, 6)\n        ]\n        all_results.append(result_tuple)\n\n    # Format the final output string as specified\n    case_strings = []\n    for res in all_results:\n        # Format each number to 6 decimal places and join with commas\n        formatted_res = f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f},{res[3]:.6f}]\"\n        case_strings.append(formatted_res)\n    \n    # Join the individual case strings and enclose in brackets\n    final_output_string = f\"[{','.join(case_strings)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}