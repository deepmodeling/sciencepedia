{
    "hands_on_practices": [
        {
            "introduction": "DFT+U方法的核心在于修正标准DFT泛函对电子过度离域化的倾向，特别是对d轨道或f轨道电子。这一修正通过引入一个能量惩罚项来实现，该惩罚项抑制了分数的轨道占据数。本练习将通过解析推导，让您亲身体验在Dudarev方案下，轨道占据数的微小变化如何影响总能量，从而揭示DFT+U方法促使轨道占据数趋向整数的内在能量驱动力。",
            "id": "4242187",
            "problem": "考虑一种用于计算电化学的过渡金属氧化物正极材料，其中，金属 $d$ 轨道上的强局域电子关联效应通过密度泛函理论加哈伯德 $U$ (DFT+U) 方法处理。在 Dudarev 的 $U_{\\mathrm{eff}} = U - J$ 方法的旋转不变形式中，修正能量惩罚了关联子空间占据矩阵对幂等性（即特征值等于 $0$ 或 $1$）的偏离。假设在电化学条件下，由于电子化学势的微小变化，某个自旋分辨的关联轨道的占据数 $n_{0} \\in [0,1]$ 受到一个小的扰动 $\\delta n$。从 Dudarev 修正能量是占据矩阵特征值的旋转不变泛函且在能量上不利于分数占据数这一公认原理出发，在 Dudarev 的 $U_{\\mathrm{eff}}$ 方法下，推导出与此单个特征值相关的总能量变化 $\\delta E$，保留至 $\\delta n$ 的二阶项。你的推导应利用幂等占据矩阵使修正能量最小化，以及旋转不变形式仅依赖于关联子空间占据矩阵的特征值这些性质。\n\n请以包含 $U_{\\mathrm{eff}}$、$n_{0}$ 和 $\\delta n$ 的单一闭合形式解析表达式给出 $\\delta E$ 的最终答案，保留至并包含 $(\\delta n)^{2}$ 阶的项。通过以电子伏特为单位的 $U_{\\mathrm{eff}}$，将能量变化表示为电子伏特。最终的方框表达式内不要包含单位。不需要进行数值取整。最后，简要解释你结果的符号和曲率，以说明在该方法中能量上对整数占据数的偏好。",
            "solution": "题目要求在 Dudarev DFT+U 方法的框架内，计算单个关联轨道的能量变化 $\\delta E$，其占据数从 $n_0$ 变为 $n_0 + \\delta n$。能量变化需要推导至扰动 $\\delta n$ 的二阶。\n\n出发点是 Dudarev 修正能量泛函，它被加到标准的密度泛函理论 (DFT) 总能量上。对于给定的自旋通道 $\\sigma$，该泛函是旋转不变的，并且可以用关联子空间的局域占据矩阵的特征值 $n_i^{\\sigma}$ 来表示。该泛函具有以下形式：\n$$E_{U} = \\frac{U_{\\mathrm{eff}}}{2} \\sum_{\\sigma, i} \\left( n_i^{\\sigma} - (n_i^{\\sigma})^2 \\right)$$\n其中 $U_{\\mathrm{eff}}$ 是有效的在位库仑和交换参数，求和遍及所选原子子空间内的所有自旋通道 $\\sigma$ 和所有关联轨道 $i$。\n\n题目要求我们分析与单个自旋分辨轨道相关的能量变化。因此，我们可以分离出这个单轨道（或等效地，占据矩阵的单个特征值）对总修正能量的贡献。设该轨道的占据数为 $n$。它对 $E_U$ 的贡献为：\n$$E(n) = \\frac{U_{\\mathrm{eff}}}{2} (n - n^2)$$\n这个函数描述了一个开口向下的抛物线，其根在 $n=0$ 和 $n=1$ 处，最大值在 $n=1/2$ 处。当占据数 $n$ 为整数（$0$ 或 $1$）时，能量修正最小（等于 $0$）；当轨道半满（$n=0.5$）时，能量修正最大。这种泛函形式明确地惩罚了分数占据，这也是 DFT 中哈伯德 $U$ 修正的核心目的。\n\n给定初始占据数 $n_0$ 和一个小的扰动 $\\delta n$。新的占据数是 $n = n_0 + \\delta n$。修正能量的变化 $\\delta E$ 是最终态能量与初始态能量之差：\n$$\\delta E = E(n_0 + \\delta n) - E(n_0)$$\n代入 $E(n)$ 的表达式：\n$$\\delta E = \\frac{U_{\\mathrm{eff}}}{2} \\left[ (n_0 + \\delta n) - (n_0 + \\delta n)^2 \\right] - \\frac{U_{\\mathrm{eff}}}{2} \\left[ n_0 - n_0^2 \\right]$$\n为了得到关于 $\\delta n$ 的二阶表达式，我们展开 $(n_0 + \\delta n)^2$ 项：\n$$(n_0 + \\delta n)^2 = n_0^2 + 2n_0 \\delta n + (\\delta n)^2$$\n将此代回 $\\delta E$ 的表达式中：\n$$\\delta E = \\frac{U_{\\mathrm{eff}}}{2} \\left[ n_0 + \\delta n - (n_0^2 + 2n_0 \\delta n + (\\delta n)^2) - n_0 + n_0^2 \\right]$$\n现在，我们通过消去项来简化：\n$$\\delta E = \\frac{U_{\\mathrm{eff}}}{2} \\left[ (n_0 - n_0) + (\\delta n - 2n_0 \\delta n) - (n_0^2 - n_0^2) - (\\delta n)^2 \\right]$$\n$$\\delta E = \\frac{U_{\\mathrm{eff}}}{2} \\left[ (1 - 2n_0) \\delta n - (\\delta n)^2 \\right]$$\n此表达式是精确的，并按要求包含了 $\\delta n$ 的二阶项。\n\n为解释这一结果，我们分析其组成部分。能量变化 $\\delta E$ 可以通过考察其对占据数变化 $\\delta n$ 的一阶和二阶依赖关系来理解。\n\n一阶项是 $\\frac{U_{\\mathrm{eff}}}{2}(1 - 2n_0)\\delta n$。这是能量泛函 $E(n)$ 在 $n_0$ 处的一阶导数乘以 $\\delta n$。\n- 如果轨道填充不足一半 ($0 \\le n_0  1/2$)，则 $(1 - 2n_0)$ 项为正。因此，任何占据数的增加 ($\\delta n > 0$) 都会导致能量惩罚 ($\\delta E > 0$)，而减少 ($\\delta n  0$) 则会带来能量增益 ($\\delta E  0$)。这提供了一个能量上的“力”，驱使占据数趋向于 $0$。\n- 如果轨道填充超过一半 ($1/2  n_0 \\le 1$)，则 $(1 - 2n_0)$ 项为负。在这种情况下，占据数的增加 ($\\delta n > 0$) 会带来能量增益 ($\\delta E  0$)，而减少 ($\\delta n  0$) 则会导致能量惩罚 ($\\delta E > 0$)。这会驱使占据数趋向于 $1$。\n- 在恰好半填充时 ($n_0=1/2$)，该项消失，这对应于能量泛函 $E(n)$ 的极值点（最大值点）。\n\n二阶项是 $-\\frac{U_{\\mathrm{eff}}}{2}(\\delta n)^2$。该项与能量泛函的曲率有关。$E(n)$ 的二阶导数是：\n$$\\frac{d^2E}{dn^2} = \\frac{d}{dn} \\left[ \\frac{U_{\\mathrm{eff}}}{2}(1 - 2n) \\right] = -U_{\\mathrm{eff}}$$\n由于 $U_{\\mathrm{eff}}$ 是一个正定参数，曲率总是负的。这种负曲率是 Dudarev 泛函对分数占据进行惩罚的决定性特征。它使能量景观相对于占据数是向下凹的，从而确保整数占据 $n=0$ 和 $n=1$ 是修正能量的局部最小值。因此，对于任何非零的 $\\delta n$，二阶项 $-\\frac{U_{\\mathrm{eff}}}{2}(\\delta n)^2$ 总是负的，反映了这种凹性。来自 $E_U$ 的这种负曲率抵消了标准 DFT 过度离域化电子的趋势，并且可以在总能量景观中导致形成具有类整数占据的多个稳定态，这对于描述强关联材料中的氧化还原过程和极化子态至关重要。",
            "answer": "$$\\boxed{\\frac{U_{\\mathrm{eff}}}{2} \\left( (1 - 2n_0) \\delta n - (\\delta n)^2 \\right)}$$"
        },
        {
            "introduction": "在理解了DFT+U的理论核心之后，任何实际计算的首要步骤都是确保结果的数值收敛性。本练习模拟了DFT+U计算中至关重要的收敛性测试过程，特别是针对平面波截断能和k点采样的收敛性。您将利用一个基于物理原理的代理模型，系统性地寻找在满足能量和力收敛标准下计算效率最高的参数设置，这是所有第一性原理计算的标准操作。",
            "id": "4242214",
            "problem": "要求您设计并实现一个程序，用于评估密度泛函理论加哈伯德 $U$ (DFT+$U$) 计算中，针对一种模型关联氧化物，总能量和力关于平面波截断能和布里渊区采样密度（以 $k$ 点网格表示）的收敛性。您的程序必须为总能量和力中的离散化误差使用一个有科学依据的代理模型，并且必须根据明确定义的标准提出可靠的设置。其目标是编码计算化学家在不调用任何外部模拟引擎的情况下，为确保平面波 DFT+$U$ 计算中总能量和力的可靠性所遵循的逻辑。\n\n请基于以下基本原理和广泛接受的标度律事实进行推导：\n- 总能量的平面波基组不完备性误差会随着平面波动能截断值（记为 $E_{\\mathrm{cut}}$）的增加而按幂律衰减。这是因为波函数和电荷密度的傅里叶表示，相对于所包含的最大平面波矢量的收敛是代数式的。用一个指数 $p$ 和一个依赖于 $U$ 的前置因子 $a(U)$ 来表示此项，即能量误差贡献为 $\\propto a(U)\\,E_{\\mathrm{cut}}^{-p}$。\n- 布里渊区积分（有限 $k$ 点采样）误差会随着 $k$ 点总数（记为 $N_k$）的增加而按幂律衰减，其指数 $q(U)$ 依赖于电子结构。对于金属性体系（小带隙或无带隙），$q(U)$ 小于绝缘性体系（有限带隙），因为在后者中被积函数更平滑。将此贡献表示为 $\\propto b(U)\\,N_k^{-q(U)}$。\n- DFT+$U$ 中的哈伯德修正会改变在位电子相互作用，通常在关联氧化物中打开一个随 $U$ 增大的能隙。这会改变布里渊区被积函数的平滑度，从而改变 $k$ 点收敛的有效指数 $q(U)$。它还会改变前置因子 $a(U)$ 和 $b(U)$，因为波函数的特性以及对基组和采样的敏感度会随着能隙的变化而改变。\n- 力的误差遵循类似的趋势，其基组（类 Pulay）贡献和布里渊区采样贡献也随 $E_{\\mathrm{cut}}$ 和 $N_k$ 按幂律衰减，但其指数和前置因子可能与总能量的不同。\n\n为创建一个通用、可测试的程序，请采用以下编码了上述原理的代理误差模型：\n- 定义一个随 $U$ 增加的有效带隙 $E_{\\mathrm{g}}(U)$，它在一个对关联氧化物而言物理上现实的上限处饱和：\n$$\nE_{\\mathrm{g}}(U)=\\min\\left(0.5\\,U,\\ 3.0\\right)\\ \\text{(in eV)}.\n$$\n- 使用以下能量和力误差的幂律指数：\n$$\np=2.1,\\quad q(U)=1.1+0.9\\,\\tanh\\!\\left(\\frac{E_{\\mathrm{g}}(U)}{1.5}\\right),\\quad r=1.2,\\quad s(U)=0.9+0.8\\,\\tanh\\!\\left(\\frac{E_{\\mathrm{g}}(U)}{1.5}\\right).\n$$\n- 使用随能隙增大而减小的、依赖于 $U$ 的前置因子：\n$$\na(U)=\\frac{100.0}{1.0+E_{\\mathrm{g}}(U)},\\quad b(U)=\\frac{5.0}{1.0+E_{\\mathrm{g}}(U)},\\quad f_a(U)=\\frac{20.0}{1.0+E_{\\mathrm{g}}(U)},\\quad f_b(U)=\\frac{2.0}{1.0+E_{\\mathrm{g}}(U)}.\n$$\n- 将代理总能量 $E_{\\mathrm{model}}(U,E_{\\mathrm{cut}},N_k)$ 建模为一个真实但未知的基线 $E_{\\mathrm{true}}(U)$ 加上来自基组不完备性和 $k$ 点采样的离散化误差，并包含一个弱的交叉项来模拟耦合误差：\n$$\nE_{\\mathrm{model}}(U,E_{\\mathrm{cut}},N_k)=E_{\\mathrm{true}}(U)+a(U)\\,E_{\\mathrm{cut}}^{-p}+b(U)\\,N_k^{-q(U)}+\\frac{1}{2}\\sqrt{a(U)\\,b(U)}\\,E_{\\mathrm{cut}}^{-p/2}\\,N_k^{-q(U)/2}.\n$$\n- 将平衡构型下（此时物理力为零，仅剩下数值误差）的代理力的大小 $F_{\\mathrm{model}}(U,E_{\\mathrm{cut}},N_k)$ 建模为：\n$$\nF_{\\mathrm{model}}(U,E_{\\mathrm{cut}},N_k)=f_a(U)\\,E_{\\mathrm{cut}}^{-r}+f_b(U)\\,N_k^{-s(U)}+0.3\\,\\sqrt{f_a(U)\\,f_b(U)}\\,E_{\\mathrm{cut}}^{-r/2}\\,N_k^{-s(U)/2}.\n$$\n- 为了在不同设置间进行数值比较，您可以将基线设置为一个简单的 $U$ 的线性形式 $E_{\\mathrm{true}}(U)=-100.0+0.1\\,U$（单位 eV），请注意，在通过与一个共同的高精度参考值进行差分来评估收敛性时，实际值会相互抵消。\n\n使用标准计算实践定义可靠性标准：\n- 对于一个候选设置 $\\left(E_{\\mathrm{cut}},\\mathbf{k}\\right)$，其中 $\\mathbf{k}=(n_x,n_y,n_z)$ 且 $N_k=n_x n_y n_z$，使用测试用例中可用的最大 $E_{\\mathrm{cut}}$ 和最密的 $k$ 网格（最大的 $N_k$）来计算参考能量 $E_{\\mathrm{ref}}$。如果一个候选设置满足\n$$\n\\left|E_{\\mathrm{model}}(U,E_{\\mathrm{cut}},N_k)-E_{\\mathrm{ref}}\\right|\\le \\varepsilon_E,\n$$\n则它是能量收敛的，其中 $\\varepsilon_E$ 是指定的能量容差（单位 eV）。\n- 如果一个候选设置满足\n$$\nF_{\\mathrm{model}}(U,E_{\\mathrm{cut}},N_k)\\le \\varepsilon_F,\n$$\n则它是力收敛的，其中 $\\varepsilon_F$ 是指定的力容差（单位 eV/\\AA）。\n- 如果一个候选设置同时满足能量收敛和力收敛，则它是可靠的。在所有可靠的候选设置中，选择使计算成本的简单代理最小化的那一个，该成本与基组大小和 $k$ 点数量的乘积成正比：\n$$\nC(E_{\\mathrm{cut}},N_k)=E_{\\mathrm{cut}}^{1.5}\\,N_k.\n$$\n如果没有候选设置满足这两个标准，则报告未达到收敛，并报告在所提供的设置中观测到的与参考值的最小能量差和最小力的大小。\n\n物理单位：\n- 平面波截断能 $E_{\\mathrm{cut}}$ 必须以 eV 为单位指定。\n- 能量差必须以 eV 为单位。\n- 力的大小必须以 eV/\\AA 为单位。\n\n本问题不使用角度单位。\n\n您的程序必须实现该代理模型，为每个测试用例评估所有候选设置，应用可靠性标准，在可能的情况下选择推荐的设置，并按如下规定将结果汇总为单行。\n\n测试套件：\n请严格实现以下四个测试用例。在每个案例中，$U$ 的单位是 eV，$E_{\\mathrm{cut}}$ 值的单位是 eV，$k$ 网格是整数三元组 $(n_x,n_y,n_z)$，总点数 $N_k=n_x n_y n_z$，容差以 $(\\varepsilon_E,\\varepsilon_F)$ 的形式给出，单位为 $(\\text{eV},\\ \\text{eV}/\\AA)$。\n- 案例 1：$U=4.0$；$E_{\\mathrm{cut}}\\in\\{350.0,400.0,450.0,500.0,600.0\\}$；$k$ 网格 $\\{(4,4,4),(6,6,6),(8,8,8)\\}$；容差 $(\\varepsilon_E,\\varepsilon_F)=(0.001,0.005)$。\n- 案例 2：$U=0.0$；$E_{\\mathrm{cut}}\\in\\{350.0,400.0,500.0,600.0\\}$；$k$ 网格 $\\{(2,2,2),(4,4,4),(6,6,6)\\}$；容差 $(\\varepsilon_E,\\varepsilon_F)=(0.001,0.005)$。\n- 案例 3：$U=6.0$；$E_{\\mathrm{cut}}\\in\\{300.0,350.0,400.0\\}$；$k$ 网格 $\\{(3,3,3),(4,4,4)\\}$；容差 $(\\varepsilon_E,\\varepsilon_F)=(0.001,0.005)$。\n- 案例 4：$U=3.0$；$E_{\\mathrm{cut}}\\in\\{300.0,320.0,340.0\\}$；$k$ 网格 $\\{(2,2,2)\\}$；容差 $(\\varepsilon_E,\\varepsilon_F)=(0.0005,0.002)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个测试用例的结果，形式为一个由方括号括起来的、逗号分隔的列表的列表。每个内部列表必须按以下顺序包含五个条目：\n$[\\text{converged},E_{\\mathrm{cut}}^{\\star},N_k^{\\star},\\Delta E^{\\star},F^{\\star}]$，其中：\n- 如果找到了可靠的设置，$\\text{converged}$ 为 $1$，否则为 $0$。\n- $E_{\\mathrm{cut}}^{\\star}$ 是推荐的平面波截断能（单位 eV），如果未收敛则为 $-1$。\n- $N_k^{\\star}$ 是推荐的 $k$ 点总数，如果未收敛则为 $-1$。\n- $\\Delta E^{\\star}$ 是在推荐设置下与参考值的绝对能量差（如果未收敛，则为观测到的最小差值），单位 eV，四舍五入到六位小数。\n- $F^{\\star}$ 是在推荐设置下的力的大小（如果未收敛，则为观测到的最小力的大小），单位 eV/\\AA，四舍五入到六位小数。\n\n整个输出必须是精确的一行，类似于：\n$[[\\dots],[\\dots],[\\dots],[\\dots]]$\n不含任何额外的字符或空格。",
            "solution": "该问题要求设计并实现一个程序，用于根据一个给定的数值误差代理模型，确定密度泛函理论加哈伯德 $U$ (DFT+$U$) 计算的最佳计算设置。此任务模拟了计算材料科学中标准的收敛性测试工作流程。解决方案的结构是首先实现代理模型的数学函数，然后创建一个算法，根据指定的可靠性和成本标准系统地评估候选设置。\n\n问题的核心在于所提供的总能量 $E_{\\mathrm{model}}$ 和原子力的模 $F_{\\mathrm{model}}$ 的代理模型，它们是哈伯德参数 $U$、平面波动能截断值 $E_{\\mathrm{cut}}$ 和布里渊区采样点总数 $N_k$ 的函数。\n\n首先，我们将代理模型的各个组成部分形式化。该模型的行为主要由一个有效的电子带隙 $E_{\\mathrm{g}}(U)$ 控制，它依赖于哈伯德 $U$ 参数。这是一个关键的物理特征，因为带隙的存在与否及其大小会显著影响数值收敛性。有效带隙由下式给出：\n$$\nE_{\\mathrm{g}}(U) = \\min(0.5 \\cdot U, 3.0)\n$$\n其中 $U$ 的单位是 eV。这个函数模拟了随着 $U$ 的增加带隙的打开，并在一个对关联氧化物而言实际的值 $3.0\\,\\text{eV}$ 处饱和。\n\n能量和力相对于 $E_{\\mathrm{cut}}$ 和 $N_k$ 的收敛性由幂律描述。这些幂律的指数要么是常数，要么依赖于带隙 $E_{\\mathrm{g}}(U)$。这些指数是：\n- $p = 2.1$ (能量误差 vs. $E_{\\mathrm{cut}}$)\n- $q(U) = 1.1 + 0.9 \\cdot \\tanh\\left(\\frac{E_{\\mathrm{g}}(U)}{1.5}\\right)$ (能量误差 vs. $N_k$)\n- $r = 1.2$ (力误差 vs. $E_{\\mathrm{cut}}$)\n- $s(U) = 0.9 + 0.8 \\cdot \\tanh\\left(\\frac{E_{\\mathrm{g}}(U)}{1.5}\\right)$ (力误差 vs. $N_k$)\n\n双曲正切函数 $\\tanh$ 为指数 $q$ 和 $s$ 提供了一个平滑的过渡，因为体系从金属性（$E_{\\mathrm{g}} \\approx 0$）变为绝缘性（$E_{\\mathrm{g}} > 0$）。\n\n这些幂律的前置因子也依赖于带隙，这模拟了有带隙的体系通常对离散化误差不太敏感这一事实：\n- $a(U) = \\frac{100.0}{1.0 + E_{\\mathrm{g}}(U)}$ (能量 vs. $E_{\\mathrm{cut}}$ 前置因子)\n- $b(U) = \\frac{5.0}{1.0 + E_{\\mathrm{g}}(U)}$ (能量 vs. $N_k$ 前置因子)\n- $f_a(U) = \\frac{20.0}{1.0 + E_{\\mathrm{g}}(U)}$ (力 vs. $E_{\\mathrm{cut}}$ 前置因子)\n- $f_b(U) = \\frac{2.0}{1.0 + E_{\\mathrm{g}}(U)}$ (力 vs. $N_k$ 前置因子)\n\n总的模型能量 $E_{\\mathrm{model}}$ 和力的模 $F_{\\mathrm{model}}$ 是这些误差贡献的总和，包括一个弱交叉项以考虑非可加效应：\n$$\nE_{\\mathrm{model}}(U, E_{\\mathrm{cut}}, N_k) = E_{\\mathrm{true}}(U) + a(U)E_{\\mathrm{cut}}^{-p} + b(U)N_k^{-q(U)} + \\frac{1}{2}\\sqrt{a(U)b(U)} E_{\\mathrm{cut}}^{-p/2} N_k^{-q(U)/2}\n$$\n$$\nF_{\\mathrm{model}}(U, E_{\\mathrm{cut}}, N_k) = f_a(U)E_{\\mathrm{cut}}^{-r} + f_b(U)N_k^{-s(U)} + 0.3\\sqrt{f_a(U)f_b(U)} E_{\\mathrm{cut}}^{-r/2} N_k^{-s(U)/2}\n$$\n基线能量给出为 $E_{\\mathrm{true}}(U) = -100.0 + 0.1 \\cdot U$。\n\n每个测试用例的算法流程如下：\n1.  **初始化**：对于一个给定的测试用例，包含参数 $U$、$E_{\\mathrm{cut}}$ 值列表和 $k$ 网格列表，以及容差 $(\\varepsilon_E, \\varepsilon_F)$，首先计算依赖于 $U$ 的模型参数：$E_{\\mathrm{g}}(U)$、$q(U)$、$s(U)$ 和所有前置因子。对每个网格，计算 $k$ 点总数 $N_k = n_x n_y n_z$。\n\n2.  **参考计算**：计算一个高精度的参考能量 $E_{\\mathrm{ref}}$。这是通过使用测试用例中提供的最大 $E_{\\mathrm{cut}}$ 值和最大 $N_k$ 值来评估 $E_{\\mathrm{model}}$ 完成的。这模仿了使用计算成本最高的设置作为基准的实际方法。\n\n3.  **候选设置评估**：算法会遍历所提供集合中所有可能的 $(E_{\\mathrm{cut}}, N_k)$ 对。对于每个候选设置：\n    a. 计算 $E_{\\mathrm{model}}$ 和 $F_{\\mathrm{model}}$。\n    b. 计算与参考值的绝对能量差：$\\Delta E = |E_{\\mathrm{model}} - E_{\\mathrm{ref}}|$。\n    c. 通过与容差比较来检查设置是否可靠：\n       - 能量收敛：$\\Delta E \\le \\varepsilon_E$。\n       - 力收敛：$F_{\\mathrm{model}} \\le \\varepsilon_F$。\n    d. 如果一个设置是可靠的（满足两个标准），它将被添加到一个可靠候选者列表中。\n    e. 在此过程中，会单独跟踪所有候选设置中观测到的最小 $\\Delta E$ 和最小 $F_{\\mathrm{model}}$。如果没有找到可靠的设置，将使用这些值。\n\n4.  **最优设置选择**：\n    a. 如果可靠候选者列表不为空，算法将继续寻找计算效率最高的一个。计算成本 $C$ 估计为 $C(E_{\\mathrm{cut}}, N_k) = E_{\\mathrm{cut}}^{1.5} \\cdot N_k$。成本最低的可靠候选者被选为推荐设置 $(E_{\\mathrm{cut}}^{\\star}, N_k^{\\star})$。结果被标记为收敛（标志 $1$）。\n    b. 如果可靠候选者列表为空，则该案例被标记为未收敛（标志 $0$），推荐设置被设为占位符值，$E_{\\mathrm{cut}}^{\\star} = -1.0$ 和 $N_k^{\\star} = -1$。\n\n5.  **输出格式化**：该测试用例的最终结果被组合成一个包含五个值的列表：$[\\text{converged}, E_{\\mathrm{cut}}^{\\star}, N_k^{\\star}, \\Delta E^{\\star}, F^{\\star}]$。\n    - 对于收敛的案例，$\\Delta E^{\\star}$ 和 $F^{\\star}$ 是推荐设置下的能量差和力的大小。\n    - 对于未收敛的案例，$\\Delta E^{\\star}$ 和 $F^{\\star}$ 分别是观测到的最小能量差和最小力的大小。\n    - 所有能量和力的值都按要求四舍五入到六位小数。对所有测试用例重复此过程，并将最终结果汇总到单行输出中。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Evaluates DFT+U convergence for model correlated oxides using a surrogate model.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"U\": 4.0,\n            \"E_cut_values\": [350.0, 400.0, 450.0, 500.0, 600.0],\n            \"k_meshes\": [(4, 4, 4), (6, 6, 6), (8, 8, 8)],\n            \"tolerances\": (0.001, 0.005)\n        },\n        {\n            \"U\": 0.0,\n            \"E_cut_values\": [350.0, 400.0, 500.0, 600.0],\n            \"k_meshes\": [(2, 2, 2), (4, 4, 4), (6, 6, 6)],\n            \"tolerances\": (0.001, 0.005)\n        },\n        {\n            \"U\": 6.0,\n            \"E_cut_values\": [300.0, 350.0, 400.0],\n            \"k_meshes\": [(3, 3, 3), (4, 4, 4)],\n            \"tolerances\": (0.001, 0.005)\n        },\n        {\n            \"U\": 3.0,\n            \"E_cut_values\": [300.0, 320.0, 340.0],\n            \"k_meshes\": [(2, 2, 2)],\n            \"tolerances\": (0.0005, 0.002)\n        }\n    ]\n\n    all_results = []\n    \n    # Static exponents\n    p = 2.1\n    r = 1.2\n\n    for case in test_cases:\n        U = case[\"U\"]\n        E_cut_values = case[\"E_cut_values\"]\n        k_meshes = case[\"k_meshes\"]\n        epsilon_E, epsilon_F = case[\"tolerances\"]\n\n        # Calculate U-dependent parameters\n        E_g = min(0.5 * U, 3.0)\n        tanh_term = np.tanh(E_g / 1.5)\n        \n        q = 1.1 + 0.9 * tanh_term\n        s = 0.9 + 0.8 * tanh_term\n        \n        a = 100.0 / (1.0 + E_g)\n        b = 5.0 / (1.0 + E_g)\n        f_a = 20.0 / (1.0 + E_g)\n        f_b = 2.0 / (1.0 + E_g)\n        \n        E_true = -100.0 + 0.1 * U\n\n        def get_E_model(E_cut, Nk):\n            term1 = a * (E_cut ** -p)\n            term2 = b * (Nk ** -q)\n            cross_term = 0.5 * np.sqrt(a * b) * (E_cut ** (-p / 2.0)) * (Nk ** (-q / 2.0))\n            return E_true + term1 + term2 + cross_term\n\n        def get_F_model(E_cut, Nk):\n            term1 = f_a * (E_cut ** -r)\n            term2 = f_b * (Nk ** -s)\n            cross_term = 0.3 * np.sqrt(f_a * f_b) * (E_cut ** (-r / 2.0)) * (Nk ** (-s / 2.0))\n            return term1 + term2 + cross_term\n\n        def get_cost(E_cut, Nk):\n            return (E_cut ** 1.5) * Nk\n\n        Nk_values = [k[0] * k[1] * k[2] for k in k_meshes]\n        candidates = [(ecut, nk) for ecut in E_cut_values for nk in Nk_values]\n        \n        # Reference calculation\n        E_cut_ref = max(E_cut_values)\n        Nk_ref = max(Nk_values)\n        E_ref = get_E_model(E_cut_ref, Nk_ref)\n        \n        reliable_candidates = []\n        min_delta_E = float('inf')\n        min_F = float('inf')\n        \n        for ecut, nk in candidates:\n            E_model_val = get_E_model(ecut, nk)\n            F_model_val = get_F_model(ecut, nk)\n            \n            delta_E = abs(E_model_val - E_ref)\n            \n            if delta_E  min_delta_E:\n                min_delta_E = delta_E\n            if F_model_val  min_F:\n                min_F = F_model_val\n                \n            is_energy_converged = delta_E = epsilon_E\n            is_force_converged = F_model_val = epsilon_F\n            \n            if is_energy_converged and is_force_converged:\n                cost = get_cost(ecut, nk)\n                reliable_candidates.append({\n                    \"E_cut\": ecut, \"Nk\": nk, \"cost\": cost, \n                    \"delta_E\": delta_E, \"F\": F_model_val\n                })\n\n        if reliable_candidates:\n            best_candidate = min(reliable_candidates, key=lambda x: x['cost'])\n            result = [\n                1,\n                float(best_candidate[\"E_cut\"]),\n                int(best_candidate[\"Nk\"]),\n                round(best_candidate[\"delta_E\"], 6),\n                round(best_candidate[\"F\"], 6)\n            ]\n        else:\n            result = [\n                0,\n                -1.0,\n                -1,\n                round(min_delta_E, 6),\n                round(min_F, 6)\n            ]\n            \n        all_results.append(result)\n\n    # Format the final output string exactly as specified\n    result_strings = [str(r).replace(\" \", \"\") for r in all_results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "DFT+U计算的预测能力在很大程度上取决于Hubbard参数$U$和双重计数方案的选取。本练习将指导您完成一个关键的基准测试过程：将计算结果与实验数据进行对比，以确定最具物理意义的参数。您将学习如何使用一个稳健的损失函数来量化理论与实验之间的一致性，并据此对$U$值和双重计数方法做出有理有据的选择，这是任何严肃的DFT+U实践者都必须掌握的核心技能。",
            "id": "4242185",
            "problem": "给定根据密度泛函理论加哈伯德参数 (DFT+U) 计算得到的科恩-沈带隙的离散数据集，这些数据集针对两种双重计算校正方案：完全局域极限 (FLL) 和平均场近似 (AMF)。任务是数学上评估计算出的带隙对双重计算校正方案选择和哈伯德参数 $U$ 的灵敏度，并构建一个针对实验光吸收和光电发射可观测量的稳健基准测试指标。\n\n基础背景。DFT+U 能量泛函可以写成密度泛函理论 (DFT) 能量、一个哈伯德校正项减去一个双重计算项的形式，即 $E_{\\mathrm{DFT}+U} = E_{\\mathrm{DFT}} + E_U - E_{\\mathrm{DC}}$，其中 $E_U$ 取决于 $U$ 和局域化轨道的占据数，而 $E_{\\mathrm{DC}}$ 是双重计算校正。两种广泛使用的双重计算选择是完全局域极限 (FLL) 和平均场近似 (AMF)。$U$ 的变化会改变关联子空间的分裂，从而改变带隙 $E_g$。光吸收通常探测的是光学带隙 $E_g^{\\mathrm{opt}}$，由于激子束缚能 $E_b$ 的存在，该值可能低于基本带隙。光电发射和反光电发射提供了基本带隙 $E_g^{\\mathrm{pes}}$ 的估计值。\n\n您的程序必须为每个提供的测试用例执行以下步骤：\n\n1. 灵敏度估计。给定一个哈伯德参数 $U_i$（单位为 $\\mathrm{eV}$）的网格以及相应计算出的带隙 $E_g^{\\mathrm{FLL}}(U_i)$ 和 $E_g^{\\mathrm{AMF}}(U_i)$（单位为 $\\mathrm{eV}$），通过有限差分为方案 $s \\in \\{\\mathrm{FLL}, \\mathrm{AMF}\\}$ 计算离散灵敏度 $S^{s}(U_i)$：\n   • 对于具有相邻点 $i-1$ 和 $i+1$ 的内部点 $i$，定义\n   $$S^{s}(U_i) = \\frac{E_g^{s}(U_{i+1}) - E_g^{s}(U_{i-1})}{U_{i+1} - U_{i-1}}.$$\n   • 对于端点，使用单边差分：\n   $$S^{s}(U_0) = \\frac{E_g^{s}(U_1) - E_g^{s}(U_0)}{U_1 - U_0}, \\quad S^{s}(U_{N-1}) = \\frac{E_g^{s}(U_{N-1}) - E_g^{s}(U_{N-2})}{U_{N-1} - U_{N-2}}.$$\n   以浮点数形式报告灵敏度，单位为 $\\mathrm{eV}/\\mathrm{eV}$。\n\n2. 稳健基准测试损失。将光学校正的基本目标定义为 $E_g^{\\mathrm{opt}} + E_b$（单位为 $\\mathrm{eV}$），并使用光电发射基本目标 $E_g^{\\mathrm{pes}}$（单位为 $\\mathrm{eV}$）。对于给定的方案 $s$ 和参数 $U_i$，定义每个方案的组合稳健损失\n   $$L_s(U_i) = \\frac{1}{2}\\left(\\mathrm{Huber}\\left(E_g^s(U_i) - \\left(E_g^{\\mathrm{opt}} + E_b\\right), \\delta\\right) + \\mathrm{Huber}\\left(E_g^s(U_i) - E_g^{\\mathrm{pes}}, \\delta\\right)\\right),$$\n   其中 Huber 损失为\n   $$\\mathrm{Huber}(r, \\delta) = \\begin{cases}\n   \\frac{1}{2} r^2,  |r| \\le \\delta,\\\\\n   \\delta|r| - \\frac{1}{2} \\delta^2,  |r|  \\delta.\n   \\end{cases}$$\n   使用 $\\delta = 0.2$ $\\mathrm{eV}$。\n\n3. 方案和参数选择。找出方案 $s^\\ast \\in \\{\\mathrm{FLL}, \\mathrm{AMF}\\}$ 和参数 $U^\\ast$，使得 $L_s(U_i)$ 在所有方案和所有网格点 $U_i$ 上最小化。如果在数值容差范围内最小损失值出现平局，优先选择 $\\mathrm{FLL}$ 而非 $\\mathrm{AMF}$；如果对于所选方案，在多个 $U_i$ 上仍然存在平局，则选择最小的 $U_i$。\n\n4. 要输出的摘要指标。对于每个测试用例，计算并以列表形式输出以下各项：\n   • 所选方案索引，作为整数：$0$ 代表 $\\mathrm{FLL}$，$1$ 代表 $\\mathrm{AMF}$。\n   • 所选的 $U^\\ast$，作为浮点数，单位为 $\\mathrm{eV}$。\n   • 灵敏度 $S^{s^\\ast}(U^\\ast)$（浮点数，单位为 $\\mathrm{eV}/\\mathrm{eV}$）。\n   • 灵敏度比率 $S^{\\mathrm{FLL}}(U^\\ast)/S^{\\mathrm{AMF}}(U^\\ast)$（浮点数；如果分母为零且分子非零，则返回 $\\infty$；如果分子和分母均为零，则返回 $1.0$）。\n   • 最小稳健损失 $L_{s^\\ast}(U^\\ast)$，作为浮点数，单位为 $\\mathrm{eV}$。\n   • 一个布尔值 $b$，指示拟合是否可接受，如果 $L_{s^\\ast}(U^\\ast) \\le T$ 则 $b = \\mathrm{True}$，否则 $b = \\mathrm{False}$，使用阈值 $T = 0.1$ $\\mathrm{eV}$。\n\n物理和数值单位。所有能量和哈伯德参数 $U$ 都必须以 $\\mathrm{eV}$ 为单位处理。灵敏度以 $\\mathrm{eV}/\\mathrm{eV}$ 为单位报告。不涉及角度。不需要百分比。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素对应一个测试用例，并且本身是包含上述六项的列表。例如：\n$$[ [\\text{case1\\_item1}, \\ldots, \\text{case1\\_item6}], [\\text{case2\\_item1}, \\ldots, \\text{case2\\_item6}], \\ldots ]$$\n\n测试套件。使用以下测试用例：\n\n测试用例 A（通用情况，单调且斜率不同）：\n• $U$ 网格：$[0, 1, 2, 3, 4, 5]$ $\\mathrm{eV}$。\n• $E_g^{\\mathrm{FLL}}(U)$：$[0.8, 1.5, 2.3, 3.1, 3.8, 4.5]$ $\\mathrm{eV}$。\n• $E_g^{\\mathrm{AMF}}(U)$：$[0.6, 1.0, 1.5, 1.9, 2.3, 2.7]$ $\\mathrm{eV}$。\n• $E_g^{\\mathrm{opt}} = 2.2$ $\\mathrm{eV}$，$E_g^{\\mathrm{pes}} = 2.8$ $\\mathrm{eV}$，$E_b = 0.4$ $\\mathrm{eV}$。\n\n测试用例 B（边界情况，对 $U$ 的依赖性弱）：\n• $U$ 网格：$[0, 2, 4, 6, 8]$ $\\mathrm{eV}$。\n• $E_g^{\\mathrm{FLL}}(U)$：$[1.0, 1.1, 1.2, 1.25, 1.3]$ $\\mathrm{eV}$。\n• $E_g^{\\mathrm{AMF}}(U)$：$[0.9, 0.95, 1.0, 1.05, 1.1]$ $\\mathrm{eV}$。\n• $E_g^{\\mathrm{opt}} = 1.05$ $\\mathrm{eV}$，$E_g^{\\mathrm{pes}} = 1.2$ $\\mathrm{eV}$，$E_b = 0.1$ $\\mathrm{eV}$。\n\n测试用例 C（边缘情况，在大的 $U$ 值下饱和）：\n• $U$ 网格：$[0, 1, 2, 3, 4, 5, 6]$ $\\mathrm{eV}$。\n• $E_g^{\\mathrm{FLL}}(U)$：$[0.5, 1.2, 1.8, 2.2, 2.4, 2.5, 2.5]$ $\\mathrm{eV}$。\n• $E_g^{\\mathrm{AMF}}(U)$：$[0.4, 0.9, 1.3, 1.6, 1.8, 1.9, 1.9]$ $\\mathrm{eV}$。\n• $E_g^{\\mathrm{opt}} = 1.7$ $\\mathrm{eV}$，$E_g^{\\mathrm{pes}} = 2.1$ $\\mathrm{eV}$，$E_b = 0.3$ $\\mathrm{eV}$。\n\n完全按照规定实现选择和报告规则，并为三个测试用例以所需格式生成单行输出。",
            "solution": "该问题陈述已经过严格审查，并被确定为有效。它在科学上基于计算材料科学的原理，特别是密度泛函理论 (DFT)，并且是良构的，为获得唯一且可验证的解提供了所有必要的数据、参数和定义。该问题要求实施一个计算协议，用于将 DFT+U 计算与实验数据进行基准测试，这是该领域的标准做法。\n\n该过程包括四个主要步骤：估计计算出的带隙对哈伯德 $U$ 参数的灵敏度，定义和计算用于与实验可观测量进行比较的稳健损失函数，选择最优的计算方案和参数，最后报告一组摘要指标。每个步骤将在下面详细说明，并遵循所提供的定义。所有数学量将按要求以 LaTeX 格式呈现。\n\n基础背景是 DFT+U 能量泛函 $E_{\\mathrm{DFT}+U} = E_{\\mathrm{DFT}} + E_U - E_{\\mathrm{DC}}$。双重计算校正 $E_{\\mathrm{DC}}$ 的选择会影响计算出的电子结构，包括基本带隙 $E_g$。我们获得了两种常见方案的数据，即完全局域极限 (FLL) 和平均场近似 (AMF)。\n\n**步骤1：灵敏度估计**\n\n灵敏度 $S^{s}(U_i)$ 量化了对于给定方案 $s \\in \\{\\mathrm{FLL}, \\mathrm{AMF}\\}$，在特定点 $U_i$ 处带隙 $E_g^s$ 相对于哈伯德参数 $U$ 的变化率。它是导数 $\\frac{dE_g^s}{dU}$ 的数值近似。问题指定对离散 $U$ 网格的内部点使用中心差分公式，对端点使用单边有限差分。\n\n对于内部网格点 $U_i$（其中 $i \\in \\{1, 2, \\dots, N-2\\}$），灵敏度计算如下：\n$$S^{s}(U_i) = \\frac{E_g^{s}(U_{i+1}) - E_g^{s}(U_{i-1})}{U_{i+1} - U_{i-1}}$$\n这个二阶精确公式比一阶单边差分提供了更稳定的局部斜率估计。\n\n对于第一个点 $U_0$，使用前向差分：\n$$S^{s}(U_0) = \\frac{E_g^{s}(U_1) - E_g^{s}(U_0)}{U_1 - U_0}$$\n对于最后一个点 $U_{N-1}$，使用后向差分：\n$$S^{s}(U_{N-1}) = \\frac{E_g^{s}(U_{N-1}) - E_g^{s}(U_{N-2})}{U_{N-1} - U_{N-2}}$$\n这些灵敏度是为 FLL 和 AMF 两种方案在它们各自的 $U$ 网格上计算的。单位是 $\\mathrm{eV}/\\mathrm{eV}$。\n\n**步骤2：稳健基准测试损失**\n\n需要一个损失函数来量化计算出的带隙 $E_g^s(U_i)$ 与实验测量值之间的差异。问题要求与两个不同的实验目标进行比较：\n1. 经激子束缚能 $E_b$ 校正的光吸收带隙 $E_g^{\\mathrm{opt}}$。这个和 $E_g^{\\mathrm{opt}} + E_b$ 作为光学测量得到的基本带隙的估计值。\n2. 光电发射带隙 $E_g^{\\mathrm{pes}}$，这是通过光电发射和反光电发射光谱学对基本带隙的直接测量。\n\n采用 Huber 损失函数来提供对异常值的稳健性。它结合了平方误差损失（L2 范数）对小残差和绝对误差损失（L1 范数）对大残差的理想特性。对于一个残差 $r$，带有阈值参数 $\\delta$ 的 Huber 损失为：\n$$\\mathrm{Huber}(r, \\delta) = \\begin{cases}\n\\frac{1}{2} r^2,  \\text{if } |r| \\le \\delta \\\\\n\\delta|r| - \\frac{1}{2} \\delta^2,  \\text{if } |r|  \\delta\n\\end{cases}$$\n问题指定 $\\delta = 0.2$ $\\mathrm{eV}$。\n\n对于给定的方案 $s$ 和参数 $U_i$，总稳健损失（记作 $L_s(U_i)$）是为两个实验目标计算的 Huber 损失的平均值：\n$$L_s(U_i) = \\frac{1}{2}\\left(\\mathrm{Huber}\\left(E_g^s(U_i) - \\left(E_g^{\\mathrm{opt}} + E_b\\right), \\delta\\right) + \\mathrm{Huber}\\left(E_g^s(U_i) - E_g^{\\mathrm{pes}}, \\delta\\right)\\right)$$\n\n**步骤3：方案和参数选择**\n\n方案 $s^\\ast$ 和参数 $U^\\ast$ 的最优组合是能够最小化在所有方案 $s$ 和所有网格点 $U_i$ 上的稳健损失函数 $L_s(U_i)$ 的组合。通过为每个对 $(s, U_i)$ 计算 $L_s(U_i)$ 并识别最小值来执行优化。\n\n为确保确定性的结果，规定了特定的平局打破规则：\n1. 如果 FLL 和 AMF 方案都达到了最小损失值，则应优先选择 FLL 方案（$s^\\ast = \\mathrm{FLL}$）。\n2. 如果对于所选方案 $s^\\ast$，在多个 $U_i$ 值上都达到了最小损失，则选择最小的 $U_i$ 值作为 $U^\\ast$。\n\n**步骤4：摘要指标**\n\n在确定最优对 $(s^\\ast, U^\\ast)$ 之后，必须计算一组六个摘要指标以供输出：\n1. **方案索引：** $s^\\ast$ 的整数表示，其中 $0$ 对应 FLL，$1$ 对应 AMF。\n2. **所选的 $U^\\ast$：** 最优哈伯德参数，单位为 $\\mathrm{eV}$。\n3. **灵敏度 $S^{s^\\ast}(U^\\ast)$：** 在最优参数 $U^\\ast$ 下，最优方案的预计算灵敏度，单位为 $\\mathrm{eV}/\\mathrm{eV}$。\n4. **灵敏度比率：** 比率 $S^{\\mathrm{FLL}}(U^\\ast) / S^{\\mathrm{AMF}}(U^\\ast)$。对分母为零的情况需要特殊处理：如果 $S^{\\mathrm{AMF}}(U^\\ast)=0$ 且 $S^{\\mathrm{FLL}}(U^\\ast) \\ne 0$，值为无穷大。如果两者都为零，值为 $1.0$。\n5. **最小损失 $L_{s^\\ast}(U^\\ast)$：** 损失函数的最小值，单位为 $\\mathrm{eV}$。\n6. **可接受性：** 一个布尔值，如果最小损失 $L_{s^\\ast}(U^\\ast)$ 小于或等于阈值 $T = 0.1$ $\\mathrm{eV}$，则为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。\n\n这些步骤构成了一个完整而严谨的工作流程，用于将计算方法与实验数据进行基准测试，从而实现有原则的模型参数选择。对于每个提供的测试用例，实现将精确遵循此逻辑。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DFT+U benchmarking problem for a suite of test cases.\n    \"\"\"\n    \n    # Define physical and model constants from the problem statement\n    delta = 0.2  # Huber loss parameter in eV\n    loss_threshold = 0.1  # Acceptability threshold T in eV\n\n    # Test cases as provided in the problem statement\n    test_cases = [\n        {\n            \"U\": np.array([0., 1., 2., 3., 4., 5.]),\n            \"Eg_FLL\": np.array([0.8, 1.5, 2.3, 3.1, 3.8, 4.5]),\n            \"Eg_AMF\": np.array([0.6, 1.0, 1.5, 1.9, 2.3, 2.7]),\n            \"Eg_opt\": 2.2, \"Eg_pes\": 2.8, \"Eb\": 0.4\n        },\n        {\n            \"U\": np.array([0., 2., 4., 6., 8.]),\n            \"Eg_FLL\": np.array([1.0, 1.1, 1.2, 1.25, 1.3]),\n            \"Eg_AMF\": np.array([0.9, 0.95, 1.0, 1.05, 1.1]),\n            \"Eg_opt\": 1.05, \"Eg_pes\": 1.2, \"Eb\": 0.1\n        },\n        {\n            \"U\": np.array([0., 1., 2., 3., 4., 5., 6.]),\n            \"Eg_FLL\": np.array([0.5, 1.2, 1.8, 2.2, 2.4, 2.5, 2.5]),\n            \"Eg_AMF\": np.array([0.4, 0.9, 1.3, 1.6, 1.8, 1.9, 1.9]),\n            \"Eg_opt\": 1.7, \"Eg_pes\": 2.1, \"Eb\": 0.3\n        },\n    ]\n\n    def compute_sensitivity(U, Eg):\n        \"\"\"\n        Calculates the discrete sensitivity S^s(U_i) using finite differences.\n        \"\"\"\n        N = len(U)\n        S = np.zeros(N, dtype=float)\n        # Endpoint: forward difference\n        if N > 1:\n            S[0] = (Eg[1] - Eg[0]) / (U[1] - U[0])\n            # Endpoint: backward difference\n            S[N-1] = (Eg[N-1] - Eg[N-2]) / (U[N-1] - U[N-2])\n        if N > 2:\n            # Interior points: central difference\n            for i in range(1, N - 1):\n                S[i] = (Eg[i+1] - Eg[i-1]) / (U[i+1] - U[i-1])\n        return S\n\n    def huber_loss(r, delta):\n        \"\"\"\n        Calculates the Huber loss for a given residual r and delta.\n        \"\"\"\n        abs_r = np.abs(r)\n        if abs_r = delta:\n            return 0.5 * r**2\n        else:\n            return delta * abs_r - 0.5 * delta**2\n\n    def calculate_total_loss(Eg_val, E_target1, E_target2, delta):\n        \"\"\"\n        Calculates the combined robust loss L_s(U_i).\n        \"\"\"\n        r1 = Eg_val - E_target1\n        r2 = Eg_val - E_target2\n        loss1 = huber_loss(r1, delta)\n        loss2 = huber_loss(r2, delta)\n        return 0.5 * (loss1 + loss2)\n\n    all_results = []\n    for case in test_cases:\n        U, Eg_FLL, Eg_AMF = case[\"U\"], case[\"Eg_FLL\"], case[\"Eg_AMF\"]\n        Eg_opt, Eg_pes, Eb = case[\"Eg_opt\"], case[\"Eg_pes\"], case[\"Eb\"]\n\n        # Step 1: Sensitivity estimation\n        S_FLL = compute_sensitivity(U, Eg_FLL)\n        S_AMF = compute_sensitivity(U, Eg_AMF)\n        \n        # Define experimental targets\n        E_target1 = Eg_opt + Eb\n        E_target2 = Eg_pes\n\n        min_loss = float('inf')\n        best_scheme_idx = -1\n        best_U_idx = -1\n\n        # Step 2  3: Compute losses and find minimum\n        # Iterate FLL (0) then AMF (1) to handle tie-breaking for scheme\n        schemes = [(0, Eg_FLL), (1, Eg_AMF)]\n        for s_idx, Eg_s in schemes:\n            for i in range(len(U)):\n                loss = calculate_total_loss(Eg_s[i], E_target1, E_target2, delta)\n                \n                # Using  handles tie-breaking for U (first one wins)\n                # and for scheme (FLL is checked first)\n                if loss  min_loss:\n                    min_loss = loss\n                    best_scheme_idx = s_idx\n                    best_U_idx = i\n\n        # Step 4: Summary metrics\n        chosen_scheme_idx = best_scheme_idx\n        chosen_U = U[best_U_idx]\n        \n        if chosen_scheme_idx == 0: # FLL\n            chosen_S = S_FLL[best_U_idx]\n        else: # AMF\n            chosen_S = S_AMF[best_U_idx]\n            \n        # Sensitivity ratio\n        s_fll_at_U_star = S_FLL[best_U_idx]\n        s_amf_at_U_star = S_AMF[best_U_idx]\n        \n        if s_amf_at_U_star == 0.0:\n            if s_fll_at_U_star == 0.0:\n                S_ratio = 1.0\n            else:\n                S_ratio = float('inf')\n        else:\n            S_ratio = s_fll_at_U_star / s_amf_at_U_star\n            \n        min_loss_val = min_loss\n        is_acceptable = min_loss_val = loss_threshold\n        \n        result_list = [\n            chosen_scheme_idx,\n            float(chosen_U),\n            float(chosen_S),\n            float(S_ratio),\n            float(min_loss_val),\n            is_acceptable\n        ]\n        all_results.append(result_list)\n        \n    # Format the final output as specified\n    output_str = f\"[{','.join(map(str, all_results))}]\".replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}