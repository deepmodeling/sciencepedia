{
    "hands_on_practices": [
        {
            "introduction": "本练习聚焦于MHC速率表达式中的前置因子。我们将通过量纲分析来验证其单位，并探讨约化普朗克常数 $\\hbar$ 在非绝热电子转移过程中的根本作用。这项练习旨在加深对模型量子力学起源（费米黄金定则）与最终动力学参数之间联系的理解。",
            "id": "4260324",
            "problem": "在电极电子转移的 Marcus–Hush–Chidsey (MHC) 模型的非绝热极限下，电极与氧化还原态之间电子转移的速率常数前因子通常写作\n$$\nA \\equiv \\frac{2\\pi}{\\hbar}\\,|V|^{2}\\,\\frac{1}{\\sqrt{4\\pi\\,\\lambda\\,k_{B}\\,T}},\n$$\n其中 $V$ 是电子耦合矩阵元，$\\lambda$ 是重组能，$k_{B}$ 是玻尔兹曼常数，$T$ 是绝对温度，而 $\\hbar$ 是约化普朗克常数。\n\n(a) 仅从能量、时间和温度的基本量纲定义出发，使用量纲分析确定 $A$ 的单位。您可以假设这些符号的量纲为：$[V]=\\text{能量}$，$[\\lambda]=\\text{能量}$，$[k_{B}T]=\\text{能量}$，以及 $[\\hbar]=\\text{能量}\\times\\text{时间}$。请用时间的基本单位明确表示您最终得到的 $A$ 的量纲结果。\n\n(b) 基于您的量纲分析和植根于含时微扰理论（费米黄金定则）的物理推理，确定 $\\hbar$ 在电极非绝热电子转移极限中将耦合能标转换为速率常数所起的作用。\n\n(c) 对于一个具体案例，使用以下参数（典型的室温下金属电极上的电子转移参数）数值计算 $A$：$V=0.010\\,\\text{eV}$，$\\lambda=0.80\\,\\text{eV}$， $T=298\\,\\text{K}$，$\\hbar=1.054\\,571\\,817\\times 10^{-34}\\,\\text{J}\\cdot\\text{s}$， $k_{B}=1.380\\,649\\times 10^{-23}\\,\\text{J}\\cdot\\text{K}^{-1}$，以及 $1\\,\\text{eV}=1.602\\,176\\,634\\times 10^{-19}\\,\\text{J}$。按需进行所有单位换算并计算 $A$。将您的最终数值答案四舍五入至三位有效数字。以 $\\text{s}^{-1}$ 为单位表示您的最终结果。答案框中不要包含单位。",
            "solution": "该问题提问清晰，其科学基础根植于量子力学和物理化学原理，并包含了完整解答所需的所有信息。我们将按顺序处理每个部分。\n\n(a) 为使用量纲分析确定前因子 $A$ 的单位，我们从其定义开始：\n$$\nA \\equiv \\frac{2\\pi}{\\hbar}\\,|V|^{2}\\,\\frac{1}{\\sqrt{4\\pi\\,\\lambda\\,k_{B}\\,T}}\n$$\n常数 $2\\pi$ 和 $4\\pi$ 是无量纲数，在量纲分析中可以忽略。令 $[X]$ 表示量 $X$ 的量纲。$A$ 的量纲由下式给出：\n$$\n[A] = \\frac{1}{[\\hbar]} [V]^{2} \\frac{1}{\\sqrt{[\\lambda][k_{B}T]}}\n$$\n问题以能量（我们记作 $[E]$）和时间（我们记作 $[T]$）的基本量纲给出了变量的量纲：\n\\begin{itemize}\n    \\itemsep0em\n    \\item $[V] = [E]$ (能量)\n    \\item $[\\lambda] = [E]$ (能量)\n    \\item $[k_{B}T] = [E]$ (能量)\n    \\item $[\\hbar] = [E] \\cdot [T]$ (能量 $\\times$ 时间)\n\\end{itemize}\n将这些代入 $[A]$ 的量纲方程：\n$$\n[A] = \\frac{1}{[E] \\cdot [T]} \\cdot [E]^{2} \\cdot \\frac{1}{\\sqrt{[E] \\cdot [E]}}\n$$\n我们可以简化平方根中的项：\n$$\n\\sqrt{[E] \\cdot [E]} = \\sqrt{[E]^{2}} = [E]\n$$\n将其代回 $[A]$ 的表达式：\n$$\n[A] = \\frac{1}{[E] \\cdot [T]} \\cdot [E]^{2} \\cdot \\frac{1}{[E]}\n$$\n能量量纲 $[E]$ 可以消去：\n$$\n[A] = \\frac{[E]^{2}}{([E] \\cdot [T]) \\cdot [E]} = \\frac{[E]^{2}}{[E]^{2} \\cdot [T]} = \\frac{1}{[T]} = [T]^{-1}\n$$\n因此，$A$ 的量纲是时间的倒数。在国际单位制（SI）基本单位中，这对应于秒的倒数，即 $\\text{s}^{-1}$，这是速率常数或频率的单位。\n\n(b) 约化普朗克常数 $\\hbar$ 的作用可以通过在含时微扰理论（该表达式由此导出）的背景下考察给定表达式的结构来理解。从一个初态到一组连续末态的跃迁速率 $k$ 由费米黄金定则给出：\n$$\nk = \\frac{2\\pi}{\\hbar} |\\langle \\psi_f | \\hat{H}_{\\text{pert}} | \\psi_i \\rangle|^{2} \\rho(E_f)\n$$\n这里，$\\langle \\psi_f | \\hat{H}_{\\text{pert}} | \\psi_i \\rangle$ 是耦合初态 $\\psi_i$ 和末态 $\\psi_f$ 的微扰哈密顿量的矩阵元，$\\rho(E_f)$ 是能量为 $E_f$ 时的末态密度。\n\n在 Marcus-Hush-Chidsey 模型的背景下，速率常数前因子 $A$ 在特定假设下对应于此跃迁速率。\n\\begin{itemize}\n    \\itemsep0em\n    \\item 电子耦合矩阵元 $V$ 对应于微扰矩阵元 $\\langle \\psi_f | \\hat{H}_{\\text{pert}} | \\psi_i \\rangle$。因此，$|V|^{2}$ 是耦合强度的平方，量纲为 $[E]^{2}$。\n    \\item 项 $\\frac{1}{\\sqrt{4\\pi\\lambda k_B T}}$ 代表电极上可用于电子转移过程的、经过热平均的电子态密度。根据我们在(a)部分的量纲分析，$\\sqrt{4\\pi\\lambda k_B T}$ 的量纲是 $[E]$。因此，这个态密度因子的量纲是 $[E]^{-1}$。\n\\end{itemize}\n因此，乘积 $|V|^{2} \\cdot \\frac{1}{\\sqrt{4\\pi\\lambda k_B T}}$ 的量纲为 $[E]^{2} \\cdot [E]^{-1} = [E]$。这个量代表了跃迁过程的有效能量，由耦合强度和末态的可及性决定。\n\n于是，速率常数 $A$ 的量纲结构为：\n$$\n[A] = \\frac{1}{[\\hbar]} \\cdot [E]\n$$\n鉴于 $[\\hbar] = [E] \\cdot [T]$，我们发现：\n$$\n[A] = \\frac{[E]}{[E] \\cdot [T]} = \\frac{1}{[T]}\n$$\n这证实了 $\\hbar$ 是将一个具有能量量纲的量转换为一个具有时间倒数量纲（速率或频率）的量的基本物理常数。这一作用是量子力学的基石，反映了能量-时间不确定性原理 ($\\Delta E \\Delta t \\gtrsim \\hbar$)。一个以能量标度 $E$ 为特征的量子过程，发生的时间尺度与 $\\hbar/E$ 成正比，因此其速率与 $E/\\hbar$ 成正比。在非绝热极限下，$\\hbar$ 作为作用量子，直接将能量景观（$|V|^2$ 和态密度）与时间动力学（电子转移速率）联系起来。\n\n(c) 为数值计算 $A$，我们使用给定的公式和参数。\n$$\nA = \\frac{2\\pi}{\\hbar}\\,|V|^{2}\\,\\frac{1}{\\sqrt{4\\pi\\,\\lambda\\,k_{B}\\,T}}\n$$\n首先，我们必须将所有参数转换为一套一致的单位，具体为国际单位制（焦耳、开尔文、秒）。\n给定参数：\n\\begin{itemize}\n    \\itemsep0em\n    \\item $V = 0.010\\,\\text{eV}$\n    \\item $\\lambda = 0.80\\,\\text{eV}$\n    \\item $T = 298\\,\\text{K}$\n    \\item $\\hbar = 1.054\\,571\\,817 \\times 10^{-34}\\,\\text{J}\\cdot\\text{s}$\n    \\item $k_{B} = 1.380\\,649 \\times 10^{-23}\\,\\text{J}\\cdot\\text{K}^{-1}$\n    \\item $1\\,\\text{eV} = 1.602\\,176\\,634 \\times 10^{-19}\\,\\text{J}$\n\\end{itemize}\n对 $V$ 和 $\\lambda$ 进行单位换算：\n$$\nV = 0.010\\,\\text{eV} \\times \\left( \\frac{1.602\\,176\\,634 \\times 10^{-19}\\,\\text{J}}{1\\,\\text{eV}} \\right) = 1.602\\,176\\,634 \\times 10^{-21}\\,\\text{J}\n$$\n$$\n\\lambda = 0.80\\,\\text{eV} \\times \\left( \\frac{1.602\\,176\\,634 \\times 10^{-19}\\,\\text{J}}{1\\,\\text{eV}} \\right) = 1.281\\,741\\,3072 \\times 10^{-19}\\,\\text{J}\n$$\n现在我们计算表达式的各个组成部分。\n热能项是 $k_B T$：\n$$\nk_B T = (1.380\\,649 \\times 10^{-23}\\,\\text{J}\\cdot\\text{K}^{-1}) \\times (298\\,\\text{K}) = 4.114\\,334... \\times 10^{-21}\\,\\text{J}\n$$\n计算平方根下的项：\n$$\n4\\pi\\lambda k_B T = 4\\pi \\times (1.281\\,741... \\times 10^{-19}\\,\\text{J}) \\times (4.114\\,334... \\times 10^{-21}\\,\\text{J})\n$$\n$$\n4\\pi\\lambda k_B T \\approx 6.626\\,93... \\times 10^{-39}\\,\\text{J}^2\n$$\n该项的平方根是：\n$$\n\\sqrt{4\\pi\\lambda k_B T} \\approx \\sqrt{6.626\\,93... \\times 10^{-39}\\,\\text{J}^2} \\approx 8.140\\,60... \\times 10^{-20}\\,\\text{J}\n$$\n现在，计算分子项 $2\\pi|V|^2$：\n$$\n|V|^2 = (1.602\\,176\\,634 \\times 10^{-21}\\,\\text{J})^2 \\approx 2.566\\,970... \\times 10^{-42}\\,\\text{J}^2\n$$\n$$\n2\\pi|V|^2 \\approx 2\\pi \\times (2.566\\,970... \\times 10^{-42}\\,\\text{J}^2) \\approx 1.612\\,86... \\times 10^{-41}\\,\\text{J}^2\n$$\n最后，将所有部分组合起来计算 $A$：\n$$\nA = \\frac{2\\pi|V|^2}{\\hbar \\sqrt{4\\pi\\lambda k_B T}} \\approx \\frac{1.612\\,86... \\times 10^{-41}\\,\\text{J}^2}{(1.054\\,571\\,817 \\times 10^{-34}\\,\\text{J}\\cdot\\text{s}) \\times (8.140\\,60... \\times 10^{-20}\\,\\text{J})}\n$$\n$$\nA \\approx \\frac{1.612\\,86... \\times 10^{-41}\\,\\text{J}^2}{8.586\\,25... \\times 10^{-54}\\,\\text{J}^2 \\cdot\\text{s}} \\approx 1.8785... \\times 10^{12}\\,\\text{s}^{-1}\n$$\n按要求将结果四舍五入至三位有效数字：\n$$\nA \\approx 1.88 \\times 10^{12}\\,\\text{s}^{-1}\n$$",
            "answer": "$$\n\\boxed{1.88 \\times 10^{12}}\n$$"
        },
        {
            "introduction": "MHC模型为解释实验结果提供了强有力的框架。本练习将演示如何将该模型与依赖于分子-电极间距的电子转移速率的真实测量数据联系起来。通过将实验数据拟合到模型预测的指数衰减关系，我们可以提取出一个关键的物理参数——衰减常数 $\\beta$。",
            "id": "4260340",
            "problem": "给定一组在不同溶剂和电极材料组合下测得的、依赖于距离的多相电子转移速率数据。从一个有效的基础原理出发，推导 Marcus-Hush-Chidsey (MHC) 电极动力学模型中速率对距离依赖性的主导项，并用它来推断表征渐逝电子耦合的指数衰减常数。然后，您需要将推导出的关系式实现为一个程序，用以从所提供的数据集中拟合衰减常数，并输出拟合值。\n\n基本原理（作为推导的起点）：\n- Fermi 黄金法则：非绝热电子转移速率与电子耦合的平方和核因子成正比，即 $k \\propto \\lvert V \\rvert^{2} \\times \\mathrm{FCWD}$，其中 $\\mathrm{FCWD}$ 表示 Franck-Condon 加权密度。\n- Marcus 电子转移模型：核因子可以很好地由一个关于能隙的高斯函数描述，其重组能为 $\\lambda$，温度为 $T$；多相情况则对根据 Fermi-Dirac 分布占据的电极电子态进行积分，从而得到用于电极动力学的 Marcus-Hush-Chidsey (MHC) 速率。\n- 电子耦合穿过有限厚度势垒的渐逝隧穿行为，意味着耦合强度具有指数距离依赖性，因此耦合项依赖于分离距离。\n\n任务：\n1. 从上述基本原理出发，推导在重组能 $\\lambda$、驱动力（电极过电势）$\\Delta G$ 和热环境固定的情况下，多相电子转移速率 $k(d)$ 对分离距离 $d$ 的主导项依赖关系。您的推导必须确定一个概括了距离依赖性的衰减参数 $\\beta$。\n2. 实现一个程序，在给定一组测量的距离和速率的情况下，通过步骤1中推导出的适当回归方法来拟合衰减参数 $\\beta$。对任何对数变换，请使用自然对数。假设在对数域中存在加性高斯噪声（等效于速率中的乘性对数正态噪声）。\n3. 物理单位：距离 $d$ 的单位是 $\\mathrm{nm}$，速率 $k$ 的单位是 $\\mathrm{s}^{-1}$。报告拟合的 $\\beta$，单位为 $\\mathrm{nm}^{-1}$。\n4. 输出格式：您的程序应生成单行输出，其中包含所有拟合的 $\\beta$ 值，四舍五入到三位小数，格式为方括号括起来的逗号分隔的 Python 列表，例如 $[0.123,4.567,8.910]$。\n\n测试套件（每个案例提供距离 $d$（单位 $\\mathrm{nm}$）和测量速率 $k$（单位 $\\mathrm{s}^{-1}$））：\n- 案例 $1$（金电极，水中）：$d = [0.5, 1.0, 1.5, 2.0, 2.5]$, $k = [67379.47, 453.9993, 3.059023, 0.0206115, 0.000138879]$。\n- 案例 $2$（金电极，乙腈中）：$d = [0.5, 1.0, 1.5, 2.0, 2.5]$, $k = [91575.0, 1677.313, 30.72106, 0.5626759, 0.010305768]$。\n- 案例 $3$（石墨电极，水中）：$d = [0.5, 1.0, 1.5, 2.0, 2.5]$, $k = [49575.0, 122.88424, 0.3045994, 0.0007550268, 0.00000187152]$。\n- 案例 $4$（石墨电极，离子液体中）：$d = [0.5, 1.0, 1.5, 2.0, 2.5]$, $k = [149361.0, 7436.25, 370.229, 18.43264, 0.9177069]$。\n- 案例 $5$（慢衰减边缘案例）：$d = [0.5, 1.0, 1.5, 2.0, 2.5]$, $k = [7788.008, 6065.307, 4723.666, 3678.794, 2865.048]$。\n- 案例 $6$（零距离边界）：$d = [0.0, 0.1, 0.2, 0.3, 0.4]$, $k = [100000.0, 36787.944, 13533.528, 4978.707, 1831.564]$。\n\n答案规格：\n- 对于测试套件中的每个案例，计算拟合的衰减参数 $\\beta$（单位为 $\\mathrm{nm}^{-1}$），并四舍五入到三位小数。\n- 您的程序应生成单行输出，其中包含结果，格式为方括号括起来的逗号分隔列表，例如 $[10.000,8.000,12.000,6.000,0.500,10.000]$。",
            "solution": "该问题要求基于 Marcus-Hush-Chidsey (MHC) 模型，推导多相电子转移速率常数 $k(d)$ 对距离依赖性的主导项，并随后实现一个拟合程序，从提供的实验数据中确定指数衰减常数 $\\beta$。\n\n**距离依赖性的推导**\n\n分析始于用于非绝热电子转移过程速率常数 $k$ 的 Fermi 黄金法则。该法则指出，速率与电子耦合矩阵元 $\\lvert V \\rvert$ 的平方以及 Franck-Condon 加权态密度 (FCWD) 成正比：\n$$k \\propto \\lvert V \\rvert^2 \\times \\mathrm{FCWD}$$\n\n对于电极上的多相电子转移，总速率常数 $k$ 是对电极导带内所有电子能级 $\\epsilon$ 的积分。综合的 Marcus-Hush-Chidsey (MHC) 模型为该速率提供了以下表达式：\n$$k = C_{pre} \\int_{-\\infty}^{\\infty} \\rho(\\epsilon) \\lvert V(\\epsilon) \\rvert^2 f(\\epsilon, E_F, T) \\exp\\left(-\\frac{(\\lambda + \\Delta G - \\epsilon)^2}{4\\lambda k_B T}\\right) d\\epsilon$$\n在此方程中，$C_{pre}$ 是一系列基本常数，$\\rho(\\epsilon)$ 是能量为 $\\epsilon$ 时的电极态密度，$\\lvert V(\\epsilon) \\rvert$ 是该能量下的电子耦合，$f(\\epsilon, E_F, T)$ 是温度为 $T$、Fermi 能级为 $E_F$ 时的 Fermi-Dirac 分布函数，$\\lambda$ 是重组能，$\\Delta G$ 是在标准电势下（与外加过电势相关）反应的自由能变化，$k_B$ 是 Boltzmann 常数。\n\n问题指明实验条件是重组能 ($\\lambda$)、驱动力 ($\\Delta G$) 和温度 ($T$) 保持固定。一个常用且有效的近似方法（尤其适用于主导项分析）是，在被积函数值显著的能量范围内，将态密度 $\\rho(\\epsilon)$ 和电子耦合 $\\lvert V(\\epsilon) \\rvert$ 视为对能量 $\\epsilon$ 弱相关。基于此假设，这些项可以被当作与能量无关的常数并移到积分号外：\n$$k \\approx C_{pre} \\rho \\lvert V \\rvert^2 \\int_{-\\infty}^{\\infty} f(\\epsilon, E_F, T) \\exp\\left(-\\frac{(\\lambda + \\Delta G - \\epsilon)^2}{4\\lambda k_B T}\\right) d\\epsilon$$\n由于在给定的实验中 $\\lambda$、$\\Delta G$ 和 $T$ 是常数，整个积分的计算结果是一个与分离距离 $d$ 无关的数值。我们用 $I_{\\mathrm{MHC}}$ 表示这个常数因子，它代表了对电极态积分后得到的总核贡献。\n$$I_{\\mathrm{MHC}} = \\int_{-\\infty}^{\\infty} f(\\epsilon, E_F, T) \\exp\\left(-\\frac{(\\lambda + \\Delta G - \\epsilon)^2}{4\\lambda k_B T}\\right) d\\epsilon$$\n因此，速率常数 $k$ 与依赖于距离的电子耦合的平方成正比：\n$$k(d) \\propto \\lvert V(d) \\rvert^2$$\n\n电子耦合 $\\lvert V(d) \\rvert$ 量化了氧化还原分子的轨道与电极电子态之间跨越分离介质（势垒）的相互作用。这种相互作用由量子力学隧穿效应主导。电子穿过厚度为 $d$ 的势垒的概率随厚度指数衰减。因此，电子耦合矩阵元表现出对距离的指数依赖性：\n$$\\lvert V(d) \\rvert = V_0 e^{-\\beta_{el} d}$$\n此处，$V_0$ 是在参考距离（例如 $d=0$）的耦合，$\\beta_{el}$ 是电子衰减常数，它由势垒介质的性质决定。\n\n将这个耦合表达式代入速率的正比关系中，我们得到速率常数 $k(d)$ 对距离 $d$ 的主导项依赖关系：\n$$k(d) \\propto \\left( V_0 e^{-\\beta_{el} d} \\right)^2 = V_0^2 e^{-2\\beta_{el} d}$$\n这个关系通常被写成简单的指数衰减形式：\n$$k(d) = k_0 e^{-\\beta d}$$\n在这个最终表达式中，$k_0$ 是外推至零距离（$d=0$）时的速率常数，它整合了 $V_0^2$ 和所有其他与距离无关的因子（例如 $C_{pre}$、$\\rho$、$I_{\\mathrm{MHC}}$）。参数 $\\beta$ 是速率的总体衰减常数。通过比较形式，我们建立了可观测的速率衰减常数 $\\beta$ 与底层的电子耦合衰减常数 $\\beta_{el}$ 之间的关键关系：\n$$\\beta = 2\\beta_{el}$$\n推导出的关系式 $k(d) = k_0 e^{-\\beta d}$ 构成了数据拟合过程的基础。\n\n**拟合步骤**\n\n模型 $k(d) = k_0 e^{-\\beta d}$ 是一个指数函数。为了便于进行简单而稳健的拟合，我们通过对等式两边取自然对数来将其线性化：\n$$\\ln(k) = \\ln(k_0 e^{-\\beta d}) = \\ln(k_0) + \\ln(e^{-\\beta d})$$\n$$\\ln(k) = \\ln(k_0) - \\beta d$$\n这个方程是标准线性形式 $y = c + mx$，其中：\n- 因变量是 $y = \\ln(k)$。\n- 自变量是 $x = d$。\n- 斜率是 $m = -\\beta$。\n- y轴截距是 $c = \\ln(k_0)$。\n\n问题陈述了一个假设，即在对数域中存在加性高斯噪声，这等效于原始速率中的乘性对数正态噪声。这一假设使得对对数变换后的数据 $(d_i, \\ln(k_i))$ 进行普通线性最小二乘回归成为统计上正确的参数估计方法。最佳拟合线的斜率 $m$ 将通过直接关系 $\\beta = -m$ 提供衰减参数 $\\beta$。\n\n对于每个数据集，计算算法将执行以下步骤：\n1.  将速率数据 $k_i$ 转换为其自然对数 $\\ln(k_i)$。\n2.  对 $\\ln(k)$ 与 $d$ 进行线性回归，以确定斜率 $m$。\n3.  计算衰减参数为 $\\beta = -m$。\n\n物理单位是一致的。由于 $d$ 的单位是 $\\mathrm{nm}$，而 $\\ln(k)$ 是无量纲的，斜率 $m$ 的单位是 $\\mathrm{nm}^{-1}$。因此，计算出的衰减参数 $\\beta$ 也将具有所要求的单位 $\\mathrm{nm}^{-1}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives the exponential decay constant beta from distance-dependent electron\n    transfer rate data based on the Marcus-Hush-Chidsey model.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a dictionary containing distance (d) and rate (k) data.\n    test_cases = [\n        {\n            \"d\": [0.5, 1.0, 1.5, 2.0, 2.5],\n            \"k\": [67379.47, 453.9993, 3.059023, 0.0206115, 0.000138879]\n        },\n        {\n            \"d\": [0.5, 1.0, 1.5, 2.0, 2.5],\n            \"k\": [91575.0, 1677.313, 30.72106, 0.5626759, 0.010305768]\n        },\n        {\n            \"d\": [0.5, 1.0, 1.5, 2.0, 2.5],\n            \"k\": [49575.0, 122.88424, 0.3045994, 0.0007550268, 0.00000187152]\n        },\n        {\n            \"d\": [0.5, 1.0, 1.5, 2.0, 2.5],\n            \"k\": [149361.0, 7436.25, 370.229, 18.43264, 0.9177069]\n        },\n        {\n            \"d\": [0.5, 1.0, 1.5, 2.0, 2.5],\n            \"k\": [7788.008, 6065.307, 4723.666, 3678.794, 2865.048]\n        },\n        {\n            \"d\": [0.0, 0.1, 0.2, 0.3, 0.4],\n            \"k\": [100000.0, 36787.944, 13533.528, 4978.707, 1831.564]\n        }\n    ]\n\n    results = []\n    # Iterate through each test case to calculate the decay constant.\n    for case in test_cases:\n        # Convert lists to NumPy arrays for vectorized operations.\n        d = np.array(case[\"d\"])\n        k = np.array(case[\"k\"])\n\n        # The relationship k = k0 * exp(-beta * d) can be linearized by taking the natural log:\n        # ln(k) = ln(k0) - beta * d\n        # This is a linear equation of the form y = c + m*x, where y=ln(k), x=d, and m=-beta.\n        log_k = np.log(k)\n\n        # Perform a linear regression (polynomial fit of degree 1) on the transformed data.\n        # np.polyfit returns the coefficients [slope, intercept] for the best-fit line.\n        slope, _ = np.polyfit(d, log_k, 1)\n\n        # The decay parameter beta is the negative of the slope from the linear fit.\n        beta = -slope\n\n        # Append the calculated beta to the results list.\n        results.append(beta)\n\n    # Format the results to three decimal places as required.\n    formatted_results = [f\"{res:.3f}\" for res in results]\n\n    # Final print statement in the exact required format: a comma-separated list in brackets.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "本练习将深入MHC模型的核心——卷积积分。我们将学习如何实现一种高效的数值方法，即高斯-埃尔米特求积法，来求解此积分并分析其收敛性。对于任何旨在精确模拟电极动力学的计算电化学家而言，这项练习将构建起至关重要的技能。",
            "id": "4260295",
            "problem": "您的任务是实现一个数值算法，用于评估一个在电极动力学的 Marcus–Hush–Chidsey 模型中出现的高斯-费米卷积。从统计力学和电子转移理论的基础出发，考虑一个位于电极上的电子，其化学势设为零，电子能量变量以热单位写作 $x = \\varepsilon / (k_B T)$，其中 $k_B$ 是玻尔兹曼常数，$T$ 是绝对温度。费米-狄拉克占据因子为 $f(x) = 1 / \\left(1 + e^{x}\\right)$。核重组由一个高斯因子建模，其宽度由重组能 $\\lambda$ 控制，并对能量失配引入二次惩罚。在无量纲形式下，设 $\\Lambda = \\lambda / (k_B T)$ 以及无量纲驱动参数 $\\delta$（过电势和标准自由能的平移组合，并由 $k_B T$ 进行缩放），用于速率评估的核心卷积积分可写作\n$$\nI(\\delta,\\Lambda) = \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{(x - \\delta)^2}{4 \\Lambda}\\right)\\,\\frac{1}{1 + e^{x}}\\,dx.\n$$\n\n您的目标是通过将该积分变换为带权重 $\\exp(-u^2)$ 的标准埃尔米特形式，来实现高斯-埃尔米特求积。具体来说，您必须：\n- 推导变量替换，将 $I(\\delta,\\Lambda)$ 变换为 $\\int_{-\\infty}^{\\infty} e^{-u^2} g(u)\\,du$ 形式的积分，其中 $g(u)$ 依赖于 $\\delta$ 和 $\\Lambda$。\n- 使用 $n$ 点高斯-埃尔米特法则来近似变换后的积分，从而得到 $I(\\delta,\\Lambda)$。\n- 通过与对变换后的积分在 $u \\in (-\\infty,\\infty)$ 上进行直接数值积分计算出的高精度参考值进行比较，验证关于节点数 $n$ 的收敛性。\n\n设计一个程序，对于一组指定的 $\\Lambda$ 和 $\\delta$ 值，计算在每个给定的 $n$ 值下，高斯-埃尔米特近似在 $\\delta$ 值网格上的最大相对误差。然后，对于每个 $\\Lambda$，确定集合中能够使最大相对误差小于指定容差 $\\varepsilon$ 的最小 $n$ 值。\n\n所有计算都应以无量纲形式进行；最终数值结果中不需要物理单位。不涉及角度。相对误差必须表示为十进制数。\n\n使用以下测试套件：\n- 无量纲重组能 $\\Lambda \\in \\{\\,0.5,\\,2.0,\\,20.0,\\,50.0\\,\\}$。\n- 无量纲驱动参数 $\\delta \\in \\{\\, -10.0,\\, -2.0,\\, 0.0,\\, 2.0,\\, 10.0 \\,\\}$。\n- 高斯-埃尔米特节点数 $n \\in \\{\\,4,\\,8,\\,16,\\,32,\\,64\\,\\}$。\n- 容差 $\\varepsilon = 10^{-8}$。\n\n您的程序必须：\n- 使用针对权重 $\\exp(-u^2)$ 的标准节点和权重，实现高斯-埃尔米特近似。\n- 通过对变换后的积分在 $u$ 上进行直接数值积分，计算 $I(\\delta,\\Lambda)$ 的高精度参考值。\n- 对于每个 $\\Lambda$，计算在给定的 $\\delta$ 网格上每个 $n$ 对应的最大相对误差。\n- 对于每个 $\\Lambda$，返回集合 $\\{\\,4,\\,8,\\,16,\\,32,\\,64\\,\\}$ 中使最大相对误差小于 $\\varepsilon$ 的最小 $n$。如果没有值能达到该容差，则返回最大的 $n$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个条目是对应于上述顺序中每个 $\\Lambda$ 的最小合格 $n$ 值（例如，$[n_{\\Lambda=0.5},n_{\\Lambda=2.0},n_{\\Lambda=20.0},n_{\\Lambda=50.0}]$）。每个 $n$ 必须是整数。",
            "solution": "本问题要求使用高斯-埃尔米特求积法来高效地计算 Marcus-Hush-Chidsey 模型中的一个核心卷积积分。为此，我们首先需要将积分变换为适用于该求积法的标准形式，然后设计算法来评估其近似精度。\n\n**1. 积分变换**\n\n高斯-埃尔米特求积法用于计算形如 $\\int_{-\\infty}^{\\infty} e^{-u^2} g(u)\\,du$ 的积分。我们的目标积分是：\n$$\nI(\\delta,\\Lambda) = \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{(x - \\delta)^2}{4 \\Lambda}\\right)\\,\\frac{1}{1 + e^{x}}\\,dx\n$$\n为了匹配 $e^{-u^2}$ 的权重形式，我们进行变量替换。令：\n$$\nu^2 = \\frac{(x - \\delta)^2}{4 \\Lambda} \\implies u = \\frac{x - \\delta}{2\\sqrt{\\Lambda}}\n$$\n从该式解出 $x$：\n$$\nx(u) = 2\\sqrt{\\Lambda} u + \\delta\n$$\n微分可得：\n$$\ndx = 2\\sqrt{\\Lambda}\\,du\n$$\n由于 $x$ 的积分区间是 $(-\\infty, \\infty)$，线性变换后的 $u$ 的积分区间仍然是 $(-\\infty, \\infty)$。\n\n将这些代入原积分表达式中，得到：\n$$\nI(\\delta, \\Lambda) = \\int_{-\\infty}^{\\infty} e^{-u^2} \\left( \\frac{1}{1 + \\exp(2\\sqrt{\\Lambda} u + \\delta)} \\right) (2\\sqrt{\\Lambda}\\,du)\n$$\n整理后，即可得到高斯-埃尔米特求积的标准形式：\n$$\nI(\\delta, \\Lambda) = \\int_{-\\infty}^{\\infty} e^{-u^2} g(u; \\delta, \\Lambda)\\,du\n$$\n其中，函数 $g(u)$ 定义为：\n$$\ng(u; \\delta, \\Lambda) = 2\\sqrt{\\Lambda} \\frac{1}{1 + \\exp(2\\sqrt{\\Lambda} u + \\delta)}\n$$\n\n**2. 高斯-埃尔米特求积与算法设计**\n\n$n$ 点高斯-埃尔米特求积法将上述积分近似为一个加权和：\n$$\nI_{GH}(\\delta, \\Lambda; n) = \\sum_{i=1}^{n} w_i g(u_i; \\delta, \\Lambda)\n$$\n其中 $u_i$ 是 $n$ 阶埃尔米特多项式的根（节点），$w_i$ 是对应的权重。\n\n算法流程如下：\n1.  **计算参考值**：对于每一组给定的 $(\\delta, \\Lambda)$，使用高精度的自适应数值积分方法（如 `scipy.integrate.quad`）计算变换后的积分 $\\int_{-\\infty}^{\\infty} e^{-u^2} g(u; \\delta, \\Lambda)\\,du$，得到参考值 $I_{ref}$。\n2.  **计算近似值**：对于每个指定的节点数 $n$，获取对应的高斯-埃尔米特节点 $u_i$ 和权重 $w_i$。使用上述求和公式计算积分的近似值 $I_{GH}$。\n3.  **计算误差**：计算相对误差 $E_{rel} = |(I_{GH} - I_{ref}) / I_{ref}|$。\n4.  **确定最小节点数**：\n    a. 对于每个给定的 $\\Lambda$ 值，按升序遍历节点数 $n \\in \\{4, 8, 16, 32, 64\\}$。\n    b. 对于每个 $n$，计算在所有指定的 $\\delta$ 值上的最大相对误差 $E_{max} = \\max_{\\delta} \\{E_{rel}\\}$。\n    c. 找到第一个使 $E_{max}$ 小于容差 $\\varepsilon = 10^{-8}$ 的 $n$ 值。这个 $n$ 就是该 $\\Lambda$ 所需的最小节点数。\n    d. 如果遍历完所有 $n$ 值后仍未达到容差，则根据题目要求，返回集合中最大的 $n$ 值（即64）。\n\n为保证数值稳定性，计算费米-狄拉克分布项 $1/(1+e^y)$ 时应使用能够处理大指数的函数（如 `scipy.special.expit(-y)`）以避免浮点溢出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\nfrom scipy.special import expit\n\ndef solve():\n    \"\"\"\n    Computes the smallest number of Gauss-Hermite nodes to achieve a specified\n    tolerance for the Marcus-Hush-Chidsey integral.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = {\n        'Lambda_vals': [0.5, 2.0, 20.0, 50.0],\n        'delta_vals': [-10.0, -2.0, 0.0, 2.0, 10.0],\n        'n_vals': [4, 8, 16, 32, 64],\n        'epsilon': 1e-8\n    }\n\n    Lambda_vals = test_cases['Lambda_vals']\n    delta_vals = test_cases['delta_vals']\n    n_vals = test_cases['n_vals']\n    epsilon = test_cases['epsilon']\n    \n    results = []\n\n    # The function g(u) from the derivation: g(u) = 2*sqrt(L) / (1 + exp(2*sqrt(L)*u + d))\n    # We use scipy.special.expit(-x) for the numerically stable calculation of 1/(1+exp(x)).\n    def g_func(u, delta, Lambda):\n        sqrt_Lambda = np.sqrt(Lambda)\n        arg = 2 * sqrt_Lambda * u + delta\n        return 2 * sqrt_Lambda * expit(-arg)\n\n    # The full integrand for the reference calculation: integrand(u) = exp(-u^2) * g(u)\n    def integrand_ref(u, delta, Lambda):\n        return np.exp(-u**2) * g_func(u, delta, Lambda)\n\n    # Loop over each reorganization energy Lambda\n    for Lambda in Lambda_vals:\n        # Default to the largest n as per instructions, if tolerance is not met\n        smallest_n = n_vals[-1]\n\n        # Loop over the number of nodes n to find the smallest that meets the tolerance\n        for n in n_vals:\n            # Get Gauss-Hermite nodes (u_i) and weights (w_i) for the weight function exp(-x^2)\n            nodes, weights = np.polynomial.hermite.hermgauss(n)\n            \n            max_relative_error = 0.0\n\n            # Loop over the driving parameter delta to find the max relative error for this (Lambda, n) pair\n            for delta in delta_vals:\n                # 1. Calculate the high-accuracy reference integral using a standard library routine.\n                # The integral is of the form int(exp(-u^2)*g(u) du) from -inf to inf.\n                try:\n                    I_ref, _ = integrate.quad(integrand_ref, -np.inf, np.inf, args=(delta, Lambda))\n                except Exception as e:\n                    # In case of integration failure, treat error as infinite to discard the 'n' value.\n                    max_relative_error = np.inf\n                    break\n                \n                # The integrand is strictly positive, so I_ref should be > 0.\n                # A zero or negative value indicates a numerical issue.\n                if I_ref = 0.0:\n                    relative_error = np.inf\n                else:\n                    # 2. Calculate the Gauss-Hermite approximation: I_gh = sum(w_i * g(u_i))\n                    g_values_at_nodes = g_func(nodes, delta, Lambda)\n                    I_gh = np.sum(weights * g_values_at_nodes)\n\n                    # 3. Calculate the relative error\n                    relative_error = np.abs((I_gh - I_ref) / I_ref)\n                \n                # Update the maximum relative error found for the current n\n                if relative_error > max_relative_error:\n                    max_relative_error = relative_error\n\n            # 4. Check if the tolerance is met for this n. If so, it's the smallest qualifying n\n            # because we are iterating n in increasing order.\n            if max_relative_error  epsilon:\n                smallest_n = n\n                break  # Exit the loop over n, as we have found our answer for this Lambda\n\n        results.append(smallest_n)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}