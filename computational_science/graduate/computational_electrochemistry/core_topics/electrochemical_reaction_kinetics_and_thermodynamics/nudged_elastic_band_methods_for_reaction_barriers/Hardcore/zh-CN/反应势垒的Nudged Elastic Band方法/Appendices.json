{
    "hands_on_practices": [
        {
            "introduction": "任何微动弹性带（NEB）计算的收敛性在很大程度上取决于初始路径的质量。一个好的初始猜测可以显著减少达到收敛所需的计算工作量。本练习将简单的线性笛卡尔插值与更先进的图像依赖对势（IDPP）方法进行比较，让您通过量化初始垂直于路径的力的减小程度，亲手体验并理解一个高质量初始路径的重要性 ()。",
            "id": "4254438",
            "problem": "考虑一个与计算电化学相关的最小吸附反应：一个位置向量为 $\\mathbf{r} \\in \\mathbb{R}^3$ 的吸附质粒子接近一个由位于 $\\mathbf{s}_1$ 和 $\\mathbf{s}_2$ 的两个固定原子组成的刚性表面。物理势能被建模为吸附质与每个表面原子之间的两个莫尔斯相互作用之和，不考虑吸附质-吸附质或表面-表面的贡献。设吸附质与表面原子 $j \\in \\{1,2\\}$ 之间的莫尔斯势为\n$$\nV_j(R_j) = D_j\\left[\\left(1 - e^{-a_j (R_j - r_{0,j})}\\right)^2 - 1\\right],\n$$\n其中 $R_j = \\|\\mathbf{r} - \\mathbf{s}_j\\|$，$D_j$ 是以电子伏特 (eV) 为单位的势阱深度，$a_j$ 是以埃的倒数 ($\\text{Å}^{-1}$) 为单位的范围参数，$r_{0,j}$ 是以埃 ($\\text{Å}$) 为单位的平衡键长。总势能为 $E(\\mathbf{r}) = V_1(R_1) + V_2(R_2)$。\n\n你的任务是编写一个完整的、可运行的程序，为微动弹性带 (NEB) 方法构建两条初始路径：一条通过线性笛卡尔插值，另一条通过依赖于镜像的对势 (IDPP) 方法。然后，量化与线性插值相比，IDPP方法在初始NEB垂直力上实现的减小量。该减小量必须报告为IDPP初始化路径的垂直力大小的均方根 (RMS) 与线性插值路径的均方根之比。\n\n使用以下定义和要求：\n\n- 构建一条由 $N$ 个镜像组成的离散路径 $\\{\\mathbf{r}_0, \\mathbf{r}_1, \\ldots, \\mathbf{r}_{N-1}\\}$，其端点 $\\mathbf{r}_0$ (初始态) 和 $\\mathbf{r}_{N-1}$ (末态) 是固定的。镜像是根据路径参数 $s_i = i/(N-1)$ (其中 $i = 0, \\ldots, N-1$) 排序的。\n- 对于微动弹性带 (NEB) 方法，镜像 $i$ (不包括端点) 处的垂直力定义为将物理力 $-\\nabla E(\\mathbf{r}_i)$ 分解为平行于和垂直于局部切线 $\\boldsymbol{\\tau}_i$ 的分量。使用对称切线\n$$\n\\boldsymbol{\\tau}_i = \\frac{\\mathbf{r}_{i+1} - \\mathbf{r}_{i-1}}{\\|\\mathbf{r}_{i+1} - \\mathbf{r}_{i-1}\\|},\n$$\n并将力的垂直分量定义为\n$$\n\\mathbf{F}_{\\perp}(\\mathbf{r}_i) = -\\nabla E(\\mathbf{r}_i) + \\left[\\nabla E(\\mathbf{r}_i) \\cdot \\boldsymbol{\\tau}_i\\right]\\boldsymbol{\\tau}_i.\n$$\n计算所有非端点镜像的垂直力大小的均方根 (RMS)：\n$$\nF_{\\text{RMS}} = \\sqrt{\\frac{1}{N-2}\\sum_{i=1}^{N-2} \\|\\mathbf{F}_{\\perp}(\\mathbf{r}_i)\\|^2 }.\n$$\n- 对于线性笛卡尔插值，将中间镜像设置为\n$$\n\\mathbf{r}_i^{\\text{lin}} = (1 - s_i)\\,\\mathbf{r}_0 + s_i\\,\\mathbf{r}_{N-1}.\n$$\n- 对于依赖于镜像的对势 (IDPP) 方法，为每个镜像和每个吸附质-表面原子对构建目标距离，\n$$\nR_{j}^{\\text{target}}(s_i) = (1 - s_i)\\,R_{j}(\\mathbf{r}_0) + s_i\\,R_{j}(\\mathbf{r}_{N-1}),\n$$\n并将所有中间镜像（端点固定）的IDPP目标函数定义为\n$$\n\\Phi = \\sum_{i=1}^{N-2} \\sum_{j=1}^{2} w(R_{j}(\\mathbf{r}_i))\\left(R_{j}(\\mathbf{r}_i) - R_{j}^{\\text{target}}(s_i)\\right)^2,\n$$\n权重为 $w(R) = R^{-p}$，其中 $p > 0$ 是给定的指数。通过最小化 $\\Phi$ (关于中间镜像的位置 $\\mathbf{r}_i$，其中 $i=1,\\ldots,N-2$，同时保持 $\\mathbf{r}_0$ 和 $\\mathbf{r}_{N-1}$ 固定) 来获得IDPP初始化的路径 $\\{\\mathbf{r}_i^{\\text{IDPP}}\\}$。\n- 推导并实现物理势能 $E(\\mathbf{r})$ 关于 $\\mathbf{r}$ 的梯度，用于计算 $\\mathbf{F}_{\\perp}(\\mathbf{r}_i)$。\n- 推导并实现IDPP目标函数 $\\Phi$ 关于 $\\mathbf{r}_i$ 的梯度以进行优化。您必须将 $w(R)$ 视为 $R$ 的函数，即在梯度中包含 $\\mathrm{d}w/\\mathrm{d}R$。\n- 所有能量单位必须是电子伏特 (eV)，所有长度单位必须是埃 ($\\text{Å}$)，所有力的单位必须是 $\\text{eV}/\\text{Å}$。将最终报告的比率表示为无单位的小数，四舍五入到六位小数。\n\n测试套件的固定表面原子位置、初始和最终吸附质位置以及参数值如下所示。对于每个测试用例，计算线性和IDPP路径的RMS垂直力，并报告减小比率 $F_{\\text{RMS}}^{\\text{IDPP}} / F_{\\text{RMS}}^{\\text{lin}}$。\n\n几何结构和端点：\n- 表面原子1：$\\mathbf{s}_1 = (0, 0, 0)$。\n- 表面原子2：$\\mathbf{s}_2 = (d, 0, 0)$，其中 $d$ 在每个测试用例中指定。\n- 初始吸附质位置：$\\mathbf{r}_0 = \\left(\\frac{d}{2}, 0, z_{\\text{init}}\\right)$。\n- 末态吸附质位置：$\\mathbf{r}_{N-1} = \\left(0, 0, z_{\\text{ads}}\\right)$。\n\n测试套件 (每行定义一个测试用例，参数顺序为：$N$, $d$ ($\\text{Å}$), $z_{\\text{init}}$ ($\\text{Å}$), $z_{\\text{ads}}$ ($\\text{Å}$), $D_1$ (eV), $a_1$ ($\\text{Å}^{-1}$), $r_{0,1}$ ($\\text{Å}$), $D_2$ (eV), $a_2$ ($\\text{Å}^{-1}$), $r_{0,2}$ ($\\text{Å}$), $p$, $\\text{IDPP\\_iterations}$, $\\alpha$):\n1. $N=7$, $d=2.5$, $z_{\\text{init}}=5.0$, $z_{\\text{ads}}=1.2$, $D_1=0.8$, $a_1=2.0$, $r_{0,1}=1.2$, $D_2=0.4$, $a_2=1.5$, $r_{0,2}=1.4$, $p=2$, $\\text{IDPP\\_iterations}=400$, $\\alpha=0.10$。\n2. $N=3$, $d=2.5$, $z_{\\text{init}}=5.0$, $z_{\\text{ads}}=1.2$, $D_1=0.8$, $a_1=2.0$, $r_{0,1}=1.2$, $D_2=0.4$, $a_2=1.5$, $r_{0,2}=1.4$, $p=2$, $\\text{IDPP\\_iterations}=200$, $\\alpha=0.10$。\n3. $N=15$, $d=2.5$, $z_{\\text{init}}=7.0$, $z_{\\text{ads}}=1.1$, $D_1=0.9$, $a_1=2.2$, $r_{0,1}=1.1$, $D_2=0.5$, $a_2=1.6$, $r_{0,2}=1.3$, $p=2$, $\\text{IDPP\\_iterations}=600$, $\\alpha=0.08$。\n4. $N=7$, $d=3.0$, $z_{\\text{init}}=5.5$, $z_{\\text{ads}}=1.3$, $D_1=0.7$, $a_1=1.8$, $r_{0,1}=1.2$, $D_2=0.6$, $a_2=1.7$, $r_{0,2}=1.4$, $p=4$, $\\text{IDPP\\_iterations}=500$, $\\alpha=0.08$。\n\n您的程序必须：\n- 实现两条初始路径的构建。\n- 使用基于梯度的更新和固定端点来优化IDPP路径，直到达到最大迭代次数或满足一个小的容差为止；如果IDPP目标函数增加，则使用回溯法减小步长 $\\alpha$。\n- 为每个测试用例计算两条路径的NEB垂直力和RMS大小。\n- 生成单行输出，其中包含所有测试用例的减小比率，形式为用方括号括起来的逗号分隔列表，每个比率格式化为六位小数（例如，“[0.732145,0.854321,0.621000,0.790123]”）。\n\n所有数值输出必须是表示 $F_{\\text{RMS}}^{\\text{IDPP}} / F_{\\text{RMS}}^{\\text{lin}}$ 的无单位小数，四舍五入到六位小数。如果出现角度（应该不会出现），则必须以弧度为单位。不允许使用百分比；任何分数量都应表示为小数。",
            "solution": "该问题要求比较微动弹性带 (NEB) 路径的两种初始化方法：线性笛卡尔插值和依赖于镜像的对势 (IDPP) 方法。该比较基于初始均方根 (RMS) 垂直力，这是一个关键指标，表明初始路径与最小能量路径的接近程度。较低的初始垂直力通常会导致NEB优化更快地收敛。\n\n该系统由一个位于位置 $\\mathbf{r}$ 的吸附质粒子与一个由两个位于固定位置 $\\mathbf{s}_1$ 和 $\\mathbf{s}_2$ 的原子组成的刚性表面相互作用。总势能 $E(\\mathbf{r})$ 是两个莫尔斯势之和，每个势对应一个吸附质-表面原子对：\n$$\nE(\\mathbf{r}) = V_1(R_1) + V_2(R_2)\n$$\n其中 $R_j = \\|\\mathbf{r} - \\mathbf{s}_j\\|$ 是吸附质与表面原子 $j$ 之间的距离，莫尔斯势 $V_j$ 由下式给出\n$$\nV_j(R_j) = D_j\\left[\\left(1 - e^{-a_j (R_j - r_{0,j})}\\right)^2 - 1\\right].\n$$\n在此，$D_j$、$a_j$ 和 $r_{0,j}$ 分别是原子对 $j$ 的势阱深度、范围参数和平衡键长。\n\n首先，我们必须推导势能的解析梯度 $\\nabla E(\\mathbf{r})$，这是计算物理力 $\\mathbf{F}(\\mathbf{r}) = -\\nabla E(\\mathbf{r})$ 所必需的。使用链式法则：\n$$\n\\nabla E(\\mathbf{r}) = \\sum_{j=1}^{2} \\nabla V_j(R_j) = \\sum_{j=1}^{2} \\frac{\\mathrm{d}V_j}{\\mathrm{d}R_j} \\nabla R_j.\n$$\n距离函数的梯度为 $\\nabla R_j = \\nabla \\|\\mathbf{r} - \\mathbf{s}_j\\| = \\frac{\\mathbf{r} - \\mathbf{s}_j}{\\|\\mathbf{r} - \\mathbf{s}_j\\|} = \\frac{\\mathbf{r} - \\mathbf{s}_j}{R_j}$。\n莫尔斯势对距离的导数是：\n$$\n\\frac{\\mathrm{d}V_j}{\\mathrm{d}R_j} = D_j \\cdot 2 \\left(1 - e^{-a_j (R_j - r_{0,j})}\\right) \\cdot \\left(-e^{-a_j (R_j - r_{0,j})}\\right) \\cdot (-a_j) = 2a_j D_j \\left(e^{-a_j(R_j - r_{0,j})} - e^{-2a_j(R_j - r_{0,j})}\\right).\n$$\n结合这些，总势能的梯度为：\n$$\n\\nabla E(\\mathbf{r}) = \\sum_{j=1}^{2} \\left[ 2a_j D_j \\left(e^{-a_j(R_j - r_{0,j})} - e^{-2a_j(R_j - r_{0,j})}\\right) \\frac{\\mathbf{r} - \\mathbf{s}_j}{R_j} \\right].\n$$\n\n反应路径被离散化为 $N$ 个镜像 $\\{\\mathbf{r}_0, \\mathbf{r}_1, \\ldots, \\mathbf{r}_{N-1}\\}$，其中 $\\mathbf{r}_0$ 和 $\\mathbf{r}_{N-1}$ 是固定的。对于任何中间镜像 $\\mathbf{r}_i$ ($i \\in \\{1, \\ldots, N-2\\}$)，力 $\\mathbf{F}_i = -\\nabla E(\\mathbf{r}_i)$ 被分解为平行于路径和垂直于路径的分量。局部路径方向由归一化切向量 $\\boldsymbol{\\tau}_i$ 估计。使用指定的对称切线：\n$$\n\\boldsymbol{\\tau}_i = \\frac{\\mathbf{r}_{i+1} - \\mathbf{r}_{i-1}}{\\|\\mathbf{r}_{i+1} - \\mathbf{r}_{i-1}\\|}.\n$$\n力的垂直分量（NEB方法旨在将其置零）是通过从总力中减去平行分量得到的：\n$$\n\\mathbf{F}_{\\perp}(\\mathbf{r}_i) = \\mathbf{F}_i - (\\mathbf{F}_i \\cdot \\boldsymbol{\\tau}_i)\\boldsymbol{\\tau}_i.\n$$\n垂直力的总体大小通过所有中间镜像上的RMS值来量化：\n$$\nF_{\\text{RMS}} = \\sqrt{\\frac{1}{N-2}\\sum_{i=1}^{N-2} \\|\\mathbf{F}_{\\perp}(\\mathbf{r}_i)\\|^2 }.\n$$\n\n两种路径初始化方法是：\n1.  **线性笛卡尔插值**：这是最简单的方法，其中中间镜像被放置在连接端点的直线上：\n    $$\n    \\mathbf{r}_i^{\\text{lin}} = (1 - s_i)\\mathbf{r}_0 + s_i\\mathbf{r}_{N-1}, \\quad \\text{where } s_i = i/(N-1).\n    $$\n    这种方法通常会生成化学上不合理的路径，穿过高能区域，导致较大的初始力。\n\n2.  **依赖于镜像的对势 (IDPP)**：该方法通过插值内坐标（原子间距离）而不是笛卡尔坐标来生成物理上更合理的路径。首先，通过线性插值端点距离，为每个镜像 $i$ 和吸附质-表面原子对 $j$ 定义目标距离 $R_{j}^{\\text{target}}(s_i)$：\n    $$\n    R_{j}^{\\text{target}}(s_i) = (1 - s_i) R_j(\\mathbf{r}_0) + s_i R_j(\\mathbf{r}_{N-1}).\n    $$\n    然后构造一个目标函数 $\\Phi$ 来惩罚路径中实际距离与这些目标距离的平方偏差：\n    $$\n    \\Phi(\\{\\mathbf{r}_i\\}_{i=1}^{N-2}) = \\sum_{i=1}^{N-2} \\sum_{j=1}^{2} w(R_{j}(\\mathbf{r}_i))\\left(R_{j}(\\mathbf{r}_i) - R_{j}^{\\text{target}}(s_i)\\right)^2.\n    $$\n    权重函数 $w(R) = R^{-p}$ 给予更短、更强的键更大的重要性。IDPP路径 $\\{\\mathbf{r}_i^{\\text{IDPP}}\\}$ 是通过最小化 $\\Phi$ (关于中间镜像的位置 $\\{\\mathbf{r}_i\\}_{i=1}^{N-2}$) 获得的。我们使用梯度下降法进行此最小化。$\\Phi$ 相对于单个镜像 $\\mathbf{r}_k$ 坐标的梯度是：\n    $$\n    \\frac{\\partial \\Phi}{\\partial \\mathbf{r}_k} = \\nabla_{\\mathbf{r}_k} \\left[ \\sum_{j=1}^{2} w(R_{j}(\\mathbf{r}_k))\\left(R_{j}(\\mathbf{r}_k) - R_{j}^{\\text{target}}(s_k)\\right)^2 \\right].\n    $$\n    令 $g_j(R_j) = w(R_j)(R_j - R_j^{\\text{target}})^2 = R_j^{-p}(R_j - R_j^{\\text{target}})^2$。梯度为 $\\frac{\\partial \\Phi}{\\partial \\mathbf{r}_k} = \\sum_{j=1}^{2} \\frac{\\mathrm{d}g_j}{\\mathrm{d}R_j} \\nabla_{\\mathbf{r}_k} R_j$。\n    导数 $\\frac{\\mathrm{d}g_j}{\\mathrm{d}R_j}$ 使用乘法法则求得：\n    $$\n    \\frac{\\mathrm{d}g_j}{\\mathrm{d}R_j} = \\frac{\\mathrm{d}w}{\\mathrm{d}R_j}(R_j - R_j^{\\text{target}})^2 + w(R_j) \\cdot 2(R_j - R_j^{\\text{target}})\n    = -p R_j^{-p-1}(R_j - R_j^{\\text{target}})^2 + 2 R_j^{-p}(R_j - R_j^{\\text{target}}).\n    $$\n    提出公因子后，我们得到：\n    $$\n    \\frac{\\mathrm{d}g_j}{\\mathrm{d}R_j} = R_j^{-p-1}(R_j - R_j^{\\text{target}}) \\left[ -p(R_j - R_j^{\\text{target}}) + 2R_j \\right] = R_j^{-p-1}(R_j - R_j^{\\text{target}}) \\left[ (2-p)R_j + pR_j^{\\text{target}} \\right].\n    $$\n    与 $\\nabla_{\\mathbf{r}_k} R_j = (\\mathbf{r}_k - \\mathbf{s}_j) / R_j$ 结合，最终的梯度表达式为：\n    $$\n    \\frac{\\partial \\Phi}{\\partial \\mathbf{r}_k} = \\sum_{j=1}^{2} R_j^{-p-2}(\\mathbf{r}_k) \\left(R_j(\\mathbf{r}_k) - R_{j}^{\\text{target}}(s_k)\\right) \\left[ (2-p)R_j(\\mathbf{r}_k) + pR_{j}^{\\text{target}}(s_k) \\right] (\\mathbf{r}_k - \\mathbf{s}_j).\n    $$\n    优化的过程是让每个镜像 $\\mathbf{r}_k$ 沿着 $-\\frac{\\partial \\Phi}{\\partial \\mathbf{r}_k}$ 的方向移动。\n\n每个测试用例的总体流程如下：\n1.  定义几何结构：$\\mathbf{s}_1, \\mathbf{s}_2, \\mathbf{r}_0, \\mathbf{r}_{N-1}$。\n2.  构建线性插值路径 $\\{\\mathbf{r}_i^{\\text{lin}}\\}$。\n3.  计算该路径的 $F_{\\text{RMS}}^{\\text{lin}}$。\n4.  将IDPP路径初始化为线性路径。\n5.  使用带回溯的梯度下降法迭代最小化IDPP目标函数 $\\Phi$，以找到 $\\{\\mathbf{r}_i^{\\text{IDPP}}\\}$。\n6.  计算优化后的IDPP路径的 $F_{\\text{RMS}}^{\\text{IDPP}}$。\n7.  计算并报告比率 $F_{\\text{RMS}}^{\\text{IDPP}} / F_{\\text{RMS}}^{\\text{lin}}$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # N, d, z_init, z_ads, D1, a1, r01, D2, a2, r02, p, IDPP_iterations, alpha\n        (7, 2.5, 5.0, 1.2, 0.8, 2.0, 1.2, 0.4, 1.5, 1.4, 2, 400, 0.10),\n        (3, 2.5, 5.0, 1.2, 0.8, 2.0, 1.2, 0.4, 1.5, 1.4, 2, 200, 0.10),\n        (15, 2.5, 7.0, 1.1, 0.9, 2.2, 1.1, 0.5, 1.6, 1.3, 2, 600, 0.08),\n        (7, 3.0, 5.5, 1.3, 0.7, 1.8, 1.2, 0.6, 1.7, 1.4, 4, 500, 0.08),\n    ]\n\n    results = []\n    for params in test_cases:\n        N, d, z_init, z_ads, D1, a1, r01, D2, a2, r02, p, idpp_iters, alpha = params\n        s1 = np.array([0.0, 0.0, 0.0])\n        s2 = np.array([d, 0.0, 0.0])\n        r0 = np.array([d / 2.0, 0.0, z_init])\n        rN_1 = np.array([0.0, 0.0, z_ads])\n\n        # 1. Linear Cartesian Interpolation Path\n        path_lin = np.zeros((N, 3))\n        path_lin[0], path_lin[-1] = r0, rN_1\n        for i in range(1, N - 1):\n            s_i = i / (N - 1)\n            path_lin[i] = (1 - s_i) * r0 + s_i * rN_1\n\n        # 2. Image-Dependent Pair Potential (IDPP) Path\n        path_idpp = path_lin.copy()\n        \n        R1_0 = np.linalg.norm(r0 - s1)\n        R2_0 = np.linalg.norm(r0 - s2)\n        R1_N_1 = np.linalg.norm(rN_1 - s1)\n        R2_N_1 = np.linalg.norm(rN_1 - s2)\n\n        target_dists = np.zeros((N, 2))\n        for i in range(N):\n            s_i = i / (N - 1)\n            target_dists[i, 0] = (1 - s_i) * R1_0 + s_i * R1_N_1\n            target_dists[i, 1] = (1 - s_i) * R2_0 + s_i * R2_N_1\n\n        s_atoms = [s1, s2]\n        idpp_params = {\n            'target_dists': target_dists[1:-1],\n            's_atoms': s_atoms,\n            'p': p,\n        }\n\n        # IDPP Optimization\n        for _ in range(idpp_iters):\n            images_to_opt = path_idpp[1:-1]\n            obj_old, grad = idpp_objective_and_gradient(images_to_opt, **idpp_params)\n            \n            # Simple backtracking line search\n            current_alpha = alpha\n            while True:\n                new_images = images_to_opt - current_alpha * grad\n                obj_new, _ = idpp_objective_and_gradient(new_images, **idpp_params)\n                \n                if obj_new  obj_old:\n                    path_idpp[1:-1] = new_images\n                    break\n                \n                current_alpha /= 2.0\n                if current_alpha  1e-12:  # Stop if step size is too small\n                    break\n\n        # 3. Calculate RMS perpendicular forces\n        force_params = {'s1': s1, 's2': s2, 'D1': D1, 'a1': a1, 'r01': r01,\n                        'D2': D2, 'a2': a2, 'r02': r02}\n\n        rms_force_lin = calculate_rms_perp_force(path_lin, **force_params)\n        rms_force_idpp = calculate_rms_perp_force(path_idpp, **force_params)\n        \n        if rms_force_lin == 0:\n            ratio = 1.0 if rms_force_idpp == 0 else float('inf')\n        else:\n            ratio = rms_force_idpp / rms_force_lin\n        \n        results.append(f\"{ratio:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef potential_gradient(r, s1, s2, D1, a1, r01, D2, a2, r02):\n    \"\"\"Calculates the gradient of the total potential energy at position r.\"\"\"\n    params = [(s1, D1, a1, r01), (s2, D2, a2, r02)]\n    total_grad = np.zeros(3)\n\n    for s_j, D_j, a_j, r0_j in params:\n        vec_r_sj = r - s_j\n        R_j = np.linalg.norm(vec_r_sj)\n        if R_j  1e-9: continue # Avoid division by zero\n\n        exp_term1 = np.exp(-a_j * (R_j - r0_j))\n        exp_term2 = np.exp(-2 * a_j * (R_j - r0_j))\n\n        dV_dR = 2 * a_j * D_j * (exp_term1 - exp_term2)\n        grad_Vj = dV_dR * (vec_r_sj / R_j)\n        total_grad += grad_Vj\n        \n    return total_grad\n\ndef calculate_rms_perp_force(path, **kwargs):\n    \"\"\"Calculates the RMS perpendicular force for a given path.\"\"\"\n    N = path.shape[0]\n    if N = 2:\n        return 0.0\n\n    sum_sq_force_perp = 0.0\n    for i in range(1, N - 1):\n        ri_minus_1, ri, ri_plus_1 = path[i - 1], path[i], path[i + 1]\n        \n        tangent_vec = ri_plus_1 - ri_minus_1\n        norm_tangent_vec = np.linalg.norm(tangent_vec)\n        \n        if norm_tangent_vec  1e-9:\n            tau_i = np.zeros(3)\n        else:\n            tau_i = tangent_vec / norm_tangent_vec\n            \n        force = -potential_gradient(ri, **kwargs)\n        \n        force_parallel_mag = np.dot(force, tau_i)\n        force_parallel = force_parallel_mag * tau_i\n        force_perp = force - force_parallel\n        \n        sum_sq_force_perp += np.linalg.norm(force_perp)**2\n\n    return np.sqrt(sum_sq_force_perp / (N - 2))\n\ndef idpp_objective_and_gradient(images, target_dists, s_atoms, p):\n    \"\"\"Calculates the IDPP objective and its gradient for intermediate images.\"\"\"\n    num_images = images.shape[0]\n    gradient = np.zeros_like(images)\n    objective = 0.0\n\n    s1, s2 = s_atoms\n    s_j_list = [s1, s2]\n\n    for i in range(num_images):\n        r_k = images[i]\n        \n        for j in range(2):\n            s_j = s_j_list[j]\n            R_k_j = np.linalg.norm(r_k - s_j)\n            R_target_k_j = target_dists[i, j]\n            \n            if R_k_j  1e-9: continue\n\n            # Objective function term\n            diff = R_k_j - R_target_k_j\n            weight = R_k_j**(-p)\n            objective += weight * (diff**2)\n            \n            # Gradient term\n            # Derivation: grad = R_j^(-p-2) * (R_j - R_j_target) * [(2-p)R_j + p*R_j_target] * (r_k - s_j)\n            term1 = R_k_j**(-p - 2)\n            term2 = diff\n            term3 = (2 - p) * R_k_j + p * R_target_k_j\n            vec_rk_sj = r_k - s_j\n            \n            gradient[i] += term1 * term2 * term3 * vec_rk_sj\n\n    return objective, gradient\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在生成了合理的初始路径后，下一步是执行核心的NEB优化。本练习深入探讨了NEB算法的实现细节，您将会在一个经典的Müller-Brown势能面上运行该方法。通过系统地改变连接图像的弹簧常数 $k$，您将分析这一关键参数如何影响最小能量路径（MEP）的稳定性和计算得到的能垒的准确性 ()。",
            "id": "4254377",
            "problem": "考虑一个二维势能面上的反应坐标的离散路径表示，该路径在微动弹性带 (Nudged Elastic Band, NEB) 方法中被建模为一组由弹簧连接的映像点。设势能面由 Müller–Brown 函数定义，该函数是类高斯项的总和，并广泛用于最小能量路径算法的基准测试。这些映像点由位置 $\\mathbf{r}_i = (x_i, y_i)$ 表示，其中 $i = 0, 1, \\dots, N-1$，其端点固定在反应物极小值 $\\mathbf{r}_0$ 和产物极小值 $\\mathbf{r}_{N-1}$。每个中间映像点的 NEB 力是通过移除真实力（势的负梯度）的平行分量并沿弹性带添加一个弹簧力来构造的，以保持均匀间距。能垒高度定义为沿收敛的 NEB 路径的最大能量减去反应物极小值处的能量。在计算电化学的背景下，零外加电势下计算的能垒是一个无量纲量，表示由特征能量尺度归一化的能量差。\n\n从以下基本原理出发：\n- 映像点上的保守力由 $\\mathbf{F}^{\\text{true}}(\\mathbf{r}) = - \\nabla V(\\mathbf{r})$ 给出，其中 $V(\\mathbf{r})$ 是势能函数。\n- NEB 投影移除 $\\mathbf{F}^{\\text{true}}$ 平行于离散带局部切线 $\\boldsymbol{\\tau}_i$ 的分量，仅保留垂直分量 $\\mathbf{F}^{\\perp}_i = \\mathbf{F}^{\\text{true}}_i - (\\mathbf{F}^{\\text{true}}_i \\cdot \\boldsymbol{\\tau}_i)\\boldsymbol{\\tau}_i$。\n- 弹簧力仅沿切线方向作用，其大小由弹簧常数 $k$ 控制。\n\n在由下式定义的 Müller–Brown 势能面上实现 NEB 方法\n$$\nV(x, y) = \\sum_{j=1}^{4} A_j \\exp\\left(a_j(x - x_j)^2 + b_j(x - x_j)(y - y_j) + c_j(y - y_j)^2\\right),\n$$\n参数为\n$$\nA = [-200, -100, -170, 15], \\quad a = [-1, -1, -6.5, 0.7], \\quad b = [0, 0, 11, 0.6], \\quad c = [-10, -10, -6.5, 0.7],\n$$\n中心点为\n$$\n(x_j, y_j) = [(1, 0), (0, 0.5), (-0.5, 1.5), (-1, 1)]。\n$$\n所有能量和距离均为无量纲。初始和最终端点 $\\mathbf{r}_0$ 和 $\\mathbf{r}_{N-1}$ 必须通过从已知极小值附近的合理猜测点开始对 $V(x, y)$ 进行局域最小化来获得。\n\n使用一个标准的 NEB 离散化，包含 $N$ 个映像点，使得端点固定在最小化的反应物和产物位置，内部映像点通过根据 NEB 力对其位置进行迭代更新来弛豫。使用一种基于相邻映像点能量的改进切线定义，以避免最高能量区域附近的扭结。为获得准确的参考能垒，使用爬山映像点 NEB (Climbing-Image NEB, CI-NEB) 变体，其中能量最高的映像点移除弹簧力并反转真实力的平行分量，从而收敛到鞍点。\n\n通过对一组 $k$ 值运行 NEB，对能垒高度作为弹簧常数 $k$ 的函数进行灵敏度分析，并确定哪些 $k$ 值能产生稳定且准确的最小能量路径 (MEP)。对于稳定性和准确性，使用以下标准：\n- 最终映像点间距的变异系数 $\\mathrm{CV} = \\sigma_d / \\bar{d}$ 必须小于一个阈值，其中 $d_i = \\|\\mathbf{r}_{i+1} - \\mathbf{r}_i\\|$ 对于 $i = 0, \\dots, N-2$，$\\bar{d}$ 是平均间距，$\\sigma_d$ 是间距的标准差。\n- 最终迭代时最大垂直真实力范数 $\\max_i \\|\\mathbf{F}^{\\perp}_i\\|$ 必须小于一个力容差阈值。\n- 相对于 CI-NEB 参考能垒的能垒高度绝对误差必须小于一个能量容差阈值。\n\n采用零外加电极电势，因此不向 $V(x, y)$ 添加额外的倾斜项；所有能量差均以无量纲单位报告。除非另有说明，所有 NEB 运行使用以下数值配置：映像点数 $N$ 等于 $16$，最大迭代次数等于 $3000$，时间步长等于 $0.02$，变异系数阈值等于 $0.30$，力容差等于 $0.005$，能垒能量容差等于 $0.10$。通过从猜测点 $(x, y) = (-0.55, 1.45)$ 和 $(x, y) = (0.62, 0.03)$ 开始进行局域最小化，分别获得反应物和产物极小值。\n\n构建一个程序，对于以下测试集中的每个弹簧常数 $k$，运行 NEB 并根据上述标准评估所得路径是否既稳定又准确：\n- 测试用例 1：$k = 0.005$，\n- 测试用例 2：$k = 0.020$，\n- 测试用例 3：$k = 0.100$，\n- 测试用例 4：$k = 0.500$，\n- 测试用例 5：$k = 1.000$，\n- 测试用例 6：$k = 2.000$。\n\n对于参考能垒，使用 $k_{\\text{ref}} = 0.100$ 和相同的数值配置进行一次爬山映像点 NEB 运行。您的程序的最终输出必须是单行文本，包含一个布尔值列表，按上面列出的顺序指出每个 $k$ 的 NEB 结果是否既稳定又准确，格式化为方括号括起来的逗号分隔列表，例如 $\\left[\\text{True},\\text{False},\\dots\\right]$。不应产生任何其他输出。不使用角度；报告的所有量均为无量纲。输出必须根据此处描述的程序逻辑确定性地生成，无需任何用户输入或外部文件。",
            "solution": "该问题被认为是有效的，因为它提出了一个明确定义的、基于既定科学原理的计算任务。它内容自洽、客观且有科学依据。目标是通过评估针对不同弹簧常数 $k$ 计算出的最小能量路径 (MEP) 的稳定性和准确性，对微动弹性带 (NEB) 方法进行灵敏度分析。该分析在基准 Müller–Brown 势能面上进行。\n\n解决方案分几个阶段进行：\n1. 定义势能面 (PES) 及其梯度。\n2. 确定固定的路径端点（反应物和产物极小值）。\n3. 实现标准 NEB 和爬山映像点 NEB (CI-NEB) 算法。\n4. 使用 CI-NEB 计算高精度参考反应能垒。\n5. 对一系列弹簧常数 $k$ 执行标准 NEB 计算，并根据指定标准评估结果。\n\n### 1. 势能面：Müller–Brown 势\n二维 PES 由 Müller–Brown 函数给出：\n$$\nV(x, y) = \\sum_{j=1}^{4} A_j \\exp\\left(a_j(x - x_j)^2 + b_j(x - x_j)(y - y_j) + c_j(y - y_j)^2\\right)\n$$\n参数 $A_j$、$a_j$、$b_j$、$c_j$ 和中心点 $(x_j, y_j)$ 在问题描述中提供。位于位置 $\\mathbf{r}=(x,y)$ 的映像点上的保守力是势的负梯度，$\\mathbf{F}^{\\text{true}}(\\mathbf{r}) = -\\nabla V(\\mathbf{r})$。梯度的分量可解析地导出：\n$$\n\\frac{\\partial V}{\\partial x} = \\sum_{j=1}^{4} A_j e^{E_j(\\mathbf{r})} \\left[ 2a_j(x - x_j) + b_j(y - y_j) \\right]\n$$\n$$\n\\frac{\\partial V}{\\partial y} = \\sum_{j=1}^{4} A_j e^{E_j(\\mathbf{r})} \\left[ b_j(x - x_j) + 2c_j(y - y_j) \\right]\n$$\n其中 $E_j(\\mathbf{r})$ 是第 $j$ 项的指数函数的宗量。\n\n### 2. 端点确定\n反应路径的起始点和终点 $\\mathbf{r}_0$ 和 $\\mathbf{r}_{N-1}$ 对应于 PES 上的局域极小值。通过从初始猜测点 $\\mathbf{r}_{\\text{guess},0} = (-0.55, 1.45)$ 和 $\\mathbf{r}_{\\text{guess},N-1} = (0.62, 0.03)$ 开始执行数值优化（具体为 L-BFGS-B 算法）来找到这些点。这为固定的反应物和产物状态提供了精确的坐标。\n\n### 3. 微动弹性带 (NEB) 方法\nNEB 方法通过弛豫一组由弹簧连接的离散映像点 $\\{\\mathbf{r}_i\\}_{i=0}^{N-1}$ 来找到 MEP。\n\n**初始化**：通过在优化后的端点 $\\mathbf{r}_0$ 和 $\\mathbf{r}_{N-1}$ 之间进行线性插值来创建初始路径：\n$$ \\mathbf{r}_i = \\mathbf{r}_0 + \\frac{i}{N-1}(\\mathbf{r}_{N-1} - \\mathbf{r}_0) \\quad \\text{for } i = 0, \\dots, N-1 $$\n\n**力的计算**：对于每个中间映像点 $\\mathbf{r}_i$ ($i=1, \\dots, N-2$)，计算总 NEB 力 $\\mathbf{F}^{\\text{NEB}}_i$。该力由两部分组成：真实势能力的垂直分量和一个平行的弹簧力。\n- **切线向量**：使用一种“改进的切线”定义来防止扭结。切线 $\\boldsymbol{\\tau}_i$ 根据相邻映像点 $V_{i-1}$ 和 $V_{i+1}$ 的能量来定义。它与指向能量较高邻居的向量对齐，从而促进了路径的平滑表示：\n$$\n\\boldsymbol{\\tau}_i \\propto\n\\begin{cases}\n    \\mathbf{r}_{i+1} - \\mathbf{r}_i  \\text{if } V_{i+1}  V_{i-1} \\\\\n    \\mathbf{r}_i - \\mathbf{r}_{i-1}  \\text{if } V_{i-1}  V_{i+1} \\\\\n    \\mathbf{r}_{i+1} - \\mathbf{r}_{i-1}  \\text{if } V_{i+1} = V_{i-1}\n\\end{cases}\n$$\n所得向量被归一化为单位长度。\n- **力分量**：将真实力 $\\mathbf{F}^{\\text{true}}_i = -\\nabla V(\\mathbf{r}_i)$ 投影到其垂直于 ($\\mathbf{F}^{\\perp}_i$) 和平行于 ($\\mathbf{F}^{\\parallel_{\\text{true}}}_i$) 切线 $\\boldsymbol{\\tau}_i$ 的分量上。\n$$ \\mathbf{F}^{\\perp}_i = \\mathbf{F}^{\\text{true}}_i - (\\mathbf{F}^{\\text{true}}_i \\cdot \\boldsymbol{\\tau}_i)\\boldsymbol{\\tau}_i $$\n弹簧力沿切线方向作用，以保持均匀的映像点间距：\n$$ \\mathbf{F}^{\\parallel_{\\text{spring}}}_i = k (\\|\\mathbf{r}_{i+1} - \\mathbf{r}_i\\| - \\|\\mathbf{r}_i - \\mathbf{r}_{i-1}\\|) \\boldsymbol{\\tau}_i $$\n- **总 NEB 力**：映像点 $i$ 上的总力是这两个分量的和：\n$$ \\mathbf{F}^{\\text{NEB}}_i = \\mathbf{F}^{\\perp}_i + \\mathbf{F}^{\\parallel_{\\text{spring}}}_i $$\n\n**路径优化**：使用一个简单的时间步长为 $\\Delta t = 0.02$ 的欧拉积分方案来迭代更新中间映像点的位置：\n$$ \\mathbf{r}_i(t+\\Delta t) = \\mathbf{r}_i(t) + \\Delta t \\cdot \\mathbf{F}^{\\text{NEB}}_i $$\n此过程重复固定的迭代次数（$3000$ 次）。\n\n### 4. 爬山映像点 NEB (CI-NEB)\n为了获得准确的参考能垒，使用 CI-NEB 变体。在该方法中，能量最高的映像点 $\\mathbf{r}_{i_{\\text{max}}}$ 不受弹簧力的作用。相反，真实力的平行分量被反转，以驱动映像点沿势能面攀升至鞍点。\n$$ \\mathbf{F}^{\\text{CI}}_{i_{\\text{max}}} = \\mathbf{F}^{\\perp}_{i_{\\text{max}}} - \\mathbf{F}^{\\parallel_{\\text{true}}}_{i_{\\text{max}}} = \\mathbf{F}^{\\text{true}}_{i_{\\text{max}}} - 2(\\mathbf{F}^{\\text{true}}_{i_{\\text{max}}} \\cdot \\boldsymbol{\\tau}_{i_{\\text{max}}})\\boldsymbol{\\tau}_{i_{\\text{max}}} $$\n参考能垒 $\\text{Barrier}_{\\text{ref}}$ 计算为收敛后的爬山映像点与反应物之间的能量差：$\\text{Barrier}_{\\text{ref}} = V(\\mathbf{r}_{i_{\\text{max}}}) - V(\\mathbf{r}_0)$。这是在 $k_{\\text{ref}} = 0.100$ 的条件下完成的。\n\n### 5. 稳定性和准确性分析\n对弹簧常数 $k$ 的每个测试值，执行一次标准的 NEB 计算。所得路径根据三个标准进行评估：\n1. **间距稳定性**：映像点间距的变异系数 $\\mathrm{CV} = \\sigma_d / \\bar{d}$ 必须小于 $0.30$。低 CV 值表示路径平滑且均匀分布。\n2. **力收敛**：垂直力分量的最大范数 $\\max_i \\|\\mathbf{F}^{\\perp}_i\\|$ 必须低于 $0.005$ 的容差。这确保了路径已收敛到 MEP，在 MEP 上垂直力为零。\n3. **能垒准确性**：使用当前 $k$ 计算的能垒高度与参考能垒之间的绝对差值 $|\\text{Barrier}(k) - \\text{Barrier}_{\\text{ref}}|$ 必须小于 $0.10$。\n\n当且仅当所有三个标准都满足时，给定的 $k$ 值才被认为产生“稳定且准确”的结果。最终输出是一个布尔值列表，反映了对每个测试的 $k$ 值的此项评估。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# GLOBAL CONSTANTS for Müller-Brown Potential\n# These are defined globally as they are immutable and used by multiple functions.\nA_param = np.array([-200, -100, -170, 15])\na_param = np.array([-1, -1, -6.5, 0.7])\nb_param = np.array([0, 0, 11, 0.6])\nc_param = np.array([-10, -10, -6.5, 0.7])\nX_J_param = np.array([1, 0, -0.5, -1])\nY_J_param = np.array([0, 0.5, 1.5, 1])\n\ndef muller_brown_potential(pos):\n    \"\"\"Calculates the Müller-Brown potential at a given position (x, y).\"\"\"\n    x, y = pos[0], pos[1]\n    value = 0.0\n    for j in range(4):\n        dx = x - X_J_param[j]\n        dy = y - Y_J_param[j]\n        exponent = a_param[j] * dx**2 + b_param[j] * dx * dy + c_param[j] * dy**2\n        value += A_param[j] * np.exp(exponent)\n    return value\n\ndef muller_brown_gradient(pos):\n    \"\"\"Calculates the gradient of the Müller-Brown potential.\"\"\"\n    x, y = pos[0], pos[1]\n    grad = np.zeros(2)\n    for j in range(4):\n        dx = x - X_J_param[j]\n        dy = y - Y_J_param[j]\n        exponent = a_param[j] * dx**2 + b_param[j] * dx * dy + c_param[j] * dy**2\n        prefactor = A_param[j] * np.exp(exponent)\n        \n        grad[0] += prefactor * (2 * a_param[j] * dx + b_param[j] * dy)\n        grad[1] += prefactor * (b_param[j] * dx + 2 * c_param[j] * dy)\n    return grad\n\ndef run_neb(k, is_ci, r0, rN_1, N, max_iter, dt):\n    \"\"\"Runs a Nudged Elastic Band (NEB/CI-NEB) calculation.\"\"\"\n    # 1. Initialize the path by linear interpolation\n    path = np.linspace(r0, rN_1, N)\n    \n    # 2. Iterative optimization loop\n    for _ in range(max_iter):\n        # Calculate energies and true forces for all images at current positions\n        energies = np.array([muller_brown_potential(p) for p in path])\n        true_forces = -np.array([muller_brown_gradient(p) for p in path])\n        \n        # Identify climbing image index if CI-NEB is active\n        climbing_image_index = -1\n        if is_ci:\n            # Add 1 to index to map from slice (1:-1) to full path array\n            climbing_image_index = np.argmax(energies[1:-1]) + 1\n\n        # Calculate tangents and NEB forces for internal images\n        neb_forces = np.zeros_like(path)\n        for i in range(1, N - 1):\n            v_prev, v_next = energies[i-1], energies[i+1]\n            p_prev, p_curr, p_next = path[i-1], path[i], path[i+1]\n            \n            # Improved tangent definition: points towards the higher-energy neighbor globally\n            tangent_vec = np.zeros(2, dtype=float)\n            if v_next > v_prev:\n                tangent_vec = p_next - p_curr\n            elif v_prev > v_next:\n                tangent_vec = p_curr - p_prev\n            else: # v_next == v_prev\n                tangent_vec = p_next - p_prev\n            \n            norm_tangent = np.linalg.norm(tangent_vec)\n            tangent = tangent_vec / norm_tangent if norm_tangent > 1e-9 else np.zeros(2, dtype=float)\n\n            # Calculate force components\n            force_true_i = true_forces[i]\n            force_parallel_mag = np.dot(force_true_i, tangent)\n            force_perp = force_true_i - force_parallel_mag * tangent\n\n            # Assign force based on CI or standard NEB\n            if is_ci and i == climbing_image_index:\n                # Climbing image force: F_true - 2 * F_parallel\n                neb_forces[i] = force_true_i - 2 * force_parallel_mag * tangent\n            else:\n                # Standard NEB Force: F_perp + F_spring_parallel\n                d_next = np.linalg.norm(p_next - p_curr)\n                d_prev = np.linalg.norm(p_curr - p_prev)\n                force_spring_parallel = k * (d_next - d_prev) * tangent\n                neb_forces[i] = force_perp + force_spring_parallel\n        \n        # 3. Update internal image positions using Euler step\n        path[1:-1] += dt * neb_forces[1:-1]\n        \n    return path\n\ndef solve():\n    \"\"\"Main function to execute the NEB sensitivity analysis.\"\"\"\n    # Define problem parameters\n    N = 16\n    MAX_ITERATIONS = 3000\n    TIME_STEP = 0.02\n    CV_THRESHOLD = 0.30\n    FORCE_TOLERANCE = 0.005\n    ENERGY_TOLERANCE = 0.10\n    TEST_K_VALUES = [0.005, 0.020, 0.100, 0.500, 1.000, 2.000]\n    \n    # 1. Find reactant (r0) and product (rN_1) minima using L-BFGS-B\n    r0_guess = np.array([-0.55, 1.45])\n    rN_1_guess = np.array([0.62, 0.03])\n    \n    res_r0 = minimize(muller_brown_potential, r0_guess, jac=muller_brown_gradient, method='L-BFGS-B')\n    r0 = res_r0.x\n    \n    res_rN_1 = minimize(muller_brown_potential, rN_1_guess, jac=muller_brown_gradient, method='L-BFGS-B')\n    rN_1 = res_rN_1.x\n\n    # 2. Calculate reference barrier using Climbing-Image NEB\n    k_ref = 0.100\n    ref_path = run_neb(k_ref, True, r0, rN_1, N, MAX_ITERATIONS, TIME_STEP)\n    ref_energies = np.array([muller_brown_potential(p) for p in ref_path])\n    barrier_ref = np.max(ref_energies) - ref_energies[0]\n    \n    results = []\n    \n    # 3. Perform sensitivity analysis for each test k value\n    for k in TEST_K_VALUES:\n        final_path = run_neb(k, False, r0, rN_1, N, MAX_ITERATIONS, TIME_STEP)\n        \n        # Evaluate stability and accuracy criteria on the final path\n        \n        # Criterion 1: Coefficient of Variation of image spacing\n        diffs = final_path[1:] - final_path[:-1]\n        distances = np.linalg.norm(diffs, axis=1)\n        mean_dist = np.mean(distances)\n        std_dist = np.std(distances)\n        cv = std_dist / mean_dist if mean_dist > 1e-9 else 0.0\n        is_stable_cv = cv  CV_THRESHOLD\n        \n        # Criterion 2: Maximum perpendicular force\n        final_energies = np.array([muller_brown_potential(p) for p in final_path])\n        final_true_forces = -np.array([muller_brown_gradient(p) for p in final_path])\n        max_perp_force = 0.0\n        \n        for i in range(1, N - 1):\n            v_prev, v_next = final_energies[i-1], final_energies[i+1]\n            p_prev, p_curr, p_next = final_path[i-1], final_path[i], final_path[i+1]\n\n            tangent_vec = np.zeros(2, dtype=float)\n            if v_next > v_prev:\n                tangent_vec = p_next - p_curr\n            elif v_prev > v_next:\n                tangent_vec = p_curr - p_prev\n            else:\n                tangent_vec = p_next - p_prev\n            \n            norm_tangent = np.linalg.norm(tangent_vec)\n            tangent = tangent_vec / norm_tangent if norm_tangent > 1e-9 else np.zeros(2, dtype=float)\n\n            force_true_i = final_true_forces[i]\n            force_parallel_mag = np.dot(force_true_i, tangent)\n            perp_force_vec = force_true_i - force_parallel_mag * tangent\n            max_perp_force = max(max_perp_force, np.linalg.norm(perp_force_vec))\n            \n        is_stable_force = max_perp_force  FORCE_TOLERANCE\n        \n        # Criterion 3: Barrier height accuracy\n        barrier_k = np.max(final_energies) - final_energies[0]\n        is_accurate_energy = abs(barrier_k - barrier_ref)  ENERGY_TOLERANCE\n        \n        # Combine booleans: True if all criteria are met\n        results.append(is_stable_cv and is_stable_force and is_accurate_energy)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solver\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "标准的静态NEB计算直接得到的是零温下的电子能垒 $\\Delta E^\\dagger$。为了与在有限温度下进行的实验测量结果进行比较，我们必须计算活化自由能 $\\Delta G^\\dagger(T)$。本练习将指导您完成这一关键的后处理步骤，展示如何利用谐振子近似从静态NEB结果（即反应物和过渡态的振动频率）中估算热力学校正，并将其与更严谨的平均力势（PMF）方法得到的结果进行比较 ()。",
            "id": "4254430",
            "problem": "考虑一个吸附物在电化学电极上的表面扩散事件。其热激活反应势垒由温度 $T$ 下的活化自由能 $\\Delta G^\\dagger(T)$ 来量化。通常采用两种计算路径：(i) 沿反应坐标 $s$ 的平均力势 (PMF)，以及 (ii) 源自静态微动弹性带 (NEB) 数据的谐波近似。使用以下基础理论：\n\n- 玻尔兹曼分布通过 $G(s;T) = -k_{\\mathrm{B}} T \\ln P(s) + C$ 将概率密度 $P(s)$ 与自由能剖面 $G(s;T)$ 联系起来，其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，$C$ 是一个在计算差值时会抵消的常数。PMF 势垒为 $\\Delta G^\\dagger_{\\mathrm{PMF}}(T) = G(s^\\dagger;T) - G(s_0;T)$，其中 $s^\\dagger$ 是 $G(s;T)$ 最大值处的坐标，$s_0$ 是反应物的最小值处。\n- 对于一组角频率为 $\\{\\omega_i\\}$ 的简正模，独立量子谐振子的振动配分函数得出振动自由能 $F_{\\mathrm{vib}}(T) = \\sum_i \\left( \\frac{1}{2}\\hbar\\omega_i + k_{\\mathrm{B}} T \\ln\\left(1 - e^{-\\beta \\hbar \\omega_i}\\right) \\right)$，其中 $\\beta = 1/(k_{\\mathrm{B}} T)$，$\\hbar$ 是约化普朗克常数，所有角度均以弧度为单位。在静态 NEB 谐波近似中，自由能势垒为\n$$\n\\Delta G^\\dagger_{\\mathrm{harm}}(T) = \\Delta E^\\dagger + F_{\\mathrm{vib}}^{\\mathrm{TS}}(T) - F_{\\mathrm{vib}}^{\\mathrm{min}}(T),\n$$\n其中 $\\Delta E^\\dagger$ 是来自 NEB 的电子能垒，$F_{\\mathrm{vib}}^{\\mathrm{TS}}(T)$ 仅使用过渡态的实值（非虚）振动模式（不包括反应坐标的不稳定模式）计算，$F_{\\mathrm{vib}}^{\\mathrm{min}}(T)$ 使用最小能量点所有振动模式计算。角频率通过 $\\omega = 2\\pi \\nu$ 与普通频率 $\\nu$ 相关联。\n\n实现一个程序来：\n1. 通过取剖面的全局最大值与全局最小值之差，直接从离散的 PMF 数据 $G(s_j;T)$ 计算 $\\Delta G^\\dagger_{\\mathrm{PMF}}(T)$。\n2. 使用上述量子谐振子自由能公式，从静态 NEB 数据计算 $\\Delta G^\\dagger_{\\mathrm{harm}}(T)$，通过 $\\omega = 2\\pi \\nu$ 将以太赫兹 (THz) 为单位的普通频率转换为以弧度/秒为单位的角频率，其中 $\\nu$ 的单位是 $\\mathrm{Hz}$，满足 $1\\,\\mathrm{THz} = 10^{12}\\,\\mathrm{Hz}$。\n3. 使用常数 $k_{\\mathrm{B}} = 8.617333262\\times 10^{-5}\\,\\mathrm{eV/K}$ 和 $\\hbar = 6.582119569\\times 10^{-16}\\,\\mathrm{eV\\cdot s}$。\n\n所有能量必须以电子伏特 (eV) 表示。所有温度必须以开尔文 (K) 表示。任何角频率中使用的角度必须以弧度表示。报告计算出的势垒，单位为电子伏特 (eV)，并四舍五入到小数点后四位。\n\n测试套件：\n- 案例 A (正常路径): $T = 300\\,\\mathrm{K}$; PMF 剖面 $G(s;T)$ (单位 $\\mathrm{eV}$): $\\{0.000, 0.045, 0.120, 0.190, 0.220, 0.205, 0.130, 0.060, 0.000\\}$; NEB $\\Delta E^\\dagger = 0.180\\,\\mathrm{eV}$; 最小能量点简正模频率 (THz): $\\{5.0, 7.0, 9.0, 12.0, 15.0\\}$; 过渡态实值模式频率 (THz) (不包括不稳定模式): $\\{6.0, 8.0, 10.0, 13.0\\}$。\n- 案例 B (边界条件，近乎平坦的势垒): $T = 300\\,\\mathrm{K}$; PMF 剖面 $G(s;T)$ (单位 $\\mathrm{eV}$): $\\{0.000, 0.003, 0.006, 0.010, 0.012, 0.011, 0.007, 0.004, 0.001\\}$; NEB $\\Delta E^\\dagger = 0.030\\,\\mathrm{eV}$; 最小能量点简正模频率 (THz): $\\{3.0, 5.0, 7.0, 9.0, 11.0\\}$; 过渡态实值模式频率 (THz): $\\{3.5, 5.5, 7.5, 9.5\\}$。\n- 案例 C (边缘情况，较高温度): $T = 800\\,\\mathrm{K}$; PMF 剖面 $G(s;T)$ (单位 $\\mathrm{eV}$): $\\{0.000, 0.030, 0.090, 0.150, 0.180, 0.175, 0.110, 0.050, 0.000\\}$; NEB $\\Delta E^\\dagger = 0.220\\,\\mathrm{eV}$; 最小能量点简正模频率 (THz): $\\{4.0, 6.5, 8.0, 10.0, 12.0\\}$; 过渡态实值模式频率 (THz): $\\{5.0, 7.0, 9.0, 11.0\\}$。\n\n您的程序应生成单行输出，其中包含六个结果，格式为方括号内的逗号分隔列表，顺序为 $[\\Delta G^\\dagger_{\\mathrm{PMF}}(A), \\Delta G^\\dagger_{\\mathrm{harm}}(A), \\Delta G^\\dagger_{\\mathrm{PMF}}(B), \\Delta G^\\dagger_{\\mathrm{harm}}(B), \\Delta G^\\dagger_{\\mathrm{PMF}}(C), \\Delta G^\\dagger_{\\mathrm{harm}}(C)]$，每个数值都四舍五入到小数点后四位，并以 $\\mathrm{eV}$ 表示。",
            "solution": "问题陈述已经过严格验证，被认为是合理、适定且在科学上基于统计力学和计算化学原理的。它提供了计算指定量所需的所有必要数据、常数和明确定义。我们现在将进行完整的求解。\n\n目标是使用两种不同的计算方法来计算表面扩散过程的活化自由能势垒 $\\Delta G^\\dagger(T)$：一种基于平均力势 (PMF)，另一种基于使用微动弹性带 (NEB) 计算数据的谐波近似。所有计算将针对三个不同的测试案例进行。\n\n提供的物理常数是玻尔兹曼常数 $k_{\\mathrm{B}} = 8.617333262\\times 10^{-5}\\,\\mathrm{eV/K}$ 和约化普朗克常数 $\\hbar = 6.582119569\\times 10^{-16}\\,\\mathrm{eV\\cdot s}$。所有能量值将以电子伏特 ($eV$) 表示，温度以开尔文 ($K$) 表示。\n\n**1. PMF 活化势垒的计算, $\\Delta G^\\dagger_{\\mathrm{PMF}}(T)$**\n\n平均力势 $G(s;T)$ 表示在给定温度 $T$ 下，系统作为所选反应坐标 $s$ 函数的自由能。在此框架内，活化势垒定义为最大自由能（对应于过渡态 $s^\\dagger$）与最小自由能（对应于反应物态 $s_0$）之间的差值。\n公式为：\n$$\n\\Delta G^\\dagger_{\\mathrm{PMF}}(T) = G(s^\\dagger;T) - G(s_0;T)\n$$\n对于给定的离散 PMF 剖面 $\\{G(s_j;T)\\}$，此计算简化为在所提供的数据集中寻找全局最大值和全局最小值：\n$$\n\\Delta G^\\dagger_{\\mathrm{PMF}}(T) = \\max(\\{G(s_j;T)\\}) - \\min(\\{G(s_j;T)\\})\n$$\n将使用各自的 PMF 剖面对三个测试案例中的每一个进行此计算。\n\n**2. 谐波活化势垒的计算, $\\Delta G^\\dagger_{\\mathrm{harm}}(T)$**\n\n此方法通过将来自 NEB 的静态电子能垒与谐波振动自由能贡献相结合来近似自由能势垒。控制方程为：\n$$\n\\Delta G^\\dagger_{\\mathrm{harm}}(T) = \\Delta E^\\dagger + F_{\\mathrm{vib}}^{\\mathrm{TS}}(T) - F_{\\mathrm{vib}}^{\\mathrm{min}}(T)\n$$\n这里，$\\Delta E^\\dagger$ 是过渡态和最小能量点之间的电子能量差，从静态（零温）NEB 计算中获得。$F_{\\mathrm{vib}}^{\\mathrm{min}}(T)$ 和 $F_{\\mathrm{vib}}^{\\mathrm{TS}}(T)$ 分别是最小能量结构和过渡态结构的振动自由能。\n\n振动自由能 $F_{\\mathrm{vib}}(T)$ 是通过将每个振动简正模（建模为独立的量子谐振子）的贡献求和来计算的。公式为：\n$$\nF_{\\mathrm{vib}}(T) = \\sum_i \\left( \\frac{1}{2}\\hbar\\omega_i + k_{\\mathrm{B}} T \\ln\\left(1 - e^{-\\hbar\\omega_i / (k_{\\mathrm{B}} T)}\\right) \\right)\n$$\n总和中的第一项 $\\frac{1}{2}\\hbar\\omega_i$ 是模式 $i$ 的零点能 (ZPE)。第二项表示该模式对自由能的热贡献。求和是在相关的模式集上执行的：\n- 对于 $F_{\\mathrm{vib}}^{\\mathrm{min}}(T)$，总和涵盖了最小能量结构的所有振动模式。\n- 对于 $F_{\\mathrm{vib}}^{\\mathrm{TS}}(T)$，总和涵盖了过渡态的所有实值振动模式，不包括与沿反应坐标运动相对应的单个虚频模式。\n\n简正模频率 $\\nu_i$ 以太赫兹 ($THz$) 为单位提供。它们必须转换为以弧度/秒为单位的角频率 $\\omega_i$ 才能在公式中使用。转换分两步完成：\n1. 从 $THz$ 转换为 $Hz$：$\\nu_i\\,[\\mathrm{Hz}] = \\nu_i\\,[\\mathrm{THz}] \\times 10^{12}$。\n2. 从普通频率转换为角频率：$\\omega_i\\,[\\mathrm{rad/s}] = 2\\pi\\nu_i\\,[\\mathrm{Hz}]$。\n\n**3. 算法实现**\n\n将实现一个 Python 程序来执行这些计算。总体结构如下：\n- 定义物理常数 $k_{\\mathrm{B}}$ 和 $\\hbar$。\n- 将三个测试案例的数据以结构化格式存储。\n- 将创建一个辅助函数 `calculate_F_vib(frequencies, T)`。此函数将接收一个频率列表（以 $THz$ 为单位）和一个温度（以 $K$ 为单位），并返回总振动自由能 $F_{\\mathrm{vib}}(T)$（以 $eV$ 为单位）。它将处理频率单位转换和模式求和。为了在计算接近 1 的 $x$ 的 $\\ln(1-x)$ 时保持数值稳定性，将使用 `numpy.log1p` 函数，形式为 `numpy.log1p(-numpy.exp(-arg))`。\n- 程序的主要部分将遍历每个测试案例。\n- 在每次迭代中：\n    a. 通过找到 PMF 剖面的最大值和最小值来计算 $\\Delta G^\\dagger_{\\mathrm{PMF}}(T)$。\n    b. 调用 `calculate_F_vib` 来计算 $F_{\\mathrm{vib}}^{\\mathrm{min}}(T)$ 和 $F_{\\mathrm{vib}}^{\\mathrm{TS}}(T)$。\n    c. 使用谐波势垒的主公式计算 $\\Delta G^\\dagger_{\\mathrm{harm}}(T)$。\n- 将收集六个结果值（三个案例中每个的 $\\Delta G^\\dagger_{\\mathrm{PMF}}$ 和 $\\Delta G^\\dagger_{\\mathrm{harm}}$）。\n- 最后，结果将被格式化为单个字符串，每个值四舍五入到小数点后四位，并按规定打印到标准输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational electrochemistry problem by calculating activation\n    free energy barriers using PMF and harmonic approximation methods.\n    \"\"\"\n    \n    # Define physical constants.\n    # Boltzmann constant in eV/K\n    KB_EV_K = 8.617333262e-5\n    # Reduced Planck constant in eV*s\n    HBAR_EV_S = 6.582119569e-16\n\n    # Test suite data.\n    test_cases = [\n        {\n            \"case_id\": \"A\",\n            \"T\": 300.0,\n            \"pmf_profile_ev\": [0.000, 0.045, 0.120, 0.190, 0.220, 0.205, 0.130, 0.060, 0.000],\n            \"delta_E_dagger_ev\": 0.180,\n            \"min_freqs_thz\": [5.0, 7.0, 9.0, 12.0, 15.0],\n            \"ts_real_freqs_thz\": [6.0, 8.0, 10.0, 13.0],\n        },\n        {\n            \"case_id\": \"B\",\n            \"T\": 300.0,\n            \"pmf_profile_ev\": [0.000, 0.003, 0.006, 0.010, 0.012, 0.011, 0.007, 0.004, 0.001],\n            \"delta_E_dagger_ev\": 0.030,\n            \"min_freqs_thz\": [3.0, 5.0, 7.0, 9.0, 11.0],\n            \"ts_real_freqs_thz\": [3.5, 5.5, 7.5, 9.5],\n        },\n        {\n            \"case_id\": \"C\",\n            \"T\": 800.0,\n            \"pmf_profile_ev\": [0.000, 0.030, 0.090, 0.150, 0.180, 0.175, 0.110, 0.050, 0.000],\n            \"delta_E_dagger_ev\": 0.220,\n            \"min_freqs_thz\": [4.0, 6.5, 8.0, 10.0, 12.0],\n            \"ts_real_freqs_thz\": [5.0, 7.0, 9.0, 11.0],\n        }\n    ]\n\n    def calculate_F_vib(freqs_thz, T_k):\n        \"\"\"\n        Calculates the vibrational free energy F_vib for a set of frequencies.\n        \n        Args:\n            freqs_thz (list[float]): List of normal mode frequencies in THz.\n            T_k (float): Temperature in Kelvin.\n\n        Returns:\n            float: Total vibrational free energy in eV.\n        \"\"\"\n        if not freqs_thz:\n            return 0.0\n\n        freqs_hz = np.array(freqs_thz) * 1e12\n        omegas_rad_s = 2 * np.pi * freqs_hz\n        \n        kbt_ev = KB_EV_K * T_k\n        hbar_omega_ev = HBAR_EV_S * omegas_rad_s\n        \n        # Zero-point energy (ZPE) contribution\n        zpe = 0.5 * np.sum(hbar_omega_ev)\n        \n        # Thermal contribution\n        # Use np.log1p for numerical stability: log(1-exp(-x)) -> log1p(-exp(-x))\n        exp_arg = -hbar_omega_ev / kbt_ev\n        # Handle cases where exp_arg is very small, leading to underflow in exp.\n        # np.exp handles this gracefully (returns 0.0).\n        log_term = np.log1p(-np.exp(exp_arg))\n        thermal_energy = kbt_ev * np.sum(log_term)\n        \n        return zpe + thermal_energy\n\n    results = []\n    for case in test_cases:\n        # 1. Compute PMF barrier\n        pmf_profile = case[\"pmf_profile_ev\"]\n        delta_g_pmf = max(pmf_profile) - min(pmf_profile)\n        results.append(delta_g_pmf)\n        \n        # 2. Compute harmonic barrier\n        T = case[\"T\"]\n        delta_E_dagger = case[\"delta_E_dagger_ev\"]\n        \n        # Calculate vibrational free energies for minimum and transition state\n        f_vib_min = calculate_F_vib(case[\"min_freqs_thz\"], T)\n        f_vib_ts = calculate_F_vib(case[\"ts_real_freqs_thz\"], T)\n\n        # Calculate the final harmonic free energy barrier\n        delta_g_harm = delta_E_dagger + f_vib_ts - f_vib_min\n        results.append(delta_g_harm)\n\n    # Format results to four decimal places and print\n    formatted_results = [\"{:.4f}\".format(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}