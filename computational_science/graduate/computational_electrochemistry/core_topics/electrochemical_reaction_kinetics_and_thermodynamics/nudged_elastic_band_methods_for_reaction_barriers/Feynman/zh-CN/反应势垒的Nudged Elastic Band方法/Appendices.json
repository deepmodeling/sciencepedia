{
    "hands_on_practices": [
        {
            "introduction": "在应用像NEB这样的复杂算法寻找最小能量路径（MEP）之前，从根本上理解MEP是什么至关重要。本练习将引导您对一个简单的势能面进行MEP的解析推导，将抽象的定义与具体的数学解联系起来。通过这个过程，您将为NEB算法旨在通过数值方法找到的几何特性建立起直观的认识。",
            "id": "4254429",
            "problem": "考虑一个与电极上电子转移反应相关的二维势能面，其集体反应坐标 $x$ 描述沿界面的反应进程，而正交的溶剂化坐标 $y$ 则受到周围电解质的谐波势惩罚。该势能为\n$$\nE(x,y) = x^{4} - 2 x^{2} + \\alpha y^{2},\n$$\n其中 $\\alpha > 0$ 为常数。在微动弹性带（Nudged Elastic Band, NEB）方法中，最小能量路径（Minimal Energy Path, MEP）是构型空间中的一条曲线，在该曲线上，垂直于路径的力分量为零，即路径切线与势能梯度平行。从MEP的定义（即其上垂直力为零的连续曲线）出发，推导MEP必须满足的微分条件，并用它求出连接 $E(x,y)$ 两个极小值点的MEP $y(x)$ 的显式解析表达式。然后，确定鞍点坐标 $(x^{\\ast}, y^{\\ast})$ 并计算任一极小值点与鞍点之间的能垒高度 $\\Delta E$。\n\n以行矩阵 $[y(x), x^{\\ast}, y^{\\ast}, \\Delta E]$ 的形式报告你的最终答案。提供精确的符号表达式；无需四舍五入，并且由于能量是无量纲化的，因此不需要单位。",
            "solution": "该问题要求我们求解给定二维势能面的最小能量路径（MEP）、鞍点坐标以及反应能垒。\n\n势能面由以下公式给出：\n$$\nE(x,y) = x^{4} - 2 x^{2} + \\alpha y^{2}\n$$\n其中常数 $\\alpha > 0$。\n\n首先，我们通过寻找梯度 $\\nabla E$ 为零的点来确定势能面的驻点。梯度是一阶偏导数的向量：\n$$\n\\nabla E(x,y) = \\left( \\frac{\\partial E}{\\partial x}, \\frac{\\partial E}{\\partial y} \\right) = (4x^{3} - 4x, 2\\alpha y)\n$$\n将梯度设为零向量 $\\nabla E = (0, 0)$，得到一个包含两个方程的方程组：\n$$\n4x^{3} - 4x = 0 \\implies 4x(x^{2} - 1) = 0\n$$\n$$\n2\\alpha y = 0\n$$\n从第一个方程，我们解得 $x$ 的解为 $x=0$，$x=1$ 和 $x=-1$。从第二个方程，由于 $\\alpha > 0$，我们必须有 $y=0$。\n因此，驻点是 $(-1, 0)$，$(0, 0)$ 和 $(1, 0)$。\n\n为了对这些驻点进行分类，我们计算二阶偏导数的Hessian矩阵：\n$$\nH(x,y) = \\begin{pmatrix} \\frac{\\partial^2 E}{\\partial x^2} & \\frac{\\partial^2 E}{\\partial x \\partial y} \\\\ \\frac{\\partial^2 E}{\\partial y \\partial x} & \\frac{\\partial^2 E}{\\partial y^2} \\end{pmatrix} = \\begin{pmatrix} 12x^2 - 4 & 0 \\\\ 0 & 2\\alpha \\end{pmatrix}\n$$\n我们在每个驻点处计算Hessian矩阵：\n- 对于 $(\\pm 1, 0)$:\n$$\nH(\\pm 1, 0) = \\begin{pmatrix} 12(1)^2 - 4 & 0 \\\\ 0 & 2\\alpha \\end{pmatrix} = \\begin{pmatrix} 8 & 0 \\\\ 0 & 2\\alpha \\end{pmatrix}\n$$\n特征值为 $8$ 和 $2\\alpha$。由于 $\\alpha > 0$，两个特征值均为正，这表明点 $(-1, 0)$ 和 $(1, 0)$ 是局部极小值点。\n\n- 对于 $(0, 0)$:\n$$\nH(0, 0) = \\begin{pmatrix} 12(0)^2 - 4 & 0 \\\\ 0 & 2\\alpha \\end{pmatrix} = \\begin{pmatrix} -4 & 0 \\\\ 0 & 2\\alpha \\end{pmatrix}\n$$\n特征值为 $-4$ 和 $2\\alpha$。由于一个特征值为负，另一个为正，点 $(0, 0)$ 是一个一阶鞍点。这是连接两个极小值点的反应的过渡态。因此，鞍点坐标为 $(x^{\\ast}, y^{\\ast}) = (0, 0)$。\n\n接下来，我们推导MEP的微分条件。MEP被定义为这样一条路径：在其上每一点，势能梯度 $\\nabla E$ 都与路径的切向量平行。如果我们将路径描述为函数 $y(x)$，则切向量与 $(1, \\frac{dy}{dx})$ 成比例。切向量与梯度向量 $\\nabla E = (\\frac{\\partial E}{\\partial x}, \\frac{\\partial E}{\\partial y})$ 之间的平行条件意味着它们的分量成比例：\n$$\n\\frac{dy/dx}{1} = \\frac{\\partial E / \\partial y}{\\partial E / \\partial x}\n$$\n这给出了MEP的微分条件：\n$$\n\\frac{dy}{dx} = \\frac{2\\alpha y}{4x^3 - 4x}\n$$\n我们需要解这个常微分方程，以找到连接极小值点 $(-1, 0)$ 和 $(1, 0)$ 的MEP $y(x)$ 的显式形式。\n\n我们可以立即观察到 $y(x) = 0$ 是这个微分方程的一个解。如果 $y=0$，方程左边是 $\\frac{d}{dx}(0) = 0$，右边是 $\\frac{2\\alpha(0)}{4x^3-4x} = 0$。\n对于 $x \\in [-1, 1]$，路径 $y(x)=0$ 是一条连续曲线，它穿过起始极小值点 $(-1, 0)$、鞍点 $(0, 0)$ 和终点极小值点 $(1, 0)$。从物理上看，势能 $E(x,y) = x^4-2x^2+\\alpha y^2$ 描述了在 $x$ 方向上的双势阱和在 $y$ 方向上以 $y=0$ 为中心的谐振子势。任何偏离 $x$ 轴（即 $y \\neq 0$）的行为都会使能量增加 $\\alpha y^2$。因此，作为最小能量的路径，MEP将完全位于 $x$ 轴上。因此，连接两个极小值点的MEP是 $y(x) = 0$。\n\n最后，我们计算能垒 $\\Delta E$，即鞍点与任一极小值点之间的能量差。\n鞍点 $(x^{\\ast}, y^{\\ast}) = (0, 0)$ 处的能量为：\n$$\nE(0, 0) = 0^4 - 2(0)^2 + \\alpha(0)^2 = 0\n$$\n极小值点 $(\\pm 1, 0)$ 处的能量为：\n$$\nE(\\pm 1, 0) = (\\pm 1)^4 - 2(\\pm 1)^2 + \\alpha(0)^2 = 1 - 2 + 0 = -1\n$$\n能垒是其能量差：\n$$\n\\Delta E = E(x^{\\ast}, y^{\\ast}) - E(x_{\\text{min}}, y_{\\text{min}}) = E(0,0) - E(\\pm 1, 0) = 0 - (-1) = 1\n$$\n\n总结来说，MEP为 $y(x)=0$，鞍点位于 $(0, 0)$，能垒为 $1$。结果应以行矩阵 $[y(x), x^{\\ast}, y^{\\ast}, \\Delta E]$ 的形式给出。\n结果是 $[0, 0, 0, 1]$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 0 & 0 & 0 & 1 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "NEB计算的效率和成功在很大程度上取决于初始反应路径猜测的质量。这个动手编程练习将一个简单的线性插值方法与更复杂的像对依赖势（IDPP）方法进行对比。通过实现这两种方法并比较它们的性能，您将获得关于为何物理上合理的路径初始化对于像表面吸附这样的复杂体系至关重要的实践见解。",
            "id": "4254438",
            "problem": "考虑一个与计算电化学相关的最小吸附反应：一个位置矢量为 $\\mathbf{r} \\in \\mathbb{R}^3$ 的吸附质粒子接近一个由两个固定原子（位于 $\\mathbf{s}_1$ 和 $\\mathbf{s}_2$）组成的刚性表面。物理势能被建模为吸附质与每个表面原子之间的两个莫尔斯相互作用之和，不考虑吸附质-吸附质或表面-表面之间的作用。设吸附质与表面原子 $j \\in \\{1,2\\}$ 之间的莫尔斯势为\n$$\nV_j(R_j) = D_j\\left[\\left(1 - e^{-a_j (R_j - r_{0,j})}\\right)^2 - 1\\right],\n$$\n其中 $R_j = \\|\\mathbf{r} - \\mathbf{s}_j\\|$，$D_j$ 是以电子伏特 (eV) 为单位的势阱深度，$a_j$ 是以埃的倒数 ($\\text{Å}^{-1}$) 为单位的范围参数，$r_{0,j}$ 是以埃 ($\\text{Å}$) 为单位的平衡键长。总势能为 $E(\\mathbf{r}) = V_1(R_1) + V_2(R_2)$。\n\n你的任务是编写一个完整的、可运行的程序，为微动弹性带 (Nudged Elastic Band, NEB) 方法构建两种初始路径：一种通过线性笛卡尔插值，另一种通过依赖于镜像的对势 (Image-Dependent Pair Potential, IDPP) 方法。然后，量化与线性插值相比，IDPP方法实现的初始NEB垂直力的减小程度。该减少量必须以IDPP初始化路径的均方根 (RMS) 垂直力大小与线性插值路径的均方根垂直力大小之比的形式报告。\n\n使用以下定义和要求：\n\n- 构建一个由 $N$ 个镜像组成的离散路径 $\\{\\mathbf{r}_0, \\mathbf{r}_1, \\ldots, \\mathbf{r}_{N-1}\\}$，其端点 $\\mathbf{r}_0$（初态）和 $\\mathbf{r}_{N-1}$（末态）是固定的。镜像由路径参数 $s_i = i/(N-1)$ for $i = 0, \\ldots, N-1$ 排序。\n- 对于微动弹性带 (NEB) 方法，镜像 $i$（不包括端点）处的垂直力是通过将物理力 $-\\nabla E(\\mathbf{r}_i)$ 分解为平行于和垂直于局部切线 $\\boldsymbol{\\tau}_i$ 的分量来定义的。使用对称切线\n$$\n\\boldsymbol{\\tau}_i = \\frac{\\mathbf{r}_{i+1} - \\mathbf{r}_{i-1}}{\\|\\mathbf{r}_{i+1} - \\mathbf{r}_{i-1}\\|},\n$$\n并将力的垂直分量定义为\n$$\n\\mathbf{F}_{\\perp}(\\mathbf{r}_i) = -\\nabla E(\\mathbf{r}_i) + \\left[\\nabla E(\\mathbf{r}_i) \\cdot \\boldsymbol{\\tau}_i\\right]\\boldsymbol{\\tau}_i.\n$$\n计算所有非端点镜像的RMS垂直力大小：\n$$\nF_{\\text{RMS}} = \\sqrt{\\frac{1}{N-2}\\sum_{i=1}^{N-2} \\|\\mathbf{F}_{\\perp}(\\mathbf{r}_i)\\|^2 }.\n$$\n- 对于线性笛卡尔插值，将中间镜像设置为\n$$\n\\mathbf{r}_i^{\\text{lin}} = (1 - s_i)\\,\\mathbf{r}_0 + s_i\\,\\mathbf{r}_{N-1}.\n$$\n- 对于依赖于镜像的对势 (IDPP) 方法，为每个镜像和每个吸附质-表面原子对构建目标距离，\n$$\nR_{j}^{\\text{target}}(s_i) = (1 - s_i)\\,R_{j}(\\mathbf{r}_0) + s_i\\,R_{j}(\\mathbf{r}_{N-1}),\n$$\n并将所有中间镜像（端点固定）的IDPP目标函数定义为\n$$\n\\Phi = \\sum_{i=1}^{N-2} \\sum_{j=1}^{2} w(R_{j}(\\mathbf{r}_i))\\left(R_{j}(\\mathbf{r}_i) - R_{j}^{\\text{target}}(s_i)\\right)^2,\n$$\n权重为 $w(R) = R^{-p}$，其中给定指数 $p > 0$。通过最小化 $\\Phi$（相对于中间镜像的位置 $\\mathbf{r}_i$，其中 $i=1,\\ldots,N-2$），同时保持 $\\mathbf{r}_0$ 和 $\\mathbf{r}_{N-1}$ 固定，来获得IDPP初始化的路径 $\\{\\mathbf{r}_i^{\\text{IDPP}}\\}$。\n- 推导并实现物理势能 $E(\\mathbf{r})$ 相对于 $\\mathbf{r}$ 的梯度，用于计算 $\\mathbf{F}_{\\perp}(\\mathbf{r}_i)$。\n- 推导并实现IDPP目标函数 $\\Phi$ 相对于 $\\mathbf{r}_i$ 的梯度以进行优化。你必须将 $w(R)$ 视为 $R$ 的函数，即在梯度中包含 $\\mathrm{d}w/\\mathrm{d}R$。\n- 所有能量单位必须是电子伏特 (eV)，所有长度单位必须是埃 ($\\text{Å}$)，所有力的单位必须是 $\\text{eV}/\\text{Å}$。将最终报告的比率表示为无单位的小数，并四舍五入到六位小数。\n\n下面给出了测试套件的固定表面原子位置、初始和最终吸附质位置以及参数值。对于每个测试用例，计算线性和IDPP路径的RMS垂直力，并报告减少比率 $F_{\\text{RMS}}^{\\text{IDPP}} / F_{\\text{RMS}}^{\\text{lin}}$。\n\n几何结构和端点：\n- 表面原子1：$\\mathbf{s}_1 = (0, 0, 0)$。\n- 表面原子2：$\\mathbf{s}_2 = (d, 0, 0)$，其中 $d$ 在每个测试用例中指定。\n- 初始吸附质位置：$\\mathbf{r}_0 = \\left(\\frac{d}{2}, 0, z_{\\text{init}}\\right)$。\n- 最终吸附质位置：$\\mathbf{r}_{N-1} = \\left(0, 0, z_{\\text{ads}}\\right)$。\n\n测试套件（每行定义一个测试用例，参数顺序为：$N$, $d$ ($\\text{Å}$), $z_{\\text{init}}$ ($\\text{Å}$), $z_{\\text{ads}}$ ($\\text{Å}$), $D_1$ (eV), $a_1$ ($\\text{Å}^{-1}$), $r_{0,1}$ ($\\text{Å}$), $D_2$ (eV), $a_2$ ($\\text{Å}^{-1}$), $r_{0,2}$ ($\\text{Å}$), $p$, $\\text{IDPP\\_iterations}$, $\\alpha$）：\n1. $N=7$, $d=2.5$, $z_{\\text{init}}=5.0$, $z_{\\text{ads}}=1.2$, $D_1=0.8$, $a_1=2.0$, $r_{0,1}=1.2$, $D_2=0.4$, $a_2=1.5$, $r_{0,2}=1.4$, $p=2$, $\\text{IDPP\\_iterations}=400$, $\\alpha=0.10$。\n2. $N=3$, $d=2.5$, $z_{\\text{init}}=5.0$, $z_{\\text{ads}}=1.2$, $D_1=0.8$, $a_1=2.0$, $r_{0,1}=1.2$, $D_2=0.4$, $a_2=1.5$, $r_{0,2}=1.4$, $p=2$, $\\text{IDPP\\_iterations}=200$, $\\alpha=0.10$。\n3. $N=15$, $d=2.5$, $z_{\\text{init}}=7.0$, $z_{\\text{ads}}=1.1$, $D_1=0.9$, $a_1=2.2$, $r_{0,1}=1.1$, $D_2=0.5$, $a_2=1.6$, $r_{0,2}=1.3$, $p=2$, $\\text{IDPP\\_iterations}=600$, $\\alpha=0.08$。\n4. $N=7$, $d=3.0$, $z_{\\text{init}}=5.5$, $z_{\\text{ads}}=1.3$, $D_1=0.7$, $a_1=1.8$, $r_{0,1}=1.2$, $D_2=0.6$, $a_2=1.7$, $r_{0,2}=1.4$, $p=4$, $\\text{IDPP\\_iterations}=500$, $\\alpha=0.08$。\n\n你的程序必须：\n- 实现两种初始路径的构建。\n- 使用基于梯度的更新（固定端点）来优化IDPP路径，直到达到最大迭代次数或满足一个小的容差；如果IDPP目标函数值增加，则使用回溯法减小步长 $\\alpha$。\n- 为每个测试用例计算两条路径的NEB垂直力和RMS大小。\n- 生成单行输出，其中包含所有测试用例的减少比率，格式为方括号内的逗号分隔列表，每个比率格式化为六位小数（例如，\"[0.732145,0.854321,0.621000,0.790123]\"）。\n\n所有数值输出必须是代表 $F_{\\text{RMS}}^{\\text{IDPP}} / F_{\\text{RMS}}^{\\text{lin}}$ 的无单位小数，并四舍五入到六位小数。如果出现角度（应该不会出现），则必须以弧度为单位。不允许使用百分比；将任何分数量表示为小数。",
            "solution": "该问题要求比较微动弹性带 (Nudged Elastic Band, NEB) 路径的两种初始化方法：线性笛卡尔插值和依赖于镜像的对势 (Image-Dependent Pair Potential, IDPP) 方法。比较是基于初始均方根 (root-mean-square, RMS) 垂直力，这是一个关键指标，表明初始路径与最小能量路径的接近程度。较低的初始垂直力通常会导致NEB优化更快地收敛。\n\n该系统由一个位于位置 $\\mathbf{r}$ 的吸附质粒子与一个由位于固定位置 $\\mathbf{s}_1$ 和 $\\mathbf{s}_2$ 的两个原子组成的刚性表面相互作用。总势能 $E(\\mathbf{r})$ 是两个莫尔斯势之和，每个势对应一个吸附质-表面原子对：\n$$\nE(\\mathbf{r}) = V_1(R_1) + V_2(R_2)\n$$\n其中 $R_j = \\|\\mathbf{r} - \\mathbf{s}_j\\|$ 是吸附质与表面原子 $j$ 之间的距离，莫尔斯势 $V_j$ 由下式给出：\n$$\nV_j(R_j) = D_j\\left[\\left(1 - e^{-a_j (R_j - r_{0,j})}\\right)^2 - 1\\right].\n$$\n此处，$D_j$、$a_j$ 和 $r_{0,j}$ 分别是原子对 $j$ 的势阱深度、范围参数和平衡键长。\n\n首先，我们必须推导势能的解析梯度 $\\nabla E(\\mathbf{r})$，这是计算物理力 $\\mathbf{F}(\\mathbf{r}) = -\\nabla E(\\mathbf{r})$ 所必需的。使用链式法则：\n$$\n\\nabla E(\\mathbf{r}) = \\sum_{j=1}^{2} \\nabla V_j(R_j) = \\sum_{j=1}^{2} \\frac{\\mathrm{d}V_j}{\\mathrm{d}R_j} \\nabla R_j.\n$$\n距离函数的梯度为 $\\nabla R_j = \\nabla \\|\\mathbf{r} - \\mathbf{s}_j\\| = \\frac{\\mathbf{r} - \\mathbf{s}_j}{\\|\\mathbf{r} - \\mathbf{s}_j\\|} = \\frac{\\mathbf{r} - \\mathbf{s}_j}{R_j}$。\n莫尔斯势相对于距离的导数为：\n$$\n\\frac{\\mathrm{d}V_j}{\\mathrm{d}R_j} = D_j \\cdot 2 \\left(1 - e^{-a_j (R_j - r_{0,j})}\\right) \\cdot \\left(-e^{-a_j (R_j - r_{0,j})}\\right) \\cdot (-a_j) = 2a_j D_j \\left(e^{-a_j(R_j - r_{0,j})} - e^{-2a_j(R_j - r_{0,j})}\\right).\n$$\n综合这些，总势能的梯度为：\n$$\n\\nabla E(\\mathbf{r}) = \\sum_{j=1}^{2} \\left[ 2a_j D_j \\left(e^{-a_j(R_j - r_{0,j})} - e^{-2a_j(R_j - r_{0,j})}\\right) \\frac{\\mathbf{r} - \\mathbf{s}_j}{R_j} \\right].\n$$\n\n反应路径被离散化为 $N$ 个镜像，$\\{\\mathbf{r}_0, \\mathbf{r}_1, \\ldots, \\mathbf{r}_{N-1}\\}$，其中 $\\mathbf{r}_0$ 和 $\\mathbf{r}_{N-1}$ 是固定的。对于任何中间镜像 $\\mathbf{r}_i$ ($i \\in \\{1, \\ldots, N-2\\}$)，力 $\\mathbf{F}_i = -\\nabla E(\\mathbf{r}_i)$ 被分解为平行于路径和垂直于路径的分量。局部路径方向由归一化切向矢量 $\\boldsymbol{\\tau}_i$ 估计。使用指定的对称切线：\n$$\n\\boldsymbol{\\tau}_i = \\frac{\\mathbf{r}_{i+1} - \\mathbf{r}_{i-1}}{\\|\\mathbf{r}_{i+1} - \\mathbf{r}_{i-1}\\|}.\n$$\nNEB方法旨在消除力的垂直分量，该分量通过从总力中减去平行分量得到：\n$$\n\\mathbf{F}_{\\perp}(\\mathbf{r}_i) = \\mathbf{F}_i - (\\mathbf{F}_i \\cdot \\boldsymbol{\\tau}_i)\\boldsymbol{\\tau}_i.\n$$\n垂直力的总体大小通过所有中间镜像的RMS值来量化：\n$$\nF_{\\text{RMS}} = \\sqrt{\\frac{1}{N-2}\\sum_{i=1}^{N-2} \\|\\mathbf{F}_{\\perp}(\\mathbf{r}_i)\\|^2 }.\n$$\n\n两种路径初始化方法是：\n1.  **线性笛卡尔插值**：这是最简单的方法，其中中间镜像被放置在连接端点的直线上：\n    $$\n    \\mathbf{r}_i^{\\text{lin}} = (1 - s_i)\\mathbf{r}_0 + s_i\\mathbf{r}_{N-1}, \\quad \\text{其中 } s_i = i/(N-1).\n    $$\n    这种方法通常会生成化学上不合理的路径，穿过高能区域，导致初始力很大。\n\n2.  **依赖于镜像的对势 (IDPP)**：该方法通过插值内坐标（原子间距离）而非笛卡尔坐标来生成物理上更合理的路径。首先，为每个镜像 $i$ 和吸附质-表面原子对 $j$ 定义目标距离 $R_{j}^{\\text{target}}(s_i)$，通过线性插值端点距离得到：\n    $$\n    R_{j}^{\\text{target}}(s_i) = (1 - s_i) R_j(\\mathbf{r}_0) + s_i R_j(\\mathbf{r}_{N-1}).\n    $$\n    然后构建一个目标函数 $\\Phi$，用于惩罚路径中实际距离与这些目标距离的平方偏差：\n    $$\n    \\Phi(\\{\\mathbf{r}_i\\}_{i=1}^{N-2}) = \\sum_{i=1}^{N-2} \\sum_{j=1}^{2} w(R_{j}(\\mathbf{r}_i))\\left(R_{j}(\\mathbf{r}_i) - R_{j}^{\\text{target}}(s_i)\\right)^2.\n    $$\n    权重函数 $w(R) = R^{-p}$ 给予较短、较强的键更大的重要性。IDPP路径 $\\{\\mathbf{r}_i^{\\text{IDPP}}\\}$是通过最小化 $\\Phi$（相对于中间镜像的位置 $\\{\\mathbf{r}_i\\}_{i=1}^{N-2}$）获得的。我们使用梯度下降法进行此最小化。$\\Phi$ 相对于单个镜像 $\\mathbf{r}_k$ 坐标的梯度是：\n    $$\n    \\frac{\\partial \\Phi}{\\partial \\mathbf{r}_k} = \\nabla_{\\mathbf{r}_k} \\left[ \\sum_{j=1}^{2} w(R_{j}(\\mathbf{r}_k))\\left(R_{j}(\\mathbf{r}_k) - R_{j}^{\\text{target}}(s_k)\\right)^2 \\right].\n    $$\n    设 $g_j(R_j) = w(R_j)(R_j - R_j^{\\text{target}})^2 = R_j^{-p}(R_j - R_j^{\\text{target}})^2$。梯度为 $\\frac{\\partial \\Phi}{\\partial \\mathbf{r}_k} = \\sum_{j=1}^{2} \\frac{\\mathrm{d}g_j}{\\mathrm{d}R_j} \\nabla_{\\mathbf{r}_k} R_j$。\n    导数 $\\frac{\\mathrm{d}g_j}{\\mathrm{d}R_j}$ 使用乘法法则求得：\n    $$\n    \\frac{\\mathrm{d}g_j}{\\mathrm{d}R_j} = \\frac{\\mathrm{d}w}{\\mathrm{d}R_j}(R_j - R_j^{\\text{target}})^2 + w(R_j) \\cdot 2(R_j - R_j^{\\text{target}})\n    = -p R_j^{-p-1}(R_j - R_j^{\\text{target}})^2 + 2 R_j^{-p}(R_j - R_j^{\\text{target}}).\n    $$\n    提取公因式，我们得到：\n    $$\n    \\frac{\\mathrm{d}g_j}{\\mathrmd{R_j}} = R_j^{-p-1}(R_j - R_j^{\\text{target}}) \\left[ -p(R_j - R_j^{\\text{target}}) + 2R_j \\right] = R_j^{-p-1}(R_j - R_j^{\\text{target}}) \\left[ (2-p)R_j + pR_j^{\\text{target}} \\right].\n    $$\n    结合 $\\nabla_{\\mathbf{r}_k} R_j = (\\mathbf{r}_k - \\mathbf{s}_j) / R_j$，最终的梯度表达式为：\n    $$\n    \\frac{\\partial \\Phi}{\\partial \\mathbf{r}_k} = \\sum_{j=1}^{2} R_j^{-p-2}(\\mathbf{r}_k) \\left(R_j(\\mathbf{r}_k) - R_{j}^{\\text{target}}(s_k)\\right) \\left[ (2-p)R_j(\\mathbf{r}_k) + pR_{j}^{\\text{target}}(s_k) \\right] (\\mathbf{r}_k - \\mathbf{s}_j).\n    $$\n    优化过程通过为每个镜像 $\\mathbf{r}_k$ 沿 $-\\frac{\\partial \\Phi}{\\partial \\mathbf{r}_k}$ 方向迈进。\n\n每个测试用例的总体流程如下：\n1.  定义几何结构：$\\mathbf{s}_1, \\mathbf{s}_2, \\mathbf{r}_0, \\mathbf{r}_{N-1}$。\n2.  构建线性插值路径 $\\{\\mathbf{r}_i^{\\text{lin}}\\}$。\n3.  计算此路径的 $F_{\\text{RMS}}^{\\text{lin}}$。\n4.  将IDPP路径初始化为线性路径。\n5.  使用带回溯的梯度下降法，在指定的迭代次数内迭代最小化IDPP目标函数 $\\Phi$，以找到 $\\{\\mathbf{r}_i^{\\text{IDPP}}\\}$。\n6.  计算优化后的IDPP路径的 $F_{\\text{RMS}}^{\\text{IDPP}}$。\n7.  计算并报告比率 $F_{\\text{RMS}}^{\\text{IDPP}} / F_{\\text{RMS}}^{\\text{lin}}$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # N, d, z_init, z_ads, D1, a1, r01, D2, a2, r02, p, IDPP_iterations, alpha\n        (7, 2.5, 5.0, 1.2, 0.8, 2.0, 1.2, 0.4, 1.5, 1.4, 2, 400, 0.10),\n        (3, 2.5, 5.0, 1.2, 0.8, 2.0, 1.2, 0.4, 1.5, 1.4, 2, 200, 0.10),\n        (15, 2.5, 7.0, 1.1, 0.9, 2.2, 1.1, 0.5, 1.6, 1.3, 2, 600, 0.08),\n        (7, 3.0, 5.5, 1.3, 0.7, 1.8, 1.2, 0.6, 1.7, 1.4, 4, 500, 0.08),\n    ]\n\n    results = []\n    for params in test_cases:\n        N, d, z_init, z_ads, D1, a1, r01, D2, a2, r02, p, idpp_iters, alpha = params\n        s1 = np.array([0.0, 0.0, 0.0])\n        s2 = np.array([d, 0.0, 0.0])\n        r0 = np.array([d / 2.0, 0.0, z_init])\n        rN_1 = np.array([0.0, 0.0, z_ads])\n\n        # 1. Linear Cartesian Interpolation Path\n        path_lin = np.zeros((N, 3))\n        path_lin[0], path_lin[-1] = r0, rN_1\n        for i in range(1, N - 1):\n            s_i = i / (N - 1)\n            path_lin[i] = (1 - s_i) * r0 + s_i * rN_1\n\n        # 2. Image-Dependent Pair Potential (IDPP) Path\n        path_idpp = path_lin.copy()\n        \n        R1_0 = np.linalg.norm(r0 - s1)\n        R2_0 = np.linalg.norm(r0 - s2)\n        R1_N_1 = np.linalg.norm(rN_1 - s1)\n        R2_N_1 = np.linalg.norm(rN_1 - s2)\n\n        target_dists = np.zeros((N, 2))\n        for i in range(N):\n            s_i = i / (N - 1)\n            target_dists[i, 0] = (1 - s_i) * R1_0 + s_i * R1_N_1\n            target_dists[i, 1] = (1 - s_i) * R2_0 + s_i * R2_N_1\n\n        s_atoms = [s1, s2]\n        idpp_params = {\n            'target_dists': target_dists[1:-1],\n            's_atoms': s_atoms,\n            'p': p,\n        }\n\n        # IDPP Optimization\n        for _ in range(idpp_iters):\n            images_to_opt = path_idpp[1:-1]\n            obj_old, grad = idpp_objective_and_gradient(images_to_opt, **idpp_params)\n            \n            # Simple backtracking line search\n            current_alpha = alpha\n            while True:\n                new_images = images_to_opt - current_alpha * grad\n                obj_new, _ = idpp_objective_and_gradient(new_images, **idpp_params)\n                \n                if obj_new  obj_old:\n                    path_idpp[1:-1] = new_images\n                    break\n                \n                current_alpha /= 2.0\n                if current_alpha  1e-12:  # Stop if step size is too small\n                    break\n\n        # 3. Calculate RMS perpendicular forces\n        force_params = {'s1': s1, 's2': s2, 'D1': D1, 'a1': a1, 'r01': r01,\n                        'D2': D2, 'a2': a2, 'r02': r02}\n\n        rms_force_lin = calculate_rms_perp_force(path_lin, **force_params)\n        rms_force_idpp = calculate_rms_perp_force(path_idpp, **force_params)\n        \n        if rms_force_lin == 0:\n            ratio = 1.0 if rms_force_idpp == 0 else float('inf')\n        else:\n            ratio = rms_force_idpp / rms_force_lin\n        \n        results.append(f\"{ratio:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef potential_gradient(r, s1, s2, D1, a1, r01, D2, a2, r02):\n    \"\"\"Calculates the gradient of the total potential energy at position r.\"\"\"\n    params = [(s1, D1, a1, r01), (s2, D2, a2, r02)]\n    total_grad = np.zeros(3)\n\n    for s_j, D_j, a_j, r0_j in params:\n        vec_r_sj = r - s_j\n        R_j = np.linalg.norm(vec_r_sj)\n        if R_j  1e-9: continue # Avoid division by zero\n\n        exp_term1 = np.exp(-a_j * (R_j - r0_j))\n        exp_term2 = np.exp(-2 * a_j * (R_j - r0_j))\n\n        dV_dR = 2 * a_j * D_j * (exp_term1 - exp_term2)\n        grad_Vj = dV_dR * (vec_r_sj / R_j)\n        total_grad += grad_Vj\n        \n    return total_grad\n\ndef calculate_rms_perp_force(path, **kwargs):\n    \"\"\"Calculates the RMS perpendicular force for a given path.\"\"\"\n    N = path.shape[0]\n    if N  3:\n        return 0.0\n\n    sum_sq_force_perp = 0.0\n    for i in range(1, N - 1):\n        ri_minus_1, ri, ri_plus_1 = path[i - 1], path[i], path[i + 1]\n        \n        tangent_vec = ri_plus_1 - ri_minus_1\n        norm_tangent_vec = np.linalg.norm(tangent_vec)\n        \n        if norm_tangent_vec  1e-9:\n            tau_i = np.zeros(3)\n        else:\n            tau_i = tangent_vec / norm_tangent_vec\n            \n        force = -potential_gradient(ri, **kwargs)\n        \n        force_parallel_mag = np.dot(force, tau_i)\n        force_parallel = force_parallel_mag * tau_i\n        force_perp = force - force_parallel\n        \n        sum_sq_force_perp += np.linalg.norm(force_perp)**2\n\n    return np.sqrt(sum_sq_force_perp / (N - 2))\n\ndef idpp_objective_and_gradient(images, target_dists, s_atoms, p):\n    \"\"\"Calculates the IDPP objective and its gradient for intermediate images.\"\"\"\n    num_images = images.shape[0]\n    gradient = np.zeros_like(images)\n    objective = 0.0\n\n    s1, s2 = s_atoms\n    s_j_list = [s1, s2]\n\n    for i in range(num_images):\n        r_k = images[i]\n        \n        for j in range(2):\n            s_j = s_j_list[j]\n            R_k_j = np.linalg.norm(r_k - s_j)\n            R_target_k_j = target_dists[i, j]\n            \n            if R_k_j  1e-9: continue\n\n            # Objective function term\n            diff = R_k_j - R_target_k_j\n            weight = R_k_j**(-p)\n            objective += weight * (diff**2)\n            \n            # Gradient term\n            # Derivation: grad = R_j^(-p-2) * (R_j - R_j_target) * [(2-p)R_j + p*R_j_target] * (r_k - s_j)\n            term1 = R_k_j**(-p - 2)\n            term2 = diff\n            term3 = (2 - p) * R_k_j + p * R_target_k_j\n            vec_rk_sj = r_k - s_j\n            \n            gradient[i] += term1 * term2 * term3 * vec_rk_sj\n\n    return objective, gradient\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "虽然NEB计算直接得到的是势能垒（$\\Delta E^\\dagger$），但真实的化学反应发生在有限温度下，并由活化自由能垒（$\\Delta G^\\dagger$）决定。本练习旨在弥合这一关键差距。您将学习如何利用静态NEB计算的结果（振动频率）来估算自由能垒，并将此谐振子近似结果与从平均力势（PMF）剖面获得的更严格结果进行比较。",
            "id": "4254430",
            "problem": "考虑在电化学电极上发生的一次吸附质表面扩散事件。该热激活反应势垒由温度 $T$ 下的活化自由能 $\\Delta G^\\dagger(T)$ 来量化。通常采用两种计算路径：(i) 沿反应坐标 $s$ 的平均力势 (PMF)，以及 (ii) 基于静态弹性带微扰 (Nudged Elastic Band, NEB) 数据得到的谐波近似估计。使用以下基本原理：\n\n- 玻尔兹曼分布通过 $G(s;T) = -k_{\\mathrm{B}} T \\ln P(s) + C$ 将概率密度 $P(s)$ 与自由能剖面 $G(s;T)$ 联系起来，其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数， $C$ 是一个在计算差值时会抵消的常数。PMF 势垒为 $\\Delta G^\\dagger_{\\mathrm{PMF}}(T) = G(s^\\dagger;T) - G(s_0;T)$，其中 $s^\\dagger$ 是 $G(s;T)$ 最大值处的坐标，$s_0$ 是反应物极小点。\n- 对于一组角频率为 $\\{\\omega_i\\}$ 的简正模，独立量子谐振子的振动配分函数给出振动自由能 $F_{\\mathrm{vib}}(T) = \\sum_i \\left( \\frac{1}{2}\\hbar\\omega_i + k_{\\mathrm{B}} T \\ln\\left(1 - e^{-\\beta \\hbar \\omega_i}\\right) \\right)$，其中 $\\beta = 1/(k_{\\mathrm{B}} T)$，$\\hbar$ 是约化普朗克常数，所有角度均以弧度为单位。在静态 NEB 谐波近似估计中，自由能势垒为\n$$\n\\Delta G^\\dagger_{\\mathrm{harm}}(T) = \\Delta E^\\dagger + F_{\\mathrm{vib}}^{\\mathrm{TS}}(T) - F_{\\mathrm{vib}}^{\\mathrm{min}}(T),\n$$\n其中 $\\Delta E^\\dagger$ 是来自 NEB 的电子能垒，$F_{\\mathrm{vib}}^{\\mathrm{TS}}(T)$ 仅使用过渡态的实频（非虚频）振动模式（不包括反应坐标的不稳定模式）计算得出，而 $F_{\\mathrm{vib}}^{\\mathrm{min}}(T)$ 使用极小点的所有振动模式计算得出。角频率通过 $\\omega = 2\\pi \\nu$ 与普通频率 $\\nu$ 相关联。\n\n实现一个程序来完成以下任务：\n1. 通过取剖面的全局最大值与全局最小值之差，直接从离散的 PMF 数据 $G(s_j;T)$ 计算 $\\Delta G^\\dagger_{\\mathrm{PMF}}(T)$。\n2. 使用上述量子谐振子自由能公式，从静态 NEB 数据计算 $\\Delta G^\\dagger_{\\mathrm{harm}}(T)$，通过 $\\omega = 2\\pi \\nu$ 将以太赫兹 (THz) 为单位的普通频率转换为以弧度/秒为单位的角频率，其中 $\\nu$ 的单位为 $\\mathrm{Hz}$，满足 $1\\,\\mathrm{THz} = 10^{12}\\,\\mathrm{Hz}$。\n3. 使用常数 $k_{\\mathrm{B}} = 8.617333262\\times 10^{-5}\\,\\mathrm{eV/K}$ 和 $\\hbar = 6.582119569\\times 10^{-16}\\,\\mathrm{eV\\cdot s}$。\n\n所有能量必须以电子伏特 (eV) 表示。所有温度必须以开尔文 (K) 表示。任何角频率中使用的角度必须以弧度表示。报告计算出的势垒，单位为电子伏特 (eV)，并四舍五入到小数点后四位。\n\n测试套件：\n- 情况 A (正常路径): $T = 300\\,\\mathrm{K}$；PMF 剖面 $G(s;T)$ (单位 $\\mathrm{eV}$): $\\{0.000, 0.045, 0.120, 0.190, 0.220, 0.205, 0.130, 0.060, 0.000\\}$；NEB $\\Delta E^\\dagger = 0.180\\,\\mathrm{eV}$；极小点简正模频率 (单位 $\\mathrm{THz}$): $\\{5.0, 7.0, 9.0, 12.0, 15.0\\}$；过渡态实模频率 (单位 $\\mathrm{THz}$，不包括不稳定模式): $\\{6.0, 8.0, 10.0, 13.0\\}$。\n- 情况 B (边界条件，近乎平坦的势垒): $T = 300\\,\\mathrm{K}$；PMF 剖面 $G(s;T)$ (单位 $\\mathrm{eV}$): $\\{0.000, 0.003, 0.006, 0.010, 0.012, 0.011, 0.007, 0.004, 0.001\\}$；NEB $\\Delta E^\\dagger = 0.030\\,\\mathrm{eV}$；极小点简正模频率 (单位 $\\mathrm{THz}$): $\\{3.0, 5.0, 7.0, 9.0, 11.0\\}$；过渡态实模频率 (单位 $\\mathrm{THz}$): $\\{3.5, 5.5, 7.5, 9.5\\}$。\n- 情况 C (边缘情况，较高温度): $T = 800\\,\\mathrm{K}$；PMF 剖面 $G(s;T)$ (单位 $\\mathrm{eV}$): $\\{0.000, 0.030, 0.090, 0.150, 0.180, 0.175, 0.110, 0.050, 0.000\\}$；NEB $\\Delta E^\\dagger = 0.220\\,\\mathrm{eV}$；极小点简正模频率 (单位 $\\mathrm{THz}$): $\\{4.0, 6.5, 8.0, 10.0, 12.0\\}$；过渡态实模频率 (单位 $\\mathrm{THz}$): $\\{5.0, 7.0, 9.0, 11.0\\}$。\n\n您的程序应生成单行输出，其中包含六个结果，格式为用方括号括起来的逗号分隔列表，顺序为 $[\\Delta G^\\dagger_{\\mathrm{PMF}}(A), \\Delta G^\\dagger_{\\mathrm{harm}}(A), \\Delta G^\\dagger_{\\mathrm{PMF}}(B), \\Delta G^\\dagger_{\\mathrm{harm}}(B), \\Delta G^\\dagger_{\\mathrm{PMF}}(C), \\Delta G^\\dagger_{\\mathrm{harm}}(C)]$，每个数值都四舍五入到小数点后四位，并以 $\\mathrm{eV}$ 表示。",
            "solution": "问题陈述已经过严格验证，被认为是合理、定义明确且在科学上基于统计力学和计算化学原理的。它提供了计算指定量所需的所有必要数据、常数和清晰定义。我们现在将进行完整的求解。\n\n目标是使用两种不同的计算方法，计算表面扩散过程的活化自由能垒 $\\Delta G^\\dagger(T)$：一种基于平均力势 (PMF)，另一种基于使用弹性带微扰 (NEB) 计算数据的谐波近似。所有计算将针对三个不同的测试用例进行。\n\n提供的物理常数是玻尔兹曼常数 $k_{\\mathrm{B}} = 8.617333262\\times 10^{-5}\\,\\mathrm{eV/K}$ 和约化普朗克常数 $\\hbar = 6.582119569\\times 10^{-16}\\,\\mathrm{eV\\cdot s}$。所有能量值将以电子伏特 ($eV$) 表示，温度以开尔文 ($K$) 表示。\n\n**1. PMF 活化势垒的计算，$\\Delta G^\\dagger_{\\mathrm{PMF}}(T)$**\n\n平均力势 $G(s;T)$ 表示在给定温度 $T$ 下，系统自由能作为所选反应坐标 $s$ 的函数。在此框架内，活化势垒定义为最大自由能（对应于过渡态 $s^\\dagger$）与最小自由能（对应于反应物态 $s_0$）之间的差值。\n公式为：\n$$\n\\Delta G^\\dagger_{\\mathrm{PMF}}(T) = G(s^\\dagger;T) - G(s_0;T)\n$$\n对于给定的离散 PMF 剖面 $\\{G(s_j;T)\\}$，此计算简化为在所提供的数据集中找到全局最大值和全局最小值：\n$$\n\\Delta G^\\dagger_{\\mathrm{PMF}}(T) = \\max(\\{G(s_j;T)\\}) - \\min(\\{G(s_j;T)\\})\n$$\n将使用各自的 PMF 剖面对三个测试用例中的每一个执行此计算。\n\n**2. 谐波活化势垒的计算，$\\Delta G^\\dagger_{\\mathrm{harm}}(T)$**\n\n该方法通过将来自 NEB 的静态电子能垒与谐波振动自由能贡献相结合来近似计算自由能垒。其控制方程为：\n$$\n\\Delta G^\\dagger_{\\mathrm{harm}}(T) = \\Delta E^\\dagger + F_{\\mathrm{vib}}^{\\mathrm{TS}}(T) - F_{\\mathrm{vib}}^{\\mathrm{min}}(T)\n$$\n此处，$\\Delta E^\\dagger$ 是过渡态和极小点之间的电子能量差，从静态（零温）NEB 计算中获得。$F_{\\mathrm{vib}}^{\\mathrm{min}}(T)$ 和 $F_{\\mathrm{vib}}^{\\mathrm{TS}}(T)$ 分别是极小点结构和过渡态结构的振动自由能。\n\n振动自由能 $F_{\\mathrm{vib}}(T)$ 是通过将每个振动简正模的贡献相加来计算的，每个简正模被建模为独立的量子谐振子。公式为：\n$$\nF_{\\mathrm{vib}}(T) = \\sum_i \\left( \\frac{1}{2}\\hbar\\omega_i + k_{\\mathrm{B}} T \\ln\\left(1 - e^{-\\hbar\\omega_i / (k_{\\mathrm{B}} T)}\\right) \\right)\n$$\n总和中的第一项 $\\frac{1}{2}\\hbar\\omega_i$ 是模式 $i$ 的零点能 (ZPE)。第二项代表该模式对自由能的热贡献。求和是在相关的模式集上进行的：\n- 对于 $F_{\\mathrm{vib}}^{\\mathrm{min}}(T)$，求和遍及最小能量结构的所有振动模式。\n- 对于 $F_{\\mathrm{vib}}^{\\mathrm{TS}}(T)$，求和遍及过渡态的所有实值振动模式，不包括与沿反应坐标运动相对应的单个虚频模式。\n\n简正模频率 $\\nu_i$ 以太赫兹 ($THz$) 为单位提供。它们必须转换为以弧度/秒为单位的角频率 $\\omega_i$ 才能在公式中使用。转换分两步完成：\n1. 从 $THz$ 转换为 $Hz$：$\\nu_i\\,[\\mathrm{Hz}] = \\nu_i\\,[\\mathrm{THz}] \\times 10^{12}$。\n2. 从普通频率转换为角频率：$\\omega_i\\,[\\mathrm{rad/s}] = 2\\pi\\nu_i\\,[\\mathrm{Hz}]$。\n\n**3. 算法实现**\n\n将实现一个 Python 程序来执行这些计算。总体结构如下：\n- 定义物理常数 $k_{\\mathrm{B}}$ 和 $\\hbar$。\n- 将三个测试用例的数据以结构化格式存储。\n- 将创建一个辅助函数 `calculate_F_vib(frequencies, T)`。该函数将接收一个频率列表（单位为 $THz$）和一个温度（单位为 $K$），并返回总振动自由能 $F_{\\mathrm{vib}}(T)$（单位为 $eV$）。它将处理频率单位转换和模式求和。\n- 为了在计算接近 1 的 $x$ 值的 $\\ln(1-x)$ 时保持数值稳定性，将使用 `numpy.log1p` 函数，形式为 `numpy.log1p(-numpy.exp(-arg))`。\n- 程序的主体部分将遍历每个测试用例。\n- 在每次迭代中：\n    a. 通过查找 PMF 剖面的最大值和最小值来计算 $\\Delta G^\\dagger_{\\mathrm{PMF}}(T)$。\n    b. 调用 `calculate_F_vib` 来计算 $F_{\\mathrm{vib}}^{\\mathrm{min}}(T)$ 和 $F_{\\mathrm{vib}}^{\\mathrm{TS}}(T)$。\n    c. 使用谐波势垒的主公式计算 $\\Delta G^\\dagger_{\\mathrm{harm}}(T)$。\n- 将收集六个结果值（三个情况下各自的 $\\Delta G^\\dagger_{\\mathrm{PMF}}$ 和 $\\Delta G^\\dagger_{\\mathrm{harm}}$）。\n- 最后，结果将被格式化为单个字符串，每个值四舍五入到小数点后四位，并按规定打印到标准输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational electrochemistry problem by calculating activation\n    free energy barriers using PMF and harmonic approximation methods.\n    \"\"\"\n    \n    # Define physical constants.\n    # Boltzmann constant in eV/K\n    KB_EV_K = 8.617333262e-5\n    # Reduced Planck constant in eV*s\n    HBAR_EV_S = 6.582119569e-16\n\n    # Test suite data.\n    test_cases = [\n        {\n            \"case_id\": \"A\",\n            \"T\": 300.0,\n            \"pmf_profile_ev\": [0.000, 0.045, 0.120, 0.190, 0.220, 0.205, 0.130, 0.060, 0.000],\n            \"delta_E_dagger_ev\": 0.180,\n            \"min_freqs_thz\": [5.0, 7.0, 9.0, 12.0, 15.0],\n            \"ts_real_freqs_thz\": [6.0, 8.0, 10.0, 13.0],\n        },\n        {\n            \"case_id\": \"B\",\n            \"T\": 300.0,\n            \"pmf_profile_ev\": [0.000, 0.003, 0.006, 0.010, 0.012, 0.011, 0.007, 0.004, 0.001],\n            \"delta_E_dagger_ev\": 0.030,\n            \"min_freqs_thz\": [3.0, 5.0, 7.0, 9.0, 11.0],\n            \"ts_real_freqs_thz\": [3.5, 5.5, 7.5, 9.5],\n        },\n        {\n            \"case_id\": \"C\",\n            \"T\": 800.0,\n            \"pmf_profile_ev\": [0.000, 0.030, 0.090, 0.150, 0.180, 0.175, 0.110, 0.050, 0.000],\n            \"delta_E_dagger_ev\": 0.220,\n            \"min_freqs_thz\": [4.0, 6.5, 8.0, 10.0, 12.0],\n            \"ts_real_freqs_thz\": [5.0, 7.0, 9.0, 11.0],\n        }\n    ]\n\n    def calculate_F_vib(freqs_thz, T_k):\n        \"\"\"\n        Calculates the vibrational free energy F_vib for a set of frequencies.\n        \n        Args:\n            freqs_thz (list[float]): List of normal mode frequencies in THz.\n            T_k (float): Temperature in Kelvin.\n\n        Returns:\n            float: Total vibrational free energy in eV.\n        \"\"\"\n        if not freqs_thz:\n            return 0.0\n\n        freqs_hz = np.array(freqs_thz) * 1e12\n        omegas_rad_s = 2 * np.pi * freqs_hz\n        \n        kbt_ev = KB_EV_K * T_k\n        hbar_omega_ev = HBAR_EV_S * omegas_rad_s\n        \n        # Zero-point energy (ZPE) contribution\n        zpe = 0.5 * np.sum(hbar_omega_ev)\n        \n        # Thermal contribution\n        # Use np.log1p for numerical stability: log(1-exp(-x)) -> log1p(-exp(-x))\n        exp_arg = -hbar_omega_ev / kbt_ev\n        # Handle cases where exp_arg is very small, leading to underflow in exp.\n        # np.exp handles this gracefully (returns 0.0).\n        log_term = np.log1p(-np.exp(exp_arg))\n        thermal_energy = kbt_ev * np.sum(log_term)\n        \n        return zpe + thermal_energy\n\n    results = []\n    for case in test_cases:\n        # 1. Compute PMF barrier\n        pmf_profile = case[\"pmf_profile_ev\"]\n        delta_g_pmf = max(pmf_profile) - min(pmf_profile)\n        results.append(delta_g_pmf)\n        \n        # 2. Compute harmonic barrier\n        T = case[\"T\"]\n        delta_E_dagger = case[\"delta_E_dagger_ev\"]\n        \n        # Calculate vibrational free energies for minimum and transition state\n        f_vib_min = calculate_F_vib(case[\"min_freqs_thz\"], T)\n        f_vib_ts = calculate_F_vib(case[\"ts_real_freqs_thz\"], T)\n\n        # Calculate the final harmonic free energy barrier\n        delta_g_harm = delta_E_dagger + f_vib_ts - f_vib_min\n        results.append(delta_g_harm)\n\n    # Format results to four decimal places and print\n    formatted_results = [\"{:.4f}\".format(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}