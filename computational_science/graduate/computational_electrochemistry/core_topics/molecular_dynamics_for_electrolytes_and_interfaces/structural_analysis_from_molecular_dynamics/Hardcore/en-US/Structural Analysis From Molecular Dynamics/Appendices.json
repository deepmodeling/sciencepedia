{
    "hands_on_practices": [
        {
            "introduction": "The radial distribution function, $g(r)$, is the cornerstone of structural analysis in disordered systems, providing a statistical picture of the local environment around a particle. A key application is to transform this probabilistic description into a chemically intuitive quantity: the coordination number, which represents the average number of neighbors in a solvation shell. This practice  will guide you through the essential workflow of deriving and numerically calculating the coordination number from a discrete $g(r)$ dataset, a fundamental skill for interpreting molecular dynamics simulations of electrolytes.",
            "id": "4259524",
            "problem": "A classical Molecular Dynamics (MD) simulation of a $1.0$ molar lithium salt in ethylene carbonate at $T=298\\,\\mathrm{K}$ and ambient pressure yields the radial distribution function (RDF) between lithium cations and carbonyl oxygen atoms, denoted $g_{ab}(r)$ with $a=\\mathrm{Li}^{+}$ and $b=\\mathrm{O}$. The goal is to obtain the average coordination number of carbonyl oxygen atoms in the first solvation shell of $\\mathrm{Li}^{+}$ by integrating the appropriate quantity up to the first minimum of the RDF.\n\nStarting from the definition of the pair correlation function and the spherical shell volume element, derive the expression that connects the coordination number to the RDF and bulk number density of species $b$. Then, using the provided physical properties to determine the bulk number density of oxygen atoms and the provided discrete RDF data, carry out a numerically consistent integration up to the first minimum and report the coordination number.\n\nAssume the liquid is dominated by ethylene carbonate with mass density $\\rho_{\\mathrm{mass}}=1.32\\,\\mathrm{g}\\,\\mathrm{cm}^{-3}$ at $T=298\\,\\mathrm{K}$, ethylene carbonate molecular formula $\\mathrm{C}_{3}\\mathrm{H}_{4}\\mathrm{O}_{3}$, molar mass $M=88.06\\,\\mathrm{g}\\,\\mathrm{mol}^{-1}$, and three oxygen atoms per molecule. Use Avogadro’s constant $N_{A}=6.022\\times 10^{23}\\,\\mathrm{mol}^{-1}$. Treat the oxygen bulk number density as originating from the solvent molecules only. The first minimum of the lithium–oxygen RDF occurs at $r_{m}=3.2\\,\\text{\\AA}$.\n\nThe RDF data are sampled on a uniform radial grid with spacing $\\Delta r=0.2\\,\\text{\\AA}$, with $r$ in $\\text{\\AA}$ and $g_{ab}(r)$ dimensionless:\n\n- `$r$` values: `r={0.0,0.2,0.4,0.6,0.8,1.0,1.2,1.4,1.6,1.8,2.0,2.2,2.4,2.6,2.8,3.0,3.2}`\n\n- `$g_{ab}(r)$` values: `g_ab(r)={0.0,0.0,0.0,0.05,0.10,0.20,0.50,1.20,2.50,3.80,4.20,3.60,2.80,1.40,0.70,0.45,0.35}`\n\nProceed as follows:\n\n- From first principles, express the coordination number in terms of the RDF and the bulk number density.\n\n- Compute the oxygen atom bulk number density $\\rho_{b}$ in $\\text{\\AA}^{-3}$ from $\\rho_{\\mathrm{mass}}$, $M$, and $N_{A}$.\n\n- Perform a first-order quadrature that is consistent with the uniform sampling to evaluate the integral up to $r_{m}$.\n\n- Report the coordination number rounded to three significant figures. The coordination number is dimensionless; do not include units in your final numerical result.",
            "solution": "The user wants me to solve a problem from the field of computational electrochemistry.\n\n### Step 1: Extract Givens\n- System: $1.0$ molar lithium salt in ethylene carbonate.\n- Temperature: $T=298\\,\\mathrm{K}$.\n- Pressure: Ambient.\n- Quantity of interest: Average coordination number of carbonyl oxygen atoms in the first solvation shell of $\\mathrm{Li}^{+}$.\n- Correlation function: Radial distribution function (RDF), $g_{ab}(r)$, with $a=\\mathrm{Li}^{+}$ and $b=\\mathrm{O}$.\n- Integration limit: First minimum of the RDF, $r_{m}=3.2\\,\\text{\\AA}$.\n- Solvent (ethylene carbonate) mass density: $\\rho_{\\mathrm{mass}}=1.32\\,\\mathrm{g}\\,\\mathrm{cm}^{-3}$.\n- Solvent molecular formula: $\\mathrm{C}_{3}\\mathrm{H}_{4}\\mathrm{O}_{3}$.\n- Solvent molar mass: $M=88.06\\,\\mathrm{g}\\,\\mathrm{mol}^{-1}$.\n- Number of oxygen atoms per solvent molecule: $3$.\n- Avogadro's constant: $N_{A}=6.022\\times 10^{23}\\,\\mathrm{mol}^{-1}$.\n- Instruction: Treat the oxygen bulk number density as originating from the solvent molecules only, using all three oxygen atoms per molecule.\n- RDF data grid spacing: $\\Delta r=0.2\\,\\text{\\AA}$.\n- RDF data points $(r, g_{ab}(r))$ where $r$ is in $\\text{\\AA}$:\n  - `r={0.0,0.2,0.4,0.6,0.8,1.0,1.2,1.4,1.6,1.8,2.0,2.2,2.4,2.6,2.8,3.0,3.2}`\n  - `g_ab(r)={0.0,0.0,0.0,0.05,0.10,0.20,0.50,1.20,2.50,3.80,4.20,3.60,2.80,1.40,0.70,0.45,0.35}`\n- Task 1: Derive expression for coordination number.\n- Task 2: Compute bulk number density of oxygen atoms, $\\rho_{b}$.\n- Task 3: Perform numerical integration using first-order quadrature.\n- Task 4: Report the final coordination number rounded to three significant figures.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded in the principles of statistical mechanics and computational chemistry. The use of the radial distribution function to calculate coordination numbers is a standard and fundamental technique for analyzing the structure of liquids and solutions. The physical data provided for ethylene carbonate (density, molar mass) are realistic.\n\nThe problem is well-posed. It provides all necessary data and constants ($g_{ab}(r)$ values, integration limits, physical constants) and a clear set of instructions to arrive at a unique numerical answer. The instruction to use a \"first-order quadrature\" is a standard specification for numerical methods, for which the trapezoidal rule is a suitable choice given the discrete, uniformly-spaced data.\n\nThere is a minor ambiguity in the problem statement. It specifies the RDF is between $\\mathrm{Li}^{+}$ and \"carbonyl oxygen atoms\" and the goal is the coordination number of \"carbonyl oxygen atoms\", but then explicitly instructs to use all \"three oxygen atoms per molecule\" to calculate the bulk number density $\\rho_b$. A strict interpretation would require using the bulk density of only carbonyl oxygens (of which there is one per molecule). This would create a contradiction. However, a more reasonable interpretation, common in such problems, is that species $b$ in both $g_{ab}(r)$ and $\\rho_b$ refers to the same set of atoms, which the problem defines for calculation purposes as all three oxygen atoms. The term \"carbonyl oxygen\" is likely used because the Li-O interaction is dominated by the carbonyl oxygen, but for the bulk calculation, all oxygens are to be included as per the explicit instruction. Under this interpretation, the problem is internally consistent and solvable.\n\nTherefore, the problem is deemed valid.\n\n### Step 3: Verdict and Action\nThe problem is valid. I will proceed with the solution.\n\nThe average coordination number, $N_c$, of species $b$ around species $a$ up to a distance $r_m$ is the total number of particles of species $b$ found within a sphere of radius $r_m$ centered on a particle of species $a$. This can be calculated by integrating the local number density of species $b$ over the volume of this sphere.\n\nThe radial distribution function, $g_{ab}(r)$, relates the local number density of species $b$ at a distance $r$ from a particle of species $a$, denoted $\\rho_b(r)$, to the average bulk number density of species $b$, $\\rho_b$. The relationship is given by:\n$$\n\\rho_b(r) = \\rho_b g_{ab}(r)\n$$\nThe number of particles of species $b$, $dN_b$, in a thin spherical shell of radius $r$ and thickness $dr$ around a particle of species $a$ is the product of the local density and the volume of the shell, $dV = 4\\pi r^2 dr$:\n$$\ndN_b(r) = \\rho_b(r) dV = \\rho_b g_{ab}(r) (4\\pi r^2 dr)\n$$\nTo find the total coordination number $N_c$ in the first solvation shell, which extends to the first minimum of the RDF at $r=r_m$, we integrate $dN_b(r)$ from $r=0$ to $r=r_m$:\n$$\nN_c(r_m) = \\int_0^{r_m} dN_b(r) = \\int_0^{r_m} 4\\pi \\rho_b r^2 g_{ab}(r) dr\n$$\nSince $\\rho_b$ and $4\\pi$ are constants, we can write the expression as:\n$$\nN_c(r_m) = 4\\pi \\rho_b \\int_0^{r_m} r^2 g_{ab}(r) dr\n$$\nThis is the required expression connecting the coordination number to the RDF and the bulk number density.\n\nNext, we compute the bulk number density of oxygen atoms, $\\rho_b$. The problem states that the solvent is ethylene carbonate ($\\mathrm{C}_{3}\\mathrm{H}_{4}\\mathrm{O}_{3}$) and we must use its mass density $\\rho_{\\mathrm{mass}} = 1.32\\,\\mathrm{g}\\,\\mathrm{cm}^{-3}$, molar mass $M = 88.06\\,\\mathrm{g}\\,\\mathrm{mol}^{-1}$, and consider all three oxygen atoms per molecule. We use Avogadro's constant $N_{A} = 6.022\\times 10^{23}\\,\\mathrm{mol}^{-1}$.\n\nThe number density of solvent molecules, $\\rho_{\\text{solvent}}$, is given by:\n$$\n\\rho_{\\text{solvent}} = \\frac{\\rho_{\\mathrm{mass}}}{M} N_A\n$$\nSince there are $3$ oxygen atoms per solvent molecule, the number density of oxygen atoms, $\\rho_b$, is:\n$$\n\\rho_b = 3 \\times \\rho_{\\text{solvent}} = 3 \\frac{\\rho_{\\mathrm{mass}} N_A}{M}\n$$\nSubstituting the given values:\n$$\n\\rho_b = 3 \\times \\frac{1.32\\,\\mathrm{g}\\,\\mathrm{cm}^{-3}}{88.06\\,\\mathrm{g}\\,\\mathrm{mol}^{-1}} \\times 6.022\\times 10^{23}\\,\\mathrm{mol}^{-1} \\approx 2.7079 \\times 10^{22}\\,\\mathrm{cm}^{-3}\n$$\nThe calculation requires units of $\\text{\\AA}$. We use the conversion $1\\,\\mathrm{cm} = 10^8\\,\\text{\\AA}$, which implies $1\\,\\mathrm{cm}^3 = 10^{24}\\,\\text{\\AA}^3$.\n$$\n\\rho_b = (2.7079 \\times 10^{22}\\,\\mathrm{cm}^{-3}) \\times \\frac{1\\,\\mathrm{cm}^3}{10^{24}\\,\\text{\\AA}^3} = 0.027079\\,\\text{\\AA}^{-3}\n$$\n\nNow, we must numerically evaluate the integral $I = \\int_0^{r_m} r^2 g_{ab}(r) dr$. The data for $r$ and $g_{ab}(r)$ are provided on a uniform grid with spacing $\\Delta r = 0.2\\,\\text{\\AA}$, and the integration limit is $r_m = 3.2\\,\\text{\\AA}$. We use the trapezoidal rule, a first-order quadrature method. Let the integrand be $h(r) = r^2 g_{ab}(r)$. The integral is approximated as:\n$$\nI \\approx \\frac{\\Delta r}{2} \\left[ h(r_0) + 2\\sum_{i=1}^{N-1} h(r_i) + h(r_N) \\right]\n$$\nwhere the data points are indexed from $i=0$ to $N=16$, so $r_0=0.0\\,\\text{\\AA}$ and $r_{16}=3.2\\,\\text{\\AA}$.\nWe tabulate the values of $h_i = r_i^2 g_{ab}(r_i)$:\n$h_0 = (0.0)^2 \\times 0.0 = 0.0$\n$h_1 = (0.2)^2 \\times 0.0 = 0.0$\n$h_2 = (0.4)^2 \\times 0.0 = 0.0$\n$h_3 = (0.6)^2 \\times 0.05 = 0.018$\n$h_4 = (0.8)^2 \\times 0.10 = 0.064$\n$h_5 = (1.0)^2 \\times 0.20 = 0.200$\n$h_6 = (1.2)^2 \\times 0.50 = 0.720$\n$h_7 = (1.4)^2 \\times 1.20 = 2.352$\n$h_8 = (1.6)^2 \\times 2.50 = 6.400$\n$h_9 = (1.8)^2 \\times 3.80 = 12.312$\n$h_{10} = (2.0)^2 \\times 4.20 = 16.800$\n$h_{11} = (2.2)^2 \\times 3.60 = 17.424$\n$h_{12} = (2.4)^2 \\times 2.80 = 16.128$\n$h_{13} = (2.6)^2 \\times 1.40 = 9.464$\n$h_{14} = (2.8)^2 \\times 0.70 = 5.488$\n$h_{15} = (3.0)^2 \\times 0.45 = 4.050$\n$h_{16} = (3.2)^2 \\times 0.35 = 3.584$\n\nThe sum of the intermediate terms is:\n$$\n\\sum_{i=1}^{15} h_i = 0.0 + 0.0 + 0.018 + 0.064 + 0.200 + 0.720 + 2.352 + 6.400 + 12.312 + 16.800 + 17.424 + 16.128 + 9.464 + 5.488 + 4.050 = 91.422\n$$\nThe value of the integral is then:\n$$\nI \\approx \\frac{0.2\\,\\text{\\AA}}{2} \\left[ h_0 + 2\\sum_{i=1}^{15} h_i + h_{16} \\right] = 0.1\\,\\text{\\AA} \\times [0.0 + 2(91.422) + 3.584] = 0.1 \\times [182.844 + 3.584]\\,\\text{\\AA}^3 = 18.6428\\,\\text{\\AA}^3\n$$\nFinally, we compute the coordination number $N_c$:\n$$\nN_c = 4\\pi \\rho_b I \\approx 4\\pi \\times (0.027079\\,\\text{\\AA}^{-3}) \\times (18.6428\\,\\text{\\AA}^3)\n$$\n$$\nN_c \\approx 6.3429\n$$\nThe problem requires the result to be rounded to three significant figures.\n$$\nN_c \\approx 6.34\n$$",
            "answer": "$$\\boxed{6.34}$$"
        },
        {
            "introduction": "Obtaining a structural metric like the coordination number is only the first step; ensuring its statistical reliability is equally critical. Molecular dynamics trajectories possess temporal correlations, meaning consecutive snapshots are not independent, which complicates error analysis. This exercise  introduces a rigorous method to assess the convergence of structural descriptors by accounting for these correlations, allowing you to estimate the simulation time required to achieve a desired level of precision.",
            "id": "4259506",
            "problem": "You are analyzing the convergence of the Radial Distribution Function (RDF) $g(r)$ computed from Molecular Dynamics (MD) trajectories in computational electrochemistry. Consider a system where the RDF estimator is built from per-frame histogram counts of ion–ion pair separations in spherical shells. For a given bin $i$ centered at radius $r_i$ with width $\\Delta r$, let $X_{i,t}$ denote the total number of pair counts falling into bin $i$ during frame $t$. Assume $\\{X_{i,t}\\}$ is a stationary, ergodic time series with nonzero temporal correlation. Let $\\mu_i$ and $\\sigma_i^2$ denote, respectively, the sample mean and sample variance of $X_{i,t}$ over the trajectory, and let $\\tau_{\\text{int},i}$ denote the integrated autocorrelation time of $X_{i,t}$ measured in frames. Let $\\Delta t$ be the time per frame in picoseconds. Define a target relative standard error threshold $\\epsilon_i$ (expressed as a decimal) for $g(r_i)$.\n\nStarting from the Central Limit Theorem for correlated observables and the definition of the integrated autocorrelation time, derive the minimal number of frames $N_{\\text{req},i}$ required for bin $i$ such that the relative standard error of $g(r_i)$ is less than or equal to $\\epsilon_i$. Express the required physical sampling time $T_{\\text{req},i}$ in picoseconds. If $\\mu_i = 0$, return $N_{\\text{req},i} = \\infty$ and $T_{\\text{req},i} = \\infty$.\n\nYour program must implement the derived expression and evaluate the following test suite. For each test case, compute per-bin $N_{\\text{req},i}$ and $T_{\\text{req},i}$ given $(\\mu_i,\\sigma_i^2,\\tau_{\\text{int},i},\\epsilon_i)$ and $\\Delta t$. Use the exact values provided below:\n\nTest Case $1$ (happy path, multiple bins):\n- Frame time $\\Delta t = 1.0$ picoseconds.\n- Bin parameters:\n    - Bin $1$: $\\mu_1 = 120$, $\\sigma_1^2 = 140$, $\\tau_{\\text{int},1} = 5.0$, $\\epsilon_1 = 0.05$.\n    - Bin $2$: $\\mu_2 = 60$, $\\sigma_2^2 = 80$, $\\tau_{\\text{int},2} = 10.0$, $\\epsilon_2 = 0.05$.\n    - Bin $3$: $\\mu_3 = 10$, $\\sigma_3^2 = 15$, $\\tau_{\\text{int},3} = 8.0$, $\\epsilon_3 = 0.10$.\n\nTest Case $2$ (boundary condition including effectively uncorrelated counts and an empty bin):\n- Frame time $\\Delta t = 0.5$ picoseconds.\n- Bin parameters:\n    - Bin $1$: $\\mu_1 = 200$, $\\sigma_1^2 = 200$, $\\tau_{\\text{int},1} = 0.5$, $\\epsilon_1 = 0.02$.\n    - Bin $2$: $\\mu_2 = 0$, $\\sigma_2^2 = 0$, $\\tau_{\\text{int},2} = 0.5$, $\\epsilon_2 = 0.10$.\n\nTest Case $3$ (strong correlation, low and high signal bins):\n- Frame time $\\Delta t = 2.0$ picoseconds.\n- Bin parameters:\n    - Bin $1$: $\\mu_1 = 100$, $\\sigma_1^2 = 100$, $\\tau_{\\text{int},1} = 50.0$, $\\epsilon_1 = 0.05$.\n    - Bin $2$: $\\mu_2 = 5$, $\\sigma_2^2 = 25$, $\\tau_{\\text{int},2} = 50.0$, $\\epsilon_2 = 0.20$.\n\nYour program should produce a single line of output containing the results as a comma-separated nested list enclosed in square brackets with no spaces. Each test case’s result is a list of per-bin results, and each bin result is a two-element list $[N_{\\text{req},i},T_{\\text{req},i}]$, where $N_{\\text{req},i}$ is an integer number of frames and $T_{\\text{req},i}$ is the required physical time in picoseconds as a float. For example, a single test case with two bins would appear as $[[N_1,T_1],[N_2,T_2]]$ and the overall output would be a list of such lists for all test cases.",
            "solution": "The problem requires the derivation of the minimal number of simulation frames, $N_{\\text{req},i}$, and the corresponding physical time, $T_{\\text{req},i}$, needed to achieve a target relative standard error, $\\epsilon_i$, for the estimator of the Radial Distribution Function, $g(r_i)$, in a specific histogram bin $i$.\n\nThe problem states that the RDF estimator is built from per-frame histogram counts, $X_{i,t}$, for pairs in bin $i$ at frame $t$. The time series $\\{X_{i,t}\\}$ is stationary and ergodic. The RDF value, $g(r_i)$, is directly proportional to the true mean of this time series, $\\bar{X}_i$. In a simulation of finite length, we estimate $\\bar{X}_i$ using the sample mean, $\\mu_i$, calculated over $N$ frames:\n$$\n\\mu_i = \\frac{1}{N} \\sum_{t=1}^{N} X_{i,t}\n$$\nSince the RDF is proportional to the mean pair count, the relative error in $g(r_i)$ is equal to the relative error in its estimator, $\\mu_i$.\n$$\n\\text{Rel. Error}(g(r_i)) = \\frac{\\text{SE}(g(r_i))}{|g(r_i)|} = \\frac{\\text{SE}(C \\mu_i)}{|C \\mu_i|} = \\frac{\\text{SE}(\\mu_i)}{|\\mu_i|}\n$$\nwhere $C$ is a constant of proportionality and $\\text{SE}(\\cdot)$ denotes the standard error. We assume $\\mu_i \\ge 0$ as it represents counts.\n\nThe problem specifies that the time series $\\{X_{i,t}\\}$ has nonzero temporal correlation. For such a correlated series, the Central Limit Theorem states that the variance of the sample mean, $\\text{Var}(\\mu_i)$, is not simply $\\sigma_i^2/N$, but is inflated by a factor known as the statistical inefficiency, $s_i$. This factor is related to the integrated autocorrelation time, $\\tau_{\\text{int},i}$. A standard result from statistical mechanics gives the variance of the mean as:\n$$\n\\text{Var}(\\mu_i) = \\frac{2 \\tau_{\\text{int},i} \\sigma_i^2}{N}\n$$\nHere, $\\sigma_i^2$ is the variance of the individual data points $X_{i,t}$, $N$ is the total number of frames, and $\\tau_{\\text{int},i}$ is the integrated autocorrelation time measured in frames. The term $2\\tau_{\\text{int},i}$ represents the number of correlated steps it takes to produce one statistically independent sample. This formulation is consistent with the case of uncorrelated data (where, by one common definition, $\\tau_{\\text{int},i}=0.5$), which correctly recovers $\\text{Var}(\\mu_i) = \\sigma_i^2/N$.\n\nThe standard error of the mean, $\\text{SE}(\\mu_i)$, is the square root of its variance:\n$$\n\\text{SE}(\\mu_i) = \\sqrt{\\text{Var}(\\mu_i)} = \\sqrt{\\frac{2 \\tau_{\\text{int},i} \\sigma_i^2}{N}} = \\sigma_i \\sqrt{\\frac{2 \\tau_{\\text{int},i}}{N}}\n$$\nThe relative standard error is then:\n$$\n\\text{RelSE}(\\mu_i) = \\frac{\\text{SE}(\\mu_i)}{\\mu_i} = \\frac{\\sigma_i}{\\mu_i} \\sqrt{\\frac{2 \\tau_{\\text{int},i}}{N}}\n$$\nWe are given a target relative standard error threshold, $\\epsilon_i$. To find the minimal number of frames, $N_{\\text{req},i}$, we set the relative standard error equal to this threshold:\n$$\n\\epsilon_i = \\frac{\\sigma_i}{\\mu_i} \\sqrt{\\frac{2 \\tau_{\\text{int},i}}{N_{\\text{req},i}}}\n$$\nSolving for $N_{\\text{req},i}$ involves squaring both sides and rearranging the terms:\n$$\n\\epsilon_i^2 = \\left(\\frac{\\sigma_i}{\\mu_i}\\right)^2 \\frac{2 \\tau_{\\text{int},i}}{N_{\\text{req},i}}\n$$\n$$\nN_{\\text{req},i} = \\frac{2 \\tau_{\\text{int},i} \\sigma_i^2}{\\mu_i^2 \\epsilon_i^2} = 2 \\tau_{\\text{int},i} \\left(\\frac{\\sigma_i}{\\mu_i \\epsilon_i}\\right)^2\n$$\nSince the number of frames must be an integer, and we require the error to be *less than or equal to* $\\epsilon_i$, we must take the ceiling of the result:\n$$\nN_{\\text{req},i} = \\left\\lceil 2 \\tau_{\\text{int},i} \\left(\\frac{\\sqrt{\\sigma_i^2}}{\\mu_i \\epsilon_i}\\right)^2 \\right\\rceil\n$$\nThe required physical sampling time, $T_{\\text{req},i}$, is the number of frames multiplied by the time per frame, $\\Delta t$:\n$$\nT_{\\text{req},i} = N_{\\text{req},i} \\cdot \\Delta t\n$$\nA special condition arises if $\\mu_i = 0$. In this case, the relative error is undefined, as it involves a division by zero. Physically, it is impossible to achieve a finite relative error for a quantity whose mean is zero. Therefore, the required number of frames and sampling time are infinite. This is consistent with the derived formula for $N_{\\text{req},i}$, which diverges as $\\mu_i \\to 0$.\n$$\n\\text{If } \\mu_i = 0, \\text{ then } N_{\\text{req},i} = \\infty \\text{ and } T_{\\text{req},i} = \\infty\n$$\nThe program implementation will follow these derived expressions.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the required number of frames and sampling time for RDF convergence.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"dt\": 1.0,\n            \"bins\": [\n                {\"mu\": 120, \"var\": 140, \"tau\": 5.0, \"eps\": 0.05},  # Bin 1\n                {\"mu\": 60, \"var\": 80, \"tau\": 10.0, \"eps\": 0.05},  # Bin 2\n                {\"mu\": 10, \"var\": 15, \"tau\": 8.0, \"eps\": 0.10},   # Bin 3\n            ],\n        },\n        {\n            \"dt\": 0.5,\n            \"bins\": [\n                {\"mu\": 200, \"var\": 200, \"tau\": 0.5, \"eps\": 0.02},  # Bin 1\n                {\"mu\": 0, \"var\": 0, \"tau\": 0.5, \"eps\": 0.10},     # Bin 2\n            ],\n        },\n        {\n            \"dt\": 2.0,\n            \"bins\": [\n                {\"mu\": 100, \"var\": 100, \"tau\": 50.0, \"eps\": 0.05}, # Bin 1\n                {\"mu\": 5, \"var\": 25, \"tau\": 50.0, \"eps\": 0.20},  # Bin 2\n            ],\n        },\n    ]\n\n    all_case_results = []\n    for case in test_cases:\n        delta_t = case[\"dt\"]\n        case_bin_results = []\n        for bin_params in case[\"bins\"]:\n            mu_i = bin_params[\"mu\"]\n            \n            if mu_i == 0:\n                n_req = float('inf')\n                t_req = float('inf')\n            else:\n                sigma_sq_i = bin_params[\"var\"]\n                tau_int_i = bin_params[\"tau\"]\n                epsilon_i = bin_params[\"eps\"]\n                \n                # Derived formula: N_req = 2 * tau_int * sigma_sq / (mu * epsilon)^2\n                numerator = 2.0 * tau_int_i * sigma_sq_i\n                denominator = (mu_i * epsilon_i) ** 2\n                \n                n_req_float = numerator / denominator\n                \n                # The number of frames must be an integer, so we take the ceiling.\n                n_req = int(np.ceil(n_req_float))\n                \n                # The required physical time is the product of frames and time per frame.\n                t_req = n_req * delta_t\n            \n            case_bin_results.append([n_req, t_req])\n        \n        all_case_results.append(case_bin_results)\n\n    # Format the final output string to be a comma-separated nested list\n    # with no spaces, as per the problem specification.\n    outer_list_str = []\n    for case_result in all_case_results:\n        inner_list_str = []\n        for n_val, t_val in case_result:\n            n_str = 'inf' if n_val == float('inf') else str(int(n_val))\n            t_str = 'inf' if t_val == float('inf') else str(float(t_val))\n            inner_list_str.append(f\"[{n_str},{t_str}]\")\n        outer_list_str.append(f\"[{','.join(inner_list_str)}]\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(outer_list_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While the radial distribution function excels at describing local, pairwise structure, it cannot fully capture the extended, network-like organization prevalent in systems like concentrated electrolytes or ionic liquids. To characterize this mesoscale structure, we turn to tools from graph theory and percolation theory. This practice  demonstrates how to analyze a system's connectivity by treating ions as nodes in a graph, enabling you to identify the formation of system-spanning clusters and quantify the percolation threshold, a critical indicator of changes in transport properties and phase behavior.",
            "id": "4259554",
            "problem": "You are given three artificial molecular dynamics snapshots representative of concentrated electrolyte environments in a cubic periodic simulation box. Each snapshot consists of a set of ion coordinates and a box length. Your task is to perform a structural analysis using graph-based connectivity: treat each ion as a node and connect two nodes with an undirected edge if their minimum-image distance under periodic boundary conditions is less than or equal to a specified cutoff distance. From this graph, compute the cluster size distribution and identify the percolation threshold across a set of candidate cutoff distances. The definition of percolation to use is the existence of a largest connected component whose fractional size is greater than or equal to a specified fraction threshold.\n\nFundamental base and definitions to use:\n- Molecular dynamics yields atomistic coordinates at discrete times. Given a single snapshot of positions $\\{\\mathbf{r}_i\\}_{i=1}^{N}$ within a cubic box of side length $L$, apply periodic boundary conditions via the Minimum Image Convention (MIC), defined as follows. For any pair $i,j$, define the displacement vector\n$$\n\\Delta \\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i - L \\cdot \\operatorname{round}\\left(\\frac{\\mathbf{r}_j - \\mathbf{r}_i}{L}\\right),\n$$\nwhere the rounding function is applied component-wise. The Euclidean distance is then\n$$\nd_{ij} = \\left\\lVert \\Delta \\mathbf{r}_{ij} \\right\\rVert_2.\n$$\n- For a given cutoff distance $r_c$, define an undirected graph $G(r_c)$ whose vertex set is the ions and whose edge set contains $\\{i,j\\}$ if and only if $d_{ij} \\le r_c$.\n- A connected component is a maximal set of vertices where any two are linked by a path. The cluster size distribution is the multiset of component sizes. The largest cluster fraction is $S_{\\max}(r_c)/N$, where $S_{\\max}(r_c)$ is the size of the largest component and $N$ is the total number of ions.\n- The percolation threshold for a given snapshot and fraction threshold $\\phi$ is the smallest cutoff $r_c$ from a supplied candidate list such that $S_{\\max}(r_c)/N \\ge \\phi$. If no candidate cutoff meets the criterion, report no percolation.\n\nThe analysis must be based solely on these definitions, starting from Euclidean geometry and graph connectivity, without invoking any shortcut formulas or external hints. Ensure numerical soundness by using the Minimum Image Convention and computing exact connected components.\n\nUnits and output requirements:\n- Distances are in nanometers, denoted $\\mathrm{nm}$. All cutoff distances $r_c$, box lengths $L$, and coordinates are in $\\mathrm{nm}$. Express the final percolation cutoff for each test case in $\\mathrm{nm}$, rounded to three decimal places.\n- The fraction threshold $\\phi$ is unitless and must be treated as a decimal (not a percentage).\n- If no percolation is found for a test case, output the sentinel value $-1.000$ (interpreted as $\\mathrm{nm}$) for that case.\n\nTest suite:\nFor each test case, construct the coordinates exactly as specified below.\n\n- Test Case A (happy path):\n  - Number of ions $N = 12$.\n  - Box length $L = 5.0\\,\\mathrm{nm}$.\n  - Coordinates are defined by two groups:\n    1. A linear chain of $7$ ions:\n       $$\\mathbf{r}_i = \\left(0.5 + 0.49\\,i,\\ 0.5,\\ 0.5\\right)\\ \\text{for}\\ i \\in \\{0,1,2,3,4,5,6\\}.$$\n    2. $5$ well-separated ions:\n       $$\\mathbf{r}_j = \\left(1.0 + 0.4\\,j,\\ 3.5,\\ 3.5\\right)\\ \\text{for}\\ j \\in \\{0,1,2,3,4\\}.$$\n  - Candidate cutoff distances:\n    $$\\{0.3,\\ 0.4,\\ 0.5,\\ 0.6\\}\\ \\mathrm{nm}.$$\n  - Fraction threshold:\n    $$\\phi = 0.5.$$\n\n- Test Case B (boundary condition at threshold):\n  - Number of ions $N = 10$.\n  - Box length $L = 4.0\\,\\mathrm{nm}$.\n  - Coordinates are defined by two groups:\n    1. A linear chain of $5$ ions:\n       $$\\mathbf{r}_i = \\left(0.5 + 0.45\\,i,\\ 0.5,\\ 0.5\\right)\\ \\text{for}\\ i \\in \\{0,1,2,3,4\\}.$$\n    2. $5$ well-separated ions:\n       $$\\mathbf{r}_j = \\left(1.0 + 0.5\\,j,\\ 3.0,\\ 3.0\\right)\\ \\text{for}\\ j \\in \\{0,1,2,3,4\\}.$$\n  - Candidate cutoff distances:\n    $$\\{0.4,\\ 0.45,\\ 0.5\\}\\ \\mathrm{nm}.$$\n  - Fraction threshold:\n    $$\\phi = 0.5.$$\n\n- Test Case C (no percolation):\n  - Number of ions $N = 8$.\n  - Box length $L = 3.0\\,\\mathrm{nm}$.\n  - Coordinates are $4$ dimers, each with separation $0.3\\,\\mathrm{nm}$, but candidate cutoffs are strictly less than $0.3\\,\\mathrm{nm}$:\n    $$\\begin{aligned}\n    \\mathbf{r}_0 = (0.5,\\ 0.5,\\ 0.5),  \\mathbf{r}_1 = (0.8,\\ 0.5,\\ 0.5),\\\\\n    \\mathbf{r}_2 = (1.5,\\ 1.5,\\ 1.5),  \\mathbf{r}_3 = (1.8,\\ 1.5,\\ 1.5),\\\\\n    \\mathbf{r}_4 = (0.5,\\ 2.5,\\ 2.5),  \\mathbf{r}_5 = (0.8,\\ 2.5, 2.5),\\\\\n    \\mathbf{r}_6 = (2.5,\\ 0.5,\\ 2.5),  \\mathbf{r}_7 = (2.8,\\ 0.5, 2.5).\n    \\end{aligned}$$\n  - Candidate cutoff distances:\n    $$\\{0.2,\\ 0.25\\}\\ \\mathrm{nm}.$$\n  - Fraction threshold:\n    $$\\phi = 0.5.$$\n\nProgram requirements:\n- Implement the Minimum Image Convention for periodic boundary conditions exactly as specified.\n- For each candidate $r_c$, build $G(r_c)$, compute connected components, and obtain the cluster size distribution and the largest cluster fraction $S_{\\max}(r_c)/N$.\n- For each test case, identify the percolation threshold as the smallest $r_c$ from its candidate list such that $S_{\\max}(r_c)/N \\ge \\phi$. If none exist, report $-1.000$.\n- Your program should produce a single line of output containing the percolation thresholds for Test Cases A, B, and C, respectively, as a comma-separated list enclosed in square brackets, with each value rounded to three decimal places in $\\mathrm{nm}$ (e.g., $$[0.500,0.450,-1.000]$$).",
            "solution": "The problem statement has been validated and is deemed valid. It is scientifically grounded in the principles of computational chemistry and statistical mechanics, specifically the analysis of particle configurations from molecular dynamics. The problem is well-posed, with all necessary data, definitions, and constraints provided. The objectives are clear, and the required methodology is explicitly defined, ensuring a unique and verifiable solution.\n\nThe task is to determine the percolation threshold for three distinct molecular systems given their ion coordinates, simulation box dimensions, a set of candidate cutoff distances, and a percolation fraction threshold. The solution involves a graph-based analysis of ion connectivity under periodic boundary conditions.\n\nThe algorithmic approach proceeds as follows for each test case:\n1.  The candidate cutoff distances, $\\{r_c\\}$, are first sorted in ascending order. This is essential because the percolation threshold is defined as the *smallest* $r_c$ that satisfies the percolation criterion.\n2.  We iterate through the sorted candidate cutoffs. For each $r_c$, we construct a graph $G(r_c)$ and test for percolation.\n3.  The graph $G(r_c)$ has $N$ vertices, where $N$ is the number of ions. An undirected edge is created between two vertices, say $i$ and $j$, if the distance between the corresponding ions, $d_{ij}$, is less than or equal to $r_c$.\n4.  The distance $d_{ij}$ must be calculated using the Minimum Image Convention (MIC) to account for the periodic boundary conditions of the cubic simulation box of side length $L$. The displacement vector $\\Delta \\mathbf{r}_{ij}$ between ion $j$ at position $\\mathbf{r}_j$ and ion $i$ at position $\\mathbf{r}_i$ is given by:\n    $$\n    \\Delta \\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i - L \\cdot \\operatorname{round}\\left(\\frac{\\mathbf{r}_j - \\mathbf{r}_i}{L}\\right)\n    $$\n    where the $\\operatorname{round}$ function is applied to each vector component. The distance is the Euclidean norm of this displacement vector, $d_{ij} = \\left\\lVert \\Delta \\mathbf{r}_{ij} \\right\\rVert_2$. Computationally, it is more efficient to compare squared distances to avoid the square root operation: an edge exists if $d_{ij}^2 \\le r_c^2$. The adjacency list is a suitable data structure to represent the graph.\n5.  Once the graph $G(r_c)$ is constructed, we must find the sizes of its connected components. A graph traversal algorithm, such as Depth-First Search (DFS) or Breadth-First Search (BFS), is employed. We maintain a `visited` array to keep track of visited vertices. We iterate through all vertices from $0$ to $N-1$. If a vertex has not been visited, we start a new traversal from it, counting all vertices in its connected component and marking them as visited.\n6.  During the component search, we track the size of the largest component found, denoted $S_{\\max}(r_c)$.\n7.  The percolation criterion is then checked. Percolation is said to occur if the fraction of ions in the largest cluster, $S_{\\max}(r_c)/N$, is greater than or equal to the specified fraction threshold, $\\phi$.\n    $$\n    \\frac{S_{\\max}(r_c)}{N} \\ge \\phi\n    $$\n8.  If the criterion is met, the current $r_c$ is the percolation threshold. Since we are iterating through the cutoffs in ascending order, this will be the smallest such $r_c$. The function then returns this value.\n9.  If the loop completes without the criterion ever being met, it signifies that no percolation occurs for any of the candidate cutoff distances. In this case, the specified sentinel value of $-1.0$ is returned.\n\nThis procedure is applied to each of the three test cases, and the resulting percolation thresholds are collected and formatted as a comma-separated list, with each value rounded to three decimal places.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_percolation_threshold(coords: np.ndarray, N: int, L: float, cutoffs: list[float], phi: float) - float:\n    \"\"\"\n    Calculates the percolation threshold for a set of ions in a periodic box.\n\n    Args:\n        coords: An (N, 3) numpy array of ion coordinates.\n        N: The number of ions.\n        L: The side length of the cubic periodic box.\n        cutoffs: A list of candidate cutoff distances.\n        phi: The fraction threshold for percolation.\n\n    Returns:\n        The smallest cutoff distance that achieves percolation, or -1.0 if none do.\n    \"\"\"\n    sorted_cutoffs = sorted(cutoffs)\n\n    for rc in sorted_cutoffs:\n        rc_sq = rc * rc\n\n        # Build adjacency list for the graph G(rc)\n        adj = [[] for _ in range(N)]\n        for i in range(N):\n            for j in range(i + 1, N):\n                # Calculate squared distance using Minimum Image Convention (MIC)\n                dr = coords[j] - coords[i]\n                dr -= L * np.round(dr / L)\n                dist_sq = np.sum(dr**2)\n\n                if dist_sq = rc_sq:\n                    adj[i].append(j)\n                    adj[j].append(i)\n\n        # Find connected components and the size of the largest one using DFS\n        visited = [False] * N\n        max_component_size = 0\n        for i in range(N):\n            if not visited[i]:\n                current_component_size = 0\n                stack = [i]\n                visited[i] = True\n                while stack:\n                    u = stack.pop()\n                    current_component_size += 1\n                    for v in adj[u]:\n                        if not visited[v]:\n                            visited[v] = True\n                            stack.append(v)\n                \n                if current_component_size  max_component_size:\n                    max_component_size = current_component_size\n        \n        # Check for percolation\n        if N  0 and (max_component_size / N) = phi:\n            return rc\n\n    return -1.0\n\ndef solve():\n    \"\"\"\n    Defines and solves the test cases for percolation analysis.\n    \"\"\"\n    # Test Case A\n    N_A = 12\n    coords_A_list = []\n    # Group 1: linear chain of 7 ions\n    for i in range(7):\n        coords_A_list.append([0.5 + 0.49 * i, 0.5, 0.5])\n    # Group 2: 5 well-separated ions\n    for j in range(5):\n        coords_A_list.append([1.0 + 0.4 * j, 3.5, 3.5])\n\n    case_A = (\n        np.array(coords_A_list),\n        N_A,\n        5.0,  # L\n        [0.3, 0.4, 0.5, 0.6],  # cutoffs\n        0.5   # phi\n    )\n\n    # Test Case B\n    N_B = 10\n    coords_B_list = []\n    # Group 1: linear chain of 5 ions\n    for i in range(5):\n        coords_B_list.append([0.5 + 0.45 * i, 0.5, 0.5])\n    # Group 2: 5 well-separated ions\n    for j in range(5):\n        coords_B_list.append([1.0 + 0.5 * j, 3.0, 3.0])\n\n    case_B = (\n        np.array(coords_B_list),\n        N_B,\n        4.0,  # L\n        [0.4, 0.45, 0.5],  # cutoffs\n        0.5   # phi\n    )\n\n    # Test Case C\n    N_C = 8\n    coords_C_list = [\n        [0.5, 0.5, 0.5], [0.8, 0.5, 0.5],\n        [1.5, 1.5, 1.5], [1.8, 1.5, 1.5],\n        [0.5, 2.5, 2.5], [0.8, 2.5, 2.5],\n        [2.5, 0.5, 2.5], [2.8, 0.5, 2.5]\n    ]\n\n    case_C = (\n        np.array(coords_C_list),\n        N_C,\n        3.0,  # L\n        [0.2, 0.25],  # cutoffs\n        0.5   # phi\n    )\n\n    test_cases = [case_A, case_B, case_C]\n    results = []\n    \n    for case in test_cases:\n        coords, N, L, cutoffs, phi = case\n        result = find_percolation_threshold(coords, N, L, cutoffs, phi)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.3f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}