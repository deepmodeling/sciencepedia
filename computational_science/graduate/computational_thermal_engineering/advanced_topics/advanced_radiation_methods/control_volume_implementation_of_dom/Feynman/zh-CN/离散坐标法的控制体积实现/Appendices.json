{
    "hands_on_practices": [
        {
            "introduction": "在开发任何计算代码时，第一步也是最关键的一步是验证。本练习将指导您实现一个简单的一维控制容积离散坐标法（DOM）求解器，并根据精确的解析解来验证其准确性。通过执行网格加密研究并计算收敛阶，您将掌握验证数值方法和建立对离散化方案信心所需的基本技能。",
            "id": "3945290",
            "problem": "一束准直单色光束进入一个一维平板腔，腔内充满了均匀、纯吸收、无发射、无散射的介质。该平板占据空间区间 $x \\in [0,L]$。强度场 $I(x,\\mu)$ 由稳态一维辐射传输方程 (RTE) 控制\n$$\n\\mu \\,\\frac{d I(x,\\mu)}{d x} + \\kappa \\, I(x,\\mu) = 0,\n$$\n其中 $x$ 是空间坐标，$\\mu$ 是传播方向相对于 $x$ 轴夹角的余弦，$\\kappa$ 是吸收系数。在左边界，沿单个离散纵标 $\\mu_b \\in (0,1]$ 给定一束入射强度为 $I_0$ 的准直光束，即 $I(0,\\mu_b)=I_0$，而右边界在 $\\mu_b$ 方向上没有入射辐射。\n\n你将使用一阶迎风闭合，为等于光束方向 $\\mu_b$ 的单个离散纵标实现一个控制体离散纵标法 (DOM)。你的实现必须基于基本守恒定律：\n- 将 RTE 在宽度为 $\\Delta x$、从 $x_{i-1/2}$ 到 $x_{i+1/2}$ 的空间控制体上积分，以获得对流（流动）通量和体吸收之间的离散平衡。\n- 使用与 $\\mu_b$ 符号一致的迎风近似来闭合界面强度。\n- 在包含 $N$ 个控制体的均匀网格上，从流入边界向流出边界推进，以获得单元平均或单元中心的离散强度值 $\\{ I_i \\}_{i=1}^N$。\n\n为了进行验证，使用沿光束方向的解析解作为参考，该解可沿特征线直接从 RTE 获得：\n$$\nI_{\\text{exact}}(x,\\mu_b) = I_0 \\, \\exp\\!\\left(-\\frac{\\kappa}{\\mu_b}\\, x\\right).\n$$\n使用单元中心位置 $x_i = \\left(i-\\tfrac{1}{2}\\right)\\Delta x$ 以及 $\\Delta x = L/N$。\n\n将单元中心的误差定义为 $e_i = I_i - I_{\\text{exact}}(x_i,\\mu_b)$。使用强度误差的相对 $L_2$ 范数量化收敛性\n$$\nE_2 = \\frac{\\left( \\sum_{i=1}^{N} e_i^2 \\, \\Delta x \\right)^{1/2}}{\\left( \\sum_{i=1}^{N} I_{\\text{exact}}(x_i,\\mu_b)^2 \\, \\Delta x \\right)^{1/2}}.\n$$\n使用网格 $N \\in \\{N_1,N_2,N_3,N_4\\}$（其中 $N_{j+1}=2N_j$）进行网格加密研究，并使用最后两个网格计算观测到的精度阶：\n$$\np = \\frac{\\ln\\!\\left( E_2(N_3) / E_2(N_4) \\right)}{\\ln\\!\\left( h_3 / h_4 \\right)}, \\quad h_j = \\frac{L}{N_j}.\n$$\n\n实现一个程序，对于下面定义的每个测试用例，在网格序列上计算 $E_2$，并以浮点数形式返回观测到的阶数 $p$。相对于上面定义的 $L_2$ 度量，所有计算都是无量纲的。角度由方向余弦 $\\mu_b$ (无量纲) 表示。由于只报告相对误差，强度可以是任何一致的单位，但你必须将 $I_0$ 视为给定的标量。将最终报告的观测阶数表示为十进制浮点数。\n\n测试套件（每个元组为 $(L,\\kappa,\\mu_b,I_0)$）：\n- 情况 A（理想路径，垂直入射，中等吸收）：$(1.0,\\,1.0,\\,1.0,\\,1.0)$。\n- 情况 B（掠射，中等吸收，更陡峭的特征线）：$(1.0,\\,1.0,\\,0.2,\\,1.0)$。\n- 情况 C（短腔，光学厚，非单位入射流）：$(0.2,\\,20.0,\\,0.8,\\,2.0)$。\n\n对于每种情况，使用网格 $N \\in \\{10,20,40,80\\}$，并根据 $N=40$ 和 $N=80$ 的结果计算 $p$。你的程序应生成单行输出，其中包含以逗号分隔的列表形式的结果，并用方括号括起来，顺序为 $[p_{\\text{A}},p_{\\text{B}},p_{\\text{C}}]$，每个 $p$ 值四舍五入到六位小数。",
            "solution": "该问题经验证在科学上是合理的、适定的和客观的。它为应用于辐射传输方程的数值方法提供了一个标准的验证练习。我们现在开始求解。\n\n目标是为纯吸收介质的一维稳态辐射传输方程 (RTE) 推导并实现一个一阶控制体数值格式，该方程由下式给出：\n$$\n\\mu_b \\,\\frac{d I(x,\\mu_b)}{d x} + \\kappa \\, I(x,\\mu_b) = 0\n$$\n此处，$I(x, \\mu_b)$ 是在空间坐标 $x$ 处沿固定方向余弦 $\\mu_b > 0$ 的辐射强度，$\\kappa$ 是恒定的吸收系数。\n\n数值解是通过将区域 $x \\in [0,L]$ 离散为 $N$ 个均匀的控制体（或单元）$C_i = [x_{i-1/2}, x_{i+1/2}]$（其中 $i=1, \\dots, N$）来构建的。每个单元的宽度为 $\\Delta x = L/N$，单元中心位于 $x_i = x_{i-1/2} + \\Delta x / 2 = (i - 1/2)\\Delta x$。\n\n第一步是将 RTE 在一个通用控制体 $C_i$ 上积分：\n$$\n\\int_{x_{i-1/2}}^{x_{i+1/2}} \\left( \\mu_b \\,\\frac{d I}{d x} + \\kappa \\, I \\right) dx = 0\n$$\n对第一项（流动项或对流项）应用微积分基本定理，并分离积分可得：\n$$\n\\mu_b \\left[ I(x) \\right]_{x_{i-1/2}}^{x_{i+1/2}} + \\kappa \\int_{x_{i-1/2}}^{x_{i+1/2}} I(x) \\, dx = 0\n$$\n这就得到了控制体的精确平衡方程：\n$$\n\\mu_b \\left( I_{i+1/2} - I_{i-1/2} \\right) + \\kappa \\int_{x_{i-1/2}}^{x_{i+1/2}} I(x) \\, dx = 0\n$$\n其中 $I_{i\\pm1/2}$ 表示在单元面（界面）$x_{i\\pm1/2}$ 处的强度。\n\n为了获得一个可解的代数系统，我们必须对该平衡方程中的各项进行近似。单元 $C_i$ 的单元平均强度定义为：\n$$\nI_i = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} I(x) \\, dx\n$$\n因此，体吸收项近似为：\n$$\n\\kappa \\int_{x_{i-1/2}}^{x_{i+1/2}} I(x) \\, dx = \\kappa \\, I_i \\, \\Delta x\n$$\n这是一个二阶精度的近似（中点法则）。整个格式的精度将由最低阶的近似决定，即界面强度的闭合。\n\n问题指定了一阶迎风闭合。由于 $\\mu_b > 0$，辐射从左向右（$x$ 增加的方向）传播。因此，“迎风”方向是 $x$ 较小的方向。单元界面处的强度由迎风单元的单元平均强度来近似。\n对于单元 $i$ 在 $x_{i+1/2}$ 处的右侧面，迎风单元是单元 $i$ 本身：\n$$\nI_{i+1/2} \\approx I_i\n$$\n对于单元 $i$ 在 $x_{i-1/2}$ 处的左侧面，迎风单元是单元 $i-1$：\n$$\nI_{i-1/2} \\approx I_{i-1}\n$$\n将这些一阶近似代入平衡方程，得到单元 $i$ 的离散代数方程：\n$$\n\\mu_b \\left( I_i - I_{i-1} \\right) + \\kappa \\, I_i \\, \\Delta x = 0\n$$\n这个方程将单元 $i$ 中的强度与相邻迎风单元 $i-1$ 中的强度联系起来。我们可以重新整理它来求解 $I_i$：\n$$\nI_i (\\mu_b + \\kappa \\, \\Delta x) = \\mu_b \\, I_{i-1}\n$$\n$$\nI_i = \\left( \\frac{\\mu_b}{\\mu_b + \\kappa \\, \\Delta x} \\right) I_{i-1}\n$$\n这个递推关系使我们能够从边界开始，在区域内“推进”，计算每个单元的强度。\n\n推进过程从流入边界 $x=0$ 开始。边界条件为 $I(0, \\mu_b) = I_0$。对于第一个单元 $i=1$，其左侧面是区域边界，所以 $x_{1/2} = 0$。该面的迎风值就是边界值本身：$I_{1/2} = I_0$。对单元 $i=1$ 的离散方程应用同样的逻辑：\n$$\n\\mu_b \\left( I_1 - I_0 \\right) + \\kappa \\, I_1 \\, \\Delta x = 0\n$$\n求解 $I_1$ 可得：\n$$\nI_1 = \\left( \\frac{\\mu_b}{\\mu_b + \\kappa \\, \\Delta x} \\right) I_0\n$$\n这表明，如果我们将 $I_0$ 定义为已知的入流边界强度，则该通用递推关系对所有单元 $i=1, \\dots, N$ 都成立。\n\n完整算法如下：\n1.  给定参数 $L, \\kappa, \\mu_b, I_0$ 和网格尺寸 $N$，计算 $\\Delta x = L/N$。\n2.  初始化一个用于表示迎风强度的变量 `I_prev` $= I_0$。\n3.  对于 $i=1, \\dots, N$，使用递推式计算单元平均强度 $I_i$：\n    $$\n    I_i = \\left( \\frac{\\mu_b}{\\mu_b + \\kappa \\, \\Delta x} \\right) \\times \\text{`I_prev`}\n    $$\n    然后，用新计算出的 $I_i$ 更新 `I_prev` 以用于下一次迭代。\n\n为评估精度，我们将数值解 $\\{I_i\\}_{i=1}^N$ 与在单元中心处求值的解析解 $I_{\\text{exact}}(x_i, \\mu_b) = I_0 \\exp(-\\kappa x_i / \\mu_b)$ 进行比较，其中 $x_i = (i-1/2)\\Delta x$。相对 $L_2$ 误差范数计算如下：\n$$\nE_2 = \\frac{\\left( \\sum_{i=1}^{N} (I_i - I_{\\text{exact}}(x_i))^2 \\right)^{1/2}}{\\left( \\sum_{i=1}^{N} (I_{\\text{exact}}(x_i))^2 \\right)^{1/2}}\n$$\n注意，所提供公式的分子和分母中的因子 $\\sqrt{\\Delta x}$ 会被消掉。\n\n最后，使用来自两个连续加密的网格（$N_3=40$ 和 $N_4=80$）的误差来计算观测到的精度阶 $p$。相应的网格尺寸为 $h_3 = L/N_3$ 和 $h_4 = L/N_4$，因此加密比为 $h_3/h_4=2$。$p$ 的计算公式为：\n$$\np = \\frac{\\ln(E_2(N_3) / E_2(N_4))}{\\ln(2)}\n$$\n对于一阶格式，预计会得到 $p \\approx 1$。下面的 Python 代码实现了这整个过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D radiative transfer problem using a first-order control-volume\n    method, performs a grid refinement study, and computes the observed order\n    of accuracy for several test cases.\n    \"\"\"\n    \n    # Test suite: each tuple is (L, kappa, mu_b, I_0)\n    test_cases = [\n        (1.0, 1.0, 1.0, 1.0),   # Case A\n        (1.0, 1.0, 0.2, 1.0),   # Case B\n        (0.2, 20.0, 0.8, 2.0)   # Case C\n    ]\n    \n    # Mesh refinement sequence\n    N_sequence = [10, 20, 40, 80]\n    \n    # List to store the calculated order of accuracy for each case\n    p_results = []\n    \n    for case in test_cases:\n        L, kappa, mu_b, I_0 = case\n        \n        E2_errors = []\n        for N in N_sequence:\n            # 1. Setup mesh and cell center coordinates\n            dx = L / N\n            # Cell centers x_i are at (i-1/2)*dx for i=1,...,N\n            # In 0-based Python indexing, this is (i+0.5)*dx for i=0,...,N-1\n            x_centers = (np.arange(N) + 0.5) * dx\n            \n            # 2. Compute the analytical solution at cell centers for reference\n            I_exact = I_0 * np.exp(-kappa * x_centers / mu_b)\n            \n            # 3. Compute the numerical solution using the derived marching scheme\n            I_numerical = np.zeros(N)\n            # The upwind value for the first cell is the boundary condition\n            I_prev = I_0\n            # Pre-compute the marching coefficient\n            marching_coeff = mu_b / (mu_b + kappa * dx)\n            \n            for i in range(N):\n                I_numerical[i] = marching_coeff * I_prev\n                # Update the upwind value for the next cell\n                I_prev = I_numerical[i]\n                \n            # 4. Calculate the relative L2 error norm\n            # The L2 norm is sqrt(sum(vector**2))\n            error_norm = np.linalg.norm(I_numerical - I_exact)\n            exact_norm = np.linalg.norm(I_exact)\n            \n            if exact_norm == 0:\n                # This case is unlikely here but is a good practice to avoid division by zero\n                E2 = 0.0 if error_norm == 0 else np.inf\n            else:\n                E2 = error_norm / exact_norm\n                \n            E2_errors.append(E2)\n            \n        # 5. Calculate the observed order of accuracy 'p'\n        # The calculation uses the last two meshes, N=40 and N=80.\n        # These correspond to indices 2 and 3 in the E2_errors list.\n        # The grid refinement ratio is h_N3/h_N4 = (L/N3)/(L/N4) = N4/N3 = 2.\n        refinement_ratio = float(N_sequence[3]) / N_sequence[2]\n        p = np.log(E2_errors[2] / E2_errors[3]) / np.log(refinement_ratio)\n        p_results.append(p)\n        \n    # Final print statement in the exact required format.\n    # The results are rounded to six decimal places.\n    print(f\"[{','.join(f'{p:.6f}' for p in p_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在一维验证的基础上，我们将问题扩展到二维，这带来了新的数值挑战。本练习的核心是“伪散射”现象，这是一种由空间和角度离散化相互作用引起的数值扩散。您将实现一个二维求解器，以量化一个准直光束穿过网格时产生的这种人为误差，从而深刻理解角度加密对于维持辐射传输方向性的重要性。",
            "id": "3945288",
            "problem": "本文考虑在方形真空介质域中，采用离散纵标法 (DOM) 对辐射传输方程 (RTE) 进行二维控制体积公式化。其基本原理是在非参与介质中的稳态、单色 RTE，该方程可简化为流方程。控制方程为 $ \\boldsymbol{s} \\cdot \\nabla I(\\boldsymbol{x}, \\boldsymbol{s}) = 0 $，其中 $I$ 是辐射强度，$ \\boldsymbol{s} = (\\mu, \\eta) $ 是传播方向，对于角度 $\\phi$，有 $\\mu = \\cos \\phi$ 和 $\\eta = \\sin \\phi$。在笛卡尔网格上的控制体积实现中，单元内的离散平衡由穿过单元面的通量导出。采用一阶迎风（阶梯）差分格式，单元面上的强度由上游单元中心值近似。这产生了一个离散流更新，它混合了两个上游相邻单元的贡献，这种方法已知会引入伪散射。当准直光束穿过网格时，伪散射表现为非物理性的横向扩散。\n\n使用控制体积离散化，考虑一个无量纲尺寸为 $ L_x = 1 $ 和 $ L_y = 1 $ 的单位方形域，该域被离散为 $ N_x \\times N_y $ 个单元，其中 $ \\Delta x = L_x / N_x $ 和 $ \\Delta y = L_y / N_y $。一束无量纲强度为 $ I_b $ 的准直光束以真实方向 $ \\phi_{\\mathrm{true}} $ (单位为弧度) 从左边界上的点 $ (x=0, y=y_0) $ 入射，其中 $0  \\phi_{\\mathrm{true}}  \\pi/2$，因此 $\\mu_{\\mathrm{true}} = \\cos \\phi_{\\mathrm{true}} > 0$ 且 $\\eta_{\\mathrm{true}} = \\sin \\phi_{\\mathrm{true}} > 0$。离散纵标法 (DOM) 使用第一象限中的一组有限的离散角度，定义为 $ \\{ \\phi_k \\}_{k=0}^{N-1} $，其中 $\\phi_k = (k + 0.5)\\Delta$，$ \\Delta = \\frac{\\pi/2}{N} $，$ N $ 是角方向的数量。边界上的光束被映射到与 $ \\phi_{\\mathrm{true}} $ 最接近的离散纵标 $ \\phi_d $，然后使用阶梯差分法在网格中进行推进。\n\n从方向为 $ (\\mu,\\eta) $ 的稳态真空流动的控制体积平衡出发，单元中心强度 $ I_{i,j} $ 的离散阶梯差分更新公式为\n$$\nI_{i,j} = \\frac{ \\frac{\\mu}{\\Delta x} I_{i-1,j} + \\frac{\\eta}{\\Delta y} I_{i,j-1} }{ \\frac{\\mu}{\\Delta x} + \\frac{\\eta}{\\Delta y} },\n$$\n适用于 $ i \\ge 0 $ 和 $ j \\ge 0 $，其中左边界有上游边界条件 $I_{-1,j}$，下边界有上游边界条件 $I_{i,-1}$。左边界条件强制 $I_{0, j_0} = I_b$，其中 $j_0 = \\lfloor y_0 / \\Delta y \\rfloor$，对于 $j \\ne j_0$ 则 $I_{0,j} = 0$。下边界条件为 $I_{i,0} = 0$ (对于 $i > 0$)，域内其余部分初始值为 $0$。推进顺序必须遵循来自 $ (i-1,j) $ 和 $ (i,j-1) $ 的上游依赖关系。\n\n定义理想离散光束路径为从 $ (0,y_0) $ 出发，沿 $ \\phi_{\\mathrm{true}} $ 方向传播的直线特征线所穿过的所有单元内部的集合。该路径可以通过使用参数化直线 $ (x(t), y(t)) = ( \\mu_{\\mathrm{true}} t, y_0 + \\eta_{\\mathrm{true}} t ) $ (其中 $ t \\ge 0 $) 的网格遍历算法来构建，根据先到达垂直网格线还是水平网格线来移动到下一个单元，直到路径离开域。访问过的单元索引集合即为理想路径 $ \\mathcal{P}_{\\mathrm{ideal}} $。\n\n将伪散射误差量化为位于理想路径之外的计算强度占总计算强度的分数：\n$$\nE = \\frac{ \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} I_{i,j} \\, \\chi_{(i,j) \\notin \\mathcal{P}_{\\mathrm{ideal}}} }{ \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} I_{i,j} },\n$$\n其中 $ \\chi $ 是指示函数。此误差既包括阶梯差分引起的空间伪散射，也包括因映射到 $ \\phi_d $ 而产生的方向不匹配。证明增加 $ N $ (角度加密) 会使 $ \\phi_d $ 更接近 $ \\phi_{\\mathrm{true}} $，从而减小阶梯更新中的横向混合权重，进而减小 $ E $。\n\n角度单位必须是弧度。所有量均为无量纲。您的程序必须实现所述的控制体积 DOM 阶梯差分和理想路径构建，为每个测试案例计算 $ E $，并以浮点数形式输出结果。\n\n使用以下测试套件：\n- 案例 $ 1 $ (常规角度加密)：$ N_x = 30 $，$ N_y = 30 $，$ y_0 = 0.5 $，$ I_b = 1.0 $，$ \\phi_{\\mathrm{true}} = 0.7 $，$ N = 8 $。\n- 案例 $ 2 $ (角度加密)：$ N_x = 30 $，$ N_y = 30 $，$ y_0 = 0.5 $，$ I_b = 1.0 $，$ \\phi_{\\mathrm{true}} = 0.7 $，$ N = 32 $。\n- 案例 $ 3 $ (方向对齐边缘情况)：$ N_x = 30 $，$ N_y = 30 $，$ y_0 = 0.5 $，$ I_b = 1.0 $，$ N = 8 $，其中 $ \\phi_{\\mathrm{true}} $ 被精确选择为离散纵标之一，即 $ \\phi_{\\mathrm{true}} = (k+0.5)\\Delta $，其中 $ k = 2 $，所以 $ \\Delta = \\frac{\\pi}{16} $ 且 $ \\phi_{\\mathrm{true}} = \\frac{5\\pi}{32} $。\n- 案例 $ 4 $ (粗网格，斜光束)：$ N_x = 10 $，$ N_y = 10 $，$ y_0 = 0.5 $，$ I_b = 1.0 $，$ \\phi_{\\mathrm{true}} = 1.05 $，$ N = 32 $。\n\n对于每个案例，计算 $ E $ 并以浮点数表示。您的程序应生成一行输出，其中包含一个逗号分隔的列表，用方括号括起来 (例如，$ [e_1,e_2,e_3,e_4] $），其中每个 $ e_i $ 是为案例 $ i $ 计算出的 $ E $。",
            "solution": "用户请求解决一个涉及辐射传输方程 (RTE) 的离散纵标法 (DOM) 的计算问题。第一步是验证问题陈述的有效性。\n\n### 步骤 1：提取已知信息\n- **控制方程**：稳态、单色、非参与（真空）介质中的辐射传输方程，$ \\boldsymbol{s} \\cdot \\nabla I(\\boldsymbol{x}, \\boldsymbol{s}) = 0 $，其中 $I$ 是辐射强度，$\\boldsymbol{s} = (\\mu, \\eta)$ 是方向向量，$\\mu = \\cos \\phi$ 且 $\\eta = \\sin \\phi$。\n- **域和网格**：一个单位方形域，$L_x = 1$ 和 $L_y = 1$，被离散化为 $N_x \\times N_y$ 个尺寸为 $\\Delta x = L_x / N_x$ 和 $\\Delta y = L_y / N_y$ 的单元。\n- **数值方法**：采用一阶迎风（阶梯）差分格式的控制体积法。\n- **离散更新方程**：对于单元 $(i,j)$ 和方向 $\\mu>0, \\eta>0$：$$ I_{i,j} = \\frac{ \\frac{\\mu}{\\Delta x} I_{i-1,j} + \\frac{\\eta}{\\Delta y} I_{i,j-1} }{ \\frac{\\mu}{\\Delta x} + \\frac{\\eta}{\\Delta y} } $$\n- **边界条件**：一束强度为 $I_b$ 的准直光束以真实方向 $\\phi_{\\mathrm{true}} \\in (0, \\pi/2)$ 从 $(x=0, y=y_0)$ 入射。这通过在左边界 ($i=0$) 上，为索引为 $j_0 = \\lfloor y_0 / \\Delta y \\rfloor$ 的单元设置入射强度为 $I_b$，所有其他边界单元为零来模拟。下边界 ($j=0$) 的入射强度为零。\n- **角度离散化 (DOM)**：连续角度 $\\phi$ 被离散化为集合 $\\{ \\phi_k \\}_{k=0}^{N-1}$，其中 $\\phi_k = (k + 0.5)\\Delta$ 且 $\\Delta = \\frac{\\pi/2}{N}$。光束的真实方向 $\\phi_{\\mathrm{true}}$ 被映射到最接近的离散纵标 $\\phi_d$。\n- **理想路径**：单元集合 $\\mathcal{P}_{\\mathrm{ideal}}$，其内部被源于 $(0, y_0)$ 且方向为 $\\phi_{\\mathrm{true}}$ 的直线所穿过。此路径使用网格遍历算法确定。\n- **伪散射误差度量**：$$ E = \\frac{ \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} I_{i,j} \\, \\chi_{(i,j) \\notin \\mathcal{P}_{\\mathrm{ideal}}} }{ \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} I_{i,j} } $$ 其中 $\\chi$ 是指示函数。\n- **测试案例**：\n    1.  $N_x = 30$, $N_y = 30$, $y_0 = 0.5$, $I_b = 1.0$, $\\phi_{\\mathrm{true}} = 0.7$, $N = 8$。\n    2.  $N_x = 30$, $N_y = 30$, $y_0 = 0.5$, $I_b = 1.0$, $\\phi_{\\mathrm{true}} = 0.7$, $N = 32$。\n    3.  $N_x = 30$, $N_y = 30$, $y_0 = 0.5$, $I_b = 1.0$, $N = 8$, $\\phi_{\\mathrm{true}} = 5\\pi/32$。\n    4.  $N_x = 10$, $N_y = 10$, $y_0 = 0.5$, $I_b = 1.0$, $\\phi_{\\mathrm{true}} = 1.05$, $N = 32$。\n\n### 步骤 2：使用提取的已知信息进行验证\n- **科学依据**：该问题基于辐射传输的基本原理和计算工程中使用的标准数值方法（控制体积法、离散纵标法、阶梯差分法）。“伪散射”现象是这类格式中一个有据可查的数值伪影。该问题在科学上是合理的。\n- **适定性**：该问题描述了一个具有指定流入边界条件的输运方程的推进过程。对于第一象限中的方向（$\\mu>0, \\eta>0$），任何点 $(i,j)$ 的解仅取决于先前索引 $(i-1,j)$ 和 $(i,j-1)$ 处的值。这种结构保证了唯一且稳定的解。误差度量定义清晰。\n- **客观性**：该问题要求基于完全指定的算法和参数计算一个定量度量 $E$。它没有主观性。\n\n问题陈述在计算热工学的指定领域内提供了一个清晰、可验证且有一定难度的任务。尽管边界条件的表述（“$I_{0, j_0} = I_b$”）与面通量或虚拟单元的正式定义相比稍显不精确，但在实现推进方案的背景下，其意图是明确的。这可以解释为从边界源为第一列单元设置上游强度。因此，该问题被认为是有效的。\n\n### 步骤 3：结论与行动\n问题有效。将提供一个解决方案。\n\n### 解决方案\n\n该问题要求量化伪散射，这是辐射传输方程的离散纵标法控制体积实现中的一种数值伪影。解决方案涉及基于所提供的方程和定义实施数值模拟。\n\n**原理与离散化**\n该方法的基础是辐射能量守恒。对于非参与介质和稳态，RTE 简化为 $\\boldsymbol{s} \\cdot \\nabla I = 0$，表明强度 $I$ 沿方向 $\\boldsymbol{s}$ 的特征线是恒定的。控制体积法将此方程的积分形式在尺寸为 $\\Delta x \\times \\Delta y$ 的网格单元 $V_{i,j}$ 上离散化。使用散度定理，离散方向 $\\boldsymbol{s}_d = (\\mu_d, \\eta_d)$ 的方程为：\n$$ \\int_{V_{i,j}} \\nabla \\cdot (\\boldsymbol{s}_d I) \\, dV = \\oint_{\\partial V_{i,j}} I (\\boldsymbol{s}_d \\cdot \\boldsymbol{n}) \\, dA = 0 $$\n其中 $\\boldsymbol{n}$ 是单元边界 $\\partial V_{i,j}$ 的外法线向量。该平衡式展开为：\n$$ \\mu_d (I_{e} - I_{w})\\Delta y + \\eta_d (I_{n} - I_{s})\\Delta x = 0 $$\n这里，$I_w, I_e, I_s, I_n$ 分别代表单元西、东、南、北面上的平均强度。\n\n**一阶迎风（阶梯）格式**\n阶梯格式使用来自上游方向的单元中心强度来近似单元面强度。对于第一象限（$\\mu_d > 0, \\eta_d > 0$），信息从负 $x$ 和 $y$ 方向流向正 $x$ 和 $y$ 方向。因此，流入面强度由相邻的上游单元近似，$I_w \\approx I_{i-1,j}$ 和 $I_s \\approx I_{i,j-1}$。流出面强度由单元自身的强度近似，$I_e \\approx I_{i,j}$ 和 $I_n \\approx I_{i,j}$。将这些代入平衡方程得到：\n$$ \\mu_d (I_{i,j} - I_{i-1,j})\\Delta y + \\eta_d (I_{i,j} - I_{i,j-1})\\Delta x = 0 $$\n解出 $I_{i,j}$ 得到指定的更新公式：\n$$ I_{i,j} = \\frac{ (\\mu_d/\\Delta x) I_{i-1,j} + (\\eta_d/\\Delta y) I_{i,j-1} }{ (\\mu_d/\\Delta x) + (\\eta_d/\\Delta y) } $$\n该方程表明，一个单元中的强度是两个上游单元强度的加权平均值。这个平均过程是数值扩散或“伪散射”的来源，因为它导致最初的准直光束在以倾斜角度穿过网格时发生横向扩散。\n\n**算法实现**\n对于每个测试案例，解决方案通过以下步骤实现：\n1.  **设置与角度离散化**：定义网格参数（$\\Delta x, \\Delta y$）。生成离散角度集 $\\{\\phi_k\\}$。通过找到使 $|\\phi_k - \\phi_{\\mathrm{true}}|$ 最小的 $\\phi_k$，将真实光束方向 $\\phi_{\\mathrm{true}}$ 映射到最接近的离散纵标 $\\phi_d$。计算相应的方向余弦 $(\\mu_d, \\eta_d)$。\n2.  **理想路径计算**：理想路径 $\\mathcal{P}_{\\mathrm{ideal}}$ 是真实、无散射的光束会穿过的网格单元集合。这使用稳健的网格遍历算法（如 Amanatides-Woo 算法）计算。从入口点 $(0, y_0)$ 开始，算法迭代地找到与真实方向 $\\phi_{\\mathrm{true}}$ 的直线相交的下一个单元，直到直线离开域。\n3.  **DOM 模拟**：初始化一个大小为 $N_x \\times N_y$ 的数组 `I` 为零。模拟按照尊重数据依赖性的顺序在网格中推进。对于 $\\mu_d>0, \\eta_d>0$，这意味着从 $i=0$ 到 $N_x-1$ 和 $j=0$ 到 $N_y-1$ 进行迭代。在每个单元 $(i,j)$，从左侧单元 $(i-1,j)$ 和底部单元 $(i,j-1)$ 获取上游强度。对于边界上的单元（$i=0$ 或 $j=0$），上游值由问题的边界条件提供。具体来说，对于源单元（$i=0, j=j_0$），来自左侧的上游强度为 $I_b$，否则为 $0$。来自底部（$j=0$）的上游强度始终为 $0$。然后使用离散更新公式计算单元强度 $I_{i,j}$。\n4.  **误差量化**：在强度场 $I$ 完全计算完毕后，计算域中的总强度为 $\\sum I_{i,j}$。同时，对所有*不在*理想路径上的单元的强度求和，即 $\\sum_{(i,j) \\notin \\mathcal{P}_{\\mathrm{ideal}}} I_{i,j}$。伪散射误差 $E$ 是后者与前者的比值。这量化了数值上“泄漏”出正确物理路径的辐射能量的比例。\n\n通过对每个测试案例执行此过程，我们可以观察伪散射的行为，包括其随角度加密而减小（案例 1 vs. 2），以及其对网格分辨率和光束角度的依赖性（案例 4）。案例 3 说明，即使方向完全对齐（$\\phi_{\\mathrm{true}} = \\phi_d$），阶梯格式的空间离散化仍然会引起伪散射。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_ideal_path(Nx, Ny, dx, dy, y0, phi_true):\n    \"\"\"\n    Calculates the set of ideal path cells using an Amanatides-Woo-like algorithm.\n    This algorithm efficiently finds all grid cells a ray passes through.\n    \"\"\"\n    path = set()\n    mu_true = np.cos(phi_true)\n    eta_true = np.sin(phi_true)\n\n    # Initial position and cell index. The ray starts at (0, y0) on the left boundary.\n    cx, cy = 0.0, y0\n    i = 0\n    j = int(np.floor(cy / dy))\n    \n    # Clamp initial cell index to be within grid bounds\n    if j  0: j = 0\n    if j >= Ny: j = Ny - 1\n    \n    path.add((i, j))\n\n    # For 0  phi_true  pi/2, the ray moves in +i and +j directions\n    step_i = 1\n    step_j = 1\n\n    # Time to cross next grid lines from the starting point (cx, cy)\n    next_vert_boundary = (i + 1) * dx\n    next_horiz_boundary = (j + 1) * dy\n    \n    # Avoid division by zero, though problem constraints make mu_true, eta_true > 0\n    t_max_x = (next_vert_boundary - cx) / mu_true if mu_true > 1e-12 else float('inf')\n    t_max_y = (next_horiz_boundary - cy) / eta_true if eta_true > 1e-12 else float('inf')\n\n\n    # Time step required to cross one cell width or height\n    t_delta_x = dx / mu_true if mu_true > 1e-12 else float('inf')\n    t_delta_y = dy / eta_true if eta_true > 1e-12 else float('inf')\n\n    while True:\n        if t_max_x  t_max_y:\n            t_max_x += t_delta_x\n            i += step_i\n        else:\n            t_max_y += t_delta_y\n            j += step_j\n        \n        if i >= Nx or j >= Ny:\n            break\n            \n        path.add((i, j))\n        \n    return path\n\ndef solve_single_case(Nx, Ny, y0, Ib, phi_true, N):\n    \"\"\"\n    Solves for the false scattering error E for a single test case.\n    \"\"\"\n    Lx, Ly = 1.0, 1.0\n    dx, dy = Lx / Nx, Ly / Ny\n\n    # 1. Angular Discretization\n    delta_phi = (np.pi / 2.0) / N\n    phi_k = np.array([(k + 0.5) * delta_phi for k in range(N)])\n    \n    # Find nearest discrete angle phi_d\n    idx_d = np.argmin(np.abs(phi_k - phi_true))\n    phi_d = phi_k[idx_d]\n    mu_d = np.cos(phi_d)\n    eta_d = np.sin(phi_d)\n    \n    # 2. Ideal Path Calculation\n    ideal_path = calculate_ideal_path(Nx, Ny, dx, dy, y0, phi_true)\n    \n    # 3. Control-Volume DOM Simulation\n    I = np.zeros((Nx, Ny))\n    j0 = int(np.floor(y0 / dy))\n    \n    # Pre-calculate weights for the update formula\n    weight_x = mu_d / dx\n    weight_y = eta_d / dy\n    weight_total = weight_x + weight_y\n\n    # Marching calculation for the first quadrant (mu > 0, eta > 0)\n    for i in range(Nx):\n        for j in range(Ny):\n            # Get upwind intensities based on boundary conditions\n            I_upwind_x = I[i - 1, j] if i > 0 else (Ib if j == j0 else 0.0)\n            I_upwind_y = I[i, j - 1] if j > 0 else 0.0\n            \n            # Apply step-differencing update formula\n            if weight_total > 1e-12:\n                I[i, j] = (weight_x * I_upwind_x + weight_y * I_upwind_y) / weight_total\n            else:\n                I[i, j] = 0.0\n            \n    # 4. Error Quantification\n    total_intensity = np.sum(I)\n    \n    if total_intensity  1e-12:\n        return 0.0\n\n    outside_intensity = 0.0\n    for i in range(Nx):\n        for j in range(Ny):\n            if (i, j) not in ideal_path:\n                outside_intensity += I[i, j]\n                \n    error = outside_intensity / total_intensity\n    return error\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1: (Nx, Ny, y0, Ib, phi_true, N)\n        (30, 30, 0.5, 1.0, 0.7, 8),\n        # Case 2: (refined angles)\n        (30, 30, 0.5, 1.0, 0.7, 32),\n        # Case 3: (aligned direction)\n        (30, 30, 0.5, 1.0, (5.0 * np.pi / 32.0), 8),\n        # Case 4: (coarse grid, oblique beam)\n        (10, 10, 0.5, 1.0, 1.05, 32)\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, Ny, y0, Ib, phi_true, N = case\n        result = solve_single_case(Nx, Ny, y0, Ib, phi_true, N)\n        results.append(result)\n\n    # Format the final output string as a list of floats (as strings)\n    formatted_results = [str(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "实际工程问题通常涉及复杂的几何形状，需要使用非结构化网格。在这些网格上实现离散坐标法需要一个通用的方法来确定计算顺序，以确保在上游单元的信息可用之前，不处理下游单元。本练习将此“扫掠”问题构建为一个图论问题，并指导您使用拓扑排序算法来为任意方向和网格生成一个有效的计算顺序，这是开发高级计算流体动力学（CFD）求解器的一项核心技能。",
            "id": "3945345",
            "problem": "在计算热工学领域，您的任务是为离散纵标法（DOM）设计一种控制体扫描排序。离散纵标法（DOM）通过将角域离散化为一组有限的方向来求解辐射传输方程（RTE），并对空间域进行扫描，以确保在计算下游单元中的未知数之前，上游信息已经可用。对于一个固定的纵标方向向量 $\\vec{s}_m \\in \\mathbb{R}^d$（其中 $d \\in \\{2,3\\}$），请在非结构化网格上构建一个控制体单元的拓扑排序，使得每个单元都在其所有上游邻居之后出现。\n\n从辐射传输方程沿单一纵标方向 $\\vec{s}_m$ 的基本输运出发，其中流项 $ \\vec{s}_m \\cdot \\nabla I(\\vec{x}, \\vec{s}_m) $ 意味着位置 $\\vec{x}$ 处的强度依赖于 $-\\vec{s}_m$ 方向上的上游值。在控制体离散化中，这强制要求对于两个相邻单元共享的每个内表面，相对于 $\\vec{s}_m$ 位于下游的单元必须在位于上游的单元之后处理。\n\n有向依赖图定义如下。假设有 $N$ 个单元，索引为整数 $0,1,\\dots,N-1$。每个单元 $i$ 都有一个中心位置 $\\vec{x}_i \\in \\mathbb{R}^d$。非结构化网格的连接性以一组无向邻居对 $(i,j)$ 的形式给出，表示单元 $i$ 和单元 $j$ 共享一个公共面。对于每个无向邻居对 $(i,j)$，如果 $\\vec{s}_m \\cdot (\\vec{x}_j - \\vec{x}_i) > 0$，则创建一条从 $i$ 到 $j$ 的有向边；如果 $\\vec{s}_m \\cdot (\\vec{x}_j - \\vec{x}_i)  0$，则创建一条从 $j$ 到 $i$ 的有向边；如果 $\\vec{s}_m \\cdot (\\vec{x}_j - \\vec{x}_i) = 0$，则不创建有向边。对这个有向图执行拓扑排序。当有多个单元可供处理时（入度为零），通过选择 $\\phi_i := \\vec{s}_m \\cdot \\vec{x}_i$ 值最小的单元来打破平局；如果 $\\phi_i$ 值仍然相同，则按最小的单元索引打破平局。\n\n您的程序必须实现此构造，并为下面的每个测试用例生成一个扫描排序。对于每个测试用例，输出是拓扑排序后的单元索引列表。所有测试用例的最终输出必须是单行，包含一个由这些列表组成的、用逗号分隔的列表，并用方括号括起来。每个列表必须精确地包含所有单元索引一次，并按计算出的顺序排列。所有坐标均无单位，方向是无单位向量；由于方向是以笛卡尔分量给出的，因此无需指定角度单位。\n\n测试套件：\n- 案例 $1$（结构化二维网格，水平扫描）：\n  - 单元：索引 $0,1,2,3$。\n  - 中心点：$\\vec{x}_0=(0,0)$, $\\vec{x}_1=(1,0)$, $\\vec{x}_2=(0,1)$, $\\vec{x}_3=(1,1)$。\n  - 无向邻居：$(0,1)$, $(2,3)$, $(0,2)$, $(1,3)$。\n  - 方向：$\\vec{s}_m=(1,0)$。\n\n- 案例 $2$（结构化二维网格，对角扫描）：\n  - 单元：索引 $0,1,2,3$。\n  - 中心点：$\\vec{x}_0=(0,0)$, $\\vec{x}_1=(1,0)$, $\\vec{x}_2=(0,1)$, $\\vec{x}_3=(1,1)$。\n  - 无向邻居：$(0,1)$, $(2,3), (0,2), (1,3)$。\n  - 方向：$\\vec{s}_m=\\left(\\frac{1}{\\sqrt{2}},\\frac{1}{\\sqrt{2}}\\right)$。\n\n- 案例 $3$（一维链，反向扫描）：\n  - 单元：索引 $0,1,2$。\n  - 中心点：$\\vec{x}_0=(0,0)$, $\\vec{x}_1=(1,0)$, $\\vec{x}_2=(2,0)$。\n  - 无向邻居：$(0,1)$, $(1,2)$。\n  - 方向：$\\vec{s}_m=(-1,0)$。\n\n- 案例 $4$（垂直方向导致在唯一的邻居上没有边）：\n  - 单元：索引 $0,1$。\n  - 中心点：$\\vec{x}_0=(0,0)$, $\\vec{x}_1=(1,0)$。\n  - 无向邻居：$(0,1)$。\n  - 方向：$\\vec{s}_m=(0,1)$。\n\n- 案例 $5$（单个孤立单元）：\n  - 单元：索引 $0$。\n  - 中心点：$\\vec{x}_0=(0,0)$。\n  - 无向邻居：无。\n  - 方向：$\\vec{s}_m=(1,0)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素是一个整数列表，代表相应案例的扫描顺序（例如，$[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]$）。每个测试用例的结果必须是一个整数列表。",
            "solution": "对用户提供的问题陈述进行严格的验证过程。\n\n### 步骤 1：提取已知信息\n\n- **任务**：为离散纵标法（DOM）设计控制体扫描排序。\n- **方法**：在非结构化网格上构建一个控制体单元的拓扑排序。\n- **基本原理**：对于固定的纵标方向 $\\vec{s}_m \\in \\mathbb{R}^d$，扫描必须在处理下游单元之前先处理上游单元。流项 $\\vec{s}_m \\cdot \\nabla I(\\vec{x}, \\vec{s}_m)$ 意味着对 $-\\vec{s}_m$ 方向上的上游值存在依赖。\n- **图定义**：\n    - **节点**：$N$ 个单元，索引为 $0, 1, \\dots, N-1$。每个单元 $i$ 有一个中心位置 $\\vec{x}_i \\in \\mathbb{R}^d$。\n    - **初始连接性**：一组无向邻居对 $(i,j)$。\n    - **有向边规则**：对于每一对 $(i,j)$：\n        - 如果 $\\vec{s}_m \\cdot (\\vec{x}_j - \\vec{x}_i) > 0$，创建一条从 $i$ 到 $j$ 的有向边。\n        - 如果 $\\vec{s}_m \\cdot (\\vec{x}_j - \\vec{x}_i)  0$，创建一条从 $j$ 到 $i$ 的有向边。\n        - 如果 $\\vec{s}_m \\cdot (\\vec{x}_j - \\vec{x}_i) = 0$，不创建有向边。\n- **排序算法**：对构建的有向图执行拓扑排序。\n- **平局处理规则**：当多个单元的入度为零时：\n    1.  选择 $\\phi_i := \\vec{s}_m \\cdot \\vec{x}_i$ 值最小的单元。\n    2.  如果 $\\phi_i$ 值相同，选择单元索引最小的单元。\n- **测试用例**：\n    - **案例 1**：$N=4$ 个单元，$\\vec{x}_0=(0,0), \\vec{x}_1=(1,0), \\vec{x}_2=(0,1), \\vec{x}_3=(1,1)$。邻居：$(0,1), (2,3), (0,2), (1,3)$。方向：$\\vec{s}_m=(1,0)$。\n    - **案例 2**：$N=4$ 个单元，$\\vec{x}_0=(0,0), \\vec{x}_1=(1,0), \\vec{x}_2=(0,1), \\vec{x}_3=(1,1)$。邻居：$(0,1), (2,3), (0,2), (1,3)$。方向：$\\vec{s}_m=(\\frac{1}{\\sqrt{2}},\\frac{1}{\\sqrt{2}})$。\n    - **案例 3**：$N=3$ 个单元，$\\vec{x}_0=(0,0), \\vec{x}_1=(1,0), \\vec{x}_2=(2,0)$。邻居：$(0,1), (1,2)$。方向：$\\vec{s}_m=(-1,0)$。\n    - **案例 4**：$N=2$ 个单元，$\\vec{x}_0=(0,0), \\vec{x}_1=(1,0)$。邻居：$(0,1)$。方向：$\\vec{s}_m=(0,1)$。\n    - **案例 5**：$N=1$ 个单元，$\\vec{x}_0=(0,0)$。邻居：无。方向：$\\vec{s}_m=(1,0)$。\n- **输出格式**：单行输出，包含一个由列表组成的、用逗号分隔的列表，并用方括号括起来，例如 `[[...],[...]]`。\n\n### 步骤 2：使用提取的已知信息进行验证\n\n1.  **科学依据**：该问题在计算热工学中有坚实的理论基础。离散纵标法是求解辐射传输方程的标准技术。基于方向向量定义的上游/下游依赖关系来扫描计算域的核心思想，是数值求解双曲型输运方程的基础。构建依赖图并执行拓扑排序是建立有效计算序列的正确且标准的过程。\n2.  **良构性**：该问题是良构的。图的构建规则是明确的。创建的图是一个有向无环图（DAG）。为了证明这一点，假设存在一个环：$i_1 \\to i_2 \\to \\dots \\to i_k \\to i_1$。根据边的定义，这意味着 $\\vec{s}_m \\cdot (\\vec{x}_{i_2} - \\vec{x}_{i_1}) > 0$，$\\vec{s}_m \\cdot (\\vec{x}_{i_3} - \\vec{x}_{i_2}) > 0$，...，$\\vec{s}_m \\cdot (\\vec{x}_{i_1} - \\vec{x}_{i_k}) > 0$。将这些不等式相加得到 $\\sum_{j=1}^{k} \\vec{s}_m \\cdot (\\vec{x}_{i_{j+1}} - \\vec{x}_{i_j}) > 0$，其中 $i_{k+1}=i_1$。根据点积的线性性质，这等价于 $\\vec{s}_m \\cdot \\sum_{j=1}^{k} (\\vec{x}_{i_{j+1}} - \\vec{x}_{i_j}) > 0$。这个和是一个伸缩级数，结果为零向量：$(\\vec{x}_{i_2} - \\vec{x}_{i_1}) + \\dots + (\\vec{x}_{i_1} - \\vec{x}_{i_k}) = \\vec{0}$。这导致了矛盾 $\\vec{s}_m \\cdot \\vec{0} > 0$，即 $0 > 0$。因此，不可能存在环。在有向无环图上总是可以进行拓扑排序。明确的平局处理规则（首先按 $\\phi_i$，然后按单元索引）确保了最终的拓扑排序是唯一的。\n3.  **客观性**：问题以精确、客观的数学和算法术语陈述。\n4.  **完整性和一致性**：每个测试用例都提供了所有必要的信息（单元中心、连接性、方向向量）。图的构建和排序规则明确无歧义。\n5.  **无其他缺陷**：该问题没有其他无效标志。它是一个计算科学领域中形式化的、可解的问题。\n\n### 步骤 3：结论与行动\n\n问题**有效**。将提供一个解决方案。\n\n### 解决方案\n\n该问题要求实现一个特定算法，以确定离散化域中单元的计算顺序，这个过程在离散纵标法（DOM）的背景下被称为“扫描”。这本质上是一个图论问题：基于物理依赖关系构建一个有向图，然后找到其节点的拓扑排序。\n\n**1. 依赖图的构建**\n\n辐射传输方程在离散化后，会在相邻的控制体（单元）之间产生依赖关系。对于给定的离散方向 $\\vec{s}_m$，一个单元中的强度依赖于其“上游”邻居的强度。如果单元 $j$ 沿着 $\\vec{s}_m$ 方向比单元 $i$ 更远，则称 $j$ 在 $i$ 的下游。这种几何关系可以用点积来形式化。给定两个相邻单元 $i$ 和 $j$，其中心分别为 $\\vec{x}_i$ 和 $\\vec{x}_j$，从 $i$ 到 $j$ 的向量是 $\\vec{v}_{ij} = \\vec{x}_j - \\vec{x}_i$。这个向量在方向 $\\vec{s}_m$ 上的投影由 $\\vec{s}_m \\cdot \\vec{v}_{ij}$ 给出。\n\n- 如果 $\\vec{s}_m \\cdot (\\vec{x}_j - \\vec{x}_i) > 0$，单元 $j$ 在 $i$ 的下游。信息从 $i$ 流向 $j$。因此，我们必须在处理 $j$ 之前处理 $i$，这由一个有向边 $i \\to j$ 表示。\n- 如果 $\\vec{s}_m \\cdot (\\vec{x}_j - \\vec{x}_i)  0$，单元 $i$ 在 $j$ 的下游。这意味着存在一条边 $j \\to i$。\n- 如果 $\\vec{s}_m \\cdot (\\vec{x}_j - \\vec{x}_i) = 0$，这些单元位于一个垂直于方向 $\\vec{s}_m$ 的平面上。沿此面没有直接的上游-下游依赖关系，因此在扫描中它们之间不创建有向边。\n\n如在验证过程中所证明，这个构建过程保证了一个有向无环图（DAG），这是拓扑排序的先决条件。\n\n**2. 带平局处理的拓扑排序**\n\n一个标准的拓扑排序算法是 Kahn 算法。它的工作原理是迭代地识别和处理入度为零的节点（即没有入边的节点）。\n\n标准算法如下：\n1.  计算图中每个节点的入度。\n2.  用所有入度为 $0$ 的节点初始化一个队列。\n3.  当队列不为空时：\n    a. 从队列中取出一个节点 $u$。将 $u$ 添加到拓扑排序列表中。\n    b. 对于 $u$ 的每个邻居 $v$：将 $v$ 的入度减一。如果 $v$ 的入度变为 $0$，则将 $v$ 入队。\n\n问题为步骤 2 和 3b 指定了一个严格的平局处理规则。当有多个节点可用时（入度为 $0$），它们不应按任意或先进先出（FIFO）的顺序处理。相反，下一个要处理的节点是 $\\phi_i = \\vec{s}_m \\cdot \\vec{x}_i$ 值最小的那个。如果 $\\phi_i$ 值出现平局，则通过选择单元索引 $i$ 最小的节点来进一步解决。\n\n这个复杂的平局处理要求意味着一个简单的队列是不够的。最小优先队列是合适的数据结构。每个单元 $i$ 被插入到优先队列中，其优先级键由元组 $(\\phi_i, i)$ 给出。Python 的 `heapq` 库实现了一个最小优先队列，它能自然地处理元组的字典序比较，从而正确地实现了指定的平局处理逻辑。\n\n**3. 算法实现**\n\n每个测试用例的最终算法是：\n1.  **初始化**：对于 $N$ 个单元，创建一个邻接表 `adj`（例如，列表的列表）和一个大小为 $N$ 的整数数组 `in_degree`，并初始化为零。\n2.  **图构建**：遍历每个无向邻居对 $(i, j)$：\n    - 计算 $d = \\vec{s}_m \\cdot (\\vec{x}_j - \\vec{x}_i)$。\n    - 如果 $d > 0$，添加边 $i \\to j$，方法是将 $j$ 附加到 `adj[i]` 并增加 `in_degree[j]`。\n    - 如果 $d  0$，添加边 $j \\to i$，方法是将 $i$ 附加到 `adj[j]` 并增加 `in_degree[i]`。\n3.  **优先级计算**：为所有单元 $k=0, \\dots, N-1$ 计算 $\\phi_k = \\vec{s}_m \\cdot \\vec{x}_k$。\n4.  **优先队列填充**：创建一个最小优先队列。对于每个 `in_degree[k]` 为 $0$ 的单元 $k$，将元组 $(\\phi_k, k)$ 推入优先队列。\n5.  **主循环**：\n    - 初始化一个空列表 `sorted_order`。\n    - 当优先队列不为空时：\n        a. 弹出具有最小优先级的元素 $(\\phi_u, u)$。\n        b. 将单元索引 $u$ 附加到 `sorted_order`。\n        c. 对于 `adj[u]` 中的每个邻居 $v$：\n            i. 将 `in_degree[v]` 减一。\n            ii. 如果 `in_degree[v]` 现在为 $0$，则将元组 $(\\phi_v, v)$ 推入优先队列。\n6.  **结果**：列表 `sorted_order` 包含了唯一且正确排序的单元索引序列。对所有测试用例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the sweep order computation,\n    and print the results in the required format.\n    \"\"\"\n    test_cases = [\n        # Case 1 (structured 2-D mesh, horizontal sweep)\n        {\n            \"cell_indices\": [0, 1, 2, 3],\n            \"centers\": np.array([[0,0], [1,0], [0,1], [1,1]], dtype=float),\n            \"neighbors\": [(0,1), (2,3), (0,2), (1,3)],\n            \"direction\": np.array([1,0], dtype=float)\n        },\n        # Case 2 (structured 2-D mesh, diagonal sweep)\n        {\n            \"cell_indices\": [0, 1, 2, 3],\n            \"centers\": np.array([[0,0], [1,0], [0,1], [1,1]], dtype=float),\n            \"neighbors\": [(0,1), (2,3), (0,2), (1,3)],\n            \"direction\": np.array([1/np.sqrt(2), 1/np.sqrt(2)], dtype=float)\n        },\n        # Case 3 (one-dimensional chain, reverse sweep)\n        {\n            \"cell_indices\": [0, 1, 2],\n            \"centers\": np.array([[0,0], [1,0], [2,0]], dtype=float),\n            \"neighbors\": [(0,1), (1,2)],\n            \"direction\": np.array([-1,0], dtype=float)\n        },\n        # Case 4 (perpendicular direction yields no edge)\n        {\n            \"cell_indices\": [0, 1],\n            \"centers\": np.array([[0,0], [1,0]], dtype=float),\n            \"neighbors\": [(0,1)],\n            \"direction\": np.array([0,1], dtype=float)\n        },\n        # Case 5 (single isolated cell)\n        {\n            \"cell_indices\": [0],\n            \"centers\": np.array([[0,0]], dtype=float),\n            \"neighbors\": [],\n            \"direction\": np.array([1,0], dtype=float)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_sweep_order(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # e.g., [[0, 2, 1, 3],[0, 1, 2, 3],...]\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_sweep_order(case):\n    \"\"\"\n    Computes the sweep order for a single test case.\n\n    Args:\n        case (dict): A dictionary containing the mesh and direction data.\n\n    Returns:\n        list: A list of cell indices in the topologically sorted sweep order.\n    \"\"\"\n    indices = case[\"cell_indices\"]\n    centers = case[\"centers\"]\n    neighbors = case[\"neighbors\"]\n    s_m = case[\"direction\"]\n    \n    num_cells = len(indices)\n    if num_cells == 0:\n        return []\n\n    adj = [[] for _ in range(num_cells)]\n    in_degree = [0] * num_cells\n\n    # Build the directed graph and compute in-degrees\n    for i, j in neighbors:\n        # Ensure i and j are valid indices\n        if i >= num_cells or j >= num_cells:\n            continue\n            \n        x_i = centers[i]\n        x_j = centers[j]\n        \n        dot_product = np.dot(s_m, x_j - x_i)\n        \n        # Add a small tolerance for floating point comparisons\n        if dot_product > 1e-9:\n            # Edge from i to j\n            adj[i].append(j)\n            in_degree[j] += 1\n        elif dot_product  -1e-9:\n            # Edge from j to i\n            adj[j].append(i)\n            in_degree[i] += 1\n    \n    # Calculate phi values for tie-breaking\n    phi_values = [np.dot(s_m, centers[i]) for i in range(num_cells)]\n\n    # Initialize a min-priority queue with all nodes having an in-degree of 0\n    # The priority is a tuple (phi_value, cell_index)\n    pq = []\n    for i in range(num_cells):\n        if in_degree[i] == 0:\n            heapq.heappush(pq, (phi_values[i], i))\n\n    sorted_order = []\n    \n    # Kahn's algorithm using a priority queue for tie-breaking\n    while pq:\n        _, u = heapq.heappop(pq)\n        sorted_order.append(u)\n        \n        for v in adj[u]:\n            in_degree[v] -= 1\n            if in_degree[v] == 0:\n                heapq.heappush(pq, (phi_values[v], v))\n                \n    return sorted_order\n\nsolve()\n```"
        }
    ]
}