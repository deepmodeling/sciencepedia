{
    "hands_on_practices": [
        {
            "introduction": "The first step in developing any computational model is verification: ensuring the code correctly solves the mathematical equations it is intended to. This practice provides a foundational exercise in code verification for a control-volume scheme. By implementing a solver for a simplified one-dimensional radiative transfer problem with a known analytical solution, you will learn to quantify the numerical error and confirm the scheme's theoretical order of accuracy through a grid refinement study .",
            "id": "3945290",
            "problem": "A collimated monochromatic beam enters a one-dimensional slab cavity filled with a homogeneous, purely absorbing, non-emitting, non-scattering medium. The slab occupies the spatial interval $x \\in [0,L]$. The intensity field $I(x,\\mu)$ is governed by the steady, one-dimensional Radiative Transfer Equation (RTE)\n$$\n\\mu \\,\\frac{\\mathrm{d} I(x,\\mu)}{\\mathrm{d} x} + \\kappa \\, I(x,\\mu) = 0,\n$$\nwhere $x$ is the spatial coordinate, $\\mu$ is the cosine of the propagation direction with respect to the $x$-axis, and $\\kappa$ is the absorption coefficient. A collimated beam is prescribed at the left boundary along a single discrete ordinate $\\mu_b \\in (0,1]$ with incoming intensity $I_0$, i.e., $I(0,\\mu_b)=I_0$, and the right boundary has no incoming radiation along $\\mu_b$.\n\nYou will implement a control-volume Discrete Ordinates Method (DOM) using a first-order upwind closure for a single discrete ordinate equal to the beam direction $\\mu_b$. Your implementation must be based on fundamental balance laws:\n- Integrate the RTE over a spatial control volume of width $\\Delta x$, from $x_{i-1/2}$ to $x_{i+1/2}$, to obtain a discrete balance between convective (streaming) fluxes and volumetric absorption.\n- Close the face intensities using an upwind approximation consistent with the sign of $\\mu_b$.\n- March from the inflow boundary to the outflow boundary to obtain the cell-averaged or cell-centered discrete intensity values $\\{ I_i \\}_{i=1}^N$ on a uniform mesh of $N$ control volumes.\n\nFor verification, use the analytic solution along the beam direction, obtainable directly from the RTE along characteristics, as a reference:\n$$\nI_{\\text{exact}}(x,\\mu_b) = I_0 \\, \\exp\\!\\left(-\\frac{\\kappa}{\\mu_b}\\, x\\right).\n$$\nUse the cell-center locations $x_i = \\left(i-\\tfrac{1}{2}\\right)\\Delta x$ with $\\Delta x = L/N$.\n\nDefine the error at cell centers by $e_i = I_i - I_{\\text{exact}}(x_i,\\mu_b)$. Quantify convergence using the relative $L_2$ norm of the intensity error\n$$\nE_2 = \\frac{\\left( \\sum_{i=1}^{N} e_i^2 \\, \\Delta x \\right)^{1/2}}{\\left( \\sum_{i=1}^{N} I_{\\text{exact}}(x_i,\\mu_b)^2 \\, \\Delta x \\right)^{1/2}}.\n$$\nPerform a grid refinement study with meshes $N \\in \\{N_1,N_2,N_3,N_4\\}$ where $N_{j+1}=2N_j$, and compute the observed order of accuracy using the last two meshes:\n$$\np = \\frac{\\ln\\!\\left( E_2(N_3) / E_2(N_4) \\right)}{\\ln\\!\\left( h_3 / h_4 \\right)}, \\quad h_j = \\frac{L}{N_j}.\n$$\n\nImplement a program that, for each test case defined below, computes $E_2$ on the sequence of meshes and returns the observed order $p$ as a floating-point number. All calculations are dimensionless with respect to the $L_2$ metric defined above. Angles are represented by direction cosine $\\mu_b$ (dimensionless). Intensities may be in any consistent unit since only relative errors are reported, but you must treat $I_0$ as a given scalar. Express the final reported observed orders as decimal floating-point numbers.\n\nTest suite (each tuple is $(L,\\kappa,\\mu_b,I_0)$):\n- Case A (happy path, normal incidence, moderate absorption): $(1.0,\\,1.0,\\,1.0,\\,1.0)$.\n- Case B (grazing incidence, moderate absorption, steeper characteristic): $(1.0,\\,1.0,\\,0.2,\\,1.0)$.\n- Case C (short cavity, optically thick, non-unit inflow): $(0.2,\\,20.0,\\,0.8,\\,2.0)$.\n\nFor each case, use meshes $N \\in \\{10,20,40,80\\}$ to compute $p$ from $N=40$ and $N=80$. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[p_{\\text{A}},p_{\\text{B}},p_{\\text{C}}]$, with each $p$ rounded to six decimal places.",
            "solution": "The problem is validated as scientifically sound, well-posed, and objective. It presents a standard verification exercise for a numerical method applied to the Radiative Transfer Equation. We will now proceed with the solution.\n\nThe objective is to derive and implement a first-order control-volume numerical scheme for the one-dimensional, steady-state Radiative Transfer Equation (RTE) for a purely absorbing medium, given by:\n$$\n\\mu_b \\,\\frac{\\mathrm{d} I(x,\\mu_b)}{\\mathrm{d} x} + \\kappa \\, I(x,\\mu_b) = 0\n$$\nHere, $I(x, \\mu_b)$ is the radiation intensity at spatial coordinate $x$ along the fixed direction cosine $\\mu_b  0$, and $\\kappa$ is the constant absorption coefficient.\n\nThe numerical solution is constructed by discretizing the domain $x \\in [0,L]$ into $N$ uniform control volumes (or cells) $C_i = [x_{i-1/2}, x_{i+1/2}]$ for $i=1, \\dots, N$. Each cell has a width $\\Delta x = L/N$, and the cell center is located at $x_i = x_{i-1/2} + \\Delta x / 2 = (i - 1/2)\\Delta x$.\n\nThe first step is to integrate the RTE over a generic control volume $C_i$:\n$$\n\\int_{x_{i-1/2}}^{x_{i+1/2}} \\left( \\mu_b \\,\\frac{\\mathrm{d} I}{\\mathrm{d} x} + \\kappa \\, I \\right) \\mathrm{d}x = 0\n$$\nApplying the fundamental theorem of calculus to the first term (the streaming or convective term) and separating the integrals gives:\n$$\n\\mu_b \\left[ I(x) \\right]_{x_{i-1/2}}^{x_{i+1/2}} + \\kappa \\int_{x_{i-1/2}}^{x_{i+1/2}} I(x) \\, \\mathrm{d}x = 0\n$$\nThis results in an exact balance equation for the control volume:\n$$\n\\mu_b \\left( I_{i+1/2} - I_{i-1/2} \\right) + \\kappa \\int_{x_{i-1/2}}^{x_{i+1/2}} I(x) \\, \\mathrm{d}x = 0\n$$\nwhere $I_{i\\pm1/2}$ represents the intensity at the cell faces (interfaces) $x_{i\\pm1/2}$.\n\nTo obtain a solvable algebraic system, we must approximate the terms in this balance equation. The cell-averaged intensity for cell $C_i$ is defined as:\n$$\nI_i = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} I(x) \\, \\mathrm{d}x\n$$\nThe volumetric absorption term is thus approximated as:\n$$\n\\kappa \\int_{x_{i-1/2}}^{x_{i+1/2}} I(x) \\, \\mathrm{d}x = \\kappa \\, I_i \\, \\Delta x\n$$\nThis is a second-order accurate approximation (midpoint rule). The accuracy of the overall scheme will be dictated by the lowest-order approximation, which is the closure for the face intensities.\n\nThe problem specifies a first-order upwind closure. Since $\\mu_b  0$, radiation propagates from left to right (increasing $x$). The \"upwind\" direction is therefore the direction of smaller $x$. The intensity at a cell face is approximated by the cell-averaged intensity of the upwind cell.\nFor the right face of cell $i$ at $x_{i+1/2}$, the upwind cell is cell $i$ itself:\n$$\nI_{i+1/2} \\approx I_i\n$$\nFor the left face of cell $i$ at $x_{i-1/2}$, the upwind cell is cell $i-1$:\n$$\nI_{i-1/2} \\approx I_{i-1}\n$$\nSubstituting these first-order approximations into the balance equation yields the discrete algebraic equation for cell $i$:\n$$\n\\mu_b \\left( I_i - I_{i-1} \\right) + \\kappa \\, I_i \\, \\Delta x = 0\n$$\nThis equation relates the intensity in cell $i$ to the intensity in the adjacent upwind cell $i-1$. We can rearrange it to solve for $I_i$:\n$$\nI_i (\\mu_b + \\kappa \\, \\Delta x) = \\mu_b \\, I_{i-1}\n$$\n$$\nI_i = \\left( \\frac{\\mu_b}{\\mu_b + \\kappa \\, \\Delta x} \\right) I_{i-1}\n$$\nThis recurrence relation allows us to compute the intensity in each cell, starting from the boundary and \"marching\" through the domain.\n\nThe marching process begins at the inflow boundary, $x=0$. The boundary condition is $I(0, \\mu_b) = I_0$. For the first cell, $i=1$, the left face is the domain boundary, so $x_{1/2} = 0$. The upwind value for this face is the boundary value itself: $I_{1/2} = I_0$. Applying the same logic to the discrete equation for cell $i=1$:\n$$\n\\mu_b \\left( I_1 - I_0 \\right) + \\kappa \\, I_1 \\, \\Delta x = 0\n$$\nSolving for $I_1$ yields:\n$$\nI_1 = \\left( \\frac{\\mu_b}{\\mu_b + \\kappa \\, \\Delta x} \\right) I_0\n$$\nThis shows that the general recurrence relation holds for all cells $i=1, \\dots, N$ if we define $I_0$ as the known inflow boundary intensity.\n\nThe complete algorithm is as follows:\n1.  Given parameters $L, \\kappa, \\mu_b, I_0$ and a mesh size $N$, calculate $\\Delta x = L/N$.\n2.  Initialize a variable for the upwind intensity, `I_prev` = $I_0$.\n3.  For $i=1, \\dots, N$, compute the cell-averaged intensity $I_i$ using the recurrence:\n    $$\n    I_i = \\left( \\frac{\\mu_b}{\\mu_b + \\kappa \\, \\Delta x} \\right) \\times \\text{`I_prev`}\n    $$\n    Then, update `I_prev` with the newly computed $I_i$ for the next iteration.\n\nTo assess the accuracy, we compare the numerical solution $\\{I_i\\}_{i=1}^N$ to the analytical solution evaluated at cell centers, $I_{\\text{exact}}(x_i, \\mu_b) = I_0 \\exp(-\\kappa x_i / \\mu_b)$, where $x_i = (i-1/2)\\Delta x$. The relative $L_2$ error norm is computed as:\n$$\nE_2 = \\frac{\\left( \\sum_{i=1}^{N} (I_i - I_{\\text{exact}}(x_i))^2 \\right)^{1/2}}{\\left( \\sum_{i=1}^{N} (I_{\\text{exact}}(x_i))^2 \\right)^{1/2}}\n$$\nNote that the factor of $\\sqrt{\\Delta x}$ in the numerator and denominator of the provided formula cancels out.\n\nFinally, the observed order of accuracy, $p$, is computed using the errors from two successively refined meshes, $N_3=40$ and $N_4=80$. The corresponding mesh sizes are $h_3 = L/N_3$ and $h_4 = L/N_4$, so the refinement ratio is $h_3/h_4=2$. The formula for $p$ is:\n$$\np = \\frac{\\ln(E_2(N_3) / E_2(N_4))}{\\ln(2)}\n$$\nA first-order scheme is expected to yield $p \\approx 1$. The Python code below implements this entire procedure.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D radiative transfer problem using a first-order control-volume\n    method, performs a grid refinement study, and computes the observed order\n    of accuracy for several test cases.\n    \"\"\"\n    \n    # Test suite: each tuple is (L, kappa, mu_b, I_0)\n    test_cases = [\n        (1.0, 1.0, 1.0, 1.0),   # Case A\n        (1.0, 1.0, 0.2, 1.0),   # Case B\n        (0.2, 20.0, 0.8, 2.0)   # Case C\n    ]\n    \n    # Mesh refinement sequence\n    N_sequence = [10, 20, 40, 80]\n    \n    # List to store the calculated order of accuracy for each case\n    p_results = []\n    \n    for case in test_cases:\n        L, kappa, mu_b, I_0 = case\n        \n        E2_errors = []\n        for N in N_sequence:\n            # 1. Setup mesh and cell center coordinates\n            dx = L / N\n            # Cell centers x_i are at (i-1/2)*dx for i=1,...,N\n            # In 0-based Python indexing, this is (i+0.5)*dx for i=0,...,N-1\n            x_centers = (np.arange(N) + 0.5) * dx\n            \n            # 2. Compute the analytical solution at cell centers for reference\n            I_exact = I_0 * np.exp(-kappa * x_centers / mu_b)\n            \n            # 3. Compute the numerical solution using the derived marching scheme\n            I_numerical = np.zeros(N)\n            # The upwind value for the first cell is the boundary condition\n            I_prev = I_0\n            # Pre-compute the marching coefficient\n            marching_coeff = mu_b / (mu_b + kappa * dx)\n            \n            for i in range(N):\n                I_numerical[i] = marching_coeff * I_prev\n                # Update the upwind value for the next cell\n                I_prev = I_numerical[i]\n                \n            # 4. Calculate the relative L2 error norm\n            # The L2 norm is sqrt(sum(vector**2))\n            error_norm = np.linalg.norm(I_numerical - I_exact)\n            exact_norm = np.linalg.norm(I_exact)\n            \n            if exact_norm == 0:\n                # This case is unlikely here but is a good practice to avoid division by zero\n                E2 = 0.0 if error_norm == 0 else np.inf\n            else:\n                E2 = error_norm / exact_norm\n                \n            E2_errors.append(E2)\n            \n        # 5. Calculate the observed order of accuracy 'p'\n        # The calculation uses the last two meshes, N=40 and N=80.\n        # These correspond to indices 2 and 3 in the E2_errors list.\n        # The grid refinement ratio is h_N3/h_N4 = (L/N3)/(L/N4) = N4/N3 = 2.\n        refinement_ratio = float(N_sequence[3]) / N_sequence[2]\n        p = np.log(E2_errors[2] / E2_errors[3]) / np.log(refinement_ratio)\n        p_results.append(p)\n        \n    # Final print statement in the exact required format.\n    # The results are rounded to six decimal places.\n    print(f\"[{','.join(f'{p:.6f}' for p in p_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "After verifying a code's basic accuracy, it is crucial to understand its limitations and numerical artifacts, especially in multiple dimensions. This exercise explores \"false scattering,\" a non-physical diffusion of radiation inherent in first-order upwind schemes like the step-differencing method. By simulating a collimated beam crossing a two-dimensional grid, you will visualize and quantify this error, gaining insight into the interplay between spatial and angular discretization and the importance of higher-order schemes or mitigation techniques .",
            "id": "3945288",
            "problem": "A two-dimensional control-volume formulation of the Radiative Transfer Equation (RTE) with the Discrete Ordinates Method (DOM) is considered for a vacuum medium in a square domain. The fundamental base is the steady, monochromatic RTE in a non-participating medium, which reduces to the streaming equation. The governing equation is $ \\boldsymbol{s} \\cdot \\nabla I(\\boldsymbol{x}, \\boldsymbol{s}) = 0 $, where $ I $ is the radiative intensity and $ \\boldsymbol{s} = (\\mu, \\eta) $ is the propagation direction with $ \\mu = \\cos \\phi $ and $ \\eta = \\sin \\phi $ for angle $ \\phi $. In the control-volume implementation on a Cartesian grid, the discrete balance in a cell is derived from fluxes across the cell faces. With first-order upwind (step) differencing, the face intensities are approximated by upwind cell-centered values. This yields a discrete streaming update that blends contributions from two upwind neighbors, which is known to introduce false scattering. The false scattering manifests as non-physical lateral spread of a collimated beam when crossing a grid.\n\nUsing the control-volume discretization, consider a unit square domain of dimensionless size $ L_x = 1 $ and $ L_y = 1 $ discretized into $ N_x \\times N_y $ cells, with $ \\Delta x = L_x / N_x $ and $ \\Delta y = L_y / N_y $. A collimated beam of dimensionless intensity $ I_b $ enters at the left boundary at the point $ (x=0, y=y_0) $ with true direction $ \\phi_{\\mathrm{true}} $ in radians, where $ 0  \\phi_{\\mathrm{true}}  \\pi/2 $ so that $ \\mu_{\\mathrm{true}} = \\cos \\phi_{\\mathrm{true}}  0 $ and $ \\eta_{\\mathrm{true}} = \\sin \\phi_{\\mathrm{true}}  0 $. The Discrete Ordinates Method (DOM) uses a finite set of discrete angles in the first quadrant, defined as $ \\{ \\phi_k \\}_{k=0}^{N-1} $ with $ \\phi_k = (k + 0.5)\\Delta $, $ \\Delta = \\frac{\\pi/2}{N} $, and $ N $ the number of angular directions. The boundary beam is mapped to the nearest discrete ordinate $ \\phi_d $ to $ \\phi_{\\mathrm{true}} $ and then marched through the grid using step differencing.\n\nStarting from the control-volume streaming balance for a steady vacuum with direction $ (\\mu,\\eta) $, the discrete step-differencing update for the cell-centered intensity $ I_{i,j} $ is\n$$\nI_{i,j} = \\frac{ \\frac{\\mu}{\\Delta x} I_{i-1,j} + \\frac{\\eta}{\\Delta y} I_{i,j-1} }{ \\frac{\\mu}{\\Delta x} + \\frac{\\eta}{\\Delta y} },\n$$\nfor $ i \\ge 0 $ and $ j \\ge 0 $ with upwind boundary conditions $ I_{-1,j} $ at the left boundary and $ I_{i,-1} $ at the bottom boundary. The left boundary condition enforces $ I_{0, j_0} = I_b $ where $ j_0 = \\lfloor y_0 / \\Delta y \\rfloor $, and $ I_{0,j} = 0 $ for $ j \\ne j_0 $. The bottom boundary condition is $ I_{i,0} = 0 $ for $ i  0 $, and the remaining domain is initially $ 0 $. The marching order must respect upwinding from $ (i-1,j) $ and $ (i,j-1) $.\n\nDefine the ideal discrete beam path as the set of cells whose interiors are intersected by the straight characteristic starting at $ (0,y_0) $ traveling along $ \\phi_{\\mathrm{true}} $. This path can be constructed by a grid traversal algorithm using the parametric line $ (x(t), y(t)) = ( \\mu_{\\mathrm{true}} t, y_0 + \\eta_{\\mathrm{true}} t ) $ with $ t \\ge 0 $, moving to the next vertical or horizontal grid line based on which is reached first, until the path exits the domain. The set of visited cell indices is the ideal path $ \\mathcal{P}_{\\mathrm{ideal}} $.\n\nQuantify the false scattering error as the fraction of computed intensity that resides outside the ideal path:\n$$\nE = \\frac{ \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} I_{i,j} \\, \\chi_{(i,j) \\notin \\mathcal{P}_{\\mathrm{ideal}}} }{ \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} I_{i,j} },\n$$\nwhere $ \\chi $ is the indicator function. This error captures both spatial false scattering from the step differencing and directional mismatch due to mapping to $ \\phi_d $. Show that increasing $ N $ (angular refinement) reduces $ E $ by aligning $ \\phi_d $ more closely with $ \\phi_{\\mathrm{true}} $, thereby reducing lateral blending weights in the step update.\n\nAngle unit must be radians. All quantities are dimensionless. Your program must implement the described control-volume DOM step differencing and the ideal path construction, compute $ E $ for each test case, and output the results as floats.\n\nUse the following test suite:\n- Case $ 1 $ (happy path angular refinement): $ N_x = 30 $, $ N_y = 30 $, $ y_0 = 0.5 $, $ I_b = 1.0 $, $ \\phi_{\\mathrm{true}} = 0.7 $, $ N = 8 $.\n- Case $ 2 $ (refined angles): $ N_x = 30 $, $ N_y = 30 $, $ y_0 = 0.5 $, $ I_b = 1.0 $, $ \\phi_{\\mathrm{true}} = 0.7 $, $ N = 32 $.\n- Case $ 3 $ (aligned direction edge case): $ N_x = 30 $, $ N_y = 30 $, $ y_0 = 0.5 $, $ I_b = 1.0 $, $ N = 8 $, with $ \\phi_{\\mathrm{true}} $ chosen exactly equal to one of the discrete ordinates, namely $ \\phi_{\\mathrm{true}} = (k+0.5)\\Delta $ with $ k = 2 $, so $ \\Delta = \\frac{\\pi}{16} $ and $ \\phi_{\\mathrm{true}} = \\frac{5\\pi}{32} $.\n- Case $ 4 $ (coarse grid, oblique beam): $ N_x = 10 $, $ N_y = 10 $, $ y_0 = 0.5 $, $ I_b = 1.0 $, $ \\phi_{\\mathrm{true}} = 1.05 $, $ N = 32 $.\n\nFor each case, compute $ E $ and express it as a float. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $ [e_1,e_2,e_3,e_4] $), where each $ e_i $ is the computed $ E $ for Case $ i $.",
            "solution": "The user has requested a solution to a computational problem involving the Discrete Ordinates Method (DOM) for the Radiative Transfer Equation (RTE). The initial step is to validate the problem statement.\n\n### Step 1: Extract Givens\n- **Governing Equation**: The steady, monochromatic Radiative Transfer Equation in a non-participating (vacuum) medium, $ \\boldsymbol{s} \\cdot \\nabla I(\\boldsymbol{x}, \\boldsymbol{s}) = 0 $, where $I$ is radiative intensity and $\\boldsymbol{s} = (\\mu, \\eta)$ is the direction vector with $\\mu = \\cos \\phi$ and $\\eta = \\sin \\phi$.\n- **Domain and Grid**: A unit square domain, $L_x = 1$ and $L_y = 1$, discretized into $N_x \\times N_y$ cells of size $\\Delta x = L_x / N_x$ and $\\Delta y = L_y / N_y$.\n- **Numerical Method**: Control-volume formulation with first-order upwind (step) differencing.\n- **Discrete Update Equation**: For a cell $(i,j)$ and a direction with $\\mu0, \\eta0$: $$ I_{i,j} = \\frac{ \\frac{\\mu}{\\Delta x} I_{i-1,j} + \\frac{\\eta}{\\Delta y} I_{i,j-1} }{ \\frac{\\mu}{\\Delta x} + \\frac{\\eta}{\\Delta y} } $$\n- **Boundary Conditions**: A collimated beam of intensity $I_b$ enters at $(x=0, y=y_0)$ with true direction $\\phi_{\\mathrm{true}} \\in (0, \\pi/2)$. This is modeled by setting the incoming intensity for the cell at index $j_0 = \\lfloor y_0 / \\Delta y \\rfloor$ on the left boundary ($i=0$) to $I_b$, and zero for all other boundary cells. The incoming intensity at the bottom boundary ($j=0$) is zero.\n- **Angular Discretization (DOM)**: The continuous angle $\\phi$ is discretized into a set $\\{ \\phi_k \\}_{k=0}^{N-1}$ where $\\phi_k = (k + 0.5)\\Delta$ and $\\Delta = \\frac{\\pi/2}{N}$. The beam's true direction $\\phi_{\\mathrm{true}}$ is mapped to the nearest discrete ordinate $\\phi_d$.\n- **Ideal Path**: The set of cells $\\mathcal{P}_{\\mathrm{ideal}}$ whose interiors are intersected by the straight line originating at $(0, y_0)$ with direction $\\phi_{\\mathrm{true}}$. This path is determined using a grid traversal algorithm.\n- **Error Metric for False Scattering**: $$ E = \\frac{ \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} I_{i,j} \\, \\chi_{(i,j) \\notin \\mathcal{P}_{\\mathrm{ideal}}} }{ \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} I_{i,j} } $$ where $\\chi$ is the indicator function.\n- **Test Cases**:\n    1.  $N_x = 30$, $N_y = 30$, $y_0 = 0.5$, $I_b = 1.0$, $\\phi_{\\mathrm{true}} = 0.7$, $N = 8$.\n    2.  $N_x = 30$, $N_y = 30$, $y_0 = 0.5$, $I_b = 1.0$, $\\phi_{\\mathrm{true}} = 0.7$, $N = 32$.\n    3.  $N_x = 30$, $N_y = 30$, $y_0 = 0.5$, $I_b = 1.0$, $N = 8$, $\\phi_{\\mathrm{true}} = 5\\pi/32$.\n    4.  $N_x = 10$, $N_y = 10$, $y_0 = 0.5$, $I_b = 1.0$, $\\phi_{\\mathrm{true}} = 1.05$, $N = 32$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is based on fundamental principles of radiative transfer and standard numerical methods (Control Volume, DOM, Step Differencing) used in computational engineering. The phenomenon of \"false scattering\" is a well-documented numerical artifact of such schemes. The problem is scientifically sound.\n- **Well-Posed**: The problem describes a marching procedure for a transport equation with specified inflow boundary conditions. For a direction in the first quadrant ($\\mu0, \\eta0$), the solution at any point $(i,j)$ depends only on values at previous indices $(i-1,j)$ and $(i,j-1)$. This structure guarantees a unique and stable solution. The error metric is clearly defined.\n- **Objective**: The problem requires the calculation of a quantitative metric, $E$, based on a fully specified algorithm and parameters. It is free from subjectivity.\n\nThe problem statement provides a clear, verifiable, and non-trivial task within the specified domain of computational thermal engineering. While the phrasing of boundary conditions (\"$I_{0, j_0} = I_b$\") is slightly imprecise compared to a formal definition of face fluxes or ghost cells, its intent is unambiguous in the context of implementing a marching scheme. One interprets this as setting the upwind intensity for the first column of cells from a boundary source. Therefore, the problem is deemed valid.\n\n### Step 3: Verdict and Action\nThe problem is valid. A solution will be provided.\n\n### Solution\n\nThe problem requires the quantification of false scattering, a numerical artifact in the control-volume implementation of the Discrete Ordinates Method for the Radiative Transfer Equation. The solution involves implementing a numerical simulation based on the provided equations and definitions.\n\n**Principle and Discretization**\nThe foundation of the method is the conservation of radiant energy. For a non-participating medium and steady state, the RTE simplifies to $\\boldsymbol{s} \\cdot \\nabla I = 0$, indicating that intensity $I$ is constant along a characteristic line in direction $\\boldsymbol{s}$. The control-volume method discretizes the integral form of this equation over a grid cell $V_{i,j}$ of size $\\Delta x \\times \\Delta y$. Using the divergence theorem, the equation for a discrete direction $\\boldsymbol{s}_d = (\\mu_d, \\eta_d)$ is:\n$$ \\int_{V_{i,j}} \\nabla \\cdot (\\boldsymbol{s}_d I) \\, \\mathrm{d}V = \\oint_{\\partial V_{i,j}} I (\\boldsymbol{s}_d \\cdot \\boldsymbol{n}) \\, \\mathrm{d}A = 0 $$\nwhere $\\boldsymbol{n}$ is the outward normal vector to the cell boundary $\\partial V_{i,j}$. This balance expands to:\n$$ \\mu_d (I_{e} - I_{w})\\Delta y + \\eta_d (I_{n} - I_{s})\\Delta x = 0 $$\nHere, $I_w, I_e, I_s, I_n$ represent the average intensities on the west, east, south, and north faces of the cell, respectively.\n\n**First-Order Upwind (Step) Scheme**\nThe step scheme approximates the face intensities using the cell-centered intensity from the upwind direction. For the first quadrant ($\\mu_d  0, \\eta_d  0$), information flows from negative $x$ and $y$ to positive $x$ and $y$. Thus, the inflow face intensities are approximated by the neighboring upwind cells, $I_w \\approx I_{i-1,j}$ and $I_s \\approx I_{i,j-1}$. The outflow face intensities are approximated by the cell's own intensity, $I_e \\approx I_{i,j}$ and $I_n \\approx I_{i,j}$. Substituting these into the balance equation yields:\n$$ \\mu_d (I_{i,j} - I_{i-1,j})\\Delta y + \\eta_d (I_{i,j} - I_{i,j-1})\\Delta x = 0 $$\nSolving for $I_{i,j}$ gives the specified update formula:\n$$ I_{i,j} = \\frac{ (\\mu_d/\\Delta x) I_{i-1,j} + (\\eta_d/\\Delta y) I_{i,j-1} }{ (\\mu_d/\\Delta x) + (\\eta_d/\\Delta y) } $$\nThis equation shows that the intensity in a cell is a weighted average of the intensities in the two upwind cells. This averaging process is the source of numerical diffusion, or \"false scattering,\" as it causes an initially collimated beam to spread laterally as it crosses the grid at an oblique angle.\n\n**Algorithmic Implementation**\nThe solution is implemented via the following steps for each test case:\n1.  **Setup and Angular Discretization**: The grid parameters ($\\Delta x, \\Delta y$) are defined. The set of discrete angles $\\{\\phi_k\\}$ is generated. The true beam direction $\\phi_{\\mathrm{true}}$ is mapped to the nearest discrete ordinate $\\phi_d$ by finding the $\\phi_k$ that minimizes $|\\phi_k - \\phi_{\\mathrm{true}}|$. The corresponding direction cosines $(\\mu_d, \\eta_d)$ are computed.\n2.  **Ideal Path Calculation**: The ideal path $\\mathcal{P}_{\\mathrm{ideal}}$ is the set of grid cells that the true, unscattered beam would pass through. This is computed using a robust grid-traversal algorithm, such as the Amanatides-Woo algorithm. Starting from the entry point $(0, y_0)$, the algorithm iteratively finds the next cell intersected by the line with true direction $\\phi_{\\mathrm{true}}$ until the line exits the domain.\n3.  **DOM Simulation**: An array `I` of size $N_x \\times N_y$ is initialized to zero. The simulation proceeds by marching through the grid in an order that respects data dependencies. For $\\mu_d0, \\eta_d0$, this means iterating from $i=0$ to $N_x-1$ and $j=0$ to $N_y-1$. At each cell $(i,j)$, the upwind intensities are retrieved from the left cell $(i-1,j)$ and the bottom cell $(i,j-1)$. For cells on the boundary ($i=0$ or $j=0$), the upwind values are provided by the problem's boundary conditions. Specifically, the upwind intensity from the left is $I_b$ for the source cell ($i=0, j=j_0$) and $0$ otherwise. The upwind intensity from the bottom ($j=0$) is always $0$. The cell intensity $I_{i,j}$ is then calculated using the discrete update formula.\n4.  **Error Quantification**: After the intensity field $I$ is fully computed, the total intensity in the domain is calculated as $\\sum I_{i,j}$. The intensity in all cells *not* on the ideal path, $\\sum_{(i,j) \\notin \\mathcal{P}_{\\mathrm{ideal}}} I_{i,j}$, is also summed. The false scattering error $E$ is the ratio of the latter to the former. This quantifies the fraction of radiative energy that has numerically \"leaked\" out of the correct physical path.\n\nBy executing this procedure for each test case, we can observe the behavior of false scattering, including its reduction with angular refinement (Case 1 vs. 2) and its dependence on grid resolution and beam angle (Case 4). Case 3 illustrates that even with perfect directional alignment ($\\phi_{\\mathrm{true}} = \\phi_d$), the spatial discretization of the step scheme still induces false scattering.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_ideal_path(Nx, Ny, dx, dy, y0, phi_true):\n    \"\"\"\n    Calculates the set of ideal path cells using an Amanatides-Woo-like algorithm.\n    This algorithm efficiently finds all grid cells a ray passes through.\n    \"\"\"\n    path = set()\n    mu_true = np.cos(phi_true)\n    eta_true = np.sin(phi_true)\n\n    # Initial position and cell index. The ray starts at (0, y0) on the left boundary.\n    cx, cy = 0.0, y0\n    i = 0\n    j = int(np.floor(cy / dy))\n    \n    # Clamp initial cell index to be within grid bounds\n    if j  0: j = 0\n    if j = Ny: j = Ny - 1\n    \n    path.add((i, j))\n\n    # For 0  phi_true  pi/2, the ray moves in +i and +j directions\n    step_i = 1\n    step_j = 1\n\n    # Time to cross next grid lines from the starting point (cx, cy)\n    next_vert_boundary = (i + 1) * dx\n    next_horiz_boundary = (j + 1) * dy\n    \n    # Avoid division by zero, though problem constraints make mu_true, eta_true  0\n    t_max_x = (next_vert_boundary - cx) / mu_true if mu_true  1e-12 else float('inf')\n    t_max_y = (next_horiz_boundary - cy) / eta_true if eta_true  1e-12 else float('inf')\n\n\n    # Time step required to cross one cell width or height\n    t_delta_x = dx / mu_true if mu_true  1e-12 else float('inf')\n    t_delta_y = dy / eta_true if eta_true  1e-12 else float('inf')\n\n    while True:\n        if t_max_x  t_max_y:\n            t_max_x += t_delta_x\n            i += step_i\n        else:\n            t_max_y += t_delta_y\n            j += step_j\n        \n        if i = Nx or j = Ny:\n            break\n            \n        path.add((i, j))\n        \n    return path\n\ndef solve_single_case(Nx, Ny, y0, Ib, phi_true, N):\n    \"\"\"\n    Solves for the false scattering error E for a single test case.\n    \"\"\"\n    Lx, Ly = 1.0, 1.0\n    dx, dy = Lx / Nx, Ly / Ny\n\n    # 1. Angular Discretization\n    delta_phi = (np.pi / 2.0) / N\n    phi_k = np.array([(k + 0.5) * delta_phi for k in range(N)])\n    \n    # Find nearest discrete angle phi_d\n    idx_d = np.argmin(np.abs(phi_k - phi_true))\n    phi_d = phi_k[idx_d]\n    mu_d = np.cos(phi_d)\n    eta_d = np.sin(phi_d)\n    \n    # 2. Ideal Path Calculation\n    ideal_path = calculate_ideal_path(Nx, Ny, dx, dy, y0, phi_true)\n    \n    # 3. Control-Volume DOM Simulation\n    I = np.zeros((Nx, Ny))\n    j0 = int(np.floor(y0 / dy))\n    \n    # Pre-calculate weights for the update formula\n    weight_x = mu_d / dx\n    weight_y = eta_d / dy\n    weight_total = weight_x + weight_y\n\n    # Marching calculation for the first quadrant (mu  0, eta  0)\n    for i in range(Nx):\n        for j in range(Ny):\n            # Get upwind intensities based on boundary conditions\n            I_upwind_x = I[i - 1, j] if i  0 else (Ib if j == j0 else 0.0)\n            I_upwind_y = I[i, j - 1] if j  0 else 0.0\n            \n            # Apply step-differencing update formula\n            if weight_total  1e-12:\n                I[i, j] = (weight_x * I_upwind_x + weight_y * I_upwind_y) / weight_total\n            else:\n                I[i, j] = 0.0\n            \n    # 4. Error Quantification\n    total_intensity = np.sum(I)\n    \n    if total_intensity  1e-12:\n        return 0.0\n\n    outside_intensity = 0.0\n    for i in range(Nx):\n        for j in range(Ny):\n            if (i, j) not in ideal_path:\n                outside_intensity += I[i, j]\n                \n    error = outside_intensity / total_intensity\n    return error\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1: (Nx, Ny, y0, Ib, phi_true, N)\n        (30, 30, 0.5, 1.0, 0.7, 8),\n        # Case 2: (refined angles)\n        (30, 30, 0.5, 1.0, 0.7, 32),\n        # Case 3: (aligned direction)\n        (30, 30, 0.5, 1.0, (5.0 * np.pi / 32.0), 8),\n        # Case 4: (coarse grid, oblique beam)\n        (10, 10, 0.5, 1.0, 1.05, 32)\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, Ny, y0, Ib, phi_true, N = case\n        result = solve_single_case(Nx, Ny, y0, Ib, phi_true, N)\n        results.append(result)\n\n    # Format the final output string as a list of floats (as strings)\n    formatted_results = [str(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "To build a versatile solver applicable to real-world engineering geometries, one must move beyond simple structured grids. This practice addresses the fundamental algorithmic challenge of implementing the Discrete Ordinates Method on unstructured meshes. You will learn how to establish the correct computational sequence, or \"sweep,\" by modeling cell dependencies as a directed graph and applying a topological sort, a critical skill for developing robust and general-purpose computational fluid dynamics and heat transfer codes .",
            "id": "3945345",
            "problem": "You are given the task of designing a control-volume sweep ordering for the Discrete Ordinates Method (DOM) in computational thermal engineering. The Discrete Ordinates Method (DOM) solves the Radiative Transfer Equation (RTE) by discretizing the angular domain into a finite set of directions and sweeping the spatial domain such that upwind information is available before computing unknowns in downstream cells. For a fixed ordinate direction vector $\\vec{s}_m \\in \\mathbb{R}^d$ with $d \\in \\{2,3\\}$, construct a topologically sorted ordering of control-volume cells on an unstructured mesh so that each cell appears after all of its upwind neighbors.\n\nStart from fundamental transport for the Radiative Transfer Equation along a single ordinate direction $\\vec{s}_m$, where the streaming term $ \\vec{s}_m \\cdot \\nabla I(\\vec{x}, \\vec{s}_m) $ implies that intensities at position $\\vec{x}$ depend on upwind values in the direction $-\\vec{s}_m$. In a control-volume discretization, this enforces that, for each internal face shared by two adjacent cells, the cell located downstream relative to $\\vec{s}_m$ must be processed after the cell located upstream.\n\nDefine the directed dependency graph as follows. Let there be $N$ cells, indexed by integers $0,1,\\dots,N-1$. Each cell $i$ has a center position $\\vec{x}_i \\in \\mathbb{R}^d$. The unstructured mesh connectivity is given as a set of undirected neighbor pairs $(i,j)$ indicating that cell $i$ and cell $j$ share a common face. For each undirected neighbor pair $(i,j)$, create a directed edge from $i$ to $j$ if $\\vec{s}_m \\cdot (\\vec{x}_j - \\vec{x}_i)  0$, create a directed edge from $j$ to $i$ if $\\vec{s}_m \\cdot (\\vec{x}_j - \\vec{x}_i)  0$, and no directed edge if $\\vec{s}_m \\cdot (\\vec{x}_j - \\vec{x}_i) = 0$. Perform a topological sort of this directed graph. When multiple cells are available to be processed (zero in-degree), break ties by choosing the cell with smallest value of $\\phi_i := \\vec{s}_m \\cdot \\vec{x}_i$, and then by smallest cell index if $\\phi_i$ ties.\n\nYour program must implement this construction and produce a sweep ordering for each of the test cases below. For each test case, the output is the topologically sorted list of cell indices. The final output across all test cases must be a single line containing a comma-separated list of these lists, enclosed in square brackets. Each list must contain all cell indices exactly once, in the computed order. All coordinates are given without units, and directions are unitless vectors; there is no angle unit to specify because directions are given in Cartesian components.\n\nTest Suite:\n- Case $1$ (structured $2$-D mesh, horizontal sweep):\n  - Cells: indices $0,1,2,3$.\n  - Centers: $\\vec{x}_0=(0,0)$, $\\vec{x}_1=(1,0)$, $\\vec{x}_2=(0,1)$, $\\vec{x}_3=(1,1)$.\n  - Undirected neighbors: $(0,1)$, $(2,3)$, $(0,2)$, $(1,3)$.\n  - Direction: $\\vec{s}_m=(1,0)$.\n\n- Case $2$ (structured $2$-D mesh, diagonal sweep):\n  - Cells: indices $0,1,2,3$.\n  - Centers: $\\vec{x}_0=(0,0)$, $\\vec{x}_1=(1,0)$, $\\vec{x}_2=(0,1)$, $\\vec{x}_3=(1,1)$.\n  - Undirected neighbors: $(0,1)$, $(2,3)$, $(0,2)$, $(1,3)$.\n  - Direction: $\\vec{s}_m=\\left(\\frac{1}{\\sqrt{2}},\\frac{1}{\\sqrt{2}}\\right)$.\n\n- Case $3$ (one-dimensional chain, reverse sweep):\n  - Cells: indices $0,1,2$.\n  - Centers: $\\vec{x}_0=(0,0)$, $\\vec{x}_1=(1,0)$, $\\vec{x}_2=(2,0)$.\n  - Undirected neighbors: $(0,1)$, $(1,2)$.\n  - Direction: $\\vec{s}_m=(-1,0)$.\n\n- Case $4$ (perpendicular direction yields no edge on the only neighbor):\n  - Cells: indices $0,1$.\n  - Centers: $\\vec{x}_0=(0,0)$, $\\vec{x}_1=(1,0)$.\n  - Undirected neighbors: $(0,1)$.\n  - Direction: $\\vec{s}_m=(0,1)$.\n\n- Case $5$ (single isolated cell):\n  - Cells: index $0$.\n  - Centers: $\\vec{x}_0=(0,0)$.\n  - Undirected neighbors: none.\n  - Direction: $\\vec{s}_m=(1,0)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is a list of integers representing the sweep order for the corresponding case (for example, $[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]$). The result for each test case must be a list of integers.",
            "solution": "The user-provided problem statement is subjected to a rigorous validation process.\n\n### Step 1: Extract Givens\n\n- **Task**: Design a control-volume sweep ordering for the Discrete Ordinates Method (DOM).\n- **Method**: Construct a topologically sorted ordering of control-volume cells on an unstructured mesh.\n- **Underlying Principle**: For a fixed ordinate direction $\\vec{s}_m \\in \\mathbb{R}^d$, the sweep must process upwind cells before downstream cells. The streaming term $\\vec{s}_m \\cdot \\nabla I(\\vec{x}, \\vec{s}_m)$ implies dependency on upwind values in the direction $-\\vec{s}_m$.\n- **Graph Definition**:\n    - **Nodes**: $N$ cells, indexed $0, 1, \\dots, N-1$. Each cell $i$ has a center position $\\vec{x}_i \\in \\mathbb{R}^d$.\n    - **Initial Connectivity**: A set of undirected neighbor pairs $(i,j)$.\n    - **Directed Edge Rule**: For each pair $(i,j)$:\n        - If $\\vec{s}_m \\cdot (\\vec{x}_j - \\vec{x}_i)  0$, create a directed edge from $i$ to $j$.\n        - If $\\vec{s}_m \\cdot (\\vec{x}_j - \\vec{x}_i)  0$, create a directed edge from $j$ to $i$.\n        - If $\\vec{s}_m \\cdot (\\vec{x}_j - \\vec{x}_i) = 0$, create no directed edge.\n- **Sorting Algorithm**: Perform a topological sort on the constructed directed graph.\n- **Tie-Breaking Rule**: When multiple cells have zero in-degree:\n    1.  Choose the cell with the smallest value of $\\phi_i := \\vec{s}_m \\cdot \\vec{x}_i$.\n    2.  If $\\phi_i$ values are tied, choose the cell with the smallest index.\n- **Test Cases**:\n    - **Case 1**: $N=4$ cells, $\\vec{x}_0=(0,0), \\vec{x}_1=(1,0), \\vec{x}_2=(0,1), \\vec{x}_3=(1,1)$. Neighbors: $(0,1), (2,3), (0,2), (1,3)$. Direction: $\\vec{s}_m=(1,0)$.\n    - **Case 2**: $N=4$ cells, $\\vec{x}_0=(0,0), \\vec{x}_1=(1,0), \\vec{x}_2=(0,1), \\vec{x}_3=(1,1)$. Neighbors: $(0,1), (2,3), (0,2), (1,3)$. Direction: $\\vec{s}_m=(\\frac{1}{\\sqrt{2}},\\frac{1}{\\sqrt{2}})$.\n    - **Case 3**: $N=3$ cells, $\\vec{x}_0=(0,0), \\vec{x}_1=(1,0), \\vec{x}_2=(2,0)$. Neighbors: $(0,1), (1,2)$. Direction: $\\vec{s}_m=(-1,0)$.\n    - **Case 4**: $N=2$ cells, $\\vec{x}_0=(0,0), \\vec{x}_1=(1,0)$. Neighbors: $(0,1)$. Direction: $\\vec{s}_m=(0,1)$.\n    - **Case 5**: $N=1$ cell, $\\vec{x}_0=(0,0)$. Neighbors: none. Direction: $\\vec{s}_m=(1,0)$.\n- **Output Format**: A single line containing a comma-separated list of lists, enclosed in square brackets, e.g., `[[...],[...]]`.\n\n### Step 2: Validate Using Extracted Givens\n\n1.  **Scientifically Grounded**: The problem is well-grounded in computational thermal engineering. The Discrete Ordinates Method is a standard technique for solving the Radiative Transfer Equation. The core idea of sweeping a computational domain based on upwind/downwind dependencies defined by a direction vector is fundamental to solving hyperbolic-type transport equations numerically. The construction of a dependency graph and performing a topological sort is a correct and standard procedure to establish a valid computational sequence.\n2.  **Well-Posed**: The problem is well-posed. The graph construction rules are explicit. The graph created is a Directed Acyclic Graph (DAG). To prove this, assume a cycle exists: $i_1 \\to i_2 \\to \\dots \\to i_k \\to i_1$. By the edge definition, this implies $\\vec{s}_m \\cdot (\\vec{x}_{i_2} - \\vec{x}_{i_1})  0$, $\\vec{s}_m \\cdot (\\vec{x}_{i_3} - \\vec{x}_{i_2})  0$, ..., $\\vec{s}_m \\cdot (\\vec{x}_{i_1} - \\vec{x}_{i_k})  0$. Summing these inequalities yields $\\sum_{j=1}^{k} \\vec{s}_m \\cdot (\\vec{x}_{i_{j+1}} - \\vec{x}_{i_j})  0$, where $i_{k+1}=i_1$. By linearity of the dot product, this is $\\vec{s}_m \\cdot \\sum_{j=1}^{k} (\\vec{x}_{i_{j+1}} - \\vec{x}_{i_j})  0$. The sum is a telescoping series that results in the zero vector: $(\\vec{x}_{i_2} - \\vec{x}_{i_1}) + \\dots + (\\vec{x}_{i_1} - \\vec{x}_{i_k}) = \\vec{0}$. This leads to the contradiction $\\vec{s}_m \\cdot \\vec{0}  0$, or $0  0$. Thus, no cycles can exist. A topological sort is always possible on a DAG. The explicit tie-breaking rules (first by $\\phi_i$, then by cell index) ensure that the resulting topological sort is unique.\n3.  **Objective**: The problem is stated in precise, objective mathematical and algorithmic terms.\n4.  **Complete and Consistent**: All necessary information (cell centers, connectivity, direction vectors) is provided for each test case. The rules for graph construction and sorting are unambiguous.\n5.  **No other flaws**: The problem is free of the other invalidity flags. It is a formal, solvable problem in computational science.\n\n### Step 3: Verdict and Action\n\nThe problem is **valid**. A solution will be provided.\n\n### Solution\n\nThe problem requires the implementation of a specific algorithm to determine a computational order for cells in a discretized domain, a procedure known as a \"sweep\" in the context of the Discrete Ordinates Method (DOM). This is fundamentally a graph theory problem: constructing a directed graph based on physical dependencies and then finding a topological ordering of its nodes.\n\n**1. Dependency Graph Construction**\n\nThe Radiative Transfer Equation, when discretized, creates dependencies between adjacent control volumes (cells). For a given discrete direction $\\vec{s}_m$, the intensity in a cell is dependent on the intensity from its \"upwind\" neighbors. A cell $j$ is downstream of cell $i$ if it is further along the direction of $\\vec{s}_m$. This geometric relationship can be formalized using the dot product. Given two adjacent cells $i$ and $j$ with centers $\\vec{x}_i$ and $\\vec{x}_j$, the vector from $i$ to $j$ is $\\vec{v}_{ij} = \\vec{x}_j - \\vec{x}_i$. The projection of this vector onto the direction $\\vec{s}_m$ is given by $\\vec{s}_m \\cdot \\vec{v}_{ij}$.\n\n- If $\\vec{s}_m \\cdot (\\vec{x}_j - \\vec{x}_i)  0$, cell $j$ is downstream of $i$. Information flows from $i$ to $j$. Thus, we must process $i$ before $j$, which is represented by a directed edge $i \\to j$.\n- If $\\vec{s}_m \\cdot (\\vec{x}_j - \\vec{x}_i)  0$, cell $i$ is downstream of $j$. This implies an edge $j \\to i$.\n- If $\\vec{s}_m \\cdot (\\vec{x}_j - \\vec{x}_i) = 0$, the cells lie on a plane perpendicular to the direction $\\vec{s}_m$. There is no direct upwind-downstream dependency along this face, so no directed edge is created between them for the sweep.\n\nAs demonstrated during validation, this construction process guarantees a Directed Acyclic Graph (DAG), which is a prerequisite for topological sorting.\n\n**2. Topological Sorting with Tie-Breaking**\n\nA standard algorithm for topological sorting is Kahn's algorithm. It works by iteratively identifying and processing nodes with an in-degree of zero (i.e., nodes with no incoming edges).\n\nThe standard algorithm is as follows:\n1.  Compute the in-degree for every node in the graph.\n2.  Initialize a queue with all nodes having an in-degree of $0$.\n3.  While the queue is not empty:\n    a. Dequeue a node $u$. Add $u$ to the topologically sorted list.\n    b. For each neighbor $v$ of $u$: decrement the in-degree of $v$. If the in-degree of $v$ becomes $0$, enqueue $v$.\n\nThe problem specifies a strict tie-breaking rule for step 2 and 3b. When multiple nodes are available (have an in-degree of $0$), they should not be processed in an arbitrary or FIFO order. Instead, the node to be processed next is the one with the minimum value of $\\phi_i = \\vec{s}_m \\cdot \\vec{x}_i$. If a tie in $\\phi_i$ occurs, it is further resolved by choosing the node with the smallest cell index $i$.\n\nThis complex tie-breaking requirement means a simple queue is insufficient. A min-priority queue is the appropriate data structure. Each cell $i$ is inserted into the priority queue with a priority key given by the tuple $(\\phi_i, i)$. Python's `heapq` library implements a min-priority queue that naturally handles lexicographical comparison of tuples, correctly implementing the specified tie-breaking logic.\n\n**3. Algorithmic Implementation**\n\nThe final algorithm for each test case is:\n1.  **Initialization**: For $N$ cells, create an adjacency list `adj` (e.g., a list of lists) and an integer array `in_degree` of size $N$, initialized to zeros.\n2.  **Graph Building**: Iterate through each undirected neighbor pair $(i, j)$:\n    - Calculate $d = \\vec{s}_m \\cdot (\\vec{x}_j - \\vec{x}_i)$.\n    - If $d  0$, add edge $i \\to j$ by appending $j$ to `adj[i]` and incrementing `in_degree[j]`.\n    - If $d  0$, add edge $j \\to i$ by appending $i$ to `adj[j]` and incrementing `in_degree[i]`.\n3.  **Priority Calculation**: Compute $\\phi_k = \\vec{s}_m \\cdot \\vec{x}_k$ for all cells $k=0, \\dots, N-1$.\n4.  **Priority Queue Seeding**: Create a min-priority queue. For each cell $k$ where `in_degree[k]` is $0$, push the tuple $(\\phi_k, k)$ onto the priority queue.\n5.  **Main Loop**:\n    - Initialize an empty list `sorted_order`.\n    - While the priority queue is not empty:\n        a. Pop the element with the smallest priority, $(\\phi_u, u)$.\n        b. Append the cell index $u$ to `sorted_order`.\n        c. For each neighbor $v$ in `adj[u]`:\n            i. Decrement `in_degree[v]`.\n            ii. If `in_degree[v]` is now $0$, push the tuple $(\\phi_v, v)$ onto the priority queue.\n6.  **Result**: The list `sorted_order` contains the unique, correctly ordered sequence of cell indices. This process is repeated for all test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the sweep order computation,\n    and print the results in the required format.\n    \"\"\"\n    test_cases = [\n        # Case 1 (structured 2-D mesh, horizontal sweep)\n        {\n            \"cell_indices\": [0, 1, 2, 3],\n            \"centers\": np.array([[0,0], [1,0], [0,1], [1,1]], dtype=float),\n            \"neighbors\": [(0,1), (2,3), (0,2), (1,3)],\n            \"direction\": np.array([1,0], dtype=float)\n        },\n        # Case 2 (structured 2-D mesh, diagonal sweep)\n        {\n            \"cell_indices\": [0, 1, 2, 3],\n            \"centers\": np.array([[0,0], [1,0], [0,1], [1,1]], dtype=float),\n            \"neighbors\": [(0,1), (2,3), (0,2), (1,3)],\n            \"direction\": np.array([1/np.sqrt(2), 1/np.sqrt(2)], dtype=float)\n        },\n        # Case 3 (one-dimensional chain, reverse sweep)\n        {\n            \"cell_indices\": [0, 1, 2],\n            \"centers\": np.array([[0,0], [1,0], [2,0]], dtype=float),\n            \"neighbors\": [(0,1), (1,2)],\n            \"direction\": np.array([-1,0], dtype=float)\n        },\n        # Case 4 (perpendicular direction yields no edge)\n        {\n            \"cell_indices\": [0, 1],\n            \"centers\": np.array([[0,0], [1,0]], dtype=float),\n            \"neighbors\": [(0,1)],\n            \"direction\": np.array([0,1], dtype=float)\n        },\n        # Case 5 (single isolated cell)\n        {\n            \"cell_indices\": [0],\n            \"centers\": np.array([[0,0]], dtype=float),\n            \"neighbors\": [],\n            \"direction\": np.array([1,0], dtype=float)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_sweep_order(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # e.g., [[0, 2, 1, 3],[0, 1, 2, 3],...]\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_sweep_order(case):\n    \"\"\"\n    Computes the sweep order for a single test case.\n\n    Args:\n        case (dict): A dictionary containing the mesh and direction data.\n\n    Returns:\n        list: A list of cell indices in the topologically sorted sweep order.\n    \"\"\"\n    indices = case[\"cell_indices\"]\n    centers = case[\"centers\"]\n    neighbors = case[\"neighbors\"]\n    s_m = case[\"direction\"]\n    \n    num_cells = len(indices)\n    if num_cells == 0:\n        return []\n\n    adj = [[] for _ in range(num_cells)]\n    in_degree = [0] * num_cells\n\n    # Build the directed graph and compute in-degrees\n    for i, j in neighbors:\n        # Ensure i and j are valid indices\n        if i = num_cells or j = num_cells:\n            continue\n            \n        x_i = centers[i]\n        x_j = centers[j]\n        \n        dot_product = np.dot(s_m, x_j - x_i)\n        \n        # Add a small tolerance for floating point comparisons\n        if dot_product  1e-9:\n            # Edge from i to j\n            adj[i].append(j)\n            in_degree[j] += 1\n        elif dot_product  -1e-9:\n            # Edge from j to i\n            adj[j].append(i)\n            in_degree[i] += 1\n    \n    # Calculate phi values for tie-breaking\n    phi_values = [np.dot(s_m, centers[i]) for i in range(num_cells)]\n\n    # Initialize a min-priority queue with all nodes having an in-degree of 0\n    # The priority is a tuple (phi_value, cell_index)\n    pq = []\n    for i in range(num_cells):\n        if in_degree[i] == 0:\n            heapq.heappush(pq, (phi_values[i], i))\n\n    sorted_order = []\n    \n    # Kahn's algorithm using a priority queue for tie-breaking\n    while pq:\n        _, u = heapq.heappop(pq)\n        sorted_order.append(u)\n        \n        for v in adj[u]:\n            in_degree[v] -= 1\n            if in_degree[v] == 0:\n                heapq.heappush(pq, (phi_values[v], v))\n                \n    return sorted_order\n\nsolve()\n```"
        }
    ]
}