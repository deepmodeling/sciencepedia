{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握动态模式分解（DMD），最好的方法莫过于亲手实现其核心算法。本练习将指导您完成这一过程，我们将以一个经典的热传导问题——一维杆中的热扩散为例。通过为这个具有明确解析解的物理系统生成合成数据，您将能够实现基于奇异值分解（SVD）的DMD算法，并验证您计算出的DMD模式和特征值是否与理论预测相符。这个练习旨在为您构建一个坚实的基础，理解DMD如何从数据中提取出与物理相关的动态特征。",
            "id": "3949672",
            "problem": "考虑一根长度为 $L$ 的一维均匀杆，仅受纯热传导作用，两端具有固定温度的狄利克雷边界条件。温度场 $T(x,t)$ 满足热方程 $\\frac{\\partial T}{\\partial t}=\\alpha \\frac{\\partial^2 T}{\\partial x^2}$，其中 $\\alpha$ 是热扩散率。将杆离散为 $n$ 个内部点，间距均匀为 $\\Delta x=L/(n+1)$，并使用二阶中心有限差分来近似空间拉普拉斯算子。这得到了一个在 $\\mathbb{R}^n$ 上的线性常微分方程，形式为 $\\frac{d \\mathbf{x}}{dt}=\\alpha L \\mathbf{x}$，其中 $L \\in \\mathbb{R}^{n \\times n}$ 是具有狄利克雷边界条件的离散拉普拉斯矩阵。精确的时间-$\\Delta t$ 演化算子为 $A=\\exp(\\alpha \\Delta t L)$，其中 $\\exp(\\cdot)$ 表示矩阵指数。\n\n您将通过一个初始状态 $\\mathbf{x}_0$ 在算子 $A$ 下演化 $m$ 个时间步长（大小为 $\\Delta t$ 秒）来构建快照矩阵 $X \\in \\mathbb{R}^{n \\times (m-1)}$ 和 $Y \\in \\mathbb{R}^{n \\times (m-1)}$，使得 $X$ 的列为 $\\{\\mathbf{x}_1,\\ldots,\\mathbf{x}_{m-1}\\}$，$Y$ 的列为 $\\{\\mathbf{x}_2,\\ldots,\\mathbf{x}_m\\}$，其中 $\\mathbf{x}_{k+1}=A\\mathbf{x}_k$。动态模态分解 (DMD) 旨在寻找一个低秩线性算子，该算子将快照从 $X$ 推进到 $Y$，并将动力学分解为具有相应增长率的相干模态。\n\n从 $X$ 的奇异值分解出发，利用 Moore-Penrose 伪逆的定义，推导在由主左奇异向量张成的子空间中的降维算子以及相应的 DMD 模态构造。通过与热传导的物理原理相结合来解释每一步，包括离散拉普拉斯算子的作用以及对单位为 $\\mathrm{s}^{-1}$ 的连续时间增长率的解释。\n\n实现一个程序，该程序能够：\n- 为具有狄利克雷边界条件的一维杆构建离散拉普拉斯矩阵 $L$。\n- 通过使用精确算子 $A=\\exp(\\alpha \\Delta t L)$ 演化一个初始条件来生成合成快照数据。\n- 通过计算 $X$ 的奇异值分解、构建降维算子、计算其特征分解，然后计算 DMD 模态来执行动态模态分解。\n- 使用复数对数除以 $\\Delta t$ 将离散时间特征值转换为连续时间增长率，并以 $\\mathrm{s}^{-1}$ 为单位解释这些速率。\n\n对于数值单位，使用米（m）表示 $L$，秒（s）表示 $\\Delta t$。温度单位为开尔文，但由于算子是线性的，数值将是特征向量的无单位标量；连续时间增长率必须以 $\\mathrm{s}^{-1}$ 表示。\n\n您必须根据以下测试套件评估您的实现。在每种情况下，从离散拉普拉斯算子的精确特征向量构建指定的初始条件，以便理论上的连续时间增长率是已知的。使用狄利克雷边界的解析离散拉普拉斯特征值，由 $\\mu_k=-\\frac{2}{\\Delta x^2}\\left(1-\\cos\\left(\\frac{k\\pi}{n+1}\\right)\\right)$ 给出（对于模态指数 $k\\in\\{1,\\ldots,n\\}$），以及相应的特征向量 $u^{(k)}_i=\\sin\\left(\\frac{k\\pi i}{n+1}\\right)$（对于网格指数 $i\\in\\{1,\\ldots,n\\}$）。\n\n- 测试用例1（标准情况，秩为1的动力学）：\n  - 参数：$L=1.0$ $\\mathrm{m}$，$n=32$，$\\alpha=1.0\\times 10^{-4}$ $\\mathrm{m^2/s}$，$\\Delta t=0.05$ $\\mathrm{s}$，$m=50$ 个快照，初始条件是指数为 $k=3$ 的单个特征模态，DMD 秩 $r=1$。\n  - 预期：主导的连续时间增长率 $\\omega$ 应与理论值 $\\alpha \\mu_{k}$ 相匹配，相对误差小于 $10^{-6}$。\n\n- 测试用例2（多模态，秩为2的动力学）：\n  - 参数：$L=1.0$ $\\mathrm{m}$，$n=32$，$\\alpha=1.0\\times 10^{-4}$ $\\mathrm{m^2/s}$，$\\Delta t=0.05$ $\\mathrm{s}$，$m=60$ 个快照，初始条件是指数为 $k_1=2$ 和 $k_2=7$ 的组合 $1.0\\cdot u^{(k_1)}+0.7\\cdot u^{(k_2)}$，DMD 秩 $r=2$。\n  - 预期：在将每个恢复的速率与最接近的理论值配对后，两个主导的连续时间增长率应与 $\\{\\alpha \\mu_{k_1},\\alpha \\mu_{k_2}\\}$ 相匹配，最大相对误差小于 $10^{-5}$。\n\n- 测试用例3（边界情况，近稳态动力学）：\n  - 参数：$L=1.0$ $\\mathrm{m}$，$n=32$，$\\alpha=1.0\\times 10^{-9}$ $\\mathrm{m^2/s}$，$\\Delta t=0.1$ $\\mathrm{s}$，$m=40$ 个快照，初始条件是指数为 $k=5$ 的单个特征模态，DMD 秩 $r=1$。\n  - 预期：主导的连续时间增长率的绝对值应小于 $5.0\\times 10^{-7}$ $\\mathrm{s^{-1}}$。\n\n您的程序必须为每个测试用例计算 DMD 特征值和模态，将离散时间特征值转换为单位为 $\\mathrm{s}^{-1}$ 的连续时间增长率，然后评估所述标准，为每个测试用例生成一个布尔值，指示标准是否得到满足。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[result_1,result_2,result_3]$），其中每个 $result_i$ 为 $True$ 或 $False$。",
            "solution": "该问题是有效的，因为它在科学上基于热物理学和数值分析的原理，问题设定良好，具有明确的目标和可验证的测试用例，并且没有任何矛盾或歧义。\n\n在此，我们推导应用于热传导的动态模态分解 (DMD) 的公式，并提供其实现。\n\n物理过程是长度为 $L$ 的一维杆中的热传导，由热方程控制：\n$$\n\\frac{\\partial T(x,t)}{\\partial t} = \\alpha \\frac{\\partial^2 T(x,t)}{\\partial x^2}\n$$\n其中 $T(x,t)$ 是温度场，$\\alpha$ 是热扩散率。杆具有固定温度的狄利克雷边界条件，$T(0,t) = T_0$ 和 $T(L,t) = T_L$。通过考虑相对于稳态线性分布的温度，我们可以设置齐次边界条件，$T(0,t) = 0$ 和 $T(L,t) = 0$。\n\n将空间域离散为 $n$ 个内部点，间距为 $\\Delta x = L/(n+1)$，我们可以用离散点 $x_i = i \\Delta x$（对于 $i \\in \\{1, \\ldots, n\\}$）来近似空间变量 $x$。温度场变成一个向量 $\\mathbf{x}(t) \\in \\mathbb{R}^n$，其中 $\\mathbf{x}_i(t) \\approx T(x_i, t)$。在点 $x_i$ 处的空间二阶导数 $\\frac{\\partial^2 T}{\\partial x^2}$ 使用二阶中心有限差分格式来近似：\n$$\n\\frac{\\partial^2 T}{\\partial x^2}\\bigg|_{x_i} \\approx \\frac{T(x_{i+1}, t) - 2T(x_i, t) + T(x_{i-1}, t)}{(\\Delta x)^2}\n$$\n这种离散化将偏微分方程转化为一个耦合线性常微分方程组：\n$$\n\\frac{d\\mathbf{x}}{dt} = \\alpha L \\mathbf{x}\n$$\n此处，$L \\in \\mathbb{R}^{n \\times n}$ 是离散拉普拉斯矩阵。对于齐次狄利克雷边界条件，$L$ 是一个对称三对角矩阵，主对角线上的元素为 $-2/(\\Delta x)^2$，第一上、下对角线上的元素为 $1/(\\Delta x)^2$。\n\n该线性常微分方程组的精确解由矩阵指数给出：\n$$\n\\mathbf{x}(t) = \\exp(\\alpha t L) \\mathbf{x}(0)\n$$\n动力学由连续时间算子 $\\alpha L$ 的谱特性决定。$L$ 的特征值在解析上是已知的，为 $\\mu_k = -\\frac{2}{(\\Delta x)^2}\\left(1-\\cos\\left(\\frac{k\\pi}{n+1}\\right)\\right)$，其中 $k \\in \\{1, \\ldots, n\\}$。所有特征值都是实数且为负，反映了热传导的耗散性质。因此，$\\alpha L$ 的特征值为 $\\omega_k = \\alpha \\mu_k$，它们是系统特征模态的连续时间衰减率。更负的 $\\omega_k$ 表示更快的衰减。相应的特征向量 $u^{(k)}$ 是离散的正弦函数，代表了这些模态的空间形状。\n\n动态模态分解 (DMD) 是一种用于分析动力学系统的数据驱动方法。它假设状态从一个时间步到下一个时间步的演化可以由一个线性算子来近似。我们收集系统状态的一系列 $m+1$ 个快照，$\\{\\mathbf{x}_0, \\mathbf{x}_1, \\ldots, \\mathbf{x}_m\\}$，这些快照是在恒定的时间间隔 $\\Delta t$ 拍摄的。在此问题中，快照由精确的传播算子 $A = \\exp(\\alpha \\Delta t L)$ 无噪声地生成，因此有 $\\mathbf{x}_{k+1} = A \\mathbf{x}_k$。\n\n我们从这些快照构建两个数据矩阵，$X$ 和 $Y$。按照规定，$X = [\\mathbf{x}_1, \\mathbf{x}_2, \\dots, \\mathbf{x}_{m-1}]$ 和 $Y = [\\mathbf{x}_2, \\mathbf{x}_3, \\dots, \\mathbf{x}_m]$。控制动力学 $\\mathbf{x}_{k+1} = A \\mathbf{x}_k$ 意味着矩阵关系 $Y = AX$。\n\nDMD 的核心目标是找到近似 $A$ 的“最佳拟合”线性算子。在最小二乘意义上，解由 $A \\approx YX^+$ 给出，其中 $X^+$ 是 $X$ 的 Moore-Penrose 伪逆。对于状态维度 $n$ 很大的系统，计算、存储和分析完整的 $n \\times n$ 算子 $A$ 通常是不可行的。DMD提供了一种优雅的方法来计算 $A$ 的谱特性，而无需构建完整的矩阵。\n\n该过程利用了数据矩阵 $X$ 的奇异值分解 (SVD)。我们计算 $X$ 的“经济”SVD：\n$$\nX = U \\Sigma V^H\n$$\n其中 $U \\in \\mathbb{C}^{n \\times p}$，$\\Sigma \\in \\mathbb{R}^{p \\times p}$，$V \\in \\mathbb{C}^{(m-1) \\times p}$，且 $p = \\min(n, m-1)$。$U$ 的列是左奇异向量（或称本征正交分解模态），它们构成了由 $X$ 中快照张成的空间的标准正交基。对角矩阵 $\\Sigma$ 包含奇异值，这些值量化了每个模态的“能量”或重要性。对于像热传导这样的耗散系统，系统的大部分能量会迅速集中在少数低频、慢衰减的模态中。这意味着奇异值谱会迅速衰减，表明动力学可以在一个低秩子空间内被精确捕捉。因此，我们可以将 SVD 截断到秩 $r \\ll p$：\n$$\nX \\approx U_r \\Sigma_r V_r^H\n$$\n其中 $U_r \\in \\mathbb{C}^{n \\times r}$，$\\Sigma_r \\in \\mathbb{R}^{r \\times r}$，$V_r \\in \\mathbb{C}^{(m-1) \\times r}$。$U_r$ 的列构成了最能捕捉 $X$ 中数据的 $r$ 维子空间的基。\n\n截断后 $X$ 的伪逆是 $X_r^+ = V_r \\Sigma_r^{-1} U_r^H$。完整的算子 $A$ 则近似为 $A \\approx Y X_r^+ = Y V_r \\Sigma_r^{-1} U_r^H$。我们不计算这个大矩阵，而是将其投影到由 $U_r$ 的列张成的低维子空间上。得到的降维算子 $\\tilde{A}_{\\text{red}} \\in \\mathbb{C}^{r \\times r}$ 表示投影到 POD 基上的完整动力学：\n$$\n\\tilde{A}_{\\text{red}} = U_r^H A U_r \\approx U_r^H (Y V_r \\Sigma_r^{-1} U_r^H) U_r\n$$\n由于 $U_r^H U_r = I_r$（$r \\times r$ 单位矩阵），上式简化为：\n$$\n\\tilde{A}_{\\text{red}} = U_r^H Y V_r \\Sigma_r^{-1}\n$$\n这是一个小的 $r \\times r$ 矩阵，其计算成本低廉，易于处理。我们通过标准的特征分解找到它的特征值和特征向量：\n$$\n\\tilde{A}_{\\text{red}} \\mathbf{w}_j = \\lambda_j \\mathbf{w}_j\n$$\n降维算子 $\\tilde{A}_{\\text{red}}$ 的特征值 $\\lambda_j$ 就是 DMD 特征值。它们是完整算子 $A$ 的 $r$ 个主导特征值的出色近似。\n\n完整算子 $A$ 对应的特征向量，即所谓的 DMD 模态 $\\phi_j$，可以被重构。一种标准方法是将投影DMD模态定义为将 $\\tilde{A}_{\\text{red}}$ 的特征向量投影回高维状态空间的结果：\n$$\n\\phi_j = U_r \\mathbf{w}_j\n$$\n每个 DMD 模态 $\\phi_j$ 代表一个相干的空间模式，其振幅根据其对应的 DMD 特征值 $\\lambda_j$ 随时间演化。系统在时间步 $k$ 的状态可以近似为这些模态的线性组合：$\\mathbf{x}_k \\approx \\sum_{j=1}^r c_j \\phi_j (\\lambda_j)^k$。\n\n最后，为了将 DMD 结果与底层的连续时间物理学联系起来，我们将离散时间 DMD 特征值 $\\lambda_j$ 转换为连续时间特征值 $\\omega_j$。由于算子 $A$ 代表了经过一个时间步长 $\\Delta t$ 的演化，它们之间的关系是 $\\lambda_j = \\exp(\\omega_j \\Delta t)$。因此，我们可以恢复连续时间的增长/衰减率和频率：\n$$\n\\omega_j = \\frac{\\ln(\\lambda_j)}{\\Delta t}\n$$\n$\\omega_j$ 的单位是 $\\mathrm{s}^{-1}$。对于热方程，真实的特征值是实数且为负。因此，计算出的 $\\operatorname{Re}(\\omega_j)$ 对应于一个衰减率，表示模态模式 $\\phi_j$ 中的热能耗散的速度。虚部 $\\operatorname{Im}(\\omega_j)$ 代表振荡频率，对于这个纯粹的扩散问题，该值应接近于零。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for Dynamic Mode Decomposition.\n    \"\"\"\n    test_cases = [\n        {\n            'L': 1.0, 'n': 32, 'alpha': 1.0e-4, 'dt': 0.05, 'm': 50,\n            'k_indices': [3], 'coeffs': [1.0], 'r': 1,\n            'check': 'relative_error', 'threshold': 1e-6\n        },\n        {\n            'L': 1.0, 'n': 32, 'alpha': 1.0e-4, 'dt': 0.05, 'm': 60,\n            'k_indices': [2, 7], 'coeffs': [1.0, 0.7], 'r': 2,\n            'check': 'max_relative_error', 'threshold': 1e-5\n        },\n        {\n            'L': 1.0, 'n': 32, 'alpha': 1.0e-9, 'dt': 0.1, 'm': 40,\n            'k_indices': [5], 'coeffs': [1.0], 'r': 1,\n            'check': 'absolute_magnitude', 'threshold': 5.0e-7\n        }\n    ]\n\n    results = [run_dmd_test(**params) for params in test_cases]\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_dmd_test(L, n, alpha, dt, m, k_indices, coeffs, r, check, threshold):\n    \"\"\"\n    Performs a single DMD test case and verifies the result.\n\n    Args:\n        L (float): Length of the rod (m).\n        n (int): Number of interior spatial grid points.\n        alpha (float): Thermal diffusivity (m^2/s).\n        dt (float): Time step size (s).\n        m (int): Number of time steps to generate snapshots.\n        k_indices (list[int]): Indices of the analytical eigenmodes for the initial condition.\n        coeffs (list[float]): Coefficients for the linear combination of eigenmodes.\n        r (int): Rank for DMD truncation.\n        check (str): The type of check to perform ('relative_error', 'max_relative_error', 'absolute_magnitude').\n        threshold (float): The threshold for the check.\n\n    Returns:\n        bool: True if the test passes, False otherwise.\n    \"\"\"\n    \n    # 1. Construct the 1D discrete Laplacian matrix L\n    dx = L / (n + 1.0)\n    main_diag = -2.0 * np.ones(n)\n    off_diag = np.ones(n - 1)\n    L_matrix = (np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)) / (dx**2)\n\n    # 2. Generate the initial condition x0 from analytical eigenvectors\n    x0 = np.zeros(n, dtype=np.float64)\n    grid_points = np.arange(1, n + 1)\n    for k, c in zip(k_indices, coeffs):\n        eigenvector = np.sin(k * np.pi * grid_points / (n + 1.0))\n        x0 += c * eigenvector\n\n    # 3. Generate snapshot data by evolving the system\n    # The exact time-dt propagator is A = exp(alpha * dt * L)\n    A_op = expm(alpha * dt * L_matrix)\n    \n    snapshots = [x0]\n    current_x = x0\n    for _ in range(m):\n        current_x = A_op @ current_x\n        snapshots.append(current_x)\n    \n    # Form data matrices X and Y\n    # X = [x_1, ..., x_{m-1}], Y = [x_2, ..., x_m]\n    X = np.array(snapshots[1:m]).T\n    Y = np.array(snapshots[2:m+1]).T\n\n    # 4. Perform Dynamic Mode Decomposition\n    U, s, Vh = np.linalg.svd(X, full_matrices=False)\n\n    # Truncate to rank r\n    U_r = U[:, :r]\n    s_r = s[:r]\n    Vh_r = Vh[:r, :]\n    V_r = Vh_r.T\n    \n    # 5. Compute the reduced operator A_tilde and its eigendecomposition\n    Sigma_r_inv = np.diag(1.0 / s_r)\n    A_tilde = U_r.T @ Y @ V_r @ Sigma_r_inv\n    \n    dmd_eigvals, _ = np.linalg.eig(A_tilde)\n\n    # 6. Compute continuous-time growth rates (omega)\n    omegas = np.log(dmd_eigvals) / dt\n\n    # 7. Verification against theoretical values\n    theoretical_omegas = []\n    for k in k_indices:\n        mu_k = -2.0 / (dx**2) * (1.0 - np.cos(k * np.pi / (n + 1.0)))\n        theoretical_omegas.append(alpha * mu_k)\n    \n    # For diffusion, omegas should be real. We take the real part for comparison.\n    computed_omegas_real = np.sort(omegas.real)\n    theoretical_omegas_sorted = np.sort(np.array(theoretical_omegas))\n\n    if check == 'relative_error':\n        # Used for Test Case 1\n        rel_error = np.abs((computed_omegas_real[0] - theoretical_omegas_sorted[0]) / theoretical_omegas_sorted[0])\n        return rel_error  threshold\n    \n    elif check == 'max_relative_error':\n        # Used for Test Case 2\n        rel_errors = np.abs((computed_omegas_real - theoretical_omegas_sorted) / theoretical_omegas_sorted)\n        return np.max(rel_errors)  threshold\n    \n    elif check == 'absolute_magnitude':\n        # Used for Test Case 3\n        # The growth rate should be close to the theoretical value. Test checks its magnitude.\n        return np.abs(omegas[0])  threshold\n        \n    return False\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "在掌握了DMD的基本实现之后，一个自然而然的实际问题是如何为分析采集数据。快照的采集时间间隔（$\\Delta t$）的选择至关重要，它直接影响到我们能否准确地解析出流动中的热振荡。本练习将带您探讨在设计数据采集策略时所面临的权衡。您将运用奈奎斯特采样准则来避免频率混叠，并考虑如何在测量噪声存在的情况下，确保所选的$\\Delta t$足以分辨出模式的衰减率，从而为实验或数值模拟的设计提供理论依据。",
            "id": "3949633",
            "problem": "一个热驱动的开腔流动表现出一个主导的振荡热模态，您计划使用动态模态分解 (DMD) 对其进行分析。假设一个代表点处的标量温度脉动遵循线性动力学，其具有一个由连续时间特征值 $s = \\sigma + i \\omega$ 表征的单一主导模态，其中 $\\sigma \\in \\mathbb{R}$ 是阻尼率，$\\omega = 2 \\pi f$，且振荡频率 $f \\in \\mathbb{R}^{+}$。时间离散的DMD特征值通过 $\\lambda = \\exp(s \\Delta t)$ 与连续时间特征值相关联，其中 $\\Delta t$ 是快照时间间隔。\n\n您获得了以下用于计划采集的设计信息：\n\n- 主导振荡频率 $f = 80\\,\\mathrm{Hz}$。\n- 预期的指数衰减率大小 $\\gamma = -\\sigma = 50\\,\\mathrm{s}^{-1}$ (即 $\\sigma = -50\\,\\mathrm{s}^{-1}$)。\n- 测量噪声相对于瞬时信号幅值的相对标准差为 $\\nu = 0.005$ (无量纲)，并且您要求由阻尼引起的每个快照的相对幅值变化至少为 $k \\nu$ (其中 $k = 5$)，以5倍的系数超过噪声。\n\n仅使用基本原理，即：\n- 用于无混叠地解析频率为 $f$ 的振荡的奈奎斯特-香农采样准则，以及\n- 线性热脉动的指数松弛及其到时间离散DMD特征值幅值的映射，\n\n确定在所述噪声准则下，既能避免混叠又能确保每个快照的阻尼是可解析的最大的快照时间间隔 $\\Delta t$。\n\n以毫秒为单位表示最终的时间步长，并将您的答案四舍五入到三位有效数字。",
            "solution": "我们从两个基本依据出发：\n\n1. 奈奎斯特-香农采样准则：为避免最高频率为 $f$ 的带限信号发生混叠，采样频率 $f_{s}$ 必须满足 $f_{s} \\geq 2 f$。由于 $f_{s} = 1/\\Delta t$，这得出了以下约束条件\n$$\n\\Delta t \\leq \\frac{1}{2 f}.\n$$\n\n2. 线性指数松弛及其在动态模态分解 (DMD) 中的离散映射：对于一个具有连续时间特征值 $s = \\sigma + i \\omega$ 的线性模态，在快照时间间隔 $\\Delta t$ 内的离散时间特征值为\n$$\n\\lambda = \\exp(s \\Delta t) = \\exp(\\sigma \\Delta t) \\exp(i \\omega \\Delta t).\n$$\n$\\lambda$ 的大小为 $|\\lambda| = \\exp(\\sigma \\Delta t)$。对于一个衰减模态，$\\sigma = -\\gamma  0$ 且 $\\gamma > 0$，因此 $|\\lambda| = \\exp(-\\gamma \\Delta t)  1$。由阻尼引起的每个快照的相对幅值变化（即从一个快照到下一个快照的缩减因子）是\n$$\n1 - |\\lambda| = 1 - \\exp(-\\gamma \\Delta t).\n$$\n为确保阻尼在测量噪声下是可解析的，该变化应超过一个与相对噪声标准差 $\\nu$ 相关的指定阈值。为实现与噪声的保守分离，我们采用 $k$-sigma 准则，并施加以下条件\n$$\n1 - \\exp(-\\gamma \\Delta t) \\geq k \\nu,\n$$\n其中 $k = 5$ 且 $\\nu = 0.005$。对 $\\Delta t$ 求解此不等式，可得到一个下界：\n$$\n\\exp(-\\gamma \\Delta t) \\leq 1 - k \\nu\n\\;\\;\\Rightarrow\\;\\;\n-\\gamma \\Delta t \\leq \\ln(1 - k \\nu)\n\\;\\;\\Rightarrow\\;\\;\n\\Delta t \\geq -\\frac{1}{\\gamma} \\ln(1 - k \\nu).\n$$\n\n因此，快照时间间隔 $\\Delta t$ 必须位于以下区间内\n$$\n-\\frac{1}{\\gamma} \\ln(1 - k \\nu) \\;\\leq\\; \\Delta t \\;\\leq\\; \\frac{1}{2 f}.\n$$\n为了在满足两个约束条件的同时最小化数据量，我们选择可行的最大 $\\Delta t$，即\n$$\n\\Delta t^{\\star} = \\frac{1}{2 f},\n$$\n条件是 $\\frac{1}{2 f} \\geq -\\frac{1}{\\gamma} \\ln(1 - k \\nu)$。\n\n现在我们用给定的参数来评估这些边界：\n- 频率: $f = 80\\,\\mathrm{Hz}$ 给出\n$$\n\\Delta t_{\\text{Nyquist}} = \\frac{1}{2 f} = \\frac{1}{2 \\times 80} = \\frac{1}{160} = 0.00625\\,\\mathrm{s}.\n$$\n- 阻尼可解析性下界，其中 $\\gamma = 50\\,\\mathrm{s}^{-1}$，$k = 5$ 且 $\\nu = 0.005$：\n$$\n\\Delta t_{\\min} = -\\frac{1}{\\gamma} \\ln(1 - k \\nu)\n= -\\frac{1}{50} \\ln(1 - 5 \\times 0.005)\n= -\\frac{1}{50} \\ln(1 - 0.025)\n= -\\frac{1}{50} \\ln(0.975).\n$$\n计算对数值，然后求值：\n$$\n\\ln(0.975) \\approx -0.025317,\n\\quad\n\\Rightarrow\n\\Delta t_{\\min} \\approx -\\frac{1}{50} \\times (-0.025317)\n= \\frac{0.025317}{50}\n\\approx 0.00050634\\,\\mathrm{s}.\n$$\n\n可行性检查：\n$$\n\\Delta t_{\\text{Nyquist}} = 0.00625\\,\\mathrm{s}\n\\quad\\text{and}\\quad\n\\Delta t_{\\min} \\approx 0.00050634\\,\\mathrm{s},\n$$\n因此 $\\Delta t_{\\text{Nyquist}} \\geq \\Delta t_{\\min}$，可行区间非空。在两个准则下，最大允许间隔为\n$$\n\\Delta t^{\\star} = \\Delta t_{\\text{Nyquist}} = 0.00625\\,\\mathrm{s}.\n$$\n\n转换为毫秒：\n$$\n\\Delta t^{\\star} = 0.00625\\,\\mathrm{s} = 6.25\\,\\mathrm{ms}.\n$$\n\n四舍五入到三位有效数字，合适的快照时间间隔为 $6.25\\,\\mathrm{ms}$。",
            "answer": "$$\\boxed{6.25}$$"
        },
        {
            "introduction": "理论上，我们总希望满足奈奎斯特采样准则，但在实践中，由于硬件限制或对系统先验知识的缺乏，我们可能会遇到采样不足的情况。这会导致一种被称为“混叠”（aliasing）的现象，即高频信号被错误地识别为低频信号。本练习旨在让您直面这一DMD分析中的常见陷阱。您将通过编程模拟混叠过程，并实现一种巧妙的校正策略——利用两种不同的采样率来明确地恢复真实的频率。这个实践不仅加深了您对采样理论的理解，还为您提供了一种强大的故障排除技术。",
            "id": "3949623",
            "problem": "对流传热场中的单个相干热模式可局部建模为 $T_{\\text{mode}}(t) = \\Re\\{a \\, e^{\\omega t}\\}$ 形式的复指数响应，其中 $a \\in \\mathbb{C}$，$t$ 是以秒为单位的时间，复角频率为 $\\omega = \\sigma + i \\, 2 \\pi f$，其中 $\\sigma \\in \\mathbb{R}$ 表示以 $\\text{s}^{-1}$ 为单位的实值增长或衰减率，$f \\in \\mathbb{R}_{\\ge 0}$ 是以赫兹为单位的物理振荡频率。动态模态分解 (Dynamic Mode Decomposition, DMD) 是一种数据驱动的谱分解方法，它通过以秒为单位的采样间隔 $\\Delta t$ 均匀采样的时间快照来近似底层的线性算子。对于单个模式，离散时间特征值为 $$\\lambda = e^{\\omega \\Delta t}.$$ 使用辐角 $\\operatorname{Arg}(\\lambda) \\in (-\\pi, \\pi]$ 定义的主复对数，可得出 DMD 估计值 $$\\hat{\\omega} = \\frac{1}{\\Delta t} \\log(\\lambda),$$ 这意味着其虚部满足 $$\\Im(\\hat{\\omega}) = \\frac{\\theta}{\\Delta t}, \\quad \\text{其中 } \\theta = \\operatorname{Arg}(\\lambda) \\in (-\\pi, \\pi].$$ 这为 $\\Im(\\hat{\\omega})$ 施加了一个 $(-\\pi/\\Delta t, \\pi/\\Delta t]$ 的频率窗口，即对推断出的角频率的奈奎斯特限制。因此，不充分的采样间隔 $\\Delta t$ 会通过加或减 $2 \\pi$ 的整数倍，将真实的虚部 $\\Im(\\omega) = 2 \\pi f$ 混叠到主分支中，这会将真实频率 $f$ 映射到一个错误的观测值 $\\hat{f} = \\Im(\\hat{\\omega})/(2 \\pi)$。\n\n您的任务是形式化并实现混叠机制，然后使用基于两种不同采样间隔的、有原则的策略对频率进行去混叠。程序必须：\n\n- 对于每个测试用例，将热模式视为具有给定真实频率 $f$（单位：赫兹）和增长率 $\\sigma$（单位：$\\text{s}^{-1}$）的精确单频模式。构建相应的连续时间特征值映射，并计算两种采样间隔 $\\Delta t_a$ 和 $\\Delta t_b$（单位：秒）的离散时间特征值。\n- 计算由主分支引起的混叠观测值：对于每个 $\\Delta t_j$，构建 $\\lambda_j = \\exp((\\sigma + i 2 \\pi f) \\Delta t_j)$，计算 $\\theta_j = \\operatorname{Arg}(\\lambda_j)$（单位：弧度），然后计算观测频率 $\\hat{f}_j = \\theta_j/(2 \\pi \\Delta t_j)$（单位：赫兹）。\n- 通过模关系 $$2 \\pi f = \\frac{\\theta_j}{\\Delta t_j} + \\frac{2 \\pi n_j}{\\Delta t_j}, \\quad n_j \\in \\mathbb{Z},$$ 展示不充分的 $\\Delta t$ 如何将真实频率 $f$ 映射到 $\\Im(\\hat{\\omega})$，这可以得出 $$f = \\frac{\\theta_j + 2 \\pi n_j}{2 \\pi \\Delta t_j}.$$\n- 实现一个校正策略，使用两种采样间隔来求解整数 $n_a$ 和 $n_b$。给定一个已知的频率上限 $f_{\\max}$（单位：赫兹），搜索整数对 $(n_a, n_b)$，使得由 $\\Delta t_a$ 和 $\\Delta t_b$ 得出的两个关于 $f$ 的表达式在一个很小的容差范围内一致，并且 $f \\in [0, f_{\\max}]$。将恢复的频率 $\\tilde{f}$ 报告为两个一致值的平均值。角度必须以弧度处理。搜索容差应为 $10^{-9}$ 赫兹，并且您应该在 $\\{-N_j, \\ldots, N_j\\}$ 的范围内搜索 $n_j$，其中 $N_j = \\lceil f_{\\max} \\Delta t_j \\rceil + 2$。\n- 每个测试用例最终报告的量仅为校正后的去混叠频率 $\\tilde{f}$（单位：赫兹）。在程序内部，您必须计算混叠值 $\\hat{f}_j$ 以验证映射关系，但最终输出应仅包含 $\\tilde{f}$。\n\n使用以下测试套件。每个元组为 $(f, \\sigma, \\Delta t_a, \\Delta t_b, f_{\\max})$：\n\n- 用例 $1$（两种采样间隔均无混叠）：$(20.0, -1.0, 0.01, 0.012, 100.0)$，其中 $f$ 的单位为赫兹，$\\sigma$ 的单位为 $\\text{s}^{-1}$，$\\Delta t$ 的单位为秒。\n- 用例 $2$（两种采样间隔均有混叠）：$(120.0, -5.0, 0.01, 0.008, 200.0)$。\n- 用例 $3$（$\\Delta t_a$ 处于奈奎斯特边界）：$(50.0, 0.0, 0.01, 0.0092, 100.0)$。\n- 用例 $4$（显著混叠伴随轻微增长）：$(300.0, 2.0, 0.004, 0.0033, 500.0)$。\n\n物理单位和数值约定：\n\n- 所有频率 $f$、$\\hat{f}_j$ 和 $\\tilde{f}$ 必须以赫兹表示，并四舍五入到六位小数。\n- 所有时间间隔 $\\Delta t$ 的单位均为秒。\n- 所有角度的单位均为弧度。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述用例顺序排列，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_k$ 是校正后的去混叠频率 $\\tilde{f}$（单位：赫兹），并四舍五入到六位小数。输出必须是单行，不含任何额外文本。",
            "solution": "该问题是有效的，因为它科学地基于线性系统和信号处理的原理（特别是连续时间系统的离散时间表示和奈奎斯特-香农采样定理），问题适定，目标明确，信息充分，并且其表述是客观的。\n\n解决方案首先将动态模态分解 (DMD) 中固有的混叠现象形式化，然后实现一个系统性搜索算法来消除混叠，并恢复热模式的真实频率。\n\n单个热模式通过复指数响应 $T_{\\text{mode}}(t) = \\Re\\{a \\, e^{\\omega t}\\}$ 进行建模，其动态由连续时间特征值 $\\omega = \\sigma + i \\, 2 \\pi f$ 控制。此处，$\\sigma$ 是以 $\\text{s}^{-1}$ 为单位的增长/衰减率，$f \\ge 0$ 是以赫兹为单位的振荡频率。\n\n当这个连续时间过程以均匀的时间间隔 $\\Delta t$ 进行采样时，所得到的离散时间系统由离散时间特征值 $\\lambda$ 描述，它通过以下映射关系与 $\\omega$ 相关联：\n$$ \\lambda = e^{\\omega \\Delta t} = e^{(\\sigma + i 2 \\pi f) \\Delta t} = e^{\\sigma \\Delta t} e^{i 2 \\pi f \\Delta t} $$\nDMD 从数据中近似这个特征值 $\\lambda$。为了恢复连续时间动态，必须计算 $\\lambda$ 的复对数：\n$$ \\hat{\\omega} = \\frac{1}{\\Delta t} \\log(\\lambda) $$\n标准复对数函数 $\\log(z) = \\ln|z| + i \\operatorname{Arg}(z)$ 使用主辐角 $\\operatorname{Arg}(z) \\in (-\\pi, \\pi]$。将此应用于我们的特征值 $\\lambda$：\n$$\n\\log(\\lambda) = \\ln|e^{\\sigma \\Delta t} e^{i 2 \\pi f \\Delta t}| + i \\operatorname{Arg}(e^{\\sigma \\Delta t} e^{i 2 \\pi f \\Delta t})\n= \\ln(e^{\\sigma \\Delta t}) + i \\operatorname{Arg}(e^{i 2 \\pi f \\Delta t})\n= \\sigma \\Delta t + i \\theta\n$$\n其中 $\\theta = \\operatorname{Arg}(e^{i 2 \\pi f \\Delta t})$ 是真实相位 $2 \\pi f \\Delta t$ 被卷绕到区间 $(-\\pi, \\pi]$ 内的值。\n因此，恢复的连续时间特征值为：\n$$ \\hat{\\omega} = \\frac{1}{\\Delta t}(\\sigma \\Delta t + i \\theta) = \\sigma + i \\frac{\\theta}{\\Delta t} $$\n虽然实部 $\\Re(\\hat{\\omega}) = \\sigma$ 被正确恢复，但虚部发生了混叠。真实相位 $\\phi_{\\text{true}} = 2 \\pi f \\Delta t$ 和观测相位 $\\theta$ 通过一个未知的 $2\\pi$ 整数倍相关联：\n$$ 2 \\pi f \\Delta t = \\theta + 2 \\pi n, \\quad n \\in \\mathbb{Z} $$\n这个整数 $n$ 表示将真实相位映射到主分支时“丢失”的完整 $2\\pi$ 旋转圈数。两边同除以 $2 \\pi \\Delta t$ 得到真实频率 $f$ 与观测到的量之间的关系：\n$$ f = \\frac{\\theta + 2 \\pi n}{2 \\pi \\Delta t} $$\n对应于 $n=0$ 的观测频率 $\\hat{f}$ 是 $\\hat{f} = \\frac{\\theta}{2 \\pi \\Delta t}$。这就是混叠值。\n\n为了找到真实频率 $f$，我们必须确定未知的整数 $n$。所提出的策略使用两个不同的采样间隔 $\\Delta t_a$ 和 $\\Delta t_b$。对于每个采样间隔，我们可以计算离散特征值 $\\lambda_j$ 及其主辐角 $\\theta_j$（其中 $j \\in \\{a, b\\}$）。这会产生一个包含两个未知整数 $n_a$ 和 $n_b$ 的方程组：\n$$ f = \\frac{\\theta_a + 2 \\pi n_a}{2 \\pi \\Delta t_a} $$\n$$ f = \\frac{\\theta_b + 2 \\pi n_b}{2 \\pi \\Delta t_b} $$\n去混叠算法的核心是找到一个整数对 $(n_a, n_b)$，使得这两个关于 $f$ 的表达式一致。我们搜索这样一对整数，使得计算出的频率（我们记为 $f_a(n_a)$ 和 $f_b(n_b)$）在一个小的容差 $\\epsilon = 10^{-9}$ Hz 内相等：\n$$ |f_a(n_a) - f_b(n_b)|  \\epsilon $$\n此外，解必须具有物理意义，受上限 $f_{\\max}$ 的约束，因此我们要求 $0 \\le f \\le f_{\\max}$。\n\n对 $n_j$ 的搜索在一个有限范围 $\\{-N_j, \\ldots, N_j\\}$ 内进行，其中 $N_j = \\lceil f_{\\max} \\Delta t_j \\rceil + 2$。这个范围的构建是为了确保其足够大，能够包含任何频率直至 $f_{\\max}$ 的真实整数缠绕计数。\n\n对于每个测试用例，算法流程如下：\n1. 给定 $f$, $\\sigma$, $\\Delta t_a$, $\\Delta t_b$ 和 $f_{\\max}$。\n2. 计算真实的连续时间特征值 $\\omega = \\sigma + i 2\\pi f$。\n3. 对于每个采样时间 $\\Delta t_j$ ($j=a,b$)：\n   a. 计算离散时间特征值 $\\lambda_j = e^{\\omega \\Delta t_j}$。\n   b. 提取主辐角 $\\theta_j = \\operatorname{Arg}(\\lambda_j)$。\n4. 使用 $N_j = \\lceil f_{\\max} \\Delta t_j \\rceil + 2$ 确定 $n_a$ 和 $n_b$ 的搜索范围。\n5. 在这些搜索范围内遍历所有整数对 $(n_a, n_b)$。对于每一对：\n   a. 计算候选频率 $f_{\\text{cand}, a} = (\\theta_a + 2\\pi n_a)/(2\\pi \\Delta t_a)$ 和 $f_{\\text{cand}, b} = (\\theta_b + 2\\pi n_b)/(2\\pi \\Delta t_b)$。\n   b. 检查候选值是否满足以下条件：\n      i. $|f_{\\text{cand}, a} - f_{\\text{cand}, b}|  10^{-9}$\n      ii. $0 \\le f_{\\text{cand}, a} \\le f_{\\max}$\n      iii. $0 \\le f_{\\text{cand}, b} \\le f_{\\max}$\n6. 如果一对整数满足所有条件，则找到了去混叠频率 $\\tilde{f}$。它被计算为两个一致候选值的平均值：$\\tilde{f} = (f_{\\text{cand}, a} + f_{\\text{cand}, b}) / 2$。然后将该值四舍五入到六位小数作为最终结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the unaliased frequency of a thermal mode given two\n    different sampling intervals.\n    \"\"\"\n    # Test cases: Each tuple is (f, sigma, dt_a, dt_b, f_max)\n    test_cases = [\n        (20.0, -1.0, 0.01, 0.012, 100.0),   # Case 1\n        (120.0, -5.0, 0.01, 0.008, 200.0),  # Case 2\n        (50.0, 0.0, 0.01, 0.0092, 100.0),   # Case 3\n        (300.0, 2.0, 0.004, 0.0033, 500.0)   # Case 4\n    ]\n\n    results = []\n    \n    # Define constants\n    pi = np.pi\n    two_pi = 2 * pi\n    tolerance = 1e-9\n\n    for case in test_cases:\n        f_true, sigma, dt_a, dt_b, f_max = case\n        \n        # 1. Calculate the continuous-time eigenvalue omega\n        omega = sigma + 1j * two_pi * f_true\n\n        # 2. For each sampling time, compute the discrete eigenvalue lambda\n        #    and its principal argument theta\n        lambda_a = np.exp(omega * dt_a)\n        theta_a = np.angle(lambda_a)\n\n        lambda_b = np.exp(omega * dt_b)\n        theta_b = np.angle(lambda_b)\n\n        # 3. Determine the search ranges for integers n_a and n_b\n        # The range is [-N, N] where N = ceil(f_max * dt) + 2\n        N_a = int(np.ceil(f_max * dt_a)) + 2\n        N_b = int(np.ceil(f_max * dt_b)) + 2\n        \n        found_solution = False\n        f_tilde = np.nan\n\n        # 4. Iterate through integer pairs (n_a, n_b) to find a consistent solution\n        for n_a in range(-N_a, N_a + 1):\n            for n_b in range(-N_b, N_b + 1):\n                # Calculate candidate frequencies\n                f_cand_a = (theta_a + two_pi * n_a) / (two_pi * dt_a)\n                f_cand_b = (theta_b + two_pi * n_b) / (two_pi * dt_b)\n\n                # Check if candidates meet the criteria\n                # a) Frequencies are close to each other\n                # b) Frequencies are within the physical bounds [0, f_max]\n                if abs(f_cand_a - f_cand_b)  tolerance:\n                    if 0.0 = f_cand_a = f_max and 0.0 = f_cand_b = f_max:\n                        # 5. A valid solution is found. Average the results.\n                        f_tilde = (f_cand_a + f_cand_b) / 2.0\n                        found_solution = True\n                        break\n            if found_solution:\n                break\n        \n        # 6. Round the final result to 6 decimal places and append\n        results.append(f\"{round(f_tilde, 6):.6f}\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        }
    ]
}