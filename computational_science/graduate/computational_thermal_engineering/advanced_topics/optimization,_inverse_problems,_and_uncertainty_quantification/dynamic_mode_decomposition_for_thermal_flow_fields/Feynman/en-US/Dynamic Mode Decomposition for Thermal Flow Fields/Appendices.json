{
    "hands_on_practices": [
        {
            "introduction": "The best way to understand an algorithm is to build it from the ground up. This first exercise guides you through implementing the core Dynamic Mode Decomposition (DMD) algorithm for a classic thermal problem: one-dimensional heat conduction in a rod. By applying DMD to data generated from a system with known analytical solutions, you can rigorously verify that your implementation correctly extracts the physical decay rates and spatial modes, providing a solid foundation for analyzing more complex flows. ",
            "id": "3949672",
            "problem": "Consider a one-dimensional homogeneous rod of length $L$ subject to pure thermal conduction, with fixed-temperature Dirichlet boundary conditions at both ends. The temperature field $T(x,t)$ satisfies the heat equation $\\frac{\\partial T}{\\partial t}=\\alpha \\frac{\\partial^2 T}{\\partial x^2}$, where $\\alpha$ is the thermal diffusivity. Discretize the rod into $n$ interior points with uniform spacing $\\Delta x=L/(n+1)$, and use a second-order centered finite difference to approximate the spatial Laplacian. This yields a linear ordinary differential equation in $\\mathbb{R}^n$ of the form $\\frac{d \\mathbf{x}}{dt}=\\alpha L \\mathbf{x}$, where $L \\in \\mathbb{R}^{n \\times n}$ is the discrete Laplacian matrix with Dirichlet boundary conditions. The exact time-$\\Delta t$ evolution operator is $A=\\exp(\\alpha \\Delta t L)$, where $\\exp(\\cdot)$ denotes the matrix exponential.\n\nYou will form snapshot matrices $X \\in \\mathbb{R}^{n \\times (m-1)}$ and $Y \\in \\mathbb{R}^{n \\times (m-1)}$ by evolving an initial state $\\mathbf{x}_0$ under $A$ for $m$ time steps of size $\\Delta t$ seconds, so that the columns of $X$ are $\\{\\mathbf{x}_1,\\ldots,\\mathbf{x}_{m-1}\\}$ and the columns of $Y$ are $\\{\\mathbf{x}_2,\\ldots,\\mathbf{x}_m\\}$, with $\\mathbf{x}_{k+1}=A\\mathbf{x}_k$. Dynamic Mode Decomposition (DMD) seeks a low-rank linear operator that advances the snapshots from $X$ to $Y$ and decomposes the dynamics into coherent modes with associated growth rates.\n\nStarting from the singular value decomposition of $X$ and using the definition of the Moore–Penrose pseudoinverse, derive the reduced operator in the subspace spanned by the dominant left singular vectors and the corresponding DMD mode construction. Explain each step by anchoring to the physics of thermal conduction, including the role of the discrete Laplacian and the interpretation of the continuous-time growth rates in $\\mathrm{s}^{-1}$.\n\nImplement a program that:\n- Constructs the discrete Laplacian $L$ for a one-dimensional rod with Dirichlet boundary conditions.\n- Generates synthetic snapshot data by evolving an initial condition with the exact operator $A=\\exp(\\alpha \\Delta t L)$.\n- Performs Dynamic Mode Decomposition by computing the singular value decomposition of $X$, forming the reduced operator, computing its eigen-decomposition, and then computing the DMD modes.\n- Converts the discrete-time eigenvalues to continuous-time growth rates using the complex logarithm divided by $\\Delta t$ and interprets these rates in $\\mathrm{s}^{-1}$.\n\nFor numerical units, use $L$ in meters and $\\Delta t$ in seconds. Temperatures are in Kelvin, but numerical values will be unitless scalings of eigenvectors since the operator is linear; the continuous-time growth rates must be expressed in $\\mathrm{s}^{-1}$.\n\nYou must evaluate your implementation against the following test suite. In each case, construct the specified initial condition from exact eigenvectors of the discrete Laplacian so that the theoretical continuous-time growth rates are known. Use the analytical discrete Laplacian eigenvalues for Dirichlet boundaries, given by $\\mu_k=-\\frac{2}{\\Delta x^2}\\left(1-\\cos\\left(\\frac{k\\pi}{n+1}\\right)\\right)$ for mode index $k\\in\\{1,\\ldots,n\\}$, and the corresponding eigenvectors $u^{(k)}_i=\\sin\\left(\\frac{k\\pi i}{n+1}\\right)$ for grid index $i\\in\\{1,\\ldots,n\\}$.\n\n- Test Case 1 (happy path, rank-$1$ dynamics):\n  - Parameters: $L=1.0$ $\\mathrm{m}$, $n=32$, $\\alpha=1.0\\times 10^{-4}$ $\\mathrm{m^2/s}$, $\\Delta t=0.05$ $\\mathrm{s}$, $m=50$ snapshots, initial condition is a single eigenmode with index $k=3$, DMD rank $r=1$.\n  - Expected: The dominant continuous-time growth rate $\\omega$ should match the theoretical value $\\alpha \\mu_{k}$ within a relative error less than $10^{-6}$.\n\n- Test Case 2 (multiple modes, rank-$2$ dynamics):\n  - Parameters: $L=1.0$ $\\mathrm{m}$, $n=32$, $\\alpha=1.0\\times 10^{-4}$ $\\mathrm{m^2/s}$, $\\Delta t=0.05$ $\\mathrm{s}$, $m=60$ snapshots, initial condition is a combination $1.0\\cdot u^{(k_1)}+0.7\\cdot u^{(k_2)}$ with indices $k_1=2$ and $k_2=7$, DMD rank $r=2$.\n  - Expected: The two dominant continuous-time growth rates should match $\\{\\alpha \\mu_{k_1},\\alpha \\mu_{k_2}\\}$ within a maximum relative error less than $10^{-5}$ after pairing each recovered rate with the closest theoretical value.\n\n- Test Case 3 (boundary case, near-stationary dynamics):\n  - Parameters: $L=1.0$ $\\mathrm{m}$, $n=32$, $\\alpha=1.0\\times 10^{-9}$ $\\mathrm{m^2/s}$, $\\Delta t=0.1$ $\\mathrm{s}$, $m=40$ snapshots, initial condition is a single eigenmode with index $k=5$, DMD rank $r=1$.\n  - Expected: The dominant continuous-time growth rate magnitude should be less than $5.0\\times 10^{-7}$ $\\mathrm{s^{-1}}$.\n\nYour program must compute the DMD eigenvalues and modes for each test case, convert the discrete-time eigenvalues to continuous-time growth rates in $\\mathrm{s}^{-1}$, and then evaluate the described criteria to produce a boolean for each test case indicating whether the criterion is satisfied. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,result_3]$), where each $result_i$ is either $True$ or $False$.",
            "solution": "The problem is valid as it is scientifically grounded in the principles of thermal physics and numerical analysis, is well-posed with a clear objective and verifiable test cases, and is free of any contradictions or ambiguities.\n\nHerein, we derive the formulation for Dynamic Mode Decomposition (DMD) applied to thermal conduction and provide its implementation.\n\nThe physical process is thermal conduction in a one-dimensional rod of length $L$, governed by the heat equation:\n$$\n\\frac{\\partial T(x,t)}{\\partial t} = \\alpha \\frac{\\partial^2 T(x,t)}{\\partial x^2}\n$$\nwhere $T(x,t)$ is the temperature field and $\\alpha$ is the thermal diffusivity. The rod has fixed-temperature Dirichlet boundary conditions, $T(0,t) = T_0$ and $T(L,t) = T_L$. By considering the temperature relative to the steady-state linear profile, we can set homogeneous boundary conditions, $T(0,t) = 0$ and $T(L,t) = 0$.\n\nDiscretizing the spatial domain into $n$ interior points with spacing $\\Delta x = L/(n+1)$, we can approximate the spatial variable $x$ by discrete points $x_i = i \\Delta x$ for $i \\in \\{1, \\ldots, n\\}$. The temperature field becomes a vector $\\mathbf{x}(t) \\in \\mathbb{R}^n$, where $\\mathbf{x}_i(t) \\approx T(x_i, t)$. The second spatial derivative $\\frac{\\partial^2 T}{\\partial x^2}$ at point $x_i$ is approximated using a second-order centered finite difference scheme:\n$$\n\\frac{\\partial^2 T}{\\partial x^2}\\bigg|_{x_i} \\approx \\frac{T(x_{i+1}, t) - 2T(x_i, t) + T(x_{i-1}, t)}{(\\Delta x)^2}\n$$\nThis discretization transforms the partial differential equation into a system of coupled linear ordinary differential equations:\n$$\n\\frac{d\\mathbf{x}}{dt} = \\alpha L \\mathbf{x}\n$$\nHere, $L \\in \\mathbb{R}^{n \\times n}$ is the discrete Laplacian matrix. For homogeneous Dirichlet boundary conditions, $L$ is a symmetric tridiagonal matrix with $-2/(\\Delta x)^2$ on the main diagonal and $1/(\\Delta x)^2$ on the first super- and sub-diagonals.\n\nThe exact solution to this linear ODE system is given by the matrix exponential:\n$$\n\\mathbf{x}(t) = \\exp(\\alpha t L) \\mathbf{x}(0)\n$$\nThe dynamics are governed by the spectral properties of the continuous-time operator $\\alpha L$. The eigenvalues of $L$ are known analytically to be $\\mu_k = -\\frac{2}{(\\Delta x)^2}\\left(1-\\cos\\left(\\frac{k\\pi}{n+1}\\right)\\right)$ for $k \\in \\{1, \\ldots, n\\}$. All eigenvalues are real and negative, reflecting the dissipative nature of thermal conduction. The eigenvalues of $\\alpha L$ are thus $\\omega_k = \\alpha \\mu_k$, which are the continuous-time decay rates of the system's eigenmodes. A more negative $\\omega_k$ signifies a more rapid decay. The corresponding eigenvectors, $u^{(k)}$, are discrete sine functions representing the spatial shapes of these modes.\n\nDynamic Mode Decomposition (DMD) is a data-driven method for analyzing dynamical systems. It assumes that the evolution of the state from one time step to the next can be approximated by a linear operator. We collect a sequence of $m+1$ snapshots of the system state, $\\{\\mathbf{x}_0, \\mathbf{x}_1, \\ldots, \\mathbf{x}_m\\}$, taken at a constant time interval $\\Delta t$. In this problem, the snapshots are generated noise-free from the exact propagator $A = \\exp(\\alpha \\Delta t L)$, such that $\\mathbf{x}_{k+1} = A \\mathbf{x}_k$.\n\nWe form two data matrices, $X$ and $Y$, from these snapshots. As specified, $X = [\\mathbf{x}_1, \\mathbf{x}_2, \\dots, \\mathbf{x}_{m-1}]$ and $Y = [\\mathbf{x}_2, \\mathbf{x}_3, \\dots, \\mathbf{x}_m]$. The governing dynamics $ \\mathbf{x}_{k+1} = A \\mathbf{x}_k $ imply the matrix relationship $Y = AX$.\n\nThe core goal of DMD is to find the \"best-fit\" linear operator that approximates $A$. In a least-squares sense, the solution is given by $A \\approx YX^+$, where $X^+$ is the Moore-Penrose pseudoinverse of $X$. For a system with a large state dimension $n$, computing, storing, and analyzing the full $n \\times n$ operator $A$ is often intractable. DMD provides an elegant way to compute the spectral properties of $A$ without ever forming the full matrix.\n\nThe procedure leverages the Singular Value Decomposition (SVD) of the data matrix $X$. We compute the \"economy\" SVD of $X$:\n$$\nX = U \\Sigma V^H\n$$\nwhere $U \\in \\mathbb{C}^{n \\times p}$, $\\Sigma \\in \\mathbb{R}^{p \\times p}$, $V \\in \\mathbb{C}^{(m-1) \\times p}$, and $p = \\min(n, m-1)$. The columns of $U$ are the left singular vectors (or Proper Orthogonal Decomposition modes), which form an orthonormal basis for the space spanned by the snapshots in $X$. The diagonal matrix $\\Sigma$ contains the singular values, which quantify the \"energy\" or importance of each mode. For a dissipative system like thermal conduction, most of the system's energy quickly becomes concentrated in a few low-frequency, slowly-decaying modes. This means the singular value spectrum will decay rapidly, suggesting that the dynamics can be accurately captured within a low-rank subspace. We can therefore truncate the SVD to a rank $r \\ll p$:\n$$\nX \\approx U_r \\Sigma_r V_r^H\n$$\nwhere $U_r \\in \\mathbb{C}^{n \\times r}$, $\\Sigma_r \\in \\mathbb{R}^{r \\times r}$, and $V_r \\in \\mathbb{C}^{(m-1) \\times r}$. The columns of $U_r$ form a basis for the $r$-dimensional subspace that best captures the data in $X$.\n\nThe pseudoinverse of the truncated $X$ is $X_r^+ = V_r \\Sigma_r^{-1} U_r^H$. The full operator $A$ is then approximated as $A \\approx Y X_r^+ = Y V_r \\Sigma_r^{-1} U_r^H$. Instead of computing this large matrix, we project it onto the low-dimensional subspace spanned by the columns of $U_r$. The resulting reduced operator, $\\tilde{A}_{\\text{red}} \\in \\mathbb{C}^{r \\times r}$, represents the full dynamics projected onto the POD basis:\n$$\n\\tilde{A}_{\\text{red}} = U_r^H A U_r \\approx U_r^H (Y V_r \\Sigma_r^{-1} U_r^H) U_r\n$$\nSince $U_r^H U_r = I_r$ (the $r \\times r$ identity matrix), this simplifies to:\n$$\n\\tilde{A}_{\\text{red}} = U_r^H Y V_r \\Sigma_r^{-1}\n$$\nThis is a small $r \\times r$ matrix that is computationally inexpensive to handle. We find its eigenvalues and eigenvectors through a standard eigendecomposition:\n$$\n\\tilde{A}_{\\text{red}} \\mathbf{w}_j = \\lambda_j \\mathbf{w}_j\n$$\nThe eigenvalues $\\lambda_j$ of the reduced operator $\\tilde{A}_{\\text{red}}$ are the DMD eigenvalues. They are excellent approximations of the $r$ dominant eigenvalues of the full operator $A$.\n\nThe corresponding eigenvectors of the full operator $A$, known as the DMD modes $\\phi_j$, can be reconstructed. A standard approach is to define the projected DMD modes as the projection of the eigenvectors of $\\tilde{A}_{\\text{red}}$ back into the high-dimensional state space:\n$$\n\\phi_j = U_r \\mathbf{w}_j\n$$\nEach DMD mode $\\phi_j$ represents a coherent spatial pattern whose amplitude evolves in time according to its corresponding DMD eigenvalue $\\lambda_j$. The state of the system at time step $k$ can be approximated as a linear combination of these modes: $\\mathbf{x}_k \\approx \\sum_{j=1}^r c_j \\phi_j (\\lambda_j)^k$.\n\nFinally, to connect the DMD results back to the underlying continuous-time physics, we convert the discrete-time DMD eigenvalues $\\lambda_j$ into continuous-time eigenvalues $\\omega_j$. Since the operator $A$ represents evolution over a a time step $\\Delta t$, the relationship is $\\lambda_j = \\exp(\\omega_j \\Delta t)$. We can thus recover the continuous-time growth/decay rates and frequencies:\n$$\n\\omega_j = \\frac{\\ln(\\lambda_j)}{\\Delta t}\n$$\nThe unit of $\\omega_j$ is $\\mathrm{s}^{-1}$. For the heat equation, the true eigenvalues are real and negative. Therefore, the computed $\\operatorname{Re}(\\omega_j)$ corresponds to a decay rate, representing how quickly the thermal energy in the mode pattern $\\phi_j$ dissipates. The imaginary part $\\operatorname{Im}(\\omega_j)$ represents an oscillatory frequency, which should be close to zero for this problem of pure diffusion.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for Dynamic Mode Decomposition.\n    \"\"\"\n    test_cases = [\n        {\n            'L': 1.0, 'n': 32, 'alpha': 1.0e-4, 'dt': 0.05, 'm': 50,\n            'k_indices': [3], 'coeffs': [1.0], 'r': 1,\n            'check': 'relative_error', 'threshold': 1e-6\n        },\n        {\n            'L': 1.0, 'n': 32, 'alpha': 1.0e-4, 'dt': 0.05, 'm': 60,\n            'k_indices': [2, 7], 'coeffs': [1.0, 0.7], 'r': 2,\n            'check': 'max_relative_error', 'threshold': 1e-5\n        },\n        {\n            'L': 1.0, 'n': 32, 'alpha': 1.0e-9, 'dt': 0.1, 'm': 40,\n            'k_indices': [5], 'coeffs': [1.0], 'r': 1,\n            'check': 'absolute_magnitude', 'threshold': 5.0e-7\n        }\n    ]\n\n    results = [run_dmd_test(**params) for params in test_cases]\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_dmd_test(L, n, alpha, dt, m, k_indices, coeffs, r, check, threshold):\n    \"\"\"\n    Performs a single DMD test case and verifies the result.\n\n    Args:\n        L (float): Length of the rod (m).\n        n (int): Number of interior spatial grid points.\n        alpha (float): Thermal diffusivity (m^2/s).\n        dt (float): Time step size (s).\n        m (int): Number of time steps to generate snapshots.\n        k_indices (list[int]): Indices of the analytical eigenmodes for the initial condition.\n        coeffs (list[float]): Coefficients for the linear combination of eigenmodes.\n        r (int): Rank for DMD truncation.\n        check (str): The type of check to perform ('relative_error', 'max_relative_error', 'absolute_magnitude').\n        threshold (float): The threshold for the check.\n\n    Returns:\n        bool: True if the test passes, False otherwise.\n    \"\"\"\n    \n    # 1. Construct the 1D discrete Laplacian matrix L\n    dx = L / (n + 1.0)\n    main_diag = -2.0 * np.ones(n)\n    off_diag = np.ones(n - 1)\n    L_matrix = (np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)) / (dx**2)\n\n    # 2. Generate the initial condition x0 from analytical eigenvectors\n    x0 = np.zeros(n, dtype=np.float64)\n    grid_points = np.arange(1, n + 1)\n    for k, c in zip(k_indices, coeffs):\n        eigenvector = np.sin(k * np.pi * grid_points / (n + 1.0))\n        x0 += c * eigenvector\n\n    # 3. Generate snapshot data by evolving the system\n    # The exact time-dt propagator is A = exp(alpha * dt * L)\n    A_op = expm(alpha * dt * L_matrix)\n    \n    snapshots = [x0]\n    current_x = x0\n    for _ in range(m):\n        current_x = A_op @ current_x\n        snapshots.append(current_x)\n    \n    # Form data matrices X and Y\n    # X = [x_1, ..., x_{m-1}], Y = [x_2, ..., x_m]\n    X = np.array(snapshots[1:m]).T\n    Y = np.array(snapshots[2:m+1]).T\n\n    # 4. Perform Dynamic Mode Decomposition\n    U, s, Vh = np.linalg.svd(X, full_matrices=False)\n\n    # Truncate to rank r\n    U_r = U[:, :r]\n    s_r = s[:r]\n    Vh_r = Vh[:r, :]\n    V_r = Vh_r.T\n    \n    # 5. Compute the reduced operator A_tilde and its eigendecomposition\n    Sigma_r_inv = np.diag(1.0 / s_r)\n    A_tilde = U_r.T @ Y @ V_r @ Sigma_r_inv\n    \n    dmd_eigvals, _ = np.linalg.eig(A_tilde)\n\n    # 6. Compute continuous-time growth rates (omega)\n    omegas = np.log(dmd_eigvals) / dt\n\n    # 7. Verification against theoretical values\n    theoretical_omegas = []\n    for k in k_indices:\n        mu_k = -2.0 / (dx**2) * (1.0 - np.cos(k * np.pi / (n + 1.0)))\n        theoretical_omegas.append(alpha * mu_k)\n    \n    # For diffusion, omegas should be real. We take the real part for comparison.\n    computed_omegas_real = np.sort(omegas.real)\n    theoretical_omegas_sorted = np.sort(np.array(theoretical_omegas))\n\n    if check == 'relative_error':\n        # Used for Test Case 1\n        rel_error = np.abs((computed_omegas_real[0] - theoretical_omegas_sorted[0]) / theoretical_omegas_sorted[0])\n        return rel_error  threshold\n    \n    elif check == 'max_relative_error':\n        # Used for Test Case 2\n        rel_errors = np.abs((computed_omegas_real - theoretical_omegas_sorted) / theoretical_omegas_sorted)\n        return np.max(rel_errors)  threshold\n    \n    elif check == 'absolute_magnitude':\n        # Used for Test Case 3\n        # The growth rate should be close to the theoretical value. Test checks its magnitude.\n        return np.abs(omegas[0])  threshold\n        \n    return False\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "Before applying DMD to experimental or numerical data, a critical step is to design the data acquisition strategy. This practice focuses on selecting an appropriate sampling interval, $\\Delta t$, which involves a fundamental trade-off between resolving high-frequency oscillations and capturing slow decay rates in the presence of measurement noise. By working through the constraints imposed by the Nyquist criterion and signal-to-noise considerations, you will develop the practical skill of choosing a $\\Delta t$ that ensures the resulting DMD analysis is both accurate and meaningful. ",
            "id": "3949633",
            "problem": "A thermally driven open-cavity flow exhibits a dominant oscillatory thermal mode that you plan to analyze with Dynamic Mode Decomposition (DMD). Assume the scalar temperature fluctuation at a representative point follows linear dynamics with a single dominant mode characterized by a continuous-time eigenvalue $s = \\sigma + i \\omega$, where $\\sigma \\in \\mathbb{R}$ is the damping rate and $\\omega = 2 \\pi f$ with oscillation frequency $f \\in \\mathbb{R}^{+}$. The time-discrete DMD eigenvalue is related to the continuous-time eigenvalue by $\\lambda = \\exp(s \\Delta t)$, where $\\Delta t$ is the snapshot interval.\n\nYou are given the following design information for a planned acquisition:\n\n- Dominant oscillation frequency $f = 80\\,\\mathrm{Hz}$.\n- Expected exponential decay rate magnitude $\\gamma = -\\sigma = 50\\,\\mathrm{s}^{-1}$ (i.e., $\\sigma = -50\\,\\mathrm{s}^{-1}$).\n- The measurement noise has a relative standard deviation $\\nu = 0.005$ (dimensionless) with respect to the instantaneous signal amplitude, and you require that the per-snapshot relative amplitude change due to damping be at least $k \\nu$ with $k = 5$ to exceed noise by a factor of $5$.\n\nUsing only fundamental principles, namely:\n- the Nyquist–Shannon sampling criterion for resolving an oscillation of frequency $f$ without aliasing, and\n- the exponential relaxation of linear thermal fluctuations and its mapping to the discrete-time DMD eigenvalue magnitude,\n\ndetermine the largest snapshot interval $\\Delta t$ that simultaneously avoids aliasing and ensures resolvable damping per snapshot under the stated noise criterion.\n\nExpress the final time step in milliseconds and round your answer to three significant figures.",
            "solution": "We begin from two fundamental bases:\n\n1. Nyquist–Shannon sampling criterion: To avoid aliasing for a band-limited signal with highest frequency $f$, the sampling frequency $f_{s}$ must satisfy $f_{s} \\geq 2 f$. With $f_{s} = 1/\\Delta t$, this yields the constraint\n$$\n\\Delta t \\leq \\frac{1}{2 f}.\n$$\n\n2. Linear exponential relaxation and its discrete mapping in Dynamic Mode Decomposition (DMD): For a linear mode with continuous-time eigenvalue $s = \\sigma + i \\omega$, the discrete-time eigenvalue over a snapshot interval $\\Delta t$ is\n$$\n\\lambda = \\exp(s \\Delta t) = \\exp(\\sigma \\Delta t) \\exp(i \\omega \\Delta t).\n$$\nThe magnitude of $\\lambda$ is $|\\lambda| = \\exp(\\sigma \\Delta t)$. For a decaying mode, $\\sigma = -\\gamma  0$ with $\\gamma  0$, so $|\\lambda| = \\exp(-\\gamma \\Delta t)  1$. The per-snapshot relative amplitude change due to damping (i.e., the reduction factor from one snapshot to the next) is\n$$\n1 - |\\lambda| = 1 - \\exp(-\\gamma \\Delta t).\n$$\nTo ensure the damping is resolvable over measurement noise, the change should exceed a prescribed threshold related to the relative noise standard deviation $\\nu$. Adopting a $k$-sigma criterion for a conservative separation from noise, we impose\n$$\n1 - \\exp(-\\gamma \\Delta t) \\geq k \\nu,\n$$\nwith $k = 5$ and $\\nu = 0.005$. Solving this inequality for $\\Delta t$ yields a lower bound:\n$$\n\\exp(-\\gamma \\Delta t) \\leq 1 - k \\nu\n\\;\\;\\Rightarrow\\;\\;\n-\\gamma \\Delta t \\leq \\ln(1 - k \\nu)\n\\;\\;\\Rightarrow\\;\\;\n\\Delta t \\geq -\\frac{1}{\\gamma} \\ln(1 - k \\nu).\n$$\n\nTherefore, the snapshot interval $\\Delta t$ must lie in the interval\n$$\n-\\frac{1}{\\gamma} \\ln(1 - k \\nu) \\;\\leq\\; \\Delta t \\;\\leq\\; \\frac{1}{2 f}.\n$$\nTo minimize data volume while meeting both constraints, we select the largest feasible $\\Delta t$, namely\n$$\n\\Delta t^{\\star} = \\frac{1}{2 f},\n$$\nprovided that $\\frac{1}{2 f} \\geq -\\frac{1}{\\gamma} \\ln(1 - k \\nu)$.\n\nWe now evaluate the bounds with the given parameters:\n- Frequency: $f = 80\\,\\mathrm{Hz}$ gives\n$$\n\\Delta t_{\\text{Nyquist}} = \\frac{1}{2 f} = \\frac{1}{2 \\times 80} = \\frac{1}{160} = 0.00625\\,\\mathrm{s}.\n$$\n- Damping resolvability lower bound with $\\gamma = 50\\,\\mathrm{s}^{-1}$, $k = 5$, and $\\nu = 0.005$:\n$$\n\\Delta t_{\\min} = -\\frac{1}{\\gamma} \\ln(1 - k \\nu)\n= -\\frac{1}{50} \\ln(1 - 5 \\times 0.005)\n= -\\frac{1}{50} \\ln(1 - 0.025)\n= -\\frac{1}{50} \\ln(0.975).\n$$\nCompute the logarithm symbolically then evaluate:\n$$\n\\ln(0.975) \\approx -0.025317,\n\\quad\n\\Rightarrow\n\\Delta t_{\\min} \\approx -\\frac{1}{50} \\times (-0.025317)\n= \\frac{0.025317}{50}\n\\approx 0.00050634\\,\\mathrm{s}.\n$$\n\nFeasibility check:\n$$\n\\Delta t_{\\text{Nyquist}} = 0.00625\\,\\mathrm{s}\n\\quad\\text{and}\\quad\n\\Delta t_{\\min} \\approx 0.00050634\\,\\mathrm{s},\n$$\nso $\\Delta t_{\\text{Nyquist}} \\geq \\Delta t_{\\min}$ and the feasible interval is nonempty. The largest admissible interval under both criteria is\n$$\n\\Delta t^{\\star} = \\Delta t_{\\text{Nyquist}} = 0.00625\\,\\mathrm{s}.\n$$\n\nConvert to milliseconds:\n$$\n\\Delta t^{\\star} = 0.00625\\,\\mathrm{s} = 6.25\\,\\mathrm{ms}.\n$$\n\nRounded to three significant figures, the appropriate snapshot interval is $6.25\\,\\mathrm{ms}$.",
            "answer": "$$\\boxed{6.25}$$"
        },
        {
            "introduction": "When the sampling rate is too low, it violates the Nyquist-Shannon theorem, leading to a phenomenon known as aliasing where high frequencies masquerade as lower ones. This practice tackles this common pitfall head-on by demonstrating how DMD's reliance on the complex logarithm can produce erroneous frequencies from undersampled data. You will implement a powerful unaliasing technique that uses measurements from two different sampling rates to resolve this ambiguity and recover the true frequency of a thermal mode. ",
            "id": "3949623",
            "problem": "A single coherent thermal mode in a convective heat transfer field can be locally modeled as a complex exponential response of the form $T_{\\text{mode}}(t) = \\Re\\{a \\, e^{\\omega t}\\}$, where $a \\in \\mathbb{C}$, $t$ is time in seconds, and the complex angular frequency is $\\omega = \\sigma + i \\, 2 \\pi f$, with $\\sigma \\in \\mathbb{R}$ denoting the real-valued growth or decay rate in $\\text{s}^{-1}$ and $f \\in \\mathbb{R}_{\\ge 0}$ the physical oscillation frequency in hertz. Dynamic Mode Decomposition (DMD) is a data-driven spectral decomposition that approximates the underlying linear operator from snapshots sampled uniformly in time with sampling interval $\\Delta t$ in seconds. For a single mode, the discrete-time eigenvalue is $$\\lambda = e^{\\omega \\Delta t}.$$ The principal complex logarithm, defined with argument $\\operatorname{Arg}(\\lambda) \\in (-\\pi, \\pi]$, yields the DMD estimate $\\hat{\\omega} = \\frac{1}{\\Delta t} \\log(\\lambda)$, which implies that the imaginary part satisfies $\\Im(\\hat{\\omega}) = \\frac{\\theta}{\\Delta t}$, where $\\theta = \\operatorname{Arg}(\\lambda) \\in (-\\pi, \\pi]$. This enforces a frequency window of $(-\\pi/\\Delta t, \\pi/\\Delta t]$ for $\\Im(\\hat{\\omega})$, i.e., a Nyquist limitation for the inferred angular frequency. Consequently, inadequate sampling interval $\\Delta t$ aliases the true imaginary part $\\Im(\\omega) = 2 \\pi f$ into the principal branch by adding or subtracting integer multiples of $2 \\pi$, which maps the true frequency $f$ to an erroneous observed value $\\hat{f} = \\Im(\\hat{\\omega})/(2 \\pi)$.\n\nYour task is to formalize and implement the aliasing mechanism and then unalias the frequency using a principled strategy based on two different sampling intervals. The program must:\n\n- For each test case, treat the thermal mode as exactly single-frequency with given true $f$ in hertz and growth rate $\\sigma$ in $\\text{s}^{-1}$. Construct the corresponding continuous-time eigenvalue mapping and the discrete-time eigenvalues for two sampling intervals $\\Delta t_a$ and $\\Delta t_b$ in seconds.\n- Compute the aliased observations induced by the principal branch: for each $\\Delta t_j$, form $\\lambda_j = \\exp((\\sigma + i 2 \\pi f) \\Delta t_j)$, compute $\\theta_j = \\operatorname{Arg}(\\lambda_j)$ in radians, and then compute the observed frequency $\\hat{f}_j = \\theta_j/(2 \\pi \\Delta t_j)$ in hertz.\n- Show how inadequate $\\Delta t$ maps the true $f$ to $\\Im(\\hat{\\omega})$ by the modular relation $2 \\pi f = \\frac{\\theta_j}{\\Delta t_j} + \\frac{2 \\pi n_j}{\\Delta t_j}, \\quad n_j \\in \\mathbb{Z},$ which yields $f = \\frac{\\theta_j + 2 \\pi n_j}{2 \\pi \\Delta t_j}.$\n- Implement a correction strategy that uses two sampling intervals to resolve the integers $n_a$ and $n_b$. Given a known upper bound $f_{\\max}$ in hertz, search integer pairs $(n_a, n_b)$ such that the two expressions for $f$ from $\\Delta t_a$ and $\\Delta t_b$ agree within a small tolerance, and $f \\in [0, f_{\\max}]$. Report the recovered frequency $\\tilde{f}$ as the average of the two consistent values. Angles must be treated in radians. The search tolerance should be $10^{-9}$ in hertz, and you should search $n_j$ over the range $\\{-N_j, \\ldots, N_j\\}$ with $N_j = \\lceil f_{\\max} \\Delta t_j \\rceil + 2$.\n- The final reported quantity for each test case is only the corrected unaliased frequency $\\tilde{f}$ in hertz. Internally, your program must compute the aliased $\\hat{f}_j$ values to validate the mapping, but the final output should only contain $\\tilde{f}$.\n\nUse the following test suite. Each tuple is $(f, \\sigma, \\Delta t_a, \\Delta t_b, f_{\\max})$:\n\n- Case $1$ (no aliasing on either sampling interval): $(20.0, -1.0, 0.01, 0.012, 100.0)$ with $f$ in hertz, $\\sigma$ in $\\text{s}^{-1}$, and $\\Delta t$ in seconds.\n- Case $2$ (aliasing on both sampling intervals): $(120.0, -5.0, 0.01, 0.008, 200.0)$.\n- Case $3$ (boundary at Nyquist on $\\Delta t_a$): $(50.0, 0.0, 0.01, 0.0092, 100.0)$.\n- Case $4$ (significant aliasing with mild growth): $(300.0, 2.0, 0.004, 0.0033, 500.0)$.\n\nPhysical units and numerical conventions:\n\n- All frequencies $f$, $\\hat{f}_j$, and $\\tilde{f}$ must be expressed in hertz and rounded to six decimal places.\n- All time intervals $\\Delta t$ are in seconds.\n- All angles are in radians.\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered by the cases above, e.g., $[r_1,r_2,r_3,r_4]$, where each $r_k$ is the corrected unaliased frequency $\\tilde{f}$ in hertz rounded to six decimal places. The output must be a single line with no additional text.",
            "solution": "The problem is valid as it is scientifically grounded in the principles of linear systems and signal processing (specifically, the discrete-time representation of continuous-time systems and the Nyquist-Shannon sampling theorem), well-posed with a clear objective and sufficient information, and objective in its formulation.\n\nThe solution proceeds by first formalizing the aliasing phenomenon inherent in Dynamic Mode Decomposition (DMD) and then implementing a systematic search algorithm to reverse the aliasing and recover the true frequency of a thermal mode.\n\nA single thermal mode is modeled by the complex exponential response $T_{\\text{mode}}(t) = \\Re\\{a \\, e^{\\omega t}\\}$, where its dynamics are governed by the continuous-time eigenvalue $\\omega = \\sigma + i \\, 2 \\pi f$. Here, $\\sigma$ is the growth/decay rate in $\\text{s}^{-1}$ and $f \\ge 0$ is the oscillation frequency in hertz.\n\nWhen this continuous-time process is sampled with a uniform time interval $\\Delta t$, the resulting discrete-time system is described by the discrete-time eigenvalue $\\lambda$, which relates to $\\omega$ by the mapping:\n$$ \\lambda = e^{\\omega \\Delta t} = e^{(\\sigma + i 2 \\pi f) \\Delta t} = e^{\\sigma \\Delta t} e^{i 2 \\pi f \\Delta t} $$\nDMD approximates this eigenvalue $\\lambda$ from data. To recover the continuous-time dynamics, one must compute the complex logarithm of $\\lambda$:\n$$ \\hat{\\omega} = \\frac{1}{\\Delta t} \\log(\\lambda) $$\nThe standard complex logarithm function, $\\log(z) = \\ln|z| + i \\operatorname{Arg}(z)$, uses the principal argument $\\operatorname{Arg}(z) \\in (-\\pi, \\pi]$. Applying this to our eigenvalue $\\lambda$:\n$$\n\\log(\\lambda) = \\ln|e^{\\sigma \\Delta t} e^{i 2 \\pi f \\Delta t}| + i \\operatorname{Arg}(e^{\\sigma \\Delta t} e^{i 2 \\pi f \\Delta t})\n= \\ln(e^{\\sigma \\Delta t}) + i \\operatorname{Arg}(e^{i 2 \\pi f \\Delta t})\n= \\sigma \\Delta t + i \\theta\n$$\nwhere $\\theta = \\operatorname{Arg}(e^{i 2 \\pi f \\Delta t})$ is the true phase $2 \\pi f \\Delta t$ wrapped into the interval $(-\\pi, \\pi]$.\nThe recovered continuous-time eigenvalue is therefore:\n$$ \\hat{\\omega} = \\frac{1}{\\Delta t}(\\sigma \\Delta t + i \\theta) = \\sigma + i \\frac{\\theta}{\\Delta t} $$\nWhile the real part $\\Re(\\hat{\\omega}) = \\sigma$ is correctly recovered, the imaginary part is aliased. The true phase $\\phi_{\\text{true}} = 2 \\pi f \\Delta t$ and the observed phase $\\theta$ are related by an unknown integer multiple of $2\\pi$:\n$$ 2 \\pi f \\Delta t = \\theta + 2 \\pi n, \\quad n \\in \\mathbb{Z} $$\nThis integer $n$ accounts for the number of full $2 \\pi$ rotations \"lost\" when mapping the true phase to the principal branch. Dividing by $2 \\pi \\Delta t$ gives the relationship between the true frequency $f$ and the observed quantities:\n$$ f = \\frac{\\theta + 2 \\pi n}{2 \\pi \\Delta t} $$\nThe observed frequency $\\hat{f}$, corresponding to $n=0$, is $\\hat{f} = \\frac{\\theta}{2 \\pi \\Delta t}$. This is the aliased value.\n\nTo find the true frequency $f$, we must determine the unknown integer $n$. The proposed strategy uses two different sampling intervals, $\\Delta t_a$ and $\\Delta t_b$. For each sampling interval, we can compute the discrete eigenvalue $\\lambda_j$ and its principal argument $\\theta_j$ (for $j \\in \\{a, b\\}$). This yields a system of two equations with two unknown integers, $n_a$ and $n_b$:\n$$ f = \\frac{\\theta_a + 2 \\pi n_a}{2 \\pi \\Delta t_a} $$\n$$ f = \\frac{\\theta_b + 2 \\pi n_b}{2 \\pi \\Delta t_b} $$\nThe core of the unaliasing algorithm is to find an integer pair $(n_a, n_b)$ that makes these two expressions for $f$ consistent. We search for a pair such that the computed frequencies, which we denote $f_a(n_a)$ and $f_b(n_b)$, are equal within a small tolerance $\\epsilon = 10^{-9}$ Hz:\n$$ |f_a(n_a) - f_b(n_b)|  \\epsilon $$\nAdditionally, the solution must be physically meaningful, constrained by an upper bound $f_{\\max}$, so we require $0 \\le f \\le f_{\\max}$.\n\nThe search for $n_j$ is conducted over a finite range $\\{-N_j, \\ldots, N_j\\}$, where $N_j = \\lceil f_{\\max} \\Delta t_j \\rceil + 2$. This range is constructed to be sufficiently large to contain the true integer wrap-around count for any frequency up to $f_{\\max}$.\n\nThe algorithm proceeds as follows for each test case:\n1. Given $f$, $\\sigma$, $\\Delta t_a$, $\\Delta t_b$, and $f_{\\max}$.\n2. Calculate the true continuous-time eigenvalue $\\omega = \\sigma + i 2\\pi f$.\n3. For each sampling time $\\Delta t_j$ ($j=a,b$):\n   a. Compute the discrete-time eigenvalue $\\lambda_j = e^{\\omega \\Delta t_j}$.\n   b. Extract the principal argument $\\theta_j = \\operatorname{Arg}(\\lambda_j)$.\n4. Determine the search ranges for $n_a$ and $n_b$ using $N_j = \\lceil f_{\\max} \\Delta t_j \\rceil + 2$.\n5. Iterate through all integer pairs $(n_a, n_b)$ within these search ranges. For each pair:\n   a. Compute candidate frequencies $f_{\\text{cand}, a} = (\\theta_a + 2\\pi n_a)/(2\\pi \\Delta t_a)$ and $f_{\\text{cand}, b} = (\\theta_b + 2\\pi n_b)/(2\\pi \\Delta t_b)$.\n   b. Check if the candidates satisfy the conditions:\n      i. $|f_{\\text{cand}, a} - f_{\\text{cand}, b}|  10^{-9}$\n      ii. $0 \\le f_{\\text{cand}, a} \\le f_{\\max}$\n      iii. $0 \\le f_{\\text{cand}, b} \\le f_{\\max}$\n6. If a pair satisfies all conditions, the unaliased frequency $\\tilde{f}$ is found. It is calculated as the average of the two consistent candidates: $\\tilde{f} = (f_{\\text{cand}, a} + f_{\\text{cand}, b}) / 2$. This value is then rounded to six decimal places for the final result.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the unaliased frequency of a thermal mode given two\n    different sampling intervals.\n    \"\"\"\n    # Test cases: Each tuple is (f, sigma, dt_a, dt_b, f_max)\n    test_cases = [\n        (20.0, -1.0, 0.01, 0.012, 100.0),   # Case 1\n        (120.0, -5.0, 0.01, 0.008, 200.0),  # Case 2\n        (50.0, 0.0, 0.01, 0.0092, 100.0),   # Case 3\n        (300.0, 2.0, 0.004, 0.0033, 500.0)   # Case 4\n    ]\n\n    results = []\n    \n    # Define constants\n    pi = np.pi\n    two_pi = 2 * pi\n    tolerance = 1e-9\n\n    for case in test_cases:\n        f_true, sigma, dt_a, dt_b, f_max = case\n        \n        # 1. Calculate the continuous-time eigenvalue omega\n        omega = sigma + 1j * two_pi * f_true\n\n        # 2. For each sampling time, compute the discrete eigenvalue lambda\n        #    and its principal argument theta\n        lambda_a = np.exp(omega * dt_a)\n        theta_a = np.angle(lambda_a)\n\n        lambda_b = np.exp(omega * dt_b)\n        theta_b = np.angle(lambda_b)\n\n        # 3. Determine the search ranges for integers n_a and n_b\n        # The range is [-N, N] where N = ceil(f_max * dt) + 2\n        N_a = int(np.ceil(f_max * dt_a)) + 2\n        N_b = int(np.ceil(f_max * dt_b)) + 2\n        \n        found_solution = False\n        f_tilde = np.nan\n\n        # 4. Iterate through integer pairs (n_a, n_b) to find a consistent solution\n        for n_a in range(-N_a, N_a + 1):\n            for n_b in range(-N_b, N_b + 1):\n                # Calculate candidate frequencies\n                f_cand_a = (theta_a + two_pi * n_a) / (two_pi * dt_a)\n                f_cand_b = (theta_b + two_pi * n_b) / (two_pi * dt_b)\n\n                # Check if candidates meet the criteria\n                # a) Frequencies are close to each other\n                # b) Frequencies are within the physical bounds [0, f_max]\n                if abs(f_cand_a - f_cand_b)  tolerance:\n                    if 0.0 = f_cand_a = f_max and 0.0 = f_cand_b = f_max:\n                        # 5. A valid solution is found. Average the results.\n                        f_tilde = (f_cand_a + f_cand_b) / 2.0\n                        found_solution = True\n                        break\n            if found_solution:\n                break\n        \n        # 6. Round the final result to 6 decimal places and append\n        results.append(f\"{round(f_tilde, 6):.6f}\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        }
    ]
}