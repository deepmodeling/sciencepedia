{
    "hands_on_practices": [
        {
            "introduction": "理论知识是根基，但只有通过实践才能真正掌握动态模式分解 (DMD) 的精髓。本节的第一个练习将指导您从零开始构建一个核心的 DMD 算法。我们将以一维热传导这一经典物理问题为例，利用 DMD 从数值模拟生成的快照数据中提取系统的动态特征，并将其与已知的理论解进行对比，从而验证算法的有效性。这项实践不仅能加深您对 DMD 算法内部机理的理解，还能让您亲身体验数据驱动方法在识别潜在物理规律方面的强大能力 。",
            "id": "3949672",
            "problem": "考虑一根长度为 $L$ 的一维均匀杆，处于纯热传导状态，两端均为固定温度的狄利克雷边界条件。温度场 $T(x,t)$ 满足热方程 $\\frac{\\partial T}{\\partial t}=\\alpha \\frac{\\partial^2 T}{\\partial x^2}$，其中 $\\alpha$ 是热扩散系数。将杆离散化为 $n$ 个内部点，均匀间距为 $\\Delta x=L/(n+1)$，并使用二阶中心有限差分来近似空间拉普拉斯算子。这将产生一个 $\\mathbb{R}^n$ 上的线性常微分方程，形式为 $\\frac{d \\mathbf{x}}{dt}=\\alpha L \\mathbf{x}$，其中 $L \\in \\mathbb{R}^{n \\times n}$ 是带狄利克雷边界条件的离散拉普拉斯矩阵。精确的时间-$\\Delta t$ 演化算子是 $A=\\exp(\\alpha \\Delta t L)$，其中 $\\exp(\\cdot)$ 表示矩阵指数。\n\n您将通过在算子 $A$ 下将初始状态 $\\mathbf{x}_0$ 演化 $m$ 个时间步（步长为 $\\Delta t$ 秒，生成 $m+1$ 个快照）来构成快照矩阵 $X \\in \\mathbb{R}^{n \\times (m-1)}$ 和 $Y \\in \\mathbb{R}^{n \\times (m-1)}$，使得 $X$ 的列为 $\\{\\mathbf{x}_1,\\ldots,\\mathbf{x}_{m-1}\\}$，$Y$ 的列为 $\\{\\mathbf{x}_2,\\ldots,\\mathbf{x}_m\\}$，且 $\\mathbf{x}_{k+1}=A\\mathbf{x}_k$。动态模态分解 (DMD) 旨在寻找一个低秩线性算子，该算子能将快照从 $X$ 推进到 $Y$，并将动力学分解为具有相关增长率的相干模态。\n\n从 $X$ 的奇异值分解出发，利用摩尔-彭若斯伪逆的定义，推导出在主左奇异向量张成的子空间中的降维算子以及相应的DMD模态构建方法。通过与热传导的物理学相结合来解释每一步，包括离散拉普拉斯算子的作用以及对单位为 $\\mathrm{s}^{-1}$ 的连续时间增长率的解释。\n\n实现一个程序，该程序能：\n- 为具有狄利克雷边界条件的一维杆构建离散拉普拉斯算子 $L$。\n- 通过使用精确算子 $A=\\exp(\\alpha \\Delta t L)$ 演化初始条件来生成合成快照数据。\n- 通过计算 $X$ 的奇异值分解、构建降维算子、计算其特征分解，然后计算DMD模态来执行动态模态分解。\n- 使用复对数除以 $\\Delta t$ 将离散时间特征值转换为连续时间增长率，并以 $\\mathrm{s}^{-1}$ 为单位解释这些增长率。\n\n对于数值单位，使用米（m）作为 $L$ 的单位，秒（s）作为 $\\Delta t$ 的单位。温度单位为开尔文，但由于算子是线性的，数值将是特征向量的无量纲缩放；连续时间增长率必须以 $\\mathrm{s}^{-1}$ 表示。\n\n您必须根据以下测试套件评估您的实现。在每种情况下，从离散拉普拉斯算子的精确特征向量构建指定的初始条件，以使理论上的连续时间增长率是已知的。使用狄利克雷边界的离散拉普拉斯算子解析特征值，其表达式为 $\\mu_k=-\\frac{2}{\\Delta x^2}\\left(1-\\cos\\left(\\frac{k\\pi}{n+1}\\right)\\right)$（模态指数 $k\\in\\{1,\\ldots,n\\}$），以及对应的特征向量 $u^{(k)}_i=\\sin\\left(\\frac{k\\pi i}{n+1}\\right)$（网格指数 $i\\in\\{1,\\ldots,n\\}$）。\n\n- 测试用例 1 (理想路径，秩-1动力学)：\n  - 参数：$L=1.0$ $\\mathrm{m}$，$n=32$，$\\alpha=1.0\\times 10^{-4}$ $\\mathrm{m^2/s}$，$\\Delta t=0.05$ $\\mathrm{s}$，演化 $m=50$ 个时间步，初始条件是指数为 $k=3$ 的单个特征模态，DMD 秩 $r=1$。\n  - 预期：主导连续时间增长率 $\\omega$ 应与理论值 $\\alpha \\mu_{k}$ 匹配，相对误差小于 $10^{-6}$。\n\n- 测试用例 2 (多模态，秩-2动力学)：\n  - 参数：$L=1.0$ $\\mathrm{m}$，$n=32$，$\\alpha=1.0\\times 10^{-4}$ $\\mathrm{m^2/s}$，$\\Delta t=0.05$ $\\mathrm{s}$，演化 $m=60$ 个时间步，初始条件是指数为 $k_1=2$ 和 $k_2=7$ 的组合 $1.0\\cdot u^{(k_1)}+0.7\\cdot u^{(k_2)}$，DMD 秩 $r=2$。\n  - 预期：在将每个恢复的增长率与最接近的理论值配对后，两个主导连续时间增长率应与 $\\{\\alpha \\mu_{k_1},\\alpha \\mu_{k_2}\\}$ 匹配，最大相对误差小于 $10^{-5}$。\n\n- 测试用例 3 (边界情况，近稳态动力学)：\n  - 参数：$L=1.0$ $\\mathrm{m}$，$n=32$，$\\alpha=1.0\\times 10^{-9}$ $\\mathrm{m^2/s}$，$\\Delta t=0.1$ $\\mathrm{s}$，演化 $m=40$ 个时间步，初始条件是指数为 $k=5$ 的单个特征模态，DMD 秩 $r=1$。\n  - 预期：主导连续时间增长率的幅度应小于 $5.0\\times 10^{-7}$ $\\mathrm{s^{-1}}$。\n\n您的程序必须为每个测试用例计算DMD特征值和模态，将离散时间特征值转换为单位为 $\\mathrm{s}^{-1}$ 的连续时间增长率，然后评估所述标准，为每个测试用例生成一个布尔值，指示标准是否满足。您的程序应生成一行输出，其中包含一个方括号括起来的逗号分隔列表的结果（例如，$[result_1,result_2,result_3]$），其中每个 $result_i$ 为 $True$ 或 $False$。",
            "solution": "该问题是有效的，因为它在科学上基于热物理学和数值分析的原理，问题本身是适定的，具有明确的目标和可验证的测试用例，并且没有任何矛盾或歧义。\n\n在此，我们推导应用于热传导的动态模态分解 (DMD) 的公式，并提供其实现。\n\n物理过程是长度为 $L$ 的一维杆中的热传导，由热方程控制：\n$$\n\\frac{\\partial T(x,t)}{\\partial t} = \\alpha \\frac{\\partial^2 T(x,t)}{\\partial x^2}\n$$\n其中 $T(x,t)$ 是温度场，$\\alpha$ 是热扩散系数。杆具有固定温度的狄利克雷边界条件，$T(0,t) = T_0$ 和 $T(L,t) = T_L$。通过考虑相对于稳态线性分布的温度，我们可以设置齐次边界条件，$T(0,t) = 0$ 和 $T(L,t) = 0$。\n\n将空间域离散化为 $n$ 个内部点，间距为 $\\Delta x = L/(n+1)$，我们可以用离散点 $x_i = i \\Delta x$（$i \\in \\{1, \\ldots, n\\}$）来近似空间变量 $x$。温度场变成一个向量 $\\mathbf{x}(t) \\in \\mathbb{R}^n$，其中 $\\mathbf{x}_i(t) \\approx T(x_i, t)$。点 $x_i$ 处的空间二阶导数 $\\frac{\\partial^2 T}{\\partial x^2}$ 使用二阶中心有限差分格式来近似：\n$$\n\\frac{\\partial^2 T}{\\partial x^2}\\bigg|_{x_i} \\approx \\frac{T(x_{i+1}, t) - 2T(x_i, t) + T(x_{i-1}, t)}{(\\Delta x)^2}\n$$\n这种离散化将偏微分方程转化为一个耦合线性常微分方程组：\n$$\n\\frac{d\\mathbf{x}}{dt} = \\alpha L \\mathbf{x}\n$$\n这里，$L \\in \\mathbb{R}^{n \\times n}$ 是离散拉普拉斯矩阵。对于齐次狄利克雷边界条件，$L$ 是一个对称三对角矩阵，其主对角线上的元素为 $-2/(\\Delta x)^2$，第一上对角线和第一下对角线上的元素为 $1/(\\Delta x)^2$。\n\n该线性常微分方程组的精确解由矩阵指数给出：\n$$\n\\mathbf{x}(t) = \\exp(\\alpha t L) \\mathbf{x}(0)\n$$\n动力学由连续时间算子 $\\alpha L$ 的谱特性决定。$L$ 的特征值可以解析地求得，为 $\\mu_k = -\\frac{2}{(\\Delta x)^2}\\left(1-\\cos\\left(\\frac{k\\pi}{n+1}\\right)\\right)$（$k \\in \\{1, \\ldots, n\\}$）。所有特征值都是实数且为负，这反映了热传导的耗散性质。因此，$\\alpha L$ 的特征值为 $\\omega_k = \\alpha \\mu_k$，它们是系统特征模态的连续时间衰减率。$\\omega_k$ 的值越负，表示衰减越快。对应的特征向量 $u^{(k)}$ 是表示这些模态空间形状的离散正弦函数。\n\n动态模态分解 (DMD) 是一种用于分析动力学系统的数据驱动方法。它假设从一个时间步到下一个时间步的状态演化可以由一个线性算子近似。我们采集系统状态的一系列 $m+1$ 个快照，即 $\\{\\mathbf{x}_0, \\mathbf{x}_1, \\ldots, \\mathbf{x}_m\\}$，这些快照在恒定的时间间隔 $\\Delta t$ 采集。在这个问题中，快照是由精确的传播算子 $A = \\exp(\\alpha \\Delta t L)$ 无噪声地生成的，因此 $\\mathbf{x}_{k+1} = A \\mathbf{x}_k$。\n\n我们从这些快照构建两个数据矩阵 $X$ 和 $Y$。根据规定，$X = [\\mathbf{x}_1, \\mathbf{x}_2, \\dots, \\mathbf{x}_{m-1}]$ 和 $Y = [\\mathbf{x}_2, \\mathbf{x}_3, \\dots, \\mathbf{x}_m]$。控制动力学 $ \\mathbf{x}_{k+1} = A \\mathbf{x}_k $ 意味着矩阵关系 $Y = AX$。\n\nDMD 的核心目标是找到近似 $A$ 的“最佳拟合”线性算子。在最小二乘意义下，解由 $A \\approx YX^+$ 给出，其中 $X^+$ 是 $X$ 的摩尔-彭若斯伪逆。对于状态维度 $n$ 很大的系统，计算、存储和分析完整的 $n \\times n$ 算子 $A$ 通常是难以处理的。DMD 提供了一种优雅的方法来计算 $A$ 的谱特性，而无需构建完整的矩阵。\n\n该过程利用了数据矩阵 $X$ 的奇异值分解 (SVD)。我们计算 $X$ 的“经济”SVD：\n$$\nX = U \\Sigma V^H\n$$\n其中 $U \\in \\mathbb{C}^{n \\times p}$，$\\Sigma \\in \\mathbb{R}^{p \\times p}$，$V \\in \\mathbb{C}^{(m-1) \\times p}$，以及 $p = \\min(n, m-1)$。$U$ 的列是左奇异向量（或称本征正交分解模态），它们构成了由 $X$ 中快照所张成空间的一个正交归一基。对角矩阵 $\\Sigma$ 包含奇异值，这些奇异值量化了每个模态的“能量”或重要性。对于像热传导这样的耗散系统，系统的大部分能量会迅速集中在少数低频、慢衰减的模态中。这意味着奇异值谱将迅速衰减，表明动力学可以在一个低秩子空间内被精确捕捉。因此，我们可以将SVD截断至秩 $r \\ll p$：\n$$\nX \\approx U_r \\Sigma_r V_r^H\n$$\n其中 $U_r \\in \\mathbb{C}^{n \\times r}$，$\\Sigma_r \\in \\mathbb{R}^{r \\times r}$，以及 $V_r \\in \\mathbb{C}^{(m-1) \\times r}$。$U_r$ 的列构成了最能捕捉 $X$ 中数据的 $r$ 维子空间的一个基。\n\n截断后的 $X$ 的伪逆是 $X_r^+ = V_r \\Sigma_r^{-1} U_r^H$。完整的算子 $A$ 随后被近似为 $A \\approx Y X_r^+ = Y V_r \\Sigma_r^{-1} U_r^H$。我们不计算这个大矩阵，而是将其投影到由 $U_r$ 的列张成的低维子空间上。得到的降维算子 $\\tilde{A}_{\\text{red}} \\in \\mathbb{C}^{r \\times r}$ 表示投影到POD基上的完整动力学：\n$$\n\\tilde{A}_{\\text{red}} = U_r^H A U_r \\approx U_r^H (Y V_r \\Sigma_r^{-1} U_r^H) U_r\n$$\n由于 $U_r^H U_r = I_r$（$r \\times r$ 单位矩阵），这简化为：\n$$\n\\tilde{A}_{\\text{red}} = U_r^H Y V_r \\Sigma_r^{-1}\n$$\n这是一个小的 $r \\times r$ 矩阵，处理起来计算成本低。我们通过标准的特征分解找到它的特征值和特征向量：\n$$\n\\tilde{A}_{\\text{red}} \\mathbf{w}_j = \\lambda_j \\mathbf{w}_j\n$$\n降维算子 $\\tilde{A}_{\\text{red}}$ 的特征值 $\\lambda_j$ 就是DMD特征值。它们是完整算子 $A$ 的 $r$ 个主导特征值的极好近似。\n\n完整算子 $A$ 对应的特征向量，即DMD模态 $\\phi_j$，可以被重构。一种标准方法是将投影DMD模态定义为将 $\\tilde{A}_{\\text{red}}$ 的特征向量投影回高维状态空间：\n$$\n\\phi_j = U_r \\mathbf{w}_j\n$$\n每个DMD模态 $\\phi_j$ 代表一个相干的空间模式，其幅值根据其对应的DMD特征值 $\\lambda_j$ 随时间演化。系统在时间步 $k$ 的状态可以近似为这些模态的线性组合：$\\mathbf{x}_k \\approx \\sum_{j=1}^r c_j \\phi_j (\\lambda_j)^k$。\n\n最后，为了将DMD结果与底层的连续时间物理学联系起来，我们将离散时间DMD特征值 $\\lambda_j$ 转换为连续时间特征值 $\\omega_j$。由于算子 $A$ 代表了在一个时间步 $\\Delta t$ 内的演化，它们之间的关系是 $\\lambda_j = \\exp(\\omega_j \\Delta t)$。因此，我们可以恢复连续时间的增长/衰减率和频率：\n$$\n\\omega_j = \\frac{\\ln(\\lambda_j)}{\\Delta t}\n$$\n$\\omega_j$ 的单位是 $\\mathrm{s}^{-1}$。对于热方程，真实的特征值是实数且为负。因此，计算出的 $\\operatorname{Re}(\\omega_j)$ 对应于一个衰减率，表示模态模式 $\\phi_j$ 中的热能耗散得有多快。虚部 $\\operatorname{Im}(\\omega_j)$ 代表一个振荡频率，对于这个纯扩散问题，它应该接近于零。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for Dynamic Mode Decomposition.\n    \"\"\"\n    test_cases = [\n        {\n            'L': 1.0, 'n': 32, 'alpha': 1.0e-4, 'dt': 0.05, 'm': 50,\n            'k_indices': [3], 'coeffs': [1.0], 'r': 1,\n            'check': 'relative_error', 'threshold': 1e-6\n        },\n        {\n            'L': 1.0, 'n': 32, 'alpha': 1.0e-4, 'dt': 0.05, 'm': 60,\n            'k_indices': [2, 7], 'coeffs': [1.0, 0.7], 'r': 2,\n            'check': 'max_relative_error', 'threshold': 1e-5\n        },\n        {\n            'L': 1.0, 'n': 32, 'alpha': 1.0e-9, 'dt': 0.1, 'm': 40,\n            'k_indices': [5], 'coeffs': [1.0], 'r': 1,\n            'check': 'absolute_magnitude', 'threshold': 5.0e-7\n        }\n    ]\n\n    results = [run_dmd_test(**params) for params in test_cases]\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_dmd_test(L, n, alpha, dt, m, k_indices, coeffs, r, check, threshold):\n    \"\"\"\n    Performs a single DMD test case and verifies the result.\n\n    Args:\n        L (float): Length of the rod (m).\n        n (int): Number of interior spatial grid points.\n        alpha (float): Thermal diffusivity (m^2/s).\n        dt (float): Time step size (s).\n        m (int): Number of time steps to generate snapshots.\n        k_indices (list[int]): Indices of the analytical eigenmodes for the initial condition.\n        coeffs (list[float]): Coefficients for the linear combination of eigenmodes.\n        r (int): Rank for DMD truncation.\n        check (str): The type of check to perform ('relative_error', 'max_relative_error', 'absolute_magnitude').\n        threshold (float): The threshold for the check.\n\n    Returns:\n        bool: True if the test passes, False otherwise.\n    \"\"\"\n    \n    # 1. Construct the 1D discrete Laplacian matrix L\n    dx = L / (n + 1.0)\n    main_diag = -2.0 * np.ones(n)\n    off_diag = np.ones(n - 1)\n    L_matrix = (np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)) / (dx**2)\n\n    # 2. Generate the initial condition x0 from analytical eigenvectors\n    x0 = np.zeros(n, dtype=np.float64)\n    grid_points = np.arange(1, n + 1)\n    for k, c in zip(k_indices, coeffs):\n        eigenvector = np.sin(k * np.pi * grid_points / (n + 1.0))\n        x0 += c * eigenvector\n\n    # 3. Generate snapshot data by evolving the system\n    # The exact time-dt propagator is A = exp(alpha * dt * L)\n    A_op = expm(alpha * dt * L_matrix)\n    \n    snapshots = [x0]\n    current_x = x0\n    for _ in range(m):\n        current_x = A_op @ current_x\n        snapshots.append(current_x)\n    \n    # Form data matrices X and Y\n    # X = [x_1, ..., x_{m-1}], Y = [x_2, ..., x_m]\n    X = np.array(snapshots[1:m]).T\n    Y = np.array(snapshots[2:m+1]).T\n\n    # 4. Perform Dynamic Mode Decomposition\n    U, s, Vh = np.linalg.svd(X, full_matrices=False)\n\n    # Truncate to rank r\n    U_r = U[:, :r]\n    s_r = s[:r]\n    Vh_r = Vh[:r, :]\n    V_r = Vh_r.T\n    \n    # 5. Compute the reduced operator A_tilde and its eigendecomposition\n    Sigma_r_inv = np.diag(1.0 / s_r)\n    A_tilde = U_r.T @ Y @ V_r @ Sigma_r_inv\n    \n    dmd_eigvals, _ = np.linalg.eig(A_tilde)\n\n    # 6. Compute continuous-time growth rates (omega)\n    omegas = np.log(dmd_eigvals) / dt\n\n    # 7. Verification against theoretical values\n    theoretical_omegas = []\n    for k in k_indices:\n        mu_k = -2.0 / (dx**2) * (1.0 - np.cos(k * np.pi / (n + 1.0)))\n        theoretical_omegas.append(alpha * mu_k)\n    \n    # For diffusion, omegas should be real. We take the real part for comparison.\n    computed_omegas_real = np.sort(omegas.real)\n    theoretical_omegas_sorted = np.sort(np.array(theoretical_omegas))\n\n    if check == 'relative_error':\n        # Used for Test Case 1\n        rel_error = np.abs((computed_omegas_real[0] - theoretical_omegas_sorted[0]) / theoretical_omegas_sorted[0])\n        return rel_error  threshold\n    \n    elif check == 'max_relative_error':\n        # Used for Test Case 2\n        rel_errors = np.abs((computed_omegas_real - theoretical_omegas_sorted) / theoretical_omegas_sorted)\n        return np.max(rel_errors)  threshold\n    \n    elif check == 'absolute_magnitude':\n        # Used for Test Case 3\n        # The growth rate should be close to the theoretical value. Test checks its magnitude.\n        return np.abs(omegas[0])  threshold\n        \n    return False\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "一个成功的 DMD 分析始于高质量的数据采集。在应用任何精密的算法之前，我们必须确保输入的数据能够真实反映系统的动态行为，这要求我们审慎地设计实验或数值模拟的参数。本练习将引导您解决一个在 DMD 应用中至关重要的问题：如何选择最佳的快照采样时间间隔 $\\Delta t$。您需要权衡两个基本准则：一方面，必须满足奈奎斯特-香农采样定理，以避免高频振荡产生频率混叠；另一方面，$\\Delta t$ 又要足够长，以确保模式的衰减或增长能够在测量噪声中被清晰地分辨出来。通过这项实践，您将学会如何在数据采集的实际约束与分析方法的理论要求之间找到最佳平衡点 。",
            "id": "3949633",
            "problem": "一个热驱动的开腔流动呈现出一个主导的振荡热模态，您计划使用动态模态分解（DMD）对其进行分析。假设一个代表性点的标量温度脉动遵循线性动力学，其具有单一主导模态，该模态由连续时间特征值 $s = \\sigma + i \\omega$ 表征，其中 $\\sigma \\in \\mathbb{R}$ 是阻尼率，$\\omega = 2 \\pi f$，$f \\in \\mathbb{R}^{+}$ 为振荡频率。时间离散的DMD特征值通过 $\\lambda = \\exp(s \\Delta t)$ 与连续时间特征值相关，其中 $\\Delta t$ 是快照时间间隔。\n\n为计划中的数据采集，您获得了以下设计信息：\n\n- 主导振荡频率 $f = 80\\,\\mathrm{Hz}$。\n- 预期指数衰减率大小 $\\gamma = -\\sigma = 50\\,\\mathrm{s}^{-1}$ (即 $\\sigma = -50\\,\\mathrm{s}^{-1}$)。\n- 测量噪声相对于瞬时信号幅值的相对标准差为 $\\nu = 0.005$（无量纲），并且您要求由于阻尼引起的每个快照的相对幅值变化至少为 $k \\nu$（其中 $k = 5$），以超过噪声5倍。\n\n仅使用基本原理，即：\n- 用于无混叠地解析频率为 $f$ 的振荡的奈奎斯特-香农采样准则，以及\n- 线性热脉动的指数弛豫及其到离散时间DMD特征值幅值的映射，\n\n确定在满足所述噪声准则的情况下，既能避免混叠又能确保每个快照的阻尼可分辨的最大快照时间间隔 $\\Delta t$。\n\n以毫秒表示最终的时间步长，并将您的答案四舍五入到三位有效数字。",
            "solution": "我们从两个基本依据出发：\n\n1. 奈奎斯特-香农采样准则：为避免最高频率为 $f$ 的带限信号发生混叠，采样频率 $f_{s}$ 必须满足 $f_{s} \\geq 2 f$。由于 $f_{s} = 1/\\Delta t$，这给出了约束条件\n$$\n\\Delta t \\leq \\frac{1}{2 f}.\n$$\n\n2. 线性指数弛豫及其在动态模态分解（DMD）中的离散映射：对于一个具有连续时间特征值 $s = \\sigma + i \\omega$ 的线性模态，在快照时间间隔 $\\Delta t$ 内的离散时间特征值为\n$$\n\\lambda = \\exp(s \\Delta t) = \\exp(\\sigma \\Delta t) \\exp(i \\omega \\Delta t).\n$$\n$\\lambda$ 的幅值为 $|\\lambda| = \\exp(\\sigma \\Delta t)$。对于衰减模态，$\\sigma = -\\gamma  0$ 且 $\\gamma  0$，因此 $|\\lambda| = \\exp(-\\gamma \\Delta t)  1$。由于阻尼引起的每个快照的相对幅值变化（即从一个快照到下一个快照的缩减因子）为\n$$\n1 - |\\lambda| = 1 - \\exp(-\\gamma \\Delta t).\n$$\n为确保阻尼在测量噪声中是可分辨的，该变化应超过与相对噪声标准差 $\\nu$ 相关的预设阈值。采用 $k$-sigma 准则以保守地与噪声分离，我们施加\n$$\n1 - \\exp(-\\gamma \\Delta t) \\geq k \\nu,\n$$\n其中 $k = 5$ 且 $\\nu = 0.005$。解此不等式以求得 $\\Delta t$ 的下界：\n$$\n\\exp(-\\gamma \\Delta t) \\leq 1 - k \\nu\n\\;\\;\\Rightarrow\\;\\;\n-\\gamma \\Delta t \\leq \\ln(1 - k \\nu)\n\\;\\;\\Rightarrow\\;\\;\n\\Delta t \\geq -\\frac{1}{\\gamma} \\ln(1 - k \\nu).\n$$\n\n因此，快照时间间隔 $\\Delta t$ 必须位于区间\n$$\n-\\frac{1}{\\gamma} \\ln(1 - k \\nu) \\;\\leq\\; \\Delta t \\;\\leq\\; \\frac{1}{2 f}.\n$$\n为了在满足两个约束条件的同时最小化数据量，我们选择最大的可行 $\\Delta t$，即\n$$\n\\Delta t^{\\star} = \\frac{1}{2 f},\n$$\n前提是 $\\frac{1}{2 f} \\geq -\\frac{1}{\\gamma} \\ln(1 - k \\nu)$。\n\n现在我们用给定的参数评估这些界限：\n- 频率：$f = 80\\,\\mathrm{Hz}$ 给出\n$$\n\\Delta t_{\\text{Nyquist}} = \\frac{1}{2 f} = \\frac{1}{2 \\times 80} = \\frac{1}{160} = 0.00625\\,\\mathrm{s}.\n$$\n- 阻尼可分辨性下界，其中 $\\gamma = 50\\,\\mathrm{s}^{-1}$，$k = 5$ 且 $\\nu = 0.005$：\n$$\n\\Delta t_{\\min} = -\\frac{1}{\\gamma} \\ln(1 - k \\nu)\n= -\\frac{1}{50} \\ln(1 - 5 \\times 0.005)\n= -\\frac{1}{50} \\ln(1 - 0.025)\n= -\\frac{1}{50} \\ln(0.975).\n$$\n先符号计算对数，然后求值：\n$$\n\\ln(0.975) \\approx -0.025317,\n\\quad\n\\Rightarrow\n\\Delta t_{\\min} \\approx -\\frac{1}{50} \\times (-0.025317)\n= \\frac{0.025317}{50}\n\\approx 0.00050634\\,\\mathrm{s}.\n$$\n\n可行性检查：\n$$\n\\Delta t_{\\text{Nyquist}} = 0.00625\\,\\mathrm{s}\n\\quad\\text{and}\\quad\n\\Delta t_{\\min} \\approx 0.00050634\\,\\mathrm{s},\n$$\n因此 $\\Delta t_{\\text{Nyquist}} \\geq \\Delta t_{\\min}$，可行区间非空。在两个准则下，最大允许的时间间隔是\n$$\n\\Delta t^{\\star} = \\Delta t_{\\text{Nyquist}} = 0.00625\\,\\mathrm{s}.\n$$\n\n转换为毫秒：\n$$\n\\Delta t^{\\star} = 0.00625\\,\\mathrm{s} = 6.25\\,\\mathrm{ms}.\n$$\n\n四舍五入到三位有效数字，合适的快照时间间隔是 $6.25\\,\\mathrm{ms}$。",
            "answer": "$$\\boxed{6.25}$$"
        },
        {
            "introduction": "在理想情况下，我们总能以满足奈奎斯特准则的频率进行采样，但实际情况往往更为复杂。当我们由于物理或硬件限制而无法采用足够高的采样率时，就会发生频率混叠——高频信号被错误地识别为低频信号。本练习旨在让您深入探究 DMD 分析中的频率混叠现象，并掌握一种巧妙的修正策略。您将通过编程实现一个利用两种不同采样率来明确恢复真实频率的高级技术。这项实践将您的技能从简单的算法应用提升到故障诊断和信号恢复的层面，为您处理非理想实验数据提供了有力的工具 。",
            "id": "3949623",
            "problem": "对流传热场中的单个相干热模态可以局部建模为一种复指数响应，形式为 $T_{\\text{mode}}(t) = \\Re\\{a \\, e^{\\omega t}\\}$，其中 $a \\in \\mathbb{C}$，$t$ 是时间（单位为秒），复角频率为 $\\omega = \\sigma + i \\, 2 \\pi f$。这里，$\\sigma \\in \\mathbb{R}$ 表示实值的增长或衰减率（单位为 $\\text{s}^{-1}$），$f \\in \\mathbb{R}_{\\ge 0}$ 是物理振荡频率（单位为赫兹）。动态模态分解 (Dynamic Mode Decomposition, DMD) 是一种数据驱动的谱分解方法，它通过在时间上以采样间隔 $\\Delta t$（秒）均匀采样的快照来近似底层的线性算子。对于单个模态，离散时间特征值为 $$\\lambda = e^{\\omega \\Delta t}.$$ 复主对数（定义其辐角 $\\operatorname{Arg}(\\lambda) \\in (-\\pi, \\pi]$）产生 DMD 估计值 $$\\hat{\\omega} = \\frac{1}{\\Delta t} \\log(\\lambda),$$ 这意味着虚部满足 $$\\Im(\\hat{\\omega}) = \\frac{\\theta}{\\Delta t}, \\quad \\text{其中 } \\theta = \\operatorname{Arg}(\\lambda) \\in (-\\pi, \\pi].$$ 这为 $\\Im(\\hat{\\omega})$ 强制设定了一个频率窗口 $(-\\pi/\\Delta t, \\pi/\\Delta t]$，即对推断出的角频率存在奈奎斯特限制。因此，不充分的采样间隔 $\\Delta t$ 会通过加或减 $2 \\pi$ 的整数倍，将真实虚部 $\\Im(\\omega) = 2 \\pi f$ 混叠到主分支中，从而将真实频率 $f$ 映射到一个错误的观测值 $\\hat{f} = \\Im(\\hat{\\omega})/(2 \\pi)$。\n\n你的任务是形式化并实现该混叠机制，然后使用一种基于两个不同采样间隔的系统性策略来对频率进行解混叠。程序必须：\n\n- 对于每个测试案例，将热模态视为严格的单频模态，具有给定的真实频率 $f$（赫兹）和增长率 $\\sigma$（$\\text{s}^{-1}$）。为两个采样间隔 $\\Delta t_a$ 和 $\\Delta t_b$（秒）构建相应的连续时间特征值映射和离散时间特征值。\n- 计算由主分支引起的混叠观测值：对于每个 $\\Delta t_j$，构建 $\\lambda_j = \\exp((\\sigma + i 2 \\pi f) \\Delta t_j)$，计算 $\\theta_j = \\operatorname{Arg}(\\lambda_j)$（弧度），然后计算观测频率 $\\hat{f}_j = \\theta_j/(2 \\pi \\Delta t_j)$（赫兹）。\n- 通过模关系 $$2 \\pi f = \\frac{\\theta_j}{\\Delta t_j} + \\frac{2 \\pi n_j}{\\Delta t_j}, \\quad n_j \\in \\mathbb{Z},$$ 展示不充分的 $\\Delta t$ 如何将真实频率 $f$ 映射到 $\\Im(\\hat{\\omega})$，这导出 $$f = \\frac{\\theta_j + 2 \\pi n_j}{2 \\pi \\Delta t_j}.$$\n- 实现一个修正策略，该策略使用两个采样间隔来求解整数 $n_a$ 和 $n_b$。给定一个已知的上界 $f_{\\max}$（赫兹），搜索整数对 $(n_a, n_b)$，使得由 $\\Delta t_a$ 和 $\\Delta t_b$ 得出的两个关于 $f$ 的表达式在一个很小的容差范围内一致，并且 $f \\in [0, f_{\\max}]$。将恢复的频率 $\\tilde{f}$ 报告为两个一致值的平均值。角度必须以弧度处理。搜索容差应为 $10^{-9}$ 赫兹，并且你应该在 $\\{-N_j, \\ldots, N_j\\}$ 的范围内搜索 $n_j$，其中 $N_j = \\lceil f_{\\max} \\Delta t_j \\rceil + 2$。\n- 每个测试案例最终报告的量仅为修正后的解混叠频率 $\\tilde{f}$（赫兹）。在内部，你的程序必须计算混叠值 $\\hat{f}_j$ 以验证该映射，但最终输出应仅包含 $\\tilde{f}$。\n\n使用以下测试套件。每个元组为 $(f, \\sigma, \\Delta t_a, \\Delta t_b, f_{\\max})$：\n\n- 案例 1（两个采样间隔均无混叠）：$(20.0, -1.0, 0.01, 0.012, 100.0)$，其中 $f$ 单位为赫兹，$\\sigma$ 单位为 $\\text{s}^{-1}$，$\\Delta t$ 单位为秒。\n- 案例 2（两个采样间隔均有混叠）：$(120.0, -5.0, 0.01, 0.008, 200.0)$。\n- 案例 3（$\\Delta t_a$ 处于奈奎斯特边界）：$(50.0, 0.0, 0.01, 0.0092, 100.0)$。\n- 案例 4（显著混叠伴随温和增长）：$(300.0, 2.0, 0.004, 0.0033, 500.0)$。\n\n物理单位和数值约定：\n\n- 所有频率 $f$、$\\hat{f}_j$ 和 $\\tilde{f}$ 必须以赫兹表示，并四舍五入到六位小数。\n- 所有时间间隔 $\\Delta t$ 单位为秒。\n- 所有角度单位为弧度。\n\n最终输出格式：\n\n- 你的程序应生成单行输出，包含一个由逗号分隔并用方括号括起来的结果列表，按上述案例顺序排列，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_k$ 是修正后的解混叠频率 $\\tilde{f}$（赫兹），四舍五入到六位小数。输出必须是单行，无任何附加文本。",
            "solution": "该问题是有效的，因为它在科学上基于线性系统和信号处理的原理（特别是连续时间系统的离散时间表示和奈奎斯特-香农采样定理），问题本身是适定的，具有明确的目标和充分的信息，并且表述客观。\n\n解决方案首先将动态模态分解 (DMD) 中固有的混叠现象形式化，然后实现一个系统性搜索算法来消除混叠并恢复热模态的真实频率。\n\n单个热模态由复指数响应 $T_{\\text{mode}}(t) = \\Re\\{a \\, e^{\\omega t}\\}$ 建模，其动态特性由连续时间特征值 $\\omega = \\sigma + i \\, 2 \\pi f$ 决定。其中，$\\sigma$ 是增长/衰减率（单位为 $\\text{s}^{-1}$），$f \\ge 0$ 是振荡频率（单位为赫兹）。\n\n当这个连续时间过程以均匀时间间隔 $\\Delta t$ 进行采样时，得到的离散时间系统由离散时间特征值 $\\lambda$ 描述，它通过以下映射与 $\\omega$ 相关联：\n$$ \\lambda = e^{\\omega \\Delta t} = e^{(\\sigma + i 2 \\pi f) \\Delta t} = e^{\\sigma \\Delta t} e^{i 2 \\pi f \\Delta t} $$\nDMD 从数据中近似这个特征值 $\\lambda$。为了恢复连续时间动态特性，必须计算 $\\lambda$ 的复对数：\n$$ \\hat{\\omega} = \\frac{1}{\\Delta t} \\log(\\lambda) $$\n标准的复对数函数 $\\log(z) = \\ln|z| + i \\operatorname{Arg}(z)$ 使用主辐角 $\\operatorname{Arg}(z) \\in (-\\pi, \\pi]$。将此应用于我们的特征值 $\\lambda$：\n$$\n\\log(\\lambda) = \\ln|e^{\\sigma \\Delta t} e^{i 2 \\pi f \\Delta t}| + i \\operatorname{Arg}(e^{\\sigma \\Delta t} e^{i 2 \\pi f \\Delta t})\n= \\ln(e^{\\sigma \\Delta t}) + i \\operatorname{Arg}(e^{i 2 \\pi f \\Delta t})\n= \\sigma \\Delta t + i \\theta\n$$\n其中 $\\theta = \\operatorname{Arg}(e^{i 2 \\pi f \\Delta t})$ 是真实相位 $2 \\pi f \\Delta t$ 被卷绕到区间 $(-\\pi, \\pi]$ 后的值。\n因此，恢复的连续时间特征值为：\n$$ \\hat{\\omega} = \\frac{1}{\\Delta t}(\\sigma \\Delta t + i \\theta) = \\sigma + i \\frac{\\theta}{\\Delta t} $$\n虽然实部 $\\Re(\\hat{\\omega}) = \\sigma$ 被正确恢复，但虚部发生了混叠。真实相位 $\\phi_{\\text{true}} = 2 \\pi f \\Delta t$ 和观测相位 $\\theta$ 通过一个未知的 $2\\pi$ 整数倍相关联：\n$$ 2 \\pi f \\Delta t = \\theta + 2 \\pi n, \\quad n \\in \\mathbb{Z} $$\n这个整数 $n$ 表示在将真实相位映射到主分支时“丢失”的完整 $2 \\pi$ 圈数。两边同除以 $2 \\pi \\Delta t$ 得到真实频率 $f$ 与观测到的量之间的关系：\n$$ f = \\frac{\\theta + 2 \\pi n}{2 \\pi \\Delta t} $$\n观测频率 $\\hat{f}$ 对应于 $n=0$ 的情况，即 $\\hat{f} = \\frac{\\theta}{2 \\pi \\Delta t}$。这就是混叠值。\n\n为了找到真实频率 $f$，我们必须确定未知整数 $n$。提出的策略使用两个不同的采样间隔 $\\Delta t_a$ 和 $\\Delta t_b$。对于每个采样间隔，我们可以计算离散特征值 $\\lambda_j$及其主辐角 $\\theta_j$（$j \\in \\{a, b\\}$）。这会得到一个包含两个方程和两个未知整数 $n_a$ 和 $n_b$ 的方程组：\n$$ f = \\frac{\\theta_a + 2 \\pi n_a}{2 \\pi \\Delta t_a} $$\n$$ f = \\frac{\\theta_b + 2 \\pi n_b}{2 \\pi \\Delta t_b} $$\n解混叠算法的核心是找到一个整数对 $(n_a, n_b)$，使得这两个关于 $f$ 的表达式一致。我们搜索一对整数，使得计算出的频率（我们表示为 $f_a(n_a)$ 和 $f_b(n_b)$）在一个很小的容差 $\\epsilon = 10^{-9}$ Hz 内相等：\n$$ |f_a(n_a) - f_b(n_b)|  \\epsilon $$\n此外，解必须具有物理意义，受上界 $f_{\\max}$ 的约束，因此我们要求 $0 \\le f \\le f_{\\max}$。\n\n对 $n_j$ 的搜索在一个有限范围 $\\{-N_j, \\ldots, N_j\\}$ 内进行，其中 $N_j = \\lceil f_{\\max} \\Delta t_j \\rceil + 2$。这个范围的构建是为了确保其足够大，以包含任何频率直至 $f_{\\max}$ 的真实整数卷绕计数。\n\n对于每个测试案例，算法按以下步骤进行：\n1. 给定 $f$、$\\sigma$、$\\Delta t_a$、$\\Delta t_b$ 和 $f_{\\max}$。\n2. 计算真实的连续时间特征值 $\\omega = \\sigma + i 2\\pi f$。\n3. 对于每个采样时间 $\\Delta t_j$（$j=a,b$）：\n   a. 计算离散时间特征值 $\\lambda_j = e^{\\omega \\Delta t_j}$。\n   b. 提取主辐角 $\\theta_j = \\operatorname{Arg}(\\lambda_j)$。\n4. 使用 $N_j = \\lceil f_{\\max} \\Delta t_j \\rceil + 2$ 确定 $n_a$ 和 $n_b$ 的搜索范围。\n5. 在这些搜索范围内遍历所有整数对 $(n_a, n_b)$。对于每对整数：\n   a. 计算候选频率 $f_{\\text{cand}, a} = (\\theta_a + 2\\pi n_a)/(2\\pi \\Delta t_a)$ 和 $f_{\\text{cand}, b} = (\\theta_b + 2\\pi n_b)/(2\\pi \\Delta t_b)$。\n   b. 检查候选值是否满足以下条件：\n      i. $|f_{\\text{cand}, a} - f_{\\text{cand}, b}|  10^{-9}$\n      ii. $0 \\le f_{\\text{cand}, a} \\le f_{\\max}$\n      iii. $0 \\le f_{\\text{cand}, b} \\le f_{\\max}$\n6. 如果一对整数满足所有条件，则找到了解混叠频率 $\\tilde{f}$。它被计算为两个一致候选值的平均值：$\\tilde{f} = (f_{\\text{cand}, a} + f_{\\text{cand}, b}) / 2$。然后将此值四舍五入到六位小数作为最终结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the unaliased frequency of a thermal mode given two\n    different sampling intervals.\n    \"\"\"\n    # Test cases: Each tuple is (f, sigma, dt_a, dt_b, f_max)\n    test_cases = [\n        (20.0, -1.0, 0.01, 0.012, 100.0),   # Case 1\n        (120.0, -5.0, 0.01, 0.008, 200.0),  # Case 2\n        (50.0, 0.0, 0.01, 0.0092, 100.0),   # Case 3\n        (300.0, 2.0, 0.004, 0.0033, 500.0)   # Case 4\n    ]\n\n    results = []\n    \n    # Define constants\n    pi = np.pi\n    two_pi = 2 * pi\n    tolerance = 1e-9\n\n    for case in test_cases:\n        f_true, sigma, dt_a, dt_b, f_max = case\n        \n        # 1. Calculate the continuous-time eigenvalue omega\n        omega = sigma + 1j * two_pi * f_true\n\n        # 2. For each sampling time, compute the discrete eigenvalue lambda\n        #    and its principal argument theta\n        lambda_a = np.exp(omega * dt_a)\n        theta_a = np.angle(lambda_a)\n\n        lambda_b = np.exp(omega * dt_b)\n        theta_b = np.angle(lambda_b)\n\n        # 3. Determine the search ranges for integers n_a and n_b\n        # The range is [-N, N] where N = ceil(f_max * dt) + 2\n        N_a = int(np.ceil(f_max * dt_a)) + 2\n        N_b = int(np.ceil(f_max * dt_b)) + 2\n        \n        found_solution = False\n        f_tilde = np.nan\n\n        # 4. Iterate through integer pairs (n_a, n_b) to find a consistent solution\n        for n_a in range(-N_a, N_a + 1):\n            for n_b in range(-N_b, N_b + 1):\n                # Calculate candidate frequencies\n                f_cand_a = (theta_a + two_pi * n_a) / (two_pi * dt_a)\n                f_cand_b = (theta_b + two_pi * n_b) / (two_pi * dt_b)\n\n                # Check if candidates meet the criteria\n                # a) Frequencies are close to each other\n                # b) Frequencies are within the physical bounds [0, f_max]\n                if abs(f_cand_a - f_cand_b)  tolerance:\n                    if 0.0 = f_cand_a = f_max and 0.0 = f_cand_b = f_max:\n                        # 5. A valid solution is found. Average the results.\n                        f_tilde = (f_cand_a + f_cand_b) / 2.0\n                        found_solution = True\n                        break\n            if found_solution:\n                break\n        \n        # 6. Round the final result to 6 decimal places and append\n        results.append(f\"{round(f_tilde, 6):.6f}\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        }
    ]
}