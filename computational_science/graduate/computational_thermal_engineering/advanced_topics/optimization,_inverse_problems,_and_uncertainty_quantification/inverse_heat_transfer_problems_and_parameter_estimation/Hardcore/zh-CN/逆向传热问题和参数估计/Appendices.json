{
    "hands_on_practices": [
        {
            "introduction": "在任何计算分析中，首要步骤都是将连续的物理定律（偏微分方程）转化为计算机可以处理的离散形式。本练习将指导您如何为一个一维热传导问题推导其离散时间状态空间模型 。这是为后续的参数估计和控制算法（如卡尔曼（Kalman）滤波）建立基础模型的关键一步。",
            "id": "3965101",
            "problem": "一个长度为 $L$、具有恒定热物理性质的一维均匀板，其瞬态热传导过程无内部热源。从能量守恒和傅里叶定律出发，描述温度场 $T(x,t)$ 的控制偏微分方程为\n$$\n\\rho c \\,\\frac{\\partial T}{\\partial t} = k\\,\\frac{\\partial^{2} T}{\\partial x^{2}},\n$$\n其中 $\\rho$ 是密度， $c$ 是比热， $k$ 是热导率；热扩散系数为 $\\alpha = k/(\\rho c)$。边界保持在给定温度 $T(0,t)=0$ 和 $T(L,t)=0$。将空间域离散为 $N=4$ 个内部节点，节点位置为 $x_i=i\\,\\Delta x$（$i\\in\\{1,2,3,4\\}$），节点间距均匀，为 $\\Delta x = L/(N+1)$。设状态向量为 $\\mathbf{x}(t) = [\\,T(x_1,t)\\;\\;T(x_2,t)\\;\\;T(x_3,t)\\;\\;T(x_4,t)\\,]^{\\top}$。使用二阶中心有限差分法离散化空间二阶导数，并使用时间步长为 $\\Delta t$ 的前向（显式）Euler 法对时间进行离散化，得到以下形式的线性时不变离散时间状态空间模型\n$$\n\\mathbf{x}_{k+1} = \\mathbf{A}_d(\\alpha,\\Delta t,\\Delta x)\\,\\mathbf{x}_k + \\mathbf{w}_k,\n$$\n其中 $\\mathbf{w}_k$ 代表过程建模不确定性。两个点传感器分别测量内部节点 $x_2$ 和 $x_4$ 处的温度。在离散时间 $k$ 的测量值建模为\n$$\n\\mathbf{y}_k = \\mathbf{H}\\,\\mathbf{x}_k + \\mathbf{v}_k,\n$$\n其中 $\\mathbf{v}_k$ 是均值为零、协方差矩阵为 $\\mathbf{R}$ 的高斯（正态分布）传感器噪声，$\\mathbf{H}$ 是选择观测状态的测量矩阵。热扩散系数 $\\alpha$ 是未知的，将根据测量值 $\\{\\mathbf{y}_k\\}$ 进行估计；在模型推导过程中，将 $\\alpha$ 保持为符号形式。假设边值 $T(0,t)$ 和 $T(L,t)$ 恒等于 $0$，因此没有由边界引起的附加输入。\n\n从控制偏微分方程和上述定义出发，推导内部节点温度的半离散常微分方程（ODE），然后使用前向 Euler 时间离散化方法得到离散时间状态空间模型。显式地写出测量模型，确定 $\\mathbf{H}$ 和 $\\mathbf{v}_k$ 的统计特性。定义无量纲参数 $r = \\alpha\\,\\Delta t/\\Delta x^{2}$，并用 $r$ 表示离散时间状态转移矩阵 $\\mathbf{A}_d$。\n\n使用 $\\mathrm{pmatrix}$ 记法，将最终答案表示为闭式 $4\\times 4$ 矩阵 $\\mathbf{A}_d(r)$。无需进行数值代入或四舍五入。最终表达式中不要包含单位。",
            "solution": "首先对问题进行验证，以确保其具有科学依据、是适定的且客观的。该控制方程是标准的一维热方程，是传热学理论的基石。所用的离散化方法，即中心有限差分和前向 Euler 法，是标准的数值技术。状态空间表述是现代控制与估计理论中处理动态系统的常用方法。该问题提供了所有必要信息，内部逻辑一致，且没有歧义。它是物理系统计算建模中的一个标准练习。因此，该问题被认为是有效的。\n\n求解过程首先通过离散化空间域来推导半离散模型（一个关于时间的常微分方程组），然后通过离散化时间来推导全离散状态空间模型。\n\n瞬态热传导的控制偏微分方程（PDE）为：\n$$\n\\rho c \\,\\frac{\\partial T}{\\partial t} = k\\,\\frac{\\partial^{2} T}{\\partial x^{2}}\n$$\n两边同除以 $\\rho c$ 并利用热扩散系数的定义 $\\alpha = k/(\\rho c)$，我们得到：\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha\\,\\frac{\\partial^{2} T}{\\partial x^{2}}\n$$\n长度为 $L$ 的空间域被离散为 $N=4$ 个内部节点，节点间距均匀，为 $\\Delta x = L/(N+1) = L/5$。节点位置为 $x_i = i\\,\\Delta x$（$i \\in \\{1, 2, 3, 4\\}$）。这些节点上的温度记为 $T_i(t) = T(x_i, t)$。边界条件为 $T(0,t)=0$ 和 $T(L,t)=0$。在我们的离散框架中，这对应于 $T_0(t) = 0$ 和 $T_5(t) = 0$，因为 $x_0 = 0$ 且 $x_5 = 5\\,\\Delta x = L$。\n\n为得到半离散系统，我们使用二阶中心有限差分格式来近似每个内部节点 $x_i$ 处的空间二阶导数：\n$$\n\\frac{\\partial^{2} T}{\\partial x^{2}}\\bigg|_{x=x_i} \\approx \\frac{T(x_i - \\Delta x, t) - 2T(x_i, t) + T(x_i + \\Delta x, t)}{\\Delta x^2} = \\frac{T_{i-1}(t) - 2T_i(t) + T_{i+1}(t)}{\\Delta x^2}\n$$\n将此近似代入每个内部节点的控制偏微分方程，得到一个常微分方程组（ODEs）：\n$$\n\\frac{d T_i}{d t} = \\frac{\\alpha}{\\Delta x^2} (T_{i-1} - 2T_i + T_{i+1})\n$$\n我们为 $N=4$ 个内部节点中的每一个写出该方程：\n对于节点 $i=1$：$\\frac{d T_1}{d t} = \\frac{\\alpha}{\\Delta x^2} (T_0 - 2T_1 + T_2)$。由于 $T_0=0$，该式变为 $\\frac{d T_1}{d t} = \\frac{\\alpha}{\\Delta x^2} (-2T_1 + T_2)$。\n对于节点 $i=2$：$\\frac{d T_2}{d t} = \\frac{\\alpha}{\\Delta x^2} (T_1 - 2T_2 + T_3)$。\n对于节点 $i=3$：$\\frac{d T_3}{d t} = \\frac{\\alpha}{\\Delta x^2} (T_2 - 2T_3 + T_4)$。\n对于节点 $i=4$：$\\frac{d T_4}{d t} = \\frac{\\alpha}{\\Delta x^2} (T_3 - 2T_4 + T_5)$。由于 $T_5=0$，该式变为 $\\frac{d T_4}{d t} = \\frac{\\alpha}{\\Delta x^2} (T_3 - 2T_4)$。\n\n该常微分方程组可以写成矩阵形式 $\\dot{\\mathbf{x}}(t) = \\mathbf{A}_c \\mathbf{x}(t)$，其中状态向量为 $\\mathbf{x}(t) = [\\,T_1(t)\\;\\;T_2(t)\\;\\;T_3(t)\\;\\;T_4(t)\\,]^{\\top}$。\n$$\n\\frac{d}{dt} \\begin{pmatrix} T_1 \\\\ T_2 \\\\ T_3 \\\\ T_4 \\end{pmatrix} = \\frac{\\alpha}{\\Delta x^2} \\begin{pmatrix} -2  1  0  0 \\\\ 1  -2  1  0 \\\\ 0  1  -2  1 \\\\ 0  0  1  -2 \\end{pmatrix} \\begin{pmatrix} T_1 \\\\ T_2 \\\\ T_3 \\\\ T_4 \\end{pmatrix}\n$$\n因此，连续时间系统矩阵为 $\\mathbf{A}_c = \\frac{\\alpha}{\\Delta x^2} \\begin{pmatrix} -2  1  0  0 \\\\ 1  -2  1  0 \\\\ 0  1  -2  1 \\\\ 0  0  1  -2 \\end{pmatrix}$。\n\n接下来，我们使用时间步长为 $\\Delta t$ 的前向（显式）Euler 法对时间进行离散化。时间导数近似为 $\\dot{\\mathbf{x}}(t_k) \\approx (\\mathbf{x}(t_{k+1}) - \\mathbf{x}(t_k))/\\Delta t = (\\mathbf{x}_{k+1} - \\mathbf{x}_k)/\\Delta t$。\n将此代入半离散系统 $\\dot{\\mathbf{x}} = \\mathbf{A}_c \\mathbf{x}$ 中：\n$$\n\\frac{\\mathbf{x}_{k+1} - \\mathbf{x}_k}{\\Delta t} = \\mathbf{A}_c \\mathbf{x}_k\n$$\n重新整理以求解 $\\mathbf{x}_{k+1}$：\n$$\n\\mathbf{x}_{k+1} = \\mathbf{x}_k + \\Delta t \\mathbf{A}_c \\mathbf{x}_k = (\\mathbf{I} + \\Delta t \\mathbf{A}_c) \\mathbf{x}_k\n$$\n其中 $\\mathbf{I}$ 是 $4\\times 4$ 的单位矩阵。通过与给定的状态空间模型形式 $\\mathbf{x}_{k+1} = \\mathbf{A}_d \\mathbf{x}_k + \\mathbf{w}_k$ 进行比较，我们可以确定离散时间状态转移矩阵 $\\mathbf{A}_d$ 为：\n$$\n\\mathbf{A}_d = \\mathbf{I} + \\Delta t \\mathbf{A}_c\n$$\n代入 $\\mathbf{A}_c$ 的表达式：\n$$\n\\mathbf{A}_d = \\mathbf{I} + \\Delta t \\left( \\frac{\\alpha}{\\Delta x^2} \\begin{pmatrix} -2  1  0  0 \\\\ 1  -2  1  0 \\\\ 0  1  -2  1 \\\\ 0  0  1  -2 \\end{pmatrix} \\right)\n$$\n使用定义的无量纲参数 $r = \\alpha\\Delta t/\\Delta x^2$：\n$$\n\\mathbf{A}_d = \\mathbf{I} + r \\begin{pmatrix} -2  1  0  0 \\\\ 1  -2  1  0 \\\\ 0  1  -2  1 \\\\ 0  0  1  -2 \\end{pmatrix}\n$$\n进行矩阵加法：\n$$\n\\mathbf{A}_d(r) = \\begin{pmatrix} 1  0  0  0 \\\\ 0  1  0  0 \\\\ 0  0  1  0 \\\\ 0  0  0  1 \\end{pmatrix} + \\begin{pmatrix} -2r  r  0  0 \\\\ r  -2r  r  0 \\\\ 0  r  -2r  r \\\\ 0  0  r  -2r \\end{pmatrix} = \\begin{pmatrix} 1-2r  r  0  0 \\\\ r  1-2r  r  0 \\\\ 0  r  1-2r  r \\\\ 0  0  r  1-2r \\end{pmatrix}\n$$\n这就是所求的离散时间状态转移矩阵。\n\n最后，我们构建测量模型。传感器测量节点 $x_2$ 和 $x_4$ 处的温度。因此，测量向量 $\\mathbf{y}_k$ 由温度 $T_2(t_k)$ 和 $T_4(t_k)$ 组成。测量模型为 $\\mathbf{y}_k = \\mathbf{H}\\mathbf{x}_k + \\mathbf{v}_k$。测量矩阵 $\\mathbf{H}$ 必须选择状态向量 $\\mathbf{x}_k = [\\,T_1(t_k)\\;\\;T_2(t_k)\\;\\;T_3(t_k)\\;\\;T_4(t_k)\\,]^{\\top}$ 的第二个和第四个分量。这可以通过以下矩阵实现：\n$$\n\\mathbf{H} = \\begin{pmatrix} 0  1  0  0 \\\\ 0  0  0  1 \\end{pmatrix}\n$$\n测量噪声 $\\mathbf{v}_k$ 被指定为协方差矩阵为 $\\mathbf{R}$ 的零均值高斯过程，形式上记为 $\\mathbf{v}_k \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{R})$。\n\n问题要求将闭式 $4 \\times 4$ 矩阵 $\\mathbf{A}_d(r)$ 作为最终答案。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 1 - 2r  r  0  0 \\\\ r  1 - 2r  r  0 \\\\ 0  r  1 - 2r  r \\\\ 0  0  r  1 - 2r \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "建立了计算模型后，我们便会遇到逆问题的核心挑战：不适定性（ill-posedness）。本练习通过一个动手编程任务，直观地展示了非唯一性（non-uniqueness）这一概念 。您将发现，不同的物理原因（例如热源分布）可以产生完全相同的稀疏测量数据，这使得逆问题本质上是模糊的，并凸显了为何简单的直接反演是不可行的。",
            "id": "3965224",
            "problem": "考虑有限长杆上存在时间无关的分布体积热源的一维热传导问题，该问题由以下偏微分方程控制：\n$$\nu_t(x,t) - \\alpha\\, u_{xx}(x,t) = q(x), \\quad x \\in (0,L), \\ t > 0,\n$$\n服从齐次狄利克雷（Dirichlet）边界条件和零初始条件：\n$$\nu(0,t) = u(L,t) = 0 \\ \\text{for all } t \\ge 0, \\qquad u(x,0)=0 \\ \\text{for all } x \\in [0,L].\n$$\n此处，$u(x,t)$ 是温度场，$\\alpha > 0$ 是热扩散系数，$q(x)$ 是未知的时间无关的分布热源。逆热传递问题旨在从稀疏的温度测量值中重建 $q(x)$。\n\n从能量守恒和傅里叶（Fourier）热传导定律出发，并使用与边界条件一致的变量分离表示法，可以将 $q(x)$ 和 $u(x,t)$ 在合适的正交基中表示，并获得一个线性测量算子，该算子将源的系数映射到有限个时空位置上的测量温度。由于测量次数是有限的，此映射可能不是单射的，这意味着多个不同的源 $q_1(x) \\ne q_2(x)$ 可能会产生相同的测量数据 $u(x_i, T_k)$。\n\n您的任务是构造明确的反例，以证明从稀疏测量值估计 $q(x)$ 的非唯一性。您必须实现一个程序，对于每个指定的测试用例，构造两个不同的源 $q_1(x)$ 和 $q_2(x)$，并评估在给定传感器位置和时间下，根据定义在域 $(0,L)$ 上的正向热传导模型和所述条件，它们是否产生相同的测量值。将 $q(x)$ 表示为一个截断级数\n$$\nq(x) \\approx \\sum_{n=1}^{N} \\hat{q}_n \\, \\sin\\!\\left( \\frac{n \\pi x}{L} \\right),\n$$\n其中截断指数 $N$ 足够大，以便在数值上能明显看出反例。对于每个测试用例，定义从系数 $\\hat{q}_n$ 到测量向量 $\\{u(x_i,T_k)\\}_{i,k}$ 的正向映射（由控制方程和边界/初始条件所隐含），并构造 $q_1$ 和 $q_2$，使得 $q_1 \\ne q_2$ 但计算出的测量值在数值精度范围内重合。\n\n为了量化非唯一性，为每个测试用例计算比率\n$$\n\\mathcal{E} \\;=\\; \\frac{\\left\\| \\mathbf{y}(q_2) - \\mathbf{y}(q_1) \\right\\|_\\infty}{\\left\\| \\hat{\\mathbf{q}}^{(2)} - \\hat{\\mathbf{q}}^{(1)} \\right\\|_2},\n$$\n其中 $\\mathbf{y}(q)$ 是堆叠的测量向量，$\\|\\cdot\\|_\\infty$ 是测量条目上的最大范数，$\\|\\cdot\\|_2$ 是截断系数向量上的欧几里得范数。一个成功的反例应表现出 $\\mathcal{E}$ 在数值上与零无法区分（在浮点舍入误差范围内），而 $\\left\\|\\hat{\\mathbf{q}}^{(2)} - \\hat{\\mathbf{q}}^{(1)}\\right\\|_2 > 0$。\n\n使用以下测试套件。在所有情况下，取 $L=1$ 和 $\\alpha=1$。测量集由空间传感器位置 $\\{x_i\\}$ 和时间 $\\{T_k\\}$ 定义，并给出级数截断阶数 $N$。对于每个测试用例，您必须构造 $q_1$ 和 $q_2$，使得 $\\mathcal{E}$ 尽可能接近于零，同时 $q_1 \\ne q_2$：\n\n- 测试用例 1（单个传感器不可见性）：$\\{x_i\\} = \\{0.5\\}$，$\\{T_k\\} = \\{0.6\\}$，$N=50$。\n- 测试用例 2（两个对称传感器）：$\\{x_i\\} = \\{1/3, \\ 2/3\\}$，$\\{T_k\\} = \\{0.8\\}$，$N=60$。\n- 测试用例 3（多个时间，两个传感器）：$\\{x_i\\} = \\{0.25, \\ 0.5\\}$，$\\{T_k\\} = \\{0.2, \\ 0.7\\}$，$N=64$。\n- 测试用例 4（通用传感器和时间；零空间构造）：$\\{x_i\\} = \\{0.2, \\ 0.4, \\ 0.7\\}$，$\\{T_k\\} = \\{0.1, \\ 0.3, \\ 0.9\\}$，$N=30$。\n\n对于测试用例 1-3，您应利用给定传感器位置处正弦本征函数的结构特性，选择对测量不可见的系数的非平凡子集；对于测试用例 4，您应使用至少由 $N$ 指定的基函数数量，在线性测量算子的零空间中构造一个非平凡向量，以在一般情况下证明非唯一性。\n\n您的程序必须生成单行输出，其中包含按上述顺序列出的四个测试用例的 $\\mathcal{E}$ 值，形式为方括号括起来的逗号分隔列表（例如，\"[e1,e2,e3,e4]\"）。这些输出是纯数字，没有物理单位，因为它们是范数的比率；不需要单位转换。如果存在角度，必须以弧度为单位进行解释；然而，此任务不明确要求角度单位。最终的数值输出必须是浮点值。",
            "solution": "该问题要求构造反例来证明逆热源问题的非唯一性。具体来说，我们必须找到两个不同的、时间无关的热源 $q_1(x)$ 和 $q_2(x)$，它们在稀疏的位置和时间点集上产生相同的温度测量值。非唯一性的度量由比率 $\\mathcal{E}$ 给出。\n\n温度 $u(x,t)$ 的控制偏微分方程(PDE)是带源项 $q(x)$ 的一维热方程：\n$$\nu_t - \\alpha u_{xx} = q(x), \\quad x \\in (0,L), \\ t > 0\n$$\n服从齐次狄利克雷（Dirichlet）边界条件 $u(0,t) = u(L,t) = 0$ 和零初始条件 $u(x,0) = 0$。\n\n首先，我们推导将给定源 $q(x)$ 映射到温度场 $u(x,t)$ 的正向模型。齐次边界条件建议使用变量分离法和正弦级数基，该基在区间 $[0,L]$ 上是正交的。我们将未知源 $q(x)$ 和温度 $u(x,t)$ 表示为截断的傅里叶正弦级数：\n$$\nq(x) = \\sum_{n=1}^{N} \\hat{q}_n \\sin\\left(\\frac{n\\pi x}{L}\\right)\n$$\n$$\nu(x,t) = \\sum_{n=1}^{N} \\hat{u}_n(t) \\sin\\left(\\frac{n\\pi x}{L}\\right)\n$$\n其中 $\\hat{q}_n$ 是常数系数，$\\hat{u}_n(t)$ 是与时间相关的系数。\n\n将这些级数代入偏微分方程，我们得到：\n$$\n\\sum_{n=1}^{N} \\frac{d\\hat{u}_n}{dt} \\sin\\left(\\frac{n\\pi x}{L}\\right) - \\alpha \\sum_{n=1}^{N} \\hat{u}_n(t) \\left(-\\frac{n^2\\pi^2}{L^2}\\right) \\sin\\left(\\frac{n\\pi x}{L}\\right) = \\sum_{n=1}^{N} \\hat{q}_n \\sin\\left(\\frac{n\\pi x}{L}\\right)\n$$\n根据正弦基函数的正交性，这个等式必须对每个模态独立成立。这为系数 $\\hat{u}_n(t)$ 产生了一个包含 $N$ 个解耦的一阶常微分方程（ODEs）的系统：\n$$\n\\frac{d\\hat{u}_n}{dt} + \\alpha \\left(\\frac{n\\pi}{L}\\right)^2 \\hat{u}_n(t) = \\hat{q}_n, \\quad n=1, 2, \\dots, N\n$$\n初始条件 $u(x,0)=0$ 意味着对所有 $n$ 都有 $\\hat{u}_n(0)=0$。这个常微分方程初值问题的解是：\n$$\n\\hat{u}_n(t) = \\frac{\\hat{q}_n}{\\lambda_n} \\left(1 - e^{-\\lambda_n t}\\right), \\quad \\text{其中} \\quad \\lambda_n = \\alpha \\left(\\frac{n\\pi}{L}\\right)^2\n$$\n将此解代回 $u(x,t)$ 的级数中，得到完整的正向解：\n$$\nu(x,t) = \\sum_{n=1}^{N} \\hat{q}_n \\frac{L^2}{\\alpha n^2\\pi^2} \\left(1 - e^{-\\alpha(n\\pi/L)^2 t}\\right) \\sin\\left(\\frac{n\\pi x}{L}\\right)\n$$\n这个方程建立了源系数 $\\hat{\\mathbf{q}} = [\\hat{q}_1, \\dots, \\hat{q}_N]^T$ 与特定点 $(x_i, T_k)$ 处的温度测量值之间的线性关系。设 $\\mathbf{y}$ 为堆叠的测量值 $u(x_i, T_k)$ 的向量。该关系可以写成矩阵向量乘积的形式：\n$$\n\\mathbf{y} = \\mathbf{A}\\hat{\\mathbf{q}}\n$$\n其中 $\\mathbf{A}$ 是正向算子，一个尺寸为 $M \\times N$ 的矩阵，其中 $M$ 是测量总数。$\\mathbf{A}$ 中对应于测量 $(x_i, T_k)$ 和系数 $\\hat{q}_n$ 的条目是：\n$$\nA_{(i,k), n} = \\frac{L^2}{\\alpha n^2\\pi^2} \\left(1 - e^{-\\alpha(n\\pi/L)^2 T_k}\\right) \\sin\\left(\\frac{n\\pi x_i}{L}\\right)\n$$\n如果我们可以找到两个不同的系数向量 $\\hat{\\mathbf{q}}^{(1)} \\neq \\hat{\\mathbf{q}}^{(2)}$ 产生相同的测量向量，即 $\\mathbf{A}\\hat{\\mathbf{q}}^{(1)} = \\mathbf{A}\\hat{\\mathbf{q}}^{(2)}$，则逆问题中出现非唯一性。这等价于找到一个非零向量 $\\Delta\\hat{\\mathbf{q}} = \\hat{\\mathbf{q}}^{(2)} - \\hat{\\mathbf{q}}^{(1)}$ 使得 $\\mathbf{A}\\Delta\\hat{\\mathbf{q}} = \\mathbf{0}$。这样的向量 $\\Delta\\hat{\\mathbf{q}}$ 位于矩阵 $\\mathbf{A}$ 的零空间（或核）中。\n\n任务是为每个测试用例找到这样一个 $\\Delta\\hat{\\mathbf{q}} \\neq \\mathbf{0}$。我们可以将 $\\hat{\\mathbf{q}}^{(1)}$ 设置为任意向量（例如，零向量），并令 $\\hat{\\mathbf{q}}^{(2)} = \\hat{\\mathbf{q}}^{(1)} + \\Delta\\hat{\\mathbf{q}}$。非唯一性度量 $\\mathcal{E}$ 于是为：\n$$\n\\mathcal{E} = \\frac{\\left\\| \\mathbf{y}(q_2) - \\mathbf{y}(q_1) \\right\\|_\\infty}{\\left\\| \\hat{\\mathbf{q}}^{(2)} - \\hat{\\mathbf{q}}^{(1)} \\right\\|_2} = \\frac{\\left\\| \\mathbf{A}\\Delta\\hat{\\mathbf{q}} \\right\\|_\\infty}{\\left\\| \\Delta\\hat{\\mathbf{q}} \\right\\|_2}\n$$\n一个成功的反例将产生 $\\mathcal{E} \\approx 0$，同时 $\\|\\Delta\\hat{\\mathbf{q}}\\|_2 > 0$。对于所有测试用例，$L=1$ 且 $\\alpha=1$。\n\n情况 1：$\\{x_i\\} = \\{0.5\\}$, $\\{T_k\\} = \\{0.6\\}$, $N=50$。\n算子的空间部分是 $\\sin(n\\pi x_i) = \\sin(n\\pi/2)$。对于任何偶数 $n$，此项为零。因此，矩阵 $\\mathbf{A}$ 中任何 $n$ 为偶数的列都将是零列。我们可以通过为偶数模态（例如 $n=2$）选择一个非零系数来构造一个零空间向量 $\\Delta\\hat{\\mathbf{q}}$。我们选择 $\\Delta\\hat{\\mathbf{q}}$ 为标准基向量 $e_2$（对应于 $n=2$，在1基系统中是第二个索引，因此在0基数组中是索引1），所以 $\\hat{q}_2=1$ 且所有其他系数为零。根据构造，$\\mathbf{A}\\Delta\\hat{\\mathbf{q}}=\\mathbf{0}$。\n\n情况 2：$\\{x_i\\} = \\{1/3, 2/3\\}$, $\\{T_k\\} = \\{0.8\\}$, $N=60$。\n空间项在 $x_1=1/3$ 和 $x_2=2/3$ 处求值。\n如果 $n$ 是 $3$ 的倍数，则 $\\sin(n\\pi/3) = 0$。\n如果 $n$ 是 $3$ 的倍数，则 $\\sin(2n\\pi/3) = 0$。\n因此，对于任何是 $3$ 的倍数的 $n$，$\\mathbf{A}$ 的相应列是零列。我们选择 $\\Delta\\hat{\\mathbf{q}}$ 在 $n=3$ 处有一个非零分量，即标准基向量 $e_3$（在0基数组中是索引2）。\n\n情况 3：$\\{x_i\\} = \\{0.25, 0.5\\}$, $\\{T_k\\} = \\{0.2, 0.7\\}$, $N=64$。\n空间位置是 $x_1=1/4$ 和 $x_2=1/2$。\n对于 $n$ 是 $4$ 的倍数，$\\sin(n\\pi/4)$ 为零。\n对于 $n$ 是 $2$ 的倍数，$\\sin(n\\pi/2)$ 为零。\n要使 $\\mathbf{A}$ 的一列为零，正弦项必须对所有传感器位置都为零。这发生在 $n$ 是分母的最小公倍数，即 $\\text{lcm}(4,2)=4$ 的倍数时。因此，对于任何是 $4$ 的倍数的 $n$，相应的列是零。我们选择 $\\Delta\\hat{\\mathbf{q}}$ 为标准基向量 $e_4$（在0基数组中是索引3）。\n\n情况 4：$\\{x_i\\} = \\{0.2, 0.4, 0.7\\}$, $\\{T_k\\} = \\{0.1, 0.3, 0.9\\}$, $N=30$。\n传感器位置不会导致矩阵 $\\mathbf{A}$ 中出现明显的结构性零。在这里，测量数量为 $M = 3 \\times 3 = 9$，而未知系数的数量为 $N=30$。由于 $N > M$，矩阵 $\\mathbf{A}$ 是一个“宽”矩阵，其零空间保证是非平凡的（其维度至少为 $N-M = 21$）。为了找到零空间中的一个向量，我们使用 $\\mathbf{A}$ 的奇异值分解(SVD) $\\mathbf{A} = \\mathbf{U}\\mathbf{\\Sigma}\\mathbf{V}^T$。$\\mathbf{V}$ 中对应于 $\\mathbf{\\Sigma}$ 中零（或数值上非常小）奇异值的列构成了 $\\mathbf{A}$ 零空间的一个标准正交基。我们选择 $\\Delta\\hat{\\mathbf{q}}$ 为对应于最小奇异值的 $\\mathbf{V}$ 的列。该向量被计算为矩阵 $\\mathbf{V}^T$（在数值库中表示为`vh`）的最后一行。\n根据构造，$\\|\\Delta\\hat{\\mathbf{q}}\\|_2=1$，且 $\\|\\mathbf{A}\\Delta\\hat{\\mathbf{q}}\\|_2 = \\sigma_{\\min}$，其中 $\\sigma_{\\min}$ 是最小奇异值。因此 $\\mathcal{E}$ 将在 $\\sigma_{\\min}$ 的量级，接近于机器精度。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the four test cases for the inverse heat source problem and prints the results.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1: (xs, Ts, N)\n        ({'xs': [0.5], 'Ts': [0.6], 'N': 50, 'case_num': 1}),\n        # Case 2\n        ({'xs': [1/3, 2/3], 'Ts': [0.8], 'N': 60, 'case_num': 2}),\n        # Case 3\n        ({'xs': [0.25, 0.5], 'Ts': [0.2, 0.7], 'N': 64, 'case_num': 3}),\n        # Case 4\n        ({'xs': [0.2, 0.4, 0.7], 'Ts': [0.1, 0.3, 0.9], 'N': 30, 'case_num': 4})\n    ]\n    \n    results = []\n    for params in test_cases:\n        e_ratio = calculate_e_ratio(**params)\n        results.append(e_ratio)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_e_ratio(xs, Ts, N, case_num, L=1.0, alpha=1.0):\n    \"\"\"\n    Constructs a counterexample for a given test case and computes the non-uniqueness ratio E.\n    \n    Args:\n        xs (list): List of spatial sensor locations.\n        Ts (list): List of measurement times.\n        N (int): Truncation order for the Fourier series.\n        case_num (int): The test case number (1-4).\n        L (float): Length of the rod.\n        alpha (float): Thermal diffusivity.\n\n    Returns:\n        float: The calculated ratio E.\n    \"\"\"\n    num_measurements = len(xs) * len(Ts)\n    A = np.zeros((num_measurements, N))\n    \n    n_vals = np.arange(1, N + 1)\n    \n    # Vectorized calculation of coefficients for matrix A\n    lambda_n = alpha * (n_vals * np.pi / L)**2\n    # Pre-calculate term that is independent of x_i and T_k\n    term1 = (L**2) / (alpha * (n_vals * np.pi)**2)\n    \n    row_idx = 0\n    for T_k in Ts:\n        for x_i in xs:\n            # Calculate the row of A corresponding to (x_i, T_k)\n            term2 = 1 - np.exp(-lambda_n * T_k)\n            term3 = np.sin(n_vals * np.pi * x_i / L)\n            A[row_idx, :] = term1 * term2 * term3\n            row_idx += 1\n\n    # Construct the null-space vector delta_q_hat\n    delta_q_hat = np.zeros(N)\n    \n    if case_num == 1:\n        # For x=0.5, sin(n*pi*0.5) is 0 for n=2,4,6... We pick n=2.\n        # n is 1-based, array is 0-based. n=2 corresponds to index 1.\n        delta_q_hat[1] = 1.0\n    elif case_num == 2:\n        # For x=1/3 and x=2/3, sin(n*pi*x) is 0 for n=3,6,9... We pick n=3.\n        # n=3 corresponds to index 2.\n        delta_q_hat[2] = 1.0\n    elif case_num == 3:\n        # For x=0.25 and x=0.5, sin(n*pi*x) is 0 for n=4,8,12... We pick n=4.\n        # n=4 corresponds to index 3.\n        delta_q_hat[3] = 1.0\n    elif case_num == 4:\n        # Generic case: use SVD to find a vector in the numerical null space.\n        # The matrix vh contains the right singular vectors as rows.\n        # The last row corresponds to the smallest singular value.\n        _u, _s, vh = np.linalg.svd(A, full_matrices=True)\n        delta_q_hat = vh[-1]\n    \n    # Calculate the ratio E\n    # y_diff = A @ delta_q_hat\n    y_diff = np.dot(A, delta_q_hat)\n    norm_y_diff = np.linalg.norm(y_diff, ord=np.inf)\n    norm_q_diff = np.linalg.norm(delta_q_hat, ord=2)\n    \n    if norm_q_diff  1e-15:\n        # This should not happen with the chosen delta_q_hat vectors\n        return np.nan\n        \n    return norm_y_diff / norm_q_diff\n\nsolve()\n```"
        },
        {
            "introduction": "由于逆问题具有不适定性，我们需要专门的技术来寻求稳定且有意义的解。本综合练习将向您介绍 Tikhonov 正则化，这是一种应对此类问题的经典方法 。此实践涵盖了该方法的理论基础、选择关键正则化参数的算法设计，以及其在一个实际问题中的完整编程实现，从而“驯服”不适定性。",
            "id": "3965129",
            "problem": "考虑一个线性逆热传递估计问题，该问题源于一个在时间和空间上已经离散化的一维瞬态热传导模型。离散化的正向算子将未知的边界热通量向量映射到内部温度测量值。记线性正向算子为 $A \\in \\mathbb{R}^{m \\times n}$，未知参数向量（例如，$n$ 个离散时刻的边界热通量）为 $\\theta \\in \\mathbb{R}^{n}$，在 $m$ 个时空点的测量温度向量为 $b \\in \\mathbb{R}^{m}$。测量模型为\n$$\nb = A \\theta_{\\text{true}} + \\varepsilon,\n$$\n其中 $\\theta_{\\text{true}} \\in \\mathbb{R}^{n}$ 是真实参数向量，$\\varepsilon \\in \\mathbb{R}^{m}$ 是一个加性噪声向量，其分量是独立同分布的，服从均值为零、已知标准差为 $\\sigma$ 的高斯（正态）分布，即 $\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$ 对于 $i = 1,2,\\dots,m$。\n\n为稳定 $\\theta$ 的估计，考虑零阶 Tikhonov 正则化，其中对于给定的正则化参数 $\\lambda  0$ 和单位惩罚 $L = I_n$，正则化估计 $\\theta_{\\lambda}$ 求解最小化问题\n$$\n\\theta_{\\lambda} = \\arg\\min_{\\theta \\in \\mathbb{R}^n} \\left\\{ \\|A \\theta - b\\|_2^2 + \\lambda^2 \\|\\theta\\|_2^2 \\right\\}.\n$$\n定义残差向量 $r(\\lambda) = A \\theta_{\\lambda} - b$ 及其范数 $\\|r(\\lambda)\\|_2$。\n\n任务1（推导）：从概率测量模型和欧几里得范数的基本性质出发，推导一个在噪声水平 $\\sigma$ 已知时选择正则化参数 $\\lambda$ 的原则性规则。具体来说，推导差异性原则，该原则规定选择 $\\lambda$ 以使残差范数满足\n$$\n\\|A \\theta_{\\lambda} - b\\|_2 \\approx \\tau \\, \\sigma \\, \\sqrt{m},\n$$\n其中 $\\tau \\geq 1$ 是一个安全因子，用于解释模型差异和 $\\sigma$ 的不确定性。\n\n任务2（算法设计）：提出并论证一个稳健的数值算法，用于从第一性原理计算这样的 $\\lambda$，而不使用快捷公式。你的算法应依赖于基本的线性代数运算和残差范数相对于 $\\lambda$ 的单调性。\n\n任务3（程序实现与测试套件）：实现一个完整的程序，该程序为以下每个测试用例构建 $A$、$\\theta_{\\text{true}}$ 和 $b$；然后使用你的算法根据差异性原则选择 $\\lambda$；并输出所选的 $\\lambda$ 值。\n\n确保科学真实性的构建细节：\n- 对于所有测试用例，通过一个代表一维热传导离散 Green 函数的指数衰减核来定义 $A$：\n$$\nA_{ij} = \\exp\\left(-\\alpha \\, |i - j|\\right),\n$$\n衰减率为 $\\alpha  0$，其中索引 $i = 1,2,\\dots,m$ 和 $j = 1,2,\\dots,n$。这产生了一个在逆热传导问题中典型的、物理上合理的病态正向算子。\n- 对于真实参数向量，设置\n$$\n\\theta_{\\text{true},j} = \\sin\\left(\\frac{\\pi j}{n+1}\\right), \\quad j = 1,2,\\dots,n,\n$$\n这是一个与实际热通量历史一致的光滑、带限剖面。\n- 使用固定的伪随机种子 $12345$ 生成噪声向量 $\\varepsilon$，以确保跨实现的一致性，即对所有测试用例使用同一个种子 $12345$。噪声分量应为独立同分布的高斯值，其标准差为 $\\sigma$（单位与 $b$ 的条目相同）。\n\n测试套件：\n- 用例 A（正常路径）: $m = 30$, $n = 10$, $\\alpha = 0.35$, $\\sigma = 0.02$, $\\tau = 1.05$。\n- 用例 B（近无噪声边缘情况）: $m = 30$, $n = 10$, $\\alpha = 0.35$, $\\sigma = 10^{-6}$, $\\tau = 1.00$。\n- 用例 C（高噪声边缘情况）: $m = 30$, $n = 10$, $\\alpha = 0.35$, $\\sigma = 0.20$, $\\tau = 1.10$。\n- 用例 D（秩亏正向算子）: $m = 25$, $n = 12$, $\\alpha = 0.50$, $\\sigma = 0.03$, $\\tau = 1.05$。为引入秩亏，在使用上述核构建 $A$ 后，将其最后两列覆盖为倒数第三列的副本，即设置 $A_{:,n-1} = A_{:,n-2}$ 和 $A_{:,n} = A_{:,n-2}$。\n\n数值要求和输出规范：\n- 你的算法必须找到 $\\lambda$，使得 $\\|A \\theta_{\\lambda} - b\\|_2$ 与目标值 $\\tau \\sigma \\sqrt{m}$ 的绝对容差在 $10^{-8}$ 以内；如果目标低于可实现的最小残差（例如，由于 $b$ 在 $A$ 的左零空间中的分量），则返回 $\\lambda = 0$。\n- 在此问题中，所有量都是无量纲的；输出中无需携带物理单位。\n- 你的程序应产生单行输出，其中包含四个测试用例所选的 $\\lambda$ 值，格式为方括号内以逗号分隔的列表，即\n$$\n[\\lambda_{\\text{A}}, \\lambda_{\\text{B}}, \\lambda_{\\text{C}}, \\lambda_{\\text{D}}].\n$$\n每个 $\\lambda$ 必须以普通浮点数形式打印。\n\n你的程序必须是完整且可直接运行的，无需任何用户输入或外部文件，并且必须使用固定的伪随机种子 $12345$ 进行噪声生成，以确保输出是确定性的。",
            "solution": "所提出的问题是计算热工学领域一个适定且有科学依据的练习，特别关注线性逆问题背景下的参数估计。它要求推导一个标准的正则化参数选择规则，设计一个实现该规则的数值算法，并提供一个针对指定测试套件进行测试的具体实现。\n\n### 步骤1：提取已知条件\n- **测量模型**：$b = A \\theta_{\\text{true}} + \\varepsilon$，其中 $A \\in \\mathbb{R}^{m \\times n}$，$ \\theta_{\\text{true}} \\in \\mathbb{R}^{n}$，$b \\in \\mathbb{R}^{m}$，以及 $\\varepsilon \\in \\mathbb{R}^{m}$。\n- **噪声模型**：噪声向量 $\\varepsilon$ 的分量，记为 $\\varepsilon_i$，是独立同分布（i.i.d.）的，服从均值为零、已知方差为 $\\sigma^2$ 的高斯分布，即 $\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$。\n- **正则化问题**：对于正则化参数 $\\lambda  0$，零阶 Tikhonov 正则化估计 $\\theta_{\\lambda}$ 是 $\\theta_{\\lambda} = \\arg\\min_{\\theta \\in \\mathbb{R}^n} \\left\\{ \\|A \\theta - b\\|_2^2 + \\lambda^2 \\|\\theta\\|_2^2 \\right\\}$ 的解。\n- **参数选择规则**：差异性原则，该原则规定选择 $\\lambda$ 使得残差范数满足 $\\|A \\theta_{\\lambda} - b\\|_2 \\approx \\tau \\, \\sigma \\, \\sqrt{m}$，其中 $\\tau \\geq 1$ 是一个安全因子。\n- **正向算子定义**：$A_{ij} = \\exp\\left(-\\alpha \\, |i - j|\\right)$ 对于 $i=1, \\dots, m$ 和 $j=1, \\dots, n$。注意，标准数值实现使用从0开始的索引，但函数形式保持不变。\n- **真实参数定义**：$\\theta_{\\text{true},j} = \\sin\\left(\\frac{\\pi j}{n+1}\\right)$ 对于 $j=1, \\dots, n$。\n- **噪声生成**：使用固定的伪随机种子 $12345$。\n- **测试用例**：\n    - 用例 A: $m=30$, $n=10$, $\\alpha=0.35$, $\\sigma=0.02$, $\\tau=1.05$。\n    - 用例 B: $m=30$, $n=10$, $\\alpha=0.35$, $\\sigma=10^{-6}$, $\\tau=1.00$。\n    - 用例 C: $m=30$, $n=10$, $\\alpha=0.35$, $\\sigma=0.20$, $\\tau=1.10$。\n    - 用例 D: $m=25$, $n=12$, $\\alpha=0.50$, $\\sigma=0.03$, $\\tau=1.05$。构建后，$A$ 的最后两列被其倒数第三列的副本替换。\n- **数值要求**：找到 $\\lambda$ 使得残差范数与目标值 $\\tau \\sigma \\sqrt{m}$ 的绝对容差在 $10^{-8}$ 以内。如果对于 $\\lambda \\ge 0$ 目标无法达到，则返回 $\\lambda=0$。\n\n### 步骤2：使用提取的已知条件进行验证\n问题是有效的。\n- 它**具有科学依据**：它探讨了 Tikhonov 正则化，这是一种处理病态逆问题的基石方法，并使用了一个具有物理动机的线性算子。\n- 它是**适定的**：问题任务定义清晰，信息充分，可以得出一个唯一、可计算的解。正则化的使用正是为了使潜在的估计问题变得适定。\n- 它是**客观的**：所有定义都是数学的，所有数据都是定量的。\n- 它是**完整和一致的**：测试套件的所有参数都已提供，并且设置中没有矛盾。\n- 它在**计算上是可行的**，并且不需要无法验证的假设。\n\n### 步骤3：结论与行动\n问题是有效的。将提供完整的解决方案。\n\n### 任务1：差异性原则的推导\n\n目标是为选择正则化参数 $\\lambda$ 推导一个原则性基础。这一选择的基础在于测量噪声的统计特性。\n\n测量模型由下式给出：\n$$\nb = A \\theta_{\\text{true}} + \\varepsilon\n$$\n其中 $\\theta_{\\text{true}}$ 是未知的真实参数向量，$\\varepsilon$ 是噪声向量。与真实参数对应的残差是：\n$$\nr_{\\text{true}} = A \\theta_{\\text{true}} - b = - \\varepsilon\n$$\n这个“理想”残差的欧几里得范数平方是：\n$$\n\\|r_{\\text{true}}\\|_2^2 = \\|-\\varepsilon\\|_2^2 = \\|\\varepsilon\\|_2^2 = \\sum_{i=1}^{m} \\varepsilon_i^2\n$$\n根据问题陈述，噪声分量 $\\varepsilon_i$ 是从正态分布 $\\mathcal{N}(0, \\sigma^2)$ 中独立同分布抽取的。噪声分量平方的期望值是方差定义的直接结果：\n$$\n\\text{Var}(\\varepsilon_i) = E[\\varepsilon_i^2] - (E[\\varepsilon_i])^2\n$$\n由于 $E[\\varepsilon_i]=0$ 和 $\\text{Var}(\\varepsilon_i)=\\sigma^2$，我们有：\n$$\nE[\\varepsilon_i^2] = \\sigma^2\n$$\n根据期望的线性性质，噪声向量范数平方的期望值是：\n$$\nE[\\|\\varepsilon\\|_2^2] = E\\left[\\sum_{i=1}^{m} \\varepsilon_i^2\\right] = \\sum_{i=1}^{m} E[\\varepsilon_i^2] = \\sum_{i=1}^{m} \\sigma^2 = m\\sigma^2\n$$\n对于大量的测量次数 $m$，大数定律表明观测值 $\\|\\varepsilon\\|_2^2$ 将接近其期望值。因此，我们期望：\n$$\n\\|\\varepsilon\\|_2 \\approx \\sqrt{m\\sigma^2} = \\sigma\\sqrt{m}\n$$\n该方法的原则是，一个好的正则化解 $\\theta_{\\lambda}$ 对数据的拟合程度不应“优于”噪声水平。强迫残差范数 $\\|A\\theta - b\\|_2$ 显著小于 $\\sigma\\sqrt{m}$ 将构成对测量值 $b$ 中噪声的过拟合。相反，远大于此的残差表明欠拟合。\n\n因此，一个合理的标准是选择正则化参数 $\\lambda$，使得正则化残差的范数 $\\|A\\theta_{\\lambda} - b\\|_2$ 与我们对噪声范数的期望相匹配。这导出了差异性原则的核心方程：\n$$\n\\|A\\theta_{\\lambda} - b\\|_2 = \\delta\n$$\n其中 $\\delta$ 是对噪声范数 $\\|\\varepsilon\\|_2$ 的估计。一个稳健的选择是将 $\\delta$ 设置得比预期噪声范数稍大，以考虑统计波动、$\\sigma$ 的可能低估以及未建模的误差。这引入了一个安全因子 $\\tau \\ge 1$：\n$$\n\\|A\\theta_{\\lambda} - b\\|_2 = \\tau \\sigma \\sqrt{m}\n$$\n这就完成了当噪声水平 $\\sigma$ 已知时，选择 $\\lambda$ 的差异性原则方法的推导。\n\n### 任务2：算法设计\n\n任务是找到一个值 $\\lambda \\ge 0$，该值解非线性标量方程 $\\|A\\theta_{\\lambda} - b\\|_2 = \\delta$，其中 $\\delta = \\tau \\sigma \\sqrt{m}$。\n\n首先，我们建立正则化解 $\\theta_{\\lambda}$ 的显式表达式。它是 Tikhonov 泛函的最小化子：\n$$\nJ(\\theta) = \\|A \\theta - b\\|_2^2 + \\lambda^2 \\|\\theta\\|_2^2 = (A\\theta - b)^T(A\\theta - b) + \\lambda^2 \\theta^T\\theta\n$$\n为了找到最小值，我们将关于 $\\theta$ 的梯度设为零：\n$$\n\\nabla_{\\theta} J(\\theta) = 2A^T(A\\theta - b) + 2\\lambda^2\\theta = 0\n$$\n$$\nA^TA\\theta - A^Tb + \\lambda^2\\theta = 0\n$$\n这给出了正则化的正规方程：\n$$\n(A^TA + \\lambda^2 I) \\theta = A^T b\n$$\n因此，$\\theta_{\\lambda}$ 的解是：\n$$\n\\theta_{\\lambda} = (A^TA + \\lambda^2 I)^{-1} A^T b\n$$\n让我们定义残差范数函数 $\\phi(\\lambda) = \\|A\\theta_{\\lambda} - b\\|_2$。我们需要解 $\\phi(\\lambda) = \\delta$。可以证明（例如，通过 $A$ 的奇异值分解），对于任何不完全在 $A$ 的左零空间中的 $b$，$\\phi(\\lambda)$ 是一个在 $\\lambda  0$ 上严格递增且连续的函数。这种单调性是设计稳健求根算法的关键。\n\n该问题可以重述为求函数 $g(\\lambda) = \\phi(\\lambda) - \\delta = 0$ 的根。鉴于其单调性，二分法因其稳健性和简单性而成为一个绝佳的选择。\n\n所提出的算法如下：\n\n1.  **定义目标**：计算目标残差范数 $\\delta = \\tau \\sigma \\sqrt{m}$。\n\n2.  **处理边缘情况 ($\\lambda=0$)**：确定最小可能残差范数。这发生在非正则化最小二乘解的情况下，对应于 $\\lambda \\to 0^+$。解 $\\theta_0$ 可通过求解标准正规方程 $A^TA\\theta = A^Tb$ 来找到，或者更稳健地，通过对 $A\\theta \\approx b$ 使用最小二乘求解器（例如，基于 QR 或 SVD 分解）来找到。令最小残差范数为 $\\phi_{\\text{min}} = \\|A\\theta_0 - b\\|_2$。\n    - 如果 $\\delta  \\phi_{\\text{min}}$，则对于任何 $\\lambda \\ge 0$ 目标都是无法实现的。根据问题规范，适当的操作是返回 $\\lambda=0$。\n\n3.  **建立搜索区间**：如果 $\\delta \\ge \\phi_{\\text{min}}$，则存在唯一的解 $\\lambda \\ge 0$。我们需要找到一个区间 $[\\lambda_{\\text{low}}, \\lambda_{\\text{high}}]$ 来包围 $g(\\lambda) = 0$ 的根。\n    - 设置下界 $\\lambda_{\\text{low}} = 0$。我们知道 $g(0) = \\phi_{\\text{min}} - \\delta \\le 0$。\n    - 找到一个上界 $\\lambda_{\\text{high}}$ 使得 $g(\\lambda_{\\text{high}})  0$。当 $\\lambda \\to \\infty$ 时，$\\theta_{\\lambda} \\to 0$，因此 $\\phi(\\lambda) \\to \\|-b\\|_2 = \\|b\\|_2$。因此，仅当 $\\delta  \\|b\\|_2$ 时解才存在。我们可以通过从一个猜测值（例如，$\\lambda_{\\text{high}}=1$）开始，并重复将其加倍直到 $\\phi(\\lambda_{\\text{high}})  \\delta$ 来找到 $\\lambda_{\\text{high}}$。\n\n4.  **二分法**：应用二分法算法在区间 $[\\lambda_{\\text{low}}, \\lambda_{\\text{high}}]$ 内找到 $g(\\lambda)$ 的根。\n    - 迭代足够次数（例如，对于双精度浮点数为 $100$ 次）或直到达到所需容差。\n    - 在每次迭代中：\n        a. 计算中点：$\\lambda_{\\text{mid}} = (\\lambda_{\\text{low}} + \\lambda_{\\text{high}}) / 2$。\n        b. 计算中点处的残差范数 $\\phi(\\lambda_{\\text{mid}})$。这涉及：\n            i.  构建矩阵 $M = A^TA + \\lambda_{\\text{mid}}^2 I$ 和向量 $v = A^T b$。\n            ii. 求解线性系统 $M\\theta = v$ 以获得 $\\theta_{\\lambda_{\\text{mid}}}$。\n            iii. 计算 $\\|A\\theta_{\\lambda_{\\text{mid}}} - b\\|_2$。\n        c. 将残差范数的值与目标进行比较：\n            - 如果 $\\phi(\\lambda_{\\text{mid}})  \\delta$，这意味着 $\\lambda_{\\text{mid}}$ 太小。更新下界：$\\lambda_{\\text{low}} = \\lambda_{\\text{mid}}$。\n            - 如果 $\\phi(\\lambda_{\\text{mid}}) \\ge \\delta$，这意味着 $\\lambda_{\\text{mid}}$ 足够大。更新上界：$\\lambda_{\\text{high}} = \\lambda_{\\text{mid}}$。\n\n5.  **返回结果**：循环终止后，解为 $\\lambda \\approx (\\lambda_{\\text{low}} + \\lambda_{\\text{high}}) / 2$。迭代确保了 $|\\phi(\\lambda) - \\delta|$ 在期望的容差范围内。\n\n该算法仅依赖于基本的线性代数运算（矩阵乘法、求解线性系统），并且由于 $\\phi(\\lambda)$ 的单调性，保证收敛到唯一解。\n\n### 任务3：程序实现\n\n以下 Python 代码实现了指定的测试套件。它遵循上面设计的算法，为每个测试用例构建必要的矩阵和向量，然后应用二分法根据差异性原则找到适当的正则化参数 $\\lambda$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve\n\ndef solve_problem():\n    \"\"\"\n    Solves the inverse heat transfer problem for four test cases.\n    For each case, it constructs the matrices, generates data, and uses a\n    bisection algorithm to find the Tikhonov regularization parameter \\lambda\n    according to the discrepancy principle.\n    \"\"\"\n\n    test_cases = [\n        # Case A (happy path)\n        {'m': 30, 'n': 10, 'alpha': 0.35, 'sigma': 0.02, 'tau': 1.05, 'rank_deficient': False},\n        # Case B (near-noiseless edge case)\n        {'m': 30, 'n': 10, 'alpha': 0.35, 'sigma': 1e-6, 'tau': 1.00, 'rank_deficient': False},\n        # Case C (high-noise edge case)\n        {'m': 30, 'n': 10, 'alpha': 0.35, 'sigma': 0.20, 'tau': 1.10, 'rank_deficient': False},\n        # Case D (rank-deficient forward operator)\n        {'m': 25, 'n': 12, 'alpha': 0.50, 'sigma': 0.03, 'tau': 1.05, 'rank_deficient': True},\n    ]\n\n    results = []\n\n    # Use a single random number generator for reproducibility across all cases\n    # as if they were run in sequence. The problem statement is slightly ambiguous,\n    # but re-seeding for each case is also a valid deterministic interpretation.\n    # This approach (one generator) is more common.\n    rng = np.random.default_rng(12345)\n\n    for case in test_cases:\n        m, n, alpha, sigma, tau = case['m'], case['n'], case['alpha'], case['sigma'], case['tau']\n\n        # 1. Construct the forward operator A\n        # Use 0-based indexing (0..m-1, 0..n-1), which is equivalent to\n        # 1-based indexing for the form |i-j|.\n        i_indices = np.arange(m)[:, np.newaxis]\n        j_indices = np.arange(n)[np.newaxis, :]\n        A = np.exp(-alpha * np.abs(i_indices - j_indices))\n        \n        # Special modification for Case D to induce rank deficiency\n        if case['rank_deficient']:\n            A[:, -2] = A[:, -3]  # Set (n-1)-th column equal to (n-2)-th\n            A[:, -1] = A[:, -3]  # Set n-th column equal to (n-2)-th\n\n        # 2. Construct the ground-truth parameter vector theta_true\n        j_vec = np.arange(1, n + 1)\n        theta_true = np.sin(np.pi * j_vec / (n + 1))\n\n        # 3. Generate the noisy measurement vector b\n        epsilon = rng.normal(loc=0.0, scale=sigma, size=m)\n        b = A @ theta_true + epsilon\n\n        # 4. Define target residual norm based on the discrepancy principle\n        delta_target = tau * sigma * np.sqrt(m)\n        \n        # 5. Implement root-finding algorithm for lambda\n\n        # Helper function to compute the residual norm for a given lambda\n        def calc_residual_norm(lambda_val, A_mat, b_vec):\n            n_dim = A_mat.shape[1]\n            if lambda_val == 0.0:\n                # For lambda=0, use a robust least-squares solver\n                # which handles rank deficiency correctly.\n                theta_sol = np.linalg.lstsq(A_mat, b_vec, rcond=None)[0]\n            else:\n                # For lambda > 0, solve the Tikhonov normal equations\n                lhs = A_mat.T @ A_mat + (lambda_val**2) * np.identity(n_dim)\n                rhs = A_mat.T @ b_vec\n                # Use scipy.linalg.solve as it is robust.\n                theta_sol = solve(lhs, rhs, assume_a='sym')\n            \n            residual = A_mat @ theta_sol - b_vec\n            return np.linalg.norm(residual)\n\n        # Check if the target is achievable\n        min_residual_norm = calc_residual_norm(0.0, A, b)\n        \n        final_lambda = 0.0\n        if delta_target = min_residual_norm:\n            # Target is not achievable for lambda >= 0. Per instructions, return 0.\n            final_lambda = 0.0\n        else:\n            # Use bisection to find the lambda that meets the target residual norm.\n            lambda_low = 0.0\n            \n            # Establish an upper bound for the search\n            lambda_high = 1.0\n            # Check if norm(b) is the upper limit\n            norm_b = np.linalg.norm(b)\n            if delta_target >= norm_b:\n                # The target is at or beyond the asymptotic limit lambda -> inf.\n                # This is unusual. We can't find a finite lambda. However, for\n                # this problem, this branch will not be taken.\n                # For robustness, we could set lambda to a very large number.\n                # But we will rely on the expansion to find a valid bracket.\n                pass\n\n            # Expand search interval until an upper bound is found\n            while calc_residual_norm(lambda_high, A, b)  delta_target:\n                lambda_high *= 2.0\n            \n            # Perform bisection for a fixed number of iterations for precision\n            num_iterations = 100\n            for _ in range(num_iterations):\n                lambda_mid = (lambda_low + lambda_high) / 2.0\n                if lambda_mid == lambda_low or lambda_mid == lambda_high: # Precision limit reached\n                    break\n                \n                current_residual_norm = calc_residual_norm(lambda_mid, A, b)\n                \n                # The problem statement requires tolerance on the residual norm, not lambda.\n                # The bisection naturally converges lambda, and due to monotonicity,\n                # the norm will also converge. 100 iterations on lambda is sufficient.\n                if np.abs(current_residual_norm - delta_target)  1e-8:\n                    break\n                \n                if current_residual_norm  delta_target:\n                    lambda_low = lambda_mid\n                else:\n                    lambda_high = lambda_mid\n            \n            final_lambda = (lambda_low + lambda_high) / 2.0\n\n        results.append(final_lambda)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve_problem()\n```"
        }
    ]
}