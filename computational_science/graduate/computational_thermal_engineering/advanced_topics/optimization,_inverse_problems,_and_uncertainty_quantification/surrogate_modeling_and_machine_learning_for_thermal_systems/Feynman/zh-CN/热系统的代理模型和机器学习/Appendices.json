{
    "hands_on_practices": [
        {
            "introduction": "在开发任何代理模型时，首要步骤是为训练和验证建立一个可靠的“基准真相”(ground truth)。这个练习  将指导您推导一个基本热传导问题的精确解析解。掌握这项技能使您能够为简单系统生成高保真度数据，并为评估代理模型的准确性提供一个坚实的基准。",
            "id": "3988641",
            "problem": "一个一维平板占据空间域 $0 \\le x \\le L$。该平板具有恒定的热导率 $k$，并经历均匀的体积生热 $q$（单位为 $\\mathrm{W/m^3}$）。在稳态下，边界温度由狄利克雷（Dirichlet）条件 $T(0) = T_0$ 和 $T(L) = T_L$ 固定。您的任务是推导精确的稳态温度场 $T(x)$，以作为代理模型训练和验证的基准。\n\n从能量守恒和傅里叶（Fourier）热传导定律出发，求出平板中温度分布 $T(x)$ 作为 $x$、$L$、$k$、$q$、$T_0$ 和 $T_L$ 函数的闭式解析表达式。请提供一个单一的闭式表达式作为最终答案，该表达式适合在代理模型工作流中直接用作基准真相（ground-truth）目标。不要进行任何数值代入。",
            "solution": "问题陈述被解析和验证。\n\n**1. 已知条件提取**\n- 系统：一维平板。\n- 空间域：$0 \\le x \\le L$。\n- 热导率：$k$，假定为常数。\n- 体积生热：$q$，假定为均匀。\n- 系统状态：稳态。\n- 边界条件：$T(0) = T_0$ 和 $T(L) = T_L$。\n\n**2. 问题验证**\n- **科学依据**：该问题基于热传递的基本原理，特别是热扩散方程（热力学第一定律的推论）和傅里叶传导定律。这些是公认的物理定律。\n- **适定性**：该问题描述了一个带有两个指定边界条件（狄利克雷类型）的二阶线性常微分方程。这构成了一个适定的边值问题，其存在唯一且稳定的解。\n- **客观性**：该问题使用物理学和工程学中的精确、标准术语进行陈述。所有参数都已明确定义，没有主观或模糊的语言。\n- **完整性与一致性**：该问题提供了推导唯一解所需的所有必要信息（$k$, $q$, $L$, $T_0$, $T_L$）。所提供的数据或条件中没有矛盾之处。\n\n**结论**：该问题是有效的，因为它具有科学依据、适定、客观且自洽。可以进行解析解的推导。\n\n**3. 温度场 $T(x)$ 的推导**\n推导从通用热扩散方程开始。对于具有内热源的一维系统，该方程为：\n$$ \\frac{\\partial}{\\partial x} \\left( k \\frac{\\partial T}{\\partial x} \\right) + q = \\rho c_p \\frac{\\partial T}{\\partial t} $$\n其中 $T$ 是温度，$k$ 是热导率，$q$ 是体积生热率，$\\rho$ 是密度，$c_p$ 是比热容。\n\n根据问题陈述，系统处于稳态，这意味着所有时间导数均为零：$\\frac{\\partial T}{\\partial t} = 0$。此外，热导率 $k$ 是恒定的。在这些条件下，关于 $x$ 的偏导数变为常导数，热方程简化为：\n$$ k \\frac{d^2 T}{d x^2} + q = 0 $$\n这是一个关于温度分布 $T(x)$ 的二阶常微分方程。我们可以将其重新整理为：\n$$ \\frac{d^2 T}{d x^2} = -\\frac{q}{k} $$\n为了求得温度分布 $T(x)$，我们将此方程对空间坐标 $x$ 积分两次。\n\n第一次积分得到温度梯度 $\\frac{dT}{dx}$：\n$$ \\int \\frac{d^2 T}{d x^2} dx = \\int -\\frac{q}{k} dx $$\n$$ \\frac{dT}{dx} = -\\frac{q}{k}x + C_1 $$\n其中 $C_1$ 是第一个积分常数。\n\n第二次积分得到温度分布 $T(x)$：\n$$ \\int \\frac{dT}{dx} dx = \\int \\left(-\\frac{q}{k}x + C_1\\right) dx $$\n$$ T(x) = -\\frac{q}{2k}x^{2} + C_1 x + C_2 $$\n其中 $C_2$ 是第二个积分常数。\n\n常数 $C_1$ 和 $C_2$ 通过应用指定的边界条件来确定。\n第一个边界条件位于 $x=0$ 处，其中 $T(0) = T_0$。将 $x=0$ 代入通解：\n$$ T(0) = -\\frac{q}{2k}(0)^{2} + C_1(0) + C_2 = T_0 $$\n这直接给出了第二个常数的值：\n$$ C_2 = T_0 $$\n第二个边界条件位于 $x=L$ 处，其中 $T(L) = T_L$。将 $x=L$ 和 $C_2 = T_0$ 代入通解：\n$$ T(L) = -\\frac{q}{2k}L^{2} + C_1 L + T_0 = T_L $$\n现在我们求解此方程以得到第一个常数 $C_1$：\n$$ C_1 L = T_L - T_0 + \\frac{qL^{2}}{2k} $$\n$$ C_1 = \\frac{T_L - T_0}{L} + \\frac{qL}{2k} $$\n既然两个积分常数都已确定，我们将它们代回 $T(x)$ 的通解中：\n$$ T(x) = -\\frac{q}{2k}x^{2} + \\left( \\frac{T_L - T_0}{L} + \\frac{qL}{2k} \\right) x + T_0 $$\n为了以更结构化的形式呈现，我们可以重新整理这些项：\n$$ T(x) = T_0 + (T_L - T_0)\\frac{x}{L} + \\frac{qLx}{2k} - \\frac{qx^{2}}{2k} $$\n对与热生成相关的项进行因式分解，可以得到一个具有物理洞察力的表达式。该解是一个线性温度分布（$q=0$ 时的解）和一个由内部热源引起的抛物线分布的叠加：\n$$ T(x) = T_0 + (T_L - T_0)\\frac{x}{L} + \\frac{q}{2k}(Lx - x^{2}) $$\n这是平板中稳态温度分布作为给定参数函数的最终闭式解析表达式。该表达式在计算热工学中可作为验证代理模型的精确基准真相。",
            "answer": "$$\n\\boxed{T_0 + (T_L - T_0)\\frac{x}{L} + \\frac{q}{2k}(Lx - x^{2})}\n$$"
        },
        {
            "introduction": "当我们拥有生成数据的方法后，便可以着手构建代理模型。径向基函数(Radial Basis Functions, RBF)是在多维空间中对散乱数据进行插值的强大工具。这个实践  为一个散热翅片问题提供了一个完整的、动手操作的RBF代理模型构建流程，您将学习如何生成数据集、标准化输入、使用交叉验证选择超参数，并利用最终模型进行预测。",
            "id": "3988771",
            "problem": "您的任务是使用径向基函数（RBF）构建一个代理模型，以近似从热导率 $k$ 和体积热生成率 $q$ 到直细肋片中峰值温度的映射。该肋片在侧表面和尖端都受到对流换热。该物理系统是一个长度为 $L$ 的一维肋片，具有恒定的横截面积 $A$ 和周长 $P$，由具有恒定热导率 $k$ 和均匀内部体积热生成率 $q$ 的均质材料制成。周围流体处于均匀的环境温度 $T_{\\infty}$，侧表面的对流换热系数为 $h$，尖端的对流换热系数为 $h_{t}$。位于 $x=0$ 处的肋片基部保持在恒定温度 $T_{b}$。肋片的控制性一维稳态能量平衡方程可以从能量守恒和傅里叶热传导定律导出，从而得到一个关于温度场 $T(x)$ 的线性二阶微分方程，并在基部和尖端有相应的边界条件。峰值温度定义为 $\\max_{x \\in [0,L]} T(x)$。\n\n使用以下常数和单位：\n- 肋片长度 $L$ 等于 $0.05$ 米。\n- 横截面积 $A$ 等于 $1\\times 10^{-4}$ 平方米。\n- 周长 $P$ 等于 $0.04$ 米。\n- 侧表面对流系数 $h$ 等于 $50$ 瓦/平方米-开尔文。\n- 尖端对流系数 $h_{t}$ 等于 $50$ 瓦/平方米-开尔文。\n- 基部温度 $T_{b}$ 等于 $350$ 开尔文。\n- 环境温度 $T_{\\infty}$ 等于 $300$ 开尔文。\n\n所有温度必须以开尔文表示。如果在数学操作中出现任何角度，都必须以弧度表示。\n\n根据第一性原理，程序必须：\n1. 实现一个函数，对于给定的输入 $(k,q)$，通过求解稳态能量守恒所隐含的一维肋片边值问题，返回峰值温度 $\\max_{x \\in [0,L]} T(x)$。该问题考虑了沿周长和尖端的对流。此方法应仅使用上述基本定义和边界条件，通过算法从控制方程和边界条件推导出来，而不调用或假设任何预先提供的公式。\n2. 通过组合集合 $k \\in \\{20,60,120,200\\}$ 瓦/米-开尔文 和 $q \\in \\{0,2.5\\times 10^{5},5.0\\times 10^{5},1.0\\times 10^{6}\\}$ 瓦/立方米 中的所有配对，生成一个大小为 $N$ 等于 $16$ 的训练数据集。对于每个配对，使用第 1 项中的函数计算相应的峰值温度。\n3. 使用高斯核 $\\phi(r) = \\exp\\!\\big(-(\\varepsilon\\, r)^{2}\\big)$ 构建一个 RBF 代理模型，其中 $r$ 是 $(k,q)$ 空间中的欧几里得距离，$\\varepsilon$ 是正的形状参数。在计算距离之前，通过减去样本均值并除以根据训练数据集计算出的样本标准差，对每个输入特征 $k$ 和 $q$ 进行标准化。通过求解 RBF 权重的线性系统来构建插值器，以使代理模型在训练点上与训练值完全匹配。\n4. 使用留一法交叉验证（LOOCV）从候选集 $\\{0.2,0.5,1.0,2.0,3.0,5.0,10.0\\}$ 中选择形状参数 $\\varepsilon$。对于每个候选 $\\varepsilon$，计算在 $N$ 等于 $16$ 个训练点上的均方 LOOCV 误差，并选择使该误差最小的 $\\varepsilon$。\n5. 使用选定的形状参数，对以下五个 $(k,q)$ 测试案例评估代理模型：\n   - 案例 1：$k$ 等于 $120$，$q$ 等于 $5.0\\times 10^{5}$。\n   - 案例 2：$k$ 等于 $80$，$q$ 等于 $0$。\n   - 案例 3：$k$ 等于 $20$，$q$ 等于 $1.0\\times 10^{6}$。\n   - 案例 4：$k$ 等于 $200$，$q$ 等于 $1.0\\times 10^{6}$。\n   - 案例 5：$k$ 等于 $60$，$q$ 等于 $2.5\\times 10^{5}$。\n   报告这些案例的代理模型预测的峰值温度（单位为开尔文）。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，具体为：$[\\varepsilon_{\\text{opt}},T_{1},T_{2},T_{3},T_{4},T_{5}]$，其中 $\\varepsilon_{\\text{opt}}$ 是选定的形状参数（无单位），$T_{i}$ 是上述测试案例的代理模型预测的峰值温度（单位为开尔文）。输出中的所有数值条目必须是浮点数。",
            "solution": "该问题要求构建并验证一个径向基函数（RBF）代理模型，以预测一维肋片中的峰值温度。该过程包括几个步骤：推导肋片温度分布的解析解，使用此解析解生成训练数据集，使用留一法交叉验证（LOOCV）优化 RBF 形状参数，最后，对一组测试案例预测峰值温度。\n\n### 步骤 1：肋片温度的解析模型\n\n第一步是推导沿肋片的温度分布 $T(x)$。我们考虑肋片上位于位置 $x$ 处、长度为 $dx$ 的微分单元上的一维稳态能量平衡。肋片具有恒定的横截面积 $A$、周长 $P$ 和热导率 $k$。它与环境温度为 $T_{\\infty}$ 的流体进行对流换热，换热系数为 $h$，并具有均匀的体积热生成率 $q$。\n\n能量平衡方程为：\n$$q_{cond, x} + q_{gen} = q_{cond, x+dx} + q_{conv}$$\n使用傅里叶热传导定律 $q_{cond} = -kA \\frac{dT}{dx}$、牛顿冷却定律进行对流换热 $q_{conv} = h(Pdx)(T-T_{\\infty})$，并考虑内部热生成 $q_{gen} = q(Adx)$，我们得到：\n$$-kA \\frac{dT}{dx}\\bigg|_x + qAdx = -kA \\frac{dT}{dx}\\bigg|_{x+dx} + hP(T(x)-T_{\\infty})dx$$\n使用泰勒级数展开在 $x+dx$ 处的项并简化，我们得到控制性二阶常微分方程（ODE）：\n$$k \\frac{d^2T}{dx^2} - \\frac{hP}{A}(T-T_{\\infty}) + q = 0$$\n为简化起见，我们引入超温 $\\theta(x) = T(x) - T_{\\infty}$。ODE 变为：\n$$\\frac{d^2\\theta}{dx^2} - m^2\\theta = -S$$\n其中 $m = \\sqrt{\\frac{hP}{kA}}$ 是肋片参数，而 $S = \\frac{q}{k}$ 与源项有关。\n\n这是一个线性、非齐次、二阶 ODE。通解是齐次解 $\\theta_h(x)$ 和特解 $\\theta_p(x)$ 的和。齐次方程 $\\theta'' - m^2\\theta=0$ 的解为 $\\theta_h(x) = C_1 \\cosh(mx) + C_2 \\sinh(mx)$。对于常数源项 $-S$，假设一个常数特解 $\\theta_p(x) = C$。代入 ODE 得到 $-m^2C = -S$，所以 $C = \\frac{S}{m^2} = \\frac{q/k}{hP/kA} = \\frac{qA}{hP}$。我们将此项表示为 $\\theta_s = \\frac{qA}{hP}$。\n\n超温的通解是：\n$$\\theta(x) = C_1 \\cosh(mx) + C_2 \\sinh(mx) + \\theta_s$$\n常数 $C_1$ 和 $C_2$ 由边界条件确定。\n\n**边界条件：**\n1.  在肋片基部（$x=0$）：温度固定为 $T_b$。\n    $$T(0) = T_b \\implies \\theta(0) = T_b - T_{\\infty} \\equiv \\theta_b$$\n    应用此条件，我们得到 $\\theta_b = C_1 \\cosh(0) + C_2 \\sinh(0) + \\theta_s = C_1 + \\theta_s$。\n    因此，$C_1 = \\theta_b - \\theta_s$。\n\n2.  在肋片尖端（$x=L$）：发生对流，系数为 $h_t$。尖端的能量平衡要求传入尖端的传导热量等于从尖端表面流出的对流热量。\n    $$-kA\\frac{dT}{dx}\\bigg|_{x=L} = h_t A (T(L)-T_{\\infty})$$\n    用 $\\theta$ 表示，即为 $-k\\frac{d\\theta}{dx}\\bigg|_{x=L} = h_t \\theta(L)$。\n    导数为 $\\frac{d\\theta}{dx} = mC_1 \\sinh(mx) + mC_2 \\cosh(mx)$。在 $x=L$ 处求值并代入边界条件，得到：\n    $$-k(mC_1 \\sinh(mL) + mC_2 \\cosh(mL)) = h_t(C_1 \\cosh(mL) + C_2 \\sinh(mL) + \\theta_s)$$\n    重新整理以求解 $C_2$：\n    $$C_2 (h_t \\sinh(mL) + km \\cosh(mL)) = -C_1(h_t \\cosh(mL) + km \\sinh(mL)) - h_t \\theta_s$$\n    $$C_2 = -\\frac{C_1(h_t \\cosh(mL) + km \\sinh(mL)) + h_t \\theta_s}{h_t \\sinh(mL) + km \\cosh(mL)}$$\n利用已知的参数 $(k, q)$，我们可以计算出 $m$、$\\theta_s$、$C_1$ 和 $C_2$，从而完全定义温度分布 $T(x) = T_{\\infty} + \\theta(x)$。\n\n### 步骤 2：峰值温度计算\n\n峰值温度是 $\\max_{x \\in [0,L]} T(x)$。最大值可能出现在边界（$x=0$ 或 $x=L$）或内部点 $x_c \\in (0,L)$，在该点处 $\\frac{dT}{dx}(x_c) = \\frac{d\\theta}{dx}(x_c) = 0$。\n内部极值的条件是：\n$$mC_1 \\sinh(mx_c) + mC_2 \\cosh(mx_c) = 0 \\implies \\tanh(mx_c) = -\\frac{C_2}{C_1}$$\n当且仅当 $|-C_2/C_1|  1$ 时，$x_c$ 存在实数解。如果 $\\frac{d^2\\theta}{dx^2}(x_c)  0$，则极值为最大值。可以证明，只有当 $C_1  0$ 时，此条件才成立。\n对于给定的问题参数，$C_1 = \\theta_b - \\theta_s = (T_b - T_{\\infty}) - \\frac{qA}{hP} = 50 - q(5 \\times 10^{-5})$。为了可能出现内部最大值（$C_1  0$），我们需要 $q > 1 \\times 10^6$ W/m$^3$。由于数据集中的最大 $q$ 值为 $1 \\times 10^6$ W/m$^3$（此时 $C_1=0$），并且在所有其他情况下 $q  1 \\times 10^6$ W/m$^3$（此时 $C_1 > 0$），因此在任何指定场景下都不会出现内部最大值。\n因此，峰值温度必须出现在区域的边界上。峰值温度由下式给出：\n$$T_{peak} = \\max(T(0), T(L)) = \\max(T_b, T(L))$$\n其中 $T(L) = T_{\\infty} + C_1 \\cosh(mL) + C_2 \\sinh(mL) + \\theta_s$。这提供了一个确定性函数，用于计算任何输入对 $(k, q)$ 的峰值温度。\n\n### 步骤 3：RBF 代理模型\n\n我们建立一个 RBF 代理模型来近似映射 $(k, q) \\mapsto T_{peak}$。\n\n**训练数据：** 通过取 $k \\in \\{20,60,120,200\\}$ 和 $q \\in \\{0,2.5\\times 10^{5},5.0\\times 10^{5},1.0\\times 10^{6}\\}$ 的所有组合，生成一个包含 $N=16$ 个点的训练集。对于每一对 $(k_i, q_i)$，使用解析模型计算相应的峰值温度 $y_i = T_{peak}(k_i, q_i)$。\n\n**特征标准化：** 将输入特征 $(k, q)$ 进行标准化，使其均值为零，方差为一。从 16 个训练点计算样本均值 $(\\mu_k, \\mu_q)$ 和标准差 $(\\sigma_k, \\sigma_q)$。标准化的输入为 $\\mathbf{x}'_i = (k'_i, q'_i)$，其中 $k'_i = (k_i - \\mu_k)/\\sigma_k$，$q'_i = (q_i - \\mu_q)/\\sigma_q$。\n\n**RBF 插值：** RBF 代理模型的形式为 $f(\\mathbf{x}') = \\sum_{j=1}^{N} w_j \\phi(\\|\\mathbf{x}' - \\mathbf{x}'_j\\|)$，其中 $\\mathbf{x}'_j$ 是标准化的训练输入，$w_j$ 是权重，$\\phi(r)$ 是高斯核 $\\phi(r) = \\exp(-(\\varepsilon r)^2)$。距离 $r$ 是标准化空间中的欧几里得距离。权重 $\\mathbf{w} = [w_1, \\dots, w_N]^T$ 通过求解线性系统 $\\mathbf{\\Phi}\\mathbf{w} = \\mathbf{y}$ 得到，其中 $\\mathbf{y} = [y_1, \\dots, y_N]^T$ 是训练输出的向量，$\\mathbf{\\Phi}$ 是 $N \\times N$ 的插值矩阵，其元素为 $\\Phi_{ij} = \\phi(\\|\\mathbf{x}'_i - \\mathbf{x}'_j\\|)$。\n\n### 步骤 4：通过 LOOCV 优化形状参数\n\n形状参数 $\\varepsilon$ 从集合 $\\{0.2,0.5,1.0,2.0,3.0,5.0,10.0\\}$ 中通过最小化 LOOCV 的均方误差来选择。对于给定的 $\\varepsilon$，第 $i$ 个点的 LOOCV 预测误差可以高效计算，而无需重新训练模型 $N$ 次。该误差由下式给出：\n$$e_i = y_i - f_{(-i)}(\\mathbf{x}_i) = \\frac{w_i}{(\\mathbf{\\Phi}^{-1})_{ii}}$$\n其中 $f_{(-i)}$ 是在除第 $i$ 个点之外的所有数据上训练的模型，$\\mathbf{w} = \\mathbf{\\Phi}^{-1}\\mathbf{y}$，$(\\mathbf{\\Phi}^{-1})_{ii}$ 是插值矩阵逆的第 $i$ 个对角元素。均方 LOOCV 误差为 $MSE_{LOOCV} = \\frac{1}{N}\\sum_{i=1}^N e_i^2$。我们为每个候选 $\\varepsilon$ 计算此值，并选择产生最小 $MSE_{LOOCV}$ 的那个。\n\n### 步骤 5：预测\n\n使用最优形状参数 $\\varepsilon_{opt}$，利用所有 $N=16$ 个训练点构建最终的 RBF 模型。确定最终的权重 $\\mathbf{w}_{final}$。要为一个新的测试点 $(k_{test}, q_{test})$ 预测峰值温度，首先使用训练集的 $\\mu_k, \\sigma_k, \\mu_q, \\sigma_q$ 对该点进行标准化，得到 $\\mathbf{x}'_{test}$。然后按如下方式计算预测值：\n$$T_{pred} = f(\\mathbf{x}'_{test}) = \\sum_{j=1}^{N} w_{final, j} \\exp\\left(-(\\varepsilon_{opt} \\|\\mathbf{x}'_{test} - \\mathbf{x}'_j\\|)^2\\right)$$\n此过程应用于五个指定的测试案例。对于同时也是训练点的测试案例，RBF 插值器将精确地再现由解析模型计算的值，这是此方法的一个关键属性。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and evaluates an RBF surrogate model for fin peak temperature.\n    \"\"\"\n    # Physical constants\n    L = 0.05       # Fin length (m)\n    A = 1.0e-4     # Cross-sectional area (m^2)\n    P = 0.04       # Perimeter (m)\n    h = 50.0       # Convection coefficient (W/m^2-K)\n    h_t = 50.0     # Tip convection coefficient (W/m^2-K)\n    T_b = 350.0    # Base temperature (K)\n    T_inf = 300.0  # Ambient temperature (K)\n    theta_b = T_b - T_inf\n\n    def get_peak_temperature(k, q):\n        \"\"\"\n        Calculates the peak temperature of the fin for given k and q.\n        \"\"\"\n        # Handle k=0 case to avoid division by zero\n        if k == 0:\n            return np.nan\n\n        # Calculate intermediate parameters\n        m_squared = (h * P) / (k * A)\n        m = np.sqrt(m_squared)\n        theta_s = (q * A) / (h * P)\n\n        # Determine integration constants C1 and C2\n        C1 = theta_b - theta_s\n\n        # Avoid issues with large mL by using np.exp\n        mL = m * L\n        cosh_mL = np.cosh(mL)\n        sinh_mL = np.sinh(mL)\n\n        # Numerator and denominator for C2 calculation\n        num_C2 = -C1 * (h_t * cosh_mL + k * m * sinh_mL) - h_t * theta_s\n        den_C2 = h_t * sinh_mL + k * m * cosh_mL\n        C2 = num_C2 / den_C2\n\n        # The analytical solution indicates that for the given q range,\n        # no interior maximum exists. The peak is at the boundary.\n        # So, we only need to check T(L).\n\n        # Temperature at the tip (x=L)\n        theta_L = C1 * cosh_mL + C2 * sinh_mL + theta_s\n        T_L = T_inf + theta_L\n\n        # Peak temperature is max of base and tip temperatures\n        return max(T_b, T_L)\n\n    # 1. Generate training dataset\n    k_vals = np.array([20.0, 60.0, 120.0, 200.0])\n    q_vals = np.array([0.0, 2.5e5, 5.0e5, 1.0e6])\n    N = len(k_vals) * len(q_vals)\n\n    X_train = np.array(np.meshgrid(k_vals, q_vals)).T.reshape(-1, 2)\n    y_train = np.array([get_peak_temperature(k, q) for k, q in X_train])\n\n    # 2. Standardize input features\n    mu = np.mean(X_train, axis=0)\n    sigma = np.std(X_train, axis=0)\n    X_train_std = (X_train - mu) / sigma\n\n    # 3. Select shape parameter epsilon via LOOCV\n    epsilons = [0.2, 0.5, 1.0, 2.0, 3.0, 5.0, 10.0]\n    best_eps = None\n    min_mse = float('inf')\n\n    # Distance matrix for standardized training points\n    dist_matrix = np.sqrt(((X_train_std[:, np.newaxis, :] - X_train_std[np.newaxis, :, :])**2).sum(axis=2))\n    \n    for eps in epsilons:\n        # Construct interpolation matrix Phi\n        Phi = np.exp(-(eps * dist_matrix)**2)\n\n        # Solve for weights and calculate LOOCV error\n        try:\n            # Using solve is more stable but inv is needed for the efficient LOOCV formula\n            inv_Phi = np.linalg.inv(Phi)\n            weights = inv_Phi @ y_train\n            loocv_errors = weights / np.diag(inv_Phi)\n            mse = np.mean(loocv_errors**2)\n\n            if mse  min_mse:\n                min_mse = mse\n                best_eps = eps\n        except np.linalg.LinAlgError:\n            # In case of singularity, skip this epsilon\n            continue\n    \n    eps_opt = best_eps\n\n    # 4. Build final RBF model with optimal epsilon\n    final_dist_matrix = np.sqrt(((X_train_std[:, np.newaxis, :] - X_train_std[np.newaxis, :, :])**2).sum(axis=2))\n    final_Phi = np.exp(-(eps_opt * final_dist_matrix)**2)\n    final_weights = np.linalg.solve(final_Phi, y_train)\n\n    # 5. Evaluate surrogate at test cases\n    test_cases = [\n        (120.0, 5.0e5),\n        (80.0, 0.0),\n        (20.0, 1.0e6),\n        (200.0, 1.0e6),\n        (60.0, 2.5e5),\n    ]\n    \n    test_predictions = []\n    for k_test, q_test in test_cases:\n        x_test = np.array([k_test, q_test])\n        x_test_std = (x_test - mu) / sigma\n        \n        # Calculate distances from test point to all training points\n        dists = np.sqrt(np.sum((X_train_std - x_test_std)**2, axis=1))\n        \n        # Calculate kernel values\n        kernel_vals = np.exp(-(eps_opt * dists)**2)\n        \n        # Make prediction\n        T_pred = np.sum(final_weights * kernel_vals)\n        test_predictions.append(T_pred)\n\n    # Format the final output\n    results = [eps_opt] + test_predictions\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个在训练数据上表现准确的代理模型是不够的，它还必须在物理上是合理的。这最后一个练习  介绍了一个关键的验证步骤：检验模型的物理一致性。您将通过实施一种数值方法，来验证您的代理模型是否遵循基本的物理定律，例如单调性，从而确保其预测结果的可靠性和可信度。",
            "id": "3988673",
            "problem": "给定一个预先训练好的代理函数，该函数将一个热物理参数的输入向量映射到一个预测的稳态单位面积导热热通量。将该代理函数记为 $\\hat{q}:\\mathbb{R}^6\\rightarrow\\mathbb{R}$，其输入向量为 $\\mathbf{x}=\\left(T_h,T_c,L_1,k_1,L_2,k_2\\right)$，其中 $T_h$ 是热侧温度（单位：$\\mathrm{K}$），$T_c$ 是冷侧温度（单位：$\\mathrm{K}$），$L_1$ 和 $L_2$ 是层厚度（单位：$\\mathrm{m}$），$k_1$ 和 $k_2$ 是热导率（单位：$\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$）。基于傅里叶热传导定律和串联热阻结构，物理上一致的单调性期望如下：\n- $\\frac{\\partial \\hat{q}}{\\partial T_h}\\ge 0$,\n- $\\frac{\\partial \\hat{q}}{\\partial T_c}\\le 0$,\n- $\\frac{\\partial \\hat{q}}{\\partial L_1}\\le 0$,\n- $\\frac{\\partial \\hat{q}}{\\partial k_1}\\ge 0$,\n- $\\frac{\\partial \\hat{q}}{\\partial L_2}\\le 0$,\n- $\\frac{\\partial \\hat{q}}{\\partial k_2}\\ge 0$.\n\n你的任务是实现一个针对训练好的代理函数输出的数值单调性测试，方法是通过中心有限差分计算经验梯度，并在抽样输入上验证其符号约束。使用中心有限差分近似来计算在 $\\mathbf{x}$ 处的第 $j$ 个偏导数，\n$$\n\\frac{\\partial \\hat{q}}{\\partial x_j}(\\mathbf{x})\\approx \\frac{\\hat{q}\\!\\left(\\mathbf{x}+h_j\\mathbf{e}_j\\right)-\\hat{q}\\!\\left(\\mathbf{x}-h_j\\mathbf{e}_j\\right)}{2h_j},\n$$\n其中 $\\mathbf{e}_j$ 是第 $j$ 个坐标单位向量，$h_j0$ 是 $x_j$ 的扰动幅度。根据 $h_j=\\max\\!\\left(\\epsilon_j, s\\,|x_j|\\right)$ 来选择 $h_j$，其中 $s$ 是一个无量纲步长分数，$\\epsilon_j$ 是一个与变量相关的最小步长，用于限制舍入敏感性。使用以下最小步长：$\\epsilon_{T_h}=\\epsilon_{T_c}=10^{-6}\\,\\mathrm{K}$，$\\epsilon_{L_1}=\\epsilon_{L_2}=10^{-9}\\,\\mathrm{m}$，以及 $\\epsilon_{k_1}=\\epsilon_{k_2}=10^{-9}\\,\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$。如果一个符号约束在绝对容差 $\\tau0$ 内成立，则视为满足。即，对于期望为非负的导数，接受 $\\frac{\\partial \\hat{q}}{\\partial x_j}\\ge -\\tau$；对于期望为非正的导数，接受 $\\frac{\\partial \\hat{q}}{\\partial x_j}\\le \\tau$。\n\n输入的抽样应在指定的物理上合理的范围内呈独立同分布（i.i.d.）的均匀分布。对于下文的每个测试用例，在其定义域内抽取 $N$ 个样本 $\\mathbf{x}^{(i)}$，计算经验梯度，并在每个样本上验证所有六个符号约束。一个测试用例通过的条件是，当且仅当所有六个约束对所有 $N$ 个样本都得到满足。\n\n所有温度以 $\\mathrm{K}$ 表示，长度以 $\\mathrm{m}$ 表示，热导率以 $\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$ 表示，代理热通量以 $\\mathrm{W}\\,\\mathrm{m}^{-2}$ 表示。本问题不涉及角度。程序的最终输出必须是一行，包含一个用方括号括起来的逗号分隔列表，每个测试用例对应一个布尔值（$\\mathrm{True}$ 或 $\\mathrm{False}$）以指示通过或失败，顺序如下文所示，例如 $\\left[\\mathrm{True},\\mathrm{False},\\mathrm{True},\\mathrm{True}\\right]$。\n\n使用以下测试套件，其设计旨在覆盖典型条件、边界状态和近简并情况：\n\n- 测试用例 1（典型建筑围护结构体系）：\n  - $N=200$，$s=10^{-4}$，$\\tau=10^{-9}$。\n  - 范围：$T_h\\in[310,350]\\,\\mathrm{K}$，$T_c\\in[280,300]\\,\\mathrm{K}$，$L_1\\in[0.01,0.05]\\,\\mathrm{m}$，$k_1\\in[0.2,0.8]\\,\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$，$L_2\\in[0.01,0.05]\\,\\mathrm{m}$，$k_2\\in[10,50]\\,\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$。\n  - 随机种子：$12345$。\n\n- 测试用例 2（接近极限的薄高导热层）：\n  - $N=200$，$s=10^{-6}$，$\\tau=10^{-9}$。\n  - 范围：$T_h\\in[330,360]\\,\\mathrm{K}$，$T_c\\in[290,300]\\,\\mathrm{K}$，$L_1\\in[10^{-4},10^{-3}]\\,\\mathrm{m}$，$k_1\\in[100,400]\\,\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$，$L_2\\in[10^{-4},10^{-3}]\\,\\mathrm{m}$，$k_2\\in[100,400]\\,\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$。\n  - 随机种子：$54321$。\n\n- 测试用例 3（驱动温差小的近等温边界）：\n  - $N=200$，$s=10^{-4}$，$\\tau=10^{-9}$。\n  - 范围：$T_h\\in[300.1,300.5]\\,\\mathrm{K}$，$T_c\\in[299.6,300.0]\\,\\mathrm{K}$，$L_1\\in[0.01,0.02]\\,\\mathrm{m}$，$k_1\\in[0.2,0.5]\\,\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$，$L_2\\in[0.01,0.02]\\,\\mathrm{m}$，$k_2\\in[5,10]\\,\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$。\n  - 随机种子：$11111$。\n\n- 测试用例 4（低热导率层主导总热阻）：\n  - $N=200$，$s=10^{-4}$，$\\tau=10^{-9}$。\n  - 范围：$T_h\\in[315,335]\\,\\mathrm{K}$，$T_c\\in[285,295]\\,\\mathrm{K}$，$L_1\\in[0.02,0.04]\\,\\mathrm{m}$，$k_1\\in[0.02,0.05]\\,\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$，$L_2\\in[0.01,0.03]\\,\\mathrm{m}$，$k_2\\in[0.5,1.5]\\,\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$。\n  - 随机种子：$22222$。\n\n你的程序必须为每个测试用例的抽样输入实现经验梯度计算和单调性验证，并按照上文描述的精确单行格式 $\\left[\\mathrm{result}_1,\\mathrm{result}_2,\\mathrm{result}_3,\\mathrm{result}_4\\right]$ 生成最终的布尔结果。",
            "solution": "该问题是有效的。它在计算热工领域提出了一个清晰、有科学依据且适定的任务，特别涉及到代理模型的验证与确认。问题的核心是实现一个数值程序，用以测试模拟稳态热通量的代理函数 $\\hat{q}$ 的物理单调性。\n\n尽管问题陈述提到了一个“预先训练好的代理函数”$\\hat{q}$，但并未提供其显式形式，唯一合乎逻辑且可解的解释是为任何有效代理模型都必须逼近的底层物理模型实现该测试。该问题涉及通过两个串联层的一维稳态热传导。根据傅里叶定律推导出的单位面积热通量 $q$ 的解析解为：\n$$q(\\mathbf{x}) = \\frac{T_h - T_c}{\\frac{L_1}{k_1} + \\frac{L_2}{k_2}}$$\n其中输入向量为 $\\mathbf{x}=\\left(T_h,T_c,L_1,k_1,L_2,k_2\\right)$。单位面积的总热阻为 $R_{\\text{th}} = \\frac{L_1}{k_1} + \\frac{L_2}{k_2}$。因此，$q = (T_h - T_c) / R_{\\text{th}}$。在测试的实现中，我们将使用这个解析表达式作为 $\\hat{q}$。\n\n首先，我们通过解析方式验证问题中指定的单调性约束对于此模型是物理上正确的。物理参数 $L_1, k_1, L_2, k_2$ 均为正值，且指定的抽样范围确保 $T_h > T_c$。\n\n1.  关于 $T_h$ 的导数：\n    $$\\frac{\\partial q}{\\partial T_h} = \\frac{1}{\\frac{L_1}{k_1} + \\frac{L_2}{k_2}} = \\frac{1}{R_{\\text{th}}}$$\n    由于 $R_{\\text{th}} > 0$，我们有 $\\frac{\\partial q}{\\partial T_h} > 0$，这与期望 $\\frac{\\partial \\hat{q}}{\\partial T_h} \\ge 0$ 一致。\n\n2.  关于 $T_c$ 的导数：\n    $$\\frac{\\partial q}{\\partial T_c} = \\frac{-1}{\\frac{L_1}{k_1} + \\frac{L_2}{k_2}} = -\\frac{1}{R_{\\text{th}}}$$\n    该值恒为负，与 $\\frac{\\partial \\hat{q}}{\\partial T_c} \\le 0$ 一致。\n\n3.  关于 $L_1$ 的导数：\n    $$\\frac{\\partial q}{\\partial L_1} = (T_h - T_c) \\cdot \\left( -1 \\cdot \\left(\\frac{L_1}{k_1} + \\frac{L_2}{k_2}\\right)^{-2} \\cdot \\frac{1}{k_1} \\right) = -\\frac{T_h - T_c}{k_1 R_{\\text{th}}^2}$$\n    由于 $T_h - T_c > 0$ 且 $k_1 > 0$，我们有 $\\frac{\\partial q}{\\partial L_1}  0$，与 $\\frac{\\partial \\hat{q}}{\\partial L_1} \\le 0$ 一致。\n\n4.  关于 $k_1$ 的导数：\n    $$\\frac{\\partial q}{\\partial k_1} = (T_h - T_c) \\cdot \\left( -1 \\cdot \\left(\\frac{L_1}{k_1} + \\frac{L_2}{k_2}\\right)^{-2} \\cdot \\left(-\\frac{L_1}{k_1^2}\\right) \\right) = \\frac{(T_h - T_c) L_1}{k_1^2 R_{\\text{th}}^2}$$\n    由于 $T_h - T_c > 0$ 且 $L_1 > 0$，我们有 $\\frac{\\partial q}{\\partial k_1} > 0$，与 $\\frac{\\partial \\hat{q}}{\\partial k_1} \\ge 0$ 一致。\n\n5.  关于 $L_2$ 和 $k_2$ 的导数：根据对称性，其结果与 $L_1$ 和 $k_1$ 的结果类似。\n    $$\\frac{\\partial q}{\\partial L_2} = -\\frac{T_h - T_c}{k_2 R_{\\text{th}}^2}  0, \\quad \\text{与 } \\frac{\\partial \\hat{q}}{\\partial L_2} \\le 0 \\text{ 一致}$$\n    $$\\frac{\\partial q}{\\partial k_2} = \\frac{(T_h - T_c) L_2}{k_2^2 R_{\\text{th}}^2} > 0, \\quad \\text{与 } \\frac{\\partial \\hat{q}}{\\partial k_2} \\ge 0 \\text{ 一致}$$\n所有指定的单调性约束都是正确的。\n\n该解决方案实现了以下算法：\n1.  一个主程序遍历问题描述中定义的 4 个测试用例。对每个用例，计算一个布尔结果。\n2.  对于给定的测试用例，使用指定的值为随机数生成器设定种子，以确保可复现性。\n3.  一个循环运行 N 次迭代。在每次迭代中，通过从其指定范围独立均匀地抽取每个分量来采样一个 6 维输入向量 $\\mathbf{x}^{(i)}$。\n4.  对于每个样本 $\\mathbf{x}^{(i)}$，算法遍历其从 $j=0$ 到 $j=5$ 的 6 个分量。\n5.  在每个内循环迭代中，使用中心有限差分公式近似计算偏导数 $\\frac{\\partial \\hat{q}}{\\partial x_j}$：\n    $$\\frac{\\partial \\hat{q}}{\\partial x_j}(\\mathbf{x}) \\approx \\frac{\\hat{q}(\\mathbf{x}+h_j\\mathbf{e}_j) - \\hat{q}(\\mathbf{x}-h_j\\mathbf{e}_j)}{2h_j}$$\n    扰动大小 $h_j$ 对每个变量 $x_j$ 均根据规则 $h_j=\\max(\\epsilon_j, s |x_j|)$ 确定，使用特定于用例的步长分数 $s$ 和全局定义的最小步长 $\\epsilon_j$。\n6.  然后将计算出的数值梯度与其预期符号进行核对。该核对包含绝对容差 $\\tau$。令 $g_j$ 为变量 $x_j$ 计算出的梯度。\n    - 如果期望导数为非负（$\\ge 0$），则当 $g_j  -\\tau$ 时，约束被违反。\n    - 如果期望导数为非正（$\\le 0$），则当 $g_j > \\tau$ 时，约束被违反。\n7.  如果在任何采样点上任何变量的约束被违反，该测试用例立即被标记为失败（`False`），算法继续处理下一个测试用例。\n8.  如果所有 6 个约束对所有 $N$ 个样本都满足，则该测试用例被标记为通过（`True`）。\n9.  最后，将所有测试用例的布尔结果列表按规定格式化并打印到标准输出。\n\n由于解析函数是完全单调的，预计数值测试将在所有情况下通过，从而得到输出 `[True,True,True,True]`。任何偏差都将表明存在一个区域，其中数值微分方法因精度或稳定性问题而失败，而这正是本测试旨在探查的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a numerical monotonicity test for a surrogate model of heat flux.\n    The surrogate is represented by the ideal physical model for 1D steady-state\n    heat conduction through two layers.\n    \"\"\"\n    \n    def q_surrogate(x: np.ndarray) -> float:\n        \"\"\"\n        Calculates the heat flux based on the analytical model.\n        x = [T_h, T_c, L_1, k_1, L_2, k_2]\n        \"\"\"\n        Th, Tc, L1, k1, L2, k2 = x\n        # The problem's constraints on L_i and k_i ensure the denominator is positive.\n        resistance = L1 / k1 + L2 / k2\n        return (Th - Tc) / resistance\n\n    test_cases = [\n        # Test Case 1 (typical building envelope regime)\n        {\n            'N': 200, 's': 1e-4, 'tau': 1e-9, 'seed': 12345,\n            'ranges': [\n                (310.0, 350.0),  # T_h [K]\n                (280.0, 300.0),  # T_c [K]\n                (0.01, 0.05),    # L_1 [m]\n                (0.2, 0.8),      # k_1 [W/mK]\n                (0.01, 0.05),    # L_2 [m]\n                (10.0, 50.0)     # k_2 [W/mK]\n            ]\n        },\n        # Test Case 2 (thin, highly conductive layers near the limit)\n        {\n            'N': 200, 's': 1e-6, 'tau': 1e-9, 'seed': 54321,\n            'ranges': [\n                (330.0, 360.0),  # T_h [K]\n                (290.0, 300.0),  # T_c [K]\n                (1e-4, 1e-3),    # L_1 [m]\n                (100.0, 400.0),  # k_1 [W/mK]\n                (1e-4, 1e-3),    # L_2 [m]\n                (100.0, 400.0)   # k_2 [W/mK]\n            ]\n        },\n        # Test Case 3 (near-isothermal boundary with small driving temperature difference)\n        {\n            'N': 200, 's': 1e-4, 'tau': 1e-9, 'seed': 11111,\n            'ranges': [\n                (300.1, 300.5),  # T_h [K]\n                (299.6, 300.0),  # T_c [K]\n                (0.01, 0.02),    # L_1 [m]\n                (0.2, 0.5),      # k_1 [W/mK]\n                (0.01, 0.02),    # L_2 [m]\n                (5.0, 10.0)      # k_2 [W/mK]\n            ]\n        },\n        # Test Case 4 (low-conductivity layer dominating overall resistance)\n        {\n            'N': 200, 's': 1e-4, 'tau': 1e-9, 'seed': 22222,\n            'ranges': [\n                (315.0, 335.0),  # T_h [K]\n                (285.0, 295.0),  # T_c [K]\n                (0.02, 0.04),    # L_1 [m]\n                (0.02, 0.05),    # k_1 [W/mK]\n                (0.01, 0.03),    # L_2 [m]\n                (0.5, 1.5)       # k_2 [W/mK]\n            ]\n        }\n    ]\n\n    # Minimum step sizes for perturbation\n    epsilons = np.array([1e-6, 1e-6, 1e-9, 1e-9, 1e-9, 1e-9])\n    \n    # Expected signs of partial derivatives: 1 for >= 0, -1 for = 0\n    # Corresponding to [T_h, T_c, L_1, k_1, L_2, k_2]\n    expected_signs = np.array([1, -1, -1, 1, -1, 1])\n    \n    results = []\n\n    for case in test_cases:\n        case_passes = True\n        rng = np.random.default_rng(case['seed'])\n        \n        N, s, tau = case['N'], case['s'], case['tau']\n        ranges = case['ranges']\n        \n        for _ in range(N):\n            # Generate a random sample vector\n            x_sample = np.array([rng.uniform(low, high) for low, high in ranges])\n            \n            # Compute perturbations h for all variables\n            h_vector = np.maximum(epsilons, s * np.abs(x_sample))\n            \n            for j in range(len(x_sample)):\n                # Evaluate surrogate at x + h*e_j and x - h*e_j\n                x_plus = x_sample.copy()\n                x_plus[j] += h_vector[j]\n                \n                x_minus = x_sample.copy()\n                x_minus[j] -= h_vector[j]\n                \n                q_plus = q_surrogate(x_plus)\n                q_minus = q_surrogate(x_minus)\n                \n                # Compute centered finite difference\n                grad_j = (q_plus - q_minus) / (2 * h_vector[j])\n                \n                # Verify sign constraint against tolerance tau\n                is_violated = False\n                if expected_signs[j] > 0 and grad_j  -tau:\n                    is_violated = True\n                elif expected_signs[j]  0 and grad_j > tau:\n                    is_violated = True\n\n                if is_violated:\n                    case_passes = False\n                    break  # Exit j-loop (variables)\n            \n            if not case_passes:\n                break  # Exit i-loop (samples)\n        \n        results.append(case_passes)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}