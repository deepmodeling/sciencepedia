{
    "hands_on_practices": [
        {
            "introduction": "The power of spectral methods lies in their ability to represent smooth, periodic functions with exceptional accuracy. A core operation in solving differential equations is differentiation, which in the Fourier domain, remarkably simplifies to algebraic multiplication. This first practice invites you to verify this principle by implementing a Fourier-based spectral derivative and comparing its output to exact analytical solutions, allowing you to witness the \"spectral accuracy\" of the method firsthand. ",
            "id": "3946953",
            "problem": "Consider a one-dimensional, spatially periodic, smooth temperature field defined on a domain of length $2\\pi$ with periodic boundary conditions. The objective is to verify the accuracy of spectral differentiation implemented via the Fast Fourier Transform (FFT) by comparing numerically computed derivatives to analytically derived reference derivatives. The test must quantify the discrepancy using the $L^2$ and $L^\\infty$ error norms. The angle unit for trigonometric functions must be in radians. All quantities are dimensionless; no physical units are required.\n\nStarting from the foundational representation of periodic functions by Fourier series and the differentiation property of the Fourier transform, design and implement a pseudospectral differentiation operator that computes the first spatial derivative of a periodic function sampled at $N$ equispaced points over $[0,2\\pi)$. The program must:\n- Construct equispaced grid points $x_j$ for $j=0,\\dots,N-1$ on the interval $[0,2\\pi)$.\n- Evaluate the manufactured temperature field $T(x)$ on this grid for each test case.\n- Compute the spectral derivative using a Fourier-transform-based approach consistent with the differentiation property of Fourier series for periodic functions.\n- Derive and evaluate the exact analytic derivative $T'(x)$ for each manufactured field.\n- Compute the error field $e(x_j)=T'_{\\text{num}}(x_j)-T'_{\\text{ref}}(x_j)$.\n- Report the errors using the following norms:\n  - The $L^2$ error defined by $\\left(\\sum_{j=0}^{N-1} |e(x_j)|^2\\,\\Delta x\\right)^{1/2}$, where $\\Delta x = 2\\pi/N$.\n  - The $L^\\infty$ error defined by $\\max_{0\\le j \\le N-1} |e(x_j)|$.\nAll trigonometric evaluations must use radians.\n\nTest Suite. Use the following manufactured fields and resolutions:\n1. Happy path (band-limited, well-resolved): $N=32$, $T(x)=\\sin(3x)+\\tfrac{1}{2}\\cos(2x)$.\n2. Non-power-of-two and odd size: $N=33$, $T(x)=\\sin(9x)$.\n3. Near-Nyquist mode: $N=64$, $T(x)=\\cos(31x)$.\n4. Aliasing-prone smooth but not band-limited: $N=64$, $T(x)=\\exp(\\sin(x))$.\n\nFor each case, compute the numerical derivative via spectral differentiation and compare to the exact analytic derivative. Then compute and return the $L^2$ and $L^\\infty$ error norms.\n\nFinal Output Format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain the $L^2$ error followed by the $L^\\infty$ error for each test case in the order listed above, with each value rounded to eight decimal places. For example, the output format must be\n$[L2\\_1,L\\infty\\_1,L2\\_2,L\\infty\\_2,L2\\_3,L\\infty\\_3,L2\\_4,L\\infty\\_4]$,\nwhere $L2\\_k$ and $L\\infty\\_k$ denote the $L^2$ and $L^\\infty$ errors for test case $k$ respectively.",
            "solution": "The problem statement has been meticulously reviewed and is determined to be **valid**. It is scientifically grounded in the principles of Fourier analysis, numerically well-posed, and an objective exercise in computational science. The task is to implement and verify a pseudospectral differentiation operator, a standard technique in the numerical solution of partial differential equations, particularly in direct numerical simulation (DNS) where high accuracy is paramount. All necessary parameters, functions, and error metric definitions are provided, allowing for a unique and verifiable solution.\n\n### Theoretical Foundation of Pseudospectral Differentiation\n\nThe method is based on the differentiation property of the Fourier series. A sufficiently smooth function $T(x)$ that is periodic on the spatial domain $[0, 2\\pi)$ can be represented by its complex Fourier series:\n$$\nT(x) = \\sum_{k=-\\infty}^{\\infty} \\hat{T}_k e^{ikx}\n$$\nwhere $k$ represents the integer wavenumbers and $\\hat{T}_k$ are the complex Fourier coefficients. The spatial derivative, $T'(x)$, is obtained by differentiating this series term-by-term with respect to $x$:\n$$\nT'(x) = \\frac{d}{dx} \\sum_{k=-\\infty}^{\\infty} \\hat{T}_k e^{ikx} = \\sum_{k=-\\infty}^{\\infty} (ik) \\hat{T}_k e^{ikx}\n$$\nThis fundamental property shows that differentiation in physical space is equivalent to multiplication by $ik$ in Fourier space, where $i$ is the imaginary unit.\n\n### Numerical Implementation via Discrete Fourier Transform\n\nIn a computational setting, the continuous function $T(x)$ is represented by its samples on a discrete grid of $N$ equispaced points: $x_j = j \\frac{2\\pi}{N}$ for $j=0, 1, \\dots, N-1$. The pseudospectral (or collocation) method involves the following steps:\n\n1.  **Forward Transform**: The vector of function samples, $T_j = T(x_j)$, is transformed into the discrete Fourier domain using the Fast Fourier Transform (FFT). This yields a vector of discrete Fourier coefficients, $\\hat{T}_k$.\n    $$\n    \\hat{T}_k = \\mathcal{F}\\{T_j\\} = \\sum_{j=0}^{N-1} T_j e^{-i 2\\pi jk/N}\n    $$\n\n2.  **Wavenumber Vector**: The indices $k=0, 1, \\dots, N-1$ of the FFT output must be mapped to the corresponding physical wavenumbers. For a domain of length $L=2\\pi$, the wavenumbers are integers. Standard FFT libraries produce coefficients in an order that requires a specific wavenumber vector $\\boldsymbol{\\kappa}$ for correct multiplication. This vector is given by $\\boldsymbol{\\kappa} = [0, 1, \\dots, k_{\\text{max}}, -k_{\\text{Ny}}, \\dots, -1]$, where $k_{\\text{max}}$ and the handling of the Nyquist wavenumber $k_{\\text{Ny}}$ depend on whether $N$ is even or odd.\n\n3.  **Nyquist Frequency Handling (for even $N$)**: When $N$ is even, the Nyquist wavenumber is $k_{\\text{Ny}} = N/2$. The corresponding mode on the grid is $e^{i(N/2)x_j} = e^{i\\pi j} = (-1)^j$. The derivative of the real function $\\cos(k_{\\text{Ny}}x)$ is $-k_{\\text{Ny}}\\sin(k_{\\text{Ny}}x)$. At the grid points $x_j$, $\\sin(k_{\\text{Ny}}x_j) = \\sin(\\pi j) = 0$. Consequently, the derivative of the cosine part of the Nyquist mode is not representable as it is zero everywhere on the grid. To maintain a real-valued derivative for a real-valued input function and to avoid ambiguity, the Fourier coefficient corresponding to the Nyquist wavenumber is effectively multiplied by $0$. This is a standard convention in spectral codes.\n\n4.  **Differentiation in Fourier Space**: A modified wavenumber vector, $\\boldsymbol{\\kappa}'$, is formed where the Nyquist component is set to zero if $N$ is even. The Fourier coefficients of the derivative, $\\widehat{T'}_k$, are then computed by element-wise multiplication:\n    $$\n    \\widehat{T'}_k = (i \\kappa'_k) \\hat{T}_k\n    $$\n\n5.  **Inverse Transform**: The derivative in physical space, $T'_{\\text{num},j}$, is recovered by applying the inverse FFT (iFFT) to the modified coefficients $\\widehat{T'}_k$.\n    $$\n    T'_{\\text{num},j} = \\mathcal{F}^{-1}\\{\\widehat{T'}_k\\} = \\frac{1}{N} \\sum_{k=0}^{N-1} \\widehat{T'}_k e^{i 2\\pi jk/N}\n    $$\n    Due to floating-point arithmetic, the result of the iFFT on the transformed derivative of a real signal may have a negligible imaginary part, which is discarded by taking the real part of the result.\n\n### Error Analysis\n\nThe accuracy of the numerical derivative $T'_{\\text{num}}$ is assessed by comparing it to the exact analytical derivative $T'_{\\text{ref}}$ evaluated at the grid points $x_j$. The error field is defined as $e(x_j)=T'_{\\text{num}}(x_j)-T'_{\\text{ref}}(x_j)$. The magnitude of this error is quantified using two standard norms:\n\n-   The discrete $L^2$ error norm, which measures the root-mean-square error over the domain:\n    $$\n    \\|e\\|_{L^2} = \\left( \\sum_{j=0}^{N-1} |e(x_j)|^2 \\Delta x \\right)^{1/2} \\quad \\text{where} \\quad \\Delta x = \\frac{2\\pi}{N}\n    $$\n-   The $L^\\infty$ error norm, which measures the maximum absolute error at any point in the domain:\n    $$\n    \\|e\\|_{L^\\infty} = \\max_{0 \\le j \\le N-1} |e(x_j)|\n    $$\n\nFor band-limited functions that are well-resolved (i.e., all active wavenumbers $k$ satisfy $|k| < N/2$), the differentiation error is dominated by floating-point arithmetic and should be close to machine precision. For functions that are not band-limited, the error is dominated by aliasing, where high-wavenumber content that cannot be represented on the grid is erroneously folded onto lower wavenumbers, causing a discretization error that does not vanish with machine precision. The provided test cases are designed to probe these behaviors.",
            "answer": "```python\nimport numpy as np\n\ndef spectral_derivative(T_values, N):\n    \"\"\"\n    Computes the first derivative of a periodic function using the Fourier spectral method.\n\n    Args:\n        T_values (np.ndarray): The function values at N equispaced points in [0, 2*pi).\n        N (int): The number of grid points.\n\n    Returns:\n        np.ndarray: The numerical derivative at the grid points.\n    \"\"\"\n    # 1. Forward FFT to get Fourier coefficients\n    T_hat = np.fft.fft(T_values)\n\n    # 2. Define the wavenumber vector kappa\n    # For a domain of length L=2*pi, the wavenumbers are integers.\n    # np.fft.fftfreq(N) gives frequencies f in cycles per sample.\n    # Multiply by N to get frequencies in cycles per domain length.\n    # Since L=2*pi, these are the wavenumbers k.\n    kappa = np.fft.fftfreq(N, d=1.0/N)\n\n    # 3. Handle the Nyquist frequency for even N\n    # The derivative of the Nyquist mode cos(N/2*x) is not representable\n    # on the grid. To keep the derivative of a real function real, its\n    # corresponding derivative coefficient is set to zero.\n    if N % 2 == 0:\n        kappa[N // 2] = 0.0\n\n    # 4. Multiply by i*kappa in Fourier space\n    T_prime_hat = 1j * kappa * T_hat\n\n    # 5. Inverse FFT to get the derivative in physical space\n    T_prime_num = np.fft.ifft(T_prime_hat)\n\n    # The result should be real; take the real part to discard negligible\n    # imaginary components due to floating-point error.\n    return np.real(T_prime_num)\n\ndef solve():\n    \"\"\"\n    Executes the verification test for spectral differentiation across all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": 32,\n            \"T_func\": lambda x: np.sin(3 * x) + 0.5 * np.cos(2 * x),\n            \"T_prime_func\": lambda x: 3 * np.cos(3 * x) - np.sin(2 * x),\n        },\n        {\n            \"N\": 33,\n            \"T_func\": lambda x: np.sin(9 * x),\n            \"T_prime_func\": lambda x: 9 * np.cos(9 * x),\n        },\n        {\n            \"N\": 64,\n            \"T_func\": lambda x: np.cos(31 * x),\n            \"T_prime_func\": lambda x: -31 * np.sin(31 * x),\n        },\n        {\n            \"N\": 64,\n            \"T_func\": lambda x: np.exp(np.sin(x)),\n            \"T_prime_func\": lambda x: np.cos(x) * np.exp(np.sin(x)),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        T_func = case[\"T_func\"]\n        T_prime_func = case[\"T_prime_func\"]\n\n        # Construct grid and evaluate functions\n        delta_x = 2 * np.pi / N\n        x_grid = np.arange(0, N) * delta_x\n        \n        T_values = T_func(x_grid)\n        T_prime_ref = T_prime_func(x_grid)\n\n        # Compute numerical derivative\n        T_prime_num = spectral_derivative(T_values, N)\n\n        # Compute error field\n        error = T_prime_num - T_prime_ref\n\n        # Compute L2 and Linf error norms\n        l2_error = np.sqrt(np.sum(error**2) * delta_x)\n        linf_error = np.max(np.abs(error))\n\n        results.append(f\"{l2_error:.8f}\")\n        results.append(f\"{linf_error:.8f}\")\n    \n    # Print the final output in the required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "With the tool of spectral differentiation in hand, we can now assemble the components of a solver for the incompressible Navier-Stokes equations, the cornerstone of fluid dynamics. This exercise guides you through a single time step of the incremental pressure-correction method, a classic algorithm for handling the coupling between pressure and velocity. You will see how an intermediate, non-divergence-free velocity field is \"projected\" back onto the space of physically realistic, incompressible flows. ",
            "id": "3946876",
            "problem": "You are given the incompressible Navier–Stokes equations in two spatial dimensions for a velocity field $\\mathbf{u}(x,y,t)$ and a pressure field $p(x,y,t)$, in non-dimensional form, on a square periodic domain:\n$$\n\\mathbf{u}_t + \\mathbf{N}(\\mathbf{u}) = -\\nabla p + \\nu \\nabla^2 \\mathbf{u},\\qquad \\nabla\\cdot\\mathbf{u}=0,\n$$\nwhere $\\mathbf{N}(\\mathbf{u})$ denotes the nonlinear convection operator and $\\nu$ is the kinematic viscosity. The task is to implement a single time step of the incremental pressure-correction method within a Fourier pseudo-spectral discretization and quantify how the divergence produced in the intermediate velocity is removed by the projection.\n\nImplement the following, starting from fundamental principles only:\n\n- Use a Fourier pseudo-spectral discretization on the periodic domain $[0,2\\pi]^2$ with $N\\times N$ uniformly spaced grid points. Let $N$ be a positive integer and the grid spacing satisfies $dx=dy=2\\pi/N$. Use the standard discrete Fourier transform with wavenumbers that are integer-valued and consistent with the $[0,2\\pi]$ periodicity.\n\n- Construct a divergence-free initial velocity field via a streamfunction $\\psi(x,y)$ such that $\\mathbf{u}=\\nabla^\\perp\\psi$ with $\\mathbf{u}(x,y,0)=\\left(\\partial_y\\psi,-\\partial_x\\psi\\right)$. Take $\\psi(x,y)=\\sin(x)\\sin(y)$. All quantities are non-dimensional.\n\n- Discretize the nonlinear convection operator $\\mathbf{N}(\\mathbf{u})$ as $(\\mathbf{u}\\cdot\\nabla)\\mathbf{u}$ in physical space using spectral derivatives to form $\\nabla\\mathbf{u}$, then compute the pointwise products and transform back to Fourier space. Apply the classical $2/3$ de-aliasing rule to the nonlinear term in Fourier space by zeroing modes with $|k_x|>N/3$ or $|k_y|>N/3$.\n\n- Perform a single explicit forward-Euler step for the intermediate velocity $\\mathbf{u}^\\star$ that ignores pressure. Then perform an incremental pressure correction (projection) to obtain $\\mathbf{u}^{n+1}$ that satisfies the discrete incompressibility constraint. Use only the fundamental governing equations and the periodic spectral representation to derive the necessary relations for the pressure increment and the projection operator; do not use any pre-stated formulas.\n\n- Quantify the divergence using the discrete $L^2$ norm of the scalar divergence field, defined as\n$$\n\\|\\nabla\\cdot\\mathbf{v}\\|_{2}=\\left(\\sum_{j=0}^{N-1}\\sum_{k=0}^{N-1} \\left(\\nabla\\cdot\\mathbf{v}(x_j,y_k)\\right)^2\\,dx\\,dy\\right)^{1/2},\n$$\nfor a velocity field $\\mathbf{v}$ at the corresponding time. Report three quantities per test case: the discrete $L^2$ norm of the divergence of the initial velocity $\\mathbf{u}^n$, of the intermediate velocity $\\mathbf{u}^\\star$, and of the projected velocity $\\mathbf{u}^{n+1}$.\n\nYour program must produce results for the following test suite of parameter sets, each expressed in non-dimensional units:\n\n- Test $1$: $N=64$, $\\Delta t=10^{-3}$, $\\nu=10^{-3}$, with the nonlinear convection active.\n- Test $2$: $N=64$, $\\Delta t=10^{-6}$, $\\nu=10^{-3}$, with the nonlinear convection active.\n- Test $3$: $N=64$, $\\Delta t=5\\times 10^{-3}$, $\\nu=0$, with the nonlinear convection active.\n- Test $4$: $N=64$, $\\Delta t=10^{-3}$, $\\nu=10^{-3}$, with the nonlinear convection disabled (i.e., take $\\mathbf{N}(\\mathbf{u})=\\mathbf{0}$).\n\nFor each test case, the program must compute and output a list of three real numbers (each a float): $[\\|\\nabla\\cdot\\mathbf{u}^n\\|_2,\\ \\|\\nabla\\cdot\\mathbf{u}^\\star\\|_2,\\ \\|\\nabla\\cdot\\mathbf{u}^{n+1}\\|_2]$.\n\nFinal output format requirement:\n\n- Your program should produce a single line of output containing a list of lists, one per test case, with the three floats for each case in the order listed above. The format must be exactly like\n$$\n[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3],[a_4,b_4,c_4]],\n$$\nwhere each $a_i$, $b_i$, and $c_i$ are decimal numbers.\n\nAll calculations are to be done in non-dimensional units. Angles are in radians. No external input should be required, and the program must be self-contained and runnable in a modern environment. The core of the implementation must follow from the governing equations and the spectral representation, not from pre-given shortcut formulas.",
            "solution": "The starting point is the incompressible Navier–Stokes equations\n$$\n\\mathbf{u}_t + \\mathbf{N}(\\mathbf{u}) = -\\nabla p + \\nu \\nabla^2 \\mathbf{u},\\qquad \\nabla\\cdot\\mathbf{u}=0,\n$$\non a periodic domain. The incremental pressure-correction method proceeds by first forming an intermediate velocity without the pressure term and then correcting it to enforce the divergence-free constraint using a scalar pressure increment computed from a Poisson problem. The derivation relies only on the equations, the periodic boundary conditions, and standard spectral identities.\n\nFundamental base and representation:\n\n- In a $[0,2\\pi]^2$ periodic domain with $N\\times N$ grid points, use the spectral wavenumbers $k_x$ and $k_y$ that are integers consistent with the discrete Fourier transform on a $2\\pi$-periodic interval. Denote the discrete Fourier transforms of fields by hats, for example $\\widehat{u_x}(k_x,k_y)$.\n\n- Spectral differentiation identities are well-established: for each mode $(k_x,k_y)$, $\\partial_x$ corresponds to multiplication by $\\mathrm{i}k_x$, $\\partial_y$ to $\\mathrm{i}k_y$, and the Laplacian $\\nabla^2$ corresponds to multiplication by $-(k_x^2+k_y^2)$.\n\n- The divergence in Fourier space is $\\widehat{\\nabla\\cdot\\mathbf{u}}=\\mathrm{i}k_x\\widehat{u_x}+\\mathrm{i}k_y\\widehat{u_y}$, and its inverse transform yields $\\nabla\\cdot\\mathbf{u}(x,y)$.\n\nDivergence-free initialization via a streamfunction:\n\n- Let the streamfunction be $\\psi(x,y)=\\sin(x)\\sin(y)$. Define the initial velocity $\\mathbf{u}(x,y,0)=\\left(\\partial_y\\psi,-\\partial_x\\psi\\right)=\\left(\\cos(y)\\sin(x),-\\cos(x)\\sin(y)\\right)$, which is divergence-free by construction because $\\nabla\\cdot\\nabla^\\perp\\psi=0$.\n\nNonlinear term and pseudo-spectral calculation:\n\n- The nonlinear convection operator is $\\mathbf{N}(\\mathbf{u})=(\\mathbf{u}\\cdot\\nabla)\\mathbf{u}$. Its $x$-component is $N_x=u_x\\partial_x u_x+u_y\\partial_y u_x$, and its $y$-component is $N_y=u_x\\partial_x u_y+u_y\\partial_y u_y$.\n\n- Compute $\\partial_x u_x$, $\\partial_y u_x$, $\\partial_x u_y$, and $\\partial_y u_y$ in Fourier space by multiplying $\\widehat{u_x}$ and $\\widehat{u_y}$ by $\\mathrm{i}k_x$ or $\\mathrm{i}k_y$, then transform to physical space to form the products that define $N_x$ and $N_y$. Transform $N_x$ and $N_y$ back to Fourier space. Apply the $2/3$ de-aliasing rule by zeroing Fourier modes with $|k_x|>N/3$ or $|k_y|>N/3$ in the nonlinear term. This follows from the well-tested approach to control aliasing errors in pseudo-spectral computations of quadratic nonlinearities.\n\nIntermediate step without pressure:\n\n- Discretize time explicitly with a forward Euler step for the intermediate velocity $\\mathbf{u}^\\star$. Denote $\\Delta t$ as the time step. From the momentum equation without pressure, the intermediate update in Fourier space is\n$$\n\\widehat{\\mathbf{u}^\\star} = \\widehat{\\mathbf{u}^n} + \\Delta t\\left(-\\widehat{\\mathbf{N}(\\mathbf{u}^n)} + \\nu \\widehat{\\nabla^2 \\mathbf{u}^n}\\right),\n$$\nwhere $\\widehat{\\nabla^2 \\mathbf{u}^n}=-(k_x^2+k_y^2)\\widehat{\\mathbf{u}^n}$.\n\n- The intermediate velocity will generally not satisfy $\\nabla\\cdot\\mathbf{u}^\\star=0$ because the pressure term responsible for enforcing incompressibility was omitted.\n\nIncremental pressure correction via Helmholtz decomposition:\n\n- The vector field $\\mathbf{u}^\\star$ can be uniquely decomposed into a divergence-free part and a gradient of a scalar potential in a periodic domain:\n$$\n\\mathbf{u}^\\star = \\mathbf{u}^{n+1} + \\Delta t \\nabla \\phi,\n$$\nwith $\\nabla\\cdot\\mathbf{u}^{n+1}=0$ and $\\phi$ being the incremental pressure divided by the density (in non-dimensional form). Taking the divergence of the decomposition,\n$$\n\\nabla\\cdot\\mathbf{u}^\\star = \\Delta t \\nabla^2 \\phi,\n$$\nwhich implies a Poisson equation for the pressure increment,\n$$\n\\nabla^2 \\phi = \\frac{1}{\\Delta t}\\nabla\\cdot\\mathbf{u}^\\star.\n$$\n\n- In Fourier space for non-zero modes, this Poisson equation reduces to\n$$\n-(k_x^2+k_y^2)\\widehat{\\phi} = \\frac{1}{\\Delta t}\\left(\\mathrm{i}k_x\\widehat{u^\\star_x}+\\mathrm{i}k_y\\widehat{u^\\star_y}\\right),\n$$\nso for $(k_x,k_y)\\neq(0,0)$,\n$$\n\\widehat{\\phi} = -\\frac{\\mathrm{i}k_x\\widehat{u^\\star_x}+\\mathrm{i}k_y\\widehat{u^\\star_y}}{(k_x^2+k_y^2)\\Delta t}.\n$$\nThe zero mode $\\widehat{\\phi}(0,0)$ is undetermined up to an additive constant and can be set to $0$.\n\n- The corrected velocity is then obtained by subtracting the gradient of the pressure increment:\n$$\n\\widehat{\\mathbf{u}^{n+1}} = \\widehat{\\mathbf{u}^\\star} - \\Delta t\\,\\mathrm{i}\\mathbf{k}\\,\\widehat{\\phi}.\n$$\nCombining the previous relations yields the familiar Fourier-space Leray projector onto divergence-free fields:\n$$\n\\widehat{\\mathbf{u}^{n+1}} = \\left(\\mathbf{I} - \\frac{\\mathbf{k}\\mathbf{k}^\\top}{\\|\\mathbf{k}\\|^2}\\right)\\widehat{\\mathbf{u}^\\star},\n$$\nfor $(k_x,k_y)\\neq(0,0)$, where $\\mathbf{k}=(k_x,k_y)$ and $\\mathbf{I}$ is the identity matrix. This construction follows directly from the Helmholtz decomposition and the solution of the Poisson equation and does not require any shortcut formulas beyond the spectral representations and the governing equations. At the zero mode, set $\\widehat{\\mathbf{u}^{n+1}}=\\widehat{\\mathbf{u}^\\star}$ because $\\mathbf{k}=\\mathbf{0}$ makes the projection indeterminate, but the divergence of a constant mode is zero.\n\nDivergence quantification:\n\n- For any velocity field $\\mathbf{v}$, compute the divergence in Fourier space as $\\widehat{\\nabla\\cdot\\mathbf{v}}=\\mathrm{i}k_x\\widehat{v_x}+\\mathrm{i}k_y\\widehat{v_y}$, inverse transform to get $\\nabla\\cdot\\mathbf{v}(x,y)$, and then compute the discrete $L^2$ norm\n$$\n\\|\\nabla\\cdot\\mathbf{v}\\|_{2}=\\left(\\sum_{j=0}^{N-1}\\sum_{k=0}^{N-1} \\left(\\nabla\\cdot\\mathbf{v}(x_j,y_k)\\right)^2\\,dx\\,dy\\right)^{1/2},\n$$\nwith $dx=dy=2\\pi/N$.\n\nAlgorithmic steps for each test case:\n\n1. Set up the grid $x_j=j\\,dx$ and $y_k=k\\,dy$ for $j,k\\in\\{0,\\dots,N-1\\}$, $dx=dy=2\\pi/N$, and Fourier wavenumbers $k_x$ and $k_y$ via the discrete Fourier frequency functions scaled to integer wavenumbers.\n\n2. Initialize the velocity field $\\mathbf{u}^n$ in physical space from the streamfunction, then compute its Fourier transforms $\\widehat{u_x^n}$ and $\\widehat{u_y^n}$.\n\n3. Compute spectral derivatives to obtain $\\partial_x \\mathbf{u}^n$ and $\\partial_y \\mathbf{u}^n$ in physical space, form the nonlinear term $(\\mathbf{u}^n\\cdot\\nabla)\\mathbf{u}^n$, transform it to Fourier space, and apply the $2/3$ de-aliasing filter.\n\n4. Compute $\\widehat{\\nabla^2 \\mathbf{u}^n}=-(k_x^2+k_y^2)\\widehat{\\mathbf{u}^n}$.\n\n5. Form the intermediate velocity $\\widehat{\\mathbf{u}^\\star}=\\widehat{\\mathbf{u}^n}+\\Delta t\\left(-\\widehat{\\mathbf{N}(\\mathbf{u}^n)}+\\nu\\widehat{\\nabla^2\\mathbf{u}^n}\\right)$.\n\n6. Compute $\\|\\nabla\\cdot\\mathbf{u}^n\\|_2$ and $\\|\\nabla\\cdot\\mathbf{u}^\\star\\|_2$.\n\n7. Project $\\widehat{\\mathbf{u}^\\star}$ onto the divergence-free subspace using the Fourier-space projector to obtain $\\widehat{\\mathbf{u}^{n+1}}$.\n\n8. Compute $\\|\\nabla\\cdot\\mathbf{u}^{n+1}\\|_2$.\n\nTest suite coverage:\n\n- Test $1$ uses $N=64$, $\\Delta t=10^{-3}$, $\\nu=10^{-3}$, and active convection, representing a typical direct numerical simulation step.\n\n- Test $2$ uses a very small time step $\\Delta t=10^{-6}$ to check the limiting behavior and numerical round-off influence.\n\n- Test $3$ sets $\\nu=0$ (inviscid) with $\\Delta t=5\\times 10^{-3}$ to focus on the convective nonlinearity and the role of projection when diffusion is absent.\n\n- Test $4$ disables the nonlinear term, leaving only diffusion; since $\\nabla^2$ commutes with divergence and the initial field is divergence-free, the intermediate divergence is expected to remain near zero up to numerical precision.\n\nThe program outputs one list per test case containing three floats $[\\|\\nabla\\cdot\\mathbf{u}^n\\|_2,\\ \\|\\nabla\\cdot\\mathbf{u}^\\star\\|_2,\\ \\|\\nabla\\cdot\\mathbf{u}^{n+1}\\|_2]$. Aggregated into a single line, the overall output is a list of these lists, strictly in the required format. The projection step must reduce the divergence norm from the intermediate value to a value near machine precision, demonstrating the removal of divergence by the projection derived from the governing equations and spectral representation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef spectral_wavenumbers(N):\n    \"\"\"\n    Return 2D arrays of integer Fourier wavenumbers kx, ky and k^2 for a 2π-periodic domain.\n    \"\"\"\n    k1d = np.fft.fftfreq(N) * N  # integer wavenumbers consistent with 2π periodicity\n    kx, ky = np.meshgrid(k1d, k1d, indexing='ij')\n    k2 = kx**2 + ky**2\n    return kx, ky, k2\n\ndef dealias_mask(N):\n    \"\"\"\n    2/3-rule dealiasing mask: keep modes with |k|<= N/3 in each direction.\n    \"\"\"\n    k1d = np.fft.fftfreq(N) * N\n    kx, ky = np.meshgrid(k1d, k1d, indexing='ij')\n    cutoff = N // 3\n    mask = (np.abs(kx) <= cutoff) & (np.abs(ky) <= cutoff)\n    return mask\n\ndef streamfunction_initial_u(N):\n    \"\"\"\n    Construct divergence-free initial velocity from psi = sin(x) sin(y).\n    u = (∂ψ/∂y, -∂ψ/∂x) = (cos(y) sin(x), -cos(x) sin(y))\n    \"\"\"\n    L = 2.0 * np.pi\n    x = np.linspace(0.0, L, N, endpoint=False)\n    y = np.linspace(0.0, L, N, endpoint=False)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n    ux = np.cos(Y) * np.sin(X)\n    uy = -np.cos(X) * np.sin(Y)\n    return ux, uy\n\ndef fft2(field):\n    return np.fft.fft2(field)\n\ndef ifft2(field_hat):\n    return np.fft.ifft2(field_hat)\n\ndef compute_divergence_norm(ux_hat, uy_hat, kx, ky, dx, dy):\n    \"\"\"\n    Compute L2 norm of divergence: ||∇·u||_2 over the domain using discrete sum.\n    \"\"\"\n    div_hat = 1j * kx * ux_hat + 1j * ky * uy_hat\n    div = np.real(ifft2(div_hat))\n    norm = np.sqrt(np.sum(div**2) * dx * dy)\n    return norm\n\ndef compute_nonlinear_term_hat(ux_hat, uy_hat, kx, ky, N, mask):\n    \"\"\"\n    Compute (u · ∇) u pseudo-spectrally with 2/3-rule dealiasing.\n    \"\"\"\n    # Spectral derivatives of u components\n    dux_dx_hat = 1j * kx * ux_hat\n    dux_dy_hat = 1j * ky * ux_hat\n    duy_dx_hat = 1j * kx * uy_hat\n    duy_dy_hat = 1j * ky * uy_hat\n\n    # Transform derivatives to physical space\n    dux_dx = np.real(ifft2(dux_dx_hat))\n    dux_dy = np.real(ifft2(dux_dy_hat))\n    duy_dx = np.real(ifft2(duy_dx_hat))\n    duy_dy = np.real(ifft2(duy_dy_hat))\n\n    # Velocity in physical space\n    ux = np.real(ifft2(ux_hat))\n    uy = np.real(ifft2(uy_hat))\n\n    # Nonlinear term in physical space\n    Nx = ux * dux_dx + uy * dux_dy\n    Ny = ux * duy_dx + uy * duy_dy\n\n    # Transform back to Fourier space\n    Nx_hat = fft2(Nx)\n    Ny_hat = fft2(Ny)\n\n    # Apply 2/3 de-aliasing to nonlinear term\n    Nx_hat = Nx_hat * mask\n    Ny_hat = Ny_hat * mask\n\n    return Nx_hat, Ny_hat\n\ndef incremental_pressure_correction_step(N, dt, nu, nonlinear_active=True):\n    \"\"\"\n    Perform one incremental pressure correction step for given parameters.\n    Returns divergence norms: [||div u^n||2, ||div u*||2, ||div u^{n+1}||2].\n    \"\"\"\n    # Grid and spectral wavenumbers\n    L = 2.0 * np.pi\n    dx = L / N\n    dy = L / N\n    kx, ky, k2 = spectral_wavenumbers(N)\n    mask = dealias_mask(N)\n\n    # Initial velocity from streamfunction\n    ux, uy = streamfunction_initial_u(N)\n\n    # Fourier transforms of initial velocity\n    ux_hat = fft2(ux)\n    uy_hat = fft2(uy)\n\n    # Divergence norm of initial velocity\n    divn = compute_divergence_norm(ux_hat, uy_hat, kx, ky, dx, dy)\n\n    # Nonlinear term\n    if nonlinear_active:\n        Nx_hat, Ny_hat = compute_nonlinear_term_hat(ux_hat, uy_hat, kx, ky, N, mask)\n    else:\n        Nx_hat = np.zeros_like(ux_hat)\n        Ny_hat = np.zeros_like(uy_hat)\n\n    # Diffusion term in spectral space: nu * ∇^2 u = -nu * k^2 * u_hat\n    lap_ux_hat = -k2 * ux_hat\n    lap_uy_hat = -k2 * uy_hat\n\n    # Intermediate velocity u* via explicit Euler: u* = u^n + dt * ( -N(u^n) + nu ∇^2 u^n )\n    ux_star_hat = ux_hat + dt * (-Nx_hat + nu * lap_ux_hat)\n    uy_star_hat = uy_hat + dt * (-Ny_hat + nu * lap_uy_hat)\n\n    # Divergence norm of intermediate velocity\n    div_star = compute_divergence_norm(ux_star_hat, uy_star_hat, kx, ky, dx, dy)\n\n    # Projection to divergence-free subspace in Fourier space (Leray projector)\n    # For k != 0: u^{n+1}_hat = u*_hat - k (k · u*_hat) / |k|^2\n    # Handle k^2 = 0 (zero mode) separately.\n    u_dot_k_hat = kx * ux_star_hat + ky * uy_star_hat\n    # Avoid division by zero: create factor with zeros where k2 == 0\n    factor = np.zeros_like(u_dot_k_hat, dtype=np.complex128)\n    nonzero = k2 != 0\n    factor[nonzero] = u_dot_k_hat[nonzero] / k2[nonzero]\n    ux_new_hat = ux_star_hat - kx * factor\n    uy_new_hat = uy_star_hat - ky * factor\n\n    # Divergence norm of projected velocity\n    div_new = compute_divergence_norm(ux_new_hat, uy_new_hat, kx, ky, dx, dy)\n\n    return [divn, div_star, div_new]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (N, dt, nu, nonlinear_active)\n    test_cases = [\n        (64, 1e-3, 1e-3, True),     # Test 1\n        (64, 1e-6, 1e-3, True),     # Test 2\n        (64, 5e-3, 0.0, True),      # Test 3\n        (64, 1e-3, 1e-3, False),    # Test 4\n    ]\n\n    results = []\n    for N, dt, nu, nonlinear_active in test_cases:\n        norms = incremental_pressure_correction_step(N, dt, nu, nonlinear_active)\n        # Convert to Python floats for clean printing\n        results.append([float(norms[0]), float(norms[1]), float(norms[2])])\n\n    # Final print statement in the exact required format: one single line, list of lists.\n    print(f\"[{','.join([str(item) for item in results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While Fourier series are perfect for periodic phenomena, many engineering problems, such as heat transfer through a solid wall or flow in a channel, are inherently non-periodic. This practice introduces the Chebyshev spectral method, the standard for handling such wall-bounded domains. You will construct a Chebyshev differentiation matrix to compute the temperature gradient and wall heat flux, observing how the strategic clustering of collocation points near boundaries is key to resolving sharp gradients accurately. ",
            "id": "3946956",
            "problem": "Consider the non-dimensional one-dimensional conduction domain $y \\in [-1,1]$ with thermal conductivity set to unity. By Fourier’s law of heat conduction, the wall-normal heat flux is given by $q_y(y) = -\\partial_y T(y)$. In direct numerical simulation using spectral methods, Chebyshev–Gauss–Lobatto collocation is a standard approach to approximate derivatives. The Chebyshev–Gauss–Lobatto nodes are $y_j = \\cos\\left(\\frac{\\pi j}{N}\\right)$ for $j = 0,1,\\dots,N$, where $N$ is the polynomial degree. Define the alternating weights $c_j = (-1)^j \\, w_j$ with $w_0 = w_N = 2$ and $w_j = 1$ for $1 \\le j \\le N-1$. The Chebyshev first-derivative differentiation matrix $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ satisfies\n$$\nD_{ij} = \\begin{cases}\n\\frac{c_i}{c_j} \\, \\frac{1}{y_i - y_j}, & i \\ne j, \\\\\n-\\sum_{k\\ne i} D_{ik}, & i = j,\n\\end{cases}\n$$\nwhich yields the spectral collocation approximation $\\left.\\frac{dT}{dy}\\right|_{y=y_i} \\approx \\sum_{j=0}^{N} D_{ij} \\, T(y_j)$ for $i=0,\\dots,N$.\n\nYour task is to implement a program that constructs $D$ for given $N$, evaluates a specified analytic temperature profile $T(y)$ at the Chebyshev–Gauss–Lobatto nodes, computes the spectral approximation of $\\partial_y T$ at all nodes via matrix–vector multiplication, extracts the wall-normal heat flux at the walls $y=+1$ and $y=-1$, and compares it with the exact analytic flux obtained from the known derivative of $T(y)$. Thermal conductivity is unity, so report fluxes and errors in dimensionless units. All trigonometric evaluations must use angles in radians. The numerical error for a test case must be reported as the maximum of the absolute errors at $y=+1$ and $y=-1$, i.e.,\n$$\n\\varepsilon = \\max\\left( \\left| q_y^{\\text{num}}(+1) - q_y^{\\text{exact}}(+1) \\right|, \\, \\left| q_y^{\\text{num}}(-1) - q_y^{\\text{exact}}(-1) \\right| \\right),\n$$\nwhere $q_y^{\\text{num}}(\\pm 1)$ are obtained from the Chebyshev differentiation and $q_y^{\\text{exact}}(\\pm 1)$ from the analytic derivative.\n\nUse the following test suite, which spans a representative set of analytic profiles and resolutions:\n- Case 1 (polynomial, happy path): $T(y) = y^4$, $N=8$.\n- Case 2 (exponential, moderate gradient): $T(y) = \\exp(3 y)$, $N=24$.\n- Case 3 (hyperbolic cosine, moderate resolution): $T(y) = \\cosh(5 y)$, $N=16$.\n- Case 4 (sine in radians, small $N$): $T(y) = \\sin(\\pi y)$, $N=8$.\n- Case 5 (exponential, steep gradient): $T(y) = \\exp(10 y)$, $N=32$.\n\nFor each case, compute and return the single floating-point number $\\varepsilon$ as defined above. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,\\dots]$). Since all quantities are non-dimensional, no physical units are required in the output; angles must be treated in radians throughout.",
            "solution": "The problem is valid as it is scientifically grounded in the principles of Fourier's law of heat conduction and the established numerical technique of Chebyshev spectral collocation. It is well-posed, objective, and contains all necessary information to derive a unique, verifiable solution. We proceed with the solution.\n\nThe core of the problem is to compute the temperature gradient, $\\partial_y T$, at the boundaries of a one-dimensional domain $y \\in [-1, 1]$ using a Chebyshev spectral method and to compare the resulting heat flux to the exact analytical solution. The heat flux, given a unity thermal conductivity, is defined by Fourier's law as $q_y(y) = -\\partial_y T(y)$.\n\n**Step 1: Domain Discretization with Chebyshev–Gauss–Lobatto Nodes**\n\nThe spectral method requires the function to be evaluated at a specific set of points, or nodes. For this problem, we use the Chebyshev–Gauss–Lobatto (CGL) nodes, which are the extrema of the $N$-th order Chebyshev polynomial of the first kind. These nodes are distributed in the interval $[-1, 1]$ and are given by the formula:\n$$y_j = \\cos\\left(\\frac{\\pi j}{N}\\right) \\quad \\text{for } j = 0, 1, \\dots, N$$\nwhere $N$ is the polynomial degree. This set of $N+1$ nodes includes the boundary points, as $y_0 = \\cos(0) = 1$ and $y_N = \\cos(\\pi) = -1$. The nodes are not evenly spaced; they cluster near the boundaries $y=\\pm 1$, a property that is highly advantageous for resolving sharp gradients or boundary layers often encountered in transport phenomena.\n\n**Step 2: Construction of the Chebyshev Differentiation Matrix**\n\nThe spectral derivative of a function represented by its values at the CGL nodes is computed via multiplication with a Chebyshev differentiation matrix, $D$. This matrix $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ is constructed as follows.\n\nFirst, we define a set of alternating weights, $c_j$, for each node $j$:\n$$c_j = (-1)^j \\, w_j$$\nwhere the weights $w_j$ are given by $w_0 = w_N = 2$ and $w_j = 1$ for $1 \\le j \\le N-1$.\n\nThe entries of the differentiation matrix $D$ are then defined. The off-diagonal entries are:\n$$D_{ij} = \\frac{c_i}{c_j} \\, \\frac{1}{y_i - y_j} \\quad \\text{for } i \\ne j$$\nThe diagonal entries are determined by the condition that the derivative of a constant function must be zero. If we represent a constant function $f(y)=k$ by the vector $\\mathbf{f} = [k, k, \\dots, k]^T$, its derivative vector must be $\\mathbf{0}$. The numerical derivative is $D\\mathbf{f} = k(D\\mathbf{1})$, where $\\mathbf{1}$ is a vector of ones. For $D\\mathbf{1}$ to be zero, the sum of a a row's elements must be zero: $\\sum_{j=0}^{N} D_{ij} = 0$. This gives the formula for the diagonal entries:\n$$D_{ii} = -\\sum_{k=0, k\\ne i}^{N} D_{ik}$$\nThis construction ensures that the differentiation matrix is exact for any polynomial of degree up to $N$.\n\n**Step 3: Approximation of the Temperature Gradient and Heat Flux**\n\nLet the analytic temperature profile be $T(y)$. We first evaluate this function at the CGL nodes to obtain a discrete temperature vector $\\mathbf{T}$:\n$$\\mathbf{T} = [T(y_0), T(y_1), \\dots, T(y_N)]^T$$\nThe spectral approximation of the temperature gradient at each node is then obtained by a matrix-vector product:\n$$\n\\begin{pmatrix}\n (dT/dy)|_{y_0} \\\\\n (dT/dy)|_{y_1} \\\\\n \\vdots \\\\\n (dT/dy)|_{y_N}\n\\end{pmatrix}_{\\text{num}}\n\\approx D \\mathbf{T}\n$$\nThe numerical heat flux vector, $\\mathbf{q}_y^{\\text{num}}$, is subsequently found by applying Fourier's law:\n$$\\mathbf{q}_y^{\\text{num}} = - D \\mathbf{T}$$\n\n**Step 4: Evaluation of Wall Heat Flux and Numerical Error**\n\nThe primary objective is to evaluate the heat flux at the walls, which are located at $y = +1$ and $y = -1$. These correspond to the nodes $y_0$ and $y_N$, respectively.\n\nThe numerical wall fluxes are the first and last components of the $\\mathbf{q}_y^{\\text{num}}$ vector:\n$$q_y^{\\text{num}}(+1) = - (D \\mathbf{T})_0$$\n$$q_y^{\\text{num}}(-1) = - (D \\mathbf{T})_N$$\n\nTo assess the accuracy of this approximation, we compare these numerical values to the exact fluxes derived from the analytical derivative of the temperature profile, $T'(y) = \\frac{dT}{dy}$. The exact fluxes are:\n$$q_y^{\\text{exact}}(+1) = -T'(1)$$\n$$q_y^{\\text{exact}}(-1) = -T'(-1)$$\n\nThe final error, $\\varepsilon$, for each test case is defined as the maximum of the absolute errors at the two walls:\n$$\\varepsilon = \\max\\left( \\left| q_y^{\\text{num}}(+1) - q_y^{\\text{exact}}(+1) \\right|, \\, \\left| q_y^{\\text{num}}(-1) - q_y^{\\text{exact}}(-1) \\right| \\right)$$\n\nThis procedure is applied to each test case by substituting the corresponding function $T(y)$, its analytical derivative $T'(y)$, and the specified polynomial degree $N$. For example, in Case 1 where $T(y)=y^4$ and $N=8$, the analytical derivative is $T'(y)=4y^3$. Since the degree of the polynomial ($4$) is less than or equal to $N=8$, the spectral differentiation is exact, and the error $\\varepsilon$ is expected to be on the order of machine precision. For non-polynomial functions, the error will be finite and will decrease rapidly as $N$ increases (spectral convergence).",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_chebyshev_diff_matrix(N):\n    \"\"\"\n    Constructs the (N+1)x(N+1) Chebyshev differentiation matrix.\n    \n    Args:\n        N (int): The polynomial degree.\n        \n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple containing the differentiation \n                                       matrix D and the node locations y.\n    \"\"\"\n    if N == 0:\n        return np.array([[0.]]), np.array([0.])\n    \n    # Chebyshev-Gauss-Lobatto nodes\n    j = np.arange(N + 1)\n    y = np.cos(np.pi * j / N)\n    \n    # Alternating weights\n    w = np.ones(N + 1)\n    w[0] = w[N] = 2.0\n    c = (-1)**j * w\n    \n    # Tile y and c for vectorized computation of off-diagonal elements\n    y_col = y[:, np.newaxis]\n    y_row = y[np.newaxis, :]\n    c_col = c[:, np.newaxis]\n    c_row = c[np.newaxis, :]\n    \n    # Compute off-diagonal elements\n    diff = y_col - y_row\n    # Add identity to avoid division by zero on the diagonal\n    diff += np.identity(N + 1)\n    \n    D = (c_col / c_row) / diff\n    \n    # Set diagonal elements to zero, as they were placeholders\n    np.fill_diagonal(D, 0)\n    \n    # Compute diagonal elements from row-sum condition\n    D_diag = -np.sum(D, axis=1)\n    np.fill_diagonal(D, D_diag)\n    \n    return D, y\n\ndef calculate_wall_flux_error(N, T_func, T_prime_func):\n    \"\"\"\n    Computes the maximum absolute error of the wall-normal heat flux.\n    \n    Args:\n        N (int): The polynomial degree.\n        T_func (callable): The analytic temperature profile T(y).\n        T_prime_func (callable): The analytic derivative T'(y).\n        \n    Returns:\n        float: The maximum error epsilon.\n    \"\"\"\n    # Construct the differentiation matrix and nodes\n    D, y = compute_chebyshev_diff_matrix(N)\n    \n    # Evaluate temperature at the nodes\n    T_at_nodes = T_func(y)\n    \n    # Compute the numerical derivative via matrix-vector product\n    dT_dy_num = D @ T_at_nodes\n    \n    # The walls are at y = +1 (node 0) and y = -1 (node N)\n    # Numerical heat flux q = -dT/dy\n    q_num_p1 = -dT_dy_num[0]\n    q_num_m1 = -dT_dy_num[N]\n    \n    # Exact heat flux\n    q_exact_p1 = -T_prime_func(1.0)\n    q_exact_m1 = -T_prime_func(-1.0)\n    \n    # Calculate errors at each wall\n    error_p1 = np.abs(q_num_p1 - q_exact_p1)\n    error_m1 = np.abs(q_num_m1 - q_exact_m1)\n    \n    # Return the maximum of the two errors\n    return np.maximum(error_p1, error_m1)\n\ndef solve():\n    \"\"\"\n    Main solver function that runs all test cases and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: polynomial, happy path\n        {'N': 8, 'T': lambda y: y**4, 'Tp': lambda y: 4 * y**3, 'name': 'y^4, N=8'},\n        # Case 2: exponential, moderate gradient\n        {'N': 24, 'T': lambda y: np.exp(3 * y), 'Tp': lambda y: 3 * np.exp(3 * y), 'name': 'exp(3y), N=24'},\n        # Case 3: hyperbolic cosine, moderate resolution\n        {'N': 16, 'T': lambda y: np.cosh(5 * y), 'Tp': lambda y: 5 * np.sinh(5 * y), 'name': 'cosh(5y), N=16'},\n        # Case 4: sine in radians, small N\n        {'N': 8, 'T': lambda y: np.sin(np.pi * y), 'Tp': lambda y: np.pi * np.cos(np.pi * y), 'name': 'sin(pi*y), N=8'},\n        # Case 5: exponential, steep gradient\n        {'N': 32, 'T': lambda y: np.exp(10 * y), 'Tp': lambda y: 10 * np.exp(10 * y), 'name': 'exp(10y), N=32'},\n    ]\n\n    results = []\n    for case in test_cases:\n        error = calculate_wall_flux_error(case['N'], case['T'], case['Tp'])\n        results.append(f\"{error:.16e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}