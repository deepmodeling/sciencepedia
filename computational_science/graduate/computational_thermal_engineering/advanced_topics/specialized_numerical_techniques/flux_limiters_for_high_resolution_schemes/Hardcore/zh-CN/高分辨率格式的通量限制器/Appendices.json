{
    "hands_on_practices": [
        {
            "introduction": "理论是抽象的，但其影响是具体的。本练习旨在通过一个直接的计算，揭示通量限制器在高分辨率格式中的核心作用。我们将手动计算一个给定数据点序列的界面温度，从而直观地理解通量限制器函数（如 van Albada 限制器）如何根据局部解的光滑度来调整数值通量，并将其与无限制的二阶格式进行比较。这个实践将帮助你把抽象的数学公式与数值耗散这一关键物理概念联系起来。",
            "id": "3955144",
            "problem": "考虑由无源标量的能量守恒定律 $\\frac{\\partial T}{\\partial t} + a \\frac{\\partial T}{\\partial x} = 0$ 控制的一维、常系数温度平流，其中平流速度 $a>0$ 为正。在一个具有节点 $x_i$、单元平均值 $T_i$ 和数值对流通量 $F_{i+1/2} = a\\,T_{i+1/2}^{-}$ 的均匀、单元中心的有限体积离散网格上，其中 $T_{i+1/2}^{-}$ 表示在 $x_{i+1/2}$ 处的左侧重构界面温度。在高分辨率的总变差递减 (TVD) 守恒律的单调上游中心格式 (MUSCL) 重构中，单元 $i$ 内的分段线性斜率受到一个应用于上游梯度的通量限制器 $\\phi(r)$ 的限制。van Albada 限制器由下式指定：\n$$\n\\phi(r) = \\frac{r^{2} + r}{1 + r^{2}},\n$$\n对于 $a>0$，无量纲梯度比定义为：\n$$\nr = \\frac{T_{i} - T_{i-1}}{T_{i+1} - T_{i}}。\n$$\n给定网格序列 $(T_{i-1}, T_i, T_{i+1}) = (\\,300\\,\\text{K},\\,330\\,\\text{K},\\,365\\,\\text{K}\\,)$ 和 $a = 0.25\\,\\text{m}\\,\\text{s}^{-1}$，使用带有 van Albada 限制器的 TVD-MUSCL 方法重构 $x_{i+1/2}$ 处的左侧界面温度 $T_{i+1/2}^{-}$。然后，通过比较 $F_{i+1/2}$ 的值，解释相对于对应于 $\\phi(r)=1$ 的无限制上游线性重构，对流通量中增量数值扩散的符号和大小。\n\n将您最终计算的 $T_{i+1/2}^{-}$ 四舍五入到四位有效数字。以开尔文表示界面温度。",
            "solution": "该问题要求使用总变差递减 (TVD) 守恒律的单调上游中心格式 (MUSCL) 方法重构界面温度，然后解释由通量限制器引入的数值扩散。\n\n控制方程是温度 $T$ 的一维线性平流方程：\n$$\n\\frac{\\partial T}{\\partial t} + a \\frac{\\partial T}{\\partial x} = 0\n$$\n其中平流速度 $a$ 为正，表示流动方向从左到右。\n\n在有限体积框架中，单元 $i$ 的半离散形式为：\n$$\n\\frac{d T_i}{dt} = -\\frac{1}{\\Delta x} (F_{i+1/2} - F_{i-1/2})\n$$\n其中 $T_i$ 是单元平均温度，$F_{i\\pm1/2}$ 是单元界面处的数值通量。问题指定通量为 $F_{i+1/2} = a\\,T_{i+1/2}^{-}$，其中 $T_{i+1/2}^{-}$ 是在界面 $x_{i+1/2}$ 左侧的重构温度。\n\n对于一个具有上游偏置斜率（因为 $a>0$）的 MUSCL 格式，单元 $i$ 内温度的分段线性重构在其右侧面 $x_{i+1/2}$ 处得到的值为：\n$$\nT_{i+1/2}^{-} = T_i + \\frac{1}{2} \\sigma_i \\Delta x\n$$\n其中 $\\sigma_i$ 是单元 $i$ 中受限的斜率。问题指出限制器应用于上游梯度。对于 $a>0$，单元 $i$ 的上游梯度基于单元 $i$ 和 $i-1$ 中的数据。无限制的上游偏置斜率为 $\\sigma_{i, \\text{unlim}} = (T_i - T_{i-1}) / \\Delta x$。\n\n将通量限制器 $\\phi(r)$ 应用于此斜率，得到受限斜率：\n$$\n\\sigma_i = \\phi(r_i) \\frac{T_i - T_{i-1}}{\\Delta x}\n$$\n将此代入重构公式，得到左侧界面温度的表达式：\n$$\nT_{i+1/2}^{-} = T_i + \\frac{1}{2} \\left( \\phi(r_i) \\frac{T_i - T_{i-1}}{\\Delta x} \\right) \\Delta x = T_i + \\frac{1}{2} \\phi(r_i) (T_i - T_{i-1})\n$$\n问题提供了必要的数据：$T_{i-1} = 300\\,\\text{K}$，$T_i = 330\\,\\text{K}$，和 $T_{i+1} = 365\\,\\text{K}$。\n\n首先，我们计算单元 $i$ 处的无量纲梯度比 $r$：\n$$\nr_i = \\frac{T_{i} - T_{i-1}}{T_{i+1} - T_{i}} = \\frac{330 - 300}{365 - 330} = \\frac{30}{35} = \\frac{6}{7}\n$$\n接下来，我们计算当 $r = 6/7$ 时，van Albada 通量限制器函数 $\\phi(r)$ 的值：\n$$\n\\phi(r) = \\frac{r^{2} + r}{1 + r^{2}} \\implies \\phi\\left(\\frac{6}{7}\\right) = \\frac{\\left(\\frac{6}{7}\\right)^{2} + \\frac{6}{7}}{1 + \\left(\\frac{6}{7}\\right)^{2}} = \\frac{\\frac{36}{49} + \\frac{42}{49}}{\\frac{49}{49} + \\frac{36}{49}} = \\frac{\\frac{78}{49}}{\\frac{85}{49}} = \\frac{78}{85}\n$$\n现在，我们可以计算重构的界面温度 $T_{i+1/2}^{-}$：\n$$\nT_{i+1/2}^{-} = T_i + \\frac{1}{2} \\phi(r_i) (T_i - T_{i-1}) = 330 + \\frac{1}{2} \\left(\\frac{78}{85}\\right) (330 - 300)\n$$\n$$\nT_{i+1/2}^{-} = 330 + \\frac{1}{2} \\left(\\frac{78}{85}\\right) (30) = 330 + \\frac{1170}{85} = 330 + \\frac{234}{17}\n$$\n数值上，这个值是：\n$$\nT_{i+1/2}^{-} \\approx 330 + 13.76470588... = 343.76470588...\\,\\text{K}\n$$\n按要求四舍五入到四位有效数字，得到：\n$$\nT_{i+1/2}^{-} \\approx 343.8\\,\\text{K}\n$$\n为了解释限制器的效果，我们将此结果与无限制的上游线性重构进行比较，后者对应于设置 $\\phi(r)=1$。这代表了一个纯二阶完全上游格式。\n$$\nT_{i+1/2, \\text{unlim}}^{-} = T_i + \\frac{1}{2} (1) (T_i - T_{i-1}) = 330 + \\frac{1}{2} (30) = 330 + 15 = 345\\,\\text{K}\n$$\n相应的数值通量是用 $a = 0.25\\,\\text{m}\\,\\text{s}^{-1}$ 计算的：\n$$\nF_{i+1/2, \\text{limited}} = a \\cdot T_{i+1/2}^{-} = 0.25 \\times \\left(330 + \\frac{1170}{85}\\right) \\approx 0.25 \\times 343.7647 = 85.94117...\\,\\text{W}\\,\\text{m}^{-2}\\text{ (如果T是焓的代表)}\n$$\n$$\nF_{i+1/2, \\text{unlim}} = a \\cdot T_{i+1/2, \\text{unlim}}^{-} = 0.25 \\times 345 = 86.25\\,\\text{W}\\,\\text{m}^{-2}\n$$\n一阶上游格式，已知是扩散性最强但无振荡的，将使用 $T_{i+1/2}^{-} = T_i = 330\\,\\text{K}$。其通量将是 $F_{i+1/2, \\text{1st}} = 0.25 \\times 330 = 82.5\\,\\text{W}\\,\\text{m}^{-2}$。\n\n限制器的值为 $\\phi(r_i) = 78/85 \\approx 0.9176$，小于 $1$。这导致重构温度 $T_{i+1/2}^{-} \\approx 343.8\\,\\text{K}$ 低于无限制二阶值 $T_{i+1/2, \\text{unlim}}^{-} = 345\\,\\text{K}$，并且更接近一阶值 $T_{i+1/2, \\text{1st}}^{-} = 330\\,\\text{K}$。\n\n这种向一阶上游结果的偏移是增加数值扩散的定义性特征。高阶格式在陡峭梯度附近可能引入非物理振荡（过冲和下冲）。通量限制器的作用是添加恰到好处的数值扩散来抑制这些振荡并强制单调性（TVD 属性），代价是在光滑区域的精度略低于无限制格式。\n\n因此，由限制器引入的增量数值扩散的符号是正的（即增加了扩散）。这种效应的大小反映在重构温度和相应对流通量的降低上。通量从 $F_{i+1/2, \\text{unlim}} = 86.25$ 减少到 $F_{i+1/2, \\text{limited}} \\approx 85.94$。通量之差 $\\Delta F = F_{i+1/2, \\text{unlim}} - F_{i+1/2, \\text{limited}} > 0$ 代表了限制器应用的耗散修正。\n$$\n\\Delta F = a \\frac{1}{2} (1 - \\phi(r_i)) (T_i - T_{i-1}) = 0.25 \\times \\frac{1}{2} \\left(1 - \\frac{78}{85}\\right) (30) = 0.25 \\times 15 \\times \\frac{7}{85} = \\frac{21}{68} \\approx 0.3088\n$$\n这个正值证实了限制器的作用是相对于无限制二阶重构增加了格式的耗散。",
            "answer": "$$\n\\boxed{343.8}\n$$"
        },
        {
            "introduction": "在构建了数值格式之后，验证其是否达到了预期的设计精度是计算方法学中的一个关键步骤。本实践将指导你编写一个完整的有限体积求解器，用于求解一个光滑正弦波的对流问题，并应用 van Leer 通量限制器。通过执行网格加密研究，你将学习如何量化数值误差，并凭经验验证该高分辨率格式在光滑解区域确实能达到理论上的二阶精度。这项练习不仅能巩固你对通量限制器实施的理解，还能让你掌握计算科学中必不可少的代码验证技能。",
            "id": "3955097",
            "problem": "一个光滑标量场的一维线性平流由守恒律 $\\partial_t u + \\partial_x (a u) = 0$ 控制，其中平流速度 $a$ 为正常数。从该守恒律和在 $[0,1]$ 区间上具有 $N$ 个宽度为 $\\Delta x$ 的单元的均匀周期性网格上的守恒型有限体积离散化的定义出发，构造一个高分辨率显式更新方案。该方案使用带有 van Leer 通量限制器的通量限制上风格式，并以库朗-弗里德里希斯-列维 (CFL) 数 $\\nu \\in (0,1]$ 将解在时间上推进。对于斜率比 $r$，van Leer 限制器定义为 $\\phi_{\\mathrm{VL}}(r) = \\dfrac{r + |r|}{1 + |r|}$。在数值通量中对 $a > 0$ 使用标准的上风选择，并精确地施加周期性边界条件。\n\n物理和数值设置如下：\n\n- 区域：$x \\in [0,1]$，单位为米。使用周期性边界条件。\n- 平流速度：$a = 1\\,\\mathrm{m/s}$。\n- 初始条件：$u(x,0) = \\sin(2\\pi x)$。\n- 最终时间：$T = 1\\,\\mathrm{s}$，因此在时间 $T$ 的精确解为 $u(x,T) = \\sin(2\\pi x)$。\n- 时间步长：选择 $\\Delta t$ 以满足 $\\nu = a \\Delta t / \\Delta x$。使用 $\\nu = 0.5$，以确保对于下面定义的所有网格，$T/\\Delta t$ 都是整数。\n\n您必须：\n- 使用有限体积法以守恒形式离散化守恒律，对 $a > 0$ 的情况采用带有 van Leer 限制器的高分辨率上风通量。该限制器应通过由连续单边差分构成的斜率比 $r_i$ 来应用，并用于修正界面 $x_{i+1/2}$ 处的通量。通过构造，该方法对于 $a > 0$ 必须是 Godunov 意义下的总变差递减 (TVD) 的。清晰地实现周期性，以计算所有必需的单边差分和界面通量。\n- 使用选定的显式时间步长将解从 $t=0$ 推进到 $t=T$，以使 $T/\\Delta t$ 为整数。\n- 计算在 $t=T$ 时的离散 $L^2$ 误差，其定义为 $E_2 = \\left(\\sum_{i=1}^{N} (u_i^{\\mathrm{num}} - u_i^{\\mathrm{exact}})^2 \\, \\Delta x \\right)^{1/2}$，其中 $u_i^{\\mathrm{exact}} = \\sin(2\\pi x_i)$ 且 $x_i$ 是单元 $i$ 的中心。\n- 进行网格加密研究，并通过 $p = \\dfrac{\\log(E_2^{(1)}/E_2^{(2)})}{\\log(\\Delta x^{(1)}/\\Delta x^{(2)})}$ 估算任意两个连续网格之间的观测精度阶 $p$。\n\n使用以下网格尺寸（单元数 $N$）的测试套件：\n- 粗网格：$N = 50$。\n- 中等网格：$N = 100$。\n- 细网格：$N = 200$。\n- 极细网格：$N = 400$。\n\n数值和物理单位：距离单位必须是 $\\mathrm{m}$，时间单位是 $\\mathrm{s}$，速度单位是 $\\mathrm{m/s}$。$L^2$ 误差和观测阶 $p$ 是无量纲数。初始条件振幅和所有常数必须完全按照规定使用。\n\n您的程序必须：\n- 对于测试套件中的每个 $N$，计算在 $t=T$ 时的 $L^2$ 误差 $E_2$ 作为浮点数。\n- 计算三个观测阶 $p_{50\\to 100}$, $p_{100\\to 200}$ 和 $p_{200\\to 400}$ 作为浮点数。\n- 返回一个最终的布尔值，指示在两个最精细的网格上是否通过条件 $p_{100\\to 200} \\ge 1.8$ 和 $p_{200\\to 400} \\ge 1.8$ 验证了二阶精度。\n\n最终输出格式规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按顺序包含以下条目：$[E_{50}, E_{100}, E_{200}, E_{400}, p_{50\\to 100}, p_{100\\to 200}, p_{200\\to 400}, \\text{verified}]$，其中每个 $E_N$ 和 $p$ 都是浮点数，而 $\\text{verified}$ 是一个布尔值。例如，输出可能看起来像 $[1.23e-04,3.08e-05,7.67e-06,1.91e-06,2.00,2.00,2.00,True]$。",
            "solution": "该问题要求构建并应用一个高分辨率、通量限制的有限体积格式来求解一维线性平流方程。我们将详细介绍数值方法的推导、其实现以及误差分析和精度阶验证的步骤。\n\n控制性偏微分方程 (PDE) 是守恒形式的线性平流方程：\n$$ \\partial_t u + \\partial_x (a u) = 0 $$\n其中 $u(x,t)$ 是一个标量场，$t$ 是时间，$x$ 是空间坐标，$a$ 是给定的正常数平流速度 $a=1\\,\\mathrm{m/s}$。该问题设定在一维周期性区域 $x \\in [0,1]$ 上。\n\n我们在具有 $N$ 个单元的均匀网格上采用有限体积法。区域 $[0,1]$ 被划分为宽度为 $\\Delta x = 1/N$ 的单元 $C_i = [x_{i-1/2}, x_{i+1/2}]$，其中 $i=0, 1, \\dots, N-1$。单元中心为 $x_i = (i+0.5)\\Delta x$。在单元 $C_i$ 上对 PDE 进行积分得到：\n$$ \\int_{x_{i-1/2}}^{x_{i+1/2}} \\partial_t u \\,dx + \\int_{x_{i-1/2}}^{x_{i+1/2}} \\partial_x (au) \\,dx = 0 $$\n使用莱布尼茨法则和微积分基本定理，上式变为：\n$$ \\frac{d}{dt} \\int_{x_{i-1/2}}^{x_{i+1/2}} u \\,dx + [au]_{x_{i+1/2}} - [au]_{x_{i-1/2}} = 0 $$\n我们定义单元平均量 $u_i(t) = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) \\,dx$。单元平均量的演化方程为：\n$$ \\frac{d u_i}{dt} + \\frac{1}{\\Delta x} (F_{i+1/2} - F_{i-1/2}) = 0 $$\n此处，$F_{i \\pm 1/2}$ 表示在单元界面 $x_{i \\pm 1/2}$ 处的数值通量，它近似于这些位置的物理通量 $au$。\n\n对于时间离散化，我们使用显式前向欧拉法。全离散更新公式为：\n$$ \\frac{u_i^{n+1} - u_i^n}{\\Delta t} + \\frac{1}{\\Delta x} (F_{i+1/2}^n - F_{i-1/2}^n) = 0 $$\n$$ u_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} (F_{i+1/2}^n - F_{i-1/2}^n) $$\n其中 $u_i^n$ 是在时间 $t^n = n\\Delta t$ 时单元 $i$ 中单元平均值的近似。项 $\\frac{\\Delta t}{\\Delta x}$ 与库朗-弗里德里希斯-列维 (CFL) 数 $\\nu = \\frac{a \\Delta t}{\\Delta x}$ 相关。更新公式变为：\n$$ u_i^{n+1} = u_i^n - \\frac{\\nu}{a} (F_{i+1/2}^n - F_{i-1/2}^n) $$\n\n为了在保持稳定性（即，总变差递减，TVD）的同时实现高分辨率，我们将数值通量 $F_{i+1/2}$ 构造为一个低分辨率（一阶）通量和一个受限的高分辨率（反扩散）修正项的组合。由于平流速度 $a$ 为正，信息从左向右传播，因此我们使用上风格式。\n\n在界面 $x_{i+1/2}$ 处的一阶上风通量是：\n$$ F_{i+1/2}^{\\text{1st}} = a u_i^n $$\n针对此问题的常用二阶格式是 Lax-Wendroff 格式，其通量（对于 $a>0$）为：\n$$ F_{i+1/2}^{\\text{LW}} = a u_i^n + \\frac{a}{2}\\left(1 - \\frac{a\\Delta t}{\\Delta x}\\right)(u_{i+1}^n - u_i^n) = a u_i^n + \\frac{a(1-\\nu)}{2}(u_{i+1}^n - u_i^n) $$\nLax-Wendroff 通量与一阶上风通量之差是反扩散通量项，该项能带来更高的精度，但也可能在陡峭梯度附近引入伪振荡。\n$$ \\Phi_{i+1/2}^{\\text{AD}} = F_{i+1/2}^{\\text{LW}} - F_{i+1/2}^{\\text{1st}} = \\frac{a(1-\\nu)}{2}(u_{i+1}^n - u_i^n) $$\n高分辨率通量限制格式是通过将此反扩散通量的一部分限制后加到一阶通量上来构建的：\n$$ F_{i+1/2} = F_{i+1/2}^{\\text{1st}} + \\phi(r_{i+1/2}) \\Phi_{i+1/2}^{\\text{AD}} = a u_i^n + \\phi(r_{i+1/2}) \\frac{a(1-\\nu)}{2}(u_{i+1}^n - u_i^n) $$\n函数 $\\phi(r)$ 是通量限制器，它取决于斜率比 $r$。对于 $a>0$ 的上风格式，界面 $x_{i+1/2}$ 处通量的斜率比比较了上风单元 ($i-1$) 中的梯度与局部单元 ($i$) 中的梯度。它被定义为连续单元间差分的比率：\n$$ r_{i+1/2} = \\frac{u_i^n - u_{i-1}^n}{u_{i+1}^n - u_i^n} $$\n这个比率衡量解的局部光滑度。问题指定了 van Leer 通量限制器：\n$$ \\phi_{\\mathrm{VL}}(r) = \\frac{r + |r|}{1 + |r|} $$\n如果分母 $u_{i+1}^n - u_i^n$ 为零，$r_{i+1/2}$ 是未定义的。然而，在这种情况下，反扩散通量项 $\\Phi_{i+1/2}^{\\text{AD}}$ 也为零，因此无论限制器的值如何，修正项都为空。我们通过将修正项设置为零来处理这种情况。\n\n周期性边界条件意味着单元索引按模 $N$ 处理。例如，单元 $i=0$ 的上风邻居是单元 $i=N-1$，而单元 $i=N-1$ 的下风邻居是单元 $i=0$。这可以通过数组滚动或模运算来高效实现。\n\n每个时间步的总体算法如下：\n1. 对每个单元 $i=0, \\dots, N-1$，使用单元 $i-1$、$i$ 和 $i+1$ 的值，并采用周期性环绕，计算斜率比 $r_{i+1/2}$。\n2. 为每个界面计算 van Leer 限制器 $\\phi_{\\mathrm{VL}}(r_{i+1/2})$。\n3. 为每个界面 $i=0, \\dots, N-1$ 计算数值通量 $F_{i+1/2}$。\n4. 通过移动右界面通量数组，计算每个单元左界面的通量 $F_{i-1/2}$。\n5. 同时将所有单元平均值 $u_i^n$ 更新为 $u_i^{n+1}$。\n\n此过程重复 $N_t = T/\\Delta t$ 个时间步以达到最终时间 $T=1\\,\\mathrm{s}$。给定 $a=1\\,\\mathrm{m/s}$、$\\nu=0.5$ 和 $\\Delta x = 1/N$，时间步长为 $\\Delta t = \\nu \\Delta x / a = 0.5/N$，步数为 $N_t = T/\\Delta t = 1/(0.5/N) = 2N$，这是一个整数。\n\n在最后一个时间步之后，我们计算离散 $L^2$ 误差：\n$$ E_2 = \\left(\\sum_{i=0}^{N-1} (u_i^{\\text{num}} - u_i^{\\text{exact}})^2 \\, \\Delta x \\right)^{1/2} $$\n其中 $u_i^{\\text{num}}$ 是时间 $T$ 时单元 $i$ 中的数值解，而 $u_i^{\\text{exact}} = u(x_i, T)$。由于波速为 $a=1\\,\\mathrm{m/s}$ 且最终时间为 $T=1\\,\\mathrm{s}$，波恰好传播一个区域长度，因周期性而返回其初始状态。因此，$u(x,T) = u(x-aT,0) = \\sin(2\\pi(x-1)) = \\sin(2\\pi x)$。\n\n最后，我们使用两个具有分辨率 $N_1$ 和 $N_2$（以及相应的网格尺寸 $\\Delta x_1, \\Delta x_2$ 和误差 $E_2^{(1)}, E_2^{(2)}$）的连续网格进行网格加密研究。观测精度阶 $p$ 估计为：\n$$ p = \\frac{\\log(E_2^{(1)}/E_2^{(2)})}{\\log(\\Delta x_1/\\Delta x_2)} $$\n在我们的情况中，网格数量加倍，$\\Delta x_1/\\Delta x_2 = 2$，所以 $p = \\frac{\\log(E_2^{(1)}/E_2^{(2)})}{\\log(2)}$。我们期望对于光滑解，该格式的 $p \\approx 2$，尽管限制器可能会在极值点附近稍微降低这个值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D linear advection equation using a flux-limited finite volume scheme\n    and performs a grid refinement study.\n    \"\"\"\n    \n    # --- Physical and Numerical Parameters ---\n    grid_sizes = [50, 100, 200, 400]\n    a = 1.0  # Advection speed in m/s\n    L = 1.0  # Domain length in m\n    T = 1.0  # Final time in s\n    nu = 0.5  # CFL number\n\n    l2_errors = []\n\n    for N in grid_sizes:\n        # --- Grid and Time Step Setup ---\n        dx = L / N\n        dt = nu * dx / a\n        num_steps = int(round(T / dt))\n\n        # --- Initial Condition ---\n        # Cell centers\n        x = (np.arange(N) + 0.5) * dx\n        u = np.sin(2 * np.pi * x)\n\n        # --- Time Integration Loop ---\n        for _ in range(num_steps):\n            # Enforce periodic boundary conditions by rolling the array\n            u_im1 = np.roll(u, 1)  # u_{i-1}\n            u_ip1 = np.roll(u, -1)  # u_{i+1}\n            \n            # --- Calculate Slope Ratio r ---\n            # r_{i+1/2} = (u_i - u_{i-1}) / (u_{i+1} - u_i)\n            # which is associated with the flux F_{i+1/2}\n            \n            # Numerator of r\n            num_r = u - u_im1\n            # Denominator of r\n            den_r = u_ip1 - u\n            \n            # Handle division by zero for r\n            r = np.zeros_like(u)\n            nonzero_den_mask = (den_r != 0)\n            r[nonzero_den_mask] = num_r[nonzero_den_mask] / den_r[nonzero_den_mask]\n            \n            # --- Calculate van Leer Flux Limiter phi ---\n            # phi(r) = (r + |r|) / (1 + |r|)\n            phi = (r + np.abs(r)) / (1.0 + np.abs(r))\n\n            # --- Calculate High-Resolution Flux F_{i+1/2} ---\n            # F_{i+1/2} = a*u_i + phi * a*(1-nu)/2 * (u_{i+1} - u_i)\n            \n            # First-order upwind flux\n            flux_low = a * u\n            \n            # Anti-diffusive correction term\n            flux_correction = phi * (a * (1 - nu) / 2.0) * den_r\n            \n            # High-resolution flux at the right cell interface (i+1/2)\n            F_iph = flux_low + flux_correction\n            \n            # Flux at the left cell interface (i-1/2) by rolling\n            F_imh = np.roll(F_iph, 1)\n            \n            # --- Update Solution ---\n            # u^{n+1} = u^n - (dt/dx) * (F_{i+1/2} - F_{i-1/2})\n            u = u - (dt / dx) * (F_iph - F_imh)\n\n        # --- Error Calculation ---\n        # Exact solution at t=T is the same as the initial condition\n        u_exact = np.sin(2 * np.pi * x)\n        \n        # L2-norm of the error\n        error = np.sqrt(np.sum((u - u_exact)**2) * dx)\n        l2_errors.append(error)\n\n    # --- Order of Accuracy Calculation ---\n    orders = []\n    for i in range(len(grid_sizes) - 1):\n        # p = log(E1/E2) / log(dx1/dx2)\n        # dx1/dx2 = 2 for grid doubling\n        order = np.log(l2_errors[i] / l2_errors[i+1]) / np.log(2)\n        orders.append(order)\n\n    # --- Verification of Second-Order Accuracy ---\n    # Condition: p >= 1.8 on the two finest refinements\n    verified = (orders[1] >= 1.8) and (orders[2] >= 1.8)\n\n    # --- Final Output Formatting ---\n    results_list = l2_errors + orders + [verified]\n    # Example format: [1.23e-04,3.08e-05,7.67e-06,1.91e-06,2.00,2.00,2.00,True]\n    # We use a mix of general and scientific notation for floats to be clean\n    formatted_results = []\n    for item in results_list:\n        if isinstance(item, bool):\n            formatted_results.append(str(item))\n        else: # float\n            if abs(item)  1e-3 and item != 0:\n                 formatted_results.append(f\"{item:.6e}\")\n            else:\n                 formatted_results.append(f\"{item:.6f}\")\n    \n    print(f\"[{','.join(map(str, results_list))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "本高级练习探讨了构建稳健数值求解器时的一个关键精妙之处，即空间离散和时间积分在维持总变差不增（TVD）等稳定性时所产生的相互作用。它挑战了一个常见的误解：即一个TVD限制的空间格式本身足以防止所有振荡。通过比较像经典四阶Runge-Kutta（RK4）这样的非强稳定性保持（non-SSP）时间积分器与一个SSP积分器，你将直接观察并量化时间步进方法的选择如何引入伪振荡，即使空间部分已被仔细限制。这个实践对于理解和构建在面对激波或接触间断等挑战性问题时真正稳健的求解器至关重要。",
            "id": "3955164",
            "problem": "考虑由守恒律 $T_t + a T_x = 0$ 控制的一维线性温度平流，其定义在周期性域 $x \\in [0,1]$ 上，其中 $T(x,t)$ 是以开尔文为单位的温度，$t$ 是以秒为单位的时间，$a$ 是以米/秒为单位的恒定平流速度。使用有限体积格式，其中网格平均值 $T_i^n$ 代表在时间层 $n$ 时网格 $i$ 内 $T$ 的平均值。半离散更新由通量差分定义，\n$$\n\\frac{d T_i}{dt} = - \\frac{F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}}{\\Delta x},\n$$\n其中 $F_{i+\\frac{1}{2}}$ 是网格 $i$ 和 $i+1$ 之间网格界面上的相容数值通量，$\\Delta x$ 是以米为单位的均匀网格间距。使用带有 minmod 限制器的守恒律单调上游中心格式 (MUSCL) 重构来构造二阶空间离散，以计算界面状态。将 minmod 函数定义为\n$$\n\\operatorname{minmod}(p,q) = \\begin{cases}\n\\operatorname{sign}(p)\\min(|p|,|q|),  \\text{if } \\operatorname{sign}(p) = \\operatorname{sign}(q), \\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\n对于每个界面 $x_{i+\\frac{1}{2}}$，使用周期性索引重构左、右状态，\n$$\nT_{i+\\frac{1}{2}}^L = T_i + \\frac{1}{2}\\operatorname{minmod}\\left(T_i - T_{i-1}, T_{i+1} - T_i\\right), \\quad\nT_{i+\\frac{1}{2}}^R = T_{i+1} - \\frac{1}{2}\\operatorname{minmod}\\left(T_{i+1} - T_i, T_{i+2} - T_{i+1}\\right),\n$$\n使用 Rusanov (局部 Lax–Friedrichs) 数值通量，\n$$\nF_{i+\\frac{1}{2}} = \\frac{1}{2}\\left(a T_{i+\\frac{1}{2}}^L + a T_{i+\\frac{1}{2}}^R\\right) - \\frac{1}{2}|a|\\left(T_{i+\\frac{1}{2}}^R - T_{i+\\frac{1}{2}}^L\\right).\n$$\n使用经典的四阶龙格-库塔方法 (RK4) 或三阶强稳定性保持龙格-库塔方法 (SSPRK3)进行时间积分。前者是一种非强稳定性保持 (non-SSP) 的高阶积分器，而后者是强稳定性保持 (SSP) 的。将库朗-弗里德里希斯-列维 (CFL) 数定义为 $\\text{CFL} = \\frac{a \\Delta t}{\\Delta x}$，其中 $\\Delta t$ 是以秒为单位的时间步长。对于 SSPRK3 方法，使用 Shu–Osher 阶段，其中从 $n$ 到 $n+1$ 的更新由三个凸组合的类前向欧拉阶段给出。\n\n将时间层 $n$ 时离散温度的全变分 (在序列意义上) 定义为\n$$\n\\operatorname{TV}(T^n) = \\sum_{i=0}^{N-1} \\left| T_{i+1}^n - T_i^n \\right|,\n$$\n并采用周期性索引，使得 $T_N^n \\equiv T_0^n$。全变分递减 (TVD) 条件要求在适当的稳定性条件下，$\\operatorname{TV}(T^{n+1}) \\le \\operatorname{TV}(T^n)$。强稳定性保持 (SSP) 方法保证，如果一个给定的空间离散与前向欧拉步的组合在某个时间步长限制下是 TVD 的，那么 SSP 方法在相关的时间步长限制下也保持 TVD，因为它可以写成前向欧拉步的凸组合。像 RK4 这样的非 SSP 方法不保证 TVD，因此即使空间格式是受限的，也可能产生振荡。\n\n您的任务是构建计算实验，展示一个非 SSP 的 RK4 方法在使用了 MUSCL 空间限制的情况下仍产生振荡的案例，并通过计算全变分相对于初始全变分的最大归一化增量来量化对 TVD 条件的违反程度。对于每个实验，运行固定数量的时间步并计算\n$$\n\\mathcal{V} = \\max_{0 \\le n \\le N_{\\text{steps}}} \\frac{\\max\\left(\\operatorname{TV}(T^n) - \\operatorname{TV}(T^0), 0\\right)}{\\operatorname{TV}(T^0)}.\n$$\n将 $\\mathcal{V}$报告为无量纲的小数。如果 $\\mathcal{V} = 0$，则在运行期间未违反 TVD 条件；如果 $\\mathcal{V}  0$，则 TVD 条件被违反的程度即为报告的数值。\n\n使用以下物理参数和初始条件，确保科学真实性和单位一致性：\n- 平流速度 $a = 1 \\ \\text{m/s}$。\n- 域长度 $L = 1 \\ \\text{m}$，使用周期性边界条件。\n- 网格分辨率 $N$ 个网格；因此 $\\Delta x = L/N$ 米。\n- 时间步长 $\\Delta t = \\text{CFL} \\cdot \\Delta x / a$ 秒。\n\n使用以下包含不同积分器类型、网格分辨率、CFL 数和初始条件的测试套件。对于初始条件，定义：\n- 阶跃剖面 (单调间断)：$T(x,0) = 1 \\ \\text{K}$ 对于 $x \\in [0.3, 0.7)$，其他情况 $T(x,0) = 0 \\ \\text{K}$。\n- 平滑余弦剖面：$T(x,0) = \\frac{1}{2}\\left(1 + \\cos(2\\pi x)\\right) \\ \\text{K}$。\n\n对每个测试运行 $N_{\\text{steps}} = 20$ 个时间步并计算 $\\mathcal{V}$。\n\n测试套件：\n1. 非 SSP RK4，$\\text{CFL} = 0.95$，$N = 50$，阶跃剖面。\n2. SSPRK3，$\\text{CFL} = 0.95$，$N = 50$，阶跃剖面。\n3. 非 SSP RK4，$\\text{CFL} = 0.90$，$N = 200$，阶跃剖面。\n4. 非 SSP RK4，$\\text{CFL} = 0.95$，$N = 50$，平滑余弦剖面。\n\n您的程序应生成单行输出，其中包含四个测试案例的结果，格式为方括号内以逗号分隔的小数列表（例如，“[result1,result2,result3,result4]”）。每个数字必须是对应测试案例的 $\\mathcal{V}$ 值，四舍五入到六位小数。由于所有输出都是无量纲的比率，不应打印任何物理单位。如果使用了角度，其单位应为弧度，但此设置不需要角度单位。不得使用百分比；所有结果都必须表示为小数。",
            "solution": "问题陈述是偏微分方程数值方法领域中一个定义明确的计算实验，特别关注热工学中的输运现象。它具有科学依据、自成体系且客观。所有参数、方程和数值方法都是计算流体动力学领域的标准方法。因此，该问题是有效的，并且可以构建一个解。\n\n任务是研究一维线性平流方程 $T_t + a T_x = 0$ 的数值格式的全变分递减 (TVD) 特性。该格式结合了二阶 MUSCL 空间重构和两种不同的时间积分方法：非强稳定性保持 (non-SSP) 的经典四阶龙格-库塔 (RK4) 方法和三阶强稳定性保持龙格-库塔 (SSPRK3) 方法。目标是展示并量化非 SSP 积分器即使在空间离散旨在防止振荡的情况下，也可能引入振荡并违反 TVD 特性。\n\n解是使用有限体积法计算的。域 $x \\in [0, 1]$ 被划分为 $N$ 个宽度为 $\\Delta x = L/N = 1/N$ 的均匀网格。状态变量是网格平均温度 $T_i^n$。网格平均值 $T_i$ 演化的半离散方程由下式给出\n$$\n\\frac{d T_i}{dt} = \\mathcal{L}(T)_i = - \\frac{F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}}{\\Delta x}\n$$\n其中 $\\mathcal{L}(T)_i$ 代表空间离散算子，$F_{i+\\frac{1}{2}}$ 是网格 $i$ 和网格 $i+1$ 之间界面上的数值通量。\n\n**1. 空间离散**\n\n空间离散包括三个步骤：数据重构、通量计算和通量差分。\n\n**1.1. 带 Minmod 限制器的 MUSCL 重构**\n\n为实现空间上的二階精度，我们从网格平均值重构每个网格内的温度分布。在每个网格界面 $x_{i+\\frac{1}{2}}$ 处，我们通过带斜率限制的线性重构来确定左状态 $T_{i+\\frac{1}{2}}^L$ 和右状态 $T_{i+\\frac{1}{2}}^R$。\n\n每个网格 $i$ 中的斜率（记为 $\\Delta_i$）受到限制，以防止在陡峭梯度附近产生伪振荡。minmod 限制器用于此目的。它比较后向差分 $T_i - T_{i-1}$ 和前向差分 $T_{i+1} - T_i$。受限斜率由 $\\sigma_i = \\operatorname{minmod}(T_i - T_{i-1}, T_{i+1} - T_i)$ 给出，其中 minmod 函数定义为\n$$\n\\operatorname{minmod}(p,q) = \\begin{cases}\n\\operatorname{sign}(p)\\min(|p|,|q|),  \\text{if } \\operatorname{sign}(p) = \\operatorname{sign}(q) \\\\\n0,  \\text{otherwise}\n\\end{cases}\n$$\n该限制器确保重构值不会引入新的局部极值，这是 TVD 格式的一个关键属性。界面 $x_{i+\\frac{1}{2}}$ 处的重构状态则为：\n$$\nT_{i+\\frac{1}{2}}^L = T_i + \\frac{1}{2}\\sigma_i\n$$\n$$\nT_{i+\\frac{1}{2}}^R = T_{i+1} - \\frac{1}{2}\\sigma_{i+1}\n$$\n通过对域边界处的网格索引进行环绕处理来施加周期性边界条件。例如，对于网格 $i=0$，值 $T_{i-1}$ 取为 $T_{N-1}$。\n\n**1.2. Rusanov (局部 Lax-Friedrichs) 通量**\n\n利用每个界面上的左、右状态，使用 Rusanov 公式计算数值通量 $F_{i+\\frac{1}{2}}$。该通量是鲁棒的，并引入与局部波速成正比的数值耗散。\n$$\nF_{i+\\frac{1}{2}} = \\frac{1}{2}\\left(a T_{i+\\frac{1}{2}}^L + a T_{i+\\frac{1}{2}}^R\\right) - \\frac{1}{2}|a|\\left(T_{i+\\frac{1}{2}}^R - T_{i+\\frac{1}{2}}^L\\right)\n$$\n由于平流速度给定为 $a=1 \\ \\text{m/s} > 0$，这简化为迎风通量 $F_{i+\\frac{1}{2}} = a T_{i+\\frac{1}{2}}^L$。\n\n**2. 时间离散**\n\n半离散系统 $\\frac{dT}{dt} = \\mathcal{L}(T)$ 是一个常微分方程组，使用龙格-库塔方法求解。\n\n**2.1. 三阶强稳定性保持龙格-库塔 (SSPRK3)**\n\nSSP 方法旨在保持前向欧拉方法的稳定性属性 (如 TVD 特性)。SSPRK3 方法通过三个阶段将解从时间 $n$推进到 $n+1$：\n$$\n\\begin{aligned}\nT^{(1)} = T^n + \\Delta t \\mathcal{L}(T^n) \\\\\nT^{(2)} = \\frac{3}{4}T^n + \\frac{1}{4}T^{(1)} + \\frac{1}{4}\\Delta t \\mathcal{L}(T^{(1)}) \\\\\nT^{n+1} = \\frac{1}{3}T^n + \\frac{2}{3}T^{(2)} + \\frac{2}{3}\\Delta t \\mathcal{L}(T^{(2)})\n\\end{aligned}\n$$\n如果在某个 CFL 条件下，空间算子 $\\mathcal{L}$ 与前向欧拉耦合是 TVD 的，SSPRK3 保证全离散格式在相关的 CFL 条件下也是 TVD 的。\n\n**2.2. 经典四阶龙格-库塔 (RK4)**\n\n经典的 RK4 方法以其高精度而聞名，但它不是一种 SSP 方法。这意味着即使空间格式在前向欧拉下是 TVD 的，它也可能违反 TVD 特性。其阶段为：\n$$\n\\begin{aligned}\nk_1 = \\mathcal{L}(T^n) \\\\\nk_2 = \\mathcal{L}(T^n + \\frac{\\Delta t}{2} k_1) \\\\\nk_3 = \\mathcal{L}(T^n + \\frac{\\Delta t}{2} k_2) \\\\\nk_4 = \\mathcal{L}(T^n + \\Delta t k_3) \\\\\nT^{n+1} = T^n + \\frac{\\Delta t}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n\\end{aligned}\n$$\n这些系数不满足 SSP 方法所需的凸组合性质。\n\n**3. TVD 违反情况的评估**\n\n为量化性能，我们测量每个时间步 $n$ 处离散解的全变分 (TV)：\n$$\n\\operatorname{TV}(T^n) = \\sum_{i=0}^{N-1} |T_{i+1}^n - T_i^n|\n$$\n其中由于周期性，$T_N^n \\equiv T_0^n$。如果对所有 $n$ 都有 $\\operatorname{TV}(T^{n+1}) \\le \\operatorname{TV}(T^n)$，则格式是 TVD 的。我们计算仿真过程中 TV 的最大归一化增量，由度量 $\\mathcal{V}$ 定义：\n$$\n\\mathcal{V} = \\max_{0 \\le n \\le N_{\\text{steps}}} \\frac{\\max\\left(\\operatorname{TV}(T^n) - \\operatorname{TV}(T^0), 0\\right)}{\\operatorname{TV}(T^0)}\n$$\n$\\mathcal{V} = 0$ 的值表示未观察到 TVD 违反，而 $\\mathcal{V} > 0$ 则量化了违反的程度。\n\n**4. 实现与测试流程**\n\n对指定的四个测试案例中的每一个都进行仿真。流程如下：\n1.  定义包含 $N$ 个网格的网格，网格中心为 $x_i = (i+0.5)\\Delta x$。\n2.  基于给定的剖面（阶跃或余弦），在网格中心采样，初始化温度数组 $T^0$。\n3.  计算恒定时间步长 $\\Delta t = \\text{CFL} \\cdot \\Delta x / a$。\n4.  计算初始全变分 $\\operatorname{TV}(T^0)$。\n5.  迭代 $N_{\\text{steps}} = 20$ 个时间步。在每一步中，使用指定的时间积分器 (SSPRK3 或 RK4) 更新解 $T^n \\to T^{n+1}$。\n6.  在每一步，计算并存储 $\\operatorname{TV}(T^n)$。\n7.  仿真结束后，根据存储的全变分值历史记录计算度量 $\\mathcal{V}$。\n\n此流程被系统地应用于所有测试案例，并报告所得的 $\\mathcal{V}$ 值。实现使用向量化的 `NumPy` 操作以提高效率。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation test suite and print results.\n    \"\"\"\n\n    def minmod(p, q):\n        \"\"\"\n        Vectorized minmod limiter function.\n        \"\"\"\n        sign_p = np.sign(p)\n        result = np.zeros_like(p)\n        # The condition sign(p) * sign(q) > 0 is a concise way to handle signs\n        # and avoids issues with np.sign(0) = 0.\n        idx = np.where(sign_p * np.sign(q) > 0)\n        result[idx] = sign_p[idx] * np.minimum(np.abs(p[idx]), np.abs(q[idx]))\n        return result\n\n    def compute_rhs(T, dx, a):\n        \"\"\"\n        Computes the right-hand side of the semi-discrete finite volume scheme.\n        This corresponds to the spatial operator L(T).\n        \"\"\"\n        # Periodic boundary conditions via np.roll\n        T_im1 = np.roll(T, 1)\n        T_ip1 = np.roll(T, -1)\n\n        # MUSCL reconstruction with minmod limiter\n        # Slope in each cell i is based on differences with neighbors\n        delta_backward = T - T_im1\n        delta_forward = T_ip1 - T\n        sigma = minmod(delta_backward, delta_forward)\n\n        # Reconstructed states at interface i+1/2\n        # T_L corresponds to T_{i+1/2}^L, T_R to T_{i+1/2}^R\n        T_L = T + 0.5 * sigma\n        T_R = T_ip1 - 0.5 * np.roll(sigma, -1)\n\n        # Rusanov (local Lax-Friedrichs) flux\n        # F_flux[i] corresponds to F_{i+1/2}\n        flux_avg = 0.5 * (a * T_L + a * T_R)\n        dissipation = 0.5 * np.abs(a) * (T_R - T_L)\n        F_flux = flux_avg - dissipation\n\n        # Flux difference for each cell i: F_{i+1/2} - F_{i-1/2}\n        rhs = -(F_flux - np.roll(F_flux, 1)) / dx\n        return rhs\n\n    def ssprk3_step(T, dt, dx, a):\n        \"\"\"\n        Performs one time step using the third-order SSP Runge-Kutta method.\n        \"\"\"\n        T1 = T + dt * compute_rhs(T, dx, a)\n        T2 = 0.75 * T + 0.25 * (T1 + dt * compute_rhs(T1, dx, a))\n        T_next = (1.0 / 3.0) * T + (2.0 / 3.0) * (T2 + dt * compute_rhs(T2, dx, a))\n        return T_next\n\n    def rk4_step(T, dt, dx, a):\n        \"\"\"\n        Performs one time step using the classical fourth-order Runge-Kutta method.\n        \"\"\"\n        k1 = compute_rhs(T, dx, a)\n        k2 = compute_rhs(T + 0.5 * dt * k1, dx, a)\n        k3 = compute_rhs(T + 0.5 * dt * k2, dx, a)\n        k4 = compute_rhs(T + dt * k3, dx, a)\n        T_next = T + (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n        return T_next\n\n    def total_variation(T):\n        \"\"\"\n        Computes the total variation of a discrete solution with periodic boundaries.\n        \"\"\"\n        return np.sum(np.abs(T - np.roll(T, 1)))\n\n    def run_simulation(integrator, cfl, N, ic_profile, n_steps):\n        \"\"\"\n        Runs a single simulation case and computes the TVD violation metric V.\n        \"\"\"\n        # Physical and grid parameters\n        L = 1.0\n        a = 1.0\n        dx = L / N\n        dt = cfl * dx / a\n\n        x = (np.arange(N) + 0.5) * dx\n\n        # Initial conditions\n        if ic_profile == 'step':\n            T = np.where((x >= 0.3)  (x  0.7), 1.0, 0.0)\n        elif ic_profile == 'cosine':\n            T = 0.5 * (1.0 + np.cos(2.0 * np.pi * x))\n        else:\n            raise ValueError(\"Unknown initial condition profile.\")\n\n        # Determine the time stepping function\n        if integrator == 'RK4':\n            step_func = rk4_step\n        elif integrator == 'SSPRK3':\n            step_func = ssprk3_step\n        else:\n            raise ValueError(\"Unknown integrator.\")\n\n        # Compute initial total variation\n        tv0 = total_variation(T)\n        if tv0 == 0.0:\n            return 0.0 # No variation to increase\n\n        tv_history = [tv0]\n        \n        T_current = T.copy()\n        for _ in range(n_steps):\n            T_current = step_func(T_current, dt, dx, a)\n            tv_history.append(total_variation(T_current))\n\n        # Compute the metric V\n        tv_history = np.array(tv_history)\n        max_tv_increase = np.max(np.maximum(tv_history - tv0, 0))\n        \n        V = max_tv_increase / tv0\n        \n        return V\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'integrator': 'RK4', 'cfl': 0.95, 'N': 50, 'ic_profile': 'step', 'n_steps': 20},\n        {'integrator': 'SSPRK3', 'cfl': 0.95, 'N': 50, 'ic_profile': 'step', 'n_steps': 20},\n        {'integrator': 'RK4', 'cfl': 0.90, 'N': 200, 'ic_profile': 'step', 'n_steps': 20},\n        {'integrator': 'RK4', 'cfl': 0.95, 'N': 50, 'ic_profile': 'cosine', 'n_steps': 20},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(**case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}