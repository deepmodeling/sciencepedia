{
    "hands_on_practices": [
        {
            "introduction": "在开发任何自适应时间步进策略之前，我们必须首先理解限制时间步长的根本原因。对于显式时间积分方法，其主要限制来自于数值稳定性。本练习将通过对半离散热方程进行特征值分析，揭示显式欧拉法稳定性的内在机理，并指导您为一个具体的一维有限元网格计算出最大的允许时间步长 。这构成了理解和避免数值发散的第一步。",
            "id": "3934582",
            "problem": "考虑一根均匀杆中的一维瞬态热传导，使用线性单元的有限元（FE）方法进行离散化。半离散系统具有标准形式 $M \\, \\dot{T}(t) + K \\, T(t) = F(t)$，其中 $M$ 是对称正定（SPD）的电容（质量）矩阵，$K$ 是对称正定（SPD）的电导（刚度）矩阵。应用显式单步法来在时间上推进温度向量 $T(t)$。\n\nA部分（推导）：从半离散热方程出发，对齐次系统（$F(t)=0$）使用前向欧拉显式离散化，通过沿 $M^{-1}K$ 的特征模态分解动力学来进行线性稳定性分析。根据 $M^{-1}K$ 的最大特征值推导显式时间步长的稳定性界限。\n\nB部分（计算）：考虑一根长度为 $L=0.3\\,\\text{m}$、均匀横截面积为 $A=1.0\\times 10^{-4}\\,\\text{m}^{2}$ 的杆，其热导率为 $k=200\\,\\text{W}\\,\\text{m}^{-1}\\,\\text{K}^{-1}$，密度为 $\\rho=7800\\,\\text{kg}\\,\\text{m}^{-3}$，比热容为 $c=500\\,\\text{J}\\,\\text{kg}^{-1}\\,\\text{K}^{-1}$。杆的两端保持零温度（狄利克雷边界条件 $T(0,t)=0$ 和 $T(L,t)=0$）。用一个包含四个节点（节点1、2、3、4）和三个等长线性单元的均匀网格对区域进行离散化，并使用一致的单元电容和电导矩阵\n$$\nM^{(e)}=\\frac{\\rho c A h}{6}\\begin{bmatrix}2  1 \\\\ 1  2\\end{bmatrix},\\qquad\nK^{(e)}=\\frac{k A}{h}\\begin{bmatrix}1  -1 \\\\ -1  1\\end{bmatrix},\n$$\n其中 $h=L/3$。组装全局矩阵，在节点1和4处施加狄利克雷边界条件，并提取内部节点2和3的降阶 $2\\times 2$ 系统。计算此降阶系统的 $M^{-1}K$ 的最大特征值 $\\lambda_{\\max}$，然后确定由A部分中的稳定性界限预测的最大稳定时间步长 $\\Delta t_{\\max}$。\n\n以秒为单位表示最终的 $\\Delta t_{\\max}$，并将答案四舍五入到四位有效数字。",
            "solution": "控制半离散热方程为\n$$\nM \\, \\dot{T}(t) + K \\, T(t) = F(t),\n$$\n其中对于标准的热物理性质和适定的边界条件，$M$ 和 $K$ 是对称正定（SPD）矩阵。为了进行线性稳定性分析，我们考虑齐次系统 $F(t)=0$，得到\n$$\n\\dot{T}(t) = -M^{-1}K\\,T(t).\n$$\n我们将前向欧拉显式格式应用于此线性系统：\n$$\nT^{n+1} = T^{n} + \\Delta t \\,\\dot{T}^{n} = T^{n} - \\Delta t \\, M^{-1}K\\,T^{n} = \\left(I - \\Delta t \\, M^{-1}K\\right) T^{n}.\n$$\n设 $M^{-1}K$ 容许特征对 $\\{(\\lambda_{i},v_{i})\\}$ 的特征分解，其中 $M^{-1}K\\,v_{i}=\\lambda_{i} v_{i}$，并且由于 $K$ 和 $M$ 的对称正定性，所有 $\\lambda_{i}0$ 且存在一组完备的特征向量。在特征基中展开 $T^{n}$，$T^{n}=\\sum_{i}\\alpha_{i}^{n} v_{i}$，则沿每个模态的递推关系为\n$$\n\\alpha_{i}^{n+1} = \\left(1 - \\Delta t \\,\\lambda_{i}\\right)\\alpha_{i}^{n}.\n$$\n标量放大因子为 $g_{i}(\\Delta t)=1 - \\Delta t \\,\\lambda_{i}$。对于线性测试方程，当前向欧拉格式对所有模态满足 $|g_{i}(\\Delta t)|\\leq 1$ 时是稳定的。因为 $\\lambda_{i}0$，条件 $|1 - \\Delta t \\,\\lambda_{i}|\\leq 1$ 可简化为\n$$\n-1 \\leq 1 - \\Delta t \\,\\lambda_{i} \\leq 1 \\quad \\Longrightarrow \\quad 0 \\leq \\Delta t \\,\\lambda_{i} \\leq 2.\n$$\n因此，所有模态的稳定性要求\n$$\n\\Delta t \\leq \\frac{2}{\\lambda_{\\max}},\n$$\n其中 $\\lambda_{\\max}=\\max_{i}\\lambda_{i}$ 是 $M^{-1}K$ 的谱半径。\n\n我们现在为指定的网格和材料数据计算 $\\lambda_{\\max}$。网格有4个节点和3个等长单元，所以 $h=L/3$。由于 $L=0.3$，我们有 $h=0.1$。单元矩阵为\n$$\nM^{(e)}=\\frac{\\rho c A h}{6}\\begin{bmatrix}2  1 \\\\ 1  2\\end{bmatrix},\\qquad K^{(e)}=\\frac{k A}{h}\\begin{bmatrix}1  -1 \\\\ -1  1\\end{bmatrix}.\n$$\n数值上，\n$$\n\\rho c = 7800\\times 500 = 3.9\\times 10^{6},\\quad A h = (1.0\\times 10^{-4})\\times 0.1 = 1.0\\times 10^{-5},\n$$\n所以\n$$\n\\frac{\\rho c A h}{6} = \\frac{3.9\\times 10^{6}\\times 1.0\\times 10^{-5}}{6} = \\frac{39}{6} = 6.5,\n$$\n以及\n$$\n\\frac{k A}{h} = \\frac{200\\times 1.0\\times 10^{-4}}{0.1} = 0.2.\n$$\n因此，\n$$\nM^{(e)}=\\begin{bmatrix}13  6.5 \\\\ 6.5  13\\end{bmatrix},\\qquad K^{(e)}=0.2\\begin{bmatrix}1  -1 \\\\ -1  1\\end{bmatrix}.\n$$\n对三个单元 $(1\\text{–}2)$、$(2\\text{–}3)$、$(3\\text{–}4)$ 进行组装，得到 $4\\times 4$ 的全局矩阵。在节点1和4处施加齐次狄利克雷边界条件，可将其简化为节点2和3处的内部自由度。降阶后的 $2\\times 2$ 矩阵为\n$$\nM=\\begin{bmatrix}26  6.5 \\\\ 6.5  26\\end{bmatrix},\\qquad K=\\begin{bmatrix}0.4  -0.2 \\\\ -0.2  0.4\\end{bmatrix}.\n$$\n我们求解广义特征值 $\\lambda$\n$$\nK v = \\lambda M v.\n$$\n等价地，$\\lambda$ 满足\n$$\n\\det\\!\\left(K - \\lambda M\\right)=0.\n$$\n计算行列式：\n\\begin{align*}\n\\det\\!\\left(K - \\lambda M\\right)\n= \\det\\!\\begin{bmatrix}0.4 - 26\\lambda  -0.2 - 6.5\\lambda \\\\ -0.2 - 6.5\\lambda  0.4 - 26\\lambda\\end{bmatrix} \\\\\n= (0.4 - 26\\lambda)^{2} - (-0.2 - 6.5\\lambda)^{2} \\\\\n= \\left[(0.4 - 26\\lambda) - (-0.2 - 6.5\\lambda)\\right]\\left[(0.4 - 26\\lambda) + (-0.2 - 6.5\\lambda)\\right] \\\\\n= \\left(0.6 - 19.5\\lambda\\right)\\left(0.2 - 32.5\\lambda\\right).\n\\end{align*}\n令其为零，得到两个特征值：\n$$\n0.6 - 19.5\\lambda = 0 \\quad \\Longrightarrow \\quad \\lambda_{1} = \\frac{0.6}{19.5} = \\frac{2}{65},\n$$\n$$\n0.2 - 32.5\\lambda = 0 \\quad \\Longrightarrow \\quad \\lambda_{2} = \\frac{0.2}{32.5} = \\frac{2}{325}.\n$$\n因此，\n$$\n\\lambda_{\\max} = \\frac{2}{65}.\n$$\n根据上面为前向欧拉格式推导的稳定性界限，\n$$\n\\Delta t_{\\max} = \\frac{2}{\\lambda_{\\max}} = \\frac{2}{(2/65)} = 65.\n$$\n因此，对于此网格和材料集，最大的稳定显式时间步长为 $\\Delta t_{\\max}=65$ 秒。四舍五入到四位有效数字得到 $65.00$。",
            "answer": "$$\\boxed{65.00}$$"
        },
        {
            "introduction": "仅仅满足稳定性条件通常不足以实现高效的瞬态模拟，因为在某些阶段，为了达到精度要求可能需要非常小的时间步长。本练习将指导您实现一种更先进的自适应策略，即使用嵌入式龙格-库塔方法（Runge-Kutta method）来估计和控制每一步的局部截断误差。通过将数值误差保持在预设的容差范围内，该方法能够根据解的变化动态调整时间步长，是现代自适应求解器的核心技术 。",
            "id": "3934689",
            "problem": "考虑一根长度为 $L$、热扩散系数为 $\\alpha$ 的一维均匀杆，在狄利克雷边界条件下进行瞬态热传导。其控制方程为热方程，表示为以下偏微分方程\n$$\n\\frac{\\partial T(x,t)}{\\partial t} = \\alpha \\frac{\\partial^2 T(x,t)}{\\partial x^2},\n$$\n其中 $x \\in [0,L]$ 且 $t \\ge 0$，对于所有 $t$，边界条件为 $T(0,t) = 0$ 和 $T(L,t) = 0$，初始条件为 $T(x,0) = \\sin\\left(\\frac{\\pi x}{L}\\right)$。在这些条件下，其精确解为\n$$\nT_{\\text{exact}}(x,t) = e^{-\\alpha \\left(\\frac{\\pi}{L}\\right)^2 t} \\sin\\left(\\frac{\\pi x}{L}\\right).\n$$\n使用包含 $N$ 个节点、间距为 $\\Delta x = \\frac{L}{N-1}$ 的均匀网格对区域进行空间离散化，并用二阶中心差分近似空间导数。这将为内部节点（不包括狄利克雷边界）产生一个半离散常微分方程组：\n$$\n\\frac{d\\mathbf{y}(t)}{dt} = \\mathbf{f}(\\mathbf{y}(t)) = \\alpha \\frac{1}{\\Delta x^2} \\left( \\mathbf{P}\\mathbf{y}(t) \\right),\n$$\n其中 $\\mathbf{y}(t) \\in \\mathbb{R}^{N-2}$ 是内部节点温度的向量，$\\mathbf{P}$ 是具有齐次狄利克雷条件的离散拉普拉斯算子。\n\n构建一个在区间 $t \\in [0, t_f]$ 上的时间积分算法，该算法使用一个带有嵌入式一阶方法的显式二阶方法来估计每一步的局部截断误差。对温度向量 $\\mathbf{y}$ 的误差使用欧几里得范数，并将该范数的单位视为开尔文。设计一个自适应步长控制器，其目标是达到指定的每步误差容限 $\\mathrm{tol}$，并且仅在估计的局部误差范数小于或等于 $\\mathrm{tol}$ 时才接受该步。引入最小时间步长 $\\Delta t_{\\min}$ 和最大时间步长 $\\Delta t_{\\max}$，后者需满足热方程的显式稳定性要求。如果在 $\\Delta t_{\\min}$ 时，估计的局部误差仍高于 $\\mathrm{tol}$，则接受该步以避免死锁，并以 $\\Delta t_{\\min}$ 继续。\n\n对于每次模拟，计算：\n- 达到 $t_f$ 所需的已接受时间步数 $N_{\\text{steps}}$。\n- 在 $t_f$ 时的全局欧几里得范数误差，定义为\n$$\nE_{\\text{final}} = \\left\\| \\mathbf{y}(t_f) - \\mathbf{y}_{\\text{exact}}(t_f) \\right\\|_2,\n$$\n其中 $\\mathbf{y}_{\\text{exact}}(t_f)$ 是通过在内部网格点上计算 $T_{\\text{exact}}(x_i,t_f)$ 得到的。\n\n设计一个测试，通过将容限减半并观察步数和最终误差来验证收敛率。具体来说，使用容限值 $(\\mathrm{tol}_1, \\mathrm{tol}_2)$（其中 $\\mathrm{tol}_2 = \\frac{1}{2}\\mathrm{tol}_1$）运行成对的模拟，并比较以下比率\n$$\nR_{\\text{steps}} = \\frac{N_{\\text{steps}}(\\mathrm{tol}_2)}{N_{\\text{steps}}(\\mathrm{tol}_1)}, \\quad\nR_{\\text{error}} = \\frac{E_{\\text{final}}(\\mathrm{tol}_2)}{E_{\\text{final}}(\\mathrm{tol}_1)}.\n$$\n对于一个由嵌入式一阶误差估计控制的二阶方法，其预期行为（在控制器决定时间步长且未在 $\\Delta t_{\\min}$ 或 $\\Delta t_{\\max}$ 处饱和的情况下）是 $R_{\\text{steps}}$ 约等于 $\\sqrt{2}$ 且 $R_{\\text{error}}$ 约等于 $\\frac{1}{2}$。\n\n使用以下固定的物理和数值参数：\n- 杆长：$L = 1$ 米。\n- 空间节点数：$N = 50$。\n- 最终时间：$t_f = 1.0$ 秒。\n- 最小时间步长：$\\Delta t_{\\min} = 10^{-3}$ 秒。\n- 最大时间步长：$\\Delta t_{\\max}$ 设置为显式稳定性极限的 $0.9$ 倍，即：\n$$\n\\Delta t_{\\max} = 0.9 \\cdot \\frac{\\Delta x^2}{2 \\alpha}.\n$$\n\n实现自适应控制器并运行以下参数对测试套件，其中每个测试用例都是一个参数对 $(\\alpha, \\mathrm{tol}_1, \\mathrm{tol}_2)$：\n1. $(\\alpha = 10^{-4} \\,\\text{m}^2/\\text{s}, \\mathrm{tol}_1 = 10^{-4} \\,\\text{K}, \\mathrm{tol}_2 = 5 \\times 10^{-5} \\,\\text{K})$ — 控制器在远离边界的情况下运行的常规情况。\n2. $(\\alpha = 10^{-4} \\,\\text{m}^2/\\text{s}, \\mathrm{tol}_1 = 10^{-10} \\,\\text{K}, \\mathrm{tol}_2 = 5 \\times 10^{-11} \\,\\text{K})$ — 预计将在 $\\Delta t_{\\min}$ 处饱和的边缘情况。\n3. $(\\alpha = 10^{-3} \\,\\text{m}^2/\\text{s}, \\mathrm{tol}_1 = 10^{-4} \\,\\text{K}, \\mathrm{tol}_2 = 5 \\times 10^{-5} \\,\\text{K})$ — 更高的扩散系数，以探究不同的刚度和控制器缩放特性。\n\n对于每个测试用例，计算布尔值，以指示观察到的比率是否在指定容限内满足预期：\n- 如果 $\\left|\\frac{R_{\\text{steps}} - \\sqrt{2}}{\\sqrt{2}}\\right| \\le 0.10$，则将 $b_{\\text{steps}}$ 报告为 $\\text{True}$，否则为 $\\text{False}$。\n- 如果 $\\left|\\frac{R_{\\text{error}} - \\frac{1}{2}}{\\frac{1}{2}}\\right| \\le 0.20$，则将 $b_{\\text{error}}$ 报告为 $\\text{True}$，否则为 $\\text{False}$。\n\n您的程序应生成单行输出，其中包含六个布尔值，按测试用例和度量指标的顺序列出，以逗号分隔并用方括号括起（例如，“[b1,b2,b3,b4,b5,b6]”），其中对于每个测试用例，第一个布尔值对应于 $b_{\\text{steps}}$，第二个对应于 $b_{\\text{error}}$。所有涉及时间的量都必须以秒为单位表示，所有误差范数都必须以开尔文为单位考虑。不涉及角度。",
            "solution": "该问题要求构建并验证一种用于求解一维瞬态热方程的自适应时间步长算法。该解决方案遵循偏微分方程（PDEs）数值分析的既定原则，特别是采用线方法结合嵌入式龙格-库塔格式进行时间积分。\n\n### 1. 使用线方法进行半离散化\n\n控制偏微分方程为\n$$\n\\frac{\\partial T(x,t)}{\\partial t} = \\alpha \\frac{\\partial^2 T(x,t)}{\\partial x^2}\n$$\n其中 $x \\in [0, L]$ 且 $t \\ge 0$。第一步是将这个单一的偏微分方程转化为一个关于时间的耦合常微分方程（ODEs）组。这通过线方法实现，即对空间域进行离散化并近似空间导数。\n\n定义一个包含 $N$ 个节点的均匀网格，因此空间坐标为 $x_i = i \\cdot \\Delta x$，其中 $i=0, 1, \\dots, N-1$，网格间距为 $\\Delta x = L/(N-1)$。令 $T_i(t) = T(x_i, t)$ 为节点 $i$ 处的温度。在内部节点 $x_i$ 处（其中 $i=1, \\dots, N-2$），二阶空间导数使用二阶中心差分格式来近似：\n$$\n\\frac{\\partial^2 T}{\\partial x^2}\\bigg|_{x=x_i} \\approx \\frac{T_{i-1}(t) - 2T_i(t) + T_{i+1}(t)}{\\Delta x^2}.\n$$\n将此近似代入每个内部节点的热方程，得到一个包含 $N-2$ 个常微分方程的方程组：\n$$\n\\frac{d T_i(t)}{dt} = \\frac{\\alpha}{\\Delta x^2} \\left( T_{i-1}(t) - 2T_i(t) + T_{i+1}(t) \\right).\n$$\n边界条件为 $T(0,t) = T_0(t) = 0$ 和 $T(L,t) = T_{N-1}(t) = 0$。这些值被纳入第一个和最后一个内部节点（$i=1$ 和 $i=N-2$）的方程中。\n\n该方程组可以写成矩阵形式 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$，其中 $\\mathbf{y}(t) = [T_1(t), T_2(t), \\dots, T_{N-2}(t)]^T$ 是内部节点的温度向量。函数 $\\mathbf{f}(\\mathbf{y})$ 代表右侧项，它是一个线性运算 $\\frac{\\alpha}{\\Delta x^2} \\mathbf{P} \\mathbf{y}$，其中 $\\mathbf{P}$ 是表示带有齐次狄利克雷边界条件的离散拉普拉斯算子的 $(N-2) \\times (N-2)$ 三对角矩阵：\n$$\n\\mathbf{P} = \\begin{pmatrix}\n-2  1  0  \\dots \\\\\n1  -2  1  \\dots \\\\\n0  1  -2  \\dots \\\\\n\\vdots    \\ddots    1 \\\\\n\\dots  0  1  -2\n\\end{pmatrix}.\n$$\n\n### 2. 使用嵌入式方法的自适应时间积分\n\n为了从初始状态 $\\mathbf{y}(0)$ 求解常微分方程组 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$，我们使用一种自适应时间步长方法。这需要一个积分器，能够在每一步提供局部截断误差的估计。嵌入式龙格-库塔方法是实现此目的的理想选择。我们选择休恩-欧拉对（Heun-Euler pair），其阶数为 $(2,1)$。\n\n在从 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的每个时间步中，我们计算解 $\\mathbf{y}_{n+1}$ 的两种近似：\n1.  **一阶（前向欧拉）解, $\\hat{\\mathbf{y}}_{n+1}$**：\n    $$\n    \\mathbf{k}_1 = \\mathbf{f}(\\mathbf{y}_n)\n    $$\n    $$\n    \\hat{\\mathbf{y}}_{n+1} = \\mathbf{y}_n + \\Delta t \\, \\mathbf{k}_1\n    $$\n2.  **二阶（休恩法）解, $\\mathbf{y}_{n+1}$**：\n    $$\n    \\mathbf{k}_2 = \\mathbf{f}(\\hat{\\mathbf{y}}_{n+1}) = \\mathbf{f}(\\mathbf{y}_n + \\Delta t \\, \\mathbf{k}_1)\n    $$\n    $$\n    \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{2} (\\mathbf{k}_1 + \\mathbf{k}_2)\n    $$\n\n这两种解之间的差异提供了低阶方法局部截断误差的估计。我们用它来代表高阶方法的误差。误差估计向量为 $\\mathbf{e}_{n+1} = \\mathbf{y}_{n+1} - \\hat{\\mathbf{y}}_{n+1}$，其欧几里得范数 $E_{\\text{local}} = \\|\\mathbf{e}_{n+1}\\|_2$ 用于步长控制。\n\n### 3. 步长控制算法\n\n自适应算法的核心是控制器，它调整时间步长 $\\Delta t$ 以满足预设的局部误差容限 $\\mathrm{tol}$。\n\n- **步长接受/拒绝**：计算 $E_{\\text{local}}$ 后，如果 $E_{\\text{local}} \\le \\mathrm{tol}$，则接受该步。如果步长被接受，则时间推进（$t_{n+1} = t_n + \\Delta t$）并更新解（$\\mathbf{y}_{n+1}$ 成为新的 $\\mathbf{y}_n$）。如果 $E_{\\text{local}}  \\mathrm{tol}$，则拒绝该步，时间不推进，并使用更小的 $\\Delta t$ 重试该步。\n- **步长更新**：新的时间步长 $\\Delta t_{\\text{new}}$ 是根据当前尝试的误差计算的。对于一个由 $p$ 阶嵌入式方法控制的 $p+1$ 阶方法（这里 $p=1$），最佳步长与误差的换算关系如下：\n$$\n\\Delta t_{\\text{new}} = S \\cdot \\Delta t_{\\text{current}} \\left( \\frac{\\mathrm{tol}}{E_{\\text{local}}} \\right)^{\\frac{1}{p+1}},\n$$\n其中 $S$ 是一个安全因子（通常为 $0.8$ - $0.9$），以防止过于乐观的步长增加。我们选择 $S=0.9$ 和 $p=1$，得到：\n$$\n\\Delta t_{\\text{new}} = 0.9 \\cdot \\Delta t_{\\text{current}} \\sqrt{\\frac{\\mathrm{tol}}{E_{\\text{local}}}}.\n$$\n无论当前步是被接受还是被拒绝，都使用此公式计算下一次尝试的步长。\n- **约束**：计算出的 $\\Delta t$ 被限制在 $[\\Delta t_{\\min}, \\Delta t_{\\max}]$ 范围内。最小步长 $\\Delta t_{\\min}$ 防止算法采用过小的步长，而最大步长 $\\Delta t_{\\max}$ 由热方程的显式稳定性极限确定：$\\Delta t_{\\text{stable}} = \\Delta x^2/(2\\alpha)$。我们使用 $\\Delta t_{\\max} = 0.9 \\cdot \\Delta t_{\\text{stable}}$。\n- **避免死锁**：问题规定，如果当前步长等于或小于 $\\Delta t_{\\min}$ 且误差仍然超过 $\\mathrm{tol}$，则必须接受该步以防止模拟停滞。这通过将接受条件修改为 `if E_local = tol or dt = dt_min` 来实现。\n\n### 4. 收敛率验证\n\n自适应积分器理论表明，对于一个 $p$ 阶主方法，全局误差应与容限成正比，$E_{\\text{global}} \\propto \\mathrm{tol}$。此外，平均步长 $\\Delta t$ 应与 $\\mathrm{tol}^{1/(p+1)}$ 成正比。\n\n对于我们的二阶方法（$p=1$ 控制 $p+1=2$），我们期望：\n-   **全局误差**：$E_{\\text{final}} \\propto \\mathrm{tol}$。将容限减半（$\\mathrm{tol}_2 = \\frac{1}{2}\\mathrm{tol}_1$）应使最终误差减半，因此比率 $R_{\\text{error}} = \\frac{E_{\\text{final}}(\\mathrm{tol}_2)}{E_{\\text{final}}(\\mathrm{tol}_1)}$ 应约等于 $\\frac{1}{2}$。\n-   **步数**：平均时间步长 $\\Delta t$ 与 $\\mathrm{tol}^{1/2}$ 成正比。覆盖固定区间 $[0, t_f]$ 的步数 $N_{\\text{steps}}$ 与平均步长成反比，因此 $N_{\\text{steps}} \\propto 1/\\Delta t \\propto \\mathrm{tol}^{-1/2}$。因此，将容限减半应使步数增加一个因子 $(1/2)^{-1/2} = \\sqrt{2}$。比率 $R_{\\text{steps}} = \\frac{N_{\\text{steps}}(\\mathrm{tol}_2)}{N_{\\text{steps}}(\\mathrm{tol}_1)}$ 应约等于 $\\sqrt{2}$。\n\n实现将针对容限对 $(\\mathrm{tol}_1, \\mathrm{tol}_2)$ 模拟系统，并检查这些理论比率是否在指定的相对误差范围内得到满足，从而确认自适应算法的正确行为。控制器在 $\\Delta t_{\\min}$ 或 $\\Delta t_{\\max}$ 处饱和的情况预计不会遵循这些缩放定律。",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef run_simulation(alpha, tol, L, N, tf, dt_min):\n    \"\"\"\n    Solves the 1D heat equation with an adaptive step-size controller.\n\n    Args:\n        alpha (float): Thermal diffusivity.\n        tol (float): Per-step error tolerance.\n        L (float): Length of the rod.\n        N (int): Number of spatial nodes.\n        tf (float): Final time.\n        dt_min (float): Minimum allowed time step.\n\n    Returns:\n        tuple: (number of accepted steps, final global error).\n    \"\"\"\n    dx = L / (N - 1)\n    dt_max = 0.9 * (dx ** 2) / (2 * alpha)\n    \n    # Interior spatial grid\n    x_interior = np.linspace(dx, L - dx, N - 2)\n    \n    # Initial condition for interior nodes\n    y = np.sin(np.pi * x_interior / L)\n    \n    # Pre-calculate constant for RHS evaluation\n    C = alpha / (dx ** 2)\n    \n    def f(y_vec):\n        \"\"\"Computes the RHS of the ODE system dy/dt = f(y).\"\"\"\n        # Pad with zero Dirichlet boundary conditions\n        y_full = np.zeros(N)\n        y_full[1:-1] = y_vec\n        # Central difference approximation\n        dydt = C * (y_full[:-2] - 2 * y_full[1:-1] + y_full[2:])\n        return dydt\n\n    t = 0.0\n    dt = dt_min  # Start with a conservative step size\n    n_steps = 0\n    safety_factor = 0.9\n\n    while t  tf:\n        # Ensure the final step lands exactly on tf\n        if t + dt > tf:\n            dt = tf - t\n\n        # Heun-Euler embedded pair\n        k1 = f(y)\n        y_euler = y + dt * k1\n        k2 = f(y_euler)\n        y_heun = y + (dt / 2.0) * (k1 + k2)\n        \n        # Estimate local error\n        error_norm = np.linalg.norm(y_heun - y_euler)\n        # Avoid division by zero if error is nil\n        if error_norm  1e-16:\n            error_norm = 1e-16\n\n        # Step acceptance condition\n        accept_step = (error_norm = tol) or (dt = dt_min)\n\n        if accept_step:\n            t += dt\n            y = y_heun\n            n_steps += 1\n        \n        # Calculate new step size for the next attempt (or next step)\n        # Based on the error of the current attempt, regardless of acceptance\n        dt_new = safety_factor * dt * (tol / error_norm)**0.5\n        \n        # Clip the new step size to the defined bounds\n        dt = min(dt_max, max(dt_min, dt_new))\n\n    # Compute final global error against the exact solution\n    y_exact_tf = np.exp(-alpha * (np.pi/L)**2 * tf) * np.sin(np.pi * x_interior / L)\n    E_final = np.linalg.norm(y - y_exact_tf)\n    \n    return n_steps, E_final\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the final results.\n    \"\"\"\n    # Fixed physical and numerical parameters\n    L = 1.0\n    N = 50\n    tf = 1.0\n    dt_min = 1.0e-3\n\n    # Test suite: (alpha, tol_1, tol_2)\n    test_cases = [\n        (1.0e-4, 1.0e-4, 5.0e-5),\n        (1.0e-4, 1.0e-10, 5.0e-11),\n        (1.0e-3, 1.0e-4, 5.0e-5),\n    ]\n\n    all_booleans = []\n\n    for alpha, tol1, tol2 in test_cases:\n        # Run simulation for the first tolerance\n        N_steps1, E_final1 = run_simulation(alpha, tol1, L, N, tf, dt_min)\n        \n        # Run simulation for the second tolerance\n        N_steps2, E_final2 = run_simulation(alpha, tol2, L, N, tf, dt_min)\n\n        # Compute ratios\n        # Avoid division by zero if a result is zero\n        R_steps = N_steps2 / N_steps1 if N_steps1 > 0 else float('inf')\n        R_error = E_final2 / E_final1 if E_final1 > 0 else float('inf')\n        \n        # Verify step count ratio against theoretical sqrt(2)\n        sqrt2 = math.sqrt(2)\n        b_steps = abs((R_steps - sqrt2) / sqrt2) = 0.10\n        all_booleans.append(b_steps)\n\n        # Verify final error ratio against theoretical 0.5\n        b_error = abs((R_error - 0.5) / 0.5) = 0.20\n        all_booleans.append(b_error)\n\n    # Format the final output string\n    print(f\"[{','.join(map(str, all_booleans))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "瞬态热传导问题常常表现出“刚性”（stiffness），即稳定性要求的时间步长远小于精度要求的时间步长，导致显式方法效率低下。为了应对这一挑战，我们可以采用一种更高级的自适应策略：在不同计算格式之间动态切换。本练习将引导您设计并实现一个基于傅里叶数（Fourier number）和滞回控制的准则，使求解器能够在计算成本低的显式方法和无条件稳定的隐式方法之间智能选择，从而在保证稳定性的前提下最大化计算效率 。",
            "id": "3934621",
            "problem": "您被要求为一维瞬态热传导问题，形式化、实现并评估一个自适应积分模式切换准则。该准则基于傅里叶数和目标容差，并包含滞后机制以防止方案间的快速振荡。目的是从第一性原理推导该准则，然后在一个程序中实现它，该程序对几个测试用例执行短期模拟并报告可量化的结果。\n\n从均匀材料的一维瞬态热方程开始，\n$$\n\\frac{\\partial T(x,t)}{\\partial t} = \\alpha \\frac{\\partial^2 T(x,t)}{\\partial x^2},\n$$\n其中 $T$ 是温度，$t$ 是时间，$x$ 是空间坐标，$\\alpha$ 是热扩散率，定义为\n$$\n\\alpha = \\frac{k}{\\rho c_p}.\n$$\n这里，$k$ 是热导率，$\\rho$ 是质量密度，$c_p$ 是定压比热容。考虑一个长度为 $L$ 的平板，其边界温度为固定的（狄利克雷）$T(0,t)=T_L$ 和 $T(L,t)=T_R$，内部被离散化为 $N$ 个均匀分布的内部节点，间距为 $\\Delta x = \\frac{L}{N+1}$。在空间上使用二阶中心差分，在时间上使用单步推进。显式前向欧拉（FE）方法和隐式后向欧拉（BE）方法将作为两种候选积分方案。\n\n将大小为 $\\Delta t$ 的一个时间步的傅里叶数（Fo）定义为\n$$\nFo = \\frac{\\alpha \\Delta t}{\\Delta x^2}.\n$$\n您必须开发一个有原则的准则，该准则使用计算出的 $Fo$ 和一个目标容差参数，在每个时间步决定是使用显式方法还是隐式方法，并在准则中包含滞后机制，以使 $Fo$ 围绕容差的微小波动不会导致立即来回切换。该准则必须从底层离散化的稳定性和精度特性以及扩散的物理原理推导出来，而不是基于临时规则。\n\n实现以下计算设置：\n\n- 空间离散化采用 $N$ 个内部节点，均匀间距 $\\Delta x$，边界温度为狄利克雷条件 $T_L$ 和 $T_R$。初始内部温度是均匀的 $T_0$。\n- 对内部节点 $i$ 的FE更新，是使用计算出的 $Fo$ 和固定的边界值，对离散拉普拉斯算子应用标准的二阶中心差分显式步。\n- BE更新通过求解一个三对角线性系统来应用，该系统由时间上的全隐式后向欧拉和空间上的二阶中心差分产生，已知的狄利克雷边界条件贡献于右端项。\n- 在每个时间步，对于一个建议的 $\\Delta t$，计算 $Fo$，应用您带滞后机制的切换准则，选择方案，并推进求解。\n\n设计您的滞后机制，使得一旦选定一个方案，Fo 在目标值周围的容差带内的微小偏离不会触发切换。您的准则必须是具体且在算法上可检查的，但在指定和实现它之前，您必须首先从离散热方程的基本性质和数值方案的放大行为中推导出它。\n\n物理单位必须一致地使用和报告。材料属性 $k$ 的单位是 $\\mathrm{W/(m\\,K)}$，$\\rho$ 的单位是 $\\mathrm{kg/m^3}$，$c_p$ 的单位是 $\\mathrm{J/(kg\\,K)}$，$L$ 的单位是 $\\mathrm{m}$，$\\Delta t$ 的单位是 $\\mathrm{s}$，$T$ 的单位是 $\\mathrm{K}$。\n\n您的程序必须处理以下参数集的测试套件。在每种情况下，除非您的准则在 $Fo$ 被评估后立即指示切换，否则在第一个时间步以显式模式开始。对于每个用例，对列出的每个 $\\Delta t$ 值执行一次更新：\n\n- 测试用例1（理想路径，显式安全区）：\n  - 材料：$k = 45\\,\\mathrm{W/(m\\,K)}$, $\\rho = 7850\\,\\mathrm{kg/m^3}$, $c_p = 500\\,\\mathrm{J/(kg\\,K)}$。\n  - 几何：$L = 0.02\\,\\mathrm{m}$, $N = 10$。\n  - 边界温度：$T_L = 400\\,\\mathrm{K}$, $T_R = 300\\,\\mathrm{K}$。\n  - 初始内部温度：$T_0 = 300\\,\\mathrm{K}$。\n  - 时间步长序列：$\\Delta t$ 列表 $[0.002, 0.003, 0.004, 0.005]\\,\\mathrm{s}$。\n  - 目标容差和滞后：目标 $ \\tau = 0.45$（无量纲），滞后半宽 $h = 0.03$（无量纲）。\n- 测试用例2（跨入需要隐式方法的区域）：\n  - 材料：$k = 45\\,\\mathrm{W/(m\\,K)}$, $\\rho = 7850\\,\\mathrm{kg/m^3}$, $c_p = 500\\,\\mathrm{J/(kg\\,K)}$。\n  - 几何：$L = 0.02\\,\\mathrm{m}$, $N = 10$。\n  - 边界温度：$T_L = 400\\,\\mathrm{K}$, $T_R = 300\\,\\mathrm{K}$。\n  - 初始内部温度：$T_0 = 300\\,\\mathrm{K}$。\n  - 时间步长序列：$\\Delta t$ 列表 $[0.1, 0.3, 0.6]\\,\\mathrm{s}$。\n  - 目标容差和滞后：目标 $ \\tau = 0.45$，滞后半宽 $h = 0.03$。\n- 测试用例3（Fo在容差附近振荡以测试滞后效应）：\n  - 材料：$k = 45\\,\\mathrm{W/(m\\,K)}$, $\\rho = 7850\\,\\mathrm{kg/m^3}$, $c_p = 500\\,\\mathrm{J/(kg\\,K)}$。\n  - 几何：$L = 0.02\\,\\mathrm{m}$, $N = 10$。\n  - 边界温度：$T_L = 400\\,\\mathrm{K}$, $T_R = 300\\,\\mathrm{K}$。\n  - 初始内部温度：$T_0 = 300\\,\\mathrm{K}$。\n  - 时间步长序列：$\\Delta t$ 列表 $[0.06, 0.05, 0.08, 0.04, 0.07]\\,\\mathrm{s}$。\n  - 目标容差和滞后：目标 $ \\tau = 0.20$，滞后半宽 $h = 0.05$。\n- 测试用例4（由于步长较大，主要使用隐式方法）：\n  - 材料：$k = 45\\,\\mathrm{W/(m\\,K)}$, $\\rho = 7850\\,\\mathrm{kg/m^3}$, $c_p = 500\\,\\mathrm{J/(kg\\,K)}$。\n  - 几何：$L = 0.02\\,\\mathrm{m}$, $N = 10$。\n  - 边界温度：$T_L = 400\\,\\mathrm{K}$, $T_R = 300\\,\\mathrm{K}$。\n  - 初始内部温度：$T_0 = 300\\,\\mathrm{K}$。\n  - 时间步长序列：$\\Delta t$ 列表 $[0.5, 0.4, 0.6, 0.7]\\,\\mathrm{s}$。\n  - 目标容差和滞后：目标 $ \\tau = 0.10$，滞后半宽 $h = 0.02$。\n\n对于每个测试用例，您的程序必须计算并返回一个包含三个值的列表：\n- 使用显式方案的步数比例，以四位小数表示。\n- 在整个时间步长序列中遇到的方案切换总次数（一个整数）。\n- 最终在所有节点（包括两个边界）上的空间平均温度（即 $T_L$、所有内部节点温度和 $T_R$ 的算术平均值），单位为 $\\mathrm{K}$，保留四位小数。\n\n您的程序应生成单行输出，其中包含测试用例的结果，形式为方括号括起来的逗号分隔列表，其中每个元素是上述描述的用于一个测试用例的列表。例如，输出必须看起来像\n$$\n[\\,[a_1,b_1,c_1],\\,[a_2,b_2,c_2],\\,[a_3,b_3,c_3],\\,[a_4,b_4,c_4]\\,]\n$$\n其中的数值由您的计算填充。不应打印任何其他输出。",
            "solution": "该问题要求为求解一维瞬态热方程开发并实现一个自适应方案切换准则。在每个时间步，选择在显式前向欧拉（FE）方法和隐式后向欧拉（BE）方法之间进行。该准则必须基于无量纲的傅里叶数、一个目标容差，并包含一个滞后机制。\n\n控制偏微分方程（PDE）是一维热方程：\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2}\n$$\n其中 $T(x,t)$ 是温度，$\\alpha = k/(\\rho c_p)$ 是热扩散率，$k$ 是热导率，$\\rho$ 是密度，$c_p$ 是比热容。空间域是 $x \\in [0, L]$。我们将此域离散化为 $N$ 个内部节点，均匀间距为 $\\Delta x = L/(N+1)$。节点的空间位置为 $x_i = i \\Delta x$，其中 $i=0, 1, \\dots, N+1$。边界条件为固定温度 $T(0,t) = T_0 = T_L$ 和 $T(L,t) = T_{N+1} = T_R$。内部节点 $i$ 在时间步 $n$ 的温度记为 $T_i^n$。\n\n对空间导数使用二阶中心差分，内部节点 $i$ 的半离散方程为：\n$$\n\\frac{d T_i}{d t} = \\alpha \\frac{T_{i+1} - 2T_i + T_{i-1}}{\\Delta x^2}\n$$\n\n我们考虑两种时间积分方案：\n\n1.  **前向欧拉（FE）方法（显式）**：该方案对时间导数使用前向差分，在当前时间步 $n$ 评估空间导数。\n    $$\n    \\frac{T_i^{n+1} - T_i^n}{\\Delta t} = \\alpha \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{\\Delta x^2}\n    $$\n    重新整理得到显式更新规则：\n    $$\n    T_i^{n+1} = T_i^n + \\frac{\\alpha \\Delta t}{\\Delta x^2} \\left( T_{i+1}^n - 2T_i^n + T_{i-1}^n \\right)\n    $$\n    引入傅里叶数 $Fo = \\frac{\\alpha \\Delta t}{\\Delta x^2}$，更新变为：\n    $$\n    T_i^{n+1} = T_i^n + Fo \\left( T_{i+1}^n - 2T_i^n + T_{i-1}^n \\right)\n    $$\n    该方法计算成本低，因为它为新温度 $T_i^{n+1}$ 提供了直接的公式。\n\n2.  **后向欧拉（BE）方法（隐式）**：该方案对时间导数使用后向差分，在未来时间步 $n+1$ 评估空间导数。\n    $$\n    \\frac{T_i^{n+1} - T_i^n}{\\Delta t} = \\alpha \\frac{T_{i+1}^{n+1} - 2T_i^{n+1} + T_{i-1}^{n+1}}{\\Delta x^2}\n    $$\n    重新整理以将未知项 $T^{n+1}$ 组合在左侧，得到一个关于内部节点 $i=1, \\dots, N$ 的线性方程组：\n    $$\n    -Fo \\, T_{i-1}^{n+1} + (1 + 2Fo) T_i^{n+1} - Fo \\, T_{i+1}^{n+1} = T_i^n\n    $$\n    该方法计算成本更高，因为它需要在每个时间步求解这个线性系统。\n\n**切换准则的推导**\n\nFE 和 BE 之间的选择取决于它们的稳定性。为了推导 FE 方法的稳定性条件，我们进行 Von Neumann 稳定性分析。我们考虑误差的单个傅里叶模式，$E_i^n = G^n e^{\\mathrm{j} k_m x_i}$，其中 $G$ 是每时间步的放大因子，$k_m$ 是波数，$\\mathrm{j}=\\sqrt{-1}$。对于一个稳定的方案，误差不能增长，这要求 $|G| \\le 1$。将误差模式代入 FE 更新方程可得：\n$$\nG^{n+1} e^{\\mathrm{j} k_m i \\Delta x} = G^n e^{\\mathrm{j} k_m i \\Delta x} + Fo \\left( G^n e^{\\mathrm{j} k_m (i+1) \\Delta x} - 2G^n e^{\\mathrm{j} k_m i \\Delta x} + G^n e^{\\mathrm{j} k_m (i-1) \\Delta x} \\right)\n$$\n除以 $G^n e^{\\mathrm{j} k_m i \\Delta x}$ 得到放大因子 $G$：\n$$\nG = 1 + Fo \\left( e^{\\mathrm{j} k_m \\Delta x} - 2 + e^{-\\mathrm{j} k_m \\Delta x} \\right) = 1 + Fo \\left( 2 \\cos(k_m \\Delta x) - 2 \\right)\n$$\n使用恒等式 $1 - \\cos(\\theta) = 2 \\sin^2(\\theta/2)$，我们得到：\n$$\nG = 1 - 4 Fo \\sin^2\\left(\\frac{k_m \\Delta x}{2}\\right)\n$$\n稳定性条件 $|G| \\le 1$ 意味着 $-1 \\le G \\le 1$。上界 $G \\le 1$ 总是满足的，因为 $Fo  0$。下界 $-1 \\le G$ 给出：\n$$\n-1 \\le 1 - 4 Fo \\sin^2\\left(\\frac{k_m \\Delta x}{2}\\right) \\implies 4 Fo \\sin^2\\left(\\frac{k_m \\Delta x}{2}\\right) \\le 2 \\implies Fo \\le \\frac{1}{2 \\sin^2(k_m \\Delta x/2)}\n$$\n该条件必须对所有可能的波数 $k_m$ 成立。最严格的条件（$Fo$ 的最小上界）发生在 $\\sin^2(k_m \\Delta x/2)$ 最大时，即为 $1$。这对应于网格能解析的最高频率（最短波长）模式，$\\lambda = 2\\Delta x$，此时 $k_m \\Delta x = \\pi$。因此，FE 方法的稳定性极限是：\n$$\nFo \\le 0.5\n$$\nBE 方法对所有 $Fo  0$ 都是无条件稳定的。其放大因子为 $G = (1 + 4 Fo \\sin^2(k_m \\Delta x/2))^{-1}$，始终满足 $0  G \\le 1$。\n\n切换的主要动机是在最小化计算成本的同时保持稳定性。FE 方法因其速度而受青睐，但仅在其稳定时。BE 方法为任何时间步长提供了稳定性，但代价是求解一个线性系统。\n\n一个有原则的切换准则可以基于稳定性极限 $Fo = 0.5$ 建立。为确保精度并避免在稳定性边界附近出现的数值振荡，我们选择一个目标阈值 $\\tau  0.5$。如果 $Fo$ 低于此目标，FE 方法将被认为是安全的。\n\n为防止在 $Fo$ 围绕 $\\tau$ 波动时发生快速切换（“抖动”），引入了滞后带。我们定义一个滞后半宽 $h$，创建一个下阈值 $T_L = \\tau - h$ 和一个上阈值 $T_H = \\tau + h$。切换逻辑形式化如下：设当前积分模式为 $M$。\n\n- 如果 $M$ 是 **显式 (FE)**：仅当傅里叶数超过上阈值时切换到 **隐式 (BE)**：$Fo > T_H$。\n- 如果 $M$ 是 **隐式 (BE)**：仅当傅里叶数低于下阈值时切换回 **显式 (FE)**：$Fo  T_L$。\n- 如果 $Fo$ 在区间 $[T_L, T_H]$ 内，则保留当前模式。\n\n初始模式设置为显式。在第一个时间步，先检查准则并选择模式，然后再执行更新。\n\n**数值方案的实现**\n\n**显式更新：**\n新时间步的温度向量 $\\mathbf{T}^{n+1}$ 直接由当前步的向量 $\\mathbf{T}^{n}$ 计算得出。对于每个内部节点 $i \\in \\{1, ..., N\\}$：\n$$\nT_i^{n+1} = T_i^n + Fo(T_{i+1}^n - 2T_i^n + T_{i-1}^n)\n$$\n边界值 $T_0^n = T_L$ 和 $T_{N+1}^n = T_R$ 分别用于 $i=1$ 和 $i=N$ 的计算。\n\n**隐式更新：**\nBE 方案需要求解三对角线性系统 $\\mathbf{A} \\mathbf{T}^{n+1} = \\mathbf{b}$ 以得到未知内部温度向量 $\\mathbf{T}^{n+1} = [T_1^{n+1}, \\dots, T_N^{n+1}]^T$。$N \\times N$ 矩阵 $\\mathbf{A}$ 的形式如下：\n$$\n\\mathbf{A} = \n\\begin{pmatrix}\n1+2Fo  -Fo  0  \\dots  0 \\\\\n-Fo  1+2Fo  -Fo  \\dots  0 \\\\\n0  \\ddots  \\ddots  \\ddots  0 \\\\\n0  \\dots  -Fo  1+2Fo  -Fo \\\\\n0  \\dots  0  -Fo  1+2Fo\n\\end{pmatrix}\n$$\n右端向量 $\\mathbf{b}$ 由前一个时间步的温度 $\\mathbf{T}^n$ 构成，并包含了固定的边界条件：\n$$\n\\mathbf{b} = \n\\begin{pmatrix}\nT_1^n + Fo \\cdot T_L \\\\\nT_2^n \\\\\n\\vdots \\\\\nT_{N-1}^n \\\\\nT_N^n + Fo \\cdot T_R\n\\end{pmatrix}\n$$\n该系统可以使用三对角矩阵算法（TDMA）或专门的带状系统求解器（如 `scipy.linalg.solve_banded`）高效求解。\n\n每个测试用例的流程是：初始化温度场和模式，然后遍历时间步长序列。在每一步中，计算 $Fo$，应用切换准则，使用适当的方案更新温度，并记录统计数据（方案选择、切换次数）。最后，计算所需的输出指标。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Solves the 1D transient heat equation using an adaptive scheme-switching\n    criterion between Forward Euler and Backward Euler methods.\n    \"\"\"\n    test_cases = [\n        {\n            \"material\": {\"k\": 45.0, \"rho\": 7850.0, \"cp\": 500.0},\n            \"geometry\": {\"L\": 0.02, \"N\": 10},\n            \"conditions\": {\"T_L\": 400.0, \"T_R\": 300.0, \"T_0\": 300.0},\n            \"time\": {\"dt_list\": [0.002, 0.003, 0.004, 0.005]},\n            \"control\": {\"tau\": 0.45, \"h\": 0.03},\n        },\n        {\n            \"material\": {\"k\": 45.0, \"rho\": 7850.0, \"cp\": 500.0},\n            \"geometry\": {\"L\": 0.02, \"N\": 10},\n            \"conditions\": {\"T_L\": 400.0, \"T_R\": 300.0, \"T_0\": 300.0},\n            \"time\": {\"dt_list\": [0.1, 0.3, 0.6]},\n            \"control\": {\"tau\": 0.45, \"h\": 0.03},\n        },\n        {\n            \"material\": {\"k\": 45.0, \"rho\": 7850.0, \"cp\": 500.0},\n            \"geometry\": {\"L\": 0.02, \"N\": 10},\n            \"conditions\": {\"T_L\": 400.0, \"T_R\": 300.0, \"T_0\": 300.0},\n            \"time\": {\"dt_list\": [0.06, 0.05, 0.08, 0.04, 0.07]},\n            \"control\": {\"tau\": 0.20, \"h\": 0.05},\n        },\n        {\n            \"material\": {\"k\": 45.0, \"rho\": 7850.0, \"cp\": 500.0},\n            \"geometry\": {\"L\": 0.02, \"N\": 10},\n            \"conditions\": {\"T_L\": 400.0, \"T_R\": 300.0, \"T_0\": 300.0},\n            \"time\": {\"dt_list\": [0.5, 0.4, 0.6, 0.7]},\n            \"control\": {\"tau\": 0.10, \"h\": 0.02},\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        # Unpack parameters\n        k = case[\"material\"][\"k\"]\n        rho = case[\"material\"][\"rho\"]\n        cp = case[\"material\"][\"cp\"]\n        L = case[\"geometry\"][\"L\"]\n        N = case[\"geometry\"][\"N\"]\n        T_L = case[\"conditions\"][\"T_L\"]\n        T_R = case[\"conditions\"][\"T_R\"]\n        T_0 = case[\"conditions\"][\"T_0\"]\n        dt_list = case[\"time\"][\"dt_list\"]\n        tau = case[\"control\"][\"tau\"]\n        h = case[\"control\"][\"h\"]\n\n        # Calculated parameters\n        alpha = k / (rho * cp)\n        dx = L / (N + 1)\n\n        # Initialize state variables\n        # T_interior stores temperatures of N internal nodes\n        T_interior = np.full(N, T_0, dtype=float)\n        \n        current_mode = 'EXPLICIT'\n        explicit_steps = 0\n        switches = 0\n        \n        T_low = tau - h\n        T_high = tau + h\n\n        for dt in dt_list:\n            Fo = alpha * dt / (dx**2)\n            \n            prev_mode = current_mode\n            if current_mode == 'EXPLICIT':\n                if Fo > T_high:\n                    current_mode = 'IMPLICIT'\n            elif current_mode == 'IMPLICIT':\n                if Fo  T_low:\n                    current_mode = 'EXPLICIT'\n\n            if current_mode != prev_mode:\n                switches += 1\n\n            # Extend temperature array with boundaries for easier calculation\n            T_full = np.concatenate(([T_L], T_interior, [T_R]))\n\n            if current_mode == 'EXPLICIT':\n                explicit_steps += 1\n                T_new_interior = np.zeros(N)\n                for i in range(N):\n                    # T_full indices are i, i+1, i+2 for nodes i-1, i, i+1\n                    T_new_interior[i] = T_full[i+1] + Fo * (T_full[i+2] - 2 * T_full[i+1] + T_full[i])\n                T_interior = T_new_interior\n            \n            else: # IMPLICIT\n                # Build the tridiagonal system Ax = b for interior nodes\n                # A is represented by its diagonals for solve_banded\n                # a_banded has shape (3, N) for a tridiagonal matrix\n                # Row 0: super-diagonal (shifted)\n                # Row 1: main diagonal\n                # Row 2: sub-diagonal\n                \n                a_banded = np.zeros((3, N))\n                a_banded[0, 1:] = -Fo  # Super-diagonal\n                a_banded[1, :] = 1 + 2 * Fo  # Main diagonal\n                a_banded[2, :-1] = -Fo  # Sub-diagonal\n\n                # Build the right-hand side vector b\n                b = T_interior.copy()\n                b[0] += Fo * T_L\n                b[-1] += Fo * T_R\n\n                # Solve the system\n                T_interior = solve_banded((1, 1), a_banded, b)\n\n        # Calculate final metrics for the case\n        total_steps = len(dt_list)\n        explicit_fraction = round(explicit_steps / total_steps, 4)\n        \n        final_T_full = np.concatenate(([T_L], T_interior, [T_R]))\n        final_avg_temp = round(np.mean(final_T_full), 4)\n\n        results.append([explicit_fraction, switches, final_avg_temp])\n    \n    # Format and print the final output\n    output_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]},{r[2]}]\" for r in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}