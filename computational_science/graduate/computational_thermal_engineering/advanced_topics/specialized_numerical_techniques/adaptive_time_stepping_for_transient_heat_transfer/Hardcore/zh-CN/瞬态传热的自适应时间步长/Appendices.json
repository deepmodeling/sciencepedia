{
    "hands_on_practices": [
        {
            "introduction": "在深入研究自适应方法之前，我们必须首先理解为何固定时间步长会失效。本练习将显式时间积分方案的稳定性与物理系统的特性直接联系起来，这些特性通过离散化系统矩阵的特征值来体现。通过推导和计算一个简单有限元模型的最大稳定时间步长，您将对传热背景下的Courant-Friedrichs-Lewy (CFL) 条件有基本的理解 。",
            "id": "3934582",
            "problem": "考虑一根均匀杆中的一维瞬态热传导问题，该问题通过有限元（FE）方法和线性单元进行离散化。半离散系统具有规范形式 $M \\, \\dot{T}(t) + K \\, T(t) = F(t)$，其中 $M$ 是对称正定（SPD）的容量（质量）矩阵，$K$ 是对称正定（SPD）的电导（刚度）矩阵。应用一个显式单步法来对温度向量 $T(t)$ 进行时间推进。\n\nA部分（推导）：从半离散热方程出发，对齐次系统（$F(t)=0$）使用前向欧拉显式离散，通过沿 $M^{-1}K$ 的特征模态分解动力学过程，进行线性稳定性分析。推导以 $M^{-1}K$ 的最大特征值表示的显式时间步长稳定性界限。\n\nB部分（计算）：考虑一根长度为 $L=0.3\\,\\text{m}$、均匀横截面积为 $A=1.0\\times 10^{-4}\\,\\text{m}^{2}$ 的杆，其热导率为 $k=200\\,\\text{W}\\,\\text{m}^{-1}\\,\\text{K}^{-1}$，密度为 $\\rho=7800\\,\\text{kg}\\,\\text{m}^{-3}$，比热为 $c=500\\,\\text{J}\\,\\text{kg}^{-1}\\,\\text{K}^{-1}$。杆的两端保持零温度（狄利克雷边界条件 $T(0,t)=0$ 和 $T(L,t)=0$）。使用包含四个节点（节点1、2、3、4）和三个等长线性单元的均匀网格对区域进行离散，并使用一致单元容量和电导矩阵\n$$\nM^{(e)}=\\frac{\\rho c A h}{6}\\begin{bmatrix}2  1 \\\\ 1  2\\end{bmatrix},\\qquad\nK^{(e)}=\\frac{k A}{h}\\begin{bmatrix}1  -1 \\\\ -1  1\\end{bmatrix},\n$$\n其中 $h=L/3$。组装全局矩阵，在节点1和4处施加狄利克雷边界条件，并提取关于内部节点2和3的简化 $2\\times 2$ 系统。计算此简化系统的 $M^{-1}K$ 的最大特征值 $\\lambda_{\\max}$，然后根据A部分推导出的稳定性界限确定最大稳定时间步长 $\\Delta t_{\\max}$。\n\n以秒为单位表示最终的 $\\Delta t_{\\max}$，并将答案四舍五入到四位有效数字。",
            "solution": "控制半离散热方程为\n$$\nM \\, \\dot{T}(t) + K \\, T(t) = F(t),\n$$\n其中对于标准的热物理性质和适定的边界条件，$M$ 和 $K$ 是对称正定（SPD）矩阵。为了进行线性稳定性分析，我们考虑齐次系统 $F(t)=0$，得到\n$$\n\\dot{T}(t) = -M^{-1}K\\,T(t).\n$$\n我们将前向欧拉显式格式应用于此线性系统：\n$$\nT^{n+1} = T^{n} + \\Delta t \\,\\dot{T}^{n} = T^{n} - \\Delta t \\, M^{-1}K\\,T^{n} = \\left(I - \\Delta t \\, M^{-1}K\\right) T^{n}.\n$$\n设 $M^{-1}K$ 容许特征分解，其特征对为 $\\{(\\lambda_{i},v_{i})\\}$，其中 $M^{-1}K\\,v_{i}=\\lambda_{i} v_{i}$。由于 $K$ 和 $M$ 的对称正定性，所有 $\\lambda_{i}0$ 且存在一组完备的特征向量。将 $T^{n}$ 在特征基中展开，即 $T^{n}=\\sum_{i}\\alpha_{i}^{n} v_{i}$，则沿每个模态的递推关系为\n$$\n\\alpha_{i}^{n+1} = \\left(1 - \\Delta t \\,\\lambda_{i}\\right)\\alpha_{i}^{n}.\n$$\n标量放大因子为 $g_{i}(\\Delta t)=1 - \\Delta t \\,\\lambda_{i}$。对于线性检验方程，当前向欧拉格式对所有模态都满足 $|g_{i}(\\Delta t)|\\leq 1$ 时，该格式是稳定的。因为 $\\lambda_{i}0$，条件 $|1 - \\Delta t \\,\\lambda_{i}|\\leq 1$ 可简化为\n$$\n-1 \\leq 1 - \\Delta t \\,\\lambda_{i} \\leq 1 \\quad \\Longrightarrow \\quad 0 \\leq \\Delta t \\,\\lambda_{i} \\leq 2.\n$$\n因此，所有模态的稳定性要求\n$$\n\\Delta t \\leq \\frac{2}{\\lambda_{\\max}},\n$$\n其中 $\\lambda_{\\max}=\\max_{i}\\lambda_{i}$ 是 $M^{-1}K$ 的谱半径。\n\n现在我们为指定的网格和材料数据计算 $\\lambda_{\\max}$。该网格有4个节点和3个等长单元，因此 $h=L/3$。由于 $L=0.3$，我们得到 $h=0.1$。单元矩阵为\n$$\nM^{(e)}=\\frac{\\rho c A h}{6}\\begin{bmatrix}2  1 \\\\ 1  2\\end{bmatrix},\\qquad K^{(e)}=\\frac{k A}{h}\\begin{bmatrix}1  -1 \\\\ -1  1\\end{bmatrix}.\n$$\n数值上，\n$$\n\\rho c = 7800\\times 500 = 3.9\\times 10^{6},\\quad A h = (1.0\\times 10^{-4})\\times 0.1 = 1.0\\times 10^{-5},\n$$\n所以\n$$\n\\frac{\\rho c A h}{6} = \\frac{3.9\\times 10^{6}\\times 1.0\\times 10^{-5}}{6} = \\frac{39}{6} = 6.5,\n$$\n以及\n$$\n\\frac{k A}{h} = \\frac{200\\times 1.0\\times 10^{-4}}{0.1} = 0.2.\n$$\n因此，\n$$\nM^{(e)}=\\begin{bmatrix}13  6.5 \\\\ 6.5  13\\end{bmatrix},\\qquad K^{(e)}=0.2\\begin{bmatrix}1  -1 \\\\ -1  1\\end{bmatrix}.\n$$\n对三个单元 $(1\\text{–}2)$、$(2\\text{–}3)$、$(3\\text{–}4)$ 进行组装，得到 $4\\times 4$ 的全局矩阵。在节点1和4处施加齐次狄利克雷边界条件后，系统简化为关于节点2和3的内部自由度。简化后的 $2\\times 2$ 矩阵为\n$$\nM=\\begin{bmatrix}26  6.5 \\\\ 6.5  26\\end{bmatrix},\\qquad K=\\begin{bmatrix}0.4  -0.2 \\\\ -0.2  0.4\\end{bmatrix}.\n$$\n我们求解广义特征值 $\\lambda$，其满足\n$$\nK v = \\lambda M v.\n$$\n等价地，$\\lambda$ 满足\n$$\n\\det\\!\\left(K - \\lambda M\\right)=0.\n$$\n计算行列式：\n\\begin{align*}\n\\det\\!\\left(K - \\lambda M\\right)\n= \\det\\!\\begin{bmatrix}0.4 - 26\\lambda  -0.2 - 6.5\\lambda \\\\ -0.2 - 6.5\\lambda  0.4 - 26\\lambda\\end{bmatrix} \\\\\n= (0.4 - 26\\lambda)^{2} - (-0.2 - 6.5\\lambda)^{2} \\\\\n= \\left[(0.4 - 26\\lambda) - (-0.2 - 6.5\\lambda)\\right]\\left[(0.4 - 26\\lambda) + (-0.2 - 6.5\\lambda)\\right] \\\\\n= \\left(0.6 - 19.5\\lambda\\right)\\left(0.2 - 32.5\\lambda\\right).\n\\end{align*}\n令其为零，得到两个特征值：\n$$\n0.6 - 19.5\\lambda = 0 \\quad \\Longrightarrow \\quad \\lambda_{1} = \\frac{0.6}{19.5} = \\frac{2}{65},\n$$\n$$\n0.2 - 32.5\\lambda = 0 \\quad \\Longrightarrow \\quad \\lambda_{2} = \\frac{0.2}{32.5} = \\frac{2}{325}.\n$$\n因此，\n$$\n\\lambda_{\\max} = \\frac{2}{65}.\n$$\n根据上面为前向欧拉格式推导的稳定性界限，\n$$\n\\Delta t_{\\max} = \\frac{2}{\\lambda_{\\max}} = \\frac{2}{(2/65)} = 65.\n$$\n因此，对于此网格和材料组，最大的稳定显式时间步长为 $\\Delta t_{\\max}=65$ 秒。四舍五入到四位有效数字得到 $65.00$。",
            "answer": "$$\\boxed{65.00}$$"
        },
        {
            "introduction": "一个稳定的时间步长是必要的，但确保数值解在物理上貌似合理同样重要。这个动手编程练习将挑战您设计一个自适应控制器，以强制执行离散最大值原理，防止由急剧瞬变引起的非物理解的温度振荡。通过实施一个维持空间单调性的拒绝策略，您将学到一种构建尊重底层物理的鲁棒求解器的实用方法 。",
            "id": "3934707",
            "problem": "要求您设计并实现一种算法，用于处理一维瞬态热传导问题。该算法需采用自适应时间步长规则，在剧烈的边界温度跳变下保持离散极值原理和空间单调性。其基础模型是瞬态热方程，必须从第一性原理推导和实现，不得依赖任何内置求解器。目标是构建一个有意对极值原理施加压力的测试用例，并开发一种自适应时间步长策略，以防止非物理振荡和过冲。\n\n物理模型是一维瞬态热方程，描述温度 $T(x,t)$：\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2},\n$$\n其中 $\\alpha$ 是热扩散系数。区域是一根长度为 $L$ 米的杆，空间坐标 $x \\in [0,L]$，初始温度为 $T(x,0) = T_0$ 开尔文，时间为 $t$ 秒。边界条件为狄利克雷（固定温度）类型。在左端，温度在时间 $t=0$ 时从 $T_0$ 突变至 $T_1$，而右端保持在 $T_0$；即，对于所有 $t \\ge 0$，$T(0,t) = T_1$；对于所有 $t \\ge 0$，$T(L,t) = T_0$。热扩散系数 $\\alpha$ 的单位必须是 $\\mathrm{m^2/s}$，$L$ 的单位是 $\\mathrm{m}$，$t$ 的单位是 $\\mathrm{s}$，$T$ 的单位是 $\\mathrm{K}$。\n\n您必须将空间域离散为 $N$ 个均匀间隔的节点（包括边界），间距为 $\\Delta x = L/(N-1)$，并使用简单的显式前向欧拉时间步进法，以及中心二阶有限差分法来处理拉普拉斯算子。您必须为时间步长 $\\Delta t$ 设计一种自适应规则，以防止违反离散极值原理并保持离散温度分布在空间上的单调性（给定 $T_1 \\ge T_0$ 时，从 $x=0$ 到 $x=L$ 非增）。该自适应规则必须根据离散化算子的局部条件调整 $\\Delta t$，以确保显式更新中的混合权重为非负，并且必须拒绝任何会导致超出边界值的过冲或违反空间单调性的建议步长；被拒绝的步长必须用更小的 $\\Delta t$ 重试。\n\n您的程序必须实现以下要求：\n\n- 从基本的能量守恒和傅里叶定律出发，论证模型和离散化的合理性，并实现时间的显式更新。\n- 实现狄利克雷边界条件 $T(0,t) = T_1$ 和 $T(L,t) = T_0$，以及初始条件 $T(x,0) = T_0$。\n- 使用一个自适应时间步长规则，该规则：\n  - 提出一个候选 $\\Delta t$，\n  - 确保显式更新中的系数为非负，\n  - 当离散极值原理或空间单调性将被违反时，拒绝并将 $\\Delta t$ 减半，\n  - 在成功步进后谨慎增加 $\\Delta t$，但绝不超过保持更新权重非负的限制。\n- 在整个模拟过程中，跟踪定义为\n  $$\n  \\max\\left(0, -\\min_i \\left(T_i - T_{i+1}\\right)\\right)\n  $$\n  的最大单调性破坏幅值，其中 $T_i$ 是节点索引 $i$ 处的离散温度，并记录该量随时间变化的最大值。该量必须以开尔文为单位报告。\n\n您必须为一组四个测试用例运行求解器。对于每个测试用例，给定参数 $(L, N, \\alpha, T_0, T_1, t_{\\mathrm{final}}, \\Delta t_{\\mathrm{init}})$，其中 $t_{\\mathrm{final}}$ 是最终时间（秒），$\\Delta t_{\\mathrm{init}}$ 是初始建议时间步长（秒）。测试套件如下：\n\n- 用例 1：$L=0.02$ $\\mathrm{m}$, $N=21$, $\\alpha=1\\times 10^{-5}$ $\\mathrm{m^2/s}$, $T_0=300$ $\\mathrm{K}$, $T_1=600$ $\\mathrm{K}$, $t_{\\mathrm{final}}=0.5$ $\\mathrm{s}$, $\\Delta t_{\\mathrm{init}}=0.2$ $\\mathrm{s}$。\n- 用例 2：$L=0.02$ $\\mathrm{m}$, $N=5$, $\\alpha=1\\times 10^{-4}$ $\\mathrm{m^2/s}$, $T_0=300$ $\\mathrm{K}$, $T_1=600$ $\\mathrm{K}$, $t_{\\mathrm{final}}=0.1$ $\\mathrm{s}$, $\\Delta t_{\\mathrm{init}}=0.05$ $\\mathrm{s}$。\n- 用例 3：$L=0.1$ $\\mathrm{m}$, $N=51$, $\\alpha=1\\times 10^{-6}$ $\\mathrm{m^2/s}$, $T_0=300$ $\\mathrm{K}$, $T_1=800$ $\\mathrm{K}$, $t_{\\mathrm{final}}=10.0$ $\\mathrm{s}$, $\\Delta t_{\\mathrm{init}}=5.0$ $\\mathrm{s}$。\n- 用例 4：$L=0.02$ $\\mathrm{m}$, $N=3$, $\\alpha=1\\times 10^{-3}$ $\\mathrm{m^2/s}$, $T_0=300$ $\\mathrm{K}$, $T_1=600$ $\\mathrm{K}$, $t_{\\mathrm{final}}=0.01$ $\\mathrm{s}$, $\\Delta t_{\\mathrm{init}}=0.1$ $\\mathrm{s}$。\n\n对于每个用例，您的程序必须输出模拟期间观察到的最大空间单调性破坏幅值（单位：开尔文）。最终输出必须是单行，包含一个用方括号括起来的逗号分隔列表，每个结果四舍五入到六位小数，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 是一个以 $\\mathrm{K}$ 为单位的浮点数。\n\n所有计算都必须使用指定的单位。不涉及角度。不得使用百分比。\n\n您的实现必须是一个完整、可运行的程序。它不得读取任何外部输入，并且除了要求的单行列表外，不得产生任何其他输出。",
            "solution": "该问题要求为一维瞬态热方程设计并实现一种自适应时间步进算法。该算法必须在狄利克雷边界条件发生剧烈跳变时，保持解的离散极值原理和空间单调性。\n\n### 基于原理的推导与离散化\n\n物理过程由一维瞬态热方程控制：\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2}\n$$\n其中 $T(x,t)$ 是位置 $x \\in [0,L]$ 和时间 $t \\ge 0$ 时的温度（单位：开尔文），$\\alpha$ 是热扩散系数（单位：$\\mathrm{m^2/s}$）。该方程是通过将能量守恒原理与傅里叶热传导定律相结合推导出来的。一维控制体的能量守恒定律指出，内能的变化率等于流入其中的净热流率，即 $\\rho c_p \\frac{\\partial T}{\\partial t} = -\\frac{\\partial q}{\\partial x}$，其中 $q$ 是热通量，$\\rho$ 是密度，$c_p$ 是比热容。傅里叶定律指出，热通量与负温度梯度成正比，$q = -k \\frac{\\partial T}{\\partial x}$，其中 $k$ 是热导率。将两者结合，得到热方程，其中 $\\alpha = k/(\\rho c_p)$。\n\n为了数值求解该方程，我们对空间域和时间进行离散化。空间域 $x \\in [0,L]$ 被划分为 $N$ 个均匀间隔的节点，$x_i = i \\Delta x$，其中 $i=0, 1, \\dots, N-1$，网格间距为 $\\Delta x = L/(N-1)$。在节点 $i$ 和时间步 $n$ 处的温度记为 $T_i^n$。\n\n空间二阶导数使用二阶中心有限差分格式进行近似：\n$$\n\\frac{\\partial^2 T}{\\partial x^2}\\bigg|_{x_i, t^n} \\approx \\frac{T_{i-1}^n - 2T_i^n + T_{i+1}^n}{(\\Delta x)^2}\n$$\n时间导数使用显式前向欧拉法进行近似：\n$$\n\\frac{\\partial T}{\\partial t}\\bigg|_{x_i, t^n} \\approx \\frac{T_i^{n+1} - T_i^n}{\\Delta t}\n$$\n其中 $\\Delta t = t^{n+1} - t^n$ 是时间步长。将这些近似代入热方程，得到任意内部节点 $i \\in \\{1, \\dots, N-2\\}$ 的完全离散化显式更新规则：\n$$\n\\frac{T_i^{n+1} - T_i^n}{\\Delta t} = \\alpha \\frac{T_{i-1}^n - 2T_i^n + T_{i+1}^n}{(\\Delta x)^2}\n$$\n整理后得到下一时间步的温度 $T_i^{n+1}$：\n$$\nT_i^{n+1} = T_i^n + \\frac{\\alpha \\Delta t}{(\\Delta x)^2} (T_{i-1}^n - 2T_i^n + T_{i+1}^n)\n$$\n\n### 稳定性与离散极值原理\n\n我们定义无量纲傅里叶数 $s = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$。更新方程可以重写为：\n$$\nT_i^{n+1} = s T_{i-1}^n + (1 - 2s) T_i^n + s T_{i+1}^n\n$$\n离散极值原理 (DMP) 指出，在点 $(x_i, t^{n+1})$ 的温度不能高于时间 $t^n$ 时域内的最高温度，也不能低于最低温度。为此，$T_i^{n+1}$ 必须是前一时间步温度的凸组合，这要求更新方程中的所有系数都为非负。由于 $\\alpha$、$\\Delta t$ 和 $(\\Delta x)^2$ 均为正数，所以 $s \\ge 0$。唯一剩下的条件是：\n$$\n1 - 2s \\ge 0 \\implies s \\le \\frac{1}{2}\n$$\n这给出了前向欧拉格式的条件稳定性极限：\n$$\n\\frac{\\alpha \\Delta t}{(\\Delta x)^2} \\le \\frac{1}{2} \\implies \\Delta t \\le \\frac{(\\Delta x)^2}{2\\alpha}\n$$\n我们将此最大允许时间步长表示为 $\\Delta t_{\\mathrm{max}}$。如果 $\\Delta t  \\Delta t_{\\mathrm{max}}$，系数 $(1-2s)$ 会变为负数，导致 $T_i^{n+1}$ 可能超出其邻居定义的范围，从而引起非物理振荡（过冲和下冲）。这既违反了DMP，也违反了空间单调性。\n\n### 自适应时间步进算法设计\n\n问题指定的初始条件旨在如果选择一个大的固定时间步长就会违反稳定性准则。温度分布初始均匀为 $T_0$，但 $x=0$ 处的边界瞬时升高到 $T_1$。需要一个自适应算法来管理时间步长 $\\Delta t$，以确保在任何时候都能得到物理上正确的解。\n\n算法流程如下：\n1.  **初始化**：离散化区域，设置 $\\Delta x = L/(N-1)$。将温度数组 $T$ 初始化为 $T_0$。施加边界条件：$T_0 \\leftarrow T_1$ 和 $T_{N-1} \\leftarrow T_0$。设置当前时间 $t=0.0$，并将试验时间步长 $\\Delta t$ 初始化为 $\\Delta t_{\\mathrm{init}}$。计算稳定性极限 $\\Delta t_{\\mathrm{max}} = (\\Delta x)^2 / (2\\alpha)$。初始化一个变量 `max_violation` 为 $0.0$。\n\n2.  **时间演化循环**：当 $t  t_{\\mathrm{final}}$ 时，模拟在循环中运行。在每次迭代中，尝试一个时间步。\n\n3.  **步长拒绝子循环**：为确保每一步都有效，使用一个内循环：\n    a. 提出一个候选时间步长 $\\Delta t_{\\mathrm{cand}}$。对于模拟的第一步，这是 $\\Delta t_{\\mathrm{init}}$。对于后续步骤，它基于前一个成功的步长。注意不要让步长越过 $t_{\\mathrm{final}}$。\n    b. 使用显式更新规则和 $\\Delta t_{\\mathrm{cand}}$ 计算下一时间步的候选温度分布 $T_{\\mathrm{cand}}$。\n    c. 根据两个标准验证候选分布 $T_{\\mathrm{cand}}$：\n        i. **极值原理违反**：检查是否有任何温度值超出了初始范围 $[T_0, T_1]$。这通过测试 $\\max(T_{\\mathrm{cand}})  T_1$ 或 $\\min(T_{\\mathrm{cand}})  T_0$ 来完成（假设 $T_1 \\ge T_0$）。\n        ii. **空间单调性违反**：对于给定的边界条件（$T_1 \\ge T_0$），温度分布应随 $x$ 非递增。如果对于任何节点索引 $i$ 出现 $T_i  T_{i+1}$，则发生违反。\n    d. **决策**：如果任一验证检查失败，则拒绝候选步长。将 $\\Delta t_{\\mathrm{cand}}$ 减半（$\\Delta t_{\\mathrm{cand}} \\leftarrow \\Delta t_{\\mathrm{cand}} / 2$），并重复子循环。此过程保证最终会找到一个可接受的、更小的时间步长。\n    e. 如果两个检查都通过，则接受该步长。内循环终止。\n\n4.  **状态更新**：一旦找到有效的步长 $\\Delta t_{\\mathrm{cand}}$，就更新模拟状态：\n    a. 将当前温度分布设置为已接受的候选分布：$T \\leftarrow T_{\\mathrm{cand}}$。\n    b. 推进模拟时间：$t \\leftarrow t + \\Delta t_{\\mathrm{cand}}$。\n    c. 为*下一次*迭代提出时间步长，方法是谨慎地增加当前成功的步长，例如乘以因子 $1.2$。但是，此建议步长严格地被 $\\Delta t_{\\mathrm{max}}$ 限制，以主动强制稳定性。因此，$\\Delta t_{\\mathrm{next}} \\leftarrow \\min(1.2 \\times \\Delta t_{\\mathrm{cand}}, \\Delta t_{\\mathrm{max}})$。\n\n5.  **指标跟踪**：问题要求跟踪最大单调性破坏。由于算法会拒绝任何*将要导致*破坏的步长，因此被接受的温度分布在设计上不会出现单调性破坏。在每个接受的状态上计算指标 $\\max\\left(0, -\\min_i \\left(T_i - T_{i+1}\\right)\\right)$。对于正确实现的算法，该值应为零（或在机器精度数量级，出于实际目的可视为零），因为任何具有 $T_i  T_{i+1}$ 的分布都应已被拒绝。因此，在整个模拟过程中该指标的最大值预计为零，从而证实了算法的正确性。\n\n这种自适应策略确保了即使面对具有挑战性的初始时间步长，模拟也能自动减小步长以解决边界附近的剧烈初始瞬变，然后在解变得平滑时增加步长，从而提供一种高效且稳健的解决方案。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(L, N, alpha, T0, T1, t_final, dt_init):\n    \"\"\"\n    Solves the 1D transient heat equation with an adaptive time step\n    that enforces the discrete maximum principle and spatial monotonicity.\n\n    Args:\n        L (float): Length of the rod (m).\n        N (int): Number of spatial nodes.\n        alpha (float): Thermal diffusivity (m^2/s).\n        T0 (float): Initial temperature and right boundary temperature (K).\n        T1 (float): Left boundary temperature (K).\n        t_final (float): Final simulation time (s).\n        dt_init (float): Initial time step (s).\n\n    Returns:\n        float: The maximum spatial monotonicity violation amplitude observed.\n    \"\"\"\n    # 1. Discretization and Initialization\n    if N  2:\n        return 0.0  # Not enough nodes for a meaningful simulation\n        \n    x = np.linspace(0, L, N)\n    dx = L / (N - 1)\n    \n    # Set initial temperature profile at t=0\n    T = np.full(N, T0, dtype=np.float64)\n    # Apply boundary condition at x=0 for t>=0\n    T[0] = T1\n    # Boundary at x=L is already at T0\n    \n    t = 0.0\n    dt_current_proposal = dt_init\n    \n    # 2. Stability Limit\n    # The explicit scheme is stable for s = alpha * dt / dx**2 = 0.5\n    # The time step must not exceed this physical limit.\n    dt_max = (dx**2) / (2.0 * alpha)\n    \n    max_monotonicity_violation = 0.0\n    \n    # Assumption based on problem statement\n    temp_min, temp_max = min(T0, T1), max(T0, T1)\n    \n    # 3. Time Loop\n    while t  t_final:\n        # 4. Adaptive Time Stepping Logic (Rejection Loop)\n        dt_proposed = min(dt_current_proposal, t_final - t) # Do not step over t_final\n\n        while True:\n            # If the time step becomes excessively small, break to prevent infinite loops.\n            if dt_proposed  1e-15:\n                break\n                \n            # Propose the next state T_next\n            T_next = np.copy(T)\n            \n            # Explicit forward Euler update for interior nodes\n            # Using vectorization for performance\n            s = alpha * dt_proposed / (dx**2)\n            T_next[1:-1] = T[1:-1] + s * (T[2:] - 2 * T[1:-1] + T[:-2])\n            \n            # Boundary conditions are fixed (Dirichlet)\n            T_next[0] = T1\n            T_next[-1] = T0\n            \n            # --- Validation Checks ---\n            # Check 1: Maximum Principle Violation (Overshoot/Undershoot)\n            # The temperature should stay within the initial boundary limits.\n            max_principle_violation = np.any(T_next[1:-1] > temp_max) or np.any(T_next[1:-1]  temp_min)\n            \n            # Check 2: Spatial Monotonicity Violation\n            # For T1 >= T0, temperature should be non-increasing from left to right.\n            # Violation occurs if T_i  T_{i+1} for any i.\n            diffs = T_next[:-1] - T_next[1:]\n            monotonicity_violation_check = np.any(diffs  0)\n            \n            if max_principle_violation or monotonicity_violation_check:\n                # REJECT step: The proposed step is too large. Halve it and retry.\n                dt_proposed /= 2.0\n            else:\n                # ACCEPT step: The step is valid.\n                break # Exit the rejection loop\n        \n        # If dt became too small, we end the simulation for this case.\n        if dt_proposed  1e-15:\n            break\n            \n        # 5. Update State\n        dt_accepted = dt_proposed\n        T = T_next\n        t += dt_accepted\n        \n        # 6. Track Metrics on the accepted state\n        # The problem requires tracking the violation metric. By design of the\n        # rejection algorithm, this value should be zero on all accepted states.\n        diffs = T[:-1] - T[1:]\n        if diffs.size > 0:\n            current_violation = max(0.0, -np.min(diffs))\n            if current_violation > max_monotonicity_violation:\n                max_monotonicity_violation = current_violation\n        \n        # 7. Propose dt for the *next* iteration\n        # Cautiously increase step size, but never beyond the theoretical max.\n        dt_current_proposal = min(dt_accepted * 1.2, dt_max)\n\n    return max_monotonicity_violation\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (L, N, alpha, T0, T1, t_final, dt_init)\n        (0.02, 21, 1e-5, 300.0, 600.0, 0.5, 0.2),\n        (0.02, 5, 1e-4, 300.0, 600.0, 0.1, 0.05),\n        (0.1, 51, 1e-6, 300.0, 800.0, 10.0, 5.0),\n        (0.02, 3, 1e-3, 300.0, 600.0, 0.01, 0.1),\n    ]\n\n    results = []\n    for case in test_cases:\n        violation = run_simulation(*case)\n        results.append(f\"{violation:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\n# Run the solver\nsolve()\n```"
        },
        {
            "introduction": "最常见的自适应策略旨在控制局部截断误差，以高效地达到期望的精度水平。本练习将指导您使用嵌入式龙格-库塔对来估计和控制误差，从而实现一个现代的自适应时间步进算法。您不仅将构建控制器，还将通过测试其收敛速度来验证其性能，这是验证任何数值代码的关键技能 。",
            "id": "3934689",
            "problem": "考虑一根长度为 $L$、热扩散率为 $\\alpha$ 的一维均匀杆，在狄利克雷边界条件下进行瞬态热传导。其控制方程为热方程，表示为以下偏微分方程\n$$\n\\frac{\\partial T(x,t)}{\\partial t} = \\alpha \\frac{\\partial^2 T(x,t)}{\\partial x^2},\n$$\n其中 $x \\in [0,L]$ 且 $t \\ge 0$，边界条件为对所有 $t$ 都有 $T(0,t) = 0$ 和 $T(L,t) = 0$，初始条件为 $T(x,0) = \\sin\\left(\\frac{\\pi x}{L}\\right)$。在这些条件下，其精确解为\n$$\nT_{\\text{exact}}(x,t) = e^{-\\alpha \\left(\\frac{\\pi}{L}\\right)^2 t} \\sin\\left(\\frac{\\pi x}{L}\\right).\n$$\n使用包含 $N$ 个节点、间距为 $\\Delta x = \\frac{L}{N-1}$ 的均匀网格对区域进行空间离散化，并用二阶中心差分近似空间导数。这将为内部节点（不包括狄利克雷边界）产生一个半离散的常微分方程组：\n$$\n\\frac{d\\mathbf{y}(t)}{dt} = \\mathbf{f}(\\mathbf{y}(t)) = \\alpha \\frac{1}{\\Delta x^2} \\left( \\mathbf{P}\\mathbf{y}(t) \\right),\n$$\n其中 $\\mathbf{y}(t) \\in \\mathbb{R}^{N-2}$ 是内部节点温度的向量，$\\mathbf{P}$ 是具有齐次狄利克雷条件的离散拉普拉斯算子。\n\n在时间区间 $t \\in [0, t_f]$ 上，使用一个带有嵌入式一阶方法的显式二阶方法来构建一个时间积分算法，以估计每步的局部截断误差。对温度向量 $\\mathbf{y}$ 的误差使用欧几里得范数，并将该范数的单位视为开尔文。设计一个自适应时间步长控制器，其目标是达到指定的每步误差容限 $\\mathrm{tol}$，仅当估计的局部误差范数小于或等于 $\\mathrm{tol}$ 时才接受该步。算法中应包含一个最小时间步长 $\\Delta t_{\\min}$ 和一个最大时间步长 $\\Delta t_{\\max}$，后者需满足热方程的显式稳定性条件。如果在 $\\Delta t_{\\min}$ 时，估计的局部误差仍高于 $\\mathrm{tol}$，则接受该步以避免死锁，并以 $\\Delta t_{\\min}$ 继续进行。\n\n对于每次模拟，计算：\n- 达到 $t_f$ 所需的已接受时间步数 $N_{\\text{steps}}$。\n- 在 $t_f$ 时的全局欧几里得范数误差，定义为\n$$\nE_{\\text{final}} = \\left\\| \\mathbf{y}(t_f) - \\mathbf{y}_{\\text{exact}}(t_f) \\right\\|_2,\n$$\n其中 $\\mathbf{y}_{\\text{exact}}(t_f)$ 是通过在内部网格点上计算 $T_{\\text{exact}}(x_i,t_f)$ 得到的。\n\n设计一个测试，通过将容限减半并观察步数和最终误差来验证收敛率。具体来说，使用容限值 $(\\mathrm{tol}_1, \\mathrm{tol}_2)$（其中 $\\mathrm{tol}_2 = \\frac{1}{2}\\mathrm{tol}_1$）进行成对模拟，并比较以下比率\n$$\nR_{\\text{steps}} = \\frac{N_{\\text{steps}}(\\mathrm{tol}_2)}{N_{\\text{steps}}(\\mathrm{tol}_1)}, \\quad\nR_{\\text{error}} = \\frac{E_{\\text{final}}(\\mathrm{tol}_2)}{E_{\\text{final}}(\\mathrm{tol}_1)}.\n$$\n对于一个由嵌入式一阶误差估计控制的二阶方法，其预期行为（在控制器决定时间步长且未在 $\\Delta t_{\\min}$ 或 $\\Delta t_{\\max}$ 处饱和的情况下）是 $R_{\\text{steps}}$ 约等于 $\\sqrt{2}$ 且 $R_{\\text{error}}$ 约等于 $\\frac{1}{2}$。\n\n使用以下固定的物理和数值参数：\n- 杆长：$L = 1$ 米。\n- 空间节点数：$N = 50$。\n- 最终时间：$t_f = 1.0$ 秒。\n- 最小时间步长：$\\Delta t_{\\min} = 10^{-3}$ 秒。\n- 最大时间步长：$\\Delta t_{\\max}$ 设置为显式稳定性极限的 $0.9$ 倍，即\n$$\n\\Delta t_{\\max} = 0.9 \\cdot \\frac{\\Delta x^2}{2 \\alpha}.\n$$\n\n实现该自适应控制器并运行以下参数对的测试套件，其中每个测试用例是一对 $(\\alpha, \\mathrm{tol}_1, \\mathrm{tol}_2)$：\n1. $(\\alpha = 10^{-4} \\,\\text{m}^2/\\text{s}, \\mathrm{tol}_1 = 10^{-4} \\,\\text{K}, \\mathrm{tol}_2 = 5 \\times 10^{-5} \\,\\text{K})$ — 控制器在远离边界的情况下运行的一般情况。\n2. $(\\alpha = 10^{-4} \\,\\text{m}^2/\\text{s}, \\mathrm{tol}_1 = 10^{-10} \\,\\text{K}, \\mathrm{tol}_2 = 5 \\times 10^{-11} \\,\\text{K})$ — 预计在 $\\Delta t_{\\min}$ 处饱和的边缘情况。\n3. $(\\alpha = 10^{-3} \\,\\text{m}^2/\\text{s}, \\mathrm{tol}_1 = 10^{-4} \\,\\text{K}, \\mathrm{tol}_2 = 5 \\times 10^{-5} \\,\\text{K})$ — 更高的扩散率，以探究不同的刚度和控制器缩放行为。\n\n对每个测试用例，计算布尔值以指示观察到的比率是否在指定容差内满足预期：\n- 如果 $\\left|\\frac{R_{\\text{steps}} - \\sqrt{2}}{\\sqrt{2}}\\right| \\le 0.10$，则将 $b_{\\text{steps}}$ 报告为 $\\text{True}$，否则报告为 $\\text{False}$。\n- 如果 $\\left|\\frac{R_{\\text{error}} - \\frac{1}{2}}{\\frac{1}{2}}\\right| \\le 0.20$，则将 $b_{\\text{error}}$ 报告为 $\\text{True}$，否则报告为 $\\text{False}$。\n\n您的程序应生成单行输出，其中包含六个布尔值，按测试用例和指标排序，以逗号分隔并用方括号括起来（例如，“[b1,b2,b3,b4,b5,b6]”），其中每个测试用例的第一个布尔值对应于 $b_{\\text{steps}}$，第二个对应于 $b_{\\text{error}}$。所有涉及时间的量必须以秒为单位表示，所有误差范数必须以开尔文为单位。不涉及角度。",
            "solution": "该问题要求构建并验证一种自适应时间步进算法，用于求解一维瞬态热方程。该解决方案是遵循偏微分方程（PDE）数值分析的既定原则开发的，特别是采用线方法（method of lines）结合嵌入式龙格-库塔格式（Runge-Kutta scheme）进行时间积分。\n\n### 1. 使用线方法进行半离散化\n\n控制偏微分方程为\n$$\n\\frac{\\partial T(x,t)}{\\partial t} = \\alpha \\frac{\\partial^2 T(x,t)}{\\partial x^2}\n$$\n其中 $x \\in [0, L]$ 且 $t \\ge 0$。第一步是将这个单一的偏微分方程转化为一个关于时间的耦合常微分方程（ODE）组。这通过线方法实现，即我们对空间域进行离散化并近似空间导数。\n\n定义一个包含 $N$ 个节点的均匀网格，其空间坐标为 $x_i = i \\cdot \\Delta x$（$i=0, 1, \\dots, N-1$），其中网格间距为 $\\Delta x = L/(N-1)$。令 $T_i(t) = T(x_i, t)$ 为节点 $i$ 处的温度。在内部节点 $x_i$（其中 $i=1, \\dots, N-2$）处的二阶空间导数使用二阶中心差分格式来近似：\n$$\n\\frac{\\partial^2 T}{\\partial x^2}\\bigg|_{x=x_i} \\approx \\frac{T_{i-1}(t) - 2T_i(t) + T_{i+1}(t)}{\\Delta x^2}.\n$$\n将此式代入每个内部节点的热方程，得到一个包含 $N-2$ 个常微分方程的方程组：\n$$\n\\frac{d T_i(t)}{dt} = \\frac{\\alpha}{\\Delta x^2} \\left( T_{i-1}(t) - 2T_i(t) + T_{i+1}(t) \\right).\n$$\n边界条件为 $T(0,t) = T_0(t) = 0$ 和 $T(L,t) = T_{N-1}(t) = 0$。这些值被纳入第一个和最后一个内部节点（$i=1$ 和 $i=N-2$）的方程中。\n\n该方程组可以写成矩阵形式 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$，其中 $\\mathbf{y}(t) = [T_1(t), T_2(t), \\dots, T_{N-2}(t)]^T$ 是内部节点的温度向量。函数 $\\mathbf{f}(\\mathbf{y})$ 代表右侧项，它是一个线性运算 $\\frac{\\alpha}{\\Delta x^2} \\mathbf{P} \\mathbf{y}$，其中 $\\mathbf{P}$ 是一个 $(N-2) \\times (N-2)$ 的三对角矩阵，代表具有齐次狄利克雷边界条件的离散拉普拉斯算子：\n$$\n\\mathbf{P} = \\begin{pmatrix}\n-2  1  0  \\dots \\\\\n1  -2  1  \\dots \\\\\n0  1  -2  \\dots \\\\\n\\vdots   \\ddots    1 \\\\\n\\dots  0  1  -2\n\\end{pmatrix}.\n$$\n\n### 2. 使用嵌入式方法的自适应时间积分\n\n为了从初始状态 $\\mathbf{y}(0)$ 求解该常微分方程组 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$，我们使用一种自适应时间步进方法。这需要一个能够在每一步提供局部截断误差估计的积分器。嵌入式龙格-库塔方法是实现此目的的理想选择。我们选择休恩-欧拉（Heun-Euler）对，其阶数为 $(2,1)$。\n\n在从 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的每个时间步中，我们计算解 $\\mathbf{y}_{n+1}$ 的两个近似值：\n1.  **一阶（前向欧拉）解，$\\hat{\\mathbf{y}}_{n+1}$**：\n    $$\n    \\mathbf{k}_1 = \\mathbf{f}(\\mathbf{y}_n)\n    $$\n    $$\n    \\hat{\\mathbf{y}}_{n+1} = \\mathbf{y}_n + \\Delta t \\, \\mathbf{k}_1\n    $$\n2.  **二阶（休恩法）解，$\\mathbf{y}_{n+1}$**：\n    $$\n    \\mathbf{k}_2 = \\mathbf{f}(\\hat{\\mathbf{y}}_{n+1}) = \\mathbf{f}(\\mathbf{y}_n + \\Delta t \\, \\mathbf{k}_1)\n    $$\n    $$\n    \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{2} (\\mathbf{k}_1 + \\mathbf{k}_2)\n    $$\n\n这两个解之间的差异提供了低阶方法局部截断误差的估计值。我们用它作为高阶方法误差的代理。误差估计向量为 $\\mathbf{e}_{n+1} = \\mathbf{y}_{n+1} - \\hat{\\mathbf{y}}_{n+1}$，其欧几里得范数 $E_{\\text{local}} = \\|\\mathbf{e}_{n+1}\\|_2$ 用于步长控制。\n\n### 3. 步长控制算法\n\n自适应算法的核心是控制器，它调整时间步长 $\\Delta t$ 以满足预设的局部误差容限 $\\mathrm{tol}$。\n\n- **步长接受/拒绝**：计算出 $E_{\\text{local}}$ 后，如果 $E_{\\text{local}} \\le \\mathrm{tol}$，则接受该步。如果步长被接受，则时间向前推进（$t_{n+1} = t_n + \\Delta t$）并更新解（$\\mathbf{y}_{n+1}$ 成为新的 $\\mathbf{y}_n$）。如果 $E_{\\text{local}}  \\mathrm{tol}$，则拒绝该步，时间不推进，并用一个更小的 $\\Delta t$ 重试该步。\n- **步长更新**：新的时间步长 $\\Delta t_{\\text{new}}$ 是根据当前尝试的误差计算的。对于一个由 $p$ 阶嵌入式方法控制的 $p+1$ 阶方法（这里 $p=1$），最优步长随误差的变化关系如下：\n$$\n\\Delta t_{\\text{new}} = S \\cdot \\Delta t_{\\text{current}} \\left( \\frac{\\mathrm{tol}}{E_{\\text{local}}} \\right)^{\\frac{1}{p+1}},\n$$\n其中 $S$ 是一个安全因子（通常为 $0.8$ - $0.9$），以防止过于乐观的步长增加。我们选择 $S=0.9$ 和 $p=1$，得到：\n$$\n\\Delta t_{\\text{new}} = 0.9 \\cdot \\Delta t_{\\text{current}} \\sqrt{\\frac{\\mathrm{tol}}{E_{\\text{local}}}}.\n$$\n无论当前步是被接受还是被拒绝，该公式都用于计算下一次尝试的步长。\n- **约束**：计算出的 $\\Delta t$ 被限制在 $[\\Delta t_{\\min}, \\Delta t_{\\max}]$ 范围内。最小步长 $\\Delta t_{\\min}$ 防止算法采用过小的步长，而最大步长 $\\Delta t_{\\max}$ 由热方程的显式稳定性极限决定：$\\Delta t_{\\text{stable}} = \\Delta x^2/(2\\alpha)$。我们使用 $\\Delta t_{\\max} = 0.9 \\cdot \\Delta t_{\\text{stable}}$。\n- **避免死锁**：问题规定，如果当前步长等于或小于 $\\Delta t_{\\min}$ 且误差仍超过 $\\mathrm{tol}$，则必须接受该步以防止模拟停滞。这通过将接受条件修改为 `if E_local = tol or dt == dt_min` 来实现。\n\n### 4. 收敛率验证\n\n自适应控制器的有效性通过测试其收敛特性来验证。自适应积分器的理论表明，对于一个 $p$ 阶主方法，全局误差应与容限成正比，即 $E_{\\text{global}} \\propto \\mathrm{tol}$。此外，平均步长 $\\Delta t$ 应与 $\\mathrm{tol}^{1/(p+1)}$ 成正比。\n\n对于我们的二阶方法（$p=1$ 控制 $p+1=2$），我们期望：\n-   **全局误差**：$E_{\\text{final}} \\propto \\mathrm{tol}$。将容限减半（$\\mathrm{tol}_2 = \\frac{1}{2}\\mathrm{tol}_1$）应使最终误差减半，因此比率 $R_{\\text{error}} = \\frac{E_{\\text{final}}(\\mathrm{tol}_2)}{E_{\\text{final}}(\\mathrm{tol}_1)}$ 应约等于 $\\frac{1}{2}$。\n-   **步数**：平均时间步长 $\\Delta t$ 与 $\\mathrm{tol}^{1/2}$ 成正比。覆盖固定区间 $[0, t_f]$ 所需的步数 $N_{\\text{steps}}$ 与平均步长成反比，因此 $N_{\\text{steps}} \\propto 1/\\Delta t \\propto \\mathrm{tol}^{-1/2}$。因此，将容限减半应使步数增加一个因子 $(1/2)^{-1/2} = \\sqrt{2}$。比率 $R_{\\text{steps}} = \\frac{N_{\\text{steps}}(\\mathrm{tol}_2)}{N_{\\text{steps}}(\\mathrm{tol}_1)}$ 应约等于 $\\sqrt{2}$。\n\n实现将针对多对容限 $(\\mathrm{tol}_1, \\mathrm{tol}_2)$ 模拟该系统，并检查这些理论比率是否在指定的相对误差范围内得到满足，从而确认自适应算法的正确行为。控制器在 $\\Delta t_{\\min}$ 或 $\\Delta t_{\\max}$ 处饱和的情况预计不会遵循这些缩放定律。",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef run_simulation(alpha, tol, L, N, tf, dt_min):\n    \"\"\"\n    Solves the 1D heat equation with an adaptive step-size controller.\n\n    Args:\n        alpha (float): Thermal diffusivity.\n        tol (float): Per-step error tolerance.\n        L (float): Length of the rod.\n        N (int): Number of spatial nodes.\n        tf (float): Final time.\n        dt_min (float): Minimum allowed time step.\n\n    Returns:\n        tuple: (number of accepted steps, final global error).\n    \"\"\"\n    dx = L / (N - 1)\n    dt_max = 0.9 * (dx ** 2) / (2 * alpha)\n    \n    # Interior spatial grid\n    x_interior = np.linspace(dx, L - dx, N - 2)\n    \n    # Initial condition for interior nodes\n    y = np.sin(np.pi * x_interior / L)\n    \n    # Pre-calculate constant for RHS evaluation\n    C = alpha / (dx ** 2)\n    \n    def f(y_vec):\n        \"\"\"Computes the RHS of the ODE system dy/dt = f(y).\"\"\"\n        # Pad with zero Dirichlet boundary conditions\n        y_full = np.zeros(N)\n        y_full[1:-1] = y_vec\n        # Central difference approximation\n        dydt = C * (y_full[:-2] - 2 * y_full[1:-1] + y_full[2:])\n        return dydt\n\n    t = 0.0\n    dt = dt_min  # Start with a conservative step size\n    n_steps = 0\n    safety_factor = 0.9\n\n    while t  tf:\n        # Ensure the final step lands exactly on tf\n        if t + dt > tf:\n            dt = tf - t\n\n        # Heun-Euler embedded pair\n        k1 = f(y)\n        y_euler = y + dt * k1\n        k2 = f(y_euler)\n        y_heun = y + (dt / 2.0) * (k1 + k2)\n        \n        # Estimate local error\n        error_norm = np.linalg.norm(y_heun - y_euler)\n        # Avoid division by zero if error is nil\n        if error_norm  1e-16:\n            error_norm = 1e-16\n\n        # Step acceptance condition\n        accept_step = (error_norm = tol) or (dt == dt_min)\n\n        if accept_step:\n            t += dt\n            y = y_heun\n            n_steps += 1\n        \n        # Calculate new step size for the next attempt (or next step)\n        # Based on the error of the current attempt, regardless of acceptance\n        dt_new = safety_factor * dt * (tol / error_norm)**0.5\n        \n        # Clip the new step size to the defined bounds\n        dt = min(dt_max, max(dt_min, dt_new))\n\n    # Compute final global error against the exact solution\n    y_exact_tf = np.exp(-alpha * (np.pi/L)**2 * tf) * np.sin(np.pi * x_interior / L)\n    E_final = np.linalg.norm(y - y_exact_tf)\n    \n    return n_steps, E_final\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the final results.\n    \"\"\"\n    # Fixed physical and numerical parameters\n    L = 1.0\n    N = 50\n    tf = 1.0\n    dt_min = 1.0e-3\n\n    # Test suite: (alpha, tol_1, tol_2)\n    test_cases = [\n        (1.0e-4, 1.0e-4, 5.0e-5),\n        (1.0e-4, 1.0e-10, 5.0e-11),\n        (1.0e-3, 1.0e-4, 5.0e-5),\n    ]\n\n    all_booleans = []\n\n    for alpha, tol1, tol2 in test_cases:\n        # Run simulation for the first tolerance\n        N_steps1, E_final1 = run_simulation(alpha, tol1, L, N, tf, dt_min)\n        \n        # Run simulation for the second tolerance\n        N_steps2, E_final2 = run_simulation(alpha, tol2, L, N, tf, dt_min)\n\n        # Compute ratios\n        # Avoid division by zero if a result is zero\n        R_steps = N_steps2 / N_steps1 if N_steps1 > 0 else float('inf')\n        R_error = E_final2 / E_final1 if E_final1 > 0 else float('inf')\n        \n        # Verify step count ratio against theoretical sqrt(2)\n        sqrt2 = math.sqrt(2)\n        b_steps = abs((R_steps - sqrt2) / sqrt2) = 0.10\n        all_booleans.append(b_steps)\n\n        # Verify final error ratio against theoretical 0.5\n        b_error = abs((R_error - 0.5) / 0.5) = 0.20\n        all_booleans.append(b_error)\n\n    # Format the final output string\n    print(f\"[{','.join(map(str, all_booleans))}]\")\n\nsolve()\n```"
        }
    ]
}