{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of sharp-interface immersed boundary methods is the accurate enforcement of boundary conditions on a non-conforming grid. To achieve this, we introduce 'ghost cells' within the solid domain and assign them values such that a desired condition is met at the interface. This exercise  provides the mathematical foundation for a second-order accurate treatment of Dirichlet boundary conditions by guiding you through the derivation of a quadratic interpolation formula for the ghost-cell temperature. Mastering this derivation is key to understanding how high-fidelity information is communicated from the boundary to the fluid domain.",
            "id": "3961914",
            "problem": "A Cartesian finite-volume heat conduction solver employs an immersed boundary method (IBM) to treat a smooth embedded solid boundary cutting arbitrarily through the grid. To enforce a Dirichlet boundary condition on temperature, the ghost-cell temperature inside the solid is assigned so that interpolation along the local normal to the interface recovers the known boundary temperature. Consider a single ghost cell whose center lies along a normal ray to the interface. Let $s$ denote the signed distance along the unit normal pointing from the boundary into the fluid, with $s=0$ on the interface $\\Gamma$, $s>0$ in the fluid, and $s<0$ in the solid. Along this normal ray, the ghost-cell center is located at $s=-d_{g}$ with $d_{g}>0$. The first and second neighboring fluid cell centers along the same normal ray are located at $s=d_{1}$ and $s=d_{2}$, respectively, with $0<d_{1}<d_{2}$ and known temperatures $T_{1}=T(d_{1})$ and $T_{2}=T(d_{2})$. The temperature on the interface is prescribed as the Dirichlet data $T_{b}=T(0)$.\n\nAssume that $T(s)$ is sufficiently smooth in a neighborhood of the interface and that the local interface curvature is negligible over the distances $d_{g}$, $d_{1}$, and $d_{2}$ so that interpolation along the normal is appropriate. Starting from the Dirichlet boundary condition and the definition of a quadratic interpolant consistent with the temperature field along the normal line, derive a second-order accurate expression for the ghost-cell temperature $T_{g}=T(-d_{g})$ by constructing the unique quadratic polynomial that interpolates the three data points $\\{(0,T_{b}),(d_{1},T_{1}),(d_{2},T_{2})\\}$ and evaluating it at $s=-d_{g}$.\n\nExpress your final answer as a single closed-form analytic expression for $T_{g}$ in terms of $T_{b}$, $T_{1}$, $T_{2}$, $d_{g}$, $d_{1}$, and $d_{2}$. No numerical evaluation is required, and no units are needed in the final expression.",
            "solution": "The user-provided problem statement has been validated and is deemed valid. It is scientifically grounded, well-posed, and objective. The problem outlines a standard procedure in computational heat transfer for handling immersed boundaries and asks for a specific mathematical derivation.\n\nThe objective is to derive an expression for the ghost-cell temperature $T_g$. This temperature corresponds to the value $T(-d_g)$ of a temperature profile $T(s)$ along a normal to the boundary. The derivation is to be based on a quadratic polynomial that interpolates three known temperature values at specific locations along this normal. The given data points are $(s, T)$: $(0, T_b)$, $(d_1, T_1)$, and $(d_2, T_2)$. Here, $s$ is the signed distance from the boundary, $T_b$ is the prescribed boundary temperature, and $T_1$ and $T_2$ are known temperatures at fluid cell centers located at distances $d_1$ and $d_2$ from the boundary, respectively. The ghost cell is at a signed distance $s = -d_g$.\n\nWe seek a unique quadratic polynomial $P(s)$ such that:\n$$ P(0) = T_b $$\n$$ P(d_1) = T_1 $$\n$$ P(d_2) = T_2 $$\nThe ghost-cell temperature $T_g$ is then defined as the value of this polynomial evaluated at $s = -d_g$, i.e., $T_g = P(-d_g)$.\n\nA direct and systematic method for constructing such an interpolating polynomial is Lagrange interpolation. The Lagrange form of the unique quadratic polynomial passing through the three points $(s_0, y_0)$, $(s_1, y_1)$, and $(s_2, y_2)$ is given by:\n$$ P(s) = y_0 L_0(s) + y_1 L_1(s) + y_2 L_2(s) $$\nwhere $L_0(s)$, $L_1(s)$, and $L_2(s)$ are the Lagrange basis polynomials, defined as:\n$$ L_j(s) = \\prod_{i=0, i \\neq j}^{2} \\frac{s - s_i}{s_j - s_i} $$\nIn our specific case, the points are $(s_0, y_0) = (0, T_b)$, $(s_1, y_1) = (d_1, T_1)$, and $(s_2, y_2) = (d_2, T_2)$. We construct the basis polynomials as follows:\n\nFor $j=0$:\n$$ L_0(s) = \\frac{s - s_1}{s_0 - s_1} \\cdot \\frac{s - s_2}{s_0 - s_2} = \\frac{s - d_1}{0 - d_1} \\cdot \\frac{s - d_2}{0 - d_2} = \\frac{(s-d_1)(s-d_2)}{d_1 d_2} $$\n\nFor $j=1$:\n$$ L_1(s) = \\frac{s - s_0}{s_1 - s_0} \\cdot \\frac{s - s_2}{s_1 - s_2} = \\frac{s - 0}{d_1 - 0} \\cdot \\frac{s - d_2}{d_1 - d_2} = \\frac{s(s-d_2)}{d_1(d_1 - d_2)} $$\n\nFor $j=2$:\n$$ L_2(s) = \\frac{s - s_0}{s_2 - s_0} \\cdot \\frac{s - s_1}{s_2 - s_1} = \\frac{s - 0}{d_2 - 0} \\cdot \\frac{s - d_1}{d_2 - d_1} = \\frac{s(s-d_1)}{d_2(d_2 - d_1)} $$\n\nThe interpolating polynomial for the temperature $T(s)$ is thus:\n$$ P(s) = T_b \\frac{(s-d_1)(s-d_2)}{d_1 d_2} + T_1 \\frac{s(s-d_2)}{d_1(d_1 - d_2)} + T_2 \\frac{s(s-d_1)}{d_2(d_2 - d_1)} $$\nTo find the ghost-cell temperature $T_g$, we evaluate this polynomial at $s = -d_g$:\n$$ T_g = P(-d_g) = T_b \\frac{(-d_g-d_1)(-d_g-d_2)}{d_1 d_2} + T_1 \\frac{(-d_g)(-d_g-d_2)}{d_1(d_1 - d_2)} + T_2 \\frac{(-d_g)(-d_g-d_1)}{d_2(d_2 - d_1)} $$\nSimplifying the terms:\nThe coefficient for $T_b$ becomes:\n$$ \\frac{(-1)(d_g+d_1)(-1)(d_g+d_2)}{d_1 d_2} = \\frac{(d_g+d_1)(d_g+d_2)}{d_1 d_2} $$\nThe coefficient for $T_1$ becomes:\n$$ \\frac{(-d_g)(-1)(d_g+d_2)}{d_1(d_1 - d_2)} = \\frac{d_g(d_g+d_2)}{d_1(d_1 - d_2)} $$\nThe coefficient for $T_2$ becomes:\n$$ \\frac{(-d_g)(-1)(d_g+d_1)}{d_2(d_2 - d_1)} = \\frac{d_g(d_g+d_1)}{d_2(d_2 - d_1)} $$\nCombining these results gives the final expression for the ghost-cell temperature $T_g$. This expression uses a quadratic interpolation, which is consistent with the requirements for a second-order accurate numerical scheme for the heat equation in the presence of arbitrarily-shaped boundaries.\n\nThe final expression for $T_g$ is a weighted sum of the boundary temperature $T_b$ and the two neighboring fluid temperatures $T_1$ and $T_2$, where the weights are functions of the distances $d_g$, $d_1$, and $d_2$.\n$$ T_g = T_b \\frac{(d_g+d_1)(d_g+d_2)}{d_1 d_2} + T_1 \\frac{d_g(d_g+d_2)}{d_1(d_1 - d_2)} + T_2 \\frac{d_g(d_g+d_1)}{d_2(d_2 - d_1)} $$\nThis is the required closed-form analytic expression. It can be written more symmetrically by factoring $-1$ from the denominator of the $T_1$ term, since $d_2 > d_1$:\n$$ T_g = T_b \\frac{(d_g+d_1)(d_g+d_2)}{d_1 d_2} - T_1 \\frac{d_g(d_g+d_2)}{d_1(d_2 - d_1)} + T_2 \\frac{d_g(d_g+d_1)}{d_2(d_2 - d_1)} $$\nHowever, the first form is the direct result from the standard definition of Lagrange polynomials and is equally correct.",
            "answer": "$$ \\boxed{ T_b \\frac{(d_g+d_1)(d_g+d_2)}{d_1 d_2} + T_1 \\frac{d_g(d_g+d_2)}{d_1(d_1-d_2)} + T_2 \\frac{d_g(d_g+d_1)}{d_2(d_2-d_1)} } $$"
        },
        {
            "introduction": "While accuracy at the boundary is crucial, numerical stability is paramount for a simulation to run successfully, especially with explicit time-stepping schemes. A classic challenge in cut-cell immersed boundary methods is the 'small cell problem,' where tiny cells near the interface can impose prohibitively small time-step restrictions. This hands-on exercise  delves into two powerful, physically-grounded stabilization techniques: flux redistribution and cell merging. By implementing and testing these strategies, you will learn how to overcome stability bottlenecks while rigorously maintaining global energy conservation.",
            "id": "3961816",
            "problem": "Consider a one-dimensional transient heat conduction problem in a fluid subdomain embedded inside a larger Cartesian grid, treated using the Immersed Boundary Method (IBM). The governing energy equation in the fluid is the heat diffusion equation, derived from conservation of energy and Fourier’s law: $$\\frac{\\partial T}{\\partial t} = \\kappa \\frac{\\partial^2 T}{\\partial x^2},$$ where $T$ is temperature, $\\kappa = \\frac{k}{\\rho c}$ is the thermal diffusivity, $k$ is the thermal conductivity, $\\rho$ is density, and $c$ is specific heat. Let the cross-sectional area be $A = 1\\,\\mathrm{m}^2$, so that the volumetric heat capacity is $C_v = \\rho c$ in $\\mathrm{J}/(\\mathrm{m}^3\\cdot\\mathrm{K})$ and energy $U$ in $\\mathrm{J}$ for a control volume of length $l$ is $U = C_v \\, l \\, T$.\n\nUse a finite-volume discretization on an interval of length $L = 1\\,\\mathrm{m}$ partitioned into $N$ nominal cells of uniform base size $\\Delta x = L/N$. An immersed boundary cuts the first cell so that its fluid length is $l_0 = \\alpha \\Delta x$, with $0  \\alpha \\le 1$, while the remaining cells have fluid lengths $l_i = \\Delta x$ for $i \\ge 1$. The left boundary at $x=0$ and the right boundary at $x=L$ are both thermally insulated, imposing zero heat flux. The discrete internal face between cell $i$ and cell $i+1$ is located midway between cell centers, yielding an effective center-to-center distance $$d_{i+\\frac{1}{2}} = \\frac{1}{2}\\left(l_i + l_{i+1}\\right).$$ Discrete diffusive heat flux across internal face $i+\\frac{1}{2}$ is given by $$F_{i+\\frac{1}{2}} = -k A \\frac{T_{i+1} - T_i}{d_{i+\\frac{1}{2}}},$$ and the semi-discrete conservation update for cell $i$ is $$\\frac{\\mathrm{d}}{\\mathrm{d}t}\\left(C_v \\, l_i \\, T_i\\right) = F_{i-\\frac{1}{2}} - F_{i+\\frac{1}{2}},$$ with $F_{-\\frac{1}{2}} = 0$ and $F_{N-\\frac{1}{2}} = 0$ due to insulated boundaries.\n\nSmall cut cells with $l_0 \\ll \\Delta x$ can render explicit time stepping unstable. Two stabilization strategies commonly used in immersed boundary treatments are to modify face fluxes adjacent to small cut cells (flux redistribution or clipping) and to merge the small cut cell with an adjacent larger cell (cell merging), while maintaining global conservation. Your task is to implement both strategies and evaluate their impact on global energy conservation.\n\nStarting from conservation of energy and Fourier’s law, and using the finite-volume framework described above:\n- Derive a consistent explicit Euler update for $T_i$ in terms of face fluxes and cell volumes.\n- Implement Strategy A (flux redistribution/clipping): modify the interfacial flux(es) adjacent to the small cut cell by a stabilization factor based on the local explicit stability requirement for diffusion, applied symmetrically to both sides of the affected face(s) so that per-face conservation is preserved.\n- Implement Strategy B (cell merging): treat the first two cells as a merged cluster with combined length $l_0 + l_1$; suppress the internal flux between them; drive the cluster’s energy change using only its external face(s); and distribute the cluster’s energy change to the constituent cells proportionally to their volumes so that global conservation is maintained.\n- Use insulated boundary conditions, so the theoretically exact total energy in the fluid subdomain remains constant in time.\n\nUse the following physical parameters: $k = 1\\,\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$, $C_v = 1000\\,\\mathrm{J}/(\\mathrm{m}^3\\cdot\\mathrm{K})$, $A = 1\\,\\mathrm{m}^2$. Use an initial temperature field $$T(x) = \\sin(2\\pi x),$$ sampled at cell centers for the given nonuniform mesh. Advance in time using explicit Euler with time step $\\Delta t = 0.01\\,\\mathrm{s}$ for $n = 100$ steps. For each simulation, compute the absolute global energy error in joules at the end of the run, defined as $$E_\\mathrm{err} = \\left| \\sum_{i=0}^{N-1} C_v l_i T_i^{(n)} - \\sum_{i=0}^{N-1} C_v l_i T_i^{(0)} \\right|.$$\n\nTest Suite:\n- Test 1 (happy path, no cut): $N = 50$, $\\alpha = 1$, strategy = none. Expect near-zero energy error due to insulated boundaries and conservation.\n- Test 2 (moderate cut, flux redistribution): $N = 50$, $\\alpha = 0.05$, strategy = flux redistribution/clipping. Evaluate $E_\\mathrm{err}$.\n- Test 3 (severe cut, cell merging): $N = 50$, $\\alpha = 0.01$, strategy = cell merging. Evaluate $E_\\mathrm{err}$.\n- Test 4 (extreme cut, flux redistribution): $N = 50$, $\\alpha = 0.001$, strategy = flux redistribution/clipping. Evaluate $E_\\mathrm{err}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"). Each result must be a float giving the absolute energy error $E_\\mathrm{err}$ in joules for the corresponding test case, using the parameter values above and the strategies as described. Angles, if any, must be in radians. Express all energies in joules. No percentages are required in this problem.",
            "solution": "The problem statement has been critically validated and is deemed valid. It presents a well-posed problem in computational thermal engineering, free from scientific or logical contradictions, although it contains a minor ambiguity regarding the total domain length common in immersed boundary literature, which does not impede the solvability or the core objective of the problem. The task is to implement and evaluate two common stabilization strategies for the Immersed Boundary Method (IBM) applied to a transient heat diffusion problem, focusing on their impact on global energy conservation. All provided data and conditions are sufficient and consistent for deriving a solution.\n\nThe governing partial differential equation for one-dimensional heat diffusion is:\n$$ \\frac{\\partial T}{\\partial t} = \\kappa \\frac{\\partial^2 T}{\\partial x^2} $$\nwhere $\\kappa = k / (\\rho c)$ is the thermal diffusivity. The problem is formulated using a finite-volume method. The semi-discrete form of the energy conservation law for a control volume (cell) $i$ of length $l_i$ is given as:\n$$ \\frac{\\mathrm{d}}{\\mathrm{d}t}\\left(C_v \\, l_i \\, T_i\\right) = F_{i-\\frac{1}{2}} - F_{i+\\frac{1}{2}} $$\nwhere $C_v = \\rho c$ is the volumetric heat capacity, $T_i$ is the average temperature in cell $i$, and $F_{i\\pm\\frac{1}{2}}$ are the heat fluxes across the cell faces. Since $C_v$ and $l_i$ are constant in time, we can write:\n$$ C_v l_i \\frac{\\mathrm{d}T_i}{\\mathrm{d}t} = F_{i-\\frac{1}{2}} - F_{i+\\frac{1}{2}} $$\nApplying an explicit Euler time integration scheme, where the time derivative is approximated as $\\frac{\\mathrm{d}T_i}{\\mathrm{d}t} \\approx \\frac{T_i^{n+1} - T_i^n}{\\Delta t}$, we derive the update rule for the temperature $T_i$ at the new time step $n+1$:\n$$ \\frac{T_i^{n+1} - T_i^n}{\\Delta t} = \\frac{1}{C_v l_i} \\left( F_{i-\\frac{1}{2}}^n - F_{i+\\frac{1}{2}}^n \\right) $$\n$$ T_i^{n+1} = T_i^n + \\frac{\\Delta t}{C_v l_i} \\left( F_{i-\\frac{1}{2}}^n - F_{i+\\frac{1}{2}}^n \\right) $$\nThe heat flux $F_{i+\\frac{1}{2}}^n$ at face $i+\\frac{1}{2}$ is calculated based on Fourier's law, using temperatures at time level $n$:\n$$ F_{i+\\frac{1}{2}}^n = -k A \\frac{T_{i+1}^n - T_i^n}{d_{i+\\frac{1}{2}}} $$\nwhere $d_{i+\\frac{1}{2}} = \\frac{1}{2}(l_i + l_{i+1})$ is the distance between the centers of cell $i$ and cell $i+1$. The insulated boundary conditions imply zero flux at the domain ends: $F_{-\\frac{1}{2}} = 0$ and $F_{N-\\frac{1}{2}} = 0$.\n\nA key feature of this numerical scheme is its adherence to global energy conservation. The rate of change of the total energy in the domain, $E_\\mathrm{total} = \\sum_{i=0}^{N-1} C_v l_i T_i$, is:\n$$ \\frac{\\mathrm{d}E_\\mathrm{total}}{\\mathrm{d}t} = \\sum_{i=0}^{N-1} C_v l_i \\frac{\\mathrm{d}T_i}{\\mathrm{d}t} = \\sum_{i=0}^{N-1} \\left( F_{i-\\frac{1}{2}} - F_{i+\\frac{1}{2}} \\right) $$\nThis forms a telescoping sum: $(F_{-\\frac{1}{2}} - F_{\\frac{1}{2}}) + (F_{\\frac{1}{2}} - F_{\\frac{3}{2}}) + \\dots + (F_{N-\\frac{3}{2}} - F_{N-\\frac{1}{2}}) = F_{-\\frac{1}{2}} - F_{N-\\frac{1}{2}}$. Given the insulated boundaries, this sum is $0 - 0 = 0$. Thus, the total energy should theoretically remain constant.\n\nThe stabilization strategies are necessitated by the stability constraint of the explicit scheme, which is particularly restrictive for the small cut cell (cell $0$).\n\n**Strategy A: Flux Redistribution/Clipping**\nThe stability of the explicit Euler scheme requires that the time step $\\Delta t$ satisfies a local Courant-Friedrichs-Lewy (CFL) condition for each cell. For the small cut cell $0$, adjacent to an insulated boundary, the update rule $T_0^{n+1} = T_0^n - \\frac{\\Delta t}{C_v l_0} F_{0+\\frac{1}{2}}^n$ leads to a stability limit. Substituting the flux expression yields:\n$$ T_0^{n+1} = T_0^n \\left( 1 - \\frac{\\Delta t \\cdot k A}{C_v l_0 d_{0+\\frac{1}{2}}} \\right) + \\dots $$\nFor stability, the coefficient of $T_0^n$ must be non-negative, which requires $\\Delta t \\le \\frac{C_v l_0 d_{0+\\frac{1}{2}}}{k A}$. This local time step limit, let's call it $\\Delta t_{\\mathrm{loc},0}$, becomes very small as $l_0 \\to 0$.\nTo use a fixed, larger $\\Delta t$, the flux $F_{0+\\frac{1}{2}}$ is scaled by a stabilization factor $s$:\n$$ s = \\min\\left(1.0, \\frac{\\Delta t_{\\mathrm{loc},0}}{\\Delta t}\\right) = \\min\\left(1.0, \\frac{C_v l_0 d_{0+\\frac{1}{2}}}{k A \\Delta t}\\right) $$\nThe modified flux $F'_{0+\\frac{1}{2}} = s \\cdot F_{0+\\frac{1}{2}}$ is used in the update equations for both cell $0$ and cell $1$. This preserves per-face conservation (flux out of cell $0$ equals flux into cell $1$) and, by extension, global energy conservation, as the telescoping sum property remains intact.\n\n**Strategy B: Cell Merging**\nThis strategy merges the small cell $0$ with its neighbor, cell $1$, into a single computational cluster.\n1. The internal flux between them is set to zero: $F_{0+\\frac{1}{2}} = 0$.\n2. The energy of the merged cluster, $E_m = E_0 + E_1 = C_v l_0 T_0 + C_v l_1 T_1$, is updated based on its external fluxes, which are $F_{-\\frac{1}{2}} = 0$ (at the boundary) and $F_{1+\\frac{1}{2}}$ (at the interface with cell $2$). The rate of change of the cluster's energy is $\\frac{\\mathrm{d}E_m}{\\mathrm{d}t} = F_{-\\frac{1}{2}} - F_{1+\\frac{1}{2}} = -F_{1+\\frac{1}{2}}$.\n3. The total energy change of the cluster over one time step, $\\Delta E_m = -\\Delta t \\cdot F_{1+\\frac{1}{2}}^n$, is distributed to cells $0$ and $1$ proportionally to their volumes (or lengths, since area is constant):\n$$ \\Delta E_0 = \\Delta E_m \\frac{l_0}{l_0 + l_1}, \\quad \\Delta E_1 = \\Delta E_m \\frac{l_1}{l_0 + l_1} $$\nThe temperatures are then updated:\n$$ T_0^{n+1} = T_0^n + \\frac{\\Delta E_0}{C_v l_0} = T_0^n + \\frac{\\Delta E_m}{C_v (l_0 + l_1)} $$\n$$ T_1^{n+1} = T_1^n + \\frac{\\Delta E_1}{C_v l_1} = T_1^n + \\frac{\\Delta E_m}{C_v (l_0 + l_1)} $$\nThis is equivalent to applying the same temperature increment to both cells in the cluster. This method is also inherently conservative. The total energy change of the system is the sum of changes in all cells (or clusters), which again telescopes to zero due to the cancellation of internal fluxes.\n\nBoth strategies are designed to be perfectly conservative. The computed absolute energy error, $E_\\mathrm{err}$, should therefore be close to zero, limited only by floating-point arithmetic precision, demonstrating the effectiveness of these methods in maintaining global conservation while ensuring numerical stability.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D transient heat conduction problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        (50, 1.0, \"none\"),\n        (50, 0.05, \"flux_redistribution/clipping\"),\n        (50, 0.01, \"cell_merging\"),\n        (50, 0.001, \"flux_redistribution/clipping\"),\n    ]\n\n    results = []\n    for N, alpha, strategy in test_cases:\n        result = simulate_case(N, alpha, strategy)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef simulate_case(N, alpha, strategy):\n    \"\"\"\n    Runs a single simulation case and returns the absolute energy error.\n\n    Args:\n        N (int): Number of nominal cells.\n        alpha (float): Fraction of the first cell's length.\n        strategy (str): Stabilization strategy ('none', 'flux_redistribution/clipping', 'cell_merging').\n\n    Returns:\n        float: Absolute global energy error in joules.\n    \"\"\"\n    # Physical and numerical parameters\n    L = 1.0\n    k = 1.0\n    Cv = 1000.0\n    A = 1.0\n    dt = 0.01\n    n_steps = 100\n\n    # Grid setup\n    dx = L / N\n    l = np.full(N, dx, dtype=np.float64)\n    l[0] = alpha * dx\n\n    # Cell center positions\n    x_coords = np.zeros(N, dtype=np.float64)\n    x_coords[0] = l[0] / 2.0\n    cell_left_edge = l[0]\n    for i in range(1, N):\n        x_coords[i] = cell_left_edge + l[i] / 2.0\n        cell_left_edge += l[i]\n\n    # Distances between cell centers\n    d = np.zeros(N - 1, dtype=np.float64)\n    for i in range(N - 1):\n        d[i] = (l[i] + l[i + 1]) / 2.0\n\n    # Initial condition\n    T_current = np.sin(2 * np.pi * x_coords, dtype=np.float64)\n\n    # Calculate initial total energy\n    E_initial = np.sum(Cv * l * T_current)\n\n    # Time-stepping loop\n    for _ in range(n_steps):\n        T_new = np.copy(T_current)\n\n        # Calculate fluxes at all internal faces (F[i+1] corresponds to face i+1/2)\n        F = np.zeros(N + 1, dtype=np.float64)\n        for i in range(N - 1):\n            F[i + 1] = -k * A * (T_current[i + 1] - T_current[i]) / d[i]\n\n        # Apply stabilization strategy\n        if strategy == \"flux_redistribution/clipping\":\n            # stability limit for cell 0\n            dt_loc_0 = (Cv * l[0] * d[0]) / (k * A)\n            s = min(1.0, dt_loc_0 / dt)\n            F[1] *= s\n            \n            # General update for all cells\n            # Cell 0 (left boundary, flux F[-1/2] = 0)\n            net_flux_rate_0 = -F[1]\n            T_new[0] = T_current[0] + (dt / (Cv * l[0])) * net_flux_rate_0\n            # Internal cells\n            for i in range(1, N - 1):\n                net_flux_rate_i = F[i] - F[i + 1]\n                T_new[i] = T_current[i] + (dt / (Cv * l[i])) * net_flux_rate_i\n            # Cell N-1 (right boundary, flux F[N-1/2] = 0)\n            net_flux_rate_N_1 = F[N - 1]\n            T_new[N-1] = T_current[N-1] + (dt / (Cv * l[N-1])) * net_flux_rate_N_1\n\n        elif strategy == \"cell_merging\":\n            # Suppress flux between cell 0 and 1\n            F[1] = 0.0\n            \n            # Energy change of the merged cluster (0, 1) due to external flux F[1+1/2]\n            flux_out_of_cluster = F[2]\n            delta_E_m = -dt * flux_out_of_cluster\n            \n            # Distribute temp change to cells 0 and 1\n            l_m = l[0] + l[1]\n            delta_T_cluster = delta_E_m / (Cv * l_m)\n            T_new[0] = T_current[0] + delta_T_cluster\n            T_new[1] = T_current[1] + delta_T_cluster\n            \n            # Update other cells normally\n            for i in range(2, N - 1):\n                net_flux_rate_i = F[i] - F[i + 1]\n                T_new[i] = T_current[i] + (dt / (Cv * l[i])) * net_flux_rate_i\n            # Update cell N-1\n            if N  2:\n                net_flux_rate_N_1 = F[N-1]\n                T_new[N-1] = T_current[N-1] + (dt / (Cv * l[N-1])) * net_flux_rate_N_1\n\n        else: # \"none\" strategy\n            # General update for all cells\n            # Cell 0 (left boundary, F[-1/2]=0)\n            net_flux_rate_0 = -F[1]\n            T_new[0] = T_current[0] + (dt / (Cv * l[0])) * net_flux_rate_0\n            # Internal cells\n            for i in range(1, N - 1):\n                net_flux_rate_i = F[i] - F[i + 1]\n                T_new[i] = T_current[i] + (dt / (Cv * l[i])) * net_flux_rate_i\n            # Cell N-1 (right boundary, F[N-1/2]=0)\n            net_flux_rate_N_1 = F[N-1]\n            T_new[N-1] = T_current[N-1] + (dt / (Cv * l[N-1])) * net_flux_rate_N_1\n            \n        T_current = T_new\n\n    # Final Energy\n    E_final = np.sum(Cv * l * T_current)\n    \n    # Absolute Energy Error\n    E_err = np.abs(E_final - E_initial)\n    \n    return E_err\n\nsolve()\n```"
        },
        {
            "introduction": "A robust numerical method must not only be stable and locally accurate, but it must also respect fundamental physical laws, such as the conservation of energy. This practice  offers a powerful method for verifying the consistency of your immersed boundary implementation by leveraging the divergence theorem. You will calculate the total heat transfer across the immersed surface from two distinct perspectives—a Lagrangian surface integral and an Eulerian volume integral—and reconcile the results. This process provides deep insight into the interplay between the two frames of reference and confirms that your discrete operators correctly capture the integral conservation laws.",
            "id": "3961812",
            "problem": "You are asked to compute the total conductive heat transfer across a smoothly immersed, closed curve embedded inside a uniform Cartesian grid, using two complementary formulations grounded in first principles of heat conduction. The setting models a two-dimensional, steady conduction process with a spatially varying temperature field sampled on an Eulerian grid, and a circular immersed boundary treated with a Lagrangian quadrature. The goal is to quantify and reconcile the total heat transfer obtained by the Eulerian control-volume approach and the Lagrangian surface integral approach, using consistent interpolation between the two descriptions, as is standard in the immersed boundary method (IBM).\n\nFundamental base:\n- Fourier’s law of heat conduction: the heat flux vector is $\\mathbf{q} = -k \\nabla T$, where $k$ is the thermal conductivity and $T$ is the temperature field.\n- The divergence theorem (Gauss’ theorem) in two dimensions: for any sufficiently smooth vector field $\\mathbf{F}$ and a region $\\Omega$ with boundary $\\partial \\Omega$ and outward unit normal $\\mathbf{n}$, \n$$\n\\int_{\\partial \\Omega} \\mathbf{F} \\cdot \\mathbf{n} \\, \\mathrm{d}s = \\int_{\\Omega} \\nabla \\cdot \\mathbf{F} \\, \\mathrm{d}A.\n$$\nApplied to $\\mathbf{F} = \\mathbf{q} = -k \\nabla T$, this yields \n$$\n\\int_{\\partial \\Omega} \\mathbf{q} \\cdot \\mathbf{n} \\, \\mathrm{d}s = -\\int_{\\Omega} \\nabla \\cdot (k \\nabla T) \\, \\mathrm{d}A.\n$$\n\nImmersed boundary method (IBM) perspective:\n- The immersed boundary is represented in a Lagrangian frame by a parametric curve $\\mathbf{X}(\\theta)$ with $\\theta$ the curve parameter (angle in radians).\n- The Eulerian grid stores the scalar field $T$ and its discrete gradients $\\nabla T$, which are interpolated to Lagrangian points. This interpolation is a practical surrogate for the regularized Dirac delta used in IBM to couple Lagrangian and Eulerian descriptions.\n\nYou must implement both total heat transfer evaluations across a circle $\\Gamma$ of radius $R$ centered at $(c_x,c_y)$:\n1. Lagrangian quadrature of the surface integral \n$$\nQ_{\\mathrm{Lag}} = \\int_{\\Gamma} \\mathbf{q} \\cdot \\mathbf{n} \\, \\mathrm{d}s, \\quad \\mathbf{q} = -k \\nabla T, \\quad \\mathbf{n} \\text{ is the outward unit normal on } \\Gamma,\n$$\napproximated as a composite trapezoidal rule over $N_s$ uniformly spaced angles $\\theta \\in [0,2\\pi)$ in radians. At each Lagrangian point $\\mathbf{X}(\\theta) = (c_x + R \\cos\\theta, c_y + R \\sin\\theta)$, obtain $\\nabla T$ by bilinear interpolation of the Eulerian discrete gradients.\n\n2. Eulerian control-volume flux using the divergence theorem over the disk $\\Omega$ interior to $\\Gamma$:\n$$\nQ_{\\mathrm{Eul}} = -\\int_{\\Omega} \\nabla \\cdot (k \\nabla T) \\, \\mathrm{d}A,\n$$\napproximated by summing the discrete Laplacian of $T$ multiplied by $k$ and the cell area $\\Delta x \\, \\Delta y$ over the set of grid cell centers lying inside the circle.\n\nDiscretization details to implement:\n- Use a uniform Cartesian grid of $N_x \\times N_y$ cell centers spanning $[0,1] \\times [0,1]$ meters with $\\Delta x = 1/N_x$ and $\\Delta y = 1/N_y$. The cell-center coordinates are $x_i = (i + \\tfrac{1}{2}) \\Delta x$, $y_j = (j + \\tfrac{1}{2}) \\Delta y$, where $i=0,\\dots,N_x-1$ and $j=0,\\dots,N_y-1$.\n- Compute the discrete gradients $\\partial T / \\partial x$ and $\\partial T / \\partial y$ by second-order finite differences in the interior:\n$$\n\\left.\\frac{\\partial T}{\\partial x}\\right|_{j,i} \\approx \\frac{T_{j,i+1} - T_{j,i-1}}{2\\Delta x}, \\quad\n\\left.\\frac{\\partial T}{\\partial y}\\right|_{j,i} \\approx \\frac{T_{j+1,i} - T_{j-1,i}}{2\\Delta y}.\n$$\nFor boundary indices, use second-order one-sided differences to fill values.\n- Compute the discrete Laplacian by second-order central differences in the interior:\n$$\n(\\nabla^2 T)_{j,i} \\approx \\frac{T_{j,i+1} - 2T_{j,i} + T_{j,i-1}}{\\Delta x^2} + \\frac{T_{j+1,i} - 2T_{j,i} + T_{j-1,i}}{\\Delta y^2}.\n$$\n- Bilinear interpolation at a point $(x,y)$ uses the four neighboring cell centers $(x_i,y_j), (x_{i+1},y_j), (x_i,y_{j+1}), (x_{i+1},y_{j+1})$ with weights determined by relative position within the cell.\n\nTemperature fields and units:\n- Let $k$ be specified in $\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$, positions in meters, and temperature in kelvin. The temperature fields are constructed so that units are consistent:\n  - Radial quadratic: $T(x,y) = T_0 + A\\left[(x-c_x)^2 + (y-c_y)^2\\right]$, with $A$ in $\\mathrm{K}/\\mathrm{m}^2$.\n  - Linear: $T(x,y) = T_0 + B(x-c_x) + C(y-c_y)$, with $B, C$ in $\\mathrm{K}/\\mathrm{m}$.\n  - Anisotropic quadratic: $T(x,y) = T_0 + A_x(x-c_x)^2 + A_y(y-c_y)^2$, with $A_x, A_y$ in $\\mathrm{K}/\\mathrm{m}^2$.\n- Angles $\\theta$ for the Lagrangian parameterization must be in radians.\n\nScientific realism and reconciliation:\n- The two fluxes $Q_{\\mathrm{Lag}}$ and $Q_{\\mathrm{Eul}}$ should agree in the continuum limit. Discrepancies arise due to discretization, interpolation, and geometric masking of cells near the immersed boundary. You must report both fluxes and their absolute difference $D = |Q_{\\mathrm{Lag}} - Q_{\\mathrm{Eul}}|$.\n\nTest suite:\nImplement the program to evaluate the following four cases. All circles are strictly inside the domain so that boundary artifacts are minimized.\n\n- Case 1 (happy path, smooth and symmetric field):\n  - $N_x = N_y = 128$, $k = 1.0 \\ \\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$, $(c_x,c_y) = (0.5,0.5) \\ \\mathrm{m}$, $R = 0.20 \\ \\mathrm{m}$, $N_s = 1024$,\n  - $T_0 = 300 \\ \\mathrm{K}$, $A = 8 \\ \\mathrm{K}/\\mathrm{m}^2$,\n  - Temperature: radial quadratic.\n\n- Case 2 (edge case, coarse grid and small geometry scale):\n  - $N_x = N_y = 32$, $k = 1.0 \\ \\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$, $(c_x,c_y) = (0.5,0.5) \\ \\mathrm{m}$, $R = 0.20 \\ \\mathrm{m}$, $N_s = 256$,\n  - $T_0 = 300 \\ \\mathrm{K}$, $A = 8 \\ \\mathrm{K}/\\mathrm{m}^2$,\n  - Temperature: radial quadratic.\n\n- Case 3 (boundary condition case, zero net flux expectation):\n  - $N_x = N_y = 64$, $k = 1.0 \\ \\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$, $(c_x,c_y) = (0.5,0.5) \\ \\mathrm{m}$, $R = 0.30 \\ \\mathrm{m}$, $N_s = 512$,\n  - $T_0 = 300 \\ \\mathrm{K}$, $B = 10 \\ \\mathrm{K}/\\mathrm{m}$, $C = -7 \\ \\mathrm{K}/\\mathrm{m}$,\n  - Temperature: linear.\n\n- Case 4 (anisotropic quadratic field, non-symmetric gradients):\n  - $N_x = N_y = 96$, $k = 1.0 \\ \\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$, $(c_x,c_y) = (0.5,0.5) \\ \\mathrm{m}$, $R = 0.25 \\ \\mathrm{m}$, $N_s = 512$,\n  - $T_0 = 300 \\ \\mathrm{K}$, $A_x = 3 \\ \\mathrm{K}/\\mathrm{m}^2$, $A_y = 1 \\ \\mathrm{K}/\\mathrm{m}^2$,\n  - Temperature: anisotropic quadratic.\n\nRequired outputs:\n- For each case, compute $Q_{\\mathrm{Lag}}$ and $Q_{\\mathrm{Eul}}$ in watts and the absolute difference $D$ in watts.\n- Express all values in watts ($W$), rounded to six decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order\n$$\n[Q_{\\mathrm{Lag}}^{(1)}, Q_{\\mathrm{Eul}}^{(1)}, D^{(1)}, Q_{\\mathrm{Lag}}^{(2)}, Q_{\\mathrm{Eul}}^{(2)}, D^{(2)}, Q_{\\mathrm{Lag}}^{(3)}, Q_{\\mathrm{Eul}}^{(3)}, D^{(3)}, Q_{\\mathrm{Lag}}^{(4)}, Q_{\\mathrm{Eul}}^{(4)}, D^{(4)}],\n$$\nwhere the superscript $(\\cdot)$ denotes the case index.",
            "solution": "The problem requires the computation of the total conductive heat transfer across a closed, circular boundary immersed in a two-dimensional domain. This will be accomplished by implementing two distinct but physically equivalent formulations: a Lagrangian surface integral along the boundary and an Eulerian volume integral over the area enclosed by the boundary. The comparison of their results is a fundamental validation technique in the context of immersed boundary methods (IBM). The entire analysis is based on Fourier's law of heat conduction and the divergence theorem.\n\nFirst, we establish the mathematical and physical framework. The heat flux vector, $\\mathbf{q}$, is given by Fourier's law:\n$$\n\\mathbf{q} = -k \\nabla T\n$$\nwhere $k$ is the thermal conductivity (assumed constant) and $T$ is the temperature field. The total heat transfer, $Q$, across a closed curve $\\Gamma$ is the flux of $\\mathbf{q}$ through $\\Gamma$:\n$$\nQ = \\oint_{\\Gamma} \\mathbf{q} \\cdot \\mathbf{n} \\, \\mathrm{d}s\n$$\nwhere $\\mathbf{n}$ is the outward unit normal vector to $\\Gamma$, and $\\mathrm{d}s$ is the differential arc length. By applying the divergence theorem to the region $\\Omega$ enclosed by $\\Gamma$, this surface integral can be converted into a volume (area in 2D) integral:\n$$\nQ = \\int_{\\Omega} \\nabla \\cdot \\mathbf{q} \\, \\mathrm{d}A = -\\int_{\\Omega} \\nabla \\cdot (k \\nabla T) \\, \\mathrm{d}A = -k \\int_{\\Omega} \\nabla^2 T \\, \\mathrm{d}A\n$$\nThese two expressions for $Q$ form the basis for the two computational methods.\n\nThe problem is discretized on a uniform Cartesian grid defined over the domain $[0,1] \\times [0,1]$. The grid consists of $N_x \\times N_y$ cells, with grid spacings $\\Delta x = 1/N_x$ and $\\Delta y = 1/N_y$. The coordinates of the cell centers are given by $x_i = (i + 0.5)\\Delta x$ for $i \\in \\{0, 1, \\dots, N_x-1\\}$ and $y_j = (j + 0.5)\\Delta y$ for $j \\in \\{0, 1, \\dots, N_y-1\\}$. The continuous temperature field $T(x,y)$ is evaluated at these cell centers to produce a discrete field $T_{j,i} = T(x_i, y_j)$.\n\nTo evaluate the integrals, we need discrete approximations for the gradient and Laplacian operators. We compute the gradient components, $\\partial T / \\partial x$ and $\\partial T / \\partial y$, on the grid. For interior nodes, second-order central differences are used:\n$$\n\\left.\\frac{\\partial T}{\\partial x}\\right|_{j,i} \\approx \\frac{T_{j,i+1} - T_{j,i-1}}{2\\Delta x}, \\quad \\left.\\frac{\\partial T}{\\partial y}\\right|_{j,i} \\approx \\frac{T_{j+1,i} - T_{j-1,i}}{2\\Delta y}\n$$\nFor nodes on the domain boundaries (e.g., $i=0$ or $i=N_x-1$), second-order one-sided difference formulas are employed to maintain accuracy across the entire grid. For instance, at the left boundary ($i=0$):\n$$\n\\left.\\frac{\\partial T}{\\partial x}\\right|_{j,0} \\approx \\frac{-3T_{j,0} + 4T_{j,1} - T_{j,2}}{2\\Delta x}\n$$\nAnd at the right boundary ($i=N_x-1$):\n$$\n\\left.\\frac{\\partial T}{\\partial x}\\right|_{j,N_x-1} \\approx \\frac{3T_{j,N_x-1} - 4T_{j,N_x-2} + T_{j,N_x-3}}{2\\Delta x}\n$$\nAnalogous formulas apply for the $y$-gradient at the $j=0$ and $j=N_y-1$ boundaries.\n\nThe Laplacian, $\\nabla^2 T$, is required for the Eulerian volume integral. As the circles in all test cases are strictly within the domain, we only need to evaluate the Laplacian at interior grid points. The standard second-order central difference scheme is sufficient:\n$$\n(\\nabla^2 T)_{j,i} \\approx \\frac{T_{j,i+1} - 2T_{j,i} + T_{j,i-1}}{\\Delta x^2} + \\frac{T_{j+1,i} - 2T_{j,i} + T_{j-1,i}}{\\Delta y^2}\n$$\n\nThe first method, the Lagrangian surface quadrature ($Q_{\\mathrm{Lag}}$), approximates the surface integral. The circular boundary $\\Gamma$ with radius $R$ and center $(c_x, c_y)$ is parameterized in a Lagrangian frame by $\\mathbf{X}(\\theta) = (c_x + R\\cos\\theta, c_y + R\\sin\\theta)$ for $\\theta \\in [0, 2\\pi)$. The outward unit normal is $\\mathbf{n}(\\theta) = (\\cos\\theta, \\sin\\theta)$, and the arc length element is $\\mathrm{d}s = R\\,\\mathrm{d}\\theta$. The integral becomes:\n$$\nQ_{\\mathrm{Lag}} = -k R \\int_0^{2\\pi} \\nabla T(\\mathbf{X}(\\theta)) \\cdot \\mathbf{n}(\\theta) \\, \\mathrm{d}\\theta\n$$\nThis integral is numerically approximated using the composite trapezoidal rule over $N_s$ uniformly spaced points. With angular step size $\\Delta\\theta = 2\\pi/N_s$ and angles $\\theta_m = m\\Delta\\theta$ for $m \\in \\{0, \\dots, N_s-1\\}$, the sum is:\n$$\nQ_{\\mathrm{Lag}} \\approx -k R \\Delta\\theta \\sum_{m=0}^{N_s-1} \\left( \\nabla T(\\mathbf{X}(\\theta_m)) \\cdot \\mathbf{n}(\\theta_m) \\right)\n$$\nA crucial step in this process is the coupling of the Lagrangian and Eulerian frames. The gradient vector $\\nabla T$ at each Lagrangian point $\\mathbf{X}(\\theta_m)$ is not directly available. It must be interpolated from the discrete gradient fields, $\\partial T/\\partial x$ and $\\partial T/\\partial y$, which are defined on the Eulerian grid. We use bilinear interpolation for this purpose. For a point $(x,y)$, we identify the four surrounding cell centers and use a weighted average of the gradient values at these centers to find the interpolated gradient at $(x,y)$.\n\nThe second method, the Eulerian volume integration ($Q_{\\mathrm{Eul}}$), approximates the area integral derived from the divergence theorem:\n$$\nQ_{\\mathrm{Eul}} \\approx -k \\sum_{(x_i, y_j) \\in \\Omega} (\\nabla^2 T)_{j,i} \\, \\Delta x \\Delta y\n$$\nThe summation is performed over the set of all grid cell centers $(x_i, y_j)$ that lie strictly inside the circle $\\Gamma$. This is determined by the condition $(x_i - c_x)^2 + (y_j - c_y)^2  R^2$. The value $(\\nabla^2 T)_{j,i}$ is the discrete Laplacian computed at each interior cell center. This approach relies on a \"masking\" technique to represent the geometry, which is a common feature of Cartesian grid methods for complex domains.\n\nFinally, the absolute difference $D = |Q_{\\mathrm{Lag}} - Q_{\\mathrm{Eul}}|$ is computed. In the continuum limit, $D$ should be zero. In a discrete setting, $D  0$ reflects the combined effects of discretization errors in the finite difference schemes, interpolation errors from the Eulerian to the Lagrangian frame, and geometric approximation errors (aliasing) in both the Lagrangian quadrature and the Eulerian cell masking. Comparing $Q_{\\mathrm{Lag}}$, $Q_{\\mathrm{Eul}}$, and their analytical values (where available) provides a rigorous verification of the numerical implementation.",
            "answer": "```python\nimport numpy as np\n\ndef compute_gradients(T, dx, dy):\n    \"\"\"\n    Computes the gradient of a 2D scalar field T using second-order finite differences.\n    \"\"\"\n    Ny, Nx = T.shape\n    Gx = np.zeros_like(T, dtype=float)\n    Gy = np.zeros_like(T, dtype=float)\n\n    # Gx: Central difference for interior\n    if Nx  2:\n        Gx[:, 1:-1] = (T[:, 2:] - T[:, :-2]) / (2 * dx)\n        # Gx: Second-order one-sided for boundaries\n        Gx[:, 0] = (-3 * T[:, 0] + 4 * T[:, 1] - T[:, 2]) / (2 * dx)\n        Gx[:, -1] = (3 * T[:, -1] - 4 * T[:, -2] + T[:, -3]) / (2 * dx)\n    elif Nx == 2: # Handle very small grids\n        Gx[:, 0] = (T[:, 1] - T[:, 0]) / dx\n        Gx[:, 1] = (T[:, 1] - T[:, 0]) / dx\n\n\n    # Gy: Central difference for interior\n    if Ny  2:\n        Gy[1:-1, :] = (T[2:, :] - T[:-2, :]) / (2 * dy)\n        # Gy: Second-order one-sided for boundaries\n        Gy[0, :] = (-3 * T[0, :] + 4 * T[1, :] - T[2, :]) / (2 * dy)\n        Gy[-1, :] = (3 * T[-1, :] - 4 * T[-2, :] + T[-3, :]) / (2 * dy)\n    elif Ny == 2:\n        Gy[0, :] = (T[1, :] - T[0, :]) / dy\n        Gy[1, :] = (T[1, :] - T[0, :]) / dy\n        \n    return Gx, Gy\n\ndef compute_laplacian(T, dx, dy):\n    \"\"\"\n    Computes the Laplacian of a 2D scalar field T using second-order central differences\n    for the interior grid points. Boundaries are left as zero.\n    \"\"\"\n    lap_T = np.zeros_like(T, dtype=float)\n    Ny, Nx = T.shape\n    if Nx  2 and Ny  2:\n        lap_T[1:-1, 1:-1] = (T[1:-1, 2:] - 2*T[1:-1, 1:-1] + T[1:-1, :-2]) / dx**2 + \\\n                            (T[2:, 1:-1] - 2*T[1:-1, 1:-1] + T[:-2, 1:-1]) / dy**2\n    return lap_T\n\ndef bilinear_interp(field, pt_x, pt_y, dx, dy):\n    \"\"\"\n    Performs bilinear interpolation of a field value at a point (pt_x, pt_y).\n    \"\"\"\n    Ny, Nx = field.shape\n    \n    i_float = pt_x / dx - 0.5\n    j_float = pt_y / dy - 0.5\n    \n    i_idx = int(i_float)\n    j_idx = int(j_float)\n    \n    # Clip to ensure indices are within bounds for the 4-point stencil\n    i_idx = np.clip(i_idx, 0, Nx - 2)\n    j_idx = np.clip(j_idx, 0, Ny - 2)\n    \n    t = i_float - i_idx\n    u = j_float - j_idx\n    \n    val = ((1 - t) * (1 - u) * field[j_idx, i_idx] +\n           t * (1 - u) * field[j_idx, i_idx + 1] +\n           (1 - t) * u * field[j_idx + 1, i_idx] +\n           t * u * field[j_idx + 1, i_idx + 1])\n    return val\n\ndef calculate_Q_lagrangian(Gx, Gy, dx, dy, k, cx, cy, R, Ns):\n    \"\"\"\n    Calculates total heat transfer using Lagrangian surface quadrature.\n    \"\"\"\n    d_theta = 2 * np.pi / Ns\n    thetas = np.arange(Ns) * d_theta\n    integrand_sum = 0.0\n\n    for theta in thetas:\n        x_L = cx + R * np.cos(theta)\n        y_L = cy + R * np.sin(theta)\n        nx = np.cos(theta)\n        ny = np.sin(theta)\n        \n        grad_Tx = bilinear_interp(Gx, x_L, y_L, dx, dy)\n        grad_Ty = bilinear_interp(Gy, x_L, y_L, dx, dy)\n        \n        gradT_dot_n = grad_Tx * nx + grad_Ty * ny\n        integrand_sum += gradT_dot_n\n        \n    Q_lag = -k * R * integrand_sum * d_theta\n    return Q_lag\n\ndef calculate_Q_eulerian(lap_T, xx, yy, dx, dy, k, cx, cy, R):\n    \"\"\"\n    Calculates total heat transfer using Eulerian volume integration.\n    \"\"\"\n    dA = dx * dy\n    mask = (xx - cx)**2 + (yy - cy)**2  R**2\n    \n    Q_eul = -k * np.sum(lap_T[mask]) * dA\n    return Q_eul\n\ndef solve():\n    \"\"\"\n    Main solver function to process all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path, smooth and symmetric field)\n        {'Nx': 128, 'Ny': 128, 'k': 1.0, 'cx': 0.5, 'cy': 0.5, 'R': 0.20, 'Ns': 1024,\n         'T_type': 'radial_quad', 'T_params': {'T0': 300.0, 'A': 8.0}},\n        # Case 2 (edge case, coarse grid and small geometry scale)\n        {'Nx': 32, 'Ny': 32, 'k': 1.0, 'cx': 0.5, 'cy': 0.5, 'R': 0.20, 'Ns': 256,\n         'T_type': 'radial_quad', 'T_params': {'T0': 300.0, 'A': 8.0}},\n        # Case 3 (boundary condition case, zero net flux expectation)\n        {'Nx': 64, 'Ny': 64, 'k': 1.0, 'cx': 0.5, 'cy': 0.5, 'R': 0.30, 'Ns': 512,\n         'T_type': 'linear', 'T_params': {'T0': 300.0, 'B': 10.0, 'C': -7.0}},\n        # Case 4 (anisotropic quadratic field, non-symmetric gradients)\n        {'Nx': 96, 'Ny': 96, 'k': 1.0, 'cx': 0.5, 'cy': 0.5, 'R': 0.25, 'Ns': 512,\n         'T_type': 'anisotropic_quad', 'T_params': {'T0': 300.0, 'Ax': 3.0, 'Ay': 1.0}},\n    ]\n\n    results = []\n    for params in test_cases:\n        Nx, Ny, k, cx, cy, R, Ns = params['Nx'], params['Ny'], params['k'], params['cx'], params['cy'], params['R'], params['Ns']\n        \n        # 1. Setup Grid and Temperature Field\n        dx, dy = 1.0 / Nx, 1.0 / Ny\n        x_coords = (np.arange(Nx) + 0.5) * dx\n        y_coords = (np.arange(Ny) + 0.5) * dy\n        xx, yy = np.meshgrid(x_coords, y_coords)\n        \n        T_params = params['T_params']\n        if params['T_type'] == 'radial_quad':\n            T = T_params['T0'] + T_params['A'] * ((xx - cx)**2 + (yy - cy)**2)\n        elif params['T_type'] == 'linear':\n            T = T_params['T0'] + T_params['B'] * (xx - cx) + T_params['C'] * (yy - cy)\n        elif params['T_type'] == 'anisotropic_quad':\n            T = T_params['T0'] + T_params['Ax'] * (xx - cx)**2 + T_params['Ay'] * (yy - cy)**2\n\n        # 2. Compute Derivatives on Eulerian Grid\n        Gx, Gy = compute_gradients(T, dx, dy)\n        lap_T = compute_laplacian(T, dx, dy)\n\n        # 3. Calculate Lagrangian Flux\n        Q_lag = calculate_Q_lagrangian(Gx, Gy, dx, dy, k, cx, cy, R, Ns)\n        \n        # 4. Calculate Eulerian Flux\n        Q_eul = calculate_Q_eulerian(lap_T, xx, yy, dx, dy, k, cx, cy, R)\n        \n        # 5. Calculate Difference\n        D = abs(Q_lag - Q_eul)\n        \n        results.extend([Q_lag, Q_eul, D])\n\n    print(f\"[{','.join(f'{v:.6f}' for v in results)}]\")\n\nsolve()\n```"
        }
    ]
}