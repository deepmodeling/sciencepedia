{
    "hands_on_practices": [
        {
            "introduction": "在锐利界面浸入边界法中，核心挑战之一是在非贴体网格上精确施加边界条件。一种常见且有效的方法是“虚拟单元法”（ghost-cell method），它通过在固体域内设置虚拟单元的物理量值，来间接满足界面上的条件。本练习旨在引导您通过多项式插值，从第一性原理出发，推导用于保证二阶精度的虚拟单元温度表达式 。掌握这一推导是构建高阶浸入边界格式的数学基础。",
            "id": "3961914",
            "problem": "一个笛卡尔坐标系下的有限体积法热传导求解器采用浸入边界法（IBM）来处理任意穿过网格的光滑嵌入固体边界。为了施加温度的狄利克雷边界条件，固体内部的虚拟单元的温度被设定，使得沿着界面局部法线的插值能够恢复已知的边界温度。考虑一个虚拟单元，其中心位于界面的一条法线上。设 $s$ 表示沿着从边界指向流体的单位法线方向的有符号距离，其中在界面 $\\Gamma$ 上 $s=0$，在流体中 $s>0$，在固体中 $s<0$。沿着这条法线，虚拟单元中心位于 $s=-d_{g}$ 处，其中 $d_{g}>0$。沿同一法线的第一个和第二个相邻流体单元中心分别位于 $s=d_{1}$ 和 $s=d_{2}$ 处，其中 $0 < d_1 < d_2$。假设我们知道边界温度 $T_b$、第一个流体单元温度 $T_1$ 和第二个流体单元温度 $T_2$。您的任务是，通过这三个点 $(0, T_b)$、$(d_1, T_1)$ 和 $(d_2, T_2)$ 拟合一个唯一的二次多项式 $P(s)$，并用它来推导虚拟单元温度 $T_g = P(-d_g)$ 的封闭形式解析表达式。该表达式应为 $T_b$、$T_1$ 和 $T_2$ 以及距离 $d_g$、$d_1$ 和 $d_2$ 的函数。请在最终答案框中提供这个表达式。",
            "solution": "用户提供的问题陈述已经过验证，被认为是有效的。它具有科学依据，提法得当，并且是客观的。该问题概述了计算传热学中处理浸入边界的标准程序，并要求进行特定的数学推导。\n\n目标是推导虚拟单元温度 $T_g$ 的表达式。该温度对应于沿边界法线的温度分布 $T(s)$ 在 $T(-d_g)$ 处的值。推导过程需基于一个二次多项式，该多项式对沿此法线特定位置的三个已知温度值进行插值。给定的数据点为 $(s, T)$: $(0, T_b)$、$(d_1, T_1)$ 和 $(d_2, T_2)$。这里，$s$ 是距边界的有符号距离，$T_b$ 是指定的边界温度，$T_1$ 和 $T_2$ 分别是距边界 $d_1$ 和 $d_2$ 处的流体单元中心的已知温度。虚拟单元位于有符号距离 $s = -d_g$ 处。\n\n我们寻求一个唯一的二次多项式 $P(s)$，使得：\n$$ P(0) = T_b $$\n$$ P(d_1) = T_1 $$\n$$ P(d_2) = T_2 $$\n虚拟单元温度 $T_g$ 则定义为该多项式在 $s = -d_g$ 处的值，即 $T_g = P(-d_g)$。\n\n构造此类插值多项式的一个直接而系统的方法是拉格朗日插值法。通过三个点 $(s_0, y_0)$、$(s_1, y_1)$ 和 $(s_2, y_2)$ 的唯一二次多项式的拉格朗日形式由下式给出：\n$$ P(s) = y_0 L_0(s) + y_1 L_1(s) + y_2 L_2(s) $$\n其中 $L_0(s)$、$L_1(s)$ 和 $L_2(s)$ 是拉格朗日基多项式，定义为：\n$$ L_j(s) = \\prod_{i=0, i \\neq j}^{2} \\frac{s - s_i}{s_j - s_i} $$\n在我们的具体情况下，这些点是 $(s_0, y_0) = (0, T_b)$、$(s_1, y_1) = (d_1, T_1)$ 和 $(s_2, y_2) = (d_2, T_2)$。我们如下构造基多项式：\n\n对于 $j=0$：\n$$ L_0(s) = \\frac{s - s_1}{s_0 - s_1} \\cdot \\frac{s - s_2}{s_0 - s_2} = \\frac{s - d_1}{0 - d_1} \\cdot \\frac{s - d_2}{0 - d_2} = \\frac{(s-d_1)(s-d_2)}{d_1 d_2} $$\n\n对于 $j=1$：\n$$ L_1(s) = \\frac{s - s_0}{s_1 - s_0} \\cdot \\frac{s - s_2}{s_1 - s_2} = \\frac{s - 0}{d_1 - 0} \\cdot \\frac{s - d_2}{d_1 - d_2} = \\frac{s(s-d_2)}{d_1(d_1 - d_2)} $$\n\n对于 $j=2$：\n$$ L_2(s) = \\frac{s - s_0}{s_2 - s_0} \\cdot \\frac{s - s_1}{s_2 - s_1} = \\frac{s - 0}{d_2 - 0} \\cdot \\frac{s - d_1}{d_2 - d_1} = \\frac{s(s-d_1)}{d_2(d_2 - d_1)} $$\n\n因此，温度 $T(s)$ 的插值多项式为：\n$$ P(s) = T_b \\frac{(s-d_1)(s-d_2)}{d_1 d_2} + T_1 \\frac{s(s-d_2)}{d_1(d_1 - d_2)} + T_2 \\frac{s(s-d_1)}{d_2(d_2 - d_1)} $$\n为了求得虚拟单元温度 $T_g$，我们将该多项式在 $s = -d_g$ 处求值：\n$$ T_g = P(-d_g) = T_b \\frac{(-d_g-d_1)(-d_g-d_2)}{d_1 d_2} + T_1 \\frac{(-d_g)(-d_g-d_2)}{d_1(d_1 - d_2)} + T_2 \\frac{(-d_g)(-d_g-d_1)}{d_2(d_2 - d_1)} $$\n简化各项：\n$T_b$ 的系数变为：\n$$ \\frac{(-1)(d_g+d_1)(-1)(d_g+d_2)}{d_1 d_2} = \\frac{(d_g+d_1)(d_g+d_2)}{d_1 d_2} $$\n$T_1$ 的系数变为：\n$$ \\frac{(-d_g)(-1)(d_g+d_2)}{d_1(d_1 - d_2)} = \\frac{d_g(d_g+d_2)}{d_1(d_1 - d_2)} $$\n$T_2$ 的系数变为：\n$$ \\frac{(-d_g)(-1)(d_g+d_1)}{d_2(d_2 - d_1)} = \\frac{d_g(d_g+d_1)}{d_2(d_2 - d_1)} $$\n将这些结果合并，得到虚拟单元温度 $T_g$ 的最终表达式。该表达式使用二次插值，这与在存在任意形状边界时热方程的二阶精确数值格式的要求是一致的。\n\n$T_g$ 的最终表达式是边界温度 $T_b$ 和两个相邻流体温度 $T_1$ 和 $T_2$ 的加权和，其中权重是距离 $d_g$、$d_1$ 和 $d_2$ 的函数。\n$$ T_g = T_b \\frac{(d_g+d_1)(d_g+d_2)}{d_1 d_2} + T_1 \\frac{d_g(d_g+d_2)}{d_1(d_1 - d_2)} + T_2 \\frac{d_g(d_g+d_1)}{d_2(d_2 - d_1)} $$\n这就是所要求的封闭形式解析表达式。由于 $d_2 > d_1$，可以通过从 $T_1$ 项的分母中提出因子 $-1$ 来使其形式更对称：\n$$ T_g = T_b \\frac{(d_g+d_1)(d_g+d_2)}{d_1 d_2} - T_1 \\frac{d_g(d_g+d_2)}{d_1(d_2 - d_1)} + T_2 \\frac{d_g(d_g+d_1)}{d_2(d_2 - d_1)} $$\n然而，第一种形式是根据拉格朗日多项式的标准定义直接得出的结果，同样是正确的。",
            "answer": "$$ \\boxed{ T_g = T_b \\frac{(d_g+d_1)(d_g+d_2)}{d_1 d_2} + T_1 \\frac{d_g(d_g+d_2)}{d_1(d_1-d_2)} + T_2 \\frac{d_g(d_g+d_1)}{d_2(d_2-d_1)} } $$"
        },
        {
            "introduction": "理论推导出的数值格式必须经过严格的验证，以确认其实际实现能达到设计的收敛精度，这是科学计算的基本原则。本实践将采用“人造解法”（Method of Manufactured Solutions, MMS）这一标准的验证技术。您需要编程实现线性和二次精度的虚拟单元法，并定量地测量它们的收敛阶 。这项练习将为您提供代码验证的实战经验，教您如何系统地测试数值方法，从而建立对模拟工具可靠性的信心。",
            "id": "3961938",
            "problem": "考虑一个用于稳态热传导中沉浸边界法 (IBM) 鬼点强制的一维验证问题。其基本依据是傅里叶定律和稳态热传导，这两者共同推出了拉普拉斯方程，即温度场的二阶空间导数与源项相平衡。在一维局部界面法向坐标下，这简化为温度的二阶导数。我们关注于对狄利克雷边界条件使用鬼点强制，在与界面相邻的流体节点上对二阶导数进行离散近似。\n\n一个光滑的制造温度场被指定为法向坐标 $s$ 的函数：\n$$\nT(s) = e^{s} + 0.3 \\sin(3 s),\n$$\n其精确的二阶导数为\n$$\nT''(s) = e^{s} - 2.7 \\sin(3 s).\n$$\n在 $s = 0$ 处存在一个沉浸界面，其狄利克雷边界条件 $T(0)$ 由制造解给出。沿 $s$ 定义了一个间距为 $\\Delta n$ 的均匀网格，与界面相邻的流体节点位于 $s = d$ 处，其中 $d = \\alpha \\Delta n$ 且 $\\alpha \\in (0,1)$ 是从界面到流体节点沿网格间距的小数距离。鬼点位于固体内部，坐标为 $s = d - \\Delta n < 0$。离界面更远的下一个流体节点位于 $s = d + \\Delta n > 0$。\n\n将要检验两种鬼点强制策略：\n\n- 线性鬼点强制：通过在鬼点和流体节点之间的线段上进行线性外插来确定鬼点值，使得在界面 $s = 0$ 处的插值等于狄利克雷边界值。此方法仅使用界面值和相邻流体值，并以与这两个节点之间的线性剖面相一致的方式强制执行边界条件。\n\n- 二次鬼点强制：通过拟合一个穿过法线上三个点的二次多项式来确定鬼点值：位于 $s = -d$ 的镜像点 $I$，位于 $s = 0$ 的边界点 $B$，以及位于 $s = d$ 的流体点 $P$。然后，在鬼点位置 $s = d - \\Delta n$ 处评估该二次拟合，以与跨边界的二阶剖面相一致的方式重构鬼点值。\n\n对于每种强制策略，位于 $s=d$ 的界面相邻流体节点上二阶导数的离散近似由中心差分公式定义，该公式使用位于 $s = d - \\Delta n$ 的鬼点值和位于 $s = d + \\Delta n$ 的流体节点值：\n$$\nD_2 = \\frac{ T(d - \\Delta n)_{\\text{ghost}} - 2 T(d) + T(d + \\Delta n) }{ \\Delta n^2 }.\n$$\n在同一位置的精确二阶导数为 $T''(d)$，绝对误差为\n$$\nE(\\Delta n; \\alpha) = \\left| D_2 - T''(d) \\right|.\n$$\n\n您的任务是严格按照上述定义实现两种鬼点强制策略，为一系列对应于网格尺寸 $N \\in \\{32,64,128,256,512,1024\\}$ 的网格间距 $\\Delta n$（因此 $\\Delta n = 1/N$）计算误差 $E(\\Delta n; \\alpha)$，并通过对 $\\log(E)$ 与 $\\log(\\Delta n)$ 的关系进行最小二乘法线性拟合并取其斜率，来估计每种强制策略的观测精度阶 $p$。线性策略的期望精度阶为 $p = 1$，二次策略的期望精度阶为 $p = 2$。\n\n设计一个测试套件，覆盖一系列界面位置，包括类边缘情况：\n\n- 对于使用线性鬼点强制的 $\\alpha \\in \\{0.05, 0.1, 0.5, 0.9, 0.95\\}$。\n- 对于使用二次鬼点强制的 $\\alpha \\in \\{0.05, 0.1, 0.5, 0.9, 0.95\\}$。\n\n对于每个测试用例，计算观测阶数 $p$，并返回一个布尔值，指示观测阶数是否在期望阶数（线性为 $p = 1$，二次为 $p = 2$）的 $\\pm 0.2$ 容差范围内。最终输出为不带物理单位的布尔值。\n\n您的程序应生成单行输出，其中包含按上述测试套件顺序列出的结果，格式为方括号括起来的逗号分隔列表（例如，“[result1,result2,...]”），即：\n$$\n[\\text{linear } \\alpha = 0.05, \\text{linear } \\alpha = 0.1, \\text{linear } \\alpha = 0.5, \\text{linear } \\alpha = 0.9, \\text{linear } \\alpha = 0.95, \\text{quadratic } \\alpha = 0.05, \\text{quadratic } \\alpha = 0.1, \\text{quadratic } \\alpha = 0.5, \\text{quadratic } \\alpha = 0.9, \\text{quadratic } \\alpha = 0.95].\n$$",
            "solution": "该问题是有效的。这是一个在计算热工学领域内表述清晰、有科学依据的验证练习，没有任何指定的缺陷。任务是实现并分析应用于一维稳态热传导问题的沉浸边界法中的两种不同鬼点强制策略。\n\n此分析的基础是一个制造的温度场解，由下式给出：\n$$\nT(s) = e^{s} + 0.3 \\sin(3 s).\n$$\n相应的精确二阶导数（在稳态热传导方程中，它代表了源项，最多相差一个常数因子）为：\n$$\nT''(s) = e^{s} - 2.7 \\sin(3 s).\n$$\n一个带有狄利克雷条件 $T(0)$ 的沉浸边界位于 $s=0$ 处。计算网格是均匀的，间距为 $\\Delta n$。与界面相邻的流体节点位于 $s=d$ 处，其中 $d = \\alpha \\Delta n$，$\\alpha \\in (0,1)$。此节点上温度的二阶导数 $T''(d)$ 使用三点中心差分模板进行近似：\n$$\nD_2 = \\frac{ T_{ghost}(d - \\Delta n) - 2 T(d) + T(d + \\Delta n) }{ \\Delta n^2 }.\n$$\n这里，$T(d)$ 和 $T(d + \\Delta n)$ 是流体节点上的精确温度，$T_{ghost}(d - \\Delta n)$ 是鬼点 $(s = d - \\Delta n)$ 处的温度，其值必须被重构以强制执行边界条件。目标是通过分析绝对误差 $E(\\Delta n; \\alpha) = | D_2 - T''(d) |$ 作为 $\\Delta n$ 的函数，来确定两种重构方案的精度阶 $p$。\n\n### 线性鬼点强制\n\n该策略通过假设在鬼点 $s = d - \\Delta n$ 和相邻流体节点 $s = d$ 之间存在线性温度剖面来确定鬼点值。这条直线通过点 $(d - \\Delta n, T_{ghost})$ 和 $(d, T(d))$，并通过外插法在 $s=0$ 处满足边界条件，即穿过点 $(0, T(0))$。该直线的方程为：\n$$ \\frac{T_{interp}(s) - T(d)}{s - d} = \\frac{T_{ghost} - T(d)}{(d - \\Delta n) - d} = \\frac{T(d) - T_{ghost}}{\\Delta n} $$\n在 $s=0$ 处设置 $T_{interp}(0) = T(0)$，我们得到：\n$$ \\frac{T(0) - T(d)}{0 - d} = \\frac{T(d) - T_{ghost}}{\\Delta n} $$\n利用 $d = \\alpha \\Delta n$，该方程变为：\n$$ \\frac{T(d) - T(0)}{\\alpha \\Delta n} = \\frac{T(d) - T_{ghost}}{\\Delta n} $$\n求解鬼点温度 $T_{ghost}$：\n$$ T_{ghost} = T(d) - \\frac{T(d) - T(0)}{\\alpha} = \\frac{\\alpha T(d) - T(d) + T(0)}{\\alpha} = \\frac{T(0) - (1-\\alpha)T(d)}{\\alpha} $$\n此方法使用一阶精度的外插法来强制执行边界条件，因此所得的二阶导数近似预计为一阶精度，即 $p=1$。\n\n### 二次鬼点强制\n\n这种更高阶的策略通过将二次多项式 $P(s) = as^2 + bs + c$ 拟合到三个特定点来重构鬼点值。选择这些点是为了提供跨边界温度场的二阶精度表示：\n1.  与界面相邻的流体点：$P(d, T(d))$。\n2.  边界点本身：$B(0, T(0))$。\n3.  一个相对于边界与流体点对称的“镜像”点：$I(-d, T(-d))$。\n\n多项式的系数通过求解以下方程组来确定：\n$$\n\\begin{align*} T(d) = ad^2 + bd + c \\\\ T(0) = c \\\\ T(-d) = ad^2 - bd + c \\end{align*}\n$$\n从第二个方程，我们立即得到 $c = T(0)$。将第一个和第三个方程相加得到 $T(d) + T(-d) = 2ad^2 + 2c$，从而得出系数 $a$：\n$$\na = \\frac{T(d) + T(-d) - 2T(0)}{2d^2}.\n$$\n从第一个方程中减去第三个方程得到 $T(d) - T(-d) = 2bd$，从而得出系数 $b$：\n$$\nb = \\frac{T(d) - T(-d)}{2d}.\n$$\n然后，通过在该鬼点的位置 $s_{ghost} = d - \\Delta n$ 处评估此多项式，可以找到鬼点温度 $T_{ghost}$：\n$$\nT_{ghost} = P(d - \\Delta n) = a(d - \\Delta n)^2 + b(d - \\Delta n) + c.\n$$\n由于此重构使用二次多项式，因此所得的二阶导数近似预计为二阶精度，即 $p=2$。\n\n### 精度阶验证\n\n对于每种策略和每个指定的 $\\alpha$ 值，精度阶 $p$ 通过数值收敛性研究确定。绝对误差 $E$ 是为一系列逐渐细化的网格间距 $\\Delta n = 1/N$ 计算的，其中 $N \\in \\{32, 64, 128, 256, 512, 1024\\}$。误差与网格间距之间的理论关系是 $E \\approx C (\\Delta n)^p$，其中 $C$ 是一个常数。取对数后得到线性关系：\n$$\n\\log(E) \\approx \\log(C) + p \\log(\\Delta n).\n$$\n观测精度阶 $p$ 是通过使用线性最小二乘回归对数据点 $(\\log(\\Delta n), \\log(E))$ 进行最佳拟合线的斜率来计算的。如果计算出的阶数 $p$ 在理论期望阶数（线性为 $1$，二次为 $2$）的 $\\pm 0.2$ 容差范围内，则每个测试用例的验证成功。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and verifies linear and quadratic ghost-cell enforcement\n    strategies for an immersed boundary method in 1D heat conduction.\n    \"\"\"\n\n    # Define the manufactured solution and its exact second derivative\n    def T(s: float) -> float:\n        \"\"\"Manufactured temperature field T(s).\"\"\"\n        return np.exp(s) + 0.3 * np.sin(3 * s)\n\n    def T_double_prime(s: float) -> float:\n        \"\"\"Exact second derivative T''(s).\"\"\"\n        return np.exp(s) - 2.7 * np.sin(3 * s)\n\n    # Test suite parameters as specified in the problem statement\n    test_cases = [\n        # (alpha, enforcement_type, expected_order)\n        (0.05, 'linear', 1.0),\n        (0.1,  'linear', 1.0),\n        (0.5,  'linear', 1.0),\n        (0.9,  'linear', 1.0),\n        (0.95, 'linear', 1.0),\n        (0.05, 'quadratic', 2.0),\n        (0.1,  'quadratic', 2.0),\n        (0.5,  'quadratic', 2.0),\n        (0.9,  'quadratic', 2.0),\n        (0.95, 'quadratic', 2.0),\n    ]\n\n    # Grid sizes for the convergence study\n    Ns = np.array([32, 64, 128, 256, 512, 1024])\n    delta_ns = 1.0 / Ns\n\n    results = []\n    tolerance = 0.2\n\n    for alpha, enforcement_type, p_expected in test_cases:\n        log_delta_ns = np.log(delta_ns)\n        log_errors = []\n\n        for dn in delta_ns:\n            # Distance from interface to adjacent fluid node\n            d = alpha * dn\n            \n            # Key spatial locations\n            s_adj = d             # Interface-adjacent fluid node\n            s_next = d + dn       # Next fluid node\n            s_bdy = 0.0           # Boundary location\n            s_ghost = d - dn      # Ghost node location\n\n            # Exact temperatures at required locations\n            T_adj = T(s_adj)\n            T_next = T(s_next)\n            T_bdy = T(s_bdy)\n\n            T_ghost = 0.0\n            if enforcement_type == 'linear':\n                # Linear enforcement using extrapolation\n                # T_ghost = T(d) - (T(d) - T(0))/alpha\n                # Rearranged: T_ghost = (T(0) - (1-alpha)*T(d))/alpha\n                if abs(alpha) > 1e-14:\n                    T_ghost = (T_bdy - (1.0 - alpha) * T_adj) / alpha\n                else: # Should not happen\n                    T_ghost = 0\n            \n            elif enforcement_type == 'quadratic':\n                # Quadratic enforcement: Fit P(s) = as^2 + bs + c through\n                # points at s = -d, 0, d.\n                s_img = -d\n                T_img = T(s_img)\n                \n                # Coefficients of the quadratic polynomial P(s)\n                c_quad = T_bdy\n                if abs(d) > 1e-14: # Avoid division by zero\n                    a_quad = (T_adj + T_img - 2.0 * T_bdy) / (2.0 * d**2)\n                    b_quad = (T_adj - T_img) / (2.0 * d)\n                else: # Should not happen with given test cases\n                    # Fallback to Taylor series for a and b if d is tiny\n                    a_quad = 0.5 * T_double_prime(0.0) # T''(0)/2!\n                    b_quad = (np.exp(0.0) + 0.3 * 3.0 * np.cos(0.0)) # T'(0)\n                \n                # Evaluate the polynomial at the ghost node location\n                T_ghost = a_quad * s_ghost**2 + b_quad * s_ghost + c_quad\n            \n            # Approximate the second derivative using the central difference formula\n            D2 = (T_ghost - 2.0 * T_adj + T_next) / (dn**2)\n\n            # Exact second derivative at the adjacent node\n            T_pp_adj = T_double_prime(s_adj)\n\n            # Compute the absolute error\n            error = np.abs(D2 - T_pp_adj)\n            log_errors.append(np.log(error))\n\n        # Perform linear regression on log-log data to find the observed order\n        log_errors = np.array(log_errors)\n        p_observed, _ = np.polyfit(log_delta_ns, log_errors, 1)\n\n        # Verify if the observed order is within the specified tolerance\n        is_valid = np.abs(p_observed - p_expected) <= tolerance\n        results.append(is_valid)\n\n    # Format the boolean results into the required string format\n    result_str = [str(res).lower() for res in results]\n    print(f\"[{','.join(result_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从单个单元的理论构建转向完整的模拟，往往会暴露出各种实际工程挑战。在切割单元（cut-cell）类浸入边界法中，一个典型难题是“小单元问题”（small cell problem），即被界面切割后体积过小的单元会导致显式时间步长变得极小，从而引发严重的数值不稳定性。本练习将探讨两种主流的稳定性策略：通量重构和单元合并 。通过实现并测试这些策略，您将学会如何诊断和解决IBM代码中的关键稳定性问题，这对于开发能处理真实复杂几何的稳健求解器至关重要。",
            "id": "3961816",
            "problem": "考虑一个嵌入在较大笛卡尔网格内的流体子域中的一维瞬态热传导问题，使用浸入边界法 (IBM) 进行处理。流体中的控制能量方程是热扩散方程，由能量守恒和傅里叶定律推导得出： $$\\frac{\\partial T}{\\partial t} = \\kappa \\frac{\\partial^2 T}{\\partial x^2},$$ 其中 $T$ 是温度，$\\kappa = \\frac{k}{\\rho c}$ 是热扩散率，$k$ 是热导率，$\\rho$ 是密度，$c$ 是比热。设横截面积为 $A = 1\\,\\mathrm{m}^2$，因此体积热容为 $C_v = \\rho c$，单位为 $\\mathrm{J}/(\\mathrm{m}^3\\cdot\\mathrm{K})$，对于长度为 $l$ 的控制体积，其能量 $U$（单位为 $\\mathrm{J}$）为 $U = C_v \\, l \\, T$。\n\n在长度为 $L = 1\\,\\mathrm{m}$ 的区间上使用有限体积离散化，该区间被划分为 $N$ 个均匀基础尺寸为 $\\Delta x = L/N$ 的名义单元。一个浸入边界切割第一个单元，使其流体长度为 $l_0 = \\alpha \\Delta x$，其中 $0 < \\alpha \\le 1$，而其余单元的流体长度为 $l_i = \\Delta x$（对于 $i \\ge 1$）。位于 $x=0$ 的左边界和位于 $x=L$ 的右边界均为热绝缘，施加零热通量。单元 $i$ 和单元 $i+1$ 之间的离散内界面位于单元中心的中间，从而产生有效的中心间距 $$d_{i+\\frac{1}{2}} = \\frac{1}{2}\\left(l_i + l_{i+1}\\right)。$$ 穿过内界面 $i+\\frac{1}{2}$ 的离散扩散热通量由下式给出 $$F_{i+\\frac{1}{2}} = -k A \\frac{T_{i+1} - T_i}{d_{i+\\frac{1}{2}}},$$ 单元 $i$ 的半离散守恒更新为 $$\\frac{\\mathrm{d}}{\\mathrm{d}t}\\left(C_v \\, l_i \\, T_i\\right) = F_{i-\\frac{1}{2}} - F_{i+\\frac{1}{2}},$$ 由于是绝缘边界，$F_{-\\frac{1}{2}} = 0$ 且 $F_{N-\\frac{1}{2}} = 0$。\n\n具有 $l_0 \\ll \\Delta x$ 的小切割单元会使显式时间步进不稳定。在浸入边界处理中，两种常用的稳定化策略是：修改邻近小切割单元的面通量（通量重分布或裁剪），以及将小切割单元与相邻的较大单元合并（单元合并），同时保持全局守恒。您的任务是实现这两种策略，并评估它们对全局能量守恒的影响。\n\n从能量守恒和傅里叶定律出发，并使用上述有限体积框架：\n- 根据面通量和单元体积，推导 $T_i$ 的一致性显式欧拉更新。\n- 实现策略 A（通量重分布/裁剪）：根据扩散的局部显式稳定性要求，通过一个稳定化因子修改邻近小切割单元的界面通量，该因子对称地应用于受影响面的两侧，以保持逐面守恒。\n- 实现策略 B（单元合并）：将前两个单元视为一个合并簇，总长度为 $l_0 + l_1$；抑制它们之间的内部通量；仅使用其外表面来驱动该簇的能量变化；并将该簇的能量变化按体积比例分配给组成单元，以维持全局守恒。\n- 使用绝缘边界条件，因此流体子域中的理论精确总能量随时间保持恒定。\n\n使用以下物理参数：$k = 1\\,\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$，$C_v = 1000\\,\\mathrm{J}/(\\mathrm{m}^3\\cdot\\mathrm{K})$，$A = 1\\,\\mathrm{m}^2$。使用初始温度场 $$T(x) = \\sin(2\\pi x),$$ 在给定非均匀网格的单元中心进行采样。使用时间步长 $\\Delta t = 0.01\\,\\mathrm{s}$ 的显式欧拉法进行时间推进，共 $n = 100$ 步。对于每次模拟，计算运行结束时以焦耳为单位的全局绝对能量误差，定义为 $$E_\\mathrm{err} = \\left| \\sum_{i=0}^{N-1} C_v l_i T_i^{(n)} - \\sum_{i=0}^{N-1} C_v l_i T_i^{(0)} \\right|。$$\n\n测试套件：\n- 测试 1（理想路径，无切割）：$N = 50$，$\\alpha = 1$，策略 = 无。由于绝缘边界和守恒性，预期能量误差接近于零。\n- 测试 2（中等切割，通量重分布）：$N = 50$，$\\alpha = 0.05$，策略 = 通量重分布/裁剪。计算 $E_\\mathrm{err}$。\n- 测试 3（严重切割，单元合并）：$N = 50$，$\\alpha = 0.01$，策略 = 单元合并。计算 $E_\\mathrm{err}$。\n- 测试 4（极端切割，通量重分布）：$N = 50，$\\alpha = 0.001$，策略 = 通量重分布/裁剪。计算 $E_\\mathrm{err}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3,result4]”）。每个结果必须是一个浮点数，给出相应测试用例的绝对能量误差 $E_\\mathrm{err}$（单位为焦耳），使用上述参数值和所述策略。角度（如有）必须以弧度为单位。所有能量均以焦耳表示。此问题不需要百分比。",
            "solution": "该问题陈述已经过严格验证，并被认为是有效的。它提出了一个计算热工学领域的适定问题，没有科学或逻辑上的矛盾，尽管在关于总域长度方面存在一个在浸入边界文献中常见的轻微模糊之处，但这并不妨碍问题的可解性或核心目标。任务是实现并评估应用于瞬态热扩散问题的浸入边界法 (IBM) 的两种常用稳定化策略，重点关注它们对全局能量守恒的影响。所有提供的数据和条件对于推导解决方案都是充分且一致的。\n\n一维热扩散的控制偏微分方程是：\n$$ \\frac{\\partial T}{\\partial t} = \\kappa \\frac{\\partial^2 T}{\\partial x^2} $$\n其中 $\\kappa = k / (\\rho c)$ 是热扩散率。该问题采用有限体积法进行公式化。对于长度为 $l_i$ 的控制体积（单元）$i$，能量守恒定律的半离散形式如下：\n$$ \\frac{\\mathrm{d}}{\\mathrm{d}t}\\left(C_v \\, l_i \\, T_i\\right) = F_{i-\\frac{1}{2}} - F_{i+\\frac{1}{2}} $$\n其中 $C_v = \\rho c$ 是体积热容，$T_i$ 是单元 $i$ 中的平均温度，$F_{i\\pm\\frac{1}{2}}$ 是穿过单元面的热通量。由于 $C_v$ 和 $l_i$ 随时间恒定，我们可以写成：\n$$ C_v l_i \\frac{\\mathrm{d}T_i}{\\mathrm{d}t} = F_{i-\\frac{1}{2}} - F_{i+\\frac{1}{2}} $$\n应用显式欧拉时间积分方案，其中时间导数近似为 $\\frac{\\mathrm{d}T_i}{\\mathrm{d}t} \\approx \\frac{T_i^{n+1} - T_i^n}{\\Delta t}$，我们推导出新时间步 $n+1$ 时温度 $T_i$ 的更新规则：\n$$ \\frac{T_i^{n+1} - T_i^n}{\\Delta t} = \\frac{1}{C_v l_i} \\left( F_{i-\\frac{1}{2}}^n - F_{i+\\frac{1}{2}}^n \\right) $$\n$$ T_i^{n+1} = T_i^n + \\frac{\\Delta t}{C_v l_i} \\left( F_{i-\\frac{1}{2}}^n - F_{i+\\frac{1}{2}}^n \\right) $$\n在面 $i+\\frac{1}{2}$ 处的热通量 $F_{i+\\frac{1}{2}}^n$ 是基于傅里叶定律，使用时间层 $n$ 的温度计算的：\n$$ F_{i+\\frac{1}{2}}^n = -k A \\frac{T_{i+1}^n - T_i^n}{d_{i+\\frac{1}{2}}} $$\n其中 $d_{i+\\frac{1}{2}} = \\frac{1}{2}(l_i + l_{i+1})$ 是单元 $i$ 和单元 $i+1$ 中心之间的距离。绝缘边界条件意味着在域的末端通量为零：$F_{-\\frac{1}{2}} = 0$ 且 $F_{N-\\frac{1}{2}} = 0$。\n\n该数值格式的一个关键特征是其对全局能量守恒的遵守。域中总能量 $E_\\mathrm{total} = \\sum_{i=0}^{N-1} C_v l_i T_i$ 的变化率为：\n$$ \\frac{\\mathrm{d}E_\\mathrm{total}}{\\mathrm{d}t} = \\sum_{i=0}^{N-1} C_v l_i \\frac{\\mathrm{d}T_i}{\\mathrm{d}t} = \\sum_{i=0}^{N-1} \\left( F_{i-\\frac{1}{2}} - F_{i+\\frac{1}{2}} \\right) $$\n这形成了一个伸缩求和：$(F_{-\\frac{1}{2}} - F_{\\frac{1}{2}}) + (F_{\\frac{1}{2}} - F_{\\frac{3}{2}}) + \\dots + (F_{N-\\frac{3}{2}} - F_{N-\\frac{1}{2}}) = F_{-\\frac{1}{2}} - F_{N-\\frac{1}{2}}$。考虑到绝缘边界，此和为 $0 - 0 = 0$。因此，总能量理论上应保持不变。\n\n稳定化策略是显式格式的稳定性约束所必需的，对于小切割单元（单元 $0$）而言，该约束尤其严格。\n\n**策略 A：通量重分布/裁剪**\n显式欧拉格式的稳定性要求时间步长 $\\Delta t$ 满足每个单元的局部 Courant-Friedrichs-Lewy (CFL) 条件。对于邻近绝缘边界的小切割单元 $0$，更新规则 $T_0^{n+1} = T_0^n - \\frac{\\Delta t}{C_v l_0} F_{0+\\frac{1}{2}}^n$ 导出一个稳定性极限。代入通量表达式可得：\n$$ T_0^{n+1} = T_0^n \\left( 1 - \\frac{\\Delta t \\cdot k A}{C_v l_0 d_{0+\\frac{1}{2}}} \\right) + \\dots $$\n为了保持稳定，$T_0^n$ 的系数必须为非负，这要求 $\\Delta t \\le \\frac{C_v l_0 d_{0+\\frac{1}{2}}}{k A}$。这个局部时间步长限制，我们称之为 $\\Delta t_{\\mathrm{loc},0}$，随着 $l_0 \\to 0$ 而变得非常小。\n为了使用一个固定的、较大的 $\\Delta t$，通量 $F_{0+\\frac{1}{2}}$ 通过一个稳定化因子 $s$ 进行缩放：\n$$ s = \\min\\left(1.0, \\frac{\\Delta t_{\\mathrm{loc},0}}{\\Delta t}\\right) = \\min\\left(1.0, \\frac{C_v l_0 d_{0+\\frac{1}{2}}}{k A \\Delta t}\\right) $$\n修改后的通量 $F'_{0+\\frac{1}{2}} = s \\cdot F_{0+\\frac{1}{2}}$ 用于单元 $0$ 和单元 $1$ 的更新方程中。这保持了逐面守恒（从单元 $0$ 流出的通量等于流入单元 $1$ 的通量），并因此保持了全局能量守恒，因为伸缩求和的性质保持不变。\n\n**策略 B：单元合并**\n此策略将小单元 $0$ 与其邻居单元 $1$ 合并成一个单一的计算簇。\n1. 它们之间的内部通量被设置为零：$F_{0+\\frac{1}{2}} = 0$。\n2. 合并簇的能量 $E_m = E_0 + E_1 = C_v l_0 T_0 + C_v l_1 T_1$，根据其外部通量进行更新，外部通量为 $F_{-\\frac{1}{2}} = 0$（在边界处）和 $F_{1+\\frac{1}{2}}$（在与单元 $2$ 的界面处）。簇能量的变化率为 $\\frac{\\mathrm{d}E_m}{\\mathrm{d}t} = F_{-\\frac{1}{2}} - F_{1+\\frac{1}{2}} = -F_{1+\\frac{1}{2}}$。\n3. 在一个时间步长内，簇的总能量变化 $\\Delta E_m = -\\Delta t \\cdot F_{1+\\frac{1}{2}}^n$，按其体积（或长度，因为面积是恒定的）比例分配给单元 $0$ 和 $1$：\n$$ \\Delta E_0 = \\Delta E_m \\frac{l_0}{l_0 + l_1}, \\quad \\Delta E_1 = \\Delta E_m \\frac{l_1}{l_0 + l_1} $$\n然后更新温度：\n$$ T_0^{n+1} = T_0^n + \\frac{\\Delta E_0}{C_v l_0} = T_0^n + \\frac{\\Delta E_m}{C_v (l_0 + l_1)} $$\n$$ T_1^{n+1} = T_1^n + \\frac{\\Delta E_1}{C_v l_1} = T_1^n + \\frac{\\Delta E_m}{C_v (l_0 + l_1)} $$\n这等效于对簇中的两个单元施加相同的温度增量。此方法也是内在守恒的。系统的总能量变化是所有单元（或簇）变化的总和，由于内部通量的抵消，该总和再次伸缩为零。\n\n两种策略都被设计为完全守恒的。因此，计算出的绝对能量误差 $E_\\mathrm{err}$ 应接近于零，仅受浮点算术精度的限制，这展示了这些方法在维持全局守恒的同时确保数值稳定性的有效性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D transient heat conduction problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        (50, 1.0, \"none\"),\n        (50, 0.05, \"flux_redistribution/clipping\"),\n        (50, 0.01, \"cell_merging\"),\n        (50, 0.001, \"flux_redistribution/clipping\"),\n    ]\n\n    results = []\n    for N, alpha, strategy in test_cases:\n        result = simulate_case(N, alpha, strategy)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef simulate_case(N, alpha, strategy):\n    \"\"\"\n    Runs a single simulation case and returns the absolute energy error.\n\n    Args:\n        N (int): Number of nominal cells.\n        alpha (float): Fraction of the first cell's length.\n        strategy (str): Stabilization strategy ('none', 'flux_redistribution/clipping', 'cell_merging').\n\n    Returns:\n        float: Absolute global energy error in joules.\n    \"\"\"\n    # Physical and numerical parameters\n    L = 1.0\n    k = 1.0\n    Cv = 1000.0\n    A = 1.0\n    dt = 0.01\n    n_steps = 100\n\n    # Grid setup\n    dx = L / N\n    l = np.full(N, dx, dtype=np.float64)\n    l[0] = alpha * dx\n\n    # Cell center positions\n    x_coords = np.zeros(N, dtype=np.float64)\n    x_coords[0] = l[0] / 2.0\n    cell_left_edge = l[0]\n    for i in range(1, N):\n        x_coords[i] = cell_left_edge + l[i] / 2.0\n        cell_left_edge += l[i]\n\n    # Distances between cell centers\n    d = np.zeros(N - 1, dtype=np.float64)\n    for i in range(N - 1):\n        d[i] = (l[i] + l[i + 1]) / 2.0\n\n    # Initial condition\n    T_current = np.sin(2 * np.pi * x_coords, dtype=np.float64)\n\n    # Calculate initial total energy\n    E_initial = np.sum(Cv * l * T_current)\n\n    # Time-stepping loop\n    for _ in range(n_steps):\n        T_new = np.copy(T_current)\n\n        # Calculate fluxes at all internal faces (F[i] corresponds to face i-1/2)\n        F = np.zeros(N + 1, dtype=np.float64)\n        for i in range(N - 1):\n            F[i + 1] = -k * A * (T_current[i + 1] - T_current[i]) / d[i]\n\n        # Apply stabilization strategy\n        if strategy == \"flux_redistribution/clipping\":\n            # stability limit for cell 0\n            if d[0] > 1e-12: # Avoid division by zero\n                dt_loc_0 = (Cv * l[0] * d[0]) / (k * A)\n                s = min(1.0, dt_loc_0 / dt)\n                F[1] *= s\n            else:\n                F[1] = 0.0\n            \n            # General update for all cells\n            # Cell 0 (left boundary, flux F[-1/2] = 0)\n            net_flux_rate_0 = -F[1]\n            if l[0] > 1e-12:\n                T_new[0] = T_current[0] + (dt / (Cv * l[0])) * net_flux_rate_0\n            # Internal cells\n            for i in range(1, N - 1):\n                net_flux_rate_i = F[i] - F[i + 1]\n                T_new[i] = T_current[i] + (dt / (Cv * l[i])) * net_flux_rate_i\n            # Cell N-1 (right boundary, flux F[N-1/2] = 0)\n            if N > 1:\n                net_flux_rate_N_1 = F[N - 1]\n                T_new[N-1] = T_current[N-1] + (dt / (Cv * l[N-1])) * net_flux_rate_N_1\n\n        elif strategy == \"cell_merging\":\n            # Suppress flux between cell 0 and 1\n            F[1] = 0.0\n            \n            # Energy change of the merged cluster (0, 1) due to external flux F[1+1/2]\n            flux_out_of_cluster = F[2] if N > 2 else 0.0\n            delta_E_m = -dt * flux_out_of_cluster\n            \n            # Distribute temp change to cells 0 and 1\n            l_m = l[0] + l[1]\n            if l_m > 1e-12:\n                delta_T_cluster = delta_E_m / (Cv * l_m)\n                T_new[0] = T_current[0] + delta_T_cluster\n                T_new[1] = T_current[1] + delta_T_cluster\n            \n            # Update other cells normally\n            for i in range(2, N - 1):\n                net_flux_rate_i = F[i] - F[i + 1]\n                T_new[i] = T_current[i] + (dt / (Cv * l[i])) * net_flux_rate_i\n            # Update cell N-1\n            if N > 2:\n                net_flux_rate_N_1 = F[N-1]\n                T_new[N-1] = T_current[N-1] + (dt / (Cv * l[N-1])) * net_flux_rate_N_1\n\n        else: # \"none\" strategy\n            # General update for all cells\n            # Cell 0 (left boundary, F[-1/2]=0)\n            net_flux_rate_0 = -F[1]\n            if l[0] > 1e-12:\n                T_new[0] = T_current[0] + (dt / (Cv * l[0])) * net_flux_rate_0\n            # Internal cells\n            for i in range(1, N - 1):\n                net_flux_rate_i = F[i] - F[i + 1]\n                T_new[i] = T_current[i] + (dt / (Cv * l[i])) * net_flux_rate_i\n            # Cell N-1 (right boundary, F[N-1/2]=0)\n            if N > 1:\n                net_flux_rate_N_1 = F[N-1]\n                T_new[N-1] = T_current[N-1] + (dt / (Cv * l[N-1])) * net_flux_rate_N_1\n            \n        T_current = T_new\n\n    # Final Energy\n    E_final = np.sum(Cv * l * T_current)\n    \n    # Absolute Energy Error\n    E_err = np.abs(E_final - E_initial)\n    \n    return E_err\n\nsolve()\n```"
        }
    ]
}