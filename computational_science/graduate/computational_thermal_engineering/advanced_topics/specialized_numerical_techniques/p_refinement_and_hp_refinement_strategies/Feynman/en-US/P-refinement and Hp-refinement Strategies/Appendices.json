{
    "hands_on_practices": [
        {
            "introduction": "To effectively implement advanced adaptive strategies, one must first master the fundamentals of the Finite Element Method (FEM). This practice returns to first principles, guiding you through the construction of the element stiffness matrix and load vector from the weak form of a simple 1D heat conduction problem. By progressing from a linear ($p=1$) to a quadratic ($p=2$) element, you will gain hands-on experience with the algebraic modifications that underpin $p$-refinement, solidifying your understanding of how higher-order approximations are built at the most basic level.",
            "id": "3977363",
            "problem": "Consider steady one-dimensional heat conduction governed by Fourier’s law and energy conservation. On the domain $[0,1]$, the strong form is $-\\frac{d}{dx}\\left(k \\frac{dT}{dx}\\right)=q$ with constant conductivity $k=1$ and volumetric heat generation $q=0$. The boundary conditions are homogeneous Dirichlet at the left end and nonhomogeneous Dirichlet at the right end: $T(0)=0$ and $T(1)=1$. Use the Galerkin Finite Element Method (Finite Element Method (FEM)) with the standard $H^{1}$-conforming trial and test spaces and one element spanning the entire domain.\n\nTasks:\n- Starting from the weak form, construct the element-level stiffness matrix and load vector for a single linear ($p=1$) element on $[0,1]$ using the canonical linear Lagrange shape functions.\n- Apply $p$-refinement to upgrade the same single element to a quadratic ($p=2$) element with Lagrange interpolation nodes located at $x=0$, $x=\\frac{1}{2}$, and $x=1$. Construct the corresponding element-level stiffness matrix and load vector.\n- Assemble the global system for the quadratic case. Then impose the essential (Dirichlet) boundary conditions $T(0)=0$ and $T(1)=1$. Reduce the system to the single interior Degree of Freedom (DOF) associated with the node at $x=\\frac{1}{2}$, and solve explicitly for that nodal temperature.\n\nExpress the final value of the interior nodal temperature as a nondimensional number. No rounding is required; report the exact value.",
            "solution": "The problem statement is a well-posed boundary value problem in one-dimensional steady-state heat conduction, suitable for analysis by the Finite Element Method. It is scientifically grounded, self-contained, and all data required for the solution are provided. The problem is therefore valid.\n\nThe governing strong form of the heat conduction equation is given by:\n$$ -\\frac{d}{dx}\\left(k \\frac{dT}{dx}\\right) = q(x) \\quad \\text{for } x \\in (0,1) $$\nwith conductivity $k=1$, volumetric heat generation $q=0$, and Dirichlet boundary conditions $T(0)=0$ and $T(1)=1$.\n\nFirst, we derive the weak form. Let $v(x)$ be a weighting function in a suitable function space. Multiplying the strong form by $v(x)$ and integrating over the domain $\\Omega = [0,1]$ yields:\n$$ -\\int_{0}^{1} v \\frac{d}{dx}\\left(k \\frac{dT}{dx}\\right) dx = \\int_{0}^{1} v q dx $$\nApplying integration by parts to the left-hand side:\n$$ \\int_{0}^{1} k \\frac{dv}{dx} \\frac{dT}{dx} dx - \\left[v k \\frac{dT}{dx}\\right]_{0}^{1} = \\int_{0}^{1} v q dx $$\nThe Galerkin method approximates the temperature field $T(x)$ as a linear combination of basis functions $N_j(x)$, $T(x) \\approx T^h(x) = \\sum_{j=1}^{n} T_j N_j(x)$, where $T_j$ are the nodal temperature values. The weighting functions $v(x)$ are chosen from the same set of basis functions, i.e., $v(x) = N_i(x)$. This leads to a system of algebraic equations $[K]\\{T\\} = \\{F\\}$, where the stiffness matrix $[K]$ and force vector $\\{F\\}$ are defined as:\n$$ K_{ij} = \\int_{0}^{1} k \\frac{dN_i}{dx} \\frac{dN_j}{dx} dx $$\n$$ F_i = \\int_{0}^{1} N_i q dx + \\left[N_i k \\frac{dT}{dx}\\right]_{0}^{1} $$\nGiven $k=1$ and $q=0$, the element stiffness matrix is $K_{ij}^{(e)} = \\int_{\\Omega_e} \\frac{dN_i}{dx} \\frac{dN_j}{dx} dx$ and the element load vector from heat generation is $\\{F^{(e)}\\} = \\{0\\}$.\n\n**Task 1: Linear Element ($p=1$) on $[0,1]$**\nFor a single linear element spanning the domain $[0,1]$, the nodes are at $x_1=0$ and $x_2=1$. The canonical linear Lagrange shape functions are:\n$N_1(x) = 1-x$\n$N_2(x) = x$\nThe derivatives of the shape functions are:\n$\\frac{dN_1}{dx} = -1$\n$\\frac{dN_2}{dx} = 1$\nThe components of the $2 \\times 2$ element stiffness matrix $K^{(e)}$ are calculated as:\n$K_{11}^{(e)} = \\int_{0}^{1} (1) (\\frac{dN_1}{dx})(\\frac{dN_1}{dx}) dx = \\int_{0}^{1} (-1)(-1) dx = 1$\n$K_{12}^{(e)} = \\int_{0}^{1} (1) (\\frac{dN_1}{dx})(\\frac{dN_2}{dx}) dx = \\int_{0}^{1} (-1)(1) dx = -1$\n$K_{21}^{(e)} = K_{12}^{(e)} = -1$\n$K_{22}^{(e)} = \\int_{0}^{1} (1) (\\frac{dN_2}{dx})(\\frac{dN_2}{dx}) dx = \\int_{0}^{1} (1)(1) dx = 1$\nThe element stiffness matrix for the $p=1$ element is:\n$$ [K^{(e)}] = \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix} $$\nThe element load vector due to the source term is:\n$$ \\{F^{(e)}\\} = \\begin{pmatrix} \\int_{0}^{1} N_1(x) (0) dx \\\\ \\int_{0}^{1} N_2(x) (0) dx \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix} $$\n\n**Task 2: Quadratic Element ($p=2$) on $[0,1]$**\nFor a single quadratic element spanning $[0,1]$, the nodes are located at $x_1=0$, $x_2=\\frac{1}{2}$, and $x_3=1$. The quadratic Lagrange shape functions are:\n$N_1(x) = \\frac{(x-x_2)(x-x_3)}{(x_1-x_2)(x_1-x_3)} = \\frac{(x-1/2)(x-1)}{(0-1/2)(0-1)} = 2(x^2 - \\frac{3}{2}x + \\frac{1}{2}) = 2x^2 - 3x + 1$\n$N_2(x) = \\frac{(x-x_1)(x-x_3)}{(x_2-x_1)(x_2-x_3)} = \\frac{(x-0)(x-1)}{(1/2-0)(1/2-1)} = -4(x^2-x) = -4x^2 + 4x$\n$N_3(x) = \\frac{(x-x_1)(x-x_2)}{(x_3-x_1)(x_3-x_2)} = \\frac{(x-0)(x-1/2)}{(1-0)(1-1/2)} = 2(x^2 - \\frac{1}{2}x) = 2x^2 - x$\nThe derivatives are:\n$\\frac{dN_1}{dx} = 4x - 3$\n$\\frac{dN_2}{dx} = -8x + 4$\n$\\frac{dN_3}{dx} = 4x - 1$\nThe components of the $3 \\times 3$ element stiffness matrix $K^{(e)}$ are calculated:\n$K_{11}^{(e)} = \\int_0^1 (4x-3)^2 dx = \\int_0^1 (16x^2-24x+9)dx = [\\frac{16}{3}x^3-12x^2+9x]_0^1 = \\frac{16}{3}-12+9 = \\frac{7}{3}$\n$K_{12}^{(e)} = \\int_0^1 (4x-3)(-8x+4)dx = \\int_0^1 (-32x^2+40x-12)dx = [-\\frac{32}{3}x^3+20x^2-12x]_0^1 = -\\frac{32}{3}+20-12 = -\\frac{8}{3}$\n$K_{13}^{(e)} = \\int_0^1 (4x-3)(4x-1)dx = \\int_0^1 (16x^2-16x+3)dx = [\\frac{16}{3}x^3-8x^2+3x]_0^1 = \\frac{16}{3}-8+3 = \\frac{1}{3}$\n$K_{22}^{(e)} = \\int_0^1 (-8x+4)^2dx = \\int_0^1 (64x^2-64x+16)dx = [\\frac{64}{3}x^3-32x^2+16x]_0^1 = \\frac{64}{3}-32+16 = \\frac{16}{3}$\n$K_{23}^{(e)} = \\int_0^1 (-8x+4)(4x-1)dx = \\int_0^1 (-32x^2+24x-4)dx = [-\\frac{32}{3}x^3+12x^2-4x]_0^1 = -\\frac{32}{3}+12-4 = -\\frac{8}{3}$\n$K_{33}^{(e)} = \\int_0^1 (4x-1)^2dx = \\int_0^1 (16x^2-8x+1)dx = [\\frac{16}{3}x^3-4x^2+x]_0^1 = \\frac{16}{3}-4+1 = \\frac{7}{3}$\nBy symmetry, $K_{21}^{(e)}=K_{12}^{(e)}$, $K_{31}^{(e)}=K_{13}^{(e)}$, and $K_{32}^{(e)}=K_{23}^{(e)}$.\nThe element stiffness matrix for the $p=2$ element is:\n$$ [K^{(e)}] = \\begin{pmatrix} 7/3 & -8/3 & 1/3 \\\\ -8/3 & 16/3 & -8/3 \\\\ 1/3 & -8/3 & 7/3 \\end{pmatrix} = \\frac{1}{3} \\begin{pmatrix} 7 & -8 & 1 \\\\ -8 & 16 & -8 \\\\ 1 & -8 & 7 \\end{pmatrix} $$\nThe element load vector is again $\\{F^{(e)}\\} = \\{0\\}$.\n\n**Task 3: System Assembly, Boundary Conditions, and Solution for Quadratic Case**\nSince there is only one element, the global system is identical to the element system: $[K]\\{T\\} = \\{F\\}$. The vector $\\{F\\}$ incorporates both the source term (which is zero) and the boundary reaction forces. The system of equations is:\n$$ \\frac{1}{3} \\begin{pmatrix} 7 & -8 & 1 \\\\ -8 & 16 & -8 \\\\ 1 & -8 & 7 \\end{pmatrix} \\begin{pmatrix} T_1 \\\\ T_2 \\\\ T_3 \\end{pmatrix} = \\begin{pmatrix} R_1 \\\\ 0 \\\\ R_3 \\end{pmatrix} $$\nwhere $T_1=T(0)$, $T_2=T(1/2)$, and $T_3=T(1)$. $R_1$ and $R_3$ are the unknown reaction forces at the Dirichlet boundaries.\nThe essential boundary conditions are given as $T_1 = 0$ and $T_3 = 1$.\nThe goal is to solve for the unknown interior nodal temperature, $T_2$. We focus on the second equation of the system, which corresponds to the unconstrained Degree of Freedom (DOF):\n$$ K_{21}T_1 + K_{22}T_2 + K_{23}T_3 = 0 $$\nSubstituting the values of the stiffness matrix components and the boundary conditions:\n$$ (-\\frac{8}{3})(0) + (\\frac{16}{3})T_2 + (-\\frac{8}{3})(1) = 0 $$\nThis simplifies to:\n$$ (\\frac{16}{3})T_2 - \\frac{8}{3} = 0 $$\nSolving for $T_2$:\n$$ (\\frac{16}{3})T_2 = \\frac{8}{3} $$\n$$ T_2 = \\frac{8/3}{16/3} = \\frac{8}{16} = \\frac{1}{2} $$\nThe temperature at the interior node $x=1/2$ is $1/2$. This result is exact because the quadratic element space contains the exact linear solution $T(x)=x$.",
            "answer": "$$ \\boxed{\\frac{1}{2}} $$"
        },
        {
            "introduction": "Having established the mechanics of $p$-refinement, we now explore its primary motivation: the potential for vastly superior convergence rates. This computational exercise  directly compares the efficiency of $p$-refinement against traditional $h$-refinement for approximating a smooth, analytic function. By enforcing an equal number of degrees of freedom for both strategies, you will empirically verify the exponential convergence of spectral ($p$-type) methods and witness firsthand why they are the preferred choice for problems where the solution is known to be regular.",
            "id": "3977301",
            "problem": "You are tasked with a principled numerical comparison between polynomial degree refinement and mesh-size refinement in the context of spectral and finite element interpolation of a temperature field in computational thermal engineering. Consider a dimensionless temperature field $T(x)=\\exp(x)$ defined on the interval $[0,1]$. The objective is to quantify and compare interpolation error under the two refinement strategies: polynomial degree refinement ($p$-refinement) using a single spectral element and mesh-size refinement ($h$-refinement) using a uniform partition with linear elements, while enforcing the same number of global degrees of freedom for a fair comparison.\n\nBase your approach on the following foundational principles and definitions:\n- The governing context is steady thermal behavior represented by a scalar field $T(x)$; the interpolation problem is independent of dynamics and boundary conditions because the goal is solely the approximation of a smooth function by discrete polynomial spaces. The approximation underlies the discretization strategies used in numerical solutions of thermal conduction.\n- The spectral element method on a single element of $[0,1]$ uses polynomial interpolation of degree $p$ at a set of nodal points associated with orthogonal polynomials, and the error assessment must be based on a well-defined norm over $[0,1]$.\n- The mesh-size refinement approach with linear elements uses piecewise linear interpolation over a partition of $[0,1]$ into subintervals of equal length, and the error assessment likewise uses the same norm over $[0,1]$.\n\nFormulate a program that, for each specified polynomial degree $p$, performs the following steps:\n1. Construct a single-element spectral interpolant of degree $p$ for $T(x)=\\exp(x)$ on $[0,1]$ using polynomial interpolation nodes that include both endpoints and are aligned with the theory of orthogonal polynomials on $[-1,1]$, mapped to $[0,1]$.\n2. Construct a uniform mesh of $N$ linear elements on $[0,1]$, where $N$ is chosen to satisfy $N=p$ so that both the spectral interpolant and the linear mesh interpolant have the same number of global degrees of freedom $p+1$ on $[0,1]$. Build the continuous piecewise linear interpolant for $T(x)$ on this mesh.\n3. For each interpolant, compute the interpolation error as the $L^2$ norm over $[0,1]$, defined by\n$$\nE = \\left( \\int_{0}^{1} \\left( T(x) - T_h(x) \\right)^2 \\, dx \\right)^{1/2},\n$$\nwhere $T_h(x)$ denotes the respective interpolant. Use a high-order quadrature to ensure that the integral is accurately approximated for all tested cases.\n\nYour test suite must assess the following values of the polynomial degree $p$: $p\\in\\{1,2,5,10,20\\}$. This set covers:\n- A boundary case $p=1$ where both strategies coincide in form.\n- Moderate degrees $p=2$ and $p=5$ representing typical refinement scenarios.\n- Higher degrees $p=10$ and $p=20$ to demonstrate the behavior of analytic function interpolation under $p$-refinement compared to $h$-refinement at the same global degrees of freedom.\n\nAll quantities are dimensionless; no physical units are required. Angles are not involved. The final output from your program must be a single line containing a comma-separated list enclosed in square brackets, where each entry corresponds to one test case and is itself a list of the form $[p,E_p,E_h]$ with $E_p$ the $L^2$ interpolation error for the spectral $p$-refined interpolant and $E_h$ the $L^2$ interpolation error for the $h$-refined linear interpolant, both expressed as floating-point numbers. For example, the output format must be\n$[\\,[p_1,E_{p,1},E_{h,1}],\\,[p_2,E_{p,2},E_{h,2}],\\,\\ldots\\,]$,\nwith each $p_i$ from the specified test suite.\n\nYour program must be complete, runnable, and produce exactly the single-line output described above without requiring any user input or external resources.",
            "solution": "The user-provided problem is assessed as **valid**. It is a well-posed, scientifically grounded problem in numerical analysis, directly relevant to the comparison of fundamental discretization strategies in computational science and engineering.\n\n### Principle-Based Solution\n\nThe problem requires a numerical comparison of two fundamental refinement strategies for function approximation: polynomial degree refinement ($p$-refinement) and mesh-size refinement ($h$-refinement). We are tasked with interpolating the scalar temperature field $T(x) = \\exp(x)$ on the dimensionless domain $[0, 1]$ and quantifying the interpolation error for each strategy under the constraint of an equal number of global degrees of freedom.\n\nThe core principle being investigated is the rate of convergence of the interpolation error. For analytic functions, such as $T(x) = \\exp(x)$, spectral methods ($p$-refinement) are known to exhibit exponential convergence, meaning the error decreases exponentially with the polynomial degree $p$. In contrast, low-order finite element methods ($h$-refinement with fixed low-degree polynomials) exhibit algebraic convergence, where the error decreases as a power of the mesh size $h$.\n\nLet's formalize the two approaches for a given integer parameter $p \\ge 1$. For a fair comparison, both methods will be configured to use $p+1$ global degrees of freedom (DoF).\n\n#### 1. p-Refinement: Spectral Element Interpolation\n\nIn this approach, we use a single element, the entire domain $[0, 1]$, and seek an approximation within the space of polynomials of degree at most $p$, denoted $\\mathbb{P}_p([0, 1])$. A unique polynomial in this space is determined by its values at $p+1$ distinct points. To achieve high accuracy, these points should not be chosen arbitrarily. The theory of spectral methods indicates that a near-optimal choice is the set of Gauss-Lobatto-Legendre (GLL) nodes.\n\nThe GLL nodes, $\\{\\xi_j\\}_{j=0}^{p}$, are defined on the reference interval $[-1, 1]$. The endpoints $\\xi_0 = -1$ and $\\xi_p = 1$ are included, and the $p-1$ interior nodes, $\\{\\xi_j\\}_{j=1}^{p-1}$, are the roots of $P'_p(\\xi)$, the first derivative of the Legendre polynomial of degree $p$. These nodes are also the roots of the Jacobi polynomial $P_{p-1}^{(1,1)}(\\xi)$.\n\nWe transform these nodes from the reference interval $[-1, 1]$ to the physical domain $[0, 1]$ using the affine map:\n$$\nx_j = \\frac{1}{2}(\\xi_j + 1), \\quad j = 0, 1, \\ldots, p\n$$\nThe spectral interpolant, $T_p(x)$, is the unique polynomial of degree $p$ that passes through the points $(x_j, T(x_j))$:\n$$\nT_p(x) = \\sum_{j=0}^{p} T(x_j) L_j(x)\n$$\nHere, $L_j(x)$ are the Lagrange basis polynomials of degree $p$ associated with the node set $\\{x_j\\}$, satisfying $L_j(x_k) = \\delta_{jk}$, where $\\delta_{jk}$ is the Kronecker delta.\n\n#### 2. h-Refinement: Piecewise Linear Finite Element Interpolation\n\nFor the $h$-refinement strategy, we use the simplest finite element: the linear element. To match the $p+1$ degrees of freedom of the spectral method, we construct a uniform mesh of $N$ elements, where the number of nodes is $N+1 = p+1$, which implies $N=p$.\n\nThe domain $[0, 1]$ is partitioned into $p$ subintervals $[x_i, x_{i+1}]$ of equal length $h = 1/p$. The grid nodes are located at:\n$$\nx_i = \\frac{i}{p}, \\quad i = 0, 1, \\ldots, p\n$$\nThe interpolant, $T_h(x)$, is a continuous function that is linear on each subinterval $[x_i, x_{i+1}]$. For $x \\in [x_i, x_{i+1}]$, the interpolant is given by:\n$$\nT_h(x) = T(x_i) \\frac{x_{i+1} - x}{h} + T(x_{i+1}) \\frac{x - x_i}{h}\n$$\nThis defines the interpolant over the entire domain $[0, 1]$. For the special case $p=1$, we have $N=1$ element. The nodes are $x_0=0$ and $x_1=1$, and the interpolant is a single line segment connecting $(0, T(0))$ and $(1, T(1))$. This is identical to the spectral interpolant of degree $p=1$, whose GLL nodes are also at the endpoints. Thus, for $p=1$, the errors $E_p$ and $E_h$ must be equal.\n\n#### 3. Error Quantification\n\nThe interpolation error for both methods is measured using the $L^2$-norm, defined as:\n$$\nE = \\left( \\int_{0}^{1} \\left( T(x) - T_{approx}(x) \\right)^2 \\, dx \\right)^{1/2}\n$$\nwhere $T_{approx}(x)$ is either the spectral interpolant $T_p(x)$ or the piecewise linear interpolant $T_h(x)$.\n\nFor the $h$-refinement case, the integral is computed by summing the contributions from each element:\n$$\nE_h^2 = \\int_{0}^{1} \\left( T(x) - T_h(x) \\right)^2 \\, dx = \\sum_{i=0}^{p-1} \\int_{x_i}^{x_{i+1}} \\left( T(x) - T_h(x) \\right)^2 \\, dx\n$$\nThese integrals do not have simple analytical solutions and must be computed numerically. We employ a high-order adaptive quadrature routine, specifically the Gauss-Kronrod method, to ensure that the numerical integration error is negligible compared to the interpolation error being measured.\n\nThe following Python code implements this procedure for the specified values of $p \\in \\{1, 2, 5, 10, 20\\}$, calculating the errors $E_p$ and $E_h$ for each case. The results will demonstrate the superior convergence properties of $p$-refinement for the smooth, analytic function $T(x) = \\exp(x)$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import special, interpolate, integrate\n\ndef solve():\n    \"\"\"\n    Compares p-refinement and h-refinement for interpolating T(x)=exp(x)\n    on [0, 1] with an equal number of degrees of freedom.\n    \"\"\"\n\n    # Define the function to be interpolated.\n    def T(x):\n        return np.exp(x)\n\n    # The set of polynomial degrees to test.\n    test_cases = [1, 2, 5, 10, 20]\n    results = []\n\n    for p in test_cases:\n        # --- p-REFINEMENT (SPECTRAL METHOD) ---\n\n        # 1. Determine Gauss-Lobatto-Legendre (GLL) nodes for degree p.\n        # The interior GLL nodes are the roots of the derivative of the p-th\n        # Legendre polynomial, which are also roots of the Jacobi polynomial P_{p-1}^{(1,1)}.\n        if p == 1:\n            # For p=1, the GLL nodes are the endpoints.\n            gll_nodes_ref = np.array([-1.0, 1.0])\n        else:\n            # For p > 1, compute interior nodes and add endpoints.\n            internal_nodes_ref, _ = special.roots_jacobi(p - 1, 1, 1)\n            gll_nodes_ref = np.concatenate(([-1.0], internal_nodes_ref, [1.0]))\n\n        # 2. Map nodes from reference interval [-1, 1] to physical interval [0, 1].\n        gll_nodes_phys = 0.5 * (gll_nodes_ref + 1.0)\n        \n        # 3. Evaluate the function at the GLL nodes.\n        y_p_values = T(gll_nodes_phys)\n\n        # 4. Construct the polynomial interpolant using barycentric interpolation.\n        interpolant_p = interpolate.BarycentricInterpolator(gll_nodes_phys, y_p_values)\n\n        # 5. Define the squared error function for the p-refined interpolant.\n        def squared_error_p(x):\n            return (T(x) - interpolant_p(x))**2\n\n        # 6. Compute the L2 error by integrating the squared error.\n        integral_p, _ = integrate.quad(squared_error_p, 0, 1)\n        E_p = np.sqrt(integral_p)\n\n        # --- h-REFINEMENT (PIECEWISE LINEAR FEM) ---\n\n        # 1. Define a uniform mesh with N=p elements, giving p+1 nodes.\n        N = p\n        h_nodes = np.linspace(0, 1, N + 1)\n\n        # 2. Evaluate the function at the uniform nodes.\n        y_h_values = T(h_nodes)\n\n        # 3. Compute the L2 error by summing integrals over each element.\n        total_squared_error_h = 0.0\n        for i in range(N):\n            x_i, x_i1 = h_nodes[i], h_nodes[i+1]\n            y_i, y_i1 = y_h_values[i], y_h_values[i+1]\n            h = x_i1 - x_i\n\n            # Define the linear interpolant and squared error on the element [x_i, x_i1].\n            # Using default arguments in lambda to capture loop variables by value.\n            def squared_error_h_element(x, _xi=x_i, _yi=y_i, _xi1=x_i1, _yi1=y_i1, _h=h):\n                linear_interpolant_val = _yi * (_xi1 - x) / _h + _yi1 * (x - _xi) / _h\n                return (T(x) - linear_interpolant_val)**2\n\n            integral_h_element, _ = integrate.quad(squared_error_h_element, x_i, x_i1)\n            total_squared_error_h += integral_h_element\n\n        E_h = np.sqrt(total_squared_error_h)\n        \n        # Store the results for this p value.\n        results.append(f\"[{p},{E_p},{E_h}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The power of $p$-refinement is compelling, but its practical implementation is not without challenges. One of the most significant practical hurdles is the degradation of the stiffness matrix conditioning as the polynomial degree $p$ increases. This practice  delves into this critical issue, tasking you with numerically investigating the growth of the condition number and implementing a diagonal scaling technique to mitigate this ill-conditioning. Successfully completing this exercise will equip you with the knowledge to build high-order solvers that are not only accurate but also numerically robust.",
            "id": "3977350",
            "problem": "Consider one-dimensional steady heat conduction governed by Fourier’s law, where the thermal conductivity is constant and equal to $k=1$. On the reference element $[-1,1]$, the weak form of the conduction problem yields an element stiffness matrix defined by the bilinear form applied to hierarchical polynomial basis functions. Let the hierarchical basis be constructed from Legendre polynomials, with basis functions $\\{\\phi_i(x)\\}_{i=1}^p$ where $\\phi_i(x)=P_i(x)$, and $P_i(x)$ denotes the degree-$i$ Legendre polynomial normalized such that $P_i(1)=1$. The constant mode $P_0(x)$ is excluded to avoid singularity due to the null space of the gradient operator. The element stiffness matrix entries are\n$$\nK_{ij} \\;=\\; \\int_{-1}^{1} \\phi_i'(x)\\,\\phi_j'(x)\\,\\mathrm{d}x,\n$$\nfor $i,j \\in \\{1,2,\\dots,p\\}$. The goal is to analyze the impact of increasing $p$ on the conditioning of the stiffness matrix, estimate the growth of the condition number with respect to $p$ for Legendre-based hierarchical bases, and propose a diagonal scaling to mitigate ill-conditioning.\n\nStarting from the fundamental balance of energy and Fourier’s law, and using the Galerkin method on the reference element, derive how the stiffness matrix $K$ arises from the $H^1$ seminorm of the basis functions. Then, for a set of values of $p$, numerically assemble $K$ via exact polynomial quadrature (use Gauss–Legendre quadrature of sufficient order so that the integral of a polynomial of degree up to $2p-2$ is computed exactly) and compute the $2$-norm condition number $\\kappa_2(K)$ defined as\n$$\n\\kappa_2(K)\\;=\\;\\frac{\\lambda_{\\max}(K)}{\\lambda_{\\min}(K)},\n$$\nwhere $\\lambda_{\\max}(K)$ and $\\lambda_{\\min}(K)$ are the largest and smallest eigenvalues of $K$, respectively. Next, propose and implement a diagonal scaling $D$ with entries\n$$\nD_{ii}\\;=\\;\\int_{-1}^{1}\\left(\\phi_i'(x)\\right)^2\\,\\mathrm{d}x,\n$$\nand form the scaled stiffness matrix\n$$\n\\widetilde{K}\\;=\\;D^{-1/2} K\\, D^{-1/2}.\n$$\nCompute the condition number $\\kappa_2(\\widetilde{K})$ and compare with $\\kappa_2(K)$, discussing the observed mitigation of ill-conditioning. Finally, using the numerically computed $\\kappa_2(K)$ over the provided $p$ values, estimate the growth exponent $\\alpha$ in the empirical model\n$$\n\\kappa_2(K)\\;\\approx\\;C\\,p^{\\alpha},\n$$\nby performing a least-squares linear regression on $\\log(\\kappa_2(K))$ versus $\\log(p)$.\n\nAll computations are dimensionless and involve no physical units. Angles do not appear. Use Gauss–Legendre quadrature with a number of points $N_q$ satisfying $2N_q-1 \\ge 2p-2$, for example $N_q=2p+5$.\n\nYour program must implement the following test suite (each test case is a value of $p$):\n- $p=1$ (boundary case, single basis function),\n- $p=2$ (low-order case),\n- $p=4$ (moderate case),\n- $p=8$ (happy-path case),\n- $p=12$ (high-order case).\n\nFor each test case, your program must compute and return two floats: the unscaled condition number $\\kappa_2(K)$ and the scaled condition number $\\kappa_2(\\widetilde{K})$. After processing all test cases, your program must estimate and return the growth exponent $\\alpha$ based on the unscaled condition numbers for $p \\in \\{2,4,8,12\\}$. The final output must be a single line containing a comma-separated list enclosed in square brackets, in the exact order:\n$$\n[\\kappa_2(K)\\text{ at }p=1,\\;\\kappa_2(\\widetilde{K})\\text{ at }p=1,\\;\\kappa_2(K)\\text{ at }p=2,\\;\\kappa_2(\\widetilde{K})\\text{ at }p=2,\\;\\kappa_2(K)\\text{ at }p=4,\\;\\kappa_2(\\widetilde{K})\\text{ at }p=4,\\;\\kappa_2(K)\\text{ at }p=8,\\;\\kappa_2(\\widetilde{K})\\text{ at }p=8,\\;\\kappa_2(K)\\text{ at }p=12,\\;\\kappa_2(\\widetilde{K})\\text{ at }p=12,\\;\\alpha].\n$$\nAll reported values must be floats. The program must be self-contained, require no input, and use numerical quadrature and eigenvalue computation to produce the results exactly in the prescribed format.",
            "solution": "The starting point is Fourier’s law of heat conduction stating that the heat flux is proportional to the negative temperature gradient. In steady state, conservation of energy imposes the differential equation\n$$\n-\\frac{\\mathrm{d}}{\\mathrm{d}x}\\left(k \\frac{\\mathrm{d}T}{\\mathrm{d}x}\\right)\\;=\\;0,\n$$\non each element, which simplifies to\n$$\n-\\frac{\\mathrm{d}^2 T}{\\mathrm{d}x^2}\\;=\\;0,\n$$\nwhen $k=1$ is constant. The Galerkin method employs basis functions to approximate the temperature field $\\displaystyle T(x)\\approx \\sum_{i=0}^{p} a_i \\phi_i(x)$. The weak form involves integrating the product of gradients of basis functions, yielding the element stiffness matrix\n$$\nK_{ij}\\;=\\;\\int_{-1}^{1} \\phi_i'(x)\\,\\phi_j'(x)\\,\\mathrm{d}x,\n$$\nwhich encodes the $H^1$ seminorm inner product on the reference element $[-1,1]$.\n\nFor Legendre-based hierarchical bases, we take $\\phi_i(x)=P_i(x)$ for $i\\in\\{1,2,\\dots,p\\}$, excluding the constant mode $P_0(x)$ to prevent singularity due to the kernel of the gradient. The matrix $K$ is symmetric and positive definite, because each $\\phi_i'(x)$ is nonzero and the bilinear form is coercive on the span of $\\{P_1,\\dots,P_p\\}$.\n\nTo compute $K$ exactly by numerical quadrature, we note that $\\phi_i'(x)$ is a polynomial of degree $i-1$, and the integrand $\\phi_i'(x)\\phi_j'(x)$ has degree at most $2p-2$. Gauss–Legendre quadrature with $N_q$ points integrates polynomials up to degree $2N_q-1$ exactly; thus any choice of $N_q$ satisfying $2N_q-1\\ge 2p-2$ yields exact evaluation. For robustness, one may select $N_q=2p+5$.\n\nThe $2$-norm condition number is defined as\n$$\n\\kappa_2(K)\\;=\\;\\frac{\\lambda_{\\max}(K)}{\\lambda_{\\min}(K)},\n$$\nwhere $\\lambda_{\\max}(K)$ and $\\lambda_{\\min}(K)$ are the extreme eigenvalues. Since $K$ is symmetric positive definite, we compute these via the symmetric eigenvalue solver.\n\nIll-conditioning grows with $p$ because higher-degree polynomials possess larger gradients, which amplify the $H^1$ seminorm. For Legendre polynomials, a well-known identity is\n$$\n\\int_{-1}^{1} \\left(P_n'(x)\\right)^2\\,\\mathrm{d}x\\;=\\;\\frac{2\\,n\\,(n+1)}{2n+1},\n$$\nwhich asymptotically behaves like $\\mathcal{O}(n)$ for large $n$. This suggests that diagonal entries of $K$ grow on the order of $p$, and hence the ratio of largest to smallest entries grows with $p$, leading to an increase in $\\kappa_2(K)$ approximately proportional to a power of $p$. The exact growth rate depends on the off-diagonal coupling among derivatives of Legendre polynomials, which we resolve numerically.\n\nTo mitigate ill-conditioning, we propose diagonal scaling based on normalizing each basis function by its gradient norm. Define the diagonal scaling matrix\n$$\nD\\;=\\;\\mathrm{diag}\\left(D_{11},D_{22},\\dots,D_{pp}\\right),\\quad D_{ii}\\;=\\;\\int_{-1}^{1}\\left(\\phi_i'(x)\\right)^2\\,\\mathrm{d}x.\n$$\nForm the scaled stiffness matrix\n$$\n\\widetilde{K}\\;=\\;D^{-1/2}\\,K\\,D^{-1/2}.\n$$\nThis scaling normalizes the $H^1$ seminorm of each mode, equalizes diagonal entries to unity, and reduces disparities among modes, thereby improving the condition number. In terms of spectral properties, the scaled matrix is a correlation matrix of gradient modes, which typically has a significantly smaller condition number than the unscaled stiffness matrix.\n\nAlgorithmic steps:\n- For each $p$ in the test suite $\\{1,2,4,8,12\\}$, construct $\\{\\phi_i\\}_{i=1}^{p}$ as Legendre polynomials $P_i(x)$, evaluate their derivatives at Gauss–Legendre points $\\{x_k,w_k\\}_{k=1}^{N_q}$, and assemble $K$ via\n$$\nK_{ij}\\;=\\;\\sum_{k=1}^{N_q} w_k\\,\\phi_i'(x_k)\\,\\phi_j'(x_k).\n$$\n- Compute $\\kappa_2(K)$ by the ratio of the largest and smallest eigenvalues of $K$.\n- Form $D$ with $D_{ii}=K_{ii}$, build $\\widetilde{K}=D^{-1/2} K D^{-1/2}$, and compute $\\kappa_2(\\widetilde{K})$ similarly.\n- Estimate the growth exponent $\\alpha$ in the model $\\kappa_2(K)\\approx C p^{\\alpha}$ by least-squares fitting of $\\log(\\kappa_2(K))$ versus $\\log(p)$ for $p\\in\\{2,4,8,12\\}$:\n$$\n\\alpha\\;=\\;\\frac{\\sum (\\log p - \\overline{\\log p})(\\log \\kappa_2 - \\overline{\\log \\kappa_2})}{\\sum (\\log p - \\overline{\\log p})^2}.\n$$\n\nThe final program produces a single line of output containing the floats in the exact order specified:\n$$\n[\\kappa_2(K)\\text{ at }p=1,\\;\\kappa_2(\\widetilde{K})\\text{ at }p=1,\\;\\kappa_2(K)\\text{ at }p=2,\\;\\kappa_2(\\widetilde{K})\\text{ at }p=2,\\;\\kappa_2(K)\\text{ at }p=4,\\;\\kappa_2(\\widetilde{K})\\text{ at }p=4,\\;\\kappa_2(K)\\text{ at }p=8,\\;\\kappa_2(\\widetilde{K})\\text{ at }p=8,\\;\\kappa_2(K)\\text{ at }p=12,\\;\\kappa_2(\\widetilde{K})\\text{ at }p=12,\\;\\alpha].\n$$\nThis framework directly tests the impact of $p$-refinement on stiffness conditioning and demonstrates how diagonal scaling rooted in the $H^1$ seminorm alleviates ill-conditioning, which is essential when designing $p$-refinement and combined $h$-$p$-refinement strategies in computational thermal engineering.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom numpy.polynomial.legendre import Legendre, leggauss\n\ndef assemble_stiffness_legendre(p: int) -> np.ndarray:\n    \"\"\"\n    Assemble the stiffness matrix K_ij = ∫_{-1}^{1} P_i'(x) P_j'(x) dx\n    for i,j = 1..p (excluding P_0).\n    Uses Gauss-Legendre quadrature with sufficient order for exactness.\n    \"\"\"\n    # Number of quadrature points: exactness up to degree 2p-2, choose a safe value\n    nquad = max(2 * p + 5, 8)\n    xq, wq = leggauss(nquad)\n\n    # Evaluate derivatives of Legendre polynomials at quadrature points\n    # Legendre.basis(n) gives polynomial with coefficient 1 for degree n (in Legendre basis)\n    deriv_vals = np.zeros((p, nquad))\n    for i in range(1, p + 1):\n        Pi = Legendre.basis(i)\n        dPi = Pi.deriv()\n        deriv_vals[i - 1, :] = dPi(xq)\n\n    # Assemble stiffness matrix via quadrature: K = dphi * W * dphi^T\n    # where W is diagonal of weights\n    K = deriv_vals @ (wq[:, None] * deriv_vals.T)\n    return K\n\ndef condition_number_2norm_spd(K: np.ndarray) -> float:\n    \"\"\"\n    Compute the 2-norm condition number for a symmetric positive definite matrix:\n    cond2 = lambda_max / lambda_min\n    \"\"\"\n    # Use eigenvalues for symmetric matrix\n    evals = np.linalg.eigvalsh(K)\n    # Guard against tiny negative due to numerical roundoff\n    evals = np.maximum(evals, 0.0)\n    lam_min = np.min(evals)\n    lam_max = np.max(evals)\n    # If lam_min is zero (should not happen for our SPD), return inf\n    if lam_min == 0.0:\n        return float('inf')\n    return float(lam_max / lam_min)\n\ndef diagonal_scaling(K: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Return the scaled stiffness matrix Ktilde = D^{-1/2} K D^{-1/2},\n    with D = diag(K_ii) (gradient L2 norms of basis functions).\n    \"\"\"\n    diag_entries = np.diag(K).copy()\n    # Prevent division by zero: add tiny perturbation (shouldn't be needed for i>=1)\n    diag_entries = np.where(diag_entries > 0.0, diag_entries, 1e-30)\n    inv_sqrt = 1.0 / np.sqrt(diag_entries)\n    # Scale: Ktilde_{ij} = K_{ij} / sqrt(D_ii D_jj)\n    Ktilde = (inv_sqrt[:, None] * K) * inv_sqrt[None, :]\n    return Ktilde\n\ndef estimate_alpha(ps: np.ndarray, kappas: np.ndarray) -> float:\n    \"\"\"\n    Estimate alpha in kappa ~ C * p^alpha via least-squares fit on logs.\n    \"\"\"\n    logp = np.log(ps.astype(float))\n    logk = np.log(kappas.astype(float))\n    # Linear regression slope\n    mean_logp = np.mean(logp)\n    mean_logk = np.mean(logk)\n    num = np.sum((logp - mean_logp) * (logk - mean_logk))\n    den = np.sum((logp - mean_logp) ** 2)\n    if den == 0.0:\n        return 0.0\n    return float(num / den)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_ps = [1, 2, 4, 8, 12]\n\n    unscaled = []\n    scaled = []\n    for p in test_ps:\n        K = assemble_stiffness_legendre(p)\n        kappa = condition_number_2norm_spd(K)\n        Ktilde = diagonal_scaling(K)\n        kappa_scaled = condition_number_2norm_spd(Ktilde)\n        unscaled.append(kappa)\n        scaled.append(kappa_scaled)\n\n    # Estimate alpha using unscaled condition numbers for p in {2,4,8,12}\n    ps_for_fit = np.array([2, 4, 8, 12], dtype=float)\n    kappas_for_fit = np.array([unscaled[test_ps.index(int(pp))] for pp in ps_for_fit], dtype=float)\n    alpha = estimate_alpha(ps_for_fit, kappas_for_fit)\n\n    # Aggregate results: [kappa_p1, kappa_scaled_p1, kappa_p2, kappa_scaled_p2, ... , alpha]\n    results = []\n    for i in range(len(test_ps)):\n        results.append(unscaled[i])\n        results.append(scaled[i])\n    results.append(alpha)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}