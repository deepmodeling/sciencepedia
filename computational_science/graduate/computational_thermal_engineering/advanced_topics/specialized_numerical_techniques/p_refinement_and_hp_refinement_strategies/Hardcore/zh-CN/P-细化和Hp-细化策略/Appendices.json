{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握 $p$-refinement，我们必须首先了解它在最基础层面上的运作方式，即单元刚度矩阵的构建。本练习将引导您完成将单个单元从线性（$p=1$）升级到二次（$p=2$）的过程，揭示多项式丰富化对代数系统的直接影响。通过这个手动计算，您将对 $p$-refinement 的内部机制有更深刻的理解。",
            "id": "3977363",
            "problem": "考虑由傅里叶定律和能量守恒控制的稳态一维热传导。在域 $[0,1]$ 上，其强形式为 $-\\frac{d}{dx}\\left(k \\frac{dT}{dx}\\right)=q$，其中导热系数为常数 $k=1$，体积热生成为 $q=0$。边界条件为左端齐次狄利克雷边界条件和右端非齐次狄利克雷边界条件：$T(0)=0$ 和 $T(1)=1$。使用伽辽金有限元法（FEM），采用标准的 $H^{1}$-协调试探和检验空间，以及一个跨越整个域的单元。\n\n任务：\n- 从弱形式出发，使用标准的线性拉格朗日形函数，为 $[0,1]$ 上的单个线性（$p=1$）单元构建单元级刚度矩阵和载荷向量。\n- 应用 $p$-细化，将同一个单元升级为二次（$p=2$）单元，其拉格朗日插值节点位于 $x=0$、$x=\\frac{1}{2}$ 和 $x=1$。构建相应的单元级刚度矩阵和载荷向量。\n- 对二次情况组装全局系统。然后施加本质（狄利克雷）边界条件 $T(0)=0$ 和 $T(1)=1$。将系统简化为与 $x=\\frac{1}{2}$ 处节点相关的单个内部自由度（DOF），并显式求解该节点温度。\n\n将内部节点温度的最终值表示为无量纲数。无需四舍五入；报告精确值。",
            "solution": "该问题陈述是一个适定的一维稳态热传导边值问题，适合使用有限元法进行分析。它具有科学依据，内容自洽，且求解所需的所有数据均已提供。因此，该问题是有效的。\n\n热传导方程的控制强形式由下式给出：\n$$ -\\frac{d}{dx}\\left(k \\frac{dT}{dx}\\right) = q(x) \\quad \\text{for } x \\in (0,1) $$\n其中导热系数 $k=1$，体积热生成 $q=0$，狄利克雷边界条件为 $T(0)=0$ 和 $T(1)=1$。\n\n首先，我们推导弱形式。设 $v(x)$ 是一个合适函数空间中的权函数。将强形式乘以 $v(x)$ 并在域 $\\Omega = [0,1]$ 上积分，得到：\n$$ -\\int_{0}^{1} v \\frac{d}{dx}\\left(k \\frac{dT}{dx}\\right) dx = \\int_{0}^{1} v q dx $$\n对左侧应用分部积分：\n$$ \\int_{0}^{1} k \\frac{dv}{dx} \\frac{dT}{dx} dx - \\left[v k \\frac{dT}{dx}\\right]_{0}^{1} = \\int_{0}^{1} v q dx $$\n伽辽金法将温度场 $T(x)$ 近似为基函数 $N_j(x)$ 的线性组合，$T(x) \\approx T^h(x) = \\sum_{j=1}^{n} T_j N_j(x)$，其中 $T_j$ 是节点温度值。权函数 $v(x)$ 选自同一组基函数，即 $v(x) = N_i(x)$。这导出一个代数方程组 $[K]\\{T\\} = \\{F\\}$，其中刚度矩阵 $[K]$ 和力向量 $\\{F\\}$ 定义为：\n$$ K_{ij} = \\int_{0}^{1} k \\frac{dN_i}{dx} \\frac{dN_j}{dx} dx $$\n$$ F_i = \\int_{0}^{1} N_i q dx + \\left[N_i k \\frac{dT}{dx}\\right]_{0}^{1} $$\n给定 $k=1$ 和 $q=0$，单元刚度矩阵为 $K_{ij}^{(e)} = \\int_{\\Omega_e} \\frac{dN_i}{dx} \\frac{dN_j}{dx} dx$，由热生成引起的单元载荷向量为 $\\{F^{(e)}\\} = \\{0\\}$。\n\n**任务1：$[0,1]$ 上的线性单元（$p=1$）**\n对于一个跨越域 $[0,1]$ 的单个线性单元，节点位于 $x_1=0$ 和 $x_2=1$。标准的线性拉格朗日形函数为：\n$N_1(x) = 1-x$\n$N_2(x) = x$\n形函数的导数为：\n$\\frac{dN_1}{dx} = -1$\n$\\frac{dN_2}{dx} = 1$\n$2 \\times 2$ 单元刚度矩阵 $K^{(e)}$ 的分量计算如下：\n$K_{11}^{(e)} = \\int_{0}^{1} (1) (\\frac{dN_1}{dx})(\\frac{dN_1}{dx}) dx = \\int_{0}^{1} (-1)(-1) dx = 1$\n$K_{12}^{(e)} = \\int_{0}^{1} (1) (\\frac{dN_1}{dx})(\\frac{dN_2}{dx}) dx = \\int_{0}^{1} (-1)(1) dx = -1$\n$K_{21}^{(e)} = K_{12}^{(e)} = -1$\n$K_{22}^{(e)} = \\int_{0}^{1} (1) (\\frac{dN_2}{dx})(\\frac{dN_2}{dx}) dx = \\int_{0}^{1} (1)(1) dx = 1$\n$p=1$ 单元的单元刚度矩阵为：\n$$ [K^{(e)}] = \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} $$\n由源项引起的单元载荷向量为：\n$$ \\{F^{(e)}\\} = \\begin{pmatrix} \\int_{0}^{1} N_1(x) (0) dx \\\\ \\int_{0}^{1} N_2(x) (0) dx \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix} $$\n\n**任务2：$[0,1]$ 上的二次单元（$p=2$）**\n对于一个跨越 $[0,1]$ 的单个二次单元，节点位于 $x_1=0$、$x_2=\\frac{1}{2}$ 和 $x_3=1$。二次拉格朗日形函数为：\n$N_1(x) = \\frac{(x-x_2)(x-x_3)}{(x_1-x_2)(x_1-x_3)} = \\frac{(x-1/2)(x-1)}{(0-1/2)(0-1)} = 2(x^2 - \\frac{3}{2}x + \\frac{1}{2}) = 2x^2 - 3x + 1$\n$N_2(x) = \\frac{(x-x_1)(x-x_3)}{(x_2-x_1)(x_2-x_3)} = \\frac{(x-0)(x-1)}{(1/2-0)(1/2-1)} = -4(x^2-x) = -4x^2 + 4x$\n$N_3(x) = \\frac{(x-x_1)(x-x_2)}{(x_3-x_1)(x_3-x_2)} = \\frac{(x-0)(x-1/2)}{(1-0)(1-1/2)} = 2(x^2 - \\frac{1}{2}x) = 2x^2 - x$\n导数为：\n$\\frac{dN_1}{dx} = 4x - 3$\n$\\frac{dN_2}{dx} = -8x + 4$\n$\\frac{dN_3}{dx} = 4x - 1$\n$3 \\times 3$ 单元刚度矩阵 $K^{(e)}$ 的分量计算如下：\n$K_{11}^{(e)} = \\int_0^1 (4x-3)^2 dx = \\int_0^1 (16x^2-24x+9)dx = [\\frac{16}{3}x^3-12x^2+9x]_0^1 = \\frac{16}{3}-12+9 = \\frac{7}{3}$\n$K_{12}^{(e)} = \\int_0^1 (4x-3)(-8x+4)dx = \\int_0^1 (-32x^2+40x-12)dx = [-\\frac{32}{3}x^3+20x^2-12x]_0^1 = -\\frac{32}{3}+20-12 = -\\frac{8}{3}$\n$K_{13}^{(e)} = \\int_0^1 (4x-3)(4x-1)dx = \\int_0^1 (16x^2-16x+3)dx = [\\frac{16}{3}x^3-8x^2+3x]_0^1 = \\frac{16}{3}-8+3 = \\frac{1}{3}$\n$K_{22}^{(e)} = \\int_0^1 (-8x+4)^2dx = \\int_0^1 (64x^2-64x+16)dx = [\\frac{64}{3}x^3-32x^2+16x]_0^1 = \\frac{64}{3}-32+16 = \\frac{16}{3}$\n$K_{23}^{(e)} = \\int_0^1 (-8x+4)(4x-1)dx = \\int_0^1 (-32x^2+24x-4)dx = [-\\frac{32}{3}x^3+12x^2-4x]_0^1 = -\\frac{32}{3}+12-4 = -\\frac{8}{3}$\n$K_{33}^{(e)} = \\int_0^1 (4x-1)^2dx = \\int_0^1 (16x^2-8x+1)dx = [\\frac{16}{3}x^3-4x^2+x]_0^1 = \\frac{16}{3}-4+1 = \\frac{7}{3}$\n根据对称性，$K_{21}^{(e)}=K_{12}^{(e)}$，$K_{31}^{(e)}=K_{13}^{(e)}$，以及 $K_{32}^{(e)}=K_{23}^{(e)}$。\n$p=2$ 单元的单元刚度矩阵为：\n$$ [K^{(e)}] = \\begin{pmatrix} 7/3  -8/3  1/3 \\\\ -8/3  16/3  -8/3 \\\\ 1/3  -8/3  7/3 \\end{pmatrix} = \\frac{1}{3} \\begin{pmatrix} 7  -8  1 \\\\ -8  16  -8 \\\\ 1  -8  7 \\end{pmatrix} $$\n单元载荷向量同样为 $\\{F^{(e)}\\} = \\{0\\}$。\n\n**任务3：二次情况的系统组装、边界条件和求解**\n由于只有一个单元，全局系统与单元系统相同：$[K]\\{T\\} = \\{F\\}$。向量 $\\{F\\}$ 包含了源项（为零）和边界反力。方程组为：\n$$ \\frac{1}{3} \\begin{pmatrix} 7  -8  1 \\\\ -8  16  -8 \\\\ 1  -8  7 \\end{pmatrix} \\begin{pmatrix} T_1 \\\\ T_2 \\\\ T_3 \\end{pmatrix} = \\begin{pmatrix} R_1 \\\\ 0 \\\\ R_3 \\end{pmatrix} $$\n其中 $T_1=T(0)$，$T_2=T(1/2)$，$T_3=T(1)$。$R_1$ 和 $R_3$ 是狄利克雷边界上的未知反力。\n给定的本质边界条件为 $T_1 = 0$ 和 $T_3 = 1$。\n目标是求解未知的内部节点温度 $T_2$。我们关注系统中的第二个方程，它对应于无约束的自由度（DOF）：\n$$ K_{21}T_1 + K_{22}T_2 + K_{23}T_3 = 0 $$\n代入刚度矩阵分量和边界条件的值：\n$$ (-\\frac{8}{3})(0) + (\\frac{16}{3})T_2 + (-\\frac{8}{3})(1) = 0 $$\n简化后得到：\n$$ (\\frac{16}{3})T_2 - \\frac{8}{3} = 0 $$\n求解 $T_2$：\n$$ (\\frac{16}{3})T_2 = \\frac{8}{3} $$\n$$ T_2 = \\frac{8/3}{16/3} = \\frac{8}{16} = \\frac{1}{2} $$\n内部节点 $x=1/2$ 处的温度为 $1/2$。这个结果是精确的，因为二次单元空间包含了精确的线性解 $T(x)=x$。",
            "answer": "$$ \\boxed{\\frac{1}{2}} $$"
        },
        {
            "introduction": "在理解了 $p$-refinement 的基本机制之后，我们现在来探讨其主要优势：它在处理光滑问题时卓越的效率。本练习通过编程实践，数值比较了 $p$-refinement（谱方法）和 $h$-refinement（标准有限元）在逼近一个光滑函数时的收敛性。您将亲眼见证高阶方法的标志性特征——指数收敛，并理解为何在相同的自由度下，$p$-refinement 的精度远超 $h$-refinement。",
            "id": "3977301",
            "problem": "你的任务是在计算热工学的背景下，对谱元和有限元插值中的多项式阶数加密和网格尺寸加密进行一次基于原理的数值比较。考虑在区间 $[0,1]$ 上定义的无量纲温度场 $T(x)=\\exp(x)$。目标是量化和比较两种加密策略下的插值误差：使用单个谱元的多项式阶数加密（$p$-加密）和使用线性元的均匀剖分的网格尺寸加密（$h$-加密），同时为了公平比较，强制两种策略具有相同的全局自由度。\n\n你的方法应基于以下基本原则和定义：\n- 控制背景是由标量场 $T(x)$ 表示的稳态热行为；插值问题独立于动力学和边界条件，因为目标仅仅是用离散多项式空间逼近一个光滑函数。这种逼近是热传导数值解中所使用的离散化策略的基础。\n- 在 $[0,1]$ 单个单元上的谱元法使用与正交多项式相关的一组节点上的 $p$ 阶多项式插值，并且误差评估必须基于 $[0,1]$ 上一个明确定义的范数。\n- 使用线性元的网格尺寸加密方法在 $[0,1]$ 的等长子区间剖分上使用分段线性插值，误差评估同样使用 $[0,1]$ 上的相同范数。\n\n编写一个程序，对于每个指定的多项式阶数 $p$，执行以下步骤：\n1. 对 $[0,1]$ 上的 $T(x)=\\exp(x)$ 构建一个 $p$ 阶的单元素谱插值。使用的多项式插值节点应包括两个端点，并与 $[-1,1]$ 上映射到 $[0,1]$ 的正交多项式理论保持一致。\n2. 在 $[0,1]$ 上构建一个包含 $N$ 个线性元的均匀网格，其中 $N$ 的选择应满足 $N=p$，以使谱插值和线性网格插值在 $[0,1]$ 上具有相同的全局自由度 $p+1$。在此网格上构建 $T(x)$ 的连续分段线性插值。\n3. 对每个插值，计算其在 $[0,1]$ 上的 $L^2$ 范数插值误差，定义为\n$$\nE = \\left( \\int_{0}^{1} \\left( T(x) - T_h(x) \\right)^2 \\, dx \\right)^{1/2},\n$$\n其中 $T_h(x)$ 表示相应的插值函数。使用高阶求积法来确保在所有测试案例中积分都能被精确近似。\n\n你的测试套件必须评估以下多项式阶数 $p$ 的值：$p\\in\\{1,2,5,10,20\\}$。该集合涵盖：\n- 一个边界情况 $p=1$，此时两种策略在形式上重合。\n- 中等阶数 $p=2$ 和 $p=5$，代表典型的加密场景。\n- 较高阶数 $p=10$ 和 $p=20$，用于展示在相同全局自由度下，$p$-加密相比于$h$-加密在解析函数插值中的表现。\n\n所有量都是无量纲的；不需要物理单位。不涉及角度。你的程序最终输出必须是单行，包含一个方括号括起来的逗号分隔列表，其中每个条目对应一个测试用例，本身是一个形如 $[p,E_p,E_h]$ 的列表，$E_p$ 是谱$p$-加密插值的$L^2$插值误差，$E_h$ 是$h$-加密线性插值的$L^2$插值误差，两者均表示为浮点数。例如，输出格式必须为\n$[\\,[p_1,E_{p,1},E_{h,1}],\\,[p_2,E_{p,2},E_{h,2}],\\,\\ldots\\,]$,\n其中每个 $p_i$ 来自指定的测试套件。\n\n你的程序必须是完整的、可运行的，并且能够精确地产生上述单行输出，无需任何用户输入或外部资源。",
            "solution": "用户提供的问题被评估为 **有效**。这是一个定义明确、具有科学依据的数值分析问题，直接关系到计算科学与工程中基本离散化策略的比较。\n\n### 基于原理的解决方案\n\n该问题要求对函数逼近的两种基本加密策略进行数值比较：多项式阶数加密（$p$-加密）和网格尺寸加密（$h$-加密）。我们的任务是在无量纲域 $[0, 1]$ 上插值标量温度场 $T(x) = \\exp(x)$，并在全局自由度相等的约束下，量化每种策略的插值误差。\n\n所研究的核心原理是插值误差的收敛率。对于像 $T(x) = \\exp(x)$ 这样的解析函数，已知谱方法（$p$-加密）会表现出指数收敛，即误差随多项式阶数 $p$呈指数级下降。相比之下，低阶有限元方法（固定低阶多项式的$h$-加密）则表现出代数收敛，即误差随网格尺寸 $h$ 的幂次下降。\n\n让我们为一个给定的整数参数 $p \\ge 1$ 来形式化这两种方法。为进行公平比较，两种方法都将配置为使用 $p+1$ 个全局自由度（DoF）。\n\n#### 1. p-加密：谱元插值\n\n在此方法中，我们使用单个元素，即整个域 $[0, 1]$，并在最多 $p$ 阶的多项式空间（记为 $\\mathbb{P}_p([0, 1])$）中寻找一个近似解。该空间中的唯一多项式由其在 $p+1$ 个不同点上的值确定。为实现高精度，这些点不应随意选择。谱方法理论表明，近乎最优的选择是Gauss-Lobatto-Legendre (GLL) 节点集。\n\nGLL节点 $\\{\\xi_j\\}_{j=0}^{p}$ 定义在参考区间 $[-1, 1]$上。端点 $\\xi_0 = -1$ 和 $\\xi_p = 1$ 被包括在内，而 $p-1$ 个内部节点 $\\{\\xi_j\\}_{j=1}^{p-1}$ 是 $p$ 阶勒让德多项式的一阶导数 $P'_p(\\xi)$ 的根。这些节点也是雅可比多项式 $P_{p-1}^{(1,1)}(\\xi)$ 的根。\n\n我们使用仿射映射将这些节点从参考区间 $[-1, 1]$ 转换到物理域 $[0, 1]$：\n$$\nx_j = \\frac{1}{2}(\\xi_j + 1), \\quad j = 0, 1, \\ldots, p\n$$\n谱插值 $T_p(x)$ 是穿过点 $(x_j, T(x_j))$ 的唯一的 $p$ 阶多项式：\n$$\nT_p(x) = \\sum_{j=0}^{p} T(x_j) L_j(x)\n$$\n此处，$L_j(x)$ 是与节点集 $\\{x_j\\}$ 相关的 $p$ 阶拉格朗日基多项式，满足 $L_j(x_k) = \\delta_{jk}$，其中 $\\delta_{jk}$ 是克罗内克δ。\n\n#### 2. h-加密：分段线性有限元插值\n\n对于 $h$-加密策略，我们使用最简单的有限元：线性元。为了匹配谱方法的 $p+1$ 个自由度，我们构建一个包含 $N$ 个单元的均匀网格，其中节点数为 $N+1 = p+1$，这意味着 $N=p$。\n\n域 $[0, 1]$ 被剖分为 $p$ 个等长的子区间 $[x_i, x_{i+1}]$，长度为 $h = 1/p$。网格节点位于：\n$$\nx_i = \\frac{i}{p}, \\quad i = 0, 1, \\ldots, p\n$$\n插值函数 $T_h(x)$ 是一个连续函数，在每个子区间 $[x_i, x_{i+1}]$ 上是线性的。对于 $x \\in [x_i, x_{i+1}]$，插值函数由下式给出：\n$$\nT_h(x) = T(x_i) \\frac{x_{i+1} - x}{h} + T(x_{i+1)} \\frac{x - x_i}{h}\n$$\n这定义了在整个域 $[0, 1]$ 上的插值函数。对于 $p=1$ 的特殊情况，我们有 $N=1$ 个单元。节点为 $x_0=0$ 和 $x_1=1$，插值函数是连接 $(0, T(0))$ 和 $(1, T(1))$ 的单条线段。这与 $p=1$ 阶的谱插值相同，其GLL节点也位于端点。因此，对于 $p=1$，误差 $E_p$ 和 $E_h$ 必须相等。\n\n#### 3. 误差量化\n\n两种方法的插值误差均使用 $L^2$-范数进行度量，定义为：\n$$\nE = \\left( \\int_{0}^{1} \\left( T(x) - T_{approx}(x) \\right)^2 \\, dx \\right)^{1/2}\n$$\n其中 $T_{approx}(x)$ 是谱插值 $T_p(x)$ 或分段线性插值 $T_h(x)$。\n\n对于 $h$-加密情况，该积分通过对每个单元的贡献求和来计算：\n$$\nE_h^2 = \\int_{0}^{1} \\left( T(x) - T_h(x) \\right)^2 \\, dx = \\sum_{i=0}^{p-1} \\int_{x_i}^{x_{i+1}} \\left( T(x) - T_h(x) \\right)^2 \\, dx\n$$\n这些积分没有简单的解析解，必须进行数值计算。我们采用高阶自适应求積程序，特别是 Gauss-Kronrod 方法，以确保数值积分误差与所测量的插值误差相比可以忽略不计。\n\n以下 Python 代码为指定的 $p \\in \\{1, 2, 5, 10, 20\\}$ 值实现了此过程，计算每种情况下的误差 $E_p$ 和 $E_h$。结果将展示对于光滑解析函数 $T(x) = \\exp(x)$，$p$-加密所具有的卓越收敛特性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import special, interpolate, integrate\n\ndef solve():\n    \"\"\"\n    Compares p-refinement and h-refinement for interpolating T(x)=exp(x)\n    on [0, 1] with an equal number of degrees of freedom.\n    \"\"\"\n\n    # Define the function to be interpolated.\n    def T(x):\n        return np.exp(x)\n\n    # The set of polynomial degrees to test.\n    test_cases = [1, 2, 5, 10, 20]\n    results = []\n\n    for p in test_cases:\n        # --- p-REFINEMENT (SPECTRAL METHOD) ---\n\n        # 1. Determine Gauss-Lobatto-Legendre (GLL) nodes for degree p.\n        # The interior GLL nodes are the roots of the derivative of the p-th\n        # Legendre polynomial, which are also roots of the Jacobi polynomial P_{p-1}^{(1,1)}.\n        if p == 1:\n            # For p=1, the GLL nodes are the endpoints.\n            gll_nodes_ref = np.array([-1.0, 1.0])\n        else:\n            # For p  1, compute interior nodes and add endpoints.\n            internal_nodes_ref, _ = special.roots_jacobi(p - 1, 1, 1)\n            gll_nodes_ref = np.concatenate(([-1.0], internal_nodes_ref, [1.0]))\n\n        # 2. Map nodes from reference interval [-1, 1] to physical interval [0, 1].\n        gll_nodes_phys = 0.5 * (gll_nodes_ref + 1.0)\n        \n        # 3. Evaluate the function at the GLL nodes.\n        y_p_values = T(gll_nodes_phys)\n\n        # 4. Construct the polynomial interpolant using barycentric interpolation.\n        interpolant_p = interpolate.BarycentricInterpolator(gll_nodes_phys, y_p_values)\n\n        # 5. Define the squared error function for the p-refined interpolant.\n        def squared_error_p(x):\n            return (T(x) - interpolant_p(x))**2\n\n        # 6. Compute the L2 error by integrating the squared error.\n        integral_p, _ = integrate.quad(squared_error_p, 0, 1)\n        E_p = np.sqrt(integral_p)\n\n        # --- h-REFINEMENT (PIECEWISE LINEAR FEM) ---\n\n        # 1. Define a uniform mesh with N=p elements, giving p+1 nodes.\n        N = p\n        h_nodes = np.linspace(0, 1, N + 1)\n\n        # 2. Evaluate the function at the uniform nodes.\n        y_h_values = T(h_nodes)\n\n        # 3. Compute the L2 error by summing integrals over each element.\n        total_squared_error_h = 0.0\n        for i in range(N):\n            x_i, x_i1 = h_nodes[i], h_nodes[i+1]\n            y_i, y_i1 = y_h_values[i], y_h_values[i+1]\n            h = x_i1 - x_i\n\n            # Define the linear interpolant and squared error on the element [x_i, x_i1].\n            # Using default arguments in lambda to capture loop variables by value.\n            def squared_error_h_element(x, _xi=x_i, _yi=y_i, _xi1=x_i1, _yi1=y_i1, _h=h):\n                linear_interpolant_val = _yi * (_xi1 - x) / _h + _yi1 * (x - _xi) / _h\n                return (T(x) - linear_interpolant_val)**2\n\n            integral_h_element, _ = integrate.quad(squared_error_h_element, x_i, x_i1)\n            total_squared_error_h += integral_h_element\n\n        E_h = np.sqrt(total_squared_error_h)\n        \n        # Store the results for this p value.\n        results.append(f\"[{p},{E_p},{E_h}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "高阶方法虽然功能强大，但也带来了独特的数值挑战。本练习聚焦于一个关键问题：随着多项式阶数 $p$ 的增加，刚度矩阵的条件数会恶化，导致数值求解困难。通过这个编码实践，您将量化此问题，并实施一种标准的对角缩放技术来改善系统的数值稳定性，这是开发稳健高阶求解器的一项关键技能。",
            "id": "3977350",
            "problem": "考虑由傅里叶定律控制的一维稳态热传导问题，其中热导率为常数且等于 $k=1$。在参考单元 $[-1,1]$ 上，该传导问题的弱形式产生一个单元刚度矩阵，该矩阵由应用于分层多项式基函数的双线性形式定义。设分层基由勒让德多项式构造，基函数为 $\\{\\phi_i(x)\\}_{i=1}^p$，其中 $\\phi_i(x)=P_i(x)$，$P_i(x)$ 表示经过归一化以满足 $P_i(1)=1$ 的 $i$ 次勒让德多项式。排除常数模式 $P_0(x)$ 是为了避免由梯度算子的零空间引起的奇异性。单元刚度矩阵的项为\n$$\nK_{ij} \\;=\\; \\int_{-1}^{1} \\phi_i'(x)\\,\\phi_j'(x)\\,\\mathrm{d}x,\n$$\n其中 $i,j \\in \\{1,2,\\dots,p\\}$。目标是分析增加 $p$ 对刚度矩阵条件数的影响，估计基于勒让德多项式的分层基的条件数随 $p$ 的增长情况，并提出一种对角缩放方法来减轻病态问题。\n\n从基本能量守恒和傅里叶定律出发，在参考单元上使用伽辽金法，推导刚度矩阵 $K$ 是如何从基函数的 $H^1$ 半范数产生的。然后，对于一组 $p$ 值，通过精确多项式求积（使用足够高阶的高斯-勒让德求积，以确保对次数最高为 $2p-2$ 的多项式的积分能被精确计算）来数值组装 $K$，并计算定义如下的 2-范数条件数 $\\kappa_2(K)$：\n$$\n\\kappa_2(K)\\;=\\;\\frac{\\lambda_{\\max}(K)}{\\lambda_{\\min}(K)},\n$$\n其中 $\\lambda_{\\max}(K)$ 和 $\\lambda_{\\min}(K)$ 分别是 $K$ 的最大和最小特征值。接下来，提出并实现一个对角缩放矩阵 $D$，其项为\n$$\nD_{ii}\\;=\\;\\int_{-1}^{1}\\left(\\phi_i'(x)\\right)^2\\,\\mathrm{d}x,\n$$\n并构造经过缩放的刚度矩阵\n$$\n\\widetilde{K}\\;=\\;D^{-1/2} K\\, D^{-1/2}.\n$$\n计算条件数 $\\kappa_2(\\widetilde{K})$ 并与 $\\kappa_2(K)$ 进行比较，讨论观察到的病态问题缓解效果。最后，使用针对给定 $p$ 值数值计算出的 $\\kappa_2(K)$，在经验模型中估计增长指数 $\\alpha$：\n$$\n\\kappa_2(K)\\;\\approx\\;C\\,p^{\\alpha},\n$$\n通过对 $\\log(\\kappa_2(K))$ 与 $\\log(p)$ 进行最小二乘线性回归来实现。\n\n所有计算都是无量纲的，不涉及物理单位。不出现角度。使用高斯-勒让德求积，其点数 $N_q$ 满足 $2N_q-1 \\ge 2p-2$，例如 $N_q=2p+5$。\n\n您的程序必须实现以下测试套件（每个测试用例是一个 $p$ 值）：\n- $p=1$ (边界情况，单个基函数),\n- $p=2$ (低阶情况),\n- $p=4$ (中等情况),\n- $p=8$ (理想情况),\n- $p=12$ (高阶情况).\n\n对于每个测试用例，您的程序必须计算并返回两个浮点数：未缩放的条件数 $\\kappa_2(K)$ 和经过缩放的条件数 $\\kappa_2(\\widetilde{K})$。处理完所有测试用例后，您的程序必须基于 $p \\in \\{2,4,8,12\\}$ 的未缩放条件数来估计并返回增长指数 $\\alpha$。最终输出必须是单行，包含一个用方括号括起来的逗号分隔列表，并严格遵循以下顺序：\n$$\n[\\kappa_2(K)\\text{ at }p=1,\\;\\kappa_2(\\widetilde{K})\\text{ at }p=1,\\;\\kappa_2(K)\\text{ at }p=2,\\;\\kappa_2(\\widetilde{K})\\text{ at }p=2,\\;\\kappa_2(K)\\text{ at }p=4,\\;\\kappa_2(\\widetilde{K})\\text{ at }p=4,\\;\\kappa_2(K)\\text{ at }p=8,\\;\\kappa_2(\\widetilde{K})\\text{ at }p=8,\\;\\kappa_2(K)\\text{ at }p=12,\\;\\kappa_2(\\widetilde{K})\\text{ at }p=12,\\;\\alpha].\n$$\n所有报告的值都必须是浮点数。程序必须是自包含的，不需要任何输入，并使用数值求积和特征值计算来精确地以规定格式生成结果。",
            "solution": "出发点是傅里叶热传导定律，该定律指出热通量与负温度梯度成正比。在稳态下，能量守恒导出了微分方程\n$$\n-\\frac{\\mathrm{d}}{\\mathrm{d}x}\\left(k \\frac{\\mathrm{d}T}{\\mathrm{d}x}\\right)\\;=\\;0,\n$$\n该方程在每个单元上成立，当 $k=1$ 为常数时，简化为\n$$\n-\\frac{\\mathrm{d}^2 T}{\\mathrm{d}x^2}\\;=\\;0.\n$$\n伽辽金法使用基函数来近似温度场 $\\displaystyle T(x)\\approx \\sum_{i=0}^{p} a_i \\phi_i(x)$。其弱形式涉及对基函数梯度的乘积进行积分，从而得到单元刚度矩阵\n$$\nK_{ij}\\;=\\;\\int_{-1}^{1} \\phi_i'(x)\\,\\phi_j'(x)\\,\\mathrm{d}x,\n$$\n该矩阵体现了在参考单元 $[-1,1]$ 上的 $H^1$ 半范数内积。\n\n对于基于勒让德的分层基，我们取 $\\phi_i(x)=P_i(x)$，$i\\in\\{1,2,\\dots,p\\}$，并排除常数模式 $P_0(x)$ 以防止由梯度算子核（零空间）引起的奇异性。矩阵 $K$ 是对称正定的，因为每个 $\\phi_i'(x)$ 都是非零的，并且该双线性形式在 $\\{P_1,\\dots,P_p\\}$ 的张成空间上是强制的。\n\n为了通过数值求积精确计算 $K$，我们注意到 $\\phi_i'(x)$ 是一个 $i-1$ 次多项式，被积函数 $\\phi_i'(x)\\phi_j'(x)$ 的次数最高为 $2p-2$。具有 $N_q$ 个点的高斯-勒让德求积可以精确地对次数最高为 $2N_q-1$ 的多项式进行积分；因此，任何满足 $2N_q-1\\ge 2p-2$ 的 $N_q$ 选择都能得到精确的计算结果。为保证稳健性，可以选择 $N_q=2p+5$。\n\n2-范数条件数定义为\n$$\n\\kappa_2(K)\\;=\\;\\frac{\\lambda_{\\max}(K)}{\\lambda_{\\min}(K)},\n$$\n其中 $\\lambda_{\\max}(K)$ 和 $\\lambda_{\\min}(K)$ 是极端特征值。由于 $K$ 是对称正定的，我们通过对称特征值求解器来计算这些值。\n\n病态程度随 $p$ 的增长而加剧，因为更高次的多项式具有更大的梯度，这会放大 $H^1$ 半范数。对于勒让德多项式，有一个有用的恒等式：\n$$\n\\int_{-1}^{1} (P_n'(x))^2\\,\\mathrm{d}x\\;=\\;n(n+1),\n$$\n对于大的 $n$，其渐进行为如同 $\\mathcal{O}(n^2)$。这表明 $K$ 的对角项（即梯度范数的平方）按 $p^2$ 的量级增长。因此矩阵的极端特征值之间的差距会迅速扩大，导致 $\\kappa_2(K)$ 的增长大致与 $p$ 的某个幂成正比。确切的增长率取决于勒让德多项式导数之间的非对角耦合，我们通过数值方法来确定这一点。\n\n为减轻病态问题，我们提出一种基于梯度范数对每个基函数进行归一化的对角缩放方法。定义对角缩放矩阵\n$$\nD\\;=\\;\\mathrm{diag}\\left(D_{11},D_{22},\\dots,D_{pp}\\right),\\quad D_{ii}\\;=\\;\\int_{-1}^{1}\\left(\\phi_i'(x)\\right)^2\\,\\mathrm{d}x.\n$$\n构造经过缩放的刚度矩阵\n$$\n\\widetilde{K}\\;=\\;D^{-1/2}\\,K\\,D^{-1/2}.\n$$\n这种缩放将每个模式的 $H^1$ 半范数归一化，使对角项等于 1，并减少了模式间的差异，从而改善了条件数。在谱特性方面，缩放后的矩阵是梯度模式的相关矩阵，其条件数通常比未缩放的刚度矩阵小得多。\n\n算法步骤：\n- 对于测试套件 $\\{1,2,4,8,12\\}$ 中的每个 $p$，将 $\\{\\phi_i\\}_{i=1}^{p}$ 构造为勒让德多项式 $P_i(x)$，在各高斯-勒让德点 $\\{x_k,w_k\\}_{k=1}^{N_q}$ 上计算它们的导数，并通过以下方式组装 $K$：\n$$\nK_{ij}\\;=\\;\\sum_{k=1}^{N_q} w_k\\,\\phi_i'(x_k)\\,\\phi_j'(x_k).\n$$\n- 通过 $K$ 的最大和最小特征值的比值计算 $\\kappa_2(K)$。\n- 构造 $D$，其中 $D_{ii}=K_{ii}$，构建 $\\widetilde{K}=D^{-1/2} K D^{-1/2}$，并类似地计算 $\\kappa_2(\\widetilde{K})$。\n- 对于 $p\\in\\{2,4,8,12\\}$，通过对 $\\log(\\kappa_2(K))$ 与 $\\log(p)$ 进行最小二乘拟合，来估计模型 $\\kappa_2(K)\\approx C p^{\\alpha}$ 中的增长指数 $\\alpha$：\n$$\n\\alpha\\;=\\;\\frac{\\sum (\\log p - \\overline{\\log p})(\\log \\kappa_2 - \\overline{\\log \\kappa_2})}{\\sum (\\log p - \\overline{\\log p})^2}.\n$$\n\n最终程序生成单行输出，其中包含按指定精确顺序排列的浮点数：\n$$\n[\\kappa_2(K)\\text{ at }p=1,\\;\\kappa_2(\\widetilde{K})\\text{ at }p=1,\\;\\kappa_2(K)\\text{ at }p=2,\\;\\kappa_2(\\widetilde{K})\\text{ at }p=2,\\;\\kappa_2(K)\\text{ at }p=4,\\;\\kappa_2(\\widetilde{K})\\text{ at }p=4,\\;\\kappa_2(K)\\text{ at }p=8,\\;\\kappa_2(\\widetilde{K})\\text{ at }p=8,\\;\\kappa_2(K)\\text{ at }p=12,\\;\\kappa_2(\\widetilde{K})\\text{ at }p=12,\\;\\alpha].\n$$\n该框架直接测试了 $p$-细化对刚度矩阵条件数的影响，并演示了植根于 $H^1$ 半范数的对角缩放如何缓解病态问题，这在计算热工学中设计 $p$-细化和组合 $h$-$p$-细化策略时至关重要。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom numpy.polynomial.legendre import Legendre, leggauss\n\ndef assemble_stiffness_legendre(p: int) - np.ndarray:\n    \"\"\"\n    Assemble the stiffness matrix K_ij = ∫_{-1}^{1} P_i'(x) P_j'(x) dx\n    for i,j = 1..p (excluding P_0).\n    Uses Gauss-Legendre quadrature with sufficient order for exactness.\n    \"\"\"\n    # Number of quadrature points: exactness up to degree 2p-2, choose a safe value\n    nquad = max(2 * p + 5, 8)\n    xq, wq = leggauss(nquad)\n\n    # Evaluate derivatives of Legendre polynomials at quadrature points\n    # Legendre.basis(n) gives polynomial with coefficient 1 for degree n (in Legendre basis)\n    deriv_vals = np.zeros((p, nquad))\n    for i in range(1, p + 1):\n        Pi = Legendre.basis(i)\n        dPi = Pi.deriv()\n        deriv_vals[i - 1, :] = dPi(xq)\n\n    # Assemble stiffness matrix via quadrature: K = dphi * W * dphi^T\n    # where W is diagonal of weights\n    K = deriv_vals @ (wq[:, None] * deriv_vals.T)\n    return K\n\ndef condition_number_2norm_spd(K: np.ndarray) - float:\n    \"\"\"\n    Compute the 2-norm condition number for a symmetric positive definite matrix:\n    cond2 = lambda_max / lambda_min\n    \"\"\"\n    # Use eigenvalues for symmetric matrix\n    evals = np.linalg.eigvalsh(K)\n    # Guard against tiny negative due to numerical roundoff\n    evals = np.maximum(evals, 0.0)\n    lam_min = np.min(evals)\n    lam_max = np.max(evals)\n    # If lam_min is zero (should not happen for our SPD), return inf\n    if lam_min == 0.0:\n        return float('inf')\n    return float(lam_max / lam_min)\n\ndef diagonal_scaling(K: np.ndarray) - np.ndarray:\n    \"\"\"\n    Return the scaled stiffness matrix Ktilde = D^{-1/2} K D^{-1/2},\n    with D = diag(K_ii) (gradient L2 norms of basis functions).\n    \"\"\"\n    diag_entries = np.diag(K).copy()\n    # Prevent division by zero: add tiny perturbation (shouldn't be needed for i=1)\n    diag_entries = np.where(diag_entries  0.0, diag_entries, 1e-30)\n    inv_sqrt = 1.0 / np.sqrt(diag_entries)\n    # Scale: Ktilde_{ij} = K_{ij} / sqrt(D_ii D_jj)\n    Ktilde = (inv_sqrt[:, None] * K) * inv_sqrt[None, :]\n    return Ktilde\n\ndef estimate_alpha(ps: np.ndarray, kappas: np.ndarray) - float:\n    \"\"\"\n    Estimate alpha in kappa ~ C * p^alpha via least-squares fit on logs.\n    \"\"\"\n    logp = np.log(ps.astype(float))\n    logk = np.log(kappas.astype(float))\n    # Linear regression slope\n    mean_logp = np.mean(logp)\n    mean_logk = np.mean(logk)\n    num = np.sum((logp - mean_logp) * (logk - mean_logk))\n    den = np.sum((logp - mean_logp) ** 2)\n    if den == 0.0:\n        return 0.0\n    return float(num / den)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_ps = [1, 2, 4, 8, 12]\n\n    unscaled = []\n    scaled = []\n    for p in test_ps:\n        K = assemble_stiffness_legendre(p)\n        kappa = condition_number_2norm_spd(K)\n        Ktilde = diagonal_scaling(K)\n        kappa_scaled = condition_number_2norm_spd(Ktilde)\n        unscaled.append(kappa)\n        scaled.append(kappa_scaled)\n\n    # Estimate alpha using unscaled condition numbers for p in {2,4,8,12}\n    ps_for_fit = np.array([2, 4, 8, 12], dtype=float)\n    kappas_for_fit = np.array([unscaled[test_ps.index(int(pp))] for pp in ps_for_fit], dtype=float)\n    alpha = estimate_alpha(ps_for_fit, kappas_for_fit)\n\n    # Aggregate results: [kappa_p1, kappa_scaled_p1, kappa_p2, kappa_scaled_p2, ... , alpha]\n    results = []\n    for i in range(len(test_ps)):\n        results.append(unscaled[i])\n        results.append(scaled[i])\n    results.append(alpha)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}