{
    "hands_on_practices": [
        {
            "introduction": "我们对糊状区的建模探索始于最基本的情景：局部热力学平衡下的凝固过程。本练习旨在推导杠杆定律，这是将二元合金糊状区内固相分数与温度进行定量关联的基石。掌握此推导过程  将巩固您对相图如何在理想化的缓慢冷却条件下控制微观结构演变的理解。",
            "id": "3974905",
            "problem": "一种初始溶质浓度为 $C_0$ 的稀二元合金，在固液界面处满足局部热力学平衡的条件下发生凝固。假设在两相区内的任何温度 $T$ 下，代表性体积内的液相和固相各自成分均匀，并通过平衡相图上的一条连接线相连。在稀溶液范围内，平衡相图可局部线性化为\n$$T = T_M + m_L\\,C_L,\\qquad T = T_M + m_S\\,C_S,$$\n其中 $T_M$ 是纯溶剂的熔化温度，$m_L$ 和 $m_S$ 分别是液相线和固相线的恒定斜率，且 $m_L  0$ 和 $m_S  0$，$C_L$ 和 $C_S$ 是在温度 $T$ 时液相和固相中的溶质浓度。假设宏观偏析可以忽略不计，从而在整个凝固过程中，体积平均溶质浓度保持为 $C_0$。\n\n仅从代表性两相体积内的溶质守恒和上述局部平衡连接线关系出发，推导固相分数 $f_s$ 作为 $T$、$C_0$、$T_M$、$m_L$ 和 $m_S$ 的显式函数的封闭形式表达式。该表达式在对应于 $C_0$ 的液相线和固相线温度之间的两相区间内有效。将 $f_s(T;C_0,T_M,m_L,m_S)$ 的最终结果表示为单一的简化解析表达式。最终答案必须以无量纲分数（而非百分比）的形式给出。不需要进行数值计算。",
            "solution": "此问题旨在基于材料科学的热力学原理，推导凝固过程中的杠杆定律。固相分数 $f_s$ 作为温度 $T$ 的函数的推导，从代表性两相体积内的溶质守恒原理开始。\n\n根据问题陈述，在整个凝固过程中，体积平均溶质浓度保持为初始浓度 $C_0$ 不变，这代表了一个封闭系统。一个代表性体积内的总溶质是固相中的溶质和液相中的溶质之和。设 $f_s$ 为固相的质量分数，$f_l$ 为液相的质量分数。由于系统仅由这两相组成，它们的质量分数之和必须为1：\n$$f_s + f_l = 1$$\n总溶质浓度 $C_0$ 是固相浓度 $C_S$ 和液相浓度 $C_L$ 的加权平均值：\n$$C_0 = f_s C_S + f_l C_L$$\n问题假设在代表性体积内，各相的成分是均匀的。将 $f_l = 1 - f_s$ 代入守恒方程，得到：\n$$C_0 = f_s C_S + (1 - f_s) C_L$$\n$$C_0 = f_s C_S + C_L - f_s C_L$$\n这个方程可以重新整理以求解固相分数 $f_s$：\n$$f_s (C_L - C_S) = C_L - C_0$$\n$$f_s = \\frac{C_L - C_0}{C_L - C_S}$$\n这个表达式被称为杠杆定律。\n\n下一步是使用所提供的线性化相图关系，将浓度 $C_L$ 和 $C_S$ 表示为温度 $T$ 的函数：\n$$T = T_M + m_L C_L$$\n$$T = T_M + m_S C_S$$\n其中 $T_M$ 是纯溶剂的熔点，$m_L$ 和 $m_S$ 分别是液相线和固相线的恒定斜率。我们可以重新整理这些方程，以求解在两相区内给定温度 $T$ 下的 $C_L$ 和 $C_S$：\n$$C_L(T) = \\frac{T - T_M}{m_L}$$\n$$C_S(T) = \\frac{T - T_M}{m_S}$$\n现在，我们将 $C_L$ 和 $C_S$ 的这些表达式代入 $f_s$ 的杠杆定律方程中：\n$$f_s(T) = \\frac{\\frac{T - T_M}{m_L} - C_0}{\\frac{T - T_M}{m_L} - \\frac{T - T_M}{m_S}}$$\n为简化此表达式，我们首先可以合并分母中的各项：\n$$\\frac{T - T_M}{m_L} - \\frac{T - T_M}{m_S} = (T - T_M) \\left( \\frac{1}{m_L} - \\frac{1}{m_S} \\right) = (T - T_M) \\left( \\frac{m_S - m_L}{m_L m_S} \\right)$$\n分子可以写成：\n$$\\frac{T - T_M}{m_L} - C_0 = \\frac{T - T_M - m_L C_0}{m_L}$$\n将这些代回 $f_s(T)$ 的表达式中：\n$$f_s(T) = \\frac{\\frac{T - T_M - m_L C_0}{m_L}}{(T - T_M) \\left( \\frac{m_S - m_L}{m_L m_S} \\right)}$$\n$$f_s(T) = \\left( \\frac{T - T_M - m_L C_0}{m_L} \\right) \\left( \\frac{m_L m_S}{(T - T_M)(m_S - m_L)} \\right)$$\n项 $m_L$ 被消去，得到：\n$$f_s(T) = \\frac{m_S (T - T_M - m_L C_0)}{(m_S - m_L)(T - T_M)}$$\n这是一个有效的表达式，但为了更清晰，可以进一步简化。我们可以将包含 $T$ 的项与常数参数分开：\n$$f_s(T) = \\left( \\frac{m_S}{m_S - m_L} \\right) \\left( \\frac{T - T_M - m_L C_0}{T - T_M} \\right)$$\n括号中的第二项可以分成两部分：\n$$f_s(T) = \\left( \\frac{m_S}{m_S - m_L} \\right) \\left( \\frac{T - T_M}{T - T_M} - \\frac{m_L C_0}{T - T_M} \\right)$$\n这可以简化为固相分数作为温度和给定参数的函数的最终封闭形式表达式：\n$$f_s(T) = \\frac{m_S}{m_S - m_L} \\left( 1 - \\frac{m_L C_0}{T - T_M} \\right)$$\n这个方程在两相（糊状）区内的温度 $T$ 范围内有效，该区域的边界是液相线温度 $T_L = T_M + m_L C_0$（此时 $f_s=0$）和固相线温度 $T_S = T_M + m_S C_0$（在杠杆定律的平衡条件下，此时 $f_s=1$）。",
            "answer": "$$\\boxed{\\frac{m_S}{m_S - m_L} \\left( 1 - \\frac{m_L C_0}{T - T_M} \\right)}$$"
        },
        {
            "introduction": "现实世界中的凝固过程很少能达到完全的平衡状态。下一个练习将引入 Scheil-Gulliver 模型，该模型考虑了固相中溶质扩散有限这一关键的非平衡效应。通过推导 Scheil 方程 ，您将了解溶质在凝固前沿如何被排斥，从而使剩余液相的成分富集，并相应地降低局部液相线温度——这是微观偏析背后的一个关键机制。",
            "id": "3974918",
            "problem": "考虑一种正在进行定向凝固的二元合金，其糊状区跨越了固相线和液相线之间的温度范围。假设在固液界面处存在局部热力学平衡，固相中的溶质扩散可以忽略不计，而液相则完全混合。这些是 Scheil 模型的经典假设。设溶质分配系数定义为 $k = C_{S}/C_{L}$，其中 $C_{S}$ 是在界面处形成的固相中的瞬时溶质质量分数，$C_{L}$ 是相邻液相中的瞬时溶质质量分数。设初始整体溶质质量分数为 $C_{0}$，并用 $f_{S}$ 表示固相分数。\n\n从糊状区中一个无穷小控制体积内的溶质守恒以及分配系数的定义出发，根据 Scheil 假设，推导剩余液相中溶质富集浓度 $C_{L}$ 作为固相分数 $f_{S}$ 函数的表达式。然后，使用合金成分附近的线性化相图，通过液相线关系式 $T_{L}(C) = T_{L}^{0} + m_{L}\\,C$ 来量化这种富集如何改变局部液相线温度，其中 $T_{L}^{0}$ 是纯溶剂的液相线温度，$m_{L}$ 是液相线相对于溶质质量分数 $C$ 的（恒定）斜率。\n\n使用以下参数值：$k = 0.3$，$C_{0} = 0.05$（无量纲溶质质量分数），$T_{L}^{0} = 933\\,\\mathrm{K}$，$m_{L} = -250\\,\\mathrm{K}$ 每单位溶质质量分数，并在 $f_{S} = 0.8$ 处计算结果。计算由富集引起的液相线温度 $T_{L}(C_{L}(f_S))$，并报告该最终温度。将您的答案四舍五入到四位有效数字，并以 $\\mathrm{K}$ 为单位表示。",
            "solution": "这是一个基于经典 Scheil-Gulliver 模型的、在材料科学与凝固加工领域中的良定问题。所有必要的假设、定义和数据均已提供，并且它们在科学上是合理且一致的。\n\n第一个任务是推导 Scheil 方程，该方程描述了液相中的溶质浓度 $C_{L}$ 作为固相分数 $f_{S}$ 的函数。该推导基于一个微分控制体积上的溶质质量平衡，并遵循固相中无扩散、液相中完全混合以及界面处局部平衡的假设。\n\n让我们考虑一个单位质量的系统。总溶质浓度为 $C_{0}$。随着凝固的进行，无穷小质量的固相 $df_{S}$ 从液相中形成。在任何给定时刻，剩余液相的质量为 $(1 - f_{S})$。液相中溶质的总量为 $C_{L}(1 - f_{S})$。\n\n随着凝固的进行，液相中溶质含量的变化由微分 $d\\left(C_{L}(1 - f_{S})\\right)$ 给出。使用微分的乘法法则，我们有：\n$$d\\left(C_{L}(1 - f_{S})\\right) = (1 - f_{S})dC_{L} + C_{L}d(1 - f_{S}) = (1 - f_{S})dC_{L} - C_{L}df_{S}$$\n\n这种溶质含量的变化必须等于离开液相以形成新固相的溶质的量。新形成的固相质量为 $df_S$。该固相的浓度为 $C_S$。因此，从液相中移除的溶质质量为 $C_{S}df_{S}$。液相中的溶质含量因此减少了此数量。这给出了溶质平衡方程：\n$$d\\left(C_{L}(1 - f_{S})\\right) = -C_{S}df_{S}$$\n\n将两个关于液相中溶质含量变化的表达式相等，我们得到：\n$$(1 - f_{S})dC_{L} - C_{L}df_{S} = -C_{S}df_{S}$$\n\n问题陈述，界面处维持局部热力学平衡，这使我们可以使用分配系数 $k = C_{S}/C_{L}$。将 $C_{S} = k C_{L}$ 代入平衡方程：\n$$(1 - f_{S})dC_{L} - C_{L}df_{S} = -kC_{L}df_{S}$$\n\n我们现在可以重新整理方程以分离变量 $C_{L}$ 和 $f_{S}$：\n$$(1 - f_{S})dC_{L} = (C_{L} - kC_{L})df_{S}$$\n$$(1 - f_{S})dC_{L} = (1 - k)C_{L}df_{S}$$\n$$\\frac{dC_{L}}{C_{L}} = (1 - k)\\frac{df_{S}}{1 - f_{S}}$$\n\n为了找到 $C_{L}$ 和 $f_{S}$ 之间的关系，我们对这个微分方程进行积分。积分从凝固开始时（此时 $f_{S}=0$ 且液相浓度为初始整体浓度 $C_{L}=C_{0}$）进行到一个由固相分数 $f_{S}$ 和相应液相浓度 $C_{L}$ 定义的任意状态。\n$$\\int_{C_{0}}^{C_{L}} \\frac{dC'_{L}}{C'_{L}} = \\int_{0}^{f_{S}} (1 - k)\\frac{df'_{S}}{1 - f'_{S}}$$\n\n方程左侧积分为：\n$$\\left[ \\ln(C'_{L}) \\right]_{C_{0}}^{C_{L}} = \\ln(C_{L}) - \\ln(C_{0}) = \\ln\\left(\\frac{C_{L}}{C_{0}}\\right)$$\n\n方程右侧积分为：\n$$(1 - k) \\int_{0}^{f_{S}} \\frac{df'_{S}}{1 - f'_{S}} = (1 - k) \\left[ -\\ln(1 - f'_{S}) \\right]_{0}^{f_{S}} = (1 - k) \\left( -\\ln(1 - f_{S}) - (-\\ln(1)) \\right) = -(1 - k)\\ln(1 - f_{S})$$\n这可以重写为 $(k - 1)\\ln(1 - f_{S})$。\n\n将两边的积分结果相等：\n$$\\ln\\left(\\frac{C_{L}}{C_{0}}\\right) = (k - 1)\\ln(1 - f_{S})$$\n\n对两边取指数，我们得到了 $C_{L}$ 作为 $f_{S}$ 函数的最终表达式，即 Scheil 方程：\n$$C_{L}(f_{S}) = C_{0}(1 - f_{S})^{k-1}$$\n\n第二个任务是使用这个强大的结果来计算在特定固相分数下的液相线温度。我们给定的参数值如下：\n- 分配系数：$k = 0.3$\n- 初始溶质质量分数：$C_{0} = 0.05$\n- 用于评估的固相分数：$f_{S} = 0.8$\n- 纯溶剂的液相线温度：$T_{L}^{0} = 933\\,\\mathrm{K}$\n- 液相线斜率：$m_{L} = -250\\,\\mathrm{K}$\n\n首先，我们计算当固相分数 $f_{S}$ 达到 $0.8$ 时，液相中富集的溶质浓度 $C_{L}$：\n$$C_{L}(0.8) = C_{0}(1 - 0.8)^{k-1} = 0.05(0.2)^{0.3-1} = 0.05(0.2)^{-0.7}$$\n$$C_{L}(0.8) \\approx 0.05 \\times 3.085235 = 0.15426175$$\n\n接下来，我们使用线性化液相线方程 $T_{L}(C) = T_{L}^{0} + m_{L}\\,C$ 来找到与此富集液相浓度相对应的液相线温度。该温度代表了当 $f_S = 0.8$ 时固液界面处的平衡温度。\n$$T_{L}(C_{L}(0.8)) = T_{L}^{0} + m_{L} \\times C_{L}(0.8)$$\n$$T_{L} = 933\\,\\mathrm{K} + (-250\\,\\mathrm{K}) \\times 0.15426175$$\n$$T_{L} = 933\\,\\mathrm{K} - 38.5654375\\,\\mathrm{K}$$\n$$T_{L} = 894.4345625\\,\\mathrm{K}$$\n\n问题要求最终答案四舍五入到四位有效数字。\n计算出的温度是 $894.4345625\\,\\mathrm{K}$。前四位有效数字是 $8$、$9$、$4$ 和 $4$。第五位数字是 $3$，小于 $5$，所以我们向下舍入。\n最终结果是 $894.4\\,\\mathrm{K}$。",
            "answer": "$$\\boxed{894.4}$$"
        },
        {
            "introduction": "在探索了理论基础之后，我们现在将理论与计算实践联系起来。这项综合性练习将指导您实现并比较两种最常见的用于凝固模拟的固定网格数值方法：有效热容法（EHC）和焓法。通过将您的代码与经典的 Stefan 问题的解析解进行基准测试 ，您将亲身体验数值模拟中的挑战，例如如何保证能量守恒和处理热容的剧烈变化，并理解这些基础算法在实际应用中的优劣权衡。",
            "id": "3974910",
            "problem": "您需要在一个具有已知尖锐界面 Stefan 解的半无限域基准问题中，实现并比较两种用于处理带糊状区的一维凝固问题的固定网格方法。这两种方法是：有效热容法（EHC）和焓法。从控制能量守恒定律和傅里叶热传导定律出发，推导并实现离散算法，模拟到指定的最终时间，从每种方法中提取界面位置的数值估计，并根据 Stefan 解的解析界面位置计算绝对误差。所有界面位置误差均以米为单位表示。\n\n物理设置为半无限域中的一维热传导，空间坐标为 $x \\ge 0$，初始温度为熔化温度，边界 $x=0$ 突然冷却至低于熔点的温度。使用以下材料属性和条件，这些属性和条件是金属的典型代表：\n\n- 密度 $ \\rho = 2700\\,\\mathrm{kg/m^3} $。\n- 热导率 $ k = 200\\,\\mathrm{W/(m\\,K)} $。\n- 比热 $ c = 900\\,\\mathrm{J/(kg\\,K)} $。\n- 熔化潜热 $ L = 3.97\\times 10^{5}\\,\\mathrm{J/kg} $。\n- 熔化温度 $ T_m = 933\\,\\mathrm{K} $。\n- 边界（冷却）温度，位于 $ x=0 $: $ T_s = 800\\,\\mathrm{K} $。\n- 初始温度 $ T(x,0) = T_m $，对于所有 $ x \\ge 0 $。\n\n通过一个足够大的有限长度 $ L_x = 0.1\\,\\mathrm{m} $ 来模拟半无限域，并使用远场狄利克雷边界条件 $ T(L_x,t) = T_m $ 对所有 $ t \\ge 0 $ 成立。空间网格是均匀的，间距 $ \\Delta x $ 如下文测试套件中所指定，时间积分为显式。对于所有测试用例，设模拟最终时间为 $ t_\\mathrm{final} = 5\\,\\mathrm{s} $。使用均匀的时间步长，该步长受温度方程在有效热容等于显热容区域的标准显式稳定性判据约束：\n$$\n\\Delta t \\le \\frac{\\Delta x^2}{2\\,\\alpha_\\mathrm{max}}, \\quad \\alpha_\\mathrm{max} = \\frac{k}{\\rho\\,c}.\n$$\n在您的实现中，设置 $ \\Delta t = 0.9\\,\\Delta x^2/(2\\,\\alpha_\\mathrm{max}) $，并在需要时通过缩短最后一步来精确达到 $ t_\\mathrm{final} $。\n\n通过一个以熔化温度为中心、宽度为 $ \\Delta T $ 的有限温度区间引入糊状区正则化。定义固相线和液相线温度为 $ T_\\mathrm{sol} = T_m - \\Delta T / 2 $ 和 $ T_\\mathrm{liq} = T_m + \\Delta T / 2 $。液相分数 $ f_\\ell(T) $ 建模为：\n$$\nf_\\ell(T) = \n\\begin{cases}\n0,  T \\le T_\\mathrm{sol},\\\\\n\\frac{T - T_\\mathrm{sol}}{\\Delta T},  T_\\mathrm{sol}  T  T_\\mathrm{liq},\\\\\n1,  T \\ge T_\\mathrm{liq}.\n\\end{cases}\n$$\n\n对于有效热容法，使用以下方程演化温度：\n$$\n\\rho\\,c_\\mathrm{eff}(T)\\,\\frac{\\partial T}{\\partial t} = k\\,\\frac{\\partial^2 T}{\\partial x^2},\n$$\n其中\n$$\nc_\\mathrm{eff}(T) = c + \\frac{L}{\\Delta T} \\quad \\text{if } T_\\mathrm{sol}  T  T_\\mathrm{liq}, \\quad \\text{and } c_\\mathrm{eff}(T) = c \\text{ otherwise.}\n$$\n对空间二阶导数使用二阶中心差分，对时间使用向前欧拉法。在每个时间步施加狄利克雷边界条件 $ T(0,t) = T_s $ 和 $ T(L_x,t) = T_m $。\n\n对于焓法，使用以下方程演化体积焓 $ H(T) $：\n$$\n\\frac{\\partial H}{\\partial t} = k\\,\\frac{\\partial^2 T}{\\partial x^2}, \\quad H(T) = \\rho\\,c\\,T + \\rho\\,L\\,f_\\ell(T).\n$$\n在每个时间步，通过 $ H(T) $ 定义所隐含的分段线性逆关系从 $ H $ 计算 $ T $。对 $ H $ 使用相同的离散空间算子和向前欧拉推进。通过在每个时间步设置 $ T(0,t) = T_s $ 和 $ T(L_x,t) = T_m $ 来强制执行狄利克雷边界条件，并相应地更新边界焓值 $ H(0,t) = H(T_s) $ 和 $ H(L_x,t) = H(T_m) $。\n\n对于此配置，解析尖锐界面单相 Stefan 解给出的界面位置 $ s(t) $ 为：\n$$\ns(t) = 2\\,\\lambda\\,\\sqrt{\\alpha\\,t}, \\quad \\alpha = \\frac{k}{\\rho\\,c},\n$$\n其中参数 $ \\lambda $ 是解一个超越方程得到的，该方程涉及 Stefan 数 $ \\mathrm{Ste} $ 和互补误差函数 (CERF, 通常写作 $ \\operatorname{erfc} $):\n$$\n\\mathrm{Ste} = \\frac{c\\,(T_m - T_s)}{L}, \\quad \\mathrm{Ste} = \\sqrt{\\pi}\\,\\lambda\\,\\exp(\\lambda^2)\\,\\operatorname{erfc}(\\lambda).\n$$\n对给定的参数数值计算 $ \\lambda $，然后计算 $ s(t_\\mathrm{final}) $。\n\n在 $ t_\\mathrm{final} $ 时刻，通过找到温度 $ T $ 首次穿过 $ T_m $ 的位置，并在网格点之间进行线性插值，来从每种方法中提取数值界面位置 $ s_\\mathrm{num} $。为每种方法计算绝对误差 $ |s_\\mathrm{num} - s(t_\\mathrm{final})| $，单位为米。\n\n测试套件：\n提供三个测试用例，用于探究数值行为的不同方面：\n- 用例1（基准分辨率，中等糊状区宽度）：$ \\Delta x = 5\\times 10^{-4}\\,\\mathrm{m} $, $ \\Delta T = 10\\,\\mathrm{K} $。\n- 用例2（较粗网格，尖锐界面极限）：$ \\Delta x = 10^{-3}\\,\\mathrm{m} $, $ \\Delta T = 1\\,\\mathrm{K} $。\n- 用例3（基准分辨率，宽糊状区宽度）：$ \\Delta x = 5\\times 10^{-4}\\,\\mathrm{m} $, $ \\Delta T = 50\\,\\mathrm{K} $。\n\n数值输出规范：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果。每个测试用例的结果应为一个双元素列表 $[e_\\mathrm{EHC}, e_\\mathrm{ENT}]$，其中包含以米为单位的浮点数，分别表示有效热容法和焓法在 $ t_\\mathrm{final} $ 时的绝对误差。对于三个测试用例，最终输出必须采用以下形式：\n$$\n\\text{print } \\big[ [e_{\\mathrm{EHC},1},e_{\\mathrm{ENT},1}], [e_{\\mathrm{EHC},2},e_{\\mathrm{ENT},2}], [e_{\\mathrm{EHC},3},e_{\\mathrm{ENT},3}] \\big].\n$$",
            "solution": "该问题要求实现和比较两种用于一维凝固问题的固定网格数值方法：有效热容法（EHC）和焓法。凝固前沿位置的数值结果将与已知的尖锐界面 Stefan 问题的解析解进行验证。\n\n基本控制原理是能量守恒。对于一个有热传导但无内部热源的系统，能量方程由下式给出：\n$$\n\\frac{\\partial (\\rho h)}{\\partial t} = \\nabla \\cdot (k \\nabla T)\n$$\n其中 $\\rho$ 是密度，$h$ 是比焓，$t$ 是时间，$k$ 是热导率，$T$ 是温度。比焓 $h$ 是温度和相的函数。对于经历固-液相变的物质，其定义为：\n$$\nh(T) = \\int_{T_\\mathrm{ref}}^T c(T') \\, dT' + L f_{\\ell}(T)\n$$\n其中 $c$ 是比热，$L$ 是熔化潜热，$f_{\\ell}(T)$ 是液相分数，其值从 0（固相）到 1（液相）变化。对于这个问题，我们假设每个相的材料属性是恒定的，因此积分简化为 $c(T-T_\\mathrm{ref})$。体积焓为 $H = \\rho h$。\n\n该问题使用糊状区模型，其中相变发生在从固相线温度 $T_\\mathrm{sol} = T_m - \\Delta T / 2$ 到液相线温度 $T_\\mathrm{liq} = T_m + \\Delta T / 2$ 的有限温度区间 $\\Delta T$ 内。在此区间内，液相分数 $f_{\\ell}(T)$ 被给定为温度的线性函数。\n\n这两种数值方法源于对能量方程中焓项的不同处理方式。\n\n**有效热容法（EHC）**\n\n此方法以温度为变量明确地重构能量方程。使用链式法则，焓的时间导数表示为：\n$$\n\\frac{\\partial h}{\\partial t} = \\frac{\\partial h}{\\partial T} \\frac{\\partial T}{\\partial t} = c_\\mathrm{eff}(T) \\frac{\\partial T}{\\partial t}\n$$\n其中 $c_\\mathrm{eff}(T) = \\frac{\\partial h}{\\partial T}$ 是有效热容。根据 $h(T)$ 的定义，我们推导出 $c_\\mathrm{eff}(T)$：\n$$\nc_\\mathrm{eff}(T) = \\frac{\\partial}{\\partial T} \\left( c T + L f_{\\ell}(T) \\right) = c + L \\frac{df_{\\ell}}{dT}\n$$\n使用为 $f_{\\ell}(T)$ 指定的线性形式，导数 $\\frac{df_{\\ell}}{dT}$ 在糊状区内（$T_\\mathrm{sol}  T  T_\\mathrm{liq}$）为 $1/\\Delta T$，在其他区域为 $0$。这导致了问题陈述中给出的分段定义。因此，EHC 方法的控制方程为：\n$$\n\\rho c_\\mathrm{eff}(T) \\frac{\\partial T}{\\partial t} = k \\frac{\\partial^2 T}{\\partial x^2}\n$$\n这是一个非线性热方程，因为系数 $c_\\mathrm{eff}$ 依赖于解 $T$。\n\n为了进行数值求解，我们在空间上使用二阶中心差分进行离散，在时间上使用向前欧拉法。设 $T_i^n$ 为网格点 $x_i = i \\Delta x$ 和时间 $t_n = n \\Delta t$ 处的温度。离散更新方程为：\n$$\n\\rho c_\\mathrm{eff}(T_i^n) \\frac{T_i^{n+1} - T_i^n}{\\Delta t} = k \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{\\Delta x^2}\n$$\n求解下一个时间步的温度 $T_i^{n+1}$：\n$$\nT_i^{n+1} = T_i^n + \\frac{k \\Delta t}{\\rho c_\\mathrm{eff}(T_i^n) \\Delta x^2} (T_{i+1}^n - 2T_i^n + T_{i-1}^n)\n$$\nEHC 方法的算法包括初始化温度场，然后迭代执行：\n1. 对温度施加狄利克雷边界条件。\n2. 在每个内部网格点 $i$，根据当前温度计算 $c_\\mathrm{eff}(T_i^n)$。\n3. 使用显式更新公式计算新温度 $T_i^{n+1}$。\n4. 前进到下一个时间步。\n\n**焓法**\n\n此方法保留体积焓 $H = \\rho h$ 作为主要演化变量。控制方程为：\n$$\n\\frac{\\partial H}{\\partial t} = k \\frac{\\partial^2 T}{\\partial x^2}\n$$\n$H$ 和温度 $T$ 之间的关系由 $H(T) = \\rho c T + \\rho L f_{\\ell}(T)$ 给出。该方法的关键特征是时间演化针对焓，而空间算子（拉普拉斯算子）需要温度。这就需要在每个时间步中进行 $H$ 和 $T$ 之间的转换。\n\n离散化方程为：\n$$\n\\frac{H_i^{n+1} - H_i^n}{\\Delta t} = k \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{\\Delta x^2}\n$$\n焓的更新方程为：\n$$\nH_i^{n+1} = H_i^n + \\frac{k \\Delta t}{\\Delta x^2} (T_{i+1}^n - 2T_i^n + T_{i-1}^n)\n$$\n为了获得拉普拉斯算子所需的温度场 $T^n$，我们必须对 $H(T)$ 关系进行求逆。给定 $f_{\\ell}(T)$ 的分段线性定义，$H(T)$ 函数也是分段线性的且单调递增，使其逆函数 $T(H)$ 是单值的。该关系为：\n- 如果 $H \\le H_\\mathrm{sol} = \\rho c T_\\mathrm{sol}$：$T = H / (\\rho c)$\n- 如果 $H_\\mathrm{sol}  H  H_\\mathrm{liq} = \\rho c T_\\mathrm{liq} + \\rho L$：$T = \\frac{H + \\rho L \\frac{T_\\mathrm{sol}}{\\Delta T}}{ \\rho c + \\frac{\\rho L}{\\Delta T} }$\n- 如果 $H \\ge H_\\mathrm{liq}$：$T = (H - \\rho L) / (\\rho c)$\n\n焓法的算法如下：\n1. 初始化温度场 $T^0$ 并计算相应的初始焓场 $H^0 = H(T^0)$。\n2. 迭代执行：\n   a. 对温度 $T^n$ 施加狄利克雷边界条件。更新边界处的焓值 $H_0^n = H(T_0^n)$ 和 $H_{N-1}^n = H(T_{N-1}^n)$。\n   b. 使用显式更新公式为内部点计算新的焓场 $H^{n+1}$，该公式使用上一步的温度 $T^n$。\n   c. 通过对新的焓值求逆来更新内部温度 $T_i^{n+1}$：$T_i^{n+1} = T(H_i^{n+1})$。\n   d. 前进到下一个时间步。\n\n**解析解：单相 Stefan 问题**\n\n对于尖锐界面（$\\Delta T \\to 0$）和初始温度为熔化温度的半无限域情况，存在解析解。固-液界面的位置 $s(t)$ 由下式给出：\n$$\ns(t) = 2 \\lambda \\sqrt{\\alpha t}\n$$\n其中 $\\alpha = k/(\\rho c)$ 是固相的热扩散率。常数 $\\lambda$ 通过求解一个在移动界面上强制能量平衡的超越方程来确定：\n$$\n\\mathrm{Ste} = \\sqrt{\\pi} \\lambda e^{\\lambda^2} \\mathrm{erfc}(\\lambda)\n$$\nStefan 数 $\\mathrm{Ste} = \\frac{c(T_m - T_s)}{L}$ 是一个无量纲参数，表示显热与潜热之比。互补误差函数是 $\\mathrm{erfc}(\\lambda)$。该方程必须通过数值方法求解 $\\lambda$。得到的 $s(t_\\mathrm{final})$ 作为基准，用于与数值解进行比较。\n\n**数值实现细节**\n\n模拟域长度为 $L_x = 0.1\\,\\mathrm{m}$，使用均匀网格间距 $\\Delta x$ 进行离散。时间步长 $\\Delta t$ 的选择满足纯固相/液相的显式稳定性判据，$\\Delta t = 0.9 \\frac{\\Delta x^2}{2\\alpha}$，其中 $\\alpha = k/(\\rho c)$。这个选择是保守的，并确保了整个区域的稳定性，因为糊状区中的有效扩散率较低。模拟运行至最终时间 $t_\\mathrm{final} = 5\\,\\mathrm{s}$。\n\n数值界面位置 $s_\\mathrm{num}$ 是从最终温度分布 $T(x, t_\\mathrm{final})$ 中提取的。我们从冷却边界开始找到第一个满足 $T_i \\ge T_m$ 的网格索引 $i$。界面位于网格点 $x_{i-1}$ 和 $x_i$ 之间。使用线性插值来估计其精确位置：\n$$\ns_\\mathrm{num} = x_{i-1} + (x_i - x_{i-1}) \\frac{T_m - T_{i-1}}{T_i - T_{i-1}}\n$$\n最后，对每种方法和测试用例，绝对误差计算为 $|s_\\mathrm{num} - s(t_\\mathrm{final})|$。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import erfc\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Implements and compares Effective Heat Capacity and Enthalpy methods\n    for a 1D solidification problem.\n    \"\"\"\n\n    # --- Material Properties and Conditions ---\n    rho = 2700.0  # Density, kg/m^3\n    k = 200.0   # Thermal conductivity, W/(m K)\n    c = 900.0   # Specific heat, J/(kg K)\n    L = 3.97e5  # Latent heat of fusion, J/kg\n    T_m = 933.0 # Melting temperature, K\n    T_s = 800.0 # Boundary cooling temperature, K\n    \n    # --- Domain and Simulation Parameters ---\n    L_x = 0.1     # Domain length, m\n    t_final = 5.0 # Final simulation time, s\n\n    # --- Analytical Solution ---\n    Ste = c * (T_m - T_s) / L\n    alpha = k / (rho * c)\n\n    def lambda_equation(lam):\n        return np.sqrt(np.pi) * lam * np.exp(lam**2) * erfc(lam) - Ste\n\n    # Find the root for lambda\n    sol = root_scalar(lambda_equation, bracket=[0.01, 1.0], method='brentq')\n    lambda_val = sol.root\n    \n    s_analytical = 2 * lambda_val * np.sqrt(alpha * t_final)\n\n    # --- Test Suite ---\n    test_cases = [\n        # (dx, DeltaT)\n        (5e-4, 10.0),  # Case 1: baseline resolution, moderate mushy width\n        (1e-3, 1.0),   # Case 2: coarser grid, sharp-interface limit\n        (5e-4, 50.0),  # Case 3: baseline resolution, wide mushy width\n    ]\n\n    all_results = []\n\n    for dx, DeltaT in test_cases:\n        \n        # --- Common Numerical Setup for a Test Case ---\n        N_x = int(L_x / dx) + 1\n        x = np.linspace(0, L_x, N_x)\n        dt = 0.9 * dx**2 / (2 * alpha)\n        T_sol = T_m - DeltaT / 2\n        T_liq = T_m + DeltaT / 2\n\n        # --- EHC Method Simulation ---\n        T_ehc = np.full(N_x, T_m)\n        T_ehc[0] = T_s\n        \n        t = 0.0\n        while t  t_final:\n            dt_step = min(dt, t_final - t)\n            T_old = T_ehc.copy()\n            \n            c_eff = np.full(N_x, c)\n            mushy_mask = (T_old  T_sol)  (T_old  T_liq)\n            c_eff[mushy_mask] = c + L / DeltaT\n            \n            # Vectorized update for interior nodes\n            laplacian_T = (T_old[2:] - 2 * T_old[1:-1] + T_old[:-2]) / dx**2\n            dT_dt = k / (rho * c_eff[1:-1]) * laplacian_T\n            T_ehc[1:-1] = T_old[1:-1] + dT_dt * dt_step\n            \n            t += dt_step\n\n        # --- Enthalpy Method Simulation ---\n        def T_to_H(T_arr):\n            _H = np.zeros_like(T_arr)\n            solid_mask = T_arr = T_sol\n            mushy_mask = (T_arr  T_sol)  (T_arr  T_liq)\n            liquid_mask = T_arr = T_liq\n            \n            _H[solid_mask] = rho * c * T_arr[solid_mask]\n            _H[mushy_mask] = rho * c * T_arr[mushy_mask] + rho * L * (T_arr[mushy_mask] - T_sol) / DeltaT\n            _H[liquid_mask] = rho * c * T_arr[liquid_mask] + rho * L\n            return _H\n\n        def H_to_T(H_arr):\n            _T = np.zeros_like(H_arr)\n            H_sol = rho * c * T_sol\n            H_liq = rho * c * T_liq + rho * L\n            \n            solid_mask = H_arr = H_sol\n            mushy_mask = (H_arr  H_sol)  (H_arr  H_liq)\n            liquid_mask = H_arr = H_liq\n\n            _T[solid_mask] = H_arr[solid_mask] / (rho * c)\n            _T[mushy_mask] = (H_arr[mushy_mask] * DeltaT + rho * L * T_sol) / (rho * c * DeltaT + rho * L)\n            _T[liquid_mask] = (H_arr[liquid_mask] - rho * L) / (rho * c)\n            return _T\n        \n        T_ent = np.full(N_x, T_m)\n        H_ent = T_to_H(T_ent)\n\n        t = 0.0\n        while t  t_final:\n            dt_step = min(dt, t_final - t)\n            \n            # Apply BCs on T and update H at boundaries\n            T_ent[0] = T_s\n            T_ent[-1] = T_m\n            H_ent[0] = T_to_H(np.array([T_ent[0]]))[0]\n            H_ent[-1] = T_to_H(np.array([T_ent[-1]]))[0]\n            \n            H_old = H_ent.copy()\n\n            # Vectorized update for interior nodes\n            laplacian_T = (T_ent[2:] - 2*T_ent[1:-1] + T_ent[:-2]) / dx**2\n            dH_dt = k * laplacian_T\n            H_ent[1:-1] = H_old[1:-1] + dH_dt * dt_step\n            \n            # Update interior temperatures from new enthalpy\n            T_ent[1:-1] = H_to_T(H_ent[1:-1])\n\n            t += dt_step\n\n        # --- Interface Extraction and Error Calculation ---\n        def find_interface_pos(T_profile, x_grid):\n            # Find first index where temperature crosses T_m\n            try:\n                idx = np.where(T_profile = T_m)[0][0]\n                if idx == 0: return 0.0 # Interface at the wall\n                \n                # Linear interpolation\n                x1, T1 = x_grid[idx-1], T_profile[idx-1]\n                x2, T2 = x_grid[idx], T_profile[idx]\n                \n                if T2 == T1: return x1\n                \n                s_num = x1 + (x2 - x1) * (T_m - T1) / (T2 - T1)\n                return s_num\n            except IndexError:\n                # Temperature never reaches T_m, interface is beyond domain\n                return x_grid[-1]\n\n        s_num_ehc = find_interface_pos(T_ehc, x)\n        s_num_ent = find_interface_pos(T_ent, x)\n        \n        error_ehc = abs(s_num_ehc - s_analytical)\n        error_ent = abs(s_num_ent - s_analytical)\n        \n        all_results.append([error_ehc, error_ent])\n\n    # --- Format and Print Final Output ---\n    str_results = [f\"[{r[0]},{r[1]}]\" for r in all_results]\n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n```"
        }
    ]
}