{
    "hands_on_practices": [
        {
            "introduction": "流体体积（VOF）方法与分段线性界面计算（PLIC）的精髓在于其几何精度。一切计算的核心都是一个基础的“正向问题”：给定一个计算网格单元以及其中由法向量 $\\mathbf{n}$ 和平面常数 $\\alpha$ 定义的界面，如何精确计算出该界面所切割出的流体体积（或面积）？这个练习将指导你从第一性原理出发，开发一个稳健的几何裁剪算法，该算法能够应对各种极端情况，例如界面几乎与单元格相切时产生的微小“薄片”体积，或是与坐标轴对齐的法线。通过完成这项实践，你将为任何VOF-PLIC实现构建起最关键的几何计算引擎。",
            "id": "4004146",
            "problem": "考虑在笛卡尔网格中使用分段线性界面重构 (PLIC) 的流体体积 (VOF) 法。在单个计算单元中，重构的界面由一个线性流形表示：二维中为一条直线，三维中为一个平面。设计算单元在二维中为单位正方形，定义为 $\\{(x,y)\\in\\mathbb{R}^2 \\mid 0 \\le x \\le 1, 0 \\le y \\le 1\\}$，在三维中为单位立方体，定义为 $\\{(x,y,z)\\in\\mathbb{R}^3 \\mid 0 \\le x \\le 1, 0 \\le y \\le 1, 0 \\le z \\le 1\\}$。PLIC 界面是满足 $n \\cdot \\mathbf{x} = \\alpha$ 的点集，其中 $\\mathbf{n}$ 是界面法向量，$\\alpha$ 是一个标量偏移，液相占据单元内 $n \\cdot \\mathbf{x} \\le \\alpha$ 的半空间。单元内的局部体积分数必须等于半空间与单位单元相交区域的度量（二维中为面积，三维中为体积），并由单元度量进行归一化。\n\n目标是设计并验证鲁棒的裁剪算法，用于计算极端几何构型下的相交度量，且与体积分数守恒和线性界面表示相一致。这些算法必须仅依赖于凸多胞体与半空间的交集，并从第一性原理出发：(i) 质量守恒意味着体积分数等于液相区域所占单元度量的分数，(ii) PLIC 界面是线性的，以及 (iii) 凸多胞体与半空间相交后仍为凸多胞体。\n\n定义以下任务：\n- 对于二维，计算交集 $R_2 = \\{(x,y) \\in [0,1]^2 \\mid n_x x + n_y y \\le \\alpha\\}$ 的面积。\n- 对于三维，计算交集 $R_3 = \\{(x,y,z) \\in [0,1]^3 \\mid n_x x + n_y y + n_z z \\le \\alpha\\}$ 的体积。\n\n您的程序必须从第一性原理出发实现几何裁剪，并为下面的测试套件生成结果。算法必须对以下情况具有鲁棒性：\n- 界面几乎与单元相切，产生微小薄片度量的近切情况。\n- 法线与坐标轴对齐，产生轴对齐的半空间。\n- 靠近边和角的切割，对数值公差构成考验。\n\n使用以下测试套件。对于每个测试用例，计算单位单元内的相交度量，并使用通过/失败标准将其与提供的期望值进行比较。所有期望值均以与度量相同的单位给出：二维为面积，三维为体积。不需要物理单位或角度单位。\n\n二维测试用例（单位正方形）：\n- 案例 $1$：$n = (1,0)$, $\\alpha = 0.37$, 期望面积 $= 0.37$。\n- 案例 $2$：$n = (1,0)$, $\\alpha = -10^{-12}$, 期望面积 $= 0$。\n- 案例 $3$：$n = (1,0)$, $\\alpha = 1.2$, 期望面积 $= 1$。\n- 案例 $4$：$n = (1,1)$, $\\alpha = 0.5$, 期望面积 $= 0.125$。\n- 案例 $5$：$n = (1,1)$, $\\alpha = 10^{-4}$, 期望面积 $= 5 \\times 10^{-9}$。\n- 案例 $6$：$n = (1,1)$, $\\alpha = 1.99$, 期望面积 $= 0.99995$。\n- 案例 $7$：$n = (0,1)$, $\\alpha = 0.65$, 期望面积 $= 0.65$。\n\n三维测试用例（单位立方体）：\n- 案例 $8$：$n = (1,0,0)$, $\\alpha = 0.37$, 期望体积 $= 0.37$。\n- 案例 $9$：$n = (1,0,0)$, $\\alpha = -10^{-12}$, 期望体积 $= 0$。\n- 案例 $10$：$n = (1,0,0)$, $\\alpha = 1.2$, 期望体积 $= 1$。\n- 案例 $11$：$n = (1,1,1)$, $\\alpha = 0.5$, 期望体积 $= 0.020833333333333332$。\n- 案例 $12$：$n = (1,1,1)$, $\\alpha = 0.01$, 期望体积 $= 1.6666666666666667 \\times 10^{-7}$。\n- 案例 $13$：$n = (1,1,1)$, $\\alpha = 2.99$, 期望体积 $= 0.9999998333333334$。\n- 案例 $14$：$n = (0,1,0)$, $\\alpha = 0.65$, 期望体积 $= 0.65$。\n\n通过/失败标准：\n- 如果计算出的度量 $m_{\\text{comp}}$ 满足 $\\lvert m_{\\text{comp}} - m_{\\text{exp}} \\rvert \\le \\max(\\varepsilon_{\\text{abs}}, \\varepsilon_{\\text{rel}} \\cdot \\max(1, \\lvert m_{\\text{exp}} \\rvert))$，其中 $\\varepsilon_{\\text{abs}} = 10^{-9}$ 且 $\\varepsilon_{\\text{rel}} = 10^{-9}$，则测试通过。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result_1,result_2,\\dots,result_{14}]$），其中每个 $result_i$ 是一个布尔值，表示按上述顺序列出的案例 $i$ 的通过或失败情况。",
            "solution": "该问题要求计算单位超立方体与一个半空间相交区域的度量（二维为面积，三维为体积）。这是计算几何中的一个经典问题，是用于多相流模拟的流体体积 (VOF) 法中的分段线性界面重构 (PLIC) 方案的基础。液相由单位单元 $[0,1]^d$ 内的不等式 $n \\cdot \\mathbf{x} \\le \\alpha$ 定义，其中 $d \\in \\{2, 3\\}$。任务的核心是基于第一性原理开发一个鲁棒的算法，以计算由法向量 $n$ 和偏移 $\\alpha$ 定义的界面平面的各种几何构型下的此度量。\n\n解决方案是通过将一般问题系统地简化为一个存在解析解的典范形式而得出的。这种方法确保了正确性和鲁棒性。\n\n**1. 基本原理**\n\n算法建立在以下原则之上：\n- 单位单元是一个凸多胞体 $[0,1]^d$。\n- 液相区域是该凸多胞体与半空间 $n \\cdot \\mathbf{x} \\le \\alpha$ 的交集，其结果是另一个凸多胞体。\n- 集合的度量在等距变换（例如，反射）下是不变的。\n\n**2. 算法步骤**\n\n整体算法分几个阶段进行：\n\n**阶段 1：降维**\n法向量 $n$ 可能有零分量。例如，在三维中，如果 $n = (n_x, n_y, 0)$，界面方程 $n_x x + n_y y \\le \\alpha$ 与 $z$ 坐标无关。液相区域的体积是 $xy$ 平面中相应二维区域的面积乘以单元在 $z$ 方向的长度（即 $1$）。一般来说，如果 $n$ 的某些分量为零，问题可以在由 $n$ 的非零分量对应的轴所张成的低维空间中解决。所得的度量是相同的。算法首先识别问题的有效维度，并使用简化的法向量和维度进行处理。如果 $n$ 的所有分量都为零，则出现特殊情况，不等式变为 $0 \\le \\alpha$。如果 $\\alpha \\ge 0$，度量为 $1$；如果 $\\alpha  0$，度量为 $0$。如果只有一个分量 $n_k$ 非零，问题是一维的，度量就是单元长度的一部分，计算方式为：如果 $n_k > 0$，则为 $\\text{clip}(\\alpha/n_k, 0, 1)$；如果 $n_k  0$，则为 $\\text{clip}(1 - \\alpha/n_k, 0, 1)$。\n\n**阶段 2：转换为典范形式**\n一般问题可以通过将其转换为法向量所有分量均为非负的典范形式来简化。这是通过一系列保体积的反射变换实现的。对于任何 $n_i  0$ 的维度 $i$，我们应用反射 $x_i \\to 1 - x'_i$。新坐标 $x'_i$ 的定义域仍然是 $[0,1]$。不等式 $\\sum_j n_j x_j \\le \\alpha$ 变为：\n$$ \\sum_{j \\ne i} n_j x_j + n_i(1-x'_i) \\le \\alpha \\implies \\sum_{j \\ne i} n_j x_j - n_i x'_i \\le \\alpha - n_i $$\n通过定义新的法向量 $n'$（其中 $n'_i = -n_i > 0$）和新的偏移 $\\alpha' = \\alpha - n_i$，我们得到了一个具有非负法向量分量的等价问题。对所有具有负法向量分量的维度重复此过程。在此阶段之后，我们得到一个由 $(n', \\alpha')$ 定义的新问题，其中 $n'$ 的所有分量均为非负。函数 $f(\\mathbf{x}) = n' \\cdot \\mathbf{x}$ 现在在所有坐标上都是单调递增的。\n\n**阶段 3：边界判断与平凡情况**\n对于所有 $i$ 都有 $n'_i \\ge 0$ 的典范问题，在单位单元中 $n' \\cdot \\mathbf{x}$ 的最小值为 $0$，在 $\\mathbf{x}=(0,\\dots,0)$ 处取得。最大值为 $\\sum_i n'_i$，在 $\\mathbf{x}=(1,\\dots,1)$ 处取得。这允许进行简单的检查：\n- 如果 $\\alpha' \\le 0$，液相区域为空（或度量为零），因此度量为 $0$。\n- 如果 $\\alpha' \\ge \\sum_i n'_i$，整个单元被填充，度量为 $1$。\n\n**阶段 4：用于体积计算的容斥公式**\n对于 $0  \\alpha'  \\sum_i n'_i$ 的非平凡情况，液相区域是一个通过切割超立方体靠近原点的角而形成的凸多胞体。这种形状的体积可以解析计算。由 $\\{\\mathbf{x} \\in \\mathbb{R}^d_+ \\mid n' \\cdot \\mathbf{x} \\le \\alpha'\\}$（即在第一卦限）定义的单纯形的体积由以下公式给出：\n$$ V_{\\text{simplex}} = \\frac{(\\alpha')^d}{d! \\prod_{i=1}^d n'_i} $$\n此公式仅在单纯形不延伸到任何面 $x_i = 1$ 之外时，才对单位超立方体内的单纯形部分有效。为了考虑超立方体面对其的裁剪，我们使用容斥原理。所求体积是第一卦限中单纯形的体积减去位于超立方体外部区域（即一个或多个 $x_i > 1$）的体积。这导出了度量 $M$ 的通用公式：\n$$ M(n', \\alpha', d) = \\frac{1}{\\prod_{i=1}^d n'_i} \\sum_{S \\subseteq \\{1, \\dots, d\\}} (-1)^{|S|} \\frac{\\left(\\alpha' - \\sum_{j \\in S} n'_j\\right)^d}{d!} H\\left(\\alpha' - \\sum_{j \\in S} n'_j\\right) $$\n此处，求和是针对维度索引 $\\{1, \\dots, d\\}$ 的所有 $2^d$ 个子集 $S$ 进行的，$H$ 是亥维赛阶跃函数，当其参数为正时为 $1$，否则为 $0$。这有效地修剪了求和，只包括那些调整后的 alpha 值为正的项。$S=\\emptyset$ 对应的项是初始单纯形的体积。\n\n这种对降维、典范变换和容斥原理的系统性应用，提供了一个鲁棒且数学上合理的算法，能够处理所有测试用例，包括那些旨在考验数值精度和几何退化情况的用例。",
            "answer": "```python\nimport numpy as np\nfrom itertools import combinations\nimport math\n\ndef compute_measure(n_orig, alpha_orig):\n    \"\"\"\n    Computes the measure (area in 2D, volume in 3D) of the region\n    n . x = alpha inside the unit hypercube [0,1]^d.\n    \"\"\"\n    n = np.array(n_orig, dtype=float)\n    alpha = float(alpha_orig)\n    dim = len(n)\n    \n    # Epsilon for floating point comparisons\n    TOL = 1e-12\n\n    # Stage 1: Dimensionality Reduction\n    non_zero_indices = np.where(np.abs(n) > TOL)[0]\n    sub_dim = len(non_zero_indices)\n\n    if sub_dim == 0:\n        return 1.0 if alpha >= 0 else 0.0\n\n    # If the problem is effectively lower-dimensional, solve it in that subspace.\n    # The measure in the full space is the same.\n    if sub_dim  dim:\n        sub_n = n[non_zero_indices]\n        # Recursively call on the sub-problem\n        return compute_measure(sub_n, alpha)\n\n    # From here, dim = sub_dim and all components of n are non-zero.\n    \n    # Handle the 1D case explicitly for clarity, though it's covered by the \n    # transformation logic as well.\n    if dim == 1:\n        n0 = n[0]\n        if n0 > 0:\n            val = alpha / n0\n        else: # n0  0\n            # n0*x = alpha => x >= alpha/n0.\n            # measure of x in [0,1] is 1 - alpha/n0\n            val = 1.0 - (alpha / n0)\n        return np.clip(val, 0.0, 1.0)\n        \n    # Stage 2: Transformation to a Canonical Form (all normal components non-negative)\n    n_prime = n.copy()\n    alpha_prime = alpha\n    for i in range(dim):\n        if n_prime[i]  0:\n            alpha_prime -= n_prime[i]\n            n_prime[i] = -n_prime[i]\n\n    # After transformation, n_prime has all positive components.\n    \n    # Stage 3: Bounding and Trivial Cases for the canonical problem\n    if alpha_prime = TOL:\n        return 0.0\n    if alpha_prime >= np.sum(n_prime):\n        return 1.0\n\n    # Stage 4: Inclusion-Exclusion Formula for measure calculation\n    total_volume_term = 0.0\n    \n    # Iterate over all subset sizes k = 0, 1, ..., dim\n    for k in range(dim + 1):\n        # The sign of the term in the inclusion-exclusion sum\n        term_sign = (-1)**k\n        \n        # Iterate over all subsets of indices of size k\n        for subset_indices in combinations(range(dim), k):\n            n_subset_sum = np.sum(n_prime[list(subset_indices)])\n            \n            current_alpha = alpha_prime - n_subset_sum\n            \n            # The Heaviside function H(...) implemented by this check\n            if current_alpha > TOL:\n                term = (current_alpha**dim)\n                total_volume_term += term_sign * term\n    \n    prod_n = np.prod(n_prime)\n    factorial_d = math.factorial(dim)\n    \n    final_measure = total_volume_term / (factorial_d * prod_n)\n    \n    return np.clip(final_measure, 0.0, 1.0)\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # 2D cases\n        {'n': (1,0), 'alpha': 0.37, 'expected': 0.37, 'dim': 2},\n        {'n': (1,0), 'alpha': -1e-12, 'expected': 0.0, 'dim': 2},\n        {'n': (1,0), 'alpha': 1.2, 'expected': 1.0, 'dim': 2},\n        {'n': (1,1), 'alpha': 0.5, 'expected': 0.125, 'dim': 2},\n        {'n': (1,1), 'alpha': 1e-4, 'expected': 5e-9, 'dim': 2},\n        {'n': (1,1), 'alpha': 1.99, 'expected': 0.99995, 'dim': 2},\n        {'n': (0,1), 'alpha': 0.65, 'expected': 0.65, 'dim': 2},\n        # 3D cases\n        {'n': (1,0,0), 'alpha': 0.37, 'expected': 0.37, 'dim': 3},\n        {'n': (1,0,0), 'alpha': -1e-12, 'expected': 0.0, 'dim': 3},\n        {'n': (1,0,0), 'alpha': 1.2, 'expected': 1.0, 'dim': 3},\n        {'n': (1,1,1), 'alpha': 0.5, 'expected': 0.020833333333333332, 'dim': 3},\n        {'n': (1,1,1), 'alpha': 0.01, 'expected': 1.6666666666666667e-07, 'dim': 3},\n        {'n': (1,1,1), 'alpha': 2.99, 'expected': 0.9999998333333334, 'dim': 3},\n        {'n': (0,1,0), 'alpha': 0.65, 'expected': 0.65, 'dim': 3},\n    ]\n\n    eps_abs = 1e-9\n    eps_rel = 1e-9\n    \n    results = []\n    \n    for case in test_cases:\n        computed_measure = compute_measure(case['n'], case['alpha'])\n        expected_measure = case['expected']\n        \n        abs_error = abs(computed_measure - expected_measure)\n        \n        # Pass/fail criterion: |m_comp - m_exp| = max(eps_abs, eps_rel * max(1, |m_exp|))\n        tolerance = max(eps_abs, eps_rel * max(1.0, abs(expected_measure)))\n\n        passed = abs_error = tolerance\n        results.append(passed)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在前一个练习解决了“正向问题”之后，我们现在转向PLIC的核心任务——“反向问题”：在已知单元格内的流体体积分数 $f$ 和界面法向量 $\\mathbf{n}$ 的情况下，如何确定界面在线性重构方程 $\\mathbf{n} \\cdot \\mathbf{x} = \\alpha$ 中的位置参数 $\\alpha$？这个练习要求你实现一个能够求解 $\\alpha$ 的重构程序，并设计一个全面的单元测试组来验证其正确性。这些测试不仅要确保“重构-积分”循环中的体积守恒，还要检验一阶矩（质心）的一致性以及与补集相关的几何自洽性，这是确保VOF-PLIC代码可靠性的关键步骤。",
            "id": "4004072",
            "problem": "您的任务是为计算热工学中的流体体积法（VOF）界面重构所使用的二维分段线性界面计算（PLIC）模块，设计并实现一个最小化的、自包含的单元测试套件。其目标是验证在重构-积分循环下的体积不变性，以及笛卡尔单元内重构界面多边形的一阶矩（面积加权积分）的一致性。该问题以纯数学术语提出。\n\n考虑一个定义为域 $\\Omega = [0,1] \\times [0,1]$ 的单位正方形计算单元。设单元内的流体区域由半空间表示\n$$\n\\mathcal{H}(\\mathbf{n}, \\alpha) = \\left\\{ \\mathbf{x} \\in \\Omega \\,\\middle|\\, \\mathbf{n} \\cdot \\mathbf{x} \\le \\alpha \\right\\},\n$$\n其中 $\\mathbf{n} = (n_x, n_y)$ 是一个单位法向量，$\\alpha \\in \\mathbb{R}$ 是平面常数。流体多边形 $\\mathcal{P}$ 定义为交集 $\\mathcal{P} = \\Omega \\cap \\mathcal{H}(\\mathbf{n}, \\alpha)$。\n\n使用的基本定义：\n- 目标体积分数（在二维中为面积分数）为 $f \\in [0,1]$。\n- 重构的界面必须满足约束条件\n$$\nA(\\mathbf{n}, \\alpha) = \\int_{\\mathcal{P}} 1 \\, dA = f,\n$$\n其中 $A(\\mathbf{n}, \\alpha)$ 是 $\\mathcal{P}$ 的面积。\n- 关于原点的一阶矩为\n$$\nM_x(\\mathbf{n}, \\alpha) = \\int_{\\mathcal{P}} x \\, dA, \\quad M_y(\\mathbf{n}, \\alpha) = \\int_{\\mathcal{P}} y \\, dA,\n$$\n质心为\n$$\n\\mathbf{c} = \\left( \\frac{M_x}{A}, \\frac{M_y}{A} \\right), \\quad \\text{for } A > 0.\n$$\n\n从第一性原理出发，实现以下算法组件：\n1. 一个鲁棒的多边形裁剪器，用于通过对单位正方形 $\\Omega$ 进行半平面裁剪来计算 $\\mathcal{P} = \\Omega \\cap \\{\\mathbf{x}\\,|\\,\\mathbf{n}\\cdot\\mathbf{x} \\le \\alpha\\}$。\n2. 从鞋带公式及其矩类似公式推导出的 $A$、$M_x$ 和 $M_y$ 的精确多边形积分。\n3. 一个重构例程，在给定 $\\mathbf{n}$ 和 $f$ 的情况下，通过求解 $A(\\mathbf{n}, \\alpha) = f$ 来计算 $\\alpha$。该求解过程使用一种区间法，利用 $A$ 对 $\\alpha$ 的单调性。\n4. 一个参考离散求积法（在 $N \\times N$ 网格上对 $\\Omega$ 的单元中心进行均匀采样），用于近似计算 $A$、$M_x$ 和 $M_y$ 以进行交叉检验。\n\n设计一个单元测试套件，为每个测试配置 $(\\mathbf{n}, f)$ 验证以下属性：\n- 重构-积分循环下的体积不变性：从 $(\\mathbf{n}, f)$ 重构 $\\alpha$，然后对多边形进行积分以获得 $A$。如果满足以下条件，则测试通过\n$$\n\\left| A - f \\right| \\le \\varepsilon_A^{\\mathrm{abs}} + \\varepsilon_A^{\\mathrm{rel}} \\, f.\n$$\n- 与离散求积法的一阶矩一致性：通过精确多边形积分和在 $N \\times N$ 网格上进行均匀采样来计算 $(A, M_x, M_y)$。如果满足以下条件，则测试通过\n$$\n\\left| A_{\\mathrm{poly}} - A_{\\mathrm{quad}} \\right| \\le \\varepsilon_Q^{A}, \\quad\n\\left| M_{x,\\mathrm{poly}} - M_{x,\\mathrm{quad}} \\right| \\le \\varepsilon_Q^{M}, \\quad\n\\left| M_{y,\\mathrm{poly}} - M_{y,\\mathrm{quad}} \\right| \\le \\varepsilon_Q^{M}.\n$$\n- 互补一致性：通过翻转法向量和平面常数（即使用 $-\\mathbf{n}$ 和 $-\\alpha$）来定义互补半空间。计算互补多边形 $\\mathcal{P}' = \\Omega \\cap \\{\\mathbf{x}\\,|\\,(-\\mathbf{n}) \\cdot \\mathbf{x} \\le -\\alpha\\}$ 的 $(A', M_x', M_y')$。如果满足以下条件，则测试通过\n$$\n\\left| (A + A') - 1 \\right| \\le \\varepsilon_C^{A}, \\quad\n\\left| (M_x + M_x') - \\frac{1}{2} \\right| \\le \\varepsilon_C^{M}, \\quad\n\\left| (M_y + M_y') - \\frac{1}{2} \\right| \\le \\varepsilon_C^{M}.\n$$\n\n可接受的容差：\n- 重构-积分不变性：$\\varepsilon_A^{\\mathrm{abs}} = 10^{-12}$，$\\varepsilon_A^{\\mathrm{rel}} = 10^{-10}$。\n- 离散求积交叉检验：$\\varepsilon_Q^{A} = 5 \\times 10^{-4}$，$\\varepsilon_Q^{M} = 5 \\times 10^{-4}$，其中 $N = 400$。\n- 互补一致性：$\\varepsilon_C^{A} = 10^{-12}$，$\\varepsilon_C^{M} = 10^{-12}$。\n\n测试套件：\n使用以下配置，每个配置中的 $\\mathbf{n}$ 都经过单位归一化：\n- 案例 1：$\\mathbf{n} = (1, 0)$，$f = 0.3$。\n- 案例 2：$\\mathbf{n} = (0, 1)$，$f = 0.7$。\n- 案例 3：$\\mathbf{n} = \\frac{1}{\\sqrt{2}}(1, 1)$，$f = 0.5$。\n- 案例 4：$\\mathbf{n} = \\mathrm{normalize}(10^{-4}, 1)$，$f = 0.01$。\n- 案例 5：$\\mathbf{n} = \\frac{1}{\\sqrt{2}}(1, -1)$，$f = 0.99$。\n- 案例 6：$\\mathbf{n} = (1, 0)$，$f = 0$。\n- 案例 7：$\\mathbf{n} = (1, 0)$，$f = 1$。\n\n最终输出规范：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。对于上述顺序中的每个案例，输出三个布尔值，分别对应于：\n- 体积不变性测试通过，\n- 矩一致性测试通过，\n- 互补一致性测试通过。\n\n因此，输出总共应有 $21$ 个条目，顺序如下\n$$\n[\\text{Inv}_1,\\text{Mom}_1,\\text{Comp}_1,\\text{Inv}_2,\\text{Mom}_2,\\text{Comp}_2,\\dots,\\text{Inv}_7,\\text{Mom}_7,\\text{Comp}_7].\n$$\n此问题不要求物理单位。不涉及角度。将每个布尔值表示为 Python 字面量 $True$ 或 $False$。",
            "solution": "用户提供了一个有效的、适定性的问题。请求是为流体体积法（VOF）框架内的二维分段线性界面计算（PLIC）模块设计并实现一个单元测试套件。解决方案需要从第一性原理出发，开发几个几何和数值算法。本文档概述了每个组件的理论基础和算法设计。\n\n问题围绕一个单位正方形计算单元 $\\Omega = [0,1] \\times [0,1]$。流体界面由一个单位法向量 $\\mathbf{n}=(n_x, n_y)$ 和一个平面常数 $\\alpha$ 定义的线表示。流体占据单元中 $\\mathbf{n} \\cdot \\mathbf{x} \\le \\alpha$ 的部分，形成一个多边形 $\\mathcal{P}$。任务的核心是验证操作此表示的算法的一致性和正确性。\n\n解决方案分为四个主要算法组件，随后是利用这些组件的测试套件逻辑。\n\n### 1. 多边形裁剪算法\n\n为了确定流体多边形 $\\mathcal{P} = \\Omega \\cap \\{ \\mathbf{x} \\,|\\, \\mathbf{n} \\cdot \\mathbf{x} \\le \\alpha \\}$，我们必须用流体界面线定义的半空间来裁剪单位正方形 $\\Omega$。Sutherland-Hodgman 算法是一种鲁棒且标准的方法，用于对凸多边形（正方形）进行凸裁剪区域（半空间）的裁剪。\n\n算法流程如下：\n初始主题多边形是单位正方形，其顶点按逆时针（CCW）顺序为 $\\{(0,0), (1,0), (1,1), (0,1)\\}$。我们遍历该多边形的每条边。对于由起始顶点 $\\mathbf{s}$ 和结束顶点 $\\mathbf{e}$ 定义的每条边，我们分析它们相对于裁剪线 $\\mathbf{n} \\cdot \\mathbf{x} = \\alpha$ 的位置。\n如果 $\\mathbf{n} \\cdot \\mathbf{p} \\le \\alpha$，则点 $\\mathbf{p}$ 在流体区域“内部”。对于每条边 $(\\mathbf{s}, \\mathbf{e})$，有四种情况：\n1.  $\\mathbf{s}$ 和 $\\mathbf{e}$ 都在内部：该边完全在流体区域内。将结束顶点 $\\mathbf{e}$ 添加到新多边形的输出顶点列表中。\n2.  $\\mathbf{s}$ 在内部，$\\mathbf{e}$ 在外部：该边穿过边界。我们计算该边与线 $\\mathbf{n} \\cdot \\mathbf{x} = \\alpha$ 的交点 $\\mathbf{i}$，并将 $\\mathbf{i}$ 添加到输出列表中。\n3.  $\\mathbf{s}$ 和 $\\mathbf{e}$ 都在外部：该边完全在流体区域外。不添加任何顶点。\n4.  $\\mathbf{s}$ 在外部，$\\mathbf{e}$ 在内部：该边穿过边界。我们计算交点 $\\mathbf{i}$，并将 $\\mathbf{i}$ 和结束顶点 $\\mathbf{e}$ 都添加到输出列表中。\n\n从 $\\mathbf{s}$ 到 $\\mathbf{e}$ 的边的交点 $\\mathbf{i}$，可以通过将线段参数化为 $\\mathbf{p}(t) = \\mathbf{s} + t(\\mathbf{e}-\\mathbf{s})$（对于 $t \\in [0,1]$）并求解 $\\mathbf{n} \\cdot \\mathbf{p}(t) = \\alpha$ 时的 $t$ 来找到。这得出 $t = (\\alpha - \\mathbf{n} \\cdot \\mathbf{s}) / (\\mathbf{n} \\cdot (\\mathbf{e}-\\mathbf{s}))$。\n\n此过程为流体多边形 $\\mathcal{P}$ 生成一个新的顶点列表，这些顶点按 CCW 约定正确排序，这对于后续的积分步骤至关重要。\n\n### 2. 精确多边形积分计算\n\n给定裁剪后多边形 $\\mathcal{P}$ 的有序顶点 $(x_0, y_0), (x_1, y_1), \\dots, (x_{k-1}, y_{k-1})$，我们可以精确计算其面积 $A$ 和一阶矩 $M_x$、$M_y$。这些计算基于 Green 定理，该定理将沿简单闭合曲线的线积分与它所包围的平面区域上的二重积分联系起来。这导出了著名的鞋带公式及其矩的类似形式。\n\n对于一个有 $k$ 个顶点（从 $i=0$ 到 $k-1$ 按 CCW 顺序索引，且 $(x_k, y_k) = (x_0, y_0)$）的多边形：\n-   **面积 ($A$)**:\n    $$\n    A = \\frac{1}{2} \\sum_{i=0}^{k-1} (x_i y_{i+1} - x_{i+1} y_i)\n    $$\n-   **关于 y 轴的一阶矩 ($M_x$)**:\n    $$\n    M_x = \\int_{\\mathcal{P}} x \\,dA = \\frac{1}{6} \\sum_{i=0}^{k-1} (x_i y_{i+1} - x_{i+1} y_i)(x_i + x_{i+1})\n    $$\n-   **关于 x 轴的一阶矩 ($M_y$)**:\n    $$\n    M_y = \\int_{\\mathcal{P}} y \\,dA = \\frac{1}{6} \\sum_{i=0}^{k-1} (x_i y_{i+1} - x_{i+1} y_i)(y_i + y_{i+1})\n    $$\n这些公式为重构多边形的属性提供了精确的解析结果，仅受浮点精度限制。\n\n### 3. 界面重构例程\n\n这是一个反问题：给定法向量 $\\mathbf{n}$ 和目标流体面积分数 $f$，我们必须找到满足面积约束 $A(\\mathbf{n}, \\alpha) = f$ 的平面常数 $\\alpha$。面积 $A(\\mathbf{n}, \\alpha)$ 是 $\\alpha$ 的单调递增函数。此属性使该问题适合使用求根算法。\n\n我们定义一个目标函数 $g(\\alpha) = A(\\mathbf{n}, \\alpha) - f$。我们寻找根 $\\alpha^*$ 使得 $g(\\alpha^*) = 0$。像二分法，或者更高效的 Brent 法这样的区间法，是此任务的理想选择。`scipy.optimize.brentq` 是一个出色的实现。\n\n要使用区间法，我们必须首先确定一个保证包含根的区间 $[\\alpha_{min}, \\alpha_{max}]$。在单位正方形 $\\Omega$ 上，$\\mathbf{n}\\cdot\\mathbf{x}$ 的值是有界的。最小值和最大值在正方形的角点处取得：$(0,0), (1,0), (0,1), (1,1)$。令 $\\alpha_{low} = \\min_{\\mathbf{v} \\in \\text{corners}} (\\mathbf{n} \\cdot \\mathbf{v})$ 和 $\\alpha_{high} = \\max_{\\mathbf{v} \\in \\text{corners}} (\\mathbf{n} \\cdot \\mathbf{v})$。对于任何 $\\alpha  \\alpha_{low}$，面积 $A(\\alpha)$ 为 $0$。对于任何 $\\alpha > \\alpha_{high}$，面积 $A(\\alpha)$ 为 $1$。因此，对于目标分数 $f \\in (0,1)$，根 $\\alpha^*$ 必须位于 $[\\alpha_{low}, \\alpha_{high}]$ 内。该区间为求根算法提供了必要的括号。$f=0$ 和 $f=1$ 的极端情况可以通过选择此范围之外的 $\\alpha$ 来直接处理，例如，对于 $f=0$ 使用 $\\alpha_{low} - 1$，对于 $f=1$ 使用 $\\alpha_{high} + 1$。\n\n### 4. 用于验证的离散求积法\n\n需要一个参考计算来交叉检验矩。一个简单有效的方法是通过均匀采样进行离散求积。我们将域 $\\Omega$ 离散化为 $N \\times N$ 的子单元网格。我们在每个子单元的中心对条件 $\\mathbf{n} \\cdot \\mathbf{x} \\le \\alpha$ 进行采样。\n\n子单元 $(i,j)$ 的中心是 $\\mathbf{x}_{ij} = (\\frac{i+0.5}{N}, \\frac{j+0.5}{N})$，其中 $i,j \\in \\{0, \\dots, N-1\\}$。每个子单元的面积是 $\\Delta A = (1/N)^2$。积分近似为和：\n-   $A_{\\mathrm{quad}} = \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\mathbb{I}(\\mathbf{n} \\cdot \\mathbf{x}_{ij} \\le \\alpha) \\Delta A$\n-   $M_{x,\\mathrm{quad}} = \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} x_i \\mathbb{I}(\\mathbf{n} \\cdot \\mathbf{x}_{ij} \\le \\alpha) \\Delta A$\n-   $M_{y,\\mathrm{quad}} = \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} y_j \\mathbb{I}(\\mathbf{n} \\cdot \\mathbf{x}_{ij} \\le \\alpha) \\Delta A$\n其中 $\\mathbb{I}(\\cdot)$ 是指示函数。当 $N=400$ 时，这为验证目的提供了相当准确的近似值。\n\n### 单元测试套件执行\n\n测试套件遍历所提供的配置 $(\\mathbf{n}, f)$。对每个配置执行以下测试：\n\n1.  **体积不变性**：使用求根例程从 $(\\mathbf{n}, f)$ 重构 $\\alpha$。然后，用 $(\\mathbf{n}, \\alpha)$ 裁剪正方形得到 $\\mathcal{P}$。使用精确积分公式计算其面积 $A_{\\mathrm{poly}}$。如果 $|A_{\\mathrm{poly}} - f| \\le \\varepsilon_A^{\\mathrm{abs}} + \\varepsilon_A^{\\mathrm{rel}} f$，则测试通过。这验证了重构和积分是互逆操作。\n2.  **矩一致性**：使用相同的多边形 $\\mathcal{P}$ 及其属性 $(A_{\\mathrm{poly}}, M_{x,\\mathrm{poly}}, M_{y,\\mathrm{poly}})$，使用 $N=400$ 的求积法计算近似属性 $(A_{\\mathrm{quad}}, M_{x,\\mathrm{quad}}, M_{y,\\mathrm{quad}})$。如果绝对差异在指定容差内，例如 $|A_{\\mathrm{poly}} - A_{\\mathrm{quad}}| \\le \\varepsilon_Q^{A}$，则测试通过。\n3.  **互补一致性**：构造互补多边形 $\\mathcal{P}' = \\Omega \\cap \\{\\mathbf{x}\\,|\\,(-\\mathbf{n}) \\cdot \\mathbf{x} \\le -\\alpha\\}$。计算其属性 $(A', M_x', M_y')$。如果 $\\mathcal{P}$ 和 $\\mathcal{P}'$ 的属性之和与完整正方形 $\\Omega$ 的属性匹配：$A+A'=1$，$M_x+M_x'=1/2$，$M_y+M_y'=1/2$，且在给定的严格容差内，则测试通过。这验证了该公式的几何和代数自洽性。\n\n通过实现这些组件和测试，我们为 PLIC-VOF 方法的基本操作构建了一个严格的验证套件。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Designs and runs a unit test suite for a 2D VOF PLIC module.\n    \"\"\"\n\n    # Tolerances from the problem statement\n    EPS_A_ABS = 1e-12\n    EPS_A_REL = 1e-10\n    EPS_Q_A = 5e-4\n    EPS_Q_M = 5e-4\n    EPS_C_A = 1e-12\n    EPS_C_M = 1e-12\n    N_QUAD = 400\n    \n    # Machine epsilon for geometric comparisons\n    GEOM_TOL = 1e-14\n\n    def normalize(v):\n        \"\"\"Normalizes a 2D vector.\"\"\"\n        norm = np.linalg.norm(v)\n        if norm  GEOM_TOL:\n            # As per problem, n is a unit normal, so this shouldn't happen\n            # with valid inputs. Return a default to avoid division by zero.\n            return np.array([1.0, 0.0])\n        return np.array(v) / norm\n\n    def clip_with_half_plane(subject_polygon, n, alpha):\n        \"\"\"\n        Clips a convex polygon against a half-plane using Sutherland-Hodgman.\n        The half-plane is defined by n.x = alpha.\n        Vertices are assumed to be numpy arrays.\n        \"\"\"\n        output_list = []\n        if not subject_polygon:\n            return []\n        \n        # Start with the last vertex to process the first edge\n        s = subject_polygon[-1]\n        \n        for e in subject_polygon:\n            s_dot = np.dot(n, s)\n            e_dot = np.dot(n, e)\n            \n            s_inside = (s_dot - alpha) = GEOM_TOL\n            e_inside = (e_dot - alpha) = GEOM_TOL\n            \n            if s_inside != e_inside:\n                # Edge crosses the clipping plane, find intersection\n                d_dot = e_dot - s_dot\n                if abs(d_dot) > GEOM_TOL:\n                    t = (alpha - s_dot) / d_dot\n                    # Ensure t is within [0,1] for valid segment intersection\n                    t = np.clip(t, 0.0, 1.0)\n                    isection = s + t * (e - s)\n                    output_list.append(isection)\n\n            if e_inside:\n                output_list.append(e)\n            \n            s = e\n            \n        return output_list\n        \n    def get_polygon_from_half_space(n, alpha):\n        \"\"\"\n        Computes the fluid polygon by clipping the unit square with a half-space.\n        \"\"\"\n        square_vertices = [np.array([0.0, 0.0]), np.array([1.0, 0.0]), \n                             np.array([1.0, 1.0]), np.array([0.0, 1.0])]\n        \n        num_corners_inside = sum(1 for v in square_vertices if (np.dot(n, v) - alpha) = GEOM_TOL)\n\n        if num_corners_inside == 4: # all inside\n            return square_vertices\n        \n        clipped_poly = clip_with_half_plane(square_vertices, n, alpha)\n\n        if len(clipped_poly)  3:\n            return [] # Empty or degenerate polygon\n        \n        return clipped_poly\n\n    def calculate_polygon_properties(vertices):\n        \"\"\"\n        Calculates area and first moments of a polygon using shoelace formulas.\n        Vertices are assumed to be ordered CCW.\n        \"\"\"\n        if not vertices or len(vertices)  3:\n            return 0.0, 0.0, 0.0\n\n        A = 0.0\n        Mx = 0.0\n        My = 0.0\n        \n        for i in range(len(vertices)):\n            v1 = vertices[i]\n            v2 = vertices[(i + 1) % len(vertices)]\n            \n            x1, y1 = v1[0], v1[1]\n            x2, y2 = v2[0], v2[1]\n            \n            cross_product = x1 * y2 - x2 * y1\n            \n            A += cross_product\n            Mx += cross_product * (x1 + x2)\n            My += cross_product * (y1 + y2)\n            \n        return A / 2.0, Mx / 6.0, My / 6.0\n\n    def find_alpha(n, f):\n        \"\"\"\n        Finds alpha such that the area for (n, alpha) is f.\n        \"\"\"\n        # Determine bracketing interval for alpha\n        corners = [np.array([0.0, 0.0]), np.array([1.0, 0.0]), \n                   np.array([1.0, 1.0]), np.array([0.0, 1.0])]\n        dot_products = [np.dot(n, v) for v in corners]\n        alpha_min = min(dot_products)\n        alpha_max = max(dot_products)\n        \n        if f = GEOM_TOL:\n            return alpha_min - 1.0\n        if f >= 1.0 - GEOM_TOL:\n            return alpha_max + 1.0\n\n        def objective_func(alpha):\n            poly = get_polygon_from_half_space(n, alpha)\n            area, _, _ = calculate_polygon_properties(poly)\n            return area - f\n\n        try:\n            # Use a slightly wider bracket to handle floating point at boundaries\n            alpha_root, r = brentq(objective_func, alpha_min - GEOM_TOL, alpha_max + GEOM_TOL, full_output=True)\n            if not r.converged:\n                # Should not happen with this monotonic function\n                raise RuntimeError(\"Root finding for alpha failed to converge.\")\n            return alpha_root\n        except ValueError:\n            # This can happen if signs at endpoints are the same, indicating f is 0 or 1.\n            # We already handled this, but as a fallback:\n            area_at_min = objective_func(alpha_min) + f\n            if abs(f - area_at_min)  GEOM_TOL:\n                return alpha_min\n            area_at_max = objective_func(alpha_max) + f\n            if abs(f - area_at_max)  GEOM_TOL:\n                return alpha_max\n            # If still failing, problem is likely ill-posed for the given f\n            raise\n\n    def calculate_quadrature_properties(n, alpha, N):\n        \"\"\"\n        Calculates properties using discrete quadrature on an N x N grid.\n        \"\"\"\n        dx = 1.0 / N\n        cell_area = dx * dx\n        \n        A_quad, Mx_quad, My_quad = 0.0, 0.0, 0.0\n        \n        x_coords = (np.arange(N) + 0.5) * dx\n        y_coords = (np.arange(N) + 0.5) * dx\n        \n        for i in range(N):\n            for j in range(N):\n                pt = np.array([x_coords[i], y_coords[j]])\n                if np.dot(n, pt) - alpha = GEOM_TOL:\n                    A_quad += cell_area\n                    Mx_quad += x_coords[i] * cell_area\n                    My_quad += y_coords[j] * cell_area\n                    \n        return A_quad, Mx_quad, My_quad\n\n    # Test cases from the problem statement\n    test_cases_raw = [\n        ((1, 0), 0.3),\n        ((0, 1), 0.7),\n        ((1/np.sqrt(2), 1/np.sqrt(2)), 0.5),\n        ((1e-4, 1), 0.01),\n        ((1/np.sqrt(2), -1/np.sqrt(2)), 0.99),\n        ((1, 0), 0.0),\n        ((1, 0), 1.0),\n    ]\n\n    results = []\n    \n    for n_raw, f in test_cases_raw:\n        n = normalize(n_raw)\n        \n        # Reconstruct alpha from (n, f)\n        alpha = find_alpha(n, f)\n        \n        # Get polygon properties\n        poly = get_polygon_from_half_space(n, alpha)\n        A_poly, Mx_poly, My_poly = calculate_polygon_properties(poly)\n        \n        # 1. Volume Invariance Test\n        inv_pass = abs(A_poly - f) = EPS_A_ABS + EPS_A_REL * f\n        \n        # 2. Moment Consistency Test\n        A_quad, Mx_quad, My_quad = calculate_quadrature_properties(n, alpha, N_QUAD)\n        mom_pass_A = abs(A_poly - A_quad) = EPS_Q_A\n        mom_pass_Mx = abs(Mx_poly - Mx_quad) = EPS_Q_M\n        mom_pass_My = abs(My_poly - My_quad) = EPS_Q_M\n        mom_pass = mom_pass_A and mom_pass_Mx and mom_pass_My\n        \n        # 3. Complement Consistency Test\n        n_comp = -n\n        alpha_comp = -alpha\n        poly_comp = get_polygon_from_half_space(n_comp, alpha_comp)\n        A_comp, Mx_comp, My_comp = calculate_polygon_properties(poly_comp)\n        \n        comp_pass_A = abs((A_poly + A_comp) - 1.0) = EPS_C_A\n        comp_pass_Mx = abs((Mx_poly + Mx_comp) - 0.5) = EPS_C_M\n        comp_pass_My = abs((My_poly + My_comp) - 0.5) = EPS_C_M\n        comp_pass = comp_pass_A and comp_pass_Mx and comp_pass_My\n        \n        results.extend([inv_pass, mom_pass, comp_pass])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "拥有了可靠的静态界面重构能力后，下一步便是将其应用于模拟流体的运动。在VOF方法中，流体的平流输运是通过计算在时间步 $\\Delta t$ 内穿过单元格交界面的流体通量来完成的。这个练习将具体展示如何利用已重构的界面来计算这一动态物理量。通过解决这个基于几何平流概念的实际计算问题，你将掌握连接静态界面几何与动态流场演化的核心环节，为更新VOF场奠定基础。",
            "id": "4004075",
            "problem": "考虑在计算热工学背景下，使用流体体积（VOF）法和分段线性界面重构（PLIC）进行两相流平流计算所采用的均匀笛卡尔网格。关注单个供给单元，其局部坐标定义为 $x \\in [0,\\Delta x]$、$y \\in [0,\\Delta y]$ 和 $z \\in [0,\\Delta z]$。流速恒定且沿 $x$ 方向，$\\mathbf{u} = (u,0,0)$，且库朗-弗里德里希-列维（CFL）数 $\\mathrm{CFL} = u \\Delta t / \\Delta x$ 满足 $\\mathrm{CFL}  1$。供给单元内的界面通过PLIC方法重构，表示为该单元与一个平面的交集，该平面由方程 $n_x x + n_y y + n_z z = \\alpha$ 描述，其中 $\\mathbf{n} = (n_x,n_y,n_z)$ 是由VOF梯度提供的单位法向量，$\\alpha$ 是由局部体积分数确定的平面常数。\n\n假设参数值如下：\n- $\\Delta x = 0.01\\,\\mathrm{m}$，$\\Delta y = 0.02\\,\\mathrm{m}$，$\\Delta z = 0.01\\,\\mathrm{m}$，\n- $u = 1\\,\\mathrm{m/s}$，$\\Delta t = 0.003\\,\\mathrm{s}$（因此 $\\mathrm{CFL} = 0.3$），\n- $\\mathbf{n} = (0.6,0.8,0)$（单位向量），\n- $\\alpha = 0.014\\,\\mathrm{m}$。\n\n在该时间步内，于恒定平流作用下，穿过 $x = \\Delta x$ 处右侧（垂直）单元面的重构流体的精确PLIC通量，等于位于扫掠平板区域 $x \\in [\\Delta x - d, \\Delta x]$（其中 $d = u \\Delta t$）内的重构流体区域部分的体积。从指示函数的守恒和恒定速度下的几何平流出发，计算在时间间隔 $\\Delta t$ 内穿过右侧面的精确PLIC体积通量 $F$。最终答案以 $\\mathrm{m^3}$ 为单位表示，并四舍五入至五位有效数字。",
            "solution": "该问题要求计算在一个时间步 $\\Delta t$ 内，流体穿过计算单元右侧面的体积通量 $F$。在流体体积（VOF）框架内，流体界面通过分段线性界面重构（PLIC）方法表示为一个平面。\n\n问题陈述，体积通量 $F$ 等于位于由 $x \\in [\\Delta x - d, \\Delta x]$ 定义的“扫掠平板区域”内的重构流体区域的体积，其中 $d = u \\Delta t$。这是恒定速度场下平流的标准几何解释。\n\n目标区域是一个由几个半空间相交定义的多面体：\n1.  重构的流体区域：界面由平面 $n_x x + n_y y + n_z z = \\alpha$ 给出。法向量 $\\mathbf{n}$ 通常定义为指向流体外部。因此，流体占据 $n_x x + n_y y + n_z z \\le \\alpha$ 的空间。\n2.  扫掠平板区域：平流纯粹沿 $x$ 方向，因此在时间 $\\Delta t$ 内穿过 $x=\\Delta x$ 面的体积起源于由 $x \\in [\\Delta x - u\\Delta t, \\Delta x]$ 定义的平板区域。\n3.  单元边界：计算被限制在供给单元内，这施加了边界 $y \\in [0, \\Delta y]$ 和 $z \\in [0, \\Delta z]$。\n\n待计算的总通量体积 $F$ 是在由所有这些约束条件定义的区域 $V$ 上对 1 进行积分得到的。\n首先，让我们代入给定的参数数值。\n单元尺寸：$\\Delta x = 0.01\\,\\mathrm{m}$，$\\Delta y = 0.02\\,\\mathrm{m}$，$\\Delta z = 0.01\\,\\mathrm{m}$。\n流动参数：$u = 1\\,\\mathrm{m/s}$，$\\Delta t = 0.003\\,\\mathrm{s}$。\n平流距离为 $d = u \\Delta t = (1\\,\\mathrm{m/s})(0.003\\,\\mathrm{s}) = 0.003\\,\\mathrm{m}$。\n因此，扫掠平板区域为 $x \\in [0.01 - 0.003, 0.01]$，可简化为 $x \\in [0.007, 0.01]$。\n\n界面平面定义：\n法向量 $\\mathbf{n} = (0.6, 0.8, 0)$。\n平面常数 $\\alpha = 0.014\\,\\mathrm{m}$。\n流体位于由不等式 $0.6x + 0.8y + 0z \\le 0.014$ 定义的区域内，该不等式可简化为 $0.6x + 0.8y \\le 0.014$。\n\n体积 $F$ 是在由以下不等式定义的区域 $V$ 上的积分：\n1. $0.007 \\le x \\le 0.01$\n2. $0 \\le y \\le 0.02$\n3. $0 \\le z \\le 0.01$\n4. $0.6x + 0.8y \\le 0.014$\n\n流体区域的表达式不依赖于变量 $z$（因为 $n_z=0$）。这意味着对于任意给定的 $(x, y)$ 对，被积函数沿 $z$ 方向是常数。可以首先对 $z$ 进行积分，结果就是将该区域在 $xy$ 平面上的投影面积乘以单元深度 $\\Delta z$。\n\n设 $A$ 为 $xy$ 平面上由以下条件定义的二维区域的面积：\n1. $0.007 \\le x \\le 0.01$\n2. $0 \\le y \\le 0.02$\n3. $0.6x + 0.8y \\le 0.014$\n\n则通量体积为 $F = A \\times \\Delta z$。我们现在专注于计算 $A$。\n第三个不等式可以重写为将 $y$ 表示为 $x$ 的函数：\n$0.8y \\le 0.014 - 0.6x$\n$y \\le \\frac{0.014 - 0.6x}{0.8}$\n$y \\le 0.0175 - 0.75x$\n\n因此，区域 $A$ 由 $x=0.007$、$x=0.01$、$y=0$ 和 $y \\le \\min(0.02, 0.0175 - 0.75x)$ 界定。\n我们必须检查直线 $y = 0.0175 - 0.75x$ 是否在我们的 $x$ 积分域 $[0.007, 0.01]$ 内与单元顶部 $y = 0.02$ 相交。\n让我们在 $x$ 域的边界处计算上界 $0.0175 - 0.75x$ 的值：\n在 $x = 0.007$ 处：$y = 0.0175 - 0.75(0.007) = 0.0175 - 0.00525 = 0.01225$。\n在 $x = 0.01$ 处：$y = 0.0175 - 0.75(0.01) = 0.0175 - 0.0075 = 0.01$。\n\n由于 $0.01225$ 和 $0.01$ 均小于单元高度 $\\Delta y = 0.02$，因此积分区域的上边界始终由直线 $y = 0.0175 - 0.75x$ 给出，而单元边界 $y = 0.02$ 不构成对该面积的约束。\n面积 $A$ 可以通过积分计算：\n$$ A = \\int_{0.007}^{0.01} \\left( \\int_0^{0.0175 - 0.75x} dy \\right) dx $$\n$$ A = \\int_{0.007}^{0.01} (0.0175 - 0.75x) dx $$\n该积分代表一个梯形的面积。我们可以直接求解：\n$$ A = \\left[ 0.0175x - 0.75\\frac{x^2}{2} \\right]_{0.007}^{0.01} = \\left[ 0.0175x - 0.375x^2 \\right]_{0.007}^{0.01} $$\n代入上下限：\n$$ A = (0.0175(0.01) - 0.375(0.01)^2) - (0.0175(0.007) - 0.375(0.007)^2) $$\n$$ A = (0.000175 - 0.375(0.0001)) - (0.0001225 - 0.375(0.000049)) $$\n$$ A = (0.000175 - 0.0000375) - (0.0001225 - 0.000018375) $$\n$$ A = 0.0001375 - 0.000104125 $$\n$$ A = 0.000033375\\,\\mathrm{m}^2 $$\n这个计算可以用梯形的几何面积公式来验证：面积 $= \\frac{1}{2}(\\text{高}_1 + \\text{高}_2) \\times \\text{宽}$。\n宽度 $w = 0.01 - 0.007 = 0.003\\,\\mathrm{m}$。\n高度分别为 $h_1 = 0.01225\\,\\mathrm{m}$（在 $x=0.007$ 处）和 $h_2 = 0.01\\,\\mathrm{m}$（在 $x=0.01$ 处）。\n$$ A = \\frac{1}{2}(0.01225 + 0.01)(0.003) = \\frac{1}{2}(0.02225)(0.003) = 0.011125 \\times 0.003 = 0.000033375\\,\\mathrm{m}^2 $$\n结果匹配。\n\n最后，我们将面积 $A$ 乘以单元深度 $\\Delta z$ 来计算体积通量 $F$：\n$$ F = A \\times \\Delta z = (0.000033375\\,\\mathrm{m}^2) \\times (0.01\\,\\mathrm{m}) $$\n$$ F = 0.00000033375\\,\\mathrm{m}^3 $$\n用科学记数法表示，即为 $F = 3.3375 \\times 10^{-7}\\,\\mathrm{m}^3$。\n题目要求答案四舍五入到五位有效数字。计算出的值 $3.3375 \\times 10^{-7}$ 已经恰好是五位有效数字。",
            "answer": "$$\n\\boxed{3.3375 \\times 10^{-7}}\n$$"
        }
    ]
}