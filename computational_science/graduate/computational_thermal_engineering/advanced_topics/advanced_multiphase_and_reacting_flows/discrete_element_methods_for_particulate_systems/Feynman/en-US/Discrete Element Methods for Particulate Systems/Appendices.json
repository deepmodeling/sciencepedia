{
    "hands_on_practices": [
        {
            "introduction": "The core of any Discrete Element Method (DEM) simulation lies in its time integration scheme, the numerical engine that advances particle states through time. The Velocity-Verlet algorithm is a cornerstone of molecular and granular dynamics, lauded for its excellent energy conservation properties, second-order accuracy, and minimal memory requirements. This practice requires you to derive the Velocity-Verlet integrator from first principles, analyze its numerical stability, and implement it to solve for particle trajectories . Mastering this integrator provides a fundamental understanding of the mechanics behind a DEM simulation and the critical role of the time step in ensuring a stable and accurate solution.",
            "id": "3947654",
            "problem": "A system of rigid spherical particles is modeled by Discrete Element Methods (DEM), where interactions and motion are described by Newton’s laws. Consider a single rigid spherical particle with mass $m$ and moment of inertia $I$ about its center. Let $\\mathbf{x}(t)$ denote the particle position, $\\mathbf{v}(t)$ its linear velocity, $\\boldsymbol{\\omega}(t)$ its angular velocity, and $\\boldsymbol{\\theta}(t)$ its orientation vector expressed in radians. The net force $\\mathbf{F}$ and torque $\\boldsymbol{\\tau}$ arise from interactions such as springs and contacts, possibly with no-slip constraints, but for the purpose of this problem they are deterministic and depend at most on positions and orientations at each time. The fundamental base is Newton’s second law for translation and rotation:\n$$m \\,\\frac{d^2 \\mathbf{x}}{dt^2} = \\mathbf{F}(\\mathbf{x}, t), \\quad I \\,\\frac{d \\boldsymbol{\\omega}}{dt} = \\boldsymbol{\\tau}(\\boldsymbol{\\theta}, t),$$\nwith the kinematic relation\n$$\\frac{d \\boldsymbol{\\theta}}{dt} = \\boldsymbol{\\omega}.$$\n\nYour tasks are:\n1. Derive, from first principles, a Velocity-Verlet time integration scheme for DEM that updates positions $\\mathbf{x}$, linear velocities $\\mathbf{v}$, and angular velocities $\\boldsymbol{\\omega}$ over a time step $\\Delta t$. The derivation must begin from the fundamental laws above, without introducing any shortcut formulas. The derivation should clearly state and use the accelerations $\\mathbf{a}(t) = \\mathbf{F}(\\mathbf{x}(t), t)/m$ and angular accelerations $\\boldsymbol{\\alpha}(t) = \\boldsymbol{\\tau}(\\boldsymbol{\\theta}(t), t)/I$, and must produce explicit update formulas for $\\mathbf{x}^{n+1}$, $\\mathbf{v}^{n+1}$, and $\\boldsymbol{\\omega}^{n+1}$ from values at time step $n$.\n2. Discuss the formal order of accuracy and stability properties of the scheme for position-dependent forces and torques, including a linear stability analysis for a one-dimensional harmonic oscillator defined by $m \\, d^2 x/dt^2 = -k x$ and its rotational analog $I \\, d^2 \\theta/dt^2 = -k_t \\theta$. Clearly state the stability condition in terms of the natural angular frequency and $\\Delta t$. All angles must be expressed in radians.\n3. Implement a complete, runnable program that applies the derived Velocity-Verlet scheme to the following scientifically realistic test suite. Use the International System of Units (SI): mass in $\\mathrm{kg}$, stiffness in $\\mathrm{N/m}$, moment of inertia in $\\mathrm{kg\\,m^2}$, time in $\\mathrm{s}$, torque stiffness in $\\mathrm{N\\,m/rad}$, and angles in radians. The program must produce quantitative outputs as specified.\n\nTest Suite:\n- Accuracy tests (single-step local truncation error for position-dependent forces and torques):\n    - Translational harmonic oscillator: $m = 1.0$, $k = 100.0$, initial position $x_0 = 0.1$ $\\mathrm{m}$, initial velocity $v_0 = 0.0$ $\\mathrm{m/s}$, time steps $\\Delta t_1 = 0.01$ $\\mathrm{s}$ and $\\Delta t_2 = 0.005$ $\\mathrm{s}$. Compute the exact solution after one step using $x(t) = x_0 \\cos(\\omega t) + v_0 \\frac{\\sin(\\omega t)}{\\omega}$ and $v(t) = -x_0 \\omega \\sin(\\omega t) + v_0 \\cos(\\omega t)$ with $\\omega = \\sqrt{k/m}$. Measure the absolute errors $\\varepsilon_x(\\Delta t)$ and $\\varepsilon_v(\\Delta t)$ after one Velocity-Verlet step for $\\Delta t_1$ and $\\Delta t_2$, then report the ratios $\\varepsilon_x(\\Delta t_1)/\\varepsilon_x(\\Delta t_2)$ and $\\varepsilon_v(\\Delta t_1)/\\varepsilon_v(\\Delta t_2)$ as floats.\n    - Rotational harmonic oscillator: $I = 0.004$, $k_t = 0.5$, initial orientation $\\theta_0 = 0.1$ $\\mathrm{rad}$, initial angular velocity $\\omega_0 = 0.0$ $\\mathrm{rad/s}$, time steps $\\Delta t_1 = 0.01$ $\\mathrm{s}$ and $\\Delta t_2 = 0.005$ $\\mathrm{s}$. Use $\\theta(t) = \\theta_0 \\cos(\\Omega t) + \\omega_0 \\frac{\\sin(\\Omega t)}{\\Omega}$ and $\\omega(t) = -\\theta_0 \\Omega \\sin(\\Omega t) + \\omega_0 \\cos(\\Omega t)$ with $\\Omega = \\sqrt{k_t/I}$. Measure the absolute error in angular velocity $\\varepsilon_\\omega(\\Delta t)$ after one Velocity-Verlet step for both time steps and report the ratio $\\varepsilon_\\omega(\\Delta t_1)/\\varepsilon_\\omega(\\Delta t_2)$ as a float.\n\n- Stability tests (boundedness over many steps for a harmonic oscillator):\n    - Translational harmonic oscillator with $m = 1.0$, $k = 100.0$, initial condition $x_0 = 0.1$ $\\mathrm{m}$, $v_0 = 0.0$ $\\mathrm{m/s}$. Simulate for $N = 2000$ steps using the Velocity-Verlet scheme with three time steps: $\\Delta t_{\\text{small}} = 0.05$ $\\mathrm{s}$, $\\Delta t_{\\text{border}} = 0.2$ $\\mathrm{s}$, and $\\Delta t_{\\text{large}} = 0.25$ $\\mathrm{s}$. Define boundedness as the maximum absolute position over the simulation not exceeding $10$ times the initial absolute position and no numerical overflow. For each time step, output a boolean indicating whether the motion remains bounded.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list should contain six entries in the following order: $[\\varepsilon_x(\\Delta t_1)/\\varepsilon_x(\\Delta t_2), \\varepsilon_v(\\Delta t_1)/\\varepsilon_v(\\Delta t_2), \\varepsilon_\\omega(\\Delta t_1)/\\varepsilon_\\omega(\\Delta t_2), \\text{bounded}(\\Delta t_{\\text{small}}), \\text{bounded}(\\Delta t_{\\text{border}}), \\text{bounded}(\\Delta t_{\\text{large}})]$. All three ratios must be floats, and the three boundedness indicators must be booleans. The program must not read any input and must be fully self-contained.",
            "solution": "The problem statement is evaluated as valid. It is scientifically grounded in the principles of Newtonian mechanics and numerical analysis, specifically concerning the Discrete Element Method (DEM). The problem is well-posed, with all necessary parameters and conditions provided to derive a unique, meaningful solution. The language is objective and unambiguous. A complete solution is therefore provided.\n\n### 1. Derivation of the Velocity-Verlet Integration Scheme\n\nThe Velocity-Verlet algorithm is derived from Taylor series expansions of the position, $\\mathbf{x}(t)$, and velocity, $\\mathbf{v}(t)$. The fundamental equations of motion are given as:\n$$m \\frac{d^2 \\mathbf{x}}{dt^2} = \\mathbf{F}(\\mathbf{x}, t) \\implies \\frac{d\\mathbf{v}}{dt} = \\mathbf{a}(\\mathbf{x}, t)$$\n$$I \\frac{d \\boldsymbol{\\omega}}{dt} = \\boldsymbol{\\tau}(\\boldsymbol{\\theta}, t) \\implies \\frac{d\\boldsymbol{\\omega}}{dt} = \\boldsymbol{\\alpha}(\\boldsymbol{\\theta}, t)$$\nwhere $\\mathbf{a}(t)$ is the linear acceleration and $\\boldsymbol{\\alpha}(t)$ is the angular acceleration. The kinematic relation is $\\frac{d\\mathbf{x}}{dt} = \\mathbf{v}$ and $\\frac{d\\boldsymbol{\\theta}}{dt} = \\boldsymbol{\\omega}$.\n\nLet the state of the system at time $t_n = n \\Delta t$ be $(\\mathbf{x}^n, \\mathbf{v}^n, \\boldsymbol{\\theta}^n, \\boldsymbol{\\omega}^n)$. We seek the state at time $t_{n+1} = t_n + \\Delta t$.\n\n**Step 1: Position and Orientation Update**\nWe start with the Taylor series expansion for the position vector $\\mathbf{x}(t)$ around time $t_n$:\n$$\\mathbf{x}(t_n + \\Delta t) = \\mathbf{x}(t_n) + \\frac{d\\mathbf{x}}{dt}\\bigg|_{t_n} \\Delta t + \\frac{1}{2} \\frac{d^2\\mathbf{x}}{dt^2}\\bigg|_{t_n} \\Delta t^2 + O(\\Delta t^3)$$\nSubstituting the kinematic relation $\\mathbf{v} = d\\mathbf{x}/dt$ and the definition of acceleration $\\mathbf{a} = d^2\\mathbf{x}/dt^2$:\n$$\\mathbf{x}^{n+1} \\approx \\mathbf{x}^n + \\mathbf{v}^n \\Delta t + \\frac{1}{2} \\mathbf{a}^n \\Delta t^2$$\nThis is the position update formula, which is accurate to second order. The local error is $O(\\Delta t^3)$.\n\nAn identical derivation applies to the orientation vector $\\boldsymbol{\\theta}$, replacing linear quantities with their rotational counterparts:\n$$\\boldsymbol{\\theta}^{n+1} \\approx \\boldsymbol{\\theta}^n + \\boldsymbol{\\omega}^n \\Delta t + \\frac{1}{2} \\boldsymbol{\\alpha}^n \\Delta t^2$$\n\n**Step 2: Velocity and Angular Velocity Update**\nTo update the velocity, we use the Taylor expansion for $\\mathbf{v}(t)$ around $t_n$:\n$$\\mathbf{v}(t_n + \\Delta t) = \\mathbf{v}(t_n) + \\frac{d\\mathbf{v}}{dt}\\bigg|_{t_n} \\Delta t + O(\\Delta t^2) = \\mathbf{v}^n + \\mathbf{a}^n \\Delta t + O(\\Delta t^2)$$\nThis is a simple forward Euler step and is only first-order accurate. The key to the Velocity-Verlet scheme is to improve this accuracy by averaging the accelerations at the beginning and end of the time step.\n$$\\mathbf{v}^{n+1} \\approx \\mathbf{v}^n + \\frac{\\mathbf{a}^n + \\mathbf{a}^{n+1}}{2} \\Delta t$$\nTo use this formula, we need the acceleration $\\mathbf{a}^{n+1} = \\mathbf{a}(\\mathbf{x}^{n+1}, t_{n+1})$, which depends on the yet-to-be-calculated position $\\mathbf{x}^{n+1}$. This suggests the following sequence of operations:\n1.  Compute the new position $\\mathbf{x}^{n+1}$ using the formula from Step 1.\n2.  Use the new position $\\mathbf{x}^{n+1}$ to calculate the force $\\mathbf{F}(\\mathbf{x}^{n+1}, t_{n+1})$ and thus the new acceleration $\\mathbf{a}^{n+1}$.\n3.  Compute the new velocity $\\mathbf{v}^{n+1}$ using the averaged acceleration formula.\n\nThe complete Velocity-Verlet algorithm for one time step is:\n1.  Update positions: $\\mathbf{x}^{n+1} = \\mathbf{x}^{n} + \\mathbf{v}^{n}\\Delta t + \\frac{1}{2}\\mathbf{a}^{n}\\Delta t^2$.\n2.  Calculate new accelerations: $\\mathbf{a}^{n+1} = \\mathbf{F}(\\mathbf{x}^{n+1}, t_{n+1})/m$.\n3.  Update velocities: $\\mathbf{v}^{n+1} = \\mathbf{v}^{n} + \\frac{1}{2}(\\mathbf{a}^{n} + \\mathbf{a}^{n+1})\\Delta t$.\n\nThe same logic applies to the rotational dynamics:\n1.  Update orientations: $\\boldsymbol{\\theta}^{n+1} = \\boldsymbol{\\theta}^{n} + \\boldsymbol{\\omega}^{n}\\Delta t + \\frac{1}{2}\\boldsymbol{\\alpha}^{n}\\Delta t^2$.\n2.  Calculate new angular accelerations: $\\boldsymbol{\\alpha}^{n+1} = \\boldsymbol{\\tau}(\\boldsymbol{\\theta}^{n+1}, t_{n+1})/I$.\n3.  Update angular velocities: $\\boldsymbol{\\omega}^{n+1} = \\boldsymbol{\\omega}^{n} + \\frac{1}{2}(\\boldsymbol{\\alpha}^{n} + \\boldsymbol{\\alpha}^{n+1})\\Delta t$.\n\n### 2. Accuracy and Stability Analysis\n\n**Order of Accuracy**\nThe local truncation error is the error incurred in a single step, assuming the state at time $t_n$ is exact.\nFor position, the Taylor expansion gives:\n$$ \\mathbf{x}_{\\text{exact}}(t_n+\\Delta t) = \\mathbf{x}^n + \\mathbf{v}^n \\Delta t + \\frac{1}{2} \\mathbf{a}^n \\Delta t^2 + \\frac{1}{6} \\dot{\\mathbf{a}}^n \\Delta t^3 + O(\\Delta t^4) $$\nThe numerical position is $\\mathbf{x}^{n+1} = \\mathbf{x}^n + \\mathbf{v}^n \\Delta t + \\frac{1}{2} \\mathbf{a}^n \\Delta t^2$. The local error is therefore $E_x = \\mathbf{x}_{\\text{exact}}^{n+1} - \\mathbf{x}^{n+1} = \\frac{1}{6} \\dot{\\mathbf{a}}^n \\Delta t^3 + O(\\Delta t^4)$. The position update has a local error of $O(\\Delta t^3)$. However, for the specific test case of a harmonic oscillator starting from rest ($v_0=0$), we have $\\dot{\\mathbf{a}} = (d\\mathbf{a}/d\\mathbf{x})\\mathbf{v}$, so $\\dot{\\mathbf{a}}(t=0) = 0$. The leading error term vanishes, and the error becomes $E_x = \\frac{1}{24}\\ddot{\\mathbf{a}}^n \\Delta t^4 + O(\\Delta t^5)$, which is $O(\\Delta t^4)$.\n\nFor velocity, we expand $\\mathbf{a}^{n+1}$ around $t_n$:\n$$ \\mathbf{a}^{n+1} = \\mathbf{a}(\\mathbf{x}^{n+1}) \\approx \\mathbf{a}(\\mathbf{x}^n + \\mathbf{v}^n\\Delta t + \\dots) \\approx \\mathbf{a}^n + \\frac{d\\mathbf{a}}{dt}\\bigg|_{t_n} \\Delta t + O(\\Delta t^2) = \\mathbf{a}^n + \\dot{\\mathbf{a}}^n \\Delta t + O(\\Delta t^2) $$\nSubstituting this into the velocity update rule:\n$$ \\mathbf{v}^{n+1} = \\mathbf{v}^n + \\frac{1}{2}(\\mathbf{a}^n + \\mathbf{a}^n + \\dot{\\mathbf{a}}^n \\Delta t + O(\\Delta t^2)) \\Delta t = \\mathbf{v}^n + \\mathbf{a}^n \\Delta t + \\frac{1}{2} \\dot{\\mathbf{a}}^n \\Delta t^2 + O(\\Delta t^3) $$\nThe exact velocity is $\\mathbf{v}_{\\text{exact}}(t_n+\\Delta t) = \\mathbf{v}^n + \\mathbf{a}^n\\Delta t + \\frac{1}{2}\\dot{\\mathbf{a}}^n\\Delta t^2 + \\frac{1}{6}\\ddot{\\mathbf{a}}^n\\Delta t^3 + O(\\Delta t^4)$. The local error is $E_v = \\mathbf{v}^{n+1} - \\mathbf{v}_{\\text{exact}}^{n+1} = - \\frac{1}{6}\\ddot{\\mathbf{a}}^n\\Delta t^3 + O(\\Delta t^4)$, neglecting the error contribution from the expansion of $\\mathbf{a}^{n+1}$. A more careful analysis shows $E_v \\sim O(\\Delta t^3)$.\nThe local errors for position and velocity are $O(\\Delta t^3)$. For the specific case where $\\dot{\\mathbf{a}}(0)=0$, the position error is $O(\\Delta t^4)$. The global error for the scheme is one order lower, making it a second-order method, $O(\\Delta t^2)$.\n\n**Linear Stability Analysis**\nWe analyze the one-dimensional harmonic oscillator, $m \\ddot{x} = -k x$, or $\\ddot{x} = -\\omega^2 x$, where $\\omega = \\sqrt{k/m}$. The Velocity-Verlet equations are:\n1. $x_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a_n \\Delta t^2 = x_n + v_n \\Delta t - \\frac{1}{2} \\omega^2 x_n \\Delta t^2$\n2. $v_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t = v_n - \\frac{1}{2} \\omega^2 (x_n + x_{n+1}) \\Delta t$\nWe can represent this system as a matrix transformation on the state vector $\\begin{pmatrix} x_n & v_n \\end{pmatrix}^T$. Substituting $x_{n+1}$ from (1) into (2) gives the system matrix, or amplification matrix, $\\mathbf{M}$:\n$$\n\\begin{pmatrix} x_{n+1} \\\\ v_{n+1} \\end{pmatrix} = \\mathbf{M} \\begin{pmatrix} x_n \\\\ v_n \\end{pmatrix} = \n\\begin{pmatrix} 1 - \\frac{1}{2} (\\omega \\Delta t)^2 & \\Delta t \\\\ -\\omega^2 \\Delta t (1 - \\frac{1}{4} (\\omega \\Delta t)^2) & 1 - \\frac{1}{2} (\\omega \\Delta t)^2 \\end{pmatrix}\n\\begin{pmatrix} x_n \\\\ v_n \\end{pmatrix}\n$$\nThe system is stable if the eigenvalues $\\lambda$ of $\\mathbf{M}$ satisfy $|\\lambda| \\le 1$. The eigenvalues are solutions to the characteristic equation $\\lambda^2 - \\text{Tr}(\\mathbf{M})\\lambda + \\det(\\mathbf{M}) = 0$.\nThe trace is $\\text{Tr}(\\mathbf{M}) = 2 - (\\omega \\Delta t)^2$. The determinant is $\\det(\\mathbf{M}) = 1$. The equation becomes:\n$$ \\lambda^2 - (2 - (\\omega \\Delta t)^2)\\lambda + 1 = 0 $$\nFor the eigenvalues to lie on the unit circle (i.e., $|\\lambda|=1$ and non-growing oscillations), the discriminant of this quadratic equation must be non-positive:\n$$ (2 - (\\omega \\Delta t)^2)^2 - 4 \\le 0 \\implies -2 \\le 2 - (\\omega \\Delta t)^2 \\le 2 $$\nThe right inequality, $-(\\omega \\Delta t)^2 \\le 0$, is always true. The left inequality gives the stability condition:\n$$ (\\omega \\Delta t)^2 \\le 4 \\implies \\omega \\Delta t \\le 2 $$\nThus, the Velocity-Verlet scheme is conditionally stable for the harmonic oscillator. The time step $\\Delta t$ must be chosen such that it is less than or equal to $2/\\omega$, where $\\omega$ is the highest natural frequency in the system. The same condition, $\\Omega \\Delta t \\le 2$, applies to the rotational oscillator.\n\n### 3. Implementation and Test Suite Results\n\nThe provided Python code implements the derived Velocity-Verlet algorithm and applies it to the specified test suite.\n\n**Accuracy Tests**\n- **Translational Oscillator:** $m=1.0$, $k=100.0$, so $\\omega=10.0$ rad/s. Initial conditions are $x_0=0.1, v_0=0.0$. Since $v_0=0$, we have $\\dot{a}(0)=0$. The local truncation error for position is expected to be $O(\\Delta t^4)$, and for velocity, $O(\\Delta t^3)$. When halving the time step from $\\Delta t_1$ to $\\Delta t_2$, the position error should decrease by a factor of $(2)^4=16$, and the velocity error by a factor of $(2)^3=8$.\n- **Rotational Oscillator:** $I=0.004$, $k_t=0.5$, so $\\Omega=\\sqrt{125} \\approx 11.18$ rad/s. Initial conditions are $\\theta_0=0.1, \\omega_0=0.0$. The local truncation error for angular velocity is $O(\\Delta t^3)$, so the error ratio is expected to be $(2)^3=8$.\n\n**Stability Tests**\nThe stability condition is $\\Delta t \\le 2/\\omega = 2/10.0 = 0.2$ s.\n- $\\Delta t_{\\text{small}} = 0.05$ s: $\\omega \\Delta t = 0.5 < 2$. The simulation is expected to be stable and bounded.\n- $\\Delta t_{\\text{border}} = 0.2$ s: $\\omega \\Delta t = 2.0$. The simulation is at the limit of stability. The energy should be conserved, and the motion should remain bounded.\n- $\\Delta t_{\\text{large}} = 0.25$ s: $\\omega \\Delta t = 2.5 > 2$. The simulation is expected to be unstable, with the amplitude growing exponentially and eventually overflowing or exceeding the specified bound.\n\nThe code computes the results for these tests and formats them as requested.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, analyzes, and implements the Velocity-Verlet integration scheme\n    for a DEM problem, as specified in the problem statement.\n    \"\"\"\n\n    # --- Part 1: Accuracy Tests ---\n\n    # --- Translational Harmonic Oscillator ---\n    m_t = 1.0\n    k_t = 100.0\n    x0_t = 0.1\n    v0_t = 0.0\n    dt_t1 = 0.01\n    dt_t2 = 0.005\n\n    omega_t = np.sqrt(k_t / m_t)\n\n    def run_trans_step(x0, v0, dt, k, m):\n        # Initial acceleration\n        a0 = -k * x0 / m\n        # Update position\n        x1 = x0 + v0 * dt + 0.5 * a0 * dt**2\n        # Update acceleration\n        a1 = -k * x1 / m\n        # Update velocity\n        v1 = v0 + 0.5 * (a0 + a1) * dt\n        return x1, v1\n    \n    # Numerical results for one step\n    x1_num_dt1, v1_num_dt1 = run_trans_step(x0_t, v0_t, dt_t1, k_t, m_t)\n    x1_num_dt2, v1_num_dt2 = run_trans_step(x0_t, v0_t, dt_t2, k_t, m_t)\n\n    # Exact solutions after one step\n    x1_exact_dt1 = x0_t * np.cos(omega_t * dt_t1)\n    v1_exact_dt1 = -x0_t * omega_t * np.sin(omega_t * dt_t1)\n    x1_exact_dt2 = x0_t * np.cos(omega_t * dt_t2)\n    v1_exact_dt2 = -x0_t * omega_t * np.sin(omega_t * dt_t2)\n\n    # Absolute errors\n    eps_x_dt1 = np.abs(x1_num_dt1 - x1_exact_dt1)\n    eps_v_dt1 = np.abs(v1_num_dt1 - v1_exact_dt1)\n    eps_x_dt2 = np.abs(x1_num_dt2 - x1_exact_dt2)\n    eps_v_dt2 = np.abs(v1_num_dt2 - v1_exact_dt2)\n\n    # Ratios of errors\n    ratio_x = eps_x_dt1 / eps_x_dt2\n    ratio_v = eps_v_dt1 / eps_v_dt2\n\n    # --- Rotational Harmonic Oscillator ---\n    I_r = 0.004\n    kt_r = 0.5\n    theta0_r = 0.1\n    omega0_r = 0.0\n    dt_r1 = 0.01\n    dt_r2 = 0.005\n\n    Omega_r = np.sqrt(kt_r / I_r)\n\n    def run_rot_step(theta0, omega0, dt, kt, I):\n        # Initial angular acceleration\n        alpha0 = -kt * theta0 / I\n        # Update orientation (though not explicitly needed for omega error)\n        theta1 = theta0 + omega0 * dt + 0.5 * alpha0 * dt**2\n        # Update angular acceleration\n        alpha1 = -kt * theta1 / I\n        # Update angular velocity\n        omega1 = omega0 + 0.5 * (alpha0 + alpha1) * dt\n        return omega1\n\n    # Numerical omega after one step\n    omega1_num_dt1 = run_rot_step(theta0_r, omega0_r, dt_r1, kt_r, I_r)\n    omega1_num_dt2 = run_rot_step(theta0_r, omega0_r, dt_r2, kt_r, I_r)\n\n    # Exact omega after one step\n    omega1_exact_dt1 = -theta0_r * Omega_r * np.sin(Omega_r * dt_r1)\n    omega1_exact_dt2 = -theta0_r * Omega_r * np.sin(Omega_r * dt_r2)\n\n    # Absolute errors\n    eps_omega_dt1 = np.abs(omega1_num_dt1 - omega1_exact_dt1)\n    eps_omega_dt2 = np.abs(omega1_num_dt2 - omega1_exact_dt2)\n\n    # Ratio of errors\n    ratio_omega = eps_omega_dt1 / eps_omega_dt2\n\n\n    # --- Part 2: Stability Tests ---\n    \n    # Parameters for stability test\n    m_s = 1.0\n    k_s = 100.0\n    x0_s = 0.1\n    v0_s = 0.0\n    N_s = 2000\n    dt_small = 0.05\n    dt_border = 0.2\n    dt_large = 0.25\n    dts_s = [dt_small, dt_border, dt_large]\n    \n    boundedness_results = []\n    \n    def check_boundedness(dt, k, m, x0, v0, N):\n        x = x0\n        v = v0\n        max_abs_x = np.abs(x0)\n        bound = 10.0 * np.abs(x0)\n        \n        for _ in range(N):\n            # Velocity-Verlet update\n            a = -k * x / m\n            x_new = x + v * dt + 0.5 * a * dt**2\n            a_new = -k * x_new / m\n            v_new = v + 0.5 * (a + a_new) * dt\n            \n            x, v = x_new, v_new\n            \n            # Check for overflow and bound\n            if not np.isfinite(x):\n                return False\n            \n            if np.abs(x) > max_abs_x:\n                max_abs_x = np.abs(x)\n            \n            if max_abs_x > bound:\n                return False\n                \n        return True\n\n    for dt_val in dts_s:\n        is_bounded = check_boundedness(dt_val, k_s, m_s, x0_s, v0_s, N_s)\n        boundedness_results.append(is_bounded)\n        \n    is_bounded_small, is_bounded_border, is_bounded_large = boundedness_results\n\n    # Final result assembly\n    results = [\n        ratio_x, \n        ratio_v, \n        ratio_omega, \n        is_bounded_small, \n        is_bounded_border, \n        is_bounded_large\n    ]\n\n    # Final print statement in the exact required format.\n    print(f\"[{results[0]},{results[1]},{results[2]},{str(results[3]).lower()},{str(results[4]).lower()},{str(results[5]).lower()}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "With a robust integration scheme established, the next critical element is the force law that describes particle interactions. The classical Hertzian theory provides a precise nonlinear model for the elastic force between contacting spheres, but its computational expense can be a bottleneck in large-scale simulations. This practice delves into the essential engineering trade-off between accuracy and efficiency by tasking you with creating a linearized contact model and quantifying its deviation from the full Hertzian solution . This comparative analysis is a vital exercise in model validation, teaching you to assess the impact of simplifying assumptions on simulation fidelity.",
            "id": "3947595",
            "problem": "Consider the Discrete Element Method (DEM) applied to frictionless, elastic, normal contact between two spherical particles. In computational thermal engineering, such contact laws govern mechanical contact and influence thermal contact conductance. You are asked to validate a linearized stiffness model against a nonlinear contact model derived under the assumptions of small deformation, isotropic linear elasticity, and non-adhesive contact between spheres. The nonlinear model shall be based on the classical elastic contact theory for spheres, and the linearized model shall be constructed by first-order Taylor expansion around a specified reference overlap. Your task is to compute and compare force-displacement curves and quantify the error introduced by the linearization.\n\nStarting from the fundamental base consisting of Newtonian mechanics and widely accepted small-deformation elastic contact theory, proceed as follows:\n\n1. For two spheres with Young’s moduli $E_1$ and $E_2$, Poisson’s ratios $\\nu_1$ and $\\nu_2$, and radii $R_1$ and $R_2$, derive the effective elastic modulus $E^\\ast$ and the effective radius $R^\\ast$ for normal contact between the spheres.\n2. Let the normal approach (overlap) be $\\delta \\ge 0$, with $\\delta$ expressed in meters (m). The nonlinear normal contact force model shall be the elastic contact law for spheres, expressed in terms of $E^\\ast$, $R^\\ast$, and $\\delta$. Construct the linearized model by performing a first-order Taylor expansion of the nonlinear force with respect to $\\delta$ about a reference overlap $\\delta_{\\mathrm{ref}}$, so that the linearized model matches both force and tangent stiffness at $\\delta_{\\mathrm{ref}}$.\n3. For each test case, sample the overlap $\\delta$ over a uniformly spaced grid on the interval $[\\delta_{\\min}, \\delta_{\\max}]$, where $\\delta_{\\min}$ is strictly positive to avoid division by zero in relative error evaluation. Use $\\delta_{\\min} = \\delta_{\\max}/N_{\\mathrm{s}}$, where $N_{\\mathrm{s}}$ is the number of samples.\n4. For each sampled $\\delta$, compute the nonlinear force (in newtons, N) and the linearized force (in newtons, N). Quantify the linearization error using the pointwise dimensionless relative error defined as the absolute difference divided by the nonlinear force. Aggregate these into two metrics per test case:\n   - The root-mean-square relative error over the sampled $\\delta$ values.\n   - The maximum relative error over the sampled $\\delta$ values.\n5. Express all inputs in International System of Units (SI). Radii $R_1$, $R_2$ are in meters (m), Young’s modulus $E$ is in pascals (Pa), overlap $\\delta$ is in meters (m), and force is in newtons (N). The relative error metrics are dimensionless numbers. Your program must output these metrics as decimal floating-point numbers rounded to six decimal places.\n\nTest suite:\nUse the following five scientifically plausible test cases intended to probe a range of material stiffnesses, particle sizes, and linearization reference overlaps. For each case, set $\\delta_{\\mathrm{ref}} = f_{\\mathrm{ref}} \\, \\delta_{\\max}$ and $\\delta_{\\min} = \\delta_{\\max}/N_{\\mathrm{s}}$.\n\n- Case A (typical stiff contact, equal materials and sizes):\n  - $E_1 = 200 \\times 10^9$ Pa, $\\nu_1 = 0.30$, $E_2 = 200 \\times 10^9$ Pa, $\\nu_2 = 0.30$\n  - $R_1 = 0.005$ m, $R_2 = 0.005$ m\n  - $\\delta_{\\max} = 5 \\times 10^{-6}$ m, $f_{\\mathrm{ref}} = 0.5$, $N_{\\mathrm{s}} = 200$\n\n- Case B (soft contact, nearly incompressible rubber, equal materials and sizes):\n  - $E_1 = 10 \\times 10^6$ Pa, $\\nu_1 = 0.49$, $E_2 = 10 \\times 10^6$ Pa, $\\nu_2 = 0.49$\n  - $R_1 = 0.01$ m, $R_2 = 0.01$ m\n  - $\\delta_{\\max} = 50 \\times 10^{-6}$ m, $f_{\\mathrm{ref}} = 0.5$, $N_{\\mathrm{s}} = 200$\n\n- Case C (stiff-soft contact, equal sizes):\n  - $E_1 = 200 \\times 10^9$ Pa, $\\nu_1 = 0.30$, $E_2 = 10 \\times 10^6$ Pa, $\\nu_2 = 0.49$\n  - $R_1 = 0.002$ m, $R_2 = 0.002$ m\n  - $\\delta_{\\max} = 2 \\times 10^{-6}$ m, $f_{\\mathrm{ref}} = 0.5$, $N_{\\mathrm{s}} = 200$\n\n- Case D (stiff contact, small particles, linearization near the lower end of the range):\n  - $E_1 = 200 \\times 10^9$ Pa, $\\nu_1 = 0.30$, $E_2 = 200 \\times 10^9$ Pa, $\\nu_2 = 0.30$\n  - $R_1 = 0.001$ m, $R_2 = 0.001$ m\n  - $\\delta_{\\max} = 1 \\times 10^{-6}$ m, $f_{\\mathrm{ref}} = 0.1$, $N_{\\mathrm{s}} = 200$\n\n- Case E (stiff contact, moderate particles, linearization near the upper end of the range):\n  - $E_1 = 200 \\times 10^9$ Pa, $\\nu_1 = 0.30$, $E_2 = 200 \\times 10^9$ Pa, $\\nu_2 = 0.30$\n  - $R_1 = 0.003$ m, $R_2 = 0.003$ m\n  - $\\delta_{\\max} = 3 \\times 10^{-6}$ m, $f_{\\mathrm{ref}} = 0.9$, $N_{\\mathrm{s}} = 200$\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, output the root-mean-square relative error followed immediately by the maximum relative error (two numbers per case), both rounded to six decimal places. The overall output must therefore be a flat list of $10$ numbers in the order of Cases A through E, for example, $\\left[ \\text{A\\_rms}, \\text{A\\_max}, \\text{B\\_rms}, \\text{B\\_max}, \\ldots, \\text{E\\_rms}, \\text{E\\_max} \\right]$.",
            "solution": "The posed problem requires the validation of a linearized normal contact force model against the classical nonlinear Hertzian contact theory for two elastic spheres. This task is relevant to computational methods like the Discrete Element Method (DEM), where simplified force laws can significantly reduce computational expense. The analysis involves deriving the force models, sampling them over a specified range of overlaps, and quantifying the linearization error.\n\nThe problem is scientifically grounded, well-posed, and all necessary parameters and procedures are provided. It is based on established principles of contact mechanics and numerical analysis. Therefore, the problem is deemed valid and a full solution is presented below.\n\n**1. Theoretical Formulation of Contact Models**\n\nThe interaction between two contacting elastic spheres is described by their material properties (Young's modulus $E$ and Poisson's ratio $\\nu$) and their geometry (radii $R$). Subscripts $1$ and $2$ denote the two spheres.\n\n**1.1. Effective Material and Geometric Properties**\n\nThe response of the two-sphere system can be simplified by defining an effective Young's modulus, $E^\\ast$, and an effective radius, $R^\\ast$. These parameters combine the properties of both spheres into equivalent values for a sphere-on-flat-plane contact problem.\n\nThe effective Young's modulus, $E^\\ast$, is defined by the relation:\n$$\n\\frac{1}{E^\\ast} = \\frac{1-\\nu_1^2}{E_1} + \\frac{1-\\nu_2^2}{E_2}\n$$\nThis can be computed as:\n$$\nE^\\ast = \\left( \\frac{1-\\nu_1^2}{E_1} + \\frac{1-\\nu_2^2}{E_2} \\right)^{-1}\n$$\nThe effective radius, $R^\\ast$, is defined by the curvatures of the two spheres:\n$$\n\\frac{1}{R^\\ast} = \\frac{1}{R_1} + \\frac{1}{R_2}\n$$\nThis can be computed as:\n$$\nR^\\ast = \\left( \\frac{1}{R_1} + \\frac{1}{R_2} \\right)^{-1}\n$$\n\n**1.2. Nonlinear Normal Contact Force Model (Hertzian Theory)**\n\nUnder the assumptions of frictionless, non-adhesive, and elastic contact with small deformations, the relationship between the normal contact force, $F_{nl}$, and the normal overlap (approach), $\\delta$, is given by the Hertzian contact theory:\n$$\nF_{nl}(\\delta) = \\frac{4}{3} E^\\ast \\sqrt{R^\\ast} \\delta^{3/2} \\quad \\text{for} \\quad \\delta \\ge 0\n$$\nThe force is zero for $\\delta < 0$ (no contact). This model is nonlinear due to the power-law relationship $F_{nl} \\propto \\delta^{3/2}$.\n\n**1.3. Linearized Normal Contact Force Model**\n\nA linearized force model, $F_{lin}(\\delta)$, is constructed by performing a first-order Taylor expansion of the nonlinear force $F_{nl}(\\delta)$ about a specified reference overlap, $\\delta_{\\mathrm{ref}}$. The general form of the expansion is:\n$$\nF_{lin}(\\delta) = F_{nl}(\\delta_{\\mathrm{ref}}) + \\left. \\frac{dF_{nl}}{d\\delta} \\right|_{\\delta=\\delta_{\\mathrm{ref}}} (\\delta - \\delta_{\\mathrm{ref}})\n$$\nThis ensures that the linearized model matches both the force and the tangent stiffness of the nonlinear model at $\\delta = \\delta_{\\mathrm{ref}}$.\n\nFirst, we determine the tangent stiffness, $k_t(\\delta)$, by differentiating $F_{nl}(\\delta)$:\n$$\nk_t(\\delta) = \\frac{dF_{nl}}{d\\delta} = \\frac{d}{d\\delta} \\left( \\frac{4}{3} E^\\ast \\sqrt{R^\\ast} \\delta^{3/2} \\right) = \\frac{4}{3} E^\\ast \\sqrt{R^\\ast} \\left( \\frac{3}{2} \\delta^{1/2} \\right) = 2 E^\\ast \\sqrt{R^\\ast} \\sqrt{\\delta}\n$$\nEvaluating the force and stiffness at $\\delta_{\\mathrm{ref}}$:\n$$\nF_{nl}(\\delta_{\\mathrm{ref}}) = \\frac{4}{3} E^\\ast \\sqrt{R^\\ast} \\delta_{\\mathrm{ref}}^{3/2}\n$$\n$$\nk_t(\\delta_{\\mathrm{ref}}) = 2 E^\\ast \\sqrt{R^\\ast} \\sqrt{\\delta_{\\mathrm{ref}}}\n$$\nSubstituting these into the Taylor expansion formula:\n$$\nF_{lin}(\\delta) = \\frac{4}{3} E^\\ast \\sqrt{R^\\ast} \\delta_{\\mathrm{ref}}^{3/2} + \\left( 2 E^\\ast \\sqrt{R^\\ast} \\sqrt{\\delta_{\\mathrm{ref}}} \\right) (\\delta - \\delta_{\\mathrm{ref}})\n$$\nWe can simplify this expression by factoring out common terms:\n$$\nF_{lin}(\\delta) = E^\\ast \\sqrt{R^\\ast} \\left( \\frac{4}{3} \\delta_{\\mathrm{ref}}^{3/2} + 2\\delta\\sqrt{\\delta_{\\mathrm{ref}}} - 2\\delta_{\\mathrm{ref}}^{3/2} \\right)\n$$\n$$\nF_{lin}(\\delta) = E^\\ast \\sqrt{R^\\ast} \\left( 2\\delta\\sqrt{\\delta_{\\mathrm{ref}}} - \\frac{2}{3} \\delta_{\\mathrm{ref}}^{3/2} \\right)\n$$\nThe final form of the linearized force model is:\n$$\nF_{lin}(\\delta) = 2 E^\\ast \\sqrt{R^\\ast \\delta_{\\mathrm{ref}}} \\left( \\delta - \\frac{1}{3} \\delta_{\\mathrm{ref}} \\right)\n$$\nThis model is affine in $\\delta$, exhibiting a constant stiffness $k_t(\\delta_{\\mathrm{ref}})$.\n\n**2. Error Quantification**\n\nTo assess the accuracy of the linearization, we compute the pointwise relative error and then aggregate it into two metrics. The analysis is performed over a grid of $N_{\\mathrm{s}}$ uniformly spaced samples of overlap $\\delta$ in the interval $[\\delta_{\\min}, \\delta_{\\max}]$, where $\\delta_{\\min} = \\delta_{\\max}/N_{\\mathrms}$. The sampling starts at a strictly positive value to avoid division by zero when calculating relative error, since $F_{nl}(0) = 0$.\n\nThe pointwise dimensionless relative error, $\\epsilon(\\delta)$, is defined as:\n$$\n\\epsilon(\\delta) = \\frac{|F_{nl}(\\delta) - F_{lin}(\\delta)|}{F_{nl}(\\delta)}\n$$\nFrom these pointwise errors, two aggregate metrics are computed for each test case:\n1.  **Root-Mean-Square Relative Error (RMSRE)**: For a set of sampled overlaps $\\{\\delta_i\\}_{i=1}^{N_{\\mathrm{s}}}$, the RMSRE is given by:\n    $$\n    \\text{RMSRE} = \\sqrt{\\frac{1}{N_{\\mathrm{s}}} \\sum_{i=1}^{N_{\\mathrm{s}}} \\left( \\epsilon(\\delta_i) \\right)^2}\n    $$\n2.  **Maximum Relative Error (MRE)**: This is the maximum value of the pointwise relative error over the sampled overlaps:\n    $$\n    \\text{MRE} = \\max_{i} \\{ \\epsilon(\\delta_i) \\}\n    $$\n\n**3. Computational Procedure**\n\nThe solution is implemented as a Python script that executes the following steps for each test case provided in the problem statement:\n1.  Calculate the effective radius $R^\\ast$ and effective modulus $E^\\ast$ from the given properties of the two spheres ($R_1, \\nu_1, E_1, R_2, \\nu_2, E_2$).\n2.  Determine the parameters for the analysis range: the reference overlap $\\delta_{\\mathrm{ref}} = f_{\\mathrm{ref}} \\, \\delta_{\\max}$ and the minimum overlap $\\delta_{\\min} = \\delta_{\\max}/N_{\\mathrm{s}}$.\n3.  Generate an array of $N_{\\mathrm{s}}$ uniformly spaced $\\delta$ values from $\\delta_{\\min}$ to $\\delta_{\\max}$.\n4.  For each value in the $\\delta$ array, compute the corresponding nonlinear force $F_{nl}(\\delta)$ and linearized force $F_{lin}(\\delta)$ using the derived formulas.\n5.  Calculate the pointwise relative error $\\epsilon(\\delta)$ for all sampled points.\n6.  Compute the RMSRE and MRE from the array of pointwise errors.\n7.  Store the resulting RMSRE and MRE values.\n8.  After processing all test cases, the results are formatted into a single list and printed as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing nonlinear and linearized contact models\n    for a series of test cases.\n    \"\"\"\n\n    def compute_errors_for_case(E1, nu1, R1, E2, nu2, R2, delta_max, f_ref, Ns):\n        \"\"\"\n        Computes the RMS and max relative errors for a single test case.\n\n        Args:\n            E1, nu1, R1: Properties of sphere 1 (Young's modulus, Poisson's ratio, radius).\n            E2, nu2, R2: Properties of sphere 2.\n            delta_max (float): Maximum overlap for the analysis range.\n            f_ref (float): Factor to determine the reference overlap from delta_max.\n            Ns (int): Number of sample points.\n\n        Returns:\n            tuple: A tuple containing (rms_relative_error, max_relative_error).\n        \"\"\"\n        # Step 1: Calculate effective material and geometric properties\n        E_star = 1.0 / ((1.0 - nu1**2) / E1 + (1.0 - nu2**2) / E2)\n        \n        # Handle the case of a sphere on a flat plane (R2 -> infinity)\n        if R2 == float('inf'):\n            R_star = R1\n        else:\n            R_star = 1.0 / (1.0 / R1 + 1.0 / R2)\n\n        # Step 2: Define analysis range and reference overlap\n        delta_ref = f_ref * delta_max\n        delta_min = delta_max / Ns\n\n        # Step 3: Generate the grid of overlap values\n        delta = np.linspace(delta_min, delta_max, Ns)\n\n        # Step 4: Compute nonlinear and linearized forces\n        # Nonlinear force: F_nl = (4/3) * E* * sqrt(R*) * delta^(3/2)\n        hertz_const = (4.0 / 3.0) * E_star * np.sqrt(R_star)\n        F_nl = hertz_const * delta**1.5\n\n        # Linearized force: F_lin = 2 * E* * sqrt(R* * delta_ref) * (delta - delta_ref/3)\n        lin_const = 2.0 * E_star * np.sqrt(R_star * delta_ref)\n        F_lin = lin_const * (delta - delta_ref / 3.0)\n        \n        # Step 5: Calculate pointwise relative error\n        # The problem statement defines error as absolute difference divided by nonlinear force.\n        relative_error = np.abs(F_nl - F_lin) / F_nl\n\n        # Step 6: Compute aggregate error metrics\n        rms_relative_error = np.sqrt(np.mean(relative_error**2))\n        max_relative_error = np.max(relative_error)\n\n        return rms_relative_error, max_relative_error\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        {'E1': 200e9, 'nu1': 0.30, 'R1': 0.005, 'E2': 200e9, 'nu2': 0.30, 'R2': 0.005, \n         'delta_max': 5e-6, 'f_ref': 0.5, 'Ns': 200},\n        # Case B\n        {'E1': 10e6, 'nu1': 0.49, 'R1': 0.01, 'E2': 10e6, 'nu2': 0.49, 'R2': 0.01, \n         'delta_max': 50e-6, 'f_ref': 0.5, 'Ns': 200},\n        # Case C\n        {'E1': 200e9, 'nu1': 0.30, 'R1': 0.002, 'E2': 10e6, 'nu2': 0.49, 'R2': 0.002, \n         'delta_max': 2e-6, 'f_ref': 0.5, 'Ns': 200},\n        # Case D\n        {'E1': 200e9, 'nu1': 0.30, 'R1': 0.001, 'E2': 200e9, 'nu2': 0.30, 'R2': 0.001, \n         'delta_max': 1e-6, 'f_ref': 0.1, 'Ns': 200},\n        # Case E\n        {'E1': 200e9, 'nu1': 0.30, 'R1': 0.003, 'E2': 200e9, 'nu2': 0.30, 'R2': 0.003, \n         'delta_max': 3e-6, 'f_ref': 0.9, 'Ns': 200},\n    ]\n\n    results = []\n    for case in test_cases:\n        rms_err, max_err = compute_errors_for_case(**case)\n        results.append(f\"{rms_err:.6f}\")\n        results.append(f\"{max_err:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "To capture the full physics of many particulate systems, we must extend our mechanical model to include heat transfer. In granular materials, conductive heat transfer through the small contact areas between particles is often the dominant mode of thermal transport, creating a direct coupling between the system's mechanical and thermal states. This practice challenges you to bridge these two domains by developing a predictive model for heat conduction across a dynamically formed Hertzian contact . By connecting the contact radius from elastic theory to the thermal resistance from Fourier's law, you will build and validate a fundamental thermo-mechanical interaction model, a key step towards simulating complex industrial processes.",
            "id": "3947631",
            "problem": "Given two elastic spheres with radii, elastic moduli, Poisson ratios, thermal conductivities, and a specified normal load and temperature difference, derive from first principles a predictive model of conductive heat transfer across the contact formed by the spheres and verify a simplified Discrete Element Method (DEM) conduction model against the analytical solution. The derivation must begin with Fourier’s law of heat conduction and the Hertz theory of elastic contact, and proceed using only fundamental laws and well-tested facts.\n\nAssume that at the contact the interfacial resistance is negligible and the spheres behave locally as semi-infinite bodies for heat conduction. The physical situation is as follows: two spheres are pressed together under a normal load such that a circular contact of radius forms; one sphere is maintained at a higher uniform temperature and the other at a lower uniform temperature far from the contact. Under these assumptions, the total heat transfer across the contact depends on the contact radius and the thermal conductivities of the materials. The analytical solution for the conduction problem can be obtained by considering each sphere’s constriction (spreading) resistance and summing them in series.\n\nStart from Hertz theory to relate the normal load to the contact radius for elastic spheres, and from Fourier’s law to relate temperature gradients to heat flux. For two elastic spheres, the effective radius and effective modulus of elasticity are defined by the standard combinations for spherical contact. Use only these fundamentals to derive expressions for the contact radius and the total thermal resistance of the two-sphere system, then compute the analytical heat transfer as the temperature difference divided by the total thermal resistance.\n\nDefine a simplified Discrete Element Method (DEM) conduction model that represents each sphere’s thermal constriction as a resistor whose value scales inversely with the contact radius and the thermal conductivity, but with a model constant that may deviate from the exact analytical constant. Treat the two resistors in series to obtain the DEM-predicted total resistance and thus the DEM-predicted heat transfer.\n\nYour program must:\n- Compute the contact radius using Hertz theory for two spheres under a normal load $F$.\n- Compute the analytical total thermal resistance and the corresponding analytical heat transfer $Q_{\\mathrm{anal}}$ between the spheres for a given temperature difference $\\Delta T$.\n- Compute the DEM-predicted total thermal resistance using a model constant $C_{\\mathrm{DEM}}$ and the corresponding DEM-predicted heat transfer $Q_{\\mathrm{DEM}}$.\n- Return the relative error $\\varepsilon = \\left| Q_{\\mathrm{DEM}} - Q_{\\mathrm{anal}} \\right| / Q_{\\mathrm{anal}}$ for each test case as a floating-point number.\n\nUnits and angle specifications:\n- All lengths must be in meters ($\\mathrm{m}$).\n- All forces must be in newtons ($\\mathrm{N}$).\n- All elastic moduli must be in pascals ($\\mathrm{Pa}$).\n- All thermal conductivities must be in watts per meter-kelvin ($\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$).\n- All temperature differences must be in kelvin ($\\mathrm{K}$).\n- Angles do not appear in this problem.\n- The final heat transfer must be in watts ($\\mathrm{W}$), but the required program output is the dimensionless relative error for each test case.\n\nFundamental base and definitions to use:\n- Fourier’s law of heat conduction: $\\mathbf{q} = -k \\nabla T$, where $\\mathbf{q}$ is the heat flux vector, $k$ is the thermal conductivity, and $T$ is temperature.\n- Thermal resistance $R$ relates net heat transfer to temperature difference through $Q = \\Delta T / R$.\n- Hertz theory for elastic contact of two spheres under normal load $F$: the contact radius $a$ scales as $a = \\left( \\dfrac{3 F R_{\\mathrm{eff}}}{4 E_{\\mathrm{eff}}} \\right)^{1/3}$, where $R_{\\mathrm{eff}} = \\left( \\dfrac{1}{R_1} + \\dfrac{1}{R_2} \\right)^{-1}$ and $E_{\\mathrm{eff}} = \\left( \\dfrac{1 - \\nu_1^2}{E_1} + \\dfrac{1 - \\nu_2^2}{E_2} \\right)^{-1}$ with $E_i$ the Young’s modulus and $\\nu_i$ the Poisson ratio of sphere $i$.\n- For a semi-infinite body with a circular contact of radius $a$, the spreading resistance scales inversely with $a$ and $k$. Treat the two spheres’ resistances in series to obtain the total resistance.\n\nTest suite:\nProvide the following three test cases to verify different regimes and coverage. In each case, compute the relative error $\\varepsilon$ described above.\n\n- Case $1$ (happy path, identical materials, moderate load):\n    - $R_1 = 0.010$ $\\mathrm{m}$, $R_2 = 0.010$ $\\mathrm{m}$\n    - $E_1 = 200 \\times 10^{9}$ $\\mathrm{Pa}$, $\\nu_1 = 0.30$\n    - $E_2 = 200 \\times 10^{9}$ $\\mathrm{Pa}$, $\\nu_2 = 0.30$\n    - $k_1 = 54$ $\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$, $k_2 = 54$ $\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$\n    - $F = 50$ $\\mathrm{N}$\n    - $\\Delta T = 20$ $\\mathrm{K}$\n    - $C_{\\mathrm{DEM}} = 4.0$\n\n- Case $2$ (edge: very small load, dissimilar materials with one low conductivity):\n    - $R_1 = 0.005$ $\\mathrm{m}$, $R_2 = 0.007$ $\\mathrm{m}$\n    - $E_1 = 200 \\times 10^{9}$ $\\mathrm{Pa}$, $\\nu_1 = 0.30$\n    - $E_2 = 3 \\times 10^{9}$ $\\mathrm{Pa}$, $\\nu_2 = 0.35$\n    - $k_1 = 54$ $\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$, $k_2 = 0.25$ $\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$\n    - $F = 0.05$ $\\mathrm{N}$\n    - $\\Delta T = 5$ $\\mathrm{K}$\n    - $C_{\\mathrm{DEM}} = 3.5$\n\n- Case $3$ (edge: large load, strongly dissimilar materials):\n    - $R_1 = 0.020$ $\\mathrm{m}$, $R_2 = 0.010$ $\\mathrm{m}$\n    - $E_1 = 110 \\times 10^{9}$ $\\mathrm{Pa}$, $\\nu_1 = 0.34$\n    - $E_2 = 70 \\times 10^{9}$ $\\mathrm{Pa}$, $\\nu_2 = 0.20$\n    - $k_1 = 400$ $\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$, $k_2 = 1.4$ $\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$\n    - $F = 300$ $\\mathrm{N}$\n    - $\\Delta T = 50$ $\\mathrm{K}$\n    - $C_{\\mathrm{DEM}} = 4.2$\n\nFinal output format:\nYour program should produce a single line of output containing the relative errors for the three cases as a comma-separated list enclosed in square brackets, for example, $\\left[ \\varepsilon_1, \\varepsilon_2, \\varepsilon_3 \\right]$. The entries must be floating-point numbers. No additional text should be printed.",
            "solution": "The problem statement has been validated and is determined to be a well-posed, scientifically grounded problem in computational thermal engineering. It is free of contradictions, ambiguities, and factual errors. All necessary physical parameters and constants are provided for the given test cases. The task is to derive and implement a model for heat transfer between two spheres based on first principles and compare it to a simplified Discrete Element Method (DEM) model.\n\nThe derivation and computational procedure are as follows:\n\n**1. Contact Mechanics: Hertz Theory**\nThe mechanical interaction between two elastic spheres in contact is described by Hertz theory. This theory provides a relationship between the normal compressive force $F$ and the radius $a$ of the resulting circular contact area. This relationship is a function of the spheres' geometries and material properties.\n\nFirst, an effective radius of curvature, $R_{\\mathrm{eff}}$, is defined for the two-sphere system. For spheres with radii $R_1$ and $R_2$, this is:\n$$R_{\\mathrm{eff}} = \\left( \\frac{1}{R_1} + \\frac{1}{R_2} \\right)^{-1}$$\nSecond, an effective Young's modulus, $E_{\\mathrm{eff}}$, is defined to account for the elastic properties of both spheres. Given their respective Young's moduli, $E_1$ and $E_2$, and Poisson's ratios, $\\nu_1$ and $\\nu_2$, the effective modulus is:\n$$E_{\\mathrm{eff}} = \\left( \\frac{1 - \\nu_1^2}{E_1} + \\frac{1 - \\nu_2^2}{E_2} \\right)^{-1}$$\nWith these effective properties, Hertz's equation for the contact radius $a$ under a normal load $F$ is:\n$$a = \\left( \\frac{3 F R_{\\mathrm{eff}}}{4 E_{\\mathrm{eff}}} \\right)^{1/3}$$\n\n**2. Analytical Model of Conductive Heat Transfer**\nThe flow of heat is governed by Fourier's law, $\\mathbf{q} = -k \\nabla T$. For the specified steady-state conditions, the temperature field satisfies the Laplace equation, $\\nabla^2 T = 0$. The problem assumes that each sphere behaves as a semi-infinite body with respect to heat flow constricting to or spreading from the small contact area.\n\nFor a single semi-infinite medium with thermal conductivity $k$, the thermal resistance associated with heat flowing through an isothermal circular patch of radius $a$ on its surface is known as the constriction (or spreading) resistance, $R_{\\mathrm{const}}$. This is a standard result in heat transfer theory, given by:\n$$R_{\\mathrm{const}} = \\frac{1}{4 k a}$$\nThe problem states that the total thermal resistance of the two-sphere contact can be modeled by placing the individual constriction resistances in series. This is appropriate when the thermal resistance of the physical interface is negligible. Therefore, the total analytical thermal resistance, $R_{\\mathrm{anal}}$, is the sum of the resistances of sphere $1$ and sphere $2$:\n$$R_{\\mathrm{anal}} = R_{1, \\mathrm{anal}} + R_{2, \\mathrm{anal}} = \\frac{1}{4 k_1 a} + \\frac{1}{4 k_2 a}$$\nFactoring out the common terms, we obtain:\n$$R_{\\mathrm{anal}} = \\frac{1}{4 a} \\left( \\frac{1}{k_1} + \\frac{1}{k_2} \\right)$$\nThe total heat transfer rate, $Q$, across a thermal resistance $R$ due to a temperature difference $\\Delta T$ is given by the relation $Q = \\Delta T / R$. The analytical heat transfer rate, $Q_{\\mathrm{anal}}$, is thus:\n$$Q_{\\mathrm{anal}} = \\frac{\\Delta T}{R_{\\mathrm{anal}}} = \\frac{\\Delta T}{\\frac{1}{4 a} \\left( \\frac{1}{k_1} + \\frac{1}{k_2} \\right)}$$\n\n**3. Simplified DEM Conduction Model**\nA simplified model, typical in DEM simulations, is proposed for comparison. This model follows the same functional form as the analytical solution for thermal resistance but replaces the exact analytical constant, $4$, with a general model constant, $C_{\\mathrm{DEM}}$.\n\nThe resistance of an individual sphere $i$ in this DEM model is:\n$$R_{i, \\mathrm{DEM}} = \\frac{1}{C_{\\mathrm{DEM}} k_i a}$$\nAgain, summing the resistances in series gives the total DEM-predicted thermal resistance, $R_{\\mathrm{DEM}}$:\n$$R_{\\mathrm{DEM}} = R_{1, \\mathrm{DEM}} + R_{2, \\mathrm{DEM}} = \\frac{1}{C_{\\mathrm{DEM}} k_1 a} + \\frac{1}{C_{\\mathrm{DEM}} k_2 a}$$\nThis simplifies to:\n$$R_{\\mathrm{DEM}} = \\frac{1}{C_{\\mathrm{DEM}} a} \\left( \\frac{1}{k_1} + \\frac{1}{k_2} \\right)$$\nConsequently, the DEM-predicted heat transfer rate, $Q_{\\mathrm{DEM}}$, is:\n$$Q_{\\mathrm{DEM}} = \\frac{\\Delta T}{R_{\\mathrm{DEM}}} = \\frac{\\Delta T}{\\frac{1}{C_{\\mathrm{DEM}} a} \\left( \\frac{1}{k_1} + \\frac{1}{k_2} \\right)}$$\n\n**4. Relative Error Calculation**\nThe final step is to quantify the discrepancy between the DEM prediction and the analytical solution by calculating the relative error, $\\varepsilon$:\n$$\\varepsilon = \\frac{\\left| Q_{\\mathrm{DEM}} - Q_{\\mathrm{anal}} \\right|}{Q_{\\mathrm{anal}}}$$\nBy substituting the derived expressions for $Q_{\\mathrm{DEM}}$ and $Q_{\\mathrm{anal}}$, we can simplify this expression. Let the common term be $Z = a \\Delta T / \\left( \\frac{1}{k_1} + \\frac{1}{k_2} \\right)$. Then $Q_{\\mathrm{DEM}} = C_{\\mathrm{DEM}} \\cdot Z$ and $Q_{\\mathrm{anal}} = 4 \\cdot Z$.\n$$\\varepsilon = \\frac{\\left| C_{\\mathrm{DEM}} \\cdot Z - 4 \\cdot Z \\right|}{4 \\cdot Z} = \\frac{\\left| C_{\\mathrm{DEM}} - 4 \\right| \\cdot Z}{4 \\cdot Z}$$\nSince all physical parameters are positive, $Z > 0$, allowing it to be cancelled:\n$$\\varepsilon = \\frac{\\left| C_{\\mathrm{DEM}} - 4 \\right|}{4}$$\nThis result indicates that the relative error is solely dependent on the deviation of the DEM constant $C_{\\mathrm{DEM}}$ from the analytical constant $4$. The required program will perform the full step-by-step calculation to arrive at this error value, thereby verifying the entire modeling process.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating the relative error between an analytical\n    and a simplified DEM model for heat conduction between two elastic spheres.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple contains:\n    # (R1, R2, E1, nu1, E2, nu2, k1, k2, F, delta_T, C_dem)\n    test_cases = [\n        # Case 1 (happy path, identical materials, moderate load)\n        (0.010, 0.010, 200e9, 0.30, 200e9, 0.30, 54.0, 54.0, 50.0, 20.0, 4.0),\n        # Case 2 (edge: very small load, dissimilar materials)\n        (0.005, 0.007, 200e9, 0.30, 3e9, 0.35, 54.0, 0.25, 0.05, 5.0, 3.5),\n        # Case 3 (edge: large load, strongly dissimilar materials)\n        (0.020, 0.010, 110e9, 0.34, 70e9, 0.20, 400.0, 1.4, 300.0, 50.0, 4.2),\n    ]\n\n    def calculate_relative_error(params):\n        \"\"\"\n        Computes the relative error for a single set of parameters.\n        \"\"\"\n        R1, R2, E1, nu1, E2, nu2, k1, k2, F, delta_T, C_dem = params\n\n        # Step 1: Compute contact radius 'a' using Hertz theory.\n        \n        # Effective radius of curvature\n        R_eff = (1.0 / R1 + 1.0 / R2)**(-1.0)\n        \n        # Effective Young's modulus\n        E_eff = ((1.0 - nu1**2) / E1 + (1.0 - nu2**2) / E2)**(-1.0)\n        \n        # Contact radius\n        a = (3.0 * F * R_eff / (4.0 * E_eff))**(1.0/3.0)\n\n        # Step 2: Compute analytical heat transfer Q_anal.\n        \n        # Analytical total thermal resistance\n        R_anal = (1.0 / (4.0 * a)) * (1.0 / k1 + 1.0 / k2)\n        \n        # Analytical heat transfer\n        # Check for R_anal being zero to avoid division by zero, though physically impossible here.\n        if R_anal == 0:\n            Q_anal = float('inf') if delta_T > 0 else 0.0\n        else:\n            Q_anal = delta_T / R_anal\n            \n        # Step 3: Compute DEM-predicted heat transfer Q_dem.\n        \n        # DEM-predicted total thermal resistance\n        R_dem = (1.0 / (C_dem * a)) * (1.0 / k1 + 1.0 / k2)\n        \n        # DEM-predicted heat transfer\n        if R_dem == 0:\n            Q_dem = float('inf') if delta_T > 0 else 0.0\n        else:\n            Q_dem = delta_T / R_dem\n            \n        # Step 4: Compute the relative error epsilon.\n        \n        # Avoid division by zero if the analytical solution yields zero heat transfer.\n        if Q_anal == 0.0:\n            # If both are zero, error is 0. If only Q_anal is zero, error is infinite.\n            return 0.0 if Q_dem == 0.0 else float('inf')\n            \n        error = np.abs(Q_dem - Q_anal) / Q_anal\n        \n        return error\n\n    results = []\n    for case in test_cases:\n        result = calculate_relative_error(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}