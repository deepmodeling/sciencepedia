{
    "hands_on_practices": [
        {
            "introduction": "离散元方法（DEM）模拟的核心在于接触力模型，它决定了颗粒间的相互作用。本练习将探讨物理上精确但计算成本高昂的非线性赫兹（Hertz）模型与简化线性模型之间的权衡。通过量化线性化引入的误差，您将对大规模模拟中的模型选择获得实用的洞察力。",
            "id": "3947595",
            "problem": "考虑应用于两个球形颗粒之间无摩擦、弹性、法向接触的离散元法（DEM）。在计算热工学中，此类接触定律控制着机械接触并影响热接触传导。要求您根据一个非线性接触模型来验证一个线性化刚度模型，该非线性模型是基于小变形、各向同性线弹性以及球体间无粘附接触的假设推导得出。非线性模型应基于经典的球体弹性接触理论，而线性化模型应通过对非线性力在指定参考重叠量周围进行一阶泰勒展开来构建。您的任务是计算并比较力-位移曲线，并量化由线性化引入的误差。\n\n从牛顿力学和广为接受的小变形弹性接触理论等基本原理出发，按以下步骤进行：\n\n1. 对于两个杨氏模量为 $E_1$ 和 $E_2$、泊松比为 $\\nu_1$ 和 $\\nu_2$、半径为 $R_1$ 和 $R_2$ 的球体，推导它们之间法向接触的等效弹性模量 $E^\\ast$ 和等效半径 $R^\\ast$。\n2. 设法向接近量（重叠量）为 $\\delta \\ge 0$，单位为米（m）。非线性法向接触力模型应为球体的弹性接触定律，用 $E^\\ast$、$R^\\ast$ 和 $\\delta$ 表示。通过对非线性力相对于 $\\delta$ 在参考重叠量 $\\delta_{\\mathrm{ref}}$ 处进行一阶泰勒展开来构建线性化模型，使得线性化模型在 $\\delta_{\\mathrm{ref}}$ 处的力与切向刚度均与之匹配。\n3. 对于每个测试用例，在区间 $[\\delta_{\\min}, \\delta_{\\max}]$ 上的均匀间隔网格上对重叠量 $\\delta$ 进行采样。其中 $\\delta_{\\min}$ 必须为正，以避免在计算相对误差时出现除以零的情况。使用 $\\delta_{\\min} = \\delta_{\\max}/N_{\\mathrm{s}}$，其中 $N_{\\mathrm{s}}$ 为采样点数。\n4. 对于每个采样点 $\\delta$，计算非线性力（单位：牛顿，N）和线性化力（单位：牛顿，N）。使用逐点无量纲相对误差来量化线性化误差，其定义为绝对差值除以非线性力。将这些误差汇总为每个测试用例的两个指标：\n   - 在所有采样点 $\\delta$ 上的均方根相对误差。\n   - 在所有采样点 $\\delta$ 上的最大相对误差。\n5. 所有输入均使用国际单位制（SI）。半径 $R_1$、$R_2$ 的单位为米（m），杨氏模量 $E$ 的单位为帕斯卡（Pa），重叠量 $\\delta$ 的单位为米（m），力的单位为牛顿（N）。相对误差指标是无量纲数。您的程序必须将这些指标输出为舍入到六位小数的十进制浮点数。\n\n测试套件：\n使用以下五个科学上合理的测试用例，旨在探究一系列材料刚度、颗粒尺寸和线性化参考重叠量的影响。对于每个用例，设置 $\\delta_{\\mathrm{ref}} = f_{\\mathrm{ref}} \\, \\delta_{\\max}$ 和 $\\delta_{\\min} = \\delta_{\\max}/N_{\\mathrm{s}}$。\n\n- 用例 A（典型的刚性接触，相同材料和尺寸）：\n  - $E_1 = 200 \\times 10^9$ Pa, $\\nu_1 = 0.30$, $E_2 = 200 \\times 10^9$ Pa, $\\nu_2 = 0.30$\n  - $R_1 = 0.005$ m, $R_2 = 0.005$ m\n  - $\\delta_{\\max} = 5 \\times 10^{-6}$ m, $f_{\\mathrm{ref}} = 0.5$, $N_{\\mathrm{s}} = 200$\n\n- 用例 B（软接触，近乎不可压缩的橡胶，相同材料和尺寸）：\n  - $E_1 = 10 \\times 10^6$ Pa, $\\nu_1 = 0.49$, $E_2 = 10 \\times 10^6$ Pa, $\\nu_2 = 0.49$\n  - $R_1 = 0.01$ m, $R_2 = 0.01$ m\n  - $\\delta_{\\max} = 50 \\times 10^{-6}$ m, $f_{\\mathrm{ref}} = 0.5$, $N_{\\mathrm{s}} = 200$\n\n- 用例 C（刚-软接触，相同尺寸）：\n  - $E_1 = 200 \\times 10^9$ Pa, $\\nu_1 = 0.30$, $E_2 = 10 \\times 10^6$ Pa, $\\nu_2 = 0.49$\n  - $R_1 = 0.002$ m, $R_2 = 0.002$ m\n  - $\\delta_{\\max} = 2 \\times 10^{-6}$ m, $f_{\\mathrm{ref}} = 0.5$, $N_{\\mathrm{s}} = 200$\n\n- 用例 D（刚性接触，小颗粒，在线性化范围的低端附近进行线性化）：\n  - $E_1 = 200 \\times 10^9$ Pa, $\\nu_1 = 0.30$, $E_2 = 200 \\times 10^9$ Pa, $\\nu_2 = 0.30$\n  - $R_1 = 0.001$ m, $R_2 = 0.001$ m\n  - $\\delta_{\\max} = 1 \\times 10^{-6}$ m, $f_{\\mathrm{ref}} = 0.1$, $N_{\\mathrm{s}} = 200$\n\n- 用例 E（刚性接触，中等颗粒，在线性化范围的高端附近进行线性化）：\n  - $E_1 = 200 \\times 10^9$ Pa, $\\nu_1 = 0.30$, $E_2 = 200 \\times 10^9$ Pa, $\\nu_2 = 0.30$\n  - $R_1 = 0.003$ m, $R_2 = 0.003$ m\n  - $\\delta_{\\max} = 3 \\times 10^{-6}$ m, $f_{\\mathrm{ref}} = 0.9$, $N_{\\mathrm{s}} = 200$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。对于每个测试用例，输出均方根相对误差，紧接着是最大相对误差（每个用例两个数字），两者都四舍五入到六位小数。因此，总输出必须是一个包含10个数字的扁平列表，按用例 A 到 E 的顺序排列，例如 $\\left[ \\text{A\\_rms}, \\text{A\\_max}, \\text{B\\_rms}, \\text{B\\_max}, \\ldots, \\text{E\\_rms}, \\text{E\\_max} \\right]$。",
            "solution": "所提出的问题要求根据两个弹性球体的经典非线性Hertz接触理论，来验证一个线性化的法向接触力模型。此任务与离散元法（DEM）等计算方法相关，在这些方法中，简化的力定律可以显著降低计算成本。分析过程涉及推导力模型，在指定的重叠范围内对其进行采样，并量化线性化误差。\n\n该问题具有科学依据，提法明确，并提供了所有必要的参数和步骤。它基于接触力学和数值分析的既定原则。因此，该问题被认为是有效的，下面将给出完整的解答。\n\n**1. 接触模型的理论构建**\n\n两个接触的弹性球体之间的相互作用由其材料属性（杨氏模量 $E$ 和泊松比 $\\nu$）及其几何形状（半径 $R$）来描述。下标 1 和 2 分别表示两个球体。\n\n**1.1. 等效材料和几何属性**\n\n通过定义等效杨氏模量 $E^\\ast$ 和等效半径 $R^\\ast$，可以简化双球系统的响应。这些参数将两个球体的属性组合成等效值，用于球体与平面的接触问题。\n\n等效杨氏模量 $E^\\ast$ 由以下关系定义：\n$$\n\\frac{1}{E^\\ast} = \\frac{1-\\nu_1^2}{E_1} + \\frac{1-\\nu_2^2}{E_2}\n$$\n可以计算为：\n$$\nE^\\ast = \\left( \\frac{1-\\nu_1^2}{E_1} + \\frac{1-\\nu_2^2}{E_2} \\right)^{-1}\n$$\n等效半径 $R^\\ast$ 由两个球体的曲率定义：\n$$\n\\frac{1}{R^\\ast} = \\frac{1}{R_1} + \\frac{1}{R_2}\n$$\n可以计算为：\n$$\nR^\\ast = \\left( \\frac{1}{R_1} + \\frac{1}{R_2} \\right)^{-1}\n$$\n\n**1.2. 非线性法向接触力模型（Hertz理论）**\n\n在无摩擦、无粘附、小变形的弹性接触假设下，法向接触力 $F_{nl}$ 与法向重叠量（接近量） $\\delta$ 之间的关系由Hertz接触理论给出：\n$$\nF_{nl}(\\delta) = \\frac{4}{3} E^\\ast \\sqrt{R^\\ast} \\delta^{3/2} \\quad \\text{for} \\quad \\delta \\ge 0\n$$\n当 $\\delta \\le 0$ 时（无接触），力为零。由于幂律关系 $F_{nl} \\propto \\delta^{3/2}$，该模型是非线性的。\n\n**1.3. 线性化法向接触力模型**\n\n线性化力模型 $F_{lin}(\\delta)$ 是通过对非线性力 $F_{nl}(\\delta)$ 在指定的参考重叠量 $\\delta_{\\mathrm{ref}}$ 处进行一阶泰勒展开来构建的。展开的一般形式为：\n$$\nF_{lin}(\\delta) = F_{nl}(\\delta_{\\mathrm{ref}}) + \\left. \\frac{dF_{nl}}{d\\delta} \\right|_{\\delta=\\delta_{\\mathrm{ref}}} (\\delta - \\delta_{\\mathrm{ref}})\n$$\n这确保了线性化模型在 $\\delta = \\delta_{\\mathrm{ref}}$ 处的力与切向刚度均与非线性模型匹配。\n\n首先，我们通过对 $F_{nl}(\\delta)$ 求导来确定切向刚度 $k_t(\\delta)$：\n$$\nk_t(\\delta) = \\frac{dF_{nl}}{d\\delta} = \\frac{d}{d\\delta} \\left( \\frac{4}{3} E^\\ast \\sqrt{R^\\ast} \\delta^{3/2} \\right) = \\frac{4}{3} E^\\ast \\sqrt{R^\\ast} \\left( \\frac{3}{2} \\delta^{1/2} \\right) = 2 E^\\ast \\sqrt{R^\\ast} \\sqrt{\\delta}\n$$\n在 $\\delta_{\\mathrm{ref}}$ 处计算力和刚度：\n$$\nF_{nl}(\\delta_{\\mathrm{ref}}) = \\frac{4}{3} E^\\ast \\sqrt{R^\\ast} \\delta_{\\mathrm{ref}}^{3/2}\n$$\n$$\nk_t(\\delta_{\\mathrm{ref}}) = 2 E^\\ast \\sqrt{R^\\ast} \\sqrt{\\delta_{\\mathrm{ref}}}\n$$\n将这些代入泰勒展开公式：\n$$\nF_{lin}(\\delta) = \\frac{4}{3} E^\\ast \\sqrt{R^\\ast} \\delta_{\\mathrm{ref}}^{3/2} + \\left( 2 E^\\ast \\sqrt{R^\\ast} \\sqrt{\\delta_{\\mathrm{ref}}} \\right) (\\delta - \\delta_{\\mathrm{ref}})\n$$\n我们可以通过提取公因式来简化此表达式：\n$$\nF_{lin}(\\delta) = E^\\ast \\sqrt{R^\\ast} \\left( \\frac{4}{3} \\delta_{\\mathrm{ref}}^{3/2} + 2\\delta\\sqrt{\\delta_{\\mathrm{ref}}} - 2\\delta_{\\mathrm{ref}}^{3/2} \\right)\n$$\n$$\nF_{lin}(\\delta) = E^\\ast \\sqrt{R^\\ast} \\left( 2\\delta\\sqrt{\\delta_{\\mathrm{ref}}} - \\frac{2}{3} \\delta_{\\mathrm{ref}}^{3/2} \\right)\n$$\n线性化力模型的最终形式为：\n$$\nF_{lin}(\\delta) = 2 E^\\ast \\sqrt{R^\\ast \\delta_{\\mathrm{ref}}} \\left( \\delta - \\frac{1}{3} \\delta_{\\mathrm{ref}} \\right)\n$$\n该模型是关于 $\\delta$ 的仿射函数，表现出恒定的刚度 $k_t(\\delta_{\\mathrm{ref}})$。\n\n**2. 误差量化**\n\n为了评估线性化的准确性，我们计算逐点相对误差，然后将其汇总为两个指标。分析在区间 $[\\delta_{\\min}, \\delta_{\\max}]$ 内的 $N_{\\mathrm{s}}$ 个均匀间隔的重叠量 $\\delta$ 采样点上进行，其中 $\\delta_{\\min} = \\delta_{\\max}/N_{\\mathrm{s}}$。采样从一个严格为正的值开始，以避免在计算相对误差时出现除以零的情况，因为 $F_{nl}(0) = 0$。\n\n逐点无量纲相对误差 $\\epsilon(\\delta)$ 定义为：\n$$\n\\epsilon(\\delta) = \\frac{|F_{nl}(\\delta) - F_{lin}(\\delta)|}{F_{nl}(\\delta)}\n$$\n根据这些逐点误差，为每个测试用例计算两个汇总指标：\n1.  **均方根相对误差 (RMSRE)**：对于一组采样重叠量 $\\{\\delta_i\\}_{i=1}^{N_{\\mathrm{s}}}$，RMSRE由下式给出：\n    $$\n    \\text{RMSRE} = \\sqrt{\\frac{1}{N_{\\mathrm{s}}} \\sum_{i=1}^{N_{\\mathrm{s}}} \\left( \\epsilon(\\delta_i) \\right)^2}\n    $$\n2.  **最大相对误差 (MRE)**：这是在所有采样重叠量上逐点相对误差的最大值：\n    $$\n    \\text{MRE} = \\max_{i} \\{ \\epsilon(\\delta_i) \\}\n    $$\n\n**3. 计算步骤**\n\n解决方案通过一个Python脚本实现，该脚本为问题陈述中提供的每个测试用例执行以下步骤：\n1.  根据给定的两个球体的属性（$R_1, \\nu_1, E_1, R_2, \\nu_2, E_2$）计算等效半径 $R^\\ast$ 和等效模量 $E^\\ast$。\n2.  确定分析范围的参数：参考重叠量 $\\delta_{\\mathrm{ref}} = f_{\\mathrm{ref}} \\, \\delta_{\\max}$ 和最小重叠量 $\\delta_{\\min} = \\delta_{\\max}/N_{\\mathrm{s}}$。\n3.  生成一个包含 $N_{\\mathrm{s}}$ 个从 $\\delta_{\\min}$ 到 $\\delta_{\\max}$ 均匀间隔的 $\\delta$ 值的数组。\n4.  对于 $\\delta$ 数组中的每个值，使用推导出的公式计算相应的非线性力 $F_{nl}(\\delta)$ 和线性化力 $F_{lin}(\\delta)$。\n5.  计算所有采样点的逐点相对误差 $\\epsilon(\\delta)$。\n6.  根据逐点误差数组计算RMSRE和MRE。\n7.  存储得到的RMSRE和MRE值。\n8.  处理完所有测试用例后，将结果格式化为单个列表，并按规定格式打印。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ... # Scipy is not required for this solution.\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing nonlinear and linearized contact models\n    for a series of test cases.\n    \"\"\"\n\n    def compute_errors_for_case(E1, nu1, R1, E2, nu2, R2, delta_max, f_ref, Ns):\n        \"\"\"\n        Computes the RMS and max relative errors for a single test case.\n\n        Args:\n            E1, nu1, R1: Properties of sphere 1 (Young's modulus, Poisson's ratio, radius).\n            E2, nu2, R2: Properties of sphere 2.\n            delta_max (float): Maximum overlap for the analysis range.\n            f_ref (float): Factor to determine the reference overlap from delta_max.\n            Ns (int): Number of sample points.\n\n        Returns:\n            tuple: A tuple containing (rms_relative_error, max_relative_error).\n        \"\"\"\n        # Step 1: Calculate effective material and geometric properties\n        E_star = 1.0 / ((1.0 - nu1**2) / E1 + (1.0 - nu2**2) / E2)\n        \n        # Handle the case of a sphere on a flat plane (R2 -> infinity)\n        if R2 == float('inf'):\n            R_star = R1\n        else:\n            R_star = 1.0 / (1.0 / R1 + 1.0 / R2)\n\n        # Step 2: Define analysis range and reference overlap\n        delta_ref = f_ref * delta_max\n        delta_min = delta_max / Ns\n\n        # Step 3: Generate the grid of overlap values\n        delta = np.linspace(delta_min, delta_max, Ns)\n\n        # Step 4: Compute nonlinear and linearized forces\n        # Nonlinear force: F_nl = (4/3) * E* * sqrt(R*) * delta^(3/2)\n        hertz_const = (4.0 / 3.0) * E_star * np.sqrt(R_star)\n        F_nl = hertz_const * delta**1.5\n\n        # Linearized force: F_lin = 2 * E* * sqrt(R* * delta_ref) * (delta - delta_ref/3)\n        lin_const = 2.0 * E_star * np.sqrt(R_star * delta_ref)\n        F_lin = lin_const * (delta - delta_ref / 3.0)\n        \n        # Step 5: Calculate pointwise relative error\n        # The problem statement defines error as absolute difference divided by nonlinear force.\n        relative_error = np.abs(F_nl - F_lin) / F_nl\n\n        # Step 6: Compute aggregate error metrics\n        rms_relative_error = np.sqrt(np.mean(relative_error**2))\n        max_relative_error = np.max(relative_error)\n\n        return rms_relative_error, max_relative_error\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        {'E1': 200e9, 'nu1': 0.30, 'R1': 0.005, 'E2': 200e9, 'nu2': 0.30, 'R2': 0.005, \n         'delta_max': 5e-6, 'f_ref': 0.5, 'Ns': 200},\n        # Case B\n        {'E1': 10e6, 'nu1': 0.49, 'R1': 0.01, 'E2': 10e6, 'nu2': 0.49, 'R2': 0.01, \n         'delta_max': 50e-6, 'f_ref': 0.5, 'Ns': 200},\n        # Case C\n        {'E1': 200e9, 'nu1': 0.30, 'R1': 0.002, 'E2': 10e6, 'nu2': 0.49, 'R2': 0.002, \n         'delta_max': 2e-6, 'f_ref': 0.5, 'Ns': 200},\n        # Case D\n        {'E1': 200e9, 'nu1': 0.30, 'R1': 0.001, 'E2': 200e9, 'nu2': 0.30, 'R2': 0.001, \n         'delta_max': 1e-6, 'f_ref': 0.1, 'Ns': 200},\n        # Case E\n        {'E1': 200e9, 'nu1': 0.30, 'R1': 0.003, 'E2': 200e9, 'nu2': 0.30, 'R2': 0.003, \n         'delta_max': 3e-6, 'f_ref': 0.9, 'Ns': 200},\n    ]\n\n    results = []\n    for case in test_cases:\n        rms_err, max_err = compute_errors_for_case(**case)\n        results.append(f\"{rms_err:.6f}\")\n        results.append(f\"{max_err:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "计算出作用力后，我们必须求解牛顿（Newton）运动方程来更新颗粒的运动状态。本实践将指导您实现离散元方法中的主力算法——速度-Verlet（Velocity-Verlet）积分方法，用于处理颗粒的平动和转动。您还将分析其精度和稳定性，这是决定任何动力学模拟可靠性和可行性的两个关键属性。",
            "id": "3947654",
            "problem": "一个刚性球形颗粒系统通过离散元方法 (DEM) 进行建模，其中相互作用和运动由牛顿定律描述。考虑一个质量为 $m$、绕其中心的转动惯量为 $I$ 的单个刚性球形颗粒。令 $\\mathbf{x}(t)$ 表示颗粒位置，$\\mathbf{v}(t)$ 表示其线速度，$\\boldsymbol{\\omega}(t)$ 表示其角速度，$\\boldsymbol{\\theta}(t)$ 表示其以弧度表示的取向矢量。净力 $\\mathbf{F}$ 和扭矩 $\\boldsymbol{\\tau}$ 源于弹簧和接触等相互作用，可能带有无滑移约束，但就本问题而言，它们是确定性的，并且在每个时刻最多仅取决于位置和取向。基本依据是牛顿第二平动和转动定律：\n$$m \\,\\frac{d^2 \\mathbf{x}}{dt^2} = \\mathbf{F}(\\mathbf{x}, t), \\quad I \\,\\frac{d \\boldsymbol{\\omega}}{dt} = \\boldsymbol{\\tau}(\\boldsymbol{\\theta}, t),$$\n以及运动学关系\n$$\\frac{d \\boldsymbol{\\theta}}{dt} = \\boldsymbol{\\omega}。$$\n\n你的任务是：\n1. 从第一性原理出发，推导一个用于 DEM 的 Velocity-Verlet 时间积分方案，该方案在一个时间步长 $\\Delta t$ 内更新位置 $\\mathbf{x}$、线速度 $\\mathbf{v}$ 和角速度 $\\boldsymbol{\\omega}$。推导必须从上述基本定律开始，不得引入任何快捷公式。推导应明确陈述并使用加速度 $\\mathbf{a}(t) = \\mathbf{F}(\\mathbf{x}(t), t)/m$ 和角加速度 $\\boldsymbol{\\alpha}(t) = \\boldsymbol{\\tau}(\\boldsymbol{\\theta}(t), t)/I$，并且必须从时间步 $n$ 的值生成 $\\mathbf{x}^{n+1}$、$\\mathbf{v}^{n+1}$ 和 $\\boldsymbol{\\omega}^{n+1}$ 的显式更新公式。\n2. 讨论该方案对于位置相关力和扭矩的精度阶数和稳定性。这包括对由 $m \\, d^2 x/dt^2 = -k x$ 定义的一维谐振子及其转动模拟 $I \\, d^2 \\theta/dt^2 = -k_t \\theta$ 进行线性稳定性分析。请用固有角频率和 $\\Delta t$ 明确陈述稳定性条件。所有角度必须以弧度表示。\n3. 实现一个完整、可运行的程序，将推导出的 Velocity-Verlet 方案应用于以下科学上真实的测试套件。使用国际单位制 (SI)：质量单位为 $\\mathrm{kg}$，刚度单位为 $\\mathrm{N/m}$，转动惯量单位为 $\\mathrm{kg\\,m^2}$，时间单位为 $\\mathrm{s}$，扭转刚度单位为 $\\mathrm{N\\,m/rad}$，角度单位为弧度。程序必须按规定产生量化输出。\n\n测试套件：\n- 精度测试（针对位置相关力和扭矩的单步局部截断误差）：\n    - 平动谐振子：$m = 1.0$，$k = 100.0$，初始位置 $x_0 = 0.1$ $\\mathrm{m}$，初始速度 $v_0 = 0.0$ $\\mathrm{m/s}$，时间步长 $\\Delta t_1 = 0.01$ $\\mathrm{s}$ 和 $\\Delta t_2 = 0.005$ $\\mathrm{s}$。使用 $x(t) = x_0 \\cos(\\omega t) + v_0 \\frac{\\sin(\\omega t)}{\\omega}$ 和 $v(t) = -x_0 \\omega \\sin(\\omega t) + v_0 \\cos(\\omega t)$（其中 $\\omega = \\sqrt{k/m}$）计算一步后的精确解。测量在 Velocity-Verlet 方案下，对于 $\\Delta t_1$ 和 $\\Delta t_2$，一步后的绝对误差 $\\varepsilon_x(\\Delta t)$ 和 $\\varepsilon_v(\\Delta t)$，然后将比率 $\\varepsilon_x(\\Delta t_1)/\\varepsilon_x(\\Delta t_2)$ 和 $\\varepsilon_v(\\Delta t_1)/\\varepsilon_v(\\Delta t_2)$ 作为浮点数报告。\n    - 转动谐振子：$I = 0.004$，$k_t = 0.5$，初始取向 $\\theta_0 = 0.1$ $\\mathrm{rad}$，初始角速度 $\\omega_0 = 0.0$ $\\mathrm{rad/s}$，时间步长 $\\Delta t_1 = 0.01$ $\\mathrm{s}$ 和 $\\Delta t_2 = 0.005$ $\\mathrm{s}$。使用 $\\theta(t) = \\theta_0 \\cos(\\Omega t) + \\omega_0 \\frac{\\sin(\\Omega t)}{\\Omega}$ 和 $\\omega(t) = -\\theta_0 \\Omega \\sin(\\Omega t) + \\omega_0 \\cos(\\Omega t)$（其中 $\\Omega = \\sqrt{k_t/I}$）。测量在 Velocity-Verlet 方案下，对于两个时间步长，一步后的角速度绝对误差 $\\varepsilon_\\omega(\\Delta t)$，并报告比率 $\\varepsilon_\\omega(\\Delta t_1)/\\varepsilon_\\omega(\\Delta t_2)$ 作为浮点数。\n\n- 稳定性测试（谐振子在多个步长后的有界性）：\n    - 平动谐振子，$m = 1.0$，$k = 100.0$，初始条件 $x_0 = 0.1$ $\\mathrm{m}$，$v_0 = 0.0$ $\\mathrm{m/s}$。使用 Velocity-Verlet 方案和三个时间步长模拟 $N = 2000$ 步：$\\Delta t_{\\text{small}} = 0.05$ $\\mathrm{s}$，$\\Delta t_{\\text{border}} = 0.2$ $\\mathrm{s}$，以及 $\\Delta t_{\\text{large}} = 0.25$ $\\mathrm{s}$。有界性定义为模拟过程中的最大绝对位置不超过初始绝对位置的 $10$ 倍，并且没有数值溢出。对于每个时间步长，输出一个布尔值，指示运动是否保持有界。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表应按以下顺序包含六个条目：$[\\varepsilon_x(\\Delta t_1)/\\varepsilon_x(\\Delta t_2), \\varepsilon_v(\\Delta t_1)/\\varepsilon_v(\\Delta t_2), \\varepsilon_\\omega(\\Delta t_1)/\\varepsilon_\\omega(\\Delta t_2), \\text{bounded}(\\Delta t_{\\text{small}}), \\text{bounded}(\\Delta t_{\\text{border}}), \\text{bounded}(\\Delta t_{\\text{large}})]$。所有三个比率必须是浮点数，三个有界性指标必须是布尔值。程序不得读取任何输入，并且必须是完全自包含的。",
            "solution": "问题陈述经评估有效。它在科学上基于牛顿力学和数值分析的原理，特别是关于离散元方法 (DEM)。该问题是适定的，提供了所有必要的参数和条件，可以推导出唯一且有意义的解。语言客观、明确。因此，提供完整的解决方案。\n\n### 1. Velocity-Verlet 积分方案的推导\n\nVelocity-Verlet 算法由位置 $\\mathbf{x}(t)$ 和速度 $\\mathbf{v}(t)$ 的泰勒级数展开推导而来。基本运动方程如下：\n$$m \\frac{d^2 \\mathbf{x}}{dt^2} = \\mathbf{F}(\\mathbf{x}, t) \\implies \\frac{d\\mathbf{v}}{dt} = \\mathbf{a}(\\mathbf{x}, t)$$\n$$I \\frac{d \\boldsymbol{\\omega}}{dt} = \\boldsymbol{\\tau}(\\boldsymbol{\\theta}, t) \\implies \\frac{d\\boldsymbol{\\omega}}{dt} = \\boldsymbol{\\alpha}(\\boldsymbol{\\theta}, t)$$\n其中 $\\mathbf{a}(t)$ 是线加速度，$\\boldsymbol{\\alpha}(t)$ 是角加速度。运动学关系为 $\\frac{d\\mathbf{x}}{dt} = \\mathbf{v}$ 和 $\\frac{d\\boldsymbol{\\theta}}{dt} = \\boldsymbol{\\omega}$。\n\n设系统在时间 $t_n = n \\Delta t$ 的状态为 $(\\mathbf{x}^n, \\mathbf{v}^n, \\boldsymbol{\\theta}^n, \\boldsymbol{\\omega}^n)$。我们寻求在时间 $t_{n+1} = t_n + \\Delta t$ 的状态。\n\n**步骤 1：位置和取向更新**\n我们从位置矢量 $\\mathbf{x}(t)$ 在时间 $t_n$ 附近的泰勒级数展开开始：\n$$\\mathbf{x}(t_n + \\Delta t) = \\mathbf{x}(t_n) + \\frac{d\\mathbf{x}}{dt}\\bigg|_{t_n} \\Delta t + \\frac{1}{2} \\frac{d^2\\mathbf{x}}{dt^2}\\bigg|_{t_n} \\Delta t^2 + O(\\Delta t^3)$$\n代入运动学关系 $\\mathbf{v} = d\\mathbf{x}/dt$ 和加速度定义 $\\mathbf{a} = d^2\\mathbf{x}/dt^2$：\n$$\\mathbf{x}^{n+1} \\approx \\mathbf{x}^n + \\mathbf{v}^n \\Delta t + \\frac{1}{2} \\mathbf{a}^n \\Delta t^2$$\n这是位置更新公式，具有二阶精度。局部误差为 $O(\\Delta t^3)$。\n\n同样的推导适用于取向矢量 $\\boldsymbol{\\theta}$，只需将线性量替换为其转动对应量：\n$$\\boldsymbol{\\theta}^{n+1} \\approx \\boldsymbol{\\theta}^n + \\boldsymbol{\\omega}^n \\Delta t + \\frac{1}{2} \\boldsymbol{\\alpha}^n \\Delta t^2$$\n\n**步骤 2：速度和角速度更新**\n为了更新速度，我们使用 $\\mathbf{v}(t)$ 在 $t_n$ 附近的泰勒展开：\n$$\\mathbf{v}(t_n + \\Delta t) = \\mathbf{v}(t_n) + \\frac{d\\mathbf{v}}{dt}\\bigg|_{t_n} \\Delta t + O(\\Delta t^2) = \\mathbf{v}^n + \\mathbf{a}^n \\Delta t + O(\\Delta t^2)$$\n这是一个简单的前向欧拉步，只有一阶精度。Velocity-Verlet 方案的关键是通过对时间步开始和结束时的加速度进行平均来提高精度。\n$$\\mathbf{v}^{n+1} \\approx \\mathbf{v}^n + \\frac{\\mathbf{a}^n + \\mathbf{a}^{n+1}}{2} \\Delta t$$\n要使用此公式，我们需要加速度 $\\mathbf{a}^{n+1} = \\mathbf{a}(\\mathbf{x}^{n+1}, t_{n+1})$，它依赖于尚待计算的位置 $\\mathbf{x}^{n+1}$。这表明了以下操作顺序：\n1.  使用步骤 1 中的公式计算新位置 $\\mathbf{x}^{n+1}$。\n2.  使用新位置 $\\mathbf{x}^{n+1}$ 计算力 $\\mathbf{F}(\\mathbf{x}^{n+1}, t_{n+1})$，从而得到新加速度 $\\mathbf{a}^{n+1}$。\n3.  使用平均加速度公式计算新速度 $\\mathbf{v}^{n+1}$。\n\n一个时间步的完整 Velocity-Verlet 算法如下：\n1.  更新位置：$\\mathbf{x}^{n+1} = \\mathbf{x}^{n} + \\mathbf{v}^{n}\\Delta t + \\frac{1}{2}\\mathbf{a}^{n}\\Delta t^2$。\n2.  计算新加速度：$\\mathbf{a}^{n+1} = \\mathbf{F}(\\mathbf{x}^{n+1}, t_{n+1})/m$。\n3.  更新速度：$\\mathbf{v}^{n+1} = \\mathbf{v}^{n} + \\frac{1}{2}(\\mathbf{a}^{n} + \\mathbf{a}^{n+1})\\Delta t$。\n\n同样的逻辑也适用于转动动力学：\n1.  更新取向：$\\boldsymbol{\\theta}^{n+1} = \\boldsymbol{\\theta}^{n} + \\boldsymbol{\\omega}^{n}\\Delta t + \\frac{1}{2}\\boldsymbol{\\alpha}^{n}\\Delta t^2$。\n2.  计算新角加速度：$\\boldsymbol{\\alpha}^{n+1} = \\boldsymbol{\\tau}(\\boldsymbol{\\theta}^{n+1}, t_{n+1})/I$。\n3.  更新角速度：$\\boldsymbol{\\omega}^{n+1} = \\boldsymbol{\\omega}^{n} + \\frac{1}{2}(\\boldsymbol{\\alpha}^{n} + \\boldsymbol{\\alpha}^{n+1})\\Delta t$。\n\n### 2. 精度和稳定性分析\n\n**精度阶数**\n局部截断误差是在假设时间 $t_n$ 的状态是精确的情况下，单步产生的误差。\n对于位置，泰勒展开给出：\n$$ \\mathbf{x}_{\\text{exact}}(t_n+\\Delta t) = \\mathbf{x}^n + \\mathbf{v}^n \\Delta t + \\frac{1}{2} \\mathbf{a}^n \\Delta t^2 + \\frac{1}{6} \\dot{\\mathbf{a}}^n \\Delta t^3 + O(\\Delta t^4) $$\n数值计算的位置为 $\\mathbf{x}^{n+1} = \\mathbf{x}^n + \\mathbf{v}^n \\Delta t + \\frac{1}{2} \\mathbf{a}^n \\Delta t^2$。因此局部误差为 $E_x = \\mathbf{x}_{\\text{exact}}^{n+1} - \\mathbf{x}^{n+1} = \\frac{1}{6} \\dot{\\mathbf{a}}^n \\Delta t^3 + O(\\Delta t^4)$。位置更新的局部误差为 $O(\\Delta t^3)$。然而，对于从静止开始（$v_0=0$）的谐振子这一特定测试案例，我们有 $\\dot{\\mathbf{a}} = (d\\mathbf{a}/d\\mathbf{x})\\mathbf{v}$，所以 $\\dot{\\mathbf{a}}(t=0) = 0$。误差的主导项消失，误差变为 $E_x = \\frac{1}{24}\\ddot{\\mathbf{a}}^n \\Delta t^4 + O(\\Delta t^5)$，即 $O(\\Delta t^4)$。\n\n对于速度，我们展开 $t_n$ 附近的 $\\mathbf{a}^{n+1}$：\n$$ \\mathbf{a}^{n+1} = \\mathbf{a}(\\mathbf{x}^{n+1}) \\approx \\mathbf{a}(\\mathbf{x}^n + \\mathbf{v}^n\\Delta t + \\dots) \\approx \\mathbf{a}^n + \\frac{d\\mathbf{a}}{dt}\\bigg|_{t_n} \\Delta t + O(\\Delta t^2) = \\mathbf{a}^n + \\dot{\\mathbf{a}}^n \\Delta t + O(\\Delta t^2) $$\n将此代入速度更新规则：\n$$ \\mathbf{v}^{n+1} = \\mathbf{v}^n + \\frac{1}{2}(\\mathbf{a}^n + \\mathbf{a}^n + \\dot{\\mathbf{a}}^n \\Delta t + O(\\Delta t^2)) \\Delta t = \\mathbf{v}^n + \\mathbf{a}^n \\Delta t + \\frac{1}{2} \\dot{\\mathbf{a}}^n \\Delta t^2 + O(\\Delta t^3) $$\n精确速度为 $\\mathbf{v}_{\\text{exact}}(t_n+\\Delta t) = \\mathbf{v}^n + \\mathbf{a}^n\\Delta t + \\frac{1}{2}\\dot{\\mathbf{a}}^n\\Delta t^2 + \\frac{1}{6}\\ddot{\\mathbf{a}}^n\\Delta t^3 + O(\\Delta t^4)$。局部误差为 $E_v = \\mathbf{v}^{n+1} - \\mathbf{v}_{\\text{exact}}^{n+1} = - \\frac{1}{6}\\ddot{\\mathbf{a}}^n\\Delta t^3 + O(\\Delta t^4)$，这里忽略了 $\\mathbf{a}^{n+1}$ 展开带来的误差贡献。更仔细的分析表明 $E_v \\sim O(\\Delta t^3)$。\n位置和速度的局部误差为 $O(\\Delta t^3)$。在 $\\dot{\\mathbf{a}}(0)=0$ 的特定情况下，位置误差为 $O(\\Delta t^4)$。该方案的全局误差低一个阶次，使其成为一个二阶方法，即 $O(\\Delta t^2)$。\n\n**线性稳定性分析**\n我们分析一维谐振子，$m \\ddot{x} = -k x$，或 $\\ddot{x} = -\\omega^2 x$，其中 $\\omega = \\sqrt{k/m}$。Velocity-Verlet 方程为：\n1. $x_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a_n \\Delta t^2 = x_n + v_n \\Delta t - \\frac{1}{2} \\omega^2 x_n \\Delta t^2$\n2. $v_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t = v_n - \\frac{1}{2} \\omega^2 (x_n + x_{n+1}) \\Delta t$\n我们可以将此系统表示为对状态向量 $\\begin{pmatrix} x_n  v_n \\end{pmatrix}^T$ 的矩阵变换，或称放大矩阵 $\\mathbf{M}$：\n$$\n\\begin{pmatrix} x_{n+1} \\\\ v_{n+1} \\end{pmatrix} = \\mathbf{M} \\begin{pmatrix} x_n \\\\ v_n \\end{pmatrix} = \n\\begin{pmatrix} 1 - \\frac{1}{2} (\\omega \\Delta t)^2  \\Delta t \\\\ -\\omega^2 \\Delta t (1 - \\frac{1}{4} (\\omega \\Delta t)^2)  1 - \\frac{1}{2} (\\omega \\Delta t)^2 \\end{pmatrix}\n\\begin{pmatrix} x_n \\\\ v_n \\end{pmatrix}\n$$\n如果 $\\mathbf{M}$ 的特征值 $\\lambda$ 满足 $|\\lambda| \\le 1$，则系统是稳定的。特征值是特征方程 $\\lambda^2 - \\text{Tr}(\\mathbf{M})\\lambda + \\det(\\mathbf{M}) = 0$ 的解。\n迹为 $\\text{Tr}(\\mathbf{M}) = 2 - (\\omega \\Delta t)^2$。行列式为 $\\det(\\mathbf{M}) = 1$。方程变为：\n$$ \\lambda^2 - (2 - (\\omega \\Delta t)^2)\\lambda + 1 = 0 $$\n为了使特征值位于单位圆上（即 $|\\lambda|=1$ 且振荡不增长），这个二次方程的判别式必须为非正：\n$$ (2 - (\\omega \\Delta t)^2)^2 - 4 \\le 0 \\implies -2 \\le 2 - (\\omega \\Delta t)^2 \\le 2 $$\n右侧不等式 $-(\\omega \\Delta t)^2 \\le 0$ 总是成立。左侧不等式给出稳定性条件：\n$$ (\\omega \\Delta t)^2 \\le 4 \\implies \\omega \\Delta t \\le 2 $$\n因此，对于谐振子，Velocity-Verlet 方案是条件稳定的。时间步长 $\\Delta t$ 的选择必须使其小于或等于 $2/\\omega$，其中 $\\omega$ 是系统中的最高固有频率。同样的条件 $\\Omega \\Delta t \\le 2$ 也适用于转动振子。\n\n### 3. 实现与测试套件结果\n\n提供的 Python 代码实现了推导出的 Velocity-Verlet 算法，并将其应用于指定的测试套件。\n\n**精度测试**\n- **平动振子：** $m=1.0$，$k=100.0$，所以 $\\omega=10.0$ rad/s。初始条件是 $x_0=0.1, v_0=0.0$。由于 $v_0=0$，我们有 $\\dot{a}(0)=0$。位置的局部截断误差预计为 $O(\\Delta t^4)$，速度的局部截断误差预计为 $O(\\Delta t^3)$。当时间步长从 $\\Delta t_1$ 减半到 $\\Delta t_2$ 时，位置误差应减少 $(2)^4=16$ 倍，速度误差应减少 $(2)^3=8$ 倍。\n- **转动振子：** $I=0.004$，$k_t=0.5$，所以 $\\Omega=\\sqrt{125} \\approx 11.18$ rad/s。初始条件是 $\\theta_0=0.1, \\omega_0=0.0$。角速度的局部截断误差为 $O(\\Delta t^3)$，因此误差比率预计为 $(2)^3=8$。\n\n**稳定性测试**\n稳定性条件为 $\\Delta t \\le 2/\\omega = 2/10.0 = 0.2$ s。\n- $\\Delta t_{\\text{small}} = 0.05$ s: $\\omega \\Delta t = 0.5  2$。预计模拟将是稳定且有界的。\n- $\\Delta t_{\\text{border}} = 0.2$ s: $\\omega \\Delta t = 2.0$。模拟处于稳定性的极限。能量应守恒，运动应保持有界。\n- $\\Delta t_{\\text{large}} = 0.25$ s: $\\omega \\Delta t = 2.5 > 2$。预计模拟将不稳定，振幅呈指数增长，并最终溢出或超过指定界限。\n\n代码计算这些测试的结果，并按要求格式化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, analyzes, and implements the Velocity-Verlet integration scheme\n    for a DEM problem, as specified in the problem statement.\n    \"\"\"\n\n    # --- Part 1: Accuracy Tests ---\n\n    # --- Translational Harmonic Oscillator ---\n    m_t = 1.0\n    k_t = 100.0\n    x0_t = 0.1\n    v0_t = 0.0\n    dt_t1 = 0.01\n    dt_t2 = 0.005\n\n    omega_t = np.sqrt(k_t / m_t)\n\n    def run_trans_step(x0, v0, dt, k, m):\n        # Initial acceleration\n        a0 = -k * x0 / m\n        # Update position\n        x1 = x0 + v0 * dt + 0.5 * a0 * dt**2\n        # Update acceleration\n        a1 = -k * x1 / m\n        # Update velocity\n        v1 = v0 + 0.5 * (a0 + a1) * dt\n        return x1, v1\n    \n    # Numerical results for one step\n    x1_num_dt1, v1_num_dt1 = run_trans_step(x0_t, v0_t, dt_t1, k_t, m_t)\n    x1_num_dt2, v1_num_dt2 = run_trans_step(x0_t, v0_t, dt_t2, k_t, m_t)\n\n    # Exact solutions after one step\n    x1_exact_dt1 = x0_t * np.cos(omega_t * dt_t1)\n    v1_exact_dt1 = -x0_t * omega_t * np.sin(omega_t * dt_t1)\n    x1_exact_dt2 = x0_t * np.cos(omega_t * dt_t2)\n    v1_exact_dt2 = -x0_t * omega_t * np.sin(omega_t * dt_t2)\n\n    # Absolute errors\n    eps_x_dt1 = np.abs(x1_num_dt1 - x1_exact_dt1)\n    eps_v_dt1 = np.abs(v1_num_dt1 - v1_exact_dt1)\n    eps_x_dt2 = np.abs(x1_num_dt2 - x1_exact_dt2)\n    eps_v_dt2 = np.abs(v1_num_dt2 - v1_exact_dt2)\n\n    # Ratios of errors\n    ratio_x = eps_x_dt1 / eps_x_dt2\n    ratio_v = eps_v_dt1 / eps_v_dt2\n\n    # --- Rotational Harmonic Oscillator ---\n    I_r = 0.004\n    kt_r = 0.5\n    theta0_r = 0.1\n    omega0_r = 0.0\n    dt_r1 = 0.01\n    dt_r2 = 0.005\n\n    Omega_r = np.sqrt(kt_r / I_r)\n\n    def run_rot_step(theta0, omega0, dt, kt, I):\n        # Initial angular acceleration\n        alpha0 = -kt * theta0 / I\n        # Update orientation (though not explicitly needed for omega error)\n        theta1 = theta0 + omega0 * dt + 0.5 * alpha0 * dt**2\n        # Update angular acceleration\n        alpha1 = -kt * theta1 / I\n        # Update angular velocity\n        omega1 = omega0 + 0.5 * (alpha0 + alpha1) * dt\n        return omega1\n\n    # Numerical omega after one step\n    omega1_num_dt1 = run_rot_step(theta0_r, omega0_r, dt_r1, kt_r, I_r)\n    omega1_num_dt2 = run_rot_step(theta0_r, omega0_r, dt_r2, kt_r, I_r)\n\n    # Exact omega after one step\n    omega1_exact_dt1 = -theta0_r * Omega_r * np.sin(Omega_r * dt_r1)\n    omega1_exact_dt2 = -theta0_r * Omega_r * np.sin(Omega_r * dt_r2)\n\n    # Absolute errors\n    eps_omega_dt1 = np.abs(omega1_num_dt1 - omega1_exact_dt1)\n    eps_omega_dt2 = np.abs(omega1_num_dt2 - omega1_exact_dt2)\n\n    # Ratio of errors\n    ratio_omega = eps_omega_dt1 / eps_omega_dt2\n\n\n    # --- Part 2: Stability Tests ---\n    \n    # Parameters for stability test\n    m_s = 1.0\n    k_s = 100.0\n    x0_s = 0.1\n    v0_s = 0.0\n    N_s = 2000\n    dt_small = 0.05\n    dt_border = 0.2\n    dt_large = 0.25\n    dts_s = [dt_small, dt_border, dt_large]\n    \n    boundedness_results = []\n    \n    def check_boundedness(dt, k, m, x0, v0, N):\n        x = x0\n        v = v0\n        max_abs_x = np.abs(x0)\n        bound = 10.0 * np.abs(x0)\n        \n        for _ in range(N):\n            # Velocity-Verlet update\n            a = -k * x / m\n            x_new = x + v * dt + 0.5 * a * dt**2\n            a_new = -k * x_new / m\n            v_new = v + 0.5 * (a + a_new) * dt\n            \n            x, v = x_new, v_new\n            \n            # Check for overflow and bound\n            if not np.isfinite(x):\n                return False\n            \n            if np.abs(x) > max_abs_x:\n                max_abs_x = np.abs(x)\n            \n            if max_abs_x > bound:\n                return False\n                \n        return True\n\n    for dt_val in dts_s:\n        is_bounded = check_boundedness(dt_val, k_s, m_s, x0_s, v0_s, N_s)\n        boundedness_results.append(is_bounded)\n        \n    is_bounded_small, is_bounded_border, is_bounded_large = boundedness_results\n\n    # Final result assembly\n    results = [\n        ratio_x, \n        ratio_v, \n        ratio_omega, \n        is_bounded_small, \n        is_bounded_border, \n        is_bounded_large\n    ]\n\n    # Final print statement in the exact required format.\n    print(f\"[{results[0]},{results[1]},{results[2]},{str(results[3]).lower()},{str(results[4]).lower()},{str(results[5]).lower()}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在热颗粒系统中，热量传递与力学接触密切相关。本练习将综合运用前面的概念，对赫兹（Hertz）理论预测的接触区域上的导热进行建模。您将对照解析解来验证一个简化的DEM导热模型，这是构建预测性多物理场模拟的关键一步。",
            "id": "3947631",
            "problem": "给定两个弹性球体，已知其半径、弹性模量、泊松比、热导率，以及指定的法向载荷和温差，要求从第一性原理推导一个预测跨球体接触面传导传热的模型，并用解析解验证一个简化的离散元法（DEM）传导模型。推导必须从傅里叶热传导定律和赫兹弹性接触理论开始，并且只使用基本定律和经过充分检验的事实。\n\n假设在接触处，界面热阻可忽略不计，且就热传导而言，球体在局部表现为半无限体。物理情景如下：两个球体在法向载荷下被压在一起，形成一个半径为 $a$ 的圆形接触面；一个球体在远离接触面的地方保持较高的均匀温度，另一个则保持较低的均匀温度。在这些假设下，跨接触面的总传热量取决于接触半径和材料的热导率。该传导问题的解析解可以通过考虑每个球体的收缩（或扩展）热阻并将它们串联相加来获得。\n\n从 Hertz 理论出发，建立弹性球体的法向载荷与接触半径之间的关系；从傅里叶定律出发，建立温度梯度与热流密度之间的关系。对于两个弹性球体，等效半径和等效弹性模量由球形接触的标准组合定义。仅使用这些基本原理来推导接触半径和双球体系统总热阻的表达式，然后将温差除以总热阻来计算解析传热量。\n\n定义一个简化的离散元法（DEM）传导模型，该模型将每个球体的热收缩表示为一个热阻，其值与接触半径和热导率成反比，但带有一个可能偏离精确解析常数的模型常数。将两个热阻视为串联，以获得 DEM 预测的总热阻，从而得到 DEM 预测的传热量。\n\n您的程序必须：\n- 使用 Hertz 理论计算在法向载荷 $F$ 下两个球体的接触半径。\n- 对于给定的温差 $\\Delta T$，计算解析总热阻及相应的解析传热量 $Q_{\\mathrm{anal}}$。\n- 使用模型常数 $C_{\\mathrm{DEM}}$ 计算 DEM 预测的总热阻及相应的 DEM 预测传热量 $Q_{\\mathrm{DEM}}$。\n- 对每个测试用例，返回相对误差 $\\varepsilon = \\left| Q_{\\mathrm{DEM}} - Q_{\\mathrm{anal}} \\right| / Q_{\\mathrm{anal}}$，结果为浮点数。\n\n单位和角度规范：\n- 所有长度单位必须是米（$\\mathrm{m}$）。\n- 所有力的单位必须是牛顿（$\\mathrm{N}$）。\n- 所有弹性模量的单位必须是帕斯卡（$\\mathrm{Pa}$）。\n- 所有热导率的单位必须是瓦特每米开尔文（$\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$）。\n- 所有温差的单位必须是开尔文（$\\mathrm{K}$）。\n- 本问题不涉及角度。\n- 最终的传热量单位必须是瓦特（$\\mathrm{W}$），但程序要求输出的是每个测试用例的无量纲相对误差。\n\n使用的基本原理和定义：\n- 傅里叶热传导定律：$\\mathbf{q} = -k \\nabla T$，其中 $\\mathbf{q}$ 是热流密度矢量， $k$ 是热导率， $T$ 是温度。\n- 热阻 $R$ 通过 $Q = \\Delta T / R$ 将净传热量与温差联系起来。\n- Hertz 弹性接触理论，用于法向载荷 $F$ 下的两个球体：接触半径 $a$ 的关系式为 $a = \\left( \\dfrac{3 F R_{\\mathrm{eff}}}{4 E_{\\mathrm{eff}}} \\right)^{1/3}$，其中 $R_{\\mathrm{eff}} = \\left( \\dfrac{1}{R_1} + \\dfrac{1}{R_2} \\right)^{-1}$ 且 $E_{\\mathrm{eff}} = \\left( \\dfrac{1 - \\nu_1^2}{E_1} + \\dfrac{1 - \\nu_2^2}{E_2} \\right)^{-1}$，$E_i$ 是球体 $i$ 的杨氏模量，$\\nu_i$ 是其泊松比。\n- 对于一个半径为 $a$ 的圆形接触面的半无限体，其扩展热阻与 $a$ 和 $k$ 成反比。将两个球体的热阻视为串联以获得总热阻。\n\n测试套件：\n提供以下三个测试用例来验证不同工况和覆盖范围。在每种情况下，计算上述的相对误差 $\\varepsilon$。\n\n- 情况 1（正常情况，相同材料，中等载荷）：\n    - $R_1 = 0.010$ $\\mathrm{m}$，$R_2 = 0.010$ $\\mathrm{m}$\n    - $E_1 = 200 \\times 10^{9}$ $\\mathrm{Pa}$，$\\nu_1 = 0.30$\n    - $E_2 = 200 \\times 10^{9}$ $\\mathrm{Pa}$，$\\nu_2 = 0.30$\n    - $k_1 = 54$ $\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$，$k_2 = 54$ $\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$\n    - $F = 50$ $\\mathrm{N}$\n    - $\\Delta T = 20$ $\\mathrm{K}$\n    - $C_{\\mathrm{DEM}} = 4.0$\n\n- 情况 2（边缘情况：极小载荷，不同材料且其中一个导热性低）：\n    - $R_1 = 0.005$ $\\mathrm{m}$，$R_2 = 0.007$ $\\mathrm{m}$\n    - $E_1 = 200 \\times 10^{9}$ $\\mathrm{Pa}$，$\\nu_1 = 0.30$\n    - $E_2 = 3 \\times 10^{9}$ $\\mathrm{Pa}$，$\\nu_2 = 0.35$\n    - $k_1 = 54$ $\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$，$k_2 = 0.25$ $\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$\n    - $F = 0.05$ $\\mathrm{N}$\n    - $\\Delta T = 5$ $\\mathrm{K}$\n    - $C_{\\mathrm{DEM}} = 3.5$\n\n- 情况 3（边缘情况：大载荷，材料性质差异大）：\n    - $R_1 = 0.020$ $\\mathrm{m}$，$R_2 = 0.010$ $\\mathrm{m}$\n    - $E_1 = 110 \\times 10^{9}$ $\\mathrm{Pa}$，$\\nu_1 = 0.34$\n    - $E_2 = 70 \\times 10^{9}$ $\\mathrm{Pa}$，$\\nu_2 = 0.20$\n    - $k_1 = 400$ $\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$，$k_2 = 1.4$ $\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$\n    - $F = 300$ $\\mathrm{N}$\n    - $\\Delta T = 50$ $\\mathrm{K}$\n    - $C_{\\mathrm{DEM}} = 4.2$\n\n最终输出格式：\n您的程序应生成一行输出，其中包含三个案例的相对误差，格式为逗号分隔的列表并用方括号括起来，例如 $[ \\varepsilon_1, \\varepsilon_2, \\varepsilon_3 ]$。列表中的条目必须是浮点数。不应打印任何其他文本。",
            "solution": "该问题陈述已经过验证，被确定为计算热工学中一个适定、有科学依据的问题。该问题没有矛盾、歧义和事实错误。为给定的测试用例提供了所有必需的物理参数和常数。任务是基于第一性原理推导并实现一个球体间传热的模型，并将其与一个简化的离散元法（DEM）模型进行比较。\n\n推导和计算过程如下：\n\n**1. 接触力学：Hertz 理论**\n两个弹性球体在接触时的力学相互作用由 Hertz 理论描述。该理论提供了法向压缩力 $F$ 与所产生的圆形接触区域半径 $a$ 之间的关系。这种关系是球体几何形状和材料属性的函数。\n\n首先，为双球体系统定义一个等效曲率半径 $R_{\\mathrm{eff}}$。对于半径为 $R_1$ 和 $R_2$ 的球体，其表达式为：\n$$R_{\\mathrm{eff}} = \\left( \\frac{1}{R_1} + \\frac{1}{R_2} \\right)^{-1}$$\n其次，定义一个等效杨氏模量 $E_{\\mathrm{eff}}$，以考虑两个球体的弹性特性。给定它们各自的杨氏模量 $E_1$ 和 $E_2$，以及泊松比 $\\nu_1$ 和 $\\nu_2$，等效模量为：\n$$E_{\\mathrm{eff}} = \\left( \\frac{1 - \\nu_1^2}{E_1} + \\frac{1 - \\nu_2^2}{E_2} \\right)^{-1}$$\n利用这些等效属性，法向载荷 $F$ 下的接触半径 $a$ 的 Hertz 方程为：\n$$a = \\left( \\frac{3 F R_{\\mathrm{eff}}}{4 E_{\\mathrm{eff}}} \\right)^{1/3}$$\n\n**2. 传导传热的解析模型**\n热流由傅里叶定律 $\\mathbf{q} = -k \\nabla T$ 控制。对于指定的稳态条件，温度场满足拉普拉斯方程 $\\nabla^2 T = 0$。该问题假设，就热流向小接触区域收缩或从中扩展而言，每个球体都表现为半无限体。\n\n对于热导率为 $k$ 的单个半无限介质，与热流通过其表面半径为 $a$ 的等温圆形区域相关的热阻被称为收缩（或扩展）热阻 $R_{\\mathrm{const}}$。这是热传导理论中的一个标准结果，由下式给出：\n$$R_{\\mathrm{const}} = \\frac{1}{4 k a}$$\n问题陈述指出，双球体接触的总热阻可以通过将各个收缩热阻串联来建模。当物理界面的热阻可忽略不计时，这种方法是合适的。因此，总解析热阻 $R_{\\mathrm{anal}}$ 是球体1和球体2的热阻之和：\n$$R_{\\mathrm{anal}} = R_{1, \\mathrm{anal}} + R_{2, \\mathrm{anal}} = \\frac{1}{4 k_1 a} + \\frac{1}{4 k_2 a}$$\n提取公因式，我们得到：\n$$R_{\\mathrm{anal}} = \\frac{1}{4 a} \\left( \\frac{1}{k_1} + \\frac{1}{k_2} \\right)$$\n由于温差 $\\Delta T$ 产生的跨热阻 $R$ 的总传热速率 $Q$ 由关系式 $Q = \\Delta T / R$ 给出。因此，解析传热速率 $Q_{\\mathrm{anal}}$ 为：\n$$Q_{\\mathrm{anal}} = \\frac{\\Delta T}{R_{\\mathrm{anal}}} = \\frac{\\Delta T}{\\frac{1}{4 a} \\left( \\frac{1}{k_1} + \\frac{1}{k_2} \\right)}$$\n\n**3. 简化的 DEM 传导模型**\n提出一个在 DEM 模拟中典型的简化模型用于比较。该模型的热阻函数形式与解析解相同，但用一个通用的模型常数 $C_{\\mathrm{DEM}}$ 替换了精确的解析常数 $4$。\n\n在此 DEM 模型中，单个球体 $i$ 的热阻为：\n$$R_{i, \\mathrm{DEM}} = \\frac{1}{C_{\\mathrm{DEM}} k_i a}$$\n同样，将热阻串联相加得到 DEM 预测的总热阻 $R_{\\mathrm{DEM}}$：\n$$R_{\\mathrm{DEM}} = R_{1, \\mathrm{DEM}} + R_{2, \\mathrm{DEM}} = \\frac{1}{C_{\\mathrm{DEM}} k_1 a} + \\frac{1}{C_{\\mathrm{DEM}} k_2 a}$$\n简化后为：\n$$R_{\\mathrm{DEM}} = \\frac{1}{C_{\\mathrm{DEM}} a} \\left( \\frac{1}{k_1} + \\frac{1}{k_2} \\right)$$\n因此，DEM 预测的传热速率 $Q_{\\mathrm{DEM}}$ 为：\n$$Q_{\\mathrm{DEM}} = \\frac{\\Delta T}{R_{\\mathrm{DEM}}} = \\frac{\\Delta T}{\\frac{1}{C_{\\mathrm{DEM}} a} \\left( \\frac{1}{k_1} + \\frac{1}{k_2} \\right)}$$\n\n**4. 相对误差计算**\n最后一步是通过计算相对误差 $\\varepsilon$ 来量化 DEM 预测与解析解之间的差异：\n$$\\varepsilon = \\frac{\\left| Q_{\\mathrm{DEM}} - Q_{\\mathrm{anal}} \\right|}{Q_{\\mathrm{anal}}}$$\n通过代入 $Q_{\\mathrm{DEM}}$ 和 $Q_{\\mathrm{anal}}$ 的推导表达式，我们可以简化此表达式。令公共项为 $Z = a \\Delta T / \\left( \\frac{1}{k_1} + \\frac{1}{k_2} \\right)$。那么 $Q_{\\mathrm{DEM}} = C_{\\mathrm{DEM}} \\cdot Z$ 且 $Q_{\\mathrm{anal}} = 4 \\cdot Z$。\n$$\\varepsilon = \\frac{\\left| C_{\\mathrm{DEM}} \\cdot Z - 4 \\cdot Z \\right|}{4 \\cdot Z} = \\frac{\\left| C_{\\mathrm{DEM}} - 4 \\right| \\cdot Z}{4 \\cdot Z}$$\n由于所有物理参数均为正，因此 $Z > 0$，可以消去：\n$$\\varepsilon = \\frac{\\left| C_{\\mathrm{DEM}} - 4 \\right|}{4}$$\n此结果表明，相对误差仅取决于 DEM 常数 $C_{\\mathrm{DEM}}$ 与解析常数 $4$ 之间的偏差。所需的程序将执行完整的逐步计算以得出此误差值，从而验证整个建模过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating the relative error between an analytical\n    and a simplified DEM model for heat conduction between two elastic spheres.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple contains:\n    # (R1, R2, E1, nu1, E2, nu2, k1, k2, F, delta_T, C_dem)\n    test_cases = [\n        # Case 1 (happy path, identical materials, moderate load)\n        (0.010, 0.010, 200e9, 0.30, 200e9, 0.30, 54.0, 54.0, 50.0, 20.0, 4.0),\n        # Case 2 (edge: very small load, dissimilar materials)\n        (0.005, 0.007, 200e9, 0.30, 3e9, 0.35, 54.0, 0.25, 0.05, 5.0, 3.5),\n        # Case 3 (edge: large load, strongly dissimilar materials)\n        (0.020, 0.010, 110e9, 0.34, 70e9, 0.20, 400.0, 1.4, 300.0, 50.0, 4.2),\n    ]\n\n    def calculate_relative_error(params):\n        \"\"\"\n        Computes the relative error for a single set of parameters.\n        \"\"\"\n        R1, R2, E1, nu1, E2, nu2, k1, k2, F, delta_T, C_dem = params\n\n        # Step 1: Compute contact radius 'a' using Hertz theory.\n        \n        # Effective radius of curvature\n        R_eff = (1.0 / R1 + 1.0 / R2)**(-1.0)\n        \n        # Effective Young's modulus\n        E_eff = ((1.0 - nu1**2) / E1 + (1.0 - nu2**2) / E2)**(-1.0)\n        \n        # Contact radius\n        a = (3.0 * F * R_eff / (4.0 * E_eff))**(1.0/3.0)\n\n        # Step 2: Compute analytical heat transfer Q_anal.\n        \n        # Analytical total thermal resistance\n        R_anal = (1.0 / (4.0 * a)) * (1.0 / k1 + 1.0 / k2)\n        \n        # Analytical heat transfer\n        # Check for R_anal being zero to avoid division by zero, though physically impossible here.\n        if R_anal == 0:\n            Q_anal = float('inf') if delta_T > 0 else 0.0\n        else:\n            Q_anal = delta_T / R_anal\n            \n        # Step 3: Compute DEM-predicted heat transfer Q_dem.\n        \n        # DEM-predicted total thermal resistance\n        R_dem = (1.0 / (C_dem * a)) * (1.0 / k1 + 1.0 / k2)\n        \n        # DEM-predicted heat transfer\n        if R_dem == 0:\n            Q_dem = float('inf') if delta_T > 0 else 0.0\n        else:\n            Q_dem = delta_T / R_dem\n            \n        # Step 4: Compute the relative error epsilon.\n        \n        # Avoid division by zero if the analytical solution yields zero heat transfer.\n        if Q_anal == 0.0:\n            # If both are zero, error is 0. If only Q_anal is zero, error is infinite.\n            return 0.0 if Q_dem == 0.0 else float('inf')\n            \n        error = np.abs(Q_dem - Q_anal) / Q_anal\n        \n        return error\n\n    results = []\n    for case in test_cases:\n        result = calculate_relative_error(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}