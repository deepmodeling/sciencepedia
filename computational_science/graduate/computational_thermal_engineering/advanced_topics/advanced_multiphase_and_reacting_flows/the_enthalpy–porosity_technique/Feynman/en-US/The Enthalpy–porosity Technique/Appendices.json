{
    "hands_on_practices": [
        {
            "introduction": "Understanding the dominant physical mechanisms is the first step in analyzing any complex thermal-fluid problem. This exercise guides you through the process of non-dimensionalizing the governing equations for melting driven by natural convection, a classic scenario where the enthalpy-porosity technique is applied. By performing this analysis, you will identify the key dimensionless parameters, the Rayleigh ($Ra$) and Stefan ($Ste$) numbers, that dictate the system's behavior, providing critical insight before a single line of code is written or a simulation is run .",
            "id": "3991317",
            "problem": "A square cavity of side length $L_{c}$ is filled with a phase change material (PCM) initially at its fusion temperature $T_{m}$. At time $t=0$, the left wall is suddenly maintained at a higher temperature $T_{h}>T_{m}$, while the remaining walls are thermally insulated. The flow is modeled as incompressible under the Boussinesq approximation, and the phase change is treated using the enthalpy–porosity technique in which the mushy zone is modeled as a porous medium with a Darcy drag that vanishes in the fully liquid region and diverges in the fully solid region. The liquid properties at $T\\approx T_{m}$ are considered constant. Using first principles (conservation of mass, momentum, and energy) as the fundamental base, and by performing a systematic non-dimensionalization, identify the canonical dimensionless groups that quantify buoyancy-driven convection relative to diffusive transport and the ratio of sensible to latent heat effects during melting. Then, evaluate these dimensionless groups for the following scientifically realistic data and boundary conditions, using liquid properties for transport coefficients:\n- Cavity size: $L_{c}=0.05\\,\\text{m}$.\n- Gravity: $g=9.81\\,\\text{m}\\,\\text{s}^{-2}$.\n- Thermal expansion coefficient: $\\beta=8.00\\times 10^{-4}\\,\\text{K}^{-1}$.\n- Hot-wall temperature and fusion temperature: $T_{h}=330\\,\\text{K}$ and $T_{m}=315\\,\\text{K}$, so that the imposed temperature difference is $\\Delta T=T_{h}-T_{m}$.\n- Liquid density: $\\rho_{\\ell}=800\\,\\text{kg}\\,\\text{m}^{-3}$.\n- Liquid dynamic viscosity: $\\mu_{\\ell}=3.00\\times 10^{-3}\\,\\text{Pa}\\,\\text{s}$, giving the liquid kinematic viscosity $\\nu=\\mu_{\\ell}/\\rho_{\\ell}$.\n- Liquid thermal conductivity: $k_{\\ell}=0.200\\,\\text{W}\\,\\text{m}^{-1}\\,\\text{K}^{-1}$ and specific heat at constant pressure: $c_{p}=2000\\,\\text{J}\\,\\text{kg}^{-1}\\,\\text{K}^{-1}$, giving the liquid thermal diffusivity $\\alpha=k_{\\ell}/(\\rho_{\\ell}c_{p})$.\n- Latent heat of fusion: $L_{h}=2.00\\times 10^{5}\\,\\text{J}\\,\\text{kg}^{-1}$.\n\nBased on your nondimensionalization, compute the buoyancy–diffusion ratio customarily defined for natural convection in a cavity and the sensible-to-latent heat ratio customarily defined for melting with phase change. Then, using physical reasoning grounded in the nondimensional governing equations and the enthalpy–porosity closure, explain qualitatively how the magnitude of these two groups jointly influences the internal flow strength and the evolving interface morphology during melting. Express the final answers for these two dimensionless groups as a row matrix $\\big[Ra,\\ Ste\\big]$ and round both entries to four significant figures. Because both groups are dimensionless, no units are required for the final reported values.",
            "solution": "We begin from the conservation laws for an incompressible Newtonian fluid under the Boussinesq approximation and the enthalpy–porosity formulation for phase change. The governing equations consist of:\n- Mass conservation: $\\nabla\\cdot \\boldsymbol{u}=0$.\n- Momentum conservation (liquid region and mushy region with Darcy drag): $\\rho\\left(\\dfrac{\\partial \\boldsymbol{u}}{\\partial t}+\\boldsymbol{u}\\cdot \\nabla \\boldsymbol{u}\\right)=-\\nabla p+\\mu \\nabla^{2}\\boldsymbol{u}+\\rho\\,\\boldsymbol{g}\\,\\beta\\,(T-T_{\\text{ref}})\\,\\hat{\\boldsymbol{y}}+\\boldsymbol{S}_{D}$, where $\\boldsymbol{S}_{D}$ represents the Darcy-like sink term used in the enthalpy–porosity technique and vanishes in the fully liquid region.\n- Energy conservation written in terms of sensible–latent enthalpy: $\\dfrac{\\partial (\\rho h)}{\\partial t}+\\nabla \\cdot (\\rho \\boldsymbol{u} h)=\\nabla \\cdot (k \\nabla T)$, where the specific enthalpy $h$ is $h=h_{0}+c_{p}(T-T_{0})+L_{h} f_{\\ell}$ and $f_{\\ell}\\in[0,1]$ is the liquid fraction.\n\nUpon substituting $h$ and assuming constant $\\rho$, $c_{p}$, and $k$ (liquid properties), the energy equation can be recast as\n$$\n\\rho c_{p}\\left(\\dfrac{\\partial T}{\\partial t}+\\boldsymbol{u}\\cdot \\nabla T\\right)=k \\nabla^{2} T-\\rho L_{h}\\dfrac{\\partial f_{\\ell}}{\\partial t}.\n$$\n\nTo identify the canonical dimensionless groups, we introduce characteristic scales appropriate for natural convection and conduction in a differentially heated cavity with side length $L_{c}$ and imposed temperature difference $\\Delta T=T_{h}-T_{m}$. We choose:\n- Length scale: $L_{c}$, so $\\boldsymbol{x}=L_{c}\\,\\boldsymbol{x}^{*}$.\n- Temperature scale: $\\Delta T$, so $T=T_{\\text{ref}}+\\Delta T\\,\\theta$, with $\\theta=T^{*}$ the dimensionless temperature.\n- Velocity scale: $\\alpha/L_{c}$, where $\\alpha=k/(\\rho c_{p})$ is the thermal diffusivity, so $\\boldsymbol{u}=(\\alpha/L_{c})\\,\\boldsymbol{u}^{*}$.\n- Time scale: $L_{c}^{2}/\\alpha$, so $t=(L_{c}^{2}/\\alpha)\\,t^{*}$.\n- Pressure scale: $\\rho \\alpha^{2}/L_{c}^{2}$, so $p=(\\rho \\alpha^{2}/L_{c}^{2})\\,p^{*}$.\n\nWith these scales, the dimensionless momentum equation (neglecting the Darcy term in the fully liquid region where it vanishes, and retaining it elsewhere as a damping proportional to velocity) becomes\n$$\n\\dfrac{\\partial \\boldsymbol{u}^{*}}{\\partial t^{*}}+\\boldsymbol{u}^{*}\\cdot \\nabla^{*} \\boldsymbol{u}^{*}=-\\nabla^{*} p^{*}+\\Pr \\nabla^{*2} \\boldsymbol{u}^{*}+Ra\\,\\Pr\\,\\theta\\,\\hat{\\boldsymbol{y}}+\\boldsymbol{S}_{D}^{*},\n$$\nwhere the Prandtl number is $\\Pr=\\dfrac{\\nu}{\\alpha}$ and the Rayleigh number is\n$$\nRa=\\dfrac{g\\,\\beta\\,\\Delta T\\,L_{c}^{3}}{\\nu\\,\\alpha}.\n$$\nThis $Ra$ quantifies the ratio of buoyancy forcing to diffusive dissipation in the natural convection of a differentially heated cavity.\n\nThe dimensionless energy equation becomes\n$$\n\\dfrac{\\partial \\theta}{\\partial t^{*}}+\\boldsymbol{u}^{*}\\cdot \\nabla^{*} \\theta=\\nabla^{*2} \\theta-\\dfrac{1}{Ste}\\,\\dfrac{\\partial f_{\\ell}}{\\partial t^{*}},\n$$\nwhere the Stefan number is\n$$\nSte=\\dfrac{c_{p}\\,\\Delta T}{L_{h}}.\n$$\nThis $Ste$ measures the ratio of sensible heating over the imposed temperature difference to the latent heat required for melting; small $Ste$ indicates latent heat dominates the energy budget and slows phase change, whereas large $Ste$ indicates that sensible heat readily raises temperature relative to the latent requirement.\n\nHaving identified $Ra$ and $Ste$ from first principles via nondimensionalization, we now evaluate them for the given data.\n\nFirst compute the transport properties used in $Ra$:\n- The kinematic viscosity is\n$$\n\\nu=\\dfrac{\\mu_{\\ell}}{\\rho_{\\ell}}=\\dfrac{3.00\\times 10^{-3}}{800}=3.75\\times 10^{-6}\\ \\text{m}^{2}\\,\\text{s}^{-1}.\n$$\n- The thermal diffusivity is\n$$\n\\alpha=\\dfrac{k_{\\ell}}{\\rho_{\\ell} c_{p}}=\\dfrac{0.200}{800\\times 2000}=1.25\\times 10^{-7}\\ \\text{m}^{2}\\,\\text{s}^{-1}.\n$$\n- The imposed temperature difference is\n$$\n\\Delta T=T_{h}-T_{m}=330-315=15\\ \\text{K}.\n$$\n- The cavity length cubed is\n$$\nL_{c}^{3}=(0.05)^{3}=1.25\\times 10^{-4}\\ \\text{m}^{3}.\n$$\n\nInsert these into $Ra$:\n$$\nRa=\\dfrac{(9.81)\\,(8.00\\times 10^{-4})\\,(15)\\,(1.25\\times 10^{-4})}{(3.75\\times 10^{-6})\\,(1.25\\times 10^{-7})}.\n$$\nCompute numerator and denominator separately:\n$$\n\\text{Numerator}=9.81\\times 8.00\\times 10^{-4}\\times 15\\times 1.25\\times 10^{-4}=1.4715\\times 10^{-5},\n$$\n$$\n\\text{Denominator}=3.75\\times 10^{-6}\\times 1.25\\times 10^{-7}=4.6875\\times 10^{-13}.\n$$\nTherefore,\n$$\nRa=\\dfrac{1.4715\\times 10^{-5}}{4.6875\\times 10^{-13}}=\\left(\\dfrac{1.4715}{4.6875}\\right)\\times 10^{8}\\approx 3.139\\times 10^{7}.\n$$\n\nNext compute $Ste$:\n$$\nSte=\\dfrac{c_{p}\\,\\Delta T}{L_{h}}=\\dfrac{2000\\times 15}{2.00\\times 10^{5}}=\\dfrac{30000}{200000}=0.15.\n$$\n\nRounded to four significant figures, we obtain\n$$\nRa=3.139\\times 10^{7},\\qquad Ste=0.1500.\n$$\n\nQualitative influence on flow and interface shape within the enthalpy–porosity framework: The momentum equation shows that buoyancy enters as $Ra\\,\\Pr\\,\\theta\\,\\hat{\\boldsymbol{y}}$, so, at fixed $\\Pr$, increasing $Ra$ proportionally strengthens the driving relative to viscous and thermal diffusion. Large $Ra$ produces vigorous natural convection, increasing convective heat transport from the hot wall into the melt. Scaling analyses and correlations for differentially heated cavities indicate that the Nusselt number increases with $Ra$ (for example, $Nu\\sim Ra^{n}$ with $n>0$ in laminar regimes), which accelerates melting and deforms the solid–liquid interface: warm fluid rises along the hot wall and sweeps across the top, so the melt front typically bulges upward near the top and lags near the bottom, producing a concave interface when viewed from the liquid side. The energy equation contains the latent term $-(1/Ste)\\,\\partial f_{\\ell}/\\partial t^{*}$, revealing that, for small $Ste$, a given rate of melting ($\\partial f_{\\ell}/\\partial t^{*}$) demands a large sink from the sensible energy balance. Consequently, at small $Ste$, the temperature field remains close to the fusion isotherm in much of the domain, the mushy region broadens, and the interface advances slowly even under strong convection. Conversely, for larger $Ste$, sensible heating readily raises temperatures above $T_{m}$, shrinking the mushy zone and allowing convection-induced thermal nonuniformities to imprint more strongly on the interface shape. Jointly, large $Ra$ and large $Ste$ favor strong circulations and pronounced, asymmetric melt fronts with thin thermal boundary layers; large $Ra$ but small $Ste$ yields strong flow but an interface whose global advancement remains limited by latent heat, with melting concentrated where convective heat flux is highest (near the upper portion of the hot wall). In all cases, the enthalpy–porosity Darcy drag regularizes flow within the mushy zone, but the primary controls on flow strength and interface morphology emerge through $Ra$ and $Ste$ as derived above.\n\nFinally, per instructions, we report the two dimensionless groups as a row matrix $\\big[Ra,\\ Ste\\big]$ rounded to four significant figures.",
            "answer": "$$\\boxed{\\begin{bmatrix}3.139\\times 10^{7} & 0.1500\\end{bmatrix}}$$"
        },
        {
            "introduction": "Transitioning from continuous equations to a robust computational solver requires a carefully designed algorithm that can handle the strong nonlinearities inherent in phase-change problems. This practice challenges you to think like a CFD developer by evaluating different algorithmic structures for a segregated solver implementing the enthalpy-porosity method. The focus is on correctly handling the momentum sink term and the iterative coupling between temperature, enthalpy, and liquid fraction, which are essential for a stable and accurate simulation .",
            "id": "3991255",
            "problem": "Consider a segregated finite-volume method (FVM) implementation of the enthalpy–porosity technique for solidification/melting of a pure substance within a bounded domain. The governing laws are energy conservation and momentum balance with a Darcy-like damping term in the mushy region. The energy conservation law in enthalpy form is \n$$\\frac{\\partial (\\rho h)}{\\partial t} + \\nabla \\cdot (\\rho \\mathbf{u} h) = \\nabla \\cdot (k \\nabla T),$$ \nwith the constitutive relation \n$$h(T,f_l) = h_{\\text{sens}}(T) + f_l L, \\quad h_{\\text{sens}}(T) = \\int_{T_{\\text{ref}}}^{T} \\rho c_p(\\theta)\\, d\\theta,$$ \nwhere $h$ is enthalpy, $T$ is temperature, $f_l$ is liquid fraction, $L$ is latent heat, $\\rho$ is density, $k$ is thermal conductivity, and $c_p$ is specific heat at constant pressure. The momentum balance includes a mushy-zone sink term modeled as \n$$\\rho\\left(\\frac{\\partial \\mathbf{u}}{\\partial t} + \\mathbf{u}\\cdot\\nabla \\mathbf{u}\\right) = -\\nabla p + \\nabla\\cdot\\left(\\mu \\left(\\nabla \\mathbf{u} + \\nabla \\mathbf{u}^{\\top}\\right)\\right) - A(f_l)\\, \\mathbf{u},$$ \nwhere $\\mathbf{u}$ is velocity, $p$ is pressure, $\\mu$ is viscosity, and $A(f_l)$ is a nonnegative coefficient that grows as $f_l \\to 0$ to damp velocity in solid regions. A typical well-tested form is \n$$A(f_l) = A_m \\frac{(1 - f_l)^2}{f_l^3 + \\epsilon^3},$$ \nwith $A_m$ a large constant and $\\epsilon$ a small regularization parameter. The liquid fraction $f_l$ is defined by a smooth ramp across the phase-change interval $[T_s,T_l]$, for instance \n$$f_l(T) = \n\\begin{cases}\n0, & T \\le T_s,\\\\\n\\frac{T - T_s}{T_l - T_s}, & T_s < T < T_l,\\\\\n1, & T \\ge T_l,\n\\end{cases}$$\nor any differentiable regularization thereof so that $\\frac{df_l}{dT}$ is well-defined.\n\nYou are to choose the option that most correctly outlines pseudocode for a segregated enthalpy–porosity solver, including explicit identification of data structures for $T$, $h$, $f_l$, $\\mathbf{u}$, and the sink coefficient (or sink term) and a clear statement of where and how the nonlinearity is handled within the loop. The solver should:\n\n- Store cell-centered arrays for primary fields and coefficients consistent with FVM.\n- Respect the coupling $h(T,f_l)$ and $A(f_l)$.\n- Enforce mass conservation via Semi-Implicit Method for Pressure-Linked Equations (SIMPLE).\n- Treat the mushy-zone sink semi-implicitly in the momentum matrix to improve stability.\n- Handle the nonlinearity arising from $f_l(T)$ and $A(f_l)$ through a consistent iterative strategy within each time step.\n\nWhich option below is the most appropriate?\n\nA. Data structures: cell-centered arrays $T[\\Omega]$, $h[\\Omega]$, $f_l[\\Omega]$, $\\mathbf{u}_x[\\Omega]$, $\\mathbf{u}_y[\\Omega]$, $p[\\Omega]$, $A[\\Omega]$, and face fluxes $F[\\text{faces}]$. For each time index $n$: initialize $T^{(0)}$, $f_l^{(0)}$, $\\mathbf{u}^{(0)}$. Perform a Picard nonlinearity loop over $m$ until convergence: \n- Build momentum matrices with diagonal augmented by $A(f_l^{(m)})$; solve for $\\mathbf{u}^{(m+1)}$; apply Semi-Implicit Method for Pressure-Linked Equations (SIMPLE) pressure correction; under-relax $\\mathbf{u}$. \n- Assemble energy equation in temperature form using an effective heat capacity $c_{\\text{eff}}^{(m)} = c_p + L \\frac{df_l}{dT}\\big|_{T^{(m)}}$; solve for $T^{(m+1)}$ with advection by $\\mathbf{u}^{(m+1)}$; update $f_l^{(m+1)} = f_l(T^{(m+1)})$; update $h^{(m+1)} = h_{\\text{sens}}(T^{(m+1)}) + f_l^{(m+1)} L$; under-relax $T$, $f_l$, and $h$. \n- Recompute $A^{(m+1)} = A(f_l^{(m+1)})$; check residuals of $\\mathbf{u}$, $T$, $f_l$, and the enthalpy closure $h - \\left(h_{\\text{sens}}(T) + f_l L\\right)$; if below tolerance, advance to $n+1$. Nonlinearity is handled by freezing $f_l$ and $A$ in coefficients within each $m$ and updating them after each segregated solve.\n\nB. Data structures: $T[\\Omega]$, $h[\\Omega]$, $f_l[\\Omega]$, $\\mathbf{u}[\\Omega]$, $p[\\Omega]$. For each time index $n$: compute $f_l^{(n)}$ from $T^{(n-1)}$ once and keep it fixed; compute $A^{(n)} = A(f_l^{(n)})$; solve momentum with the sink term added to the right-hand side explicitly; skip pressure correction to save computation; solve the energy equation in $h$ form using $\\mathbf{u}^{(n)}$, then set $T^{(n)} = h^{(n)}/(\\rho c_p)$; proceed to $n+1$ with no inner iterations. Nonlinearity is handled by a single explicit update of $f_l$ per time step.\n\nC. Data structures: $h[\\Omega]$, $\\mathbf{u}[\\Omega]$, $p[\\Omega]$, $A[\\Omega]$. For each time index $n$: compute $A(f_l)$ using $f_l = h/L$ clipped to $[0,1]$; solve momentum without any diagonal augmentation by $A$ but instead subtract $A(f_l)\\mathbf{u}$ on the right-hand side; omit Semi-Implicit Method for Pressure-Linked Equations (SIMPLE) pressure correction; solve the enthalpy equation for $h$ and output $T$ only at the end via $T = h/(\\rho c_p)$. Nonlinearity is handled by evaluating $A$ from $h$ once per time step.\n\nD. Data structures: $T[\\Omega]$, $f_l[\\Omega]$, $\\mathbf{u}[\\Omega]$, $p[\\Omega]$, $A[\\Omega]$. For each time index $n$: form a single monolithic Jacobian system coupling $T$ and $\\mathbf{u}$ with entries including $\\partial A/\\partial f_l \\cdot \\partial f_l/\\partial T$; apply Newton’s method to solve the coupled system in one shot; update $f_l$ after convergence; no separate momentum or energy solves are performed. Nonlinearity is handled by Newton linearization inside the single coupled solve rather than an inner segregated loop.\n\nSelect the most appropriate option.",
            "solution": "The user requires a critical evaluation of a problem concerning the numerical implementation of the enthalpy–porosity method for solidification and melting, followed by a detailed analysis of the proposed algorithmic options.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n- **Technique**: Segregated finite-volume method (FVM) for the enthalpy–porosity technique.\n- **Application**: Solidification/melting of a pure substance.\n- **Governing Equations**:\n    - Energy Conservation: $\\frac{\\partial (\\rho h)}{\\partial t} + \\nabla \\cdot (\\rho \\mathbf{u} h) = \\nabla \\cdot (k \\nabla T)$\n    - Momentum Balance: $\\rho\\left(\\frac{\\partial \\mathbf{u}}{\\partial t} + \\mathbf{u}\\cdot\\nabla \\mathbf{u}\\right) = -\\nabla p + \\nabla\\cdot\\left(\\mu \\left(\\nabla \\mathbf{u} + \\nabla \\mathbf{u}^{\\top}\\right)\\right) - A(f_l)\\, \\mathbf{u}$\n- **Constitutive Relations**:\n    - Enthalpy: $h(T,f_l) = h_{\\text{sens}}(T) + f_l L$, with $h_{\\text{sens}}(T) = \\int_{T_{\\text{ref}}}^{T} \\rho c_p(\\theta)\\, d\\theta$.\n    - Mushy-Zone Sink Coefficient: $A(f_l) = A_m \\frac{(1 - f_l)^2}{f_l^3 + \\epsilon^3}$, where $A(f_l)$ is nonnegative and grows as $f_l \\to 0$.\n    - Liquid Fraction: $f_l(T) = \\begin{cases} 0, & T \\le T_s,\\\\ \\frac{T - T_s}{T_l - T_s}, & T_s < T < T_l,\\\\ 1, & T \\ge T_l, \\end{cases}$ or a differentiable regularization.\n- **Nomenclature**: $h$ (enthalpy), $T$ (temperature), $f_l$ (liquid fraction), $L$ (latent heat), $\\rho$ (density), $k$ (thermal conductivity), $c_p$ (specific heat), $\\mathbf{u}$ (velocity), $p$ (pressure), $\\mu$ (viscosity), $A(f_l)$ (sink coefficient).\n- **Solver Requirements**:\n    1. Store cell-centered arrays.\n    2. Respect the coupling between $h(T,f_l)$ and $A(f_l)$.\n    3. Use the Semi-Implicit Method for Pressure-Linked Equations (SIMPLE) for mass conservation.\n    4. Treat the mushy-zone sink term semi-implicitly in the momentum matrix.\n    5. Handle nonlinearity ($f_l(T)$, $A(f_l)$) with a consistent iterative strategy within each time step.\n\n**Step 2: Validate Using Extracted Givens**\n\n- **Scientific Grounding**: The problem is well-grounded in the principles of computational fluid dynamics (CFD) and heat transfer. The enthalpy-porosity model, the governing Navier-Stokes and energy equations, and the Carman-Kozeny-like formulation for the Darcy sink term are all standard, well-established components in this field.\n- **Well-Posedness**: The problem asks for the identification of a correct numerical algorithm based on a set of clearly defined physical and numerical constraints. This is a well-posed question in the context of numerical methods.\n- **Objectivity**: The problem statement is objective, using precise-technical language and mathematical definitions. The requirements for the solver (segregated, SIMPLE, semi-implicit sink) are unambiguous technical specifications.\n\nThe problem statement is free of scientific unsoundness, ambiguity, and internal contradictions. It presents a standard, non-trivial problem in computational engineering.\n\n**Step 3: Verdict and Action**\n\nThe problem statement is **valid**. The solution process will proceed with the derivation of the correct answer and evaluation of the provided options.\n\n### Solution and Option Analysis\n\nA correct algorithm for this problem must be a segregated solver, where momentum, pressure correction, and energy equations are solved sequentially within an outer iteration loop for each time step. This loop is necessary to handle the strong nonlinear coupling between the variables.\n\n1.  **Segregated Iterative Structure**: Within each time step, an iterative procedure (e.g., a Picard loop, indexed by $m$) is required. Iteration starts with a guess (e.g., values from the previous time step, $T^{(0)} = T^n$, $\\mathbf{u}^{(0)} = \\mathbf{u}^n$, etc.) and proceeds until the fields converge.\n\n2.  **Momentum Equation and Sink Term**: The momentum equation contains the sink term $-A(f_l)\\,\\mathbf{u}$. A semi-implicit treatment is required for stability. For a generic control volume $P$, the discretized momentum equation is of the form $a_P \\mathbf{u}_P = \\sum a_{nb} \\mathbf{u}_{nb} + \\mathbf{b}$. The sink term, when discretized at cell $P$, is $-A_P(f_l)\\,\\mathbf{u}_P$.\n    - An explicit treatment would add this term to the source vector $\\mathbf{b}$, using the velocity from the previous iteration: $\\mathbf{b} \\leftarrow \\mathbf{b} - A_P(f_l^{(m)})\\,\\mathbf{u}_P^{(m)}$. This is unstable for large $A_P$.\n    - A semi-implicit treatment linearizes the source term: $S = S_C + S_P \\mathbf{u}_P$. Here, $S_C = 0$ and $S_P = -A_P(f_l^{(m)})$. The term $S_P \\mathbf{u}_P$ is moved to the left-hand side of the discretized equation, augmenting the main diagonal coefficient: $a_P \\leftarrow a_P - S_P = a_P + A_P(f_l^{(m)})$. This significantly enhances stability by implicitly damping the velocity when $A_P$ is large (i.e., in the solid region).\n\n3.  **Pressure-Velocity Coupling**: The SIMPLE algorithm must be used. This involves solving the momentum equations for a predictor velocity field $\\mathbf{u}^*$, then solving a Poisson-like pressure-correction equation for $p'$, and finally correcting both the velocity and pressure fields to enforce mass conservation.\n\n4.  **Energy Equation and Phase Change**: The energy equation involves enthalpy $h$, which is a nonlinear function of temperature $T$ across the phase change interval.\n    - One approach is to solve the transport equation for enthalpy $h$ directly. This yields a new enthalpy field $h^{(m+1)}$. Subsequently, one must invert the $h(T)$ relationship to find the corresponding temperature field $T^{(m+1)}$. This inversion step itself is nonlinear.\n    - A common alternative, which linearizes the problem, is to solve for temperature $T$ using an effective heat capacity. From $h(T) = h_{\\text{sens}}(T) + f_l(T)L$, we can write $\\frac{\\partial h}{\\partial t} = \\frac{\\partial h}{\\partial T}\\frac{\\partial T}{\\partial t}$. The term $\\frac{\\partial h}{\\partial T} = \\rho c_p + L \\frac{df_l}{dT}$ acts as an effective heat capacity, $\\rho c_{\\text{eff}}$. This term can be very large in the mushy zone, capturing the latent heat effect. In a numerical scheme, $\\frac{df_l}{dT}$ would be evaluated using the temperature from the previous iteration, $T^{(m)}$.\n\n5.  **Coupling and Updates**: Within the iterative loop, after solving for the primary variables ($\\mathbf{u}^{(m+1)}$, $p^{(m+1)}$, $T^{(m+1)}$), all dependent properties must be updated. This includes the liquid fraction $f_l^{(m+1)} = f_l(T^{(m+1)})$, the enthalpy $h^{(m+1)} = h(T^{(m+1)}, f_l^{(m+1)})$, and the momentum sink coefficient $A^{(m+1)} = A(f_l^{(m+1)})$. These updated properties are then used in the next iteration, $m+1$. Under-relaxation of the variables is typically necessary to achieve a converged solution.\n\nWith these principles established, we evaluate each option.\n\n**Evaluation of Option A**\n\nThis option proposes a segregated iterative loop (Picard loop over $m$) within each time step $n$.\n- **Data Structures**: The list of cell-centered and face-based arrays is appropriate for a standard FVM code.\n- **Momentum Solve**: It correctly specifies building momentum matrices with the diagonal \"augmented by $A(f_l^{(m)})$,\" which is the required semi-implicit treatment. It then correctly describes the application of the SIMPLE algorithm for pressure correction. Under-relaxation is mentioned, which is critical for convergence. This part is entirely correct.\n- **Energy Solve**: It proposes solving the energy equation in temperature form using an effective heat capacity $c_{\\text{eff}}^{(m)} = c_p + L \\frac{df_l}{dT}\\big|_{T^{(m)}}$. This is a valid and widely used method. It correctly states that the advecting velocity should be the newly computed $\\mathbf{u}^{(m+1)}$. The subsequent update steps for $f_l^{(m+1)}$ and $h^{(m+1)}$ based on the new temperature $T^{(m+1)}$ are correct. Under-relaxation is again correctly mentioned.\n- **Nonlinearity and Convergence**: It describes the re-computation of the momentum sink coefficient $A^{(m+1)}$ from the updated $f_l^{(m+1)}$, correctly closing the loop for the next iteration. The convergence check includes residuals of primary variables and the \"enthalpy closure\" $h - (h_{\\text{sens}}(T) + f_l L)$, which is a good practice for ensuring thermodynamic consistency. The final summary of the nonlinearity handling (\"freezing $f_l$ and $A$ in coefficients within each $m$ and updating them after each segregated solve\") is an accurate description of the segregated Picard iteration strategy.\n\nThis option meticulously describes a state-of-the-art, robust algorithm that satisfies all requirements of the problem statement.\n**Verdict: Correct.**\n\n**Evaluation of Option B**\n\nThis option outlines an algorithm with several fundamental flaws.\n- It proceeds to the next time step with \"no inner iterations,\" violating the requirement for a \"consistent iterative strategy within each time step\" to handle the strong nonlinearity.\n- It treats the momentum sink term \"explicitly,\" violating the requirement for a semi-implicit treatment. This is numerically unstable.\n- It proposes to \"skip pressure correction,\" violating the requirement to use SIMPLE and fundamentally failing to enforce mass conservation.\n- The temperature update formula $T^{(n)} = h^{(n)}/(\\rho c_p)$ is physically incorrect as it completely neglects the latent heat $L$ and the proper definition of sensible enthalpy.\n- The use of $T^{(n-1)}$ to compute properties for step $n$ introduces a time lag that severely degrades accuracy and stability.\n**Verdict: Incorrect.**\n\n**Evaluation of Option C**\n\nThis option shares many of the flaws of Option B.\n- The relation $f_l = h/L$ is physically incorrect; it ignores sensible heat $h_{\\text{sens}}$.\n- The momentum sink is treated explicitly (\"subtract $A(f_l)\\mathbf{u}$ on the right-hand side\"), violating the semi-implicit requirement.\n- It omits the SIMPLE pressure correction, failing to enforce mass conservation.\n- The temperature update formula $T = h/(\\rho c_p)$ is again physically incorrect.\n- The procedure lacks the necessary inner iterations for handling nonlinearity within a time step.\n**Verdict: Incorrect.**\n\n**Evaluation of Option D**\n\nThis option describes a fundamentally different type of solver.\n- It proposes forming a \"single monolithic Jacobian system\" and applying Newton's method. This is a **coupled** solver, not a **segregated** one.\n- The problem explicitly requires a \"**segregated** finite-volume method\" and the use of \"**SIMPLE**.\" SIMPLE is an algorithm inherently designed for segregated solvers. A monolithic Newton solver and a segregated SIMPLE-based solver are mutually exclusive architectural choices.\n- While a coupled Newton solver is a valid approach for these problems, it is not the approach specified in the problem statement. Therefore, this option fails to meet the core requirements.\n**Verdict: Incorrect.**\n\n### Conclusion\n\nOption A is the only one that accurately describes a numerical algorithm consistent with all the requirements outlined in the problem statement: a segregated FVM solver using the SIMPLE algorithm, with semi-implicit treatment of the Darcy sink term and a consistent iterative strategy (Picard loop) to handle the nonlinearities of phase change.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "The final step in mastering a numerical method is to implement it and understand its behavior firsthand. This coding exercise focuses on a one-dimensional conduction-driven melting problem, allowing you to compare two common numerical formulations derived from the enthalpy-based energy equation: the direct enthalpy update and the effective heat capacity method. By implementing both and analyzing the difference in their predictions, you will gain a practical understanding of how discretization choices can impact the numerical solution's accuracy and behavior .",
            "id": "3991244",
            "problem": "Consider one-dimensional transient conduction with melting in a slab governed by energy conservation. The enthalpy–porosity technique treats the latent heat by evolving the enthalpy field and relating it to temperature and liquid fraction, while the effective heat capacity formulation treats latent heat by augmenting the heat capacity over a finite mushy temperature interval. You must implement both formulations for the same discretization and mushy interval and compute the difference in the estimated interface location over time. Work in purely mathematical terms and produce results that depend only on the specified parameters.\n\nFundamental base: Start from energy conservation in one dimension for a phase-changing material without fluid motion. Let $x \\in [0,L]$ be the spatial coordinate. The governing law is the energy equation\n$$\n\\rho \\frac{\\partial h}{\\partial t} = \\frac{\\partial}{\\partial x}\\left(k \\frac{\\partial T}{\\partial x}\\right),\n$$\nwhere $\\rho$ is density, $h$ is specific enthalpy, $k$ is thermal conductivity, and $T$ is temperature. The boundary conditions are $T(0,t)=T_{\\text{hot}}$ (Dirichlet) and $\\frac{\\partial T}{\\partial x}(L,t)=0$ (adiabatic Neumann), and the initial condition is $T(x,0)=T_{\\text{init}}$.\n\nLatent heat is incorporated using a linear liquid fraction $f_{\\ell}(T)$ across a finite mushy interval. Define the melting temperature $T_m$ and the mushy half-width $\\Delta T/2$. The solidus and liquidus are $T_s = T_m - \\Delta T/2$ and $T_{\\ell i} = T_m + \\Delta T/2$, respectively. Define\n$$\nf_{\\ell}(T) = \n\\begin{cases}\n0, & T \\le T_s,\\\\\n\\frac{T - T_s}{\\Delta T}, & T_s < T < T_{\\ell i},\\\\\n1, & T \\ge T_{\\ell i}.\n\\end{cases}\n$$\nThe latent heat per unit mass is $L_h$. The specific enthalpy is defined as\n$$\nh(T) = c_p T + L_h f_{\\ell}(T),\n$$\nwith $c_p$ the specific heat capacity of the sensible part.\n\nTwo formulations must be implemented on the same grid and time step:\n- Enthalpy–porosity formulation: Evolve $h$ according to the energy equation using the temperature in the diffusion term, then recover $T$ at each node by inverting the piecewise-linear relationship $h(T)$.\n- Effective heat capacity formulation: Evolve $T$ according to\n$$\n\\rho c_{\\text{app}}(T)\\frac{\\partial T}{\\partial t} = \\frac{\\partial}{\\partial x}\\left(k \\frac{\\partial T}{\\partial x}\\right),\n$$\nwhere the apparent heat capacity is defined by\n$$\nc_{\\text{app}}(T) =\n\\begin{cases}\nc_p, & T \\le T_s,\\\\\nc_p + \\frac{L_h}{\\Delta T}, & T_s < T < T_{\\ell i},\\\\\nc_p, & T \\ge T_{\\ell i}.\n\\end{cases}\n$$\n\nInterface location definition: The phase-change interface is defined as the location where the liquid fraction equals $0.5$. Let $x_{0.5}(t)$ be the unique $x$ such that $f_{\\ell}(T(x,t)) = 0.5$; in discrete form, you must linearly interpolate between grid nodes to locate $x_{0.5}$. For the enthalpy–porosity formulation, compute $f_{\\ell}$ from the recovered temperature. For the effective heat capacity formulation, compute $f_{\\ell}$ directly from the temperature field. The required quantity is the absolute difference $\\Delta x(t)$ between the two formulations’ $x_{0.5}(t)$ at prescribed times.\n\nNumerical method requirements:\n- Use a uniform grid with spacing $dx$, $N = \\lfloor L/dx \\rfloor + 1$ nodes, explicit time stepping with step $dt$, and second-order central differences for the Laplacian in the interior. Enforce the Dirichlet boundary at $x=0$ by assigning $T(0,t)=T_{\\text{hot}}$ at each time step. Enforce the adiabatic boundary at $x=L$ by a zero-gradient ghost-node approach $T_{N}(t) = T_{N-1}(t)$ when computing the second derivative.\n- For the enthalpy–porosity formulation, update specific enthalpy as\n$$\nh_i^{n+1} = h_i^n + \\frac{dt}{\\rho} k \\left.\\frac{\\partial^2 T}{\\partial x^2}\\right|_i^n,\n$$\nthen invert $h^{n+1}_i$ to find $T^{n+1}_i$ using the piecewise linear $h(T)$ defined above. After inversion, reimpose $T^{n+1}_0 = T_{\\text{hot}}$ and set $h^{n+1}_0 = h(T_{\\text{hot}})$.\n- For the effective heat capacity formulation, update temperature as\n$$\nT_i^{n+1} = T_i^n + \\frac{dt}{\\rho c_{\\text{app}}(T_i^n)} k \\left.\\frac{\\partial^2 T}{\\partial x^2}\\right|_i^n,\n$$\nand reimpose $T^{n+1}_0 = T_{\\text{hot}}$.\n- The Laplacian at an interior node $i$ is $\\left.\\frac{\\partial^2 T}{\\partial x^2}\\right|_i \\approx \\frac{T_{i+1}-2T_i+T_{i-1}}{dx^2}$. At the adiabatic end node $i=N-1$, use a ghost-node approximation $\\left.\\frac{\\partial^2 T}{\\partial x^2}\\right|_{N-1} \\approx \\frac{T_{N-2}-T_{N-1}}{dx^2}$.\n\nPhysical parameters and units:\n- Domain length $L$ in $\\mathrm{m}$, thermal conductivity $k$ in $\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$, density $\\rho$ in $\\mathrm{kg}\\,\\mathrm{m}^{-3}$, specific heat $c_p$ in $\\mathrm{J}\\,\\mathrm{kg}^{-1}\\,\\mathrm{K}^{-1}$, latent heat $L_h$ in $\\mathrm{J}\\,\\mathrm{kg}^{-1}$, temperatures $T_{\\text{hot}}$, $T_m$, $T_{\\text{init}}$ in $\\mathrm{K}$, mushy width $\\Delta T$ in $\\mathrm{K}$, spatial step $dx$ in $\\mathrm{m}$, and time step $dt$ in $\\mathrm{s}$. All outputs must be reported in $\\mathrm{m}$.\n\nTest suite and coverage:\nUse the following four parameter sets, each providing times at which to report the interface difference. All parameters are scientifically plausible and consistent, and all outputs must be floats in meters.\n\nMaterial parameters common to all tests: $\\rho = 800\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$, $k = 0.2\\,\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$, $c_p = 2000\\,\\mathrm{J}\\,\\mathrm{kg}^{-1}\\,\\mathrm{K}^{-1}$, $L_h = 200000\\,\\mathrm{J}\\,\\mathrm{kg}^{-1}$, $T_m = 300\\,\\mathrm{K}$, $T_{\\text{hot}} = 320\\,\\mathrm{K}$, $T_{\\text{init}} = 280\\,\\mathrm{K}$.\n\n- Test 1 (happy path, fine grid): $L=0.05\\,\\mathrm{m}$, $dx=0.001\\,\\mathrm{m}$, $dt=1.0\\,\\mathrm{s}$, $\\Delta T=4.0\\,\\mathrm{K}$, times $\\{100\\,\\mathrm{s},300\\,\\mathrm{s},600\\,\\mathrm{s},1000\\,\\mathrm{s}\\}$.\n- Test 2 (near stability limit, same grid): $L=0.05\\,\\mathrm{m}$, $dx=0.001\\,\\mathrm{m}$, $dt=3.5\\,\\mathrm{s}$, $\\Delta T=4.0\\,\\mathrm{K}$, times $\\{100\\,\\mathrm{s},500\\,\\mathrm{s},900\\,\\mathrm{s}\\}$.\n- Test 3 (sharp interface limit, small mushy width): $L=0.05\\,\\mathrm{m}$, $dx=0.001\\,\\mathrm{m}$, $dt=1.0\\,\\mathrm{s}$, $\\Delta T=0.5\\,\\mathrm{K}$, times $\\{100\\,\\mathrm{s},300\\,\\mathrm{s},600\\,\\mathrm{s},1000\\,\\mathrm{s}\\}$.\n- Test 4 (coarse grid): $L=0.05\\,\\mathrm{m}$, $dx=0.002\\,\\mathrm{m}$, $dt=8.0\\,\\mathrm{s}$, $\\Delta T=8.0\\,\\mathrm{K}$, times $\\{128\\,\\mathrm{s},256\\,\\mathrm{s},512\\,\\mathrm{s},800\\,\\mathrm{s}\\}$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element of the outer list corresponds to one test case and must itself be a bracket-enclosed comma-separated list of floats in meters representing the absolute difference $\\Delta x(t)$ at the prescribed times for that test. For example: \"[[0.001,0.002],[0.003]]\" with actual values computed from the simulation. No additional text must be printed.",
            "solution": "The problem has been validated and is determined to be a well-posed, scientifically sound, and complete problem in computational heat transfer. It requires the implementation and comparison of two standard numerical methods for solving one-dimensional transient heat conduction with phase change. All parameters, equations, and numerical procedures are explicitly defined, allowing for a deterministic and verifiable solution.\n\nThe physical system is governed by the conservation of energy, expressed in terms of specific enthalpy $h$:\n$$\n\\rho \\frac{\\partial h}{\\partial t} = \\frac{\\partial}{\\partial x}\\left(k \\frac{\\partial T}{\\partial x}\\right)\n$$\nwhere $\\rho$ is density, $k$ is thermal conductivity, $T$ is temperature, and $t$ is time. The spatial domain is $x \\in [0, L]$. The material undergoes a phase transition, and its specific enthalpy $h$ is a function of both sensible heat (related to temperature change) and latent heat (related to phase change). The relationship is given by:\n$$\nh(T) = c_p T + L_h f_{\\ell}(T)\n$$\nHere, $c_p$ is the specific heat capacity and $L_h$ is the latent heat of fusion. The liquid fraction, $f_{\\ell}(T)$, is defined as a linear function of temperature across a finite mushy interval $[T_s, T_{\\ell i}]$, where $T_s = T_m - \\Delta T/2$ is the solidus temperature and $T_{\\ell i} = T_m + \\Delta T/2$ is the liquidus temperature:\n$$\nf_{\\ell}(T) = \n\\begin{cases}\n0, & T \\le T_s \\\\\n\\frac{T - T_s}{\\Delta T}, & T_s < T < T_{\\ell i} \\\\\n1, & T \\ge T_{\\ell i}\n\\end{cases}\n$$\nThe problem requires a comparison of two explicit numerical formulations for solving this system.\n\n**1. Enthalpy–Porosity (EP) Formulation**\nThis method directly discretizes the energy equation in its enthalpy form. Using a forward-in-time, central-in-space (FTCS) scheme, the enthalpy at a spatial node $i$ and time step $n+1$ is updated based on the temperature field at the previous time step $n$:\n$$\nh_i^{n+1} = h_i^n + \\frac{dt}{\\rho} k \\left( \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{dx^2} \\right)\n$$\nAfter the new enthalpy field $h^{n+1}$ is computed, the temperature field $T^{n+1}$ is recovered by inverting the piecewise-linear $h(T)$ relationship. This inversion is performed pointwise at each node:\n- If $h \\le c_p T_s$, the material is solid: $T = h / c_p$.\n- If $h \\ge c_p T_{\\ell i} + L_h$, the material is liquid: $T = (h - L_h) / c_p$.\n- If $c_p T_s < h < c_p T_{\\ell i} + L_h$, the material is in the mushy zone: $T = T_s + \\frac{h - c_p T_s}{c_p + L_h/\\Delta T}$.\n\n**2. Effective Heat Capacity (EHC) Formulation**\nThis method recasts the governing equation in terms of temperature by defining an apparent heat capacity, $c_{\\text{app}}(T) = dh/dT$. This results in a nonlinear heat equation:\n$$\n\\rho c_{\\text{app}}(T)\\frac{\\partial T}{\\partial t} = \\frac{\\partial}{\\partial x}\\left(k \\frac{\\partial T}{\\partial x}\\right)\n$$\nwhere $c_{\\text{app}}(T)$ is a piecewise-constant function:\n$$\nc_{\\text{app}}(T) =\n\\begin{cases}\nc_p, & T \\le T_s \\text{ or } T \\ge T_{\\ell i} \\\\\nc_p + \\frac{L_h}{\\Delta T}, & T_s < T < T_{\\ell i}\n\\end{cases}\n$$\nThe explicit FTCS discretization for this formulation updates the temperature directly:\n$$\nT_i^{n+1} = T_i^n + \\frac{dt}{\\rho c_{\\text{app}}(T_i^n)} k \\left( \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{dx^2} \\right)\n$$\nThe core difference between the two methods lies in the explicit time-marching scheme. In the EHC method, the term $c_{\\text{app}}(T_i^n)$ explicitly uses the temperature at time step $n$ to determine the capacity for heat absorption. In the EP method, this effect is handled implicitly during the inversion step after $h_i^{n+1}$ has already been calculated using the temperature gradient from time $n$. This time lag in accounting for latent heat absorption is the primary source of the numerical discrepancy between the two schemes.\n\n**Numerical Discretization and Boundary Conditions**\nBoth formulations are implemented on a uniform grid with $N = \\lfloor L/dx \\rfloor + 1$ nodes. The spatial step is $dx$ and the time step is $dt$.\n- At the left boundary ($x=0$, node $i=0$), a Dirichlet condition is enforced by setting $T_0^{n+1} = T_{\\text{hot}}$ at every time step. For the EP method, $h_0^{n+1}$ is also updated accordingly.\n- At the right boundary ($x=L$, node $i=N-1$), an adiabatic condition ($\\partial T/\\partial x = 0$) is enforced. The problem specifies using a ghost node $T_N = T_{N-1}$ to approximate the Laplacian, resulting in a non-standard, first-order accurate formula:\n$$\n\\left.\\frac{\\partial^2 T}{\\partial x^2}\\right|_{N-1} \\approx \\frac{T_{N-2}-T_{N-1}}{dx^2}\n$$\nThis specific discretization is used consistently for both formulations to ensure a fair comparison.\n\n**Interface Location**\nThe phase-change interface is defined as the location $x_{0.5}(t)$ where the liquid fraction is exactly $f_{\\ell}=0.5$. Since the solution is computed on discrete grid nodes, the location is found by linear interpolation. First, the liquid fraction $f_{\\ell}(T_i)$ is computed for all nodes $i$. Then, two adjacent nodes $i$ and $i+1$ that bracket the value $0.5$ (i.e., $f_{\\ell}(T_i) \\le 0.5 < f_{\\ell}(T_{i+1})$) are identified. The interface location is then calculated as:\n$$\nx_{0.5} = x_i + dx \\left( \\frac{0.5 - f_{\\ell}(T_i)}{f_{\\ell}(T_{i+1}) - f_{\\ell}(T_i)} \\right)\n$$\nThis procedure is performed for both the EP and EHC simulations at the required time points. The final output is the absolute difference between the interface locations predicted by the two methods, $\\Delta x(t) = |x_{0.5, \\text{EP}}(t) - x_{0.5, \\text{EHC}}(t)|$. The solution is generated by running parallel simulations for each test case, collecting the interface positions at the specified times, and computing their differences.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_f_l(T, T_s, delta_T):\n    \"\"\"Computes the liquid fraction array from a temperature array.\"\"\"\n    # Using np.clip for a concise way to implement the piecewise function\n    # f_l = (T - T_s) / delta_T, clipped to the range [0, 1]\n    # Small epsilon to handle floating point comparisons at boundaries\n    epsilon = 1e-9\n    f_l = np.clip((T - T_s) / (delta_T + epsilon), 0.0, 1.0)\n    return f_l\n\ndef h_from_T(T, c_p, L_h, T_s, delta_T):\n    \"\"\"Computes the specific enthalpy from temperature.\"\"\"\n    if isinstance(T, np.ndarray):\n        f_l = get_f_l(T, T_s, delta_T)\n        return c_p * T + L_h * f_l\n    else: # scalar\n        f_l = 0.0\n        T_li = T_s + delta_T\n        if T > T_s:\n            if T  T_li:\n                f_l = (T-T_s)/delta_T\n            else:\n                f_l = 1.0\n        return c_p * T + L_h * f_l\n\ndef T_from_h(h, c_p, L_h, T_s, delta_T):\n    \"\"\"Computes the temperature by inverting the enthalpy relation.\"\"\"\n    T = np.zeros_like(h)\n    T_li = T_s + delta_T\n\n    h_s = c_p * T_s\n    h_li = c_p * T_li + L_h\n\n    solid_mask = h = h_s\n    liquid_mask = h >= h_li\n    mushy_mask = (~solid_mask)  (~liquid_mask)\n\n    T[solid_mask] = h[solid_mask] / c_p\n    T[liquid_mask] = (h[liquid_mask] - L_h) / c_p\n\n    c_app_mushy = c_p + L_h / delta_T\n    T[mushy_mask] = T_s + (h[mushy_mask] - h_s) / c_app_mushy\n    \n    return T\n\ndef get_c_app(T, c_p, L_h, T_s, delta_T):\n    \"\"\"Computes the apparent heat capacity from temperature.\"\"\"\n    c_app = np.full_like(T, c_p)\n    T_li = T_s + delta_T\n    mushy_mask = (T > T_s)  (T  T_li)\n    c_app[mushy_mask] += L_h / delta_T\n    return c_app\n\ndef find_interface(T, x_nodes, T_s, delta_T):\n    \"\"\"Finds the interface location (f_l=0.5) by linear interpolation.\"\"\"\n    f_l = get_f_l(T, T_s, delta_T)\n    \n    # searchsorted finds the first index i where a[i] >= value\n    # We want to find i where f_l[i-1] = 0.5  f_l[i]\n    # np.searchsorted gives the insertion point, which is our upper index\n    idx1 = np.searchsorted(f_l, 0.5)\n\n    if idx1 == 0:\n        return 0.0\n    if idx1 == len(x_nodes):\n        return x_nodes[-1]\n\n    idx0 = idx1 - 1\n    \n    f_l0 = f_l[idx0]\n    f_l1 = f_l[idx1]\n\n    x0 = x_nodes[idx0]\n    \n    if f_l1 == f_l0:\n        return x0 if f_l0 >= 0.5 else x_nodes[-1]\n        \n    # Linear interpolation\n    x_interface = x0 + (x_nodes[idx1] - x0) * (0.5 - f_l0) / (f_l1 - f_l0)\n    return x_interface\n\ndef run_simulation(method, L, dx, dt, delta_T, report_times, params):\n    \"\"\"Runs a single simulation for a given method (EP or EHC).\"\"\"\n    rho, k, c_p, L_h, T_m, T_hot, T_init = params\n\n    T_s = T_m - delta_T / 2\n    N = int(round(L / dx)) + 1\n    x_nodes = np.linspace(0, L, N)\n    max_time = max(report_times)\n\n    T = np.full(N, T_init)\n    T[0] = T_hot\n    h = h_from_T(T, c_p, L_h, T_s, delta_T) if method == 'EP' else None\n    \n    x05_results = []\n    current_time = 0.0\n    \n    sorted_report_times = sorted(list(report_times))\n    report_idx = 0\n\n    while current_time  max_time + dt:\n        \n        while report_idx  len(sorted_report_times) and current_time >= sorted_report_times[report_idx]:\n            x05 = find_interface(T, x_nodes, T_s, delta_T)\n            x05_results.append(x05)\n            report_idx += 1\n\n        T_old = T.copy()\n\n        laplacian = np.zeros(N)\n        laplacian[1:N-1] = (T_old[2:N] - 2*T_old[1:N-1] + T_old[0:N-2]) / (dx**2)\n        laplacian[N-1] = (T_old[N-2] - T_old[N-1]) / (dx**2)\n        \n        if method == 'EP':\n            h[1:N] += (dt / rho) * k * laplacian[1:N]\n            T = T_from_h(h, c_p, L_h, T_s, delta_T)\n            T[0] = T_hot\n            h[0] = h_from_T(T[0], c_p, L_h, T_s, delta_T)\n        else: # EHC\n            c_app = get_c_app(T_old, c_p, L_h, T_s, delta_T)\n            T[1:N] = T_old[1:N] + (dt / (rho * c_app[1:N])) * k * laplacian[1:N]\n            T[0] = T_hot\n        \n        current_time += dt\n\n    while report_idx  len(sorted_report_times):\n        x05 = find_interface(T, x_nodes, T_s, delta_T)\n        x05_results.append(x05)\n        report_idx += 1\n\n    return x05_results\n    \ndef solve():\n    \"\"\"Main solver function to run all test cases and print results.\"\"\"\n    # Common material parameters\n    common_params = {\n        \"rho\": 800.0, \"k\": 0.2, \"c_p\": 2000.0, \"L_h\": 200000.0,\n        \"T_m\": 300.0, \"T_hot\": 320.0, \"T_init\": 280.0\n    }\n    \n    test_cases = [\n        {\"L\": 0.05, \"dx\": 0.001, \"dt\": 1.0, \"delta_T\": 4.0, \"times\": {100.0, 300.0, 600.0, 1000.0}},\n        {\"L\": 0.05, \"dx\": 0.001, \"dt\": 3.5, \"delta_T\": 4.0, \"times\": {100.0, 500.0, 900.0}},\n        {\"L\": 0.05, \"dx\": 0.001, \"dt\": 1.0, \"delta_T\": 0.5, \"times\": {100.0, 300.0, 600.0, 1000.0}},\n        {\"L\": 0.05, \"dx\": 0.002, \"dt\": 8.0, \"delta_T\": 8.0, \"times\": {128.0, 256.0, 512.0, 800.0}}\n    ]\n\n    all_results = []\n    \n    p = common_params\n    params_tuple = (p['rho'], p['k'], p['c_p'], p['L_h'], p['T_m'], p['T_hot'], p['T_init'])\n\n    for case in test_cases:\n        L, dx, dt, delta_T, times = case.values()\n        \n        sorted_times = sorted(list(times))\n        \n        x05_ep_raw = run_simulation('EP', L, dx, dt, delta_T, times, params_tuple)\n        x05_ehc_raw = run_simulation('EHC', L, dx, dt, delta_T, times, params_tuple)\n        \n        diffs = np.abs(np.array(x05_ep_raw) - np.array(x05_ehc_raw))\n        \n        time_map = {t: d for t, d in zip(sorted_times, diffs)}\n        sorted_diffs = [time_map[t] for t in sorted_times]\n\n        all_results.append(sorted_diffs)\n    \n    result_strings = [f\"[{','.join([f'{x:.10f}' for x in res_list])}]\" for res_list in all_results]\n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}