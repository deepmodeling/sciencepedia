{
    "hands_on_practices": [
        {
            "introduction": "We begin our practical journey with the Dirichlet boundary condition, where the temperature at a boundary is explicitly prescribed. This exercise guides you through the process of discretizing the transient heat equation using the explicit forward-Euler method. More importantly, it delves into the crucial concept of numerical stability, helping you derive the conditions under which your simulation will produce physically meaningful results rather than diverging uncontrollably. ",
            "id": "3938346",
            "problem": "Consider one-dimensional heat conduction in a homogeneous slab occupying the interval $x \\in [0,L]$ with constant thermal properties. Let $T(x,t)$ denote the temperature field. The slab obeys conservation of energy and Fourier's law. Dirichlet boundary conditions impose that the temperature at the boundaries is fixed by external reservoirs. The physical meaning of such Dirichlet boundary conditions is that the boundaries are maintained at prescribed temperatures by ideal thermostats with infinite heat capacity and infinite thermal conductance, thereby enforcing $T(0,t)=T_L$ and $T(L,t)=T_R$ for all time $t$.\n\nStarting from the conservation of energy and Fourier's law, derive the governing Partial Differential Equation (PDE) for transient heat conduction in the slab with constant density $\\rho$, specific heat capacity $c$, and thermal conductivity $k$. Explain, on physical grounds, why a Dirichlet boundary condition enforces a fixed temperature at the boundary and how it differs from a Neumann boundary condition and a Robin boundary condition. Then, discretize the PDE in space using a uniform grid and central differences with spacing $h$, and discretize in time using the forward Euler method with time step $\\Delta t$ to obtain a Finite Difference Method (FDM) update equation for interior nodes under Dirichlet boundary conditions. Using a principle-based stability analysis (energy method or Fourier/von Neumann analysis), derive the necessary and sufficient condition on the parameters $\\alpha$, $\\Delta t$, and $h$ that guarantees stability of the explicit scheme, where $\\alpha = k/(\\rho c)$ is the thermal diffusivity. Finally, in the steady state with no internal heat generation, derive the temperature distribution and the constant heat flux according to Fourier's law.\n\nYour program must implement these derived results to evaluate a test suite of parameter sets. For each test case, compute:\n- A boolean indicating whether the explicit forward-Euler central-difference discretization is stable under Dirichlet boundary conditions.\n- The steady-state boundary heat flux at $x=0$ in watts per square meter (W/m$^2$), expressed as a float in W/m$^2$.\n\nUse the following test suite. All quantities are specified with units and must be interpreted as such:\n- Test case $1$: $L = 0.1 \\text{ m}$, $N_c = 20$ uniform cells, $h = L/N_c$, $\\alpha = 1.2\\times 10^{-4} \\text{ m}^2/\\text{s}$, $\\Delta t = 0.052083333333 \\text{ s}$, $k = 400 \\text{ W}/(\\text{m}\\cdot\\text{K})$, $T_L = 300 \\text{ K}$, $T_R = 350 \\text{ K}$.\n- Test case $2$: $L = 0.2 \\text{ m}$, $N_c = 40$ uniform cells, $h = L/N_c$, $\\alpha = 1.0\\times 10^{-5} \\text{ m}^2/\\text{s}$, $\\Delta t = 1.25 \\text{ s}$, $k = 50 \\text{ W}/(\\text{m}\\cdot\\text{K})$, $T_L = 300 \\text{ K}$, $T_R = 300 \\text{ K}$.\n- Test case $3$: $L = 0.1 \\text{ m}$, $N_c = 20$ uniform cells, $h = L/N_c$, $\\alpha = 1.2\\times 10^{-4} \\text{ m}^2/\\text{s}$, $\\Delta t = 0.12 \\text{ s}$, $k = 400 \\text{ W}/(\\text{m}\\cdot\\text{K})$, $T_L = 350 \\text{ K}$, $T_R = 300 \\text{ K}$.\n- Test case $4$: $L = 0.05 \\text{ m}$, $N_c = 100$ uniform cells, $h = L/N_c$, $\\alpha = 8.0\\times 10^{-5} \\text{ m}^2/\\text{s}$, $\\Delta t = 1.0\\times 10^{-4} \\text{ s}$, $k = 150 \\text{ W}/(\\text{m}\\cdot\\text{K})$, $T_L = 310 \\text{ K}$, $T_R = 330 \\text{ K}$.\n\nIn all cases, assume no internal volumetric heat generation, and express the steady-state heat flux in W/m$^2$. Angles do not appear in this problem, so no angle unit is required. The final output format must be a single line containing a comma-separated list enclosed in square brackets, where each test case result is itself a two-element list of the form $[\\text{stable}, \\text{flux}]$ with the boolean followed by the float. For example, the program should print a line like $[[\\text{True}, -123.456],[\\text{False}, 0.0]]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with no spaces inside brackets.",
            "solution": "The problem requires a comprehensive derivation and analysis of one-dimensional transient heat conduction, followed by the implementation of the derived results to solve specific test cases. The steps are as follows: derivation of the governing partial differential equation (PDE), a physical explanation of boundary conditions, discretization of the PDE, stability analysis of the numerical scheme, and derivation of the steady-state solution.\n\n**1. Derivation of the Governing PDE**\n\nThe governing equation for heat conduction is derived from the principle of conservation of energy. Consider a one-dimensional slab of homogeneous material with constant properties: density $\\rho$, specific heat capacity $c$, and thermal conductivity $k$. For an arbitrary control volume within the slab from $x$ to $x+\\Delta x$ with a uniform cross-sectional area $A$, the energy balance equation is:\n\nRate of change of internal energy = Rate of heat entering - Rate of heat leaving + Rate of heat generation\n\nMathematically, this is expressed as:\n$$\n\\frac{\\partial}{\\partial t} \\int_{x}^{x+\\Delta x} \\rho c T(u,t) A \\, du = A q(x,t) - A q(x+\\Delta x, t) + \\int_{x}^{x+\\Delta x} \\dot{q}_{gen}(u,t) A \\, du\n$$\nwhere $T(x,t)$ is the temperature, $q(x,t)$ is the heat flux (energy per unit area per unit time), and $\\dot{q}_{gen}$ is the volumetric rate of internal heat generation. Dividing by $A\\Delta x$ and taking the limit as $\\Delta x \\to 0$ yields the differential form of the energy conservation equation:\n$$\n\\rho c \\frac{\\partial T}{\\partial t} = -\\frac{\\partial q}{\\partial x} + \\dot{q}_{gen}\n$$\nFourier's law of heat conduction relates the heat flux to the temperature gradient:\n$$\nq = -k \\frac{\\partial T}{\\partial x}\n$$\nThe negative sign indicates that heat flows from higher to lower temperatures. Substituting Fourier's law into the energy equation gives:\n$$\n\\rho c \\frac{\\partial T}{\\partial t} = -\\frac{\\partial}{\\partial x} \\left(-k \\frac{\\partial T}{\\partial x}\\right) + \\dot{q}_{gen} = \\frac{\\partial}{\\partial x} \\left(k \\frac{\\partial T}{\\partial x}\\right) + \\dot{q}_{gen}\n$$\nFor a homogeneous material with constant thermal conductivity $k$, and with no internal heat generation ($\\dot{q}_{gen}=0$ as specified), the equation simplifies to:\n$$\n\\rho c \\frac{\\partial T}{\\partial t} = k \\frac{\\partial^2 T}{\\partial x^2}\n$$\nDividing by $\\rho c$ gives the final form of the one-dimensional transient heat conduction equation:\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2}\n$$\nwhere $\\alpha = k/(\\rho c)$ is the thermal diffusivity, a material property that measures how quickly heat propagates through the material.\n\n**2. Physical Meaning of Boundary Conditions**\n\nBoundary conditions are essential for obtaining a unique solution to the PDE. They represent the thermal interaction of the system with its surroundings.\n\n- **Dirichlet Boundary Condition (Type I)**: This condition specifies a fixed temperature at the boundary, i.e., $T(x_b, t) = T_{prescribed}$. Physically, this represents a boundary in contact with an ideal thermal reservoir that has an infinite heat capacity and infinite thermal conductance. Such a reservoir can absorb or supply any amount of heat required to maintain its temperature, which is imposed on the boundary. Examples include a boundary in contact with a large body of fluid undergoing a phase change (e.g., an ice-water bath).\n\n- **Neumann Boundary Condition (Type II)**: This condition specifies the heat flux at the boundary, i.e., $-k \\frac{\\partial T}{\\partial x}\\big|_{x_b} = q_{prescribed}$. A special and common case is the adiabatic or insulated boundary, where the heat flux is zero ($q_{prescribed}=0$). Physically, this models a boundary where a known heating or cooling rate is applied, such as from an electrical heater of known power output, or a boundary that is perfectly insulated, preventing any heat from crossing it. In contrast to the Dirichlet condition where the temperature is fixed, here the temperature at the boundary is free to evolve based on the heat flow within the domain.\n\n- **Robin Boundary Condition (Type III)**: This condition specifies a relationship between the temperature at the boundary and the heat flux, typically representing convective heat transfer to a surrounding fluid. It is expressed as $-k \\frac{\\partial T}{\\partial x}\\big|_{x_b} = h_{conv} (T(x_b, t) - T_{\\infty})$, where $h_{conv}$ is the convection heat transfer coefficient and $T_{\\infty}$ is the temperature of the surrounding fluid. This condition is a more realistic representation for many engineering systems than either Dirichlet or Neumann, as it models a finite rate of heat transfer to or from an external medium. It bridges the gap between the ideal fixed temperature (Dirichlet, corresponding to $h_{conv} \\to \\infty$) and fixed flux (Neumann).\n\n**3. Finite Difference Discretization**\n\nTo solve the PDE numerically, we discretize the domain in space and time. The spatial domain $x \\in [0,L]$ is divided into $N_c$ uniform cells, resulting in $N_c+1$ nodes indexed $i=0, 1, \\dots, N_c$. The spacing is $h=L/N_c$. The time is discretized with a step $\\Delta t$, with time levels indexed by $n$.\nLet $T_i^n \\approx T(x_i, t_n)$, where $x_i = i h$ and $t_n = n \\Delta t$.\n\nThe PDE is $\\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2}$.\n- The time derivative is approximated using the **Forward Euler** method (a first-order forward difference):\n$$\n\\frac{\\partial T}{\\partial t} \\bigg|_{i,n} \\approx \\frac{T_i^{n+1} - T_i^n}{\\Delta t}\n$$\n- The spatial second derivative is approximated using the **Central Difference** scheme (a second-order central difference):\n$$\n\\frac{\\partial^2 T}{\\partial x^2} \\bigg|_{i,n} \\approx \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{h^2}\n$$\nSubstituting these approximations into the PDE:\n$$\n\\frac{T_i^{n+1} - T_i^n}{\\Delta t} = \\alpha \\left( \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{h^2} \\right)\n$$\nSolving for the temperature at the next time step, $T_i^{n+1}$, gives the explicit update equation for interior nodes ($i=1, \\dots, N_c-1$):\n$$\nT_i^{n+1} = T_i^n + \\frac{\\alpha \\Delta t}{h^2} (T_{i+1}^n - 2T_i^n + T_{i-1}^n)\n$$\nThis can be written using the non-dimensional mesh Fourier number, $Fo = \\frac{\\alpha \\Delta t}{h^2}$:\n$$\nT_i^{n+1} = T_i^n + Fo (T_{i+1}^n - 2T_i^n + T_{i-1}^n) = (1-2Fo)T_i^n + Fo(T_{i+1}^n + T_{i-1}^n)\n$$\nThe Dirichlet boundary conditions are applied directly at the boundary nodes: $T_0^n = T_L$ and $T_{N_c}^n = T_R$ for all time steps $n$.\n\n**4. Stability Analysis**\n\nThe stability of the explicit scheme is analyzed using the von Neumann method. We consider the propagation of a single Fourier mode of error, $E_i^n = \\xi^n e^{j k_m i h}$, where $E_i^n$ is the error at node $i$ and time $n$, $\\xi$ is the amplification factor per time step, $k_m$ is the wave number, and $j=\\sqrt{-1}$. The scheme is stable if the magnitude of the amplification factor $|\\xi| \\le 1$ for all possible wave numbers. The error must satisfy the same homogeneous finite difference equation.\nSubstituting the error term into the update equation:\n$$\n\\xi^{n+1} e^{j k_m i h} = \\xi^n e^{j k_m i h} + Fo(\\xi^n e^{j k_m (i+1)h} - 2\\xi^n e^{j k_m i h} + \\xi^n e^{j k_m (i-1)h})\n$$\nDividing by $\\xi^n e^{j k_m i h}$:\n$$\n\\xi = 1 + Fo(e^{j k_m h} - 2 + e^{-j k_m h})\n$$\nUsing the identity $e^{j\\theta} + e^{-j\\theta} = 2\\cos(\\theta)$, this becomes:\n$$\n\\xi = 1 + Fo(2\\cos(k_m h) - 2) = 1 - 2Fo(1 - \\cos(k_m h))\n$$\nUsing the half-angle identity $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$:\n$$\n\\xi = 1 - 4Fo \\sin^2(k_m h / 2)\n$$\nFor stability, we require $|\\xi| \\le 1$, which translates to $-1 \\le \\xi \\le 1$.\nThe condition $\\xi \\le 1$ is always met because $Fo > 0$ and $\\sin^2(k_m h/2) \\ge 0$.\nThe critical condition is $\\xi \\ge -1$:\n$$\n1 - 4Fo \\sin^2(k_m h / 2) \\ge -1\n$$\n$$\n2 \\ge 4Fo \\sin^2(k_m h / 2)\n$$\n$$\nFo \\le \\frac{1}{2 \\sin^2(k_m h / 2)}\n$$\nThis condition must hold for all wave numbers $k_m$. The most restrictive case occurs when the denominator is minimal, i.e., when $\\sin^2(k_m h/2)$ is maximal. The maximum value of $\\sin^2(\\theta)$ is $1$. This corresponds to the highest frequency (shortest wavelength) error mode that can be represented on the grid, where $k_m h = \\pi$.\nThus, the necessary and sufficient condition for stability is:\n$$\nFo \\le \\frac{1}{2} \\quad \\text{or} \\quad \\frac{\\alpha \\Delta t}{h^2} \\le \\frac{1}{2}\n$$\n\n**5. Steady-State Solution**\n\nIn the steady state, the temperature field no longer changes with time, so $\\frac{\\partial T}{\\partial t} = 0$. The governing PDE simplifies to an ordinary differential equation (ODE):\n$$\n\\alpha \\frac{d^2 T}{dx^2} = 0 \\quad \\implies \\quad \\frac{d^2 T}{dx^2} = 0\n$$\nIntegrating this ODE twice with respect to $x$ yields a linear temperature profile:\n$$\n\\frac{dT}{dx} = C_1\n$$\n$$\nT(x) = C_1 x + C_2\n$$\nThe integration constants $C_1$ and $C_2$ are determined by applying the boundary conditions $T(0)=T_L$ and $T(L)=T_R$:\n- At $x=0$: $T(0) = C_1(0) + C_2 = T_L \\implies C_2 = T_L$.\n- At $x=L$: $T(L) = C_1 L + C_2 = T_R \\implies C_1 L + T_L = T_R \\implies C_1 = \\frac{T_R - T_L}{L}$.\n\nThe steady-state temperature distribution is therefore:\n$$\nT(x) = \\left(\\frac{T_R - T_L}{L}\\right)x + T_L\n$$\nThe heat flux is found using Fourier's law with this temperature profile:\n$$\nq = -k \\frac{dT}{dx} = -k C_1 = -k \\left(\\frac{T_R - T_L}{L}\\right) = k \\frac{T_L - T_R}{L}\n$$\nSince the temperature gradient $\\frac{dT}{dx}$ is constant, the heat flux $q$ is also constant throughout the slab in the steady state with no internal heat generation. The flux at $x=0$ is the same as the flux at any other position $x \\in [0,L]$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for a suite of test cases.\n    For each case, it computes:\n    1. A boolean indicating if the FDM scheme is stable.\n    2. The steady-state heat flux at x=0.\n    \"\"\"\n    test_cases = [\n        # Test case 1: L, Nc, alpha, dt, k, T_L, T_R\n        (0.1, 20, 1.2e-4, 0.052083333333, 400, 300, 350),\n        # Test case 2\n        (0.2, 40, 1.0e-5, 1.25, 50, 300, 300),\n        # Test case 3\n        (0.1, 20, 1.2e-4, 0.12, 400, 350, 300),\n        # Test case 4\n        (0.05, 100, 8.0e-5, 1.0e-4, 150, 310, 330),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        L, Nc, alpha, dt, k, T_L, T_R = case\n        \n        # Calculate grid spacing h\n        h = L / Nc\n        \n        # --- Stability Check ---\n        # The stability condition for the explicit forward-Euler central-difference\n        # scheme for the 1D heat equation is alpha * dt / h^2 <= 0.5.\n        # This is also known as the Fourier number, Fo.\n        fourier_number = alpha * dt / (h**2)\n        is_stable = fourier_number <= 0.5\n        \n        # --- Steady-State Heat Flux Calculation ---\n        # In steady state with no internal generation, the temperature profile is linear.\n        # T(x) = (T_R - T_L)/L * x + T_L\n        # The heat flux q is constant and given by Fourier's law:\n        # q = -k * dT/dx\n        # dT/dx = (T_R - T_L) / L\n        # q = -k * (T_R - T_L) / L = k * (T_L - T_R) / L\n        # The flux is constant for all x in [0, L].\n        if L > 0:\n            flux = k * (T_L - T_R) / L\n        else: # Avoid division by zero, though L > 0 in all test cases.\n            flux = float('nan') \n            \n        results.append([is_stable, flux])\n\n    # Format the final output string exactly as required,\n    # e.g., [[True,-123.456],[False,0.0]] a list of lists.\n    # The str() of a list adds spaces, so we remove them.\n    result_strings = [str(r).replace(\" \", \"\") for r in results]\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\n# Execute the solution function.\nsolve()\n```"
        },
        {
            "introduction": "Next, we explore Neumann boundary conditions, which specify the heat flux entering or leaving a domain. This practice introduces a robust, physically-motivated approach based on the direct application of energy conservation to boundary control volumes. You will implement an unconditionally stable implicit time-stepping scheme and verify your code's correctness by checking if it perfectly conserves energy, a powerful and fundamental validation technique. ",
            "id": "3938343",
            "problem": "Consider one-dimensional transient heat conduction in a homogeneous rod of length $L$ (in $\\mathrm{m}$) and constant cross-sectional area $A$ (in $\\mathrm{m^2}$). Let $x \\in [0,L]$ denote position along the rod and $t \\ge 0$ denote time (in $\\mathrm{s}$). The temperature field $T(x,t)$ (in $\\mathrm{K}$) evolves according to the conservation of energy and Fourier’s law, which together yield the governing partial differential equation (PDE): $$\\rho c_p \\frac{\\partial T}{\\partial t} = \\frac{\\partial}{\\partial x}\\left(k \\frac{\\partial T}{\\partial x}\\right),$$ where $\\rho$ (in $\\mathrm{kg/m^3}$) is the density, $c_p$ (in $\\mathrm{J/(kg\\cdot K)}$) is the specific heat capacity at constant pressure, and $k$ (in $\\mathrm{W/(m\\cdot K)}$) is the thermal conductivity. Assume $k$, $\\rho$, and $c_p$ are constant in space and time, so the thermal diffusivity $\\alpha = k/(\\rho c_p)$ (in $\\mathrm{m^2/s}$) is constant, and the PDE reduces to $$\\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2}.$$\n\nAt the boundary $x=0$, a prescribed heat flux $q_0(t)$ (in $\\mathrm{W/m^2}$) enters the rod; at the boundary $x=L$, the rod is insulated so the heat flux $q_L(t)$ equals $0$. The Neumann boundary conditions are therefore $$-k\\left.\\frac{\\partial T}{\\partial x}\\right|_{x=0} = q_0(t), \\qquad -k\\left.\\frac{\\partial T}{\\partial x}\\right|_{x=L} = q_L(t) = 0.$$ The initial condition is spatially uniform, $$T(x,0) = T_0,$$ with $T_0$ (in $\\mathrm{K}$) a given constant. Symmetry boundary conditions in one dimension correspond to zero normal temperature gradient, which is the same mathematical form as an insulating Neumann boundary; hence, the $x=L$ boundary here is also a symmetry plane for the temperature field.\n\nTask. Starting strictly from conservation of energy and Fourier’s law, and without invoking any pre-derived discretization shortcuts, derive a finite difference method (FDM) in space and an implicit first-order scheme in time for the above PDE, making explicit how to impose the Neumann boundary conditions at $x=0$ and $x=L$ via flux-based relations. Implement the resulting scheme in a single program that, for each test case below, advances the temperature to the specified final time and evaluates energy conservation by comparing the change in internal energy of the rod to the net energy input through the boundaries.\n\nDefinitions to use in your implementation and evaluation:\n- The discrete internal energy of the rod at time $t$ is $$U(t) = \\rho c_p A \\int_0^L T(x,t)\\,dx,$$ to be approximated numerically on a uniform grid in $x$ with spacing $\\Delta x$ (in $\\mathrm{m}$) using a composite trapezoidal rule.\n- The net energy input through the boundaries over $[0,t]$ is $$E_{\\text{in}}(t) = A \\int_0^t \\big(q_0(\\tau) - q_L(\\tau)\\big)\\,d\\tau,$$ to be approximated numerically using the same time step $\\Delta t$ (in $\\mathrm{s}$) as your implicit scheme.\n- The energy conservation residual to report for each test case is $$R(t_{\\text{final}}) = U(t_{\\text{final}}) - U(0) - E_{\\text{in}}(t_{\\text{final}}),$$ which must be expressed in $\\mathrm{J}$.\n\nYour program must implement the implicit time integrator with flux-based Neumann boundary treatment derived from first principles, and for each test case below, compute the scalar residual $R(t_{\\text{final}})$ in $\\mathrm{J}$.\n\nGrid and discretization requirements:\n- Use a uniform spatial grid with $N$ nodes (including $x=0$ and $x=L$) and spacing $\\Delta x = L/(N-1)$ (in $\\mathrm{m}$).\n- Use a constant time step $\\Delta t$ (in $\\mathrm{s}$) for $n_{\\text{steps}}$ steps so that $n_{\\text{steps}}\\Delta t = t_{\\text{final}}$.\n- Impose the Neumann boundary conditions through flux-based derivative relations, not by prescribing ghost temperatures arbitrarily.\n\nTest suite. Implement the following four test cases, each physically self-consistent and designed to exercise the boundary implementation and energy accounting:\n1. Happy path with constant flux:\n   - $L = 0.05$ $\\mathrm{m}$, $A = 5.0\\times 10^{-4}$ $\\mathrm{m^2}$, $N = 101$, $\\Delta t = 0.01$ $\\mathrm{s}$, $t_{\\text{final}} = 0.5$ $\\mathrm{s}$.\n   - Material: $k = 200$ $\\mathrm{W/(m\\cdot K)}$, $\\rho = 8900$ $\\mathrm{kg/m^3}$, $c_p = 385$ $\\mathrm{J/(kg\\cdot K)}$.\n   - Initial temperature: $T_0 = 300$ $\\mathrm{K}$.\n   - Boundary fluxes: $q_0(t) = 2.0\\times 10^{4}$ $\\mathrm{W/m^2}$, $q_L(t) = 0$ $\\mathrm{W/m^2}$.\n2. Oscillatory flux with zero net energy input over one period:\n   - $L = 0.05$ $\\mathrm{m}$, $A = 5.0\\times 10^{-4}$ $\\mathrm{m^2}$, $N = 101$, $\\Delta t = 0.002$ $\\mathrm{s}$, $t_{\\text{final}} = 0.2$ $\\mathrm{s}$.\n   - Material: $k = 200$ $\\mathrm{W/(m\\cdot K)}$, $\\rho = 8900$ $\\mathrm{kg/m^3}$, $c_p = 385$ $\\mathrm{J/(kg\\cdot K)}$.\n   - Initial temperature: $T_0 = 300$ $\\mathrm{K}$.\n   - Boundary fluxes: $q_0(t) = 1.0\\times 10^{5}\\sin(2\\pi t / 0.2)$ $\\mathrm{W/m^2}$, $q_L(t) = 0$ $\\mathrm{W/m^2}$.\n3. Edge case with zero flux:\n   - $L = 0.05$ $\\mathrm{m}$, $A = 5.0\\times 10^{-4}$ $\\mathrm{m^2}$, $N = 101$, $\\Delta t = 0.01$ $\\mathrm{s}$, $t_{\\text{final}} = 0.5$ $\\mathrm{s}$.\n   - Material: $k = 200$ $\\mathrm{W/(m\\cdot K)}$, $\\rho = 8900$ $\\mathrm{kg/m^3}$, $c_p = 385$ $\\mathrm{J/(kg\\cdot K)}$.\n   - Initial temperature: $T_0 = 300$ $\\mathrm{K}$.\n   - Boundary fluxes: $q_0(t) = 0$ $\\mathrm{W/m^2}$, $q_L(t) = 0$ $\\mathrm{W/m^2}$.\n4. Strong flux with coarse grid and larger time step:\n   - $L = 0.02$ $\\mathrm{m}$, $A = 1.0\\times 10^{-4}$ $\\mathrm{m^2}$, $N = 11$, $\\Delta t = 0.1$ $\\mathrm{s}$, $t_{\\text{final}} = 0.1$ $\\mathrm{s}$.\n   - Material: $k = 200$ $\\mathrm{W/(m\\cdot K)}$, $\\rho = 8900$ $\\mathrm{kg/m^3}$, $c_p = 385$ $\\mathrm{J/(kg\\cdot K)}$.\n   - Initial temperature: $T_0 = 300$ $\\mathrm{K}$.\n   - Boundary fluxes: $q_0(t) = 1.0\\times 10^{6}$ $\\mathrm{W/m^2}$, $q_L(t) = 0$ $\\mathrm{W/m^2}$.\n\nOutput specification. Your program should produce a single line of output containing the energy conservation residuals as a comma-separated list enclosed in square brackets, in the same order as the test cases, each value expressed in $\\mathrm{J}$ as a decimal float. For example, the output must be of the form $$[\\text{residual}_1,\\text{residual}_2,\\text{residual}_3,\\text{residual}_4],$$ where each $\\text{residual}_i$ is $R(t_{\\text{final}})$ for test case $i$ in $\\mathrm{J}$.",
            "solution": "The problem requires the derivation and implementation of a numerical scheme to solve the one-dimensional transient heat equation, with a specific focus on deriving the finite difference equations from first principles and correctly implementing Neumann boundary conditions. The validity of the implementation is to be checked by evaluating energy conservation.\n\nThe governing partial differential equation (PDE) for the temperature field $T(x,t)$ in a homogeneous rod is:\n$$ \\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2} $$\nwhere $\\alpha = k/(\\rho c_p)$ is the constant thermal diffusivity. This equation is defined on the spatial domain $x \\in [0, L]$ for time $t \\ge 0$. The initial condition is a uniform temperature $T(x,0) = T_0$. The boundary conditions are of the Neumann type, specifying heat fluxes:\n$$ -k\\left.\\frac{\\partial T}{\\partial x}\\right|_{x=0} = q_0(t) \\quad \\text{and} \\quad -k\\left.\\frac{\\partial T}{\\partial x}\\right|_{x=L} = q_L(t) = 0 $$\n\nThe derivation will be based on the finite volume method (FVM), which starts from the integral form of the conservation of energy. This approach ensures that the resulting numerical scheme is inherently conservative, which is a central theme of this problem.\n\nFirst, we discretize the spatial domain $[0,L]$ into $N$ nodes, indexed by $i = 0, 1, \\dots, N-1$. The nodes are located at positions $x_i = i \\Delta x$, where the uniform grid spacing is $\\Delta x = L/(N-1)$. We define control volumes (CVs) around each node. For interior nodes ($1 \\le i \\le N-2$), the CV extends from $x_i - \\Delta x/2$ to $x_i + \\Delta x/2$, having a length of $\\Delta x$. For the boundary nodes, the CVs have length $\\Delta x/2$: CV$_0$ is $[0, \\Delta x/2]$ and CV$_{N-1}$ is $[L-\\Delta x/2, L]$.\n\nThe integral form of the energy conservation for any control volume $V$ with boundary $\\partial V$ states that the rate of change of internal energy equals the net rate of heat flow into the volume:\n$$ \\frac{d}{dt} \\int_V \\rho c_p T \\,dV = -\\int_{\\partial V} \\mathbf{q} \\cdot \\mathbf{n} \\,dS $$\nIn one dimension, with a constant cross-sectional area $A$, this simplifies to:\n$$ \\frac{d}{dt} \\int_{x_a}^{x_b} \\rho c_p A T(x,t) \\,dx = A [q(x_a,t) - q(x_b,t)] $$\nwhere $q = -k \\frac{\\partial T}{\\partial x}$ is the heat flux according to Fourier's law.\n\n**1. Discretization for an Interior Node ($1 \\le i \\le N-2$)**\nThe control volume is CV$_i = [x_i - \\Delta x/2, x_i + \\Delta x/2]$. Applying the energy balance:\n$$ \\rho c_p A \\frac{d}{dt} \\int_{x_i-\\Delta x/2}^{x_i+\\Delta x/2} T(x,t) \\,dx = A [q(x_i-\\Delta x/2, t) - q(x_i+\\Delta x/2, t)] $$\nWe approximate the integral assuming the temperature $T_i(t)$ at the node is representative of the average temperature in the CV, and discretize the fluxes using central differences between adjacent nodes:\n$$ \\int_{x_i-\\Delta x/2}^{x_i+\\Delta x/2} T(x,t) \\,dx \\approx T_i(t) \\Delta x $$\n$$ q(x_i-\\Delta x/2, t) \\approx -k \\frac{T_i(t) - T_{i-1}(t)}{\\Delta x} $$\n$$ q(x_i+\\Delta x/2, t) \\approx -k \\frac{T_{i+1}(t) - T_i(t)}{\\Delta x} $$\nSubstituting these approximations into the energy balance and simplifying:\n$$ \\rho c_p A \\Delta x \\frac{dT_i}{dt} = A \\left[ -k \\frac{T_i - T_{i-1}}{\\Delta x} - \\left(-k \\frac{T_{i+1} - T_i}{\\Delta x}\\right) \\right] $$\n$$ \\frac{dT_i}{dt} = \\frac{k}{\\rho c_p} \\frac{T_{i+1} - 2T_i + T_{i-1}}{(\\Delta x)^2} = \\alpha \\frac{T_{i+1} - 2T_i + T_{i-1}}{(\\Delta x)^2} $$\nThis is the semi-discrete equation for an interior node.\n\n**2. Discretization for the Boundary Node at $x=0$ ($i=0$)**\nThe control volume is CV$_0 = [0, \\Delta x/2]$, with length $\\Delta x/2$. The heat flux at the left face is the prescribed boundary flux, $q(0,t) = q_0(t)$.\n$$ \\rho c_p A \\frac{d}{dt} \\int_{0}^{\\Delta x/2} T(x,t) \\,dx = A [q(0, t) - q(\\Delta x/2, t)] $$\nUsing similar approximations:\n$$ \\int_{0}^{\\Delta x/2} T(x,t) \\,dx \\approx T_0(t) \\frac{\\Delta x}{2} $$\n$$ q(\\Delta x/2, t) \\approx -k \\frac{T_1(t) - T_0(t)}{\\Delta x} $$\nThe energy balance becomes:\n$$ \\rho c_p A \\frac{\\Delta x}{2} \\frac{dT_0}{dt} = A \\left[ q_0(t) - \\left(-k \\frac{T_1 - T_0}{\\Delta x}\\right) \\right] $$\n$$ \\frac{dT_0}{dt} = \\frac{2}{\\rho c_p \\Delta x} q_0(t) + \\frac{2k}{\\rho c_p (\\Delta x)^2} (T_1 - T_0) = \\frac{2\\alpha}{k \\Delta x} q_0(t) + \\frac{2\\alpha}{(\\Delta x)^2} (T_1 - T_0) $$\n\n**3. Discretization for the Boundary Node at $x=L$ ($i=N-1$)**\nThe control volume is CV$_{N-1} = [L - \\Delta x/2, L]$, with length $\\Delta x/2$. The boundary is insulated, so $q(L,t) = q_L(t) = 0$.\n$$ \\rho c_p A \\frac{d}{dt} \\int_{L-\\Delta x/2}^{L} T(x,t) \\,dx = A [q(L-\\Delta x/2, t) - q(L, t)] $$\nThe approximations are:\n$$ \\int_{L-\\Delta x/2}^{L} T(x,t) \\,dx \\approx T_{N-1}(t) \\frac{\\Delta x}{2} $$\n$$ q(L-\\Delta x/2, t) \\approx -k \\frac{T_{N-1}(t) - T_{N-2}(t)}{\\Delta x} $$\nThe energy balance becomes:\n$$ \\rho c_p A \\frac{\\Delta x}{2} \\frac{dT_{N-1}}{dt} = A \\left[ -k \\frac{T_{N-1} - T_{N-2}}{\\Delta x} - 0 \\right] $$\n$$ \\frac{dT_{N-1}}{dt} = \\frac{2k}{\\rho c_p (\\Delta x)^2} (T_{N-2} - T_{N-1}) = \\frac{2\\alpha}{(\\Delta x)^2} (T_{N-2} - T_{N-1}) $$\n\n**4. Implicit Time Integration (Backward Euler)**\nWe discretize in time using a constant step $\\Delta t$. Let $T_i^n$ be the temperature at node $i$ at time $t_n = n \\Delta t$. The first-order implicit (Backward Euler) scheme approximates the time derivative as $\\frac{dT_i}{dt} \\approx \\frac{T_i^{n+1} - T_i^n}{\\Delta t}$ and evaluates all spatial terms at the new time level $n+1$. Let $\\lambda = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$ be the dimensionless mesh Fourier number.\n\nFor interior nodes ($1 \\le i \\le N-2$):\n$$ \\frac{T_i^{n+1} - T_i^n}{\\Delta t} = \\alpha \\frac{T_{i+1}^{n+1} - 2T_i^{n+1} + T_{i-1}^{n+1}}{(\\Delta x)^2} $$\n$$ -\\lambda T_{i-1}^{n+1} + (1+2\\lambda)T_i^{n+1} - \\lambda T_{i+1}^{n+1} = T_i^n $$\n\nFor the boundary node $i=0$:\n$$ \\frac{T_0^{n+1} - T_0^n}{\\Delta t} = \\frac{2\\alpha}{k \\Delta x} q_0(t^{n+1}) + \\frac{2\\alpha}{(\\Delta x)^2} (T_1^{n+1} - T_0^{n+1}) $$\n$$ (1+2\\lambda)T_0^{n+1} - 2\\lambda T_1^{n+1} = T_0^n + \\frac{2\\alpha \\Delta t}{k \\Delta x} q_0^{n+1} = T_0^n + \\frac{2\\lambda \\Delta x}{k} q_0^{n+1} $$\n\nFor the boundary node $i=N-1$:\n$$ \\frac{T_{N-1}^{n+1} - T_{N-1}^n}{\\Delta t} = \\frac{2\\alpha}{(\\Delta x)^2} (T_{N-2}^{n+1} - T_{N-1}^{n+1}) $$\n$$ -2\\lambda T_{N-2}^{n+1} + (1+2\\lambda)T_{N-1}^{n+1} = T_{N-1}^n $$\n\n**5. Linear System Formulation**\nThese equations form a system of $N$ linear equations for the $N$ unknown temperatures $\\mathbf{T}^{n+1} = [T_0^{n+1}, \\dots, T_{N-1}^{n+1}]^T$. The system can be written in matrix form as $\\mathbf{A} \\mathbf{T}^{n+1} = \\mathbf{b}^n$.\n\nThe matrix $\\mathbf{A}$ is an $N \\times N$ tridiagonal matrix, constant in time:\n$$ \\mathbf{A} = \\begin{pmatrix}\n1+2\\lambda & -2\\lambda & & & \\\\\n-\\lambda & 1+2\\lambda & -\\lambda & & \\\\\n& \\ddots & \\ddots & \\ddots & \\\\\n& & -\\lambda & 1+2\\lambda & -\\lambda \\\\\n& & & -2\\lambda & 1+2\\lambda\n\\end{pmatrix} $$\n\nThe right-hand side vector $\\mathbf{b}^n$ is:\n$$ \\mathbf{b}^n = \\begin{pmatrix}\nT_0^n + \\frac{2\\lambda \\Delta x}{k} q_0(t^{n+1}) \\\\\nT_1^n \\\\\n\\vdots \\\\\nT_{N-2}^n \\\\\nT_{N-1}^n\n\\end{pmatrix} $$\n\n**6. Algorithm and Energy Conservation**\nThe algorithm proceeds as follows:\n1.  Initialize the temperature field: $T_i^0 = T_0$ for all $i=0, \\dots, N-1$.\n2.  Calculate the initial internal energy $U(0)$ using the composite trapezoidal rule:\n    $U(0) = \\rho c_p A \\int_0^L T(x,0) dx \\approx \\rho c_p A \\Delta x \\left( \\frac{T_0^0}{2} + \\sum_{i=1}^{N-2} T_i^0 + \\frac{T_{N-1}^0}{2} \\right)$.\n3.  Construct the matrix $\\mathbf{A}$.\n4.  Loop for $n$ from $0$ to $n_{\\text{steps}}-1$:\n    a. Construct the vector $\\mathbf{b}^n$ using $\\mathbf{T}^n$ and the boundary flux $q_0(t^{n+1})$.\n    b. Solve the linear system $\\mathbf{A} \\mathbf{T}^{n+1} = \\mathbf{b}^n$ to find the temperatures at the next time step.\n    c. Update the total energy input $E_{\\text{in}}$ by adding the contribution from the current step: $A (q_0(t^{n+1}) - q_L(t^{n+1})) \\Delta t$. We use a right-sided sum for the time integral, consistent with the Backward Euler scheme.\n5.  After the final time step, calculate the final internal energy $U(t_{\\text{final}})$ using the temperature field $\\mathbf{T}^{n_{\\text{steps}}}$ and the trapezoidal rule.\n6.  Compute the energy conservation residual: $R(t_{\\text{final}}) = U(t_{\\text{final}}) - U(0) - E_{\\text{in}}(t_{\\text{final}})$.\n\nDue to the finite volume formulation, which discretizes the integral conservation law directly, the numerical scheme is inherently energy-conserving. This means the calculated residual $R(t_{\\text{final}})$ should be close to zero, limited only by floating-point precision. This provides a strong verification of the correctness of the derivation and implementation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the 1D transient heat conduction problem.\n    \"\"\"\n\n    def run_simulation(params):\n        \"\"\"\n        Executes a single simulation case for the heat conduction problem.\n\n        This function sets up and solves the 1D transient heat equation using a\n        finite volume method in space and an implicit first-order (Backward Euler)\n        scheme in time. It implements Neumann boundary conditions via a flux-based\n        formulation derived from first principles. The primary output is the\n        energy conservation residual, which verifies the implementation's correctness.\n\n        Args:\n            params (dict): A dictionary containing all physical and numerical\n                           parameters for the simulation case.\n\n        Returns:\n            float: The energy conservation residual R(t_final) in Joules.\n        \"\"\"\n        # Extract physical and numerical parameters from the dictionary\n        L = params['L']\n        A = params['A']\n        N = params['N']\n        dt = params['dt']\n        t_final = params['t_final']\n        k = params['k']\n        rho = params['rho']\n        cp = params['cp']\n        T0 = params['T0']\n        q0_func = params['q0_func']\n\n        # Calculate derived discretization parameters\n        dx = L / (N - 1)\n        n_steps = int(round(t_final / dt))\n        alpha = k / (rho * cp)\n        lam = alpha * dt / (dx**2)\n\n        # Initialize temperature field\n        T = np.full(N, T0, dtype=float)\n        x_nodes = np.linspace(0, L, N)\n\n        # 1. Calculate initial internal energy U(0) using the composite trapezoidal rule.\n        # np.trapz implements this rule: integral(y*dx) ~ dx * (y_0/2 + y_1 + ... + y_{N-1}/2)\n        U0 = rho * cp * A * np.trapz(T, x=x_nodes)\n        \n        # Initialize total net energy input\n        E_in_total = 0.0\n\n        # 2. Assemble the time-independent linear system matrix A\n        A_matrix = np.zeros((N, N))\n\n        # Equation for node i=0 (left boundary)\n        A_matrix[0, 0] = 1.0 + 2.0 * lam\n        A_matrix[0, 1] = -2.0 * lam\n\n        # Equations for interior nodes i=1 to N-2\n        for i in range(1, N - 1):\n            A_matrix[i, i - 1] = -lam\n            A_matrix[i, i]     = 1.0 + 2.0 * lam\n            A_matrix[i, i + 1] = -lam\n\n        # Equation for node i=N-1 (right boundary)\n        A_matrix[N - 1, N - 2] = -2.0 * lam\n        A_matrix[N - 1, N - 1] = 1.0 + 2.0 * lam\n\n        # 3. Time-stepping loop\n        for n in range(n_steps):\n            t_new = (n + 1) * dt\n\n            # Assemble the right-hand side vector b\n            b = T.copy()  # Start with temperatures from the previous step\n            q0_new = q0_func(t_new)\n            \n            # Update the first element of b with the boundary flux term. q_L is always 0.\n            flux_term = (2.0 * lam * dx / k) * q0_new\n            b[0] += flux_term\n\n            # Solve the linear system A * T_new = b\n            T = np.linalg.solve(A_matrix, b)\n\n            # Update total energy input using a right-hand sum, consistent with Backward Euler\n            E_in_total += A * q0_new * dt\n\n        # 4. Calculate final internal energy U(t_final)\n        Uf = rho * cp * A * np.trapz(T, x=x_nodes)\n\n        # 5. Calculate the energy conservation residual\n        residual = Uf - U0 - E_in_total\n        return residual\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            'L': 0.05, 'A': 5.0e-4, 'N': 101, 'dt': 0.01, 't_final': 0.5,\n            'k': 200.0, 'rho': 8900.0, 'cp': 385.0, 'T0': 300.0,\n            'q0_func': lambda t: 2.0e4\n        },\n        {\n            'L': 0.05, 'A': 5.0e-4, 'N': 101, 'dt': 0.002, 't_final': 0.2,\n            'k': 200.0, 'rho': 8900.0, 'cp': 385.0, 'T0': 300.0,\n            'q0_func': lambda t: 1.0e5 * np.sin(2.0 * np.pi * t / 0.2)\n        },\n        {\n            'L': 0.05, 'A': 5.0e-4, 'N': 101, 'dt': 0.01, 't_final': 0.5,\n            'k': 200.0, 'rho': 8900.0, 'cp': 385.0, 'T0': 300.0,\n            'q0_func': lambda t: 0.0\n        },\n        {\n            'L': 0.02, 'A': 1.0e-4, 'N': 11, 'dt': 0.1, 't_final': 0.1,\n            'k': 200.0, 'rho': 8900.0, 'cp': 385.0, 'T0': 300.0,\n            'q0_func': lambda t: 1.0e6\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Our final practice introduces a cornerstone of modern scientific computing: the Method of Manufactured Solutions (MMS). This powerful technique allows for rigorous verification of a numerical code by forcing the governing equations to have a chosen analytical solution. In this exercise, you will apply MMS to systematically test your implementation of a full suite of boundary conditions—including Dirichlet, Neumann, Robin, and periodic—and quantify your solver's accuracy, a crucial step in building trust in any simulation tool. ",
            "id": "3938328",
            "problem": "Consider one-dimensional, steady heat conduction in a homogeneous medium with constant thermal conductivity, nondimensionalized such that the thermal conductivity is unity. Starting from conservation of energy and Fourier's law of heat conduction, the local balance reduces to the ordinary differential equation $$ -\\frac{d^2 T}{dx^2} = s(x), $$ where $x \\in [0,1]$, $T(x)$ is the nondimensional temperature, and $s(x)$ is a nondimensional source term. Implement a second-order accurate, uniform-grid, finite-difference solver for this equation under five boundary condition types: Dirichlet, Neumann, Robin, periodic, and symmetry. Use the method of manufactured solutions to verify accuracy, and perform sensitivity analysis for the Robin boundary condition. All quantities are nondimensional, so no physical units are required.\n\nThe boundary condition types are defined as follows:\n- Dirichlet: $T(0) = T_0$, $T(1) = T_1$.\n- Neumann: $\\frac{dT}{dx}(0) = g_0$, $\\frac{dT}{dx}(1) = g_1$, augmented by a zero-mean constraint $\\int_0^1 T(x)\\,dx = 0$ to remove the constant nullspace and ensure uniqueness.\n- Robin (convective): $-\\,\\frac{dT}{dx}(0) = h_c\\,(T(0) - T_\\infty)$, with $h_c>0$ and a specified ambient $T_\\infty$, and a Dirichlet boundary $T(1)$ at the right end.\n- Periodic: $T(0) = T(1)$ and $\\frac{dT}{dx}(0) = \\frac{dT}{dx}(1)$, augmented by the zero-mean constraint $\\int_0^1 T(x)\\,dx = 0$ to remove the constant nullspace and ensure uniqueness.\n- Symmetry: $\\frac{dT}{dx}(0) = 0$ and $T(1)$ specified (Dirichlet).\n\nDiscretize the operator $-\\frac{d^2}{dx^2}$ on a uniform grid such that for interior points $x_i$ with spacing $h$, the second derivative is approximated by the centered difference and the discrete equation is $$-\\,\\frac{T_{i-1} - 2 T_i + T_{i+1}}{h^2} = s(x_i),$$ which can be rearranged to $$2 T_i - T_{i-1} - T_{i+1} = h^2\\, s(x_i).$$ Impose boundary conditions with second-order accuracy:\n- For Dirichlet boundaries, enforce $T_0 = T_0$ and $T_{N-1} = T_1$ directly.\n- For Neumann boundaries, use ghost elimination from the centered derivative $\\frac{T_1 - T_{-1}}{2h} = g_0$ and $\\frac{T_{N} - T_{N-2}}{2h} = g_1$ to eliminate ghost values and form the boundary rows $$2 T_0 - 2 T_1 = h^2 s(x_0) - 2 h g_0, \\quad 2 T_{N-1} - 2 T_{N-2} = h^2 s(x_{N-1}) + 2 h g_1.$$ Impose the zero-mean constraint with a Lagrange multiplier via the trapezoidal-rule weights to discretize $\\int_0^1 T(x)\\,dx = 0$.\n- For the Robin boundary at $x=0$, use the second-order one-sided derivative approximation $$\\frac{dT}{dx}(0) \\approx \\frac{-3\\,T_0 + 4\\,T_1 - T_2}{2h},$$ and enforce the boundary condition to form the equation: $$\\left(\\frac{3}{2h} - h_c\\right) T_0 - \\frac{2}{h} T_1 + \\frac{1}{2h} T_2 = -h_c T_\\infty.$$ At $x=1$, enforce Dirichlet as above.\n- For periodic boundaries on a uniform grid with $N$ points and spacing $h = \\frac{1}{N}$ over $[0,1)$, use wrap-around indices to discretize $$2 T_i - T_{i-1\\,(\\mathrm{mod}\\,N)} - T_{i+1\\,(\\mathrm{mod}\\,N)} = h^2\\, s(x_i),$$ and add the zero-mean constraint via equal weights to discretize $\\int_0^1 T(x)\\,dx = 0$.\n\nManufactured solutions and sources:\n- Dirichlet test: $T(x) = \\sin(\\pi x) + x$, so $T(0) = 0$, $T(1) = 1$, and $s(x) = \\pi^2 \\sin(\\pi x)$ since $-\\,\\frac{d^2 T}{dx^2} = \\pi^2 \\sin(\\pi x)$.\n- Neumann test: $T(x) = \\cos(\\pi x)$, so $\\frac{dT}{dx}(0) = 0$, $\\frac{dT}{dx}(1) = 0$, and $s(x) = \\pi^2 \\cos(\\pi x)$.\n- Robin test: $T(x) = e^{x}$, so $s(x) = -\\,e^{x}$, and enforce $-\\,\\frac{dT}{dx}(0) = h_c\\,(T(0) - T_\\infty)$ with $h_c = 1$ and $T_\\infty = 2$; enforce $T(1) = e$ at the right boundary. Sensitivity is computed by perturbing $h_c$ by a small $\\Delta h_c$ and measuring the solution change.\n- Periodic test: $T(x) = \\sin(2\\pi x)$, so $s(x) = 4\\pi^2 \\sin(2\\pi x)$ with zero mean; enforce periodicity and zero mean.\n- Symmetry test: $T(x) = \\frac{1 - \\cos(\\pi x)}{2}$, so $\\frac{dT}{dx}(0) = 0$, $T(1) = 1$, and $s(x) = -\\,\\frac{\\pi^2}{2} \\cos(\\pi x)$.\n\nError and verification metrics:\n- Use the trapezoidal rule to approximate the integral norm on $[0,1]$ for nonperiodic grids: weights $w_0 = w_{N-1} = \\frac{1}{2}$ and $w_i = 1$ otherwise, and grid spacing $h = \\frac{1}{N-1}$. The discrete $L^2$ error is $$E_2 = \\left( h \\sum_{i=0}^{N-1} w_i \\left( T_i^{\\mathrm{num}} - T(x_i) \\right)^2 \\right)^{1/2}.$$ The discrete $L^\\infty$ error is $$E_\\infty = \\max_i \\left| T_i^{\\mathrm{num}} - T(x_i) \\right|.$$\n- For periodic grids, use equal weights and $h = \\frac{1}{N}$ to approximate integrals and enforce the zero-mean constraint.\n- Empirical order of accuracy for the Dirichlet test is computed from two grid sizes $N_1$ and $N_2$ as $$p = \\frac{\\ln\\left(\\frac{E_2(N_1)}{E_2(N_2)}\\right)}{\\ln\\left(\\frac{h_1}{h_2}\\right)},$$ where $h_j = \\frac{1}{N_j - 1}$.\n- Sensitivity for Robin is computed as $$S = \\frac{\\left\\| T^{(h_c+\\Delta h_c)} - T^{(h_c)} \\right\\|_{2}}{\\Delta h_c},$$ using the discrete $L^2$ norm with trapezoidal weights.\n- Symmetry boundary check computes the numerical boundary derivative via the second-order one-sided formula $$\\left.\\frac{dT}{dx}\\right|_{x=0} \\approx \\frac{-3\\,T_0 + 4\\,T_1 - T_2}{2h},$$ and returns a boolean indicating whether the magnitude is less than a tolerance $\\tau$.\n\nTest suite specification:\n- Dirichlet verification: $N_1 = 50$, $N_2 = 100$; compute and return $p$ as a float.\n- Neumann error: $N = 64$ with zero-mean constraint; compute and return $E_2$ as a float.\n- Robin sensitivity: $N = 101$, base $h_c = 1$, ambient $T_\\infty = 2$, perturbation $\\Delta h_c = 10^{-3}$; compute and return $S$ as a float.\n- Periodic error: $N = 128$; compute and return $E_\\infty$ as a float.\n- Symmetry boundary residual check: $N = 80$, tolerance $\\tau = 5 \\times 10^{-4}$; compute the boundary derivative magnitude and return a boolean indicating whether it is less than $\\tau$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order described above, namely $$[p, E_2^{\\mathrm{Neumann}}, S^{\\mathrm{Robin}}, E_\\infty^{\\mathrm{Periodic}}, \\mathrm{sym\\_ok}].$$ Each float should be printed in standard decimal notation, and the boolean should be printed as either True or False.",
            "solution": "The problem asks for the implementation of a second-order accurate finite-difference solver for the one-dimensional steady-state heat equation, $-\\frac{d^2 T}{dx^2} = s(x)$, subject to five different types of boundary conditions. The solution requires constructing and solving a linear system of equations for each case, and then using manufactured solutions to perform verification and sensitivity analysis.\n\nThe core of the method is the discretization of the differential operator and the boundary conditions on a uniform grid. Let the domain $[0, 1]$ be discretized into $N$ points $x_i = i h$, where $h$ is the grid spacing. For non-periodic problems, the grid includes endpoints, so $h = 1/(N-1)$ and $i = 0, \\dots, N-1$. For periodic problems, the grid covers $[0, 1)$, so $h=1/N$ and $i = 0, \\dots, N-1$.\n\nThe second derivative is approximated using a second-order central difference formula:\n$$ \\left. \\frac{d^2 T}{dx^2} \\right|_{x_i} \\approx \\frac{T_{i-1} - 2 T_i + T_{i+1}}{h^2} $$\nSubstituting this into the governing equation $-\\frac{d^2 T}{dx^2} = s(x)$ gives the discrete equation for an interior grid point $x_i$:\n$$ -\\frac{T_{i-1} - 2 T_i + T_{i+1}}{h^2} = s(x_i) $$\nRearranging yields a linear equation relating the temperature at neighboring points:\n$$ -T_{i-1} + 2 T_i - T_{i+1} = h^2 s(x_i) $$\nThis equation forms the basis of the linear system $A \\mathbf{T} = \\mathbf{b}$, where $\\mathbf{T} = [T_0, T_1, \\dots, T_{N-1}]^T$ is the vector of unknown temperatures. The specific form of the matrix $A$ and the right-hand-side vector $\\mathbf{b}$ depends on the boundary conditions.\n\nBelow, we detail the construction of the linear system for each boundary condition type.\n\n**1. Dirichlet Boundary Conditions**\nGiven $T(0) = T_0$ and $T(1) = T_1$. These conditions are enforced directly on the grid points $x_0$ and $x_{N-1}$.\nThe linear system for $\\mathbf{T} = [T_0, ..., T_{N-1}]^T$ is:\n- For $i=0$: $T_0 = T_0$. This corresponds to a row in matrix $A$ of $[1, 0, \\dots, 0]$ and $b_0 = T_0$.\n- For $i=1, \\dots, N-2$: $-T_{i-1} + 2 T_i - T_{i+1} = h^2 s(x_i)$.\n- For $i=N-1$: $T_{N-1} = T_1$. This corresponds to a row in matrix $A$ of $[0, \\dots, 0, 1]$ and $b_{N-1} = T_1$.\nThe resulting matrix $A$ is a tridiagonal-like matrix.\n\n**2. Neumann Boundary Conditions**\nGiven $\\frac{dT}{dx}(0) = g_0$ and $\\frac{dT}{dx}(1) = g_1$. These derivative conditions are discretized using second-order central differences, which requires introducing \"ghost\" points $T_{-1}$ and $T_N$:\n$$ \\frac{T_1 - T_{-1}}{2h} = g_0 \\implies T_{-1} = T_1 - 2hg_0 $$\n$$ \\frac{T_N - T_{N-2}}{2h} = g_1 \\implies T_N = T_{N-2} + 2hg_1 $$\nThese ghost points are eliminated by substituting them into the governing equation evaluated at the boundary points $x_0$ and $x_{N-1}$:\n- For $i=0$: $-T_{-1} + 2T_0 - T_1 = h^2s(x_0) \\implies -(T_1 - 2hg_0) + 2T_0 - T_1 = h^2s(x_0) \\implies 2T_0 - 2T_1 = h^2s(x_0) - 2hg_0$.\n- For $i=N-1$: $-T_{N-2} + 2T_{N-1} - T_N = h^2s(x_{N-1}) \\implies -T_{N-2} + 2T_{N-1} - (T_{N-2} + 2hg_1) = h^2s(x_{N-1}) \\implies -2T_{N-2} + 2T_{N-1} = h^2s(x_{N-1}) + 2hg_1$.\nThe resulting linear system $A\\mathbf{T}=\\mathbf{b}$ has a nullspace corresponding to constant solutions. To ensure a unique solution, the constraint $\\int_0^1 T(x)dx=0$ is added. This is discretized using the trapezoidal rule, $h \\sum_{i=0}^{N-1} w_i T_i = 0$, where $w_i$ are the trapezoidal weights. This constraint is incorporated using a Lagrange multiplier $\\lambda$, leading to an augmented, non-singular $(N+1) \\times (N+1)$ block system:\n$$\n\\begin{pmatrix} A & C^T \\\\ C & 0 \\end{pmatrix}\n\\begin{pmatrix} \\mathbf{T} \\\\ \\lambda \\end{pmatrix}\n= \\begin{pmatrix} \\mathbf{b} \\\\ 0 \\end{pmatrix}\n$$\nwhere $C = h[w_0, w_1, \\dots, w_{N-1}]$.\n\n**3. Robin (Convective) Boundary Condition**\nGiven $-\\frac{dT}{dx}(0) = h_c(T(0) - T_\\infty)$ and $T(1)=T_{end}$, where $h_c$ is the convective coefficient. The derivative at $x=0$ is approximated using a second-order one-sided difference:\n$$ \\left. \\frac{dT}{dx} \\right|_{x=0} \\approx \\frac{-3T_0 + 4T_1 - T_2}{2h_g} $$\nwhere $h_g$ is the grid spacing. Substituting this into the Robin condition gives the first row of the linear system:\n$$ - \\frac{-3T_0 + 4T_1 - T_2}{2h_g} = h_c(T_0 - T_\\infty) $$\nRearranging gives the equation provided in the problem statement:\n$$ \\left(\\frac{3}{2h_g} - h_c\\right) T_0 - \\frac{2}{h_g} T_1 + \\frac{1}{2h_g} T_2 = -h_c T_\\infty $$\nThe interior equations are standard, and the last equation is the Dirichlet condition $T_{N-1} = T_{end}$. This system is well-posed and does not require augmentation.\n\n**4. Periodic Boundary Conditions**\nGiven $T(0)=T(1)$ and $\\frac{dT}{dx}(0)=\\frac{dT}{dx}(1)$. On a periodic grid ($x_i=i/N$), these conditions are naturally handled by using wrap-around indices (modulo $N$) in the central difference formula for all points $i=0, \\dots, N-1$:\n$$ -T_{(i-1)\\pmod N} + 2T_i - T_{(i+1)\\pmod N} = h^2 s(x_i) $$\nThis results in a circulant matrix $A$. Similar to the Neumann case, this system has a constant nullspace and requires the zero-mean constraint $\\int_0^1 T(x)dx=0$. Discretizing with equal weights for the periodic grid ($h \\sum T_i = 0$) and using a Lagrange multiplier leads to the same augmented block system structure as in the Neumann case.\n\n**5. Symmetry Boundary Condition**\nThe symmetry condition $\\frac{dT}{dx}(0)=0$ is a special case of the Neumann condition with $g_0=0$. The boundary at $x=1$ is Dirichlet, $T(1)=T_{end}$. The system is constructed as a hybrid:\n- For $i=0$: Use the Neumann boundary equation with $g_0=0$, which simplifies to $2T_0 - 2T_1 = h^2s(x_0)$.\n- For $i=1, \\dots, N-2$: Use the standard interior equation.\n- For $i=N-1$: Use the Dirichlet condition $T_{N-1}=T_{end}$.\nThis system is well-posed without augmentation.\n\nThe numerical implementation involves constructing the appropriate matrix $A$ and vector $\\mathbf{b}$ for each test case, solving the linear system for $\\mathbf{T}$, and then computing the required error norms, convergence order, or sensitivity metrics based on the provided manufactured solutions.",
            "answer": "```python\nimport numpy as np\n\ndef solve_bvp(N, s_func, bc_type, bc_params):\n    \"\"\"\n    Solves the 1D heat equation -T'' = s(x) using finite differences.\n\n    Args:\n        N (int): Number of grid points.\n        s_func (callable): Source function s(x).\n        bc_type (str): Type of boundary condition. One of 'dirichlet', \n                         'neumann', 'robin', 'periodic', 'symmetry'.\n        bc_params (dict): Parameters for the boundary conditions.\n\n    Returns:\n        tuple: A tuple (x, T) where x is the grid and T is the numerical solution.\n    \"\"\"\n    if bc_type == 'periodic':\n        h = 1.0 / N\n        x = np.linspace(0, 1.0 - h, N)\n    else:\n        h = 1.0 / (N - 1)\n        x = np.linspace(0.0, 1.0, N)\n\n    s_vec = s_func(x)\n    \n    if bc_type in ['neumann', 'periodic']:\n        # Augmented system for singular problems\n        size = N + 1\n        A = np.zeros((size, size))\n        b = np.zeros(size)\n\n        if bc_type == 'neumann':\n            A[:N, :N] = np.diag(2.0 * np.ones(N)) - np.diag(np.ones(N - 1), 1) - np.diag(np.ones(N - 1), -1)\n            # Boundary rows\n            g0, g1 = bc_params['g0'], bc_params['g1']\n            A[0, 0], A[0, 1] = 2.0, -2.0\n            A[N - 1, N - 2], A[N - 1, N - 1] = -2.0, 2.0\n            \n            b[:N] = h**2 * s_vec\n            b[0] -= 2.0 * h * g0\n            b[N - 1] += 2.0 * h * g1\n            \n            # Lagrange multiplier for zero-mean constraint (trapezoidal rule)\n            weights = np.ones(N)\n            weights[0] = weights[-1] = 0.5\n            C = h * weights\n            A[:N, N] = C\n            A[N, :N] = C\n        else: # periodic\n            A[:N, :N] = np.diag(2.0 * np.ones(N)) \\\n                      - np.diag(np.ones(N - 1), 1) \\\n                      - np.diag(np.ones(N - 1), -1)\n            A[0, N - 1] = -1.0\n            A[N - 1, 0] = -1.0\n            b[:N] = h**2 * s_vec\n            \n            # Lagrange multiplier for zero-mean constraint (equal weights)\n            C = h * np.ones(N)\n            A[:N, N] = C\n            A[N, :N] = C\n\n    else: # Well-posed problems\n        size = N\n        A = np.zeros((size, size))\n        b = np.zeros(size)\n        \n        # Interior points\n        for i in range(1, N - 1):\n            A[i, i-1] = -1.0\n            A[i, i] = 2.0\n            A[i, i+1] = -1.0\n            b[i] = h**2 * s_vec[i]\n            \n        if bc_type == 'dirichlet':\n            T0, T1 = bc_params['T0'], bc_params['T1']\n            A[0, 0] = 1.0\n            b[0] = T0\n            A[N - 1, N - 1] = 1.0\n            b[N - 1] = T1\n        elif bc_type == 'robin':\n            h_conv, T_inf, T1 = bc_params['h_conv'], bc_params['T_inf'], bc_params['T1']\n            # Robin BC at x=0\n            A[0, 0] = 3.0 / (2.0 * h) - h_conv\n            A[0, 1] = -4.0 / (2.0 * h)\n            A[0, 2] = 1.0 / (2.0 * h)\n            b[0] = -h_conv * T_inf\n            # Dirichlet BC at x=1\n            A[N - 1, N - 1] = 1.0\n            b[N - 1] = T1\n        elif bc_type == 'symmetry':\n            T1 = bc_params['T1']\n            # Symmetry (Neumann g=0) at x=0\n            A[0, 0], A[0, 1] = 2.0, -2.0\n            b[0] = h**2 * s_vec[0]\n            # Dirichlet at x=1\n            A[N-1, N-1] = 1.0\n            b[N-1] = T1\n            \n    sol = np.linalg.solve(A, b)\n    T = sol[:N] if bc_type in ['neumann', 'periodic'] else sol\n    return x, T\n\n# --- Main execution function ---\ndef solve():\n    pi = np.pi\n    e = np.e\n    results = []\n\n    # 1. Dirichlet test: Order of accuracy\n    N1, N2 = 50, 100\n    s_dirichlet = lambda x: pi**2 * np.sin(pi * x)\n    T_exact_dirichlet = lambda x: np.sin(pi * x) + x\n    \n    # Solve for N1\n    h1 = 1.0 / (N1 - 1)\n    x1, T_num1 = solve_bvp(N1, s_dirichlet, 'dirichlet', {'T0': 0.0, 'T1': 1.0})\n    weights1 = np.ones(N1); weights1[0] = weights1[-1] = 0.5\n    E2_1 = np.sqrt(h1 * np.sum(weights1 * (T_num1 - T_exact_dirichlet(x1))**2))\n    \n    # Solve for N2\n    h2 = 1.0 / (N2 - 1)\n    x2, T_num2 = solve_bvp(N2, s_dirichlet, 'dirichlet', {'T0': 0.0, 'T1': 1.0})\n    weights2 = np.ones(N2); weights2[0] = weights2[-1] = 0.5\n    E2_2 = np.sqrt(h2 * np.sum(weights2 * (T_num2 - T_exact_dirichlet(x2))**2))\n\n    p = np.log(E2_1 / E2_2) / np.log(h1 / h2)\n    results.append(p)\n\n    # 2. Neumann test: L2 error\n    N_neumann = 64\n    s_neumann = lambda x: pi**2 * np.cos(pi * x)\n    T_exact_neumann = lambda x: np.cos(pi * x)\n    \n    x_neumann, T_num_neumann = solve_bvp(N_neumann, s_neumann, 'neumann', {'g0': 0.0, 'g1': 0.0})\n    h_neumann = 1.0 / (N_neumann - 1)\n    weights_n = np.ones(N_neumann); weights_n[0] = weights_n[-1] = 0.5\n    E2_neumann = np.sqrt(h_neumann * np.sum(weights_n * (T_num_neumann - T_exact_neumann(x_neumann))**2))\n    results.append(E2_neumann)\n\n    # 3. Robin test: Sensitivity\n    N_robin = 101\n    h_conv_robin = 1.0 \n    T_inf_robin = 2.0\n    delta_h_conv_robin = 1e-3\n    s_robin = lambda x: -np.exp(x)\n\n    # Base case\n    _, T_base = solve_bvp(N_robin, s_robin, 'robin', {'h_conv': h_conv_robin, 'T_inf': T_inf_robin, 'T1': e})\n    # Perturbed case\n    x_robin_p, T_pert = solve_bvp(N_robin, s_robin, 'robin', {'h_conv': h_conv_robin + delta_h_conv_robin, 'T_inf': T_inf_robin, 'T1': e})\n\n    h_grid_robin = 1.0 / (N_robin - 1)\n    weights_r = np.ones(N_robin); weights_r[0] = weights_r[-1] = 0.5\n    norm_diff = np.sqrt(h_grid_robin * np.sum(weights_r * (T_pert - T_base)**2))\n    S_robin = norm_diff / delta_h_conv_robin\n    results.append(S_robin)\n\n    # 4. Periodic test: L_inf error\n    N_periodic = 128\n    s_periodic = lambda x: 4 * pi**2 * np.sin(2 * pi * x)\n    T_exact_periodic = lambda x: np.sin(2 * pi * x)\n    \n    x_periodic, T_num_periodic = solve_bvp(N_periodic, s_periodic, 'periodic', {})\n    E_inf_periodic = np.max(np.abs(T_num_periodic - T_exact_periodic(x_periodic)))\n    results.append(E_inf_periodic)\n\n    # 5. Symmetry test: Boundary residual check\n    N_symm = 80\n    tau_symm = 5e-4\n    s_symm = lambda x: -0.5 * pi**2 * np.cos(pi * x)\n    \n    x_symm, T_num_symm = solve_bvp(N_symm, s_symm, 'symmetry', {'T1': 1.0})\n    h_symm = 1.0 / (N_symm - 1)\n    \n    # Second-order one-sided derivative at x=0\n    T0, T1, T2 = T_num_symm[0], T_num_symm[1], T_num_symm[2]\n    deriv_at_0 = (-3.0 * T0 + 4.0 * T1 - T2) / (2.0 * h_symm)\n    sym_ok = np.abs(deriv_at_0) < tau_symm\n    results.append(sym_ok)\n\n    # Final print statement\n    result_str = f\"[{results[0]},{results[1]},{results[2]},{results[3]},{results[4]}]\"\n    print(result_str)\n\nsolve()\n```"
        }
    ]
}