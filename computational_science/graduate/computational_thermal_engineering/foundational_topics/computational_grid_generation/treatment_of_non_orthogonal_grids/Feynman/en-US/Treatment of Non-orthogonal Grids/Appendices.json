{
    "hands_on_practices": [
        {
            "introduction": "Before discretizing physical laws, a robust description of the computational grid's geometry is essential. This practice grounds your understanding in the fundamental vector calculations required to define face centroids, area vectors, and the critical geometric relationships between neighboring cells on a general non-orthogonal mesh . Mastering these first-principle calculations is the initial step toward building or analyzing any advanced finite volume solver.",
            "id": "3999805",
            "problem": "Consider steady heat conduction modeled by Fourier’s law, where the diffusive heat flux density across a face is proportional to the temperature gradient projected along the face’s outward unit normal. In the Finite Volume Method (FVM), on non-orthogonal grids, the primary diffusion contribution between two neighboring control volumes is built from the projection of the centroid-to-centroid vector onto the face unit normal, which requires robust geometric definitions of the face centroid and face normal for general polyhedral cells.\n\nA single quadrilateral face separates two neighboring cells with centroids $P$ and $N$. The face vertices are given in counterclockwise order by the position vectors $\\boldsymbol{r}_1$, $\\boldsymbol{r}_2$, $\\boldsymbol{r}_3$, and $\\boldsymbol{r}_4$ in three-dimensional space. The vertex coordinates and cell centroids are:\n- $\\boldsymbol{r}_1 = (\\,0.100,\\, 0.000,\\, 0.020\\,)$ m,\n- $\\boldsymbol{r}_2 = (\\,0.180,\\, 0.040,\\, 0.030\\,)$ m,\n- $\\boldsymbol{r}_3 = (\\,0.160,\\, 0.120,\\, 0.010\\,)$ m,\n- $\\boldsymbol{r}_4 = (\\,0.080,\\, 0.080,\\, 0.000\\,)$ m,\n- $\\boldsymbol{r}_P = (\\,0.120,\\, 0.050,\\, 0.010\\,)$ m,\n- $\\boldsymbol{r}_N = (\\,0.140,\\, 0.090,\\, 0.020\\,)$ m.\n\nStarting from first principles of vector calculus and geometry, and without assuming planarity beyond the local triangular decompositions, do the following:\n- Construct the face centroid $\\boldsymbol{r}_f$ by decomposing the quadrilateral into two triangles $(\\boldsymbol{r}_1,\\boldsymbol{r}_2,\\boldsymbol{r}_3)$ and $(\\boldsymbol{r}_1,\\boldsymbol{r}_3,\\boldsymbol{r}_4)$ and performing an area-weighted average of the triangle centroids.\n- Construct the face area vector by summing the triangle area vectors, and define the unit face normal $\\boldsymbol{n}_f$ by normalizing this area vector. Choose the orientation of $\\boldsymbol{n}_f$ such that $(\\boldsymbol{r}_N - \\boldsymbol{r}_P)\\cdot \\boldsymbol{n}_f \\ge 0$.\n- Using these geometric constructs, derive and compute the orthogonal distance $d_{\\perp}$ as the projection of $(\\boldsymbol{r}_N - \\boldsymbol{r}_P)$ onto $\\boldsymbol{n}_f$.\n\nReport only the final value of $d_{\\perp}$. Express your answer in meters and round to four significant figures.",
            "solution": "The user-provided problem has been validated and is determined to be a valid, well-posed problem in computational geometry, relevant to the field of computational thermal engineering. All necessary data are provided, the constraints are consistent, and the problem is grounded in established scientific and mathematical principles.\n\nThe solution proceeds by following the steps outlined in the problem statement. All coordinates are given in meters.\n\nFirst, we define the given position vectors for the vertices of the quadrilateral face and the centroids of the neighboring cells, $P$ and $N$:\n$\\boldsymbol{r}_1 = \\begin{pmatrix} 0.100 \\\\ 0.000 \\\\ 0.020 \\end{pmatrix}$, $\\boldsymbol{r}_2 = \\begin{pmatrix} 0.180 \\\\ 0.040 \\\\ 0.030 \\end{pmatrix}$, $\\boldsymbol{r}_3 = \\begin{pmatrix} 0.160 \\\\ 0.120 \\\\ 0.010 \\end{pmatrix}$, $\\boldsymbol{r}_4 = \\begin{pmatrix} 0.080 \\\\ 0.080 \\\\ 0.000 \\end{pmatrix}$\n$\\boldsymbol{r}_P = \\begin{pmatrix} 0.120 \\\\ 0.050 \\\\ 0.010 \\end{pmatrix}$, $\\boldsymbol{r}_N = \\begin{pmatrix} 0.140 \\\\ 0.090 \\\\ 0.020 \\end{pmatrix}$\n\nThe first task is to construct the face centroid $\\boldsymbol{r}_f$ by decomposing the quadrilateral into two triangles, $T_A = (\\boldsymbol{r}_1, \\boldsymbol{r}_2, \\boldsymbol{r}_3)$ and $T_B = (\\boldsymbol{r}_1, \\boldsymbol{r}_3, \\boldsymbol{r}_4)$.\n\nFor triangle $T_A$, we calculate its centroid, area vector, and scalar area.\nThe centroid $\\boldsymbol{c}_A$ is the arithmetic mean of its vertices:\n$$ \\boldsymbol{c}_A = \\frac{1}{3}(\\boldsymbol{r}_1 + \\boldsymbol{r}_2 + \\boldsymbol{r}_3) = \\frac{1}{3}\\begin{pmatrix} 0.100+0.180+0.160 \\\\ 0.000+0.040+0.120 \\\\ 0.020+0.030+0.010 \\end{pmatrix} = \\frac{1}{3}\\begin{pmatrix} 0.440 \\\\ 0.160 \\\\ 0.060 \\end{pmatrix} $$\nThe area vector $\\boldsymbol{A}_A$ is calculated using the cross product of two edge vectors:\n$$ \\boldsymbol{r}_2 - \\boldsymbol{r}_1 = \\begin{pmatrix} 0.080 \\\\ 0.040 \\\\ 0.010 \\end{pmatrix}, \\quad \\boldsymbol{r}_3 - \\boldsymbol{r}_1 = \\begin{pmatrix} 0.060 \\\\ 0.120 \\\\ -0.010 \\end{pmatrix} $$\n$$ \\boldsymbol{A}_A = \\frac{1}{2} [(\\boldsymbol{r}_2 - \\boldsymbol{r}_1) \\times (\\boldsymbol{r}_3 - \\boldsymbol{r}_1)] = \\frac{1}{2} \\begin{pmatrix} (0.040)(-0.010) - (0.010)(0.120) \\\\ (0.010)(0.060) - (0.080)(-0.010) \\\\ (0.080)(0.120) - (0.040)(0.060) \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} -0.0016 \\\\ 0.0014 \\\\ 0.0072 \\end{pmatrix} = \\begin{pmatrix} -0.0008 \\\\ 0.0007 \\\\ 0.0036 \\end{pmatrix} $$\nThe scalar area $A_A$ is the magnitude of $\\boldsymbol{A}_A$:\n$$ A_A = |\\boldsymbol{A}_A| = \\sqrt{(-0.0008)^2 + (0.0007)^2 + (0.0036)^2} = \\sqrt{1.409 \\times 10^{-5}} \\approx 0.003753665 \\text{ m}^2 $$\n\nFor triangle $T_B$, we perform analogous calculations.\nThe centroid $\\boldsymbol{c}_B$ is:\n$$ \\boldsymbol{c}_B = \\frac{1}{3}(\\boldsymbol{r}_1 + \\boldsymbol{r}_3 + \\boldsymbol{r}_4) = \\frac{1}{3}\\begin{pmatrix} 0.100+0.160+0.080 \\\\ 0.000+0.120+0.080 \\\\ 0.020+0.010+0.000 \\end{pmatrix} = \\frac{1}{3}\\begin{pmatrix} 0.340 \\\\ 0.200 \\\\ 0.030 \\end{pmatrix} $$\nThe area vector $\\boldsymbol{A}_B$ is:\n$$ \\boldsymbol{r}_3 - \\boldsymbol{r}_1 = \\begin{pmatrix} 0.060 \\\\ 0.120 \\\\ -0.010 \\end{pmatrix}, \\quad \\boldsymbol{r}_4 - \\boldsymbol{r}_1 = \\begin{pmatrix} -0.020 \\\\ 0.080 \\\\ -0.020 \\end{pmatrix} $$\n$$ \\boldsymbol{A}_B = \\frac{1}{2} [(\\boldsymbol{r}_3 - \\boldsymbol{r}_1) \\times (\\boldsymbol{r}_4 - \\boldsymbol{r}_1)] = \\frac{1}{2} \\begin{pmatrix} (0.120)(-0.020) - (-0.010)(0.080) \\\\ (-0.010)(-0.020) - (0.060)(-0.020) \\\\ (0.060)(0.080) - (0.120)(-0.020) \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} -0.0016 \\\\ 0.0014 \\\\ 0.0072 \\end{pmatrix} = \\begin{pmatrix} -0.0008 \\\\ 0.0007 \\\\ 0.0036 \\end{pmatrix} $$\nThe scalar area $A_B$ is the magnitude of $\\boldsymbol{A}_B$:\n$$ A_B = |\\boldsymbol{A}_B| = \\sqrt{(-0.0008)^2 + (0.0007)^2 + (0.0036)^2} = \\sqrt{1.409 \\times 10^{-5}} \\approx 0.003753665 \\text{ m}^2 $$\nThe face centroid $\\boldsymbol{r}_f$ is the area-weighted average of the triangle centroids:\n$$ \\boldsymbol{r}_f = \\frac{A_A \\boldsymbol{c}_A + A_B \\boldsymbol{c}_B}{A_A + A_B} $$\nSince $A_A = A_B$, this simplifies to the arithmetic mean of the centroids:\n$$ \\boldsymbol{r}_f = \\frac{1}{2}(\\boldsymbol{c}_A + \\boldsymbol{c}_B) = \\frac{1}{2} \\left[ \\frac{1}{3}\\begin{pmatrix} 0.440 \\\\ 0.160 \\\\ 0.060 \\end{pmatrix} + \\frac{1}{3}\\begin{pmatrix} 0.340 \\\\ 0.200 \\\\ 0.030 \\end{pmatrix} \\right] = \\frac{1}{6}\\begin{pmatrix} 0.780 \\\\ 0.360 \\\\ 0.090 \\end{pmatrix} = \\begin{pmatrix} 0.130 \\\\ 0.060 \\\\ 0.015 \\end{pmatrix} $$\n\nThe second task is to construct the face area vector and the unit face normal $\\boldsymbol{n}_f$.\nThe total face area vector $\\boldsymbol{A}_f$ is the sum of the triangle area vectors:\n$$ \\boldsymbol{A}_f = \\boldsymbol{A}_A + \\boldsymbol{A}_B = \\begin{pmatrix} -0.0008 \\\\ 0.0007 \\\\ 0.0036 \\end{pmatrix} + \\begin{pmatrix} -0.0008 \\\\ 0.0007 \\\\ 0.0036 \\end{pmatrix} = \\begin{pmatrix} -0.0016 \\\\ 0.0014 \\\\ 0.0072 \\end{pmatrix} $$\nThe magnitude of the face area vector is:\n$$ |\\boldsymbol{A}_f| = \\sqrt{(-0.0016)^2 + (0.0014)^2 + (0.0072)^2} = \\sqrt{2.56 \\times 10^{-6} + 1.96 \\times 10^{-6} + 51.84 \\times 10^{-6}} = \\sqrt{5.636 \\times 10^{-5}} $$\n$$ |\\boldsymbol{A}_f| \\approx 0.00750733 \\text{ m}^2 $$\nThe raw unit normal vector is $\\boldsymbol{n}_{f, \\text{raw}} = \\frac{\\boldsymbol{A}_f}{|\\boldsymbol{A}_f|}$.\nWe must ensure its orientation satisfies $(\\boldsymbol{r}_N - \\boldsymbol{r}_P)\\cdot \\boldsymbol{n}_f \\ge 0$. First, we compute the vector connecting the cell centroids:\n$$ \\boldsymbol{d} = \\boldsymbol{r}_N - \\boldsymbol{r}_P = \\begin{pmatrix} 0.140-0.120 \\\\ 0.090-0.050 \\\\ 0.020-0.010 \\end{pmatrix} = \\begin{pmatrix} 0.02 \\\\ 0.04 \\\\ 0.01 \\end{pmatrix} $$\nNext, we check the sign of the dot product $\\boldsymbol{d} \\cdot \\boldsymbol{A}_f$:\n$$ \\boldsymbol{d} \\cdot \\boldsymbol{A}_f = (0.02)(-0.0016) + (0.04)(0.0014) + (0.01)(0.0072) = -0.000032 + 0.000056 + 0.000072 = 0.000096 $$\nSince this dot product is positive, the direction of $\\boldsymbol{A}_f$ is already consistent with the requirement. Thus, the final unit normal vector $\\boldsymbol{n}_f$ is:\n$$ \\boldsymbol{n}_f = \\frac{\\boldsymbol{A}_f}{|\\boldsymbol{A}_f|} = \\frac{1}{\\sqrt{5.636 \\times 10^{-5}}} \\begin{pmatrix} -0.0016 \\\\ 0.0014 \\\\ 0.0072 \\end{pmatrix} $$\n\nThe third task is to compute the orthogonal distance $d_{\\perp}$. This is defined as the projection of the centroid-to-centroid vector $\\boldsymbol{d} = \\boldsymbol{r}_N - \\boldsymbol{r}_P$ onto the unit face normal $\\boldsymbol{n}_f$. This projection is given by the dot product:\n$$ d_{\\perp} = (\\boldsymbol{r}_N - \\boldsymbol{r}_P) \\cdot \\boldsymbol{n}_f = \\boldsymbol{d} \\cdot \\frac{\\boldsymbol{A}_f}{|\\boldsymbol{A}_f|} = \\frac{\\boldsymbol{d} \\cdot \\boldsymbol{A}_f}{|\\boldsymbol{A}_f|} $$\nUsing the values computed previously:\n$$ d_{\\perp} = \\frac{0.000096}{\\sqrt{5.636 \\times 10^{-5}}} \\approx \\frac{0.000096}{0.00750733} \\approx 0.0127873 \\text{ m} $$\nRounding the result to four significant figures as requested:\n$$ d_{\\perp} \\approx 0.01279 \\text{ m} $$",
            "answer": "$$\\boxed{0.01279}$$"
        },
        {
            "introduction": "With the geometric framework in place, we can investigate how grid non-orthogonality directly impacts the accuracy of a numerical scheme. This exercise guides you through implementing a simple two-point flux approximation for a heat conduction problem and using the method of manufactured solutions to quantify the resulting discretization error . By correlating this error with standard mesh skewness metrics, you will develop a practical understanding of how to assess mesh quality and predict the behavior of basic numerical methods on imperfect grids.",
            "id": "3999818",
            "problem": "Consider the steady, isotropic heat conduction equation with constant thermal conductivity, written as $-\\nabla \\cdot (k \\nabla T) = q$, with $k$ a positive constant. In a Finite Volume Method (FVM) discretization on a general two-dimensional mesh, the divergence of the diffusive flux over a control volume can be derived from the divergence theorem as the sum of normal fluxes across its faces. On non-orthogonal grids, the center-to-center vector between neighboring cells is generally not aligned with the face normal, which induces geometric errors if one uses a two-point approximation for the flux. This problem is concerned with quantifying such errors and relating them to standard skewness metrics.\n\nA family of skew meshes is constructed by applying an affine shear to a unit-square reference grid. Let the reference coordinates be $(x,y) \\in [0,1] \\times [0,1]$, with a structured partition of $N_x \\times N_y$ quadrilateral cells. Define the physical coordinates $(x',y')$ by the shear map\n$$\n\\begin{pmatrix} x' \\\\ y' \\end{pmatrix}\n=\n\\begin{pmatrix} 1  \\alpha \\\\ 0  1 \\end{pmatrix}\n\\begin{pmatrix} x \\\\ y \\end{pmatrix}\n=\n\\begin{pmatrix} x + \\alpha y \\\\ y \\end{pmatrix},\n$$\nwhere $\\alpha$ is a real-valued skew parameter. The mapping is linear and area-preserving for any $\\alpha$.\n\nLet the benchmark temperature field be the manufactured solution\n$$\nT(x',y') = \\sin(\\pi x') \\sin(\\pi y'),\n$$\nand take $k = 1$ so that the exact Laplacian is\n$$\n\\nabla^2 T(x',y') = -2 \\pi^2 \\sin(\\pi x') \\sin(\\pi y').\n$$\nFor each interior cell, form a discrete approximation to the divergence of the diffusive flux using a two-point, center-to-center scheme on each face. For a face $f$ between a cell $P$ and a neighbor $N$, define the center-to-center vector $\\boldsymbol{r}_f = \\boldsymbol{x}_N - \\boldsymbol{x}_P$, its magnitude $|\\boldsymbol{r}_f|$, and unit vector $\\hat{\\boldsymbol{r}}_f = \\boldsymbol{r}_f / |\\boldsymbol{r}_f|$. Let the face edge vector be $\\boldsymbol{e}_f$ whose magnitude is the face length $L_f = \\|\\boldsymbol{e}_f\\|$, and let $\\hat{\\boldsymbol{n}}_f$ be the unit normal to the face, oriented such that $\\hat{\\boldsymbol{n}}_f \\cdot \\hat{\\boldsymbol{r}}_f \\ge 0$. The face area vector is then $\\boldsymbol{S}_f = L_f \\hat{\\boldsymbol{n}}_f$. The two-point normal flux across face $f$ is computed as\n$$\n\\Phi_f^{\\text{TP}} = \\left( \\frac{T_N - T_P}{|\\boldsymbol{r}_f|} \\right) \\left( \\boldsymbol{S}_f \\cdot \\hat{\\boldsymbol{r}}_f \\right),\n$$\nand the discrete divergence in cell $P$ is $\\sum_{f \\in \\partial P} \\Phi_f^{\\text{TP}} / A_P$, where $A_P$ is the physical cell area. At boundary faces, impose Dirichlet data by setting $T_N = T$ evaluated at the face center and taking $\\boldsymbol{r}_f$ from the cell center to the face center.\n\nDefine the per-cell error as\n$$\nE_P = \\frac{1}{A_P} \\sum_{f \\in \\partial P} \\Phi_f^{\\text{TP}} - \\nabla^2 T(\\boldsymbol{x}_P),\n$$\nand compute the discrete $L_2$ norm and the discrete $L_{\\infty}$ norm over all cells:\n$$\n\\|E\\|_{L_2} = \\sqrt{ \\sum_{P} A_P \\, E_P^2 }, \\qquad \\|E\\|_{L_{\\infty}} = \\max_{P} |E_P|.\n$$\nTo characterize non-orthogonality, use the following face-based skewness metrics. For each face $f$, define the misalignment angle\n$$\n\\theta_f = \\arccos\\!\\left( \\left| \\hat{\\boldsymbol{n}}_f \\cdot \\hat{\\boldsymbol{r}}_f \\right| \\right),\n$$\nexpressed in radians, and the non-orthogonal correction vector\n$$\n\\boldsymbol{s}_f = \\boldsymbol{S}_f - \\left( \\boldsymbol{S}_f \\cdot \\hat{\\boldsymbol{r}}_f \\right) \\hat{\\boldsymbol{r}}_f,\n$$\nwith magnitude $\\|\\boldsymbol{s}_f\\| = L_f \\sin(\\theta_f)$. Over the entire mesh (including boundary faces), compute\n$$\n\\theta_{\\max} = \\max_f \\theta_f, \\qquad \\overline{\\|\\boldsymbol{s}\\|} = \\frac{1}{N_F} \\sum_{f} \\|\\boldsymbol{s}_f\\|,\n$$\nwhere $N_F$ is the total number of faces.\n\nYour task is to implement a program that, for a sequence of meshes generated by different $(N_x,N_y,\\alpha)$ triplets, computes the discrete $L_2$ and $L_{\\infty}$ norms of the error $E_P$, along with the skewness metrics $\\theta_{\\max}$ and $\\overline{\\|\\boldsymbol{s}\\|}$, and then correlates the error magnitude with the skewness metrics by reporting the Pearson correlation coefficients across the test suite between the vector of $\\|E\\|_{L_2}$ values and the vectors of $\\theta_{\\max}$ and $\\overline{\\|\\boldsymbol{s}\\|}$, respectively.\n\nAngle quantities must be reported in radians. All other quantities are dimensionless in this setup.\n\nImplement the program to evaluate the following test suite:\n- Case $1$: $(N_x,N_y,\\alpha) = (20,20,0.0)$.\n- Case $2$: $(N_x,N_y,\\alpha) = (20,20,0.2)$.\n- Case $3$: $(N_x,N_y,\\alpha) = (20,20,0.4)$.\n- Case $4$ (edge case with coarse resolution): $(N_x,N_y,\\alpha) = (4,4,0.3)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case contributes a sub-list with four floats $[\\|E\\|_{L_2}, \\|E\\|_{L_{\\infty}}, \\theta_{\\max}, \\overline{\\|\\boldsymbol{s}\\|}]$ in that order. After these sub-lists, append two additional floats: the Pearson correlation coefficient between the list of $\\|E\\|_{L_2}$ values and the list of $\\theta_{\\max}$ values across the four cases, and the Pearson correlation coefficient between the list of $\\|E\\|_{L_2}$ values and the list of $\\overline{\\|\\boldsymbol{s}\\|}$ values across the four cases. For example, the output format is\n$$\n\\big[ [e_{2,1}, e_{\\infty,1}, \\theta_{\\max,1}, \\overline{\\|s\\|}_1], [e_{2,2}, e_{\\infty,2}, \\theta_{\\max,2}, \\overline{\\|s\\|}_2], [e_{2,3}, e_{\\infty,3}, \\theta_{\\max,3}, \\overline{\\|s\\|}_3], [e_{2,4}, e_{\\infty,4}, \\theta_{\\max,4}, \\overline{\\|s\\|}_4], \\rho_{e_2,\\theta}, \\rho_{e_2,\\overline{s}} \\big],\n$$\nwhere each $e_{2,i}$ is $\\|E\\|_{L_2}$ for case $i$, each $e_{\\infty,i}$ is $\\|E\\|_{L_{\\infty}}$ for case $i$, and $\\rho_{e_2,\\theta}$ and $\\rho_{e_2,\\overline{s}}$ are the corresponding Pearson correlation coefficients. The program must generate the mesh, perform all computations, and print the single-line output exactly in this format, without any other text.",
            "solution": "The problem requires a critical analysis of the discretization error incurred by a two-point flux approximation (TPFA) scheme within a Finite Volume Method (FVM) framework for the steady-state heat conduction equation on non-orthogonal grids. The analysis will be performed by implementing the specified numerical scheme for a series of test cases and correlating the computed error against standard grid skewness metrics.\n\nThe governing partial differential equation is the Poisson equation, arising from steady, isotropic heat conduction with constant thermal conductivity $k$ and a heat source $q$:\n$$\n-\\nabla \\cdot (k \\nabla T) = q\n$$\nFor this problem, we are given $k=1$, so the equation simplifies to $-\\nabla^2 T = q$. The FVM is based on integrating this equation over a control volume $V_P$ (a cell in the mesh) and applying the divergence theorem:\n$$\n\\int_{V_P} -\\nabla \\cdot (\\nabla T) \\, dV = \\int_{V_P} q \\, dV\n$$\n$$\n-\\oint_{\\partial V_P} \\nabla T \\cdot d\\boldsymbol{S} = \\int_{V_P} q \\, dV\n$$\nThe left-hand side represents the net heat flux into the control volume through its boundary $\\partial V_P$. Discretizing this expression, the integral over the cell volume $V_P$ is approximated as $q_P A_P$, where $q_P$ is the source evaluation at the cell center $\\boldsymbol{x}_P$ and $A_P$ is the cell area (in 2D). The boundary integral is approximated by a sum of fluxes over the faces $f$ that constitute $\\partial V_P$:\n$$\n\\sum_{f \\in \\partial V_P} \\text{Flux}_f^{\\text{in}} \\approx q_P A_P\n$$\nThe problem is set up to analyze a specific, simple approximation for the flux. For a face $f$ separating cell $P$ from a neighboring cell $N$, the temperature gradient $\\nabla T$ is approximated along the line connecting the cell centers, $\\boldsymbol{r}_f = \\boldsymbol{x}_N - \\boldsymbol{x}_P$. This leads to the two-point approximation for the heat flux entering cell $P$ from neighbor $N$ across face $f$:\n$$\n\\Phi_f^{\\text{TP}} = \\left( \\frac{T_N - T_P}{|\\boldsymbol{r}_f|} \\right) \\left( \\boldsymbol{S}_f \\cdot \\hat{\\boldsymbol{r}}_f \\right)\n$$\nHere, $\\boldsymbol{S}_f$ is the face area vector (normal to the face, with magnitude equal to face length), and $\\hat{\\boldsymbol{r}}_f$ is the unit vector along the center-to-center line. This approximation is known to be accurate only when the grid is orthogonal, i.e., when $\\boldsymbol{r}_f$ is parallel to $\\boldsymbol{S}_f$. On non-orthogonal grids, where $\\boldsymbol{S}_f \\cdot \\hat{\\boldsymbol{r}}_f \\neq |\\boldsymbol{S}_f|$, this formulation introduces a \"skewness error.\"\n\nTo quantify this error, we use the method of manufactured solutions. A smooth analytical function for the temperature field, $T(x',y') = \\sin(\\pi x') \\sin(\\pi y')$, is prescribed. The corresponding source term $q$ required to satisfy the governing equation is then calculated exactly:\n$$\nq = -\\nabla^2 T = -(-2\\pi^2 \\sin(\\pi x') \\sin(\\pi y')) = 2\\pi^2 T(x', y')\n$$\nThe discrete operator for the source term, derived from the FVM balance, is $(\\sum_{f} \\Phi_f^{\\text{TP}}) / A_P$. The problem defines the per-cell error $E_P$ as the difference between the action of the discrete operator and the analytical Laplacian operator, both evaluated using the manufactured solution:\n$$\nE_P = \\frac{1}{A_P} \\sum_{f \\in \\partial P} \\Phi_f^{\\text{TP}} - \\nabla^2 T(\\boldsymbol{x}_P)\n$$\nThis error $E_P$ represents the truncation error of the spatial discretization. We will quantify this error globally over the mesh using the discrete $L_2$ and $L_{\\infty}$ norms:\n$$\n\\|E\\|_{L_2} = \\sqrt{ \\sum_{P} A_P \\, E_P^2 }, \\qquad \\|E\\|_{L_{\\infty}} = \\max_{P} |E_P|\n$$\nThe geometric non-orthogonality is characterized by two metrics. For each face $f$, we compute the misalignment angle $\\theta_f$ between the face normal and the cell-center connection vector:\n$$\n\\theta_f = \\arccos\\!\\left( \\left| \\hat{\\boldsymbol{n}}_f \\cdot \\hat{\\boldsymbol{r}}_f \\right| \\right) = \\arccos\\!\\left( \\frac{|\\boldsymbol{S}_f \\cdot \\boldsymbol{r}_f|}{\\|\\boldsymbol{S}_f\\| \\|\\boldsymbol{r}_f\\|} \\right)\n$$\nAnd the magnitude of the non-orthogonal correction vector $\\boldsymbol{s}_f$, which is the component of the face area vector $\\boldsymbol{S}_f$ that is orthogonal to $\\hat{\\boldsymbol{r}}_f$:\n$$\n\\|\\boldsymbol{s}_f\\| = \\|\\boldsymbol{S}_f\\| \\sin(\\theta_f)\n$$\nThese are aggregated into global mesh skewness metrics $\\theta_{\\max}$ (the maximum angle over all faces) and $\\overline{\\|\\boldsymbol{s}\\|}$ (the average magnitude of $\\boldsymbol{s}_f$ over all faces).\n\nThe implementation proceeds as follows:\n1.  For each test case defined by $(N_x, N_y, \\alpha)$, a structured grid is generated. First, a uniform Cartesian grid of $(N_x+1) \\times (N_y+1)$ nodes is created in the reference domain $[0,1] \\times [0,1]$. Then, the affine shear map $\\begin{pmatrix} x' \\\\ y' \\end{pmatrix} = \\begin{pmatrix} 1  \\alpha \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} x \\\\ y \\end{pmatrix}$ is applied to transform the node coordinates into the physical domain.\n2.  Geometric properties for all cells and faces are computed. Cell centers $\\boldsymbol{x}_P$ are calculated as the centroid of their four vertices. Cell areas $A_P$ are calculated using the shoelace formula. For each face, its length $L_f$, center, and area vector $\\boldsymbol{S}_f$ are determined.\n3.  A loop iterates over each cell $P$ in the grid. For each of its four faces, the corresponding neighbor $N$ is identified.\n4.  For each face, if it is an interior face, the neighbor is an adjacent cell. If it is a boundary face, the \"neighbor\" data is taken at the face center, consistent with the specified Dirichlet boundary condition treatment.\n5.  The vectors $\\boldsymbol{r}_f$ and $\\boldsymbol{S}_f$ are computed. The orientation of $\\boldsymbol{S}_f$ is algorithmically enforced to ensure $\\boldsymbol{S}_f \\cdot \\boldsymbol{r}_f \\ge 0$.\n6.  The flux contribution $\\Phi_f^{\\text{TP}}$ is calculated and added to a running sum for cell $P$. The face-based skewness metrics $\\theta_f$ and $\\|\\boldsymbol{s}_f\\|$ are also computed and stored, avoiding duplicate calculations for interior faces.\n7.  After processing all faces of a cell, the total flux sum is used to compute the cell error $E_P$.\n8.  Once all cells are processed, the global error norms $\\|E\\|_{L_2}$ and $\\|E\\|_{L_{\\infty}}$, and the global skewness metrics $\\theta_{\\max}$ and $\\overline{\\|\\boldsymbol{s}\\|}$, are calculated.\n9.  After completing all four test cases, the Pearson correlation coefficient is computed between the vector of $\\|E\\|_{L_2}$ values and the vectors of $\\theta_{\\max}$ and $\\overline{\\|\\boldsymbol{s}\\|}$ values, respectively. This quantifies the statistical relationship between the discretization error and grid non-orthogonality.\n\nThis procedure provides a complete and rigorous evaluation as demanded by the problem statement.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        (20, 20, 0.0),\n        (20, 20, 0.2),\n        (20, 20, 0.4),\n        (4, 4, 0.3),\n    ]\n\n    case_results = []\n    e_l2_values = []\n    theta_max_values = []\n    s_bar_values = []\n\n    for Nx, Ny, alpha in test_cases:\n        e_l2, e_linf, theta_max, s_bar = compute_metrics(Nx, Ny, alpha)\n        case_results.append([e_l2, e_linf, theta_max, s_bar])\n        e_l2_values.append(e_l2)\n        theta_max_values.append(theta_max)\n        s_bar_values.append(s_bar)\n\n    # Compute correlation coefficients\n    rho_e2_theta = np.corrcoef(e_l2_values, theta_max_values)[0, 1]\n    rho_e2_s = np.corrcoef(e_l2_values, s_bar_values)[0, 1]\n\n    # Format the output string\n    result_str_parts = [f\"[{','.join(f'{val:.8e}' for val in res)}]\" for res in case_results]\n    full_result_str = f\"[{','.join(result_str_parts)},{rho_e2_theta:.8e},{rho_e2_s:.8e}]\"\n    \n    print(full_result_str)\n\ndef compute_metrics(Nx, Ny, alpha):\n    \"\"\"\n    Computes error and skewness metrics for a given mesh configuration.\n    \"\"\"\n    # Define manufactured solution and its Laplacian\n    T_func = lambda x, y: np.sin(np.pi * x) * np.sin(np.pi * y)\n    lap_T_func = lambda x, y: -2 * np.pi**2 * np.sin(np.pi * x) * np.sin(np.pi * y)\n\n    # 1. Generate mesh nodes in physical coordinates (x', y')\n    x_ref = np.linspace(0, 1, Nx + 1)\n    y_ref = np.linspace(0, 1, Ny + 1)\n    xx_ref, yy_ref = np.meshgrid(x_ref, y_ref, indexing='ij')\n\n    shear_map = np.array([[1, alpha], [0, 1]])\n    ref_coords = np.stack([xx_ref, yy_ref], axis=-1)\n    nodes = np.einsum('ij,klj-kli', shear_map, ref_coords)\n\n    # 2. Compute cell centers and areas\n    cell_centers = np.zeros((Nx, Ny, 2))\n    cell_areas = np.zeros((Nx, Ny))\n    for i in range(Nx):\n        for j in range(Ny):\n            v1 = nodes[i, j]\n            v2 = nodes[i + 1, j]\n            v3 = nodes[i + 1, j + 1]\n            v4 = nodes[i, j + 1]\n            cell_centers[i, j] = (v1 + v2 + v3 + v4) / 4.0\n            # Shoelace formula for area of a quadrilateral\n            area = 0.5 * abs(v1[0]*v2[1] - v1[1]*v2[0] + \n                             v2[0]*v3[1] - v2[1]*v3[0] + \n                             v3[0]*v4[1] - v3[1]*v4[0] + \n                             v4[0]*v1[1] - v4[1]*v1[0])\n            cell_areas[i, j] = area\n            \n    # 3. Main loop: Compute fluxes and skewness for each cell\n    cell_flux_sum = np.zeros((Nx, Ny))\n    face_thetas = []\n    face_s_mags = []\n    processed_faces = set()\n\n    for i in range(Nx):\n        for j in range(Ny):\n            P_center = cell_centers[i, j]\n            T_P = T_func(P_center[0], P_center[1])\n\n            # Neighbors: E, N, W, S\n            neighbors_info = [\n                ('E', i + 1, j, (i + 1, j), (i + 1, j + 1)), # N, P_face_node_idx1, P_face_node_idx2\n                ('N', i, j + 1, (i + 1, j + 1), (i, j + 1)),\n                ('W', i - 1, j, (i, j + 1), (i, j)),\n                ('S', i, j - 1, (i, j), (i + 1, j))\n            ]\n\n            for direction, ni, nj, v_idx1, v_idx2 in neighbors_info:\n                is_boundary = not (0 = ni  Nx and 0 = nj  Ny)\n                \n                v1 = nodes[v_idx1]\n                v2 = nodes[v_idx2]\n\n                # Face area vector S_f, oriented outwards from P\n                S_f = np.array([v2[1] - v1[1], -(v2[0] - v1[0])])\n                L_f = np.linalg.norm(S_f)\n\n                if is_boundary:\n                    face_center = (v1 + v2) / 2.0\n                    r_f = face_center - P_center\n                    T_N = T_func(face_center[0], face_center[1])\n                else:\n                    N_center = cell_centers[ni, nj]\n                    r_f = N_center - P_center\n                    T_N = T_func(N_center[0], N_center[1])\n\n                # Ensure S_f.r_f = 0 as per problem spec\n                if np.dot(S_f, r_f)  0:\n                    S_f = -S_f\n                \n                r_f_mag_sq = np.dot(r_f, r_f)\n                if r_f_mag_sq == 0:\n                    flux = 0\n                else:\n                    flux = (T_N - T_P) * np.dot(S_f, r_f) / r_f_mag_sq\n                \n                cell_flux_sum[i, j] += flux\n                \n                # Use a canonical representation of the face to avoid double counting\n                face_key = tuple(sorted((v_idx1, v_idx2)))\n                if face_key not in processed_faces:\n                    processed_faces.add(face_key)\n                    \n                    r_f_mag = np.sqrt(r_f_mag_sq)\n                    if L_f  1e-12 and r_f_mag  1e-12:\n                        cos_theta_abs = abs(np.dot(S_f, r_f)) / (L_f * r_f_mag)\n                        # Clamp due to potential floating point inaccuracies\n                        cos_theta_abs = min(1.0, max(-1.0, cos_theta_abs))\n                        theta_f = np.arccos(cos_theta_abs)\n                        s_mag = L_f * np.sin(theta_f)\n                        \n                        face_thetas.append(theta_f)\n                        face_s_mags.append(s_mag)\n\n    # 4. Compute error norms and aggregated skewness metrics\n    cell_errors = np.zeros((Nx, Ny))\n    for i in range(Nx):\n        for j in range(Ny):\n            P_center = cell_centers[i, j]\n            lap_T_P = lap_T_func(P_center[0], P_center[1])\n            discrete_lap = cell_flux_sum[i, j] / cell_areas[i, j]\n            cell_errors[i, j] = discrete_lap - lap_T_P\n            \n    e_l2 = np.sqrt(np.sum(cell_areas * cell_errors**2))\n    e_linf = np.max(np.abs(cell_errors))\n    \n    theta_max = np.max(face_thetas) if face_thetas else 0.0\n    s_bar = np.mean(face_s_mags) if face_s_mags else 0.0\n\n    return e_l2, e_linf, theta_max, s_bar\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "The errors introduced by non-orthogonality extend beyond simple loss of accuracy; they can destabilize complex, coupled systems like those found in fluid dynamics. This practice explores a critical application: the Rhie-Chow momentum interpolation scheme used to prevent pressure-velocity decoupling in incompressible flow solvers . By quantifying the error and the emergence of checkerboarding patterns when non-orthogonal corrections are omitted, you will see firsthand why proper geometric treatment is non-negotiable for robust CFD simulations.",
            "id": "3999812",
            "problem": "Consider a two-dimensional, steady, incompressible flow field in which the face-normal velocity used for mass flux evaluation is obtained via the Rhie–Chow momentum interpolation (RCMI). In a non-orthogonal grid, the orthogonal approximation of the face-normal pressure gradient uses the center-to-center pressure difference projected along the line connecting cell centers, while the full non-orthogonal correction adds the tangential component of the pressure gradient projected onto the face normal. The objective is to quantify the error in the computed face-normal velocity when non-orthogonal corrections are neglected, by comparing with a reference solution constructed from a known analytic pressure field, and to report the induced checkerboarding amplitude.\n\nFundamental base and geometric setup:\n- Let the pressure be a smooth scalar field $p(x,y)$ defined on a mapped grid. The face-normal velocity component induced by the pressure gradient is taken, in nondimensional form, as $u_{n,f} = -\\nabla p \\cdot \\boldsymbol{n}_f$, where $\\boldsymbol{n}_f$ is the unit normal of face $f$. This choice corresponds to nondimensionalization where the effective inverse momentum coefficient is unity, so all quantities are dimensionless.\n- For a face $f$ shared by two neighboring control volumes with centers separated by the vector $\\boldsymbol{d}$ of magnitude $\\lvert \\boldsymbol{d} \\rvert$, define the unit vector $\\hat{\\boldsymbol{d}} = \\boldsymbol{d} / \\lvert \\boldsymbol{d} \\rvert$. Decompose the face normal as $\\boldsymbol{n}_f = \\beta_f \\hat{\\boldsymbol{d}} + \\boldsymbol{t}_f$, where $\\beta_f = \\boldsymbol{n}_f \\cdot \\hat{\\boldsymbol{d}}$ and $\\boldsymbol{t}_f$ is the component of $\\boldsymbol{n}_f$ tangent to $\\hat{\\boldsymbol{d}}$. The orthogonal approximation of the face-normal pressure gradient uses $\\beta_f \\, \\Delta p / \\lvert \\boldsymbol{d} \\rvert$, where $\\Delta p$ is the pressure difference across the face. The non-orthogonal correction adds $\\boldsymbol{t}_f \\cdot (\\nabla p)_f$, where $(\\nabla p)_f$ is the pressure gradient evaluated at the face center.\n- Construct a non-orthogonal grid via the linear shear mapping from computational coordinates $(\\xi,\\eta) \\in [0,1]^2$ to physical coordinates $(x,y)$:\n$$\nx(\\xi,\\eta) = \\xi + \\alpha \\eta,\\quad y(\\xi,\\eta) = \\eta,\n$$\nwhere $\\alpha$ is the shear parameter. Cell centers are located at $\\xi_i = (i + 0.5) \\Delta \\xi$ and $\\eta_j = (j + 0.5) \\Delta \\eta$, with $\\Delta \\xi = 1/N_x$ and $\\Delta \\eta = 1/N_y$. Interior vertical faces lie at $\\xi_{f} = (i+1) \\Delta \\xi$ and $\\eta_{f} = \\eta_j$, and interior horizontal faces lie at $\\xi_f = \\xi_i$ and $\\eta_f = (j+1) \\Delta \\eta$.\n- For vertical faces, the face tangent is $\\partial \\boldsymbol{r} / \\partial \\eta = (\\alpha,1)$, giving the unit normal\n$$\n\\boldsymbol{n}_v = \\frac{(1,-\\alpha)}{\\sqrt{1+\\alpha^2}},\\quad \\boldsymbol{d}_v = (\\Delta \\xi, 0),\\quad \\beta_v = \\boldsymbol{n}_v \\cdot \\hat{\\boldsymbol{d}}_v = \\frac{1}{\\sqrt{1+\\alpha^2}}.\n$$\nFor horizontal faces, the face tangent is $\\partial \\boldsymbol{r} / \\partial \\xi = (1,0)$, giving the unit normal\n$$\n\\boldsymbol{n}_h = (0,1),\\quad \\boldsymbol{d}_h = (\\alpha \\Delta \\eta, \\Delta \\eta),\\quad \\beta_h = \\boldsymbol{n}_h \\cdot \\hat{\\boldsymbol{d}}_h = \\frac{1}{\\sqrt{1+\\alpha^2}}.\n$$\nThus, both vertical and horizontal faces share the same $\\beta = 1/\\sqrt{1+\\alpha^2}$, while $\\lvert \\boldsymbol{d}_v \\rvert = \\Delta \\xi$ and $\\lvert \\boldsymbol{d}_h \\rvert = \\Delta \\eta \\sqrt{1+\\alpha^2}$.\n\nReference and uncorrected face-normal gradients:\n- Reference (full correction): $g_{\\text{ref},f} = \\nabla p(x_f,y_f) \\cdot \\boldsymbol{n}_f$.\n- Uncorrected (orthogonal-only): $g_{\\text{orth},f} = \\beta_f \\, \\Delta p / \\lvert \\boldsymbol{d} \\rvert$.\n- The corresponding nondimensional face-normal velocities are $u_{\\text{ref},f} = -g_{\\text{ref},f}$ and $u_{\\text{uncorr},f} = -g_{\\text{orth},f}$.\n\nError and checkerboarding amplitude definitions:\n- The mean absolute error (MAE) is the average of $\\lvert u_{\\text{uncorr},f} - u_{\\text{ref},f} \\rvert$ over all interior faces (both vertical and horizontal).\n- The checkerboarding amplitude is defined along a one-dimensional sequence of interior faces as the magnitude of the highest-frequency discrete Fourier component (alternating pattern). For a sequence $\\{e_m\\}_{m=0}^{M-1}$ of face-velocity errors along a line, the amplitude is\n$$\nA = \\left\\lvert \\frac{1}{M} \\sum_{m=0}^{M-1} e_m (-1)^m \\right\\rvert.\n$$\nCompute $A$ along the central-row vertical faces and the central-column horizontal faces and report the maximum of the two.\n\nTest suite and pressure fields:\nUse the following nondimensional test-suite parameter sets and pressure fields $p(x,y)$, with their analytic gradients $\\nabla p(x,y)$:\n- Case $1$: $N_x = 32$, $N_y = 32$, $\\alpha = 0.3$, $p_1(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$, $\\nabla p_1 = (2\\pi \\cos(2\\pi x)\\sin(2\\pi y),\\; 2\\pi \\sin(2\\pi x)\\cos(2\\pi y))$.\n- Case $2$: $N_x = 32$, $N_y = 32$, $\\alpha = 0.0$, $p_2(x,y) = x + 2y$, $\\nabla p_2 = (1,\\;2)$.\n- Case $3$: $N_x = 32$, $N_y = 32$, $\\alpha = 1.0$, $p_1(x,y)$ as above.\n- Case $4$: $N_x = 8$, $N_y = 8$, $\\alpha = 0.5$, $p_3(x,y) = x^2 + y^2$, $\\nabla p_3 = (2x,\\;2y)$.\n- Case $5$: $N_x = 8$, $N_y = 8$, $\\alpha = 0.0$, $p_3(x,y)$ as above.\n\nRequired computations:\n- For each case, construct the grid, compute $u_{\\text{ref},f}$ and $u_{\\text{uncorr},f}$ for all interior faces, then compute the MAE and the checkerboarding amplitude $A$ as defined.\n- All quantities are nondimensional; no physical units are required.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list of five two-element lists, each inner list being $[\\text{MAE},\\text{Amplitude}]$ for the corresponding test case, with no spaces, for example:\n[[mae1,amp1],[mae2,amp2],[mae3,amp3],[mae4,amp4],[mae5,amp5]]",
            "solution": "The problem statement has been validated and is deemed sound. It presents a well-posed, scientifically grounded numerical experiment in computational fluid dynamics, specifically concerning the finite volume method on non-orthogonal grids. All necessary parameters, definitions, and governing equations are provided, and no contradictions or ambiguities that would preclude a unique solution are present. The problem is a standard exercise in analyzing the discretization error associated with the pressure gradient term when non-orthogonal corrections are omitted.\n\nThe task is to compute the mean absolute error (MAE) and the checkerboarding amplitude for the face-normal velocity on a two-dimensional, non-orthogonal grid. The error arises from using a simplified orthogonal approximation for the pressure gradient instead of the full, geometrically correct formulation. The analysis is performed for several test cases involving different grid parameters and analytic pressure fields.\n\nThe core of the methodology involves calculating two versions of the face-normal velocity, $u_f$, for each interior face $f$ of the computational grid.\n\n$1$. **Grid and Coordinate System**: The physical domain $(x,y)$ is generated from a uniform computational grid in $(\\xi,\\eta) \\in [0,1]^2$ via the linear shear mapping:\n$$\nx(\\xi,\\eta) = \\xi + \\alpha \\eta, \\quad y(\\xi,\\eta) = \\eta\n$$\nwhere $\\alpha$ is the shear parameter. Cell centers are located at the center of computational cells, and face centers are located at the boundaries between computational cells. For a grid of $N_x \\times N_y$ cells, the computational cell dimensions are $\\Delta \\xi = 1/N_x$ and $\\Delta \\eta = 1/N_y$.\n\n$2$. **Reference Face-Normal Velocity ($u_{\\text{ref},f}$)**: This is the 'true' velocity, derived from the exact analytic pressure field, $p(x,y)$. It is computed by projecting the analytic pressure gradient, $\\nabla p$, evaluated at the physical face center $(x_f, y_f)$, onto the face's unit normal vector, $\\boldsymbol{n}_f$.\n$$\nu_{\\text{ref},f} = -\\nabla p(x_f, y_f) \\cdot \\boldsymbol{n}_f\n$$\nThe unit normal vectors for vertical ($\\boldsymbol{n}_v$) and horizontal ($\\boldsymbol{n}_h$) faces are given as $\\boldsymbol{n}_v = (1, -\\alpha)/\\sqrt{1+\\alpha^2}$ and $\\boldsymbol{n}_h = (0, 1)$, respectively.\n\n$3$. **Uncorrected Face-Normal Velocity ($u_{\\text{uncorr},f}$)**: This velocity is calculated using the orthogonal approximation common in finite volume solvers. It approximates the normal pressure gradient using only the pressure difference, $\\Delta p$, between the two cells sharing the face, projected along the line connecting their centers.\n$$\nu_{\\text{uncorr},f} = -g_{\\text{orth},f} = -\\beta_f \\frac{\\Delta p}{|\\boldsymbol{d}|}\n$$\nHere, $\\Delta p$ is the pressure difference between the adjacent cell centers (e.g., $p_E - p_P$ for an east face), $|\\boldsymbol{d}|$ is the distance between these cell centers, and $\\beta_f = \\boldsymbol{n}_f \\cdot \\hat{\\boldsymbol{d}}$ is the cosine of the angle between the face normal $\\boldsymbol{n}_f$ and the unit vector $\\hat{\\boldsymbol{d}}$ connecting the cell centers. The problem provides the necessary geometric factors: $\\beta_f = 1/\\sqrt{1+\\alpha^2}$ for both face types, $|\\boldsymbol{d}_v| = \\Delta \\xi$ for vertical faces, and $|\\boldsymbol{d}_h| = \\Delta \\eta \\sqrt{1+\\alpha^2}$ for horizontal faces.\n\n$4$. **Error Quantification**:\n   - **Mean Absolute Error (MAE)**: The error for a single face is $e_f = u_{\\text{uncorr},f} - u_{\\text{ref},f}$. The MAE is the average of the absolute value of this error, $|e_f|$, over all interior faces of the grid (both vertical and horizontal).\n   $$\n   \\text{MAE} = \\frac{1}{N_{\\text{faces}}} \\sum_{f} |u_{\\text{uncorr},f} - u_{\\text{ref},f}|\n   $$\n   - **Checkerboarding Amplitude ($A$)**: This metric quantifies the high-frequency, cell-to-cell oscillations in the error field, a phenomenon known as checkerboarding, which Rhie-Chow interpolation is designed to suppress. For a sequence of face errors $\\{e_m\\}_{m=0}^{M-1}$ along a grid line, the amplitude is the magnitude of the normalized discrete Fourier component at the Nyquist frequency:\n   $$\n   A = \\left\\lvert \\frac{1}{M} \\sum_{m=0}^{M-1} e_m (-1)^m \\right\\rvert\n   $$\n   This amplitude is calculated for two sequences: the errors on the vertical faces along the central horizontal grid line, and the errors on the horizontal faces along the central vertical grid line. The maximum of these two amplitudes is reported.\n\nThe solution is implemented by iterating through each test case. For each case, we construct the grid, loop through all interior faces, compute $u_{\\text{ref},f}$ and $u_{\\text{uncorr},f}$, and store the resulting error $e_f$. Finally, the MAE and the maximum checkerboarding amplitude $A$ are computed from the collected errors. The procedure is deterministic and yields a unique numerical result for each defined case. Special cases where the grid is orthogonal ($\\alpha=0$) and the pressure field is linear or quadratic serve as analytical checks, as the orthogonal approximation error should be zero, validating the implementation.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational thermal engineering problem for all specified test cases.\n    \"\"\"\n\n    def p1(x, y):\n        return np.sin(2 * np.pi * x) * np.sin(2 * np.pi * y)\n\n    def grad_p1(x, y):\n        val_x = 2 * np.pi * np.cos(2 * np.pi * x) * np.sin(2 * np.pi * y)\n        val_y = 2 * np.pi * np.sin(2 * np.pi * x) * np.cos(2 * np.pi * y)\n        return np.array([val_x, val_y])\n\n    def p2(x, y):\n        return x + 2 * y\n\n    def grad_p2(x, y):\n        return np.array([1.0, 2.0])\n\n    def p3(x, y):\n        return x**2 + y**2\n\n    def grad_p3(x, y):\n        return np.array([2 * x, 2 * y])\n\n    test_cases = [\n        {'Nx': 32, 'Ny': 32, 'alpha': 0.3, 'p_func': p1, 'grad_p_func': grad_p1},\n        {'Nx': 32, 'Ny': 32, 'alpha': 0.0, 'p_func': p2, 'grad_p_func': grad_p2},\n        {'Nx': 32, 'Ny': 32, 'alpha': 1.0, 'p_func': p1, 'grad_p_func': grad_p1},\n        {'Nx': 8, 'Ny': 8, 'alpha': 0.5, 'p_func': p3, 'grad_p_func': grad_p3},\n        {'Nx': 8, 'Ny': 8, 'alpha': 0.0, 'p_func': p3, 'grad_p_func': grad_p3},\n    ]\n\n    def compute_metrics_for_case(Nx, Ny, alpha, p_func, grad_p_func):\n        \"\"\"\n        Computes MAE and checkerboarding amplitude for a single case.\n        \"\"\"\n        delta_xi = 1.0 / Nx\n        delta_eta = 1.0 / Ny\n\n        def map_coords(xi, eta):\n            return xi + alpha * eta, eta\n\n        total_error_sum = 0.0\n        num_faces = 0\n\n        vert_errors_central_row = []\n        horiz_errors_central_col = []\n        \n        # Geometric factors\n        sqrt_1_alpha_sq = np.sqrt(1 + alpha**2)\n        beta = 1.0 / sqrt_1_alpha_sq\n        n_v = np.array([1.0, -alpha]) / sqrt_1_alpha_sq\n        n_h = np.array([0.0, 1.0])\n        d_v_mag = delta_xi\n        d_h_mag = delta_eta * sqrt_1_alpha_sq\n\n        central_row_j_idx = Ny // 2\n        central_col_i_idx = Nx // 2\n\n        # Loop over interior vertical faces\n        for j in range(Ny):\n            for i in range(Nx - 1):\n                eta_j_center = (j + 0.5) * delta_eta\n                xi_p_center = (i + 0.5) * delta_xi\n                xi_e_center = (i + 1.5) * delta_xi\n                xi_f = (i + 1.0) * delta_xi\n\n                x_p, y_p = map_coords(xi_p_center, eta_j_center)\n                x_e, y_e = map_coords(xi_e_center, eta_j_center)\n                x_f, y_f = map_coords(xi_f, eta_j_center)\n\n                delta_p = p_func(x_e, y_e) - p_func(x_p, y_p)\n                \n                g_orth = beta * delta_p / d_v_mag\n                g_ref = np.dot(grad_p_func(x_f, y_f), n_v)\n\n                error = g_ref - g_orth  # e_u = u_uncorr - u_ref = -g_orth - (-g_ref) = g_ref - g_orth\n                total_error_sum += np.abs(error)\n                num_faces += 1\n                \n                if j == central_row_j_idx:\n                    vert_errors_central_row.append(error)\n\n        # Loop over interior horizontal faces\n        for j in range(Ny - 1):\n            for i in range(Nx):\n                xi_i_center = (i + 0.5) * delta_xi\n                eta_p_center = (j + 0.5) * delta_eta\n                eta_n_center = (j + 1.5) * delta_eta\n                eta_f = (j + 1.0) * delta_eta\n\n                x_p, y_p = map_coords(xi_i_center, eta_p_center)\n                x_n, y_n = map_coords(xi_i_center, eta_n_center)\n                x_f, y_f = map_coords(xi_i_center, eta_f)\n\n                delta_p = p_func(x_n, y_n) - p_func(x_p, y_p)\n                \n                g_orth = beta * delta_p / d_h_mag\n                g_ref = np.dot(grad_p_func(x_f, y_f), n_h)\n\n                error = g_ref - g_orth\n                total_error_sum += np.abs(error)\n                num_faces += 1\n                \n                if i == central_col_i_idx:\n                    horiz_errors_central_col.append(error)\n\n        mae = total_error_sum / num_faces if num_faces  0 else 0.0\n\n        # Calculate checkerboarding amplitude\n        e_v = np.array(vert_errors_central_row)\n        M_v = len(e_v)\n        amp_v = 0.0\n        if M_v  0:\n            alternating_v = (-1.0)**np.arange(M_v)\n            amp_v = np.abs(np.sum(e_v * alternating_v) / M_v)\n\n        e_h = np.array(horiz_errors_central_col)\n        M_h = len(e_h)\n        amp_h = 0.0\n        if M_h  0:\n            alternating_h = (-1.0)**np.arange(M_h)\n            amp_h = np.abs(np.sum(e_h * alternating_h) / M_h)\n            \n        amplitude = max(amp_v, amp_h)\n        \n        return [mae, amplitude]\n\n    results = []\n    for case in test_cases:\n        result = compute_metrics_for_case(**case)\n        results.append(result)\n    \n    # Format output to match the required specification '[[mae1,amp1],[mae2,amp2],...]'\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n\n```"
        }
    ]
}