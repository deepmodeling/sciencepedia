{
    "hands_on_practices": [
        {
            "introduction": "在有限元分析中，网格质量直接关系到计算结果的物理真实性和数值稳定性。本练习旨在通过等参元法，深入探讨雅可比行列式作为网格质量关键指标的意义。通过本练习，您将理解为何保持雅可比行列式为正值是确保单元体积非负和刚度矩阵正定性的必要条件，并通过一个具体的仿射变换单元，亲手计算一个重要的网格质量度量——缩放雅可比值 ()。",
            "id": "3959412",
            "problem": "考虑三维瞬态热传导方程，其强形式写作 $\\rho c \\frac{\\partial T}{\\partial t} = \\nabla \\cdot (k \\nabla T) + q$，以及使用八节点三线性六面体单元对其进行的等参数有限元离散化。在从参考立方体 $(\\xi,\\eta,\\zeta) \\in [-1,1]^{3}$ 到物理单元的标准等参数映射中，物理坐标 $(x,y,z)$ 由附于八个节点的三线性形函数 $N_{i}(\\xi,\\eta,\\zeta)$ 插值得到。在此映射下，弱形式中的单元级积分通过变量替换进行变换\n$$\n\\int_{\\Omega_{e}} f(\\boldsymbol{x}) \\,\\mathrm{d}\\Omega \\;=\\; \\int_{-1}^{1} \\int_{-1}^{1} \\int_{-1}^{1} f\\big(\\boldsymbol{x}(\\xi,\\eta,\\zeta)\\big)\\,\\det\\big(\\boldsymbol{J}(\\xi,\\eta,\\zeta)\\big)\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta\\,\\mathrm{d}\\zeta,\n$$\n其中 $\\boldsymbol{J}(\\xi,\\eta,\\zeta)$ 是映射的雅可比矩阵，其列为 $\\partial \\boldsymbol{x}/\\partial \\xi$、$\\partial \\boldsymbol{x}/\\partial \\eta$ 和 $\\partial \\boldsymbol{x}/\\partial \\zeta$。在 $[-1,1]$ 上的高斯求积在各高斯积分点上使用正权重。对于一个六面体单元，解释为什么在高斯积分点处 $\\det(\\boldsymbol{J})$ 的符号必须为正，以保持定向并对离散化热传导方程中的单元矩阵产生具有物理意义的贡献。然后，对于下面给出的特定扭曲平行六面体单元，计算在八个 $2\\times 2\\times 2$ 高斯积分点（其坐标为 $\\xi=\\pm 1/\\sqrt{3}$, $\\eta=\\pm 1/\\sqrt{3}$, $\\zeta=\\pm 1/\\sqrt{3}$）上缩放雅可比行列式的最小值，其中某一点的缩放雅可比行列式定义为\n$$\nJ_{s}(\\xi,\\eta,\\zeta) \\;=\\; \\frac{\\det(\\boldsymbol{J}(\\xi,\\eta,\\zeta))}{\\left\\|\\frac{\\partial \\boldsymbol{x}}{\\partial \\xi}(\\xi,\\eta,\\zeta)\\right\\| \\left\\|\\frac{\\partial \\boldsymbol{x}}{\\partial \\eta}(\\xi,\\eta,\\zeta)\\right\\| \\left\\|\\frac{\\partial \\boldsymbol{x}}{\\partial \\zeta}(\\xi,\\eta,\\zeta)\\right\\|}.\n$$\n\n八个物理节点的坐标由一个基点 $\\boldsymbol{a} = (0.1,-0.05,0.02)$ 和三个边向量 $\\boldsymbol{v}_{1}=(2.0,0.2,0.0)$, $\\boldsymbol{v}_{2}=(0.0,1.6,0.1)$, 和 $\\boldsymbol{v}_{3}=(0.3,-0.1,0.9)$ 通过以下方式生成\n$$\n\\boldsymbol{x}(\\xi_{i},\\eta_{i},\\zeta_{i}) \\;=\\; \\boldsymbol{a} \\;+\\; \\frac{\\xi_{i}}{2}\\,\\boldsymbol{v}_{1} \\;+\\; \\frac{\\eta_{i}}{2}\\,\\boldsymbol{v}_{2} \\;+\\; \\frac{\\zeta_{i}}{2}\\,\\boldsymbol{v}_{3},\n$$\n其中 $(\\xi_{i},\\eta_{i},\\zeta_{i})$ 是按照常规六面体节点顺序排列的八个角点参考坐标 $(\\pm 1,\\pm 1,\\pm 1)$。该单元在物理空间中是几何扭曲且非正交的，但仍然是参考立方体的一个仿射图像。\n\n将最终答案表示为无量纲小数，并四舍五入到四位有效数字。",
            "solution": "问题陈述被认定为有效。它在科学上基于有限元方法的原理，信息完备、问题适定，并且语言客观。\n\n该问题包含两部分。第一部分是解释雅可比行列式必须为正的物理和数学必要性。第二部分是为给定单元计算一个特定的网格质量度量。\n\n第一部分：雅可比行列式为正的重要性\n\n等参数映射将物理单元 $\\Omega_e$ 上的积分变换为标准参考单元（一个由 $(\\xi, \\eta, \\zeta) \\in [-1,1]^3$ 定义的立方体）上的积分。积分的变量替换法则是：\n$$\n\\int_{\\Omega_{e}} f(\\boldsymbol{x}) \\,\\mathrm{d}\\Omega = \\int_{-1}^{1} \\int_{-1}^{1} \\int_{-1}^{1} f\\big(\\boldsymbol{x}(\\xi,\\eta,\\zeta)\\big)\\,\\det\\big(\\boldsymbol{J}(\\xi,\\eta,\\zeta)\\big)\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta\\,\\mathrm{d}\\zeta\n$$\n此处，$\\det(\\boldsymbol{J})$ 是变换 $\\boldsymbol{x}(\\xi, \\eta, \\zeta)$ 的雅可比矩阵的行列式。它代表了物理空间中的微分体积元 $\\mathrm{d}\\Omega$ 与参考空间中的微分体积元 $\\mathrm{d}\\xi\\,\\mathrm{d}\\eta\\,\\mathrm{d}\\zeta$ 之间的局部比率。也就是说，$\\mathrm{d}\\Omega = \\det(\\boldsymbol{J})\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta\\,\\mathrm{d}\\zeta$。\n\n$\\det(\\boldsymbol{J})$ 在单元内（特别是在用于数值计算积分的高斯积分点处）必须为正，主要有三个原因：\n\n$1$. 物理体积：物理体积元 $\\mathrm{d}\\Omega$ 必须是一个正量。按照惯例，参考体积元 $\\mathrm{d}\\xi\\,\\mathrm{d}\\eta\\,\\mathrm{d}\\zeta$ 是正的。因此，为使 $\\mathrm{d}\\Omega$ 为正，$\\det(\\boldsymbol{J})$ 必须严格为正。$\\det(\\boldsymbol{J}) = 0$ 意味着单元退化，体积为零，而 $\\det(\\boldsymbol{J})  0$ 意味着单元“缠结”或“内外翻转”，这是非物理的。\n\n$2$. 数学有效性：变量替换定理要求映射 $\\boldsymbol{x}(\\xi, \\eta, \\zeta)$ 是一个微分同胚，这意味着它必须是连续可微的，并且其逆映射也连续可微。一个必要条件是雅可比行列式在定义域内符号不变且非零。一个正的 $\\det(\\boldsymbol{J})$ 确保了映射是一对一且保向的，即参考空间中的右手坐标系映射到物理空间中的右手坐标系。\n\n$3$. 矩阵的数值稳定性与物理意义：单元矩阵，如质量矩阵 $\\boldsymbol{M}_e$ 和刚度矩阵 $\\boldsymbol{K}_e$，是通过高斯求积计算的。高斯求积将积分近似为一个和式：$\\sum_k w_k g(\\xi_k, \\eta_k, \\zeta_k)$，其中 $g$ 是包含 $\\det(\\boldsymbol{J})$ 的完整被积函数，而权重 $w_k$ 总是正的。例如，单元质量矩阵中的一个元素是 $M_{ij} = \\int_{\\Omega_e} \\rho c N_i N_j \\,\\mathrm{d}\\Omega$。当 $i=j$ 时，项 $\\rho c N_i N_j$ 是正的。如果 $\\det(\\boldsymbol{J})$ 在某个积分点为负，那么该点将对总和产生负贡献。这可能导致计算出的质量矩阵非正定，这在物理上是不正确的，因为它可能意味着，例如，一个正的动能可能与一个非物理状态相关联。非正定的质量或刚度矩阵会破坏整个方程组的解。\n\n第二部分：最小缩放雅可比行列式的计算\n\n八节点等参数单元的坐标映射由 $\\boldsymbol{x}(\\xi, \\eta, \\zeta) = \\sum_{i=1}^{8} N_{i}(\\xi,\\eta,\\zeta) \\boldsymbol{x}_{i}$ 给出，其中 $\\boldsymbol{x}_i$ 是节点坐标，而 $N_i$ 是三线性形函数 $N_i(\\xi,\\eta,\\zeta) = \\frac{1}{8}(1+\\xi_i\\xi)(1+\\eta_i\\eta)(1+\\zeta_i\\zeta)$。节点坐标由以下关系指定：\n$$\n\\boldsymbol{x}_{i} = \\boldsymbol{a} + \\frac{\\xi_{i}}{2}\\,\\boldsymbol{v}_{1} + \\frac{\\eta_{i}}{2}\\,\\boldsymbol{v}_{2} + \\frac{\\zeta_{i}}{2}\\,\\boldsymbol{v}_{3}\n$$\n其中 $(\\xi_i, \\eta_i, \\zeta_i)$ 是参考立方体中节点的坐标，即 $(\\pm 1, \\pm 1, \\pm 1)$。将此代入插值公式可得：\n$$\n\\boldsymbol{x}(\\xi, \\eta, \\zeta) = \\sum_{i=1}^{8} N_{i} \\left( \\boldsymbol{a} + \\frac{\\xi_{i}}{2}\\,\\boldsymbol{v}_{1} + \\frac{\\eta_{i}}{2}\\,\\boldsymbol{v}_{2} + \\frac{\\zeta_{i}}{2}\\,\\boldsymbol{v}_{3} \\right) = \\boldsymbol{a}\\sum_{i=1}^{8}N_i + \\frac{\\boldsymbol{v}_1}{2}\\sum_{i=1}^{8}\\xi_i N_i + \\frac{\\boldsymbol{v}_2}{2}\\sum_{i=1}^{8}\\eta_i N_i + \\frac{\\boldsymbol{v}_3}{2}\\sum_{i=1}^{8}\\zeta_i N_i\n$$\n使用三线性形函数的恒等式 $\\sum_i N_i = 1$, $\\sum_i \\xi_i N_i = \\xi$, $\\sum_i \\eta_i N_i = \\eta$, 和 $\\sum_i \\zeta_i N_i = \\zeta$，该映射简化为一个仿射变换：\n$$\n\\boldsymbol{x}(\\xi, \\eta, \\zeta) = \\boldsymbol{a} + \\frac{\\xi}{2}\\,\\boldsymbol{v}_{1} + \\frac{\\eta}{2}\\,\\boldsymbol{v}_{2} + \\frac{\\zeta}{2}\\,\\boldsymbol{v}_{3}\n$$\n雅可比矩阵 $\\boldsymbol{J}$ 的列是 $\\boldsymbol{x}$ 关于 $\\xi$、$\\eta$ 和 $\\zeta$ 的偏导数：\n$$\n\\frac{\\partial \\boldsymbol{x}}{\\partial \\xi} = \\frac{1}{2}\\boldsymbol{v}_{1} = \\frac{1}{2}(2.0, 0.2, 0.0) = (1.0, 0.1, 0.0)\n$$\n$$\n\\frac{\\partial \\boldsymbol{x}}{\\partial \\eta} = \\frac{1}{2}\\boldsymbol{v}_{2} = \\frac{1}{2}(0.0, 1.6, 0.1) = (0.0, 0.8, 0.05)\n$$\n$$\n\\frac{\\partial \\boldsymbol{x}}{\\partial \\zeta} = \\frac{1}{2}\\boldsymbol{v}_{3} = \\frac{1}{2}(0.3, -0.1, 0.9) = (0.15, -0.05, 0.45)\n$$\n由于这些向量是常数，雅可比矩阵 $\\boldsymbol{J}$ 在整个单元中是恒定的。因此，$\\det(\\boldsymbol{J})$ 和缩放雅可比行列式 $J_s$ 也是常数。其最小值就是任意一点的值。\n$$\n\\boldsymbol{J} = \\begin{pmatrix} 1.0  0.0  0.15 \\\\ 0.1  0.8  -0.05 \\\\ 0.0  0.05  0.45 \\end{pmatrix}\n$$\n$\\boldsymbol{J}$ 的行列式为：\n$$\n\\det(\\boldsymbol{J}) = 1.0(0.8 \\cdot 0.45 - (-0.05) \\cdot 0.05) - 0.0(\\ldots) + 0.15(0.1 \\cdot 0.05 - 0.8 \\cdot 0.0)\n$$\n$$\n\\det(\\boldsymbol{J}) = 1.0(0.36 + 0.0025) + 0.15(0.005) = 0.3625 + 0.00075 = 0.36325\n$$\n接下来，我们计算 $\\boldsymbol{J}$ 的列向量的范数：\n$$\n\\left\\|\\frac{\\partial \\boldsymbol{x}}{\\partial \\xi}\\right\\| = \\left\\| \\frac{1}{2}\\boldsymbol{v}_{1} \\right\\| = \\frac{1}{2}\\sqrt{2.0^2 + 0.2^2 + 0.0^2} = \\frac{1}{2}\\sqrt{4.04}\n$$\n$$\n\\left\\|\\frac{\\partial \\boldsymbol{x}}{\\partial \\eta}\\right\\| = \\left\\| \\frac{1}{2}\\boldsymbol{v}_{2} \\right\\| = \\frac{1}{2}\\sqrt{0.0^2 + 1.6^2 + 0.1^2} = \\frac{1}{2}\\sqrt{2.57}\n$$\n$$\n\\left\\|\\frac{\\partial \\boldsymbol{x}}{\\partial \\zeta}\\right\\| = \\left\\| \\frac{1}{2}\\boldsymbol{v}_{3} \\right\\| = \\frac{1}{2}\\sqrt{0.3^2 + (-0.1)^2 + 0.9^2} = \\frac{1}{2}\\sqrt{0.09 + 0.01 + 0.81} = \\frac{1}{2}\\sqrt{0.91}\n$$\n缩放雅可比行列式 $J_s$ 定义为：\n$$\nJ_{s} = \\frac{\\det(\\boldsymbol{J})}{\\left\\|\\frac{\\partial \\boldsymbol{x}}{\\partial \\xi}\\right\\| \\left\\|\\frac{\\partial \\boldsymbol{x}}{\\partial \\eta}\\right\\| \\left\\|\\frac{\\partial \\boldsymbol{x}}{\\partial \\zeta}\\right\\|}\n$$\n代入计算出的值：\n$$\nJ_s = \\frac{0.36325}{\\left(\\frac{1}{2}\\sqrt{4.04}\\right) \\left(\\frac{1}{2}\\sqrt{2.57}\\right) \\left(\\frac{1}{2}\\sqrt{0.91}\\right)} = \\frac{8 \\times 0.36325}{\\sqrt{4.04 \\times 2.57 \\times 0.91}}\n$$\n$$\nJ_s = \\frac{2.906}{\\sqrt{9.448348}} \\approx \\frac{2.906}{3.0738165} \\approx 0.945404\n$$\n由于对于这个仿射单元，$J_s$ 是一个常数，它在所有八个高斯积分点的值都相同，因此这个值也就是最小值。四舍五入到四位有效数字，结果为 $0.9454$。",
            "answer": "$$\n\\boxed{0.9454}\n$$"
        },
        {
            "introduction": "将理论公式转化为可靠的计算机代码是计算工程师的核心技能之一。本练习将引导您实现并验证用于评估网格正交性的角度度量，重点关注有限体积法 (FVM) 中的一个常见计算任务。您将通过对比两种经典的向量夹角计算方法——基于反余弦 (`arccos`) 的方法和更为稳健的基于反正切 (`arctan2`) 的方法——来揭示在处理接近平行或垂直等临界情况时可能出现的数值精度问题，从而掌握编写高质量几何计算程序的关键技巧 ()。",
            "id": "3959477",
            "problem": "您的任务是实现并验证与计算热工学相关的基于角度的网格质量度量，重点关注有限体积 (FV) 方法在扩散问题中使用的网格正交性。考虑一个单位面法向量为 $\\mathbf{n}$ 的面，以及连接相邻单元中心的向量 $\\mathbf{d}$。网格的非正交性可以通过 $\\mathbf{n}$ 和 $\\mathbf{d}$ 之间的夹角 $\\theta$ 来量化，非正交性度量 $\\varphi$ 定义为 $\\varphi = \\lvert \\theta - \\pi/2 \\rvert$。角度必须以弧度表示。\n\n从基本定义出发：\n- 点积 $\\,\\mathbf{a} \\cdot \\mathbf{b} = \\lVert \\mathbf{a} \\rVert \\lVert \\mathbf{b} \\rVert \\cos \\theta\\,$ 将角度 $\\theta$ 与其​​余弦值关联起来。\n- 在三维空间中，叉积的模遵循 $\\,\\lVert \\mathbf{a} \\times \\mathbf{b} \\rVert = \\lVert \\mathbf{a} \\rVert \\lVert \\mathbf{b} \\rVert \\sin \\theta\\,$，而在二维空间中，标量 $\\,a_x b_y - a_y b_x\\,$ 等于其嵌入三维空间后叉积的 z 分量。\n\n您必须：\n1. 使用点积公式计算 $\\theta$：\n   $$\\theta_{\\mathrm{dot}} = \\arccos\\!\\left(\\frac{\\mathbf{n} \\cdot \\mathbf{d}}{\\lVert \\mathbf{n} \\rVert \\lVert \\mathbf{d} \\rVert}\\right),$$\n   在数值处理上要小心，将 $\\arccos$ 的参数限制在区间 $\\left[-1,1\\right]$ 内。\n2. 使用反正切公式计算 $\\theta$：\n   $$\\theta_{\\arctan} = \\arctan2\\!\\left(\\frac{\\lVert \\mathbf{n} \\times \\mathbf{d} \\rVert}{\\lVert \\mathbf{n} \\rVert \\lVert \\mathbf{d} \\rVert},\\,\\frac{\\mathbf{n} \\cdot \\mathbf{d}}{\\lVert \\mathbf{n} \\rVert \\lVert \\mathbf{d} \\rVert}\\right),$$\n   其中对于二维向量，您必须使用 $\\lvert n_x d_y - n_y d_x \\rvert$ 作为分子中嵌入叉积的模。\n3. 根据这两个角度计算非正交性度量 $\\varphi$，即 $\\varphi_{\\mathrm{dot}} = \\lvert \\theta_{\\mathrm{dot}} - \\pi/2 \\rvert$ 和 $\\varphi_{\\arctan} = \\lvert \\theta_{\\arctan} - \\pi/2 \\rvert$。\n4. 通过检查两种公式之间的一致性来验证鲁棒性。对于每个测试用例，输出一个布尔值，表示两个角度是否在指定容差内一致且计算有效。一致性定义为 $\\lvert \\theta_{\\mathrm{dot}} - \\theta_{\\arctan} \\rvert \\le \\varepsilon$，其中 $\\varepsilon = 10^{-12}$。如果 $\\lVert \\mathbf{n} \\rVert = 0$ 或 $\\lVert \\mathbf{d} \\rVert = 0$，则计算无效。\n\n角度单位规范：所有角度必须以弧度计算。\n\n测试套件：\n使用以下代表面法向量和单元中心间向量的向量对 $(\\mathbf{n}, \\mathbf{d})$。每个向量以二维或三维形式提供。所有分量均为无量纲。\n\n- 情况 1：$\\mathbf{n} = (1,0,0)$，$\\mathbf{d} = (0,1,0)$。\n- 情况 2：$\\mathbf{n} = (1,0,0)$，$\\mathbf{d} = (10^{-12},1,0)$。\n- 情况 3：$\\mathbf{n} = (1,0,0)$，$\\mathbf{d} = (10^{3},0,0)$。\n- 情况 4：$\\mathbf{n} = (1,0,0)$，$\\mathbf{d} = (-2,0,0)$。\n- 情况 5：$\\mathbf{n} = (1,0,0)$，$\\mathbf{d} = (0,0,0)$。\n- 情况 6：$\\mathbf{n} = (1,10^{-14},0)$，$\\mathbf{d} = (1,-10^{-14},0)$。\n- 情况 7：$\\mathbf{n} = \\left(\\frac{\\sqrt{2}}{2}, \\frac{\\sqrt{2}}{2}\\right)$，$\\mathbf{d} = \\left(\\frac{\\sqrt{2}}{2}, -\\frac{\\sqrt{2}}{2}\\right)$。\n- 情况 8：$\\mathbf{n} = (1,2,3)$，$\\mathbf{d} = (4,5,6)$。\n\n要求的最终输出格式：\n您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$\\left[\\mathrm{result}_1,\\mathrm{result}_2,\\mathrm{result}_3\\right]$）。每个 $\\mathrm{result}_i$ 必须是对应于情况 $i$ 的布尔值，表示 $\\theta_{\\mathrm{dot}}$ 和 $\\theta_{\\arctan}$ 是否在 $\\varepsilon$ 容差内一致且计算有效。角度计算必须在内部使用弧度。",
            "solution": "该问题要求实现并验证两种计算两个向量 $\\mathbf{n}$ 和 $\\mathbf{d}$ 之间夹角 $\\theta$ 的方法，这是评估诸如有限体积 (FV) 法等计算方法网格质量的一项基本任务。我们关注的质量度量是非正交性，量化为 $\\varphi = \\lvert \\theta - \\pi/2 \\rvert$。题目要求我们使用基于点积的 `arccos` 公式和更鲁棒的 `arctan2` 公式来计算 $\\theta$，然后对一系列测试用例验证它们的一致性。\n\n首先，对问题陈述进行验证。\n**步骤 1：提取给定信息**\n- 向量：一个面法向量 $\\mathbf{n}$ 和一个单元中心连接向量 $\\mathbf{d}$。\n- 角度：$\\theta$ 是 $\\mathbf{n}$ 和 $\\mathbf{d}$ 之间的夹角。\n- 非正交性度量：$\\varphi = \\lvert \\theta - \\pi/2 \\rvert$。\n- 点积定义：$\\mathbf{a} \\cdot \\mathbf{b} = \\lVert \\mathbf{a} \\rVert \\lVert \\mathbf{b} \\rVert \\cos \\theta$。\n- 叉积的模 (3D)：$\\lVert \\mathbf{a} \\times \\mathbf{b} \\rVert = \\lVert \\mathbf{a} \\rVert \\lVert \\mathbf{b} \\rVert \\sin \\theta$。\n- 叉积的模 (2D)：$\\lvert a_x b_y - a_y b_x \\rvert$。\n- 角度公式 1 (点积)：$\\theta_{\\mathrm{dot}} = \\arccos\\!\\left(\\frac{\\mathbf{n} \\cdot \\mathbf{d}}{\\lVert \\mathbf{n} \\rVert \\lVert \\mathbf{d} \\rVert}\\right)$，其参数被限制在 $[-1, 1]$ 内。\n- 角度公式 2 (反正切)：$\\theta_{\\arctan} = \\arctan2\\!\\left(\\frac{\\lVert \\mathbf{n} \\times \\mathbf{d} \\rVert}{\\lVert \\mathbf{n} \\rVert \\lVert \\mathbf{d} \\rVert},\\,\\frac{\\mathbf{n} \\cdot \\mathbf{d}}{\\lVert \\mathbf{n} \\rVert \\lVert \\mathbf{d} \\rVert}\\right)$，对于二维向量使用二维叉积的模。\n- 验证标准：\n    1. 如果 $\\lVert \\mathbf{n} \\rVert = 0$ 或 $\\lVert \\mathbf{d} \\rVert = 0$，则计算无效。\n    2. 一致性定义为 $\\lvert \\theta_{\\mathrm{dot}} - \\theta_{\\arctan} \\rvert \\le \\varepsilon$，容差 $\\varepsilon = 10^{-12}$。\n- 单位：所有角度均为弧度。\n- 测试用例：提供了八组 $(\\mathbf{n}, \\mathbf{d})$ 向量对。\n\n**步骤 2：使用提取的给定信息进行验证**\n该问题具有科学依据、是适定的且客观的。它基于向量代数的基本原理及其在计算工程中的标准应用。指令精确，提供了必要的数据和公式，任务是实现一个确定性算法。问题描述中将 $\\mathbf{n}$ 描述为“单位向量”，而测试用例中它并非单位向量，这个微小的不一致之处无关紧要，因为所提供的公式通过向量的模对其进行了正确的归一化，使其具有普适性。\n\n**步骤 3：结论与行动**\n问题有效。将开发并实现一个解决方案。\n\n**基于原理的设计与实现**\n\n任务的核心是计算两个向量之间夹角 $\\theta \\in [0, \\pi]$。所规定的两种方法为数值稳定性提供了一个比较。\n\n1.  **点积 (`arccos`) 方法**：\n    角度 $\\theta$ 的余弦值由点积定义导出：\n    $$ \\cos\\theta = \\frac{\\mathbf{n} \\cdot \\mathbf{d}}{\\lVert \\mathbf{n} \\rVert \\lVert \\mathbf{d} \\rVert} $$\n    然后通过取反余弦来求得角度：$\\theta_{\\mathrm{dot}} = \\arccos(\\cos\\theta)$。当 $\\mathbf{n}$ 和 $\\mathbf{d}$ 近似共线（平行或反平行）时，会出现一个关键的数值问题。在这种情况下，$\\cos\\theta$ 非常接近 $1$ 或 $-1$。由于有限精度浮点运算，计算出的值可能会略微超出 `arccos` 函数的有效定义域 $[-1, 1]$，从而导致定义域错误。问题正确地要求将 `arccos` 的参数限制在 $[-1, 1]$ 内以防止这种情况发生。\n\n2.  **反正切 (`arctan2`) 方法**：\n    `arctan2(y, x)` 函数计算正 x 轴与点 $(x, y)$ 之间的夹角（以弧度为单位）。它优于 $\\arctan(y/x)$，因为它利用两个参数的符号来确定正确的象限，从而产生一个在 $(-\\pi, \\pi]$ 范围内的结果。通过为其提供与 $\\sin\\theta$ 和 $\\cos\\theta$ 成比例的参数，我们可以鲁棒地确定 $\\theta$。\n    所需的参数是：\n    - $x \\propto \\cos\\theta = \\frac{\\mathbf{n} \\cdot \\mathbf{d}}{\\lVert \\mathbf{n} \\rVert \\lVert \\mathbf{d} \\rVert}$\n    - $y \\propto \\sin\\theta = \\frac{\\lVert \\mathbf{n} \\times \\mathbf{d} \\rVert}{\\lVert \\mathbf{n} \\rVert \\lVert \\mathbf{d} \\rVert}$\n    叉积的模给出 $\\lVert \\mathbf{a} \\rVert \\lVert \\mathbf{b} \\rVert \\sin\\theta$。因为 $\\theta \\in [0, \\pi]$（`arccos` 的值域），所以 $\\sin\\theta \\ge 0$，因此我们直接使用模。对于二维向量 $\\mathbf{n} = (n_x, n_y)$ 和 $\\mathbf{d} = (d_x, d_y)$，等效三维叉积的模是 $\\lvert n_x d_y - n_y d_x \\rvert$。\n    因此，$\\theta_{\\arctan}$ 按规定计算。这种方法通常比 `arccos` 方法更稳定，尤其是在处理小角度时。\n\n**算法流程**\n对于每个测试用例 $(\\mathbf{n}, \\mathbf{d})$：\n1.  将向量表示为数值数组。\n2.  计算欧几里得范数（模）$\\lVert \\mathbf{n} \\rVert$ 和 $\\lVert \\mathbf{d} \\rVert$。\n3.  检查无效条件：如果任一范数为零，则该情况的结果为 `False`。\n4.  如果范数非零，则继续。计算范数之积 $\\lVert \\mathbf{n} \\rVert \\lVert \\mathbf{d} \\rVert$。\n5.  计算点积 $\\mathbf{n} \\cdot \\mathbf{d}$。\n6.  计算 $\\cos\\theta = (\\mathbf{n} \\cdot \\mathbf{d}) / (\\lVert \\mathbf{n} \\rVert \\lVert \\mathbf{d} \\rVert)$。\n7.  将 $\\cos\\theta$ 限制在区间 $[-1.0, 1.0]$ 内后，取其 `arccos` 计算 $\\theta_{\\mathrm{dot}}$。\n8.  计算叉积的模。这需要检查向量的维度。\n    - 如果是三维，计算 $\\lVert \\mathbf{n} \\times \\mathbf{d} \\rVert$。\n    - 如果是二维，计算 $\\lvert n_x d_y - n_y d_x \\rvert$。\n9.  计算与 $\\sin\\theta$ 成比例的值：$\\lVert \\mathbf{n} \\times \\mathbf{d} \\rVert / (\\lVert \\mathbf{n} \\rVert \\lVert \\mathbf{d} \\rVert)$。\n10. 使用 `arctan2` 函数，以正弦和余弦分量为参数，计算 $\\theta_{\\arctan}$。\n11. 比较两个角度：确定是否 $\\lvert \\theta_{\\mathrm{dot}} - \\theta_{\\arctan} \\rvert \\le 10^{-12}$。此布尔值是该用例的结果。\n12. 收集所有用例的布尔结果，并将其格式化为要求的输出字符串。\n\n该逻辑使用 Python 的 `numpy` 库实现，因为它提供了高效且可靠的向量运算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the grid quality metric validation problem for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Orthogonal vectors\n        ((1, 0, 0), (0, 1, 0)),\n        # Case 2: Nearly orthogonal vectors\n        ((1, 0, 0), (1e-12, 1, 0)),\n        # Case 3: Parallel vectors\n        ((1, 0, 0), (1e3, 0, 0)),\n        # Case 4: Anti-parallel vectors\n        ((1, 0, 0), (-2, 0, 0)),\n        # Case 5: Zero vector, invalid computation\n        ((1, 0, 0), (0, 0, 0)),\n        # Case 6: Nearly parallel vectors, testing precision\n        ((1, 1e-14, 0), (1, -1e-14, 0)),\n        # Case 7: 2D orthogonal vectors\n        ((np.sqrt(2)/2, np.sqrt(2)/2), (np.sqrt(2)/2, -np.sqrt(2)/2)),\n        # Case 8: General 3D vectors\n        ((1, 2, 3), (4, 5, 6)),\n    ]\n\n    def compute_angle_agreement(n_tuple, d_tuple):\n        \"\"\"\n        Computes the angle between two vectors using two methods and checks agreement.\n\n        Args:\n            n_tuple: A tuple representing vector n.\n            d_tuple: A tuple representing vector d.\n\n        Returns:\n            A boolean indicating if the computation is valid and the two angle\n            calculations agree within the tolerance.\n        \"\"\"\n        n = np.array(n_tuple, dtype=np.float64)\n        d = np.array(d_tuple, dtype=np.float64)\n\n        # Calculate norms and check for invalidity (zero vector)\n        norm_n = np.linalg.norm(n)\n        norm_d = np.linalg.norm(d)\n        \n        if norm_n == 0 or norm_d == 0:\n            return False\n\n        norm_prod = norm_n * norm_d\n        \n        # --- Dot-product (arccos) method ---\n        dot_nd = np.dot(n, d)\n        cos_theta = dot_nd / norm_prod\n        \n        # Clamp argument to arccos to handle potential floating point inaccuracies\n        cos_theta_clamped = np.clip(cos_theta, -1.0, 1.0)\n        theta_dot = np.arccos(cos_theta_clamped)\n\n        # --- Arctangent (arctan2) method ---\n        # Calculate magnitude of cross product based on dimension\n        if n.size == 3:\n            # 3D case\n            norm_cross_nd = np.linalg.norm(np.cross(n, d))\n        elif n.size == 2:\n            # 2D case as specified\n            norm_cross_nd = np.abs(n[0] * d[1] - n[1] * d[0])\n        else:\n            # Should not happen with given test cases\n            return False\n\n        sin_theta_component = norm_cross_nd / norm_prod\n        \n        # arctan2(y, x), where y ~ sin(theta) and x ~ cos(theta)\n        # This correctly computes the angle in [0, pi], matching arccos range\n        theta_arctan = np.arctan2(sin_theta_component, cos_theta)\n        \n        # --- Validation check ---\n        epsilon = 1e-12\n        agreement = np.abs(theta_dot - theta_arctan) = epsilon\n        \n        return agreement\n\n    results = []\n    for case in test_cases:\n        n_vec, d_vec = case\n        result = compute_angle_agreement(n_vec, d_vec)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "网格质量对模拟精度的影响究竟有多大？本练习将指导您使用“制造解方法”(Method of Manufactured Solutions, MMS) 这一强大的代码验证技术，来定量地评估网格非正交性所引入的数值误差。您将为一个具有已知精确解的二维热传导问题构建一个可控的非正交剪切网格，并计算一个简化的通量近似方案所产生的误差 ()。这个实践将清晰地揭示，随着网格质量的下降，仿真结果的准确性会如何受到影响。",
            "id": "3959445",
            "problem": "你的任务是构建一个人工解基准问题，以量化在使用有限体积法 (FVM) 求解稳态、常物性热传导问题时，网格非正交性对交界面法向热通量误差的影响。其控制物理原理是傅里叶热传导定律和散度定理。人工温度场定义在一个二维域上，并在一个逻辑矩形网格的单元中心进行采样，该网格经过剪切以产生由一个参数控制的非正交性。你的任务是计算一个忽略了非正交修正的两点法向热通量近似的相对均方根 (RMS) 误差，并将其表示为非正交性参数的函数。\n\n基本原理：\n- 傅里叶热传导定律：热通量矢量由 $\\mathbf{q} = -k \\nabla T$ 给出，其中 $k$ 是恒定的热导率，$T$ 是温度。\n- 散度定理（在其标准的 FVM 应用中）：对于面积矢量为 $\\mathbf{S}$ 的面，通过该面的法向热通量为 $\\Phi = \\mathbf{q} \\cdot \\mathbf{S} = -\\nabla T \\cdot \\mathbf{S}$（当 $k=1$ 时）。面积矢量 $\\mathbf{S}$ 的大小等于面的长度，方向等于控制体面的向外单位法线方向。\n\n几何与非正交网格：\n- 使用一个计算域 $(\\xi,\\eta) \\in [0,1]\\times[0,1]$，以及一个均匀的逻辑矩形网格，其 $N_x \\times N_y$ 个单元中心的坐标为 $(\\xi_i,\\eta_j) = \\big((i+\\tfrac{1}{2})/N_x,\\,(j+\\tfrac{1}{2})/N_y\\big)$，其中整数 $i \\in \\{0,\\dots,N_x-1\\}$ 和 $j \\in \\{0,\\dots,N_y-1\\}$。\n- 通过以下线性剪切将计算域映射到物理坐标：\n$$\nx(\\xi,\\eta) = \\xi + \\tan(\\theta)\\,\\eta,\\quad y(\\xi,\\eta) = \\eta,\n$$\n其中 $\\theta$ 是非正交性参数（角度单位：弧度），$\\tan(\\theta)$ 控制剪切幅度。这种构造确保了计算坐标线之间的夹角与正交性的偏离程度受到 $\\theta$ 的控制。\n\n人工温度场：\n- 定义无量纲温度场\n$$\nT(x,y) = \\sin\\!\\big(2\\pi x\\big)\\,\\sin\\!\\big(2\\pi y\\big).\n$$\n这给出了一个精确已知的梯度\n$$\n\\nabla T(x,y) = \\left( 2\\pi\\cos\\!\\big(2\\pi x\\big)\\,\\sin\\!\\big(2\\pi y\\big),\\; 2\\pi\\sin\\!\\big(2\\pi x\\big)\\,\\cos\\!\\big(2\\pi y\\big) \\right),\n$$\n该梯度必须在物理空间中的面中心进行计算。\n\n待量化的离散化误差：\n- 只考虑内部面。对于由一对相邻控制体（中心为 $\\mathbf{x}_P$ 和 $\\mathbf{x}_N$）共享的每个内部面 $f$，定义：\n  - 中心到中心向量 $\\mathbf{d}_f = \\mathbf{x}_N - \\mathbf{x}_P$。\n  - 面面积向量 $\\mathbf{S}_f$，其大小等于面长度，方向为从所属单元 $P$ 向外的法线方向；对于直面，$\\mathbf{S}_f$ 垂直于面的切线，并由映射计算得出。\n  - 精确的面法向热通量 $\\Phi_f^{\\text{exact}} = -\\nabla T(\\mathbf{x}_f)\\cdot \\mathbf{S}_f$，其中 $\\mathbf{x}_f$ 是通过映射相应的计算面中心得到的物理面中心点。\n  - 忽略非正交修正的两点通量近似，定义为中心到中心方向导数在面面积向量上的投影，由两个相邻单元中心的值 $T(\\mathbf{x}_P)$ 和 $T(\\mathbf{x}_N)$ 以及几何信息 $(\\mathbf{d}_f,\\mathbf{S}_f)$ 构建。使用 $k=1$ 和无量纲单位。\n- 将这些面的差异聚合起来，形成一个在所有内部面上的无量纲相对 RMS 误差，\n$$\n\\mathcal{E}_{\\text{rel}} = \\sqrt{\\frac{\\sum_f \\big(\\Phi_f^{\\text{tpf}} - \\Phi_f^{\\text{exact}}\\big)^2}{\\sum_f \\big(\\Phi_f^{\\text{exact}}\\big)^2}},\n$$\n其中 $\\Phi_f^{\\text{tpf}}$ 是面 $f$ 的两点通量近似。\n\n角度单位和物理单位：\n- 角度 $\\theta$ 必须以弧度为单位指定。\n- 所有量都是无量纲的；不需要进行物理单位转换。\n\n测试套件：\n- 使用 $N_x=N_y=N$ 的方形网格和以下 $(N,\\theta)$ 对：\n  - 情况 1：$N=16$, $\\theta=0.0$。\n  - 情况 2：$N=16$, $\\theta=0.2$。\n  - 情况 3：$N=16$, $\\theta=0.5$。\n  - 情况 4：$N=32$, $\\theta=0.5$。\n  - 情况 5：$N=16$, $\\theta=0.7$。\n\n程序要求：\n- 按照规定实现几何和人工场。\n- 对于每个测试用例，使用两个面族的所有内部面计算 $\\mathcal{E}_{\\text{rel}}$。\n- 你的程序应生成单行输出，其中包含结果，形式为逗号分隔的浮点数列表，精确到 $8$ 位小数，并用方括号括起来（例如，$\\big[$$0.01234567$$,$$0.00123456$$\\big]$）。顺序必须与上面列出的情况 1 到 5 匹配。",
            "solution": "该问题陈述已经过严格验证，被认为是可靠、适定且具有科学依据的。它提出了计算传热学中的一个明确任务：量化在非正交网格上，有限体积法 (FVM) 中一种常见简化所引入的误差。我们将着手提供一个完整的解决方案。\n\n问题的核心是计算一个相对均方根 (RMS) 误差 $\\mathcal{E}_{\\text{rel}}$，该误差在一个剪切计算网格的内部面上比较了精确的解析热通量与简化的数值近似。此分析是针对一个稳态热传导问题进行的，该问题由傅里叶定律 $\\mathbf{q} = -k \\nabla T$ 控制，在一个二维域上具有一个已知的（或“人工的”）温度场。对于此问题，热导率 $k$ 取为 1，所有量均为无量纲。\n\n人工温度场由下式给出：\n$$\nT(x,y) = \\sin(2\\pi x) \\sin(2\\pi y)\n$$\n因此，该场的解析梯度为：\n$$\n\\nabla T(x,y) = \\begin{pmatrix} 2\\pi\\cos(2\\pi x)\\sin(2\\pi y) \\\\ 2\\pi\\sin(2\\pi x)\\cos(2\\pi y) \\end{pmatrix}\n$$\n\n计算网格是一个在单位正方形 $(\\xi, \\eta) \\in [0,1] \\times [0,1]$ 上定义的 $N_x \\times N_y$ 个单元的逻辑矩形网格。一个线性剪切映射将这些计算坐标转换为物理坐标 $(x,y)$：\n$$\nx(\\xi,\\eta) = \\xi + \\tan(\\theta)\\eta\n$$\n$$\ny(\\xi,\\eta) = \\eta\n$$\n其中 $\\theta$ 是以弧度为单位的剪切角。这个变换将常数 $\\eta$ 线映射到物理域中的水平线，而常数 $\\xi$ 线则被映射到斜率为 $1/\\tan(\\theta)$ 的线。因此，物理网格线之间的夹角为 $90^\\circ - \\theta$。\n\n我们的步骤如下：\n1.  根据参数 $N_x$、$N_y$ 和 $\\theta$ 定义网格几何。\n2.  遍历网格的所有内部面。\n3.  对于每个面，计算精确热通量 $\\Phi_f^{\\text{exact}}$ 和近似的两点热通量 $\\Phi_f^{\\text{tpf}}$。\n4.  汇总平方差以计算最终的相对 RMS 误差 $\\mathcal{E}_{\\text{rel}}$。\n\n**1. 网格几何**\n\n一个索引为 $i \\in \\{0, \\dots, N_x-1\\}$ 和 $j \\in \\{0, \\dots, N_y-1\\}$ 的单元 $(i, j)$，其中心位于计算坐标 $(\\xi_c, \\eta_c)$：\n$$\n\\xi_c = \\frac{i+0.5}{N_x}, \\quad \\eta_c = \\frac{j+0.5}{N_y}\n$$\n这些坐标通过剪切变换映射到物理坐标 $(x_c, y_c)$。\n\n一个内部面被两个相邻单元共享。我们考虑两族面：\n-   **$\\xi$-面：** 位于常数 $\\xi$ 处，分隔单元 $(i,j)$ 和 $(i+1,j)$ 的面。它们的计算中心位于 $(\\xi_f, \\eta_f) = (\\frac{i+1}{N_x}, \\frac{j+0.5}{N_y})$。\n-   **$\\eta$-面：** 位于常数 $\\eta$ 处，分隔单元 $(i,j)$ 和 $(i,j+1)$ 的面。它们的计算中心位于 $(\\xi_f, \\eta_f) = (\\frac{i+0.5}{N_x}, \\frac{j+1}{N_y})$。\n\n面面积向量 $\\mathbf{S}_f$ 至关重要。其大小是面长，方向是从指定的“所属”单元 $P$ 指向外部的法线方向。对于线性映射，这些向量对于每个面族都是恒定的。使用从映射雅可比矩阵派生的标准 FVM 定义，单元宽度为 $\\Delta\\xi = 1/N_x$ 和 $\\Delta\\eta = 1/N_y$：\n-   对于一个 $\\xi$-面（例如，单元的东面），面积向量为 $\\mathbf{S}_{\\xi} = (\\Delta\\eta, -\\tan(\\theta)\\Delta\\eta)$。\n-   对于一个 $\\eta$-面（例如，单元的北面），面积向量为 $\\mathbf{S}_{\\eta} = (0, \\Delta\\xi)$。\n\n**2. 单个面的通量计算**\n\n对于分隔所属单元 $P$ 和相邻单元 $N$ 的每个内部面 $f$，我们执行以下计算。\n\n**精确通量 $\\Phi_f^{\\text{exact}}$:**\n通过该面的精确热通量由面中心处的热通量向量 $\\mathbf{q}(\\mathbf{x}_f) = -\\nabla T(\\mathbf{x}_f)$ 和面面积向量 $\\mathbf{S}_f$ 的点积给出。\n$$\n\\Phi_f^{\\text{exact}} = \\mathbf{q}(\\mathbf{x}_f) \\cdot \\mathbf{S}_f = - \\nabla T(\\mathbf{x}_f) \\cdot \\mathbf{S}_f\n$$\n这里，$\\mathbf{x}_f$ 是面中心的物理坐标，$\\nabla T(\\mathbf{x}_f)$ 是在该点计算的精确梯度。\n\n**近似两点通量 $\\Phi_f^{\\text{tpf}}$:**\n该通量近似仅使用两个相邻单元中心处的温度值 $T_P = T(\\mathbf{x}_P)$ 和 $T_N = T(\\mathbf{x}_N)$，以及几何向量 $\\mathbf{d}_f = \\mathbf{x}_N - \\mathbf{x}_P$ 和 $\\mathbf{S}_f$ 来构建。梯度沿连接单元中心的线近似：\n$$\n\\nabla T_f^{\\text{approx}} = \\frac{T_N - T_P}{|\\mathbf{d}_f|^2} \\mathbf{d}_f\n$$\n相应的近似热通量向量为 $\\mathbf{q}_f^{\\text{tpf}} = - \\nabla T_f^{\\text{approx}}$。通过该面的通量则为：\n$$\n\\Phi_f^{\\text{tpf}} = \\mathbf{q}_f^{\\text{tpf}} \\cdot \\mathbf{S}_f = - \\left( \\frac{T_N - T_P}{|\\mathbf{d}_f|^2} \\mathbf{d}_f \\right) \\cdot \\mathbf{S}_f = - (T_N - T_P) \\frac{\\mathbf{d}_f \\cdot \\mathbf{S}_f}{|\\mathbf{d}_f|^2}\n$$\n这个公式正确地捕捉了一个“忽略非正交修正”的简单 FVM 方案的本质。误差的产生是因为对于非正交网格（$\\theta \\neq 0$），单元中心连接向量 $\\mathbf{d}_f$ 通常不与面法向量（嵌入在 $\\mathbf{S}_f$ 中）平行。\n\n**3. 汇总与误差计算**\n\n我们遍历所有内部面，对误差的平方和精确通量的平方进行求和：\n-   误差平方和：$\\sum_f_ \\text{err} = \\sum_{f} \\left(\\Phi_f^{\\text{tpf}} - \\Phi_f^{\\text{exact}}\\right)^2$\n-   精确通量平方和：$\\sum_f_ \\text{exact} = \\sum_{f} \\left(\\Phi_f^{\\text{exact}}\\right)^2$\n\n求和遍及所有内部 $\\xi$-面和 $\\eta$-面。最终的相对 RMS 误差为：\n$$\n\\mathcal{E}_{\\text{rel}} = \\sqrt{\\frac{\\sum_f_ \\text{err}}{\\sum_f_ \\text{exact}}}\n$$\n\n实现将包括一个以 $N$ 和 $\\theta$ 为输入的函数。在此函数内部，我们将对两个面族的内部面索引进行循环，计算几何属性，为每个面评估两种通量，并累加计算 $\\mathcal{E}_{\\text{rel}}$ 所需的和。对问题陈述中提供的每个测试用例重复此过程。\n\n对于正交情况（$\\theta=0$），对于两个面族，向量 $\\mathbf{d}_f$ 都与 $\\mathbf{S}_f$ 平行。此时 $\\Phi_f^{\\text{tpf}}$ 中的主要误差是使用中心差分 $(T_N - T_P)/|\\mathbf{d}_f|$ 近似导数 $\\partial T/\\partial n$ 所产生的截断误差。该误差是二阶的，O($\\Delta x^2$)，应该很小。对于非正交情况（$\\theta \\neq 0$），由 $\\mathbf{d}_f$ 和 $\\mathbf{S}_f$ 未对齐引起的几何误差会引入一个一阶误差，O($\\Delta x$)，这将占主导地位。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_relative_rms_error(N, theta_rad):\n    \"\"\"\n    Computes the relative RMS error for a given grid size and non-orthogonality angle.\n\n    Args:\n        N (int): The number of cells in each direction (Nx=Ny=N).\n        theta_rad (float): The non-orthogonality angle in radians.\n\n    Returns:\n        float: The calculated relative RMS error.\n    \"\"\"\n    N_x, N_y = N, N\n    delta_xi = 1.0 / N_x\n    delta_eta = 1.0 / N_y\n    tan_theta = np.tan(theta_rad)\n\n    # --- Manufactured Solution Functions ---\n    def T_func(x, y):\n        return np.sin(2 * np.pi * x) * np.sin(2 * np.pi * y)\n\n    def grad_T_func(x, y):\n        grad_x = 2 * np.pi * np.cos(2 * np.pi * x) * np.sin(2 * np.pi * y)\n        grad_y = 2 * np.pi * np.sin(2 * np.pi * x) * np.cos(2 * np.pi * y)\n        return np.array([grad_x, grad_y])\n\n    def map_to_physical(xi, eta):\n        x = xi + tan_theta * eta\n        y = eta\n        return np.array([x, y])\n\n    sum_sq_error = 0.0\n    sum_sq_exact = 0.0\n\n    # --- Process interior xi-faces (vertical faces) ---\n    S_xi = np.array([delta_eta, -tan_theta * delta_eta])\n    for i in range(N_x - 1):\n        for j in range(N_y):\n            # Cell P (owner) and N (neighbor) computational centers\n            xi_P, eta_P = (i + 0.5) * delta_xi, (j + 0.5) * delta_eta\n            xi_N, eta_N = (i + 1.5) * delta_xi, (j + 0.5) * delta_eta\n            \n            # Face computational center\n            xi_f, eta_f = (i + 1.0) * delta_xi, (j + 0.5) * delta_eta\n\n            # Map to physical coordinates\n            x_P = map_to_physical(xi_P, eta_P)\n            x_N = map_to_physical(xi_N, eta_N)\n            x_f = map_to_physical(xi_f, eta_f)\n            \n            # Geometric vectors\n            d_f = x_N - x_P\n            \n            # Calculate fluxes\n            T_P = T_func(x_P[0], x_P[1])\n            T_N = T_func(x_N[0], x_N[1])\n            \n            d_f_dot_S_f = np.dot(d_f, S_xi)\n            d_f_dot_d_f = np.dot(d_f, d_f)\n            \n            # Note: k=1 is assumed\n            phi_tpf = -(T_N - T_P) * d_f_dot_S_f / d_f_dot_d_f\n            \n            grad_T_at_f = grad_T_func(x_f[0], x_f[1])\n            phi_exact = -np.dot(grad_T_at_f, S_xi)\n            \n            # Accumulate sums\n            sum_sq_error += (phi_tpf - phi_exact)**2\n            sum_sq_exact += phi_exact**2\n\n    # --- Process interior eta-faces (horizontal faces) ---\n    S_eta = np.array([0.0, delta_xi])\n    for i in range(N_x):\n        for j in range(N_y - 1):\n            # Cell P (owner) and N (neighbor) computational centers\n            xi_P, eta_P = (i + 0.5) * delta_xi, (j + 0.5) * delta_eta\n            xi_N, eta_N = (i + 0.5) * delta_xi, (j + 1.5) * delta_eta\n            \n            # Face computational center\n            xi_f, eta_f = (i + 0.5) * delta_xi, (j + 1.0) * delta_eta\n\n            # Map to physical coordinates\n            x_P = map_to_physical(xi_P, eta_P)\n            x_N = map_to_physical(xi_N, eta_N)\n            x_f = map_to_physical(xi_f, eta_f)\n            \n            # Geometric vectors\n            d_f = x_N - x_P\n\n            # Calculate fluxes\n            T_P = T_func(x_P[0], x_P[1])\n            T_N = T_func(x_N[0], x_N[1])\n\n            d_f_dot_S_f = np.dot(d_f, S_eta)\n            d_f_dot_d_f = np.dot(d_f, d_f)\n\n            phi_tpf = -(T_N - T_P) * d_f_dot_S_f / d_f_dot_d_f\n            \n            grad_T_at_f = grad_T_func(x_f[0], x_f[1])\n            phi_exact = -np.dot(grad_T_at_f, S_eta)\n            \n            # Accumulate sums\n            sum_sq_error += (phi_tpf - phi_exact)**2\n            sum_sq_exact += phi_exact**2\n\n    if sum_sq_exact == 0.0:\n        return 0.0 # Or handle as an error, but unlikely for this problem\n\n    return np.sqrt(sum_sq_error / sum_sq_exact)\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        (16, 0.0),  # Case 1\n        (16, 0.2),  # Case 2\n        (16, 0.5),  # Case 3\n        (32, 0.5),  # Case 4\n        (16, 0.7),  # Case 5\n    ]\n\n    results = []\n    for N, theta_rad in test_cases:\n        error = calculate_relative_rms_error(N, theta_rad)\n        results.append(f\"{error:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}