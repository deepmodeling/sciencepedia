{
    "hands_on_practices": [
        {
            "introduction": "任何基于坐标变换的网格生成方法，其首要任务是确保从计算域到物理域的映射是双射（一对一）的，以避免网格线交叉或折叠，即“网格缠结”。雅可比行列式是检验此映射有效性的核心数学工具，其符号和大小直接反映了局部单元的变形和方向。本练习  将通过一个具体的代数网格变形案例，引导你推导保证映射有效的条件，从而深刻理解网格生成中的数学约束。",
            "id": "3987900",
            "problem": "在计算热工学中，维持计算域与物理域之间的一一映射对于避免传热数值模拟中的网格缠结至关重要。考虑一个用于控制浮力驱动腔流中节点聚类的二维代数网格变形。该变形通过以下方式将计算正方形 $(\\xi,\\eta)\\in [0,1]\\times[0,1]$ 映射到物理平面：\n$$\nx(\\xi,\\eta) = \\xi,\\qquad y(\\xi,\\eta) = \\eta + \\epsilon \\sin(\\pi \\xi)\\sin(\\pi \\eta),\n$$\n其中 $\\epsilon$ 是一个无量纲控制参数。\n\n从平面间映射的雅可比行列式定义和二维双射映射的条件出发，推导该变换的雅可比行列式 $J(\\xi,\\eta;\\epsilon)$ 的显式表达式。利用此表达式确定 $|\\epsilon|$ 的最紧上界，以使映射在整个计算正方形内保持双射，确保在 $[0,1]\\times[0,1]$ 内的任何地方都不会出现网格线交叉。在你的推理中，指明当 $|\\epsilon|$ 趋近其最大允许值时，雅可比行列式趋近于零的 $(\\xi,\\eta)$ 位置，并解释为什么从网格缠结风险的角度来看这些位置是至关重要的。\n\n作为最终答案，仅报告 $\\epsilon$ 的最大允许幅值的符号表达式（用 $\\pi$ 表示）。不要四舍五入。$\\epsilon$ 没有物理单位；它是无量纲的。",
            "solution": "该问题要求推导给定二维映射保持双射的条件，以确保没有网格缠结。这涉及到计算变换的雅可比行列式，并找到参数 $\\epsilon$ 的约束条件，以防止行列式在指定域内变为零或改变符号。\n\n给定的变换根据以下函数将计算坐标 $(\\xi, \\eta)$ 从单位正方形 $[0,1]\\times[0,1]$ 映射到物理坐标 $(x,y)$：\n$$\nx(\\xi,\\eta) = \\xi\n$$\n$$\ny(\\xi,\\eta) = \\eta + \\epsilon \\sin(\\pi \\xi)\\sin(\\pi \\eta)\n$$\n如果一个连续可微的映射的雅可比行列式在域的内部不变号且永不为零，则该映射在该域内保持双射（一对一）。从 $(\\xi, \\eta)$ 到 $(x,y)$ 的变换的雅可比行列式 $J$ 定义为：\n$$\nJ(\\xi,\\eta;\\epsilon) = \\det \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix} = \\frac{\\partial x}{\\partial \\xi}\\frac{\\partial y}{\\partial \\eta} - \\frac{\\partial x}{\\partial \\eta}\\frac{\\partial y}{\\partial \\xi}\n$$\n首先，我们计算变换函数所需的偏导数：\n$$\n\\frac{\\partial x}{\\partial \\xi} = 1\n$$\n$$\n\\frac{\\partial x}{\\partial \\eta} = 0\n$$\n$$\n\\frac{\\partial y}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi} \\left( \\eta + \\epsilon \\sin(\\pi \\xi)\\sin(\\pi \\eta) \\right) = \\epsilon \\pi \\cos(\\pi \\xi)\\sin(\\pi \\eta)\n$$\n$$\n\\frac{\\partial y}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta} \\left( \\eta + \\epsilon \\sin(\\pi \\xi)\\sin(\\pi \\eta) \\right) = 1 + \\epsilon \\pi \\sin(\\pi \\xi)\\cos(\\pi \\eta)\n$$\n将这些导数代入雅可比行列式的公式中，我们得到 $J$ 的显式表达式：\n$$\nJ(\\xi,\\eta;\\epsilon) = (1) \\cdot (1 + \\epsilon \\pi \\sin(\\pi \\xi)\\cos(\\pi \\eta)) - (0) \\cdot (\\epsilon \\pi \\cos(\\pi \\xi)\\sin(\\pi \\eta))\n$$\n$$\nJ(\\xi,\\eta;\\epsilon) = 1 + \\epsilon \\pi \\sin(\\pi \\xi)\\cos(\\pi \\eta)\n$$\n为使变换有效并避免网格缠结，雅可比行列式必须在整个域内保持严格为正，即对于所有的 $(\\xi,\\eta) \\in [0,1]\\times[0,1]$，都有 $J(\\xi,\\eta;\\epsilon) > 0$。$J=0$ 的值表示一个奇异变换，此时网格线会塌陷；而 $J<0$ 则意味着坐标系的局部反转，这两种情况都构成网格缠结。因此，我们必须满足不等式：\n$$\n1 + \\epsilon \\pi \\sin(\\pi \\xi)\\cos(\\pi \\eta) > 0\n$$\n为了找到 $|\\epsilon|$ 的最紧上界，我们必须在域 $(\\xi,\\eta) \\in [0,1]\\times[0,1]$ 上找到项 $A(\\xi,\\eta) = \\sin(\\pi \\xi)\\cos(\\pi \\eta)$ 的最小值和最大值。\n对于 $\\xi \\in [0,1]$，项 $\\sin(\\pi \\xi)$ 始终为非负，范围从 $0$ 到 $1$。其最大值为 $1$，在 $\\xi = 1/2$ 时取得。\n对于 $\\eta \\in [0,1]$，项 $\\cos(\\pi \\eta)$ 的范围从 $1$（在 $\\eta=0$ 时）到 $-1$（在 $\\eta=1$ 时）。\n\n$A(\\xi,\\eta)$ 的最大值出现在 $\\sin(\\pi \\xi)$ 为最大值且 $\\cos(\\pi \\eta)$ 为最大值时：\n$$\n\\max(A) = \\max(\\sin(\\pi \\xi)) \\cdot \\max(\\cos(\\pi \\eta)) = (1) \\cdot (1) = 1\n$$\n这发生在 $\\xi = 1/2$ 和 $\\eta = 0$ 时，即点 $(1/2, 0)$。\n\n$A(\\xi,\\eta)$ 的最小值出现在 $\\sin(\\pi \\xi)$ 为最大值且 $\\cos(\\pi \\eta)$ 为最小值时：\n$$\n\\min(A) = \\max(\\sin(\\pi \\xi)) \\cdot \\min(\\cos(\\pi \\eta)) = (1) \\cdot (-1) = -1\n$$\n这发生在 $\\xi = 1/2$ 和 $\\eta = 1$ 时，即点 $(1/2, 1)$。\n\n现在我们根据 $\\epsilon$ 的符号来分析不等式 $1 + \\epsilon \\pi A(\\xi,\\eta) > 0$。\n\n情况1：$\\epsilon > 0$。\n项 $\\epsilon \\pi A(\\xi,\\eta)$ 可能为负。不等式必须在最严格的条件下也成立，这对应于 $A(\\xi,\\eta)$ 的最小值 $-1$。\n$$\n1 + \\epsilon \\pi (-1) > 0 \\implies 1 - \\epsilon \\pi > 0 \\implies \\epsilon \\pi < 1 \\implies \\epsilon < \\frac{1}{\\pi}\n$$\n\n情况2：$\\epsilon < 0$。\n项 $\\epsilon \\pi A(\\xi,\\eta)$ 可能为正。不等式必须在最严格的条件下也成立，这对应于 $A(\\xi,\\eta)$ 的最大值 $1$。令 $\\epsilon = -|\\epsilon|$。\n$$\n1 + \\epsilon \\pi (1) > 0 \\implies 1 - |\\epsilon| \\pi > 0 \\implies |\\epsilon| \\pi < 1 \\implies |\\epsilon| < \\frac{1}{\\pi}\n$$\n\n综合两种情况，雅可比行列式在域内处处严格为正的条件是 $|\\epsilon| < 1/\\pi$。$\\epsilon$ 幅值的最紧上界是雅可比行列式首次达到零时的值。这发生在 $|\\epsilon| = 1/\\pi$ 时。因此，$\\epsilon$ 的最大允许幅值为 $1/\\pi$。\n\n当 $|\\epsilon|$ 趋近其最大值 $1/\\pi$ 时，雅可比行列式趋近于零的 $(\\xi,\\eta)$ 位置，是项 $\\sin(\\pi \\xi)\\cos(\\pi \\eta)$ 达到其极值点的地方。\n- 如果 $\\epsilon \\to 1/\\pi$，当 $1 + (1/\\pi)\\pi \\sin(\\pi \\xi)\\cos(\\pi \\eta) = 0$ 时，雅可比行列式变为零，这可以简化为 $\\sin(\\pi \\xi)\\cos(\\pi \\eta) = -1$。这发生在 $(\\xi, \\eta) = (1/2, 1)$。\n- 如果 $\\epsilon \\to -1/\\pi$，当 $1 - (1/\\pi)\\pi \\sin(\\pi \\xi)\\cos(\\pi \\eta) = 0$ 时，雅可比行列式变为零，这可以简化为 $\\sin(\\pi \\xi)\\cos(\\pi \\eta) = 1$。这发生在 $(\\xi, \\eta) = (1/2, 0)$。\n\n从网格缠结的角度来看，这些位置是至关重要的，因为它们是局部映射首次变为奇异的点。在这些点上，$J = \\partial y / \\partial \\eta = 0$。这意味着对于一条 $\\xi$ 恒定的线，物理坐标 $y$ 不再是 $\\eta$ 的单调函数。零导数标志着折叠的开始，此时计算网格中的两个不同点 $(\\xi, \\eta_1)$ 和 $(\\xi, \\eta_2)$ 可能会映射到同一个物理点 $(x,y)$，从而破坏了映射的一对一性质并导致网格缠结。",
            "answer": "$$\\boxed{\\frac{1}{\\pi}}$$"
        },
        {
            "introduction": "跨有限插值（Transfinite Interpolation, TFI）是生成贴体结构化网格的经典而强大的技术，它能够精确匹配任意形状的复杂边界。然而，TFI虽然保证了边界的贴合性，却不自动保证内部网格的高质量，尤其是在边界曲线相交的角点区域，可能会产生显著的网格倾斜。本练习  将指导你从第一性原理出发构建一个TFI映射，并定量分析由于角点切矢不兼容性引入的网格正交性误差，从而建立起生成算法与网格质量度量之间的直接联系。",
            "id": "3987841",
            "problem": "考虑一个从单位正方形 $[0,1] \\times [0,1]$（参数为 $(\\xi,\\eta)$）到一个物理平面域的二维参数化映射，该映射适用于模拟具有轻微变形边界的薄板中的稳态热传导。该映射通过超限插值（TFI），也称为 Coons 曲面，利用四条插值域边缘位置的边界曲线来构建。设四条边界曲线定义如下：\n- 底部边界，位于 $\\eta = 0$ 处：$D_{1}(\\xi) = \\big(\\xi,\\, d\\,\\xi(1-\\xi)\\big)$。\n- 顶部边界，位于 $\\eta = 1$ 处：$D_{2}(\\xi) = \\big(\\xi,\\, 1 + a\\,\\xi(1-\\xi)\\big)$。\n- 左侧边界，位于 $\\xi = 0$ 处：$C_{1}(\\eta) = \\big(b\\,\\eta(1-\\eta),\\, \\eta\\big)$。\n- 右侧边界，位于 $\\xi = 1$ 处：$C_{2}(\\eta) = \\big(1 + c\\,\\eta(1-\\eta),\\, \\eta\\big)$。\n\n这些曲线在四个角点处满足位置相容性，即 $D_{1}(0) = C_{1}(0)$，$D_{1}(1) = C_{2}(0)$，$D_{2}(0) = C_{1}(1)$ 和 $D_{2}(1) = C_{2}(1)$，但它们在角点处的切向量通常不相容（非正交），这可能在角点附近引入网格正交性误差。\n\n从参数化映射和边界插值的基本原理出发，并且不假设任何用于内部构建的快捷公式，推导内部映射 $\\mathbf{X}(\\xi,\\eta) = \\big(x(\\xi,\\eta),\\,y(\\xi,\\eta)\\big)$ 的 TFI 表达式，该表达式插值所有四条边界并一致地恢复四个角点。然后，取网格正交性度量为参数坐标方向之间夹角的余弦，定义为\n$$\nE(\\xi,\\eta) = \\frac{\\big|\\mathbf{X}_{\\xi}(\\xi,\\eta) \\cdot \\mathbf{X}_{\\eta}(\\xi,\\eta)\\big|}{\\|\\mathbf{X}_{\\xi}(\\xi,\\eta)\\|\\,\\|\\mathbf{X}_{\\eta}(\\xi,\\eta)\\|},\n$$\n量化由左下角 $(\\xi,\\eta) = (0,0)$ 处的角点切线不相容性引入的正交性误差。\n\n使用参数值 $a = 0.3$，$b = 0.2$，$c = -0.25$ 和 $d = 0.25$，并将 $E(0,0)$ 作为单个实数进行计算。将您的最终答案表示为无量纲小数，并将结果四舍五入到四位有效数字。",
            "solution": "该问题要求推导超限插值（TFI）映射，并随后计算特定角点处的网格正交性度量。解题过程按规定从基本原理出发。\n\n构建一个二维参数化映射 $\\mathbf{X}(\\xi, \\eta) = (x(\\xi,\\eta), y(\\xi,\\eta))$，将参数域中的单位正方形 $(\\xi, \\eta) \\in [0, 1] \\times [0, 1]$ 映射到物理域。该映射必须插值四条指定的边界曲线：位于 $\\eta=0$ 处的 $D_1(\\xi)$，位于 $\\eta=1$ 处的 $D_2(\\xi)$，位于 $\\xi=0$ 处的 $C_1(\\eta)$，以及位于 $\\xi=1$ 处的 $C_2(\\eta)$。\n\n超限插值或 Coons 曲面，通过投影算子的布尔和来构建内部映射 $\\mathbf{X}(\\xi,\\eta)$。我们定义两个投影算子 $P_\\xi$ 和 $P_\\eta$，它们在成对的曲线之间进行插值。使用线性混合函数 $L_0(\\zeta) = 1-\\zeta$ 和 $L_1(\\zeta) = \\zeta$，投影算子为：\n$$ P_{\\xi}[\\mathbf{X}](\\xi, \\eta) = (1-\\xi)\\mathbf{X}(0, \\eta) + \\xi\\mathbf{X}(1, \\eta) $$\n$$ P_{\\eta}[\\mathbf{X}](\\xi, \\eta) = (1-\\eta)\\mathbf{X}(\\xi, 0) + \\eta\\mathbf{X}(\\xi, 1) $$\n代入边界条件 $\\mathbf{X}(0, \\eta) = C_1(\\eta)$，$\\mathbf{X}(1, \\eta) = C_2(\\eta)$，$\\mathbf{X}(\\xi, 0) = D_1(\\xi)$ 和 $\\mathbf{X}(\\xi, 1) = D_2(\\xi)$，我们得到：\n$$ P_{\\xi}(\\xi, \\eta) = (1-\\xi)C_1(\\eta) + \\xi C_2(\\eta) $$\n$$ P_{\\eta}(\\xi, \\eta) = (1-\\eta)D_1(\\xi) + \\eta D_2(\\xi) $$\nTFI 映射是这些投影算子的布尔和，$\\mathbf{X} = P_\\xi \\oplus P_\\eta$，定义为：\n$$ \\mathbf{X}(\\xi, \\eta) = P_\\xi(\\xi, \\eta) + P_\\eta(\\xi, \\eta) - P_\\xi P_\\eta(\\xi, \\eta) $$\n乘积投影算子 $P_\\xi P_\\eta$ 是通过将 $P_\\xi$ 应用于 $P_\\eta$ 的结果来找到的：\n$$ P_\\xi P_\\eta(\\xi, \\eta) = P_\\xi \\big[ (1-\\eta)D_1(\\xi) + \\eta D_2(\\xi) \\big] = (1-\\xi)\\big[ (1-\\eta)D_1(0) + \\eta D_2(0) \\big] + \\xi\\big[ (1-\\eta)D_1(1) + \\eta D_2(1) \\big] $$\n问题说明边界在角点处是位置相容的，因此我们有：\n$\\mathbf{X}(0,0) = D_1(0) = C_1(0) = (0,0)$\n$\\mathbf{X}(1,0) = D_1(1) = C_2(0) = (1,0)$\n$\\mathbf{X}(0,1) = D_2(0) = C_1(1) = (0,1)$\n$\\mathbf{X}(1,1) = D_2(1) = C_2(1) = (1,1)$\n将这些代入 $P_\\xi P_\\eta$ 的表达式中，得到四个角点的双线性插值：\n$$ P_\\xi P_\\eta(\\xi, \\eta) = (1-\\xi)(1-\\eta)\\mathbf{X}(0,0) + \\xi(1-\\eta)\\mathbf{X}(1,0) + (1-\\xi)\\eta\\mathbf{X}(0,1) + \\xi\\eta\\mathbf{X}(1,1) $$\n因此，完整的 TFI 映射为：\n$$ \\mathbf{X}(\\xi, \\eta) = (1-\\xi)C_1(\\eta) + \\xi C_2(\\eta) + (1-\\eta)D_1(\\xi) + \\eta D_2(\\xi) - \\big[ (1-\\xi)(1-\\eta)\\mathbf{X}(0,0) + \\xi(1-\\eta)\\mathbf{X}(1,0) + (1-\\xi)\\eta\\mathbf{X}(0,1) + \\xi\\eta\\mathbf{X}(1,1) \\big] $$\n现在，我们将给定的边界曲线定义代入此公式。映射 $\\mathbf{X}(\\xi,\\eta)$ 具有分量 $(x(\\xi,\\eta), y(\\xi,\\eta))$。\n对于 $x$ 分量：\n$x_{C1}(\\eta) = b\\eta(1-\\eta)$, $x_{C2}(\\eta) = 1+c\\eta(1-\\eta)$, $x_{D1}(\\xi) = \\xi$, $x_{D2}(\\xi) = \\xi$。\n$x_{00}=0$, $x_{10}=1$, $x_{01}=0$, $x_{11}=1$。\n$$ x(\\xi,\\eta) = (1-\\xi)b\\eta(1-\\eta) + \\xi(1+c\\eta(1-\\eta)) + (1-\\eta)\\xi + \\eta\\xi - \\big[ \\xi(1-\\eta) + \\xi\\eta \\big] $$\n$$ x(\\xi,\\eta) = (1-\\xi)b\\eta(1-\\eta) + \\xi + \\xi c\\eta(1-\\eta) + \\xi - \\xi = \\xi + (1-\\xi)b\\eta(1-\\eta) + \\xi c\\eta(1-\\eta) $$\n对于 $y$ 分量：\n$y_{C1}(\\eta) = \\eta$, $y_{C2}(\\eta) = \\eta$, $y_{D1}(\\xi) = d\\xi(1-\\xi)$, $y_{D2}(\\xi) = 1+a\\xi(1-\\xi)$。\n$y_{00}=0$, $y_{10}=0$, $y_{01}=1$, $y_{11}=1$。\n$$ y(\\xi,\\eta) = (1-\\xi)\\eta + \\xi\\eta + (1-\\eta)d\\xi(1-\\xi) + \\eta(1+a\\xi(1-\\xi)) - \\big[ (1-\\xi)\\eta + \\xi\\eta \\big] $$\n$$ y(\\xi,\\eta) = \\eta + (1-\\eta)d\\xi(1-\\xi) + \\eta + \\eta a\\xi(1-\\xi) - \\eta = \\eta + (1-\\eta)d\\xi(1-\\xi) + \\eta a\\xi(1-\\xi) $$\n接下来，我们计算切向量 $\\mathbf{X}_{\\xi} = \\frac{\\partial \\mathbf{X}}{\\partial \\xi}$ 和 $\\mathbf{X}_{\\eta} = \\frac{\\partial \\mathbf{X}}{\\partial \\eta}$。\n$$ \\frac{\\partial x}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi} \\big[ \\xi + b\\eta(1-\\eta) - \\xi b\\eta(1-\\eta) + \\xi c\\eta(1-\\eta) \\big] = 1 - b\\eta(1-\\eta) + c\\eta(1-\\eta) = 1 + (c-b)\\eta(1-\\eta) $$\n$$ \\frac{\\partial y}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi} \\big[ \\eta + d(1-\\eta)(\\xi-\\xi^2) + a\\eta(\\xi-\\xi^2) \\big] = d(1-\\eta)(1-2\\xi) + a\\eta(1-2\\xi) = (d(1-\\eta)+a\\eta)(1-2\\xi) $$\n$$ \\frac{\\partial x}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta} \\big[ \\xi + b(1-\\xi)(\\eta-\\eta^2) + c\\xi(\\eta-\\eta^2) \\big] = b(1-\\xi)(1-2\\eta) + c\\xi(1-2\\eta) = (b(1-\\xi)+c\\xi)(1-2\\eta) $$\n$$ \\frac{\\partial y}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta} \\big[ \\eta + d\\xi(1-\\xi) - \\eta d\\xi(1-\\xi) + \\eta a\\xi(1-\\xi) \\big] = 1 - d\\xi(1-\\xi) + a\\xi(1-\\xi) = 1 + (a-d)\\xi(1-\\xi) $$\n切向量为：\n$$ \\mathbf{X}_{\\xi}(\\xi,\\eta) = \\begin{pmatrix} 1 + (c-b)\\eta(1-\\eta) \\\\ (d(1-\\eta) + a\\eta)(1-2\\xi) \\end{pmatrix}, \\quad \\mathbf{X}_{\\eta}(\\xi,\\eta) = \\begin{pmatrix} (b(1-\\xi) + c\\xi)(1-2\\eta) \\\\ 1 + (a-d)\\xi(1-\\xi) \\end{pmatrix} $$\n我们在左下角 $(\\xi,\\eta)=(0,0)$ 处计算这些向量：\n$$ \\mathbf{X}_{\\xi}(0,0) = \\begin{pmatrix} 1 + (c-b)(0) \\\\ (d(1)+a(0))(1) \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ d \\end{pmatrix} $$\n$$ \\mathbf{X}_{\\eta}(0,0) = \\begin{pmatrix} (b(1)+c(0))(1) \\\\ 1+(a-d)(0) \\end{pmatrix} = \\begin{pmatrix} b \\\\ 1 \\end{pmatrix} $$\n正交性度量 $E(\\xi,\\eta)$ 是这些向量之间夹角的余弦。在 $(0,0)$ 处：\n$$ E(0,0) = \\frac{\\big|\\mathbf{X}_{\\xi}(0,0) \\cdot \\mathbf{X}_{\\eta}(0,0)\\big|}{\\|\\mathbf{X}_{\\xi}(0,0)\\|\\,\\|\\mathbf{X}_{\\eta}(0,0)\\|} $$\n我们计算点积和范数：\n$$ \\mathbf{X}_{\\xi}(0,0) \\cdot \\mathbf{X}_{\\eta}(0,0) = \\begin{pmatrix} 1 \\\\ d \\end{pmatrix} \\cdot \\begin{pmatrix} b \\\\ 1 \\end{pmatrix} = 1 \\cdot b + d \\cdot 1 = b+d $$\n$$ \\|\\mathbf{X}_{\\xi}(0,0)\\| = \\sqrt{1^2 + d^2} = \\sqrt{1+d^2} $$\n$$ \\|\\mathbf{X}_{\\eta}(0,0)\\| = \\sqrt{b^2 + 1^2} = \\sqrt{1+b^2} $$\n将这些代入 $E(0,0)$ 的表达式中：\n$$ E(0,0) = \\frac{|b+d|}{\\sqrt{1+d^2}\\sqrt{1+b^2}} $$\n现在，我们代入给定的参数值：$a=0.3$，$b=0.2$，$c=-0.25$ 和 $d=0.25$。请注意，本次特定计算不需要 $a$ 和 $c$。\n$$ b+d = 0.2 + 0.25 = 0.45 $$\n$$ 1+d^2 = 1 + (0.25)^2 = 1 + 0.0625 = 1.0625 $$\n$$ 1+b^2 = 1 + (0.2)^2 = 1 + 0.04 = 1.04 $$\n$$ E(0,0) = \\frac{|0.45|}{\\sqrt{1.0625}\\sqrt{1.04}} = \\frac{0.45}{\\sqrt{1.0625 \\times 1.04}} = \\frac{0.45}{\\sqrt{1.105}} $$\n计算数值：\n$$ E(0,0) \\approx \\frac{0.45}{1.0511898} \\approx 0.4280709... $$\n将结果四舍五入到四位有效数字，我们得到 $0.4281$。",
            "answer": "$$\n\\boxed{0.4281}\n$$"
        },
        {
            "introduction": "对于几何外形极其复杂的区域，非结构化网格因其高度的灵活性而成为首选。不同的生成算法，如Delaunay三角剖分（DT）和推进前沿法（AFM），即便应用于完全相同的节点集，也会因其连接策略的内在差异而产生质量迥异的网格。本实践  是一个编程练习，要求你对同一组节点分别应用这两种主流的三角剖分策略，并使用最小内角这一关键质量度量进行量化比较，从而直观地揭示两种算法在保证单元几何质量方面的优劣。",
            "id": "3987848",
            "problem": "您需要为弯曲边界构建并比较两种平面三角网格，并使用最小角度量来量化三角形质量的差异。背景是计算热工学，其中网格质量影响传热模拟的数值精度和稳定性。这两种网格分别使用 Delaunay 三角剖分 (DT) 和前沿推进法 (AFM) 生成。用于比较的度量是每个三角形的最小内角，以度为单位表示。\n\n从欧几里得几何出发，三角形的内角由其边长和边的点积明确定义。对于 $\\mathbb{R}^2$ 中顶点位置向量为 $\\mathbf{p}_0$、$\\mathbf{p}_1$ 和 $\\mathbf{p}_2$ 的三角形，每个顶点的内角可以从向量方向及其范数推导出来，从而为计算每个三角形中的最小角提供了基本依据。\n\n您必须为 DT 和 AFM 生成相同的节点集，以便三角形质量的任何差异都纯粹源于连接策略。对于每个测试用例，请执行以下步骤：\n\n1. 节点集生成：\n   - 弯曲边界定义：\n     - 半径为 $R$ 的圆，使用参数形式 $\\mathbf{b}(\\theta) = (R\\cos\\theta, R\\sin\\theta)$。\n     - 半长轴为 $a$ 和 $b$ 的椭圆，使用 $\\mathbf{e}(\\theta) = (a\\cos\\theta, b\\sin\\theta)$。\n   - 用 $N$ 个等距点离散化边界，使用 $\\theta_j = 2\\pi j/N$（其中 $j=0,1,\\dots,N-1$）。\n   - 生成 $L-1$ 个同心内环，由缩放半径 $r_\\ell = 1 - \\ell/L$（其中 $\\ell=1,2,\\dots,L-1$）定义（均匀径向分级），并用相同的 $N$ 个角度 $\\theta_j$ 参数化这些环。对于圆，点是 $(R r_\\ell \\cos\\theta_j, R r_\\ell \\sin\\theta_j)$。对于椭圆，点是 $(a r_\\ell \\cos\\theta_j, b r_\\ell \\sin\\theta_j)$。\n   - 包含一个位于 $(0,0)$ 的中心节点以闭合前沿。\n   - 对 DT 和 AFM 使用相同的节点集。\n\n2. 网格构建：\n   - DT 网格：计算 $\\mathbb{R}^2$ 中节点集的 Delaunay 三角剖分。\n   - AFM 网格：通过分层连接相邻环来构建三角形。对于环索引 $\\ell$ 和角度索引 $j$（其中 $j$ 对 $N$ 取模），每个分段创建两个三角形：\n     - $(\\ell,j)\\rightarrow(\\ell+1,j)\\rightarrow(\\ell+1,j+1)$，\n     - $(\\ell,j)\\rightarrow(\\ell+1,j+1)\\rightarrow(\\ell,j+1)$，\n     最后通过扇形 $(L-1,j)\\rightarrow\\text{中心}\\rightarrow(L-1,j+1)$ 将最内圈三角剖分至中心点。\n\n3. 三角形最小角度量：\n   - 对于每个三角形，使用欧几里得向量运算和反余弦函数计算所有三个内角，并取最小角度（以度为单位）。即，对于每个三角形 $T$，计算 $\\alpha_{\\min}(T)$（以度为单位）。\n\n4. 差异量化：\n   - 对于每个网格，计算：\n     - 最小角的算术平均值：$\\mu = \\frac{1}{M}\\sum_{k=1}^{M} \\alpha_{\\min}(T_k)$，其中 $M$ 是三角形的数量。\n     - 最坏情况下的最小角：$\\omega = \\min_{k=1,\\dots,M} \\alpha_{\\min}(T_k)$。\n   - 计算同一节点集下 DT 和 AFM 之间的差异：\n     - $\\Delta\\mu = \\mu_{\\text{DT}} - \\mu_{\\text{AFM}}$，\n     - $\\Delta\\omega = \\omega_{\\text{DT}} - \\omega_{\\text{AFM}}$。\n   -所有角度必须以度为单位表示。\n\n测试套件：\n提供三个科学上合理的测试用例，用于检验网格生成和质量评估的不同方面。\n\n- 测试用例 1（理想情况，圆形，中等分辨率）：$R=1$，$N=64$，$L=8$。\n- 测试用例 2（椭圆，几何形状导致的各向异性）：$a=1.5$，$b=1$，$N=64$，$L=8$。\n- 测试用例 3（边界条件，粗分辨率）：$R=1$，$N=16$，$L=3$。\n\n您的程序必须实现上述规范，为每个测试用例计算 $\\Delta\\mu$ 和 $\\Delta\\omega$，并在单行中输出结果。最终输出格式必须是一个包含在方括号内的逗号分隔列表，包含的值按 $[\\Delta\\mu_1,\\Delta\\omega_1,\\Delta\\mu_2,\\Delta\\omega_2,\\Delta\\mu_3,\\Delta\\omega_3]$ 的顺序排列，其中下标表示测试用例索引（1 到 3）。所有角度量必须以度为单位，浮点数应直接打印，除了编程语言的默认行为外不进行舍入调整。",
            "solution": "所提出的问题在科学上是合理的，数学上定义明确，并且在计算上是可行的。它解决了计算物理学和工程学中的一项基本任务：为数值模拟生成网格并评估其质量。该问题指定了两种不同且标准的网格划分策略，Delaunay 三角剖分 (DT) 和一种结构化的前沿推进法 (AFM)，应用于同一组节点。然后使用标准的网格质量度量——最小内角，进行严格的比较。所有参数、几何定义和算法都以足够的精度指定，以允许唯一且可验证的解。因此，该问题是有效的，我们继续提供一个合理的解决方案。\n\n问题的核心在于比较同一点集的两种不同三角剖分的几何质量。在计算热工学中常用的数值方法（如有限元法 (FEM) 或有限体积法 (FVM)）中，三角网格的质量至关重要。质量差的三角形，特别是那些内角非常小的三角形（所谓的“狭长”或“退化”三角形），可能导致病态的数值系统、精度降低以及迭代求解器收敛速度变慢。\n\n**1. 节点集生成**\n\n为确保直接比较三角剖分的连接性，我们为每个测试用例的 DT 和 AFM 方法生成了相同的节点集。这些节点分布在由弯曲边界定义的平面域内。生成过程如下：\n\n- 一组 $N$ 个角度位置由 $\\theta_j = \\frac{2\\pi j}{N}$ 定义，其中 $j=0, 1, \\dots, N-1$。\n- 对于给定的几何形状（圆形或椭圆形），使用这些角度对边界进行离散化。边界本身对应于径向比例因子 1。\n- 生成 $L-1$ 个同心内环。这些环在径向方向上均匀分级。第 $\\ell$-个环（其中 $\\ell=1, \\dots, L-1$）的比例因子由 $r_\\ell = 1 - \\ell/L$ 给出。最外层边界可以视为 $\\ell=0$ 的环，其 $r_0=1$。这样总共有 $L$ 个环。\n- 对于半径为 $R$ 的圆，在环 $\\ell$ ($0 \\le \\ell < L$) 上角度为 $\\theta_j$ 的点是 $\\mathbf{p}_{\\ell,j} = ((1 - \\ell/L)R\\cos\\theta_j, (1 - \\ell/L)R\\sin\\theta_j)$。\n- 对于半长轴为 $a$ 和 $b$ 的椭圆，一个点是 $\\mathbf{p}_{\\ell,j} = ((1 - \\ell/L)a\\cos\\theta_j, (1 - \\ell/L)b\\sin\\theta_j)$。\n- 在原点 $(0,0)$ 处放置一个节点作为中心点，这对于在区域内部闭合网格是必需的。\n- 节点总数为 $N \\times L + 1$。\n\n**2. 网格构建方法**\n\n定义节点集后，应用两种不同的三角剖分算法。\n\n**2.1. Delaunay 三角剖分 (DT)**\nDelaunay 三角剖分是计算几何中的一种经典方法。对于平面中的给定点集 $P$，如果 $\\text{DT}(P)$ 中没有任何三角形的外接圆内部包含 $P$ 中的任何点，则该三角剖分 $\\text{DT}(P)$ 是一个 Delaunay 三角剖分。这种“空外接圆”性质具有最大化网格中所有三角形最小角的理想效果，从而尽可能避免细长三角形。就此特定质量度量而言，它代表了一种最优解。我们将使用 `scipy.spatial.Delaunay` 类来计算 DT，该类为此实现了高效的算法（通常是 Quickhull）。\n\n**2.2. 前沿推进法 (AFM)**\n问题中描述的具体过程是一种结构化的、逐层的三角剖分，可以看作是前沿推进法的简化形式。“前沿”在这种情况下是每个同心环的边界。算法过程如下：\n- 对于外环 $\\ell$ 和内环 $\\ell+1$ 之间的每一层（其中 $\\ell=0, \\dots, L-2$），由相邻节点 $(\\mathbf{p}_{\\ell,j}, \\mathbf{p}_{\\ell,j+1}, \\mathbf{p}_{\\ell+1,j+1}, \\mathbf{p}_{\\ell+1,j})$ 形成的四边形都被划分为两个三角形。问题指定了划分方式：\n  - 三角形 1：连接顶点 $(\\ell, j)$、$(\\ell+1, j)$ 和 $(\\ell+1, j+1)$。\n  - 三角形 2：连接顶点 $(\\ell, j)$、$(\\ell+1, j+1)$ 和 $(\\ell, j+1)$。\n  索引 $j$ 对 $N$ 取模处理，以应对环的闭环特性。\n- 在对 $L-1$ 层进行三角剖分后，最内层的环（环 $L-1$）被三角剖分到中心点。这是通过创建一系列“扇形”三角形来完成的，其中每个三角形由最内层环上的两个相邻节点和中心点形成：$(\\ell=L-1, j)$、中心点和 $(\\ell=L-1, j+1)$。\n这种结构化方法创建了一个高度规则的网格，但与 DT 的自适应性不同，其质量受到预定义连接性的限制。\n\n**3. 三角形质量评估**\n\n为了量化网格质量，我们计算每个三角形的最小内角。对于顶点位置向量为 $\\mathbf{p}_0$、$\\mathbf{p}_1$ 和 $\\mathbf{p}_2$ 的三角形，顶点 $\\mathbf{p}_0$ 处的角 $\\alpha_0$ 是通过从该顶点出发的边向量 $\\mathbf{v}_{01} = \\mathbf{p}_1 - \\mathbf{p}_0$ 和 $\\mathbf{v}_{02} = \\mathbf{p}_2 - \\mathbf{p}_0$ 的点积来找到的。该角由以下公式给出：\n$$ \\alpha_0 = \\arccos\\left(\\frac{\\mathbf{v}_{01} \\cdot \\mathbf{v}_{02}}{\\|\\mathbf{v}_{01}\\| \\|\\mathbf{v}_{02}\\|}\\right) $$\n另外两个角 $\\alpha_1$ 和 $\\alpha_2$ 的计算方式类似。单个三角形 $T_k$ 的质量度量是其最小角，$\\alpha_{\\min}(T_k) = \\min(\\alpha_0, \\alpha_1, \\alpha_2)$。`arccos` 的结果是弧度，必须通过乘以 $180/\\pi$ 转换为度。\n\n**4. 比较分析**\n\n为了比较 DT 和 AFM 网格的整体质量，我们为每个网格计算两个聚合统计量：\n- 网格中所有 $M$ 个三角形的最小角的算术平均值：$\\mu = \\frac{1}{M}\\sum_{k=1}^{M} \\alpha_{\\min}(T_k)$。该度量表示平均三角形质量。\n- 所有三角形中的全局最小角：$\\omega = \\min_{k=1,\\dots,M} \\alpha_{\\min}(T_k)$。该度量识别出网格中最差的单个三角形，这通常是数值稳定性的关键因素。\n\n最终的比较通过两种方法之间这些度量的差异来体现：\n- $\\Delta\\mu = \\mu_{\\text{DT}} - \\mu_{\\text{AFM}}$\n- $\\Delta\\omega = \\omega_{\\text{DT}} - \\omega_{\\text{AFM}}$\n\n$\\Delta\\mu$ 和 $\\Delta\\omega$ 的正值表示 Delaunay 三角剖分产生的网格分别具有更好的平均质量和更好的最坏情况三角形，这通常是预期的，因为其具有角度优化特性。实现将对指定的测试用例执行这些计算。",
            "answer": "```python\nimport numpy as np\nfrom scipy.spatial import Delaunay\n\ndef solve():\n    \"\"\"\n    Main function to run the mesh comparison for all test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: Circle, moderate resolution\n        {'shape': 'circle', 'params': {'R': 1.0}, 'N': 64, 'L': 8},\n        # Case 2: Ellipse, anisotropy\n        {'shape': 'ellipse', 'params': {'a': 1.5, 'b': 1.0}, 'N': 64, 'L': 8},\n        # Case 3: Circle, coarse resolution\n        {'shape': 'circle', 'params': {'R': 1.0}, 'N': 16, 'L': 3},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Step 1: Generate Node Set\n        points = generate_nodes(case['shape'], case['params'], case['N'], case['L'])\n\n        # Step 2: Build Meshes\n        dt_triangles = build_dt_mesh(points)\n        afm_triangles = build_afm_mesh(case['N'], case['L'])\n\n        # Step 3  4: Compute Quality Metrics and Differences\n        mu_dt, omega_dt = compute_mesh_quality(points, dt_triangles)\n        mu_afm, omega_afm = compute_mesh_quality(points, afm_triangles)\n\n        delta_mu = mu_dt - mu_afm\n        delta_omega = omega_dt - omega_afm\n\n        results.extend([delta_mu, delta_omega])\n\n    # Final print statement\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef generate_nodes(shape, params, N, L):\n    \"\"\"\n    Generates the node set for a given geometry.\n    The nodes are ordered by ring, then by angle.\n    Ring 0 is the outermost boundary, ring L-1 is the innermost.\n    The last point is the center at (0,0).\n    \"\"\"\n    num_points = N * L + 1\n    points = np.zeros((num_points, 2))\n    thetas = np.linspace(0, 2 * np.pi, N, endpoint=False)\n\n    for l in range(L):\n        scale = 1.0 - l / L\n        if shape == 'circle':\n            R = params['R']\n            x_coords = R * scale * np.cos(thetas)\n            y_coords = R * scale * np.sin(thetas)\n        elif shape == 'ellipse':\n            a, b = params['a'], params['b']\n            x_coords = a * scale * np.cos(thetas)\n            y_coords = b * scale * np.sin(thetas)\n        \n        start_idx = l * N\n        end_idx = start_idx + N\n        points[start_idx:end_idx, 0] = x_coords\n        points[start_idx:end_idx, 1] = y_coords\n\n    # Center node is already (0,0) by np.zeros initialization\n    return points\n\n\ndef build_dt_mesh(points):\n    \"\"\"\n    Computes the Delaunay triangulation for a given set of points.\n    \"\"\"\n    delaunay_tri = Delaunay(points)\n    return delaunay_tri.simplices\n\n\ndef build_afm_mesh(N, L):\n    \"\"\"\n    Constructs the triangulation using the structured Advancing Front Method.\n    \"\"\"\n    triangles = []\n    \n    # Layered triangulation between concentric rings\n    for l in range(L - 1):\n        for j in range(N):\n            j_plus_1 = (j + 1) % N\n            \n            # Indices for the four nodes of the \"quad\"\n            idx_lj = l * N + j\n            idx_lj1 = l * N + j_plus_1\n            idx_l1j = (l + 1) * N + j\n            idx_l1j1 = (l + 1) * N + j_plus_1\n            \n            # Create two triangles from the quad\n            # Triangle 1: (l,j) -> (l+1,j) -> (l+1,j+1)\n            triangles.append([idx_lj, idx_l1j, idx_l1j1])\n            # Triangle 2: (l,j) -> (l+1,j+1) -> (l,j+1)\n            triangles.append([idx_lj, idx_l1j1, idx_lj1])\n\n    # Fan triangulation for the innermost ring to the center\n    center_idx = N * L\n    innermost_ring_l = L - 1\n    for j in range(N):\n        j_plus_1 = (j + 1) % N\n        idx_L1j = innermost_ring_l * N + j\n        idx_L1j1 = innermost_ring_l * N + j_plus_1\n        \n        # Triangle: (L-1,j) -> center -> (L-1,j+1)\n        triangles.append([idx_L1j, center_idx, idx_L1j1])\n        \n    return np.array(triangles)\n\n\ndef compute_min_angle_of_triangle(p0, p1, p2):\n    \"\"\"\n    Computes the minimum internal angle of a single triangle in degrees.\n    \"\"\"\n    # Create edge vectors\n    v01 = p1 - p0\n    v02 = p2 - p0\n    v12 = p2 - p1\n\n    # Compute dot products and norms\n    dot_p0 = np.dot(v01, v02)\n    dot_p1 = np.dot(-v01, v12)\n    dot_p2 = np.dot(-v02, -v12)\n\n    norm_v01 = np.linalg.norm(v01)\n    norm_v02 = np.linalg.norm(v02)\n    norm_v12 = np.linalg.norm(v12)\n\n    # Avoid division by zero for degenerate triangles (collinear points)\n    if norm_v01 == 0 or norm_v02 == 0 or norm_v12 == 0:\n        return 0.0\n\n    # Calculate cosines of angles, clipping to handle floating point inaccuracies\n    cos_a0 = np.clip(dot_p0 / (norm_v01 * norm_v02), -1.0, 1.0)\n    cos_a1 = np.clip(dot_p1 / (norm_v01 * norm_v12), -1.0, 1.0)\n    \n    # The third angle is derived from the first two\n    # a2 = 180 - a0 - a1, however, direct computation is more robust\n    cos_a2 = np.clip(dot_p2 / (norm_v02 * norm_v12), -1.0, 1.0)\n    \n    # Calculate angles in radians and then convert to degrees\n    a0 = np.arccos(cos_a0)\n    a1 = np.arccos(cos_a1)\n    a2 = np.arccos(cos_a2)\n\n    angles_deg = np.rad2deg([a0, a1, a2])\n    \n    return np.min(angles_deg)\n\n\ndef compute_mesh_quality(points, triangles):\n    \"\"\"\n    Computes the mean and minimum of the minimum angles for all triangles in a mesh.\n    \"\"\"\n    min_angles = [\n        compute_min_angle_of_triangle(points[tri[0]], points[tri[1]], points[tri[2]])\n        for tri in triangles\n    ]\n    \n    min_angles = np.array(min_angles)\n    mean_min_angle = np.mean(min_angles)\n    worst_case_angle = np.min(min_angles)\n    \n    return mean_min_angle, worst_case_angle\n\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}