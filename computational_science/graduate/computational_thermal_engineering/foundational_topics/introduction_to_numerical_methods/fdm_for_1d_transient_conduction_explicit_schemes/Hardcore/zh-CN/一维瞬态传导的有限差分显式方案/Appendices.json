{
    "hands_on_practices": [
        {
            "introduction": "计算传热学的第一步是将控制偏微分方程转化为可执行的算法。本练习将指导您推导并实现经典的一维瞬态热传导问题的前向时间中心空间（FTCS）格式。通过编写求解器并与已知的解析解进行对比测试，您将对显式有限差分方法及其稳定性约束建立基础性的理解。",
            "id": "3952352",
            "problem": "考虑一个长度为 $L$ 的均匀杆中的一维瞬态热传导问题，其两端具有固定温度（狄利克雷）边界条件。令 $T(x,t)$ 表示温度场，$\\alpha$ 表示热扩散率（单位为 $\\mathrm{m}^2/\\mathrm{s}$），并假设一个具有 $N$ 个节点的均匀空间剖分，节点间距为 $\\Delta x = L/(N-1)$。杆的两端 $x=0$ 和 $x=L$ 保持恒定温度，初始温度分布是使用正弦函数表示的、振幅为 $A$ 的单个空间本征模。角度必须以弧度处理。\n\n从一维热方程 $ \\partial T / \\partial t = \\alpha \\, \\partial^2 T / \\partial x^2 $ 出发，推导一个前向时间中心空间（FTCS）显式有限差分格式。在所述的均匀网格上，时间上使用前向差分，空间上使用中心二阶差分。清晰地推导内部节点的离散更新方程，用傅里叶数 $Fo$ 表示，其中 $Fo$ 必须直接由离散化参数和材料属性定义。在所有时间层级上施加狄利克雷边界条件。\n\n基于适用于线性常系数偏微分方程的标准模态放大法，进行稳定性分析。用 $Fo$ 和空间波数表示放大因子，并推导出确保所有容许的离散空间模态都有界放大的 $Fo$ 条件。在您的算法中使用此条件来实现先验稳定性检查。\n\n设计并实现一个算法，该算法能够：\n- 构建空间网格，并使用 $T(x,0) = A \\, \\sin(m \\pi x / L)$ 初始化温度场，其中 $m$ 是与狄利克雷边界条件兼容的指定整数模态指数。\n- 使用显式 FTCS 格式将解在时间上推进到最终时间 $t_f$，并在每一步施加边界值。\n- 对所选的初始模态，在 $t_f$ 时刻计算精确解析解，并计算数值解与精确解在整个网格上的最大绝对误差。\n- 报告一个稳定性标志，指示所选的 $Fo$ 是否满足推导出的稳定性条件，并附上定量诊断信息。\n\n物理单位：\n- 温度以开尔文报告。\n- 时间以秒报告。\n- 长度以米报告。\n- 正弦函数中的角度必须为弧度。\n\n您的程序必须实现基于时间步和空间节点的循环更新。对于每个测试用例，它必须按顺序输出一个包含以下值的列表：\n- 一个使用推导的 $Fo$ 准则的布尔稳定性标志。\n- 一个浮点数，等于 $t_f$ 时刻的最大绝对误差，单位为开尔文。\n- 一个浮点数，等于 $t_f$ 时刻的最大绝对温度幅值，单位为开尔文。\n- 一个浮点数，等于 $t_f$，单位为秒。\n\n测试套件：\n- 测试用例 1（正常路径）：$L = 1.0$ $\\mathrm{m}$，$\\alpha = 1.0 \\times 10^{-4}$ $\\mathrm{m}^2/\\mathrm{s}$，$N=41$，$\\Delta t = 0.1$ $\\mathrm{s}$，$t_f = 1.0$ $\\mathrm{s}$，$A=1.0$ $\\mathrm{K}$，$m=1$。\n- 测试用例 2（稳定性边界条件）：$L = 1.0$ $\\mathrm{m}$，$\\alpha = 1.0 \\times 10^{-4}$ $\\mathrm{m}^2/\\mathrm{s}$，$N=101$，$\\Delta t = 0.5$ $\\mathrm{s}$，$t_f = 5.0$ $\\mathrm{s}$，$A=1.0$ $\\mathrm{K}$，$m=1$。\n- 测试用例 3（用高频分量探测不稳定性的边界情况）：$L = 1.0$ $\\mathrm{m}$，$\\alpha = 1.0 \\times 10^{-4}$ $\\mathrm{m}^2/\\mathrm{s}$，$N=101$，$\\Delta t = 0.6$ $\\mathrm{s}$，$t_f = 3.0$ $\\mathrm{s}$，$A=1.0$ $\\mathrm{K}$，$m=N-2$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个元素对应一个测试用例，并且本身必须是按上述顺序排列的列表。例如：$[ [\\text{flag}_1, \\text{err}_1, \\text{maxT}_1, \\text{t}_1], [\\text{flag}_2, \\text{err}_2, \\text{maxT}_2, \\text{t}_2], [\\text{flag}_3, \\text{err}_3, \\text{maxT}_3, \\text{t}_3] ]$。",
            "solution": "该问题要求对一维瞬态热传导方程，推导、进行稳定性分析并实现前向时间中心空间（FTCS）显式有限差分方法。然后将该解与已知的解析解进行比较，以评估其准确性。\n\n一维热传导的控制偏微分方程（PDE）是：\n$$ \\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2} $$\n其中 $T(x,t)$ 是空间坐标 $x$ 和时间 $t$ 处的温度，$\\alpha$ 是材料的热扩散率。该问题定义在空间域 $x \\in [0, L]$上，具有齐次狄利克雷边界条件 $T(0, t) = 0$ 和 $T(L, t) = 0$。初始温度分布以单个空间本征模的形式给出：\n$$ T(x,0) = A \\sin\\left(\\frac{m \\pi x}{L}\\right) $$\n其中 $A$ 是振幅，$m$ 是一个整数模态指数。\n\n首先，我们推导 FTCS 有限差分格式。我们将区域离散化为一个具有 $N$ 个空间节点的均匀网格，节点索引为 $i=0, 1, \\dots, N-1$，使得 $x_i = i \\Delta x$，其中空间步长为 $\\Delta x = L/(N-1)$。时间以恒定步长 $\\Delta t$ 进行离散化，使得 $t_n = n \\Delta t$。网格点 $(x_i, t_n)$ 处的温度表示为 $T_i^n$。\n\n时间导数 $\\partial T/\\partial t$ 使用一阶精度的前向差分来近似：\n$$ \\frac{\\partial T}{\\partial t} \\bigg|_{i,n} \\approx \\frac{T_i^{n+1} - T_i^n}{\\Delta t} $$\n空间二阶导数 $\\partial^2 T/\\partial x^2$ 使用二阶精度的中心差分来近似：\n$$ \\frac{\\partial^2 T}{\\partial x^2} \\bigg|_{i,n} \\approx \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{(\\Delta x)^2} $$\n将这些近似代入控制偏微分方程，得到 FTCS 格式：\n$$ \\frac{T_i^{n+1} - T_i^n}{\\Delta t} = \\alpha \\left( \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{(\\Delta x)^2} \\right) $$\n这个方程可以重新整理，以提供一个基于当前时间层 $T^n$ 的温度来计算下一个时间层 $T_i^{n+1}$ 的温度的显式更新规则：\n$$ T_i^{n+1} = T_i^n + \\frac{\\alpha \\Delta t}{(\\Delta x)^2} (T_{i+1}^n - 2T_i^n + T_{i-1}^n) $$\n我们定义无量纲的傅里叶数 $Fo$ 为：\n$$ Fo = \\frac{\\alpha \\Delta t}{(\\Delta x)^2} $$\n内部节点（$i=1, \\dots, N-2$）的更新方程可以简洁地写为：\n$$ T_i^{n+1} = T_i^n + Fo (T_{i+1}^n - 2T_i^n + T_{i-1}^n) = (1 - 2Fo)T_i^n + Fo(T_{i-1}^n + T_{i+1}^n) $$\n\n接下来，我们进行 von Neumann 稳定性分析，以确定稳定解对 $Fo$ 的约束条件。我们考虑数值解的单个傅里叶模态的传播， $T_i^n = G^n e^{\\mathrm{i}k_w x_i}$，其中 $G$ 是每个时间步的放大因子，$k_w$ 是空间波数，$\\mathrm{i}=\\sqrt{-1}$。将其代入离散方程：\n$$ G^{n+1} e^{\\mathrm{i}k_w x_i} = (1 - 2Fo) G^n e^{\\mathrm{i}k_w x_i} + Fo (G^n e^{\\mathrm{i}k_w x_{i-1}} + G^n e^{\\mathrm{i}k_w x_{i+1}}) $$\n两边同除以 $G^n e^{\\mathrm{i}k_w x_i}$ 并使用 $x_{i\\pm1} = x_i \\pm \\Delta x$：\n$$ G = (1 - 2Fo) + Fo (e^{-\\mathrm{i}k_w \\Delta x} + e^{\\mathrm{i}k_w \\Delta x}) $$\n使用欧拉(Euler)恒等式 $e^{\\mathrm{i}\\theta} + e^{-\\mathrm{i}\\theta} = 2\\cos(\\theta)$，我们得到：\n$$ G = 1 - 2Fo + 2Fo \\cos(k_w \\Delta x) = 1 - 2Fo(1 - \\cos(k_w \\Delta x)) $$\n利用半角恒等式 $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$：\n$$ G = 1 - 4Fo\\sin^2\\left(\\frac{k_w \\Delta x}{2}\\right) $$\n为了保证稳定性，放大因子的模对于所有可能的波数都不能超过 1，即 $|G| \\le 1$。这意味着 $-1 \\le G \\le 1$。\n条件 $G \\le 1$ 总是满足的，因为 $Fo > 0$ 且 $\\sin^2(\\cdot) \\ge 0$。\n条件 $G \\ge -1$ 提供了稳定性约束：\n$$ 1 - 4Fo\\sin^2\\left(\\frac{k_w \\Delta x}{2}\\right) \\ge -1 $$\n$$ 2 \\ge 4Fo\\sin^2\\left(\\frac{k_w \\Delta x}{2}\\right) \\implies Fo \\le \\frac{1}{2\\sin^2\\left(\\frac{k_w \\Delta x}{2}\\right)} $$\n这个约束必须对所有波数都成立。最严格的情况发生在 $\\sin^2(k_w \\Delta x / 2)$ 取最大值 1 时。这对应于网格上可分辨的最高频率模态，此时 $k_w \\Delta x = \\pi$。由此得出 FTCS 格式的最终稳定性判据：\n$$ Fo \\le \\frac{1}{2} $$\n\n对于给定的初始和边界条件，该偏微分方程的解析解可以通过分离变量法找到。由于初始条件 $\\sin(m \\pi x / L)$ 已经是给定边界条件下空间算子的单个本征函数，解的时间演化是该模态的指数衰减：\n$$ T_{\\text{exact}}(x,t) = A \\sin\\left(\\frac{m \\pi x}{L}\\right) \\exp\\left(-\\alpha \\left(\\frac{m \\pi}{L}\\right)^2 t\\right) $$\n这个精确解用于计算数值格式的误差。\n\n算法流程如下：\n1. 对于每个测试用例，定义参数 $L, \\alpha, N, \\Delta t, t_f, A, m$。\n2. 计算派生的网格参数 $\\Delta x = L/(N-1)$ 和傅里叶数 $Fo = \\alpha \\Delta t / (\\Delta x)^2$。\n3. 执行先验稳定性检查：如果 $Fo \\le 0.5$，则格式是稳定的。\n4. 根据初始条件 $T(x,0)$ 初始化空间网格 $x$ 和温度数组 $T$。\n5. 从 $t=0$ 到 $t_f$ 进行时间迭代。在每个时间步中，创建当前温度场的副本。然后，遍历所有内部空间节点（$i=1, \\dots, N-2$）并使用 FTCS 公式更新温度。边界点 $i=0$ 和 $i=N-1$ 处的温度保持固定为 0。\n6. 在最后一个时间步之后，计算精确解 $T_{\\text{exact}}(x,t_f)$。\n7. 从数值解中计算最大绝对误差 $\\max_i |T_i - T_{\\text{exact}}(x_i, t_f)|$ 和最大绝对温度幅值 $\\max_i |T_i|$。\n8. 报告稳定性标志、最大绝对误差、最大绝对温度和最终时间 $t_f$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D transient heat conduction problem using an explicit FTCS scheme\n    for a series of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, alpha, N, dt, tf, A, m)\n        (1.0, 1.0e-4, 41, 0.1, 1.0, 1.0, 1),\n        (1.0, 1.0e-4, 101, 0.5, 5.0, 1.0, 1),\n        (1.0, 1.0e-4, 101, 0.6, 3.0, 1.0, 101 - 2),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, alpha, N, dt, tf, A, m = case\n\n        # 1. Setup grid and parameters\n        dx = L / (N - 1)\n        x = np.linspace(0.0, L, N)\n        Fo = alpha * dt / (dx**2)\n\n        # 2. Stability Check\n        is_stable = Fo = 0.5\n\n        # 3. Initialization\n        T = A * np.sin(m * np.pi * x / L)\n        \n        # Dirichlet boundary conditions are fixed at T=0.\n        # They are correctly set by the initial condition and will not be\n        # updated in the spatial loop.\n        T[0] = 0.0\n        T[-1] = 0.0\n\n        # 4. Time Marching Loop\n        # The problem requires loop-based updates.\n        num_steps = int(round(tf / dt))\n        \n        for n in range(num_steps):\n            T_old = T.copy()\n            # Loop over interior nodes\n            for i in range(1, N - 1):\n                T[i] = T_old[i] + Fo * (T_old[i+1] - 2 * T_old[i] + T_old[i-1])\n\n        # 5. Final Calculations\n        # The final simulation time is num_steps * dt, which equals tf for these cases.\n        t_final = num_steps * dt\n\n        # Analytical solution at t_final\n        decay_term = np.exp(-alpha * (m * np.pi / L)**2 * t_final)\n        T_exact = A * np.sin(m * np.pi * x / L) * decay_term\n\n        # Metrics\n        # In case of instability, T can become NaN\n        if np.isnan(T).any():\n            max_abs_error = float('inf')\n            max_abs_temp = float('inf')\n        else:\n            max_abs_error = np.max(np.abs(T - T_exact))\n            max_abs_temp = np.max(np.abs(T))\n\n        results.append([is_stable, max_abs_error, max_abs_temp, tf])\n\n    # Final print statement in the exact required format.\n    # str() on a list of lists produces the required format with spaces.\n    # The join(map(...)) idiom is more complex and produces a slightly different\n    # spacing, so we use the simpler and more standard str() conversion.\n    print(str(results).replace(\"'\", '\"'))\n\nsolve()\n\n```"
        },
        {
            "introduction": "虽然冯·诺依曼分析为稳定性提供了数学条件，但从物理角度理解它也同样至关重要。本练习探讨了正定性原则，揭示了稳定性约束 $Fo \\le 0.5$ 对于防止非物理性的新温度极值的产生是必要的。通过检视更新格式的系数，您将对显式格式为何以及如何变得不稳定获得更直观的认识。",
            "id": "3952406",
            "problem": "考虑一维均匀杆中的热扩散，其材料属性恒定，受能量守恒和傅里叶热传导定律的支配。其控制偏微分方程是具有恒定热扩散系数的标准扩散方程。使用均匀的空间网格和均匀的时间步长，通过结合前向时间离散和中心空间离散，构建一个显式时间推进的有限差分法 (FDM) 格式。不要假设任何预先推导出的更新公式。从微分控制体上的能量守恒和傅里叶定律开始，导出扩散方程，然后进行时间和空间上的离散近似。识别出由离散化产生的时间步长和网格间距的无量纲组合。使用该组合将内部节点的更新表示为当前节点及其在上一时间层的最近邻居节点的线性组合。通过分析此线性组合的系数，证明存在一个阈值，超过该阈值时，其中一个系数会变为负数。解释为什么这种负值意味着对于非负初始数据，保正性被违反。\n\n然后，通过一个使用无量纲变量（因此不需要物理单位）的特定数值示例来说明其后果。考虑一个由 $N$ 个节点组成的均匀网格，其中 $N=11$，节点索引为 $i=0,1,\\dots,10$。边界条件为狄利克雷边界条件，$T_0^n=0$ 和 $T_{10}^n=0$ 对所有时间层 $n$ 成立。在时间层 $n=0$ 时的初始条件是非负的，且仅集中在中心节点上：令中心索引为 $i_c=(N-1)/2=5$，设置 $T_{i_c}^0=1$，并对所有 $i\\neq i_c$ 设置 $T_i^0=0$。对无量纲时间步长参数（傅里叶数）的三个不同值 $Fo\\in\\{0.25,0.5,0.6\\}$，执行恰好一次显式时间更新。\n\n您的程序必须为这三个 $Fo$ 值中的每一个计算两个输出：\n- 一个布尔值，指示内部节点线性组合中的所有三个更新系数是否为非负。\n- 在指定网格和边界/初始数据上计算出的一步时间步长后的最小节点值 $\\min_i T_i^{1}$。\n\n测试套件：\n- 情况 A (正常路径): $Fo=0.25$。\n- 情况 B (边界): $Fo=0.5$。\n- 情况 C (超出阈值): $Fo=0.6$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n$[b_{0.25},m_{0.25},b_{0.5},m_{0.5},b_{0.6},m_{0.6}]$，\n其中 $b_{Fo}$ 是给定 $Fo$ 的布尔系数非负性指示符，而 $m_{Fo}$ 是对应的最小值 $\\min_i T_i^{1}$（浮点数）。由于设置为完全无量纲，因此无需报告物理单位。",
            "solution": "我们从第一性原理开始，推导显式有限差分法 (FDM) 格式。\n\n**1. 控制方程的推导与离散化**\n\n具有恒定属性的均匀介质中的一维瞬态热传导受能量守恒定律支配。对于长度为 $\\Delta x$、横截面积均匀为 $A$ 的任意控制体，能量平衡为：\n$$ \\frac{dE_{stored}}{dt} = \\dot{E}_{in} - \\dot{E}_{out} $$\n其中 $E_{stored}$ 是存储在控制体内的内能，$\\dot{E}$ 代表能量传输速率。储存的能量为 $E_{stored} = \\int_{x}^{x+\\Delta x} \\rho c_p T(x', t) A dx'$，其中 $\\rho$ 是密度，$c_p$ 是比热容。因此，储存能量的变化率为 $\\frac{dE_{stored}}{dt} \\approx \\rho c_p A \\Delta x \\frac{\\partial T}{\\partial t}$。\n\n能量通过传导进行传递，遵循傅里叶定律 $q = -kA \\frac{\\partial T}{\\partial x}$，其中 $k$ 是热导率。进入控制体的净热传导速率为 $\\dot{E}_{in} - \\dot{E}_{out} = q_x - q_{x+\\Delta x}$。\n将这些代入能量平衡方程，得到：\n$$ \\rho c_p A \\Delta x \\frac{\\partial T}{\\partial t} \\approx \\left(-kA \\frac{\\partial T}{\\partial x}\\right)\\bigg|_x - \\left(-kA \\frac{\\partial T}{\\partial x}\\right)\\bigg|_{x+\\Delta x} $$\n除以 $A \\Delta x$ 并重新整理，得到：\n$$ \\rho c_p \\frac{\\partial T}{\\partial t} \\approx k \\frac{\\left(\\frac{\\partial T}{\\partial x}\\right)\\bigg|_{x+\\Delta x} - \\left(\\frac{\\partial T}{\\partial x}\\right)\\bigg|_x}{\\Delta x} $$\n在 $\\Delta x \\to 0$ 的极限情况下，这成为精确的偏微分方程 (PDE)：\n$$ \\rho c_p \\frac{\\partial T}{\\partial t} = k \\frac{\\partial^2 T}{\\partial x^2} $$\n除以 $\\rho c_p$ 得到标准扩散方程，其中 $\\alpha = k / (\\rho c_p)$ 是热扩散系数：\n$$ \\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2} $$\n为离散化该方程，我们在空间和时间上使用均匀网格，其中 $T(x_i, t_n)$ 表示为 $T_i^n$，并有 $x_i = i \\Delta x$ 和 $t_n = n \\Delta t$。我们使用有限差分来近似导数。\n时间导数用一阶前向差分近似：\n$$ \\frac{\\partial T}{\\partial t}\\bigg|_{(i,n)} \\approx \\frac{T_i^{n+1} - T_i^n}{\\Delta t} $$\n空间二阶导数用二阶中心差分近似：\n$$ \\frac{\\partial^2 T}{\\partial x^2}\\bigg|_{(i,n)} \\approx \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{(\\Delta x)^2} $$\n将这些近似代入偏微分方程，得到前向时间中心空间 (FTCS) 显式格式：\n$$ \\frac{T_i^{n+1} - T_i^n}{\\Delta t} = \\alpha \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{(\\Delta x)^2} $$\n求解新时间层的温度 $T_i^{n+1}$，我们得到更新方程：\n$$ T_i^{n+1} = T_i^n + \\frac{\\alpha \\Delta t}{(\\Delta x)^2} (T_{i+1}^n - 2T_i^n + T_{i-1}^n) $$\n无量纲组合是网格傅里叶数，$Fo = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$。代入 $Fo$ 可以简化更新方程：\n$$ T_i^{n+1} = T_i^n + Fo (T_{i+1}^n - 2T_i^n + T_{i-1}^n) $$\n通过合并项，这可以表示为前一时间层温度的线性组合：\n$$ T_i^{n+1} = (Fo) T_{i-1}^n + (1 - 2Fo) T_i^n + (Fo) T_{i+1}^n $$\n\n**2. 保正性与稳定性分析**\n\n更新方程将新温度 $T_i^{n+1}$ 表示为前一时间步 $n$ 处相邻节点温度的加权平均。该线性组合的系数为：\n$$ C_{i-1} = Fo $$\n$$ C_i = 1 - 2Fo $$\n$$ C_{i+1} = Fo $$\n为了使数值解具有物理意义，它应遵守热力学第二定律。对于一个具有非负初始数据且无热沉的扩散问题，任何点的温度都不应低于初始最低温度。这被称为保正性。确保这一点的充分条件是线性组合中的所有系数均为非负。\n1. $C_{i-1} = Fo \\ge 0$。由于 $\\alpha, \\Delta t, \\Delta x$ 均为非负，此条件恒成立。\n2. $C_{i+1} = Fo \\ge 0$。此条件也恒成立。\n3. $C_i = 1 - 2Fo \\ge 0$。这施加了一个约束条件：$1 \\ge 2Fo \\implies Fo \\le \\frac{1}{2}$。\n\n因此，傅里叶数的阈值为 $Fo=0.5$。如果 $Fo  0.5$，系数 $C_i = 1-2Fo$ 将变为负数。这种负值意味着，如果中心节点 $T_i^n$ 的温度是一个局部最大值，它将对其未来的值 $T_i^{n+1}$ 产生负贡献。\n\n为了证明这种违规，考虑指定的初始条件：除中心节点 $i_c=5$ 外，所有 $i$ 的 $T_i^0 = 0$，而 $T_5^0 = 1$。让我们计算一个时间步后该中心节点的温度 $T_5^1$：\n$$ T_5^1 = Fo \\cdot T_4^0 + (1 - 2Fo) \\cdot T_5^0 + Fo \\cdot T_6^0 $$\n代入初始值 $T_4^0 = 0$， $T_5^0 = 1$ 和 $T_6^0 = 0$：\n$$ T_5^1 = Fo \\cdot (0) + (1 - 2Fo) \\cdot (1) + Fo \\cdot (0) = 1 - 2Fo $$\n如果 $Fo  0.5$，则 $2Fo  1$，这使得 $T_5^1 = 1 - 2Fo  0$。从一个完全非负的温度场开始，该格式产生了一个负温度，这对于纯粹的扩散过程在物理上是不可能的，并标志着数值不稳定性。\n\n问题的数值部分要求对 $Fo$ 值为 $0.25$、$0.5$ 和 $0.6$ 进行此计算。这将在程序中实现。对于每种情况，我们将首先检查所有系数是否为非负（$Fo \\le 0.5$），然后使用提供的初始和边界条件计算一个时间步后的最低温度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D transient heat conduction problem using an explicit FDM scheme\n    for three specified Fourier numbers and calculates the requested outputs.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [0.25, 0.5, 0.6]\n\n    results = []\n    \n    # Problem specifications for the numerical example\n    N = 11  # Number of nodes\n    i_c = (N - 1) // 2  # Index of the center node, (11-1)/2 = 5\n\n    # Initial Condition (at time n=0)\n    T0 = np.zeros(N)\n    T0[i_c] = 1.0\n\n    for Fo in test_cases:\n        # --- Part 1: Check if all coefficients are non-negative ---\n        # The coefficients are Fo, (1 - 2*Fo), and Fo.\n        # Since Fo is always = 0, we only need to check (1 - 2*Fo).\n        coeffs_are_nonnegative = (1 - 2 * Fo) = 0\n\n        # --- Part 2: Compute temperature distribution after one time step ---\n        # Initialize temperature array for the next time step (n=1)\n        T1 = np.zeros(N)\n\n        # The boundary conditions are T_0^n = 0 and T_{10}^n = 0.\n        # Since T1 is initialized to zeros, these are automatically satisfied.\n\n        # Apply the explicit update formula for all interior nodes (i = 1 to N-2)\n        # T_i^{n+1} = Fo * T_{i-1}^n + (1 - 2*Fo) * T_i^n + Fo * T_{i+1}^n\n        for i in range(1, N - 1):\n            T1[i] = Fo * T0[i - 1] + (1 - 2 * Fo) * T0[i] + Fo * T0[i + 1]\n\n        # Find the minimum nodal value in the new temperature distribution\n        min_T1 = np.min(T1)\n\n        # Append the results for this case\n        results.append(coeffs_are_nonnegative)\n        results.append(min_T1)\n        \n    # Format the results into the required string format.\n    # The map(str, ...) converts each item (boolean or float) to its string representation.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    \n    # Final print statement in the exact required format.\n    # Note: Python's `str()` on booleans produces \"True\" and \"False\" with capital letters.\n    # We replace them with lowercase to be certain, though typically this is not required.\n    print(output_str.replace('True', 'true').replace('False', 'false'))\n\nsolve()\n\n```"
        },
        {
            "introduction": "编写求解器只是工作的一半；确保其产生正确的结果至关重要。本练习介绍了网格加密研究这一关键技术，用以验证您的代码精度。通过系统地减小步长（$\\Delta x$ 和 $\\Delta t$）并测量由此带来的误差减小，您将从数值上验证FTCS格式的理论收敛阶，这是计算科学中验证与确认（VV）的基石。",
            "id": "3952361",
            "problem": "考虑一个在一维瞬态热传导问题，该问题由定义在具有固定温度边界的闭区间上的热方程所控制。其物理模型是标准的偏微分方程\n$$\n\\frac{\\partial T(x,t)}{\\partial t} = \\alpha \\,\\frac{\\partial^2 T(x,t)}{\\partial x^2},\n$$\n其中 $T(x,t)$ 是温度场，$x \\in [0,L]$ 是空间坐标，$t \\ge 0$ 是时间，$\\alpha$ 是热扩散系数。空间域长度为 $L$，热扩散系数为 $\\alpha$。边界条件为齐次狄利克雷边界条件，\n$$\nT(0,t) = 0 \\;\\text{and}\\; T(L,t) = 0 \\quad \\text{for all } t \\ge 0,\n$$\n初始条件为\n$$\nT(x,0) = \\sin\\!\\left(\\frac{\\pi x}{L}\\right).\n$$\n该场根据热方程演化；对于此特定的初始和边界条件，其精确解已知为\n$$\nT_{\\text{exact}}(x,t) = \\sin\\!\\left(\\frac{\\pi x}{L}\\right) \\exp\\!\\left(-\\alpha \\left(\\frac{\\pi}{L}\\right)^2 t\\right).\n$$\n\n使用显式前向时间中心空间格式的有限差分法 (FDM) 来近似温度场。定义傅里叶数 (Fo) 为\n$$\nFo = \\frac{\\alpha\\,\\Delta t}{\\Delta x^2},\n$$\n其中 $\\Delta x$ 是空间步长，$\\Delta t$ 是时间步长。在一维空间中，显式格式要求 $Fo \\le \\frac{1}{2}$ 以保证稳定性。\n\n基于上述物理定律和定义，计划并执行在以下场景下的网格加密研究，并计算观测到的收敛率。对于每个场景，将解近似到时间 $t_{\\text{end}}$，比较数值解场 $T_{\\text{num}}(x,t_{\\text{end}})$ 与精确解场 $T_{\\text{exact}}(x,t_{\\text{end}})$，并将误差定义为内部均匀间隔网格点上的离散 $L^2$-范数，\n$$\nE = \\left( \\sum_{i=1}^{N-1} \\left[T_{\\text{num}}(x_i,t_{\\text{end}}) - T_{\\text{exact}}(x_i,t_{\\text{end}})\\right]^2 \\Delta x \\right)^{1/2},\n$$\n其中 $x_i = i\\,\\Delta x$（对于 $i = 0,1,\\dots,N$），且 $N = \\frac{L}{\\Delta x}$ 是一个整数。对于每对加密参数 $(\\Delta x_1,\\Delta x_2)$ 或 $(\\Delta t_1,\\Delta t_2)$，通过使用两种分辨率将误差拟合到幂律来估计观测阶数 $p$，\n$$\np = \\frac{\\ln\\!\\left(\\frac{E_2}{E_1}\\right)}{\\ln\\!\\left(\\frac{h_2}{h_1}\\right)},\n$$\n其中 $h$ 表示加密参数（研究空间加密时 $h=\\Delta x$，研究时间加密时 $h=\\Delta t$），$E_1$ 和 $E_2$ 分别是粗网格和细网格上的误差。在所有情况下，均使用整数个时间步；当 $t_{\\text{end}}$ 不是 $\\Delta t$ 的精确倍数时，计算 $t_{\\text{num}} = n \\,\\Delta t$（其中 $n = \\mathrm{round}\\!\\left(\\frac{t_{\\text{end}}}{\\Delta t}\\right)$），并与 $T_{\\text{exact}}(x,t_{\\text{num}})$ 进行比较以确保一致性。\n\n使用具有科学真实性的参数执行以下测试套件。所有具有物理单位的量都已指定；收敛率是无量纲的，必须以纯小数形式报告。\n\n- 测试 1（空间加密，稳定的内部傅里叶数）：\n  - $L = 1$ (米)，$\\alpha = 7.19 \\times 10^{-5}$ (平方米/秒)，$t_{\\text{end}} = 19$ (秒)，$Fo = 0.4$。\n  - 粗空间步长：$\\Delta x_1 = \\frac{L}{50}$，细空间步长：$\\Delta x_2 = \\frac{L}{100}$。\n  - 选择时间步长以保持 $Fo$ 固定：$\\Delta t_j = Fo\\,\\frac{\\Delta x_j^2}{\\alpha}$，对于 $j \\in \\{1,2\\}$。\n  - 返回观测到的空间收敛率 $p_{\\text{space},\\,0.4}$。\n\n- 测试 2（空间加密，边界稳定性傅里叶数）：\n  - $L = 1$ (米)，$\\alpha = 7.19 \\times 10^{-5}$ (平方米/秒)，$t_{\\text{end}} = 19$ (秒)，$Fo = 0.5$。\n  - 粗空间步长：$\\Delta x_1 = \\frac{L}{50}$，细空间步长：$\\Delta x_2 = \\frac{L}{100}$。\n  - 选择时间步长以保持 $Fo$ 固定：$\\Delta t_j = Fo\\,\\frac{\\Delta x_j^2}{\\alpha}$，对于 $j \\in \\{1,2\\}$。\n  - 返回观测到的空间收敛率 $p_{\\text{space},\\,0.5}$。\n\n- 测试 3（固定空间分辨率下的时间加密）：\n  - $L = 1$ (米)，$\\alpha = 7.19 \\times 10^{-5}$ (平方米/秒)，$t_{\\text{end}} = 19$ (秒)。\n  - 固定空间步长：$\\Delta x = \\frac{L}{100}$。\n  - 粗时间步长：$\\Delta t_1 = 0.556$ (秒)，细时间步长：$\\Delta t_2 = 0.278$ (秒)。\n  - 返回观测到的时间收敛率 $p_{\\text{time}}$。\n\n您的程序必须计算这三个收敛率，并生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[p_{\\text{space},\\,0.4}, p_{\\text{space},\\,0.5}, p_{\\text{time}}]$。由于这些收敛率是无量纲的，请将它们表示为不带任何单位的小数，并在程序中将它们四舍五入到最终输出的六位小数。",
            "solution": "该问题要求对一维瞬态热传导方程进行数值求解，\n$$\n\\frac{\\partial T(x,t)}{\\partial t} = \\alpha \\,\\frac{\\partial^2 T(x,t)}{\\partial x^2}\n$$\n在空间域 $x \\in [0,L]$ 上，使用齐次狄利克雷边界条件 $T(0,t)=T(L,t)=0$ 和初始条件 $T(x,0) = \\sin(\\pi x / L)$。\n\n数值方法是使用显式前向时间中心空间 (FTCS) 格式的有限差分法 (FDM)。令离散网格点 $x_i = i\\,\\Delta x$ 和时间 $t_n = n\\,\\Delta t$ 处的温度表示为 $T_i^n$。热方程的 FTCS 离散化是通过用一阶前向差分近似时间导数，用二阶中心差分近似空间导数得出的：\n$$\n\\frac{T_i^{n+1} - T_i^n}{\\Delta t} = \\alpha \\left( \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{\\Delta x^2} \\right)\n$$\n其中 $i = 1, \\dots, N-1$ 是内部空间索引，且 $N=L/\\Delta x$。重新整理以求解下一时间步的温度 $T_i^{n+1}$，得到显式更新规则：\n$$\nT_i^{n+1} = T_i^n + \\frac{\\alpha\\,\\Delta t}{\\Delta x^2} \\left( T_{i+1}^n - 2T_i^n + T_{i-1}^n \\right)\n$$\n引入无量纲的傅里叶数 $Fo = \\frac{\\alpha\\,\\Delta t}{\\Delta x^2}$，更新方程简化为：\n$$\nT_i^{n+1} = T_i^n + Fo \\left( T_{i+1}^n - 2T_i^n + T_{i-1}^n \\right) = Fo\\,T_{i-1}^n + (1 - 2Fo)T_i^n + Fo\\,T_{i+1}^n\n$$\n已知此格式仅在傅里叶数满足条件 $Fo \\le 1/2$ 时才稳定。所有指定的测试用例都遵守此稳定性约束。\n\n对于给定的一组参数 $(\\Delta x, \\Delta t)$，解决该问题的总体算法如下：\n1.  建立计算网格。空间区间数为 $N = L/\\Delta x$。空间网格点为 $x_i = i\\,\\Delta x$，其中 $i=0, 1, \\dots, N$。\n2.  使用给定的初始条件在时间 $t=0$ 初始化温度场：对于所有 $i$，$T_i^0 = \\sin(\\pi x_i/L)$。\n3.  确定总时间步数。根据规定，步数为 $n_{\\text{steps}} = \\mathrm{round}(t_{\\text{end}}/\\Delta t)$。因此，最终模拟时间为 $t_{\\text{num}} = n_{\\text{steps}}\\,\\Delta t$。\n4.  从时间步 $n=0$ 迭代到 $n=n_{\\text{steps}}-1$。在每一步中，使用 FTCS 更新规则为所有内部点 $i=1, \\dots, N-1$ 计算温度场 $T^{n+1}$（从 $T^n$ 计算得出）。在每一步都强制施加边界条件 $T_0^{n+1}=0$ 和 $T_N^{n+1}=0$。\n5.  在最后一个时间步之后，在相同的空间网格上计算数值结束时间 $t_{\\text{num}}$ 处的精确解：$T_{\\text{exact}}(x_i, t_{\\text{num}}) = \\sin(\\pi x_i / L) \\exp(-\\alpha (\\pi/L)^2 t_{\\text{num}})$。\n6.  使用提供的公式计算内部网格点上误差的离散 $L^2$-范数 $E$：\n    $$\n    E = \\left( \\sum_{i=1}^{N-1} \\left[T_i^{n_{\\text{steps}}} - T_{\\text{exact}}(x_i, t_{\\text{num}})\\right]^2 \\Delta x \\right)^{1/2}\n    $$\n对于每个测试，运行两次模拟：一次使用粗离散化参数（$h_1$，即 $\\Delta x_1$ 或 $\\Delta t_1$），另一次使用加密参数 ($h_2$) 。然后使用相应的误差 $E_1$ 和 $E_2$ 来计算观测到的收敛阶数 $p$：\n$$\np = \\frac{\\ln(E_2/E_1)}{\\ln(h_2/h_1)}\n$$\n\nFTCS 格式的理论截断误差为 $O(\\Delta t, \\Delta x^2)$。\n- 对于空间加密测试（测试1和2），时间步长 $\\Delta t$ 通过固定的傅里叶数与空间步长 $\\Delta x$ 耦合，$\\Delta t = Fo\\,\\Delta x^2/\\alpha$。因此，总误差预计将与 $\\Delta x^2$ 成比例，理论收敛率为 $p_{\\text{space}}=2$。\n- 对于时间加密测试（测试3），$\\Delta x$ 保持不变，而 $\\Delta t$ 变化。因此，误差由时间上的一阶项主导，理论收敛率为 $p_{\\text{time}}=1$。\n\n程序将对三个指定的测试用例执行这些步骤，以确定观测到的收敛率 $p_{\\text{space},\\,0.4}$、$p_{\\text{space},\\,0.5}$ 和 $p_{\\text{time}}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(L, alpha, t_end, delta_x, delta_t):\n    \"\"\"\n    Runs a single 1D transient heat conduction simulation using the FTCS scheme.\n\n    Args:\n        L (float): Length of the spatial domain.\n        alpha (float): Thermal diffusivity.\n        t_end (float): Target end time for the simulation.\n        delta_x (float): Spatial step size.\n        delta_t (float): Time step size.\n\n    Returns:\n        float: The discrete L2-norm of the error.\n    \"\"\"\n    # 1. Establish grid and parameters\n    # As per problem, N = L/delta_x is an integer.\n    N = int(round(L / delta_x))\n    x = np.linspace(0, L, N + 1)\n    Fo = alpha * delta_t / delta_x**2\n\n    # Stability check (problem statement ensures this, but good practice)\n    if Fo > 0.5:\n        raise ValueError(f\"Stability condition not met: Fo = {Fo} > 0.5\")\n\n    # 2. Initialize temperature field\n    T = np.sin(np.pi * x / L)\n\n    # 3. Determine number of time steps and final numerical time\n    n_steps = int(round(t_end / delta_t))\n    t_num = n_steps * delta_t\n\n    # 4. Time-stepping loop\n    for _ in range(n_steps):\n        # Use a copy to store the new values\n        T_new = T.copy()\n        # Apply FTCS update rule for interior points\n        T_new[1:-1] = T[1:-1] + Fo * (T[2:] - 2 * T[1:-1] + T[:-2])\n        T = T_new\n        # Boundary conditions T(0)=0 and T(L)=0 are maintained as endpoints are not updated\n\n    # 5. Compute exact solution at the final numerical time\n    T_exact = np.sin(np.pi * x / L) * np.exp(-alpha * (np.pi / L)**2 * t_num)\n\n    # 6. Calculate the discrete L2-norm of the error over interior points\n    # (T[1:-1] - T_exact[1:-1]) is the vector of differences at interior points\n    error_sq_sum = np.sum((T[1:-1] - T_exact[1:-1])**2)\n    error = np.sqrt(error_sq_sum * delta_x)\n    \n    return error\n\ndef calculate_convergence_rate(E1, E2, h1, h2):\n    \"\"\"Calculates the observed order of convergence p.\"\"\"\n    return np.log(E2 / E1) / np.log(h2 / h1)\n\ndef solve():\n    \"\"\"\n    Executes the mesh refinement study as described in the problem statement.\n    \"\"\"\n    # Common parameters\n    L = 1.0  # meter\n    alpha = 7.19e-5  # meter^2/s\n    t_end = 19.0  # second\n\n    results = []\n\n    # Test 1: Spatial refinement with Fo = 0.4\n    Fo_1 = 0.4\n    dx1_1 = L / 50.0\n    dx1_2 = L / 100.0\n    dt1_1 = Fo_1 * dx1_1**2 / alpha\n    dt1_2 = Fo_1 * dx1_2**2 / alpha\n    E1_1 = run_simulation(L, alpha, t_end, dx1_1, dt1_1)\n    E1_2 = run_simulation(L, alpha, t_end, dx1_2, dt1_2)\n    p_space_04 = calculate_convergence_rate(E1_1, E1_2, dx1_1, dx1_2)\n    results.append(p_space_04)\n\n    # Test 2: Spatial refinement with Fo = 0.5\n    Fo_2 = 0.5\n    dx2_1 = L / 50.0\n    dx2_2 = L / 100.0\n    dt2_1 = Fo_2 * dx2_1**2 / alpha\n    dt2_2 = Fo_2 * dx2_2**2 / alpha\n    E2_1 = run_simulation(L, alpha, t_end, dx2_1, dt2_1)\n    E2_2 = run_simulation(L, alpha, t_end, dx2_2, dt2_2)\n    p_space_05 = calculate_convergence_rate(E2_1, E2_2, dx2_1, dx2_2)\n    results.append(p_space_05)\n    \n    # Test 3: Temporal refinement at fixed spatial resolution\n    dx3 = L / 100.0\n    dt3_1 = 0.556\n    dt3_2 = 0.278\n    E3_1 = run_simulation(L, alpha, t_end, dx3, dt3_1)\n    E3_2 = run_simulation(L, alpha, t_end, dx3, dt3_2)\n    p_time = calculate_convergence_rate(E3_1, E3_2, dt3_1, dt3_2)\n    results.append(p_time)\n\n    # Format and print the final output\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}