{
    "hands_on_practices": [
        {
            "introduction": "This first practice guides you through the core process of translating the 1D heat equation into a working computer code using the explicit Forward-Time Centered-Space (FTCS) scheme. You will not only implement the time-stepping algorithm but also confront the crucial concept of numerical stability, governed by the Fourier number $Fo$. This exercise () builds the fundamental skill set needed for solving transient diffusion problems and verifying your results against an exact analytical solution.",
            "id": "3952352",
            "problem": "Consider a one-dimensional transient heat conduction problem in a homogeneous rod of length $L$ with fixed-temperature (Dirichlet) boundary conditions at both ends. Let $T(x,t)$ denote the temperature field, $\\alpha$ the thermal diffusivity (in $\\mathrm{m}^2/\\mathrm{s}$), and assume a uniform spatial partition with $N$ nodes, spacing $\\Delta x = L/(N-1)$. The rod ends at $x=0$ and $x=L$ are held at constant temperatures, and the initial temperature distribution is a single spatial eigenmode with amplitude $A$ expressed using the sine function. Angles must be treated in radians.\n\nStarting from the one-dimensional heat equation $ \\partial T / \\partial t = \\alpha \\, \\partial^2 T / \\partial x^2 $, derive a Forward-Time Centered-Space (FTCS) explicit finite difference scheme. Use a forward difference in time and a centered second-difference in space on the uniform grid described. Clearly derive the discrete update at interior nodes in terms of the Fourier number $Fo$, where $Fo$ must be defined directly from the discretization parameters and material properties. Impose the Dirichlet boundary conditions at all time levels.\n\nPerform a stability analysis based on a standard mode-amplification approach appropriate for linear constant-coefficient partial differential equations. Express the amplification factor in terms of $Fo$ and spatial wavenumber, and derive the condition on $Fo$ ensuring bounded amplification for all admissible discrete spatial modes. Use this condition to implement an a priori stability check in your algorithm.\n\nDesign and implement an algorithm that:\n- Constructs the spatial grid and initializes the temperature field using $T(x,0) = A \\, \\sin(m \\pi x / L)$ for a specified integer mode index $m$ compatible with the Dirichlet boundary conditions.\n- Advances the solution in time to a final time $t_f$ using the explicit FTCS scheme, enforcing boundary values at each step.\n- Evaluates the exact analytical solution at $t_f$ for the chosen initial mode, and computes the maximum absolute error between the numerical and exact solutions over the grid.\n- Reports a stability flag indicating whether the $Fo$ chosen satisfies the derived stability condition, along with quantitative diagnostics.\n\nPhysical units:\n- Report temperatures in Kelvin.\n- Report times in seconds.\n- Report lengths in meters.\n- Angles in the sine function must be in radians.\n\nYour program must implement loop-based updates over time steps and spatial nodes. For each test case, it must output a list of values containing, in order:\n- A boolean stability flag using the derived $Fo$ criterion.\n- A float equal to the maximum absolute error at $t_f$ in Kelvin.\n- A float equal to the maximum absolute temperature magnitude at $t_f$ in Kelvin.\n- A float equal to $t_f$ in seconds.\n\nTest suite:\n- Test Case 1 (happy path): $L = 1.0$ $\\mathrm{m}$, $\\alpha = 1.0 \\times 10^{-4}$ $\\mathrm{m}^2/\\mathrm{s}$, $N=41$, $\\Delta t = 0.1$ $\\mathrm{s}$, $t_f = 1.0$ $\\mathrm{s}$, $A=1.0$ $\\mathrm{K}$, $m=1$.\n- Test Case 2 (boundary condition on stability): $L = 1.0$ $\\mathrm{m}$, $\\alpha = 1.0 \\times 10^{-4}$ $\\mathrm{m}^2/\\mathrm{s}$, $N=101$, $\\Delta t = 0.5$ $\\mathrm{s}$, $t_f = 5.0$ $\\mathrm{s}$, $A=1.0$ $\\mathrm{K}$, $m=1$.\n- Test Case 3 (edge case probing instability with high-frequency content): $L = 1.0$ $\\mathrm{m}$, $\\alpha = 1.0 \\times 10^{-4}$ $\\mathrm{m}^2/\\mathrm{s}$, $N=101$, $\\Delta t = 0.6$ $\\mathrm{s}$, $t_f = 3.0$ $\\mathrm{s}$, $A=1.0$ $\\mathrm{K}$, $m=N-2$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element corresponds to a test case and must itself be a list in the order specified above. For example: $[ [\\text{flag}_1, \\text{err}_1, \\text{maxT}_1, \\text{t}_1], [\\text{flag}_2, \\text{err}_2, \\text{maxT}_2, \\text{t}_2], [\\text{flag}_3, \\text{err}_3, \\text{maxT}_3, \\text{t}_3] ]$.",
            "solution": "The problem requires the derivation, stability analysis, and implementation of the Forward-Time Centered-Space (FTCS) explicit finite difference method for the one-dimensional transient heat conduction equation. The solution is then compared against a known analytical solution to assess its accuracy.\n\nThe governing partial differential equation (PDE) for one-dimensional heat conduction is:\n$$ \\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2} $$\nwhere $T(x,t)$ is the temperature at spatial coordinate $x$ and time $t$, and $\\alpha$ is the thermal diffusivity of the material. The problem is defined on a spatial domain $x \\in [0, L]$ with homogeneous Dirichlet boundary conditions, $T(0, t) = 0$ and $T(L, t) = 0$. The initial temperature distribution is given as a single spatial eigenmode:\n$$ T(x,0) = A \\sin\\left(\\frac{m \\pi x}{L}\\right) $$\nwhere $A$ is the amplitude and $m$ is an integer mode index.\n\nFirst, we derive the FTCS finite difference scheme. We discretize the domain into a uniform grid with $N$ spatial nodes, indexed by $i=0, 1, \\dots, N-1$, such that $x_i = i \\Delta x$, where the spatial step is $\\Delta x = L/(N-1)$. Time is discretized with a constant step $\\Delta t$, such that $t_n = n \\Delta t$. The temperature at a grid point $(x_i, t_n)$ is denoted by $T_i^n$.\n\nThe time derivative $\\partial T/\\partial t$ is approximated using a first-order accurate forward difference:\n$$ \\frac{\\partial T}{\\partial t} \\bigg|_{i,n} \\approx \\frac{T_i^{n+1} - T_i^n}{\\Delta t} $$\nThe spatial second derivative $\\partial^2 T/\\partial x^2$ is approximated using a second-order accurate centered difference:\n$$ \\frac{\\partial^2 T}{\\partial x^2} \\bigg|_{i,n} \\approx \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{(\\Delta x)^2} $$\nSubstituting these approximations into the governing PDE yields the FTCS scheme:\n$$ \\frac{T_i^{n+1} - T_i^n}{\\Delta t} = \\alpha \\left( \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{(\\Delta x)^2} \\right) $$\nThis equation can be rearranged to provide an explicit update rule for the temperature at the next time level, $T_i^{n+1}$, based on temperatures at the current level, $T^n$:\n$$ T_i^{n+1} = T_i^n + \\frac{\\alpha \\Delta t}{(\\Delta x)^2} (T_{i+1}^n - 2T_i^n + T_{i-1}^n) $$\nWe define the non-dimensional Fourier number, $Fo$, as:\n$$ Fo = \\frac{\\alpha \\Delta t}{(\\Delta x)^2} $$\nThe update equation for interior nodes ($i=1, \\dots, N-2$) is concisely written as:\n$$ T_i^{n+1} = T_i^n + Fo (T_{i+1}^n - 2T_i^n + T_{i-1}^n) = (1 - 2Fo)T_i^n + Fo(T_{i-1}^n + T_{i+1}^n) $$\n\nNext, we perform a von Neumann stability analysis to determine the constraints on $Fo$ for a stable solution. We consider the propagation of a single Fourier mode of the numerical solution, $T_i^n = G^n e^{\\mathrm{j}k_w x_i}$, where $G$ is the amplification factor per time step, $k_w$ is the spatial wavenumber, and $\\mathrm{j}=\\sqrt{-1}$. Substituting this into the discretized equation:\n$$ G^{n+1} e^{\\mathrm{j}k_w x_i} = (1 - 2Fo) G^n e^{\\mathrm{j}k_w x_i} + Fo (G^n e^{\\mathrm{j}k_w x_{i-1}} + G^n e^{\\mathrm{j}k_w x_{i+1}}) $$\nDividing by $G^n e^{\\mathrm{j}k_w x_i}$ and using $x_{i\\pm1} = x_i \\pm \\Delta x$:\n$$ G = (1 - 2Fo) + Fo (e^{-\\mathrm{j}k_w \\Delta x} + e^{\\mathrm{j}k_w \\Delta x}) $$\nUsing Euler's identity, $e^{\\mathrm{j}\\theta} + e^{-\\mathrm{j}\\theta} = 2\\cos(\\theta)$, we get:\n$$ G = 1 - 2Fo + 2Fo \\cos(k_w \\Delta x) = 1 - 2Fo(1 - \\cos(k_w \\Delta x)) $$\nWith the half-angle identity $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$:\n$$ G = 1 - 4Fo\\sin^2\\left(\\frac{k_w \\Delta x}{2}\\right) $$\nFor stability, the magnitude of the amplification factor must not exceed unity for all possible wavenumbers, i.e., $|G| \\le 1$. This implies $-1 \\le G \\le 1$.\nThe condition $G \\le 1$ is always satisfied, since $Fo > 0$ and $\\sin^2(\\cdot) \\ge 0$.\nThe condition $G \\ge -1$ provides the stability constraint:\n$$ 1 - 4Fo\\sin^2\\left(\\frac{k_w \\Delta x}{2}\\right) \\ge -1 $$\n$$ 2 \\ge 4Fo\\sin^2\\left(\\frac{k_w \\Delta x}{2}\\right) \\implies Fo \\le \\frac{1}{2\\sin^2\\left(\\frac{k_w \\Delta x}{2}\\right)} $$\nThis constraint must hold for all wavenumbers. The most restrictive case occurs when $\\sin^2(k_w \\Delta x / 2)$ is maximum, which is $1$. This corresponds to the highest frequency mode resolvable on the grid, where $k_w \\Delta x = \\pi$. This yields the final stability criterion for the FTCS scheme:\n$$ Fo \\le \\frac{1}{2} $$\n\nThe analytical solution to the PDE with the given initial and boundary conditions can be found using separation of variables. Since the initial condition is already a single eigenfunction $\\sin(m \\pi x / L)$ of the spatial operator with the given boundary conditions, the time evolution is an exponential decay of this mode:\n$$ T_{\\text{exact}}(x,t) = A \\sin\\left(\\frac{m \\pi x}{L}\\right) \\exp\\left(-\\alpha \\left(\\frac{m \\pi}{L}\\right)^2 t\\right) $$\nThis exact solution is used to compute the error of the numerical scheme.\n\nThe algorithm proceeds as follows:\n1. For each test case, define the parameters $L, \\alpha, N, \\Delta t, t_f, A, m$.\n2. Compute derived grid parameters $\\Delta x = L/(N-1)$ and the Fourier number $Fo = \\alpha \\Delta t / (\\Delta x)^2$.\n3. Perform an a priori stability check: if $Fo \\le 0.5$, the scheme is stable.\n4. Initialize a spatial grid $x$ and the temperature array $T$ according to the initial condition $T(x,0)$.\n5. Iterate in time from $t=0$ to $t_f$. In each time step, create a copy of the current temperature field. Then, loop over all interior spatial nodes ($i=1, \\dots, N-2$) and update the temperature using the FTCS formula. The boundary temperatures at $i=0$ and $i=N-1$ remain fixed at $0$.\n6. After the final time step, calculate the exact solution $T_{\\text{exact}}(x,t_f)$.\n7. Compute the maximum absolute error, $\\max_i |T_i - T_{\\text{exact}}(x_i, t_f)|$, and the maximum absolute temperature magnitude, $\\max_i |T_i|$, from the numerical solution.\n8. Report the stability flag, maximum absolute error, maximum absolute temperature, and final time $t_f$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D transient heat conduction problem using an explicit FTCS scheme\n    for a series of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, alpha, N, dt, tf, A, m)\n        (1.0, 1.0e-4, 41, 0.1, 1.0, 1.0, 1),\n        (1.0, 1.0e-4, 101, 0.5, 5.0, 1.0, 1),\n        (1.0, 1.0e-4, 101, 0.6, 3.0, 1.0, 101 - 2),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, alpha, N, dt, tf, A, m = case\n\n        # 1. Setup grid and parameters\n        dx = L / (N - 1)\n        x = np.linspace(0.0, L, N)\n        Fo = alpha * dt / (dx**2)\n\n        # 2. Stability Check\n        is_stable = Fo <= 0.5\n\n        # 3. Initialization\n        T = A * np.sin(m * np.pi * x / L)\n        \n        # Dirichlet boundary conditions are fixed at T=0.\n        # They are correctly set by the initial condition and will not be\n        # updated in the spatial loop.\n        T[0] = 0.0\n        T[-1] = 0.0\n\n        # 4. Time Marching Loop\n        # The problem requires loop-based updates.\n        num_steps = int(round(tf / dt))\n        \n        for n in range(num_steps):\n            T_old = T.copy()\n            # Loop over interior nodes\n            for i in range(1, N - 1):\n                T[i] = T_old[i] + Fo * (T_old[i+1] - 2 * T_old[i] + T_old[i-1])\n\n        # 5. Final Calculations\n        # The final simulation time is num_steps * dt, which equals tf for these cases.\n        t_final = num_steps * dt\n\n        # Analytical solution at t_final\n        decay_term = np.exp(-alpha * (m * np.pi / L)**2 * t_final)\n        T_exact = A * np.sin(m * np.pi * x / L) * decay_term\n\n        # Metrics\n        # In case of instability, T can become NaN\n        if np.isnan(T).any():\n            max_abs_error = float('inf')\n            max_abs_temp = float('inf')\n        else:\n            max_abs_error = np.max(np.abs(T - T_exact))\n            max_abs_temp = np.max(np.abs(T))\n\n        results.append([is_stable, max_abs_error, max_abs_temp, tf])\n\n    # Final print statement in the exact required format.\n    # str() on a list of lists produces the required format with spaces.\n    # The join(map(...)) idiom is more complex and produces a slightly different\n    # spacing, so we use the simpler and more standard str() conversion.\n    print(str(results).replace(\"'\", '\"'))\n\nsolve()\n\n```"
        },
        {
            "introduction": "Building on the foundational solver, this practice introduces two common complexities: internal heat generation and insulated (Neumann) boundary conditions. You will learn how to modify the finite difference equations to account for a source term and how to correctly implement the boundary conditions, a common task in modeling systems with internal heat sources or perfectly insulated walls. This exercise () is crucial for expanding your solver's capability to handle more realistic physical scenarios.",
            "id": "3952400",
            "problem": "Consider one-dimensional transient heat conduction with constant volumetric internal heat generation in a homogeneous slab. Starting from the conservation of energy in a differential control volume and Fourierâ€™s law of heat conduction, the governing equation for temperature evolution is\n$$\n\\rho c \\,\\frac{\\partial T}{\\partial t} = k \\,\\frac{\\partial^2 T}{\\partial x^2} + q''',\n$$\nfor $x \\in [0,L]$ and $t \\ge 0$, where $T$ is temperature, $k$ is thermal conductivity, $\\rho$ is density, $c$ is specific heat capacity, and $q'''$ is constant volumetric heat generation. The boundaries are perfectly insulated, so the Neumann boundary conditions are\n$$\n\\frac{\\partial T}{\\partial x}(0,t) = 0, \\quad \\frac{\\partial T}{\\partial x}(L,t) = 0.\n$$\nYou are to use the Finite Difference Method (FDM) with an explicit time integration scheme (forward Euler in time and second-order central differencing in space) to numerically solve the above problem for the provided test suite. Implement the insulated boundary conditions consistently within the explicit scheme. Then, compute the exact analytical solution for the particular initial conditions given in each test case by separating the spatially uniform component (driven by internal generation) and the spatially varying component (which evolves under diffusion with insulated boundaries). Use the exact solution as a reference to evaluate the numerical error.\n\nAngle-dependent functions must use radians. All physical units must be respected: length in meters ($\\mathrm{m}$), time in seconds ($\\mathrm{s}$), temperature in kelvin ($\\mathrm{K}$), thermal conductivity in watts per meter-kelvin ($\\mathrm{W/(m\\,K)}$), density in kilograms per cubic meter ($\\mathrm{kg/m^3}$), specific heat capacity in joules per kilogram-kelvin ($\\mathrm{J/(kg\\,K)}$), and volumetric heat generation in watts per cubic meter ($\\mathrm{W/m^3}$). Express the final numerical errors in kelvin.\n\nDefine the thermal diffusivity as\n$$\n\\alpha = \\frac{k}{\\rho c}.\n$$\nDefine the Fourier number as\n$$\nFo = \\frac{\\alpha\\,\\Delta t}{\\Delta x^2},\n$$\nwhere $\\Delta x$ is the uniform spatial step and $\\Delta t$ is the uniform time step. Use the provided $Fo$ values to set $\\Delta t$ via $\\Delta t = Fo\\,\\Delta x^2/\\alpha$.\n\nFor each test case, proceed as follows:\n- Discretize the domain $[0,L]$ with $N$ equally spaced nodes.\n- Initialize $T(x,0)$ as specified.\n- Advance the explicit scheme for $n_{\\text{steps}}$ time steps, where $n_{\\text{steps}}$ is chosen so that $t_{\\text{sim}} = n_{\\text{steps}}\\,\\Delta t$ matches the provided final time $t_{\\text{final}}$ exactly or to within numerical rounding where $t_{\\text{final}}/\\Delta t$ is an integer by construction in the test suite.\n- Compute the exact solution $T_{\\text{exact}}(x,t_{\\text{sim}})$ for the specified initial condition and insulated boundaries with constant $q'''$.\n- Report the maximum absolute error $E = \\max_{x} \\left|T_{\\text{num}}(x,t_{\\text{sim}}) - T_{\\text{exact}}(x,t_{\\text{sim}})\\right|$ in kelvin.\n\nTest suite:\n- Test Case $1$ (uniform initial condition, happy path):\n  - $L = 0.02\\,\\mathrm{m}$, $k = 200\\,\\mathrm{W/(m\\,K)}$, $\\rho = 7800\\,\\mathrm{kg/m^3}$, $c = 500\\,\\mathrm{J/(kg\\,K)}$, $q''' = 1.0\\times 10^6\\,\\mathrm{W/m^3}$.\n  - $N = 41$, $Fo = 0.4$, $t_{\\text{final}} = 1.95\\,\\mathrm{s}$.\n  - Initial condition: $T(x,0) = T_0$ with $T_0 = 300\\,\\mathrm{K}$ (spatially uniform).\n- Test Case $2$ (single-mode nonuniform initial condition, stability boundary):\n  - $L = 0.1\\,\\mathrm{m}$, $k = 25\\,\\mathrm{W/(m\\,K)}$, $\\rho = 1000\\,\\mathrm{kg/m^3}$, $c = 1000\\,\\mathrm{J/(kg\\,K)}$, $q''' = 5.0\\times 10^5\\,\\mathrm{W/m^3}$.\n  - $N = 101$, $Fo = 0.5$, $t_{\\text{final}} = 2.0\\,\\mathrm{s}$.\n  - Initial condition: $T(x,0) = T_0 + A\\cos\\!\\big(\\pi x/L\\big)$ with $T_0 = 300\\,\\mathrm{K}$, $A = 10\\,\\mathrm{K}$.\n- Test Case $3$ (long-time behavior, higher spatial mode):\n  - $L = 0.05\\,\\mathrm{m}$, $k = 15\\,\\mathrm{W/(m\\,K)}$, $\\rho = 850\\,\\mathrm{kg/m^3}$, $c = 2000\\,\\mathrm{J/(kg\\,K)}$, $q''' = 2.0\\times 10^5\\,\\mathrm{W/m^3}$.\n  - $N = 51$, $Fo = 0.5$, $t_{\\text{final}} = 56.6666666667\\,\\mathrm{s}$.\n  - Initial condition: $T(x,0) = T_0 + A\\cos\\!\\big(2\\pi x/L\\big)$ with $T_0 = 300\\,\\mathrm{K}$, $A = 20\\,\\mathrm{K}$.\n\nRequired final output format:\nYour program should produce a single line of output containing the maximum absolute errors for the three test cases, in kelvin, as a comma-separated list enclosed in square brackets, with each value rounded to six decimal places, for example, `[0.123456, 0.234567, 0.345678]`. Angles in all cosine functions must be interpreted in radians. The final answers are floats.",
            "solution": "The solution is developed by first discretizing the governing partial differential equation (PDE) and its boundary conditions, then deriving the exact analytical solution for verification, and finally implementing the numerical algorithm to compute the error.\n\n**1. Numerical Discretization (FDM)**\nThe governing equation is $\\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2} + \\frac{q'''}{\\rho c}$. We discretize the spatial domain $[0,L]$ into $N$ nodes, with uniform spacing $\\Delta x = L/(N-1)$. Let $T_i^j$ denote the temperature at node $x_i = i\\Delta x$ and time $t_j = j\\Delta t$.\n\nUsing a forward difference for the time derivative (Forward Euler) and a second-order central difference for the spatial derivative, the PDE is approximated as:\n$$\n\\frac{T_i^{j+1} - T_i^j}{\\Delta t} = \\alpha \\left( \\frac{T_{i+1}^j - 2T_i^j + T_{i-1}^j}{\\Delta x^2} \\right) + \\frac{q'''}{\\rho c}\n$$\nSolving for the temperature at the next time step, $T_i^{j+1}$, gives the explicit update rule for interior nodes ($i = 1, \\dots, N-2$):\n$$\nT_i^{j+1} = T_i^j + \\frac{\\alpha \\Delta t}{\\Delta x^2} (T_{i+1}^j - 2T_i^j + T_{i-1}^j) + \\frac{q'''}{\\rho c} \\Delta t\n$$\nUsing the definition of the Fourier number, $Fo = \\frac{\\alpha \\Delta t}{\\Delta x^2}$, this simplifies to:\n$$\nT_i^{j+1} = T_i^j + Fo (T_{i+1}^j - 2T_i^j + T_{i-1}^j) + \\frac{q'''}{\\rho c} \\Delta t\n$$\nThe explicit nature of this scheme imposes a stability constraint, $Fo \\le 0.5$, which is satisfied by all test cases.\n\n**2. Implementation of Insulated Boundary Conditions**\nThe Neumann boundary conditions $\\frac{\\partial T}{\\partial x} = 0$ at $x=0$ and $x=L$ are handled using the method of \"ghost nodes\" to maintain second-order spatial accuracy.\n- At the left boundary ($x=0$, node $i=0$), we imagine a ghost node at $x_{-1} = -\\Delta x$. A central difference for the gradient is $\\frac{T_1^j - T_{-1}^j}{2\\Delta x} = 0$, which implies $T_{-1}^j = T_1^j$. Substituting this into the general update rule for $i=0$:\n$$\nT_0^{j+1} = T_0^j + Fo (T_1^j - 2T_0^j + T_{-1}^j) + \\frac{q''' \\Delta t}{\\rho c} = T_0^j + Fo (T_1^j - 2T_0^j + T_1^j) + \\frac{q''' \\Delta t}{\\rho c}\n$$\n$$\nT_0^{j+1} = T_0^j + 2Fo(T_1^j - T_0^j) + \\frac{q''' \\Delta t}{\\rho c}\n$$\n- At the right boundary ($x=L$, node $i=N-1$), a ghost node at $x_N = L+\\Delta x$ gives $T_N^j = T_{N-2}^j$. The update rule becomes:\n$$\nT_{N-1}^{j+1} = T_{N-1}^j + Fo (T_N^j - 2T_{N-1}^j + T_{N-2}^j) + \\frac{q''' \\Delta t}{\\rho c} = T_{N-1}^j + Fo (T_{N-2}^j - 2T_{N-1}^j + T_{N-2}^j) + \\frac{q''' \\Delta t}{\\rho c}\n$$\n$$\nT_{N-1}^{j+1} = T_{N-1}^j + 2Fo(T_{N-2}^j - T_{N-1}^j) + \\frac{q''' \\Delta t}{\\rho c}\n$$\n\n**3. Analytical Solution**\nThe analytical solution is found by decomposing the temperature $T(x,t)$ into a spatially averaged component $\\bar{T}(t)$ and a spatially varying component $T_{var}(x,t)$ with zero spatial average.\n$$\nT(x,t) = \\bar{T}(t) + T_{var}(x,t)\n$$\nIntegrating the governing PDE over the domain length $L$ and applying the insulated boundary conditions demonstrates that the average temperature evolves according to:\n$$\n\\frac{d\\bar{T}}{dt} = \\frac{q'''}{\\rho c} \\implies \\bar{T}(t) = \\bar{T}(0) + \\frac{q'''}{\\rho c} t\n$$\nwhere $\\bar{T}(0) = \\frac{1}{L}\\int_0^L T(x,0) dx$ is the initial average temperature. The spatially varying component $T_{var}(x,t)$ must then satisfy the homogeneous heat equation with the same insulated boundaries:\n$$\n\\frac{\\partial T_{var}}{\\partial t} = \\alpha \\frac{\\partial^2 T_{var}}{\\partial x^2}\n$$\nThe general solution for this homogeneous problem is a Fourier cosine series:\n$$\nT_{var}(x,t) = \\sum_{n=1}^{\\infty} A_n \\cos\\left(\\frac{n\\pi x}{L}\\right) e^{-\\alpha (n\\pi/L)^2 t}\n$$\nThe coefficients $A_n$ are determined from the initial condition $T_{var}(x,0) = T(x,0) - \\bar{T}(0)$.\nFor the specific initial conditions provided, $T(x,0) = T_0 + A\\cos(m\\pi x/L)$ for $m \\in \\{0, 1, 2\\}$, the initial average temperature is $\\bar{T}(0) = T_0$. The Fourier series reduces to a single term corresponding to the given mode. The full analytical solution is:\n$$\nT_{\\text{exact}}(x,t) = T_0 + \\frac{q'''}{\\rho c} t + A \\cos\\left(\\frac{m\\pi x}{L}\\right) e^{-\\alpha (m\\pi/L)^2 t}\n$$\n- For Test Case 1: $m=0$ (or $A=0$), so the cosine term vanishes. $T_{\\text{exact}}(x,t) = T_0 + \\frac{q'''}{\\rho c} t$.\n- For Test Case 2: $m=1$.\n- For Test Case 3: $m=2$.\n\n**4. Algorithm**\nThe numerical solution is computed as follows:\n1. For each test case, define all physical ($L, k, \\rho, c, q'''$) and numerical ($N, Fo$) parameters, along with the initial condition parameters ($T_0, A, m$) and final time $t_{\\text{final}}$.\n2. Calculate derived parameters: $\\alpha = k/(\\rho c)$, $\\Delta x = L/(N-1)$, $\\Delta t = Fo \\cdot \\Delta x^2/\\alpha$, and $n_{\\text{steps}} = \\text{round}(t_{\\text{final}}/\\Delta t)$.\n3. Initialize a temperature array $T$ of size $N$ according to the initial condition $T(x,0)$.\n4. Iterate $n_{\\text{steps}}$ times, updating the temperature array $T$ in each step using the FDM equations for the interior and boundary nodes. A temporary array $T_{old}$ is used to store values from the previous time step.\n5. After the loop, calculate the exact solution $T_{\\text{exact}}$ at $t_{\\text{sim}} = n_{\\text{steps}}\\Delta t$ using the derived analytical formula.\n6. Compute the maximum absolute error $E = \\max(|T - T_{\\text{exact}}|)$.\n7. The computed errors for all test cases are collected and reported.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_analytical_solution(x, t, L, k, rho, c, q_gen, T0, A, m_mode):\n    \"\"\"\n    Computes the analytical solution for the given a single-mode initial condition.\n    T(x,t) = (T0 + q'''*t/(rho*c)) + A*cos(m*pi*x/L)*exp(-alpha*(m*pi/L)^2*t)\n    \"\"\"\n    spatially_uniform_part = T0 + (q_gen / (rho * c)) * t\n\n    if m_mode == 0 or A == 0:\n        spatially_varying_part = 0.0\n    else:\n        alpha = k / (rho * c)\n        exponent = -alpha * (m_mode * np.pi / L)**2 * t\n        spatially_varying_part = A * np.cos(m_mode * np.pi * x / L) * np.exp(exponent)\n        \n    return spatially_uniform_part + spatially_varying_part\n\ndef get_initial_condition(x, L, T0, A, m_mode):\n    \"\"\"\n    Computes the initial temperature profile.\n    T(x,0) = T0 + A*cos(m*pi*x/L)\n    \"\"\"\n    if m_mode == 0 or A == 0:\n        return np.full_like(x, T0)\n    else:\n        return T0 + A * np.cos(m_mode * np.pi * x / L)\n\ndef run_simulation(case):\n    \"\"\"\n    Runs the FDM simulation for a single test case and computes the error.\n    \"\"\"\n    # 1. Extract parameters from the case dictionary\n    L, k, rho, c, q_gen = case['phys']\n    N, Fo, t_final = case['num']\n    T0, A, m_mode = case['ic']\n\n    # 2. Calculate derived numerical parameters\n    alpha = k / (rho * c)\n    dx = L / (N - 1)\n    dt = Fo * dx**2 / alpha\n    # Use round() to handle potential float inaccuracies for t_final/dt\n    n_steps = int(round(t_final / dt))\n    \n    # 3. Setup grid and initial condition\n    x = np.linspace(0, L, N)\n    T = get_initial_condition(x, L, T0, A, m_mode)\n\n    # 4. Perform time-stepping using explicit FDM\n    q_term = (q_gen / (rho * c)) * dt\n    \n    for _ in range(n_steps):\n        T_old = np.copy(T)\n        \n        # Vectorized update for interior nodes\n        T[1:-1] = T_old[1:-1] + Fo * (T_old[2:] - 2*T_old[1:-1] + T_old[:-2]) + q_term\n            \n        # Update boundary nodes (Neumann)\n        T[0] = T_old[0] + 2 * Fo * (T_old[1] - T_old[0]) + q_term\n        T[-1] = T_old[-1] + 2 * Fo * (T_old[-2] - T_old[-1]) + q_term\n\n    # 5. Calculate exact solution for comparison\n    t_sim = n_steps * dt\n    T_exact = get_analytical_solution(x, t_sim, L, k, rho, c, q_gen, T0, A, m_mode)\n\n    # 6. Compute and return maximum absolute error\n    error = np.max(np.abs(T - T_exact))\n    return error\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run simulations, and print results.\n    \"\"\"\n    test_cases = [\n        # Test Case 1: uniform IC, happy path\n        {\n            'phys': (0.02, 200.0, 7800.0, 500.0, 1.0e6), # L, k, rho, c, q'''\n            'num': (41, 0.4, 1.95),                     # N, Fo, t_final\n            'ic': (300.0, 0.0, 0)                        # T0, A, m_mode\n        },\n        # Test Case 2: single-mode IC, stability boundary\n        {\n            'phys': (0.1, 25.0, 1000.0, 1000.0, 5.0e5),\n            'num': (101, 0.5, 2.0),\n            'ic': (300.0, 10.0, 1)\n        },\n        # Test Case 3: long-time, higher spatial mode\n        {\n            'phys': (0.05, 15.0, 850.0, 2000.0, 2.0e5),\n            'num': (51, 0.5, 56.6666666667),\n            'ic': (300.0, 20.0, 2)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        error = run_simulation(case)\n        results.append(f\"{error:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A numerical solution is only useful if we can trust its accuracy. This final practice introduces the essential scientific skill of code verification through a mesh refinement study, a standard procedure in computational fluid dynamics and heat transfer. By systematically refining the grid and analyzing how the error behaves, you will empirically measure the convergence rate of your solver (), providing quantitative evidence that your code is implemented correctly and converges to the true solution at the theoretically predicted rate.",
            "id": "3952361",
            "problem": "Consider the one-dimensional transient heat conduction problem governed by the heat equation on a closed interval with fixed temperature boundaries. The physical model is the standard partial differential equation\n$$\n\\frac{\\partial T(x,t)}{\\partial t} = \\alpha \\,\\frac{\\partial^2 T(x,t)}{\\partial x^2},\n$$\nwhere $T(x,t)$ is the temperature field, $x \\in [0,L]$ is the spatial coordinate, $t \\ge 0$ is time, and $\\alpha$ is the thermal diffusivity. The spatial domain length is $L$, and the thermal diffusivity is $\\alpha$. Boundary conditions are homogeneous Dirichlet,\n$$\nT(0,t) = 0 \\;\\text{and}\\; T(L,t) = 0 \\quad \\text{for all } t \\ge 0,\n$$\nand the initial condition is\n$$\nT(x,0) = \\sin\\!\\left(\\frac{\\pi x}{L}\\right).\n$$\nThis field evolves according to the heat equation; for this specific initial and boundary condition, the exact solution is known to be\n$$\nT_{\\text{exact}}(x,t) = \\sin\\!\\left(\\frac{\\pi x}{L}\\right) \\exp\\!\\left(-\\alpha \\left(\\frac{\\pi}{L}\\right)^2 t\\right).\n$$\n\nUse the Finite Difference Method (FDM) with the explicit forward-time and central-space scheme to approximate the temperature field. Define the Fourier number (Fo) as\n$$\nFo = \\frac{\\alpha\\,\\Delta t}{\\Delta x^2},\n$$\nwhere $\\Delta x$ is the spatial step and $\\Delta t$ is the time step. The explicit scheme in one spatial dimension requires $Fo \\le \\frac{1}{2}$ for stability.\n\nStarting from the preceding physical laws and definitions, plan and execute a mesh refinement study under the following scenarios, and compute the observed convergence rates. For each scenario, approximate the solution to time $t_{\\text{end}}$, compare the numerical field $T_{\\text{num}}(x,t_{\\text{end}})$ against the exact field $T_{\\text{exact}}(x,t_{\\text{end}})$, and define the error as the discrete $L^2$-norm over the interior grid points with uniform spacing,\n$$\nE = \\left( \\sum_{i=1}^{N-1} \\left[T_{\\text{num}}(x_i,t_{\\text{end}}) - T_{\\text{exact}}(x_i,t_{\\text{end}})\\right]^2 \\Delta x \\right)^{1/2},\n$$\nwhere $x_i = i\\,\\Delta x$ for $i = 0,1,\\dots,N$ and $N = \\frac{L}{\\Delta x}$ is an integer. For each refinement pair $(\\Delta x_1,\\Delta x_2)$ or $(\\Delta t_1,\\Delta t_2)$, estimate the observed order $p$ by fitting the error to a power law using two resolutions,\n$$\np = \\frac{\\ln\\!\\left(\\frac{E_2}{E_1}\\right)}{\\ln\\!\\left(\\frac{h_2}{h_1}\\right)},\n$$\nwhere $h$ denotes the refinement parameter ($h=\\Delta x$ when studying spatial refinement, $h=\\Delta t$ when studying temporal refinement), and $E_1$ and $E_2$ are the errors on the coarse and refined grids, respectively. In all cases, use integer numbers of time steps; when $t_{\\text{end}}$ is not an exact multiple of $\\Delta t$, compute $t_{\\text{num}} = n \\,\\Delta t$ with $n = \\mathrm{round}\\!\\left(\\frac{t_{\\text{end}}}{\\Delta t}\\right)$ and compare against $T_{\\text{exact}}(x,t_{\\text{num}})$ to ensure consistency.\n\nPerform the following test suite with scientifically realistic parameters. All quantities with physical units are specified; convergence rates are dimensionless and must be reported as plain decimal numbers.\n\n- Test $1$ (spatial refinement, stable interior Fourier number): \n  - $L = 1$ (meter), $\\alpha = 7.19 \\times 10^{-5}$ (meter squared per second), $t_{\\text{end}} = 19$ (second), $Fo = 0.4$.\n  - Coarse spatial step: $\\Delta x_1 = \\frac{L}{50}$, refined spatial step: $\\Delta x_2 = \\frac{L}{100}$.\n  - Time steps are chosen to keep $Fo$ fixed: $\\Delta t_j = Fo\\,\\frac{\\Delta x_j^2}{\\alpha}$ for $j \\in \\{1,2\\}$.\n  - Return the observed spatial convergence rate $p_{\\text{space},\\,0.4}$.\n\n- Test $2$ (spatial refinement, boundary stability Fourier number):\n  - $L = 1$ (meter), $\\alpha = 7.19 \\times 10^{-5}$ (meter squared per second), $t_{\\text{end}} = 19$ (second), $Fo = 0.5$.\n  - Coarse spatial step: $\\Delta x_1 = \\frac{L}{50}$, refined spatial step: $\\Delta x_2 = \\frac{L}{100}$.\n  - Time steps are chosen to keep $Fo$ fixed: $\\Delta t_j = Fo\\,\\frac{\\Delta x_j^2}{\\alpha}$ for $j \\in \\{1,2\\}$.\n  - Return the observed spatial convergence rate $p_{\\text{space},\\,0.5}$.\n\n- Test $3$ (temporal refinement at fixed spatial resolution): \n  - $L = 1$ (meter), $\\alpha = 7.19 \\times 10^{-5}$ (meter squared per second), $t_{\\text{end}} = 19$ (second).\n  - Fixed spatial step: $\\Delta x = \\frac{L}{100}$.\n  - Coarse time step: $\\Delta t_1 = 0.556$ (second), refined time step: $\\Delta t_2 = 0.278$ (second).\n  - Return the observed temporal convergence rate $p_{\\text{time}}$.\n\nYour program must compute the three rates and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[p_{\\text{space},\\,0.4}, p_{\\text{space},\\,0.5}, p_{\\text{time}}]$. Since these convergence rates are dimensionless, express them as decimal numbers without any unit and round them in the program to six decimal places in the final output.",
            "solution": "The problem requires the numerical solution of the one-dimensional transient heat conduction equation,\n$$\n\\frac{\\partial T(x,t)}{\\partial t} = \\alpha \\,\\frac{\\partial^2 T(x,t)}{\\partial x^2}\n$$\non a spatial domain $x \\in [0,L]$ with homogeneous Dirichlet boundary conditions $T(0,t)=T(L,t)=0$ and an initial condition $T(x,0) = \\sin(\\pi x / L)$.\n\nThe numerical approach is the Finite Difference Method (FDM) using an explicit Forward-Time, Central-Space (FTCS) scheme. Let the temperature at discrete grid point $x_i = i\\,\\Delta x$ and time $t_n = n\\,\\Delta t$ be denoted by $T_i^n$. The FTCS discretization of the heat equation is derived by approximating the time derivative with a first-order forward difference and the spatial derivative with a second-order central difference:\n$$\n\\frac{T_i^{n+1} - T_i^n}{\\Delta t} = \\alpha \\left( \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{\\Delta x^2} \\right)\n$$\nwhere $i = 1, \\dots, N-1$ are the interior spatial indices, with $N=L/\\Delta x$. Rearranging to solve for the temperature at the next time step, $T_i^{n+1}$, gives the explicit update rule:\n$$\nT_i^{n+1} = T_i^n + \\frac{\\alpha\\,\\Delta t}{\\Delta x^2} \\left( T_{i+1}^n - 2T_i^n + T_{i-1}^n \\right)\n$$\nIntroducing the dimensionless Fourier number, $Fo = \\frac{\\alpha\\,\\Delta t}{\\Delta x^2}$, the update equation simplifies to:\n$$\nT_i^{n+1} = T_i^n + Fo \\left( T_{i+1}^n - 2T_i^n + T_{i-1}^n \\right) = Fo\\,T_{i-1}^n + (1 - 2Fo)T_i^n + Fo\\,T_{i+1}^n\n$$\nThis scheme is known to be stable only if the Fourier number satisfies the condition $Fo \\le 1/2$. All specified test cases adhere to this stability constraint.\n\nThe overall algorithm to solve the problem for a given set of parameters $(\\Delta x, \\Delta t)$ is as follows:\n1.  Establish the computational grid. The number of spatial intervals is $N = L/\\Delta x$. The spatial grid points are $x_i = i\\,\\Delta x$ for $i=0, 1, \\dots, N$.\n2.  Initialize the temperature field at time $t=0$ using the given initial condition: $T_i^0 = \\sin(\\pi x_i/L)$ for all $i$.\n3.  Determine the total number of time steps. As specified, this is $n_{\\text{steps}} = \\mathrm{round}(t_{\\text{end}}/\\Delta t)$. The final simulation time is thus $t_{\\text{num}} = n_{\\text{steps}}\\,\\Delta t$.\n4.  Iterate from time step $n=0$ to $n=n_{\\text{steps}}-1$. In each step, compute the temperature field $T^{n+1}$ from $T^n$ using the FTCS update rule for all interior points $i=1, \\dots, N-1$. The boundary conditions $T_0^{n+1}=0$ and $T_N^{n+1}=0$ are enforced at every step.\n5.  After the final time step, compute the exact solution at the numerical end time $t_{\\text{num}}$ on the same spatial grid: $T_{\\text{exact}}(x_i, t_{\\text{num}}) = \\sin(\\pi x_i / L) \\exp(-\\alpha (\\pi/L)^2 t_{\\text{num}})$.\n6.  Calculate the discrete $L^2$-norm of the error, $E$, over the interior grid points using the provided formula:\n    $$\n    E = \\left( \\sum_{i=1}^{N-1} \\left[T_i^{n_{\\text{steps}}} - T_{\\text{exact}}(x_i, t_{\\text{num}})\\right]^2 \\Delta x \\right)^{1/2}\n    $$\nFor each test, two simulations are run: one with a coarse discretization parameter ($h_1$, which is either $\\Delta x_1$ or $\\Delta t_1$) and one with a refined parameter ($h_2$). The corresponding errors, $E_1$ and $E_2$, are then used to compute the observed order of convergence, $p$:\n$$\np = \\frac{\\ln(E_2/E_1)}{\\ln(h_2/h_1)}\n$$\n\nThe theoretical truncation error of the FTCS scheme is $O(\\Delta t, \\Delta x^2)$.\n- For the spatial refinement tests (Test 1 and 2), the time step $\\Delta t$ is coupled to the spatial step $\\Delta x$ via a fixed Fourier number, $\\Delta t = Fo\\,\\Delta x^2/\\alpha$. Thus, the total error is expected to scale with $\\Delta x^2$, and the theoretical convergence rate is $p_{\\text{space}}=2$.\n- For the temporal refinement test (Test 3), $\\Delta x$ is held constant while $\\Delta t$ is varied. The error is thus dominated by the first-order term in time, and the theoretical convergence rate is $p_{\\text{time}}=1$.\n\nThe program will execute these steps for the three specified test cases to determine the observed convergence rates $p_{\\text{space},\\,0.4}$, $p_{\\text{space},\\,0.5}$, and $p_{\\text{time}}$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(L, alpha, t_end, delta_x, delta_t):\n    \"\"\"\n    Runs a single 1D transient heat conduction simulation using the FTCS scheme.\n\n    Args:\n        L (float): Length of the spatial domain.\n        alpha (float): Thermal diffusivity.\n        t_end (float): Target end time for the simulation.\n        delta_x (float): Spatial step size.\n        delta_t (float): Time step size.\n\n    Returns:\n        float: The discrete L2-norm of the error.\n    \"\"\"\n    # 1. Establish grid and parameters\n    # As per problem, N = L/delta_x is an integer.\n    N = int(round(L / delta_x))\n    x = np.linspace(0, L, N + 1)\n    Fo = alpha * delta_t / delta_x**2\n\n    # Stability check (problem statement ensures this, but good practice)\n    if Fo > 0.5:\n        raise ValueError(f\"Stability condition not met: Fo = {Fo} > 0.5\")\n\n    # 2. Initialize temperature field\n    T = np.sin(np.pi * x / L)\n\n    # 3. Determine number of time steps and final numerical time\n    n_steps = int(round(t_end / delta_t))\n    t_num = n_steps * delta_t\n\n    # 4. Time-stepping loop\n    for _ in range(n_steps):\n        # Use a copy to store the new values\n        T_new = T.copy()\n        # Apply FTCS update rule for interior points\n        T_new[1:-1] = T[1:-1] + Fo * (T[2:] - 2 * T[1:-1] + T[:-2])\n        T = T_new\n        # Boundary conditions T(0)=0 and T(L)=0 are maintained as endpoints are not updated\n\n    # 5. Compute exact solution at the final numerical time\n    T_exact = np.sin(np.pi * x / L) * np.exp(-alpha * (np.pi / L)**2 * t_num)\n\n    # 6. Calculate the discrete L2-norm of the error over interior points\n    # (T[1:-1] - T_exact[1:-1]) is the vector of differences at interior points\n    error_sq_sum = np.sum((T[1:-1] - T_exact[1:-1])**2)\n    error = np.sqrt(error_sq_sum * delta_x)\n    \n    return error\n\ndef calculate_convergence_rate(E1, E2, h1, h2):\n    \"\"\"Calculates the observed order of convergence p.\"\"\"\n    return np.log(E2 / E1) / np.log(h2 / h1)\n\ndef solve():\n    \"\"\"\n    Executes the mesh refinement study as described in the problem statement.\n    \"\"\"\n    # Common parameters\n    L = 1.0  # meter\n    alpha = 7.19e-5  # meter^2/s\n    t_end = 19.0  # second\n\n    results = []\n\n    # Test 1: Spatial refinement with Fo = 0.4\n    Fo_1 = 0.4\n    dx1_1 = L / 50.0\n    dx1_2 = L / 100.0\n    dt1_1 = Fo_1 * dx1_1**2 / alpha\n    dt1_2 = Fo_1 * dx1_2**2 / alpha\n    E1_1 = run_simulation(L, alpha, t_end, dx1_1, dt1_1)\n    E1_2 = run_simulation(L, alpha, t_end, dx1_2, dt1_2)\n    p_space_04 = calculate_convergence_rate(E1_1, E1_2, dx1_1, dx1_2)\n    results.append(p_space_04)\n\n    # Test 2: Spatial refinement with Fo = 0.5\n    Fo_2 = 0.5\n    dx2_1 = L / 50.0\n    dx2_2 = L / 100.0\n    dt2_1 = Fo_2 * dx2_1**2 / alpha\n    dt2_2 = Fo_2 * dx2_2**2 / alpha\n    E2_1 = run_simulation(L, alpha, t_end, dx2_1, dt2_1)\n    E2_2 = run_simulation(L, alpha, t_end, dx2_2, dt2_2)\n    p_space_05 = calculate_convergence_rate(E2_1, E2_2, dx2_1, dx2_2)\n    results.append(p_space_05)\n    \n    # Test 3: Temporal refinement at fixed spatial resolution\n    dx3 = L / 100.0\n    dt3_1 = 0.556\n    dt3_2 = 0.278\n    E3_1 = run_simulation(L, alpha, t_end, dx3, dt3_1)\n    E3_2 = run_simulation(L, alpha, t_end, dx3, dt3_2)\n    p_time = calculate_convergence_rate(E3_1, E3_2, dt3_1, dt3_2)\n    results.append(p_time)\n\n    # Format and print the final output\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}