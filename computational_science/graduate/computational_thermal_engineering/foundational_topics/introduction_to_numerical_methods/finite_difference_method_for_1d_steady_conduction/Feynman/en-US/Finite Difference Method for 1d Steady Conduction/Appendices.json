{
    "hands_on_practices": [
        {
            "introduction": "The first step in mastering computational methods is to build a solver from the ground up. This practice guides you through the complete process of creating a versatile one-dimensional heat conduction solver. You will translate the governing differential equation and various physical boundary conditions (Dirichlet, Neumann, and Robin) into a tridiagonal system of linear equations and then implement the highly efficient Thomas algorithm (TDMA) to find the temperature distribution, handling complexities like variable thermal conductivity .",
            "id": "3954359",
            "problem": "Consider one-dimensional steady-state heat conduction along a rod of length $L$ with spatial coordinate $x \\in [0,L]$. The governing equation, derived from conservation of energy and Fourier’s law of heat conduction, is\n$$\n\\frac{d}{dx}\\Big(k(x)\\frac{dT}{dx}\\Big) + q'''(x) = 0,\n$$\nwhere $T(x)$ is temperature, $k(x)$ is thermal conductivity, and $q'''(x)$ is volumetric heat generation. Assume a uniform grid with $N$ equal intervals, node indices $i=0,1,\\dots,N$, and spacing $\\Delta x = L/N$. Use the Finite Difference Method (FDM) to derive a tridiagonal linear system $a_i T_{i-1} + b_i T_i + c_i T_{i+1} = d_i$ for $i=0,1,\\dots,N$ that enforces the governing equation at interior nodes and boundary conditions at the endpoints. For variable $k(x)$, use consistent interface values $k_{i+1/2}$ defined by the harmonic mean\n$$\nk_{i+\\frac{1}{2}} = \\frac{2}{\\frac{1}{k_i} + \\frac{1}{k_{i+1}}}, \\quad \\text{with } k_i \\equiv k(x_i).\n$$\nFor interior nodes $i=1,\\dots,N-1$, discretize the flux divergence using a conservative two-point flux approximation:\n$$\n-\\,\\frac{k_{i-\\frac{1}{2}}}{\\Delta x}\\,T_{i-1} + \\frac{k_{i-\\frac{1}{2}} + k_{i+\\frac{1}{2}}}{\\Delta x}\\,T_i - \\frac{k_{i+\\frac{1}{2}}}{\\Delta x}\\,T_{i+1} = -\\,q'''_i\\,\\Delta x,\n$$\nwhere $q'''_i \\equiv q'''(x_i)$. For boundary conditions, enforce the following linear relations at $i=0$ (left) and $i=N$ (right) based on an energy balance over a half-control-volume at the boundary, yielding:\n- Dirichlet (prescribed temperature): $T_0 = T_\\text{L}$ or $T_N = T_\\text{R}$.\n- Neumann (prescribed outward heat flux $q''$): $-\\,k\\,\\frac{dT}{dx}\\big|_{\\text{face}} = q''$,\n$$\n\\text{left:}\\quad \\bigg(\\frac{k_{1/2}}{\\Delta x}\\bigg)T_0 - \\bigg(\\frac{k_{1/2}}{\\Delta x}\\bigg)T_1 = q''_\\text{L}, \\qquad\n\\text{right:}\\quad -\\bigg(\\frac{k_{N-1/2}}{\\Delta x}\\bigg)T_{N-1} + \\bigg(\\frac{k_{N-1/2}}{\\Delta x}\\bigg)T_N = -q''_\\text{R}.\n$$\n- Robin (convective boundary with ambient temperature $T_\\infty$ and heat transfer coefficient $h$): $-\\,k\\,\\frac{dT}{dx}\\big|_{\\text{face}} = h\\,(T_\\text{s} - T_\\infty)$,\n$$\n\\text{left:}\\quad \\bigg(\\frac{k_{1/2}}{\\Delta x} + h_\\text{L}\\bigg)T_0 - \\bigg(\\frac{k_{1/2}}{\\Delta x}\\bigg)T_1 = h_\\text{L}\\,T_{\\infty,\\text{L}},\n$$\n$$\n\\text{right:}\\quad -\\bigg(\\frac{k_{N-1/2}}{\\Delta x}\\bigg)T_{N-1} + \\bigg(\\frac{k_{N-1/2}}{\\Delta x} + h_\\text{R}\\bigg)T_N = h_\\text{R}\\,T_{\\infty,\\text{R}}.\n$$\nYou must implement the Thomas algorithm (TriDiagonal Matrix Algorithm (TDMA)) to solve the resulting tridiagonal system. Starting from first principles, derive the forward elimination and back substitution formulas explicitly and explain their correctness. Then, write a complete program that constructs the tridiagonal system for each test case and solves it using the derived TDMA formulas.\n\nPhysical units must be respected: use meters ($\\text{m}$), Kelvin ($\\text{K}$), Watts per meter-Kelvin ($\\text{W}/(\\text{m}\\cdot\\text{K})$), Watts per cubic meter ($\\text{W}/\\text{m}^3$), and Watts per square meter-Kelvin ($\\text{W}/(\\text{m}^2\\cdot\\text{K})$).\n\nTest suite:\n- Case $1$ (constant conductivity, Dirichlet–Dirichlet, no generation):\n  - $L = 1\\,\\text{m}$, $N = 10$, $k(x) \\equiv 10\\,\\text{W}/(\\text{m}\\cdot\\text{K})$, $q'''(x) \\equiv 0\\,\\text{W}/\\text{m}^3$, $T(0) = 300\\,\\text{K}$, $T(L) = 350\\,\\text{K}$.\n  - Output: the list of nodal temperatures $[T_0,\\dots,T_{10}]$ in $\\text{K}$.\n- Case $2$ (piecewise conductivity, Neumann–Dirichlet, no generation):\n  - $L = 1\\,\\text{m}$, $N = 8$, $k(x) = 100\\,\\text{W}/(\\text{m}\\cdot\\text{K})$ for $x < L/2$, and $k(x) = 200\\,\\text{W}/(\\text{m}\\cdot\\text{K})$ for $x \\ge L/2$, $q'''(x) \\equiv 0\\,\\text{W}/\\text{m}^3$, left boundary insulated ($q''_\\text{L} = 0\\,\\text{W}/\\text{m}^2$), right boundary $T(L) = 400\\,\\text{K}$.\n  - Output: the list of nodal temperatures $[T_0,\\dots,T_8]$ in $\\text{K}$.\n- Case $3$ (constant conductivity, Dirichlet–Dirichlet, uniform generation):\n  - $L = 0.02\\,\\text{m}$, $N = 20$, $k(x) \\equiv 200\\,\\text{W}/(\\text{m}\\cdot\\text{K})$, $q'''(x) \\equiv 1.0\\times 10^5\\,\\text{W}/\\text{m}^3$, $T(0) = 300\\,\\text{K}$, $T(L) = 300\\,\\text{K}$.\n  - Output: the list of nodal temperatures $[T_0,\\dots,T_{20}]$ in $\\text{K}$.\n- Case $4$ (constant conductivity, Robin–Robin, no generation):\n  - $L = 0.5\\,\\text{m}$, $N = 10$, $k(x) \\equiv 30\\,\\text{W}/(\\text{m}\\cdot\\text{K})$, $q'''(x) \\equiv 0\\,\\text{W}/\\text{m}^3$, left boundary: $h_\\text{L} = 100\\,\\text{W}/(\\text{m}^2\\cdot\\text{K})$, $T_{\\infty,\\text{L}} = 290\\,\\text{K}$, right boundary: $h_\\text{R} = 50\\,\\text{W}/(\\text{m}^2\\cdot\\text{K})$, $T_{\\infty,\\text{R}} = 310\\,\\text{K}$.\n  - Output: the list of nodal temperatures $[T_0,\\dots,T_{10}]$ in $\\text{K}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list of nodal temperatures in $\\text{K}$, rounded to $6$ decimal places. For example:\n$$\n[\\text{case1\\_list},\\text{case2\\_list},\\text{case3\\_list},\\text{case4\\_list}]\n$$\nwith no spaces in the output string.",
            "solution": "The user has provided a well-defined problem in computational heat transfer. All necessary governing equations, discretization schemes, boundary conditions, and test parameters are specified. The problem is scientifically sound, self-contained, and algorithmically solvable. Therefore, the problem is valid.\n\n### 1. Finite Difference Formulation\n\nThe problem is to solve the one-dimensional, steady-state heat conduction equation with variable thermal conductivity $k(x)$ and volumetric heat generation $q'''(x)$:\n$$\n\\frac{d}{dx}\\left(k(x)\\frac{dT}{dx}\\right) + q'''(x) = 0\n$$\nThe domain $x \\in [0, L]$ is discretized into a uniform grid with $N$ intervals, resulting in $N+1$ nodes indexed $i=0, 1, \\dots, N$. The grid spacing is $\\Delta x = L/N$, and the nodal positions are $x_i = i \\Delta x$. We seek the nodal temperatures $T_i \\approx T(x_i)$.\n\nA conservative finite difference scheme is derived by integrating the governing equation over a control volume (CV) of length $\\Delta x$ centered at each interior node $x_i$. The CV extends from $x_{i-1/2}$ to $x_{i+1/2}$.\n$$\n\\int_{x_{i-1/2}}^{x_{i+1/2}} \\left( \\frac{d}{dx}\\left(k\\frac{dT}{dx}\\right) + q''' \\right) dx = 0\n$$\nApplying the fundamental theorem of calculus to the first term and approximating the integral of the source term gives:\n$$\n\\left. \\left(k\\frac{dT}{dx}\\right) \\right|_{x_{i+1/2}} - \\left. \\left(k\\frac{dT}{dx}\\right) \\right|_{x_{i-1/2}} + q'''_i \\Delta x = 0\n$$\nThe heat fluxes at the CV faces are approximated using centered differences:\n$$\n\\left. \\left(k\\frac{dT}{dx}\\right) \\right|_{x_{i+1/2}} \\approx k_{i+1/2} \\frac{T_{i+1} - T_i}{\\Delta x}\n$$\n$$\n\\left. \\left(k\\frac{dT}{dx}\\right) \\right|_{x_{i-1/2}} \\approx k_{i-1/2} \\frac{T_i - T_{i-1}}{\\Delta x}\n$$\nThe interface thermal conductivity $k_{i \\pm 1/2}$ is calculated using the harmonic mean to correctly handle abrupt changes in material properties and ensure continuity of heat flux:\n$$\nk_{i-1/2} = \\frac{2}{\\frac{1}{k_{i-1}} + \\frac{1}{k_i}}, \\quad k_{i+1/2} = \\frac{2}{\\frac{1}{k_i} + \\frac{1}{k_{i+1}}}\n$$\nSubstituting the flux approximations into the integrated energy balance yields:\n$$\nk_{i+1/2} \\frac{T_{i+1} - T_i}{\\Delta x} - k_{i-1/2} \\frac{T_i - T_{i-1}}{\\Delta x} + q'''_i \\Delta x = 0\n$$\nMultiplying by $-\\Delta x$ and rearranging terms gives the linear equation for an interior node $i \\in [1, N-1]$ provided in the problem statement:\n$$\n\\left(-\\frac{k_{i-1/2}}{\\Delta x}\\right) T_{i-1} + \\left(\\frac{k_{i-1/2} + k_{i+1/2}}{\\Delta x}\\right) T_i + \\left(-\\frac{k_{i+1/2}}{\\Delta x}\\right) T_{i+1} = -q'''_i \\Delta x\n$$\nThis equation fits the general tridiagonal form $a_i T_{i-1} + b_i T_i + c_i T_{i+1} = d_i$.\n\n### 2. Assembling the Tridiagonal System\n\nThe complete system of $N+1$ linear equations for the $N+1$ unknown temperatures $T_0, \\dots, T_N$ is formed by applying the appropriate equation at each node.\n\n**Interior Nodes ($i = 1, \\dots, N-1$):**\n- $a_i = -k_{i-1/2} / \\Delta x$\n- $b_i = (k_{i-1/2} + k_{i+1/2}) / \\Delta x$\n- $c_i = -k_{i+1/2} / \\Delta x$\n- $d_i = -q'''_i \\Delta x$\n\n**Boundary Nodes ($i=0$ and $i=N$):**\nThe first ($i=0$) and last ($i=N$) rows of the system are determined by the boundary conditions.\n\n**Left Boundary ($i=0$):**\n1.  **Dirichlet:** $T_0 = T_L$. The equation is $1 \\cdot T_0 + 0 \\cdot T_1 = T_L$.\n    - $b_0 = 1$, $c_0 = 0$, $d_0 = T_L$. ($a_0$ is not used).\n2.  **Neumann:** The provided discretization is $\\frac{k_{1/2}}{\\Delta x}T_0 - \\frac{k_{1/2}}{\\Delta x}T_1 = q''_\\text{L}$.\n    - $b_0 = k_{1/2} / \\Delta x$, $c_0 = -k_{1/2} / \\Delta x$, $d_0 = q''_\\text{L}$.\n3.  **Robin:** The provided discretization is $\\left(\\frac{k_{1/2}}{\\Delta x} + h_\\text{L}\\right)T_0 - \\frac{k_{1/2}}{\\Delta x}T_1 = h_\\text{L}T_{\\infty,\\text{L}}$.\n    - $b_0 = k_{1/2}/\\Delta x + h_\\text{L}$, $c_0 = -k_{1/2}/\\Delta x$, $d_0 = h_\\text{L}T_{\\infty,\\text{L}}$.\n\n**Right Boundary ($i=N$):**\n1.  **Dirichlet:** $T_N = T_R$. The equation is $1 \\cdot T_N = T_R$.\n    - $a_N = 0$, $b_N = 1$, $d_N = T_R$. ($c_N$ is not used).\n2.  **Neumann:** The provided discretization is $-\\frac{k_{N-1/2}}{\\Delta x}T_{N-1} + \\frac{k_{N-1/2}}{\\Delta x}T_N = -q''_\\text{R}$.\n    - $a_N = -k_{N-1/2}/\\Delta x$, $b_N = k_{N-1/2}/\\Delta x$, $d_N = -q''_\\text{R}$.\n3.  **Robin:** The provided discretization is $-\\left(\\frac{k_{N-1/2}}{\\Delta x}\\right)T_{N-1} + \\left(\\frac{k_{N-1/2}}{\\Delta x} + h_\\text{R}\\right)T_N = h_\\text{R}T_{\\infty,\\text{R}}$.\n    - $a_N = -k_{N-1/2}/\\Delta x$, $b_N = k_{N-1/2}/\\Delta x + h_\\text{R}$, $d_N = h_\\text{R}T_{\\infty,\\text{R}}$.\n\nThese coefficients form a tridiagonal system of linear equations of size $(N+1) \\times (N+1)$, which can be solved efficiently.\n\n### 3. Derivation of the Thomas Algorithm (TDMA)\n\nThe Thomas algorithm, or Tridiagonal Matrix Algorithm (TDMA), is a specialized form of Gaussian elimination for tridiagonal systems. It solves the system in $O(N)$ operations, which is significantly more efficient than a general $O(N^3)$ matrix inversion. The derivation consists of a forward elimination pass followed by a backward substitution pass.\n\nConsider the system of equations for $i = 0, \\dots, N$:\n$$\na_i T_{i-1} + b_i T_i + c_i T_{i+1} = d_i\n$$\nwhere by definition $a_0 = 0$ and $c_N = 0$.\n\n**Forward Elimination Pass:**\nThe goal of this pass is to transform the system into an upper bidiagonal form. We achieve this by eliminating the sub-diagonal elements $a_i$.\n\nThe first equation ($i=0$) is $b_0 T_0 + c_0 T_1 = d_0$. We can express $T_0$ in terms of $T_1$:\n$$\nT_0 = -\\frac{c_0}{b_0} T_1 + \\frac{d_0}{b_0}\n$$\nThe second equation ($i=1$) is $a_1 T_0 + b_1 T_1 + c_1 T_2 = d_1$. Substituting the expression for $T_0$:\n$$\na_1 \\left(-\\frac{c_0}{b_0} T_1 + \\frac{d_0}{b_0}\\right) + b_1 T_1 + c_1 T_2 = d_1\n$$\nRearranging terms:\n$$\n\\left(b_1 - \\frac{a_1 c_0}{b_0}\\right) T_1 + c_1 T_2 = d_1 - \\frac{a_1 d_0}{b_0}\n$$\nThis process can be generalized. We perform row operations that transform each equation to the form $T_i + c'_i T_{i+1} = d'_i$.\nLet's define modified coefficients $c'_i$ and $d'_i$.\n\nFor $i=0$:\n$$\nc'_0 = \\frac{c_0}{b_0}, \\quad d'_0 = \\frac{d_0}{b_0}\n$$\nFor $i > 0$, we have the original equation $a_i T_{i-1} + b_i T_i + c_i T_{i+1} = d_i$ and the previously modified equation for row $i-1$: $T_{i-1} = -c'_{i-1} T_i + d'_{i-1}$. Substituting the expression for $T_{i-1}$ into the original equation for row $i$:\n$$\na_i (-c'_{i-1} T_i + d'_{i-1}) + b_i T_i + c_i T_{i+1} = d_i\n$$\nGrouping terms by $T_i$ and $T_{i+1}$:\n$$\n(b_i - a_i c'_{i-1}) T_i + c_i T_{i+1} = d_i - a_i d'_{i-1}\n$$\nDividing by the new coefficient of $T_i$ to isolate it yields the recurrence relations for the modified coefficients:\n$$\nc'_i = \\frac{c_i}{b_i - a_i c'_{i-1}}, \\quad d'_i = \\frac{d_i - a_i d'_{i-1}}{b_i - a_i c'_{i-1}}\n$$\nThese recurrences are applied for $i = 1, \\dots, N$. Note that for $i=N$, $c_N=0$, so $c'_N=0$.\n\nThe forward elimination sweep proceeds as follows:\n1.  Calculate $c'_0 = c_0/b_0$ and $d'_0 = d_0/b_0$.\n2.  For $i = 1, \\dots, N$, calculate $c'_i$ and $d'_i$ using the recurrence relations.\n\n**Backward Substitution Pass:**\nAfter the forward pass, the system has been transformed into an upper bidiagonal form:\n$$\nT_i + c'_i T_{i+1} = d'_i \\quad \\text{for } i=0, \\dots, N-1\n$$\n$$\nT_N = d'_N \\quad (\\text{since } c'_N = 0)\n$$\nThe last temperature $T_N$ is known directly:\n$$\nT_N = d'_N\n$$\nThe remaining temperatures can be found by substituting backwards from $i=N-1$ down to $0$:\n$$\nT_i = d'_i - c'_i T_{i+1}\n$$\nThe back substitution sweep proceeds as follows:\n1.  Set $T_N = d'_N$.\n2.  For $i = N-1, N-2, \\dots, 0$, calculate $T_i = d'_i - c'_i T_{i+1}$.\n\nThis two-pass procedure completes the solution. The algorithm is numerically stable for diagonally dominant matrices, a condition met by the physical systems under consideration.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_tdma(a, b, c, d):\n    \"\"\"\n    Solves a tridiagonal linear system Ax=d using the Thomas algorithm (TDMA).\n\n    Args:\n        a (np.ndarray): The sub-diagonal (indices 1 to n-1). a[0] is ignored.\n        b (np.ndarray): The main diagonal (indices 0 to n-1).\n        c (np.ndarray): The super-diagonal (indices 0 to n-2). c[n-1] is ignored.\n        d (np.ndarray): The right-hand side vector.\n\n    Returns:\n        np.ndarray: The solution vector x.\n    \"\"\"\n    n = len(d)\n    c_prime = np.zeros(n)\n    d_prime = np.zeros(n)\n    x = np.zeros(n)\n\n    # Forward elimination\n    c_prime[0] = c[0] / b[0]\n    d_prime[0] = d[0] / b[0]\n\n    for i in range(1, n):\n        denom = b[i] - a[i] * c_prime[i-1]\n        c_prime[i] = c[i] / denom\n        d_prime[i] = (d[i] - a[i] * d_prime[i-1]) / denom\n\n    # Backward substitution\n    x[n-1] = d_prime[n-1]\n    for i in range(n-2, -1, -1):\n        x[i] = d_prime[i] - c_prime[i] * x[i+1]\n\n    return x\n\ndef solve_heat_conduction(L, N, k_func, q_func, bc_left, bc_right):\n    \"\"\"\n    Constructs and solves the 1D steady heat conduction problem using FDM.\n    \"\"\"\n    # 1. Setup grid and properties\n    x_nodes = np.linspace(0, L, N + 1)\n    dx = L / N\n    \n    k_vals = np.array([k_func(x) for x in x_nodes])\n    q_vals = np.array([q_func(x) for x in x_nodes])\n\n    # 2. Compute interface conductivities\n    k_interface = np.zeros(N)\n    for i in range(N):\n        # Harmonic mean for k_{i+1/2}\n        if k_vals[i] == 0 or k_vals[i+1] == 0:\n            k_interface[i] = 0 # Or handle as insulated\n        else:\n            k_interface[i] = 2.0 / (1.0/k_vals[i] + 1.0/k_vals[i+1])\n\n    # 3. Initialize tridiagonal system coefficients\n    num_nodes = N + 1\n    a = np.zeros(num_nodes) # sub-diagonal\n    b = np.zeros(num_nodes) # main-diagonal\n    c = np.zeros(num_nodes) # super-diagonal\n    d = np.zeros(num_nodes) # RHS vector\n\n    # 4. Fill coefficients for interior nodes (i = 1 to N-1)\n    for i in range(1, N):\n        a[i] = -k_interface[i-1] / dx\n        b[i] = (k_interface[i-1] + k_interface[i]) / dx\n        c[i] = -k_interface[i] / dx\n        d[i] = -q_vals[i] * dx\n\n    # 5. Fill coefficients for boundary nodes (i=0 and i=N)\n    # Left boundary (i=0)\n    bc_type_L, bc_val_L = bc_left[0], bc_left[1:]\n    if bc_type_L == 'dirichlet':\n        b[0] = 1.0\n        c[0] = 0.0\n        d[0] = bc_val_L[0]\n    elif bc_type_L == 'neumann':\n        q_L = bc_val_L[0]\n        b[0] = k_interface[0] / dx\n        c[0] = -k_interface[0] / dx\n        d[0] = q_L\n    elif bc_type_L == 'robin':\n        h_L, T_inf_L = bc_val_L\n        b[0] = k_interface[0] / dx + h_L\n        c[0] = -k_interface[0] / dx\n        d[0] = h_L * T_inf_L\n\n    # Right boundary (i=N)\n    bc_type_R, bc_val_R = bc_right[0], bc_right[1:]\n    if bc_type_R == 'dirichlet':\n        a[N] = 0.0\n        b[N] = 1.0\n        d[N] = bc_val_R[0]\n    elif bc_type_R == 'neumann':\n        q_R = bc_val_R[0]\n        a[N] = -k_interface[N-1] / dx\n        b[N] = k_interface[N-1] / dx\n        d[N] = -q_R\n    elif bc_type_R == 'robin':\n        h_R, T_inf_R = bc_val_R\n        a[N] = -k_interface[N-1] / dx\n        b[N] = k_interface[N-1] / dx + h_R\n        d[N] = h_R * T_inf_R\n\n    # 6. Solve the system\n    T = solve_tdma(a, b, c, d)\n    return T\n\n\ndef solve():\n    test_cases = [\n        # Case 1\n        {\n            \"L\": 1.0, \"N\": 10, \"k_func\": lambda x: 10.0, \"q_func\": lambda x: 0.0,\n            \"bc_left\": ('dirichlet', 300.0), \"bc_right\": ('dirichlet', 350.0)\n        },\n        # Case 2\n        {\n            \"L\": 1.0, \"N\": 8, \"k_func\": lambda x: 100.0 if x < 0.5 else 200.0, \"q_func\": lambda x: 0.0,\n            \"bc_left\": ('neumann', 0.0), \"bc_right\": ('dirichlet', 400.0)\n        },\n        # Case 3\n        {\n            \"L\": 0.02, \"N\": 20, \"k_func\": lambda x: 200.0, \"q_func\": lambda x: 1.0e5,\n            \"bc_left\": ('dirichlet', 300.0), \"bc_right\": ('dirichlet', 300.0)\n        },\n        # Case 4\n        {\n            \"L\": 0.5, \"N\": 10, \"k_func\": lambda x: 30.0, \"q_func\": lambda x: 0.0,\n            \"bc_left\": ('robin', 100.0, 290.0), \"bc_right\": ('robin', 50.0, 310.0)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        T = solve_heat_conduction(\n            case[\"L\"], case[\"N\"], case[\"k_func\"], case[\"q_func\"],\n            case[\"bc_left\"], case[\"bc_right\"]\n        )\n        results.append(T)\n\n    # Format the final output string exactly as required\n    result_strings = []\n    for T in results:\n        # Format each temperature list to a string '[T0,T1,...]'\n        # with numbers rounded to 6 decimal places.\n        temp_list_str = f\"[{','.join([f'{temp:.6f}' for temp in T])}]\"\n        result_strings.append(temp_list_str)\n\n    # Join the individual case strings into the final format '[[...],[...]]'\n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "Once a numerical solver is built, the most critical question is: is it correct? This analytical exercise serves as a fundamental validation test for the finite difference method. By comparing the numerical solution to the exact analytical solution for a simple conduction problem, you will prove that the standard second-order discretization is not just an approximation but is *exact* for linear temperature profiles, providing a deep insight into the method's truncation error .",
            "id": "3954436",
            "problem": "A homogeneous one-dimensional rod of length $L$ with constant thermal conductivity $k$ is in steady conduction with no internal volumetric heat generation. The left end at $x=0$ is held at a prescribed temperature $T(0)=T_{0}$ and the right end at $x=L$ is held at a prescribed temperature $T(L)=T_{L}$. Starting from the principle of energy conservation and Fourier’s law of heat conduction, derive the continuous governing equation for the temperature field $T(x)$ and determine the exact temperature distribution $T(x)$.\n\nUsing the Finite Difference Method (FDM), discretize the domain into $N$ equal subintervals, producing $N+1$ grid points $x_{i}=i\\,\\Delta x$ for $i=0,1,\\dots,N$ with uniform spacing $\\Delta x=L/N$. Formulate the discrete steady-state conduction equations for the interior nodes and enforce the boundary conditions at the endpoints. Solve the resulting linear system to obtain the nodal temperatures $\\{T_{i}\\}_{i=0}^{N}$.\n\nValidate the discrete formulation by comparing the nodal temperatures $\\{T_{i}\\}$ to the exact continuous solution $T(x)$ evaluated at the grid points $\\{x_{i}\\}$. Define the maximum norm error as\n$$\nE_{\\infty}(\\Delta x)=\\max_{0\\leq i\\leq N}\\left|T_{i}-T(x_{i})\\right|.\n$$\nDerive a closed-form expression for $E_{\\infty}(\\Delta x)$ as a function of $\\Delta x$. Express $E_{\\infty}(\\Delta x)$ in kelvins (K). The final answer must be a single analytic expression depending only on $\\Delta x$.",
            "solution": "The problem requires the derivation and comparison of the continuous and discrete solutions for one-dimensional steady-state heat conduction in a homogeneous rod with prescribed boundary temperatures and no internal heat generation. The final goal is to find a closed-form expression for the maximum error between the two solutions.\n\nFirst, we derive the continuous governing equation and its exact solution. The principle of energy conservation for a one-dimensional steady-state system with no heat generation states that the heat flow rate, $q_x$, is constant along the rod. This is expressed as:\n$$\n\\frac{dq_x}{dx} = 0\n$$\nFourier's law of heat conduction relates the heat flow rate to the temperature gradient:\n$$\nq_x = -kA\\frac{dT}{dx}\n$$\nwhere $k$ is the thermal conductivity and $A$ is the cross-sectional area, both assumed constant. Substituting Fourier's law into the energy conservation equation gives:\n$$\n\\frac{d}{dx}\\left(-kA\\frac{dT}{dx}\\right) = 0\n$$\nSince $k$ and $A$ are constants, we can simplify this to the governing ordinary differential equation for the temperature field $T(x)$:\n$$\n\\frac{d^2T}{dx^2} = 0\n$$\nTo find the exact temperature distribution $T(x)$, we integrate this equation twice with respect to $x$:\n$$\n\\frac{dT}{dx} = C_1\n$$\n$$\nT(x) = C_1 x + C_2\n$$\nwhere $C_1$ and $C_2$ are integration constants determined by the boundary conditions.\nThe given boundary conditions are:\n1. At $x=0$, $T(0) = T_0$.\n2. At $x=L$, $T(L) = T_L$.\n\nApplying the first boundary condition:\n$$\nT(0) = C_1(0) + C_2 = T_0 \\implies C_2 = T_0\n$$\nApplying the second boundary condition:\n$$\nT(L) = C_1 L + T_0 = T_L \\implies C_1 = \\frac{T_L - T_0}{L}\n$$\nSubstituting the constants back into the general solution, we obtain the exact continuous temperature distribution:\n$$\nT(x) = \\left(\\frac{T_L - T_0}{L}\\right)x + T_0\n$$\n\nNext, we formulate and solve the problem using the Finite Difference Method (FDM). The domain of length $L$ is discretized into $N$ equal subintervals of width $\\Delta x = L/N$. This creates $N+1$ grid points $x_i = i\\Delta x$ for $i = 0, 1, \\dots, N$. The temperature at each grid point $x_i$ is denoted by $T_i$.\n\nThe governing equation $\\frac{d^2T}{dx^2} = 0$ is discretized at each interior node $x_i$ (for $i=1, 2, \\dots, N-1$) using a second-order accurate central difference scheme for the second derivative:\n$$\n\\left.\\frac{d^2T}{dx^2}\\right|_{x_i} \\approx \\frac{T_{i+1} - 2T_i + T_{i-1}}{(\\Delta x)^2}\n$$\nSubstituting this into the governing equation gives the discrete equation for each interior node:\n$$\n\\frac{T_{i+1} - 2T_i + T_{i-1}}{(\\Delta x)^2} = 0\n$$\nThis simplifies to a linear algebraic equation for the nodal temperatures:\n$$\nT_{i+1} - 2T_i + T_{i-1} = 0 \\quad \\text{for } i = 1, 2, \\dots, N-1\n$$\nThis set of $N-1$ equations is supplemented by the boundary conditions, which are applied directly at the endpoints:\n$$\nT_0 = T(0) = T_0\n$$\n$$\nT_N = T(L) = T_L\n$$\nThe discrete equation can be rearranged as $T_i - T_{i-1} = T_{i+1} - T_i$, which indicates that the temperature difference between any two adjacent nodes is constant. This implies that the nodal temperatures form an arithmetic progression. We can write the general solution for $T_i$ as:\n$$\nT_i = T_0 + i \\cdot C\n$$\nwhere $C$ is the constant difference. To find $C$, we use the boundary condition at $i=N$:\n$$\nT_N = T_0 + N \\cdot C = T_L\n$$\nSolving for $C$:\n$$\nC = \\frac{T_L - T_0}{N}\n$$\nSubstituting this back gives the solution for the nodal temperatures:\n$$\nT_i = T_0 + i \\left(\\frac{T_L - T_0}{N}\\right) \\quad \\text{for } i = 0, 1, \\dots, N\n$$\n\nFinally, we validate the discrete formulation by comparing the nodal temperatures $\\{T_i\\}$ with the exact continuous solution $T(x)$ evaluated at the grid points $\\{x_i\\}$. The exact solution at a grid point $x_i = i \\Delta x = i (L/N)$ is:\n$$\nT(x_i) = \\left(\\frac{T_L - T_0}{L}\\right)x_i + T_0 = \\left(\\frac{T_L - T_0}{L}\\right)\\left(i \\frac{L}{N}\\right) + T_0 = i\\left(\\frac{T_L - T_0}{N}\\right) + T_0\n$$\nComparing this with the discrete solution $T_i$:\n$$\nT(x_i) = T_0 + i\\left(\\frac{T_L - T_0}{N}\\right)\n$$\n$$\nT_i = T_0 + i \\left(\\frac{T_L - T_0}{N}\\right)\n$$\nWe observe that the expression for the numerical solution $T_i$ is identical to the expression for the exact solution evaluated at the grid point $x_i$. Therefore, the error at each node, $e_i = T_i - T(x_i)$, is:\n$$\ne_i = \\left(T_0 + i \\left(\\frac{T_L - T_0}{N}\\right)\\right) - \\left(T_0 + i \\left(\\frac{T_L - T_0}{N}\\right)\\right) = 0\n$$\nThis holds for all nodes $i=0, 1, \\dots, N$.\n\nThe maximum norm error is defined as $E_{\\infty}(\\Delta x)=\\max_{0\\leq i\\leq N}\\left|T_{i}-T(x_{i})\\right|$. Since the error at every node is zero, the maximum error is also zero:\n$$\nE_{\\infty}(\\Delta x) = \\max_{0\\leq i\\leq N}|0| = 0\n$$\nThis result occurs because the central difference scheme for the second derivative is based on a Taylor series expansion. The truncation error of this scheme is proportional to the fourth derivative of the function, $T^{(4)}(x)$. For the given problem, the exact solution is a linear function, $T(x) = C_1 x + C_2$. All derivatives of order two and higher are identically zero. Specifically, $T^{(4)}(x) = 0$. Consequently, the local truncation error of the finite difference approximation is exactly zero, and the FDM solution coincides with the exact solution at the nodes.\n\nThe closed-form expression for $E_{\\infty}(\\Delta x)$ is therefore $0$. This value is a constant, which trivially satisfies the requirement that it depends only on $\\Delta x$. The unit of the error is Kelvins (K), so the result is $0$ K.",
            "answer": "$$\n\\boxed{0}\n$$"
        },
        {
            "introduction": "Beyond simple cases, we need a robust strategy to verify our code's accuracy for complex problems. This practice introduces a cornerstone of modern code verification: the Method of Manufactured Solutions (MMS). You will learn how to 'manufacture' a problem with a known analytical solution to rigorously test your solver, and then perform a mesh refinement study to compute the observed order of accuracy, quantitatively confirming that your implementation behaves as theoretically expected .",
            "id": "3954376",
            "problem": "Consider one-dimensional steady heat conduction on the spatial interval $[0,1]$ in meters, with thermal conductivity $k(x)$ and volumetric heat generation rate $s(x)$ in watts per cubic meter. The governing equation follows from the combination of Fourier's law of heat conduction and energy conservation in steady state, which yields the differential equation\n$$\n-\\frac{d}{dx}\\left(k(x)\\frac{dT}{dx}\\right) = s(x),\n$$\nwith boundary conditions specified at $x=0$ and $x=1$. You will implement a second-order accurate finite difference method (FDM) on a uniform mesh of $N$ nodes (including boundaries), with $h = \\frac{1}{N-1}$, to numerically approximate the temperature field $T(x)$ in kelvin. Use the conservative interior discretization\n$$\n-\\frac{1}{h^2}\\left(k_{i+\\frac{1}{2}}\\left(T_{i+1}-T_i\\right) - k_{i-\\frac{1}{2}}\\left(T_i - T_{i-1}\\right)\\right) = s(x_i),\n$$\nfor interior nodes $i=1,\\dots,N-2$, where the interface conductivity $k_{i\\pm\\frac{1}{2}}$ must be approximated by the harmonic mean\n$$\nk_{i+\\frac{1}{2}} = \\left(\\frac{1}{2}\\left(\\frac{1}{k_i} + \\frac{1}{k_{i+1}}\\right)\\right)^{-1} = \\frac{2 k_i k_{i+1}}{k_i + k_{i+1}},\n$$\nand similarly for $k_{i-\\frac{1}{2}}$. For Dirichlet boundary conditions, enforce the exact temperature at the boundary nodes. For a Neumann boundary condition at $x=1$ with zero heat flux and constant conductivity, enforce the boundary derivative using the second-order accurate formula\n$$\n\\frac{3 T_{N-1} - 4 T_{N-2} + T_{N-3}}{2h} = 0.\n$$\nYou will perform a mesh refinement analysis using a manufactured solution so that the analytical solution is known. For each test case, define the exact solution $T_{\\text{exact}}(x)$ in kelvin, the conductivity $k(x)$, and the source term $s(x)$ in watts per cubic meter derived from the governing equation, and appropriate boundary conditions. Compute the numerical solution for three successive values of $N$ and evaluate the discrete $L^2$ error norm\n$$\nE_N = \\sqrt{h \\sum_{i=0}^{N-1} \\left(T_i^{\\text{num}} - T_{\\text{exact}}(x_i)\\right)^2},\n$$\nwhere $x_i = i h$, $T_i^{\\text{num}}$ is the computed numerical temperature at node $i$, and $T_{\\text{exact}}(x_i)$ is the exact temperature at the node. From the two finest meshes, compute the observed order of accuracy\n$$\np_{\\text{obs}} = \\frac{\\ln\\left(E_{N_2}/E_{N_3}\\right)}{\\ln\\left(h_{N_2}/h_{N_3}\\right)},\n$$\nwith $h_N = \\frac{1}{N-1}$ and $(N_1,N_2,N_3)$ being the successive mesh sizes for the test case. Report $p_{\\text{obs}}$ as a dimensionless float.\n\nTest Suite:\n- Test Case 1 (Dirichlet–Dirichlet, constant conductivity):\n  - Domain: $x \\in [0,1]$ meters.\n  - Conductivity: $k(x) = 1$ watt per meter-kelvin.\n  - Exact solution: $T_{\\text{exact}}(x) = \\sin(\\pi x)$ kelvin.\n  - Source: $s(x) = -\\frac{d}{dx}\\left(k(x)\\frac{dT_{\\text{exact}}}{dx}\\right) = \\pi^2 \\sin(\\pi x)$ watts per cubic meter.\n  - Boundary conditions: $T(0) = 0$ kelvin, $T(1) = 0$ kelvin.\n  - Mesh sizes: $(N_1,N_2,N_3) = (21, 41, 81)$.\n\n- Test Case 2 (Dirichlet–Dirichlet, smoothly varying conductivity):\n  - Domain: $x \\in [0,1]$ meters.\n  - Conductivity: $k(x) = 1 + x$ watts per meter-kelvin.\n  - Exact solution: $T_{\\text{exact}}(x) = \\sin(\\pi x)$ kelvin.\n  - Source: $s(x) = -\\frac{d}{dx}\\left(k(x)\\frac{dT_{\\text{exact}}}{dx}\\right) = (1+x)\\pi^2 \\sin(\\pi x) - \\pi \\cos(\\pi x)$ watts per cubic meter.\n  - Boundary conditions: $T(0) = 0$ kelvin, $T(1) = 0$ kelvin.\n  - Mesh sizes: $(N_1,N_2,N_3) = (17, 33, 65)$.\n\n- Test Case 3 (Dirichlet–Neumann, constant conductivity with zero-flux at the right boundary):\n  - Domain: $x \\in [0,1]$ meters.\n  - Conductivity: $k(x) = 1$ watt per meter-kelvin.\n  - Exact solution: $T_{\\text{exact}}(x) = \\sin\\left(\\frac{\\pi}{2} x\\right)$ kelvin.\n  - Source: $s(x) = -\\frac{d}{dx}\\left(k(x)\\frac{dT_{\\text{exact}}}{dx}\\right) = \\left(\\frac{\\pi}{2}\\right)^2 \\sin\\left(\\frac{\\pi}{2} x\\right)$ watts per cubic meter.\n  - Boundary conditions: $T(0) = 0$ kelvin, and zero-flux $k \\frac{dT}{dx}(1) = 0$ at $x=1$.\n  - Mesh sizes: $(N_1,N_2,N_3) = (19, 37, 73)$.\n\nYour program must:\n- Implement the described FDM, assemble and solve the resulting linear system for each $N$.\n- Compute $E_{N}$ for each $N$ in each test case, then compute $p_{\\text{obs}}$ from the two finest meshes.\n- Produce a single line of output containing the three $p_{\\text{obs}}$ values, in order of the test cases, as a comma-separated list enclosed in square brackets. For example: \"[p1,p2,p3]\".\nAll outputs for $p_{\\text{obs}}$ are dimensionless floats.",
            "solution": "The problem requires the implementation of a second-order accurate finite difference method (FDM) to solve the one-dimensional, steady-state heat conduction equation on the interval $x \\in [0, 1]$. The governing equation is\n$$\n-\\frac{d}{dx}\\left(k(x)\\frac{dT}{dx}\\right) = s(x),\n$$\nwhere $T(x)$ is the temperature, $k(x)$ is the thermal conductivity, and $s(x)$ is the volumetric heat generation rate. The objective is to perform a mesh refinement study using the Method of Manufactured Solutions to verify the second-order accuracy of the numerical scheme.\n\nFirst, the spatial domain $[0, 1]$ is discretized into a uniform mesh of $N$ nodes. The coordinates of the nodes are given by $x_i = i h$ for $i = 0, 1, \\dots, N-1$, where $h = 1/(N-1)$ is the constant grid spacing. The temperature at these nodes, $T(x_i)$, is denoted by $T_i$.\n\nFor the interior nodes, $i = 1, \\dots, N-2$, we apply the provided conservative finite difference discretization. This scheme is derived by integrating the governing equation over a control volume centered at each node, from $x_i - h/2$ to $x_i + h/2$. This leads to the discrete equation:\n$$\n-\\frac{1}{h} \\left( \\left. k \\frac{dT}{dx} \\right|_{i+\\frac{1}{2}} - \\left. k \\frac{dT}{dx} \\right|_{i-\\frac{1}{2}} \\right) = s(x_i).\n$$\nThe fluxes at the control volume faces, $\\left. k \\frac{dT}{dx} \\right|_{i\\pm\\frac{1}{2}}$, are approximated using a central difference, for instance $\\left. k \\frac{dT}{dx} \\right|_{i+\\frac{1}{2}} \\approx k_{i+\\frac{1}{2}} \\frac{T_{i+1}-T_i}{h}$. This results in the specified formula:\n$$\n-\\frac{1}{h^2}\\left(k_{i+\\frac{1}{2}}\\left(T_{i+1}-T_i\\right) - k_{i-\\frac{1}{2}}\\left(T_i - T_{i-1}\\right)\\right) = s(x_i).\n$$\nThe interface conductivities $k_{i\\pm\\frac{1}{2}}$ are calculated using the harmonic mean of the conductivities at the adjacent nodes:\n$$\nk_{i+\\frac{1}{2}} = \\frac{2 k(x_i) k(x_{i+1})}{k(x_i) + k(x_{i+1})} \\quad \\text{and} \\quad k_{i-\\frac{1}{2}} = \\frac{2 k(x_{i-1}) k(x_i)}{k(x_{i-1}) + k(x_i)}.\n$$\nThe harmonic mean is particularly effective for ensuring flux conservation, especially when conductivity varies sharply.\n\nRearranging the interior node equation to group terms by the unknown temperatures $T_{i-1}$, $T_i$, and $T_{i+1}$ yields a linear algebraic equation for each interior node $i$:\n$$\n\\left(-\\frac{k_{i-\\frac{1}{2}}}{h^2}\\right) T_{i-1} + \\left(\\frac{k_{i-\\frac{1}{2}} + k_{i+\\frac{1}{2}}}{h^2}\\right) T_i + \\left(-\\frac{k_{i+\\frac{1}{2}}}{h^2}\\right) T_{i+1} = s(x_i).\n$$\nThese $N-2$ equations, combined with two equations for the boundary conditions at nodes $i=0$ and $i=N-1$, form a system of $N$ linear equations in $N$ unknowns, which can be written in matrix form as $A\\mathbf{T} = \\mathbf{b}$. Here, $\\mathbf{T} = [T_0, T_1, \\dots, T_{N-1}]^T$ is the vector of unknown nodal temperatures, $A$ is an $N \\times N$ coefficient matrix, and $\\mathbf{b}$ is an $N \\times 1$ source vector.\n\nThe boundary conditions determine the first ($i=0$) and last ($i=N-1$) rows of the system.\nFor a Dirichlet boundary condition, such as $T(0) = T_0^{\\text{exact}}$, the corresponding equation is simply $1 \\cdot T_0 = T_0^{\\text{exact}}$. This sets the first row of matrix $A$ to $[1, 0, \\dots, 0]$ and the first element of $\\mathbf{b}$ to $T_0^{\\text{exact}}$. A Dirichlet condition at $x=1$ is handled similarly for the last row.\n\nFor the zero-flux Neumann boundary condition at $x=1$, $k(1)\\frac{dT}{dx}(1) = 0$, a discrete approximation for the derivative is required. The problem specifies a second-order accurate, one-sided formula:\n$$\n\\frac{3 T_{N-1} - 4 T_{N-2} + T_{N-3}}{2h} = 0.\n$$\nThis directly gives the final equation of the system: $T_{N-3} - 4T_{N-2} + 3T_{N-1} = 0$. For this equation, the last row of matrix $A$ will have non-zero entries in columns $N-3$, $N-2$, and $N-1$, with values $1$, $-4$, and $3$ respectively. The corresponding element in $\\mathbf{b}$ is $0$.\n\nOnce the matrix $A$ and vector $\\mathbf{b}$ are fully assembled for a given test case and mesh size $N$, the linear system is solved for the numerical solution vector $\\mathbf{T}^{\\text{num}}$.\n\nTo verify the implementation, we use the manufactured solutions provided. For each $N$, the numerical solution $\\mathbf{T}^{\\text{num}}$ is compared against the exact solution evaluated at the grid points, $\\mathbf{T}^{\\text{exact}}$. The error is quantified using the discrete $L^2$ norm:\n$$\nE_N = \\sqrt{h \\sum_{i=0}^{N-1} \\left(T_i^{\\text{num}} - T_{\\text{exact}}(x_i)\\right)^2}.\n$$\nThe observed order of accuracy, $p_{\\text{obs}}$, is then computed using the errors from the two finest meshes, $N_2$ and $N_3$:\n$$\np_{\\text{obs}} = \\frac{\\ln\\left(E_{N_2}/E_{N_3}\\right)}{\\ln\\left(h_{N_2}/h_{N_3}\\right)}.\n$$\nFor a second-order accurate scheme, we expect $p_{\\text{obs}} \\approx 2$ as the mesh is refined. The program will execute this procedure for all three test cases and report the calculated $p_{\\text{obs}}$ values.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_bvp(N, k_func, s_func, bc_left_tuple, bc_right_tuple):\n    \"\"\"\n    Solves the 1D steady conduction BVP using a finite difference method.\n\n    Args:\n        N (int): Number of grid nodes.\n        k_func (callable): Function k(x) for thermal conductivity.\n        s_func (callable): Function s(x) for the source term.\n        bc_left_tuple (tuple): Tuple of (type, value) for the left BC.\n        bc_right_tuple (tuple): Tuple of (type, value) for the right BC.\n\n    Returns:\n        np.array: The numerical solution for temperature T at the grid nodes.\n    \"\"\"\n    h = 1.0 / (N - 1)\n    x = np.linspace(0.0, 1.0, N)\n\n    k_vals = k_func(x)\n    s_vals = s_func(x)\n\n    A = np.zeros((N, N))\n    b = np.zeros(N)\n\n    # Interior nodes (i=1, ..., N-2)\n    for i in range(1, N - 1):\n        k_im1 = k_vals[i - 1]\n        k_i = k_vals[i]\n        k_ip1 = k_vals[i + 1]\n\n        # Harmonic mean for interface conductivity\n        k_imhalf = (2.0 * k_im1 * k_i) / (k_im1 + k_i)\n        k_iphalf = (2.0 * k_i * k_ip1) / (k_i + k_ip1)\n\n        A[i, i - 1] = -k_imhalf / (h * h)\n        A[i, i] = (k_imhalf + k_iphalf) / (h * h)\n        A[i, i + 1] = -k_iphalf / (h * h)\n        b[i] = s_vals[i]\n\n    # Boundary conditions\n    # Left BC at x=0 (node i=0)\n    bc_left_type, bc_left_val = bc_left_tuple\n    if bc_left_type == 'dirichlet':\n        A[0, 0] = 1.0\n        b[0] = bc_left_val\n    \n    # Right BC at x=1 (node i=N-1)\n    bc_right_type, bc_right_val = bc_right_tuple\n    if bc_right_type == 'dirichlet':\n        A[N - 1, N - 1] = 1.0\n        b[N - 1] = bc_right_val\n    elif bc_right_type == 'neumann':\n        # Zero-flux Neumann BC: 3*T_{N-1} - 4*T_{N-2} + T_{N-3} = 0\n        if bc_right_val == 0.0:\n            A[N - 1, N - 3] = 1.0\n            A[N - 1, N - 2] = -4.0\n            A[N - 1, N - 1] = 3.0\n            b[N - 1] = 0.0\n\n    # Solve the linear system\n    T_num = np.linalg.solve(A, b)\n    return T_num\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Case 1: DD, constant k\",\n            \"k_func\": lambda x: np.full_like(x, 1.0),\n            \"T_exact_func\": lambda x: np.sin(np.pi * x),\n            \"s_func\": lambda x: np.pi**2 * np.sin(np.pi * x),\n            \"bc_left\": ('dirichlet', 0.0),\n            \"bc_right\": ('dirichlet', 0.0),\n            \"meshes\": (21, 41, 81)\n        },\n        {\n            \"name\": \"Case 2: DD, variable k\",\n            \"k_func\": lambda x: 1.0 + x,\n            \"T_exact_func\": lambda x: np.sin(np.pi * x),\n            \"s_func\": lambda x: (1.0 + x) * np.pi**2 * np.sin(np.pi * x) - np.pi * np.cos(np.pi * x),\n            \"bc_left\": ('dirichlet', 0.0),\n            \"bc_right\": ('dirichlet', 0.0),\n            \"meshes\": (17, 33, 65)\n        },\n        {\n            \"name\": \"Case 3: DN, constant k\",\n            \"k_func\": lambda x: np.full_like(x, 1.0),\n            \"T_exact_func\": lambda x: np.sin(np.pi / 2.0 * x),\n            \"s_func\": lambda x: (np.pi / 2.0)**2 * np.sin(np.pi / 2.0 * x),\n            \"bc_left\": ('dirichlet', 0.0),\n            \"bc_right\": ('neumann', 0.0),\n            \"meshes\": (19, 37, 73)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        errors = []\n        h_vals = []\n        for N in case[\"meshes\"]:\n            h = 1.0 / (N - 1)\n            x = np.linspace(0.0, 1.0, N)\n            \n            # Solve for numerical temperature\n            T_num = solve_bvp(N, case[\"k_func\"], case[\"s_func\"], case[\"bc_left\"], case[\"bc_right\"])\n            \n            # Get exact temperature\n            T_exact = case[\"T_exact_func\"](x)\n            \n            # Calculate L2 error\n            error = np.sqrt(h * np.sum((T_num - T_exact)**2))\n            errors.append(error)\n            h_vals.append(h)\n            \n        # Unpack errors and grid spacings\n        E_N2, E_N3 = errors[1], errors[2]\n        h_N2, h_N3 = h_vals[1], h_vals[2]\n\n        # Compute observed order of accuracy\n        p_obs = np.log(E_N2 / E_N3) / np.log(h_N2 / h_N3)\n        results.append(p_obs)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}