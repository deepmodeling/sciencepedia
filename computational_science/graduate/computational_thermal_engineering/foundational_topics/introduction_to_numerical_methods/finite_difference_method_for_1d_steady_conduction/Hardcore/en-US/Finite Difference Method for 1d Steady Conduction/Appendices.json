{
    "hands_on_practices": [
        {
            "introduction": "The first step in mastering any computational method is to build a solver from the ground up. This practice guides you through the complete process of developing a finite difference code for one-dimensional steady heat conduction. By translating the governing differential equation and various physical boundary conditions into a tridiagonal linear system and implementing the efficient Thomas Algorithm (TDMA) to solve it, you will build a robust and fundamental computational tool .",
            "id": "3954359",
            "problem": "Consider one-dimensional steady-state heat conduction along a rod of length $L$ with spatial coordinate $x \\in [0,L]$. The governing equation, derived from conservation of energy and Fourier’s law of heat conduction, is\n$$\n\\frac{d}{dx}\\Big(k(x)\\frac{dT}{dx}\\Big) + q'''(x) = 0,\n$$\nwhere $T(x)$ is temperature, $k(x)$ is thermal conductivity, and $q'''(x)$ is volumetric heat generation. Assume a uniform grid with $N$ equal intervals, node indices $i=0,1,\\dots,N$, and spacing $\\Delta x = L/N$. Use the Finite Difference Method (FDM) to derive a tridiagonal linear system $a_i T_{i-1} + b_i T_i + c_i T_{i+1} = d_i$ for $i=0,1,\\dots,N$ that enforces the governing equation at interior nodes and boundary conditions at the endpoints. For variable $k(x)$, use consistent interface values $k_{i+1/2}$ defined by the harmonic mean\n$$\nk_{i+\\frac{1}{2}} = \\frac{2}{\\frac{1}{k_i} + \\frac{1}{k_{i+1}}}, \\quad \\text{with } k_i \\equiv k(x_i).\n$$\nFor interior nodes $i=1,\\dots,N-1$, discretize the flux divergence using a conservative two-point flux approximation:\n$$\n-\\,\\frac{k_{i-\\frac{1}{2}}}{\\Delta x}\\,T_{i-1} + \\frac{k_{i-\\frac{1}{2}} + k_{i+\\frac{1}{2}}}{\\Delta x}\\,T_i - \\frac{k_{i+\\frac{1}{2}}}{\\Delta x}\\,T_{i+1} = -\\,q'''_i\\,\\Delta x,\n$$\nwhere $q'''_i \\equiv q'''(x_i)$. For boundary conditions, enforce the following linear relations at $i=0$ (left) and $i=N$ (right):\n- Dirichlet (prescribed temperature): $T_0 = T_\\text{L}$ or $T_N = T_\\text{R}$.\n- Neumann (prescribed outward heat flux $q''$): $-\\,k\\,\\frac{dT}{dx}\\big|_{\\text{face}} = q''$ with a one-sided face gradient approximation over $\\Delta x/2$, yielding\n$$\n\\text{left:}\\quad \\bigg(\\frac{2k_{1/2}}{\\Delta x}\\bigg)T_0 \\;-\\;\\bigg(\\frac{2k_{1/2}}{\\Delta x}\\bigg)T_1 \\;=\\; q''_\\text{L}, \\qquad\n\\text{right:}\\quad -\\bigg(\\frac{2k_{N-\\frac{1}{2}}}{\\Delta x}\\bigg)T_{N-1} \\;+\\;\\bigg(\\frac{2k_{N-\\frac{1}{2}}}{\\Delta x}\\bigg)T_N \\;=\\; -\\,q''_\\text{R}.\n$$\n- Robin (convective boundary with ambient temperature $T_\\infty$ and heat transfer coefficient $h$): $-\\,k\\,\\frac{dT}{dx}\\big|_{\\text{face}} = h\\,(T_\\text{s} - T_\\infty)$, with the same face gradient approximation, yielding\n$$\n\\text{left:}\\quad \\bigg(\\frac{2k_{1/2}}{\\Delta x} + h_\\text{L}\\bigg)T_0 \\;-\\;\\bigg(\\frac{2k_{1/2}}{\\Delta x}\\bigg)T_1 \\;=\\; h_\\text{L}\\,T_{\\infty,\\text{L}},\n$$\n$$\n\\text{right:}\\quad -\\bigg(\\frac{2k_{N-\\frac{1}{2}}}{\\Delta x}\\bigg)T_{N-1} \\;+\\;\\bigg(\\frac{2k_{N-\\frac{1}{2}}}{\\Delta x} + h_\\text{R}\\bigg)T_N \\;=\\; h_\\text{R}\\,T_{\\infty,\\text{R}}.\n$$\nYou must implement the Thomas algorithm (TriDiagonal Matrix Algorithm (TDMA)) to solve the resulting tridiagonal system. Starting from first principles, derive the forward elimination and back substitution formulas explicitly and explain their correctness. Then, write a complete program that constructs the tridiagonal system for each test case and solves it using the derived TDMA formulas.\n\nPhysical units must be respected: use meters ($\\text{m}$), kelvin ($\\text{K}$), watts per meter-kelvin ($\\text{W}/(\\text{m}\\cdot\\text{K})$), watts per cubic meter ($\\text{W}/\\text{m}^3$), and watts per square meter-kelvin ($\\text{W}/(\\text{m}^2\\cdot\\text{K})$).\n\nTest suite:\n- Case $1$ (constant conductivity, Dirichlet–Dirichlet, no generation):\n  - $L = 1\\,\\text{m}$, $N = 10$, $k(x) \\equiv 10\\,\\text{W}/(\\text{m}\\cdot\\text{K})$, $q'''(x) \\equiv 0\\,\\text{W}/\\text{m}^3$, $T(0) = 300\\,\\text{K}$, $T(L) = 350\\,\\text{K}$.\n  - Output: the list of nodal temperatures $[T_0,\\dots,T_{10}]$ in $\\text{K}$.\n- Case $2$ (piecewise conductivity, Neumann–Dirichlet, no generation):\n  - $L = 1\\,\\text{m}$, $N = 8$, $k(x) = 100\\,\\text{W}/(\\text{m}\\cdot\\text{K})$ for $x  L/2$, and $k(x) = 200\\,\\text{W}/(\\text{m}\\cdot\\text{K})$ for $x \\ge L/2$, $q'''(x) \\equiv 0\\,\\text{W}/\\text{m}^3$, left boundary insulated ($q''_\\text{L} = 0\\,\\text{W}/\\text{m}^2$), right boundary $T(L) = 400\\,\\text{K}$.\n  - Output: the list of nodal temperatures $[T_0,\\dots,T_8]$ in $\\text{K}$.\n- Case $3$ (constant conductivity, Dirichlet–Dirichlet, uniform generation):\n  - $L = 0.02\\,\\text{m}$, $N = 20$, $k(x) \\equiv 200\\,\\text{W}/(\\text{m}\\cdot\\text{K})$, $q'''(x) \\equiv 1.0\\times 10^5\\,\\text{W}/\\text{m}^3$, $T(0) = 300\\,\\text{K}$, $T(L) = 300\\,\\text{K}$.\n  - Output: the list of nodal temperatures $[T_0,\\dots,T_{20}]$ in $\\text{K}$.\n- Case $4$ (constant conductivity, Robin–Robin, no generation):\n  - $L = 0.5\\,\\text{m}$, $N = 10$, $k(x) \\equiv 30\\,\\text{W}/(\\text{m}\\cdot\\text{K})$, $q'''(x) \\equiv 0\\,\\text{W}/\\text{m}^3$, left boundary: $h_\\text{L} = 100\\,\\text{W}/(\\text{m}^2\\cdot\\text{K})$, $T_{\\infty,\\text{L}} = 290\\,\\text{K}$, right boundary: $h_\\text{R} = 50\\,\\text{W}/(\\text{m}^2\\cdot\\text{K})$, $T_{\\infty,\\text{R}} = 310\\,\\text{K}$.\n  - Output: the list of nodal temperatures $[T_0,\\dots,T_{10}]$ in $\\text{K}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list of nodal temperatures in $\\text{K}$, rounded to $6$ decimal places. For example:\n$$\n[\\text{case1\\_list},\\text{case2\\_list},\\text{case3\\_list},\\text{case4\\_list}]\n$$\nwith no spaces in the output string.",
            "solution": "The user has provided a well-defined problem in computational heat transfer. All necessary governing equations, discretization schemes, boundary conditions, and test parameters are specified. The problem is scientifically sound, self-contained, and algorithmically solvable. Therefore, the problem is valid.\n\n### 1. Finite Difference Formulation\n\nThe problem is to solve the one-dimensional, steady-state heat conduction equation with variable thermal conductivity $k(x)$ and volumetric heat generation $q'''(x)$:\n$$\n\\frac{d}{dx}\\left(k(x)\\frac{dT}{dx}\\right) + q'''(x) = 0\n$$\nThe domain $x \\in [0, L]$ is discretized into a uniform grid with $N$ intervals, resulting in $N+1$ nodes indexed $i=0, 1, \\dots, N$. The grid spacing is $\\Delta x = L/N$, and the nodal positions are $x_i = i \\Delta x$. We seek the nodal temperatures $T_i \\approx T(x_i)$.\n\nA conservative finite difference scheme is derived by integrating the governing equation over a control volume (CV) of length $\\Delta x$ centered at each interior node $x_i$. The CV extends from $x_{i-1/2}$ to $x_{i+1/2}$.\n$$\n\\int_{x_{i-1/2}}^{x_{i+1/2}} \\left( \\frac{d}{dx}\\left(k\\frac{dT}{dx}\\right) + q''' \\right) dx = 0\n$$\nApplying the fundamental theorem of calculus to the first term and approximating the integral of the source term gives:\n$$\n\\left. \\left(k\\frac{dT}{dx}\\right) \\right|_{x_{i+1/2}} - \\left. \\left(k\\frac{dT}{dx}\\right) \\right|_{x_{i-1/2}} + q'''_i \\Delta x = 0\n$$\nThe heat fluxes at the CV faces are approximated using centered differences:\n$$\n\\left. \\left(k\\frac{dT}{dx}\\right) \\right|_{x_{i+1/2}} \\approx k_{i+1/2} \\frac{T_{i+1} - T_i}{\\Delta x}\n$$\n$$\n\\left. \\left(k\\frac{dT}{dx}\\right) \\right|_{x_{i-1/2}} \\approx k_{i-1/2} \\frac{T_i - T_{i-1}}{\\Delta x}\n$$\nThe interface thermal conductivity $k_{i \\pm 1/2}$ is calculated using the harmonic mean to correctly handle abrupt changes in material properties and ensure continuity of heat flux:\n$$\nk_{i-1/2} = \\frac{2}{\\frac{1}{k_{i-1}} + \\frac{1}{k_i}}, \\quad k_{i+1/2} = \\frac{2}{\\frac{1}{k_i} + \\frac{1}{k_{i+1}}}\n$$\nSubstituting the flux approximations into the integrated energy balance yields:\n$$\nk_{i+1/2} \\frac{T_{i+1} - T_i}{\\Delta x} - k_{i-1/2} \\frac{T_i - T_{i-1}}{\\Delta x} + q'''_i \\Delta x = 0\n$$\nMultiplying by $-\\Delta x$ and rearranging terms gives the linear equation for an interior node $i \\in [1, N-1]$ provided in the problem statement:\n$$\n\\left(-\\frac{k_{i-1/2}}{\\Delta x}\\right) T_{i-1} + \\left(\\frac{k_{i-1/2} + k_{i+1/2}}{\\Delta x}\\right) T_i + \\left(-\\frac{k_{i+1/2}}{\\Delta x}\\right) T_{i+1} = -q'''_i \\Delta x\n$$\nThis equation fits the general tridiagonal form $a_i T_{i-1} + b_i T_i + c_i T_{i+1} = d_i$.\n\n### 2. Assembling the Tridiagonal System\n\nThe complete system of $N+1$ linear equations for the $N+1$ unknown temperatures $T_0, \\dots, T_N$ is formed by applying the appropriate equation at each node.\n\n**Interior Nodes ($i = 1, \\dots, N-1$):**\n- $a_i = -k_{i-1/2} / \\Delta x$\n- $b_i = (k_{i-1/2} + k_{i+1/2}) / \\Delta x$\n- $c_i = -k_{i+1/2} / \\Delta x$\n- $d_i = -q'''_i \\Delta x$\n\n**Boundary Nodes ($i=0$ and $i=N$):**\nThe first ($i=0$) and last ($i=N$) rows of the system are determined by the boundary conditions.\n\n**Left Boundary ($i=0$):**\n1.  **Dirichlet:** $T_0 = T_L$. The equation is $1 \\cdot T_0 + 0 \\cdot T_1 = T_L$.\n    - $b_0 = 1$, $c_0 = 0$, $d_0 = T_L$. ($a_0$ is not used).\n2.  **Neumann:** $-\\,k\\,\\frac{dT}{dx}\\big|_{\\text{face}} = q''_\\text{L}$. The provided discretization is $\\left(\\frac{2k_{1/2}}{\\Delta x}\\right)T_0 - \\left(\\frac{2k_{1/2}}{\\Delta x}\\right)T_1 = q''_\\text{L}$.\n    - $b_0 = 2k_{1/2} / \\Delta x$, $c_0 = -2k_{1/2} / \\Delta x$, $d_0 = q''_\\text{L}$.\n3.  **Robin:** The provided discretization is $\\left(\\frac{2k_{1/2}}{\\Delta x} + h_\\text{L}\\right)T_0 - \\left(\\frac{2k_{1/2}}{\\Delta x}\\right)T_1 = h_\\text{L}T_{\\infty,\\text{L}}$.\n    - $b_0 = 2k_{1/2}/\\Delta x + h_\\text{L}$, $c_0 = -2k_{1/2}/\\Delta x$, $d_0 = h_\\text{L}T_{\\infty,\\text{L}}$.\n\n**Right Boundary ($i=N$):**\n1.  **Dirichlet:** $T_N = T_R$. The equation is $1 \\cdot T_N = T_R$.\n    - $a_N = 0$, $b_N = 1$, $d_N = T_R$. ($c_N$ is not used).\n2.  **Neumann:** $-\\,k\\,\\frac{dT}{dx}\\big|_{\\text{face}} = q''_\\text{R}$. The provided discretization is $-\\left(\\frac{2k_{N-1/2}}{\\Delta x}\\right)T_{N-1} + \\left(\\frac{2k_{N-1/2}}{\\Delta x}\\right)T_N = -q''_\\text{R}$.\n    - $a_N = -2k_{N-1/2}/\\Delta x$, $b_N = 2k_{N-1/2}/\\Delta x$, $d_N = -q''_\\text{R}$.\n3.  **Robin:** The provided discretization is $-\\left(\\frac{2k_{N-1/2}}{\\Delta x}\\right)T_{N-1} + \\left(\\frac{2k_{N-1/2}}{\\Delta x} + h_\\text{R}\\right)T_N = h_\\text{R}T_{\\infty,\\text{R}}$.\n    - $a_N = -2k_{N-1/2}/\\Delta x$, $b_N = 2k_{N-1/2}/\\Delta x + h_\\text{R}$, $d_N = h_\\text{R}T_{\\infty,\\text{R}}$.\n\nThese coefficients form a tridiagonal system of linear equations of size $(N+1) \\times (N+1)$, which can be solved efficiently.\n\n### 3. Derivation of the Thomas Algorithm (TDMA)\n\nThe Thomas algorithm, or Tridiagonal Matrix Algorithm (TDMA), is a specialized form of Gaussian elimination for tridiagonal systems. It solves the system in $O(N)$ operations, which is significantly more efficient than a general $O(N^3)$ matrix inversion. The derivation consists of a forward elimination pass followed by a backward substitution pass.\n\nConsider the system of equations for $i = 0, \\dots, N$:\n$$\na_i T_{i-1} + b_i T_i + c_i T_{i+1} = d_i\n$$\nwhere by definition $a_0 = 0$ and $c_N = 0$.\n\n**Forward Elimination Pass:**\nThe goal of this pass is to transform the system into an upper bidiagonal form. We achieve this by eliminating the sub-diagonal elements $a_i$.\n\nThe first equation ($i=0$) is $b_0 T_0 + c_0 T_1 = d_0$. We can express $T_0$ in terms of $T_1$:\n$$\nT_0 = -\\frac{c_0}{b_0} T_1 + \\frac{d_0}{b_0}\n$$\nThe second equation ($i=1$) is $a_1 T_0 + b_1 T_1 + c_1 T_2 = d_1$. Substituting the expression for $T_0$:\n$$\na_1 \\left(-\\frac{c_0}{b_0} T_1 + \\frac{d_0}{b_0}\\right) + b_1 T_1 + c_1 T_2 = d_1\n$$\nRearranging terms:\n$$\n\\left(b_1 - \\frac{a_1 c_0}{b_0}\\right) T_1 + c_1 T_2 = d_1 - \\frac{a_1 d_0}{b_0}\n$$\nThis process can be generalized. We perform row operations that transform each equation to the form $T_i + c'_i T_{i+1} = d'_i$.\nLet's define modified coefficients $c'_i$ and $d'_i$.\n\nFor $i=0$:\n$$\nc'_0 = \\frac{c_0}{b_0}, \\quad d'_0 = \\frac{d_0}{b_0}\n$$\nFor $i  0$, we have the original equation $a_i T_{i-1} + b_i T_i + c_i T_{i+1} = d_i$ and the previously modified equation for row $i-1$: $T_{i-1} = -c'_{i-1} T_i + d'_{i-1}$. Substituting the expression for $T_{i-1}$ into the original equation for row $i$:\n$$\na_i (-c'_{i-1} T_i + d'_{i-1}) + b_i T_i + c_i T_{i+1} = d_i\n$$\nGrouping terms by $T_i$ and $T_{i+1}$:\n$$\n(b_i - a_i c'_{i-1}) T_i + c_i T_{i+1} = d_i - a_i d'_{i-1}\n$$\nDividing by the new coefficient of $T_i$ to isolate it yields the recurrence relations for the modified coefficients:\n$$\nc'_i = \\frac{c_i}{b_i - a_i c'_{i-1}}, \\quad d'_i = \\frac{d_i - a_i d'_{i-1}}{b_i - a_i c'_{i-1}}\n$$\nThese recurrences are applied for $i = 1, \\dots, N$. Note that for $i=N$, $c_N=0$, so $c'_N=0$.\n\nThe forward elimination sweep proceeds as follows:\n1.  Calculate $c'_0 = c_0/b_0$ and $d'_0 = d_0/b_0$.\n2.  For $i = 1, \\dots, N$, calculate $c'_i$ and $d'_i$ using the recurrence relations.\n\n**Backward Substitution Pass:**\nAfter the forward pass, the system has been transformed into an upper bidiagonal form:\n$$\nT_i + c'_i T_{i+1} = d'_i \\quad \\text{for } i=0, \\dots, N-1\n$$\n$$\nT_N = d'_N \\quad (\\text{since } c'_N = 0)\n$$\nThe last temperature $T_N$ is known directly:\n$$\nT_N = d'_N\n$$\nThe remaining temperatures can be found by substituting backwards from $i=N-1$ down to $0$:\n$$\nT_i = d'_i - c'_i T_{i+1}\n$$\nThe back substitution sweep proceeds as follows:\n1.  Set $T_N = d'_N$.\n2.  For $i = N-1, N-2, \\dots, 0$, calculate $T_i = d'_i - c'_i T_{i+1}$.\n\nThis two-pass procedure completes the solution. The algorithm is numerically stable for diagonally dominant matrices, a condition met by the physical systems under consideration.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_tdma(a, b, c, d):\n    \"\"\"\n    Solves a tridiagonal linear system Ax=d using the Thomas algorithm (TDMA).\n\n    Args:\n        a (np.ndarray): The sub-diagonal (indices 1 to n-1). a[0] is ignored.\n        b (np.ndarray): The main diagonal (indices 0 to n-1).\n        c (np.ndarray): The super-diagonal (indices 0 to n-2). c[n-1] is ignored.\n        d (np.ndarray): The right-hand side vector.\n\n    Returns:\n        np.ndarray: The solution vector x.\n    \"\"\"\n    n = len(d)\n    c_prime = np.zeros(n)\n    d_prime = np.zeros(n)\n    x = np.zeros(n)\n\n    # Forward elimination\n    c_prime[0] = c[0] / b[0]\n    d_prime[0] = d[0] / b[0]\n\n    for i in range(1, n):\n        denom = b[i] - a[i] * c_prime[i-1]\n        c_prime[i] = c[i] / denom\n        d_prime[i] = (d[i] - a[i] * d_prime[i-1]) / denom\n\n    # Backward substitution\n    x[n-1] = d_prime[n-1]\n    for i in range(n-2, -1, -1):\n        x[i] = d_prime[i] - c_prime[i] * x[i+1]\n\n    return x\n\ndef solve_heat_conduction(L, N, k_func, q_func, bc_left, bc_right):\n    \"\"\"\n    Constructs and solves the 1D steady heat conduction problem using FDM.\n    \"\"\"\n    # 1. Setup grid and properties\n    x_nodes = np.linspace(0, L, N + 1)\n    dx = L / N\n    \n    k_vals = np.array([k_func(x) for x in x_nodes])\n    q_vals = np.array([q_func(x) for x in x_nodes])\n\n    # 2. Compute interface conductivities\n    k_interface = np.zeros(N)\n    for i in range(N):\n        # Harmonic mean for k_{i+1/2}\n        if k_vals[i] == 0 or k_vals[i+1] == 0:\n            k_interface[i] = 0 # Or handle as insulated\n        else:\n            k_interface[i] = 2.0 / (1.0/k_vals[i] + 1.0/k_vals[i+1])\n\n    # 3. Initialize tridiagonal system coefficients\n    num_nodes = N + 1\n    a = np.zeros(num_nodes) # sub-diagonal\n    b = np.zeros(num_nodes) # main-diagonal\n    c = np.zeros(num_nodes) # super-diagonal\n    d = np.zeros(num_nodes) # RHS vector\n\n    # 4. Fill coefficients for interior nodes (i = 1 to N-1)\n    for i in range(1, N):\n        a[i] = -k_interface[i-1] / dx\n        b[i] = (k_interface[i-1] + k_interface[i]) / dx\n        c[i] = -k_interface[i] / dx\n        d[i] = -q_vals[i] * dx\n\n    # 5. Fill coefficients for boundary nodes (i=0 and i=N)\n    # Left boundary (i=0)\n    bc_type_L, bc_val_L = bc_left[0], bc_left[1:]\n    if bc_type_L == 'dirichlet':\n        b[0] = 1.0\n        c[0] = 0.0\n        d[0] = bc_val_L[0]\n    elif bc_type_L == 'neumann':\n        q_L = bc_val_L[0]\n        b[0] = 2 * k_interface[0] / dx\n        c[0] = -2 * k_interface[0] / dx\n        d[0] = q_L\n    elif bc_type_L == 'robin':\n        h_L, T_inf_L = bc_val_L\n        b[0] = 2 * k_interface[0] / dx + h_L\n        c[0] = -2 * k_interface[0] / dx\n        d[0] = h_L * T_inf_L\n\n    # Right boundary (i=N)\n    bc_type_R, bc_val_R = bc_right[0], bc_right[1:]\n    if bc_type_R == 'dirichlet':\n        a[N] = 0.0\n        b[N] = 1.0\n        d[N] = bc_val_R[0]\n    elif bc_type_R == 'neumann':\n        q_R = bc_val_R[0]\n        a[N] = -2 * k_interface[N-1] / dx\n        b[N] = 2 * k_interface[N-1] / dx\n        d[N] = -q_R\n    elif bc_type_R == 'robin':\n        h_R, T_inf_R = bc_val_R\n        a[N] = -2 * k_interface[N-1] / dx\n        b[N] = 2 * k_interface[N-1] / dx + h_R\n        d[N] = h_R * T_inf_R\n\n    # 6. Solve the system\n    T = solve_tdma(a, b, c, d)\n    return T\n\n\ndef solve():\n    test_cases = [\n        # Case 1\n        {\n            \"L\": 1.0, \"N\": 10, \"k_func\": lambda x: 10.0, \"q_func\": lambda x: 0.0,\n            \"bc_left\": ('dirichlet', 300.0), \"bc_right\": ('dirichlet', 350.0)\n        },\n        # Case 2\n        {\n            \"L\": 1.0, \"N\": 8, \"k_func\": lambda x: 100.0 if x  0.5 else 200.0, \"q_func\": lambda x: 0.0,\n            \"bc_left\": ('neumann', 0.0), \"bc_right\": ('dirichlet', 400.0)\n        },\n        # Case 3\n        {\n            \"L\": 0.02, \"N\": 20, \"k_func\": lambda x: 200.0, \"q_func\": lambda x: 1.0e5,\n            \"bc_left\": ('dirichlet', 300.0), \"bc_right\": ('dirichlet', 300.0)\n        },\n        # Case 4\n        {\n            \"L\": 0.5, \"N\": 10, \"k_func\": lambda x: 30.0, \"q_func\": lambda x: 0.0,\n            \"bc_left\": ('robin', 100.0, 290.0), \"bc_right\": ('robin', 50.0, 310.0)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        T = solve_heat_conduction(\n            case[\"L\"], case[\"N\"], case[\"k_func\"], case[\"q_func\"],\n            case[\"bc_left\"], case[\"bc_right\"]\n        )\n        results.append(T)\n\n    # Format the final output string exactly as required\n    result_strings = []\n    for T in results:\n        # Format each temperature list to a string '[T0,T1,...]'\n        # with numbers rounded to 6 decimal places.\n        temp_list_str = f\"[{','.join([f'{temp:.6f}' for temp in T])}]\"\n        result_strings.append(temp_list_str)\n\n    # Join the individual case strings into the final format '[[...],[...]]'\n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "A solver that produces numbers is not enough; we need confidence that those numbers are correct. This exercise introduces a cornerstone of scientific computing: code verification using the Method of Manufactured Solutions (MMS). By testing your code against a problem with a known, non-trivial analytical solution, you will perform a mesh refinement study to quantitatively measure your code's accuracy and confirm that it achieves the expected theoretical convergence rate .",
            "id": "3954376",
            "problem": "Consider one-dimensional steady heat conduction on the spatial interval $[0,1]$ in meters, with thermal conductivity $k(x)$ and volumetric heat generation rate $s(x)$ in watts per cubic meter. The governing equation follows from the combination of Fourier's law of heat conduction and energy conservation in steady state, which yields the differential equation\n$$\n-\\frac{d}{dx}\\left(k(x)\\frac{dT}{dx}\\right) = s(x),\n$$\nwith boundary conditions specified at $x=0$ and $x=1$. You will implement a second-order accurate finite difference method (FDM) on a uniform mesh of $N$ nodes (including boundaries), with $h = \\frac{1}{N-1}$, to numerically approximate the temperature field $T(x)$ in kelvin. Use the conservative interior discretization\n$$\n-\\frac{1}{h^2}\\left(k_{i+\\frac{1}{2}}\\left(T_{i+1}-T_i\\right) - k_{i-\\frac{1}{2}}\\left(T_i - T_{i-1}\\right)\\right) = s(x_i),\n$$\nfor interior nodes $i=1,\\dots,N-2$, where the interface conductivity $k_{i\\pm\\frac{1}{2}}$ must be approximated by the harmonic mean\n$$\nk_{i+\\frac{1}{2}} = \\left(\\frac{1}{2}\\left(\\frac{1}{k_i} + \\frac{1}{k_{i+1}}\\right)\\right)^{-1} = \\frac{2 k_i k_{i+1}}{k_i + k_{i+1}},\n$$\nand similarly for $k_{i-\\frac{1}{2}}$. For Dirichlet boundary conditions, enforce the exact temperature at the boundary nodes. For a Neumann boundary condition at $x=1$ with zero heat flux and constant conductivity, enforce the boundary derivative using the second-order accurate formula\n$$\n\\frac{3 T_{N-1} - 4 T_{N-2} + T_{N-3}}{2h} = 0.\n$$\nYou will perform a mesh refinement analysis using a manufactured solution so that the analytical solution is known. For each test case, define the exact solution $T_{\\text{exact}}(x)$ in kelvin, the conductivity $k(x)$, and the source term $s(x)$ in watts per cubic meter derived from the governing equation, and appropriate boundary conditions. Compute the numerical solution for three successive values of $N$ and evaluate the discrete $L^2$ error norm\n$$\nE_N = \\sqrt{h \\sum_{i=0}^{N-1} \\left(T_i^{\\text{num}} - T_{\\text{exact}}(x_i)\\right)^2},\n$$\nwhere $x_i = i h$, $T_i^{\\text{num}}$ is the computed numerical temperature at node $i$, and $T_{\\text{exact}}(x_i)$ is the exact temperature at the node. From the two finest meshes, compute the observed order of accuracy\n$$\np_{\\text{obs}} = \\frac{\\ln\\left(E_{N_2}/E_{N_3}\\right)}{\\ln\\left(h_{N_2}/h_{N_3}\\right)},\n$$\nwith $h_N = \\frac{1}{N-1}$ and $(N_1,N_2,N_3)$ being the successive mesh sizes for the test case. Report $p_{\\text{obs}}$ as a dimensionless float.\n\nTest Suite:\n- Test Case 1 (Dirichlet–Dirichlet, constant conductivity):\n  - Domain: $x \\in [0,1]$ meters.\n  - Conductivity: $k(x) = 1$ watt per meter-kelvin.\n  - Exact solution: $T_{\\text{exact}}(x) = \\sin(\\pi x)$ kelvin.\n  - Source: $s(x) = -\\frac{d}{dx}\\left(k(x)\\frac{dT_{\\text{exact}}}{dx}\\right) = \\pi^2 \\sin(\\pi x)$ watts per cubic meter.\n  - Boundary conditions: $T(0) = 0$ kelvin, $T(1) = 0$ kelvin.\n  - Mesh sizes: $(N_1,N_2,N_3) = (21, 41, 81)$.\n\n- Test Case 2 (Dirichlet–Dirichlet, smoothly varying conductivity):\n  - Domain: $x \\in [0,1]$ meters.\n  - Conductivity: $k(x) = 1 + x$ watts per meter-kelvin.\n  - Exact solution: $T_{\\text{exact}}(x) = \\sin(\\pi x)$ kelvin.\n  - Source: $s(x) = -\\frac{d}{dx}\\left(k(x)\\frac{dT_{\\text{exact}}}{dx}\\right) = (1+x)\\pi^2 \\sin(\\pi x) - \\pi \\cos(\\pi x)$ watts per cubic meter.\n  - Boundary conditions: $T(0) = 0$ kelvin, $T(1) = 0$ kelvin.\n  - Mesh sizes: $(N_1,N_2,N_3) = (17, 33, 65)$.\n\n- Test Case 3 (Dirichlet–Neumann, constant conductivity with zero-flux at the right boundary):\n  - Domain: $x \\in [0,1]$ meters.\n  - Conductivity: $k(x) = 1$ watt per meter-kelvin.\n  - Exact solution: $T_{\\text{exact}}(x) = \\sin\\left(\\frac{\\pi}{2} x\\right)$ kelvin.\n  - Source: $s(x) = -\\frac{d}{dx}\\left(k(x)\\frac{dT_{\\text{exact}}}{dx}\\right) = \\left(\\frac{\\pi}{2}\\right)^2 \\sin\\left(\\frac{\\pi}{2} x\\right)$ watts per cubic meter.\n  - Boundary conditions: $T(0) = 0$ kelvin, and zero-flux $k \\frac{dT}{dx}(1) = 0$ at $x=1$.\n  - Mesh sizes: $(N_1,N_2,N_3) = (19, 37, 73)$.\n\nYour program must:\n- Implement the described FDM, assemble and solve the resulting linear system for each $N$.\n- Compute $E_{N}$ for each $N$ in each test case, then compute $p_{\\text{obs}}$ from the two finest meshes.\n- Produce a single line of output containing the three $p_{\\text{obs}}$ values, in order of the test cases, as a comma-separated list enclosed in square brackets. For example: \"[p1,p2,p3]\".\nAll outputs for $p_{\\text{obs}}$ are dimensionless floats.",
            "solution": "The problem requires the implementation of a second-order accurate finite difference method (FDM) to solve the one-dimensional, steady-state heat conduction equation on the interval $x \\in [0, 1]$. The governing equation is\n$$\n-\\frac{d}{dx}\\left(k(x)\\frac{dT}{dx}\\right) = s(x),\n$$\nwhere $T(x)$ is the temperature, $k(x)$ is the thermal conductivity, and $s(x)$ is the volumetric heat generation rate. The objective is to perform a mesh refinement study using the Method of Manufactured Solutions to verify the second-order accuracy of the numerical scheme.\n\nFirst, the spatial domain $[0, 1]$ is discretized into a uniform mesh of $N$ nodes. The coordinates of the nodes are given by $x_i = i h$ for $i = 0, 1, \\dots, N-1$, where $h = 1/(N-1)$ is the constant grid spacing. The temperature at these nodes, $T(x_i)$, is denoted by $T_i$.\n\nFor the interior nodes, $i = 1, \\dots, N-2$, we apply the provided conservative finite difference discretization. This scheme is derived by integrating the governing equation over a control volume centered at each node, from $x_i - h/2$ to $x_i + h/2$. This leads to the discrete equation:\n$$\n-\\frac{1}{h} \\left( \\left. k \\frac{dT}{dx} \\right|_{i+\\frac{1}{2}} - \\left. k \\frac{dT}{dx} \\right|_{i-\\frac{1}{2}} \\right) = s(x_i).\n$$\nThe fluxes at the control volume faces, $\\left. k \\frac{dT}{dx} \\right|_{i\\pm\\frac{1}{2}}$, are approximated using a central difference, for instance $\\left. k \\frac{dT}{dx} \\right|_{i+\\frac{1}{2}} \\approx k_{i+\\frac{1}{2}} \\frac{T_{i+1}-T_i}{h}$. This results in the specified formula:\n$$\n-\\frac{1}{h^2}\\left(k_{i+\\frac{1}{2}}\\left(T_{i+1}-T_i\\right) - k_{i-\\frac{1}{2}}\\left(T_i - T_{i-1}\\right)\\right) = s(x_i).\n$$\nThe interface conductivities $k_{i\\pm\\frac{1}{2}}$ are calculated using the harmonic mean of the conductivities at the adjacent nodes:\n$$\nk_{i+\\frac{1}{2}} = \\frac{2 k(x_i) k(x_{i+1})}{k(x_i) + k(x_{i+1})} \\quad \\text{and} \\quad k_{i-\\frac{1}{2}} = \\frac{2 k(x_{i-1}) k(x_i)}{k(x_{i-1}) + k(x_i)}.\n$$\nThe harmonic mean is particularly effective for ensuring flux conservation, especially when conductivity varies sharply.\n\nRearranging the interior node equation to group terms by the unknown temperatures $T_{i-1}$, $T_i$, and $T_{i+1}$ yields a linear algebraic equation for each interior node $i$:\n$$\n\\left(-\\frac{k_{i-\\frac{1}{2}}}{h^2}\\right) T_{i-1} + \\left(\\frac{k_{i-\\frac{1}{2}} + k_{i+\\frac{1}{2}}}{h^2}\\right) T_i + \\left(-\\frac{k_{i+\\frac{1}{2}}}{h^2}\\right) T_{i+1} = s(x_i).\n$$\nThese $N-2$ equations, combined with two equations for the boundary conditions at nodes $i=0$ and $i=N-1$, form a system of $N$ linear equations in $N$ unknowns, which can be written in matrix form as $A\\mathbf{T} = \\mathbf{b}$. Here, $\\mathbf{T} = [T_0, T_1, \\dots, T_{N-1}]^T$ is the vector of unknown nodal temperatures, $A$ is an $N \\times N$ coefficient matrix, and $\\mathbf{b}$ is an $N \\times 1$ source vector.\n\nThe boundary conditions determine the first ($i=0$) and last ($i=N-1$) rows of the system.\nFor a Dirichlet boundary condition, such as $T(0) = T_0^{\\text{exact}}$, the corresponding equation is simply $1 \\cdot T_0 = T_0^{\\text{exact}}$. This sets the first row of matrix $A$ to $[1, 0, \\dots, 0]$ and the first element of $\\mathbf{b}$ to $T_0^{\\text{exact}}$. A Dirichlet condition at $x=1$ is handled similarly for the last row.\n\nFor the zero-flux Neumann boundary condition at $x=1$, $k(1)\\frac{dT}{dx}(1) = 0$, a discrete approximation for the derivative is required. The problem specifies a second-order accurate, one-sided formula:\n$$\n\\frac{3 T_{N-1} - 4 T_{N-2} + T_{N-3}}{2h} = 0.\n$$\nThis directly gives the final equation of the system: $T_{N-3} - 4T_{N-2} + 3T_{N-1} = 0$. For this equation, the last row of matrix $A$ will have non-zero entries in columns $N-3$, $N-2$, and $N-1$, with values $1$, $-4$, and $3$ respectively. The corresponding element in $\\mathbf{b}$ is $0$.\n\nOnce the matrix $A$ and vector $\\mathbf{b}$ are fully assembled for a given test case and mesh size $N$, the linear system is solved for the numerical solution vector $\\mathbf{T}^{\\text{num}}$.\n\nTo verify the implementation, we use the manufactured solutions provided. For each $N$, the numerical solution $\\mathbf{T}^{\\text{num}}$ is compared against the exact solution evaluated at the grid points, $\\mathbf{T}^{\\text{exact}}$. The error is quantified using the discrete $L^2$ norm:\n$$\nE_N = \\sqrt{h \\sum_{i=0}^{N-1} \\left(T_i^{\\text{num}} - T_{\\text{exact}}(x_i)\\right)^2}.\n$$\nThe observed order of accuracy, $p_{\\text{obs}}$, is then computed using the errors from the two finest meshes, $N_2$ and $N_3$:\n$$\np_{\\text{obs}} = \\frac{\\ln\\left(E_{N_2}/E_{N_3}\\right)}{\\ln\\left(h_{N_2}/h_{N_3}\\right)}.\n$$\nFor a second-order accurate scheme, we expect $p_{\\text{obs}} \\approx 2$ as the mesh is refined. The program will execute this procedure for all three test cases and report the calculated $p_{\\text{obs}}$ values.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_bvp(N, k_func, s_func, bc_left_tuple, bc_right_tuple):\n    \"\"\"\n    Solves the 1D steady conduction BVP using a finite difference method.\n\n    Args:\n        N (int): Number of grid nodes.\n        k_func (callable): Function k(x) for thermal conductivity.\n        s_func (callable): Function s(x) for the source term.\n        bc_left_tuple (tuple): Tuple of (type, value) for the left BC.\n        bc_right_tuple (tuple): Tuple of (type, value) for the right BC.\n\n    Returns:\n        np.array: The numerical solution for temperature T at the grid nodes.\n    \"\"\"\n    h = 1.0 / (N - 1)\n    x = np.linspace(0.0, 1.0, N)\n\n    k_vals = k_func(x)\n    s_vals = s_func(x)\n\n    A = np.zeros((N, N))\n    b = np.zeros(N)\n\n    # Interior nodes (i=1, ..., N-2)\n    for i in range(1, N - 1):\n        k_im1 = k_vals[i - 1]\n        k_i = k_vals[i]\n        k_ip1 = k_vals[i + 1]\n\n        # Harmonic mean for interface conductivity\n        k_imhalf = (2.0 * k_im1 * k_i) / (k_im1 + k_i)\n        k_iphalf = (2.0 * k_i * k_ip1) / (k_i + k_ip1)\n\n        A[i, i - 1] = -k_imhalf / (h * h)\n        A[i, i] = (k_imhalf + k_iphalf) / (h * h)\n        A[i, i + 1] = -k_iphalf / (h * h)\n        b[i] = s_vals[i]\n\n    # Boundary conditions\n    # Left BC at x=0 (node i=0)\n    bc_left_type, bc_left_val = bc_left_tuple\n    if bc_left_type == 'dirichlet':\n        A[0, 0] = 1.0\n        b[0] = bc_left_val\n    \n    # Right BC at x=1 (node i=N-1)\n    bc_right_type, bc_right_val = bc_right_tuple\n    if bc_right_type == 'dirichlet':\n        A[N - 1, N - 1] = 1.0\n        b[N - 1] = bc_right_val\n    elif bc_right_type == 'neumann':\n        # Zero-flux Neumann BC: 3*T_{N-1} - 4*T_{N-2} + T_{N-3} = 0\n        if bc_right_val == 0.0:\n            A[N - 1, N - 3] = 1.0\n            A[N - 1, N - 2] = -4.0\n            A[N - 1, N - 1] = 3.0\n            b[N - 1] = 0.0\n\n    # Solve the linear system\n    T_num = np.linalg.solve(A, b)\n    return T_num\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Case 1: DD, constant k\",\n            \"k_func\": lambda x: np.full_like(x, 1.0),\n            \"T_exact_func\": lambda x: np.sin(np.pi * x),\n            \"s_func\": lambda x: np.pi**2 * np.sin(np.pi * x),\n            \"bc_left\": ('dirichlet', 0.0),\n            \"bc_right\": ('dirichlet', 0.0),\n            \"meshes\": (21, 41, 81)\n        },\n        {\n            \"name\": \"Case 2: DD, variable k\",\n            \"k_func\": lambda x: 1.0 + x,\n            \"T_exact_func\": lambda x: np.sin(np.pi * x),\n            \"s_func\": lambda x: (1.0 + x) * np.pi**2 * np.sin(np.pi * x) - np.pi * np.cos(np.pi * x),\n            \"bc_left\": ('dirichlet', 0.0),\n            \"bc_right\": ('dirichlet', 0.0),\n            \"meshes\": (17, 33, 65)\n        },\n        {\n            \"name\": \"Case 3: DN, constant k\",\n            \"k_func\": lambda x: np.full_like(x, 1.0),\n            \"T_exact_func\": lambda x: np.sin(np.pi / 2.0 * x),\n            \"s_func\": lambda x: (np.pi / 2.0)**2 * np.sin(np.pi / 2.0 * x),\n            \"bc_left\": ('dirichlet', 0.0),\n            \"bc_right\": ('neumann', 0.0),\n            \"meshes\": (19, 37, 73)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        errors = []\n        h_vals = []\n        for N in case[\"meshes\"]:\n            h = 1.0 / (N - 1)\n            x = np.linspace(0.0, 1.0, N)\n            \n            # Solve for numerical temperature\n            T_num = solve_bvp(N, case[\"k_func\"], case[\"s_func\"], case[\"bc_left\"], case[\"bc_right\"])\n            \n            # Get exact temperature\n            T_exact = case[\"T_exact_func\"](x)\n            \n            # Calculate L2 error\n            error = np.sqrt(h * np.sum((T_num - T_exact)**2))\n            errors.append(error)\n            h_vals.append(h)\n            \n        # Unpack errors and grid spacings\n        E_N2, E_N3 = errors[1], errors[2]\n        h_N2, h_N3 = h_vals[1], h_vals[2]\n\n        # Compute observed order of accuracy\n        p_obs = np.log(E_N2 / E_N3) / np.log(h_N2 / h_N3)\n        results.append(p_obs)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "With a verified code, we can tackle more complex and realistic physical scenarios. This practice focuses on validating the treatment of a common engineering feature: heat transfer across a composite slab with thermal contact resistance at the interface. You will implement a specific discretization for the material interface and compare your numerical results against a known analytical solution, a crucial step in ensuring your model can faithfully represent real-world physics .",
            "id": "3954435",
            "problem": "Consider a two-layer planar slab in one-dimensional steady heat conduction with constant thermal conductivities in each layer and a thermal contact resistance at the interface. The governing physical basis is energy conservation and Fourier’s law of heat conduction. In steady state, the heat flux is spatially constant and the temperature field in each homogeneous layer is linear. The interface exhibits a finite temperature jump proportional to the heat flux due to the thermal contact resistance. The boundaries at the two ends are prescribed temperatures (Dirichlet type). The objective is to validate a finite difference discretization that treats the interface using a resistance-based face conductance against the exact analytical solution.\n\nYou must derive and implement a discretization that follows from integrating the steady one-dimensional conduction equation over control volumes and expressing face heat fluxes through thermal resistances. Assume a unit cross-sectional area. Use the following fundamental bases:\n- Energy conservation for a stationary control volume: the net conductive heat flow across the control volume surfaces equals zero in steady state.\n- Fourier’s law of heat conduction: the heat flux is given by $q = -k \\,\\dfrac{dT}{dx}$, where $k$ is the thermal conductivity, $T$ is the temperature, and $x$ is the spatial coordinate.\n- Thermal contact resistance at the interface: the temperature drop across the interface is $\\Delta T_{\\text{int}} = q\\,R_c$, where $R_c$ is the contact resistance.\n\nDiscretization requirements:\n- Partition layer $1$ of thickness $L_1$ into $N_1$ uniform control volumes of width $\\Delta x_1 = L_1/N_1$. Partition layer $2$ of thickness $L_2$ into $N_2$ uniform control volumes of width $\\Delta x_2 = L_2/N_2$. Place nodal unknowns at control volume centers; the interface coincides with the face between the last control volume of layer $1$ and the first control volume of layer $2$.\n- For an interior face in a homogeneous layer with conductivity $k$, use the face conductance $G = \\dfrac{1}{\\left(\\dfrac{\\Delta x}{2}\\dfrac{1}{k} + \\dfrac{\\Delta x}{2}\\dfrac{1}{k}\\right)} = \\dfrac{k}{\\Delta x}$.\n- For a boundary face with a Dirichlet temperature $T_{\\mathrm{b}}$, use the half-cell face conductance $G = \\dfrac{1}{\\left(\\dfrac{\\Delta x}{2}\\dfrac{1}{k}\\right)} = \\dfrac{2k}{\\Delta x}$ and incorporate $G\\,T_{\\mathrm{b}}$ into the source term of the adjacent node’s discrete balance.\n- For the interface face between the two layers with conductivities $k_1$ and $k_2$, half-cell widths $\\dfrac{\\Delta x_1}{2}$ and $\\dfrac{\\Delta x_2}{2}$, and contact resistance $R_c$ (units $\\mathrm{m^2\\,K/W}$), use the composite face conductance $$G_{\\mathrm{int}} = \\dfrac{1}{\\left(\\dfrac{\\Delta x_1}{2}\\dfrac{1}{k_1} + R_c + \\dfrac{\\Delta x_2}{2}\\dfrac{1}{k_2}\\right)}.$$ Assemble a tridiagonal linear system for the nodal temperatures $T_i$ such that the sum of incoming and outgoing conductive fluxes balances to zero at each interior node, with known boundary temperatures entering via source terms.\n\nAnalytical solution for validation:\n- Let the total thickness be $L = L_1 + L_2$, the left boundary temperature be $T_0$ at $x = 0$, and the right boundary temperature be $T_L$ at $x = L$.\n- The constant heat flux is $$q = \\dfrac{T_0 - T_L}{\\left(\\dfrac{L_1}{k_1} + R_c + \\dfrac{L_2}{k_2}\\right)}.$$\n- The exact temperature distribution is piecewise linear:\n  - For $0 \\le x \\le L_1$: $$T(x) = T_0 - \\dfrac{q}{k_1}\\,x.$$\n  - For $L_1 \\le x \\le L$: $$T(x) = T_L + \\dfrac{q}{k_2}\\,(L - x).$$\n- The nodal positions are $x_i = \\left(i + \\dfrac{1}{2}\\right)\\Delta x_1$ for $i = 0,1,\\dots,N_1-1$ in layer $1$, and $x_i = L_1 + \\left(j + \\dfrac{1}{2}\\right)\\Delta x_2$ for $j = 0,1,\\dots,N_2-1$ in layer $2$.\n\nValidation metric:\n- For each test case, compute the maximum absolute pointwise error between the discrete nodal temperatures and the analytical temperature evaluated at the same nodal positions. Express the error in kelvin (K), rounded to $6$ decimal places.\n\nTest suite:\nProvide results for the following parameter sets, with all quantities in coherent units:\n- Test case $1$ (general case): $L_1 = 0.04\\,\\mathrm{m}$, $L_2 = 0.06\\,\\mathrm{m}$, $k_1 = 16\\,\\mathrm{W/(m\\,K)}$, $k_2 = 45\\,\\mathrm{W/(m\\,K)}$, $R_c = 5\\times 10^{-4}\\,\\mathrm{m^2\\,K/W}$, $T_0 = 400\\,\\mathrm{K}$, $T_L = 300\\,\\mathrm{K}$, $N_1 = 40$, $N_2 = 60$.\n- Test case $2$ (large contact resistance): $L_1 = 0.02\\,\\mathrm{m}$, $L_2 = 0.02\\,\\mathrm{m}$, $k_1 = 200\\,\\mathrm{W/(m\\,K)}$, $k_2 = 200\\,\\mathrm{W/(m\\,K)}$, $R_c = 5\\times 10^{-2}\\,\\mathrm{m^2\\,K/W}$, $T_0 = 350\\,\\mathrm{K}$, $T_L = 300\\,\\mathrm{K}$, $N_1 = 20$, $N_2 = 20$.\n- Test case $3$ (zero contact resistance): $L_1 = 0.03\\,\\mathrm{m}$, $L_2 = 0.07\\,\\mathrm{m}$, $k_1 = 5\\,\\mathrm{W/(m\\,K)}$, $k_2 = 150\\,\\mathrm{W/(m\\,K)}$, $R_c = 0\\,\\mathrm{m^2\\,K/W}$, $T_0 = 500\\,\\mathrm{K}$, $T_L = 300\\,\\mathrm{K}$, $N_1 = 30$, $N_2 = 70$.\n- Test case $4$ (high grid nonuniformity across layers): $L_1 = 0.1\\,\\mathrm{m}$, $L_2 = 0.9\\,\\mathrm{m}$, $k_1 = 40\\,\\mathrm{W/(m\\,K)}$, $k_2 = 40\\,\\mathrm{W/(m\\,K)}$, $R_c = 10^{-6}\\,\\mathrm{m^2\\,K/W}$, $T_0 = 310\\,\\mathrm{K}$, $T_L = 290\\,\\mathrm{K}$, $N_1 = 3$, $N_2 = 97$.\n- Test case $5$ (very thin first layer): $L_1 = 10^{-3}\\,\\mathrm{m}$, $L_2 = 9.9\\times 10^{-2}\\,\\mathrm{m}$, $k_1 = 10\\,\\mathrm{W/(m\\,K)}$, $k_2 = 10\\,\\mathrm{W/(m\\,K)}$, $R_c = 10^{-3}\\,\\mathrm{m^2\\,K/W}$, $T_0 = 1000\\,\\mathrm{K}$, $T_L = 900\\,\\mathrm{K}$, $N_1 = 1$, $N_2 = 99$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each entry being the maximum absolute error for the corresponding test case in kelvin (K), rounded to $6$ decimal places (for example, $\\left[\\text{result}_1,\\text{result}_2,\\dots\\right]$). No additional text should be printed.",
            "solution": "The problem statement is assessed to be valid. It is scientifically grounded, well-posed, and objective. It presents a standard problem in computational heat transfer—the one-dimensional steady-state conduction through a composite slab with contact resistance. The provided governing equations, discretization scheme, and analytical solution are all correct and consistent with established principles of thermal engineering and numerical methods. The test cases are well-defined and provide all necessary data for a unique solution.\n\nThe solution proceeds by first constructing the numerical model based on the specified finite difference method (FDM), then implementing the provided analytical solution, and finally computing the maximum absolute error between the two for each test case.\n\n**1. Finite Difference Method (FDM) Formulation**\n\nThe physical domain, consisting of two layers of total thickness $L=L_1+L_2$, is discretized into $N = N_1 + N_2$ contiguous control volumes (CVs). The nodal temperature $T_i$ is defined at the center of each CV $i$. The fundamental principle applied to each CV is the conservation of energy, which for steady-state conduction without heat generation simplifies to the statement that the sum of heat transfer rates across the faces of the CV is zero.\n\nThe heat flow rate, $Q$, across a face between two nodes $i$ and $j$ is modeled using a thermal conductance, $G$, as $Q = G(T_i - T_j)$, where the area is assumed to be unity. This is an analogue to Ohm's law, with temperature difference as potential and heat flow as current. The total system of equations for the unknown nodal temperatures, $T_i$ for $i=0, \\dots, N-1$, forms a linear system $\\mathbf{A}\\mathbf{T} = \\mathbf{b}$, where $\\mathbf{T}$ is the vector of nodal temperatures. The specific form of the equation for each node $i$ is:\n\n$$ G_{\\text{left}}(T_{\\text{left}} - T_i) + G_{\\text{right}}(T_{\\text{right}} - T_i) = 0 $$\n\nwhere $T_{\\text{left}}$ and $T_{\\text{right}}$ are the temperatures of the adjacent nodes (or boundaries), and $G_{\\text{left}}$ and $G_{\\text{right}}$ are the conductances to the left and right faces of the CV. This can be rearranged into the form for a row of the matrix system: $G_{\\text{left}}T_{\\text{left}} - (G_{\\text{left}} + G_{\\text{right}})T_i + G_{\\text{right}}T_{\\text{right}} = 0$.\n\nThe conductances are defined based on the thermal resistances as $G = 1/R_{th}$. The problem specifies the conductances for different face types:\n\n- **Interior Face (within layer 1 or 2):** For a face between two nodes in a homogeneous material with conductivity $k$ and grid spacing $\\Delta x$, the resistance is the sum of two half-cell resistances: $R_{th} = \\frac{\\Delta x/2}{k} + \\frac{\\Delta x/2}{k} = \\frac{\\Delta x}{k}$. The conductance is $G = \\frac{k}{\\Delta x}$.\n\n- **Boundary Face (at $x=0$ or $x=L$):** For a face at a Dirichlet boundary with temperature $T_{\\mathrm{b}}$, the resistance is that of a single half-cell: $R_{th} = \\frac{\\Delta x/2}{k}$. The conductance is $G_{\\mathrm{b}} = \\frac{2k}{\\Delta x}$. The known boundary temperature is incorporated into the source vector $\\mathbf{b}$. For node $0$, the term $G_{\\mathrm{b}}T_0$ is moved to the right-hand side. For the last node, $N-1$, the term $G_{\\mathrm{b}}T_L$ is moved to the right-hand side.\n\n- **Interface Face (between layer 1 and 2):** At the interface between node $N_1-1$ (layer 1) and node $N_1$ (layer 2), the total thermal resistance is the sum of three resistances in series: the half-cell in layer 1, the contact resistance $R_c$, and the half-cell in layer 2. The interface conductance is therefore:\n$$ G_{\\mathrm{int}} = \\frac{1}{\\frac{\\Delta x_1/2}{k_1} + R_c + \\frac{\\Delta x_2/2}{k_2}} $$\n\nAssembling these equations for all $N$ nodes results in a symmetric, positive-definite, tridiagonal matrix $\\mathbf{A}$, which is efficiently solved to find the numerical temperature vector $\\mathbf{T}_{\\text{numerical}}$. We use a specialized banded matrix solver for this purpose.\n\n**2. Analytical Solution**\n\nThe problem provides the exact analytical solution for validation. First, the constant heat flux $q$ through the slab is calculated by dividing the total temperature drop by the total thermal resistance:\n$$ q = \\frac{T_0 - T_L}{R_{\\text{total}}} = \\frac{T_0 - T_L}{\\left(\\frac{L_1}{k_1} + R_c + \\frac{L_2}{k_2}\\right)} $$\nThe temperature distribution $T(x)$ is piecewise linear. For each nodal position $x_i$, the analytical temperature is calculated as:\n- For a node in layer 1 ($0 \\le x_i \\le L_1$):\n  $$ T(x_i) = T_0 - \\frac{q}{k_1}x_i $$\n- For a node in layer 2 ($L_1  x_i \\le L_1+L_2$):\n  $$ T(x_i) = T_L + \\frac{q}{k_2}(L_1+L_2 - x_i) $$\nThe nodal positions $x_i$ for the cell-centered grid are:\n- For $i=0, \\dots, N_1-1$: $x_i = (i + 1/2)\\Delta x_1$, where $\\Delta x_1 = L_1/N_1$.\n- For $i=N_1, \\dots, N-1$ (letting $j=i-N_1$): $x_i = L_1 + (j + 1/2)\\Delta x_2$, where $\\Delta x_2 = L_2/N_2$.\nThis yields the analytical temperature vector $\\mathbf{T}_{\\text{analytical}}$.\n\n**3. Validation Metric**\n\nThe validation is performed by computing the maximum absolute pointwise error between the numerical and analytical solutions:\n$$ \\text{Error} = \\max_i |T_{\\text{numerical},i} - T_{\\text{analytical},i}| $$\nA crucial insight is that the specified FDM scheme, based on a centered difference approximation, is exact for problems where the solution is a polynomial of degree one (a linear function). Since the temperature profile in each layer is linear, the discretization error for interior nodes is zero. The specific treatment of the boundary and interface conditions using the thermal resistance analogy also preserves this exactness. Therefore, the computed error is expected to be non-zero only due to floating-point representation limits, i.e., on the order of machine precision. The final result is rounded to $6$ decimal places as requested.\n\nThe following code implements this complete procedure for each test case provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Solves the 1D steady conduction problem for a two-layer slab\n    with contact resistance using FDM and validates against the\n    analytical solution for a series of test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (general case)\n        {'L1': 0.04, 'L2': 0.06, 'k1': 16.0, 'k2': 45.0, 'Rc': 5e-4, \n         'T0': 400.0, 'TL': 300.0, 'N1': 40, 'N2': 60},\n        # Test case 2 (large contact resistance)\n        {'L1': 0.02, 'L2': 0.02, 'k1': 200.0, 'k2': 200.0, 'Rc': 5e-2, \n         'T0': 350.0, 'TL': 300.0, 'N1': 20, 'N2': 20},\n        # Test case 3 (zero contact resistance)\n        {'L1': 0.03, 'L2': 0.07, 'k1': 5.0, 'k2': 150.0, 'Rc': 0.0, \n         'T0': 500.0, 'TL': 300.0, 'N1': 30, 'N2': 70},\n        # Test case 4 (high grid nonuniformity)\n        {'L1': 0.1, 'L2': 0.9, 'k1': 40.0, 'k2': 40.0, 'Rc': 1e-6, \n         'T0': 310.0, 'TL': 290.0, 'N1': 3, 'N2': 97},\n        # Test case 5 (very thin first layer)\n        {'L1': 1e-3, 'L2': 9.9e-2, 'k1': 10.0, 'k2': 10.0, 'Rc': 1e-3, \n         'T0': 1000.0, 'TL': 900.0, 'N1': 1, 'N2': 99},\n    ]\n\n    results = []\n    for case in test_cases:\n        error = calculate_max_error(**case)\n        results.append(f\"{error:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_max_error(L1, L2, k1, k2, Rc, T0, TL, N1, N2):\n    \"\"\"\n    Calculates the maximum absolute error between the FDM and analytical solutions.\n    \"\"\"\n    N = N1 + N2\n    dx1 = L1 / N1 if N1 > 0 else 0.0\n    dx2 = L2 / N2 if N2 > 0 else 0.0\n    \n    # --- 1. FDM Numerical Solution ---\n    # Assemble the tridiagonal system A*T = b.\n    # The matrix A is stored in the `ab` banded format for scipy.linalg.solve_banded.\n    # ab has 3 rows: super-diagonal (shifted), main-diagonal, sub-diagonal (shifted).\n    ab = np.zeros((3, N))\n    b = np.zeros(N)\n\n    # Pre-calculate interface conductance if both layers exist\n    G_int = 0.0\n    if N1 > 0 and N2 > 0:\n        R_int_thermal = (dx1 / 2.0 / k1) + Rc + (dx2 / 2.0 / k2)\n        G_int = 1.0 / R_int_thermal\n\n    # Build matrix row by row\n    for i in range(N):\n        # Determine properties of the current control volume (CV)\n        is_in_layer1 = (i  N1)\n        k_node = k1 if is_in_layer1 else k2\n        dx_node = dx1 if is_in_layer1 else dx2\n\n        # Left face of CV i\n        if i == 0:  # Left boundary face\n            G_left = 2.0 * k_node / dx_node\n            b[i] -= G_left * T0\n        elif i == N1: # Interface face (from layer 2 side)\n            G_left = G_int\n            ab[2, i-1] = G_left\n        else: # Interior face\n            G_left = k_node / dx_node\n            ab[2, i-1] = G_left\n\n        # Right face of CV i\n        if i == N - 1: # Right boundary face\n            G_right = 2.0 * k_node / dx_node\n            b[i] -= G_right * TL\n        elif i == N1 - 1: # Interface face (from layer 1 side)\n            G_right = G_int\n            ab[0, i+1] = G_right\n        else: # Interior face\n            G_right = k_node / dx_node\n            ab[0, i+1] = G_right\n        \n        # Main diagonal term\n        ab[1, i] = -(G_left + G_right)\n\n    # Solve the linear system for nodal temperatures\n    T_numerical = solve_banded((1, 1), ab, b)\n\n    # --- 2. Analytical Solution ---\n    L_total = L1 + L2\n    R_total = (L1 / k1 if k1 > 0 else 0) + Rc + (L2 / k2 if k2 > 0 else 0)\n    q = (T0 - TL) / R_total if R_total > 0 else 0.0\n\n    # Calculate nodal positions\n    x_nodes = np.zeros(N)\n    if N1 > 0:\n        x_nodes[:N1] = (np.arange(N1) + 0.5) * dx1\n    if N2 > 0:\n        x_nodes[N1:] = L1 + (np.arange(N2) + 0.5) * dx2\n\n    # Calculate analytical temperatures at nodal positions\n    T_analytical = np.zeros(N)\n    mask_layer1 = x_nodes = L1\n    mask_layer2 = ~mask_layer1\n\n    T_analytical[mask_layer1] = T0 - (q / k1) * x_nodes[mask_layer1]\n    T_analytical[mask_layer2] = TL + (q / k2) * (L_total - x_nodes[mask_layer2])\n\n    # --- 3. Validation ---\n    max_abs_error = np.max(np.abs(T_numerical - T_analytical))\n    \n    return max_abs_error\n\nsolve()\n```"
        }
    ]
}