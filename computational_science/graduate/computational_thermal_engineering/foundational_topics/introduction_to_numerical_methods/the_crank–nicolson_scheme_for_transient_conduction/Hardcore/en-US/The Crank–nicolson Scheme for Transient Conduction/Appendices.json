{
    "hands_on_practices": [
        {
            "introduction": "This first practice delves into the core of numerical stability by having you perform a von Neumann analysis numerically. You will derive the analytical amplification factor, $G(q)$, for the Crank-Nicolson scheme and then verify it by simulating the evolution of a single Fourier mode, connecting abstract theory to concrete computational results. This exercise is invaluable for developing a deep intuition for how the scheme handles different spatial frequencies and why it is unconditionally stable .",
            "id": "3990185",
            "problem": "Consider one-dimensional transient heat conduction governed by the energy conservation law coupled with Fourier’s law of heat conduction. In a homogeneous medium with constant thermal diffusivity $\\alpha$, the temperature field $u(x,t)$ on a periodic domain evolves according to the parabolic partial differential equation $\\partial u/\\partial t \\,=\\, \\alpha\\, \\partial^2 u/\\partial x^2$. On a uniform grid of $N$ points over a domain of length $L$ with spatial step $h = L/N$, and time step $\\Delta t$, consider the Crank-Nicolson method (CN) applied to the standard second-order central-difference spatial discretization, and periodic boundary conditions. The resulting update from time level $n$ to $n+1$ can be expressed as a linear system with a circulant left-hand side. The discrete Fourier modes $e^{\\mathrm{i} q j}$, where $j$ is the grid index and $q$ is the discrete wavenumber in radians per index, are eigenfunctions of the discrete Laplacian under periodic boundary conditions.\n\nYour tasks are:\n- Starting from conservation of energy and Fourier’s law, derive the one-dimensional heat equation $\\partial u/\\partial t \\,=\\, \\alpha\\, \\partial^2 u/\\partial x^2$.\n- Construct the uniform-grid, second-order central-difference discrete Laplacian operator $L$ acting on a grid function $u_j$ as $L u_j \\,=\\, u_{j+1} \\, - \\, 2 u_j \\, + \\, u_{j-1}$ with periodic wrap-around indexing.\n- Derive the Crank-Nicolson (CN) semi-implicit time discretization for this semi-discrete system, writing the update in the form $(I \\, - \\, \\tfrac{\\alpha \\, \\Delta t}{2 h^2} \\, L) \\, u^{n+1} \\,=\\, (I \\, + \\, \\tfrac{\\alpha \\, \\Delta t}{2 h^2} \\, L) \\, u^n$, where $I$ is the identity operator, and $u^n$ is the vector of grid values at time level $n$.\n- For a single discrete Fourier mode $u_j^n \\,=\\, \\hat{u}^n \\, e^{\\mathrm{i} q j}$, use the eigenvalue of $L$ to obtain the analytical amplification factor $G(q)$ of one CN time step in terms of the dimensionless ratio $r \\,=\\, \\alpha\\, \\Delta t / h^2$ and the mode-dependent quantity you identify from the discrete Laplacian eigenvalue. Do not provide intermediate shortcut formulas; derive the amplification factor from first principles.\n\nDesign a numerical experiment that measures the mode-by-mode amplification by:\n- Initializing $u^0$ to a single complex Fourier mode with unit amplitude, $u_j^0 \\,=\\, e^{\\mathrm{i} q j}$, for a specified integer mode index $m$ with $q \\,=\\, 2 \\pi m / N$.\n- Assembling the circulant left-hand side matrix $(I \\, - \\, \\tfrac{r}{2} L)$ and the right-hand side vector $(I \\, + \\, \\tfrac{r}{2} L) \\, u^0$ and solving for $u^1$ using exact linear algebra.\n- Computing the measured amplification ratio $R_{\\mathrm{meas}} \\,=\\, \\hat{u}^1 / \\hat{u}^0$ for the chosen mode via the Discrete Fourier Transform (DFT).\n\nFor each test case below, compute the absolute error $E \\,=\\, \\lvert R_{\\mathrm{meas}} \\, - \\, G(q) \\rvert$ as a dimensionless float:\n- Case $1$: $N \\,=\\, 64$, $L \\,=\\, 2 \\pi$, $\\alpha \\,=\\, 1.0$, $\\Delta t \\,=\\, 10^{-4}$, $m \\,=\\, 0$.\n- Case $2$: $N \\,=\\, 64$, $L \\,=\\, 2 \\pi$, $\\alpha \\,=\\, 1.0$, $\\Delta t \\,=\\, 10^{-2}$, $m \\,=\\, 16$.\n- Case $3$: $N \\,=\\, 64$, $L \\,=\\, 2 \\pi$, $\\alpha \\,=\\, 1.0$, $\\Delta t \\,=\\, 1$, $m \\,=\\, 32$.\n- Case $4$: $N \\,=\\, 33$, $L \\,=\\, 2 \\pi$, $\\alpha \\,=\\, 0.5$, $\\Delta t \\,=\\, 0.2$, $m \\,=\\, 11$.\n- Case $5$: $N \\,=\\, 128$, $L \\,=\\, 2 \\pi$, $\\alpha \\,=\\, 1.0$, $\\Delta t \\,=\\, 0.05$, $m \\,=\\, 5$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[result1,result2,result3]$), where each entry is the absolute error $E$ for the corresponding test case in the order listed above. All numerical answers must be dimensionless floats, and there are no physical units required. The numerical experiment must validate the analytically derived amplification factor by demonstrating that the measured amplification ratio matches the analytical prediction within numerical precision and by covering low-frequency, mid-frequency, and highest-frequency discrete modes, as well as small and large values of $r$ to probe properties of Crank-Nicolson stability and damping characteristics.",
            "solution": "The problem is validated as scientifically grounded, well-posed, and complete. We proceed with the solution, which involves several theoretical derivations followed by a numerical implementation to verify the theoretical results.\n\n**Derivation of the One-Dimensional Heat Equation**\n\nWe begin from the principle of conservation of energy. For a one-dimensional medium, consider an arbitrary segment from position $x_1$ to $x_2$. The total thermal energy $E_{\\text{total}}$ within this segment is the integral of the volumetric energy density, $e(x,t)$, over the volume. Assuming a uniform cross-sectional area $A$, this is $E_{\\text{total}} = \\int_{x_1}^{x_2} e(x,t) A \\, dx$. The rate of change of this energy must equal the net rate at which heat flows into the segment. Let $\\phi(x,t)$ be the heat flux (energy per unit area per unit time). The rate of heat flow into the segment is $A \\phi(x_1, t) - A \\phi(x_2, t)$. Thus, the integral form of energy conservation is:\n$$\n\\frac{d}{dt} \\int_{x_1}^{x_2} e(x,t) A \\, dx = A \\phi(x_1, t) - A \\phi(x_2, t)\n$$\nDividing by $A$ and using the fundamental theorem of calculus on the right-hand side, we get:\n$$\n\\frac{d}{dt} \\int_{x_1}^{x_2} e(x,t) \\, dx = - \\int_{x_1}^{x_2} \\frac{\\partial \\phi}{\\partial x} \\, dx\n$$\nBringing the time derivative inside the integral on the left (Leibniz integral rule) yields:\n$$\n\\int_{x_1}^{x_2} \\frac{\\partial e}{\\partial t} \\, dx = - \\int_{x_1}^{x_2} \\frac{\\partial \\phi}{\\partial x} \\, dx\n$$\nSince this equality must hold for any arbitrary interval $[x_1, x_2]$, the integrands must be equal. This gives the differential form of energy conservation:\n$$\n\\frac{\\partial e}{\\partial t} = - \\frac{\\partial \\phi}{\\partial x}\n$$\nThe thermal energy density $e$ is related to the temperature $u(x,t)$ by $e(x,t) = \\rho c_p u(x,t)$, where $\\rho$ is the mass density and $c_p$ is the specific heat capacity, both assumed constant. Fourier's law of heat conduction states that the heat flux is proportional to the negative temperature gradient: $\\phi(x,t) = -k \\frac{\\partial u}{\\partial x}$, where $k$ is the thermal conductivity, also assumed constant.\n\nSubstituting these two constitutive relations into the energy conservation equation:\n$$\n\\frac{\\partial}{\\partial t} (\\rho c_p u) = - \\frac{\\partial}{\\partial x} \\left(-k \\frac{\\partial u}{\\partial x}\\right)\n$$\n$$\n\\rho c_p \\frac{\\partial u}{\\partial t} = k \\frac{\\partial^2 u}{\\partial x^2}\n$$\nRearranging the terms, we obtain the one-dimensional heat equation:\n$$\n\\frac{\\partial u}{\\partial t} = \\frac{k}{\\rho c_p} \\frac{\\partial^2 u}{\\partial x^2}\n$$\nWe define the thermal diffusivity as $\\alpha = k / (\\rho c_p)$, which consolidates the material properties into a single constant. The final governing equation is:\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}\n$$\n\n**Discretization of the Spatial Operator**\n\nThe heat equation is discretized on a uniform grid of $N$ points $x_j = j h$ for $j = 0, 1, \\dots, N-1$, where $h=L/N$ is the spatial step size. The temperature at grid point $j$ and time $t$ is denoted $u_j(t)$. The second spatial derivative, $\\partial^2 u/\\partial x^2$, is approximated at grid point $x_j$ using a second-order central difference scheme. This is derived from the Taylor series expansions of $u(x)$ around $x_j$:\n$$\nu(x_j+h) = u(x_j) + h \\frac{\\partial u}{\\partial x}\\bigg|_{x_j} + \\frac{h^2}{2} \\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{x_j} + \\frac{h^3}{6} \\frac{\\partial^3 u}{\\partial x^3}\\bigg|_{x_j} + O(h^4)\n$$\n$$\nu(x_j-h) = u(x_j) - h \\frac{\\partial u}{\\partial x}\\bigg|_{x_j} + \\frac{h^2}{2} \\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{x_j} - \\frac{h^3}{6} \\frac{\\partial^3 u}{\\partial x^3}\\bigg|_{x_j} + O(h^4)\n$$\nAdding these two expansions cancels the odd-order derivative terms:\n$$\nu(x_j+h) + u(x_j-h) = 2 u(x_j) + h^2 \\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{x_j} + O(h^4)\n$$\nSolving for the second derivative, we get the approximation:\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{x_j} \\approx \\frac{u(x_j+h) - 2u(x_j) + u(x_j-h)}{h^2} = \\frac{u_{j+1} - 2u_j + u_{j-1}}{h^2}\n$$\nThe problem statement defines a discrete operator $L$ acting on the grid function $u_j$ as $L u_j = u_{j+1} - 2u_j + u_{j-1}$. This is a non-scaled representation of the discrete Laplacian. Periodic boundary conditions imply that indices are evaluated modulo $N$, so $u_{N} = u_0$ and $u_{-1} = u_{N-1}$. The semi-discrete form of the heat equation is thus:\n$$\n\\frac{d u_j}{d t} = \\frac{\\alpha}{h^2} (L u)_j\n$$\n\n**Derivation of the Crank-Nicolson Scheme**\n\nThe Crank-Nicolson method is an implicit time-stepping scheme that is second-order accurate in time. It is derived by discretizing the time derivative using the central difference formula around the time level $n+1/2$:\n$$\n\\frac{u^{n+1}_j - u^{n}_j}{\\Delta t} \\approx \\frac{d u_j}{d t}\\bigg|_{t_{n+1/2}}\n$$\nwhere $u^n_j$ is the temperature at grid point $j$ and time step $n$. The spatial derivative term on the right-hand side of the semi-discrete equation is also approximated at time level $n+1/2$ by averaging its values at time levels $n$ and $n+1$:\n$$\n\\frac{\\alpha}{h^2} (L u)_j \\bigg|_{t_{n+1/2}} \\approx \\frac{1}{2} \\left[ \\left(\\frac{\\alpha}{h^2} L u\\right)^{n}_j + \\left(\\frac{\\alpha}{h^2} L u\\right)^{n+1}_j \\right]\n$$\nEquating the two approximations gives the fully discrete scheme:\n$$\n\\frac{u^{n+1}_j - u^{n}_j}{\\Delta t} = \\frac{\\alpha}{2h^2} \\left[ (L u^n)_j + (L u^{n+1})_j \\right]\n$$\nMultiplying by $\\Delta t$ and rearranging terms to separate the known values at time $n$ from the unknown values at time $n+1$:\n$$\nu^{n+1}_j - \\frac{\\alpha \\Delta t}{2h^2} (L u^{n+1})_j = u^{n}_j + \\frac{\\alpha \\Delta t}{2h^2} (L u^n)_j\n$$\nLet's define the dimensionless parameter $r = \\alpha \\Delta t / h^2$. The scheme for the entire vector of grid values $u^n$ can be written in operator form:\n$$\nu^{n+1} - \\frac{r}{2} L u^{n+1} = u^{n} + \\frac{r}{2} L u^{n}\n$$\nFactoring out $u^{n+1}$ and $u^n$ and using the identity operator $I$:\n$$\n\\left(I - \\frac{r}{2}L\\right) u^{n+1} = \\left(I + \\frac{r}{2}L\\right) u^{n}\n$$\nThis is the final form of the Crank-Nicolson update rule, which requires solving a linear system at each time step.\n\n**Derivation of the Analytical Amplification Factor**\n\nTo analyze the stability and accuracy of the scheme, we perform a von Neumann stability analysis. We examine how a single discrete Fourier mode, $u_j^n = \\hat{u}^n e^{\\mathrm{i}qj}$, is amplified over one time step. Here, $\\hat{u}^n$ is the complex amplitude of the mode at time step $n$, $j$ is the grid index, and $q$ is the discrete wavenumber.\n\nFirst, we find the eigenvalue of the discrete Laplacian operator $L$ when acting on this Fourier mode:\n$$\n(L u^n)_j = u_{j+1}^n - 2u_j^n + u_{j-1}^n = \\hat{u}^n e^{\\mathrm{i}q(j+1)} - 2\\hat{u}^n e^{\\mathrm{i}qj} + \\hat{u}^n e^{\\mathrm{i}q(j-1)}\n$$\nFactoring out $\\hat{u}^n e^{\\mathrm{i}qj}$:\n$$\n(L u^n)_j = \\hat{u}^n e^{\\mathrm{i}qj} (e^{\\mathrm{i}q} - 2 + e^{-\\mathrm{i}q})\n$$\nUsing Euler's formula, $e^{\\mathrm{i}q} + e^{-\\mathrm{i}q} = 2\\cos(q)$. Thus, the expression in the parenthesis becomes $2\\cos(q) - 2$.\nSo, $L$ acts as a scalar multiplication on the Fourier mode:\n$$\n(L u^n)_j = (2\\cos(q) - 2) u_j^n\n$$\nThe eigenvalue of the operator $L$ for the mode with wavenumber $q$ is $\\lambda_L(q) = 2(\\cos(q) - 1)$.\n\nNow, we substitute the Fourier mode ansatz into the Crank-Nicolson scheme:\n$$\n\\left(I - \\frac{r}{2}L\\right) u^{n+1} = \\left(I + \\frac{r}{2}L\\right) u^{n}\n$$\nSince Fourier modes are eigenfunctions of $L$, they are also eigenfunctions of any operator polynomial in $L$, such as $(I - \\frac{r}{2}L)$ and $(I + \\frac{r}{2}L)$. Applying these operators to the mode yields:\n$$\n\\left(1 - \\frac{r}{2}\\lambda_L(q)\\right) u^{n+1}_j = \\left(1 + \\frac{r}{2}\\lambda_L(q)\\right) u^{n}_j\n$$\nSubstituting $u_j^n = \\hat{u}^n e^{\\mathrm{i}qj}$ and $u_j^{n+1} = \\hat{u}^{n+1} e^{\\mathrm{i}qj}$:\n$$\n\\left(1 - \\frac{r}{2}\\lambda_L(q)\\right) \\hat{u}^{n+1} e^{\\mathrm{i}qj} = \\left(1 + \\frac{r}{2}\\lambda_L(q)\\right) \\hat{u}^{n} e^{\\mathrm{i}qj}\n$$\nThe amplification factor is defined as $G(q) = \\hat{u}^{n+1} / \\hat{u}^{n}$. Dividing through, we get:\n$$\nG(q) = \\frac{1 + \\frac{r}{2}\\lambda_L(q)}{1 - \\frac{r}{2}\\lambda_L(q)}\n$$\nSubstituting the expression for the mode-dependent eigenvalue $\\lambda_L(q) = 2(\\cos(q) - 1)$:\n$$\nG(q) = \\frac{1 + \\frac{r}{2}(2(\\cos(q) - 1))}{1 - \\frac{r}{2}(2(\\cos(q) - 1))} = \\frac{1 + r(\\cos(q) - 1)}{1 - r(\\cos(q) - 1)}\n$$\n\n**Numerical Experiment Design**\nThe numerical experiment validates this analytical result. For each test case, we perform the following steps:\n$1$. We initialize the grid function $u^0$ to a single complex Fourier mode $u_j^0 = e^{\\mathrm{i} q j}$ with unit amplitude, where $q = 2\\pi m / N$ for a given integer mode index $m$.\n$2$. We construct the matrix representation of the Crank-Nicolson operators. The operator $L$ is a circulant matrix. The matrices for the linear system $A u^1 = b$ are $A = I - \\frac{r}{2} L$ and $b = (I + \\frac{r}{2} L) u^0$.\n$3$. We solve the linear system $A u^1 = b$ for the state vector $u^1$ at the next time step using a standard linear solver.\n$4$. We calculate the measured amplification ratio, $R_{\\mathrm{meas}}$. Since the initial state is a pure Fourier mode, the state after one linear time step, $u^1$, should be the same mode multiplied by the amplification factor, apart from numerical floating-point errors. The amplitude of a mode $m$ in a signal $v$ can be extracted using the Discrete Fourier Transform (DFT), as $\\hat{v}[m] = \\text{DFT}(v)[m] / N$. The amplification is the ratio of amplitudes: $R_{\\mathrm{meas}} = \\hat{u}^1[m] / \\hat{u}^0[m]$. Since $\\hat{u}^0[m] = 1$, this simplifies to $R_{\\mathrm{meas}} = \\text{DFT}(u^1)[m] / N$.\n$5$. Finally, we compute the absolute error between the measured and analytical amplification factors: $E = |R_{\\mathrm{meas}} - G(q)|$. This error is expected to be close to machine precision, confirming the correctness of the analytical derivation and the numerical implementation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import circulant\n\ndef solve():\n    \"\"\"\n    Solves the problem by running a numerical experiment for each test case\n    to validate the analytical amplification factor of the Crank-Nicolson scheme.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, L, alpha, dt, m)\n        (64, 2 * np.pi, 1.0, 1e-4, 0),\n        (64, 2 * np.pi, 1.0, 1e-2, 16),\n        (64, 2 * np.pi, 1.0, 1.0, 32),\n        (33, 2 * np.pi, 0.5, 0.2, 11),\n        (128, 2 * np.pi, 1.0, 0.05, 5),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, L, alpha, dt, m = case\n\n        # Calculate derived parameters\n        h = L / N\n        r = alpha * dt / (h * h)\n        q = 2 * np.pi * m / N\n\n        # --- Analytical Amplification Factor G(q) ---\n        # G(q) = (1 + r * (cos(q) - 1)) / (1 - r * (cos(q) - 1))\n        cos_q = np.cos(q)\n        g_analytical = (1 + r * (cos_q - 1)) / (1 - r * (cos_q - 1))\n\n        # --- Numerical Experiment ---\n        \n        # 1. Initialize to a single complex Fourier mode with unit amplitude\n        j_indices = np.arange(N)\n        u0 = np.exp(1j * q * j_indices)\n\n        # 2. Assemble the circulant matrices for the CN scheme\n        # The discrete Laplacian L is a circulant matrix. We construct its first row.\n        # L u_j = u_{j+1} - 2*u_j + u_{j-1}\n        # First row of L matrix is [-2, 1, 0, ..., 0, 1]\n        l_first_row = np.zeros(N)\n        l_first_row[0] = -2.0\n        l_first_row[1] = 1.0\n        l_first_row[N - 1] = 1.0  # Periodic boundary condition\n        \n        L_matrix = circulant(l_first_row)\n        \n        # Identity matrix\n        I_matrix = np.identity(N)\n\n        # LHS matrix A = I - (r/2) * L\n        A_matrix = I_matrix - (r / 2.0) * L_matrix\n        \n        # RHS operator matrix B_op = I + (r/2) * L\n        B_op_matrix = I_matrix + (r / 2.0) * L_matrix\n\n        # Calculate RHS vector b = B_op * u^0\n        b_vector = B_op_matrix @ u0\n\n        # 3. Solve the linear system A * u^1 = b for u^1\n        u1 = np.linalg.solve(A_matrix, b_vector)\n\n        # 4. Compute the measured amplification ratio R_meas via DFT\n        # The amplitude of mode m in u1 is DFT(u1)[m] / N.\n        # Initial amplitude is 1. So, R_meas = (DFT(u1)[m] / N) / 1.\n        dft_u1 = np.fft.fft(u1)\n        r_measured = dft_u1[m] / N\n\n        # 5. Compute the absolute error E\n        error = np.abs(r_measured - g_analytical)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "After exploring the scheme's stability, the next crucial step is to verify its accuracy for a complete solution. This practice guides you through implementing the Crank-Nicolson scheme for a classic transient conduction problem and performing a systematic convergence study against a known analytical solution. By observing the error decrease as you refine the mesh and time step, you will empirically confirm the scheme's second-order accuracy in both space and time, a fundamental skill in computational code verification .",
            "id": "3990207",
            "problem": "Consider one-dimensional transient heat conduction in a homogeneous slab governed by the heat equation. The fundamental base is the conservation of energy and Fourier’s law of heat conduction, which together imply the heat equation $ \\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2} $ for $ x \\in (0, L) $ and $ t  0 $, where $ T(x,t) $ is the temperature field, $ \\alpha $ is the thermal diffusivity, and $ L $ is the slab length. The slab is subject to homogeneous Dirichlet boundary conditions $ T(0,t) = 0 $ and $ T(L,t) = 0 $ for all $ t \\ge 0 $. The initial temperature field is $ T(x,0) = \\sin\\left(\\frac{\\pi x}{L}\\right) + \\frac{1}{2}\\sin\\left(\\frac{3\\pi x}{L}\\right) $.\n\nBy separation of variables, the exact solution for the Dirichlet slab can be written in the Fourier sine series form $ T(x,t) = \\sum_{m=1}^{\\infty} A_m \\exp\\left(-\\alpha \\lambda_m^2 t\\right)\\sin\\left(\\lambda_m x\\right) $ with $ \\lambda_m = \\frac{m\\pi}{L} $ and coefficients $ A_m $ determined by the initial condition. For the specified initial condition, the only nonzero coefficients are $ A_1 = 1 $ and $ A_3 = \\frac{1}{2} $, and the exact solution reduces to $ T_{\\mathrm{exact}}(x,t) = \\exp\\left(-\\alpha \\left(\\frac{\\pi}{L}\\right)^2 t\\right)\\sin\\left(\\frac{\\pi x}{L}\\right) + \\frac{1}{2}\\exp\\left(-\\alpha \\left(\\frac{3\\pi}{L}\\right)^2 t\\right)\\sin\\left(\\frac{3\\pi x}{L}\\right) $.\n\nYour task is to derive and implement the Crank-Nicolson (CN) scheme for this problem on a uniform spatial grid and constant time step, and use the exact solution to compute numerical errors as functions of the spatial step $ \\Delta x $ and time step $ \\Delta t $. Specifically:\n\n- Derive the CN time-stepping scheme for the interior nodes in the domain $ x \\in (0, L) $ under the homogeneous Dirichlet boundary conditions, using standard second-order centered differences in space and the trapezoidal time integration for the diffusion term. Do not use any shortcut formulas; start from the heat equation and construct the discrete equations by applying appropriate finite difference approximations and time averaging.\n- Implement the CN scheme in a program that advances the solution from $ t = 0 $ to $ t = t_{\\mathrm{end}} $ using a uniform mesh with $ N_x $ nodes (including boundaries) and a constant time step $ \\Delta t $. Assume $ \\Delta t $ divides $ t_{\\mathrm{end}} $ exactly.\n- Compute the discrete root-mean-square error at $ t = t_{\\mathrm{end}} $ between the numerical solution and $ T_{\\mathrm{exact}}(x,t_{\\mathrm{end}}) $ evaluated at the same grid nodes, defined as $ E = \\sqrt{\\frac{1}{N_x}\\sum_{i=0}^{N_x-1}\\left(T_i^{n_{\\mathrm{end}}} - T_{\\mathrm{exact}}(x_i, t_{\\mathrm{end}})\\right)^2} $. Report the error $ E $ in kelvin ($ \\mathrm{K} $). Use $ x_i = i \\Delta x $ with $ \\Delta x = \\frac{L}{N_x - 1} $ and $ n_{\\mathrm{end}} $ the final time index.\n\nPhysical units:\n- Report spatial quantities in meters ($ \\mathrm{m} $) and time in seconds ($ \\mathrm{s} $).\n- The thermal diffusivity $ \\alpha $ must be in $ \\mathrm{m}^2/\\mathrm{s} $.\n- Errors must be reported in kelvin ($ \\mathrm{K} $).\n\nImplement the program to run the following test suite that explores the error behavior with different $ \\Delta x $ and $ \\Delta t $:\n\n- Test $ 1 $ (baseline): $ L = 1.0 \\ \\mathrm{m} $, $ \\alpha = 1.0 \\times 10^{-4} \\ \\mathrm{m}^2/\\mathrm{s} $, $ t_{\\mathrm{end}} = 10.0 \\ \\mathrm{s} $, $ N_x = 51 $, $ \\Delta t = 0.10 \\ \\mathrm{s} $.\n- Test $ 2 $ (refined time step): $ L = 1.0 \\ \\mathrm{m} $, $ \\alpha = 1.0 \\times 10^{-4} \\ \\mathrm{m}^2/\\mathrm{s} $, $ t_{\\mathrm{end}} = 10.0 \\ \\mathrm{s} $, $ N_x = 51 $, $ \\Delta t = 0.025 \\ \\mathrm{s} $.\n- Test $ 3 $ (refined spatial step): $ L = 1.0 \\ \\mathrm{m} $, $ \\alpha = 1.0 \\times 10^{-4} \\ \\mathrm{m}^2/\\mathrm{s} $, $ t_{\\mathrm{end}} = 10.0 \\ \\mathrm{s} $, $ N_x = 201 $, $ \\Delta t = 0.10 \\ \\mathrm{s} $.\n- Test $ 4 $ (coarse both): $ L = 1.0 \\ \\mathrm{m} $, $ \\alpha = 1.0 \\times 10^{-4} \\ \\mathrm{m}^2/\\mathrm{s} $, $ t_{\\mathrm{end}} = 10.0 \\ \\mathrm{s} $, $ N_x = 21 $, $ \\Delta t = 1.25 \\ \\mathrm{s} $.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $ [E_1,E_2,E_3,E_4] $), where each $ E_k $ is the root-mean-square error in $ \\mathrm{K} $ for test $ k $ at $ t = t_{\\mathrm{end}} $ evaluated on the corresponding grid.",
            "solution": "The user-provided problem is evaluated as valid based on the specified criteria. It is scientifically grounded in the principles of heat transfer and numerical analysis, well-posed with sufficient and consistent information, and objective in its formulation. The task is to derive and implement the Crank-Nicolson scheme for a one-dimensional transient heat conduction problem and to compute the numerical error against a provided exact solution.\n\n### Derivation of the Crank-Nicolson Scheme\n\nThe governing partial differential equation (PDE) for one-dimensional transient heat conduction is the heat equation:\n$$ \\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2} $$\nwhere $T(x,t)$ is the temperature, $\\alpha$ is the thermal diffusivity, $x$ is the spatial coordinate, and $t$ is time. The domain is $x \\in (0, L)$ and $t  0$.\n\nThe problem is discretized on a uniform grid. Let the spatial domain be divided into $N_x-1$ intervals of width $\\Delta x = \\frac{L}{N_x - 1}$, with grid points $x_i = i \\Delta x$ for $i = 0, 1, \\dots, N_x-1$. Time is discretized in steps of $\\Delta t$, with $t_n = n \\Delta t$. The temperature at grid point $i$ and time step $n$ is denoted by $T_i^n \\approx T(x_i, t_n)$.\n\nThe Crank-Nicolson method approximates the time derivative using a forward difference centered at $t_{n+1/2}$ and approximates the spatial derivative term by averaging its value at the current time step ($n$) and the next time step ($n+1$). This is equivalent to applying the trapezoidal rule for the time integration of the spatial term.\n\nThe time derivative is approximated as:\n$$ \\frac{\\partial T}{\\partial t} \\bigg|_{i}^{n+1/2} \\approx \\frac{T_i^{n+1} - T_i^n}{\\Delta t} $$\nThe PDE evaluated at the midpoint in time $t_{n+1/2}$ is:\n$$ \\frac{\\partial T}{\\partial t} \\bigg|_{i}^{n+1/2} = \\alpha \\frac{\\partial^2 T}{\\partial x^2} \\bigg|_{i}^{n+1/2} $$\nThe Crank-Nicolson scheme approximates the right-hand side by averaging:\n$$ \\frac{\\partial^2 T}{\\partial x^2} \\bigg|_{i}^{n+1/2} \\approx \\frac{1}{2} \\left( \\frac{\\partial^2 T}{\\partial x^2} \\bigg|_{i}^{n+1} + \\frac{\\partial^2 T}{\\partial x^2} \\bigg|_{i}^{n} \\right) $$\nCombining these gives the semi-discretized equation:\n$$ \\frac{T_i^{n+1} - T_i^n}{\\Delta t} = \\frac{\\alpha}{2} \\left[ \\left(\\frac{\\partial^2 T}{\\partial x^2}\\right)_i^{n+1} + \\left(\\frac{\\partial^2 T}{\\partial x^2}\\right)_i^n \\right] $$\nNext, the second-order spatial derivative is approximated using a standard second-order central difference stencil:\n$$ \\frac{\\partial^2 T}{\\partial x^2} \\bigg|_{i} \\approx \\frac{T_{i-1} - 2T_i + T_{i+1}}{(\\Delta x)^2} $$\nSubstituting this spatial discretization into the time-stepping equation yields the fully discrete form:\n$$ \\frac{T_i^{n+1} - T_i^n}{\\Delta t} = \\frac{\\alpha}{2} \\left( \\frac{T_{i-1}^{n+1} - 2T_i^{n+1} + T_{i+1}^{n+1}}{(\\Delta x)^2} + \\frac{T_{i-1}^{n} - 2T_i^{n} + T_{i+1}^{n}}{(\\Delta x)^2} \\right) $$\nTo simplify this expression, we introduce the non-dimensional diffusion number (or mesh Fourier number), $r$:\n$$ r = \\frac{\\alpha \\Delta t}{(\\Delta x)^2} $$\nMultiplying the entire equation by $\\Delta t$ and substituting $r$:\n$$ T_i^{n+1} - T_i^n = \\frac{r}{2} \\left( (T_{i-1}^{n+1} - 2T_i^{n+1} + T_{i+1}^{n+1}) + (T_{i-1}^{n} - 2T_i^{n} + T_{i+1}^{n}) \\right) $$\nThe next step is to rearrange the equation by grouping all terms at the new time step $n+1$ (the unknowns) on the left-hand side (LHS) and all terms at the current time step $n$ (the knowns) on the right-hand side (RHS):\n$$ T_i^{n+1} - \\frac{r}{2}(T_{i-1}^{n+1} - 2T_i^{n+1} + T_{i+1}^{n+1}) = T_i^n + \\frac{r}{2}(T_{i-1}^{n} - 2T_i^{n} + T_{i+1}^{n}) $$\nSimplifying both sides leads to the final form of the finite difference equation for an interior node $i$:\n$$ -\\frac{r}{2}T_{i-1}^{n+1} + (1+r)T_i^{n+1} - \\frac{r}{2}T_{i+1}^{n+1} = \\frac{r}{2}T_{i-1}^{n} + (1-r)T_i^{n} + \\frac{r}{2}T_{i+1}^{n} $$\nThis equation is valid for the interior nodes of the domain, i.e., for $i = 1, 2, \\dots, N_x-2$.\n\nThe problem specifies homogeneous Dirichlet boundary conditions: $T(0,t) = 0$ and $T(L,t) = 0$. In our discrete framework, this translates to $T_0^n = 0$ and $T_{N_x-1}^n = 0$ for all time steps $n$.\n\nThis system of linear equations for the unknown temperatures at the interior nodes $\\{T_i^{n+1}\\}_{i=1}^{N_x-2}$ can be written in matrix form as:\n$$ \\mathbf{A} \\mathbf{T}_{\\mathrm{int}}^{n+1} = \\mathbf{B} \\mathbf{T}_{\\mathrm{int}}^{n} $$\nwhere $\\mathbf{T}_{\\mathrm{int}}^n = [T_1^n, T_2^n, \\dots, T_{N_x-2}^n]^T$ is the vector of interior temperatures. The matrices $\\mathbf{A}$ and $\\mathbf{B}$ are tridiagonal and have dimensions $(N_x-2) \\times (N_x-2)$.\n\nThe LHS matrix $\\mathbf{A}$ is:\n$$ \\mathbf{A} = \\begin{pmatrix}\n1+r  -r/2  0  \\dots \\\\\n-r/2  1+r  -r/2  \\dots \\\\\n0  \\ddots  \\ddots  \\ddots \\\\\n\\dots  -r/2  1+r  -r/2 \\\\\n\\dots  0  -r/2  1+r\n\\end{pmatrix} $$\nThe RHS matrix $\\mathbf{B}$ is:\n$$ \\mathbf{B} = \\begin{pmatrix}\n1-r  r/2  0  \\dots \\\\\nr/2  1-r  r/2  \\dots \\\\\n0  \\ddots  \\ddots  \\ddots \\\\\n\\dots  r/2  1-r  r/2 \\\\\n\\dots  0  r/2  1-r\n\\end{pmatrix} $$\nNote that the terms involving $T_0$ and $T_{N_x-1}$ from the general stencil equation are zero due to the boundary conditions and are thus absorbed. For example, for the first interior node ($i=1$), the equation is $(1+r)T_1^{n+1} - \\frac{r}{2}T_2^{n+1} = (1-r)T_1^n + \\frac{r}{2}T_2^n$.\n\nTo advance the solution from time $t_n$ to $t_{n+1}$, we perform the following steps:\n1.  Construct the known RHS vector $\\mathbf{b} = \\mathbf{B} \\mathbf{T}_{\\mathrm{int}}^{n}$.\n2.  Solve the linear system $\\mathbf{A} \\mathbf{T}_{\\mathrm{int}}^{n+1} = \\mathbf{b}$ for the unknown vector $\\mathbf{T}_{\\mathrm{int}}^{n+1}$.\nSince $\\mathbf{A}$ is a symmetric, positive-definite, tridiagonal matrix, this system can be solved very efficiently, for instance, using the Thomas algorithm or a banded matrix solver.\n\nThe initial condition $T(x,0) = \\sin\\left(\\frac{\\pi x}{L}\\right) + \\frac{1}{2}\\sin\\left(\\frac{3\\pi x}{L}\\right)$ is used to set the temperature vector $\\mathbf{T}^0$ at $n=0$. The numerical solution is then marched forward in time until $t = t_{\\mathrm{end}}$.\n\nFinally, the discrete root-mean-square error $E$ is calculated at $t=t_{\\mathrm{end}}$ by comparing the numerical solution $T_i^{n_{\\mathrm{end}}}$ with the exact solution $T_{\\mathrm{exact}}(x_i, t_{\\mathrm{end}})$ at all grid nodes $i = 0, \\dots, N_x-1$:\n$$ E = \\sqrt{\\frac{1}{N_x}\\sum_{i=0}^{N_x-1}\\left(T_i^{n_{\\mathrm{end}}} - T_{\\mathrm{exact}}(x_i, t_{\\mathrm{end}})\\right)^2} $$\nThe specified exact solution is used for this comparison.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef exact_solution(x, t, L, alpha):\n    \"\"\"\n    Computes the exact analytical solution to the heat equation problem.\n    \"\"\"\n    term1 = np.exp(-alpha * (np.pi / L)**2 * t) * np.sin(np.pi * x / L)\n    term2 = 0.5 * np.exp(-alpha * (3 * np.pi / L)**2 * t) * np.sin(3 * np.pi * x / L)\n    return term1 + term2\n\ndef run_simulation(L, alpha, t_end, Nx, dt):\n    \"\"\"\n    Runs one simulation of the Crank-Nicolson scheme for the 1D heat equation.\n\n    Args:\n        L (float): Length of the slab in meters.\n        alpha (float): Thermal diffusivity in m^2/s.\n        t_end (float): Final simulation time in seconds.\n        Nx (int): Number of spatial grid points.\n        dt (float): Time step in seconds.\n\n    Returns:\n        float: The root-mean-square error at t_end.\n    \"\"\"\n    # 1. Setup spatial and temporal grid\n    dx = L / (Nx - 1)\n    x = np.linspace(0, L, Nx)\n    \n    # Ensure t_end is a multiple of dt\n    num_t_steps = int(round(t_end / dt))\n\n    # 2. Define the non-dimensional diffusion number\n    r = alpha * dt / dx**2\n\n    # 3. Set the initial condition T(x, 0)\n    T = exact_solution(x, 0, L, alpha)\n\n    # 4. Set up the tridiagonal system A * T_new = b for interior nodes\n    N_int = Nx - 2  # Number of interior nodes\n    \n    # The LHS matrix A is constant, so it can be constructed once.\n    # We use the banded format required by scipy.linalg.solve_banded.\n    # The matrix has 1 lower diagonal, 1 main diagonal, 1 upper diagonal.\n    # The format is a (3, N_int) array.\n    A_banded = np.zeros((3, N_int))\n    A_banded[0, 1:] = -r / 2.0      # Super-diagonal (u)\n    A_banded[1, :] = 1.0 + r         # Main diagonal (d)\n    A_banded[2, :-1] = -r / 2.0      # Sub-diagonal (l)\n\n    # 5. Perform the time-marching loop\n    T_int = T[1:-1].copy() # Get interior nodes for the first step\n\n    for _ in range(num_t_steps):\n        # Construct the RHS vector b = B * T_int\n        # This is done explicitly to avoid forming the matrix B\n        b = np.zeros(N_int)\n        \n        # General case for nodes not adjacent to boundaries\n        if N_int > 2:\n            b[1:-1] = (r / 2.0) * T_int[:-2] + (1.0 - r) * T_int[1:-1] + (r / 2.0) * T_int[2:]\n        \n        # First interior node (i=1), where T_0^n = 0\n        if N_int > 0:\n            b[0] = (1.0 - r) * T_int[0] + (r / 2.0) * T_int[1] if N_int > 1 else (1.0 - r) * T_int[0]\n        \n        # Last interior node (i=Nx-2), where T_{Nx-1}^n = 0\n        if N_int > 1:\n            b[-1] = (r / 2.0) * T_int[-2] + (1.0 - r) * T_int[-1]\n\n        # Solve the linear system A * T_int_new = b for T_int_new\n        T_int = solve_banded((1, 1), A_banded, b)\n\n    # 6. Reconstruct the full solution vector at t_end\n    T_numerical = np.zeros(Nx)\n    T_numerical[1:-1] = T_int\n    # Boundary nodes T_numerical[0] and T_numerical[-1] remain 0.\n\n    # 7. Calculate the exact solution at t_end\n    T_exact_final = exact_solution(x, t_end, L, alpha)\n\n    # 8. Compute the Root-Mean-Square (RMS) error\n    # The sum is over all Nx points, including boundaries.\n    error = np.sqrt(np.mean((T_numerical - T_exact_final)**2))\n    \n    return error\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, alpha, t_end, Nx, dt)\n        (1.0, 1.0e-4, 10.0, 51, 0.10),    # Test 1\n        (1.0, 1.0e-4, 10.0, 51, 0.025),   # Test 2\n        (1.0, 1.0e-4, 10.0, 201, 0.10),   # Test 3\n        (1.0, 1.0e-4, 10.0, 21, 1.25),    # Test 4\n    ]\n\n    results = []\n    for case in test_cases:\n        L, alpha, t_end, Nx, dt = case\n        # Calculate the error for the current test case.\n        error = run_simulation(L, alpha, t_end, Nx, dt)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world engineering problems often involve complex, time-varying conditions, which demand a robust verification strategy. This exercise challenges you to extend your Crank-Nicolson solver to handle time-dependent source terms and boundary conditions, a critical feature for practical simulations. You will use the powerful Method of Manufactured Solutions (MMS) to create a custom benchmark problem, allowing you to rigorously verify your implementation in the absence of a readily available analytical solution .",
            "id": "3990262",
            "problem": "Consider one-dimensional transient heat conduction in a homogeneous solid rod of length $L$ with constant thermal diffusivity $\\alpha$. Let $x \\in [0,L]$ and $t \\ge 0$. The governing equation follows from conservation of energy and Fourier’s law, expressed as the heat equation with a volumetric source term: $$\\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2} + s(x,t).$$ Assume Dirichlet boundary conditions $T(0,t) = g_0(t)$ and $T(L,t) = g_L(t)$, and an initial condition $T(x,0) = T_0(x)$. The temperature $T$ is measured in kelvin, lengths in meters, and time in seconds. Angles (if any) must be in radians.\n\nTo test a time-centered implementation of time-dependent boundary conditions and volumetric sources in the Crank-Nicolson scheme, use the Method of Manufactured Solutions. Define the exact solution $$u(x,t) = \\sin\\!\\left(\\frac{\\pi x}{L}\\right)\\cos(\\omega t) + \\frac{x}{L}\\, t\\, e^{-\\beta t}.$$ From the governing equation and this $u(x,t)$, determine the corresponding source term $s(x,t)$, boundary functions $g_0(t)$ and $g_L(t)$, and initial condition $T_0(x)$ so that $u(x,t)$ satisfies the problem exactly. All angles are in radians.\n\nStarting from the above fundamental laws and definitions, derive a Crank-Nicolson time discretization for the interior nodes that correctly incorporates the time-dependent source and boundary conditions via time-centered contributions evaluated at $t^n$ and $t^{n+1}$. In particular, the discrete system must use the spatial second difference operator on the interior and include boundary-value influences in a manner consistent with time-centering. Do not use pre-derived shortcut formulas; instead, derive the discrete scheme from first principles by applying temporal midpoint quadrature to the governing equation and eliminating the boundary nodes via Dirichlet constraints.\n\nImplement your derivation in a complete program that:\n- Discretizes the spatial domain uniformly with $N_x$ intervals, so the grid spacing is $\\Delta x = L/N_x$ and the interior unknowns are at $x_i = i\\Delta x$ for $i=1,2,\\dots,N_x-1$.\n- Uses a uniform time step $\\Delta t$ such that $t_f/\\Delta t$ is an integer, and advances the solution to the final time $t_f$.\n- Evaluates the volumetric source term $s(x,t)$ at $t^n$ and $t^{n+1}$ and forms a time-centered contribution.\n- Evaluates the boundary values $g_0(t)$ and $g_L(t)$ at $t^n$ and $t^{n+1}$ and incorporates their time-centered influence into the interior equations.\n- Initializes with $T_0(x)$ and computes the numerical solution $T^{n}(x)$ at each time step.\n\nFor each test case below, compute the maximum absolute error at the final time $t_f$, defined as $$E_{\\infty} = \\max_{0 \\le i \\le N_x} \\left| T(x_i,t_f) - u(x_i,t_f) \\right|.$$ Report each $E_{\\infty}$ in kelvin as a floating-point number.\n\nUse the following physical parameters (shared by all tests):\n- $L = 0.3$ $\\mathrm{m}$,\n- $\\alpha = 1.6 \\times 10^{-5}$ $\\mathrm{m}^2/\\mathrm{s}$,\n- $\\omega = 7.0$ $\\mathrm{rad}/\\mathrm{s}$,\n- $\\beta = 3.0$ $\\mathrm{s}^{-1}$,\n- $t_f = 0.2$ $\\mathrm{s}$.\n\nTest suite (each case specifies $(N_x,\\Delta t)$):\n1. Happy path: $(N_x,\\Delta t) = (50, 0.004)$.\n2. Coarse resolution edge case: $(N_x,\\Delta t) = (12, 0.01)$.\n3. Fine resolution case: $(N_x,\\Delta t) = (150, 0.001)$.\n\nYour program should produce a single line of output containing the three results as a comma-separated list enclosed in square brackets (e.g., $[E_1,E_2,E_3]$), where $E_1$, $E_2$, and $E_3$ correspond to the cases $1$, $2$, and $3$, respectively. Each entry must be the floating-point value of $E_{\\infty}$ in kelvin.",
            "solution": "The problem is first validated by determining the source term, boundary conditions, and initial condition that are consistent with the provided manufactured solution. Subsequently, the Crank-Nicolson numerical scheme is derived from first principles and formulated as a matrix system.\n\n### 1. Problem Formulation via the Method of Manufactured Solutions\n\nThe one-dimensional transient heat equation with a source term is given by:\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2} + s(x,t)\n$$\nWe are given a manufactured solution $u(x,t)$ which is assumed to be the exact solution to the problem.\n$$\nu(x,t) = \\sin\\!\\left(\\frac{\\pi x}{L}\\right)\\cos(\\omega t) + \\frac{x}{L}\\, t\\, e^{-\\beta t}\n$$\nTo make this function an exact solution, we must derive the source term $s(x,t)$, initial condition $T_0(x)$, and boundary conditions $g_0(t)$ and $g_L(t)$ that satisfy the governing equation and the constraints.\n\nFirst, we compute the necessary partial derivatives of $u(x,t)$.\n\nThe partial derivative with respect to time $t$ is:\n$$\n\\frac{\\partial u}{\\partial t} = \\frac{\\partial}{\\partial t} \\left[ \\sin\\!\\left(\\frac{\\pi x}{L}\\right)\\cos(\\omega t) \\right] + \\frac{\\partial}{\\partial t} \\left[ \\frac{x}{L} t e^{-\\beta t} \\right] \\\\\n\\frac{\\partial u}{\\partial t} = -\\omega \\sin\\!\\left(\\frac{\\pi x}{L}\\right)\\sin(\\omega t) + \\frac{x}{L} (1 \\cdot e^{-\\beta t} + t \\cdot (-\\beta e^{-\\beta t})) \\\\\n\\frac{\\partial u}{\\partial t} = -\\omega \\sin\\!\\left(\\frac{\\pi x}{L}\\right)\\sin(\\omega t) + \\frac{x}{L} (1 - \\beta t) e^{-\\beta t}\n$$\nThe second partial derivative with respect to space $x$ is:\n$$\n\\frac{\\partial u}{\\partial x} = \\frac{\\pi}{L} \\cos\\!\\left(\\frac{\\pi x}{L}\\right)\\cos(\\omega t) + \\frac{1}{L} t e^{-\\beta t} \\\\\n\\frac{\\partial^2 u}{\\partial x^2} = -\\left(\\frac{\\pi}{L}\\right)^2 \\sin\\!\\left(\\frac{\\pi x}{L}\\right)\\cos(\\omega t)\n$$\nThe source term $s(x,t)$ is found by rearranging the governing equation: $s(x,t) = \\frac{\\partial T}{\\partial t} - \\alpha \\frac{\\partial^2 T}{\\partial x^2}$. Substituting the derivatives of $u(x,t)$:\n$$\ns(x,t) = \\left[ -\\omega \\sin\\!\\left(\\frac{\\pi x}{L}\\right)\\sin(\\omega t) + \\frac{x}{L} (1 - \\beta t) e^{-\\beta t} \\right] - \\alpha \\left[ -\\left(\\frac{\\pi}{L}\\right)^2 \\sin\\!\\left(\\frac{\\pi x}{L}\\right)\\cos(\\omega t) \\right] \\\\\ns(x,t) = \\sin\\!\\left(\\frac{\\pi x}{L}\\right) \\left[ \\alpha\\left(\\frac{\\pi}{L}\\right)^2\\cos(\\omega t) - \\omega\\sin(\\omega t) \\right] + \\frac{x}{L}(1 - \\beta t)e^{-\\beta t}\n$$\nThe initial condition $T_0(x)$ is obtained by evaluating $u(x,t)$ at $t=0$:\n$$\nT_0(x) = u(x,0) = \\sin\\!\\left(\\frac{\\pi x}{L}\\right)\\cos(0) + \\frac{x}{L}(0)e^0 = \\sin\\!\\left(\\frac{\\pi x}{L}\\right)\n$$\nThe Dirichlet boundary conditions are found by evaluating $u(x,t)$ at $x=0$ and $x=L$:\n$$\ng_0(t) = T(0,t) = u(0,t) = \\sin(0)\\cos(\\omega t) + \\frac{0}{L} t e^{-\\beta t} = 0 \\\\\ng_L(t) = T(L,t) = u(L,t) = \\sin(\\pi)\\cos(\\omega t) + \\frac{L}{L} t e^{-\\beta t} = t e^{-\\beta t}\n$$\n\n### 2. Derivation of the Crank-Nicolson Scheme\nThe Crank-Nicolson method is derived by time-centering the governing equation at $t^{n+1/2} = t^n + \\Delta t/2$. The time derivative is approximated by a central difference over the interval $[t^n, t^{n+1}]$, and the spatial derivative and source terms are approximated by the average of their values at $t^n$ and $t^{n+1}$. Let $T_i^n \\approx T(x_i, t^n)$.\n\n$$\n\\left. \\frac{\\partial T}{\\partial t} \\right|_{i}^{n+1/2} = \\frac{1}{2} \\left[ \\left(\\alpha \\frac{\\partial^2 T}{\\partial x^2} + s\\right)_i^n + \\left(\\alpha \\frac{\\partial^2 T}{\\partial x^2} + s\\right)_i^{n+1} \\right]\n$$\nUsing a second-order central difference for the time derivative and the standard central difference for the spatial second derivative:\n$$\n\\frac{T_i^{n+1} - T_i^n}{\\Delta t} = \\frac{\\alpha}{2} \\left( \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{(\\Delta x)^2} + \\frac{T_{i+1}^{n+1} - 2T_i^{n+1} + T_{i-1}^{n+1}}{(\\Delta x)^2} \\right) + \\frac{1}{2}(s_i^n + s_i^{n+1})\n$$\nwhere $s_i^k = s(x_i, t^k)$. We group terms at time level $n+1$ (unknowns) on the left side and terms at time level $n$ (knowns) on the right. Let $r = \\frac{\\alpha \\Delta t}{2(\\Delta x)^2}$. Multiplying by $\\Delta t$ and rearranging gives:\n$$\nT_i^{n+1} - r(T_{i+1}^{n+1} - 2T_i^{n+1} + T_{i-1}^{n+1}) = T_i^n + r(T_{i+1}^n - 2T_i^n + T_{i-1}^n) + \\frac{\\Delta t}{2}(s_i^n + s_i^{n+1})\n$$\nThis simplifies to the stencil for the interior nodes $i=1, 2, \\dots, N_x-1$:\n$$\n-r T_{i-1}^{n+1} + (1+2r) T_i^{n+1} - r T_{i+1}^{n+1} = r T_{i-1}^n + (1-2r) T_i^n + r T_{i+1}^n + \\frac{\\Delta t}{2}(s_i^n + s_i^{n+1})\n$$\n\n### 3. Matrix System Formulation\nThe set of equations for all interior nodes forms a tridiagonal system of linear equations, $\\mathbf{A} \\mathbf{T}_{\\text{int}}^{n+1} = \\mathbf{d}^n$, where $\\mathbf{T}_{\\text{int}}^{n+1} = [T_1^{n+1}, T_2^{n+1}, \\dots, T_{N_x-1}^{n+1}]^T$ is the vector of unknown interior temperatures at time $t^{n+1}$.\n\nThe matrix $\\mathbf{A}$ is a $(N_x-1) \\times (N_x-1)$ symmetric tridiagonal matrix:\n$$\n\\mathbf{A} = \n\\begin{pmatrix}\n1+2r  -r  0  \\cdots  0 \\\\\n-r  1+2r  -r  \\cdots  0 \\\\\n0  -r  1+2r   \\vdots \\\\\n\\vdots   \\ddots   -r \\\\\n0  \\cdots   -r  1+2r\n\\end{pmatrix}\n$$\nThe right-hand side vector $\\mathbf{d}^n$ is constructed by considering the terms from time level $n$ and incorporating the boundary conditions. The boundary values $T_0^k = g_0(t^k)$ and $T_{N_x}^k = g_L(t^k)$ for $k \\in \\{n, n+1\\}$ are known.\n\nFor the first interior node ($i=1$):\n$$\n-r T_0^{n+1} + (1+2r) T_1^{n+1} - r T_2^{n+1} = r T_0^n + (1-2r) T_1^n + r T_2^n + \\frac{\\Delta t}{2}(s_1^n + s_1^{n+1})\n$$\nMoving the known boundary term $-r T_0^{n+1}$ to the right-hand side:\n$$\nd_1^n = (1-2r) T_1^n + r T_2^n + r(T_0^n + T_0^{n+1}) + \\frac{\\Delta t}{2}(s_1^n + s_1^{n+1})\n$$\nFor the last interior node ($i=N_x-1$):\n$$\n-r T_{N_x-2}^{n+1} + (1+2r) T_{N_x-1}^{n+1} - r T_{N_x}^{n+1} = r T_{N_x-2}^n + (1-2r) T_{N_x-1}^n + r T_{N_x}^n + \\frac{\\Delta t}{2}(s_{N_x-1}^n + s_{N_x-1}^{n+1})\n$$\nMoving the known boundary term $-r T_{N_x}^{n+1}$ to the right-hand side:\n$$\nd_{N_x-1}^n = r T_{N_x-2}^n + (1-2r) T_{N_x-1}^n + r(T_{N_x}^n + T_{N_x}^{n+1}) + \\frac{\\Delta t}{2}(s_{N_x-1}^n + s_{N_x-1}^{n+1})\n$$\nFor any other interior node $i \\in \\{2, \\dots, N_x-2\\}$:\n$$\nd_i^n = r T_{i-1}^n + (1-2r) T_i^n + r T_{i+1}^n + \\frac{\\Delta t}{2}(s_i^n + s_i^{n+1})\n$$\nAt each time step, we assemble the RHS vector $\\mathbf{d}^n$ using the solution from time $t^n$ and solve the tridiagonal system $\\mathbf{A} \\mathbf{T}_{\\text{int}}^{n+1} = \\mathbf{d}^n$ efficiently using a specialized algorithm such as the Thomas algorithm, available in `scipy.linalg.solve_banded`.\n\n### 4. Algorithmic Procedure\n1.  Set physical and numerical parameters: $L, \\alpha, \\omega, \\beta, t_f, N_x, \\Delta t$.\n2.  Define the functions for the exact solution $u(x,t)$, source term $s(x,t)$, boundary conditions $g_0(t), g_L(t)$, and initial condition $T_0(x)$.\n3.  Create the spatial grid $x_i = i \\Delta x$ for $i=0, \\dots, N_x$, where $\\Delta x = L/N_x$.\n4.  Initialize the temperature vector $T$ of size $N_x+1$ using the initial condition: $T_i = T_0(x_i)$.\n5.  Construct the constant, tridiagonal matrix $\\mathbf{A}$ in a banded format suitable for the solver.\n6.  Iterate in a time-stepping loop from $t=0$ to $t_f$:\n    a. Determine the current time $t^n$ and next time $t^{n+1}$.\n    b. Construct the right-hand side (RHS) vector $\\mathbf{d}^n$ of size $N_x-1$ using the values of $T^n$ and the source and boundary functions evaluated at $t^n$ and $t^{n+1}$.\n    c. Solve the linear system $\\mathbf{A} \\mathbf{T}_{\\text{int}}^{n+1} = \\mathbf{d}^n$ to obtain the interior temperatures at the next time step.\n    d. Update the interior nodes of the main temperature vector $T$ with the new solution $\\mathbf{T}_{\\text{int}}^{n+1}$.\n7.  After the final time step, set the boundary points of the numerical solution $T$ to their exact values at $t_f$: $T_0 = g_0(t_f)$ and $T_{N_x} = g_L(t_f)$.\n8.  Calculate the exact solution $u(x_i, t_f)$ at all grid points.\n9.  Compute the maximum absolute error $E_{\\infty} = \\max_{0 \\le i \\le N_x} |T_i - u(x_i, t_f)|$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main solver function to run the test cases and print the results.\n    \"\"\"\n    # Shared physical parameters\n    L = 0.3  # m\n    alpha = 1.6e-5  # m^2/s\n    omega = 7.0  # rad/s\n    beta = 3.0  # s^-1\n    t_f = 0.2  # s\n\n    # Define the test cases\n    test_cases = [\n        (50, 0.004),   # Case 1: Happy path\n        (12, 0.01),    # Case 2: Coarse resolution\n        (150, 0.001),  # Case 3: Fine resolution\n    ]\n\n    # --- Manufactured Solution and Derived Functions ---\n    # All angles are in radians, as per numpy default.\n\n    def u_exact(x, t, L, omega, beta):\n        \"\"\"Exact manufactured solution u(x, t).\"\"\"\n        term1 = np.sin(np.pi * x / L) * np.cos(omega * t)\n        term2 = (x / L) * t * np.exp(-beta * t)\n        return term1 + term2\n\n    def s_source(x, t, L, alpha, omega, beta):\n        \"\"\"Derived volumetric source term s(x, t).\"\"\"\n        pi_L_sq = (np.pi / L)**2\n        term1_factor = alpha * pi_L_sq * np.cos(omega * t) - omega * np.sin(omega * t)\n        term1 = np.sin(np.pi * x / L) * term1_factor\n        term2 = (x / L) * (1 - beta * t) * np.exp(-beta * t)\n        return term1 + term2\n\n    def g0(t):\n        \"\"\"Boundary condition at x=0.\"\"\"\n        return 0.0\n\n    def gL(t, beta):\n        \"\"\"Boundary condition at x=L.\"\"\"\n        return t * np.exp(-beta * t)\n\n    def T0(x, L):\n        \"\"\"Initial condition T(x, 0).\"\"\"\n        return np.sin(np.pi * x / L)\n\n    def run_simulation(Nx, dt):\n        \"\"\"\n        Runs the Crank-Nicolson simulation for a single test case.\n\n        Args:\n            Nx (int): Number of spatial intervals.\n            dt (float): Time step size.\n\n        Returns:\n            float: The maximum absolute error E_infinity at the final time.\n        \"\"\"\n        # --- Discretization Setup ---\n        dx = L / Nx\n        x = np.linspace(0, L, Nx + 1)\n        num_steps = round(t_f / dt)\n        # Ensure final time is an exact multiple of dt\n        final_time = num_steps * dt\n\n        # Diffusion number for Crank-Nicolson\n        r = alpha * dt / (2.0 * dx**2)\n\n        # --- Matrix System Setup (A * T_n+1 = d_n) ---\n        num_interior_nodes = Nx - 1\n        \n        # Construct the banded matrix A for the LHS\n        A_banded = np.zeros((3, num_interior_nodes))\n        A_banded[0, 1:] = -r  # Super-diagonal\n        A_banded[1, :] = 1.0 + 2.0 * r  # Main diagonal\n        A_banded[2, :-1] = -r  # Sub-diagonal\n        \n        # --- Initialization ---\n        T = T0(x, L)\n        \n        # --- Time Marching Loop ---\n        for n in range(num_steps):\n            t_n = n * dt\n            t_n_plus_1 = (n + 1) * dt\n            \n            T_interior_n = T[1:Nx]\n            \n            # Construct the RHS vector d_n\n            d_n = np.zeros(num_interior_nodes)\n\n            # Contribution from B * T_n (interior nodes)\n            # This is equivalent to r*T_{i-1}^n + (1-2r)*T_i^n + r*T_{i+1}^n for i=2..Nx-2\n            if num_interior_nodes > 1:\n                d_n[1:-1] = r * T_interior_n[:-2] + (1.0 - 2.0 * r) * T_interior_n[1:-1] + r * T_interior_n[2:]\n                # First interior node (i=1)\n                d_n[0] = (1.0 - 2.0 * r) * T_interior_n[0] + r * T_interior_n[1]\n                # Last interior node (i=Nx-1)\n                d_n[-1] = r * T_interior_n[-2] + (1.0 - 2.0 * r) * T_interior_n[-1]\n            elif num_interior_nodes == 1:\n                d_n[0] = (1.0 - 2.0 * r) * T_interior_n[0]\n\n            \n            # Add source term contribution\n            s_n = s_source(x[1:Nx], t_n, L, alpha, omega, beta)\n            s_n_plus_1 = s_source(x[1:Nx], t_n_plus_1, L, alpha, omega, beta)\n            d_n += (dt / 2.0) * (s_n + s_n_plus_1)\n\n            # Add boundary condition contribution\n            if num_interior_nodes > 0:\n                d_n[0] += r * (g0(t_n) + g0(t_n_plus_1))\n                d_n[-1] += r * (gL(t_n, beta) + gL(t_n_plus_1, beta))\n            \n            # Solve the linear system for T at t_n+1\n            if num_interior_nodes > 0:\n                T_interior_n_plus_1 = solve_banded((1, 1), A_banded, d_n)\n            \n                # Update the solution vector\n                T[1:Nx] = T_interior_n_plus_1\n\n        # --- Error Calculation at Final Time ---\n        # Update boundary values to t_f for correct error calculation\n        T[0] = g0(final_time)\n        T[Nx] = gL(final_time, beta)\n\n        T_exact_final = u_exact(x, final_time, L, omega, beta)\n        error = np.max(np.abs(T - T_exact_final))\n        \n        return error\n\n    results = []\n    for Nx, dt in test_cases:\n        error_inf = run_simulation(Nx, dt)\n        results.append(error_inf)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}