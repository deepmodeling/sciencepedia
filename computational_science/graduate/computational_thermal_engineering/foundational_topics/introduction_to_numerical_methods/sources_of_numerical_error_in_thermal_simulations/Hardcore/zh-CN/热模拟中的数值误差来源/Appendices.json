{
    "hands_on_practices": [
        {
            "introduction": "在将控制方程（如热传导方程）离散化时，我们用代数近似代替了微分算子，这必然会引入离散误差。验证数值代码的一个基本步骤是确认随着网格的细化，这个误差会减小，并以预期的速率收敛。本练习  将指导您使用“制造解法”（Method of Manufactured Solutions），通过一个精确已知的解析解来严格量化一个简单一维稳态热传导问题的离散误差，并计算其收敛阶，这是评估数值方法准确性的核心技能。",
            "id": "3984849",
            "problem": "考虑一维稳态传导问题，热导率恒定，其控制偏微分方程 (PDE) 为 $- \\dfrac{d^2 T}{dx^2} = q(x)$，定义域为 $x \\in [0,1]$，边界条件为狄利克雷边界条件 $T(0) = 0$ 和 $T(1) = 0$。令精确解为 $T(x) = \\sin(\\pi x)$。为确保 $T(x)$ 是该偏微分方程的精确解，取源项为 $q(x) = \\pi^2 \\sin(\\pi x)$。我们关注的量是由拉普拉斯算子的二阶均匀网格有限差分近似引起的离散化误差。\n\n使用包含 $N$ 个单元的均匀网格，这意味着网格间距为 $h = 1/N$，内部节点索引为 $i = 1, 2, \\dots, N-1$，其位置在 $x_i = i h$。在内部节点上，使用标准的二阶中心差分格式对算子 $- \\dfrac{d^2 T}{dx^2}$ 进行离散化，并结合狄利克雷边界条件，从而得到一个关于内部节点离散解值的三对角线性系统。组装并求解该离散系统，以获得每个内部节点 $x_i$ 处的数值近似解 $T_h(x_i)$。\n\n将内部节点上的逐点离散化误差定义为 $e_i = T_h(x_i) - T(x_i)$，并计算误差的离散勒贝格二次范数 (L2)，\n$$\n\\|e\\|_{2,h} = \\sqrt{h \\sum_{i=1}^{N-1} e_i^2},\n$$\n该范数是对 $[0,1]$ 上连续 $L_2$ 范数的一致近似。此外，通过对任意一对连续加倍的网格 $(N, 2N)$ 进行计算，来量化连续网格加密之间的经验收敛率，\n$$\np(N,2N) = \\frac{\\log\\left(\\|e\\|_{2,h_{2N}} / \\|e\\|_{2,h_N}\\right)}{\\log(1/2)}.\n$$\n这个 $p(N,2N)$ 表征了对于所选的数值格式和问题，离散 $L_2$ 误差随 $N$ 变化的标度关系。\n\n您的程序必须：\n- 为每个指定的 $N$ 构建并求解离散有限差分系统。\n- 使用上述定义为每个 $N$ 计算 $\\|e\\|_{2,h}$。\n- 为测试套件中所有可用的连续加倍网格对计算 $p(N,2N)$。\n\n不需要物理单位；所有量均为无量纲。角度以弧度为单位，因为 $\\pi$ 在精确解 $T(x) = \\sin(\\pi x)$ 中作为角频率出现。\n\n测试套件：\n- 使用以下网格尺寸集合：$N \\in \\{2, 3, 4, 8, 16, 32, 64\\}$。\n- 按所列顺序为每个 $N$ 计算相应的误差 $\\|e\\|_{2,h}$。\n- 为连续加倍的网格对 $(4, 8)$、$(8, 16)$、$(16, 32)$ 和 $(32, 64)$ 计算观测到的收敛阶 $p(N,2N)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个方括号内的两个列表。第一个列表按顺序包含 $N \\in \\{2, 3, 4, 8, 16, 32, 64\\}$ 的误差 $\\|e\\|_{2,h}$。第二个列表包含四个连续加倍网格对 $(4, 8)$、$(8, 16)$、$(16, 32)$ 和 $(32, 64)$ 的观测收敛阶 $p(N,2N)$。例如，输出结构必须为 $[[\\text{error}_{N=2}, \\dots, \\text{error}_{N=64}], [p(4,8), p(8,16), p(16,32), p(32,64)]]$ 的形式。",
            "solution": "该问题要求使用二阶有限差分法对一维泊松方程进行数值求解，并随后分析离散化误差及其收敛率。\n\n控制偏微分方程 (PDE) 如下：\n$$\n- \\frac{d^2 T}{dx^2} = q(x)\n$$\n定义域为 $x \\in [0, 1]$。该问题附有齐次狄利克雷边界条件：\n$$\nT(0) = 0 \\quad \\text{and} \\quad T(1) = 0\n$$\n为便于误差分析，指定了一个构造解 $T(x) = \\sin(\\pi x)$。为确保此函数满足偏微分方程，必须相应地选择源项 $q(x)$。对精确解求两次导数可得：\n$$\n\\frac{dT}{dx} = \\pi \\cos(\\pi x) \\quad \\implies \\quad \\frac{d^2 T}{dx^2} = -\\pi^2 \\sin(\\pi x)\n$$\n将此代入偏微分方程，得到所需的源项：\n$$\n- (-\\pi^2 \\sin(\\pi x)) = q(x) \\quad \\implies \\quad q(x) = \\pi^2 \\sin(\\pi x)\n$$\n构造解同样满足所给的边界条件，因为 $T(0) = \\sin(0) = 0$ 且 $T(1) = \\sin(\\pi) = 0$。\n\n为数值求解该问题，我们使用包含 $N$ 个单元的均匀网格对定义域 $[0, 1]$ 进行离散化。这将创建 $N+1$ 个节点，位置在 $x_i = i h$，$i = 0, 1, \\dots, N$，其中网格间距为 $h = 1/N$。数值解记为 $T_{h,i}$，将在 $N-1$ 个内部节点上计算，即对 $i = 1, 2, \\dots, N-1$。\n\n二阶导数算子 $-d^2T/dx^2$ 在每个内部节点 $x_i$ 处使用二阶精度的中心差分格式进行近似。$T(x_{i+1})$ 和 $T(x_{i-1})$ 在 $x_i$ 点的泰勒级数展开可得到以下近似式：\n$$\n\\left. \\frac{d^2 T}{dx^2} \\right|_{x_i} = \\frac{T(x_{i+1}) - 2T(x_i) + T(x_{i-1})}{h^2} + \\mathcal{O}(h^2)\n$$\n将此近似式代入数值解 $T_{h,i}$ 的控制偏微分方程，得到每个内部节点 $i$ 处的有限差分方程：\n$$\n- \\frac{T_{h,i+1} - 2T_{h,i} + T_{h,i-1}}{h^2} = q(x_i)\n$$\n重排此方程可得到内部节点上未知数的关系式：\n$$\n-T_{h,i-1} + 2T_{h,i} - T_{h,i+1} = h^2 q(x_i) \\quad \\text{for } i = 1, 2, \\dots, N-1\n$$\n边界条件 $T_{h,0} = T(0) = 0$ 和 $T_{h,N} = T(1) = 0$ 被整合到第一个 ($i=1$) 和最后一个 ($i=N-1$) 内部节点中：\n对于 $i=1$：$-T_{h,0} + 2T_{h,1} - T_{h,2} = h^2 q(x_1) \\implies 2T_{h,1} - T_{h,2} = h^2 q(x_1)$。\n对于 $i=N-1$：$-T_{h,N-2} + 2T_{h,N-1} - T_{h,N} = h^2 q(x_{N-1}) \\implies -T_{h,N-2} + 2T_{h,N-1} = h^2 q(x_{N-1})$。\n\n这 $N-1$ 个线性方程可以表示为矩阵形式 $A \\mathbf{T}_h = \\mathbf{b}$，其中：\n- $\\mathbf{T}_h = [T_{h,1}, T_{h,2}, \\dots, T_{h,N-1}]^T$ 是未知解值的向量。\n- $A$ 是一个 $(N-1) \\times (N-1)$ 的对称正定三对角矩阵：\n$$\nA = \\begin{pmatrix}\n2  -1  0  \\dots  0 \\\\\n-1  2  -1  \\dots  0 \\\\\n0  \\ddots  \\ddots  \\ddots  0 \\\\\n\\vdots  \\dots  -1  2  -1 \\\\\n0  \\dots  0  -1  2\n\\end{pmatrix}\n$$\n- $\\mathbf{b}$ 是大小为 $N-1$ 的右端向量，其分量为 $b_i = h^2 q(x_i) = h^2 \\pi^2 \\sin(\\pi x_i) = h^2 \\pi^2 \\sin(\\pi i h)$。\n\n求解该问题的步骤如下：\n1.  对于每个指定的网格尺寸 $N$，构建矩阵 $A$ 和向量 $\\mathbf{b}$。\n2.  求解线性系统 $A \\mathbf{T}_h = \\mathbf{b}$ 以获得数值解 $\\mathbf{T}_h$。\n3.  计算逐点误差向量 $\\mathbf{e}$，其中每个分量为 $e_i = T_{h,i} - T(x_i)$，$i=1, \\dots, N-1$。\n4.  使用给定公式计算误差的离散勒贝格二次范数 (L2 范数)：\n    $$\n    \\|e\\|_{2,h} = \\sqrt{h \\sum_{i=1}^{N-1} e_i^2}\n    $$\n5.  在计算完所有必需的 $N$ 的误差后，确定连续加密网格对 $(N, 2N)$ 的经验收敛阶 $p$。对于一个 $p$ 阶格式，误差随网格尺寸 $h$ 的变化关系为 $\\|e\\|_{2,h} \\approx C h^p$，其中 $C$ 是一个常数。对于两个尺寸分别为 $h_N = 1/N$ 和 $h_{2N} = 1/(2N)$ 的网格，我们有以下比率：\n    $$\n    \\frac{\\|e\\|_{2,h_{2N}}}{\\|e\\|_{2,h_N}} \\approx \\frac{C h_{2N}^p}{C h_N^p} = \\left(\\frac{h_{2N}}{h_N}\\right)^p = \\left(\\frac{1/2N}{1/N}\\right)^p = \\left(\\frac{1}{2}\\right)^p\n    $$\n    取对数求解 $p$ 得到观测到的收敛阶的公式：\n    $$\n    p(N,2N) = \\frac{\\log\\left(\\|e\\|_{2,h_{2N}} / \\|e\\|_{2,h_N}\\right)}{\\log(1/2)}\n    $$\n    由于中心差分格式是二阶精度的，我们预期随着 $N$ 的增大，$p(N,2N)$ 会趋近于 $2$。\n\n对网格尺寸集合 $N \\in \\{2, 3, 4, 8, 16, 32, 64\\}$ 实施这整个过程，以生成所需的误差范数和收敛率。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Solves the 1D Poisson equation using a finite difference method,\n    computes the L2 error norm, and estimates the convergence rate.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = {\n        'N_values': [2, 3, 4, 8, 16, 32, 64],\n        'rate_pairs': [(4, 8), (8, 16), (16, 32), (32, 64)]\n    }\n\n    N_values = test_cases['N_values']\n    rate_pairs = test_cases['rate_pairs']\n    \n    errors = {}\n\n    for N in N_values:\n        # 1. Setup mesh and grid parameters\n        h = 1.0 / N\n        num_interior_nodes = N - 1\n        \n        # If there are no interior nodes (e.g., N=1), there is nothing to solve.\n        if num_interior_nodes == 0:\n            errors[N] = 0.0\n            continue\n\n        # Interior node locations\n        x_i = np.arange(1, N) * h\n\n        # 2. Construct the tridiagonal linear system A*T_h = b\n        \n        # The matrix A is represented in a banded format for scipy.linalg.solve_banded.\n        # For a tridiagonal matrix with diagonals at -1, 0, 1, the shape is (3, num_interior_nodes).\n        # Row 0: Super-diagonal (u=1)\n        # Row 1: Main diagonal\n        # Row 2: Sub-diagonal (l=1)\n        ab = np.zeros((3, num_interior_nodes))\n        ab[0, 1:] = -1.0\n        ab[1, :] = 2.0\n        ab[2, :-1] = -1.0\n\n        # Construct the right-hand side vector b\n        # q(x) = pi^2 * sin(pi*x)\n        # b_i = h^2 * q(x_i)\n        q_i = np.pi**2 * np.sin(np.pi * x_i)\n        b = h**2 * q_i\n\n        # 3. Solve the linear system\n        # The (l, u) tuple is (1, 1) for a tridiagonal matrix\n        T_h = solve_banded((1, 1), ab, b)\n        \n        # 4. Compute the error\n        # Exact solution T(x) = sin(pi*x)\n        T_exact = np.sin(np.pi * x_i)\n        \n        # Pointwise error e_i = T_h(x_i) - T(x_i)\n        e_i = T_h - T_exact\n        \n        # Discrete L2 norm of the error\n        # ||e||_{2,h} = sqrt(h * sum(e_i^2))\n        l2_error_norm = np.sqrt(h * np.sum(e_i**2))\n        \n        errors[N] = l2_error_norm\n        \n    # 5. Compute empirical convergence rates\n    rates = []\n    for n1, n2 in rate_pairs:\n        error1 = errors[n1]\n        error2 = errors[n2]\n        # p = log(||e_2N|| / ||e_N||) / log(1/2)\n        rate = np.log(error2 / error1) / np.log(0.5)\n        rates.append(rate)\n\n    # 6. Format the final output\n    error_list = [errors[N] for N in N_values]\n    \n    # Final print statement in the exact required format.\n    print(f\"[[{','.join(map(str, error_list))}],[{','.join(map(str, rates))}]]\")\n\nsolve()\n```"
        },
        {
            "introduction": "数值模拟的准确性不仅取决于网格的密度，还取决于网格的质量，例如单元的形状和长宽比。在多维问题中，尤其是在边界层或复杂几何特征附近，使用具有高长宽比的拉伸网格是很常见的，但这可能导致误差具有各向异性。本练习  通过一个二维热通量计算的案例，让您亲手分析和验证网格长宽比如何引入与方向相关的截断误差，从而加深对网格质量重要性的理解。",
            "id": "3984839",
            "problem": "考虑在热导率 $k$ 为常数的均匀介质中的二维稳态热传导。控制传导热输运的物理定律是傅里叶定律：热通量矢量为 $\\mathbf{q} = -k \\nabla T$，其中 $T(x,y)$ 是空间中的温度场。对于位于点 $(x_0,y_0)$ 且法向为 $x$ 方向的面，穿过该垂直面的精确法向热通量为 $q_x^{\\text{exact}}(x_0,y_0) = -k \\,\\partial T/\\partial x \\big|_{(x_0,y_0)}$。类似地，对于位于 $(x_0,y_0)$ 且法向为 $y$ 方向的面，穿过该水平面的精确法向热通量为 $q_y^{\\text{exact}}(x_0,y_0) = -k \\,\\partial T/\\partial y \\big|_{(x_0,y_0)}$。\n\n您将分析在拉伸的笛卡尔网格上使用标准的二阶中心差分公式近似梯度时，面法向热通量的截断误差。设网格间距为 $\\Delta x$ 和 $\\Delta y$，并定义纵横比 $r = \\Delta x / \\Delta y$。面上的热通量近似使用有限差分法（FDM）沿各自法向的中心差分：\n- 对于 $(x_0,y_0)$ 处的 $x$ 法向面，使用近似 $q_x^{\\text{num}}(x_0,y_0;\\Delta x) = -k \\,\\big(T(x_0+\\Delta x/2,y_0) - T(x_0-\\Delta x/2,y_0)\\big) / \\Delta x$。\n- 对于 $(x_0,y_0)$ 处的 $y$ 法向面，使用近似 $q_y^{\\text{num}}(x_0,y_0;\\Delta y) = -k \\,\\big(T(x_0,y_0+\\Delta y/2) - T(x_0,y_0-\\Delta y/2)\\big) / \\Delta y$。\n\n为了纯粹因网格拉伸而分离出各向异性效应，请使用人工制造的温度场 $T(x,y) = \\exp(a x) + \\exp(a y)$（其中 $a  0$），这样在任何位置的精确导数都是已知的。对于所有计算，设置 $k = 1$（单位 $\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$），设置 $a = 1$（单位 $\\mathrm{m}^{-1}$），并在点 $(x_0,y_0)$ 处评估通量，其中 $x_0 = 0.37$ 和 $y_0 = 0.37$（单位 $\\mathrm{m}$）。固定 $\\Delta y = 0.01$（单位 $\\mathrm{m}$），并定义 $\\Delta x = r \\,\\Delta y$。每个方向的绝对热通量误差定义为 $E_x(r) = \\big|q_x^{\\text{num}} - q_x^{\\text{exact}}\\big|$ 和 $E_y(r) = \\big|q_y^{\\text{num}} - q_y^{\\text{exact}}\\big|$，单位均为 $\\mathrm{W}\\,\\mathrm{m}^{-2}$。为了揭示各向异性引起的缩放行为，构建无量纲量 $S(r) = \\big(E_x(r)/E_y(r)\\big) / r^2$。\n\n从傅里叶定律和二阶中心差分的定义出发，您必须：\n- 使用关于 $(x_0,y_0)$ 的泰勒级数展开，推导 $E_x(r)$ 和 $E_y(r)$ 的主阶截断误差表达式。\n- 证明对于所选的人工解（$a = 1$ 且 $x_0 = y_0$），主阶截断误差之比满足 $E_x(r)/E_y(r) \\propto r^2$，从而当 $\\Delta x$ 和 $\\Delta y$ 足够小时，$S(r)$ 近似为常数且接近于 $1$。\n\n实现一个程序，对下面列出的每个测试用例，计算 $q_x^{\\text{exact}}$、$q_x^{\\text{num}}$、$E_x(r)$、$q_y^{\\text{exact}}$、$q_y^{\\text{num}}$、$E_y(r)$，并仅输出该用例的 $S(r)$。输出必须是无量纲的（没有单位）。\n\n测试套件（每个用例仅指定纵横比，其他参数如上所述固定）：\n- 用例 1：$r = 1$\n- 用例 2：$r = 2$\n- 用例 3：$r = 0.25$\n- 用例 4：$r = 5$\n- 用例 5：$r = 10$\n\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表的结果（例如，$\\big[$result1,result2,result3$\\big]$），其中每个条目是相应测试用例的 $S(r)$。输出是无量纲实数（浮点数）。此问题不涉及角度，所有涉及物理量的内部通量和误差计算都应以 $\\mathrm{W}\\,\\mathrm{m}^{-2}$ 为单位进行，但打印的输出必须是无量纲的。",
            "solution": "该问题已经过验证，被确定为数值分析领域中一个适定且具有科学依据的练习，特别是关于热传导有限差分法中截断误差的分析。所有必需的参数和定义均已提供，问题没有矛盾或含糊之处。\n\n求解过程分两个阶段。首先，进行主阶截断误差的理论推导，以建立预期的缩放行为。其次，开发数值实现来计算给定测试用例的指定量。\n\n### 第 1 部分：截断误差和缩放行为的理论推导\n\n核心任务是分析热通量数值近似的误差。这通过将数值公式与精确解的泰勒级数展开进行比较来实现。\n\n**1. 精确热通量**\n\n分析始于精确温度场 $T(x,y) = \\exp(ax) + \\exp(ay)$ 和傅里叶定律 $\\mathbf{q} = -k \\nabla T$。精确热通量矢量的分量是：\n$q_x^{\\text{exact}}(x,y) = -k \\frac{\\partial T}{\\partial x} = -k \\frac{\\partial}{\\partial x} (\\exp(ax) + \\exp(ay)) = -k a \\exp(ax)$\n$q_y^{\\text{exact}}(x,y) = -k \\frac{\\partial T}{\\partial y} = -k \\frac{\\partial}{\\partial y} (\\exp(ax) + \\exp(ay)) = -k a \\exp(ay)$\n\n在指定的评估点 $(x_0, y_0)$，精确通量为：\n$q_x^{\\text{exact}}(x_0,y_0) = -k a \\exp(ax_0)$\n$q_y^{\\text{exact}}(x_0,y_0) = -k a \\exp(ay_0)$\n\n**2. x 方向通量的截断误差**\n\n$x$ 法向通量的数值近似由二阶中心差分公式给出：\n$q_x^{\\text{num}}(x_0,y_0;\\Delta x) = -k \\frac{T(x_0+\\Delta x/2, y_0) - T(x_0-\\Delta x/2, y_0)}{\\Delta x}$\n\n为了找到截断误差，我们在点 $(x_0, y_0)$ 附近对温度项 $T(x_0+\\Delta x/2, y_0)$ 和 $T(x_0-\\Delta x/2, y_0)$ 进行泰勒级数展开。我们只需要在 $x$ 方向上展开。设 $T_x = \\frac{\\partial T}{\\partial x}$，$T_{xxx} = \\frac{\\partial^3 T}{\\partial x^3}$ 等，均在 $(x_0, y_0)$ 处求值。\n\n$T(x_0+\\frac{\\Delta x}{2}, y_0) = T(x_0,y_0) + \\left(\\frac{\\Delta x}{2}\\right) T_x + \\frac{1}{2!} \\left(\\frac{\\Delta x}{2}\\right)^2 T_{xx} + \\frac{1}{3!} \\left(\\frac{\\Delta x}{2}\\right)^3 T_{xxx} + O(\\Delta x^4)$\n$T(x_0-\\frac{\\Delta x}{2}, y_0) = T(x_0,y_0) - \\left(\\frac{\\Delta x}{2}\\right) T_x + \\frac{1}{2!} \\left(\\frac{\\Delta x}{2}\\right)^2 T_{xx} - \\frac{1}{3!} \\left(\\frac{\\Delta x}{2}\\right)^3 T_{xxx} + O(\\Delta x^4)$\n\n从第一个展开式中减去第二个展开式，可以消去偶数阶导数项：\n$T(x_0+\\frac{\\Delta x}{2}, y_0) - T(x_0-\\frac{\\Delta x}{2}, y_0) = \\Delta x \\,T_x + 2 \\frac{1}{6} \\left(\\frac{\\Delta x}{2}\\right)^3 T_{xxx} + O(\\Delta x^5)$\n$ = \\Delta x \\,T_x + \\frac{\\Delta x^3}{24} T_{xxx} + O(\\Delta x^5)$\n\n除以 $\\Delta x$ 得到导数的近似值：\n$\\frac{T(x_0+\\Delta x/2, y_0) - T(x_0-\\Delta x/2, y_0)}{\\Delta x} = T_x + \\frac{\\Delta x^2}{24} T_{xxx} + O(\\Delta x^4)$\n\n将此代回 $q_x^{\\text{num}}$ 的公式中：\n$q_x^{\\text{num}} = -k \\left( T_x + \\frac{\\Delta x^2}{24} T_{xxx} + O(\\Delta x^4) \\right)$\n$q_x^{\\text{num}} = (-k \\, T_x) - k \\frac{\\Delta x^2}{24} T_{xxx} + O(\\Delta x^4)$\n\n认识到 $q_x^{\\text{exact}} = -k \\, T_x$，我们得到：\n$q_x^{\\text{num}} = q_x^{\\text{exact}} - k \\frac{\\Delta x^2}{24} T_{xxx} + O(\\Delta x^4)$\n\n截断误差为 $\\tau_x = q_x^{\\text{num}} - q_x^{\\text{exact}} = -k \\frac{\\Delta x^2}{24} T_{xxx} + O(\\Delta x^4)$。\n因此，主阶绝对误差 $E_x(r) = |q_x^{\\text{num}} - q_x^{\\text{exact}}|$ 为：\n$E_x(r) \\approx \\left| -k \\frac{\\Delta x^2}{24} \\frac{\\partial^3 T}{\\partial x^3} \\Big|_{(x_0,y_0)} \\right|$\n\n**3. y 方向通量的截断误差**\n\n对于 $y$ 方向的推导是完全类似的：\n$q_y^{\\text{num}} = q_y^{\\text{exact}} - k \\frac{\\Delta y^2}{24} T_{yyy} + O(\\Delta y^4)$\n其中 $T_{yyy} = \\frac{\\partial^3 T}{\\partial y^3} \\Big|_{(x_0,y_0)}$。主阶绝对误差 $E_y(r) = |q_y^{\\text{num}} - q_y^{\\text{exact}}|$ 为：\n$E_y(r) \\approx \\left| -k \\frac{\\Delta y^2}{24} \\frac{\\partial^3 T}{\\partial y^3} \\Big|_{(x_0,y_0)} \\right|$\n\n**4. 人工解的误差缩放行为**\n\n对于特定的温度场 $T(x,y) = \\exp(ax) + \\exp(ay)$，所需的三阶导数是：\n$\\frac{\\partial^3 T}{\\partial x^3} = \\frac{d^3}{dx^3} \\exp(ax) = a^3 \\exp(ax)$\n$\\frac{\\partial^3 T}{\\partial y^3} = \\frac{d^3}{dy^3} \\exp(ay) = a^3 \\exp(ay)$\n\n在 $(x_0, y_0)$ 处的主阶误差变为：\n$E_x(r) \\approx \\frac{k |a^3| \\exp(ax_0)}{24} \\Delta x^2$\n$E_y(r) \\approx \\frac{k |a^3| \\exp(ay_0)}{24} \\Delta y^2$\n由于 $a  0$，绝对值是多余的。这些误差的比值为：\n$\\frac{E_x(r)}{E_y(r)} \\approx \\frac{\\frac{k a^3 \\exp(ax_0)}{24} \\Delta x^2}{\\frac{k a^3 \\exp(ay_0)}{24} \\Delta y^2} = \\frac{\\exp(ax_0)}{\\exp(ay_0)} \\left( \\frac{\\Delta x}{\\Delta y} \\right)^2$\n\n问题指定 $x_0 = y_0$，这使得 $\\exp(ax_0) = \\exp(ay_0)$。此外，网格纵横比为 $r = \\Delta x / \\Delta y$。将这些代入比值中得到：\n$\\frac{E_x(r)}{E_y(r)} \\approx \\left( \\frac{\\Delta x}{\\Delta y} \\right)^2 = r^2$\n\n这表明，对于所选的人工解和评估点，绝对误差之比与网格纵横比的平方成正比，即 $E_x(r)/E_y(r) \\propto r^2$。\n\n最后，我们分析无量纲量 $S(r)$：\n$S(r) = \\frac{E_x(r) / E_y(r)}{r^2}$\n\n基于我们的主阶分析，对于足够小的网格间距 $\\Delta x$ 和 $\\Delta y$，我们预期：\n$S(r) \\approx \\frac{r^2}{r^2} = 1$\n\n$S(r)$ 的值应近似为常数且等于 $1$，这证实了截断误差中的各向异性与网格纵横比的平方直接成比例。数值计算将验证这一理论预测的准确性。\n\n### 第 2 部分：数值实现\n\n以下 Python 代码实现了所述的计算。它定义了精确温度场以及精确和数值热通量的函数。然后，它遍历纵横比 $r$ 的指定测试用例，计算误差 $E_x(r)$ 和 $E_y(r)$，并最终计算缩放量 $S(r)$。结果被收集并以要求的格式打印出来。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the heat flux truncation error problem for a set of aspect ratios.\n    \"\"\"\n    # Define constants and fixed parameters from the problem statement.\n    k = 1.0  # Thermal conductivity in W m^-1 K^-1\n    a = 1.0  # Parameter in manufactured solution in m^-1\n    x0 = 0.37  # x-coordinate of evaluation point in m\n    y0 = 0.37  # y-coordinate of evaluation point in m\n    dy = 0.01  # Grid spacing in y-direction in m\n\n    # Define the test cases for the aspect ratio r.\n    test_cases = [\n        1.0,  # Case 1: r = 1\n        2.0,  # Case 2: r = 2\n        0.25, # Case 3: r = 0.25\n        5.0,  # Case 4: r = 5\n        10.0, # Case 5: r = 10\n    ]\n\n    # --- Function Definitions ---\n\n    def manufactured_temperature(x, y):\n        \"\"\"\n        Calculates the manufactured temperature field T(x,y).\n        T(x,y) = exp(a*x) + exp(a*y)\n        \"\"\"\n        return np.exp(a * x) + np.exp(a * y)\n\n    def exact_flux_x(x):\n        \"\"\"\n        Calculates the exact x-normal heat flux.\n        q_x_exact = -k * a * exp(a*x)\n        \"\"\"\n        return -k * a * np.exp(a * x)\n\n    def exact_flux_y(y):\n        \"\"\"\n        Calculates the exact y-normal heat flux.\n        q_y_exact = -k * a * exp(a*y)\n        \"\"\"\n        return -k * a * np.exp(a * y)\n\n    def numerical_flux_x(x, y, dx_val):\n        \"\"\"\n        Calculates the numerical x-normal heat flux using central differencing.\n        \"\"\"\n        T_plus = manufactured_temperature(x + dx_val / 2.0, y)\n        T_minus = manufactured_temperature(x - dx_val / 2.0, y)\n        return -k * (T_plus - T_minus) / dx_val\n\n    def numerical_flux_y(x, y, dy_val):\n        \"\"\"\n        Calculates the numerical y-normal heat flux using central differencing.\n        \"\"\"\n        T_plus = manufactured_temperature(x, y + dy_val / 2.0)\n        T_minus = manufactured_temperature(x, y - dy_val / 2.0)\n        return -k * (T_plus - T_minus) / dy_val\n\n    results = []\n    # Calculate exact fluxes once, as they are independent of r\n    q_x_e = exact_flux_x(x0)\n    q_y_e = exact_flux_y(y0)\n\n    # Loop over each test case\n    for r in test_cases:\n        # Define dx based on the aspect ratio r\n        dx = r * dy\n\n        # Calculate numerical fluxes\n        q_x_n = numerical_flux_x(x0, y0, dx)\n        q_y_n = numerical_flux_y(x0, y0, dy)\n        \n        # Calculate absolute errors\n        E_x = abs(q_x_n - q_x_e)\n        E_y = abs(q_y_n - q_y_e)\n        \n        # Calculate the dimensionless scaling quantity S(r)\n        # S(r) = (E_x(r) / E_y(r)) / r^2\n        S_r = (E_x / E_y) / (r**2)\n        \n        results.append(S_r)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从稳态问题转向瞬态问题后，我们面临着一个新的误差来源：时间离散化。总的数值误差现在是空间离散误差和时间离散误差共同作用的结果。为了进行有效的瞬态模拟，必须能够区分并平衡这两种误差。本练习  将通过一个瞬态热传导问题，教您如何在一个固定的空间网格上进行时间步长加密研究，从而分离并量化时间积分格式的误差，并评估其相对于空间误差的大小。",
            "id": "3984856",
            "problem": "考虑由能量平衡和傅里叶传导定律控制的一维热传导，对于恒定的材料属性，这会得到偏微分方程 (PDE) $ \\rho c \\frac{\\partial T}{\\partial t} = k \\frac{\\partial^2 T}{\\partial x^2} $，其中 $ \\rho $ 是质量密度，$ c $ 是比热容，$ k $ 是热导率，$ T(x,t) $ 是温度。引入热扩散系数 $ \\alpha = \\frac{k}{\\rho c} $，该 PDE 变为 $ \\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2} $。在空间区间 $ x \\in [0,L] $ 上，对于齐次 Dirichlet 边界条件 $ T(0,t) = T(L,t) = T_{\\text{ref}} $ 和初始偏差 $ u(x,0) = T(x,0) - T_{\\text{ref}} = \\Theta \\sin\\left(\\frac{\\pi x}{L}\\right) $，精确的温度偏差 $ u(x,t) = T(x,t) - T_{\\text{ref}} $ 具有解析解，由 $ u(x,t) = \\Theta \\sin\\left(\\frac{\\pi x}{L}\\right) \\exp\\left(-\\alpha \\frac{\\pi^2}{L^2} t\\right) $ 给出。假设 $ T_{\\text{ref}} $ 和 $ \\Theta $ 是常数。\n\n令 $ N $ 为内部空间网格点的数量，$ \\Delta x = \\frac{L}{N+1} $。考虑使用二阶中心有限差分近似对二阶导数在齐次 Dirichlet 边界条件下进行线方法 (MOL) 空间半离散化。这将得到一个线性常微分方程 (ODE) 系统 $ \\frac{d\\mathbf{u}}{dt} = \\mathbf{A}\\mathbf{u} $，其中 $ \\mathbf{u}(t) \\in \\mathbb{R}^N $ 汇集了内部点 $ x_i = i \\Delta x $ (对于 $ i = 1,2,\\dots,N $) 处 $ u(x,t) $ 的节点值，而 $ \\mathbf{A} \\in \\mathbb{R}^{N \\times N} $ 是由 $ \\alpha $ 缩放的离散拉普拉斯算子。半离散精确解为 $ \\mathbf{u}_{\\text{sd}}(t) = \\exp(\\mathbf{A} t) \\mathbf{u}_0 $，其中 $ \\mathbf{u}_0 $ 是离散化的初始条件，$ \\exp(\\cdot) $ 表示矩阵指数。\n\n在固定的空间分辨率（固定的 $ N $ 和 $ \\Delta x $）下，对三种时间积分方案进行时间加密：前向 Euler（显式一阶）、后向 Euler（隐式一阶）和 Crank–Nicolson（隐式二阶梯形）。对于每种方案，使用一系列三个时间步长 $ \\Delta t_0 $、$ \\Delta t_1 = \\frac{1}{2} \\Delta t_0 $ 和 $ \\Delta t_2 = \\frac{1}{2} \\Delta t_1 $ 来达到指定的最终时间 $ t_f $。对于每个 $ \\Delta t $，计算数值解 $ \\mathbf{u}_{\\text{num}}(t_f) $ 和半离散精确解 $ \\mathbf{u}_{\\text{sd}}(t_f) $，然后使用由 $ \\lVert \\mathbf{e} \\rVert_{2,\\Delta x} = \\left( \\sum_{i=1}^{N} e_i^2 \\Delta x \\right)^{1/2} $ 定义的离散 $ L^2 $ 范数计算时间离散误差 $ E_{\\text{temp}}(\\Delta t) $，其中 $ \\mathbf{e} = \\mathbf{u}_{\\text{num}}(t_f) - \\mathbf{u}_{\\text{sd}}(t_f) $。同时，计算在 $ t_f $ 时的空间离散误差为 $ E_{\\text{spat}} = \\lVert \\mathbf{u}_{\\text{sd}}(t_f) - \\mathbf{u}_{\\text{ex}}(t_f) \\rVert_{2,\\Delta x} $，其中 $ \\mathbf{u}_{\\text{ex}}(t_f) $ 是在网格点 $ x_i $ 上采样的精确连续解 $ u(x,t_f) $。\n\n对于每种方案及其加密序列，通过两次连续加密使用公式 $ p_{\\text{obs}} = \\frac{\\log\\left( \\frac{E_{\\text{temp}}(\\Delta t_1)}{E_{\\text{temp}}(\\Delta t_2)} \\right)}{\\log\\left( \\frac{\\Delta t_1}{\\Delta t_2} \\right)} $ 来确定观测到的时间阶数 $ p_{\\text{obs}} $。对于每种方案，报告序对 $ (p_{\\text{obs}}, r) $，其中 $ r = \\frac{E_{\\text{temp}}(\\Delta t_2)}{E_{\\text{spat}}} $ 量化了在最精细时间步长下时间误差与空间误差的相对大小。所有误差的大小都必须以开尔文 (K) 表示，因为 $ u $ 和 $ T $ 是温度。三角函数中的角度以弧度为单位。\n\n为以下参数集的测试套件实施此实验。在所有情况下，使用 $ T_{\\text{ref}} = 300 \\text{ K} $、$ \\Theta = 1 \\text{ K} $ 以及给定的 $ L $、$ \\alpha $、$ N $ 和 $ t_f $。对于前向 Euler，使用提供的 $ r_0 $ 选择 $ \\Delta t_0 = r_0 \\frac{\\Delta x^2}{\\alpha} $ 以满足显式稳定性约束；对于后向 Euler 和 Crank–Nicolson，使用相同的 $ \\Delta t_0 $ 公式，但请注意这些方案是无条件稳定的。在所有情况下，通过使用整数步数来确保数值积分精确达到 $ t_f $；如果 $ t_f / \\Delta t $ 不是整数，则将步长调整为 $ \\Delta t' = \\frac{t_f}{n} $，其中 $ n = \\mathrm{round}\\left(\\frac{t_f}{\\Delta t}\\right) $。在计算和阶数估算公式中使用调整后的 $ \\Delta t' $。\n\n测试套件：\n- 案例 $ A $ (前向 Euler, \"理想情况\"): $ L = 1 \\text{ m} $, $ \\alpha = 10^{-4} \\text{ m}^2/\\text{s} $, $ N = 50 $, $ t_f = 10 \\text{ s} $, $ r_0 = 0.4 $。\n- 案例 $ B $ (后向 Euler, 粗略步长): $ L = 1 \\text{ m} $, $ \\alpha = 10^{-4} \\text{ m}^2/\\text{s} $, $ N = 50 $, $ t_f = 30 \\text{ s} $, $ r_0 = 4.0 $。\n- 案例 $ C $ (Crank–Nicolson, 中等步长): $ L = 1 \\text{ m} $, $ \\alpha = 10^{-4} \\text{ m}^2/\\text{s} $, $ N = 50 $, $ t_f = 30 \\text{ s} $, $ r_0 = 1.0 $。\n- 案例 $ D $ (前向 Euler, 接近稳定边界): $ L = 1 \\text{ m} $, $ \\alpha = 10^{-4} \\text{ m}^2/\\text{s} $, $ N = 50 $, $ t_f = 10 \\text{ s} $, $ r_0 = 0.49 $。\n\n你的程序必须：\n- 使用二阶中心有限差分近似法，在齐次 Dirichlet 边界条件下构建 $ \\mathbf{A} $ 用于 $ \\frac{\\partial^2}{\\partial x^2} $，并由 $ \\alpha $ 进行缩放。\n- 对于每个案例，使用矩阵指数计算 $ \\mathbf{u}_{\\text{sd}}(t_f) = \\exp(\\mathbf{A} t_f) \\mathbf{u}_0 $。\n- 实现三种时间积分方案，为加密序列中的每个 $ \\Delta t $ 计算 $ \\mathbf{u}_{\\text{num}}(t_f) $。\n- 以开尔文为单位计算 $ E_{\\text{temp}}(\\Delta t) $ 和 $ E_{\\text{spat}} $。\n- 按照定义计算 $ p_{\\text{obs}} $ 和 $ r $。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。列表顺序必须是 $ [p_A, r_A, p_B, r_B, p_C, r_C, p_D, r_D] $，其中 $ p_A $ 和 $ r_A $ 对应案例 A，$ p_B $ 和 $ r_B $ 对应案例 B，以此类推。每个 $ p_{\\text{obs}} $ 和 $ r $ 都必须打印为十进制浮点数（无单位，无百分号）。",
            "solution": "用户提供的问题是计算热工领域一个有效且适定的数值分析练习。所有参数、定义和程序都明确指定，科学上合理，并且计算上可行。该问题将按所述方式解决。\n\n问题的核心是通过分离空间和时间离散误差，来分析一维热方程 $ \\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2} $ 模拟中的数值误差来源。\n\n### 1. 空间离散化：线方法\n\n第一步是使用线方法 (MOL) 将偏微分方程 (PDE) 转换为常微分方程 (ODE) 系统。这是通过将空间域 $ x \\in [0,L] $ 离散化为 $ N+2 $ 个点来实现的，其中有 $ N $ 个内部点 $ x_i = i \\Delta x $ (对于 $ i=1, \\dots, N $)，其中 $ \\Delta x = L/(N+1) $。这些点上的温度偏差由向量 $ \\mathbf{u}(t) = [u_1(t), u_2(t), \\dots, u_N(t)]^T $ 表示，其中 $ u_i(t) = T(x_i, t) - T_{\\text{ref}} $。\n\n在每个内部点 $ x_i $ 处的二阶空间导数 $ \\frac{\\partial^2 u}{\\partial x^2} $ 使用二阶精度的中心有限差分格式来近似：\n$$ \\frac{\\partial^2 u}{\\partial x^2} \\bigg|_{x=x_i} \\approx \\frac{u(x_{i-1},t) - 2u(x_i,t) + u(x_{i+1},t)}{\\Delta x^2} = \\frac{u_{i-1}(t) - 2u_i(t) + u_{i+1}(t)}{\\Delta x^2} $$\n齐次 Dirichlet 边界条件 $ T(0,t)=T(L,t)=T_{\\text{ref}} $ 意味着 $ u_0(t) = 0 $ 和 $ u_{N+1}(t) = 0 $。在每个内部节点 $ i=1, \\dots, N $ 应用有限差分近似，得到线性 ODE 系统：\n$$ \\frac{d\\mathbf{u}}{dt} = \\mathbf{A}\\mathbf{u} $$\n其中 $ \\mathbf{A} \\in \\mathbb{R}^{N \\times N} $ 是一个表示缩放后的离散拉普拉斯算子的常数矩阵。它是一个对称三对角矩阵，如下所示：\n$$ \\mathbf{A} = \\frac{\\alpha}{\\Delta x^2} \n\\begin{pmatrix}\n-2  1  0  \\cdots  0 \\\\\n1  -2  1  \\cdots  0 \\\\\n0  1  \\ddots  \\ddots  \\vdots \\\\\n\\vdots  \\ddots  \\ddots  -2  1 \\\\\n0  \\cdots  0  1  -2\n\\end{pmatrix}\n$$\n\n### 2. 用于误差分析的参考解\n\n为了分离和量化不同的误差来源，我们在最终时间 $ t_f $ 使用三个不同的解向量：\n1.  **精确解析解 ($ \\mathbf{u}_{\\text{ex}} $)**: 连续解析解 $ u(x,t) = \\Theta \\sin\\left(\\frac{\\pi x}{L}\\right) \\exp\\left(-\\alpha \\frac{\\pi^2}{L^2} t\\right) $ 在时间 $ t_f $ 时于网格点 $ x_i $ 上求值。该向量代表了真实的、无误差的解。\n2.  **半离散精确解 ($ \\mathbf{u}_{\\text{sd}} $)**: 这是 ODE 系统 $ \\frac{d\\mathbf{u}}{dt} = \\mathbf{A}\\mathbf{u} $ 的精确解。它使用矩阵指数计算得出，即 $ \\mathbf{u}_{\\text{sd}}(t_f) = \\exp(\\mathbf{A} t_f) \\mathbf{u}_0 $，其中 $ \\mathbf{u}_0 $ 是在网格点上采样的初始条件 $ u(x,0) $。此解没有时间误差，但包含空间离散误差。\n3.  **全离散数值解 ($ \\mathbf{u}_{\\text{num}} $)**: 该解是通过对 ODE 系统应用数值时间积分方案获得的。它同时包含空间和时间误差。\n\n### 3. 误差量化\n\n使用这些参考解，我们定义了两个关键的误差度量，它们使用离散 $ L^2 $ 范数 $ \\lVert \\mathbf{e} \\rVert_{2,\\Delta x} = \\left( \\sum_{i=1}^{N} e_i^2 \\Delta x \\right)^{1/2} $。\n-   **空间离散误差 ($ E_{\\text{spat}} $)**: 此误差完全由空间导数的有限差分近似引起。它是半离散精确解与真实解析解之间的差：\n    $$ E_{\\text{spat}} = \\lVert \\mathbf{u}_{\\text{sd}}(t_f) - \\mathbf{u}_{\\text{ex}}(t_f) \\rVert_{2,\\Delta x} $$\n-   **时间离散误差 ($ E_{\\text{temp}} $)**: 此误差完全由时间积分方案引起。它是全离散数值解与半离散精确解之间的差：\n    $$ E_{\\text{temp}}(\\Delta t) = \\lVert \\mathbf{u}_{\\text{num}}(t_f) - \\mathbf{u}_{\\text{sd}}(t_f) \\rVert_{2,\\Delta x} $$\n\n### 4. 时间积分方案\n\n数值解 $ \\mathbf{u}_{\\text{num}}(t_f) $ 是通过将解从 $ t=0 $ 以离散时间步长 $ \\Delta t $ 推进到 $ t=t_f $ 来计算的。令 $ \\mathbf{u}^k $ 表示在时间 $ t_k = k \\Delta t $ 时的解。这三种方案的实现如下：\n-   **前向 Euler (显式，一阶)**: 更新规则由时间上的前向差分导出，$ \\mathbf{u}^{k+1} = (\\mathbf{I} + \\Delta t \\mathbf{A}) \\mathbf{u}^k $。这在每一步都涉及简单的矩阵-向量乘法。\n-   **后向 Euler (隐式，一阶)**: 更新规则使用后向差分，$ (\\mathbf{I} - \\Delta t \\mathbf{A}) \\mathbf{u}^{k+1} = \\mathbf{u}^k $。这需要在每个时间步求解关于 $ \\mathbf{u}^{k+1} $ 的线性方程组。\n-   **Crank–Nicolson (隐式，二阶)**: 该方案对时间 $ t_k $ 和 $ t_{k+1} $ 的右侧项进行平均，得到更新规则 $ (\\mathbf{I} - \\frac{\\Delta t}{2} \\mathbf{A}) \\mathbf{u}^{k+1} = (\\mathbf{I} + \\frac{\\Delta t}{2} \\mathbf{A}) \\mathbf{u}^k $。这也需要在每一步求解一个线性系统。\n\n对于隐式方案，左侧的矩阵在整个积分过程中是恒定的，因此其 LU 分解只计算一次，并在每一步中重复使用，以高效地求解线性系统。\n\n### 5. 分析步骤\n\n对于每个测试案例和每个指定的积分方案，都进行时间加密研究。使用一系列三个时间步长，$ \\Delta t_0 $、$ \\Delta t_1 = \\Delta t_0/2 $ 和 $ \\Delta t_2 = \\Delta t_1/2 $。在积分之前，每个名义上的 $ \\Delta t $ 都会被调整为 $ \\Delta t' = t_f / \\text{round}(t_f/\\Delta t) $，以确保用整数步数达到最终时间 $ t_f $。对每个调整后的步长计算时间误差 $ E_{\\text{temp}}(\\Delta t') $。\n\n然后，根据两个最精细时间步长 $ \\Delta t'_1 $ 和 $ \\Delta t'_2 $ 的误差，计算观测到的时间收敛阶 $ p_{\\text{obs}} $：\n$$ p_{\\text{obs}} = \\frac{\\log\\left( E_{\\text{temp}}(\\Delta t'_1) / E_{\\text{temp}}(\\Delta t'_2) \\right)}{\\log\\left( \\Delta t'_1 / \\Delta t'_2 \\right)} $$\n理论上，该值应接近积分方案的理论阶数（FE/BE 为 $ 1 $，CN 为 $ 2 $）。\n\n最后，计算最小时间误差与空间误差的比率 $ r $：\n$$ r = \\frac{E_{\\text{temp}}(\\Delta t'_2)}{E_{\\text{spat}}} $$\n该比率量化了在最精细时间步长下，模拟误差是由时间离散化主导还是由空间离散化主导。$ r \\ll 1 $ 的值表示空间主导的误差，而 $ r \\gg 1 $ 表示时间主导的误差。一个均衡良好的模拟目标通常是使 $ r \\approx 1 $。\n\n实现过程是为四个指定的测试案例系统地执行这整个程序。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm, lu_factor, lu_solve\n\ndef solve():\n    \"\"\"\n    Solves the numerical analysis problem for the 1D heat equation.\n    \n    This function iterates through a suite of test cases, performing for each:\n    1. Spatial discretization using the Method of Lines.\n    2. Calculation of exact, semi-discrete, and numerical solutions.\n    3. Temporal refinement study to find the order of convergence.\n    4. Calculation of spatial and temporal error metrics.\n    5. Reporting of the observed order and the ratio of temporal to spatial error.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'name': 'A', 'scheme': 'fe', 'L': 1.0, 'alpha': 1e-4, 'N': 50, 'tf': 10.0, 'r0': 0.4},\n        {'name': 'B', 'scheme': 'be', 'L': 1.0, 'alpha': 1e-4, 'N': 50, 'tf': 30.0, 'r0': 4.0},\n        {'name': 'C', 'scheme': 'cn', 'L': 1.0, 'alpha': 1e-4, 'N': 50, 'tf': 30.0, 'r0': 1.0},\n        {'name': 'D', 'scheme': 'fe', 'L': 1.0, 'alpha': 1e-4, 'N': 50, 'tf': 10.0, 'r0': 0.49},\n    ]\n\n    # Global constants\n    Theta = 1.0  # K\n\n    final_results = []\n\n    for case in test_cases:\n        # Unpack parameters for the current case\n        scheme_type = case['scheme']\n        L = case['L']\n        alpha = case['alpha']\n        N = case['N']\n        tf = case['tf']\n        r0 = case['r0']\n\n        # 1. Spatial Discretization\n        dx = L / (N + 1)\n        x_grid = np.linspace(dx, L - dx, N)\n\n        # Construct the discrete Laplacian matrix A\n        main_diag = -2.0 * np.ones(N)\n        off_diag = np.ones(N - 1)\n        A = (alpha / dx**2) * (np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1))\n\n        # Initial Condition vector\n        u0 = Theta * np.sin(np.pi * x_grid / L)\n\n        # 2. Reference Solutions\n        # Continuous exact solution sampled on the grid\n        u_ex_tf = Theta * np.sin(np.pi * x_grid / L) * np.exp(-alpha * (np.pi**2 / L**2) * tf)\n        \n        # Semi-discrete exact solution using matrix exponential\n        u_sd_tf = expm(A * tf) @ u0\n\n        # Helper for discrete L2 norm\n        def norm_l2_dx(v, delta_x):\n            return np.sqrt(np.sum(v**2) * delta_x)\n\n        # 3. Error Quantification\n        # Spatial Discretization Error\n        E_spat = norm_l2_dx(u_sd_tf - u_ex_tf, dx)\n\n        # 4. Temporal Refinement Study\n        temporal_errors = []\n        adjusted_dts = []\n        \n        dt_base = r0 * dx**2 / alpha\n        dt_refinements = [dt_base, dt_base / 2.0, dt_base / 4.0]\n\n        for dt_nominal in dt_refinements:\n            # Adjust time step to reach tf exactly\n            if dt_nominal > 0 and tf > 0:\n                num_steps = int(np.round(tf / dt_nominal))\n                if num_steps == 0: num_steps = 1\n            else:\n                num_steps = 1\n            \n            dt_adj = tf / num_steps\n            adjusted_dts.append(dt_adj)\n            \n            u_num = np.copy(u0)\n\n            # Time integration loop\n            if scheme_type == 'fe':\n                op = np.eye(N) + dt_adj * A\n                for _ in range(num_steps):\n                    u_num = op @ u_num\n            elif scheme_type == 'be':\n                mat = np.eye(N) - dt_adj * A\n                lu, piv = lu_factor(mat)\n                for _ in range(num_steps):\n                    u_num = lu_solve((lu, piv), u_num)\n            elif scheme_type == 'cn':\n                mat_lhs = np.eye(N) - (dt_adj / 2.0) * A\n                mat_rhs = np.eye(N) + (dt_adj / 2.0) * A\n                lu, piv = lu_factor(mat_lhs)\n                for _ in range(num_steps):\n                    b = mat_rhs @ u_num\n                    u_num = lu_solve((lu, piv), b)\n\n            # Compute and store temporal error for this time step\n            E_temp = norm_l2_dx(u_num - u_sd_tf, dx)\n            temporal_errors.append(E_temp)\n            \n        # 5. Final Analysis\n        # Observed temporal order of convergence\n        E_temp1, E_temp2 = temporal_errors[1], temporal_errors[2]\n        dt1_adj, dt2_adj = adjusted_dts[1], adjusted_dts[2]\n        \n        if E_temp2 > 0 and E_temp1 > E_temp2 and dt1_adj / dt2_adj > 1:\n            p_obs = np.log(E_temp1 / E_temp2) / np.log(dt1_adj / dt2_adj)\n        else:\n            p_obs = np.nan # Fallback, should not be reached\n\n        # Ratio of temporal to spatial error at the finest time step\n        r = temporal_errors[2] / E_spat if E_spat > 0 else np.inf\n        \n        final_results.extend([p_obs, r])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        }
    ]
}