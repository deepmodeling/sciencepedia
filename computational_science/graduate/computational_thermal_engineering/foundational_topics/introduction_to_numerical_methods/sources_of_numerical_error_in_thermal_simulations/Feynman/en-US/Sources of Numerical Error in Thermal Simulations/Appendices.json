{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of reliable computational work is verification: ensuring your code correctly solves the mathematical equations it is designed to model. This first exercise introduces the Method of Manufactured Solutions (MMS), a powerful technique for quantifying discretization error. By prescribing an exact analytical solution, we can precisely measure how the error in our numerical approximation decreases as the grid is refined, allowing us to verify that our implementation achieves its theoretical order of accuracy .",
            "id": "3984849",
            "problem": "Consider one-dimensional steady conduction with constant thermal conductivity, governed by the partial differential equation (PDE) $- \\dfrac{d^2 T}{dx^2} = q(x)$ on the domain $x \\in [0,1]$ with Dirichlet boundary conditions $T(0) = 0$ and $T(1) = 0$. Let the exact solution be $T(x) = \\sin(\\pi x)$. To ensure that $T(x)$ is the exact solution of the PDE, take the source term to be $q(x) = \\pi^2 \\sin(\\pi x)$. The quantity of interest is the discretization error induced by a second-order uniform-mesh finite difference approximation of the Laplacian.\n\nUse a uniform mesh of $N$ cells, which implies a mesh spacing $h = 1/N$ and interior node indices $i = 1, 2, \\dots, N-1$ located at $x_i = i h$. Discretize the operator $- \\dfrac{d^2 T}{dx^2}$ at interior nodes using the standard second-order central difference stencil with Dirichlet boundary conditions, yielding a tridiagonal linear system for the discrete solution values at interior nodes. Assemble and solve this discrete system to obtain a numerical approximation $T_h(x_i)$ at each interior node $x_i$.\n\nDefine the pointwise discretization error at interior nodes as $e_i = T_h(x_i) - T(x_i)$ and compute the discrete Lebesgue two-norm (L2) of the error,\n$$\n\\|e\\|_{2,h} = \\sqrt{h \\sum_{i=1}^{N-1} e_i^2},\n$$\nwhich serves as a consistent approximation to the continuous $L_2$ norm on $[0,1]$. In addition, quantify the empirical convergence rate between successive mesh refinements by computing, for any pair of consecutive doubling meshes $(N, 2N)$,\n$$\np(N,2N) = \\frac{\\log\\left(\\|e\\|_{2,h_{2N}} / \\|e\\|_{2,h_N}\\right)}{\\log(1/2)}.\n$$\nThis $p(N,2N)$ characterizes the scaling of the discrete $L_2$ error with respect to $N$ for the chosen numerical scheme and problem.\n\nYour program must:\n- Construct and solve the discrete finite difference system for each specified $N$.\n- Compute $\\|e\\|_{2,h}$ for each $N$ using the above definition.\n- Compute $p(N,2N)$ for all available successive doubling pairs present in the test suite.\n\nNo physical units are required; all quantities are dimensionless. Angles are in radians because $\\pi$ appears as the angular frequency in the exact solution $T(x) = \\sin(\\pi x)$.\n\nTest suite:\n- Use the following set of mesh sizes: $N \\in \\{2, 3, 4, 8, 16, 32, 64\\}$.\n- Compute the corresponding errors $\\|e\\|_{2,h}$ for each $N$ in the listed order.\n- Compute the observed orders $p(N,2N)$ for the consecutive doubling pairs $(4, 8)$, $(8, 16)$, $(16, 32)$, and $(32, 64)$.\n\nFinal output format:\n- Your program should produce a single line of output containing two lists enclosed in a single pair of square brackets. The first list contains the errors $\\|e\\|_{2,h}$ for $N \\in \\{2, 3, 4, 8, 16, 32, 64\\}$ in that order. The second list contains the observed orders $p(N,2N)$ for the four consecutive doubling pairs $(4, 8)$, $(8, 16)$, $(16, 32)$, and $(32, 64)$. For example, the output structure must be of the form $[[\\text{error}_{N=2}, \\dots, \\text{error}_{N=64}], [p(4,8), p(8,16), p(16,32), p(32,64)]]$.",
            "solution": "The problem requires the numerical solution of the one-dimensional Poisson equation using a second-order finite difference method and a subsequent analysis of the discretization error and its convergence rate.\n\nThe governing partial differential equation (PDE) is given by:\n$$\n- \\frac{d^2 T}{dx^2} = q(x)\n$$\non the domain $x \\in [0, 1]$. The problem is supplemented with homogeneous Dirichlet boundary conditions:\n$$\nT(0) = 0 \\quad \\text{and} \\quad T(1) = 0\n$$\nTo facilitate error analysis, a manufactured solution is specified as $T(x) = \\sin(\\pi x)$. To ensure this function satisfies the PDE, the source term $q(x)$ must be chosen accordingly. Differentiating the exact solution twice yields:\n$$\n\\frac{dT}{dx} = \\pi \\cos(\\pi x) \\quad \\implies \\quad \\frac{d^2 T}{dx^2} = -\\pi^2 \\sin(\\pi x)\n$$\nSubstituting this into the PDE gives the required source term:\n$$\n- (-\\pi^2 \\sin(\\pi x)) = q(x) \\quad \\implies \\quad q(x) = \\pi^2 \\sin(\\pi x)\n$$\nThe provided boundary conditions are also satisfied by the manufactured solution, as $T(0) = \\sin(0) = 0$ and $T(1) = \\sin(\\pi) = 0$.\n\nTo solve this problem numerically, we discretize the domain $[0, 1]$ using a uniform mesh of $N$ cells. This creates $N+1$ nodes located at $x_i = i h$ for $i = 0, 1, \\dots, N$, where the mesh spacing is $h = 1/N$. The numerical solution, denoted $T_{h,i}$, will be computed at the $N-1$ interior nodes, i.e., for $i = 1, 2, \\dots, N-1$.\n\nThe second derivative operator, $-d^2T/dx^2$, is approximated at each interior node $x_i$ using a second-order accurate central difference stencil. The Taylor series expansions for $T(x_{i+1})$ and $T(x_{i-1})$ around $x_i$ lead to the approximation:\n$$\n\\left. \\frac{d^2 T}{dx^2} \\right|_{x_i} = \\frac{T(x_{i+1}) - 2T(x_i) + T(x_{i-1})}{h^2} + \\mathcal{O}(h^2)\n$$\nSubstituting this into the governing PDE for the numerical solution $T_{h,i}$ gives the finite difference equation at each interior node $i$:\n$$\n- \\frac{T_{h,i+1} - 2T_{h,i} + T_{h,i-1}}{h^2} = q(x_i)\n$$\nRearranging this equation provides a relation for the unknowns at the interior nodes:\n$$\n-T_{h,i-1} + 2T_{h,i} - T_{h,i+1} = h^2 q(x_i) \\quad \\text{for } i = 1, 2, \\dots, N-1\n$$\nThe boundary conditions $T_{h,0} = T(0) = 0$ and $T_{h,N} = T(1) = 0$ are incorporated at the first ($i=1$) and last ($i=N-1$) interior nodes:\nFor $i=1$: $-T_{h,0} + 2T_{h,1} - T_{h,2} = h^2 q(x_1) \\implies 2T_{h,1} - T_{h,2} = h^2 q(x_1)$.\nFor $i=N-1$: $-T_{h,N-2} + 2T_{h,N-1} - T_{h,N} = h^2 q(x_{N-1}) \\implies -T_{h,N-2} + 2T_{h,N-1} = h^2 q(x_{N-1})$.\n\nThese $N-1$ linear equations can be expressed in matrix form as $A \\mathbf{T}_h = \\mathbf{b}$, where:\n- $\\mathbf{T}_h = [T_{h,1}, T_{h,2}, \\dots, T_{h,N-1}]^T$ is the vector of unknown solution values.\n- $A$ is an $(N-1) \\times (N-1)$ symmetric, positive-definite, tridiagonal matrix:\n$$\nA = \\begin{pmatrix}\n2 & -1 & 0 & \\dots & 0 \\\\\n-1 & 2 & -1 & \\dots & 0 \\\\\n0 & \\ddots & \\ddots & \\ddots & 0 \\\\\n\\vdots & \\dots & -1 & 2 & -1 \\\\\n0 & \\dots & 0 & -1 & 2\n\\end{pmatrix}\n$$\n- $\\mathbf{b}$ is the right-hand side vector of size $N-1$, with components $b_i = h^2 q(x_i) = h^2 \\pi^2 \\sin(\\pi x_i) = h^2 \\pi^2 \\sin(\\pi i h)$.\n\nThe procedure for solving the problem is as follows:\n1.  For each specified mesh size $N$, construct the matrix $A$ and the vector $\\mathbf{b}$.\n2.  Solve the linear system $A \\mathbf{T}_h = \\mathbf{b}$ to obtain the numerical solution $\\mathbf{T}_h$.\n3.  Calculate the pointwise error vector $\\mathbf{e}$, where each component is $e_i = T_{h,i} - T(x_i)$ for $i=1, \\dots, N-1$.\n4.  Compute the discrete Lebesgue two-norm (L2 norm) of the error using the given formula:\n    $$\n    \\|e\\|_{2,h} = \\sqrt{h \\sum_{i=1}^{N-1} e_i^2}\n    $$\n5.  After calculating the errors for all required $N$, determine the empirical order of convergence $p$ for pairs of successively refined meshes $(N, 2N)$. The error for a $p$-th order scheme scales with the mesh size $h$ as $\\|e\\|_{2,h} \\approx C h^p$, where $C$ is a constant. For two meshes with sizes $h_N = 1/N$ and $h_{2N} = 1/(2N)$, we have the ratio:\n    $$\n    \\frac{\\|e\\|_{2,h_{2N}}}{\\|e\\|_{2,h_N}} \\approx \\frac{C h_{2N}^p}{C h_N^p} = \\left(\\frac{h_{2N}}{h_N}\\right)^p = \\left(\\frac{1/2N}{1/N}\\right)^p = \\left(\\frac{1}{2}\\right)^p\n    $$\n    Solving for $p$ by taking the logarithm gives the formula for the observed order of convergence:\n    $$\n    p(N,2N) = \\frac{\\log\\left(\\|e\\|_{2,h_{2N}} / \\|e\\|_{2,h_N}\\right)}{\\log(1/2)}\n    $$\n    Since the central difference scheme is second-order accurate, we expect $p(N,2N)$ to approach $2$ as $N$ increases.\n\nThis entire process is implemented for the set of mesh sizes $N \\in \\{2, 3, 4, 8, 16, 32, 64\\}$ to generate the required error norms and convergence rates.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Solves the 1D Poisson equation using a finite difference method,\n    computes the L2 error norm, and estimates the convergence rate.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = {\n        'N_values': [2, 3, 4, 8, 16, 32, 64],\n        'rate_pairs': [(4, 8), (8, 16), (16, 32), (32, 64)]\n    }\n\n    N_values = test_cases['N_values']\n    rate_pairs = test_cases['rate_pairs']\n    \n    errors = {}\n\n    for N in N_values:\n        # 1. Setup mesh and grid parameters\n        h = 1.0 / N\n        num_interior_nodes = N - 1\n        \n        # If there are no interior nodes (e.g., N=1), there is nothing to solve.\n        if num_interior_nodes == 0:\n            errors[N] = 0.0\n            continue\n\n        # Interior node locations\n        x_i = np.arange(1, N) * h\n\n        # 2. Construct the tridiagonal linear system A*T_h = b\n        \n        # The matrix A is represented in a banded format for scipy.linalg.solve_banded.\n        # For a tridiagonal matrix with diagonals at -1, 0, 1, the shape is (3, num_interior_nodes).\n        # Row 0: Super-diagonal (u=1)\n        # Row 1: Main diagonal\n        # Row 2: Sub-diagonal (l=1)\n        ab = np.zeros((3, num_interior_nodes))\n        ab[0, 1:] = -1.0\n        ab[1, :] = 2.0\n        ab[2, :-1] = -1.0\n\n        # Construct the right-hand side vector b\n        # q(x) = pi^2 * sin(pi*x)\n        # b_i = h^2 * q(x_i)\n        q_i = np.pi**2 * np.sin(np.pi * x_i)\n        b = h**2 * q_i\n\n        # 3. Solve the linear system\n        # The (l, u) tuple is (1, 1) for a tridiagonal matrix\n        T_h = solve_banded((1, 1), ab, b)\n        \n        # 4. Compute the error\n        # Exact solution T(x) = sin(pi*x)\n        T_exact = np.sin(np.pi * x_i)\n        \n        # Pointwise error e_i = T_h(x_i) - T(x_i)\n        e_i = T_h - T_exact\n        \n        # Discrete L2 norm of the error\n        # ||e||_{2,h} = sqrt(h * sum(e_i^2))\n        l2_error_norm = np.sqrt(h * np.sum(e_i**2))\n        \n        errors[N] = l2_error_norm\n        \n    # 5. Compute empirical convergence rates\n    rates = []\n    for n1, n2 in rate_pairs:\n        error1 = errors[n1]\n        error2 = errors[n2]\n        # p = log(||e_2N|| / ||e_N||) / log(1/2)\n        rate = np.log(error2 / error1) / np.log(0.5)\n        rates.append(rate)\n\n    # 6. Format the final output\n    error_list = [errors[N] for N in N_values]\n    \n    # Final print statement in the exact required format.\n    print(f\"[[{','.join(map(str, error_list))}],[{','.join(map(str, rates))}]]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While finite differences are conceptually straightforward, many practical thermal codes utilize the Finite Volume Method (FVM) for its inherent conservation properties, especially in cases with spatially varying material properties. A key challenge in FVM is approximating quantities like thermal conductivity $k(x)$ at the faces between control volumes. This practice explores how different common interpolation schemes impact the consistency of the diffusive flux calculation and demonstrates how to measure their respective orders of accuracy .",
            "id": "3984847",
            "problem": "Consider one-dimensional, steady heat conduction without sources over the nondimensional domain $[0,1]$, governed by Fourier’s law $q(x)=-k(x)\\,\\frac{dT}{dx}(x)$ and the conservation statement that the net diffusive flux across a control volume vanishes in the absence of internal generation. The thermal conductivity is spatially varying and given by $k(x)=1+x$. A uniform grid with $N$ cells partitions the domain, with cell centers at $x_i=(i-\\frac{1}{2})\\Delta x$ for $i\\in\\{1,2,\\dots,N\\}$, faces at $x_{i+\\frac{1}{2}}=i\\,\\Delta x$ for $i\\in\\{1,2,\\dots,N-1\\}$, and $\\Delta x=\\frac{1}{N}$. The exact temperature field is the smooth function $T(x)=\\sin(\\pi x)$.\n\nDefine the approximate diffusive flux at an interior face $x_{i+\\frac{1}{2}}$ by the finite volume face formula\n$$\\tilde{q}_{i+\\frac{1}{2}}=-\\hat{k}_{i+\\frac{1}{2}}\\left(\\frac{T_{i+1}-T_i}{\\Delta x}\\right),$$\nwhere $T_i=T(x_i)$ and $T_{i+1}=T(x_{i+1})$, and $\\hat{k}_{i+\\frac{1}{2}}$ is an approximation of the conductivity at the face. Consider the following three conductivity approximations:\n- Scheme S1 (Arithmetic average of cell-centered conductivity): $\\hat{k}_{i+\\frac{1}{2}}=\\frac{k(x_i)+k(x_{i+1})}{2}$.\n- Scheme S2 (Exact face conductivity): $\\hat{k}_{i+\\frac{1}{2}}=k(x_{i+\\frac{1}{2}})$.\n- Scheme S3 (Harmonic average of cell-centered conductivity): $\\hat{k}_{i+\\frac{1}{2}}=\\frac{2\\,k(x_i)\\,k(x_{i+1})}{k(x_i)+k(x_{i+1})}$.\n\nThe exact face diffusive flux is\n$$q(x_{i+\\frac{1}{2}})=-k(x_{i+\\frac{1}{2}})\\,T'(x_{i+\\frac{1}{2}}),$$\nwith $T'(x)=\\pi\\cos(\\pi x)$. For each interior face, define the consistency error of the flux approximation by\n$$e_{i+\\frac{1}{2}}=\\tilde{q}_{i+\\frac{1}{2}}-q(x_{i+\\frac{1}{2}}).$$\nDefine the global face-based error norm by the discrete $L^2$ norm\n$$E(N;\\text{scheme})=\\left(\\frac{1}{N-1}\\sum_{i=1}^{N-1}e_{i+\\frac{1}{2}}^2\\right)^{1/2}.$$\nGiven two uniform grids with $N_{\\text{coarse}}$ and $N_{\\text{fine}}=2\\,N_{\\text{coarse}}$, define the observed convergence order\n$$p=\\frac{\\log\\left(\\frac{E(N_{\\text{coarse}};\\text{scheme})}{E(N_{\\text{fine}};\\text{scheme})}\\right)}{\\log(2)}.$$\n\nTask: Construct the finite volume face flux approximation as specified above for the three schemes S1, S2, and S3, compute the consistency error at all interior faces, aggregate it with the discrete $L^2$ norm, and compute the observed order $p$ on grid pairs. All quantities are nondimensional.\n\nYour program must implement the above logic and produce the observed order $p$ for each case in the following test suite:\n- Test $1$: Scheme S1 with $N_{\\text{coarse}}=20$ and $N_{\\text{fine}}=40$.\n- Test $2$: Scheme S2 with $N_{\\text{coarse}}=20$ and $N_{\\text{fine}}=40$.\n- Test $3$: Scheme S3 with $N_{\\text{coarse}}=20$ and $N_{\\text{fine}}=40$.\n- Test $4$ (edge case, very coarse grids): Scheme S2 with $N_{\\text{coarse}}=2$ and $N_{\\text{fine}}=4$.\n- Test $5$ (additional coverage): Scheme S3 with $N_{\\text{coarse}}=10$ and $N_{\\text{fine}}=20$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of Tests $1$ through $5$, for example, $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5\\right]$. Each $\\text{result}_j$ must be a floating-point number.",
            "solution": "The user-provided problem has been validated and is sound. It is a well-posed, scientifically grounded exercise in numerical analysis, specifically focusing on the consistency error of finite volume approximations for heat conduction.\n\nThe objective is to determine the observed order of convergence for three different finite volume flux approximation schemes. This analysis is conducted for one-dimensional, steady-state heat conduction in a nondimensional domain $[0, 1]$, governed by Fourier's Law. The problem is a classic example of the method of manufactured solutions, where an exact temperature field is presumed to verify the accuracy of a numerical discretization.\n\nThe governing equation for the diffusive heat flux is Fourier's Law:\n$$q(x) = -k(x) \\frac{dT}{dx}(x)$$\nThe thermal conductivity is given as a spatially varying linear function $k(x) = 1+x$, and the exact temperature profile is a smooth function $T(x) = \\sin(\\pi x)$. The first derivative of the temperature is $T'(x) = \\pi \\cos(\\pi x)$. Substituting these into Fourier's law yields the exact analytical expression for the heat flux:\n$$q(x) = -(1+x) \\pi \\cos(\\pi x)$$\n\nThe domain $[0, 1]$ is partitioned into a uniform grid of $N$ cells, each of width $\\Delta x = 1/N$. The cell centers are located at $x_i = (i - 1/2)\\Delta x$ for $i \\in \\{1, 2, \\dots, N\\}$, and the faces between adjacent cells are at $x_{i+1/2} = i\\Delta x$ for $i \\in \\{1, \\dots, N-1\\}$.\n\nIn the finite volume method, the flux across an interior cell face $x_{i+1/2}$ is approximated. The general formula for this approximate flux, $\\tilde{q}_{i+1/2}$, is:\n$$\\tilde{q}_{i+\\frac{1}{2}} = -\\hat{k}_{i+\\frac{1}{2}} \\left( \\frac{T_{i+1} - T_i}{\\Delta x} \\right)$$\nHere, $T_i = T(x_i)$ and $T_{i+1} = T(x_{i+1})$ are the exact temperatures at the centers of the cells adjacent to the face. The term $\\frac{T_{i+1} - T_i}{\\Delta x}$ is a second-order accurate central difference approximation of the temperature gradient $dT/dx$ at the face location $x_{i+1/2}$. The term $\\hat{k}_{i+1/2}$ is an approximation of the thermal conductivity at the same face. The problem specifies three schemes for this approximation:\n\n$1$. **Scheme S1 (Arithmetic Mean):** $\\hat{k}_{i+\\frac{1}{2}} = \\frac{k(x_i) + k(x_{i+1})}{2}$\n$2$. **Scheme S2 (Exact Face Value):** $\\hat{k}_{i+\\frac{1}{2}} = k(x_{i+\\frac{1}{2}})$\n$3$. **Scheme S3 (Harmonic Mean):** $\\hat{k}_{i+\\frac{1}{2}} = \\frac{2k(x_i)k(x_{i+1})}{k(x_i) + k(x_{i+1})}$\n\nA key observation arises from the linearity of the given conductivity function, $k(x)=1+x$. The arithmetic mean of conductivity at two cell centers, $x_i$ and $x_{i+1}$, is exactly equal to the conductivity at the midpoint, which is the face location $x_{i+1/2}$.\n$$\\hat{k}_{i+\\frac{1}{2}}^{S1} = \\frac{k(x_i) + k(x_{i+1})}{2} = \\frac{(1 + (i-1/2)\\Delta x) + (1 + (i+1/2)\\Delta x)}{2} = \\frac{2 + 2i\\Delta x}{2} = 1 + i\\Delta x = k(i\\Delta x) = k(x_{i+\\frac{1}{2}})$$\nThus, for this specific problem, Scheme S1 and Scheme S2 are mathematically identical. Their computed errors and convergence orders will be identical.\n\nThe local consistency error for each interior face is defined as the difference between the approximate and exact fluxes:\n$$e_{i+\\frac{1}{2}} = \\tilde{q}_{i+\\frac{1}{2}} - q(x_{i+\\frac{1}{2}})$$\nThe global error is quantified by a discrete $L^2$ norm, which aggregates the local errors across all $N-1$ interior faces:\n$$E(N; \\text{scheme}) = \\left( \\frac{1}{N-1} \\sum_{i=1}^{N-1} e_{i+\\frac{1}{2}}^2 \\right)^{1/2}$$\nTo determine the rate at which this error decreases as the grid is refined, we compute the observed order of convergence, $p$. This is calculated using the errors from a coarse grid ($N_{\\text{coarse}}$) and a fine grid ($N_{\\text{fine}} = 2N_{\\text{coarse}}$):\n$$p = \\frac{\\log\\left( \\frac{E(N_{\\text{coarse}};\\text{scheme})}{E(N_{\\text{fine}};\\text{scheme})} \\right)}{\\log(2)}$$\nA value of $p \\approx 2$ indicates that the scheme is second-order accurate, meaning the error decreases by a factor of approximately $4$ when the grid spacing is halved.\n\nThe computational procedure is as follows:\nFirst, a function `compute_global_error(N, scheme)` is implemented. For a given grid size $N$ and scheme, it performs these steps:\n$1$. It defines the grid geometry: $\\Delta x$, cell center locations $x_i$, and face locations $x_{i+1/2}$.\n$2$. It computes the vector of exact fluxes, $q(x_{i+1/2})$, at all interior faces.\n$3$. It computes the vector of approximate fluxes, $\\tilde{q}_{i+1/2}$, for the chosen scheme. This involves evaluating $T(x)$ and $k(x)$ at the necessary cell center locations and applying the corresponding formula for $\\hat{k}_{i+1/2}$.\n$4$. It calculates the vector of local consistency errors, $e_{i+1/2}$.\n$5$. It computes and returns the global error norm $E(N)$.\n\nNext, for each test case defined in the problem, this function is called twice: once for $N_{\\text{coarse}}$ and once for $N_{\\text{fine}}$. The resulting errors, $E_{\\text{coarse}}$ and $E_{\\text{fine}}$, are used to calculate the observed order of convergence $p$. The results for all test cases are then collected and presented. All three schemes are expected to demonstrate second-order accuracy, but with different error magnitudes.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of computing the observed convergence order for three\n    finite volume flux approximation schemes.\n    \"\"\"\n\n    def compute_global_error(N: int, scheme: str) -> float:\n        \"\"\"\n        Computes the discrete L2 norm of the flux consistency error for a given\n        grid size N and approximation scheme.\n\n        Args:\n            N: The number of cells in the uniform grid.\n            scheme: A string identifier for the scheme ('S1', 'S2', or 'S3').\n\n        Returns:\n            The global error norm E(N).\n        \"\"\"\n        if N <= 1:\n            # There are no interior faces for N=1. The problem is defined for N>=2.\n            # Returning NaN or raising an error are options. Returning a large number\n            # is a pragmatic choice to indicate non-convergence if used improperly.\n            # However, given problem constraints, N is at least 2.\n            raise ValueError(\"Number of cells N must be greater than 1.\")\n        \n        # 1. Define grid and exact functions\n        delta_x = 1.0 / N\n        k_func = lambda x: 1.0 + x\n        T_func = lambda x: np.sin(np.pi * x)\n        T_prime_func = lambda x: np.pi * np.cos(np.pi * x)\n\n        # 2. Define grid points\n        # Interior faces are indexed i=1, ..., N-1.\n        # Face i+1/2 is at x = i * delta_x.\n        i_face = np.arange(1, N, dtype=float)\n        x_faces = i_face * delta_x\n\n        # Cell centers relevant to these faces.\n        # For face i+1/2, we need centers of cell i and cell i+1.\n        # x_i corresponds to x_centers[i_face-1]\n        # x_{i+1} corresponds to x_centers[i_face]\n        i_cell = np.arange(1, N + 1, dtype=float)\n        x_centers = (i_cell - 0.5) * delta_x\n\n        # 3. Calculate exact flux at interior faces\n        q_exact = -k_func(x_faces) * T_prime_func(x_faces)\n\n        # 4. Calculate approximate flux\n        # Temperatures at cell centers surrounding each face\n        T_i = T_func(x_centers[i_face.astype(int) - 1])\n        T_i_plus_1 = T_func(x_centers[i_face.astype(int)])\n\n        # Conductivities at cell centers\n        k_i = k_func(x_centers[i_face.astype(int) - 1])\n        k_i_plus_1 = k_func(x_centers[i_face.astype(int)])\n\n        # Interpolated conductivity at faces\n        if scheme == 'S1':\n            # Arithmetic average of cell-centered conductivity\n            k_hat = (k_i + k_i_plus_1) / 2.0\n        elif scheme == 'S2':\n            # Exact face conductivity\n            k_hat = k_func(x_faces)\n        elif scheme == 'S3':\n            # Harmonic average of cell-centered conductivity\n            k_hat = 2.0 * k_i * k_i_plus_1 / (k_i + k_i_plus_1)\n        else:\n            raise ValueError(f\"Unknown scheme: {scheme}\")\n\n        # Approximate temperature gradient\n        grad_T_approx = (T_i_plus_1 - T_i) / delta_x\n        \n        # Approximate flux\n        q_approx = -k_hat * grad_T_approx\n\n        # 5. Compute error\n        # Local consistency error at each face\n        e_faces = q_approx - q_exact\n\n        # Global L2 error norm\n        sum_sq_error = np.sum(e_faces**2)\n        global_error = np.sqrt(sum_sq_error / (N - 1))\n        \n        return global_error\n\n    def calculate_p(scheme: str, N_coarse: int, N_fine: int) -> float:\n        \"\"\"\n        Calculates the observed order of convergence p.\n        \"\"\"\n        E_coarse = compute_global_error(N_coarse, scheme)\n        E_fine = compute_global_error(N_fine, scheme)\n        \n        # Definition of p requires the ratio of errors.\n        # If E_fine is zero, it implies perfect accuracy or underflow.\n        if E_fine == 0.0:\n            return np.inf if E_coarse > 0.0 else 0.0 # Or another indicator of exceptional convergence\n\n        ratio = E_coarse / E_fine\n        p = np.log(ratio) / np.log(2.0)\n        return p\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ('S1', 20, 40),\n        ('S2', 20, 40),\n        ('S3', 20, 40),\n        ('S2', 2, 4),\n        ('S3', 10, 20),\n    ]\n\n    results = []\n    for case in test_cases:\n        scheme, N_c, N_f = case\n        p_val = calculate_p(scheme, N_c, N_f)\n        results.append(p_val)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Transient simulations introduce another dimension of complexity: time. The total numerical error in a time-dependent problem is a combination of spatial and temporal discretization errors, and understanding their individual contributions is critical for efficient and accurate modeling. This exercise uses the Method of Lines (MOL) to isolate these error sources, allowing you to perform a temporal refinement study to verify the order of your time integration scheme and quantify its error relative to the underlying spatial error .",
            "id": "3984856",
            "problem": "Consider one-dimensional heat conduction governed by the energy balance and Fourier conduction law, which for constant material properties yields the partial differential equation (PDE) $ \\rho c \\frac{\\partial T}{\\partial t} = k \\frac{\\partial^2 T}{\\partial x^2} $, where $ \\rho $ is mass density, $ c $ is specific heat capacity, $ k $ is thermal conductivity, and $ T(x,t) $ is temperature. Introducing thermal diffusivity $ \\alpha = \\frac{k}{\\rho c} $, the PDE becomes $ \\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2} $. On the spatial interval $ x \\in [0,L] $ with homogeneous Dirichlet boundary conditions $ T(0,t) = T(L,t) = T_{\\text{ref}} $ and an initial deviation $ u(x,0) = T(x,0) - T_{\\text{ref}} = \\Theta \\sin\\left(\\frac{\\pi x}{L}\\right) $, the exact temperature deviation $ u(x,t) = T(x,t) - T_{\\text{ref}} $ is analytically known and given by $ u(x,t) = \\Theta \\sin\\left(\\frac{\\pi x}{L}\\right) \\exp\\left(-\\alpha \\frac{\\pi^2}{L^2} t\\right) $. Assume $ T_{\\text{ref}} $ and $ \\Theta $ are constants.\n\nLet $ N $ be the number of interior spatial grid points and $ \\Delta x = \\frac{L}{N+1} $. Consider the method of lines (MOL) spatial semi-discretization using the second-order centered finite difference approximation for the second derivative under homogeneous Dirichlet boundary conditions. This yields a linear ordinary differential equation (ODE) system $ \\frac{d\\mathbf{u}}{dt} = \\mathbf{A}\\mathbf{u} $, where $ \\mathbf{u}(t) \\in \\mathbb{R}^N $ collects nodal values of $ u(x,t) $ at interior points $ x_i = i \\Delta x $ for $ i = 1,2,\\dots,N $, and $ \\mathbf{A} \\in \\mathbb{R}^{N \\times N} $ is the discrete Laplacian scaled by $ \\alpha $. The semi-discrete exact solution is $ \\mathbf{u}_{\\text{sd}}(t) = \\exp(\\mathbf{A} t) \\mathbf{u}_0 $, where $ \\mathbf{u}_0 $ is the discretized initial condition and $ \\exp(\\cdot) $ denotes the matrix exponential.\n\nAt fixed spatial resolution (fixed $ N $ and $ \\Delta x $), perform temporal refinement for three time integration schemes: forward Euler (explicit first-order), backward Euler (implicit first-order), and Crank–Nicolson (implicit second-order trapezoidal). For each scheme, use a sequence of three time steps $ \\Delta t_0 $, $ \\Delta t_1 = \\frac{1}{2} \\Delta t_0 $, and $ \\Delta t_2 = \\frac{1}{2} \\Delta t_1 $ to reach a prescribed final time $ t_f $. For each $ \\Delta t $, compute the numerical solution $ \\mathbf{u}_{\\text{num}}(t_f) $ and the semi-discrete exact $ \\mathbf{u}_{\\text{sd}}(t_f) $, then compute the temporal discretization error $ E_{\\text{temp}}(\\Delta t) $ using the discrete $ L^2 $ norm defined by $ \\lVert \\mathbf{e} \\rVert_{2,\\Delta x} = \\left( \\sum_{i=1}^{N} e_i^2 \\Delta x \\right)^{1/2} $, where $ \\mathbf{e} = \\mathbf{u}_{\\text{num}}(t_f) - \\mathbf{u}_{\\text{sd}}(t_f) $. Also compute the spatial discretization error at $ t_f $ as $ E_{\\text{spat}} = \\lVert \\mathbf{u}_{\\text{sd}}(t_f) - \\mathbf{u}_{\\text{ex}}(t_f) \\rVert_{2,\\Delta x} $, where $ \\mathbf{u}_{\\text{ex}}(t_f) $ is the exact continuous solution $ u(x,t_f) $ sampled on the grid $ x_i $.\n\nFor each scheme and its refinement sequence, determine the observed temporal order $ p_{\\text{obs}} $ using two successive refinements via $ p_{\\text{obs}} = \\frac{\\log\\left( \\frac{E_{\\text{temp}}(\\Delta t_1)}{E_{\\text{temp}}(\\Delta t_2)} \\right)}{\\log\\left( \\frac{\\Delta t_1}{\\Delta t_2} \\right)} $. Report, for each scheme, the pair $ (p_{\\text{obs}}, r) $ where $ r = \\frac{E_{\\text{temp}}(\\Delta t_2)}{E_{\\text{spat}}} $ quantifies the relative magnitude of temporal to spatial error at the finest time step. All error magnitudes must be expressed in Kelvin (K), since $ u $ and $ T $ are temperatures. Angles in trigonometric functions are in radians.\n\nImplement this experiment for the following test suite of parameter sets. In all cases, use $ T_{\\text{ref}} = 300 \\text{ K} $, $ \\Theta = 1 \\text{ K} $, and the given $ L $, $ \\alpha $, $ N $, and $ t_f $. For forward Euler, choose $ \\Delta t_0 = r_0 \\frac{\\Delta x^2}{\\alpha} $ with the provided $ r_0 $ to respect explicit stability constraints; for backward Euler and Crank–Nicolson, use the same $ \\Delta t_0 $ formula but note that these schemes are unconditionally stable. In all cases, ensure the numerical integration reaches exactly $ t_f $ by using an integer number of steps; if $ t_f / \\Delta t $ is not an integer, adjust the step size to $ \\Delta t' = \\frac{t_f}{n} $ where $ n = \\mathrm{round}\\left(\\frac{t_f}{\\Delta t}\\right) $. Use the adjusted $ \\Delta t' $ in the computation and in the order estimation formula.\n\nTest suite:\n- Case $ A $ (forward Euler, \"happy path\"): $ L = 1 \\text{ m} $, $ \\alpha = 10^{-4} \\text{ m}^2/\\text{s} $, $ N = 50 $, $ t_f = 10 \\text{ s} $, $ r_0 = 0.4 $.\n- Case $ B $ (backward Euler, coarse steps): $ L = 1 \\text{ m} $, $ \\alpha = 10^{-4} \\text{ m}^2/\\text{s} $, $ N = 50 $, $ t_f = 30 \\text{ s} $, $ r_0 = 4.0 $.\n- Case $ C $ (Crank–Nicolson, moderate steps): $ L = 1 \\text{ m} $, $ \\alpha = 10^{-4} \\text{ m}^2/\\text{s} $, $ N = 50 $, $ t_f = 30 \\text{ s} $, $ r_0 = 1.0 $.\n- Case $ D $ (forward Euler, near stability edge): $ L = 1 \\text{ m} $, $ \\alpha = 10^{-4} \\text{ m}^2/\\text{s} $, $ N = 50 $, $ t_f = 10 \\text{ s} $, $ r_0 = 0.49 $.\n\nYour program must:\n- Construct $ \\mathbf{A} $ using the second-order centered finite difference approximation for $ \\frac{\\partial^2}{\\partial x^2} $ with homogeneous Dirichlet boundary conditions and scale by $ \\alpha $.\n- Compute $ \\mathbf{u}_{\\text{sd}}(t_f) = \\exp(\\mathbf{A} t_f) \\mathbf{u}_0 $ for each case using the matrix exponential.\n- Implement the three time integration schemes to compute $ \\mathbf{u}_{\\text{num}}(t_f) $ for each $ \\Delta t $ in the refinement sequence.\n- Compute $ E_{\\text{temp}}(\\Delta t) $ and $ E_{\\text{spat}} $ in Kelvin.\n- Compute $ p_{\\text{obs}} $ and $ r $ as defined.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list order must be $ [p_A, r_A, p_B, r_B, p_C, r_C, p_D, r_D] $, where $ p_A $ and $ r_A $ correspond to Case $ A $, $ p_B $ and $ r_B $ to Case $ B $, etc. Each $ p_{\\text{obs}} $ and $ r $ must be printed as decimal floating-point numbers (no units and no percentage signs).",
            "solution": "The user-provided problem is a valid and well-posed numerical analysis exercise in the field of computational thermal engineering. All parameters, definitions, and procedures are clearly specified, scientifically sound, and computationally feasible. The problem will be solved as stated.\n\nThe core of the problem is to analyze the sources of numerical error in a simulation of the one-dimensional heat equation, $ \\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2} $, by separating the spatial and temporal discretization errors.\n\n### 1. Spatial Discretization: Method of Lines\n\nThe first step is to transform the partial differential equation (PDE) into a system of ordinary differential equations (ODEs) using the Method of Lines (MOL). This is achieved by discretizing the spatial domain $ x \\in [0,L] $ into $ N+2 $ points, with $ N $ interior points $ x_i = i \\Delta x $ for $ i=1, \\dots, N $, where $ \\Delta x = L/(N+1) $. The temperature deviation at these points is denoted by the vector $ \\mathbf{u}(t) = [u_1(t), u_2(t), \\dots, u_N(t)]^T $, where $ u_i(t) = T(x_i, t) - T_{\\text{ref}} $.\n\nThe second spatial derivative $ \\frac{\\partial^2 u}{\\partial x^2} $ at each interior point $ x_i $ is approximated using a second-order accurate central finite difference scheme:\n$$ \\frac{\\partial^2 u}{\\partial x^2} \\bigg|_{x=x_i} \\approx \\frac{u(x_{i-1},t) - 2u(x_i,t) + u(x_{i+1},t)}{\\Delta x^2} = \\frac{u_{i-1}(t) - 2u_i(t) + u_{i+1}(t)}{\\Delta x^2} $$\nThe homogeneous Dirichlet boundary conditions $ T(0,t)=T(L,t)=T_{\\text{ref}} $ imply that $ u_0(t) = 0 $ and $ u_{N+1}(t) = 0 $. Applying the finite difference approximation at each interior node $ i=1, \\dots, N $ yields the linear ODE system:\n$$ \\frac{d\\mathbf{u}}{dt} = \\mathbf{A}\\mathbf{u} $$\nwhere $ \\mathbf{A} \\in \\mathbb{R}^{N \\times N} $ is a constant matrix representing the scaled discrete Laplacian operator. It is a symmetric tridiagonal matrix given by:\n$$ \\mathbf{A} = \\frac{\\alpha}{\\Delta x^2} \n\\begin{pmatrix}\n-2 & 1 & 0 & \\cdots & 0 \\\\\n1 & -2 & 1 & \\cdots & 0 \\\\\n0 & 1 & \\ddots & \\ddots & \\vdots \\\\\n\\vdots & \\ddots & \\ddots & -2 & 1 \\\\\n0 & \\cdots & 0 & 1 & -2\n\\end{pmatrix}\n$$\n\n### 2. Reference Solutions for Error Analysis\n\nTo isolate and quantify the different sources of error, we use three distinct solution vectors at the final time $ t_f $:\n1.  **Exact Analytical Solution ($ \\mathbf{u}_{\\text{ex}} $)**: The continuous analytical solution $ u(x,t) = \\Theta \\sin\\left(\\frac{\\pi x}{L}\\right) \\exp\\left(-\\alpha \\frac{\\pi^2}{L^2} t\\right) $ is evaluated at the grid points $ x_i $ at time $ t_f $. This vector represents the true, error-free solution.\n2.  **Semi-Discrete Exact Solution ($ \\mathbf{u}_{\\text{sd}} $)**: This is the exact solution to the ODE system $ \\frac{d\\mathbf{u}}{dt} = \\mathbf{A}\\mathbf{u} $. It is computed using the matrix exponential as $ \\mathbf{u}_{\\text{sd}}(t_f) = \\exp(\\mathbf{A} t_f) \\mathbf{u}_0 $, where $ \\mathbf{u}_0 $ is the initial condition $ u(x,0) $ sampled at the grid points. This solution is free from temporal error but contains spatial discretization error.\n3.  **Fully Discrete Numerical Solution ($ \\mathbf{u}_{\\text{num}} $)**: This solution is obtained by applying a numerical time integration scheme to the ODE system. It contains both spatial and temporal errors.\n\n### 3. Error Quantification\n\nUsing these reference solutions, we define two key error metrics using the discrete $ L^2 $ norm $ \\lVert \\mathbf{e} \\rVert_{2,\\Delta x} = \\left( \\sum_{i=1}^{N} e_i^2 \\Delta x \\right)^{1/2} $.\n-   **Spatial Discretization Error ($ E_{\\text{spat}} $)**: This error is solely due to the finite difference approximation of the spatial derivative. It is the difference between the semi-discrete exact solution and the true analytical solution:\n    $$ E_{\\text{spat}} = \\lVert \\mathbf{u}_{\\text{sd}}(t_f) - \\mathbf{u}_{\\text{ex}}(t_f) \\rVert_{2,\\Delta x} $$\n-   **Temporal Discretization Error ($ E_{\\text{temp}} $)**: This error is solely due to the time integration scheme. It is the difference between the fully discrete numerical solution and the semi-discrete exact solution:\n    $$ E_{\\text{temp}}(\\Delta t) = \\lVert \\mathbf{u}_{\\text{num}}(t_f) - \\mathbf{u}_{\\text{sd}}(t_f) \\rVert_{2,\\Delta x} $$\n\n### 4. Time Integration Schemes\n\nThe numerical solution $ \\mathbf{u}_{\\text{num}}(t_f) $ is computed by advancing the solution from $ t=0 $ to $ t=t_f $ in discrete time steps $ \\Delta t $. Let $ \\mathbf{u}^k $ denote the solution at time $ t_k = k \\Delta t $. The three schemes are implemented as follows:\n-   **Forward Euler (explicit, 1st-order)**: The update rule is derived from a forward difference in time, $ \\mathbf{u}^{k+1} = (\\mathbf{I} + \\Delta t \\mathbf{A}) \\mathbf{u}^k $. This involves a simple matrix-vector multiplication at each step.\n-   **Backward Euler (implicit, 1st-order)**: The update rule uses a backward difference, $ (\\mathbf{I} - \\Delta t \\mathbf{A}) \\mathbf{u}^{k+1} = \\mathbf{u}^k $. This requires solving a linear system of equations for $ \\mathbf{u}^{k+1} $ at each time step.\n-   **Crank–Nicolson (implicit, 2nd-order)**: This scheme averages the right-hand side at times $ t_k $ and $ t_{k+1} $, leading to the update rule $ (\\mathbf{I} - \\frac{\\Delta t}{2} \\mathbf{A}) \\mathbf{u}^{k+1} = (\\mathbf{I} + \\frac{\\Delta t}{2} \\mathbf{A}) \\mathbf{u}^k $. This also requires solving a linear system at each step.\n\nFor the implicit schemes, the matrix on the left-hand side is constant throughout the integration, so its LU factorization is computed once and reused for efficient solution of the linear system at every step.\n\n### 5. Analysis Procedure\n\nFor each test case and each specified integration scheme, a temporal refinement study is conducted. A sequence of three time steps, $ \\Delta t_0 $, $ \\Delta t_1 = \\Delta t_0/2 $, and $ \\Delta t_2 = \\Delta t_1/2 $, is used. Before integration, each nominal $ \\Delta t $ is adjusted to $ \\Delta t' = t_f / \\text{round}(t_f/\\Delta t) $ to ensure the final time $ t_f $ is reached with an integer number of steps. The temporal error $ E_{\\text{temp}}(\\Delta t') $ is computed for each adjusted step size.\n\nThe observed temporal order of convergence, $ p_{\\text{obs}} $, is then calculated from the errors of the two finest time steps, $ \\Delta t'_1 $ and $ \\Delta t'_2 $:\n$$ p_{\\text{obs}} = \\frac{\\log\\left( E_{\\text{temp}}(\\Delta t'_1) / E_{\\text{temp}}(\\Delta t'_2) \\right)}{\\log\\left( \\Delta t'_1 / \\Delta t'_2 \\right)} $$\nThis value should theoretically approach the formal order of the integration scheme ($ 1 $ for FE/BE, $ 2 $ for CN).\n\nFinally, the ratio $ r $ of the smallest temporal error to the spatial error is computed:\n$$ r = \\frac{E_{\\text{temp}}(\\Delta t'_2)}{E_{\\text{spat}}} $$\nThis ratio quantifies whether the simulation error at the finest time step is dominated by the temporal or spatial discretization. A value of $ r \\ll 1 $ indicates a spatially-dominated error, while $ r \\gg 1 $ indicates a temporally-dominated error. The goal of a well-balanced simulation is often to have $ r \\approx 1 $.\n\nThe implementation proceeds by systematically executing this entire procedure for each of the four specified test cases.",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm, lu_factor, lu_solve\n\ndef solve():\n    \"\"\"\n    Solves the numerical analysis problem for the 1D heat equation.\n    \n    This function iterates through a suite of test cases, performing for each:\n    1. Spatial discretization using the Method of Lines.\n    2. Calculation of exact, semi-discrete, and numerical solutions.\n    3. Temporal refinement study to find the order of convergence.\n    4. Calculation of spatial and temporal error metrics.\n    5. Reporting of the observed order and the ratio of temporal to spatial error.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'name': 'A', 'scheme': 'fe', 'L': 1.0, 'alpha': 1e-4, 'N': 50, 'tf': 10.0, 'r0': 0.4},\n        {'name': 'B', 'scheme': 'be', 'L': 1.0, 'alpha': 1e-4, 'N': 50, 'tf': 30.0, 'r0': 4.0},\n        {'name': 'C', 'scheme': 'cn', 'L': 1.0, 'alpha': 1e-4, 'N': 50, 'tf': 30.0, 'r0': 1.0},\n        {'name': 'D', 'scheme': 'fe', 'L': 1.0, 'alpha': 1e-4, 'N': 50, 'tf': 10.0, 'r0': 0.49},\n    ]\n\n    # Global constants\n    Theta = 1.0  # K\n\n    final_results = []\n\n    for case in test_cases:\n        # Unpack parameters for the current case\n        scheme_type = case['scheme']\n        L = case['L']\n        alpha = case['alpha']\n        N = case['N']\n        tf = case['tf']\n        r0 = case['r0']\n\n        # 1. Spatial Discretization\n        dx = L / (N + 1)\n        x_grid = np.linspace(dx, L - dx, N)\n\n        # Construct the discrete Laplacian matrix A\n        main_diag = -2.0 * np.ones(N)\n        off_diag = np.ones(N - 1)\n        A = (alpha / dx**2) * (np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1))\n\n        # Initial Condition vector\n        u0 = Theta * np.sin(np.pi * x_grid / L)\n\n        # 2. Reference Solutions\n        # Continuous exact solution sampled on the grid\n        u_ex_tf = Theta * np.sin(np.pi * x_grid / L) * np.exp(-alpha * (np.pi**2 / L**2) * tf)\n        \n        # Semi-discrete exact solution using matrix exponential\n        u_sd_tf = expm(A * tf) @ u0\n\n        # Helper for discrete L2 norm\n        def norm_l2_dx(v, delta_x):\n            return np.sqrt(np.sum(v**2) * delta_x)\n\n        # 3. Error Quantification\n        # Spatial Discretization Error\n        E_spat = norm_l2_dx(u_sd_tf - u_ex_tf, dx)\n\n        # 4. Temporal Refinement Study\n        temporal_errors = []\n        adjusted_dts = []\n        \n        dt_base = r0 * dx**2 / alpha\n        dt_refinements = [dt_base, dt_base / 2.0, dt_base / 4.0]\n\n        for dt_nominal in dt_refinements:\n            # Adjust time step to reach tf exactly\n            if dt_nominal > 0 and tf > 0:\n                num_steps = int(np.round(tf / dt_nominal))\n                if num_steps == 0: num_steps = 1\n            else:\n                num_steps = 1\n            \n            dt_adj = tf / num_steps\n            adjusted_dts.append(dt_adj)\n            \n            u_num = np.copy(u0)\n\n            # Time integration loop\n            if scheme_type == 'fe':\n                op = np.eye(N) + dt_adj * A\n                for _ in range(num_steps):\n                    u_num = op @ u_num\n            elif scheme_type == 'be':\n                mat = np.eye(N) - dt_adj * A\n                lu, piv = lu_factor(mat)\n                for _ in range(num_steps):\n                    u_num = lu_solve((lu, piv), u_num)\n            elif scheme_type == 'cn':\n                mat_lhs = np.eye(N) - (dt_adj / 2.0) * A\n                mat_rhs = np.eye(N) + (dt_adj / 2.0) * A\n                lu, piv = lu_factor(mat_lhs)\n                for _ in range(num_steps):\n                    b = mat_rhs @ u_num\n                    u_num = lu_solve((lu, piv), b)\n\n            # Compute and store temporal error for this time step\n            E_temp = norm_l2_dx(u_num - u_sd_tf, dx)\n            temporal_errors.append(E_temp)\n            \n        # 5. Final Analysis\n        # Observed temporal order of convergence\n        E_temp1, E_temp2 = temporal_errors[1], temporal_errors[2]\n        dt1_adj, dt2_adj = adjusted_dts[1], adjusted_dts[2]\n        \n        if E_temp2 > 0 and E_temp1 > E_temp2 and dt1_adj / dt2_adj > 1:\n            p_obs = np.log(E_temp1 / E_temp2) / np.log(dt1_adj / dt2_adj)\n        else:\n            p_obs = np.nan # Fallback, should not be reached\n\n        # Ratio of temporal to spatial error at the finest time step\n        r = temporal_errors[2] / E_spat if E_spat > 0 else np.inf\n        \n        final_results.extend([p_obs, r])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        }
    ]
}