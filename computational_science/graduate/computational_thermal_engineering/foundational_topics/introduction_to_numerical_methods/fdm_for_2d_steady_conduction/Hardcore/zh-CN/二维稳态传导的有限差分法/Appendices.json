{
    "hands_on_practices": [
        {
            "introduction": "在解决实际工程问题之前，验证我们编写的计算代码的正确性是至关重要的一步。制造解法（Method of Manufactured Solutions, MMS）是一种强大而通用的代码验证技术，它通过一个已知的精确解来检验我们数值方案的实现是否准确。本练习将指导您实现一个基础的有限差分求解器，并进行网格收敛性研究，以验证其是否达到了理论上的二阶精度，这是计算科学领域一项基本功 。",
            "id": "3952953",
            "problem": "考虑在一个单位正方形区域 $[0,1] \\times [0,1]$ 内的均匀介质中，二维稳态热传导问题，其热导率 $k$ 为常数。带有体积热生成的稳态热传导的控制能量平衡方程为散度形式 $-\\nabla \\cdot (k \\nabla T) = q$，其中 $T$ 是温度，$q$ 是体积热生成率。假设变量为无量纲且 $k = 1$。设精确温度场为 $T(x,y) = \\sin(\\pi x)\\sin(\\pi y)$，其中角度以弧度为单位。使用此精确解，通过关系式 $-\\nabla^2 T = q$ 生成相应的源项 $q(x,y)$，并在整个区域边界上施加与精确解一致的狄利克雷边界条件。单位正方形的边界位于 $x=0$、$x=1$、$y=0$ 和 $y=1$。\n\n从第一性原理出发，推导控制方程在双向等间距的均匀笛卡尔网格上的二阶精度有限差分法 (FDM) 离散格式。在内部网格点上使用五点模板，并在网格边界上强制施加狄利克雷边界条件。构建离散线性系统，该系统对应于作用在 $T$ 上的负拉普拉斯算子等于离散的 $q$。通过在内部网格点上计算 $q$ 的值来组装右端项。求解生成的线性系统，以获得内部网格点上的 $T$。\n\n定义空间步长为 $h = 1/(n+1)$，其中 $n$ 是每个坐标方向上内部网格点的数量。设内部网格点位于 $x_i = ih$ 和 $y_j = jh$，其中 $i,j \\in \\{1,2,\\ldots,n\\}$。通过比较内部网格点上的数值解与精确解来计算离散误差。使用离散 $L_2$ 范数，定义为 $\\left(\\sum_{i=1}^n \\sum_{j=1}^n \\left|e_{ij}\\right|^2 h^2\\right)^{1/2}$，以及离散 $L_\\infty$ 范数，定义为 $\\max_{i,j} \\left|e_{ij}\\right|$，其中 $e_{ij}$ 是点 $(x_i,y_j)$ 处的误差。\n\n通过使用公式 $p = \\frac{\\log(E_\\text{coarse}/E_\\text{fine})}{\\log(h_\\text{coarse}/h_\\text{fine})}$ 计算连续均匀网格之间的观测阶数 $p$ 来验证二阶收敛性，其中 $E$ 是 $L_2$ 误差或 $L_\\infty$ 误差，$h$ 是对应内部点数量的网格间距。\n\n您的程序必须实现上述要求，求解离散系统，并报告一组测试网格对的观测阶数。所有量均为无量纲。\n\n测试套件：\n- 使用内部网格尺寸 $n \\in \\{4,8,16,32,64\\}$，并评估连续网格对 $(4,8)$、$(8,16)$、$(16,32)$ 和 $(32,64)$ 之间的观测阶数。\n- 对于每对网格，计算 $L_2$ 范数和 $L_\\infty$ 范数的观测阶数。\n- 该测试套件涵盖了一个粗网格边界情况 ($n=4$)、多个中间网格和一个相对较密的网格 ($n=64$)，以测试渐近行为。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为观测到的阶数，顺序需严格遵循：$[p_{L_2}(4,8), p_{L_2}(8,16), p_{L_2}(16,32), p_{L_2}(32,64), p_{L_\\infty}(4,8), p_{L_\\infty}(8,16), p_{L_\\infty}(16,32), p_{L_\\infty}(32,64)]$。\n- 每个条目必须是浮点数。",
            "solution": "该问题已经过验证，被确定为有效。它具有科学依据，是适定的、客观的，并包含获得唯一解所需的所有必要信息。\n\n### 1. 问题构建\n\n该问题涉及单位正方形区域 $\\Omega = [0,1] \\times [0,1]$ 内的二维稳态热传导。控制方程是泊松方程，它由能量平衡方程 $-\\nabla \\cdot (k \\nabla T) = q$ 在假设热导率 $k=1$ 为常数的情况下导出。方程为：\n$$-\\nabla^2 T(x,y) = q(x,y) \\quad \\text{for } (x,y) \\in \\Omega$$\n其中 $T$ 是温度场，$q$ 是体积热生成率。\n\n采用制造解方法 (MMS) 来验证数值格式。给定一个精确解：\n$$T_{exact}(x,y) = \\sin(\\pi x)\\sin(\\pi y)$$\n将 $T_{exact}$ 代入控制方程，推导出相应的源项 $q(x,y)$。其偏导数为：\n$$ \\frac{\\partial T_{exact}}{\\partial x} = \\pi \\cos(\\pi x)\\sin(\\pi y) \\implies \\frac{\\partial^2 T_{exact}}{\\partial x^2} = -\\pi^2 \\sin(\\pi x)\\sin(\\pi y) $$\n$$ \\frac{\\partial T_{exact}}{\\partial y} = \\pi \\sin(\\pi x)\\cos(\\pi y) \\implies \\frac{\\partial^2 T_{exact}}{\\partial y^2} = -\\pi^2 \\sin(\\pi x)\\sin(\\pi y) $$\n$T_{exact}$ 的拉普拉斯算子为：\n$$ \\nabla^2 T_{exact} = \\frac{\\partial^2 T_{exact}}{\\partial x^2} + \\frac{\\partial^2 T_{exact}}{\\partial y^2} = -2\\pi^2 \\sin(\\pi x)\\sin(\\pi y) $$\n因此，源项必须是：\n$$ q(x,y) = -\\nabla^2 T_{exact} = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y) $$\n在单位正方形的所有四个边界 ($\\partial\\Omega$) 上施加狄利克雷边界条件，这些条件取自精确解。\n$$ T(x,y) = T_{exact}(x,y) \\quad \\text{for } (x,y) \\in \\partial\\Omega $$\n在边界 $x=0$、$x=1$、$y=0$ 和 $y=1$ 上，精确解的值为零：\n$$ T(0,y) = \\sin(0)\\sin(\\pi y) = 0 $$\n$$ T(1,y) = \\sin(\\pi)\\sin(\\pi y) = 0 $$\n$$ T(x,0) = \\sin(\\pi x)\\sin(0) = 0 $$\n$$ T(x,1) = \\sin(\\pi x)\\sin(\\pi) = 0 $$\n因此，我们在整个边界上具有齐次狄利克雷边界条件。\n\n### 2. 有限差分离散化\n\n该区域使用均匀的笛卡尔网格进行离散化，每个方向有 $n$ 个内部点。网格间距为 $h = 1/(n+1)$。网格点为 $(x_i, y_j)$，其中 $x_i = ih$ 且 $y_j = jh$，$i,j \\in \\{0, 1, \\dots, n+1\\}$。内部点对应的索引为 $i,j \\in \\{1, 2, \\dots, n\\}$。设 $T_{i,j}$ 为 $T(x_i, y_j)$ 的数值近似值。\n\n二阶偏导数使用二阶中心差分公式进行近似。这些公式由点 $(x_i, y_j)$ 附近的泰勒级数展开推导而来：\n$$ T(x_i \\pm h, y_j) = T(x_i, y_j) \\pm h \\frac{\\partial T}{\\partial x} + \\frac{h^2}{2} \\frac{\\partial^2 T}{\\partial x^2} \\pm \\frac{h^3}{6} \\frac{\\partial^3 T}{\\partial x^3} + \\mathcal{O}(h^4) $$\n将 $+h$ 和 $-h$ 的展开式相加得到：\n$$ T(x_i+h, y_j) + T(x_i-h, y_j) = 2T(x_i, y_j) + h^2 \\frac{\\partial^2 T}{\\partial x^2} + \\mathcal{O}(h^4) $$\n对二阶导数进行整理，得到二阶精度的近似式：\n$$ \\left.\\frac{\\partial^2 T}{\\partial x^2}\\right|_{(x_i,y_j)} = \\frac{T_{i-1,j} - 2T_{i,j} + T_{i+1,j}}{h^2} + \\mathcal{O}(h^2) $$\n对于 $y$ 方向，类似地：\n$$ \\left.\\frac{\\partial^2 T}{\\partial y^2}\\right|_{(x_i,y_j)} = \\frac{T_{i,j-1} - 2T_{i,j} + T_{i,j+1}}{h^2} + \\mathcal{O}(h^2) $$\n将这些近似式代入内部网格点 $(x_i, y_j)$ 处的控制方程 $-\\nabla^2 T = q$，得到离散方程：\n$$ -\\left( \\frac{T_{i-1,j} - 2T_{i,j} + T_{i+1,j}}{h^2} + \\frac{T_{i,j-1} - 2T_{i,j} + T_{i,j+1}}{h^2} \\right) = q_{i,j} $$\n其中 $q_{i,j} = q(x_i, y_j)$。整理后得到五点模板方程：\n$$ 4T_{i,j} - T_{i-1,j} - T_{i+1,j} - T_{i,j-1} - T_{i,j+1} = h^2 q_{i,j} $$\n此方程对所有内部点均有效，即对 $i,j \\in \\{1, 2, \\dots, n\\}$ 成立。\n\n### 3. 线性方程组\n\n$n^2$ 个未知内部温度 $\\{T_{i,j}\\}$ 的 $n^2$ 个离散方程构成一个线性方程组 $A\\vec{T} = \\vec{b}$。未知数被排列成一个长度为 $N=n^2$ 的单一向量 $\\vec{T}$。我们使用行主序映射，其中网格点 $(i,j)$ 的索引 $k$ 为 $k = (j-1)n + (i-1)$，$k \\in \\{0, 1, \\dots, N-1\\}$。\n\n矩阵 $A$ 是一个 $N \\times N$ 的稀疏矩阵。第 $k$ 行对应点 $(i,j)$ 处的离散方程。方程 $4T_{i,j} - T_{i-1,j} - T_{i+1,j} - T_{i,j-1} - T_{i,j+1} = h^2 q_{i,j}$ 导致第 $k$ 行的矩阵元素如下：\n- $A_{k,k} = 4$\n- $A_{k, k-1} = -1$ (对于邻点 $(i-1,j)$，如果 $i1$)\n- $A_{k, k+1} = -1$ (对于邻点 $(i+1,j)$，如果 $i",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags\nfrom scipy.sparse.linalg import spsolve\nimport math\n\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to solve the 2D Poisson problem and compute convergence orders.\n    \"\"\"\n\n    def solve_poisson(n: int) -> tuple[float, float, float]:\n        \"\"\"\n        Solves the 2D Poisson equation on a unit square for a given grid size.\n\n        Args:\n            n: The number of interior grid points in each direction.\n\n        Returns:\n            A tuple containing:\n            - h (float): The grid spacing.\n            - l2_error (float): The discrete L2 norm of the error.\n            - linf_error (float): The discrete L_infinity norm of the error.\n        \"\"\"\n        # 1. Define grid parameters\n        h = 1.0 / (n + 1)\n        N = n * n  # Total number of interior points (unknowns)\n\n        # 2. Create grid coordinates for interior points\n        # Grid points are at x_i = i*h, y_j = j*h for i,j in {1,...,n}\n        grid_pts = np.arange(1, n + 1) * h\n        # Use 'ij' indexing so that X[j, i] = x_i and Y[j, i] = y_j\n        X, Y = np.meshgrid(grid_pts, grid_pts, indexing='ij')\n\n        # 3. Assemble the right-hand side (RHS) vector `b`\n        # q(x,y) = 2 * pi^2 * sin(pi*x) * sin(pi*y)\n        # b = h^2 * q, flattened in row-major order\n        q_grid = 2 * (np.pi**2) * np.sin(np.pi * X) * np.sin(np.pi * Y)\n        b = (h**2) * q_grid.flatten()\n\n        # 4. Assemble the sparse matrix A for the negative Laplacian\n        # The equation is 4*T_ij - T_i-1,j - T_i+1,j - T_i,j-1 - T_i,j+1 = b_ij\n        # This structure results in a matrix with 5 non-zero diagonals.\n        \n        main_diag = np.full(N, 4.0)\n        \n        # Off-diagonal for x-neighbors (k -> k+/-1)\n        # Need to zero out entries that cross row boundaries\n        off_diag_1 = np.full(N - 1, -1.0)\n        off_diag_1[n-1::n] = 0.0\n        \n        # Off-diagonal for y-neighbors (k -> k+/-n)\n        off_diag_n = np.full(N - n, -1.0)\n        \n        diagonals = [main_diag, off_diag_1, off_diag_1, off_diag_n, off_diag_n]\n        offsets = [0, 1, -1, n, -n]\n        \n        A = diags(diagonals, offsets, shape=(N, N), format='csr')\n\n        # 5. Solve the linear system A * T_vec = b\n        T_vec_num = spsolve(A, b)\n\n        # 6. Compute the error\n        # Reshape the numerical solution to the 2D grid\n        T_grid_num = T_vec_num.reshape((n, n))\n        \n        # Get the exact solution at the interior grid points\n        T_grid_exact = np.sin(np.pi * X) * np.sin(np.pi * Y)\n        \n        # Compute the error grid\n        error_grid = T_grid_num - T_grid_exact\n\n        # 7. Calculate error norms\n        # L-infinity norm\n        linf_error = np.abs(error_grid).max()\n        \n        # L2 norm: sqrt(sum(|e_ij|^2 * h^2)) = h * sqrt(sum(|e_ij|^2))\n        # np.linalg.norm(error_grid) computes the Frobenius norm, which is sqrt(sum(|e_ij|^2))\n        l2_error = h * np.linalg.norm(error_grid)\n        \n        return h, l2_error, linf_error\n\n    # Test suite parameters\n    n_values = [4, 8, 16, 32, 64]\n    errors = {}\n\n    # Calculate errors for each grid size\n    for n in n_values:\n        h, l2_err, linf_err = solve_poisson(n)\n        errors[n] = {'h': h, 'l2': l2_err, 'linf': linf_err}\n\n    # Compute observed convergence orders\n    p_l2_list = []\n    p_linf_list = []\n    \n    for i in range(len(n_values) - 1):\n        n_coarse = n_values[i]\n        n_fine = n_values[i+1]\n        \n        # Get errors and grid spacings\n        e_coarse_l2 = errors[n_coarse]['l2']\n        e_fine_l2 = errors[n_fine]['l2']\n        \n        e_coarse_linf = errors[n_coarse]['linf']\n        e_fine_linf = errors[n_fine]['linf']\n        \n        h_coarse = errors[n_coarse]['h']\n        h_fine = errors[n_fine]['h']\n\n        # Calculate observed order p = log(E_c/E_f) / log(h_c/h_f)\n        p_l2 = math.log(e_coarse_l2 / e_fine_l2) / math.log(h_coarse / h_fine)\n        p_linf = math.log(e_coarse_linf / e_fine_linf) / math.log(h_coarse / h_fine)\n        \n        p_l2_list.append(p_l2)\n        p_linf_list.append(p_linf)\n\n    # Combine results into the final list in the specified order\n    final_results = p_l2_list + p_linf_list\n\n    # Print the final output in the required format\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实的物理问题往往涉及由不同属性（如导热系数 $k$）的多种材料构成的系统。在材料界面上，对这些属性进行简单的算术平均可能会导致违反能量守恒定律的非物理结果。本练习揭示了这一常见陷阱，并阐明了为何采用谐和平均来计算界面导热系数是正确的选择，因为它能够精确模拟串联热阻，从而确保数值格式的物理守恒性 。",
            "id": "3952938",
            "problem": "考虑一个宽度为 $L_x$、高度为 $L_y$ 的矩形域内无内部热源的稳态二维热传导问题。热导率 $k(\\mathbf{x})$ 是分段常数，在 $x=L_x/2$ 处有一个与垂直网格面对齐的界面：界面西侧 $k(\\mathbf{x})=k_L$，东侧 $k(\\mathbf{x})=k_R$。西边界温度保持在 $T(0,y)=T_W$，东边界温度为 $T(L_x,y)=T_E$，南北边界是绝热的（$\\partial T/\\partial y=0$）。由于数据在 $y$ 方向上是均匀的，精确连续解在 $x$ 方向上是一维的，且真实的物理通量 $q_x$ 是一个常数。\n\n在均匀网格上应用单元中心有限差分法 (FDM)，在 $x$ 方向上恰好有两个控制体（中心分别位于 $x=L_x/4$ 和 $x=3L_x/4$），在 $y$ 方向上有任意数量的控制体（由于南北绝热和 $y$ 方向的均匀性，这不起作用）。位于 $x=L_x/2$ 的内部界面通过在相邻单元中心之间的距离 $\\Delta x=L_x/2$ 上使用中心差分来近似法向通量：\n$$\nq_{f} \\equiv -k_f \\frac{T_R - T_L}{\\Delta x},\n$$\n其中 $T_L$ 和 $T_R$ 分别是西侧和东侧单元中心的温度，而 $k_f$ 是待选择的有效界面热导率。在西边界界面，使用单边差分，距离为半宽 $\\Delta x/2$：\n$$\nq_W \\equiv -k_L \\frac{T_L - T_W}{\\Delta x/2}.\n$$\n东边界也采用类似的处理方法。\n\n假设 $L_x=L_y=1$，$k_L=1$，$k_R=100$，$T_W=1$，$T_E=0$。精确连续解在 $x$ 方向上是分段线性的，并具有单一的恒定热通量。仅使用控制方程 $\\nabla \\cdot (-k \\nabla T)=0$ 和 Fourier 定律 $q_x=-k \\, dT/dx$，考虑使用算术平均 $k_f^{\\text{arith}}=(k_L+k_R)/2$ 计算的穿过内部界面的离散通量，并将其与西边界界面处的边流通量进行比较。然后，考虑一种基于与串联热阻一致的界面调和平均的修正 $k_f$ 选择。\n\n选择所有正确的陈述：\n\nA. 对于给定的数据，在界面处使用 $k_f^{\\text{arith}}=(k_L+k_R)/2$ 得到 $q_f=50.5$，而西边界通量为 $q_W\\approx 1.9802$，这在左侧控制体中产生一个非零的净离散源/汇，从而违反了局部守恒。\n\nB. 选择界面热导率为调和平均 $k_f=\\dfrac{2}{\\dfrac{1}{k_L}+\\dfrac{1}{k_R}}$，得到的界面通量与边流通量相匹配（对于给定的数据），从而恢复了两个控制体中的局部离散守恒。\n\nC. 在界面处使用几何平均 $k_f=\\sqrt{k_L k_R}$，可以保证在 $k$ 不连续的情况下，对于任意网格和边界条件都能实现局部离散守恒。\n\nD. 对于界面两侧不均匀的相邻单元中心间距 $\\Delta x_L$ 和 $\\Delta x_R$，守恒的界面热导率可推广为\n$$\nk_f=\\frac{\\Delta x_L+\\Delta x_R}{\\dfrac{\\Delta x_L}{k_L}+\\dfrac{\\Delta x_R}{k_R}},\n$$\n这样 $q_f=-k_f \\dfrac{T_R-T_L}{\\Delta x_L+\\Delta x_R}$ 就能强制实现通量连续性和离散守恒。",
            "solution": "用户希望我扮演一位STEM教授，解决一个计算传热学问题。\n\n### 问题验证\n\n**第一步：提取已知条件**\n\n- **问题类型**：稳态二维热传导，无内部热源。\n- **区域**：矩形域，宽度 $L_x$，高度 $L_y$。\n- **热导率**：分段常数，界面位于 $x=L_x/2$。\n  - 对于 $x  L_x/2$，$k(\\mathbf{x}) = k_L$。\n  - 对于 $x > L_x/2$，$k(\\mathbf{x}) = k_R$。\n- **边界条件**：\n  - 西边界 ($x=0$)：$T(0,y)=T_W$。\n  - 东边界 ($x=L_x$)：$T(L_x,y)=T_E$。\n  - 南北边界：绝热，$\\partial T/\\partial y=0$。\n- **精确解性质**：在 $x$ 方向上是一维的，物理通量 $q_x$ 是常数。\n- **数值方法**：均匀网格上的单元中心有限差分法 (FDM)。\n  - $x$ 方向上有两个控制体。\n  - 单元中心位于 $x_L = L_x/4$ 和 $x_R = 3L_x/4$。\n  - 控制体宽度 $\\Delta x = L_x/2$。\n  - 内部界面位于 $x=L_x/2$。\n- **离散通量近似**：\n  - 内部界面：$q_{f} \\equiv -k_f \\frac{T_R - T_L}{\\Delta x}$。\n  - 西边界界面：$q_W \\equiv -k_L \\frac{T_L - T_W}{\\Delta x/2}$。\n  - 东边界界面：（类似）$q_E \\equiv -k_R \\frac{T_E - T_R}{\\Delta x/2}$。\n- **给定数据**：\n  - $L_x=1$, $L_y=1$。\n  - $k_L=1$, $k_R=100$。\n  - $T_W=1$, $T_E=0$。\n- **控制方程**：$\\nabla \\cdot (-k \\nabla T)=0$ 和 Fourier 定律 $q_x=-k \\, dT/dx$。\n- **待考虑的界面热导率模型**：\n  - 算术平均：$k_f^{\\text{arith}}=(k_L+k_R)/2$。\n  - 调和平均：$k_f=\\dfrac{2}{\\dfrac{1}{k_L}+\\dfrac{1}{k_R}}$。\n\n**第二步：使用提取的已知条件进行验证**\n\n- **科学基础**：该问题基于稳态热传导的基本原理（Fourier定律和能量守恒）以及标准的单元中心有限差分数值方法。对于不连续系数的界面热导率分析是计算物理学和工程学的核心课题。该设置在科学上是合理的。\n- **适定性**：连续的边值问题是适定的。离散FDM系统产生一个关于两个未知单元中心温度的两个线性代数方程组，该方程组是可解的。\n- **客观性**：问题使用了传热学和数值分析中精确、标准且明确的术语来陈述。\n- **设置不完整或矛盾**：问题提供了进行全面分析所需的所有数据和定义。对区域、物理和离散化的描述是完整和一致的。\n- **不切实际或不可行**：物理参数在一个模型问题的合理范围内。该设置在物理上是可行的。\n- **不适定或结构不良**：该问题结构良好，旨在比较处理材料界面的不同数值方案，这是一个经典且重要的话题。\n- **伪深刻、琐碎或同义反复**：该问题解决了数值方法中的一个非平凡问题。界面热导率的选择对数值解的准确性和守恒性有重要影响，这是一个实质性的概念挑战。\n\n**第三步：结论与行动**\n\n问题陈述是**有效的**。这是一个在计算传热学领域中适定且科学合理的问题。进行求解。\n\n### 求解推导\n\n首先，我们求该问题的精确连续解。由于边界条件在 $y$ 方向上是均匀的，且顶部/底部边界是绝热的，因此问题是一维的，热量仅在 $x$ 方向上传导。对于无热源的稳态一维热传导，热通量 $q_x$ 在整个区域内必须是常数。\n\n该区域由两个串联的层组成。令 $T_m$ 为材料界面 $x = L_x/2 = 0.5$ 处的温度。\n通过左侧层（从 $x=0$ 到 $x=0.5$）的热通量是：\n$$q_x = -k_L \\frac{T_m - T_W}{L_x/2}$$\n通过右侧层（从 $x=0.5$ 到 $x=1$）的热通量是：\n$$q_x = -k_R \\frac{T_E - T_m}{L_x/2}$$\n令这两个关于常数通量 $q_x$ 的表达式相等：\n$$-k_L \\frac{T_m - T_W}{L_x/2} = -k_R \\frac{T_E - T_m}{L_x/2}$$\n$$k_L(T_m - T_W) = k_R(T_E - T_m)$$\n代入给定值 $k_L=1$, $k_R=100$, $T_W=1$, $T_E=0$：\n$$1(T_m - 1) = 100(0 - T_m)$$\n$$T_m - 1 = -100T_m$$\n$$101T_m = 1 \\implies T_m = \\frac{1}{101}$$\n精确的恒定热通量为：\n$$q_x^{\\text{exact}} = -k_L \\frac{T_m - T_W}{L_x/2} = -1 \\frac{1/101 - 1}{1/2} = -2\\left(\\frac{1-101}{101}\\right) = -2\\left(\\frac{-100}{101}\\right) = \\frac{200}{101} \\approx 1.980198$$\n\n为了分析离散格式的特性，特别是其相容性，我们使用在单元中心评估的精确解的温度值来评估离散通量算子。单元中心位于 $x_L = L_x/4 = 0.25$ 和 $x_R = 3L_x/4 = 0.75$。\n精确温度分布是分段线性的。\n对于 $x \\in [0, 0.5]$：$T(x) = T_W + \\frac{x}{L_x/2}(T_m - T_W) = 1 + \\frac{x}{0.5}(\\frac{1}{101} - 1) = 1 - \\frac{200}{101}x$。\n对于 $x \\in [0.5, 1]$：$T(x) = T_m + \\frac{x-0.5}{L_x/2}(T_E - T_m) = \\frac{1}{101} + \\frac{x-0.5}{0.5}(0 - \\frac{1}{101}) = \\frac{1}{101} - \\frac{2}{101}(x-0.5) = \\frac{2(1-x)}{101}$。\n\n单元中心处的精确温度为：\n$T_L = T(0.25) = 1 - \\frac{200}{101}(0.25) = 1 - \\frac{50}{101} = \\frac{51}{101}$。\n$T_R = T(0.75) = \\frac{2(1-0.75)}{101} = \\frac{2(0.25)}{101} = \\frac{0.5}{101} = \\frac{1}{202}$。\n\n现在我们逐项分析每个选项。分析的核心是检查当用这些精确温度评估离散通量公式时，离散通量平衡（局部守恒），例如 $q_W = q_f$，是否成立。如果不相等，则该格式存在截断误差，精确解不满足离散方程。\n\n### 逐项分析\n\n**A. 对于给定的数据，在界面处使用 $k_f^{\\text{arith}}=(k_L+k_R)/2$ 得到 $q_f=50.5$，而西边界通量为 $q_W\\approx 1.9802$，这在左侧控制体中产生一个非零的净离散源/汇，从而违反了局部守恒。**\n\n我们使用精确温度 $T_L=51/101$ 和 $T_R=1/202$ 来评估离散通量。\n网格间距为 $\\Delta x = L_x/2 = 1/2 = 0.5$。半间距为 $\\Delta x/2 = 1/4 = 0.25$。\n\n西边界通量：\n$$q_W = -k_L \\frac{T_L - T_W}{\\Delta x/2} = -1 \\frac{51/101 - 1}{0.25} = -4\\left(\\frac{51-101}{101}\\right) = -4\\left(\\frac{-50}{101}\\right) = \\frac{200}{101} \\approx 1.9802$$\n这与精确物理通量相匹配，正如预期的那样，因为该区域的温度分布是线性的。\n\n使用算术平均热导率的界面通量：\n$k_f^{\\text{arith}} = (k_L + k_R)/2 = (1 + 100)/2 = 50.5$。\n$$q_f = -k_f^{\\text{arith}} \\frac{T_R - T_L}{\\Delta x} = -50.5 \\frac{1/202 - 51/101}{0.5} = -101 \\left(\\frac{1}{202} - \\frac{102}{202}\\right) = -101 \\left(\\frac{-101}{202}\\right) = \\frac{101^2}{202} = \\frac{10201}{202} = 50.5$$\n选项中陈述的值是正确的：$q_W \\approx 1.9802$ 和 $q_f = 50.5$。由于 $q_f \\neq q_W$，左侧控制体存在净通量不平衡，等于 $q_f - q_W = 50.5 - 200/101 \\approx 48.52$。这表示存在一个大的“离散源”或截断误差，并表明使用算术平均时，离散方程与物理不一致，因为精确解不满足它们。\n\n**结论：正确。**\n\n**B. 选择界面热导率为调和平均 $k_f=\\dfrac{2}{\\dfrac{1}{k_L}+\\dfrac{1}{k_R}}$，得到的界面通量与边流通量相匹配（对于给定的数据），从而恢复了两个控制体中的局部离散守恒。**\n\n我们计算调和平均热导率：\n$$k_f^{\\text{harm}} = \\frac{2}{\\frac{1}{k_L} + \\frac{1}{k_R}} = \\frac{2}{\\frac{1}{1} + \\frac{1}{100}} = \\frac{2}{101/100} = \\frac{200}{101}$$\n现在，我们使用这个 $k_f$ 和精确温度 $T_L=51/101$ 和 $T_R=1/202$ 计算界面通量 $q_f$：\n$$q_f = -k_f^{\\text{harm}} \\frac{T_R - T_L}{\\Delta x} = -\\frac{200}{101} \\frac{1/202 - 51/101}{0.5} = -\\frac{400}{101} \\left(\\frac{1-102}{202}\\right) = -\\frac{400}{101} \\left(\\frac{-101}{202}\\right) = \\frac{400}{202} = \\frac{200}{101}$$\n如选项A的分析所示，西边界通量 $q_W = 200/101$。\n因此，使用调和平均时，$q_f = q_W = 200/101$。这意味着左侧控制体的净通量为零，因此满足局部守恒。通过扩展（或直接计算），守恒对右侧控制体也成立。该格式对于这个一维问题是精确的。\n\n**结论：正确。**\n\n**C. 在界面处使用几何平均 $k_f=\\sqrt{k_L k_R}$，可以保证在 $k$ 不连续的情况下，对于任意网格和边界条件都能实现局部离散守恒。**\n\n这是一个非常强且普适的论断。我们可以用我们的特定问题来检验它。\n几何平均热导率为：\n$$k_f^{\\text{geom}} = \\sqrt{k_L k_R} = \\sqrt{1 \\times 100} = 10$$\n我们使用这个值和精确温度计算界面通量 $q_f$：\n$$q_f = -k_f^{\\text{geom}} \\frac{T_R - T_L}{\\Delta x} = -10 \\frac{1/202 - 51/101}{0.5} = -20 \\left(\\frac{-101}{202}\\right) = 20 \\left(\\frac{1}{2}\\right) = 10$$\n正确的物理通量是 $q_x^{\\text{exact}} = 200/101 \\approx 1.98$。由于 $q_f = 10 \\neq 200/101$，即使对于这个简单的一维均匀网格问题，几何平均也没有产生一个相容的离散化。因此，它“保证”在“任意网格和边界条件”下守恒的说法是错误的。\n\n**结论：不正确。**\n\n**D. 对于界面两侧不均匀的相邻单元中心间距 $\\Delta x_L$ 和 $\\Delta x_R$，守恒的界面热导率可推广为 $k_f=\\frac{\\Delta x_L+\\Delta x_R}{\\dfrac{\\Delta x_L}{k_L}+\\dfrac{\\Delta x_R}{k_R}}$，这样 $q_f=-k_f \\dfrac{T_R-T_L}{\\Delta x_L+\\Delta x_R}$ 就能强制实现通量连续性和离散守恒。**\n\n该选项提出了 $k_f$ 和通量 $q_f$ 的推广公式。我们基于串联热阻的类比来分析它。考虑两个单元中心 L 和 R，被一个材料界面隔开。从 L 中心到界面的距离是 $\\Delta x_L$（热导率为 $k_L$），从界面到 R 中心的距离是 $\\Delta x_R$（热导率为 $k_R$）。总距离是 $\\Delta x_L + \\Delta x_R$。\n从 L 到 R 的一维热通量由 $T_L-T_R$ 驱动，跨越总热阻 $R_{th, total}$。\n$R_{th,total} = R_{th,L} + R_{th,R} = \\frac{\\Delta x_L}{k_L A} + \\frac{\\Delta x_R}{k_R A}$，其中 $A$ 是横截面积。\n热流率是 $\\dot{Q} = \\frac{T_L - T_R}{R_{th,total}}$。热通量是 $q = \\dot{Q}/A = \\frac{T_L - T_R}{A \\cdot R_{th,total}} = \\frac{T_L-T_R}{\\frac{\\Delta x_L}{k_L} + \\frac{\\Delta x_R}{k_R}}$。\n\n问题陈述的通量为 $q_f = -k_f \\dfrac{T_R - T_L}{\\Delta x_L + \\Delta x_R}$。让我们代入所提出的 $k_f$ 公式：\n$$q_f = -\\left(\\frac{\\Delta x_L+\\Delta x_R}{\\dfrac{\\Delta x_L}{k_L}+\\dfrac{\\Delta x_R}{k_R}}\\right) \\frac{T_R-T_L}{\\Delta x_L+\\Delta x_R} = - \\frac{T_R-T_L}{\\dfrac{\\Delta x_L}{k_L}+\\dfrac{\\Delta x_R}{k_R}} = \\frac{T_L-T_R}{\\dfrac{\\Delta x_L}{k_L}+\\dfrac{\\Delta x_R}{k_R}}$$\n这个 $q_f$ 的表达式与一维分层介质的物理推导通量 $q$ 完全相同。通过确保离散通量公式精确地再现了单元中心之间的一维物理通量，该方法保证了一维问题的守恒性。这是调和平均在非均匀网格上的正确推广。对于我们的均匀网格情况，$\\Delta x_L = \\Delta x_R = \\Delta x/2$，该 $k_f$ 公式简化为标准的调和平均 $\\frac{2}{1/k_L + 1/k_R}$。\n\n**结论：正确。**",
            "answer": "$$\\boxed{ABD}$$"
        },
        {
            "introduction": "将偏微分方程离散化会产生一个庞大的线性方程组，对于精细的网格，直接求解法（如高斯消元法）的计算成本过高而变得不切实际。迭代法，例如高斯-赛德尔（Gauss-Seidel）法，为此提供了高效的替代方案。本练习将探讨高斯-赛德尔法的一种变体——红黑着色排序法，这种方法不仅能保证收敛性，更重要的是，它揭示了大规模并行计算的潜力，这对于现代高性能计算至关重要 。",
            "id": "3952957",
            "problem": "考虑一种均质材料在二维稳态下的热传导问题，其热导率恒定。该问题可通过能量守恒定律和傅里叶定律推导出的泊松方程进行建模。设温度场为 $T(x,y)$，定义在矩形域 $\\Omega = [0,L_x] \\times [0,L_y]$ 上。若单位热导率的体积源密度由 $f(x,y)$ 定义，则控制方程为\n$$\n\\nabla^2 T(x,y) = - f(x,y),\n$$\n服从边界 $\\partial \\Omega$ 上的狄利克雷边界条件 $T(x,y) = g(x,y)$。所有三角函数中的角度均以弧度为单位。温度必须以开尔文为单位表示。您的任务是使用有限差分法 (FDM) 在均匀笛卡尔网格上对此问题进行离散化，并使用红黑高斯-赛德尔迭代法求解所得的线性系统。您还必须从第一性原理出发，解释为什么红黑着色方案能够增强并行性，以及为什么该方法能保持收敛性。\n\n出发点要求：\n- 从能量守恒（稳态）和热传导的傅里叶定律开始，阐述控制方程及其性质（例如，在狄利克雷边界条件下离散系统的对称性和正定性）。\n- 使用泰勒展开在均匀网格上推导拉普拉斯算子的中心差分近似，网格在 $x$ 和 $y$ 方向上的间距分别为 $h_x$ 和 $h_y$，确保从第一性原理和成熟公式出发的科学一致性。\n- 通过识别网格上有限差分模板图的二分结构，建立红黑高斯-赛德尔迭代法，并证明在一次扫描中相同颜色集合中的节点是相互独立的，并根据对称正定系统的矩阵分裂理论论证其收敛性。\n\n实现要求：\n- 程序必须在均匀网格上组装使用五点模板的离散泊松算子，施加狄利克雷边界值，并使用红黑高斯-赛德尔法进行迭代，直到基于离散残差范数的停止准则得到满足或达到最大迭代次数。\n- 内部节点 $(i,j)$ 处的离散残差必须按如下方式计算\n$$\nr_{i,j} = \\frac{T_{i-1,j} - 2 T_{i,j} + T_{i+1,j}}{h_x^2} + \\frac{T_{i,j-1} - 2 T_{i,j} + T_{i,j+1}}{h_y^2} + f_{i,j},\n$$\n且停止准则必须为 $\\max_{i,j} |r_{i,j}|  \\varepsilon$，其中 $\\varepsilon$ 是一个给定的容差。\n\n测试套件：\n实现并求解以下三个测试用例。在所有用例中，返回所有网格点上与精确解相比的最大绝对温度误差（以开尔文为单位）。请使用指定的容差和迭代次数限制。\n\n- 测试用例 $1$（理想情况，具有构造解的方形域）：\n  - 域参数：$L_x = 1$，$L_y = 1$。\n  - 网格分辨率：$N_x = 65$，$N_y = 65$（每个方向上的总节点数，包括边界）。\n  - 精确解：$T(x,y) = \\sin(\\pi x)\\sin(\\pi y)$。\n  - 源项：$f(x,y) = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$，使得 $\\nabla^2 T = -f$ 成立。\n  - 边界数据：在 $\\partial \\Omega$ 上 $T(x,y) = \\sin(\\pi x)\\sin(\\pi y)$。\n  - 容差：$\\varepsilon = 10^{-8}$。\n  - 最大迭代次数：$N_{\\text{max}} = 5000$。\n  - 输出：最大绝对误差，以开尔文为单位的浮点数。\n\n- 测试用例 $2$（边界条件边缘情况，平凡解）：\n  - 域参数：$L_x = 1$，$L_y = 1$。\n  - 网格分辨率：$N_x = 4$，$N_y = 4$。\n  - 精确解：$T(x,y) = 0$。\n  - 源项：$f(x,y) = 0$。\n  - 边界数据：在 $\\partial \\Omega$ 上 $T(x,y) = 0$。\n  - 容差：$\\varepsilon = 10^{-12}$。\n  - 最大迭代次数：$N_{\\text{max}} = 5000$。\n  - 输出：最大绝对误差，以开尔文为单位的浮点数。\n\n- 测试用例 $3$（具有各向异性网格间距的矩形域）：\n  - 域参数：$L_x = 2$，$L_y = 1$。\n  - 网格分辨率：$N_x = 63$，$N_y = 17$。\n  - 精确解：$T(x,y) = \\sin\\!\\big(\\frac{\\pi x}{L_x}\\big)\\sin\\!\\big(\\frac{\\pi y}{L_y}\\big)$。\n  - 源项：$f(x,y) = \\Big(\\frac{\\pi^2}{L_x^2} + \\frac{\\pi^2}{L_y^2}\\Big) \\sin\\!\\big(\\frac{\\pi x}{L_x}\\big)\\sin\\!\\big(\\frac{\\pi y}{L_y}\\big)$，使得 $\\nabla^2 T = -f$ 成立。\n  - 边界数据：在 $\\partial \\Omega$ 上 $T(x,y) = \\sin\\!\\big(\\frac{\\pi x}{L_x}\\big)\\sin\\!\\big(\\frac{\\pi y}{L_y}\\big)$。\n  - 容差：$\\varepsilon = 10^{-8}$。\n  - 最大迭代次数：$N_{\\text{max}} = 5000$。\n  - 输出：最大绝对误差，以开尔文为单位的浮点数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个以方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3]$），其中 $r_1$、$r_2$ 和 $r_3$ 分别是测试用例 $1$、$2$ 和 $3$ 的最大绝对温度误差（以开尔文为单位）。不应打印任何其他文本。",
            "solution": "该问题的物理基础是应用于热传递的能量守恒原理。在稳态下，内部能量不随时间变化，因此传入任何控制体的净热传导速率必须与该体积内产生的热量速率相平衡。这种平衡在数学上表示为：\n$$\n-\\oint_{\\partial V} \\vec{q} \\cdot d\\vec{A} + \\int_V \\dot{q} \\, dV = 0\n$$\n在这里，$\\vec{q}$ 代表热通量矢量，单位为瓦特每平方米（$W/m^2$），$\\dot{q}$ 是体积生热率（$W/m^3$），$V$ 是控制体，$\\partial V$ 是其边界面。应用散度定理，我们将面积分转换成体积分，得到 $\\int_V (-\\nabla \\cdot \\vec{q} + \\dot{q}) \\, dV = 0$。由于这必须对任意体积 $V$ 成立，被积函数本身必须为零，从而导出能量平衡的微分形式：$\\nabla \\cdot \\vec{q} = \\dot{q}$。\n\n热通量与温度之间的关系由傅里叶热传导定律给出，即 $\\vec{q} = -k \\nabla T$，其中 $k$ 是材料的热导率，$T$ 是温度场。对于具有恒定热导率的均质材料，将傅里叶定律代入能量平衡方程得到 $\\nabla \\cdot (-k \\nabla T) = \\dot{q}$，可简化为 $-k \\nabla^2 T = \\dot{q}$。拉普拉斯算子为 $\\nabla^2 = \\nabla \\cdot \\nabla$。通过定义单位热导率的源项 $f(x,y) = \\dot{q}/k$，我们得到二维稳态热传导的控制泊松方程：\n$$\n\\nabla^2 T(x,y) = - f(x,y)\n$$\n此方程需在矩形域 $\\Omega = [0,L_x] \\times [0,L_y]$ 上求解，并服从指定的狄利克雷边界条件。\n\n为了数值求解此偏微分方程，我们采用有限差分法（FDM）。我们将连续域 $\\Omega$ 离散化为一个均匀的笛卡尔网格，网格点为 $(x_i, y_j)$，其中 $x_i = i h_x$（$i \\in \\{0, 1, \\dots, N_x-1\\}$），$y_j = j h_y$（$j \\in \\{0, 1, \\dots, N_y-1\\}$）。网格间距为 $h_x = L_x / (N_x - 1)$ 和 $h_y = L_y / (N_y - 1)$。网格点上的温度记为 $T_{i,j} \\approx T(x_i, y_j)$。拉普拉斯算子中的偏导数使用基于泰勒级数展开的中心差分进行近似。对于在点 $(x_i, y_j)$ 处关于 $x$ 的二阶偏导数：\n$$\nT(x_i \\pm h_x, y_j) = T(x_i, y_j) \\pm h_x \\frac{\\partial T}{\\partial x} \\bigg|_{(i,j)} + \\frac{h_x^2}{2} \\frac{\\partial^2 T}{\\partial x^2} \\bigg|_{(i,j)} \\pm \\frac{h_x^3}{6} \\frac{\\partial^3 T}{\\partial x^3} \\bigg|_{(i,j)} + \\mathcal{O}(h_x^4)\n$$\n将 $+h_x$ 和 $-h_x$ 的展开式相加，奇数阶导数项被消去，得到：\n$$\nT_{i+1,j} + T_{i-1,j} = 2T_{i,j} + h_x^2 \\frac{\\partial^2 T}{\\partial x^2} \\bigg|_{(i,j)} + \\mathcal{O}(h_x^4)\n$$\n整理后得到二阶精度的中心差分近似：\n$$\n\\frac{\\partial^2 T}{\\partial x^2} \\bigg|_{(i,j)} \\approx \\frac{T_{i+1,j} - 2T_{i,j} + T_{i-1,j}}{h_x^2}\n$$\n对于 $y$ 方向的导数，可以得到相似的表达式。将这些近似代入泊松方程，得到每个内部节点 $(i,j)$ 处的离散方程：\n$$\n\\frac{T_{i+1,j} - 2T_{i,j} + T_{i-1,j}}{h_x^2} + \\frac{T_{i,j+1} - 2T_{i,j} + T_{i,j-1}}{h_y^2} + f_{i,j} = 0\n$$\n这个五点模板将一个节点的温度与其四个最近邻居的温度联系起来。这构成了一个关于未知内部温度的大型稀疏线性方程组 $A\\mathbf{T} = \\mathbf{b}$。\n\n红黑高斯-赛德尔法是求解此线性系统的一种迭代技术。它利用了五点模板的结构。网格节点被划分为两个集合，“红色”和“黑色”，如同棋盘格：如果 $i+j$ 是偶数，则节点 $(i,j)$ 是红色的；如果 $i+j$ 是奇数，则是黑色的。通过在离散方程中分离出 $T_{i,j}$，得到 $T_{i,j}$ 的更新公式：\n$$\nT_{i,j} = \\frac{1}{2(1/h_x^2 + 1/h_y^2)} \\left( \\frac{T_{i+1,j} + T_{i-1,j}}{h_x^2} + \\frac{T_{i,j+1} + T_{i,j-1}}{h_y^2} + f_{i,j} \\right)\n$$\n关键在于，任何节点的更新仅依赖于其四个最近的邻居，而这些邻居都具有相反的颜色。这种二分结构意味着所有红色节点可以仅使用黑色节点的值同时更新，反之亦然。这个特性是并行性的基础：一次红黑高斯-赛德尔迭代分两个阶段进行。首先，一次“红色扫描”并行更新所有红色节点。其次，一次“黑色扫描”使用新计算出的红色节点值并行更新所有黑色节点。\n\n这种迭代方法的收敛性是有保证的，因为对于狄利克雷边界条件，线性系统的矩阵 $A$ 是对称正定的（SPD）。$A$ 的对称性是中心差分模板对称性的直接结果。正定性可以通过证明二次型 $\\mathbf{x}^T A \\mathbf{x}$ 对应于离散的狄利克雷能量（即平方差之和）来证明，对于边界为零的任何非平凡温度场 $\\mathbf{x}$，该能量为正。高斯-赛德尔方法及其任何重排序（如红黑排序）都被证明对于任何对称正定矩阵是收敛的。迭代持续进行，直到离散残差 $r_{i,j}$ 小到可以接受的程度。残差衡量当前解 $T^{(k)}$ 满足离散方程的程度：\n$$\nr_{i,j}^{(k)} = \\frac{T_{i-1,j}^{(k)} - 2 T_{i,j}^{(k)} + T_{i+1,j}^{(k)}}{h_x^2} + \\frac{T_{i,j-1}^{(k)} - 2 T_{i,j}^{(k)} + T_{i,j+1}^{(k)}}{h_y^2} + f_{i,j}\n$$\n停止准则是 $\\max_{i,j} |r_{i,j}^{(k)}|  \\varepsilon$，其中 $\\varepsilon$ 是给定的容差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_poisson_solver(Lx, Ly, Nx, Ny, T_exact_func, f_func, epsilon, N_max):\n    \"\"\"\n    Solves the 2D Poisson equation using a red-black Gauss-Seidel iterative method.\n\n    Args:\n        Lx (float): Domain length in x-direction.\n        Ly (float): Domain length in y-direction.\n        Nx (int): Number of grid points in x-direction.\n        Ny (int): Number of grid points in y-direction.\n        T_exact_func (callable): Function T(X, Y) for the exact solution.\n        f_func (callable): Function f(X, Y) for the source term.\n        epsilon (float): Convergence tolerance for the residual.\n        N_max (int): Maximum number of iterations.\n\n    Returns:\n        float: Maximum absolute error between the numerical and exact solutions.\n    \"\"\"\n    # 1. Grid setup\n    x = np.linspace(0.0, Lx, Nx)\n    y = np.linspace(0.0, Ly, Ny)\n    hx = Lx / (Nx - 1)\n    hy = Ly / (Ny - 1)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # 2. Initialization\n    T_exact = T_exact_func(X, Y)\n    f = f_func(X, Y)\n    \n    # Initialize temperature field, with 0s for interior and BCs on boundary\n    T = np.zeros_like(T_exact)\n    T[0,  :] = T_exact[0,  :]\n    T[-1, :] = T_exact[-1, :]\n    T[:,  0] = T_exact[:,  0]\n    T[:, -1] = T_exact[:, -1]\n\n    # Pre-calculate constants for the update formula\n    inv_hx2 = 1.0 / (hx * hx)\n    inv_hy2 = 1.0 / (hy * hy)\n    denom = 2.0 * (inv_hx2 + inv_hy2)\n\n    # 3. Create red-black masks for the interior of the grid\n    # Indices for the interior grid slice [1:-1, 1:-1]\n    idx, idy = np.indices((Nx - 2, Ny - 2)) \n    # Red nodes: i+j is even. Note that indices are relative to the whole grid, \n    # so we use their original indices (idx+1, idy+1).\n    red_mask_interior = ((idx + 1) + (idy + 1)) % 2 == 0\n    black_mask_interior = np.logical_not(red_mask_interior)\n    \n    # 4. Iteration loop\n    for _ in range(N_max):\n        # --- Red Sweep ---\n        # Calculate update term for all interior points based on current T\n        T_update_term = ( (T[2:, 1:-1] + T[:-2, 1:-1]) * inv_hx2 + \\\n                          (T[1:-1, 2:] + T[1:-1, :-2]) * inv_hy2 + \\\n                          f[1:-1, 1:-1] ) / denom\n        # Apply update only to red points\n        T[1:-1, 1:-1][red_mask_interior] = T_update_term[red_mask_interior]\n\n        # --- Black Sweep ---\n        # Recalculate update term now that red points are updated\n        T_update_term = ( (T[2:, 1:-1] + T[:-2, 1:-1]) * inv_hx2 + \\\n                          (T[1:-1, 2:] + T[1:-1, :-2]) * inv_hy2 + \\\n                          f[1:-1, 1:-1] ) / denom\n        # Apply update only to black points\n        T[1:-1, 1:-1][black_mask_interior] = T_update_term[black_mask_interior]\n        \n        # 5. Check for convergence\n        if _ % 5 == 0: # Check residual every 5 iterations to save computation\n            residual = (T[2:, 1:-1] - 2*T[1:-1, 1:-1] + T[:-2, 1:-1]) * inv_hx2 + \\\n                       (T[1:-1, 2:] - 2*T[1:-1, 1:-1] + T[1:-1, :-2]) * inv_hy2 + \\\n                       f[1:-1, 1:-1]\n            max_residual = np.max(np.abs(residual))\n            if max_residual  epsilon:\n                break\n    \n    # 6. Calculate final error\n    max_abs_error = np.max(np.abs(T - T_exact))\n    return max_abs_error\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases, then prints the results.\n    \"\"\"\n    pi = np.pi\n    test_cases = [\n        # Test case 1\n        {\n            \"Lx\": 1.0, \"Ly\": 1.0, \"Nx\": 65, \"Ny\": 65,\n            \"T_exact_func\": lambda X, Y: np.sin(pi * X) * np.sin(pi * Y),\n            \"f_func\": lambda X, Y: 2 * pi**2 * np.sin(pi * X) * np.sin(pi * Y),\n            \"epsilon\": 1e-8, \"N_max\": 5000,\n        },\n        # Test case 2\n        {\n            \"Lx\": 1.0, \"Ly\": 1.0, \"Nx\": 4, \"Ny\": 4,\n            \"T_exact_func\": lambda X, Y: 0.0 * X * Y, # Ensure correct shape\n            \"f_func\": lambda X, Y: 0.0 * X * Y,\n            \"epsilon\": 1e-12, \"N_max\": 5000,\n        },\n        # Test case 3\n        {\n            \"Lx\": 2.0, \"Ly\": 1.0, \"Nx\": 63, \"Ny\": 17,\n            \"T_exact_func\": lambda X, Y: np.sin(pi * X / 2.0) * np.sin(pi * Y / 1.0),\n            \"f_func\": lambda X, Y: ( (pi/2.0)**2 + (pi/1.0)**2 ) * np.sin(pi * X / 2.0) * np.sin(pi * Y / 1.0),\n            \"epsilon\": 1e-8, \"N_max\": 5000,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        error = run_poisson_solver(\n            case[\"Lx\"], case[\"Ly\"], case[\"Nx\"], case[\"Ny\"],\n            case[\"T_exact_func\"], case[\"f_func\"],\n            case[\"epsilon\"], case[\"N_max\"]\n        )\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}