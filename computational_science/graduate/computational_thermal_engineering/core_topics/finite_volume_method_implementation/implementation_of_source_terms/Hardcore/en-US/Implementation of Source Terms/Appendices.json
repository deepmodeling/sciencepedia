{
    "hands_on_practices": [
        {
            "introduction": "A critical step in developing reliable simulation software is verification: ensuring the code correctly solves the mathematical model. This practice introduces a fundamental verification technique using a manufactured solution. We will focus on implementing a Joule heating source term, $S_J$, which depends on the gradient of the electric potential field. By testing the implementation against a case with a known analytical solution—a linear potential field—we can rigorously validate the correctness of our discretized gradient operator and the subsequent source term calculation .",
            "id": "3962599",
            "problem": "You are asked to implement and verify the numerical implementation of a volumetric Joule heating source term in a Direct Current (DC) conduction problem within a homogeneous medium. The verification centers on the case where the electric potential is linear, which implies a uniform electric field and hence a uniform Joule heating source term across the domain. The objective is to compute the source term from the discretized potential field and compare it against the analytical expectation derived from fundamental laws.\n\nFundamental base to use:\n- Ohm’s law for steady conduction: the current density is given by $\\mathbf{J} = \\boldsymbol{\\sigma}\\,\\mathbf{E}$, where $\\boldsymbol{\\sigma}$ is either a scalar electrical conductivity or a symmetric, positive-definite conductivity tensor, and $\\mathbf{E}$ is the electric field.\n- The electric field is the negative gradient of the electric potential: $\\mathbf{E} = -\\nabla \\phi$.\n- The volumetric rate of Joule heating (source term) is $S_J = \\mathbf{J} \\cdot \\mathbf{E}$, expressed in $\\mathrm{W/m^3}$.\n\nScenario:\n- Consider a rectangular, homogeneous domain in $\\mathbb{R}^d$ with a uniform grid and cell-centered variables. Let the electric potential be linear, $\\phi(\\mathbf{x}) = \\phi_0 + \\sum_{i=1}^d a_i x_i$, where $\\phi_0$ and $a_i$ are constants. This yields a uniform electric field $\\mathbf{E} = -(a_1, a_2, \\dots, a_d)$ throughout the domain and a uniform Joule heating source $S_J$.\n- For isotropic conductivity (scalar) $\\sigma$, $S_J$ is constant and equal to $\\sigma \\sum_{i=1}^d a_i^2$.\n- For anisotropic conductivity (tensor) $\\boldsymbol{\\sigma} \\in \\mathbb{R}^{d \\times d}$, symmetric and positive definite, $S_J$ is constant and equal to $\\mathbf{E}^\\mathsf{T} \\boldsymbol{\\sigma} \\mathbf{E} = \\mathbf{a}^\\mathsf{T} \\boldsymbol{\\sigma} \\mathbf{a}$, with $\\mathbf{a} = (a_1,\\dots,a_d)$.\n\nYour task:\n- Implement a program that constructs uniform grids, evaluates the linear potential at cell centers, computes numerical gradients using a consistent finite-difference scheme suitable for cell-centered data, computes the electric field and current density, and forms the Joule heating source term as $\\mathbf{J} \\cdot \\mathbf{E}$ at every cell.\n- For each test case, compare the computed field $S_J(\\mathbf{x})$ with the analytical uniform value and report the maximum absolute deviation over all cells. Express the final deviations in $\\mathrm{W/m^3}$.\n\nNumerical details:\n- Use cell-centered grids over domain lengths $(L_x, L_y, L_z)$ with $N_x, N_y, N_z$ cells per dimension.\n- Use second-order central differences in interior cells and consistent one-sided differences at domain boundaries, so a linear potential yields an exact discrete gradient.\n\nUnits:\n- Electrical conductivity $\\sigma$ and tensor components are in $\\mathrm{S/m}$.\n- Electric potential $\\phi$ is in $\\mathrm{V}$.\n- Electric field $\\mathbf{E}$ is in $\\mathrm{V/m}$.\n- Joule heating source $S_J$ is in $\\mathrm{W/m^3}$.\n- Report deviations in $\\mathrm{W/m^3}$ as floating-point numbers.\n\nTest suite:\nImplement the following $5$ test cases. For each, compute $S_J$ numerically and report the single number $\\max_{\\text{cells}} |S_J^{\\text{num}} - S_J^{\\text{analytic}}|$ in $\\mathrm{W/m^3}$.\n\n- Test $1$ (one-dimensional, isotropic, typical resolution):\n  - Dimension $d = 1$.\n  - $N_x = 51$, $L_x = 0.7$ $\\mathrm{m}$.\n  - $\\phi_0 = 2.0$ $\\mathrm{V}$, $a_1 = 3.0$ $\\mathrm{V/m}$.\n  - $\\sigma = 10.0$ $\\mathrm{S/m}$.\n- Test $2$ (two-dimensional, isotropic, mixed gradients):\n  - Dimension $d = 2$.\n  - $(N_x, N_y) = (64, 32)$, $(L_x, L_y) = (1.2, 0.8)$ $\\mathrm{m}$.\n  - $\\phi_0 = 0.0$ $\\mathrm{V}$, $(a_1, a_2) = (5.0, -4.0)$ $\\mathrm{V/m}$.\n  - $\\sigma = 2.0$ $\\mathrm{S/m}$.\n- Test $3$ (two-dimensional, anisotropic conductivity tensor):\n  - Dimension $d = 2$.\n  - $(N_x, N_y) = (33, 65)$, $(L_x, L_y) = (0.5, 0.3)$ $\\mathrm{m}$.\n  - $\\phi_0 = 1.0$ $\\mathrm{V}$, $(a_1, a_2) = (2.0, -4.0)$ $\\mathrm{V/m}$.\n  - $\\boldsymbol{\\sigma} = \\begin{bmatrix} 5.0  1.0 \\\\ 1.0  3.0 \\end{bmatrix}$ $\\mathrm{S/m}$.\n- Test $4$ (three-dimensional, isotropic, zero field edge case):\n  - Dimension $d = 3$.\n  - $(N_x, N_y, N_z) = (7, 9, 11)$, $(L_x, L_y, L_z) = (0.1, 0.2, 0.3)$ $\\mathrm{m}$.\n  - $\\phi_0 = 10.0$ $\\mathrm{V}$, $(a_1, a_2, a_3) = (0.0, 0.0, 0.0)$ $\\mathrm{V/m}$.\n  - $\\sigma = 12.0$ $\\mathrm{S/m}$.\n- Test $5$ (one-dimensional, isotropic, boundary-dominated coarse grid):\n  - Dimension $d = 1$.\n  - $N_x = 2$, $L_x = 1.0$ $\\mathrm{m}$.\n  - $\\phi_0 = -3.0$ $\\mathrm{V}$, $a_1 = 0.75$ $\\mathrm{V/m}$.\n  - $\\sigma = 7.0$ $\\mathrm{S/m}$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5]\"). Each entry must be the maximum absolute deviation for the corresponding test case expressed in $\\mathrm{W/m^3}$ as a floating-point number.",
            "solution": "The problem requires the numerical implementation and verification of a volumetric Joule heating source term, $S_J$, for a DC conduction problem in a homogeneous medium. The verification is based on a specific case where the electric potential, $\\phi$, is a linear function of position, which simplifies the analytical calculation and provides a clear benchmark for the numerical scheme.\n\nThe foundational physics is given by three principles. First, Ohm's law relates the current density vector $\\mathbf{J}$ to the electric field vector $\\mathbf{E}$ and the electrical conductivity $\\boldsymbol{\\sigma}$ as $\\mathbf{J} = \\boldsymbol{\\sigma}\\,\\mathbf{E}$. The conductivity $\\boldsymbol{\\sigma}$ can be a scalar $\\sigma$ for isotropic materials or a tensor for anisotropic materials. Second, the electric field is defined as the negative gradient of the scalar electric potential, $\\mathbf{E} = -\\nabla \\phi$. Third, the volumetric Joule heating rate, which acts as a source term in a thermal energy balance, is given by the dot product $S_J = \\mathbf{J} \\cdot \\mathbf{E}$. Substituting the first two relations into the third gives $S_J = (-\\nabla\\phi)^\\mathsf{T} \\boldsymbol{\\sigma} (-\\nabla\\phi) = (\\nabla\\phi)^\\mathsf{T} \\boldsymbol{\\sigma} (\\nabla\\phi)$.\n\nThe problem specifies a linear potential field of the form $\\phi(\\mathbf{x}) = \\phi_0 + \\sum_{i=1}^d a_i x_i$, where $\\mathbf{x}=(x_1, \\dots, x_d)$, and $\\phi_0$ and $a_i$ are constants. The gradient of this potential is a constant vector, $\\nabla\\phi = (a_1, a_2, \\dots, a_d) = \\mathbf{a}$. Consequently, the electric field is uniform throughout the domain: $\\mathbf{E} = -\\mathbf{a}$. This uniformity propagates to the current density, $\\mathbf{J} = -\\boldsymbol{\\sigma}\\mathbf{a}$, and the Joule heating source term, $S_J$. The analytical source term, $S_J^{\\text{analytic}}$, is therefore a constant value given by $S_J^{\\text{analytic}} = (-\\mathbf{a}) \\cdot (-\\boldsymbol{\\sigma}\\mathbf{a}) = \\mathbf{a}^\\mathsf{T} \\boldsymbol{\\sigma} \\mathbf{a}$. For the isotropic case where $\\boldsymbol{\\sigma}$ is the scalar $\\sigma$ times the identity matrix, this simplifies to $S_J^{\\text{analytic}} = \\sigma (\\mathbf{a} \\cdot \\mathbf{a}) = \\sigma \\sum_{i=1}^d a_i^2$.\n\nThe numerical task is to discretize the domain, compute the source term $S_J^{\\text{num}}$ at each discrete cell, and verify that it matches the constant analytical value $S_J^{\\text{analytic}}$. The core of the verification lies in the numerical computation of the gradient, $\\nabla\\phi$. The problem mandates a finite-difference scheme that is exact for a linear potential. This is a crucial requirement. A numerical gradient operator that satisfies this property will, when applied to the discrete potential field $\\phi_{i,j,\\dots}$, produce a discrete electric field $\\mathbf{E}^{\\text{num}}$ that is uniform across the grid and equal to the analytical field $-\\mathbf{a}$, up to machine precision.\n\nThe algorithm proceeds as follows:\n$1$. For each test case, define the domain dimensions $(L_x, L_y, \\dots)$, the number of cells $(N_x, N_y, \\dots)$, the potential coefficients $(\\phi_0, a_1, a_2, \\dots)$, and the conductivity $\\sigma$ or $\\boldsymbol{\\sigma}$.\n$2$. Construct a uniform, cell-centered grid. For each dimension $k \\in \\{x, y, z\\}$, the cell size is $\\Delta_k = L_k / N_k$, and the cell-center coordinates are $x_{k,i} = (i + 0.5)\\Delta_k$ for $i \\in \\{0, 1, \\dots, N_k-1\\}$. In multiple dimensions, these coordinate vectors are used to generate multidimensional coordinate arrays.\n$3$. Evaluate the linear potential $\\phi(\\mathbf{x})$ at each cell center, creating a multidimensional array $\\boldsymbol{\\Phi}$ of potential values.\n$4$. Calculate the analytical source term $S_J^{\\text{analytic}}$ using the appropriate formula, either $\\sigma \\sum a_i^2$ for isotropic cases or $\\mathbf{a}^\\mathsf{T} \\boldsymbol{\\sigma} \\mathbf{a}$ for anisotropic cases. This yields a single scalar value.\n$5$. Compute the numerical gradient of the potential field $\\boldsymbol{\\Phi}$. We employ a finite-difference scheme that is second-order accurate in the interior of the domain and first-order accurate at the boundaries. Both the central and one-sided stencils used are exact for linear functions, fulfilling the problem's requirement. The `numpy.gradient` function implements such a scheme, making it a suitable tool. This step produces arrays for each component of the gradient, e.g., $(\\nabla\\phi)_x$, $(\\nabla\\phi)_y$, etc.\n$6$. From the gradient, calculate the components of the electric field vector at each cell, $\\mathbf{E}^{\\text{num}} = -\\nabla^{\\text{num}} \\phi$. Each component $E_k^{\\text{num}}$ is a multidimensional array.\n$7$. Compute the components of the current density vector $\\mathbf{J}^{\\text{num}} = \\boldsymbol{\\sigma} \\mathbf{E}^{\\text{num}}$. In the isotropic case, this is a simple scaling: $J_k^{\\text{num}} = \\sigma E_k^{\\text{num}}$. In the anisotropic case, it is a matrix-vector multiplication at each grid point: $J_i^{\\text{num}} = \\sum_j \\sigma_{ij} E_j^{\\text{num}}$.\n$8$. Calculate the numerical source term $S_J^{\\text{num}} = \\mathbf{J}^{\\text{num}} \\cdot \\mathbf{E}^{\\text{num}} = \\sum_k J_k^{\\text{num}} E_k^{\\text{num}}$. This results in a multidimensional array where each element is the source term value in the corresponding cell.\n$9$. The final verification step is to compute the maximum absolute deviation between the numerical source term field and the constant analytical value: $\\max | S_J^{\\text{num}} - S_J^{\\text{analytic}} |$. Since the chosen numerical gradient scheme is exact for the given linear potential, all subsequent numerical calculations should also be exact, differing from the analytical solution only by floating-point round-off errors. Therefore, the expected deviation is a value very close to $0$.\n\nThis procedure is applied to each of the $5$ test cases provided, which span one, two, and three dimensions, isotropic and anisotropic conductivity, non-zero and zero fields, and grids of varying resolutions, including a coarse $2$-cell grid to test boundary condition handling. The maximum absolute deviation for each case is then reported.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_deviation(d, N, L, phi0, a, sigma):\n    \"\"\"\n    Calculates the maximum absolute deviation of the numerical Joule heating source term.\n\n    Args:\n        d (int): Number of spatial dimensions.\n        N (tuple): Number of cells in each dimension (Nx, Ny, ...).\n        L (tuple): Length of the domain in each dimension (Lx, Ly, ...).\n        phi0 (float): Constant offset for the potential function.\n        a (tuple): Coefficients of the linear terms in the potential function.\n        sigma (float or list of lists): Electrical conductivity (scalar for isotropic,\n                                        matrix for anisotropic).\n\n    Returns:\n        float: The maximum absolute deviation between the numerical and analytical\n               source terms over all cells.\n    \"\"\"\n    # 1. Create Grid\n    deltas = tuple(L[i] / N[i] for i in range(d))\n    \n    # Create 1D coordinate vectors for cell centers\n    coord_vectors = [np.linspace(0.5 * deltas[i], L[i] - 0.5 * deltas[i], N[i]) for i in range(d)]\n    \n    # Create multidimensional coordinate grids\n    if d > 1:\n        coord_grids = np.meshgrid(*coord_vectors, indexing='ij')\n    else:\n        coord_grids = coord_vectors\n\n    # 2. Evaluate Potential Field\n    phi = np.full(N, phi0, dtype=np.float64)\n    for i in range(d):\n        phi += a[i] * coord_grids[i]\n\n    # 3. Calculate Analytical Source Term\n    a_vec = np.array(a)\n    if np.isscalar(sigma):  # Isotropic case\n        S_J_analytic = sigma * np.dot(a_vec, a_vec)\n    else:  # Anisotropic case\n        sigma_mat = np.array(sigma)\n        S_J_analytic = a_vec.T @ sigma_mat @ a_vec\n\n    # 4. Calculate Numerical Gradient\n    # np.gradient uses 2nd-order central differences for interior and\n    # 1st-order one-sided differences for boundaries. Both are exact\n    # for a linear function, as required.\n    grad_phi = np.gradient(phi, *deltas)\n    \n    # np.gradient returns a single array for 1D, must be in a list for uniform handling\n    if d == 1:\n        grad_phi = [grad_phi]\n\n    # 5. Calculate Numerical Electric Field E = -grad(phi)\n    E_field = [-g for g in grad_phi]\n\n    # 6. Calculate Numerical Current Density J = sigma * E\n    if np.isscalar(sigma):  # Isotropic case\n        J_field = [sigma * e for e in E_field]\n    else:  # Anisotropic case: J_i = sum_j(sigma_ij * E_j)\n        J_field = []\n        sigma_mat = np.array(sigma)\n        for i in range(d):\n            J_comp = np.zeros(N, dtype=np.float64)\n            for j in range(d):\n                J_comp += sigma_mat[i, j] * E_field[j]\n            J_field.append(J_comp)\n\n    # 7. Calculate Numerical Source Term S_J = J . E\n    S_J_num = np.zeros(N, dtype=np.float64)\n    for i in range(d):\n        S_J_num += J_field[i] * E_field[i]\n\n    # 8. Compute Maximum Absolute Deviation\n    max_abs_dev = np.max(np.abs(S_J_num - S_J_analytic))\n    \n    return max_abs_dev\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Test 1: 1D, isotropic, typical resolution\n        {'d': 1, 'N': (51,), 'L': (0.7,), 'phi0': 2.0, 'a': (3.0,), 'sigma': 10.0},\n        \n        # Test 2: 2D, isotropic, mixed gradients\n        {'d': 2, 'N': (64, 32), 'L': (1.2, 0.8), 'phi0': 0.0, 'a': (5.0, -4.0), 'sigma': 2.0},\n        \n        # Test 3: 2D, anisotropic\n        {'d': 2, 'N': (33, 65), 'L': (0.5, 0.3), 'phi0': 1.0, 'a': (2.0, -4.0), \n         'sigma': [[5.0, 1.0], [1.0, 3.0]]},\n         \n        # Test 4: 3D, isotropic, zero field edge case\n        {'d': 3, 'N': (7, 9, 11), 'L': (0.1, 0.2, 0.3), 'phi0': 10.0, 'a': (0.0, 0.0, 0.0), \n         'sigma': 12.0},\n\n        # Test 5: 1D, isotropic, boundary-dominated coarse grid\n        {'d': 1, 'N': (2,), 'L': (1.0,), 'phi0': -3.0, 'a': (0.75,), 'sigma': 7.0}\n    ]\n\n    results = []\n    for case in test_cases:\n        deviation = calculate_deviation(case['d'], case['N'], case['L'], case['phi0'], case['a'], case['sigma'])\n        results.append(deviation)\n\n    # Format and print the final output as specified\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Many critical engineering problems, such as combustion, involve source terms that are highly non-linear and can make the governing equations numerically \"stiff.\" This exercise moves into this advanced territory by focusing on the chemical heat release source, $S_{\\mathrm{chem}}$, governed by the Arrhenius rate law. The key task is not only to compute the source term itself but also to derive and implement its partial derivative with respect to temperature, $\\frac{\\partial S_{\\mathrm{chem}}}{\\partial T}$. This derivative is a component of the system's Jacobian matrix and is essential for the convergence of the robust implicit solvers needed to tackle such stiff problems .",
            "id": "3962610",
            "problem": "Consider the volumetric chemical heat-release source term for a homogeneous reacting mixture appearing in the thermal energy equation, modeled as a sum over elementary reactions. Let the number of species be $N_{\\mathrm{s}}$ and the number of reactions be $N_{\\mathrm{r}}$. For each reaction index $r \\in \\{1,\\dots,N_{\\mathrm{r}}\\}$, the reaction progress rate is modeled by an Arrhenius power-law in terms of the mass fractions as\n$$\n\\dot{\\omega}_r(T,\\mathbf{Y}) \\;=\\; A_r \\exp\\!\\left(-\\dfrac{E_r}{R\\,T}\\right) \\prod_{k=1}^{N_{\\mathrm{s}}} Y_k^{\\nu_{kr}},\n$$\nwhere $T$ is the absolute temperature in kelvin, $\\mathbf{Y} = (Y_1,\\dots,Y_{N_{\\mathrm{s}}})$ are species mass fractions, $A_r$ is the pre-exponential factor, $E_r$ is the activation energy, $R$ is the universal gas constant, and $\\nu_{kr}\\ge 0$ are the reaction orders. The volumetric chemical heat source is modeled as\n$$\nS_{\\mathrm{chem}}(T,\\mathbf{Y}) \\;=\\; - \\sum_{r=1}^{N_{\\mathrm{r}}} \\Delta H_r \\,\\dot{\\omega}_r(T,\\mathbf{Y}),\n$$\nwhere $\\Delta H_r$ is the molar enthalpy of reaction (products minus reactants), with $\\Delta H_r0$ for exothermic reactions in this convention. Assume $A_r$, $E_r$, $\\Delta H_r$, and $\\nu_{kr}$ are constants with respect to $T$ and $\\mathbf{Y}$ in the model, and that $\\mathbf{Y}$ is held fixed when differentiating with respect to $T$ for Newton-Raphson coupling in an implicit solver.\n\nTask 1 (derivation): Starting from conservation of energy and the above definitions, derive a closed-form expression for the temperature derivative $\\partial S_{\\mathrm{chem}}/\\partial T$ at fixed $\\mathbf{Y}$, expressed directly in terms of $\\{A_r,E_r,\\Delta H_r,\\nu_{kr},R,T,\\mathbf{Y}\\}$. Your derivation must begin from the definition of $S_{\\mathrm{chem}}$ and fundamental calculus rules, not from any pre-stated shortcut formula.\n\nTask 2 (implementation): Implement a program that, for given inputs $(T,\\mathbf{Y},\\{A_r\\},\\{E_r\\},\\{\\Delta H_r\\},\\{\\nu_{kr}\\})$, computes $S_{\\mathrm{chem}}(T,\\mathbf{Y})$ and the derivative $\\partial S_{\\mathrm{chem}}/\\partial T$ using your derived expressions. Use the universal gas constant $R = 8.31446261815324\\,\\mathrm{J}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$. You may assume that each mass fraction $Y_k \\ge 0$ and $\\sum_k Y_k = 1$. Treat any zero-order dependence $Y_k^{0}$ as equal to $1$ even if $Y_k=0$.\n\nUnits: The volumetric source term $S_{\\mathrm{chem}}$ must be reported in $\\mathrm{W}\\,\\mathrm{m}^{-3}$ and the derivative $\\partial S_{\\mathrm{chem}}/\\partial T$ in $\\mathrm{W}\\,\\mathrm{m}^{-3}\\,\\mathrm{K}^{-1}$. Use the inputs such that the resulting units are consistent; in particular, interpret $\\Delta H_r$ in $\\mathrm{J}\\,\\mathrm{mol}^{-1}$ and $\\dot{\\omega}_r$ in $\\mathrm{mol}\\,\\mathrm{m}^{-3}\\,\\mathrm{s}^{-1}$ so that $S_{\\mathrm{chem}}$ has units $\\mathrm{J}\\,\\mathrm{m}^{-3}\\,\\mathrm{s}^{-1}=\\mathrm{W}\\,\\mathrm{m}^{-3}$.\n\nTest suite: Your program must compute $S_{\\mathrm{chem}}$ and $\\partial S_{\\mathrm{chem}}/\\partial T$ for the following five test cases, each specified by $(T,\\mathbf{Y},\\{A_r\\},\\{E_r\\},\\{\\Delta H_r\\},\\{\\nu_{kr}\\})$.\n\n- Case $1$ (baseline, mixed fractional orders):\n  - $N_{\\mathrm{s}} = 3$, $N_{\\mathrm{r}} = 2$.\n  - $T = 1200\\,\\mathrm{K}$.\n  - $\\mathbf{Y} = [0.70,\\,0.20,\\,0.10]$.\n  - $\\{A_r\\} = [2.0\\times 10^{7},\\,1.0\\times 10^{8}]$.\n  - $\\{E_r\\}\\,(\\mathrm{J}\\,\\mathrm{mol}^{-1}) = [8.0\\times 10^{4},\\,1.2\\times 10^{5}]$.\n  - $\\{\\Delta H_r\\}\\,(\\mathrm{J}\\,\\mathrm{mol}^{-1}) = [-2.0\\times 10^{5},\\,-5.0\\times 10^{5}]$.\n  - $\\{\\nu_{kr}\\}$ as a matrix with rows for reactions:\n    - $r=1$: $[1.0,\\,1.0,\\,0.0]$,\n    - $r=2$: $[0.5,\\,0.5,\\,0.0]$.\n\n- Case $2$ (species-depletion edge case; vanishing rate due to a zero mass fraction):\n  - $N_{\\mathrm{s}} = 3$, $N_{\\mathrm{r}} = 2$.\n  - $T = 1000\\,\\mathrm{K}$.\n  - $\\mathbf{Y} = [1.0,\\,0.0,\\,0.0]$.\n  - $\\{A_r\\} = [1.0\\times 10^{7},\\,3.0\\times 10^{7}]$.\n  - $\\{E_r\\}\\,(\\mathrm{J}\\,\\mathrm{mol}^{-1}) = [5.0\\times 10^{4},\\,1.0\\times 10^{5}]$.\n  - $\\{\\Delta H_r\\}\\,(\\mathrm{J}\\,\\mathrm{mol}^{-1}) = [-1.0\\times 10^{5},\\,-2.0\\times 10^{5}]$.\n  - $\\{\\nu_{kr}\\}$:\n    - $r=1$: $[1.0,\\,1.0,\\,0.0]$,\n    - $r=2$: $[2.0,\\,1.0,\\,0.0]$.\n\n- Case $3$ (zero activation energy in one reaction; derivative contribution vanishes for that reaction):\n  - $N_{\\mathrm{s}} = 3$, $N_{\\mathrm{r}} = 2$.\n  - $T = 900\\,\\mathrm{K}$.\n  - $\\mathbf{Y} = [0.50,\\,0.30,\\,0.20]$.\n  - $\\{A_r\\} = [3.0\\times 10^{3},\\,2.5\\times 10^{7}]$.\n  - $\\{E_r\\}\\,(\\mathrm{J}\\,\\mathrm{mol}^{-1}) = [0.0,\\,6.0\\times 10^{4}]$.\n  - $\\{\\Delta H_r\\}\\,(\\mathrm{J}\\,\\mathrm{mol}^{-1}) = [-4.0\\times 10^{5},\\,-3.0\\times 10^{5}]$.\n  - $\\{\\nu_{kr}\\}$:\n    - $r=1$: $[1.0,\\,0.0,\\,0.0]$,\n    - $r=2$: $[1.0,\\,1.0,\\,0.0]$.\n\n- Case $4$ (low temperature with a zero-order reaction; includes an endothermic reaction):\n  - $N_{\\mathrm{s}} = 3$, $N_{\\mathrm{r}} = 3$.\n  - $T = 300\\,\\mathrm{K}$.\n  - $\\mathbf{Y} = [0.20,\\,0.60,\\,0.20]$.\n  - $\\{A_r\\} = [4.0\\times 10^{8},\\,5.0\\times 10^{9},\\,1.0\\times 10^{7}]$.\n  - $\\{E_r\\}\\,(\\mathrm{J}\\,\\mathrm{mol}^{-1}) = [7.5\\times 10^{4},\\,1.1\\times 10^{5},\\,2.0\\times 10^{4}]$.\n  - $\\{\\Delta H_r\\}\\,(\\mathrm{J}\\,\\mathrm{mol}^{-1}) = [-1.0\\times 10^{5},\\,+2.0\\times 10^{5},\\,-5.0\\times 10^{4}]$.\n  - $\\{\\nu_{kr}\\}$:\n    - $r=1$: $[0.5,\\,0.5,\\,0.0]$,\n    - $r=2$: $[1.0,\\,1.0,\\,1.0]$,\n    - $r=3$: $[0.0,\\,0.0,\\,0.0]$.\n\n- Case $5$ (single reaction, zero-order in all species; purely temperature-controlled):\n  - $N_{\\mathrm{s}} = 3$, $N_{\\mathrm{r}} = 1$.\n  - $T = 1500\\,\\mathrm{K}$.\n  - $\\mathbf{Y} = [0.40,\\,0.40,\\,0.20]$.\n  - $\\{A_r\\} = [8.0\\times 10^{6}]$.\n  - $\\{E_r\\}\\,(\\mathrm{J}\\,\\mathrm{mol}^{-1}) = [9.0\\times 10^{4}]$.\n  - $\\{\\Delta H_r\\}\\,(\\mathrm{J}\\,\\mathrm{mol}^{-1}) = [-1.5\\times 10^{5}]$.\n  - $\\{\\nu_{kr}\\}$:\n    - $r=1$: $[0.0,\\,0.0,\\,0.0]$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, output a two-element list [$S_{\\mathrm{chem}}$, $\\partial S_{\\mathrm{chem}}/\\partial T$] in the stated units, with each value rounded to $6$ decimal places, and with no spaces anywhere in the line. For example, the overall output should look like $[[v_{11},v_{12}],[v_{21},v_{22}],\\dots]$ where $v_{ij}$ are decimal numbers. No other text should be printed.",
            "solution": "The problem is valid as it is scientifically grounded in chemical kinetics and thermodynamics, well-posed, objective, and provides all necessary information for a unique solution. We are tasked with two objectives: first, to derive an expression for the temperature derivative of the chemical heat source term, $\\partial S_{\\mathrm{chem}}/\\partial T$; second, to implement a program to compute both $S_{\\mathrm{chem}}$ and its derivative for a given set of test cases.\n\n### Task 1: Derivation of $\\partial S_{\\mathrm{chem}} / \\partial T$\n\nThe volumetric chemical heat source, $S_{\\mathrm{chem}}$, is defined as the sum of heat released or absorbed over all elementary reactions in the mixture:\n$$\nS_{\\mathrm{chem}}(T,\\mathbf{Y}) \\;=\\; - \\sum_{r=1}^{N_{\\mathrm{r}}} \\Delta H_r \\,\\dot{\\omega}_r(T,\\mathbf{Y})\n$$\nwhere $\\Delta H_r$ is the molar enthalpy of reaction $r$ (constant), and $\\dot{\\omega}_r$ is the progress rate of reaction $r$.\n\nTo find the partial derivative of $S_{\\mathrm{chem}}$ with respect to temperature $T$, we must differentiate the above expression while holding the mass fraction vector $\\mathbf{Y}$ constant, as specified. The derivative of a finite sum is the sum of the derivatives. Since $\\Delta H_r$ are constants, they can be factored out of the differentiation operator:\n$$\n\\frac{\\partial S_{\\mathrm{chem}}}{\\partial T} = \\frac{\\partial}{\\partial T} \\left( - \\sum_{r=1}^{N_{\\mathrm{r}}} \\Delta H_r \\,\\dot{\\omega}_r(T,\\mathbf{Y}) \\right) = - \\sum_{r=1}^{N_{\\mathrm{r}}} \\Delta H_r \\, \\frac{\\partial \\dot{\\omega}_r}{\\partial T}\n$$\n\nThe next step is to find the derivative of the reaction progress rate, $\\dot{\\omega}_r$, with respect to $T$. The rate is given by the Arrhenius power-law expression:\n$$\n\\dot{\\omega}_r(T,\\mathbf{Y}) \\;=\\; A_r \\exp\\!\\left(-\\dfrac{E_r}{R\\,T}\\right) \\prod_{k=1}^{N_{\\mathrm{s}}} Y_k^{\\nu_{kr}}\n$$\nHere, $A_r$ (pre-exponential factor), $E_r$ (activation energy), $R$ (universal gas constant), and $\\nu_{kr}$ (reaction orders) are all constants. For the partial derivative with respect to $T$, the mass fractions $Y_k$ are also treated as constants. Therefore, the product term $\\prod_{k=1}^{N_{\\mathrm{s}}} Y_k^{\\nu_{kr}}$ is a constant with respect to $T$. Let us define this product as a concentration-dependent factor $C_r(\\mathbf{Y})$:\n$$\nC_r(\\mathbf{Y}) = \\prod_{k=1}^{N_{\\mathrm{s}}} Y_k^{\\nu_{kr}}\n$$\nThis allows us to write $\\dot{\\omega}_r$ more compactly for the purpose of differentiation with respect to $T$:\n$$\n\\dot{\\omega}_r(T, \\mathbf{Y}) = A_r \\, C_r(\\mathbf{Y}) \\, \\exp\\!\\left(-\\dfrac{E_r}{R\\,T}\\right)\n$$\n\nNow we differentiate $\\dot{\\omega}_r$ with respect to $T$. The terms $A_r$ and $C_r(\\mathbf{Y})$ are constant factors.\n$$\n\\frac{\\partial \\dot{\\omega}_r}{\\partial T} = A_r \\, C_r(\\mathbf{Y}) \\, \\frac{\\partial}{\\partial T} \\left( \\exp\\!\\left(-\\dfrac{E_r}{R\\,T}\\right) \\right)\n$$\nWe apply the chain rule for differentiation. Let the argument of the exponential be $u(T) = -E_r / (RT) = -(E_r/R)T^{-1}$. The derivative of $\\exp(u(T))$ with respect to $T$ is $\\exp(u(T)) \\cdot (du/dT)$. First, we compute $du/dT$:\n$$\n\\frac{du}{dT} = \\frac{d}{dT} \\left( -\\frac{E_r}{R} T^{-1} \\right) = -\\frac{E_r}{R} (-1) T^{-2} = \\frac{E_r}{R T^2}\n$$\nSubstituting this back into the derivative of the exponential term:\n$$\n\\frac{\\partial}{\\partial T} \\left( \\exp\\!\\left(-\\dfrac{E_r}{R\\,T}\\right) \\right) = \\exp\\!\\left(-\\dfrac{E_r}{R\\,T}\\right) \\cdot \\left(\\frac{E_r}{R T^2}\\right)\n$$\nNow, substitute this result into the expression for $\\partial \\dot{\\omega}_r / \\partial T$:\n$$\n\\frac{\\partial \\dot{\\omega}_r}{\\partial T} = A_r \\, C_r(\\mathbf{Y}) \\, \\exp\\!\\left(-\\dfrac{E_r}{R\\,T}\\right) \\cdot \\left(\\frac{E_r}{R T^2}\\right)\n$$\nWe recognize that the group of terms $A_r \\, C_r(\\mathbf{Y}) \\, \\exp\\left(-E_r/(RT)\\right)$ is simply the original reaction rate $\\dot{\\omega}_r(T, \\mathbf{Y})$. This allows for a compact representation of the derivative:\n$$\n\\frac{\\partial \\dot{\\omega}_r}{\\partial T} = \\dot{\\omega}_r(T,\\mathbf{Y}) \\cdot \\frac{E_r}{R T^2}\n$$\n\nFinally, we substitute this expression for $\\partial \\dot{\\omega}_r / \\partial T$ back into our equation for $\\partial S_{\\mathrm{chem}} / \\partial T$:\n$$\n\\frac{\\partial S_{\\mathrm{chem}}}{\\partial T} = - \\sum_{r=1}^{N_{\\mathrm{r}}} \\Delta H_r \\left( \\dot{\\omega}_r(T,\\mathbf{Y}) \\cdot \\frac{E_r}{R T^2} \\right)\n$$\nRearranging the terms, we arrive at the final closed-form expression for the derivative:\n$$\n\\frac{\\partial S_{\\mathrm{chem}}}{\\partial T} = - \\sum_{r=1}^{N_{\\mathrm{r}}} \\Delta H_r \\, \\frac{E_r}{R T^2} \\, \\dot{\\omega}_r(T,\\mathbf{Y})\n$$\nThis expression can also be written in terms of the individual source contributions, $S_{\\mathrm{chem}, r} = -\\Delta H_r \\dot{\\omega}_r$, as:\n$$\n\\frac{\\partial S_{\\mathrm{chem}}}{\\partial T} = \\sum_{r=1}^{N_{\\mathrm{r}}} S_{\\mathrm{chem}, r}(T,\\mathbf{Y}) \\cdot \\frac{E_r}{R T^2}\n$$\nThis completes the derivation. The result is expressed solely in terms of the provided parameters and variables.\n\n### Task 2: Implementation\n\nThe implementation will compute $S_{\\mathrm{chem}}$ and $\\partial S_{\\mathrm{chem}}/\\partial T$ for each test case using the derived formulas. The core of the implementation is a function that takes the parameters for a single scenario ($T, \\mathbf{Y}, \\{A_r\\}, \\{E_r\\}, \\{\\Delta H_r\\}, \\{\\nu_{kr}\\}$). Inside this function, we iterate through each reaction $r=1, \\dots, N_r$. For each reaction, we compute $\\dot{\\omega}_r$ first. This value is then used to calculate the contribution of reaction $r$ to both $S_{\\mathrm{chem}}$ and its derivative $\\partial S_{\\mathrm{chem}}/\\partial T$. These contributions are summed up to obtain the total values. The calculations are vectorized using NumPy for efficiency and clarity. A special case, $Y_k^0=1$ even for $Y_k=0$, as specified in the problem, is naturally handled by Python and NumPy's `**` operator, which evaluates `0.0**0.0` to `1.0`.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It defines the test cases, computes the results, and prints them\n    in the specified format.\n    \"\"\"\n\n    # Define the universal gas constant R in J/(mol*K)\n    R = 8.31446261815324\n\n    test_cases = [\n        # Case 1: baseline, mixed fractional orders\n        {\n            \"T\": 1200.0,\n            \"Y\": [0.70, 0.20, 0.10],\n            \"A\": [2.0e7, 1.0e8],\n            \"E\": [8.0e4, 1.2e5],\n            \"delta_H\": [-2.0e5, -5.0e5],\n            \"nu\": [[1.0, 1.0, 0.0], [0.5, 0.5, 0.0]],\n        },\n        # Case 2: species-depletion edge case\n        {\n            \"T\": 1000.0,\n            \"Y\": [1.0, 0.0, 0.0],\n            \"A\": [1.0e7, 3.0e7],\n            \"E\": [5.0e4, 1.0e5],\n            \"delta_H\": [-1.0e5, -2.0e5],\n            \"nu\": [[1.0, 1.0, 0.0], [2.0, 1.0, 0.0]],\n        },\n        # Case 3: zero activation energy\n        {\n            \"T\": 900.0,\n            \"Y\": [0.50, 0.30, 0.20],\n            \"A\": [3.0e3, 2.5e7],\n            \"E\": [0.0, 6.0e4],\n            \"delta_H\": [-4.0e5, -3.0e5],\n            \"nu\": [[1.0, 0.0, 0.0], [1.0, 1.0, 0.0]],\n        },\n        # Case 4: low temperature with zero-order and endothermic reaction\n        {\n            \"T\": 300.0,\n            \"Y\": [0.20, 0.60, 0.20],\n            \"A\": [4.0e8, 5.0e9, 1.0e7],\n            \"E\": [7.5e4, 1.1e5, 2.0e4],\n            \"delta_H\": [-1.0e5, 2.0e5, -5.0e4],\n            \"nu\": [[0.5, 0.5, 0.0], [1.0, 1.0, 1.0], [0.0, 0.0, 0.0]],\n        },\n        # Case 5: single, purely temperature-controlled reaction\n        {\n            \"T\": 1500.0,\n            \"Y\": [0.40, 0.40, 0.20],\n            \"A\": [8.0e6],\n            \"E\": [9.0e4],\n            \"delta_H\": [-1.5e5],\n            \"nu\": [[0.0, 0.0, 0.0]],\n        },\n    ]\n\n    def compute_source_and_derivative(T, Y_list, A_list, E_list, delta_H_list, nu_matrix):\n        \"\"\"\n        Computes the chemical source term S_chem and its temperature derivative.\n        \n        Args:\n            T (float): Temperature in Kelvin.\n            Y_list (list): List of species mass fractions.\n            A_list (list): List of pre-exponential factors.\n            E_list (list): List of activation energies in J/mol.\n            delta_H_list (list): List of molar enthalpies of reaction in J/mol.\n            nu_matrix (list of lists): Matrix of reaction orders (Nr x Ns).\n\n        Returns:\n            tuple: A tuple containing (S_chem, dS_chem_dT).\n        \"\"\"\n        # Convert inputs to NumPy arrays for vectorized operations\n        Y = np.array(Y_list)\n        A = np.array(A_list)\n        E = np.array(E_list)\n        delta_H = np.array(delta_H_list)\n        nu = np.array(nu_matrix)\n\n        # Calculate concentration-dependent part of reaction rate, C_r = prod(Y_k^nu_kr)\n        # Broadcasting Y (shape=(Ns,)) onto nu (shape=(Nr, Ns)) results in an array\n        # of shape (Nr, Ns). We then take the product along axis=1 (species axis).\n        # This correctly handles Y_k=0 cases, including the 0^0=1 convention.\n        conc_prods = np.prod(Y**nu, axis=1)\n\n        # Calculate Arrhenius exponential term\n        exp_terms = np.exp(-E / (R * T))\n\n        # Calculate reaction progress rates, dot(omega)_r\n        omega_dots = A * exp_terms * conc_prods\n\n        # Calculate individual reaction contributions to the source term S_chem,r\n        s_chem_terms = -delta_H * omega_dots\n\n        # Sum contributions to get total S_chem\n        s_chem = np.sum(s_chem_terms)\n        \n        # Calculate the derivative using the derived formula:\n        # dS_chem/dT = sum_r S_chem,r * E_r / (R * T^2)\n        # Note: (E / (R * T**2)) term can be zero if E_r=0, which is handled correctly.\n        ds_chem_dt_terms = s_chem_terms * E / (R * T**2)\n\n        # Sum contributions to get total derivative\n        ds_chem_dt = np.sum(ds_chem_dt_terms)\n        \n        return s_chem, ds_chem_dt\n\n    results_list = []\n    for case in test_cases:\n        s_chem, ds_chem_dt = compute_source_and_derivative(\n            case[\"T\"], case[\"Y\"], case[\"A\"], case[\"E\"], case[\"delta_H\"], case[\"nu\"]\n        )\n        # Format each pair of results as requested\n        results_list.append(f\"[{s_chem:.6f},{ds_chem_dt:.6f}]\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results_list)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Our focus now shifts to transient phenomena, where source terms often depend on the evolution of the system's state over time. This practice addresses the implementation of a latent heat source for phase change (e.g., melting or solidification) using the enthalpy method. The source term is formulated based on the rate of change of the material's liquid fraction. The objective is to demonstrate that the numerical scheme is conservative, meaning that the time-integral of the discrete source power must exactly equal the total latent energy dictated by the overall change in phase. This exercise is crucial for ensuring that your transient simulations correctly conserve energy over time .",
            "id": "3962644",
            "problem": "You are given a single, spatially uniform control volume whose temperature varies in time and may undergo phase change within a prescribed mushy interval. Your task is to implement a numerically consistent phase change source term and verify energy conservation at the control volume level by integrating the source term over time. Begin from first principles of conservation of energy and the definition of enthalpy, and design a discrete algorithm that is consistent with those principles. The control volume has constant density and thermophysical properties over the time interval of interest. Assume no bulk motion and neglect spatial heat fluxes across the boundary so that the latent heat contribution is the only internal source term to be accounted for in the energy balance.\n\nUse the following foundational base:\n- Conservation of energy for a control volume: the time rate of change of total thermal energy equals the net volumetric power added. Express the total thermal energy with specific enthalpy, where the specific enthalpy is composed of a sensible part and a latent part. You may assume the specific enthalpy is given by the sum of a baseline sensible contribution and a latent contribution that depends on the liquid fraction.\n- The liquid fraction is a function of temperature defined by a piecewise linear relation across a mushy interval bounded by the solidus and liquidus temperatures.\n\nConstruct a discrete, time-accurate representation of the phase change source term that is consistent with the time rate of change of the latent part of enthalpy. Implement the following steps:\n1. For each test case, you are given a time grid $\\{t^n\\}_{n=0}^{N}$ (not necessarily uniformly spaced), a temperature history $\\{T^n\\}_{n=0}^{N}$, the density $\\rho$, the control volume $V$, the latent heat of fusion $L$, the solidus temperature $T_s$, and the liquidus temperature $T_l$.\n2. Map temperature to liquid fraction using the piecewise definition\n   - $f(T) = 0$ if $T \\le T_s$,\n   - $f(T) = 1$ if $T \\ge T_l$,\n   - $f(T) = \\dfrac{T - T_s}{T_l - T_s}$ if $T_s  T  T_l$.\n3. Define a consistent discrete phase change source power over each time step that represents the rate at which latent energy is exchanged in the control volume due to changes in liquid fraction. Your design must follow from the time derivative of the latent part of enthalpy and use only information available at discrete times $\\{t^n\\}$ and liquid fractions $\\{f^n\\}$.\n4. Compute the time integral of this discrete source over the full interval to obtain the total latent heat exchanged $Q_{\\text{int}}$ in joules.\n5. Independently compute $Q_{\\text{mass}}$, the expected latent heat based on the net mass that has changed phase over the interval, in joules.\n6. Report the absolute error $|Q_{\\text{int}} - Q_{\\text{mass}}|$ in joules for each test case.\n\nUnits and sign conventions:\n- Use the International System of Units. Temperatures are in kelvin, time in seconds, density in kilograms per cubic meter, volume in cubic meters, latent heat in joules per kilogram, and energy in joules.\n- Define the liquid fraction $f$ to increase with melting. A positive source power corresponds to energy input to accomplish melting; a negative value corresponds to energy release upon solidification.\n\nTest suite:\nImplement your program to evaluate the following five test cases. In each case, compute $Q_{\\text{int}}$ and $Q_{\\text{mass}}$ and output the absolute error in joules.\n\n- Case A (ramp through full mushy interval):\n  - $\\rho = 7800$, $V = 1\\cdot 10^{-6}$, $L = 2.7\\cdot 10^{5}$, $T_s = 600$, $T_l = 660$.\n  - Time: $t^n = n$ for $n = 0,\\dots,200$ (so $t \\in [0,200]$).\n  - Temperature: $T^n$ linearly from $580$ at $t^0$ to $680$ at $t^{200}$.\n\n- Case B (no melting, always below solidus):\n  - $\\rho = 7800$, $V = 1\\cdot 10^{-6}$, $L = 2.7\\cdot 10^{5}$, $T_s = 600$, $T_l = 660$.\n  - Time: $t^n = n$ for $n = 0,\\dots,100$ (so $t \\in [0,100]$).\n  - Temperature: $T^n = 590$ for all $n$.\n\n- Case C (partial melting within mushy band):\n  - $\\rho = 900$, $V = 2\\cdot 10^{-5}$, $L = 2.0\\cdot 10^{5}$, $T_s = 320$, $T_l = 330$.\n  - Time: $t^n = n$ for $n = 0,\\dots,50$ (so $t \\in [0,50]$).\n  - Temperature: $T^n$ linearly from $323$ at $t^0$ to $328$ at $t^{50}$.\n\n- Case D (refreezing from above liquidus to below solidus):\n  - $\\rho = 7800$, $V = 1\\cdot 10^{-6}$, $L = 2.7\\cdot 10^{5}$, $T_s = 600$, $T_l = 660$.\n  - Time: $t^n = n$ for $n = 0,\\dots,200$ (so $t \\in [0,200]$).\n  - Temperature: $T^n$ linearly from $700$ at $t^0$ to $580$ at $t^{200}$.\n\n- Case E (nonuniform time steps, crossing the mushy interval):\n  - $\\rho = 2700$, $V = 5\\cdot 10^{-6}$, $L = 3.97\\cdot 10^{5}$, $T_s = 855$, $T_l = 933$.\n  - Time: $t = [0,1,2,4,7,11,16]$.\n  - Temperature: $T = [840,850,860,900,920,940,950]$.\n\nFinal output format:\nYour program should produce a single line of output containing the absolute errors for Cases A through E, in joules, as a comma-separated list enclosed in square brackets (e.g., \"[xA,xB,xC,xD,xE]\"). Each entry must be a floating-point number in joules. Do not print any additional text. Express the numbers in joules without any unit labels in the output; the problem statement already specifies the unit.",
            "solution": "The problem is validated as scientifically grounded, well-posed, objective, and complete. It is based on the fundamental principle of energy conservation and utilizes the standard enthalpy method for modeling phase change, a cornerstone of computational thermal engineering. All required data and definitions are provided, and the task is to implement a specified numerical algorithm and verify its conservative properties. We may now proceed with the solution.\n\nThe derivation and implementation follow from the first principles of thermodynamics for a control volume.\n\n**1. Governing Principle and Enthalpy Formulation**\n\nThe fundamental principle is the conservation of energy for a control volume, which states that the time rate of change of the total energy $E$ within the volume is equal to the net rate of energy addition, $\\dot{Q}$. For a spatially uniform control volume $V$ with constant density $\\rho$ and no spatial fluxes across its boundary, this is expressed as:\n$$ \\frac{dE}{dt} = P_{source} $$\nwhere $P_{source}$ is the total power (in watts) from internal sources.\n\nThe total thermal energy $E$ is given by $E = m h = (\\rho V) h$, where $h$ is the specific enthalpy. The specific enthalpy is composed of a sensible part (related to temperature change) and a latent part (related to phase change):\n$$ h(T) = h_{sensible}(T) + h_{latent}(T) $$\nThe problem is concerned with the source term arising from the latent heat exchange. The latent part of the specific enthalpy is defined as:\n$$ h_{latent}(T) = L f(T) $$\nwhere $L$ is the specific latent heat of fusion (in J/kg) and $f(T)$ is the liquid fraction, a dimensionless quantity that varies from $0$ (fully solid) to $1$ (fully liquid).\n\n**2. Derivation of the Phase Change Source Term**\n\nThe source power due to phase change, $P_{source}$, is the time rate of change of the total latent energy in the control volume:\n$$ P_{source}(t) = \\frac{d}{dt} \\left[ \\int_V \\rho h_{latent}(T) \\, dV \\right] $$\nGiven the assumptions of spatial uniformity and constant properties, this simplifies to:\n$$ P_{source}(t) = \\rho V \\frac{d(h_{latent})}{dt} = \\rho V L \\frac{df(T)}{dt} $$\nThis equation defines the instantaneous power generated or consumed during phase transition.\n\n**3. Discretization of the Source Term and its Time Integral**\n\nTo implement this numerically, we consider a discrete set of time points $\\{t^0, t^1, \\dots, t^N\\}$ with corresponding temperatures $\\{T^0, T^1, \\dots, T^N\\}$.\n\nFirst, we calculate the liquid fraction $f^n = f(T^n)$ at each time point $t^n$ using the provided piecewise linear function:\n$$\nf(T) =\n\\begin{cases}\n0  \\text{if } T \\le T_s \\\\\n\\dfrac{T - T_s}{T_l - T_s}  \\text{if } T_s  T  T_l \\\\\n1  \\text{if } T \\ge T_l\n\\end{cases}\n$$\nwhere $T_s$ and $T_l$ are the solidus and liquidus temperatures, respectively.\n\nNext, we define a discrete representation of the source power over each time interval $[t^n, t^{n+1}]$. Using a first-order finite difference to approximate the time derivative $df/dt$, the average source power $P_{source}^n$ over the interval is:\n$$ P_{source}^n = \\rho V L \\frac{f^{n+1} - f^n}{t^{n+1} - t^n} $$\nThis expression represents the average rate of latent energy exchange over the time step $\\Delta t^n = t^{n+1} - t^n$.\n\nThe problem requires computing the total latent energy exchanged, $Q_{int}$, by integrating this discrete source power over the entire time interval $[t^0, t^N]$. The discrete integral is a summation of the energy exchanged in each time step:\n$$ Q_{int} = \\sum_{n=0}^{N-1} (\\text{average power}_n) \\times (\\text{time step duration}_n) = \\sum_{n=0}^{N-1} P_{source}^n \\Delta t^n $$\nSubstituting the expression for $P_{source}^n$:\n$$ Q_{int} = \\sum_{n=0}^{N-1} \\left( \\rho V L \\frac{f^{n+1} - f^n}{t^{n+1} - t^n} \\right) (t^{n+1} - t^n) $$\n\n**4. Verification of Energy Conservation**\n\nThe expression for $Q_{int}$ reveals a telescoping sum. The time step durations $\\Delta t^n = (t^{n+1} - t^n)$ cancel analytically in each term of the summation:\n$$ Q_{int} = \\rho V L \\sum_{n=0}^{N-1} (f^{n+1} - f^n) $$\n$$ Q_{int} = \\rho V L \\left[ (f^1 - f^0) + (f^2 - f^1) + \\dots + (f^N - f^{N-1}) \\right] $$\nThe intermediate terms cancel out, yielding:\n$$ Q_{int} = \\rho V L (f^N - f^0) $$\n\nThis result demonstrates that the chosen discrete source term formulation is exactly conservative. The total latent energy calculated by the numerical integration depends only on the initial ($f^0$) and final ($f^N$) states of the liquid fraction, not on the intermediate path or the size of the time steps.\n\nTo verify this, we compute the expected energy exchange, $Q_{mass}$, based on the net change in phase. The total mass of the control volume is $m = \\rho V$. The net mass that changes phase from solid to liquid is $m \\cdot (f^N - f^0)$. The associated latent energy is:\n$$ Q_{mass} = [m (f^N - f^0)] \\cdot L = \\rho V L (f^N - f^0) $$\n\nBy direct comparison, we see that $Q_{int} = Q_{mass}$. Therefore, the absolute error $|Q_{int} - Q_{mass}|$ is analytically zero. The implementation will follow the summation process explicitly to adhere to the problem steps. Any resulting non-zero error will be attributable solely to floating-point arithmetic inaccuracies inherent in digital computation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the phase change source term problem for five test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case A: Ramp through full mushy interval\n        {\n            \"rho\": 7800.0, \"V\": 1.0e-6, \"L\": 2.7e5, \"Ts\": 600.0, \"Tl\": 660.0,\n            \"t\": np.arange(201, dtype=float),\n            \"T\": np.linspace(580.0, 680.0, 201)\n        },\n        # Case B: No melting, always below solidus\n        {\n            \"rho\": 7800.0, \"V\": 1.0e-6, \"L\": 2.7e5, \"Ts\": 600.0, \"Tl\": 660.0,\n            \"t\": np.arange(101, dtype=float),\n            \"T\": np.full(101, 590.0)\n        },\n        # Case C: Partial melting within mushy band\n        {\n            \"rho\": 900.0, \"V\": 2.0e-5, \"L\": 2.0e5, \"Ts\": 320.0, \"Tl\": 330.0,\n            \"t\": np.arange(51, dtype=float),\n            \"T\": np.linspace(323.0, 328.0, 51)\n        },\n        # Case D: Refreezing from above liquidus to below solidus\n        {\n            \"rho\": 7800.0, \"V\": 1.0e-6, \"L\": 2.7e5, \"Ts\": 600.0, \"Tl\": 660.0,\n            \"t\": np.arange(201, dtype=float),\n            \"T\": np.linspace(700.0, 580.0, 201)\n        },\n        # Case E: Nonuniform time steps, crossing the mushy interval\n        {\n            \"rho\": 2700.0, \"V\": 5.0e-6, \"L\": 3.97e5, \"Ts\": 855.0, \"Tl\": 933.0,\n            \"t\": np.array([0.0, 1.0, 2.0, 4.0, 7.0, 11.0, 16.0]),\n            \"T\": np.array([840.0, 850.0, 860.0, 900.0, 920.0, 940.0, 950.0])\n        }\n    ]\n\n    results = []\n    \n    def liquid_fraction(T_vals, T_s, T_l):\n        \"\"\"\n        Computes the liquid fraction based on temperature using a piecewise linear model.\n        Handles scalar or numpy array inputs for temperature.\n        \"\"\"\n        # Ensure robustness against T_l = T_s, although not present in test cases.\n        if T_l = T_s:\n            return np.where(T_vals > T_s, 1.0, 0.0)\n        \n        # Calculate liquid fraction in the mushy zone\n        f = (T_vals - T_s) / (T_l - T_s)\n        \n        # Clip the result to the range [0, 1] for temperatures outside the mushy zone\n        return np.clip(f, 0.0, 1.0)\n\n    for case in test_cases:\n        rho, V, L, Ts, Tl = case[\"rho\"], case[\"V\"], case[\"L\"], case[\"Ts\"], case[\"Tl\"]\n        t, T_hist = case[\"t\"], case[\"T\"]\n        \n        # Step 2: Map temperature to liquid fraction\n        f_vals = liquid_fraction(T_hist, Ts, Tl)\n        \n        # Step 3  4: Define discrete source power and compute its time integral Q_int\n        # Calculate changes in time and liquid fraction over each step\n        dt_vals = np.diff(t)\n        df_vals = np.diff(f_vals)\n        \n        # Create a mask to handle dt=0, although not expected in these test cases\n        mask = dt_vals != 0\n        P_source_vals = np.zeros_like(dt_vals)\n        \n        # Calculate discrete power P = rho*V*L*(df/dt) for each step\n        P_source_vals[mask] = rho * V * L * (df_vals[mask] / dt_vals[mask])\n        \n        # Integrate power over time: Q_int = sum(P_n * dt_n)\n        Q_int = np.sum(P_source_vals * dt_vals)\n        \n        # Step 5: Independently compute expected latent heat Q_mass\n        f_initial = f_vals[0]\n        f_final = f_vals[-1]\n        Q_mass = rho * V * L * (f_final - f_initial)\n        \n        # Step 6: Report the absolute error\n        error = np.abs(Q_int - Q_mass)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}