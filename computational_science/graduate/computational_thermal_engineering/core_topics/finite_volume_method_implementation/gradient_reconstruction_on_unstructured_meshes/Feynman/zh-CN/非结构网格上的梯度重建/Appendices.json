{
    "hands_on_practices": [
        {
            "introduction": "任何数值方案的一个基本检验是确保它能正确反映其所近似的物理量的数学特性。对于梯度而言，一个关键性质是它在坐标旋转下的协变性。本练习  要求你实现加权最小二乘法，并设计一个严格的测试来验证其梯度计算是否遵循正确的变换规律，为后续更复杂的应用建立坚实的基础。",
            "id": "3958335",
            "problem": "考虑一个用于计算热工学的有限体积法 (FVM) 中的二维非结构化网格邻域。设一个标量温度场 $T(\\mathbf{x})$ 定义在平面上，其中 $\\mathbf{x} = (x,y)$ 的单位为米，$T$ 的单位为开尔文。梯度 $\\nabla T(\\mathbf{x})$ 的单位是开尔文/米。您将实现一个加权最小二乘梯度重构方法，并设计一个测试来验证重构的梯度在网格的刚性平移和旋转下协变变换。您的验证必须从第一性原理出发，即从梯度的定义和多变量微积分的链式法则开始推导，不得依赖任何快捷公式。\n\n平面上的刚体运动由一个平移向量 $\\mathbf{t} \\in \\mathbb{R}^2$（单位为米）和一个旋转角度 $\\theta$（单位为弧度）给出。旋转矩阵 $\\mathbf{R}(\\theta)$ 满足正交性并保持距离不变。在此运动下，网格点 $\\mathbf{x}$ 被映射到 $\\mathbf{x}' = \\mathbf{R}(\\theta)\\mathbf{x} + \\mathbf{t}$。在网格运动下物理不变量的标量场为 $T'(\\mathbf{x}') = T(\\mathbf{R}(\\theta)^{\\top}(\\mathbf{x}' - \\mathbf{t}))$，它表示在 $\\mathbf{x}'$ 的原像处求值的原始场。\n\n您必须：\n- 在中心点 $\\mathbf{x}_0$ 处，使用其邻点 $\\{\\mathbf{x}_i\\}$ 以及温度值 $T(\\mathbf{x}_0)$ 和 $T(\\mathbf{x}_i)$，通过最小化带有基于距离的权重的残差平方和，来实现加权最小二乘梯度重构，以估计 $\\mathbf{x}_0$ 处的 $\\nabla T$。使用与 $1/\\|\\mathbf{x}_i - \\mathbf{x}_0\\|^2$ 成正比的权重 $w_i$。\n- 将刚体运动 $(\\mathbf{R}(\\theta), \\mathbf{t})$ 应用于网格，得到 $\\mathbf{x}_0' = \\mathbf{R}(\\theta)\\mathbf{x}_0 + \\mathbf{t}$ 和 $\\mathbf{x}_i' = \\mathbf{R}(\\theta)\\mathbf{x}_i + \\mathbf{t}$，并如上所述定义 $T'(\\mathbf{x}')$。使用变换后的邻点和 $T'$ 在 $\\mathbf{x}_0'$ 处重构梯度。\n- 使用第一性原理（链式法则），确定原始梯度与变换后坐标系中的梯度之间为满足协变性而必须保持的理论关系。严格地使用此关系，仅根据您原始重构的梯度和刚体运动参数，计算变换后的期望梯度，不进行任何启发式校正。\n- 计算变换后期望梯度与重构梯度之间差异的欧几里得范数作为离差。以 $\\mathrm{K/m}$ 为单位表示该离差。\n\n实现该程序，并在以下测试集上进行评估。每种情况下的温度场都是线性的：$T(\\mathbf{x}) = \\alpha x + \\beta y + \\gamma$，其中 $\\alpha$ 和 $\\beta$ 的单位为 $\\mathrm{K/m}$，$\\gamma$ 的单位为 $\\mathrm{K}$。角度以弧度指定；位置以米指定。对于每个测试用例，请使用提供的中心点和邻点坐标。\n\n测试用例 1（一般刚体运动，非退化邻域）：\n- 中心点 $\\mathbf{x}_0 = (0.3,-0.4)$。\n- 邻点 $\\{(1.1,-0.5),(0.0,-0.1),(0.8,0.7),(-0.6,-0.9),(0.4,-1.2),(1.5,0.2)\\}$。\n- 场系数：$\\alpha = 2.5$，$\\beta = -1.0$，$\\gamma = 350$。\n- 旋转角度：$\\theta = 0.7$。\n- 平移：$\\mathbf{t} = (0.5,-1.0)$。\n\n测试用例 2（纯平移，非退化邻域）：\n- 中心点 $\\mathbf{x}_0 = (0.3,-0.4)$。\n- 邻点 $\\{(1.1,-0.5),(0.0,-0.1),(0.8,0.7),(-0.6,-0.9),(0.4,-1.2),(1.5,0.2)\\}$。\n- 场系数：$\\alpha = 2.5$，$\\beta = -1.0$，$\\gamma = 350$。\n- 旋转角度：$\\theta = 0.0$。\n- 平移：$\\mathbf{t} = (-3.0,4.0)$。\n\n测试用例 3（纯旋转 $\\,\\pi\\,$，不同邻域）：\n- 中心点 $\\mathbf{x}_0 = (-0.2,0.1)$。\n- 邻点 $\\{(0.5,0.6),(-0.1,-0.8),(-0.7,0.3),(0.9,-0.4),(-0.5,1.0)\\}$。\n- 场系数：$\\alpha = 1.2$，$\\beta = 3.4$，$\\gamma = 280$。\n- 旋转角度：$\\theta = \\pi$。\n- 平移：$\\mathbf{t} = (0.0,0.0)$。\n\n测试用例 4（带微小横向扰动的近共线邻域）：\n- 中心点 $\\mathbf{x}_0 = (0.0,0.0)$。\n- 邻点 $\\{(-1.0,0.001),(-0.5,-0.002),(0.3,0.0005),(0.8,-0.0015),(1.2,0.002)\\}$。\n- 场系数：$\\alpha = -0.8$，$\\beta = 0.6$，$\\gamma = 310$。\n- 旋转角度：$\\theta = \\pi/2$。\n- 平移：$\\mathbf{t} = (0.2,-0.3)$。\n\n您的程序应生成单行输出，其中包含四个测试用例的离差，以 $\\mathrm{K/m}$ 为单位，形式为方括号内以逗号分隔的列表，例如：$[d_1,d_2,d_3,d_4]$，其中每个 $d_i$ 是一个以 $\\mathrm{K/m}$ 为单位的浮点数。",
            "solution": "用户的要求是验证并解决一个关于在非结构化网格上使用加权最小二乘法重构的梯度所具有的协变变换性质的问题。\n\n### 步骤 1：提取已知条件\n- **标量场**：一个温度场 $T(\\mathbf{x})$，其中 $\\mathbf{x} = (x,y)$。用于测试的场为 $T(\\mathbf{x}) = \\alpha x + \\beta y + \\gamma$。\n- **刚体运动**：一个坐标变换 $\\mathbf{x}' = \\mathbf{R}(\\theta)\\mathbf{x} + \\mathbf{t}$，其中 $\\mathbf{R}(\\theta)$ 是一个按角度 $\\theta$ 旋转的二维旋转矩阵，$\\mathbf{t}$ 是一个平移向量。\n- **变换后的场**：新坐标系中的标量场定义为 $T'(\\mathbf{x}') = T(\\mathbf{R}(\\theta)^{\\top}(\\mathbf{x}' - \\mathbf{t}))$。\n- **梯度重构方法**：在中心点 $\\mathbf{x}_0$ 使用邻点 $\\{\\mathbf{x}_i\\}$ 的加权最小二乘法。\n- **权重**：邻点 $i$ 的权重为 $w_i \\propto 1/\\|\\mathbf{x}_i - \\mathbf{x}_0\\|^2$。我们将使用 $w_i = 1/\\|\\mathbf{x}_i - \\mathbf{x}_0\\|^2$。\n- **验证任务**：\n    1. 在原始网格中重构 $\\mathbf{x}_0$ 处的梯度 $\\nabla T$。\n    2. 在变换后的网格中重构 $\\mathbf{x}_0' = \\mathbf{R}(\\theta)\\mathbf{x}_0 + \\mathbf{t}$ 处的梯度 $\\nabla' T'$。\n    3. 使用链式法则确定原始梯度和变换后梯度之间的理论关系。\n    4. 使用此关系计算期望的变换后梯度。\n    5. 计算重构的变换后梯度与期望的变换后梯度之间的差异，定义为其差的欧几里得范数。\n- **测试用例**：提供了四个特定的测试用例，每个用例都包含：\n    - 中心点 $\\mathbf{x}_0$。\n    - 一组邻点 $\\{\\mathbf{x}_i\\}$。\n    - 温度场系数 $(\\alpha, \\beta, \\gamma)$。\n    - 旋转角度 $\\theta$。\n    - 平移向量 $\\mathbf{t}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准对问题进行评估：\n- **科学基础**：该问题根植于矢量微积分（链式法则、梯度）、线性代数（矩阵运算、最小二乘法）以及计算物理和工程（有限体积法、梯度重构）中的基本原理。所有概念都是成熟的。\n- **适定性**：问题定义清晰，信息充分。对于每个测试用例，都提供了所有必要的数据（网格点、场参数、变换参数）。只要邻点不完全共线，最小二乘问题就能得出唯一解，所有测试用例都满足此条件（测试用例 4 是“近共线”但非完全共线，这使其成为数值稳定性的一个良好测试）。\n- **客观性**：问题以精确、量化和无偏见的语言陈述。目标具体且可衡量。\n- 该问题未表现出任何无效性缺陷。它在科学上是合理的、可形式化的、完整的、现实的和结构良好的。\n\n### 步骤 3：结论与行动\n该问题被判定为**有效**。将提供一个完整的、有理有据的解答。\n\n### 基于原理的解答\n\n问题的核心是验证数值计算的梯度在坐标系刚体运动下是否能正确变换（协变）。我们首先从第一性原理推导数值方法和理论变换定律。\n\n**1. 加权最小二乘梯度重构**\n我们希望找到中心点 $\\mathbf{x}_0$ 处梯度向量 $\\mathbf{g} = \\nabla T(\\mathbf{x}_0) = (g_x, g_y)^{\\top}$ 的一个估计。基于一阶泰勒级数展开，邻点 $\\mathbf{x}_i$ 处的温度 $T_i$ 可以近似为：\n$$\nT(\\mathbf{x}_i) \\approx T(\\mathbf{x}_0) + \\nabla T(\\mathbf{x}_0) \\cdot (\\mathbf{x}_i - \\mathbf{x}_0)\n$$\n整理后，我们为每个邻点 $i$ 得到一个方程：\n$$\nT_i - T_0 \\approx g_x (x_i - x_0) + g_y (y_i - y_0)\n$$\n其中 $T_i = T(\\mathbf{x}_i)$ 且 $T_0 = T(\\mathbf{x}_0)$。令 $\\Delta T_i = T_i - T_0$ 和 $\\Delta \\mathbf{x}_i = \\mathbf{x}_i - \\mathbf{x}_0 = (\\Delta x_i, \\Delta y_i)^{\\top}$。所有 $N$ 个邻点的方程组构成一个超定线性系统 $\\mathbf{A} \\mathbf{g} \\approx \\mathbf{b}$，其中：\n$$\n\\mathbf{A} = \\begin{pmatrix} \\Delta x_1 & \\Delta y_1 \\\\ \\Delta x_2 & \\Delta y_2 \\\\ \\vdots & \\vdots \\\\ \\Delta x_N & \\Delta y_N \\end{pmatrix}, \\quad\n\\mathbf{g} = \\begin{pmatrix} g_x \\\\ g_y \\end{pmatrix}, \\quad\n\\mathbf{b} = \\begin{pmatrix} \\Delta T_1 \\\\ \\Delta T_2 \\\\ \\vdots \\\\ \\Delta T_N \\end{pmatrix}\n$$\n加权最小二乘法旨在最小化加权残差平方和：\n$$\nJ(\\mathbf{g}) = \\sum_{i=1}^{N} w_i \\left( (\\Delta x_i, \\Delta y_i) \\cdot \\mathbf{g} - \\Delta T_i \\right)^2 = (\\mathbf{A}\\mathbf{g} - \\mathbf{b})^{\\top} \\mathbf{W} (\\mathbf{A}\\mathbf{g} - \\mathbf{b})\n$$\n其中 $\\mathbf{W}$ 是一个权重对角矩阵，$W_{ii} = w_i = 1/\\|\\Delta \\mathbf{x}_i\\|^2$。通过将 $J$ 对 $\\mathbf{g}$ 的导数设为零，即 $\\frac{\\partial J}{\\partial \\mathbf{g}} = 0$，可以找到最小值，这会得到正规方程组：\n$$\n(\\mathbf{A}^{\\top}\\mathbf{W}\\mathbf{A})\\mathbf{g} = \\mathbf{A}^{\\top}\\mathbf{W}\\mathbf{b}\n$$\n梯度 $\\mathbf{g}$ 可以通过解这个 $2 \\times 2$ 线性系统得到。对于问题中给定的线性温度场 $T(\\mathbf{x}) = \\alpha x + \\beta y + \\gamma$，真实梯度是常数 $\\nabla T = (\\alpha, \\beta)^{\\top}$。近似式 $T(\\mathbf{x}_i) \\approx T(\\mathbf{x}_0) + \\nabla T \\cdot \\Delta \\mathbf{x}_i$ 变为等式，只要 $\\mathbf{A}^{\\top}\\mathbf{W}\\mathbf{A}$ 可逆（即邻点不共线），最小二乘法将恢复精确的梯度。\n\n**2. 梯度向量的协变变换**\n我们从第一性原理推导梯度的变换规则。刚体运动将点 $\\mathbf{x}$ 映射到 $\\mathbf{x}' = \\mathbf{R}\\mathbf{x} + \\mathbf{t}$。从变换后坐标返回原始坐标的逆映射是 $\\mathbf{x}(\\mathbf{x}') = \\mathbf{R}^{-1}(\\mathbf{x}' - \\mathbf{t})$。由于旋转矩阵 $\\mathbf{R}$ 是正交的，所以 $\\mathbf{R}^{-1} = \\mathbf{R}^{\\top}$，因此：\n$$\n\\mathbf{x}(\\mathbf{x}') = \\mathbf{R}^{\\top}(\\mathbf{x}' - \\mathbf{t})\n$$\n标量温度场是物理不变量，因此其在某物理点的值与描述该点的坐标系无关。因此，变换后的场定义为 $T'(\\mathbf{x}') = T(\\mathbf{x}(\\mathbf{x}'))$。\n\n我们寻求 $T'$ 相对于新坐标 $\\mathbf{x}' = (x', y')$ 的梯度。我们使用多变量链式法则。梯度 $\\nabla' T' = (\\frac{\\partial T'}{\\partial x'}, \\frac{\\partial T'}{\\partial y'})^{\\top}$ 的分量是：\n$$\n\\frac{\\partial T'}{\\partial x'_k} = \\sum_{j=1}^{2} \\frac{\\partial T}{\\partial x_j} \\frac{\\partial x_j}{\\partial x'_k}\n$$\n这可以表示为矩阵形式。为了便于推导，我们将梯度向量视为行向量。那么 $(\\nabla' T')_{\\text{row}} = (\\nabla T)_{\\text{row}} \\mathbf{J}$，其中 $\\mathbf{J}$ 是逆映射 $\\mathbf{x}(\\mathbf{x'})$ 的雅可比矩阵：\n$$\n\\mathbf{J} = \\frac{\\partial \\mathbf{x}}{\\partial \\mathbf{x'}} = \\begin{pmatrix} \\frac{\\partial x}{\\partial x'} & \\frac{\\partial x}{\\partial y'} \\\\ \\frac{\\partial y}{\\partial x'} & \\frac{\\partial y}{\\partial y'} \\end{pmatrix}\n$$\n从映射关系 $\\mathbf{x}(\\mathbf{x}') = \\mathbf{R}^{\\top}\\mathbf{x}' - \\mathbf{R}^{\\top}\\mathbf{t}$ 可知，雅可比矩阵就是 $\\mathbf{x}'$ 的常数矩阵系数，即 $\\mathbf{R}^{\\top}$。\n$$\n\\mathbf{J} = \\mathbf{R}^{\\top}\n$$\n将此代入链式法则表达式中，得到 $(\\nabla' T')_{\\text{row}} = (\\nabla T)_{\\text{row}} \\mathbf{R}^{\\top}$。将两边转置以返回到列向量形式：\n$$\n\\nabla' T' = (\\mathbf{R}^{\\top})^{\\top} (\\nabla T) = \\mathbf{R} (\\nabla T)\n$$\n这是梯度向量（一阶协变张量）的理论变换定律。新坐标系中的梯度向量是通过用相同的旋转矩阵 $\\mathbf{R}$ 旋转原始梯度向量得到的。平移 $\\mathbf{t}$ 不影响梯度。这就是在变换框架中的“期望”梯度。\n\n**3. 验证流程**\n验证算法如下：\n1.  **原始重构**：对于给定的测试用例，计算中心点和邻点的温度 $T_0$ 和 $T_i$。求解加权最小二乘系统 $(\\mathbf{A}^{\\top}\\mathbf{W}\\mathbf{A})\\mathbf{g}_{\\text{orig}} = \\mathbf{A}^{\\top}\\mathbf{W}\\mathbf{b}$ 以找到原始重构梯度 $\\mathbf{g}_{\\text{orig}}$。\n2.  **变换后重构**：\n    a. 将刚体运动应用于所有点：$\\mathbf{x}'_0 = \\mathbf{R}\\mathbf{x}_0 + \\mathbf{t}$ 和 $\\mathbf{x}'_i = \\mathbf{R}\\mathbf{x}_i + \\mathbf{t}$。\n    b. 变换后点 $\\mathbf{x}'_i$ 的温度是 $T'(\\mathbf{x}'_i) = T(\\mathbf{x}_i)$。因此，对应点的温度值保持不变。\n    c. 为变换后的几何结构求解一个新的加权最小二乘系统 $(\\mathbf{A}'^{\\top}\\mathbf{W}'\\mathbf{A}')\\mathbf{g}'_{\\text{recon}} = \\mathbf{A}'^{\\top}\\mathbf{W}'\\mathbf{b}'$，以找到新框架中的重构梯度 $\\mathbf{g}'_{\\text{recon}}$。\n3.  **期望梯度**：使用导出的协变定律计算期望的变换后梯度：$\\mathbf{g}'_{\\text{exp}} = \\mathbf{R} \\mathbf{g}_{\\text{orig}}$。\n4.  **离差**：计算重构的变换后梯度与期望的变换后梯度之差的欧几里得范数：$d = \\| \\mathbf{g}'_{\\text{recon}} - \\mathbf{g}'_{\\text{exp}} \\|_2$。\n\n因为所选的权重 $w_i = 1/\\|\\Delta\\mathbf{x}_i\\|^2$ 是基于距离的，而距离在刚体运动下是不变的（$w'_i = w_i$），所以该数值方案本身是完全协变的。如在思考过程中所示，可以解析地证明 $\\mathbf{g}'_{\\text{recon}} = \\mathbf{R} \\mathbf{g}_{\\text{orig}}$。因此，计算出的离差 $d$ 应该为零，仅受浮点运算精度的限制。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the gradient reconstruction covariance problem for all test cases.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"x0\": np.array([0.3, -0.4]),\n            \"neighbors\": np.array([\n                [1.1, -0.5], [0.0, -0.1], [0.8, 0.7], \n                [-0.6, -0.9], [0.4, -1.2], [1.5, 0.2]\n            ]),\n            \"field_coeffs\": (2.5, -1.0, 350.0), # alpha, beta, gamma\n            \"theta\": 0.7,\n            \"t\": np.array([0.5, -1.0]),\n        },\n        {\n            \"x0\": np.array([0.3, -0.4]),\n            \"neighbors\": np.array([\n                [1.1, -0.5], [0.0, -0.1], [0.8, 0.7], \n                [-0.6, -0.9], [0.4, -1.2], [1.5, 0.2]\n            ]),\n            \"field_coeffs\": (2.5, -1.0, 350.0),\n            \"theta\": 0.0,\n            \"t\": np.array([-3.0, 4.0]),\n        },\n        {\n            \"x0\": np.array([-0.2, 0.1]),\n            \"neighbors\": np.array([\n                [0.5, 0.6], [-0.1, -0.8], [-0.7, 0.3], \n                [0.9, -0.4], [-0.5, 1.0]\n            ]),\n            \"field_coeffs\": (1.2, 3.4, 280.0),\n            \"theta\": np.pi,\n            \"t\": np.array([0.0, 0.0]),\n        },\n        {\n            \"x0\": np.array([0.0, 0.0]),\n            \"neighbors\": np.array([\n                [-1.0, 0.001], [-0.5, -0.002], [0.3, 0.0005], \n                [0.8, -0.0015], [1.2, 0.002]\n            ]),\n            \"field_coeffs\": (-0.8, 0.6, 310.0),\n            \"theta\": np.pi / 2,\n            \"t\": np.array([0.2, -0.3]),\n        }\n    ]\n\n    results = []\n\n    def reconstruct_gradient(center_point, neighbor_points, center_temp, neighbor_temps):\n        \"\"\"\n        Implements weighted least-squares gradient reconstruction.\n        \n        Args:\n            center_point (np.ndarray): 1D array of shape (2,) for the center point coords.\n            neighbor_points (np.ndarray): 2D array of shape (N, 2) for neighbor coords.\n            center_temp (float): Temperature at the center point.\n            neighbor_temps (np.ndarray): 1D array of shape (N,) for neighbor temperatures.\n            \n        Returns:\n            np.ndarray: The reconstructed gradient vector of shape (2,).\n        \"\"\"\n        delta_x = neighbor_points - center_point\n        delta_T = neighbor_temps - center_temp\n        \n        # Weights proportional to 1/distance^2\n        # Add a small epsilon to avoid division by zero if a neighbor is at the center\n        distances_sq = np.sum(delta_x**2, axis=1)\n        weights = 1.0 / (distances_sq + 1e-15)\n        \n        W = np.diag(weights)\n        A = delta_x\n        b = delta_T\n        \n        # Normal equations: (A^T W A) g = A^T W b\n        A_T_W_A = A.T @ W @ A\n        A_T_W_b = A.T @ W @ b\n        \n        gradient = np.linalg.solve(A_T_W_A, A_T_W_b)\n        return gradient\n\n    for case in test_cases:\n        x0 = case[\"x0\"]\n        neighbors = case[\"neighbors\"]\n        alpha, beta, gamma = case[\"field_coeffs\"]\n        theta = case[\"theta\"]\n        t = case[\"t\"]\n        \n        # Define the linear temperature field\n        temp_field = lambda p: alpha * p[..., 0] + beta * p[..., 1] + gamma\n\n        # --- 1. Original Gradient Reconstruction ---\n        T0 = temp_field(x0)\n        Ti = temp_field(neighbors)\n        grad_orig = reconstruct_gradient(x0, neighbors, T0, Ti)\n        \n        # --- 2. Transformed Gradient Reconstruction ---\n        # Rotation matrix\n        c, s = np.cos(theta), np.sin(theta)\n        R = np.array([[c, -s], [s, c]])\n        \n        # Apply rigid motion to mesh points\n        x0_prime = R @ x0 + t\n        neighbors_prime = (R @ neighbors.T).T + t\n        \n        # Per problem statement T'(x') = T(R^T(x'-t)), so T'(x_i') = T(x_i).\n        # Temperature values at corresponding points are identical.\n        T0_prime = T0\n        Ti_prime = Ti\n        \n        grad_prime_recon = reconstruct_gradient(x0_prime, neighbors_prime, T0_prime, Ti_prime)\n        \n        # --- 3. Expected Transformed Gradient ---\n        # Apply covariance transformation law: grad' = R * grad\n        grad_prime_expected = R @ grad_orig\n        \n        # --- 4. Compute Discrepancy ---\n        discrepancy = np.linalg.norm(grad_prime_recon - grad_prime_expected)\n        results.append(discrepancy)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个正确的实现方案在高质量网格上表现良好，但真实世界的应用常常包含非理想的网格单元。本练习  探讨了最小二乘法的一个关键失效模式：当邻近单元中心近似共线时产生的数值不稳定。你将分析多种基于第一性原理的修正策略，学会在保证数值稳定性的同时，维持“线性场重构精确性”这一至关重要的性质。",
            "id": "3958296",
            "problem": "在用于稳态热传导的二维 ($2\\mathrm{D}$) 单元中心有限体积法 (FVM) 中，通过单元面的扩散通量使用傅里叶定律 $\\mathbf{q}=-k\\nabla T$ 计算，这需要在每个单元形心处稳定且准确地重构温度梯度 $\\nabla T$。考虑在一个单元 $P$ 中，利用其相邻单元中心 $\\{\\mathbf{x}_i\\}$，基于关于形心 $\\mathbf{x}_P$ 的一阶泰勒展开，使用最小二乘 (LS) 格式来重构 $\\nabla T$，\n$$\nT(\\mathbf{x}_i)=T(\\mathbf{x}_P)+\\nabla T\\cdot(\\mathbf{x}_i-\\mathbf{x}_P)+\\mathcal{O}(\\|\\mathbf{x}_i-\\mathbf{x}_P\\|^2).\n$$\n定义 $\\Delta\\mathbf{x}_i=\\mathbf{x}_i-\\mathbf{x}_P$ 并最小化\n$$\nJ(\\mathbf{g})=\\sum_i w_i\\left[T(\\mathbf{x}_i)-T(\\mathbf{x}_P)-\\mathbf{g}\\cdot\\Delta\\mathbf{x}_i\\right]^2,\n$$\n其中权重 $w_i>0$，$\\mathbf{g}$ 是在 $\\mathbf{x}_P$ 处重构的梯度。正规方程组为\n$$\n\\left(\\sum_i w_i\\,\\Delta\\mathbf{x}_i\\Delta\\mathbf{x}_i^{\\top}\\right)\\mathbf{g}=\\sum_i w_i\\,\\Delta\\mathbf{x}_i\\left[T(\\mathbf{x}_i)-T(\\mathbf{x}_P)\\right].\n$$\n假设邻居的偏移量近似共线，即存在一个标准正交基 $\\{\\mathbf{e},\\mathbf{n}\\}$ 使得\n$$\n\\Delta\\mathbf{x}_i=d_i\\,\\mathbf{e}+\\epsilon_i\\,\\mathbf{n},\\quad \\text{其中 }\\sum_i w_i\\,\\epsilon_i^2\\ll \\sum_i w_i\\,d_i^2.\n$$\n那么正规矩阵\n$$\n\\mathbf{A}=\\sum_i w_i\\,\\Delta\\mathbf{x}_i\\Delta\\mathbf{x}_i^{\\top}\n$$\n有一个与 $\\mathbf{e}$ 相关的大特征值和一个与 $\\mathbf{n}$ 相关的非常小的特征值，从而导致一个大的条件数和对 $\\mathbf{g}$ 的 $\\mathbf{n}$ 分量的不稳定估计。\n\n根据梯度的基本定义（通过泰勒展开）和散度定理，\n$$\n\\int_V \\nabla T\\,\\mathrm{d}V=\\int_{\\partial V}T\\,\\mathbf{n}\\,\\mathrm{d}S,\n$$\n任何补救措施都必须要么增加独立的方向信息，要么对可观测性差的分量进行正则化，同时保持对线性场的相容性，以使非退化模板保持线性精确性。\n\n以下哪种补救措施是在这种退化的二维模板中保持梯度分量稳定，同时在非退化情况下保留线性精确性的、合理的、基于原则的方法？\n\nA. 增加与近共线方向最对齐的邻居的权重 $w_i$，以减小估计器在该方向上的方差。\n\nB. 用一个或多个源自散度定理 (格林-高斯) 的面法向方程来增强 LS 系统，例如，引入软约束 $\\mathbf{g}\\approx \\frac{1}{|V_P|}\\sum_{f\\in\\partial V_P}T_f\\,\\mathbf{n}_f\\,A_f$，其约束权重随着局部网格尺寸 $h\\to 0$ 而消失，从而在模板非退化时增加独立的方向信息，而不改变对线性 $T$ 的精确性。\n\nC. 对 LS 正规方程组应用具有固定参数 $\\lambda>0$ 的各向同性 Tikhonov 正则化，即求解 $\\left(\\mathbf{A}+\\lambda\\mathbf{I}\\right)\\mathbf{g}=\\mathbf{b}$，这总能稳定解并为非退化模板保留线性精确性。\n\nD. 扩大模板以包含额外的非共线邻居（例如，第二环单元中心或边界面点），使得 $\\sum_i w_i\\,\\epsilon_i^2$ 与 $\\sum_i w_i\\,d_i^2$ 相当，从而恢复满秩并改善 $\\mathbf{A}$ 的条件数。\n\nE. 旋转坐标系，使 $\\mathbf{e}$ 与 x 轴对齐，并且当 $\\mathbf{A}$ 的条件数超过阈值时，将正交梯度分量 $g_n$ 设置为零，从而避免在观测不良的方向上放大噪声。\n\n选择所有适用的选项。确保您的选择基于基本原理和关于稳定性和在非退化模板中保留线性精确性的既定标准进行论证。",
            "solution": "用户提供了一个关于计算热工学中有限体积法 (FVM) 背景下梯度重构数值方法的问题。任务是验证问题陈述的有效性，然后评估针对由近共线单元模板引起的病态最小二乘系统的几种建议补救措施。\n\n### 问题验证\n\n首先，在尝试求解之前，必须对问题陈述的科学合理性、自洽性和清晰度进行验证。\n\n**步骤 1：提取已知条件**\n\n问题陈述提供了以下信息：\n1.  **背景**：用于稳态热传导的二维单元中心有限体积法。\n2.  **控制定律**：扩散通量的傅里叶定律为 $\\mathbf{q}=-k\\nabla T$。\n3.  **梯度重构方法**：使用最小二乘 (LS) 格式来寻找单元形心 $\\mathbf{x}_P$ 处的温度梯度 $\\mathbf{g} \\approx \\nabla T$。\n4.  **LS 方法的基础**：关于 $\\mathbf{x}_P$ 的一阶泰勒级数展开：$T(\\mathbf{x}_i)=T(\\mathbf{x}_P)+\\nabla T\\cdot(\\mathbf{x}_i-\\mathbf{x}_P)+\\mathcal{O}(\\|\\mathbf{x}_i-\\mathbf{x}_P\\|^2)$。\n5.  **定义**：从单元中心 $P$ 到邻居 $i$ 的向量为 $\\Delta\\mathbf{x}_i=\\mathbf{x}_i-\\mathbf{x}_P$。\n6.  **LS 目标函数**：要最小化的函数是 $J(\\mathbf{g})=\\sum_i w_i\\left[T(\\mathbf{x}_i)-T(\\mathbf{x}_P)-\\mathbf{g}\\cdot\\Delta\\mathbf{x}_i\\right]^2$，权重 $w_i>0$。\n7.  **正规方程组**：$J(\\mathbf{g})$ 的最小化导致线性系统 $\\mathbf{A}\\mathbf{g}=\\mathbf{b}$，其中正规矩阵为 $\\mathbf{A}=\\left(\\sum_i w_i\\,\\Delta\\mathbf{x}_i\\Delta\\mathbf{x}_i^{\\top}\\right)$，右侧项为 $\\mathbf{b}=\\sum_i w_i\\,\\Delta\\mathbf{x}_i\\left[T(\\mathbf{x}_i)-T(\\mathbf{x}_P)\\right]$。\n8.  **退化条件**：问题考虑了近共线的邻居偏移量，其特征在于存在一个标准正交基 $\\{\\mathbf{e},\\mathbf{n}\\}$，使得 $\\Delta\\mathbf{x}_i=d_i\\,\\mathbf{e}+\\epsilon_i\\,\\mathbf{n}$，且几何条件为 $\\sum_i w_i\\,\\epsilon_i^2\\ll \\sum_i w_i\\,d_i^2$。\n9.  **退化的后果**：矩阵 $\\mathbf{A}$ 的条件数很大，导致沿 $\\mathbf{n}$ 方向的梯度分量估计不稳定。\n10. **基本原理**：散度定理（或格林-高斯定理）将梯度的体积分与面积分联系起来：$\\int_V \\nabla T\\,\\mathrm{d}V=\\int_{\\partial V}T\\,\\mathbf{n}\\,\\mathrm{d}S$。\n11. **补救措施的标准**：任何有效的补救措施都必须：\n    *   提供稳定性（例如，通过增加独立的方向信息或通过正则化）。\n    *   为非退化模板保留线性精确性。“线性精确性”意味着该方案必须为任何位置的线性函数形式的温度场精确重构梯度。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n*   **科学基础**：该问题牢固地植根于偏微分方程数值方法的成熟理论，特别是有限体积法。最小二乘法用于数据拟合、泰勒级数用于局部逼近、散度定理以及矩阵条件数分析都是应用数学和工程中的标准、基本概念。退化模板导致的病态问题是 FVM 中一个众所周知的实践和理论挑战。\n*   **适定性**：该问题是适定的。它清晰地定义了一个技术挑战，并要求根据明确定义的具体标准（稳定性和线性精确性）评估提出的解决方案。\n*   **客观性**：语言正式、精确、客观。它使用了计算物理和数值分析领域的标准数学符号和术语。没有主观或模糊的陈述。\n\n**步骤 3：结论与行动**\n\n问题陈述是 **有效的**。它在科学上是合理的、自洽的，并且是客观表述的。它提出了一个关于数值算法属性的有意义的问题。可以开始求解过程。\n\n### 求解与选项分析\n\n问题的核心是为邻居点近共线时病态的矩阵 $\\mathbf{A}$ 寻找补救措施，同时满足“线性精确性”这一关键约束。如果对于任何线性温度场 $T(\\mathbf{x}) = T_P + \\mathbf{c} \\cdot (\\mathbf{x} - \\mathbf{x}_P)$，重构的梯度 $\\mathbf{g}$ 都精确等于真实的常数梯度 $\\mathbf{c}$，那么该梯度重构方案就具有线性精确性。\n\n我们首先验证标准 LS 方法对于非退化模板是否具有线性精确性。\n如果 $T(\\mathbf{x}_i) = T_P + \\mathbf{c} \\cdot (\\mathbf{x}_i - \\mathbf{x}_P)$，那么 $T(\\mathbf{x}_i) - T_P = \\mathbf{c} \\cdot \\Delta\\mathbf{x}_i = \\Delta\\mathbf{x}_i^{\\top}\\mathbf{c}$。\n正规方程组的右侧项变为：\n$$\n\\mathbf{b} = \\sum_i w_i\\,\\Delta\\mathbf{x}_i\\left[T(\\mathbf{x}_i)-T_P\\right] = \\sum_i w_i\\,\\Delta\\mathbf{x}_i(\\Delta\\mathbf{x}_i^{\\top}\\mathbf{c}) = \\left(\\sum_i w_i\\,\\Delta\\mathbf{x}_i\\Delta\\mathbf{x}_i^{\\top}\\right)\\mathbf{c} = \\mathbf{A}\\mathbf{c}.\n$$\n正规方程组为 $\\mathbf{A}\\mathbf{g} = \\mathbf{A}\\mathbf{c}$。如果模板非退化，邻居向量 $\\Delta\\mathbf{x}_i$ 不全共线，矩阵 $\\mathbf{A}$ 是可逆的。在这种情况下，唯一解是 $\\mathbf{g} = \\mathbf{c}$。因此，对于非退化模板，标准的 LS 方法确实具有线性精确性。\n\n现在，我们评估每种建议的补救措施。\n\n**A. 增加与近共线方向最对齐的邻居的权重 $w_i$，以减小估计器在该方向上的方差。**\n\n这个选项建议修改权重 $w_i$。病态问题源于 $\\sum_i w_i\\,\\epsilon_i^2 \\ll \\sum_i w_i\\,d_i^2$。“与近共线方向最对齐的邻居”是那些 $|\\epsilon_i|$ 相对于 $|d_i|$ 较小的邻居。增加它们的权重 $w_i$ 将使 $\\sum_i w_i\\,d_i^2$ 的值更大，而对 $\\sum_i w_i\\,\\epsilon_i^2$ 的影响很小。这将加剧两个和之间的差异，导致矩阵 $\\mathbf{A}$ 的条件数*更大*。这种策略对稳定系统是适得其反的。更合乎逻辑的做法是增加在正交方向 $\\mathbf{n}$ 上提供信息的邻居的权重（即那些 $|\\epsilon_i|$ 较大的邻居），但该选项的陈述恰恰相反。\n\n**结论：不正确。**\n\n**B. 用一个或多个源自散度定理 (格林-高斯) 的面法向方程来增强 LS 系统，例如，引入软约束 $\\mathbf{g}\\approx \\frac{1}{|V_P|}\\sum_{f\\in\\partial V_P}T_f\\,\\mathbf{n}_f\\,A_f$，其约束权重随着局部网格尺寸 $h\\to 0$ 而消失，从而在模板非退化时增加独立的方向信息，而不改变对线性 $T$ 的精确性。**\n\n这提出了一种混合的格林-高斯/最小二乘 (GG-LS) 方法。格林-高斯梯度 $\\mathbf{g}_{GG} = \\frac{1}{|V_P|}\\sum_f T_f \\mathbf{n}_f A_f$ 提供了一个基于面信息的独立梯度估计。对于一个典型的多边形单元，面法向向量 $\\{\\mathbf{n}_f\\}$ 不共线，因此它们可以提供方向信息，从而对病态的 LS 系统进行正则化。这解决了稳定性的要求。\n\n接下来，我们检查线性精确性。如前文所述，标准的 LS 格式具有线性精确性。我们必须检查 GG 部分是否也具有线性精确性。对于线性场 $T(\\mathbf{x}) = T_0 + \\mathbf{c} \\cdot \\mathbf{x}$，精确的体积平均梯度是 $\\frac{1}{|V|} \\int_V \\nabla T \\,dV = \\mathbf{c}$。格林-高斯定理指出这等于 $\\frac{1}{|V|} \\int_{\\partial V} T \\mathbf{n} \\,dS$。对于多边形单元，标准离散化 $\\frac{1}{|V_P|}\\sum_f T_f \\mathbf{n}_f A_f$（其中 $T_f$ 是面心的温度）可以精确地计算这个积分，得到 $\\mathbf{c}$。因此，GG 梯度估计也具有线性精确性。\n由于 LS 部分和 GG 约束对于线性场都由 $\\mathbf{g}=\\mathbf{c}$ 精确满足，它们的组合（作为新最小化问题中的加权和）也将产生 $\\mathbf{g}=\\mathbf{c}$。该方法保留了线性精确性。权重随着 $h \\to 0$ 而消失的条件使得该方案在模板非退化的细网格上渐近地由高阶 LS 项主导。这是一种合理的、基于原则且被广泛使用的技术。\n\n**结论：正确。**\n\n**C. 对 LS 正规方程组应用具有固定参数 $\\lambda>0$ 的各向同性 Tikhonov 正则化，即求解 $\\left(\\mathbf{A}+\\lambda\\mathbf{I}\\right)\\mathbf{g}=\\mathbf{b}$，这总能稳定解并为非退化模板保留线性精确性。**\n\n这种方法，即 Tikhonov 正则化，通过求解 $(\\mathbf{A}+\\lambda\\mathbf{I})\\mathbf{g}=\\mathbf{b}$ 来稳定系统。加上 $\\lambda\\mathbf{I}$ 会使 $\\mathbf{A}$ 的特征值移动 $\\lambda$，使得正则化后的矩阵 $\\mathbf{A}+\\lambda\\mathbf{I}$ 条件良好且可逆，即使 $\\mathbf{A}$ 是奇异的。所以，它“总能稳定解”。\n\n然而，我们必须检查线性精确性。如前所述，对于线性场，正规方程组为 $\\mathbf{A}\\mathbf{g}=\\mathbf{A}\\mathbf{c}$。正则化后的系统变为 $(\\mathbf{A}+\\lambda\\mathbf{I})\\mathbf{g} = \\mathbf{A}\\mathbf{c}$。解为 $\\mathbf{g} = (\\mathbf{A}+\\lambda\\mathbf{I})^{-1}\\mathbf{A}\\mathbf{c}$。为了使 $\\mathbf{g}$ 等于 $\\mathbf{c}$，我们需要 $(\\mathbf{A}+\\lambda\\mathbf{I})^{-1}\\mathbf{A}$ 是单位矩阵 $\\mathbf{I}$。对于任何 $\\lambda>0$ 和可逆的 $\\mathbf{A}$，这都不成立。解是偏向于零的（因为这种形式的正则化对应于最小化 $J(\\mathbf{g})+\\lambda\\|\\mathbf{g}\\|^2$）。这种方法为了稳定性牺牲了线性精确性。因此，其“保留线性精确性”的说法是错误的。\n\n**结论：不正确。**\n\n**D. 扩大模板以包含额外的非共线邻居（例如，第二环单元中心或边界面点），使得 $\\sum_i w_i\\,\\epsilon_i^2$ 与 $\\sum_i w_i\\,d_i^2$ 相当，从而恢复满秩并改善 $\\mathbf{A}$ 的条件数。**\n\n这种方法解决了问题的根本原因：模板的几何缺陷。通过添加更多与初始集合不对齐的数据点（邻居），新的点集 $\\{\\Delta\\mathbf{x}_i\\}$ 不再是近共线的。这直接增加了 $\\sum w_i \\epsilon_i^2$ 相对于 $\\sum w_i d_i^2$ 的大小，使得矩阵 $\\mathbf{A}$ 条件良好且可逆。这直接提高了稳定性。\n\n该方法仍然是纯粹的最小二乘重构。如初始分析所示，只要矩阵 $\\mathbf{A}$ 可逆，LS 方法本身就具有线性精确性。扩大模板不会改变这一基本属性。唯一的权衡是更高的计算成本和对非线性场可能更大的截断误差（由于距离 $\\|\\Delta\\mathbf{x}_i\\|$ 更大），但它完美地满足了稳定性和线性精确性的既定标准。这是一种非常常见且有效的策略。\n\n**结论：正确。**\n\n**E. 旋转坐标系，使 $\\mathbf{e}$ 与 x 轴对齐，并且当 $\\mathbf{A}$ 的条件数超过阈值时，将正交梯度分量 $g_n$ 设置为零，从而避免在观测不良的方向上放大噪声。**\n\n旋转坐标系是一种简化表示的基变换，但并不改变问题的内在性质。这种方法的核心是识别分辨率差的梯度方向 ($\\mathbf{n}$) 并人为地将相应的梯度分量 ($g_n$) 设置为零。这肯定会防止在该分量中放大数值误差，从而提供一种形式的稳定性。\n\n然而，考虑线性精确性标准。如果真实的温度场是线性的，其梯度为 $\\mathbf{c} = c_e \\mathbf{e} + c_n \\mathbf{n}$ 且 $c_n \\neq 0$，这种方法将产生一个在 $\\mathbf{n}$ 方向分量为零的重构梯度 $\\mathbf{g}$。因此，$\\mathbf{g} \\neq \\mathbf{c}$。除非真实梯度恰好在病态方向上没有分量，否则该方法不具有线性精确性。由于补救措施必须对任何线性场都保留精确性，所以这种方法失败了。它通过丢弃解中一个可能非零的部分而引入了系统误差。\n\n**结论：不正确。**",
            "answer": "$$\\boxed{BD}$$"
        },
        {
            "introduction": "最后的这项练习综合了前面所学的知识。在工业级软件中，没有任何一种方法能完美适用于所有情况。在这里，你将根据局部网格质量度量，设计并实现一个在加权最小二乘法 (WLS) 和格林-高斯法 (GG) 之间智能切换的动态算法 。这项任务模拟了开发稳健、可靠的工业级数值求解器的过程。",
            "id": "3958323",
            "problem": "您的任务是在有限体积法 (FVM) 框架内，为二维非结构化网格设计并实现一个动态梯度重构算法。该算法必须根据局部几何和数值质量，在两种重构方法之间切换：格林-高斯 (GG) 方法和加权最小二乘 (WLS) 方法。目标是在给定单元的中心重构一个标量场（在此解释为温度）的梯度，并确保在边界附近和高度扭曲的区域具有鲁棒性。重构的梯度必须与解析参考解进行比较评估，且算法的方法选择必须有明确、可量化的标准作为依据。\n\n从以下基本原理开始：\n- 高斯散度定理指出，对于一个足够平滑的标量场 $\\,\\phi(\\boldsymbol{x})\\,$，在面积为 $\\,A\\,$ 的多边形单元上的单元平均梯度满足\n$$\n\\int_{\\Omega} \\nabla \\phi \\, \\mathrm{d}\\Omega = \\int_{\\partial \\Omega} \\phi \\, \\boldsymbol{n} \\, \\mathrm{d}S,\n$$\n其中 $\\,\\boldsymbol{n}\\,$ 表示外向单位法向量，$\\,\\partial \\Omega\\,$ 是单元边界。\n- 一个围绕单元中心 $\\,\\boldsymbol{x}_P\\,$ 的线性场 $\\,\\phi(\\boldsymbol{x})\\approx \\phi_P + \\boldsymbol{g}\\cdot(\\boldsymbol{x}-\\boldsymbol{x}_P)\\,$ 的加权最小二乘 (WLS) 拟合，可以通过最小化以下函数得到\n$$\nJ(\\boldsymbol{g}) = \\sum_j w_j \\left[ \\phi_j - \\phi_P - \\boldsymbol{g}\\cdot(\\boldsymbol{x}_j-\\boldsymbol{x}_P) \\right]^2,\n$$\n其中权重 $\\,w_j>0\\,$ 为正，从而导出正规方程\n$$\n\\left( \\boldsymbol{A}^\\top \\boldsymbol{W}\\boldsymbol{A} \\right)\\boldsymbol{g} = \\boldsymbol{A}^\\top \\boldsymbol{W}\\boldsymbol{b},\n$$\n其中 $\\,\\boldsymbol{A}\\,$ 的行是 $\\,(\\boldsymbol{x}_j-\\boldsymbol{x}_P)^\\top\\,$，$\\,\\boldsymbol{b}\\,$ 的元素是 $\\,\\phi_j - \\phi_P\\,$，而 $\\,\\boldsymbol{W}\\,$ 是对角元素为 $\\,w_j\\,$ 的对角矩阵。\n\n基于以下标准设计一个鲁棒的方法选择器：\n1. 边界邻近度：如果任何一个面是边界面（狄利克雷条件），则优先选择 WLS，因为格林-高斯方法在边界处可能因面值带偏而受影响。\n2. 非正交性：将面上的非正交性定义为面法向量 $\\,\\boldsymbol{n}_f\\,$ 与特定向量之间的夹角（单位：度）。对于内部面，该向量是中心到中心的向量 $\\,\\boldsymbol{d}_f\\,$；对于边界面，该向量是单元中心到面中心的向量。该角度为\n$$\n\\theta_f = \\arccos\\left( \\frac{|\\boldsymbol{d}_f\\cdot \\boldsymbol{n}_f|}{\\|\\boldsymbol{d}_f\\|} \\right)\\times \\frac{180}{\\pi}.\n$$\n设 $\\,\\theta_{\\max}\\,$ 为所有面中的最大角度。如果 $\\,\\theta_{\\max} > \\Theta^\\star\\,$，则优先选择 WLS。使用 $\\,\\Theta^\\star = 60\\,$ 度。\n3. 数值条件：如果优先选择 WLS，计算 $\\,\\boldsymbol{A}^\\top \\boldsymbol{W}\\boldsymbol{A}\\,$ 的条件数 $\\,\\kappa\\,$ 及其秩。如果 $\\,\\kappa>\\kappa_{\\max}\\,$ 或秩 < 2，则退回使用 GG。使用 $\\,\\kappa_{\\max}=10^6\\,$。\n\n实现以下内容：\n- 格林-高斯梯度：对于一个面积为 $\\,A\\,$、边（面）长为 $\\,L_f\\,$、外向单位法向量为 $\\,\\boldsymbol{n}_f\\,$、中点为 $\\,\\boldsymbol{x}_f\\,$ 的多边形单元，梯度近似为\n$$\n\\nabla \\phi_P \\approx \\frac{1}{A} \\sum_{f} \\phi_f \\, \\boldsymbol{n}_f \\, L_f,\n$$\n其中，对于内部面，$\\,\\phi_f\\,$ 等于两个相邻单元值的算术平均值；对于边界面，$\\,\\phi_f\\,$ 等于在 $\\,\\boldsymbol{x}_f\\,$ 处的狄利克雷边界值。\n- 加权最小二乘梯度：仅使用内部邻居单元中心 $\\,\\boldsymbol{x}_j\\,$ 和权重 $\\,w_j = 1/\\|\\boldsymbol{x}_j-\\boldsymbol{x}_P\\|\\,$ 求解正规方程以得到 $\\,\\boldsymbol{g}\\,$。如果根据上述标准，系统是秩亏的或病态的，则退回使用 GG。\n\n解析温度场和单位：\n- 设解析温度场为\n$$\nT(x,y) = 300 + 10x + 5y + 0.5\\,x\\,y,\n$$\n其中 $\\,T\\,$ 的单位是开尔文 (K)，$\\,x,y\\,$ 的单位是米 (m)。精确梯度为\n$$\n\\nabla T(x,y) = \\left(10 + 0.5y,\\; 5 + 0.5x \\right) \\quad \\text{单位是 K/m}.\n$$\n所有计算出的梯度误差必须以开尔文每米 (K/m) 为单位报告。角度必须以度为单位处理。\n\n测试套件：\n对于每个测试用例，通过其顶点（逆时针顺序）和每个面的邻居元数据（是否为边界，如果是内部面，则提供邻居中心）来定义一个目标单元。程序必须在单元中心评估所选方法以及梯度绝对误差的大小（欧几里得范数）。算法必须根据上述标准动态选择重构方法。\n\n- 测试用例 1（内部形状良好的正方形，无边界）：\n    - 顶点：$(1,1)$, $(2,1)$, $(2,2)$, $(1,2)$。\n    - 每个面的邻居（按顶点顺序的面 0 到 3）：内部邻居，中心位于 $(1.5,0.5)$, $(2.5,1.5)$, $(1.5,2.5)$, $(0.5,1.5)$。\n- 测试用例 2（边界角落的正方形）：\n    - 顶点：$(0,0)$, $(1,0)$, $(1,1)$, $(0,1)$。\n    - 每个面的邻居：面 0 为边界，面 1 为内部面，中心位于 $(1.5,0.5)$，面 2 为内部面，中心位于 $(0.5,1.5)$，面 3 为边界。\n- 测试用例 3（高度扭曲的四边形，仅有内部邻居）：\n    - 顶点：$(2.0,1.0)$, $(3.0,1.1)$, $(2.8,2.2)$, $(2.0,2.0)$。\n    - 每个面的邻居：内部邻居中心位于 $(3.3,0.4)$, $(3.6,1.8)$, $(1.9,2.8)$, $(1.4,1.4)$。\n- 测试用例 4（内部邻居不足以进行 WLS 计算的边界面）：\n    - 顶点：$(3,0)$, $(4,0)$, $(4,1)$, $(3,1)$。\n    - 每个面的邻居：面 0、1、2 为边界，面 3 为内部面，中心位于 $(2.5,0.5)$。\n\n选择阈值：\n- 非正交性阈值：$\\,\\Theta^\\star = 60\\,$ 度。\n- 最大可接受条件数：$\\,\\kappa_{\\max} = 10^6\\,$。\n\n输出规范：\n- 对于每个测试用例，输出一个包含两个条目的列表：所选方法的代码和梯度绝对误差的大小。格林-高斯 (GG) 方法使用代码 $\\,0\\,$，加权最小二乘 (WLS) 方法使用代码 $\\,1\\,$。\n- 最终程序输出必须是单行文本，其中包含所有测试用例的结果，格式为方括号内的逗号分隔列表。每个结果必须是一个不含空格的双元素列表，形式为 $\\,\\left[\\text{方法代码},\\text{误差}\\right]\\,$。例如：\n$$\n[\\,[0,0.001234],[1,0.000567],\\ldots\\,]\n$$\n- 所有梯度误差必须以浮点数形式表示，单位为 $\\,\\text{K/m}\\,$。输出必须只包含数值（不含单位字符串），每个误差四舍五入到六位小数。\n\n角度单位要求：\n- 所有用于非正交性评估的角度都必须以度为单位处理。\n\n您的程序必须实现这个动态选择算法，为指定的测试套件计算重构梯度，将其与精确的解析梯度进行比较，并生成所需的输出行。",
            "solution": "问题陈述经评估有效。它在科学上基于有限体积法 (FVM) 的原理，在数学上是适定的，并为一个计算工程任务提供了完整、明确的需求和数据。因此，可以构建一个解决方案。\n\n核心任务是为二维非结构化网格实现一个动态梯度重构算法。该算法必须根据局部单元的几何形状和数值稳定性，在格林-高斯 (GG) 和加权最小二乘 (WLS) 方法之间进行选择。解决方案分几个阶段进行：几何预处理、应用选择逻辑、使用所选方法计算梯度，以及根据精确的解析解评估结果误差。\n\n### 几何预处理\n对于每个由一组顶点 $\\{\\boldsymbol{v}_0, \\boldsymbol{v}_1, \\ldots, \\boldsymbol{v}_{N-1}\\}$（按逆时针顺序）定义的多边形单元，几个几何属性是基础。\n\n单元的面积 $A$ 使用鞋带公式计算：\n$$ A = \\frac{1}{2} \\left| \\sum_{i=0}^{N-1} (x_i y_{i+1} - x_{i+1} y_i) \\right| $$\n其中 $\\boldsymbol{v}_i = (x_i, y_i)$ 且索引以 $N$ 为模。\n\n单元中心 $\\boldsymbol{x}_P = (C_x, C_y)$ 使用简单多边形的精确公式计算：\n$$ C_x = \\frac{1}{6A} \\sum_{i=0}^{N-1} (x_i + x_{i+1})(x_i y_{i+1} - x_{i+1} y_i) $$\n$$ C_y = \\frac{1}{6A} \\sum_{i=0}^{N-1} (y_i + y_{i+1})(x_i y_{i+1} - x_{i+1} y_i) $$\n\n连接顶点 $\\boldsymbol{v}_i$ 到 $\\boldsymbol{v}_{i+1}$ 的多边形每条边构成一个面 $f$。对于每个面，我们计算：\n- 面长 $L_f = \\| \\boldsymbol{v}_{i+1} - \\boldsymbol{v}_i \\|$。\n- 面中点（中心）$\\boldsymbol{x}_f = \\frac{1}{2}(\\boldsymbol{v}_i + \\boldsymbol{v}_{i+1})$。\n- 外向单位法向量 $\\boldsymbol{n}_f$。对于顶点 $(x_i, y_i)$ 和 $(x_{i+1}, y_{i+1})$，未缩放的法向量是 $(y_{i+1}-y_i, -(x_{i+1}-x_i))$，然后将其归一化为单位长度。\n\n### 动态方法选择算法\n实现了一个分层决策过程，为每个单元选择最合适的梯度重构方法。\n\n1.  **边界邻近度**：第一个标准是是否存在边界面。如果单元的任何一个面是边界面，则优先选择 WLS 方法。这是因为 GG 方法依赖于面上的值，对于内部面，这些值可以从相邻单元的中心插值得到。而在边界上，这是不可能的，直接使用边界值会引入偏差，尤其是在非正交网格中。在这种情况下，仅使用内部邻居构建的 WLS 可以提供更鲁棒的梯度估计。\n\n2.  **非正交性**：如果单元没有边界面，则通过每个面 $f$ 上的非正交性角度 $\\theta_f$ 来评估其几何质量。这个角度衡量了连接单元中心的向量 $\\boldsymbol{d}_f$ 与面法向量 $\\boldsymbol{n}_f$ 之间的偏差。其定义为：\n    $$ \\theta_f = \\arccos\\left( \\frac{|\\boldsymbol{d}_f\\cdot \\boldsymbol{n}_f|}{\\|\\boldsymbol{d}_f\\|} \\right)\\times \\frac{180}{\\pi} $$\n    对于内部面，$\\boldsymbol{d}_f = \\boldsymbol{x}_N - \\boldsymbol{x}_P$，其中 $\\boldsymbol{x}_N$ 是邻居单元的中心。对于边界面，$\\boldsymbol{d}_f = \\boldsymbol{x}_f - \\boldsymbol{x}_P$。如果所有面上的最大非正交性 $\\theta_{\\max}$ 超过阈值 $\\Theta^\\star = 60^\\circ$，则认为网格高度扭曲，此时优先选择 WLS 以减轻 GG 在这种情况下可能产生的大误差。\n\n3.  **数值条件**：如果根据上述标准优先选择 WLS，则需对其数值稳定性进行最终检查。WLS 方法需要求解一个线性系统。一个适定的系统需要足够数量的线性无关约束。对于二维梯度，至少需要两个不共线的邻居单元中心。这通过以下方式进行正式检查：\n    - **秩**：系统矩阵 $\\boldsymbol{M} = \\boldsymbol{A}^\\top \\boldsymbol{W}\\boldsymbol{A}$ 的秩必须为 $2$。如果内部邻居的数量少于 $2$，或者它们相对于单元中心 $\\boldsymbol{x}_P$ 共线，则秩将小于 $2$。\n    - **条件数**：条件数 $\\kappa(\\boldsymbol{M})$ 衡量解对输入扰动的敏感度。一个非常高的条件数表明系统是病态的。\n    如果秩小于 $2$ 或 $\\kappa(\\boldsymbol{M})$ 超过阈值 $\\kappa_{\\max}=10^6$，则认为 WLS 方法不可靠。在这种情况下，算法必须退回到更鲁棒但可能精度较低的 GG 方法。\n\n如果主要标准（边界邻近度、非正交性）均未表明优先选择 WLS，则默认使用 GG 方法。\n\n### 梯度重构方法\n标量场是解析温度函数 $\\phi(x,y) = T(x,y) = 300 + 10x + 5y + 0.5xy$。\n\n**格林-高斯 (GG) 梯度**\nGG 方法使用高斯散度定理的离散形式来近似单元平均梯度：\n$$ \\nabla \\phi_P \\approx \\frac{1}{A} \\sum_{f} \\phi_f \\boldsymbol{n}_f L_f $$\n面上的标量场值 $\\phi_f$ 近似为：\n- 对于内部面，它是两个相邻单元中心处值的算术平均值：$\\phi_f = \\frac{1}{2} (\\phi_P + \\phi_N)$，其中 $\\phi_P = T(\\boldsymbol{x}_P)$ 且 $\\phi_N = T(\\boldsymbol{x}_N)$。\n- 对于边界面，它是面中点处的精确值：$\\phi_f = T(\\boldsymbol{x}_f)$。\n\n**加权最小二乘 (WLS) 梯度**\nWLS 方法旨在寻找一个梯度向量 $\\boldsymbol{g} = (g_x, g_y)^\\top$，该向量能最小化在一组内部邻居 $j$ 上的加权残差平方和：\n$$ J(\\boldsymbol{g}) = \\sum_j w_j \\left[ (\\phi_j - \\phi_P) - \\boldsymbol{g} \\cdot (\\boldsymbol{x}_j - \\boldsymbol{x}_P) \\right]^2 $$\n权重被选择为与从单元中心到邻居中心的距离成反比，$w_j = 1/\\|\\boldsymbol{x}_j - \\boldsymbol{x}_P\\|$。这种最小化过程导出正规方程：\n$$ \\left( \\boldsymbol{A}^\\top \\boldsymbol{W}\\boldsymbol{A} \\right)\\boldsymbol{g} = \\boldsymbol{A}^\\top \\boldsymbol{W}\\boldsymbol{b} $$\n在这里，$\\boldsymbol{A}$ 是行向量为位移向量 $(\\boldsymbol{x}_j-\\boldsymbol{x}_P)^\\top$ 的矩阵，$\\boldsymbol{W}$ 是权重 $w_j$ 构成的对角矩阵，$\\boldsymbol{b}$ 是标量差 $\\phi_j - \\phi_P$ 构成的向量。求解这个 $2 \\times 2$ 系统以得到梯度向量 $\\boldsymbol{g}$。\n\n### 误差评估\n对于每个测试用例，将重构的梯度 $\\boldsymbol{g}_{recon}$ 与在单元中心 $\\boldsymbol{x}_P$ 处计算的精确解析梯度进行比较：\n$$ \\nabla T(x_P, y_P) = (10 + 0.5y_P, 5 + 0.5x_P) $$\n绝对误差大小计算为差向量的欧几里得范数：\n$$ \\text{Error} = \\| \\boldsymbol{g}_{recon} - \\nabla T(\\boldsymbol{x}_P) \\| $$\n每个测试用例的最终输出包括一个方法代码（GG 为 $0$，WLS 为 $1$）和这个计算出的误差，四舍五入到六位小数。",
            "answer": "```python\nimport numpy as np\n\n# --- Problem Constants and Analytic Functions ---\n\nTHETA_STAR = 60.0  # degrees\nKAPPA_MAX = 1e6\n\ndef analytic_T(x, y):\n    \"\"\"Analytic temperature field T(x,y) in Kelvin.\"\"\"\n    return 300.0 + 10.0 * x + 5.0 * y + 0.5 * x * y\n\ndef analytic_grad_T(x, y):\n    \"\"\"Exact gradient of the temperature field in K/m.\"\"\"\n    return np.array([10.0 + 0.5 * y, 5.0 + 0.5 * x])\n\n# --- Geometric Utility Functions ---\n\ndef get_polygon_properties(vertices):\n    \"\"\"\n    Calculates the area and centroid of a simple polygon.\n    Assumes vertices are given in counter-clockwise order.\n    \"\"\"\n    verts_shifted = np.roll(vertices, -1, axis=0)\n    cross_prod_terms = vertices[:, 0] * verts_shifted[:, 1] - verts_shifted[:, 0] * vertices[:, 1]\n    \n    area = 0.5 * np.sum(cross_prod_terms)\n    \n    cx_terms = (vertices[:, 0] + verts_shifted[:, 0]) * cross_prod_terms\n    cy_terms = (vertices[:, 1] + verts_shifted[:, 1]) * cross_prod_terms\n    \n    centroid_x = (1.0 / (6.0 * area)) * np.sum(cx_terms)\n    centroid_y = (1.0 / (6.0 * area)) * np.sum(cy_terms)\n    \n    return area, np.array([centroid_x, centroid_y])\n\ndef get_face_properties(vertices):\n    \"\"\"\n    Calculates properties for each face of the polygon.\n    Returns a list of dictionaries, one for each face.\n    \"\"\"\n    num_verts = len(vertices)\n    faces = []\n    for i in range(num_verts):\n        p1 = vertices[i]\n        p2 = vertices[(i + 1) % num_verts]\n        \n        face_vec = p2 - p1\n        length = np.linalg.norm(face_vec)\n        midpoint = 0.5 * (p1 + p2)\n        \n        # Outward normal for CCW vertices\n        normal = np.array([face_vec[1], -face_vec[0]]) / length\n        faces.append({'length': length, 'midpoint': midpoint, 'normal': normal})\n    return faces\n\n# --- Gradient Reconstruction Methods ---\n\ndef calculate_gg_gradient(cell_centroid, cell_area, faces, neighbor_data):\n    \"\"\"Computes the gradient using the Green-Gauss method.\"\"\"\n    grad_sum = np.zeros(2)\n    phi_P = analytic_T(cell_centroid[0], cell_centroid[1])\n    \n    for i, face in enumerate(faces):\n        neighbor = neighbor_data[i]\n        if neighbor['type'] == 'internal':\n            phi_N = analytic_T(neighbor['centroid'][0], neighbor['centroid'][1])\n            phi_f = 0.5 * (phi_P + phi_N)\n        else: # boundary\n            phi_f = analytic_T(face['midpoint'][0], face['midpoint'][1])\n        \n        grad_sum += phi_f * face['normal'] * face['length']\n        \n    return grad_sum / cell_area\n\ndef solve():\n    \"\"\"Main solver function to process all test cases.\"\"\"\n    \n    # Test cases defined as (vertices, neighbor_metadata)\n    test_cases = [\n        # Case 1: Interior well-shaped square\n        (\n            np.array([[1, 1], [2, 1], [2, 2], [1, 2]], dtype=float),\n            [\n                {'type': 'internal', 'centroid': np.array([1.5, 0.5])},\n                {'type': 'internal', 'centroid': np.array([2.5, 1.5])},\n                {'type': 'internal', 'centroid': np.array([1.5, 2.5])},\n                {'type': 'internal', 'centroid': np.array([0.5, 1.5])},\n            ]\n        ),\n        # Case 2: Boundary corner square\n        (\n            np.array([[0, 0], [1, 0], [1, 1], [0, 1]], dtype=float),\n            [\n                {'type': 'boundary', 'centroid': None},\n                {'type': 'internal', 'centroid': np.array([1.5, 0.5])},\n                {'type': 'internal', 'centroid': np.array([0.5, 1.5])},\n                {'type': 'boundary', 'centroid': None},\n            ]\n        ),\n        # Case 3: Highly skewed quadrilateral, internal\n        (\n            np.array([[2.0, 1.0], [3.0, 1.1], [2.8, 2.2], [2.0, 2.0]], dtype=float),\n            [\n                {'type': 'internal', 'centroid': np.array([3.3, 0.4])},\n                {'type': 'internal', 'centroid': np.array([3.6, 1.8])},\n                {'type': 'internal', 'centroid': np.array([1.9, 2.8])},\n                {'type': 'internal', 'centroid': np.array([1.4, 1.4])},\n            ]\n        ),\n        # Case 4: Boundary cell with insufficient neighbors for WLS\n        (\n            np.array([[3, 0], [4, 0], [4, 1], [3, 1]], dtype=float),\n            [\n                {'type': 'boundary', 'centroid': None},\n                {'type': 'boundary', 'centroid': None},\n                {'type': 'boundary', 'centroid': None},\n                {'type': 'internal', 'centroid': np.array([2.5, 0.5])},\n            ]\n        )\n    ]\n    \n    results = []\n\n    for vertices, neighbor_data in test_cases:\n        # --- 1. Geometric Pre-processing ---\n        area, centroid = get_polygon_properties(vertices)\n        faces = get_face_properties(vertices)\n        phi_P = analytic_T(centroid[0], centroid[1])\n\n        # --- 2. Dynamic Method Selection ---\n        has_boundary = any(n['type'] == 'boundary' for n in neighbor_data)\n        prefer_wls = has_boundary\n        \n        if not prefer_wls:\n            max_theta = 0.0\n            for i, face in enumerate(faces):\n                neighbor = neighbor_data[i]\n                if neighbor['type'] == 'internal':\n                    d_f = neighbor['centroid'] - centroid\n                else: # Boundary\n                    d_f = face['midpoint'] - centroid\n                \n                cos_theta = np.abs(np.dot(d_f, face['normal'])) / np.linalg.norm(d_f)\n                # Clip to avoid domain errors with arccos\n                cos_theta = np.clip(cos_theta, 0.0, 1.0)\n                theta_deg = np.degrees(np.arccos(cos_theta))\n                if theta_deg > max_theta:\n                    max_theta = theta_deg\n            \n            if max_theta > THETA_STAR:\n                prefer_wls = True\n        \n        # --- 3. Gradient Calculation ---\n        grad = None\n        method_code = 0  # Default to GG (0)\n\n        if prefer_wls:\n            internal_neighbors = [n['centroid'] for n in neighbor_data if n['type'] == 'internal']\n            \n            if len(internal_neighbors)  2:\n                # Revert to GG, not enough neighbors for WLS\n                pass\n            else:\n                # Attempt WLS\n                num_neighbors = len(internal_neighbors)\n                A = np.zeros((num_neighbors, 2))\n                b = np.zeros(num_neighbors)\n                w = np.zeros(num_neighbors)\n\n                for i, neighbor_centroid in enumerate(internal_neighbors):\n                    delta_x = neighbor_centroid - centroid\n                    A[i, :] = delta_x\n                    dist = np.linalg.norm(delta_x)\n                    w[i] = 1.0 / dist\n                    phi_N = analytic_T(neighbor_centroid[0], neighbor_centroid[1])\n                    b[i] = phi_N - phi_P\n                \n                W = np.diag(w)\n                M = A.T @ W @ A\n                \n                rank = np.linalg.matrix_rank(M)\n                if rank  2:\n                    # Revert to GG, rank deficient\n                    pass\n                else:\n                    cond = np.linalg.cond(M)\n                    if cond > KAPPA_MAX:\n                        # Revert to GG, ill-conditioned\n                        pass\n                    else:\n                        # WLS is valid\n                        rhs = A.T @ W @ b\n                        grad = np.linalg.solve(M, rhs)\n                        method_code = 1\n        \n        # Fallback to GG if WLS was not selected or failed\n        if grad is None:\n            grad = calculate_gg_gradient(centroid, area, faces, neighbor_data)\n            method_code = 0\n            \n        # --- 4. Error Evaluation ---\n        exact_grad = analytic_grad_T(centroid[0], centroid[1])\n        error = np.linalg.norm(grad - exact_grad)\n        \n        results.append(f\"[{method_code},{error:.6f}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}