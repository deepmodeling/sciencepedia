{
    "hands_on_practices": [
        {
            "introduction": "要想高效地使用和设计迭代求解器，我们必须首先理解是什么在支配它们的性能。关键指标是迭代矩阵的谱半径，它决定了渐进收敛速度。本实践通过一个基础的分析练习，为一个模型问题推导出这一关键量值，为理解收敛行为奠定理论基础。",
            "id": "3986575",
            "problem": "一个具有恒定横截面的直翅片可通过稳态一维热传导方程建模，并带有齐次狄利克雷边界条件。经过无量纲化后，该问题可简化为以下边值问题\n$$\n- \\frac{d^{2} u}{dx^{2}} = f(x), \\quad x \\in (0,1), \\qquad u(0)=0,\\; u(1)=0.\n$$\n使用 $n$ 个等间距的内部点 $x_{j} = j h$（其中 $j=1,2,\\dots,n$ 且 $h = \\frac{1}{n+1}$）对区间内部进行离散化。使用标准二阶中心差分，得到线性系统 $A \\mathbf{u} = \\mathbf{b}$，其中 $A$ 是由带狄利克雷边界条件的离散负二阶导数产生的三对角矩阵。考虑将雅可比方法应用于此系统，采用标准分裂 $A = D - (L+U)$，雅可比迭代矩阵为 $B_{J} = I - D^{-1} A$。\n\n从离散算子和边界条件出发，通过构造一个合适的特征向量正交基，显式地推导出 $B_{J}$ 的特征对。然后，将谱半径 $\\rho(B_{J})$ 确定为一个关于 $n$ 的闭式函数。\n\n只需报告 $\\rho(B_{J})$ 的最终闭式解析表达式。不需要进行数值计算。",
            "solution": "该问题是有效的。这是一个数值分析中的标准、适定问题，涉及从边值问题的有限差分离散导出的迭代矩阵的谱性质。所有信息都是自洽且科学合理的。\n\n我们首先对给定的边值问题进行离散化：\n$$\n- \\frac{d^{2} u}{dx^{2}} = f(x), \\quad x \\in (0,1), \\qquad u(0)=0,\\; u(1)=0.\n$$\n将域 $(0,1)$ 分成 $n+1$ 个等宽的子区间，宽度为 $h = \\frac{1}{n+1}$。网格点为 $x_j = jh$，其中 $j=0, 1, \\dots, n+1$。函数 $u(x)$ 在内部网格点上的值记为 $u_j = u(x_j)$，其中 $j=1, 2, \\dots, n$。边界条件意味着 $u_0 = 0$ 且 $u_{n+1} = 0$。\n\n在内部点 $x_j$ 处的二阶导数使用二阶中心差分公式进行近似：\n$$\n\\frac{d^{2} u}{dx^{2}}\\Bigg|_{x=x_j} \\approx \\frac{u(x_{j+1}) - 2u(x_j) + u(x_{j-1})}{h^2} = \\frac{u_{j+1} - 2u_j - u_{j-1}}{h^2}.\n$$\n将此近似代入每个内部点 $x_j$ 的微分方程中，得到一个包含 $n$ 个线性方程的方程组：\n$$\n- \\frac{u_{j+1} - 2u_j + u_{j-1}}{h^2} = f(x_j), \\quad j=1, 2, \\dots, n.\n$$\n重新整理各项，我们得到：\n$$\n\\frac{1}{h^2}(-u_{j-1} + 2u_j - u_{j+1}) = f_j,\n$$\n其中 $f_j = f(x_j)$。我们应用边界条件：当 $j=1$ 时，$u_0=0$；当 $j=n$ 时，$u_{n+1}=0$。该方程组可以写成矩阵形式 $A \\mathbf{u} = \\mathbf{b}$，其中 $\\mathbf{u} = [u_1, u_2, \\dots, u_n]^T$，$\\mathbf{b} = [f_1, f_2, \\dots, f_n]^T$，而 $A$ 是一个 $n \\times n$ 矩阵：\n$$\nA = \\frac{1}{h^2} \\begin{pmatrix}\n2   -1  0  \\cdots  0 \\\\\n-1  2  -1  \\ddots  \\vdots \\\\\n0  -1  \\ddots  \\ddots  0 \\\\\n\\vdots  \\ddots  \\ddots  2  -1 \\\\\n0  \\cdots  0  -1  2\n\\end{pmatrix}.\n$$\n对于雅可比方法，矩阵 $A$ 分裂为 $A = D - (L+U)$，其中 $D$ 是 $A$ 的对角部分，而 $-L$ 和 $-U$ 分别是 $A$ 的严格下三角和上三角部分。雅可比迭代矩阵由 $B_J = D^{-1}(L+U) = I - D^{-1}A$ 给出。\n\n从 $A$ 的结构可知，其对角部分为 $D = \\frac{2}{h^2}I$，其中 $I$ 是 $n \\times n$ 的单位矩阵。\n$D$ 的逆矩阵是 $D^{-1} = \\frac{h^2}{2}I$。\n将此代入 $B_J$ 的表达式中：\n$$\nB_J = I - \\left(\\frac{h^2}{2}I\\right) A = I - \\frac{h^2}{2} \\left[ \\frac{1}{h^2} \\begin{pmatrix}\n2   -1   \\cdots \\\\\n-1  2  -1  \\\\\n  \\ddots  \\ddots  \\ddots \\\\\n    -1  2\n\\end{pmatrix} \\right] = I - \\frac{1}{2} \\begin{pmatrix}\n2   -1   \\cdots \\\\\n-1  2  -1  \\\\\n  \\ddots  \\ddots  \\ddots \\\\\n    -1  2\n\\end{pmatrix}.\n$$\n这就得到了雅可比迭代矩阵：\n$$\nB_J = \\begin{pmatrix}\n1      \\\\\n  1    \\\\\n    \\ddots   \\\\\n      1\n\\end{pmatrix} - \\begin{pmatrix}\n1   -1/2    \\\\\n-1/2  1  -1/2  \\\\\n  \\ddots  \\ddots  \\ddots \\\\\n    -1/2  1\n\\end{pmatrix} = \\begin{pmatrix}\n0  1/2  0  \\cdots  0 \\\\\n1/2  0  1/2  \\ddots  \\vdots \\\\\n0  1/2  \\ddots  \\ddots  0 \\\\\n\\vdots  \\ddots  \\ddots  0  1/2 \\\\\n0  \\cdots  0  1/2  0\n\\end{pmatrix}.\n$$\n为了求谱半径 $\\rho(B_J)$，我们需要求出 $B_J$ 的特征值。题目要求我们通过首先构造一个特征向量的正交基来做到这一点。$B_J$ 的特征向量与 $A$ 的特征向量相同，因为 $B_J$ 是 $A$ 的一个线性多项式，且 $D$ 是单位矩阵的标量倍数。\n\n让我们求解三对角矩阵 $T$ 的特征对，其中 $A = \\frac{1}{h^2}T$，且 $T$ 的对角线元素为 $2$，非对角线元素为 $-1$。设 $T$ 的一个特征向量为 $\\mathbf{v}$，其对应的特征值为 $\\mu$。特征值问题 $T\\mathbf{v} = \\mu \\mathbf{v}$ 的第 $j$ 个分量是：\n$$\n-v_{j-1} + 2v_j - v_{j+1} = \\mu v_j,\n$$\n边界条件为 $v_0 = 0$ 和 $v_{n+1} = 0$。这是一个线性二阶差分方程。我们假设解的形式为 $v_j = \\sin(j\\theta)$，其中 $\\theta$ 是某个角度。边界条件 $v_0=0$ 自动满足。条件 $v_{n+1}=0$ 要求 $\\sin((n+1)\\theta) = 0$，这意味着 $(n+1)\\theta = k\\pi$，其中 $k$ 为某个整数。因此，我们得到一族由 $k$ 索引的候选解：\n$$\n\\theta_k = \\frac{k\\pi}{n+1}, \\quad k=1, 2, \\dots, n.\n$$\n对应的向量 $\\mathbf{v}^{(k)}$ 的分量为 $v_j^{(k)} = \\sin\\left(\\frac{jk\\pi}{n+1}\\right)$。这些向量构成 $n$ 个线性无关的向量集合，并且它们构成了 $\\mathbb{R}^n$ 的一个正交基。\n\n让我们求解每个特征向量 $\\mathbf{v}^{(k)}$ 对应的特征值 $\\mu_k$。将 $v_j^{(k)}$ 代入差分方程：\n$$\n-\\sin\\left(\\frac{(j-1)k\\pi}{n+1}\\right) + 2\\sin\\left(\\frac{jk\\pi}{n+1}\\right) - \\sin\\left(\\frac{(j+1)k\\pi}{n+1}\\right) = \\mu_k \\sin\\left(\\frac{jk\\pi}{n+1}\\right).\n$$\n使用三角恒等式 $\\sin(a-b)+\\sin(a+b) = 2\\sin(a)\\cos(b)$，我们可以简化左侧：\n$$\n2\\sin\\left(\\frac{jk\\pi}{n+1}\\right) - \\left[ \\sin\\left(\\frac{(j-1)k\\pi}{n+1}\\right) + \\sin\\left(\\frac{(j+1)k\\pi}{n+1}\\right) \\right] = 2\\sin\\left(\\frac{jk\\pi}{n+1}\\right) - 2\\sin\\left(\\frac{jk\\pi}{n+1}\\right)\\cos\\left(\\frac{k\\pi}{n+1}\\right).\n$$\n提取公因式 $\\sin\\left(\\frac{jk\\pi}{n+1}\\right)$，我们得到：\n$$\n\\left(2 - 2\\cos\\left(\\frac{k\\pi}{n+1}\\right)\\right) \\sin\\left(\\frac{jk\\pi}{n+1}\\right) = \\mu_k \\sin\\left(\\frac{jk\\pi}{n+1}\\right).\n$$\n因此，$T$ 的特征值为 $\\mu_k = 2 - 2\\cos\\left(\\frac{k\\pi}{n+1}\\right)$，其中 $k=1, \\dots, n$。\n\n矩阵 $A$、$T$ 和 $B_J$ 共享相同的特征向量 $\\mathbf{v}^{(k)}$。设 $\\lambda_k(A)$ 为 $A$ 的特征值，$\\lambda_k(B_J)$ 为 $B_J$ 的特征值。\n$$\n\\lambda_k(A) = \\frac{1}{h^2}\\mu_k = \\frac{2}{h^2}\\left(1 - \\cos\\left(\\frac{k\\pi}{n+1}\\right)\\right).\n$$\n$B_J$ 和 $A$ 的特征值之间的关系是 $\\lambda(B_J) = 1 - (\\frac{h^2}{2})\\lambda(A)$。因此，\n$$\n\\lambda_k(B_J) = 1 - \\frac{h^2}{2} \\lambda_k(A) = 1 - \\frac{h^2}{2} \\left[ \\frac{2}{h^2}\\left(1 - \\cos\\left(\\frac{k\\pi}{n+1}\\right)\\right) \\right].\n$$\n$$\n\\lambda_k(B_J) = 1 - \\left(1 - \\cos\\left(\\frac{k\\pi}{n+1}\\right)\\right) = \\cos\\left(\\frac{k\\pi}{n+1}\\right), \\quad k=1, 2, \\dots, n.\n$$\n$B_J$ 的特征对是 $\\left( \\cos\\left(\\frac{k\\pi}{n+1}\\right), \\mathbf{v}^{(k)} \\right)$，其中 $\\mathbf{v}^{(k)}$ 的第 $j$ 个分量是 $\\sin\\left(\\frac{jk\\pi}{n+1}\\right)$。\n\n$B_J$ 的谱半径是其特征值绝对值的最大值：\n$$\n\\rho(B_J) = \\max_{k \\in \\{1, \\dots, n\\}} |\\lambda_k(B_J)| = \\max_{k \\in \\{1, \\dots, n\\}} \\left| \\cos\\left(\\frac{k\\pi}{n+1}\\right) \\right|.\n$$\n余弦函数的自变量 $\\frac{k\\pi}{n+1}$ 的取值范围从 $\\frac{\\pi}{n+1}$ (当 $k=1$ 时) 到 $\\frac{n\\pi}{n+1}$ (当 $k=n$ 时)。这个范围包含在区间 $(0, \\pi)$ 内。函数 $|\\cos(x)|$ 在 $(0, \\pi)$ 上关于 $x=\\pi/2$ 对称，其最大值在任何闭区间 $[a, b] \\subset (0, \\pi)$ 的端点，即 $x=a$ 或 $x=b$ 处取得。\n在本例中，自变量集合是离散的：$\\{\\frac{\\pi}{n+1}, \\frac{2\\pi}{n+1}, \\dots, \\frac{n\\pi}{n+1}\\}$。当 $\\theta$ 最接近 $0$ 或 $\\pi$ 时，$|\\cos(\\theta)|$ 的值最大。\n最接近 $0$ 和 $\\pi$ 的自变量是当 $k=1$ 和 $k=n$ 时：\n$$\n\\text{当 } k=1 \\text{ 时}: \\quad \\left| \\cos\\left(\\frac{\\pi}{n+1}\\right) \\right| = \\cos\\left(\\frac{\\pi}{n+1}\\right) \\quad \\text{(因为当 } n \\ge 1 \\text{ 时，} \\frac{\\pi}{n+1} \\in (0, \\pi/2] \\text{)}。\n$$\n$$\n\\text{当 } k=n \\text{ 时}: \\quad \\left| \\cos\\left(\\frac{n\\pi}{n+1}\\right) \\right| = \\left| \\cos\\left(\\pi - \\frac{\\pi}{n+1}\\right) \\right| = \\left| -\\cos\\left(\\frac{\\pi}{n+1}\\right) \\right| = \\cos\\left(\\frac{\\pi}{n+1}\\right).\n$$\n对于 $k=2, \\dots, n-1$，$|\\cos(\\frac{k\\pi}{n+1})|$ 的值会更小，因为 $\\frac{k\\pi}{n+1}$ 比端点值离 $0$ 和 $\\pi$ 更远。\n因此，最大绝对值在 $k=1$ 和 $k=n$ 时取得。\n谱半径为：\n$$\n\\rho(B_J) = \\cos\\left(\\frac{\\pi}{n+1}\\right).\n$$",
            "answer": "$$\n\\boxed{\\cos\\left(\\frac{\\pi}{n+1}\\right)}\n$$"
        },
        {
            "introduction": "从理论转向实践时，我们会遇到简单模型问题中不存在的复杂性。对于非对称系统，例如由对流主导的传热问题产生的系统，我们对未知量进行排序的方式会极大地影响求解器的稳定性和速度。本练习通过编程实践，展示了不当的排序如何导致逐次超松弛（SOR）方法失效，而一个基于物理洞察的排序则能确保其收敛性。",
            "id": "3986584",
            "problem": "考虑在恒定属性下的稳态一维对流-扩散能量平衡，在包含 $n$ 个节点的均匀网格上进行标准的有限体积离散化，得到一个线性系统 $A \\mathbf{T} = \\mathbf{b}$，其中系数矩阵 $A$ 是一个三对角矩阵。对于纯传导问题（无对流），$A$ 是对称正定的，例如对角线元素为 $2$，非对角线元素为 $-1$。对于使用迎风差分格式离散的对流主导问题，$A$ 仍然是严格对角占优的，其非对角元素为非正数，并且通常是非对称的，其中上游耦合（一个非对角线）的量值可能远大于下游耦合（另一个非对角线）的量值。定常迭代法通过将 $A$ 分解为 $A = D - L - U$ 来求解 $A \\mathbf{T} = \\mathbf{b}$，其中 $D$ 是对角部分，$L$ 是严格下三角部分，$U$ 是严格上三角部分（所有这些都是相对于给定的未知数排序定义的）。使用松弛参数 $\\omega$ 的逐次超松弛（SOR）方法采用以下迭代格式\n$$\n\\mathbf{T}^{(k+1)} = (D - \\omega L)^{-1} \\left( (1 - \\omega) D + \\omega U \\right) \\mathbf{T}^{(k)} + (D - \\omega L)^{-1} \\omega \\mathbf{b}.\n$$\n相关的齐次 SOR 迭代矩阵为\n$$\nG_{\\omega} = (D - \\omega L)^{-1} \\left( (1 - \\omega) D + \\omega U \\right).\n$$\n对于给定的排序和 $\\omega$，SOR 方法的收敛性由谱半径 $\\rho(G_{\\omega})$ 决定，即该方法收敛当且仅当 $\\rho(G_{\\omega})  1$。未知数的排序通过置换相似性改变了 $A$ 到 $D$、$L$ 和 $U$ 的分解：如果 $P$ 是表示重新排序的置换矩阵，则重新排序后的系统为 $\\tilde{A} = P A P^{\\mathsf{T}}$，并且矩阵分裂也相应改变。在非对称情况下，这会强烈影响 $\\rho(G_{\\omega})$，可能导致在不良排序下超松弛 SOR 发散。\n\n您的任务是通过计算指定排序下的 $\\rho(G_{\\omega})$ 来量化 SOR 对排序的敏感性，并构建一个反例，其中不良排序导致 $\\omega  1$ 时发散。\n\n从离散能量平衡的基本原理和代数分裂 $A = D - L - U$ 出发，推导排序如何映射到 $A$ 的置换相似性，进而得到修正的 $G_{\\omega}$。实现一个程序，该程序：\n\n- 接受以下矩阵、排序和松弛参数的测试套件作为固定的内部数据。\n- 对于每个测试用例，根据指定的排序形成重新排序的矩阵 $\\tilde{A} = P A P^{\\mathsf{T}}$，根据该排序构造 $D$、$L$ 和 $U$，建立 SOR 迭代矩阵 $G_{\\omega}$，计算 $\\rho(G_{\\omega})$，并返回一个布尔值，指示收敛（$\\rho(G_{\\omega})  1$）或发散（$\\rho(G_{\\omega}) \\ge 1$）。\n\n使用以下测试套件，其设计旨在涵盖不同方面，包括对称正定的“理想情况”、非对称的对流主导情况和边界行为，并明确说明参数：\n\n- 测试用例 1：对称正定传导问题，$n = 20$，三对角矩阵，对角线元素为 $2$，非对角线元素为 $-1$；自然排序；$\\omega = 1.8$。\n- 测试用例 2：与测试用例 1 相同，但采用逆序；$\\omega = 1.8$。\n- 测试用例 3：对流主导的非对称系统，$n = 20$，三对角矩阵，对角线元素为 $4.0$，下非对角线元素为 $-0.05$，上非对角线元素为 $-3.9$；自然排序；$\\omega = 1.2$。\n- 测试用例 4：与测试用例 3 相同，但采用逆序；$\\omega = 1.2$。\n- 测试用例 5：与测试用例 3 相同，但采用逆序；$\\omega = 1.05$。\n- 测试用例 6：与测试用例 3 相同；自然排序；采用欠松弛，$\\omega = 0.9$。\n\n定义：\n\n- 自然排序是索引 $\\{1,2,\\dots,n\\}$ 上的单位置换 $P = I$。\n- 逆序是将索引 $i$ 映射到 $n+1-i$ 的置换。\n\n您的程序应生成单行输出，其中包含六个测试用例的结果，格式为方括号内以逗号分隔的列表（例如，“[true,true,false,...]”）。每个条目必须是一个布尔值，按上面列出的顺序指示相应测试用例的收敛（true）或发散（false）。这些代数评估不需要物理单位。不涉及角度。不使用百分比；答案条目仅为布尔值。",
            "solution": "核心任务是确定逐次超松弛（SOR）迭代法对于几个源自计算热工问题的线性系统的收敛性。SOR 方法的收敛性由其关联的迭代矩阵 $G_{\\omega}$ 的谱半径决定。该方法收敛的充分必要条件是谱半径 $\\rho(G_{\\omega})$ 严格小于 $1$。\n\n该问题关注线性系统 $A \\mathbf{T} = \\mathbf{b}$ 中未知数的排序如何影响收敛性，特别是对于源于对流主导现象的非对称矩阵。对 $n$ 个未知数的一种排序由一个 $n \\times n$ 大小的置换矩阵 $P$ 表示。应用此排序将原始系统转换为一个等价系统：\n$$\n(P A P^{\\mathsf{T}}) (P \\mathbf{T}) = P \\mathbf{b}\n$$\n令 $\\tilde{A} = P A P^{\\mathsf{T}}$、$\\tilde{\\mathbf{T}} = P \\mathbf{T}$ 和 $\\tilde{\\mathbf{b}} = P \\mathbf{b}$。然后将 SOR 方法应用于重新排序的系统 $\\tilde{A} \\tilde{\\mathbf{T}} = \\tilde{\\mathbf{b}}$。\n\nSOR 方法基于系数矩阵的分裂。对于重新排序的矩阵 $\\tilde{A}$，其分裂为 $\\tilde{A} = \\tilde{D} - \\tilde{L} - \\tilde{U}$，其中：\n- $\\tilde{D}$ 是 $\\tilde{A}$ 的对角部分。\n- $-\\tilde{L}$ 是 $\\tilde{A}$ 的严格下三角部分。因此，$\\tilde{L}$ 是 $\\tilde{A}$ 的严格下三角部分的负矩阵。\n- $-\\tilde{U}$ 是 $\\tilde{A}$ 的严格上三角部分。因此，$\\tilde{U}$ 是 $\\tilde{A}$ 的严格上三角部分的负矩阵。\n\n重新排序系统的 SOR 迭代公式为：\n$$\n\\tilde{\\mathbf{T}}^{(k+1)} = (\\tilde{D} - \\omega \\tilde{L})^{-1} \\left( (1 - \\omega) \\tilde{D} + \\omega \\tilde{U} \\right) \\tilde{\\mathbf{T}}^{(k)} + (\\tilde{D} - \\omega \\tilde{L})^{-1} \\omega \\tilde{\\mathbf{b}}\n$$\n其中 $\\omega$ 是松弛参数，$k$ 是迭代索引。该过程的收敛性取决于重新排序系统的 SOR 迭代矩阵 $\\tilde{G}_{\\omega}$ 的谱半径，其定义为：\n$$\n\\tilde{G}_{\\omega} = (\\tilde{D} - \\omega \\tilde{L})^{-1} \\left( (1 - \\omega) \\tilde{D} + \\omega \\tilde{U} \\right)\n$$\n收敛条件是 $\\rho(\\tilde{G}_{\\omega})  1$。\n\n为了评估每个测试用例的收敛性，我们遵循一个系统化的计算步骤：\n$1$. 按规定构建大小为 $n \\times n$ 的基础矩阵 $A$。对于一个主对角线为 $d$，下对角线为 $l$，上对角线为 $u$ 的三对角矩阵，其元素为 $A_{ii} = d$，$A_{i, i-1} = l$ 和 $A_{i, i+1} = u$。\n$2$. 为指定的排序构建置换矩阵 $P$。\n    - 对于自然排序，$P$ 是单位矩阵 $I$。\n    - 对于逆序，$P$ 是一个反对角矩阵，其元素为 $P_{i, n+1-i} = 1$（对于 $i=1, \\dots, n$），所有其他元素均为 $0$。\n$3$. 计算重新排序的矩阵 $\\tilde{A} = P A P^{\\mathsf{T}}$。\n$4$. 分解 $\\tilde{A}$ 以获得矩阵 $\\tilde{D}$、$\\tilde{L}$ 和 $\\tilde{U}$。具体来说：\n    - $\\tilde{D}$ 是一个包含 $\\tilde{A}$ 对角线元素的对角矩阵。\n    - $\\tilde{L}$ 是 $\\tilde{A}$ 严格下三角部分的负矩阵。\n    - $\\tilde{U}$ 是 $\\tilde{A}$ 严格上三角部分的负矩阵。\n$5$. 使用给定的 $\\omega$ 值组装 SOR 迭代矩阵 $\\tilde{G}_{\\omega}$。\n$6$. 计算 $\\tilde{G}_{\\omega}$ 的特征值 $\\lambda_i$。\n$7$. 计算谱半径 $\\rho(\\tilde{G}_{\\omega}) = \\max_i |\\lambda_i|$。\n$8$. 通过测试 $\\rho(\\tilde{G}_{\\omega})  1$ 来确定收敛性。结果是一个布尔值：`true` 表示收敛，`false` 表示发散。\n\n此过程将应用于六个测试用例中的每一个。\n\n- 对于测试用例 1 和 2，矩阵 $A$ 是对称正定（SPD）的。对于此类矩阵，已知 SOR 方法对任何松弛参数 $\\omega \\in (0, 2)$ 都收敛。由于置换相似变换 $P A P^{\\mathsf{T}}$ 保持了 SPD 性质，因此对于自然排序和逆序，当 $\\omega = 1.8$ 时，预期都会收敛。\n\n- 对于测试用例 3-6，矩阵 $A$ 是非对称且严格对角占优的，对应于一个采用迎风差分格式的对流主导问题。此类矩阵通常是 M-矩阵，对于 M-矩阵，如果 $\\omega \\in (0, 1]$，则保证 SOR 对任何排序都收敛。这预测了测试用例 6（其中 $\\omega = 0.9$）会收敛。对于超松弛（$\\omega > 1$），不保证收敛，并且对未知数的排序高度敏感。“自然”排序（$1, 2, \\dots, n$）构成了相对于强耦合方向（从高索引到低索引）的下游扫描，已知这对于 $\\omega > 1$ 的 SOR 是不稳定的。相反，“逆序”（$n, n-1, \\dots, 1$）构成了上游扫描，这与信息流方向一致，通常能实现稳定且快速的收敛。此推理表明测试用例 3（$\\omega = 1.2$，自然排序）会发散，而测试用例 4 和 5（$\\omega = 1.2$ 和 $\\omega=1.05$，逆序）会收敛。\n\n最终的程序为每个测试用例实现了这一完整的验证过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the problem by evaluating SOR convergence for a suite of test cases.\n    \"\"\"\n\n    def construct_tridiagonal_matrix(n, diag_val, lower_val, upper_val):\n        \"\"\"Constructs a tridiagonal matrix of size n x n.\"\"\"\n        diag = np.full(n, diag_val)\n        lower = np.full(n - 1, lower_val)\n        upper = np.full(n - 1, upper_val)\n        return np.diag(diag) + np.diag(lower, k=-1) + np.diag(upper, k=1)\n\n    def check_sor_convergence(A, ordering, omega):\n        \"\"\"\n        Checks the convergence of the SOR method for a given matrix, ordering, and omega.\n\n        Args:\n            A (np.ndarray): The base coefficient matrix.\n            ordering (str): The ordering of unknowns, 'natural' or 'reverse'.\n            omega (float): The relaxation parameter.\n\n        Returns:\n            bool: True if the method converges, False otherwise.\n        \"\"\"\n        n = A.shape[0]\n\n        # 1. Construct the permutation matrix P\n        if ordering == 'natural':\n            P = np.identity(n)\n        elif ordering == 'reverse':\n            P = np.fliplr(np.identity(n))\n        else:\n            raise ValueError(\"Unknown ordering type\")\n\n        # 2. Compute the reordered matrix A_tilde\n        A_tilde = P @ A @ P.T\n\n        # 3. Decompose A_tilde into D, L, U\n        # Note the convention: A = D - L - U\n        D_tilde = np.diag(np.diag(A_tilde))\n        L_tilde = -np.tril(A_tilde, k=-1)\n        U_tilde = -np.triu(A_tilde, k=1)\n\n        # 4. Construct the SOR iteration matrix G_omega\n        # G_omega = inv(D - omega*L) * ((1-omega)*D + omega*U)\n        # Check if D - omega*L is invertible\n        inv_term = D_tilde - omega * L_tilde\n        try:\n            np.linalg.inv(inv_term)\n        except np.linalg.LinAlgError:\n            # If the matrix is singular, spectral radius is effectively infinite\n            return False\n\n        G_omega = np.linalg.inv(inv_term) @ ((1 - omega) * D_tilde + omega * U_tilde)\n\n        # 5. Compute the spectral radius\n        eigenvalues = np.linalg.eigvals(G_omega)\n        spectral_radius = np.max(np.abs(eigenvalues))\n\n        # 6. Check for convergence\n        return spectral_radius  1.0\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'n': 20, 'diag': 2.0, 'lower': -1.0, 'upper': -1.0, 'ordering': 'natural', 'omega': 1.8}, # Case 1\n        {'n': 20, 'diag': 2.0, 'lower': -1.0, 'upper': -1.0, 'ordering': 'reverse', 'omega': 1.8}, # Case 2\n        {'n': 20, 'diag': 4.0, 'lower': -0.05, 'upper': -3.9, 'ordering': 'natural', 'omega': 1.2}, # Case 3\n        {'n': 20, 'diag': 4.0, 'lower': -0.05, 'upper': -3.9, 'ordering': 'reverse', 'omega': 1.2}, # Case 4\n        {'n': 20, 'diag': 4.0, 'lower': -0.05, 'upper': -3.9, 'ordering': 'reverse', 'omega': 1.05},# Case 5\n        {'n': 20, 'diag': 4.0, 'lower': -0.05, 'upper': -3.9, 'ordering': 'natural', 'omega': 0.9}  # Case 6\n    ]\n\n    results = []\n    for case in test_cases:\n        # Construct the base matrix A\n        A = construct_tridiagonal_matrix(case['n'], case['diag'], case['lower'], case['upper'])\n        \n        # Check convergence and store the result\n        converges = check_sor_convergence(A, case['ordering'], case['omega'])\n        results.append(str(converges).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实的工程问题对求解器的效率和鲁棒性都提出了很高的要求。最后的这项实践将综合我们所学的知识，构建一个更精密的混合求解器。我们将结合雅可比（Jacobi）方法的高度并行性与逐次超松弛（SOR）方法更快的渐进收敛速度，创建一个能够在这两种方法之间自适应切换，并动态估算最优松弛因子 $ \\omega $ 的先进算法。",
            "id": "3986541",
            "problem": "考虑一个方形域中的稳态热传导问题，其边界条件为齐次狄利克雷边界条件，由偏微分方程 $- \\nabla \\cdot ( \\mathbf{k} \\nabla T ) = f(x,y)$ 控制，其中 $\\mathbf{k} = \\mathrm{diag}(k_x,k_y)$ 是一个分量为 $k_x  0$ 和 $k_y  0$ 的常数、正定电导率张量。使用一个包含 $n \\times n$ 个内部点的均匀笛卡尔网格，网格间距为 $h = 1/(n+1)$，并采用标准的二阶中心差分格式，内部点的有限差分方程可以写为\n$$\n2(k_x + k_y) \\, T_{i,j} - k_x \\left( T_{i+1,j} + T_{i-1,j} \\right) - k_y \\left( T_{i,j+1} + T_{i,j-1} \\right) = h^2 f_{i,j},\n$$\n对于 $i,j \\in \\{1,2,\\dots,n\\}$，边界上 $T=0$。\n\n你必须设计并实现一个混合定常迭代求解器，该求解器以雅可比方法开始以利用其并行更新结构，然后在观测到的残差下降率稳定时切换到逐次超松弛（SOR）方法。第 $k$ 次迭代的残差逐点定义为\n$$\nr^{(k)}_{i,j} = 2(k_x + k_y) \\, T^{(k)}_{i,j} - k_x \\left( T^{(k)}_{i+1,j} + T^{(k)}_{i-1,j} \\right) - k_y \\left( T^{(k)}_{i,j+1} + T^{(k)}_{i,j-1} \\right) - h^2 f_{i,j},\n$$\n残差范数为 $||r^{(k)}||_2 = \\left( \\sum_{i=1}^n \\sum_{j=1}^n \\left(r^{(k)}_{i,j}\\right)^2 \\right)^{1/2}$。雅可比更新由下式给出\n$$\nT^{(k+1)}_{i,j} = \\frac{k_x \\left( T^{(k)}_{i+1,j} + T^{(k)}_{i-1,j} \\right) + k_y \\left( T^{(k)}_{i,j+1} + T^{(k)}_{i,j-1} \\right) + h^2 f_{i,j}}{2(k_x + k_y)},\n$$\n而带有松弛因子 $\\omega \\in (0,2)$ 的逐次超松弛（SOR）更新为\n$$\nT^{(k+1)}_{i,j} = (1-\\omega) T^{(k)}_{i,j} + \\omega \\, \\frac{k_x \\left( T^{(k)}_{i+1,j} + T^{(k+1)}_{i-1,j} \\right) + k_y \\left( T^{(k)}_{i,j+1} + T^{(k+1)}_{i,j-1} \\right) + h^2 f_{i,j}}{2(k_x + k_y)},\n$$\n其中高斯-赛德尔排序使用最新的相邻节点值。\n\n切换准则：设在雅可比迭代期间计算比率序列 $q_k = ||r^{(k)}||_2 / ||r^{(k-1)}||_2$。在经过最少 $N_{\\min}$ 次雅可比迭代后，计算一个长度为 $m$ 的滑动窗口内的比率，如果窗口内的比率是稳定的且严格收缩的，则切换到SOR。这被解释为 $\\max(q_{k-m+1},\\dots,q_k) - \\min(q_{k-m+1},\\dots,q_k) \\le \\delta$ 且 $\\frac{1}{m}\\sum_{j=k-m+1}^k q_j  1$。在切换时，将窗口内比率的平均值估计为 $\\hat{\\rho}_J$，并使用一个关于 $\\hat{\\rho}_J$ 的有科学依据的函数来选择超松弛因子 $\\omega$。你必须确保 $\\omega \\in (0,2)$ 并在你的解决方案中记录其理由。\n\n停止准则：使用相对残差范数阈值 $||r^{(k)}||_2 / ||r^{(0)}||_2 \\le \\tau$，从零初始猜测 $T^{(0)}_{i,j} = 0$ 开始。\n\n实现该混合求解器并将其应用于以下三个测试用例。在每个案例中，域是单位正方形，边界条件是 $T=0$，内部网格尺寸为 $n \\times n$。\n\n- 测试用例A（通用、各向同性、常数源）：\n  - $n = 50$\n  - $k_x = 1$, $k_y = 1$\n  - $f(x,y) = 1$\n  - 相对容差 $\\tau = 10^{-6}$\n  - 滑动窗口长度 $m = 20$\n  - 最小雅可比迭代次数 $N_{\\min} = 40$\n  - 最大雅可比迭代次数 $N_{\\max} = 100$\n  - 稳定带 $\\delta = 5 \\times 10^{-4}$\n\n- 测试用例B（各向异性、平滑源）：\n  - $n = 60$\n  - $k_x = 4$, $k_y = 1$\n  - $f(x,y) = \\sin(\\pi x)\\sin(\\pi y)$\n  - 相对容差 $\\tau = 5 \\times 10^{-7}$\n  - 滑动窗口长度 $m = 25$\n  - 最小雅可比迭代次数 $N_{\\min} = 50$\n  - 最大雅可比迭代次数 $N_{\\max} = 120$\n  - 稳定带 $\\delta = 8 \\times 10^{-4}$\n\n- 测试用例C（小网格、高频棋盘格源）：\n  - $n = 8$\n  - $k_x = 1$, $k_y = 1$\n  - $f_{i,j} = (-1)^{i+j}$\n  - 相对容差 $\\tau = 10^{-6}$\n  - 滑动窗口长度 $m = 10$\n  - 最小雅可比迭代次数 $N_{\\min} = 15$\n  - 最大雅可比迭代次数 $N_{\\max} = 40$\n  - 稳定带 $\\delta = 10^{-3}$\n\n输出规格：对于每个测试用例，计算并返回一个包含三个量的列表：\n- 满足停止准则所需的总迭代次数（雅可比迭代次数加SOR迭代次数）（整数），\n- 是否切换到逐次超松弛（SOR）方法的指示符（如果切换则为 $1$，否则为 $0$），\n- SOR中使用的最终松弛因子 $\\omega$（四舍五入到 $5$ 位小数的浮点数；如果从未使用SOR，则报告 $\\omega = 1.0$）。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的三元组包含在其自己的子括号中，例如 $[ [a_1,b_1,c_1], [a_2,b_2,c_2], [a_3,b_3,c_3] ]$，其中每个 $a_k$ 是一个整数，每个 $b_k$ 是一个在 $\\{0,1\\}$ 中的整数，每个 $c_k$ 是一个四舍五入到 $5$ 位小数的浮点数。",
            "solution": "用户提供了一个在偏微分方程数值方法领域中定义明确的计算问题。该问题在科学上是合理的、自成体系的，并且在算法上是精确的。因此，它被认为是有效的，并将构建一个解决方案。\n\n### **1. 问题表述**\n\n该问题涉及二维方形域中稳态热传导方程的数值解：\n$$\n- \\nabla \\cdot ( \\mathbf{k} \\nabla T ) = f(x,y)\n$$\n其中 $\\mathbf{k} = \\mathrm{diag}(k_x, k_y)$ 是一个对角电导率张量，其对角元为正常数 $k_x$ 和 $k_y$，$T(x,y)$ 是温度场，$f(x,y)$ 是一个热源项。边界条件是齐次狄利克雷条件，即在正方形的所有边界上 $T=0$。\n\n在一个具有 $n \\times n$ 个内部点和网格间距 $h = 1/(n+1)$ 的均匀笛卡尔网格上，使用二阶中心差分格式对此方程进行离散化，可以得到一个线性代数方程组。对于每个内部网格点 $(i,j)$，其中 $i, j \\in \\{1, \\dots, n\\}$，方程为：\n$$\n2(k_x + k_y) T_{i,j} - k_x ( T_{i+1,j} + T_{i-1,j} ) - k_y ( T_{i,j+1} + T_{i,j-1} ) = h^2 f_{i,j}\n$$\n该方程组可以写成矩阵形式 $A\\mathbf{T} = \\mathbf{b}$，其中 $\\mathbf{T}$ 是未知温度 $T_{i,j}$ 的向量。矩阵 $A$ 是一个大而稀疏的矩阵，并且当 $k_x, k_y  0$ 时，它是对称正定的（SPD）。这个SPD性质至关重要，因为它保证了所提出的迭代方法的收敛性。\n\n### **2. 混合迭代求解器设计**\n\n任务是实现一个混合迭代求解器，该求解器从雅可比方法开始，并根据收敛行为自适应地切换到逐次超松弛（SOR）方法。\n\n#### **2.1. 雅可比方法**\n\n雅可比方法是一种迭代格式，其中新迭代值 $T^{(k+1)}$ 的每个分量仅使用前一次迭代 $T^{(k)}$ 的分量来计算。点 $(i,j)$ 的更新规则是：\n$$\nT^{(k+1)}_{i,j} = \\frac{k_x ( T^{(k)}_{i+1,j} + T^{(k)}_{i-1,j} ) + k_y ( T^{(k)}_{i,j+1} + T^{(k)}_{i,j-1} ) + h^2 f_{i,j}}{2(k_x + k_y)}\n$$\n雅可比方法的一个关键特性是所有点 $(i,j)$ 的更新可以同时（并行）进行，因为它们在同一次迭代中彼此不依赖。这是通过在当前迭代的所有计算中使用前一次迭代的温度场副本来实现的。\n\n#### **2.2. 逐次超松弛（SOR）方法**\n\nSOR是高斯-赛德尔方法的一种增强。它通过取前一个迭代值 $T^{(k)}_{i,j}$ 和一个高斯-赛德尔步骤预测的值的加权平均来计算新的迭代值 $T^{(k+1)}_{i,j}$。依次应用于网格点（例如，按字典序）的更新规则是：\n$$\nT^{(k+1)}_{i,j} = (1-\\omega) T^{(k)}_{i,j} + \\omega \\, \\frac{k_x (T^{(k)}_{i+1,j} + T^{(k+1)}_{i-1,j}) + k_y (T^{(k)}_{i,j+1} + T^{(k+1)}_{i,j-1}) + h^2 f_{i,j}}{2(k_x + k_y)}\n$$\n这里，$\\omega \\in (0, 2)$ 是松弛因子。在更新 $T_{i,j}$ 时，$T_{i-1,j}$ 和 $T_{i,j-1}$ 的值已经在第 $(k+1)$ 次迭代中更新为它们的新值，而 $T_{i+1,j}$ 和 $T_{i,j+1}$ 仍处于第 $k$ 次迭代的值。这种顺序数据依赖性使得SOR在其标准形式下是内在地不可并行的，但如果 $\\omega$ 选择得当，通常会比雅可比方法收敛得更快。\n\n#### **2.3. 切换准则与 $\\omega$ 估计**\n\n求解器从雅可比迭代开始。混合策略的核心是切换到SOR的准则。\n1.  **监控：** 在雅可比阶段，我们在每次迭代 $k$ 时计算残差的L2范数 $||r^{(k)}||_2$。残差定义为 $r^{(k)} = A T^{(k)} - \\mathbf{b}$，其逐点分量为 $r^{(k)}_{i,j} = 2(k_x + k_y) T^{(k)}_{i,j} - k_x (T^{(k)}_{i+1,j} + T^{(k)}_{i-1,j}) - k_y (T^{(k)}_{i,j+1} + T^{(k)}_{i,j-1}) - h^2 f_{i,j}$。然后我们跟踪残差下降比率序列 $q_k = ||r^{(k)}||_2 / ||r^{(k-1)}||_2$。\n2.  **条件：** 对于 $k$ 在 $N_{\\min}$ 和 $N_{\\max}$ 之间的迭代，我们检查一个包含 $m$ 个最新比率的滑动窗口。如果同时满足两个条件，则触发向SOR的切换：\n    -   窗口中的比率已稳定：$\\max(q_{k-m+1}, \\dots, q_k) - \\min(q_{k-m+1}, \\dots, q_k) \\le \\delta$。\n    -   求解器正在收敛：平均比率 $\\frac{1}{m}\\sum_{j=k-m+1}^k q_j  1$。\n3.  **Omega估计：** 切换时，窗口中比率的平均值 $\\hat{\\rho}_J = \\text{mean}(q_{k-m+1}, \\dots, q_k)$ 作为雅可比迭代矩阵谱半径的估计值。这是合理的，因为对于收敛的线性迭代，渐近收敛率由谱半径决定，这表现为连续误差（和残差）范数的比率。对于由此离散化产生的矩阵类别，一个完善的理论结果将最优SOR松弛因子 $\\omega_{\\text{opt}}$ 与雅可比谱半径 $\\rho_J$ 联系起来：\n    $$\n    \\omega_{\\text{opt}} = \\frac{2}{1 + \\sqrt{1 - \\rho_J^2}}\n    $$\n    我们在此公式中使用我们的估计值 $\\hat{\\rho}_J$ 来计算后续SOR迭代的 $\\omega$ 值。由于切换条件要求 $\\hat{\\rho}_J  1$，平方根的参数为正，计算出的 $\\omega$ 将在范围 $[1, 2)$ 内，满足收敛性要求 $\\omega \\in (0, 2)$。如果求解器没有切换到SOR，$\\omega$ 报告为 $1.0$。\n\n### **3. 算法实现**\n\n总体算法如下：\n1.  **初始化：**\n    -   设置网格参数 $n, h$。为温度 $T$ 和源项 $f$ 构建 $(n+2) \\times (n+2)$ 的数组。初始化 $T^{(0)} = 0$。\n    -   根据测试用例计算源项数组 $f$ 和右端项数组 $\\mathbf{b} = h^2 f$。\n    -   计算初始残差范数 $||r^{(0)}||_2 = ||A T^{(0)} - \\mathbf{b}||_2 = ||-\\mathbf{b}||_2$。\n    -   确定停止容差：$||r^{(k)}||_2 \\le \\tau ||r^{(0)}||_2$。\n\n2.  **主迭代循环：**\n    -   循环持续直到满足停止准则。\n    -   初始化 `mode = 'jacobi'`, `switched = 0`, `iter_count = 0`。\n    -   在循环内部，如果 `mode == 'jacobi'`:\n        -   执行一次雅可比更新以从 $T^{(k)}$ 得到 $T^{(k+1)}$。\n        -   `iter_count` 加一。\n        -   计算新的残差范数 $||r^{(k+1)}||_2$。\n        -   计算并存储比率 $q_{k+1} = ||r^{(k+1)}||_2 / ||r^{(k)}||_2$。\n        -   如果 $N_{\\min} \\le \\text{iter\\_count} \\le N_{\\max}$ 且有足够的比率可用，检查切换条件。如果满足，设置 `mode = 'sor'`, `switched = 1`，并计算 $\\omega$。\n    -   如果 `mode == 'sor'`:\n        -   通过遍历所有内部网格点来执行一次SOR更新。\n        -   `iter_count` 加一。\n        -   计算新的残差范数 $||r^{(k+1)}||_2$。\n\n3.  **终止：**\n    -   一旦 $||r^{(k)}||_2$ 低于目标值，循环终止。\n    -   将总的 `iter_count`、`switched` 标志（$1$ 或 $0$）以及计算出的 `omega`（如果未发生切换则为 $1.0$）记录下来用于该测试用例。\n\n对提供的三个测试用例中的每一个都实现了此结构。",
            "answer": "```python\nimport numpy as np\n\ndef run_solver(n, kx, ky, f_type, tau, m, N_min, N_max, delta):\n    \"\"\"\n    Implements the hybrid Jacobi-SOR solver for a single test case.\n\n    Args:\n        n (int): Number of interior grid points along one dimension.\n        kx (float): Conductivity in the x-direction.\n        ky (float): Conductivity in the y-direction.\n        f_type (str): Type of source function ('constant', 'sinsin', 'checkerboard').\n        tau (float): Relative tolerance for stopping criterion.\n        m (int): Sliding window length for switching criterion.\n        N_min (int): Minimum number of Jacobi iterations before checking switch condition.\n        N_max (int): Maximum number of Jacobi iterations before checking switch condition.\n        delta (float): Stability band for ratios in switching criterion.\n\n    Returns:\n        tuple: (total_iterations, switched_flag, omega_value)\n    \"\"\"\n    h = 1.0 / (n + 1)\n\n    # Setup source term f and RHS b\n    f = np.zeros((n + 2, n + 2))\n    if f_type == 'constant':\n        f[1:-1, 1:-1] = 1.0\n    elif f_type == 'sinsin':\n        # Use 'ij' indexing to match loops used for i, j indices\n        x_coords = np.linspace(0, 1, n + 2)\n        y_coords = np.linspace(0, 1, n + 2)\n        X, Y = np.meshgrid(x_coords, y_coords, indexing='ij')\n        f = np.sin(np.pi * X) * np.sin(np.pi * Y)\n    elif f_type == 'checkerboard':\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                f[i, j] = (-1)**(i + j)\n    b = h**2 * f\n\n    def calculate_residual_norm(T_mat):\n        \"\"\"Computes the L2 norm of the residual r = AT - b.\"\"\"\n        res_mat = (2 * (kx + ky) * T_mat[1:-1, 1:-1] -\n                   kx * (T_mat[2:, 1:-1] + T_mat[:-2, 1:-1]) -\n                   ky * (T_mat[1:-1, 2:] + T_mat[1:-1, :-2]) -\n                   b[1:-1, 1:-1])\n        return np.linalg.norm(res_mat)\n\n    # Initialization\n    T = np.zeros((n + 2, n + 2))\n    \n    initial_res_norm = calculate_residual_norm(T)\n    if initial_res_norm == 0:\n        return 0, 0, 1.0\n        \n    stop_norm = tau * initial_res_norm\n    \n    iter_count = 0\n    switched = 0\n    omega = 1.0\n    mode = 'jacobi'\n    res_ratios = []\n    \n    current_res_norm = initial_res_norm\n    # Safety break to prevent infinite loops\n    max_total_iters = 50000 \n    \n    while current_res_norm > stop_norm and iter_count  max_total_iters:\n        T_old = np.copy(T)\n        previous_res_norm = current_res_norm\n\n        if mode == 'jacobi':\n            # Jacobi update\n            T[1:-1, 1:-1] = (kx * (T_old[2:, 1:-1] + T_old[:-2, 1:-1]) +\n                             ky * (T_old[1:-1, 2:] + T_old[1:-1, :-2]) +\n                             b[1:-1, 1:-1]) / (2 * (kx + ky))\n            \n            iter_count += 1\n            current_res_norm = calculate_residual_norm(T)\n            \n            if previous_res_norm > 1e-15:\n                res_ratios.append(current_res_norm / previous_res_norm)\n            \n            if N_min = iter_count = N_max and len(res_ratios) >= m:\n                window = res_ratios[-m:]\n                mean_q = np.mean(window)\n                \n                if (np.max(window) - np.min(window) = delta) and (mean_q  1.0):\n                    switched = 1\n                    mode = 'sor'\n                    rho_J_est = mean_q\n                    omega = 2 / (1 + np.sqrt(1 - rho_J_est**2))\n        \n        else: # mode == 'sor'\n            # SOR update\n            for i in range(1, n + 1):\n                for j in range(1, n + 1):\n                    # Uses newest T[i-1,j] and T[i,j-1] from this sweep\n                    gs_sum = kx * (T_old[i+1, j] + T[i-1, j]) + ky * (T_old[i, j+1] + T[i, j-1])\n                    gs_term = (gs_sum + b[i, j]) / (2 * (kx + ky))\n                    T[i, j] = (1 - omega) * T_old[i, j] + omega * gs_term\n            \n            iter_count += 1\n            current_res_norm = calculate_residual_norm(T)\n            \n    if switched == 0:\n        omega_val = 1.0\n    else:\n        omega_val = omega\n\n    return iter_count, switched, omega_val\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Test Case A\n        {'n': 50, 'kx': 1, 'ky': 1, 'f_type': 'constant', 'tau': 1e-6,\n         'm': 20, 'N_min': 40, 'N_max': 100, 'delta': 5e-4},\n        # Test Case B\n        {'n': 60, 'kx': 4, 'ky': 1, 'f_type': 'sinsin', 'tau': 5e-7,\n         'm': 25, 'N_min': 50, 'N_max': 120, 'delta': 8e-4},\n        # Test Case C\n        {'n': 8, 'kx': 1, 'ky': 1, 'f_type': 'checkerboard', 'tau': 1e-6,\n         'm': 10, 'N_min': 15, 'N_max': 40, 'delta': 1e-3}\n    ]\n\n    results = []\n    for case in test_cases:\n        iters, switch_flag, omega_final = run_solver(**case)\n        results.append([iters, switch_flag, omega_final])\n\n    # Format the output string precisely as requested\n    formatted_results = []\n    for r in results:\n        # r[2] is float; format it to 5 decimal places\n        formatted_results.append(f\"[{r[0]},{r[1]},{r[2]:.5f}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```"
        }
    ]
}