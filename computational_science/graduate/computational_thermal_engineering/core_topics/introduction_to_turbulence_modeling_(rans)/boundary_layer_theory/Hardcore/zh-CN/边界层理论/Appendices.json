{
    "hands_on_practices": [
        {
            "introduction": "Blasius解是层流平板边界层理论的基石，它将偏微分控制方程简化为了一个非线性常微分方程。虽然该方程没有解析解，但可以通过数值方法精确求解。本实践将指导你使用“打靶法”——一种强大的数值技术——来求解这个经典的边值问题，从而获得与壁面剪切应力直接相关的关键无量纲参数$f''(0)$。",
            "id": "3938896",
            "problem": "考虑在一个与均匀自由来流速度 $U_{\\infty}$ 对齐的半无限平板上形成的二维、稳态、不可压缩的层流边界层。从边界层流动的质量和动量守恒出发，其控制方程为连续性方程 $\\partial u / \\partial x + \\partial v / \\partial y = 0$ 和流向动量方程 $u \\, \\partial u / \\partial x + v \\, \\partial u / \\partial y = \\nu \\, \\partial^2 u / \\partial y^2$，其中 $u(x,y)$ 和 $v(x,y)$ 分别是流向和壁面法向的速度分量，$\\nu$ 是运动粘度。采用流函数表示并寻找具有适当缩放的相似变量的相似解，可将上述偏微分方程组简化为关于无量纲流函数剖面 $f(\\eta)$ 的经典 Blasius 常微分方程 (ODE)：\n$$\nf'''(\\eta) + \\tfrac{1}{2} f(\\eta) \\, f''(\\eta) = 0,\n$$\n其边界条件为\n$$\nf(0) = 0, \\quad f'(0) = 0, \\quad \\text{以及} \\quad f'(\\eta \\to \\infty) = 1,\n$$\n其中，撇号表示对相似变量 $\\eta$ 的微分。我们感兴趣的量是未知的初始曲率 $f''(0)$，它决定了壁面切应力，并且是一个无量纲数。\n\n你的任务是实现一种数值打靶法来求解上述初值问题 (IVP)，并确定 $f''(0)$ 的值，要求结果至少有四位有效数字。将 $s = f''(0)$ 视为一个打靶参数。对于任意试验值 $s$，使用一个现代自适应常微分方程求解器，将 Blasius 常微分方程作为一个一阶系统从 $\\eta = 0$ 积分到一个有限截断值 $\\eta = L$。定义残差\n$$\nR(s; L) = f'(\\eta = L; s) - 1,\n$$\n并找到使 $R(s; L) = 0$ 成立的 $s$。将你计算出的 $s$ 与经典参考值 $s_{\\mathrm{ref}} = 0.332057336215$ 进行比较，并评估结果是否至少有四位有效数字是正确的。对于此评估，如果绝对误差 $|s - s_{\\mathrm{ref}}| \\le 0.00005$，则判定为通过，这保证了对于一个接近 $s_{\\mathrm{ref}}$ 的值，其四舍五入到四位有效数字的结果是正确的。\n\n该解法必须是纯算法且无量纲的。在一个无需任何外部输入的单一程序中实现你的求解器，并生成所需的输出。使用标准科学计算库中的自适应常微分方程积分器来精确处理该初值问题。你可以使用诸如二分法或割线法等一维求根方法来求解打靶参数。\n\n测试套件：\n为以下参数集 $(L, \\mathrm{rtol}, \\mathrm{atol})$ 提供结果，其中 $L$ 是相似变量的有限截断值，$\\mathrm{rtol}$ 和 $\\mathrm{atol}$ 分别是 ODE 求解器的相对和绝对容差。所有量均为无量纲。\n\n- 情况 1：$(L, \\mathrm{rtol}, \\mathrm{atol}) = (10.0, 10^{-9}, 10^{-11})$。\n- 情况 2：$(L, \\mathrm{rtol}, \\mathrm{atol}) = (4.0, 10^{-8}, 10^{-10})$。\n- 情况 3：$(L, \\mathrm{rtol}, \\mathrm{atol}) = (20.0, 10^{-8}, 10^{-10})$。\n- 情况 4：$(L, \\mathrm{rtol}, \\mathrm{atol}) = (10.0, 10^{-6}, 10^{-8})$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。每个元素对应一个测试用例，并且必须是 $[s, e, p]$ 形式的三元素列表，其中 $s$ 是计算出的 $f''(0)$ 并四舍五入到六位小数的值，$e$ 是绝对误差 $|s - s_{\\mathrm{ref}}|$ 并四舍五入到六位小数的值，$p$ 是一个布尔值，指示是否满足四位有效数字的标准。例如，输出格式必须为：\n$$\n[[s_1, e_1, p_1],[s_2, e_2, p_2],[s_3, e_3, p_3],[s_4, e_4, p_4]].\n$$",
            "solution": "用户提出的问题具有科学依据、良构且客观。它涉及使用标准的打靶法对 Blasius 方程进行数值求解，这是流体力学中的一个经典问题。所有需要的数据、边界条件和评估标准均已提供。该问题是有效的。\n\n核心任务是求解关于无量纲流函数剖面 $f(\\eta)$ 的三阶非线性常微分方程 (ODE) 边值问题 (BVP)。该 ODE 是 Blasius 方程：\n$$\nf'''(\\eta) + \\tfrac{1}{2} f(\\eta) \\, f''(\\eta) = 0\n$$\n遵循以下边界条件：\n$$\nf(0) = 0, \\quad f'(0) = 0, \\quad \\text{以及} \\quad f'(\\eta \\to \\infty) = 1\n$$\n目标是找到未知初始条件 $f''(0)$ 的值。这类 BVP 非常适合使用打靶法，该方法将 BVP 转化为一个可以迭代求解的初值问题 (IVP)。\n\n**步骤 1：转换为一阶常微分方程组**\n为使用标准的 IVP 求解器，必须将三阶 ODE 转换为一个包含三个一阶 ODE 的方程组。我们定义一个状态向量 $y(\\eta)$ 如下：\n$$\ny(\\eta) = \\begin{bmatrix} y_0(\\eta) \\\\ y_1(\\eta) \\\\ y_2(\\eta) \\end{bmatrix} = \\begin{bmatrix} f(\\eta) \\\\ f'(\\eta) \\\\ f''(\\eta) \\end{bmatrix}\n$$\n向量 $y$ 的各分量对 $\\eta$ 的导数构成了如下方程组：\n$$\n\\frac{d y}{d \\eta} = \\begin{bmatrix} y_0' \\\\ y_1' \\\\ y_2' \\end{bmatrix} = \\begin{bmatrix} f' \\\\ f'' \\\\ f''' \\end{bmatrix} = \\begin{bmatrix} y_1 \\\\ y_2 \\\\ -\\frac{1}{2} f f'' \\end{bmatrix} = \\begin{bmatrix} y_1 \\\\ y_2 \\\\ -0.5 \\, y_0 \\, y_2 \\end{bmatrix}\n$$\n这就是将要进行数值积分的一阶常微分方程组。\n\n**步骤 2：打靶法**\n打靶法通过将缺失的初始条件 $f''(0)$ 视为一个参数（我们称之为 $s$）来解决此问题。我们通过猜测 $s$ 并积分 IVP，从 $\\eta=0$ 开始“发射”解。目标是调整 $s$，直到满足域远端的边界条件。\n\n在 $\\eta=0$ 处的 IVP 初始条件为：\n$$\nf(0) = 0 \\quad \\implies \\quad y_0(0) = 0\n$$\n$$\nf'(0) = 0 \\quad \\implies \\quad y_1(0) = 0\n$$\n缺失的条件就是我们的打靶参数：\n$$\nf''(0) = s \\quad \\implies \\quad y_2(0) = s\n$$\n因此，我们 IVP 的初始状态向量为 $y(0) = [0, 0, s]^T$。\n\n无穷远处的边界条件 $f'(\\eta \\to \\infty) = 1$ 在数值上是难以处理的。我们通过在相似变量的一个有限但足够大的值 $\\eta = L$ 上施加该条件来进行近似。该条件变为 $f'(L; s) = 1$，或者用我们的状态向量表示为 $y_1(L; s) = 1$。参数 $L$ 是测试套件中指定的输入之一。\n\n我们定义一个残差函数 $R(s; L)$，它衡量给定的猜测值 $s$ 与满足远场边界条件的差距：\n$$\nR(s; L) = y_1(L; s) - 1\n$$\n现在问题简化为求解方程 $R(s;L) = 0$ 的根。\n\n**步骤 3：数值实现**\n总体算法如下：\n1. 对于由元组 $(L, \\mathrm{rtol}, \\mathrm{atol})$ 指定的每个测试用例，我们需要找到求解 $R(s; L) = 0$ 的 $s$ 值。\n2. 对于任意给定的 $s$，残差函数 $R(s; L)$ 的评估需要使用一个现代自适应 ODE 求解器（具体为 `scipy.integrate.solve_ivp`）以及所提供的相对容差 `rtol` 和绝对容差 `atol`，将一阶 ODE 系统从 $\\eta=0$ 积分到 $\\eta=L$，初始条件为 $y(0) = [0, 0, s]^T$。该求解器会自动调整其内部步长以达到所需精度。\n3. 使用一个鲁棒的一维求根算法来找到使 $R(s; L) = 0$ 的 $s$ 值。`scipy.optimize.brentq` 函数实现了 Brent 方法，是一个极佳的选择。它需要一个区间 $[s_a, s_b]$，使得残差函数在端点处符号相反，即 $R(s_a; L) \\times R(s_b; L)  0$。一个合适的区间是 $[0, 1]$。当 $s=0$ 时，解显然为 $f(\\eta)=0$，所以 $y_1(L)=0$ 且 $R(0; L) = -1$。当 $s=1$ 时，初始曲率很大，我们预计速度剖面会超过目标值，使得 $y_1(L) > 1$ 因而 $R(1; L) > 0$。这个区间保证了根的存在。\n4. 一旦找到根 $s$（即我们对 $f''(0)$ 的近似值），就将其与高精度参考值 $s_{\\mathrm{ref}} = 0.332057336215$ 进行比较。计算绝对误差 $e = |s - s_{\\mathrm{ref}}|$。\n5. 如果满足精度标准 $e \\le 0.00005$，则将一个通过/失败标志 $p$ 设置为 `True`，否则设置为 `False`。\n6. 将计算出的值 $s$ 和误差 $e$ 四舍五入到六位小数，并存储三元组 $[s, e, p]$。对所有测试用例重复此过程。\n\n最终输出是这些三元组的列表，根据问题规范格式化为字符串。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves the Blasius equation for f''(0) using a shooting method\n    for a suite of test cases and formats the output.\n    \"\"\"\n\n    # High-precision reference value for f''(0)\n    S_REF = 0.332057336215\n    # Accuracy criterion for passing the test\n    PASS_CRITERION = 0.00005\n\n    def blasius_ode_system(eta, y):\n        \"\"\"\n        Defines the first-order ODE system for the Blasius equation.\n        The state vector y is [f, f', f''].\n        The system returns [y', y'', y'''] = [f', f'', f'''].\n        The Blasius equation is f''' = -0.5 * f * f''.\n        \"\"\"\n        return [y[1], y[2], -0.5 * y[0] * y[2]]\n\n    def solve_blasius(L, rtol, atol):\n        \"\"\"\n        Finds s = f''(0) for a given set of numerical parameters.\n\n        It uses a root-finding algorithm (Brent's method) on a residual\n        function. The residual represents the error in the far-field\n        boundary condition f'(L) = 1.\n\n        Args:\n            L (float): Finite truncation of the semi-infinite domain.\n            rtol (float): Relative tolerance for the ODE solver.\n            atol (float): Absolute tolerance for the ODE solver.\n\n        Returns:\n            float: The computed value of s = f''(0).\n        \"\"\"\n        \n        def residual(s):\n            \"\"\"\n            Computes the residual R(s) = f'(L; s) - 1.\n            This function is the target for the root-finder.\n            It solves the IVP for a given shooting parameter s.\n            \"\"\"\n            # Initial conditions: y(0) = [f(0), f'(0), f''(0)]\n            y0 = [0.0, 0.0, s]\n            \n            # Solve the IVP from eta=0 to eta=L\n            sol = solve_ivp(\n                fun=blasius_ode_system,\n                t_span=[0, L],\n                y0=y0,\n                method='RK45',  # Adaptive Runge-Kutta method\n                rtol=rtol,\n                atol=atol\n            )\n            \n            # Extract f'(L), which is the second component of the solution\n            # at the last time point.\n            f_prime_at_L = sol.y[1, -1]\n            return f_prime_at_L - 1.0\n\n        # Find the root of the residual function s.\n        # A bracket of [0, 1] is robust:\n        # s=0 - f'=0 - residual=-1\n        # s=1 - f' overshoots 1 - residual  0\n        try:\n            s_solution = brentq(residual, a=0.0, b=1.0, xtol=1e-15, rtol=1e-15)\n        except ValueError:\n            # In case the bracket is invalid for extreme parameters,\n            # which shouldn't happen for this problem.\n            return np.nan\n            \n        return s_solution\n\n    # Test suite provided in the problem statement\n    test_cases = [\n        (10.0, 1e-9, 1e-11),\n        (4.0, 1e-8, 1e-10),\n        (20.0, 1e-8, 1e-10),\n        (10.0, 1e-6, 1e-8),\n    ]\n\n    results = []\n    for L, rtol, atol in test_cases:\n        s_computed = solve_blasius(L, rtol, atol)\n        \n        error = abs(s_computed - S_REF)\n        passed = (error = PASS_CRITERION)\n        \n        s_rounded = round(s_computed, 6)\n        error_rounded = round(error, 6)\n        \n        results.append([s_rounded, error_rounded, passed])\n\n    # Generate the output string in the exact specified format.\n    # The default string representation of a list of lists matches the format,\n    # and spaces are removed to be precise.\n    output_string = str(results).replace(\" \", \"\")\n    print(output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "在许多工程应用中，例如实验测量或复杂的数值模拟，我们处理的是离散的速度剖面数据，而非解析解。本实践旨在让你掌握如何从这些数据中计算出关键的边界层积分参数，如位移厚度($\\delta^*$)和动量厚度($\\theta$)。此外，它还将演示如何运用强大的动量积分方程来估算壁面剪切应力，这是一个在实际中难以直接精确测量的物理量。",
            "id": "3938934",
            "problem": "考虑在光滑平板上，流向压力梯度为零的稳定、不可压缩、二维层流边界层。一个测量系统在两个相邻的流向位置上提供了垂直于壁面的离散速度剖面，其中一个位置在 $x=0.3\\,\\mathrm{m}$。您必须仅使用基本定义和边界层动量积分关系，从离散数据中计算下游位置 $x=0.3\\,\\mathrm{m}$ 处的位移厚度和动量厚度，然后推断出 $x=0.3\\,\\mathrm{m}$ 处的壁面切应力和表面摩擦系数。\n\n所有计算必须基于以下原理：\n- 位移厚度 $\\delta^\\*$ 定义为\n$$\n\\delta^\\* \\equiv \\int_{0}^{\\infty} \\left(1 - \\frac{u(y)}{U_\\infty}\\right)\\,\\mathrm{d}y,\n$$\n其中 $u(y)$ 是在壁面法向坐标 $y$ 处的局部平均流向速度，$U_\\infty$ 是自由流速度。\n- 动量厚度 $\\theta$ 定义为\n$$\n\\theta \\equiv \\int_{0}^{\\infty} \\frac{u(y)}{U_\\infty}\\left(1 - \\frac{u(y)}{U_\\infty}\\right)\\,\\mathrm{d}y.\n$$\n- 在所述条件下（稳定、不可压缩、二维、零压力梯度），适用于平板的流向动量积分关系将壁面切应力 $\\tau_w$ 与动量厚度的流向演化联系起来。\n\n您必须使用为非均匀网格设计的、一致的数值积分方法，处理从 $y=0$ 到作为离散数据一部分提供的有限 $y_{\\max}$ 的积分。速度剖面以离散样本 $(y_i, u_i)$ 的形式提供，其中 $i$ 是样本的索引，$y_0=0$ 对应于壁面。\n\n给定一个包含三种场景的测试套件。在每种场景中，都必须使用两个流向位置 $x_1$ 和 $x_2$（其中 $x_2=0.3\\,\\mathrm{m}$）的离散剖面。自由流速度 $U_\\infty$ 和流体密度 $\\rho$ 均已给定。离散剖面是使用广泛应用的四阶 Pohlhausen 型多项式近似生成的，该近似适用于层流零压力梯度边界层：\n$$\n\\frac{u(y;x)}{U_\\infty} =\n\\begin{cases}\n2\\eta - 2\\eta^3 + \\eta^4,  \\text{若 } \\eta \\le 1,\\\\\n1,  \\text{若 } \\eta  1,\n\\end{cases}\n\\quad \\text{其中} \\quad \\eta \\equiv \\frac{y}{\\delta(x)},\n$$\n其中 $\\delta(x)$ 是用于生成剖面的预设边界层厚度参数。离散采样点在 $y=0$ 和 $y=y_{\\max}$ 之间均匀分布，点数为指定的 $N$ 个，每个 $y$ 处的速度 $u(y;x)$ 由上述表达式确定。\n\n对于每种场景，计算在 $x=x_2$ 处的值：\n- 位移厚度 $\\delta^\\*$，单位为 $\\mathrm{m}$。\n- 动量厚度 $\\theta$，单位为 $\\mathrm{m}$。\n- 壁面切应力 $\\tau_w$，单位为 $\\mathrm{Pa}$ (帕斯卡)，通过边界层动量积分关系以及使用两个站点 $x_1$ 和 $x_2$ 对 $\\mathrm{d}\\theta/\\mathrm{d}x$ 进行的一致数值近似来推断。\n- 表面摩擦系数（无量纲），定义为 $C_f \\equiv \\tau_w/\\left(\\frac{1}{2}\\rho U_\\infty^2\\right)$。\n\n如果中间计算中出现角度，请使用弧度，尽管本问题没有明确要求角度计算。最终数值结果需以指定单位表示，并将每个输出数字四舍五入到六位小数。\n\n测试套件参数集：\n- 场景 1 (理想情况):\n    - $U_\\infty = 10.0\\,\\mathrm{m/s}$，$\\rho = 1.20\\,\\mathrm{kg/m^3}$，$x_1 = 0.295\\,\\mathrm{m}$，$x_2 = 0.300\\,\\mathrm{m}$，\n    - $y_{\\max} = 0.015\\,\\mathrm{m}$，$N = 61$，\n    - $\\delta(x_1) = 0.00335\\,\\mathrm{m}$，$\\delta(x_2) = 0.00340\\,\\mathrm{m}$。\n- 场景 2 (壁面法向粗采样):\n    - $U_\\infty = 20.0\\,\\mathrm{m/s}$，$\\rho = 1.20\\,\\mathrm{kg/m^3}$，$x_1 = 0.290\\,\\mathrm{m}$，$x_2 = 0.300\\,\\mathrm{m}$，\n    - $y_{\\max} = 0.012\\,\\mathrm{m}$，$N = 11$，\n    - $\\delta(x_1) = 0.00236\\,\\mathrm{m}$，$\\delta(x_2) = 0.00240\\,\\mathrm{m}$。\n- 场景 3 (小流向间距):\n    - $U_\\infty = 5.0\\,\\mathrm{m/s}$，$\\rho = 1.20\\,\\mathrm{kg/m^3}$，$x_1 = 0.299\\,\\mathrm{m}$，$x_2 = 0.300\\,\\mathrm{m}$，\n    - $y_{\\max} = 0.018\\,\\mathrm{m}$，$N = 41$，\n    - $\\delta(x_1) = 0.00475\\,\\mathrm{m}$，$\\delta(x_2) = 0.00480\\,\\mathrm{m}$。\n\n您的程序必须：\n- 使用上述参数生成离散剖面。\n- 使用适用于非均匀网格的复合梯形法则，从离散数据计算 $x_2$ 处的 $\\delta^\\*$ 和 $\\theta$。\n- 使用基于两个测量剖面的有限差分法，近似计算 $x_1$ 和 $x_2$ 之间的 $\\mathrm{d}\\theta/\\mathrm{d}x$。\n- 在零压力梯度条件下，使用积分关系推断 $x_2$ 处的 $\\tau_w$ 和 $C_f$。\n\n最终输出格式规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。\n- 该列表必须按顺序包含三个场景的串联结果，每个场景按 $\\left[\\delta^\\*, \\theta, \\tau_w, C_f\\right]$ 的顺序提供四个数字。\n- 例如，输出应类似于 $\\left[\\delta^\\*_1,\\theta_1,\\tau_{w,1},C_{f,1},\\delta^\\*_2,\\theta_2,\\tau_{w,2},C_{f,2},\\delta^\\*_3,\\theta_3,\\tau_{w,3},C_{f,3}\\right]$，其中每个数字都四舍五入到六位小数。",
            "solution": "该问题是在平板上稳定、不可压缩、二维流动且压力梯度为零的边界层理论背景下提出的。其推导过程源于基本定义和边界层动量积分关系。\n\n首先从核心定义开始，这些定义不依赖于任何特定的闭式解，而仅依赖于测量的剖面。位移厚度 $\\delta^\\*$ 定义为\n$$\n\\delta^\\* = \\int_0^\\infty \\left(1 - \\frac{u(y)}{U_\\infty}\\right)\\,\\mathrm{d}y,\n$$\n动量厚度 $\\theta$ 定义为\n$$\n\\theta = \\int_0^\\infty \\frac{u(y)}{U_\\infty}\\left(1 - \\frac{u(y)}{U_\\infty}\\right)\\,\\mathrm{d}y.\n$$\n由于测量仅在有限的 $y_{\\max}$ 范围内可用，我们通过在 $y_{\\max}$ 处截断来近似半无限积分：\n$$\n\\delta^\\* \\approx \\int_0^{y_{\\max}} \\left(1 - \\frac{u(y)}{U_\\infty}\\right)\\,\\mathrm{d}y,\\quad\n\\theta \\approx \\int_0^{y_{\\max}} \\frac{u(y)}{U_\\infty}\\left(1 - \\frac{u(y)}{U_\\infty}\\right)\\,\\mathrm{d}y.\n$$\n这些积分使用复合梯形法则在离散的非均匀网格 $\\{y_i\\}_{i=0}^{N-1}$ 上进行数值计算。如果我们将 $\\delta^\\*$ 的被积函数表示为 $f(y) = 1 - u(y)/U_\\infty$，将 $\\theta$ 的被积函数表示为 $g(y) = (u/U_\\infty)(1 - u/U_\\infty)$，那么复合梯形法则得出\n$$\n\\int_0^{y_{\\max}} f(y)\\,\\mathrm{d}y \\approx \\sum_{i=0}^{N-2} \\frac{f(y_i) + f(y_{i+1})}{2}\\,(y_{i+1} - y_i),\n$$\n$\\int_0^{y_{\\max}} g(y)\\,\\mathrm{d}y$ 的计算也与此类似。\n\n为了通过积分关系推断壁面切应力 $\\tau_w$，我们引用通过对边界层内的 Navier–Stokes 方程进行积分而导出的边界层动量积分方程。对于平板上稳定、不可压缩、二维、零压力梯度且自由流速度 $U_\\infty$ 恒定的流动，该关系式简化为\n$$\n\\frac{\\mathrm{d}\\theta}{\\mathrm{d}x} = \\frac{\\tau_w}{\\rho U_\\infty^2}.\n$$\n该方程是边界层流向动量平衡的表述：动量厚度相对于 $x$ 的增长率与归一化的壁面切应力成正比。重新整理得到\n$$\n\\tau_w = \\rho U_\\infty^2\\,\\frac{\\mathrm{d}\\theta}{\\mathrm{d}x}.\n$$\n表面摩擦系数（在此首次定义）为 $C_f \\equiv \\tau_w/\\left(\\frac{1}{2}\\rho U_\\infty^2\\right)$，从而得出\n$$\nC_f = \\frac{\\tau_w}{\\frac{1}{2}\\rho U_\\infty^2} = 2\\,\\frac{\\mathrm{d}\\theta}{\\mathrm{d}x}.\n$$\n所需的导数 $\\mathrm{d}\\theta/\\mathrm{d}x$ 并未以解析形式提供，因此我们使用两个相邻站点 $x_1$ 和 $x_2$ 之间的有限差分来近似它：\n$$\n\\frac{\\mathrm{d}\\theta}{\\mathrm{d}x}\\bigg|_{x_2} \\approx \\frac{\\theta(x_2) - \\theta(x_1)}{x_2 - x_1}.\n$$\n对于足够小的 $|x_2 - x_1|$（如所提供场景中的情况），这种近似是合理的。\n\n计算每个场景所需量的算法设计：\n1. 从 $y=0$ 到 $y=y_{\\max}$ 生成具有 $N$ 个均匀分布点的离散壁面法向网格 $\\{y_i\\}$，使用 $y_i = i\\,\\Delta y$，其中 $\\Delta y = y_{\\max}/(N-1)$。\n2. 使用零压力梯度的 Pohlhausen 型多项式在 $x_1$ 和 $x_2$ 处生成离散速度剖面：\n   - 定义 $\\eta_i(x) = y_i/\\delta(x)$。\n   - 如果 $\\eta_i \\le 1$，则计算 $u_i(x)/U_\\infty = 2\\eta_i - 2\\eta_i^3 + \\eta_i^4$；否则，$u_i(x)/U_\\infty = 1$。\n   - 乘以 $U_\\infty$ 以获得每个网格点上的 $u_i(x)$。\n3. 使用复合梯形法则计算 $\\delta^\\*(x_2)$ 和 $\\theta(x_2)$：\n   - 对于 $\\delta^\\*$，求和 $\\sum_{i=0}^{N-2} \\frac{\\left(1 - u_i(x_2)/U_\\infty\\right)+\\left(1 - u_{i+1}(x_2)/U_\\infty\\right)}{2}\\,(y_{i+1} - y_i)$。\n   - 对于 $\\theta$，求和 $\\sum_{i=0}^{N-2} \\frac{\\left(\\frac{u_i(x_2)}{U_\\infty}\\left(1 - \\frac{u_i(x_2)}{U_\\infty}\\right)\\right) + \\left(\\frac{u_{i+1}(x_2)}{U_\\infty}\\left(1 - \\frac{u_{i+1}(x_2)}{U_\\infty}\\right)\\right)}{2}\\,(y_{i+1} - y_i)$。\n4. 使用 $x_1$ 的剖面和该场景相同的网格构建参数（每个场景都提供自己的 $y_{\\max}$ 和 $N$），类似地计算 $\\theta(x_1)$。\n5. 通过有限差分 $(\\theta(x_2) - \\theta(x_1))/(x_2 - x_1)$ 近似计算 $x_2$ 处的 $\\mathrm{d}\\theta/\\mathrm{d}x$。\n6. 计算 $\\tau_w = \\rho U_\\infty^2\\,\\mathrm{d}\\theta/\\mathrm{d}x$（单位 $\\mathrm{Pa}$）和 $C_f = 2\\,\\mathrm{d}\\theta/\\mathrm{d}x$（无量纲）。\n7. 将每个输出量（$\\delta^\\*$、$\\theta$、$\\tau_w$、 $C_f$）四舍五入到六位小数，并将所有场景的结果汇总为指定的单行输出格式。\n\n科学真实性：\n- Pohlhausen 型多项式在零压力梯度下提供了一个自洽的层流边界层剖面。\n- 当剖面在远小于 $y_{\\max}$ 处达到自由流值（$u/U_\\infty \\approx 1$）时，在 $y_{\\max}$ 处的数值积分截断是可以接受的，这一点由剖面模型保证。\n- $\\mathrm{d}\\theta/\\mathrm{d}x$ 的有限差分近似因流向间距小而合理，并且与用于推断 $\\tau_w$ 的积分关系相一致。\n\n该方法将基本定义与动量积分原理相结合，以推断壁面切应力，而无需直接对近壁速度进行微分，这与在给定条件下使用积分关系的指令相符。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef pohlhausen_profile(y, delta, U_inf):\n    \"\"\"\n    Compute u(y)/U_inf using a 4th-degree Pohlhausen-type polynomial for zero pressure gradient.\n    For eta = y/delta = 1: f(eta) = 2*eta - 2*eta**3 + eta**4\n    For eta > 1: f(eta) = 1\n    Returns u(y) in m/s for array y.\n    \"\"\"\n    eta = y / delta\n    f = np.where(eta = 1.0, 2*eta - 2*eta**3 + eta**4, 1.0)\n    return U_inf * f\n\ndef trapezoidal_integral(y, integrand):\n    \"\"\"\n    Composite trapezoidal rule over nonuniform grid y for integrand values.\n    Assumes y is sorted ascending and integrand has same shape.\n    \"\"\"\n    return np.sum(0.5 * (integrand[:-1] + integrand[1:]) * (y[1:] - y[:-1]))\n\ndef thicknesses_from_profile(y, u, U_inf):\n    \"\"\"\n    Compute displacement thickness delta_star and momentum thickness theta\n    from discrete profile (y, u) using trapezoidal rule.\n    \"\"\"\n    # Ensure arrays are numpy and sorted by y\n    y = np.asarray(y)\n    u = np.asarray(u)\n    # Sort if not sorted\n    if not np.all(np.diff(y) >= 0):\n        idx = np.argsort(y)\n        y = y[idx]\n        u = u[idx]\n    # Compute integrands\n    phi = 1.0 - (u / U_inf)\n    psi = (u / U_inf) * (1.0 - (u / U_inf))\n    # Integrate\n    delta_star = trapezoidal_integral(y, phi)\n    theta = trapezoidal_integral(y, psi)\n    return delta_star, theta\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: dict with U_inf, rho, x1, x2, y_max, N, delta1, delta2\n    test_cases = [\n        {\n            \"U_inf\": 10.0,\n            \"rho\": 1.20,\n            \"x1\": 0.295,\n            \"x2\": 0.300,\n            \"y_max\": 0.015,\n            \"N\": 61,\n            \"delta1\": 0.00335,\n            \"delta2\": 0.00340,\n        },\n        {\n            \"U_inf\": 20.0,\n            \"rho\": 1.20,\n            \"x1\": 0.290,\n            \"x2\": 0.300,\n            \"y_max\": 0.012,\n            \"N\": 11,\n            \"delta1\": 0.00236,\n            \"delta2\": 0.00240,\n        },\n        {\n            \"U_inf\": 5.0,\n            \"rho\": 1.20,\n            \"x1\": 0.299,\n            \"x2\": 0.300,\n            \"y_max\": 0.018,\n            \"N\": 41,\n            \"delta1\": 0.00475,\n            \"delta2\": 0.00480,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        U_inf = case[\"U_inf\"]\n        rho = case[\"rho\"]\n        x1 = case[\"x1\"]\n        x2 = case[\"x2\"]\n        y_max = case[\"y_max\"]\n        N = case[\"N\"]\n        delta1 = case[\"delta1\"]\n        delta2 = case[\"delta2\"]\n\n        # Generate wall-normal grid\n        y = np.linspace(0.0, y_max, N)\n\n        # Generate profiles at x1 and x2 using the Pohlhausen-type approximation\n        u1 = pohlhausen_profile(y, delta1, U_inf)\n        u2 = pohlhausen_profile(y, delta2, U_inf)\n\n        # Compute thicknesses at x1 and x2\n        delta_star_2, theta_2 = thicknesses_from_profile(y, u2, U_inf)\n        _, theta_1 = thicknesses_from_profile(y, u1, U_inf)\n\n        # Finite difference for dtheta/dx at x2\n        dtheta_dx = (theta_2 - theta_1) / (x2 - x1)\n\n        # Infer wall shear stress and skin-friction coefficient via integral relation\n        tau_w = rho * (U_inf ** 2) * dtheta_dx  # Pa\n        C_f = 2.0 * dtheta_dx  # dimensionless\n\n        # Round to six decimal places\n        results.extend([\n            f\"{delta_star_2:.6f}\",\n            f\"{theta_2:.6f}\",\n            f\"{tau_w:.6f}\",\n            f\"{C_f:.6f}\",\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "边界层从层流到湍流的转捩是影响飞行器性能、热交换效率和许多其他工程系统设计的关键物理现象。$e^N$方法是预测这一转变的经典且广泛应用的工程工具。本实践将引导你实现一个基于$e^N$方法的转捩预测模型，通过对小扰动增长率的积分，来确定不稳定波增长到足以触发转捩的位置。",
            "id": "3938888",
            "problem": "考虑均匀自由来流中光滑平板上的二维、不可压缩、层流边界层。假设小振幅扰动在线性稳定性理论下演化，并且其流向空间放大足够缓慢，使得局部增长率的描述有意义。目标是使用指数 $e^N$ 框架，确定累积扰动增长达到指定阈值的流向转捩位置。所有长度必须以米表示，所有速度以米/秒表示，所有粘度以平方米/秒表示，最终的转捩位置必须以米报告，并四舍五入到小数点后四位。\n\n从基本原理出发，将扰动振幅 $A(x)$ 建模为在流向坐标 $x$ 上根据一个线性常微分方程演化，其局部增长率为 $s(x)$，使得 $A(x)$ 对 $x$ 的变化率与 $A(x)$ 和 $s(x)$ 成正比。累积增长因子 $N(x)$ 定义为从参考位置 $x_0$ 开始的振幅比的自然对数。当累积增长 $N(x)$ 达到指定的阈值 $N_{\\mathrm{th}}$ 时，我们认为在最小的流向位置 $x_t$ 处发生转捩。如果 $N(x)$ 在计算域内始终未达到 $N_{\\mathrm{th}}$，则转捩位置必须报告为 $-1.0$。\n\n为在计算上封闭该模型而无需调用完整的 Orr–Sommerfeld 分析，我们采用一个局部空间放大率 $s(x)$ 的包络模型，该模型量纲一致，并且能定性地代表在零压力梯度到缓变外部压力梯度中 Tollmien–Schlichting (TS) 波的放大情况。设外部速度模型为 $U_e(x) = U_\\infty \\left(\\frac{x}{x_0}\\right)^m$，适用于 $x \\ge x_0$，其中 $U_\\infty$ 是自由来流速度，$m$ 是 Falkner–Skan 压力梯度指数（$m = 0$ 表示零压力梯度，$m  0$ 表示逆压力梯度，$m > 0$ 表示顺压力梯度），$x_0$ 是前缘偏移量，在该位置假定边界层已充分发展，可以支持线性不稳定性分析。将基于 $x$ 的局部雷诺数定义为 $Re_x(x) = \\dfrac{U_e(x) \\, x}{\\nu}$，其中 $\\nu$ 是运动粘度。使用以下包络模型计算 $s(x)$：\n对于 $Re_x(x)  Re_{\\mathrm{crit}}$，令 $s(x) = 0$；对于 $Re_x(x) \\ge Re_{\\mathrm{crit}}$，定义\n$$\ns(x) = F_{\\mathrm{pg}} \\, c_0 \\, \\frac{U_e(x)}{\\nu} \\left( \\frac{Re_x(x) - Re_{\\mathrm{crit}}}{Re_{\\mathrm{ref}}} \\right)^{p} \\exp\\!\\left( -\\beta \\, \\frac{Re_x(x)}{Re_{\\mathrm{ref}}} \\right),\n$$\n其中 $c_0$ 是一个无量纲比例常数，$Re_{\\mathrm{crit}}$ 是不稳定的起始雷诺数，$Re_{\\mathrm{ref}}$ 是一个用于缩放包络的参考雷诺数，$p$ 是一个控制近起始增长行为的正指数，$\\beta$ 是一个正的包络衰减参数。因子 $F_{\\mathrm{pg}} = 1 - r \\, m$ 模拟了压力梯度对扰动增长包络的一阶失稳或稳定化影响，其中 $r$ 为正常数。函数 $s(x)$ 的单位是米的倒数，确保累积增长积分 $N(x)$ 是无量纲的。\n\n您的任务是编写一个程序，对于给定的参数，计算累积增长\n$$\nN(x) = \\int_{x_0}^{x} s(\\xi) \\, d\\xi\n$$\n并找到最小的 $x_t \\in [x_0, x_{\\mathrm{end}}]$ 使得 $N(x_t) = N_{\\mathrm{th}}$。如果在 $[x_0, x_{\\mathrm{end}}]$ 内不存在这样的 $x_t$，则必须返回 $-1.0$。在 $x \\in [x_0, x_{\\mathrm{end}}]$ 的均匀网格上使用数值积分，并在相邻网格点之间执行线性插值，以精确确定 $N(x)$ 与 $N_{\\mathrm{th}}$ 的交点位置。输出必须以米表示，并四舍五入到小数点后四位。\n\n使用以下测试套件实现并测试您的程序。每个测试用例都以国际单位制 (SI) 指定参数 $(U_\\infty, \\nu, x_0, x_{\\mathrm{end}}, m, c_0, Re_{\\mathrm{crit}}, Re_{\\mathrm{ref}}, p, \\beta, N_{\\mathrm{th}})$，所有情况下固定 $r = 1.5$。\n\n- 测试用例 1（一般情况，零压力梯度）：$(U_\\infty = 30.0, \\nu = 1.5 \\times 10^{-5}, x_0 = 0.05, x_{\\mathrm{end}} = 1.5, m = 0.0, c_0 = 5.0 \\times 10^{-6}, Re_{\\mathrm{crit}} = 3.5 \\times 10^{5}, Re_{\\mathrm{ref}} = 1.0 \\times 10^{6}, p = 1.0, \\beta = 0.3, N_{\\mathrm{th}} = 9.0)$。\n- 测试用例 2（域内无转捩）：$(U_\\infty = 15.0, \\nu = 1.5 \\times 10^{-5}, x_0 = 0.05, x_{\\mathrm{end}} = 1.5, m = 0.0, c_0 = 5.0 \\times 10^{-6}, Re_{\\mathrm{crit}} = 3.5 \\times 10^{5}, Re_{\\mathrm{ref}} = 1.0 \\times 10^{6}, p = 1.0, \\beta = 0.3, N_{\\mathrm{th}} = 9.0)$。\n- 测试用例 3（逆压力梯度导致失稳）：$(U_\\infty = 20.0, \\nu = 1.5 \\times 10^{-5}, x_0 = 0.05, x_{\\mathrm{end}} = 1.5, m = -0.25, c_0 = 5.0 \\times 10^{-6}, Re_{\\mathrm{crit}} = 3.5 \\times 10^{5}, Re_{\\mathrm{ref}} = 1.0 \\times 10^{6}, p = 1.0, \\beta = 0.3, N_{\\mathrm{th}} = 9.0)$。\n- 测试用例 4（接近域末端的更高阈值）：$(U_\\infty = 30.0, \\nu = 1.5 \\times 10^{-5}, x_0 = 0.05, x_{\\mathrm{end}} = 1.5, m = 0.0, c_0 = 5.0 \\times 10^{-6}, Re_{\\mathrm{crit}} = 3.5 \\times 10^{5}, Re_{\\mathrm{ref}} = 1.0 \\times 10^{6}, p = 1.0, \\beta = 0.3, N_{\\mathrm{th}} = 11.5)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如 $[x_{t,1}, x_{t,2}, x_{t,3}, x_{t,4}]$，其中每个 $x_{t,i}$ 是测试用例 $i$ 的转捩位置，以米为单位，四舍五入到小数点后四位。如果某个测试用例在域内没有发生转捩，则相应的条目必须是 $-1.0000$。",
            "solution": "问题陈述经评估有效。\n\n### 第 1 步：提取已知条件\n\n- **扰动振幅模型**：扰动振幅 $A(x)$ 的变化率由线性常微分方程给出：$\\frac{dA}{dx} = s(x) A(x)$，其中 $s(x)$ 是局部空间增长率。\n- **累积增长因子**：$N(x) = \\ln\\left(\\frac{A(x)}{A(x_0)}\\right) = \\int_{x_0}^{x} s(\\xi) \\, d\\xi$。\n- **转捩判据**：转捩发生在 $N(x_t)$ 达到阈值 $N_{\\mathrm{th}}$ 的最小流向位置 $x_t$。\n- **无转捩条件**：如果 $N(x)$ 在计算域 $[x_0, x_{\\mathrm{end}}]$ 内始终未达到 $N_{\\mathrm{th}}$，则转捩位置报告为 $-1.0$。\n- **外部速度模型**：$U_e(x) = U_\\infty \\left(\\frac{x}{x_0}\\right)^m$，适用于 $x \\ge x_0$。\n- **局部雷诺数**：$Re_x(x) = \\dfrac{U_e(x) \\, x}{\\nu}$。\n- **空间放大率模型**：对于 $Re_x(x)  Re_{\\mathrm{crit}}$，$s(x) = 0$。对于 $Re_x(x) \\ge Re_{\\mathrm{crit}}$，\n$$\ns(x) = F_{\\mathrm{pg}} \\, c_0 \\, \\frac{U_e(x)}{\\nu} \\left( \\frac{Re_x(x) - Re_{\\mathrm{crit}}}{Re_{\\mathrm{ref}}} \\right)^{p} \\exp\\!\\left( -\\beta \\, \\frac{Re_x(x)}{Re_{\\mathrm{ref}}} \\right)\n$$\n- **压力梯度因子**：$F_{\\mathrm{pg}} = 1 - r \\, m$，其中 $r = 1.5$ 为固定值。\n- **计算方法**：\n    - 在 $x \\in [x_0, x_{\\mathrm{end}}]$ 的均匀网格上进行数值积分。\n    - 使用线性插值找到交点位置 $x_t$。\n- **测试用例**：为四个测试场景提供了参数 $(U_\\infty, \\nu, x_0, x_{\\mathrm{end}}, m, c_0, Re_{\\mathrm{crit}}, Re_{\\mathrm{ref}}, p, \\beta, N_{\\mathrm{th}})$。\n    1.  $(30.0, 1.5 \\times 10^{-5}, 0.05, 1.5, 0.0, 5.0 \\times 10^{-6}, 3.5 \\times 10^{5}, 1.0 \\times 10^{6}, 1.0, 0.3, 9.0)$\n    2.  $(15.0, 1.5 \\times 10^{-5}, 0.05, 1.5, 0.0, 5.0 \\times 10^{-6}, 3.5 \\times 10^{5}, 1.0 \\times 10^{6}, 1.0, 0.3, 9.0)$\n    3.  $(20.0, 1.5 \\times 10^{-5}, 0.05, 1.5, -0.25, 5.0 \\times 10^{-6}, 3.5 \\times 10^{5}, 1.0 \\times 10^{6}, 1.0, 0.3, 9.0)$\n    4.  $(30.0, 1.5 \\times 10^{-5}, 0.05, 1.5, 0.0, 5.0 \\times 10^{-6}, 3.5 \\times 10^{5}, 1.0 \\times 10^{6}, 1.0, 0.3, 11.5)$\n\n### 第 2 步：使用提取的已知条件进行验证\n\n根据验证标准对问题进行评估：\n- **科学依据**：该问题基于流体动力学的既定原理，特别是边界层稳定性和转捩。$e^N$ 方法是一种标准的、尽管是半经验的工程工具，用于转捩预测。速度、雷诺数和扰动增长率包络的模型是简化的，但在该领域是具有物理代表性的模型。量纲一致性是合理的：$s(x)$ 的单位是 $m^{-1}$，因此其积分 $N(x)$ 是无量纲的。\n- **适定性**：该问题是适定的。它要求解方程 $N(x) - N_{\\mathrm{th}} = 0$ 的根。由于增长率 $s(x)$ 是非负的，累积增长函数 $N(x)$ 是单调不减的。这确保了如果存在解，该解是唯一的（因为我们寻求的是最小的 $x_t$）。问题提供了明确的数值求解步骤，并规定了在给定域内无解时的输出。\n- **客观性**：问题以精确、客观和定量的方式陈述。没有主观因素。\n- **完整性与一致性**：问题是自包含的。所有必要的参数、方程、边界条件（域 $[x_0, x_{\\mathrm{end}}]$）和数值方法都已指定。测试用例提供了求解所需的完整数据集。没有内部矛盾。\n- **可行性**：物理参数和范围对于航空和机械工程应用是现实的。计算任务是可行且明确定义的。\n\n### 第 3 步：结论与行动\n\n该问题是**有效**的。将根据提供的模型和计算指令制定解决方案。\n\n### 解答\n\n目标是找到平板上的转捩位置 $x_t$，该点定义为边界层扰动的累积增长因子 $N(x)$ 首次达到指定阈值 $N_{\\mathrm{th}}$ 的点。累积增长是通过对一个模型化的空间放大率 $s(x)$ 从起始位置 $x_0$ 进行积分来计算的。\n\n求解每个测试用例的 $x_t$ 的算法步骤如下：\n\n1.  **离散化计算域**：将空间域 $[x_0, x_{\\mathrm{end}}]$ 离散化为由点 $\\{x_i\\}_{i=0}^M$ 组成的精细均匀网格，其中 $x_i = x_0 + i \\cdot \\Delta x$ 且 $\\Delta x = (x_{\\mathrm{end}} - x_0)/M$。选择足够大的点数 $M+1$ 以确保数值积分的准确性。\n\n2.  **计算局部放大率**：对于网格上的每个点 $x_i$，计算局部放大率 $s(x_i)$。这涉及基于所提供模型的一系列计算：\n    a.  计算外部速度 $U_e(x_i) = U_\\infty \\left(\\frac{x_i}{x_0}\\right)^m$。\n    b.  计算局部雷诺数 $Re_x(x_i) = \\frac{U_e(x_i) \\, x_i}{\\nu}$。\n    c.  评估放大率 $s(x_i)$。如果 $Re_x(x_i)$ 低于临界雷诺数 $Re_{\\mathrm{crit}}$，则流动是稳定的，且 $s(x_i) = 0$。否则，使用给定的包络公式计算 $s(x_i)$：\n        $$\n        s(x_i) = (1 - r \\, m) \\, c_0 \\, \\frac{U_e(x_i)}{\\nu} \\left( \\frac{Re_x(x_i) - Re_{\\mathrm{crit}}}{Re_{\\mathrm{ref}}} \\right)^{p} \\exp\\!\\left( -\\beta \\, \\frac{Re_x(x_i)}{Re_{\\mathrm{ref}}} \\right)\n        $$\n\n3.  **计算累积增长因子**：累积增长因子 $N(x)$ 是放大率的积分，$N(x) = \\int_{x_0}^{x} s(\\xi) \\, d\\xi$。该积分在网格上进行数值计算。我们使用梯形法则，它高效且非常适合精细网格。每个网格点 $x_i$ 处的 $N(x_i)$ 值通过累加由 $s(x)$ 函数形成的梯形面积得到：\n    $$\n    N(x_i) \\approx \\sum_{j=1}^{i} \\frac{s(x_{j-1}) + s(x_j)}{2} \\Delta x\n    $$\n    这可以通过使用累积梯形积分函数高效实现，从而得到一个值数组 $\\{N(x_i)\\}_{i=0}^M$，其中 $N(x_0) = 0$。\n\n4.  **确定转捩位置**：我们在数组 $\\{N(x_i)\\}$ 中搜索第一个满足 $N(x_i) \\ge N_{\\mathrm{th}}$ 的索引 $i$。\n    a.  如果在 $i=M$ 之前都未找到这样的索引，则意味着 $N(x_{\\mathrm{end}})  N_{\\mathrm{th}}$，并且在计算域内不发生转捩。在这种情况下，结果报告为 $-1.0$。\n    b.  如果找到这样的索引 $i$，则转捩位置 $x_t$ 位于区间 $[x_{i-1}, x_i]$ 内。为了找到其精确值，我们执行线性插值。假设一条直线连接点 $(x_{i-1}, N(x_{i-1}))$ 和 $(x_i, N(x_i))$，我们找到对应于 $N(x_t) = N_{\\mathrm{th}}$ 的值 $x_t$：\n        $$\n        x_t = x_{i-1} + (x_i - x_{i-1}) \\frac{N_{\\mathrm{th}} - N(x_{i-1})}{N(x_i) - N(x_{i-1})}\n        $$\n\n5.  **最终确定输出**：计算出的转捩位置 $x_t$ 四舍五入到小数点后四位。如果未发生转捩，则根据问题规范将该值报告为 $-1.0000$。对所有四个提供的测试用例重复此过程。\n\n该实现将使用 `numpy` 库进行高效的向量化计算，并使用 `scipy.integrate.cumulative_trapezoid` 进行精确的数值积分。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import cumulative_trapezoid\n\ndef solve():\n    \"\"\"\n    Main function to solve the boundary layer transition problem for all test cases.\n    \"\"\"\n\n    # Parameter r is fixed for all cases.\n    r = 1.5\n\n    # Test cases: (U_inf, nu, x0, x_end, m, c0, Re_crit, Re_ref, p, beta, N_th)\n    test_cases = [\n        (30.0, 1.5e-5, 0.05, 1.5, 0.0, 5.0e-6, 3.5e5, 1.0e6, 1.0, 0.3, 9.0),\n        (15.0, 1.5e-5, 0.05, 1.5, 0.0, 5.0e-6, 3.5e5, 1.0e6, 1.0, 0.3, 9.0),\n        (20.0, 1.5e-5, 0.05, 1.5, -0.25, 5.0e-6, 3.5e5, 1.0e6, 1.0, 0.3, 9.0),\n        (30.0, 1.5e-5, 0.05, 1.5, 0.0, 5.0e-6, 3.5e5, 1.0e6, 1.0, 0.3, 11.5),\n    ]\n\n    def find_transition_location(params):\n        \"\"\"\n        Calculates the transition location for a single set of parameters.\n        \"\"\"\n        U_inf, nu, x0, x_end, m, c0, Re_crit, Re_ref, p, beta, N_th = params\n        \n        # 1. Discretize the domain\n        num_points = 20001  # Sufficiently large number for accuracy\n        x_grid = np.linspace(x0, x_end, num_points)\n\n        # 2. Calculate the local amplification rate s(x)\n        \n        # 2a. External velocity U_e(x)\n        # Handle the case x0=0 to avoid division by zero, although not needed for these test cases.\n        if x0 == 0:\n            # For Falkner-Skan, x=0 is a singularity if m is not 0 or 1.\n            # Assume Ue=U_inf if x0=0 (or handle as per specific model extension).\n            # This branch is not taken for the given problem.\n            Ue_grid = np.full_like(x_grid, U_inf)\n        else:\n            Ue_grid = U_inf * (x_grid / x0)**m\n\n        # 2b. Local Reynolds number Re_x(x)\n        Rex_grid = Ue_grid * x_grid / nu\n\n        # 2c. Amplification rate s(x)\n        s_grid = np.zeros_like(x_grid)\n        \n        # Create a mask for points where instability can occur\n        mask = Rex_grid >= Re_crit\n        \n        # Calculate s(x) only for the unstable region\n        if np.any(mask):\n            F_pg = 1.0 - r * m\n            \n            # Select values for the unstable region\n            Ue_masked = Ue_grid[mask]\n            Rex_masked = Rex_grid[mask]\n            \n            term1 = F_pg * c0 * Ue_masked / nu\n            term2 = ((Rex_masked - Re_crit) / Re_ref)**p\n            term3 = np.exp(-beta * Rex_masked / Re_ref)\n            \n            s_grid[mask] = term1 * term2 * term3\n\n        # 3. Compute the cumulative growth factor N(x)\n        # Use scipy's cumulative_trapezoid for accurate integration\n        N_grid = cumulative_trapezoid(s_grid, x_grid, initial=0)\n\n        # 4. Determine the transition location\n        # Find indices where N surpasses the threshold N_th\n        crossing_indices = np.where(N_grid >= N_th)[0]\n\n        if crossing_indices.size == 0:\n            # Transition does not occur within the domain\n            return -1.0\n        else:\n            # First index where N >= N_th\n            idx = crossing_indices[0]\n            \n            if idx == 0:\n                # This would mean N(x0) >= N_th, transition is at the start\n                return x0\n\n            # Use linear interpolation to find the precise crossing point\n            x_prev, x_curr = x_grid[idx - 1], x_grid[idx]\n            N_prev, N_curr = N_grid[idx - 1], N_grid[idx]\n            \n            # Avoid division by zero if N_curr == N_prev\n            if N_curr == N_prev:\n                 return x_prev\n\n            xt = x_prev + (x_curr - x_prev) * (N_th - N_prev) / (N_curr - N_prev)\n            return xt\n\n    results = []\n    for case in test_cases:\n        xt = find_transition_location(case)\n        # 5. Format output\n        if xt == -1.0:\n            # As per instruction: \"the corresponding entry must be -1.0000\"\n            results.append(\"-1.0000\")\n        else:\n            results.append(f\"{xt:.4f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}