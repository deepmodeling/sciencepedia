{
    "hands_on_practices": [
        {
            "introduction": "The stability of a numerical scheme forms a crucial link between the pre-processing stage of mesh generation and the solver configuration. This practice provides essential experience in analyzing how mesh characteristics, specifically the minimum cell size on a non-uniform grid, dictate the maximum permissible time step $\\Delta t$ for an explicit time-integration scheme. Mastering this calculation is fundamental to preventing catastrophic numerical instabilities and ensuring a valid simulation .",
            "id": "3983557",
            "problem": "A one-dimensional transient heat diffusion problem is to be simulated using the explicit Forward Euler time integration with second-order centered spatial differencing. The physical domain is a rod of length $L = 0.36$ $\\mathrm{m}$ with constant thermal diffusivity $\\alpha = 1.4 \\times 10^{-5}$ $\\mathrm{m^2/s}$. As part of pre-processing, a nonuniform mesh is generated by the stretching map $x_i = L \\left(\\frac{i}{N}\\right)^2$ for $i = 0, 1, \\dots, N$, with $N = 12$. The solver uses a single global uniform time step $\\Delta t$ for all cells and enforces stability by constraining $\\Delta t$ using the smallest spatial step $h$ in the mesh as the characteristic spacing. The post-processing will compute the dimensionless Fourier number at the most restrictive cell to verify proximity to the stability limit.\n\nStarting from the conservation of energy and Fourierâ€™s law leading to the one-dimensional heat equation, derive the linear stability constraint applicable to the explicit scheme described, then compute the largest stable uniform time step $\\Delta t$ permitted by the mesh and material properties. Use the smallest neighbor spacing $h$ found from the provided mapping to set the constraint. Round your final numerical answer to four significant figures and express it in seconds.",
            "solution": "The problem is well-posed and scientifically grounded. All necessary data are provided and are consistent.\n\nThe one-dimensional transient heat diffusion equation is given by:\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2}\n$$\nwhere $T$ is temperature, $t$ is time, $x$ is the spatial coordinate, and $\\alpha$ is the thermal diffusivity.\n\nThe problem specifies a numerical solution using the explicit Forward Euler method for time integration and a second-order centered difference for spatial discretization. Let $T_i^n$ represent the temperature at spatial node $i$ and time step $n$. The forward difference in time is:\n$$\n\\frac{\\partial T}{\\partial t} \\bigg|_i^n \\approx \\frac{T_i^{n+1} - T_i^n}{\\Delta t}\n$$\nThe centered difference in space for a uniform mesh with spacing $h$ is:\n$$\n\\frac{\\partial^2 T}{\\partial x^2} \\bigg|_i^n \\approx \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{h^2}\n$$\nSubstituting these into the heat equation gives the Forward-Time Centered-Space (FTCS) discretization:\n$$\n\\frac{T_i^{n+1} - T_i^n}{\\Delta t} = \\alpha \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{h^2}\n$$\nRearranging for the future temperature $T_i^{n+1}$ yields the explicit update equation:\n$$\nT_i^{n+1} = T_i^n + \\frac{\\alpha \\Delta t}{h^2} (T_{i+1}^n - 2T_i^n + T_{i-1}^n)\n$$\nThe dimensionless group $Fo = \\frac{\\alpha \\Delta t}{h^2}$ is the mesh Fourier number. A von Neumann stability analysis of this scheme on a uniform grid shows that it is stable if and only if the Fourier number is bounded:\n$$\nFo \\le \\frac{1}{2} \\quad \\implies \\quad \\frac{\\alpha \\Delta t}{h^2} \\le \\frac{1}{2}\n$$\nThis leads to the stability constraint on the time step:\n$$\n\\Delta t \\le \\frac{h^2}{2\\alpha}\n$$\nThe problem specifies a non-uniform mesh, for which the stability analysis is more complex. However, it explicitly directs that the stability constraint be based on the smallest spatial step size $h$ in the mesh. Let this minimum spacing be $h_{min}$. The condition for the largest stable uniform time step $\\Delta t_{max}$ is therefore:\n$$\n\\Delta t_{max} = \\frac{h_{min}^2}{2\\alpha}\n$$\nTo find $h_{min}$, we must analyze the given mesh generation map:\n$$\nx_i = L \\left(\\frac{i}{N}\\right)^2 \\quad \\text{for } i = 0, 1, \\dots, N\n$$\nThe spacing $h_i$ of the $i$-th cell, defined as the distance between node $i$ and node $i-1$, is:\n$$\nh_i = x_i - x_{i-1} \\quad \\text{for } i = 1, \\dots, N\n$$\nSubstituting the mapping function:\n$$\nh_i = L \\left(\\frac{i}{N}\\right)^2 - L \\left(\\frac{i-1}{N}\\right)^2 = \\frac{L}{N^2} \\left[ i^2 - (i-1)^2 \\right]\n$$\nExpanding the term $(i-1)^2 = i^2 - 2i + 1$:\n$$\nh_i = \\frac{L}{N^2} [i^2 - (i^2 - 2i + 1)] = \\frac{L}{N^2} (2i - 1)\n$$\nTo find $h_{min}$, we observe that $h_i$ is a linearly increasing function of the index $i$. Therefore, the minimum spacing occurs at the smallest index, $i=1$:\n$$\nh_{min} = h_1 = \\frac{L}{N^2} (2(1) - 1) = \\frac{L}{N^2}\n$$\nNow we substitute the given numerical values: $L = 0.36 \\, \\mathrm{m}$ and $N=12$.\n$$\nh_{min} = \\frac{0.36}{12^2} = \\frac{0.36}{144} = 0.0025 \\, \\mathrm{m}\n$$\nWith the minimum spacing determined, we can now calculate the largest stable time step $\\Delta t_{max}$ using the given thermal diffusivity $\\alpha = 1.4 \\times 10^{-5} \\, \\mathrm{m^2/s}$.\n$$\n\\Delta t_{max} = \\frac{h_{min}^2}{2\\alpha} = \\frac{(0.0025)^2}{2 \\times (1.4 \\times 10^{-5})}\n$$\n$$\n\\Delta t_{max} = \\frac{6.25 \\times 10^{-6}}{2.8 \\times 10^{-5}} = \\frac{6.25}{28} \\approx 0.22321428... \\, \\mathrm{s}\n$$\nThe problem requires the final answer to be rounded to four significant figures.\n$$\n\\Delta t_{max} \\approx 0.2232 \\, \\mathrm{s}\n$$\nThis value represents the largest uniform time step that can be used by the solver while guaranteeing numerical stability for the entire domain, based on the conservative constraint imposed by the smallest cell in the mesh. The Fourier number for this most restrictive cell will be exactly at the limit of $0.5$.",
            "answer": "$$\n\\boxed{0.2232}\n$$"
        },
        {
            "introduction": "A critical part of post-processing is not just visualizing results, but also rigorously quantifying their accuracy. This exercise introduces the Grid Convergence Index (GCI), a standardized and widely accepted method in computational engineering for estimating the discretization error of a simulation. By working through this calculation, you will learn how to establish confidence intervals for your computed results, making your simulations more credible and reliable .",
            "id": "3983586",
            "problem": "A heated laminar flow through a straight channel of length $L$ and hydraulic diameter $D_{h}$ is simulated using Computational Fluid Dynamics (CFD). The material properties are constant, and the wall boundary condition imposes a uniform heat flux. The post-processing target is the area-averaged Nusselt number $Nu$, defined from first principles by $Nu = h D_{h} / k$, where $h$ is the convective heat transfer coefficient and $k$ is the thermal conductivity. The spatial discretization is uniform along the heated length, and three systematically refined grids are constructed in pre-processing with $N_{3} = 64$, $N_{2} = 128$, and $N_{1} = 256$ control volumes along the streamwise direction, so the grid spacing scales as $h_{i} \\propto L / N_{i}$ and the refinement ratios satisfy $r_{21} = h_{2}/h_{1} = 2$ and $r_{32} = h_{3}/h_{2} = 2$. The solver employs a second-order spatial scheme and a fully implicit time marching to steady state; iterative errors are negligible because residuals are reduced below $10^{-8}$ in nondimensional form for all grids. The post-processing yields the following area-averaged Nusselt numbers on the three grids: $Nu_{3} = 7.880$, $Nu_{2} = 7.974$, and $Nu_{1} = 8.017$. Assume the solution is in the asymptotic range of grid convergence and that the leading-order discretization error behaves as $E(h) \\approx C h^{p}$, where $C$ is a constant and $p$ is the observed order of accuracy. Using the three-grid methodology for the Grid Convergence Index (GCI) with a safety factor $F_{s} = 1.25$, construct the GCI on the finest grid and interpret the corresponding uncertainty band around $Nu_{1}$. Report only the upper limit of the uncertainty band for the Nusselt number based on the finest grid. Express your final answer as a dimensionless Nusselt number and round your answer to $4$ significant figures.",
            "solution": "The problem requires the calculation of the upper limit of the uncertainty band for the area-averaged Nusselt number, $Nu$, computed on the finest grid. The Grid Convergence Index (GCI) methodology, a standardized procedure for estimating discretization error in computational simulations, will be employed as specified.\n\nThe given data from the three systematically refined grids are:\n-   Fine grid (1): solution $\\phi_1 = Nu_1 = 8.017$.\n-   Medium grid (2): solution $\\phi_2 = Nu_2 = 7.974$.\n-   Coarse grid (3): solution $\\phi_3 = Nu_3 = 7.880$.\n\nThe grid refinement is uniform with a constant refinement ratio $r = 2$. The safety factor for the GCI calculation is specified as $F_s = 1.25$.\n\nThe GCI method assumes that the discretization error $E$ follows the relation $E(h) = \\phi(h) - \\phi_{exact} \\approx C h^p$, where $\\phi(h)$ is the solution on a grid with characteristic spacing $h$, $\\phi_{exact}$ is the exact solution, $C$ is a constant, and $p$ is the order of accuracy. For a three-grid study with a constant refinement ratio $r = h_2/h_1 = h_3/h_2$, the observed order of accuracy, $p$, can be calculated.\n\nFirst, we compute the differences between the solutions on consecutive grids:\n$$ \\epsilon_{21} = \\phi_2 - \\phi_1 = 7.974 - 8.017 = -0.043 $$\n$$ \\epsilon_{32} = \\phi_3 - \\phi_2 = 7.880 - 7.974 = -0.094 $$\n\nThe ratio of these differences, $R$, is used to find $p$:\n$$ R = \\frac{\\epsilon_{32}}{\\epsilon_{21}} = \\frac{\\phi_3 - \\phi_2}{\\phi_2 - \\phi_1} = \\frac{-0.094}{-0.043} = \\frac{94}{43} $$\nFor a solution in the asymptotic range, this ratio is approximately equal to $r^p$. Thus, we can solve for the observed order of accuracy $p$:\n$$ p = \\frac{\\ln(R)}{\\ln(r)} = \\frac{\\ln\\left(\\frac{94}{43}\\right)}{\\ln(2)} \\approx \\frac{\\ln(2.1860465)}{0.693147} \\approx \\frac{0.782071}{0.693147} \\approx 1.12828 $$\n\nThe uncertainty in the fine-grid solution, $U$, is calculated by multiplying the Richardson error estimate by the safety factor $F_s$. The error estimate for the fine-grid solution $\\phi_1$ is given by $E_a^{12} = \\frac{\\phi_1 - \\phi_2}{r^p - 1}$. The uncertainty $U$ is:\n$$ U = F_s \\left| E_a^{12} \\right| = F_s \\left| \\frac{\\phi_1 - \\phi_2}{r^p - 1} \\right| $$\nWe can substitute $r^p = R$ into this expression:\n$$ U = F_s \\frac{|\\phi_1 - \\phi_2|}{R - 1} $$\nSubstituting the numerical values:\n$$ U = 1.25 \\times \\frac{|8.017 - 7.974|}{\\frac{94}{43} - 1} = 1.25 \\times \\frac{0.043}{\\frac{94 - 43}{43}} = 1.25 \\times \\frac{0.043}{\\frac{51}{43}} $$\n$$ U = 1.25 \\times \\frac{0.043 \\times 43}{51} = 1.25 \\times \\frac{1.849}{51} \\approx 1.25 \\times 0.0362549 \\approx 0.0453186 $$\n\nThe problem requires the upper limit of the uncertainty band around the fine-grid Nusselt number, $Nu_1 = \\phi_1$. This uncertainty band is defined as $[\\phi_1 - U, \\phi_1 + U]$. The upper limit is therefore $\\phi_1 + U$.\n$$ \\text{Upper Limit} = \\phi_1 + U = 8.017 + 0.0453186 = 8.0623186 $$\n\nFinally, the problem requires the answer to be rounded to $4$ significant figures.\n$$ \\text{Upper Limit} \\approx 8.062 $$\nThis value represents the upper bound of the interval within which the exact Nusselt number is expected to lie, with a safety factor of $1.25$.",
            "answer": "$$\\boxed{8.062}$$"
        },
        {
            "introduction": "Choosing the right numerical solver often involves a complex trade-off between accuracy, stability, and computational cost. This comprehensive practice guides you through the entire simulation workflow to compare an explicit, multi-step method with a single-step implicit method for a transient heat conduction problem. By implementing both solvers and analyzing their performance using error and cost metrics, you will gain practical insight into making informed engineering decisions about which numerical strategy is optimal for a given problem .",
            "id": "3983540",
            "problem": "You will implement a computational experiment, following the standard simulation workflow of pre-processing, solver, and post-processing, to analyze the trade-off between one single large implicit time step and many smaller explicit time steps for transient one-dimensional heat conduction with homogeneous Dirichlet boundary conditions. The governing physics is defined by conservation of energy and Fourier's law of heat conduction, yielding the one-dimensional heat equation. The mathematical and physical base is as follows.\n\nFundamental base:\n- The one-dimensional transient heat conduction in a homogeneous medium is modeled by the heat equation\n$$\n\\frac{\\partial T(x,t)}{\\partial t} = \\alpha \\frac{\\partial^2 T(x,t)}{\\partial x^2},\n$$\nfor $0  x  L$, $t  0$, where $T$ is temperature in $\\mathrm{K}$, $\\alpha$ is thermal diffusivity in $\\mathrm{m^2/s}$, and $L$ is length in $\\mathrm{m}$.\n- Homogeneous Dirichlet boundary conditions: $T(0,t) = 0$ and $T(L,t) = 0$ for $t \\ge 0$.\n- Initial condition: $T(x,0) = T_0 \\sin\\left(\\frac{\\pi x}{L}\\right)$, where $T_0$ is the amplitude in $\\mathrm{K}$.\n- Analytical solution: \n$$\nT_{\\text{exact}}(x,t) = T_0 \\sin\\left(\\frac{\\pi x}{L}\\right) \\exp\\left(-\\alpha \\left(\\frac{\\pi}{L}\\right)^2 t\\right).\n$$\n\nPre-processing:\n- Discretize space using the Finite Difference Method (FDM) with $N_x$ interior nodes, uniform spacing $\\Delta x = \\frac{L}{N_x+1}$, at locations $x_i = i \\Delta x$ for $i = 1,2,\\dots,N_x$. The boundary nodes at $x = 0$ and $x = L$ are excluded from the unknown vector due to the homogeneous Dirichlet boundary conditions, but their values are accounted for in the discrete operators.\n- Initialize the discrete temperature vector using $T_i(0) = T_0 \\sin\\left(\\frac{\\pi x_i}{L}\\right)$ for $i = 1,\\dots,N_x$.\n\nSolver:\n- Explicit method: forward Euler in time with central differences in space for the interior nodes,\n$$\nT_i^{n+1} = T_i^n + \\mathrm{Fo}_e\\left(T_{i+1}^n - 2 T_i^n + T_{i-1}^n\\right),\n$$\nwhere $\\mathrm{Fo}_e = \\frac{\\alpha \\Delta t_e}{\\Delta x^2}$, $\\Delta t_e$ is the explicit time step, and $n$ denotes the time level. The boundary conditions imply $T_0^n = 0$ and $T_{N_x+1}^n = 0$. The explicit scheme must respect the classical stability condition $\\mathrm{Fo}_e \\le \\frac{1}{2}$.\n- Implicit method: backward Euler in time with central differences in space, for a single large step of size $\\Delta t_i = T_{\\text{end}}$,\n$$\n\\left(\\mathbf{I} - \\mathrm{Fo}_i \\mathbf{L}\\right)\\mathbf{T}^{n+1} = \\mathbf{T}^{n},\n$$\nwhere $\\mathrm{Fo}_i = \\frac{\\alpha \\Delta t_i}{\\Delta x^2}$, $\\mathbf{I}$ is the identity matrix, and $\\mathbf{L}$ is the standard tridiagonal discrete Laplacian with stencil coefficients $\\{-1,2,-1\\}$ applied to interior nodes. The matrix has main diagonal entries $1 + 2\\mathrm{Fo}_i$ and off-diagonal entries $-\\mathrm{Fo}_i$. Use the Thomas algorithm (tridiagonal Gaussian elimination) to solve the linear system exactly for the one implicit step.\n\nPost-processing:\n- Compute the analytical solution at the final time $t = T_{\\text{end}}$ at the interior grid points, $\\mathbf{T}_{\\text{exact}}(T_{\\text{end}})$, using the given formula.\n- Define the normalized discrete root-mean-square error for a vector $\\mathbf{T}$ at $t = T_{\\text{end}}$ relative to the exact solution as\n$$\ne = \\frac{1}{T_0}\\sqrt{\\frac{1}{N_x}\\sum_{i=1}^{N_x}\\left(T_i - T_{\\text{exact},i}\\right)^2},\n$$\nwhich is dimensionless.\n- Define a dimensionless computational cost model per interior node as follows. Let $c_e$ be the cost coefficient for one explicit step per interior node, and $c_i$ be the cost coefficient for one implicit step per interior node. Then\n$$\nC_{\\text{exp}} = N_{\\text{steps}} \\, c_e, \\quad C_{\\text{imp}} = 1 \\cdot c_i,\n$$\nwhere $N_{\\text{steps}} = T_{\\text{end}}/\\Delta t_e$ is the number of explicit steps, assumed to be an integer. Use $c_e = 6$ and $c_i = 10$ to reflect typical per-node operation counts for explicit updates versus one tridiagonal solve.\n- Define a dimensionless objective for decision-making that balances error and cost,\n$$\nJ = e + \\lambda C,\n$$\nwhere $\\lambda$ is a dimensionless weight. The lower $J$ across methods indicates the preferred method under that weight.\n\nYour task:\n- Implement the full workflow: pre-processing (grid and initialization), solver (explicit multiple steps and implicit single step), and post-processing (compute errors, costs, and decision).\n- For each test case, compute:\n    1. The error ratio $r_e = \\frac{e_{\\text{exp}}}{e_{\\text{imp}}}$ (dimensionless).\n    2. The cost ratio $r_c = \\frac{C_{\\text{exp}}}{C_{\\text{imp}}}$ (dimensionless).\n    3. The decision $d$, defined as $d = 1$ if $J_{\\text{exp}}  J_{\\text{imp}}$, and $d = 0$ otherwise (integer).\n\nPhysical units and consistency:\n- Use International System of Units (SI units): $L$ in $\\mathrm{m}$, $\\alpha$ in $\\mathrm{m^2/s}$, $T_{\\text{end}}$ and $\\Delta t_e$ in $\\mathrm{s}$, $T_0$ in $\\mathrm{K}$. The outputs $r_e$, $r_c$, and $d$ are dimensionless or unitless integers, so no physical units are required for the final outputs.\n\nTest suite:\n- Use $T_0 = 1$ for all cases.\n- For each case, ensure $\\mathrm{Fo}_e \\le \\frac{1}{2}$ and that $T_{\\text{end}}/\\Delta t_e$ is an integer.\n\nProvide the following four test cases:\n- Case $1$ (happy-path with moderate diffusion and fine grid):\n    - $L = 0.1$, $\\alpha = 10^{-5}$, $N_x = 50$, $T_{\\text{end}} = 10.0$, $\\Delta t_e = 0.02$, $\\lambda = 0.1$.\n- Case $2$ (small time horizon, coarser grid, slower explicit evolution):\n    - $L = 0.1$, $\\alpha = 10^{-4}$, $N_x = 20$, $T_{\\text{end}} = 1.0$, $\\Delta t_e = 0.001$, $\\lambda = 0.01$.\n- Case $3$ (near stability limit explicit steps on a long domain):\n    - $L = 1.0$, $\\alpha = 5\\times 10^{-3}$, $N_x = 200$, $T_{\\text{end}} = 0.099$, $\\Delta t_e = 0.0012375$, $\\lambda = 1.0$.\n- Case $4$ (edge case with very coarse grid and explicit near the stability limit):\n    - $L = 0.05$, $\\alpha = 10^{-4}$, $N_x = 5$, $T_{\\text{end}} = 4.087584$, $\\Delta t_e = 0.340632$, $\\lambda = 0.5$.\n\nFinal output format:\n- Your program should produce a single line of output containing, for each test case, a list with three entries $[r_e, r_c, d]$. Aggregate all four test case lists into a single top-level list. The exact output string must be a single line of the form\n$$\n\\big[ [r_{e,1}, r_{c,1}, d_1], [r_{e,2}, r_{c,2}, d_2], [r_{e,3}, r_{c,3}, d_3], [r_{e,4}, r_{c,4}, d_4] \\big],\n$$\nwith numeric values printed in standard decimal notation.",
            "solution": "The user-provided problem has been rigorously validated and is determined to be a valid, well-posed, and scientifically sound exercise in computational thermal engineering. All parameters, equations, and conditions are complete, consistent, and grounded in established principles of numerical analysis and heat transfer.\n\nThe problem requires a comparative analysis of two numerical schemes for solving the one-dimensional transient heat equation: a multi-step explicit forward Euler method and a single-step implicit backward Euler method. The comparison is based on a trade-off between numerical accuracy (error) and computational effort (cost), formalized through a dimensionless objective function. The entire process follows the standard simulation workflow: pre-processing, solving, and post-processing.\n\nThe governing partial differential equation (PDE) for this problem is the one-dimensional heat equation:\n$$\n\\frac{\\partial T(x,t)}{\\partial t} = \\alpha \\frac{\\partial^2 T(x,t)}{\\partial x^2}\n$$\nThis equation describes the evolution of temperature $T$ over time $t$ along a one-dimensional spatial domain of length $L$, where $\\alpha$ is the thermal diffusivity of the material. The system is subject to homogeneous Dirichlet boundary conditions, $T(0,t) = T(L,t) = 0$, and an initial sinusoidal temperature distribution, $T(x,0) = T_0 \\sin\\left(\\frac{\\pi x}{L}\\right)$. This specific initial condition corresponds to the first eigenmode of the spatial differential operator, leading to a convenient analytical solution for verification:\n$$\nT_{\\text{exact}}(x,t) = T_0 \\sin\\left(\\frac{\\pi x}{L}\\right) \\exp\\left(-\\alpha \\left(\\frac{\\pi}{L}\\right)^2 t\\right)\n$$\n\nThe core of the task is to discretize and solve this problem numerically.\n\n**1. Pre-processing: Discretization**\n\nFirst, the continuous spatial domain $x \\in [0, L]$ is discretized into a grid. We define $N_x$ interior nodes, with a uniform spacing of $\\Delta x = \\frac{L}{N_x+1}$. The spatial coordinates of the interior nodes are $x_i = i \\Delta x$ for $i=1, 2, \\dots, N_x$. The temperature at these nodes is denoted by $T_i(t)$.\n\nUsing a second-order central difference approximation for the spatial second derivative, we obtain a system of ordinary differential equations (ODEs):\n$$\n\\frac{d T_i(t)}{dt} = \\frac{\\alpha}{\\Delta x^2} (T_{i+1}(t) - 2T_i(t) + T_{i-1}(t))\n$$\nIn matrix form, this is $\\frac{d\\mathbf{T}}{dt} = \\frac{\\alpha}{\\Delta x^2}\\mathbf{A}\\mathbf{T}$, where $\\mathbf{T}$ is the vector of temperatures at the interior nodes and $\\mathbf{A}$ is a tridiagonal matrix representing the discrete Laplacian operator with stencil $(1, -2, 1)$, incorporating the zero-value boundary conditions.\n\nThe initial condition is discretized by sampling the continuous function at the grid points:\n$$\nT_i(0) = T_0 \\sin\\left(\\frac{\\pi x_i}{L}\\right)\n$$\n\n**2. Solver: Temporal Integration**\n\nThe system of ODEs is integrated in time from $t=0$ to $t=T_{\\text{end}}$ using two different methods.\n\n**2.1. Explicit Method: Forward Euler**\n\nThe time derivative is approximated using a forward difference. The scheme updates the temperature at time level $n+1$ using only known values from time level $n$:\n$$\n\\frac{T_i^{n+1} - T_i^n}{\\Delta t_e} = \\frac{\\alpha}{\\Delta x^2}(T_{i+1}^n - 2T_i^n + T_{i-1}^n)\n$$\nRearranging gives the explicit update rule:\n$$\nT_i^{n+1} = T_i^n + \\mathrm{Fo}_e (T_{i+1}^n - 2T_i^n + T_{i-1}^n)\n$$\nwhere $\\mathrm{Fo}_e = \\frac{\\alpha \\Delta t_e}{\\Delta x^2}$ is the explicit Courant-Friedrichs-Lewy (CFL) or Fourier number. This method is computationally simple but only conditionally stable, requiring $\\mathrm{Fo}_e \\le \\frac{1}{2}$ to prevent unbounded error growth. The simulation proceeds by applying this update rule for $N_{\\text{steps}} = T_{\\text{end}}/\\Delta t_e$ steps.\n\n**2.2. Implicit Method: Backward Euler**\n\nThe time derivative is again approximated by a first-order difference, but the spatial term is evaluated at the future time level $n+1$:\n$$\n\\frac{T_i^{n+1} - T_i^n}{\\Delta t_i} = \\frac{\\alpha}{\\Delta x^2}(T_{i+1}^{n+1} - 2T_i^{n+1} + T_{i-1}^{n+1})\n$$\nThis problem specifies a single large time step, $\\Delta t_i = T_{\\text{end}}$. Rearranging the terms to place all unknown quantities ($T^{n+1}$) on the left-hand side yields a system of linear equations for each interior node $i$:\n$$\n-\\mathrm{Fo}_i T_{i-1}^{n+1} + (1 + 2\\mathrm{Fo}_i) T_i^{n+1} - \\mathrm{Fo}_i T_{i+1}^{n+1} = T_i^n\n$$\nwhere $\\mathrm{Fo}_i = \\frac{\\alpha \\Delta t_i}{\\Delta x^2}$. In matrix form, this is $(\\mathbf{I} - \\mathrm{Fo}_i \\mathbf{A})\\mathbf{T}^{n+1} = \\mathbf{T}^{n}$. The resulting matrix $(\\mathbf{I} - \\mathrm{Fo}_i \\mathbf{A})$ is tridiagonal, symmetric, and diagonally dominant, which allows for a highly efficient and stable solution using the Thomas algorithm (a form of Gaussian elimination for tridiagonal systems). This method is unconditionally stable, permitting very large time steps, but at the cost of solving a linear system.\n\n**3. Post-processing: Analysis and Decision**\n\nAfter obtaining the numerical solutions at $t=T_{\\text{end}}$ from both methods, a quantitative comparison is performed.\n\nFirst, the analytical solution $T_{\\text{exact}}(x_i, T_{\\text{end}})$ is computed at each interior node.\n\nThe accuracy of each numerical solution ($\\mathbf{T}_{\\text{exp}}$ and $\\mathbf{T}_{\\text{imp}}$) is measured by the normalized discrete root-mean-square error:\n$$\ne = \\frac{1}{T_0}\\sqrt{\\frac{1}{N_x}\\sum_{i=1}^{N_x}\\left(T_i - T_{\\text{exact},i}\\right)^2}\n$$\n\nNext, the computational cost is estimated using the provided dimensionless model:\n- Explicit cost: $C_{\\text{exp}} = N_{\\text{steps}} \\cdot c_e = (T_{\\text{end}}/\\Delta t_e) \\cdot 6$\n- Implicit cost: $C_{\\text{imp}} = 1 \\cdot c_i = 10$\n\nFinally, a decision is made based on the objective function $J = e + \\lambda C$, which balances the error $e$ against the cost $C$ using a weighting factor $\\lambda$. The method with the lower value of $J$ is deemed superior for the given $\\lambda$. The decision variable $d$ is set to $1$ if $J_{\\text{exp}}  J_{\\text{imp}}$, and $0$ otherwise.\n\nThe ratios of the errors, $r_e = e_{\\text{exp}} / e_{\\text{imp}}$, and costs, $r_c = C_{\\text{exp}} / C_{\\text{imp}}$, are also computed to provide further insight into the relative performance of the two schemes. The implementation will systematically execute this entire workflow for each specified test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef thomas_algorithm(a, b, c, d):\n    \"\"\"\n    Solves a tridiagonal system of equations Ax = d using the Thomas algorithm.\n    a: sub-diagonal (length N-1)\n    b: main diagonal (length N)\n    c: super-diagonal (length N-1)\n    d: right-hand side (length N)\n    Returns the solution vector x.\n    \"\"\"\n    n = len(d)\n    c_prime = np.zeros(n)\n    d_prime = np.zeros(n)\n    x = np.zeros(n)\n\n    # Forward elimination\n    c_prime[0] = c[0] / b[0]\n    d_prime[0] = d[0] / b[0]\n    for i in range(1, n):\n        denominator = b[i] - a[i-1] * c_prime[i-1]\n        if i  n - 1:\n            c_prime[i] = c[i] / denominator\n        d_prime[i] = (d[i] - a[i-1] * d_prime[i-1]) / denominator\n\n    # Backward substitution\n    x[n-1] = d_prime[n-1]\n    for i in range(n-2, -1, -1):\n        x[i] = d_prime[i] - c_prime[i] * x[i+1]\n        \n    return x\n\ndef solve():\n    \"\"\"\n    Main function to run the computational experiment for all test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: L, alpha, Nx, T_end, dt_e, lambda_val\n        (0.1, 1e-5, 50, 10.0, 0.02, 0.1),\n        # Case 2\n        (0.1, 1e-4, 20, 1.0, 0.001, 0.01),\n        # Case 3\n        (1.0, 5e-3, 200, 0.099, 0.0012375, 1.0),\n        # Case 4\n        (0.05, 1e-4, 5, 4.087584, 0.340632, 0.5),\n    ]\n\n    T0 = 1.0\n    c_e = 6.0\n    c_i = 10.0\n    \n    all_results = []\n\n    for L, alpha, Nx, T_end, dt_e, lambda_val in test_cases:\n        # ===== 1. PRE-PROCESSING =====\n        dx = L / (Nx + 1)\n        x_nodes = np.linspace(dx, L - dx, Nx)\n        \n        # Initial condition\n        T_initial = T0 * np.sin(np.pi * x_nodes / L)\n\n        # ===== 2. SOLVER: EXPLICIT METHOD =====\n        Fo_e = alpha * dt_e / dx**2\n        \n        # As per problem validation, Fo = 0.5 is met for all cases.\n        # As per problem validation, T_end / dt_e is an integer.\n        N_steps = int(round(T_end / dt_e))\n        \n        T_current_exp = np.copy(T_initial)\n        \n        for _ in range(N_steps):\n            T_new_exp = np.copy(T_current_exp)\n            \n            # Vectorized update for interior nodes\n            T_new_exp[1:-1] = T_current_exp[1:-1] + Fo_e * (\n                T_current_exp[2:] - 2 * T_current_exp[1:-1] + T_current_exp[0:-2])\n            \n            # Update for boundary-adjacent nodes (T=0 at boundaries)\n            T_new_exp[0] = T_current_exp[0] + Fo_e * (T_current_exp[1] - 2 * T_current_exp[0] + 0)\n            if Nx > 1: # Avoid double counting for Nx=1\n                T_new_exp[-1] = T_current_exp[-1] + Fo_e * (0 - 2 * T_current_exp[-1] + T_current_exp[-2])\n            \n            T_current_exp = T_new_exp\n            \n        T_final_exp = T_current_exp\n\n        # ===== 3. SOLVER: IMPLICIT METHOD =====\n        dt_i = T_end\n        Fo_i = alpha * dt_i / dx**2\n        \n        # Set up the tridiagonal system Ax = d\n        # A has diagonals: a, b, c\n        # b_j = 1 + 2*Fo_i\n        # a_j = c_j = -Fo_i\n        # d = T_initial\n        \n        b = np.full(Nx, 1.0 + 2.0 * Fo_i)\n        a = np.full(Nx - 1, -Fo_i)\n        c = np.full(Nx - 1, -Fo_i)\n        d = T_initial\n        \n        T_final_imp = thomas_algorithm(a, b, c, d)\n\n        # ===== 4. POST-PROCESSING =====\n        # Analytical solution\n        decay_term = np.exp(-alpha * (np.pi/L)**2 * T_end)\n        T_exact = T0 * np.sin(np.pi * x_nodes / L) * decay_term\n\n        # Errors\n        e_exp = (1/T0) * np.sqrt(np.mean((T_final_exp - T_exact)**2))\n        e_imp = (1/T0) * np.sqrt(np.mean((T_final_imp - T_exact)**2))\n\n        # Costs\n        C_exp = N_steps * c_e\n        C_imp = 1.0 * c_i\n        \n        # Ratios\n        r_e = e_exp / e_imp if e_imp != 0 else float('inf')\n        r_c = C_exp / C_imp\n\n        # Objective functions and decision\n        J_exp = e_exp + lambda_val * C_exp\n        J_imp = e_imp + lambda_val * C_imp\n        \n        decision = 1 if J_exp  J_imp else 0\n\n        all_results.append([r_e, r_c, decision])\n\n    # Final print statement in the exact required format.\n    print(str(all_results).replace(\"'\", \"\"))\n\nsolve()\n```"
        }
    ]
}