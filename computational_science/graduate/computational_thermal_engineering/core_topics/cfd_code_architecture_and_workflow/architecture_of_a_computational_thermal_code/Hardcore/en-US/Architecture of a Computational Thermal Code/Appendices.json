{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of the Finite Volume Method (FVM) is the accurate representation of continuous physical phenomena within discrete control volumes. This practice focuses on a critical component of this process: the integration of a spatially varying volumetric source term, $Q(\\mathbf{x})$. By implementing an adaptive numerical quadrature scheme , you will learn how to translate a continuous source field into the discrete values required by the solver, a fundamental skill for building any physics-based simulation code.",
            "id": "3937455",
            "problem": "You are designing the source-term integration module in the architecture of a computational thermal code. The module must convert a continuous, spatially varying volumetric heat source density $Q(\\mathbf{x})$ with units $\\mathrm{W}/\\mathrm{m}^3$ into discrete source terms per control volume for use in a Finite Volume Method (FVM) solver. The discrete source in a control volume is defined as the volume integral of the continuous field over the control volume. Derive a mathematically consistent discrete representation starting from the energy conservation over a control volume and implement a quadrature-based integration over axis-aligned rectangular control volumes in two spatial dimensions with a uniform out-of-plane thickness.\n\nStart from the energy conservation statement over a control volume $\\Omega_P$ with boundary $\\partial \\Omega_P$ for transient heat conduction with volumetric generation: \n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t}\\int_{\\Omega_P} \\rho c T \\,\\mathrm{d}\\Omega \n= -\\int_{\\partial \\Omega_P} \\mathbf{q}\\cdot \\mathbf{n}\\,\\mathrm{d}\\Gamma + \\int_{\\Omega_P} Q(\\mathbf{x})\\,\\mathrm{d}\\Omega,\n$$\nwhere $\\rho$ is mass density, $c$ is specific heat capacity, $T$ is temperature, $\\mathbf{q}$ is conductive heat flux vector, and $Q(\\mathbf{x})$ is volumetric heat source density. The discrete source term for the control volume assembly is \n$$\nS_P \\equiv \\int_{\\Omega_P} Q(\\mathbf{x})\\,\\mathrm{d}\\Omega.\n$$\nFor an axis-aligned rectangular control volume with bounds $x\\in[x_0,x_1]$, $y\\in[y_0,y_1]$ and uniform out-of-plane thickness $h$ in $\\mathrm{m}$, define a reference square $\\hat{\\Omega}=[-1,1]\\times[-1,1]$ and a mapping \n$$\n\\phi(\\xi,\\eta)=\\left(x(\\xi),y(\\eta)\\right),\\quad x(\\xi)=\\frac{x_0+x_1}{2}+\\frac{x_1-x_0}{2}\\,\\xi,\\quad y(\\eta)=\\frac{y_0+y_1}{2}+\\frac{y_1-y_0}{2}\\,\\eta,\n$$\nwith Jacobian determinant $J=\\left|\\frac{\\partial(x,y)}{\\partial(\\xi,\\eta)}\\right|=\\frac{(x_1-x_0)(y_1-y_0)}{4}$. Using tensor-product Gauss–Legendre quadrature with $n$ points per direction on $\\hat{\\Omega}$, approximate \n$$\nS_P \\approx h \\sum_{i=1}^{n}\\sum_{j=1}^{n} w_i w_j\\, Q\\big(\\phi(\\xi_i,\\eta_j)\\big)\\, J,\n$$\nwhere $\\{\\xi_i,w_i\\}_{i=1}^{n}$ are Gauss–Legendre nodes and weights on $[-1,1]$ and similarly for $\\{\\eta_j,w_j\\}_{j=1}^{n}$. Implement an adaptive choice of $n$ that increases until the relative change in $S_P$ between successive $n$ is below a user-specified tolerance.\n\nYour program must construct a modular architecture with the following responsibilities:\n- A quadrature module that provides Gauss–Legendre nodes and weights on $[-1,1]$ and forms tensor-product points and weights.\n- A mapping from the reference square to physical rectangles and the corresponding constant Jacobian factor for axis-aligned rectangles.\n- An integration routine that, for a given $Q(x,y)$, bounds $[x_0,x_1]\\times[y_0,y_1]$, thickness $h$, and tolerance, returns $S_P$ in $\\mathrm{W}$.\n- An adaptive strategy that starts from $n=n_0$ and increases $n$ until the relative change criterion is satisfied or a maximum $n_{\\max}$ is reached.\n\nTest Suite. Use the following five scientifically consistent test cases to exercise different aspects of the architecture. For each case, compute and return $S_P$ expressed in $\\mathrm{W}$, rounded to six significant figures, using an adaptive tolerance of $10^{-10}$, an initial $n_0=2$, and a maximum $n_{\\max}=64$.\n\n- Case $1$ (constant source, happy path): $Q(x,y)=1.0\\times 10^{6}\\ \\mathrm{W}/\\mathrm{m}^3$, $x\\in[0,2]$, $y\\in[0,3]$, $h=0.1\\ \\mathrm{m}$.\n- Case $2$ (linear source, exact under low-order quadrature): $Q(x,y)=2.0\\times 10^{5}+3.0\\times 10^{5}\\,x+1.0\\times 10^{5}\\,y\\ \\mathrm{W}/\\mathrm{m}^3$, $x\\in[1,2]$, $y\\in[2,4]$, $h=0.5\\ \\mathrm{m}$.\n- Case $3$ (quadratic source, tests higher-order exactness): $Q(x,y)=1.0\\times 10^{5}\\,x^2+2.0\\times 10^{5}\\,y^2+5.0\\times 10^{5}\\,x\\,y\\ \\mathrm{W}/\\mathrm{m}^3$, $x\\in[0,1]$, $y\\in[0,1]$, $h=0.1\\ \\mathrm{m}$.\n- Case $4$ (trigonometric source, smooth but non-polynomial): $Q(x,y)=1.0\\times 10^{6}\\,\\sin(\\pi x)\\,\\cos(\\pi y)\\ \\mathrm{W}/\\mathrm{m}^3$, $x\\in[0,1]$, $y\\in[0,0.5]$, $h=0.2\\ \\mathrm{m}$, where $\\pi$ is the circle constant in radians.\n- Case $5$ (sharply peaked source, edge-case robustness): $Q(x,y)=1.0\\times 10^{6}\\,\\exp\\!\\left(-100\\,\\left[(x-0.5)^2+(y-0.25)^2\\right]\\right)\\ \\mathrm{W}/\\mathrm{m}^3$, $x\\in[0,1]$, $y\\in[0,0.5]$, $h=0.05\\ \\mathrm{m}$.\n\nFinal Output Format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each entry being the rounded value in $\\mathrm{W}$ for the corresponding case in the above order, for example, $[s_1,s_2,s_3,s_4,s_5]$.",
            "solution": "The problem statement has been critically validated and is found to be scientifically grounded, well-posed, and complete. It describes a standard and physically meaningful task in computational thermal engineering: the discretization of a continuous source term for use in a Finite Volume Method (FVM) solver. The provided mathematical framework, including the energy conservation equation, the change of variables to a reference element, and the use of tensor-product Gauss-Legendre quadrature, is correct and represents established practice in numerical methods for partial differential equations. The test cases are well-chosen to verify the implementation against problems with known analytical solutions and to test its robustness on more complex functions.\n\nThe objective is to compute the total heat generation rate, $S_P$, within a control volume, $\\Omega_P$. This quantity acts as a source term in the discretized energy balance equation. The starting point is the formal definition of $S_P$ as the volume integral of the volumetric heat source density, $Q(\\mathbf{x})$, over the control volume $\\Omega_P$:\n$$\nS_P \\equiv \\int_{\\Omega_P} Q(\\mathbf{x})\\,\\mathrm{d}\\Omega\n$$\nThe problem specifies a two-dimensional domain with a uniform out-of-plane thickness, $h$. The control volume is an axis-aligned rectangle, $\\Omega_P = [x_0, x_1] \\times [y_0, y_1]$, extruded by a thickness $h$. The volume element is thus $\\mathrm{d}\\Omega = h \\, \\mathrm{d}A = h \\, \\mathrm{d}x \\, \\mathrm{d}y$. The integral becomes:\n$$\nS_P = h \\int_{y_0}^{y_1} \\int_{x_0}^{x_1} Q(x, y) \\, \\mathrm{d}x \\, \\mathrm{d}y\n$$\nTo facilitate a general and efficient numerical integration, the integral over the physical domain $[x_0, x_1] \\times [y_0, y_1]$ is transformed into an integral over a canonical reference square, $\\hat{\\Omega} = [-1, 1] \\times [-1, 1]$. This is achieved through a linear mapping, $\\phi(\\xi, \\eta)$, for each coordinate:\n$$\nx(\\xi) = \\frac{x_0+x_1}{2} + \\frac{x_1-x_0}{2}\\xi\n$$\n$$\ny(\\eta) = \\frac{y_0+y_1}{2} + \\frac{y_1-y_0}{2}\\eta\n$$\nThe differential area element transforms as $\\mathrm{d}x\\,\\mathrm{d}y = J\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta$, where $J$ is the determinant of the Jacobian of the mapping $\\phi$. For this affine mapping, the Jacobian matrix is diagonal:\n$$\n\\mathbf{J} = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix} = \\begin{pmatrix} \\frac{x_1-x_0}{2} & 0 \\\\ 0 & \\frac{y_1-y_0}{2} \\end{pmatrix}\n$$\nThe determinant is a constant value:\n$$\nJ = \\det(\\mathbf{J}) = \\frac{(x_1-x_0)(y_1-y_0)}{4}\n$$\nSubstituting this transformation into the integral for $S_P$ yields:\n$$\nS_P = h \\int_{-1}^{1} \\int_{-1}^{1} Q(x(\\xi), y(\\eta)) \\, J \\, \\mathrm{d}\\xi \\, \\mathrm{d}\\eta\n$$\nThis integral over the reference square is now in a standard form suitable for numerical quadrature. We employ a tensor-product Gauss-Legendre quadrature rule. For a one-dimensional integral on $[-1, 1]$, an $n$-point Gauss-Legendre rule approximates the integral as a weighted sum:\n$$\n\\int_{-1}^{1} f(z) \\, \\mathrm{d}z \\approx \\sum_{i=1}^{n} w_i f(z_i)\n$$\nwhere $\\{z_i\\}_{i=1}^n$ are the nodes (roots of the $n$-th degree Legendre polynomial) and $\\{w_i\\}_{i=1}^n$ are the corresponding weights. This rule is exact for polynomials of degree up to $2n-1$.\n\nFor our two-dimensional integral, we apply this rule along each dimension, forming a tensor product:\n$$\nS_P \\approx h \\, J \\sum_{j=1}^{n} w_j \\left( \\sum_{i=1}^{n} w_i Q(x(\\xi_i), y(\\eta_j)) \\right) = h \\, J \\sum_{i=1}^{n} \\sum_{j=1}^{n} w_i w_j Q(\\phi(\\xi_i, \\eta_j))\n$$\nwhere $\\{\\xi_i, w_i\\}$ and $\\{\\eta_j, w_j\\}$ are the same set of $n$ Gauss-Legendre nodes and weights.\n\nTo ensure accuracy, an adaptive strategy is implemented. The number of quadrature points, $n$, is systematically increased until the computed value of $S_P$ converges. Let $S_P^{(n)}$ be the value of the integral computed using an $n \\times n$ grid of points. Starting with an initial order $n=n_0$, we compute $S_P^{(n_0)}$. We then generate a sequence of increasing orders, for instance by doubling, $n_k = 2n_{k-1}$. At each step $k > 0$, we compute $S_P^{(n_k)}$ and evaluate the relative change:\n$$\n\\epsilon_{\\text{rel}} = \\left| \\frac{S_P^{(n_k)} - S_P^{(n_{k-1})}}{S_P^{(n_k)}} \\right|\n$$\nThe process terminates when $\\epsilon_{\\text{rel}}$ falls below a specified tolerance, or when $n_k$ exceeds a maximum allowed value, $n_{\\max}$. This ensures that a sufficiently accurate result is obtained without using more computational effort than necessary. For integrands that are polynomials of low degree, the quadrature rule is exact, and convergence will be immediate. For more complex, non-polynomial functions, the order $n$ will increase until the approximation is satisfactory.\n\nThe software architecture is designed to be modular:\n1.  A quadrature module provides the fundamental Gauss-Legendre nodes and weights for a given order $n$.\n2.  The mapping from reference to physical coordinates and the constant Jacobian are handled separately.\n3.  A core integration routine takes these components and a function $Q(x,y)$ to compute the integral for a fixed $n$.\n4.  An adaptive-control routine orchestrates the process, managing the iteration on $n$ and checking for convergence.\n\nThis structure segregates concerns, promoting code reuse and clarity, which is crucial for the architecture of a large-scale computational code.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\nimport math\n\n# --- Module for Quadrature and Integration ---\n\ndef get_gauss_legendre(n):\n    \"\"\"\n    Provides n Gauss-Legendre nodes and weights on the interval [-1, 1].\n    Wraps scipy.special.roots_legendre for modularity.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Number of Gauss points must be at least 1.\")\n    nodes, weights = roots_legendre(n)\n    return nodes, weights\n\ndef _integrate_2d_fixed_n(q_func, x_bounds, y_bounds, n):\n    \"\"\"\n    Performs 2D integration over a rectangle for a fixed number of quadrature points n.\n    This is the core integration step.\n    \"\"\"\n    x0, x1 = x_bounds\n    y0, y1 = y_bounds\n    \n    # Jacobian of the transformation from reference to physical domain\n    jacobian = (x1 - x0) * (y1 - y0) / 4.0\n\n    # Get nodes and weights for the [-1, 1] reference interval\n    nodes, weights = get_gauss_legendre(n)\n\n    integral_sum = 0.0\n\n    # Tensor-product Gauss-Legendre summation\n    for i in range(n):\n        xi_i = nodes[i]\n        w_i = weights[i]\n        \n        # Map reference coordinate xi_i to physical coordinate x\n        x_val = 0.5 * (x0 + x1) + 0.5 * (x1 - x0) * xi_i\n\n        for j in range(n):\n            eta_j = nodes[j]\n            w_j = weights[j]\n\n            # Map reference coordinate eta_j to physical coordinate y\n            y_val = 0.5 * (y0 + y1) + 0.5 * (y1 - y0) * eta_j\n\n            q_val = q_func(x_val, y_val)\n            integral_sum += w_i * w_j * q_val\n\n    return integral_sum * jacobian\n\ndef calculate_source_term(q_func, x_bounds, y_bounds, h, tol, n0, n_max):\n    \"\"\"\n    Calculates the discrete source term S_P using an adaptive quadrature scheme.\n    \n    Args:\n        q_func (callable): The source function Q(x, y).\n        x_bounds (tuple): Physical bounds for x, (x0, x1).\n        y_bounds (tuple): Physical bounds for y, (y0, y1).\n        h (float): The uniform out-of-plane thickness.\n        tol (float): The relative tolerance for convergence.\n        n0 (int): The initial number of quadrature points per dimension.\n        n_max (int): The maximum number of quadrature points per dimension.\n        \n    Returns:\n        float: The calculated source term S_P in Watts.\n    \"\"\"\n    if n0 < 1:\n        raise ValueError(\"Initial number of points n0 must be at least 1.\")\n\n    n = n0\n    s_prev = _integrate_2d_fixed_n(q_func, x_bounds, y_bounds, n)\n\n    if n >= n_max:\n        return s_prev * h\n\n    while True:\n        s_curr_n = n * 2 if n > 0 else 1 # Double the number of points\n        if s_curr_n > n_max:\n            s_curr_n = n_max\n\n        s_curr = _integrate_2d_fixed_n(q_func, x_bounds, y_bounds, s_curr_n)\n\n        # Check for convergence\n        if s_curr != 0:\n            relative_change = abs((s_curr - s_prev) / s_curr)\n            if relative_change < tol:\n                return s_curr * h\n        elif s_prev == 0: # Both are zero, converged\n            return 0.0\n\n        if s_curr_n == n_max:\n            # Reached max iterations without converging to tolerance\n            return s_curr * h\n\n        n = s_curr_n\n        s_prev = s_curr\n\n# --- Utility for Final Formatting ---\ndef _round_to_sig_figs(value, sig_figs):\n    \"\"\"Rounds a number to a specified number of significant figures.\"\"\"\n    if value == 0:\n        return 0.0\n    \n    # Calculate the position of the first significant digit.\n    # math.log10(abs(value)) gives the power of 10.\n    # math.floor of that gives the order of magnitude.\n    # The number of decimal places for rounding is then derived from this.\n    decimal_places = sig_figs - 1 - math.floor(math.log10(abs(value)))\n    \n    return round(value, decimal_places)\n\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and compute the results.\n    \"\"\"\n    # --- Test Case Definitions ---\n\n    # Case 1: Constant source\n    def q1(x, y): return 1.0e6\n    case1_params = {'q_func': q1, 'x_bounds': (0, 2), 'y_bounds': (0, 3), 'h': 0.1}\n\n    # Case 2: Linear source\n    def q2(x, y): return 2.0e5 + 3.0e5 * x + 1.0e5 * y\n    case2_params = {'q_func': q2, 'x_bounds': (1, 2), 'y_bounds': (2, 4), 'h': 0.5}\n    \n    # Case 3: Quadratic source\n    def q3(x, y): return 1.0e5 * x**2 + 2.0e5 * y**2 + 5.0e5 * x * y\n    case3_params = {'q_func': q3, 'x_bounds': (0, 1), 'y_bounds': (0, 1), 'h': 0.1}\n    \n    # Case 4: Trigonometric source\n    def q4(x, y): return 1.0e6 * np.sin(np.pi * x) * np.cos(np.pi * y)\n    case4_params = {'q_func': q4, 'x_bounds': (0, 1), 'y_bounds': (0, 0.5), 'h': 0.2}\n\n    # Case 5: Sharply peaked source\n    def q5(x, y): return 1.0e6 * np.exp(-100 * ((x - 0.5)**2 + (y - 0.25)**2))\n    case5_params = {'q_func': q5, 'x_bounds': (0, 1), 'y_bounds': (0, 0.5), 'h': 0.05}\n    \n    test_cases = [\n        case1_params,\n        case2_params,\n        case3_params,\n        case4_params,\n        case5_params,\n    ]\n\n    # --- Execution Parameters ---\n    adaptive_tol = 1.0e-10\n    n0 = 2\n    n_max = 64\n    sig_figs = 6\n\n    results = []\n    for params in test_cases:\n        s_p = calculate_source_term(\n            params['q_func'],\n            params['x_bounds'],\n            params['y_bounds'],\n            params['h'],\n            adaptive_tol,\n            n0,\n            n_max\n        )\n        rounded_result = _round_to_sig_figs(s_p, sig_figs)\n        results.append(f\"{rounded_result:.{sig_figs-1}e}\" if sig_figs>1 and rounded_result!=0 else str(rounded_result))\n    \n    # Custom formatting to avoid scientific notation for some numbers if it's cleaner\n    formatted_results = []\n    for r_str in results:\n        val = float(r_str)\n        if 1e-4 <= abs(val) < 1e6:\n            # Check if it's an integer or can be represented cleanly\n            if val == int(val):\n                formatted_results.append(str(int(val)))\n            else:\n                # Format to avoid trailing zeros but maintain FP representation\n                formatted_results.append(f\"{val:g}\")\n        else:\n            # Use the scientific notation\n            if val == 0:\n                formatted_results.append(\"0.0\")\n            else:\n                exponent = math.floor(math.log10(abs(val)))\n                mantissa = val / (10**exponent)\n                formatted_mantissa = f\"{mantissa:.{sig_figs-1}f}\"\n                # Handle cases like 9.999999 -> 10.00000\n                if formatted_mantissa.startswith(\"10.\"):\n                    mantissa = 1.0\n                    exponent += 1\n                    formatted_mantissa = f\"{mantissa:.{sig_figs-1}f}\"\n                formatted_results.append(f\"{formatted_mantissa}e+{exponent}\" if exponent>=0 else f\"{formatted_mantissa}e{exponent}\")\n\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, formatted_results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Real-world thermal problems often involve the complex interplay of advection (transport by flow) and diffusion (transport by conduction), and the simulation's numerical stability and physical accuracy depend heavily on how the code handles these competing effects. This exercise explores the Péclet number, $Pe$, a dimensionless group that quantifies the ratio of advection to diffusion. Understanding the Péclet number is crucial as it serves as a local guide for the code's architectural logic, helping it to intelligently switch between different discretization schemes to maintain robustness and minimize error .",
            "id": "3937444",
            "problem": "You are designing the discretization module of a general-purpose computational thermal code that solves an advection–diffusion transport equation for temperature. The governing conservation law for sensible energy starts from Fourier’s law for diffusion and advection by a given velocity field. Consider the scalar transport equation for temperature $T(\\mathbf{x},t)$ with density $\\rho$, specific heat capacity $c_p$, thermal conductivity $k$, and velocity field $\\mathbf{u}(\\mathbf{x},t)$:\n$$\n\\rho c_p \\frac{\\partial T}{\\partial t} + \\rho c_p \\,\\mathbf{u}\\cdot\\nabla T = \\nabla\\cdot\\left(k \\nabla T\\right) + S,\n$$\nwhere $S$ is a volumetric source term. Let the thermal diffusivity be $\\alpha = k/(\\rho c_p)$. Assume that characteristic scales $U$, $L$, and $\\Theta$ exist for velocity magnitude, length, and temperature variation, respectively, and that the mesh is unstructured with characteristic element size $h_e$ and face-normal distance $\\Delta_f$.\n\nTask:\n- Starting from the governing equation and the definitions above, nondimensionalize the equation to identify the dimensionless group that measures the ratio of advection to diffusion, and express this group explicitly in terms of $U$, $L$, and $\\alpha$. Then, express a local face-based version in terms of $|\\mathbf{u}\\cdot\\mathbf{n}|$, $\\Delta_f$, and $\\alpha$. Provide physical interpretation of how the magnitude of this group implies advection- or diffusion-dominated transport.\n- Using this interpretation, reason about how a discretization module within a modular code architecture should use this dimensionless group to select between central, upwind, and stabilized high-resolution schemes. Your reasoning must explicitly address local versus global decisions, consistency and conservation, and handling of anisotropic diffusion.\n\nWhich of the following architectural designs for the discretization module correctly expresses and uses this dimensionless group to guide selection of stabilization or upwinding schemes? Select all that apply.\n\nA. The module computes a local face-based ratio $Pe_f = \\dfrac{|\\mathbf{u}\\cdot \\mathbf{n}|\\,\\Delta_f}{\\alpha}$ (equivalently $Pe_f = \\dfrac{F}{D}$ in a finite volume flux notation), and blends fluxes with a bounded high-resolution limiter: for small $|Pe_f|$ it recovers central differencing, and for large $|Pe_f|$ it approaches upwind, with smooth transition governed by a monotone function of $|Pe_f|$. For finite element formulations, it uses a Streamline Upwind Petrov–Galerkin (SUPG) stabilization parameter $\\tau \\sim \\dfrac{h_e}{\\|\\mathbf{u}\\|}\\,\\phi(Pe_e)$ with $\\phi(Pe)$ a standard shape such as $\\coth(Pe)-1/Pe$. The implementation encapsulates scheme kernels behind a strategy interface, allowing per-face or per-element selection based on $Pe$ while preserving conservation and consistency.\n\nB. The module computes a single domain-wide ratio using a global average $U$ and a domain diameter $L$ and switches all faces or elements to upwind if this global value exceeds a threshold; otherwise it uses central differencing everywhere. The choice does not vary in space or time and ignores mesh nonuniformity and material heterogeneity.\n\nC. For transient problems, the module bases the scheme selection entirely on the Courant number $Co = U\\,\\Delta t / \\Delta_f$, arguing that diffusion becomes negligible whenever advection is important. It therefore ignores any ratio involving $\\alpha$ and uses central differencing whenever $Co$ is small, independent of material properties.\n\nD. In media with anisotropic diffusion represented by a symmetric positive definite tensor $\\mathbf{K}$, the module defines direction-dependent ratios along local principal directions: $Pe_i = \\dfrac{|\\mathbf{u}\\cdot \\mathbf{e}_i|\\,h_i}{\\alpha_i}$, where $\\alpha_i$ are effective diffusivities along eigenvectors $\\mathbf{e}_i$ and $h_i$ are directional element length scales from a metric tensor. It applies streamline stabilization when the along-stream value is large while avoiding unnecessary crosswind artificial diffusion when the cross-stream values are order unity or smaller. The stabilization is residual-based and consistent, vanishing for the exact solution.\n\nE. To guarantee monotonicity, the module always uses first-order upwind for any nonzero value of the ratio at any face, and adds isotropic artificial diffusion proportional to $\\|\\mathbf{u}\\|\\,h_e$ that does not depend on material diffusivity or on the ratio’s magnitude, so that oscillations are eliminated in all regimes.\n\nAnswer choices reflect different architectural and numerical design philosophies. Choose all that are justified by the nondimensional analysis and preserve the desired numerical properties in a general-purpose code.",
            "solution": "Starting from the conservation law,\n$$\n\\rho c_p \\frac{\\partial T}{\\partial t} + \\rho c_p \\,\\mathbf{u}\\cdot\\nabla T = \\nabla\\cdot\\left(k \\nabla T\\right) + S,\n$$\ndefine thermal diffusivity $\\alpha = \\dfrac{k}{\\rho c_p}$. Introduce nondimensional variables $T^* = \\dfrac{T - T_{ref}}{\\Theta}$, $\\mathbf{x}^* = \\dfrac{\\mathbf{x}}{L}$, and $t^* = \\dfrac{t}{L/U}$. Using the chain rule, $\\nabla = \\dfrac{1}{L}\\nabla^*$ and $\\dfrac{\\partial}{\\partial t} = \\dfrac{U}{L}\\dfrac{\\partial}{\\partial t^*}$, and substituting $T = T_{ref} + \\Theta T^*$ into the governing equation (omitting $S$ for clarity in the ratio derivation), we obtain\n$$\n\\rho c_p \\left(\\frac{U}{L}\\Theta \\frac{\\partial T^*}{\\partial t^*} + \\Theta \\mathbf{u}\\cdot \\frac{1}{L}\\nabla^* T^*\\right) = k \\frac{1}{L^2} \\nabla^{*2} (\\Theta T^*).\n$$\nCanceling common factors and using $\\alpha = k/(\\rho c_p)$ gives\n$$\n\\frac{U}{L} \\frac{\\partial T^*}{\\partial t^*} + \\frac{\\mathbf{u}}{U}\\cdot \\nabla^* T^* = \\frac{\\alpha}{U L} \\nabla^{*2} T^*.\n$$\nMultiplying through by $L/U$ yields\n$$\n\\frac{\\partial T^*}{\\partial t^*} + \\left(\\frac{\\mathbf{u}}{U}\\right)\\cdot \\nabla^* T^* = \\frac{1}{Pe}\\,\\nabla^{*2} T^*,\n$$\nwhere the dimensionless group\n$$\nPe = \\frac{U L}{\\alpha}\n$$\nis the Péclet number, measuring the ratio of advection to diffusion transport rates. Physically, $Pe \\ll 1$ implies diffusion-dominated behavior, while $Pe \\gg 1$ implies advection-dominated behavior with steep internal and boundary layers.\n\nFor a discrete unstructured mesh, a natural local face-based form compares advective to diffusive flux magnitudes at a face $f$ with outward unit normal $\\mathbf{n}$ and centroid-to-centroid distance $\\Delta_f$. In a finite volume notation, the advective flux magnitude is $F_f = \\rho c_p |\\mathbf{u}\\cdot \\mathbf{n}| A_f$ and the diffusive conductance is $D_f = k A_f/\\Delta_f$, so their ratio simplifies to\n$$\nPe_f = \\frac{F_f}{D_f} = \\frac{\\rho c_p |\\mathbf{u}\\cdot \\mathbf{n}| A_f}{k A_f/\\Delta_f} = \\frac{|\\mathbf{u}\\cdot \\mathbf{n}|\\,\\Delta_f}{\\alpha}.\n$$\nAn elementwise form is similarly $Pe_e = \\dfrac{\\|\\mathbf{u}\\|\\,h_e}{\\alpha}$ with $h_e$ an appropriate element metric length. Constants of order unity in these definitions may vary across discretizations, but the physical interpretation remains: small $Pe$ indicates diffusion-dominated transport amenable to central differencing, while large $Pe$ indicates advection dominance that requires upwinding or stabilization to avoid nonphysical oscillations and to control numerical diffusion.\n\nImplications for discretization selection in a code architecture:\n- Local versus global: Because $\\mathbf{u}$, $\\alpha$, and mesh spacings vary in space and time, $Pe$ should be evaluated locally (per face or per element). A global threshold ignores heterogeneity and leads to suboptimal or unstable choices.\n- Consistency and conservation: Stabilization should be consistent (vanishing for the exact solution) and should preserve conservation in the discrete balance. Strategies include bounded high-resolution finite volume schemes with flux limiters and residual-based Petrov–Galerkin stabilizations in finite elements.\n- Anisotropy and directionality: With anisotropic diffusion, the relevant comparison is directional. Streamline stabilization should be applied along the flow direction when the along-stream $Pe$ is large, while avoiding unnecessary crosswind artificial diffusion when cross-stream diffusion remains effective.\n\nOption-by-option analysis:\n\nA. This option computes $Pe_f = \\dfrac{|\\mathbf{u}\\cdot \\mathbf{n}|\\,\\Delta_f}{\\alpha}$ locally and uses it to blend between central and upwind with a bounded limiter. This matches the face-based ratio derived from first principles and adapts per face. The mention of a Streamline Upwind Petrov–Galerkin (SUPG) stabilization parameter $\\tau \\sim \\dfrac{h_e}{\\|\\mathbf{u}\\|}\\,\\phi(Pe_e)$ with a shape like $\\phi(Pe) = \\coth(Pe)-1/Pe$ reflects standard residual-based consistent stabilization that depends on $Pe$. Encapsulating scheme kernels behind a strategy interface and selecting per face or per element preserves modularity and conservation. Verdict: Correct.\n\nB. A single global ratio based on domain-averaged $U$ and a single $L$ ignores local mesh spacing, local velocity, and material variation; it also prevents spatially adaptive selection that is critical when $Pe$ varies strongly. This is not justified by the local nondimensional analysis and is a poor architectural choice. Verdict: Incorrect.\n\nC. The Courant number $Co = U\\,\\Delta t / \\Delta_f$ controls explicit time-stepping stability and temporal accuracy, but it does not measure the ratio of advection to diffusion. Ignoring $\\alpha$ discards the diffusion physics and misguides spatial scheme selection. Even for transient problems, spatial stabilization should be based on $Pe$, not solely on $Co$. Verdict: Incorrect.\n\nD. With anisotropic diffusion tensor $\\mathbf{K}$, defining direction-dependent ratios $Pe_i = \\dfrac{|\\mathbf{u}\\cdot \\mathbf{e}_i|\\,h_i}{\\alpha_i}$ using local eigenvectors $\\mathbf{e}_i$ and directional length scales $h_i$ is consistent with first principles. Applying streamline stabilization when along-stream values are large, while restraining crosswind artificial diffusion when cross-stream values are order unity or smaller, is physically and numerically sound. Residual-based, consistent stabilization that vanishes for the exact solution is appropriate and preserves accuracy. Verdict: Correct.\n\nE. Always using first-order upwind for any nonzero value of the ratio and adding isotropic artificial diffusion independent of $\\alpha$ and of the ratio’s magnitude sacrifices accuracy in diffusion-dominated regions and violates consistency by introducing excessive, physics-independent dissipation. This design is not justified by the nondimensional analysis. Verdict: Incorrect.\n\nTherefore, the correct choices are A and D.",
            "answer": "$$\\boxed{AD}$$"
        },
        {
            "introduction": "A sophisticated code is useless if it is not correct, and the process of verification ensures that the software implementation accurately solves the intended mathematical equations. This practice introduces a powerful technique for code verification known as the Method of Manufactured Solutions (MMS). In this exercise , you will derive the exact source term required to make a chosen analytical function a solution to the governing partial differential equation, thereby creating a perfect test case for evaluating your code's accuracy.",
            "id": "3937495",
            "problem": "A computational thermal code solving transient conduction is organized into modules for geometry-discretization, field and material database, physics-operator assembly, boundary-condition management, and solver orchestration. The physics kernel advances the temperature field based on conservation of energy and Fourier’s law. Starting from the local conservation of energy and Fourier’s law, derive the volumetric source term that must be injected for verification under the Method of Manufactured Solutions (MMS).\n\nBegin from the following fundamental base:\n- Conservation of energy for a differential control volume: the rate of change of sensible energy equals the divergence of conductive heat flux plus volumetric heat generation.\n- Fourier’s law for isotropic conduction: the conductive heat flux is $-\\;k(\\mathbf{x})\\,\\nabla T(\\mathbf{x},t)$.\n\nConsider a three-dimensional domain with coordinates $\\mathbf{x} = (x,y,z)$, constant density $\\rho$ and constant specific heat capacity $c_p$, and a spatially varying but isotropic thermal conductivity $k(\\mathbf{x})$ defined by $k(x,y,z) = k_0\\,\\exp(\\eta x)\\,(1+\\zeta z^2)$, where $k_0 > 0$, $\\eta$ is any real constant, and $\\zeta \\ge 0$. For MMS, choose the manufactured analytic temperature field\n$$\nT(x,y,z,t) = \\exp(\\alpha t)\\,\\sin(\\beta x)\\,\\cos(\\gamma y)\\,\\bigl(1+z^2\\bigr),\n$$\nwhere $\\alpha$, $\\beta$, and $\\gamma$ are positive constants. The architecture’s boundary-condition module would set Dirichlet data by restricting $T(\\mathbf{x},t)$ to the boundary, and the physics-operator assembly must compute a source term consistent with this $T$ and $k$.\n\nUsing only the fundamental base above, derive a closed-form analytic expression for the volumetric heat source term $Q(x,y,z,t)$ that makes the manufactured $T$ satisfy the transient conduction equation. Express $Q$ in base International System of Units (SI) as watts per cubic meter. Do not perform any numerical evaluation or rounding. Provide the final $Q(x,y,z,t)$ as a single closed-form expression.",
            "solution": "The objective is to derive the volumetric heat source term, $Q(x,y,z,t)$, required to satisfy the transient heat conduction equation for a specified manufactured temperature field $T(x,y,z,t)$ and a spatially varying thermal conductivity $k(\\mathbf{x})$.\n\nThe governing equation for transient heat conduction is derived from the principle of conservation of energy. The rate of change of sensible energy in a differential control volume is given by $\\rho c_p \\frac{\\partial T}{\\partial t}$, where $\\rho$ is the density and $c_p$ is the specific heat capacity. This must be balanced by the net rate of heat conducted into the volume, which is given by the negative divergence of the heat flux, $-\\nabla \\cdot \\mathbf{q}$, plus any volumetric heat generation, $Q$.\nThe energy conservation equation is thus:\n$$ \\rho c_p \\frac{\\partial T}{\\partial t} = -\\nabla \\cdot \\mathbf{q} + Q $$\nFourier's law for an isotropic medium states that the heat flux $\\mathbf{q}$ is proportional to the negative temperature gradient:\n$$ \\mathbf{q} = -k(\\mathbf{x}) \\nabla T(\\mathbf{x}, t) $$\nSubstituting Fourier's law into the energy conservation equation gives the general transient heat conduction equation:\n$$ \\rho c_p \\frac{\\partial T}{\\partial t} = \\nabla \\cdot \\left( k(\\mathbf{x}) \\nabla T(\\mathbf{x}, t) \\right) + Q(x,y,z,t) $$\nTo find the source term $Q$ that is consistent with the manufactured solution, we rearrange this equation:\n$$ Q(x,y,z,t) = \\rho c_p \\frac{\\partial T}{\\partial t} - \\nabla \\cdot \\left( k \\nabla T \\right) $$\n\nThe problem provides the following functions and constants:\n-   Manufactured temperature field: $T(x,y,z,t) = \\exp(\\alpha t)\\,\\sin(\\beta x)\\,\\cos(\\gamma y)\\,\\bigl(1+z^2\\bigr)$\n-   Spatially varying thermal conductivity: $k(x,y,z) = k_0\\,\\exp(\\eta x)\\,(1+\\zeta z^2)$\n-   Constants: $\\rho$, $c_p$, $\\alpha$, $\\beta$, $\\gamma$, $k_0$, $\\eta$, $\\zeta$.\n\nWe will compute each term in the expression for $Q$ separately.\n\nFirst, we compute the time-derivative term, $\\rho c_p \\frac{\\partial T}{\\partial t}$:\n$$ \\frac{\\partial T}{\\partial t} = \\frac{\\partial}{\\partial t} \\left[ \\exp(\\alpha t)\\,\\sin(\\beta x)\\,\\cos(\\gamma y)\\,\\bigl(1+z^2\\bigr) \\right] = \\alpha \\exp(\\alpha t)\\,\\sin(\\beta x)\\,\\cos(\\gamma y)\\,\\bigl(1+z^2\\bigr) = \\alpha T $$\nTherefore, the first term for $Q$ is:\n$$ \\rho c_p \\frac{\\partial T}{\\partial t} = \\rho c_p \\alpha \\exp(\\alpha t)\\,\\sin(\\beta x)\\,\\cos(\\gamma y)\\,\\bigl(1+z^2\\bigr) $$\n\nNext, we compute the divergence term, $\\nabla \\cdot (k \\nabla T)$. We can expand this term using the vector calculus identity $\\nabla \\cdot (\\phi \\mathbf{F}) = (\\nabla \\phi) \\cdot \\mathbf{F} + \\phi (\\nabla \\cdot \\mathbf{F})$. Here, $\\phi = k$ and $\\mathbf{F} = \\nabla T$.\n$$ \\nabla \\cdot (k \\nabla T) = (\\nabla k) \\cdot (\\nabla T) + k \\nabla^2 T $$\nWe will compute the components $\\nabla T$, $\\nabla^2 T$, and $\\nabla k$.\n\nThe gradient of the temperature, $\\nabla T = \\left( \\frac{\\partial T}{\\partial x}, \\frac{\\partial T}{\\partial y}, \\frac{\\partial T}{\\partial z} \\right)$:\n$$ \\frac{\\partial T}{\\partial x} = \\beta \\exp(\\alpha t)\\,\\cos(\\beta x)\\,\\cos(\\gamma y)\\,\\bigl(1+z^2\\bigr) $$\n$$ \\frac{\\partial T}{\\partial y} = -\\gamma \\exp(\\alpha t)\\,\\sin(\\beta x)\\,\\sin(\\gamma y)\\,\\bigl(1+z^2\\bigr) $$\n$$ \\frac{\\partial T}{\\partial z} = 2z \\exp(\\alpha t)\\,\\sin(\\beta x)\\,\\cos(\\gamma y) $$\n\nThe Laplacian of the temperature, $\\nabla^2 T = \\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2} + \\frac{\\partial^2 T}{\\partial z^2}$:\n$$ \\frac{\\partial^2 T}{\\partial x^2} = -\\beta^2 \\exp(\\alpha t)\\,\\sin(\\beta x)\\,\\cos(\\gamma y)\\,\\bigl(1+z^2\\bigr) = -\\beta^2 T $$\n$$ \\frac{\\partial^2 T}{\\partial y^2} = -\\gamma^2 \\exp(\\alpha t)\\,\\sin(\\beta x)\\,\\cos(\\gamma y)\\,\\bigl(1+z^2\\bigr) = -\\gamma^2 T $$\n$$ \\frac{\\partial^2 T}{\\partial z^2} = \\frac{\\partial}{\\partial z} \\left( 2z \\exp(\\alpha t)\\,\\sin(\\beta x)\\,\\cos(\\gamma y) \\right) = 2 \\exp(\\alpha t)\\,\\sin(\\beta x)\\,\\cos(\\gamma y) = \\frac{2}{1+z^2}T $$\nCombining these gives:\n$$ \\nabla^2 T = T \\left(-\\beta^2 - \\gamma^2 + \\frac{2}{1+z^2}\\right) $$\nSo, the term $k \\nabla^2 T$ is:\n$$ k \\nabla^2 T = k_0 \\exp(\\eta x) (1+\\zeta z^2) \\left[ \\exp(\\alpha t)\\sin(\\beta x)\\cos(\\gamma y)(1+z^2) \\right] \\left(-\\beta^2 - \\gamma^2 + \\frac{2}{1+z^2}\\right) $$\n$$ k \\nabla^2 T = k_0 \\exp(\\alpha t) \\exp(\\eta x) \\sin(\\beta x) \\cos(\\gamma y) \\left[ -(\\beta^2+\\gamma^2)(1+z^2)(1+\\zeta z^2) + 2(1+\\zeta z^2) \\right] $$\n\nThe gradient of the thermal conductivity, $\\nabla k = \\left( \\frac{\\partial k}{\\partial x}, \\frac{\\partial k}{\\partial y}, \\frac{\\partial k}{\\partial z} \\right)$:\n$$ \\frac{\\partial k}{\\partial x} = \\eta \\, k_0 \\exp(\\eta x) (1+\\zeta z^2) = \\eta k $$\n$$ \\frac{\\partial k}{\\partial y} = 0 $$\n$$ \\frac{\\partial k}{\\partial z} = k_0 \\exp(\\eta x) (2\\zeta z) = k \\frac{2\\zeta z}{1+\\zeta z^2} $$\n\nNow, we compute the dot product $(\\nabla k) \\cdot (\\nabla T)$:\n$$ (\\nabla k) \\cdot (\\nabla T) = \\frac{\\partial k}{\\partial x}\\frac{\\partial T}{\\partial x} + \\frac{\\partial k}{\\partial y}\\frac{\\partial T}{\\partial y} + \\frac{\\partial k}{\\partial z}\\frac{\\partial T}{\\partial z} $$\n$$ (\\nabla k) \\cdot (\\nabla T) = (\\eta k)(\\beta \\exp(\\alpha t)\\cos(\\beta x)\\cos(\\gamma y)(1+z^2)) + (0) + \\left(k \\frac{2\\zeta z}{1+\\zeta z^2}\\right)(2z \\exp(\\alpha t)\\sin(\\beta x)\\cos(\\gamma y)) $$\nSubstituting $k = k_0 \\exp(\\eta x)(1+\\zeta z^2)$:\n$$ (\\nabla k) \\cdot (\\nabla T) = \\eta \\beta k_0 \\exp(\\eta x)(1+\\zeta z^2) \\exp(\\alpha t)\\cos(\\beta x)\\cos(\\gamma y)(1+z^2) + 4\\zeta z^2 k_0 \\exp(\\eta x)\\exp(\\alpha t)\\sin(\\beta x)\\cos(\\gamma y) $$\n\nWe assemble the divergence term $\\nabla \\cdot(k \\nabla T) = (\\nabla k) \\cdot (\\nabla T) + k \\nabla^2 T$. Combining the expressions and factoring out common terms $k_0 \\exp(\\alpha t) \\exp(\\eta x) \\cos(\\gamma y)$:\n$$ \\nabla \\cdot(k \\nabla T) = k_0 \\exp(\\alpha t) \\exp(\\eta x) \\cos(\\gamma y) \\bigg[ \\eta \\beta \\cos(\\beta x)(1+z^2)(1+\\zeta z^2) + 4\\zeta z^2 \\sin(\\beta x) - \\sin(\\beta x)(\\beta^2+\\gamma^2)(1+z^2)(1+\\zeta z^2) + 2\\sin(\\beta x)(1+\\zeta z^2) \\bigg] $$\n$$ \\nabla \\cdot(k \\nabla T) = k_0 \\exp(\\alpha t) \\exp(\\eta x) \\cos(\\gamma y) \\bigg[ \\eta \\beta \\cos(\\beta x)(1+z^2)(1+\\zeta z^2) + \\sin(\\beta x) \\left( -(\\beta^2+\\gamma^2)(1+z^2)(1+\\zeta z^2) + 2(1+\\zeta z^2) + 4\\zeta z^2 \\right) \\bigg] $$\nSimplifying the term in parentheses for $\\sin(\\beta x)$: $2 + 2\\zeta z^2 + 4\\zeta z^2 = 2+6\\zeta z^2=2(1+3\\zeta z^2)$.\n$$ \\nabla \\cdot(k \\nabla T) = k_0 \\exp(\\alpha t) \\exp(\\eta x) \\cos(\\gamma y) \\bigg[ \\eta \\beta (1+z^2)(1+\\zeta z^2) \\cos(\\beta x) + \\left( 2(1+3\\zeta z^2) - (\\beta^2+\\gamma^2)(1+z^2)(1+\\zeta z^2) \\right) \\sin(\\beta x) \\bigg] $$\n\nFinally, we substitute the two main components into the expression for $Q$:\n$$ Q = \\rho c_p \\frac{\\partial T}{\\partial t} - \\nabla \\cdot (k \\nabla T) $$\n$$ Q = \\rho c_p \\alpha \\exp(\\alpha t)\\sin(\\beta x)\\cos(\\gamma y)(1+z^2) - k_0 \\exp(\\alpha t) \\exp(\\eta x) \\cos(\\gamma y) \\bigg[ \\dots \\bigg] $$\nFactor out the common term $\\exp(\\alpha t)\\cos(\\gamma y)$ and group terms by $\\sin(\\beta x)$ and $\\cos(\\beta x)$:\n$$ Q = \\exp(\\alpha t)\\cos(\\gamma y) \\bigg[ \\rho c_p \\alpha (1+z^2) \\sin(\\beta x) - k_0 \\exp(\\eta x) \\left( \\eta \\beta (1+z^2)(1+\\zeta z^2) \\cos(\\beta x) + \\left( 2(1+3\\zeta z^2) - (\\beta^2+\\gamma^2)(1+z^2)(1+\\zeta z^2) \\right) \\sin(\\beta x) \\right) \\bigg] $$\nDistributing the negative sign and grouping terms:\n$$ Q(x,y,z,t) = \\exp(\\alpha t)\\cos(\\gamma y) \\bigg[ \\sin(\\beta x) \\left\\{ \\rho c_p \\alpha (1+z^2) + k_0 \\exp(\\eta x) \\left[ (\\beta^2+\\gamma^2)(1+z^2)(1+\\zeta z^2) - 2(1+3\\zeta z^2) \\right] \\right\\} - k_0 \\beta \\eta \\exp(\\eta x) (1+z^2)(1+\\zeta z^2) \\cos(\\beta x) \\bigg] $$\nThis is the final closed-form expression for the volumetric source term.",
            "answer": "$$\n\\boxed{\n\\exp(\\alpha t)\\cos(\\gamma y) \\left[ \\sin(\\beta x) \\left\\{ \\rho c_p \\alpha (1+z^2) + k_0 \\exp(\\eta x) \\left[ (\\beta^2+\\gamma^2)(1+z^2)(1+\\zeta z^2) - 2(1+3\\zeta z^2) \\right] \\right\\} - k_0 \\beta \\eta \\exp(\\eta x) (1+z^2)(1+\\zeta z^2) \\cos(\\beta x) \\right]\n}\n$$"
        }
    ]
}