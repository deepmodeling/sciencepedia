{
    "hands_on_practices": [
        {
            "introduction": "第一个练习通过引入欠松弛的基本概念为你奠定基础。通过使用不同的松弛因子计算单个热节点的更新温度，你将具体理解该技术作为加权平均的工作原理，并开始体会收敛速度与稳定性之间的权衡。这个简单的标量案例  是所有高级松弛方法应用的基石。",
            "id": "3983933",
            "problem": "一个具有温度依赖性边界热交换的稳态一维热阻网络中的单个内部节点，在空间离散化后，被一个形式为 $F(\\phi)=0$ 的非线性代数平衡方程建模，其中 $\\phi$ 表示以 $\\mathrm{K}$ 为单位的节点温度。为了获得数值解，通过在 $F(\\phi)=0$ 的局部线性化形式的左侧代数分离 $\\phi$ 来构造不动点迭代，这定义了一个映射 $G(\\phi)$，使得所谓的原始更新由 $\\phi^{\\star}=G(\\phi^{k})$ 给出。在实践中，为了增强鲁棒性，采用了求解欠松弛方法，其中下一个迭代值 $\\phi^{k+1}$ 是通过使用松弛因子 $\\alpha\\in(0,1]$ 将当前状态 $\\phi^{k}$ 和原始更新 $\\phi^{\\star}$ 混合得到的。\n\n从不动点形式和任何真实稳态解 $\\phi^{\\infty}$ 在迭代下保持不变的要求出发，推导欠松弛更新作为 $\\phi^{k}$ 和 $\\phi^{\\star}$ 的凸组合。然后，对于这样一个网络中的特定节点，假设当前迭代值为 $\\phi^{k}=0\\,\\mathrm{K}$，且从局部不动点映射计算出的原始更新为 $\\phi^{\\star}=2\\,\\mathrm{K}$。计算松弛因子 $\\alpha=0.2$、$\\alpha=0.5$ 和 $\\alpha=0.9$ 时的下一个迭代值 $\\phi^{k+1}$。将每个计算出的温度以 $\\mathrm{K}$ 为单位表示，并将您的答案四舍五入到四位有效数字。\n\n最后，在标量情况下，使用稳态解附近的不动点映射的局部线性化，表示为 $G(\\phi)\\approx \\phi^{\\infty}+\\lambda\\left(\\phi-\\phi^{\\infty}\\right)$，论证松弛因子 $\\alpha$ 如何影响欠松弛迭代中误差传播因子的大小，并讨论在不计算任何进一步数值的情况下，稳定性与速度之间的权衡。",
            "solution": "该问题被评估为有效。它在科学上基于计算热工学的数值方法原理，特别是不动点迭代和解的松弛技术。该问题提法恰当，内容完整，并使用了精确、客观的语言。推导、计算和分析所需的所有数据和定义均已提供。\n\n该问题包括三个部分：\n1.  欠松弛更新方程的推导。\n2.  在特定条件下，下一个迭代值的数值计算。\n3.  松弛因子对收敛性影响的理论分析。\n\n我们将按顺序解决每个部分。\n\n首先，我们推导欠松弛更新公式。目标是通过混合当前迭代值 $\\phi^{k}$ 和原始更新 $\\phi^{\\star}$ 来获得下一个迭代值 $\\phi^{k+1}$。原始更新由不动点映射 $\\phi^{\\star}=G(\\phi^k)$ 定义。\n\n原始更新所提出的变化是差值 $\\delta\\phi = \\phi^{\\star} - \\phi^{k}$。在标准的不动点迭代（也称为 Picard 迭代或逐次代入迭代）中，下一个迭代值将是 $\\phi^{k+1} = \\phi^{\\star}$。在欠松弛中，只有这个建议变化的一部分 $\\alpha$ 应用于当前状态。因子 $\\alpha$ 是松弛因子，其中 $\\alpha \\in (0, 1]$。\n\n因此，下一个迭代值是通过将这个被抑制的变化加到当前迭代值上形成的：\n$$\n\\phi^{k+1} = \\phi^{k} + \\alpha(\\phi^{\\star} - \\phi^{k})\n$$\n这个表达式可以进行代数重排：\n$$\n\\phi^{k+1} = \\phi^{k} - \\alpha\\phi^{k} + \\alpha\\phi^{\\star}\n$$\n$$\n\\phi^{k+1} = (1-\\alpha)\\phi^{k} + \\alpha\\phi^{\\star}\n$$\n这是 $\\phi^{k}$ 和 $\\phi^{\\star}$ 的一个凸组合，因为当 $\\alpha \\in [0, 1]$ 时，系数 $(1-\\alpha)$ 和 $\\alpha$ 是非负的，并且它们的和为 $(1-\\alpha) + \\alpha = 1$。\n\n问题指出，任何真实的稳态解 $\\phi^{\\infty}$ 在迭代下必须保持不变。稳态解是映射 $G$ 的一个不动点，即 $G(\\phi^{\\infty})=\\phi^{\\infty}$。让我们测试我们推导出的公式。如果当前迭代值是解，即 $\\phi^{k} = \\phi^{\\infty}$，那么原始更新是 $\\phi^{\\star} = G(\\phi^{k}) = G(\\phi^{\\infty}) = \\phi^{\\infty}$。将这些代入更新公式得到：\n$$\n\\phi^{k+1} = (1-\\alpha)\\phi^{\\infty} + \\alpha\\phi^{\\infty} = (1-\\alpha+\\alpha)\\phi^{\\infty} = 1 \\cdot \\phi^{\\infty} = \\phi^{\\infty}\n$$\n解确实保持不变，这证实了所推导形式的正确性。\n\n其次，我们根据给定的数值计算下一个迭代值 $\\phi^{k+1}$。给定值是当前迭代值 $\\phi^{k}=0\\,\\mathrm{K}$ 和原始更新 $\\phi^{\\star}=2\\,\\mathrm{K}$。我们使用推导出的公式 $\\phi^{k+1} = (1-\\alpha)\\phi^{k} + \\alpha\\phi^{\\star}$。\n\n对于 $\\alpha=0.2$：\n$$\n\\phi^{k+1} = (1-0.2)(0\\,\\mathrm{K}) + (0.2)(2\\,\\mathrm{K}) = (0.8)(0\\,\\mathrm{K}) + (0.2)(2\\,\\mathrm{K}) = 0\\,\\mathrm{K} + 0.4\\,\\mathrm{K} = 0.4\\,\\mathrm{K}\n$$\n四舍五入到四位有效数字，结果是 $0.4000\\,\\mathrm{K}$。\n\n对于 $\\alpha=0.5$：\n$$\n\\phi^{k+1} = (1-0.5)(0\\,\\mathrm{K}) + (0.5)(2\\,\\mathrm{K}) = (0.5)(0\\,\\mathrm{K}) + (0.5)(2\\,\\mathrm{K}) = 0\\,\\mathrm{K} + 1.0\\,\\mathrm{K} = 1.0\\,\\mathrm{K}\n$$\n四舍五入到四位有效数字，结果是 $1.000\\,\\mathrm{K}$。\n\n对于 $\\alpha=0.9$：\n$$\n\\phi^{k+1} = (1-0.9)(0\\,\\mathrm{K}) + (0.9)(2\\,\\mathrm{K}) = (0.1)(0\\,\\mathrm{K}) + (0.9)(2\\,\\mathrm{K}) = 0\\,\\mathrm{K} + 1.8\\,\\mathrm{K} = 1.8\\,\\mathrm{K}\n$$\n四舍五入到四位有效数字，结果是 $1.800\\,\\mathrm{K}$。\n\n第三，我们分析松弛因子 $\\alpha$ 对收敛性的影响。设第 $k$ 次迭代的误差定义为 $e^{k} = \\phi^{k} - \\phi^{\\infty}$。欠松弛迭代方案是：\n$$\n\\phi^{k+1} = (1-\\alpha)\\phi^{k} + \\alpha G(\\phi^{k})\n$$\n我们已知 $G(\\phi)$ 在解 $\\phi^{\\infty}$ 附近的局部线性化：\n$$\nG(\\phi^{k}) \\approx \\phi^{\\infty} + \\lambda(\\phi^{k} - \\phi^{\\infty})\n$$\n将此代入迭代方案：\n$$\n\\phi^{k+1} \\approx (1-\\alpha)\\phi^{k} + \\alpha[\\phi^{\\infty} + \\lambda(\\phi^{k} - \\phi^{\\infty})]\n$$\n为了找到连续误差之间的关系，我们从两边减去 $\\phi^{\\infty}$。注意 $\\phi^{\\infty}$ 可以写成 $(1-\\alpha)\\phi^{\\infty} + \\alpha\\phi^{\\infty}$。\n$$\n\\phi^{k+1} - \\phi^{\\infty} \\approx [(1-\\alpha)\\phi^{k} - (1-\\alpha)\\phi^{\\infty}] + [\\alpha\\phi^{\\infty} + \\alpha\\lambda(\\phi^{k} - \\phi^{\\infty}) - \\alpha\\phi^{\\infty}]\n$$\n$$\n\\phi^{k+1} - \\phi^{\\infty} \\approx (1-\\alpha)(\\phi^{k} - \\phi^{\\infty}) + \\alpha\\lambda(\\phi^{k} - \\phi^{\\infty})\n$$\n提出误差项 $(\\phi^k - \\phi^{\\infty}) = e^k$：\n$$\ne^{k+1} \\approx [(1-\\alpha) + \\alpha\\lambda] e^{k}\n$$\n因此，欠松弛方案的误差传播因子，我们称之为 $\\lambda_{\\alpha}$，是：\n$$\n\\lambda_{\\alpha} = (1-\\alpha) + \\alpha\\lambda\n$$\n为了使迭代收敛，该因子的大小必须小于 $1$，即 $|\\lambda_{\\alpha}| < 1$。$|\\lambda_{\\alpha}|$ 的值决定了收敛速度；较小的大小意味着更快的收敛。因子 $\\lambda_{\\alpha}$ 是在 $\\lambda_{\\alpha}=1$（当 $\\alpha=0$ 时）和 $\\lambda_{\\alpha}=\\lambda$（当 $\\alpha=1$ 时）之间的线性插值。\n\n稳定性与速度之间的权衡如下：\n- **稳定性**：减小松弛因子 $\\alpha$（即使其小于 $1$）会使更新更加保守，因为 $\\phi^{k+1}$ 更接近于 $\\phi^{k}$。这会抑制大的振荡，并能稳定一个原本发散或不稳定的迭代。对于一个非线性问题，其中局部有效 $\\lambda$ 可能变化并暂时超过 $1$，一个小的 $\\alpha$ 提供了一个鲁棒性裕度，防止解发散。然而，这种增加的稳定性是有代价的。\n- **速度**：收敛速率由 $|\\lambda_{\\alpha}|$ 决定。\n    - 如果基本迭代已经是收敛且单调的（$0 < \\lambda < 1$），那么对于任何 $\\alpha \\in (0,1)$，我们有 $\\lambda < \\lambda_{\\alpha} < 1$。在这种情况下，欠松弛（$\\alpha < 1$）会减慢收敛速度，最快的速率是在没有松弛（$\\alpha=1$）时实现的。\n    - 如果基本迭代是收敛且振荡的（$-1 < \\lambda < 0$），可能存在一个最优松弛因子 $\\alpha_{\\text{opt}} = \\frac{1}{1-\\lambda}$，它使得 $\\lambda_{\\alpha}=0$。因为 $-1 < \\lambda < 0$，我们有 $1/2 < \\alpha_{\\text{opt}} < 1$。因此使用 $\\alpha<1$ 可以加速收敛。\n    - 一般来说，选择一个小的 $\\alpha$ 会使 $|\\lambda_{\\alpha}|$ 更接近于 $1$（因为当 $\\alpha \\to 0$ 时 $\\lambda_{\\alpha}$ 趋近于 $1$），这对应于慢收敛。选择一个较大的 $\\alpha$（更接近于 $1$）会使 $\\lambda_{\\alpha}$ 趋向于 $\\lambda$，如果基本迭代表现良好，这可能会更快，但如果表现不好，则风险更大。\n\n总之，松弛因子 $\\alpha$ 是一个控制参数，用于平衡收敛速度和迭代稳定性这两个相互竞争的需求。小的 $\\alpha$ 有利于稳定性而非速度，而大的 $\\alpha$ 有利于速度，但可能带来不稳定的风险。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.4000 & 1.000 & 1.800\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在标量概念的基础上，本练习将欠松弛技术推广到线性方程组，这在离散化的工程问题中十分常见。你将通过检验放大矩阵的特征值来分析迭代过程的稳定性，这是数值线性代数的一个基石。该练习  将使你掌握确定稳定收敛解所需精确数学条件的能力。",
            "id": "3983945",
            "problem": "考虑一个用于稳定稳态热传导方程不动点求解器的伪时间步欠松弛格式。从能量守恒和傅里叶定律出发，对热方程中的拉普拉斯算子进行空间离散化，得到一个线性残差映射 $R(\\mathbf{T}) = F \\mathbf{T} - \\mathbf{b}$，其中 $F$ 是残差相对于温度向量 $\\mathbf{T}$ 的雅可比矩阵。应用一阶显式伪时间更新将残差驱动至零：\n$$\n\\mathbf{T}^{k+1} = \\mathbf{T}^{k} - \\alpha \\left(F \\mathbf{T}^{k} - \\mathbf{b}\\right),\n$$\n其中 $\\alpha$ 是一个无量纲欠松弛参数。在稳态解 $\\mathbf{T}^{\\star}$ 附近对更新进行线性化，误差 $\\mathbf{e}^{k} = \\mathbf{T}^{k} - \\mathbf{T}^{\\star}$ 的演化规律为\n$$\n\\mathbf{e}^{k+1} = G_{\\alpha} \\, \\mathbf{e}^{k}, \\quad \\text{with} \\quad G_{\\alpha} = I - \\alpha F.\n$$\n仅当谱半径 $\\rho(G_{\\alpha})$ 满足 $\\rho(G_{\\alpha}) < 1$ 时，线性迭代的收敛性才能得到保证。设迭代矩阵为\n$$\nF = \\begin{bmatrix} 1.3 & 0.4 \\\\ 0.1 & 0.9 \\end{bmatrix}.\n$$\n从标准特征值问题定义和上述收敛准则出发，完成以下操作：\n- 精确计算 $F$ 的特征值。\n- 从线性迭代稳定性的第一性原理出发，推导使 $G_{\\alpha}$ 达到临界稳定（即 $\\rho(G_{\\alpha}) = 1$ 的临界阈值）的最大允许欠松弛参数 $\\alpha$，并用它来陈述收敛的严格可行性条件。\n- 通过使用您所获得的特征值，在阈值处显式计算 $\\rho(G_{\\alpha})$ 来验证此阈值。\n\n将最大允许值 $\\alpha$ 表示为单个闭式解析表达式。不要进行近似；将最终值表示为精确表达式。将 $\\alpha$ 表示为不带单位的纯数。",
            "solution": "首先根据所需准则对问题陈述进行验证。\n\n### 问题验证\n\n**第1步：提取已知条件**\n- 伪时间更新格式：$\\mathbf{T}^{k+1} = \\mathbf{T}^{k} - \\alpha \\left(F \\mathbf{T}^{k} - \\mathbf{b}\\right)$\n- 误差演化方程：$\\mathbf{e}^{k+1} = G_{\\alpha} \\, \\mathbf{e}^{k}$\n- 放大矩阵：$G_{\\alpha} = I - \\alpha F$\n- 收敛准则：$\\rho(G_{\\alpha}) < 1$，其中 $\\rho$ 是谱半径。\n- 迭代矩阵 $F$：\n$$\nF = \\begin{bmatrix} 1.3 & 0.4 \\\\ 0.1 & 0.9 \\end{bmatrix}\n$$\n\n**第2步：使用提取的已知条件进行验证**\n- **科学基础：** 问题描述了 Richardson 迭代，这是一种求解线性系统的标准方法，应用于计算热工领域。基于放大矩阵谱半径的稳定性分析是数值线性代数中一个基本且正确的概念。该公式与既定原理一致。\n- **适定性：** 问题提供了一个特定的矩阵，并要求基于明确的数学准则求解一个唯一可确定的量（临界欠松弛参数）。所有必要的数据都已提供。\n- **客观性：** 问题使用精确的数学语言和客观标准陈述。没有主观或含糊不清的术语。\n- **完整性与一致性：** 问题是自洽的，没有矛盾之处。更新格式、误差演化和稳定性准则之间的关系在内部是一致的。\n\n**第3步：结论与行动**\n该问题被认为是有效的，因为它是科学合理的、适定的、客观的和自洽的。可以继续求解过程。\n\n### 解答\n\n解答过程按要求分为三部分：计算 $F$ 的特征值，推导临界欠松弛参数 $\\alpha$，并验证结果。\n\n**第1部分：计算 $F$ 的特征值**\n\n矩阵 $F$ 的特征值 $\\lambda$ 是特征方程 $\\det(F - \\lambda I) = 0$ 的根，其中 $I$ 是单位矩阵。\n$$\n\\det\\left( \\begin{bmatrix} 1.3 - \\lambda & 0.4 \\\\ 0.1 & 0.9 - \\lambda \\end{bmatrix} \\right) = 0\n$$\n展开行列式得到特征多项式：\n$$\n(1.3 - \\lambda)(0.9 - \\lambda) - (0.4)(0.1) = 0\n$$\n$$\n1.17 - 1.3\\lambda - 0.9\\lambda + \\lambda^2 - 0.04 = 0\n$$\n$$\n\\lambda^2 - 2.2\\lambda + 1.13 = 0\n$$\n我们使用二次公式 $\\lambda = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$ 求解这个关于 $\\lambda$ 的二次方程：\n$$\n\\lambda = \\frac{-(-2.2) \\pm \\sqrt{(-2.2)^2 - 4(1)(1.13)}}{2(1)}\n$$\n$$\n\\lambda = \\frac{2.2 \\pm \\sqrt{4.84 - 4.52}}{2}\n$$\n$$\n\\lambda = \\frac{2.2 \\pm \\sqrt{0.32}}{2}\n$$\n项 $\\sqrt{0.32}$ 可以简化为：$\\sqrt{0.32} = \\sqrt{\\frac{32}{100}} = \\frac{\\sqrt{16 \\times 2}}{10} = \\frac{4\\sqrt{2}}{10} = 0.4\\sqrt{2}$。\n将此代回 $\\lambda$ 的方程中：\n$$\n\\lambda = \\frac{2.2 \\pm 0.4\\sqrt{2}}{2} = 1.1 \\pm 0.2\\sqrt{2}\n$$\n$F$ 的两个特征值是：\n$$\n\\lambda_{\\max}(F) = 1.1 + 0.2\\sqrt{2}\n$$\n$$\n\\lambda_{\\min}(F) = 1.1 - 0.2\\sqrt{2}\n$$\n由于 $\\sqrt{2} \\approx 1.414$，我们可以看到 $0.2\\sqrt{2} \\approx 0.2828$，小于 $1.1$，因此两个特征值都是正实数。\n\n**第2部分：推导最大允许欠松弛参数 $\\alpha$**\n\n放大矩阵为 $G_{\\alpha} = I - \\alpha F$。如果 $\\lambda_i$ 是 $F$ 的一个特征值，其对应的特征向量为 $\\mathbf{v}_i$，那么 $G_{\\alpha}$ 对应的特征值 $\\mu_i$ 由下式给出：\n$$\nG_{\\alpha}\\mathbf{v}_i = (I - \\alpha F)\\mathbf{v}_i = I\\mathbf{v}_i - \\alpha F\\mathbf{v}_i = \\mathbf{v}_i - \\alpha\\lambda_i\\mathbf{v}_i = (1 - \\alpha\\lambda_i)\\mathbf{v}_i\n$$\n因此，$G_{\\alpha}$ 的特征值为 $\\mu_i = 1 - \\alpha\\lambda_i$。\n当且仅当 $G_{\\alpha}$ 的谱半径小于1时，迭代收敛：\n$$\n\\rho(G_{\\alpha}) = \\max_i |\\mu_i| = \\max_i |1 - \\alpha\\lambda_i| < 1\n$$\n这个条件必须对 $F$ 的所有特征值 $\\lambda_i$ 都成立。这等价于不等式：\n$$\n-1 < 1 - \\alpha\\lambda_i < 1 \\quad \\text{for all } i\n$$\n我们分析这个不等式的两部分。对于欠松弛格式，我们考虑 $\\alpha > 0$。由于我们发现 $F$ 的所有特征值 $\\lambda_i$ 都是正数，因此 $\\alpha\\lambda_i > 0$。\n不等式的右边是 $1 - \\alpha\\lambda_i < 1$，简化为 $-\\alpha\\lambda_i < 0$。对于 $\\alpha > 0$ 和 $\\lambda_i > 0$，这总是成立的。\n不等式的左边是 $-1 < 1 - \\alpha\\lambda_i$，简化为 $\\alpha\\lambda_i < 2$，或 $\\alpha < \\frac{2}{\\lambda_i}$。\n这个条件必须对所有特征值都成立。因此，$\\alpha$ 必须小于所有可能的 $\\frac{2}{\\lambda_i}$ 值中的最小值：\n$$\n\\alpha < \\min_i \\left(\\frac{2}{\\lambda_i}\\right) = \\frac{2}{\\max_i(\\lambda_i)} = \\frac{2}{\\lambda_{\\max}(F)}\n$$\n收敛的严格可行性条件是 $0 < \\alpha < \\frac{2}{\\lambda_{\\max}(F)}$。\n使系统达到临界稳定的最大允许欠松弛参数 $\\alpha$ 对应于此区间的边界，即 $\\rho(G_{\\alpha}) = 1$。我们记此临界值为 $\\alpha_{crit}$，其值为：\n$$\n\\alpha_{crit} = \\frac{2}{\\lambda_{\\max}(F)} = \\frac{2}{1.1 + 0.2\\sqrt{2}}\n$$\n为了将其表示为单个闭式解析表达式，我们可以对分母进行有理化：\n$$\n\\alpha_{crit} = \\frac{2}{\\frac{11}{10} + \\frac{2}{10}\\sqrt{2}} = \\frac{20}{11 + 2\\sqrt{2}}\n$$\n$$\n\\alpha_{crit} = \\frac{20(11 - 2\\sqrt{2})}{(11 + 2\\sqrt{2})(11 - 2\\sqrt{2})} = \\frac{220 - 40\\sqrt{2}}{11^2 - (2\\sqrt{2})^2} = \\frac{220 - 40\\sqrt{2}}{121 - 8} = \\frac{220 - 40\\sqrt{2}}{113}\n$$\n\n**第3部分：验证阈值**\n\n在临界阈值 $\\alpha = \\alpha_{crit} = \\frac{2}{\\lambda_{\\max}(F)}$ 处，我们计算谱半径 $\\rho(G_{\\alpha_{crit}})$。$G_{\\alpha_{crit}}$ 的特征值为 $1 - \\alpha_{crit}\\lambda_i$。\n\n对于特征值 $\\lambda_{\\max}(F)$：\n$$\n\\mu_{\\max} = 1 - \\alpha_{crit}\\lambda_{\\max}(F) = 1 - \\left(\\frac{2}{\\lambda_{\\max}(F)}\\right)\\lambda_{\\max}(F) = 1 - 2 = -1\n$$\n$$\n|\\mu_{\\max}| = |-1| = 1\n$$\n对于特征值 $\\lambda_{\\min}(F)$：\n$$\n\\mu_{\\min} = 1 - \\alpha_{crit}\\lambda_{\\min}(F) = 1 - \\left(\\frac{2}{\\lambda_{\\max}(F)}\\right)\\lambda_{\\min}(F) = 1 - 2\\frac{\\lambda_{\\min}(F)}{\\lambda_{\\max}(F)}\n$$\n由于 $0 < \\lambda_{\\min}(F) < \\lambda_{\\max}(F)$，比值 $\\frac{\\lambda_{\\min}(F)}{\\lambda_{\\max}(F)}$ 是一个小于1的正数。因此，$0 < 2\\frac{\\lambda_{\\min}(F)}{\\lambda_{\\max}(F)} < 2$。\n这意味着 $-1 < 1 - 2\\frac{\\lambda_{\\min}(F)}{\\lambda_{\\max}(F)} < 1$，即 $|\\mu_{\\min}| < 1$。\n在阈值处的谱半径为：\n$$\n\\rho(G_{\\alpha_{crit}}) = \\max(|\\mu_{\\max}|, |\\mu_{\\min}|) = \\max(1, |\\mu_{\\min}|) = 1\n$$\n这证实了 $\\alpha_{crit} = \\frac{220 - 40\\sqrt{2}}{113}$ 确实是使系统达到临界稳定的最大允许参数。\n收敛的严格可行性条件是 $0 < \\alpha < \\frac{220 - 40\\sqrt{2}}{113}$。问题要求的是使系统达到临界稳定的最大允许 $\\alpha$，即这个上界。",
            "answer": "$$\\boxed{\\frac{220 - 40\\sqrt{2}}{113}}$$"
        },
        {
            "introduction": "为了连接理论与实践，最后一个练习要求你通过编写代码实现欠松弛算法，以解决一个代表真实热平衡的非线性问题。通过为一个同时包含线性和四次方辐射项的方程开发求解器，你将巩固对迭代过程及其在实际工程环境中应用的理解。这项动手编程任务  展示了欠松弛在确保复杂非线性系统稳健收敛方面的威力。",
            "id": "3983935",
            "problem": "考虑一个处于稳态的集总热节点，它通过一条线性化路径和一条辐射路径进行热交换。稳态热力学第一定律要求，所有传入和传出热流率之和为零。将线性路径建模为与温度成正比，辐射路径建模为与温度的四次方成正比，则标量能量平衡可以写成\n$$\na\\,T + b\\,T^{4} = c,\n$$\n其中 $a>0$ 和 $b>0$ 是常数，$T$ 是未知温度。常数 $c>0$ 代表净规定热输入。定义残差函数\n$$\nR(T) \\equiv a\\,T + b\\,T^{4} - c.\n$$\n为此标量方程实现一个带有欠松弛的逐次替换（不动点）法。使用欠松弛的定义思想：在每次迭代中，通过将当前迭代值代入所有非线性项并求解所得的关于主未知数的线性方程，来计算一个无约束更新，然后用松弛因子 $\\alpha \\in (0,1]$ 将下一个迭代值构造为当前迭代值和无约束更新的凸组合。自始至终使用固定的松弛因子 $\\alpha = 0.3$。设收敛标准为相对残差\n$$\nr_k \\equiv \\frac{\\lvert R(T_k)\\rvert}{\\lvert c \\rvert},\n$$\n并在 $r_k < 10^{-6}$ 时宣告收敛。迭代次数计为达到第一个满足收敛准则的迭代值所进行的欠松弛更新步数。如果初始猜测值 $T_0$ 已满足准则，则报告迭代次数为零。如果该方法在最多 $10^{6}$ 次迭代内未能收敛，或者迭代值变为非有限值，则该情况报告整数 $-1$。\n\n您的任务是编写一个程序，对于下面测试套件中的每一组参数，使用上述算法，返回在 $\\alpha=0.3$ 的条件下达到容差所需的迭代次数。所有参数 $a$、$b$、$c$ 和 $T_0$ 都是以一致单位给出的正实数；所要求的答案是迭代次数，因此是无单位整数。\n\n测试套件（每个案例是一个元组 $(a,b,c,T_0)$）：\n1. $(a,b,c,T_0) = (25.0,\\;5.0\\times 10^{-8},\\;1000.0,\\;300.0)$\n2. $(a,b,c,T_0) = (100.0,\\;1.0\\times 10^{-12},\\;20000.0,\\;200.0)$\n3. $(a,b,c,T_0) = (2.0,\\;1.0\\times 10^{-7},\\;500.0,\\;50.0)$\n4. $(a,b,c,T_0) = (10.0,\\;5.0\\times 10^{-8},\\;1000.0,\\;10.0)$\n5. $(a,b,c,T_0) = (1.0\\times 10^{-3},\\;5.0\\times 10^{-8},\\;1000.0,\\;300.0)$\n\n最终输出格式：您的程序应生成单行输出，其中包含五个结果，形式为方括号内无空格的逗号分隔列表，例如 $[n_1,n_2,n_3,n_4,n_5]$，其中每个 $n_i$ 是相应测试案例的整数迭代次数，如果方法在规定规则下未收敛，则为 $-1$。",
            "solution": "该问题要求实现一种带有欠松弛的逐次替换法，以求解一个代表热节点稳态能量平衡的标量非线性方程。控制方程由下式给出：\n$$\naT + bT^4 = c\n$$\n其中 $T$ 是绝对温度，$a$、$b$ 和 $c$ 是代表系统物理属性的正数常数。这些常数为 $a > 0$、$b > 0$ 和 $c > 0$。\n\n任务是找出对于几组参数，指定的数值方案收敛所需的迭代次数。\n\n首先，我们形式化地描述迭代算法。该方法的核心是在每一步中对该方程进行线性化。设 $T_k$ 为第 $k$ 次迭代时的温度。问题描述指出，无约束更新（此处记为 $T_{k+1}^*$）是通过“将当前迭代值代入所有非线性项并求解所得的关于主未知数的线性方程”来找到的。方程 $aT + bT^4 - c = 0$ 中唯一的非线性项是 $bT^4$。将此项视为基于当前迭代值 $T_k$ 的一个恒定源，我们为 $T_{k+1}^*$ 建立一个线性方程：\n$$\na T_{k+1}^* + b T_k^4 = c\n$$\n求解此方程得到 $T_{k+1}^*$ 的无约束更新：\n$$\nT_{k+1}^* = \\frac{c - b T_k^4}{a}\n$$\n然后，下一个迭代值 $T_{k+1}$ 通过欠松弛形成，欠松弛被定义为当前迭代值 $T_k$ 和无约束更新 $T_{k+1}^*$ 的凸组合。使用松弛因子 $\\alpha \\in (0, 1]$，更新规则为：\n$$\nT_{k+1} = (1 - \\alpha) T_k + \\alpha T_{k+1}^*\n$$\n将 $T_{k+1}^*$ 的表达式代入此方程，得到完整的迭代公式：\n$$\nT_{k+1} = (1 - \\alpha) T_k + \\alpha \\left( \\frac{c - b T_k^4}{a} \\right)\n$$\n问题指定了固定的松弛因子 $\\alpha = 0.3$。\n\n对于给定的一组参数 $(a, b, c, T_0)$，寻找迭代次数的算法如下：\n\n1.  **初始化**：设置参数 $a$、$b$、$c$ 和初始猜测值 $T_0$。设置松弛因子 $\\alpha = 0.3$，收敛容差 $\\epsilon = 10^{-6}$，以及最大迭代次数 $N_{\\text{max}} = 10^6$。设迭代计数器为 $k=0$，当前温度为 $T_k = T_0$。\n\n2.  **初始收敛性检查**：计算残差函数 $R(T_k) = aT_k + bT_k^4 - c$。收敛性通过相对残差 $r_k = \\frac{|R(T_k)|}{|c|}$ 来衡量。由于给定 $c > 0$，这可简化为 $r_k = \\frac{|R(T_k)|}{c}$。如果 $r_0 < \\epsilon$，则初始猜测值已足够精确，过程终止，迭代次数为 0。\n\n3.  **迭代循环**：如果初始猜测值不满足准则，则开始迭代循环， $k = 1, 2, 3, \\dots, N_{\\text{max}}$。\n    a.  将当前迭代值存储为 $T_{k-1}$。\n    b.  使用更新规则计算下一个迭代值 $T_k$：\n        $$\n        T_k = (1 - \\alpha) T_{k-1} + \\alpha \\left( \\frac{c - b T_{k-1}^4}{a} \\right)\n        $$\n    c.  **失败检查**：计算出 $T_k$ 后，检查它是否已变为非有限数（例如，无穷大或NaN）。如果迭代发散，例如由于计算 $T_{k-1}^4$ 时发生上溢，就可能出现这种情况。如果 $T_k$ 是非有限数，则该方法已失败。过程终止，并报告结果为 $-1$。\n    d.  **收敛性检查**：为新的迭代值计算相对残差 $r_k = \\frac{|aT_k + bT_k^4 - c|}{c}$。\n    e.  如果 $r_k < \\epsilon$，则解已收敛。过程终止，并将当前迭代次数 $k$ 作为结果报告。\n\n4.  **最大迭代次数检查**：如果循环完成（即 $k$ 达到 $N_{\\text{max}}$）而收敛准则仍未满足，则该方法未能在允许的迭代次数内收敛。过程终止，并报告结果为 $-1$。\n\n这个完整的算法将被实现并应用于所提供的五个测试案例中的每一个。计算必须使用具有足够精度的浮点运算来执行，以处理给定的参数值，并尽可能避免过早的下溢或上溢。使用 `numpy.float64` 适合此任务。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _solve_single_case(a_in, b_in, c_in, T_0_in):\n    \"\"\"\n    Solves a single case of the thermal balance problem using successive\n    substitution with under-relaxation.\n    \"\"\"\n    # Use numpy.float64 for robust floating-point arithmetic\n    a = np.float64(a_in)\n    b = np.float64(b_in)\n    c = np.float64(c_in)\n    T_k = np.float64(T_0_in)\n\n    alpha = np.float64(0.3)\n    tolerance = np.float64(1e-6)\n    max_iterations = 1000000\n\n    # Define residual function for convenience\n    def R(T):\n        # Handle potential overflow in T**4\n        try:\n            T_pow4 = T**4\n        except OverflowError:\n            return np.inf\n        \n        if not np.isfinite(T_pow4):\n            # This indicates T is too large, causing overflow.\n            # Return non-finite to be caught as a failure condition.\n            return np.inf\n        return a * T + b * T_pow4 - c\n\n    # Initial a-priori check for convergence at k=0\n    # The problem specifies |c| in the denominator, and c > 0.\n    residual_0 = R(T_k)\n    if not np.isfinite(residual_0):\n        return -1\n        \n    rel_residual_0 = np.abs(residual_0) / c\n    if rel_residual_0  tolerance:\n        return 0\n\n    # Iteration loop\n    for k in range(1, max_iterations + 1):\n        T_prev = T_k\n\n        # Step 1: Compute unconstrained update T_star\n        # The term T_prev**4 can overflow if T_prev becomes very large\n        try:\n            T_prev_pow4 = T_prev**4\n        except OverflowError:\n            return -1 # Iteration diverged, causing overflow\n\n        if not np.isfinite(T_prev_pow4):\n            return -1 # Iteration diverged, causing overflow\n\n        T_star = (c - b * T_prev_pow4) / a\n\n        # Step 2: Compute the new iterate T_k with under-relaxation\n        T_k = (np.float64(1.0) - alpha) * T_prev + alpha * T_star\n        \n        # Check if the new iterate is finite\n        if not np.isfinite(T_k):\n            return -1 # Iteration has produced a non-finite value\n\n        # Step 3: Check for convergence\n        residual_k = R(T_k)\n        if not np.isfinite(residual_k):\n            # T_k itself may be finite, but R(T_k) can overflow\n            return -1\n\n        rel_residual_k = np.abs(residual_k) / c\n        if rel_residual_k  tolerance:\n            return k\n\n    # If the loop finishes, the method failed to converge within max_iterations\n    return -1\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (a, b, c, T_0)\n        (25.0, 5.0e-8, 1000.0, 300.0),\n        (100.0, 1.0e-12, 20000.0, 200.0),\n        (2.0, 1.0e-7, 500.0, 50.0),\n        (10.0, 5.0e-8, 1000.0, 10.0),\n        (1.0e-3, 5.0e-8, 1000.0, 300.0)\n    ]\n\n    results = []\n    for case in test_cases:\n        iteration_count = _solve_single_case(*case)\n        results.append(iteration_count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solver\nsolve()\n\n```"
        }
    ]
}