{
    "hands_on_practices": [
        {
            "introduction": "理解欠松弛技术应从最简单的情形入手：求解单个方程。本练习将带你掌握基本的更新公式，展示新解如何由旧解和原始更新值加权平均得到。通过一个简单的计算和对误差传播的分析，你将对一个核心概念建立起直观的认识：迭代稳定性和快速收敛之间的权衡，这是所有数值求解器中的一个中心主题 。",
            "id": "3983933",
            "problem": "一个具有温度依赖性边界热交换的稳态一维热阻网络中的单个内部节点，在空间离散化后，通过一个非线性代数平衡式 $F(\\phi)=0$ 进行建模，其中 $\\phi$ 表示节点温度，单位为 $\\mathrm{K}$。为了获得数值解，通过对 $F(\\phi)=0$ 的局部线性化形式进行代数变换，将 $\\phi$ 分离到等式左侧，从而构造了一个不动点迭代。这定义了一个映射 $G(\\phi)$，使得所谓的原始更新由 $\\phi^{\\star}=G(\\phi^{k})$ 给出。在实践中，为了增强鲁棒性，采用了欠松弛方法，即使用一个松弛因子 $\\alpha\\in(0,1]$ 将当前状态 $\\phi^{k}$ 和原始更新 $\\phi^{\\star}$混合，以获得下一个迭代值 $\\phi^{k+1}$。\n\n从不动点形式出发，并根据任何真实稳态解 $\\phi^{\\infty}$ 在迭代下必须保持不变的要求，推导出欠松弛更新作为 $\\phi^{k}$ 和 $\\phi^{\\star}$ 的凸组合。然后，对于该网络中的一个特定节点，假设当前迭代值为 $\\phi^{k}=0\\,\\mathrm{K}$，且根据局部不动点映射计算出的原始更新为 $\\phi^{\\star}=2\\,\\mathrm{K}$。计算当松弛因子 $\\alpha=0.2$、$\\alpha=0.5$ 和 $\\alpha=0.9$ 时的下一个迭代值 $\\phi^{k+1}$。将每个计算出的温度以 $\\mathrm{K}$ 为单位表示，并将答案四舍五入到四位有效数字。\n\n最后，在标量情况下，使用稳态解附近不动点映射的局部线性化表示 $G(\\phi)\\approx \\phi^{\\infty}+\\lambda\\left(\\phi-\\phi^{\\infty}\\right)$（其中 $|\\lambda|1$），论述松弛因子 $\\alpha$ 如何影响欠松弛迭代中误差传播因子的大小，并讨论在不进行任何进一步数值计算的情况下，稳定性与速度之间的权衡。",
            "solution": "该问题被评估为有效。它在科学上基于计算热工学中数值方法的原理，特别是关于不动点迭代和解的松弛技术。该问题提法恰当、内容完整，并使用了精确、客观的语言。推导、计算和分析所需的所有数据和定义均已提供。\n\n该问题包含三个部分：\n1.  欠松弛更新方程的推导。\n2.  在特定条件下计算下一个迭代值。\n3.  松弛因子对收敛性影响的理论分析。\n\n我们将依次解决每个部分。\n\n首先，我们推导欠松弛更新公式。目标是通过混合当前迭代值 $\\phi^{k}$ 和原始更新 $\\phi^{\\star}$ 来获得下一个迭代值 $\\phi^{k+1}$。原始更新由不动点映射 $\\phi^{\\star}=G(\\phi^k)$ 定义。\n\n原始更新所提出的变化是差值 $\\delta\\phi = \\phi^{\\star} - \\phi^{k}$。在标准的不动点迭代（也称为皮卡迭代或逐次代换迭代）中，下一个迭代值将是 $\\phi^{k+1} = \\phi^{\\star}$。在欠松弛中，只有这个建议变化的一部分 $\\alpha$ 被应用到当前状态。因子 $\\alpha$ 是松弛因子，满足 $\\alpha \\in (0, 1]$。\n\n因此，下一个迭代值是通过将这个衰减后的变化量加到当前迭代值上形成的：\n$$\n\\phi^{k+1} = \\phi^{k} + \\alpha(\\phi^{\\star} - \\phi^{k})\n$$\n这个表达式可以进行代数重排：\n$$\n\\phi^{k+1} = \\phi^{k} - \\alpha\\phi^{k} + \\alpha\\phi^{\\star}\n$$\n$$\n\\phi^{k+1} = (1-\\alpha)\\phi^{k} + \\alpha\\phi^{\\star}\n$$\n这是 $\\phi^{k}$ 和 $\\phi^{\\star}$ 的一个凸组合，因为当 $\\alpha \\in [0, 1]$ 时，系数 $(1-\\alpha)$ 和 $\\alpha$ 是非负的，并且它们的和为 $(1-\\alpha) + \\alpha = 1$。\n\n问题指出，任何真实的稳态解 $\\phi^{\\infty}$ 在迭代下必须保持不变。一个稳态解是映射 $G$ 的一个不动点，即 $G(\\phi^{\\infty})=\\phi^{\\infty}$。让我们测试一下我们推导出的公式。如果当前迭代值就是解，即 $\\phi^{k} = \\phi^{\\infty}$，那么原始更新为 $\\phi^{\\star} = G(\\phi^{k}) = G(\\phi^{\\infty}) = \\phi^{\\infty}$。将这些代入更新公式，得到：\n$$\n\\phi^{k+1} = (1-\\alpha)\\phi^{\\infty} + \\alpha\\phi^{\\infty} = (1-\\alpha+\\alpha)\\phi^{\\infty} = 1 \\cdot \\phi^{\\infty} = \\phi^{\\infty}\n$$\n解确实保持不变，这证实了所推导形式的正确性。\n\n第二，我们根据给定的数值计算下一个迭代值 $\\phi^{k+1}$。给定值为当前迭代值 $\\phi^{k}=0\\,\\mathrm{K}$ 和原始更新 $\\phi^{\\star}=2\\,\\mathrm{K}$。我们使用推导出的公式 $\\phi^{k+1} = (1-\\alpha)\\phi^{k} + \\alpha\\phi^{\\star}$。\n\n对于 $\\alpha=0.2$：\n$$\n\\phi^{k+1} = (1-0.2)(0\\,\\mathrm{K}) + (0.2)(2\\,\\mathrm{K}) = (0.8)(0\\,\\mathrm{K}) + (0.2)(2\\,\\mathrm{K}) = 0\\,\\mathrm{K} + 0.4\\,\\mathrm{K} = 0.4\\,\\mathrm{K}\n$$\n四舍五入到四位有效数字，结果是 $0.4000\\,\\mathrm{K}$。\n\n对于 $\\alpha=0.5$：\n$$\n\\phi^{k+1} = (1-0.5)(0\\,\\mathrm{K}) + (0.5)(2\\,\\mathrm{K}) = (0.5)(0\\,\\mathrm{K}) + (0.5)(2\\,\\mathrm{K}) = 0\\,\\mathrm{K} + 1.0\\,\\mathrm{K} = 1.0\\,\\mathrm{K}\n$$\n四舍五入到四位有效数字，结果是 $1.000\\,\\mathrm{K}$。\n\n对于 $\\alpha=0.9$：\n$$\n\\phi^{k+1} = (1-0.9)(0\\,\\mathrm{K}) + (0.9)(2\\,\\mathrm{K}) = (0.1)(0\\,\\mathrm{K}) + (0.9)(2\\,\\mathrm{K}) = 0\\,\\mathrm{K} + 1.8\\,\\mathrm{K} = 1.8\\,\\mathrm{K}\n$$\n四舍五入到四位有效数字，结果是 $1.800\\,\\mathrm{K}$。\n\n第三，我们分析松弛因子 $\\alpha$ 对收敛性的影响。设第 $k$ 次迭代的误差定义为 $e^{k} = \\phi^{k} - \\phi^{\\infty}$。欠松弛迭代格式为：\n$$\n\\phi^{k+1} = (1-\\alpha)\\phi^{k} + \\alpha G(\\phi^{k})\n$$\n给定 $G(\\phi)$ 在解 $\\phi^{\\infty}$ 附近的局部线性化：\n$$\nG(\\phi^{k}) \\approx \\phi^{\\infty} + \\lambda(\\phi^{k} - \\phi^{\\infty})\n$$\n其中 $|\\lambda|1$。将其代入迭代格式：\n$$\n\\phi^{k+1} \\approx (1-\\alpha)\\phi^{k} + \\alpha[\\phi^{\\infty} + \\lambda(\\phi^{k} - \\phi^{\\infty})]\n$$\n为了找到连续误差之间的关系，我们从两边减去 $\\phi^{\\infty}$。注意 $\\phi^{\\infty}$ 可以写成 $(1-\\alpha)\\phi^{\\infty} + \\alpha\\phi^{\\infty}$。\n$$\n\\phi^{k+1} - \\phi^{\\infty} \\approx [(1-\\alpha)\\phi^{k} - (1-\\alpha)\\phi^{\\infty}] + [\\alpha\\phi^{\\infty} + \\alpha\\lambda(\\phi^{k} - \\phi^{\\infty}) - \\alpha\\phi^{\\infty}]\n$$\n$$\n\\phi^{k+1} - \\phi^{\\infty} \\approx (1-\\alpha)(\\phi^{k} - \\phi^{\\infty}) + \\alpha\\lambda(\\phi^{k} - \\phi^{\\infty})\n$$\n提出误差项 $(\\phi^k - \\phi^{\\infty}) = e^k$：\n$$\ne^{k+1} \\approx [(1-\\alpha) + \\alpha\\lambda] e^{k}\n$$\n因此，欠松弛格式的误差传播因子，我们称之为 $\\lambda_{\\alpha}$，是：\n$$\n\\lambda_{\\alpha} = (1-\\alpha) + \\alpha\\lambda\n$$\n为了使迭代收敛，该因子的绝对值必须小于 $1$，即 $|\\lambda_{\\alpha}|  1$。$|\\lambda_{\\alpha}|$ 的值决定了收敛速度；绝对值越小意味着收敛越快。因子 $\\lambda_{\\alpha}$ 是在 $\\lambda_{\\alpha}=1$（当 $\\alpha=0$ 时）和 $\\lambda_{\\alpha}=\\lambda$（当 $\\alpha=1$ 时）之间的线性插值。\n\n稳定性与速度之间的权衡如下：\n- **稳定性**：减小松弛因子 $\\alpha$（即使其小于 $1$）会使更新更加保守，因为 $\\phi^{k+1}$ 更接近于 $\\phi^{k}$。这会抑制大的振荡，并可以稳定一个原本发散或不稳定的迭代。对于一个非线性问题，其中局部有效 $\\lambda$ 可能会变化并暂时超过 $1$，一个小的 $\\alpha$ 提供了一个鲁棒性裕度，防止解发散。然而，这种增加的稳定性是有代价的。\n- **速度**：收敛速率由 $|\\lambda_{\\alpha}|$ 决定。\n    - 如果基本迭代已经是收敛且单调的 ($0  \\lambda  1$)，那么对于任何 $\\alpha \\in (0,1)$，我们有 $\\lambda  \\lambda_{\\alpha}  1$。在这种情况下，欠松弛（$\\alpha  1$）会减慢收敛速度，而不使用松弛（$\\alpha=1$）时达到最快速率。\n    - 如果基本迭代是收敛且振荡的（$-1  \\lambda  0$），可能存在一个最优松弛因子 $\\alpha_{\\text{opt}} = \\frac{1}{1-\\lambda}$，它使得 $\\lambda_{\\alpha}=0$。由于 $-1  \\lambda  0$，我们有 $1/2  \\alpha_{\\text{opt}}  1$。因此使用 $\\alpha  1$ 可以加速收敛。\n    - 总的来说，选择一个小的 $\\alpha$ 会使 $|\\lambda_{\\alpha}|$ 更接近 $1$（因为当 $\\alpha \\to 0$ 时 $\\lambda_{\\alpha}$ 趋近于 $1$），这对应于慢收敛。选择一个较大的 $\\alpha$（接近 $1$）会使 $\\lambda_{\\alpha}$ 趋向于 $\\lambda$，如果基本迭代表现良好，这可能会更快，但如果表现不佳，则风险更高。\n\n总之，松弛因子 $\\alpha$ 是一个控制参数，用于平衡收敛速度和迭代稳定性这两个相互竞争的需求。小的 $\\alpha$ 偏向于稳定性而非速度，而大的 $\\alpha$ 偏向于速度，但可能带来不稳定的风险。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.4000  1.000  1.800\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "迭代法的真正威力体现在处理非线性问题上，例如涉及热辐射的方程。本练习将带你从纸笔分析走向实际编程。你将编写一个程序，使用逐次代换法结合欠松弛技术来求解一个非线性能量平衡方程，从而将抽象的公式转化为可工作的算法。这个编程实践将让你对从初始猜测到最终收敛判断的整个迭代流程有更坚实的掌握 。",
            "id": "3983935",
            "problem": "考虑一个处于稳态的单一集总热节点，它通过一个线性化路径和一个辐射路径进行热交换。根据稳态热力学第一定律，所有传入和传出的热流率之和为零。将线性路径建模为与温度成正比，辐射路径建模为与温度的四次方成正比，标量能量平衡可以写成\n$$\na\\,T + b\\,T^{4} = c,\n$$\n其中 $a>0$ 和 $b>0$ 是常数，$T$ 是未知温度。常数 $c>0$ 代表净规定的热输入。定义残差函数\n$$\nR(T) \\equiv a\\,T + b\\,T^{4} - c.\n$$\n对此标量方程实现带有欠松弛的逐次代换法（不动点法）。使用欠松弛的定义思想：在每次迭代中，通过将当前迭代值代入所有非线性项并求解所得的关于主未知数的线性方程，来计算一个无约束更新量，然后将当前迭代值和该无约束更新量以松弛因子 $\\alpha \\in (0,1]$ 进行凸组合，形成下一个迭代值。在整个过程中使用固定的松弛因子 $\\alpha = 0.3$。设收敛度量为相对残差\n$$\nr_k \\equiv \\frac{\\lvert R(T_k)\\rvert}{\\lvert c \\rvert},\n$$\n当 $r_k  10^{-6}$ 时，宣告收敛。迭代次数计为达到第一个满足收敛准则的迭代值所需的欠松弛更新步数。如果初始猜测值 $T_0$ 已经满足准则，则报告迭代次数为零。如果方法在最多 $10^{6}$ 次迭代内未能收敛，或者迭代值变为非有限数，则该情况报告整数 $-1$。\n\n您的任务是编写一个程序，对于下面测试套件中的每一组参数，使用上述算法，返回在 $\\alpha=0.3$ 的条件下达到容差所需的迭代次数。所有参数 $a$、$b$、$c$ 和 $T_0$ 都是以一致单位给出的正实数；所要求的答案是迭代次数，因此是无单位的整数。\n\n测试套件（每个案例是一个元组 $(a,b,c,T_0)$）：\n1. $(a,b,c,T_0) = (25.0,\\;5.0\\times 10^{-8},\\;1000.0,\\;300.0)$\n2. $(a,b,c,T_0) = (100.0,\\;1.0\\times 10^{-12},\\;20000.0,\\;200.0)$\n3. $(a,b,c,T_0) = (2.0,\\;1.0\\times 10^{-7},\\;500.0,\\;50.0)$\n4. $(a,b,c,T_0) = (10.0,\\;5.0\\times 10^{-8},\\;1000.0,\\;10.0)$\n5. $(a,b,c,T_0) = (1.0\\times 10^{-3},\\;5.0\\times 10^{-8},\\;1000.0,\\;300.0)$\n\n最终输出格式：您的程序应生成单行输出，其中包含五个结果，形式为用方括号括起来的逗号分隔列表，无空格，例如 $[n_1,n_2,n_3,n_4,n_5]$，其中每个 $n_i$ 是对应测试用例的整数迭代次数，如果方法在规定规则下未收敛，则为 $-1$。",
            "solution": "该问题要求实现一种带有欠松弛的逐次代换法，以求解一个表示热节点稳态能量平衡的标量非线性方程。控制方程由下式给出：\n$$\naT + bT^4 = c\n$$\n其中 $T$ 是绝对温度，$a$、$b$ 和 $c$ 是表示系统物理性质的正数常数。这些常数为 $a > 0$、$b > 0$ 和 $c > 0$。\n\n任务是找出对于几组不同的参数，指定的数值方案收敛所需的迭代次数。\n\n首先，我们将所述的迭代算法形式化。该方法的核心是在每一步都对该方程进行线性化。设 $T_k$ 为第 $k$ 次迭代时的温度。问题陈述中说明，无约束更新量（此处记为 $T_{k+1}^*$）是通过“将当前迭代值代入所有非线性项并求解所得的关于主未知数的线性方程”来找到的。在方程 $aT + bT^4 - c = 0$ 中，唯一的非线性项是 $bT^4$。基于当前迭代值 $T_k$，将此项视为一个常数源项，我们为 $T_{k+1}^*$ 建立一个线性方程：\n$$\na T_{k+1}^* + b T_k^4 = c\n$$\n求解该方程得到 $T_{k+1}^*$ 的无约束更新量：\n$$\nT_{k+1}^* = \\frac{c - b T_k^4}{a}\n$$\n然后，通过欠松弛形成下一个迭代值 $T_{k+1}$，欠松弛被定义为当前迭代值 $T_k$ 和无约束更新量 $T_{k+1}^*$ 的凸组合。使用松弛因子 $\\alpha \\in (0, 1]$，更新规则为：\n$$\nT_{k+1} = (1 - \\alpha) T_k + \\alpha T_{k+1}^*\n$$\n将 $T_{k+1}^*$ 的表达式代入此方程，得到完整的迭代公式：\n$$\nT_{k+1} = (1 - \\alpha) T_k + \\alpha \\left( \\frac{c - b T_k^4}{a} \\right)\n$$\n问题指定了固定的松弛因子 $\\alpha = 0.3$。\n\n对于给定的一组参数 $(a, b, c, T_0)$，寻找迭代次数的算法如下：\n\n1.  **初始化**：设置参数 $a$、$b$、$c$ 和初始猜测值 $T_0$。设置松弛因子 $\\alpha = 0.3$、收敛容差 $\\epsilon = 10^{-6}$ 以及最大迭代次数 $N_{\\text{max}} = 10^6$。设迭代计数器为 $k=0$，当前温度为 $T_k = T_0$。\n\n2.  **初始收敛性检查**：计算残差函数 $R(T_k) = aT_k + bT_k^4 - c$。收敛性由相对残差 $r_k = \\frac{|R(T_k)|}{|c|}$ 来衡量。由于给定 $c > 0$，这可简化为 $r_k = \\frac{|R(T_k)|}{c}$。如果 $r_0  \\epsilon$，则初始猜测值已足够精确，过程终止，迭代次数为 $0$。\n\n3.  **迭代循环**：如果初始猜测值不满足收敛准则，则开始迭代循环， $k = 1, 2, 3, \\dots, N_{\\text{max}}$。\n    a.  将当前迭代值存储为 $T_{k-1}$。\n    b.  使用更新规则计算下一个迭代值 $T_k$：\n        $$\n        T_k = (1 - \\alpha) T_{k-1} + \\alpha \\left( \\frac{c - b T_{k-1}^4}{a} \\right)\n        $$\n    c.  **失败检查**：计算出 $T_k$ 后，检查它是否已变为非有限数（例如无穷大或 NaN）。如果迭代发散，例如由于计算 $T_{k-1}^4$ 时发生溢出，就可能出现这种情况。如果 $T_k$ 是非有限数，则方法失败。过程终止，并报告结果为 $-1$。\n    d.  **收敛性检查**：计算新迭代值的相对残差 $r_k = \\frac{|aT_k + bT_k^4 - c|}{c}$。\n    e.  如果 $r_k  \\epsilon$，则解已收敛。过程终止，并报告当前迭代次数 $k$ 作为结果。\n\n4.  **最大迭代次数检查**：如果循环完成（即 $k$ 达到 $N_{\\text{max}}$）而未满足收敛准则，则该方法未能在允许的迭代次数内收敛。过程终止，并报告结果为 $-1$。\n\n将实现此完整算法并将其应用于所提供的五个测试用例。计算必须使用具有足够精度的浮点算术执行，以处理给定的参数值，并尽可能避免过早的下溢或上溢。使用 `numpy.float64` 适合此任务。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _solve_single_case(a_in, b_in, c_in, T_0_in):\n    \"\"\"\n    Solves a single case of the thermal balance problem using successive\n    substitution with under-relaxation.\n    \"\"\"\n    # Use numpy.float64 for robust floating-point arithmetic\n    a = np.float64(a_in)\n    b = np.float64(b_in)\n    c = np.float64(c_in)\n    T_k = np.float64(T_0_in)\n\n    alpha = np.float64(0.3)\n    tolerance = np.float64(1e-6)\n    max_iterations = 1000000\n\n    # Define residual function for convenience\n    def R(T):\n        # Handle potential overflow in T**4\n        try:\n            T_pow4 = T**4\n        except OverflowError:\n            return np.inf\n        if not np.isfinite(T_pow4):\n            # This indicates T is too large, causing overflow.\n            # Return non-finite to be caught as a failure condition.\n            return np.inf\n        return a * T + b * T_pow4 - c\n\n    # Initial a-priori check for convergence at k=0\n    # The problem specifies |c| in the denominator, and c > 0.\n    residual_0 = R(T_k)\n    if not np.isfinite(residual_0):\n        return -1\n        \n    rel_residual_0 = np.abs(residual_0) / c\n    if rel_residual_0  tolerance:\n        return 0\n\n    # Iteration loop\n    for k in range(1, max_iterations + 1):\n        T_prev = T_k\n\n        # Step 1: Compute unconstrained update T_star\n        # The term T_prev**4 can overflow if T_prev becomes very large\n        try:\n            T_prev_pow4 = T_prev**4\n        except OverflowError:\n            return -1 # Iteration diverged, causing overflow\n        if not np.isfinite(T_prev_pow4):\n            return -1 # Iteration diverged, causing overflow\n\n        T_star = (c - b * T_prev_pow4) / a\n\n        # Step 2: Compute the new iterate T_k with under-relaxation\n        T_k = (np.float64(1.0) - alpha) * T_prev + alpha * T_star\n        \n        # Check if the new iterate is finite\n        if not np.isfinite(T_k):\n            return -1 # Iteration has produced a non-finite value\n\n        # Step 3: Check for convergence\n        residual_k = R(T_k)\n        if not np.isfinite(residual_k):\n            # T_k itself may be finite, but R(T_k) can overflow\n            return -1\n\n        rel_residual_k = np.abs(residual_k) / c\n        if rel_residual_k  tolerance:\n            return k\n\n    # If the loop finishes, the method failed to converge within max_iterations\n    return -1\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (a, b, c, T_0)\n        (25.0, 5.0e-8, 1000.0, 300.0),\n        (100.0, 1.0e-12, 20000.0, 200.0),\n        (2.0, 1.0e-7, 500.0, 50.0),\n        (10.0, 5.0e-8, 1000.0, 10.0),\n        (1.0e-3, 5.0e-8, 1000.0, 300.0)\n    ]\n\n    results = []\n    for case in test_cases:\n        iteration_count = _solve_single_case(*case)\n        results.append(iteration_count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solver\nsolve()\n\n```"
        }
    ]
}