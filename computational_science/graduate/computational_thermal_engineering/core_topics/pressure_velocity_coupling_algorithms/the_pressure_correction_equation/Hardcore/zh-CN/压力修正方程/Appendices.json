{
    "hands_on_practices": [
        {
            "introduction": "压力泊松方程是不可压流体计算中的核心。本练习将指导您从第一性原理出发，在一个简化的一维通道模型中，通过有限体积法推导压力修正方程的离散形式。通过这个过程 ()，您将亲手构建连接质量守恒与最终线性系统系数的关键环节，加深对压力场如何确保无散速度场的理解。",
            "id": "3993952",
            "problem": "在一个长度为 $L$、横截面积均匀为 $A$ 的一维通道中，使用包含 $N$ 个相等控制体积的同位网格有限体积法，模拟了密度为常数 $\\rho$ 的牛顿流体的等温、不可压缩流动。能量方程是解耦的，不进行求解，且流动仅考虑沿 $x$ 方向。推导的基本依据是不可压缩流的质量守恒，$\\nabla \\cdot \\mathbf{u} = 0$，以及来自不可压缩纳维-斯托克斯方程的动量平衡，其中对流和扩散采用显式处理，而对新时刻的压力采用隐式处理。使用时间步长为 $\\Delta t$ 的后向欧拉时间步进格式将解从时间层 $n$ 推进到 $n+1$。\n\n应用了分数步（投影）法：首先，通过求解在时间层 $n+1$ 不含压力梯度的动量方程，获得一个预测速度场 $\\mathbf{u}^{*}$；然后引入一个压力修正量 $p'$，使得修正后的速度 $\\mathbf{u}^{n+1} = \\mathbf{u}^{*} - \\frac{\\Delta t}{\\rho} \\nabla p'$ 在时间层 $n+1$ 满足不可压缩连续性方程。这产生了一个泊松型的压力修正方程。该区域被离散为 $N$ 个宽度为 $\\Delta x = L/N$ 的均匀控制体积，其中压力 $p'$ 存储在单元中心，面心梯度由二阶中心差分近似，面速度 $u^{*}_{i\\pm 1/2}$ 用于计算离散散度。\n\n对于索引为 $i$ 的内部控制体积，推导三对角形式的离散压力修正方程，\n$$\na_{P} \\, p'_{i} = a_{E} \\, p'_{i+1} + a_{W} \\, p'_{i-1} + b_{i},\n$$\n其中 $a_{P}$、$a_{E}$ 和 $a_{W}$ 是线性系统系数，$b_{i}$ 是来自预测速度散度的贡献项。仅使用基本定律和所述的离散化假设，根据横截面积 $A$ 和均匀单元宽度 $\\Delta x$，确定内部单元对角系数 $a_{P}$ 的符号表达式。将最终答案表示为封闭形式的解析表达式。无需四舍五入，最终方框内的答案不应包含单位。",
            "solution": "问题陈述被评估为有效，因为它描述了计算流体动力学中一个标准的、适定的问题，基于已建立的科学原理，并且没有矛盾或含糊之处。\n\n离散压力修正方程的推导始于不可压缩流的分数步（投影）法的基本关系。新时间步的修正速度场 $\\mathbf{u}^{n+1}$ 必须满足不可压缩流体的连续性方程：\n$$\n\\nabla \\cdot \\mathbf{u}^{n+1} = 0\n$$\n修正速度与预测速度 $\\mathbf{u}^{*}$ 和压力修正量 $p'$ 的关系由所提供的公式给出：\n$$\n\\mathbf{u}^{n+1} = \\mathbf{u}^{*} - \\frac{\\Delta t}{\\rho} \\nabla p'\n$$\n其中 $\\Delta t$ 是时间步长，$\\rho$ 是恒定的流体密度。\n\n将第二个方程代入第一个方程，得到连续的压力修正方程：\n$$\n\\nabla \\cdot \\left( \\mathbf{u}^{*} - \\frac{\\Delta t}{\\rho} \\nabla p' \\right) = 0\n$$\n由于 $\\Delta t$ 和 $\\rho$ 是常数，散度算子可以分配：\n$$\n\\nabla \\cdot \\mathbf{u}^{*} - \\frac{\\Delta t}{\\rho} \\nabla \\cdot (\\nabla p') = 0\n$$\n这可以重排为关于压力修正量 $p'$ 的泊松方程：\n$$\n\\nabla^2 p' = \\frac{\\rho}{\\Delta t} \\nabla \\cdot \\mathbf{u}^{*}\n$$\n这里，$\\nabla^2$ 是拉普拉斯算子，即 $\\nabla \\cdot \\nabla$。\n\n为使用有限体积法离散该方程，我们在一个通用的内部控制体积 $CV_i$ 上对其进行积分。该控制体积具有均匀的宽度 $\\Delta x$ 和恒定的横截面积 $A$，因此其体积为 $V_P = A \\Delta x$。\n$$\n\\int_{CV_i} \\nabla^2 p' \\, dV = \\int_{CV_i} \\frac{\\rho}{\\Delta t} \\nabla \\cdot \\mathbf{u}^{*} \\, dV\n$$\n对等式两边应用散度定理，即 $\\int_V (\\nabla \\cdot \\mathbf{F}) \\, dV = \\oint_S (\\mathbf{F} \\cdot \\mathbf{n}) \\, dS$。对于一维情况，面积分简化为对控制体积东（$e$）面和西（$w$）面的求和，这两个面分别位于 $x_{i+1/2}$ 和 $x_{i-1/2}$。每个面的面积为 $A$。\n\n左侧（LHS）变为：\n$$\n\\int_{CV_i} \\nabla \\cdot (\\nabla p') \\, dV = \\oint_{S_i} (\\nabla p' \\cdot \\mathbf{n}) \\, dS = \\left[ A \\left( \\frac{\\partial p'}{\\partial x} \\right) \\right]_{e} - \\left[ A \\left( \\frac{\\partial p'}{\\partial x} \\right) \\right]_{w}\n$$\n问题指定面心梯度由二阶中心差分近似。东（$e$）面上的梯度使用单元中心值 $p'_{i+1}$ 和 $p'_{i}$ 进行近似，西（$w$）面上的梯度使用 $p'_{i}$ 和 $p'_{i-1}$ 进行近似：\n$$\n\\left( \\frac{\\partial p'}{\\partial x} \\right)_{e} \\approx \\frac{p'_{i+1} - p'_{i}}{\\Delta x}\n$$\n$$\n\\left( \\frac{\\partial p'}{\\partial x} \\right)_{w} \\approx \\frac{p'_{i} - p'_{i-1}}{\\Delta x}\n$$\n将这些近似值代入左侧：\n$$\n\\text{LHS} = A \\left( \\frac{p'_{i+1} - p'_{i}}{\\Delta x} \\right) - A \\left( \\frac{p'_{i} - p'_{i-1}}{\\Delta x} \\right) = \\frac{A}{\\Delta x} (p'_{i+1} - 2p'_{i} + p'_{i-1})\n$$\n积分方程的右侧（RHS）为：\n$$\n\\text{RHS} = \\frac{\\rho}{\\Delta t} \\int_{CV_i} \\nabla \\cdot \\mathbf{u}^{*} \\, dV = \\frac{\\rho}{\\Delta t} \\oint_{S_i} (\\mathbf{u}^{*} \\cdot \\mathbf{n}) \\, dS = \\frac{\\rho}{\\Delta t} \\left( [A u^{*}]_{e} - [A u^{*}]_{w} \\right)\n$$\n其中 $u^{*}_{e}$ 和 $u^{*}_{w}$ 是面心预测速度（给定为 $u^{*}_{i+1/2}$ 和 $u^{*}_{i-1/2}$）。\n\n令左侧和右侧相等：\n$$\n\\frac{A}{\\Delta x} (p'_{i+1} - 2p'_{i} + p'_{i-1}) = \\frac{\\rho A}{\\Delta t} (u^{*}_{i+1/2} - u^{*}_{i-1/2})\n$$\n我们现在必须将此方程重排为问题中指定的目标形式：\n$$\na_{P} \\, p'_{i} = a_{E} \\, p'_{i+1} + a_{W} \\, p'_{i-1} + b_{i}\n$$\n从我们推导的方程中，分离出包含 $p'_{i}$ 的项：\n$$\n-\\frac{2A}{\\Delta x} p'_{i} = - \\frac{A}{\\Delta x} p'_{i+1} - \\frac{A}{\\Delta x} p'_{i-1} + \\frac{\\rho A}{\\Delta t} (u^{*}_{i+1/2} - u^{*}_{i-1/2})\n$$\n将整个方程乘以 $-1$，以使 $p'_i$ 的系数为正：\n$$\n\\frac{2A}{\\Delta x} p'_{i} = \\frac{A}{\\Delta x} p'_{i+1} + \\frac{A}{\\Delta x} p'_{i-1} - \\frac{\\rho A}{\\Delta t} (u^{*}_{i+1/2} - u^{*}_{i-1/2})\n$$\n此方程现在与目标形式匹配。问题陈述中说明 $b_{i}$ 是来自预测速度散度的贡献项，并且系数 $a_P, a_E, a_W$ 应仅用 $A$ 和 $\\Delta x$ 表示。这种独特的代数排列将各项划分如下：\n$$\na_{P} = \\frac{2A}{\\Delta x}\n$$\n$$\na_{E} = \\frac{A}{\\Delta x}\n$$\n$$\na_{W} = \\frac{A}{\\Delta x}\n$$\n$$\nb_{i} = - \\frac{\\rho A}{\\Delta t} (u^{*}_{i+1/2} - u^{*}_{i-1/2})\n$$\n此形式满足所有条件，特别是 $a_P$、$a_E$ 和 $a_W$ 仅依赖于几何参数 $A$ 和 $\\Delta x$，而物理参数 $\\rho$ 和时间步长 $\\Delta t$ 被吸收到源项 $b_i$ 中。\n\n因此，内部单元的对角系数为：\n$$\na_{P} = \\frac{2A}{\\Delta x}\n$$",
            "answer": "$$\n\\boxed{\\frac{2A}{\\Delta x}}\n$$"
        },
        {
            "introduction": "在同位网格上求解压力与速度时，会遇到“棋盘格”压力振荡问题，这是一种非物理的数值失稳现象。Rhie-Chow插值格式是解决此问题的经典方法。本练习 () 将通过傅里叶分析这一强大的工具，让您从数学上揭示Rhie-Chow插值如何有效地抑制高频振荡模式，从而确保压力场的光滑性和物理真实性。",
            "id": "3993953",
            "problem": "考虑一个长度为 $L$ 的一维、周期性、均匀离散化区域，该区域包含 $N$ 个间距为 $h = L/N$ 的配置控制体，流体密度 $\\rho$ 恒定，且为不可压缩流。在半隐式压力关联方程算法 (SIMPLE) 中执行压力修正步骤，并使用 Rhie–Chow 插值在配置网格上计算面法向速度。Rhie–Chow 插值通过添加一个源于离散化动量方程的、基于压力差的项来修正单元 $i$ 和 $i+1$ 之间面上的法向速度，而其他非压力贡献项则被聚合在一个插值项中。将单元中心 $i$ 处的压力记为 $p_i$，并将面 $i+1/2$ 上由压力引起的面法向速度贡献建模为 $u_{i+1/2}^{p} = -\\delta\\,(p_{i+1} - p_i)$，其中 $\\delta > 0$ 是一个由离散化动量算子的对角占优性和网格度量决定的常数。假设对面法向速度的所有非压力贡献项要么在压力修正方程的散度项中被抵消，要么不影响压力模式耦合的分析。\n\n从不可压缩流的质量守恒及其离散散度形式出发，推导作用于压力场的线性算子 $L$，该算子仅由 Rhie–Chow 插值中压力差对法向速度的贡献产生。在均匀网格上，通过考虑形式为 $p_i = \\hat{p}\\,\\exp(\\mathrm{i} k x_i)$（其中 $x_i = i h$，波数为 $k$）的压力模态，进行傅里叶（法向模态）分析。确定归一化傅里叶符号 $\\sigma(k)$，使得 $L p_i = \\left(\\frac{\\delta}{h}\\right)\\sigma(k)\\,p_i$ 成立。\n\n最后，计算以 $k h = \\pi$ 为特征的棋盘格模态所对应的归一化符号。将最终答案表示为单个实数。无需四舍五入，且最终值不应附加任何物理单位，因为所求符号根据其构造是无量纲的。",
            "solution": "推导始于不可压缩流的质量守恒原理。在一维情况下，连续性方程的微分形式为 $\\frac{du}{dx} = 0$。对于配置网格，我们将有限体积法应用于以节点 $i$ 为中心的控制体，该控制体从面 $i-\\frac{1}{2}$ 延伸到面 $i+\\frac{1}{2}$。通过对控制体内的散度进行积分并应用散度定理，可以得到连续性方程的离散形式，结果如下：\n$$\n\\frac{u_{i+1/2} - u_{i-1/2}}{h} = 0\n$$\n其中 $u_{i+1/2}$ 和 $u_{i-1/2}$ 是控制体面上的速度，$h$ 是均匀的网格间距。\n\n问题陈述指出，我们只考虑由压力引起的面法向速度贡献，该贡献由 Rhie-Chow 插值模型给出：\n$$\nu_{i+1/2}^{p} = -\\delta\\,(p_{i+1} - p_i)\n$$\n其中 $p_i$ 是单元中心 $i$ 处的压力，$\\delta > 0$ 是一个常数。通过将索引 $i$ 移至 $i-1$ 可以得到项 $u_{i-1/2}^{p}$：\n$$\nu_{i-1/2}^{p} = -\\delta\\,(p_i - p_{i-1})\n$$\n将这些与压力相关的速度代入离散连续性方程，即可得到作用于压力场 $p$ 的线性算子 $L$。该算子构成了压力修正泊松方程的左侧。我们将 $L p_i$ 定义为该速度场的离散散度：\n$$\nL p_i = \\frac{u_{i+1/2}^{p} - u_{i-1/2}^{p}}{h}\n$$\n代入面速度的表达式：\n$$\nL p_i = \\frac{1}{h} \\left[ (-\\delta\\,(p_{i+1} - p_i)) - (-\\delta\\,(p_i - p_{i-1})) \\right]\n$$\n提出常数 $-\\frac{\\delta}{h}$：\n$$\nL p_i = -\\frac{\\delta}{h} \\left[ (p_{i+1} - p_i) - (p_i - p_{i-1}) \\right]\n$$\n化简方括号内的表达式，得到离散拉普拉斯算子模板：\n$$\nL p_i = -\\frac{\\delta}{h} (p_{i+1} - 2p_i + p_{i-1})\n$$\n这就是推导出的作用于压力场的线性算子 $L$。\n\n接下来，我们通过考虑形式为 $p_i = \\hat{p}\\,\\exp(\\mathrm{i} k x_i)$（其中 $x_i = i h$）的压力模态来进行傅里叶（法向模态）分析。为了找到 $L$ 在此模态上的作用，我们首先用 $p_i$ 来表示 $p_{i+1}$ 和 $p_{i-1}$：\n$$\np_{i+1} = \\hat{p}\\,\\exp(\\mathrm{i} k x_{i+1}) = \\hat{p}\\,\\exp(\\mathrm{i} k (x_i + h)) = \\hat{p}\\,\\exp(\\mathrm{i} k x_i)\\,\\exp(\\mathrm{i} k h) = p_i\\,\\exp(\\mathrm{i} k h)\n$$\n$$\np_{i-1} = \\hat{p}\\,\\exp(\\mathrm{i} k x_{i-1}) = \\hat{p}\\,\\exp(\\mathrm{i} k (x_i - h)) = \\hat{p}\\,\\exp(\\mathrm{i} k x_i)\\,\\exp(-\\mathrm{i} k h) = p_i\\,\\exp(-\\mathrm{i} k h)\n$$\n将这些代入 $L p_i$ 的表达式中：\n$$\nL p_i = -\\frac{\\delta}{h} (p_i\\,\\exp(\\mathrm{i} k h) - 2p_i + p_i\\,\\exp(-\\mathrm{i} k h))\n$$\n提出 $p_i$：\n$$\nL p_i = -\\frac{\\delta}{h} p_i (\\exp(\\mathrm{i} k h) - 2 + \\exp(-\\mathrm{i} k h))\n$$\n使用欧拉恒等式 $\\cos(\\theta) = \\frac{\\exp(\\mathrm{i}\\theta) + \\exp(-\\mathrm{i}\\theta)}{2}$，我们可以写出 $\\exp(\\mathrm{i} k h) + \\exp(-\\mathrm{i} k h) = 2\\cos(k h)$。括号中的表达式变为：\n$$\n\\exp(\\mathrm{i} k h) - 2 + \\exp(-\\mathrm{i} k h) = 2\\cos(k h) - 2 = -2(1 - \\cos(k h))\n$$\n将此代回 $L p_i$ 的方程中：\n$$\nL p_i = -\\frac{\\delta}{h} p_i [-2(1 - \\cos(k h))]\n$$\n$$\nL p_i = \\frac{2\\delta}{h} (1 - \\cos(k h)) p_i\n$$\n问题要求我们找到由关系式 $L p_i = \\left(\\frac{\\delta}{h}\\right)\\sigma(k)\\,p_i$ 定义的归一化傅里叶符号 $\\sigma(k)$。将此定义与我们推导出的结果进行比较，我们可以确定 $\\sigma(k)$：\n$$\n\\left(\\frac{\\delta}{h}\\right)\\sigma(k)\\,p_i = \\frac{2\\delta}{h} (1 - \\cos(k h)) p_i\n$$\n从两边消去公因子 $\\left(\\frac{\\delta}{h}\\right)p_i$，我们得到归一化符号的表达式：\n$$\n\\sigma(k) = 2(1 - \\cos(k h))\n$$\n最后，我们必须计算该符号在棋盘格模态下的值，该模态的特征是无量纲波数 $k h = \\pi$。该模态对应于网格上可以分辨的最高频率，相邻单元的压力值符号交替，即 $p_i \\propto (-1)^i$。将 $k h = \\pi$ 代入 $\\sigma(k)$ 的表达式中：\n$$\n\\sigma(k)\\rvert_{kh=\\pi} = 2(1 - \\cos(\\pi))\n$$\n由于 $\\cos(\\pi) = -1$，计算结果为：\n$$\n\\sigma(k)\\rvert_{kh=\\pi} = 2(1 - (-1)) = 2(1 + 1) = 4\n$$\n这个结果表明离散算子对棋盘格模态的响应最强，这正是 Rhie-Chow 插值所期望的行为——通过创建一个良态的压力泊松方程来防止这种伪压力振荡。",
            "answer": "$$ \\boxed{4} $$"
        },
        {
            "introduction": "建立压力修正方程后，下一步是高效地求解由此产生的大型线性方程组。本实践练习 () 将带您进入计算流体力学求解器的核心，通过编写预条件共轭梯度（PCG）法来求解压力系统。更重要的是，您将学习如何设计和解读收敛诊断指标，如残差和收敛判据，这是确保任何实际CFD模拟结果可靠性的必备技能。",
            "id": "3993963",
            "problem": "考虑在具有均匀单元体积的一维、同位有限体积网格上的牛顿流体稳态不可压缩流动。每个控制体的离散质量守恒要求跨越其各个面的质量通量的代数和为零。从应用于有限体积的质量守恒和牛顿第二定律出发，并采用分离式求解策略（首先求解动量方程以获得临时速度场），必须修正压力场以强制满足离散连续性方程。这将产生一个关于压力修正变量的线性、对称正定离散系统，该系统通过通量修正项将相邻的控制体耦合起来。数值任务是高效地求解此线性系统，并设计基于残差及其归一化的诊断方法来量化收敛性。\n\n您的任务有两方面：\n- 从第一性原理出发，推导由修正质量通量需满足离散连续性方程这一要求所产生的压力修正方程的结构，并为由此产生的对称正定线性系统的迭代求解定义适当的残差和收敛准则。\n- 实现一个程序，该程序针对一组代表一维网格上压力修正方程的小型对称正定系统，使用带简单预条件子的迭代方法求解修正变量，同时计算残差和收敛性的诊断信息。程序必须输出一行聚合了所有给定测试用例的诊断结果。\n\n使用以下定义来指导您的诊断设计：\n- 将修正变量的线性系统抽象地写为 $A x = b$，其中 $A \\in \\mathbb{R}^{n \\times n}$ 是对称正定矩阵， $x \\in \\mathbb{R}^{n}$ 是未知的压力修正向量，而 $b \\in \\mathbb{R}^{n}$ 则代表了由临时通量引起的离散质量不平衡。将第 $k$ 次迭代的残差定义为 $r^{(k)} = b - A x^{(k)}$。\n- 定义未归一化残差范数为 $R_{2}^{(k)} = \\lVert r^{(k)} \\rVert_{2}$，归一化残差为 $N_{2}^{(k)} = \\dfrac{\\lVert r^{(k)} \\rVert_{2}}{\\max\\left(\\lVert b \\rVert_{2}, \\varepsilon\\right)}$，其中 $\\varepsilon = 10^{-30}$ 以避免除以零。\n- 为 $k \\geq 1$ 定义单调性比率为 $q^{(k)} = \\dfrac{\\lVert r^{(k)} \\rVert_{2}}{\\lVert r^{(k-1)} \\rVert_{2}}$。使用一个发散检测器，如果在至少连续 $\\kappa$ 次迭代中 $q^{(k)} > \\gamma$，则标记为不收敛，其中 $\\gamma > 1$ 和 $\\kappa \\in \\mathbb{N}$ 根据每个测试用例指定。\n\n当且仅当在达到最大迭代次数之前，同时满足 $R_{2}^{(k)} \\leq \\tau_{\\text{abs}}$ 和 $N_{2}^{(k)} \\leq \\tau_{\\text{rel}}$ 时，才宣告收敛。否则，返回不收敛。\n\n算法要求：\n- 使用带对角（Jacobi）预条件子 $M = \\operatorname{diag}(A)$ 的预条件共轭梯度（PCG）法求解每个系统。使用给定的 $x^{(0)}$ 进行初始化。在每次迭代中，更新解、残差、搜索方向，并计算 $R_{2}^{(k)}$、$N_{2}^{(k)}$ 和 $q^{(k)}$。应用发散检测器参数 $(\\gamma, \\kappa)$。\n\n测试套件：\n在以下三个独立的测试用例上实现您的求解器和诊断。每个用例都是一个包含 $A$、$b$ 和求解器参数的线性系统。所有数值都是无量纲的。\n\n- 测试用例 1（良态，“理想路径”）：\n  - $n = 5$,\n  - $$A = \\begin{bmatrix}\n  2  -1  0  0  0\\\\\n  -1  2  -1  0  0\\\\\n  0  -1  2  -1  0\\\\\n  0  0  -1  2  -1\\\\\n  0  0  0  -1  2\n  \\end{bmatrix},\\quad\n  b = \\begin{bmatrix} 1\\\\ -2\\\\ 3\\\\ -2\\\\ 1 \\end{bmatrix},\\quad\n  x^{(0)} = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix}.$$\n  - 收敛参数: $\\tau_{\\text{abs}} = 10^{-12}$, $\\tau_{\\text{rel}} = 10^{-12}$, $\\gamma = 1.20$, $\\kappa = 3$, $k_{\\max} = 200$。\n\n- 测试用例 2（接近病态的三对角系统，测试鲁棒性）：\n  - $n = 6$,\n  - $$A = \\begin{bmatrix}\n  2  -0.999  0  0  0  0\\\\\n  -0.999  2  -0.999  0  0  0\\\\\n  0  -0.999  2  -0.999  0  0\\\\\n  0  0  -0.999  2  -0.999  0\\\\\n  0  0  0  -0.999  2  -0.999\\\\\n  0  0  0  0  -0.999  2\n  \\end{bmatrix},\\quad\n  b = \\begin{bmatrix} 1\\\\ -1\\\\ 1\\\\ -1\\\\ 1\\\\ -1 \\end{bmatrix},\\quad\n  x^{(0)} = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix}.$$\n  - 收敛参数: $\\tau_{\\text{abs}} = 10^{-12}$, $\\tau_{\\text{rel}} = 10^{-12}$, $\\gamma = 1.05$, $\\kappa = 4$, $k_{\\max} = 400$。\n\n- 测试用例 3（零右端项，测试立即收敛和归一化）：\n  - $n = 4$,\n  - $$A = \\begin{bmatrix}\n  2  -1  0  0\\\\\n  -1  2  -1  0\\\\\n  0  -1  2  -1\\\\\n  0  0  -1  2\n  \\end{bmatrix},\\quad\n  b = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix},\\quad\n  x^{(0)} = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix}.$$\n  - 收敛参数: $\\tau_{\\text{abs}} = 10^{-16}$, $\\tau_{\\text{rel}} = 10^{-16}$, $\\gamma = 1.10$, $\\kappa = 2$, $k_{\\max} = 50$。\n\n程序输出规范：\n- 对于每个测试用例，计算布尔收敛标志、直到终止时执行的迭代次数、最终的未归一化残差范数 $R_{2}^{(\\text{final})}$ 和最终的归一化残差 $N_{2}^{(\\text{final})}$。\n- 您的程序应生成单行输出，其中包含按测试用例顺序排列的结果，形式为逗号分隔的列表的列表，每个内部列表的格式为 $[\\text{converged}, \\text{iterations}, R_{2}^{(\\text{final})}, N_{2}^{(\\text{final})}]$。例如，输出格式必须与 $[[\\text{bool},\\text{int},\\text{float},\\text{float}],[\\text{bool},\\text{int},\\text{float},\\text{float}],[\\text{bool},\\text{int},\\text{float},\\text{float}]]$ 完全相同，不含多余的空格或文本。\n\n此处不涉及角度单位和物理单位；所有量均为无量纲。所提供的系统与在用于压力耦合方程组的半隐式方法（SIMPLE）的同位有限体积公式中产生的离散压力修正方程一致，但您必须仅基于给定的抽象线性代数公式来建立您的诊断和求解器。",
            "solution": "所提出的问题是有效的，因为它在科学上基于计算流体动力学的原理，数学上是适定的、客观的，并为其解决提供了完整且一致的数据和约束条件。任务是分析压力修正方程的结构，定义适当的收敛诊断方法，并为代表性的线性系统实现一个数值求解器。\n\n**1. 压力修正方程的第一性原理**\n\n在计算流体动力学中，分离式求解器，例如 SIMPLE（压力耦合方程组的半隐式方法）算法，通常用于求解离散化的不可压缩纳维-斯托克斯方程。这种方法将速度和压力的计算解耦，在迭代循环中顺序求解它们。\n\n起点是离散化的动量方程和连续性方程组。对于给定的控制体 $P$，动量方程可以抽象地写为：\n$$a_P \\mathbf{u}_P = \\sum_{nb} a_{nb} \\mathbf{u}_{nb} - V_P (\\nabla p)_d + \\mathbf{b}_u$$\n其中 $\\mathbf{u}_P$ 是单元 $P$ 中心处的速度矢量，求和项遍历相邻单元 $nb$，$a$ 系数源于对流项和扩散项的离散化，$V_P$ 是单元体积，$(\\nabla p)_d$ 是压力梯度的离散形式，$\\mathbf{b}_u$ 包含所有其他源项。对于不可压缩流，连续性方程或质量守恒方程为：\n$$\\sum_{f} (\\mathbf{u} \\cdot \\mathbf{n}) A_f = 0$$\n其中求和项遍历控制体的所有面 $f$，$\\mathbf{u}$ 是面上的速度，$\\mathbf{n}$ 是面的法向量，$A_f$ 是面的面积。\n\n分离式求解过程如下：\n1.  猜测一个压力场 $p^*$，或取自上一次迭代的结果。\n2.  求解动量方程，得到一个非无散度（即不满足连续性方程）的临时速度场 $\\mathbf{u}^*$：\n    $$a_P \\mathbf{u}_P^* = \\sum_{nb} a_{nb} \\mathbf{u}_{nb}^* - V_P (\\nabla p^*)_d + \\mathbf{b}_u$$\n3.  由于 $\\mathbf{u}^*$ 不满足离散连续性方程，它会为每个控制体 $P$ 产生一个净质量通量，或称为质量不平衡量 $\\dot{m}_P^*$：\n    $$\\dot{m}_P^* = \\sum_{f} \\rho (\\mathbf{u}^* \\cdot \\mathbf{n}) A_f \\neq 0$$\n4.  引入压力修正量 $p'$ 和速度修正量 $\\mathbf{u}'$，使得最终场 $p = p^* + p'$ 和 $\\mathbf{u} = \\mathbf{u}^* + \\mathbf{u}'$ 满足控制方程，其中最关键的是连续性方程。通过从 $\\mathbf{u}$ 的动量方程中减去 $\\mathbf{u}^*$ 的动量方程，并引入 SIMPLE 类方法中常见的近似，可以得到速度修正量和压力修正量梯度之间的简化关系。对于所指定的同位网格，这种关系可以在面上抽象为：\n    $$\\mathbf{u}'_f \\approx -d_f (\\nabla p')_d$$\n    其中 $d_f$ 是一个从动量方程系数推导出的系数。\n5.  然后使用此速度修正量来对最终速度场施加连续性约束：\n    $$\\sum_{f} \\rho (\\mathbf{u}^* \\cdot \\mathbf{n}) A_f + \\sum_{f} \\rho (\\mathbf{u}' \\cdot \\mathbf{n}) A_f = 0$$\n    代入 $\\mathbf{u}'_f$ 的表达式和 $\\dot{m}_P^*$ 的定义：\n    $$\\sum_{f} \\rho (-d_f (\\nabla p')_d \\cdot \\mathbf{n}) A_f = -\\dot{m}_P^*$$\n    该方程关联了相邻单元中的压力修正量 $p'$。对于具有单元 $i-1$、$i$ 和 $i+1$ 的一维网格，它离散化为如下形式：\n    $$C_{i,i-1} p'_{i-1} + C_{i,i} p'_i + C_{i,i+1} p'_{i+1} = -\\dot{m}_i^*$$\n    为所有控制体组合这些方程，会得到一个线性方程组 $A x = b$。在这里，$x$ 是每个单元的未知压力修正量 $p'$ 组成的向量；$b$ 是负质量不平衡量 $-\\dot{m}^*$ 组成的向量；$A$ 是系数矩阵。$A$ 的结构源于离散拉普拉斯算子，这使得它成为一个稀疏、对称且（在至少一个压力值作为边界条件固定的情况下）正定的矩阵。测试用例中提供的矩阵是一维域上这种结构的典型例子。\n\n**2. 求解器诊断和收敛准则**\n\n求解压力修正量 $x$ 的系统 $A x = b$ 是流体流动求解器每次外迭代的核心部分。由于必须重复执行此操作，因此需要一种高效的迭代方法。监控此内部线性代数迭代的收敛性至关重要。\n\n设 $x^{(k)}$ 为第 $k$ 次迭代时压力修正向量的近似解。\n-   **残差 ($r^{(k)}$)**：残差向量定义为 $r^{(k)} = b - A x^{(k)}$。它量化了每个控制体中方程的误差。在此物理背景下，$b$ 是来自临时速度场的质量不平衡量，而 $A x^{(k)}$ 是由当前压力修正猜测值 $x^{(k)}$ 所隐含的质量通量修正。因此，$r^{(k)}$ 代表每个控制体中的剩余质量不平衡量。求解器的目标是将此残差驱动至零。\n-   **未归一化残差范数 ($R_{2}^{(k)}$)**：残差的欧几里得范数或 L2 范数，$R_{2}^{(k)} = \\lVert r^{(k)} \\rVert_{2}$，将各个单元的不平衡量聚合成一个单一的、全局的标量度量，用以衡量离散连续性方程的满足程度。只有当这个绝对度量低于指定的容差时，即 $R_{2}^{(k)} \\leq \\tau_{\\text{abs}}$，才宣告收敛。\n-   **归一化残差 ($N_{2}^{(k)}$)**：归一化残差，$N_{2}^{(k)} = \\dfrac{\\lVert r^{(k)} \\rVert_{2}}{\\max\\left(\\lVert b \\rVert_{2}, \\varepsilon\\right)}$，提供了一个相对的收敛度量。它表示残差相对于其初始值 $\\lVert r^{(0)} \\rVert_{2} = \\lVert b \\rVert_{2}$（假设 $x^{(0)}=0$）的减小程度。这通常是比绝对残差更鲁棒的准则，因为它与问题的尺度无关。如果初始右端项 $b$ 为零，小参数 $\\varepsilon > 0$ 可防止除以零。收敛要求 $N_{2}^{(k)} \\leq \\tau_{\\text{rel}}$。\n-   **单调性比率 ($q^{(k)}$)**：为 $k \\geq 1$ 定义为 $q^{(k)} = \\dfrac{\\lVert r^{(k)} \\rVert_{2}}{\\lVert r^{(k-1)} \\rVert_{2}}$，该比率跟踪逐次迭代的收敛速率。对于一个表现良好的迭代方法，$q^{(k)} < 1$。如果 $q^{(k)} > 1$，则残差在增长，表明发散。发散检测器提供了一种实用的机制来终止失败或停滞的求解器，它在 $q^{(k)}>\\gamma$（其中 $\\gamma > 1$）连续出现 $\\kappa$ 次迭代时标记为不收敛。\n\n**3. 预条件共轭梯度（PCG）算法**\n\n共轭梯度法是求解线性系统 $A x = b$（其中 $A$ 是对称正定矩阵）的一种最优迭代算法。其收敛速率取决于 $A$ 的条件数。预处理是一种通过求解修正后的系统 $M^{-1}Ax = M^{-1}b$ 来改善条件数的技术，其中 $M$ 是预条件子矩阵。$M$ 应该是 $A$ 的一个易于求逆的近似。\n\n对于本问题，指定的预条件子是 Jacobi 预条件子，它就是 $A$ 的对角部分，即 $M = \\operatorname{diag}(A)$。对于这样的对角矩阵，其逆 $M^{-1}$ 的计算非常简单：$(M^{-1})_{ii} = 1/A_{ii}$。\n\n从初始猜测值 $x^{(0)}$ 开始求解 $A x = b$ 的 PCG 算法如下：\n\n1.  初始化迭代计数器 $k=0$。\n2.  计算初始残差：$r^{(0)} = b - A x^{(0)}$。\n3.  应用预条件子：求解 $M z^{(0)} = r^{(0)}$。对于 Jacobi 预条件子，即对每个分量 $i$ 计算 $z^{(0)}_i = r^{(0)}_i / A_{ii}$。\n4.  设置初始搜索方向：$p^{(0)} = z^{(0)}$。\n5.  计算 $\\rho_0 = (r^{(0)})^T z^{(0)}$。\n6.  开始迭代循环， $k = 0, 1, 2, \\dots, k_{\\max}-1$：\n    a. 计算矩阵-向量乘积：$\\mathbf{q}^{(k)} = A p^{(k)}$。\n    b. 计算步长：$\\alpha_k = \\rho_k / ((p^{(k)})^T \\mathbf{q}^{(k)})$。\n    c. 更新解：$x^{(k+1)} = x^{(k)} + \\alpha_k p^{(k)}$。\n    d. 更新残差：$r^{(k+1)} = r^{(k)} - \\alpha_k \\mathbf{q}^{(k)}$。这比 $r^{(k+1)} = b - A x^{(k+1)}$ 在数值上更稳定。\n    e. 使用 $r^{(k+1)}$ 对照 $\\tau_{\\text{abs}}$ 和 $\\tau_{\\text{rel}}$ 检查收敛性。如果收敛，则成功终止。\n    f. 使用单调性比率检查发散。如果检测到发散，则以失败告终。\n    g. 应用预条件子：求解 $M z^{(k+1)} = r^{(k+1)}$。对于 Jacobi 预条件子，即 $z^{(k+1)}_i = r^{(k+1)}_i / A_{ii}$。\n    h. 计算 $\\rho_{k+1} = (r^{(k+1)})^T z^{(k+1)}$。\n    i. 计算搜索方向的改进因子：$\\beta_k = \\rho_{k+1} / \\rho_k$。\n    j. 更新搜索方向：$p^{(k+1)} = z^{(k+1)} + \\beta_k p^{(k)}$。\n    k. 更新 $\\rho_k \\leftarrow \\rho_{k+1}$ 以用于下一次迭代。\n7.  如果循环完成但未收敛，则以失败告终。\n\n该算法与先前定义的诊断方法相结合，为求解测试套件中给出的压力修正系统提供了一种鲁棒且高效的方法。",
            "answer": "```python\nimport numpy as np\n\ndef solve_pressure_systems():\n    \"\"\"\n    Solves a set of linear systems representative of pressure correction equations\n    using the Preconditioned Conjugate Gradient (PCG) method with a Jacobi\n    preconditioner. It computes and returns convergence diagnostics.\n    The final output is a single string formatted as a list of lists.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"A\": np.array([\n                [2.0, -1.0, 0.0, 0.0, 0.0],\n                [-1.0, 2.0, -1.0, 0.0, 0.0],\n                [0.0, -1.0, 2.0, -1.0, 0.0],\n                [0.0, 0.0, -1.0, 2.0, -1.0],\n                [0.0, 0.0, 0.0, -1.0, 2.0]\n            ]),\n            \"b\": np.array([1.0, -2.0, 3.0, -2.0, 1.0]),\n            \"x0\": np.array([0.0, 0.0, 0.0, 0.0, 0.0]),\n            \"params\": {\"abs\": 1e-12, \"rel\": 1e-12, \"gamma\": 1.20, \"kappa\": 3, \"k_max\": 200}\n        },\n        {\n            \"A\": np.array([\n                [2.0, -0.999, 0.0, 0.0, 0.0, 0.0],\n                [-0.999, 2.0, -0.999, 0.0, 0.0, 0.0],\n                [0.0, -0.999, 2.0, -0.999, 0.0, 0.0],\n                [0.0, 0.0, -0.999, 2.0, -0.999, 0.0],\n                [0.0, 0.0, 0.0, -0.999, 2.0, -0.999],\n                [0.0, 0.0, 0.0, 0.0, -0.999, 2.0]\n            ]),\n            \"b\": np.array([1.0, -1.0, 1.0, -1.0, 1.0, -1.0]),\n            \"x0\": np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0]),\n            \"params\": {\"abs\": 1e-12, \"rel\": 1e-12, \"gamma\": 1.05, \"kappa\": 4, \"k_max\": 400}\n        },\n        {\n            \"A\": np.array([\n                [2.0, -1.0, 0.0, 0.0],\n                [-1.0, 2.0, -1.0, 0.0],\n                [0.0, -1.0, 2.0, -1.0],\n                [0.0, 0.0, -1.0, 2.0]\n            ]),\n            \"b\": np.array([0.0, 0.0, 0.0, 0.0]),\n            \"x0\": np.array([0.0, 0.0, 0.0, 0.0]),\n            \"params\": {\"abs\": 1e-16, \"rel\": 1e-16, \"gamma\": 1.10, \"kappa\": 2, \"k_max\": 50}\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        A, b, x = case[\"A\"], case[\"b\"], case[\"x0\"].copy()\n        params = case[\"params\"]\n        \n        tau_abs, tau_rel = params[\"abs\"], params[\"rel\"]\n        gamma, kappa, k_max = params[\"gamma\"], params[\"kappa\"], params[\"k_max\"]\n        \n        M_inv_diag = 1.0 / np.diag(A)\n\n        r = b - A @ x\n        r_norm_unnormalized = np.linalg.norm(r)\n        \n        b_norm = np.linalg.norm(b)\n        normalization_factor = max(b_norm, 1e-30)\n        r_norm_normalized = r_norm_unnormalized / normalization_factor\n\n        if r_norm_unnormalized = tau_abs and r_norm_normalized = tau_rel:\n            all_results.append([True, 0, r_norm_unnormalized, r_norm_normalized])\n            continue\n        \n        z = r * M_inv_diag\n        p = z.copy()\n        rho_old = r @ z\n        \n        divergence_counter = 0\n        prev_r_norm = r_norm_unnormalized\n        converged = False\n        k_iter = 0\n        \n        for k_iter in range(1, k_max + 1):\n            Ap = A @ p\n            alpha = rho_old / (p @ Ap)\n            \n            x += alpha * p\n            r -= alpha * Ap\n            \n            r_norm_unnormalized = np.linalg.norm(r)\n            r_norm_normalized = r_norm_unnormalized / normalization_factor\n            \n            monotonicity_ratio = r_norm_unnormalized / prev_r_norm if prev_r_norm > 0 else 0.0\n            if monotonicity_ratio > gamma:\n                divergence_counter += 1\n            else:\n                divergence_counter = 0\n            \n            if divergence_counter >= kappa:\n                converged = False\n                break\n                \n            prev_r_norm = r_norm_unnormalized\n            \n            if r_norm_unnormalized = tau_abs and r_norm_normalized = tau_rel:\n                converged = True\n                break\n\n            z = r * M_inv_diag\n            rho_new = r @ z\n            \n            if abs(rho_old)  1e-40:\n                converged = (r_norm_unnormalized = tau_abs and r_norm_normalized = tau_rel)\n                break\n\n            beta = rho_new / rho_old\n            p = z + beta * p\n            rho_old = rho_new\n        else:\n            converged = False\n            k_iter = k_max\n\n        all_results.append([converged, k_iter, r_norm_unnormalized, r_norm_normalized])\n    \n    # Format the output to exactly match [[bool,int,float,float],[bool,int,float,float],...]\n    output_str_parts = []\n    for res in all_results:\n        # Python's `True` stringifies to 'True', which is correct.\n        res_str = f\"[{res[0]},{res[1]},{res[2]},{res[3]}]\"\n        output_str_parts.append(res_str)\n    \n    final_output = f\"[{','.join(output_str_parts)}]\"\n    print(final_output)\n\nsolve_pressure_systems()\n```"
        }
    ]
}