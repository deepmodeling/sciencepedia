{
    "hands_on_practices": [
        {
            "introduction": "Before delving into the algorithms that solve the pressure-velocity coupling problem, it is crucial to understand why this coupling can be problematic in the first place. This exercise demonstrates the classic issue of \"checkerboard\" pressure oscillations that can arise on collocated grids, where all variables are stored at the same location. By performing a carefully designed numerical experiment , you will see firsthand how a simple collocated discretization can fail to detect these non-physical pressure modes, motivating the development of staggered grids and other advanced techniques.",
            "id": "3994267",
            "problem": "Consider the incompressible, isothermal, laminar flow of a Newtonian fluid in a two-dimensional channel in the absence of thermal gradients. The governing equations are the continuity equation and the momentum equation, stated respectively as\n$$\\nabla \\cdot \\mathbf{u} = 0,$$\n$$\\rho \\frac{\\partial \\mathbf{u}}{\\partial t} + \\rho (\\mathbf{u} \\cdot \\nabla)\\mathbf{u} = -\\nabla p + \\mu \\nabla^2 \\mathbf{u},$$\nwhere $\\mathbf{u} = (u,v)$ is the velocity field, $p$ is the pressure, $\\rho$ is the fluid density, and $\\mu$ is the dynamic viscosity. Under a pressure–velocity splitting (projection) viewpoint, the pressure is responsible for enforcing the continuity constraint by correcting a predicted velocity via\n$$\\mathbf{u}^{n+1} = \\mathbf{u}^{*} - \\frac{\\Delta t}{\\rho} \\nabla p,$$\nwhere $\\Delta t$ is the time increment, $\\mathbf{u}^{*}$ is the predicted velocity, and $\\mathbf{u}^{n+1}$ is the divergence-free corrected velocity. In a discrete setting, how $\\nabla p$ and $\\nabla \\cdot \\mathbf{u}$ are constructed depends on the grid arrangement. A naive collocated grid stores $u$, $v$, and $p$ at cell centers, approximating derivatives by central differences; a staggered grid (Marker-And-Cell (MAC) arrangement) stores $p$ at cell centers while $u$ and $v$ are stored at cell faces. It is well known in Computational Fluid Dynamics (CFD) that the naive collocated arrangement can admit spurious odd–even pressure modes (checkerboard oscillations), whereas staggered grids suppress them because face-centered fluxes directly sense cell-centered pressure differences.\n\nYour task is to derive and implement, from first principles, discrete operators for both arrangements and demonstrate numerically that a pure checkerboard pressure mode produces negligible mass-flux divergence on the naive collocated scheme (revealing decoupling), but non-negligible divergence on the staggered scheme (revealing coupling that suppresses oscillations). Treat the domain as a rectangular, uniform grid of size $N_x \\times N_y$ with spacings $\\Delta x$ and $\\Delta y$, and employ periodic boundary conditions in both directions to isolate interior coupling effects without boundary layers. Use a synthetic checkerboard pressure field\n$$p_{i,j} = p_0 (-1)^{i+j},$$\nwith amplitude $p_0$ (in $\\mathrm{Pa}$), and evaluate the divergence of the pressure-correction-induced velocity field for each scheme as follows:\n\n- For the naive collocated scheme:\n  - Place $u$, $v$, and $p$ at cell centers $(i,j)$.\n  - Approximate the cell-centered pressure gradients by central differences:\n    $$\\left(\\frac{\\partial p}{\\partial x}\\right)_{i,j} \\approx \\frac{p_{i+1,j} - p_{i-1,j}}{2\\Delta x}, \\quad \\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j} \\approx \\frac{p_{i,j+1} - p_{i,j-1}}{2\\Delta y}.$$\n  - Define the corrected cell-centered velocities:\n    $$u_{i,j}^{c} = -\\frac{\\Delta t}{\\rho}\\left(\\frac{\\partial p}{\\partial x}\\right)_{i,j}, \\quad v_{i,j}^{c} = -\\frac{\\Delta t}{\\rho}\\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j}.$$\n  - Construct face mass fluxes by naive linear interpolation of cell-centered velocities:\n    $$u_{i+\\frac{1}{2},j}^{c} = \\frac{u_{i,j}^{c} + u_{i+1,j}^{c}}{2}, \\quad v_{i,j+\\frac{1}{2}}^{c} = \\frac{v_{i,j}^{c} + v_{i,j+1}^{c}}{2}.$$\n  - Compute the cell-centered discrete divergence:\n    $$\\left(\\nabla \\cdot \\mathbf{u}^{c}\\right)_{i,j} \\approx \\frac{u_{i+\\frac{1}{2},j}^{c} - u_{i-\\frac{1}{2},j}^{c}}{\\Delta x} + \\frac{v_{i,j+\\frac{1}{2}}^{c} - v_{i,j-\\frac{1}{2}}^{c}}{\\Delta y}.$$\n\n- For the staggered MAC scheme:\n  - Place $p$ at cell centers $(i,j)$, $u$ at vertical faces $(i+\\frac{1}{2}, j)$, and $v$ at horizontal faces $(i, j+\\frac{1}{2})$.\n  - Approximate the face-centered pressure gradients by one-cell differences:\n    $$u_{i+\\frac{1}{2},j}^{s} = -\\frac{\\Delta t}{\\rho} \\frac{p_{i+1,j} - p_{i,j}}{\\Delta x}, \\quad v_{i,j+\\frac{1}{2}}^{s} = -\\frac{\\Delta t}{\\rho} \\frac{p_{i,j+1} - p_{i,j}}{\\Delta y}.$$\n  - Compute the cell-centered discrete divergence:\n    $$\\left(\\nabla \\cdot \\mathbf{u}^{s}\\right)_{i,j} \\approx \\frac{u_{i+\\frac{1}{2},j}^{s} - u_{i-\\frac{1}{2},j}^{s}}{\\Delta x} + \\frac{v_{i,j+\\frac{1}{2}}^{s} - v_{i,j-\\frac{1}{2}}^{s}}{\\Delta y}.$$\n\nDerive, using the above definitions and the synthetic $p_{i,j}$, why the collocated central differences yield $\\left(\\partial p / \\partial x\\right)_{i,j} = 0$ and $\\left(\\partial p / \\partial y\\right)_{i,j} = 0$ for the checkerboard mode, while the staggered face differences do not vanish, and hence the collocated divergence is negligible whereas the staggered divergence is non-negligible. To quantify the effect, define the root-mean-square (RMS) divergence for scheme $\\star \\in \\{c, s\\}$ as\n$$\\mathcal{D}_{\\star} = \\sqrt{\\frac{1}{N_x N_y} \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\left(\\nabla \\cdot \\mathbf{u}^{\\star}\\right)_{i,j}^2}.$$\nAs a suppression metric, report the dimensionless ratio\n$$\\mathcal{R} = \\frac{\\mathcal{D}_{s}}{\\mathcal{D}_{c} + \\varepsilon},$$\nwhere $\\varepsilon$ is a small positive number to avoid division by zero, chosen proportional to $\\mathcal{D}_{s}$ (e.g., $\\varepsilon = 10^{-16} \\mathcal{D}_{s}$). A large value of $\\mathcal{R}$ indicates that the staggered scheme strongly couples pressure to mass flux, thereby suppressing oscillations relative to the naive collocated scheme.\n\nPhysical units: take $p_0$ in $\\mathrm{Pa}$, $\\rho$ in $\\mathrm{kg/m^3}$, $\\Delta x$ and $\\Delta y$ in $\\mathrm{m}$, $\\Delta t$ in $\\mathrm{s}$. The output ratio $\\mathcal{R}$ is dimensionless.\n\nTest suite: run your program for the following parameter sets, each specified as $(N_x, N_y, \\Delta x, \\Delta y, \\rho, \\Delta t, p_0)$:\n- Case A (general case): $(32, 32, 1.0\\times 10^{-2}, 1.0\\times 10^{-2}, 1.0, 1.0\\times 10^{-3}, 1.0)$.\n- Case B (coarse grid edge case): $(8, 8, 1.0\\times 10^{-2}, 1.0\\times 10^{-2}, 1.0, 5.0\\times 10^{-4}, 1.0)$.\n- Case C (anisotropic channel aspect): $(64, 4, 5.0\\times 10^{-3}, 1.25\\times 10^{-2}, 1.0, 2.0\\times 10^{-3}, 1.0)$.\n\nYour program should produce a single line of output containing the three suppression ratios for Cases A, B, and C as a comma-separated list enclosed in square brackets (e.g., $[\\mathcal{R}_A,\\mathcal{R}_B,\\mathcal{R}_C]$). The output must be a list of floating-point numbers in decimal notation on that single line. No other text should be printed. Express all intermediate quantities internally in their proper units as specified; the final ratios are dimensionless.",
            "solution": "The problem at hand is a classic numerical experiment in Computational Fluid Dynamics (CFD) designed to illustrate the pressure-velocity coupling problem on different grid arrangements. Specifically, it contrasts a naive collocated grid, where all variables ($u$, $v$, $p$) are stored at cell centers, with a staggered Marker-And-Cell (MAC) grid, where scalar pressure $p$ is at cell centers while velocity components $u$ and $v$ are stored at cell faces. The core issue is that certain non-physical pressure oscillations, known as checkerboard modes, can exist undetected by the discrete operators of a naive collocated scheme, leading to numerical instabilities. A staggered grid, by its construction, correctly couples pressure gradients to mass fluxes, thereby preventing such spurious modes. We will demonstrate this analytically and then verify it numerically.\n\nThe analysis is performed on a synthetic checkerboard pressure field defined on a uniform $N_x \\times N_y$ grid with spacings $\\Delta x$ and $\\Delta y$. The pressure at the center of cell $(i,j)$ is given by\n$$p_{i,j} = p_0 (-1)^{i+j},$$\nwhere $p_0$ is the amplitude. The analysis relies on evaluating the divergence of the velocity field induced solely by the pressure correction step of a projection method, $\\mathbf{u}^{\\star} = -(\\Delta t / \\rho) \\nabla p$, where for simplicity we analyze the velocity field induced from a zero state. Periodic boundary conditions are assumed, and all test cases use even numbers for $N_x$ and $N_y$.\n\n### Analysis of the Naive Collocated Scheme\n\nIn the collocated scheme, all variables, including pressure $p$ and velocity components $u$ and $v$, are stored at the cell center $(i,j)$.\n\n1.  **Pressure Gradient Calculation**: The pressure gradient components are approximated at the cell center $(i,j)$ using central differences:\n    $$ \\left(\\frac{\\partial p}{\\partial x}\\right)_{i,j} \\approx \\frac{p_{i+1,j} - p_{i-1,j}}{2\\Delta x} \\quad \\text{and} \\quad \\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j} \\approx \\frac{p_{i,j+1} - p_{i,j-1}}{2\\Delta y}. $$\n    Substituting the checkerboard pressure field $p_{i,j} = p_0 (-1)^{i+j}$:\n    $$ \\frac{p_{i+1,j} - p_{i-1,j}}{2\\Delta x} = \\frac{p_0(-1)^{(i+1)+j} - p_0(-1)^{(i-1)+j}}{2\\Delta x} = \\frac{p_0(-1)^{i+j}}{2\\Delta x} \\left( (-1)^1 - (-1)^{-1} \\right) = \\frac{p_0(-1)^{i+j}}{2\\Delta x} (-1 - (-1)) = 0. $$\n    Similarly, for the $y$-gradient:\n    $$ \\frac{p_{i,j+1} - p_{i,j-1}}{2\\Delta y} = \\frac{p_0(-1)^{i+(j+1)} - p_0(-1)^{i+(j-1)}}{2\\Delta y} = \\frac{p_0(-1)^{i+j}}{2\\Delta y} \\left( (-1)^1 - (-1)^{-1} \\right) = 0. $$\n    This holds for all interior points and also at the boundaries due to the periodic conditions and the even number of grid cells in each direction. The $2\\Delta x$ central difference stencil is blind to the highest frequency (Nyquist) mode on the grid.\n\n2.  **Velocity Field and Divergence**: The pressure-correction-induced velocity components at the cell centers, denoted $\\mathbf{u}^c = (u^c, v^c)$, are:\n    $$ u_{i,j}^{c} = -\\frac{\\Delta t}{\\rho}\\left(\\frac{\\partial p}{\\partial x}\\right)_{i,j} = 0, \\quad v_{i,j}^{c} = -\\frac{\\Delta t}{\\rho}\\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j} = 0. $$\n    The velocities are zero at all cell centers.\n\n3.  **Mass Flux and Divergence**: The scheme constructs mass fluxes at cell faces by averaging the cell-centered velocities. For the face at $(i+\\frac{1}{2}, j)$:\n    $$ u_{i+\\frac{1}{2},j}^{c} = \\frac{u_{i,j}^{c} + u_{i+1,j}^{c}}{2} = \\frac{0 + 0}{2} = 0. $$\n    Similarly, $v_{i,j+\\frac{1}{2}}^{c} = 0$. Since all face fluxes are zero, the discrete divergence at cell $(i,j)$ is identically zero:\n    $$ \\left(\\nabla \\cdot \\mathbf{u}^{c}\\right)_{i,j} = \\frac{u_{i+\\frac{1}{2},j}^{c} - u_{i-\\frac{1}{2},j}^{c}}{\\Delta x} + \\frac{v_{i,j+\\frac{1}{2}}^{c} - v_{i,j-\\frac{1}{2}}^{c}}{\\Delta y} = 0. $$\n    Therefore, the root-mean-square (RMS) divergence for the collocated scheme is $\\mathcal{D}_{c} = 0$. In a numerical implementation, this value will be subject to floating-point error but should be negligible (on the order of machine precision).\n\n### Analysis of the Staggered (MAC) Scheme\n\nIn the staggered scheme, pressure $p$ is at the cell center $(i,j)$, the $u$-velocity component is at vertical faces $(i+\\frac{1}{2}, j)$, and the $v$-velocity component is at horizontal faces $(i, j+\\frac{1}{2})$.\n\n1.  **Face Velocity Calculation**: The pressure gradient is evaluated directly across a single cell to compute the velocity at the face. For the $u$-velocity at face $(i+\\frac{1}{2}, j)$, denoted $u^s_{i+\\frac{1}{2},j}$:\n    $$ u_{i+\\frac{1}{2},j}^{s} = -\\frac{\\Delta t}{\\rho} \\frac{p_{i+1,j} - p_{i,j}}{\\Delta x} = -\\frac{\\Delta t}{\\rho \\Delta x} \\left[ p_0(-1)^{(i+1)+j} - p_0(-1)^{i+j} \\right] $$\n    $$ = -\\frac{\\Delta t p_0(-1)^{i+j}}{\\rho \\Delta x} \\left[ (-1)^1 - 1 \\right] = \\frac{2 \\Delta t p_0}{\\rho \\Delta x} (-1)^{i+j}. $$\n    Similarly, for the $v$-velocity at face $(i, j+\\frac{1}{2})$:\n    $$ v_{i,j+\\frac{1}{2}}^{s} = -\\frac{\\Delta t}{\\rho} \\frac{p_{i,j+1} - p_{i,j}}{\\Delta y} = \\frac{2 \\Delta t p_0}{\\rho \\Delta y} (-1)^{i+j}. $$\n    Unlike the collocated scheme, the staggered arrangement produces a non-zero velocity field in response to the checkerboard pressure.\n\n2.  **Divergence Calculation**: The discrete divergence at cell center $(i,j)$ is:\n    $$ \\left(\\nabla \\cdot \\mathbf{u}^{s}\\right)_{i,j} = \\frac{u_{i+\\frac{1}{2},j}^{s} - u_{i-\\frac{1}{2},j}^{s}}{\\Delta x} + \\frac{v_{i,j+\\frac{1}{2}}^{s} - v_{i,j-\\frac{1}{2}}^{s}}{\\Delta y}. $$\n    We need the velocity at the left face, $u_{i-\\frac{1}{2},j}^{s}$, which is calculated as:\n    $$ u_{i-\\frac{1}{2},j}^{s} = \\frac{2 \\Delta t p_0}{\\rho \\Delta x} (-1)^{(i-1)+j} = -\\frac{2 \\Delta t p_0}{\\rho \\Delta x} (-1)^{i+j}. $$\n    Substituting into the divergence expression:\n    $$ \\frac{u_{i+\\frac{1}{2},j}^{s} - u_{i-\\frac{1}{2},j}^{s}}{\\Delta x} = \\frac{1}{\\Delta x} \\left[ \\frac{2 \\Delta t p_0}{\\rho \\Delta x} (-1)^{i+j} - \\left(-\\frac{2 \\Delta t p_0}{\\rho \\Delta x} (-1)^{i+j}\\right) \\right] = \\frac{4 \\Delta t p_0}{\\rho (\\Delta x)^2} (-1)^{i+j}. $$\n    The term for the $y$-direction is analogous. The total divergence is:\n    $$ \\left(\\nabla \\cdot \\mathbf{u}^{s}\\right)_{i,j} = \\left[ \\frac{4 \\Delta t p_0}{\\rho (\\Delta x)^2} + \\frac{4 \\Delta t p_0}{\\rho (\\Delta y)^2} \\right] (-1)^{i+j} = \\frac{4 \\Delta t p_0}{\\rho} \\left( \\frac{1}{(\\Delta x)^2} + \\frac{1}{(\\Delta y)^2} \\right) (-1)^{i+j}. $$\n    This expression represents a discrete Laplacian of the pressure field, confirming that the staggered divergence operator is strongly coupled to pressure variations. The divergence is clearly non-zero.\n\n3.  **RMS Divergence**: To find the RMS divergence $\\mathcal{D}_s$, we square the divergence at each cell, average over the grid, and take the square root. The term $(-1)^{i+j}$ squares to $1$, making the squared divergence constant across all cells:\n    $$ \\left( \\left(\\nabla \\cdot \\mathbf{u}^{s}\\right)_{i,j} \\right)^2 = \\left[ \\frac{4 \\Delta t p_0}{\\rho} \\left( \\frac{1}{(\\Delta x)^2} + \\frac{1}{(\\Delta y)^2} \\right) \\right]^2. $$\n    The RMS value is simply the absolute value of the constant factor:\n    $$ \\mathcal{D}_{s} = \\frac{4 \\Delta t p_0}{\\rho} \\left( \\frac{1}{(\\Delta x)^2} + \\frac{1}{(\\Delta y)^2} \\right). $$\n    This is a non-zero, non-negligible value.\n\n### Suppression Metric\n\nThe suppression metric $\\mathcal{R}$ is defined as $\\mathcal{R} = \\mathcal{D}_{s} / (\\mathcal{D}_{c} + \\varepsilon)$. Since we found that $\\mathcal{D}_{c}$ is analytically zero (and numerically negligible), the denominator is dominated by the regularization term $\\varepsilon = 10^{-16} \\mathcal{D}_{s}$.\n$$ \\mathcal{R} = \\frac{\\mathcal{D}_{s}}{\\mathcal{D}_{c} + 10^{-16} \\mathcal{D}_{s}} \\approx \\frac{\\mathcal{D}_{s}}{10^{-16} \\mathcal{D}_{s}} = 10^{16}. $$\nA very large value for $\\mathcal{R}$ signifies that the staggered grid generates a strong divergence (a strong correction signal) in response to a checkerboard pressure mode, whereas the naive collocated grid generates virtually no signal. This ability to \"see\" and thus correct high-frequency pressure oscillations is the fundamental advantage of the staggered grid arrangement.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_suppression_ratio(Nx, Ny, dx, dy, rho, dt, p0):\n    \"\"\"\n    Derives and implements discrete operators for collocated and staggered grids\n    to demonstrate the pressure-velocity decoupling problem for a checkerboard\n    pressure field.\n\n    Args:\n        Nx (int): Number of grid cells in the x-direction.\n        Ny (int): Number of grid cells in the y-direction.\n        dx (float): Grid spacing in the x-direction.\n        dy (float): Grid spacing in the y-direction.\n        rho (float): Fluid density.\n        dt (float): Time step.\n        p0 (float): Amplitude of the pressure field.\n\n    Returns:\n        float: The suppression ratio R = D_s / (D_c + epsilon).\n    \"\"\"\n\n    # Create grid and synthetic checkerboard pressure field\n    # Grid indices i (cols), j (rows) correspond to x, y directions.\n    # Numpy arrays are (row, col) so we map (j, i).\n    # axis=0 corresponds to j (y), axis=1 corresponds to i (x)\n    i_indices, j_indices = np.meshgrid(np.arange(Nx), np.arange(Ny))\n    p = p0 * (-1.0)**(i_indices + j_indices)\n\n    # --- Naive Collocated Scheme ---\n\n    # 1. Calculate pressure gradients at cell centers using central differences.\n    #    Periodic boundaries are handled by np.roll.\n    dp_dx = (np.roll(p, -1, axis=1) - np.roll(p, 1, axis=1)) / (2.0 * dx)\n    dp_dy = (np.roll(p, -1, axis=0) - np.roll(p, 1, axis=0)) / (2.0 * dy)\n\n    # 2. Calculate pressure-correction-induced velocities at cell centers.\n    u_c = - (dt / rho) * dp_dx\n    v_c = - (dt / rho) * dp_dy\n\n    # 3. Interpolate cell-centered velocities to faces.\n    # u_face_c at index (j, i) corresponds to face (i+1/2, j).\n    u_face_c = (u_c + np.roll(u_c, -1, axis=1)) / 2.0\n    v_face_c = (v_c + np.roll(v_c, -1, axis=0)) / 2.0\n\n    # 4. Compute cell-centered divergence from face fluxes.\n    # div_x component is (u_face(i+1/2) - u_face(i-1/2)) / dx.\n    # u_face(i-1/2, j) is u_face_c rolled by 1 along axis=1.\n    div_c_x = (u_face_c - np.roll(u_face_c, 1, axis=1)) / dx\n    div_c_y = (v_face_c - np.roll(v_face_c, 1, axis=0)) / dy\n    div_c = div_c_x + div_c_y\n\n    # 5. Calculate RMS divergence for the collocated scheme.\n    D_c = np.sqrt(np.mean(div_c**2))\n\n    # --- Staggered MAC Scheme ---\n\n    # 1. Calculate pressure-correction-induced velocities directly at faces.\n    # u_s at index (j, i) corresponds to face (i+1/2, j).\n    u_s = - (dt / rho) * (np.roll(p, -1, axis=1) - p) / dx\n    v_s = - (dt / rho) * (np.roll(p, -1, axis=0) - p) / dy\n\n    # 2. Compute cell-centered divergence from face velocities.\n    # div_x at (i,j) is (u_s(i+1/2,j) - u_s(i-1/2,j)) / dx.\n    # u_s(i-1/2,j) is u_s rolled by 1 along axis=1.\n    div_s_x = (u_s - np.roll(u_s, 1, axis=1)) / dx\n    div_s_y = (v_s - np.roll(v_s, 1, axis=0)) / dy\n    div_s = div_s_x + div_s_y\n\n    # 3. Calculate RMS divergence for the staggered scheme.\n    D_s = np.sqrt(np.mean(div_s**2))\n\n    # --- Suppression Metric ---\n    # As per the problem, use a small epsilon proportional to D_s.\n    epsilon = 1e-16 * D_s\n    R = D_s / (D_c + epsilon)\n    \n    return R\n    \ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Test suite: (Nx, Ny, dx, dy, rho, dt, p0)\n    test_cases = [\n        # Case A (general case)\n        (32, 32, 1.0e-2, 1.0e-2, 1.0, 1.0e-3, 1.0),\n        # Case B (coarse grid edge case)\n        (8, 8, 1.0e-2, 1.0e-2, 1.0, 5.0e-4, 1.0),\n        # Case C (anisotropic channel aspect)\n        (64, 4, 5.0e-3, 1.25e-2, 1.0, 2.0e-3, 1.0)\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, Ny, dx, dy, rho, dt, p0 = case\n        result = calculate_suppression_ratio(Nx, Ny, dx, dy, rho, dt, p0)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The projection method stands as one of the most fundamental and effective strategies for enforcing the incompressibility constraint in CFD. This practice provides a hands-on implementation of a single time step of this method for the benchmark lid-driven cavity flow . You will compute an intermediate velocity field that does not satisfy continuity, then solve a pressure Poisson equation to find the pressure field required to project this velocity onto a divergence-free space, quantitatively measuring the method's success by tracking the divergence of the velocity field.",
            "id": "3994286",
            "problem": "Consider the incompressible flow in a $2\\text{D}$ square driven cavity over the domain $[0,1]\\times[0,1]$ with a uniform grid of $N_x=N_y=N$ points, uniform spacing $h=1/(N-1)$, and the velocity field $\\mathbf{u}=(u,v)$ discretized at cell centers. The lid at the top boundary has a prescribed horizontal velocity $u=U_0$ and vertical velocity $v=0$, while all other walls enforce no-slip conditions $u=0$ and $v=0$. Assume nondimensional variables with fluid density equal to $1$.\n\nThe objective is to compute the pressure field using a projection method to address the pressure–velocity coupling problem and to measure the discrete divergence norm before and after the projection. The fundamental equations are the incompressible continuity equation $\\nabla\\cdot\\mathbf{u}=0$ and the momentum equation $\\partial_t\\mathbf{u}+\\text{advection}=-\\nabla p + \\nu \\nabla^2 \\mathbf{u}$, where $\\nu$ is the kinematic viscosity and $p$ is the pressure.\n\nThe algorithm for one time step proceeds as follows, starting from an initial velocity $\\mathbf{u}^n=\\mathbf{0}$ in the interior:\n\n1. Compute the intermediate velocity $\\mathbf{u}^\\star=\\mathbf{u}^n+\\nu\\,\\Delta t\\,\\nabla^2\\mathbf{u}^n$ using a second-order central-difference $5$-point stencil for each component. Enforce the velocity boundary conditions $u=U_0$ and $v=0$ on the top boundary and $u=0$, $v=0$ on the remaining walls both before and after this diffusion update.\n\n2. Compute the discrete divergence of $\\mathbf{u}^\\star$ in the interior by central differences,\n   $$\\left(\\nabla\\cdot\\mathbf{u}^\\star\\right)_{i,j}=\\frac{u^\\star_{i+1,j}-u^\\star_{i-1,j}}{2h}+\\frac{v^\\star_{i,j+1}-v^\\star_{i,j-1}}{2h},$$\n   for $i=1,\\dots,N-2$ and $j=1,\\dots,N-2$, and set the divergence to $0$ at the boundary indices. Define the discrete $L^2$ norm of the divergence over interior points as\n   $$\\|\\nabla\\cdot\\mathbf{u}^\\star\\|_{2}=\\left(h^2 \\sum_{i=1}^{N-2}\\sum_{j=1}^{N-2} \\left(\\nabla\\cdot\\mathbf{u}^\\star\\right)_{i,j}^2\\right)^{1/2}.$$\n\n3. Solve the pressure Poisson equation derived from the projection method,\n   $$\\nabla^2 p^{n+1}=\\frac{1}{\\Delta t}\\,\\nabla\\cdot\\mathbf{u}^\\star,$$\n   with homogeneous Neumann boundary conditions $\\partial p/\\partial n=0$ at all walls, and a single reference constraint $p^{n+1}=0$ at the center grid point to remove the nullspace. Use a second-order finite-difference approximation of $\\nabla^2$ employing a $5$-point stencil in the interior, and one-sided mirror conditions at boundaries that enforce $\\partial p/\\partial n=0$, such as using $p_{\\text{ghost}}=p_{\\text{adjacent}}$ leading to boundary-normal second derivatives of the form $2\\,(p_{\\text{adjacent}}-p_{\\text{boundary}})/h^2$.\n\n4. Project the intermediate velocity to enforce incompressibility by\n   $$\\mathbf{u}^{n+1}=\\mathbf{u}^\\star-\\Delta t\\,\\nabla p^{n+1},$$\n   where gradients are computed by second-order central differences in the interior and one-sided differences at the boundaries; then reapply the velocity boundary conditions $u=U_0$ and $v=0$ at the top lid and $u=0$, $v=0$ elsewhere.\n\n5. Compute the discrete divergence norm $\\|\\nabla\\cdot\\mathbf{u}^{n+1}\\|_2$ over the interior using the same definition as in step $2$.\n\nAll quantities are nondimensional; report the divergence norms as dimensionless real numbers. Implement the above method for the following test suite of parameter values:\n- Test $1$: $N=33$, $\\Delta t=0.001$, $\\nu=0.001$, $U_0=1.0$.\n- Test $2$: $N=17$, $\\Delta t=0.0005$, $\\nu=0.1$, $U_0=1.0$.\n- Test $3$: $N=33$, $\\Delta t=0.002$, $\\nu=0.001$, $U_0=0.0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a two-element list of the form $[\\|\\nabla\\cdot\\mathbf{u}^\\star\\|_2,\\|\\nabla\\cdot\\mathbf{u}^{n+1}\\|_2]$. For example, the output format must be\n$$[[a_1,b_1],[a_2,b_2],[a_3,b_3]],$$\nwith each $a_k$ and $b_k$ being real numbers corresponding to the norms for Test $k$.",
            "solution": "The problem statement has been critically validated and is deemed sound. It outlines a standard numerical exercise in computational fluid dynamics, specifically the implementation of a single time step of a projection method for the incompressible Navier-Stokes equations, simplified to the incompressible Stokes equations to isolate the pressure-velocity coupling mechanism. The problem is self-contained, scientifically grounded, and well-posed, providing all necessary equations, boundary conditions, discretization schemes, and parameters.\n\nThe solution proceeds by implementing the specified algorithm step-by-step. All mathematical entities are represented in LaTeX as required.\n\n### 1. Discretization and Initial State\nThe domain is a square $[0,1] \\times [0,1]$, discretized by a uniform collocated grid with $N_x = N_y = N$ points. The grid spacing is $h = 1/(N-1)$. The grid indices $(i,j)$ range from $0$ to $N-1$ in both $x$ and $y$ directions, where $i$ corresponds to the $x$-direction and $j$ to the $y$-direction. The velocity field is $\\mathbf{u} = (u,v)$ and the pressure is $p$.\n\nThe initial velocity field at time $t^n$ is given as $\\mathbf{u}^n = (u^n, v^n) = \\mathbf{0}$ for all interior points. The boundary conditions are enforced on $\\mathbf{u}^n$:\n-   Top boundary ($j=N-1$): $u^n_{i,N-1} = U_0$ for $i \\in [0, N-1]$, $v^n_{i,N-1} = 0$. Note that at the corners, the no-slip condition from the side walls takes precedence, so $u^n_{0,N-1}=0$ and $u^n_{N-1,N-1}=0$.\n-   Other boundaries (bottom, left, right): No-slip condition, $u^n=0$ and $v^n=0$.\n\n### 2. Intermediate Velocity Computation\nThe first step is to compute an intermediate velocity field, $\\mathbf{u}^\\star$, by applying a diffusion step to the initial velocity field $\\mathbf{u}^n$. The advection term is omitted as per the problem's formulation for this step.\n$$\n\\mathbf{u}^\\star = \\mathbf{u}^n + \\nu \\Delta t \\nabla^2 \\mathbf{u}^n\n$$\nThe Laplacian, $\\nabla^2$, is discretized using a second-order central-difference 5-point stencil for the interior points, i.e., for $i,j \\in [1, N-2]$:\n$$\n(\\nabla^2 u^n)_{i,j} = \\frac{u^n_{i+1,j} + u^n_{i-1,j} + u^n_{i,j+1} + u^n_{i,j-1} - 4u^n_{i,j}}{h^2}\n$$\nA similar expression holds for $(\\nabla^2 v^n)_{i,j}$. The intermediate velocities $u^\\star$ and $v^\\star$ are computed for all interior points. Following the computation, the prescribed velocity boundary conditions are re-enforced on the $\\mathbf{u}^\\star$ field.\n\n### 3. Divergence of Intermediate Velocity\nThe discrete divergence of the intermediate velocity field $\\mathbf{u}^\\star$ is computed at the interior grid points $(i,j)$ for $i,j \\in [1, N-2]$ using second-order central differences:\n$$\n(\\nabla \\cdot \\mathbf{u}^\\star)_{i,j} = \\frac{u^\\star_{i+1,j} - u^\\star_{i-1,j}}{2h} + \\frac{v^\\star_{i,j+1} - v^\\star_{i,j-1}}{2h}\n$$\nThe divergence is set to zero at all boundary points. The discrete $L^2$ norm of this divergence field is then computed over the interior of the domain:\n$$\n\\|\\nabla \\cdot \\mathbf{u}^\\star\\|_2 = \\left( h^2 \\sum_{i=1}^{N-2} \\sum_{j=1}^{N-2} \\left( (\\nabla \\cdot \\mathbf{u}^\\star)_{i,j} \\right)^2 \\right)^{1/2}\n$$\nThis value quantifies the extent to which the intermediate velocity field fails to satisfy the incompressibility constraint.\n\n### 4. Pressure Poisson Equation\nTo enforce incompressibility on the final velocity field, a pressure field $p^{n+1}$ is found by solving the Pressure Poisson Equation (PPE):\n$$\n\\nabla^2 p^{n+1} = \\frac{1}{\\Delta t} \\nabla \\cdot \\mathbf{u}^\\star\n$$\nThis equation is subject to homogeneous Neumann boundary conditions, $\\partial p / \\partial n = 0$, on all boundaries, where $n$ is the direction normal to the boundary. The Laplacian operator on the left-hand side is discretized using a 5-point stencil that incorporates these boundary conditions. This results in a system of linear equations $A\\mathbf{p} = \\mathbf{b}$, where $\\mathbf{p}$ is a vector of the unknown pressure values at all $N \\times N$ grid points, $A$ is the matrix representing the discretized Laplacian operator, and $\\mathbf{b}$ is the vector representing the source term $(1/\\Delta t) \\nabla \\cdot \\mathbf{u}^\\star$.\n\nFor an interior point $(i,j)$, the equation is:\n$$\n\\frac{p_{i+1,j} + p_{i-1,j} + p_{i,j+1} + p_{i,j-1} - 4p_{i,j}}{h^2} = \\frac{(\\nabla \\cdot \\mathbf{u}^\\star)_{i,j}}{\\Delta t}\n$$\nFor a boundary point, the stencil is modified to reflect the $\\partial p / \\partial n = 0$ condition. For example, at a bottom boundary point $(i,0)$, for $i \\in [1, N-2]$, the condition $\\partial p/\\partial y = 0$ is implemented using a ghost point $p_{i,-1} = p_{i,1}$, leading to the discretized equation:\n$$\n\\frac{p_{i+1,0} + p_{i-1,0} + 2p_{i,1} - 4p_{i,0}}{h^2} = \\frac{(\\nabla \\cdot \\mathbf{u}^\\star)_{i,0}}{\\Delta t}\n$$\nSimilar expressions are derived for all other boundary and corner points. The resulting matrix $A$ is singular. To obtain a unique solution, a reference pressure is set by enforcing $p^{n+1}=0$ at the center grid point $((N-1)/2, (N-1)/2)$. This is achieved by replacing the corresponding row in the matrix system with the constraint equation. The resulting non-singular linear system is solved for the pressure field $p^{n+1}$.\n\n### 5. Velocity Projection\nThe intermediate velocity $\\mathbf{u}^\\star$ is projected onto the space of divergence-free fields to yield the final, divergence-free velocity field $\\mathbf{u}^{n+1}$:\n$$\n\\mathbf{u}^{n+1} = \\mathbf{u}^\\star - \\Delta t \\nabla p^{n+1}\n$$\nThe pressure gradient $\\nabla p^{n+1}$ is computed using second-order central differences in the interior and first-order one-sided differences at the boundaries. For an interior point $(i,j)$:\n$$\n(\\nabla p^{n+1})_{i,j} = \\left( \\frac{p^{n+1}_{i+1,j} - p^{n+1}_{i-1,j}}{2h}, \\frac{p^{n+1}_{i,j+1} - p^{n+1}_{i,j-1}}{2h} \\right)\n$$\nAt the boundaries, for example at the left boundary $i=0$:\n$$\n\\left(\\frac{\\partial p^{n+1}}{\\partial x}\\right)_{0,j} = \\frac{p^{n+1}_{1,j} - p^{n+1}_{0,j}}{h}\n$$\nAfter computing $u^{n+1}$ and $v^{n+1}$, the velocity boundary conditions are reapplied to finalize the velocity field for the new time step.\n\n### 6. Divergence of Corrected Velocity\nFinally, the discrete divergence of the corrected velocity field, $\\nabla \\cdot \\mathbf{u}^{n+1}$, and its $L^2$ norm, $\\|\\nabla \\cdot \\mathbf{u}^{n+1}\\|_2$, are computed over the interior points using the same formulas as in Step 3. This norm is expected to be significantly smaller than $\\|\\nabla \\cdot \\mathbf{u}^\\star\\|_2$, demonstrating the efficacy of the projection method in enforcing the incompressibility constraint.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that iterates through test cases and prints results.\n    \"\"\"\n    test_cases = [\n        # (N, dt, nu, U0)\n        (33, 0.001, 0.001, 1.0),\n        (17, 0.0005, 0.1, 1.0),\n        (33, 0.002, 0.001, 0.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        norm_star, norm_np1 = solve_one_case(*case)\n        results.append([norm_star, norm_np1])\n    \n    # Format the output as specified: [[a1,b1],[a2,b2],[a3,b3]]\n    inner_results = [f\"[{r[0]},{r[1]}]\" for r in results]\n    print(f\"[{','.join(inner_results)}]\")\n\ndef solve_one_case(N, dt, nu, U0):\n    \"\"\"\n    Solves the problem for a single set of parameters.\n    \"\"\"\n    h = 1.0 / (N - 1)\n\n    # 1. Initialization\n    u_n = np.zeros((N, N))\n    v_n = np.zeros((N, N))\n\n    # Apply velocity boundary conditions\n    u_n[:, N-1] = U0\n    u_n[0, N-1] = 0.0   # Corner no-slip (left-top)\n    u_n[N-1, N-1] = 0.0 # Corner no-slip (right-top)\n\n    # 2. Compute intermediate velocity u_star\n    u_star = u_n.copy()\n    v_star = v_n.copy()\n\n    # Diffusion step for interior points\n    lap_u = (u_n[2:, 1:-1] + u_n[:-2, 1:-1] + u_n[1:-1, 2:] + u_n[1:-1, :-2] - 4 * u_n[1:-1, 1:-1]) / h**2\n    lap_v = (v_n[2:, 1:-1] + v_n[:-2, 1:-1] + v_n[1:-1, 2:] + v_n[1:-1, :-2] - 4 * v_n[1:-1, 1:-1]) / h**2\n    \n    u_star[1:-1, 1:-1] = u_n[1:-1, 1:-1] + nu * dt * lap_u\n    v_star[1:-1, 1:-1] = v_n[1:-1, 1:-1] + nu * dt * lap_v\n    \n    # Re-apply boundary conditions on u_star (already set for v_star as it's 0)\n    u_star[:, N-1] = U0\n    u_star[0, N-1] = 0.0\n    u_star[N-1, N-1] = 0.0\n\n    # 3. Compute divergence of u_star\n    div_u_star = np.zeros((N, N))\n    div_u_star[1:-1, 1:-1] = (u_star[2:, 1:-1] - u_star[:-2, 1:-1]) / (2 * h) + \\\n                             (v_star[1:-1, 2:] - v_star[1:-1, :-2]) / (2 * h)\n    \n    norm_div_u_star = np.sqrt(h**2 * np.sum(div_u_star[1:-1, 1:-1]**2))\n\n    # 4. Solve Pressure Poisson Equation\n    # RHS of Poisson equation\n    b_poisson = (div_u_star / dt)\n    \n    # Assemble the matrix for the linear system Ap = b\n    N_sq = N * N\n    A = np.zeros((N_sq, N_sq))\n    h2 = h**2\n    \n    k_map = np.arange(N_sq).reshape((N, N))\n\n    for i in range(N):\n        for j in range(N):\n            k = k_map[i, j]\n            \n            if 1 = i  N - 1 and 1 = j  N - 1: # Interior\n                A[k, k] = -4.0; A[k, k_map[i+1, j]] = 1.0; A[k, k_map[i-1, j]] = 1.0; A[k, k_map[i, j+1]] = 1.0; A[k, k_map[i, j-1]] = 1.0\n            elif i == 0 and j == 0: # Corner BL\n                A[k, k] = -4.0; A[k, k_map[i+1, j]] = 2.0; A[k, k_map[i, j+1]] = 2.0\n            elif i == N-1 and j == 0: # Corner BR\n                A[k, k] = -4.0; A[k, k_map[i-1, j]] = 2.0; A[k, k_map[i, j+1]] = 2.0\n            elif i == 0 and j == N-1: # Corner TL\n                A[k, k] = -4.0; A[k, k_map[i+1, j]] = 2.0; A[k, k_map[i, j-1]] = 2.0\n            elif i == N-1 and j == N-1: # Corner TR\n                A[k, k] = -4.0; A[k, k_map[i-1, j]] = 2.0; A[k, k_map[i, j-1]] = 2.0\n            elif i == 0: # Left edge\n                A[k, k] = -4.0; A[k, k_map[i+1, j]] = 2.0; A[k, k_map[i, j+1]] = 1.0; A[k, k_map[i, j-1]] = 1.0\n            elif i == N-1: # Right edge\n                A[k, k] = -4.0; A[k, k_map[i-1, j]] = 2.0; A[k, k_map[i, j+1]] = 1.0; A[k, k_map[i, j-1]] = 1.0\n            elif j == 0: # Bottom edge\n                A[k, k] = -4.0; A[k, k_map[i+1, j]] = 1.0; A[k, k_map[i-1, j]] = 1.0; A[k, k_map[i, j+1]] = 2.0\n            elif j == N-1: # Top edge\n                A[k, k] = -4.0; A[k, k_map[i+1, j]] = 1.0; A[k, k_map[i-1, j]] = 1.0; A[k, k_map[i, j-1]] = 2.0\n\n    A /= h2\n\n    # Apply pressure pinning constraint p=0 at center\n    center_idx = (N - 1) // 2\n    k_center = k_map[center_idx, center_idx]\n    A[k_center, :] = 0.0\n    A[k_center, k_center] = 1.0\n\n    b_flat = b_poisson.flatten()\n    b_flat[k_center] = 0.0\n\n    # Solve for pressure\n    p_flat = np.linalg.solve(A, b_flat)\n    p = p_flat.reshape((N, N))\n\n    # 5. Project velocity\n    dpdx = np.zeros((N, N))\n    dpdy = np.zeros((N, N))\n    \n    # Interior gradients (central difference)\n    dpdx[1:-1, :] = (p[2:, :] - p[:-2, :]) / (2 * h)\n    dpdy[:, 1:-1] = (p[:, 2:] - p[:, :-2]) / (2 * h)\n    \n    # Boundary gradients (one-sided difference)\n    dpdx[0, :] = (p[1, :] - p[0, :]) / h\n    dpdx[-1, :] = (p[-1, :] - p[-2, :]) / h\n    dpdy[:, 0] = (p[:, 1] - p[:, 0]) / h\n    dpdy[:, -1] = (p[:, -1] - p[:, -2]) / h\n\n    u_np1 = u_star - dt * dpdx\n    v_np1 = v_star - dt * dpdy\n    \n    # Reapply velocity boundary conditions\n    u_np1[:, 0] = 0.0; v_np1[:, 0] = 0.0\n    u_np1[:, -1] = U0; v_np1[:, -1] = 0.0\n    u_np1[0, :] = 0.0; v_np1[0, :] = 0.0\n    u_np1[-1, :] = 0.0; v_np1[-1, :] = 0.0\n    u_np1[0, -1] = 0.0 # Corner correction\n    u_np1[-1, -1] = 0.0 # Corner correction\n    \n    # 6. Compute divergence of u_np1\n    div_u_np1 = np.zeros((N, N))\n    div_u_np1[1:-1, 1:-1] = (u_np1[2:, 1:-1] - u_np1[:-2, 1:-1]) / (2 * h) + \\\n                              (v_np1[1:-1, 2:] - v_np1[1:-1, :-2]) / (2 * h)\n\n    norm_div_u_np1 = np.sqrt(h**2 * np.sum(div_u_np1[1:-1, 1:-1]**2))\n\n    return norm_div_u_star, norm_div_u_np1\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Building upon the single-correction projection method, more advanced algorithms have been developed to improve accuracy and efficiency, especially for transient simulations. The Pressure Implicit with Splitting of Operators (PISO) algorithm is a powerful non-iterative approach that applies multiple correction steps within a single time step. In this final practice , you will implement the PISO algorithm for a transient channel flow, observing how the successive predictor and corrector steps systematically reduce the velocity divergence to a negligible level, ensuring mass conservation is robustly maintained.",
            "id": "3994256",
            "problem": "Consider incompressible laminar flow in a two-dimensional channel of length $L_x$ in the streamwise direction and height $L_y$ in the wall-normal direction. The fluid has constant density $\\rho$ and dynamic viscosity $\\mu$. The flow starts from rest at time $t=0$ and is driven by an imposed constant streamwise pressure gradient of magnitude $G$ in units of $\\mathrm{Pa/m}$. The walls at $y=0$ and $y=L_y$ enforce no-slip velocity boundary conditions, and the streamwise direction $x$ is treated as periodic. The governing equations are the incompressible Navier–Stokes equations for constant density,\n$$\n\\rho \\frac{\\partial \\mathbf{u}}{\\partial t} + \\rho (\\mathbf{u}\\cdot\\nabla)\\mathbf{u} = -\\nabla p + \\mu \\nabla^2 \\mathbf{u} + \\rho \\mathbf{g},\n$$\nwith $\\nabla\\cdot \\mathbf{u} = 0$, and where the imposed constant streamwise pressure gradient $G$ is represented as a uniform body force equivalent to $\\rho g_x = G$. For the transient start-up regime from rest with small Reynolds number, it is acceptable to neglect the convective term $\\rho (\\mathbf{u}\\cdot\\nabla)\\mathbf{u}$ to isolate the pressure–velocity coupling effects in the algorithmic implementation.\n\nYou must implement the Pressure Implicit with Splitting of Operators (PISO) algorithm to couple pressure and velocity in time for this start-up channel flow on a collocated uniform Cartesian grid that is periodic in $x$ and has no-slip boundaries in $y$. The algorithm at each time step must, at a minimum, perform the following sequence:\n1. A velocity predictor step using the previous time step pressure field to obtain an intermediate velocity $\\mathbf{u}^*$.\n2. A first pressure correction that enforces incompressibility by solving a pressure equation derived from continuity applied to $\\mathbf{u}^*$, followed by a velocity correction to obtain $\\mathbf{u}^{(1)}$.\n3. A second pressure correction that further reduces divergence, followed by a second velocity correction to obtain $\\mathbf{u}^{(2)}$.\nYou must report the evolution of the spatial root-mean-square divergence norm $\\|\\nabla\\cdot\\mathbf{u}\\|_2$ at the predictor, first corrector, and second corrector substeps within each time step. For the purposes of this problem, define the reported norm as the spatial root-mean-square (RMS) norm\n$$\n\\|\\nabla\\cdot\\mathbf{u}\\|_2 = \\sqrt{\\frac{1}{\\Omega}\\int_{\\Omega} \\left(\\nabla\\cdot\\mathbf{u}\\right)^2 \\, d\\Omega},\n$$\nwhich in discrete form is approximated by the square root of the arithmetic mean of the pointwise squared divergence values. This quantity must be reported in units of $\\mathrm{s^{-1}}$.\n\nDiscretize the domain into $N_x$ points in $x$ and $N_y$ points in $y$ with uniform spacings $\\Delta x = L_x/N_x$ and $\\Delta y = L_y/N_y$. Use second-order central differences for spatial derivatives of diffusion and pressure gradients, periodic wrapping for $x$-direction stencils, and enforce appropriate boundary treatments at $y=0$ and $y=L_y$ consistent with no-slip velocity and zero-normal gradient pressure boundaries. Time integration should use an explicit predictor consistent with the PISO framework, and pressure corrections should be obtained by solving a discrete pressure equation that arises from applying continuity to the predicted velocity field. The uniqueness of pressure should be enforced by fixing one arbitrary reference cell pressure value.\n\nYour program must implement this algorithm and, for each time step, compute and store the three values of $\\|\\nabla\\cdot\\mathbf{u}\\|_2$ corresponding to the predictor, first corrector, and second corrector substeps. The program must run the simulation for a small number of time steps for several parameter sets constituting a test suite.\n\nTest suite:\n- Case A (happy path): $L_x = 1\\,\\mathrm{m}$, $L_y = 1\\,\\mathrm{m}$, $N_x = 16$, $N_y = 16$, $\\rho = 1\\,\\mathrm{kg/m^3}$, $\\mu = 0.01\\,\\mathrm{Pa\\cdot s}$, $G = 1\\,\\mathrm{Pa/m}$, time step $\\Delta t = 5\\times 10^{-3}\\,\\mathrm{s}$, $N_{\\text{steps}} = 4$.\n- Case B (coarser grid and larger time step boundary condition): $L_x = 1\\,\\mathrm{m}$, $L_y = 1\\,\\mathrm{m}$, $N_x = 8$, $N_y = 8$, $\\rho = 1\\,\\mathrm{kg/m^3}$, $\\mu = 0.1\\,\\mathrm{Pa\\cdot s}$, $G = 1\\,\\mathrm{Pa/m}$, time step $\\Delta t = 10^{-2}\\,\\mathrm{s}$, $N_{\\text{steps}} = 3$.\n- Case C (edge case with zero driving): $L_x = 1\\,\\mathrm{m}$, $L_y = 1\\,\\mathrm{m}$, $N_x = 16$, $N_y = 16$, $\\rho = 1\\,\\mathrm{kg/m^3}$, $\\mu = 0.01\\,\\mathrm{Pa\\cdot s}$, $G = 0\\,\\mathrm{Pa/m}$, time step $\\Delta t = 5\\times 10^{-3}\\,\\mathrm{s}$, $N_{\\text{steps}} = 3$.\n\nFinal output format:\nYour program should produce a single line of output containing the aggregated results for all test cases as a comma-separated list enclosed in square brackets. For each test case, output a list of lists, one inner list per time step, where each inner list contains the three floating-point values of $\\|\\nabla\\cdot\\mathbf{u}\\|_2$ in $\\mathrm{s^{-1}}$ for the predictor, first corrector, and second corrector substeps in that order. For example, the overall output should look like\n$[ \\text{caseA\\_results}, \\text{caseB\\_results}, \\text{caseC\\_results} ]$\nwhere each $\\text{caseX\\_results}$ is itself a list of lists of floats. The values must be numeric without any unit symbols, and the units are implicitly $\\mathrm{s^{-1}}$ as defined above.",
            "solution": "The user has provided a problem requesting the implementation of the Pressure Implicit with Splitting of Operators (PISO) algorithm for a simplified two-dimensional, incompressible, laminar channel flow. The provided problem statement is validated as scientifically grounded, well-posed, and objective. It contains all necessary information, including governing equations, boundary and initial conditions, discretization guidelines, and a specific set of test parameters. The problem is a standard, albeit non-trivial, exercise in computational fluid dynamics (CFD) and is solvable as formulated.\n\nWe will now proceed with a detailed derivation and description of the numerical method, followed by its implementation.\n\n### 1. Governing Equations\n\nThe problem concerns the transient start-up of flow in a channel, driven by a constant streamwise pressure gradient $G$. For a low Reynolds number regime, the non-linear convective term $(\\mathbf{u}\\cdot\\nabla)\\mathbf{u}$ in the Navier-Stokes equations is neglected. The governing equations for velocity $\\mathbf{u}=(u,v)$ and pressure $p$ are:\n\nMomentum equation:\n$$ \\rho \\frac{\\partial \\mathbf{u}}{\\partial t} = -\\nabla p + \\mu \\nabla^2 \\mathbf{u} + \\mathbf{f} $$\nContinuity equation (incompressibility constraint):\n$$ \\nabla \\cdot \\mathbf{u} = 0 $$\n\nHere, $\\rho$ is the constant fluid density, $\\mu$ is the dynamic viscosity, and $\\mathbf{f}$ is a body force term. The imposed pressure gradient $G$ is modeled as a uniform streamwise body force, so $\\mathbf{f} = (G, 0)$.\n\n### 2. Discretization\n\nThe equations are discretized on a collocated, uniform Cartesian grid with $N_x \\times N_y$ cells, where all variables ($u$, $v$, $p$) are stored at the cell centers. The cell dimensions are $\\Delta x = L_x/N_x$ and $\\Delta y = L_y/N_y$. Spatial derivatives are approximated using second-order central differences. For a generic field $\\phi$, the operators are:\n\nGradient:\n$$ \\nabla \\phi \\approx \\left(\\frac{\\phi_{i,j+1} - \\phi_{i,j-1}}{2\\Delta x}, \\frac{\\phi_{i+1,j} - \\phi_{i-1,j}}{2\\Delta y}\\right) $$\nLaplacian:\n$$ \\nabla^2 \\phi \\approx \\frac{\\phi_{i,j+1} - 2\\phi_{i,j} + \\phi_{i,j-1}}{\\Delta x^2} + \\frac{\\phi_{i+1,j} - 2\\phi_{i,j} + \\phi_{i-1,j}}{\\Delta y^2} $$\nDivergence:\n$$ \\nabla \\cdot \\mathbf{u} \\approx \\frac{u_{i,j+1} - u_{i,j-1}}{2\\Delta x} + \\frac{v_{i+1,j} - v_{i-1,j}}{2\\Delta y} $$\n\nTime is discretized using a forward Euler scheme with time step $\\Delta t$. Let the superscript $n$ denote the value at time $t^n$.\n\n### 3. PISO Algorithm\n\nThe PISO algorithm is a non-iterative method for pressure-velocity coupling that performs one predictor and multiple corrector steps within a single time step to enforce the incompressibility constraint. For this problem, we implement one predictor and two corrector steps. Let $\\mathbf{u}^n$ and $p^n$ be the known fields at the beginning of the time step.\n\n**Step 1: Velocity Predictor**\n\nAn intermediate velocity field, $\\mathbf{u}^*$, is explicitly calculated from the momentum equation using the pressure field from the previous time step, $p^n$.\n\n$$ \\frac{\\mathbf{u}^* - \\mathbf{u}^n}{\\Delta t} = \\frac{1}{\\rho} \\left( -\\nabla p^n + \\mu \\nabla^2 \\mathbf{u}^n + \\mathbf{f} \\right) $$\nRearranging gives the predictor equation for $\\mathbf{u}^*$:\n$$ \\mathbf{u}^* = \\mathbf{u}^n + \\frac{\\Delta t}{\\rho} \\left( -\\nabla p^n + \\mu \\nabla^2 \\mathbf{u}^n + \\mathbf{f} \\right) $$\nThis predicted velocity field $\\mathbf{u}^*$ does not, in general, satisfy the continuity equation, i.e., $\\nabla \\cdot \\mathbf{u}^* \\neq 0$. The spatial root-mean-square of this divergence, $\\|\\nabla \\cdot \\mathbf{u}^*\\|_2$, is the first value to be reported for the time step.\n\n**Step 2: First Pressure-Velocity Correction**\n\nThe goal of the corrector step is to find a pressure correction, $p'$, and a corresponding velocity correction such that the new velocity field, $\\mathbf{u}^{(1)}$, satisfies the continuity equation. The corrected velocity and pressure are defined as:\n$$ \\mathbf{u}^{(1)} = \\mathbf{u}^* + \\delta\\mathbf{u}^{(1)} $$\n$$ p^{(1)} = p^n + p' $$\nThe update to the momentum equation from the predictor step to the first corrector step is simply the change in the pressure gradient term. The relation between the velocity correction and pressure correction is derived by subtracting the predictor equation from the corrected momentum equation, yielding:\n$$ \\frac{\\mathbf{u}^{(1)} - \\mathbf{u}^*}{\\Delta t} = -\\frac{1}{\\rho}\\nabla(p^{(1)}-p^n) = -\\frac{1}{\\rho}\\nabla p' $$\nThis provides an explicit velocity correction formula:\n$$ \\mathbf{u}^{(1)} = \\mathbf{u}^* - \\frac{\\Delta t}{\\rho} \\nabla p' $$\nTo find $p'$, we enforce the incompressibility constraint on the corrected velocity, $\\nabla \\cdot \\mathbf{u}^{(1)} = 0$. Applying the divergence operator to the velocity correction equation gives:\n$$ \\nabla \\cdot \\mathbf{u}^{(1)} = \\nabla \\cdot \\mathbf{u}^* - \\frac{\\Delta t}{\\rho} \\nabla^2 p' = 0 $$\nThis leads to the first Pressure-Poisson Equation (PPE) for the pressure correction $p'$:\n$$ \\nabla^2 p' = \\frac{\\rho}{\\Delta t} \\nabla \\cdot \\mathbf{u}^* $$\nThis is an elliptic partial differential equation that we solve for $p'$. The solution requires boundary conditions. For the no-slip walls, the normal component of velocity ($v$) must remain zero. This implies that the normal component of the velocity correction must be zero at the wall. From the velocity correction formula, this imposes a zero-gradient (Neumann) boundary condition on the pressure correction: $\\frac{\\partial p'}{\\partial y} = 0$. In the periodic $x$-direction, $p'$ is also periodic.\n\nAfter solving for $p'$, we update the velocity field to $\\mathbf{u}^{(1)}$. Due to discretization errors, $\\nabla \\cdot \\mathbf{u}^{(1)}$ may not be exactly zero. We compute and report its norm, $\\|\\nabla \\cdot \\mathbf{u}^{(1)}\\|_2$.\n\n**Step 3: Second Pressure-Velocity Correction**\n\nThe PISO algorithm philosophy is to improve the satisfaction of the momentum and continuity equations by performing additional correction steps. We introduce a second pressure correction, $p''$, and a second velocity field, $\\mathbf{u}^{(2)}$. The process is analogous to the first correction:\n$$ \\mathbf{u}^{(2)} = \\mathbf{u}^{(1)} - \\frac{\\Delta t}{\\rho} \\nabla p'' $$\nEnforcing $\\nabla \\cdot \\mathbf{u}^{(2)} = 0$ yields the second PPE:\n$$ \\nabla^2 p'' = \\frac{\\rho}{\\Delta t} \\nabla \\cdot \\mathbf{u}^{(1)} $$\nNote that the source term is now the divergence of the previously corrected velocity field, $\\mathbf{u}^{(1)}$. We solve this PPE for $p''$ using the same boundary conditions as for $p'$. The velocity is then updated to $\\mathbf{u}^{(2)}$. The final divergence norm for the time step, $\\|\\nabla \\cdot \\mathbf{u}^{(2)}\\|_2$, is then computed.\n\n**Step 4: Update for Next Time Step**\n\nThe fields are advanced to the next time step, $t^{n+1}$:\n$$ \\mathbf{u}^{n+1} = \\mathbf{u}^{(2)} $$\n$$ p^{n+1} = p^n + p' + p'' $$\nThis completes one full time step of the PISO algorithm.\n\n### 4. Implementation Details\n\n- **Boundary Conditions:** The problem states periodic boundaries in $x$ and no-slip walls at $y=0$ and $y=L_y$. We use ghost cells to implement these. For a generic field $\\phi$ on a padded grid:\n    - Periodicity in $x$: $\\phi_{i,0} = \\phi_{i,N_x}$ and $\\phi_{i,N_x+1} = \\phi_{i,1}$.\n    - No-slip on walls for velocity components $u, v$: At the $y=0$ wall, we need the velocity halfway between the first interior cell and the ghost cell to be zero. Linear interpolation gives $\\frac{1}{2}(u_1 + u_0) = 0 \\implies u_0 = -u_1$. The ghost cell value is the negative of the adjacent interior cell value.\n    - Zero-gradient for pressure on walls: At the $y=0$ wall, $\\frac{\\partial p}{\\partial y}=0$ is approximated by setting the ghost cell pressure equal to the adjacent interior cell pressure: $p_0 = p_1$.\n\n- **Poisson Solver:** The discretized PPE results in a large, sparse linear system of equations, $A\\mathbf{x} = \\mathbf{b}$, where $\\mathbf{x}$ is the flattened vector of unknown pressure correction values. We construct the matrix $A$ representing the 5-point stencil of the Laplacian operator, incorporating the boundary conditions. The resulting system is singular due to the pure Neumann/periodic boundary conditions (the pressure is only known up to an additive constant). To ensure a unique solution, we enforce a reference pressure by setting the pressure correction at one cell (e.g., index `(0,0)`) to zero. This is done by modifying the corresponding row of matrix $A$ to be an identity row and setting the corresponding element in vector $\\mathbf{b}$ to zero. The system is then solved efficiently using `scipy.sparse.linalg.spsolve`.\n\n- **Numerical Stability:** The use of an explicit predictor requires the time step $\\Delta t$ to be constrained by the CFL and diffusive stability limits. The problem uses a purely explicit scheme for the viscous term, imposing $\\Delta t \\le \\frac{\\rho}{2\\mu} \\left(\\frac{1}{\\Delta x^2} + \\frac{1}{\\Delta y^2}\\right)^{-1}$. The provided test cases use $\\Delta t$ values that satisfy this criterion.\n\n- **Note on Collocated Grids:** The use of central differences for pressure gradients and velocity divergence on a collocated grid can lead to pressure-velocity decoupling (checkerboard pressure fields). Advanced schemes often employ Rhie-Chow interpolation to mitigate this. As this was not specified, it is omitted from this implementation, which adheres strictly to the problem statement. The chosen flow problem, which develops into a one-dimensional profile, is less susceptible to this issue than more complex flows.\n\nThe following Python code implements this algorithm.",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csr_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases.\n    \"\"\"\n    test_cases = [\n        # Case A (happy path)\n        {\"Lx\": 1.0, \"Ly\": 1.0, \"Nx\": 16, \"Ny\": 16, \"rho\": 1.0, \"mu\": 0.01, \"G\": 1.0, \"dt\": 5e-3, \"n_steps\": 4},\n        # Case B (coarser grid and larger time step)\n        {\"Lx\": 1.0, \"Ly\": 1.0, \"Nx\": 8, \"Ny\": 8, \"rho\": 1.0, \"mu\": 0.1, \"G\": 1.0, \"dt\": 1e-2, \"n_steps\": 3},\n        # Case C (edge case with zero driving)\n        {\"Lx\": 1.0, \"Ly\": 1.0, \"Nx\": 16, \"Ny\": 16, \"rho\": 1.0, \"mu\": 0.01, \"G\": 0.0, \"dt\": 5e-3, \"n_steps\": 3},\n    ]\n\n    all_results = []\n    \n    for params in test_cases:\n        case_results = run_simulation(**params)\n        all_results.append(case_results)\n\n    # Format the final output as a string representation of the list of lists of lists.\n    # repr() is used to get a string that is a valid Python literal.\n    print(repr(all_results).replace(\" \", \"\"))\n\ndef run_simulation(Lx, Ly, Nx, Ny, rho, mu, G, dt, n_steps):\n    \"\"\"\n    Executes the PISO simulation for a single test case.\n    \"\"\"\n    dx = Lx / Nx\n    dy = Ly / Ny\n\n    # Initialize fields (u, v, p) on a padded grid for ghost cells\n    u = np.zeros((Ny + 2, Nx + 2))\n    v = np.zeros((Ny + 2, Nx + 2))\n    p = np.zeros((Ny + 2, Nx + 2))\n    \n    # Body force\n    fx = G\n    \n    # Pre-build the Poisson matrix\n    A = build_poisson_matrix(Nx, Ny, dx, dy)\n    \n    step_results = []\n    \n    for _ in range(n_steps):\n        # Apply boundary conditions to u, v, p from the previous step\n        u = apply_velocity_bcs(u)\n        v = apply_velocity_bcs(v)\n        p = apply_pressure_bcs(p)\n        \n        # --- 1. Predictor Step ---\n        # Calculate RHS of momentum equation\n        lap_u = laplacian(u, dx, dy)\n        lap_v = laplacian(v, dx, dy)\n        grad_px, grad_py = gradient(p, dx, dy)\n        \n        rhs_u = (-grad_px + mu * lap_u + fx) / rho\n        rhs_v = (-grad_py + mu * lap_v) / rho\n        \n        # Predictor velocity u*, v*\n        u_star = u[1:-1, 1:-1] + dt * rhs_u\n        v_star = v[1:-1, 1:-1] + dt * rhs_v\n        \n        # Update padded arrays for divergence calculation\n        u[1:-1, 1:-1], v[1:-1, 1:-1] = u_star, v_star\n        u = apply_velocity_bcs(u)\n        v = apply_velocity_bcs(v)\n        \n        # Report divergence of predictor field\n        div_star = divergence(u, v, dx, dy)\n        div_norm_star = np.sqrt(np.mean(div_star**2))\n        \n        # --- 2. First Corrector Step ---\n        # Solve first Pressure-Poisson Equation\n        rhs_p1 = rho / dt * div_star\n        p_corr1 = solve_poisson(rhs_p1.flatten(), A, Nx, Ny)\n        \n        # Update velocity u**(1), v**(1)\n        grad_pc1_x, grad_pc1_y = gradient(p_corr1, dx, dy)\n        u_corr1 = u[1:-1, 1:-1] - dt / rho * grad_pc1_x\n        v_corr1 = v[1:-1, 1:-1] - dt / rho * grad_pc1_y\n        \n        u[1:-1, 1:-1], v[1:-1, 1:-1] = u_corr1, v_corr1\n        u = apply_velocity_bcs(u)\n        v = apply_velocity_bcs(v)\n\n        # Report divergence of first corrected field\n        div_corr1 = divergence(u, v, dx, dy)\n        div_norm_corr1 = np.sqrt(np.mean(div_corr1**2))\n        \n        # --- 3. Second Corrector Step ---\n        # Solve second Pressure-Poisson Equation\n        rhs_p2 = rho / dt * div_corr1\n        p_corr2 = solve_poisson(rhs_p2.flatten(), A, Nx, Ny)\n        \n        # Update velocity u**(2), v**(2)\n        grad_pc2_x, grad_pc2_y = gradient(p_corr2, dx, dy)\n        u_corr2 = u[1:-1, 1:-1] - dt / rho * grad_pc2_x\n        v_corr2 = v[1:-1, 1:-1] - dt / rho * grad_pc2_y\n        \n        u[1:-1, 1:-1], v[1:-1, 1:-1] = u_corr2, v_corr2\n        u = apply_velocity_bcs(u)\n        v = apply_velocity_bcs(v)\n\n        # Report divergence of second corrected field\n        div_corr2 = divergence(u, v, dx, dy)\n        div_norm_corr2 = np.sqrt(np.mean(div_corr2**2))\n        \n        # --- 4. Final Updates ---\n        # Update pressure field for next time step\n        p_new_interior = p[1:-1, 1:-1] + p_corr1[1:-1, 1:-1] + p_corr2[1:-1, 1:-1]\n        p[1:-1, 1:-1] = p_new_interior\n        \n        step_results.append([div_norm_star, div_norm_corr1, div_norm_corr2])\n        \n    return step_results\n\n# --- Helper Functions for Discretization and BCs ---\n\ndef apply_velocity_bcs(vel):\n    \"\"\"Apply periodic (x) and no-slip (y) BCs.\"\"\"\n    # Periodic in x\n    vel[:, 0] = vel[:, -2]\n    vel[:, -1] = vel[:, 1]\n    # No-slip in y (u_ghost = -u_interior)\n    vel[0, :] = -vel[1, :]\n    vel[-1, :] = -vel[-2, :]\n    return vel\n\ndef apply_pressure_bcs(p):\n    \"\"\"Apply periodic (x) and zero-gradient (y) BCs.\"\"\"\n    # Periodic in x\n    p[:, 0] = p[:, -2]\n    p[:, -1] = p[:, 1]\n    # Zero-gradient in y (dp/dy=0 -> p_ghost = p_interior)\n    p[0, :] = p[1, :]\n    p[-1, :] = p[-2, :]\n    return p\n\ndef laplacian(field, dx, dy):\n    \"\"\"Compute Laplacian on interior cells using a 5-point stencil.\"\"\"\n    return (field[1:-1, 2:] - 2 * field[1:-1, 1:-1] + field[1:-1, 0:-2]) / dx**2 + \\\n           (field[2:, 1:-1] - 2 * field[1:-1, 1:-1] + field[0:-2, 1:-1]) / dy**2\n\ndef divergence(u, v, dx, dy):\n    \"\"\"Compute divergence on interior cells.\"\"\"\n    return (u[1:-1, 2:] - u[1:-1, 0:-2]) / (2 * dx) + \\\n           (v[2:, 1:-1] - v[0:-2, 1:-1]) / (2 * dy)\n\ndef gradient(p, dx, dy):\n    \"\"\"Compute gradient on interior cells.\"\"\"\n    grad_x = (p[1:-1, 2:] - p[1:-1, 0:-2]) / (2 * dx)\n    grad_y = (p[2:, 1:-1] - p[0:-2, 1:-1]) / (2 * dy)\n    return grad_x, grad_y\n\ndef build_poisson_matrix(Nx, Ny, dx, dy):\n    \"\"\"Build the sparse matrix for the Poisson equation.\"\"\"\n    N = Nx * Ny\n    A = lil_matrix((N, N))\n    \n    dx2_inv = 1 / dx**2\n    dy2_inv = 1 / dy**2\n    \n    for i in range(Ny):\n        for j in range(Nx):\n            k = i * Nx + j\n            \n            # Diagonal term\n            A[k, k] = -2 * (dx2_inv + dy2_inv)\n            \n            # Off-diagonal terms\n            # West\n            A[k, i * Nx + (j - 1) % Nx] += dx2_inv\n            # East\n            A[k, i * Nx + (j + 1) % Nx] += dx2_inv\n            \n            # South\n            if i > 0:\n                A[k, (i - 1) * Nx + j] += dy2_inv\n            else: # Neumann BC at y=0\n                A[k, k] += dy2_inv\n                \n            # North\n            if i  Ny - 1:\n                A[k, (i + 1) * Nx + j] += dy2_inv\n            else: # Neumann BC at y=Ly\n                A[k, k] += dy2_inv\n\n    # Enforce pressure reference p(0,0)=0 to make matrix non-singular\n    A[0, :] = 0\n    A[0, 0] = 1\n    \n    return csr_matrix(A)\n\ndef solve_poisson(rhs_flat, A, Nx, Ny):\n    \"\"\"Solve the linear system Ax=b for pressure and reshape.\"\"\"\n    # Set RHS for reference pressure cell to 0\n    rhs_flat[0] = 0\n    \n    p_flat = spsolve(A, rhs_flat)\n    \n    p_corr_interior = p_flat.reshape((Ny, Nx))\n    \n    # Create padded array for gradient calculation\n    p_corr = np.zeros((Ny + 2, Nx + 2))\n    p_corr[1:-1, 1:-1] = p_corr_interior\n    p_corr = apply_pressure_bcs(p_corr)\n    \n    return p_corr\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}