{
    "hands_on_practices": [
        {
            "introduction": "此练习旨在从根本上探讨计算流体动力学（CFD）中压力-速度解耦问题的根源。通过对比分析同位网格（collocated grid）和交错网格（staggered grid），您将亲身体会到空间离散格式的选择对于获得稳定数值解的至关重要性。这项实践将揭示交错网格如何通过其结构自然地将压力差与质量通量紧密耦合，从而抑制困扰朴素同位网格方案的非物理“棋盘格”压力振荡 。",
            "id": "3994267",
            "problem": "考虑在二维通道中，无热梯度情况下，不可压缩、等温的牛顿流体层流。其控制方程为连续性方程和动量方程，分别表述为\n$$\\nabla \\cdot \\mathbf{u} = 0,$$\n$$\\rho \\frac{\\partial \\mathbf{u}}{\\partial t} + \\rho (\\mathbf{u} \\cdot \\nabla)\\mathbf{u} = -\\nabla p + \\mu \\nabla^2 \\mathbf{u},$$\n其中 $\\mathbf{u} = (u,v)$ 是速度场，$p$ 是压力，$\\rho$ 是流体密度，$\\mu$ 是动力粘度。在压力-速度分离（投影）的观点下，压力通过以下方式校正预测速度，从而强制满足连续性约束：\n$$\\mathbf{u}^{n+1} = \\mathbf{u}^{*} - \\frac{\\Delta t}{\\rho} \\nabla p,$$\n其中 $\\Delta t$ 是时间增量，$\\mathbf{u}^{*}$ 是预测速度，$\\mathbf{u}^{n+1}$ 是无散的校正速度。在离散设置中，$\\nabla p$ 和 $\\nabla \\cdot \\mathbf{u}$ 的构造方式取决于网格的布置。一种朴素的同位网格将 $u$、$v$ 和 $p$ 存储在网格中心，并用中心差分来近似导数；而交错网格（标记与网格（MAC）布置）将 $p$ 存储在网格中心，而 $u$ 和 $v$ 存储在网格面上。在计算流体动力学（CFD）中，众所周知，朴素的同位网格布置会容许伪奇偶压力模式（棋盘状振荡）的存在，而交错网格则能抑制这些模式，因为面心通量能直接感知到格心压力差。\n\n您的任务是，从第一性原理出发，为两种网格布置推导并实现离散算子，并通过数值方式证明：纯棋盘状压力模式在朴素同位网格格式上产生的质量通量散度可忽略不计（揭示了解耦现象），但在交错网格格式上则产生不可忽略的散度（揭示了抑制振荡的耦合作用）。将计算域视为一个尺寸为 $N_x \\times N_y$、间距为 $\\Delta x$ 和 $\\Delta y$ 的矩形均匀网格，并在两个方向上采用周期性边界条件，以便在没有边界层的情况下隔离内部耦合效应。使用一个振幅为 $p_0$（单位为 $\\mathrm{Pa}$）的合成棋盘状压力场\n$$p_{i,j} = p_0 (-1)^{i+j},$$\n并按如下方式评估每种格式下由压力校正引起的速度场的散度：\n\n- 对于朴素同位网格格式：\n  - 将 $u$、$v$ 和 $p$ 放置在网格中心 $(i,j)$。\n  - 使用中心差分近似网格中心的压力梯度：\n    $$\\left(\\frac{\\partial p}{\\partial x}\\right)_{i,j} \\approx \\frac{p_{i+1,j} - p_{i-1,j}}{2\\Delta x}, \\quad \\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j} \\approx \\frac{p_{i,j+1} - p_{i,j-1}}{2\\Delta y}.$$\n  - 定义校正后的网格中心速度：\n    $$u_{i,j}^{c} = -\\frac{\\Delta t}{\\rho}\\left(\\frac{\\partial p}{\\partial x}\\right)_{i,j}, \\quad v_{i,j}^{c} = -\\frac{\\Delta t}{\\rho}\\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j}.$$\n  - 通过对网格中心速度进行朴素的线性插值来构造面质量通量：\n    $$u_{i+\\frac{1}{2},j}^{c} = \\frac{u_{i,j}^{c} + u_{i+1,j}^{c}}{2}, \\quad v_{i,j+\\frac{1}{2}}^{c} = \\frac{v_{i,j}^{c} + v_{i,j+1}^{c}}{2}.$$\n  - 计算网格中心的离散散度：\n    $$\\left(\\nabla \\cdot \\mathbf{u}^{c}\\right)_{i,j} \\approx \\frac{u_{i+\\frac{1}{2},j}^{c} - u_{i-\\frac{1}{2},j}^{c}}{\\Delta x} + \\frac{v_{i,j+\\frac{1}{2}}^{c} - v_{i,j-\\frac{1}{2}}^{c}}{\\Delta y}.$$\n\n- 对于交错MAC格式：\n  - 将 $p$ 放置在网格中心 $(i,j)$，$u$ 放置在垂直面 $(i+\\frac{1}{2}, j)$，$v$ 放置在水平面 $(i, j+\\frac{1}{2})$。\n  - 通过单网格差分计算面心速度：\n    $$u_{i+\\frac{1}{2},j}^{s} = -\\frac{\\Delta t}{\\rho} \\frac{p_{i+1,j} - p_{i,j}}{\\Delta x}, \\quad v_{i,j+\\frac{1}{2}}^{s} = -\\frac{\\Delta t}{\\rho} \\frac{p_{i,j+1} - p_{i,j}}{\\Delta y}.$$\n  - 计算网格中心的离散散度：\n    $$\\left(\\nabla \\cdot \\mathbf{u}^{s}\\right)_{i,j} \\approx \\frac{u_{i+\\frac{1}{2},j}^{s} - u_{i-\\frac{1}{2},j}^{s}}{\\Delta x} + \\frac{v_{i,j+\\frac{1}{2}}^{s} - v_{i,j-\\frac{1}{2}}^{s}}{\\Delta y}.$$\n\n使用上述定义和合成的 $p_{i,j}$，推导为何对于棋盘状模式，同位网格的中心差分会得出 $\\left(\\partial p / \\partial x\\right)_{i,j} = 0$ 和 $\\left(\\partial p / \\partial y\\right)_{i,j} = 0$，而交错网格的面差分不为零，因此同位网格的散度可忽略不计，而交错网格的散度不可忽略。为量化此效应，定义格式 $\\star \\in \\{c, s\\}$ 的均方根（RMS）散度为\n$$\\mathcal{D}_{\\star} = \\sqrt{\\frac{1}{N_x N_y} \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\left(\\nabla \\cdot \\mathbf{u}^{\\star}\\right)_{i,j}^2}.$$\n作为抑制度量，报告无量纲比率\n$$\\mathcal{R} = \\frac{\\mathcal{D}_{s}}{\\mathcal{D}_{c} + \\varepsilon},$$\n其中 $\\varepsilon$ 是一个小的正数，以避免除以零，其值与 $\\mathcal{D}_{s}$ 成比例（例如，$\\varepsilon = 10^{-16} \\mathcal{D}_{s}$）。一个大的 $\\mathcal{R}$ 值表明交错网格格式将压力与质量通量强耦合，从而相对于朴素的同位网格格式更有效地抑制了振荡。\n\n物理单位：$p_0$ 的单位为 $\\mathrm{Pa}$，$\\rho$ 的单位为 $\\mathrm{kg/m^3}$，$\\Delta x$ 和 $\\Delta y$ 的单位为 $\\mathrm{m}$，$\\Delta t$ 的单位为 $\\mathrm{s}$。输出比率 $\\mathcal{R}$ 是无量纲的。\n\n测试套件：为以下参数集运行您的程序，每个参数集指定为 $(N_x, N_y, \\Delta x, \\Delta y, \\rho, \\Delta t, p_0)$：\n- 案例A（一般情况）：$(32, 32, 1.0\\times 10^{-2}, 1.0\\times 10^{-2}, 1.0, 1.0\\times 10^{-3}, 1.0)$。\n- 案例B（粗网格边界情况）：$(8, 8, 1.0\\times 10^{-2}, 1.0\\times 10^{-2}, 1.0, 5.0\\times 10^{-4}, 1.0)$。\n- 案例C（各向异性通道纵横比）：$(64, 4, 5.0\\times 10^{-3}, 1.25\\times 10^{-2}, 1.0, 2.0\\times 10^{-3}, 1.0)$。\n\n您的程序应生成单行输出，其中包含案例A、B和C的三个抑制比率，形式为用方括号括起来的逗号分隔列表（例如，$[\\mathcal{R}_A,\\mathcal{R}_B,\\mathcal{R}_C]$）。该输出必须是单行十进制表示的浮点数列表。不应打印任何其他文本。所有中间量在内部应以上述指定的适当单位表示；最终的比率是无量纲的。",
            "solution": "当前的问题是计算流体动力学（CFD）中的一个经典数值实验，旨在说明不同网格布置下的压力-速度耦合问题。具体来说，它对比了一种朴素的同位网格（其中所有变量（$u$、$v$、$p$）都存储在网格中心）和一种交错的标记与网格（MAC）网格（其中标量压力 $p$ 在网格中心，而速度分量 $u$ 和 $v$ 存储在网格面）。核心问题是，某些非物理性的压力振荡（称为棋盘状模式）可能存在，而朴素同位网格格式的离散算子无法检测到它们，从而导致数值不稳定性。交错网格由于其构造方式，能正确地将压力梯度与质量通量耦合，从而防止此类伪模式的出现。我们将首先进行解析证明，然后通过数值方法进行验证。\n\n分析是基于一个定义在间距为 $\\Delta x$ 和 $\\Delta y$ 的均匀 $N_x \\times N_y$ 网格上的合成棋盘状压力场进行的。网格单元 $(i,j)$ 中心的压力由\n$$p_{i,j} = p_0 (-1)^{i+j},$$\n给出，其中 $p_0$ 是振幅。此分析依赖于评估由投影法的压力校正步骤（$\\mathbf{u}^{\\star} = -(\\Delta t / \\rho) \\nabla p$）单独引起的速度场的散度，为简单起见，我们分析从零状态诱导出的速度场。假设采用周期性边界条件，并且所有测试案例中 $N_x$ 和 $N_y$ 均为偶数。\n\n### 朴素同位网格格式分析\n\n在同位网格格式中，所有变量，包括压力 $p$ 和速度分量 $u$ 和 $v$，都存储在网格中心 $(i,j)$。\n\n1.  **压力梯度计算**：在网格中心 $(i,j)$ 处，使用中心差分来近似压力梯度分量：\n    $$ \\left(\\frac{\\partial p}{\\partial x}\\right)_{i,j} \\approx \\frac{p_{i+1,j} - p_{i-1,j}}{2\\Delta x} \\quad \\text{和} \\quad \\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j} \\approx \\frac{p_{i,j+1} - p_{i,j-1}}{2\\Delta y}。 $$\n    代入棋盘状压力场 $p_{i,j} = p_0 (-1)^{i+j}$：\n    $$ \\frac{p_{i+1,j} - p_{i-1,j}}{2\\Delta x} = \\frac{p_0(-1)^{(i+1)+j} - p_0(-1)^{(i-1)+j}}{2\\Delta x} = \\frac{p_0(-1)^{i+j}}{2\\Delta x} \\left( (-1)^1 - (-1)^{-1} \\right) = \\frac{p_0(-1)^{i+j}}{2\\Delta x} (-1 - (-1)) = 0。 $$\n    同样，对于 $y$-梯度：\n    $$ \\frac{p_{i,j+1} - p_{i,j-1}}{2\\Delta y} = \\frac{p_0(-1)^{i+(j+1)} - p_0(-1)^{i+(j-1)}}{2\\Delta y} = \\frac{p_0(-1)^{i+j}}{2\\Delta y} \\left( (-1)^1 - (-1)^{-1} \\right) = 0。 $$\n    由于周期性条件以及每个方向上偶数个网格单元，该结论对所有内部点以及边界都成立。$2\\Delta x$ 的中心差分格式对网格上的最高频率（奈奎斯特）模式是“盲”的。\n\n2.  **速度场与散度**：在网格中心由压力校正引起的速度分量，记为 $\\mathbf{u}^c = (u^c, v^c)$，为：\n    $$ u_{i,j}^{c} = -\\frac{\\Delta t}{\\rho}\\left(\\frac{\\partial p}{\\partial x}\\right)_{i,j} = 0, \\quad v_{i,j}^{c} = -\\frac{\\Delta t}{\\rho}\\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j} = 0。 $$\n    所有网格中心的速度均为零。\n\n3.  **质量通量与散度**：该格式通过平均网格中心的速度来构造网格面上的质量通量。对于位于 $(i+\\frac{1}{2}, j)$ 的面：\n    $$ u_{i+\\frac{1}{2},j}^{c} = \\frac{u_{i,j}^{c} + u_{i+1,j}^{c}}{2} = \\frac{0 + 0}{2} = 0。 $$\n    同样，$v_{i,j+\\frac{1}{2}}^{c} = 0$。由于所有面通量均为零，网格单元 $(i,j)$ 处的离散散度恒为零：\n    $$ \\left(\\nabla \\cdot \\mathbf{u}^{c}\\right)_{i,j} = \\frac{u_{i+\\frac{1}{2},j}^{c} - u_{i-\\frac{1}{2},j}^{c}}{\\Delta x} + \\frac{v_{i,j+\\frac{1}{2}}^{c} - v_{i,j-\\frac{1}{2}}^{c}}{\\Delta y} = 0。 $$\n    因此，同位网格格式的均方根（RMS）散度为 $\\mathcal{D}_{c} = 0$。在数值实现中，该值会受到浮点误差的影响，但应可忽略不计（在机器精度量级）。\n\n### 交错（MAC）网格格式分析\n\n在交错网格格式中，压力 $p$ 位于网格中心 $(i,j)$，$u$-速度分量位于垂直面 $(i+\\frac{1}{2}, j)$，$v$-速度分量位于水平面 $(i, j+\\frac{1}{2})$。\n\n1.  **面速度计算**：直接跨单个网格单元计算压力梯度，以求得面上的速度。对于面 $(i+\\frac{1}{2}, j)$ 上的 $u$-速度，记为 $u^s_{i+\\frac{1}{2},j}$：\n    $$ u_{i+\\frac{1}{2},j}^{s} = -\\frac{\\Delta t}{\\rho} \\frac{p_{i+1,j} - p_{i,j}}{\\Delta x} = -\\frac{\\Delta t}{\\rho \\Delta x} \\left[ p_0(-1)^{(i+1)+j} - p_0(-1)^{i+j} \\right] $$\n    $$ = -\\frac{\\Delta t p_0(-1)^{i+j}}{\\rho \\Delta x} \\left[ (-1)^1 - 1 \\right] = \\frac{2 \\Delta t p_0}{\\rho \\Delta x} (-1)^{i+j}。 $$\n    同样，对于面 $(i, j+\\frac{1}{2})$ 上的 $v$-速度：\n    $$ v_{i,j+\\frac{1}{2}}^{s} = -\\frac{\\Delta t}{\\rho} \\frac{p_{i,j+1} - p_{i,j}}{\\Delta y} = \\frac{2 \\Delta t p_0}{\\rho \\Delta y} (-1)^{i+j}。 $$\n    与同位网格格式不同，交错网格布置在响应棋盘状压力时会产生一个非零的速度场。\n\n2.  **散度计算**：网格中心 $(i,j)$ 处的离散散度为：\n    $$ \\left(\\nabla \\cdot \\mathbf{u}^{s}\\right)_{i,j} = \\frac{u_{i+\\frac{1}{2},j}^{s} - u_{i-\\frac{1}{2},j}^{s}}{\\Delta x} + \\frac{v_{i,j+\\frac{1}{2}}^{s} - v_{i,j-\\frac{1}{2}}^{s}}{\\Delta y}。 $$\n    我们需要左侧面上的速度 $u_{i-\\frac{1}{2},j}^{s}$，其计算方式如下：\n    $$ u_{i-\\frac{1}{2},j}^{s} = \\frac{2 \\Delta t p_0}{\\rho \\Delta x} (-1)^{(i-1)+j} = -\\frac{2 \\Delta t p_0}{\\rho \\Delta x} (-1)^{i+j}。 $$\n    代入散度表达式：\n    $$ \\frac{u_{i+\\frac{1}{2},j}^{s} - u_{i-\\frac{1}{2},j}^{s}}{\\Delta x} = \\frac{1}{\\Delta x} \\left[ \\frac{2 \\Delta t p_0}{\\rho \\Delta x} (-1)^{i+j} - \\left(-\\frac{2 \\Delta t p_0}{\\rho \\Delta x} (-1)^{i+j}\\right) \\right] = \\frac{4 \\Delta t p_0}{\\rho (\\Delta x)^2} (-1)^{i+j}。 $$\n    $y$-方向的项是类似的。总散度为：\n    $$ \\left(\\nabla \\cdot \\mathbf{u}^{s}\\right)_{i,j} = \\left[ \\frac{4 \\Delta t p_0}{\\rho (\\Delta x)^2} + \\frac{4 \\Delta t p_0}{\\rho (\\Delta y)^2} \\right] (-1)^{i+j} = \\frac{4 \\Delta t p_0}{\\rho} \\left( \\frac{1}{(\\Delta x)^2} + \\frac{1}{(\\Delta y)^2} \\right) (-1)^{i+j}。 $$\n    此表达式代表压力场的离散拉普拉斯算子，证实了交错网格的散度算子与压力变化是强耦合的。散度显然不为零。\n\n3.  **均方根散度**：为了求得均方根散度 $\\mathcal{D}_s$，我们将每个网格单元的散度平方，在整个网格上取平均，然后取平方根。项 $(-1)^{i+j}$ 的平方为 $1$，使得散度的平方在所有网格单元上为常数：\n    $$ \\left( \\left(\\nabla \\cdot \\mathbf{u}^{s}\\right)_{i,j} \\right)^2 = \\left[ \\frac{4 \\Delta t p_0}{\\rho} \\left( \\frac{1}{(\\Delta x)^2} + \\frac{1}{(\\Delta y)^2} \\right) \\right]^2。 $$\n    均方根值就是这个常数因子的绝对值：\n    $$ \\mathcal{D}_{s} = \\frac{4 \\Delta t p_0}{\\rho} \\left( \\frac{1}{(\\Delta x)^2} + \\frac{1}{(\\Delta y)^2} \\right)。 $$\n    这是一个非零且不可忽略的值。\n\n### 抑制度量\n\n抑制度量 $\\mathcal{R}$ 定义为 $\\mathcal{R} = \\mathcal{D}_{s} / (\\mathcal{D}_{c} + \\varepsilon)$。由于我们发现 $\\mathcal{D}_{c}$ 解析上为零（数值上可忽略不计），分母主要由正则化项 $\\varepsilon = 10^{-16} \\mathcal{D}_{s}$ 决定。\n$$ \\mathcal{R} = \\frac{\\mathcal{D}_{s}}{\\mathcal{D}_{c} + 10^{-16} \\mathcal{D}_{s}} \\approx \\frac{\\mathcal{D}_{s}}{10^{-16} \\mathcal{D}_{s}} = 10^{16}。 $$\n一个非常大的 $\\mathcal{R}$ 值表示交错网格在响应棋盘状压力模式时会产生强散度（一个强的校正信号），而朴素的同位网格几乎不产生任何信号。这种能够“看到”并因此校正高频压力振荡的能力是交错网格布置的根本优势。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_suppression_ratio(Nx, Ny, dx, dy, rho, dt, p0):\n    \"\"\"\n    Derives and implements discrete operators for collocated and staggered grids\n    to demonstrate the pressure-velocity decoupling problem for a checkerboard\n    pressure field.\n\n    Args:\n        Nx (int): Number of grid cells in the x-direction.\n        Ny (int): Number of grid cells in the y-direction.\n        dx (float): Grid spacing in the x-direction.\n        dy (float): Grid spacing in the y-direction.\n        rho (float): Fluid density.\n        dt (float): Time step.\n        p0 (float): Amplitude of the pressure field.\n\n    Returns:\n        float: The suppression ratio R = D_s / (D_c + epsilon).\n    \"\"\"\n\n    # Create grid and synthetic checkerboard pressure field\n    # Grid indices i (cols), j (rows) correspond to x, y directions.\n    # Numpy arrays are (row, col) so we map (j, i).\n    # axis=0 corresponds to j (y), axis=1 corresponds to i (x)\n    i_indices, j_indices = np.meshgrid(np.arange(Nx), np.arange(Ny))\n    p = p0 * (-1.0)**(i_indices + j_indices)\n\n    # --- Naive Collocated Scheme ---\n\n    # 1. Calculate pressure gradients at cell centers using central differences.\n    #    Periodic boundaries are handled by np.roll.\n    dp_dx = (np.roll(p, -1, axis=1) - np.roll(p, 1, axis=1)) / (2.0 * dx)\n    dp_dy = (np.roll(p, -1, axis=0) - np.roll(p, 1, axis=0)) / (2.0 * dy)\n\n    # 2. Calculate pressure-correction-induced velocities at cell centers.\n    u_c = - (dt / rho) * dp_dx\n    v_c = - (dt / rho) * dp_dy\n\n    # 3. Interpolate cell-centered velocities to faces.\n    # u_face_c at index (j, i) corresponds to face (i+1/2, j).\n    u_face_c = (u_c + np.roll(u_c, -1, axis=1)) / 2.0\n    v_face_c = (v_c + np.roll(v_c, -1, axis=0)) / 2.0\n\n    # 4. Compute cell-centered divergence from face fluxes.\n    # div_x component is (u_face(i+1/2) - u_face(i-1/2)) / dx.\n    # u_face(i-1/2, j) is u_face_c rolled by 1 along axis=1.\n    div_c_x = (u_face_c - np.roll(u_face_c, 1, axis=1)) / dx\n    div_c_y = (v_face_c - np.roll(v_face_c, 1, axis=0)) / dy\n    div_c = div_c_x + div_c_y\n\n    # 5. Calculate RMS divergence for the collocated scheme.\n    D_c = np.sqrt(np.mean(div_c**2))\n\n    # --- Staggered MAC Scheme ---\n\n    # 1. Calculate pressure-correction-induced velocities directly at faces.\n    # u_s at index (j, i) corresponds to face (i+1/2, j).\n    u_s = - (dt / rho) * (np.roll(p, -1, axis=1) - p) / dx\n    v_s = - (dt / rho) * (np.roll(p, -1, axis=0) - p) / dy\n\n    # 2. Compute cell-centered divergence from face velocities.\n    # div_x at (i,j) is (u_s(i+1/2,j) - u_s(i-1/2,j)) / dx.\n    # u_s(i-1/2,j) is u_s rolled by 1 along axis=1.\n    div_s_x = (u_s - np.roll(u_s, 1, axis=1)) / dx\n    div_s_y = (v_s - np.roll(v_s, 1, axis=0)) / dy\n    div_s = div_s_x + div_s_y\n\n    # 3. Calculate RMS divergence for the staggered scheme.\n    D_s = np.sqrt(np.mean(div_s**2))\n\n    # --- Suppression Metric ---\n    # As per the problem, use a small epsilon proportional to D_s.\n    epsilon = 1e-16 * D_s\n    R = D_s / (D_c + epsilon)\n    \n    return R\n    \ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Test suite: (Nx, Ny, dx, dy, rho, dt, p0)\n    test_cases = [\n        # Case A (general case)\n        (32, 32, 1.0e-2, 1.0e-2, 1.0, 1.0e-3, 1.0),\n        # Case B (coarse grid edge case)\n        (8, 8, 1.0e-2, 1.0e-2, 1.0, 5.0e-4, 1.0),\n        # Case C (anisotropic channel aspect)\n        (64, 4, 5.0e-3, 1.25e-2, 1.0, 2.0e-3, 1.0)\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, Ny, dx, dy, rho, dt, p0 = case\n        result = calculate_suppression_ratio(Nx, Ny, dx, dy, rho, dt, p0)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在理解了空间离散化的挑战之后，本练习将理论付诸实践，要求您实现一种经典的分步射影法（projection method）。您将为一个经典的CFD基准问题——顶盖驱动方腔流，求解压力场以强制满足不可压缩性条件。此实践清晰地展示了射影法的核心思想：首先预测一个满足动量方程的中间速度场，然后将其投影到一个无散度空间以满足质量守恒 。",
            "id": "3994286",
            "problem": "考虑一个在 $2D$ 方形驱动腔内的不可压缩流，其区域为 $[0,1]\\times[0,1]$，使用 $N_x=N_y=N$ 个点的均匀网格，均匀间距为 $h=1/(N-1)$，速度场 $\\mathbf{u}=(u,v)$ 在单元中心离散。顶部边界的盖子具有给定的水平速度 $u=U_0$ 和垂直速度 $v=0$，而所有其他壁面强制执行无滑移条件 $u=0$ 和 $v=0$。假设使用无量纲变量，流体密度等于 $1$。\n\n目标是使用投影法计算压力场以解决压力-速度耦合问题，并测量投影前后的离散散度范数。基本方程是不可压缩连续性方程 $\\nabla\\cdot\\mathbf{u}=0$ 和动量方程 $\\partial_t\\mathbf{u}+\\text{advection}=-\\nabla p + \\nu \\nabla^2 \\mathbf{u}$，其中 $\\nu$ 是运动粘度，$p$ 是压力。\n\n一个时间步的算法如下进行，从内部的初始速度 $\\mathbf{u}^n=\\mathbf{0}$ 开始：\n\n1. 使用二阶中心差分 $5$ 点模板为每个分量计算中间速度 $\\mathbf{u}^\\star=\\mathbf{u}^n+\\nu\\,\\Delta t\\,\\nabla^2\\mathbf{u}^n$。在此扩散更新前后，均在顶部边界上强制施加速度边界条件 $u=U_0$ 和 $v=0$，在其余壁面上强制施加 $u=0$，$v=0$。\n\n2. 通过中心差分计算内部 $\\mathbf{u}^\\star$ 的离散散度，\n   $$\\left(\\nabla\\cdot\\mathbf{u}^\\star\\right)_{i,j}=\\frac{u^\\star_{i+1,j}-u^\\star_{i-1,j}}{2h}+\\frac{v^\\star_{i,j+1}-v^\\star_{i,j-1}}{2h},$$\n   对于 $i=1,\\dots,N-2$ 和 $j=1,\\dots,N-2$，并在边界索引处将散度设置为 $0$。将内部点的散度的离散 $L^2$ 范数定义为\n   $$\\|\\nabla\\cdot\\mathbf{u}^\\star\\|_{2}=\\left(h^2 \\sum_{i=1}^{N-2}\\sum_{j=1}^{N-2} \\left(\\nabla\\cdot\\mathbf{u}^\\star\\right)_{i,j}^2\\right)^{1/2}.$$\n\n3. 求解从投影法导出的压力泊松方程，\n   $$\\nabla^2 p^{n+1}=\\frac{1}{\\Delta t}\\,\\nabla\\cdot\\mathbf{u}^\\star,$$\n   在所有壁面上采用齐次诺伊曼边界条件 $\\partial p/\\partial n=0$，并在中心网格点施加单个参考约束 $p^{n+1}=0$ 以消除零空间。在内部使用采用 $5$ 点模板的 $\\nabla^2$ 的二阶有限差分近似，并在边界处使用强制 $\\partial p/\\partial n=0$ 的单边镜像条件，例如使用 $p_{\\text{ghost}}=p_{\\text{adjacent}}$，这导致边界法向二阶导数的形式为 $2\\,(p_{\\text{adjacent}}-p_{\\text{boundary}})/h^2$。\n\n4. 通过以下方式投影中间速度以强制执行不可压缩性\n   $$\\mathbf{u}^{n+1}=\\mathbf{u}^\\star-\\Delta t\\,\\nabla p^{n+1},$$\n   其中梯度在内部使用二阶中心差分计算，在边界使用单边差分计算；然后在顶盖处重新应用速度边界条件 $u=U_0$ 和 $v=0$，在其他地方应用 $u=0$，$v=0$。\n\n5. 使用步骤2中相同的定义，计算内部的离散散度范数 $\\|\\nabla\\cdot\\mathbf{u}^{n+1}\\|_2$。\n\n所有量均为无量纲；将散度范数报告为无量纲实数。为以下参数值的测试套件实现上述方法：\n- 测试 1：$N=33$，$\\Delta t=0.001$，$\\nu=0.001$，$U_0=1.0$。\n- 测试 2：$N=17$，$\\Delta t=0.0005$，$\\nu=0.1$，$U_0=1.0$。\n- 测试 3：$N=33$，$\\Delta t=0.002$，$\\nu=0.001$，$U_0=0.0$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个形式为 $[\\|\\nabla\\cdot\\mathbf{u}^\\star\\|_2,\\|\\nabla\\cdot\\mathbf{u}^{n+1}\\|_2]$ 的双元素列表。例如，输出格式必须是\n$$[[a_1,b_1],[a_2,b_2],[a_3,b_3]],$$\n其中每个 $a_k$ 和 $b_k$ 是对应于测试 $k$ 的范数的实数。",
            "solution": "问题陈述已经过严格验证，并被认为是合理的。它概述了计算流体动力学中的一个标准数值练习，具体是为不可压缩Navier-Stokes方程实现投影法的单个时间步，并简化为不可压缩Stokes方程以分离压力-速度耦合机制。该问题是自包含的、有科学依据且适定的，提供了所有必要的方程、边界条件、离散化方案和参数。\n\n解决方案通过逐步实现指定的算法来进行。所有数学实体都按要求用 LaTeX 表示。\n\n### 1. 离散化和初始状态\n区域为一方形 $[0,1] \\times [0,1]$，通过具有 $N_x = N_y = N$ 个点的均匀同位网格进行离散。网格间距为 $h = 1/(N-1)$。网格索引 $(i,j)$ 在 $x$ 和 $y$ 方向上均从 $0$ 到 $N-1$，其中 $i$ 对应 $x$ 方向，$j$ 对应 $y$ 方向。速度场为 $\\mathbf{u} = (u,v)$，压力为 $p$。\n\n时间 $t^n$ 的初始速度场对于所有内部点给定为 $\\mathbf{u}^n = (u^n, v^n) = \\mathbf{0}$。边界条件施加在 $\\mathbf{u}^n$ 上：\n-   顶部边界 ($j=N-1$): $u^n_{i,N-1} = U_0$ 对于 $i \\in [0, N-1]$, $v^n_{i,N-1} = 0$。请注意，在角点，侧壁的无滑移条件优先，因此 $u^n_{0,N-1}=0$ 和 $u^n_{N-1,N-1}=0$。\n-   其他边界 (底部、左侧、右侧): 无滑移条件，$u^n=0$ 和 $v^n=0$。\n\n### 2. 中间速度计算\n第一步是通过对初始速度场 $\\mathbf{u}^n$ 应用扩散步骤来计算中间速度场 $\\mathbf{u}^\\star$。根据该步骤的问题设定，省略了对流项。\n$$\n\\mathbf{u}^\\star = \\mathbf{u}^n + \\nu \\Delta t \\nabla^2 \\mathbf{u}^n\n$$\n拉普拉斯算子 $\\nabla^2$ 使用二阶中心差分5点模板对内部点进行离散化，即对于 $i,j \\in [1, N-2]$：\n$$\n(\\nabla^2 u^n)_{i,j} = \\frac{u^n_{i+1,j} + u^n_{i-1,j} + u^n_{i,j+1} + u^n_{i,j-1} - 4u^n_{i,j}}{h^2}\n$$\n一个类似的表达式对 $(\\nabla^2 v^n)_{i,j}$ 成立。为所有内部点计算中间速度 $u^\\star$ 和 $v^\\star$。计算后，在 $\\mathbf{u}^\\star$ 场上重新强制施加给定的速度边界条件。\n\n### 3. 中间速度的散度\n中间速度场 $\\mathbf{u}^\\star$ 的离散散度在内部网格点 $(i,j)$（对于 $i,j \\in [1, N-2]$）使用二阶中心差分计算：\n$$\n(\\nabla \\cdot \\mathbf{u}^\\star)_{i,j} = \\frac{u^\\star_{i+1,j} - u^\\star_{i-1,j}}{2h} + \\frac{v^\\star_{i,j+1} - v^\\star_{i,j-1}}{2h}\n$$\n在所有边界点，散度被设置为零。然后，在区域内部计算此散度场的离散 $L^2$ 范数：\n$$\n\\|\\nabla \\cdot \\mathbf{u}^\\star\\|_2 = \\left( h^2 \\sum_{i=1}^{N-2} \\sum_{j=1}^{N-2} \\left( (\\nabla \\cdot \\mathbf{u}^\\star)_{i,j} \\right)^2 \\right)^{1/2}\n$$\n该值量化了中间速度场未能满足不可压缩性约束的程度。\n\n### 4. 压力泊松方程\n为了在最终速度场上强制不可压缩性，通过求解压力泊松方程（PPE）来找到压力场 $p^{n+1}$：\n$$\n\\nabla^2 p^{n+1} = \\frac{1}{\\Delta t} \\nabla \\cdot \\mathbf{u}^\\star\n$$\n该方程在所有边界上均服从齐次诺伊曼边界条件 $\\partial p / \\partial n = 0$，其中 $n$ 是垂直于边界的方向。左侧的拉普拉斯算子使用包含这些边界条件的5点模板进行离散化。这产生了一个线性方程组 $A\\mathbf{p} = \\mathbf{b}$，其中 $\\mathbf{p}$ 是所有 $N \\times N$ 个网格点上未知压力值的向量，$A$ 是表示离散化拉普拉斯算子的矩阵，$\\mathbf{b}$ 是表示源项 $(1/\\Delta t) \\nabla \\cdot \\mathbf{u}^\\star$ 的向量。\n\n对于一个内部点 $(i,j)$，方程为：\n$$\n\\frac{p_{i+1,j} + p_{i-1,j} + p_{i,j+1} + p_{i,j-1} - 4p_{i,j}}{h^2} = \\frac{(\\nabla \\cdot \\mathbf{u}^\\star)_{i,j}}{\\Delta t}\n$$\n对于一个边界点，模板被修改以反映 $\\partial p / \\partial n = 0$ 条件。例如，在底部边界点 $(i,0)$，对于 $i \\in [1, N-2]$，条件 $\\partial p/\\partial y = 0$ 通过使用一个虚点 $p_{i,-1} = p_{i,1}$ 来实现，从而得到离散化方程：\n$$\n\\frac{p_{i+1,0} + p_{i-1,0} + 2p_{i,1} - 4p_{i,0}}{h^2} = \\frac{(\\nabla \\cdot \\mathbf{u}^\\star)_{i,0}}{\\Delta t}\n$$\n为所有其他边界点和角点推导出类似的表达式。得到的矩阵 $A$ 是奇异的。为了获得唯一解，通过在中心网格点 $((N-1)/2, (N-1)/2)$ 强制 $p^{n+1}=0$ 来设定一个参考压力。这是通过将矩阵系统中相应的行替换为约束方程来实现的。然后求解得到的非奇异线性系统以获得压力场 $p^{n+1}$。\n\n### 5. 速度投影\n中间速度 $\\mathbf{u}^\\star$ 被投影到无散度场空间上，以产生最终的、无散度的速度场 $\\mathbf{u}^{n+1}$：\n$$\n\\mathbf{u}^{n+1} = \\mathbf{u}^\\star - \\Delta t \\nabla p^{n+1}\n$$\n压力梯度 $\\nabla p^{n+1}$ 在内部使用二阶中心差分计算，在边界使用一阶单边差分计算。对于一个内部点 $(i,j)$:\n$$\n(\\nabla p^{n+1})_{i,j} = \\left( \\frac{p^{n+1}_{i+1,j} - p^{n+1}_{i-1,j}}{2h}, \\frac{p^{n+1}_{i,j+1} - p^{n+1}_{i,j-1}}{2h} \\right)\n$$\n在边界上，例如在左边界 $i=0$：\n$$\n\\left(\\frac{\\partial p^{n+1}}{\\partial x}\\right)_{0,j} = \\frac{p^{n+1}_{1,j} - p^{n+1}_{0,j}}{h}\n$$\n在计算完 $u^{n+1}$ 和 $v^{n+1}$ 后，重新应用速度边界条件，以最终确定新时间步的速度场。\n\n### 6. 校正后速度的散度\n最后，使用与步骤3中相同的公式，在内部点上计算校正后速度场 $\\nabla \\cdot \\mathbf{u}^{n+1}$ 的离散散度及其 $L^2$ 范数 $\\|\\nabla \\cdot \\mathbf{u}^{n+1}\\|_2$。预计该范数将显著小于 $\\|\\nabla \\cdot \\mathbf{u}^\\star\\|_2$，这证明了投影法在强制执行不可压缩性约束方面的有效性。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that iterates through test cases and prints results.\n    \"\"\"\n    test_cases = [\n        # (N, dt, nu, U0)\n        (33, 0.001, 0.001, 1.0),\n        (17, 0.0005, 0.1, 1.0),\n        (33, 0.002, 0.001, 0.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        norm_star, norm_np1 = solve_one_case(*case)\n        results.append([norm_star, norm_np1])\n    \n    # Format the output as specified: [[a1,b1],[a2,b2],[a3,b3]]\n    inner_results = [f\"[{r[0]},{r[1]}]\" for r in results]\n    print(f\"[{','.join(inner_results)}]\")\n\ndef solve_one_case(N, dt, nu, U0):\n    \"\"\"\n    Solves the problem for a single set of parameters.\n    \"\"\"\n    h = 1.0 / (N - 1)\n\n    # 1. Initialization\n    u_n = np.zeros((N, N))\n    v_n = np.zeros((N, N))\n\n    # Apply velocity boundary conditions\n    u_n[:, N-1] = U0\n    u_n[0, N-1] = 0.0   # Corner no-slip (left-top)\n    u_n[N-1, N-1] = 0.0 # Corner no-slip (right-top)\n\n    # 2. Compute intermediate velocity u_star\n    u_star = u_n.copy()\n    v_star = v_n.copy()\n\n    # Diffusion step for interior points\n    lap_u = (u_n[2:, 1:-1] + u_n[:-2, 1:-1] + u_n[1:-1, 2:] + u_n[1:-1, :-2] - 4 * u_n[1:-1, 1:-1]) / h**2\n    lap_v = (v_n[2:, 1:-1] + v_n[:-2, 1:-1] + v_n[1:-1, 2:] + v_n[1:-1, :-2] - 4 * v_n[1:-1, 1:-1]) / h**2\n    \n    u_star[1:-1, 1:-1] = u_n[1:-1, 1:-1] + nu * dt * lap_u\n    v_star[1:-1, 1:-1] = v_n[1:-1, 1:-1] + nu * dt * lap_v\n    \n    # Re-apply boundary conditions on u_star (already set for v_star as it's 0)\n    u_star[:, N-1] = U0\n    u_star[0, N-1] = 0.0\n    u_star[N-1, N-1] = 0.0\n\n    # 3. Compute divergence of u_star\n    div_u_star = np.zeros((N, N))\n    div_u_star[1:-1, 1:-1] = (u_star[2:, 1:-1] - u_star[:-2, 1:-1]) / (2 * h) + \\\n                             (v_star[1:-1, 2:] - v_star[1:-1, :-2]) / (2 * h)\n    \n    norm_div_u_star = np.sqrt(h**2 * np.sum(div_u_star[1:-1, 1:-1]**2))\n\n    # 4. Solve Pressure Poisson Equation\n    # RHS of Poisson equation\n    b_poisson = (div_u_star / dt)\n    \n    # Assemble the matrix for the linear system Ap = b\n    N_sq = N * N\n    A = np.zeros((N_sq, N_sq))\n    h2 = h**2\n    \n    k_map = np.arange(N_sq).reshape((N, N))\n\n    for i in range(N):\n        for j in range(N):\n            k = k_map[i, j]\n            \n            if i > 0 and i  N - 1 and j > 0 and j  N - 1: # Interior\n                A[k, k] = -4.0; A[k, k_map[i+1, j]] = 1.0; A[k, k_map[i-1, j]] = 1.0; A[k, k_map[i, j+1]] = 1.0; A[k, k_map[i, j-1]] = 1.0\n            elif i == 0 and j == 0: # Corner BL\n                A[k, k] = -4.0; A[k, k_map[i+1, j]] = 2.0; A[k, k_map[i, j+1]] = 2.0\n            elif i == N-1 and j == 0: # Corner BR\n                A[k, k] = -4.0; A[k, k_map[i-1, j]] = 2.0; A[k, k_map[i, j+1]] = 2.0\n            elif i == 0 and j == N-1: # Corner TL\n                A[k, k] = -4.0; A[k, k_map[i+1, j]] = 2.0; A[k, k_map[i, j-1]] = 2.0\n            elif i == N-1 and j == N-1: # Corner TR\n                A[k, k] = -4.0; A[k, k_map[i-1, j]] = 2.0; A[k, k_map[i, j-1]] = 2.0\n            elif i == 0: # Left edge\n                A[k, k] = -4.0; A[k, k_map[i+1, j]] = 2.0; A[k, k_map[i, j+1]] = 1.0; A[k, k_map[i, j-1]] = 1.0\n            elif i == N-1: # Right edge\n                A[k, k] = -4.0; A[k, k_map[i-1, j]] = 2.0; A[k, k_map[i, j+1]] = 1.0; A[k, k_map[i, j-1]] = 1.0\n            elif j == 0: # Bottom edge\n                A[k, k] = -4.0; A[k, k_map[i+1, j]] = 1.0; A[k, k_map[i-1, j]] = 1.0; A[k, k_map[i, j+1]] = 2.0\n            elif j == N-1: # Top edge\n                A[k, k] = -4.0; A[k, k_map[i+1, j]] = 1.0; A[k, k_map[i-1, j]] = 1.0; A[k, k_map[i, j-1]] = 2.0\n\n    A /= h2\n\n    # Apply pressure pinning constraint p=0 at center\n    center_idx = (N - 1) // 2\n    k_center = k_map[center_idx, center_idx]\n    A[k_center, :] = 0.0\n    A[k_center, k_center] = 1.0\n\n    b_flat = b_poisson.flatten()\n    b_flat[k_center] = 0.0\n\n    # Solve for pressure\n    p_flat = np.linalg.solve(A, b_flat)\n    p = p_flat.reshape((N, N))\n\n    # 5. Project velocity\n    dpdx = np.zeros((N, N))\n    dpdy = np.zeros((N, N))\n    \n    # Interior gradients (central difference)\n    dpdx[1:-1, :] = (p[2:, :] - p[:-2, :]) / (2 * h)\n    dpdy[:, 1:-1] = (p[:, 2:] - p[:, :-2]) / (2 * h)\n    \n    # Boundary gradients (one-sided difference)\n    dpdx[0, :] = (p[1, :] - p[0, :]) / h\n    dpdx[-1, :] = (p[-1, :] - p[-2, :]) / h\n    dpdy[:, 0] = (p[:, 1] - p[:, 0]) / h\n    dpdy[:, -1] = (p[:, -1] - p[:, -2]) / h\n\n    u_np1 = u_star - dt * dpdx\n    v_np1 = v_star - dt * dpdy\n    \n    # Reapply velocity boundary conditions\n    u_np1[:, 0] = 0.0; v_np1[:, 0] = 0.0\n    u_np1[:, -1] = U0; v_np1[:, -1] = 0.0\n    u_np1[0, :] = 0.0; v_np1[0, :] = 0.0\n    u_np1[-1, :] = 0.0; v_np1[-1, :] = 0.0\n    u_np1[0, -1] = 0.0 # Corner correction\n    u_np1[-1, -1] = 0.0 # Corner correction\n    \n    # 6. Compute divergence of u_np1\n    div_u_np1 = np.zeros((N, N))\n    div_u_np1[1:-1, 1:-1] = (u_np1[2:, 1:-1] - u_np1[:-2, 1:-1]) / (2 * h) + \\\n                              (v_np1[1:-1, 2:] - v_np1[1:-1, :-2]) / (2 * h)\n\n    norm_div_u_np1 = np.sqrt(h**2 * np.sum(div_u_np1[1:-1, 1:-1]**2))\n\n    return norm_div_u_star, norm_div_u_np1\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "最后的这项实践将引导您掌握一种更高级的算法——算子分裂的压力隐式方法（Pressure Implicit with Splitting of Operators, PISO）。您将为一个瞬态槽道流问题实现PISO算法，并观察在单个时间步内，多个校正步骤是如何逐步强制执行不可压缩性约束的。这个练习突出了PISO算法的非迭代特性及其在瞬态问题中实现紧密压力-速度耦合的高效性，这在许多工程仿真中是一项关键优势 。",
            "id": "3994256",
            "problem": "考虑在二维通道中的不可压缩层流，该通道在流向上的长度为 $L_x$，在壁面法向上的高度为 $L_y$。流体具有恒定的密度 $\\rho$ 和动力粘度 $\\mu$。流体在时间 $t=0$ 时从静止开始，并由一个大小为 $G$（单位为 $\\mathrm{Pa/m}$）的恒定流向压力梯度驱动。位于 $y=0$ 和 $y=L_y$ 的壁面强制执行无滑移速度边界条件，流向 $x$ 被视为周期性的。控制方程是针对恒定密度的不可压缩纳维-斯托克斯方程，\n$$\n\\rho \\frac{\\partial \\mathbf{u}}{\\partial t} + \\rho (\\mathbf{u}\\cdot\\nabla)\\mathbf{u} = -\\nabla p + \\mu \\nabla^2 \\mathbf{u} + \\rho \\mathbf{g},\n$$\n其中 $\\nabla\\cdot \\mathbf{u} = 0$，施加的恒定流向压力梯度 $G$ 被表示为一个等效于 $\\rho g_x = G$ 的均匀体力。对于从静止开始且雷诺数较小的瞬态启动过程，可以忽略对流项 $\\rho (\\mathbf{u}\\cdot\\nabla)\\mathbf{u}$，以便在算法实现中隔离压力-速度耦合效应。\n\n您必须实现算子分裂压力隐式（PISO）算法，在一个同位均匀笛卡尔网格上对该启动通道流进行压力和速度的时间耦合。该网格在 $x$ 方向上是周期性的，在 $y$ 方向上具有无滑移边界。每个时间步的算法必须至少执行以下序列：\n1. 使用前一时间步的压力场进行速度预测步，以获得中间速度 $\\mathbf{u}^*$。\n2. 进行第一次压力修正，通过求解一个由应用于 $\\mathbf{u}^*$ 的连续性方程导出的压力方程来强制不可压缩性，然后进行速度修正以获得 $\\mathbf{u}^{(1)}$。\n3. 进行第二次压力修正，以进一步减少散度，然后进行第二次速度修正以获得 $\\mathbf{u}^{(2)}$。\n您必须报告在每个时间步内，预测步、第一次修正步和第二次修正步子步骤中空间均方根散度范数 $\\|\\nabla\\cdot\\mathbf{u}\\|_2$ 的演变。为本问题之目的，将报告的范数定义为空间均方根（RMS）范数\n$$\n\\|\\nabla\\cdot\\mathbf{u}\\|_2 = \\sqrt{\\frac{1}{\\Omega}\\int_{\\Omega} \\left(\\nabla\\cdot\\mathbf{u}\\right)^2 \\, d\\Omega}\n$$\n其离散形式通过逐点散度平方值的算术平均值的平方根来近似。此量必须以 $\\mathrm{s^{-1}}$ 为单位报告。\n\n将域在 $x$ 方向离散为 $N_x$ 个点，在 $y$ 方向离散为 $N_y$ 个点，均匀间距分别为 $\\Delta x = L_x/N_x$ 和 $\\Delta y = L_y/N_y$。对扩散和压力梯度的空间导数使用二阶中心差分，对 $x$ 方向的模板使用周期性环绕，并在 $y=0$ 和 $y=L_y$ 处执行与无滑移速度和压力法向零梯度边界一致的适当边界处理。时间积分应使用与PISO框架一致的显式预测器，压力修正应通过求解一个由将连续性应用于预测速度场而产生的离散压力方程来获得。压力的唯一性应通过固定一个任意参考单元的压力值来强制执行。\n\n您的程序必须实现此算法，并为每个时间步计算和存储对应于预测步、第一次修正步和第二次修正步子步骤的三个 $\\|\\nabla\\cdot\\mathbf{u}\\|_2$ 值。程序必须针对构成测试套件的几个参数集运行模拟少量时间步。\n\n测试套件：\n- 情况A（标准情况）：$L_x = 1\\,\\mathrm{m}$，$L_y = 1\\,\\mathrm{m}$，$N_x = 16$，$N_y = 16$，$\\rho = 1\\,\\mathrm{kg/m^3}$，$\\mu = 0.01\\,\\mathrm{Pa\\cdot s}$，$G = 1\\,\\mathrm{Pa/m}$，时间步长 $\\Delta t = 5\\times 10^{-3}\\,\\mathrm{s}$，$N_{\\text{steps}} = 4$。\n- 情况B（更粗的网格和更大的时间步长边界条件）：$L_x = 1\\,\\mathrm{m}$，$L_y = 1\\,\\mathrm{m}$，$N_x = 8$，$N_y = 8$，$\\rho = 1\\,\\mathrm{kg/m^3}$，$\\mu = 0.1\\,\\mathrm{Pa\\cdot s}$，$G = 1\\,\\mathrm{Pa/m}$，时间步长 $\\Delta t = 10^{-2}\\,\\mathrm{s}$，$N_{\\text{steps}} = 3$。\n- 情况C（零驱动的边界情况）：$L_x = 1\\,\\mathrm{m}$，$L_y = 1\\,\\mathrm{m}$，$N_x = 16$，$N_y = 16$，$\\rho = 1\\,\\mathrm{kg/m^3}$，$\\mu = 0.01\\,\\mathrm{Pa\\cdot s}$，$G = 0\\,\\mathrm{Pa/m}$，时间步长 $\\Delta t = 5\\times 10^{-3}\\,\\mathrm{s}$，$N_{\\text{steps}} = 3$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含所有测试用例的聚合结果，格式为方括号内以逗号分隔的列表。对于每个测试用例，输出一个列表的列表，每个内部列表对应一个时间步，其中包含该时间步中预测步、第一次修正步和第二次修正步的三个浮点数值 $\\|\\nabla\\cdot\\mathbf{u}\\|_2$（单位为 $\\mathrm{s^{-1}}$）。例如，整体输出应如下所示：\n$[ \\text{caseA\\_results}, \\text{caseB\\_results}, \\text{caseC\\_results} ]$\n其中每个 $\\text{caseX\\_results}$ 本身就是一个浮点数列表的列表。这些值必须是不带任何单位符号的数字，单位如上文定义默认为 $\\mathrm{s^{-1}}$。",
            "solution": "用户提供了一个问题，要求为一个简化的二维、不可压缩、层流通道流实现算子分裂压力隐式（PISO）算法。所提供的问题陈述被验证为科学上合理、适定且客观。它包含了所有必要的信息，包括控制方程、边界和初始条件、离散化指南以及一组特定的测试参数。该问题是计算流体动力学（CFD）中一个标准的、尽管不平凡的练习，并且按其表述是可解的。\n\n我们现在将继续详细推导和描述数值方法，然后进行其实现。\n\n### 1. 控制方程\n\n该问题涉及通道中由恒定流向压力梯度 $G$ 驱动的流动的瞬态启动过程。对于低雷诺数情况，纳维-斯托克斯方程中的非线性对流项 $(\\mathbf{u}\\cdot\\nabla)\\mathbf{u}$ 被忽略。速度 $\\mathbf{u}=(u,v)$ 和压力 $p$ 的控制方程为：\n\n动量方程：\n$$ \\rho \\frac{\\partial \\mathbf{u}}{\\partial t} = -\\nabla p + \\mu \\nabla^2 \\mathbf{u} + \\mathbf{f} $$\n连续性方程（不可压缩性约束）：\n$$ \\nabla \\cdot \\mathbf{u} = 0 $$\n\n这里，$\\rho$ 是恒定的流体密度，$\\mu$ 是动力粘度，$\\mathbf{f}$ 是一个体力项。施加的压力梯度 $G$ 被建模为一个均匀的流向体力，因此 $\\mathbf{f} = (G, 0)$。\n\n### 2. 离散化\n\n方程在一个同位的、均匀的笛卡尔网格上进行离散化，该网格有 $N_x \\times N_y$ 个单元，其中所有变量（$u$、$v$、$p$）都存储在单元中心。单元尺寸为 $\\Delta x = L_x/N_x$ 和 $\\Delta y = L_y/N_y$。空间导数使用二阶中心差分进行近似。对于一个通用场 $\\phi$，算子为：\n\n梯度：\n$$ \\nabla \\phi \\approx \\left(\\frac{\\phi_{i,j+1} - \\phi_{i,j-1}}{2\\Delta x}, \\frac{\\phi_{i+1,j} - \\phi_{i-1,j}}{2\\Delta y}\\right) $$\n拉普拉斯算子：\n$$ \\nabla^2 \\phi \\approx \\frac{\\phi_{i,j+1} - 2\\phi_{i,j} + \\phi_{i,j-1}}{\\Delta x^2} + \\frac{\\phi_{i+1,j} - 2\\phi_{i,j} + \\phi_{i-1,j}}{\\Delta y^2} $$\n散度：\n$$ \\nabla \\cdot \\mathbf{u} \\approx \\frac{u_{i,j+1} - u_{i,j-1}}{2\\Delta x} + \\frac{v_{i+1,j} - v_{i-1,j}}{2\\Delta y} $$\n\n时间使用前向欧拉格式离散，时间步长为 $\\Delta t$。让上标 $n$ 表示在时间 $t^n$ 的值。\n\n### 3. PISO 算法\n\nPISO算法是一种用于压力-速度耦合的非迭代方法，它在单个时间步内执行一个预测步和多个修正步，以强制执行不可压缩性约束。对于此问题，我们实现一个预测步和两个修正步。设 $\\mathbf{u}^n$ 和 $p^n$ 是时间步开始时的已知场。\n\n**步骤1：速度预测**\n\n一个中间速度场 $\\mathbf{u}^*$ 是根据动量方程，使用前一时间步的压力场 $p^n$ 显式计算的。\n\n$$ \\frac{\\mathbf{u}^* - \\mathbf{u}^n}{\\Delta t} = \\frac{1}{\\rho} \\left( -\\nabla p^n + \\mu \\nabla^2 \\mathbf{u}^n + \\mathbf{f} \\right) $$\n整理后得到 $\\mathbf{u}^*$ 的预测方程：\n$$ \\mathbf{u}^* = \\mathbf{u}^n + \\frac{\\Delta t}{\\rho} \\left( -\\nabla p^n + \\mu \\nabla^2 \\mathbf{u}^n + \\mathbf{f} \\right) $$\n这个预测的速度场 $\\mathbf{u}^*$ 通常不满足连续性方程，即 $\\nabla \\cdot \\mathbf{u}^* \\neq 0$。该散度的空间均方根 $\\|\\nabla \\cdot \\mathbf{u}^*\\|_2$ 是该时间步要报告的第一个值。\n\n**步骤2：第一次压力-速度修正**\n\n修正步的目标是找到一个压力修正量 $p'$ 和一个相应的速度修正量，使得新的速度场 $\\mathbf{u}^{(1)}$ 满足连续性方程。修正后的速度和压力定义为：\n$$ \\mathbf{u}^{(1)} = \\mathbf{u}^* + \\delta\\mathbf{u}^{(1)} $$\n$$ p^{(1)} = p^n + p' $$\n从预测步到第一次修正步，动量方程的更新仅仅是压力梯度项的变化。速度修正和压力修正之间的关系通过从修正后的动量方程中减去预测方程得出，得到：\n$$ \\frac{\\mathbf{u}^{(1)} - \\mathbf{u}^*}{\\Delta t} = -\\frac{1}{\\rho}\\nabla(p^{(1)}-p^n) = -\\frac{1}{\\rho}\\nabla p' $$\n这提供了一个显式的速度修正公式：\n$$ \\mathbf{u}^{(1)} = \\mathbf{u}^* - \\frac{\\Delta t}{\\rho} \\nabla p' $$\n为了找到 $p'$，我们对修正后的速度强制执行不可压缩性约束 $\\nabla \\cdot \\mathbf{u}^{(1)} = 0$。对速度修正方程应用散度算子得到：\n$$ \\nabla \\cdot \\mathbf{u}^{(1)} = \\nabla \\cdot \\mathbf{u}^* - \\frac{\\Delta t}{\\rho} \\nabla^2 p' = 0 $$\n这导出了压力修正量 $p'$ 的第一个压力泊松方程（PPE）：\n$$ \\nabla^2 p' = \\frac{\\rho}{\\Delta t} \\nabla \\cdot \\mathbf{u}^* $$\n这是一个椭圆偏微分方程，我们需要求解它来得到 $p'$。求解需要边界条件。对于无滑移壁面，速度的法向分量（$v$）必须保持为零。这意味着速度修正的法向分量在壁面处必须为零。从速度修正公式来看，这对压力修正施加了一个零梯度（诺伊曼）边界条件：$\\frac{\\partial p'}{\\partial y} = 0$。在周期性的 $x$ 方向上，$p'$ 也是周期性的。\n\n求解出 $p'$ 后，我们将速度场更新为 $\\mathbf{u}^{(1)}$。由于离散化误差，$\\nabla \\cdot \\mathbf{u}^{(1)}$ 可能不完全为零。我们计算并报告其范数 $\\|\\nabla \\cdot \\mathbf{u}^{(1)}\\|_2$。\n\n**步骤3：第二次压力-速度修正**\n\nPISO算法的理念是通过执行额外的修正步骤来改善动量和连续性方程的满足程度。我们引入第二个压力修正量 $p''$ 和第二个速度场 $\\mathbf{u}^{(2)}$。这个过程与第一次修正类似：\n$$ \\mathbf{u}^{(2)} = \\mathbf{u}^{(1)} - \\frac{\\Delta t}{\\rho} \\nabla p'' $$\n强制 $\\nabla \\cdot \\mathbf{u}^{(2)} = 0$ 得到第二个PPE：\n$$ \\nabla^2 p'' = \\frac{\\rho}{\\Delta t} \\nabla \\cdot \\mathbf{u}^{(1)} $$\n注意，源项现在是先前修正过的速度场 $\\mathbf{u}^{(1)}$ 的散度。我们使用与 $p'$ 相同的边界条件来求解这个PPE以得到 $p''$。然后将速度更新为 $\\mathbf{u}^{(2)}$。最后计算该时间步的最终散度范数 $\\|\\nabla \\cdot \\mathbf{u}^{(2)}\\|_2$。\n\n**步骤4：为下一个时间步更新**\n\n将场推进到下一个时间步 $t^{n+1}$：\n$$ \\mathbf{u}^{n+1} = \\mathbf{u}^{(2)} $$\n$$ p^{n+1} = p^n + p' + p'' $$\n这完成了一个PISO算法的完整时间步。\n\n### 4. 实现细节\n\n- **边界条件：** 问题陈述了 $x$ 方向的周期性边界和 $y=0$、$y=L_y$ 处的无滑移壁面。我们使用虚拟单元来实现这些。对于一个填充网格上的通用场 $\\phi$：\n    - $x$ 方向的周期性：$\\phi_{i,0} = \\phi_{i,N_x}$ 和 $\\phi_{i,N_x+1} = \\phi_{i,1}$。\n    - 速度分量 $u, v$ 在壁面上的无滑移：在 $y=0$ 的壁面上，我们需要第一个内部单元和虚拟单元之间的速度为零。线性插值给出 $\\frac{1}{2}(u_1 + u_0) = 0 \\implies u_0 = -u_1$。虚拟单元的值是相邻内部单元值的负数。\n    - 压力在壁面上的零梯度：在 $y=0$ 的壁面上，$\\frac{\\partial p}{\\partial y}=0$ 通过将虚拟单元压力设置为等于相邻内部单元压力来近似：$p_0 = p_1$。\n\n- **泊松求解器：** 离散化的PPE产生一个大型稀疏线性方程组 $A\\mathbf{x} = \\mathbf{b}$，其中 $\\mathbf{x}$ 是未知压力修正值的扁平化向量。我们构建代表拉普拉斯算子5点模板的矩阵 $A$，并包含边界条件。由于纯诺伊曼/周期性边界条件（压力仅在相差一个加法常数的情况下是已知的），所得系统是奇异的。为确保唯一解，我们通过将一个单元（例如，索引 `(0,0)`）的压力修正值设置为零来强制一个参考压力。这是通过将矩阵 $A$ 的相应行修改为单位行并将向量 $\\mathbf{b}$ 中的相应元素设置为零来完成的。然后使用 `scipy.sparse.linalg.spsolve` 高效地求解该系统。\n\n- **数值稳定性：** 使用显式预测器要求时间步 $\\Delta t$ 受到CFL和扩散稳定性限制的约束。该问题对粘性项使用纯显式格式，施加 $\\Delta t \\le \\frac{\\rho}{2\\mu} \\left(\\frac{1}{\\Delta x^2} + \\frac{1}{\\Delta y^2}\\right)^{-1}$。所提供的测试用例使用的 $\\Delta t$ 值满足此标准。\n\n- **关于同位网格的说明：** 在同位网格上对压力梯度和速度散度使用中心差分可能导致压力-速度解耦（棋盘格压力场）。高级格式通常采用 Rhie-Chow 插值来缓解此问题。由于问题没有指定，本实现中省略了这一点，严格遵守问题陈述。所选的流动问题（其发展为一维剖面）比更复杂的流动问题更不容易出现此问题。\n\n以下Python代码实现了此算法。",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csr_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases.\n    \"\"\"\n    test_cases = [\n        # Case A (happy path)\n        {\"Lx\": 1.0, \"Ly\": 1.0, \"Nx\": 16, \"Ny\": 16, \"rho\": 1.0, \"mu\": 0.01, \"G\": 1.0, \"dt\": 5e-3, \"n_steps\": 4},\n        # Case B (coarser grid and larger time step)\n        {\"Lx\": 1.0, \"Ly\": 1.0, \"Nx\": 8, \"Ny\": 8, \"rho\": 1.0, \"mu\": 0.1, \"G\": 1.0, \"dt\": 1e-2, \"n_steps\": 3},\n        # Case C (edge case with zero driving)\n        {\"Lx\": 1.0, \"Ly\": 1.0, \"Nx\": 16, \"Ny\": 16, \"rho\": 1.0, \"mu\": 0.01, \"G\": 0.0, \"dt\": 5e-3, \"n_steps\": 3},\n    ]\n\n    all_results = []\n    \n    for params in test_cases:\n        case_results = run_simulation(**params)\n        all_results.append(case_results)\n\n    # Format the final output as a string representation of the list of lists of lists.\n    # repr() is used to get a string that is a valid Python literal.\n    print(repr(all_results).replace(\" \", \"\"))\n\ndef run_simulation(Lx, Ly, Nx, Ny, rho, mu, G, dt, n_steps):\n    \"\"\"\n    Executes the PISO simulation for a single test case.\n    \"\"\"\n    dx = Lx / Nx\n    dy = Ly / Ny\n\n    # Initialize fields (u, v, p) on a padded grid for ghost cells\n    u = np.zeros((Ny + 2, Nx + 2))\n    v = np.zeros((Ny + 2, Nx + 2))\n    p = np.zeros((Ny + 2, Nx + 2))\n    \n    # Body force\n    fx = G\n    \n    # Pre-build the Poisson matrix\n    A = build_poisson_matrix(Nx, Ny, dx, dy)\n    \n    step_results = []\n    \n    for _ in range(n_steps):\n        # Apply boundary conditions to u, v, p from the previous step\n        u = apply_velocity_bcs(u)\n        v = apply_velocity_bcs(v)\n        p = apply_pressure_bcs(p)\n        \n        # --- 1. Predictor Step ---\n        # Calculate RHS of momentum equation\n        lap_u = laplacian(u, dx, dy)\n        lap_v = laplacian(v, dx, dy)\n        grad_px, grad_py = gradient(p, dx, dy)\n        \n        rhs_u = (-grad_px + mu * lap_u + fx) / rho\n        rhs_v = (-grad_py + mu * lap_v) / rho\n        \n        # Predictor velocity u*, v*\n        u_star = u[1:-1, 1:-1] + dt * rhs_u\n        v_star = v[1:-1, 1:-1] + dt * rhs_v\n        \n        # Update padded arrays for divergence calculation\n        u[1:-1, 1:-1], v[1:-1, 1:-1] = u_star, v_star\n        u = apply_velocity_bcs(u)\n        v = apply_velocity_bcs(v)\n        \n        # Report divergence of predictor field\n        div_star = divergence(u, v, dx, dy)\n        div_norm_star = np.sqrt(np.mean(div_star**2))\n        \n        # --- 2. First Corrector Step ---\n        # Solve first Pressure-Poisson Equation\n        rhs_p1 = rho / dt * div_star\n        p_corr1 = solve_poisson(rhs_p1.flatten(), A, Nx, Ny)\n        \n        # Update velocity u**(1), v**(1)\n        grad_pc1_x, grad_pc1_y = gradient(p_corr1, dx, dy)\n        u_corr1 = u[1:-1, 1:-1] - dt / rho * grad_pc1_x\n        v_corr1 = v[1:-1, 1:-1] - dt / rho * grad_pc1_y\n        \n        u[1:-1, 1:-1], v[1:-1, 1:-1] = u_corr1, v_corr1\n        u = apply_velocity_bcs(u)\n        v = apply_velocity_bcs(v)\n\n        # Report divergence of first corrected field\n        div_corr1 = divergence(u, v, dx, dy)\n        div_norm_corr1 = np.sqrt(np.mean(div_corr1**2))\n        \n        # --- 3. Second Corrector Step ---\n        # Solve second Pressure-Poisson Equation\n        rhs_p2 = rho / dt * div_corr1\n        p_corr2 = solve_poisson(rhs_p2.flatten(), A, Nx, Ny)\n        \n        # Update velocity u**(2), v**(2)\n        grad_pc2_x, grad_pc2_y = gradient(p_corr2, dx, dy)\n        u_corr2 = u[1:-1, 1:-1] - dt / rho * grad_pc2_x\n        v_corr2 = v[1:-1, 1:-1] - dt / rho * grad_pc2_y\n        \n        u[1:-1, 1:-1], v[1:-1, 1:-1] = u_corr2, v_corr2\n        u = apply_velocity_bcs(u)\n        v = apply_velocity_bcs(v)\n\n        # Report divergence of second corrected field\n        div_corr2 = divergence(u, v, dx, dy)\n        div_norm_corr2 = np.sqrt(np.mean(div_corr2**2))\n        \n        # --- 4. Final Updates ---\n        # Update pressure field for next time step\n        p_new_interior = p[1:-1, 1:-1] + p_corr1[1:-1, 1:-1] + p_corr2[1:-1, 1:-1]\n        p[1:-1, 1:-1] = p_new_interior\n        \n        step_results.append([div_norm_star, div_norm_corr1, div_norm_corr2])\n        \n    return step_results\n\n# --- Helper Functions for Discretization and BCs ---\n\ndef apply_velocity_bcs(vel):\n    \"\"\"Apply periodic (x) and no-slip (y) BCs.\"\"\"\n    # Periodic in x\n    vel[:, 0] = vel[:, -2]\n    vel[:, -1] = vel[:, 1]\n    # No-slip in y (u_ghost = -u_interior)\n    vel[0, :] = -vel[1, :]\n    vel[-1, :] = -vel[-2, :]\n    return vel\n\ndef apply_pressure_bcs(p):\n    \"\"\"Apply periodic (x) and zero-gradient (y) BCs.\"\"\"\n    # Periodic in x\n    p[:, 0] = p[:, -2]\n    p[:, -1] = p[:, 1]\n    # Zero-gradient in y (dp/dy=0 - p_ghost = p_interior)\n    p[0, :] = p[1, :]\n    p[-1, :] = p[-2, :]\n    return p\n\ndef laplacian(field, dx, dy):\n    \"\"\"Compute Laplacian on interior cells using a 5-point stencil.\"\"\"\n    return (field[1:-1, 2:] - 2 * field[1:-1, 1:-1] + field[1:-1, 0:-2]) / dx**2 + \\\n           (field[2:, 1:-1] - 2 * field[1:-1, 1:-1] + field[0:-2, 1:-1]) / dy**2\n\ndef divergence(u, v, dx, dy):\n    \"\"\"Compute divergence on interior cells.\"\"\"\n    return (u[1:-1, 2:] - u[1:-1, 0:-2]) / (2 * dx) + \\\n           (v[2:, 1:-1] - v[0:-2, 1:-1]) / (2 * dy)\n\ndef gradient(p, dx, dy):\n    \"\"\"Compute gradient on interior cells.\"\"\"\n    grad_x = (p[1:-1, 2:] - p[1:-1, 0:-2]) / (2 * dx)\n    grad_y = (p[2:, 1:-1] - p[0:-2, 1:-1]) / (2 * dy)\n    return grad_x, grad_y\n\ndef build_poisson_matrix(Nx, Ny, dx, dy):\n    \"\"\"Build the sparse matrix for the Poisson equation.\"\"\"\n    N = Nx * Ny\n    A = lil_matrix((N, N))\n    \n    dx2_inv = 1 / dx**2\n    dy2_inv = 1 / dy**2\n    \n    for i in range(Ny):\n        for j in range(Nx):\n            k = i * Nx + j\n            \n            # Diagonal term\n            A[k, k] = -2 * (dx2_inv + dy2_inv)\n            \n            # Off-diagonal terms\n            # West\n            A[k, i * Nx + (j - 1) % Nx] += dx2_inv\n            # East\n            A[k, i * Nx + (j + 1) % Nx] += dx2_inv\n            \n            # South\n            if i > 0:\n                A[k, (i - 1) * Nx + j] += dy2_inv\n            else: # Neumann BC at y=0\n                A[k, k] += dy2_inv\n                \n            # North\n            if i  Ny - 1:\n                A[k, (i + 1) * Nx + j] += dy2_inv\n            else: # Neumann BC at y=Ly\n                A[k, k] += dy2_inv\n\n    # Enforce pressure reference p(0,0)=0 to make matrix non-singular\n    A[0, :] = 0\n    A[0, 0] = 1\n    \n    return csr_matrix(A)\n\ndef solve_poisson(rhs_flat, A, Nx, Ny):\n    \"\"\"Solve the linear system Ax=b for pressure and reshape.\"\"\"\n    # Set RHS for reference pressure cell to 0\n    rhs_flat[0] = 0\n    \n    p_flat = spsolve(A, rhs_flat)\n    \n    p_corr_interior = p_flat.reshape((Ny, Nx))\n    \n    # Create padded array for gradient calculation\n    p_corr = np.zeros((Ny + 2, Nx + 2))\n    p_corr[1:-1, 1:-1] = p_corr_interior\n    p_corr = apply_pressure_bcs(p_corr)\n    \n    return p_corr\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}