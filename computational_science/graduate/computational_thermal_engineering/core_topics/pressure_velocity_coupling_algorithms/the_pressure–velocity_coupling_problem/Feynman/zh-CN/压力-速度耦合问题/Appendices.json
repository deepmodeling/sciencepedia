{
    "hands_on_practices": [
        {
            "introduction": "在深入研究求解压力-速度耦合的复杂算法之前，我们首先需要理解该问题在离散化层面上的根源。本练习将通过一个经典的数值实验，对比在并置网格和交错网格上压力场与速度场的耦合方式 。您将通过第一性原理推导并实现这两种网格布置下的离散算子，并数值化地证明，对于棋盘状压力震荡，常规的并置网格格式几乎无法“感知”到这种伪解，而交错网格则能有效地将其抑制。这项实践对于理解现代CFD求解器中网格布局选择的基本原理至关重要。",
            "id": "3994267",
            "problem": "考虑在没有热梯度的情况下，牛顿流体在二维通道中的不可压缩、等温、层流流动。其控制方程为连续性方程和动量方程，分别表述为\n$$\\nabla \\cdot \\mathbf{u} = 0,$$\n$$\\rho \\frac{\\partial \\mathbf{u}}{\\partial t} + \\rho (\\mathbf{u} \\cdot \\nabla)\\mathbf{u} = -\\nabla p + \\mu \\nabla^2 \\mathbf{u},$$\n其中 $\\mathbf{u} = (u,v)$ 是速度场，$p$ 是压力，$\\rho$ 是流体密度，$\\mu$ 是动力粘度。在压力-速度分裂（投影）的观点下，压力通过修正预测速度来强制执行连续性约束：\n$$\\mathbf{u}^{n+1} = \\mathbf{u}^{*} - \\frac{\\Delta t}{\\rho} \\nabla p,$$\n其中 $\\Delta t$ 是时间增量，$\\mathbf{u}^{*}$ 是预测速度，$\\mathbf{u}^{n+1}$ 是无散度的修正后速度。在离散设置中，$\\nabla p$ 和 $\\nabla \\cdot \\mathbf{u}$ 的构造方式取决于网格排列。一个朴素的同位网格（collocated grid）将 $u$、$v$ 和 $p$ 存储在单元中心，并用中心差分近似导数；一个交错网格（Marker-And-Cell (MAC) 排列）将 $p$ 存储在单元中心，而 $u$ 和 $v$ 存储在单元面上。在计算流体动力学（CFD）中，众所周知，朴素的同位网格排列会容许虚假的奇偶压力模式（棋盘状振荡），而交错网格则能抑制它们，因为以面为中心的通量能直接感知以单元为中心的压力差。\n\n您的任务是，从第一性原理出发，推导并实现两种网格排列的离散算子，并通过数值方式证明：纯棋盘状压力模式在朴素的同位网格方案上产生的质量通量散度可以忽略不计（揭示了解耦现象），但在交错网格方案上产生不可忽略的散度（揭示了抑制振荡的耦合作用）。将区域视为大小为 $N_x \\times N_y$、间距为 $\\Delta x$ 和 $\\Delta y$ 的矩形均匀网格，并在两个方向上采用周期性边界条件，以在没有边界层的情况下隔离内部耦合效应。使用一个合成的棋盘状压力场\n$$p_{i,j} = p_0 (-1)^{i+j},$$\n其振幅为 $p_0$（单位为 $\\mathrm{Pa}$），并按如下方式评估每种方案由压力修正所致速度场的散度：\n\n- 对于朴素的同位网格方案：\n  - 将 $u$、$v$ 和 $p$ 放置在单元中心 $(i,j)$。\n  - 通过中心差分近似单元中心的压力梯度：\n    $$\\left(\\frac{\\partial p}{\\partial x}\\right)_{i,j} \\approx \\frac{p_{i+1,j} - p_{i-1,j}}{2\\Delta x}, \\quad \\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j} \\approx \\frac{p_{i,j+1} - p_{i,j-1}}{2\\Delta y}.$$\n  - 定义修正后的单元中心速度：\n    $$u_{i,j}^{c} = -\\frac{\\Delta t}{\\rho}\\left(\\frac{\\partial p}{\\partial x}\\right)_{i,j}, \\quad v_{i,j}^{c} = -\\frac{\\Delta t}{\\rho}\\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j}.$$\n  - 通过对单元中心速度进行朴素的线性插值来构建面质量通量：\n    $$u_{i+\\frac{1}{2},j}^{c} = \\frac{u_{i,j}^{c} + u_{i+1,j}^{c}}{2}, \\quad v_{i,j+\\frac{1}{2}}^{c} = \\frac{v_{i,j}^{c} + v_{i,j+1}^{c}}{2}.$$\n  - 计算单元中心的离散散度：\n    $$\\left(\\nabla \\cdot \\mathbf{u}^{c}\\right)_{i,j} \\approx \\frac{u_{i+\\frac{1}{2},j}^{c} - u_{i-\\frac{1}{2},j}^{c}}{\\Delta x} + \\frac{v_{i,j+\\frac{1}{2}}^{c} - v_{i,j-\\frac{1}{2}}^{c}}{\\Delta y}.$$\n\n- 对于交错 MAC 方案：\n  - 将 $p$ 放置在单元中心 $(i,j)$，$u$ 放置在垂直面 $(i+\\frac{1}{2}, j)$，$v$ 放置在水平面 $(i, j+\\frac{1}{2})$。\n  - 面上的速度分量由相邻单元中心的压力差计算得出：\n    $$u_{i+\\frac{1}{2},j}^{s} = -\\frac{\\Delta t}{\\rho} \\frac{p_{i+1,j} - p_{i,j}}{\\Delta x}, \\quad v_{i,j+\\frac{1}{2}}^{s} = -\\frac{\\Delta t}{\\rho} \\frac{p_{i,j+1} - p_{i,j}}{\\Delta y}.$$\n  - 计算单元中心的离散散度：\n    $$\\left(\\nabla \\cdot \\mathbf{u}^{s}\\right)_{i,j} \\approx \\frac{u_{i+\\frac{1}{2},j}^{s} - u_{i-\\frac{1}{2},j}^{s}}{\\Delta x} + \\frac{v_{i,j+\\frac{1}{2}}^{s} - v_{i,j-\\frac{1}{2}}^{s}}{\\Delta y}.$$\n\n使用上述定义和合成的 $p_{i,j}$，推导为何对于棋盘状模式，同位网格的中心差分会得出 $\\left(\\partial p / \\partial x\\right)_{i,j} = 0$ 和 $\\left(\\partial p / \\partial y\\right)_{i,j} = 0$，而交错网格的面差分不为零，因此同位网格的散度可忽略不计，而交错网格的散度不可忽略。为量化此效应，将方案 $\\star \\in \\{c, s\\}$ 的均方根（RMS）散度定义为\n$$\\mathcal{D}_{\\star} = \\sqrt{\\frac{1}{N_x N_y} \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\left(\\nabla \\cdot \\mathbf{u}^{\\star}\\right)_{i,j}^2}.$$\n作为一个抑制度量，报告无量纲比率\n$$\\mathcal{R} = \\frac{\\mathcal{D}_{s}}{\\mathcal{D}_{c} + \\varepsilon},$$\n其中 $\\varepsilon$ 是一个为避免除以零而设的小正数，其值与 $\\mathcal{D}_{s}$ 成比例（例如，$\\varepsilon = 10^{-16} \\mathcal{D}_{s}$）。一个大的 $\\mathcal{R}$ 值表明，交错网格方案将压力与质量通量强耦合，从而相对于朴素的同位网格方案更有效地抑制了振荡。\n\n物理单位：$p_0$ 以 $\\mathrm{Pa}$ 为单位，$\\rho$ 以 $\\mathrm{kg/m^3}$ 为单位，$\\Delta x$ 和 $\\Delta y$ 以 $\\mathrm{m}$ 为单位，$\\Delta t$ 以 $\\mathrm{s}$ 为单位。输出比率 $\\mathcal{R}$ 是无量纲的。\n\n测试套件：为以下参数集运行您的程序，每个参数集指定为 $(N_x, N_y, \\Delta x, \\Delta y, \\rho, \\Delta t, p_0)$：\n- 情况 A（一般情况）：$(32, 32, 1.0\\times 10^{-2}, 1.0\\times 10^{-2}, 1.0, 1.0\\times 10^{-3}, 1.0)$。\n- 情况 B（粗网格边缘情况）：$(8, 8, 1.0\\times 10^{-2}, 1.0\\times 10^{-2}, 1.0, 5.0\\times 10^{-4}, 1.0)$。\n- 情况 C（各向异性通道纵横比）：$(64, 4, 5.0\\times 10^{-3}, 1.25\\times 10^{-2}, 1.0, 2.0\\times 10^{-3}, 1.0)$。\n\n您的程序应生成单行输出，其中包含情况 A、B 和 C 的三个抑制比，形式为方括号内由逗号分隔的列表（例如，$[\\mathcal{R}_A,\\mathcal{R}_B,\\mathcal{R}_C]$）。输出必须是该单行上的十进制表示的浮点数列表。不应打印任何其他文本。所有中间量在内部应按指定单位表示；最终的比率是无量纲的。",
            "solution": "当前的问题是计算流体动力学（CFD）中的一个经典数值实验，旨在说明不同网格排列上的压力-速度耦合问题。具体来说，它对比了朴素的同位网格（所有变量 $u$、$v$、$p$ 都存储在单元中心）与交错的 Marker-And-Cell (MAC) 网格（标量压力 $p$ 在单元中心，而速度分量 $u$ 和 $v$ 存储在单元面）。核心问题是，某些非物理的压力振荡（称为棋盘状模式）可能存在，而朴素同位网格方案的离散算子无法检测到它们，从而导致数值不稳定性。交错网格由于其构造，能正确地将压力梯度与质量通量耦合，从而防止此类虚假模式的出现。我们将通过解析方法证明这一点，然后进行数值验证。\n\n分析是在一个合成的棋盘状压力场上进行的，该压力场定义在一个间距为 $\\Delta x$ 和 $\\Delta y$ 的均匀 $N_x \\times N_y$ 网格上。单元 $(i,j)$ 中心的压力由下式给出\n$$p_{i,j} = p_0 (-1)^{i+j},$$\n其中 $p_0$ 是振幅。分析依赖于评估仅由投影方法的压力修正步（$\\mathbf{u}^{\\star} = -(\\Delta t / \\rho) \\nabla p$）所引起的速度场的散度，为简单起见，我们分析从零状态诱导出的速度场。假设采用周期性边界条件，并且所有测试用例中的 $N_x$ 和 $N_y$ 均为偶数。\n\n### 朴素同位网格方案的分析\n\n在同位网格方案中，所有变量，包括压力 $p$ 和速度分量 $u$ 和 $v$，都存储在单元中心 $(i,j)$。\n\n1.  **压力梯度计算**：使用中心差分在单元中心 $(i,j)$ 处近似压力梯度分量：\n    $$ \\left(\\frac{\\partial p}{\\partial x}\\right)_{i,j} \\approx \\frac{p_{i+1,j} - p_{i-1,j}}{2\\Delta x} \\quad \\text{和} \\quad \\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j} \\approx \\frac{p_{i,j+1} - p_{i,j-1}}{2\\Delta y}。 $$\n    代入棋盘状压力场 $p_{i,j} = p_0 (-1)^{i+j}$：\n    $$ \\frac{p_{i+1,j} - p_{i-1,j}}{2\\Delta x} = \\frac{p_0(-1)^{(i+1)+j} - p_0(-1)^{(i-1)+j}}{2\\Delta x} = \\frac{p_0(-1)^{i+j}}{2\\Delta x} \\left( (-1)^1 - (-1)^{-1} \\right) = \\frac{p_0(-1)^{i+j}}{2\\Delta x} (-1 - (-1)) = 0。 $$\n    同样，对于 $y$ 方向的梯度：\n    $$ \\frac{p_{i,j+1} - p_{i,j-1}}{2\\Delta y} = \\frac{p_0(-1)^{i+(j+1)} - p_0(-1)^{i+(j-1)}}{2\\Delta y} = \\frac{p_0(-1)^{i+j}}{2\\Delta y} \\left( (-1)^1 - (-1)^{-1} \\right) = 0。 $$\n    由于周期性条件以及每个方向上的网格单元数为偶数，这对所有内部点和边界点都成立。$2\\Delta x$ 的中心差分格式对网格上的最高频率（奈奎斯特）模式是“盲”的。\n\n2.  **速度场与散度**：由压力修正引起的单元中心速度分量，记为 $\\mathbf{u}^c = (u^c, v^c)$，为：\n    $$ u_{i,j}^{c} = -\\frac{\\Delta t}{\\rho}\\left(\\frac{\\partial p}{\\partial x}\\right)_{i,j} = 0, \\quad v_{i,j}^{c} = -\\frac{\\Delta t}{\\rho}\\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j} = 0。 $$\n    所有单元中心的速度均为零。\n\n3.  **质量通量与散度**：该方案通过平均单元中心速度来构建单元面上的质量通量。对于位于 $(i+\\frac{1}{2}, j)$ 的面：\n    $$ u_{i+\\frac{1}{2},j}^{c} = \\frac{u_{i,j}^{c} + u_{i+1,j}^{c}}{2} = \\frac{0 + 0}{2} = 0。 $$\n    同样，$v_{i,j+\\frac{1}{2}}^{c} = 0$。由于所有面通量均为零，单元 $(i,j)$ 处的离散散度恒等于零：\n    $$ \\left(\\nabla \\cdot \\mathbf{u}^{c}\\right)_{i,j} = \\frac{u_{i+\\frac{1}{2},j}^{c} - u_{i-\\frac{1}{2},j}^{c}}{\\Delta x} + \\frac{v_{i,j+\\frac{1}{2}}^{c} - v_{i,j-\\frac{1}{2}}^{c}}{\\Delta y} = 0。 $$\n    因此，同位网格方案的均方根（RMS）散度为 $\\mathcal{D}_{c} = 0$。在数值实现中，该值会受到浮点误差的影响，但应该可以忽略不计（在机器精度量级）。\n\n### 交错（MAC）网格方案的分析\n\n在交错网格方案中，压力 $p$ 位于单元中心 $(i,j)$，$u$ 速度分量位于垂直面 $(i+\\frac{1}{2}, j)$，而 $v$ 速度分量位于水平面 $(i, j+\\frac{1}{2})$。\n\n1.  **面速度计算**：直接跨单个单元评估压力梯度，以计算面上的速度。对于位于面 $(i+\\frac{1}{2}, j)$ 的 $u$ 速度，记为 $u^s_{i+\\frac{1}{2},j}$：\n    $$ u_{i+\\frac{1}{2},j}^{s} = -\\frac{\\Delta t}{\\rho} \\frac{p_{i+1,j} - p_{i,j}}{\\Delta x} = -\\frac{\\Delta t}{\\rho \\Delta x} \\left[ p_0(-1)^{(i+1)+j} - p_0(-1)^{i+j} \\right] $$\n    $$ = -\\frac{\\Delta t p_0(-1)^{i+j}}{\\rho \\Delta x} \\left[ (-1)^1 - 1 \\right] = \\frac{2 \\Delta t p_0}{\\rho \\Delta x} (-1)^{i+j}。 $$\n    同样，对于位于面 $(i, j+\\frac{1}{2})$ 的 $v$ 速度：\n    $$ v_{i,j+\\frac{1}{2}}^{s} = -\\frac{\\Delta t}{\\rho} \\frac{p_{i,j+1} - p_{i,j}}{\\Delta y} = \\frac{2 \\Delta t p_0}{\\rho \\Delta y} (-1)^{i+j}。 $$\n    与同位网格方案不同，交错排列在响应棋盘状压力时会产生非零速度场。\n\n2.  **散度计算**：单元中心 $(i,j)$ 处的离散散度为：\n    $$ \\left(\\nabla \\cdot \\mathbf{u}^{s}\\right)_{i,j} = \\frac{u_{i+\\frac{1}{2},j}^{s} - u_{i-\\frac{1}{2},j}^{s}}{\\Delta x} + \\frac{v_{i,j+\\frac{1}{2}}^{s} - v_{i,j-\\frac{1}{2}}^{s}}{\\Delta y}。 $$\n    我们需要左侧面上的速度 $u_{i-\\frac{1}{2},j}^{s}$，其计算如下：\n    $$ u_{i-\\frac{1}{2},j}^{s} = \\frac{2 \\Delta t p_0}{\\rho \\Delta x} (-1)^{(i-1)+j} = -\\frac{2 \\Delta t p_0}{\\rho \\Delta x} (-1)^{i+j}。 $$\n    代入散度表达式：\n    $$ \\frac{u_{i+\\frac{1}{2},j}^{s} - u_{i-\\frac{1}{2},j}^{s}}{\\Delta x} = \\frac{1}{\\Delta x} \\left[ \\frac{2 \\Delta t p_0}{\\rho \\Delta x} (-1)^{i+j} - \\left(-\\frac{2 \\Delta t p_0}{\\rho \\Delta x} (-1)^{i+j}\\right) \\right] = \\frac{4 \\Delta t p_0}{\\rho (\\Delta x)^2} (-1)^{i+j}。 $$\n    $y$ 方向的项是类似的。总散度为：\n    $$ \\left(\\nabla \\cdot \\mathbf{u}^{s}\\right)_{i,j} = \\left[ \\frac{4 \\Delta t p_0}{\\rho (\\Delta x)^2} + \\frac{4 \\Delta t p_0}{\\rho (\\Delta y)^2} \\right] (-1)^{i+j} = \\frac{4 \\Delta t p_0}{\\rho} \\left( \\frac{1}{(\\Delta x)^2} + \\frac{1}{(\\Delta y)^2} \\right) (-1)^{i+j}。 $$\n    该表达式代表压力场的离散拉普拉斯算子，证实了交错网格的散度算子与压力变化是强耦合的。散度显然不为零。\n\n3.  **RMS 散度**：为了求得 RMS 散度 $\\mathcal{D}_s$，我们将每个单元的散度平方，在整个网格上取平均，然后取平方根。项 $(-1)^{i+j}$ 的平方为 $1$，使得散度的平方在所有单元上都是常数：\n    $$ \\left( \\left(\\nabla \\cdot \\mathbf{u}^{s}\\right)_{i,j} \\right)^2 = \\left[ \\frac{4 \\Delta t p_0}{\\rho} \\left( \\frac{1}{(\\Delta x)^2} + \\frac{1}{(\\Delta y)^2} \\right) \\right]^2。 $$\n    RMS 值就是这个常数因子的绝对值：\n    $$ \\mathcal{D}_{s} = \\frac{4 \\Delta t p_0}{\\rho} \\left( \\frac{1}{(\\Delta x)^2} + \\frac{1}{(\\Delta y)^2} \\right)。 $$\n    这是一个非零、不可忽略的值。\n\n### 抑制度量\n\n抑制度量 $\\mathcal{R}$ 定义为 $\\mathcal{R} = \\mathcal{D}_{s} / (\\mathcal{D}_{c} + \\varepsilon)$。由于我们发现 $\\mathcal{D}_{c}$ 在解析上为零（在数值上可忽略不计），分母主要由正则化项 $\\varepsilon = 10^{-16} \\mathcal{D}_{s}$ 决定。\n$$ \\mathcal{R} = \\frac{\\mathcal{D}_{s}}{\\mathcal{D}_{c} + 10^{-16} \\mathcal{D}_{s}} \\approx \\frac{\\mathcal{D}_{s}}{10^{-16} \\mathcal{D}_{s}} = 10^{16}。 $$\n一个非常大的 $\\mathcal{R}$ 值表明，交错网格在响应棋盘状压力模式时会产生强烈的散度（一个强的修正信号），而朴素的同位网格几乎不产生任何信号。这种“看到”并因此能够修正高频压力振荡的能力，是交错网格排列的根本优势。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_suppression_ratio(Nx, Ny, dx, dy, rho, dt, p0):\n    \"\"\"\n    Derives and implements discrete operators for collocated and staggered grids\n    to demonstrate the pressure-velocity decoupling problem for a checkerboard\n    pressure field.\n\n    Args:\n        Nx (int): Number of grid cells in the x-direction.\n        Ny (int): Number of grid cells in the y-direction.\n        dx (float): Grid spacing in the x-direction.\n        dy (float): Grid spacing in the y-direction.\n        rho (float): Fluid density.\n        dt (float): Time step.\n        p0 (float): Amplitude of the pressure field.\n\n    Returns:\n        float: The suppression ratio R = D_s / (D_c + epsilon).\n    \"\"\"\n\n    # Create grid and synthetic checkerboard pressure field\n    # Grid indices j (rows, y), i (cols, x).\n    j_indices, i_indices = np.mgrid[0:Ny, 0:Nx]\n    p = p0 * (-1.0)**(i_indices + j_indices)\n\n    # --- Naive Collocated Scheme ---\n\n    # 1. Calculate pressure gradients at cell centers using central differences.\n    #    Periodic boundaries are handled by np.roll.\n    dp_dx = (np.roll(p, -1, axis=1) - np.roll(p, 1, axis=1)) / (2.0 * dx)\n    dp_dy = (np.roll(p, -1, axis=0) - np.roll(p, 1, axis=0)) / (2.0 * dy)\n\n    # 2. Calculate pressure-correction-induced velocities at cell centers.\n    u_c = - (dt / rho) * dp_dx\n    v_c = - (dt / rho) * dp_dy\n\n    # 3. Interpolate cell-centered velocities to faces.\n    # u_face_c at index (j, i) corresponds to face (i+1/2, j).\n    u_face_c = (u_c + np.roll(u_c, -1, axis=1)) / 2.0\n    v_face_c = (v_c + np.roll(v_c, -1, axis=0)) / 2.0\n\n    # 4. Compute cell-centered divergence from face fluxes.\n    # div_x component is (u_face(i+1/2) - u_face(i-1/2)) / dx.\n    # u_face(i-1/2, j) is u_face_c rolled by 1 along axis=1.\n    div_c_x = (u_face_c - np.roll(u_face_c, 1, axis=1)) / dx\n    div_c_y = (v_face_c - np.roll(v_face_c, 1, axis=0)) / dy\n    div_c = div_c_x + div_c_y\n\n    # 5. Calculate RMS divergence for the collocated scheme.\n    D_c = np.sqrt(np.mean(div_c**2))\n\n    # --- Staggered MAC Scheme ---\n\n    # 1. Calculate pressure-correction-induced velocities directly at faces.\n    # u_s at index (j, i) corresponds to face (i+1/2, j).\n    u_s = - (dt / rho) * (np.roll(p, -1, axis=1) - p) / dx\n    v_s = - (dt / rho) * (np.roll(p, -1, axis=0) - p) / dy\n\n    # 2. Compute cell-centered divergence from face velocities.\n    # div_x at (i,j) is (u_s(i+1/2,j) - u_s(i-1/2,j)) / dx.\n    # u_s(i-1/2,j) is u_s rolled by 1 along axis=1.\n    div_s_x = (u_s - np.roll(u_s, 1, axis=1)) / dx\n    div_s_y = (v_s - np.roll(v_s, 1, axis=0)) / dy\n    div_s = div_s_x + div_s_y\n\n    # 3. Calculate RMS divergence for the staggered scheme.\n    D_s = np.sqrt(np.mean(div_s**2))\n\n    # --- Suppression Metric ---\n    # As per the problem, use a small epsilon proportional to D_s.\n    epsilon = 1e-16 * D_s if D_s > 0 else 1e-16\n    R = D_s / (D_c + epsilon)\n    \n    return R\n    \ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Test suite: (Nx, Ny, dx, dy, rho, dt, p0)\n    test_cases = [\n        # Case A (general case)\n        (32, 32, 1.0e-2, 1.0e-2, 1.0, 1.0e-3, 1.0),\n        # Case B (coarse grid edge case)\n        (8, 8, 1.0e-2, 1.0e-2, 1.0, 5.0e-4, 1.0),\n        # Case C (anisotropic channel aspect)\n        (64, 4, 5.0e-3, 1.25e-2, 1.0, 2.0e-3, 1.0)\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, Ny, dx, dy, rho, dt, p0 = case\n        result = calculate_suppression_ratio(Nx, Ny, dx, dy, rho, dt, p0)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "理解了网格带来的挑战后，我们转向解决压力-速度耦合的核心算法：投影法。投影法通过一个预测-校正的步骤，将一个不满足连续性方程的中间速度场“投影”到无散度空间上，从而保证质量守恒 。在此实践中，您将为一个经典的顶盖驱动方腔流问题实现一个简化的投影法求解器。通过计算并比较投影步骤前后速度场的散度范数，您将亲手验证该方法是如何有效地执行不可压缩约束的。",
            "id": "3994286",
            "problem": "考虑在区域 $[0,1]\\times[0,1]$ 内的二维方腔驱动不可压缩流，使用 $N_x=N_y=N$ 个点的均匀网格，均匀间距为 $h=1/(N-1)$，速度场 $\\mathbf{u}=(u,v)$ 在单元中心进行离散。顶部边界的盖板具有给定的水平速度 $u=U_0$ 和垂直速度 $v=0$，而所有其他壁面则强制执行无滑移条件 $u=0$ 和 $v=0$。假设使用无量纲变量，流体密度等于 $1$。\n\n目标是使用投影法计算压力场以解决压力-速度耦合问题，并测量投影前后的离散散度范数。基本方程是不可压缩连续性方程 $\\nabla\\cdot\\mathbf{u}=0$ 和动量方程 $\\partial_t\\mathbf{u}+\\text{advection}=-\\nabla p + \\nu \\nabla^2 \\mathbf{u}$，其中 $\\nu$ 是运动粘度，$p$ 是压力。\n\n从内部初始速度 $\\mathbf{u}^n=\\mathbf{0}$ 开始，单个时间步的算法如下：\n\n1. 对每个分量使用二阶中心差分5点模板计算中间速度 $\\mathbf{u}^\\star=\\mathbf{u}^n+\\nu\\,\\Delta t\\,\\nabla^2\\mathbf{u}^n$。在此扩散更新前后，均在顶部边界施加速率边界条件 $u=U_0$ 和 $v=0$，并在其余壁面施加 $u=0$ 和 $v=0$。\n\n2. 通过中心差分计算内部区域 $\\mathbf{u}^\\star$ 的离散散度，\n   $$\\left(\\nabla\\cdot\\mathbf{u}^\\star\\right)_{i,j}=\\frac{u^\\star_{i+1,j}-u^\\star_{i-1,j}}{2h}+\\frac{v^\\star_{i,j+1}-v^\\star_{i,j-1}}{2h},$$\n   对于 $i=1,\\dots,N-2$ 和 $j=1,\\dots,N-2$，并在边界索引处将散度设置为 $0$。将内部点上的散度离散 $L^2$ 范数定义为\n   $$\\|\\nabla\\cdot\\mathbf{u}^\\star\\|_{2}=\\left(h^2 \\sum_{i=1}^{N-2}\\sum_{j=1}^{N-2} \\left(\\nabla\\cdot\\mathbf{u}^\\star\\right)_{i,j}^2\\right)^{1/2}.$$\n\n3. 求解从投影法导出的压力泊松方程，\n   $$\\nabla^2 p^{n+1}=\\frac{1}{\\Delta t}\\,\\nabla\\cdot\\mathbf{u}^\\star,$$\n   在所有壁面上采用齐次诺伊曼边界条件 $\\partial p/\\partial n=0$，并在中心网格点处设置单个参考约束 $p^{n+1}=0$ 以消除零空间。在内部使用5点模板对 $\\nabla^2$ 进行二阶有限差分近似，并在边界处使用强制 $\\partial p/\\partial n=0$ 的单边镜像条件，例如使用 $p_{\\text{ghost}}=p_{\\text{adjacent}}$，从而得到形式为 $2\\,(p_{\\text{adjacent}}-p_{\\text{boundary}})/h^2$ 的边界法向二阶导数。\n\n4. 通过以下方式投影中间速度以强制不可压缩性：\n   $$\\mathbf{u}^{n+1}=\\mathbf{u}^\\star-\\Delta t\\,\\nabla p^{n+1},$$\n   其中梯度在内部通过二阶中心差分计算，在边界通过单边差分计算；然后在顶部盖板处重新施加速率边界条件 $u=U_0$ 和 $v=0$，并在其他地方施加 $u=0$ 和 $v=0$。\n\n5. 使用与步骤2中相同的定义，计算内部区域的离散散度范数 $\\|\\nabla\\cdot\\mathbf{u}^{n+1}\\|_2$。\n\n所有量均为无量纲；将散度范数报告为无量纲实数。为以下参数值测试套件实现上述方法：\n- 测试 $1$：$N=33$, $\\Delta t=0.001$, $\\nu=0.001$, $U_0=1.0$。\n- 测试 $2$：$N=17$, $\\Delta t=0.0005$, $\\nu=0.1$, $U_0=1.0$。\n- 测试 $3$：$N=33$, $\\Delta t=0.002$, $\\nu=0.001$, $U_0=0.0$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个形式为 $[\\|\\nabla\\cdot\\mathbf{u}^\\star\\|_2,\\|\\nabla\\cdot\\mathbf{u}^{n+1}\\|_2]$ 的双元素列表。例如，输出格式必须是\n$$[[a_1,b_1],[a_2,b_2],[a_3,b_3]],$$\n其中每个 $a_k$ 和 $b_k$ 是对应于测试 $k$ 的范数的实数。",
            "solution": "问题陈述已经过严格验证，被认为是合理的。它概述了计算流体力学中的一个标准数值练习，具体是为不可压缩纳维-斯托克斯方程实现投影法的单个时间步，并简化为不可压缩斯托克斯方程以隔离压力-速度耦合机制。该问题是自洽的、有科学依据且适定的，提供了所有必要的方程、边界条件、离散化方案和参数。\n\n解决方案通过逐步实现指定的算法来展开。所有数学实体都按要求用 LaTeX 表示。\n\n### 1. 离散化和初始状态\n区域是一个正方形 $[0,1] \\times [0,1]$，通过一个包含 $N_x = N_y = N$ 个点的均匀同位网格进行离散。网格间距为 $h = 1/(N-1)$。网格索引 $(i,j)$ 在 $x$ 和 $y$ 方向上的范围都是从 $0$ 到 $N-1$，其中 $i$ 对应于 $x$ 方向，$j$ 对应于 $y$ 方向。速度场为 $\\mathbf{u} = (u,v)$，压力为 $p$。\n\n在时间 $t^n$ 的初始速度场对于所有内部点均给定为 $\\mathbf{u}^n = (u^n, v^n) = \\mathbf{0}$。在 $\\mathbf{u}^n$ 上施加边界条件：\n-   顶部边界（$j=N-1$）：对于 $i \\in [0, N-1]$，$u^n_{i,N-1} = U_0$，$v^n_{i,N-1} = 0$。请注意，在角点处，侧壁的无滑移条件优先，因此 $u^n_{0,N-1}=0$ 和 $u^n_{N-1,N-1}=0$。\n-   其他边界（底部、左侧、右侧）：无滑移条件，$u^n=0$ 和 $v^n=0$。\n\n### 2. 中间速度计算\n第一步是通过对初始速度场 $\\mathbf{u}^n$ 应用扩散步骤来计算中间速度场 $\\mathbf{u}^\\star$。根据该步骤的问题表述，对流项被省略。\n$$\n\\mathbf{u}^\\star = \\mathbf{u}^n + \\nu \\Delta t \\nabla^2 \\mathbf{u}^n\n$$\n对于内部点，即 $i,j \\in [1, N-2]$，拉普拉斯算子 $\\nabla^2$ 使用二阶中心差分5点模板进行离散：\n$$\n(\\nabla^2 u^n)_{i,j} = \\frac{u^n_{i+1,j} + u^n_{i-1,j} + u^n_{i,j+1} + u^n_{i,j-1} - 4u^n_{i,j}}{h^2}\n$$\n$(\\nabla^2 v^n)_{i,j}$ 也遵循类似的表达式。为所有内部点计算中间速度 $u^\\star$ 和 $v^\\star$。计算之后，在 $\\mathbf{u}^\\star$ 场上重新施加给定的速度边界条件。\n\n### 3. 中间速度的散度\n使用二阶中心差分计算内部网格点 $(i,j)$（其中 $i,j \\in [1, N-2]$）处中间速度场 $\\mathbf{u}^\\star$ 的离散散度：\n$$\n(\\nabla \\cdot \\mathbf{u}^\\star)_{i,j} = \\frac{u^\\star_{i+1,j} - u^\\star_{i-1,j}}{2h} + \\frac{v^\\star_{i,j+1} - v^\\star_{i,j-1}}{2h}\n$$\n在所有边界点处，散度被设置为零。然后计算该散度场在区域内部的离散 $L^2$ 范数：\n$$\n\\|\\nabla \\cdot \\mathbf{u}^\\star\\|_2 = \\left( h^2 \\sum_{i=1}^{N-2} \\sum_{j=1}^{N-2} \\left( (\\nabla \\cdot \\mathbf{u}^\\star)_{i,j} \\right)^2 \\right)^{1/2}\n$$\n该值量化了中间速度场未能满足不可压缩约束的程度。\n\n### 4. 压力泊松方程\n为了对最终速度场强制施加不可压缩性，通过求解压力泊松方程（PPE）来找到压力场 $p^{n+1}$：\n$$\n\\nabla^2 p^{n+1} = \\frac{1}{\\Delta t} \\nabla \\cdot \\mathbf{u}^\\star\n$$\n该方程在所有边界上均受齐次诺伊曼边界条件 $\\partial p / \\partial n = 0$ 的约束，其中 $n$ 是垂直于边界的方向。左侧的拉普拉斯算子使用包含这些边界条件的5点模板进行离散。这会产生一个线性方程组 $A\\mathbf{p} = \\mathbf{b}$，其中 $\\mathbf{p}$ 是所有 $N \\times N$ 个网格点上未知压力值的向量，$A$ 是表示离散化拉普拉斯算子的矩阵，而 $\\mathbf{b}$ 是表示源项 $(1/\\Delta t) \\nabla \\cdot \\mathbf{u}^\\star$ 的向量。\n\n对于一个内部点 $(i,j)$，方程为：\n$$\n\\frac{p_{i+1,j} + p_{i-1,j} + p_{i,j+1} + p_{i,j-1} - 4p_{i,j}}{h^2} = \\frac{(\\nabla \\cdot \\mathbf{u}^\\star)_{i,j}}{\\Delta t}\n$$\n对于一个边界点，模板被修改以反映 $\\partial p / \\partial n = 0$ 条件。例如，在底部边界点 $(i,0)$，对于 $i \\in [1, N-2]$，条件 $\\partial p/\\partial y = 0$ 通过使用一个鬼点 $p_{i,-1} = p_{i,1}$ 来实现，从而得到离散化方程：\n$$\n\\frac{p_{i+1,0} + p_{i-1,0} + 2p_{i,1} - 4p_{i,0}}{h^2} = \\frac{(\\nabla \\cdot \\mathbf{u}^\\star)_{i,0}}{\\Delta t}\n$$\n所有其他边界点和角点都可推导出类似的表达式。生成的矩阵 $A$ 是奇异的。为了获得唯一解，通过在中心网格点 $((N-1)/2, (N-1)/2)$ 强制 $p^{n+1}=0$ 来设置参考压力。这是通过将矩阵系统中相应的行替换为约束方程来实现的。然后求解得到的非奇异线性系统以获得压力场 $p^{n+1}$。\n\n### 5. 速度投影\n中间速度 $\\mathbf{u}^\\star$ 被投影到无散场空间上，以产生最终的无散速度场 $\\mathbf{u}^{n+1}$：\n$$\n\\mathbf{u}^{n+1} = \\mathbf{u}^\\star - \\Delta t \\nabla p^{n+1}\n$$\n压力梯度 $\\nabla p^{n+1}$ 在内部使用二阶中心差分计算，在边界使用一阶单边差分计算。对于一个内部点 $(i,j)$：\n$$\n(\\nabla p^{n+1})_{i,j} = \\left( \\frac{p^{n+1}_{i+1,j} - p^{n+1}_{i-1,j}}{2h}, \\frac{p^{n+1}_{i,j+1} - p^{n+1}_{i,j-1}}{2h} \\right)\n$$\n在边界处，例如在左边界 $i=0$ 处：\n$$\n\\left(\\frac{\\partial p^{n+1}}{\\partial x}\\right)_{0,j} = \\frac{p^{n+1}_{1,j} - p^{n+1}_{0,j}}{h}\n$$\n在计算出 $u^{n+1}$ 和 $v^{n+1}$ 后，重新施加速率边界条件，以最终确定新时间步的速度场。\n\n### 6. 修正后速度的散度\n最后，使用与步骤3中相同的公式，计算内部点上修正后速度场 $\\nabla \\cdot \\mathbf{u}^{n+1}$ 的离散散度及其 $L^2$ 范数 $\\|\\nabla \\cdot \\mathbf{u}^{n+1}\\|_2$。预期该范数将显著小于 $\\|\\nabla \\cdot \\mathbf{u}^\\star\\|_2$，这证明了投影法在强制不可压缩约束方面的有效性。",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csr_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main solver function that iterates through test cases and prints results.\n    \"\"\"\n    test_cases = [\n        # (N, dt, nu, U0)\n        (33, 0.001, 0.001, 1.0),\n        (17, 0.0005, 0.1, 1.0),\n        (33, 0.002, 0.001, 0.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        norm_star, norm_np1 = solve_one_case(*case)\n        results.append([norm_star, norm_np1])\n    \n    # Format the output as specified: [[a1,b1],[a2,b2],[a3,b3]]\n    inner_results = [f\"[{r[0]},{r[1]}]\" for r in results]\n    print(f\"[{','.join(inner_results)}]\")\n\ndef solve_one_case(N, dt, nu, U0):\n    \"\"\"\n    Solves the problem for a single set of parameters.\n    Numpy arrays are indexed as (row, col) which corresponds to (y, x).\n    \"\"\"\n    h = 1.0 / (N - 1)\n\n    # 1. Initialization\n    u_n = np.zeros((N, N))\n    v_n = np.zeros((N, N))\n\n    # Apply velocity boundary conditions\n    u_n[-1, :] = U0\n    u_n[-1, 0] = 0.0   # Corner no-slip (top-left)\n    u_n[-1, -1] = 0.0 # Corner no-slip (top-right)\n\n    # 2. Compute intermediate velocity u_star\n    u_star = u_n.copy()\n    v_star = v_n.copy()\n\n    # Diffusion step for interior points\n    lap_u = (u_n[1:-1, 2:] + u_n[1:-1, :-2] + u_n[2:, 1:-1] + u_n[:-2, 1:-1] - 4 * u_n[1:-1, 1:-1]) / h**2\n    lap_v = (v_n[1:-1, 2:] + v_n[1:-1, :-2] + v_n[2:, 1:-1] + v_n[:-2, 1:-1] - 4 * v_n[1:-1, 1:-1]) / h**2\n    \n    u_star[1:-1, 1:-1] = u_n[1:-1, 1:-1] + nu * dt * lap_u\n    v_star[1:-1, 1:-1] = v_n[1:-1, 1:-1] + nu * dt * lap_v\n    \n    # Re-apply boundary conditions on u_star\n    u_star[-1, :] = U0\n    u_star[-1, 0] = 0.0\n    u_star[-1, -1] = 0.0\n\n    # 3. Compute divergence of u_star\n    div_u_star = np.zeros((N, N))\n    div_u_star[1:-1, 1:-1] = (u_star[1:-1, 2:] - u_star[1:-1, :-2]) / (2 * h) + \\\n                             (v_star[2:, 1:-1] - v_star[:-2, 1:-1]) / (2 * h)\n    \n    norm_div_u_star = np.sqrt(h**2 * np.sum(div_u_star[1:-1, 1:-1]**2))\n\n    # 4. Solve Pressure Poisson Equation\n    rhs_poisson = (div_u_star / dt).flatten()\n    \n    # Assemble the matrix for the linear system Ap = b\n    N_sq = N * N\n    A = lil_matrix((N_sq, N_sq))\n    h2 = h**2\n    \n    for j in range(N): # y-index\n        for i in range(N): # x-index\n            k = j * N + i\n            \n            # Interior points\n            if 0  i  N - 1 and 0  j  N - 1:\n                A[k, k] = -4.0; A[k, k+1] = 1.0; A[k, k-1] = 1.0; A[k, k+N] = 1.0; A[k, k-N] = 1.0\n            # Boundary points with Neumann BC\n            else:\n                A[k, k] = -4.0\n                if i > 0: A[k, k-1] = 1.0\n                else: A[k, k+1] = 1.0 # Ghost point\n                if i  N-1: A[k, k+1] = 1.0\n                else: A[k, k-1] = 1.0 # Ghost point\n                if j > 0: A[k, k-N] = 1.0\n                else: A[k, k+N] = 1.0 # Ghost point\n                if j  N-1: A[k, k+N] = 1.0\n                else: A[k, k-N] = 1.0 # Ghost point\n\n    A /= h2\n\n    center_idx = (N - 1) // 2\n    k_center = center_idx * N + center_idx\n    A[k_center, :] = 0.0\n    A[k_center, k_center] = 1.0\n    rhs_poisson[k_center] = 0.0\n\n    p_flat = spsolve(csr_matrix(A), rhs_poisson)\n    p = p_flat.reshape((N, N))\n\n    # 5. Project velocity\n    dpdx = np.zeros((N, N))\n    dpdy = np.zeros((N, N))\n    \n    dpdx[:, 1:-1] = (p[:, 2:] - p[:, :-2]) / (2 * h)\n    dpdy[1:-1, :] = (p[2:, :] - p[:-2, :]) / (2 * h)\n    \n    dpdx[:, 0] = (p[:, 1] - p[:, 0]) / h\n    dpdx[:, -1] = (p[:, -1] - p[:, -2]) / h\n    dpdy[0, :] = (p[1, :] - p[0, :]) / h\n    dpdy[-1, :] = (p[-1, :] - p[-2, :]) / h\n\n    u_np1 = u_star - dt * dpdx\n    v_np1 = v_star - dt * dpdy\n    \n    # Reapply velocity boundary conditions\n    u_np1[0, :] = 0.0; v_np1[0, :] = 0.0\n    u_np1[-1, :] = U0; v_np1[-1, :] = 0.0\n    u_np1[:, 0] = 0.0; v_np1[:, 0] = 0.0\n    u_np1[:, -1] = 0.0; v_np1[:, -1] = 0.0\n    u_np1[-1, 0] = 0.0\n    u_np1[-1, -1] = 0.0\n    \n    # 6. Compute divergence of u_np1\n    div_u_np1 = np.zeros((N, N))\n    div_u_np1[1:-1, 1:-1] = (u_np1[1:-1, 2:] - u_np1[1:-1, :-2]) / (2 * h) + \\\n                              (v_np1[2:, 1:-1] - v_np1[:-2, 1:-1]) / (2 * h)\n\n    norm_div_u_np1 = np.sqrt(h**2 * np.sum(div_u_np1[1:-1, 1:-1]**2))\n\n    return norm_div_u_star, norm_div_u_np1\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在瞬态流动模拟中，时间步内的精度和效率至关重要，简单的投影法可能不足以保证动量方程和连续性方程的耦合求解。PISO（Pressure Implicit with Splitting of Operators）算法是针对这一需求发展出的更高级的非迭代耦合方法 。本练习要求您为一个瞬态启动的槽道流实现PISO算法，它在一个时间步内包含一个预测步骤和多个校正步骤。通过追踪每个子步骤中速度场散度的演化，您将直观地观察到PISO算法如何通过多次校正逐步增强压力与速度的耦合，从而在每个时间步结束时获得更精确的无散度速度场。",
            "id": "3994256",
            "problem": "考虑在二维通道中的不可压缩层流，通道在流向上的长度为 $L_x$，在壁面法向上的高度为 $L_y$。流体具有恒定的密度 $\\rho$ 和动力粘度 $\\mu$。流动在时间 $t=0$ 时从静止开始，由一个大小为 $G$（单位为 $\\mathrm{Pa/m}$）的恒定流向压力梯度驱动。位于 $y=0$ 和 $y=L_y$ 的壁面施加了无滑移速度边界条件，流向 $x$ 方向被视为周期性的。控制方程是恒定密度的不可压缩纳维-斯托克斯方程，\n$$\n\\rho \\frac{\\partial \\mathbf{u}}{\\partial t} + \\rho (\\mathbf{u}\\cdot\\nabla)\\mathbf{u} = -\\nabla p + \\mu \\nabla^2 \\mathbf{u} + \\rho \\mathbf{g},\n$$\n以及 $\\nabla\\cdot \\mathbf{u} = 0$，其中，施加的恒定流向压力梯度 $G$ 被表示为一个均匀的体积力，等效于 $\\rho g_x = G$。对于从静止开始且雷诺数较小的瞬态启动阶段，可以忽略对流项 $\\rho (\\mathbf{u}\\cdot\\nabla)\\mathbf{u}$，以便在算法实现中分离压力-速度耦合效应。\n\n您必须实现算子分裂压力隐式 (Pressure Implicit with Splitting of Operators, PISO) 算法，以在时间上耦合此启动通道流的压力和速度。计算在一个同位均匀笛卡尔网格上进行，该网格在 $x$ 方向是周期性的，在 $y$ 方向具有无滑移边界。在每个时间步中，该算法必须至少执行以下序列：\n1. 一个速度预测步，使用前一时间步的压力场来获得中间速度 $\\mathbf{u}^*$。\n2. 第一次压力修正，通过求解由施加于 $\\mathbf{u}^*$ 的连续性方程推导出的压力方程来强制不可压缩性，然后进行速度修正以获得 $\\mathbf{u}^{(1)}$。\n3. 第二次压力修正，以进一步减小散度，然后进行第二次速度修正以获得 $\\mathbf{u}^{(2)}$。\n您必须在每个时间步内，报告预测、第一次修正和第二次修正子步中空间均方根散度范数 $\\|\\nabla\\cdot\\mathbf{u}\\|_2$ 的演变。为本问题之目的，将报告的范数定义为空间均方根 (RMS) 范数\n$$\n\\|\\nabla\\cdot\\mathbf{u}\\|_2 = \\sqrt{\\frac{1}{\\Omega}\\int_{\\Omega} \\left(\\nabla\\cdot\\mathbf{u}\\right)^2 \\, d\\Omega},\n$$\n其离散形式通过逐点散度值平方的算术平均值的平方根来近似。此量必须以 $\\mathrm{s^{-1}}$ 为单位报告。\n\n将域在 $x$ 方向离散为 $N_x$ 个点，在 $y$ 方向离散为 $N_y$ 个点，均匀间距分别为 $\\Delta x = L_x/N_x$ 和 $\\Delta y = L_y/N_y$。对扩散和压力梯度的空间导数使用二阶中心差分，对 $x$ 方向的模板使用周期性环绕，并在 $y=0$ 和 $y=L_y$ 处强制执行与无滑移速度和零法向梯度压力边界一致的适当边界处理。时间积分应使用与 PISO 框架一致的显式预测器，压力修正应通过求解一个离散压力方程来获得，该方程源于将连续性方程应用于预测速度场。应通过固定一个任意参考单元的压力值来保证压力的唯一性。\n\n您的程序必须实现此算法，并在每个时间步中，计算并存储对应于预测、第一次修正和第二次修正子步的三个 $\\|\\nabla\\cdot\\mathbf{u}\\|_2$ 值。程序必须针对构成测试套件的几组参数，运行模拟少量时间步。\n\n测试套件：\n- 案例 A (正常路径): $L_x = 1\\,\\mathrm{m}$，$L_y = 1\\,\\mathrm{m}$，$N_x = 16$，$N_y = 16$，$\\rho = 1\\,\\mathrm{kg/m^3}$，$\\mu = 0.01\\,\\mathrm{Pa\\cdot s}$，$G = 1\\,\\mathrm{Pa/m}$，时间步 $\\Delta t = 5\\times 10^{-3}\\,\\mathrm{s}$，$N_{\\text{steps}} = 4$。\n- 案例 B (更粗的网格和更大的时间步边界条件): $L_x = 1\\,\\mathrm{m}$，$L_y = 1\\,\\mathrm{m}$，$N_x = 8$，$N_y = 8$，$\\rho = 1\\,\\mathrm{kg/m^3}$，$\\mu = 0.1\\,\\mathrm{Pa\\cdot s}$，$G = 1\\,\\mathrm{Pa/m}$，时间步 $\\Delta t = 10^{-2}\\,\\mathrm{s}$，$N_{\\text{steps}} = 3$。\n- 案例 C (零驱动的边缘情况): $L_x = 1\\,\\mathrm{m}$，$L_y = 1\\,\\mathrm{m}$，$N_x = 16$，$N_y = 16$，$\\rho = 1\\,\\mathrm{kg/m^3}$，$\\mu = 0.01\\,\\mathrm{Pa\\cdot s}$，$G = 0\\,\\mathrm{Pa/m}$，时间步 $\\Delta t = 5\\times 10^{-3}\\,\\mathrm{s}$，$N_{\\text{steps}} = 3$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含所有测试用例的聚合结果，形式为方括号内由逗号分隔的列表。对于每个测试用例，输出一个列表的列表，每个时间步对应一个内部列表，其中每个内部列表按顺序包含预测、第一次修正和第二次修正子步的三个浮点数值 $\\|\\nabla\\cdot\\mathbf{u}\\|_2$ (单位为 $\\mathrm{s^{-1}}$)。例如，整体输出应如下所示\n$[ \\text{caseA\\_results}, \\text{caseB\\_results}, \\text{caseC\\_results} ]$\n其中每个 $\\text{caseX\\_results}$ 本身就是一个浮点数列表的列表。这些值必须是没有任何单位符号的数字，单位如上定义，默认为 $\\mathrm{s^{-1}}$。",
            "solution": "用户提供了一个问题，要求为一个简化的二维、不可压缩、层流通道流实现算子分裂压力隐式 (PISO) 算法。所提供的问题陈述经证实具有科学依据、问题适定且客观。它包含了所有必要的信息，包括控制方程、边界和初始条件、离散化指南以及一组特定的测试参数。该问题是计算流体力学 (CFD) 中的一个标准（尽管不简单）练习，并且可以按照其表述进行求解。\n\n我们现在将进行数值方法的详细推导和描述，然后是其实现。\n\n### 1. 控制方程\n\n该问题涉及通道中由恒定流向压力梯度 $G$ 驱动的流动的瞬态启动。对于低雷诺数情况，纳维-斯托克斯方程中的非线性对流项 $(\\mathbf{u}\\cdot\\nabla)\\mathbf{u}$ 被忽略。速度 $\\mathbf{u}=(u,v)$ 和压力 $p$ 的控制方程为：\n\n动量方程：\n$$ \\rho \\frac{\\partial \\mathbf{u}}{\\partial t} = -\\nabla p + \\mu \\nabla^2 \\mathbf{u} + \\mathbf{f} $$\n连续性方程 (不可压缩性约束)：\n$$ \\nabla \\cdot \\mathbf{u} = 0 $$\n\n这里，$\\rho$ 是恒定的流体密度，$\\mu$ 是动力粘度，$\\mathbf{f}$ 是一个体积力项。施加的压力梯度 $G$ 被建模为一个均匀的流向体积力，因此 $\\mathbf{f} = (G, 0)$。\n\n### 2. 离散化\n\n方程在一个同位的、均匀的笛卡尔网格上进行离散化，网格有 $N_x \\times N_y$ 个单元，所有变量（$u$、$v$、$p$）都存储在单元中心。单元尺寸为 $\\Delta x = L_x/N_x$ 和 $\\Delta y = L_y/N_y$。空间导数使用二阶中心差分进行近似。对于一个通用场 $\\phi$，算子为：\n\n梯度：\n$$ \\nabla \\phi \\approx \\left(\\frac{\\phi_{i,j+1} - \\phi_{i,j-1}}{2\\Delta x}, \\frac{\\phi_{i+1,j} - \\phi_{i-1,j}}{2\\Delta y}\\right) $$\n拉普拉斯算子：\n$$ \\nabla^2 \\phi \\approx \\frac{\\phi_{i,j+1} - 2\\phi_{i,j} + \\phi_{i,j-1}}{\\Delta x^2} + \\frac{\\phi_{i+1,j} - 2\\phi_{i,j} + \\phi_{i-1,j}}{\\Delta y^2} $$\n散度：\n$$ \\nabla \\cdot \\mathbf{u} \\approx \\frac{u_{i,j+1} - u_{i,j-1}}{2\\Delta x} + \\frac{v_{i+1,j} - v_{i-1,j}}{2\\Delta y} $$\n\n时间使用前向欧拉格式离散，时间步长为 $\\Delta t$。让上标 $n$ 表示在时间 $t^n$ 的值。\n\n### 3. PISO 算法\n\nPISO 算法是一种用于压力-速度耦合的非迭代方法，它在单个时间步内执行一个预测步和多个修正步，以强制执行不可压缩性约束。对于此问题，我们实现一个预测步和两个修正步。设 $\\mathbf{u}^n$ 和 $p^n$ 为时间步开始时的已知场。\n\n**第 1 步：速度预测**\n\n一个中间速度场 $\\mathbf{u}^*$ 是根据动量方程，使用前一时间步的压力场 $p^n$ 显式计算出来的。\n\n$$ \\frac{\\mathbf{u}^* - \\mathbf{u}^n}{\\Delta t} = \\frac{1}{\\rho} \\left( -\\nabla p^n + \\mu \\nabla^2 \\mathbf{u}^n + \\mathbf{f} \\right) $$\n整理后得到 $\\mathbf{u}^*$ 的预测方程：\n$$ \\mathbf{u}^* = \\mathbf{u}^n + \\frac{\\Delta t}{\\rho} \\left( -\\nabla p^n + \\mu \\nabla^2 \\mathbf{u}^n + \\mathbf{f} \\right) $$\n这个预测的速度场 $\\mathbf{u}^*$ 通常不满足连续性方程，即 $\\nabla \\cdot \\mathbf{u}^* \\neq 0$。该散度的空间均方根 $\\|\\nabla \\cdot \\mathbf{u}^*\\|_2$ 是该时间步要报告的第一个值。\n\n**第 2 步：第一次压力-速度修正**\n\n修正步的目标是找到一个压力修正量 $p'$ 和一个相应的速度修正量，使得新的速度场 $\\mathbf{u}^{(1)}$ 满足连续性方程。修正后的速度和压力定义为：\n$$ \\mathbf{u}^{(1)} = \\mathbf{u}^* + \\delta\\mathbf{u}^{(1)} $$\n$$ p^{(1)} = p^n + p' $$\n从预测步到第一次修正步，动量方程的更新仅仅是压力梯度项的变化。通过从修正后的动量方程中减去预测方程，可以推导出速度修正和压力修正之间的关系，得到：\n$$ \\frac{\\mathbf{u}^{(1)} - \\mathbf{u}^*}{\\Delta t} = -\\frac{1}{\\rho}\\nabla(p^{(1)}-p^n) = -\\frac{1}{\\rho}\\nabla p' $$\n这提供了一个显式的速度修正公式：\n$$ \\mathbf{u}^{(1)} = \\mathbf{u}^* - \\frac{\\Delta t}{\\rho} \\nabla p' $$\n为了求出 $p'$，我们对修正后的速度施加不可压缩性约束 $\\nabla \\cdot \\mathbf{u}^{(1)} = 0$。对速度修正方程应用散度算子，得到：\n$$ \\nabla \\cdot \\mathbf{u}^{(1)} = \\nabla \\cdot \\mathbf{u}^* - \\frac{\\Delta t}{\\rho} \\nabla^2 p' = 0 $$\n这就得到了关于压力修正量 $p'$ 的第一个压力泊松方程 (PPE)：\n$$ \\nabla^2 p' = \\frac{\\rho}{\\Delta t} \\nabla \\cdot \\mathbf{u}^* $$\n这是一个椭圆偏微分方程，我们求解它以得到 $p'$。求解需要边界条件。对于无滑移壁面，速度的法向分量 ($v$) 必须保持为零。这意味着速度修正量的法向分量在壁面处必须为零。根据速度修正公式，这为压力修正量施加了一个零梯度（诺伊曼）边界条件：$\\frac{\\partial p'}{\\partial y} = 0$。在周期性的 $x$ 方向上，$p'$ 也是周期性的。\n\n求解出 $p'$ 后，我们将速度场更新为 $\\mathbf{u}^{(1)}$。由于离散误差，$\\nabla \\cdot \\mathbf{u}^{(1)}$ 可能不完全为零。我们计算并报告其范数 $\\|\\nabla \\cdot \\mathbf{u}^{(1)}\\|_2$。\n\n**第 3 步：第二次压力-速度修正**\n\nPISO 算法的理念是通过执行额外的修正步骤来改善动量和连续性方程的满足程度。我们引入第二次压力修正 $p''$ 和第二个速度场 $\\mathbf{u}^{(2)}$。这个过程与第一次修正类似：\n$$ \\mathbf{u}^{(2)} = \\mathbf{u}^{(1)} - \\frac{\\Delta t}{\\rho} \\nabla p'' $$\n强制 $\\nabla \\cdot \\mathbf{u}^{(2)} = 0$ 会产生第二个 PPE：\n$$ \\nabla^2 p'' = \\frac{\\rho}{\\Delta t} \\nabla \\cdot \\mathbf{u}^{(1)} $$\n请注意，源项现在是先前修正过的速度场 $\\mathbf{u}^{(1)}$ 的散度。我们使用与 $p'$ 相同的边界条件来求解这个关于 $p''$ 的 PPE。然后将速度更新为 $\\mathbf{u}^{(2)}$。然后计算该时间步的最终散度范数 $\\|\\nabla \\cdot \\mathbf{u}^{(2)}\\|_2$。\n\n**第 4 步：为下一时间步更新**\n\n将场推进到下一个时间步 $t^{n+1}$：\n$$ \\mathbf{u}^{n+1} = \\mathbf{u}^{(2)} $$\n$$ p^{n+1} = p^n + p' + p'' $$\n这样就完成了 PISO 算法的一个完整时间步。\n\n### 4. 实现细节\n\n- **边界条件：** 问题陈述了 $x$ 方向的周期性边界和在 $y=0$ 与 $y=L_y$ 处的无滑移壁面。我们使用虚拟单元来实现这些条件。对于一个填充网格上的通用场 $\\phi$：\n    - $x$ 方向的周期性：$\\phi_{i,0} = \\phi_{i,N_x}$ 和 $\\phi_{i,N_x+1} = \\phi_{i,1}$。\n    - 速度分量 $u, v$ 在壁面上的无滑移条件：在 $y=0$ 处壁面，我们需要第一个内部单元和虚拟单元之间的速度为零。线性插值给出 $\\frac{1}{2}(u_1 + u_0) = 0 \\implies u_0 = -u_1$。虚拟单元的值是相邻内部单元值的负数。\n    - 压力在壁面上的零梯度条件：在 $y=0$ 处壁面，$\\frac{\\partial p}{\\partial y}=0$ 通过将虚拟单元的压力设置为与相邻内部单元压力相等来近似：$p_0 = p_1$。\n\n- **泊松求解器：** 离散化的 PPE 产生一个大型稀疏线性方程组 $A\\mathbf{x} = \\mathbf{b}$，其中 $\\mathbf{x}$ 是未知压力修正值的展开向量。我们构造代表拉普拉斯算子 5 点模板的矩阵 $A$，并整合边界条件。由于纯诺伊曼/周期性边界条件，得到的系统是奇异的（压力值只能确定到一个附加常数）。为了确保解的唯一性，我们通过将一个单元（例如，索引 `(0,0)`）的压力修正设置为零来强制一个参考压力。这是通过修改矩阵 $A$ 的相应行使其成为单位行，并将向量 $\\mathbf{b}$ 中的相应元素设置为零来完成的。然后使用 `scipy.sparse.linalg.spsolve` 高效地求解该系统。\n\n- **数值稳定性：** 使用显式预测器要求时间步长 $\\Delta t$ 受到 CFL 和扩散稳定性限制的约束。该问题对粘性项使用纯显式格式，这施加了 $\\Delta t \\le \\frac{\\rho}{2\\mu} \\left(\\frac{1}{\\Delta x^2} + \\frac{1}{\\Delta y^2}\\right)^{-1}$ 的约束。提供的测试用例使用的 $\\Delta t$ 值满足此标准。\n\n- **关于同位网格的说明：** 在同位网格上对压力梯度和速度散度使用中心差分可能导致压力-速度解耦（棋盘格压力场）。先进的格式通常采用 Rhie-Chow 插值来缓解此问题。由于问题陈述中未指定，本实现中省略了这一点，严格遵循问题陈述。所选的流动问题会发展成一维剖面，相比更复杂的流动，它不太容易受到此问题的影响。\n\n以下 Python 代码实现了此算法。",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csr_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases.\n    \"\"\"\n    test_cases = [\n        # Case A (happy path)\n        {\"Lx\": 1.0, \"Ly\": 1.0, \"Nx\": 16, \"Ny\": 16, \"rho\": 1.0, \"mu\": 0.01, \"G\": 1.0, \"dt\": 5e-3, \"n_steps\": 4},\n        # Case B (coarser grid and larger time step)\n        {\"Lx\": 1.0, \"Ly\": 1.0, \"Nx\": 8, \"Ny\": 8, \"rho\": 1.0, \"mu\": 0.1, \"G\": 1.0, \"dt\": 1e-2, \"n_steps\": 3},\n        # Case C (edge case with zero driving)\n        {\"Lx\": 1.0, \"Ly\": 1.0, \"Nx\": 16, \"Ny\": 16, \"rho\": 1.0, \"mu\": 0.01, \"G\": 0.0, \"dt\": 5e-3, \"n_steps\": 3},\n    ]\n\n    all_results = []\n    \n    for params in test_cases:\n        case_results = run_simulation(**params)\n        all_results.append(case_results)\n\n    # Format the final output as a string representation of the list of lists of lists.\n    print(repr(all_results).replace(\" \", \"\"))\n\ndef run_simulation(Lx, Ly, Nx, Ny, rho, mu, G, dt, n_steps):\n    \"\"\"\n    Executes the PISO simulation for a single test case.\n    \"\"\"\n    dx = Lx / Nx\n    dy = Ly / Ny\n\n    # Initialize fields (u, v, p) on a padded grid for ghost cells\n    u = np.zeros((Ny + 2, Nx + 2))\n    v = np.zeros((Ny + 2, Nx + 2))\n    p = np.zeros((Ny + 2, Nx + 2))\n    \n    # Body force\n    fx = G\n    \n    # Pre-build the Poisson matrix\n    A = build_poisson_matrix(Nx, Ny, dx, dy)\n    \n    step_results = []\n    \n    for _ in range(n_steps):\n        # Apply boundary conditions to u, v, p from the previous step\n        u = apply_velocity_bcs(u)\n        v = apply_velocity_bcs(v)\n        p = apply_pressure_bcs(p)\n        \n        # --- 1. Predictor Step ---\n        lap_u = laplacian(u, dx, dy)\n        lap_v = laplacian(v, dx, dy)\n        grad_px, grad_py = gradient(p, dx, dy)\n        \n        rhs_u = (-grad_px + mu * lap_u + fx) / rho\n        rhs_v = (-grad_py + mu * lap_v) / rho\n        \n        u_star_int = u[1:-1, 1:-1] + dt * rhs_u\n        v_star_int = v[1:-1, 1:-1] + dt * rhs_v\n        \n        u[1:-1, 1:-1], v[1:-1, 1:-1] = u_star_int, v_star_int\n        u = apply_velocity_bcs(u)\n        v = apply_velocity_bcs(v)\n        \n        div_star = divergence(u, v, dx, dy)\n        div_norm_star = np.sqrt(np.mean(div_star**2))\n        \n        # --- 2. First Corrector Step ---\n        rhs_p1 = rho / dt * div_star\n        p_corr1 = solve_poisson(rhs_p1.flatten(), A, Nx, Ny)\n        \n        grad_pc1_x, grad_pc1_y = gradient(p_corr1, dx, dy)\n        u[1:-1, 1:-1] -= dt / rho * grad_pc1_x\n        v[1:-1, 1:-1] -= dt / rho * grad_pc1_y\n        u = apply_velocity_bcs(u)\n        v = apply_velocity_bcs(v)\n\n        div_corr1 = divergence(u, v, dx, dy)\n        div_norm_corr1 = np.sqrt(np.mean(div_corr1**2))\n        \n        # --- 3. Second Corrector Step ---\n        rhs_p2 = rho / dt * div_corr1\n        p_corr2 = solve_poisson(rhs_p2.flatten(), A, Nx, Ny)\n        \n        grad_pc2_x, grad_pc2_y = gradient(p_corr2, dx, dy)\n        u[1:-1, 1:-1] -= dt / rho * grad_pc2_x\n        v[1:-1, 1:-1] -= dt / rho * grad_pc2_y\n        u = apply_velocity_bcs(u)\n        v = apply_velocity_bcs(v)\n\n        div_corr2 = divergence(u, v, dx, dy)\n        div_norm_corr2 = np.sqrt(np.mean(div_corr2**2))\n        \n        # --- 4. Final Updates ---\n        p[1:-1, 1:-1] += p_corr1[1:-1, 1:-1] + p_corr2[1:-1, 1:-1]\n        \n        step_results.append([div_norm_star, div_norm_corr1, div_norm_corr2])\n        \n    return step_results\n\ndef apply_velocity_bcs(vel):\n    vel[:, 0] = vel[:, -2]\n    vel[:, -1] = vel[:, 1]\n    vel[0, :] = -vel[1, :]\n    vel[-1, :] = -vel[-2, :]\n    return vel\n\ndef apply_pressure_bcs(p):\n    p[:, 0] = p[:, -2]\n    p[:, -1] = p[:, 1]\n    p[0, :] = p[1, :]\n    p[-1, :] = p[-2, :]\n    return p\n\ndef laplacian(field, dx, dy):\n    return (field[1:-1, 2:] - 2 * field[1:-1, 1:-1] + field[1:-1, 0:-2]) / dx**2 + \\\n           (field[2:, 1:-1] - 2 * field[1:-1, 1:-1] + field[0:-2, 1:-1]) / dy**2\n\ndef divergence(u, v, dx, dy):\n    return (u[1:-1, 2:] - u[1:-1, 0:-2]) / (2 * dx) + \\\n           (v[2:, 1:-1] - v[0:-2, 1:-1]) / (2 * dy)\n\ndef gradient(p, dx, dy):\n    grad_x = (p[1:-1, 2:] - p[1:-1, 0:-2]) / (2 * dx)\n    grad_y = (p[2:, 1:-1] - p[0:-2, 1:-1]) / (2 * dy)\n    return grad_x, grad_y\n\ndef build_poisson_matrix(Nx, Ny, dx, dy):\n    N = Nx * Ny\n    A = lil_matrix((N, N))\n    dx2_inv, dy2_inv = 1 / dx**2, 1 / dy**2\n\n    for i in range(Ny):\n        for j in range(Nx):\n            k = i * Nx + j\n            \n            A[k, k] = -2 * (dx2_inv + dy2_inv)\n            A[k, i * Nx + (j - 1) % Nx] += dx2_inv\n            A[k, i * Nx + (j + 1) % Nx] += dx2_inv\n\n            if i == 0:\n                A[k, (i + 1) * Nx + j] += 2 * dy2_inv\n            elif i == Ny - 1:\n                A[k, (i - 1) * Nx + j] += 2 * dy2_inv\n            else:\n                A[k, (i + 1) * Nx + j] += dy2_inv\n                A[k, (i - 1) * Nx + j] += dy2_inv\n\n    A[0, :] = 0\n    A[0, 0] = 1.0\n    return csr_matrix(A)\n\ndef solve_poisson(rhs_flat, A, Nx, Ny):\n    rhs_flat[0] = 0\n    p_flat = spsolve(A, rhs_flat)\n    p_corr_interior = p_flat.reshape((Ny, Nx))\n    \n    p_corr = np.zeros((Ny + 2, Nx + 2))\n    p_corr[1:-1, 1:-1] = p_corr_interior\n    p_corr = apply_pressure_bcs(p_corr)\n    \n    return p_corr\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}