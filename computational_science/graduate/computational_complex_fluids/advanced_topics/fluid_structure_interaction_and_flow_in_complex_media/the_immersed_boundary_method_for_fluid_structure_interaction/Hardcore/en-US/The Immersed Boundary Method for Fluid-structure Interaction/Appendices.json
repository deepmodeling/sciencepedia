{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of a robust Immersed Boundary Method implementation is the adjoint relationship between the force spreading operator, $S$, and the velocity interpolation operator, $J$. This property ensures that the power exchanged between the structure and the fluid is conserved at the discrete level. This practice guides you through a crucial numerical verification test, computing the inner products $\\langle \\mathbf{u}, S \\mathbf{F} \\rangle_E$ and $\\langle J \\mathbf{u}, \\mathbf{F} \\rangle_L$ to confirm that your implementation is free of common bugs and respects this fundamental principle. ",
            "id": "4107994",
            "problem": "Consider the Immersed Boundary Method (IBM) for fluid-structure interaction (FSI) on a two-dimensional periodic domain. Let the computational domain be the square $[0,1) \\times [0,1)$ with a uniform Cartesian Eulerian grid of size $N \\times N$, grid spacing $h = 1/N$, and grid points located at coordinates $(i h, j h)$ for integers $i, j \\in \\{0, 1, \\dots, N-1\\}$. Let there be a Lagrangian structure discretized by $N_L$ points with positions $\\{ \\mathbf{X}_q \\}_{q=0}^{N_L-1} \\subset [0,1)^2$ and associated Lagrangian forces $\\{ \\mathbf{F}_q \\}_{q=0}^{N_L-1} \\in \\mathbb{R}^2$. Define the Lagrangian arclength spacing $\\Delta s$ to be constant along the structure.\n\nThe Eulerian velocity field is a grid function $\\{ \\mathbf{u}_{i,j} \\in \\mathbb{R}^2 \\}_{i,j=0}^{N-1}$. The Eulerian-to-Lagrangian interpolation operator $J$ and the Lagrangian-to-Eulerian spreading operator $S$ are defined using the standard four-point discrete delta function (also known as the four-point Peskin kernel). Specifically, define the one-dimensional kernel $\\phi(r)$ for $r \\in \\mathbb{R}$ by\n$$\n\\phi(r) = \n\\begin{cases}\n\\frac{1}{8}\\Big(3 - 2|r| + \\sqrt{1 + 4|r| - 4 r^2}\\Big), & 0 \\le |r| < 1, \\\\\n\\frac{1}{8}\\Big(5 - 2|r| - \\sqrt{-7 + 12|r| - 4 r^2}\\Big), & 1 \\le |r| < 2, \\\\\n0, & |r| \\ge 2,\n\\end{cases}\n$$\nand the two-dimensional discrete delta\n$$\n\\delta_h(\\mathbf{x}) = \\frac{1}{h^2} \\, \\phi\\!\\left(\\frac{x}{h}\\right) \\, \\phi\\!\\left(\\frac{y}{h}\\right),\n$$\nwhere $\\mathbf{x} = (x,y)$ is measured as the minimal periodic displacement in each coordinate on the torus $[0,1)$.\n\nThe spreading operator $S$ maps Lagrangian forces $\\{\\mathbf{F}_q\\}$ to an Eulerian force field $\\{\\mathbf{f}_{i,j}\\}$ via\n$$\n\\mathbf{f}_{i,j} = \\sum_{q=0}^{N_L-1} \\mathbf{F}_q \\, \\delta_h\\!\\big((i h, j h) - \\mathbf{X}_q\\big) \\, \\Delta s,\n$$\nand the interpolation operator $J$ maps Eulerian velocities $\\{\\mathbf{u}_{i,j}\\}$ to Lagrangian velocities $\\{\\mathbf{U}_q\\}$ via\n$$\n\\mathbf{U}_q = \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\mathbf{u}_{i,j} \\, \\delta_h\\!\\big((i h, j h) - \\mathbf{X}_q\\big) \\, h^2.\n$$\n\nDefine the Eulerian inner product\n$$\n\\langle \\mathbf{u}, \\mathbf{v} \\rangle_E = \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\mathbf{u}_{i,j} \\cdot \\mathbf{v}_{i,j} \\, h^2,\n$$\nand the Lagrangian inner product\n$$\n\\langle \\mathbf{U}, \\mathbf{F} \\rangle_L = \\sum_{q=0}^{N_L-1} \\mathbf{U}_q \\cdot \\mathbf{F}_q \\, \\Delta s.\n$$\n\nStarting from these core definitions, design and implement a numerical procedure to verify adjointness by computing the two scalars $\\langle \\mathbf{u}, S \\mathbf{F} \\rangle_E$ and $\\langle J \\mathbf{u}, \\mathbf{F} \\rangle_L$ for random test fields, and then reporting the relative error\n$$\n\\varepsilon_\\mathrm{rel} = \\frac{\\big|\\langle \\mathbf{u}, S \\mathbf{F} \\rangle_E - \\langle J \\mathbf{u}, \\mathbf{F} \\rangle_L\\big|}{\\max\\big(\\big|\\langle \\mathbf{u}, S \\mathbf{F} \\rangle_E\\big|, \\big|\\langle J \\mathbf{u}, \\mathbf{F} \\rangle_L\\big|, \\epsilon\\big)},\n$$\nwhere $\\epsilon$ is a small positive constant to avoid division by zero.\n\nUse the following test suite. In all cases, the Lagrangian structure is a circle of radius $R = 0.25$ with center $\\mathbf{c}$, discretized uniformly by $N_L$ points with equal arc-length spacing $\\Delta s = 2 \\pi R / N_L$, with positions\n$$\n\\mathbf{X}_q = \\mathbf{c} + R \\big(\\cos(2\\pi q / N_L), \\sin(2\\pi q / N_L)\\big) \\quad \\text{mod } 1.\n$$\nFor reproducibility, generate the random Eulerian velocities $\\mathbf{u}_{i,j}$ and Lagrangian forces $\\mathbf{F}_q$ from a standard normal distribution using the specified seeds.\n\nTest cases:\n- Case $1$: $N = 16$, $N_L = 16$, $\\mathbf{c} = (0.5, 0.5)$, seed $= 1234$.\n- Case $2$: $N = 32$, $N_L = 32$, $\\mathbf{c} = (0.8, 0.2)$, seed $= 5678$.\n- Case $3$: $N = 64$, $N_L = 64$, $\\mathbf{c} = (0.1, 0.9)$, seed $= 42$.\n- Case $4$: $N = 64$, $N_L = 32$, $\\mathbf{c} = (0.5, 0.5)$, seed $= 2468$.\n- Case $5$: $N = 128$, $N_L = 128$, $\\mathbf{c} = (0.5, 0.5)$, seed $= 31415$.\n\nImplementation details and clarifications:\n- The minimal periodic displacement for a difference $\\Delta$ in a coordinate should be computed on the unit torus as $((\\Delta + 0.5) \\bmod 1) - 0.5$ to enforce periodicity.\n- All vector dot products are the standard Euclidean dot product in $\\mathbb{R}^2$.\n- Use $\\epsilon = 10^{-16}$ in the relative error formula.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry corresponds to the relative error $\\varepsilon_\\mathrm{rel}$ for the respective test case, reported in scientific notation with six digits after the decimal point (for example, $[1.234567\\text{e-}08,9.876543\\text{e-}12,\\dots]$).",
            "solution": "The problem requires a numerical verification of the adjoint relationship between the Lagrangian-to-Eulerian spreading operator $S$ and the Eulerian-to-Lagrangian interpolation operator $J$. This relationship is a cornerstone of the Immersed Boundary Method (IBM), as it ensures that the power exerted by the structure on the fluid is equal to the power absorbed by the structure from the fluid, thereby conserving energy at the discrete level. The formal statement of this adjointness property is $\\langle \\mathbf{u}, S \\mathbf{F} \\rangle_E = \\langle J \\mathbf{u}, \\mathbf{F} \\rangle_L$, where $\\langle \\cdot, \\cdot \\rangle_E$ and $\\langle \\cdot, \\cdot \\rangle_L$ are the Eulerian and Lagrangian inner products, respectively. Our task is to compute the two scalar quantities $\\langle \\mathbf{u}, S \\mathbf{F} \\rangle_E$ and $\\langle J \\mathbf{u}, \\mathbf{F} \\rangle_L$ for a series of test cases and report the relative error, $\\varepsilon_\\mathrm{rel}$, between them. A small error, on the order of machine precision, will serve as a strong validation of the numerical implementation.\n\nThe solution is designed around the precise mathematical definitions provided. The core component is the four-point Peskin kernel, a discrete delta function $\\delta_h(\\mathbf{x})$. This kernel is used to mediate the interaction between the aperiodic Lagrangian structure and the periodic Eulerian grid. It is defined as a product of one-dimensional kernels, $\\delta_h(x,y) = \\frac{1}{h^2} \\phi(x/h) \\phi(y/h)$, and has a finite support of $4h \\times 4h$. This finite support is computationally crucial, as it means each Lagrangian point interacts with only a small, fixed-size ($4 \\times 4$) stencil of neighboring Eulerian grid points. Special attention must be paid to the periodic nature of the domain $[0,1)^2$, requiring that all displacements are calculated as the minimal distance on the torus. The problem specifies the formula $((\\Delta + 0.5) \\pmod 1) - 0.5$ for a displacement $\\Delta$ in one coordinate, which is implemented directly.\n\nThe overall algorithm for each test case is as follows:\n\n$1$. **Initialization**: Given the parameters $N$, $N_L$, circle center $\\mathbf{c}$, and a random seed, we first compute the Eulerian grid spacing $h = 1/N$ and the Lagrangian arclength spacing $\\Delta s = 2 \\pi R / N_L$, with radius $R=0.25$.\n$2$. **Field Generation**: Using the provided seed, we generate a random Eulerian velocity field $\\{\\mathbf{u}_{i,j}\\}$ and a random Lagrangian force field $\\{\\mathbf{F}_q\\}$. The Lagrangian marker positions $\\{\\mathbf{X}_q\\}$ are deterministically placed on a circle, with their coordinates mapped into the domain $[0,1)^2$ via a modulo $1$ operation.\n$3$. **Computation of $\\langle \\mathbf{u}, S \\mathbf{F} \\rangle_E$**: This term is computed in two stages. First, we compute the Eulerian force density field $\\mathbf{f} = S\\mathbf{F}$. This is the \"spreading\" step, where we iterate through each Lagrangian point $q$. For each point, the force $\\mathbf{F}_q$ is distributed to the $4 \\times 4$ stencil of Eulerian grid points $(i,j)$ in its vicinity. The contribution to each grid point $\\mathbf{f}_{i,j}$ is weighted by $\\delta_h((ih, jh) - \\mathbf{X}_q) \\Delta s$. Once the full field $\\mathbf{f}$ is assembled, we compute the Eulerian inner product $\\langle \\mathbf{u}, \\mathbf{f} \\rangle_E = \\sum_{i,j} (\\mathbf{u}_{i,j} \\cdot \\mathbf{f}_{i,j}) h^2$.\n$4$. **Computation of $\\langle J \\mathbf{u}, \\mathbf{F} \\rangle_L$**: This term is also computed in two stages. First, we compute the Lagrangian velocity field $\\mathbf{U} = J\\mathbf{u}$. This is the \"interpolation\" step. We iterate through each Lagrangian point $q$. For each point, we compute its velocity $\\mathbf{U}_q$ by summing the weighted contributions from the Eulerian velocities $\\mathbf{u}_{i,j}$ at the same $4 \\times 4$ stencil of grid points. The weighting factor is $\\delta_h((ih, jh) - \\mathbf{X}_q) h^2$. Once the full field $\\mathbf{U}$ is assembled, we compute the Lagrangian inner product $\\langle \\mathbf{U}, \\mathbf{F} \\rangle_L = \\sum_q (\\mathbf{U}_q \\cdot \\mathbf{F}_q) \\Delta s$.\n$5$. **Error Calculation**: With the two scalars computed, we calculate the relative error $\\varepsilon_\\mathrm{rel}$ as defined in the problem, using a small constant $\\epsilon = 10^{-16}$ to prevent division by zero.\n\nThis procedure, when implemented with care for floating-point arithmetic and indexing, robustly tests the adjoint property. The two final scalars are computed by performing a large summation in two different orders. The deviation between them is an excellent measure of both the theoretical property and the implementation's fidelity.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the adjointness test for the Immersed Boundary Method.\n    \"\"\"\n    test_cases = [\n        # (N, N_L, center, seed)\n        (16, 16, (0.5, 0.5), 1234),\n        (32, 32, (0.8, 0.2), 5678),\n        (64, 64, (0.1, 0.9), 42),\n        (64, 32, (0.5, 0.5), 2468),\n        (128, 128, (0.5, 0.5), 31415),\n    ]\n\n    epsilon = 1e-16\n    R = 0.25\n    results = []\n\n    def phi(r):\n        \"\"\"\n        Computes the one-dimensional four-point Peskin kernel.\n        \"\"\"\n        r_abs = np.abs(r)\n        val = np.zeros_like(r_abs)\n        \n        # Case 1: 0 <= |r| < 1\n        mask1 = r_abs < 1\n        r1 = r_abs[mask1]\n        arg_sqrt1 = 1 + 4 * r1 - 4 * r1**2\n        # Clip to handle potential floating point inaccuracies at boundaries\n        arg_sqrt1[arg_sqrt1 < 0] = 0\n        val[mask1] = (1.0/8.0) * (3.0 - 2.0*r1 + np.sqrt(arg_sqrt1))\n        \n        # Case 2: 1 <= |r| < 2\n        mask2 = (r_abs >= 1) & (r_abs < 2)\n        r2 = r_abs[mask2]\n        arg_sqrt2 = -7.0 + 12.0*r2 - 4.0*r2**2\n        # Clip to handle potential floating point inaccuracies at boundaries\n        arg_sqrt2[arg_sqrt2 < 0] = 0\n        val[mask2] = (1.0/8.0) * (5.0 - 2.0*r2 - np.sqrt(arg_sqrt2))\n        \n        return val\n\n    def periodic_diff(v1, v2):\n        \"\"\"\n        Computes the minimal periodic displacement vector from v2 to v1\n        on the unit torus [0, 1)^2.\n        \"\"\"\n        diff = v1 - v2\n        return (diff + 0.5) % 1.0 - 0.5\n\n    for case in test_cases:\n        N, N_L, c, seed = case\n        c = np.array(c)\n        h = 1.0 / N\n        delta_s = 2.0 * np.pi * R / N_L\n\n        # Generate random fields\n        rng = np.random.default_rng(seed)\n        u_field = rng.standard_normal(size=(N, N, 2))\n        F_lagrangian = rng.standard_normal(size=(N_L, 2))\n\n        # Generate Lagrangian structure positions\n        angles = 2.0 * np.pi * np.arange(N_L) / N_L\n        X_lagrangian = np.zeros((N_L, 2))\n        X_lagrangian[:, 0] = c[0] + R * np.cos(angles)\n        X_lagrangian[:, 1] = c[1] + R * np.sin(angles)\n        X_lagrangian = X_lagrangian % 1.0\n\n        # === 1. Compute <u, S F>_E ===\n        # 1a. Compute Eulerian force field f = S(F)\n        f_eulerian = np.zeros((N, N, 2))\n        for q in range(N_L):\n            X_q = X_lagrangian[q, :]\n            F_q = F_lagrangian[q, :]\n            \n            base_idx = np.floor(X_q / h).astype(int)\n            \n            for i_off in range(-1, 3):  # Stencil covers 4x4 grid points\n                for j_off in range(-1, 3):\n                    i = (base_idx[0] + i_off) % N\n                    j = (base_idx[1] + j_off) % N\n                    \n                    grid_pos = np.array([i * h, j * h])\n                    d = periodic_diff(grid_pos, X_q)\n                    r = d / h\n                    \n                    phi_prod = phi(r[0]) * phi(r[1])\n                    if phi_prod == 0:\n                        continue\n                        \n                    delta_h_val = (1.0 / h**2) * phi_prod\n                    f_eulerian[i, j, :] += F_q * delta_h_val * delta_s\n                    \n        # 1b. Compute Eulerian inner product <u, f>\n        dot_products_E = np.sum(u_field * f_eulerian, axis=2)\n        inner_prod_E = np.sum(dot_products_E) * h**2\n\n        # === 2. Compute <J u, F>_L ===\n        # 2a. Compute Lagrangian velocity field U = J(u)\n        U_lagrangian = np.zeros((N_L, 2))\n        for q in range(N_L):\n            X_q = X_lagrangian[q, :]\n            \n            base_idx = np.floor(X_q / h).astype(int)\n\n            for i_off in range(-1, 3):\n                for j_off in range(-1, 3):\n                    i = (base_idx[0] + i_off) % N\n                    j = (base_idx[1] + j_off) % N\n                    \n                    grid_pos = np.array([i * h, j * h])\n                    d = periodic_diff(grid_pos, X_q)\n                    r = d / h\n                    \n                    phi_prod = phi(r[0]) * phi(r[1])\n                    if phi_prod == 0:\n                        continue\n\n                    delta_h_val = (1.0 / h**2) * phi_prod\n                    U_lagrangian[q, :] += u_field[i, j, :] * delta_h_val * h**2\n\n        # 2b. Compute Lagrangian inner product <U, F>\n        dot_products_L = np.sum(U_lagrangian * F_lagrangian, axis=1)\n        inner_prod_L = np.sum(dot_products_L) * delta_s\n\n        # === 3. Compute relative error ===\n        numerator = np.abs(inner_prod_E - inner_prod_L)\n        denominator = np.max([np.abs(inner_prod_E), np.abs(inner_prod_L), epsilon])\n        rel_error = numerator / denominator\n        results.append(rel_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "In the Immersed Boundary Method, the abstract concept of a 'regularized delta function' has a tangible physical meaning. By replacing a singular point force with a smoothed 'blob', we implicitly give the point an effective size in the fluid. This analytical exercise connects the numerical regularization width, $w$, to the effective hydrodynamic radius, $a_{\\mathrm{eff}}$, by drawing an analogy to the well-known Stokes drag on a sphere, providing crucial physical intuition for the parameters in your simulation. ",
            "id": "4108008",
            "problem": "Consider a single Lagrangian marker in the Immersed Boundary (IB) method that exerts a steady force $\\boldsymbol{F}$ on an incompressible fluid in the low Reynolds number regime, where the fluid dynamics are governed by the Stokes equations. Let the fluid be unbounded and Newtonian with dynamic viscosity $\\mu$. The IB spreading of the point force is performed using a regularized delta function with an effective kernel radius $w$, interpreted as the characteristic width of the radially symmetric blob that replaces the singular point force. To connect force and velocity at the marker location, approximate the hydrodynamic response using the Method of Regularized Stokeslets (MRS), whose regularization replaces the singular Stokeslet kernel with a smoothed kernel parameterized by $w$. \n\nStarting from the Stokes equations and the definition of the Greenâ€™s function (Stokeslet) for unbounded flow, use the well-tested property of the MRS that the fluid velocity at the center of a regularized point force of effective radius $w$ is finite and isotropic, and can be matched to the mobility of a rigid sphere by introducing an effective hydrodynamic radius $a_{\\mathrm{eff}}$ such that the self-mobility at the marker is equivalent to that of a sphere in Stokes flow. Use this equivalence to express $a_{\\mathrm{eff}}$ in terms of $w$, and then analyze how changing the kernel width from $w = h$ to $w = \\alpha h$ alters the drag required to maintain a fixed marker speed $U$ in Stokes flow. \n\nDefine the multiplicative change in drag $\\Lambda$ as the ratio of the drag for $w=\\alpha h$ to the drag for $w=h$, assuming $U$ is held fixed. Provide $\\Lambda$ as a closed-form expression in terms of $\\alpha$. The answer is dimensionless and requires no units. Do not round; give the exact symbolic expression.",
            "solution": "The problem statement is evaluated to be valid. It is scientifically grounded in the principles of low Reynolds number fluid dynamics and computational methods like the Immersed Boundary (IB) method and the Method of Regularized Stokeslets (MRS). The problem is well-posed, objective, and contains sufficient information to derive a unique solution.\n\nThe primary task is to determine how the drag force on a Lagrangian marker changes when its associated regularization kernel width is scaled. This can be solved by establishing a relationship between the marker's properties and those of a physical object, as guided by the problem.\n\nFirst, we establish the relationship between the effective hydrodynamic radius, $a_{\\mathrm{eff}}$, and the kernel width, $w$. The problem instructs us to equate the mobility of the Lagrangian marker with the mobility of a rigid sphere of radius $a_{\\mathrm{eff}}$.\n\nThe mobility of a rigid sphere in Stokes flow is derived from Stokes' drag law. The drag force $\\boldsymbol{F}$ on a sphere of radius $a$ moving at a constant velocity $\\boldsymbol{U}$ in a fluid with dynamic viscosity $\\mu$ is given by:\n$$\n\\boldsymbol{F} = 6\\pi\\mu a \\boldsymbol{U}\n$$\nThe velocity can be expressed in terms of the force as:\n$$\n\\boldsymbol{U} = \\frac{1}{6\\pi\\mu a} \\boldsymbol{F}\n$$\nThe scalar mobility, $M_{\\text{sphere}}$, is the coefficient relating force to velocity, so for a sphere of radius $a$:\n$$\nM_{\\text{sphere}}(a) = \\frac{1}{6\\pi\\mu a}\n$$\nFor our effective sphere of radius $a_{\\mathrm{eff}}$, the mobility is:\n$$\nM_{\\text{sphere}}(a_{\\mathrm{eff}}) = \\frac{1}{6\\pi\\mu a_{\\mathrm{eff}}}\n$$\n\nNext, we consider the Lagrangian marker modeled using the Method of Regularized Stokeslets (MRS). A cornerstone result of MRS is that a regularized point force $\\boldsymbol{F}$, spread by a kernel of characteristic width $w$, induces a finite velocity at its own center. This self-induced velocity, $\\boldsymbol{U}$, is given by the well-established relation:\n$$\n\\boldsymbol{U} = \\frac{1}{6\\pi\\mu w} \\boldsymbol{F}\n$$\nThe mobility of the marker, $M_{\\text{marker}}$, is therefore:\n$$\nM_{\\text{marker}}(w) = \\frac{1}{6\\pi\\mu w}\n$$\n\nThe problem requires us to equate these two mobilities:\n$$\nM_{\\text{marker}}(w) = M_{\\text{sphere}}(a_{\\mathrm{eff}})\n$$\nSubstituting the expressions for the mobilities yields:\n$$\n\\frac{1}{6\\pi\\mu w} = \\frac{1}{6\\pi\\mu a_{\\mathrm{eff}}}\n$$\nThis leads to a direct and simple relationship between the effective hydrodynamic radius and the kernel width:\n$$\na_{\\mathrm{eff}} = w\n$$\n\nNow, we can analyze the change in the required drag force. The drag force is the force $\\boldsymbol{F}$ required to maintain a fixed marker speed $U = |\\boldsymbol{U}|$. From the marker's mobility equation, we can express the magnitude of the drag force, $F = |\\boldsymbol{F}|$, as:\n$$\nF = (M_{\\text{marker}}(w))^{-1} U = 6\\pi\\mu w U\n$$\nThis shows that for a fixed speed $U$ and viscosity $\\mu$, the drag force is directly proportional to the kernel width $w$.\n\nWe are asked to find the multiplicative change in drag, $\\Lambda$, when the kernel width changes from a reference value $w_1 = h$ to a new value $w_2 = \\alpha h$.\nLet $F_1$ be the drag force corresponding to $w_1 = h$:\n$$\nF_1 = 6\\pi\\mu w_1 U = 6\\pi\\mu h U\n$$\nLet $F_2$ be the drag force corresponding to $w_2 = \\alpha h$:\n$$\nF_2 = 6\\pi\\mu w_2 U = 6\\pi\\mu (\\alpha h) U\n$$\n\nThe multiplicative change in drag, $\\Lambda$, is defined as the ratio of the new drag to the original drag:\n$$\n\\Lambda = \\frac{F_2}{F_1}\n$$\nSubstituting the expressions for $F_1$ and $F_2$:\n$$\n\\Lambda = \\frac{6\\pi\\mu (\\alpha h) U}{6\\pi\\mu h U}\n$$\nAll terms cancel out except for the scaling factor $\\alpha$.\n$$\n\\Lambda = \\alpha\n$$\nThus, the multiplicative change in drag is equal to the scaling factor applied to the kernel width.",
            "answer": "$$\\boxed{\\alpha}$$"
        },
        {
            "introduction": "Building a full fluid-structure interaction simulation requires coupling the IB operators with a fluid solver and a time-integration scheme for the structure's motion. This exercise challenges you to implement a complete simulation for a simple but illustrative case: a single point tethered by a spring in a Stokes flow. By employing a backward Euler method and testing its behavior with large time steps, you will gain hands-on experience with the power of implicit schemes in ensuring unconditional stability, a vital feature for stiff FSI problems. ",
            "id": "4108037",
            "problem": "Consider a two-dimensional, periodic, incompressible Stokes flow in a square domain of side length $L$, with uniform viscosity $\\mu$. A single Lagrangian structure point at position $\\mathbf{X}(t) \\in \\mathbb{R}^2$ is tethered to a fixed anchor position $\\mathbf{X}_0 \\in \\mathbb{R}^2$ by a linear Hookean spring with stiffness $k > 0$, so that the Lagrangian force is $\\mathbf{F}(\\mathbf{X}) = -k \\left( \\mathbf{X} - \\mathbf{X}_0 \\right)$. The structure is coupled to the fluid by the Immersed Boundary (IB) method, using a regularized delta function $\\delta_\\varepsilon$ of width parameter $\\sigma > 0$ in each spatial direction. The fluid equations in the steady Stokes regime and the IB coupling are\n$$\n\\mu \\Delta \\mathbf{u} - \\nabla p + \\mathbf{f} = \\mathbf{0}, \\quad \\nabla \\cdot \\mathbf{u} = 0,\n$$\n$$\n\\mathbf{f}(\\mathbf{x}) = \\mathbf{F}(\\mathbf{X}) \\, \\delta_\\varepsilon(\\mathbf{x} - \\mathbf{X}), \\quad \\mathbf{U}(\\mathbf{X}) = \\int_{\\Omega} \\mathbf{u}(\\mathbf{x}) \\, \\delta_\\varepsilon(\\mathbf{x} - \\mathbf{X}) \\, \\mathrm{d}\\mathbf{x},\n$$\nwhere $\\mathbf{u}$ is the Eulerian fluid velocity, $p$ is the pressure, $\\mathbf{f}$ is the Eulerian force density due to the structure, and $\\mathbf{U}(\\mathbf{X})$ is the interpolated fluid velocity at the Lagrangian point.\n\nYour task is to implement a backward Euler time-stepping update for the Lagrangian point in the steady Stokes regime and to verify unconditional stability by computing the discrete energy change. All quantities are nondimensional. The backward Euler update is defined implicitly by\n$$\n\\mathbf{X}^{n+1} = \\mathbf{X}^n + \\Delta t \\, \\mathbf{U}\\!\\left(\\mathbf{X}^{n+1}\\right),\n$$\nwith $\\Delta t > 0$ the time step and $\\mathbf{U}(\\cdot)$ determined by the Stokes solution with the IB coupling. The regularized delta function $\\delta_\\varepsilon$ must be taken as a separable Gaussian with width $\\sigma$, namely in one dimension\n$$\n\\phi_\\sigma(x) = \\frac{1}{\\sqrt{\\pi}\\,\\sigma} \\exp\\!\\left( - \\frac{x^2}{\\sigma^2} \\right),\n$$\nand in two dimensions $\\delta_\\varepsilon(\\mathbf{x}) = \\phi_\\sigma(x) \\, \\phi_\\sigma(y)$, interpreted periodically.\n\nYou must:\n- Discretize the periodic domain on an $N_x \\times N_y$ uniform grid with spacing $h = L/N_x = L/N_y$ and solve the steady Stokes equations spectrally by projecting the Fourier transform of $\\mathbf{f}$ onto divergence-free modes and inverting the Laplacian. Use the $k$-space projection $\\mathbf{P}(\\mathbf{k}) = \\mathbf{I} - \\frac{\\mathbf{k}\\mathbf{k}^\\top}{\\|\\mathbf{k}\\|^2}$ for $\\mathbf{k}\\neq \\mathbf{0}$, and set the zero mode of $\\mathbf{u}$ to zero.\n- Implement IB spreading and interpolation with the separable Gaussian kernel, ensuring the discrete weights are normalized so that $\\sum_{i,j} w_{i,j} h^2 = 1$ and interpolation approximates $\\int \\mathbf{u} \\, \\delta_\\varepsilon \\, \\mathrm{d}\\mathbf{x}$.\n- For a single Lagrangian point, numerically compute the self-mobility scalar $m(\\sigma,\\mu,L)$ defined by $\\mathbf{U} = m \\, \\mathbf{F}$ when the structure is located at a grid point and the Gaussian is centered on that point. Use this to evaluate the backward Euler update for the linear spring tether.\n- For each test case, compute the discrete energy $E^n = \\frac{1}{2} k \\left\\|\\mathbf{X}^n - \\mathbf{X}_0\\right\\|^2$ and the energy change $\\Delta E = E^{n+1} - E^n$; report $\\Delta E$.\n\nUse the following test suite, which varies the time step $\\Delta t$, stiffness $k$, and kernel width $\\sigma$ to probe unconditional stability and the damping introduced by the regularized kernel. In all cases, take $L = 1$, place the anchor at the domain center $\\mathbf{X}_0 = (L/2, L/2)$, and initialize $\\mathbf{X}^n = \\mathbf{X}_0 + \\mathbf{d}$.\n\n- Test case 1 (happy path): $N_x = N_y = 64$, $\\mu = 1$, $k = 100$, $\\Delta t = 10$, $\\sigma = 1.5 h$, $\\mathbf{d} = (0.1, -0.05)$.\n- Test case 2 (extremely large time step and stiffness): $N_x = N_y = 64$, $\\mu = 1$, $k = 10^5$, $\\Delta t = 1000$, $\\sigma = 1.5 h$, $\\mathbf{d} = (0.2, 0.2)$.\n- Test case 3 (narrow kernel): $N_x = N_y = 64$, $\\mu = 1$, $k = 1000$, $\\Delta t = 1$, $\\sigma = 0.5 h$, $\\mathbf{d} = (0.05, -0.02)$.\n- Test case 4 (wide kernel): $N_x = N_y = 64$, $\\mu = 1$, $k = 100$, $\\Delta t = 1$, $\\sigma = 3 h$, $\\mathbf{d} = (0.02, 0.01)$.\n- Test case 5 (boundary case with zero initial displacement): $N_x = N_y = 64$, $\\mu = 1$, $k = 100$, $\\Delta t = 10$, $\\sigma = 1.5 h$, $\\mathbf{d} = (0, 0)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5]$), where each $r_i$ is the floating-point value of $\\Delta E$ for the corresponding test case. All quantities are nondimensional, and angles are not involved.",
            "solution": "The user-provided problem is assessed to be **valid**. It is scientifically grounded in the principles of computational fluid dynamics, specifically the Immersed Boundary (IB) method for Stokes flow. The problem is well-posed, with all necessary parameters and equations defined, leading to a unique and computable solution. The language is objective and the setup is consistent.\n\nThe solution proceeds in four main stages:\n1.  **Spectral Stokes Solver**: The steady, incompressible Stokes equations on a periodic domain are solved efficiently using a Fourier spectral method.\n2.  **Immersed Boundary Coupling**: The interaction between the fluid and the Lagrangian structure is handled via a regularized Gaussian delta function, properly periodized for the domain.\n3.  **Mobility Calculation**: A key parameter, the scalar mobility $m$, is computed. This constant relates the force applied by the structure to the resulting velocity it experiences, under the approximation that the mobility tensor is diagonal and isotropic. This is justified by the symmetry of the setup.\n4.  **Backward Euler Time Step**: The position of the Lagrangian point is updated using an implicit backward Euler scheme, which is known to be unconditionally stable. The change in the system's potential energy is computed to verify this property.\n\n### 1. Theoretical Formulation\n\nThe fluid-structure system is described by the following equations:\n-   **Stokes Flow**: $\\mu \\Delta \\mathbf{u} - \\nabla p + \\mathbf{f} = \\mathbf{0}$ with $\\nabla \\cdot \\mathbf{u} = 0$, where $\\mu$ is viscosity, $\\mathbf{u}$ is fluid velocity, $p$ is pressure, and $\\mathbf{f}$ is the force density from the structure.\n-   **Lagrangian Force**: A linear spring connects the point $\\mathbf{X}$ to an anchor $\\mathbf{X}_0$: $\\mathbf{F} = -k(\\mathbf{X} - \\mathbf{X}_0)$.\n-   **IB Coupling**: Force is spread to the fluid via a delta function $\\delta_\\varepsilon$: $\\mathbf{f}(\\mathbf{x}) = \\mathbf{F} \\delta_\\varepsilon(\\mathbf{x} - \\mathbf{X})$. Fluid velocity is interpolated back to the point: $\\mathbf{U}(\\mathbf{X}) = \\int \\mathbf{u}(\\mathbf{x}) \\delta_\\varepsilon(\\mathbf{x} - \\mathbf{X}) d\\mathbf{x}$.\n-   **Lagrangian Point Motion**: The point moves with the interpolated fluid velocity: $d\\mathbf{X}/dt = \\mathbf{U}(\\mathbf{X})$.\n\nThe time evolution is discretized using a backward Euler step:\n$$\n\\frac{\\mathbf{X}^{n+1} - \\mathbf{X}^n}{\\Delta t} = \\mathbf{U}(\\mathbf{X}^{n+1})\n$$\nThe problem is linear, so velocity $\\mathbf{U}$ is linearly proportional to the force $\\mathbf{F}$. This relationship is defined by a mobility operator $\\mathcal{M}$: $\\mathbf{U} = \\mathcal{M}[\\mathbf{F}]$. Due to the symmetries of the periodic domain and the isotropic kernel, this operator can be approximated by a scalar mobility $m$, such that $\\mathbf{U} \\approx m \\mathbf{F}$. The force at step $n+1$ is $\\mathbf{F}^{n+1} = -k(\\mathbf{X}^{n+1} - \\mathbf{X}_0)$. Substituting these into the backward Euler equation yields:\n$$\n\\mathbf{X}^{n+1} - \\mathbf{X}^n = \\Delta t \\, m \\left( -k(\\mathbf{X}^{n+1} - \\mathbf{X}_0) \\right)\n$$\nRearranging for $\\mathbf{X}^{n+1}$, we obtain a direct update formula:\n$$\n\\mathbf{X}^{n+1} (1 + k m \\Delta t) = \\mathbf{X}^n + k m \\Delta t \\mathbf{X}_0\n$$\n$$\n\\mathbf{X}^{n+1} = \\frac{1}{1 + k m \\Delta t} \\mathbf{X}^n + \\frac{k m \\Delta t}{1 + k m \\Delta t} \\mathbf{X}_0\n$$\nThis update is unconditionally stable, as the prefactor for $\\mathbf{X}^n - \\mathbf{X}_0$ is always less than $1$ for $k, m, \\Delta t > 0$. The potential energy of the spring is $E = \\frac{1}{2} k \\|\\mathbf{X} - \\mathbf{X}_0\\|^2$. The change in energy, $\\Delta E = E^{n+1} - E^{n}$, must be negative (or zero if already at equilibrium), signifying energy dissipation into the fluid.\n\n### 2. Numerical Implementation\n\n**Spectral Stokes Solver:**\nWe discretize the domain $\\Omega = [0, L] \\times [0, L]$ on an $N \\times N$ grid with spacing $h = L/N$. In Fourier space, the Stokes equations become algebraic. The Fourier transform of the velocity, $\\hat{\\mathbf{u}}$, is found from the Fourier transform of the force density, $\\hat{\\mathbf{f}}$:\n$$\n\\hat{\\mathbf{u}}(\\mathbf{k}) = \\frac{1}{\\mu \\|\\mathbf{k}\\|^2} \\mathbf{P}(\\mathbf{k}) \\hat{\\mathbf{f}}(\\mathbf{k}), \\quad \\text{for } \\mathbf{k} \\neq \\mathbf{0}\n$$\nwhere $\\mathbf{k}=(k_x, k_y)$ is the wavevector, $\\|\\mathbf{k}\\|^2 = k_x^2 + k_y^2$, and $\\mathbf{P}(\\mathbf{k}) = \\mathbf{I} - \\mathbf{k}\\mathbf{k}^\\top / \\|\\mathbf{k}\\|^2$ is the projection operator that enforces the divergence-free condition $\\nabla \\cdot \\mathbf{u}=0$. The zero-wavenumber mode $\\hat{\\mathbf{u}}(\\mathbf{0})$ is set to zero.\n\n**Regularized Delta Function:**\nThe Gaussian kernel $\\delta_\\varepsilon(\\mathbf{x}) = \\phi_\\sigma(x)\\phi_\\sigma(y)$ with $\\phi_\\sigma(z) = (\\sqrt{\\pi}\\sigma)^{-1} \\exp(-z^2/\\sigma^2)$ must be made periodic on the domain. This is achieved by summing over periodic images: $\\phi_{p,\\sigma}(z) = \\sum_{l=-\\infty}^{\\infty} \\phi_\\sigma(z - lL)$. In practice, summing over a few images (e.g., $l \\in \\{-1, 0, 1\\}$) is sufficient due to the rapid decay of the Gaussian.\n\nThe discrete weights for spreading and interpolation, $w_{ij} = \\delta_\\varepsilon(\\mathbf{x}_{ij}-\\mathbf{X})$, are computed. To ensure that the total force applied to the fluid equals the Lagrangian force ($\\sum_{i,j} \\mathbf{f}_{ij} h^2 = \\mathbf{F}$), we enforce the discrete normalization $\\sum_{i,j} w_{ij} h^2 = 1$ by dividing the raw weights by their discrete sum multiplied by $h^2$.\n\n**Mobility Calculation ($m$):**\nThe scalar mobility $m$ is computed numerically once for each unique set of parameters $(\\sigma, \\mu, L, N)$.\n1.  A test force $\\mathbf{F}_{\\text{test}} = (1, 0)$ is applied at a grid-centered Lagrangian point $\\mathbf{X}_c$.\n2.  The force is spread to the grid nodes: $\\mathbf{f}_{ij} = \\mathbf{F}_{\\text{test}} \\cdot w_{ij}$, where $w_{ij}$ are the normalized weights corresponding to $\\mathbf{X}_c$.\n3.  The force field $\\mathbf{f}$ is transformed to Fourier space ($\\hat{\\mathbf{f}}$).\n4.  The Stokes equations are solved for the velocity field in Fourier space ($\\hat{\\mathbf{u}}$).\n5.  The velocity field is transformed back to real space ($\\mathbf{u}$).\n6.  The velocity is interpolated back to the Lagrangian point: $\\mathbf{U} = \\sum_{i,j} \\mathbf{u}_{ij} w_{ij} h^2$.\n7.  The mobility is computed as $m = U_x / F_{\\text{test},x}$. Due to symmetry, $U_y$ should be negligible.\n\n**Main Algorithm:**\nFor each test case:\n1.  Determine parameters $N, \\mu, k, \\Delta t, \\sigma$, and initial displacement $\\mathbf{d}$.\n2.  Retrieve or compute the mobility $m$ for the given $\\sigma$ and $\\mu$.\n3.  Set the anchor $\\mathbf{X}_0=(L/2, L/2)$ and initial position $\\mathbf{X}^n = \\mathbf{X}_0 + \\mathbf{d}$.\n4.  Calculate the initial energy $E^n = \\frac{1}{2} k \\|\\mathbf{d}\\|^2$.\n5.  If $\\mathbf{d}=\\mathbf{0}$, the system is at equilibrium, so $\\Delta E = 0$.\n6.  Otherwise, compute the new position $\\mathbf{X}^{n+1}$ using the explicit backward Euler update formula.\n7.  Calculate the final energy $E^{n+1} = \\frac{1}{2} k \\|\\mathbf{X}^{n+1} - \\mathbf{X}_0\\|^2$.\n8.  The final result is the energy change $\\Delta E = E^{n+1} - E^n$.\nThis procedure is repeated for all test cases. The results confirm that $\\Delta E \\le 0$ in all cases, demonstrating the dissipative and stable nature of the numerical scheme.",
            "answer": "```python\nimport numpy as np\n\ndef periodic_gaussian_1d(x, sigma, L, num_periods=2):\n    \"\"\"\n    Computes a 1D periodic Gaussian by summing over neighboring periods.\n    The sum is over l from -num_periods to +num_periods.\n    \"\"\"\n    val = np.zeros_like(x, dtype=float)\n    for l in range(-num_periods, num_periods + 1):\n        val += np.exp(-((x - l * L)**2) / sigma**2)\n    return val / (np.sqrt(np.pi) * sigma)\n\ndef get_delta_weights(X_lagrangian, grid_1d, sigma, L, h):\n    \"\"\"\n    Computes the normalized discrete delta function weights on the grid.\n    \n    Args:\n        X_lagrangian (np.ndarray): Lagrangian point position (x, y).\n        grid_1d (np.ndarray): 1D array for Eulerian grid coordinates.\n        sigma (float): Width of the Gaussian kernel.\n        L (float): Domain side length.\n        h (float): Grid spacing.\n        \n    Returns:\n        np.ndarray: 2D array of normalized weights.\n    \"\"\"\n    # Create 2D meshgrids for distances dx and dy\n    # Use 'ij' indexing to match (row, col) with (x, y)\n    dx = grid_1d[:, np.newaxis] - X_lagrangian[0]\n    dy = grid_1d[np.newaxis, :] - X_lagrangian[1]\n    \n    # Compute 1D periodic Gaussians along each axis\n    phi_x = periodic_gaussian_1d(dx, sigma, L)\n    phi_y = periodic_gaussian_1d(dy, sigma, L)\n    \n    # Raw 2D weights are the separable product\n    weights_raw = phi_x * phi_y\n    \n    # Normalize to ensure the discrete integral (sum * h^2) is exactly 1\n    normalization_factor = np.sum(weights_raw) * h**2\n    if normalization_factor < 1e-12: # Avoid division by zero if kernel is too narrow\n        return np.zeros_like(weights_raw)\n    weights = weights_raw / normalization_factor\n    \n    return weights\n\ndef calculate_mobility(N, L, mu, sigma):\n    \"\"\"\n    Calculates the scalar mobility 'm' for a single point in a periodic\n    Stokes flow using a spectral method.\n    \"\"\"\n    h = L / N\n    grid_1d = np.arange(N) * h\n    \n    # Per problem spec, place structure at a grid point for mobility calculation.\n    # For even N, (L/2, L/2) is a grid point, e.g., grid_1d[N//2].\n    X_center = np.array([L/2, L/2])\n\n    # Get discrete delta weights for a point centered on the grid\n    weights = get_delta_weights(X_center, grid_1d, sigma, L, h)\n    \n    # Apply a unit test force along x-axis\n    F_test = np.array([1.0, 0.0])\n    \n    # 1. Spread force to the grid (force density field)\n    force_grid_x = F_test[0] * weights\n    force_grid_y = F_test[1] * weights # This is an array of zeros\n\n    # 2. FFT of the force field\n    f_hat_x = np.fft.fft2(force_grid_x)\n    f_hat_y = np.fft.fft2(force_grid_y)\n    \n    # 3. Solve for velocity in Fourier space\n    # Set up wavenumbers\n    k_freq = np.fft.fftfreq(N, h)\n    kx_1d = 2 * np.pi * k_freq\n    ky_1d = 2 * np.pi * k_freq\n    kx, ky = np.meshgrid(kx_1d, ky_1d, indexing='ij')\n    \n    ksq = kx**2 + ky**2\n    \n    u_hat_x = np.zeros_like(f_hat_x)\n    u_hat_y = np.zeros_like(f_hat_y)\n    \n    # Find non-zero wavenumbers to avoid division by zero at k=0\n    nonzero_k = ksq > 1e-12\n    \n    # Project force onto divergence-free space\n    k_dot_f_hat = kx[nonzero_k] * f_hat_x[nonzero_k] + ky[nonzero_k] * f_hat_y[nonzero_k]\n    \n    P_f_hat_x = f_hat_x[nonzero_k] - kx[nonzero_k] * k_dot_f_hat / ksq[nonzero_k]\n    P_f_hat_y = f_hat_y[nonzero_k] - ky[nonzero_k] * k_dot_f_hat / ksq[nonzero_k]\n\n    # Invert Laplacian (Stokeslet in Fourier space)\n    u_hat_x[nonzero_k] = P_f_hat_x / (mu * ksq[nonzero_k])\n    u_hat_y[nonzero_k] = P_f_hat_y / (mu * ksq[nonzero_k])\n    \n    # 4. IFFT to get real-space velocity field\n    u_x = np.real(np.fft.ifft2(u_hat_x))\n    u_y = np.real(np.fft.ifft2(u_hat_y))\n    \n    # 5. Interpolate velocity at the point using the same weights\n    U_x = np.sum(u_x * weights) * h**2\n    # U_y = np.sum(u_y * weights) * h**2 # Should be near zero by symmetry\n\n    # Mobility m = U_x / F_test_x\n    return U_x\n\ndef solve():\n    test_cases = [\n        {'Nx': 64, 'Ny': 64, 'mu': 1, 'k': 100,    'dt': 10,  'sigma_h': 1.5, 'd': (0.1, -0.05)},\n        {'Nx': 64, 'Ny': 64, 'mu': 1, 'k': 1e5,    'dt': 1000,'sigma_h': 1.5, 'd': (0.2, 0.2)},\n        {'Nx': 64, 'Ny': 64, 'mu': 1, 'k': 1000,   'dt': 1,   'sigma_h': 0.5, 'd': (0.05, -0.02)},\n        {'Nx': 64, 'Ny': 64, 'mu': 1, 'k': 100,    'dt': 1,   'sigma_h': 3.0, 'd': (0.02, 0.01)},\n        {'Nx': 64, 'Ny': 64, 'mu': 1, 'k': 100,    'dt': 10,  'sigma_h': 1.5, 'd': (0.0, 0.0)},\n    ]\n\n    L = 1.0\n    results = []\n    mobility_cache = {}\n\n    for case in test_cases:\n        N = case['Nx']\n        mu = case['mu']\n        h = L / N\n        sigma = case['sigma_h'] * h\n\n        # Use caching for mobility calculation as it only depends on N, mu, sigma\n        cache_key = (N, mu, sigma)\n        if cache_key in mobility_cache:\n            m = mobility_cache[cache_key]\n        else:\n            m = calculate_mobility(N, L, mu, sigma)\n            mobility_cache[cache_key] = m\n            \n        k = case['k']\n        dt = case['dt']\n        d = np.array(case['d'])\n        X0 = np.array([L/2, L/2])\n        \n        # Initial state\n        Xn = X0 + d\n        En = 0.5 * k * np.sum(d**2)\n        \n        # Handle equilibrium case\n        if np.allclose(d, 0):\n            results.append(0.0)\n            continue\n            \n        # Backward Euler Update for X^{n+1}\n        # X^{n+1} = (X^n + k*m*dt*X0) / (1 + k*m*dt)\n        gamma = k * m * dt\n        X_np1 = (Xn + gamma * X0) / (1.0 + gamma)\n\n        # Final energy and energy change\n        d_np1 = X_np1 - X0\n        E_np1 = 0.5 * k * np.sum(d_np1**2)\n        delta_E = E_np1 - En\n        results.append(delta_E)\n\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}