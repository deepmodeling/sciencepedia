{
    "hands_on_practices": [
        {
            "introduction": "在深入研究复杂的模拟之前，理解控制粘弹性流动的基本参数至关重要。惯性、粘性和弹性之间的相互作用决定了流动状态，这可以通过无量纲数来捕捉：雷诺数（$Re$）、魏森贝格数（$Wi$）和弹性数（$El$）。本练习将巩固您对这些关键参数的理解，以及它们的值如何预示弹性湍流的可能性，该状态的特点是低惯性（$Re \\ll 1$）和高弹性（$Wi \\gg 1$）。",
            "id": "4084941",
            "problem": "在微通道中流动的稀聚合物溶液被建模为不可压缩的粘弹性流体。假设动量平衡由线性动量守恒给出，其中包括粘性应力和一个附加的聚合物额外应力，并且该聚合物额外应力遵循具有有限弛豫时间的单模线性弹性本构定律。特征尺度为溶液的长度 $L$、速度 $U$ 和总动力粘度 $\\eta$。设流体密度为 $\\rho$，聚合物弛豫时间为 $\\lambda$。流动是稳态的，其几何形状可能产生曲率或弱拉伸区域，尽管此处的分析仅关注通过无量纲化产生的内在无量纲群。\n\n从不可压缩流体的线性动量平衡和具有弛豫时间的线性粘弹性本构关系出发，使用尺度 $L$ 和 $U$ 进行无量纲化，以确定比较惯性与粘性应力、弹性弛豫与流动时间以及弹性效应与惯性的无量纲数。然后，使用以下适用于微通道流动的物理一致参数：\n- 平均速度 $U = 5.0 \\times 10^{-2}\\ \\text{m}\\,\\text{s}^{-1}$，\n- 特征长度 $L = 1.0 \\times 10^{-4}\\ \\text{m}$，\n- 总动力粘度 $\\eta = 1.0 \\times 10^{-1}\\ \\text{Pa}\\,\\text{s}$，\n- 密度 $\\rho = 1.0 \\times 10^{3}\\ \\text{kg}\\,\\text{m}^{-3}$，\n- 聚合物弛豫时间 $\\lambda = 5.0 \\times 10^{-1}\\ \\text{s}$，\n\n计算由无量纲化得出的雷诺数、魏森贝格数和弹性数。将每个无量纲数四舍五入至三位有效数字。仅根据这些无量纲数的大小，在解中提供一个科学合理的分类，说明在合适的几何形状中流动是否会表现出弹性湍流，并注明任何必要条件。将您的最终数值答案表示为一个行矩阵，按顺序包含雷诺数、魏森贝格数和弹性数。在最终的方框答案中不要包含任何单位。",
            "solution": "所述问题具有科学依据、提法恰当且客观。所有必要的参数都已提供，并且对于涉及聚合物溶液的微流体实验而言，这些参数在物理上是一致的。该任务涉及对粘弹性流体动力学控制方程进行标准的量纲分析，并解释由此产生的无量纲数，这是该领域的一项基本练习。因此，该问题是有效的，可以构建一个解。\n\n分析始于稳态、不可压缩流体流动的线性动量守恒：\n$$\n\\rho (\\mathbf{u} \\cdot \\nabla \\mathbf{u}) = -\\nabla p + \\nabla \\cdot \\boldsymbol{\\tau}\n$$\n其中，$\\rho$ 是流体密度，$\\mathbf{u}$ 是速度场，$p$ 是压力，$\\boldsymbol{\\tau}$ 是额外应力张量。对于粘弹性流体，该应力张量包括粘性贡献和弹性贡献。问题提供了一个总动力粘度 $\\eta$，我们将用它来表征粘性应力。\n\n我们使用所提供的特征尺度对控制方程进行无量纲化：长度 $L$、速度 $U$、密度 $\\rho$、粘度 $\\eta$ 和聚合物弛豫时间 $\\lambda$。我们定义无量纲变量（用撇号表示）如下：\n$$\n\\mathbf{u}' = \\frac{\\mathbf{u}}{U}, \\quad \\nabla' = L \\nabla, \\quad p' = \\frac{p}{\\rho U^2}, \\quad \\boldsymbol{\\tau}' = \\frac{\\boldsymbol{\\tau} L}{\\eta U}\n$$\n将这些代入动量方程并对各项进行标度，可以洞察相关的无量纲群。\n\n左侧的惯性项的尺度为：\n$$\n|\\rho (\\mathbf{u} \\cdot \\nabla \\mathbf{u})| \\sim \\frac{\\rho U^2}{L}\n$$\n右侧散度项的粘性应力贡献的尺度为：\n$$\n|\\nabla \\cdot \\boldsymbol{\\tau}_{visc}| \\sim \\frac{\\eta U}{L^2}\n$$\n第一个无量纲数是比较惯性与粘性应力的雷诺数，$Re$。它是惯性项与粘性项大小之比：\n$$\nRe = \\frac{\\text{惯性力}}{\\text{粘性力}} \\sim \\frac{\\rho U^2 / L}{\\eta U / L^2} = \\frac{\\rho U L}{\\eta}\n$$\n\n第二个无量纲数比较了材料的弛豫时间 $\\lambda$ 与流动过程的特征时间尺度。流动时间尺度是流体单元以速度 $U$ 行进特征长度 $L$ 所需的时间，即 $t_{flow} = L/U$。这个比率是魏森贝格数，$Wi$：\n$$\nWi = \\frac{\\text{弛豫时间}}{\\text{流动时间}} = \\frac{\\lambda}{L/U} = \\frac{\\lambda U}{L}\n$$\n魏森贝格数用于量化流动中的弹性响应程度。对于 $Wi \\gg 1$，流体的行为呈弹性，因为变形速率远快于流体弛豫应力的能力。\n\n第三个无量纲数比较了弹性效应与惯性。这通常由弹性数 $El$ 给出，它被定义为魏森贝格数与雷诺数的比值：\n$$\nEl = \\frac{Wi}{Re} = \\frac{\\lambda U / L}{\\rho U L / \\eta} = \\frac{\\lambda \\eta}{\\rho L^2}\n$$\n该数与流速 $U$ 无关，代表了材料和几何特性的比率。它比较了流体的粘弹性时间尺度（$\\lambda$）与动量粘性扩散的时间尺度（$\\rho L^2 / \\eta$）。大的 $El$ 值表明与惯性效应相比，弹性效应非常显著。\n\n接下来，我们使用提供的参数计算这些无量纲数的值：\n-   $U = 5.0 \\times 10^{-2}\\ \\text{m}\\,\\text{s}^{-1}$\n-   $L = 1.0 \\times 10^{-4}\\ \\text{m}$\n-   $\\eta = 1.0 \\times 10^{-1}\\ \\text{Pa}\\,\\text{s}$\n-   $\\rho = 1.0 \\times 10^{3}\\ \\text{kg}\\,\\text{m}^{-3}$\n-   $\\lambda = 5.0 \\times 10^{-1}\\ \\text{s}$\n\n雷诺数为：\n$$\nRe = \\frac{\\rho U L}{\\eta} = \\frac{(1.0 \\times 10^{3}) \\times (5.0 \\times 10^{-2}) \\times (1.0 \\times 10^{-4})}{1.0 \\times 10^{-1}} = \\frac{5.0 \\times 10^{-3}}{1.0 \\times 10^{-1}} = 5.0 \\times 10^{-2}\n$$\n四舍五入至三位有效数字，$Re = 5.00 \\times 10^{-2}$。\n\n魏森贝格数为：\n$$\nWi = \\frac{\\lambda U}{L} = \\frac{(5.0 \\times 10^{-1}) \\times (5.0 \\times 10^{-2})}{1.0 \\times 10^{-4}} = \\frac{2.5 \\times 10^{-2}}{1.0 \\times 10^{-4}} = 2.5 \\times 10^{2}\n$$\n四舍五入至三位有效数字，$Wi = 2.50 \\times 10^{2}$。\n\n弹性数为：\n$$\nEl = \\frac{Wi}{Re} = \\frac{2.50 \\times 10^{2}}{5.00 \\times 10^{-2}} = 5.0 \\times 10^{3}\n$$\n或者，使用其定义：\n$$\nEl = \\frac{\\lambda \\eta}{\\rho L^2} = \\frac{(5.0 \\times 10^{-1}) \\times (1.0 \\times 10^{-1})}{(1.0 \\times 10^{3}) \\times (1.0 \\times 10^{-4})^2} = \\frac{5.0 \\times 10^{-2}}{1.0 \\times 10^{-5}} = 5.0 \\times 10^{3}\n$$\n四舍五入至三位有效数字，$El = 5.00 \\times 10^{3}$。\n\n最后，我们根据这些值对流态进行分类。弹性湍流现象是一种混沌流态，它在粘弹性流体中因纯粹的弹性不稳定性而产生，且没有显著的惯性。其发生的条件是：\n1.  非常低的雷诺数，通常 $Re \\ll 1$。我们计算出的值为 $Re = 0.05$，这表明流动处于蠕动流状态，惯性效应可以忽略不计。经典的、由惯性驱动的湍流是不可能发生的。\n2.  高魏森贝格数，通常 $Wi \\gg 1$。我们的值为 $Wi = 250$，表明与粘性应力相比，弹性应力非常大。聚合物被流动显著拉伸，储存了大量的弹性能量。\n3.  具有弯曲流线的流动几何形状。问题陈述明确允许了这种可能性。在这些条件下，由沿弯曲流线拉伸的聚合物中的张力驱动的纯弹性不稳定性可以引发混沌动力学。\n\n计算出的无量纲数 $Re \\ll 1$ 和 $Wi \\gg 1$ 是弹性湍流状态的决定性特征。非常大的弹性数 $El = 5000$ 进一步强调了弹性效应相对于惯性效应的压倒性优势。因此，在具有曲率的合适几何形状下，预测流动将处于弹性湍流状态。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 5.00 \\times 10^{-2}  2.50 \\times 10^{2}  5.00 \\times 10^{3} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在模拟聚合物动力学时，尤其是在混沌流中，标准的数值方法可能会失效，导致非物理结果。一个关键的挑战是维持一个物理约束，即代表聚合物伸长的构象张量必须保持对称正定（SPD）。本练习对比了一种可能违反 SPD 条件的朴素数值格式和一种更稳健的保正定性算子分裂格式。通过实现和测试这两种方法，您将获得计算流变学中数值精妙之处的实践经验，并理解为何专门的算法对于模拟弹性湍流至关重要。",
            "id": "4084943",
            "problem": "考虑一个空间均匀的稀聚合物溶液，其由构象张量 $C(t) \\in \\mathbb{R}^{2 \\times 2}$ 建模。该张量代表聚合物端到端矢量的二阶矩，且必须始终保持对称正定 (Symmetric Positive Definite, SPD)。在无量纲形式中，由给定的随时间变化的速度梯度驱动的 Oldroyd-B 均匀本构演化，其特征是 $C$ 以 $1/Wi$ 的速率向单位张量 $I$ 进行线性松弛，并伴随由速度梯度 $G(t) \\in \\mathbb{R}^{2 \\times 2}$ 引起的仿射形变。该问题的基本前提是，$C$ 是一个类协方差张量，对于任意非零向量 $v$ 都必须满足 $v^{\\top} C v > 0$；并且，当 $C(0)$ 是对称正定时，由 $G(t)$ 生成的 $M(t)$ 所产生的连续时间仿射形变 $C(t) = M(t) C(0) M(t)^{\\top}$ 会保持正定性。此外，一个通过凸组合将 $C$ 更新至 $I$ 的松弛步骤也会保持对称正定性。\n\n您的任务是设计并实现一个对 $C(t)$ 在数值时间积分下的正定性进行计算验证的程序，并评估一个保正定性格式的收敛性。此问题中的所有量均为无量纲；如果三角函数内部出现角度，则必须以弧度为单位。\n\n将离散时间 $t_k$ 处速度梯度规定为\n$$\nG_k = \\begin{pmatrix}\n0  \\gamma_k \\\\\n-\\gamma_k  s_k\n\\end{pmatrix},\n$$\n其中\n$$\n\\gamma_k = \\omega \\sin(2\\pi \\phi_k), \\quad s_k = s_0 + \\epsilon \\sin(2\\pi \\psi_k),\n$$\n并且 $(\\phi_k)$ 和 $(\\psi_k)$ 是由逻辑斯蒂映射\n$$\nx_{k+1} = r x_k (1 - x_k),\n$$\n生成的序列，其中 $r = 4$，并给定种子 $\\phi_0 \\in (0,1)$，$\\psi_0 \\in (0,1)$。这种确定性混沌源模拟了弹性湍流和混沌聚合物拉伸中典型的脉动拉伸。\n\n为 $C$ 的演化实现两种数值时间步进格式，步长为 $\\Delta t$，共 $N$ 步：\n1. 一种朴素显式格式：\n$$\nC_{k+1}^{\\mathrm{E}} = C_k^{\\mathrm{E}} + \\Delta t \\left( G_k C_k^{\\mathrm{E}} + C_k^{\\mathrm{E}} G_k^{\\top} - \\frac{1}{Wi}\\left( C_k^{\\mathrm{E}} - I \\right) \\right).\n$$\n2. 一种基于仿射形变和松弛的保正定性算子分裂格式：\n$$\nM_k = \\exp\\left(G_k \\Delta t\\right), \\qquad \\alpha = \\exp\\left(-\\frac{\\Delta t}{Wi}\\right),\n$$\n$$\n\\widetilde{C}_{k+1} = M_k \\left( (1 - \\alpha) I + \\alpha \\widetilde{C}_k \\right) M_k^{\\top}.\n$$\n从基本性质可知，当 $M$ 可逆时，精确的仿射形变更新 $C \\mapsto M C M^{\\top}$ 会保持对称正定性；并且当 $\\alpha \\in (0,1)$ 时，凸松弛 $C \\mapsto (1-\\alpha) I + \\alpha C$ 也会保持对称正定性。因此，当精确实现时，它们的组合会保持对称正定性。\n\n验证任务：\n- 对于显式格式，在每一步进行特征值检查：使用对称矩阵的特征值分解计算最小特征值 $\\lambda_{\\min}(C_k^{\\mathrm{E}})$，如果任何 $\\lambda_{\\min}(C_k^{\\mathrm{E}}) \\leq \\tau$，则声明违规，容差 $\\tau = 10^{-12}$ 用于考虑浮点舍入误差。如果检测到违规，应用特征值裁剪的修正策略以继续计算（将任何非正特征值替换为 $\\tau$ 并重构 $C$），但要记录违规已发生。\n- 对于算子分裂格式，类似地追踪 $\\lambda_{\\min}(\\widetilde{C}_k)$ 并验证在使用精确矩阵指数更新时没有发生违规。\n\n收敛性评估：\n- 对于算子分裂格式，分别使用步长 $\\Delta t$ 和步长 $\\Delta t/2$ 计算在时间 $T$ 的最终构象张量（两者均从相同的初始张量开始），并报告两个最终张量之差的弗罗贝尼乌斯范数，\n$$\n\\| \\widetilde{C}^{\\Delta t}(T) - \\widetilde{C}^{\\Delta t/2}(T) \\|_F,\n$$\n对于一阶分裂格式，随着 $\\Delta t$ 的减小，该值应该减小。\n\n实现细节：\n- 使用由 $(\\phi_k)$ 和 $(\\psi_k)$ 序列及参数定义的给定混沌速度梯度。\n- 完全在 $2 \\times 2$ 张量空间中工作。\n- 每次更新后，通过 $C \\leftarrow \\frac{1}{2}(C + C^{\\top})$ 对数值计算的张量进行对称化，以减轻由浮点运算引起的非对称性。\n- $\\sin(\\cdot)$ 内部的角度以弧度为单位。\n\n测试套件：\n对以下四个参数集运行验证和收敛性评估。在每种情况下，$N$ 是与 $T/\\Delta t$ 最接近的整数，模拟时间为 $N \\Delta t$。\n\n情况 A（理想情况）：\n- $Wi = 1.0$, $\\Delta t = 0.01$, $T = 1.0$, $s_0 = 0.5$, $\\epsilon = 0.5$, $\\omega = 2.0$, $\\phi_0 = 0.314159$, $\\psi_0 = 0.271828$, $C(0) = I$。\n\n情况 B（大时间步长，强拉伸，可能导致显式格式违规）：\n- $Wi = 2.0$, $\\Delta t = 0.2$, $T = 2.0$, $s_0 = 0.5$, $\\epsilon = 2.0$, $\\omega = 8.0$, $\\phi_0 = 0.123456$, $\\psi_0 = 0.654321$, $C(0) = I$。\n\n情况 C（高 Weissenberg 数，中等步长）：\n- $Wi = 10.0$, $\\Delta t = 0.05$, $T = 1.5$, $s_0 = 0.0$, $\\epsilon = 1.5$, $\\omega = 5.0$, $\\phi_0 = 0.435$, $\\psi_0 = 0.781$, $C(0) = I$。\n\n情况 D（近奇异初始条件）：\n- $Wi = 1.0$, $\\Delta t = 0.1$, $T = 1.0$, $s_0 = -0.3$, $\\epsilon = 1.0$, $\\omega = 3.0$, $\\phi_0 = 0.9$, $\\psi_0 = 0.4$, $C(0) = \\mathrm{diag}(10^{-8}, 1.0)$。\n\n要求输出：\n对于每种情况，计算并返回：\n- 一个布尔值，表示显式格式在整个模拟过程中是否保持了严格正定性（没有特征值违反对容差的情况）。\n- 一个布尔值，表示算子分裂格式在整个模拟过程中是否保持了严格正定性。\n- 一个浮点数，等于算子分裂格式的弗罗贝尼乌斯范数 $\\| \\widetilde{C}^{\\Delta t}(T) - \\widetilde{C}^{\\Delta t/2}(T) \\|_F$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来（例如 $[result1,result2,\\dots]$），按情况逐一排序如下：\n$$\n[\\text{A}_{\\mathrm{explicit}}, \\text{A}_{\\mathrm{split}}, \\text{A}_{\\mathrm{conv}}, \\text{B}_{\\mathrm{explicit}}, \\text{B}_{\\mathrm{split}}, \\text{B}_{\\mathrm{conv}}, \\text{C}_{\\mathrm{explicit}}, \\text{C}_{\\mathrm{split}}, \\text{C}_{\\mathrm{conv}}, \\text{D}_{\\mathrm{explicit}}, \\text{D}_{\\mathrm{split}}, \\text{D}_{\\mathrm{conv}}].\n$$\n所有布尔值条目均为关键字 True 或 False，所有浮点数均为无量纲单位。",
            "solution": "该问题要求实现并验证用于稀聚合物溶液中 $2 \\times 2$ 对称正定 (SPD) 构象张量 $C(t)$ 时间演化的数值格式。其控制动力学由 Oldroyd-B 模型在空间均匀、随时间变化的速度梯度 $G(t)$ 下描述。核心任务是比较一个朴素显式格式和一个保正定性算子分裂格式，并评估后者的收敛性。\n\n首先，构象张量 $C(t)$ 演化的物理模型由以下常微分方程给出：\n$$\n\\frac{dC}{dt} = G(t)C(t) + C(t)G(t)^{\\top} - \\frac{1}{Wi}(C(t) - I)\n$$\n其中 $Wi$ 是 Weissenberg 数，$I$ 是单位张量，$G(t)$ 是速度梯度。如果 $C(0)$ 是对称正定，那么张量 $C(t)$ 必须在所有时间 $t \\geq 0$ 内保持对称正定。使用标准的数值积分器来维持这一物理约束是具有挑战性的。\n\n在离散时间步 $t_k = k \\Delta t$ 处，速度梯度被规定为一种随机驱动的旋转和拉伸流：\n$$\nG_k = \\begin{pmatrix} 0  \\gamma_k \\\\ -\\gamma_k  s_k \\end{pmatrix}\n$$\n分量 $\\gamma_k$ 和 $s_k$ 使用确定性混沌来模拟湍流涨落。\n$$\n\\gamma_k = \\omega \\sin(2\\pi \\phi_k), \\quad s_k = s_0 + \\epsilon \\sin(2\\pi \\psi_k)\n$$\n序列 $(\\phi_k)$ 和 $(\\psi_k)$ 来自逻辑斯蒂映射 $x_{k+1} = r x_k (1 - x_k)$，其中 $r=4$。对于种子 $\\phi_0, \\psi_0 \\in (0,1)$，该映射会生成位于区间 $(0,1)$ 内的混沌序列。这为系统提供了一个非平凡的、波动的驱动力。为此，设计了一个辅助函数来生成给定步数的这些序列。\n\n实现并比较了两种数值格式。\n\n1.  **朴素显式格式 (前向欧拉法)**：\n    该格式使用一阶前向差分来离散化控制常微分方程：\n    $$\n    C_{k+1}^{\\mathrm{E}} = C_k^{\\mathrm{E}} + \\Delta t \\left( G_k C_k^{\\mathrm{E}} + C_k^{\\mathrm{E}} G_k^{\\top} - \\frac{1}{Wi}\\left( C_k^{\\mathrm{E}} - I \\right) \\right)\n    $$\n    此方法实现简单，但不能保证保持 $C$ 的对称正定性，尤其是在时间步长 $\\Delta t$ 较大或流场较强（$G_k$ 的范数较大）时。为验证其性能，我们在每一步计算所得张量 $C_{k+1}^{\\mathrm{E}}$ 的特征值。如果最小特征值 $\\lambda_{\\min}(C_{k+1}^{\\mathrm{E}})$ 低于一个小的正容差 $\\tau = 10^{-12}$（用以考虑浮点精度），则声明违反了正定性。若发生违规，表示正定性的布尔标志将设为 `False`。为使模拟能够继续，会应用一种修正性的裁剪程序：对张量进行对角化，将任何非正特征值替换为 $\\tau$，然后重构张量。这使得模拟可以完成，同时记录下该格式未能保持正定性。\n\n2.  **保正定性算子分裂格式**：\n    该格式基于将控制常微分方程分裂为两个子问题，每个子问题都可以精确求解并保持对称正定性。\n    (a) 松弛：$\\frac{dC}{dt} = - \\frac{1}{Wi}(C - I)$\n    (b) 形变：$\\frac{dC}{dt} = G(t)C(t) + C(t)G(t)^{\\top}$\n    在时间步长 $\\Delta t$ 上，(a) 的精确解是 $C(\\Delta t) = (1 - \\alpha)I + \\alpha C(0)$，其中 $\\alpha = \\exp(-\\Delta t/Wi)$。这是两个对称正定张量（$I$ 和 $C(0)$）的凸组合，因此也是对称正定的。\n    在 $\\Delta t$ 上（假设 $G$ 为常数 $G_k$），(b) 的精确解是 $C(\\Delta t) = M_k C(0) M_k^{\\top}$，其中 $M_k = \\exp\\left(G_k \\Delta t\\right)$ 是矩阵指数。这种通过可逆矩阵 $M_k$ 的合同变换保持了对称正定性。\n    \n    分裂格式组合了这些精确解：\n    $$\n    \\widetilde{C}_{k+1} = M_k \\left( (1 - \\alpha) I + \\alpha \\widetilde{C}_k \\right) M_k^{\\top}\n    $$\n    这对应于一阶 Lie-Trotter 分裂（先松弛后形变）。根据构造，该格式在数学上保证了如果 $\\widetilde{C}_k$ 是对称正定的，那么 $\\widetilde{C}_{k+1}$ 也将是对称正定的。实现中使用 `scipy.linalg.expm` 来计算矩阵指数。与显式格式一样，每一步都监测最小特征值以数值验证此属性。\n\n对于两种格式，一个关键的实现细节是强制对称性。在每个更新步骤之后，通过操作 $C \\leftarrow \\frac{1}{2}(C + C^{\\top})$ 对张量 $C$ 进行对称化，以减轻可能破坏对称性的数值浮点误差的累积。\n\n**收敛性评估**：\n评估算子分裂格式的时间收敛性。这是一个一阶格式，因此误差应与 $\\Delta t$ 成正比。为验证这一点，对于每个测试用例，我们运行两次模拟直到一个“目标”时间 $T$。\n-   一次粗糙模拟，时间步长为 $\\Delta t_1 = \\Delta t$，共 $N_1 = \\text{round}(T/\\Delta t)$ 步，得到最终张量 $\\widetilde{C}^{\\Delta t}(T_{eff})$。\n-   一次精细模拟，时间步长为 $\\Delta t_2 = \\Delta t_1/2$，共 $N_2 = 2 N_1$ 步，得到 $\\widetilde{C}^{\\Delta t/2}(T_{eff})$。\n两次模拟都运行了相同的总有效时长 $T_{eff} = N_1 \\Delta t_1$。最终张量之间的差异使用弗罗贝尼乌斯范数量化：\n$$\n\\text{误差} = \\| \\widetilde{C}^{\\Delta t}(T_{eff}) - \\widetilde{C}^{\\Delta t/2}(T_{eff}) \\|_F\n$$\n对每个参数案例计算此误差度量。\n\n总体算法的结构是遍历四个测试用例。对于每个用例，它运行显式模拟、粗糙分裂模拟和精细分裂模拟。然后收集三个要求的输出：显式格式的正定性保持布尔值、分裂格式的正定性保持布尔值，以及用于收敛性评估的弗罗贝尼乌斯范数。这些结果被汇总到一个列表中以供最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Main function to run the verification and convergence assessment for all test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: Happy path\n        {'name': 'A', 'Wi': 1.0, 'dt': 0.01, 'T': 1.0, 's0': 0.5, 'eps': 0.5, 'omega': 2.0, \n         'phi0': 0.314159, 'psi0': 0.271828, 'C0': np.identity(2)},\n        # Case B: Large time step, strong stretching\n        {'name': 'B', 'Wi': 2.0, 'dt': 0.2, 'T': 2.0, 's0': 0.5, 'eps': 2.0, 'omega': 8.0, \n         'phi0': 0.123456, 'psi0': 0.654321, 'C0': np.identity(2)},\n        # Case C: High Weissenberg number\n        {'name': 'C', 'Wi': 10.0, 'dt': 0.05, 'T': 1.5, 's0': 0.0, 'eps': 1.5, 'omega': 5.0, \n         'phi0': 0.435, 'psi0': 0.781, 'C0': np.identity(2)},\n        # Case D: Near-singular initial condition\n        {'name': 'D', 'Wi': 1.0, 'dt': 0.1, 'T': 1.0, 's0': -0.3, 'eps': 1.0, 'omega': 3.0, \n         'phi0': 0.9, 'psi0': 0.4, 'C0': np.diag([1e-8, 1.0])}\n    ]\n\n    results = []\n    for case in test_cases:\n        case_results = run_case(case)\n        results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef logistic_map_sequence(seed, num_steps):\n    \"\"\"Generates a sequence of values from the logistic map x_k+1 = 4*x_k*(1-x_k).\"\"\"\n    seq = np.zeros(num_steps)\n    x = seed\n    for i in range(num_steps):\n        seq[i] = x\n        x = 4.0 * x * (1.0 - x)\n    return seq\n\ndef run_case(params):\n    \"\"\"\n    Runs both schemes for a given parameter set and computes the required outputs.\n    \"\"\"\n    Wi, dt, T = params['Wi'], params['dt'], params['T']\n    s0, eps, omega = params['s0'], params['eps'], params['omega']\n    phi0, psi0, C0 = params['phi0'], params['psi0'], params['C0']\n    \n    n_steps = int(round(T / dt))\n    tau = 1e-12\n    I = np.identity(2)\n\n    # Run Explicit Scheme\n    explicit_positivity_maintained = run_explicit_scheme(n_steps, dt, Wi, s0, eps, omega, phi0, psi0, C0, I, tau)\n    \n    # Run Operator-Splitting Scheme for positivity check and convergence\n    C_coarse, split_positivity_maintained = run_split_scheme(n_steps, dt, Wi, s0, eps, omega, phi0, psi0, C0, I, tau)\n    \n    n_steps_fine = 2 * n_steps\n    dt_fine = dt / 2.0\n    C_fine, _ = run_split_scheme(n_steps_fine, dt_fine, Wi, s0, eps, omega, phi0, psi0, C0, I, tau)\n    \n    # Convergence Assessment\n    conv_norm = np.linalg.norm(C_coarse - C_fine, 'fro')\n\n    return explicit_positivity_maintained, split_positivity_maintained, conv_norm\n\ndef run_explicit_scheme(n_steps, dt, Wi, s0, eps, omega, phi0, psi0, C0, I, tau):\n    \"\"\"Simulates the conformation tensor evolution using the explicit Euler scheme.\"\"\"\n    C = np.copy(C0)\n    positivity_maintained = True\n    \n    phi_seq = logistic_map_sequence(phi0, n_steps)\n    psi_seq = logistic_map_sequence(psi0, n_steps)\n\n    for k in range(n_steps):\n        gamma_k = omega * np.sin(2 * np.pi * phi_seq[k])\n        s_k = s0 + eps * np.sin(2 * np.pi * psi_seq[k])\n        Gk = np.array([[0.0, gamma_k], [-gamma_k, s_k]])\n        \n        dCdt = Gk @ C + C @ Gk.T - (1.0 / Wi) * (C - I)\n        C += dt * dCdt\n        \n        C = 0.5 * (C + C.T)  # Symmetrize\n        \n        evals, evecs = np.linalg.eigh(C)\n        if np.min(evals) = tau:\n            positivity_maintained = False\n            # Apply eigenvalue clipping for continuation\n            evals[evals = tau] = tau\n            C = evecs @ np.diag(evals) @ evecs.T\n            C = 0.5 * (C + C.T) # Re-symmetrize after reconstruction\n\n    return positivity_maintained\n\ndef run_split_scheme(n_steps, dt, Wi, s0, eps, omega, phi0, psi0, C0, I, tau):\n    \"\"\"Simulates the conformation tensor evolution using the operator-splitting scheme.\"\"\"\n    C = np.copy(C0)\n    positivity_maintained = True\n    \n    phi_seq = logistic_map_sequence(phi0, n_steps)\n    psi_seq = logistic_map_sequence(psi0, n_steps)\n    \n    alpha = np.exp(-dt / Wi)\n\n    for k in range(n_steps):\n        gamma_k = omega * np.sin(2 * np.pi * phi_seq[k])\n        s_k = s0 + eps * np.sin(2 * np.pi * psi_seq[k])\n        Gk = np.array([[0.0, gamma_k], [-gamma_k, s_k]])\n        \n        # Relaxation step\n        C_relaxed = (1.0 - alpha) * I + alpha * C\n        \n        # Deformation step\n        Mk = expm(Gk * dt)\n        C = Mk @ C_relaxed @ Mk.T\n        \n        C = 0.5 * (C + C.T)  # Symmetrize\n        \n        evals = np.linalg.eigh(C)[0]\n        if np.min(evals) = tau:\n            positivity_maintained = False\n            # No clipping required, just record the violation\n            \n    return C, positivity_maintained\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "弹性湍流的特征是混沌的流体运动和极端的聚合物伸长。为了定量地理解这一现象，我们需要能够衡量混沌程度并将其与聚合物行为联系起来的诊断工具。本练习引入有限时间李雅普诺夫指数（FTLE）作为拉格朗日混沌的有力度量，您将从合成的轨迹数据中计算 FTLE 的分布。随后，您将利用这些信息预测聚合物的伸长统计数据，从而在流动的混沌性质与聚合物的微观响应之间建立直接联系，这是弹性湍流研究的核心主题。",
            "id": "4085018",
            "problem": "考虑一个平滑的、二维的、随时间变化的线性流，作为拉格朗日示踪剂尺度上弹性湍流的合成模型。一对位置分别为 $\\mathbf{x}(t)$ 和 $\\mathbf{x}(t) + \\delta \\mathbf{x}(t)$ 的邻近拉格朗日示踪剂在速度梯度张量 $\\mathbf{A}(t)$ 的作用下演化，其演化遵循线性化分离动力学 $\\mathrm{d}\\delta \\mathbf{x}/\\mathrm{d}t = \\mathbf{A}(t)\\,\\delta \\mathbf{x}$。在长度为 $T$ 的时间窗内的有限时间李雅普诺夫指数 (FTLE) 从第一性原理定义为\n$$\n\\Lambda_T \\equiv \\frac{1}{T}\\,\\ln\\left(\\frac{\\|\\delta \\mathbf{x}(T)\\|}{\\|\\delta \\mathbf{x}(0)\\|}\\right),\n$$\n它量化了分离增长的平均指数速率。\n\n对于一个弛豫时间为 $\\tau$ 的胡克哑铃聚合物模型，在平滑流中，若不存在热噪声和有限可延展性，其端到端向量 $\\mathbf{R}(t)$ 满足线性方程 $\\mathrm{d}\\mathbf{R}/\\mathrm{d}t = \\nabla \\mathbf{u}(\\mathbf{x}(t),t)\\,\\mathbf{R} - \\mathbf{R}/\\tau$，其中 $\\nabla \\mathbf{u}$ 是沿示踪剂路径计算的速度梯度。在强混合流中，聚合物的取向倾向于与拉伸最强的方向对齐，聚合物伸展幅度近似满足\n$$\n\\|\\mathbf{R}(T)\\| \\approx \\|\\mathbf{R}(0)\\|\\,\\exp\\!\\left(\\int_0^T \\sigma_{\\max}(t)\\,\\mathrm{d}t - \\frac{T}{\\tau}\\right),\n$$\n其中 $\\sigma_{\\max}(t)$ 是聚合物感受到的最大瞬时拉伸率，对于无穷小分离，它与 $\\|\\delta \\mathbf{x}(t)\\|$ 的瞬时增长率一致。因此，使用有限时间李雅普诺夫指数的定义，沿一条轨迹在长度为 $T$ 的时间窗内的聚合物伸展因子近似为\n$$\n\\frac{\\|\\mathbf{R}(T)\\|}{\\|\\mathbf{R}(0)\\|} \\approx \\exp\\!\\left[\\left(\\Lambda_T - \\frac{1}{\\tau}\\right) T\\right].\n$$\n在本问题中，您将从一个在给定的时变线性流中的拉格朗日示踪剂对系综中计算 $\\Lambda_T$ 的分布，然后通过上述关系将该分布与聚合物伸展的统计数据联系起来。\n\n流模型。对于每个索引为 $k \\in \\{0,1,\\dots,K-1\\}$（其中 $K=12$）的示踪剂对，定义一个随时间变化的 $2\\times 2$ 速度梯度张量 $\\mathbf{A}_k(t)$ 为\n$$\n\\mathbf{A}_k(t) = \\mathbf{R}(\\theta_k(t))\\,\\begin{bmatrix} \\sigma_k(t)  0\\\\ 0  -\\sigma_k(t)\\end{bmatrix}\\,\\mathbf{R}(-\\theta_k(t)) + r_0\\,\\mathbf{J},\n$$\n其中 $\\mathbf{R}(\\theta) = \\begin{bmatrix} \\cos\\theta  -\\sin\\theta\\\\ \\sin\\theta  \\cos\\theta \\end{bmatrix}$ 是平面旋转矩阵，$\\mathbf{J}=\\begin{bmatrix} 0  -1 \\\\ 1  0 \\end{bmatrix}$，并且\n$$\n\\sigma_k(t) = s_{\\mathrm{mean}} + s_{\\mathrm{amp}}\\,\\sin(\\omega\\,t + \\phi_k), \\qquad \\theta_k(t) = \\theta_0 + \\eta\\,\\sin(\\omega_2\\,t + \\psi_k).\n$$\n使用固定参数 $s_{\\mathrm{mean}}=0.7\\,\\text{s}^{-1}$，$s_{\\mathrm{amp}}=0.3\\,\\text{s}^{-1}$，$\\omega=1.7\\,\\text{rad/s}$，$\\theta_0=0.25\\,\\text{rad}$，$\\eta=0.33\\,\\text{rad}$，$\\omega_2=2.3\\,\\text{rad/s}$，以及 $r_0=0.2\\,\\text{s}^{-1}$。角度单位为弧度，时间单位为秒，速率单位为 $\\text{s}^{-1}$。对于每个 $k$，将相位设置为 $\\phi_k = 0.3\\,k$ 和 $\\psi_k = 0.7\\,k$。\n\n轨迹系综。对于每个 $k$，定义基础初始位置 $\\mathbf{x}_k(0) = [\\cos(0.5\\,k),\\,\\sin(0.5\\,k)]^\\top$ 和初始分离向量 $\\delta \\mathbf{x}_k(0) = d_0\\,[\\cos \\alpha_k,\\, \\sin \\alpha_k]^\\top$，其中 $d_0=10^{-6}$ 且 $\\alpha_k = 0.2 + 0.4\\,k$。在相同的流 $\\mathbf{A}_k(t)$ 下，使用时间步长 $\\Delta t = 0.01\\,\\text{s}$ 和在时间 $t_n = n\\,\\Delta t$（其中 $n=0,1,\\dots, N-1$，$N = T/\\Delta t$）处的精确单步线性传播算子 $\\exp\\!\\left(\\mathbf{A}_k(t_n)\\,\\Delta t\\right)$，将每个基础示踪剂及其邻近伴随粒子演化 $T=10.0\\,\\text{s}$ 的时长。演化规则为 $\\mathbf{x}_{n+1} = \\exp\\!\\left(\\mathbf{A}_k(t_n)\\,\\Delta t\\right)\\,\\mathbf{x}_n$ 和 $\\delta \\mathbf{x}_{n+1} = \\exp\\!\\left(\\mathbf{A}_k(t_n)\\,\\Delta t\\right)\\,\\delta \\mathbf{x}_n$。\n\n诊断量。对于每对示踪剂 $k$，计算有限时间李雅普诺夫指数\n$$\n\\Lambda_T^{(k)} = \\frac{1}{T}\\,\\ln\\left(\\frac{\\|\\delta \\mathbf{x}_k(T)\\|}{\\|\\delta \\mathbf{x}_k(0)\\|}\\right).\n$$\n对于弛豫时间为 $\\tau$ 的胡克哑铃聚合物，忽略热噪声和有限可延展性，沿每条路径对应的聚合物伸展因子近似为 $\\exp\\!\\left[\\left(\\Lambda_T^{(k)} - \\tau^{-1}\\right) T\\right]$。\n\n任务。您的程序必须：\n- 按规定生成包含 $K=12$ 对示踪剂的系综。\n- 计算集合 $\\{\\Lambda_T^{(k)}\\}_{k=0}^{K-1}$。\n- 对于下面列出的每个测试用例（测试套件），计算：\n  1. 样本均值 $\\overline{\\Lambda}_T = \\frac{1}{K}\\sum_{k=0}^{K-1} \\Lambda_T^{(k)}$，单位为 $\\text{s}^{-1}$。\n  2. 满足 $\\Lambda_T^{(k)}  1/\\tau$ 的示踪剂对所占的比例 $f$（以小数表示）。\n  3. 样本均值聚合物伸展因子 $\\overline{E} = \\frac{1}{K}\\sum_{k=0}^{K-1} \\exp\\!\\left[\\left(\\Lambda_T^{(k)} - \\tau^{-1}\\right) T\\right]$（无量纲）。\n\n所有三角函数均使用弧度作为角度单位。所有与时间相关的速率均以 $\\text{s}^{-1}$ 表示，伸展因子以无量纲浮点数报告。\n\n测试套件。使用以下弛豫时间：\n- 案例 A（正常路径，高于阈值）：$\\tau = 2.0\\,\\text{s}$。\n- 案例 B（接近阈值）：$\\tau = 1.5\\,\\text{s}$。\n- 案例 C（低于阈值）：$\\tau = 0.8\\,\\text{s}$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个子列表，顺序为 [案例 A, 案例 B, 案例 C]。每个子列表必须包含三个浮点数，顺序为 $[\\overline{\\Lambda}_T, f, \\overline{E}]$，每个值四舍五入到小数点后六位。例如：\"[[0.123456,0.500000,1.234568],[...],[...]]\"。",
            "solution": "该问题是有效的。这是一个在计算复杂流体领域内适定的计算问题，其基础是拉格朗日动力学和聚合物物理学的既定原理。所有参数、方程和初始条件都已明确指定，从而可以得到唯一且可验证的解。\n\n主要目标是计算指定时变线性流中轨迹系综的有限时间李雅普诺夫指数 (FTLE)，然后利用这些统计数据分析胡克哑铃的拉伸情况。\n\n求解过程分为几个步骤：\n1.  为 $K=12$ 条轨迹中的每一条定义随时间变化的速度梯度张量 $\\mathbf{A}_k(t)$。\n2.  对于每条轨迹 $k$，在 $T=10.0\\,\\text{s}$ 的时间间隔内数值积分无穷小分离向量 $\\delta \\mathbf{x}_k(t)$ 的演化。\n3.  根据分离向量的增长计算每条轨迹的 FTLE $\\Lambda_T^{(k)}$。\n4.  使用计算出的 FTLE 集合 $\\{\\Lambda_T^{(k)}\\}_{k=0}^{K-1}$，为三种不同的聚合物弛豫时间 $\\tau$ 计算所需的统计诊断量。\n\n**1. 速度梯度张量**\n\n对于每个轨迹索引 $k \\in \\{0, 1, \\dots, 11\\}$，该 $2 \\times 2$ 速度梯度张量 $\\mathbf{A}_k(t)$ 由下式给出：\n$$\n\\mathbf{A}_k(t) = \\mathbf{R}\\!\\left(\\theta_k(t)\\right)\\,\\begin{bmatrix} \\sigma_k(t)  0\\\\ 0  -\\sigma_k(t)\\end{bmatrix}\\,\\mathbf{R}\\!\\left(-\\theta_k(t)\\right) + r_0\\,\\mathbf{J}\n$$\n其中 $\\mathbf{R}(\\theta) = \\begin{bmatrix} \\cos\\theta  -\\sin\\theta\\\\ \\sin\\theta  \\cos\\theta \\end{bmatrix}$ 是旋转矩阵，$\\mathbf{J}=\\begin{bmatrix} 0  -1 \\\\ 1  0 \\end{bmatrix}$ 是旋转的生成元。随时间变化的应变率 $\\sigma_k(t)$ 和应变方向 $\\theta_k(t)$ 为：\n$$\n\\sigma_k(t) = s_{\\mathrm{mean}} + s_{\\mathrm{amp}}\\,\\sin(\\omega\\,t + \\phi_k)\n$$\n$$\n\\theta_k(t) = \\theta_0 + \\eta\\,\\sin(\\omega_2\\,t + \\psi_k)\n$$\n参数是固定的：$s_{\\mathrm{mean}}=0.7\\,\\text{s}^{-1}$，$s_{\\mathrm{amp}}=0.3\\,\\text{s}^{-1}$，$\\omega=1.7\\,\\text{rad/s}$，$\\theta_0=0.25\\,\\text{rad}$，$\\eta=0.33\\,\\text{rad}$，$\\omega_2=2.3\\,\\text{rad/s}$，以及 $r_0=0.2\\,\\text{s}^{-1}$。相位与轨迹有关：$\\phi_k = 0.3\\,k$ 和 $\\psi_k = 0.7\\,k$。\n\n对第一项进行矩阵乘法，得到 $\\mathbf{A}_k(t)$ 的显式形式：\n$$\n\\mathbf{A}_k(t) = \\begin{bmatrix} \\sigma_k(t) \\cos(2\\theta_k(t))  \\sigma_k(t) \\sin(2\\theta_k(t)) - r_0 \\\\ \\sigma_k(t) \\sin(2\\theta_k(t)) + r_0  -\\sigma_k(t) \\cos(2\\theta_k(t)) \\end{bmatrix}\n$$\n这种形式在计算上是高效的。\n\n**2. 分离向量的数值积分**\n\n分离向量的演化由线性常微分方程 $\\mathrm{d}\\delta \\mathbf{x}/\\mathrm{d}t = \\mathbf{A}_k(t)\\,\\delta \\mathbf{x}$ 控制。我们使用时间步长 $\\Delta t = 0.01\\,\\text{s}$ 从 $t=0$ 到 $T=10.0\\,\\text{s}$ 对其进行数值求解。总步数为 $N = T/\\Delta t = 1000$。\n\n问题指定了从时间 $t_n=n\\Delta t$ 到 $t_{n+1}$ 的每一步的更新规则：\n$$\n\\delta \\mathbf{x}_{n+1} = \\exp\\!\\left(\\mathbf{A}_k(t_n)\\,\\Delta t\\right)\\,\\delta \\mathbf{x}_n\n$$\n这对应于一阶数值格式，其中假定 $\\mathbf{A}_k(t)$ 在每个小区间 $[t_n, t_{n+1}]$ 上是恒定的。矩阵指数 $\\exp(\\mathbf{M})$ 是一个标准的矩阵函数。\n\n对于每条轨迹 $k$，初始分离向量为 $\\delta \\mathbf{x}_k(0) = d_0\\,[\\cos \\alpha_k,\\, \\sin \\alpha_k]^\\top$，其初始大小为 $d_0=10^{-6}$，方向角为 $\\alpha_k = 0.2 + 0.4\\,k$。我们在 $t=0$ 时初始化 $\\delta \\mathbf{x}_k$，并为 $n=0, 1, \\dots, N-1$ 迭代应用更新规则，以找到最终的分离向量 $\\delta \\mathbf{x}_k(T)$。\n\n**3. FTLE 计算**\n\n每条轨迹的 FTLE 定义为：\n$$\n\\Lambda_T^{(k)} = \\frac{1}{T}\\,\\ln\\left(\\frac{\\|\\delta \\mathbf{x}_k(T)\\|}{\\|\\delta \\mathbf{x}_k(0)\\|}\\right)\n$$\n数值积分后，我们计算最终分离向量的欧几里得范数 $\\|\\delta \\mathbf{x}_k(T)\\|$。由于 $\\|\\delta \\mathbf{x}_k(0)\\| = d_0$，我们计算每个 $k$ 的 $\\Lambda_T^{(k)}$ 并存储结果。\n\n**4. 统计分析**\n\n利用 FTLE 的系综 $\\{\\Lambda_T^{(k)}\\}_{k=0}^{11}$，我们继续为三种测试用例计算诊断量，这些测试用例由不同的聚合物弛豫时间定义：案例 A ($\\tau = 2.0\\,\\text{s}$)、案例 B ($\\tau = 1.5\\,\\text{s}$) 和案例 C ($\\tau = 0.8\\,\\text{s}$)。\n\n对于每个测试用例，我们计算：\n\na. 样本均值 FTLE, $\\overline{\\Lambda}_T$：\n$$\n\\overline{\\Lambda}_T = \\frac{1}{K}\\sum_{k=0}^{K-1} \\Lambda_T^{(k)}\n$$\n请注意，此量与 $\\tau$ 无关，因此对于所有三种情况都相同。\n\nb. 表现出聚合物拉伸的轨迹所占的比例 $f$。当拉伸速率超过弛豫速率时，即 $\\Lambda_T^{(k)} > 1/\\tau$，就会发生这种情况。我们计算满足此条件的轨迹数量，然后除以总轨迹数 $K$。\n\nc. 样本均值聚合物伸展因子 $\\overline{E}$。单条轨迹的伸展因子近似为 $E_k = \\exp\\!\\left[\\left(\\Lambda_T^{(k)} - \\tau^{-1}\\right) T\\right]$。均值为：\n$$\n\\overline{E} = \\frac{1}{K}\\sum_{k=0}^{K-1} E_k = \\frac{1}{K}\\sum_{k=0}^{K-1} \\exp\\!\\left[\\left(\\Lambda_T^{(k)} - \\frac{1}{\\tau}\\right) T\\right]\n$$\n\n最终结果被编译成一个列表的列表，每个子列表包含相应测试用例的三元组 $[\\overline{\\Lambda}_T, f, \\overline{E}]$，每个值四舍五入到小数点后六位。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Computes FTLE statistics for a synthetic flow model and relates them to polymer extension.\n    \"\"\"\n    # Fixed parameters from the problem statement\n    K = 12\n    s_mean = 0.7\n    s_amp = 0.3\n    omega = 1.7\n    theta_0 = 0.25\n    eta = 0.33\n    omega_2 = 2.3\n    r_0 = 0.2\n    d_0 = 1e-6\n    T = 10.0\n    dt = 0.01\n    N = int(T / dt)\n\n    # Test cases for polymer relaxation time tau\n    test_taus = [2.0, 1.5, 0.8]\n\n    # Trajectory-specific phase and angle parameters\n    ks = np.arange(K)\n    phis = 0.3 * ks\n    psis = 0.7 * ks\n    alphas = 0.2 + 0.4 * ks\n\n    ftle_values = []\n\n    # Iterate over the ensemble of K trajectories\n    for k in range(K):\n        # Set the initial separation vector for trajectory k\n        delta_x = d_0 * np.array([np.cos(alphas[k]), np.sin(alphas[k])])\n\n        # Perform time-stepping integration\n        for n in range(N):\n            t_n = n * dt\n            \n            # Calculate time-dependent components sigma(t) and theta(t)\n            sigma_t = s_mean + s_amp * np.sin(omega * t_n + phis[k])\n            theta_t = theta_0 + eta * np.sin(omega_2 * t_n + psis[k])\n            \n            # Construct the velocity-gradient tensor A_k(t)\n            cos_2theta = np.cos(2 * theta_t)\n            sin_2theta = np.sin(2 * theta_t)\n            \n            A_matrix = np.array([\n                [sigma_t * cos_2theta,        sigma_t * sin_2theta - r_0],\n                [sigma_t * sin_2theta + r_0, -sigma_t * cos_2theta]\n            ])\n            \n            # Compute the one-step propagator and update the separation vector\n            propagator = expm(A_matrix * dt)\n            delta_x = propagator @ delta_x\n            \n        # Compute the FTLE for trajectory k\n        final_norm = np.linalg.norm(delta_x)\n        ftle_k = (1.0 / T) * np.log(final_norm / d_0)\n        ftle_values.append(ftle_k)\n\n    ftle_values = np.array(ftle_values)\n    \n    # Calculate the sample mean FTLE (constant across all test cases)\n    mean_ftle = np.mean(ftle_values)\n\n    all_case_results = []\n\n    # Process each test case\n    for tau in test_taus:\n        # Define the coil-stretch transition threshold\n        threshold = 1.0 / tau\n        \n        # 1. Fraction f of pairs where FTLE > 1/tau\n        count_above_threshold = np.sum(ftle_values > threshold)\n        fraction_f = count_above_threshold / K\n        \n        # 2. Mean polymer extension factor E\n        extension_factors = np.exp((ftle_values - threshold) * T)\n        mean_extension_E = np.mean(extension_factors)\n        \n        # Store the triplet of results for this case\n        case_results = [mean_ftle, fraction_f, mean_extension_E]\n        all_case_results.append(case_results)\n\n    # Format the final output string as specified\n    outer_list_str = []\n    for res_list in all_case_results:\n        # Format each number to 6 decimal places\n        inner_list_str = [f\"{x:.6f}\" for x in res_list]\n        outer_list_str.append(f\"[{','.join(inner_list_str)}]\")\n    \n    final_output_str = f\"[{','.join(outer_list_str)}]\"\n    \n    print(final_output_str)\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}