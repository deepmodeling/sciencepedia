{
    "hands_on_practices": [
        {
            "introduction": "K-BKZ 模型捕捉非线性流变行为的能力取决于其阻尼函数，而该函数通常是应变不变量的函数。第一个练习旨在提供基础训练，它将最基本的变形度量——主拉伸——与K-BKZ模型中常用的两个应变不变量联系起来。掌握这一推导对于理解该模型如何量化应变大小至关重要。",
            "id": "4090502",
            "problem": "在连续介质力学中，描述有限变形的两个关键张量是左柯西-格林（或芬格）张量 $\\boldsymbol{B}(t,t') = \\boldsymbol{F}(t,t')\\boldsymbol{F}(t,t')^{\\top}$ 和右柯西-格林张量 $\\boldsymbol{C}(t,t') = \\boldsymbol{F}(t,t')^{\\top}\\boldsymbol{F}(t,t')$，其中 $\\boldsymbol{F}(t,t')$ 是相对变形梯度。对于不可压缩材料，K-BKZ 模型中的阻尼函数通常是两个主不变量 $I_1 = \\mathrm{tr}(\\boldsymbol{B})$ 和 $I_2 = \\mathrm{tr}(\\boldsymbol{B}^{-1})$ 的函数。\n\n请严格从连续介质运动学和张量基本性质出发，运用谱理论方法将这两个不变量 $I_1$ 和 $I_2$ 用与 $t'$ 到 $t$ 之间的变形相关的主拉伸比 $\\lambda_{1}(t,t')$, $\\lambda_{2}(t,t')$, 和 $\\lambda_{3}(t,t')$ 来表示。仅假设变形具有实数极分解，且拉伸张量是可对角化的，其主拉伸为实正值。你的最终答案必须是给出这两个不变量作为 $\\lambda_{1}(t,t')$, $\\lambda_{2}(t,t')$ 和 $\\lambda_{3}(t,t')$ 函数的两个封闭形式符号表达式。\n\n无需进行数值计算。如果在推导中引入任何辅助量，应在最终表达式中将其消去，以使答案仅用 $\\lambda_{1}(t,t')$, $\\lambda_{2}(t,t')$ 和 $\\lambda_{3}(t,t')$ 表示。",
            "solution": "所述问题是有效的。这是一个在连续介质力学中适定的、有科学依据的问题，没有矛盾或含糊之处。它要求基于张量代数和运动学的基本原理进行严格推导。\n\n为使推导过程中的符号简洁，我们将与变形相关的量 $\\boldsymbol{F}(t,t')$, $\\boldsymbol{B}(t,t')$, $\\boldsymbol{C}(t,t')$ 和 $\\lambda_{i}(t,t')$ 分别表示为 $\\boldsymbol{F}$, $\\boldsymbol{B}$, $\\boldsymbol{C}$ 和 $\\lambda_{i}$。\n\n根据主文本和问题陈述中的定义，左柯西-格林（或芬格）张量为 $\\boldsymbol{B} = \\boldsymbol{F}\\boldsymbol{F}^{\\top}$，右柯西-格林张量为 $\\boldsymbol{C} = \\boldsymbol{F}^{\\top}\\boldsymbol{F}$。\n\n根据极分解定理，变形梯度 $\\boldsymbol{F}$ 可以分解为 $\\boldsymbol{F} = \\boldsymbol{R}\\boldsymbol{U}$，其中 $\\boldsymbol{R}$ 是一个正常正交的旋转张量（$\\boldsymbol{R}^{\\top}\\boldsymbol{R} = \\boldsymbol{I}$），$\\boldsymbol{U}$ 是对称正定的右拉伸张量。\n\n将此分解代入 $\\boldsymbol{C}$ 的定义：\n$$\n\\boldsymbol{C} = (\\boldsymbol{R}\\boldsymbol{U})^{\\top}(\\boldsymbol{R}\\boldsymbol{U}) = \\boldsymbol{U}^{\\top}\\boldsymbol{R}^{\\top}\\boldsymbol{R}\\boldsymbol{U} = \\boldsymbol{U}^{\\top}\\boldsymbol{I}\\boldsymbol{U} = \\boldsymbol{U}^2\n$$\n右拉伸张量 $\\boldsymbol{U}$ 的谱分解为 $\\boldsymbol{U} = \\sum_{i=1}^{3} \\lambda_{i} (\\boldsymbol{n}_{i} \\otimes \\boldsymbol{n}_{i})$，其中 $\\lambda_{i}$ 是主拉伸比，$\\boldsymbol{n}_{i}$ 是对应的特征向量（主方向）。因此，$\\boldsymbol{C} = \\boldsymbol{U}^2$ 的特征值是 $\\lambda_{i}^2$。\n\n现在考虑芬格张量 $\\boldsymbol{B} = \\boldsymbol{F}\\boldsymbol{F}^{\\top}$。我们可以证明 $\\boldsymbol{B}$ 与 $\\boldsymbol{C}$ 是相似的：\n$$\n\\boldsymbol{B} = \\boldsymbol{F}\\boldsymbol{F}^{\\top} = (\\boldsymbol{R}\\boldsymbol{U})(\\boldsymbol{R}\\boldsymbol{U})^{\\top} = \\boldsymbol{R}\\boldsymbol{U} \\boldsymbol{U}^{\\top} \\boldsymbol{R}^{\\top} = \\boldsymbol{R} \\boldsymbol{U}^2 \\boldsymbol{R}^{\\top} = \\boldsymbol{R} \\boldsymbol{C} \\boldsymbol{R}^{\\top}\n$$\n由于 $\\boldsymbol{B}$ 和 $\\boldsymbol{C}$ 是相似的（通过旋转张量 $\\boldsymbol{R}$ 相关联），它们具有相同的特征值。因此，$\\boldsymbol{B}$ 的特征值也是 $\\lambda_{i}^2$。\n\n第一个不变量 $I_{1}$ 定义为 $\\boldsymbol{B}$ 的迹，即其特征值之和：\n$$\nI_{1} = \\mathrm{tr}(\\boldsymbol{B}) = \\sum_{i=1}^{3} \\lambda_{i}^2 = \\lambda_{1}^2 + \\lambda_{2}^2 + \\lambda_{3}^2\n$$\n第二个不变量 $I_{2}$ 定义为 $\\boldsymbol{B}$ 的逆的迹：$I_{2} = \\mathrm{tr}(\\boldsymbol{B}^{-1})$。\n$\\boldsymbol{B}^{-1}$ 的特征值是 $\\boldsymbol{B}$ 的特征值的倒数，即 $\\lambda_{i}^{-2}$。\n因此，第二个不变量 $I_{2}$ 是：\n$$\nI_{2} = \\mathrm{tr}(\\boldsymbol{B}^{-1}) = \\sum_{i=1}^{3} \\lambda_{i}^{-2} = \\lambda_{1}^{-2} + \\lambda_{2}^{-2} + \\lambda_{3}^{-2}\n$$\n恢复主拉伸比的完整符号表示（其依赖于时间区间 $(t', t)$），我们得到最终表达式。\n\n第一不变量是：\n$$\nI_1 = \\lambda_{1}(t,t')^2 + \\lambda_{2}(t,t')^2 + \\lambda_{3}(t,t')^2\n$$\n第二不变量是：\n$$\nI_2 = \\lambda_{1}(t,t')^{-2} + \\lambda_{2}(t,t')^{-2} + \\lambda_{3}(t,t')^{-2}\n$$\n这些表达式提供了K-BKZ模型中使用的两个关键不变量与主拉伸比之间的所需关系。",
            "answer": "$$\\boxed{I_1 = \\lambda_{1}(t,t')^2 + \\lambda_{2}(t,t')^2 + \\lambda_{3}(t,t')^2, \\quad I_2 = \\lambda_{1}(t,t')^{-2} + \\lambda_{2}(t,t')^{-2} + \\lambda_{3}(t,t')^{-2}}$$"
        },
        {
            "introduction": "检验粘弹性本构模型的关键在于其预测剪切流中法向应力差的能力。本练习将引导您探索 K-BKZ 框架内应变张量的不同选择——具体为 Finger 张量 $\\boldsymbol{B}$ 与其逆张量 $\\boldsymbol{B}^{-1}$——如何导致对第二法向应力差 $N_2$ 的预测产生截然不同的结果。通过这个计算，您将深刻体会到模型构建中看似微小的调整对物理预测的巨大影响。",
            "id": "4090528",
            "problem": "考虑一个由单模态Kaye–Bernstein–Kearsley–Zapas (K-BKZ) 积分本构方程建模的均匀、不可压缩、等温的粘弹性流体。记忆函数为指数形式，$m(s) = (G/\\lambda)\\exp(-s/\\lambda)$，其中 $G$ 是模量，$\\lambda$ 是松弛时间。假设阻尼函数等于1，因此应力张量泛函仅取决于所选的应变度量。设流动为稳态简单剪切流，速度场为 $\\boldsymbol{v} = \\dot{\\gamma}\\, y\\, \\boldsymbol{e}_{x}$，其中 $\\dot{\\gamma}$ 是一个恒定的剪切速率。将时间延迟记为 $s = t - t'$，并使用标准的连续介质运动学来定义在区间 $[t',t]$ 上的变形梯度 $\\boldsymbol{F}(t,t')$、左柯西-格林（芬格）张量 $\\boldsymbol{B}(t,t') = \\boldsymbol{F}(t,t')\\,\\boldsymbol{F}(t,t')^{\\mathsf{T}}$ 及其逆 $\\boldsymbol{B}^{-1}(t,t')$。\n\n将第二法向应力差定义为 $N_{2} = \\sigma_{yy} - \\sigma_{zz}$，其中 $\\boldsymbol{\\sigma}$ 是柯西应力张量。从稳态简单剪切流中 $\\boldsymbol{F}$、$\\boldsymbol{B}$ 和 $\\boldsymbol{B}^{-1}$ 的基本定义出发，并利用 K-BKZ 积分应力结构以及通过线性张量泛函 $[\\cdot - \\boldsymbol{I}]$ 得到的两个候选应变度量 $\\boldsymbol{B}$ 和 $\\boldsymbol{B}^{-1}$，推导两种情况下 $N_{2}$ 的稳态预测值。然后，通过对时间积分的显式计算，确定当应力泛函使用逆芬格张量时 $N_{2}$ 的闭式解析表达式，即\n$$\n\\boldsymbol{\\sigma}(t) = \\int_{0}^{\\infty} m(s)\\,\\big(\\boldsymbol{B}^{-1}(s) - \\boldsymbol{I}\\big)\\,\\mathrm{d}s,\n$$\n在恒定剪切速率 $\\dot{\\gamma}$ 的稳态简单剪切流下。\n\n将 $N_{2}$ 的最终答案表示为包含 $G$、$\\lambda$ 和 $\\dot{\\gamma}$ 的单个解析表达式。不需要进行数值计算。如果引入任何角度，必须以弧度为单位；如果引入任何物理单位，请加以说明。",
            "solution": "该问题要求推导在稳态简单剪切流下，由单模态K-BKZ本构方程描述的粘弹性流体的第二法向应力差 $N_{2}$。我们必须首先分析应变度量基于芬格张量 $\\boldsymbol{B}$ 及其逆 $\\boldsymbol{B}^{-1}$ 的情况，然后为后一种情况提供一个闭式解。\n\n第一步是建立稳态简单剪切流的运动学。速度场由 $\\boldsymbol{v} = \\dot{\\gamma} y \\boldsymbol{e}_{x}$ 给出，其中 $\\dot{\\gamma}$ 是恒定的剪切速率。流体质点在过去时刻 $t'$ 的位置 $\\boldsymbol{x}' = (x', y', z')$ 与其在当前时刻 $t$ 的位置 $\\boldsymbol{x} = (x, y, z)$ 通过对速度场积分相关联。对于稳态流，该关系仅取决于时间延迟 $s = t - t'$。从当前构型到过去构型的映射为：\n$$\nx' = x - \\dot{\\gamma} y s, \\quad y' = y, \\quad z' = z\n$$\n变形梯度张量 $\\boldsymbol{F}(s) \\equiv \\boldsymbol{F}(t, t')$ 由其分量 $F_{ij} = \\frac{\\partial x_i(t)}{\\partial x'_j(t')}$ 定义。为了计算它，我们使用逆映射，它描述了当前位置作为过去位置的函数：\n$$\nx(t) = x' + \\dot{\\gamma} y' s, \\quad y(t) = y', \\quad z(t) = z'\n$$\n变形梯度张量的分量则为：\n$$\n\\boldsymbol{F}(s) = \\begin{pmatrix} \\frac{\\partial x}{\\partial x'}  \\frac{\\partial x}{\\partial y'}  \\frac{\\partial x}{\\partial z'} \\\\ \\frac{\\partial y}{\\partial x'}  \\frac{\\partial y}{\\partial y'}  \\frac{\\partial y}{\\partial z'} \\\\ \\frac{\\partial z}{\\partial x'}  \\frac{\\partial z}{\\partial y'}  \\frac{\\partial z}{\\partial z'} \\end{pmatrix} = \\begin{pmatrix} 1  \\dot{\\gamma}s  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix}\n$$\n左柯西-格林（或芬格）张量 $\\boldsymbol{B}(s)$ 由 $\\boldsymbol{B}(s) = \\boldsymbol{F}(s)\\boldsymbol{F}(s)^{\\mathsf{T}}$ 给出：\n$$\n\\boldsymbol{B}(s) = \\begin{pmatrix} 1  \\dot{\\gamma}s  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix} \\begin{pmatrix} 1  0  0 \\\\ \\dot{\\gamma}s  1  0 \\\\ 0  0  1 \\end{pmatrix} = \\begin{pmatrix} 1 + (\\dot{\\gamma}s)^2  \\dot{\\gamma}s  0 \\\\ \\dot{\\gamma}s  1  0 \\\\ 0  0  1 \\end{pmatrix}\n$$\n计算芬格张量的逆 $\\boldsymbol{B}^{-1}(s)$。$\\boldsymbol{B}(s)$ 的行列式为 $\\det(\\boldsymbol{B}(s)) = (1 + (\\dot{\\gamma}s)^2)(1) - (\\dot{\\gamma}s)^2 = 1$，这对于不可压缩流体是预期的结果。\n$$\n\\boldsymbol{B}^{-1}(s) = \\begin{pmatrix} 1  -\\dot{\\gamma}s  0 \\\\ -\\dot{\\gamma}s  1 + (\\dot{\\gamma}s)^2  0 \\\\ 0  0  1 \\end{pmatrix}\n$$\n具有单位阻尼函数的K-BKZ模型将附加应力张量 $\\boldsymbol{\\sigma}$ 与变形历史联系起来。对于不可压缩流体，总应力为 $\\boldsymbol{\\tau} = -p\\boldsymbol{I} + \\boldsymbol{\\sigma}$，其中 $p$ 是待定压力。第二法向应力差 $N_{2} = \\tau_{yy} - \\tau_{zz} = (-p\\delta_{yy} + \\sigma_{yy}) - (-p\\delta_{zz} + \\sigma_{zz}) = \\sigma_{yy} - \\sigma_{zz}$，因此压力项没有贡献。\n\n我们现在考虑附加应力泛函的两种候选应变度量。\n\n情况1：应力泛函取决于 $(\\boldsymbol{B} - \\boldsymbol{I})$。\n附加应力张量由下式给出：\n$$\n\\boldsymbol{\\sigma}(t) = \\int_{0}^{\\infty} m(s)\\,\\big(\\boldsymbol{B}(s) - \\boldsymbol{I}\\big)\\,\\mathrm{d}s\n$$\n项 $(\\boldsymbol{B}(s) - \\boldsymbol{I})$ 为：\n$$\n\\boldsymbol{B}(s) - \\boldsymbol{I} = \\begin{pmatrix} (\\dot{\\gamma}s)^2  \\dot{\\gamma}s  0 \\\\ \\dot{\\gamma}s  0  0 \\\\ 0  0  0 \\end{pmatrix}\n$$\n附加应力张量的相关分量为：\n$$\n\\sigma_{yy} = \\int_{0}^{\\infty} m(s) (0) \\,\\mathrm{d}s = 0\n$$\n$$\n\\sigma_{zz} = \\int_{0}^{\\infty} m(s) (0) \\,\\mathrm{d}s = 0\n$$\n因此，该模型的第二法向应力差为：\n$$\nN_{2} = \\sigma_{yy} - \\sigma_{zz} = 0\n$$\n该模型对应于给定记忆函数的上随体麦克斯韦模型，其预测的第二法向应力差为零。\n\n情况2：应力泛函取决于 $(\\boldsymbol{B}^{-1} - \\boldsymbol{I})$。\n这种情况需要进行详细计算。附加应力张量为：\n$$\n\\boldsymbol{\\sigma}(t) = \\int_{0}^{\\infty} m(s)\\,\\big(\\boldsymbol{B}^{-1}(s) - \\boldsymbol{I}\\big)\\,\\mathrm{d}s\n$$\n项 $(\\boldsymbol{B}^{-1}(s) - \\boldsymbol{I})$ 为：\n$$\n\\boldsymbol{B}^{-1}(s) - \\boldsymbol{I} = \\begin{pmatrix} 0  -\\dot{\\gamma}s  0 \\\\ -\\dot{\\gamma}s  (\\dot{\\gamma}s)^2  0 \\\\ 0  0  0 \\end{pmatrix}\n$$\n附加应力张量的相关分量为：\n$$\n\\sigma_{yy} = \\int_{0}^{\\infty} m(s) (\\dot{\\gamma}s)^2 \\,\\mathrm{d}s = \\dot{\\gamma}^2 \\int_{0}^{\\infty} m(s) s^2 \\,\\mathrm{d}s\n$$\n$$\n\\sigma_{zz} = \\int_{0}^{\\infty} m(s) (0) \\,\\mathrm{d}s = 0\n$$\n该模型的第二法向应力差为：\n$$\nN_{2} = \\sigma_{yy} - \\sigma_{zz} = \\dot{\\gamma}^2 \\int_{0}^{\\infty} m(s) s^2 \\,\\mathrm{d}s\n$$\n给定的指数记忆函数为 $m(s) = \\frac{G}{\\lambda}\\exp(-\\frac{s}{\\lambda})$。将其代入 $N_{2}$ 的表达式中：\n$$\nN_{2} = \\dot{\\gamma}^2 \\int_{0}^{\\infty} \\left(\\frac{G}{\\lambda}\\exp\\left(-\\frac{s}{\\lambda}\\right)\\right) s^2 \\,\\mathrm{d}s\n$$\n我们可以将常数从积分中提出：\n$$\nN_{2} = \\frac{G \\dot{\\gamma}^2}{\\lambda} \\int_{0}^{\\infty} s^2 \\exp\\left(-\\frac{s}{\\lambda}\\right) \\,\\mathrm{d}s\n$$\n该积分是与伽马函数相关的标准形式。通用公式为 $\\int_{0}^{\\infty} x^n \\exp(-ax) \\,\\mathrm{d}x = \\frac{n!}{a^{n+1}}$。在我们的例子中，$n=2$ 且 $a = \\frac{1}{\\lambda}$。\n$$\n\\int_{0}^{\\infty} s^2 \\exp\\left(-\\frac{s}{\\lambda}\\right) \\,\\mathrm{d}s = \\frac{2!}{(1/\\lambda)^{2+1}} = \\frac{2}{(1/\\lambda)^3} = 2\\lambda^3\n$$\n将此结果代回 $N_{2}$ 的表达式中：\n$$\nN_{2} = \\frac{G \\dot{\\gamma}^2}{\\lambda} (2\\lambda^3)\n$$\n简化表达式得到最终的闭式解：\n$$\nN_{2} = 2G\\lambda^2\\dot{\\gamma}^2\n$$\n该模型对应于下随体麦克斯韦模型，其预测的第二法向应力差为非零正值，并且与剪切速率成二次方关系。",
            "answer": "$$\\boxed{2G\\lambda^{2}\\dot{\\gamma}^{2}}$$"
        },
        {
            "introduction": "在数值模拟中实施积分型本构模型需要高效的算法来管理变形历史。最后一个练习旨在连接理论与计算，要求您推导并编写一个递推更新方案来处理 Finger 张量。成功完成此任务表明您已掌握如何将 K-BKZ 模型的连续介质运动学理论转化为实用且计算上可行的算法。",
            "id": "4090491",
            "problem": "考虑一个经历简单剪切的均质不可压缩连续体，其在 Kaye-Bernstein-Kearsley-Zapas (K-BKZ) 积分本构框架内进行建模。基本运动学由相对变形梯度 $\\boldsymbol{F}(t,t')$ 指定，它将材料线元从过去的时间 $t'$ 映射到当前时间 $t$，并遵循输运方程 $\\dfrac{d}{dt}\\boldsymbol{F}(t,t')=\\boldsymbol{L}(t)\\,\\boldsymbol{F}(t,t')$，初始条件为 $\\boldsymbol{F}(t',t')=\\boldsymbol{I}$，其中 $\\boldsymbol{L}(t)$ 是空间速度梯度，$\\boldsymbol{I}$ 是单位张量。Finger 应变度量定义为 $\\boldsymbol{B}(t,t')=\\boldsymbol{F}(t,t')\\,\\boldsymbol{F}^{\\mathsf{T}}(t,t')$。\n\n在简单剪切中，空间速度梯度 $\\boldsymbol{L}(t)$ 只有分量 $L_{12}(t)$ 非零，且 $L_{12}(t)=\\dot{\\gamma}(t)$，其中 $\\dot{\\gamma}(t)$ 是剪切速率。假设一个离散时间网格 $t_n=n\\,\\Delta t$，其具有均匀间距 $\\Delta t>0$ 和整数 $n\\geq 0$，并将 $t_{n-k}$ 和 $t_n$ 之间的 Finger 张量记为 $\\boldsymbol{B}(t_n,t_{n-k})$，其中整数 $k\\in\\{1,2,\\dots,n\\}$。\n\n您的任务是：\n- 仅从相对变形梯度的输运方程、Finger 张量的定义以及简单剪切中 $\\boldsymbol{L}(t)$ 的结构出发，推导出一个递归关系，该关系能够在一个新的时间步 $t_{n+1}$ 仅使用前一个时间步 $t_n$ 的信息和当前的增量变形来计算所有 $k\\in\\{1,\\dots,n\\}$ 的 $\\boldsymbol{B}(t_n,t_{n-k})$（即，不要在每一步都从 $t_0$ 重新计算整个历史）。\n- 设计并实现一个算法，该算法使用此递归关系，在均匀时间网格上高效地将整个集合 $\\{\\boldsymbol{B}(t_n,t_{n-k})\\}_{k=1}^n$ 更新为 $\\{\\boldsymbol{B}(t_{n+1},t_{n+1-k})\\}_{k=1}^{n+1}$，以适用于简单剪切。\n- 为验证正确性，将您递归计算的 $\\boldsymbol{B}(t_n,t_{n-k})$ 与由简单剪切的基本运动学所蕴含的精确表达式进行比较。在构建闭式基准时，只能使用累积剪切 $\\Gamma(t,t')=\\int_{t'}^{t}\\dot{\\gamma}(s)\\,ds$ 作为唯一可引用的中间量；所有其他步骤必须遵循基本定义。将每个测试案例的差异量化为在所有时间 $t_n$ 和所有 $k\\in\\{1,\\dots,n\\}$ 上的最大绝对逐元误差。\n\n对张量使用 $3\\times 3$ 表示，剪切发生在 $\\{x,y\\}$ 平面，$\\{z\\}$ 方向不受影响，并假设除了时间和剪切速率外，所有量都是无量纲的。时间必须以秒为单位处理，剪切速率以秒的倒数为单位；最终报告的误差是无量纲的。\n\n实现一个完整的、可运行的程序，对以下测试套件执行更新和验证。对于每个测试案例，使用指定的参数，在整个时间范围内计算递归更新，并报告一个等于在所有计算的对 $\\{(t_n,t_{n-k})\\}$ 中，递归 $\\boldsymbol{B}$ 和精确 $\\boldsymbol{B}$ 之间的最大绝对逐元误差的标量。\n\n测试套件：\n- 案例 1（恒定剪切速率，理想路径）：$\\Delta t=0.25\\,\\text{s}$，$N=8$ 步，在所有时间 $\\dot{\\gamma}(t)=2.0\\,\\text{s}^{-1}$。\n- 案例 2（平滑时间变化）：$\\Delta t=0.05\\,\\text{s}$，$N=40$ 步，$\\dot{\\gamma}(t)=1.5\\,\\sin(\\omega t)$，其中 $\\omega=1.0\\,\\text{rad}\\,\\text{s}^{-1}$，在 $t_n=n\\,\\Delta t$ 处求值。\n- 案例 3（符号变化和平台期）：$\\Delta t=0.10\\,\\text{s}$，$N=20$ 步，分段恒定方案：前 5 步 $\\dot{\\gamma}(t)=3.0\\,\\text{s}^{-1}$，接下来 5 步 $\\dot{\\gamma}(t)=-3.0\\,\\text{s}^{-1}$，再接下来 5 步 $\\dot{\\gamma}(t)=0.0\\,\\text{s}^{-1}$，最后 5 步 $\\dot{\\gamma}(t)=1.0\\,\\text{s}^{-1}$。\n- 案例 4（粗步长，交替速率，边界检查）：$\\Delta t=0.50\\,\\text{s}$，$N=6$ 步，第 1 步到第 6 步的 $\\dot{\\gamma}(t)$ 方案等于 $\\{0.0,\\,0.0,\\,5.0,\\,-5.0,\\,2.5,\\,-2.5\\}\\,\\text{s}^{-1}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[r_1,r_2,r_3,r_4]$），其中每个 $r_i$ 是相应测试案例的最大绝对误差，表示为十进制浮点数。不得产生任何其他输出。",
            "solution": "此问题经评估为有效。它在科学上以连续介质力学为基础，在数学上是适定的、客观的且内部一致的。推导、实现和验证所需的所有数据和条件均已提供。开始进行求解。\n\n这个问题的核心是设计并验证一个高效的递归算法，用于在采用像 K-BKZ 模型这样的积分本构模型的仿真中，更新 Finger 应变张量 $\\boldsymbol{B}(t,t')$ 的历史。运动学被限制为简单剪切。\n\n### 1. 递归更新法则的推导\n\n材料变形的时间演化由相对变形梯度 $\\boldsymbol{F}(t, t')$ 捕捉，它将线元从过去在时间 $t'$ 的构型映射到当前在时间 $t$ 的构型。变形梯度的一个基本性质是它们的复合律。对于任意三个时间 $t_j < t_n < t_{n+1}$，从 $t_j$ 到 $t_{n+1}$ 的变形可以分解为：\n$$\n\\boldsymbol{F}(t_{n+1}, t_j) = \\boldsymbol{F}(t_{n+1}, t_n) \\boldsymbol{F}(t_n, t_j)\n$$\n这里，$\\boldsymbol{F}(t_{n+1}, t_n)$ 是时间区间 $[t_n, t_{n+1}]$ 上的增量变形梯度，我们将其表示为 $\\Delta \\boldsymbol{F}_n$。该方程变为：\n$$\n\\boldsymbol{F}(t_{n+1}, t_j) = \\Delta \\boldsymbol{F}_n \\, \\boldsymbol{F}(t_n, t_j)\n$$\nFinger 应变张量 $\\boldsymbol{B}(t, t')$ 定义为 $\\boldsymbol{B}(t,t') = \\boldsymbol{F}(t,t')\\,\\boldsymbol{F}^{\\mathsf{T}}(t,t')$。我们可以将复合律代入 $\\boldsymbol{B}(t_{n+1}, t_j)$ 的定义中：\n$$\n\\boldsymbol{B}(t_{n+1}, t_j) = \\left( \\Delta \\boldsymbol{F}_n \\, \\boldsymbol{F}(t_n, t_j) \\right) \\left( \\Delta \\boldsymbol{F}_n \\, \\boldsymbol{F}(t_n, t_j) \\right)^{\\mathsf{T}}\n$$\n使用性质 $(AB)^{\\mathsf{T}} = B^{\\mathsf{T}}A^{\\mathsf{T}}$，我们得到：\n$$\n\\boldsymbol{B}(t_{n+1}, t_j) = \\Delta \\boldsymbol{F}_n \\, \\boldsymbol{F}(t_n, t_j) \\, \\boldsymbol{F}^{\\mathsf{T}}(t_n, t_j) \\, \\Delta \\boldsymbol{F}_n^{\\mathsf{T}}\n$$\n认识到 $\\boldsymbol{F}(t_n, t_j) \\, \\boldsymbol{F}^{\\mathsf{T}}(t_n, t_j) = \\boldsymbol{B}(t_n, t_j)$，我们得出所求的递归关系：\n$$\n\\boldsymbol{B}(t_{n+1}, t_j) = \\Delta \\boldsymbol{F}_n \\, \\boldsymbol{B}(t_n, t_j) \\, \\Delta \\boldsymbol{F}_n^{\\mathsf{T}}\n$$\n该方程允许我们通过对前一时间步 $t_n$ 的相应张量进行前乘和后乘增量变形梯度 $\\Delta \\boldsymbol{F}_n$ 及其转置的“更新”操作，来计算时间 $t_{n+1}$ 相对于任何过去时间 $t_j$ ($j < n$) 的 Finger 张量。\n\n### 2. 增量变形梯度的计算\n\n为了使用递归，我们必须确定增量变形梯度 $\\Delta \\boldsymbol{F}_n = \\boldsymbol{F}(t_{n+1}, t_n)$。它是输运方程 $\\frac{d}{dt}\\boldsymbol{F}(t,t_n) = \\boldsymbol{L}(t)\\,\\boldsymbol{F}(t,t_n)$ 在区间 $t \\in [t_n, t_{n+1}]$ 上，初始条件为 $\\boldsymbol{F}(t_n,t_n) = \\boldsymbol{I}$ 的解。对于简单剪切的特定情况，速度梯度张量 $\\boldsymbol{L}(t)$ 只有一个非零分量 $L_{12}(t) = \\dot{\\gamma}(t)$：\n$$\n\\boldsymbol{L}(t) = \\begin{pmatrix} 0  \\dot{\\gamma}(t)  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix}\n$$\n该矩阵的一个关键性质是，对于任意两个时间 $t_a$ 和 $t_b$，其交换子为零：$[\\boldsymbol{L}(t_a), \\boldsymbol{L}(t_b)] = \\boldsymbol{L}(t_a)\\boldsymbol{L}(t_b) - \\boldsymbol{L}(t_b)\\boldsymbol{L}(t_a) = \\boldsymbol{0} - \\boldsymbol{0} = \\boldsymbol{0}$，因为 $\\boldsymbol{L}(t)^2 = \\boldsymbol{0}$。这种可交换性将输运方程的解简化为 $\\boldsymbol{L}(t)$ 积分的标准矩阵指数：\n$$\n\\Delta \\boldsymbol{F}_n = \\boldsymbol{F}(t_{n+1}, t_n) = \\exp\\left(\\int_{t_n}^{t_{n+1}} \\boldsymbol{L}(s) \\, ds\\right)\n$$\n令 $\\Delta \\gamma_n = \\int_{t_n}^{t_{n+1}} \\dot{\\gamma}(s) \\, ds$ 为在区间 $[t_n, t_{n+1}]$ 期间累积的剪切应变。积分后的矩阵为：\n$$\n\\int_{t_n}^{t_{n+1}} \\boldsymbol{L}(s) \\, ds = \\begin{pmatrix} 0  \\Delta \\gamma_n  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix} \\equiv \\boldsymbol{A}_n\n$$\n矩阵 $\\boldsymbol{A}_n$ 是 2 阶幂零的（即 $\\boldsymbol{A}_n^2 = \\boldsymbol{0}$）。因此，矩阵指数的泰勒级数 $\\exp(\\boldsymbol{A}_n) = \\boldsymbol{I} + \\boldsymbol{A}_n + \\frac{1}{2!}\\boldsymbol{A}_n^2 + \\dots$ 在线性项之后终止：\n$$\n\\Delta \\boldsymbol{F}_n = \\exp(\\boldsymbol{A}_n) = \\boldsymbol{I} + \\boldsymbol{A}_n = \\begin{pmatrix} 1  \\Delta \\gamma_n  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix}\n$$\n问题为每个步骤指定了分段恒定的剪切速率。令 $\\dot{\\gamma}_n$ 为区间 $[t_{n-1}, t_n]$ 上的恒定剪切速率。增量剪切应变恰好为 $\\Delta \\gamma_{n-1} = \\dot{\\gamma}_n \\Delta t$。\n\n### 3. 完整的递归算法\n\n在每个时间步 $t_n$（对于 $n=1, \\dots, N$），我们需要生成历史张量集合 $\\{\\boldsymbol{B}(t_n, t_{n-k})\\}_{k=1}^n$。算法流程如下：\n1. 初始化一个空列表 `history_B` 来存储张量。\n2. 对从 1 到 $N$ 的每个步骤 $n$：\n   a. 确定增量剪切应变 $\\Delta \\gamma_{n-1} = \\dot{\\gamma}_n \\Delta t$，其中 $\\dot{\\gamma}_n$ 是为步骤 $n$ 指定的速率。\n   b. 构建增量变形梯度 $\\Delta \\boldsymbol{F}_{n-1} = \\boldsymbol{F}(t_n, t_{n-1})$。\n   c. 为时间 $t_n$ 的更新历史创建一个新列表。\n   d. 对于 `history_B` 中的每个现有张量 $\\boldsymbol{B}_{old} = \\boldsymbol{B}(t_{n-1}, t_j)$，计算更新后的张量 $\\boldsymbol{B}_{new} = \\Delta \\boldsymbol{F}_{n-1} \\, \\boldsymbol{B}_{old} \\, \\Delta \\boldsymbol{F}_{n-1}^{\\mathsf{T}}$ 并将其添加到新列表中。这将 $\\boldsymbol{B}(t_{n-1}, t_j)$ 更新为 $\\boldsymbol{B}(t_n, t_j)$。\n   e. 计算最新的历史张量，它对应于最近的时间间隔：$\\boldsymbol{B}(t_n, t_{n-1}) = \\Delta \\boldsymbol{F}_{n-1} \\, \\Delta \\boldsymbol{F}_{n-1}^{\\mathsf{T}}$。\n   f. 将这个最新的张量前置添加到新列表中。\n   g. 用新列表替换旧的 `history_B`。\n\n此过程通过利用上一步的结果，高效地更新整个历史，避免了从 $t_0$ 开始的耗时重积分。\n\n### 4. 用于精确验证的表达式\n\n为了验证，我们将递归计算的张量与直接、精确的计算结果进行比较。问题指出，精确计算应基于总累积剪切 $\\Gamma(t,t')=\\int_{t'}^{t}\\dot{\\gamma}(s)\\,ds$。\n遵循与 $\\Delta \\boldsymbol{F}_n$ 相似的推导，精确的相对变形梯度 $\\boldsymbol{F}(t, t')$ 为：\n$$\n\\boldsymbol{F}(t, t') = \\begin{pmatrix} 1  \\Gamma(t, t')  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix}\n$$\n由此，精确的 Finger 张量 $\\boldsymbol{B}(t, t')$ 为：\n$$\n\\boldsymbol{B}(t, t') = \\boldsymbol{F}(t, t') \\boldsymbol{F}^{\\mathsf{T}}(t, t') = \\begin{pmatrix} 1  \\Gamma(t, t')  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix} \\begin{pmatrix} 1  0  0 \\\\ \\Gamma(t, t')  1  0 \\\\ 0  0  1 \\end{pmatrix}\n$$\n$$\n\\boldsymbol{B}(t, t') = \\begin{pmatrix} 1 + \\Gamma(t, t')^2  \\Gamma(t, t')  0 \\\\ \\Gamma(t, t')  1  0 \\\\ 0  0  1 \\end{pmatrix}\n$$\n对于一个分段恒定剪切速率方案，其中 $\\dot{\\gamma}_i$ 是区间 $[t_{i-1}, t_i]$ 的速率，在 $t_j$ 和 $t_n$ ($j<n$) 之间的总累积剪切是：\n$$\n\\Gamma(t_n, t_j) = \\int_{t_j}^{t_n} \\dot{\\gamma}(s) ds = \\sum_{i=j+1}^{n} \\dot{\\gamma}_i \\Delta t\n$$\n所提供的 Python 代码实现了这一递归更新和验证过程。它为每个测试案例计算最大绝对误差，并应返回一个接近机器精度的值，因为递归方法和精确方法在代数上是等价的。",
            "answer": "```python\nimport numpy as np\nimport math\n\n# Per the problem constraints, scipy is permitted but not required for this solution.\n# The calculations can be performed entirely with numpy.\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n\n    def get_case_1_schedule(N, dt):\n        return [2.0] * N\n\n    def get_case_2_schedule(N, dt):\n        omega = 1.0\n        # The rate for step n (interval [t_{n-1}, t_n]) is evaluated at t_n.\n        return [1.5 * math.sin(omega * n * dt) for n in range(1, N + 1)]\n\n    def get_case_3_schedule(N, dt):\n        return [3.0]*5 + [-3.0]*5 + [0.0]*5 + [1.0]*5\n\n    def get_case_4_schedule(N, dt):\n        return [0.0, 0.0, 5.0, -5.0, 2.5, -2.5]\n\n    test_cases = [\n        # (dt, N, schedule_generator_function)\n        (0.25, 8, get_case_1_schedule),\n        (0.05, 40, get_case_2_schedule),\n        (0.10, 20, get_case_3_schedule),\n        (0.50, 6, get_case_4_schedule),\n    ]\n\n    results = []\n    for dt, N, schedule_func in test_cases:\n        gamma_dot_schedule = schedule_func(N, dt)\n        max_abs_error = run_simulation_and_validate(dt, N, gamma_dot_schedule)\n        results.append(max_abs_error)\n\n    # Format output as specified: [r1,r2,r3,r4]\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation_and_validate(dt, N, gamma_dot_schedule):\n    \"\"\"\n    Performs the recursive update and validation for a single test case.\n\n    Args:\n        dt (float): The uniform time step size.\n        N (int): The total number of steps.\n        gamma_dot_schedule (list[float]): The piecewise-constant shear rate for each step.\n\n    Returns:\n        float: The maximum absolute entrywise error found during the simulation.\n    \"\"\"\n    max_total_error = 0.0\n    \n    # B_hist_rec stores [B(t_n, t_{n-1}), B(t_n, t_{n-2}), ..., B(t_n, t_0)]\n    B_hist_rec = []\n\n    for n in range(1, N + 1):  # Loop over time steps from t_1 to t_N\n        # Rate for the current step n (interval [t_{n-1}, t_n])\n        gamma_dot_val = gamma_dot_schedule[n - 1]\n        delta_gamma = gamma_dot_val * dt\n\n        # -- Recursive Update --\n        # Incremental deformation gradient F(t_n, t_{n-1})\n        delta_F = np.array([[1.0, delta_gamma, 0.0],\n                              [0.0, 1.0, 0.0],\n                              [0.0, 0.0, 1.0]])\n\n        # Update all previously existing history tensors\n        B_hist_rec_new = [delta_F @ B_old @ delta_F.T for B_old in B_hist_rec]\n\n        # Compute and add the newest history tensor B(t_n, t_{n-1})\n        B_newest = delta_F @ delta_F.T\n        B_hist_rec_new.insert(0, B_newest)\n        \n        B_hist_rec = B_hist_rec_new\n\n        # -- Exact Calculation for Validation at time t_n --\n        B_hist_exact_n = []\n        for k in range(1, n + 1):  # k is the history lag-index, from 1 to n\n            # past_time_index j, from n-1 down to 0\n            j = n - k\n            \n            # Calculate total shear Gamma(t_n, t_j)\n            # Sum rate contributions from step j+1 to step n\n            Gamma_tn_tj = sum(gamma_dot_schedule[i - 1] for i in range(j + 1, n + 1)) * dt\n            \n            # Construct exact Finger tensor B(t_n, t_j)\n            B_exact = np.array([[1.0 + Gamma_tn_tj**2, Gamma_tn_tj, 0.0],\n                                  [Gamma_tn_tj, 1.0, 0.0],\n                                  [0.0, 0.0, 1.0]])\n            B_hist_exact_n.append(B_exact)\n\n        # -- Compare recursive vs exact and update max error --\n        # The lists B_hist_rec and B_hist_exact_n both store tensors\n        # ordered from newest (k=1) to oldest (k=n).\n        for B_rec, B_exact in zip(B_hist_rec, B_hist_exact_n):\n            error = np.max(np.abs(B_rec - B_exact))\n            if error > max_total_error:\n                max_total_error = error\n                \n    return max_total_error\n\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        }
    ]
}