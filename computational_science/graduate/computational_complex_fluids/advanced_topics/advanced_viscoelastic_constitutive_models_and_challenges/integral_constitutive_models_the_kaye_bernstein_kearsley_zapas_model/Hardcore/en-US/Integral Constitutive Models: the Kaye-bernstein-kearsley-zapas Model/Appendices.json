{
    "hands_on_practices": [
        {
            "introduction": "The heart of the K-BKZ model lies in its strain energy function, which depends on scalar invariants of the deformation. This first practice focuses on the fundamental kinematics by asking you to connect these mathematical invariants, $I_1$ and $I_2$, to their physical origin: the principal stretch ratios of the deformation . Successfully deriving this relationship is a crucial first step toward understanding how the model translates microscopic stretching into macroscopic stress predictions.",
            "id": "4090502",
            "problem": "Consider a three-dimensional continuum undergoing a general deformation from time $t'$ to time $t$. Let the deformation gradient be denoted by $\\boldsymbol{F}(t,t')$, and the Finger tensor (or left Cauchy-Green tensor) be $\\boldsymbol{B}(t,t') = \\boldsymbol{F}(t,t')\\boldsymbol{F}^{\\mathsf{T}}(t,t')$. The damping function in the K-BKZ model often depends on the principal invariants of strain tensors like $\\boldsymbol{B}(t,t')$ and its inverse, $\\boldsymbol{B}^{-1}(t,t')$.\n\nStarting strictly from continuum kinematics and fundamental tensor properties, use spectral arguments to express the first and second principal invariants of the inverse Finger tensor, $\\boldsymbol{B}^{-1}(t,t')$, in terms of the principal stretch ratios $\\lambda_{1}(t,t')$, $\\lambda_{2}(t,t')$, and $\\lambda_{3}(t,t')$ associated with the deformation between $t'$ and $t$. Assume only that the deformation has a real polar decomposition and that the stretch tensor is diagonalizable with real, positive principal stretches. Your final answer must be a single closed-form symbolic expression giving both invariants as functions of $\\lambda_{1}(t,t')$, $\\lambda_{2}(t,t')$, and $\\lambda_{3}(t,t')$.\n\nNo numerical evaluation is required. If you introduce any auxiliary quantities, eliminate them in the final expression so that the answer is stated solely in terms of $\\lambda_{1}(t,t')$, $\\lambda_{2}(t,t')$, and $\\lambda_{3}(t,t')$.",
            "solution": "This is a well-posed, scientifically grounded problem in continuum mechanics that asks for a rigorous derivation based on fundamental principles of tensor algebra and kinematics.\n\nWe begin by establishing the relationship between the inverse Finger tensor $\\boldsymbol{B}^{-1}(t,t')$ and the principal stretch ratios $\\lambda_{i}(t,t')$. For notational conciseness within the derivation, we will denote the deformation-dependent quantities $\\boldsymbol{F}(t,t')$, $\\boldsymbol{B}(t,t')$, and $\\lambda_{i}(t,t')$ as $\\boldsymbol{F}$, $\\boldsymbol{B}$, and $\\lambda_{i}$ respectively.\n\nThe Finger tensor is defined as:\n$$\n\\boldsymbol{B} = \\boldsymbol{F}\\boldsymbol{F}^{\\mathsf{T}}\n$$\nThe problem assumes the existence of the polar decomposition of the deformation gradient $\\boldsymbol{F}$. We write this decomposition as:\n$$\n\\boldsymbol{F} = \\boldsymbol{R}\\boldsymbol{U}\n$$\nwhere $\\boldsymbol{R}$ is a proper orthogonal tensor representing a pure rotation ($\\boldsymbol{R}^{\\mathsf{T}}\\boldsymbol{R} = \\boldsymbol{R}\\boldsymbol{R}^{\\mathsf{T}} = \\boldsymbol{I}$, where $\\boldsymbol{I}$ is the second-order identity tensor) and $\\boldsymbol{U}$ is the right stretch tensor, which is symmetric ($\\boldsymbol{U}^{\\mathsf{T}} = \\boldsymbol{U}$) and positive-definite.\n\nSubstituting the polar decomposition into the definition of $\\boldsymbol{B}$ yields:\n$$\n\\boldsymbol{B} = (\\boldsymbol{R}\\boldsymbol{U})(\\boldsymbol{R}\\boldsymbol{U})^{\\mathsf{T}} = \\boldsymbol{R}\\boldsymbol{U}\\boldsymbol{U}^{\\mathsf{T}}\\boldsymbol{R}^{\\mathsf{T}}\n$$\nUsing the property $\\boldsymbol{U}^{\\mathsf{T}} = \\boldsymbol{U}$, we obtain:\n$$\n\\boldsymbol{B} = \\boldsymbol{R}\\boldsymbol{U}^2\\boldsymbol{R}^{\\mathsf{T}}\n$$\nThis shows that $\\boldsymbol{B}$ is similar to $\\boldsymbol{U}^2$, and therefore they share the same eigenvalues. The problem states that the stretch tensor $\\boldsymbol{U}$ is diagonalizable. This implies that there exists an orthonormal basis of eigenvectors $\\{\\boldsymbol{n}_{1}, \\boldsymbol{n}_{2}, \\boldsymbol{n}_{3}\\}$ such that the action of $\\boldsymbol{U}$ on each $\\boldsymbol{n}_{i}$ is a simple scaling by the corresponding eigenvalue, which is the principal stretch ratio $\\lambda_{i}$. The spectral decomposition of $\\boldsymbol{U}$ is therefore:\n$$\n\\boldsymbol{U} = \\sum_{i=1}^{3} \\lambda_{i} (\\boldsymbol{n}_{i} \\otimes \\boldsymbol{n}_{i})\n$$\nwhere $\\lambda_{i} > 0$ are the principal stretches. The eigenvalues of $\\boldsymbol{U}^2$ are thus $\\lambda_{i}^2$, and consequently, the eigenvalues of $\\boldsymbol{B}$ are also $\\lambda_{i}^2$.\n\nThe tensor of interest is the inverse Finger tensor, $\\boldsymbol{B}^{-1}$. Its eigenvalues are the reciprocal of the eigenvalues of $\\boldsymbol{B}$. Therefore, the eigenvalues of $\\boldsymbol{B}^{-1}$, which we denote as $\\beta_i$, are:\n$$\n\\beta_{1} = \\lambda_{1}^{-2}, \\quad \\beta_{2} = \\lambda_{2}^{-2}, \\quad \\beta_{3} = \\lambda_{3}^{-2}\n$$\nThe principal invariants of a second-order tensor are defined in terms of its eigenvalues. The first principal invariant, $I_{1}$, is the trace of the tensor, which is the sum of its eigenvalues. For the tensor $\\boldsymbol{B}^{-1}$, this is:\n$$\nI_{1}(\\boldsymbol{B}^{-1}) = \\text{tr}(\\boldsymbol{B}^{-1}) = \\beta_{1} + \\beta_{2} + \\beta_{3} = \\lambda_{1}^{-2} + \\lambda_{2}^{-2} + \\lambda_{3}^{-2}\n$$\nThe second principal invariant, $I_{2}$, is the sum of the products of the eigenvalues taken two at a time. For the tensor $\\boldsymbol{B}^{-1}$, this is:\n$$\nI_{2}(\\boldsymbol{B}^{-1}) = \\beta_{1}\\beta_{2} + \\beta_{2}\\beta_{3} + \\beta_{3}\\beta_{1} = (\\lambda_{1}^{-2})(\\lambda_{2}^{-2}) + (\\lambda_{2}^{-2})(\\lambda_{3}^{-2}) + (\\lambda_{3}^{-2})(\\lambda_{1}^{-2})\n$$\nRestoring the full notation for the principal stretch ratios, which depend on the time interval $(t', t)$, we have the final expressions.\n\nThe first principal invariant of $\\boldsymbol{B}^{-1}(t,t')$ is:\n$$\nI_{1}(\\boldsymbol{B}^{-1}(t,t')) = \\lambda_{1}(t,t')^{-2} + \\lambda_{2}(t,t')^{-2} + \\lambda_{3}(t,t')^{-2}\n$$\nThe second principal invariant of $\\boldsymbol{B}^{-1}(t,t')$ is:\n$$\nI_{2}(\\boldsymbol{B}^{-1}(t,t')) = \\lambda_{1}(t,t')^{-2}\\lambda_{2}(t,t')^{-2} + \\lambda_{2}(t,t')^{-2}\\lambda_{3}(t,t')^{-2} + \\lambda_{3}(t,t')^{-2}\\lambda_{1}(t,t')^{-2}\n$$\nThese expressions provide the required relationship between the invariants of the inverse Finger tensor and the principal stretch ratios, derived strictly from kinematic definitions and spectral properties of tensors.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\nI_1(\\boldsymbol{B}^{-1}) = \\lambda_{1}(t,t')^{-2} + \\lambda_{2}(t,t')^{-2} + \\lambda_{3}(t,t')^{-2} \\\\\nI_2(\\boldsymbol{B}^{-1}) = \\lambda_{1}(t,t')^{-2}\\lambda_{2}(t,t')^{-2} + \\lambda_{2}(t,t')^{-2}\\lambda_{3}(t,t')^{-2} + \\lambda_{3}(t,t')^{-2}\\lambda_{1}(t,t')^{-2}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "A constitutive model's utility is judged by its ability to predict real-world fluid behavior, such as normal stress differences in shear flow. This exercise explores the profound impact of choosing a specific strain measure within the K-BKZ framework . By calculating the second normal stress difference ($N_2$) for models based on the Finger tensor $\\boldsymbol{B}$ and its inverse $\\boldsymbol{B}^{-1}$, you will directly observe how these choices lead to distinct and testable physical predictions.",
            "id": "4090528",
            "problem": "Consider a homogeneous, incompressible, isothermal viscoelastic fluid modeled by a single-mode Kaye–Bernstein–Kearsley–Zapas (K-BKZ) integral constitutive equation. The memory function is taken as exponential, $m(s) = (G/\\lambda)\\exp(-s/\\lambda)$, where $G$ is a modulus and $\\lambda$ is a relaxation time. Assume the damping function equals unity, so that the stress tensor functional depends only on the chosen strain measure. Let the flow be steady simple shear with velocity field $\\boldsymbol{v} = \\dot{\\gamma}\\, y\\, \\boldsymbol{e}_{x}$, where $\\dot{\\gamma}$ is a constant shear rate. Denote the time lag by $s = t - t'$, and use the standard continuum kinematics to define the deformation gradient $\\boldsymbol{F}(t,t')$ over the interval $[t',t]$, the left Cauchy–Green (Finger) tensor $\\boldsymbol{B}(t,t') = \\boldsymbol{F}(t,t')\\,\\boldsymbol{F}(t,t')^{\\mathsf{T}}$, and its inverse $\\boldsymbol{B}^{-1}(t,t')$.\n\nDefine the second normal stress difference as $N_{2} = \\sigma_{yy} - \\sigma_{zz}$, where $\\boldsymbol{\\sigma}$ is the Cauchy stress tensor. Starting from the fundamental definitions of $\\boldsymbol{F}$, $\\boldsymbol{B}$, and $\\boldsymbol{B}^{-1}$ for steady simple shear, and the K-BKZ integral stress construction with the two candidate strain measures $\\boldsymbol{B}$ and $\\boldsymbol{B}^{-1}$ via the linear tensor functional $[\\cdot - \\boldsymbol{I}]$, derive the steady-state prediction of $N_{2}$ in both cases. Then, by explicit evaluation of the time integral, determine the closed-form analytic expression for $N_{2}$ when the stress functional uses the inverse Finger tensor, that is,\n$$\n\\boldsymbol{\\sigma}(t) = \\int_{0}^{\\infty} m(s)\\,\\big(\\boldsymbol{B}^{-1}(s) - \\boldsymbol{I}\\big)\\,\\mathrm{d}s,\n$$\nunder steady simple shear at constant $\\dot{\\gamma}$.\n\nExpress your final answer for $N_{2}$ as a single analytic expression in terms of $G$, $\\lambda$, and $\\dot{\\gamma}$. No numerical evaluation is required. If you introduce any angles, they must be in radians; if you introduce any physical units, state them, but the final boxed answer must be unitless. Your final answer must be a single closed-form analytical expression.",
            "solution": "The problem requires the derivation of the second normal stress difference, $N_{2}$, for a viscoelastic fluid described by a single-mode K-BKZ constitutive equation under steady simple shear. We must first analyze the cases where the strain measure is based on the Finger tensor $\\boldsymbol{B}$ and its inverse $\\boldsymbol{B}^{-1}$, and then provide a closed-form solution for the latter case.\n\nThe first step is to establish the kinematics for steady simple shear flow. The velocity field is given by $\\boldsymbol{v} = \\dot{\\gamma} y \\boldsymbol{e}_{x}$, where $\\dot{\\gamma}$ is the constant shear rate. The position $\\boldsymbol{x}' = (x', y', z')$ of a fluid particle at a past time $t'$ is related to its position $\\boldsymbol{x} = (x, y, z)$ at the present time $t$ by integrating the velocity field. For a steady flow, the relationship depends only on the time lag $s = t - t'$. The mapping from the current configuration to the past configuration is:\n$$\nx' = x - \\dot{\\gamma} y s, \\quad y' = y, \\quad z' = z\n$$\nThe deformation gradient tensor $\\boldsymbol{F}(s) \\equiv \\boldsymbol{F}(t, t')$ is defined by its components $F_{ij} = \\frac{\\partial x_i(t)}{\\partial x'_j(t')}$. To calculate this, we use the inverse mapping, which describes the current position as a function of the past position:\n$$\nx(t) = x' + \\dot{\\gamma} y' s, \\quad y(t) = y', \\quad z(t) = z'\n$$\nThe components of the deformation gradient tensor are then:\n$$\n\\boldsymbol{F}(s) = \\begin{pmatrix} \\frac{\\partial x}{\\partial x'}  \\frac{\\partial x}{\\partial y'}  \\frac{\\partial x}{\\partial z'} \\\\ \\frac{\\partial y}{\\partial x'}  \\frac{\\partial y}{\\partial y'}  \\frac{\\partial y}{\\partial z'} \\\\ \\frac{\\partial z}{\\partial x'}  \\frac{\\partial z}{\\partial y'}  \\frac{\\partial z}{\\partial z'} \\end{pmatrix} = \\begin{pmatrix} 1  \\dot{\\gamma}s  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix}\n$$\nThe left Cauchy-Green (or Finger) tensor $\\boldsymbol{B}(s)$ is given by $\\boldsymbol{B}(s) = \\boldsymbol{F}(s)\\boldsymbol{F}(s)^{\\mathsf{T}}$:\n$$\n\\boldsymbol{B}(s) = \\begin{pmatrix} 1  \\dot{\\gamma}s  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix} \\begin{pmatrix} 1  0  0 \\\\ \\dot{\\gamma}s  1  0 \\\\ 0  0  1 \\end{pmatrix} = \\begin{pmatrix} 1 + (\\dot{\\gamma}s)^2  \\dot{\\gamma}s  0 \\\\ \\dot{\\gamma}s  1  0 \\\\ 0  0  1 \\end{pmatrix}\n$$\nThe inverse of the Finger tensor, $\\boldsymbol{B}^{-1}(s)$, is calculated. The determinant of $\\boldsymbol{B}(s)$ is $\\det(\\boldsymbol{B}(s)) = (1 + (\\dot{\\gamma}s)^2)(1) - (\\dot{\\gamma}s)^2 = 1$, as expected for an incompressible fluid.\n$$\n\\boldsymbol{B}^{-1}(s) = \\begin{pmatrix} 1  -\\dot{\\gamma}s  0 \\\\ -\\dot{\\gamma}s  1 + (\\dot{\\gamma}s)^2  0 \\\\ 0  0  1 \\end{pmatrix}\n$$\nThe K-BKZ model with a unit damping function relates the extra stress tensor $\\boldsymbol{\\sigma}$ to the history of deformation. For an incompressible fluid, the total stress is $\\boldsymbol{\\tau} = -p\\boldsymbol{I} + \\boldsymbol{\\sigma}$, where $p$ is the indeterminate pressure. The second normal stress difference $N_{2} = \\tau_{yy} - \\tau_{zz} = (-p\\delta_{yy} + \\sigma_{yy}) - (-p\\delta_{zz} + \\sigma_{zz}) = \\sigma_{yy} - \\sigma_{zz}$, so the pressure term does not contribute.\n\nWe now consider the two candidate strain measures for the extra stress functional.\n\nCase 1: Stress functional depends on $(\\boldsymbol{B} - \\boldsymbol{I})$.\nThe extra stress tensor is given by:\n$$\n\\boldsymbol{\\sigma}(t) = \\int_{0}^{\\infty} m(s)\\,\\big(\\boldsymbol{B}(s) - \\boldsymbol{I}\\big)\\,\\mathrm{d}s\n$$\nThe term $(\\boldsymbol{B}(s) - \\boldsymbol{I})$ is:\n$$\n\\boldsymbol{B}(s) - \\boldsymbol{I} = \\begin{pmatrix} (\\dot{\\gamma}s)^2  \\dot{\\gamma}s  0 \\\\ \\dot{\\gamma}s  0  0 \\\\ 0  0  0 \\end{pmatrix}\n$$\nThe relevant components of the extra stress tensor are:\n$$\n\\sigma_{yy} = \\int_{0}^{\\infty} m(s) (0) \\,\\mathrm{d}s = 0\n$$\n$$\n\\sigma_{zz} = \\int_{0}^{\\infty} m(s) (0) \\,\\mathrm{d}s = 0\n$$\nTherefore, the second normal stress difference for this model is:\n$$\nN_{2} = \\sigma_{yy} - \\sigma_{zz} = 0\n$$\nThis model, which corresponds to the upper-convected Maxwell model for the given memory function, predicts zero second normal stress difference.\n\nCase 2: Stress functional depends on $(\\boldsymbol{B}^{-1} - \\boldsymbol{I})$.\nThis is the case for which a detailed calculation is required. The extra stress tensor is:\n$$\n\\boldsymbol{\\sigma}(t) = \\int_{0}^{\\infty} m(s)\\,\\big(\\boldsymbol{B}^{-1}(s) - \\boldsymbol{I}\\big)\\,\\mathrm{d}s\n$$\nThe term $(\\boldsymbol{B}^{-1}(s) - \\boldsymbol{I})$ is:\n$$\n\\boldsymbol{B}^{-1}(s) - \\boldsymbol{I} = \\begin{pmatrix} 0  -\\dot{\\gamma}s  0 \\\\ -\\dot{\\gamma}s  (\\dot{\\gamma}s)^2  0 \\\\ 0  0  0 \\end{pmatrix}\n$$\nThe relevant components of the extra stress tensor are:\n$$\n\\sigma_{yy} = \\int_{0}^{\\infty} m(s) (\\dot{\\gamma}s)^2 \\,\\mathrm{d}s = \\dot{\\gamma}^2 \\int_{0}^{\\infty} m(s) s^2 \\,\\mathrm{d}s\n$$\n$$\n\\sigma_{zz} = \\int_{0}^{\\infty} m(s) (0) \\,\\mathrm{d}s = 0\n$$\nThe second normal stress difference for this model is:\n$$\nN_{2} = \\sigma_{yy} - \\sigma_{zz} = \\dot{\\gamma}^2 \\int_{0}^{\\infty} m(s) s^2 \\,\\mathrm{d}s\n$$\nWe are given the exponential memory function $m(s) = \\frac{G}{\\lambda}\\exp(-\\frac{s}{\\lambda})$. Substituting this into the expression for $N_{2}$:\n$$\nN_{2} = \\dot{\\gamma}^2 \\int_{0}^{\\infty} \\left(\\frac{G}{\\lambda}\\exp\\left(-\\frac{s}{\\lambda}\\right)\\right) s^2 \\,\\mathrm{d}s\n$$\nWe can pull the constants out of the integral:\n$$\nN_{2} = \\frac{G \\dot{\\gamma}^2}{\\lambda} \\int_{0}^{\\infty} s^2 \\exp\\left(-\\frac{s}{\\lambda}\\right) \\,\\mathrm{d}s\n$$\nThe integral is a standard form related to the Gamma function. The general formula is $\\int_{0}^{\\infty} x^n \\exp(-ax) \\,\\mathrm{d}x = \\frac{n!}{a^{n+1}}$. In our case, $n=2$ and $a = \\frac{1}{\\lambda}$.\n$$\n\\int_{0}^{\\infty} s^2 \\exp\\left(-\\frac{s}{\\lambda}\\right) \\,\\mathrm{d}s = \\frac{2!}{(1/\\lambda)^{2+1}} = \\frac{2}{(1/\\lambda)^3} = 2\\lambda^3\n$$\nSubstituting this result back into the expression for $N_{2}$:\n$$\nN_{2} = \\frac{G \\dot{\\gamma}^2}{\\lambda} (2\\lambda^3)\n$$\nSimplifying the expression gives the final closed-form solution:\n$$\nN_{2} = 2G\\lambda^2\\dot{\\gamma}^2\n$$\nThis model, corresponding to the lower-convected Maxwell model, predicts a non-zero, positive second normal stress difference that is quadratic in the shear rate.",
            "answer": "$$\\boxed{N_2 = 2G\\lambda^{2}\\dot{\\gamma}^{2}}$$"
        },
        {
            "introduction": "Moving from theory to simulation requires translating continuous integrals into discrete, computationally efficient algorithms. This practice addresses the central challenge of implementing integral models: managing the deformation history . You will derive and implement a recursive update scheme for the Finger tensor, a technique that is essential for avoiding redundant calculations and making large-scale simulations of K-BKZ fluids feasible.",
            "id": "4090491",
            "problem": "Consider a homogeneous incompressible continuum undergoing simple shear, modeled within the Kaye-Bernstein-Kearsley-Zapas (K-BKZ) integral constitutive framework. The fundamental kinematics are specified by the relative deformation gradient $\\boldsymbol{F}(t,t')$, which maps material line elements from the past time $t'$ to the present time $t$, and obeys the transport equation $\\dfrac{d}{dt}\\boldsymbol{F}(t,t')=\\boldsymbol{L}(t)\\,\\boldsymbol{F}(t,t')$ with initial condition $\\boldsymbol{F}(t',t')=\\boldsymbol{I}$, where $\\boldsymbol{L}(t)$ is the spatial velocity gradient and $\\boldsymbol{I}$ is the identity tensor. The Finger strain measure is defined as $\\boldsymbol{B}(t,t')=\\boldsymbol{F}(t,t')\\,\\boldsymbol{F}^{\\mathsf{T}}(t,t')$.\n\nIn simple shear, the spatial velocity gradient $\\boldsymbol{L}(t)$ is such that only the component $L_{12}(t)$ is nonzero, and $L_{12}(t)=\\dot{\\gamma}(t)$, where $\\dot{\\gamma}(t)$ is the shear rate. Assume a discrete time grid $t_n=n\\,\\Delta t$ with uniform spacing $\\Delta t>0$ and integer $n\\geq 0$, and write $\\boldsymbol{B}(t_n,t_{n-k})$ for the Finger tensor between $t_{n-k}$ and $t_n$ for integer $k\\in\\{1,2,\\dots,n\\}$.\n\nYour tasks are:\n- Starting only from the transport equation for the relative deformation gradient, the definition of the Finger tensor, and the structure of $\\boldsymbol{L}(t)$ in simple shear, derive a recursion that enables computing $\\boldsymbol{B}(t_n,t_{n-k})$ for all $k\\in\\{1,\\dots,n\\}$ at a new time step $t_{n+1}$ using only information from the previous time step $t_n$ and the current incremental deformation (i.e., do not recompute the entire history from $t_0$ at each step).\n- Design and implement an algorithm that uses this recursion to update the entire set $\\{\\boldsymbol{B}(t_n,t_{n-k})\\}_{k=1}^n$ to $\\{\\boldsymbol{B}(t_{n+1},t_{n+1-k})\\}_{k=1}^{n+1}$ efficiently for simple shear on a uniform time grid.\n- To verify correctness, compare your recursively computed $\\boldsymbol{B}(t_n,t_{n-k})$ against the exact expression implied by the fundamental kinematics for simple shear. Use the accumulated shear $\\Gamma(t,t')=\\int_{t'}^{t}\\dot{\\gamma}(s)\\,ds$ as the only intermediate quantity you may invoke in constructing a closed-form benchmark; all other steps must follow from the foundational definitions. Quantify the discrepancy for each test case as the maximum absolute entrywise error over all times $t_n$ and all $k\\in\\{1,\\dots,n\\}$.\n\nUse a $3\\times 3$ representation for tensors, with the shear occurring in the $xy$-plane and the $z$-direction remaining unaffected, and assume that all quantities are dimensionless except for time and shear rate. Time must be treated in seconds and shear rate in inverse seconds; the final reported errors are dimensionless.\n\nImplement a complete, runnable program that performs the update and validation over the following test suite. For each test case, use the specified parameters, compute the recursive updates across the full horizon, and report a single scalar equal to the maximum absolute entrywise error between the recursive and exact $\\boldsymbol{B}$ across all computed pairs $\\{(t_n,t_{n-k})\\}$.\n\nTest suite:\n- Case $1$ (constant shear rate, happy path): $\\Delta t=0.25\\,\\text{s}$, $N=8$ steps, $\\dot{\\gamma}(t)=2.0\\,\\text{s}^{-1}$ for all times.\n- Case $2$ (smooth time variation): $\\Delta t=0.05\\,\\text{s}$, $N=40$ steps, $\\dot{\\gamma}(t)=1.5\\,\\sin(\\omega t)$ with $\\omega=1.0\\,\\text{rad}\\,\\text{s}^{-1}$ evaluated at $t_n=n\\,\\Delta t$.\n- Case $3$ (sign changes and plateaus): $\\Delta t=0.10\\,\\text{s}$, $N=20$ steps, piecewise-constant schedule $\\dot{\\gamma}(t)=3.0\\,\\text{s}^{-1}$ for the first $5$ steps, $\\dot{\\gamma}(t)=-3.0\\,\\text{s}^{-1}$ for the next $5$ steps, $\\dot{\\gamma}(t)=0.0\\,\\text{s}^{-1}$ for the next $5$ steps, and $\\dot{\\gamma}(t)=1.0\\,\\text{s}^{-1}$ for the final $5$ steps.\n- Case $4$ (coarse stepping, alternating rates, boundary check): $\\Delta t=0.50\\,\\text{s}$, $N=6$ steps, schedule $\\dot{\\gamma}(t)$ over steps $1$ through $6$ equal to $\\{0.0,\\,0.0,\\,5.0,\\,-5.0,\\,2.5,\\,-2.5\\}\\,\\text{s}^{-1}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4]$), where each $r_i$ is the maximum absolute error for the corresponding test case expressed as a decimal float. No other output may be produced.",
            "solution": "The problem is assessed to be valid. It is scientifically grounded in continuum mechanics, mathematically well-posed, objective, and internally consistent. All necessary data and conditions for the derivation, implementation, and validation are provided. Proceeding with the solution.\n\nThe core of this problem is to devise and verify an efficient recursive algorithm for updating the history of the Finger strain tensor, $\\boldsymbol{B}(t,t')$, in a simulation employing an integral constitutive model like the K-BKZ model. The kinematics are restricted to simple shear.\n\n### 1. Derivation of the Recursive Update Rule\n\nThe temporal evolution of material deformation is captured by the relative deformation gradient, $\\boldsymbol{F}(t, t')$, which maps line elements from a past configuration at time $t'$ to the current configuration at time $t$. A fundamental property of deformation gradients is their composition rule. For any three times $t_j  t_n  t_{n+1}$, the deformation from $t_j$ to $t_{n+1}$ can be decomposed as:\n$$\n\\boldsymbol{F}(t_{n+1}, t_j) = \\boldsymbol{F}(t_{n+1}, t_n) \\boldsymbol{F}(t_n, t_j)\n$$\nHere, $\\boldsymbol{F}(t_{n+1}, t_n)$ is the incremental deformation gradient over the time interval $[t_n, t_{n+1}]$, which we denote as $\\Delta \\boldsymbol{F}_n$. The equation becomes:\n$$\n\\boldsymbol{F}(t_{n+1}, t_j) = \\Delta \\boldsymbol{F}_n \\, \\boldsymbol{F}(t_n, t_j)\n$$\nThe Finger strain tensor $\\boldsymbol{B}(t, t')$ is defined as $\\boldsymbol{B}(t,t') = \\boldsymbol{F}(t,t')\\,\\boldsymbol{F}^{\\mathsf{T}}(t,t')$. We can substitute the composition rule into the definition of $\\boldsymbol{B}(t_{n+1}, t_j)$:\n$$\n\\boldsymbol{B}(t_{n+1}, t_j) = \\left( \\Delta \\boldsymbol{F}_n \\, \\boldsymbol{F}(t_n, t_j) \\right) \\left( \\Delta \\boldsymbol{F}_n \\, \\boldsymbol{F}(t_n, t_j) \\right)^{\\mathsf{T}}\n$$\nUsing the property $(AB)^{\\mathsf{T}} = B^{\\mathsf{T}}A^{\\mathsf{T}}$, we get:\n$$\n\\boldsymbol{B}(t_{n+1}, t_j) = \\Delta \\boldsymbol{F}_n \\, \\boldsymbol{F}(t_n, t_j) \\, \\boldsymbol{F}^{\\mathsf{T}}(t_n, t_j) \\, \\Delta \\boldsymbol{F}_n^{\\mathsf{T}}\n$$\nRecognizing that $\\boldsymbol{F}(t_n, t_j) \\, \\boldsymbol{F}^{\\mathsf{T}}(t_n, t_j) = \\boldsymbol{B}(t_n, t_j)$, we arrive at the desired recursion:\n$$\n\\boldsymbol{B}(t_{n+1}, t_j) = \\Delta \\boldsymbol{F}_n \\, \\boldsymbol{B}(t_n, t_j) \\, \\Delta \\boldsymbol{F}_n^{\\mathsf{T}}\n$$\nThis equation allows us to compute the Finger tensor at time $t_{n+1}$ relative to any past time $t_j$ ($j  n$) by \"updating\" the corresponding tensor from the previous time step $t_n$ via pre- and post-multiplication with the incremental deformation gradient $\\Delta \\boldsymbol{F}_n$ and its transpose.\n\n### 2. Calculation of the Incremental Deformation Gradient\n\nTo use the recursion, we must determine the incremental deformation gradient $\\Delta \\boldsymbol{F}_n = \\boldsymbol{F}(t_{n+1}, t_n)$. It is the solution to the transport equation $\\frac{d}{dt}\\boldsymbol{F}(t,t_n) = \\boldsymbol{L}(t)\\,\\boldsymbol{F}(t,t_n)$ over the interval $t \\in [t_n, t_{n+1}]$ with the initial condition $\\boldsymbol{F}(t_n,t_n) = \\boldsymbol{I}$. For the specific case of simple shear, the velocity gradient tensor $\\boldsymbol{L}(t)$ has only one non-zero component, $L_{12}(t) = \\dot{\\gamma}(t)$:\n$$\n\\boldsymbol{L}(t) = \\begin{pmatrix} 0  \\dot{\\gamma}(t)  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix}\n$$\nA key property of this matrix is that for any two times $t_a$ and $t_b$, the commutator is zero: $[\\boldsymbol{L}(t_a), \\boldsymbol{L}(t_b)] = \\boldsymbol{L}(t_a)\\boldsymbol{L}(t_b) - \\boldsymbol{L}(t_b)\\boldsymbol{L}(t_a) = \\boldsymbol{0} - \\boldsymbol{0} = \\boldsymbol{0}$, because $\\boldsymbol{L}(t)^2 = \\boldsymbol{0}$. This commutativity simplifies the solution of the transport equation to a standard matrix exponential of the integral of $\\boldsymbol{L}(t)$:\n$$\n\\Delta \\boldsymbol{F}_n = \\boldsymbol{F}(t_{n+1}, t_n) = \\exp\\left(\\int_{t_n}^{t_{n+1}} \\boldsymbol{L}(s) \\, ds\\right)\n$$\nLet $\\Delta \\gamma_n = \\int_{t_n}^{t_{n+1}} \\dot{\\gamma}(s) \\, ds$ be the shear strain accumulated during the interval $[t_n, t_{n+1}]$. The integrated matrix is:\n$$\n\\int_{t_n}^{t_{n+1}} \\boldsymbol{L}(s) \\, ds = \\begin{pmatrix} 0  \\Delta \\gamma_n  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix} \\equiv \\boldsymbol{A}_n\n$$\nThe matrix $\\boldsymbol{A}_n$ is nilpotent of order $2$ (i.e., $\\boldsymbol{A}_n^2 = \\boldsymbol{0}$). The Taylor series for the matrix exponential, $\\exp(\\boldsymbol{A}_n) = \\boldsymbol{I} + \\boldsymbol{A}_n + \\frac{1}{2!}\\boldsymbol{A}_n^2 + \\dots$, thus terminates after the linear term:\n$$\n\\Delta \\boldsymbol{F}_n = \\exp(\\boldsymbol{A}_n) = \\boldsymbol{I} + \\boldsymbol{A}_n = \\begin{pmatrix} 1  \\Delta \\gamma_n  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix}\n$$\nThe problem specifies piecewise-constant shear rates for each step. Let $\\dot{\\gamma}_n$ be the constant shear rate over the interval $[t_{n-1}, t_n]$. The incremental shear strain is exactly $\\Delta \\gamma_{n-1} = \\dot{\\gamma}_n \\Delta t$.\n\n### 3. The Complete Recursive Algorithm\n\nAt each time step $t_n$ (for $n=1, \\dots, N$), we need to generate the set of historical tensors $\\{\\boldsymbol{B}(t_n, t_{n-k})\\}_{k=1}^n$. The algorithm proceeds as follows:\n1. Initialize an empty list, `history_B`, to store the tensors.\n2. For each step $n$ from $1$ to $N$:\n   a. Determine the incremental shear strain $\\Delta \\gamma_{n-1} = \\dot{\\gamma}_n \\Delta t$, where $\\dot{\\gamma}_n$ is the prescribed rate for step $n$.\n   b. Construct the incremental deformation gradient $\\Delta \\boldsymbol{F}_{n-1} = \\boldsymbol{F}(t_n, t_{n-1})$.\n   c. Create a new list for the updated history at time $t_n$.\n   d. For each existing tensor $\\boldsymbol{B}_{old} = \\boldsymbol{B}(t_{n-1}, t_j)$ in `history_B`, compute the updated tensor $\\boldsymbol{B}_{new} = \\Delta \\boldsymbol{F}_{n-1} \\, \\boldsymbol{B}_{old} \\, \\Delta \\boldsymbol{F}_{n-1}^{\\mathsf{T}}$ and add it to the new list. This updates $\\boldsymbol{B}(t_{n-1}, t_j)$ to $\\boldsymbol{B}(t_n, t_j)$.\n   e. Compute the newest history tensor, which corresponds to the most recent interval: $\\boldsymbol{B}(t_n, t_{n-1}) = \\Delta \\boldsymbol{F}_{n-1} \\, \\Delta \\boldsymbol{F}_{n-1}^{\\mathsf{T}}$.\n   f. Prepend this newest tensor to the new list.\n   g. Replace the old `history_B` with the new list.\n\nThis procedure efficiently updates the entire history by leveraging the results from the previous step, avoiding costly reintegration from $t_0$.\n\n### 4. Expression for Exact Validation\n\nFor validation, we compare the recursively computed tensors against a direct, exact calculation. The problem states that the exact calculation should be based on the total accumulated shear $\\Gamma(t,t')=\\int_{t'}^{t}\\dot{\\gamma}(s)\\,ds$.\nFollowing a similar derivation as for $\\Delta \\boldsymbol{F}_n$, the exact relative deformation gradient $\\boldsymbol{F}(t, t')$ is:\n$$\n\\boldsymbol{F}(t, t') = \\begin{pmatrix} 1  \\Gamma(t, t')  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix}\n$$\nFrom this, the exact Finger tensor $\\boldsymbol{B}(t, t')$ is:\n$$\n\\boldsymbol{B}(t, t') = \\boldsymbol{F}(t, t') \\boldsymbol{F}^{\\mathsf{T}}(t, t') = \\begin{pmatrix} 1  \\Gamma(t, t')  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix} \\begin{pmatrix} 1  0  0 \\\\ \\Gamma(t, t')  1  0 \\\\ 0  0  1 \\end{pmatrix}\n$$\n$$\n\\boldsymbol{B}(t, t') = \\begin{pmatrix} 1 + \\Gamma(t, t')^2  \\Gamma(t, t')  0 \\\\ \\Gamma(t, t')  1  0 \\\\ 0  0  1 \\end{pmatrix}\n$$\nFor a piecewise-constant shear rate schedule where $\\dot{\\gamma}_i$ is the rate for the interval $[t_{i-1}, t_i]$, the total shear between $t_j$ and $t_n$ ($jn$) is calculated by summation:\n$$\n\\Gamma(t_n, t_j) = \\sum_{i=j+1}^{n} \\int_{t_{i-1}}^{t_i} \\dot{\\gamma}(s) \\, ds = \\sum_{i=j+1}^{n} \\dot{\\gamma}_i \\Delta t\n$$\n\n### 5. Error Quantification\n\nFor all test cases, the shear rate $\\dot{\\gamma}(t)$ is defined as being piecewise-constant over each discrete time step $\\Delta t$. Under this condition, the integral for the incremental shear strain $\\Delta \\gamma_{n-1} = \\int_{t_{n-1}}^{t_n} \\dot{\\gamma}(s) \\, ds$ is evaluated exactly as $\\dot{\\gamma}_n \\Delta t$. Consequently, the incremental deformation gradient $\\Delta \\boldsymbol{F}_{n-1}$ used in the recursive algorithm is exact. Since the recursion relation itself is exact, the recursively computed tensors $\\boldsymbol{B}_{rec}(t_n, t_j)$ must be mathematically identical to the tensors computed via the \"exact\" validation formula, $\\boldsymbol{B}_{exact}(t_n, t_j)$. Any observed difference will be attributable solely to floating-point arithmetic precision errors, which are expected to be on the order of machine epsilon. The algorithm will compute the maximum absolute entrywise difference over all tensors at all time steps for each case.",
            "answer": "```python\nimport numpy as np\nimport math\n\n# Per the problem constraints, scipy is permitted but not required for this solution.\n# The calculations can be performed entirely with numpy.\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n\n    def get_case_1_schedule(N, dt):\n        return [2.0] * N\n\n    def get_case_2_schedule(N, dt):\n        omega = 1.0\n        # The rate for step n (interval [t_{n-1}, t_n]) is evaluated at t_n.\n        return [1.5 * math.sin(omega * n * dt) for n in range(1, N + 1)]\n\n    def get_case_3_schedule(N, dt):\n        return [3.0]*5 + [-3.0]*5 + [0.0]*5 + [1.0]*5\n\n    def get_case_4_schedule(N, dt):\n        return [0.0, 0.0, 5.0, -5.0, 2.5, -2.5]\n\n    test_cases = [\n        # (dt, N, schedule_generator_function)\n        (0.25, 8, get_case_1_schedule),\n        (0.05, 40, get_case_2_schedule),\n        (0.10, 20, get_case_3_schedule),\n        (0.50, 6, get_case_4_schedule),\n    ]\n\n    results = []\n    for dt, N, schedule_func in test_cases:\n        gamma_dot_schedule = schedule_func(N, dt)\n        max_abs_error = run_simulation_and_validate(dt, N, gamma_dot_schedule)\n        results.append(max_abs_error)\n\n    # Format output as specified: [r1,r2,r3,r4]\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation_and_validate(dt, N, gamma_dot_schedule):\n    \"\"\"\n    Performs the recursive update and validation for a single test case.\n\n    Args:\n        dt (float): The uniform time step size.\n        N (int): The total number of steps.\n        gamma_dot_schedule (list[float]): The piecewise-constant shear rate for each step.\n\n    Returns:\n        float: The maximum absolute entrywise error found during the simulation.\n    \"\"\"\n    max_total_error = 0.0\n    \n    # B_hist_rec stores [B(t_n, t_{n-1}), B(t_n, t_{n-2}), ..., B(t_n, t_0)]\n    B_hist_rec = []\n\n    for n in range(1, N + 1):  # Loop over time steps from t_1 to t_N\n        # Rate for the current step n (interval [t_{n-1}, t_n])\n        gamma_dot_val = gamma_dot_schedule[n - 1]\n        delta_gamma = gamma_dot_val * dt\n\n        # -- Recursive Update --\n        # Incremental deformation gradient F(t_n, t_{n-1})\n        delta_F = np.array([[1.0, delta_gamma, 0.0],\n                              [0.0, 1.0, 0.0],\n                              [0.0, 0.0, 1.0]])\n\n        # Update all previously existing history tensors\n        B_hist_rec_new = [delta_F @ B_old @ delta_F.T for B_old in B_hist_rec]\n\n        # Compute and add the newest history tensor B(t_n, t_{n-1})\n        B_newest = delta_F @ delta_F.T\n        B_hist_rec_new.insert(0, B_newest)\n        \n        B_hist_rec = B_hist_rec_new\n\n        # -- Exact Calculation for Validation at time t_n --\n        B_hist_exact_n = []\n        for k in range(1, n + 1):  # k is the history lag-index, from 1 to n\n            # past_time_index j, from n-1 down to 0\n            j = n - k\n            \n            # Calculate total shear Gamma(t_n, t_j)\n            # Sum rate contributions from step j+1 to step n\n            Gamma_tn_tj = sum(gamma_dot_schedule[i - 1] for i in range(j + 1, n + 1)) * dt\n            \n            # Construct exact Finger tensor B(t_n, t_j)\n            B_exact = np.array([[1.0 + Gamma_tn_tj**2, Gamma_tn_tj, 0.0],\n                                  [Gamma_tn_tj, 1.0, 0.0],\n                                  [0.0, 0.0, 1.0]])\n            B_hist_exact_n.append(B_exact)\n\n        # -- Compare recursive vs exact and update max error --\n        # The lists B_hist_rec and B_hist_exact_n both store tensors\n        # ordered from newest (k=1) to oldest (k=n).\n        for B_rec, B_exact in zip(B_hist_rec, B_hist_exact_n):\n            error = np.max(np.abs(B_rec - B_exact))\n            if error  max_total_error:\n                max_total_error = error\n                \n    return max_total_error\n\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        }
    ]
}