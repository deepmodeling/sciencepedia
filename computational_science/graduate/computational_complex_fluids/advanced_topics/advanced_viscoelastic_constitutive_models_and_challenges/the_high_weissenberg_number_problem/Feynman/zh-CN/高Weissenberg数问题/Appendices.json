{
    "hands_on_practices": [
        {
            "introduction": "在深入研究数值解法之前，理解粘弹性本构模型的解析行为至关重要。本练习将引导你推导 Oldroyd-B 模型在简单剪切流中的稳态应力分量。通过这个基础推导，你将揭示应力如何随韦森伯格数（Weissenberg number）$Wi$ 的变化而变化，从而从根本上理解“高韦森伯格数难题”的物理起源。",
            "id": "4107507",
            "problem": "一种稀聚合物溶液由其动力学理论形式的 Oldroyd-B 本构方程来模拟。聚合物附加应力张量 $\\boldsymbol{\\tau}_{p}$ 与构象张量 $\\boldsymbol{A}$ 的关系为 $\\boldsymbol{\\tau}_{p} = G \\left( \\boldsymbol{A} - \\boldsymbol{I} \\right)$，其中 $G$ 是聚合物弹性模量，$\\boldsymbol{I}$ 是单位张量。构象张量 $\\boldsymbol{A}$ 遵循上随体演化方程 $\\overset{\\triangledown}{\\boldsymbol{A}} = - \\frac{1}{\\lambda} \\left( \\boldsymbol{A} - \\boldsymbol{I} \\right)$，其中 $\\lambda$ 是聚合物松弛时间，$\\overset{\\triangledown}{(\\cdot)}$ 表示上随体导数。考虑一个速度场为 $\\boldsymbol{v} = \\left( \\dot{\\gamma} y, 0, 0 \\right)$ 的均匀、稳态简单剪切流，其中 $\\dot{\\gamma}$ 是恒定的剪切速率。仅使用这些基本定义和基本张量微积分，推导稳态聚合物剪切应力分量 $\\tau_{p,12}$ 的解析表达式，并根据 Weissenberg 数 $\\mathrm{Wi} = \\lambda \\dot{\\gamma}$，论证在该流场中 $\\tau_{p,12}$ 如何随 $\\mathrm{Wi}$ 标度变化。将您的最终结果以 $G$ 和 $\\mathrm{Wi}$ 表示的 $\\tau_{p,12}$ 的闭式解析表达式的形式给出。无需进行数值计算。以无单位表达式的形式陈述您的答案。",
            "solution": "用户希望我解决以下问题：\n一种稀聚合物溶液由其动力学理论形式的 Oldroyd-B 本构方程来模拟。聚合物附加应力张量 $\\boldsymbol{\\tau}_{p}$ 与构象张量 $\\boldsymbol{A}$ 的关系为 $\\boldsymbol{\\tau}_{p} = G \\left( \\boldsymbol{A} - \\boldsymbol{I} \\right)$，其中 $G$ 是聚合物弹性模量，$\\boldsymbol{I}$ 是单位张量。构象张量 $\\boldsymbol{A}$ 遵循上随体演化方程 $\\overset{\\triangledown}{\\boldsymbol{A}} = - \\frac{1}{\\lambda} \\left( \\boldsymbol{A} - \\boldsymbol{I} \\right)$，其中 $\\lambda$ 是聚合物松弛时间，$\\overset{\\triangledown}{(\\cdot)}$ 表示上随体导数。考虑一个速度场为 $\\boldsymbol{v} = \\left( \\dot{\\gamma} y, 0, 0 \\right)$ 的均匀、稳态简单剪切流，其中 $\\dot{\\gamma}$ 是恒定的剪切速率。仅使用这些基本定义和基本张量微积分，推导稳态聚合物剪切应力分量 $\\tau_{p,12}$ 的解析表达式，并根据 Weissenberg 数 $\\mathrm{Wi} = \\lambda \\dot{\\gamma}$，论证在该流场中 $\\tau_{p,12}$ 如何随 $\\mathrm{Wi}$ 标度变化。将您的最终结果以 $G$ 和 $\\mathrm{Wi}$ 表示的 $\\tau_{p,12}$ 的闭式解析表达式的形式给出。无需进行数值计算。以无单位表达式的形式陈述您的答案。\n\n### 步骤1：提取已知条件\n- 聚合物附加应力张量：$\\boldsymbol{\\tau}_{p} = G \\left( \\boldsymbol{A} - \\boldsymbol{I} \\right)$\n- $G$：聚合物弹性模量\n- $\\boldsymbol{A}$：构象张量\n- $\\boldsymbol{I}$：单位张量\n- 构象张量演化方程：$\\overset{\\triangledown}{\\boldsymbol{A}} = - \\frac{1}{\\lambda} \\left( \\boldsymbol{A} - \\boldsymbol{I} \\right)$\n- $\\lambda$：聚合物松弛时间\n- $\\overset{\\triangledown}{(\\cdot)}$：上随体导数\n- 均匀、稳态简单剪切流的速度场：$\\boldsymbol{v} = \\left( \\dot{\\gamma} y, 0, 0 \\right)$\n- $\\dot{\\gamma}$：恒定剪切速率\n- Weissenberg 数：$\\mathrm{Wi} = \\lambda \\dot{\\gamma}$\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学依据**：该问题描述了 Oldroyd-B 模型，这是流变学中用于描述粘弹性流体（特别是表示为胡克哑铃的稀聚合物溶液）的一个基本且广泛使用的本构模型。应力方程和构象张量的演化方程都是标准的。简单剪切流是材料表征的典型流场。Weissenberg 数的定义是正确的。所有前提都基于连续介质力学和聚合物动力学理论的既定原理。\n- **适定性**：该问题提供了确定应力张量分量唯一解所需的所有必要方程、定义和条件（稳态、均匀流）。任务具体且可回答。\n- **客观性**：该问题以精确的数学语言陈述，没有主观或含糊的术语。\n- **完整性与一致性**：所提供的信息是自洽且一致的。没有遗漏任何基本数据。\n- **与主题的相关性**：该问题是粘弹性本构模型研究中的一个核心练习，直接探讨了应力作为 Weissenberg 数的函数其行为，这对于理解计算流体动力学中的高 Weissenberg 数问题 (HWNP) 至关重要。\n\n### 步骤3：结论与行动\n该问题科学上合理，适定，客观且完整。它是非牛顿流体力学领域中的一个有效问题。我将继续进行求解。\n\n该问题要求推导稳态聚合物剪切应力 $\\tau_{p,12}$。这需要从在指定流动条件下求解构象张量 $\\boldsymbol{A}$ 的演化方程开始。\n\n像构象张量 $\\boldsymbol{A}$ 这样的逆变二阶张量的上随体导数定义为：\n$$\n\\overset{\\triangledown}{\\boldsymbol{A}} = \\frac{D\\boldsymbol{A}}{Dt} - \\boldsymbol{L}\\boldsymbol{A} - \\boldsymbol{A}\\boldsymbol{L}^{T}\n$$\n其中 $\\frac{D\\boldsymbol{A}}{Dt} = \\frac{\\partial \\boldsymbol{A}}{\\partial t} + \\boldsymbol{v} \\cdot \\nabla \\boldsymbol{A}$ 是物质导数，$\\boldsymbol{L} = \\nabla \\boldsymbol{v}$ 是速度梯度张量。\n\n问题指定了稳态和均匀流动。对于稳态流，偏时间导数为零：$\\frac{\\partial \\boldsymbol{A}}{\\partial t} = \\boldsymbol{0}$。对于均匀流动，所有场在空间上都是均匀的，这意味着构象张量 $\\boldsymbol{A}$ 不是位置的函数。因此，物质导数的对流部分也为零：$\\boldsymbol{v} \\cdot \\nabla \\boldsymbol{A} = \\boldsymbol{0}$。\n这将上随体导数简化为：\n$$\n\\overset{\\triangledown}{\\boldsymbol{A}} = - \\boldsymbol{L}\\boldsymbol{A} - \\boldsymbol{A}\\boldsymbol{L}^{T}\n$$\n将此代入给定的演化方程 $\\overset{\\triangledown}{\\boldsymbol{A}} = - \\frac{1}{\\lambda} \\left( \\boldsymbol{A} - \\boldsymbol{I} \\right)$，我们得到：\n$$\n- \\boldsymbol{L}\\boldsymbol{A} - \\boldsymbol{A}\\boldsymbol{L}^{T} = - \\frac{1}{\\lambda} \\left( \\boldsymbol{A} - \\boldsymbol{I} \\right)\n$$\n两边乘以 $-\\lambda$ 可得：\n$$\n\\lambda \\left( \\boldsymbol{L}\\boldsymbol{A} + \\boldsymbol{A}\\boldsymbol{L}^{T} \\right) = \\boldsymbol{A} - \\boldsymbol{I}\n$$\n这是一个关于张量 $\\boldsymbol{A}$ 的代数方程。\n\n接下来，我们为给定的速度场 $\\boldsymbol{v} = (v_1, v_2, v_3) = (\\dot{\\gamma} y, 0, 0)$ 确定速度梯度张量 $\\boldsymbol{L}$。$\\boldsymbol{L}$ 的分量是 $L_{ij} = \\frac{\\partial v_i}{\\partial x_j}$，其中 $(x_1, x_2, x_3) = (x, y, z)$。\n$$\n\\boldsymbol{L} = \\nabla \\boldsymbol{v} = \\begin{pmatrix}\n\\frac{\\partial v_1}{\\partial x}  \\frac{\\partial v_1}{\\partial y}  \\frac{\\partial v_1}{\\partial z} \\\\\n\\frac{\\partial v_2}{\\partial x}  \\frac{\\partial v_2}{\\partial y}  \\frac{\\partial v_2}{\\partial z} \\\\\n\\frac{\\partial v_3}{\\partial x}  \\frac{\\partial v_3}{\\partial y}  \\frac{\\partial v_3}{\\partial z}\n\\end{pmatrix} = \\begin{pmatrix}\n0  \\dot{\\gamma}  0 \\\\\n0  0  0 \\\\\n0  0  0\n\\end{pmatrix}\n$$\n$\\boldsymbol{L}$ 的转置是：\n$$\n\\boldsymbol{L}^{T} = \\begin{pmatrix}\n0  0  0 \\\\\n\\dot{\\gamma}  0  0 \\\\\n0  0  0\n\\end{pmatrix}\n$$\n我们现在计算 $\\boldsymbol{L}\\boldsymbol{A}$ 和 $\\boldsymbol{A}\\boldsymbol{L}^{T}$ 项。构象张量 $\\boldsymbol{A}$ 是对称的，所以 $A_{ij} = A_{ji}$。\n$$\n\\boldsymbol{L}\\boldsymbol{A} = \\begin{pmatrix}\n0  \\dot{\\gamma}  0 \\\\\n0  0  0 \\\\\n0  0  0\n\\end{pmatrix} \\begin{pmatrix}\nA_{11}  A_{12}  A_{13} \\\\\nA_{12}  A_{22}  A_{23} \\\\\nA_{13}  A_{23}  A_{33}\n\\end{pmatrix} = \\begin{pmatrix}\nA_{12}\\dot{\\gamma}  A_{22}\\dot{\\gamma}  A_{23}\\dot{\\gamma} \\\\\n0  0  0 \\\\\n0  0  0\n\\end{pmatrix}\n$$\n$$\n\\boldsymbol{A}\\boldsymbol{L}^{T} = \\begin{pmatrix}\nA_{11}  A_{12}  A_{13} \\\\\nA_{12}  A_{22}  A_{23} \\\\\nA_{13}  A_{23}  A_{33}\n\\end{pmatrix} \\begin{pmatrix}\n0  0  0 \\\\\n\\dot{\\gamma}  0  0 \\\\\n0  0  0\n\\end{pmatrix} = \\begin{pmatrix}\nA_{12}\\dot{\\gamma}  0  0 \\\\\nA_{22}\\dot{\\gamma}  0  0 \\\\\nA_{23}\\dot{\\gamma}  0  0\n\\end{pmatrix}\n$$\n和为：\n$$\n\\boldsymbol{L}\\boldsymbol{A} + \\boldsymbol{A}\\boldsymbol{L}^{T} = \\begin{pmatrix}\n2A_{12}\\dot{\\gamma}  A_{22}\\dot{\\gamma}  A_{23}\\dot{\\gamma} \\\\\nA_{22}\\dot{\\gamma}  0  0 \\\\\nA_{23}\\dot{\\gamma}  0  0\n\\end{pmatrix}\n$$\n现在，将此代入重新排列的演化方程 $\\boldsymbol{A} - \\boldsymbol{I} = \\lambda \\left( \\boldsymbol{L}\\boldsymbol{A} + \\boldsymbol{A}\\boldsymbol{L}^{T} \\right)$，并引入 Weissenberg 数 $\\mathrm{Wi} = \\lambda \\dot{\\gamma}$：\n$$\n\\begin{pmatrix}\nA_{11}-1  A_{12}  A_{13} \\\\\nA_{12}  A_{22}-1  A_{23} \\\\\nA_{13}  A_{23}  A_{33}-1\n\\end{pmatrix} = \\mathrm{Wi} \\begin{pmatrix}\n2A_{12}  A_{22}  A_{23} \\\\\nA_{22}  0  0 \\\\\nA_{23}  0  0\n\\end{pmatrix}\n$$\n这个矩阵方程产生了一个关于 $\\boldsymbol{A}$ 各分量的线性代数方程组：\n\\begin{itemize}\n    \\item $(3,3)$：$A_{33}-1 = \\mathrm{Wi}(0) \\implies A_{33} = 1$\n    \\item $(2,3)$：$A_{23} = \\mathrm{Wi}(0) \\implies A_{23} = 0$\n    \\item $(1,3)$：$A_{13} = \\mathrm{Wi}(A_{23}) = \\mathrm{Wi}(0) \\implies A_{13} = 0$\n    \\item $(2,2)$：$A_{22}-1 = \\mathrm{Wi}(0) \\implies A_{22} = 1$\n    \\item $(1,2)$：$A_{12} = \\mathrm{Wi}(A_{22}) = \\mathrm{Wi}(1) \\implies A_{12} = \\mathrm{Wi}$\n    \\item $(1,1)$：$A_{11}-1 = \\mathrm{Wi}(2A_{12}) = \\mathrm{Wi}(2\\mathrm{Wi}) \\implies A_{11} = 1 + 2\\mathrm{Wi}^2$\n\\end{itemize}\n因此，稳态构象张量为：\n$$\n\\boldsymbol{A} = \\begin{pmatrix}\n1 + 2\\mathrm{Wi}^2  \\mathrm{Wi}  0 \\\\\n\\mathrm{Wi}  1  0 \\\\\n0  0  1\n\\end{pmatrix}\n$$\n问题要求聚合物附加应力张量分量 $\\tau_{p,12}$。我们使用给定的关系 $\\boldsymbol{\\tau}_{p} = G \\left( \\boldsymbol{A} - \\boldsymbol{I} \\right)$：\n$$\n\\boldsymbol{\\tau}_{p} = G \\left( \\begin{pmatrix}\n1 + 2\\mathrm{Wi}^2  \\mathrm{Wi}  0 \\\\\n\\mathrm{Wi}  1  0 \\\\\n0  0  1\n\\end{pmatrix} - \\begin{pmatrix}\n1  0  0 \\\\\n0  1  0 \\\\\n0  0  1\n\\end{pmatrix} \\right) = G \\begin{pmatrix}\n2\\mathrm{Wi}^2  \\mathrm{Wi}  0 \\\\\n\\mathrm{Wi}  0  0 \\\\\n0  0  0\n\\end{pmatrix}\n$$\n从得到的这个应力张量中，我们可以直接将剪切应力分量 $\\tau_{p,12}$ 识别为 $(1,2)$ 元素：\n$$\n\\tau_{p,12} = G \\, \\mathrm{Wi}\n$$\n这就是聚合物剪切应力的闭式解析表达式。\n\n问题还要求论证 $\\tau_{p,12}$ 如何随 $\\mathrm{Wi}$ 标度变化。推导出的表达式 $\\tau_{p,12} = G \\, \\mathrm{Wi}$ 表明，聚合物剪切应力与 Weissenberg 数成正比且线性相关。随着 $\\mathrm{Wi}$ 的增加，$\\tau_{p,12}$ 无界增长。这种线性标度关系与第一法向应力差 $N_1 = \\tau_{p,11} - \\tau_{p,22} = G(2\\mathrm{Wi}^2) - G(0) = 2G\\mathrm{Wi}^2$ 形成对比，后者随 $\\mathrm{Wi}$ 呈二次方标度变化。在高 $\\mathrm{Wi}$ 下应力张量分量的无界增长是 Oldroyd-B 模型的一个典型特征，也是粘弹性流模拟中被称为高 Weissenberg 数问题 (HWNP) 的数值不稳定性的主要原因。具体到剪切应力，其标度关系是线性的。",
            "answer": "$$\n\\boxed{G \\, \\mathrm{Wi}}\n$$"
        },
        {
            "introduction": "解析解中揭示的应力无限增长在数值模拟中表现为不稳定性，其中一个典型的失效模式是构象张量（conformation tensor）失去其物理上必须满足的对称正定（Symmetric Positive-Definite, SPD）特性。这个编程练习将指导你构建一个实用的算法，用于在时间推进过程中检测并修正这种失效。掌握这种方法是开发稳健的粘弹性流体求解器的基本功。",
            "id": "4107555",
            "problem": "考虑在均匀流场中聚合物构象张量 $\\mathbf{A}$ 的演化，该演化由不含平流项的 Oldroyd-B 模型的上随流导数形式控制。Weissenberg 数（高 Weissenberg 数问题 (HWNP)）用于量化弹性，其定义为 $ \\mathrm{We} = \\lambda U / L $，其中 $ \\lambda $ 是弛豫时间，$ U $ 是特征速度，$ L $ 是特征长度。在无量纲和空间均匀的条件下，构象张量 $ \\mathbf{A} $ 服从以下连续时间演化方程\n$$\n\\frac{\\mathrm{d}\\mathbf{A}}{\\mathrm{d}t} - \\mathbf{L}\\mathbf{A} - \\mathbf{A}\\mathbf{L}^{\\top} = -\\frac{1}{\\mathrm{We}}\\left(\\mathbf{A} - \\mathbf{I}\\right),\n$$\n其中 $ \\mathbf{L} $ 是无量纲速度梯度张量，$ \\mathbf{I} $ 是单位张量。物理上允许的构象张量必须是对称正定 (Symmetric Positive Definite, SPD) 的，即 $ \\mathbf{A} = \\mathbf{A}^{\\top} $ 且 $ \\mathbf{A} $ 的所有特征值都严格为正。\n\n对于大小为 $ \\Delta t $ 的单步，一阶显式欧拉时间离散给出如下离散更新\n$$\n\\mathbf{A}^{n+1} = \\mathbf{A}^{n} + \\Delta t \\left( \\mathbf{L}\\mathbf{A}^{n} + \\mathbf{A}^{n}\\mathbf{L}^{\\top} - \\frac{1}{\\mathrm{We}}\\left(\\mathbf{A}^{n} - \\mathbf{I}\\right) \\right).\n$$\n当 $ \\mathrm{We} $ 较大和/或 $ \\Delta t $ 较大时（即高 Weissenberg 数问题），这种朴素的离散化方法可能会违反 SPD 条件，从而产生不符合物理规律的状态。\n\n您的任务是基于上述离散更新和对称正定矩阵的数学定义，实现以下功能：\n\n- 构建一个测试，在每个时间步通过检查以下两点来验证 SPD 条件：\n  1. 通过斜对称部分的矩阵范数检查对称性是否在容差 $ \\tau $ 内。\n  2. 通过最小特征值是否超过阈值 $ \\delta $ 来检查特征值的正性。\n- 当 SPD 条件被违反时，应用一种修正策略，通过以下步骤生成（在 Frobenius 范数意义下）最近的 SPD 矩阵：\n  1. 通过 $ \\mathbf{B} = \\frac{1}{2}\\left(\\mathbf{A} + \\mathbf{A}^{\\top}\\right) $ 对张量进行对称化。\n  2. 计算谱分解 $ \\mathbf{B} = \\mathbf{Q}\\boldsymbol{\\Lambda}\\mathbf{Q}^{\\top} $，其中 $ \\mathbf{Q} $ 是正交矩阵，$ \\boldsymbol{\\Lambda} $ 是对角矩阵。\n  3. 通过将 $ \\lambda_i $ 替换为 $ \\max(\\lambda_i, \\delta) $ 来裁剪低于 $ \\delta $ 的特征值。\n  4. 重构 $ \\mathbf{A}_{\\mathrm{corr}} = \\mathbf{Q}\\boldsymbol{\\Lambda}_{\\mathrm{clipped}}\\mathbf{Q}^{\\top} $。\n\n实现一个程序，该程序：\n- 初始化 $ \\mathbf{A}^{0} = \\mathbf{I} $。\n- 对每个测试用例，迭代显式更新 $ N $ 步，在每一步应用 SPD 测试，必要时进行修正，并记录：\n  1. 在 $ N $ 步中应用的总修正次数（一个整数）。\n  2. 所有时间步中，修正前的最小特征值的最小值（一个浮点数）。\n  3. 所有时间步中，修正后的最小特征值的最小值（一个浮点数）。\n\n所有量均为无量纲；不需要物理单位。不使用角度。所有报告的数值输出必须是标准的浮点值。\n\n使用以下测试套件（每个测试用例提供 $ \\mathbf{L} $ 作为 $ 3 \\times 3 $ 矩阵，$ \\mathrm{We} $ 作为正标量，$ \\Delta t $ 作为正标量，$ N $ 作为正整数步数，以及 SPD 容差 $ \\tau $ 和 $ \\delta $ 作为正标量）：\n\n- 测试用例 $ 1 $（理想情况，中等弹性和小时间步）：\n  - $ \\mathbf{L} = \\mathrm{diag}(1.0, -0.5, -0.5) $。\n  - $ \\mathrm{We} = 1.0 $。\n  - $ \\Delta t = 0.01 $。\n  - $ N = 20 $。\n  - $ \\tau = 10^{-12} $。\n  - $ \\delta = 10^{-10} $。\n- 测试用例 $ 2 $（边界情况，较大弹性和中等时间步）：\n  - $$ \\mathbf{L} = \\begin{bmatrix} 0.0  1.0  0.0 \\\\ 0.0  0.0  1.0 \\\\ -1.0  0.0  0.0 \\end{bmatrix} $$\n  - $ \\mathrm{We} = 10.0 $。\n  - $ \\Delta t = 0.05 $。\n  - $ N = 20 $。\n  - $ \\tau = 10^{-12} $。\n  - $ \\delta = 10^{-10} $。\n- 测试用例 $ 3 $（边缘情况，强弹性和大时间步）：\n  - $ \\mathbf{L} = \\mathrm{diag}(2.0, -1.0, -1.0) $。\n  - $ \\mathrm{We} = 50.0 $。\n  - $ \\Delta t = 0.2 $。\n  - $ N = 10 $。\n  - $ \\tau = 10^{-12} $。\n  - $ \\delta = 10^{-10} $。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。每个测试用例对应一个三元素列表 $ [n_{\\mathrm{corr}}, m_{\\mathrm{pre}}, m_{\\mathrm{post}}] $，其中包含：\n- $ n_{\\mathrm{corr}} $: 在 $ N $ 步中应用的总修正次数（一个整数），\n- $ m_{\\mathrm{pre}} $: 所有时间步中，修正前的最小特征值的最小值（一个浮点数），\n- $ m_{\\mathrm{post}} $: 所有时间步中，修正后的最小特征值的最小值（一个浮点数）。\n\n例如，输出格式必须类似于 $ [[n_1,m_1^{\\mathrm{pre}},m_1^{\\mathrm{post}}],[n_2,m_2^{\\mathrm{pre}},m_2^{\\mathrm{post}}],[n_3,m_3^{\\mathrm{pre}},m_3^{\\mathrm{post}}]] $，不含任何额外文本。",
            "solution": "用户提供的问题是有效的。它在计算流变学领域有科学依据，问题定义明确、客观，并包含了进行求解所需的所有必要信息。\n\n目标是使用一阶显式欧拉方法，为 Oldroyd-B 模型模拟聚合物构象张量 $\\mathbf{A}$ 的时间演化。已知该数值格式在高 Weissenberg 数 ($\\mathrm{We}$) 或大时间步 ($\\Delta t$) 时不稳定，可能会违反 $\\mathbf{A}$ 必须为对称正定 (SPD) 矩阵的物理约束。该任务涉及实现一个数值算法，该算法对解进行时间迭代，在每一步检查是否违反 SPD 属性，并在发生违反时应用特定的修正程序。算法的性能将通过跟踪修正次数以及在修正程序前后观察到的最小特征值来量化。\n\n在空间均匀流中，构象张量 $\\mathbf{A}$ 的演化由以下方程控制：\n$$\n\\frac{\\mathrm{d}\\mathbf{A}}{\\mathrm{d}t} = \\mathbf{L}\\mathbf{A} + \\mathbf{A}\\mathbf{L}^{\\top} - \\frac{1}{\\mathrm{We}}\\left(\\mathbf{A} - \\mathbf{I}\\right)\n$$\n其中 $\\mathbf{L}$ 是速度梯度张量，$\\mathrm{We}$ 是 Weissenberg 数，$\\mathbf{I}$ 是单位张量。\n\n待实现的算法如下：\n\n1.  **初始化**：对每个测试用例，我们从聚合物处于平衡状态开始，因此构象张量初始化为单位矩阵 $\\mathbf{A}^0 = \\mathbf{I}$。我们还将修正计数器 $n_{\\mathrm{corr}}$ 初始化为 $0$，并将用于跟踪修正前和修正后最小特征值的变量 $m_{\\mathrm{pre}}$ 和 $m_{\\mathrm{post}}$ 初始化为正无穷大。\n\n2.  **时间迭代**：我们从 $n=0$ 到 $N-1$ 共迭代 $N$ 个时间步。在第 $n$ 步中，我们执行以下子步骤：\n\n    a. **显式欧拉更新**：我们使用一阶显式欧拉离散计算下一个时间步的暂定构象张量 $\\mathbf{A}_{\\mathrm{tent}}^{n+1}$：\n    $$\n    \\mathbf{A}_{\\mathrm{tent}}^{n+1} = \\mathbf{A}^{n} + \\Delta t \\left( \\mathbf{L}\\mathbf{A}^{n} + \\mathbf{A}^{n}\\mathbf{L}^{\\top} - \\frac{1}{\\mathrm{We}}\\left(\\mathbf{A}^{n} - \\mathbf{I}\\right) \\right)\n    $$\n    \n    b. **SPD 条件测试**：我们检查 $\\mathbf{A}_{\\mathrm{tent}}^{n+1}$ 是否满足 SPD 条件。一个矩阵若为对称且其所有特征值均为正，则为 SPD 矩阵。该测试包含两个部分：\n        i. **对称性检查**：从解析上看，如果 $\\mathbf{A}^n$ 是对称的，那么 $\\mathbf{A}_{\\mathrm{tent}}^{n+1}$ 也应该是对称的。然而，浮点运算可能会引入微小的不对称性。我们通过计算张量斜对称部分 $\\|\\frac{1}{2}(\\mathbf{A}_{\\mathrm{tent}}^{n+1} - (\\mathbf{A}_{\\mathrm{tent}}^{n+1})^{\\top})\\|_F$ 的 Frobenius 范数来检查这一点。如果此范数大于或等于给定的容差 $\\tau$，则认为对称性条件被违反。\n        ii. **正定性检查**：我们计算 $\\mathbf{A}_{\\mathrm{tent}}^{n+1}$ 对称部分的特征值。设这些特征值的最小值为 $\\lambda_{\\min}^{\\mathrm{pre}}$。记录该值以更新全局修正前最小特征值 $m_{\\mathrm{pre}} = \\min(m_{\\mathrm{pre}}, \\lambda_{\\min}^{\\mathrm{pre}})$。如果 $\\lambda_{\\min}^{\\mathrm{pre}}$ 小于或等于给定的阈值 $\\delta$，则认为正定性条件被违反。\n\n    c. **修正程序**：如果 SPD 测试的任何一部分失败，我们应用修正以找到在 Frobenius 范数意义下与 $\\mathbf{A}_{\\mathrm{tent}}^{n+1}$ 最接近的 SPD 矩阵。\n        i. 增加修正计数器 $n_{\\mathrm{corr}}$。\n        ii. 对称化张量：$\\mathbf{B} = \\frac{1}{2}(\\mathbf{A}_{\\mathrm{tent}}^{n+1} + (\\mathbf{A}_{\\mathrm{tent}}^{n+1})^{\\top})$。\n        iii. 计算 $\\mathbf{B}$ 的谱分解，以获得其特征值 $\\lambda_i$ 和对应的特征向量（构成正交矩阵 $\\mathbf{Q}$ 的列）。这表示为 $\\mathbf{B} = \\mathbf{Q}\\boldsymbol{\\Lambda}\\mathbf{Q}^{\\top}$，其中 $\\boldsymbol{\\Lambda}$ 是特征值构成的对角矩阵。\n        iv. 裁剪任何低于阈值 $\\delta$ 的特征值。形成一个新的对角矩阵 $\\boldsymbol{\\Lambda}_{\\mathrm{clipped}}$，其对角线元素为 $\\lambda'_i = \\max(\\lambda_i, \\delta)$。\n        v. 重构修正后的张量：$\\mathbf{A}^{n+1} = \\mathbf{Q}\\boldsymbol{\\Lambda}_{\\mathrm{clipped}}\\mathbf{Q}^{\\top}$。\n        \n    d. **状态更新**：如果 SPD 测试通过，则下一步的状态就是暂定张量：$\\mathbf{A}^{n+1} = \\mathbf{A}_{\\mathrm{tent}}^{n+1}$。如果测试失败，$\\mathbf{A}^{n+1}$ 是上一步得到的修正后张量。\n\n    e. **修正后分析**：我们找到当前步骤最终张量 $\\mathbf{A}^{n+1}$ 的最小特征值，记为 $\\lambda_{\\min}^{\\mathrm{post}}$。根据构造，如果应用了修正，$\\lambda_{\\min}^{\\mathrm{post}}$ 将至少为 $\\delta$。该值用于更新整个模拟过程中的修正后最小特征值 $m_{\\mathrm{post}} = \\min(m_{\\mathrm{post}}, \\lambda_{\\min}^{\\mathrm{post}})$。\n\n3.  **结果汇总**：在 $N$ 步之后，报告给定测试用例的 $n_{\\mathrm{corr}}$、$m_{\\mathrm{pre}}$ 和 $m_{\\mathrm{post}}$ 的最终值。对所有提供的测试用例重复此整个过程。\n\n此过程在使用一个简单但可能不稳定的时间步进格式的同时，严格执行了模型的物理约束，从而展示了一种在数值模拟中处理高 Weissenberg 数问题的实用方法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Oldroyd-B conformation tensor evolution problem for a set of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"L\": np.diag([1.0, -0.5, -0.5]),\n            \"We\": 1.0,\n            \"dt\": 0.01,\n            \"N\": 20,\n            \"tau\": 1e-12,\n            \"delta\": 1e-10,\n        },\n        {\n            \"L\": np.array([[0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [-1.0, 0.0, 0.0]]),\n            \"We\": 10.0,\n            \"dt\": 0.05,\n            \"N\": 20,\n            \"tau\": 1e-12,\n            \"delta\": 1e-10,\n        },\n        {\n            \"L\": np.diag([2.0, -1.0, -1.0]),\n            \"We\": 50.0,\n            \"dt\": 0.2,\n            \"N\": 10,\n            \"tau\": 1e-12,\n            \"delta\": 1e-10,\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        L = case[\"L\"]\n        We = case[\"We\"]\n        dt = case[\"dt\"]\n        N = case[\"N\"]\n        tau = case[\"tau\"]\n        delta = case[\"delta\"]\n\n        # Initialize conformation tensor and tracking variables\n        A = np.identity(3)\n        n_corr = 0\n        m_pre = float('inf')\n        m_post = float('inf')\n        I = np.identity(3)\n\n        for _ in range(N):\n            # 1. Explicit Euler update to get tentative A_n+1\n            rhs = L @ A + A @ L.T - (1.0 / We) * (A - I)\n            A_tent = A + dt * rhs\n\n            # 2. SPD condition test\n            # a. Symmetry check\n            skew_part = 0.5 * (A_tent - A_tent.T)\n            skew_norm = np.linalg.norm(skew_part, 'fro')\n            \n            # b. Positive definiteness check. Use symmetric part for eigenvalue calculation.\n            # Using eigvalsh is robust for numerically symmetric matrices.\n            A_symm = 0.5 * (A_tent + A_tent.T)\n            try:\n                eigvals_pre = np.linalg.eigvalsh(A_symm)\n                min_eig_pre = eigvals_pre.min()\n            except np.linalg.LinAlgError:\n                min_eig_pre = -float('inf')\n\n            m_pre = min(m_pre, min_eig_pre)\n\n            is_spd = (skew_norm  tau) and (min_eig_pre  delta)\n\n            # 3. Correction procedure if needed\n            if not is_spd:\n                n_corr += 1\n                \n                # Symmetrization is already done (A_symm).\n                # Spectral decomposition\n                try:\n                    eigvals, eigvecs = np.linalg.eigh(A_symm)\n                except np.linalg.LinAlgError:\n                    # If decomposition fails, default to a safe state\n                    A = I\n                    continue\n\n                # Clip eigenvalues\n                eigvals_clipped = np.maximum(eigvals, delta)\n                \n                # Reconstruct\n                A_new = eigvecs @ np.diag(eigvals_clipped) @ eigvecs.T\n            else:\n                A_new = A_tent\n\n            # Update state for next iteration\n            A = A_new\n            \n            # 4. Post-correction analysis\n            # Final A for this step is symmetric by construction\n            try:\n                min_eig_post = np.linalg.eigvalsh(A).min()\n            except np.linalg.LinAlgError:\n                min_eig_post = -float('inf')\n\n            m_post = min(m_post, min_eig_post)\n\n        results.append([n_corr, m_pre, m_post])\n        \n    # Format the final output string as per requirements\n    inner_strings = []\n    for res in results:\n        # Format: [int, float, float]\n        inner_strings.append(f\"[{res[0]},{res[1]},{res[2]}]\")\n    final_string = f\"[{','.join(inner_strings)}]\"\n    \n    print(final_string)\n\nsolve()\n```"
        },
        {
            "introduction": "在高韦森伯格数下，另一个严峻的挑战是应力边界层的形成，这些边界层可能变得极薄，需要极高的网格分辨率才能准确捕捉。本练习将引导你实现一种自适应网格加密（Adaptive Mesh Refinement, AMR）算法。通过将计算资源集中在最需要的区域，AMR 是解决复杂流动中高韦森伯格数难题的一种高效且强大的技术。",
            "id": "4107522",
            "problem": "考虑一个无量纲平面通道，其法向坐标为 $y \\in [0,1]$。假设流动由与Oldroyd-B模型一致的粘弹性本构律控制，其中聚合物附加应力张量 $\\boldsymbol{\\tau}$ 在量纲形式下满足关系式 $\\boldsymbol{\\tau} + \\lambda \\stackrel{\\triangledown}{\\boldsymbol{\\tau}} = 2 \\eta_p \\mathbf{D}$，其中 $\\lambda$ 是聚合物松弛时间，$\\eta_p$ 是聚合物粘度，$\\stackrel{\\triangledown}{\\boldsymbol{\\tau}}$ 是 $\\boldsymbol{\\tau}$ 的上随流导数，$\\mathbf{D}$ 是形变率张量。使用特征速度 $U$ 和特征长度 $L$ 进行无量纲化后，魏森伯格数 (Wi) 定义为 $\\mathrm{Wi} = \\lambda U / L$。在高 $\\mathrm{Wi}$ 下，应力的对流输运在固壁边界附近占主导地位，超过了松弛效应，从而导致薄的应力边界层。在一个对称通道中，主导剪切应力分量 $ \\tau(y; \\mathrm{Wi}) $ 的法向变化的一个简化的、物理上一致的代理模型被指定为\n$$\n\\tau(y; \\mathrm{Wi}) = 1 - \\tfrac{1}{2}\\left( e^{-y/\\delta(\\mathrm{Wi})} + e^{-(1-y)/\\delta(\\mathrm{Wi})} \\right),\n$$\n其中边界层厚度按以下比例变化\n$$\n\\delta(\\mathrm{Wi}) = \\frac{1}{1+\\mathrm{Wi}}.\n$$\n该代理模型捕捉了随着 $\\mathrm{Wi}$ 增大，在 $y=0$ 和 $y=1$ 附近应力梯度的放大效应。\n\n您必须仅基于分段线性近似中应力梯度的大小构建一个后验误差估计器，并用它来驱动一维自适应网格加密。设当前网格由节点 $\\{y_0, y_1, \\dots, y_N\\}$ 定义，其中 $y_0=0$，$y_N=1$，单元大小为 $h_i = y_{i+1}-y_i$（$i=0,\\dots,N-1$）。通过在节点处对 $\\tau$ 进行采样并在每个单元上进行线性插值来定义分段线性近似 $\\tau_h$。单元斜率为\n$$\ns_i = \\frac{\\tau(y_{i+1}; \\mathrm{Wi}) - \\tau(y_i; \\mathrm{Wi})}{h_i}, \\quad i=0,\\dots,N-1.\n$$\n定义基于节点的梯度跳跃为\n$$\nJ_0 = s_0, \\quad J_j = s_j - s_{j-1} \\ \\text{for}\\ j=1,\\dots,N-1, \\quad J_N = s_{N-1}.\n$$\n定义节点的有效局部尺寸为\n$$\nh^{\\mathrm{eff}}_0 = h_0, \\quad h^{\\mathrm{eff}}_j = \\tfrac{1}{2}(h_{j-1}+h_j) \\ \\text{for}\\ j=1,\\dots,N-1, \\quad h^{\\mathrm{eff}}_N = h_{N-1}.\n$$\n节点指标为\n$$\n\\eta^{\\mathrm{node}}_j = \\sqrt{h^{\\mathrm{eff}}_j}\\, |J_j|, \\quad j=0,\\dots,N.\n$$\n为每个单元 $i$ 关联一个单元指标\n$$\n\\eta_i = \\tfrac{1}{2}\\left(\\eta^{\\mathrm{node}}_i + \\eta^{\\mathrm{node}}_{i+1}\\right), \\quad i=0,\\dots,N-1,\n$$\n并定义全局估计器\n$$\nE = \\sum_{i=0}^{N-1} \\eta_i.\n$$\n使用以下自适应加密策略：\n- 从一个包含 $N_0$ 个单元的均匀网格开始。\n- 在每次迭代中，计算 $\\eta_i$，找到 $\\eta_{\\max} = \\max_i \\eta_i$，并标记所有满足 $\\eta_i \\ge \\theta \\, \\eta_{\\max}$ 的单元，其中 $\\theta \\in (0,1]$ 是一个用户参数。\n- 通过二分法（插入中点）加密被标记的单元，其他单元保持不变。\n- 当 $E \\le \\text{tol}$ 或达到预设的最大迭代次数时停止。\n\n您的程序必须为下面的测试套件实现此自适应循环，并为每个测试用例返回元组 $[N, E, h_{\\min}, R]$，其中 $N$ 是最终的单元数，$E$ 是最终的全局估计器，$h_{\\min}$ 是最小的单元尺寸，$R = \\delta(\\mathrm{Wi})/h_{\\min}$ 是量化边界层厚度解析优良程度的解析比。所有量都是无量纲的；因此，所有输出都应表示为无量纲数。不涉及角度。不需要百分比。\n\n测试套件：\n- 用例 1：$\\mathrm{Wi} = 10$，$\\text{tol} = 0.01$，$\\theta = 0.5$，$N_0 = 8$，$\\text{max\\_iter} = 12$。\n- 用例 2：$\\mathrm{Wi} = 0.1$，$\\text{tol} = 0.0001$，$\\theta = 0.5$，$N_0 = 8$，$\\text{max\\_iter} = 12$。\n- 用例 3：$\\mathrm{Wi} = 50$，$\\text{tol} = 0.02$，$\\theta = 0.6$，$N_0 = 8$，$\\text{max\\_iter} = 12$。\n- 用例 4：$\\mathrm{Wi} = 200$，$\\text{tol} = 0.03$，$\\theta = 0.7$，$N_0 = 8$，$\\text{max\\_iter} = 14$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果是按 $[N,E,h_{\\min},R]$ 顺序排列的子列表。例如，包含两个用例的输出应如下所示：$[[N_1,E_1,h_{\\min,1},R_1],[N_2,E_2,h_{\\min,2},R_2]]$。",
            "solution": "问题陈述已经过严格审查，并被确定为有效。它在计算流体动力学和数值分析领域有科学依据，算法上是适定的，并以客观、明确的语言表述。为获得唯一、可验证的解所需的所有数据和定义均已提供。\n\n该问题要求为一个一维代理问题实现一个由后验误差驱动的自适应网格加密（AMR）算法。这个由函数 $\\tau(y; \\mathrm{Wi})$ 定义的代理模型，模拟了在给定魏森伯格数 $\\mathrm{Wi}$ 下粘弹性通道流中的剪切应力分布。在高 $\\mathrm{Wi}$ 下，此类流动的物理特性表现为在固壁附近形成非常薄的应力边界层。代理模型通过边界层厚度 $\\delta(\\mathrm{Wi}) = (1+\\mathrm{Wi})^{-1}$ 来捕捉这一现象，该厚度随着 $\\mathrm{Wi}$ 的增加而减小。在不过度加密整个区域的情况下有效解析这些薄层是计算复杂流体中的一个典型挑战，这使得AMR成为不可或缺的工具。\n\n所规定的AMR算法基于一种残差类型的后验误差估计器。其核心思想是估计真实解 $\\tau$ 的分段线性近似 $\\tau_h$ 中的误差，并利用该估计来指导网格加密。通过为每个单元计算指标来局部化误差，并对具有最大指标的单元进行加密。\n\n算法流程如下：\n\n1.  **解的近似与误差指示**：在给定的网格 $\\{y_0, y_1, \\dots, y_N\\}$ 上，函数 $\\tau(y; \\mathrm{Wi})$ 被一个连续的分段线性函数 $\\tau_h$ 近似。该近似的质量在局部进行评估。单元斜率 $s_i = (\\tau(y_{i+1}) - \\tau(y_i))/h_i$ 表示 $\\tau_h$ 在单元 $i$ 上的恒定梯度。在内部节点 $y_j$ 处该梯度的跳跃 $J_j = s_j - s_{j-1}$，近似于由局部网格尺寸缩放的二阶导数 $\\tau''(y_j)$。对于光滑函数，局部插值误差与二阶导数和单元尺寸的平方成正比。定义的节点指标 $\\eta^{\\mathrm{node}}_j = \\sqrt{h^{\\mathrm{eff}}_j}\\, |J_j|$ 是有限元分析中的一种标准构造，它提供了局部误差的可计算估计。在边界（$j=0$ 和 $j=N$）处，跳跃被定义为 $J_0 = s_0$ 和 $J_N = s_{N-1}$，这是在此类估计器中处理边界项的常用方法。\n\n2.  **单元和全局估计器**：基于节点的指标被平均以产生每个单元 $i$ 的指标 $\\eta_i = \\tfrac{1}{2}(\\eta^{\\mathrm{node}}_i + \\eta^{\\mathrm{node}}_{i+1})$。这将一个局部误差度量与每个网格单元关联起来。这些单元指标的总和 $E = \\sum_{i=0}^{N-1} \\eta_i$ 用作全局误差估计器。\n\n3.  **自适应加密策略**：加密过程遵循一个标准循环（通常称为 `SOLVE - ESTIMATE - MARK - REFINE`）：\n    *   生成一个包含 $N_0$ 个单元的初始均匀网格。\n    *   在每次迭代中，为当前网格计算单元指标 $\\eta_i$。\n    *   采用Dörfler标记策略：所有指标 $\\eta_i$ 是最大指标的一个重要部分的单元 $i$（即 $\\eta_i \\ge \\theta \\, \\eta_{\\max}$）都被标记以进行加密。参数 $\\theta \\in (0,1]$ 控制算法加密的积极程度。\n    *   通过在其中心点插入一个新节点来对标记的单元进行二分。这将生成一个新的、局部更精细的网格。\n    *   当全局误差估计器 $E$ 低于指定的容差 `tol`，或达到最大迭代次数 `max_iter` 时，循环终止。\n\n4.  **实现与输出**：为每个测试用例实施该程序。从初始网格开始，执行自适应循环，直到满足终止条件。终止后，报告网格和模拟的最终状态。这包括最终的单元数 $N$、最终的全局误差估计 $E$、最小的单元尺寸 $h_{\\min}$ 和解析比 $R = \\delta(\\mathrm{Wi})/h_{\\min}$。比率 $R$ 是一个关键指标，因为它量化了在边界层的特征厚度范围内放置了多少个单元，从而表明其解析的质量。对于 $R \\gg 1$，边界层被很好地解析。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the adaptive mesh refinement problem.\n    \"\"\"\n\n    test_cases = [\n        {'Wi': 10.0, 'tol': 0.01, 'theta': 0.5, 'N0': 8, 'max_iter': 12},\n        {'Wi': 0.1, 'tol': 0.0001, 'theta': 0.5, 'N0': 8, 'max_iter': 12},\n        {'Wi': 50.0, 'tol': 0.02, 'theta': 0.6, 'N0': 8, 'max_iter': 12},\n        {'Wi': 200.0, 'tol': 0.03, 'theta': 0.7, 'N0': 8, 'max_iter': 14},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_adaptive_loop(**case)\n        results.append(result)\n\n    # Format the results into the required string list-of-lists format\n    formatted_results = [f\"[{res[0]},{res[1]},{res[2]},{res[3]}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef tau(y, Wi):\n    \"\"\"\n    Calculates the surrogate stress profile tau(y; Wi).\n    \"\"\"\n    delta = 1.0 / (1.0 + Wi)\n    # To prevent overflow with large -y/delta, esp. y=1 near delta=0\n    # exp(-(1-y)/delta) is safe since y is in [0,1].\n    # exp(-y/delta) might be very small, but shouldn't overflow.\n    return 1.0 - 0.5 * (np.exp(-y / delta) + np.exp(-(1.0 - y) / delta))\n\ndef run_adaptive_loop(Wi, tol, theta, N0, max_iter):\n    \"\"\"\n    Executes the adaptive mesh refinement loop for a single test case.\n    \"\"\"\n    # Initial uniform mesh\n    nodes = np.linspace(0.0, 1.0, N0 + 1)\n    delta = 1.0 / (1.0 + Wi)\n\n    final_N = 0\n    final_E = 0.0\n\n    for _ in range(max_iter):\n        # --- ESTIMATE ---\n        N = len(nodes) - 1\n        h = np.diff(nodes)\n        \n        tau_at_nodes = tau(nodes, Wi)\n        s = np.diff(tau_at_nodes) / h\n\n        J = np.zeros(N + 1)\n        J[0] = s[0]\n        if N  1:\n            J[1:N] = s[1:] - s[:-1]\n        J[N] = s[-1]\n\n        h_eff = np.zeros(N + 1)\n        h_eff[0] = h[0]\n        if N  1:\n            h_eff[1:N] = 0.5 * (h[:-1] + h[1:])\n        h_eff[N] = h[-1]\n\n        eta_node = np.sqrt(h_eff) * np.abs(J)\n        eta_element = 0.5 * (eta_node[:-1] + eta_node[1:])\n        E = np.sum(eta_element)\n\n        final_N = N\n        final_E = E\n\n        # --- Check stopping condition ---\n        if E = tol:\n            break\n            \n        # --- MARK ---\n        eta_max = np.max(eta_element)\n        if eta_max == 0: # If error is identically zero, stop.\n            break\n\n        # A small tolerance is used in comparison to avoid floating point artifacts.\n        marked_indices = np.where(eta_element = theta * eta_max - 1e-15)[0]\n\n        if len(marked_indices) == 0:\n            # This can happen if, e.g., theta is slightly  1 due to fp error. Stop.\n            break\n\n        # --- REFINE ---\n        midpoints_to_add = (nodes[marked_indices] + nodes[marked_indices + 1]) / 2.0\n        nodes = np.unique(np.concatenate([nodes, midpoints_to_add]))\n    else:\n        # This block executes if the loop completes (max_iter reached).\n        # We must recalculate metrics for the final mesh.\n        N = len(nodes) - 1\n        h = np.diff(nodes)\n        tau_at_nodes = tau(nodes, Wi)\n        s = np.diff(tau_at_nodes) / h\n        J = np.zeros(N + 1)\n        J[0] = s[0]\n        if N  1: J[1:N] = s[1:] - s[:-1]\n        J[N] = s[-1]\n        h_eff = np.zeros(N + 1)\n        h_eff[0] = h[0]\n        if N  1: h_eff[1:N] = 0.5 * (h[:-1] + h[1:])\n        h_eff[N] = h[-1]\n        eta_node = np.sqrt(h_eff) * np.abs(J)\n        eta_element = 0.5 * (eta_node[:-1] + eta_node[1:])\n        E = np.sum(eta_element)\n        final_N = N\n        final_E = E\n        \n    # After loop termination, calculate final output quantities\n    h_final = np.diff(nodes)\n    h_min = np.min(h_final) if len(h_final)  0 else 1.0\n    R = delta / h_min\n    \n    return [final_N, final_E, h_min, R]\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}