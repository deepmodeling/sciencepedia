{
    "hands_on_practices": [
        {
            "introduction": "本征正交分解（POD）的核心思想是识别并捕获流场中能量最主要的模态。本练习  是所有降阶建模工作的基础，它将指导你如何使用奇异值来量化每个POD模态的重要性。你将通过编程实践，学习如何根据期望的能量捕获率（一个衡量精度的指标）来确定降阶模型所需的模态数量 $r$，这是构建任何POD降阶模型的第一个关键决策。",
            "id": "4101511",
            "problem": "考虑一组向量值流场快照，它们以列的形式排列在一个矩阵 $X \\in \\mathbb{R}^{n \\times m}$ 中，其中每一列 $x_j \\in \\mathbb{R}^n$ 代表了在时间索引 $j \\in \\{1,\\dots,m\\}$ 时复杂流体流动的离散状态。假设在 $\\mathbb{R}^n$ 上使用标准的欧几里得内积，并将一个快照 $x_j$ 的能量定义为 $\\|x_j\\|_2^2$。令均值中心化的快照矩阵为 $\\tilde{X} = X - \\bar{x}\\mathbf{1}^\\top$，其中 $\\bar{x} = \\frac{1}{m} X \\mathbf{1}$，而 $\\mathbf{1} \\in \\mathbb{R}^m$ 是全为1的向量。对 $\\tilde{X}$ 进行奇异值分解 (SVD)，得到 $\\tilde{X} = U \\Sigma V^\\top$，其中 $U \\in \\mathbb{R}^{n \\times r^\\star}$ 的列是标准正交的，$\\Sigma \\in \\mathbb{R}^{r^\\star \\times r^\\star}$ 是对角矩阵，其非负对角元素为 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge \\sigma_{r^\\star} \\ge 0$，$V \\in \\mathbb{R}^{m \\times r^\\star}$ 的列是标准正交的，且 $r^\\star = \\operatorname{rank}(\\tilde{X})$。将前 $r$ 个模态捕获的本征正交分解 (POD) 能量定义为累积分数\n$$\nE(r) = \\frac{\\sum_{k=1}^{r} \\sigma_k^2}{\\sum_{k=1}^{m} \\sigma_k^2},\n$$\n约定当 $k > r^\\star$ 时 $\\sigma_k = 0$，且分母等于 $\\|\\tilde{X}\\|_F^2 = \\sum_{k=1}^{r^\\star} \\sigma_k^2$。对于给定的容差 $\\epsilon \\in [0,1]$，定义\n$$\nr_{\\min}(\\epsilon) = \\min\\{r \\in \\{0,1,\\dots,m\\} \\mid E(r) \\ge \\epsilon\\},\n$$\n约定 $E(0) = 0$。\n\n您的任务是编写一个程序，对于每个指定的测试用例，使用从给定的 $X$ 构建的均值中心化快照矩阵 $\\tilde{X}$，为提供的查询 $r_q$ 计算 $E(r_q)$，并为提供的容差 $\\epsilon$ 确定 $r_{\\min}(\\epsilon)$。\n\n请使用以下测试套件。在所有情况下，索引为 $i \\in \\{1,\\dots,n\\}$ 和 $j \\in \\{1,\\dots,m\\}$，三角函数作用于弧度，并且所有量都是无量纲的。\n\n- 测试用例 1（通用多频流）：\n  - $n = 64$, $m = 32$。\n  - $X_{ij} = \\sin\\!\\left(\\frac{2\\pi i}{n}\\right)\\cos\\!\\left(\\frac{2\\pi j}{m}\\right) + 0.4\\,\\sin\\!\\left(\\frac{4\\pi i}{n}\\right)\\sin\\!\\left(\\frac{3\\pi j}{m}\\right)$。\n  - $r_q = 5$。\n  - $\\epsilon = 0.95$。\n\n- 测试用例 2（近秩二结构，高容差边界）：\n  - $n = 50$, $m = 50$。\n  - $X_{ij} = \\frac{i}{n} + \\frac{j}{m}$。\n  - $r_q = 2$。\n  - $\\epsilon = 0.999$。\n\n- 测试用例 3（受控模态叠加）：\n  - $n = 60$, $m = 45$。\n  - 定义 $u_p(i) = \\sin\\!\\left(\\frac{2\\pi p i}{n}\\right)$ 和 $v_p(j) = \\cos\\!\\left(\\frac{2\\pi p j}{m}\\right)$，对于 $p \\in \\{1,2,3\\}$，权重为 $a_1 = 2.0$, $a_2 = 1.0$, $a_3 = 0.5$。构建 $X = \\sum_{p=1}^{3} a_p\\, u_p\\, v_p^\\top$。\n  - $r_q = 2$。\n  - $\\epsilon = 0.90$。\n\n- 测试用例 4（秩一结构，小容差和查询边缘）：\n  - $n = 40$, $m = 20$。\n  - $X_{ij} = 0.01\\,\\sin\\!\\left(\\frac{2\\pi i}{n}\\right)\\cos\\!\\left(\\frac{2\\pi j}{m}\\right)$。\n  - $r_q = 0$。\n  - $\\epsilon = 0.01$。\n\n最终输出格式：您的程序应生成一行包含 Python 风格的配对列表，每个测试用例对应一个配对，其中每个配对为 $[E(r_q), r_{\\min}(\\epsilon)]$。该列表必须按照与测试用例相同的顺序列出。例如，输出必须类似于 `[ [ratio1,r1],[ratio2,r2],[ratio3,r3],[ratio4,r4] ]`，其中每个 `ratioK` 是 $[0,1]$ 中的一个浮点数，每个 `rK$` 是 $\\{0,1,\\dots,m\\}$ 中的一个整数。",
            "solution": "在尝试给出解决方案之前，用户提供的问题陈述经过了严格的验证过程。\n\n### 第 1 步：提取的已知条件\n- **快照矩阵**：$X \\in \\mathbb{R}^{n \\times m}$，其中列 $x_j \\in \\mathbb{R}^n$ 是 $j \\in \\{1,\\dots,m\\}$ 时的流场状态。\n- **能量定义**：快照 $x_j$ 的能量是 $\\|x_j\\|_2^2$。\n- **均值中心化矩阵**：$\\tilde{X} = X - \\bar{x}\\mathbf{1}^\\top$，其中 $\\bar{x} = \\frac{1}{m} X \\mathbf{1}$ 是 $X$ 各列的均值。\n- **奇异值分解 (SVD)**：$\\tilde{X} = U \\Sigma V^\\top$，其中 $U \\in \\mathbb{R}^{n \\times r^\\star}$，$\\Sigma \\in \\mathbb{R}^{r^\\star \\times r^\\star}$ 是对角矩阵，其奇异值为 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge \\sigma_{r^\\star} \\ge 0$，而 $V \\in \\mathbb{R}^{m \\times r^\\star}$。$r^\\star = \\operatorname{rank}(\\tilde{X})$。\n- **POD 能量函数**：前 $r$ 个模态捕获的累积能量分数为 $E(r) = \\frac{\\sum_{k=1}^{r} \\sigma_k^2}{\\sum_{k=1}^{m} \\sigma_k^2}$。\n- **$E(r)$ 的约定**：当 $k > r^\\star$ 时，$\\sigma_k = 0$。分母为 $\\|\\tilde{X}\\|_F^2$。\n- **最小秩函数**：对于容差 $\\epsilon \\in [0,1]$，$r_{\\min}(\\epsilon) = \\min\\{r \\in \\{0,1,\\dots,m\\} \\mid E(r) \\ge \\epsilon\\}$。\n- **$r_{\\min}(\\epsilon)$ 的约定**：$E(0) = 0$。\n- **任务**：对于每个测试用例，计算 $E(r_q)$ 和 $r_{\\min}(\\epsilon)$。\n- **测试用例 1**：\n  - $n = 64$, $m = 32$。\n  - $X_{ij} = \\sin\\!\\left(\\frac{2\\pi i}{n}\\right)\\cos\\!\\left(\\frac{2\\pi j}{m}\\right) + 0.4\\,\\sin\\!\\left(\\frac{4\\pi i}{n}\\right)\\sin\\!\\left(\\frac{3\\pi j}{m}\\right)$。\n  - $r_q = 5$。\n  - $\\epsilon = 0.95$。\n- **测试用例 2**：\n  - $n = 50$, $m = 50$。\n  - $X_{ij} = \\frac{i}{n} + \\frac{j}{m}$。\n  - $r_q = 2$。\n  - $\\epsilon = 0.999$。\n- **测试用例 3**：\n  - $n = 60$, $m = 45$。\n  - $X = \\sum_{p=1}^{3} a_p\\, u_p\\, v_p^\\top$，其中 $u_p(i) = \\sin\\!\\left(\\frac{2\\pi p i}{n}\\right)$，$v_p(j) = \\cos\\!\\left(\\frac{2\\pi p j}{m}\\right)$，权重为 $a_1 = 2.0$, $a_2 = 1.0$, $a_3 = 0.5$。\n  - $r_q = 2$。\n  - $\\epsilon = 0.90$。\n- **测试用例 4**：\n  - $n = 40$, $m = 20$。\n  - $X_{ij} = 0.01\\,\\sin\\!\\left(\\frac{2\\pi i}{n}\\right)\\cos\\!\\left(\\frac{2\\pi j}{m}\\right)$。\n  - $r_q = 0$。\n  - $\\epsilon = 0.01$。\n- **通用规则**：索引 $i \\in \\{1,\\dots,n\\}$ 和 $j \\in \\{1,\\dots,m\\}$。三角函数使用弧度。\n\n### 第 2 步：使用提取的已知条件进行验证\n根据已建立的验证标准对问题进行评估。\n1.  **科学基础**：该问题植根于线性代数（SVD）和计算流体动力学（本征正交分解）的既定原理。POD 是一种用于复杂系统模型降阶的标准、广泛使用的技术。快照能量、均值中心化和累积能量分数的定义在该领域是标准的。该问题在科学上是合理的。\n2.  **适定性**：问题提供了一个清晰、明确的执行步骤。对于每个测试用例，所有输入（$X$, $r_q$, $\\epsilon$）都已明确定义。输出（$E(r_q)$, $r_{\\min}(\\epsilon)$）由所定义的数学运算（均值中心化、SVD、求和）唯一确定。每种情况都存在唯一且稳定的解。\n3.  **客观性**：问题以精确、形式化的数学语言陈述。没有主观陈述、观点或歧义。\n4.  **完整性与一致性**：问题是自洽的。所有必需的矩阵、参数和函数都已定义。这些定义内部一致；例如，$E(r)$ 的分母被正确定为 $\\tilde{X}$ 的弗罗贝尼乌斯范数的平方，而这又等于奇异值平方和。\n5.  **非不切实际或不可行**：测试用例涉及从行为良好的数学函数构建矩阵并执行标准的数值计算。矩阵的维度适中，在计算上是可行的。\n6.  **非不适定或琐碎**：该问题需要一个非平凡的数值算法实现，涉及矩阵构建、均值中心化、SVD 以及对奇异值的分析。测试用例旨在探究不同情景（多模态、低秩、均值减去效应），展示了超出简单计算的概念深度。例如，测试用例3和4具有零均值结构，简化了 $\\tilde{X}=X$，而测试用例2具有非零均值，减去该均值后，矩阵的秩降为1。这些是微妙而重要的特征。\n\n### 第 3 步：结论与行动\n该问题被判定为**有效**。它具有科学依据、适定、客观且计算上可行。将提供一个完整的解决方案。\n\n### 解决方案与算法设计\n\n任务是为几个测试用例计算两个量：给定秩 $r_q$ 的 POD 能量 $E(r_q)$，以及捕获总能量的 $\\epsilon$ 分数所需的最小秩 $r_{\\min}(\\epsilon)$。该过程基于对均值中心化数据的奇异值分解 (SVD)。\n\n每个测试用例的算法如下：\n\n1.  **构建快照矩阵 $X$**：对于给定的维度为 $n \\times m$ 的测试用例，我们首先构建矩阵 $X \\in \\mathbb{R}^{n \\times m}$。元素 $X_{ij}$ 由提供的公式定义，需密切注意 $i \\in \\{1, \\dots, n\\}$ 和 $j \\in \\{1, \\dots, m\\}$ 的 1-基索引。\n\n2.  **计算均值中心化矩阵 $\\tilde{X}$**：用于分析波动的 POD 的基础是减去平均状态。我们通过对 $X$ 的列进行平均来计算时间平均快照 $\\bar{x} \\in \\mathbb{R}^n$：\n    $$ \\bar{x} = \\frac{1}{m} \\sum_{j=1}^{m} x_j $$\n    然后，我们通过从每一列 $x_j$ 中减去 $\\bar{x}$ 来形成均值中心化（或波动）矩阵 $\\tilde{X} \\in \\mathbb{R}^{n \\times m}$：\n    $$ \\tilde{X} = X - \\bar{x}\\mathbf{1}^\\top $$\n    其中 $\\mathbf{1}^\\top$ 是一个包含 $m$ 个1的行向量。\n\n3.  **执行奇异值分解**：我们计算均值中心化矩阵 $\\tilde{X}$ 的 SVD。\n    $$ \\tilde{X} = U \\Sigma V^\\top $$\n    此分解在 $U$ 中产生左奇异向量（POD 模态），在 $V$ 中产生右奇异向量，在 $\\Sigma$ 的对角线上产生奇异值 $\\sigma_k$。就我们的目的而言，只需要奇异值 $\\sigma_k$。我们通过标准的数值 SVD 例程将它们作为一个一维数组 $\\mathbf{s} = [\\sigma_1, \\sigma_2, \\dots, \\sigma_{\\min(n,m)}]$ 获得。\n\n4.  **计算累积能谱**：每个 POD 模态的能量与其对应奇异值的平方成正比。波动的总能量是所有模态能量之和，等于 $\\tilde{X}$ 的弗罗贝尼乌斯范数的平方：\n    $$ \\mathcal{E}_{\\text{total}} = \\|\\tilde{X}\\|_F^2 = \\sum_{k=1}^{r^\\star} \\sigma_k^2 $$\n    前 $r$ 个模态捕获的能量是 $\\sum_{k=1}^{r} \\sigma_k^2$。累积能量分数则为：\n    $$ E(r) = \\frac{\\sum_{k=1}^{r} \\sigma_k^2}{\\mathcal{E}_{\\text{total}}} $$\n    我们为所有可能的 $r$ 值（从 1 到 $r^\\star = \\operatorname{rank}(\\tilde{X})$）计算这个值。这可以通过先将所有奇异值平方，然后计算它们的累积和来高效完成。如果 $\\mathcal{E}_{\\text{total}}$ 在数值上为零，则所有波动能量都为零，我们定义当 $r > 0$ 时 $E(r) = 0$。\n\n5.  **确定 $E(r_q)$**：使用计算出的累积能谱和给定的查询秩 $r_q$：\n    - 如果 $r_q = 0$，根据定义，$E(0) = 0$。\n    - 如果 $r_q > 0$，我们从预先计算的累积能量分数数组中找到 $E(r_q)$。如果 $r_q$ 大于可用奇异值的数量，这意味着所有能量都已被捕获，所以 $E(r_q) = 1$。\n\n6.  **确定 $r_{\\min}(\\epsilon)$**：使用给定的容差 $\\epsilon \\in [0,1]$：\n    - 如果 $\\epsilon \\le 0$，条件 $E(r) \\ge \\epsilon$ 对于 $r=0$ 是满足的，因为 $E(0)=0$。因此，$r_{\\min}(\\epsilon) = 0$。\n    - 如果 $\\epsilon > 0$，我们搜索最小的整数 $r \\ge 1$ 使得 $E(r) \\ge \\epsilon$。这可以通过在已排序的累积能量分数数组中搜索第一个大于或等于 $\\epsilon$ 的元素来高效地找到。秩 $r$ 是该元素的索引加一。\n\n此结构化过程应用于每个测试用例，以生成所需的配对值 $[E(r_q), r_{\\min}(\\epsilon)]$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the POD problem for all test cases.\n    \"\"\"\n\n    def generate_x_case1(n, m):\n        \"\"\"Generates the snapshot matrix X for Test Case 1.\"\"\"\n        i_vals = np.arange(1, n + 1).reshape(-1, 1)\n        j_vals = np.arange(1, m + 1).reshape(1, -1)\n        x = (np.sin(2 * np.pi * i_vals / n) * np.cos(2 * np.pi * j_vals / m) +\n             0.4 * np.sin(4 * np.pi * i_vals / n) * np.sin(3 * np.pi * j_vals / m))\n        return x\n\n    def generate_x_case2(n, m):\n        \"\"\"Generates the snapshot matrix X for Test Case 2.\"\"\"\n        i_vals = np.arange(1, n + 1).reshape(-1, 1)\n        j_vals = np.arange(1, m + 1).reshape(1, -1)\n        x = i_vals / n + j_vals / m\n        return x\n\n    def generate_x_case3(n, m):\n        \"\"\"Generates the snapshot matrix X for Test Case 3.\"\"\"\n        i_vals = np.arange(1, n + 1).reshape(-1, 1)\n        j_vals = np.arange(1, m + 1).reshape(1, -1)\n        weights = [2.0, 1.0, 0.5]\n        x = np.zeros((n, m))\n        for p_idx, p in enumerate(range(1, 4)):\n            a_p = weights[p_idx]\n            u_p = np.sin(2 * np.pi * p * i_vals / n)\n            v_p_T = np.cos(2 * np.pi * p * j_vals / m)\n            x += a_p * (u_p @ v_p_T)\n        return x\n\n    def generate_x_case4(n, m):\n        \"\"\"Generates the snapshot matrix X for Test Case 4.\"\"\"\n        i_vals = np.arange(1, n + 1).reshape(-1, 1)\n        j_vals = np.arange(1, m + 1).reshape(1, -1)\n        x = 0.01 * np.sin(2 * np.pi * i_vals / n) * np.cos(2 * np.pi * j_vals / m)\n        return x\n\n    test_cases = [\n        {'n': 64, 'm': 32, 'gen_x': generate_x_case1, 'r_q': 5, 'epsilon': 0.95},\n        {'n': 50, 'm': 50, 'gen_x': generate_x_case2, 'r_q': 2, 'epsilon': 0.999},\n        {'n': 60, 'm': 45, 'gen_x': generate_x_case3, 'r_q': 2, 'epsilon': 0.90},\n        {'n': 40, 'm': 20, 'gen_x': generate_x_case4, 'r_q': 0, 'epsilon': 0.01},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        n, m, gen_x, r_q, epsilon = case['n'], case['m'], case['gen_x'], case['r_q'], case['epsilon']\n\n        # Step 1: Construct the snapshot matrix X\n        X = gen_x(n, m)\n\n        # Step 2: Compute the mean-centered matrix X_tilde\n        x_mean = X.mean(axis=1, keepdims=True)\n        X_tilde = X - x_mean\n\n        # Step 3: Perform SVD\n        # We only need the singular values, s.\n        s = np.linalg.svd(X_tilde, compute_uv=False)\n\n        # Step 4: Calculate cumulative energy spectrum\n        s_sq = s**2\n        total_energy = np.sum(s_sq)\n\n        cumulative_energy_frac = np.array([])\n        if total_energy > 1e-15:\n            cumulative_energy_frac = np.cumsum(s_sq) / total_energy\n            # Clamp last value to 1.0 to handle potential float precision issues\n            if cumulative_energy_frac.size > 0:\n                cumulative_energy_frac[-1] = 1.0\n\n\n        # Step 5: Determine E(r_q)\n        e_rq = 0.0\n        if r_q > 0:\n            if cumulative_energy_frac.size == 0:\n                 e_rq = 0.0\n            elif r_q > len(cumulative_energy_frac):\n                e_rq = 1.0\n            else:\n                e_rq = cumulative_energy_frac[r_q - 1]\n\n        # Step 6: Determine r_min(epsilon)\n        r_min = 0\n        if epsilon > 0:\n            if cumulative_energy_frac.size == 0:\n                # No energy, so need infinite modes for epsilon > 0.\n                # Per problem, max r is m. So we return m.\n                r_min = m\n            else:\n                # np.searchsorted finds the index where epsilon would be inserted\n                # to maintain order. The required rank is that index + 1.\n                found_idx = np.searchsorted(cumulative_energy_frac, epsilon)\n                if found_idx < len(cumulative_energy_frac):\n                    r_min = found_idx + 1\n                else: \n                    # Epsilon is > 1.0 or numerically greater than max cumulative energy.\n                    # This case implies we cannot reach the energy tolerance.\n                    # The problem constrains epsilon to [0, 1].\n                    # If max(E) is numerically < epsilon, it means we need all modes.\n                    r_min = len(cumulative_energy_frac)\n\n        results.append([e_rq, r_min])\n    \n    # Format the output exactly as specified.\n    # [ [ratio1,r1],[ratio2,r2],... ]\n    # Using str() on lists inserts spaces, so we build the string manually.\n    pairs_str = [f\"[{res[0]},{res[1]}]\" for res in results]\n    final_output_str = f\"[{','.join(pairs_str)}]\"\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了如何构建POD基之后，一个更深入的问题是：是否存在一种“最优”的构建方式？本练习  探讨了在定义POD最优性时，内积所扮演的关键而微妙的角色。通过对一个粘弹性流模型比较欧几里得、质量加权和能量加权三种不同内积的效果，你将发现，根据系统的物理特性（如能量）定制内积可以产生更精确、更符合物理规律的降阶模型。",
            "id": "4101559",
            "problem": "考虑一个平面通道中无量纲、线性化的 Oldroyd-B 黏弹性流动模型的截断伽辽金表示。设状态向量为 $x(t) \\in \\mathbb{R}^{n}$，其中 $n = 6$，分区为 $x(t) = \\begin{bmatrix} v(t) \\\\ \\tau(t) \\end{bmatrix}$，其中 $v(t) \\in \\mathbb{R}^{3}$ 代表速度模态系数，$\\tau(t) \\in \\mathbb{R}^{3}$ 代表聚合物应力模态系数。其演化由一阶线性系统控制\n$$\n\\frac{d x}{d t} = A(\\mathrm{Wi}, \\nu, \\alpha, \\beta)\\, x(t) + b\\, f(t),\n$$\n其中 $A \\in \\mathbb{R}^{6 \\times 6}$ 是一个编码了粘性耗散和聚合物应力耦合的分块矩阵，$\\mathrm{Wi}$ 是魏森伯格数（Weissenberg number），$\\nu$ 是运动粘度，$\\alpha$ 是一个缩放动量方程中聚合物应力散度的耦合系数，$\\beta$ 是聚合物粘度与总粘度之比。外部强迫为 $f(t) = \\sin(\\omega t)$，其中 $\\omega$ 以弧度为单位，而 $b \\in \\mathbb{R}^{6}$ 是一个仅作用于速度模态的恒定输入方向。\n\n使用以下物理上一致且科学上现实的参数化：\n- 设速度的模态拉普拉斯算子为 $L_v = \\mathrm{diag}(k_1^2, k_2^2, k_3^2)$，其中 $k_1 = 1$, $k_2 = 2$, $k_3 = 3$，粘性耗散块为 $A_{vv} = -\\nu L_v$，其中 $\\nu = 0.1$。\n- 设从聚合物应力到速度的类散度耦合为 $A_{v\\tau} = \\alpha D$，其中 $\\alpha = 0.5$，$D = \\mathrm{diag}(0.7, 0.6, 0.5)$。\n- 设应变到应力的耦合为 $A_{\\tau v} = \\beta S$，其中 $S = \\mathrm{diag}(0.4, 0.35, 0.3)$。\n- 设聚合物松弛为 $A_{\\tau \\tau} = -\\frac{1}{\\mathrm{Wi}} I_3$，其中 $I_3$ 是 $3 \\times 3$ 的单位矩阵，得到分块系统\n$$\nA(\\mathrm{Wi}, \\nu, \\alpha, \\beta) = \n\\begin{bmatrix}\n-\\nu L_v & \\alpha D \\\\\n\\beta S & -\\frac{1}{\\mathrm{Wi}} I_3\n\\end{bmatrix}.\n$$\n- 设强迫方向为 $b = \\begin{bmatrix} b_v \\\\ 0 \\end{bmatrix}$，其中 $b_v = [1.0,\\, 0.5,\\, 0.3]^\\top$，应力块为零。\n- 设角频率为 $\\omega = 1.2$（弧度）。\n\n定义三个对称正定内积矩阵，用于构建本征正交分解 (Proper Orthogonal Decomposition, POD) 基并执行伽辽金投影：\n- 欧几里得内积：$W_E = I_6$，即 $6 \\times 6$ 的单位矩阵。\n- 质量加权内积：$W_M = M$，其中\n$$\nM = \\mathrm{diag}(m_v, m_\\tau), \\quad m_v = [1.0,\\, 1.5,\\, 2.0], \\quad m_\\tau = [0.8,\\, 0.9,\\, 1.1],\n$$\n解释为模态坐标系中的离散化质量矩阵。\n- 能量加权内积：$W_\\mathcal{E} = E$，其中\n$$\nE = \\mathrm{diag}(m_v, \\frac{1}{\\beta}\\mathbf{1}_3),\n$$\n$\\mathbf{1}_3$ 是长度为3的全1向量，表示动能加弹性势能的二次近似，其中速度由 $m_v$ 加权，聚合物应力由 $1/\\beta$ 加权。\n\n对于每个内积 $W \\in \\{W_E, W_M, W_\\mathcal{E}\\}$，定义一个秩为 $r$ 的 POD 基 $\\Phi_W \\in \\mathbb{R}^{6 \\times r}$，该基由高保真快照 $X = [x(t_1), \\dots, x(t_N)] \\in \\mathbb{R}^{6 \\times N}$ 构建，使得 $\\Phi_W$ 的列在 $W$-内积下是标准正交的。使用 $W$-伽辽金投影来构建降阶模型 (Reduced-Order Model, ROM)\n$$\n\\frac{d x_r}{d t} = A_r x_r + b_r f(t), \\quad A_r = \\Phi_W^\\top W A \\Phi_W, \\quad b_r = \\Phi_W^\\top W b,\n$$\n并重构高维近似 $\\hat{x}(t) = \\Phi_W x_r(t)$。\n\n使用时间范围内的能量相对误差来衡量精度：\n$$\n\\varepsilon_W = \\sqrt{\\frac{\\sum_{j=1}^N \\|x(t_j) - \\hat{x}(t_j)\\|_{E}^2}{\\sum_{j=1}^N \\|x(t_j)\\|_{E}^2}},\n$$\n其中 $\\|y\\|_{E}^2 = y^\\top E y$。所有量均为无量纲；角度以弧度为单位。\n\n您的程序必须：\n1. 使用固定步长的四阶龙格-库塔法，在时间范围 $T = 10$、时间步长 $\\Delta t = 0.005$（即 $N = T/\\Delta t$ 个快照）的条件下，对初值为 $x(0) = 0$ 且强迫项为 $f(t) = \\sin(\\omega t)$ 的全阶模型进行积分。\n2. 对每个 $W \\in \\{W_E, W_M, W_\\mathcal{E}\\}$，使用数值稳定的加权分解方法，构建维度为 $r$ 的 POD 基，其中 $\\Phi_W$ 的列是 $W$-标准正交的。\n3. 对每个 $W$ 构建 ROM，使用相同的积分器进行积分，并重构 $\\hat{x}(t)$。\n4. 在每个测试案例中，计算每个 $W$ 对应的 $\\varepsilon_W$。\n\n测试套件：\n- 案例 $\\mathrm{A}$：$(\\mathrm{Wi}, \\beta, r) = (0.1,\\, 0.25,\\, 3)$。\n- 案例 $\\mathrm{B}$：$(\\mathrm{Wi}, \\beta, r) = (1.0,\\, 0.35,\\, 3)$。\n- 案例 $\\mathrm{C}$（强弹性且子空间较小的边缘案例）：$(\\mathrm{Wi}, \\beta, r) = (5.0,\\, 0.50,\\, 2)$。\n\n对于每个案例，以实数（无量纲浮点数）列表 $[\\varepsilon_{W_E}, \\varepsilon_{W_M}, \\varepsilon_{W_\\mathcal{E}}]$ 的形式报告结果。您的程序应生成单行输出，其中包含三个案例（按 $\\mathrm{A}$、$\\mathrm{B}$、$\\mathrm{C}$ 顺序）的结果。结果应为由逗号分隔的这三个三元素列表组成的列表，并用方括号括起来。例如，输出格式必须为\n$$\n[[\\varepsilon_{W_E}^{(\\mathrm{A})}, \\varepsilon_{W_M}^{(\\mathrm{A})}, \\varepsilon_{W_\\mathcal{E}}^{(\\mathrm{A})}], [\\varepsilon_{W_E}^{(\\mathrm{B})}, \\varepsilon_{W_M}^{(\\mathrm{B})}, \\varepsilon_{W_\\mathcal{E}}^{(\\mathrm{B})}], [\\varepsilon_{W_E}^{(\\mathrm{C})}, \\varepsilon_{W_M}^{(\\mathrm{C})}, \\varepsilon_{W_\\mathcal{E}}^{(\\mathrm{C})}]].\n$$\n所有计算和输出均为无量纲，角度以弧度为单位。最终输出不得附带任何单位，且必须是指定的单行格式。",
            "solution": "该问题要求为一个线性化黏弹性流动系统开发并比较降阶模型 (ROM)。该过程涉及模拟一个全阶模型 (FOM)，使用三种不同内积的本征正交分解 (POD) 构建 ROM，并评估其精度。\n\n### 1. 全阶模型 (FOM)\n系统动力学由状态向量 $x(t) \\in \\mathbb{R}^{6}$ 的线性常微分方程 (LDE) 描述。状态向量包含 3 个速度模态系数 $v(t)$ 和 3 个聚合物应力模态系数 $\\tau(t)$，使得 $x(t) = [v(t)^\\top, \\tau(t)^\\top]^\\top$。控制方程为：\n$$\n\\frac{d x}{d t} = A(\\mathrm{Wi}, \\beta) x(t) + b f(t)\n$$\n强迫函数为 $f(t) = \\sin(\\omega t)$，角频率 $\\omega = 1.2$。恒定强迫向量 $b \\in \\mathbb{R}^{6}$ 仅作用于速度模态：$b = [1.0, 0.5, 0.3, 0, 0, 0]^\\top$。\n\n状态矩阵 $A \\in \\mathbb{R}^{6 \\times 6}$ 依赖于魏森伯格数 $\\mathrm{Wi}$ 和粘度比 $\\beta$。它被定义为一个分块矩阵：\n$$\nA(\\mathrm{Wi}, \\beta) = \n\\begin{bmatrix}\nA_{vv} & A_{v\\tau} \\\\\nA_{\\tau v} & A_{\\tau \\tau}\n\\end{bmatrix} = \n\\begin{bmatrix}\n-\\nu L_v & \\alpha D \\\\\n\\beta S & -\\frac{1}{\\mathrm{Wi}} I_3\n\\end{bmatrix}\n$$\n这些分块使用给定的参数和矩阵定义：\n- 粘性耗散：$A_{vv} = -\\nu L_v$，其中运动粘度 $\\nu = 0.1$，模态拉普拉斯算子 $L_v = \\mathrm{diag}(1^2, 2^2, 3^2) = \\mathrm{diag}(1, 4, 9)$。\n- 应力到速度耦合：$A_{v\\tau} = \\alpha D$，其中耦合系数 $\\alpha = 0.5$ 且 $D = \\mathrm{diag}(0.7, 0.6, 0.5)$。\n- 速度到应力耦合：$A_{\\tau v} = \\beta S$，其中 $S = \\mathrm{diag}(0.4, 0.35, 0.3)$。参数 $\\beta$ 在每个测试案例中指定。\n- 聚合物松弛：$A_{\\tau \\tau} = -\\frac{1}{\\mathrm{Wi}} I_3$，其中 $I_3$ 是 $3 \\times 3$ 的单位矩阵，$\\mathrm{Wi}$ 在每个测试案例中指定。\n\n为了生成用于模型降阶的数据，此 FOM 从初始条件 $x(0)=0$ 开始，在时间范围 $T=10$ 内，使用固定步长的四阶龙格-库塔 (RK4) 方法进行数值积分，时间步长为 $\\Delta t = 0.005$。这将产生一个包含 $N+1$ 个状态向量或“快照”的序列 $x(t_j)$，其中 $t_j = j \\Delta t$，$j=0, 1, \\dots, N$ 且 $N=T/\\Delta t=2000$。这些快照被收集到一个快照矩阵 $X = [x(t_0), x(t_1), ..., x(t_N)] \\in \\mathbb{R}^{6 \\times (N+1)}$ 中。\n\n### 2. 加权本征正交分解 (POD)\nPOD 的目标是找到一个最优的低维基来表示快照数据。给定一个由对称正定权重矩阵 $W$ 定义的内积，我们寻求一个基 $\\Phi_W \\in \\mathbb{R}^{6 \\times r}$，其列相对于该内积是标准正交的，即 $\\Phi_W^\\top W \\Phi_W = I_r$，其中 $r$ 是 ROM 的期望秩。\n\n从快照矩阵 $X$ 计算这个 $W$-标准正交基的算法如下：\n1.  对权重矩阵进行 Cholesky 分解 $W = L L^\\top$，其中 $L$ 是一个下三角矩阵。\n2.  使用这个因子转换快照数据：$\\tilde{X} = L^\\top X$。\n3.  计算转换后数据的奇异值分解 (SVD)：$\\tilde{X} = U \\Sigma V^\\top$。$U$ 的列构成一个标准正交基，能最优地捕捉 $\\tilde{X}$ 中的数据。\n4.  通过选择 $U$ 的前 $r$ 列来截断基，这些列对应于最大的奇异值：$\\tilde{\\Phi}_W = U[:, :r]$。\n5.  将此基变换回原始坐标系以获得最终的 POD 基：$\\Phi_W = (L^\\top)^{-1} \\tilde{\\Phi}_W$。由于 $L^\\top$ 是上三角矩阵，这个线性系统可以通过回代法高效求解。\n\n对由以下矩阵定义的三个不同内积执行此过程：\n- 欧几里得内积：$W_E = I_6$。\n- 质量加权内积：$W_M = \\mathrm{diag}(1.0, 1.5, 2.0, 0.8, 0.9, 1.1)$。\n- 能量加权内积：$W_\\mathcal{E} = E = \\mathrm{diag}(1.0, 1.5, 2.0, 1/\\beta, 1/\\beta, 1/\\beta)$。注意，该矩阵依赖于测试案例中的参数 $\\beta$。\n\n### 3. 降阶模型 (ROM) 的构建与模拟\n使用计算出的 POD 基 $\\Phi_W$，通过 $W$-伽辽金投影构建一个 ROM。全阶状态 $x(t)$ 通过投影到该基上进行近似，$x(t) \\approx \\hat{x}(t) = \\Phi_W x_r(t)$，其中 $x_r(t) \\in \\mathbb{R}^r$ 是降阶状态。将此近似代入 FOM 并使用 $W$-内积投影到基上，得到 ROM：\n$$\n\\frac{d x_r}{d t} = A_r x_r(t) + b_r f(t)\n$$\n其中降阶系统矩阵由下式给出：\n$$\nA_r = \\Phi_W^\\top W A \\Phi_W \\in \\mathbb{R}^{r \\times r}\n$$\n$$\nb_r = \\Phi_W^\\top W b \\in \\mathbb{R}^{r}\n$$\n这个较小的 $r$ 维系统使用相同的 RK4 方法和时间步长进行积分。初始条件为 $x_r(0) = \\Phi_W^\\top W x(0) = 0$。然后，使用得到的降阶状态轨迹 $x_r(t_j)$ 来重构高维近似 $\\hat{x}(t_j) = \\Phi_W x_r(t_j)$。\n\n### 4. 误差评估\n每个 ROM 的精度通过能量相对误差 $\\varepsilon_W$ 来量化。至关重要的是要注意，对于所有三个 ROM（使用 $W_E, W_M, W_\\mathcal{E}$ 构建），误差都是在由能量内积矩阵 $E = W_\\mathcal{E}$ 导出的范数中测量的。误差计算如下：\n$$\n\\varepsilon_W = \\sqrt{\\frac{\\sum_{j=0}^N \\|x(t_j) - \\hat{x}(t_j)\\|_{E}^2}{\\sum_{j=0}^N \\|x(t_j)\\|_{E}^2}}\n$$\n其中能量范数的平方为 $\\|y\\|_{E}^2 = y^\\top E y$。\n\n整个过程——FOM 模拟、为三种内积分别构建 POD 基、ROM 模拟和误差计算——会对所提供的三个测试案例中的每一个重复进行。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import cholesky, solve_triangular\n\ndef rk4_step(f, t, y, dt, *args):\n    \"\"\"\n    Performs a single step of the fourth-order Runge-Kutta method.\n    \n    Args:\n        f (callable): The RHS function of the ODE, f(t, y, *args).\n        t (float): Current time.\n        y (np.ndarray): Current state vector (must be a column vector).\n        dt (float): Time step.\n        *args: Additional arguments passed to f.\n        \n    Returns:\n        np.ndarray: The state vector at time t + dt.\n    \"\"\"\n    k1 = dt * f(t, y, *args)\n    k2 = dt * f(t + 0.5 * dt, y + 0.5 * k1, *args)\n    k3 = dt * f(t + 0.5 * dt, y + 0.5 * k2, *args)\n    k4 = dt * f(t + dt, y + k3, *args)\n    return y + (k1 + 2 * k2 + 2 * k3 + k4) / 6.0\n\ndef odefun(t, x, A, b, omega):\n    \"\"\"\n    RHS of the ODE system dx/dt = Ax + b*f(t).\n    \n    Args:\n        t (float): Current time.\n        x (np.ndarray): Current state vector (column vector).\n        A (np.ndarray): State matrix.\n        b (np.ndarray): Forcing vector.\n        omega (float): Forcing frequency.\n        \n    Returns:\n        np.ndarray: The derivative dx/dt.\n    \"\"\"\n    return A @ x + b * np.sin(omega * t)\n\ndef get_pod_basis(snapshots, W, r):\n    \"\"\"\n    Computes a W-orthonormal POD basis of rank r from snapshots.\n    \n    Args:\n        snapshots (np.ndarray): Matrix of state snapshots (dims: n x N_snapshots).\n        W (np.ndarray): Symmetric positive definite weight matrix.\n        r (int): Rank of the desired basis.\n        \n    Returns:\n        np.ndarray: The POD basis matrix Phi (dims: n x r).\n    \"\"\"\n    # 1. Cholesky decomposition of W: W = L @ L.T\n    L = cholesky(W, lower=True)\n\n    # 2. Transform snapshots: X_tilde = L.T @ snapshots\n    X_tilde = L.T @ snapshots\n\n    # 3. SVD of transformed snapshots\n    U, _, _ = np.linalg.svd(X_tilde, full_matrices=False)\n\n    # 4. Truncate basis for transformed system\n    U_r = U[:, :r]\n\n    # 5. Transform basis back by solving L.T @ Phi = U_r for Phi\n    Phi = solve_triangular(L.T, U_r, lower=False, check_finite=False)\n    \n    return Phi\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    # Fixed parameters from the problem statement\n    nu = 0.1\n    alpha = 0.5\n    omega = 1.2\n    T = 10.0\n    dt = 0.005\n\n    # Fixed matrices and vectors\n    k_vals = np.array([1.0, 2.0, 3.0])\n    L_v = np.diag(k_vals**2)\n    D = np.diag([0.7, 0.6, 0.5])\n    S = np.diag([0.4, 0.35, 0.3])\n\n    b_v = np.array([1.0, 0.5, 0.3])\n    b = np.zeros((6, 1))\n    b[0:3, 0] = b_v\n\n    m_v = np.array([1.0, 1.5, 2.0])\n    m_tau = np.array([0.8, 0.9, 1.1])\n    W_M = np.diag(np.concatenate((m_v, m_tau)))\n    W_E_mat = np.eye(6)\n\n    # Test suite\n    test_cases = [\n        (0.1, 0.25, 3),  # Case A\n        (1.0, 0.35, 3),  # Case B\n        (5.0, 0.50, 2)   # Case C\n    ]\n\n    all_results = []\n\n    for Wi, beta, r in test_cases:\n        # ---- 1. Assemble Full-Order Model (FOM) ----\n        A_vv = -nu * L_v\n        A_vt = alpha * D\n        A_tv = beta * S\n        A_tt = -(1.0 / Wi) * np.eye(3)\n        A = np.block([[A_vv, A_vt], [A_tv, A_tt]])\n        \n        # Energy matrix E depends on beta and is used for error measurement\n        E_mat = np.diag(np.concatenate((m_v, np.full(3, 1.0/beta))))\n\n        weight_matrices = [W_E_mat, W_M, E_mat]\n\n        # ---- 2. Simulate FOM to generate snapshots ----\n        n_steps = int(round(T / dt))\n        timesteps = np.linspace(0, T, n_steps + 1)\n        x = np.zeros((6, 1))\n        snapshots = np.zeros((6, n_steps + 1))\n        \n        for i in range(n_steps):\n            x = rk4_step(odefun, timesteps[i], x, dt, A, b, omega)\n            snapshots[:, i + 1] = x.flatten()\n\n        # ---- 3. Build and evaluate ROMs for each inner product ----\n        case_errors = []\n        for W in weight_matrices:\n            # 3a. Construct POD basis\n            Phi = get_pod_basis(snapshots, W, r)\n\n            # 3b. Build ROM\n            Ar = Phi.T @ W @ A @ Phi\n            br = Phi.T @ W @ b\n\n            # 3c. Simulate ROM\n            xr = np.zeros((r, 1))\n            rom_snapshots_r = np.zeros((r, n_steps + 1))\n            \n            for i in range(n_steps):\n                xr = rk4_step(odefun, timesteps[i], xr, dt, Ar, br, omega)\n                rom_snapshots_r[:, i + 1] = xr.flatten()\n            \n            # 3d. Reconstruct full state\n            reconstructed_snapshots = Phi @ rom_snapshots_r\n\n            # 3e. Compute energy-relative error\n            diff = snapshots - reconstructed_snapshots\n            \n            numerator = np.sum(np.sum(diff * (E_mat @ diff), axis=0))\n            denominator = np.sum(np.sum(snapshots * (E_mat @ snapshots), axis=0))\n            \n            relative_error = np.sqrt(numerator / denominator) if denominator > 0 else 0.0\n            \n            case_errors.append(relative_error)\n            \n        all_results.append(case_errors)\n\n    # Final print statement in the exact required format.\n    sublist_strs = [f'[{\",\".join(map(str, sublist))}]' for sublist in all_results]\n    print(f\"[{','.join(sublist_strs)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "降阶模型的最终目标之一是提升计算效率。本练习  将重点从模型精度转向模型性能。你将建立一个解析性能模型，以理解为何标准的伽辽金投影在处理非线性项时效率不高，以及超降阶技术如何解决这一瓶颈。通过运用roofline模型，本练习将理论上的浮点运算（FLOP）计数与实际的硬件性能极限联系起来，让你对降阶模型可能带来的显著计算加速有一个定量的认识。",
            "id": "4101583",
            "problem": "要求您实现一个解析性能模型，以量化在使用本征正交分解（POD）和伽辽金方法（有或无超降阶）时，非线性复杂流动的降阶模型的在线阶段加速比。重点是剖析浮点运算计数和内存流量，并使用屋顶线性能模型预测求解时间。您必须实现一个程序，为多个参数集计算预测的在线加速比。\n\n推导的基本出发点是一个半离散动力系统，该系统由非线性守恒律的空间离散化（例如，有限体积或有限元）得到，可写为\n$$\n\\frac{d \\mathbf{u}}{dt} = \\mathbf{A}\\,\\mathbf{u} + \\mathbf{N}(\\mathbf{u}) + \\mathbf{f},\n$$\n其中 $\\mathbf{u}\\in\\mathbb{R}^{N_h}$ 是高维状态，$\\mathbf{A}\\in\\mathbb{R}^{N_h\\times N_h}$ 是一个线性算子，$\\mathbf{N}(\\cdot)$ 是一个非线性算子，$\\mathbf{f}\\in\\mathbb{R}^{N_h}$ 是一个强迫项。通过本征正交分解（POD）获得一个降阶基 $\\mathbf{V}\\in\\mathbb{R}^{N_h\\times r}$，状态近似为 $\\mathbf{u}\\approx \\mathbf{V}\\,\\mathbf{a}$，其中 $\\mathbf{a}\\in\\mathbb{R}^{r}$ 是降阶坐标。伽辽金投影产生一个在线降阶系统\n$$\n\\frac{d \\mathbf{a}}{dt} = \\mathbf{V}^T\\left(\\mathbf{A}\\,\\mathbf{V}\\,\\mathbf{a} + \\mathbf{N}(\\mathbf{V}\\,\\mathbf{a}) + \\mathbf{f}\\right).\n$$\n对于线性项，假设降阶算子 $\\mathbf{M}=\\mathbf{V}^T\\mathbf{A}\\mathbf{V}\\in\\mathbb{R}^{r\\times r}$ 的离线预计算是可用的，因此在线线性贡献是 $\\mathbf{M}\\,\\mathbf{a}$。对于非线性项，考虑两种在线策略：\n- 无超降阶：直接在全维 $N_h$ 上评估 $\\mathbf{N}(\\mathbf{V}\\,\\mathbf{a})$，然后用 $\\mathbf{V}^T$ 进行投影。\n- 使用超降阶：使用基于采样的超降阶方法，如离散经验插值方法（DEIM）或能量守恒采样与加权（ECSW）。其模型如下：通过一个采样算子 $\\mathbf{P}\\in\\mathbb{R}^{N_h\\times s}$ 选择 $s$ 个采样自由度，预计算一个降阶采样基，以便在线时可以使用 $\\mathbf{V}_s=\\mathbf{P}^T\\mathbf{V}\\in\\mathbb{R}^{s\\times r}$ 形成采样状态，并用 $\\mathbf{u}_s=\\mathbf{V}_s\\,\\mathbf{a}$ 评估采样非线性项 $\\mathbf{n}_s=\\mathbf{N}_s(\\mathbf{u}_s)\\in\\mathbb{R}^{s}$。假设存在一个预计算的投影映射 $\\mathbf{W}\\in\\mathbb{R}^{r\\times s}$，使得降阶非线性项近似为 $\\mathbf{W}\\,\\mathbf{n}_s$。\n\n采用以下经过充分测试的性能建模假设：\n- 一个大小为 $m\\times n$ 的稠密矩阵向量乘法在使用双精度存储（每个标量占8字节）时，需要 $2\\,m\\,n$ 次浮点运算（FLOPs），并产生 $8\\,(m\\,n + m + n)$ 字节的内存流。\n- 在 $k$ 个自由度上评估非线性算子需要 $c_n\\,k$ 次FLOPs，并产生 $b_n\\,k$ 字节的内存流，其中 $c_n$（单位：FLOPs/条目）和 $b_n$（单位：字节/条目）是给定的参数，用于模拟数值模板和数据访问模式。\n- 屋顶线模型给出的每次在线评估的时间为\n$$\nT = \\max\\left(\\frac{F}{F_{\\text{peak}}}, \\frac{Q}{B_{\\text{peak}}}\\right),\n$$\n其中 $F$ 是FLOPs计数，$Q$ 是流过的字节数，$F_{\\text{peak}}$ 是硬件峰值浮点速率（单位：FLOPs/秒），$B_{\\text{peak}}$ 是可持续内存带宽（单位：字节/秒）。时间以秒为单位表示。\n\n根据上述操作的基本原理，推导并实现以下每个时间步的在线成本模型：\n\n- 无超降阶：\n  - 计算 $\\mathbf{u}=\\mathbf{V}\\,\\mathbf{a}$：FLOPs $F_1=2\\,N_h\\,r$，字节 $Q_1=8\\,(N_h\\,r + N_h + r)$。\n  - 评估 $\\mathbf{n}=\\mathbf{N}(\\mathbf{u})$：FLOPs $F_2=c_n\\,N_h$，字节 $Q_2=b_n\\,N_h$。\n  - 投影 $\\mathbf{g}=\\mathbf{V}^T\\,\\mathbf{n}$：FLOPs $F_3=2\\,N_h\\,r$，字节 $Q_3=8\\,(N_h\\,r + N_h + r)$。\n  - 线性项 $\\mathbf{M}\\,\\mathbf{a}$：FLOPs $F_4=2\\,r^2$，字节 $Q_4=8\\,(r^2 + 2\\,r)$。\n  - 总计：$F_{\\text{noHR}} = F_1 + F_2 + F_3 + F_4$ 和 $Q_{\\text{noHR}} = Q_1 + Q_2 + Q_3 + Q_4$。\n\n- 使用超降阶：\n  - 计算采样状态 $\\mathbf{u}_s=\\mathbf{V}_s\\,\\mathbf{a}$：FLOPs $f_1=2\\,s\\,r$，字节 $q_1=8\\,(s\\,r + s + r)$。\n  - 评估采样非线性项 $\\mathbf{n}_s$：FLOPs $f_2=c_n\\,s$，字节 $q_2=b_n\\,s$。\n  - 投影 $\\mathbf{W}\\,\\mathbf{n}_s$：FLOPs $f_3=2\\,r\\,s$，字节 $q_3=8\\,(r\\,s + r + s)$。\n  - 线性项 $\\mathbf{M}\\,\\mathbf{a}$：FLOPs $f_4=2\\,r^2$，字节 $q_4=8\\,(r^2 + 2\\,r)$。\n  - 总计：$F_{\\text{HR}} = f_1 + f_2 + f_3 + f_4$ 和 $Q_{\\text{HR}} = q_1 + q_2 + q_3 + q_4$。\n\n使用屋顶线模型计算 $T_{\\text{noHR}}$ 和 $T_{\\text{HR}}$（单位：秒），并报告在线加速比\n$$\nS \\equiv \\frac{T_{\\text{noHR}}}{T_{\\text{HR}}}.\n$$\n\n实现一个程序，对于给定的参数集列表，输出一行包含每个案例的加速比 $S$ 的列表，四舍五入到六位小数。此问题不涉及角度或百分比。中间建模中时间必须以秒为单位，但报告的加速比是无量纲的。始终使用双精度（每个标量8字节）。\n\n测试套件（每个元组为 $(N_h, r, s, c_n, b_n, F_{\\text{peak}}, B_{\\text{peak}})$）：\n- 案例1（通用，中度计算密集型）：$(100000, 60, 300, 60, 16, 2.0\\times 10^{12}, 2.0\\times 10^{11})$\n- 案例2（内存密集型场景）：$(100000, 60, 120, 60, 16, 4.0\\times 10^{12}, 5.0\\times 10^{10})$\n- 案例3（无有效超降阶，$s=N_h$）：$(5000, 40, 5000, 40, 16, 1.0\\times 10^{12}, 1.0\\times 10^{11})$\n- 案例4（小网格，较高的 $c_n$ 和 $b_n$）：$(1000, 20, 50, 80, 24, 5.0\\times 10^{11}, 1.0\\times 10^{11})$\n- 案例5（大网格，重非线性）：$(200000, 80, 200, 200, 32, 2.5\\times 10^{12}, 1.5\\times 10^{11})$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[result1,result2,result3,result4,result5]\"），其中每个结果是相应案例的加速比 $S$，四舍五入为六位小数的十进制数。",
            "solution": "目标是开发并实现一个解析性能模型，以预测在本征正交分解（POD）伽辽金降阶模型（ROM）的背景下，超降阶所能带来的在线阶段加速比。加速比（记为 $S$）定义为标准伽辽金投影ROM每时间步的求解时间与采用超降阶的ROM每时间步的求解时间之比。\n\n分析始于为高维状态 $\\mathbf{u} \\in \\mathbb{R}^{N_h}$ 提供的半离散系统：\n$$\n\\frac{d \\mathbf{u}}{dt} = \\mathbf{A}\\,\\mathbf{u} + \\mathbf{N}(\\mathbf{u}) + \\mathbf{f}\n$$\n状态在降阶基 $\\mathbf{V} \\in \\mathbb{R}^{N_h \\times r}$ 中近似为 $\\mathbf{u} \\approx \\mathbf{V}\\,\\mathbf{a}$，其中 $\\mathbf{a} \\in \\mathbb{R}^{r}$ 是降阶坐标，且 $r \\ll N_h$。伽辽金投影得到降阶系统：\n$$\n\\frac{d \\mathbf{a}}{dt} = \\mathbf{V}^T\\mathbf{A}\\mathbf{V}\\,\\mathbf{a} + \\mathbf{V}^T\\mathbf{N}(\\mathbf{V}\\,\\mathbf{a}) + \\mathbf{V}^T\\mathbf{f}\n$$\n假设强迫项 $\\mathbf{V}^T\\mathbf{f}$ 和线性算子 $\\mathbf{M} = \\mathbf{V}^T\\mathbf{A}\\mathbf{V} \\in \\mathbb{R}^{r \\times r}$ 已离线预计算。主要的在线计算成本来自于对降阶非线性项的评估，我们将在两种情况下对其进行分析。\n\n每种情况的性能都使用屋顶线模型进行量化，该模型为求解时间 $T$ 提供了一个估计：\n$$\nT = \\max\\left(\\frac{F}{F_{\\text{peak}}},\\ \\frac{Q}{B_{\\text{peak}}}\\right)\n$$\n这里，$F$ 表示总浮点运算次数（FLOPs），$Q$ 是总内存流量（以字节为单位），$F_{\\text{peak}}$ 是硬件的峰值计算速率（以FLOPs/秒为单位），$B_{\\text{peak}}$ 是可持续的内存带宽（以字节/秒为单位）。我们假设使用双精度浮点数，每个标量占用8个字节。\n\n**1. 无超降阶的在线成本 ($T_{\\text{noHR}}$)**\n\n在这种标准的伽辽金方法中，非线性项 $\\mathbf{N}(\\mathbf{V}\\,\\mathbf{a})$ 在全维 $N_h$ 上进行评估，然后投影到降阶基上。每个时间步的在线计算步骤如下：\n\n1.  重构全维状态：$\\mathbf{u}=\\mathbf{V}\\,\\mathbf{a}$。这是一个大小为 $N_h \\times r$ 的矩阵与一个大小为 $r$ 的向量之间的稠密矩阵向量乘法。\n    -   FLOPs: $F_1 = 2\\,N_h\\,r$。\n    -   字节: $Q_1 = 8\\,(N_h\\,r + N_h + r)$。这包括了传输矩阵 $\\mathbf{V}$、向量 $\\mathbf{a}$ 和结果向量 $\\mathbf{u}$ 的开销。\n\n2.  评估非线性项：$\\mathbf{n}=\\mathbf{N}(\\mathbf{u})$。这在完整的 $N_h$ 维状态向量上执行。\n    -   FLOPs: $F_2 = c_n\\,N_h$。\n    -   字节: $Q_2 = b_n\\,N_h$。参数 $c_n$ 和 $b_n$ 模拟了每个条目的计算和内存成本。\n\n3.  投影非线性项：$\\mathbf{g}=\\mathbf{V}^T\\,\\mathbf{n}$。这是一个大小为 $r \\times N_h$ 的矩阵与一个大小为 $N_h$ 的向量之间的稠密矩阵向量乘法。\n    -   FLOPs: $F_3 = 2\\,r\\,N_h$。\n    -   字节: $Q_3 = 8\\,(r\\,N_h + r + N_h)$。这包括了传输 $\\mathbf{V}^T$、$\\mathbf{n}$ 和结果 $\\mathbf{g}$ 的开销。\n\n4.  计算线性项贡献：$\\mathbf{M}\\,\\mathbf{a}$。这是一个涉及预计算的 $r \\times r$ 矩阵 $\\mathbf{M}$ 的稠密矩阵向量乘法。\n    -   FLOPs: $F_4 = 2\\,r^2$。\n    -   字节: $Q_4 = 8\\,(r^2 + 2\\,r)$。这传输了 $\\mathbf{M}$、$\\mathbf{a}$ 和结果。\n\n每一步的总FLOPs和内存流量是这些贡献的总和：\n$$\nF_{\\text{noHR}} = F_1 + F_2 + F_3 + F_4 = 4\\,N_h\\,r + c_n\\,N_h + 2\\,r^2\n$$\n$$\nQ_{\\text{noHR}} = Q_1 + Q_2 + Q_3 + Q_4 = 16\\,(N_h\\,r + N_h + r) + b_n\\,N_h + 8\\,(r^2 + 2\\,r)\n$$\n然后，求解时间由屋顶线模型给出：\n$$\nT_{\\text{noHR}} = \\max\\left(\\frac{F_{\\text{noHR}}}{F_{\\text{peak}}},\\ \\frac{Q_{\\text{noHR}}}{B_{\\text{peak}}}\\right)\n$$\n\n**2. 使用超降阶的在线成本 ($T_{\\text{HR}}$)**\n\n像DEIM或ECSW这样的超降阶方法通过仅使用 $s$ 个精心选择的采样点来近似非线性项，从而避免了在全维 $N_h$ 上的计算，其中 $s$ 通常与 $r$ 的数量级相同。在线计算步骤如下：\n\n1.  计算采样状态：$\\mathbf{u}_s=\\mathbf{V}_s\\,\\mathbf{a}$。这使用了预计算的采样基 $\\mathbf{V}_s \\in \\mathbb{R}^{s \\times r}$。\n    -   FLOPs: $f_1 = 2\\,s\\,r$。\n    -   字节: $q_1 = 8\\,(s\\,r + s + r)$。\n\n2.  评估采样非线性项：$\\mathbf{n}_s=\\mathbf{N}_s(\\mathbf{u}_s)$。这仅在 $s$ 个采样点上进行评估。\n    -   FLOPs: $f_2 = c_n\\,s$。\n    -   字节: $q_2 = b_n\\,s$。\n\n3.  将采样非线性项投影到降阶空间：$\\mathbf{W}\\,\\mathbf{n}_s$。这使用了预计算的投影映射 $\\mathbf{W} \\in \\mathbb{R}^{r \\times s}$。\n    -   FLOPs: $f_3 = 2\\,r\\,s$。\n    -   字节: $q_3 = 8\\,(r\\,s + r + s)$。\n\n4.  计算线性项贡献：$\\mathbf{M}\\,\\mathbf{a}$。此步骤与非超降阶情况相同。\n    -   FLOPs: $f_4 = 2\\,r^2$。\n    -   字节: $q_4 = 8\\,(r^2 + 2\\,r)$。\n\n每一步的总FLOPs和内存流量为：\n$$\nF_{\\text{HR}} = f_1 + f_2 + f_3 + f_4 = 4\\,s\\,r + c_n\\,s + 2\\,r^2\n$$\n$$\nQ_{\\text{HR}} = q_1 + q_2 + q_3 + q_4 = 16\\,(s\\,r + s + r) + b_n\\,s + 8\\,(r^2 + 2\\,r)\n$$\n求解时间为：\n$$\nT_{\\text{HR}} = \\max\\left(\\frac{F_{\\text{HR}}}{F_{\\text{peak}}},\\ \\frac{Q_{\\text{HR}}}{B_{\\text{peak}}}\\right)\n$$\n\n**3. 在线加速比**\n\n在线加速比 $S$ 是无超降阶的每步时间与有超降阶的每步时间之比：\n$$\nS = \\frac{T_{\\text{noHR}}}{T_{\\text{HR}}}\n$$\n$S > 1$ 的值表示超降阶对于在线阶段是有益的。以下程序将实现这些计算，以计算给定参数集的 $S$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the predicted online speedup for a reduced-order model \n    with and without hyper-reduction, based on a roofline performance model.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (N_h, r, s, c_n, b_n, F_peak, B_peak)\n    test_cases = [\n        (100000, 60, 300, 60, 16, 2.0e12, 2.0e11),\n        (100000, 60, 120, 60, 16, 4.0e12, 5.0e10),\n        (5000, 40, 5000, 40, 16, 1.0e12, 1.0e11),\n        (1000, 20, 50, 80, 24, 5.0e11, 1.0e11),\n        (200000, 80, 200, 200, 32, 2.5e12, 1.5e11),\n    ]\n\n    results = []\n    for N_h, r, s, c_n, b_n, F_peak, B_peak in test_cases:\n        # --- Cost Model without Hyper-Reduction (noHR) ---\n        \n        # FLOPs calculation\n        F1_noHR = 2 * N_h * r\n        F2_noHR = c_n * N_h\n        F3_noHR = 2 * N_h * r\n        F4_noHR = 2 * r**2\n        F_noHR = F1_noHR + F2_noHR + F3_noHR + F4_noHR\n        \n        # Memory traffic calculation (in bytes)\n        Q1_noHR = 8 * (N_h * r + N_h + r)\n        Q2_noHR = b_n * N_h\n        Q3_noHR = 8 * (N_h * r + N_h + r)\n        Q4_noHR = 8 * (r**2 + 2 * r)\n        Q_noHR = Q1_noHR + Q2_noHR + Q3_noHR + Q4_noHR\n        \n        # Time-to-solution using Roofline model\n        T_noHR = max(F_noHR / F_peak, Q_noHR / B_peak)\n        \n        # --- Cost Model with Hyper-Reduction (HR) ---\n        \n        # FLOPs calculation\n        f1_HR = 2 * s * r\n        f2_HR = c_n * s\n        f3_HR = 2 * r * s\n        f4_HR = 2 * r**2\n        F_HR = f1_HR + f2_HR + f3_HR + f4_HR\n        \n        # Memory traffic calculation (in bytes)\n        q1_HR = 8 * (s * r + s + r)\n        q2_HR = b_n * s\n        q3_HR = 8 * (r * s + r + s)\n        q4_HR = 8 * (r**2 + 2 * r)\n        Q_HR = q1_HR + q2_HR + q3_HR + q4_HR\n        \n        # Time-to-solution using Roofline model\n        T_HR = max(F_HR / F_peak, Q_HR / B_peak)\n        \n        # --- Speedup Calculation ---\n        \n        # Handle case where T_HR might be zero to avoid division by zero error\n        if T_HR > 0:\n            speedup = T_noHR / T_HR\n        else:\n            # If T_HR is zero, speedup is effectively infinite, but this\n            # should not happen with the given positive parameters.\n            # We can define it as 1.0 (no speedup) if both times are zero.\n            speedup = 1.0 if T_noHR == 0 else float('inf')\n\n        results.append(round(speedup, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{res:.6f}' for res in results)}]\")\n\nsolve()\n```"
        }
    ]
}