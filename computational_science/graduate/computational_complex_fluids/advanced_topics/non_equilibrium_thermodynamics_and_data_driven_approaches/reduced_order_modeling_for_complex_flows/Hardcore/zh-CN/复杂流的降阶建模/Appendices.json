{
    "hands_on_practices": [
        {
            "introduction": "本征正交分解（POD）的核心在于识别流场数据中的主导模式。与每个模式相关的“能量”（与其奇异值相关）使我们能够对它们的重要性进行排序。本练习将指导你完成一项基本任务：给定一组流场快照，计算其能量谱，并确定为达到预设的能量捕获率所需的最小模式数量。",
            "id": "4101511",
            "problem": "考虑一组向量值流场快照，它们以列的形式排列在一个矩阵 $X \\in \\mathbb{R}^{n \\times m}$ 中，其中每一列 $x_j \\in \\mathbb{R}^n$ 代表在时间索引 $j \\in \\{1,\\dots,m\\}$ 时一个复杂流体流动的离散状态。假设在 $\\mathbb{R}^n$ 上使用标准欧几里得内积，并将一个快照 $x_j$ 的能量定义为 $\\|x_j\\|_2^2$。令均值中心化快照矩阵为 $\\tilde{X} = X - \\bar{x}\\mathbf{1}^\\top$，其中 $\\bar{x} = \\frac{1}{m} X \\mathbf{1}$，$\\mathbf{1} \\in \\mathbb{R}^m$ 是全为一的向量。对 $\\tilde{X}$ 进行奇异值分解 (SVD)，其形式为 $\\tilde{X} = U \\Sigma V^\\top$，其中 $U \\in \\mathbb{R}^{n \\times r^\\star}$ 具有标准正交列，$\\Sigma \\in \\mathbb{R}^{r^\\star \\times r^\\star}$ 是对角矩阵，其对角线元素为非负值 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge \\sigma_{r^\\star} \\ge 0$，$V \\in \\mathbb{R}^{m \\times r^\\star}$ 具有标准正交列，且 $r^\\star = \\operatorname{rank}(\\tilde{X})$。将前 $r$ 个模态所捕获的本征正交分解 (POD) 能量定义为累积分数\n$$\nE(r) = \\frac{\\sum_{k=1}^{r} \\sigma_k^2}{\\sum_{k=1}^{m} \\sigma_k^2},\n$$\n约定当 $k  r^\\star$ 时 $\\sigma_k = 0$，且分母等于 $\\|\\tilde{X}\\|_F^2 = \\sum_{k=1}^{r^\\star} \\sigma_k^2$。对于给定的容差 $\\epsilon \\in [0,1]$，定义\n$$\nr_{\\min}(\\epsilon) = \\min\\{r \\in \\{0,1,\\dots,m\\} \\mid E(r) \\ge \\epsilon\\},\n$$\n并约定 $E(0) = 0$。\n\n您的任务是编写一个程序，对于每个指定的测试用例，使用从给定 $X$ 构建的均值中心化快照矩阵 $\\tilde{X}$，计算给定查询 $r_q$ 的 $E(r_q)$ 并确定给定容差 $\\epsilon$ 的 $r_{\\min}(\\epsilon)$。\n\n请使用以下测试套件。在所有情况下，索引为 $i \\in \\{1,\\dots,n\\}$ 和 $j \\in \\{1,\\dots,m\\}$，三角函数作用于弧度，且所有量均为无量纲。\n\n- 测试用例 1 (通用多频流):\n  - $n = 64$, $m = 32$。\n  - $X_{ij} = \\sin\\!\\left(\\frac{2\\pi i}{n}\\right)\\cos\\!\\left(\\frac{2\\pi j}{m}\\right) + 0.4\\,\\sin\\!\\left(\\frac{4\\pi i}{n}\\right)\\sin\\!\\left(\\frac{3\\pi j}{m}\\right)$。\n  - $r_q = 5$。\n  - $\\epsilon = 0.95$。\n\n- 测试用例 2 (近秩二结构，高容差边界):\n  - $n = 50$, $m = 50$。\n  - $X_{ij} = \\frac{i}{n} + \\frac{j}{m}$。\n  - $r_q = 2$。\n  - $\\epsilon = 0.999$。\n\n- 测试用例 3 (受控模态叠加):\n  - $n = 60$, $m = 45$。\n  - 定义 $u_p(i) = \\sin\\!\\left(\\frac{2\\pi p i}{n}\\right)$ 和 $v_p(j) = \\cos\\!\\left(\\frac{2\\pi p j}{m}\\right)$，对于 $p \\in \\{1,2,3\\}$，权重为 $a_1 = 2.0$, $a_2 = 1.0$, $a_3 = 0.5$。构造 $X = \\sum_{p=1}^{3} a_p\\, u_p\\, v_p^\\top$。\n  - $r_q = 2$。\n  - $\\epsilon = 0.90$。\n\n- 测试用例 4 (秩一结构，小容差和查询边缘):\n  - $n = 40$, $m = 20$。\n  - $X_{ij} = 0.01\\,\\sin\\!\\left(\\frac{2\\pi i}{n}\\right)\\cos\\!\\left(\\frac{2\\pi j}{m}\\right)$。\n  - $r_q = 0$。\n  - $\\epsilon = 0.01$。\n\n最终输出格式：您的程序应生成单行文本，其中包含一个 Python 风格的配对列表，每个测试用例对应一对，其中每对是 $[E(r_q), r_{\\min}(\\epsilon)]$。该列表必须与测试用例的顺序相同。例如，输出必须类似于 `[ [ratio1,r1],[ratio2,r2],[ratio3,r3],[ratio4,r4] ]`，其中每个 `ratioK` 是 $[0,1]$ 内的浮点数，每个 `rK` 是 $\\{0,1,\\dots,m\\}$ 内的整数。",
            "solution": "在尝试给出解决方案之前，用户提供的问题陈述会经过严格的验证过程。\n\n### 步骤 1：提取的已知条件\n- **快照矩阵**：$X \\in \\mathbb{R}^{n \\times m}$，其中列 $x_j \\in \\mathbb{R}^n$ 是 $j \\in \\{1,\\dots,m\\}$ 时的流场状态。\n- **能量定义**：快照 $x_j$ 的能量是 $\\|x_j\\|_2^2$。\n- **均值中心化矩阵**：$\\tilde{X} = X - \\bar{x}\\mathbf{1}^\\top$，其中 $\\bar{x} = \\frac{1}{m} X \\mathbf{1}$ 是 $X$ 的列均值。\n- **奇异值分解 (SVD)**：$\\tilde{X} = U \\Sigma V^\\top$，其中 $U \\in \\mathbb{R}^{n \\times r^\\star}$，$\\Sigma \\in \\mathbb{R}^{r^\\star \\times r^\\star}$ 是对角矩阵，其奇异值为 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge \\sigma_{r^\\star} \\ge 0$，$V \\in \\mathbb{R}^{m \\times r^\\star}$。$r^\\star = \\operatorname{rank}(\\tilde{X})$。\n- **POD 能量函数**：前 $r$ 个模态捕获的能量累积比例为 $E(r) = \\frac{\\sum_{k=1}^{r} \\sigma_k^2}{\\sum_{k=1}^{m} \\sigma_k^2}$。\n- **$E(r)$ 的约定**：当 $k  r^\\star$ 时，$\\sigma_k = 0$。分母为 $\\|\\tilde{X}\\|_F^2$。\n- **最小秩函数**：对于容差 $\\epsilon \\in [0,1]$，$r_{\\min}(\\epsilon) = \\min\\{r \\in \\{0,1,\\dots,m\\} \\mid E(r) \\ge \\epsilon\\}$。\n- **$r_{\\min}(\\epsilon)$ 的约定**：$E(0) = 0$。\n- **任务**：对于每个测试用例，计算 $E(r_q)$ 和 $r_{\\min}(\\epsilon)$。\n- **测试用例 1**：\n  - $n = 64$, $m = 32$。\n  - $X_{ij} = \\sin\\!\\left(\\frac{2\\pi i}{n}\\right)\\cos\\!\\left(\\frac{2\\pi j}{m}\\right) + 0.4\\,\\sin\\!\\left(\\frac{4\\pi i}{n}\\right)\\sin\\!\\left(\\frac{3\\pi j}{m}\\right)$。\n  - $r_q = 5$。\n  - $\\epsilon = 0.95$。\n- **测试用例 2**：\n  - $n = 50$, $m = 50$。\n  - $X_{ij} = \\frac{i}{n} + \\frac{j}{m}$。\n  - $r_q = 2$。\n  - $\\epsilon = 0.999$。\n- **测试用例 3**：\n  - $n = 60$, $m = 45$。\n  - $X = \\sum_{p=1}^{3} a_p\\, u_p\\, v_p^\\top$，其中 $u_p(i) = \\sin\\!\\left(\\frac{2\\pi p i}{n}\\right)$, $v_p(j) = \\cos\\!\\left(\\frac{2\\pi p j}{m}\\right)$，权重 $a_1 = 2.0$, $a_2 = 1.0$, $a_3 = 0.5$。\n  - $r_q = 2$。\n  - $\\epsilon = 0.90$。\n- **测试用例 4**：\n  - $n = 40$, $m = 20$。\n  - $X_{ij} = 0.01\\,\\sin\\!\\left(\\frac{2\\pi i}{n}\\right)\\cos\\!\\left(\\frac{2\\pi j}{m}\\right)$。\n  - $r_q = 0$。\n  - $\\epsilon = 0.01$。\n- **通用规则**：索引 $i \\in \\{1,\\dots,n\\}$ 和 $j \\in \\{1,\\dots,m\\}$。三角函数使用弧度。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据既定的验证标准对问题进行评估。\n1.  **科学依据**：该问题植根于线性代数（SVD）和计算流体动力学（本征正交分解）的既定原理。POD 是一种用于复杂系统模型降阶的标准、广泛使用的技术。快照能量、均值中心化和累积能量分数的定义在该领域是标准的。该问题是科学合理的。\n2.  **适定性**：该问题提供了清晰、明确的执行步骤。对于每个测试用例，所有输入（$X$, $r_q$, $\\epsilon$）都被明确定义。输出（$E(r_q)$, $r_{\\min}(\\epsilon)$）由所定义的数学运算（均值中心化、SVD、求和）的应用唯一确定。每种情况都存在唯一且稳定的解。\n3.  **客观性**：该问题以精确、形式化的数学语言陈述。没有主观看法、意见或歧义。\n4.  **完整性与一致性**：该问题是自包含的。所有必需的矩阵、参数和函数都有定义。这些定义是内部一致的；例如，$E(r)$ 的分母被正确定为 $\\tilde{X}$ 的弗罗贝尼乌斯范数的平方，而后者又等于奇异值平方和。\n5.  **非不切实际或不可行**：测试用例涉及从行为良好的数学函数构造矩阵并执行标准数值计算。矩阵的维度适中，计算上是可行的。\n6.  **非不适定或琐碎**：该问题需要一个非平凡的数值算法实现，涉及矩阵构造、均值中心化、SVD以及对奇异值的分析。测试用例旨在探究不同情景（多模态、低秩、减去均值效应），展示了超越简单计算的概念深度。例如，测试用例3和4具有零均值结构，简化了 $\\tilde{X}=X$，而测试用例2具有非零均值，减去均值后，矩阵的秩降为1。这些是微妙而重要的特征。\n\n### 步骤 3：结论与行动\n该问题被判定为**有效**。它具有科学依据、适定、客观且计算上可行。将提供一个完整的解决方案。\n\n### 解决方案与算法设计\n\n任务是为几个测试用例计算两个量：给定秩 $r_q$ 的 POD 能量 $E(r_q)$，以及捕获总能量比例 $\\epsilon$ 所需的最小秩 $r_{\\min}(\\epsilon)$。该过程基于对均值中心化数据的奇异值分解 (SVD)。\n\n每个测试用例的算法流程如下：\n\n1.  **构造快照矩阵 $X$**：对于给定的 $n \\times m$ 维度的测试用例，我们首先构造矩阵 $X \\in \\mathbb{R}^{n \\times m}$。元素 $X_{ij}$ 由所提供的公式定义，密切注意对于 $i \\in \\{1, \\dots, n\\}$ 和 $j \\in \\{1, \\dots, m\\}$ 的基于1的索引。\n\n2.  **计算均值中心化矩阵 $\\tilde{X}$**：POD分析波动的基础是减去平均状态。我们通过平均 $X$ 的所有列来计算时间平均快照 $\\bar{x} \\in \\mathbb{R}^n$：\n    $$ \\bar{x} = \\frac{1}{m} \\sum_{j=1}^{m} x_j $$\n    然后，我们通过从每一列 $x_j$ 中减去 $\\bar{x}$ 来形成均值中心化（或波动）矩阵 $\\tilde{X} \\in \\mathbb{R}^{n \\times m}$：\n    $$ \\tilde{X} = X - \\bar{x}\\mathbf{1}^\\top $$\n    其中 $\\mathbf{1}^\\top$ 是一个包含 $m$ 个1的行向量。\n\n3.  **执行奇异值分解**：我们计算均值中心化矩阵 $\\tilde{X}$ 的 SVD。\n    $$ \\tilde{X} = U \\Sigma V^\\top $$\n    该分解产生 $U$ 中的左奇异向量（POD 模态）、$V$ 中的右奇异向量以及 $\\Sigma$ 对角线上的奇异值 $\\sigma_k$。为了我们的目的，只需要奇异值 $\\sigma_k$。我们通过标准的数值SVD例程将它们作为一个一维数组 $\\mathbf{s} = [\\sigma_1, \\sigma_2, \\dots, \\sigma_{\\min(n,m)}]$ 获得。\n\n4.  **计算累积能谱**：每个 POD 模态的能量与其对应奇异值的平方成正比。波动中的总能量是所有模态能量之和，等于 $\\tilde{X}$ 的弗罗贝尼乌斯范数的平方：\n    $$ \\mathcal{E}_{\\text{total}} = \\|\\tilde{X}\\|_F^2 = \\sum_{k=1}^{r^\\star} \\sigma_k^2 $$\n    前 $r$ 个模态捕获的能量是 $\\sum_{k=1}^{r} \\sigma_k^2$。累积能量分数则为：\n    $$ E(r) = \\frac{\\sum_{k=1}^{r} \\sigma_k^2}{\\mathcal{E}_{\\text{total}}} $$\n    我们为所有可能的 $r$ 值（从1到 $r^\\star = \\operatorname{rank}(\\tilde{X})$）计算此值。这可以通过先将所有奇异值平方，然后计算它们的累积和来高效完成。如果 $\\mathcal{E}_{\\text{total}}$ 在数值上为零，则所有波动能量都为零，我们定义对于 $r  0$，$E(r) = 1.0$。\n\n5.  **确定 $E(r_q)$**：使用计算出的累积能谱和给定的查询秩 $r_q$：\n    - 如果 $r_q = 0$，根据定义，$E(0) = 0$。\n    - 如果 $r_q  0$，我们从预先计算的累积能量分数数组中找到 $E(r_q)$。如果 $r_q$ 大于可用奇异值的数量，则意味着所有能量都已被捕获，因此 $E(r_q) = 1$。\n\n6.  **确定 $r_{\\min}(\\epsilon)$**：使用给定的容差 $\\epsilon \\in [0,1]$：\n    - 如果 $\\epsilon \\le 0$，因为 $E(0)=0$，所以条件 $E(r) \\ge \\epsilon$ 对于 $r=0$ 成立。因此，$r_{\\min}(\\epsilon) = 0$。\n    - 如果 $\\epsilon  0$，我们搜索最小的整数 $r \\ge 1$ 使得 $E(r) \\ge \\epsilon$。这可以通过在累积能量分数的排序数组中搜索第一个大于或等于 $\\epsilon$ 的元素来高效地找到。秩 $r$ 是该元素的索引加一。\n\n将此结构化过程应用于每个测试用例，以生成所需的值对 $[E(r_q), r_{\\min}(\\epsilon)]$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the POD problem for all test cases.\n    \"\"\"\n\n    def generate_x_case1(n, m):\n        \"\"\"Generates the snapshot matrix X for Test Case 1.\"\"\"\n        i_vals = np.arange(1, n + 1).reshape(-1, 1)\n        j_vals = np.arange(1, m + 1).reshape(1, -1)\n        x = (np.sin(2 * np.pi * i_vals / n) * np.cos(2 * np.pi * j_vals / m) +\n             0.4 * np.sin(4 * np.pi * i_vals / n) * np.sin(3 * np.pi * j_vals / m))\n        return x\n\n    def generate_x_case2(n, m):\n        \"\"\"Generates the snapshot matrix X for Test Case 2.\"\"\"\n        i_vals = np.arange(1, n + 1).reshape(-1, 1)\n        j_vals = np.arange(1, m + 1).reshape(1, -1)\n        x = i_vals / n + j_vals / m\n        return x\n\n    def generate_x_case3(n, m):\n        \"\"\"Generates the snapshot matrix X for Test Case 3.\"\"\"\n        i_vals = np.arange(1, n + 1).reshape(-1, 1)\n        j_vals = np.arange(1, m + 1).reshape(1, -1)\n        weights = [2.0, 1.0, 0.5]\n        x = np.zeros((n, m))\n        for p_idx, p in enumerate(range(1, 4)):\n            a_p = weights[p_idx]\n            u_p = np.sin(2 * np.pi * p * i_vals / n)\n            v_p_T = np.cos(2 * np.pi * p * j_vals / m)\n            x += a_p * (u_p @ v_p_T)\n        return x\n\n    def generate_x_case4(n, m):\n        \"\"\"Generates the snapshot matrix X for Test Case 4.\"\"\"\n        i_vals = np.arange(1, n + 1).reshape(-1, 1)\n        j_vals = np.arange(1, m + 1).reshape(1, -1)\n        x = 0.01 * np.sin(2 * np.pi * i_vals / n) * np.cos(2 * np.pi * j_vals / m)\n        return x\n\n    test_cases = [\n        {'n': 64, 'm': 32, 'gen_x': generate_x_case1, 'r_q': 5, 'epsilon': 0.95},\n        {'n': 50, 'm': 50, 'gen_x': generate_x_case2, 'r_q': 2, 'epsilon': 0.999},\n        {'n': 60, 'm': 45, 'gen_x': generate_x_case3, 'r_q': 2, 'epsilon': 0.90},\n        {'n': 40, 'm': 20, 'gen_x': generate_x_case4, 'r_q': 0, 'epsilon': 0.01},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        n, m, gen_x, r_q, epsilon = case['n'], case['m'], case['gen_x'], case['r_q'], case['epsilon']\n\n        # Step 1: Construct the snapshot matrix X\n        X = gen_x(n, m)\n\n        # Step 2: Compute the mean-centered matrix X_tilde\n        x_mean = X.mean(axis=1, keepdims=True)\n        X_tilde = X - x_mean\n\n        # Step 3: Perform SVD\n        # We only need the singular values, s.\n        s = np.linalg.svd(X_tilde, compute_uv=False)\n\n        # Step 4: Calculate cumulative energy spectrum\n        s_sq = s**2\n        total_energy = np.sum(s_sq)\n\n        cumulative_energy_frac = np.array([])\n        if total_energy > 1e-15:\n            cumulative_energy_frac = np.cumsum(s_sq) / total_energy\n            # Clamp last value to 1.0 to handle potential float precision issues\n            if cumulative_energy_frac.size > 0:\n                cumulative_energy_frac[-1] = 1.0\n\n\n        # Step 5: Determine E(r_q)\n        e_rq = 0.0\n        if r_q > 0:\n            if cumulative_energy_frac.size == 0:\n                 e_rq = 0.0\n            elif r_q > len(cumulative_energy_frac):\n                e_rq = 1.0\n            else:\n                e_rq = cumulative_energy_frac[r_q - 1]\n\n        # Step 6: Determine r_min(epsilon)\n        r_min = 0\n        if epsilon > 0:\n            if cumulative_energy_frac.size == 0:\n                # No energy, so need infinite modes for epsilon > 0.\n                # Per problem, max r is m. So we return m.\n                r_min = m\n            else:\n                # np.searchsorted finds the index where epsilon would be inserted\n                # to maintain order. The required rank is that index + 1.\n                found_idx = np.searchsorted(cumulative_energy_frac, epsilon)\n                if found_idx  len(cumulative_energy_frac):\n                    r_min = found_idx + 1\n                else: \n                    # Epsilon is > 1.0 or numerically greater than max cumulative energy.\n                    # This case implies we cannot reach the energy tolerance.\n                    # The problem constrains epsilon to [0, 1].\n                    # If max(E) is numerically  epsilon, it means we need all modes.\n                    r_min = len(cumulative_energy_frac)\n\n        results.append([e_rq, r_min])\n    \n    # Format the output exactly as specified.\n    # [ [ratio1,r1],[ratio2,r2],... ]\n    # Using str() on lists inserts spaces, so we build the string manually.\n    pairs_str = [f\"[{res[0]},{res[1]}]\" for res in results]\n    final_output_str = f\"[{','.join(pairs_str)}]\"\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "对于多物理场问题，标准的欧几里得内积可能并非最优选择。加权内积（如质量加权或能量加权）的概念将物理信息融入到基的构建过程中，从而可能产生更优的模型。本练习将探讨不同内积的选择如何影响一个基准粘弹性流模型的降阶模型（ROM）的精度，突显了这一选择对于创建物理上一致且准确的模型的重要性。",
            "id": "4101559",
            "problem": "考虑一个平面通道中无量纲线性化的 Oldroyd-B 粘弹性流动模型，该模型采用截断的伽辽金表示。设状态向量为 $x(t) \\in \\mathbb{R}^{n}$，其中 $n = 6$，分块为 $x(t) = \\begin{bmatrix} v(t) \\\\ \\tau(t) \\end{bmatrix}$，其中 $v(t) \\in \\mathbb{R}^{3}$ 表示速度模态系数，$\\tau(t) \\in \\mathbb{R}^{3}$ 表示聚合物应力模态系数。其演化由一阶线性系统控制\n$$\n\\frac{d x}{d t} = A(\\mathrm{Wi}, \\nu, \\alpha, \\beta)\\, x(t) + b\\, f(t),\n$$\n其中 $A \\in \\mathbb{R}^{6 \\times 6}$ 是一个编码了粘性耗散和聚合物应力耦合的分块矩阵，$\\mathrm{Wi}$ 是 Weissenberg 数，$\\nu$ 是运动粘度，$\\alpha$ 是一个缩放动量方程中聚合物应力散度的耦合系数，而 $\\beta$ 是聚合物与总粘度之比。外部强迫为 $f(t) = \\sin(\\omega t)$，其中 $\\omega$ 的单位为弧度，$b \\in \\mathbb{R}^{6}$ 是一个仅作用于速度模态的恒定输入方向。\n\n使用以下物理上一致且科学上现实的参数化：\n- 设速度的模态拉普拉斯算子为 $L_v = \\mathrm{diag}(k_1^2, k_2^2, k_3^2)$，其中 $k_1 = 1$, $k_2 = 2$, $k_3 = 3$，粘性耗散块为 $A_{vv} = -\\nu L_v$，其中 $\\nu = 0.1$。\n- 设从聚合物应力到速度的类散度耦合为 $A_{v\\tau} = \\alpha D$，其中 $\\alpha = 0.5$，$D = \\mathrm{diag}(0.7, 0.6, 0.5)$。\n- 设应变到应力的耦合为 $A_{\\tau v} = \\beta S$，其中 $S = \\mathrm{diag}(0.4, 0.35, 0.3)$。\n- 设聚合物松弛为 $A_{\\tau \\tau} = -\\frac{1}{\\mathrm{Wi}} I_3$，其中 $I_3$ 是 $3 \\times 3$ 单位矩阵，从而得到分块系统\n$$\nA(\\mathrm{Wi}, \\nu, \\alpha, \\beta) = \n\\begin{bmatrix}\n-\\nu L_v   \\alpha D \\\\\n\\beta S   -\\frac{1}{\\mathrm{Wi}} I_3\n\\end{bmatrix}.\n$$\n- 设强迫方向为 $b = \\begin{bmatrix} b_v \\\\ 0 \\end{bmatrix}$，其中 $b_v = [1.0,\\, 0.5,\\, 0.3]^\\top$，应力块为零。\n- 设角频率为 $\\omega = 1.2$ (弧度)。\n\n定义三个对称正定内积矩阵，用于构建本征正交分解 (POD) 基并执行伽辽金投影：\n- 欧几里得内积：$W_E = I_6$，即 $6 \\times 6$ 单位矩阵。\n- 质量加权内积：$W_M = M$，其中\n$$\nM = \\mathrm{diag}(m_v, m_\\tau), \\quad m_v = [1.0,\\, 1.5,\\, 2.0], \\quad m_\\tau = [0.8,\\, 0.9,\\, 1.1],\n$$\n解释为模态坐标下的离散化质量矩阵。\n- 能量加权内积：$W_\\mathcal{E} = E$，其中\n$$\nE = \\mathrm{diag}(m_v, \\frac{1}{\\beta}\\mathbf{1}_3),\n$$\n其中 $\\mathbf{1}_3$ 是长度为 3 的全一向量，代表动能加弹性势能的二次近似，其中速度由 $m_v$ 加权，聚合物应力由 $1/\\beta$ 加权。\n\n对于每个内积 $W \\in \\{W_E, W_M, W_\\mathcal{E}\\}$，定义一个秩为 $r$ 的 POD 基 $\\Phi_W \\in \\mathbb{R}^{6 \\times r}$，该基由高保真快照 $X = [x(t_1), \\dots, x(t_N)] \\in \\mathbb{R}^{6 \\times N}$ 构建，使得 $\\Phi_W$ 的列在 $W$-内积下是标准正交的。使用 $W$-伽辽金投影形成降阶模型 (ROM)\n$$\n\\frac{d x_r}{d t} = A_r x_r + b_r f(t), \\quad A_r = \\Phi_W^\\top W A \\Phi_W, \\quad b_r = \\Phi_W^\\top W b,\n$$\n并重构高维近似 $\\hat{x}(t) = \\Phi_W x_r(t)$。\n\n使用能量相对误差在时间范围内测量精度：\n$$\n\\varepsilon_W = \\sqrt{\\frac{\\sum_{j=1}^N \\|x(t_j) - \\hat{x}(t_j)\\|_{E}^2}{\\sum_{j=1}^N \\|x(t_j)\\|_{E}^2}},\n$$\n其中 $\\|y\\|_{E}^2 = y^\\top E y$。所有量均为无量纲；角度单位为弧度。\n\n您的程序必须：\n1. 使用固定步长四阶龙格-库塔方法，在时间范围 $T = 10$、时间步长 $\\Delta t = 0.005$（即 $N = T/\\Delta t$ 个快照）的条件下，对初值为 $x(0) = 0$ 的全阶模型进行积分，强迫项为 $f(t) = \\sin(\\omega t)$。\n2. 对于每个 $W \\in \\{W_E, W_M, W_\\mathcal{E}\\}$，使用数值稳定的加权分解构建维度为 $r$ 的 POD 基，其中 $\\Phi_W$ 的列是 $W$-标准正交的。\n3. 为每个 $W$ 构建并使用相同的积分器积分 ROM，并重构 $\\hat{x}(t)$。\n4. 在每个测试案例中为每个 $W$ 计算 $\\varepsilon_W$。\n\n测试套件：\n- 案例 $\\mathrm{A}$：$(\\mathrm{Wi}, \\beta, r) = (0.1,\\, 0.25,\\, 3)$。\n- 案例 $\\mathrm{B}$：$(\\mathrm{Wi}, \\beta, r) = (1.0,\\, 0.35,\\, 3)$。\n- 案例 $\\mathrm{C}$（具有强弹性和较小子空间的边缘案例）：$(\\mathrm{Wi}, \\beta, r) = (5.0,\\, 0.50,\\, 2)$。\n\n对于每个案例，将列表 $[\\varepsilon_{W_E}, \\varepsilon_{W_M}, \\varepsilon_{W_\\mathcal{E}}]$ 报告为实数（无量纲浮点数）。您的程序应生成单行输出，其中包含三个案例的结果，按 $\\mathrm{A}$、$\\mathrm{B}$、$\\mathrm{C}$ 的顺序，格式为由方括号括起来的、由逗号分隔的这三个三元素列表。例如，输出格式必须是\n$$\n[[\\varepsilon_{W_E}^{(\\mathrm{A})}, \\varepsilon_{W_M}^{(\\mathrm{A})}, \\varepsilon_{W_\\mathcal{E}}^{(\\mathrm{A})}], [\\varepsilon_{W_E}^{(\\mathrm{B})}, \\varepsilon_{W_M}^{(\\mathrm{B})}, \\varepsilon_{W_\\mathcal{E}}^{(\\mathrm{B})}], [\\varepsilon_{W_E}^{(\\mathrm{C})}, \\varepsilon_{W_M}^{(\\mathrm{C})}, \\varepsilon_{W_\\mathcal{E}}^{(\\mathrm{C})}]].\n$$\n所有计算和输出都是无量纲的，角度单位为弧度。最终输出不得附加任何单位，并且必须采用指定的单行格式。",
            "solution": "该问题要求为线性化粘弹性流动系统开发和比较降阶模型 (ROM)。此过程涉及模拟全阶模型 (FOM)，使用三种不同内积的本征正交分解 (POD) 构建降阶模型 (ROM)，并评估其准确性。\n\n### 1. 全阶模型 (FOM)\n系统动力学由状态向量 $x(t) \\in \\mathbb{R}^{6}$ 的线性常微分方程 (LDE) 描述。状态向量包含 3 个速度模态系数 $v(t)$ 和 3 个聚合物应力模态系数 $\\tau(t)$，因此 $x(t) = [v(t)^\\top, \\tau(t)^\\top]^\\top$。控制方程为：\n$$\n\\frac{d x}{d t} = A(\\mathrm{Wi}, \\beta) x(t) + b f(t)\n$$\n强迫函数为 $f(t) = \\sin(\\omega t)$，角频率 $\\omega = 1.2$。恒定强迫向量 $b \\in \\mathbb{R}^{6}$ 仅作用于速度模态：$b = [1.0, 0.5, 0.3, 0, 0, 0]^\\top$。\n\n状态矩阵 $A \\in \\mathbb{R}^{6 \\times 6}$ 依赖于 Weissenberg 数 $\\mathrm{Wi}$ 和粘度比 $\\beta$。它被定义为一个分块矩阵：\n$$\nA(\\mathrm{Wi}, \\beta) = \n\\begin{bmatrix}\nA_{vv}   A_{v\\tau} \\\\\nA_{\\tau v}   A_{\\tau \\tau}\n\\end{bmatrix} = \n\\begin{bmatrix}\n-\\nu L_v   \\alpha D \\\\\n\\beta S   -\\frac{1}{\\mathrm{Wi}} I_3\n\\end{bmatrix}\n$$\n这些分块使用给定的参数和矩阵定义：\n- 粘性耗散：$A_{vv} = -\\nu L_v$，运动粘度 $\\nu = 0.1$，模态拉普拉斯算子 $L_v = \\mathrm{diag}(1^2, 2^2, 3^2) = \\mathrm{diag}(1, 4, 9)$。\n- 应力到速度耦合：$A_{v\\tau} = \\alpha D$，耦合系数 $\\alpha = 0.5$，$D = \\mathrm{diag}(0.7, 0.6, 0.5)$。\n- 速度到应力耦合：$A_{\\tau v} = \\beta S$，其中 $S = \\mathrm{diag}(0.4, 0.35, 0.3)$。参数 $\\beta$ 在每个测试案例中指定。\n- 聚合物松弛：$A_{\\tau \\tau} = -\\frac{1}{\\mathrm{Wi}} I_3$，其中 $I_3$ 是 $3 \\times 3$ 单位矩阵，$\\mathrm{Wi}$ 在每个测试案例中指定。\n\n为了生成用于模型降阶的数据，此 FOM 从初始条件 $x(0)=0$ 开始，在时间范围 $T=10$ 内，使用固定步长四阶龙格-库塔 (RK4) 方法进行数值积分，时间步长为 $\\Delta t = 0.005$。这将生成一个包含 $N+1$ 个状态向量（或称“快照”）$x(t_j)$ 的序列，其中 $t_j = j \\Delta t$，$j=0, 1, \\dots, N$ 且 $N=T/\\Delta t=2000$。这些快照被收集到一个快照矩阵 $X = [x(t_0), x(t_1), ..., x(t_N)] \\in \\mathbb{R}^{6 \\times (N+1)}$ 中。\n\n### 2. 加权本征正交分解 (POD)\nPOD 的目标是为表示快照数据找到一个最优的低维基。给定一个由对称正定权重矩阵 $W$ 定义的内积，我们寻求一个基 $\\Phi_W \\in \\mathbb{R}^{6 \\times r}$，其列关于此内积是标准正交的，即 $\\Phi_W^\\top W \\Phi_W = I_r$，其中 $r$ 是 ROM 的期望秩。\n\n从快照矩阵 $X$ 计算这个 $W$-标准正交基的算法如下：\n1.  对权重矩阵进行 Cholesky 分解 $W = L L^\\top$，其中 $L$ 是一个下三角矩阵。\n2.  使用此因子变换快照数据：$\\tilde{X} = L^\\top X$。\n3.  计算变换后数据的奇异值分解 (SVD)：$\\tilde{X} = U \\Sigma V^\\top$。$U$ 的列构成一个标准正交基，可以最优地捕获 $\\tilde{X}$ 中的数据。\n4.  通过选择 $U$ 的前 $r$ 列来截断基，这些列对应于最大的奇异值：$\\tilde{\\Phi}_W = U[:, :r]$。\n5.  将此基变换回原始坐标系以获得最终的 POD 基：$\\Phi_W = (L^\\top)^{-1} \\tilde{\\Phi}_W$。由于 $L^\\top$ 是上三角矩阵，此线性系统可通过回代法高效求解。\n\n此过程针对由以下矩阵定义的三个不同内积执行：\n- 欧几里得：$W_E = I_6$。\n- 质量加权：$W_M = \\mathrm{diag}(1.0, 1.5, 2.0, 0.8, 0.9, 1.1)$。\n- 能量加权：$W_\\mathcal{E} = E = \\mathrm{diag}(1.0, 1.5, 2.0, 1/\\beta, 1/\\beta, 1/\\beta)$。请注意，此矩阵依赖于测试案例中的参数 $\\beta$。\n\n### 3. 降阶模型 (ROM) 的构建与仿真\n使用计算出的 POD 基 $\\Phi_W$，通过 $W$-伽辽金投影构建一个 ROM。全状态 $x(t)$ 通过投影到基上进行近似，$x(t) \\approx \\hat{x}(t) = \\Phi_W x_r(t)$，其中 $x_r(t) \\in \\mathbb{R}^r$ 是降阶状态。将此近似代入 FOM 并使用 $W$-内积投影到基上，得到 ROM：\n$$\n\\frac{d x_r}{d t} = A_r x_r(t) + b_r f(t)\n$$\n其中降阶系统矩阵由下式给出：\n$$\nA_r = \\Phi_W^\\top W A \\Phi_W \\in \\mathbb{R}^{r \\times r}\n$$\n$$\nb_r = \\Phi_W^\\top W b \\in \\mathbb{R}^{r}\n$$\n这个较小的 $r$ 维系统使用相同的 RK4 方法和时间步长进行积分。初始条件为 $x_r(0) = \\Phi_W^\\top W x(0) = 0$。得到的降阶状态轨迹 $x_r(t_j)$ 随后用于重构高维近似 $\\hat{x}(t_j) = \\Phi_W x_r(t_j)$。\n\n### 4. 误差评估\n每个 ROM 的准确性由能量相对误差 $\\varepsilon_W$ 来量化。关键要注意的是，对于所有三个 ROM（使用 $W_E, W_M, W_\\mathcal{E}$ 构建），误差都是在由能量内积矩阵 $E = W_\\mathcal{E}$ 导出的范数中测量的。误差计算如下：\n$$\n\\varepsilon_W = \\sqrt{\\frac{\\sum_{j=0}^N \\|x(t_j) - \\hat{x}(t_j)\\|_{E}^2}{\\sum_{j=0}^N \\|x(t_j)\\|_{E}^2}}\n$$\n其中能量范数的平方为 $\\|y\\|_{E}^2 = y^\\top E y$。\n\n整个过程——FOM 仿真、为三个内积中的每一个构建 POD 基、ROM 仿真和误差计算——将对所提供的三个测试案例中的每一个重复进行。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import cholesky, solve_triangular\n\ndef rk4_step(f, t, y, dt, *args):\n    \"\"\"\n    Performs a single step of the fourth-order Runge-Kutta method.\n    \n    Args:\n        f (callable): The RHS function of the ODE, f(t, y, *args).\n        t (float): Current time.\n        y (np.ndarray): Current state vector (must be a column vector).\n        dt (float): Time step.\n        *args: Additional arguments passed to f.\n        \n    Returns:\n        np.ndarray: The state vector at time t + dt.\n    \"\"\"\n    k1 = dt * f(t, y, *args)\n    k2 = dt * f(t + 0.5 * dt, y + 0.5 * k1, *args)\n    k3 = dt * f(t + 0.5 * dt, y + 0.5 * k2, *args)\n    k4 = dt * f(t + dt, y + k3, *args)\n    return y + (k1 + 2 * k2 + 2 * k3 + k4) / 6.0\n\ndef odefun(t, x, A, b, omega):\n    \"\"\"\n    RHS of the ODE system dx/dt = Ax + b*f(t).\n    \n    Args:\n        t (float): Current time.\n        x (np.ndarray): Current state vector (column vector).\n        A (np.ndarray): State matrix.\n        b (np.ndarray): Forcing vector.\n        omega (float): Forcing frequency.\n        \n    Returns:\n        np.ndarray: The derivative dx/dt.\n    \"\"\"\n    return A @ x + b * np.sin(omega * t)\n\ndef get_pod_basis(snapshots, W, r):\n    \"\"\"\n    Computes a W-orthonormal POD basis of rank r from snapshots.\n    \n    Args:\n        snapshots (np.ndarray): Matrix of state snapshots (dims: n x N_snapshots).\n        W (np.ndarray): Symmetric positive definite weight matrix.\n        r (int): Rank of the desired basis.\n        \n    Returns:\n        np.ndarray: The POD basis matrix Phi (dims: n x r).\n    \"\"\"\n    # 1. Cholesky decomposition of W: W = L @ L.T\n    L = cholesky(W, lower=True)\n\n    # 2. Transform snapshots: X_tilde = L.T @ snapshots\n    X_tilde = L.T @ snapshots\n\n    # 3. SVD of transformed snapshots\n    U, _, _ = np.linalg.svd(X_tilde, full_matrices=False)\n\n    # 4. Truncate basis for transformed system\n    U_r = U[:, :r]\n\n    # 5. Transform basis back by solving L.T @ Phi = U_r for Phi\n    Phi = solve_triangular(L.T, U_r, lower=False, check_finite=False)\n    \n    return Phi\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    # Fixed parameters from the problem statement\n    nu = 0.1\n    alpha = 0.5\n    omega = 1.2\n    T = 10.0\n    dt = 0.005\n\n    # Fixed matrices and vectors\n    k_vals = np.array([1.0, 2.0, 3.0])\n    L_v = np.diag(k_vals**2)\n    D = np.diag([0.7, 0.6, 0.5])\n    S = np.diag([0.4, 0.35, 0.3])\n\n    b_v = np.array([1.0, 0.5, 0.3])\n    b = np.zeros((6, 1))\n    b[0:3, 0] = b_v\n\n    m_v = np.array([1.0, 1.5, 2.0])\n    m_tau = np.array([0.8, 0.9, 1.1])\n    W_M = np.diag(np.concatenate((m_v, m_tau)))\n    W_E_mat = np.eye(6)\n\n    # Test suite\n    test_cases = [\n        (0.1, 0.25, 3),  # Case A\n        (1.0, 0.35, 3),  # Case B\n        (5.0, 0.50, 2)   # Case C\n    ]\n\n    all_results = []\n\n    for Wi, beta, r in test_cases:\n        # ---- 1. Assemble Full-Order Model (FOM) ----\n        A_vv = -nu * L_v\n        A_vt = alpha * D\n        A_tv = beta * S\n        A_tt = -(1.0 / Wi) * np.eye(3)\n        A = np.block([[A_vv, A_vt], [A_tv, A_tt]])\n        \n        # Energy matrix E depends on beta and is used for error measurement\n        E_mat = np.diag(np.concatenate((m_v, np.full(3, 1.0/beta))))\n\n        weight_matrices = [W_E_mat, W_M, E_mat]\n\n        # ---- 2. Simulate FOM to generate snapshots ----\n        n_steps = int(round(T / dt))\n        timesteps = np.linspace(0, T, n_steps + 1)\n        x = np.zeros((6, 1))\n        snapshots = np.zeros((6, n_steps + 1))\n        \n        for i in range(n_steps):\n            x = rk4_step(odefun, timesteps[i], x, dt, A, b, omega)\n            snapshots[:, i + 1] = x.flatten()\n\n        # ---- 3. Build and evaluate ROMs for each inner product ----\n        case_errors = []\n        for W in weight_matrices:\n            # 3a. Construct POD basis\n            Phi = get_pod_basis(snapshots, W, r)\n\n            # 3b. Build ROM\n            Ar = Phi.T @ W @ A @ Phi\n            br = Phi.T @ W @ b\n\n            # 3c. Simulate ROM\n            xr = np.zeros((r, 1))\n            rom_snapshots_r = np.zeros((r, n_steps + 1))\n            \n            for i in range(n_steps):\n                xr = rk4_step(odefun, timesteps[i], xr, dt, Ar, br, omega)\n                rom_snapshots_r[:, i + 1] = xr.flatten()\n            \n            # 3d. Reconstruct full state\n            reconstructed_snapshots = Phi @ rom_snapshots_r\n\n            # 3e. Compute energy-relative error\n            diff = snapshots - reconstructed_snapshots\n            \n            numerator = np.sum(np.sum(diff * (E_mat @ diff), axis=0))\n            denominator = np.sum(np.sum(snapshots * (E_mat @ snapshots), axis=0))\n            \n            relative_error = np.sqrt(numerator / denominator) if denominator > 0 else 0.0\n            \n            case_errors.append(relative_error)\n            \n        all_results.append(case_errors)\n\n    # Final print statement in the exact required format.\n    sublist_strs = [f'[{\",\".join(map(str, sublist))}]' for sublist in all_results]\n    print(f\"[{','.join(sublist_strs)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "降阶模型的主要目标是实现计算加速，尤其是在求解非线性问题时。虽然伽辽金投影减小了系统规模，但非线性项的计算仍可能成为瓶颈。本练习将介绍超降阶技术作为解决这一瓶颈的方法，并指导你使用一个分析性能模型（屋顶线模型）来量化超降阶所带来的预期加速比，从而将抽象的算法与现代硬件上的实际性能增益联系起来。",
            "id": "4101583",
            "problem": "要求您实现一个分析性能模型，用以量化在使用和不使用超降阶的情况下，通过 Proper Orthogonal Decomposition (POD) 和 Galerkin 方法对非线性复杂流动的降阶模型进行在线阶段加速。重点是分析浮点运算计数和内存流量，并使用 roofline 性能模型预测求解时间。您必须实现一个程序，为几组参数集计算预测的在线加速比。\n\n推导的基础始于一个半离散动力系统，该系统由非线性守恒律的空间离散（例如，有限体积法或有限元法）得到，可写为\n$$\n\\frac{d \\mathbf{u}}{dt} = \\mathbf{A}\\,\\mathbf{u} + \\mathbf{N}(\\mathbf{u}) + \\mathbf{f},\n$$\n其中 $\\mathbf{u}\\in\\mathbb{R}^{N_h}$ 是高维状态，$\\mathbf{A}\\in\\mathbb{R}^{N_h\\times N_h}$ 是一个线性算子，$\\mathbf{N}(\\cdot)$ 是一个非线性算子，$\\mathbf{f}\\in\\mathbb{R}^{N_h}$ 是一个强迫项。通过 Proper Orthogonal Decomposition (POD) 获得一个降阶基 $\\mathbf{V}\\in\\mathbb{R}^{N_h\\times r}$，状态被近似为 $\\mathbf{u}\\approx \\mathbf{V}\\,\\mathbf{a}$，其中 $\\mathbf{a}\\in\\mathbb{R}^{r}$ 是降阶坐标。Galerkin 投影产生一个在线降阶系统\n$$\n\\frac{d \\mathbf{a}}{dt} = \\mathbf{V}^T\\left(\\mathbf{A}\\,\\mathbf{V}\\,\\mathbf{a} + \\mathbf{N}(\\mathbf{V}\\,\\mathbf{a}) + \\mathbf{f}\\right).\n$$\n对于线性项，假设降阶算子 $\\mathbf{M}=\\mathbf{V}^T\\mathbf{A}\\mathbf{V}\\in\\mathbb{R}^{r\\times r}$ 的离线预计算是可用的，因此在线线性贡献为 $\\mathbf{M}\\,\\mathbf{a}$。对于非线性项，考虑两种在线策略：\n- 不使用超降阶：直接在全维度 $N_h$ 上评估 $\\mathbf{N}(\\mathbf{V}\\,\\mathbf{a})$，然后用 $\\mathbf{V}^T$ 进行投影。\n- 使用超降阶：使用基于采样的超降阶方法，如 Discrete Empirical Interpolation Method (DEIM) 或 Energy-Conserving Sampling and Weighting (ECSW)。其模型如下：通过一个采样算子 $\\mathbf{P}\\in\\mathbb{R}^{N_h\\times s}$ 选择 $s$ 个采样自由度，预计算一个降阶采样基，以便在线时可以使用 $\\mathbf{V}_s=\\mathbf{P}^T\\mathbf{V}\\in\\mathbb{R}^{s\\times r}$ 形成采样状态 $\\mathbf{u}_s=\\mathbf{V}_s\\,\\mathbf{a}$，并评估采样后的非线性项 $\\mathbf{n}_s=\\mathbf{N}_s(\\mathbf{u}_s)\\in\\mathbb{R}^{s}$。假设存在一个预计算的投影映射 $\\mathbf{W}\\in\\mathbb{R}^{r\\times s}$，使得降阶非线性项可近似为 $\\mathbf{W}\\,\\mathbf{n}_s$。\n\n采用以下经过充分测试的性能建模假设：\n- 一个大小为 $m\\times n$ 的稠密矩阵向量乘法，在使用双精度存储（每个标量占 $8$ 字节）时，成本为 $2\\,m\\,n$ 次浮点运算 (FLOPs)，数据流为 $8\\,(m\\,n + m + n)$ 字节。\n- 在 $k$ 个自由度上评估非线性算子的成本为 $c_n\\,k$ FLOPs，数据流为 $b_n\\,k$ 字节，其中 $c_n$（单位为 FLOPs/条目）和 $b_n$（单位为 字节/条目）是给定的参数，用于模拟数值模板和数据访问模式。\n- roofline 模型给出的每次在线评估的时间为\n$$\nT = \\max\\left(\\frac{F}{F_{\\text{peak}}},\\ \\frac{Q}{B_{\\text{peak}}}\\right),\n$$\n其中 $F$ 是 FLOP 计数，$Q$ 是数据流字节数，$F_{\\text{peak}}$ 是硬件峰值浮点运算速率（单位为 FLOPs/秒），$B_{\\text{peak}}$ 是可持续内存带宽（单位为 字节/秒）。时间以秒表示。\n\n根据上述操作的基本原理，推导并实现以下每个时间步的在线成本模型：\n\n- 不使用超降阶：\n  - 计算 $\\mathbf{u}=\\mathbf{V}\\,\\mathbf{a}$：FLOPs $F_1=2\\,N_h\\,r$，字节 $Q_1=8\\,(N_h\\,r + N_h + r)$。\n  - 评估 $\\mathbf{n}=\\mathbf{N}(\\mathbf{u})$：FLOPs $F_2=c_n\\,N_h$，字节 $Q_2=b_n\\,N_h$。\n  - 投影 $\\mathbf{g}=\\mathbf{V}^T\\,\\mathbf{n}$：FLOPs $F_3=2\\,N_h\\,r$，字节 $Q_3=8\\,(N_h\\,r + N_h + r)$。\n  - 线性项 $\\mathbf{M}\\,\\mathbf{a}$：FLOPs $F_4=2\\,r^2$，字节 $Q_4=8\\,(r^2 + 2\\,r)$。\n  - 总计：$F_{\\text{noHR}} = F_1 + F_2 + F_3 + F_4$ 和 $Q_{\\text{noHR}} = Q_1 + Q_2 + Q_3 + Q_4$。\n\n- 使用超降阶：\n  - 计算采样状态 $\\mathbf{u}_s=\\mathbf{V}_s\\,\\mathbf{a}$：FLOPs $f_1=2\\,s\\,r$，字节 $q_1=8\\,(s\\,r + s + r)$。\n  - 评估采样后的非线性项 $\\mathbf{n}_s$：FLOPs $f_2=c_n\\,s$，字节 $q_2=b_n\\,s$。\n  - 投影 $\\mathbf{W}\\,\\mathbf{n}_s$：FLOPs $f_3=2\\,r\\,s$，字节 $q_3=8\\,(r\\,s + r + s)$。\n  - 线性项 $\\mathbf{M}\\,\\mathbf{a}$：FLOPs $f_4=2\\,r^2$，字节 $q_4=8\\,(r^2 + 2\\,r)$。\n  - 总计：$F_{\\text{HR}} = f_1 + f_2 + f_3 + f_4$ 和 $Q_{\\text{HR}} = q_1 + q_2 + q_3 + q_4$。\n\n使用 roofline 模型计算 $T_{\\text{noHR}}$ 和 $T_{\\text{HR}}$（以秒为单位），并报告在线加速比\n$$\nS \\equiv \\frac{T_{\\text{noHR}}}{T_{\\text{HR}}}.\n$$\n\n实现一个程序，对于给定的参数集列表，输出一行包含每个案例的加速比 $S$ 的列表，四舍五入到六位小数。此问题不涉及角度或百分比。在中间建模中，时间必须以秒为单位，但报告的加速比是无量纲的。请一致使用双精度（每个标量 $8$ 字节）。\n\n测试套件（每个元组为 $(N_h,\\ r,\\ s,\\ c_n,\\ b_n,\\ F_{\\text{peak}},\\ B_{\\text{peak}})$）：\n- 案例 $1$（通用，中度计算密集型）：$(100000,\\ 60,\\ 300,\\ 60,\\ 16,\\ 2.0\\times 10^{12},\\ 2.0\\times 10^{11})$\n- 案例 $2$（内存密集型场景）：$(100000,\\ 60,\\ 120,\\ 60,\\ 16,\\ 4.0\\times 10^{12},\\ 5.0\\times 10^{10})$\n- 案例 $3$（无有效超降阶，$s=N_h$）：$(5000,\\ 40,\\ 5000,\\ 40,\\ 16,\\ 1.0\\times 10^{12},\\ 1.0\\times 10^{11})$\n- 案例 $4$（小网格，较高的 $c_n$ 和 $b_n$）：$(1000,\\ 20,\\ 50,\\ 80,\\ 24,\\ 5.0\\times 10^{11},\\ 1.0\\times 10^{11})$\n- 案例 $5$（大网格，强非线性）：$(200000,\\ 80,\\ 200,\\ 200,\\ 32,\\ 2.5\\times 10^{12},\\ 1.5\\times 10^{11})$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4,result5]”），其中每个结果是相应案例的加速比 $S$，表示为四舍五入到六位小数的十进制数。",
            "solution": "目标是开发并实现一个分析性能模型，用于在 Proper Orthogonal Decomposition (POD) Galerkin 降阶模型 (ROM) 的背景下，预测由超降阶带来的在线阶段加速比。加速比（记作 $S$）定义为标准 Galerkin 投影 ROM 的每个时间步的求解时间与采用超降阶的 ROM 的求解时间之比。\n\n分析始于所提供的高维状态 $\\mathbf{u} \\in \\mathbb{R}^{N_h}$ 的半离散系统：\n$$\n\\frac{d \\mathbf{u}}{dt} = \\mathbf{A}\\,\\mathbf{u} + \\mathbf{N}(\\mathbf{u}) + \\mathbf{f}\n$$\n状态在一个降阶基 $\\mathbf{V} \\in \\mathbb{R}^{N_h \\times r}$ 中近似为 $\\mathbf{u} \\approx \\mathbf{V}\\,\\mathbf{a}$，其中 $\\mathbf{a} \\in \\mathbb{R}^{r}$ 是降阶坐标，且 $r \\ll N_h$。Galerkin 投影产生降阶系统：\n$$\n\\frac{d \\mathbf{a}}{dt} = \\mathbf{V}^T\\mathbf{A}\\mathbf{V}\\,\\mathbf{a} + \\mathbf{V}^T\\mathbf{N}(\\mathbf{V}\\,\\mathbf{a}) + \\mathbf{V}^T\\mathbf{f}\n$$\n假设强迫项 $\\mathbf{V}^T\\mathbf{f}$ 和线性算子 $\\mathbf{M} = \\mathbf{V}^T\\mathbf{A}\\mathbf{V} \\in \\mathbb{R}^{r \\times r}$ 是离线预计算的。主要的在线计算成本来自对降阶非线性项的评估，我们分两种情况进行分析。\n\n每种情况的性能都使用 roofline 模型进行量化，该模型提供了求解时间 $T$ 的估计值，如下所示：\n$$\nT = \\max\\left(\\frac{F}{F_{\\text{peak}}},\\ \\frac{Q}{B_{\\text{peak}}}\\right)\n$$\n这里，$F$ 表示总浮点运算次数 (FLOPs)，$Q$ 是总内存流量（以字节为单位），$F_{\\text{peak}}$ 是硬件的峰值计算速率（单位为 FLOPs/秒），$B_{\\text{peak}}$ 是可持续内存带宽（单位为 字节/秒）。我们假设使用双精度浮点数，每个标量占 $8$ 字节。\n\n**1. 不使用超降阶的在线成本 ($T_{\\text{noHR}}$)**\n\n在这种标准的 Galerkin 方法中，非线性项 $\\mathbf{N}(\\mathbf{V}\\,\\mathbf{a})$ 在全维度 $N_h$ 上进行评估，然后投影到降阶基上。每个时间步的在线计算步骤如下：\n\n1.  重构全状态：$\\mathbf{u}=\\mathbf{V}\\,\\mathbf{a}$。这是一个大小为 $N_h \\times r$ 的矩阵和一个大小为 $r$ 的向量之间的稠密矩阵向量乘积。\n    -   FLOPs: $F_1 = 2\\,N_h\\,r$。\n    -   字节: $Q_1 = 8\\,(N_h\\,r + N_h + r)$。这包括了传输矩阵 $\\mathbf{V}$、向量 $\\mathbf{a}$ 和结果向量 $\\mathbf{u}$ 的数据流。\n\n2.  评估非线性项：$\\mathbf{n}=\\mathbf{N}(\\mathbf{u})$。这是在完整的 $N_h$ 维状态向量上执行的。\n    -   FLOPs: $F_2 = c_n\\,N_h$。\n    -   字节: $Q_2 = b_n\\,N_h$。参数 $c_n$ 和 $b_n$ 模拟了每个条目的计算和内存成本。\n\n3.  投影非线性项：$\\mathbf{g}=\\mathbf{V}^T\\,\\mathbf{n}$。这是一个大小为 $r \\times N_h$ 的矩阵和一个大小为 $N_h$ 的向量之间的稠密矩阵向量乘积。\n    -   FLOPs: $F_3 = 2\\,r\\,N_h$。\n    -   字节: $Q_3 = 8\\,(r\\,N_h + r + N_h)$。这包括了传输 $\\mathbf{V}^T$、$\\mathbf{n}$ 和结果 $\\mathbf{g}$ 的数据流。\n\n4.  计算线性项贡献：$\\mathbf{M}\\,\\mathbf{a}$。这是一个涉及预计算的 $r \\times r$ 矩阵 $\\mathbf{M}$ 的稠密矩阵向量乘积。\n    -   FLOPs: $F_4 = 2\\,r^2$。\n    -   字节: $Q_4 = 8\\,(r^2 + 2\\,r)$。这包括传输 $\\mathbf{M}$、$\\mathbf{a}$ 和结果的数据流。\n\n每个时间步的总 FLOPs 和内存流量是这些贡献的总和：\n$$\nF_{\\text{noHR}} = F_1 + F_2 + F_3 + F_4 = 4\\,N_h\\,r + c_n\\,N_h + 2\\,r^2\n$$\n$$\nQ_{\\text{noHR}} = Q_1 + Q_2 + Q_3 + Q_4 = 16\\,(N_h\\,r + N_h + r) + b_n\\,N_h + 8\\,(r^2 + 2\\,r)\n$$\n然后，求解时间由 roofline 模型给出：\n$$\nT_{\\text{noHR}} = \\max\\left(\\frac{F_{\\text{noHR}}}{F_{\\text{peak}}},\\ \\frac{Q_{\\text{noHR}}}{B_{\\text{peak}}}\\right)\n$$\n\n**2. 使用超降阶的在线成本 ($T_{\\text{HR}}$)**\n\n像 DEIM 或 ECSW 这样的超降阶方法通过仅使用 $s$ 个精心选择的采样点来近似非线性项，从而避免了在全维度 $N_h$ 上的计算，其中 $s$ 通常与 $r$ 的数量级相同。在线计算步骤如下：\n\n1.  计算采样状态：$\\mathbf{u}_s=\\mathbf{V}_s\\,\\mathbf{a}$。这使用了预计算的采样基 $\\mathbf{V}_s \\in \\mathbb{R}^{s \\times r}$。\n    -   FLOPs: $f_1 = 2\\,s\\,r$。\n    -   字节: $q_1 = 8\\,(s\\,r + s + r)$。\n\n2.  评估采样后的非线性项：$\\mathbf{n}_s=\\mathbf{N}_s(\\mathbf{u}_s)$。这仅在 $s$ 个采样点上进行评估。\n    -   FLOPs: $f_2 = c_n\\,s$。\n    -   字节: $q_2 = b_n\\,s$。\n\n3.  将采样后的非线性项投影到降阶空间：$\\mathbf{W}\\,\\mathbf{n}_s$。这使用了预计算的投影映射 $\\mathbf{W} \\in \\mathbb{R}^{r \\times s}$。\n    -   FLOPs: $f_3 = 2\\,r\\,s$。\n    -   字节: $q_3 = 8\\,(r\\,s + r + s)$。\n\n4.  计算线性项贡献：$\\mathbf{M}\\,\\mathbf{a}$。此步骤与不使用超降阶的情况相同。\n    -   FLOPs: $f_4 = 2\\,r^2$。\n    -   字节: $q_4 = 8\\,(r^2 + 2\\,r)$。\n\n每个时间步的总 FLOPs 和内存流量为：\n$$\nF_{\\text{HR}} = f_1 + f_2 + f_3 + f_4 = 4\\,s\\,r + c_n\\,s + 2\\,r^2\n$$\n$$\nQ_{\\text{HR}} = q_1 + q_2 + q_3 + q_4 = 16\\,(s\\,r + s + r) + b_n\\,s + 8\\,(r^2 + 2\\,r)\n$$\n求解时间为：\n$$\nT_{\\text{HR}} = \\max\\left(\\frac{F_{\\text{HR}}}{F_{\\text{peak}}},\\ \\frac{Q_{\\text{HR}}}{B_{\\text{peak}}}\\right)\n$$\n\n**3. 在线加速比**\n\n在线加速比 $S$ 是不使用超降阶的每步时间与使用超降阶的每步时间之比：\n$$\nS = \\frac{T_{\\text{noHR}}}{T_{\\text{HR}}}\n$$\n$S > 1$ 的值表示超降阶对在线阶段是有益的。以下程序将实现这些计算，以针对给定的参数集计算 $S$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the predicted online speedup for a reduced-order model \n    with and without hyper-reduction, based on a roofline performance model.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (N_h, r, s, c_n, b_n, F_peak, B_peak)\n    test_cases = [\n        (100000, 60, 300, 60, 16, 2.0e12, 2.0e11),\n        (100000, 60, 120, 60, 16, 4.0e12, 5.0e10),\n        (5000, 40, 5000, 40, 16, 1.0e12, 1.0e11),\n        (1000, 20, 50, 80, 24, 5.0e11, 1.0e11),\n        (200000, 80, 200, 200, 32, 2.5e12, 1.5e11),\n    ]\n\n    results = []\n    for N_h, r, s, c_n, b_n, F_peak, B_peak in test_cases:\n        # --- Cost Model without Hyper-Reduction (noHR) ---\n        \n        # FLOPs calculation\n        F1_noHR = 2 * N_h * r\n        F2_noHR = c_n * N_h\n        F3_noHR = 2 * N_h * r\n        F4_noHR = 2 * r**2\n        F_noHR = F1_noHR + F2_noHR + F3_noHR + F4_noHR\n        \n        # Memory traffic calculation (in bytes)\n        Q1_noHR = 8 * (N_h * r + N_h + r)\n        Q2_noHR = b_n * N_h\n        Q3_noHR = 8 * (N_h * r + N_h + r)\n        Q4_noHR = 8 * (r**2 + 2 * r)\n        Q_noHR = Q1_noHR + Q2_noHR + Q3_noHR + Q4_noHR\n        \n        # Time-to-solution using Roofline model\n        T_noHR = max(F_noHR / F_peak, Q_noHR / B_peak)\n        \n        # --- Cost Model with Hyper-Reduction (HR) ---\n        \n        # FLOPs calculation\n        f1_HR = 2 * s * r\n        f2_HR = c_n * s\n        f3_HR = 2 * r * s\n        f4_HR = 2 * r**2\n        F_HR = f1_HR + f2_HR + f3_HR + f4_HR\n        \n        # Memory traffic calculation (in bytes)\n        q1_HR = 8 * (s * r + s + r)\n        q2_HR = b_n * s\n        q3_HR = 8 * (r * s + r + s)\n        q4_HR = 8 * (r**2 + 2 * r)\n        Q_HR = q1_HR + q2_HR + q3_HR + q4_HR\n        \n        # Time-to-solution using Roofline model\n        T_HR = max(F_HR / F_peak, Q_HR / B_peak)\n        \n        # --- Speedup Calculation ---\n        \n        # Handle case where T_HR might be zero to avoid division by zero error\n        if T_HR > 0:\n            speedup = T_noHR / T_HR\n        else:\n            # If T_HR is zero, speedup is effectively infinite, but this\n            # should not happen with the given positive parameters.\n            # We can define it as 1.0 (no speedup) if both times are zero.\n            speedup = 1.0 if T_noHR == 0 else float('inf')\n\n        results.append(round(speedup, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{res:.6f}' for res in results)}]\")\n\nsolve()\n```"
        }
    ]
}