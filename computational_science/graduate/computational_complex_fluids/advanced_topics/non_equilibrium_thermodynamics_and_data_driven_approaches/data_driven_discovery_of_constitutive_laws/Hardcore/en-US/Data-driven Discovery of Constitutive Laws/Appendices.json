{
    "hands_on_practices": [
        {
            "introduction": "A core task in mechanics is to predict a material's stress response under a given deformation. Once a data-driven discovery process yields a candidate strain energy function, this forward problem becomes the first test of its utility. This exercise  provides direct practice in this fundamental skill, requiring you to compute the stress tensor from a given hyperelastic strain energy function expressed in terms of tensor invariants, thus bridging the abstract mathematical model with concrete, physical predictions.",
            "id": "3748670",
            "problem": "A data-driven multiscale analysis aggregates mesoscale stress-strain observations to identify an isotropic hyperelastic strain energy density for a compressible material as a function of the principal invariants of the right Cauchy–Green deformation tensor. Let the deformation gradient be\n$$\nF = \\begin{pmatrix}\n1.2  0.1  0.0 \\\\\n0.0  0.9  0.2 \\\\\n0.0  0.0  1.1\n\\end{pmatrix},\n$$\nand let the strain energy density be discovered in the invariant form\n$$\n\\psi(I_1,I_2,I_3) = \\frac{a_1}{2}\\,(I_1 - 3) + \\frac{a_2}{2}\\,(I_2 - 3) + \\frac{\\kappa}{2}\\,(\\ln J)^2,\\quad J=\\sqrt{I_3},\n$$\nwith coefficients $a_1 = 40$ megapascal (MPa), $a_2 = 10$ megapascal (MPa), and $\\kappa = 200$ megapascal (MPa). Here, $C = F^{\\top}F$, and the principal invariants are defined by $I_1 = \\mathrm{tr}(C)$, $I_2 = \\tfrac{1}{2}\\big((\\mathrm{tr}(C))^2 - \\mathrm{tr}(C^2)\\big)$, and $I_3 = \\det(C)$.\n\nStarting only from these definitions and standard continuum mechanics principles, compute the principal invariants $I_1$, $I_2$, and $I_3$ for the given $F$, and then evaluate the $(1,1)$-component of the Second Piola–Kirchhoff stress tensor $S$ consistent with the given $\\psi(I_1,I_2,I_3)$. Express your final numerical result for $S_{11}$ in MPa and round your answer to four significant figures.",
            "solution": "The problem is first validated against the required criteria.\n\n### Step 1: Extract Givens\n-   Deformation gradient: $$F = \\begin{pmatrix} 1.2  0.1  0.0 \\\\ 0.0  0.9  0.2 \\\\ 0.0  0.0  1.1 \\end{pmatrix}$$\n-   Strain energy density function: $$\\psi(I_1,I_2,I_3) = \\frac{a_1}{2}\\,(I_1 - 3) + \\frac{a_2}{2}\\,(I_2 - 3) + \\frac{\\kappa}{2}\\,(\\ln J)^2$$\n-   Jacobian of deformation: $$J=\\sqrt{I_3}$$\n-   Material coefficients: $a_1 = 40$ MPa, $a_2 = 10$ MPa, $\\kappa = 200$ MPa.\n-   Right Cauchy–Green deformation tensor: $$C = F^{\\top}F$$\n-   Principal invariants of $C$:\n    -   $I_1 = \\mathrm{tr}(C)$\n    -   $I_2 = \\tfrac{1}{2}\\big((\\mathrm{tr}(C))^2 - \\mathrm{tr}(C^2)\\big)$\n    -   $I_3 = \\det(C)$\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded**: The problem is set within the established framework of continuum mechanics and hyperelasticity. The definitions of the right Cauchy-Green tensor $C$, its invariants $I_1, I_2, I_3$, and the form of the strain energy density function $\\psi$ are standard in the field. The requested calculation of the Second Piola-Kirchhoff stress tensor $S$ from $\\psi$ is a fundamental procedure.\n2.  **Well-Posed**: The problem provides all necessary data and definitions to compute a unique result. The given deformation gradient $F$ is non-singular, ensuring that $C$ and $C^{-1}$ exist. The constitutive model $\\psi$ is a well-defined function of the invariants.\n3.  **Objective**: The problem statement is precise, quantitative, and free of any subjective or ambiguous language.\n4.  **Topic Relevance**: The problem directly addresses the theme of using a discovered constitutive law ($\\psi$) to predict material behavior (the stress tensor $S$), which is central to \"data-driven discovery of constitutive laws\" in \"multiscale modeling and analysis\".\n\nThe problem is self-contained, consistent, and scientifically sound.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete solution will be provided.\n\n### Solution\n\nThe solution proceeds in four stages:\n1.  Calculation of the right Cauchy-Green deformation tensor $C$.\n2.  Calculation of the principal invariants $I_1$, $I_2$, and $I_3$.\n3.  Derivation of the expression for the Second Piola-Kirchhoff stress tensor $S$.\n4.  Computation of the component $S_{11}$.\n\n**1. Right Cauchy-Green Tensor $C$**\n\nThe right Cauchy-Green deformation tensor $C$ is defined as $C = F^{\\top}F$. Given the deformation gradient $F$:\n$$F = \\begin{pmatrix} 1.2  0.1  0.0 \\\\ 0.0  0.9  0.2 \\\\ 0.0  0.0  1.1 \\end{pmatrix} \\implies F^{\\top} = \\begin{pmatrix} 1.2  0.0  0.0 \\\\ 0.1  0.9  0.0 \\\\ 0.0  0.2  1.1 \\end{pmatrix}$$\nThe product $F^{\\top}F$ is computed as:\n$$C = F^{\\top}F = \\begin{pmatrix} 1.2  0.0  0.0 \\\\ 0.1  0.9  0.0 \\\\ 0.0  0.2  1.1 \\end{pmatrix} \\begin{pmatrix} 1.2  0.1  0.0 \\\\ 0.0  0.9  0.2 \\\\ 0.0  0.0  1.1 \\end{pmatrix} = \\begin{pmatrix} 1.44  0.12  0.0 \\\\ 0.12  0.82  0.18 \\\\ 0.0  0.18  1.25 \\end{pmatrix}$$\n\n**2. Principal Invariants $I_1, I_2, I_3$**\n\n-   The first invariant $I_1$ is the trace of $C$.\n    $$I_1 = \\mathrm{tr}(C) = 1.44 + 0.82 + 1.25 = 3.51$$\n\n-   The third invariant $I_3$ is the determinant of $C$. This can be computed as $(\\det F)^2$. Since $F$ is upper triangular, its determinant is the product of its diagonal elements.\n    $$\\det(F) = 1.2 \\times 0.9 \\times 1.1 = 1.188$$\n    $$I_3 = \\det(C) = (\\det F)^2 = (1.188)^2 = 1.411344$$\n\n-   The second invariant $I_2$ is computed using the formula $I_2 = C_{11}C_{22} + C_{22}C_{33} + C_{33}C_{11} - (C_{12}^2 + C_{23}^2 + C_{31}^2)$.\n    $$I_2 = (1.44)(0.82) + (0.82)(1.25) + (1.25)(1.44) - \\left( (0.12)^2 + (0.18)^2 + (0.0)^2 \\right)$$\n    $$I_2 = 1.1808 + 1.025 + 1.8 - (0.0144 + 0.0324 + 0)$$\n    $$I_2 = 4.0058 - 0.0468 = 3.959$$\n\nThe computed invariants are: $I_1 = 3.51$, $I_2 = 3.959$, and $I_3 = 1.411344$.\n\n**3. Second Piola-Kirchhoff Stress Tensor $S$**\n\nThe Second Piola-Kirchhoff stress tensor $S$ is related to the strain energy density function $\\psi$ by $S = 2 \\frac{\\partial \\psi}{\\partial C}$. We use the chain rule:\n$$S = 2 \\left( \\frac{\\partial \\psi}{\\partial I_1} \\frac{\\partial I_1}{\\partial C} + \\frac{\\partial \\psi}{\\partial I_2} \\frac{\\partial I_2}{\\partial C} + \\frac{\\partial \\psi}{\\partial I_3} \\frac{\\partial I_3}{\\partial C} \\right)$$\nFirst, we find the partial derivatives of $\\psi$ with respect to the invariants. The term with $J$ is rewritten in terms of $I_3$:\n$$\\frac{\\kappa}{2}(\\ln J)^2 = \\frac{\\kappa}{2}(\\ln \\sqrt{I_3})^2 = \\frac{\\kappa}{2} \\left( \\frac{1}{2}\\ln I_3 \\right)^2 = \\frac{\\kappa}{8}(\\ln I_3)^2$$\nThe derivatives are:\n$$\\frac{\\partial \\psi}{\\partial I_1} = \\frac{a_1}{2}, \\quad \\frac{\\partial \\psi}{\\partial I_2} = \\frac{a_2}{2}, \\quad \\frac{\\partial \\psi}{\\partial I_3} = \\frac{\\kappa}{8} \\cdot 2 (\\ln I_3) \\cdot \\frac{1}{I_3} = \\frac{\\kappa}{4} \\frac{\\ln I_3}{I_3}$$\nThe derivatives of the invariants with respect to $C$ are standard results in tensor calculus:\n$$\\frac{\\partial I_1}{\\partial C} = I, \\quad \\frac{\\partial I_2}{\\partial C} = I_1 I - C, \\quad \\frac{\\partial I_3}{\\partial C} = I_3 C^{-1}$$\nwhere $I$ is the second-order identity tensor. Substituting these into the expression for $S$:\n$$S = 2 \\left[ \\left(\\frac{a_1}{2}\\right) I + \\left(\\frac{a_2}{2}\\right) (I_1 I - C) + \\left(\\frac{\\kappa}{4} \\frac{\\ln I_3}{I_3}\\right) (I_3 C^{-1}) \\right]$$\n$$S = a_1 I + a_2 (I_1 I - C) + \\frac{\\kappa}{2} (\\ln I_3) C^{-1}$$\n\n**4. Computation of $S_{11}$**\n\nWe need the $(1,1)$-component of the tensor $S$:\n$$S_{11} = a_1 I_{11} + a_2 (I_1 I_{11} - C_{11}) + \\frac{\\kappa}{2} (\\ln I_3) (C^{-1})_{11}$$\nWith $I_{11} = 1$:\n$$S_{11} = a_1 + a_2(I_1 - C_{11}) + \\frac{\\kappa}{2} (\\ln I_3) (C^{-1})_{11}$$\nThe component $(C^{-1})_{11}$ is the $(1,1)$-element of the adjugate of $C$ divided by $\\det(C)=I_3$:\n$$(C^{-1})_{11} = \\frac{1}{I_3} (C_{22}C_{33} - C_{23}C_{32}) = \\frac{(0.82)(1.25) - (0.18)^2}{1.411344}$$\n$$(C^{-1})_{11} = \\frac{1.025 - 0.0324}{1.411344} = \\frac{0.9926}{1.411344}$$\nNow, substitute the numerical values:\n-   $a_1 = 40.0$ MPa\n-   $a_2 = 10.0$ MPa\n-   $\\kappa = 200.0$ MPa\n-   $I_1 = 3.51$\n-   $C_{11} = 1.44$\n-   $I_3 = 1.411344$\n$$S_{11} = 40 + 10(3.51 - 1.44) + \\frac{200}{2} \\ln(1.411344) \\left( \\frac{0.9926}{1.411344} \\right)$$\n$$S_{11} = 40 + 10(2.07) + 100 \\ln(1.411344) \\left( \\frac{0.9926}{1.411344} \\right)$$\n$$S_{11} = 40 + 20.7 + 100 (0.344558\\dots) (0.703344\\dots)$$\n$$S_{11} = 60.7 + 24.23235\\dots$$\n$$S_{11} = 84.93235\\dots~\\text{MPa}$$\nRounding the final result to four significant figures gives:\n$$S_{11} \\approx 84.93~\\text{MPa}$$",
            "answer": "$$\\boxed{84.93}$$"
        },
        {
            "introduction": "Unlike laws derived from first principles, data-driven models are not inherently guaranteed to respect fundamental physical constraints. Therefore, a critical step in the discovery pipeline is rigorous validation. This practice  challenges you to act as a critical assessor of a learned model, implementing checks for physical consistency, such as material stability, and quantifying the risk of extrapolation beyond the training data's domain.",
            "id": "3748583",
            "problem": "You are given a small-strain, plane-stress data-driven constitutive setting in which a learned linear mapping relates the symmetric strain tensor to the symmetric stress tensor via a matrix acting on the Voigt representation. Let the Voigt strain vector be $\\mathbf{e} = (e_{xx}, e_{yy}, e_{xy})^\\top \\in \\mathbb{R}^3$, and let the learned stiffness matrix be $\\mathbf{C} \\in \\mathbb{R}^{3 \\times 3}$. The learned stress is $\\mathbf{s} = \\mathbf{C} \\,\\mathbf{e}$. Assume all quantities are nondimensionalized, so every value is dimensionless.\n\nFundamental base and constraints:\n- Under small-strain linear elasticity, the existence of a strain energy density $W(\\mathbf{e})$ requires the stress to be derived from a potential, $\\mathbf{s} = \\frac{\\partial W}{\\partial \\mathbf{e}}$, which implies the stiffness must be symmetric, i.e., $\\mathbf{C} = \\mathbf{C}^\\top$. For a quadratic energy $W(\\mathbf{e}) = \\frac{1}{2} \\,\\mathbf{e}^\\top \\mathbf{C}_s \\,\\mathbf{e}$, where $\\mathbf{C}_s = \\frac{1}{2}(\\mathbf{C}+\\mathbf{C}^\\top)$ is the symmetric part, material stability requires $\\mathbf{C}_s$ to be positive definite (all eigenvalues strictly positive).\n- Energy nonnegativity and monotonicity along rays: for any nonzero strain direction $\\mathbf{e}$ and scalar loading parameter $\\lambda \\ge 0$, the energy along the ray $\\mathbf{e}(\\lambda) = \\lambda \\mathbf{e}$ must satisfy $\\frac{\\mathrm{d}}{\\mathrm{d}\\lambda} W(\\mathbf{e}(\\lambda)) = \\mathbf{s}(\\lambda) \\cdot \\mathbf{e} = \\lambda \\,\\mathbf{e}^\\top \\mathbf{C}_s \\,\\mathbf{e} \\ge 0$, which is guaranteed if $\\mathbf{C}_s$ is positive definite; violations occur when $\\mathbf{e}^\\top \\mathbf{C}_s \\,\\mathbf{e}  0$.\n- Data-driven extrapolation risk assessment: given a set of training strains $\\mathcal{E}=\\{\\mathbf{e}_i\\}_{i=1}^N$, a test strain $\\mathbf{e}^\\star$ is said to be an extrapolation risk if it lies outside the convex hull $\\mathrm{conv}(\\mathcal{E})$, i.e., there does not exist nonnegative weights $\\{w_i\\}$ summing to $1$ such that $\\sum_i w_i \\mathbf{e}_i = \\mathbf{e}^\\star$.\n\nYour task is to write a program that, for a fixed training set $\\mathcal{E}$ and a test suite of learned stiffness matrices $\\mathbf{C}$ with corresponding test strains $\\mathbf{e}^\\star$, assesses extrapolation risk and quantifies violations of physical constraints.\n\nTraining set (common to all test cases), given as four points in $\\mathbb{R}^3$:\n- $\\mathbf{e}_1 = (0, 0, 0)$,\n- $\\mathbf{e}_2 = (0.02, 0, 0)$,\n- $\\mathbf{e}_3 = (0, 0.02, 0)$,\n- $\\mathbf{e}_4 = (0.01, 0.01, 0.005)$.\n\nTest suite consists of four cases. For each case $k \\in \\{1,2,3,4\\}$, you are given a learned stiffness matrix $\\mathbf{C}^{(k)}$ and a test strain $\\mathbf{e}^{\\star (k)}$:\n1. Case $1$ (symmetric positive definite, extrapolation expected):\n   - $\\mathbf{C}^{(1)} = \\begin{pmatrix} 1000  300  0 \\\\ 300  800  0 \\\\ 0  0  200 \\end{pmatrix}$,\n   - $\\mathbf{e}^{\\star (1)} = (0.03, 0.01, -0.002)$.\n2. Case $2$ (mild asymmetry, near-stable, inside hull expected):\n   - $\\mathbf{C}^{(2)} = \\begin{pmatrix} 900  250  10 \\\\ 260  750  -5 \\\\ 5  -20  150 \\end{pmatrix}$,\n   - $\\mathbf{e}^{\\star (2)} = (0.01, 0.01, 0)$.\n3. Case $3$ (symmetric, positive semidefinite, boundary of stability):\n   - $\\mathbf{C}^{(3)} = \\begin{pmatrix} 500  0  0 \\\\ 0  0  0 \\\\ 0  0  100 \\end{pmatrix}$,\n   - $\\mathbf{e}^{\\star (3)} = (0.02, 0.02, 0)$.\n4. Case $4$ (symmetric indefinite, energy can be negative in some directions):\n   - $\\mathbf{C}^{(4)} = \\begin{pmatrix} 100  -300  0 \\\\ -300  100  0 \\\\ 0  0  50 \\end{pmatrix}$,\n   - $\\mathbf{e}^{\\star (4)} = (0.015, 0.015, 0)$.\n\nFor each test case $k$, compute the following five quantities:\n- $Q_1^{(k)}$: a boolean indicating whether $\\mathbf{e}^{\\star (k)}$ lies outside the convex hull of the training set $\\mathcal{E}$ (True means outside; False means inside).\n- $Q_2^{(k)}$: the energy nonnegativity violation magnitude, defined as $Q_2^{(k)} = \\max\\{0, -W(\\mathbf{e}^{\\star (k)})\\}$ where $W(\\mathbf{e}) = \\frac{1}{2}\\,\\mathbf{e}^\\top \\mathbf{C}_s^{(k)} \\,\\mathbf{e}$ and $\\mathbf{C}_s^{(k)} = \\frac{1}{2}(\\mathbf{C}^{(k)} + \\mathbf{C}^{(k)\\top})$ is the symmetric part.\n- $Q_3^{(k)}$: the asymmetry norm of the learned stiffness, defined as $Q_3^{(k)} = \\|\\mathbf{C}^{(k)} - \\mathbf{C}^{(k)\\top}\\|_F$, where $\\|\\cdot\\|_F$ denotes the Frobenius norm.\n- $Q_4^{(k)}$: a boolean indicating violation of positive definiteness of $\\mathbf{C}_s^{(k)}$, i.e., True if any eigenvalue of $\\mathbf{C}_s^{(k)}$ is less than or equal to a tolerance $\\varepsilon = 10^{-12}$, and False otherwise.\n- $Q_5^{(k)}$: a boolean indicating violation of ray-wise monotonicity, i.e., True if $\\mathbf{e}^{\\star (k)\\top} \\mathbf{C}_s^{(k)} \\mathbf{e}^{\\star (k)}  -\\varepsilon$ and False otherwise, with the same $\\varepsilon$.\n\nAll computations must be carried out using the symmetric part $\\mathbf{C}_s^{(k)}$ wherever energy or definiteness is involved. Treat all values as dimensionless. Use a numerical tolerance of $\\varepsilon = 10^{-12}$ for definiteness and monotonicity checks.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order:\n$[Q_1^{(1)}, Q_2^{(1)}, Q_3^{(1)}, Q_4^{(1)}, Q_5^{(1)}, Q_1^{(2)}, Q_2^{(2)}, Q_3^{(2)}, Q_4^{(2)}, Q_5^{(2)}, Q_1^{(3)}, Q_2^{(3)}, Q_3^{(3)}, Q_4^{(3)}, Q_5^{(3)}, Q_1^{(4)}, Q_2^{(4)}, Q_3^{(4)}, Q_4^{(4)}, Q_5^{(4)}]$.\n\nDesign the algorithm from first principles stated above, without invoking any pre-packaged convex hull routines; to assess convex containment, you may determine whether there exist nonnegative weights summing to $1$ that reproduce the test strain as a convex combination of the training strains by solving a feasibility problem. All outputs must be dimensionless floats or booleans as defined, and the final line must match exactly the specified format.",
            "solution": "The problem statement has been meticulously reviewed and is deemed valid. It is scientifically grounded in the principles of linear elasticity and continuum mechanics, well-posed with all necessary data and definitions provided, and objective in its formulation. The tasks are clearly defined mathematical computations that admit a unique solution.\n\nThe solution proceeds by implementing algorithms to compute five distinct quantities for each of the four test cases. These quantities assess a data-driven constitutive model's adherence to physical principles and its extrapolation behavior. The principles and corresponding computational methods are detailed below for each quantity.\n\nFirst, we define the common data for all test cases. The training set of strain vectors is $\\mathcal{E} = \\{\\mathbf{e}_1, \\mathbf{e}_2, \\mathbf{e}_3, \\mathbf{e}_4\\}$, where:\n$$\n\\mathbf{e}_1 = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}, \\quad\n\\mathbf{e}_2 = \\begin{pmatrix} 0.02 \\\\ 0 \\\\ 0 \\end{pmatrix}, \\quad\n\\mathbf{e}_3 = \\begin{pmatrix} 0 \\\\ 0.02 \\\\ 0 \\end{pmatrix}, \\quad\n\\mathbf{e}_4 = \\begin{pmatrix} 0.01 \\\\ 0.01 \\\\ 0.005 \\end{pmatrix}\n$$\nThe numerical tolerance for checks involving near-zero values is given as $\\varepsilon = 10^{-12}$. For each test case $k$, we are given a learned stiffness matrix $\\mathbf{C}^{(k)}$ and a test strain $\\mathbf{e}^{\\star (k)}$.\n\nThe core of the analysis relies on the symmetric part of the stiffness matrix, $\\mathbf{C}_s$, which governs the strain energy. For any given learned matrix $\\mathbf{C}$, its symmetric part is computed as:\n$$\n\\mathbf{C}_s = \\frac{1}{2}\\left(\\mathbf{C} + \\mathbf{C}^\\top\\right)\n$$\n\nThe five quantities are computed as follows:\n\n$Q_1^{(k)}$: Extrapolation Risk\nThis quantity is a boolean indicating whether the test strain $\\mathbf{e}^{\\star (k)}$ lies outside the convex hull of the training set, $\\mathrm{conv}(\\mathcal{E})$. By the definition of a convex hull, a point $\\mathbf{e}^\\star$ is inside or on the boundary of $\\mathrm{conv}(\\mathcal{E})$ if and only if it can be expressed as a convex combination of the points in $\\mathcal{E}$. That is, there must exist a set of non-negative weights $\\{w_i\\}_{i=1}^4$ such that:\n$$\n\\sum_{i=1}^4 w_i \\mathbf{e}_i = \\mathbf{e}^{\\star (k)} \\quad \\text{and} \\quad \\sum_{i=1}^4 w_i = 1, \\quad w_i \\ge 0\n$$\nThis constitutes a linear programming feasibility problem. Let the weights be the unknown vector $\\mathbf{w} = (w_1, w_2, w_3, w_4)^\\top$. The conditions can be written in matrix form as $\\mathbf{A}_{\\text{eq}} \\mathbf{w} = \\mathbf{b}_{\\text{eq}}$, where:\n$$\n\\mathbf{A}_{\\text{eq}} = \\begin{pmatrix} |  |  |  | \\\\ \\mathbf{e}_1  \\mathbf{e}_2  \\mathbf{e}_3  \\mathbf{e}_4 \\\\ |  |  |  | \\\\ 1  1  1  1 \\end{pmatrix} \\in \\mathbb{R}^{4 \\times 4}, \\quad\n\\mathbf{b}_{\\text{eq}} = \\begin{pmatrix} | \\\\ \\mathbf{e}^{\\star (k)} \\\\ | \\\\ 1 \\end{pmatrix} \\in \\mathbb{R}^{4}\n$$\nThe problem is to find a vector $\\mathbf{w}$ that satisfies this system of equations along with the non-negativity constraint $\\mathbf{w} \\ge \\mathbf{0}$. We can solve this using a linear programming solver, such as `scipy.optimize.linprog`, with an arbitrary objective function (e.g., minimizing $0$). If the solver finds a feasible solution, $\\mathbf{e}^{\\star (k)}$ is inside the convex hull, and $Q_1^{(k)}$ is `False`. If no such solution exists, $\\mathbf{e}^{\\star (k)}$ is outside, and $Q_1^{(k)}$ is `True`.\n\n$Q_2^{(k)}$: Energy Nonnegativity Violation\nThe strain energy density $W$ associated with a linear elastic material is a quadratic function of the strain, defined through the symmetric part of the stiffness matrix: $W(\\mathbf{e}) = \\frac{1}{2} \\mathbf{e}^\\top \\mathbf{C}_s \\mathbf{e}$. A fundamental requirement of material physics is that strain energy must be non-negative, $W(\\mathbf{e}) \\ge 0$. A violation occurs if, for a given strain, the computed energy is negative. The magnitude of this violation for the test strain $\\mathbf{e}^{\\star (k)}$ is quantified as:\n$$\nQ_2^{(k)} = \\max\\{0, -W(\\mathbf{e}^{\\star (k)})\\} = \\max\\left\\{0, -\\frac{1}{2} (\\mathbf{e}^{\\star (k)})^\\top \\mathbf{C}_s^{(k)} \\mathbf{e}^{\\star (k)}\\right\\}\n$$\nThis is a direct calculation involving matrix-vector multiplication.\n\n$Q_3^{(k)}$: Asymmetry Norm\nThe existence of a strain energy potential function $W(\\mathbf{e})$ from which the stress can be derived ($\\mathbf{s} = \\partial W / \\partial \\mathbf{e}$) mathematically requires the stiffness matrix to be symmetric. This is known as a Maxwell relation. A learned stiffness matrix $\\mathbf{C}^{(k)}$ from data might not be perfectly symmetric. The deviation from symmetry is a measure of physical inconsistency. We quantify this deviation using the Frobenius norm of the difference between the matrix and its transpose:\n$$\nQ_3^{(k)} = \\|\\mathbf{C}^{(k)} - (\\mathbf{C}^{(k)})^\\top\\|_F = \\sqrt{\\sum_{i=1}^3 \\sum_{j=1}^3 (C_{ij}^{(k)} - C_{ji}^{(k)})^2}\n$$\nThis is computed using standard linear algebra library functions.\n\n$Q_4^{(k)}$: Positive Definiteness Violation\nFor material stability, the strain energy density $W(\\mathbf{e})$ must be strictly positive for any non-zero strain $\\mathbf{e}$. This condition is met if and only if the symmetric stiffness matrix $\\mathbf{C}_s$ is positive definite. A matrix is positive definite if all of its eigenvalues are strictly positive. A violation occurs if $\\mathbf{C}_s^{(k)}$ has at least one eigenvalue that is zero or negative. Computationally, we check if the minimum eigenvalue $\\lambda_{\\min}(\\mathbf{C}_s^{(k)})$ is less than or equal to a small tolerance $\\varepsilon = 10^{-12}$:\n$$\nQ_4^{(k)} = \\begin{cases} \\text{True}  \\text{if } \\lambda_{\\min}(\\mathbf{C}_s^{(k)}) \\le \\varepsilon \\\\ \\text{False}  \\text{otherwise} \\end{cases}\n$$\nSince $\\mathbf{C}_s^{(k)}$ is symmetric, its eigenvalues are real and can be computed efficiently.\n\n$Q_5^{(k)}$: Ray-wise Monotonicity Violation\nThis is a related but distinct check from energy nonnegativity at a single point. It examines the behavior of energy along a ray from the origin in the direction of the test strain $\\mathbf{e}^{\\star (k)}$. The energy along this ray is $W(\\lambda \\mathbf{e}^{\\star (k)}) = \\frac{1}{2} \\lambda^2 ((\\mathbf{e}^{\\star (k)})^\\top \\mathbf{C}_s^{(k)} \\mathbf{e}^{\\star (k)})$. For energy to be non-decreasing with the loading parameter $\\lambda \\ge 0$, the quadratic form $(\\mathbf{e}^{\\star (k)})^\\top \\mathbf{C}_s^{(k)} \\mathbf{e}^{\\star (k)}$ must be non-negative. A violation occurs if this quantity is negative. We use a tolerance $\\varepsilon$ for this check:\n$$\nQ_5^{(k)} = \\begin{cases} \\text{True}  \\text{if } (\\mathbf{e}^{\\star (k)})^\\top \\mathbf{C}_s^{(k)} \\mathbf{e}^{\\star (k)}  -\\varepsilon \\\\ \\text{False}  \\text{otherwise} \\end{cases}\n$$\nThis check directly evaluates whether the specific direction defined by $\\mathbf{e}^{\\star (k)}$ is a direction of decreasing energy, which is a sign of instability.\n\nThe implementation will now proceed by applying these five computational steps to each of the four test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves the data-driven constitutive model validation problem.\n    \"\"\"\n\n    # Define the training set of strain vectors.\n    e_train = [\n        np.array([0., 0., 0.]),\n        np.array([0.02, 0., 0.]),\n        np.array([0., 0.02, 0.]),\n        np.array([0.01, 0.01, 0.005])\n    ]\n\n    # Define the four test cases.\n    test_cases = [\n        {\n            \"C\": np.array([\n                [1000., 300., 0.],\n                [300., 800., 0.],\n                [0., 0., 200.]\n            ]),\n            \"e_star\": np.array([0.03, 0.01, -0.002])\n        },\n        {\n            \"C\": np.array([\n                [900., 250., 10.],\n                [260., 750., -5.],\n                [5., -20., 150.]\n            ]),\n            \"e_star\": np.array([0.01, 0.01, 0.])\n        },\n        {\n            \"C\": np.array([\n                [500., 0., 0.],\n                [0., 0., 0.],\n                [0., 0., 100.]\n            ]),\n            \"e_star\": np.array([0.02, 0.02, 0.])\n        },\n        {\n            \"C\": np.array([\n                [100., -300., 0.],\n                [-300., 100., 0.],\n                [0., 0., 50.]\n            ]),\n            \"e_star\": np.array([0.015, 0.015, 0.])\n        }\n    ]\n\n    # Set numerical tolerance.\n    TOLERANCE = 1e-12\n\n    # Prepare for convex hull checks (A_eq is common to all cases).\n    # A_eq is a 4x4 matrix from the convex combination equations.\n    # The first 3 rows are the training strain vectors as columns.\n    # The last row is [1, 1, 1, 1] for the sum-to-one constraint on weights.\n    A_eq = np.vstack([np.array(e_train).T, np.ones(len(e_train))])\n\n    results = []\n    for case in test_cases:\n        C = case[\"C\"]\n        e_star = case[\"e_star\"]\n\n        # --- Q1: Extrapolation Risk (Convex Hull Check) ---\n        # b_eq is a vector of length 4.\n        # The first 3 elements are the test strain vector.\n        # The last element is 1 for the sum-to-one constraint.\n        b_eq = np.hstack([e_star, 1.0])\n        # We seek weights w >= 0 such that A_eq @ w = b_eq.\n        # Objective function c is irrelevant for a feasibility problem.\n        c = np.zeros(len(e_train))\n        # Use scipy's linear programming solver. Non-negativity of weights is handled by bounds.\n        # method='highs' is a robust simplex and interior-point method.\n        lp_res = linprog(c=c, A_eq=A_eq, b_eq=b_eq, bounds=(0, None), method='highs')\n        \n        # A successful solve means weights were found, so e_star is IN the hull.\n        # The question asks for True if OUTSIDE the hull.\n        q1 = not lp_res.success\n\n        # --- Symmetric part of the stiffness matrix ---\n        C_s = 0.5 * (C + C.T)\n\n        # --- Q2: Energy Nonnegativity Violation ---\n        # W(e) = 0.5 * e.T @ C_s @ e\n        W_e_star = 0.5 * e_star.T @ C_s @ e_star\n        q2 = np.maximum(0.0, -W_e_star)\n\n        # --- Q3: Asymmetry Norm ---\n        # Frobenius norm of (C - C.T)\n        q3 = np.linalg.norm(C - C.T, 'fro')\n\n        # --- Q4: Positive Definiteness Violation ---\n        # Eigenvalues of the symmetric matrix C_s.\n        # np.linalg.eigvalsh is efficient and numerically stable for Hermitian matrices.\n        eigenvalues = np.linalg.eigvalsh(C_s)\n        # Violation if any eigenvalue is = tolerance.\n        q4 = np.any(eigenvalues = TOLERANCE)\n\n        # --- Q5: Ray-wise Monotonicity Violation ---\n        # Check if e_star.T @ C_s @ e_star is negative.\n        quadratic_form = e_star.T @ C_s @ e_star\n        q5 = quadratic_form  -TOLERANCE\n        \n        results.extend([q1, q2, q3, q4, q5])\n\n    # Format the output as a single string.\n    # Booleans are automatically converted to 'True'/'False'.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n\n```"
        },
        {
            "introduction": "Many advanced materials, such as metals, exhibit history-dependent behavior like plasticity, which requires iterative numerical algorithms for their simulation. This exercise  delves into a cutting-edge topic: making these classical algorithms differentiable components within a larger machine learning framework. By implementing a differentiable return-mapping algorithm, you will learn how to compute the analytical Jacobians needed for efficient, end-to-end training of data-driven plasticity models.",
            "id": "3748599",
            "problem": "You are tasked with constructing a differentiable return-mapping layer for small-strain von Mises (also called $J_2$) plasticity with isotropic elasticity and a differentiable isotropic hardening law. The layer must enforce the yield consistency condition and compute the Jacobian of the stress update with respect to a set of scalar hardening parameters for use in end-to-end training within Finite Element (FE) simulations.\n\nThe setting is three-dimensional small-strain kinematics. Let the total strain tensor be denoted by $\\boldsymbol{\\varepsilon} \\in \\mathbb{R}^{3 \\times 3}$ (symmetric), the Cauchy stress tensor by $\\boldsymbol{\\sigma} \\in \\mathbb{R}^{3 \\times 3}$ (symmetric), and the accumulated equivalent plastic strain by $\\alpha \\in \\mathbb{R}_{\\ge 0}$. The elastic constitutive law is isotropic and given by Hooke’s law:\n$$\n\\boldsymbol{\\sigma} = \\lambda \\, \\mathrm{tr}(\\boldsymbol{\\varepsilon} - \\boldsymbol{\\varepsilon}^{p}) \\, \\mathbf{I} + 2 \\mu \\, (\\boldsymbol{\\varepsilon} - \\boldsymbol{\\varepsilon}^{p}),\n$$\nwhere $\\boldsymbol{\\varepsilon}^{p}$ is the plastic strain tensor, $\\lambda$ and $\\mu$ are the Lamé parameters, and $\\mathbf{I}$ is the identity tensor. Young’s modulus $E$ and Poisson’s ratio $\\nu$ relate to the Lamé parameters via $\\mu = \\dfrac{E}{2(1+\\nu)}$ and $\\lambda = \\dfrac{E \\nu}{(1+\\nu)(1-2\\nu)}$.\n\nDefine the deviatoric stress $\\mathbf{s} = \\boldsymbol{\\sigma} - \\dfrac{1}{3} \\mathrm{tr}(\\boldsymbol{\\sigma}) \\, \\mathbf{I}$ and the von Mises equivalent stress as\n$$\n\\sigma_{\\mathrm{eq}} = \\sqrt{\\dfrac{3}{2}} \\, \\lVert \\mathbf{s} \\rVert_F,\n$$\nwhere $\\lVert \\cdot \\rVert_F$ denotes the Frobenius norm. Plastic yielding occurs if the yield function\n$$\n\\Phi(\\boldsymbol{\\sigma}, \\alpha; \\boldsymbol{\\pi}) := \\sigma_{\\mathrm{eq}} - \\sigma_y(\\alpha; \\boldsymbol{\\pi})\n$$\nexceeds zero, where $\\sigma_y(\\alpha; \\boldsymbol{\\pi})$ is the differentiable isotropic hardening law parameterized by the parameter vector $\\boldsymbol{\\pi} = [\\sigma_0, a_1, a_2, a_3]^\\top$. The hardening law is defined as\n$$\n\\sigma_y(\\alpha; \\boldsymbol{\\pi}) = \\sigma_0 + a_1 \\alpha + a_2 \\tanh(a_3 \\alpha),\n$$\nwhere $\\sigma_0$ is the initial yield stress (units: megapascal, abbreviated MPa), $a_1$ and $a_2$ have units of MPa, and $a_3$ is dimensionless. The variable $\\alpha$ is dimensionless.\n\nFor a given increment, the elastic predictor produces the trial stress $\\boldsymbol{\\sigma}^{\\mathrm{tr}}$ and its deviatoric part $\\mathbf{s}^{\\mathrm{tr}}$, with equivalent stress $\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} = \\sqrt{\\dfrac{3}{2}} \\lVert \\mathbf{s}^{\\mathrm{tr}} \\rVert_F$. If $\\Phi(\\boldsymbol{\\sigma}^{\\mathrm{tr}}, \\alpha_n; \\boldsymbol{\\pi}) \\le 0$ (where $\\alpha_n$ is the prior accumulated plastic strain), the step is elastic and $\\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{\\sigma}^{\\mathrm{tr}}$, $\\alpha_{n+1} = \\alpha_n$, and the Jacobian of $\\boldsymbol{\\sigma}_{n+1}$ with respect to $\\boldsymbol{\\pi}$ is zero.\n\nIf $\\Phi(\\boldsymbol{\\sigma}^{\\mathrm{tr}}, \\alpha_n; \\boldsymbol{\\pi})  0$, plastic correction is required. Use the standard radial return mapping based on the plastic multiplier $\\Delta \\gamma \\ge 0$, with unit flow direction\n$$\n\\mathbf{n} = \\dfrac{\\mathbf{s}^{\\mathrm{tr}}}{\\lVert \\mathbf{s}^{\\mathrm{tr}} \\rVert_F},\n$$\nand update equations\n$$\n\\mathbf{s}_{n+1} = \\mathbf{s}^{\\mathrm{tr}} - 2 \\mu \\, \\Delta \\gamma \\, \\mathbf{n}, \\quad \\alpha_{n+1} = \\alpha_n + \\sqrt{\\dfrac{2}{3}} \\, \\Delta \\gamma,\n$$\nwith hydrostatic stress preserved, i.e., $\\mathrm{tr}(\\boldsymbol{\\sigma}_{n+1}) = \\mathrm{tr}(\\boldsymbol{\\sigma}^{\\mathrm{tr}})$. The consistency condition is enforced by solving the scalar nonlinear equation\n$$\ng(\\Delta \\gamma; \\alpha_n, \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}, \\mu, \\boldsymbol{\\pi}) := \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - 2 \\mu \\, \\Delta \\gamma - \\sigma_y\\!\\left(\\alpha_n + \\sqrt{\\dfrac{2}{3}} \\, \\Delta \\gamma; \\boldsymbol{\\pi}\\right) = 0.\n$$\nThe function $g$ is monotone in $\\Delta \\gamma$ under physically reasonable parameters and can be solved by Newton’s method. Upon convergence to $\\Delta \\gamma^\\star$, the updated stress is\n$$\n\\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{\\sigma}^{\\mathrm{tr}} - 2 \\mu \\, \\Delta \\gamma^\\star \\, \\mathbf{n}.\n$$\n\nCompute the Jacobian of $\\boldsymbol{\\sigma}_{n+1}$ with respect to $\\boldsymbol{\\pi}$ using the implicit function theorem. Let $k = \\sqrt{\\dfrac{2}{3}}$, and denote $\\alpha^\\star = \\alpha_n + k \\Delta \\gamma^\\star$. The derivative $\\dfrac{\\partial \\sigma_y}{\\partial \\alpha}$ is\n$$\n\\dfrac{\\partial \\sigma_y}{\\partial \\alpha}(\\alpha^\\star; \\boldsymbol{\\pi}) = a_1 + a_2 a_3 \\, \\mathrm{sech}^2(a_3 \\alpha^\\star),\n$$\nand the partial derivatives with respect to parameters are\n$$\n\\dfrac{\\partial \\sigma_y}{\\partial \\sigma_0} = 1, \\quad\n\\dfrac{\\partial \\sigma_y}{\\partial a_1} = \\alpha^\\star, \\quad\n\\dfrac{\\partial \\sigma_y}{\\partial a_2} = \\tanh(a_3 \\alpha^\\star), \\quad\n\\dfrac{\\partial \\sigma_y}{\\partial a_3} = a_2 \\alpha^\\star \\, \\mathrm{sech}^2(a_3 \\alpha^\\star).\n$$\nImplicit differentiation of $g(\\Delta \\gamma^\\star, \\boldsymbol{\\pi}) = 0$ gives, for each parameter $\\pi_i \\in \\{\\sigma_0, a_1, a_2, a_3\\}$,\n$$\n\\dfrac{\\partial \\Delta \\gamma^\\star}{\\partial \\pi_i} =\n- \\dfrac{\\dfrac{\\partial g}{\\partial \\pi_i}}{\\dfrac{\\partial g}{\\partial \\Delta \\gamma}}\n=\n- \\dfrac{- \\dfrac{\\partial \\sigma_y}{\\partial \\pi_i}(\\alpha^\\star; \\boldsymbol{\\pi})}{-2 \\mu - k \\, \\dfrac{\\partial \\sigma_y}{\\partial \\alpha}(\\alpha^\\star; \\boldsymbol{\\pi})}\n=\n\\dfrac{\\dfrac{\\partial \\sigma_y}{\\partial \\pi_i}(\\alpha^\\star; \\boldsymbol{\\pi})}{2 \\mu + k \\, \\dfrac{\\partial \\sigma_y}{\\partial \\alpha}(\\alpha^\\star; \\boldsymbol{\\pi})}.\n$$\nHence the Jacobian of the stress tensor with respect to parameters is\n$$\n\\dfrac{\\partial \\boldsymbol{\\sigma}_{n+1}}{\\partial \\pi_i}\n=\n- 2 \\mu \\, \\mathbf{n} \\, \\dfrac{\\partial \\Delta \\gamma^\\star}{\\partial \\pi_i},\n$$\nwhere $\\mathbf{n}$ is held constant in differentiation with respect to $\\boldsymbol{\\pi}$ because $\\mathbf{n}$ depends only on the elastic predictor. In elastic steps, the Jacobian is identically zero.\n\nImplementation requirements:\n- Use units of stress in megapascal (MPa). Any reported stress, yield residual, or Jacobian norm must be in MPa. The accumulated plastic strain $\\alpha$ and $\\Delta \\gamma$ are dimensionless. Angles are not involved in this problem.\n- Construct a program that, for a given set of material parameters, prior plastic strain $\\alpha_n$, and total strain tensor $\\boldsymbol{\\varepsilon}$, performs:\n  1. Elastic prediction to determine $\\boldsymbol{\\sigma}^{\\mathrm{tr}}$ and $\\mathbf{s}^{\\mathrm{tr}}$.\n  2. Yield check and, if needed, Newton solve for $\\Delta \\gamma^\\star$ to enforce $g(\\Delta \\gamma^\\star) = 0$.\n  3. Update $\\boldsymbol{\\sigma}_{n+1}$ and compute the Jacobian tensors $\\dfrac{\\partial \\boldsymbol{\\sigma}_{n+1}}{\\partial \\pi_i}$ for $i \\in \\{1,2,3,4\\}$.\n  4. Compute the yield consistency residual magnitude as $|g(\\Delta \\gamma^\\star)|$ in MPa (use $0$ for the elastic case).\n  5. Compute the Frobenius norm in MPa of each Jacobian tensor $\\dfrac{\\partial \\boldsymbol{\\sigma}_{n+1}}{\\partial \\pi_i}$ over the $3 \\times 3$ stress tensor.\n\nTest suite:\nUse the following four test cases to exercise different aspects of the algorithm. In all cases, take $E = 210000$ MPa, $\\nu = 0.3$, $\\boldsymbol{\\varepsilon}^{p}_n = \\mathbf{0}$, and $\\alpha_n = 0$ unless stated otherwise. Each strain tensor $\\boldsymbol{\\varepsilon}$ must be symmetric.\n\n- Case $1$ (plastic, happy path): $\\boldsymbol{\\varepsilon}$ has pure shear with $\\varepsilon_{12} = \\varepsilon_{21} = 0.01$ and all other components zero; parameters $\\boldsymbol{\\pi} = [\\sigma_0, a_1, a_2, a_3] = [400, 1000, 50, 10]$.\n- Case $2$ (near-yield boundary): $\\boldsymbol{\\varepsilon}$ has pure shear with $\\varepsilon_{12} = \\varepsilon_{21} = 0.00143$ and all other components zero; parameters $\\boldsymbol{\\pi} = [400, 1000, 50, 10]$.\n- Case $3$ (hydrostatic, edge case): $\\boldsymbol{\\varepsilon}$ is hydrostatic with $\\varepsilon_{11} = \\varepsilon_{22} = \\varepsilon_{33} = 0.001$ and all off-diagonal components zero; parameters $\\boldsymbol{\\pi} = [400, 1000, 50, 10]$.\n- Case $4$ (zero strain, edge case): $\\boldsymbol{\\varepsilon}$ is zero; parameters $\\boldsymbol{\\pi} = [400, 1000, 50, 10]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, the program must output the following values in order:\n- Yield residual magnitude in MPa (float),\n- Frobenius norm in MPa of $\\dfrac{\\partial \\boldsymbol{\\sigma}_{n+1}}{\\partial \\sigma_0}$ (float),\n- Frobenius norm in MPa of $\\dfrac{\\partial \\boldsymbol{\\sigma}_{n+1}}{\\partial a_1}$ (float),\n- Frobenius norm in MPa of $\\dfrac{\\partial \\boldsymbol{\\sigma}_{n+1}}{\\partial a_2}$ (float),\n- Frobenius norm in MPa of $\\dfrac{\\partial \\boldsymbol{\\sigma}_{n+1}}{\\partial a_3}$ (float),\n- Elastic flag (boolean), which is true if the step is elastic and false if plastic.\n\nThus, the final single-line output must be a flattened list of $24$ entries for the four cases, for example:\n$[\\text{res}_1,\\text{J}_{\\sigma_0,1},\\text{J}_{a_1,1},\\text{J}_{a_2,1},\\text{J}_{a_3,1},\\text{elastic}_1,\\text{res}_2,\\ldots,\\text{elastic}_4]$.",
            "solution": "The problem is assessed to be valid. It is scientifically grounded in the principles of continuum mechanics and computational plasticity, well-posed, objective, and provides a complete and consistent set of definitions, equations, and data for implementation. The task involves creating a computational layer for a standard von Mises plasticity model with isotropic hardening and calculating its sensitivity with respect to hardening parameters, which is a standard and important procedure in modern mechanics, particularly for machine learning applications in materials science.\n\nThe procedure for determining the stress state $\\boldsymbol{\\sigma}_{n+1}$ and its Jacobians with respect to the hardening parameters $\\boldsymbol{\\pi}$ for a given incremental strain is detailed below.\n\nFirst, we define the material constants and key parameters. Young’s modulus $E$ and Poisson’s ratio $\\nu$ are given. From these, the Lamé parameters, shear modulus $\\mu$ and first Lamé parameter $\\lambda$, are calculated:\n$$\n\\mu = \\dfrac{E}{2(1+\\nu)}, \\quad \\lambda = \\dfrac{E \\nu}{(1+\\nu)(1-2\\nu)}\n$$\nThe problem consistently uses the convention that the current state is denoted by subscript $n+1$ and the previous state by $n$. All test cases start from a virgin material state, i.e., $\\boldsymbol{\\varepsilon}^{p}_n = \\mathbf{0}$ and the accumulated plastic strain $\\alpha_n = 0$. The plastic strain increment is related to the plastic multiplier increment $\\Delta\\gamma$ via a constant factor $k = \\sqrt{2/3}$.\n\nThe algorithm proceeds in four primary steps for each test case.\n\nStep 1: Elastic Predictor\nAn elastic trial state is computed assuming the entire strain increment is elastic. Given the total strain tensor $\\boldsymbol{\\varepsilon}_{n+1}$ (denoted as $\\boldsymbol{\\varepsilon}$ in the problem) and the plastic strain from the previous step $\\boldsymbol{\\varepsilon}^{p}_n$, the trial stress $\\boldsymbol{\\sigma}^{\\mathrm{tr}}$ is calculated using Hooke's law:\n$$\n\\boldsymbol{\\sigma}^{\\mathrm{tr}} = \\lambda \\, \\mathrm{tr}(\\boldsymbol{\\varepsilon}_{n+1} - \\boldsymbol{\\varepsilon}^{p}_n) \\, \\mathbf{I} + 2 \\mu \\, (\\boldsymbol{\\varepsilon}_{n+1} - \\boldsymbol{\\varepsilon}^{p}_n)\n$$\nSince $\\boldsymbol{\\varepsilon}^{p}_n = \\mathbf{0}$, this simplifies to $\\boldsymbol{\\sigma}^{\\mathrm{tr}} = \\lambda \\, \\mathrm{tr}(\\boldsymbol{\\varepsilon}_{n+1}) \\, \\mathbf{I} + 2 \\mu \\, \\boldsymbol{\\varepsilon}_{n+1}$.\nThe deviatoric part of the trial stress, $\\mathbf{s}^{\\mathrm{tr}}$, and the von Mises equivalent trial stress, $\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}$, are then computed:\n$$\n\\mathbf{s}^{\\mathrm{tr}} = \\boldsymbol{\\sigma}^{\\mathrm{tr}} - \\dfrac{1}{3} \\mathrm{tr}(\\boldsymbol{\\sigma}^{\\mathrm{tr}}) \\, \\mathbf{I}\n$$\n$$\n\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} = \\sqrt{\\dfrac{3}{2}} \\, \\lVert \\mathbf{s}^{\\mathrm{tr}} \\rVert_F\n$$\n\nStep 2: Yield Criterion Check\nThe yield condition is checked using the trial state. The yield stress, $\\sigma_y$, is evaluated at the previous accumulated plastic strain $\\alpha_n$ using the specified hardening law, which is parameterized by $\\boldsymbol{\\pi} = [\\sigma_0, a_1, a_2, a_3]^\\top$:\n$$\n\\sigma_y(\\alpha_n; \\boldsymbol{\\pi}) = \\sigma_0 + a_1 \\alpha_n + a_2 \\tanh(a_3 \\alpha_n)\n$$\nThe yield function $\\Phi$ is evaluated:\n$$\n\\Phi^{\\mathrm{tr}} = \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - \\sigma_y(\\alpha_n; \\boldsymbol{\\pi})\n$$\nIf $\\Phi^{\\mathrm{tr}} \\le 0$, the step is elastic. If $\\Phi^{\\mathrm{tr}}  0$, plastic deformation occurs, and a corrector step is necessary.\n\nStep 3: State Update\nIf the step is elastic ($\\Phi^{\\mathrm{tr}} \\le 0$):\nThe updated stress $\\boldsymbol{\\sigma}_{n+1}$ is the trial stress $\\boldsymbol{\\sigma}^{\\mathrm{tr}}$. The internal state variables remain unchanged: $\\boldsymbol{\\varepsilon}^{p}_{n+1} = \\boldsymbol{\\varepsilon}^{p}_n$ and $\\alpha_{n+1} = \\alpha_n$. The Jacobians of the stress with respect to the hardening parameters are all zero. The yield consistency residual is reported as $0$ as per the problem specification.\n\nIf the step is plastic ($\\Phi^{\\mathrm{tr}}  0$):\nA plastic corrector step, known as return mapping, is performed. The consistency condition must be satisfied at the end of the step, which leads to a scalar nonlinear equation for the plastic multiplier increment $\\Delta \\gamma$:\n$$\ng(\\Delta \\gamma) := \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - 2 \\mu \\, \\Delta \\gamma - \\sigma_y\\!\\left(\\alpha_n + \\sqrt{\\dfrac{2}{3}} \\, \\Delta \\gamma; \\boldsymbol{\\pi}\\right) = 0\n$$\nThis equation is solved for $\\Delta \\gamma^\\star \\ge 0$ using Newton's method. The iterative update for $\\Delta\\gamma$ is:\n$$\n\\Delta \\gamma_{j+1} = \\Delta \\gamma_j - \\dfrac{g(\\Delta \\gamma_j)}{g'(\\Delta \\gamma_j)}\n$$\nwhere the derivative $g'(\\Delta \\gamma)$ is:\n$$\ng'(\\Delta \\gamma) = -2 \\mu - \\sqrt{\\dfrac{2}{3}} \\dfrac{\\partial \\sigma_y}{\\partial \\alpha}\\left(\\alpha_n + \\sqrt{\\dfrac{2}{3}}\\Delta\\gamma; \\boldsymbol{\\pi}\\right)\n$$\nwith $\\dfrac{\\partial \\sigma_y}{\\partial \\alpha} = a_1 + a_2 a_3 \\, \\mathrm{sech}^2(a_3 \\alpha)$.\nUpon finding the solution $\\Delta \\gamma^\\star$, the state variables are updated. The flow direction is $\\mathbf{n} = \\mathbf{s}^{\\mathrm{tr}} / \\lVert \\mathbf{s}^{\\mathrm{tr}} \\rVert_F$. The updated stress is:\n$$\n\\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{\\sigma}^{\\mathrm{tr}} - 2 \\mu \\, \\Delta \\gamma^\\star \\, \\mathbf{n}\n$$\nThe accumulated plastic strain is updated as $\\alpha_{n+1} = \\alpha_n + \\sqrt{2/3} \\, \\Delta \\gamma^\\star$. The magnitude of the yield consistency residual $|g(\\Delta \\gamma^\\star)|$ is calculated.\n\nStep 4: Jacobian Computation\nFor a plastic step, the Jacobian of the updated stress $\\boldsymbol{\\sigma}_{n+1}$ with respect to each hardening parameter $\\pi_i \\in \\{\\sigma_0, a_1, a_2, a_3\\}$ is computed by differentiating the update equation. This relies on the sensitivity of the plastic multiplier, $\\frac{\\partial \\Delta \\gamma^\\star}{\\partial \\pi_i}$, which is found by applying the implicit function theorem to the consistency equation $g(\\Delta \\gamma^\\star, \\boldsymbol{\\pi})=0$:\n$$\n\\dfrac{\\partial \\Delta \\gamma^\\star}{\\partial \\pi_i} = - \\dfrac{\\partial g / \\partial \\pi_i}{\\partial g / \\partial \\Delta \\gamma} = \\dfrac{\\dfrac{\\partial \\sigma_y}{\\partial \\pi_i}(\\alpha_{n+1}; \\boldsymbol{\\pi})}{2 \\mu + \\sqrt{\\frac{2}{3}} \\, \\dfrac{\\partial \\sigma_y}{\\partial \\alpha}(\\alpha_{n+1}; \\boldsymbol{\\pi})}\n$$\nwhere $\\alpha_{n+1} = \\alpha_n + \\sqrt{2/3}\\Delta\\gamma^\\star$. The partial derivatives $\\partial \\sigma_y / \\partial \\pi_i$ are evaluated at $\\alpha_{n+1}$:\n$$\n\\dfrac{\\partial \\sigma_y}{\\partial \\sigma_0} = 1, \\quad\n\\dfrac{\\partial \\sigma_y}{\\partial a_1} = \\alpha_{n+1}, \\quad\n\\dfrac{\\partial \\sigma_y}{\\partial a_2} = \\tanh(a_3 \\alpha_{n+1}), \\quad\n\\dfrac{\\partial \\sigma_y}{\\partial a_3} = a_2 \\alpha_{n+1} \\, \\mathrm{sech}^2(a_3 \\alpha_{n+1})\n$$\nThe Jacobian of the stress tensor is then:\n$$\n\\dfrac{\\partial \\boldsymbol{\\sigma}_{n+1}}{\\partial \\pi_i} = \\dfrac{\\partial}{\\partial \\pi_i} \\left( \\boldsymbol{\\sigma}^{\\mathrm{tr}} - 2 \\mu \\, \\Delta \\gamma^\\star \\, \\mathbf{n} \\right) = - 2 \\mu \\, \\mathbf{n} \\, \\dfrac{\\partial \\Delta \\gamma^\\star}{\\partial \\pi_i}\n$$\nThe Frobenius norm of this Jacobian tensor is required. Since $\\mathbf{n}$ is a unit tensor with respect to the Frobenius norm ($\\lVert \\mathbf{n} \\rVert_F = 1$), the norm simplifies to:\n$$\n\\left\\lVert \\dfrac{\\partial \\boldsymbol{\\sigma}_{n+1}}{\\partial \\pi_i} \\right\\rVert_F = \\left| -2 \\mu \\, \\dfrac{\\partial \\Delta \\gamma^\\star}{\\partial \\pi_i} \\right| \\lVert \\mathbf{n} \\rVert_F = 2 \\mu \\left| \\dfrac{\\partial \\Delta \\gamma^\\star}{\\partial \\pi_i} \\right|\n$$\nFor an elastic step, all Jacobian norms are $0$.\nThe computations are performed for each of the four test cases, and the results are aggregated into a single list as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a differentiable return-mapping layer for J2 plasticity\n    and computes stress Jacobians with respect to hardening parameters.\n    \"\"\"\n\n    # --- Test Case Definitions ---\n    # Common parameters for all cases\n    E = 210000.0  # MPa\n    nu = 0.3\n    pi_common = np.array([400.0, 1000.0, 50.0, 10.0]) # [sigma0, a1, a2, a3]\n    alpha_n_common = 0.0\n\n    # Strain tensors for each case\n    eps_1 = np.array([[0.0, 0.01, 0.0], [0.01, 0.0, 0.0], [0.0, 0.0, 0.0]])\n    eps_2 = np.array([[0.0, 0.00143, 0.0], [0.00143, 0.0, 0.0], [0.0, 0.0, 0.0]])\n    eps_3 = np.array([[0.001, 0.0, 0.0], [0.0, 0.001, 0.0], [0.0, 0.0, 0.001]])\n    eps_4 = np.zeros((3, 3))\n    \n    test_cases = [\n        {'eps': eps_1, 'pi': pi_common, 'alpha_n': alpha_n_common}, # Case 1\n        {'eps': eps_2, 'pi': pi_common, 'alpha_n': alpha_n_common}, # Case 2\n        {'eps': eps_3, 'pi': pi_common, 'alpha_n': alpha_n_common}, # Case 3\n        {'eps': eps_4, 'pi': pi_common, 'alpha_n': alpha_n_common}, # Case 4\n    ]\n\n    # --- Helper Functions ---\n    def hardening_law(alpha, pi_vec):\n        \"\"\"Computes the yield stress sigma_y.\"\"\"\n        sigma0, a1, a2, a3 = pi_vec\n        return sigma0 + a1 * alpha + a2 * np.tanh(a3 * alpha)\n\n    def hardening_law_deriv_alpha(alpha, pi_vec):\n        \"\"\"Computes d(sigma_y)/d(alpha).\"\"\"\n        _, a1, a2, a3 = pi_vec\n        # sech(x) = 1/cosh(x)\n        sech_val = 1.0 / np.cosh(a3 * alpha)\n        return a1 + a2 * a3 * sech_val**2\n\n    # --- Main Logic ---\n    results = []\n    \n    # Material constants\n    mu = E / (2.0 * (1.0 + nu))\n    lmbda = E * nu / ((1.0 + nu) * (1.0 - 2.0 * nu))\n    k = np.sqrt(2.0 / 3.0)\n    I = np.identity(3)\n\n    for case in test_cases:\n        eps = case['eps']\n        pi_vec = case['pi']\n        alpha_n = case['alpha_n']\n        \n        # 1. Elastic predictor\n        tr_eps = np.trace(eps)\n        sigma_tr = lmbda * tr_eps * I + 2.0 * mu * eps\n        \n        s_tr = sigma_tr - (1.0 / 3.0) * np.trace(sigma_tr) * I\n        s_tr_norm = np.linalg.norm(s_tr, 'fro')\n        \n        # Avoid division by zero if s_tr is zero\n        if s_tr_norm  1e-12:\n            sigma_eq_tr = 0.0\n        else:\n            sigma_eq_tr = np.sqrt(3.0 / 2.0) * s_tr_norm\n\n        # 2. Yield check\n        sigma_y_n = hardening_law(alpha_n, pi_vec)\n        phi_tr = sigma_eq_tr - sigma_y_n\n\n        if phi_tr = 0:\n            # Elastic step\n            is_elastic = True\n            residual = 0.0\n            jac_norms = [0.0, 0.0, 0.0, 0.0]\n        else:\n            # Plastic step\n            is_elastic = False\n\n            # 3. Plastic corrector (Newton's method for delta_gamma)\n            delta_gamma = 0.0 # Initial guess\n            \n            # Residual function and its derivative\n            def g(dg):\n                alpha_eval = alpha_n + k * dg\n                return sigma_eq_tr - 2.0 * mu * dg - hardening_law(alpha_eval, pi_vec)\n            \n            def g_prime(dg):\n                alpha_eval = alpha_n + k * dg\n                return -2.0 * mu - k * hardening_law_deriv_alpha(alpha_eval, pi_vec)\n            \n            for _ in range(10): # Newton iterations\n                dg_update = g(delta_gamma) / g_prime(delta_gamma)\n                delta_gamma -= dg_update\n                if np.abs(g(delta_gamma))  1e-9:\n                    break\n            \n            delta_gamma_star = delta_gamma\n            residual = np.abs(g(delta_gamma_star))\n\n            alpha_star = alpha_n + k * delta_gamma_star\n\n            # 4. Jacobian computation\n            # Denominator for d(delta_gamma)/d(pi)\n            denom = 2.0 * mu + k * hardening_law_deriv_alpha(alpha_star, pi_vec)\n\n            # Numerators for d(sigma_y)/d(pi)\n            d_sigma_y_d_s0 = 1.0\n            d_sigma_y_d_a1 = alpha_star\n            d_sigma_y_d_a2 = np.tanh(pi_vec[3] * alpha_star)\n            sech_val_star = 1.0 / np.cosh(pi_vec[3] * alpha_star)\n            d_sigma_y_d_a3 = pi_vec[2] * alpha_star * sech_val_star**2\n            \n            d_sigma_y_d_pi = np.array([d_sigma_y_d_s0, d_sigma_y_d_a1, d_sigma_y_d_a2, d_sigma_y_d_a3])\n\n            # d(delta_gamma)/d(pi)\n            d_delta_gamma_d_pi = d_sigma_y_d_pi / denom\n\n            # Frobenius norm of d(sigma)/d(pi)\n            jac_norms = 2.0 * mu * np.abs(d_delta_gamma_d_pi)\n        \n        # Append results for this case\n        results.extend([residual, *jac_norms, is_elastic])\n\n    # Final print statement\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}