{
    "hands_on_practices": [
        {
            "introduction": "自适应网格加密（AMR）通过仅在必要区域进行网格细化来优化计算资源。这个练习  提供了一种量化这种成本的具体方法，特别针对一个常见场景：解析尖锐的流体界面。通过这种尺度分析，我们可以更好地预测模拟的性能和内存需求，这对于规划大规模计算至关重要。",
            "id": "4078652",
            "problem": "在一个具有清晰物质界面的复杂流体的$2$维块结构自适应网格加密（Adaptive Mesh Refinement, AMR）模拟中，考虑一条总弧长为$L$的光滑界面曲线，该曲线嵌入在一个区域中。在加密级别$\\ell$下，一个半宽为$w$（在物理空间中测量）的加密带对称地维持在界面周围。AMR使用方形块：在级别$\\ell$下，每个块是边长为$s_{\\ell}$（物理单位）的正方形，它通过$s_{\\ell} = s_{0} \\, r^{-\\ell}$与级别$0$的块边长$s_{0}$相关，其中$r > 1$是加密比（即，每个加密级别将线性尺度减小一个因子$r$）。假设如下：\n- 界面曲线是光滑的，其各处的最小曲率半径远大于$w$，因此界面周围半宽为$w$的管状邻域不会自重叠。\n- 加密带是薄的，即$w \\ll L$，并且在主阶上边界和末端效应可以忽略不计。\n- 块的放置方式使得在估计数量时，重叠和填充效率低下的问题在主阶上可以忽略不计。\n\n从基本的几何测量考量和块面积随加密级别的缩放关系出发，推导覆盖该加密带所需级别$\\ell$的块数量的主阶估计。将您的最终答案表示为关于$L$、$w$、$r$、$\\ell$和$s_{0}$的单个闭式解析表达式。不需要进行数值计算，也不需要四舍五入。最终答案必须是单个表达式。",
            "solution": "问题陈述已经过验证，被认为是科学上合理的、适定的、客观的且内部一致的。它提出了计算方法分析中的一个标准问题，具体涉及应用于界面现象的自适应网格加密（AMR）技术所需计算资源的估计。所有提供的数据和假设对于按要求推导主阶估计是充分且适当的。\n\n任务是推导覆盖物质界面周围指定加密带所需的级别$\\ell$块的数量（表示为$N_{\\ell}$）的主阶估计。该方法将基于基本几何原理，具体来说，通过将被加密区域的总面积与指定加密级别下单个计算块的面积联系起来。\n\n首先，我们定义加密带的面积$A_{band}$。问题陈述，一个半宽为$w$的加密带对称地维持在总弧长为$L$的界面曲线周围。这在曲线周围形成了一个管状邻域。因此，加密带的总宽度为$2w$。问题提供了几个关键的简化假设：界面曲线是光滑的，其最小曲率半径远大于$w$，且$w \\ll L$。这些假设使我们能够通过忽略曲率效应来近似计算带的面积。在主阶近似下，这个薄管状邻域的面积是曲线弧长与带总宽度的乘积。这相当于将曲线“展开”成一条长度为$L$的直线，并计算宽度为$2w$的周围矩形的面积。\n因此，加密带的面积由下式给出：\n$$\nA_{band} = L \\times (2w) = 2Lw\n$$\n\n接下来，我们确定级别$\\ell$下单个计算块的面积，我们将其表示为$A_{block, \\ell}$。问题指明AMR使用方形块。级别$\\ell$下块的边长（表示为$s_{\\ell}$）通过以下缩放定律与级别$0$块的边长$s_{0}$和加密比$r$相关：\n$$\ns_{\\ell} = s_{0} \\, r^{-\\ell}\n$$\n由于块是正方形，单个级别$\\ell$块的面积是其边长的平方：\n$$\nA_{block, \\ell} = s_{\\ell}^2 = (s_{0} \\, r^{-\\ell})^2 = s_{0}^2 \\, r^{-2\\ell}\n$$\n\n最后，我们可以估计覆盖整个加密带所需的级别$\\ell$块的数量$N_{\\ell}$。问题陈述，在主阶上可以忽略重叠和填充效率低下的问题。这个关键的简化意味着，总块数可以通过将带的总面积除以单个块的面积来估计。\n$$\nN_{\\ell} \\approx \\frac{A_{band}}{A_{block, \\ell}}\n$$\n代入我们推导出的$A_{band}$和$A_{block, \\ell}$的表达式：\n$$\nN_{\\ell} = \\frac{2Lw}{s_{0}^2 \\, r^{-2\\ell}}\n$$\n通过简化表达式，我们将分母中带有负指数的项移到分子：\n$$\nN_{\\ell} = 2Lw s_{0}^{-2} r^{2\\ell}\n$$\n这可以更清晰地写成分数形式：\n$$\nN_{\\ell} = \\frac{2Lw r^{2\\ell}}{s_{0}^2}\n$$\n该表达式提供了级别$\\ell$块数量的主阶估计。正如问题陈述所要求的，它是一个关于给定参数$L$、$w$、$r$、$\\ell$和$s_{0}$的闭式解析表达式。",
            "answer": "$$\n\\boxed{\\frac{2Lw r^{2\\ell}}{s_{0}^2}}\n$$"
        },
        {
            "introduction": "在 AMR 中，一个核心挑战是在不同分辨率的网格层级之间维持基本的物理定律，例如质量或能量守恒。这个练习  聚焦于“通量重构”（refluxing）技术，这是守恒型有限体积 AMR 方案的基石。它演示了如何协调粗细网格之间的通量，以防止在界面处产生非物理的人为源或汇，从而保证全局的守恒性。",
            "id": "4078654",
            "problem": "考虑在二维有限体积离散化中，一个具有恒定密度的被动标量的对流扩散。设计算网格采用自适应网格加密（AMR），空间和时间上的加密比均为 $r=2$。一个粗糙控制体的东面与一个加密区域的西边界重合，该加密区域由垂直方向堆叠的 $2$ 个精细单元组成。粗糙时间步为 $\\Delta t_{\\mathrm{c}}$，精细层级以两个大小为 $\\Delta t_{\\mathrm{f}}=\\Delta t_{\\mathrm{c}}/2$ 的子步推进。\n\n在任何控制体中，标量量在一个时间步内的有限体积更新由守恒的积分形式给出：变化量等于通过控制体边界的时间积分净向外通量的负值，加上任何时间积分的源项。本题中没有源项。在粗糙-精细界面处，守恒要求粗糙面在 $\\Delta t_{\\mathrm{c}}$ 内的时间积分通量，等于分割后的精细面在两个精细子步内的时间积分通量之和。\n\n对于粗糙单元的东面，定义正方向为从粗糙单元进入加密区域。在第一个精细子步（$k=1$）期间，从粗糙单元进入下方精细面的时间积分通量为 $\\Phi_{1}^{(1)}=0.030$ mol，进入上方精细面的时间积分通量为 $\\Phi_{2}^{(1)}=0.028$ mol。在第二个精细子步（$k=2$）期间，相应的时间积分通量为 $\\Phi_{1}^{(2)}=0.031$ mol 和 $\\Phi_{2}^{(2)}=0.029$ mol。粗糙求解器对粗糙东面在 $\\Delta t_{\\mathrm{c}}$ 内的时间积分通量的预测值为 $\\Phi_{\\mathrm{E}}^{\\mathrm{pred}}=0.110$ mol。\n\n从积分守恒定律和通量在不相交时空划分上的可加性出发，确定唯一的修正后粗糙东面时间积分通量 $\\Phi_{\\mathrm{E}}^{\\mathrm{corr}}$（在 $\\Delta t_{\\mathrm{c}}$ 内），该通量能强制实现跨粗糙-精细界面的守恒。然后，使用相同的守恒原理，解释为什么用 $\\Phi_{\\mathrm{E}}^{\\mathrm{corr}}$ 替换 $\\Phi_{\\mathrm{E}}^{\\mathrm{pred}}$ 可以消除该界面上任何人为的增益或损失。\n\n以 mol 为单位表示 $\\Phi_{\\mathrm{E}}^{\\mathrm{corr}}$ 的最终值。不要对答案进行四舍五入。",
            "solution": "该问题是有效的。这是一个在计算流体动力学领域中设定良好、具有科学依据的问题，特别涉及在自适应网格加密（AMR）中强制执行守恒定律。所有必要的数据都已提供，并且术语是该领域的标准术语。\n\n在一个时间间隔 $[t_1, t_2]$ 内，控制体 $V$ 中守恒标量 $\\psi$ 更新的基本原理是守恒定律的积分形式。在没有源项或汇项的情况下，该定律指出，体积内标量的总量的变化等于通过其边界 $\\partial V$流入体积的标量净量。数学上表示为：\n$$ \\int_V \\psi(t_2) dV - \\int_V \\psi(t_1) dV = - \\int_{t_1}^{t_2} \\oint_{\\partial V} (\\mathbf{F} \\cdot \\mathbf{n}) dA dt $$\n其中 $\\mathbf{F}$ 是标量 $\\psi$ 的通量矢量，$\\mathbf{n}$ 是边界表面元素 $dA$ 上指向外部的单位法向量。右侧表示时间积分净向外通量的负值。\n\n在有限体积法中，此原理应用于离散的控制体（单元）。对于 AMR，确保跨越不同网格分辨率界面的守恒至关重要。问题描述了这样一个界面，其中一个粗糙单元的东面与一个精细单元区域相邻。粗糙面在空间上被划分为 $2$ 个精细单元面，粗糙时间步 $\\Delta t_{\\mathrm{c}}$ 在时间上被划分为 $2$ 个精细单元时间步 $\\Delta t_{\\mathrm{f}}$。\n\n令 $\\Phi_{\\mathrm{E,c}}$ 表示在粗糙时间步 $\\Delta t_{\\mathrm{c}}$ 内通过粗糙东面的总时间积分通量。令 $\\Phi_{j}^{(k)}$ 为在第 $k$ 个精细时间子步（其中 $k \\in \\{1, 2\\}$）期间通过第 $j$ 个精细面分段（其中 $j \\in \\{1, 2\\}$ 分别代表下部和上部分段）的时间积分通量。守恒的核心要求是，通过粗糙面的标量总量必须等于在所有子时间步内通过其组成的精细面部分的总量。通量在不相交的时空表面划分上是可加的。因此，我们可以写出：\n$$ \\Phi_{\\mathrm{E,c}} = \\sum_{k=1}^{2} \\sum_{j=1}^{2} \\Phi_{j}^{(k)} $$\n修正后的粗糙东面通量 $\\Phi_{\\mathrm{E}}^{\\mathrm{corr}}$ 正是这个为强制守恒所需的量。由精细网格求解器计算出的值被视为跨界面的通量的确定性度量。\n\n问题给出了精细面时间积分通量的值：\n- 在第一个精细子步 ($k=1$) 期间：$\\Phi_{1}^{(1)} = 0.030$ mol 和 $\\Phi_{2}^{(1)} = 0.028$ mol。\n- 在第二个精细子步 ($k=2$) 期间：$\\Phi_{1}^{(2)} = 0.031$ mol 和 $\\Phi_{2}^{(2)} = 0.029$ mol。\n\n使用守恒原理，我们将这些通量相加，以找到修正后的粗糙面通量：\n$$ \\Phi_{\\mathrm{E}}^{\\mathrm{corr}} = \\Phi_{1}^{(1)} + \\Phi_{2}^{(1)} + \\Phi_{1}^{(2)} + \\Phi_{2}^{(2)} $$\n代入给定值：\n$$ \\Phi_{\\mathrm{E}}^{\\mathrm{corr}} = 0.030 + 0.028 + 0.031 + 0.029 $$\n$$ \\Phi_{\\mathrm{E}}^{\\mathrm{corr}} = (0.030 + 0.028) + (0.031 + 0.029) $$\n$$ \\Phi_{\\mathrm{E}}^{\\mathrm{corr}} = 0.058 + 0.060 $$\n$$ \\Phi_{\\mathrm{E}}^{\\mathrm{corr}} = 0.118 \\text{ mol} $$\n\n现在，我们解释为什么这个修正能强制守恒。在一个典型的 AMR 预测-校正算法中，粗糙和精细网格是独立推进的。粗糙求解器使用一个预测通量 $\\Phi_{\\mathrm{E}}^{\\mathrm{pred}} = 0.110$ mol 来更新与界面相邻的粗糙单元。根据这个预测值，量值为 $0.110$ mol 的标量通过其东面离开粗糙单元。\n同时，精细网格求解器计算通过其西边界进入精细区域的通量。进入精细区域的总量是我们计算出的总和，即 $\\sum_{k,j} \\Phi_{j}^{(k)} = 0.118$ mol。\n这里存在一个差异：离开粗糙单元的量（$0.110$ mol）不等于进入精细单元的量（$0.118$ mol）。这个不匹配量 $\\delta \\Phi = 0.118 - 0.110 = 0.008$ mol，代表了在界面上的人为产生（净增益）的标量，违反了全局守恒定律。\n\n为修正此问题，粗糙网格的解被校正。粗糙单元守恒方程中使用的通量 $\\Phi_{\\mathrm{E}}$ 被修正后的通量 $\\Phi_{\\mathrm{E}}^{\\mathrm{corr}}$ 替换，该修正通量被定义为等于精细网格通量之和。\n所以，我们将离开粗糙单元的通量设为 $\\Phi_{\\mathrm{E}}^{\\mathrm{corr}} = 0.118$ mol。\n进入精细单元的通量是 $\\sum_{k,j} \\Phi_{j}^{(k)} = 0.118$ mol。\n通过使用 $\\Phi_{\\mathrm{E}}^{\\mathrm{corr}}$，通过其东面离开粗糙控制体的标量量与通过其西面进入相邻精细控制体的标量量完全相等。因此，跨界面的总标量净变化为零：\n$$ \\Delta Q_{\\text{total, interface}} = (\\text{flux into fine cells}) - (\\text{flux out of coarse cell}) = \\left(\\sum_{k,j} \\Phi_{j}^{(k)}\\right) - \\Phi_{\\mathrm{E}}^{\\mathrm{corr}} = 0.118 - 0.118 = 0 $$\n这个过程，通常被称为“通量重配”（refluxing），确保在粗糙-精细界面处不会引入人为的源或汇，并且该方案保持完全守恒。",
            "answer": "$$\n\\boxed{0.118}\n$$"
        },
        {
            "introduction": "从独立的组件到完整、动态的 AMR 引擎，这个练习  综合了后验误差估计和网格自适应的核心逻辑。通过这个实践，你将实现一个完整的自适应循环，包括误差计算、基于高级准则（Dörfler 标记）标记待加密或粗化的单元，以及执行网格修改。这将提供对自适应模拟如何动态演化的整体理解。",
            "id": "4078680",
            "problem": "考虑一个用于一维耦合系统的自适应网格加密 (AMR) 循环，该系统代表了计算复杂流体中的界面层和边界层。空间域为 $[0,1]$，耦合场由无量纲相场变量 $\\phi(x)$ 和无量纲速度 $u(x)$ 定义，它们分别被选择用于捕捉位于中心附近的界面和靠近左边界的边界层。函数为\n$$\n\\phi(x) = \\tanh\\left(\\frac{x - x_0}{\\sqrt{2}\\,\\epsilon}\\right), \\quad u(x) = 1 - \\exp\\left(-\\frac{x}{\\delta}\\right),\n$$\n其中 $x_0 = 0.5$ 是界面位置，$\\epsilon > 0$ 是界面厚度参数，$\\delta > 0$ 是边界层厚度参数。网格由 $[0,1]$ 的一个剖分组成，该剖分包含长度为 $h_i$ 的单元（闭区间）。\n\n从一个基本定义出发，即对于扩散主导过程，基于残差的能量范数估计器将空间二阶导数的贡献作为 $H^1$ 型范数中曲率驱动误差的代理进行聚合。基于此，我们使用以下建模选择作为局部误差指标。对于中点为 $x_i$、尺寸为 $h_i$ 的单元 $i$，定义\n$$\n\\eta_{\\phi,i}^2 = \\alpha \\, h_i^2 \\, \\left|\\phi''(x_i)\\right|^2, \\quad \\eta_{u,i}^2 = \\beta \\, h_i^2 \\, \\left|u''(x_i)\\right|^2,\n$$\n以及组合的局部指标\n$$\n\\eta_i = \\sqrt{\\eta_{\\phi,i}^2 + \\eta_{u,i}^2}.\n$$\n取 $\\alpha = 1$ 和 $\\beta = 1$。\n\n定义全局能量估计器范数\n$$\n\\mathcal{E} = \\left(\\sum_{i} \\eta_i^2\\right)^{1/2}.\n$$\n\nAMR 循环按如下方式进行，仅在网格上使用确定性的局部操作：\n- 使用上述公式计算所有单元的 $\\eta_i$。\n- 使用参数为 $\\theta \\in (0,1)$ 的 Dörfler 标记法标记要加密的单元：将 $\\eta_i^2$ 按降序排序，并选择一个最小子集 $\\mathcal{M}_\\mathrm{ref}$，使得\n$$\n\\sum_{i \\in \\mathcal{M}_\\mathrm{ref}} \\eta_i^2 \\ge \\theta \\sum_j \\eta_j^2.\n$$\n- 使用阈值 $\\kappa \\in (0,1)$ 标记要粗化的单元：定义算术平均值 $\\overline{\\eta} = \\frac{1}{N}\\sum_i \\eta_i$，如果 $\\eta_i  \\kappa \\, \\overline{\\eta}$ 且单元的加密等级大于 $0$，则标记单元 $i$ 进行粗化。\n- 通过将 $\\mathcal{M}_\\mathrm{ref}$ 中的所有单元二等分为两个等长的单元来进行加密。\n- 通过合并共享相同加密等级的连续被标记单元对来进行粗化；合并操作将这对单元替换为跨越这两个区间并集的、加密等级减一的单个单元。\n- 通过施加比率约束 $r  1$ 来重新平衡网格，以维持相邻单元尺寸的规整性：如果两个相邻单元的尺寸 $h_\\mathrm{large}$ 和 $h_\\mathrm{small}$ 满足 $h_\\mathrm{large}/h_\\mathrm{small}  r$，则二等分较大的单元。在相邻单元上迭代应用此重新平衡过程，直到整个网格满足该约束或不再发生变化。\n\n当全局能量估计器范数 $\\mathcal{E}$ 小于或等于目标容差 $\\mathrm{tol}  0$ 时，或达到最大迭代次数 $\\mathrm{max\\_iters}$ 时，终止循环。对于每个测试用例，程序必须输出达到 $\\mathcal{E} \\le \\mathrm{tol}$ 所需的 AMR 迭代次数（整数），如果在迭代限制内未满足容差，则输出整数 $-1$。\n\n所有量均为无量纲。\n\n测试套件：\n提供以下参数集，其中每个测试用例是一个元组 $(\\epsilon,\\delta,\\theta,\\kappa,r,N_0,\\mathrm{tol},\\mathrm{max\\_iters})$，初始网格在 $[0,1]$ 上有 $N_0$ 个均匀单元。\n- 情况 A（具有中等边界层的一般耦合尖锐界面）：$(\\epsilon,\\delta,\\theta,\\kappa,r,N_0,\\mathrm{tol},\\mathrm{max\\_iters}) = (0.02, 0.05, 0.5, 0.3, 3.0, 16, 0.01, 20)$。\n- 情况 B（非常尖锐的界面）：$(\\epsilon,\\delta,\\theta,\\kappa,r,N_0,\\mathrm{tol},\\mathrm{max\\_iters}) = (0.005, 0.05, 0.4, 0.25, 4.0, 8, 0.005, 50)$。\n- 情况 C（弥散界面和边界层）：$(\\epsilon,\\delta,\\theta,\\kappa,r,N_0,\\mathrm{tol},\\mathrm{max\\_iters}) = (0.05, 0.2, 0.6, 0.5, 2.5, 12, 0.02, 15)$。\n- 情况 D（严格容差限制情况）：$(\\epsilon,\\delta,\\theta,\\kappa,r,N_0,\\mathrm{tol},\\mathrm{max\\_iters}) = (0.01, 0.01, 0.7, 0.2, 3.0, 6, 0.001, 10)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result1,result2,result3,result4]$），其顺序与上述测试套件相同。每个 $result$ 必须是指定的整数。",
            "solution": "该问题要求实现一个针对一维耦合系统的自适应网格加密 (AMR) 模拟。其求解方法涉及创建一个确定性算法，该算法基于后验误差指标迭代地调整网格，直到达到全局误差容差或耗尽最大迭代次数。\n\n该解决方案通过以下步骤构建：\n1.  推导给定场的二阶导数的解析表达式，这些表达式是误差指标的基础。\n2.  建立一个表示计算网格的数据结构。\n3.  详细说明 AMR 循环，包括误差估计、标记、网格自适应（加密/粗化）和重新平衡。\n\n**1. 解析误差指标函数**\n\n误差指标基于相场变量 $\\phi(x)$ 和速度场 $u(x)$ 的空间二阶导数。\n\n对于相场变量 $\\phi(x) = \\tanh\\left(\\frac{x - x_0}{\\sqrt{2}\\,\\epsilon}\\right)$，令 $z(x) = \\frac{x - x_0}{\\sqrt{2}\\,\\epsilon}$。使用链式法则求其关于 $x$ 的一阶导数：\n$$\n\\phi'(x) = \\frac{d}{dx}\\tanh(z) = \\text{sech}^2(z) \\cdot \\frac{dz}{dx} = \\frac{1}{\\sqrt{2}\\,\\epsilon} \\text{sech}^2\\left(\\frac{x - x_0}{\\sqrt{2}\\,\\epsilon}\\right)\n$$\n通过再次对 $\\phi'(x)$ 求导得到二阶导数：\n$$\n\\phi''(x) = \\frac{1}{\\sqrt{2}\\,\\epsilon} \\cdot \\frac{d}{dx}\\text{sech}^2(z) = \\frac{1}{\\sqrt{2}\\,\\epsilon} \\left[ -2 \\text{sech}(z)\\tanh(z)\\text{sech}(z) \\cdot \\frac{dz}{dx} \\right] \\\\\n= \\frac{1}{\\sqrt{2}\\,\\epsilon} \\left[ -2 \\text{sech}^2(z)\\tanh(z) \\cdot \\frac{1}{\\sqrt{2}\\,\\epsilon} \\right] \\\\\n= -\\frac{1}{\\epsilon^2} \\text{sech}^2\\left(\\frac{x - x_0}{\\sqrt{2}\\,\\epsilon}\\right) \\tanh\\left(\\frac{x - x_0}{\\sqrt{2}\\,\\epsilon}\\right)\n$$\n\n对于速度场 $u(x) = 1 - \\exp\\left(-\\frac{x}{\\delta}\\right)$，其导数更直接：\n一阶导数为：\n$$\nu'(x) = -\\left(-\\frac{1}{\\delta}\\right)\\exp\\left(-\\frac{x}{\\delta}\\right) = \\frac{1}{\\delta}\\exp\\left(-\\frac{x}{\\delta}\\right)\n$$\n二阶导数为：\n$$\nu''(x) = \\frac{1}{\\delta}\\left(-\\frac{1}{\\delta}\\right)\\exp\\left(-\\frac{x}{\\delta}\\right) = -\\frac{1}{\\delta^2}\\exp\\left(-\\frac{x}{\\delta}\\right)\n$$\n\n这些 $\\phi''(x)$ 和 $u''(x)$ 的解析表达式在每个网格单元 $i$ 的中点 $x_i$ 处被求值，以计算局部误差指标。\n\n**2. 网格数据结构**\n\n一维网格是域 $[0,1]$ 的一个剖分，表示为一个按空间坐标排序的单元列表。每个单元都是一个数据结构，存储三个关键属性：其起始坐标、结束坐标和加密等级。由 $N_0$ 个均匀单元组成的初始网格被定义为等级 $0$。当一个单元被二等分（加密）时，其两个子单元的等级被指定为比其父单元高一级。当两个单元被合并（粗化）时，得到的单个单元的等级被指定为比其父单元低一级。\n\n**3. AMR 算法**\n\nAMR 过程以循环方式执行，每一遍构成一次迭代。设迭代计数器为 $k$，从 $k=0$ 和初始网格开始。该循环最多执行 $\\mathrm{max\\_iters}$ 次迭代。\n\n**3.1. 初始状态 ($k = 0$)**\n算法首先生成一个初始均匀网格，该网格由 $N_0$ 个单元组成，每个单元的尺寸为 $h = 1/N_0$，加密等级为 $0$。\n\n**3.2. 迭代循环 ($k = 0, 1, \\dots, \\mathrm{max\\_iters}$)**\n在每次迭代中，执行以下操作序列。\n\n**步骤 A：误差估计与终止检查**\n对于当前网格，评估其误差。对于每个尺寸为 $h_i$、中点为 $x_i$ 的单元 $i$：\n使用指定的权重因子 $\\alpha=1$ 和 $\\beta=1$ 计算局部误差指标的平方：\n$$\n\\eta_{\\phi,i}^2 = h_i^2 \\, \\left|\\phi''(x_i)\\right|^2, \\quad \\eta_{u,i}^2 = h_i^2 \\, \\left|u''(x_i)\\right|^2\n$$\n组合的局部指标平方为 $\\eta_i^2 = \\eta_{\\phi,i}^2 + \\eta_{u,i}^2$。\n全局能量估计器范数是这些指标平方之和的平方根：\n$$\n\\mathcal{E} = \\left(\\sum_{i} \\eta_i^2\\right)^{1/2}\n$$\n算法首先检查终止条件。如果 $\\mathcal{E} \\le \\mathrm{tol}$，则解已收敛，并返回已执行的迭代次数 $k$。如果 $k$ 已达到 $\\mathrm{max\\_iters}$ 但仍未满足容差，则循环终止，并返回一个失败代码。\n\n**步骤 B：单元标记**\n如果未满足终止条件，则标记单元以进行自适应调整：\n- **加密标记 (Dörfler 策略)**：标记一个最小单元集 $\\mathcal{M}_\\mathrm{ref}$ 进行加密。这是通过将单元按其指标平方 $\\eta_i^2$ 降序排序，并从列表顶部开始选择单元，直到它们的累积贡献至少达到总误差平方 $\\sum_j \\eta_j^2$ 的比例 $\\theta$。\n$$ \\sum_{i \\in \\mathcal{M}_\\mathrm{ref}} \\eta_i^2 \\ge \\theta \\sum_j \\eta_j^2 $$\n- **粗化标记**：如果一个单元 $i$ 的误差指标 $\\eta_i$ 相对于所有指标的算术平均值 $\\overline{\\eta} = \\frac{1}{N}\\sum_j \\eta_j$ 较小，则标记该单元进行粗化。精确条件是 $\\eta_i  \\kappa \\, \\overline{\\eta}$，并附加约束条件：单元的加密等级必须大于 $0$，因为基础网格（等级 $0$）不能被进一步粗化。\n\n**步骤 C：网格自适应（加密与粗化）**\n根据标记从旧网格构建新网格。对排序后的单元进行一次从左到右的遍历可确保确定性的结果：\n1.  对于每个潜在的连续单元对 $(i, i+1)$，检查它们是否都被标记为粗化并且处于相同的加密等级。如果是，则将它们合并成一个新单元，该单元跨越它们的组合区间，加密等级减一。\n2.  如果一个单元 $i$ 不属于被粗化的单元对，则检查它是否存在于被标记为加密的单元集 $\\mathcal{M}_\\mathrm{ref}$ 中。如果存在，则将该单元二等分为两个等尺寸的新子单元。它们的加密等级加一。\n3.  既不粗化也不加密的单元将被不加修改地复制到新网格中。\n这种单遍策略使得对于任何给定单元，粗化优先于加密，因为对单元对的粗化检查在对单个单元的加密检查之前执行。\n\n**步骤 D：网格重新平衡**\n在主要的自适应步骤之后，对网格进行重新平衡，以强制施加关于相邻单元尺寸的几何约束。这是一个迭代过程：\n1.  启动一个循环，只要在一次遍历中发生了重新平衡操作，该循环就继续进行。\n2.  在每次遍历中，检查所有相邻的单元对。如果它们的尺寸之比 $h_\\mathrm{large}/h_\\mathrm{small}$ 超过参数 $r$，则将较大的单元标记为二等分。\n3.  如果在遍历期间有任何单元被标记，则构建一个新网格，其中所有被标记的单元都被二等分。这个新网格成为重新平衡循环下一次遍历的输入。\n4.  如果一次完整遍历完成且没有单元被标记为加密，则认为网格已重新平衡，重新平衡循环终止。\n\n**3.3. 最终结果**\n重新平衡步骤之后，当前的 AMR 迭代 $k$ 完成。算法进入下一次迭代 $k+1$。如果循环执行到 $k = \\mathrm{max\\_iters}$ 且最终的误差检查失败，则结果为 $-1$，表示未能收敛。",
            "answer": "```python\nimport numpy as np\nfrom collections import namedtuple\n\n# Define an element data structure for the mesh\nElement = namedtuple('Element', ['start', 'end', 'level'])\n\n# Analytical second derivatives\ndef phi_double_prime(x, x0, epsilon):\n    \"\"\"Computes the second derivative of the phi(x) field.\"\"\"\n    z = (x - x0) / (np.sqrt(2) * epsilon)\n    # Use np.tanh and np.cosh for numerical stability and vectorization\n    tanh_z = np.tanh(z)\n    cosh_z = np.cosh(z)\n    # sech^2(z) = 1/cosh^2(z)\n    sech_z_sq = 1.0 / (cosh_z**2)\n    return -(1.0 / epsilon**2) * sech_z_sq * tanh_z\n\ndef u_double_prime(x, delta):\n    \"\"\"Computes the second derivative of the u(x) field.\"\"\"\n    return -(1.0 / delta**2) * np.exp(-x / delta)\n\ndef run_amr_case(epsilon, delta, theta, kappa, r, N0, tol, max_iters):\n    \"\"\"\n    Executes the full AMR loop for a single test case.\n    \"\"\"\n    # 1. Initialization\n    x_bounds = np.linspace(0.0, 1.0, N0 + 1)\n    mesh = [Element(start=x_bounds[i], end=x_bounds[i+1], level=0) for i in range(N0)]\n    x0 = 0.5\n    alpha = 1.0\n    beta = 1.0\n\n    # 2. Iteration Loop\n    for k in range(max_iters + 1):\n        # Step A: Error Estimation and Termination Check\n        num_elements = len(mesh)\n        indicators = np.zeros(num_elements)\n        squared_indicators = np.zeros(num_elements)\n\n        for i, elem in enumerate(mesh):\n            h_i = elem.end - elem.start\n            x_i = (elem.start + elem.end) / 2.0\n            \n            p_dd = phi_double_prime(x_i, x0, epsilon)\n            u_dd = u_double_prime(x_i, delta)\n            \n            eta_phi_sq = alpha * h_i**2 * p_dd**2\n            eta_u_sq = beta * h_i**2 * u_dd**2\n            \n            eta_i_sq = eta_phi_sq + eta_u_sq\n            squared_indicators[i] = eta_i_sq\n            indicators[i] = np.sqrt(eta_i_sq)\n\n        global_error_sq = np.sum(squared_indicators)\n        global_error = np.sqrt(global_error_sq)\n\n        if global_error = tol:\n            return k\n\n        if k == max_iters:\n            break\n\n        # Step B: Element Marking\n        # Refinement (Dörfler marking)\n        ref_marked_indices = set()\n        target_error_sum_sq = theta * global_error_sq\n        sorted_indices = np.argsort(squared_indicators)[::-1]\n        \n        current_sum_sq = 0.0\n        for idx in sorted_indices:\n            current_sum_sq += squared_indicators[idx]\n            ref_marked_indices.add(idx)\n            if current_sum_sq >= target_error_sum_sq:\n                break\n\n        # Coarsening\n        coarsen_marked_indices = set()\n        if num_elements > 0:\n            mean_eta = np.mean(indicators)\n            coarsen_threshold = kappa * mean_eta\n            for i, eta_i in enumerate(indicators):\n                if eta_i  coarsen_threshold and mesh[i].level > 0:\n                    coarsen_marked_indices.add(i)\n\n        # Step C: Mesh Adaptation (Refine and Coarsen)\n        new_mesh = []\n        i = 0\n        while i  num_elements:\n            can_coarsen_pair = False\n            if i  num_elements - 1:\n                elem1 = mesh[i]\n                elem2 = mesh[i+1]\n                if i in coarsen_marked_indices and (i+1) in coarsen_marked_indices and elem1.level == elem2.level:\n                    can_coarsen_pair = True\n\n            if can_coarsen_pair:\n                elem1, elem2 = mesh[i], mesh[i+1]\n                new_mesh.append(Element(start=elem1.start, end=elem2.end, level=elem1.level - 1))\n                i += 2\n            elif i in ref_marked_indices:\n                elem = mesh[i]\n                mid = (elem.start + elem.end) / 2.0\n                new_mesh.append(Element(start=elem.start, end=mid, level=elem.level + 1))\n                new_mesh.append(Element(start=mid, end=elem.end, level=elem.level + 1))\n                i += 1\n            else:\n                new_mesh.append(mesh[i])\n                i += 1\n        mesh = new_mesh\n\n        # Step D: Mesh Rebalancing\n        while True:\n            rebalance_refine_indices = set()\n            for i in range(len(mesh) - 1):\n                h1 = mesh[i].end - mesh[i].start\n                h2 = mesh[i+1].end - mesh[i+1].start\n                if h2 > 1e-12 and h1 / h2 > r:\n                    rebalance_refine_indices.add(i)\n                if h1 > 1e-12 and h2 / h1 > r:\n                    rebalance_refine_indices.add(i+1)\n            \n            if not rebalance_refine_indices:\n                break\n                \n            rebalanced_mesh = []\n            for i, elem in enumerate(mesh):\n                if i in rebalance_refine_indices:\n                    mid = (elem.start + elem.end) / 2.0\n                    rebalanced_mesh.append(Element(start=elem.start, end=mid, level=elem.level + 1))\n                    rebalanced_mesh.append(Element(start=mid, end=elem.end, level=elem.level + 1))\n                else:\n                    rebalanced_mesh.append(elem)\n            mesh = rebalanced_mesh\n\n    return -1\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (epsilon, delta, theta, kappa, r, N0, tol, max_iters)\n        (0.02, 0.05, 0.5, 0.3, 3.0, 16, 0.01, 20),      # Case A\n        (0.005, 0.05, 0.4, 0.25, 4.0, 8, 0.005, 50),     # Case B\n        (0.05, 0.2, 0.6, 0.5, 2.5, 12, 0.02, 15),      # Case C\n        (0.01, 0.01, 0.7, 0.2, 3.0, 6, 0.001, 10),      # Case D\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_amr_case(*params)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}