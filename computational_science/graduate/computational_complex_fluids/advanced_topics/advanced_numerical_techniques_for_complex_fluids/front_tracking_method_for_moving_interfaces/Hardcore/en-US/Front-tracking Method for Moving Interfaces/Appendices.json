{
    "hands_on_practices": [
        {
            "introduction": "The front-tracking method's power lies in its hybrid Lagrangian-Eulerian description, where a critical element is the communication between the sharp, tracked interface and the fixed underlying grid. This exercise provides hands-on practice with the core mechanism of this communication: spreading the singular surface tension force from a Lagrangian interface element onto the surrounding Eulerian grid nodes using a discrete delta function . Mastering this calculation is fundamental to understanding how the physical forces acting on the interface are incorporated into the fluid momentum equations.",
            "id": "4088769",
            "problem": "Consider a single triangular interface element in a three-dimensional front-tracking discretization of a two-phase flow. The interface is represented by Lagrangian elements that exert a surface tension force density distributed to an underlying Eulerian grid using a regularized discrete delta function. The surface tension force per unit area on the interface is given by $\\sigma \\kappa \\mathbf{n}$, where $\\sigma$ is the surface tension coefficient, $\\kappa$ is the mean curvature, and $\\mathbf{n}$ is the unit normal. In the front-tracking method, the Eulerian force density at a grid node located at position $\\mathbf{x}_i$ due to a single element with centroid at position $\\mathbf{x}_e$ and area $A_e$ is modeled by\n$$\n\\mathbf{f}(\\mathbf{x}_i) \\approx \\sigma \\kappa \\mathbf{n} \\, A_e \\, \\delta_h(\\mathbf{x}_i - \\mathbf{x}_e).\n$$\nAssume a uniform Cartesian grid with spacing $h$, and use the standard separable regularized discrete delta function popularized in the Immersed Boundary (IB) method,\n$$\n\\delta_h(\\mathbf{r}) = \\frac{1}{h^3} \\, \\phi\\!\\left(\\frac{r_x}{h}\\right) \\, \\phi\\!\\left(\\frac{r_y}{h}\\right) \\, \\phi\\!\\left(\\frac{r_z}{h}\\right),\n$$\nwhere $\\mathbf{r} = (r_x,r_y,r_z)$ and $\\phi$ is the four-point one-dimensional kernel defined by\n$$\n\\phi(r) =\n\\begin{cases}\n\\frac{1}{8}\\left(3 - 2|r| + \\sqrt{1 + 4|r| - 4 r^2}\\right), & |r| \\leq 1, \\\\\n\\frac{1}{8}\\left(5 - 2|r| - \\sqrt{-7 + 12|r| - 4 r^2}\\right), & 1 < |r| \\leq 2, \\\\\n0, & |r| > 2.\n\\end{cases}\n$$\nYou are given:\n- Surface tension coefficient $\\sigma = 0.072$ $\\mathrm{N\\,m^{-1}}$,\n- Mean curvature $\\kappa = 4.0 \\times 10^{3}$ $\\mathrm{m^{-1}}$,\n- Interface unit normal $\\mathbf{n} = \\frac{1}{\\sqrt{3}}(1,1,1)$,\n- Triangular element area $A_e = 2.5 \\times 10^{-8}$ $\\mathrm{m^2}$,\n- Grid spacing $h = 1.0 \\times 10^{-3}$ $\\mathrm{m}$,\n- Element centroid $\\mathbf{x}_e = (1.5 \\times 10^{-3},\\, 2.25 \\times 10^{-3},\\, 0.75 \\times 10^{-3})$ $\\mathrm{m}$,\n- Target grid node position $\\mathbf{x}_i = (2.0 \\times 10^{-3},\\, 2.0 \\times 10^{-3},\\, 1.0 \\times 10^{-3})$ $\\mathrm{m}$.\n\nUsing the centroid quadrature approximation and the discrete delta function $\\delta_h$ above, compute the magnitude of the discrete surface tension force density $\\|\\mathbf{f}(\\mathbf{x}_i)\\|$ at the specified grid node. Round your final numerical answer to four significant figures. Express your final answer in $\\mathrm{N\\,m^{-3}}$. Also, verify dimensional consistency of $\\mathbf{f}$ from first principles starting with the given physical definitions and the form of $\\delta_h$.",
            "solution": "The problem requires the calculation of the magnitude of a discrete surface tension force density at a specific grid node in a front-tracking simulation. It also asks for a verification of dimensional consistency.\n\n### Step 1: Extract Givens\n- The Eulerian force density at grid node $\\mathbf{x}_i$: $\\mathbf{f}(\\mathbf{x}_i) \\approx \\sigma \\kappa \\mathbf{n} \\, A_e \\, \\delta_h(\\mathbf{x}_i - \\mathbf{x}_e)$\n- Surface tension coefficient: $\\sigma = 0.072 \\, \\mathrm{N\\,m^{-1}}$\n- Mean curvature: $\\kappa = 4.0 \\times 10^{3} \\, \\mathrm{m^{-1}}$\n- Interface unit normal: $\\mathbf{n} = \\frac{1}{\\sqrt{3}}(1,1,1)$\n- Triangular element area: $A_e = 2.5 \\times 10^{-8} \\, \\mathrm{m^2}$\n- Grid spacing: $h = 1.0 \\times 10^{-3} \\, \\mathrm{m}$\n- Element centroid position: $\\mathbf{x}_e = (1.5 \\times 10^{-3},\\, 2.25 \\times 10^{-3},\\, 0.75 \\times 10^{-3}) \\, \\mathrm{m}$\n- Target grid node position: $\\mathbf{x}_i = (2.0 \\times 10^{-3},\\, 2.0 \\times 10^{-3},\\, 1.0 \\times 10^{-3}) \\, \\mathrm{m}$\n- Regularized discrete delta function: $\\delta_h(\\mathbf{r}) = \\frac{1}{h^3} \\, \\phi\\!\\left(\\frac{r_x}{h}\\right) \\, \\phi\\!\\left(\\frac{r_y}{h}\\right) \\, \\phi\\!\\left(\\frac{r_z}{h}\\right)$\n- One-dimensional kernel: $\\phi(r) =\n\\begin{cases}\n\\frac{1}{8}\\left(3 - 2|r| + \\sqrt{1 + 4|r| - 4 r^2}\\right), & |r| \\leq 1, \\\\\n\\frac{1}{8}\\left(5 - 2|r| - \\sqrt{-7 + 12|r| - 4 r^2}\\right), & 1 < |r| \\leq 2, \\\\\n0, & |r| > 2.\n\\end{cases}$\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, well-posed, and objective.\n- **Scientifically Grounded:** The formulation is a standard representation of surface tension forces in the context of the front-tracking and immersed boundary methods, which are widely used in computational fluid dynamics for multiphase flows. The equations for the force density and the discrete delta function are taken directly from established literature (e.g., Peskin, 2002).\n- **Well-Posed:** All necessary parameters and functional forms are provided. The problem asks for a specific numerical calculation based on these inputs, which leads to a unique solution.\n- **Objective:** The problem statement is quantitative and free of subjective or ambiguous language.\n\nThe problem does not exhibit any of the flaws listed in the validation criteria. The data provided are self-consistent and realistic for a microfluidic simulation.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete solution will be provided.\n\n### Dimensional Consistency Verification\nThe problem requests verification of the dimensional consistency of the force density $\\mathbf{f}(\\mathbf{x}_i)$. Let $[X]$ denote the dimensions of a quantity $X$ in terms of mass ($M$), length ($L$), and time ($T$).\nThe surface tension coefficient $\\sigma$ is force per unit length, so $[\\sigma] = \\frac{[Force]}{[Length]} = \\frac{MLT^{-2}}{L} = MT^{-2}$.\nThe mean curvature $\\kappa$ is the inverse of a length, so $[\\kappa] = L^{-1}$.\nThe area $A_e$ has dimensions of length squared, $[A_e] = L^2$.\nThe unit normal $\\mathbf{n}$ is dimensionless.\nThe total force exerted by the element is $\\mathbf{F}_e = \\sigma \\kappa A_e \\mathbf{n}$. The dimensions of its magnitude are:\n$$\n[\\|\\mathbf{F}_e\\|] = [\\sigma] [\\kappa] [A_e] = (MT^{-2}) (L^{-1}) (L^2) = MLT^{-2}\n$$\nThese are the dimensions of force, as expected.\n\nNow consider the discrete delta function $\\delta_h(\\mathbf{r})$. The argument of the kernel $\\phi$, $r/h$, is a ratio of lengths, so it is dimensionless. The function $\\phi$ itself is therefore dimensionless. The grid spacing $h$ has dimensions of length, $[h] = L$. The delta function is defined as:\n$$\n\\delta_h(\\mathbf{r}) = \\frac{1}{h^3} \\, \\phi\\!\\left(\\frac{r_x}{h}\\right) \\, \\phi\\!\\left(\\frac{r_y}{h}\\right) \\, \\phi\\!\\left(\\frac{r_z}{h}\\right)\n$$\nIts dimensions are:\n$$\n[\\delta_h] = \\frac{1}{[h^3]} [\\phi] [\\phi] [\\phi] = \\frac{1}{L^3} \\cdot 1 \\cdot 1 \\cdot 1 = L^{-3}\n$$\nThis corresponds to an inverse volume, which is the correct dimension for a three-dimensional delta function.\n\nFinally, the force density $\\mathbf{f}(\\mathbf{x}_i) = \\mathbf{F}_e \\delta_h(\\mathbf{x}_i - \\mathbf{x}_e)$. Its dimensions are:\n$$\n[\\|\\mathbf{f}(\\mathbf{x}_i)\\|] = [\\|\\mathbf{F}_e\\|] [\\delta_h] = (MLT^{-2}) (L^{-3}) = ML^{-2}T^{-2}\n$$\nThe dimensions of force density (force per unit volume) are $\\frac{[Force]}{[Volume]} = \\frac{MLT^{-2}}{L^3} = ML^{-2}T^{-2}$. The dimensions are consistent.\n\n### Solution Calculation\nThe force density is given by $\\mathbf{f}(\\mathbf{x}_i) = \\sigma \\kappa A_e \\mathbf{n} \\, \\delta_h(\\mathbf{x}_i - \\mathbf{x}_e)$. We need to compute its magnitude $\\|\\mathbf{f}(\\mathbf{x}_i)\\|$. Since $\\mathbf{n}$ is a unit vector, $\\|\\mathbf{n}\\| = 1$. The magnitude is:\n$$\n\\|\\mathbf{f}(\\mathbf{x}_i)\\| = |\\sigma \\kappa A_e| \\cdot \\delta_h(\\mathbf{x}_i - \\mathbf{x}_e) \\cdot \\|\\mathbf{n}\\| = \\sigma \\kappa A_e \\delta_h(\\mathbf{x}_i - \\mathbf{x}_e)\n$$\n(assuming $\\sigma, \\kappa, A_e \\ge 0$ and $\\delta_h \\ge 0$, which is true for the given kernel).\n\nFirst, we compute the displacement vector $\\mathbf{r} = \\mathbf{x}_i - \\mathbf{x}_e$:\n$$\n\\mathbf{r} = \\begin{pmatrix} 2.0 \\times 10^{-3} \\\\ 2.0 \\times 10^{-3} \\\\ 1.0 \\times 10^{-3} \\end{pmatrix} \\mathrm{m} - \\begin{pmatrix} 1.5 \\times 10^{-3} \\\\ 2.25 \\times 10^{-3} \\\\ 0.75 \\times 10^{-3} \\end{pmatrix} \\mathrm{m} = \\begin{pmatrix} 0.5 \\times 10^{-3} \\\\ -0.25 \\times 10^{-3} \\\\ 0.25 \\times 10^{-3} \\end{pmatrix} \\mathrm{m}\n$$\nNext, we compute the normalized displacement components for the kernel function $\\phi$, using $h = 1.0 \\times 10^{-3} \\, \\mathrm{m}$:\n$$\n\\frac{r_x}{h} = \\frac{0.5 \\times 10^{-3}}{1.0 \\times 10^{-3}} = 0.5\n$$\n$$\n\\frac{r_y}{h} = \\frac{-0.25 \\times 10^{-3}}{1.0 \\times 10^{-3}} = -0.25\n$$\n$$\n\\frac{r_z}{h} = \\frac{0.25 \\times 10^{-3}}{1.0 \\times 10^{-3}} = 0.25\n$$\nNow we evaluate the kernel function $\\phi$ for each of these values. All absolute values are less than or equal to $1$, so we use the first case of the definition of $\\phi(r)$.\n\nFor $r=0.5$:\n$$\n\\phi(0.5) = \\frac{1}{8}\\left(3 - 2|0.5| + \\sqrt{1 + 4|0.5| - 4(0.5)^2}\\right) = \\frac{1}{8}\\left(3 - 1 + \\sqrt{1 + 2 - 1}\\right) = \\frac{1}{8}(2 + \\sqrt{2})\n$$\nFor $r=-0.25$:\n$$\n\\phi(-0.25) = \\frac{1}{8}\\left(3 - 2|-0.25| + \\sqrt{1 + 4|-0.25| - 4(-0.25)^2}\\right) = \\frac{1}{8}\\left(3 - 0.5 + \\sqrt{1 + 1 - 0.25}\\right)\n$$\n$$\n\\phi(-0.25) = \\frac{1}{8}\\left(2.5 + \\sqrt{1.75}\\right) = \\frac{1}{8}\\left(\\frac{5}{2} + \\sqrt{\\frac{7}{4}}\\right) = \\frac{1}{8}\\left(\\frac{5}{2} + \\frac{\\sqrt{7}}{2}\\right) = \\frac{1}{16}(5 + \\sqrt{7})\n$$\nSince $\\phi(r)$ depends on $|r|$, $\\phi(0.25) = \\phi(-0.25)$.\n\nNow, we compute the value of the discrete delta function $\\delta_h(\\mathbf{r})$:\n$$\n\\delta_h(\\mathbf{r}) = \\frac{1}{h^3} \\phi\\left(\\frac{r_x}{h}\\right) \\phi\\left(\\frac{r_y}{h}\\right) \\phi\\left(\\frac{r_z}{h}\\right)\n$$\n$$\n\\delta_h(\\mathbf{r}) = \\frac{1}{(1.0 \\times 10^{-3})^3} \\left[ \\frac{1}{8}(2 + \\sqrt{2}) \\right] \\left[ \\frac{1}{16}(5 + \\sqrt{7}) \\right] \\left[ \\frac{1}{16}(5 + \\sqrt{7}) \\right]\n$$\n$$\n\\delta_h(\\mathbf{r}) = \\frac{10^9}{8 \\cdot 16 \\cdot 16} (2 + \\sqrt{2}) (5 + \\sqrt{7})^2 = \\frac{10^9}{2048} (2 + \\sqrt{2}) (25 + 10\\sqrt{7} + 7) = \\frac{10^9}{2048} (2 + \\sqrt{2}) (32 + 10\\sqrt{7})\n$$\nNumerically evaluating the components:\n$\\phi(0.5) = \\frac{1}{8}(2 + \\sqrt{2}) \\approx \\frac{1}{8}(3.41421356) \\approx 0.42677670$\n$\\phi(\\pm 0.25) = \\frac{1}{16}(5 + \\sqrt{7}) \\approx \\frac{1}{16}(7.64575131) \\approx 0.47785946$\n$$\n\\delta_h(\\mathbf{r}) \\approx \\frac{1}{(1.0 \\times 10^{-3})^3} (0.42677670) (0.47785946)^2 \\approx 10^9 \\cdot (0.42677670) \\cdot (0.22834954) \\approx 9.745150 \\times 10^7 \\, \\mathrm{m^{-3}}\n$$\nNext, we compute the scalar part of the force magnitude, $F_e = \\sigma \\kappa A_e$:\n$$\nF_e = (0.072 \\, \\mathrm{N\\,m^{-1}}) \\cdot (4.0 \\times 10^3 \\, \\mathrm{m^{-1}}) \\cdot (2.5 \\times 10^{-8} \\, \\mathrm{m^2})\n$$\n$$\nF_e = 0.072 \\cdot (4.0 \\times 2.5) \\cdot (10^3 \\times 10^{-8}) \\, \\mathrm{N} = 0.072 \\cdot 10.0 \\cdot 10^{-5} \\, \\mathrm{N} = 0.72 \\cdot 10^{-5} \\, \\mathrm{N} = 7.2 \\times 10^{-6} \\, \\mathrm{N}\n$$\nFinally, we compute the magnitude of the force density:\n$$\n\\|\\mathbf{f}(\\mathbf{x}_i)\\| = F_e \\cdot \\delta_h(\\mathbf{r})\n$$\n$$\n\\|\\mathbf{f}(\\mathbf{x}_i)\\| \\approx (7.2 \\times 10^{-6} \\, \\mathrm{N}) \\cdot (9.745150 \\times 10^7 \\, \\mathrm{m^{-3}})\n$$\n$$\n\\|\\mathbf{f}(\\mathbf{x}_i)\\| \\approx 7.2 \\cdot 9.745150 \\times 10^1 \\, \\mathrm{N\\,m^{-3}} \\approx 701.6508 \\, \\mathrm{N\\,m^{-3}}\n$$\nRounding the final answer to four significant figures, we get $701.7 \\, \\mathrm{N\\,m^{-3}}$.",
            "answer": "$$\n\\boxed{701.7}\n$$"
        },
        {
            "introduction": "While the Eulerian grid solves for the fluid flow, the Lagrangian front must be meticulously managed to maintain an accurate representation of the interface. A crucial aspect of this management is the ability to compute geometric properties of the front, such as the area it encloses, which is directly related to mass conservation. This practice guides you through the development of a robust algorithm to compute the area of a polygonal interface, starting from first principles and accounting for practical numerical challenges like duplicate markers and orientation . Such routines are essential for monitoring the health and accuracy of a front-tracking simulation.",
            "id": "4088841",
            "problem": "You are given an ordered set of Lagrangian markers representing a two-dimensional material interface in a Front-Tracking Method (FTM) for Computational Fluid Dynamics (CFD). The markers are points in the plane with coordinates in meters. The task is to reconstruct a closed polygonal interface from these ordered markers and to compute its enclosed area robustly so that it can be used for conservation checks in simulations of computational complex fluids.\n\nStarting from fundamental principles, the derivation must begin from well-tested mathematical facts about line integrals over closed curves and the relation of area to such integrals. The reconstructed polygon must satisfy the following requirements: it must be closed, it must be free of spurious zero-length edges induced by near-coincident markers, and the resulting area computation must be numerically robust under translation, cyclic re-indexing of markers, and changes in orientation. You must ensure that the construction and the area evaluation are independent of uniform translations of the marker coordinates and that the method behaves consistently even when the input ordering is reversed.\n\nImplementation requirements:\n- Given an ordered list of markers $\\{(x_i,y_i)\\}_{i=0}^{N-1}$ with coordinates in $\\mathrm{m}$, reconstruct a closed polygon by connecting consecutive markers and the last marker back to the first marker. If the input is not explicitly closed, enforce closure by appending the first marker to the end. If the input already contains a closing marker within a threshold distance $\\epsilon$ (defined below), enforce exact closure by making the last marker equal to the first marker.\n- Remove consecutive near-coincident markers to avoid zero-length edges. Two consecutive markers $(x_i,y_i)$ and $(x_{i+1},y_{i+1})$ are considered near-coincident if their Euclidean distance is less than a threshold $\\epsilon$ in $\\mathrm{m}$. Use $\\epsilon = 10^{-9}\\,\\mathrm{m}$.\n- If fewer than $3$ non-coincident markers remain after de-duplication, define the area to be $0\\,\\mathrm{m}^2$.\n- Compute the enclosed area of the reconstructed polygon in $\\mathrm{m}^2$, using a robust method derived from first principles that is stable under floating-point arithmetic. The area result must be nonnegative and must be independent of the polygonâ€™s orientation (clockwise or counterclockwise).\n\nAngle usage note:\n- If any angles are used to generate markers for the test suite, angles must be in radians.\n\nYour program must implement this reconstruction and area computation and apply it to the following test suite of marker sets. All coordinates are provided in $\\mathrm{m}$:\n\n- Test case $1$ (happy path with near-duplicate and non-closed input): A square of side length $2\\,\\mathrm{m}$ with vertices at $(0\\,\\mathrm{m},0\\,\\mathrm{m})$, $(2\\,\\mathrm{m},0\\,\\mathrm{m})$, $(2\\,\\mathrm{m},2\\,\\mathrm{m})$, $(0\\,\\mathrm{m},2\\,\\mathrm{m})$. The input markers are ordered as\n  $(0\\,\\mathrm{m},0\\,\\mathrm{m})$, $(2\\,\\mathrm{m},0\\,\\mathrm{m})$, $(2\\,\\mathrm{m},(2+10^{-12})\\,\\mathrm{m})$, $(2\\,\\mathrm{m},2\\,\\mathrm{m})$, $(0\\,\\mathrm{m},2\\,\\mathrm{m})$.\n- Test case $2$ (translation invariance check): A regular hexagon of circumradius $1\\,\\mathrm{m}$ centered at $(1000\\,\\mathrm{m},1000\\,\\mathrm{m})$, with markers ordered counterclockwise at angles $0$, $\\frac{2\\pi}{6}$, $\\frac{4\\pi}{6}$, $\\frac{6\\pi}{6}$, $\\frac{8\\pi}{6}$, $\\frac{10\\pi}{6}$ radians.\n- Test case $3$ (degenerate boundary condition): Collinear markers along the $x$-axis ordered as $(-1\\,\\mathrm{m},0\\,\\mathrm{m})$, $(0\\,\\mathrm{m},0\\,\\mathrm{m})$, $(1\\,\\mathrm{m},0\\,\\mathrm{m})$, $(2\\,\\mathrm{m},0\\,\\mathrm{m})$.\n- Test case $4$ (orientation reversal): A triangle ordered clockwise with markers $(0\\,\\mathrm{m},0\\,\\mathrm{m})$, $(0\\,\\mathrm{m},2\\,\\mathrm{m})$, $(2\\,\\mathrm{m},0\\,\\mathrm{m})$.\n- Test case $5$ (non-uniformly spaced markers on an ellipse): An ellipse centered at $(-0.3\\,\\mathrm{m},0.5\\,\\mathrm{m})$ with semi-axes $a=1.1\\,\\mathrm{m}$ and $b=0.7\\,\\mathrm{m}$, sampled at angles (in radians) $t \\in \\{0, 0.2\\pi, 0.33\\pi, 0.5\\pi, 0.7\\pi, 1.17\\pi, 1.5\\pi, 1.83\\pi\\}$, producing markers $(x,y) = (-0.3 + a\\cos t,\\; 0.5 + b\\sin t)$ in meters.\n\nOutput requirements:\n- Express each computed area in $\\mathrm{m}^2$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases $1$ through $5$ (for example, \"$[a_1,a_2,a_3,a_4,a_5]$\"), where each $a_i$ is a floating-point number in $\\mathrm{m}^2$ computed by your method.\n\nDesign constraints:\n- The derivation and algorithmic design must begin from the fundamental base of line integration over closed curves and properties of area without giving away target formulas in this problem statement.\n- Ensure scientific realism and numerical plausibility throughout.",
            "solution": "The problem requires the reconstruction of a closed polygonal interface from an ordered set of Lagrangian markers and the computation of its enclosed area. The method must be robust, derived from first principles, and satisfy specific numerical hygiene requirements such as handling near-coincident points and ensuring invariance under translation and orientation changes.\n\nThe derivation of the area computation method begins with a fundamental theorem of vector calculus, Green's Theorem. For a two-dimensional vector field $\\vec{F}(x, y) = (L(x, y), M(x, y))$ and a simply connected region $D$ with a boundary curve $C$ that is piecewise smooth, simple, closed, and oriented counter-clockwise, Green's Theorem states:\n$$\n\\oint_C (L \\, dx + M \\, dy) = \\iint_D \\left( \\frac{\\partial M}{\\partial x} - \\frac{\\partial L}{\\partial y} \\right) dA\n$$\nThe area of the region $D$ is given by the integral $A = \\iint_D dA$. To compute this area using a line integral, we must select a vector field $\\vec{F}$ such that the integrand on the right-hand side is unity, i.e., $\\frac{\\partial M}{\\partial x} - \\frac{\\partial L}{\\partial y} = 1$. There are several valid choices for $\\vec{F}$, but a particularly useful one for its symmetry is $\\vec{F} = (-\\frac{1}{2}y, \\frac{1}{2}x)$. For this field, $L = -\\frac{1}{2}y$ and $M = \\frac{1}{2}x$, yielding:\n$$\n\\frac{\\partial M}{\\partial x} - \\frac{\\partial L}{\\partial y} = \\frac{\\partial}{\\partial x}\\left(\\frac{1}{2}x\\right) - \\frac{\\partial}{\\partial y}\\left(-\\frac{1}{2}y\\right) = \\frac{1}{2} - \\left(-\\frac{1}{2}\\right) = 1\n$$\nSubstituting this into Green's Theorem gives the area as a line integral:\n$$\nA = \\oint_C \\frac{1}{2}(x \\, dy - y \\, dx)\n$$\nTo apply this to a polygon, we discretize the integral. A polygon is defined by an ordered set of vertices $\\{(x_i, y_i)\\}_{i=0}^{N-1}$. The boundary $C$ is the union of line segments $C_i$ connecting vertex $(x_i, y_i)$ to $(x_{i+1}, y_{i+1})$, where the indexing is cyclic, i.e., $(x_N, y_N) = (x_0, y_0)$. The total line integral is the sum of integrals over each segment:\n$$\nA = \\sum_{i=0}^{N-1} \\int_{C_i} \\frac{1}{2}(x \\, dy - y \\, dx)\n$$\nFor a single segment $C_i$, we can parameterize the path from $(x_i, y_i)$ to $(x_{i+1}, y_{i+1})$ using a parameter $t \\in [0, 1]$: $x(t) = x_i + t(x_{i+1} - x_i)$ and $y(t) = y_i + t(y_{i+1} - y_i)$. Then $dx = (x_{i+1} - x_i)dt$ and $dy = (y_{i+1} - y_i)dt$. The integral over segment $C_i$ becomes:\n$$\n\\int_0^1 \\frac{1}{2} \\left[ (x_i + t(x_{i+1}-x_i))(y_{i+1}-y_i) - (y_i + t(y_{i+1}-y_i))(x_{i+1}-x_i) \\right] dt\n$$\nExpanding the terms inside the integral simplifies to:\n$$\n\\int_0^1 \\frac{1}{2} (x_i y_{i+1} - x_i y_i - y_i x_{i+1} + y_i x_i) dt = \\frac{1}{2}(x_i y_{i+1} - y_i x_{i+1}) \\int_0^1 dt = \\frac{1}{2}(x_i y_{i+1} - y_i x_{i+1})\n$$\nSumming over all segments from $i=0$ to $N-1$ gives the total area:\n$$\nA = \\frac{1}{2} \\sum_{i=0}^{N-1} (x_i y_{i+1} - x_{i+1} y_i)\n$$\nThis is the well-known Shoelace (or Surveyor's) formula. This formula yields a signed area: positive for counter-clockwise vertex ordering and negative for clockwise. As the problem requires a non-negative area independent of orientation, we take the absolute value:\n$$\nA = \\left| \\frac{1}{2} \\sum_{i=0}^{N-1} (x_i y_{i+1} - x_{i+1} y_i) \\right|\n$$\nThis formula is inherently robust to translation. A shift of all vertices by a vector $(a, b)$ results in new coordinates $(x'_i, y'_i) = (x_i+a, y_i+b)$. The term $(x'_i y'_{i+1} - x'_{i+1} y'_i)$ evaluates to $(x_i y_{i+1} - x_{i+1} y_i) + a(y_{i+1} - y_i) - b(x_{i+1} - x_i)$. When summed over the closed loop, the terms involving $a$ and $b$ form telescoping series that sum to zero (e.g., $\\sum (y_{i+1}-y_i) = y_1-y_0 + y_2-y_1 + \\dots + y_0-y_{N-1} = 0$), proving translation invariance.\n\nThe algorithmic implementation follows these steps:\n1.  **Filter Consecutive Near-Coincident Markers**: The raw list of markers is processed to create a clean list. The first marker is kept. Subsequent markers $(x_k, y_k)$ are added only if their Euclidean distance to the *last added marker* exceeds the threshold $\\epsilon = 10^{-9}\\,\\mathrm{m}$. This prevents zero-length or near-zero-length edges which can cause numerical issues.\n2.  **Handle Degenerate Geometries**: If the filtering process results in fewer than $3$ markers, a non-degenerate polygon cannot be formed. In this case, the area is defined to be $0\\,\\mathrm{m}^2$.\n3.  **Establish Unique Vertex List**: The Shoelace formula implicitly assumes a closed polygon from an ordered list of unique vertices. If the input marker list represents a closed loop where the last marker is a near-duplicate of the first (i.e., their distance is less than $\\epsilon$), this redundant last marker is removed from the list of vertices to be processed. This step correctly interprets the problem's requirement to \"enforce exact closure\" by working with the essential, unique geometric vertices.\n4.  **Compute Area**: The Shoelace formula is applied to the final list of $N$ unique vertices. This can be implemented efficiently using vectorized operations. The sum $\\sum_{i=0}^{N-1} (x_i y_{i+1} - x_{i+1} y_i)$ is computed, where indices are modulo $N$. The final area is half the absolute value of this sum.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of computing the area of a polygon defined by Lagrangian markers.\n    \"\"\"\n    epsilon = 1.0e-9\n\n    def compute_polygon_area(raw_markers):\n        \"\"\"\n        Reconstructs a polygon from markers and computes its area.\n\n        Args:\n            raw_markers (list of tuples): An ordered list of (x, y) coordinates for the markers.\n\n        Returns:\n            float: The computed non-negative area of the polygon.\n        \"\"\"\n        # A valid polygon requires at least 3 vertices. An empty or small\n        # list of markers results in zero area.\n        if len(raw_markers) < 3:\n            return 0.0\n\n        # Convert to a NumPy array for efficient vectorized operations.\n        raw_markers_np = np.array(raw_markers, dtype=np.float64)\n\n        # Step 1: Filter consecutive near-coincident markers\n        # to prevent zero-length or numerically unstable edges.\n        processed_markers = [raw_markers_np[0]]\n        for i in range(1, len(raw_markers_np)):\n            distance = np.linalg.norm(raw_markers_np[i] - processed_markers[-1])\n            if distance >= epsilon:\n                processed_markers.append(raw_markers_np[i])\n\n        # Step 2: Handle degenerate case (fewer than 3 unique vertices)\n        if len(processed_markers) < 3:\n            return 0.0\n\n        vertices = np.array(processed_markers)\n\n        # Step 3: Establish a unique vertex list for the Shoelace formula.\n        # If the last marker is a near-duplicate of the first, the polygon is\n        # explicitly closed. We remove the redundant last point because the\n        # formula implicitly connects the last vertex back to the first.\n        if np.linalg.norm(vertices[0] - vertices[-1]) < epsilon:\n            vertices = vertices[:-1]\n\n        # Check for degeneracy again after possibly removing the closing point.\n        if len(vertices) < 3:\n            return 0.0\n\n        # Step 4: Compute the area using the Shoelace formula.\n        # A = 0.5 * |(x0*y1 + x1*y2 + ...) - (y0*x1 + y1*x2 + ...)|\n        # This is implemented efficiently using NumPy's array operations\n        # and np.roll for circular shifting of array elements.\n        x = vertices[:, 0]\n        y = vertices[:, 1]\n        \n        # The sum of x_i * y_{i+1} minus y_i * x_{i+1}\n        area_sum = np.sum(x * np.roll(y, -1) - np.roll(x, -1) * y)\n\n        # The area is half the absolute value of the sum.\n        area = 0.5 * np.abs(area_sum)\n        \n        return area\n\n    # Test Case 1: Square with a near-duplicate point\n    case1_markers = [\n        (0.0, 0.0), (2.0, 0.0), (2.0, 2.0 + 1e-12), (2.0, 2.0), (0.0, 2.0)\n    ]\n\n    # Test Case 2: Translated regular hexagon\n    center2 = np.array([1000.0, 1000.0])\n    radius2 = 1.0\n    angles2 = np.arange(6) * (np.pi / 3.0) # Equivalent to 2*pi/6\n    case2_markers = [\n        (center2[0] + radius2 * np.cos(t), center2[1] + radius2 * np.sin(t)) for t in angles2\n    ]\n    \n    # Test Case 3: Collinear markers (degenerate polygon)\n    case3_markers = [\n        (-1.0, 0.0), (0.0, 0.0), (1.0, 0.0), (2.0, 0.0)\n    ]\n\n    # Test Case 4: Clockwise oriented triangle\n    case4_markers = [\n        (0.0, 0.0), (0.0, 2.0), (2.0, 0.0)\n    ]\n\n    # Test Case 5: Polygon approximation of an ellipse\n    center5 = np.array([-0.3, 0.5])\n    a5, b5 = 1.1, 0.7\n    angles5 = [0, 0.2*np.pi, 0.33*np.pi, 0.5*np.pi, 0.7*np.pi, 1.17*np.pi, 1.5*np.pi, 1.83*np.pi]\n    case5_markers = [\n        (center5[0] + a5 * np.cos(t), center5[1] + b5 * np.sin(t)) for t in angles5\n    ]\n    \n    test_cases = [\n        case1_markers,\n        case2_markers,\n        case3_markers,\n        case4_markers,\n        case5_markers,\n    ]\n\n    results = []\n    for case in test_cases:\n        area = compute_polygon_area(case)\n        results.append(area)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A key challenge in simulating multiphase flows is that the numerical approximation of a perfectly balanced physical force, like surface tension on a static drop, can introduce small imbalances that drive non-physical flows known as \"spurious currents\". This practice involves implementing the \"static drop test,\" a canonical benchmark used to validate multiphase flow solvers and quantify the magnitude of these numerical artifacts . By solving the Stokes equations for the flow induced by the discretized surface tension force, you will gain direct insight into how numerical parameters, such as the grid resolution and the width of the delta function, impact the accuracy and physical fidelity of the simulation.",
            "id": "4088839",
            "problem": "Consider a two-dimensional, periodic square domain of side length $L = 1$ filled with a single Newtonian fluid of dynamic viscosity $\\mu$. A single circular drop with surface tension coefficient $\\sigma$ is embedded, centered at $(0.5,0.5)$ with radius $R$. In the continuum, the static-drop configuration at rest is an exact equilibrium: the interface force balances the pressure jump and the velocity field is identically zero. In a front-tracking numerical method, the interfacial force is spread to an Eulerian grid using a regularized delta function with a finite smoothing width $\\delta_h$. In practice, a nonzero solenoidal component of the discretized force remains after spreading, generating so-called spurious currents. A rigorous way to assess the suppression of spurious currents is to perform a static-drop test: compute the steady incompressible Stokes response to the discretized interfacial force and report the maximum velocity magnitude as the grid is refined.\n\nStarting from the steady incompressible Stokes equations under periodic boundary conditions,\n$$\n-\\nabla p + \\mu \\nabla^2 \\mathbf{u} + \\mathbf{f} = \\mathbf{0}, \\qquad \\nabla \\cdot \\mathbf{u} = 0,\n$$\ndesign and implement a program that:\n\n- Represents the interface as a closed parametric curve of $M$ equally spaced Lagrangian markers on a circle of radius $R$ centered at $(0.5,0.5)$.\n- Uses the curvature $\\kappa = 1/R$ and outward unit normal vector $\\mathbf{n}$ at each marker to construct the continuous interfacial surface tension force per unit length $\\sigma \\kappa \\mathbf{n}$.\n- Spreads the interfacial force to the Eulerian grid by approximating the line integral with a Riemann sum of $M$ markers, where each marker contributes\n$$\n\\Delta \\mathbf{F}(\\mathbf{x}) = \\sigma \\kappa \\mathbf{n} \\,\\Delta s\\, \\delta_{\\delta_h}(\\mathbf{x} - \\mathbf{X}_i),\n$$\nwith $\\Delta s = 2\\pi R/M$ and the regularized two-dimensional delta function chosen as the isotropic Gaussian\n$$\n\\delta_{\\delta_h}(\\mathbf{r}) = \\frac{1}{\\pi \\delta_h^2}\\,\\exp\\!\\left(-\\frac{\\lVert \\mathbf{r}\\rVert^2}{\\delta_h^2}\\right).\n$$\nDistances $\\mathbf{r} = \\mathbf{x} - \\mathbf{X}_i$ must be computed with minimum-image periodic wrapping on the unit torus so that each component is mapped to the interval $[-0.5,0.5]$.\n\n- Solves the steady Stokes problem on a uniform $N \\times N$ grid in Fourier space using a solenoidal projection consistent with the incompressibility constraint, returning the velocity field $\\mathbf{u}(\\mathbf{x})$. The exact continuum equilibrium would yield the zero field $\\mathbf{u}(\\mathbf{x}) = \\mathbf{0}$; any nonzero field is the spurious current induced by discretization and regularization.\n- Reports the maximum velocity magnitude $\\max_{\\mathbf{x}} \\lVert \\mathbf{u}(\\mathbf{x}) \\rVert$ for each test case.\n\nAll quantities are nondimensional. Angles must be in radians. The discrete Fourier transform should be implemented using the Fast Fourier Transform (FFT). The program must produce the steady Stokes response by projecting the spread force to its divergence-free component and inverting the Laplacian in Fourier space, consistently handling the zero wavenumber mode to avoid singularities.\n\nTest Suite. Use the following set of parameter values to exercise different aspects of the method:\n\n- Case $1$: $N = 32$, $\\delta_h/h = 0.5$, $R = 0.25$, $\\mu = 1.0$, $\\sigma = 1.0$, $M = 128$.\n- Case $2$: $N = 64$, $\\delta_h/h = 1.0$, $R = 0.25$, $\\mu = 1.0$, $\\sigma = 1.0$, $M = 256$.\n- Case $3$: $N = 64$, $\\delta_h/h = 2.0$, $R = 0.25$, $\\mu = 1.0$, $\\sigma = 1.0$, $M = 256$.\n- Case $4$: $N = 128$, $\\delta_h/h = 2.0$, $R = 0.25$, $\\mu = 1.0$, $\\sigma = 1.0$, $M = 512$.\n- Case $5$: $N = 64$, $\\delta_h/h = 4.0$, $R = 0.25$, $\\mu = 1.0$, $\\sigma = 1.0$, $M = 256$.\n\nHere $h = L/N$ and $\\delta_h = (\\delta_h/h)h$. The program should compute the maximum velocity magnitude for each case. Your program should produce a single line of output containing the results as a comma-separated list of floats in scientific notation with exactly $8$ significant digits, enclosed in square brackets, in the order of the cases above (e.g., $[a_1,a_2,a_3,a_4,a_5]$). The answers are nondimensional floats.",
            "solution": "The user-provided problem is a well-posed and scientifically sound task from the domain of computational fluid dynamics, specifically concerning the numerical simulation of multiphase flows. It asks for the implementation of a static drop test, a standard benchmark used to quantify the magnitude of non-physical \"spurious currents\" that arise from the discretization of surface tension forces in front-tracking and other Eulerian methods for moving interfaces. The problem provides a complete set of physical and numerical parameters and specifies a Fourier spectral method for the solution, which is appropriate for the periodic domain. The problem statement is validated as complete, consistent, and grounded in established scientific principles.\n\nThe solution proceeds by implementing a Fourier-spectral solver for the steady, incompressible Stokes equations on a two-dimensional periodic domain, with a forcing term derived from a regularized model of surface tension on a circular interface.\n\n### Principle-Based Design of the Numerical Method\n\nThe core of the problem is to find the steady-state velocity field $\\mathbf{u}(\\mathbf{x})$ that satisfies the incompressible Stokes equations for a fluid with dynamic viscosity $\\mu$ under the action of a force field $\\mathbf{f}(\\mathbf{x})$:\n$$\n-\\nabla p + \\mu \\nabla^2 \\mathbf{u} + \\mathbf{f} = \\mathbf{0}\n$$\n$$\n\\nabla \\cdot \\mathbf{u} = 0\n$$\nwhere $p$ is the pressure. The domain is a periodic square of side length $L=1$.\n\n#### 1. Fourier Spectral Solution of Stokes Equations\nFor a problem on a periodic domain, a Fourier spectral method is highly effective. We represent all fields (velocity $\\mathbf{u}$, pressure $p$, and force $\\mathbf{f}$) by their Fourier series. The differential operators transform into algebraic operations in Fourier space. Let $\\hat{\\phi}(\\mathbf{k})$ denote the Fourier transform of a field $\\phi(\\mathbf{x})$, where $\\mathbf{k}=(k_x, k_y)$ is the wavevector. The operators transform as: $\\nabla \\rightarrow i\\mathbf{k}$, $\\nabla \\cdot \\rightarrow i\\mathbf{k} \\cdot$, and $\\nabla^2 \\rightarrow -\\|\\mathbf{k}\\|^2 = -k^2$.\n\nApplying the Fourier transform to the Stokes equations yields a system of algebraic equations for each wavevector $\\mathbf{k}$:\n$$\n-i\\mathbf{k} \\hat{p}(\\mathbf{k}) + \\mu (-k^2) \\hat{\\mathbf{u}}(\\mathbf{k}) + \\hat{\\mathbf{f}}(\\mathbf{k}) = \\mathbf{0}\n$$\n$$\ni\\mathbf{k} \\cdot \\hat{\\mathbf{u}}(\\mathbf{k}) = 0\n$$\n\nThe second equation is the incompressibility constraint in Fourier space, which states that the Fourier mode of the velocity field, $\\hat{\\mathbf{u}}(\\mathbf{k})$, must be orthogonal to its corresponding wavevector $\\mathbf{k}$. This means $\\hat{\\mathbf{u}}(\\mathbf{k})$ is a solenoidal (divergence-free) vector field.\n\nWe can eliminate the pressure term by applying a solenoidal projection operator, $\\mathcal{P}_{\\mathbf{k}}(\\mathbf{v}) = \\mathbf{v} - (\\mathbf{v} \\cdot \\mathbf{k}/k^2)\\mathbf{k}$, to the momentum equation. This operator projects a vector onto the subspace perpendicular to $\\mathbf{k}$.\n- The pressure gradient term, $-i\\mathbf{k} \\hat{p}$, is parallel to $\\mathbf{k}$, so its projection is zero: $\\mathcal{P}_{\\mathbf{k}}(-i\\mathbf{k} \\hat{p}) = \\mathbf{0}$.\n- The velocity field $\\hat{\\mathbf{u}}$ is already solenoidal, so it is unchanged by the projection: $\\mathcal{P}_{\\mathbf{k}}(\\hat{\\mathbf{u}}) = \\hat{\\mathbf{u}}$.\n\nApplying the projection to the momentum equation gives:\n$$\n-\\mu k^2 \\hat{\\mathbf{u}}(\\mathbf{k}) + \\mathcal{P}_{\\mathbf{k}}(\\hat{\\mathbf{f}}(\\mathbf{k})) = \\mathbf{0}\n$$\nSolving for $\\hat{\\mathbf{u}}(\\mathbf{k})$ for $\\mathbf{k} \\neq \\mathbf{0}$ yields:\n$$\n\\hat{\\mathbf{u}}(\\mathbf{k}) = \\frac{1}{\\mu k^2} \\mathcal{P}_{\\mathbf{k}}(\\hat{\\mathbf{f}}(\\mathbf{k})) = \\frac{1}{\\mu k^2} \\left( \\hat{\\mathbf{f}}(\\mathbf{k}) - \\frac{\\hat{\\mathbf{f}}(\\mathbf{k}) \\cdot \\mathbf{k}}{k^2} \\mathbf{k} \\right)\n$$\nFor the zero-wavenumber mode $\\mathbf{k} = \\mathbf{0}$, which corresponds to the spatial average of the fields, the momentum equation reduces to $\\hat{\\mathbf{f}}(\\mathbf{0}) = \\mathbf{0}$. This condition, stating that the net force on the domain must be zero, is satisfied for a closed interface due to symmetry. The equation provides no information about the mean velocity $\\hat{\\mathbf{u}}(\\mathbf{0})$. For a static test, we assume the system is at rest on average, so we set $\\hat{\\mathbf{u}}(\\mathbf{0}) = \\mathbf{0}$.\n\n#### 2. Interfacial Force Calculation and Spreading\nThe force $\\mathbf{f}$ originates from surface tension $\\sigma$ acting on the circular interface of radius $R$. The continuum surface tension force is a line source given by $\\mathbf{F}_s = \\sigma \\kappa \\mathbf{n}$, where $\\kappa = 1/R$ is the curvature and $\\mathbf{n}$ is the outward normal vector.\n\nNumerically, this continuous force is discretized and spread onto the $N \\times N$ Eulerian grid. The interface is represented by $M$ Lagrangian markers $\\mathbf{X}_i$ for $i=0, \\dots, M-1$, with arc length $\\Delta s = 2\\pi R / M$ between them. Each marker contributes a force that is distributed to nearby grid points using a regularized two-dimensional delta function, $\\delta_{\\delta_h}$. The problem specifies an isotropic Gaussian:\n$$\n\\delta_{\\delta_h}(\\mathbf{r}) = \\frac{1}{\\pi \\delta_h^2}\\,\\exp\\left(-\\frac{\\lVert \\mathbf{r}\\rVert^2}{\\delta_h^2}\\right)\n$$\nThe force density at any grid point $\\mathbf{x}$ is the sum of contributions from all markers:\n$$\n\\mathbf{f}(\\mathbf{x}) = \\sum_{i=0}^{M-1} (\\sigma \\kappa \\mathbf{n}_i \\Delta s) \\, \\delta_{\\delta_h}(\\mathbf{x} - \\mathbf{X}_i)\n$$\nSubstituting $\\kappa=1/R$ and $\\Delta s = 2\\pi R / M$, the term in parenthesis becomes $(2\\pi\\sigma/M)\\mathbf{n}_i$. The distance vector $\\mathbf{r} = \\mathbf{x} - \\mathbf{X}_i$ is computed using the minimum-image convention on the periodic domain of side length $L=1$, ensuring each component lies in $[-0.5, 0.5]$.\n\n#### 3. Algorithm Summary\nThe complete algorithm is as follows:\n1.  **Initialization**: Define the Eulerian grid of size $N \\times N$ with grid spacing $h=L/N=1/N$. Define the $M$ Lagrangian markers on the circular interface.\n2.  **Force Spreading**: For each grid point $\\mathbf{x}_{jk}$, calculate the total force $\\mathbf{f}(\\mathbf{x}_{jk})$ by summing the contributions from all $M$ markers using the Gaussian delta function and periodic distances. This results in two $N \\times N$ arrays for the force components, $f_x$ and $f_y$.\n3.  **Forward FFT**: Compute the discrete Fourier transforms of $f_x$ and $f_y$ to obtain $\\hat{f}_x(\\mathbf{k})$ and $\\hat{f}_y(\\mathbf{k})$.\n4.  **Fourier-Space Solve**: For each wavevector $\\mathbf{k}$ in the discrete Fourier grid:\n    a. If $\\mathbf{k}=\\mathbf{0}$, set $\\hat{u}_x(\\mathbf{0})=0$ and $\\hat{u}_y(\\mathbf{0})=0$.\n    b. If $\\mathbf{k}\\neq\\mathbf{0}$, calculate $\\hat{\\mathbf{u}}(\\mathbf{k})$ using the derived expression involving the solenoidal projection of $\\hat{\\mathbf{f}}(\\mathbf{k})$.\n5.  **Inverse FFT**: Compute the inverse discrete Fourier transforms of $\\hat{u}_x(\\mathbf{k})$ and $\\hat{u}_y(\\mathbf{k})$ to obtain the real-space velocity components $u_x(\\mathbf{x})$ and $u_y(\\mathbf{x})$.\n6.  **Result**: Calculate the velocity magnitude $\\lVert \\mathbf{u}(\\mathbf{x}) \\rVert = \\sqrt{u_x^2(\\mathbf{x}) + u_y^2(\\mathbf{x})}$ at each grid point and find the maximum value over the entire domain. This value is the magnitude of the spurious current.\n\nThis procedure is repeated for each set of parameters provided in the test suite. The resulting maximum velocity magnitudes quantify the numerical error, which is expected to decrease with grid refinement (increasing $N$) and depend sensitively on the choice of the smoothing parameter $\\delta_h$.",
            "answer": "```python\nimport numpy as np\n\ndef calculate_max_velocity(N, delta_h_over_h, R, mu, sigma, M):\n    \"\"\"\n    Computes the maximum spurious velocity for a static drop test using a \n    Fourier-spectral method for the Stokes equations.\n\n    Args:\n        N (int): Number of grid points in each dimension (N x N grid).\n        delta_h_over_h (float): Ratio of the smoothing width to the grid spacing.\n        R (float): Radius of the circular drop.\n        mu (float): Dynamic viscosity of the fluid.\n        sigma (float): Surface tension coefficient.\n        M (int): Number of Lagrangian markers on the interface.\n\n    Returns:\n        float: The maximum magnitude of the velocity field (spurious current).\n    \"\"\"\n    # 1. Grid and physical parameters setup\n    L = 1.0\n    h = L / N\n    delta_h = delta_h_over_h * h\n    \n    # Eulerian grid coordinates\n    grid_coords_1d = np.arange(N) * h\n    xx, yy = np.meshgrid(grid_coords_1d, grid_coords_1d, indexing='ij')\n\n    # 2. Interface representation\n    theta = np.linspace(0, 2 * np.pi, M, endpoint=False)\n    # Marker positions\n    Xi_x = 0.5 + R * np.cos(theta)\n    Xi_y = 0.5 + R * np.sin(theta)\n    # Outward normal vectors\n    ni_x = np.cos(theta)\n    ni_y = np.sin(theta)\n    \n    # 3. Force spreading\n    fx = np.zeros((N, N), dtype=float)\n    fy = np.zeros((N, N), dtype=float)\n    \n    # Pre-calculate constant factor for force spreading.\n    # The term sigma * kappa * ds for a marker is sigma * (1/R) * (2*pi*R/M) = 2*pi*sigma/M.\n    # The prefactor for the Gaussian delta function is 1/(pi*delta_h^2).\n    # The combined prefactor is (2*pi*sigma/M) * (1/(pi*delta_h^2)) = 2*sigma / (M*delta_h^2).\n    force_prefactor = 2 * sigma / (M * delta_h**2)\n    \n    for i in range(M):\n        # Compute wrapped distance from marker i to all grid points\n        dx = xx - Xi_x[i]\n        dy = yy - Xi_y[i]\n        \n        # Apply minimum image convention for periodic domain of L=1\n        dx -= np.round(dx)\n        dy -= np.round(dy)\n        \n        r_sq = dx**2 + dy**2\n        \n        # Evaluate the Gaussian delta function kernel\n        kernel = np.exp(-r_sq / delta_h**2)\n        \n        # Add the force contribution from marker i to the grid force field\n        fx += force_prefactor * ni_x[i] * kernel\n        fy += force_prefactor * ni_y[i] * kernel\n\n    # 4. Solve Stokes equations in Fourier space\n    # Take the 2D Fast Fourier Transform of the force field components\n    f_hat_x = np.fft.fft2(fx)\n    f_hat_y = np.fft.fft2(fy)\n    \n    # Create the grid of angular wavenumbers\n    k_freq = np.fft.fftfreq(N, d=h)\n    k_angular = 2 * np.pi * k_freq\n    kx, ky = np.meshgrid(k_angular, k_angular, indexing='ij')\n\n    k_sq = kx**2 + ky**2\n    \n    # To avoid division by zero at k=0, we compute the inverse of k^2 only where k is non-zero.\n    # The k=0 mode must be handled separately.\n    k_sq_inv = np.zeros_like(k_sq)\n    non_zero_k_mask = k_sq != 0\n    k_sq_inv[non_zero_k_mask] = 1.0 / k_sq[non_zero_k_mask]\n    \n    # Project the force field onto its solenoidal (divergence-free) part.\n    # This is done by subtracting the irrotational (curl-free) part: f_hat - (f_hat . k)k/k^2\n    f_hat_dot_k = f_hat_x * kx + f_hat_y * ky\n    \n    f_sol_x = f_hat_x - (f_hat_dot_k * kx * k_sq_inv)\n    f_sol_y = f_hat_y - (f_hat_dot_k * ky * k_sq_inv)\n    \n    # Solve for velocity in Fourier space: u_hat = f_sol / (mu * k^2)\n    u_hat_x = (1 / mu) * f_sol_x * k_sq_inv\n    u_hat_y = (1 / mu) * f_sol_y * k_sq_inv\n    # For k=0, k_sq_inv is 0, so u_hat(0,0) is correctly set to 0, satisfying the zero mean velocity condition.\n    \n    # Transform velocity back to real space using inverse FFT\n    ux = np.fft.ifft2(u_hat_x).real\n    uy = np.fft.ifft2(u_hat_y).real\n    \n    # 5. Compute the maximum velocity magnitude\n    vel_mag = np.sqrt(ux**2 + uy**2)\n    max_vel = np.max(vel_mag)\n    \n    return max_vel\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, delta_h/h, R, mu, sigma, M)\n        (32, 0.5, 0.25, 1.0, 1.0, 128),\n        (64, 1.0, 0.25, 1.0, 1.0, 256),\n        (64, 2.0, 0.25, 1.0, 1.0, 256),\n        (128, 2.0, 0.25, 1.0, 1.0, 512),\n        (64, 4.0, 0.25, 1.0, 1.0, 256),\n    ]\n\n    results = []\n    for params in test_cases:\n        max_v = calculate_max_velocity(*params)\n        results.append(f\"{max_v:.8e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}