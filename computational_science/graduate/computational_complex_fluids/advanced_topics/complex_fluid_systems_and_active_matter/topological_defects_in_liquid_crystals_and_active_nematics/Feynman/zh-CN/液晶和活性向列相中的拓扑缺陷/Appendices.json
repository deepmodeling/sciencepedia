{
    "hands_on_practices": [
        {
            "introduction": "在研究拓扑缺陷时，首要的实践技能是可靠地识别和分类它们。拓扑荷是实现这一分类的基本不变量。本练习  将指导你设计一个稳健的算法，从离散的指向矢场数据中计算拓扑荷。你将学习如何通过构建一个对指向矢“无头”特性（即 $\\mathbf{n}$ 与 $-\\mathbf{n}$ 等价）保持不变的量，来克服计算中可能出现的伪影，这是分析模拟或实验数据的一项关键技术。",
            "id": "4110590",
            "problem": "给定一个单位导向矢量序列 $\\{\\mathbf{n}_i\\}_{i=0}^{N-1}$，该序列是在二维（2D）空间中沿一条有序闭合轮廓采样的。向列液晶中的导向场是无头的，意味着 $\\mathbf{n}$ 和 $-\\mathbf{n}$ 代表相同的物理状态。向错荷是导向矢方向绕轮廓的绕数，定义为沿闭合路径的导向角净变化量除以 $\\pi$。您的任务是设计并实现一个鲁棒的算法，从离散化的导向场计算向错荷，该算法需在由导向矢无头性引起的 $\\theta \\to \\theta + \\pi$ 等同变换下保持不变。\n\n使用的基本原理：\n- 导向场由单位矢量 $\\mathbf{n}_i = (\\cos\\theta_i, \\sin\\theta_i)$ 表示，其中 $\\theta_i$ 是导向矢的一个代表性角度，定义为模 $\\pi$。\n- 拓扑荷是导向角的绕数，从离散的角度增量计算得出，并且必须在等价关系 $\\theta \\sim \\theta + \\pi$ 下保持不变。\n\n约束与要求：\n- 您的算法计算绕数的方式必须在变换 $\\theta \\to \\theta + \\pi$（对应于翻转 $\\mathbf{n}_i \\to -\\mathbf{n}_i$）下保持不变。\n- 您的算法必须对小的角度噪声和导向矢符号的随机翻转具有鲁棒性。\n- 角度必须以弧度为单位处理。\n- 轮廓是闭合的，索引顺序 $\\{0,1,\\dots,N-1\\}$ 与弧长增加方向一致；您必须包含从最后一个样本回到第一个样本的增量以闭合回路。\n- 您必须使用所述基本原理，为每个测试用例生成最终的向错荷，结果为实数。\n\n测试套件：\n对每个测试用例，按如下方式构建导向矢样本。设 $\\alpha_i$ 为沿回路的极角参数，对于 $i = 0,1,\\dots,N-1$，$\\alpha_i$ 在 $[0,2\\pi)$ 区间内均匀分布。定义一个底层的导向角模型\n$$\n\\theta_i^{\\star} = \\theta_0 + \\frac{s^\\star}{2}\\,\\alpha_i + \\eta_i,\n$$\n其中 $s^\\star$ 是目标向错荷，$\\theta_0$ 是一个常数偏移量，$\\eta_i$ 是独立的、均值为零、标准差为 $\\sigma$ 的高斯噪声样本。导向矢样本则为\n$$\n\\mathbf{n}_i = \\sigma_i\\big(\\cos\\theta_i^{\\star}, \\sin\\theta_i^{\\star}\\big),\n$$\n其中 $\\sigma_i \\in \\{+1,-1\\}$ 代表独立的随机翻转，其概率为 $\\mathbb{P}(\\sigma_i=-1)=p_{\\mathrm{flip}}$，用以模拟导向矢的无头性。使用此构造方法，实现您的算法来计算每个测试用例的向错荷。\n\n使用以下参数集作为测试套件：\n- 用例 1：$N=128$, $s^\\star=0.5$, $\\theta_0=0.1$, $\\sigma=0.02$, $p_{\\mathrm{flip}}=0.3$。\n- 用例 2：$N=64$, $s^\\star=1.0$, $\\theta_0=-0.5$, $\\sigma=0.0$, $p_{\\mathrm{flip}}=0.0$。\n- 用例 3：$N=96$, $s^\\star=-0.5$, $\\theta_0=0.0$, $\\sigma=0.01$, $p_{\\mathrm{flip}}=0.5$。\n- 用例 4：$N=200$, $s^\\star=0.0$, $\\theta_0=1.2$, $\\sigma=0.05$, $p_{\\mathrm{flip}}=0.7$。\n- 用例 5：$N=3$, $s^\\star=-1.0$, $\\theta_0=0.0$, $\\sigma=0.0$, $p_{\\mathrm{flip}}=0.0$。\n\n角度单位必须是弧度。对每个用例，计算并返回向错荷，结果为浮点数，四舍五入到六位小数。\n\n最终输出格式：\n您的程序应生成单行输出，包含所有测试用例的结果，形式为方括号内以逗号分隔的列表，例如，“[result1,result2,result3,result4,result5]”。每个结果必须是浮点数，四舍五入到六位小数，不应打印额外的文本或空行。",
            "solution": "该问题要求从二维向列相系统中沿闭合回路的一组离散导向矢量计算向错荷（一个拓扑不变量）。向列导向场 $\\mathbf{n}$ 的决定性特征是其无头性，即由 $\\mathbf{n}$ 和 $-\\mathbf{n}$ 所代表的状态在物理上是不可区分的。这对应于角度等价关系 $\\theta \\sim \\theta + \\pi$，其中 $\\theta$ 是导向矢的取向角。向错荷 $s$ 定义为导向角绕轮廓的总绕数，并用 $\\pi$ 进行归一化：\n$$\ns = \\frac{1}{\\pi} \\oint d\\theta\n$$\n一种简单的方法是，从每个矢量 $\\mathbf{n}_i$ 计算角度 $\\theta_i$，然后对差值 $\\Delta\\theta_i = \\theta_{i+1} - \\theta_i$ 求和，但这种方法会失败。这是由于两个模糊性。首先，标准的反正切函数 $\\operatorname{atan2}$ 产生的角度在 $(-\\pi, \\pi]$ 区间内，会导致虚假的 $2\\pi$ 跳变。其次，每个导向矢量 $\\mathbf{n}_i$ 的随机且未知的符号会在角度序列中引入人为的 $\\pi$ 跳变。一个鲁棒的算法必须对这些因素保持不变。\n\n确保在变换 $\\mathbf{n} \\to -\\mathbf{n}$ 下不变性的原则性方法是处理一个与导向矢分量呈二次关系的量。向列相序参量，或称 $Q$-张量，提供了这样一种表示方法。在二维情况下，这可以简化为一个复数 $q$，其分量由导向矢量 $\\mathbf{n}_i = (n_{ix}, n_{iy})$ 构建：\n$$\nq_i = (n_{ix}^2 - n_{iy}^2) + i (2n_{ix}n_{iy})\n$$\n如果导向矢由单位矢量 $\\mathbf{n}_i = (\\cos\\theta_i, \\sin\\theta_i)$ 表示，其中 $\\theta_i$ 是矢量在平面中的角度，那么复数 $q_i$ 变为：\n$$\nq_i = (\\cos^2\\theta_i - \\sin^2\\theta_i) + i(2\\cos\\theta_i\\sin\\theta_i) = \\cos(2\\theta_i) + i\\sin(2\\theta_i) = e^{i2\\theta_i}\n$$\n这个复数的辐角是 $2\\theta_i$。关键在于，这种表示在导向矢翻转 $\\mathbf{n}_i \\to -\\mathbf{n}_i$ 的情况下是不变的。一次翻转对应于角度变化 $\\theta_i \\to \\theta_i + \\pi$。新的复数 $q'_i$ 将是：\n$$\nq'_i = e^{i2(\\theta_i + \\pi)} = e^{i2\\theta_i}e^{i2\\pi} = e^{i2\\theta_i} = q_i\n$$\n因此，通过将导向矢量序列 $\\{\\mathbf{n}_i\\}$ 转换为复数序列 $\\{q_i\\}$，我们消除了由导向矢无头性引起的模糊性。随机符号翻转和噪声的影响被隐式地处理了。\n\n计算向错荷 $s$ 的问题现在转化为求解倍角 $2\\theta$ 的总绕数。沿回路 $2\\theta$ 的总变化量为 $\\Delta\\Phi_{\\text{total}} = \\oint d(2\\theta)$。荷 $s$ 与此总变化量之间的关系是：\n$$\ns = \\frac{1}{\\pi} \\oint d\\theta = \\frac{1}{2\\pi} \\oint d(2\\theta) = \\frac{\\Delta\\Phi_{\\text{total}}}{2\\pi}\n$$\n对于闭合轮廓上的离散样本集 $\\{q_i\\}_{i=0}^{N-1}$，该积分可以用有限增量的总和来近似：\n$$\n\\Delta\\Phi_{\\text{total}} \\approx \\sum_{i=0}^{N-1} \\Delta\\Phi_i\n$$\n其中 $\\Delta\\Phi_i$ 是 $q_i$ 与下一个样本 $q_{i+1}$ 之间的角度变化（通过取 $q_N=q_0$ 来闭合回路）。为避免相位缠绕问题，此增量通过计算复数比值的辐角来鲁棒地计算：\n$$\n\\Delta\\Phi_i = \\arg\\left(\\frac{q_{i+1}}{q_i}\\right) = \\arg(q_{i+1}\\bar{q}_i)\n$$\n其中 $\\bar{q}_i$ 是 $q_i$ 的复共轭。由于对所有 $i$ 都有 $|q_i|=1$，这简化了除法。这个辐角通常通过 $\\operatorname{atan2}(\\text{Im}(z), \\text{Re}(z))$ 计算，自然地产生一个在 $(-\\pi, \\pi]$ 范围内的值。这个过程正确地测量了连续 $q$ 矢量之间的最短角度，并且只要样本之间 $2\\theta$ 的真实变化量在量级上不超过 $\\pi$，它就是鲁棒的，这个条件在所有测试用例中提供的采样密度下都成立。\n\n最终的算法如下：\n1.  对每个测试用例，根据指定的模型生成导向矢量序列 $\\{\\mathbf{n}_i\\}_{i=0}^{N-1}$，包括噪声和随机符号翻转。\n2.  对每个矢量 $\\mathbf{n}_i = (n_{ix}, n_{iy})$，计算相应的复数表示 $q_i = (n_{ix}^2 - n_{iy}^2) + i(2n_{ix}n_{iy})$。\n3.  计算倍角的增量变化 $\\Delta\\Phi_i = \\arg(q_{i+1}\\bar{q}_i)$，对于 $i=0, \\dots, N-1$，其中 $q_N=q_0$。\n4.  将这些增量求和以找到总变化量：$\\Delta\\Phi_{\\text{total}} = \\sum_{i=0}^{N-1} \\Delta\\Phi_i$。\n5.  使用公式 $s = \\frac{\\Delta\\Phi_{\\text{total}}}{2\\pi}$ 计算向错荷。\n6.  按要求将最终值四舍五入到六位小数。\n使用单个随机数生成器种子以确保测试数据的随机生成是可复现的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_charge_for_case(N, s_star, theta_0, sigma, p_flip, rng):\n    \"\"\"\n    Generates director field data for a test case and computes the disclination charge.\n\n    Args:\n        N (int): Number of samples on the contour.\n        s_star (float): The target disclination charge.\n        theta_0 (float): A constant angle offset.\n        sigma (float): Standard deviation of Gaussian noise on the angle.\n        p_flip (float): Probability of a director sign flip.\n        rng (numpy.random.Generator): Random number generator instance.\n\n    Returns:\n        float: The computed disclination charge.\n    \"\"\"\n    # 1. Generate director field data\n    # Generate polar angles uniformly spaced around a circle.\n    alpha = np.linspace(0, 2 * np.pi, N, endpoint=False)\n    \n    # Generate Gaussian noise for the director angle.\n    eta = rng.normal(loc=0.0, scale=sigma, size=N)\n    \n    # Create the underlying smooth director angle field.\n    theta_star = theta_0 + (s_star / 2.0) * alpha + eta\n    \n    # Introduce random sign flips to simulate the headless director nature.\n    flips = rng.choice([-1, 1], size=N, p=[p_flip, 1 - p_flip])\n    \n    # Construct the director vectors.\n    nx = flips * np.cos(theta_star)\n    ny = flips * np.sin(theta_star)\n    \n    # 2. Compute the complex tensor order parameter q = exp(i*2*theta)\n    # This representation is invariant under n -> -n.\n    # Re(q) = nx^2 - ny^2 = cos(2*theta)\n    # Im(q) = 2*nx*ny   = sin(2*theta)\n    q = (nx**2 - ny**2) + 1j * (2 * nx * ny)\n\n    # 3. Calculate phase differences between adjacent q-vectors\n    # Use np.roll to get the next element in the sequence, closing the loop.\n    q_next = np.roll(q, -1)\n    \n    # The ratio q_next/q gives the rotation. Since |q|=1, this is q_next * conj(q).\n    delta_q = q_next * np.conj(q)\n    \n    # np.angle() computes the argument, which is the change in the doubled angle (2*theta),\n    # correctly wrapped to the interval (-pi, pi].\n    delta_phi = np.angle(delta_q)\n    \n    # 4. Sum the phase differences and calculate the charge\n    # The total phase change of 2*theta is the sum of increments.\n    total_delta_phi = np.sum(delta_phi)\n    \n    # The disclination charge s = (total change in theta) / pi\n    # which is equivalent to (total change in 2*theta) / (2*pi).\n    charge = total_delta_phi / (2.0 * np.pi)\n    \n    return charge\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # A fixed seed ensures that the noise and flips are the same for each run,\n    # leading to a reproducible result. The problem does not specify a seed,\n    # so a standard value of 0 is chosen.\n    rng = np.random.default_rng(0) \n\n    test_cases = [\n        # (N, s_star, theta_0, sigma, p_flip)\n        (128, 0.5, 0.1, 0.02, 0.3),\n        (64, 1.0, -0.5, 0.0, 0.0),\n        (96, -0.5, 0.0, 0.01, 0.5),\n        (200, 0.0, 1.2, 0.05, 0.7),\n        (3, -1.0, 0.0, 0.0, 0.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, s_star, theta_0, sigma, p_flip = case\n        charge = compute_charge_for_case(N, s_star, theta_0, sigma, p_flip, rng)\n        # Round the final result to six decimal places as required.\n        results.append(round(charge, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "识别缺陷之后，下一步是理解其内部结构。Landau-de Gennes 理论为描述缺陷芯内部及周围向列序参量的变化提供了一个强大的连续介质框架。这项综合性练习  将引导你从理论推导出发，最终实现一个数值求解器，以模拟静态缺陷的完整序参量张量场。通过这个实践，你将把抽象的变分原理直接应用于计算问题，从而获得对缺陷芯（指向矢序在此处“熔化”）具体而直观的理解。",
            "id": "4110587",
            "problem": "考虑向列相液晶的 Landau–de Gennes 理论。向列相状态由对称、无迹的二阶序参量张量 $Q_{ij}(\\mathbf{x})$ 表征，其 Landau–de Gennes 自由能泛函为\n$$\nF[Q] = \\int_{\\Omega} \\left( A\\,\\mathrm{Tr}\\,Q^2 - B\\,\\mathrm{Tr}\\,Q^3 + C\\,(\\mathrm{Tr}\\,Q^2)^2 + L\\,\\partial_k Q_{ij}\\,\\partial_k Q_{ij} \\right)\\, dV,\n$$\n其中 $A$、 $B$、 $C$ 和 $L$ 是材料参数，$\\partial_k Q_{ij}$ 表示空间导数，$\\Omega \\subset \\mathbb{R}^2$ 是一个二维区域。假设采用单弹性常数近似（即只有一个弹性常数 $L$），并忽略任何流体动力学流动。\n\n任务 1. 从泛函 $F[Q]$ 出发，在对称、无迹张量空间中使用变分法，推导 $Q_{ij}(\\mathbf{x})$ 的 Euler–Lagrange 方程。你的推导必须从平稳性的基本定义 $\\delta F = 0$ 开始，其中变分 $\\delta Q_{ij}$ 是紧支撑的。推导过程需强制执行对称性和无迹约束，并展示在静态平衡时必须为零的体“分子场”的形式。不要使用快捷公式；应通过标准的张量微积分恒等式（如 $\\delta\\,\\mathrm{Tr}\\,Q^2 = 2\\,Q_{ij}\\,\\delta Q_{ij}$）对每一项进行变分来推导结果，并在适当的边界条件下，通过分部积分仔细处理梯度项。\n\n任务 2. 将问题限制在二维平面纹理中，其中 $Q_{ij}$ 是一个 $2\\times 2$ 的对称无迹张量，并使用标量序参量 $S(\\mathbf{x}) \\ge 0$ 和指向矢角 $\\theta(\\mathbf{x})$ 对场进行参数化，即 $Q_{ij} = S\\left(n_i n_j - \\delta_{ij}/2\\right)$，其中 $\\mathbf{n}=(\\cos\\theta,\\sin\\theta)$。推导以 $S$ 和 $\\theta$ 表示的简化自由能密度，并导出 $S(\\mathbf{x})$ 和 $\\theta(\\mathbf{x})$ 的耦合 Euler–Lagrange 方程。然后，对于位于原点的拓扑荷为 $s$ 的点缺陷，在极坐标 $(r,\\phi)$ 中，假设 $\\theta(\\mathbf{x}) = s\\,\\phi$ 和 $S = S(r)$。推导 $S(r)$ 的常微分方程，并给出具有物理动机的边界条件，这些条件确保缺陷核是有限的，并且在远离缺陷处恢复到体相值 $S_0$。角度使用弧度制。在无量纲单位下进行计算，长度以网格单位度量。\n\n任务 3. 实现一个数值求解器，通过对二维 Landau–de Gennes 全泛函直接进行 $L^2$-梯度下降，计算对称、无迹 $2\\times 2$ 张量 $Q(\\mathbf{x})$ 在二维空间中的静态缺陷解，而无需显式地简化为标量序参量方程。使用间距为 1（无量纲网格单位）的方形网格，在区域中心初始化一个具有光滑核剖面的荷为 $s$ 的缺陷，并固定边界值以维持所施加的缺陷拓扑。使用二阶中心差分对分子场和拉普拉斯算子进行离散化，并通过边缘复制处理齐次 Neumann 边界条件。迭代显式梯度下降，直到达到静态。\n\n将标量序参量场定义为 $S(\\mathbf{x}) = 2\\,\\sqrt{q_{11}^2(\\mathbf{x}) + q_{12}^2(\\mathbf{x})}$，其中 $Q(\\mathbf{x}) = \\begin{pmatrix} q_{11}  q_{12} \\\\ q_{12}  -q_{11} \\end{pmatrix}$。将体标量序 $S_0$ 定义为从二维泛函的体部分获得的非零均匀静态解。将核半径 $r_c$ 定义为最小的半径 $r$（以网格单位计），在该半径的圆周上（绕缺陷中心），$S$ 的方位角平均值大于或等于 $S_0/2$。\n\n你的程序必须：\n- 使用无量纲参数和弧度制角度。\n- 在具有固定边界值的方形网格上求解完整的 $Q$ 张量梯度下降，并通过环形平均计算 $r_c$。\n- 以浮点数形式生成数值答案。\n\n测试套件。为以下四个参数集 $(A,B,C,L,s,N,\\text{iterations},\\Delta t)$ 运行你的求解器，其中 $N$ 是网格大小，“iterations”是梯度下降的步数，$\\Delta t$ 是显式时间步长：\n1. $(-1.0, 0.0, 1.0, 0.02, 0.5, 64, 800, 0.05)$\n2. $(-1.0, 0.0, 1.0, 0.02, -0.5, 64, 800, 0.05)$\n3. $(-1.0, 0.0, 1.0, 0.02, 0.0, 64, 800, 0.05)$\n4. $(-1.0, 0.0, 1.0, 0.05, 0.5, 64, 800, 0.05)$\n\n最终输出格式。你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，每个核半径都四舍五入到三位小数（以无量纲网格单位计），并按上述顺序列出（例如，“[0.750,0.745,0.000,1.120]”）。",
            "solution": "该问题定义明确，并以成熟的向列相液晶 Landau–de Gennes 理论为科学基础。它为推导控制方程和实现拓扑缺陷的数值解提供了一套完整的任务。所提供的参数和定义是标准的，足以得到唯一且有意义的解。\n\n### 任务 1：Euler–Lagrange 方程的推导\n\nLandau–de Gennes 自由能泛函由下式给出：\n$$\nF[Q] = \\int_{\\Omega} f(Q_{ij}, \\partial_k Q_{ij}) \\, dV\n$$\n其中自由能密度 $f$ 为：\n$$\nf = A\\,\\mathrm{Tr}(Q^2) - B\\,\\mathrm{Tr}(Q^3) + C\\,(\\mathrm{Tr}(Q^2))^2 + L\\,(\\partial_k Q_{ij})(\\partial_k Q_{ij})\n$$\n在此，$Q_{ij}$ 是一个对称（$Q_{ij} = Q_{ji}$）且无迹（$\\mathrm{Tr}(Q) = Q_{kk} = 0$）的张量。我们通过寻找条件 $\\delta F = 0$ 来求解静态平衡态，其中 $\\delta Q_{ij}$ 是一个任意的、满足相同对称性和无迹性约束（$\\delta Q_{ij} = \\delta Q_{ji}$ 和 $\\delta Q_{kk} = 0$）的紧支撑变分。\n\n泛函的变分为 $\\delta F = \\int_{\\Omega} \\delta f \\, dV$。我们计算密度 $f$ 中每一项的变分：\n\n1.  **第一项**：\n    $\\delta(A\\,\\mathrm{Tr}(Q^2)) = A\\,\\delta(Q_{ij}Q_{ji}) = A\\,(\\delta Q_{ij} Q_{ji} + Q_{ij} \\delta Q_{ji})$。对第二部分进行指标切换（$j \\to i, i \\to j$）并利用 $Q$ 和 $\\delta Q$ 的对称性，此式变为 $A\\,(Q_{ji}\\delta Q_{ij} + Q_{ji}\\delta Q_{ij}) = 2A\\,Q_{ji}\\delta Q_{ij} = 2A\\,Q_{ij}\\delta Q_{ij}$。\n\n2.  **第二项**：\n    $\\delta(-B\\,\\mathrm{Tr}(Q^3)) = -B\\,\\delta(Q_{ij}Q_{jk}Q_{ki})$。应用乘法法则得到三个相同的项：$-B\\,(\\delta Q_{ij} Q_{jk} Q_{ki} + Q_{ij} \\delta Q_{jk} Q_{ki} + Q_{ij} Q_{jk} \\delta Q_{ki})$。通过重新标记指标，这三项都可以写成 $-(Q^2)_{li}\\delta Q_{il}$ 的形式。总和为 $-3B\\,(Q^2)_{ji}\\delta Q_{ij} = -3B\\,(Q^2)_{ij}\\delta Q_{ij}$。\n\n3.  **第三项**：\n    $\\delta(C\\,(\\mathrm{Tr}(Q^2))^2) = C \\cdot 2\\,\\mathrm{Tr}(Q^2) \\cdot \\delta(\\mathrm{Tr}(Q^2))$。我们已经得到 $\\delta(\\mathrm{Tr}(Q^2)) = 2\\,Q_{ij}\\delta Q_{ij}$。因此，该项的变分为 $4C\\,\\mathrm{Tr}(Q^2)\\,Q_{ij}\\delta Q_{ij}$。\n\n4.  **第四项（弹性项）**：\n    $\\delta(L\\,\\partial_k Q_{ij} \\partial_k Q_{ij}) = 2L\\,(\\partial_k Q_{ij}) \\delta(\\partial_k Q_{ij}) = 2L\\,(\\partial_k Q_{ij}) \\partial_k(\\delta Q_{ij})$。为了从变分 $\\delta Q_{ij}$ 中移除导数，我们对体积进行分部积分：\n    $$\n    \\int_{\\Omega} 2L\\,(\\partial_k Q_{ij}) \\partial_k(\\delta Q_{ij}) \\, dV = \\int_{\\Omega} \\partial_k(2L\\,(\\partial_k Q_{ij}) \\delta Q_{ij}) \\, dV - \\int_{\\Omega} 2L\\,(\\partial_k \\partial_k Q_{ij}) \\delta Q_{ij} \\, dV\n    $$\n    根据散度定理，第一项是边界 $\\partial\\Omega$ 上的面积分。由于 $\\delta Q_{ij}$ 具有紧支撑（或在边界上为零），该面积分项为零。剩下的项是 $-\\int_{\\Omega} 2L\\,\\nabla^2 Q_{ij} \\delta Q_{ij} \\, dV$。\n\n合并所有项，总变分为：\n$$\n\\delta F = \\int_{\\Omega} \\left( [2AQ_{ij} - 3B(Q^2)_{ij} + 4C\\,\\mathrm{Tr}(Q^2)\\,Q_{ij}] - 2L\\nabla^2 Q_{ij} \\right) \\delta Q_{ij} \\, dV = 0\n$$\n为了使该积分对于任何允许的变分 $\\delta Q_{ij}$ 都为零，乘以 $\\delta Q_{ij}$ 的张量表达式必须具有这样一种形式，即它与任何对称无迹张量的缩并都为零。这意味着该表达式本身必须是一个形式为 $\\lambda \\delta_{ij}$ 的对称张量，其中 $\\lambda(\\mathbf{x})$ 是一个标量拉格朗日乘子场，用于强制执行无迹约束。该表达式已经是​​对称的，所以我们有：\n$$\n2AQ_{ij} - 3B(Q^2)_{ij} + 4C\\,\\mathrm{Tr}(Q^2)\\,Q_{ij} - 2L\\nabla^2 Q_{ij} = \\lambda\\delta_{ij}\n$$\n为了求出 $\\lambda$，我们取等式两边的迹。在 $d$ 维空间中，$\\mathrm{Tr}(\\delta_{ij}) = d$。\n$$\n2A\\,\\mathrm{Tr}(Q) - 3B\\,\\mathrm{Tr}(Q^2) + 4C\\,\\mathrm{Tr}(Q^2)\\,\\mathrm{Tr}(Q) - 2L\\nabla^2(\\mathrm{Tr}(Q)) = \\lambda d\n$$\n使用约束条件 $\\mathrm{Tr}(Q) = 0$，上式简化为 $-3B\\,\\mathrm{Tr}(Q^2) = \\lambda d$，从而得到 $\\lambda = -\\frac{3B}{d}\\mathrm{Tr}(Q^2)$。\n\n将 $\\lambda$ 代回即可得到 Euler-Lagrange 方程。通常通过定义**分子场** $H_{ij} = -\\frac{\\delta F_{\\text{bulk}}}{\\delta Q_{ij}}$ 来表示，它是自由能的体（非梯度）部分的变分导数：\n$$\nH_{ij} = -\\left( 2AQ_{ij} - 3B(Q^2)_{ij} + 4C\\,\\mathrm{Tr}(Q^2)\\,Q_{ij} \\right)\n$$\n完整的平衡方程则为 $H_{ij} - (\\mathrm{Tr}(H)/d)\\delta_{ij} - 2L\\nabla^2 Q_{ij} = 0$，简化后为：\n$$\n2L\\nabla^2 Q_{ij} = -\\left( 2AQ_{ij} - 3B\\left((Q^2)_{ij} - \\frac{1}{d}\\mathrm{Tr}(Q^2)\\delta_{ij}\\right) + 4C\\,\\mathrm{Tr}(Q^2)\\,Q_{ij} \\right)\n$$\n在静态平衡时必须为零的张量表达式是完整的对称无迹分子场，包括弹性部分：\n$$\n\\mathcal{H}_{ij} = \\left( 2AQ_{ij} - 3B(Q^2)_{ij}^{ST} + 4C\\,\\mathrm{Tr}(Q^2)Q_{ij} - 2L\\nabla^2 Q_{ij} \\right)^{ST} = 0\n$$\n其中上标 'ST' 表示张量的对称无迹部分，即 $T^{ST}_{ij} = \\frac{1}{2}(T_{ij}+T_{ji}) - \\frac{1}{d}T_{kk}\\delta_{ij}$。\n\n### 任务 2：二维平面缺陷的简化理论\n\n在二维空间（$d=2$）中，一个对称无迹张量 $Q$ 可以通过标量序参量 $S(\\mathbf{x}) \\ge 0$ 和指向矢角 $\\theta(\\mathbf{x})$ 进行参数化：\n$$\nQ_{ij} = S \\left( n_i n_j - \\frac{1}{2}\\delta_{ij} \\right) \\quad \\text{其中 } \\mathbf{n} = (\\cos\\theta, \\sin\\theta)\n$$\n其矩阵形式为 $Q = \\frac{S}{2} \\begin{pmatrix} \\cos(2\\theta)  \\sin(2\\theta) \\\\ \\sin(2\\theta)  -\\cos(2\\theta) \\end{pmatrix} = \\begin{pmatrix} q_{11}  q_{12} \\\\ q_{12}  -q_{11} \\end{pmatrix}$。这给出了关系式 $q_{11} = \\frac{S}{2}\\cos(2\\theta)$ 和 $q_{12} = \\frac{S}{2}\\sin(2\\theta)$。\n不变量为：\n$\\mathrm{Tr}(Q^2) = Q_{ij}Q_{ji} = 2(q_{11}^2 + q_{12}^2) = 2 \\left( (\\frac{S}{2})^2 \\cos^2(2\\theta) + (\\frac{S}{2})^2 \\sin^2(2\\theta) \\right) = \\frac{S^2}{2}$。\n在二维中 $\\mathrm{Tr}(Q^3) = 0$。因此系数为 $B$ 的项消失。\n\n体自由能密度简化为：\n$$\nf_{\\text{bulk}}(S) = A\\left(\\frac{S^2}{2}\\right) + C\\left(\\frac{S^2}{2}\\right)^2 = \\frac{A}{2}S^2 + \\frac{C}{4}S^4\n$$\n弹性自由能密度为 $f_{\\text{el}} = L \\partial_k Q_{ij} \\partial_k Q_{ij} = L \\sum_{i,j,k} (\\partial_k Q_{ij})^2 = 2L \\sum_k ((\\partial_k q_{11})^2 + (\\partial_k q_{12})^2)$。\n计算导数：\n$\\partial_k q_{11} = \\frac{1}{2}(\\partial_k S \\cos(2\\theta) - 2S \\sin(2\\theta) \\partial_k \\theta)$\n$\\partial_k q_{12} = \\frac{1}{2}(\\partial_k S \\sin(2\\theta) + 2S \\cos(2\\theta) \\partial_k \\theta)$\n将其平方求和后简化为：$(\\partial_k q_{11})^2 + (\\partial_k q_{12})^2 = \\frac{1}{4}((\\partial_k S)^2 + 4S^2(\\partial_k\\theta)^2)$。\n弹性密度变为：$f_{\\text{el}} = 2L \\sum_k \\frac{1}{4}((\\partial_k S)^2 + 4S^2(\\partial_k\\theta)^2) = \\frac{L}{2}(|\\nabla S|^2 + 4S^2|\\nabla\\theta|^2)$。\n\n总的简化自由能密度为 $f(S, \\theta) = \\frac{A}{2}S^2 + \\frac{C}{4}S^4 + \\frac{L}{2}|\\nabla S|^2 + 2LS^2|\\nabla\\theta|^2$。\n$S$ 和 $\\theta$ 的 Euler-Lagrange 方程为：\n对于 $S$：$\\frac{\\partial f}{\\partial S} - \\nabla \\cdot \\frac{\\partial f}{\\partial(\\nabla S)} = 0 \\implies AS + CS^3 + 4LS|\\nabla\\theta|^2 - L\\nabla^2 S = 0$。\n对于 $\\theta$：$\\frac{\\partial f}{\\partial \\theta} - \\nabla \\cdot \\frac{\\partial f}{\\partial(\\nabla \\theta)} = 0 \\implies 0 - \\nabla \\cdot (4LS^2\\nabla\\theta) = 0 \\implies \\nabla \\cdot (S^2\\nabla\\theta) = 0$。\n\n对于位于原点的荷为 $s$ 的点缺陷，我们假设 $\\theta(\\mathbf{x}) = s\\phi$ 且 $S=S(r)$，其中 $(r,\\phi)$ 是极坐标。\n在极坐标中，$\\nabla S = S'(r)\\hat{\\mathbf{r}}$ 以及 $\\nabla\\theta = s\\nabla\\phi = s \\frac{1}{r}\\hat{\\boldsymbol{\\phi}}$ 以及 $\\nabla^2 S = S'' + \\frac{1}{r}S'$。\n$\\theta$ 的方程自动满足，因为 $\\nabla \\cdot (S(r)^2 \\frac{s}{r}\\hat{\\boldsymbol{\\phi}}) = \\frac{s}{r} \\frac{\\partial}{\\partial\\phi} (\\frac{S(r)^2}{r}) = 0$。\n代入 $S$ 的方程，得到径向剖面 $S(r)$ 的常微分方程（ODE）：\n$$\nL\\left(S'' + \\frac{1}{r}S'\\right) = AS + CS^3 + 4LS^2 \\frac{s^2}{r^2} \\implies L\\left(S'' + \\frac{1}{r}S'\\right) - \\frac{4Ls^2S}{r^2} = AS + CS^3\n$$\n边界条件为：\n1.  **核：** $S(r \\to 0) = 0$。在指向矢未定义的缺陷核处，序参量必须为零，以确保弹性自由能是有限的。\n2.  **远场：** $S(r \\to \\infty) = S_0 = \\sqrt{-A/C}$。远离缺陷处，系统必须弛豫到均匀的体平衡态，该状态使 $f_{\\text{bulk}}(S)$ 最小化。\n\n### 任务 3：数值实现设计\n\n该求解器将实现一个 $L^2$-梯度下降方案，以在二维网格上最小化完整的 Landau-de Gennes 泛函。这对应于求解含时方程 $\\partial Q_{ij}/\\partial t = -\\delta F / \\delta Q_{ij}$，其中 $-\\delta F / \\delta Q_{ij}$ 充当将系统驱动到较低能量状态的“力”。对于给定的二维泛函且 $B=0$ 的情况，演化方程显著简化。如任务 1 所示，拉格朗日乘子项恒为零。$Q$ 的两个独立分量的方程变为：\n$$\n\\frac{\\partial q_{11}}{\\partial t} = -\\left(2Aq_{11} + 4C(\\mathrm{Tr}Q^2)q_{11}\\right) + 2L\\nabla^2 q_{11}\n$$\n$$\n\\frac{\\partial q_{12}}{\\partial t} = -\\left(2Aq_{12} + 4C(\\mathrm{Tr}Q^2)q_{12}\\right) + 2L\\nabla^2 q_{12}\n$$\n其中 $\\mathrm{Tr}(Q^2) = 2(q_{11}^2 + q_{12}^2)$。\n\n-   **离散化：** 模拟区域是一个 $N \\times N$ 的网格，间距为 $\\Delta x = \\Delta y = 1.0$。拉普拉斯算子 $\\nabla^2$ 使用二阶五点中心差分格式进行近似。\n-   **初始状态：** 在网格中心初始化一个荷为 $s$ 的缺陷。角度场设置为 $\\theta(x,y) = s \\cdot \\arctan_2(y,x)$。标量序参量被赋予一个光滑的剖面 $S(r) = S_0 \\tanh(r/r_{\\text{init}})$，该剖面在中心处为零，并在远处饱和到体相值 $S_0$，其中 $r_{\\text{init}}$ 是核尺寸的初始猜测值。\n-   **边界条件：** 为保持总拓扑荷，网格边界上的 $Q_{ij}$ 值被固定为其初始值（狄利克雷边界条件）。梯度下降更新仅应用于内部网格点。邻近边界点的拉普拉斯算子自然地包含了固定的边界值。\n-   **时间积分：** 使用简单的前向显式欧拉法：$Q^{t+\\Delta t} = Q^t + \\Delta t \\cdot (\\partial Q/\\partial t)|_t$。\n-   **核半径测量：** 弛豫过程收敛后，计算最终的标量序参量场 $S(\\mathbf{x}) = 2\\sqrt{q_{11}^2 + q_{12}^2}$。通过计算同心环带中 $S$ 的方位角平均值来确定核半径 $r_c$。具体方法是：按网格点到中心的整数距离进行分组，计算每个组中 $S$ 的平均值，并找到使该平均值 $\\ge S_0/2$ 的最小半径 $r$。对于 $s=0$ 的情况，系统弛豫到 $S=S_0$ 的均匀状态，因此核半径显然为 $0$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for defect relaxation and print results.\n    \"\"\"\n    \n    test_cases = [\n        # (A, B, C, L, s, N, iterations, dt)\n        (-1.0, 0.0, 1.0, 0.02, 0.5, 64, 800, 0.05),\n        (-1.0, 0.0, 1.0, 0.02, -0.5, 64, 800, 0.05),\n        (-1.0, 0.0, 1.0, 0.02, 0.0, 64, 800, 0.05),\n        (-1.0, 0.0, 1.0, 0.05, 0.5, 64, 800, 0.05),\n    ]\n\n    results = []\n    for params in test_cases:\n        rc = solve_defect_relaxation(*params)\n        results.append(f\"{rc:.3f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef solve_defect_relaxation(A, B, C, L, s, N, iterations, dt):\n    \"\"\"\n    Computes the core radius of a nematic defect by relaxing the Q-tensor field\n    using L2-gradient descent on the Landau-de Gennes free energy.\n\n    Args:\n        A, B, C, L: Material parameters in the Landau-de Gennes functional.\n        s: Topological charge of the defect.\n        N: Grid size (N x N).\n        iterations: Number of gradient descent steps.\n        dt: Time step for the explicit Euler method.\n\n    Returns:\n        The calculated defect core radius in grid units.\n    \"\"\"\n    # Grid setup (grid spacing h=1 is assumed)\n    grid_coords = np.arange(N, dtype=float) - (N - 1) / 2.0\n    xx, yy = np.meshgrid(grid_coords, grid_coords)\n    \n    # Calculate bulk order parameter S0\n    if C == 0 or -A / C  0:\n        S0 = 0.0\n    else:\n        S0 = np.sqrt(-A / C)\n\n    # Initial condition: defect of charge 's' at the center\n    # Polar coordinates\n    rr = np.sqrt(xx**2 + yy**2)\n    phi = np.arctan2(yy, xx)\n\n    # Defect angle profile\n    theta = s * phi\n    \n    # Smooth core profile using tanh function\n    # A reasonable initial core size prevents extreme gradients at the start.\n    r_init = 5.0\n    S_init = S0 * np.tanh(rr / r_init)\n    \n    # Initialize Q-tensor components q11 and q12\n    # Q = [[q11, q12], [q12, -q11]]\n    q11 = (S_init / 2.0) * np.cos(2 * theta)\n    q12 = (S_init / 2.0) * np.sin(2 * theta)\n    \n    # Time evolution via L2-gradient descent\n    for _ in range(iterations):\n        # Calculate Tr(Q^2) = 2 * (q11^2 + q12^2)\n        TrQ2 = 2 * (q11**2 + q12**2)\n        \n        # dQ/dt = -(dF/dQ_bulk) + 2L*nabla^2(Q)\n        # For B=0, dF/dQ_bulk = 2AQ + 4C(TrQ^2)Q\n        h_bulk_11 = -(2 * A * q11 + 4 * C * TrQ2 * q11)\n        h_bulk_12 = -(2 * A * q12 + 4 * C * TrQ2 * q12)\n        \n        # Calculate Laplacian using second-order central differences (h=1)\n        # Fixed boundary conditions mean we only compute and update on interior.\n        lap_q11 = np.zeros_like(q11)\n        lap_q12 = np.zeros_like(q12)\n        \n        lap_q11[1:-1, 1:-1] = (q11[0:-2, 1:-1] + q11[2:, 1:-1] + \n                               q11[1:-1, 0:-2] + q11[1:-1, 2:] - 4 * q11[1:-1, 1:-1])\n        lap_q12[1:-1, 1:-1] = (q12[0:-2, 1:-1] + q12[2:, 1:-1] + \n                               q12[1:-1, 0:-2] + q12[1:-1, 2:] - 4 * q12[1:-1, 1:-1])\n\n        # Explicit Euler time step for interior points\n        q11[1:-1, 1:-1] += dt * (h_bulk_11[1:-1, 1:-1] + 2 * L * lap_q11[1:-1, 1:-1])\n        q12[1:-1, 1:-1] += dt * (h_bulk_12[1:-1, 1:-1] + 2 * L * lap_q12[1:-1, 1:-1])\n\n    # Post-simulation analysis\n    # For s=0, the system relaxes to a uniform state. The \"core\" has zero size.\n    if s == 0:\n        return 0.0\n        \n    # Calculate final scalar order parameter field S(x, y) = 2 * sqrt(q11^2 + q12^2)\n    S_final = 2 * np.sqrt(q11**2 + q12**2)\n    \n    # Calculate core radius r_c\n    S_thresh = S0 / 2.0\n    \n    # Bin S values by their integer radius from the center\n    r_int = np.floor(rr).astype(int)\n    max_r = np.max(r_int)\n    \n    # Flatten arrays for use with np.bincount\n    r_flat = r_int.flatten()\n    S_flat = S_final.flatten()\n    \n    # Calculate sum and count in each radial bin for averaging\n    sum_S_by_r = np.bincount(r_flat, weights=S_flat, minlength=max_r + 1)\n    counts = np.bincount(r_flat, minlength=max_r + 1)\n    \n    # Calculate the azimuthal average S for each integer radius\n    avg_S_by_r = np.zeros(max_r + 1, dtype=float)\n    # Avoid division by zero for bins that may not contain any grid points\n    nonzero_counts = counts > 0\n    avg_S_by_r[nonzero_counts] = sum_S_by_r[nonzero_counts] / counts[nonzero_counts]\n    \n    # Find the smallest radius where the average S meets the threshold S0/2\n    passing_radii_indices = np.where(avg_S_by_r >= S_thresh)[0]\n    \n    if len(passing_radii_indices) == 0:\n        # Fallback if no radius meets threshold (e.g., core > domain size)\n        return float(max_r)\n        \n    core_radius = float(passing_radii_indices[0])\n    \n    return core_radius\n\nsolve()\n```"
        },
        {
            "introduction": "在活性物质中，拓扑缺陷扮演着全新的角色，它们能够自驱动并产生持续的流体流动。本练习  将带你从静态系统进入活性向列相的动态世界。你将学习如何将活性应力的理论模型与可观测数据联系起来，通过模拟分析由缺陷产生的速度场（类似于粒子图像测速技术 PIV 所获得的数据）。你的任务是将这些合成数据与远场解析解进行拟合，从而估算材料的活性系数 $\\zeta$，这是表征活性系统特性的关键一步。",
            "id": "4110674",
            "problem": "考虑一个二维活性向列相，其中有一个孤立的移动 $+1/2$ 缺陷嵌入在不可压缩的粘性流体中。远场流体动力学由包含活性应力的稳态斯托克斯方程控制，即 $ \\eta \\nabla^2 \\mathbf{v} - \\nabla p + \\nabla \\cdot \\boldsymbol{\\sigma}^{\\mathrm{a}} = \\mathbf{0} $，以及不可压缩条件 $ \\nabla \\cdot \\mathbf{v} = 0 $，其中 $ \\eta $ 是动力粘度，$ p $ 是压力，活性应力由 $ \\boldsymbol{\\sigma}^{\\mathrm{a}} = -\\zeta \\mathbf{Q} $ 给出。张量 $ \\mathbf{Q} $ 是二维向列相序张量 $ \\mathbf{Q} = S(\\mathbf{n}\\mathbf{n} - \\mathbf{I}/2) $，其中 $ S $ 是标量序参数，$ \\mathbf{n} $ 是指向矢。粒子图像测速技术（PIV）提供了平面上位置 $ \\mathbf{x}_k $ 处速度场 $ \\mathbf{v}(\\mathbf{x}_k) $ 的离散采样。\n\n在 $+1/2$ 缺陷的远场中，$ \\mathbf{n} $ 的对称性意味着存在一个极性方向 $ \\hat{\\mathbf{p}} $（单位向量）及其正交方向 $ \\hat{\\mathbf{p}}_{\\perp} $，并且活性驱动力 $ \\nabla \\cdot \\boldsymbol{\\sigma}^{\\mathrm{a}} $ 可以粗粒化为一个与 $ \\hat{\\mathbf{p}} $ 对齐的有效应力子。使用二维稳态斯托克斯流的格林函数表示，所得速度场与活性参数 $ \\zeta $呈线性关系。在一个科学上一致且计算上易于处理的近似中，该远场速度可以建模为\n$$\n\\mathbf{v}_{\\mathrm{model}}(\\mathbf{x}) \\equiv \\frac{C S \\zeta}{\\eta r}\\left[\\cos(\\theta - \\theta_p)\\,\\hat{\\mathbf{p}} + \\beta \\sin(\\theta - \\theta_p)\\,\\hat{\\mathbf{p}}_{\\perp}\\right],\n$$\n其中 $ C $ 是一个已知的无量纲预因子，$ \\beta $ 是一个已知的无量纲涡旋系数，用于捕捉次要的各向异性贡献，$ r = \\|\\mathbf{x}\\| $ 是到缺陷核心的径向距离，$ \\theta $ 是 $ \\mathbf{x} $ 的极角，$ \\theta_p $ 是缺陷极性 $ \\hat{\\mathbf{p}} = (\\cos\\theta_p, \\sin\\theta_p) $ 的方向角，其中 $ \\hat{\\mathbf{p}}_{\\perp} = (-\\sin\\theta_p, \\cos\\theta_p) $。此问题中的所有量都已无量纲化：长度通过特征缺陷核心长度 $ L $ 进行缩放，速度通过特征尺度进行缩放，因此可以不失一般性地将预因子 $ C $ 取为 $ C = 1/(4\\pi) $。角度必须以弧度为单位。\n\n假设一次PIV测量提供了 $ N $ 个采样位置 $ \\{\\mathbf{x}_k\\}_{k=1}^N $ 和测量速度 $ \\{\\mathbf{v}^{\\mathrm{meas}}_k\\}_{k=1}^N $。假设PIV测量噪声是一个添加到真实信号上的小的确定性扰动 $ \\boldsymbol{\\varepsilon}(\\mathbf{x}) $，因此\n$$\n\\mathbf{v}^{\\mathrm{meas}}_k = \\zeta_{\\mathrm{true}}\\mathbf{B}(\\mathbf{x}_k) + \\boldsymbol{\\varepsilon}(\\mathbf{x}_k),\n$$\n其中基场 $ \\mathbf{B}(\\mathbf{x}) $ 定义为\n$$\n\\mathbf{B}(\\mathbf{x}) \\equiv \\frac{C S}{\\eta r}\\left[\\cos(\\theta - \\theta_p)\\,\\hat{\\mathbf{p}} + \\beta \\sin(\\theta - \\theta_p)\\,\\hat{\\mathbf{p}}_{\\perp}\\right].\n$$\n您的任务是通过求解所有样本的线性模型 $ \\mathbf{v}^{\\mathrm{meas}}_k \\approx \\zeta\\,\\mathbf{B}(\\mathbf{x}_k) $ 的最小二乘拟合，从PIV数据中估计活性参数 $ \\zeta $。在给定模型下，最佳线性无偏估计通过最小化 $ \\sum_{k=1}^N \\|\\mathbf{v}^{\\mathrm{meas}}_k - \\zeta\\,\\mathbf{B}(\\mathbf{x}_k)\\|^2 $ 获得。证明该估计器可以写成关于 $ \\mathbf{B}(\\mathbf{x}_k) $ 的点积和范数的封闭形式，并实现它。\n\n为确保可复现性，测量噪声必须是确定性场\n$$\n\\boldsymbol{\\varepsilon}(\\mathbf{x}) = \\epsilon \\begin{bmatrix} \\sin(x)\\cos(y) \\\\ \\cos(x)\\sin(y) \\end{bmatrix},\n$$\n其中给定振幅为 $ \\epsilon $，$ x $ 和 $ y $ 是 $ \\mathbf{x} $ 的笛卡尔分量。\n\n将采样位置构建为以缺陷核心为中心的一组同心环。假设有 $ n_r $ 个环，其半径为 $ r_i = r_{\\min} + i\\,(r_{\\max} - r_{\\min})/(n_r - 1) $（对于 $ i = 0, 1, \\dots, n_r-1 $），每个环上有 $ n_\\theta $ 个点，其极角为 $ \\theta_j = 2\\pi j/n_\\theta $（对于 $ j = 0, 1, \\dots, n_\\theta-1 $）。采样位置为 $ \\mathbf{x}_{i,j} = (r_i\\cos\\theta_j, r_i\\sin\\theta_j) $。\n\n实现一个程序，该程序：\n- 使用上述模型、已知的 $ \\zeta_{\\mathrm{true}} $ 和 $ \\boldsymbol{\\varepsilon}(\\mathbf{x}) $，为每个测试案例生成合成的无量纲PIV数据 $ \\{\\mathbf{x}_k, \\mathbf{v}^{\\mathrm{meas}}_k\\} $。\n- 使用从第一性原理推导出的线性估计器计算最小二乘估计值 $ \\hat{\\zeta} $。\n- 在单行上输出所有测试案例的 $ \\hat{\\zeta} $ 列表，格式为方括号括起来的逗号分隔列表。\n\n所有角度均使用弧度。由于问题已完全无量纲化，因此不出现物理单位。\n\n测试套件：\n- 案例 A（理想路径）：$ \\zeta_{\\mathrm{true}} = 1.25 $，$ \\eta = 1.0 $，$ S = 0.6 $，$ \\theta_p = 0.0 $，$ r_{\\min} = 0.5 $，$ r_{\\max} = 3.0 $，$ n_r = 3 $，$ n_\\theta = 16 $，$ \\beta = 0.5 $，$ C = 1/(4\\pi) $，$ \\epsilon = 0.02 $。\n- 案例 B（近零活性边界）：$ \\zeta_{\\mathrm{true}} = 0.0 $，$ \\eta = 1.0 $，$ S = 0.8 $，$ \\theta_p = \\pi/3 $，$ r_{\\min} = 0.6 $，$ r_{\\max} = 2.5 $，$ n_r = 4 $，$ n_\\theta = 12 $，$ \\beta = 0.5 $，$ C = 1/(4\\pi) $，$ \\epsilon = 0.03 $。\n- 案例 C（各向异性和粘度变化）：$ \\zeta_{\\mathrm{true}} = 2.0 $，$ \\eta = 0.7 $，$ S = 0.5 $，$ \\theta_p = \\pi/4 $，$ r_{\\min} = 0.3 $，$ r_{\\max} = 1.5 $，$ n_r = 5 $，$ n_\\theta = 10 $，$ \\beta = 0.5 $，$ C = 1/(4\\pi) $，$ \\epsilon = 0.05 $。\n\n您的程序应生成单行输出，包含格式为方括号括起来的逗号分隔列表的结果（例如，$ [\\text{result}_A,\\text{result}_B,\\text{result}_C] $）。每个结果必须是实数（浮点数）。角度必须以弧度处理，并且基场 $ \\mathbf{B}(\\mathbf{x}) $ 必须使用上述精确定义。程序必须是自包含的，且不得读取外部输入或文件。",
            "solution": "用户请求解决一个计算物理学问题，具体涉及活性向列相领域。任务是根据合成的粒子图像测速（PIV）数据，推导并实现活性参数 $\\zeta$ 的最小二乘估计器。\n\n### 步骤1：提取已知信息\n\n问题提供了以下信息：\n- **控制方程（远场）**：稳态斯托克斯方程与活性应力，$\\eta \\nabla^2 \\mathbf{v} - \\nabla p + \\nabla \\cdot \\boldsymbol{\\sigma}^{\\mathrm{a}} = \\mathbf{0}$，以及不可压缩性条件，$\\nabla \\cdot \\mathbf{v} = 0$。\n- **活性应力**：$\\boldsymbol{\\sigma}^{\\mathrm{a}} = -\\zeta \\mathbf{Q}$。\n- **向列相序张量**：$\\mathbf{Q} = S(\\mathbf{n}\\mathbf{n} - \\mathbf{I}/2)$。\n- **远场速度模型**：\n$$\n\\mathbf{v}_{\\mathrm{model}}(\\mathbf{x}) \\equiv \\frac{C S \\zeta}{\\eta r}\\left[\\cos(\\theta - \\theta_p)\\,\\hat{\\mathbf{p}} + \\beta \\sin(\\theta - \\theta_p)\\,\\hat{\\mathbf{p}}_{\\perp}\\right]\n$$\n- **定义**：\n  - $\\mathbf{x}$：位置向量，径向距离为 $r = \\|\\mathbf{x}\\|$，极角为 $\\theta$。\n  - $\\hat{\\mathbf{p}} = (\\cos\\theta_p, \\sin\\theta_p)$：缺陷极性方向单位向量。\n  - $\\hat{\\mathbf{p}}_{\\perp} = (-\\sin\\theta_p, \\cos\\theta_p)$：正交单位向量。\n  - $\\theta_p$：缺陷极性的方向角。\n  - $\\eta$：动力粘度。\n  - $S$：标量序参数。\n  - $\\beta$：无量纲涡旋系数。\n  - $C$：无量纲预因子，给定为 $C = 1/(4\\pi)$。\n- **PIV数据的线性模型**：$\\mathbf{v}^{\\mathrm{meas}}_k = \\zeta_{\\mathrm{true}}\\mathbf{B}(\\mathbf{x}_k) + \\boldsymbol{\\varepsilon}(\\mathbf{x}_k)$。\n- **基场**：\n$$\n\\mathbf{B}(\\mathbf{x}) \\equiv \\frac{C S}{\\eta r}\\left[\\cos(\\theta - \\theta_p)\\,\\hat{\\mathbf{p}} + \\beta \\sin(\\theta - \\theta_p)\\,\\hat{\\mathbf{p}}_{\\perp}\\right]\n$$\n- **目标**：最小化成本函数 $L(\\zeta) = \\sum_{k=1}^N \\|\\mathbf{v}^{\\mathrm{meas}}_k - \\zeta\\,\\mathbf{B}(\\mathbf{x}_k)\\|^2$ 以求得估计器 $\\hat{\\zeta}$。\n- **确定性噪声场**：\n$$\n\\boldsymbol{\\varepsilon}(\\mathbf{x}) = \\epsilon \\begin{bmatrix} \\sin(x)\\cos(y) \\\\ \\cos(x)\\sin(y) \\end{bmatrix}\n$$\n- **采样网格**：具有 $n_r$ 个半径 $r_i = r_{\\min} + i\\,(r_{\\max} - r_{\\min})/(n_r - 1)$（$i = 0, \\dots, n_r-1$）的同心环，每个环上 $n_\\theta$ 个点，角度为 $\\theta_j = 2\\pi j/n_\\theta$（$j = 0, \\dots, n_\\theta-1$）。\n- **测试案例**：\n  - 案例 $A$：$\\zeta_{\\mathrm{true}} = 1.25$, $\\eta = 1.0$, $S = 0.6$, $\\theta_p = 0.0$, $r_{\\min} = 0.5$, $r_{\\max} = 3.0$, $n_r = 3$, $n_\\theta = 16$, $\\beta = 0.5$, $C = 1/(4\\pi)$, $\\epsilon = 0.02$。\n  - 案例 $B$：$\\zeta_{\\mathrm{true}} = 0.0$, $\\eta = 1.0$, $S = 0.8$, $\\theta_p = \\pi/3$, $r_{\\min} = 0.6$, $r_{\\max} = 2.5$, $n_r = 4$, $n_\\theta = 12$, $\\beta = 0.5$, $C = 1/(4\\pi)$, $\\epsilon = 0.03$。\n  - 案例 $C$：$\\zeta_{\\mathrm{true}} = 2.0$, $\\eta = 0.7$, $S = 0.5$, $\\theta_p = \\pi/4$, $r_{\\min} = 0.3$, $r_{\\max} = 1.5$, $n_r = 5$, $n_\\theta = 10$, $\\beta = 0.5$, $C = 1/(4\\pi)$, $\\epsilon = 0.05$。\n\n### 步骤2：使用提取的已知信息进行验证\n\n根据验证标准对问题进行评估。\n- **科学依据**：该问题设置在活性向列相的背景下，这是软凝聚态物理中一个成熟的子领域。使用斯托克斯流处理低雷诺数流体动力学、通过向列张量 $\\mathbf{Q}$ 定义活性应力，以及 $+1/2$ 缺陷的远场速度分布，都是文献中的标准概念。该问题是物理系统的一个简化但科学上一致的表示。\n- **适定性**：核心任务是为线性模型 $\\mathbf{v} = \\zeta \\mathbf{B}$ 寻找最佳拟合的标量参数 $\\zeta$。这是一个经典的线性最小二乘问题。给定基场 $\\mathbf{B}(\\mathbf{x})$ 和测量数据 $\\mathbf{v}^{\\mathrm{meas}}_k$ 的定义，估计器 $\\hat{\\zeta}$ 的唯一解存在且可以推导，前提是基场不恒为零。给定的参数确保了 $\\mathbf{B}(\\mathbf{x})$ 在采样域上是良定义且非零的。\n- **客观性**：该问题使用精确的数学和物理术语陈述。所有参数、模型和程序都已明确定义。没有主观或基于观点的陈述。\n- **完整性**：生成合成数据（$\\zeta_{\\mathrm{true}}$, $\\eta$, $S$, $\\theta_p$, $\\beta$, $C$, $\\epsilon$，网格参数）和执行估计所需的所有必要参数和函数形式都已提供。问题是自包含的。\n- **一致性**：所提供的数据或模型定义中没有内部矛盾。\n- **可行性**：在无量纲化框架内，参数是物理上合理的。指定的计算是标准的数值运算。\n\n### 步骤3：结论与行动\n\n问题被判定为**有效**。这是一个定义明确、有科学依据的练习，旨在使用从物理原理推导出的线性模型进行参数估计。现在可以开始求解过程。\n\n### 解法\n\n目标是找到 $\\zeta$ 的值，记为 $\\hat{\\zeta}$，使得在所有 $N$ 个数据点上，测量速度数据 $\\mathbf{v}^{\\mathrm{meas}}_k$ 与模型预测 $\\zeta\\,\\mathbf{B}(\\mathbf{x}_k)$ 之间的误差平方和最小。需要最小化的成本函数是：\n$$\nL(\\zeta) = \\sum_{k=1}^{N} \\left\\| \\mathbf{v}^{\\mathrm{meas}}_k - \\zeta\\,\\mathbf{B}(\\mathbf{x}_k) \\right\\|^2\n$$\n向量 $\\mathbf{u}$ 的欧几里得范数的平方由其与自身的点积给出，即 $\\|\\mathbf{u}\\|^2 = \\mathbf{u} \\cdot \\mathbf{u}$。应用这一点，我们可以展开成本函数：\n$$\nL(\\zeta) = \\sum_{k=1}^{N} \\left( \\mathbf{v}^{\\mathrm{meas}}_k - \\zeta\\,\\mathbf{B}(\\mathbf{x}_k) \\right) \\cdot \\left( \\mathbf{v}^{\\mathrm{meas}}_k - \\zeta\\,\\mathbf{B}(\\mathbf{x}_k) \\right)\n$$\n利用点积的分配律，求和中的每一项变为：\n$$\n\\left( \\mathbf{v}^{\\mathrm{meas}}_k \\cdot \\mathbf{v}^{\\mathrm{meas}}_k \\right) - 2\\zeta \\left( \\mathbf{v}^{\\mathrm{meas}}_k \\cdot \\mathbf{B}(\\mathbf{x}_k) \\right) + \\zeta^2 \\left( \\mathbf{B}(\\mathbf{x}_k) \\cdot \\mathbf{B}(\\mathbf{x}_k) \\right)\n$$\n用范数重写此式可得：\n$$\nL(\\zeta) = \\sum_{k=1}^{N} \\left( \\|\\mathbf{v}^{\\mathrm{meas}}_k\\|^2 - 2\\zeta (\\mathbf{v}^{\\mathrm{meas}}_k \\cdot \\mathbf{B}(\\mathbf{x}_k)) + \\zeta^2 \\|\\mathbf{B}(\\mathbf{x}_k)\\|^2 \\right)\n$$\n这个表达式是关于 $\\zeta$ 的二次函数，形式为 $A\\zeta^2 + B\\zeta + C$，描述了一个开口向上的抛物线。其最小值可以通过对 $\\zeta$ 求导并令其为零来找到。\n$$\n\\frac{d L}{d \\zeta} = \\frac{d}{d \\zeta} \\sum_{k=1}^{N} \\left( \\|\\mathbf{v}^{\\mathrm{meas}}_k\\|^2 - 2\\zeta (\\mathbf{v}^{\\mathrm{meas}}_k \\cdot \\mathbf{B}(\\mathbf{x}_k)) + \\zeta^2 \\|\\mathbf{B}(\\mathbf{x}_k)\\|^2 \\right)\n$$\n和的导数是导数的和。项 $\\|\\mathbf{v}^{\\mathrm{meas}}_k\\|^2$ 相对于 $\\zeta$ 是常数。\n$$\n\\frac{d L}{d \\zeta} = \\sum_{k=1}^{N} \\left( -2 (\\mathbf{v}^{\\mathrm{meas}}_k \\cdot \\mathbf{B}(\\mathbf{x}_k)) + 2\\zeta \\|\\mathbf{B}(\\mathbf{x}_k)\\|^2 \\right)\n$$\n将导数设为零以求最优值 $\\hat{\\zeta}$：\n$$\n0 = \\sum_{k=1}^{N} \\left( -2 (\\mathbf{v}^{\\mathrm{meas}}_k \\cdot \\mathbf{B}(\\mathbf{x}_k)) + 2\\hat{\\zeta} \\|\\mathbf{B}(\\mathbf{x}_k)\\|^2 \\right)\n$$\n我们可以重新排列此方程以解出 $\\hat{\\zeta}$：\n$$\n2\\hat{\\zeta} \\sum_{k=1}^{N} \\|\\mathbf{B}(\\mathbf{x}_k)\\|^2 = 2 \\sum_{k=1}^{N} (\\mathbf{v}^{\\mathrm{meas}}_k \\cdot \\mathbf{B}(\\mathbf{x}_k))\n$$\n最后，除以 $\\hat{\\zeta}$ 的系数，得到最小二乘估计器的封闭形式表达式：\n$$\n\\hat{\\zeta} = \\frac{\\sum_{k=1}^{N} \\mathbf{v}^{\\mathrm{meas}}_k \\cdot \\mathbf{B}(\\mathbf{x}_k)}{\\sum_{k=1}^{N} \\|\\mathbf{B}(\\mathbf{x}_k)\\|^2}\n$$\n该公式提供了算法的核心。\n\n算法流程如下：\n1.  对于给定的测试案例参数集，生成 $N = n_r \\times n_\\theta$ 个采样点 $\\{\\mathbf{x}_k\\}$ 的网格。笛卡尔坐标 $(x_k, y_k)$ 从极坐标 $(r_i, \\theta_j)$ 获得，即 $x_k = r_i \\cos(\\theta_j)$ 和 $y_k = r_i \\sin(\\theta_j)$。\n2.  对于每个点 $\\mathbf{x}_k$，我们计算基向量 $\\mathbf{B}(\\mathbf{x}_k)$ 和测量速度向量 $\\mathbf{v}^{\\mathrm{meas}}_k$。\n    - 极性向量为 $\\hat{\\mathbf{p}} = (\\cos\\theta_p, \\sin\\theta_p)$ 和 $\\hat{\\mathbf{p}}_{\\perp} = (-\\sin\\theta_p, \\cos\\theta_p)$。\n    - 基向量 $\\mathbf{B}(\\mathbf{x}_k)$ 根据其定义直接计算，使用该点的极坐标 $r_k$ 和 $\\theta_k$。\n    - 确定性噪声向量为 $\\boldsymbol{\\varepsilon}(\\mathbf{x}_k) = \\epsilon (\\sin(x_k)\\cos(y_k), \\cos(x_k)\\sin(y_k))$。\n    - 那么合成的测量速度为 $\\mathbf{v}^{\\mathrm{meas}}_k = \\zeta_{\\mathrm{true}}\\mathbf{B}(\\mathbf{x}_k) + \\boldsymbol{\\varepsilon}(\\mathbf{x}_k)$。\n3.  然后我们计算估计器 $\\hat{\\zeta}$ 所需的两个和。\n    - 分子项是点积的和：$\\sum_{k=1}^{N} \\mathbf{v}^{\\mathrm{meas}}_k \\cdot \\mathbf{B}(\\mathbf{x}_k)$。\n    - 分母项是范数平方的和：$\\sum_{k=1}^{N} \\|\\mathbf{B}(\\mathbf{x}_k)\\|^2 = \\sum_{k=1}^{N} \\mathbf{B}(\\mathbf{x}_k) \\cdot \\mathbf{B}(\\mathbf{x}_k)$。\n4.  估计值 $\\hat{\\zeta}$ 计算为这两个和的比值。\n对问题陈述中提供的每个测试案例重复此过程。实现将利用 `numpy` 对点和向量的数组进行高效的向量化计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of estimating the activity parameter zeta from synthetic PIV data\n    for a set of test cases defined in the problem statement.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: happy path\n        dict(\n            zeta_true=1.25, eta=1.0, S=0.6, theta_p=0.0,\n            r_min=0.5, r_max=3.0, n_r=3, n_theta=16,\n            beta=0.5, C=1/(4*np.pi), epsilon=0.02\n        ),\n        # Case B: near-zero activity boundary\n        dict(\n            zeta_true=0.0, eta=1.0, S=0.8, theta_p=np.pi/3,\n            r_min=0.6, r_max=2.5, n_r=4, n_theta=12,\n            beta=0.5, C=1/(4*np.pi), epsilon=0.03\n        ),\n        # Case C: anisotropy and viscosity variation\n        dict(\n            zeta_true=2.0, eta=0.7, S=0.5, theta_p=np.pi/4,\n            r_min=0.3, r_max=1.5, n_r=5, n_theta=10,\n            beta=0.5, C=1/(4*np.pi), epsilon=0.05\n        )\n    ]\n\n    results = []\n    for params in test_cases:\n        # Extract parameters for the current case\n        zeta_true = params['zeta_true']\n        eta = params['eta']\n        S = params['S']\n        theta_p = params['theta_p']\n        r_min = params['r_min']\n        r_max = params['r_max']\n        n_r = params['n_r']\n        n_theta = params['n_theta']\n        beta = params['beta']\n        C = params['C']\n        epsilon = params['epsilon']\n\n        # Step 1: Generate sampling positions\n        # Create n_r radii for the concentric rings\n        if n_r > 1:\n            radii = np.linspace(r_min, r_max, n_r)\n        else:\n            radii = np.array([r_min])\n        \n        # Create n_theta angles for points on each ring\n        angles = np.linspace(0, 2 * np.pi, n_theta, endpoint=False)\n\n        # Create a mesh grid of polar coordinates and flatten them\n        r_grid, theta_grid = np.meshgrid(radii, angles)\n        r_k = r_grid.flatten()\n        theta_k = theta_grid.flatten()\n\n        # Convert polar coordinates to Cartesian coordinates (x, y)\n        x_k = r_k * np.cos(theta_k)\n        y_k = r_k * np.sin(theta_k)\n\n        # Step 2: Calculate basis field B(x_k) and measured velocity v_meas_k\n        \n        # Define polarity vectors\n        p_hat = np.array([np.cos(theta_p), np.sin(theta_p)])\n        p_hat_perp = np.array([-np.sin(theta_p), np.cos(theta_p)])\n\n        # Calculate the basis field B(x_k) for all points\n        # The structure is (N_points, 2) for the vector field\n        cos_term = np.cos(theta_k - theta_p)[:, np.newaxis]\n        sin_term = np.sin(theta_k - theta_p)[:, np.newaxis]\n        prefactor = (C * S) / (eta * r_k[:, np.newaxis])\n        \n        B_k = prefactor * (cos_term * p_hat + beta * sin_term * p_hat_perp)\n\n        # Calculate the deterministic noise field epsilon(x_k)\n        eps_x = epsilon * np.sin(x_k) * np.cos(y_k)\n        eps_y = epsilon * np.cos(x_k) * np.sin(y_k)\n        # Reshape to (N_points, 2)\n        eps_k = np.vstack((eps_x, eps_y)).T\n\n        # Generate synthetic PIV data (measured velocity)\n        v_meas_k = zeta_true * B_k + eps_k\n\n        # Step 3  4: Compute the least-squares estimate hat_zeta\n        \n        # Numerator: sum(v_meas_k . B_k)\n        # np.sum(v_meas_k * B_k) performs element-wise multiplication and sum,\n        # which is equivalent to sum of dot products for (N, 2) arrays.\n        numerator = np.sum(v_meas_k * B_k)\n        \n        # Denominator: sum(||B_k||^2) = sum(B_k . B_k)\n        denominator = np.sum(B_k * B_k)\n\n        # If the basis field is zero everywhere (e.g., S=0), denominator is zero.\n        # Handle this to avoid division by zero.\n        if denominator == 0:\n            hat_zeta = 0.0\n        else:\n            hat_zeta = numerator / denominator\n        \n        results.append(hat_zeta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}