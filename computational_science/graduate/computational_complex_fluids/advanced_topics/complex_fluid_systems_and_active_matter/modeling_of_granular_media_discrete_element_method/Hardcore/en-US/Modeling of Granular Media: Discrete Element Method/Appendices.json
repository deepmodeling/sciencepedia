{
    "hands_on_practices": [
        {
            "introduction": "In a simulation with millions of particles, checking every pair for contact is computationally prohibitive, scaling as $O(N^2)$. The cell list method is a spatial hashing technique that reduces this complexity by only checking nearby particles. This exercise  explores the fundamental geometric reasoning behind this method, a cornerstone of efficient DEM simulations, by asking you to determine the minimal search neighborhood required to guarantee all contacts are found.",
            "id": "4095057",
            "problem": "A Discrete Element Method (DEM) simulation of granular media in three spatial dimensions partitions the computational domain into a uniform Cartesian grid of cubic cells, each of edge length $l$. The material consists of $N = 10^{6}$ spherical particles whose radii $\\{r_{i}\\}$ satisfy $0 < r_{i} \\le R_{\\max}$ for all $i$. Two particles $i$ and $j$ can be in mechanical contact only if the Euclidean distance between their centers is less than or equal to $r_{i} + r_{j}$. Contact detection is performed by inspecting a finite set of grid cells associated with each particle’s cell.\n\nAssume the grid cell size satisfies $l \\ge 2 R_{\\max}$ and that the domain is large and either periodic or sufficiently extended that boundary effects do not alter the local neighbor topology. Using only fundamental geometric considerations implied by the contact condition and the uniform grid partitioning, determine the minimal number of distinct grid cells (including the particle’s own cell) that must be inspected per particle to guarantee that every potentially contacting particle pair is considered. Express your final answer as an exact integer. No rounding is required, and there are no physical units associated with this count.",
            "solution": "The problem is first validated to ensure it is scientifically grounded, well-posed, and objective.\n\n### Step 1: Extract Givens\n- The simulation is in three spatial dimensions.\n- The computational domain is partitioned by a uniform Cartesian grid of cubic cells.\n- The edge length of each cubic cell is $l$.\n- The system contains $N = 10^{6}$ spherical particles.\n- The radius of any particle $i$, denoted $r_i$, is bounded by $0 < r_i \\le R_{\\max}$.\n- Two particles, $i$ and $j$, with radii $r_i$ and $r_j$ and centers at positions $\\mathbf{p}_i$ and $\\mathbf{p}_j$ respectively, can be in contact only if the Euclidean distance between their centers satisfies $|\\mathbf{p}_i - \\mathbf{p}_j| \\le r_i + r_j$.\n- The grid cell size is constrained by $l \\ge 2 R_{\\max}$.\n- Boundary effects are negligible.\n- The task is to find the minimal number of distinct grid cells that must be inspected for each particle to guarantee that all potential contacts are identified. This count includes the particle's own cell.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem describes the cell list method, a standard and fundamental algorithm in computational physics for efficient neighbor finding in Discrete Element Method (DEM) and Molecular Dynamics (MD) simulations. The geometric setup and contact conditions are standard. The problem is sound.\n- **Well-Posed**: The problem is well-defined. It asks for a minimal number under a clear set of geometric constraints ($l \\ge 2 R_{\\max}$). The constraints are sufficient to determine a unique integer solution.\n- **Objective**: The problem is stated using precise, formal language common in computational science. There is no ambiguity or subjectivity.\n\nAll other validation criteria are met. The problem does not violate any scientific principles, is formalizable, is not missing information, does not contain contradictions, and is not trivial.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A solution will be derived.\n\n### Solution Derivation\n\nLet us consider a particle $i$ with radius $r_i$ and its center at position $\\mathbf{p}_i$. According to the problem statement, this particle resides in a specific cubic grid cell, which we can designate as the \"home\" cell, $C_0$. We need to identify the minimal set of surrounding cells that must be checked to find all other particles $j$ that could potentially be in contact with particle $i$.\n\nThe condition for a potential contact between particle $i$ and particle $j$ (with radius $r_j$ and center at $\\mathbf{p}_j$) is that the distance between their centers is no more than the sum of their radii:\n$$\n|\\mathbf{p}_i - \\mathbf{p}_j| \\le r_i + r_j\n$$\nThe particle radii are bounded by $0 < r_k \\le R_{\\max}$ for any particle $k$. Therefore, the maximum possible distance between the centers of two contacting particles is:\n$$\nr_i + r_j \\le R_{\\max} + R_{\\max} = 2R_{\\max}\n$$\nThis means that to guarantee finding all potential contacts for particle $i$, we must search for the centers of other particles, $\\mathbf{p}_j$, within a sphere of radius $2R_{\\max}$ centered at $\\mathbf{p}_i$.\n\nThe procedure must be valid for any possible position of particle $i$ within its home cell $C_0$. To establish a coordinate system, let us define the home cell $C_0$ as the cubic region $[0, l) \\times [0, l) \\times [0, l)$. The position of the center of particle $i$ is $\\mathbf{p}_i = (x_i, y_i, z_i)$, where $0 \\le x_i < l$, $0 \\le y_i < l$, and $0 \\le z_i < l$.\n\nThe search must cover all cells that could potentially contain a contact partner. We can determine the minimal necessary search volume by considering two aspects:\n1.  Which neighboring cells *must* be included in the search?\n2.  Which cells can be definitively *excluded* from the search?\n\n**1. Cells that must be included:**\nA neighboring cell must be checked if it is possible for a particle in $C_0$ to contact a particle in that neighbor cell. Consider a cell adjacent to $C_0$, sharing a face, edge, or corner. For any such neighboring cell, there exists a boundary shared with $C_0$. It is possible to place the center of particle $i$ infinitesimally close to this boundary on the $C_0$ side, and the center of particle $j$ infinitesimally close on the neighbor's side.\n\nFor example, consider the corner-adjacent cell $C_{(-1,-1,-1)}$, which occupies the region $[-l, 0) \\times [-l, 0) \\times [-l, 0)$. We can place particle $i$ at $\\mathbf{p}_i = (\\epsilon, \\epsilon, \\epsilon)$ and particle $j$ at $\\mathbf{p}_j = (-\\epsilon, -\\epsilon, -\\epsilon)$, for an arbitrarily small positive value $\\epsilon$. Both particles are within their respective cells. The distance between their centers is $|\\mathbf{p}_i - \\mathbf{p}_j| = \\sqrt{(2\\epsilon)^2 + (2\\epsilon)^2 + (2\\epsilon)^2} = 2\\epsilon\\sqrt{3}$. This distance can be made smaller than any given positive contact distance $r_i + r_j$ (since $r_k > 0$). Therefore, contact is possible, and cell $C_{(-1,-1,-1)}$ must be checked.\n\nThis logic applies to any cell that is topologically adjacent to $C_0$. In a $3D$ Cartesian grid, a cell has $26$ such neighbors: $6$ sharing a face, $12$ sharing an edge, and $8$ sharing a corner. Including the home cell $C_0$ itself, this constitutes a $3 \\times 3 \\times 3$ block of cells. The total number of cells in this block is $3^3 = 27$.\n\n**2. Cells that can be excluded:**\nNow we must prove that no cells outside this $3 \\times 3 \\times 3$ block need to be checked. This is where the condition $l \\ge 2R_{\\max}$ is critical.\nConsider a cell $C_k$ that is not part of this $3 \\times 3 \\times 3$ block. This means that the cell index vector $\\mathbf{k} = (k_x, k_y, k_z)$ relative to $C_0$ has at least one component with an absolute value of 2 or more. Let's analyze the case for $\\mathbf{k} = (2, 0, 0)$ without loss of generality.\nThe cell $C_0$ is $[0, l) \\times [0, l) \\times [0, l)$.\nThe cell $C_{(2,0,0)}$ is $[2l, 3l) \\times [0, l) \\times [0, l)$.\n\nLet particle $i$ be in $C_0$, so its x-coordinate is $x_i \\in [0, l)$.\nLet particle $j$ be in $C_{(2,0,0)}$, so its x-coordinate is $x_j \\in [2l, 3l)$.\n\nThe distance between these particles in the x-dimension is $x_j - x_i$. The minimum possible value for this separation is attained when $x_j$ is minimized and $x_i$ is maximized:\n$$\n\\min(x_j - x_i) = \\inf(x_j) - \\sup(x_i) = 2l - l = l\n$$\nSince the actual coordinates are $x_j \\ge 2l$ and $x_i < l$, the separation is strictly $x_j - x_i > l$.\nThe total Euclidean distance between the centers is $|\\mathbf{p}_i - \\mathbf{p}_j| = \\sqrt{(x_j - x_i)^2 + (y_j - y_i)^2 + (z_j - z_i)^2}$. Since $(x_j - x_i)^2 > l^2$, the total distance must satisfy:\n$$\n|\\mathbf{p}_i - \\mathbf{p}_j| > l\n$$\nWe are given the condition $l \\ge 2R_{\\max}$. Thus, the distance between the particles is:\n$$\n|\\mathbf{p}_i - \\mathbf{p}_j| > l \\ge 2R_{\\max}\n$$\nThe condition for contact is $|\\mathbf{p}_i - \\mathbf{p}_j| \\le r_i + r_j$. The maximum value for $r_i+r_j$ is $2R_{\\max}$.\nWe have shown that $|\\mathbf{p}_i - \\mathbf{p}_j| > 2R_{\\max}$, which means $|\\mathbf{p}_i - \\mathbf{p}_j| > r_i + r_j$. Contact is impossible.\n\nThis argument holds for any cell outside the $3 \\times 3 \\times 3$ local block. Therefore, we can definitively exclude all such cells from the search.\n\nThe minimal number of cells that must be inspected to guarantee finding all potential contacts is the count of cells in the $3 \\times 3 \\times 3$ block centered on the particle's home cell. This number is $3 \\times 3 \\times 3 = 27$.",
            "answer": "$$\n\\boxed{27}\n$$"
        },
        {
            "introduction": "The rich physics of granular media arises from the non-linear forces at particle contacts. This practice focuses on the tangential (frictional) component, which is critical for the stability and strength of granular assemblies. This hands-on coding exercise  guides you through implementing the \"return mapping\" algorithm, a robust predictor-corrector scheme to enforce the non-smooth Coulomb friction law within an explicit time-stepping framework.",
            "id": "4095033",
            "problem": "You are modeling a single tangential contact in the Discrete Element Method (DEM). The contact obeys Newton's laws and Coulomb friction. The tangential contact force is modeled as a linear elastic spring integrated from the slip velocity in the tangential plane, with a Coulomb friction limit. Starting from the fundamental relations that time integration accumulates displacement from velocity and that friction is bounded by the Coulomb limit, derive and implement the update for the tangential elastic spring displacement and the resulting tangential force. Specifically, for a given contact with normal force $F_n \\ge 0$ (compressive positive), friction coefficient $\\mu \\ge 0$, tangential stiffness $k_t > 0$, time step $\\Delta t > 0$, tangential slip velocity vector $\\boldsymbol{v}_t$ in the local tangential plane, and previous tangential spring displacement vector $\\boldsymbol{\\xi}^{old}$ in the same plane, compute the updated tangential spring displacement $\\boldsymbol{\\xi}^{new}$ and the tangential contact force $\\boldsymbol{F}_t$, enforcing the Coulomb limit.\n\nFundamental base to use:\n- Newton's Second Law and kinematics: velocity integrates to displacement, so the elastic spring displacement evolves according to $\\dfrac{d\\boldsymbol{\\xi}}{dt} = \\boldsymbol{v}_t$.\n- Linear elastic tangential force: $\\boldsymbol{F}_t = -k_t \\boldsymbol{\\xi}$.\n- Coulomb friction: $\\lVert \\boldsymbol{F}_t \\rVert \\le \\mu F_n$ and, under sliding, $\\boldsymbol{F}_t$ is directed opposite the slip tendency in the tangential plane.\n\nYour program must:\n1. Perform an explicit time integration trial update of the tangential spring displacement using $\\boldsymbol{\\xi}^{trial} = \\boldsymbol{\\xi}^{old} + \\boldsymbol{v}_t \\Delta t$.\n2. Compute the corresponding trial tangential force $\\boldsymbol{F}_t^{trial} = -k_t \\boldsymbol{\\xi}^{trial}$.\n3. Enforce the Coulomb friction limit by projecting back to the admissible set when necessary:\n   - If $F_n \\le 0$ then the contact is non-load bearing, and set $\\boldsymbol{\\xi}^{new} = \\boldsymbol{0}$ and $\\boldsymbol{F}_t = \\boldsymbol{0}$.\n   - Else if $\\lVert \\boldsymbol{F}_t^{trial} \\rVert \\le \\mu F_n$, then set $\\boldsymbol{\\xi}^{new} = \\boldsymbol{\\xi}^{trial}$ and $\\boldsymbol{F}_t = \\boldsymbol{F}_t^{trial}$ (stick).\n   - Else (slide), rescale the trial state to the Coulomb surface by setting $\\boldsymbol{\\xi}^{new} = \\boldsymbol{\\xi}^{trial} \\dfrac{\\mu F_n}{\\lVert \\boldsymbol{F}_t^{trial} \\rVert}$ and $\\boldsymbol{F}_t = -k_t \\boldsymbol{\\xi}^{new}$. This enforces $\\lVert \\boldsymbol{F}_t \\rVert = \\mu F_n$ with $\\boldsymbol{F}_t$ aligned with the trial direction in the tangential plane.\n\nAll vectors are two-dimensional in the local tangential plane. Use the International System of Units: express $\\boldsymbol{\\xi}^{new}$ in $\\mathrm{m}$ and $\\boldsymbol{F}_t$ in $\\mathrm{N}$. No angles are required. The numerical output shall be expressed as raw decimal floats.\n\nTest suite:\nProvide the following six test cases, each specified by $(F_n, \\mu, k_t, \\Delta t, \\boldsymbol{v}_t, \\boldsymbol{\\xi}^{old})$ with the given units:\n- Case $1$ (stick, small increment): $F_n = 100\\,\\mathrm{N}$, $\\mu = 0.5$, $k_t = 10^4\\,\\mathrm{N/m}$, $\\Delta t = 10^{-3}\\,\\mathrm{s}$, $\\boldsymbol{v}_t = [0.01, 0]\\,\\mathrm{m/s}$, $\\boldsymbol{\\xi}^{old} = [0, 0]\\,\\mathrm{m}$.\n- Case $2$ (slide, large increment): $F_n = 100\\,\\mathrm{N}$, $\\mu = 0.5$, $k_t = 10^4\\,\\mathrm{N/m}$, $\\Delta t = 10^{-3}\\,\\mathrm{s}$, $\\boldsymbol{v}_t = [10, 0]\\,\\mathrm{m/s}$, $\\boldsymbol{\\xi}^{old} = [0, 0]\\,\\mathrm{m}$.\n- Case $3$ (boundary, exactly at limit): $F_n = 100\\,\\mathrm{N}$, $\\mu = 0.5$, $k_t = 10^4\\,\\mathrm{N/m}$, $\\Delta t = 10^{-3}\\,\\mathrm{s}$, $\\boldsymbol{v}_t = [5, 0]\\,\\mathrm{m/s}$, $\\boldsymbol{\\xi}^{old} = [0, 0]\\,\\mathrm{m}$.\n- Case $4$ (no contact): $F_n = 0\\,\\mathrm{N}$, $\\mu = 0.5$, $k_t = 10^4\\,\\mathrm{N/m}$, $\\Delta t = 10^{-3}\\,\\mathrm{s}$, $\\boldsymbol{v}_t = [100, -100]\\,\\mathrm{m/s}$, $\\boldsymbol{\\xi}^{old} = [0, 0]\\,\\mathrm{m}$.\n- Case $5$ (stick with oblique update): $F_n = 10\\,\\mathrm{N}$, $\\mu = 0.3$, $k_t = 2 \\times 10^4\\,\\mathrm{N/m}$, $\\Delta t = 2 \\times 10^{-3}\\,\\mathrm{s}$, $\\boldsymbol{v}_t = [0.003, -0.004]\\,\\mathrm{m/s}$, $\\boldsymbol{\\xi}^{old} = [10^{-4}, 0]\\,\\mathrm{m}$.\n- Case $6$ (return mapping with preloaded spring): $F_n = 5\\,\\mathrm{N}$, $\\mu = 0.2$, $k_t = 10^4\\,\\mathrm{N/m}$, $\\Delta t = 10^{-3}\\,\\mathrm{s}$, $\\boldsymbol{v}_t = [0, 0]\\,\\mathrm{m/s}$, $\\boldsymbol{\\xi}^{old} = [10^{-2}, 10^{-2}]\\,\\mathrm{m}$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the list $[\\xi_x, \\xi_y, F_{t,x}, F_{t,y}]$ for the corresponding test case in SI units (for example, $[[\\dots],[\\dots],\\dots]$). Each numerical entry must be a decimal float.",
            "solution": "The problem requires the derivation and implementation of a numerical algorithm to update the tangential force and spring displacement at a single frictional contact, as commonly modeled in the Discrete Element Method (DEM). The model is based on a linear tangential spring and the Coulomb friction law. The problem is well-posed, scientifically sound, and provides all necessary information to construct a unique solution.\n\nThe physical state of the contact is described by the tangential spring displacement vector $\\boldsymbol{\\xi}$ in the local $2$D tangential plane. The tangential force $\\boldsymbol{F}_t$ is assumed to be linearly proportional to this displacement:\n$$\n\\boldsymbol{F}_t = -k_t \\boldsymbol{\\xi}\n$$\nwhere $k_t > 0$ is the tangential stiffness.\n\nThe evolution of the spring displacement is governed by the relative tangential velocity (slip velocity) $\\boldsymbol{v}_t$ between the contacting surfaces. The rate of change of the elastic displacement is equal to the slip velocity:\n$$\n\\frac{d\\boldsymbol{\\xi}}{dt} = \\boldsymbol{v}_t\n$$\n\nThe magnitude of the tangential force is limited by the Coulomb friction criterion. The tangential force must lie within an admissible set, a disk in the tangential plane defined by:\n$$\n\\lVert \\boldsymbol{F}_t \\rVert \\le \\mu F_n\n$$\nwhere $F_n \\ge 0$ is the compressive normal force and $\\mu \\ge 0$ is the coefficient of static friction. When the force magnitude reaches the limit, $\\lVert \\boldsymbol{F}_t \\rVert = \\mu F_n$, the contact is in a state of gross sliding, and the tangential force vector must oppose the direction of slip velocity.\n\nThe algorithm to be implemented is an explicit time-stepping scheme of the predictor-corrector type, often referred to as a \"return mapping\" algorithm in computational plasticity and contact mechanics. Given the state at the beginning of a time step $\\Delta t > 0$ (represented by $\\boldsymbol{\\xi}^{old}$), the goal is to compute the state at the end of the step, $\\boldsymbol{\\xi}^{new}$ and $\\boldsymbol{F}_t$.\n\n**Step 1: Trial (Predictor) Step**\nFirst, we discretize the evolution equation for $\\boldsymbol{\\xi}$ using a forward Euler scheme. This yields a trial displacement, $\\boldsymbol{\\xi}^{trial}$, which assumes purely elastic behavior throughout the time step $\\Delta t$:\n$$\n\\boldsymbol{\\xi}^{trial} = \\boldsymbol{\\xi}^{old} + \\boldsymbol{v}_t \\Delta t\n$$\nFrom this trial displacement, a corresponding trial tangential force, $\\boldsymbol{F}_t^{trial}$, is computed:\n$$\n\\boldsymbol{F}_t^{trial} = -k_t \\boldsymbol{\\xi}^{trial}\n$$\n\n**Step 2: Constraint Enforcement (Corrector) Step**\nNext, the trial state is checked against the Coulomb friction constraint. There are three possible outcomes:\n\n**Case A: No Contact**\nIf the normal force $F_n \\le 0$, the contact is not active or is tensile. In DEM for granular materials, tensile forces are typically not supported, and any existing tangential \"memory\" in the spring is lost. Therefore, the tangential displacement and force are reset to zero.\n$$\n\\boldsymbol{\\xi}^{new} = \\boldsymbol{0} \\quad \\text{and} \\quad \\boldsymbol{F}_t = \\boldsymbol{0}\n$$\n\n**Case B: Stick Condition**\nIf the contact is active ($F_n > 0$) and the magnitude of the trial force is within the admissible friction disk, the purely elastic assumption holds. This is the \"stick\" condition.\n$$\n\\text{If } \\lVert \\boldsymbol{F}_t^{trial} \\rVert \\le \\mu F_n, \\text{ then the contact sticks.}\n$$\nIn this case, the trial values are accepted as the final values for the new state:\n$$\n\\boldsymbol{\\xi}^{new} = \\boldsymbol{\\xi}^{trial}\n$$\n$$\n\\boldsymbol{F}_t = \\boldsymbol{F}_t^{trial}\n$$\n\n**Case C: Slip Condition**\nIf the contact is active ($F_n > 0$) and the magnitude of the trial force exceeds the friction limit, the elastic assumption is invalid. The contact must slip, and the tangential force must lie on the boundary of the friction disk (the \"friction circle\").\n$$\n\\text{If } \\lVert \\boldsymbol{F}_t^{trial} \\rVert > \\mu F_n, \\text{ then the contact slips.}\n$$\nThe corrected force $\\boldsymbol{F}_t$ must have a magnitude of exactly $\\mu F_n$ and must point in the same direction as the trial force $\\boldsymbol{F}_t^{trial}$. This is achieved by radially scaling the trial force vector back to the friction circle. The scaling factor is the ratio of the maximum allowable force magnitude to the trial force magnitude.\n$$\n\\boldsymbol{F}_t = \\boldsymbol{F}_t^{trial} \\frac{\\mu F_n}{\\lVert \\boldsymbol{F}_t^{trial} \\rVert}\n$$\nThe norm of this new force is $\\lVert \\boldsymbol{F}_t \\rVert = \\left\\lVert \\boldsymbol{F}_t^{trial} \\frac{\\mu F_n}{\\lVert \\boldsymbol{F}_t^{trial} \\rVert} \\right\\rVert = \\lVert \\boldsymbol{F}_t^{trial} \\rVert \\frac{\\mu F_n}{\\lVert \\boldsymbol{F}_t^{trial} \\rVert} = \\mu F_n$, as required.\nSince the force and displacement are linearly related by the constant $-k_t$, the final displacement $\\boldsymbol{\\xi}^{new}$ is obtained by applying the same scaling factor to the trial displacement $\\boldsymbol{\\xi}^{trial}$:\n$$\n\\boldsymbol{\\xi}^{new} = \\boldsymbol{\\xi}^{trial} \\frac{\\mu F_n}{\\lVert \\boldsymbol{F}_t^{trial} \\rVert}\n$$\nThe final force can then be computed consistently as $\\boldsymbol{F}_t = -k_t \\boldsymbol{\\xi}^{new}$.\n\nThis predictor-corrector algorithm robustly and efficiently enforces the non-smooth, non-linear Coulomb friction law within an explicit DEM time-stepping framework. We will now implement this procedure for the given test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DEM tangential contact problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (stick, small increment)\n        {'Fn': 100.0, 'mu': 0.5, 'kt': 1e4, 'dt': 1e-3, 'vt': [0.01, 0.0], 'xi_old': [0.0, 0.0]},\n        # Case 2 (slide, large increment)\n        {'Fn': 100.0, 'mu': 0.5, 'kt': 1e4, 'dt': 1e-3, 'vt': [10.0, 0.0], 'xi_old': [0.0, 0.0]},\n        # Case 3 (boundary, exactly at limit)\n        {'Fn': 100.0, 'mu': 0.5, 'kt': 1e4, 'dt': 1e-3, 'vt': [5.0, 0.0], 'xi_old': [0.0, 0.0]},\n        # Case 4 (no contact)\n        {'Fn': 0.0, 'mu': 0.5, 'kt': 1e4, 'dt': 1e-3, 'vt': [100.0, -100.0], 'xi_old': [0.0, 0.0]},\n        # Case 5 (stick with oblique update)\n        {'Fn': 10.0, 'mu': 0.3, 'kt': 2e4, 'dt': 2e-3, 'vt': [0.003, -0.004], 'xi_old': [1e-4, 0.0]},\n        # Case 6 (return mapping with preloaded spring)\n        {'Fn': 5.0, 'mu': 0.2, 'kt': 1e4, 'dt': 1e-3, 'vt': [0.0, 0.0], 'xi_old': [1e-2, 1e-2]},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = update_tangential_contact(\n            case['Fn'], case['mu'], case['kt'], case['dt'],\n            np.array(case['vt']), np.array(case['xi_old'])\n        )\n        results.append(result)\n\n    # Format the final output string exactly as required\n    inner_parts = [f\"[{r[0]},{r[1]},{r[2]},{r[3]}]\" for r in results]\n    final_string = f\"[{','.join(inner_parts)}]\"\n    print(final_string)\n\ndef update_tangential_contact(Fn, mu, kt, dt, vt, xi_old):\n    \"\"\"\n    Computes the updated tangential spring displacement and contact force.\n\n    Args:\n        Fn (float): Normal force (N).\n        mu (float): Friction coefficient.\n        kt (float): Tangential stiffness (N/m).\n        dt (float): Time step (s).\n        vt (np.ndarray): Tangential slip velocity vector (m/s).\n        xi_old (np.ndarray): Previous tangential spring displacement vector (m).\n\n    Returns:\n        list: A list containing [xi_new_x, xi_new_y, Ft_x, Ft_y].\n    \"\"\"\n    # Case: No contact\n    if Fn <= 0:\n        xi_new = np.zeros(2)\n        Ft = np.zeros(2)\n        return xi_new.tolist() + Ft.tolist()\n\n    # Step 1: Trial update (predictor)\n    xi_trial = xi_old + vt * dt\n\n    # Step 2: Compute trial force\n    Ft_trial = -kt * xi_trial\n\n    # Compute magnitude of trial force\n    norm_Ft_trial = np.linalg.norm(Ft_trial)\n\n    # Compute friction limit\n    friction_limit = mu * Fn\n\n    # Step 3: Enforce Coulomb friction limit (corrector)\n    # Case: Stick condition\n    if norm_Ft_trial <= friction_limit:\n        xi_new = xi_trial\n        Ft = Ft_trial\n    # Case: Slip condition\n    else:\n        # The return mapping requires division by the norm of the trial force.\n        # This is safe because if norm_Ft_trial were 0, the 'if' condition\n        # (0 <= friction_limit) would have been true (since mu*Fn >= 0).\n        scaling_factor = friction_limit / norm_Ft_trial\n        xi_new = xi_trial * scaling_factor\n        # The final force can be calculated either by scaling Ft_trial or\n        # by using the new displacement. The latter is more robust to\n        # potential floating point inconsistencies.\n        Ft = -kt * xi_new\n\n    # Return the result as a list of floats\n    return xi_new.tolist() + Ft.tolist()\n\nsolve()\n```"
        },
        {
            "introduction": "A key feature of granular materials is structural anisotropy—the preferential alignment of contacts—which dictates their macroscopic mechanical response. The fabric tensor, $\\mathbf{F}$, provides a quantitative measure of this microscopic orientational structure. By computing the fabric tensor from a set of contact normals , you will learn how to bridge the gap from discrete particle data to a continuum-level description, a crucial step in analyzing and interpreting DEM simulation results.",
            "id": "4095013",
            "problem": "You are given a finite set of contact normals $\\{\\mathbf{n}_c\\}$ from a granular assembly modeled within the Discrete Element Method (DEM). Starting from the basic geometric definition that the contact network fabric tensor is the normalized second moment of contact orientations, compute the fabric tensor $\\mathbf{F}$, its eigenvalues, and identify the principal directions as the unit eigenvectors associated with the largest eigenvalue. Assume the following for the discretization: each contact contributes equally, every input contact normal is a real three-dimensional vector, and any zero-length vector contributes nothing and must be discarded.\n\nFundamental base: The fabric tensor of a contact network in three dimensions is defined as the average of dyadic products of unit contact normals. Starting from the orientation distribution function $p(\\mathbf{n})$ on the unit sphere with $\\int_{\\mathbb{S}^2} p(\\mathbf{n}) \\,\\mathrm{d}S = 1$, the continuous fabric tensor is $\\mathbf{F} = \\int_{\\mathbb{S}^2} p(\\mathbf{n})\\, \\mathbf{n}\\otimes \\mathbf{n}\\,\\mathrm{d}S$. In the discrete setting with $M$ valid unit contact normals, this is approximated by $\\mathbf{F} = \\dfrac{1}{M}\\sum_{c=1}^{M} \\hat{\\mathbf{n}}_c \\otimes \\hat{\\mathbf{n}}_c$, where $\\hat{\\mathbf{n}}_c = \\dfrac{\\mathbf{n}_c}{\\lVert \\mathbf{n}_c \\rVert}$ and $\\lVert \\mathbf{n}_c \\rVert \\neq 0$.\n\nYour program must:\n- Normalize each nonzero contact normal $\\mathbf{n}_c$ to unit length, discarding any zero-length vectors.\n- Compute $\\mathbf{F} = \\dfrac{1}{M}\\sum_{c=1}^{M} \\hat{\\mathbf{n}}_c \\otimes \\hat{\\mathbf{n}}_c$.\n- Compute the eigenvalues and eigenvectors of the symmetric tensor $\\mathbf{F}$.\n- Sort the eigenvalues in descending order and accordingly sort the eigenvectors.\n- For each test case, output the sorted eigenvalues and the principal direction, defined as the unit eigenvector associated with the largest eigenvalue.\n\nNumerical output requirements:\n- Round all floating-point numbers to six decimal places.\n- Angles are not required; all quantities are dimensionless.\n\nTest suite:\n- Case $1$ (nearly isotropic axis-aligned set): $\\left\\{(1,0,0),\\,(-1,0,0),\\,(0,1,0),\\,(0,-1,0),\\,(0,0,1),\\,(0,0,-1)\\right\\}$.\n- Case $2$ (strongly anisotropic aligned with $z$): $\\left\\{(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(1,0,0),\\,(0,1,0)\\right\\}$.\n- Case $3$ (anisotropy tilted in the $x$-$y$ plane): $\\left\\{(1,1,0),\\,(1,1,0),\\,(1,1,0),\\,(1,1,0),\\,(1,1,0),\\,(1,1,0),\\,(1,1,0),\\,(0.9,1.1,0),\\,(0,0,1)\\right\\}$.\n- Case $4$ (degenerate colinear case with a zero vector): $\\left\\{(1,0,0),\\,(1,0,0),\\,(1,0,0),\\,(1,0,0),\\,(1,0,0),\\,(0,0,0)\\right\\}$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case’s result must be a list of two lists: the first list contains the three sorted eigenvalues, and the second list contains the three components of the principal direction eigenvector, all rounded to six decimal places. For example, the overall structure must be of the form $\\left[\\left[\\left[\\lambda_1,\\lambda_2,\\lambda_3\\right],\\left[v_1,v_2,v_3\\right]\\right],\\ldots\\right]$ with no spaces after commas.",
            "solution": "The user-provided problem is first subjected to a rigorous validation process.\n\n### Step 1: Extract Givens\n- **Task**: Compute the fabric tensor $\\mathbf{F}$, its eigenvalues, and the principal direction for a given finite set of contact normals $\\{\\mathbf{n}_c\\}$.\n- **Context**: The problem is set within the Discrete Element Method (DEM) for modeling granular media.\n- **Definition of Fabric Tensor (Discrete)**: $\\mathbf{F} = \\dfrac{1}{M}\\sum_{c=1}^{M} \\hat{\\mathbf{n}}_c \\otimes \\hat{\\mathbf{n}}_c$.\n- **Definition of Unit Normal**: $\\hat{\\mathbf{n}}_c = \\dfrac{\\mathbf{n}_c}{\\lVert \\mathbf{n}_c \\rVert}$, where the norm $\\lVert \\mathbf{n}_c \\rVert \\neq 0$.\n- **Variable Definitions**:\n    - $\\{\\mathbf{n}_c\\}$: A set of real three-dimensional contact normal vectors.\n    - $M$: The number of valid (non-zero) contact normals.\n    - $\\otimes$: The dyadic (outer) product operator.\n- **Processing Rules**:\n    1. Each contact contributes equally.\n    2. Zero-length vectors ($\\lVert \\mathbf{n}_c \\rVert=0$) must be discarded and do not contribute to the calculation.\n    3. The eigenvalues of $\\mathbf{F}$ must be sorted in descending order.\n    4. The eigenvectors of $\\mathbf{F}$ must be sorted according to their corresponding eigenvalues.\n    5. The principal direction is defined as the unit eigenvector associated with the largest eigenvalue.\n- **Numerical Requirements**: All floating-point numerical outputs must be rounded to six decimal places.\n- **Test Suite**:\n    - Case $1$: $\\{\\mathbf{n}_c\\} = \\left\\{(1,0,0),\\,(-1,0,0),\\,(0,1,0),\\,(0,-1,0),\\,(0,0,1),\\,(0,0,-1)\\right\\}$.\n    - Case $2$: $\\{\\mathbf{n}_c\\} = \\left\\{(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(1,0,0),\\,(0,1,0)\\right\\}$.\n    - Case $3$: $\\{\\mathbf{n}_c\\} = \\left\\{(1,1,0),\\,(1,1,0),\\,(1,1,0),\\,(1,1,0),\\,(1,1,0),\\,(1,1,0),\\,(1,1,0),\\,(0.9,1.1,0),\\,(0,0,1)\\right\\}$.\n    - Case $4$: $\\{\\mathbf{n}_c\\} = \\left\\{(1,0,0),\\,(1,0,0),\\,(1,0,0),\\,(1,0,0),\\,(1,0,0),\\,(0,0,0)\\right\\}$.\n- **Output Format**: A single line string `[[[lambda1,lambda2,lambda3],[v1,v2,v3]],...]` with no spaces.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded**: The problem is based on the concept of the fabric tensor, a standard and fundamental quantity in the mechanics of granular materials and other disordered media. The provided formula for the discrete fabric tensor is the correct and widely accepted definition. The analysis via eigenvalue decomposition to find principal directions of anisotropy is a standard technique in tensor analysis. The problem is scientifically sound.\n2.  **Well-Posed**: The problem provides a clear, deterministic algorithm. For any given set of vectors, the procedure (filtering, normalization, summation, eigen-decomposition) leads to a unique result. The rule for handling zero vectors resolves ambiguity. While the principal direction for an isotropic tensor (where all three eigenvalues are equal) is mathematically not unique, a computational algorithm will produce a deterministic, valid eigenvector, making the problem computationally well-posed.\n3.  **Objective**: The problem is stated using precise mathematical and computational language. All terms are defined, and the required output is specified in an unambiguous format. It is free from subjective claims.\n4.  **Complete and Consistent**: All necessary information (formulas, test data, output format) is provided. There are no internal contradictions.\n5.  **Feasible and Relevant**: The computations required are standard linear algebra operations, feasible with common numerical libraries. The problem is directly relevant to the specified topic of *modeling of granular media: discrete element method (DEM)*.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It is scientifically grounded, well-posed, objective, and complete. A solution will be provided.\n\nThe objective is to compute the fabric tensor $\\mathbf{F}$, its eigenvalues, and its principal direction from a discrete set of contact normal vectors $\\{\\mathbf{n}_c\\}$. The procedure follows a sequence of well-defined steps derived from the principles of linear algebra and continuum mechanics adapted for a discrete system.\n\nFirst, the input set of vectors $\\{\\mathbf{n}_c\\}$ must be processed. For each vector $\\mathbf{n}_c$ in the set, its Euclidean norm $\\lVert \\mathbf{n}_c \\rVert$ is calculated. If the norm is zero (i.e., $\\mathbf{n}_c$ is the zero vector), the vector is discarded from further consideration as per the problem statement. For all non-zero vectors, a corresponding unit normal vector $\\hat{\\mathbf{n}}_c$ is computed by the normalization operation $\\hat{\\mathbf{n}}_c = \\mathbf{n}_c / \\lVert \\mathbf{n}_c \\rVert$. The total number of these valid, non-zero vectors is denoted by $M$.\n\nSecond, the fabric tensor $\\mathbf{F}$ is constructed. It is defined as the average of the dyadic products of the unit normal vectors. The dyadic product of a vector with itself, $\\hat{\\mathbf{n}}_c \\otimes \\hat{\\mathbf{n}}_c$, results in a symmetric $3 \\times 3$ matrix. For a unit normal $\\hat{\\mathbf{n}}_c = (n_x, n_y, n_z)^T$, this matrix is:\n$$\n\\hat{\\mathbf{n}}_c \\otimes \\hat{\\mathbf{n}}_c = \\begin{pmatrix} n_x^2 & n_x n_y & n_x n_z \\\\ n_y n_x & n_y^2 & n_y n_z \\\\ n_z n_x & n_z n_y & n_z^2 \\end{pmatrix}\n$$\nThe fabric tensor $\\mathbf{F}$ is the arithmetic mean of these individual matrices over all $M$ valid contacts:\n$$\n\\mathbf{F} = \\frac{1}{M} \\sum_{c=1}^{M} \\hat{\\mathbf{n}}_c \\otimes \\hat{\\mathbf{n}}_c\n$$\nSince each term $\\hat{\\mathbf{n}}_c \\otimes \\hat{\\mathbf{n}}_c$ is a symmetric matrix, their sum, and therefore $\\mathbf{F}$ itself, is also a real symmetric $3 \\times 3$ matrix. A key property of $\\mathbf{F}$ is that its trace is always unity: $\\mathrm{tr}(\\mathbf{F}) = \\frac{1}{M} \\sum_{c=1}^{M} \\mathrm{tr}(\\hat{\\mathbf{n}}_c \\otimes \\hat{\\mathbf{n}}_c) = \\frac{1}{M} \\sum_{c=1}^{M} \\lVert\\hat{\\mathbf{n}}_c\\rVert^2 = \\frac{1}{M} \\sum_{c=1}^{M} 1 = 1$. The eigenvalues of $\\mathbf{F}$ thus sum to $1$.\n\nThird, an eigenvalue decomposition of the fabric tensor $\\mathbf{F}$ is performed. This involves solving the characteristic equation $\\mathbf{F}\\mathbf{v} = \\lambda\\mathbf{v}$ for its eigenvalues $\\lambda$ and corresponding eigenvectors $\\mathbf{v}$. Because $\\mathbf{F}$ is a real symmetric matrix, it is guaranteed to have three real eigenvalues, which we denote $\\lambda_1, \\lambda_2, \\lambda_3$, and a set of three mutually orthogonal eigenvectors, $\\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{v}_3$. These eigenvalues represent the principal magnitudes of the fabric, and the eigenvectors represent the principal directions.\n\nFourth, the eigenvalues and eigenvectors are sorted and the principal direction is identified. The problem specifies sorting the eigenvalues in descending order: $\\lambda_1 \\ge \\lambda_2 \\ge \\lambda_3$. The eigenvectors must be ordered to correspond to this sorted sequence of eigenvalues. The principal direction of the fabric, which indicates the dominant orientation of the contact network, is defined as the unit eigenvector $\\mathbf{v}_1$ associated with the largest eigenvalue $\\lambda_1$.\n\nFinally, for implementation, these steps are executed for each test case. The resulting sorted eigenvalues $(\\lambda_1, \\lambda_2, \\lambda_3)$ and the components of the principal direction vector $\\mathbf{v}_1$ are rounded to six decimal places and formatted into the specified string format for the final output. Numerical libraries such as NumPy are well-suited for these tasks, providing robust functions for vector normalization, matrix operations, and the efficient and stable computation of eigenvalues and eigenvectors for symmetric matrices.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the fabric tensor problem for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (nearly isotropic axis-aligned set)\n        np.array([[1.0, 0.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 1.0, 0.0],\n                  [0.0, -1.0, 0.0], [0.0, 0.0, 1.0], [0.0, 0.0, -1.0]]),\n        \n        # Case 2 (strongly anisotropic aligned with z)\n        np.array([[0.0, 0.0, 1.0], [0.0, 0.0, 1.0], [0.0, 0.0, 1.0],\n                  [0.0, 0.0, 1.0], [0.0, 0.0, 1.0], [0.0, 0.0, 1.0],\n                  [0.0, 0.0, 1.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0],\n                  [0.0, 1.0, 0.0]]),\n\n        # Case 3 (anisotropy tilted in the x-y plane)\n        np.array([[1.0, 1.0, 0.0], [1.0, 1.0, 0.0], [1.0, 1.0, 0.0],\n                  [1.0, 1.0, 0.0], [1.0, 1.0, 0.0], [1.0, 1.0, 0.0],\n                  [1.0, 1.0, 0.0], [0.9, 1.1, 0.0], [0.0, 0.0, 1.0]]),\n\n        # Case 4 (degenerate colinear case with a zero vector)\n        np.array([[1.0, 0.0, 0.0], [1.0, 0.0, 0.0], [1.0, 0.0, 0.0],\n                  [1.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 0.0]])\n    ]\n\n    results_as_strings = []\n    \n    for vectors in test_cases:\n        # Step 1: Filter out zero-length vectors and normalize the rest.\n        norms = np.linalg.norm(vectors, axis=1)\n        # A small tolerance is better than direct comparison with 0 for floating point numbers.\n        valid_indices = np.where(norms > 1e-9)[0]\n        \n        if len(valid_indices) == 0:\n            # Handle edge case where all vectors are zero or list is empty.\n            # Fabric tensor is zero, eigenvalues are zero, principal direction is undefined.\n            # We can represent it as a zero vector.\n            eigenvalues = np.array([0.0, 0.0, 0.0])\n            principal_direction = np.array([0.0, 0.0, 0.0])\n        else:\n            valid_vectors = vectors[valid_indices]\n            valid_norms = norms[valid_indices]\n            unit_vectors = valid_vectors / valid_norms[:, np.newaxis]\n            \n            M = len(unit_vectors)\n\n            # Step 2: Compute the fabric tensor F.\n            fabric_tensor = np.zeros((3, 3))\n            for n_hat in unit_vectors:\n                fabric_tensor += np.outer(n_hat, n_hat)\n            fabric_tensor /= M\n\n            # Step 3: Compute eigenvalues and eigenvectors.\n            # np.linalg.eigh is for symmetric matrices. It's faster and more stable.\n            # It returns eigenvalues in ascending order.\n            eigenvalues, eigenvectors = np.linalg.eigh(fabric_tensor)\n            \n            # Step 4: Sort eigenvalues in descending order and sort eigenvectors accordingly.\n            sorted_indices = np.argsort(eigenvalues)[::-1]\n            sorted_eigenvalues = eigenvalues[sorted_indices]\n            sorted_eigenvectors = eigenvectors[:, sorted_indices]\n            \n            # The principal direction is the eigenvector of the largest eigenvalue.\n            principal_direction = sorted_eigenvectors[:, 0]\n\n            # Ensure principal direction has a consistent sign for deterministic output,\n            # e.g., make the element with largest absolute value positive.\n            max_abs_idx = np.argmax(np.abs(principal_direction))\n            if principal_direction[max_abs_idx] < 0:\n                principal_direction *= -1\n\n            eigenvalues = sorted_eigenvalues\n        \n        # Step 5: Format the output to six decimal places, without spaces.\n        eig_str = f\"[{','.join([f'{v:.6f}' for v in eigenvalues])}]\"\n        vec_str = f\"[{','.join([f'{v:.6f}' for v in principal_direction])}]\"\n        case_str = f\"[{eig_str},{vec_str}]\"\n        results_as_strings.append(case_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```"
        }
    ]
}