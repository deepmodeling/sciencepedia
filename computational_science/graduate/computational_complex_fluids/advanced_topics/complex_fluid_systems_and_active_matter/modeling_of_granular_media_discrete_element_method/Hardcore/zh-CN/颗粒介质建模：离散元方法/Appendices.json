{
    "hands_on_practices": [
        {
            "introduction": "离散元方法（DEM）的核心在于精确计算颗粒间的接触力。本练习将指导您实现一个切向接触模型，该模型包含一个线弹性弹簧和库仑摩擦定律 ``。通过应用在计算接触力学中广泛使用的“返回映射”算法，您将学习如何在一个显式时间步长方案中处理非线性的物理约束，这是模拟真实颗粒系统摩擦行为的关键一步。",
            "id": "4095033",
            "problem": "您正在离散元法（DEM）中对单个切向接触进行建模。该接触遵循牛顿定律和库仑摩擦定律。切向接触力被建模为一个线性弹性弹簧，其位移由切向平面内的滑移速度积分而来，并受库仑摩擦极限的约束。从时间积分累积速度得到位移以及摩擦力受库仑极限约束这些基本关系出发，推导并实现切向弹性弹簧位移和由此产生的切向力的更新算法。具体而言，对于一个给定的接触，已知法向力 $F_n \\ge 0$（压力为正）、摩擦系数 $\\mu \\ge 0$、切向刚度 $k_t > 0$、时间步长 $\\Delta t > 0$、局部切向平面中的切向滑移速度矢量 $\\boldsymbol{v}_t$ 以及同一平面中前一时刻的切向弹簧位移矢量 $\\boldsymbol{\\xi}^{old}$，请计算更新后的切向弹簧位移 $\\boldsymbol{\\xi}^{new}$ 和切向接触力 $\\boldsymbol{F}_t$，并强制施加库仑极限。\n\n使用的基本原理：\n- 牛顿第二定律和运动学：速度积分得到位移，因此弹性弹簧位移根据 $\\dfrac{d\\boldsymbol{\\xi}}{dt} = \\boldsymbol{v}_t$ 演化。\n- 线性弹性切向力：$\\boldsymbol{F}_t = -k_t \\boldsymbol{\\xi}$。\n- 库仑摩擦：$\\lVert \\boldsymbol{F}_t \\rVert \\le \\mu F_n$，并且在滑动时，$\\boldsymbol{F}_t$ 的方向与切向平面内的滑移趋势相反。\n\n您的程序必须：\n1. 使用 $\\boldsymbol{\\xi}^{trial} = \\boldsymbol{\\xi}^{old} + \\boldsymbol{v}_t \\Delta t$ 对切向弹簧位移进行显式时间积分试探更新。\n2. 计算相应的试探切向力 $\\boldsymbol{F}_t^{trial} = -k_t \\boldsymbol{\\xi}^{trial}$。\n3. 在必要时通过投影回容许集来强制施加库仑摩擦极限：\n   - 如果 $F_n \\le 0$，则接触点不承载，设置 $\\boldsymbol{\\xi}^{new} = \\boldsymbol{0}$ 和 $\\boldsymbol{F}_t = \\boldsymbol{0}$。\n   - 否则，如果 $\\lVert \\boldsymbol{F}_t^{trial} \\rVert \\le \\mu F_n$，则设置 $\\boldsymbol{\\xi}^{new} = \\boldsymbol{\\xi}^{trial}$ 和 $\\boldsymbol{F}_t = \\boldsymbol{F}_t^{trial}$（粘滞）。\n   - 否则（滑动），通过设置 $\\boldsymbol{\\xi}^{new} = \\boldsymbol{\\xi}^{trial} \\dfrac{\\mu F_n}{\\lVert \\boldsymbol{F}_t^{trial} \\rVert}$ 和 $\\boldsymbol{F}_t = -k_t \\boldsymbol{\\xi}^{new}$，将试探状态重缩放至库仑面上。这强制使得 $\\lVert \\boldsymbol{F}_t \\rVert = \\mu F_n$，且 $\\boldsymbol{F}_t$ 与切向平面内的试探方向对齐。\n\n所有矢量都是局部切向平面内的二维矢量。使用国际单位制：$\\boldsymbol{\\xi}^{new}$ 以 $\\mathrm{m}$ 表示，$\\boldsymbol{F}_t$ 以 $\\mathrm{N}$ 表示。无需使用角度。数值输出应表示为原始的十进制浮点数。\n\n测试套件：\n提供以下六个测试用例，每个用例由 $(F_n, \\mu, k_t, \\Delta t, \\boldsymbol{v}_t, \\boldsymbol{\\xi}^{old})$ 指定，并附有给定单位：\n- 用例 $1$（粘滞，小增量）：$F_n = 100\\,\\mathrm{N}$，$\\mu = 0.5$，$k_t = 10^4\\,\\mathrm{N/m}$，$\\Delta t = 10^{-3}\\,\\mathrm{s}$，$\\boldsymbol{v}_t = [0.01, 0]\\,\\mathrm{m/s}$，$\\boldsymbol{\\xi}^{old} = [0, 0]\\,\\mathrm{m}$。\n- 用例 $2$（滑动，大增量）：$F_n = 100\\,\\mathrm{N}$，$\\mu = 0.5$，$k_t = 10^4\\,\\mathrm{N/m}$，$\\Delta t = 10^{-3}\\,\\mathrm{s}$，$\\boldsymbol{v}_t = [10, 0]\\,\\mathrm{m/s}$，$\\boldsymbol{\\xi}^{old} = [0, 0]\\,\\mathrm{m}$。\n- 用例 $3$（边界，恰好在极限上）：$F_n = 100\\,\\mathrm{N}$，$\\mu = 0.5$，$k_t = 10^4\\,\\mathrm{N/m}$，$\\Delta t = 10^{-3}\\,\\mathrm{s}$，$\\boldsymbol{v}_t = [5, 0]\\,\\mathrm{m/s}$，$\\boldsymbol{\\xi}^{old} = [0, 0]\\,\\mathrm{m}$。\n- 用例 $4$（无接触）：$F_n = 0\\,\\mathrm{N}$，$\\mu = 0.5$，$k_t = 10^4\\,\\mathrm{N/m}$，$\\Delta t = 10^{-3}\\,\\mathrm{s}$，$\\boldsymbol{v}_t = [100, -100]\\,\\mathrm{m/s}$，$\\boldsymbol{\\xi}^{old} = [0, 0]\\,\\mathrm{m}$。\n- 用例 $5$（粘滞伴随斜向更新）：$F_n = 10\\,\\mathrm{N}$，$\\mu = 0.3$，$k_t = 2 \\times 10^4\\,\\mathrm{N/m}$，$\\Delta t = 2 \\times 10^{-3}\\,\\mathrm{s}$，$\\boldsymbol{v}_t = [0.003, -0.004]\\,\\mathrm{m/s}$，$\\boldsymbol{\\xi}^{old} = [10^{-4}, 0]\\,\\mathrm{m}$。\n- 用例 $6$（带有预加载弹簧的返回映射）：$F_n = 5\\,\\mathrm{N}$，$\\mu = 0.2$，$k_t = 10^4\\,\\mathrm{N/m}$，$\\Delta t = 10^{-3}\\,\\mathrm{s}$，$\\boldsymbol{v}_t = [0, 0]\\,\\mathrm{m/s}$，$\\boldsymbol{\\xi}^{old} = [10^{-2}, 10^{-2}]\\,\\mathrm{m}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个元素是对应测试用例的列表 $[\\xi_x, \\xi_y, F_{t,x}, F_{t,y}]$，单位为国际单位制（例如，$ [[\\dots],[\\dots],\\dots]$）。每个数值条目必须是十进制浮点数。",
            "solution": "该问题要求推导并实现一种数值算法，用于更新单个摩擦接触点的切向力和弹簧位移，这是离散元法（DEM）中常见的建模方式。该模型基于线性切向弹簧和库仑摩擦定律。问题陈述清晰，科学上合理，并提供了构建唯一解所需的所有信息。\n\n接触的物理状态由局部二维切向平面中的切向弹簧位移矢量 $\\boldsymbol{\\xi}$ 描述。假设切向力 $\\boldsymbol{F}_t$ 与此位移成线性比例关系：\n$$\n\\boldsymbol{F}_t = -k_t \\boldsymbol{\\xi}\n$$\n其中 $k_t > 0$ 是切向刚度。\n\n弹簧位移的演化由接触表面之间的相对切向速度（滑移速度）$\\boldsymbol{v}_t$ 控制。弹性位移的变化率等于滑移速度：\n$$\n\\frac{d\\boldsymbol{\\xi}}{dt} = \\boldsymbol{v}_t\n$$\n\n切向力的大小受库仑摩擦准则的限制。切向力必须位于一个容许集内，即在切向平面中由以下公式定义的圆盘：\n$$\n\\lVert \\boldsymbol{F}_t \\rVert \\le \\mu F_n\n$$\n其中 $F_n \\ge 0$ 是法向压力，$\\mu \\ge 0$ 是静摩擦系数。当力的大小达到极限 $\\lVert \\boldsymbol{F}_t \\rVert = \\mu F_n$ 时，接触处于宏观滑动状态，并且切向力矢量的方向必须与滑移速度的方向相反。\n\n将要实现的算法是一种显式时间步进的预测-校正格式，在计算塑性力学和接触力学中通常被称为“返回映射”算法。给定一个时间步长 $\\Delta t > 0$ 开始时的状态（由 $\\boldsymbol{\\xi}^{old}$ 表示），目标是计算该步长结束时的状态 $\\boldsymbol{\\xi}^{new}$ 和 $\\boldsymbol{F}_t$。\n\n**步骤1：试探（预测）步骤**\n首先，我们使用前向欧拉格式对 $\\boldsymbol{\\xi}$ 的演化方程进行离散化。这会产生一个试探位移 $\\boldsymbol{\\xi}^{trial}$，该位移假设在整个时间步长 $\\Delta t$ 内为纯弹性行为：\n$$\n\\boldsymbol{\\xi}^{trial} = \\boldsymbol{\\xi}^{old} + \\boldsymbol{v}_t \\Delta t\n$$\n根据此试探位移，计算出相应的试探切向力 $\\boldsymbol{F}_t^{trial}$：\n$$\n\\boldsymbol{F}_t^{trial} = -k_t \\boldsymbol{\\xi}^{trial}\n$$\n\n**步骤2：约束强制（校正）步骤**\n接下来，根据库仑摩擦约束检查试探状态。有三种可能的结果：\n\n**情况A：无接触**\n如果法向力 $F_n \\le 0$，则接触不活动或处于受拉状态。在颗粒材料的DEM中，通常不支持拉力，并且弹簧中任何现有的切向“记忆”都会丢失。因此，将切向位移和力重置为零。\n$$\n\\boldsymbol{\\xi}^{new} = \\boldsymbol{0} \\quad \\text{和} \\quad \\boldsymbol{F}_t = \\boldsymbol{0}\n$$\n\n**情况B：粘滞条件**\n如果接触是活动的（$F_n > 0$），并且试探力的大小在容许的摩擦圆盘内，则纯弹性假设成立。此即“粘滞”条件。\n$$\n\\text{如果 } \\lVert \\boldsymbol{F}_t^{trial} \\rVert \\le \\mu F_n, \\text{ 则接触点粘滞。}\n$$\n在这种情况下，试探值被接受为新状态的最终值：\n$$\n\\boldsymbol{\\xi}^{new} = \\boldsymbol{\\xi}^{trial}\n$$\n$$\n\\boldsymbol{F}_t = \\boldsymbol{F}_t^{trial}\n$$\n\n**情况C：滑动条件**\n如果接触是活动的（$F_n > 0$），并且试探力的大小超过了摩擦极限，则弹性假设无效。接触必须发生滑动，并且切向力必须位于摩擦圆盘的边界（即“摩擦圆”）上。\n$$\n\\text{如果 } \\lVert \\boldsymbol{F}_t^{trial} \\rVert > \\mu F_n, \\text{ 则接触点滑动。}\n$$\n校正后的力 $\\boldsymbol{F}_t$ 的大小必须恰好为 $\\mu F_n$，并且其方向必须与试探力 $\\boldsymbol{F}_t^{trial}$ 的方向相同。这通过将试探力矢量径向缩放回摩擦圆来实现。缩放因子是最大容许力大小与试探力大小之比。\n$$\n\\boldsymbol{F}_t = \\boldsymbol{F}_t^{trial} \\frac{\\mu F_n}{\\lVert \\boldsymbol{F}_t^{trial} \\rVert}\n$$\n这个新力的范数为 $\\lVert \\boldsymbol{F}_t \\rVert = \\left\\lVert \\boldsymbol{F}_t^{trial} \\frac{\\mu F_n}{\\lVert \\boldsymbol{F}_t^{trial} \\rVert} \\right\\rVert = \\lVert \\boldsymbol{F}_t^{trial} \\rVert \\frac{\\mu F_n}{\\lVert \\boldsymbol{F}_t^{trial} \\rVert} = \\mu F_n$，符合要求。\n由于力和位移通过常数 $-k_t$ 线性相关，最终位移 $\\boldsymbol{\\xi}^{new}$ 可通过将相同的缩放因子应用于试探位移 $\\boldsymbol{\\xi}^{trial}$ 来获得：\n$$\n\\boldsymbol{\\xi}^{new} = \\boldsymbol{\\xi}^{trial} \\frac{\\mu F_n}{\\lVert \\boldsymbol{F}_t^{trial} \\rVert}\n$$\n然后，最终的力可以一致地计算为 $\\boldsymbol{F}_t = -k_t \\boldsymbol{\\xi}^{new}$。\n\n这种预测-校正算法在显式DEM时间步进框架内，稳健而高效地施加了非光滑、非线性的库仑摩擦定律。我们现在将为给定的测试用例实现此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DEM tangential contact problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (stick, small increment)\n        {'Fn': 100.0, 'mu': 0.5, 'kt': 1e4, 'dt': 1e-3, 'vt': [0.01, 0.0], 'xi_old': [0.0, 0.0]},\n        # Case 2 (slide, large increment)\n        {'Fn': 100.0, 'mu': 0.5, 'kt': 1e4, 'dt': 1e-3, 'vt': [10.0, 0.0], 'xi_old': [0.0, 0.0]},\n        # Case 3 (boundary, exactly at limit)\n        {'Fn': 100.0, 'mu': 0.5, 'kt': 1e4, 'dt': 1e-3, 'vt': [5.0, 0.0], 'xi_old': [0.0, 0.0]},\n        # Case 4 (no contact)\n        {'Fn': 0.0, 'mu': 0.5, 'kt': 1e4, 'dt': 1e-3, 'vt': [100.0, -100.0], 'xi_old': [0.0, 0.0]},\n        # Case 5 (stick with oblique update)\n        {'Fn': 10.0, 'mu': 0.3, 'kt': 2e4, 'dt': 2e-3, 'vt': [0.003, -0.004], 'xi_old': [1e-4, 0.0]},\n        # Case 6 (return mapping with preloaded spring)\n        {'Fn': 5.0, 'mu': 0.2, 'kt': 1e4, 'dt': 1e-3, 'vt': [0.0, 0.0], 'xi_old': [1e-2, 1e-2]},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = update_tangential_contact(\n            case['Fn'], case['mu'], case['kt'], case['dt'],\n            np.array(case['vt']), np.array(case['xi_old'])\n        )\n        results.append(result)\n\n    # Format the final output string exactly as required\n    inner_parts = [f\"[{r[0]},{r[1]},{r[2]},{r[3]}]\" for r in results]\n    final_string = f\"[{','.join(inner_parts)}]\"\n    print(final_string)\n\ndef update_tangential_contact(Fn, mu, kt, dt, vt, xi_old):\n    \"\"\"\n    Computes the updated tangential spring displacement and contact force.\n\n    Args:\n        Fn (float): Normal force (N).\n        mu (float): Friction coefficient.\n        kt (float): Tangential stiffness (N/m).\n        dt (float): Time step (s).\n        vt (np.ndarray): Tangential slip velocity vector (m/s).\n        xi_old (np.ndarray): Previous tangential spring displacement vector (m).\n\n    Returns:\n        list: A list containing [xi_new_x, xi_new_y, Ft_x, Ft_y].\n    \"\"\"\n    # Case: No contact\n    if Fn = 0:\n        xi_new = np.zeros(2)\n        Ft = np.zeros(2)\n        return xi_new.tolist() + Ft.tolist()\n\n    # Step 1: Trial update (predictor)\n    xi_trial = xi_old + vt * dt\n\n    # Step 2: Compute trial force\n    Ft_trial = -kt * xi_trial\n\n    # Compute magnitude of trial force\n    norm_Ft_trial = np.linalg.norm(Ft_trial)\n\n    # Compute friction limit\n    friction_limit = mu * Fn\n\n    # Step 3: Enforce Coulomb friction limit (corrector)\n    # Case: Stick condition\n    if norm_Ft_trial = friction_limit:\n        xi_new = xi_trial\n        Ft = Ft_trial\n    # Case: Slip condition\n    else:\n        # The return mapping requires division by the norm of the trial force.\n        # This is safe because if norm_Ft_trial were 0, the 'if' condition\n        # (0 = friction_limit) would have been true (since mu*Fn >= 0).\n        scaling_factor = friction_limit / norm_Ft_trial\n        xi_new = xi_trial * scaling_factor\n        # The final force can be calculated either by scaling Ft_trial or\n        # by using the new displacement. The latter is more robust to\n        # potential floating point inconsistencies.\n        Ft = -kt * xi_new\n\n    # Return the result as a list of floats\n    return xi_new.tolist() + Ft.tolist()\n\nsolve()\n```"
        },
        {
            "introduction": "编写计算代码后，验证其正确性是至关重要的一步。本练习通过一个基础但极其重要的验证测试，来检验您的模拟程序的准确性 ``。您将把一个简单的线性弹簧-阻尼器模型下两颗粒碰撞的数值解与已知的解析解进行比较，并计算收敛率。这个过程不仅能证实您代码实现的正确性，还能加深对数值积分方案精度的理解。",
            "id": "4095007",
            "problem": "考虑两个球形颗粒之间的一次无摩擦的中心二元碰撞，该碰撞通过离散元法 (DEM) 使用线性法向弹簧-阻尼器接触定律进行建模。从牛顿第二定律出发，质量分别为 $\\,m_1\\,$ 和 $\\,m_2\\,$ 的颗粒沿其连心线的相对法向压缩量 $\\,\\xi(t)\\,$ 遵循以下常微分方程：\n$$\nm_{\\mathrm{eff}}\\,\\ddot{\\xi}(t) + c_n\\,\\dot{\\xi}(t) + k_n\\,\\xi(t) = 0,\n$$\n其中，等效质量为 $\\,m_{\\mathrm{eff}} = \\dfrac{m_1 m_2}{m_1 + m_2}\\,$，法向刚度为 $\\,k_n\\,$，法向阻尼为 $\\,c_n\\,$。假设碰撞在 $\\,t=0\\,$ 时开始，初始条件为 $\\,\\xi(0)=0\\,$ 和一个闭合相对速度 $\\,\\dot{\\xi}(0)=v_00\\,$。讨论限定在阻尼比 $\\,\\zeta  1\\,$ 的欠阻尼状态，其中阻尼比 $\\,\\zeta = \\dfrac{c_n}{2\\sqrt{k_n m_{\\mathrm{eff}}}}\\,$，无阻尼固有频率 $\\,\\omega_0 = \\sqrt{\\dfrac{k_n}{m_{\\mathrm{eff}}}}\\,$。阻尼固有频率为 $\\,\\omega_d = \\omega_0 \\sqrt{1-\\zeta^2}\\,$，接触持续时间（至分离的时间）为 $\\,t_c = \\dfrac{\\pi}{\\omega_d}\\,$。\n\n接触期间相对压缩量的解析解为：\n$$\n\\xi_{\\mathrm{ana}}(t) = \\frac{v_0}{\\omega_d}\\,e^{-\\zeta \\omega_0 t}\\,\\sin(\\omega_d t), \\quad 0 \\le t \\le t_c,\n$$\n相应的相对速度为：\n$$\n\\dot{\\xi}_{\\mathrm{ana}}(t) = v_0\\,e^{-\\zeta \\omega_0 t}\\left[\\cos(\\omega_d t) - \\frac{\\zeta \\omega_0}{\\omega_d}\\,\\sin(\\omega_d t)\\right]。\n$$\n\n一个用于相对运动的简单显式 DEM 时间积分器使用辛欧拉格式：\n$$\nv_{n+1} = v_n + \\frac{\\Delta t}{m_{\\mathrm{eff}}}\\,F_n, \\quad \\xi_{n+1} = \\xi_n + \\Delta t\\,v_{n+1},\n$$\n其中法向接触力为：\n$$\nF_n = -k_n\\,\\xi_n - c_n\\,v_n,\n$$\n初始条件为 $\\,\\xi_0 = 0\\,$ 和初始速度 $v_0$。对于给定的时间步长 $\\,\\Delta t\\,$，模拟进行到 $\\,t_{\\max} = N \\Delta t \\le t_c\\,$，其中 $\\,N = \\left\\lfloor \\dfrac{t_c}{\\Delta t} \\right\\rfloor\\,$。\n\n定义离散时间采样点 $\\,t_n = n \\Delta t\\,$，其中 $\\,n=1,2,\\dots,N\\,$，并计算数值压缩解 $\\,\\xi_{\\mathrm{num}}(t_n)\\,$ 相对于解析压缩解 $\\,\\xi_{\\mathrm{ana}}(t_n)\\,$ 的以下误差范数：\n- 在 $[0,t_{\\max}]$ 上的时间归一化 $\\,L^2\\,$ 范数：\n$$\nE_{2}(\\Delta t) = \\sqrt{\\frac{1}{t_{\\max}} \\sum_{n=1}^{N} \\left(\\xi_{\\mathrm{num}}(t_n) - \\xi_{\\mathrm{ana}}(t_n)\\right)^2 \\Delta t }。\n$$\n- 在 $[0,t_{\\max}]$ 上的 $\\,L^{\\infty}\\,$ 范数：\n$$\nE_{\\infty}(\\Delta t) = \\max_{1 \\le n \\le N} \\left| \\xi_{\\mathrm{num}}(t_n) - \\xi_{\\mathrm{ana}}(t_n) \\right|。\n$$\n\n使用三个递减的时间步长 $\\,\\Delta t_1, \\Delta t_2, \\Delta t_3\\,$，通过对 $\\,i=1,2,3\\,$ 的 $\\,\\log(E(\\Delta t_i))\\,$ 与 $\\,\\log(\\Delta t_i)\\,$ 的关系拟合一条直线并取其斜率，来评估观测到的时间步收敛率 $\\,p_2\\,$ 和 $\\,p_{\\infty}\\,$：\n$$\np \\approx \\frac{\\mathrm{d}\\log E}{\\mathrm{d}\\log \\Delta t}。\n$$\n\n实现一个程序，对下述每个测试用例，计算 $\\,i=1,2,3\\,$ 时的 $\\,E_2(\\Delta t_i)\\,$ 和 $\\,E_{\\infty}(\\Delta t_i)\\,$，确定 $\\,p_2\\,$ 和 $\\,p_{\\infty}\\,$，并输出这些收敛率。所有物理量必须使用国际单位制 (SI) 处理：质量单位为 kg，刚度单位为 N/m，阻尼单位为 N s/m，速度单位为 m/s，时间单位为 s。不使用角度。程序的最终输出必须是单行文本，包含一个用方括号括起来的逗号分隔的十进制数列表。每个数值需四舍五入到小数点后六位。该列表必须按顺序包含三个用例的 $[p_2^{(1)}, p_{\\infty}^{(1)}, p_2^{(2)}, p_{\\infty}^{(2)}, p_2^{(3)}, p_{\\infty}^{(3)}]$。\n\n测试套件：\n- 用例 $\\,1\\,$（中等阻尼，等质量）：$\\,m_1 = 1.0\\,\\mathrm{kg}\\,$, $\\,m_2 = 1.0\\,\\mathrm{kg}\\,$, $\\,k_n = 1.0\\times 10^{5}\\,\\mathrm{N/m}\\,$, $\\,c_n = 50.0\\,\\mathrm{N\\,s/m}\\,$, $\\,v_0 = 0.1\\,\\mathrm{m/s}\\,$, 时间步长 $\\,\\Delta t \\in \\{1.0\\times 10^{-4},\\, 5.0\\times 10^{-5},\\, 2.5\\times 10^{-5}\\}\\,\\mathrm{s}\\,$。\n- 用例 $\\,2\\,$（轻微阻尼，不等质量）：$\\,m_1 = 1.5\\,\\mathrm{kg}\\,$, $\\,m_2 = 0.7\\,\\mathrm{kg}\\,$, $\\,k_n = 8.0\\times 10^{4}\\,\\mathrm{N/m}\\,$, $\\,c_n = 30.0\\,\\mathrm{N\\,s/m}\\,$, $\\,v_0 = 0.05\\,\\mathrm{m/s}\\,$, 时间步长 $\\,\\Delta t \\in \\{1.0\\times 10^{-4},\\, 5.0\\times 10^{-5},\\, 2.5\\times 10^{-5}\\}\\,\\mathrm{s}\\,$。\n- 用例 $\\,3\\,$（重阻尼欠阻尼，不等质量）：$\\,m_1 = 2.0\\,\\mathrm{kg}\\,$, $\\,m_2 = 1.0\\,\\mathrm{kg}\\,$, $\\,k_n = 1.2\\times 10^{5}\\,\\mathrm{N/m}\\,$, $\\,c_n = 452.548\\,\\mathrm{N\\,s/m}\\,$, $\\,v_0 = 0.2\\,\\mathrm{m/s}\\,$, 时间步长 $\\,\\Delta t \\in \\{1.0\\times 10^{-4},\\, 5.0\\times 10^{-5},\\, 2.5\\times 10^{-5}\\}\\,\\mathrm{s}\\,$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$[r_1,r_2,r_3,r_4,r_5,r_6]$），每个速率值四舍五入到小数点后六位。",
            "solution": "该问题要求评估辛欧拉积分格式对离散元法 (DEM) 中模拟二元颗粒碰撞的阻尼谐振子模型的数值收敛率。该分析将通过比较三种不同测试用例的数值解与已知的解析解来执行。\n\n所考虑的系统是两个碰撞颗粒之间的相对运动。相对法向压缩量 $\\xi(t)$ 的控制方程是一个二阶线性常微分方程 (ODE)，其系数为常数：\n$$\nm_{\\mathrm{eff}}\\,\\ddot{\\xi}(t) + c_n\\,\\dot{\\xi}(t) + k_n\\,\\xi(t) = 0\n$$\n在此，$\\xi$ 是重叠量，$\\dot{\\xi}$ 是相对速度，$\\ddot{\\xi}$ 是相对加速度。物理参数包括等效质量 $m_{\\mathrm{eff}} = \\frac{m_1 m_2}{m_1 + m_2}$、法向刚度 $k_n$ 和法向阻尼系数 $c_n$。\n\n为了分析这个方程，通常将其重写为阻尼谐振子的标准形式：\n$$\n\\ddot{\\xi}(t) + 2\\zeta\\omega_0\\,\\dot{\\xi}(t) + \\omega_0^2\\,\\xi(t) = 0\n$$\n其中 $\\omega_0$ 是无阻尼固有频率，$\\zeta$ 是阻尼比。通过比较方程的两种形式，我们可以确定这些参数为：\n$$\n\\omega_0 = \\sqrt{\\frac{k_n}{m_{\\mathrm{eff}}}} \\quad \\text{和} \\quad 2\\zeta\\omega_0 = \\frac{c_n}{m_{\\mathrm{eff}}}\n$$\n由此可推导出阻尼比为：\n$$\n\\zeta = \\frac{c_n}{2 m_{\\mathrm{eff}} \\omega_0} = \\frac{c_n}{2 m_{\\mathrm{eff}} \\sqrt{k_n/m_{\\mathrm{eff}}}} = \\frac{c_n}{2\\sqrt{k_n m_{\\mathrm{eff}}}}\n$$\n问题限定在欠阻尼状态，即 $0 \\le \\zeta  1$。在这种状态下，特征方程具有共轭复数根，从而产生振荡解。阻尼固有频率 $\\omega_d$ 由下式给出：\n$$\n\\omega_d = \\omega_0 \\sqrt{1 - \\zeta^2}\n$$\n对于在时间 $t=0$ 开始碰撞的指定初始条件，我们有 $\\xi(0) = 0$（颗粒刚刚接触）和正的初始相对速度 $\\dot{\\xi}(0) = v_0  0$（颗粒相互靠近）。压缩量 $\\xi(t)$ 的解析解已正确给出：\n$$\n\\xi_{\\mathrm{ana}}(t) = \\frac{v_0}{\\omega_d}\\,e^{-\\zeta \\omega_0 t}\\,\\sin(\\omega_d t)\n$$\n只要颗粒重叠，即 $\\xi(t) \\ge 0$，接触就会维持。当 $\\xi(t)$ 在 $t  0$ 时首次回到零时，接触结束。这发生在 $\\sin(\\omega_d t) = 0$ 时，即首次发生在 $\\omega_d t = \\pi$。因此，总接触持续时间为 $t_c = \\frac{\\pi}{\\omega_d}$。\n\n数值解是使用辛欧拉方法（也称为 Euler-Cromer 方法）生成的。对于给定的时间步长 $\\Delta t$，系统在时间 $t_n = n \\Delta t$ 的状态 $(\\xi_n, v_n)$ 通过以下显式更新规则推进到时间 $t_{n+1}$ 的状态 $(\\xi_{n+1}, v_{n+1})$：\n$$\nv_{n+1} = v_n + \\frac{\\Delta t}{m_{\\mathrm{eff}}}\\,F_n\n$$\n$$\n\\xi_{n+1} = \\xi_n + \\Delta t\\,v_{n+1}\n$$\n在第 $n$ 步的接触力 $F_n$ 是该步状态的函数，由线性弹簧-阻尼器定律定义：\n$$\nF_n = -k_n\\,\\xi_n - c_n\\,v_n\n$$\n模拟从初始条件 $\\xi_0 = 0$ 和 $v_0$ 开始，进行 $N = \\lfloor t_c / \\Delta t \\rfloor$ 步，直到最大时间 $t_{\\max} = N \\Delta t$。\n\n为了量化数值格式的准确性，计算了两个误差范数。这些范数衡量了在离散时间点 $t_n = n \\Delta t$（其中 $n \\in \\{1, 2, \\dots, N\\}$）上数值解 $\\xi_{\\mathrm{num}}(t_n) = \\xi_n$ 与解析解 $\\xi_{\\mathrm{ana}}(t_n)$ 之间的差异。\n时间归一化的 $L^2$ 误差为：\n$$\nE_{2}(\\Delta t) = \\sqrt{\\frac{1}{t_{\\max}} \\sum_{n=1}^{N} \\left(\\xi_{\\mathrm{num}}(t_n) - \\xi_{\\mathrm{ana}}(t_n)\\right)^2 \\Delta t }\n$$\n$L^{\\infty}$ 误差，或最大绝对误差，为：\n$$\nE_{\\infty}(\\Delta t) = \\max_{1 \\le n \\le N} \\left| \\xi_{\\mathrm{num}}(t_n) - \\xi_{\\mathrm{ana}}(t_n) \\right|\n$$\n收敛率 $p$ 描述了误差 $E$ 如何随时间步长 $\\Delta t$ 缩放。对于一个 $p$ 阶方法，当 $\\Delta t \\to 0$ 时，误差预计表现为 $E(\\Delta t) \\approx C (\\Delta t)^p$，其中 $C$ 是某个常数。对该关系取对数可得：\n$$\n\\log(E) \\approx \\log(C) + p \\log(\\Delta t)\n$$\n这表明 $\\log(E)$ 与 $\\log(\\Delta t)$ 的关系图应为一条斜率为 $p$ 的直线。我们被要求通过对每个测试用例的三个数据点 $(\\log(\\Delta t_i), \\log(E(\\Delta t_i)))$ 进行线性最小二乘拟合来计算此斜率。辛欧拉方法已知是一阶精度方法，因此我们预计计算出的收敛率 $p_2$ 和 $p_\\infty$ 约为 1。\n\n总体算法如下：\n1.  对于三个测试用例中的每一个，检索物理参数 $m_1$, $m_2$, $k_n$, $c_n$, $v_0$ 和时间步长集合 $\\{\\Delta t_1, \\Delta t_2, \\Delta t_3\\}$。\n2.  计算派生的物理常数：$m_{\\mathrm{eff}}$, $\\omega_0$, $\\zeta$, $\\omega_d$ 和 $t_c$。\n3.  对于集合中的每个时间步长 $\\Delta t_i$：\n    a. 确定模拟步数 $N = \\lfloor t_c / \\Delta t_i \\rfloor$ 和最大模拟时间 $t_{\\max} = N \\Delta t_i$。\n    b. 初始化数值解的数组 $\\xi_{\\mathrm{num}}$ 和 $v_{\\mathrm{num}}$，初始值为 $\\xi_0 = 0$ 和 $v_0 = v_0$。\n    c. 执行从 $n=0$ 到 $N-1$ 的时间步循环，以计算数值轨迹。\n    d. 计算在 $n=1, \\dots, N$ 时对应的解析轨迹 $\\xi_{\\mathrm{ana}}(t_n)$。\n    e. 计算误差范数 $E_2(\\Delta t_i)$ 和 $E_\\infty(\\Delta t_i)$。\n4.  在计算完所有三个时间步长的误差后，创建两组数据点：$(\\log(\\Delta t_i), \\log(E_2(\\Delta t_i)))$ 和 $(\\log(\\Delta t_i), \\log(E_\\infty(\\Delta t_i)))$。\n5.  对每组点进行线性回归，以找到斜率，即收敛率 $p_2$ 和 $p_\\infty$。\n6.  收集六个计算出的收敛率，并将其格式化以供最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Computes the numerical convergence rates for a DEM collision model.\n\n    The function iterates through three test cases, each with a different set of\n    physical parameters. For each case, it simulates a particle collision using\n    the symplectic Euler method for three decreasing time steps. It calculates\n    the L2 and L-infinity error norms of the numerical compression against the\n    analytic solution. Finally, it determines the convergence rates by performing\n    a linear regression on the log-log plot of errors versus time steps.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"params\": (1.0, 1.0, 1.0e5, 50.0, 0.1),\n            \"dts\": [1.0e-4, 5.0e-5, 2.5e-5],\n        },\n        {\n            \"params\": (1.5, 0.7, 8.0e4, 30.0, 0.05),\n            \"dts\": [1.0e-4, 5.0e-5, 2.5e-5],\n        },\n        {\n            \"params\": (2.0, 1.0, 1.2e5, 452.548, 0.2),\n            \"dts\": [1.0e-4, 5.0e-5, 2.5e-5],\n        },\n    ]\n\n    all_rates = []\n\n    for case in test_cases:\n        m1, m2, kn, cn, v0 = case[\"params\"]\n        delta_ts = case[\"dts\"]\n        \n        # Calculate physical constants for the case\n        m_eff = (m1 * m2) / (m1 + m2)\n        omega0 = np.sqrt(kn / m_eff)\n        zeta = cn / (2 * np.sqrt(kn * m_eff))\n        \n        # Ensure the system is underdamped, as per problem statement\n        if zeta >= 1:\n            raise ValueError(f\"Damping ratio zeta={zeta} >= 1, not underdamped.\")\n            \n        omega_d = omega0 * np.sqrt(1 - zeta**2)\n        tc = np.pi / omega_d\n\n        errors_2 = []\n        errors_inf = []\n\n        for dt in delta_ts:\n            # Simulation setup\n            N = int(np.floor(tc / dt))\n            t_max = N * dt\n            \n            # Arrays for numerical solution\n            xi_num = np.zeros(N + 1)\n            v_num = np.zeros(N + 1)\n            xi_num[0] = 0.0\n            v_num[0] = v0\n\n            # Symplectic Euler time integration\n            for n in range(N):\n                force = -kn * xi_num[n] - cn * v_num[n]\n                v_num[n+1] = v_num[n] + (dt / m_eff) * force\n                xi_num[n+1] = xi_num[n] + dt * v_num[n+1]\n            \n            # The error norms are calculated for n=1 to N\n            xi_num_at_tn = xi_num[1:]\n            \n            # Generate analytic solution at corresponding time points\n            t_n = np.arange(1, N + 1) * dt\n            xi_ana_at_tn = (v0 / omega_d) * np.exp(-zeta * omega0 * t_n) * np.sin(omega_d * t_n)\n            \n            # Calculate error norms\n            diff = xi_num_at_tn - xi_ana_at_tn\n            \n            # L2 norm\n            e2 = np.sqrt((1 / t_max) * np.sum(diff**2) * dt)\n            errors_2.append(e2)\n            \n            # L-infinity norm\n            e_inf = np.max(np.abs(diff))\n            errors_inf.append(e_inf)\n\n        # Calculate convergence rates using linear regression on log-log data\n        log_dts = np.log(np.array(delta_ts))\n        \n        # p2 for L2 error\n        log_e2 = np.log(np.array(errors_2))\n        p2_result = linregress(log_dts, log_e2)\n        p2 = p2_result.slope\n        \n        # p_inf for L-infinity error\n        log_e_inf = np.log(np.array(errors_inf))\n        p_inf_result = linregress(log_dts, log_e_inf)\n        p_inf = p_inf_result.slope\n        \n        all_rates.extend([p2, p_inf])\n\n    # Format and print the final output\n    output_str = \",\".join([f\"{rate:.6f}\" for rate in all_rates])\n    print(f\"[{output_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一次经过验证的DEM模拟会产生海量数据，而关键在于从中提取有意义的物理洞见。本练习将向您展示如何从微观的接触网络信息中计算出一个宏观量——组构张量（fabric tensor） ``。通过分析这个张量，我们可以量化颗粒材料内部结构的各向异性，并将其与材料的宏观力学行为联系起来，这是连接微观结构与宏观响应的桥梁。",
            "id": "4095013",
            "problem": "给定一个通过离散元方法（DEM）模拟的颗粒组合中的有限接触法向向量集合 $\\{\\mathbf{n}_c\\}$。从接触网络组构张量是接触方向归一化二阶矩这一定义出发，计算组构张量 $\\mathbf{F}$、其特征值，并确定与最大特征值相关联的单位特征向量作为主方向。对于离散化，请作如下假设：每个接触的贡献相等，每个输入的接触法向向量都是一个实数三维向量，任何零长度向量不产生贡献且必须舍弃。\n\n基本原理：三维空间中接触网络的组构张量定义为单位接触法向向量并矢积的平均值。从单位球面上的方向分布函数 $p(\\mathbf{n})$（满足 $\\int_{\\mathbb{S}^2} p(\\mathbf{n}) \\,\\mathrm{d}S = 1$）出发，连续组构张量为 $\\mathbf{F} = \\int_{\\mathbb{S}^2} p(\\mathbf{n})\\, \\mathbf{n}\\otimes \\mathbf{n}\\,\\mathrm{d}S$。在具有 $M$ 个有效单位接触法向向量的离散情况下，这可以近似为 $\\mathbf{F} = \\dfrac{1}{M}\\sum_{c=1}^{M} \\hat{\\mathbf{n}}_c \\otimes \\hat{\\mathbf{n}}_c$，其中 $\\hat{\\mathbf{n}}_c = \\dfrac{\\mathbf{n}_c}{\\lVert \\mathbf{n}_c \\rVert}$ 且 $\\lVert \\mathbf{n}_c \\rVert \\neq 0$。\n\n您的程序必须：\n- 将每个非零接触法向向量 $\\mathbf{n}_c$ 归一化为单位长度，并舍弃任何零长度向量。\n- 计算 $\\mathbf{F} = \\dfrac{1}{M}\\sum_{c=1}^{M} \\hat{\\mathbf{n}}_c \\otimes \\hat{\\mathbf{n}}_c$。\n- 计算对称张量 $\\mathbf{F}$ 的特征值和特征向量。\n- 将特征值按降序排序，并相应地对特征向量进行排序。\n- 对于每个测试用例，输出排序后的特征值和主方向，主方向定义为与最大特征值相关联的单位特征向量。\n\n数值输出要求：\n- 将所有浮点数四舍五入到六位小数。\n- 不需要角度；所有量纲均为无量纲。\n\n测试套件：\n- 用例 $1$（近各向同性的轴对齐集合）：$\\left\\{(1,0,0),\\,(-1,0,0),\\,(0,1,0),\\,(0,-1,0),\\,(0,0,1),\\,(0,0,-1)\\right\\}$。\n- 用例 $2$（沿 $z$ 轴强各向异性）：$\\left\\{(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(1,0,0),\\,(0,1,0)\\right\\}$。\n- 用例 $3$（在 $x$-$y$ 平面内倾斜的各向异性）：$\\left\\{(1,1,0),\\,(1,1,0),\\,(1,1,0),\\,(1,1,0),\\,(1,1,0),\\,(1,1,0),\\,(1,1,0),\\,(0.9,1.1,0),\\,(0,0,1)\\right\\}$。\n- 用例 $4$（包含零向量的退化共线情况）：$\\left\\{(1,0,0),\\,(1,0,0),\\,(1,0,0),\\,(1,0,0),\\,(1,0,0),\\,(0,0,0)\\right\\}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是包含两个列表的列表：第一个列表包含三个排序后的特征值，第二个列表包含主方向特征向量的三个分量，所有数值均四舍五入到六位小数。例如，整体结构必须是 $\\left[\\left[\\left[\\lambda_1,\\lambda_2,\\lambda_3\\right],\\left[v_1,v_2,v_3\\right]\\right],\\ldots\\right]$ 的形式，逗号后没有空格。",
            "solution": "首先对用户提供的问题进行严格的验证过程。\n\n### 步骤 1：提取已知条件\n- **任务**：对于给定的有限接触法向向量集合 $\\{\\mathbf{n}_c\\}$，计算组构张量 $\\mathbf{F}$、其特征值和主方向。\n- **背景**：该问题设定在用于模拟颗粒介质的离散元方法（DEM）框架内。\n- **组构张量的定义（离散）**：$\\mathbf{F} = \\dfrac{1}{M}\\sum_{c=1}^{M} \\hat{\\mathbf{n}}_c \\otimes \\hat{\\mathbf{n}}_c$。\n- **单位法向向量的定义**：$\\hat{\\mathbf{n}}_c = \\dfrac{\\mathbf{n}_c}{\\lVert \\mathbf{n}_c \\rVert}$，其中范数 $\\lVert \\mathbf{n}_c \\rVert \\neq 0$。\n- **变量定义**：\n    - $\\{\\mathbf{n}_c\\}$：一组实数三维接触法向向量。\n    - $M$：有效（非零）接触法向向量的数量。\n    - $\\otimes$：并矢（外）积算子。\n- **处理规则**：\n    1. 每个接触的贡献相等。\n    2. 零长度向量（$\\lVert \\mathbf{n}_c \\rVert=0$）必须舍弃，不参与计算。\n    3. $\\mathbf{F}$ 的特征值必须按降序排序。\n    4. $\\mathbf{F}$ 的特征向量必须根据其对应的特征值进行排序。\n    5. 主方向定义为与最大特征值相关联的单位特征向量。\n- **数值要求**：所有浮点数值输出必须四舍五入到六位小数。\n- **测试套件**：\n    - 用例 $1$：$\\{\\mathbf{n}_c\\} = \\left\\{(1,0,0),\\,(-1,0,0),\\,(0,1,0),\\,(0,-1,0),\\,(0,0,1),\\,(0,0,-1)\\right\\}$。\n    - 用例 $2$：$\\{\\mathbf{n}_c\\} = \\left\\{(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(1,0,0),\\,(0,1,0)\\right\\}$。\n    - 用例 $3$：$\\{\\mathbf{n}_c\\} = \\left\\{(1,1,0),\\,(1,1,0),\\,(1,1,0),\\,(1,1,0),\\,(1,1,0),\\,(1,1,0),\\,(1,1,0),\\,(0.9,1.1,0),\\,(0,0,1)\\right\\}$。\n    - 用例 $4$：$\\{\\mathbf{n}_c\\} = \\left\\{(1,0,0),\\,(1,0,0),\\,(1,0,0),\\,(1,0,0),\\,(1,0,0),\\,(0,0,0)\\right\\}$。\n- **输出格式**：一个单行字符串 `[[[lambda1,lambda2,lambda3],[v1,v2,v3]],...]`，不带空格。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学依据**：该问题基于组构张量的概念，这是颗粒材料力学和其他无序介质中的一个标准和基本量。所提供的离散组构张量公式是正确且被广泛接受的定义。通过特征值分解来寻找各向异性主方向的分析是张量分析中的一种标准技术。该问题具有科学合理性。\n2.  **适定性**：该问题提供了一个清晰的、确定性的算法。对于任何给定的向量集，其处理过程（筛选、归一化、求和、特征分解）都会得到唯一的结果。处理零向量的规则消除了歧义。虽然对于各向同性张量（其中所有三个特征值都相等），主方向在数学上不是唯一的，但计算算法将产生一个确定性的、有效的特征向量，从而使问题在计算上是适定的。\n3.  **客观性**：该问题使用精确的数学和计算语言进行陈述。所有术语都已定义，所需的输出格式也以无歧义的方式指定。它不包含主观论断。\n4.  **完整性和一致性**：所有必要的信息（公式、测试数据、输出格式）都已提供。内部没有矛盾。\n5.  **可行性和相关性**：所需的计算是标准的线性代数运算，可以使用常见的数值库实现。该问题与指定的主题*颗粒介质建模：离散元方法（DEM）*直接相关。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。它具有科学依据、适定、客观且完整。将提供解决方案。\n\n目标是根据一组离散的接触法向向量 $\\{\\mathbf{n}_c\\}$ 计算组构张量 $\\mathbf{F}$、其特征值及其主方向。该过程遵循一系列明确定义的步骤，这些步骤源自适用于离散系统的线性代数和连续介质力学原理。\n\n首先，必须处理输入的向量集合 $\\{\\mathbf{n}_c\\}$。对于集合中的每个向量 $\\mathbf{n}_c$，计算其欧几里得范数 $\\lVert \\mathbf{n}_c \\rVert$。如果范数为零（即 $\\mathbf{n}_c$ 是零向量），则根据问题陈述，该向量将被舍弃，不作进一步考虑。对于所有非零向量，通过归一化操作 $\\hat{\\mathbf{n}}_c = \\mathbf{n}_c / \\lVert \\mathbf{n}_c \\rVert$ 计算出相应的单位法向向量 $\\hat{\\mathbf{n}}_c$。这些有效的、非零向量的总数用 $M$ 表示。\n\n其次，构建组构张量 $\\mathbf{F}$。它被定义为单位法向向量并矢积的平均值。一个向量与其自身的并矢积 $\\hat{\\mathbf{n}}_c \\otimes \\hat{\\mathbf{n}}_c$ 会产生一个对称的 $3 \\times 3$ 矩阵。对于一个单位法向向量 $\\hat{\\mathbf{n}}_c = (n_x, n_y, n_z)^T$，该矩阵为：\n$$\n\\hat{\\mathbf{n}}_c \\otimes \\hat{\\mathbf{n}}_c = \\begin{pmatrix} n_x^2  n_x n_y  n_x n_z \\\\ n_y n_x  n_y^2  n_y n_z \\\\ n_z n_x  n_z n_y  n_z^2 \\end{pmatrix}\n$$\n组构张量 $\\mathbf{F}$ 是所有 $M$ 个有效接触的这些单个矩阵的算术平均值：\n$$\n\\mathbf{F} = \\frac{1}{M} \\sum_{c=1}^{M} \\hat{\\mathbf{n}}_c \\otimes \\hat{\\mathbf{n}}_c\n$$\n由于每一项 $\\hat{\\mathbf{n}}_c \\otimes \\hat{\\mathbf{n}}_c$ 都是一个对称矩阵，它们的和，因此 $\\mathbf{F}$ 本身，也是一个实的对称 $3 \\times 3$ 矩阵。$\\mathbf{F}$ 的一个关键性质是其迹恒为 1：$\\mathrm{tr}(\\mathbf{F}) = \\frac{1}{M} \\sum_{c=1}^{M} \\mathrm{tr}(\\hat{\\mathbf{n}}_c \\otimes \\hat{\\mathbf{n}}_c) = \\frac{1}{M} \\sum_{c=1}^{M} \\lVert\\hat{\\mathbf{n}}_c\\rVert^2 = \\frac{1}{M} \\sum_{c=1}^{M} 1 = 1$。因此，$\\mathbf{F}$ 的特征值之和为 1。\n\n第三，对组构张量 $\\mathbf{F}$ 进行特征值分解。这涉及求解特征方程 $\\mathbf{F}\\mathbf{v} = \\lambda\\mathbf{v}$ 以得到其特征值 $\\lambda$ 和对应的特征向量 $\\mathbf{v}$。因为 $\\mathbf{F}$ 是一个实对称矩阵，所以它保证有三个实数特征值，我们记为 $\\lambda_1, \\lambda_2, \\lambda_3$，以及一组三个相互正交的特征向量 $\\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{v}_3$。这些特征值代表了组构的主值，而特征向量则代表了主方向。\n\n第四，对特征值和特征向量进行排序，并确定主方向。问题指定将特征值按降序排序：$\\lambda_1 \\ge \\lambda_2 \\ge \\lambda_3$。特征向量必须按此排序后的特征值序列进行相应排序。组构的主方向，它指明了接触网络的主要方向，被定义为与最大特征值 $\\lambda_1$ 相关联的单位特征向量 $\\mathbf{v}_1$。\n\n最后，在实现上，对每个测试用例执行这些步骤。将得到的排序后的特征值 $(\\lambda_1, \\lambda_2, \\lambda_3)$ 和主方向向量 $\\mathbf{v}_1$ 的分量四舍五入到六位小数，并格式化为指定的字符串格式作为最终输出。像 NumPy 这样的数值库非常适合这些任务，它们为向量归一化、矩阵运算以及对称矩阵特征值和特征向量的高效稳定计算提供了强大的函数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the fabric tensor problem for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (nearly isotropic axis-aligned set)\n        np.array([[1.0, 0.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 1.0, 0.0],\n                  [0.0, -1.0, 0.0], [0.0, 0.0, 1.0], [0.0, 0.0, -1.0]]),\n        \n        # Case 2 (strongly anisotropic aligned with z)\n        np.array([[0.0, 0.0, 1.0], [0.0, 0.0, 1.0], [0.0, 0.0, 1.0],\n                  [0.0, 0.0, 1.0], [0.0, 0.0, 1.0], [0.0, 0.0, 1.0],\n                  [0.0, 0.0, 1.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0],\n                  [0.0, 1.0, 0.0]]),\n\n        # Case 3 (anisotropy tilted in the x-y plane)\n        np.array([[1.0, 1.0, 0.0], [1.0, 1.0, 0.0], [1.0, 1.0, 0.0],\n                  [1.0, 1.0, 0.0], [1.0, 1.0, 0.0], [1.0, 1.0, 0.0],\n                  [1.0, 1.0, 0.0], [0.9, 1.1, 0.0], [0.0, 0.0, 1.0]]),\n\n        # Case 4 (degenerate colinear case with a zero vector)\n        np.array([[1.0, 0.0, 0.0], [1.0, 0.0, 0.0], [1.0, 0.0, 0.0],\n                  [1.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 0.0]])\n    ]\n\n    results_as_strings = []\n    \n    for vectors in test_cases:\n        # Step 1: Filter out zero-length vectors and normalize the rest.\n        norms = np.linalg.norm(vectors, axis=1)\n        # A small tolerance is better than direct comparison with 0 for floating point numbers.\n        valid_indices = np.where(norms > 1e-9)[0]\n        \n        if len(valid_indices) == 0:\n            # Handle edge case where all vectors are zero or list is empty.\n            # Fabric tensor is zero, eigenvalues are zero, principal direction is undefined.\n            # We can represent it as a zero vector.\n            eigenvalues = np.array([0.0, 0.0, 0.0])\n            principal_direction = np.array([0.0, 0.0, 0.0])\n        else:\n            valid_vectors = vectors[valid_indices]\n            valid_norms = norms[valid_indices]\n            unit_vectors = valid_vectors / valid_norms[:, np.newaxis]\n            \n            M = len(unit_vectors)\n\n            # Step 2: Compute the fabric tensor F.\n            fabric_tensor = np.zeros((3, 3))\n            for n_hat in unit_vectors:\n                fabric_tensor += np.outer(n_hat, n_hat)\n            fabric_tensor /= M\n\n            # Step 3: Compute eigenvalues and eigenvectors.\n            # np.linalg.eigh is for symmetric matrices. It's faster and more stable.\n            # It returns eigenvalues in ascending order.\n            eigenvalues, eigenvectors = np.linalg.eigh(fabric_tensor)\n            \n            # Step 4: Sort eigenvalues in descending order and sort eigenvectors accordingly.\n            sorted_indices = np.argsort(eigenvalues)[::-1]\n            sorted_eigenvalues = eigenvalues[sorted_indices]\n            sorted_eigenvectors = eigenvectors[:, sorted_indices]\n            \n            # The principal direction is the eigenvector of the largest eigenvalue.\n            principal_direction = sorted_eigenvectors[:, 0]\n\n            # Ensure principal direction has a consistent sign for deterministic output,\n            # e.g., make the element with largest absolute value positive.\n            max_abs_idx = np.argmax(np.abs(principal_direction))\n            if principal_direction[max_abs_idx]  0:\n                principal_direction *= -1\n\n            eigenvalues = sorted_eigenvalues\n        \n        # Step 5: Format the output to six decimal places, without spaces.\n        eig_str = f\"[{','.join([f'{v:.6f}' for v in eigenvalues])}]\"\n        vec_str = f\"[{','.join([f'{v:.6f}' for v in principal_direction])}]\"\n        case_str = f\"[{eig_str},{vec_str}]\"\n        results_as_strings.append(case_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```"
        }
    ]
}