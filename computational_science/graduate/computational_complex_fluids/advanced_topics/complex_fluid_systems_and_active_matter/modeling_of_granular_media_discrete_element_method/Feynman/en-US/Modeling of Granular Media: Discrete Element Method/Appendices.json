{
    "hands_on_practices": [
        {
            "introduction": "Before trusting complex simulations, we must verify that our code correctly solves problems with known outcomes. This practice uses a frictionless binary collision—a system analogous to a damped harmonic oscillator with an exact analytic solution—as a fundamental benchmark . By comparing the numerical results from a symplectic Euler integrator to this exact solution, you will not only validate an implementation but also quantitatively assess its accuracy and convergence rate, a cornerstone of verification and validation in computational science.",
            "id": "4095007",
            "problem": "Consider a frictionless, central binary collision between two spherical particles modeled by the Discrete Element Method (DEM) using a linear normal spring-dashpot contact law. Starting from Newton’s Second Law, the relative normal compression $\\,\\xi(t)\\,$ along the line-of-centers between particles of masses $\\,m_1\\,$ and $\\,m_2\\,$ obeys the ordinary differential equation\n$$\nm_{\\mathrm{eff}}\\,\\ddot{\\xi}(t) + c_n\\,\\dot{\\xi}(t) + k_n\\,\\xi(t) = 0,\n$$\nwhere the effective mass is $\\,m_{\\mathrm{eff}} = \\dfrac{m_1 m_2}{m_1 + m_2}\\,$, the normal stiffness is $\\,k_n\\,$, and the normal damping is $\\,c_n\\,$. Assume the collision initiates at $\\,t=0\\,$ with $\\,\\xi(0)=0\\,$ and a closing relative velocity $\\,\\dot{\\xi}(0)=v_00\\,$. Restrict to the underdamped regime $\\,\\zeta1\\,$ with the damping ratio $\\,\\zeta = \\dfrac{c_n}{2\\sqrt{k_n m_{\\mathrm{eff}}}}\\,$ and the undamped natural frequency $\\,\\omega_0 = \\sqrt{\\dfrac{k_n}{m_{\\mathrm{eff}}}}\\,$. The damped natural frequency is $\\,\\omega_d = \\omega_0 \\sqrt{1-\\zeta^2}\\,$, and the contact duration (time to separation) is $\\,t_c = \\dfrac{\\pi}{\\omega_d}\\,$.\n\nThe analytic solution for the relative compression during contact is\n$$\n\\xi_{\\mathrm{ana}}(t) = \\frac{v_0}{\\omega_d}\\,e^{-\\zeta \\omega_0 t}\\,\\sin(\\omega_d t), \\quad 0 \\le t \\le t_c,\n$$\nwith corresponding relative velocity\n$$\n\\dot{\\xi}_{\\mathrm{ana}}(t) = v_0\\,e^{-\\zeta \\omega_0 t}\\left[\\cos(\\omega_d t) - \\frac{\\zeta \\omega_0}{\\omega_d}\\,\\sin(\\omega_d t)\\right].\n$$\n\nA simple explicit DEM time integrator for the relative motion uses the symplectic Euler scheme:\n$$\nv_{n+1} = v_n + \\frac{\\Delta t}{m_{\\mathrm{eff}}}\\,F_n, \\quad \\xi_{n+1} = \\xi_n + \\Delta t\\,v_{n+1},\n$$\nwith the normal contact force\n$$\nF_n = -k_n\\,\\xi_n - c_n\\,v_n,\n$$\nand initial conditions $\\,\\xi_0 = 0\\,$, $\\,v_0 = v_0\\,$. For a given time step $\\,\\Delta t\\,$, simulate until $\\,t_{\\max} = N \\Delta t \\le t_c\\,$ with $\\,N = \\left\\lfloor \\dfrac{t_c}{\\Delta t} \\right\\rfloor\\,$.\n\nDefine the discrete-time sampling $\\,t_n = n \\Delta t\\,$ for $\\,n=1,2,\\dots,N\\,$, and compute the following error norms of the numerical compression $\\,\\xi_{\\mathrm{num}}(t_n)\\,$ relative to the analytic compression $\\,\\xi_{\\mathrm{ana}}(t_n)\\,$:\n- The time-normalized $\\,L^2\\,$ norm over $[0,t_{\\max}]$:\n$$\nE_{2}(\\Delta t) = \\sqrt{\\frac{1}{t_{\\max}} \\sum_{n=1}^{N} \\left(\\xi_{\\mathrm{num}}(t_n) - \\xi_{\\mathrm{ana}}(t_n)\\right)^2 \\Delta t }.\n$$\n- The $\\,L^{\\infty}\\,$ norm over $[0,t_{\\max}]$:\n$$\nE_{\\infty}(\\Delta t) = \\max_{1 \\le n \\le N} \\left| \\xi_{\\mathrm{num}}(t_n) - \\xi_{\\mathrm{ana}}(t_n) \\right|.\n$$\n\nUsing three decreasing time steps $\\,\\Delta t_1, \\Delta t_2, \\Delta t_3\\,$, assess the observed time-step convergence rates $\\,p_2\\,$ and $\\,p_{\\infty}\\,$ by fitting a straight line to $\\,\\log(E(\\Delta t_i))\\,$ versus $\\,\\log(\\Delta t_i)\\,$ for $\\,i=1,2,3\\,$ and taking the slope:\n$$\np \\approx \\frac{\\mathrm{d}\\log E}{\\mathrm{d}\\log \\Delta t}.\n$$\n\nImplement a program that, for each test case below, computes $\\,E_2(\\Delta t_i)\\,$ and $\\,E_{\\infty}(\\Delta t_i)\\,$ for $\\,i=1,2,3\\,$, determines $\\,p_2\\,$ and $\\,p_{\\infty}\\,$, and outputs the rates. All physical quantities must be handled in International System of Units (SI): masses in $\\,$kg$\\,$, stiffness in $\\,$\\mathrm{N/m}$\\,$, damping in $\\,$\\mathrm{N\\,s/m}$\\,$, velocities in $\\,$\\mathrm{m/s}$\\,$, and times in $\\,$\\mathrm{s}$\\,$. Angles are not used. The final program output must be a single line containing a comma-separated list of decimal numbers rounded to six digits after the decimal point, enclosed in square brackets. The list must contain, in order, $[p_2^{(1)}, p_{\\infty}^{(1)}, p_2^{(2)}, p_{\\infty}^{(2)}, p_2^{(3)}, p_{\\infty}^{(3)}]$ for the three cases.\n\nTest suite:\n- Case $\\,1\\,$ (moderately damped, equal masses): $\\,m_1 = 1.0\\,\\mathrm{kg}\\,$, $\\,m_2 = 1.0\\,\\mathrm{kg}\\,$, $\\,k_n = 1.0\\times 10^{5}\\,\\mathrm{N/m}\\,$, $\\,c_n = 50.0\\,\\mathrm{N\\,s/m}\\,$, $\\,v_0 = 0.1\\,\\mathrm{m/s}\\,$, time steps $\\,\\Delta t \\in \\{1.0\\times 10^{-4},\\, 5.0\\times 10^{-5},\\, 2.5\\times 10^{-5}\\}\\,\\mathrm{s}\\,$.\n- Case $\\,2\\,$ (lightly damped, unequal masses): $\\,m_1 = 1.5\\,\\mathrm{kg}\\,$, $\\,m_2 = 0.7\\,\\mathrm{kg}\\,$, $\\,k_n = 8.0\\times 10^{4}\\,\\mathrm{N/m}\\,$, $\\,c_n = 30.0\\,\\mathrm{N\\,s/m}\\,$, $\\,v_0 = 0.05\\,\\mathrm{m/s}\\,$, time steps $\\,\\Delta t \\in \\{1.0\\times 10^{-4},\\, 5.0\\times 10^{-5},\\, 2.5\\times 10^{-5}\\}\\,\\mathrm{s}\\,$.\n- Case $\\,3\\,$ (heavily damped underdamped, unequal masses): $\\,m_1 = 2.0\\,\\mathrm{kg}\\,$, $\\,m_2 = 1.0\\,\\mathrm{kg}\\,$, $\\,k_n = 1.2\\times 10^{5}\\,\\mathrm{N/m}\\,$, $\\,c_n = 452.548\\,\\mathrm{N\\,s/m}\\,$, $\\,v_0 = 0.2\\,\\mathrm{m/s}\\,$, time steps $\\,\\Delta t \\in \\{1.0\\times 10^{-4},\\, 5.0\\times 10^{-5},\\, 2.5\\times 10^{-5}\\}\\,\\mathrm{s}\\,$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5,r_6]$) with each rate rounded to six digits after the decimal point.",
            "solution": "The problem requires an assessment of the numerical convergence rate of the symplectic Euler integration scheme for a damped harmonic oscillator, which models a binary particle collision in the Discrete Element Method (DEM). The analysis will be performed by comparing the numerical solution to the known analytic solution for three distinct test cases.\n\nThe system under consideration is the relative motion between two colliding particles. The governing equation for the relative normal compression, $\\xi(t)$, is given as a second-order linear ordinary differential equation (ODE) with constant coefficients:\n$$\nm_{\\mathrm{eff}}\\,\\ddot{\\xi}(t) + c_n\\,\\dot{\\xi}(t) + k_n\\,\\xi(t) = 0\n$$\nHere, $\\xi$ is the overlap, $\\dot{\\xi}$ is the relative velocity, and $\\ddot{\\xi}$ is the relative acceleration. The physical parameters are the effective mass $m_{\\mathrm{eff}} = \\frac{m_1 m_2}{m_1 + m_2}$, the normal stiffness $k_n$, and the normal damping coefficient $c_n$.\n\nTo analyze this equation, it is standard to rewrite it in the canonical form of a damped harmonic oscillator:\n$$\n\\ddot{\\xi}(t) + 2\\zeta\\omega_0\\,\\dot{\\xi}(t) + \\omega_0^2\\,\\xi(t) = 0\n$$\nwhere $\\omega_0$ is the undamped natural frequency and $\\zeta$ is the damping ratio. By comparing the two forms of the equation, we identify these parameters as:\n$$\n\\omega_0 = \\sqrt{\\frac{k_n}{m_{\\mathrm{eff}}}} \\quad \\text{and} \\quad 2\\zeta\\omega_0 = \\frac{c_n}{m_{\\mathrm{eff}}}\n$$\nFrom this, the damping ratio is derived as:\n$$\n\\zeta = \\frac{c_n}{2 m_{\\mathrm{eff}} \\omega_0} = \\frac{c_n}{2 m_{\\mathrm{eff}} \\sqrt{k_n/m_{\\mathrm{eff}}}} = \\frac{c_n}{2\\sqrt{k_n m_{\\mathrm{eff}}}}\n$$\nThe problem is restricted to the underdamped regime, where $0 \\le \\zeta  1$. In this regime, the characteristic equation has complex conjugate roots, leading to an oscillatory solution. The damped natural frequency, $\\omega_d$, is given by:\n$$\n\\omega_d = \\omega_0 \\sqrt{1 - \\zeta^2}\n$$\nFor the specified initial conditions of a collision starting at time $t=0$, we have $\\xi(0) = 0$ (particles are just touching) and a positive initial relative velocity $\\dot{\\xi}(0) = v_0  0$ (particles are moving towards each other). The analytic solution for the compression $\\xi(t)$ is correctly given as:\n$$\n\\xi_{\\mathrm{ana}}(t) = \\frac{v_0}{\\omega_d}\\,e^{-\\zeta \\omega_0 t}\\,\\sin(\\omega_d t)\n$$\nContact is maintained as long as the particles are overlapping, i.e., $\\xi(t) \\ge 0$. The contact ends when $\\xi(t)$ first returns to zero for $t  0$. This occurs when $\\sin(\\omega_d t) = 0$, which first happens at $\\omega_d t = \\pi$. Therefore, the total contact duration is $t_c = \\frac{\\pi}{\\omega_d}$.\n\nThe numerical solution is generated using the symplectic Euler method, also known as the Euler-Cromer method. For a given time step $\\Delta t$, the state of the system $(\\xi_n, v_n)$ at time $t_n = n \\Delta t$ is advanced to the state $(\\xi_{n+1}, v_{n+1})$ at time $t_{n+1}$ by the explicit update rules:\n$$\nv_{n+1} = v_n + \\frac{\\Delta t}{m_{\\mathrm{eff}}}\\,F_n\n$$\n$$\n\\xi_{n+1} = \\xi_n + \\Delta t\\,v_{n+1}\n$$\nThe contact force $F_n$ at step $n$ is a function of the state at that step, defined by the linear spring-dashpot law:\n$$\nF_n = -k_n\\,\\xi_n - c_n\\,v_n\n$$\nThe simulation starts with the initial conditions $\\xi_0 = 0$ and $v_0 = v_0$, and proceeds for $N = \\lfloor t_c / \\Delta t \\rfloor$ steps, up to a maximum time of $t_{\\max} = N \\Delta t$.\n\nTo quantify the accuracy of the numerical scheme, two error norms are computed. These norms measure the discrepancy between the numerical solution, $\\xi_{\\mathrm{num}}(t_n) = \\xi_n$, and the analytic solution, $\\xi_{\\mathrm{ana}}(t_n)$, over the discrete time points $t_n = n \\Delta t$ for $n \\in \\{1, 2, \\dots, N\\}$.\nThe time-normalized $L^2$ error is:\n$$\nE_{2}(\\Delta t) = \\sqrt{\\frac{1}{t_{\\max}} \\sum_{n=1}^{N} \\left(\\xi_{\\mathrm{num}}(t_n) - \\xi_{\\mathrm{ana}}(t_n)\\right)^2 \\Delta t }\n$$\nThe $L^{\\infty}$ error, or maximum absolute error, is:\n$$\nE_{\\infty}(\\Delta t) = \\max_{1 \\le n \\le N} \\left| \\xi_{\\mathrm{num}}(t_n) - \\xi_{\\mathrm{ana}}(t_n) \\right|\n$$\nThe convergence rate, $p$, describes how the error $E$ scales with the time step $\\Delta t$. For a method of order $p$, the error is expected to behave as $E(\\Delta t) \\approx C (\\Delta t)^p$ for some constant $C$ as $\\Delta t \\to 0$. Taking the logarithm of this relationship yields:\n$$\n\\log(E) \\approx \\log(C) + p \\log(\\Delta t)\n$$\nThis shows that a plot of $\\log(E)$ versus $\\log(\\Delta t)$ should be a straight line with slope $p$. We are asked to compute this slope by performing a linear least-squares fit to the three data points $(\\log(\\Delta t_i), \\log(E(\\Delta t_i)))$ for each test case. The symplectic Euler method is known to be a first-order accurate method, so we expect the computed rates $p_2$ and $p_\\infty$ to be approximately $1$.\n\nThe overall algorithm is as follows:\n1. For each of the three test cases, retrieve the physical parameters $m_1$, $m_2$, $k_n$, $c_n$, $v_0$, and the set of time steps $\\{\\Delta t_1, \\Delta t_2, \\Delta t_3\\}$.\n2. Calculate the derived physical constants: $m_{\\mathrm{eff}}$, $\\omega_0$, $\\zeta$, $\\omega_d$, and $t_c$.\n3. For each time step $\\Delta t_i$ in the set:\n    a. Determine the number of simulation steps, $N = \\lfloor t_c / \\Delta t_i \\rfloor$, and the maximum simulation time $t_{\\max} = N \\Delta t_i$.\n    b. Initialize arrays for the numerical solution, $\\xi_{\\mathrm{num}}$ and $v_{\\mathrm{num}}$, with $\\xi_0 = 0$ and $v_0 = v_0$.\n    c. Execute the time-stepping loop for $n$ from $0$ to $N-1$ to compute the numerical trajectory.\n    d. Compute the corresponding analytical trajectory $\\xi_{\\mathrm{ana}}(t_n)$ for $n=1, \\dots, N$.\n    e. Calculate the error norms $E_2(\\Delta t_i)$ and $E_\\infty(\\Delta t_i)$.\n4. After computing the errors for all three time steps, create two sets of data points: $(\\log(\\Delta t_i), \\log(E_2(\\Delta t_i)))$ and $(\\log(\\Delta t_i), \\log(E_\\infty(\\Delta t_i)))$.\n5. Perform a linear regression on each set of points to find the slopes, which are the convergence rates $p_2$ and $p_\\infty$.\n6. Collect the six computed rates and format them for the final output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Computes the numerical convergence rates for a DEM collision model.\n\n    The function iterates through three test cases, each with a different set of\n    physical parameters. For each case, it simulates a particle collision using\n    the symplectic Euler method for three decreasing time steps. It calculates\n    the L2 and L-infinity error norms of the numerical compression against the\n    analytic solution. Finally, it determines the convergence rates by performing\n    a linear regression on the log-log plot of errors versus time steps.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"params\": (1.0, 1.0, 1.0e5, 50.0, 0.1),\n            \"dts\": [1.0e-4, 5.0e-5, 2.5e-5],\n        },\n        {\n            \"params\": (1.5, 0.7, 8.0e4, 30.0, 0.05),\n            \"dts\": [1.0e-4, 5.0e-5, 2.5e-5],\n        },\n        {\n            \"params\": (2.0, 1.0, 1.2e5, 452.548, 0.2),\n            \"dts\": [1.0e-4, 5.0e-5, 2.5e-5],\n        },\n    ]\n\n    all_rates = []\n\n    for case in test_cases:\n        m1, m2, kn, cn, v0 = case[\"params\"]\n        delta_ts = case[\"dts\"]\n        \n        # Calculate physical constants for the case\n        m_eff = (m1 * m2) / (m1 + m2)\n        omega0 = np.sqrt(kn / m_eff)\n        zeta = cn / (2 * np.sqrt(kn * m_eff))\n        \n        # Ensure the system is underdamped, as per problem statement\n        if zeta = 1:\n            raise ValueError(f\"Damping ratio zeta={zeta} = 1, not underdamped.\")\n            \n        omega_d = omega0 * np.sqrt(1 - zeta**2)\n        tc = np.pi / omega_d\n\n        errors_2 = []\n        errors_inf = []\n\n        for dt in delta_ts:\n            # Simulation setup\n            N = int(np.floor(tc / dt))\n            t_max = N * dt\n            \n            # Arrays for numerical solution\n            xi_num = np.zeros(N + 1)\n            v_num = np.zeros(N + 1)\n            xi_num[0] = 0.0\n            v_num[0] = v0\n\n            # Symplectic Euler time integration\n            for n in range(N):\n                force = -kn * xi_num[n] - cn * v_num[n]\n                v_num[n+1] = v_num[n] + (dt / m_eff) * force\n                xi_num[n+1] = xi_num[n] + dt * v_num[n+1]\n            \n            # The error norms are calculated for n=1 to N\n            xi_num_at_tn = xi_num[1:]\n            \n            # Generate analytic solution at corresponding time points\n            t_n = np.arange(1, N + 1) * dt\n            xi_ana_at_tn = (v0 / omega_d) * np.exp(-zeta * omega0 * t_n) * np.sin(omega_d * t_n)\n            \n            # Calculate error norms\n            diff = xi_num_at_tn - xi_ana_at_tn\n            \n            # L2 norm\n            e2 = np.sqrt((1 / t_max) * np.sum(diff**2) * dt)\n            errors_2.append(e2)\n            \n            # L-infinity norm\n            e_inf = np.max(np.abs(diff))\n            errors_inf.append(e_inf)\n\n        # Calculate convergence rates using linear regression on log-log data\n        log_dts = np.log(np.array(delta_ts))\n        \n        # p2 for L2 error\n        log_e2 = np.log(np.array(errors_2))\n        p2_result = linregress(log_dts, log_e2)\n        p2 = p2_result.slope\n        \n        # p_inf for L-infinity error\n        log_e_inf = np.log(np.array(errors_inf))\n        p_inf_result = linregress(log_dts, log_e_inf)\n        p_inf = p_inf_result.slope\n        \n        all_rates.extend([p2, p_inf])\n\n    # Format and print the final output\n    output_str = \",\".join([f\"{rate:.6f}\" for rate in all_rates])\n    print(f\"[{output_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The behavior of real granular materials is dominated by frictional interactions at particle contacts. This practice moves beyond simple linear forces and dives into the heart of the DEM force calculation loop by implementing a robust model for tangential forces that includes both elastic \"stick\" and plastic \"slip\" governed by the Coulomb friction criterion . Mastering the predictor-corrector \"return mapping\" algorithm is essential for simulating realistic granular phenomena like shear strength and jamming.",
            "id": "4095033",
            "problem": "You are modeling a single tangential contact in the Discrete Element Method (DEM). The contact obeys Newton's laws and Coulomb friction. The tangential contact force is modeled as a linear elastic spring integrated from the slip velocity in the tangential plane, with a Coulomb friction limit. Starting from the fundamental relations that time integration accumulates displacement from velocity and that friction is bounded by the Coulomb limit, derive and implement the update for the tangential elastic spring displacement and the resulting tangential force. Specifically, for a given contact with normal force $F_n \\ge 0$ (compressive positive), friction coefficient $\\mu \\ge 0$, tangential stiffness $k_t  0$, time step $\\Delta t  0$, tangential slip velocity vector $\\boldsymbol{v}_t$ in the local tangential plane, and previous tangential spring displacement vector $\\boldsymbol{\\xi}^{old}$ in the same plane, compute the updated tangential spring displacement $\\boldsymbol{\\xi}^{new}$ and the tangential contact force $\\boldsymbol{F}_t$, enforcing the Coulomb limit.\n\nFundamental base to use:\n- Newton's Second Law and kinematics: velocity integrates to displacement, so the elastic spring displacement evolves according to $\\dfrac{d\\boldsymbol{\\xi}}{dt} = \\boldsymbol{v}_t$.\n- Linear elastic tangential force: $\\boldsymbol{F}_t = -k_t \\boldsymbol{\\xi}$.\n- Coulomb friction: $\\lVert \\boldsymbol{F}_t \\rVert \\le \\mu F_n$ and, under sliding, $\\boldsymbol{F}_t$ is directed opposite the slip tendency in the tangential plane.\n\nYour program must:\n1. Perform an explicit time integration trial update of the tangential spring displacement using $\\boldsymbol{\\xi}^{trial} = \\boldsymbol{\\xi}^{old} + \\boldsymbol{v}_t \\Delta t$.\n2. Compute the corresponding trial tangential force $\\boldsymbol{F}_t^{trial} = -k_t \\boldsymbol{\\xi}^{trial}$.\n3. Enforce the Coulomb friction limit by projecting back to the admissible set when necessary:\n   - If $F_n \\le 0$ then the contact is non-load bearing, and set $\\boldsymbol{\\xi}^{new} = \\boldsymbol{0}$ and $\\boldsymbol{F}_t = \\boldsymbol{0}$.\n   - Else if $\\lVert \\boldsymbol{F}_t^{trial} \\rVert \\le \\mu F_n$, then set $\\boldsymbol{\\xi}^{new} = \\boldsymbol{\\xi}^{trial}$ and $\\boldsymbol{F}_t = \\boldsymbol{F}_t^{trial}$ (stick).\n   - Else (slide), rescale the trial state to the Coulomb surface by setting $\\boldsymbol{\\xi}^{new} = \\boldsymbol{\\xi}^{trial} \\dfrac{\\mu F_n}{\\lVert \\boldsymbol{F}_t^{trial} \\rVert}$ and $\\boldsymbol{F}_t = -k_t \\boldsymbol{\\xi}^{new}$. This enforces $\\lVert \\boldsymbol{F}_t \\rVert = \\mu F_n$ with $\\boldsymbol{F}_t$ aligned with the trial direction in the tangential plane.\n\nAll vectors are two-dimensional in the local tangential plane. Use the International System of Units: express $\\boldsymbol{\\xi}^{new}$ in $\\mathrm{m}$ and $\\boldsymbol{F}_t$ in $\\mathrm{N}$. No angles are required. The numerical output shall be expressed as raw decimal floats.\n\nTest suite:\nProvide the following six test cases, each specified by $(F_n, \\mu, k_t, \\Delta t, \\boldsymbol{v}_t, \\boldsymbol{\\xi}^{old})$ with the given units:\n- Case $1$ (stick, small increment): $F_n = 100\\,\\mathrm{N}$, $\\mu = 0.5$, $k_t = 10^4\\,\\mathrm{N/m}$, $\\Delta t = 10^{-3}\\,\\mathrm{s}$, $\\boldsymbol{v}_t = [0.01, 0]\\,\\mathrm{m/s}$, $\\boldsymbol{\\xi}^{old} = [0, 0]\\,\\mathrm{m}$.\n- Case $2$ (slide, large increment): $F_n = 100\\,\\mathrm{N}$, $\\mu = 0.5$, $k_t = 10^4\\,\\mathrm{N/m}$, $\\Delta t = 10^{-3}\\,\\mathrm{s}$, $\\boldsymbol{v}_t = [10, 0]\\,\\mathrm{m/s}$, $\\boldsymbol{\\xi}^{old} = [0, 0]\\,\\mathrm{m}$.\n- Case $3$ (boundary, exactly at limit): $F_n = 100\\,\\mathrm{N}$, $\\mu = 0.5$, $k_t = 10^4\\,\\mathrm{N/m}$, $\\Delta t = 10^{-3}\\,\\mathrm{s}$, $\\boldsymbol{v}_t = [5, 0]\\,\\mathrm{m/s}$, $\\boldsymbol{\\xi}^{old} = [0, 0]\\,\\mathrm{m}$.\n- Case $4$ (no contact): $F_n = 0\\,\\mathrm{N}$, $\\mu = 0.5$, $k_t = 10^4\\,\\mathrm{N/m}$, $\\Delta t = 10^{-3}\\,\\mathrm{s}$, $\\boldsymbol{v}_t = [100, -100]\\,\\mathrm{m/s}$, $\\boldsymbol{\\xi}^{old} = [0, 0]\\,\\mathrm{m}$.\n- Case $5$ (stick with oblique update): $F_n = 10\\,\\mathrm{N}$, $\\mu = 0.3$, $k_t = 2 \\times 10^4\\,\\mathrm{N/m}$, $\\Delta t = 2 \\times 10^{-3}\\,\\mathrm{s}$, $\\boldsymbol{v}_t = [0.003, -0.004]\\,\\mathrm{m/s}$, $\\boldsymbol{\\xi}^{old} = [10^{-4}, 0]\\,\\mathrm{m}$.\n- Case $6$ (return mapping with preloaded spring): $F_n = 5\\,\\mathrm{N}$, $\\mu = 0.2$, $k_t = 10^4\\,\\mathrm{N/m}$, $\\Delta t = 10^{-3}\\,\\mathrm{s}$, $\\boldsymbol{v}_t = [0, 0]\\,\\mathrm{m/s}$, $\\boldsymbol{\\xi}^{old} = [10^{-2}, 10^{-2}]\\,\\mathrm{m}$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the list $[\\xi_x, \\xi_y, F_{t,x}, F_{t,y}]$ for the corresponding test case in SI units (for example, $[[\\dots],[\\dots],\\dots]$). Each numerical entry must be a decimal float.",
            "solution": "The problem requires the derivation and implementation of a numerical algorithm to update the tangential force and spring displacement at a single frictional contact, as commonly modeled in the Discrete Element Method (DEM). The model is based on a linear tangential spring and the Coulomb friction law. The problem is well-posed, scientifically sound, and provides all necessary information to construct a unique solution.\n\nThe physical state of the contact is described by the tangential spring displacement vector $\\boldsymbol{\\xi}$ in the local $2$D tangential plane. The tangential force $\\boldsymbol{F}_t$ is assumed to be linearly proportional to this displacement:\n$$\n\\boldsymbol{F}_t = -k_t \\boldsymbol{\\xi}\n$$\nwhere $k_t  0$ is the tangential stiffness.\n\nThe evolution of the spring displacement is governed by the relative tangential velocity (slip velocity) $\\boldsymbol{v}_t$ between the contacting surfaces. The rate of change of the elastic displacement is equal to the slip velocity:\n$$\n\\frac{d\\boldsymbol{\\xi}}{dt} = \\boldsymbol{v}_t\n$$\n\nThe magnitude of the tangential force is limited by the Coulomb friction criterion. The tangential force must lie within an admissible set, a disk in the tangential plane defined by:\n$$\n\\lVert \\boldsymbol{F}_t \\rVert \\le \\mu F_n\n$$\nwhere $F_n \\ge 0$ is the compressive normal force and $\\mu \\ge 0$ is the coefficient of static friction. When the force magnitude reaches the limit, $\\lVert \\boldsymbol{F}_t \\rVert = \\mu F_n$, the contact is in a state of gross sliding, and the tangential force vector must oppose the direction of slip velocity.\n\nThe algorithm to be implemented is an explicit time-stepping scheme of the predictor-corrector type, often referred to as a \"return mapping\" algorithm in computational plasticity and contact mechanics. Given the state at the beginning of a time step $\\Delta t  0$ (represented by $\\boldsymbol{\\xi}^{old}$), the goal is to compute the state at the end of the step, $\\boldsymbol{\\xi}^{new}$ and $\\boldsymbol{F}_t$.\n\n**Step 1: Trial (Predictor) Step**\nFirst, we discretize the evolution equation for $\\boldsymbol{\\xi}$ using a forward Euler scheme. This yields a trial displacement, $\\boldsymbol{\\xi}^{trial}$, which assumes purely elastic behavior throughout the time step $\\Delta t$:\n$$\n\\boldsymbol{\\xi}^{trial} = \\boldsymbol{\\xi}^{old} + \\boldsymbol{v}_t \\Delta t\n$$\nFrom this trial displacement, a corresponding trial tangential force, $\\boldsymbol{F}_t^{trial}$, is computed:\n$$\n\\boldsymbol{F}_t^{trial} = -k_t \\boldsymbol{\\xi}^{trial}\n$$\n\n**Step 2: Constraint Enforcement (Corrector) Step**\nNext, the trial state is checked against the Coulomb friction constraint. There are three possible outcomes:\n\n**Case A: No Contact**\nIf the normal force $F_n \\le 0$, the contact is not active or is tensile. In DEM for granular materials, tensile forces are typically not supported, and any existing tangential \"memory\" in the spring is lost. Therefore, the tangential displacement and force are reset to zero.\n$$\n\\boldsymbol{\\xi}^{new} = \\boldsymbol{0} \\quad \\text{and} \\quad \\boldsymbol{F}_t = \\boldsymbol{0}\n$$\n\n**Case B: Stick Condition**\nIf the contact is active ($F_n  0$) and the magnitude of the trial force is within the admissible friction disk, the purely elastic assumption holds. This is the \"stick\" condition.\n$$\n\\text{If } \\lVert \\boldsymbol{F}_t^{trial} \\rVert \\le \\mu F_n, \\text{ then the contact sticks.}\n$$\nIn this case, the trial values are accepted as the final values for the new state:\n$$\n\\boldsymbol{\\xi}^{new} = \\boldsymbol{\\xi}^{trial}\n$$\n$$\n\\boldsymbol{F}_t = \\boldsymbol{F}_t^{trial}\n$$\n\n**Case C: Slip Condition**\nIf the contact is active ($F_n  0$) and the magnitude of the trial force exceeds the friction limit, the elastic assumption is invalid. The contact must slip, and the tangential force must lie on the boundary of the friction disk (the \"friction circle\").\n$$\n\\text{If } \\lVert \\boldsymbol{F}_t^{trial} \\rVert  \\mu F_n, \\text{ then the contact slips.}\n$$\nThe corrected force $\\boldsymbol{F}_t$ must have a magnitude of exactly $\\mu F_n$ and must point in the same direction as the trial force $\\boldsymbol{F}_t^{trial}$. This is achieved by radially scaling the trial force vector back to the friction circle. The scaling factor is the ratio of the maximum allowable force magnitude to the trial force magnitude.\n$$\n\\boldsymbol{F}_t = \\boldsymbol{F}_t^{trial} \\frac{\\mu F_n}{\\lVert \\boldsymbol{F}_t^{trial} \\rVert}\n$$\nThe norm of this new force is $\\lVert \\boldsymbol{F}_t \\rVert = \\left\\lVert \\boldsymbol{F}_t^{trial} \\frac{\\mu F_n}{\\lVert \\boldsymbol{F}_t^{trial} \\rVert} \\right\\rVert = \\lVert \\boldsymbol{F}_t^{trial} \\rVert \\frac{\\mu F_n}{\\lVert \\boldsymbol{F}_t^{trial} \\rVert} = \\mu F_n$, as required.\nSince the force and displacement are linearly related by the constant $-k_t$, the final displacement $\\boldsymbol{\\xi}^{new}$ is obtained by applying the same scaling factor to the trial displacement $\\boldsymbol{\\xi}^{trial}$:\n$$\n\\boldsymbol{\\xi}^{new} = \\boldsymbol{\\xi}^{trial} \\frac{\\mu F_n}{\\lVert \\boldsymbol{F}_t^{trial} \\rVert}\n$$\nThe final force can then be computed consistently as $\\boldsymbol{F}_t = -k_t \\boldsymbol{\\xi}^{new}$.\n\nThis predictor-corrector algorithm robustly and efficiently enforces the non-smooth, non-linear Coulomb friction law within an explicit DEM time-stepping framework. We will now implement this procedure for the given test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DEM tangential contact problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (stick, small increment)\n        {'Fn': 100.0, 'mu': 0.5, 'kt': 1e4, 'dt': 1e-3, 'vt': [0.01, 0.0], 'xi_old': [0.0, 0.0]},\n        # Case 2 (slide, large increment)\n        {'Fn': 100.0, 'mu': 0.5, 'kt': 1e4, 'dt': 1e-3, 'vt': [10.0, 0.0], 'xi_old': [0.0, 0.0]},\n        # Case 3 (boundary, exactly at limit)\n        {'Fn': 100.0, 'mu': 0.5, 'kt': 1e4, 'dt': 1e-3, 'vt': [5.0, 0.0], 'xi_old': [0.0, 0.0]},\n        # Case 4 (no contact)\n        {'Fn': 0.0, 'mu': 0.5, 'kt': 1e4, 'dt': 1e-3, 'vt': [100.0, -100.0], 'xi_old': [0.0, 0.0]},\n        # Case 5 (stick with oblique update)\n        {'Fn': 10.0, 'mu': 0.3, 'kt': 2e4, 'dt': 2e-3, 'vt': [0.003, -0.004], 'xi_old': [1e-4, 0.0]},\n        # Case 6 (return mapping with preloaded spring)\n        {'Fn': 5.0, 'mu': 0.2, 'kt': 1e4, 'dt': 1e-3, 'vt': [0.0, 0.0], 'xi_old': [1e-2, 1e-2]},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = update_tangential_contact(\n            case['Fn'], case['mu'], case['kt'], case['dt'],\n            np.array(case['vt']), np.array(case['xi_old'])\n        )\n        results.append(result)\n\n    # Format the final output string exactly as required\n    inner_parts = [f\"[{r[0]},{r[1]},{r[2]},{r[3]}]\" for r in results]\n    final_string = f\"[{','.join(inner_parts)}]\"\n    print(final_string)\n\ndef update_tangential_contact(Fn, mu, kt, dt, vt, xi_old):\n    \"\"\"\n    Computes the updated tangential spring displacement and contact force.\n\n    Args:\n        Fn (float): Normal force (N).\n        mu (float): Friction coefficient.\n        kt (float): Tangential stiffness (N/m).\n        dt (float): Time step (s).\n        vt (np.ndarray): Tangential slip velocity vector (m/s).\n        xi_old (np.ndarray): Previous tangential spring displacement vector (m).\n\n    Returns:\n        list: A list containing [xi_new_x, xi_new_y, Ft_x, Ft_y].\n    \"\"\"\n    # Case: No contact\n    if Fn = 0:\n        xi_new = np.zeros(2)\n        Ft = np.zeros(2)\n        return xi_new.tolist() + Ft.tolist()\n\n    # Step 1: Trial update (predictor)\n    xi_trial = xi_old + vt * dt\n\n    # Step 2: Compute trial force\n    Ft_trial = -kt * xi_trial\n\n    # Compute magnitude of trial force\n    norm_Ft_trial = np.linalg.norm(Ft_trial)\n\n    # Compute friction limit\n    friction_limit = mu * Fn\n\n    # Step 3: Enforce Coulomb friction limit (corrector)\n    # Case: Stick condition\n    if norm_Ft_trial = friction_limit:\n        xi_new = xi_trial\n        Ft = Ft_trial\n    # Case: Slip condition\n    else:\n        # The return mapping requires division by the norm of the trial force.\n        # This is safe because if norm_Ft_trial were 0, the 'if' condition\n        # (0 = friction_limit) would have been true (since mu*Fn = 0).\n        scaling_factor = friction_limit / norm_Ft_trial\n        xi_new = xi_trial * scaling_factor\n        # The final force can be calculated either by scaling Ft_trial or\n        # by using the new displacement. The latter is more robust to\n        # potential floating point inconsistencies.\n        Ft = -kt * xi_new\n\n    # Return the result as a list of floats\n    return xi_new.tolist() + Ft.tolist()\n\nsolve()\n```"
        },
        {
            "introduction": "The power of DEM is its ability to link particle-scale interactions to emergent macroscopic behavior. This exercise introduces a key post-processing technique for characterizing the internal structure of the simulated material by computing the fabric tensor, $\\mathbf{F}$ . You will learn to construct this tensor from the distribution of contact normals and use its eigenvalues and eigenvectors to quantify the magnitude and orientation of structural anisotropy, a critical step for understanding mechanical properties like anisotropic stress transmission.",
            "id": "4095013",
            "problem": "You are given a finite set of contact normals $\\{\\mathbf{n}_c\\}$ from a granular assembly modeled within the Discrete Element Method (DEM). Starting from the basic geometric definition that the contact network fabric tensor is the normalized second moment of contact orientations, compute the fabric tensor $\\mathbf{F}$, its eigenvalues, and identify the principal directions as the unit eigenvectors associated with the largest eigenvalue. Assume the following for the discretization: each contact contributes equally, every input contact normal is a real three-dimensional vector, and any zero-length vector contributes nothing and must be discarded.\n\nFundamental base: The fabric tensor of a contact network in three dimensions is defined as the average of dyadic products of unit contact normals. Starting from the orientation distribution function $p(\\mathbf{n})$ on the unit sphere with $\\int_{\\mathbb{S}^2} p(\\mathbf{n}) \\,\\mathrm{d}S = 1$, the continuous fabric tensor is $\\mathbf{F} = \\int_{\\mathbb{S}^2} p(\\mathbf{n})\\, \\mathbf{n}\\otimes \\mathbf{n}\\,\\mathrm{d}S$. In the discrete setting with $M$ valid unit contact normals, this is approximated by $\\mathbf{F} = \\dfrac{1}{M}\\sum_{c=1}^{M} \\hat{\\mathbf{n}}_c \\otimes \\hat{\\mathbf{n}}_c$, where $\\hat{\\mathbf{n}}_c = \\dfrac{\\mathbf{n}_c}{\\lVert \\mathbf{n}_c \\rVert}$ and $\\lVert \\mathbf{n}_c \\rVert \\neq 0$.\n\nYour program must:\n- Normalize each nonzero contact normal $\\mathbf{n}_c$ to unit length, discarding any zero-length vectors.\n- Compute $\\mathbf{F} = \\dfrac{1}{M}\\sum_{c=1}^{M} \\hat{\\mathbf{n}}_c \\otimes \\hat{\\mathbf{n}}_c$.\n- Compute the eigenvalues and eigenvectors of the symmetric tensor $\\mathbf{F}$.\n- Sort the eigenvalues in descending order and accordingly sort the eigenvectors.\n- For each test case, output the sorted eigenvalues and the principal direction, defined as the unit eigenvector associated with the largest eigenvalue.\n\nNumerical output requirements:\n- Round all floating-point numbers to six decimal places.\n- Angles are not required; all quantities are dimensionless.\n\nTest suite:\n- Case $1$ (nearly isotropic axis-aligned set): $\\left\\{(1,0,0),\\,(-1,0,0),\\,(0,1,0),\\,(0,-1,0),\\,(0,0,1),\\,(0,0,-1)\\right\\}$.\n- Case $2$ (strongly anisotropic aligned with $z$): $\\left\\{(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(1,0,0),\\,(0,1,0)\\right\\}$.\n- Case $3$ (anisotropy tilted in the $x$-$y$ plane): $\\left\\{(1,1,0),\\,(1,1,0),\\,(1,1,0),\\,(1,1,0),\\,(1,1,0),\\,(1,1,0),\\,(1,1,0),\\,(0.9,1.1,0),\\,(0,0,1)\\right\\}$.\n- Case $4$ (degenerate colinear case with a zero vector): $\\left\\{(1,0,0),\\,(1,0,0),\\,(1,0,0),\\,(1,0,0),\\,(1,0,0),\\,(0,0,0)\\right\\}$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case’s result must be a list of two lists: the first list contains the three sorted eigenvalues, and the second list contains the three components of the principal direction eigenvector, all rounded to six decimal places. For example, the overall structure must be of the form $\\left[\\left[\\left[\\lambda_1,\\lambda_2,\\lambda_3\\right],\\left[v_1,v_2,v_3\\right]\\right],\\ldots\\right]$ with no spaces after commas.",
            "solution": "The user-provided problem is first subjected to a rigorous validation process.\n\n### Step 1: Extract Givens\n- **Task**: Compute the fabric tensor $\\mathbf{F}$, its eigenvalues, and the principal direction for a given finite set of contact normals $\\{\\mathbf{n}_c\\}$.\n- **Context**: The problem is set within the Discrete Element Method (DEM) for modeling granular media.\n- **Definition of Fabric Tensor (Discrete)**: $\\mathbf{F} = \\dfrac{1}{M}\\sum_{c=1}^{M} \\hat{\\mathbf{n}}_c \\otimes \\hat{\\mathbf{n}}_c$.\n- **Definition of Unit Normal**: $\\hat{\\mathbf{n}}_c = \\dfrac{\\mathbf{n}_c}{\\lVert \\mathbf{n}_c \\rVert}$, where the norm $\\lVert \\mathbf{n}_c \\rVert \\neq 0$.\n- **Variable Definitions**:\n    - $\\{\\mathbf{n}_c\\}$: A set of real three-dimensional contact normal vectors.\n    - $M$: The number of valid (non-zero) contact normals.\n    - $\\otimes$: The dyadic (outer) product operator.\n- **Processing Rules**:\n    1. Each contact contributes equally.\n    2. Zero-length vectors ($\\lVert \\mathbf{n}_c \\rVert=0$) must be discarded and do not contribute to the calculation.\n    3. The eigenvalues of $\\mathbf{F}$ must be sorted in descending order.\n    4. The eigenvectors of $\\mathbf{F}$ must be sorted according to their corresponding eigenvalues.\n    5. The principal direction is defined as the unit eigenvector associated with the largest eigenvalue.\n- **Numerical Requirements**: All floating-point numerical outputs must be rounded to six decimal places.\n- **Test Suite**:\n    - Case $1$: $\\{\\mathbf{n}_c\\} = \\left\\{(1,0,0),\\,(-1,0,0),\\,(0,1,0),\\,(0,-1,0),\\,(0,0,1),\\,(0,0,-1)\\right\\}$.\n    - Case $2$: $\\{\\mathbf{n}_c\\} = \\left\\{(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(0,0,1),\\,(1,0,0),\\,(0,1,0)\\right\\}$.\n    - Case $3$: $\\{\\mathbf{n}_c\\} = \\left\\{(1,1,0),\\,(1,1,0),\\,(1,1,0),\\,(1,1,0),\\,(1,1,0),\\,(1,1,0),\\,(1,1,0),\\,(0.9,1.1,0),\\,(0,0,1)\\right\\}$.\n    - Case $4$: $\\{\\mathbf{n}_c\\} = \\left\\{(1,0,0),\\,(1,0,0),\\,(1,0,0),\\,(1,0,0),\\,(1,0,0),\\,(0,0,0)\\right\\}$.\n- **Output Format**: A single line string `[[[lambda1,lambda2,lambda3],[v1,v2,v3]],...]` with no spaces.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded**: The problem is based on the concept of the fabric tensor, a standard and fundamental quantity in the mechanics of granular materials and other disordered media. The provided formula for the discrete fabric tensor is the correct and widely accepted definition. The analysis via eigenvalue decomposition to find principal directions of anisotropy is a standard technique in tensor analysis. The problem is scientifically sound.\n2.  **Well-Posed**: The problem provides a clear, deterministic algorithm. For any given set of vectors, the procedure (filtering, normalization, summation, eigen-decomposition) leads to a unique result. The rule for handling zero vectors resolves ambiguity. While the principal direction for an isotropic tensor (where all three eigenvalues are equal) is mathematically not unique, a computational algorithm will produce a deterministic, valid eigenvector, making the problem computationally well-posed.\n3.  **Objective**: The problem is stated using precise mathematical and computational language. All terms are defined, and the required output is specified in an unambiguous format. It is free from subjective claims.\n4.  **Complete and Consistent**: All necessary information (formulas, test data, output format) is provided. There are no internal contradictions.\n5.  **Feasible and Relevant**: The computations required are standard linear algebra operations, feasible with common numerical libraries. The problem is directly relevant to the specified topic of *modeling of granular media: discrete element method (DEM)*.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It is scientifically grounded, well-posed, objective, and complete. A solution will be provided.\n\nThe objective is to compute the fabric tensor $\\mathbf{F}$, its eigenvalues, and its principal direction from a discrete set of contact normal vectors $\\{\\mathbf{n}_c\\}$. The procedure follows a sequence of well-defined steps derived from the principles of linear algebra and continuum mechanics adapted for a discrete system.\n\nFirst, the input set of vectors $\\{\\mathbf{n}_c\\}$ must be processed. For each vector $\\mathbf{n}_c$ in the set, its Euclidean norm $\\lVert \\mathbf{n}_c \\rVert$ is calculated. If the norm is zero (i.e., $\\mathbf{n}_c$ is the zero vector), the vector is discarded from further consideration as per the problem statement. For all non-zero vectors, a corresponding unit normal vector $\\hat{\\mathbf{n}}_c$ is computed by the normalization operation $\\hat{\\mathbf{n}}_c = \\mathbf{n}_c / \\lVert \\mathbf{n}_c \\rVert$. The total number of these valid, non-zero vectors is denoted by $M$.\n\nSecond, the fabric tensor $\\mathbf{F}$ is constructed. It is defined as the average of the dyadic products of the unit normal vectors. The dyadic product of a vector with itself, $\\hat{\\mathbf{n}}_c \\otimes \\hat{\\mathbf{n}}_c$, results in a symmetric $3 \\times 3$ matrix. For a unit normal $\\hat{\\mathbf{n}}_c = (n_x, n_y, n_z)^T$, this matrix is:\n$$\n\\hat{\\mathbf{n}}_c \\otimes \\hat{\\mathbf{n}}_c = \\begin{pmatrix} n_x^2  n_x n_y  n_x n_z \\\\ n_y n_x  n_y^2  n_y n_z \\\\ n_z n_x  n_z n_y  n_z^2 \\end{pmatrix}\n$$\nThe fabric tensor $\\mathbf{F}$ is the arithmetic mean of these individual matrices over all $M$ valid contacts:\n$$\n\\mathbf{F} = \\frac{1}{M} \\sum_{c=1}^{M} \\hat{\\mathbf{n}}_c \\otimes \\hat{\\mathbf{n}}_c\n$$\nSince each term $\\hat{\\mathbf{n}}_c \\otimes \\hat{\\mathbf{n}}_c$ is a symmetric matrix, their sum, and therefore $\\mathbf{F}$ itself, is also a real symmetric $3 \\times 3$ matrix. A key property of $\\mathbf{F}$ is that its trace is always unity: $\\mathrm{tr}(\\mathbf{F}) = \\frac{1}{M} \\sum_{c=1}^{M} \\mathrm{tr}(\\hat{\\mathbf{n}}_c \\otimes \\hat{\\mathbf{n}}_c) = \\frac{1}{M} \\sum_{c=1}^{M} \\lVert\\hat{\\mathbf{n}}_c\\rVert^2 = \\frac{1}{M} \\sum_{c=1}^{M} 1 = 1$. The eigenvalues of $\\mathbf{F}$ thus sum to $1$.\n\nThird, an eigenvalue decomposition of the fabric tensor $\\mathbf{F}$ is performed. This involves solving the characteristic equation $\\mathbf{F}\\mathbf{v} = \\lambda\\mathbf{v}$ for its eigenvalues $\\lambda$ and corresponding eigenvectors $\\mathbf{v}$. Because $\\mathbf{F}$ is a real symmetric matrix, it is guaranteed to have three real eigenvalues, which we denote $\\lambda_1, \\lambda_2, \\lambda_3$, and a set of three mutually orthogonal eigenvectors, $\\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{v}_3$. These eigenvalues represent the principal magnitudes of the fabric, and the eigenvectors represent the principal directions.\n\nFourth, the eigenvalues and eigenvectors are sorted and the principal direction is identified. The problem specifies sorting the eigenvalues in descending order: $\\lambda_1 \\ge \\lambda_2 \\ge \\lambda_3$. The eigenvectors must be ordered to correspond to this sorted sequence of eigenvalues. The principal direction of the fabric, which indicates the dominant orientation of the contact network, is defined as the unit eigenvector $\\mathbf{v}_1$ associated with the largest eigenvalue $\\lambda_1$.\n\nFinally, for implementation, these steps are executed for each test case. The resulting sorted eigenvalues $(\\lambda_1, \\lambda_2, \\lambda_3)$ and the components of the principal direction vector $\\mathbf{v}_1$ are rounded to six decimal places and formatted into the specified string format for the final output. Numerical libraries such as NumPy are well-suited for these tasks, providing robust functions for vector normalization, matrix operations, and the efficient and stable computation of eigenvalues and eigenvectors for symmetric matrices.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the fabric tensor problem for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (nearly isotropic axis-aligned set)\n        np.array([[1.0, 0.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 1.0, 0.0],\n                  [0.0, -1.0, 0.0], [0.0, 0.0, 1.0], [0.0, 0.0, -1.0]]),\n        \n        # Case 2 (strongly anisotropic aligned with z)\n        np.array([[0.0, 0.0, 1.0], [0.0, 0.0, 1.0], [0.0, 0.0, 1.0],\n                  [0.0, 0.0, 1.0], [0.0, 0.0, 1.0], [0.0, 0.0, 1.0],\n                  [0.0, 0.0, 1.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0],\n                  [0.0, 1.0, 0.0]]),\n\n        # Case 3 (anisotropy tilted in the x-y plane)\n        np.array([[1.0, 1.0, 0.0], [1.0, 1.0, 0.0], [1.0, 1.0, 0.0],\n                  [1.0, 1.0, 0.0], [1.0, 1.0, 0.0], [1.0, 1.0, 0.0],\n                  [1.0, 1.0, 0.0], [0.9, 1.1, 0.0], [0.0, 0.0, 1.0]]),\n\n        # Case 4 (degenerate colinear case with a zero vector)\n        np.array([[1.0, 0.0, 0.0], [1.0, 0.0, 0.0], [1.0, 0.0, 0.0],\n                  [1.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 0.0]])\n    ]\n\n    results_as_strings = []\n    \n    for vectors in test_cases:\n        # Step 1: Filter out zero-length vectors and normalize the rest.\n        norms = np.linalg.norm(vectors, axis=1)\n        # A small tolerance is better than direct comparison with 0 for floating point numbers.\n        valid_indices = np.where(norms  1e-9)[0]\n        \n        if len(valid_indices) == 0:\n            # Handle edge case where all vectors are zero or list is empty.\n            # Fabric tensor is zero, eigenvalues are zero, principal direction is undefined.\n            # We can represent it as a zero vector.\n            eigenvalues = np.array([0.0, 0.0, 0.0])\n            principal_direction = np.array([0.0, 0.0, 0.0])\n        else:\n            valid_vectors = vectors[valid_indices]\n            valid_norms = norms[valid_indices]\n            unit_vectors = valid_vectors / valid_norms[:, np.newaxis]\n            \n            M = len(unit_vectors)\n\n            # Step 2: Compute the fabric tensor F.\n            fabric_tensor = np.zeros((3, 3))\n            for n_hat in unit_vectors:\n                fabric_tensor += np.outer(n_hat, n_hat)\n            fabric_tensor /= M\n\n            # Step 3: Compute eigenvalues and eigenvectors.\n            # np.linalg.eigh is for symmetric matrices. It's faster and more stable.\n            # It returns eigenvalues in ascending order.\n            eigenvalues, eigenvectors = np.linalg.eigh(fabric_tensor)\n            \n            # Step 4: Sort eigenvalues in descending order and sort eigenvectors accordingly.\n            sorted_indices = np.argsort(eigenvalues)[::-1]\n            sorted_eigenvalues = eigenvalues[sorted_indices]\n            sorted_eigenvectors = eigenvectors[:, sorted_indices]\n            \n            # The principal direction is the eigenvector of the largest eigenvalue.\n            principal_direction = sorted_eigenvectors[:, 0]\n\n            # Ensure principal direction has a consistent sign for deterministic output,\n            # e.g., make the element with largest absolute value positive.\n            max_abs_idx = np.argmax(np.abs(principal_direction))\n            if principal_direction[max_abs_idx]  0:\n                principal_direction *= -1\n\n            eigenvalues = sorted_eigenvalues\n        \n        # Step 5: Format the output to six decimal places, without spaces.\n        eig_str = f\"[{','.join([f'{v:.6f}' for v in eigenvalues])}]\"\n        vec_str = f\"[{','.join([f'{v:.6f}' for v in principal_direction])}]\"\n        case_str = f\"[{eig_str},{vec_str}]\"\n        results_as_strings.append(case_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```"
        }
    ]
}