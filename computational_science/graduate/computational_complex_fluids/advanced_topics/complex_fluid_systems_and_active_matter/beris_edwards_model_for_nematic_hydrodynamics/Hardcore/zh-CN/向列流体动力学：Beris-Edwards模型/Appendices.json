{
    "hands_on_practices": [
        {
            "introduction": "在深入研究复杂的数值模拟之前，进行量纲分析和尺度估计是理解系统物理行为的关键第一步。这个练习旨在通过一个实际的微流体场景，帮助你建立对Beris-Edwards模型中各物理量大小的直观感受。我们将推导并计算两个核心的无量纲数——埃里克森数（Ericksen number, $Er$）和底波拉数（Deborah number, $De$），它们分别揭示了黏性效应与弹性效应、流动时间尺度与材料弛豫时间尺度之间的竞争关系，为判断特定流动状态下向列相液晶的行为主导因素提供了依据 。",
            "id": "4079599",
            "problem": "在压力驱动的微流体通道中，热致向列液晶（例如，4-4'-戊基氰基联苯）可以使用 Beris-Edwards (BE) 液晶流体动力学模型进行建模，其中流体速度场 $\\,\\mathbf{u}\\,$ 遵循增加了取向应力的 Navier–Stokes 方程的动量平衡，而取向序由排列张量 $\\,\\mathbf{Q}\\,$ 描述，其动力学方程为 $\\partial_{t}\\mathbf{Q}-\\mathbf{S}(\\nabla\\mathbf{u},\\mathbf{Q})=\\Gamma\\,\\mathbf{H}$，其中 $\\,\\mathbf{H}=-\\delta F/\\delta \\mathbf{Q}\\,$ 是从 Landau–de Gennes 自由能推导出的分子场。对于标度分析，粘性效应和弹性效应之间的竞争由 Ericksen 数表征，时间尺度竞争由 Deborah 数表征。从基本概念出发，即剪切速率为 $\\,\\dot{\\gamma}\\,$ 时的粘性应力标度为 $\\,\\eta\\,\\dot{\\gamma}\\,$，且与长度 $\\,L\\,$ 上的指向矢畸变相关的弹性分子场标度为 $\\,K/L^{2}\\,$（单一 Frank 常数近似），推导 Ericksen 数 $\\,\\mathrm{Er}\\,$ 和 Deborah 数 $\\,\\mathrm{De}\\,$ 关于材料和几何参数的表达式。然后采用以下代表室温下热致向列液晶的实际参数值：\n- 各向同性等效剪切粘度大小 $\\,\\eta = 0.10\\,\\mathrm{Pa\\,s}\\,$，\n- 旋转粘度 $\\,\\gamma_{1} = 0.050\\,\\mathrm{Pa\\,s}\\,$，\n- 单一 Frank 弹性常数 $\\,K = 7.0\\times 10^{-12}\\,\\mathrm{N}\\,$，\n以及微流体条件：\n- 通道高度 $\\,H = 50\\,\\mu\\mathrm{m}\\,$ 作为特征长度 $\\,L\\,$，\n- 平均流速 $\\,U = 1.0\\,\\mathrm{mm/s}\\,$ 给出估计的剪切速率 $\\,\\dot{\\gamma}\\approx U/H\\,$。\n\n使用这些值，计算 $\\,\\mathrm{Er}\\,$ 和 $\\,\\mathrm{De}\\,$。用无单位的无量纲结果表示你的最终答案，并四舍五入到三位有效数字。",
            "solution": "该问题经证实具有科学依据、适定且客观。它提供了一套完整且一致的定义、物理原理和数据，用于推导和计算特定流动条件下向列液晶的 Ericksen 数和 Deborah 数。\n\n推导和计算过程如下。\n\n**1. Ericksen 数 ($\\mathrm{Er}$) 的推导**\n\nEricksen 数 $\\mathrm{Er}$ 量化了流动液晶中粘性效应和弹性效应之间的竞争。它被定义为特征粘性应力 $\\sigma_{\\text{visc}}$ 与特征弹性应力 $\\sigma_{\\text{el}}$ 的比值。\n$$\n\\mathrm{Er} = \\frac{\\sigma_{\\text{visc}}}{\\sigma_{\\text{el}}}\n$$\n问题提供了与剪切速率为 $\\dot{\\gamma}$、剪切粘度为 $\\eta$ 的剪切流相关的粘性应力的标度：\n$$\n\\sigma_{\\text{visc}} \\sim \\eta \\dot{\\gamma}\n$$\n弹性应力源于液晶取向序在特征长度尺度 $L$ 上的空间畸变。该应力与分子场 $\\mathbf{H}$ 相关，而分子场又从 Frank 弹性自由能推导得出。问题中提供了在单常数近似（$K$）下分子场的标度：\n$$\nH \\sim \\frac{K}{L^2}\n$$\n弹性应力张量的分量与分子场成正比，因此弹性应力的大小也遵循类似的标度关系：\n$$\n\\sigma_{\\text{el}} \\sim \\frac{K}{L^2}\n$$\n将应力标度代入 Ericksen 数的定义中，得到表达式：\n$$\n\\mathrm{Er} = \\frac{\\eta \\dot{\\gamma}}{K / L^2} = \\frac{\\eta \\dot{\\gamma} L^2}{K}\n$$\n\n**2. Deborah 数 ($\\mathrm{De}$) 的推导**\n\nDeborah 数 $\\mathrm{De}$ 表征了时间尺度之间的竞争。它被定义为材料的本征弛豫时间 $\\tau_{\\text{relax}}$ 与流动过程的特征时间尺度 $\\tau_{\\text{flow}}$ 的比值。\n$$\n\\mathrm{De} = \\frac{\\tau_{\\text{relax}}}{\\tau_{\\text{flow}}}\n$$\n流动的特征时间尺度是特征应变率的倒数，即剪切速率 $\\dot{\\gamma}$：\n$$\n\\tau_{\\text{flow}} \\sim \\frac{1}{\\dot{\\gamma}}\n$$\n材料的弛豫时间 $\\tau_{\\text{relax}}$ 是指导向序在受到扰动后恢复到平衡所需的时间。这个过程涉及到恢复弹性力矩密度和耗散粘性力矩密度之间的平衡。弹性力矩密度由分子场驱动，标度为 $\\sim H \\sim K/L^2$。耗散粘性力矩密度是由于指向矢抵抗旋转粘度 $\\gamma_1$ 进行旋转而产生的，其标度为 $\\sim \\gamma_1 \\dot{\\theta}$，其中 $\\dot{\\theta}$ 是角旋转速率。对于弛豫过程，特征速率为 $\\dot{\\theta} \\sim 1/\\tau_{\\text{relax}}$。因此，耗散粘性力矩密度的标度为 $\\sim \\gamma_1 / \\tau_{\\text{relax}}$。\n通过平衡弹性和粘性力矩，我们发现：\n$$\n\\frac{\\gamma_1}{\\tau_{\\text{relax}}} \\sim \\frac{K}{L^2}\n$$\n解出弛豫时间，得到：\n$$\n\\tau_{\\text{relax}} \\sim \\frac{\\gamma_1 L^2}{K}\n$$\n将时间尺度代入 Deborah 数的定义中，得到表达式：\n$$\n\\mathrm{De} = \\frac{\\gamma_1 L^2 / K}{1 / \\dot{\\gamma}} = \\frac{\\gamma_1 \\dot{\\gamma} L^2}{K}\n$$\n\n**3. 数值计算**\n\n首先，我们必须将所有给定参数用一致的国际单位制（SI）单位表示。\n- 各向同性等效剪切粘度：$\\eta = 0.10\\,\\mathrm{Pa\\,s} = 0.10\\,\\mathrm{N\\,s\\,m^{-2}}$\n- 旋转粘度：$\\gamma_1 = 0.050\\,\\mathrm{Pa\\,s} = 0.050\\,\\mathrm{N\\,s\\,m^{-2}}$\n- 单一 Frank 弹性常数：$K = 7.0 \\times 10^{-12}\\,\\mathrm{N}$\n- 特征长度：$L = H = 50\\,\\mu\\mathrm{m} = 5.0 \\times 10^{-5}\\,\\mathrm{m}$\n- 平均流速：$U = 1.0\\,\\mathrm{mm/s} = 1.0 \\times 10^{-3}\\,\\mathrm{m\\,s^{-1}}$\n\n接下来，我们计算估计的剪切速率 $\\dot{\\gamma}$：\n$$\n\\dot{\\gamma} \\approx \\frac{U}{H} = \\frac{1.0 \\times 10^{-3}\\,\\mathrm{m\\,s^{-1}}}{5.0 \\times 10^{-5}\\,\\mathrm{m}} = 20\\,\\mathrm{s^{-1}}\n$$\n现在我们计算 Ericksen 数 $\\mathrm{Er}$：\n$$\n\\mathrm{Er} = \\frac{\\eta \\dot{\\gamma} L^2}{K} = \\frac{(0.10\\,\\mathrm{N\\,s\\,m^{-2}})(20\\,\\mathrm{s^{-1}})(5.0 \\times 10^{-5}\\,\\mathrm{m})^2}{7.0 \\times 10^{-12}\\,\\mathrm{N}}\n$$\n$$\n\\mathrm{Er} = \\frac{(2.0)(25 \\times 10^{-10})}{7.0 \\times 10^{-12}} = \\frac{50 \\times 10^{-10}}{7.0 \\times 10^{-12}} = \\frac{50}{7.0} \\times 10^2 \\approx 7.1428 \\times 10^2\n$$\n四舍五入到三位有效数字，我们得到 $\\mathrm{Er} = 714$。\n\n最后，我们计算 Deborah 数 $\\mathrm{De}$：\n$$\n\\mathrm{De} = \\frac{\\gamma_1 \\dot{\\gamma} L^2}{K} = \\frac{(0.050\\,\\mathrm{N\\,s\\,m^{-2}})(20\\,\\mathrm{s^{-1}})(5.0 \\times 10^{-5}\\,\\mathrm{m})^2}{7.0 \\times 10^{-12}\\,\\mathrm{N}}\n$$\n$$\n\\mathrm{De} = \\frac{(1.0)(25 \\times 10^{-10})}{7.0 \\times 10^{-12}} = \\frac{25 \\times 10^{-10}}{7.0 \\times 10^{-12}} = \\frac{25}{7.0} \\times 10^2 \\approx 3.5714 \\times 10^2\n$$\n四舍五入到三位有效数字，我们得到 $\\mathrm{De} = 357$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n714  357\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在Beris-Edwards模型的数值实现中，一个核心的挑战是保证序参量张量 $Q$ 的无迹性（$\\operatorname{tr}Q=0$）。虽然连续方程本身能保持这一特性，但数值离散和浮点误差会逐渐破坏这个约束，导致模拟结果偏离物理现实。本练习将引导你通过一个简化的模型，诊断并解决这一常见的数值漂移问题，你将亲手实现一个投影算子，以强制保证张量 $Q$ 在整个模拟过程中的无迹性，这是确保模拟稳定性和物理准确性的关键一步 。",
            "id": "4079546",
            "problem": "考虑 Beris–Edwards 模型中向列相液晶的 Landau–de Gennes 张量描述。序参量是二阶张量场 $Q(\\mathbf{x},t)$，该张量场是对称且无迹的。基本的物理要求是，在所有位置和所有时间，包括在边界上，$\\operatorname{tr} Q = 0$。解析上，如果初始化和约束一致，Beris–Edwards 动力学的偏微分方程 (PDE) 会保持 $\\operatorname{tr} Q = 0$。但在数值计算中，浮点舍入误差和不一致的边界更新会导致其从对称无迹流形上漂移。\n\n从以下基本基础出发：\n\n- 向列相序参量张量 $Q$ 是对称且无迹的，即 $Q = Q^{\\top}$ 且 $\\operatorname{tr} Q = 0$。\n- 与 Landau–de Gennes 唯象论一致的 $Q$ 的一个通用弛豫型演化方程包含一个扩散项和一个线性衰减项。在简化设定下，这可以分量形式表示为一个线性抛物型偏微分方程，\n$$\n\\frac{\\partial Q}{\\partial t} = \\Gamma \\left( L \\nabla^2 Q - a Q \\right),\n$$\n其中 $\\Gamma$、$L$ 和 $a$ 是正的材料参数，$\\nabla^2$ 是拉普拉斯算子。\n- 在没有缺陷或拓扑变化的情况下，强制执行 $\\operatorname{tr} Q = 0$ 是一个硬代数约束，该约束源于 $Q$ 作为偏张量的定义。\n\n您的任务是推导、实现并测试一种数值稳定的方法，在内部离散化和边界上强制执行 $\\operatorname{tr} Q = 0$ 约束，以防止由数值误差引起的漂移。您必须按以下步骤进行：\n\n1. 从第一性原理出发，推导一个显式代数投影，将任意 $2 \\times 2$ 实矩阵映射到对称无迹子空间。解释为什么此投影保留了向列相序参量的物理意义，以及它如何与张量分解为对称、反对称和各向同性部分相关联。\n\n2. 在大小为 $N_x \\times N_y$ 的方形晶格上，为简化的弛豫动力学\n$$\n\\frac{\\partial Q}{\\partial t} = \\Gamma \\left( L \\nabla^2 Q - a Q \\right),\n$$\n设计一个二维有限差分格式，并采用显式欧拉时间步进。使用无量纲的域和间距，并按分量处理 $Q$。使用狄利克雷边界条件，将指向矢沿 $x$ 轴均匀锚定，即，设置边界目标 $Q^\\star$ 与二维单轴态一致，其指向矢为 $\\mathbf{n} = (1,0)$，标量序幅度为 $S$；边界目标必须是无迹的。在每个时间步为边界值实现一个小的各向同性扰动，以模拟数值边界漂移（即，添加单位张量的倍数）。同样，为内部更新实现一个小的各向同性扰动，以模拟离散化中的浮点漂移。这些扰动必须由远小于 $1$ 的参数控制。\n\n3. 实现两种强制执行模式：\n   - 模式 $0$：不强制执行；展示 $\\operatorname{tr} Q$ 在内部和边界处如何漂移。\n   - 模式 $1$：仅内部强制执行；在每个时间步后，将推导出的投影应用于内部节点，但不应用于边界节点。\n   - 模式 $2$：内部和边界强制执行；在每个时间步后，将推导出的投影应用于所有节点，包括在施加边界条件后立即对边界节点应用投影。\n\n4. 为每次模拟定义并计算以下定量诊断指标：\n   - 内部节点的最终平均绝对迹，\n     $$\n     \\overline{|\\operatorname{tr} Q|}_{\\mathrm{int}} = \\frac{1}{N_{\\mathrm{int}}} \\sum_{\\text{interior nodes}} \\left| \\operatorname{tr} Q \\right|.\n     $$\n   - 边界节点的最终最大绝对迹，\n     $$\n     \\max_{\\mathrm{bnd}} \\left| \\operatorname{tr} Q \\right|.\n     $$\n   - 整个区域的最终均方根 (RMS) 迹，\n     $$\n     \\mathrm{RMS}(\\operatorname{tr} Q) = \\sqrt{\\frac{1}{N_x N_y} \\sum_{\\text{all nodes}} \\left( \\operatorname{tr} Q \\right)^2 }.\n     $$\n\n5. 实现一个完整的程序，运行以下测试套件。每个测试用例由 $(N_x, N_y, \\Delta t, \\text{steps}, L, a, \\Gamma, \\delta_{\\mathrm{int}}, \\delta_{\\mathrm{bnd}}, \\text{mode})$ 指定，其中 $\\delta_{\\mathrm{int}}$ 控制每个时间步的各向同性内部漂移幅度，$\\delta_{\\mathrm{bnd}}$ 控制每个时间步的各向同性边界漂移幅度。使用以下测试用例：\n   - 测试 $1$ (理想情况，中等内部漂移，对比无强制执行)：$(24, 24, 0.01, 400, 0.02, 0.10, 1.0, 10^{-9}, 10^{-10}, 0)$。\n   - 测试 $2$ (理想情况，中等内部漂移，内部强制执行)：$(24, 24, 0.01, 400, 0.02, 0.10, 1.0, 10^{-9}, 10^{-10}, 1)$。\n   - 测试 $3$ (边界漂移压力测试，无强制执行)：$(24, 24, 0.01, 400, 0.02, 0.10, 1.0, 10^{-9}, 10^{-6}, 0)$。\n   - 测试 $4$ (边界漂移压力测试，完全强制执行)：$(24, 24, 0.01, 400, 0.02, 0.10, 1.0, 10^{-9}, 10^{-6}, 2)$。\n   - 测试 $5$ (边缘情况，微小漂移，长时间运行，内部强制执行)：$(24, 24, 0.005, 1200, 0.02, 0.10, 1.0, 10^{-12}, 10^{-12}, 1)$。\n\n6. 初始化：将内部的初始条件设置为均匀锚定状态 $Q^\\star$ 加上一个均值为零、幅度为 $10^{-12}$ 的小的随机对称扰动，并在适用时应用带有指定边界漂移的边界目标 $Q^\\star$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，顺序如下\n$$\n\\big[\n\\overline{|\\operatorname{tr} Q|}_{\\mathrm{int}}^{(1)}, \\max_{\\mathrm{bnd}} |\\operatorname{tr} Q|^{(1)}, \\mathrm{RMS}(\\operatorname{tr} Q)^{(1)},\n\\overline{|\\operatorname{tr} Q|}_{\\mathrm{int}}^{(2)}, \\max_{\\mathrm{bnd}} |\\operatorname{tr} Q|^{(2)}, \\mathrm{RMS}(\\operatorname{tr} Q)^{(2)},\n\\ldots,\n\\overline{|\\operatorname{tr} Q|}_{\\mathrm{int}}^{(5)}, \\max_{\\mathrm{bnd}} |\\operatorname{tr} Q|^{(5)}, \\mathrm{RMS}(\\operatorname{tr} Q)^{(5)}\n\\big],\n$$\n其中上标表示测试用例编号。所有数字必须使用默认的 Python 格式打印为标准浮点值。由于问题是无量纲的，因此不需要物理单位。不涉及角度。将所有幅度表示为普通十进制数。程序必须是自包含的，并且不得需要任何用户交互。",
            "solution": "该问题要求开发并测试一种数值方案，以便在简化的 Beris-Edwards 模型中对向列相序参量张量 $Q$ 强制执行对称无迹约束。任务的核心是推导一个代数投影，将其集成到有限差分格式中，并用它来抵消模拟的数值漂移。\n\n### 1. 投影算子的推导\n\n向列相序参量 $Q$ 是一个二阶张量，必须是对称的 ($Q = Q^\\top$) 和无迹的 ($\\operatorname{tr} Q = 0$)。我们需要推导一个投影算子 $\\mathcal{P}$，它将任意 $2 \\times 2$ 实矩阵 $M$ 映射到对称无迹矩阵子空间。这可以通过两个步骤完成，对应于将一个张量分解为其基本部分。\n\n**步骤 1：投影到对称子空间**\n任何任意方阵 $M$ 都可以唯一地分解为一个对称部分 $M_s$ 和一个反对称部分 $M_a$：\n$$\nM = M_s + M_a\n$$\n其中\n$$\nM_s = \\frac{1}{2}(M + M^\\top) \\quad \\text{和} \\quad M_a = \\frac{1}{2}(M - M^\\top)\n$$\n由于 $Q$ 必须是对称的，我们舍弃反对称部分，这对应于将 $M$ 投影到对称矩阵子空间：$M \\rightarrow M_s$。\n\n**步骤 2：投影到无迹子空间**\n一个对称矩阵 $S$ 可以进一步分解为其各向同性部分和其偏（无迹）部分。在 $d$ 维空间中，分解如下：\n$$\nS = S_0 + \\frac{1}{d} \\operatorname{tr}(S) I\n$$\n其中 $I$ 是单位矩阵，$S_0 = S - \\frac{1}{d} \\operatorname{tr}(S) I$ 是无迹部分。各向同性部分 $\\frac{1}{d} \\operatorname{tr}(S) I$ 代表均匀缩放，不描述取向序。向列相排列的物理特性由各向异性的无迹部分 $S_0$ 捕获。对于我们的二维问题，$d=2$。因此，将对称矩阵 $S$ 投影到无迹子空间的操作是：\n$$\nS \\rightarrow S - \\frac{1}{2}\\operatorname{tr}(S)I\n$$\n\n**组合投影算子**\n结合这两个步骤，将一个通用 $2 \\times 2$ 矩阵 $M$ 映射到对称无迹子空间的投影 $\\mathcal{P}$ 是这两个投影的复合。我们首先将 $M$ 对称化得到 $M_s$，然后使结果无迹：\n$$\n\\mathcal{P}(M) = M_s - \\frac{1}{2}\\operatorname{tr}(M_s)I = \\frac{1}{2}(M + M^\\top) - \\frac{1}{2}\\operatorname{tr}\\left(\\frac{1}{2}(M + M^\\top)\\right)I\n$$\n利用迹算子的线性性质 ($\\operatorname{tr}(A+B) = \\operatorname{tr}(A)+\\operatorname{tr}(B)$) 和性质 $\\operatorname{tr}(A^\\top) = \\operatorname{tr}(A)$，我们有 $\\operatorname{tr}(M+M^\\top) = 2\\operatorname{tr}(M)$。投影算子的表达式简化为：\n$$\n\\mathcal{P}(M) = \\frac{1}{2}(M + M^\\top) - \\frac{1}{2}\\operatorname{tr}(M)I\n$$\n该算子从任何输入矩阵 $M$ 中分离出对称无迹分量，这恰好对应于向列相序参量 $Q$ 的物理定义。这是一个在配备了 Frobenius 内积 $\\langle A, B \\rangle = \\operatorname{tr}(A^\\top B)$ 的矩阵空间中的正交投影。\n\n### 2. 有限差分格式设计\n\n我们在一个大小为 $N_x \\times N_y$、均匀间距 $\\Delta x = \\Delta y = 1$（无量纲）的二维矩形网格上离散化该偏微分方程。张量场 $Q(x,y,t)$ 由每个网格点 $(i,j)$ 上的一个 $2 \\times 2$ 矩阵集合表示，记为 $Q_{i,j}$。\n\n**分量离散化**\n演化方程为：\n$$\n\\frac{\\partial Q}{\\partial t} = \\Gamma \\left( L \\nabla^2 Q - a Q \\right)\n$$\n拉普拉斯算子 $\\nabla^2$ 使用标准的 5 点模板对 $Q$ 的每个分量进行离散化。对于网格节点 $(i,j)$ 上的一个通用分量 $q$：\n$$\n(\\nabla^2 q)_{i,j} \\approx q_{i+1,j} + q_{i-1,j} + q_{i,j+1} + q_{i,j-1} - 4q_{i,j}\n$$\n这适用于内部节点 $i \\in [1, N_x-2]$ 和 $j \\in [1, N_y-2]$。\n\n**时间积分**\n我们使用显式欧拉格式进行时间步进，时间步长为 $\\Delta t$：\n$$\nQ_{i,j}^{n+1} = Q_{i,j}^{n} + \\Delta t \\cdot \\Gamma \\left( L (\\nabla^2 Q^n)_{i,j} - a Q_{i,j}^n \\right)\n$$\n\n**初始和边界条件**\n边界条件是一个均匀单轴态，指向矢为 $\\mathbf{n}=(1,0)$，标量序参量为 $S$。由于未给出 $S$ 的值，我们选择一个标准的无量纲值 $S=1$。边界张量 $Q^\\star$ 为：\n$$\nQ^\\star = S \\left( \\mathbf{n}\\otimes\\mathbf{n} - \\frac{1}{2}I \\right) = 1 \\cdot \\left( \\begin{pmatrix} 1  0 \\\\ 0  0 \\end{pmatrix} - \\frac{1}{2} \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} \\right) = \\begin{pmatrix} 0.5  0 \\\\ 0  -0.5 \\end{pmatrix}\n$$\n内部节点的初始条件是这个均匀状态加上一个幅度为 $10^{-12}$ 的小的、随机的、对称无迹的扰动。这确保了初始状态满足 $\\operatorname{tr} Q = 0$。边界节点初始化为 $Q^\\star$。\n\n**模拟数值漂移**\n为了模拟违反无迹约束的数值误差，我们引入各向同性扰动：\n-   **内部漂移**：在每个时间步，欧拉更新之后，将一个常数矩阵 $\\delta_{\\mathrm{int}} I$ 添加到每个内部节点的 $Q$ 张量上。这将使迹增加 $2\\delta_{\\mathrm{int}}$。\n-   **边界漂移**：在每个时间步，狄利克雷边界条件被设置为 $Q^{\\text{BC}} = Q^\\star + \\delta_{\\mathrm{bnd}} I$。\n\n### 3. 约束强制执行模式\n\n算法实现了三种模式来处理该约束：\n-   **模式 $0$ (不强制执行)**：模拟在不应用任何投影算子 $\\mathcal{P}$ 的情况下进行。由于模拟的误差项，$Q$ 的迹预计会偏离 $0$。\n-   **模式 $1$ (仅内部强制执行)**：在欧拉更新和添加内部漂移后，将投影 $\\mathcal{P}$ 应用于所有内部节点。边界节点被设置为其漂移值，且不被投影。\n-   **模式 $2$ (完全强制执行)**：在更新步骤后，将投影 $\\mathcal{P}$ 应用于所有节点（内部和边界）。然后，应用边界条件（包括漂移）。紧接着，再次对边界节点进行投影，以在所有地方严格强制执行该约束。\n\n单个时间步的算法流程如下：\n1.  计算所有内部节点的拉普拉斯算子 $(\\nabla^2 Q^n)$。\n2.  使用欧拉公式计算内部节点的更新后张量场 $Q^{n+1}_{\\text{temp}}$。\n3.  添加内部漂移项：$Q^{n+1}_{\\text{temp}} \\mathrel{+}= \\delta_{\\mathrm{int}} I$。\n4.  根据所选模式应用投影（`mode` $1$ 对内部节点，`mode` $2$ 对所有节点）。\n5.  将边界值设置为 $Q^\\star + \\delta_{\\mathrm{bnd}} I$。\n6.  如果在 `mode` $2$ 中，将投影 $\\mathcal{P}$ 应用于所有边界节点。\n7.  设置 $Q^{n+1} = Q^{n+1}_{\\text{temp}}$。\n\n### 4. 诊断指标\n\n在每次模拟结束时，计算三个定量诊断指标以评估约束强制执行的有效性：\n1.  **最终内部平均绝对迹**：衡量区域内部迹的平均漂移。\n    $$\n    \\overline{|\\operatorname{tr} Q|}_{\\mathrm{int}} = \\frac{1}{(N_x-2)(N_y-2)} \\sum_{i=1}^{N_x-2} \\sum_{j=1}^{N_y-2} \\left| \\operatorname{tr} Q_{i,j} \\right|\n    $$\n2.  **最终边界最大绝对迹**：衡量边界上最坏情况下的迹违规。\n    $$\n    \\max_{\\mathrm{bnd}} \\left| \\operatorname{tr} Q \\right| = \\max_{\\text{nodes } (i,j) \\text{ on boundary}} \\left| \\operatorname{tr} Q_{i,j} \\right|\n    $$\n3.  **最终均方根 (RMS) 迹**：整个区域上迹违规的全局度量。\n    $$\n    \\mathrm{RMS}(\\operatorname{tr} Q) = \\sqrt{\\frac{1}{N_x N_y} \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\left( \\operatorname{tr} Q_{i,j} \\right)^2 }\n    $$\n这些指标全面地展示了在不同条件和强制执行策略下，$\\operatorname{tr} Q = 0$ 约束的维持情况。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the Beris-Edwards simulation.\n    \"\"\"\n    \n    # Set a seed for reproducibility of random initial perturbations.\n    np.random.seed(0)\n\n    # (Nx, Ny, dt, steps, L, a, Gamma, delta_int, delta_bnd, mode)\n    test_cases = [\n        (24, 24, 0.01, 400, 0.02, 0.10, 1.0, 1e-9, 1e-10, 0),\n        (24, 24, 0.01, 400, 0.02, 0.10, 1.0, 1e-9, 1e-10, 1),\n        (24, 24, 0.01, 400, 0.02, 0.10, 1.0, 1e-9, 1e-6, 0),\n        (24, 24, 0.01, 400, 0.02, 0.10, 1.0, 1e-9, 1e-6, 2),\n        (24, 24, 0.005, 1200, 0.02, 0.10, 1.0, 1e-12, 1e-12, 1),\n    ]\n\n    results = []\n    for params in test_cases:\n        diagnostics = run_simulation(*params)\n        results.extend(diagnostics)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef project_to_symmetric_traceless(M):\n    \"\"\"\n    Projects a 2x2 matrix or a batch of 2x2 matrices onto the symmetric-traceless subspace.\n    The input M is assumed to have shape (..., 2, 2).\n    \"\"\"\n    # Symmetrize: M_s = 0.5 * (M + M^T)\n    M_sym = 0.5 * (M + np.swapaxes(M, -1, -2))\n    \n    # Make traceless: Q = M_s - 0.5 * tr(M_s) * I\n    # trace has shape (...)\n    trace = np.trace(M_sym, axis1=-2, axis2=-1)\n    I = np.identity(2)\n    # Use broadcasting to subtract the isotropic part\n    return M_sym - 0.5 * trace[..., np.newaxis, np.newaxis] * I\n\ndef run_simulation(Nx, Ny, dt, steps, L, a, Gamma, delta_int, delta_bnd, mode):\n    \"\"\"\n    Runs a single simulation with the given parameters and returns the diagnostics.\n    \"\"\"\n    # Constants and initial setup\n    S = 1.0\n    Q_star = S * np.array([[0.5, 0.0], [0.0, -0.5]])\n    I = np.identity(2)\n    Q = np.zeros((Nx, Ny, 2, 2))\n\n    # Initial condition for interior: Q_star + small random sym-traceless perturbation\n    pert_amp = 1e-12\n    # Create random matrix for each interior point\n    rand_pert = pert_amp * (2 * np.random.rand(Nx - 2, Ny - 2, 2, 2) - 1.0)\n    Q[1:-1, 1:-1] = Q_star + project_to_symmetric_traceless(rand_pert)\n\n    # Initial condition for boundary\n    Q[0, :] = Q_star\n    Q[-1, :] = Q_star\n    Q[:, 0] = Q_star\n    Q[:, -1] = Q_star\n\n    # Drift terms\n    drift_int_matrix = delta_int * I\n    Q_bnd_val = Q_star + delta_bnd * I\n\n    # Time-stepping loop\n    for _ in range(steps):\n        Q_new = np.copy(Q)\n\n        # Calculate Laplacian using 5-point stencil on interior\n        lap_Q = (Q[0:-2, 1:-1] + Q[2:, 1:-1] +\n                 Q[1:-1, 0:-2] + Q[1:-1, 2:] - 4 * Q[1:-1, 1:-1])\n\n        # Euler update for interior points\n        RHS = Gamma * (L * lap_Q - a * Q[1:-1, 1:-1])\n        Q_new[1:-1, 1:-1] += dt * RHS\n        \n        # Add interior drift\n        Q_new[1:-1, 1:-1] += drift_int_matrix\n\n        # Apply projection based on mode\n        if mode == 1: # Interior enforcement only\n            Q_new[1:-1, 1:-1] = project_to_symmetric_traceless(Q_new[1:-1, 1:-1])\n        elif mode == 2: # Full enforcement\n            Q_new = project_to_symmetric_traceless(Q_new)\n\n        # Apply boundary conditions\n        Q_new[0, :] = Q_bnd_val\n        Q_new[-1, :] = Q_bnd_val\n        Q_new[:, 0] = Q_bnd_val\n        Q_new[:, -1] = Q_bnd_val\n        \n        # Re-project boundaries for mode 2\n        if mode == 2:\n            Q_new[0, :] = project_to_symmetric_traceless(Q_new[0, :])\n            Q_new[-1, :] = project_to_symmetric_traceless(Q_new[-1, :])\n            Q_new[:, 0] = project_to_symmetric_traceless(Q_new[:, 0])\n            Q_new[:, -1] = project_to_symmetric_traceless(Q_new[:, -1])\n            \n        Q = Q_new\n\n    # --- Calculate final diagnostics ---\n\n    # 1. Mean absolute trace over interior nodes\n    Q_interior = Q[1:-1, 1:-1]\n    trace_Q_interior = np.trace(Q_interior, axis1=2, axis2=3)\n    mean_abs_trace_int = np.mean(np.abs(trace_Q_interior))\n\n    # 2. Maximum absolute trace over boundary nodes\n    bnd_mask = np.ones((Nx, Ny), dtype=bool)\n    bnd_mask[1:-1, 1:-1] = False\n    Q_bnd = Q[bnd_mask]\n    trace_Q_bnd = np.trace(Q_bnd, axis1=1, axis2=2)\n    max_abs_trace_bnd = np.max(np.abs(trace_Q_bnd)) if trace_Q_bnd.size > 0 else 0.0\n    \n    # 3. RMS trace over the whole domain\n    trace_Q_all = np.trace(Q, axis1=2, axis2=3)\n    rms_trace = np.sqrt(np.mean(trace_Q_all**2))\n    \n    return mean_abs_trace_int, max_abs_trace_bnd, rms_trace\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "成功运行模拟后，下一步便是从海量数据中提取有价值的物理信息，而拓扑缺陷的演化是向列相流体动力学中最引人入胜的现象之一。本实践聚焦于一项关键的后处理技能：如何从模拟产生的 $Q$ 张量场中准确地识别拓扑缺陷。你将基于指导子场（director field）的卷绕数（winding number）原理，编写一个算法来定位缺陷并确定其拓扑荷，从而将原始的张量数据转化为对系统结构和动力学的深刻理解 。",
            "id": "4079596",
            "problem": "您的任务是基于向列相流体动力学的 Beris-Edwards 模型，开发并验证一个用于检测二维向列相场中拓扑缺陷的数值判据。在向列相液晶中，其状态由一个对称、无迹的二阶张量——Landau–de Gennes 排列张量 $Q$ 描述。对于二维平面向列相，张量 $Q$ 可以用一个标量序参量 $S$ 和一个指向矢场 $\\mathbf{n} = (\\cos\\theta, \\sin\\theta)$ 表示为\n$$\nQ = S\\left(\\mathbf{n}\\otimes\\mathbf{n} - \\frac{1}{2}I\\right),\n$$\n其中 $I$ 是单位张量，$\\theta$ 是指向矢角。在 Beris–Edwards 模型中，$Q$ 的主特征向量给出了局部指向矢，其定义模一个符号，这意味着指向矢角仅在模 $\\pi$ 的意义下有定义。\n\n由闭合回路 $\\Gamma$ 包围的缺陷的拓扑荷 $s$ 由指向矢角绕回路的卷绕数给出：\n$$\ns = \\frac{1}{\\pi}\\oint_{\\Gamma} d\\theta,\n$$\n其中角度以弧度为单位。因为指向矢是无头的，所以指向矢角差必须以 $\\pi$ 为模进行计算，以确保每一步都取最小的变化量。在数值上，可以通过对每个网格单元周边的角度差求和，然后除以 $\\pi$，来在离散网格上计算 $s$。\n\n从这些定义出发，实现一个程序，该程序能够：\n1. 针对给定的缺陷集合，在方形网格上构建合成的二维排列张量场 $Q(\\mathbf{x})$。合成的指向矢角场定义为\n$$\n\\theta(x,y) = \\sum_{i=1}^{N_d} s_i \\, \\mathrm{atan2}(y-y_i, x-x_i),\n$$\n其中 $s_i\\in\\{\\pm \\tfrac{1}{2}\\}$ 是缺陷荷，$(x_i,y_i)$ 是缺陷位置，$\\mathrm{atan2}$ 是双参数反正切函数，返回以弧度为单位的角度。使用一个恒定的标量序参量 $S_0$，通过上述定义从 $\\theta$ 构建 $Q$。\n2. 利用主特征向量从 $Q$ 中恢复每个网格点的指向矢角。为保证数值稳定性和效率，您必须使用以下不变关系式计算指向矢角\n$$\n\\theta = \\frac{1}{2}\\,\\mathrm{atan2}\\left(2\\,Q_{xy},\\,Q_{xx}-Q_{yy}\\right),\n$$\n这会得到模 $\\pi$ 的角度。\n3. 通过对每个网格单元周边的角度差求和来计算该单元的卷绕数 $s$，其中每个角度差都以 $\\pi$ 为模，缩减到主值区间 $(-\\tfrac{\\pi}{2},\\tfrac{\\pi}{2}]$。如果 $\\lvert s\\rvert$ 超过一个检测阈值，则将该单元分类为包含缺陷。\n4. 将符号相同的相邻缺陷单元聚类成候选缺陷，并将每个候选缺陷的电荷估计为其单元卷绕数的平均值，其位置估计为其单元的质心。\n5. 通过将检测到的缺陷与已知的合成缺陷进行比较来验证检测结果，使用以单位正方形测量的位置容差和相对于 $\\pm\\tfrac{1}{2}$ 的电荷容差。\n\n所有角度都必须以弧度处理。您的实现必须是确定性的和自包含的。\n\n测试套件规范：\n使用以下五个测试用例；在所有用例中，定义域均为单位正方形 $[0,1]\\times[0,1]$，并且计算必须以弧度为单位。\n\n- 测试用例 1 (单个正缺陷，内部):\n    - 网格大小 $N = 128$。\n    - 标量序参量 $S_0 = 0.6$。\n    - 缺陷：一个位于 $(x_1,y_1)=(0.50,0.50)$，电荷为 $s_1=+\\tfrac{1}{2}$。\n    - 位置容差：$0.05$。\n    - 电荷容差：$0.2$。\n    - 单元卷绕数的检测阈值：$0.3$。\n\n- 测试用例 2 (单个负缺陷，内部):\n    - 网格大小 $N = 128$。\n    - 标量序参量 $S_0 = 0.6$。\n    - 缺陷：一个位于 $(x_1,y_1)=(0.50,0.50)$，电荷为 $s_1=-\\tfrac{1}{2}$。\n    - 位置容差：$0.05$。\n    - 电荷容差：$0.2$。\n    - 检测阈值：$0.3$。\n\n- 测试用例 3 (一对相反缺陷，偏离中心):\n    - 网格大小 $N = 128$。\n    - 标量序参量 $S_0 = 0.6$。\n    - 缺陷：$(x_1,y_1)=(0.30,0.70)$，电荷 $s_1=+\\tfrac{1}{2}$，以及 $(x_2,y_2)=(0.70,0.30)$，电荷 $s_2=-\\tfrac{1}{2}$。\n    - 位置容差：$0.05$。\n    - 电荷容差：$0.2$。\n    - 检测阈值：$0.3$。\n\n- 测试用例 4 (无缺陷的均匀场):\n    - 网格大小 $N = 128$。\n    - 标量序参量 $S_0 = 0.6$。\n    - 缺陷：无；对所有点取 $\\theta(x,y)=0$。\n    - 检测阈值：$0.3$。\n    - 预期结果：未检测到缺陷。\n\n- 测试用例 5 (靠近边界的正缺陷):\n    - 网格大小 $N = 128$。\n    - 标量序参量 $S_0 = 0.6$。\n    - 缺陷：一个位于 $(x_1,y_1)=(0.05,0.95)$，电荷为 $s_1=+\\tfrac{1}{2}$。\n    - 位置容差：$0.05$。\n    - 电荷容差：$0.2$。\n    - 检测阈值：$0.3$。\n\n程序输出规范：\n您的程序应生成一行输出，其中包含五个测试用例的结果。结果是一个用方括号括起来的逗号分隔列表，每个结果都是一个布尔值，指示检测结果是否与该测试用例的预期数量、在位置容差内的位置以及在电荷容差内的电荷相匹配。例如，输出格式必须与此完全一样：\n[$\\text{result}_1$,$\\text{result}_2$,$\\text{result}_3$,$\\text{result}_4$,$\\text{result}_5$]",
            "solution": "问题陈述经评估是有效的。它在科学上基于已确立的 Landau–de Gennes 和 Beris–Edwards 向列相液晶理论原理。该问题是适定的，提供了一套完整且一致的定义、物理参数和数值步骤。目标和验证标准以清晰、明确的量化语言陈述。任务是实现一个多步数值算法，以识别模拟的二维向列相场中的拓扑缺陷，并根据已知的基准真相验证检测结果。\n\n针对每个测试用例，该解决方案按五个步骤实现：(1) 在离散网格上生成合成的排列张量场 $Q(\\mathbf{x})$，(2) 从 $Q(\\mathbf{x})$ 中恢复指向矢角场 $\\theta(\\mathbf{x})$，(3) 计算每个网格单元的拓扑荷密度（卷绕数）以识别缺陷核心，(4) 对相邻的缺陷单元进行聚类，以定义和表征候选缺陷，以及 (5) 根据人工生成的基准真相验证检测到的缺陷。\n\n**1. 合成场的生成**\n\n向列相场在单位正方形域 $[0,1]\\times[0,1]$ 上被离散化到一个均匀的 $N \\times N$ 网格上。网格间距为 $h=1/(N-1)$。网格点 $(i,j)$（其中 $i,j \\in \\{0, 1, \\dots, N-1\\}$）的坐标由 $(x_i, y_j) = (i \\cdot h, j \\cdot h)$ 给出。\n\n首先构造一个合成的指向矢角场 $\\theta(x,y)$。对于一组 $N_d$ 个点缺陷，每个缺陷的电荷为 $s_k \\in \\{\\pm \\frac{1}{2}\\}$，位置为 $(x_k, y_k)$，任意点 $(x,y)$ 处的指向矢角由每个缺陷场的叠加给出：\n$$\n\\theta(x,y) = \\sum_{k=1}^{N_d} s_k \\, \\mathrm{atan2}(y-y_k, x-x_k)\n$$\n函数 $\\mathrm{atan2}(v,u)$ 返回正 $u$ 轴与点 $(u,v)$ 之间的夹角（以弧度为单位）。该表达式生成了拓扑缺陷的特征相位卷绕。在没有缺陷的情况下，此和为空，且对所有点 $\\theta(x,y)=0$，表示一个均匀的指向矢场。\n\n从该角度场 $\\theta(x,y)$ 和一个给定的恒定标量序参量 $S_0$ 出发，计算每个网格点上排列张量 $Q$ 的分量。二维平面向列相的 $Q$ 张量定义为：\n$$\nQ = S_0 \\left( \\mathbf{n}\\otimes\\mathbf{n} - \\frac{1}{2}I \\right)\n$$\n其中 $\\mathbf{n} = (\\cos\\theta, \\sin\\theta)$ 是指向矢量，$I$ 是 $2 \\times 2$ 单位矩阵。各个分量为：\n$$\n\\begin{aligned}\nQ_{xx} = S_0 \\left( \\cos^2\\theta - \\frac{1}{2} \\right) \\\\\nQ_{yy} = S_0 \\left( \\sin^2\\theta - \\frac{1}{2} \\right) = -Q_{xx} \\\\\nQ_{xy} = S_0 \\cos\\theta \\sin\\theta\n\\end{aligned}\n$$\n这三个分量存储在 $N \\times N$ 数组中，构成了检测算法的合成输入数据。\n\n**2. 指向矢场的恢复**\n\n下一步是从合成的 $Q$ 张量中恢复指向矢角场，模拟 $Q$ 是模拟或实验结果的情景。指向矢对应于 $Q$ 的主特征向量。该特征向量的角度 $\\theta$ 是在模 $\\pi$ 意义下确定的，反映了向列相指向矢的首尾对称性 $(\\mathbf{n} \\equiv -\\mathbf{n})$。一种恢复此角度的高效且数值稳定的方法是通过所提供的不变关系式：\n$$\n\\theta_{\\text{rec}} = \\frac{1}{2} \\mathrm{atan2}(2Q_{xy}, Q_{xx}-Q_{yy})\n$$\n该公式正确地给出了范围在 $(-\\pi/2, \\pi/2]$ 内的指向矢角，这是指向矢方向在模 $\\pi$ 意义下的有效表示。这个恢复的场 $\\theta_{\\text{rec}}$ 用于所有后续计算。\n\n**3. 通过卷绕数识别缺陷核心**\n\n拓扑缺陷是指向矢场中的一个奇点。它在某个区域内的存在性，通过指向矢角围绕该区域边界的非零净卷绕来揭示。缺陷的拓扑荷 $s$ 由积分 $s = \\frac{1}{\\pi} \\oint d\\theta$ 给出。\n\n我们对网格中的每个基本单元计算其离散版本。一个单元 $(i,j)$ 是由四个网格顶点 $(i,j)$、$(i+1,j)$、$(i+1,j+1)$ 和 $(i,j+1)$ 定义的正方形。我们沿着单元周边的逆时针路径对恢复的角度 $\\theta_{\\text{rec}}$ 的差值求和：\n$$\n\\Delta\\theta_{\\text{total}} = (\\theta_{i+1,j} - \\theta_{i,j}) + (\\theta_{i+1,j+1} - \\theta_{i+1,j}) + (\\theta_{i,j+1} - \\theta_{i+1,j+1}) + (\\theta_{i,j} - \\theta_{i,j+1})\n$$\n其中 $\\theta_{i,j}$ 是网格点 $(i,j)$ 处的角度。至关重要的是，由于 $\\theta$ 是在模 $\\pi$ 意义下定义的，每个角度差 $\\Delta\\theta$ 都必须被“包裹”到主值区间 $(-\\pi/2, \\pi/2]$ 以表示最小的旋转。这通过操作 $\\Delta\\theta' = \\Delta\\theta - \\pi \\cdot \\text{round}(\\Delta\\theta/\\pi)$ 来实现。单元 $(i,j)$ 的卷绕数则为：\n$$\ns_{ij} = \\frac{1}{\\pi} \\sum_{\\text{edges}} \\Delta\\theta'\n$$\n对所有 $(N-1) \\times (N-1)$ 个单元执行此计算。如果一个单元的卷绕数绝对值 $|s_{ij}|$ 超过指定的检测阈值，则该单元被归类为“缺陷单元”。\n\n**4. 缺陷聚类与表征**\n\n单个拓扑缺陷可能跨越多个相邻的网格单元，所有这些单元都会表现出显著的卷绕数。必须将这些缺陷单元分组为簇，以识别单个候选缺陷。为此，采用了广度优先搜索 (BFS) 算法。该算法遍历单元网格。当发现一个未访问的缺陷单元时，启动一次 BFS 来查找所有具有相同卷绕数符号（即正或负）的相连缺陷单元。连通性定义为共享一条边（4-连通性）。\n\n一旦识别出一个单元簇，它就被表征为单个候选缺陷：\n-   **电荷**：候选缺陷的电荷计算为簇内所有单元卷绕数 $s_{ij}$ 的算术平均值。\n-   **位置**：候选缺陷的位置是簇中各单元中心的质心。如果一个单元的左下角位于 $(x_i, y_j)$，其中心则位于 $(x_i + h/2, y_j + h/2)$。\n\n**5. 验证**\n\n最后一步是将检测到的候选缺陷列表与原始的合成缺陷列表进行比较。验证过程如下：\n1.  将真实缺陷列表和检测到的缺陷列表都根据电荷分为两个子列表：正电荷 ($s0$) 和负电荷 ($s0$)。\n2.  对于没有真实缺陷的情况，当且仅当没有检测到任何缺陷时，验证才算成功。\n3.  对于有缺陷的情况，检测到的正缺陷数量必须与真实的正缺陷数量相匹配，负缺陷同样如此。如果数量不匹配，则验证失败。\n4.  如果数量匹配，则必须在相同符号的真实缺陷和检测到的缺陷之间建立一一对应关系。这是一个分配问题，可以使用 `scipy.optimize.linear_sum_assignment` 函数来最优地解决。分配的成本矩阵是真实缺陷和检测到的缺陷位置之间的欧几里得距离。\n5.  对于每个真实缺陷及其匹配的检测缺陷对，必须满足两个条件：\n    a. 它们位置之间的欧几里得距离必须小于或等于指定的位置容差。\n    b. 它们电荷之间的绝对差值 $|s_{\\text{det}} - s_{\\text{true}}|$ 必须小于或等于指定的电荷容差。\n6.  仅当所有缺陷计数匹配，并且每个匹配对都满足位置和电荷容差标准时，该测试用例才被视为通过 (True)。否则，视为失败 (False)。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linear_sum_assignment\nfrom scipy.spatial.distance import cdist\nfrom collections import deque\n\ndef run_test_case(N, S0, defects, pos_tol, charge_tol, threshold):\n    \"\"\"\n    Runs a single test case for defect detection.\n\n    Args:\n        N (int): Grid size (N x N).\n        S0 (float): Scalar order parameter.\n        defects (list): List of dictionaries, each specifying a defect's charge and position.\n        pos_tol (float): Positional tolerance for validation.\n        charge_tol (float): Charge tolerance for validation.\n        threshold (float): Detection threshold for cell winding.\n\n    Returns:\n        bool: True if detection is successful, False otherwise.\n    \"\"\"\n\n    # Step 1: Synthetic Field Generation\n    h = 1.0 / (N - 1)\n    x_coords = np.linspace(0, 1, N)\n    y_coords = np.linspace(0, 1, N)\n    x_grid, y_grid = np.meshgrid(x_coords, y_coords)\n\n    theta_field = np.zeros((N, N), dtype=float)\n    if not defects: # Special handling for case 4\n        # theta_field is already zero, but this is explicit\n        pass\n    else:\n        for defect in defects:\n            s_i, (x_i, y_i) = defect['charge'], defect['pos']\n            theta_field += s_i * np.arctan2(y_grid - y_i, x_grid - x_i)\n\n    cos_theta = np.cos(theta_field)\n    sin_theta = np.sin(theta_field)\n\n    Q_xx = S0 * (cos_theta**2 - 0.5)\n    Q_xy = S0 * cos_theta * sin_theta\n    # Q_yy = -Q_xx is implied by tracelessness\n\n    # Step 2: Director Field Recovery\n    theta_rec = 0.5 * np.arctan2(2 * Q_xy, Q_xx - (-Q_xx))\n\n    # Step 3: Defect Core Identification\n    def wrap_angle_diff(d_theta):\n        return d_theta - np.pi * np.round(d_theta / np.pi)\n\n    theta_bl = theta_rec[:-1, :-1]\n    theta_br = theta_rec[:-1, 1:]\n    theta_tr = theta_rec[1:, 1:]\n    theta_tl = theta_rec[1:, :-1]\n\n    d1 = wrap_angle_diff(theta_br - theta_bl)\n    d2 = wrap_angle_diff(theta_tr - theta_br)\n    d3 = wrap_angle_diff(theta_tl - theta_tr)\n    d4 = wrap_angle_diff(theta_bl - theta_tl)\n\n    windings = (1.0 / np.pi) * (d1 + d2 + d3 + d4)\n    is_defect_cell = np.abs(windings) > threshold\n\n    # Step 4: Defect Clustering\n    detected_defects = []\n    visited = np.zeros_like(is_defect_cell, dtype=bool)\n    rows, cols = is_defect_cell.shape\n\n    for r in range(rows):\n        for c in range(cols):\n            if is_defect_cell[r, c] and not visited[r, c]:\n                sign = np.sign(windings[r, c])\n                q = deque([(r, c)])\n                visited[r, c] = True\n                cluster_cells_indices = []\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    cluster_cells_indices.append((curr_r, curr_c))\n\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        if (0 = nr  rows and 0 = nc  cols and\n                            not visited[nr, nc] and is_defect_cell[nr, nc] and\n                            np.sign(windings[nr, nc]) == sign):\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                cell_indices_r, cell_indices_c = zip(*cluster_cells_indices)\n                cell_indices_r = np.array(cell_indices_r)\n                cell_indices_c = np.array(cell_indices_c)\n\n                avg_charge = np.mean(windings[cell_indices_r, cell_indices_c])\n                centroid_x = np.mean(cell_indices_c + 0.5) * h\n                centroid_y = np.mean(cell_indices_r + 0.5) * h\n\n                detected_defects.append({\n                    'pos': (centroid_x, centroid_y),\n                    'charge': avg_charge\n                })\n\n    # Step 5: Validation\n    true_defects = defects\n\n    if not true_defects:\n        return not detected_defects\n\n    true_pos = [d for d in true_defects if d['charge'] > 0]\n    true_neg = [d for d in true_defects if d['charge']  0]\n    detected_pos = [d for d in detected_defects if d['charge'] > 0]\n    detected_neg = [d for d in detected_defects if d['charge']  0]\n\n    def match_defects(true_list, detected_list, p_tol, c_tol):\n        if len(true_list) != len(detected_list):\n            return False\n        if not true_list:\n            return True\n\n        true_coords = [d['pos'] for d in true_list]\n        det_coords = [d['pos'] for d in detected_list]\n\n        cost_matrix = cdist(true_coords, det_coords)\n        true_indices, det_indices = linear_sum_assignment(cost_matrix)\n\n        for t_idx, d_idx in zip(true_indices, det_indices):\n            pos_diff = cost_matrix[t_idx, d_idx]\n            if pos_diff > p_tol:\n                return False\n            \n            charge_diff = abs(detected_list[d_idx]['charge'] - true_list[t_idx]['charge'])\n            if charge_diff > c_tol:\n                return False\n        \n        return True\n\n    pos_match = match_defects(true_pos, detected_pos, pos_tol, charge_tol)\n    neg_match = match_defects(true_neg, detected_neg, pos_tol, charge_tol)\n    \n    return pos_match and neg_match\n\ndef solve():\n    test_cases = [\n        # Test Case 1\n        {\n            'N': 128, 'S0': 0.6,\n            'defects': [{'pos': (0.50, 0.50), 'charge': 0.5}],\n            'pos_tol': 0.05, 'charge_tol': 0.2, 'threshold': 0.3\n        },\n        # Test Case 2\n        {\n            'N': 128, 'S0': 0.6,\n            'defects': [{'pos': (0.50, 0.50), 'charge': -0.5}],\n            'pos_tol': 0.05, 'charge_tol': 0.2, 'threshold': 0.3\n        },\n        # Test Case 3\n        {\n            'N': 128, 'S0': 0.6,\n            'defects': [\n                {'pos': (0.30, 0.70), 'charge': 0.5},\n                {'pos': (0.70, 0.30), 'charge': -0.5}\n            ],\n            'pos_tol': 0.05, 'charge_tol': 0.2, 'threshold': 0.3\n        },\n        # Test Case 4\n        {\n            'N': 128, 'S0': 0.6,\n            'defects': [],\n            'pos_tol': 0.05, 'charge_tol': 0.2, 'threshold': 0.3\n        },\n        # Test Case 5\n        {\n            'N': 128, 'S0': 0.6,\n            'defects': [{'pos': (0.05, 0.95), 'charge': 0.5}],\n            'pos_tol': 0.05, 'charge_tol': 0.2, 'threshold': 0.3\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_test_case(\n            case['N'], case['S0'], case['defects'],\n            case['pos_tol'], case['charge_tol'], case['threshold']\n        )\n        results.append(str(result).lower())\n\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}