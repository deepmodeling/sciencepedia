{
    "hands_on_practices": [
        {
            "introduction": "理论模型通过无量纲数将复杂的物理现象联系起来。在液晶动力学中，埃里克森数（Ericksen number）$Er$ 和德博拉数（Deborah number）$De$ 分别量化了粘性力与弹性力、流动时间尺度与材料弛豫时间尺度之间的竞争。通过一个基于真实微流体实验场景的计算练习 ，我们将学习如何从基本的物理参数出发，推导并估算这些关键的无量纲数，从而对向列相液晶在流动中的行为建立直观的物理图像。",
            "id": "4079599",
            "problem": "一个在压力驱动的微流控通道中的热致向列液晶（例如，4-4'-戊基氰基联苯）可以使用Beris-Edwards (BE) 液晶流体动力学模型进行建模，其中流体速度场$\\,\\mathbf{u}\\,$服从增加了取向应力项的Navier-Stokes方程的动量平衡，而取向序由排列张量$\\,\\mathbf{Q}\\,$描述，其动力学为$\\partial_{t}\\mathbf{Q}-\\mathbf{S}(\\nabla\\mathbf{u},\\mathbf{Q})=\\Gamma\\,\\mathbf{H}$，其中$\\,\\mathbf{H}=-\\delta F/\\delta \\mathbf{Q}\\,$是从Landau-de Gennes自由能导出的分子场。在标度分析中，粘性效应和弹性效应之间的竞争由Ericksen数表征，时间尺度竞争由Deborah数表征。从以下基本概念出发：剪切速率为$\\,\\dot{\\gamma}\\,$时粘性应力标度为$\\,\\eta\\,\\dot{\\gamma}\\,$，以及在长度$\\,L\\,$上与指向矢畸变相关的弹性分子场标度为$\\,K/L^{2}\\,$（单一Frank常数近似），推导Ericksen数$\\,\\mathrm{Er}\\,$和Deborah数$\\,\\mathrm{De}\\,$用材料和几何参数表示的表达式。然后采用以下代表室温热致向列液晶的实际参数值：\n- 各向同性等效剪切粘度大小 $\\,\\eta = 0.10\\,\\mathrm{Pa\\,s}\\,$，\n- 旋转粘度 $\\,\\gamma_{1} = 0.050\\,\\mathrm{Pa\\,s}\\,$，\n- 单一Frank弹性常数 $\\,K = 7.0\\times 10^{-12}\\,\\mathrm{N}\\,$，\n以及微流控条件：\n- 通道高度 $\\,H = 50\\,\\mu\\mathrm{m}\\,$，作为特征长度 $\\,L\\,$，\n- 平均流速 $\\,U = 1.0\\,\\mathrm{mm/s}\\,$，给出估计的剪切速率 $\\,\\dot{\\gamma}\\approx U/H\\,$。\n\n使用这些值，计算$\\,\\mathrm{Er}\\,$和$\\,\\mathrm{De}\\,$。将最终的无量纲结果表示为不带单位的数值，并四舍五入到三位有效数字。",
            "solution": "该问题被验证为具有科学依据、适定且客观。它提供了一套完整且一致的定义、物理原理和数据，用于在特定流动条件下推导和计算向列液晶的Ericksen数和Deborah数。\n\n推导和计算过程如下。\n\n**1. Ericksen数（$\\mathrm{Er}$）的推导**\n\nEricksen数（$\\mathrm{Er}$）量化了流动液晶中粘性效应和弹性效应之间的竞争。它定义为特征粘性应力$\\sigma_{\\text{visc}}$与特征弹性应力$\\sigma_{\\text{el}}$之比。\n$$\n\\mathrm{Er} = \\frac{\\sigma_{\\text{visc}}}{\\sigma_{\\text{el}}}\n$$\n问题提供了与剪切速率为$\\dot{\\gamma}$、剪切粘度为$\\eta$的剪切流相关的粘性应力的标度：\n$$\n\\sigma_{\\text{visc}} \\sim \\eta \\dot{\\gamma}\n$$\n弹性应力源于液晶取向序在特征长度尺度$L$上的空间畸变。该应力与分子场$\\mathbf{H}$相关，而分子场$\\mathbf{H}$又源自Frank弹性自由能。问题提供了在单常数近似（$K$）下分子场的标度：\n$$\nH \\sim \\frac{K}{L^2}\n$$\n弹性应力张量分量与分子场成正比，因此弹性应力的大小也类似地标度：\n$$\n\\sigma_{\\text{el}} \\sim \\frac{K}{L^2}\n$$\n将应力标度代入Ericksen数的定义，得到表达式：\n$$\n\\mathrm{Er} = \\frac{\\eta \\dot{\\gamma}}{K / L^2} = \\frac{\\eta \\dot{\\gamma} L^2}{K}\n$$\n\n**2. Deborah数（$\\mathrm{De}$）的推导**\n\nDeborah数（$\\mathrm{De}$）表征了时间尺度之间的竞争。它定义为材料的内在弛豫时间$\\tau_{\\text{relax}}$与流动过程的特征时间尺度$\\tau_{\\text{flow}}$之比。\n$$\n\\mathrm{De} = \\frac{\\tau_{\\text{relax}}}{\\tau_{\\text{flow}}}\n$$\n流动的特征时间尺度是特征应变速率的倒数，即剪切速率$\\dot{\\gamma}$的倒数：\n$$\n\\tau_{\\text{flow}} \\sim \\frac{1}{\\dot{\\gamma}}\n$$\n材料的弛豫时间$\\tau_{\\text{relax}}$是取向序在受到扰动后恢复到平衡所需的时间。该过程涉及恢复弹性扭矩密度与耗散粘性扭矩密度之间的平衡。弹性扭矩密度由分子场驱动，标度为$\\sim H \\sim K/L^2$。耗散粘性扭矩密度是由于指向矢克服旋转粘度$\\gamma_1$进行旋转所致，标度为$\\sim \\gamma_1 \\dot{\\theta}$，其中$\\dot{\\theta}$是角旋转速率。对于弛豫过程，特征速率为$\\dot{\\theta} \\sim 1/\\tau_{\\text{relax}}$。因此，耗散粘性扭矩密度为$\\sim \\gamma_1 / \\tau_{\\text{relax}}$。\n通过平衡弹性和粘性扭矩，我们得到：\n$$\n\\frac{\\gamma_1}{\\tau_{\\text{relax}}} \\sim \\frac{K}{L^2}\n$$\n解出弛豫时间得到：\n$$\n\\tau_{\\text{relax}} \\sim \\frac{\\gamma_1 L^2}{K}\n$$\n将时间尺度代入Deborah数的定义，得到表达式：\n$$\n\\mathrm{De} = \\frac{\\gamma_1 L^2 / K}{1 / \\dot{\\gamma}} = \\frac{\\gamma_1 \\dot{\\gamma} L^2}{K}\n$$\n\n**3. 数值计算**\n\n首先，我们必须将所有给定参数用一致的国际单位制（SI）单位表示。\n- 各向同性等效剪切粘度：$\\eta = 0.10\\,\\mathrm{Pa\\,s} = 0.10\\,\\mathrm{N\\,s\\,m^{-2}}$\n- 旋转粘度：$\\gamma_1 = 0.050\\,\\mathrm{Pa\\,s} = 0.050\\,\\mathrm{N\\,s\\,m^{-2}}$\n- 单一Frank弹性常数：$K = 7.0 \\times 10^{-12}\\,\\mathrm{N}$\n- 特征长度：$L = H = 50\\,\\mu\\mathrm{m} = 5.0 \\times 10^{-5}\\,\\mathrm{m}$\n- 平均流速：$U = 1.0\\,\\mathrm{mm/s} = 1.0 \\times 10^{-3}\\,\\mathrm{m\\,s^{-1}}$\n\n接下来，我们计算估计的剪切速率$\\dot{\\gamma}$：\n$$\n\\dot{\\gamma} \\approx \\frac{U}{H} = \\frac{1.0 \\times 10^{-3}\\,\\mathrm{m\\,s^{-1}}}{5.0 \\times 10^{-5}\\,\\mathrm{m}} = 20\\,\\mathrm{s^{-1}}\n$$\n现在我们计算Ericksen数$\\mathrm{Er}$：\n$$\n\\mathrm{Er} = \\frac{\\eta \\dot{\\gamma} L^2}{K} = \\frac{(0.10\\,\\mathrm{N\\,s\\,m^{-2}})(20\\,\\mathrm{s^{-1}})(5.0 \\times 10^{-5}\\,\\mathrm{m})^2}{7.0 \\times 10^{-12}\\,\\mathrm{N}}\n$$\n$$\n\\mathrm{Er} = \\frac{(2.0)(25 \\times 10^{-10})}{7.0 \\times 10^{-12}} = \\frac{50 \\times 10^{-10}}{7.0 \\times 10^{-12}} = \\frac{50}{7.0} \\times 10^2 \\approx 7.1428 \\times 10^2\n$$\n四舍五入到三位有效数字，我们得到$\\mathrm{Er} = 714$。\n\n最后，我们计算Deborah数$\\mathrm{De}$：\n$$\n\\mathrm{De} = \\frac{\\gamma_1 \\dot{\\gamma} L^2}{K} = \\frac{(0.050\\,\\mathrm{N\\,s\\,m^{-2}})(20\\,\\mathrm{s^{-1}})(5.0 \\times 10^{-5}\\,\\mathrm{m})^2}{7.0 \\times 10^{-12}\\,\\mathrm{N}}\n$$\n$$\n\\mathrm{De} = \\frac{(1.0)(25 \\times 10^{-10})}{7.0 \\times 10^{-12}} = \\frac{25 \\times 10^{-10}}{7.0 \\times 10^{-12}} = \\frac{25}{7.0} \\times 10^2 \\approx 3.5714 \\times 10^2\n$$\n四舍五入到三位有效数字，我们得到$\\mathrm{De} = 357$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n714  357\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "拓扑缺陷是向列相液晶中最迷人的特征之一，它们的相互作用和运动由系统的自由能景观决定。这个练习将引导我们通过一个简化的解析模型，深入理解一对电荷相反的缺陷是如何相互吸引并最终湮灭的。通过推导缺陷对的湮灭时间 ，我们将揭示Beris-Edwards模型的参数（如旋转迁移率和弹性常数）与可观测的缺陷动力学行为之间的直接联系。",
            "id": "4079585",
            "problem": "考虑一种二维 ($2$D) 向列液晶，在没有流体动力学流动的情况下，由 Beris–Edwards 模型描述。其取向序由对称、无迹的序参量张量 $Q$ 表示，其纯弛豫动力学（无回流）由 Beris–Edwards 方程给出\n$$\n\\partial_t Q = - \\Gamma \\, \\frac{\\delta \\mathcal{F}[Q]}{\\delta Q},\n$$\n其中 $\\Gamma$ 是旋转迁移率（一个正常数），$\\mathcal{F}[Q]$ 是 Landau–de Gennes (LdG) 自由能泛函。在弹性的单常数近似下，并限制在二维空间中，该自由能泛函可写作\n$$\n\\mathcal{F}[Q] = \\int_{\\Omega} \\left( f_b(Q) + \\frac{L_1}{2} \\, \\partial_k Q_{ij} \\, \\partial_k Q_{ij} \\right) \\, d^2x,\n$$\n其中 $L_1$ 是单一弹性常数，$f_b(Q)$ 是一个稳定优选序幅值的体势，重复的下标表示求和。假设一个等幅简化，其中张量 $Q$ 采取单轴平面形式\n$$\nQ = S_0 \\left( n \\otimes n - \\frac{I}{2} \\right), \\quad n = (\\cos \\theta, \\sin \\theta), \\quad S_0 = 1,\n$$\n并且标量序参量 $S_0$ 在空间和时间上是恒定的。在此简化下，弹性等效于指向矢的单常数 Frank 能量，其有效 Frank 常数为\n$$\nK = 2 L_1 S_0^2 = 2 L_1.\n$$\n此外，在此流形上以及相同的假设下，角度场 $\\theta$ 服从扩散类型的纯弛豫动力学\n$$\n\\partial_t \\theta = \\Gamma K \\nabla^2 \\theta.\n$$\n现在考虑一个初始条件，包含一对电荷为 $+1/2$ 和 $-1/2$ 的拓扑缺陷，其中心间距为 $r_0$，位于一个大区域内，远离边界，因此在所关心的时间尺度上，镜像相互作用可以忽略不计。远离缺陷核心处，角度场是调和的，并且这对缺陷通过一个仅依赖于其间距 $r$ 的有效弹性相互作用势相互作用。在仅有指向矢描述和单常数弹性的情况下，两个电荷为 $q_1$ 和 $q_2$、间距为 $r$ 的缺陷的相互作用能具有以下形式\n$$\nV(r) = - 2 \\pi K q_1 q_2 \\ln r + \\text{const.}\n$$\n将这对缺陷视为点状物体，其间距 $r(t)$ 根据在 $V(r)$ 上的梯度下降动力学演化，其有效各向同性迁移率等于沿中心线的旋转迁移率 $\\Gamma$，因此\n$$\n\\frac{dr}{dt} = - \\Gamma \\, \\frac{dV}{dr}.\n$$\n仅使用上述基本定律和核心定义，不使用任何其他捷径，推导出一个显式解析表达式，用于计算在所述的等幅和单常数近似下，根据此 Beris–Edwards 演化，缺陷对将其间距从 $r_0$ 减小到 $0$ 所需的湮灭时间 $T(\\Gamma, L_1; r_0)$。按照上述无量纲化选择所暗示的无量纲单位进行计算（特别是，取 $S_0 = 1$ 以使 $K = 2 L_1$），并以这些无量纲时间单位表示最终的湮灭时间 $T$。\n\n然后，实现一个程序，对于以下参数值测试套件，使用您推导的公式计算湮灭时间 $T$。对所有测试用例使用相同的初始间距 $r_0 = 8.0$（无量纲）：\n- 情况 1：$(\\Gamma, L_1) = (0.5, 1.0)$\n- 情况 2：$(\\Gamma, L_1) = (0.1, 1.0)$\n- 情况 3：$(\\Gamma, L_1) = (0.5, 0.2)$\n- 情况 4：$(\\Gamma, L_1) = (1.0, 2.0)$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个湮灭时间四舍五入到恰好 $6$ 位小数，例如 $[t_1,t_2,t_3,t_4]$，其中每个 $t_i$ 是一个浮点数。所有答案必须以指定的无量纲时间单位报告。输出必须按照上面列出的情况顺序排列。最终输出为实值浮点数。",
            "solution": "所述问题具有科学依据，提法恰当，客观且内部一致。所有必要信息均已提供，可在指定近似下推导出缺陷对湮灭时间的唯一且有意义的解。因此，我们可以开始推导。\n\n目标是找到一对电荷为 $q_1 = +1/2$ 和 $q_2 = -1/2$ 的拓扑缺陷的湮灭时间 $T$，它们从初始间距 $r(t=0) = r_0$ 开始，到最终间距 $r(t=T) = 0$ 结束。间距 $r(t)$ 的动力学由相互作用势 $V(r)$ 上的梯度下降控制：\n$$\n\\frac{dr}{dt} = - \\Gamma \\, \\frac{dV}{dr}\n$$\n其中 $\\Gamma$ 是旋转迁移率。\n\n首先，我们必须确定力项 $\\frac{dV}{dr}$。在单常数弹性介质中，两个电荷为 $q_1$ 和 $q_2$ 的缺陷之间的相互作用势 $V(r)$ 由下式给出：\n$$\nV(r) = - 2 \\pi K q_1 q_2 \\ln r + \\text{const.}\n$$\n其中 $K$ 是有效 Frank 常数。该势对间距 $r$ 的导数为：\n$$\n\\frac{dV}{dr} = \\frac{d}{dr} \\left( - 2 \\pi K q_1 q_2 \\ln r + \\text{const.} \\right) = - 2 \\pi K q_1 q_2 \\frac{1}{r}\n$$\n问题指定缺陷电荷为 $q_1 = +1/2$ 和 $q_2 = -1/2$。将这些值代入力表达式中，得到：\n$$\n\\frac{dV}{dr} = - 2 \\pi K \\left( \\frac{1}{2} \\right) \\left( -\\frac{1}{2} \\right) \\frac{1}{r} = - 2 \\pi K \\left( -\\frac{1}{4} \\right) \\frac{1}{r} = \\frac{\\pi K}{2r}\n$$\n\n接下来，我们将此力项代入 $r(t)$ 的运动方程：\n$$\n\\frac{dr}{dt} = - \\Gamma \\left( \\frac{\\pi K}{2r} \\right) = - \\frac{\\Gamma \\pi K}{2r}\n$$\n这是一个一阶可分离常微分方程。我们可以通过分离变量并在指定区间上积分来求解时间 $T$。\n$$\nr \\, dr = - \\frac{\\Gamma \\pi K}{2} \\, dt\n$$\n为了找到间距从 $r_0$ 减小到 $0$ 所需的总时间 $T$，我们将左侧对 $r$ 从 $r_0$ 到 $0$ 积分，右侧对 $t$ 从 $0$ 到 $T$ 积分：\n$$\n\\int_{r_0}^{0} r' \\, dr' = \\int_{0}^{T} \\left( - \\frac{\\Gamma \\pi K}{2} \\right) \\, dt'\n$$\n计算左侧的积分得到：\n$$\n\\int_{r_0}^{0} r' \\, dr' = \\left[ \\frac{(r')^2}{2} \\right]_{r_0}^{0} = \\frac{0^2}{2} - \\frac{r_0^2}{2} = -\\frac{r_0^2}{2}\n$$\n计算右侧的积分得到：\n$$\n\\int_{0}^{T} \\left( - \\frac{\\Gamma \\pi K}{2} \\right) \\, dt' = - \\frac{\\Gamma \\pi K}{2} \\left[ t' \\right]_{0}^{T} = - \\frac{\\Gamma \\pi K}{2} T\n$$\n令两边结果相等，我们有：\n$$\n-\\frac{r_0^2}{2} = - \\frac{\\Gamma \\pi K}{2} T\n$$\n两边的因子 $-1/2$ 消去，得到：\n$$\nr_0^2 = \\Gamma \\pi K T\n$$\n解出湮灭时间 $T$，我们得到：\n$$\nT = \\frac{r_0^2}{\\Gamma \\pi K}\n$$\n问题进一步指定，有效 Frank 常数 $K$ 与弹性常数 $L_1$ 和标量序参量 $S_0$ 的关系为 $K = 2 L_1 S_0^2$。在给定的无量纲化 $S_0=1$ 下，这简化为 $K = 2 L_1$。我们将其代入 $T$ 的表达式中：\n$$\nT = \\frac{r_0^2}{\\Gamma \\pi (2 L_1)} = \\frac{r_0^2}{2 \\pi \\Gamma L_1}\n$$\n这是湮灭时间 $T$ 作为初始间距 $r_0$、旋转迁移率 $\\Gamma$ 和弹性常数 $L_1$ 的函数的最终解析表达式。\n\n对于数值计算，我们使用给定的初始间距 $r_0 = 8.0$ 和测试套件中的参数对 $(\\Gamma, L_1)$。要实现的公式是：\n$$\nT(\\Gamma, L_1; 8.0) = \\frac{8.0^2}{2 \\pi \\Gamma L_1} = \\frac{64.0}{2 \\pi \\Gamma L_1} = \\frac{32.0}{\\pi \\Gamma L_1}\n$$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the annihilation time for a pair of +/- 1/2 topological defects\n    in a 2D nematic liquid crystal based on a simplified Beris-Edwards model.\n    \"\"\"\n    \n    # Define the initial separation distance r_0.\n    r0 = 8.0\n    \n    # Define the test cases from the problem statement as tuples of (Gamma, L1).\n    test_cases = [\n        (0.5, 1.0),  # Case 1\n        (0.1, 1.0),  # Case 2\n        (0.5, 0.2),  # Case 3\n        (1.0, 2.0),  # Case 4\n    ]\n\n    results = []\n    \n    # Calculate the annihilation time for each case.\n    # The derived formula is T = r0**2 / (2 * pi * Gamma * L1).\n    r0_squared = r0**2\n    \n    for case in test_cases:\n        gamma, l1 = case\n        \n        # Calculate the denominator of the formula.\n        denominator = 2 * np.pi * gamma * l1\n        \n        # Calculate the annihilation time T.\n        annihilation_time = r0_squared / denominator\n        \n        results.append(annihilation_time)\n\n    # Format the results to exactly 6 decimal places and create the output string.\n    # The map(str, ...) approach is avoided to ensure precise formatting.\n    formatted_results = [f\"{t:.6f}\" for t in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在复杂的模拟或实验数据中，准确识别拓扑缺陷的位置和电荷是一项关键任务。本练习提供了一个构建缺陷检测算法的完整指南 ，将理论知识转化为强大的计算工具。我们将学习如何从 $Q$ 张量场中恢复导向矢场，并利用“卷绕数”这一拓扑概念来精确定位缺陷，这对于分析液晶系统的结构和动力学至关重要。",
            "id": "4079596",
            "problem": "您的任务是根据 Beris-Edwards 向列相流体动力学模型，开发并验证一个数值判据，用于检测二维向列相场中的拓扑缺陷。在向列液晶中，状态由一个对称、无迹的二阶张量——Landau–de Gennes 排列张量 $Q$ 描述。对于二维平面向列相，张量 $Q$ 可以用标量序参量 $S$ 和指向矢场 $\\mathbf{n} = (\\cos\\theta, \\sin\\theta)$ 表示为\n$$\nQ = S\\left(\\mathbf{n}\\otimes\\mathbf{n} - \\frac{1}{2}I\\right),\n$$\n其中 $I$ 是单位张量，$\\theta$ 是指向矢角。在 Beris–Edwards 模型中，$Q$ 的主特征向量给出了局部指向矢，其定义以符号为模，这意味着指向矢角仅在模 $\\pi$ 的意义下有定义。\n\n由闭合回路 $\\Gamma$ 包围的缺陷的拓扑荷 $s$ 由指向矢角沿该回路的环绕数给出：\n$$\ns = \\frac{1}{\\pi}\\oint_{\\Gamma} d\\theta,\n$$\n角度以弧度为单位。由于指向矢是无头的，指向矢角差的计算必须以 $\\pi$ 为模，以便在每一步都取最小的变化。在数值上，可以通过对每个网格单元周长上的角度差求和并除以 $\\pi$ 来计算离散网格上的 $s$。\n\n从这些定义出发，实现一个程序，该程序能够：\n1. 在方形网格上为指定的缺陷集构建合成的二维排列张量场 $Q(\\mathbf{x})$。合成的指向矢角场定义为\n$$\n\\theta(x,y) = \\sum_{i=1}^{N_d} s_i \\, \\mathrm{atan2}(y-y_i, x-x_i),\n$$\n其中 $s_i\\in\\{\\pm \\tfrac{1}{2}\\}$ 是缺陷电荷，$(x_i,y_i)$ 是缺陷位置，$\\mathrm{atan2}$ 是双参数反正切函数，返回以弧度为单位的角度。使用一个恒定的标量序参量 $S_0$，通过上述定义从 $\\theta$ 构建 $Q$。\n2. 使用主特征向量从 $Q$ 中恢复每个网格点的指向矢角。为了数值稳定性和效率，您必须使用不变关系式计算指向矢角\n$$\n\\theta = \\frac{1}{2}\\,\\mathrm{atan2}\\left(2\\,Q_{xy},\\,Q_{xx}-Q_{yy}\\right),\n$$\n该式得出以 $\\pi$ 为模的角度。\n3. 通过对单元周长上的角度差求和来计算每个网格单元的环绕数 $s$，其中每个角度差都以 $\\pi$ 为模约化到主值范围 $(-\\tfrac{\\pi}{2},\\tfrac{\\pi}{2}]$。如果 $\\lvert s\\rvert$ 超过检测阈值，则将该单元分类为包含缺陷。\n4. 将符号相同的相邻缺陷单元聚类，形成候选缺陷，并将其每个候选缺陷的电荷估计为其单元环绕数的平均值，其位置为其单元的质心。\n5. 通过将检测到的缺陷与已知的合成缺陷进行比较来验证检测结果，使用以单位正方形为单位测量的位置容差和相对于 $\\pm\\tfrac{1}{2}$ 的电荷容差。\n\n所有角度必须以弧度处理。您的实现必须是确定性的和自包含的。\n\n测试套件规范：\n使用以下五个测试用例；在所有情况下，定义域都是单位正方形 $[0,1]\\times[0,1]$，计算必须以弧度为单位。\n\n- 测试用例 1（单个正缺陷，内部）：\n    - 网格大小 $N = 128$。\n    - 标量序参量 $S_0 = 0.6$。\n    - 缺陷：一个位于 $(x_1,y_1)=(0.50,0.50)$，电荷 $s_1=+\\tfrac{1}{2}$。\n    - 位置容差：$0.05$。\n    - 电荷容差：$0.2$。\n    - 单元环绕数检测阈值：$0.3$。\n\n- 测试用例 2（单个负缺陷，内部）：\n    - 网格大小 $N = 128$。\n    - 标量序参量 $S_0 = 0.6$。\n    - 缺陷：一个位于 $(x_1,y_1)=(0.50,0.50)$，电荷 $s_1=-\\tfrac{1}{2}$。\n    - 位置容差：$0.05$。\n    - 电荷容差：$0.2$。\n    - 检测阈值：$0.3$。\n\n- 测试用例 3（一对相反缺陷，偏离中心）：\n    - 网格大小 $N = 128$。\n    - 标量序参量 $S_0 = 0.6$。\n    - 缺陷：$(x_1,y_1)=(0.30,0.70)$ 处电荷为 $s_1=+\\tfrac{1}{2}$，以及 $(x_2,y_2)=(0.70,0.30)$ 处电荷为 $s_2=-\\tfrac{1}{2}$。\n    - 位置容差：$0.05$。\n    - 电荷容差：$0.2$。\n    - 检测阈值：$0.3$。\n\n- 测试用例 4（无缺陷的均匀场）：\n    - 网格大小 $N = 128$。\n    - 标量序参量 $S_0 = 0.6$。\n    - 缺陷：无；对所有点取 $\\theta(x,y)=0$。\n    - 检测阈值：$0.3$。\n    - 预期结果：未检测到缺陷。\n\n- 测试用例 5（靠近边界的正缺陷）：\n    - 网格大小 $N = 128$。\n    - 标量序参量 $S_0 = 0.6$。\n    - 缺陷：一个位于 $(x_1,y_1)=(0.05,0.95)$，电荷 $s_1=+\\tfrac{1}{2}$。\n    - 位置容差：$0.05$。\n    - 电荷容差：$0.2$。\n    - 检测阈值：$0.3$。\n\n程序输出规范：\n您的程序应生成一行输出，其中包含五个测试用例的结果，形式为方括号内以逗号分隔的列表，每个结果都是一个布尔值，表示该测试用例的检测结果是否与预期的数量、在位置容差内的位置以及在电荷容差内的电荷相匹配。例如，输出格式必须与以下完全一样：\n[$\\text{result}_1$,$\\text{result}_2$,$\\text{result}_3$,$\\text{result}_4$,$\\text{result}_5$]",
            "solution": "该问题陈述被评估为有效。它在科学上基于已建立的 Landau–de Gennes 和 Beris–Edwards 向列液晶理论原理。该问题是适定的，提供了一套完整且一致的定义、物理参数和数值程序。目标和验证标准以清晰、无歧义的定量语言陈述。任务是实现一个多步数值算法，用于识别模拟的二维向列相场中的拓扑缺陷，并根据已知的基准真相验证检测结果。\n\n解决方案遵循针对每个测试用例的五步程序实现：(1) 在离散网格上生成合成的排列张量场 $Q(\\mathbf{x})$，(2) 从 $Q(\\mathbf{x})$ 中恢复指向矢角场 $\\theta(\\mathbf{x})$，(3) 计算每个网格单元的拓扑荷密度（环绕数）以识别缺陷核心，(4) 将相邻的缺陷单元聚类以定义和表征候选缺陷，以及 (5) 根据合成的基准真相验证检测到的缺陷。\n\n**1. 合成场生成**\n\n向列相场在单位正方形域 $[0,1]\\times[0,1]$ 上的一个均匀 $N \\times N$ 网格上被离散化。网格间距为 $h=1/(N-1)$。网格点 $(i,j)$（其中 $i,j \\in \\{0, 1, \\dots, N-1\\}$）的坐标由 $(x_i, y_j) = (i \\cdot h, j \\cdot h)$ 给出。\n\n首先构建一个合成的指向矢角场 $\\theta(x,y)$。对于一个包含 $N_d$ 个点缺陷的集合，每个缺陷的电荷为 $s_k \\in \\{\\pm \\frac{1}{2}\\}$，位置为 $(x_k, y_k)$，任意点 $(x,y)$ 处的指向矢角由每个缺陷场的叠加给出：\n$$\n\\theta(x,y) = \\sum_{k=1}^{N_d} s_k \\, \\mathrm{atan2}(y-y_k, x-x_k)\n$$\n函数 $\\mathrm{atan2}(v,u)$ 返回正 $u$ 轴与点 $(u,v)$ 之间的角度（以弧度为单位）。此表达式生成了拓扑缺陷特有的相位环绕。在没有缺陷的情况下，此和为空，所有点的 $\\theta(x,y)=0$，表示一个均匀的指向矢场。\n\n根据这个角场 $\\theta(x,y)$ 和给定的恒定标量序参量 $S_0$，在每个网格点计算排列张量 $Q$ 的分量。二维平面向列相的 $Q$ 张量定义为：\n$$\nQ = S_0 \\left( \\mathbf{n}\\otimes\\mathbf{n} - \\frac{1}{2}I \\right)\n$$\n其中 $\\mathbf{n} = (\\cos\\theta, \\sin\\theta)$ 是指向矢量，$I$ 是 $2 \\times 2$ 单位矩阵。各个分量为：\n$$\n\\begin{aligned}\nQ_{xx} = S_0 \\left( \\cos^2\\theta - \\frac{1}{2} \\right) \\\\\nQ_{yy} = S_0 \\left( \\sin^2\\theta - \\frac{1}{2} \\right) = -Q_{xx} \\\\\nQ_{xy} = S_0 \\cos\\theta \\sin\\theta\n\\end{aligned}\n$$\n这三个分量存储在 $N \\times N$ 数组中，构成了检测算法的合成输入数据。\n\n**2. 指向矢场恢复**\n\n下一步是从合成的 $Q$ 张量中恢复指向矢角场，这模拟了 $Q$ 是模拟或实验结果的情况。指向矢对应于 $Q$ 的主特征向量。该特征向量的角度 $\\theta$ 以 $\\pi$ 为模确定，反映了向列相指向矢的头尾对称性 $(\\mathbf{n} \\equiv -\\mathbf{n})$。一种高效且数值稳定的恢复该角度的方法是通过所提供的不变关系式：\n$$\n\\theta_{\\text{rec}} = \\frac{1}{2} \\mathrm{atan2}(2Q_{xy}, Q_{xx}-Q_{yy})\n$$\n这个公式正确地得出了在 $(-\\pi/2, \\pi/2]$ 范围内的指向矢角，这是指向矢方向以 $\\pi$ 为模的有效表示。这个恢复的场 $\\theta_{\\text{rec}}$ 用于所有后续计算。\n\n**3. 通过环绕数识别缺陷核心**\n\n拓扑缺陷是指向矢场中的一个奇异点。它在某个区域内的存在通过该区域边界周围指向矢角的非零净环绕来揭示。缺陷的拓扑荷 $s$ 由积分 $s = \\frac{1}{\\pi} \\oint d\\theta$ 给出。\n\n我们对网格的每个基本单元计算这个积分的离散版本。一个单元 $(i,j)$ 是由四个网格顶点 $(i,j)$、$(i+1,j)$、$(i+1,j+1)$ 和 $(i,j+1)$ 定义的正方形。我们沿着单元周长逆时针路径对恢复的角度 $\\theta_{\\text{rec}}$ 的差值求和：\n$$\n\\Delta\\theta_{\\text{total}} = (\\theta_{i+1,j} - \\theta_{i,j}) + (\\theta_{i+1,j+1} - \\theta_{i+1,j}) + (\\theta_{i,j+1} - \\theta_{i+1,j+1}) + (\\theta_{i,j} - \\theta_{i,j+1})\n$$\n其中 $\\theta_{i,j}$ 是网格点 $(i,j)$ 处的角度。关键的是，由于 $\\theta$ 是以 $\\pi$ 为模定义的，每个角度差 $\\Delta\\theta$ 必须被包裹到主区间 $(-\\pi/2, \\pi/2]$ 以表示最小的旋转。这通过操作 $\\Delta\\theta' = \\Delta\\theta - \\pi \\cdot \\text{round}(\\Delta\\theta/\\pi)$ 实现。单元 $(i,j)$ 的环绕数则为：\n$$\ns_{ij} = \\frac{1}{\\pi} \\sum_{\\text{edges}} \\Delta\\theta'\n$$\n对所有 $(N-1) \\times (N-1)$ 个单元执行此计算。如果一个单元的环绕数绝对值 $|s_{ij}|$ 超过指定的检测阈值，则该单元被分类为“缺陷单元”。\n\n**4. 缺陷聚类与表征**\n\n单个拓扑缺陷可能跨越多个相邻的网格单元，所有这些单元都将显示出显著的环绕数。这些缺陷单元必须被分组到簇中以识别单个候选缺陷。为此，采用了广度优先搜索（BFS）算法。该算法遍历单元网格。当发现一个未访问的缺陷单元时，启动BFS以找到所有具有相同环绕数符号（即正或负）的连通缺陷单元。连通性定义为共享一条边（4-连通）。\n\n一旦识别出一个单元簇，它就被表征为单个候选缺陷：\n- **电荷**：候选缺陷的电荷计算为簇内所有单元环绕数 $s_{ij}$ 的算术平均值。\n- **位置**：候选缺陷的位置是簇中单元中心的质心。如果一个单元的左下角在 $(x_i, y_j)$，其中心在 $(x_i + h/2, y_j + h/2)$。\n\n**5. 验证**\n\n最后一步是将检测到的候选缺陷列表与原始的合成缺陷列表进行比较。验证过程如下：\n1.  将真实缺陷列表和检测到的缺陷列表都根据电荷分为两个子列表：正电荷 ($s0$) 和负电荷 ($s0$)。\n2.  对于没有真实缺陷的情况，当且仅当没有检测到缺陷时，验证成功。\n3.  对于有缺陷的情况，检测到的正缺陷数量必须与真实正缺陷数量匹配，负缺陷同样如此。如果数量不匹配，验证失败。\n4.  如果数量匹配，必须在相同符号的真实缺陷和检测到的缺陷之间建立一一对应关系。这是一个分配问题，使用 `scipy.optimize.linear_sum_assignment` 函数进行最优求解。分配的成本矩阵是真实缺陷和检测到的缺陷位置之间的欧几里得距离。\n5.  对于每一个真实缺陷与其匹配的检测到的缺陷对，必须满足两个条件：\n    a. 它们位置之间的欧几里得距离必须小于或等于指定的位置容差。\n    b. 它们电荷的绝对差 $|s_{\\text{det}} - s_{\\text{true}}|$ 必须小于或等于指定的电荷容差。\n6.  只有当所有缺陷数量匹配，并且每个匹配对都满足位置和电荷容差标准时，该测试用例才被视为通过（True）。否则，视为失败（False）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linear_sum_assignment\nfrom scipy.spatial.distance import cdist\nfrom collections import deque\n\ndef run_test_case(N, S0, defects, pos_tol, charge_tol, threshold):\n    \"\"\"\n    Runs a single test case for defect detection.\n\n    Args:\n        N (int): Grid size (N x N).\n        S0 (float): Scalar order parameter.\n        defects (list): List of dictionaries, each specifying a defect's charge and position.\n        pos_tol (float): Positional tolerance for validation.\n        charge_tol (float): Charge tolerance for validation.\n        threshold (float): Detection threshold for cell winding.\n\n    Returns:\n        bool: True if detection is successful, False otherwise.\n    \"\"\"\n\n    # Step 1: Synthetic Field Generation\n    h = 1.0 / (N - 1)\n    x_coords = np.linspace(0, 1, N)\n    y_coords = np.linspace(0, 1, N)\n    x_grid, y_grid = np.meshgrid(x_coords, y_coords)\n\n    theta_field = np.zeros((N, N), dtype=float)\n    if not defects: # Special handling for case 4\n        # theta_field is already zero, but this is explicit\n        pass\n    else:\n        for defect in defects:\n            s_i, (x_i, y_i) = defect['charge'], defect['pos']\n            theta_field += s_i * np.arctan2(y_grid - y_i, x_grid - x_i)\n\n    cos_theta = np.cos(theta_field)\n    sin_theta = np.sin(theta_field)\n\n    Q_xx = S0 * (cos_theta**2 - 0.5)\n    Q_xy = S0 * cos_theta * sin_theta\n    Q_yy = -Q_xx  # S0 * (sin_theta**2 - 0.5)\n\n    # Step 2: Director Field Recovery\n    theta_rec = 0.5 * np.arctan2(2 * Q_xy, Q_xx - Q_yy)\n\n    # Step 3: Defect Core Identification\n    def wrap_angle_diff(d_theta):\n        return d_theta - np.pi * np.round(d_theta / np.pi)\n\n    theta_bl = theta_rec[:-1, :-1]\n    theta_br = theta_rec[:-1, 1:]\n    theta_tr = theta_rec[1:, 1:]\n    theta_tl = theta_rec[1:, :-1]\n\n    d1 = wrap_angle_diff(theta_br - theta_bl)\n    d2 = wrap_angle_diff(theta_tr - theta_br)\n    d3 = wrap_angle_diff(theta_tl - theta_tr)\n    d4 = wrap_angle_diff(theta_bl - theta_tl)\n\n    windings = (1.0 / np.pi) * (d1 + d2 + d3 + d4)\n    is_defect_cell = np.abs(windings) > threshold\n\n    # Step 4: Defect Clustering\n    detected_defects = []\n    visited = np.zeros_like(is_defect_cell, dtype=bool)\n    rows, cols = is_defect_cell.shape\n\n    for r in range(rows):\n        for c in range(cols):\n            if is_defect_cell[r, c] and not visited[r, c]:\n                sign = np.sign(windings[r, c])\n                q = deque([(r, c)])\n                visited[r, c] = True\n                cluster_cells_indices = []\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    cluster_cells_indices.append((curr_r, curr_c))\n\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        if (0 = nr  rows and 0 = nc  cols and\n                            not visited[nr, nc] and is_defect_cell[nr, nc] and\n                            np.sign(windings[nr, nc]) == sign):\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                cell_indices_r, cell_indices_c = zip(*cluster_cells_indices)\n                cell_indices_r = np.array(cell_indices_r)\n                cell_indices_c = np.array(cell_indices_c)\n\n                avg_charge = np.mean(windings[cell_indices_r, cell_indices_c])\n                centroid_x = np.mean(cell_indices_c + 0.5) * h\n                centroid_y = np.mean(cell_indices_r + 0.5) * h\n\n                detected_defects.append({\n                    'pos': (centroid_x, centroid_y),\n                    'charge': avg_charge\n                })\n\n    # Step 5: Validation\n    true_defects = defects\n\n    if not true_defects:\n        return not detected_defects\n\n    true_pos = [d for d in true_defects if d['charge'] > 0]\n    true_neg = [d for d in true_defects if d['charge']  0]\n    detected_pos = [d for d in detected_defects if d['charge'] > 0]\n    detected_neg = [d for d in detected_defects if d['charge']  0]\n\n    def match_defects(true_list, detected_list, p_tol, c_tol):\n        if len(true_list) != len(detected_list):\n            return False\n        if not true_list:\n            return True\n\n        true_coords = [d['pos'] for d in true_list]\n        det_coords = [d['pos'] for d in detected_list]\n\n        cost_matrix = cdist(true_coords, det_coords)\n        true_indices, det_indices = linear_sum_assignment(cost_matrix)\n\n        for t_idx, d_idx in zip(true_indices, det_indices):\n            pos_diff = cost_matrix[t_idx, d_idx]\n            if pos_diff > p_tol:\n                return False\n            \n            charge_diff = abs(detected_list[d_idx]['charge'] - true_list[t_idx]['charge'])\n            if charge_diff > c_tol:\n                return False\n        \n        return True\n\n    pos_match = match_defects(true_pos, detected_pos, pos_tol, charge_tol)\n    neg_match = match_defects(true_neg, detected_neg, pos_tol, charge_tol)\n    \n    return pos_match and neg_match\n\ndef solve():\n    test_cases = [\n        # Test Case 1\n        {\n            'N': 128, 'S0': 0.6,\n            'defects': [{'pos': (0.50, 0.50), 'charge': 0.5}],\n            'pos_tol': 0.05, 'charge_tol': 0.2, 'threshold': 0.3\n        },\n        # Test Case 2\n        {\n            'N': 128, 'S0': 0.6,\n            'defects': [{'pos': (0.50, 0.50), 'charge': -0.5}],\n            'pos_tol': 0.05, 'charge_tol': 0.2, 'threshold': 0.3\n        },\n        # Test Case 3\n        {\n            'N': 128, 'S0': 0.6,\n            'defects': [\n                {'pos': (0.30, 0.70), 'charge': 0.5},\n                {'pos': (0.70, 0.30), 'charge': -0.5}\n            ],\n            'pos_tol': 0.05, 'charge_tol': 0.2, 'threshold': 0.3\n        },\n        # Test Case 4\n        {\n            'N': 128, 'S0': 0.6,\n            'defects': [],\n            'pos_tol': 0.05, 'charge_tol': 0.2, 'threshold': 0.3\n        },\n        # Test Case 5\n        {\n            'N': 128, 'S0': 0.6,\n            'defects': [{'pos': (0.05, 0.95), 'charge': 0.5}],\n            'pos_tol': 0.05, 'charge_tol': 0.2, 'threshold': 0.3\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_test_case(\n            case['N'], case['S0'], case['defects'],\n            case['pos_tol'], case['charge_tol'], case['threshold']\n        )\n        results.append(str(result).lower())\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}