{
    "hands_on_practices": [
        {
            "introduction": "Before diving into complex simulations, it is crucial to understand the physical regimes governing the system. Dimensionless numbers like the Ericksen number ($Er$) and Deborah number ($De$) provide a powerful way to compare the strengths of competing physical effects, such as viscous versus elastic forces. This practice guides you through a scaling analysis to derive these numbers, connecting the abstract theory of the Beris-Edwards model to tangible material properties and flow conditions. ",
            "id": "4079599",
            "problem": "A thermotropic nematic liquid crystal (for example, 4'-pentyl-4-cyanobiphenyl) in a pressure-driven microfluidic channel can be modeled using the Beris-Edwards (BE) model for nemato-hydrodynamics, where the fluid velocity field $\\,\\mathbf{u}\\,$ obeys the momentum balance of the Navier–Stokes equations augmented by orientational stresses and the orientational order is described by the alignment tensor $\\,\\mathbf{Q}\\,$ with dynamics $\\partial_{t}\\mathbf{Q}-\\mathbf{S}(\\nabla\\mathbf{u},\\mathbf{Q})=\\Gamma\\,\\mathbf{H}$, in which $\\,\\mathbf{H}=-\\delta F/\\delta \\mathbf{Q}\\,$ is the molecular field derived from the Landau–de Gennes free energy. For scaling analysis, the competition between viscous and elastic effects is characterized by the Ericksen number and the timescale competition is characterized by the Deborah number. Starting from the fundamental notions that the viscous stress scale is $\\,\\eta\\,\\dot{\\gamma}\\,$ for a shear rate $\\,\\dot{\\gamma}\\,$ and that the elastic molecular field scale associated with director distortions over a length $\\,L\\,$ is $\\,K/L^{2}\\,$ (single Frank-constant approximation), derive expressions for the Ericksen number $\\,\\mathrm{Er}\\,$ and the Deborah number $\\,\\mathrm{De}\\,$ in terms of material and geometric parameters. Then adopt the following realistic parameter values representative of a room-temperature thermotropic nematic:\n- isotropic-equivalent shear viscosity magnitude $\\,\\eta = 0.10\\,\\mathrm{Pa\\,s}\\,$,\n- rotational viscosity $\\,\\gamma_{1} = 0.050\\,\\mathrm{Pa\\,s}\\,$,\n- single Frank elastic constant $\\,K = 7.0\\times 10^{-12}\\,\\mathrm{N}\\,$,\nand microfluidic conditions:\n- channel height $\\,H = 50\\,\\mu\\mathrm{m}\\,$ serving as the characteristic length $\\,L\\,$,\n- mean flow speed $\\,U = 1.0\\,\\mathrm{mm/s}\\,$ giving an estimated shear rate $\\,\\dot{\\gamma}\\approx U/H\\,$.\n\nUsing these values, compute $\\,\\mathrm{Er}\\,$ and $\\,\\mathrm{De}\\,$. Express your final dimensionless results with no units and round to three significant figures.",
            "solution": "The problem is validated as scientifically grounded, well-posed, and objective. It provides a complete and consistent set of definitions, physical principles, and data to derive and compute the Ericksen and Deborah numbers for a nematic liquid crystal under specific flow conditions.\n\nThe derivation and calculation proceed as follows.\n\n**1. Derivation of the Ericksen Number ($\\mathrm{Er}$)**\n\nThe Ericksen number, $\\mathrm{Er}$, quantifies the competition between viscous and elastic effects in a flowing liquid crystal. It is defined as the ratio of the characteristic viscous stress, $\\sigma_{\\text{visc}}$, to the characteristic elastic stress, $\\sigma_{\\text{el}}$.\n$$\n\\mathrm{Er} = \\frac{\\sigma_{\\text{visc}}}{\\sigma_{\\text{el}}}\n$$\nThe problem provides the scaling for the viscous stress associated with a shear flow at a rate $\\dot{\\gamma}$ and with a shear viscosity $\\eta$:\n$$\n\\sigma_{\\text{visc}} \\sim \\eta \\dot{\\gamma}\n$$\nThe elastic stress arises from spatial distortions of the liquid crystal's orientational order over a characteristic length scale $L$. This stress is related to the molecular field, $\\mathbf{H}$, which in turn is derived from the Frank elastic free energy. The problem provides the scaling for the molecular field in the single-constant approximation ($K$):\n$$\nH \\sim \\frac{K}{L^2}\n$$\nThe elastic stress tensor components are proportional to the molecular field, so the magnitude of the elastic stress scales similarly:\n$$\n\\sigma_{\\text{el}} \\sim \\frac{K}{L^2}\n$$\nSubstituting the stress scales into the definition of the Ericksen number yields the expression:\n$$\n\\mathrm{Er} = \\frac{\\eta \\dot{\\gamma}}{K / L^2} = \\frac{\\eta \\dot{\\gamma} L^2}{K}\n$$\n\n**2. Derivation of the Deborah Number ($\\mathrm{De}$)**\n\nThe Deborah number, $\\mathrm{De}$, characterizes the competition between timescales. It is defined as the ratio of the material's intrinsic relaxation time, $\\tau_{\\text{relax}}$, to the characteristic timescale of the flow process, $\\tau_{\\text{flow}}$.\n$$\n\\mathrm{De} = \\frac{\\tau_{\\text{relax}}}{\\tau_{\\text{flow}}}\n$$\nThe characteristic timescale of the flow is the inverse of the characteristic rate of strain, which is the shear rate $\\dot{\\gamma}$:\n$$\n\\tau_{\\text{flow}} \\sim \\frac{1}{\\dot{\\gamma}}\n$$\nThe material's relaxation time, $\\tau_{\\text{relax}}$, is the time required for orientational order to return to equilibrium after a perturbation. This process involves a balance between the restoring elastic torque density and the dissipative viscous torque density. The elastic torque density is driven by the molecular field, scaling as $\\sim H \\sim K/L^2$. The dissipative torque density is due to director rotation against the rotational viscosity, $\\gamma_1$, and scales as $\\sim \\gamma_1 \\dot{\\theta}$, where $\\dot{\\theta}$ is the rate of angular rotation. For relaxation, the characteristic rate is $\\dot{\\theta} \\sim 1/\\tau_{\\text{relax}}$. Thus, the dissipative torque density is $\\sim \\gamma_1 / \\tau_{\\text{relax}}$.\nBy balancing the elastic and viscous torques, we find:\n$$\n\\frac{\\gamma_1}{\\tau_{\\text{relax}}} \\sim \\frac{K}{L^2}\n$$\nSolving for the relaxation time gives:\n$$\n\\tau_{\\text{relax}} \\sim \\frac{\\gamma_1 L^2}{K}\n$$\nSubstituting the timescales into the definition of the Deborah number yields the expression:\n$$\n\\mathrm{De} = \\frac{\\gamma_1 L^2 / K}{1 / \\dot{\\gamma}} = \\frac{\\gamma_1 \\dot{\\gamma} L^2}{K}\n$$\n\n**3. Numerical Calculation**\n\nFirst, we must express all given parameters in coherent SI units.\n- Isotropic-equivalent shear viscosity: $\\eta = 0.10\\,\\mathrm{Pa\\,s} = 0.10\\,\\mathrm{N\\,s\\,m^{-2}}$\n- Rotational viscosity: $\\gamma_1 = 0.050\\,\\mathrm{Pa\\,s} = 0.050\\,\\mathrm{N\\,s\\,m^{-2}}$\n- Single Frank elastic constant: $K = 7.0 \\times 10^{-12}\\,\\mathrm{N}$\n- Characteristic length: $L = H = 50\\,\\mu\\mathrm{m} = 5.0 \\times 10^{-5}\\,\\mathrm{m}$\n- Mean flow speed: $U = 1.0\\,\\mathrm{mm/s} = 1.0 \\times 10^{-3}\\,\\mathrm{m\\,s^{-1}}$\n\nNext, we calculate the estimated shear rate, $\\dot{\\gamma}$:\n$$\n\\dot{\\gamma} \\approx \\frac{U}{H} = \\frac{1.0 \\times 10^{-3}\\,\\mathrm{m\\,s^{-1}}}{5.0 \\times 10^{-5}\\,\\mathrm{m}} = 20\\,\\mathrm{s^{-1}}\n$$\nNow we compute the Ericksen number, $\\mathrm{Er}$:\n$$\n\\mathrm{Er} = \\frac{\\eta \\dot{\\gamma} L^2}{K} = \\frac{(0.10\\,\\mathrm{N\\,s\\,m^{-2}})(20\\,\\mathrm{s^{-1}})(5.0 \\times 10^{-5}\\,\\mathrm{m})^2}{7.0 \\times 10^{-12}\\,\\mathrm{N}}\n$$\n$$\n\\mathrm{Er} = \\frac{(2.0)(25 \\times 10^{-10})}{7.0 \\times 10^{-12}} = \\frac{50 \\times 10^{-10}}{7.0 \\times 10^{-12}} = \\frac{50}{7.0} \\times 10^2 \\approx 7.1428 \\times 10^2\n$$\nRounding to three significant figures, we get $\\mathrm{Er} = 714$.\n\nFinally, we compute the Deborah number, $\\mathrm{De}$:\n$$\n\\mathrm{De} = \\frac{\\gamma_1 \\dot{\\gamma} L^2}{K} = \\frac{(0.050\\,\\mathrm{N\\,s\\,m^{-2}})(20\\,\\mathrm{s^{-1}})(5.0 \\times 10^{-5}\\,\\mathrm{m})^2}{7.0 \\times 10^{-12}\\,\\mathrm{N}}\n$$\n$$\n\\mathrm{De} = \\frac{(1.0)(25 \\times 10^{-10})}{7.0 \\times 10^{-12}} = \\frac{25 \\times 10^{-10}}{7.0 \\times 10^{-12}} = \\frac{25}{7.0} \\times 10^2 \\approx 3.5714 \\times 10^2\n$$\nRounding to three significant figures, we get $\\mathrm{De} = 357$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n714  357\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "When translating the continuous equations of the Beris-Edwards model to a discrete computer simulation, we must ensure that fundamental physical constraints are not violated by numerical errors. The order parameter tensor $Q$ must remain symmetric and traceless. This exercise demonstrates a critical numerical technique, the projection method, to enforce the traceless constraint and thereby maintain the physical integrity of the simulation against numerical drift. ",
            "id": "4079546",
            "problem": "Consider the Landau–de Gennes tensorial description of nematic liquid crystals in the Beris–Edwards model. The order parameter is the second-rank tensor field $Q(\\mathbf{x},t)$ that is symmetric and traceless. The fundamental physical requirement is that $\\operatorname{tr} Q = 0$ everywhere and for all times, including at boundaries. Analytically, the Partial Differential Equation (PDE) for the Beris–Edwards dynamics preserves $\\operatorname{tr} Q = 0$ if initialized and constrained consistently, but in numerical computation, floating-point roundoff and inconsistent boundary updates cause a drift from the symmetric-traceless manifold.\n\nStarting from the following foundational base:\n\n- The nematic order parameter tensor $Q$ is symmetric and traceless, which means $Q = Q^{\\top}$ and $\\operatorname{tr} Q = 0$.\n- A generic relaxation-type evolution for $Q$ consistent with Landau–de Gennes phenomenology includes a diffusive term and a linear decay term. In a simplified setting, this can be represented component-wise as a linear parabolic PDE,\n$$\n\\frac{\\partial Q}{\\partial t} = \\Gamma \\left( L \\nabla^2 Q - a Q \\right),\n$$\nwhere $\\Gamma$, $L$, and $a$ are positive material parameters, and $\\nabla^2$ is the Laplacian operator.\n- In the absence of defects or topology changes, enforcing $\\operatorname{tr} Q = 0$ is a hard algebraic constraint derived from the definition of $Q$ as a deviatoric tensor.\n\nYour task is to derive, implement, and test a numerically stable enforcement of the $\\operatorname{tr} Q = 0$ constraint both in the interior discretization and at boundaries, so as to prevent drift due to numerical errors. You must proceed as follows:\n\n1. Derive, from first principles, an explicit algebraic projection that maps any $2 \\times 2$ real matrix onto the symmetric traceless subspace. Explain why this projection preserves the physical meaning of the nematic order parameter and how it relates to the decomposition of a tensor into symmetric, antisymmetric, and isotropic parts.\n\n2. Design a two-dimensional finite difference scheme on a square lattice of size $N_x \\times N_y$ for the simplified relaxation dynamics\n$$\n\\frac{\\partial Q}{\\partial t} = \\Gamma \\left( L \\nabla^2 Q - a Q \\right),\n$$\nwith explicit Euler time stepping. Work with a dimensionless domain and spacing and treat $Q$ component-wise. Use Dirichlet boundary conditions that anchor the director uniformly along the $x$-axis, i.e., set the boundary target $Q^\\star$ consistent with a uniaxial state in two dimensions with director $\\mathbf{n} = (1,0)$ and scalar order magnitude $S$; the boundary target must be traceless. Implement a small isotropic perturbation to the boundary values at each time step to model numerical boundary drift (i.e., adding a multiple of the identity tensor). Implement a small isotropic perturbation to the interior update to model floating-point drift in the discretization as well. These perturbations must be controlled by parameters of magnitude much smaller than $1$.\n\n3. Implement two enforcement modes:\n   - Mode $0$: No enforcement; demonstrate how $\\operatorname{tr} Q$ drifts in the interior and at the boundary.\n   - Mode $1$: Interior enforcement only; apply the derived projection after each time step to the interior nodes but not to boundary nodes.\n   - Mode $2$: Interior and boundary enforcement; apply the derived projection to all nodes after each time step, including the boundary nodes right after applying the boundary condition.\n\n4. Define and compute, for each simulation, the following quantitative diagnostics:\n   - The final mean absolute trace over interior nodes,\n     $$\n     \\overline{|\\operatorname{tr} Q|}_{\\mathrm{int}} = \\frac{1}{N_{\\mathrm{int}}} \\sum_{\\text{interior nodes}} \\left| \\operatorname{tr} Q \\right|.\n     $$\n   - The final maximum absolute trace over boundary nodes,\n     $$\n     \\max_{\\mathrm{bnd}} \\left| \\operatorname{tr} Q \\right|.\n     $$\n   - The final root-mean-square (RMS) trace over the whole domain,\n     $$\n     \\mathrm{RMS}(\\operatorname{tr} Q) = \\sqrt{\\frac{1}{N_x N_y} \\sum_{\\text{all nodes}} \\left( \\operatorname{tr} Q \\right)^2 }.\n     $$\n\n5. Implement a complete program that runs the following test suite. Each test case is specified by $(N_x, N_y, \\Delta t, \\text{steps}, L, a, \\Gamma, \\delta_{\\mathrm{int}}, \\delta_{\\mathrm{bnd}}, \\text{mode})$, where $\\delta_{\\mathrm{int}}$ controls the isotropic interior drift magnitude per time step, and $\\delta_{\\mathrm{bnd}}$ controls the isotropic boundary drift magnitude per time step. Use the following test cases:\n   - Test $1$ (happy path, moderate interior drift, compare no enforcement): $(24, 24, 0.01, 400, 0.02, 0.10, 1.0, 10^{-9}, 10^{-10}, 0)$.\n   - Test $2$ (happy path, moderate interior drift, interior enforcement): $(24, 24, 0.01, 400, 0.02, 0.10, 1.0, 10^{-9}, 10^{-10}, 1)$.\n   - Test $3$ (boundary drift stress, no enforcement): $(24, 24, 0.01, 400, 0.02, 0.10, 1.0, 10^{-9}, 10^{-6}, 0)$.\n   - Test $4$ (boundary drift stress, full enforcement): $(24, 24, 0.01, 400, 0.02, 0.10, 1.0, 10^{-9}, 10^{-6}, 2)$.\n   - Test $5$ (edge case, tiny drift, long run, interior enforcement): $(24, 24, 0.005, 1200, 0.02, 0.10, 1.0, 10^{-12}, 10^{-12}, 1)$.\n\n6. Initialization: Set the initial condition in the interior to the uniform anchored state $Q^\\star$ plus a small random symmetric perturbation with zero mean and amplitude $10^{-12}$, and apply the boundary target $Q^\\star$ with the specified boundary drift when appropriate.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order\n$$\n\\big[\n\\overline{|\\operatorname{tr} Q|}_{\\mathrm{int}}^{(1)}, \\max_{\\mathrm{bnd}} |\\operatorname{tr} Q|^{(1)}, \\mathrm{RMS}(\\operatorname{tr} Q)^{(1)},\n\\overline{|\\operatorname{tr} Q|}_{\\mathrm{int}}^{(2)}, \\max_{\\mathrm{bnd}} |\\operatorname{tr} Q|^{(2)}, \\mathrm{RMS}(\\operatorname{tr} Q)^{(2)},\n\\ldots,\n\\overline{|\\operatorname{tr} Q|}_{\\mathrm{int}}^{(5)}, \\max_{\\mathrm{bnd}} |\\operatorname{tr} Q|^{(5)}, \\mathrm{RMS}(\\operatorname{tr} Q)^{(5)}\n\\big],\n$$\nwhere the superscript indicates the test case number. All numbers must be printed as standard floating-point values with default Python formatting. No physical units are required because the problem is dimensionless. Angles are not involved. Express all magnitudes as plain decimal numbers. The program must be self-contained and must not require any user interaction.",
            "solution": "The problem requires the development and testing of a numerical scheme to enforce the symmetric-traceless constraint on the nematic order parameter tensor $Q$ in a simplified Beris-Edwards model. The core of the task is to derive an algebraic projection, integrate it into a finite difference scheme, and use it to counteract simulated numerical drift.\n\n### 1. Derivation of the Projection Operator\n\nThe nematic order parameter $Q$ is a second-rank tensor that must be symmetric ($Q = Q^\\top$) and traceless ($\\operatorname{tr} Q = 0$). We need to derive a projection operator $\\mathcal{P}$ that maps any arbitrary $2 \\times 2$ real matrix $M$ onto the subspace of symmetric traceless matrices. This is achieved in two steps, corresponding to the decomposition of a tensor into its fundamental parts.\n\n**Step 1: Projection onto the Symmetric Subspace**\nAny arbitrary square matrix $M$ can be uniquely decomposed into a symmetric part $M_s$ and an antisymmetric part $M_a$:\n$$\nM = M_s + M_a\n$$\nwhere\n$$\nM_s = \\frac{1}{2}(M + M^\\top) \\quad \\text{and} \\quad M_a = \\frac{1}{2}(M - M^\\top)\n$$\nSince $Q$ must be symmetric, we discard the antisymmetric part, which corresponds to the projection of $M$ onto the subspace of symmetric matrices: $M \\rightarrow M_s$.\n\n**Step 2: Projection onto the Traceless Subspace**\nA symmetric matrix $S$ can be further decomposed into its isotropic part and its deviatoric (traceless) part. In $d$ dimensions, this is:\n$$\nS = S_0 + \\frac{1}{d} \\operatorname{tr}(S) I\n$$\nwhere $I$ is the identity matrix and $S_0 = S - \\frac{1}{d} \\operatorname{tr}(S) I$ is the traceless part. The isotropic part, $\\frac{1}{d} \\operatorname{tr}(S) I$, represents a uniform scaling and does not describe orientational order. The physical properties of nematic alignment are captured by the anisotropic, traceless part $S_0$. For our $2$-dimensional problem, $d=2$. The projection of a symmetric matrix $S$ onto the traceless subspace is thus:\n$$\nS \\rightarrow S - \\frac{1}{2}\\operatorname{tr}(S)I\n$$\n\n**Combined Projection Operator**\nCombining both steps, the projection $\\mathcal{P}$ that maps a generic $2 \\times 2$ matrix $M$ to the symmetric traceless subspace is the composition of the two projections. We first symmetrize $M$ to get $M_s$, and then make the result traceless:\n$$\n\\mathcal{P}(M) = M_s - \\frac{1}{2}\\operatorname{tr}(M_s)I = \\frac{1}{2}(M + M^\\top) - \\frac{1}{2}\\operatorname{tr}\\left(\\frac{1}{2}(M + M^\\top)\\right)I\n$$\nUsing the linearity of the trace operator ($\\operatorname{tr}(A+B) = \\operatorname{tr}(A)+\\operatorname{tr}(B)$) and the property $\\operatorname{tr}(A^\\top) = \\operatorname{tr}(A)$, we have $\\operatorname{tr}(M+M^\\top) = 2\\operatorname{tr}(M)$. The expression for the projection operator simplifies to:\n$$\n\\mathcal{P}(M) = \\frac{1}{2}(M + M^\\top) - \\frac{1}{2}\\operatorname{tr}(M)I\n$$\nThis operator isolates the symmetric, traceless component of any input matrix $M$, which corresponds precisely to the physical definition of the nematic order parameter $Q$. This is an orthogonal projection in the space of matrices equipped with the Frobenius inner product, $\\langle A, B \\rangle = \\operatorname{tr}(A^\\top B)$.\n\n### 2. Finite Difference Scheme Design\n\nWe discretize the PDE on a $2D$ rectangular grid of size $N_x \\times N_y$ with uniform spacing $\\Delta x = \\Delta y = 1$ (dimensionless). The tensor field $Q(x,y,t)$ is represented by a set of $2 \\times 2$ matrices at each grid point $(i,j)$, denoted $Q_{i,j}$.\n\n**Component-wise Discretization**\nThe evolution equation is:\n$$\n\\frac{\\partial Q}{\\partial t} = \\Gamma \\left( L \\nabla^2 Q - a Q \\right)\n$$\nThe Laplacian operator $\\nabla^2$ is discretized using the standard $5$-point stencil for each component of $Q$. For a generic component $q$ at grid node $(i,j)$:\n$$\n(\\nabla^2 q)_{i,j} \\approx q_{i+1,j} + q_{i-1,j} + q_{i,j+1} + q_{i,j-1} - 4q_{i,j}\n$$\nThis applies to the interior nodes $i \\in [1, N_x-2]$ and $j \\in [1, N_y-2]$.\n\n**Time Integration**\nWe use an explicit Euler scheme for time stepping with a time step $\\Delta t$:\n$$\nQ_{i,j}^{n+1} = Q_{i,j}^{n} + \\Delta t \\cdot \\Gamma \\left( L (\\nabla^2 Q^n)_{i,j} - a Q_{i,j}^n \\right)\n$$\n\n**Initial and Boundary Conditions**\nThe boundary condition is a uniform uniaxial state with director $\\mathbf{n}=(1,0)$ and scalar order parameter $S$. As the value of $S$ is not given, we choose a standard non-dimensional value $S=1$. The boundary tensor $Q^\\star$ is:\n$$\nQ^\\star = S \\left( \\mathbf{n}\\otimes\\mathbf{n} - \\frac{1}{2}I \\right) = 1 \\cdot \\left( \\begin{pmatrix} 1  0 \\\\ 0  0 \\end{pmatrix} - \\frac{1}{2} \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} \\right) = \\begin{pmatrix} 0.5  0 \\\\ 0  -0.5 \\end{pmatrix}\n$$\nThe initial condition for the interior nodes is this uniform state plus a small, random, symmetric, traceless perturbation of amplitude $10^{-12}$. This ensures the initial state satisfies $\\operatorname{tr} Q = 0$. The boundary nodes are initialized to $Q^\\star$.\n\n**Modeling Numerical Drift**\nTo simulate numerical errors that violate the traceless constraint, we introduce isotropic perturbations:\n-   **Interior Drift**: At each time step, after the Euler update, a constant matrix $\\delta_{\\mathrm{int}} I$ is added to the $Q$ tensor at every interior node. This increases the trace by $2\\delta_{\\mathrm{int}}$.\n-   **Boundary Drift**: The Dirichlet boundary condition is set to $Q^{\\text{BC}} = Q^\\star + \\delta_{\\mathrm{bnd}} I$ at each time step.\n\n### 3. Constraint Enforcement Modes\n\nThe algorithm implements three modes to handle the constraint:\n-   **Mode $0$ (No Enforcement)**: The simulation proceeds without any application of the projection operator $\\mathcal{P}$. The trace of $Q$ is expected to drift away from $0$ due to the simulated error terms.\n-   **Mode $1$ (Interior Enforcement)**: After the Euler update and the addition of interior drift, the projection $\\mathcal{P}$ is applied to all interior nodes. The boundary nodes are set to their drifted values and are not projected.\n-   **Mode $2$ (Full Enforcement)**: The projection $\\mathcal{P}$ is applied to all nodes (interior and boundary) after the update step. Then, the boundary conditions (including drift) are applied. Immediately after, the boundary nodes are projected again to enforce the constraint strictly everywhere.\n\nThe algorithmic flow for a single time step is:\n1.  Compute the Laplacian $(\\nabla^2 Q^n)$ for all interior nodes.\n2.  Compute the updated tensor field $Q^{n+1}_{\\text{temp}}$ for interior nodes using the Euler formula.\n3.  Add the interior drift term: $Q^{n+1}_{\\text{temp}} \\mathrel{+}= \\delta_{\\mathrm{int}} I$.\n4.  Apply projection according to the selected mode (`mode` $1$ on interior, `mode` $2$ on all nodes).\n5.  Set boundary values to $Q^\\star + \\delta_{\\mathrm{bnd}} I$.\n6.  If in `mode` $2$, apply the projection $\\mathcal{P}$ to all boundary nodes.\n7.  Set $Q^{n+1} = Q^{n+1}_{\\text{temp}}$.\n\n### 4. Diagnostic Metrics\n\nAt the end of each simulation, three quantitative diagnostics are computed to evaluate the effectiveness of the constraint enforcement:\n1.  **Final Mean Absolute Interior Trace**: Measures the average drift of the trace in the domain's interior.\n    $$\n    \\overline{|\\operatorname{tr} Q|}_{\\mathrm{int}} = \\frac{1}{(N_x-2)(N_y-2)} \\sum_{i=1}^{N_x-2} \\sum_{j=1}^{N_y-2} \\left| \\operatorname{tr} Q_{i,j} \\right|\n    $$\n2.  **Final Maximum Absolute Boundary Trace**: Measures the worst-case trace violation on the boundary.\n    $$\n    \\max_{\\mathrm{bnd}} \\left| \\operatorname{tr} Q \\right| = \\max_{\\text{nodes } (i,j) \\text{ on boundary}} \\left| \\operatorname{tr} Q_{i,j} \\right|\n    $$\n3.  **Final Root-Mean-Square (RMS) Trace**: A global measure of the trace violation over the entire domain.\n    $$\n    \\mathrm{RMS}(\\operatorname{tr} Q) = \\sqrt{\\frac{1}{N_x N_y} \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\left( \\operatorname{tr} Q_{i,j} \\right)^2 }\n    $$\nThese metrics provide a comprehensive picture of how well the $\\operatorname{tr} Q = 0$ constraint is maintained under different conditions and enforcement strategies.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the Beris-Edwards simulation.\n    \"\"\"\n    \n    # Set a seed for reproducibility of random initial perturbations.\n    np.random.seed(0)\n\n    # (Nx, Ny, dt, steps, L, a, Gamma, delta_int, delta_bnd, mode)\n    test_cases = [\n        (24, 24, 0.01, 400, 0.02, 0.10, 1.0, 1e-9, 1e-10, 0),\n        (24, 24, 0.01, 400, 0.02, 0.10, 1.0, 1e-9, 1e-10, 1),\n        (24, 24, 0.01, 400, 0.02, 0.10, 1.0, 1e-9, 1e-6, 0),\n        (24, 24, 0.01, 400, 0.02, 0.10, 1.0, 1e-9, 1e-6, 2),\n        (24, 24, 0.005, 1200, 0.02, 0.10, 1.0, 1e-12, 1e-12, 1),\n    ]\n\n    results = []\n    for params in test_cases:\n        diagnostics = run_simulation(*params)\n        results.extend(diagnostics)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef project_to_symmetric_traceless(M):\n    \"\"\"\n    Projects a 2x2 matrix or a batch of 2x2 matrices onto the symmetric-traceless subspace.\n    The input M is assumed to have shape (..., 2, 2).\n    \"\"\"\n    # Symmetrize: M_s = 0.5 * (M + M^T)\n    M_sym = 0.5 * (M + np.swapaxes(M, -1, -2))\n    \n    # Make traceless: Q = M_s - 0.5 * tr(M_s) * I\n    # trace has shape (...)\n    trace = np.trace(M_sym, axis1=-2, axis2=-1)\n    I = np.identity(2)\n    # Use broadcasting to subtract the isotropic part\n    return M_sym - 0.5 * trace[..., np.newaxis, np.newaxis] * I\n\ndef run_simulation(Nx, Ny, dt, steps, L, a, Gamma, delta_int, delta_bnd, mode):\n    \"\"\"\n    Runs a single simulation with the given parameters and returns the diagnostics.\n    \"\"\"\n    # Constants and initial setup\n    S = 1.0\n    Q_star = S * np.array([[0.5, 0.0], [0.0, -0.5]])\n    I = np.identity(2)\n    Q = np.zeros((Nx, Ny, 2, 2))\n\n    # Initial condition for interior: Q_star + small random sym-traceless perturbation\n    pert_amp = 1e-12\n    # Create random matrix for each interior point\n    rand_pert = pert_amp * (2 * np.random.rand(Nx - 2, Ny - 2, 2, 2) - 1.0)\n    Q[1:-1, 1:-1] = Q_star + project_to_symmetric_traceless(rand_pert)\n\n    # Initial condition for boundary\n    Q[0, :] = Q_star\n    Q[-1, :] = Q_star\n    Q[:, 0] = Q_star\n    Q[:, -1] = Q_star\n\n    # Drift terms\n    drift_int_matrix = delta_int * I\n    Q_bnd_val = Q_star + delta_bnd * I\n\n    # Time-stepping loop\n    for _ in range(steps):\n        Q_new = np.copy(Q)\n\n        # Calculate Laplacian using 5-point stencil on interior\n        lap_Q = (Q[0:-2, 1:-1] + Q[2:, 1:-1] +\n                 Q[1:-1, 0:-2] + Q[1:-1, 2:] - 4 * Q[1:-1, 1:-1])\n\n        # Euler update for interior points\n        RHS = Gamma * (L * lap_Q - a * Q[1:-1, 1:-1])\n        Q_new[1:-1, 1:-1] += dt * RHS\n        \n        # Add interior drift\n        Q_new[1:-1, 1:-1] += drift_int_matrix\n\n        # Apply projection based on mode\n        if mode == 1: # Interior enforcement only\n            Q_new[1:-1, 1:-1] = project_to_symmetric_traceless(Q_new[1:-1, 1:-1])\n        elif mode == 2: # Full enforcement\n            Q_new = project_to_symmetric_traceless(Q_new)\n\n        # Apply boundary conditions\n        Q_new[0, :] = Q_bnd_val\n        Q_new[-1, :] = Q_bnd_val\n        Q_new[:, 0] = Q_bnd_val\n        Q_new[:, -1] = Q_bnd_val\n        \n        # Re-project boundaries for mode 2\n        if mode == 2:\n            Q_new[0, :] = project_to_symmetric_traceless(Q_new[0, :])\n            Q_new[-1, :] = project_to_symmetric_traceless(Q_new[-1, :])\n            Q_new[:, 0] = project_to_symmetric_traceless(Q_new[:, 0])\n            Q_new[:, -1] = project_to_symmetric_traceless(Q_new[:, -1])\n            \n        Q = Q_new\n\n    # --- Calculate final diagnostics ---\n\n    # 1. Mean absolute trace over interior nodes\n    Q_interior = Q[1:-1, 1:-1]\n    trace_Q_interior = np.trace(Q_interior, axis1=2, axis2=3)\n    mean_abs_trace_int = np.mean(np.abs(trace_Q_interior))\n\n    # 2. Maximum absolute trace over boundary nodes\n    bnd_mask = np.ones((Nx, Ny), dtype=bool)\n    bnd_mask[1:-1, 1:-1] = False\n    Q_bnd = Q[bnd_mask]\n    trace_Q_bnd = np.trace(Q_bnd, axis1=1, axis2=2)\n    max_abs_trace_bnd = np.max(np.abs(trace_Q_bnd)) if trace_Q_bnd.size  0 else 0.0\n    \n    # 3. RMS trace over the whole domain\n    trace_Q_all = np.trace(Q, axis1=2, axis2=3)\n    rms_trace = np.sqrt(np.mean(trace_Q_all**2))\n    \n    return mean_abs_trace_int, max_abs_trace_bnd, rms_trace\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "One of the most fascinating aspects of nematic hydrodynamics is the dynamics of topological defects, which are singularities in the director field. To analyze their behavior, we must first reliably identify them within our numerical data. This practice introduces the standard computational method for defect detection: calculating the topological charge by measuring the winding of the director field, which is derived from the alignment tensor $Q$, around each point on a grid. ",
            "id": "4079596",
            "problem": "You are given the task of developing and validating a numerical criterion to detect topological defects in a two-dimensional nematic field based on the Beris-Edwards model for nematic hydrodynamics. In nematic liquid crystals, the state is described by a symmetric, traceless second-order tensor, the Landau–de Gennes alignment tensor $Q$. For two-dimensional planar nematics, the tensor $Q$ can be expressed in terms of a scalar order parameter $S$ and a director field $\\mathbf{n} = (\\cos\\theta, \\sin\\theta)$ as\n$$\nQ = S\\left(\\mathbf{n}\\otimes\\mathbf{n} - \\frac{1}{2}I\\right),\n$$\nwhere $I$ is the identity tensor and $\\theta$ is the director angle. In the Beris–Edwards model, the principal eigenvector of $Q$ gives the local director, defined modulo a sign, implying that the director angle is only defined modulo $\\pi$.\n\nThe topological charge $s$ of a defect enclosed by a closed loop $\\Gamma$ is given by the winding of the director angle around the loop:\n$$\ns = \\frac{1}{\\pi}\\oint_{\\Gamma} d\\theta.\n$$\nwith angles measured in radians. Because the director is headless, differences of the director angle must be computed modulo $\\pi$ so that the smallest change is taken at each step. Numerically, one can compute $s$ on a discrete grid by summing angle differences around the perimeter of each grid cell and dividing by $\\pi$.\n\nStarting from these definitions, implement a program that:\n1. Constructs synthetic two-dimensional alignment tensor fields $Q(\\mathbf{x})$ on a square grid for specified sets of defects. The synthetic director angle field is defined by\n$$\n\\theta(x,y) = \\sum_{i=1}^{N_d} s_i \\, \\mathrm{atan2}(y-y_i, x-x_i),\n$$\nwhere $s_i\\in\\{\\pm \\tfrac{1}{2}\\}$ are the defect charges, $(x_i,y_i)$ are defect positions, and $\\mathrm{atan2}$ is the two-argument arctangent function returning angles in radians. Use a constant scalar order parameter $S_0$ to build $Q$ from $\\theta$ via the definition above.\n2. Recovers the director angle at each grid point from $Q$ using the principal eigenvector. For numerical stability and efficiency, you must compute the director angle using the invariant relation\n$$\n\\theta = \\frac{1}{2}\\,\\mathrm{atan2}\\left(2\\,Q_{xy},\\,Q_{xx}-Q_{yy}\\right),\n$$\nwhich yields the angle modulo $\\pi$.\n3. Computes the winding number $s$ for each grid cell by summing the angle differences around the cell perimeter, with each angle difference reduced modulo $\\pi$ to the principal range $(-\\tfrac{\\pi}{2},\\tfrac{\\pi}{2}]$. Classify a cell as containing a defect if $\\lvert s\\rvert$ exceeds a detection threshold.\n4. Clusters adjacent defect cells of the same sign to form defect candidates, and estimates each candidate’s charge as the mean of its cell windings and its position as the centroid of its cells.\n5. Validates the detection by comparing the detected defects against the known synthetic defects, using a positional tolerance measured in the unit square and a charge tolerance relative to $\\pm\\tfrac{1}{2}$.\n\nAll angles must be treated in radians. Your implementation must be deterministic and self-contained.\n\nTest Suite Specification:\nUse the following five test cases; in all cases, the domain is the unit square $[0,1]\\times[0,1]$, and computations must be in radians.\n\n- Test Case 1 (single positive defect, interior):\n    - Grid size $N = 128$.\n    - Scalar order parameter $S_0 = 0.6$.\n    - Defects: one at $(x_1,y_1)=(0.50,0.50)$ with charge $s_1=+\\tfrac{1}{2}$.\n    - Positional tolerance: $0.05$.\n    - Charge tolerance: $0.2$.\n    - Detection threshold for cell winding: $0.3$.\n\n- Test Case 2 (single negative defect, interior):\n    - Grid size $N = 128$.\n    - Scalar order parameter $S_0 = 0.6$.\n    - Defects: one at $(x_1,y_1)=(0.50,0.50)$ with charge $s_1=-\\tfrac{1}{2}$.\n    - Positional tolerance: $0.05$.\n    - Charge tolerance: $0.2$.\n    - Detection threshold: $0.3$.\n\n- Test Case 3 (pair of opposite defects, off-center):\n    - Grid size $N = 128$.\n    - Scalar order parameter $S_0 = 0.6$.\n    - Defects: $(x_1,y_1)=(0.30,0.70)$ with $s_1=+\\tfrac{1}{2}$, and $(x_2,y_2)=(0.70,0.30)$ with $s_2=-\\tfrac{1}{2}$.\n    - Positional tolerance: $0.05$.\n    - Charge tolerance: $0.2$.\n    - Detection threshold: $0.3$.\n\n- Test Case 4 (uniform field with no defects):\n    - Grid size $N = 128$.\n    - Scalar order parameter $S_0 = 0.6$.\n    - Defects: none; take $\\theta(x,y)=0$ for all points.\n    - Detection threshold: $0.3$.\n    - Expected outcome: no detected defects.\n\n- Test Case 5 (positive defect near boundary):\n    - Grid size $N = 128$.\n    - Scalar order parameter $S_0 = 0.6$.\n    - Defects: one at $(x_1,y_1)=(0.05,0.95)$ with charge $s_1=+\\tfrac{1}{2}$.\n    - Positional tolerance: $0.05$.\n    - Charge tolerance: $0.2$.\n    - Detection threshold: $0.3$.\n\nProgram Output Specification:\nYour program should produce a single line of output containing the results for the five test cases as a comma-separated list enclosed in square brackets, with each result being a boolean indicating whether the detection matched the expected number, positions within the positional tolerance, and charges within the charge tolerance for that test case. For example, the output format must be exactly like:\n[$\\text{result}_1$,$\\text{result}_2$,$\\text{result}_3$,$\\text{result}_4$,$\\text{result}_5$]",
            "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the established principles of the Landau–de Gennes and Beris–Edwards theories for nematic liquid crystals. The problem is well-posed, providing a complete and consistent set of definitions, physical parameters, and numerical procedures. The objectives and validation criteria are stated with clear, unambiguous, quantitative language. The task is to implement a multi-step numerical algorithm to identify topological defects in a simulated 2D nematic field and validate the detection against known ground truth.\n\nThe solution is implemented following a five-step procedure for each test case: (1) generation of a synthetic alignment tensor field $Q(\\mathbf{x})$ on a discrete grid, (2) recovery of the director angle field $\\theta(\\mathbf{x})$ from $Q(\\mathbf{x})$, (3) calculation of the topological charge density (winding number) for each grid cell to identify defect cores, (4) clustering of adjacent defect cells to define and characterize defect candidates, and (5) validation of the detected defects against the synthetically generated ground truth.\n\n**1. Synthetic Field Generation**\n\nThe nematic field is discretized on a uniform $N \\times N$ grid over the unit square domain $[0,1]\\times[0,1]$. The grid spacing is $h=1/(N-1)$. The coordinates of a grid point $(i,j)$, where $i,j \\in \\{0, 1, \\dots, N-1\\}$, are given by $(x_i, y_j) = (i \\cdot h, j \\cdot h)$.\n\nA synthetic director angle field $\\theta(x,y)$ is first constructed. For a set of $N_d$ point defects, each with charge $s_k \\in \\{\\pm \\frac{1}{2}\\}$ and position $(x_k, y_k)$, the director angle at any point $(x,y)$ is given by the superposition of the fields from each defect:\n$$\n\\theta(x,y) = \\sum_{k=1}^{N_d} s_k \\, \\mathrm{atan2}(y-y_k, x-x_k)\n$$\nThe function $\\mathrm{atan2}(v,u)$ returns the angle in radians between the positive $u$-axis and the point $(u,v)$. This expression generates the characteristic phase winding of topological defects. For the case of no defects, this sum is empty, and $\\theta(x,y)=0$ for all points, representing a uniform director field.\n\nFrom this angle field $\\theta(x,y)$ and a given constant scalar order parameter $S_0$, the components of the alignment tensor $Q$ are computed at each grid point. The $Q$ tensor for a 2D planar nematic is defined as:\n$$\nQ = S_0 \\left( \\mathbf{n}\\otimes\\mathbf{n} - \\frac{1}{2}I \\right)\n$$\nwhere $\\mathbf{n} = (\\cos\\theta, \\sin\\theta)$ is the director vector and $I$ is the $2 \\times 2$ identity matrix. The individual components are:\n$$\n\\begin{aligned}\nQ_{xx} = S_0 \\left( \\cos^2\\theta - \\frac{1}{2} \\right) \\\\\nQ_{yy} = S_0 \\left( \\sin^2\\theta - \\frac{1}{2} \\right) = -Q_{xx} \\\\\nQ_{xy} = S_0 \\cos\\theta \\sin\\theta\n\\end{aligned}\n$$\nThese three components, stored in $N \\times N$ arrays, constitute the synthetic input data for the detection algorithm.\n\n**2. Director Field Recovery**\n\nThe next step is to recover the director angle field from the synthetic $Q$ tensor, mimicking a situation where $Q$ is the result of a simulation or experiment. The director corresponds to the principal eigenvector of $Q$. The angle $\\theta$ of this eigenvector is determined modulo $\\pi$, reflecting the head-tail symmetry of the nematic director $(\\mathbf{n} \\equiv -\\mathbf{n})$. An efficient and numerically stable method to recover this angle is via the provided invariant relation:\n$$\n\\theta_{\\text{rec}} = \\frac{1}{2} \\mathrm{atan2}(2Q_{xy}, Q_{xx}-Q_{yy})\n$$\nThis formula correctly yields the director angle in the range $(-\\pi/2, \\pi/2]$, which is a valid representation of the director orientation modulo $\\pi$. This recovered field, $\\theta_{\\text{rec}}$, is used for all subsequent calculations.\n\n**3. Defect Core Identification via Winding Number**\n\nA topological defect is a singularity in the director field. Its presence within a region is revealed by a non-zero net winding of the director angle around the boundary of that region. The topological charge $s$ of a defect is given by the integral $s = \\frac{1}{\\pi} \\oint d\\theta$.\n\nWe compute a discrete version of this for each elementary cell of our grid. A cell $(i,j)$ is a square defined by the four grid vertices $(i,j)$, $(i+1,j)$, $(i+1,j+1)$, and $(i,j+1)$. We sum the differences in the recovered angle $\\theta_{\\text{rec}}$ along a counter-clockwise path around the cell's perimeter:\n$$\n\\Delta\\theta_{\\text{total}} = (\\theta_{i+1,j} - \\theta_{i,j}) + (\\theta_{i+1,j+1} - \\theta_{i+1,j}) + (\\theta_{i,j+1} - \\theta_{i+1,j+1}) + (\\theta_{i,j} - \\theta_{i,j+1})\n$$\nwhere $\\theta_{i,j}$ is the angle at grid point $(i,j)$. Crucially, because $\\theta$ is defined modulo $\\pi$, each angle difference $\\Delta\\theta$ must be wrapped to the principal interval $(-\\pi/2, \\pi/2]$ to represent the smallest rotation. This is achieved by the operation $\\Delta\\theta' = \\Delta\\theta - \\pi \\cdot \\text{round}(\\Delta\\theta/\\pi)$. The winding number for cell $(i,j)$ is then:\n$$\ns_{ij} = \\frac{1}{\\pi} \\sum_{\\text{edges}} \\Delta\\theta'\n$$\nThis calculation is performed for all $(N-1) \\times (N-1)$ cells. A cell is classified as a \"defect cell\" if the absolute value of its winding number, $|s_{ij}|$, exceeds a specified detection threshold.\n\n**4. Defect Clustering and Characterization**\n\nA single topological defect may span multiple adjacent grid cells, all of which will exhibit a significant winding number. These defect cells must be grouped into clusters to identify individual defect candidates. A Breadth-First Search (BFS) algorithm is employed for this purpose. The algorithm iterates through the grid of cells. When an unvisited defect cell is found, a BFS is initiated to find all connected defect cells that share the same sign of winding number (i.e., positive or negative). Connectivity is defined by sharing an edge (4-connectivity).\n\nOnce a cluster of cells is identified, it is characterized as a single defect candidate:\n-   **Charge**: The charge of the candidate is calculated as the arithmetic mean of the winding numbers $s_{ij}$ of all cells within the cluster.\n-   **Position**: The position of the candidate is the centroid of the centers of the cells in the cluster. If a cell's bottom-left corner is at $(x_i, y_j)$, its center is at $(x_i + h/2, y_j + h/2)$.\n\n**5. Validation**\n\nThe final step is to compare the list of detected defect candidates against the original list of synthetic defects. The validation proceeds as follows:\n1.  Both the true and detected defect lists are partitioned into two sub-lists based on charge: positive ($s0$) and negative ($s0$).\n2.  For the case of no true defects, the validation is successful if and only if no defects were detected.\n3.  For cases with defects, the number of detected positive defects must match the number of true positive defects, and likewise for negative defects. If the counts do not match, the validation fails.\n4.  If the counts match, a one-to-one correspondence between true and detected defects of the same sign must be established. This is an assignment problem, which is solved optimally using the `scipy.optimize.linear_sum_assignment` function. The cost matrix for the assignment is the Euclidean distance between the positions of true and detected defects.\n5.  For each resulting pair of a true defect and its matched detected defect, two conditions must be met:\n    a. The Euclidean distance between their positions must be less than or equal to the specified positional tolerance.\n    b. The absolute difference between their charges, $|s_{\\text{det}} - s_{\\text{true}}|$, must be less than or equal to the specified charge tolerance.\n6.  The test case is considered passed (True) only if all defect counts match and every matched pair satisfies both the position and charge tolerance criteria. Otherwise, it is failed (False).",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linear_sum_assignment\nfrom scipy.spatial.distance import cdist\nfrom collections import deque\n\ndef run_test_case(N, S0, defects, pos_tol, charge_tol, threshold):\n    \"\"\"\n    Runs a single test case for defect detection.\n\n    Args:\n        N (int): Grid size (N x N).\n        S0 (float): Scalar order parameter.\n        defects (list): List of dictionaries, each specifying a defect's charge and position.\n        pos_tol (float): Positional tolerance for validation.\n        charge_tol (float): Charge tolerance for validation.\n        threshold (float): Detection threshold for cell winding.\n\n    Returns:\n        bool: True if detection is successful, False otherwise.\n    \"\"\"\n\n    # Step 1: Synthetic Field Generation\n    h = 1.0 / (N - 1)\n    x_coords = np.linspace(0, 1, N)\n    y_coords = np.linspace(0, 1, N)\n    x_grid, y_grid = np.meshgrid(x_coords, y_coords)\n\n    theta_field = np.zeros((N, N), dtype=float)\n    if not defects: # Special handling for case 4\n        # theta_field is already zero, but this is explicit\n        pass\n    else:\n        for defect in defects:\n            s_i, (x_i, y_i) = defect['charge'], defect['pos']\n            theta_field += s_i * np.arctan2(y_grid - y_i, x_grid - x_i)\n\n    cos_theta = np.cos(theta_field)\n    sin_theta = np.sin(theta_field)\n\n    Q_xx = S0 * (cos_theta**2 - 0.5)\n    Q_xy = S0 * cos_theta * sin_theta\n    Q_yy = -Q_xx  # S0 * (sin_theta**2 - 0.5)\n\n    # Step 2: Director Field Recovery\n    theta_rec = 0.5 * np.arctan2(2 * Q_xy, Q_xx - Q_yy)\n\n    # Step 3: Defect Core Identification\n    def wrap_angle_diff(d_theta):\n        return d_theta - np.pi * np.round(d_theta / np.pi)\n\n    theta_bl = theta_rec[:-1, :-1]\n    theta_br = theta_rec[:-1, 1:]\n    theta_tr = theta_rec[1:, 1:]\n    theta_tl = theta_rec[1:, :-1]\n\n    d1 = wrap_angle_diff(theta_br - theta_bl)\n    d2 = wrap_angle_diff(theta_tr - theta_br)\n    d3 = wrap_angle_diff(theta_tl - theta_tr)\n    d4 = wrap_angle_diff(theta_bl - theta_tl)\n\n    windings = (1.0 / np.pi) * (d1 + d2 + d3 + d4)\n    is_defect_cell = np.abs(windings)  threshold\n\n    # Step 4: Defect Clustering\n    detected_defects = []\n    visited = np.zeros_like(is_defect_cell, dtype=bool)\n    rows, cols = is_defect_cell.shape\n\n    for r in range(rows):\n        for c in range(cols):\n            if is_defect_cell[r, c] and not visited[r, c]:\n                sign = np.sign(windings[r, c])\n                q = deque([(r, c)])\n                visited[r, c] = True\n                cluster_cells_indices = []\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    cluster_cells_indices.append((curr_r, curr_c))\n\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        if (0 = nr  rows and 0 = nc  cols and\n                            not visited[nr, nc] and is_defect_cell[nr, nc] and\n                            np.sign(windings[nr, nc]) == sign):\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                cell_indices_r, cell_indices_c = zip(*cluster_cells_indices)\n                cell_indices_r = np.array(cell_indices_r)\n                cell_indices_c = np.array(cell_indices_c)\n\n                avg_charge = np.mean(windings[cell_indices_r, cell_indices_c])\n                centroid_x = np.mean(cell_indices_c + 0.5) * h\n                centroid_y = np.mean(cell_indices_r + 0.5) * h\n\n                detected_defects.append({\n                    'pos': (centroid_x, centroid_y),\n                    'charge': avg_charge\n                })\n\n    # Step 5: Validation\n    true_defects = defects\n\n    if not true_defects:\n        return not detected_defects\n\n    true_pos = [d for d in true_defects if d['charge']  0]\n    true_neg = [d for d in true_defects if d['charge']  0]\n    detected_pos = [d for d in detected_defects if d['charge']  0]\n    detected_neg = [d for d in detected_defects if d['charge']  0]\n\n    def match_defects(true_list, detected_list, p_tol, c_tol):\n        if len(true_list) != len(detected_list):\n            return False\n        if not true_list:\n            return True\n\n        true_coords = [d['pos'] for d in true_list]\n        det_coords = [d['pos'] for d in detected_list]\n\n        cost_matrix = cdist(true_coords, det_coords)\n        true_indices, det_indices = linear_sum_assignment(cost_matrix)\n\n        for t_idx, d_idx in zip(true_indices, det_indices):\n            pos_diff = cost_matrix[t_idx, d_idx]\n            if pos_diff  p_tol:\n                return False\n            \n            charge_diff = abs(detected_list[d_idx]['charge'] - true_list[t_idx]['charge'])\n            if charge_diff  c_tol:\n                return False\n        \n        return True\n\n    pos_match = match_defects(true_pos, detected_pos, pos_tol, c_tol)\n    neg_match = match_defects(true_neg, detected_neg, pos_tol, c_tol)\n    \n    return pos_match and neg_match\n\ndef solve():\n    test_cases = [\n        # Test Case 1\n        {\n            'N': 128, 'S0': 0.6,\n            'defects': [{'pos': (0.50, 0.50), 'charge': 0.5}],\n            'pos_tol': 0.05, 'charge_tol': 0.2, 'threshold': 0.3\n        },\n        # Test Case 2\n        {\n            'N': 128, 'S0': 0.6,\n            'defects': [{'pos': (0.50, 0.50), 'charge': -0.5}],\n            'pos_tol': 0.05, 'charge_tol': 0.2, 'threshold': 0.3\n        },\n        # Test Case 3\n        {\n            'N': 128, 'S0': 0.6,\n            'defects': [\n                {'pos': (0.30, 0.70), 'charge': 0.5},\n                {'pos': (0.70, 0.30), 'charge': -0.5}\n            ],\n            'pos_tol': 0.05, 'charge_tol': 0.2, 'threshold': 0.3\n        },\n        # Test Case 4\n        {\n            'N': 128, 'S0': 0.6,\n            'defects': [],\n            'pos_tol': 0.05, 'charge_tol': 0.2, 'threshold': 0.3\n        },\n        # Test Case 5\n        {\n            'N': 128, 'S0': 0.6,\n            'defects': [{'pos': (0.05, 0.95), 'charge': 0.5}],\n            'pos_tol': 0.05, 'charge_tol': 0.2, 'threshold': 0.3\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_test_case(\n            case['N'], case['S0'], case['defects'],\n            case['pos_tol'], case['charge_tol'], case['threshold']\n        )\n        results.append(str(result))\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}