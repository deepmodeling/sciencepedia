{
    "hands_on_practices": [
        {
            "introduction": "Understanding the continuity equation in practice begins with recognizing the critical difference between its conservative and non-conservative forms. This exercise provides a direct computational demonstration of why discretizing the conservative, or flux-divergence, form $\\frac{\\partial \\rho}{\\partial t} + \\nabla \\cdot (\\rho \\mathbf{u}) = 0$ is essential for accuracy. By comparing a non-conservative semi-Lagrangian scheme with a conservative finite-volume scheme, you will see firsthand how artificial mass loss arises and why conservative methods are a cornerstone of computational fluid dynamics .",
            "id": "4082100",
            "problem": "Consider a one-dimensional periodic domain of length $L$ with spatial coordinate $x \\in [0,L)$. A scalar density field $\\rho(x,t)$ is advected by a prescribed, time-independent velocity field $u(x)$ according to the continuity equation (conservation of mass)\n$$\n\\frac{\\partial \\rho}{\\partial t} + \\frac{\\partial}{\\partial x}(\\rho u) = 0,\n$$\nwith periodic boundary conditions. All quantities are nondimensional, and no physical units are required.\n\nYour task is to demonstrate, by computational example, that advecting density using a non-conservative scheme leads to artificial loss (or gain) of total mass, and to measure how this mass error scales with grid refinement. Use the following mathematically and computationally well-posed setup:\n\n- Domain length $L = 1$.\n- Velocity field $u(x) = \\tfrac{1}{2} + \\tfrac{1}{2}\\sin(2\\pi x)$, which is strictly positive and spatially varying.\n- Initial density\n$$\n\\rho(x,0) = 1 + 0.3\\sin(2\\pi x) + 0.8\\exp\\!\\left(-\\frac{(x-0.3)^2}{0.01}\\right),\n$$\nwhich is strictly positive and smooth.\n- Total simulation time $T = 1$.\n- Courant–Friedrichs–Lewy (CFL) number $\\mathrm{CFL} = 0.4$, to select the nominal time step $\\Delta t = \\mathrm{CFL}\\,\\Delta x / \\max_x u(x)$, where $\\Delta x = L/N$ and $N$ is the number of grid points. Use $\\Delta t$ repeatedly for as many whole steps as fit into $T$, and then one final step with the remaining time to achieve exactly $T$.\n\nImplement and compare two time-stepping schemes on a uniform grid with $N$ points, with periodic boundary conditions:\n\n1. A non-conservative semi-Lagrangian pointwise advection scheme with first-order backtracking and linear interpolation on the fixed Eulerian grid. For each grid point $x_i$, compute the backtracked foot $x_i^{\\star} = x_i - u(x_i)\\,\\Delta t$ (wrapped periodically), and update $\\rho_i^{n+1}$ by linear interpolation of $\\rho^n$ at $x_i^{\\star}$.\n\n2. A conservative finite-volume upwind flux scheme formulated in flux-divergence form. Discretize the flux at cell faces $x_{i+1/2}$ as $F_{i+1/2} = u(x_{i+1/2})\\,\\rho_i$ for $u(x_{i+1/2}) > 0$ (which holds here), and update cell averages by the flux difference $\\rho_i^{n+1} = \\rho_i^n - (\\Delta t/\\Delta x)\\left(F_{i+1/2} - F_{i-1/2}\\right)$.\n\nFor each $N$, compute the initial total mass $M_0 = \\int_0^L \\rho(x,0)\\,dx$ approximated by the Riemann sum $M_0 \\approx \\sum_i \\rho_i^0\\,\\Delta x$, and the final total masses $M_{\\mathrm{nc}}(T)$ and $M_{\\mathrm{cons}}(T)$ produced by the non-conservative and conservative schemes, respectively. Define the relative mass error for each scheme by $e_{\\mathrm{nc}} = \\lvert M_{\\mathrm{nc}}(T) - M_0 \\rvert / M_0$ and $e_{\\mathrm{cons}} = \\lvert M_{\\mathrm{cons}}(T) - M_0 \\rvert / M_0$, expressed as decimals.\n\nTest Suite:\n- Use the grid sizes $N \\in \\{50, 100, 200, 400, 800\\}$.\n- For each $N$, compute $e_{\\mathrm{nc}}$ and $e_{\\mathrm{cons}}$.\n- Estimate the empirical error-scaling exponent $q$ for the non-conservative scheme by fitting a straight line to $\\log(e_{\\mathrm{nc}})$ versus $\\log(\\Delta x)$ across the test suite, so that $e_{\\mathrm{nc}} \\approx C\\,(\\Delta x)^q$.\n\nFinal Output Format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order:\n$$\n[ e_{\\mathrm{nc}}(N{=}50), e_{\\mathrm{nc}}(N{=}100), e_{\\mathrm{nc}}(N{=}200), e_{\\mathrm{nc}}(N{=}400), e_{\\mathrm{nc}}(N{=}800), q, \\max\\{ e_{\\mathrm{cons}}(N) : N \\in \\{50,100,200,400,800\\} \\} ].\n$$\nAll entries must be decimal numbers (floats). This single-line output is the only required output of the program.",
            "solution": "The problem requires a computational demonstration of mass conservation failure in a non-conservative numerical scheme versus the mass conservation property of a conservative scheme for the one-dimensional continuity equation. We will implement and compare two specified schemes, compute the mass conservation error for a range of grid resolutions, and determine the empirical scaling of the error with the grid spacing for the non-conservative scheme.\n\nThe governing equation is the continuity equation in one dimension, which expresses the conservation of a scalar quantity $\\rho$ (density) being transported by a velocity field $u$:\n$$\n\\frac{\\partial \\rho}{\\partial t} + \\frac{\\partial}{\\partial x}(\\rho u) = 0\n$$\nThis is known as the conservative form, as the spatial derivative acts on the flux, $F = \\rho u$. A key property of this form is that the total mass in a closed or periodic domain, $M = \\int \\rho \\, dx$, is constant over time. This can be seen by integrating the equation over the domain $[0,L]$:\n$$\n\\frac{dM}{dt} = \\frac{d}{dt}\\int_0^L \\rho \\, dx = -\\int_0^L \\frac{\\partial}{\\partial x}(\\rho u) \\, dx = -[\\rho u]_0^L = 0\n$$\nThe final equality holds due to the periodic boundary conditions, where $\\rho(0,t)u(0) = \\rho(L,t)u(L)$. A numerical scheme that directly discretizes this flux-divergence form is called a \"conservative scheme\" and is expected to preserve the discrete total mass to machine precision.\n\nUsing the product rule, the continuity equation can be rewritten in a non-conservative or advective form:\n$$\n\\frac{\\partial \\rho}{\\partial t} + u \\frac{\\partial \\rho}{\\partial x} + \\rho \\frac{\\partial u}{\\partial x} = 0\n$$\nNumerical schemes that approximate a simplified version, such as the simple advection equation $\\frac{\\partial \\rho}{\\partial t} + u \\frac{\\partial \\rho}{\\partial x} = 0$, are termed \"non-conservative\" when the velocity field $u(x)$ is spatially varying. These schemes fail to account for the term $\\rho \\frac{\\partial u}{\\partial x}$, which represents the change in density due to the convergence or divergence of the velocity field. This omission leads to an artificial source or sink of mass, causing the total mass to drift over time.\n\nWe will set up a numerical experiment on a uniform grid with $N$ points, spatial resolution $\\Delta x = L/N$, and cell-centered coordinates $x_i = i \\Delta x$ for $i=0, \\dots, N-1$. The time step $\\Delta t$ is determined by the CFL condition, $\\Delta t = \\mathrm{CFL} \\cdot \\Delta x / \\max_x |u(x)|$. With $L=1$, $\\mathrm{CFL}=0.4$, and $u(x) = \\frac{1}{2} + \\frac{1}{2}\\sin(2\\pi x)$, we find $\\max_x u(x) = 1$, thus $\\Delta t = 0.4 \\Delta x$. The total simulation time $T=1$ is covered by a sequence of time steps.\n\n**1. Non-Conservative Semi-Lagrangian Scheme**\nThis method is based on the Lagrangian perspective of fluid motion. The equation $\\frac{D\\rho}{Dt} = \\frac{\\partial \\rho}{\\partial t} + u \\frac{\\partial \\rho}{\\partial x} = 0$ implies that $\\rho$ is constant along characteristic curves defined by $\\frac{dx}{dt} = u$. To update the density at a fixed Eulerian grid point $x_i$ from time $t^n$ to $t^{n+1} = t^n + \\Delta t$, we trace the characteristic back in time to find the departure point $x_i^\\star$ at time $t^n$. A first-order approximation gives:\n$$\nx_i^\\star = x_i - u(x_i) \\Delta t\n$$\nThe new density at $x_i$ is simply the density at the departure point, $\\rho_i^{n+1} = \\rho^n(x_i^\\star)$. Since $x_i^\\star$ will not in general coincide with a grid point, this value must be found by interpolating the known grid values of $\\rho^n$. The problem specifies linear interpolation. The value $\\rho_i^{n+1}$ is computed by finding the two grid points $x_j$ and $x_{j+1}$ that bracket the periodically wrapped coordinate $x_i^\\star$ and performing linear interpolation between $\\rho_j^n$ and $\\rho_{j+1}^n$. This interpolation step does not enforce the conservation of total mass, and the accumulation of these small errors leads to a significant drift in the total mass over time.\n\n**2. Conservative Finite-Volume Upwind Scheme**\nThis scheme starts from the integral form of the conservation law over each grid cell (control volume) $[x_{i-1/2}, x_{i+1/2}]$, where $x_{i\\pm1/2} = x_i \\pm \\Delta x/2$.\n$$\n\\frac{d}{dt} \\int_{x_{i-1/2}}^{x_{i+1/2}} \\rho \\, dx = (\\rho u)|_{x_{i-1/2}} - (\\rho u)|_{x_{i+1/2}}\n$$\nApproximating the cell-average density $\\rho_i \\approx \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} \\rho \\, dx$ and using a forward Euler time step, we get the discretized flux-divergence form:\n$$\n\\rho_i^{n+1} = \\rho_i^n - \\frac{\\Delta t}{\\Delta x} (F_{i+1/2} - F_{i-1/2})\n$$\nwhere $F_{i\\pm1/2}$ is the numerical flux at the cell face. For the first-order upwind scheme, the flux is determined by the state in the \"upwind\" cell. Since the given velocity field $u(x) \\geq 0$ for all $x$, the flow is always from left to right (or stationary). Thus, the state at any face is determined by the cell to its left:\n$$\nF_{i+1/2} = u(x_{i+1/2}) \\rho_i^n\n$$\nWhen we sum the update rule over all cells $i=0, \\dots, N-1$, the flux differences form a telescoping sum: $\\sum_i (F_{i+1/2} - F_{i-1/2})$. Due to periodicity ($F_{-1/2} = F_{N-1/2}$), this sum is exactly zero. Consequently, $\\sum_i \\rho_i^{n+1} = \\sum_i \\rho_i^n$, and the discrete total mass $M = \\sum_i \\rho_i \\Delta x$ is conserved to the limits of floating-point arithmetic.\n\n**3. Error Analysis**\nFor each grid size $N$, we compute the initial mass $M_0 = \\sum_i \\rho(x_i, 0) \\Delta x$ and the final masses $M_{\\mathrm{nc}}(T)$ and $M_{\\mathrm{cons}}(T)$. The relative mass errors, $e_{\\mathrm{nc}} = |M_{\\mathrm{nc}}(T) - M_0| / M_0$ and $e_{\\mathrm{cons}} = |M_{\\mathrm{cons}}(T) - M_0| / M_0$, are calculated. We expect $e_{\\mathrm{cons}}$ to be near machine epsilon, while $e_{\\mathrm{nc}}$ will be significant and should decrease as the grid is refined.\nTo find the empirical order of convergence $q$ for the non-conservative scheme's mass error, we assume a power-law relationship $e_{\\mathrm{nc}} \\approx C (\\Delta x)^q$, where $C$ is a constant. Taking the logarithm gives a linear relationship:\n$$\n\\log(e_{\\mathrm{nc}}) \\approx \\log(C) + q \\log(\\Delta x)\n$$\nBy performing a linear regression on the computed values of $\\log(e_{\\mathrm{nc}})$ against $\\log(\\Delta x)$ for the given series of grid sizes $N$, the slope of the best-fit line provides an estimate for the scaling exponent $q$.\n\nThe implementation will follow these principles, performing the simulations for the specified range of $N$, calculating the errors, and fitting for $q$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D advection problem using non-conservative and conservative schemes,\n    computes mass errors, and determines the error scaling for the non-conservative scheme.\n    \"\"\"\n    # Problem parameters\n    L = 1.0\n    T = 1.0\n    CFL = 0.4\n    TEST_CASES_N = [50, 100, 200, 400, 800]\n\n    # Field definitions\n    def u_field(x):\n        return 0.5 + 0.5 * np.sin(2 * np.pi * x / L)\n\n    def rho_initial(x):\n        return 1.0 + 0.3 * np.sin(2 * np.pi * x / L) + 0.8 * np.exp(-((x - 0.3*L)**2) / 0.01)\n\n    e_nc_results = []\n    e_cons_results = []\n\n    for N in TEST_CASES_N:\n        # ---- 1. Grid and Initial Conditions Setup ----\n        dx = L / N\n        # Cell-centered grid\n        x_nodes = np.arange(N) * dx\n        \n        # Initial density at cell centers\n        rho0 = rho_initial(x_nodes)\n        \n        # Initial total mass\n        m0 = np.sum(rho0) * dx\n\n        # ---- 2. Time-stepping Setup ----\n        u_max = 1.0  # Max of u_field is 0.5 + 0.5*1 = 1.0\n        dt = CFL * dx / u_max\n        \n        num_steps = int(T / dt)\n        last_dt = T - num_steps * dt\n        \n        timesteps = [dt] * num_steps\n        if last_dt > 1e-12:  # Add final smaller step if needed\n            timesteps.append(last_dt)\n\n        # ---- 3. Simulation Loop ----\n        # Initialize densities for both schemes\n        rho_nc = rho0.copy()\n        rho_cons = rho0.copy()\n\n        # Pre-compute velocities for efficiency\n        # Velocities at cell centers (for non-conservative scheme)\n        u_nodes = u_field(x_nodes)\n        # Velocities at cell faces (for conservative scheme)\n        x_faces = (np.arange(N) + 0.5) * dx\n        u_faces = u_field(x_faces)\n\n        for t_step in timesteps:\n            # --- Update Non-Conservative (Semi-Lagrangian) Scheme ---\n            # Compute departure points\n            x_star = x_nodes - u_nodes * t_step\n            # Linearly interpolate to find new density. np.interp handles periodicity.\n            rho_nc = np.interp(x_star, x_nodes, rho_nc, period=L)\n\n            # --- Update Conservative (Finite-Volume Upwind) Scheme ---\n            # Flux at right face of each cell i (F_{i+1/2})\n            # Upwind flux uses rho_i since u >= 0\n            flux_right = u_faces * rho_cons\n            # Flux at left face of each cell i (F_{i-1/2})\n            flux_left = np.roll(flux_right, 1) # Get F_{i-1/2} by rolling F_{j+1/2}\n            \n            # Update cell average density\n            rho_cons -= (t_step / dx) * (flux_right - flux_left)\n\n        # ---- 4. Post-processing for this N ----\n        # Final total mass\n        m_nc_final = np.sum(rho_nc) * dx\n        m_cons_final = np.sum(rho_cons) * dx\n\n        # Relative mass error\n        e_nc = np.abs(m_nc_final - m0) / m0\n        e_cons = np.abs(m_cons_final - m0) / m0\n\n        e_nc_results.append(e_nc)\n        e_cons_results.append(e_cons)\n\n    # ---- 5. Empirical Error Scaling Analysis ----\n    dx_values = L / np.array(TEST_CASES_N)\n    log_dx = np.log(dx_values)\n    log_e_nc = np.log(np.array(e_nc_results))\n    \n    # Fit log(error) vs log(dx) to a line y = mx + c. The slope m is the order q.\n    q_exponent, _ = np.polyfit(log_dx, log_e_nc, 1)\n\n    # Get the maximum error for the conservative scheme\n    max_e_cons = np.max(e_cons_results)\n\n    # ---- 6. Final Output ----\n    final_results = e_nc_results + [q_exponent, max_e_cons]\n    \n    # Format the numbers to a reasonable precision for consistent output\n    formatted_results = [f\"{val:.10f}\" for val in final_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        },
        {
            "introduction": "For incompressible fluids, where density $\\rho$ is constant, the continuity equation simplifies to a kinematic constraint on the velocity field: $\\nabla \\cdot \\mathbf{u} = 0$. This exercise guides you through implementing a projection method, a fundamental algorithm in computational fluid dynamics for enforcing this divergence-free condition. Using a spectrally accurate method based on the Fast Fourier Transform (FFT), you will construct a projection that perfectly separates a velocity field into its divergent and divergence-free parts, thereby ensuring mass conservation to machine precision .",
            "id": "4082126",
            "problem": "You are asked to design and implement a mass-conservative projection step in a fractional-step method for incompressible complex fluids that enforces the discrete conservation of mass at the new time level. Starting from the conservation of mass and the definition of incompressibility, construct a projection that maps an intermediate velocity field to a divergence-free field on a two-dimensional periodic domain. The domain is the unit torus with periodic boundary conditions, namely $[0,1]^2$, discretized on a uniform grid with $N_x$ points in the $x$-direction and $N_y$ points in the $y$-direction. The intermediate velocity field at time level $n$ after the explicit non-pressure update is denoted by $\\mathbf{u}^\\star(x,y) = (u^\\star(x,y), v^\\star(x,y))$, and the objective is to produce $\\mathbf{u}^{n+1}(x,y)$ satisfying $\\nabla \\cdot \\mathbf{u}^{n+1}(x,y) = 0$ at the discrete level to machine precision.\n\nYour construction must be based on a consistent pair of discrete gradient and divergence operators that are adjoint on the periodic grid so that the projection step enforces the discrete continuity equation exactly up to floating-point rounding. This step must conceptually solve a discrete Poisson equation for a scalar potential that corrects the intermediate velocity and guarantees a divergence-free result. The core scientific base must begin from the law of conservation of mass and the definition of incompressibility. No shortcut formulas are permitted in the problem statement; derive what is needed in your solution.\n\nImplement your projection in a way that is reproducible and numerically robust on the periodic unit square. All computations are to be nondimensional. Angles, if any, are interpreted implicitly in radians because the functions employed are trigonometric in the standard mathematical sense; however, you do not need to report any angles in the output.\n\nYour program must:\n- Construct the test velocity fields $\\mathbf{u}^\\star(x,y)$ on given grids.\n- Apply your mass-conservative projection to obtain $\\mathbf{u}^{n+1}(x,y)$.\n- Compute the discrete divergence of $\\mathbf{u}^{n+1}(x,y)$ using the same discrete operators that underlie your projection mechanism.\n- Report, for each test case, the maximum absolute value of the discrete divergence over the grid as a floating-point number.\n\nTest suite:\n- Case $1$: $N_x = 32$, $N_y = 32$. Define $x_i = i/N_x$, $y_j = j/N_y$ for integers $i \\in \\{0,\\dots,N_x-1\\}$ and $j \\in \\{0,\\dots,N_y-1\\}$. Let the scalar field $\\psi(x,y) = \\sin(2\\pi x)\\cos(2\\pi y)$ and $\\phi(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$. Define a potential-flow gradient component $\\mathbf{u}_{\\mathrm{grad}} = \\nabla \\psi$ and a divergence-free rotational component $\\mathbf{u}_{\\mathrm{vort}} = (-\\partial_y \\phi, \\partial_x \\phi)$. Set $\\mathbf{u}^\\star = \\mathbf{u}_{\\mathrm{grad}} + \\mathbf{u}_{\\mathrm{vort}} + 0.1\\,\\boldsymbol{\\eta}$, where $\\boldsymbol{\\eta}$ is a deterministic pseudorandom field drawn from a standard normal distribution with seed set to $0$ and shaped to $(N_x,N_y)$ for each component.\n- Case $2$: $N_x = 33$, $N_y = 17$. Let $\\mathbf{u}^\\star = \\boldsymbol{\\eta} + \\mathbf{c}$, where $\\boldsymbol{\\eta}$ is as above but with seed set to $0$, and $\\mathbf{c} = (1.5, -0.75)$ is a constant uniform velocity vector.\n- Case $3$: $N_x = 64$, $N_y = 64$. Let $\\psi(x,y) = \\cos(4\\pi x)\\sin(2\\pi y)$ and set $\\mathbf{u}^\\star = \\nabla \\psi$ (a pure gradient field).\n- Case $4$: $N_x = 8$, $N_y = 8$. Let $\\phi(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$ and set $\\mathbf{u}^\\star = 3\\,(-\\partial_y \\phi, \\partial_x \\phi)$ (a scaled divergence-free field).\n- Case $5$: $N_x = 16$, $N_y = 24$. Let $\\mathbf{u}^\\star = \\boldsymbol{\\eta}$ with seed set to $42$ and components drawn from a standard normal distribution.\n\nDefinitions and requirements:\n- Use the discrete Fourier transform consistent with periodic boundary conditions to realize the discrete gradient, divergence, and the solution of the Poisson equation. Use Fast Fourier Transform (FFT) as the numerical mechanism for transforms.\n- The discrete divergence must be computed spectrally using the same wavenumbers employed in the projection construction, ensuring adjointness and exact cancellation up to floating point.\n- For each case, compute the maximum absolute discrete divergence of $\\mathbf{u}^{n+1}$ and return it as a floating-point value.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[\\mathrm{result}_1,\\mathrm{result}_2,\\mathrm{result}_3,\\mathrm{result}_4,\\mathrm{result}_5]$). Each result must be a floating-point number.",
            "solution": "The problem requires the design and implementation of a mass-conservative projection step for an incompressible fluid on a two-dimensional periodic domain. The solution must be derived from first principles, specifically the conservation of mass, and implemented using spectral methods based on the Fast Fourier Transform (FFT).\n\nThe fundamental principle governing fluid motion is the conservation of mass, expressed by the continuity equation:\n$$\n\\frac{\\partial \\rho}{\\partial t} + \\nabla \\cdot (\\rho \\mathbf{u}) = 0\n$$\nwhere $\\rho$ is the fluid density and $\\mathbf{u}$ is the velocity field. For a complex fluid treated as incompressible, the density $\\rho$ is assumed to be constant in both space and time. Consequently, its partial derivatives are zero, $\\frac{\\partial \\rho}{\\partial t} = 0$ and $\\nabla \\rho = \\mathbf{0}$. The continuity equation simplifies to:\n$$\n\\rho (\\nabla \\cdot \\mathbf{u}) = 0\n$$\nSince $\\rho > 0$, this yields the incompressibility constraint, which is a kinematic condition on the velocity field:\n$$\n\\nabla \\cdot \\mathbf{u} = 0\n$$\nThis equation states that the velocity field of an incompressible flow must be divergence-free.\n\nFractional-step methods, or projection methods, are commonly used to solve the time-dependent Navier-Stokes equations for incompressible flows. They decouple the computation of velocity and pressure. In a typical two-step scheme, an intermediate velocity field, denoted $\\mathbf{u}^\\star$, is first computed at time level $n+1$ by advancing the momentum equation without the pressure gradient term. This field $\\mathbf{u}^\\star$ will not, in general, satisfy the incompressibility constraint.\n\nThe second step, the projection step, corrects $\\mathbf{u}^\\star$ to produce a velocity field $\\mathbf{u}^{n+1}$ that is discretely divergence-free. This is achieved by incorporating the effect of the pressure gradient. The correction is given by:\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^\\star}{\\Delta t} = -\\nabla p^{n+1}\n$$\nwhere $p^{n+1}$ is related to the pressure and $\\Delta t$ is the time step. For our nondimensional problem, we can absorb $\\Delta t$ into a scalar potential, $\\Phi$, such that the update is:\n$$\n\\mathbf{u}^{n+1} = \\mathbf{u}^\\star - \\nabla \\Phi\n$$\nThis is a statement of the Helmholtz-Hodge decomposition, which states that any vector field $\\mathbf{u}^\\star$ can be uniquely decomposed into a divergence-free component ($\\mathbf{u}^{n+1}$) and a curl-free (gradient) component ($\\nabla \\Phi$).\n\nTo find the potential $\\Phi$, we enforce the incompressibility constraint on the final velocity field, $\\nabla \\cdot \\mathbf{u}^{n+1} = 0$. Applying the divergence operator to the correction equation, we get:\n$$\n\\nabla \\cdot \\mathbf{u}^{n+1} = \\nabla \\cdot \\mathbf{u}^\\star - \\nabla \\cdot (\\nabla \\Phi)\n$$\nSetting $\\nabla \\cdot \\mathbf{u}^{n+1} = 0$ leads to a Poisson equation for the scalar potential $\\Phi$:\n$$\n\\nabla^2 \\Phi = \\nabla \\cdot \\mathbf{u}^\\star\n$$\nSolving this equation for $\\Phi$ allows us to compute the gradient $\\nabla \\Phi$ and subsequently the final divergence-free velocity field $\\mathbf{u}^{n+1}$.\n\nFor the specified periodic domain $[0,1]^2$, spectral methods using the Discrete Fourier Transform (DFT) are exceptionally well-suited due to their high accuracy and the efficiency of the FFT algorithm. In Fourier space, differential operators become algebraic multiplication operators. A function $f(x,y)$ on the grid is transformed to its Fourier coefficients $\\hat{f}(k_x, k_y)$, where $k_x$ and $k_y$ are the wavenumbers. The derivative operators transform as:\n$$\n\\mathcal{F}\\left(\\frac{\\partial f}{\\partial x}\\right) = i k_x \\hat{f} \\quad \\text{and} \\quad \\mathcal{F}\\left(\\frac{\\partial f}{\\partial y}\\right) = i k_y \\hat{f}\n$$\nwhere $\\mathcal{F}$ denotes the Fourier transform.\n\nThe discrete wavenumbers for a domain of size $L_x=1$, $L_y=1$ with $N_x$ and $N_y$ points are given by $k_x = 2\\pi m$ and $k_y = 2\\pi n$ for integer modes $m$ and $n$. These are calculated using `scipy.fft.fftfreq`. Specifically, $k_x = 2\\pi \\times \\text{fftfreq}(N_x, 1/N_x)$ and $k_y = 2\\pi \\times \\text{fftfreq}(N_y, 1/N_y)$.\n\nApplying the Fourier transform to the Poisson equation $\\nabla^2 \\Phi = \\nabla \\cdot \\mathbf{u}^\\star$:\n$$\n\\mathcal{F}(\\nabla^2 \\Phi) = \\mathcal{F}(\\nabla \\cdot \\mathbf{u}^\\star)\n$$\nThe left-hand side becomes:\n$$\n\\mathcal{F}(\\nabla^2 \\Phi) = \\mathcal{F}\\left(\\frac{\\partial^2 \\Phi}{\\partial x^2} + \\frac{\\partial^2 \\Phi}{\\partial y^2}\\right) = ((ik_x)^2 + (ik_y)^2)\\hat{\\Phi} = -(k_x^2 + k_y^2)\\hat{\\Phi}\n$$\nThe right-hand side, the divergence of $\\mathbf{u}^\\star = (u^\\star, v^\\star)$, becomes:\n$$\n\\mathcal{F}(\\nabla \\cdot \\mathbf{u}^\\star) = \\mathcal{F}\\left(\\frac{\\partial u^\\star}{\\partial x} + \\frac{\\partial v^\\star}{\\partial y}\\right) = i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star\n$$\nCombining these yields the algebraic equation for $\\hat{\\Phi}$ in Fourier space:\n$$\n-(k_x^2 + k_y^2)\\hat{\\Phi} = i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star\n$$\nWe can solve for $\\hat{\\Phi}$:\n$$\n\\hat{\\Phi}(k_x, k_y) = - \\frac{i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star}{k_x^2 + k_y^2}\n$$\nA special case arises for the zero-wavenumber mode $(k_x, k_y) = (0,0)$, where the denominator $k_x^2+k_y^2$ is zero. This mode corresponds to the mean value of the fields. For this mode, the numerator is also zero, $i(0)\\hat{u}^\\star_{0,0} + i(0)\\hat{v}^\\star_{0,0} = 0$. This $0/0$ indeterminacy reflects that the potential $\\Phi$ is determined only up to an arbitrary constant. We can resolve this by setting $\\hat{\\Phi}(0,0) = 0$, which corresponds to choosing the unique potential with a zero spatial mean.\n\nOnce $\\hat{\\Phi}$ is known, we find the Fourier transform of the projected velocity $\\mathbf{u}^{n+1} = \\mathbf{u}^\\star - \\nabla \\Phi$:\n$$\n\\hat{u}^{n+1} = \\hat{u}^\\star - i k_x \\hat{\\Phi}\n$$\n$$\n\\hat{v}^{n+1} = \\hat{v}^\\star - i k_y \\hat{\\Phi}\n$$\nFinally, the real-space velocity field $\\mathbf{u}^{n+1}$ is recovered by applying the inverse Fourier transform $\\mathcal{F}^{-1}$.\n\nTo verify the result, we compute the discrete divergence of $\\mathbf{u}^{n+1}$ using the same spectral operator. In Fourier space, this is:\n$$\n\\widehat{\\nabla \\cdot \\mathbf{u}^{n+1}} = i k_x \\hat{u}^{n+1} + i k_y \\hat{v}^{n+1}\n$$\nSubstituting the expressions for $\\hat{u}^{n+1}$ and $\\hat{v}^{n+1}$:\n$$\n\\widehat{\\nabla \\cdot \\mathbf{u}^{n+1}} = i k_x (\\hat{u}^\\star - i k_x \\hat{\\Phi}) + i k_y (\\hat{v}^\\star - i k_y \\hat{\\Phi})\n= (i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star) - ( (ik_x)^2 + (ik_y)^2 ) \\hat{\\Phi}\n= (i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star) + (k_x^2 + k_y^2) \\hat{\\Phi}\n$$\nSubstituting the solution for $\\hat{\\Phi}$:\n$$\n= (i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star) + (k_x^2 + k_y^2) \\left( - \\frac{i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star}{k_x^2 + k_y^2} \\right) = 0\n$$\nThis holds for all $(k_x, k_y) \\neq (0,0)$. For $(k_x, k_y)=(0,0)$, all terms are zero. Thus, the divergence of the projected field is analytically zero in Fourier space. Its inverse transform will be zero up to floating-point rounding errors. The maximum absolute value of this field is the required output.",
            "answer": "```python\nimport numpy as np\nimport scipy.fft\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n\n    test_cases = [\n        {'Nx': 32, 'Ny': 32, 'case_type': 'grad_vort_noise', 'seed': 0},\n        {'Nx': 33, 'Ny': 17, 'case_type': 'noise_const', 'seed': 0},\n        {'Nx': 64, 'Ny': 64, 'case_type': 'pure_grad', 'seed': None},\n        {'Nx': 8, 'Ny': 8, 'case_type': 'pure_vort', 'seed': None},\n        {'Nx': 16, 'Ny': 24, 'case_type': 'pure_noise', 'seed': 42},\n    ]\n\n    results = []\n    for params in test_cases:\n        result = _solve_single_case(params)\n        results.append(result)\n\n    print(f\"[{','.join(f'{r:.16e}' for r in results)}]\")\n\ndef _solve_single_case(params):\n    \"\"\"\n    Solves a single test case for the projection problem.\n    \"\"\"\n    Nx = params['Nx']\n    Ny = params['Ny']\n    case_type = params['case_type']\n    seed = params['seed']\n    \n    # 1. Construct the grid\n    x = np.arange(Nx) / Nx\n    y = np.arange(Ny) / Ny\n    xx, yy = np.meshgrid(x, y, indexing='ij')\n\n    # 2. Construct the intermediate velocity field u_star\n    pi = np.pi\n    u_star, v_star = None, None\n    rng = np.random.default_rng(seed) if seed is not None else None\n\n    if case_type == 'grad_vort_noise':\n        # Case 1: Grad + Vort + Noise\n        psi = np.sin(2 * pi * xx) * np.cos(2 * pi * yy)\n        dpsi_dx = 2 * pi * np.cos(2 * pi * xx) * np.cos(2 * pi * yy)\n        dpsi_dy = -2 * pi * np.sin(2 * pi * xx) * np.sin(2 * pi * yy)\n\n        phi_vort = np.sin(2 * pi * xx) * np.sin(2 * pi * yy)\n        dphi_dx = 2 * pi * np.cos(2 * pi * xx) * np.sin(2 * pi * yy)\n        dphi_dy = 2 * pi * np.sin(2 * pi * xx) * np.cos(2 * pi * yy)\n        \n        eta_x = rng.standard_normal(size=(Nx, Ny))\n        eta_y = rng.standard_normal(size=(Nx, Ny))\n\n        u_star = dpsi_dx - dphi_dy + 0.1 * eta_x\n        v_star = dpsi_dy + dphi_dx + 0.1 * eta_y\n\n    elif case_type == 'noise_const':\n        # Case 2: Noise + Constant\n        c = (1.5, -0.75)\n        eta_x = rng.standard_normal(size=(Nx, Ny))\n        eta_y = rng.standard_normal(size=(Nx, Ny))\n        u_star = eta_x + c[0]\n        v_star = eta_y + c[1]\n\n    elif case_type == 'pure_grad':\n        # Case 3: Pure gradient field\n        psi = np.cos(4 * pi * xx) * np.sin(2 * pi * yy)\n        u_star = -4 * pi * np.sin(4 * pi * xx) * np.sin(2 * pi * yy)\n        v_star = 2 * pi * np.cos(4 * pi * xx) * np.cos(2 * pi * yy)\n\n    elif case_type == 'pure_vort':\n        # Case 4: Purely rotational (divergence-free) field\n        phi_vort = np.sin(2 * pi * xx) * np.sin(2 * pi * yy)\n        dphi_dx = 2 * pi * np.cos(2 * pi * xx) * np.sin(2 * pi * yy)\n        dphi_dy = 2 * pi * np.sin(2 * pi * xx) * np.cos(2 * pi * yy)\n        u_star = 3.0 * (-dphi_dy)\n        v_star = 3.0 * (dphi_dx)\n\n    elif case_type == 'pure_noise':\n        # Case 5: Pure noise\n        u_star = rng.standard_normal(size=(Nx, Ny))\n        v_star = rng.standard_normal(size=(Nx, Ny))\n    \n    # 3. Perform the projection\n    u_proj, v_proj = _project_velocity(u_star, v_star, Nx, Ny)\n\n    # 4. Compute the divergence of the projected field\n    divergence_field = _calculate_divergence(u_proj, v_proj, Nx, Ny)\n\n    # 5. Return the maximum absolute divergence\n    return np.max(np.abs(divergence_field))\n\ndef _project_velocity(u, v, Nx, Ny):\n    \"\"\"\n    Projects a velocity field (u, v) onto its divergence-free part.\n    \"\"\"\n    # Create wavenumber grids\n    kx_1d = 2 * np.pi * scipy.fft.fftfreq(Nx, d=1.0/Nx)\n    ky_1d = 2 * np.pi * scipy.fft.fftfreq(Ny, d=1.0/Ny)\n    kx, ky = np.meshgrid(kx_1d, ky_1d, indexing='ij')\n\n    # FFT of the velocity field\n    u_hat = scipy.fft.fft2(u)\n    v_hat = scipy.fft.fft2(v)\n\n    # Compute FFT of divergence of (u, v)\n    div_u_hat = 1j * kx * u_hat + 1j * ky * v_hat\n\n    # Solve Poisson equation for the potential phi in Fourier space\n    k_squared = kx**2 + ky**2\n    # Handle the k=0 mode to avoid division by zero\n    k_squared[0, 0] = 1.0  # Denominator is non-zero\n    \n    phi_hat = -div_u_hat / k_squared\n    # The numerator at k=0 is already zero, so this enforces phi_hat(0,0)=0\n\n    # Correct the velocity field in Fourier space\n    u_proj_hat = u_hat - 1j * kx * phi_hat\n    v_proj_hat = v_hat - 1j * ky * phi_hat\n\n    # Inverse FFT to get the projected velocity field in real space\n    u_proj = scipy.fft.ifft2(u_proj_hat).real\n    v_proj = scipy.fft.ifft2(v_proj_hat).real\n    \n    return u_proj, v_proj\n\ndef _calculate_divergence(u, v, Nx, Ny):\n    \"\"\"\n    Computes the divergence of a velocity field (u, v) using spectral methods.\n    \"\"\"\n    # Create wavenumber grids\n    kx_1d = 2 * np.pi * scipy.fft.fftfreq(Nx, d=1.0/Nx)\n    ky_1d = 2 * np.pi * scipy.fft.fftfreq(Ny, d=1.0/Ny)\n    kx, ky = np.meshgrid(kx_1d, ky_1d, indexing='ij')\n\n    # FFT of the velocity field\n    u_hat = scipy.fft.fft2(u)\n    v_hat = scipy.fft.fft2(v)\n\n    # Compute divergence in Fourier space\n    div_u_hat = 1j * kx * u_hat + 1j * ky * v_hat\n\n    # Inverse FFT to get divergence in real space\n    divergence = scipy.fft.ifft2(div_u_hat).real\n    \n    return divergence\n\nsolve()\n```"
        },
        {
            "introduction": "Building on the projection method for incompressible flows, this practice explores the more general case of variable-density fluids, a scenario common in multiphase or non-isothermal flows. A naive application of the standard pressure-Poisson equation fails in this context, leading to significant errors in mass conservation. This problem challenges you to derive the correct variable-coefficient elliptic equation for pressure, $\\nabla \\cdot (\\frac{1}{\\rho} \\nabla p)$, that consistently enforces the divergence constraint, revealing the mathematical rigor required to extend fundamental algorithms to more complex physical systems .",
            "id": "4082096",
            "problem": "Consider a variable-density, low-Mach-number complex fluid on a bounded domain with outward unit normal $\\boldsymbol{n}$ at solid walls. The mass conservation law is the continuity equation $\\partial_t \\rho + \\nabla \\cdot (\\rho \\boldsymbol{u}) = 0$, where $\\rho$ is density and $\\boldsymbol{u}$ is velocity. In projection-type time-stepping, an intermediate velocity $\\boldsymbol{u}^*$ is computed by advancing all non-pressure terms, and the pressure-based correction step seeks $\\boldsymbol{u}^{n+1}$ and $p^{n+1}$ such that $\\boldsymbol{u}^{n+1} = \\boldsymbol{u}^* - \\Delta t \\, \\frac{1}{\\rho^{n+1}} \\nabla p^{n+1}$. Let the divergence constraint at time $t^{n+1}$ be $\\nabla \\cdot \\boldsymbol{u}^{n+1} = g^{n+1}$, where $g^{n+1}$ is chosen to be consistent with the discrete update of $\\rho^{n+1}$ from $\\partial_t \\rho + \\nabla \\cdot (\\rho \\boldsymbol{u}) = 0$ (for strictly incompressible volume flow, $g^{n+1} = 0$; for quasi-incompressible mixtures or flows with sources, $g^{n+1} \\neq 0$ may arise).\n\nStarting from the mass conservation law and the correction relation for $\\boldsymbol{u}^{n+1}$, derive the elliptic equation that $p^{n+1}$ must satisfy so that the divergence constraint is enforced exactly when $\\rho$ varies spatially and temporally. Analyze the error in mass conservation induced by using a constant-coefficient Poisson equation that neglects density variability, and identify the appropriate boundary condition for $p^{n+1}$ at a solid wall where the normal component of velocity is prescribed, $\\boldsymbol{u}^{n+1} \\cdot \\boldsymbol{n} = u_n^{\\mathrm{bc}}$.\n\nSelect the option that provides a formulation and boundary condition that are consistent with the continuity equation and ensure exact enforcement of $\\nabla \\cdot \\boldsymbol{u}^{n+1} = g^{n+1}$ under variable density.\n\nA. Solve $\\nabla^2 p^{n+1} = \\frac{1}{\\Delta t} \\left( \\nabla \\cdot \\boldsymbol{u}^* - g^{n+1} \\right)$ and impose $\\frac{\\partial p^{n+1}}{\\partial n} = 0$ at solid walls.\n\nB. Solve $\\nabla \\cdot \\left( \\frac{\\Delta t}{\\rho^{n+1}} \\nabla p^{n+1} \\right) = \\nabla \\cdot \\boldsymbol{u}^* - g^{n+1}$ and impose $\\frac{\\partial p^{n+1}}{\\partial n} = \\rho^{n+1} \\frac{1}{\\Delta t} \\left( \\boldsymbol{u}^* \\cdot \\boldsymbol{n} - u_n^{\\mathrm{bc}} \\right)$ at solid walls where $\\boldsymbol{u}^{n+1} \\cdot \\boldsymbol{n} = u_n^{\\mathrm{bc}}$ is prescribed.\n\nC. Solve $\\nabla \\cdot \\left( \\Delta t \\, \\rho^{n+1} \\nabla p^{n+1} \\right) = \\nabla \\cdot \\boldsymbol{u}^* - g^{n+1}$ and impose any bounded $p^{n+1}$ at solid walls.\n\nD. Solve $\\frac{1}{\\rho^{n+1}} \\nabla^2 p^{n+1} = \\frac{1}{\\Delta t} \\left( \\nabla \\cdot \\boldsymbol{u}^* - g^{n+1} \\right)$ and impose $p^{n+1} = 0$ at solid walls.",
            "solution": "The problem requires deriving the correct form of the pressure-Poisson equation for a variable-density flow within a projection method framework, along with its appropriate boundary condition.\n\n**1. Derivation of the Pressure Equation**\n\nWe start with the two given relations:\n1.  The velocity update formula: $\\boldsymbol{u}^{n+1} = \\boldsymbol{u}^* - \\Delta t \\, \\frac{1}{\\rho^{n+1}} \\nabla p^{n+1}$\n2.  The divergence constraint at the new time step: $\\nabla \\cdot \\boldsymbol{u}^{n+1} = g^{n+1}$\n\nOur goal is to derive an equation for $p^{n+1}$. We can do this by taking the divergence of the velocity update equation and then substituting the divergence constraint.\n\nApplying the divergence operator to the velocity update equation gives:\n$$\n\\nabla \\cdot \\boldsymbol{u}^{n+1} = \\nabla \\cdot \\left( \\boldsymbol{u}^* - \\Delta t \\, \\frac{1}{\\rho^{n+1}} \\nabla p^{n+1} \\right)\n$$\nUsing the linearity of the divergence operator, we can separate the terms on the right-hand side:\n$$\n\\nabla \\cdot \\boldsymbol{u}^{n+1} = \\nabla \\cdot \\boldsymbol{u}^* - \\nabla \\cdot \\left( \\Delta t \\, \\frac{1}{\\rho^{n+1}} \\nabla p^{n+1} \\right)\n$$\nIn the last term, the density $\\rho^{n+1}$ is a spatially varying field, so it cannot be moved outside the divergence operator. The time step $\\Delta t$ is a scalar constant with respect to spatial derivatives, so it can be factored out.\n\nNow, we enforce the divergence constraint by substituting $\\nabla \\cdot \\boldsymbol{u}^{n+1} = g^{n+1}$ into the left-hand side:\n$$\ng^{n+1} = \\nabla \\cdot \\boldsymbol{u}^* - \\nabla \\cdot \\left( \\frac{\\Delta t}{\\rho^{n+1}} \\nabla p^{n+1} \\right)\n$$\nRearranging this equation to solve for the term involving pressure, we obtain the elliptic equation for $p^{n+1}$:\n$$\n\\nabla \\cdot \\left( \\frac{\\Delta t}{\\rho^{n+1}} \\nabla p^{n+1} \\right) = \\nabla \\cdot \\boldsymbol{u}^* - g^{n+1}\n$$\nThis is a variable-coefficient Poisson-type equation, where the coefficient of the Laplacian term is a function of density.\n\n**2. Derivation of the Pressure Boundary Condition**\n\nAt a solid wall, a boundary condition on the normal velocity is prescribed: $\\boldsymbol{u}^{n+1} \\cdot \\boldsymbol{n} = u_n^{\\mathrm{bc}}$. We can use this to derive the corresponding boundary condition for the pressure equation. We take the dot product of the velocity update equation with the outward unit normal vector $\\boldsymbol{n}$:\n$$\n\\boldsymbol{u}^{n+1} \\cdot \\boldsymbol{n} = \\left( \\boldsymbol{u}^* - \\Delta t \\, \\frac{1}{\\rho^{n+1}} \\nabla p^{n+1} \\right) \\cdot \\boldsymbol{n}\n$$\nDistributing the dot product gives:\n$$\n\\boldsymbol{u}^{n+1} \\cdot \\boldsymbol{n} = \\boldsymbol{u}^* \\cdot \\boldsymbol{n} - \\frac{\\Delta t}{\\rho^{n+1}} (\\nabla p^{n+1} \\cdot \\boldsymbol{n})\n$$\nThe term $\\nabla p^{n+1} \\cdot \\boldsymbol{n}$ is the definition of the normal derivative of pressure, which can be written as $\\frac{\\partial p^{n+1}}{\\partial n}$. Substituting this and the prescribed normal velocity boundary condition into the equation yields:\n$$\nu_n^{\\mathrm{bc}} = \\boldsymbol{u}^* \\cdot \\boldsymbol{n} - \\frac{\\Delta t}{\\rho^{n+1}} \\frac{\\partial p^{n+1}}{\\partial n}\n$$\nNow, we rearrange this equation to solve for the normal derivative of pressure, $\\frac{\\partial p^{n+1}}{\\partial n}$:\n$$\n\\frac{\\Delta t}{\\rho^{n+1}} \\frac{\\partial p^{n+1}}{\\partial n} = \\boldsymbol{u}^* \\cdot \\boldsymbol{n} - u_n^{\\mathrm{bc}}\n$$\n$$\n\\frac{\\partial p^{n+1}}{\\partial n} = \\frac{\\rho^{n+1}}{\\Delta t} \\left( \\boldsymbol{u}^* \\cdot \\boldsymbol{n} - u_n^{\\mathrm{bc}} \\right)\n$$\nThis is a Neumann boundary condition for the pressure, which is required to enforce the kinematic velocity condition at the wall.\n\n**3. Evaluating the Options**\n\n*   **A:** This option uses a constant-coefficient Poisson equation ($\\nabla^2 p^{n+1}$), which is incorrect for variable density. The boundary condition is also incorrect.\n*   **B:** The elliptic equation $\\nabla \\cdot \\left( \\frac{\\Delta t}{\\rho^{n+1}} \\nabla p^{n+1} \\right) = \\nabla \\cdot \\boldsymbol{u}^* - g^{n+1}$ and the Neumann boundary condition $\\frac{\\partial p^{n+1}}{\\partial n} = \\rho^{n+1} \\frac{1}{\\Delta t} \\left( \\boldsymbol{u}^* \\cdot \\boldsymbol{n} - u_n^{\\mathrm{bc}} \\right)$ both perfectly match our derivations.\n*   **C:** The coefficient in the elliptic equation is $\\Delta t \\, \\rho^{n+1}$ instead of $\\frac{\\Delta t}{\\rho^{n+1}}$, which is incorrect. The boundary condition is also ill-defined.\n*   **D:** This option results from incorrectly factoring $1/\\rho^{n+1}$ out of the divergence, which is only valid for constant density. The Dirichlet boundary condition is also incorrect for enforcing a normal velocity constraint.\n\nTherefore, option B is the only one that presents both the correct elliptic equation and the consistent boundary condition for the variable-density projection method.",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}