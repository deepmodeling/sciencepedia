{
    "hands_on_practices": [
        {
            "introduction": "本节的第一个实践练习旨在通过一个具体的计算例子，揭示守恒与非守恒数值格式之间的本质区别。我们将通过一个简单的一维平流问题，展示一个看似合理的数值方法（半拉格朗日法）如何导致非物理的质量损失。这个练习将突显出，在模拟物理守恒律时，离散方程的数学形式至关重要。",
            "id": "4082100",
            "problem": "考虑一个长度为 $L$ 的一维周期性域，其空间坐标为 $x \\in [0,L)$。一个标量密度场 $\\rho(x,t)$ 被一个给定的、不随时间变化的速度场 $u(x)$ 平流，遵循连续性方程（质量守恒）：\n$$\n\\frac{\\partial \\rho}{\\partial t} + \\frac{\\partial}{\\partial x}(\\rho u) = 0,\n$$\n并采用周期性边界条件。所有量均为无量纲，不需要物理单位。\n\n您的任务是通过计算示例来证明，使用非守恒格式平流密度会导致总质量的人为损失（或增加），并测量此质量误差如何随网格细化而变化。请使用以下在数学和计算上均适定的设置：\n\n- 域长度 $L = 1$。\n- 速度场 $u(x) = \\tfrac{1}{2} + \\tfrac{1}{2}\\sin(2\\pi x)$，该速度场严格为正且随空间变化。\n- 初始密度\n$$\n\\rho(x,0) = 1 + 0.3\\sin(2\\pi x) + 0.8\\exp\\!\\left(-\\frac{(x-0.3)^2}{0.01}\\right),\n$$\n该密度严格为正且平滑。\n- 总模拟时间 $T = 1$。\n- 库朗-弗里德里希斯-列维（Courant–Friedrichs–Lewy, CFL）数 $\\mathrm{CFL} = 0.4$，用于选择名义时间步长 $\\Delta t = \\mathrm{CFL}\\,\\Delta x / \\max_x u(x)$，其中 $\\Delta x = L/N$ 且 $N$ 是网格点数。重复使用 $\\Delta t$ 进行尽可能多的完整步数以填充时间 $T$，然后用剩余时间进行最后一步，以精确达到 $T$。\n\n在一个具有 $N$ 个点的均匀网格上，使用周期性边界条件，实现并比较两种时间步进格式：\n\n1. 一种非守恒的半拉格朗日点态平流格式，在固定的欧拉网格上采用一阶回溯和线性插值。对于每个网格点 $x_i$，计算回溯足点 $x_i^{\\star} = x_i - u(x_i)\\,\\Delta t$（周期性回绕），并通过在 $x_i^{\\star}$ 处对 $\\rho^n$ 进行线性插值来更新 $\\rho_i^{n+1}$。\n\n2. 一种守恒的有限体积迎风通量格式，以通量散度形式表示。将单元交界面 $x_{i+1/2}$ 处的通量离散为 $F_{i+1/2} = u(x_{i+1/2})\\,\\rho_i$（对于 $u(x_{i+1/2}) > 0$，此条件在此成立），并通过通量差 $\\rho_i^{n+1} = \\rho_i^n - (\\Delta t/\\Delta x)\\left(F_{i+1/2} - F_{i-1/2}\\right)$ 更新单元平均值。\n\n对于每个 $N$，计算由黎曼和 $M_0 \\approx \\sum_i \\rho_i^0\\,\\Delta x$ 近似的初始总质量 $M_0$，以及分别由非守恒格式和守恒格式产生的最终总质量 $M_{\\mathrm{nc}}(T)$ 和 $M_{\\mathrm{cons}}(T)$。将每个格式的相对质量误差定义为 $e_{\\mathrm{nc}} = \\lvert M_{\\mathrm{nc}}(T) - M_0 \\rvert / M_0$ 和 $e_{\\mathrm{cons}} = \\lvert M_{\\mathrm{cons}}(T) - M_0 \\rvert / M_0$，以小数形式表示。\n\n测试套件：\n- 使用网格大小 $N \\in \\{50, 100, 200, 400, 800\\}$。\n- 对于每个 $N$，计算 $e_{\\mathrm{nc}}$ 和 $e_{\\mathrm{cons}}$。\n- 通过在整个测试套件中对 $\\log(e_{\\mathrm{nc}})$ 与 $\\log(\\Delta x)$ 的关系进行直线拟合，估算非守恒格式的经验误差缩放指数 $q$，使得 $e_{\\mathrm{nc}} \\approx C\\,(\\Delta x)^q$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按以下顺序排列结果：\n$$\n[ e_{\\mathrm{nc}}(N{=}50), e_{\\mathrm{nc}}(N{=}100), e_{\\mathrm{nc}}(N{=}200), e_{\\mathrm{nc}}(N{=}400), e_{\\mathrm{nc}}(N{=}800), q, \\max\\{ e_{\\mathrm{cons}}(N) : N \\in \\{50,100,200,400,800\\} \\} ].\n$$\n所有条目都必须是十进制数（浮点数）。此单行输出是程序唯一要求的输出。",
            "solution": "该问题要求通过计算来展示，对于一维连续性方程，非守恒数值格式会导致质量守恒失效，而守恒格式则具有质量守恒性质。我们将实现并比较两种指定的格式，计算在一系列网格分辨率下的质量守恒误差，并确定非守恒格式的误差随网格间距变化的经验性缩放规律。\n\n控制方程是一维连续性方程，它表示标量 $\\rho$（密度）被速度场 $u$ 输运过程中的守恒：\n$$\n\\frac{\\partial \\rho}{\\partial t} + \\frac{\\partial}{\\partial x}(\\rho u) = 0\n$$\n这被称为守恒形式，因为空间导数作用于通量 $F = \\rho u$。这种形式的一个关键性质是，在封闭或周期性域中，总质量 $M = \\int \\rho \\, dx$ 不随时间变化。这可以通过将方程在域 $[0,L]$ 上积分看出：\n$$\n\\frac{dM}{dt} = \\frac{d}{dt}\\int_0^L \\rho \\, dx = -\\int_0^L \\frac{\\partial}{\\partial x}(\\rho u) \\, dx = -[\\rho u]_0^L = 0\n$$\n最后的等式因周期性边界条件（即 $\\rho(0,t)u(0) = \\rho(L,t)u(L)$）而成立。直接对此通量散度形式进行离散化的数值格式称为“守恒格式”，并期望其能将离散总质量保持在机器精度范围内。\n\n使用乘法法则，连续性方程可以改写为非守恒形式或平流形式：\n$$\n\\frac{\\partial \\rho}{\\partial t} + u \\frac{\\partial \\rho}{\\partial x} + \\rho \\frac{\\partial u}{\\partial x} = 0\n$$\n当速度场 $u(x)$ 随空间变化时，近似简化版本（如简单平流方程 $\\frac{\\partial \\rho}{\\partial t} + u \\frac{\\partial \\rho}{\\partial x} = 0$）的数值格式被称为“非守恒的”。这些格式未能考虑 $\\rho \\frac{\\partial u}{\\partial x}$ 项，该项代表了由于速度场的汇聚或发散引起的密度变化。这种省略会导致人为的质量源或汇，使得总质量随时间漂移。\n\n我们将在一个具有 $N$ 个点、空间分辨率为 $\\Delta x = L/N$、单元中心坐标为 $x_i = i \\Delta x$（其中 $i=0, \\dots, N-1$）的均匀网格上建立一个数值实验。时间步长 $\\Delta t$ 由CFL条件决定，即 $\\Delta t = \\mathrm{CFL} \\cdot \\Delta x / \\max_x |u(x)|$。当 $L=1$，$\\mathrm{CFL}=0.4$，且 $u(x) = \\frac{1}{2} + \\frac{1}{2}\\sin(2\\pi x)$ 时，我们发现 $\\max_x u(x) = 1$，因此 $\\Delta t = 0.4 \\Delta x$。总模拟时间 $T=1$ 由一系列时间步长覆盖。\n\n**1. 非守恒半拉格朗日格式**\n此方法基于流体运动的拉格朗日视角。方程 $\\frac{D\\rho}{Dt} = \\frac{\\partial \\rho}{\\partial t} + u \\frac{\\partial \\rho}{\\partial x} = 0$ 意味着 $\\rho$ 沿着由 $\\frac{dx}{dt} = u$ 定义的特征线是常数。为了将固定欧拉网格点 $x_i$ 上的密度从时间 $t^n$ 更新到 $t^{n+1} = t^n + \\Delta t$，我们沿特征线回溯时间，找到在时间 $t^n$ 的出发点 $x_i^\\star$。一阶近似给出：\n$$\nx_i^\\star = x_i - u(x_i) \\Delta t\n$$\n$x_i$ 处的新密度就是出发点的密度，即 $\\rho_i^{n+1} = \\rho^n(x_i^\\star)$。由于 $x_i^\\star$ 通常不会与网格点重合，这个值必须通过插值已知的 $\\rho^n$ 网格值来找到。问题指定使用线性插值。$\\rho_i^{n+1}$ 的值是通过找到包含周期性回绕坐标 $x_i^\\star$ 的两个网格点 $x_j$ 和 $x_{j+1}$，并对 $\\rho_j^n$ 和 $\\rho_{j+1}^n$ 进行线性插值来计算的。这个插值步骤不保证总质量守恒，这些小误差的累积会导致总质量随时间发生显著漂移。\n\n**2. 守恒有限体积迎风格式**\n该格式从守恒律在每个网格单元（控制体积） $[x_{i-1/2}, x_{i+1/2}]$ 上的积分形式开始，其中 $x_{i\\pm1/2} = x_i \\pm \\Delta x/2$。\n$$\n\\frac{d}{dt} \\int_{x_{i-1/2}}^{x_{i+1/2}} \\rho \\, dx = (\\rho u)|_{x_{i-1/2}} - (\\rho u)|_{x_{i+1/2}}\n$$\n通过近似单元平均密度 $\\rho_i \\approx \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} \\rho \\, dx$ 并使用向前欧拉时间步，我们得到离散化的通量散度形式：\n$$\n\\rho_i^{n+1} = \\rho_i^n - \\frac{\\Delta t}{\\Delta x} (F_{i+1/2} - F_{i-1/2})\n$$\n其中 $F_{i\\pm1/2}$ 是单元交界面上的数值通量。对于一阶迎风格式，通量由“迎风”单元中的状态决定。由于给定的速度场对所有 $x$ 都满足 $u(x) \\geq 0$，流动方向总是从左到右（或静止）。因此，任何界面上的状态都由其左侧的单元决定：\n$$\nF_{i+1/2} = u(x_{i+1/2}) \\rho_i^n\n$$\n当我们将更新规则对所有单元 $i=0, \\dots, N-1$ 求和时，通量差形成一个伸缩求和：$\\sum_i (F_{i+1/2} - F_{i-1/2})$。由于周期性（$F_{-1/2} = F_{N-1/2}$），这个和正好为零。因此，$\\sum_i \\rho_i^{n+1} = \\sum_i \\rho_i^n$，离散总质量 $M = \\sum_i \\rho_i \\Delta x$ 在浮点运算的精度范围内是守恒的。\n\n**3. 误差分析**\n对于每个网格大小 $N$，我们计算初始质量 $M_0 = \\sum_i \\rho(x_i, 0) \\Delta x$ 和最终质量 $M_{\\mathrm{nc}}(T)$ 与 $M_{\\mathrm{cons}}(T)$。相对质量误差 $e_{\\mathrm{nc}} = |M_{\\mathrm{nc}}(T) - M_0| / M_0$ 和 $e_{\\mathrm{cons}} = |M_{\\mathrm{cons}}(T) - M_0| / M_0$ 被计算出来。我们预期 $e_{\\mathrm{cons}}$ 会接近机器精度，而 $e_{\\mathrm{nc}}$ 会比较显著，并应随着网格的细化而减小。\n为了找到非守恒格式质量误差的经验收敛阶 $q$，我们假设一个幂律关系 $e_{\\mathrm{nc}} \\approx C (\\Delta x)^q$，其中 $C$ 是一个常数。取对数得到一个线性关系：\n$$\n\\log(e_{\\mathrm{nc}}) \\approx \\log(C) + q \\log(\\Delta x)\n$$\n通过对给定的一系列网格大小 $N$ 所计算出的 $\\log(e_{\\mathrm{nc}})$ 对 $\\log(\\Delta x)$ 进行线性回归，最佳拟合线的斜率提供了对缩放指数 $q$ 的估计。\n\n实现将遵循这些原则，对指定的 $N$ 范围进行模拟，计算误差，并对 $q$ 进行拟合。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D advection problem using non-conservative and conservative schemes,\n    computes mass errors, and determines the error scaling for the non-conservative scheme.\n    \"\"\"\n    # Problem parameters\n    L = 1.0\n    T = 1.0\n    CFL = 0.4\n    TEST_CASES_N = [50, 100, 200, 400, 800]\n\n    # Field definitions\n    def u_field(x):\n        return 0.5 + 0.5 * np.sin(2 * np.pi * x / L)\n\n    def rho_initial(x):\n        return 1.0 + 0.3 * np.sin(2 * np.pi * x / L) + 0.8 * np.exp(-((x - 0.3*L)**2) / 0.01)\n\n    e_nc_results = []\n    e_cons_results = []\n\n    for N in TEST_CASES_N:\n        # ---- 1. Grid and Initial Conditions Setup ----\n        dx = L / N\n        # Cell-centered grid\n        x_nodes = np.arange(N) * dx\n        \n        # Initial density at cell centers\n        rho0 = rho_initial(x_nodes)\n        \n        # Initial total mass\n        m0 = np.sum(rho0) * dx\n\n        # ---- 2. Time-stepping Setup ----\n        u_max = 1.0  # Max of u_field is 0.5 + 0.5*1 = 1.0\n        dt = CFL * dx / u_max\n        \n        num_steps = int(T / dt)\n        last_dt = T - num_steps * dt\n        \n        timesteps = [dt] * num_steps\n        if last_dt > 1e-12:  # Add final smaller step if needed\n            timesteps.append(last_dt)\n\n        # ---- 3. Simulation Loop ----\n        # Initialize densities for both schemes\n        rho_nc = rho0.copy()\n        rho_cons = rho0.copy()\n\n        # Pre-compute velocities for efficiency\n        # Velocities at cell centers (for non-conservative scheme)\n        u_nodes = u_field(x_nodes)\n        # Velocities at cell faces (for conservative scheme)\n        x_faces = (np.arange(N) + 0.5) * dx\n        u_faces = u_field(x_faces)\n\n        for t_step in timesteps:\n            # --- Update Non-Conservative (Semi-Lagrangian) Scheme ---\n            # Compute departure points\n            x_star = x_nodes - u_nodes * t_step\n            # Linearly interpolate to find new density. np.interp handles periodicity.\n            rho_nc = np.interp(x_star, x_nodes, rho_nc, period=L)\n\n            # --- Update Conservative (Finite-Volume Upwind) Scheme ---\n            # Flux at right face of each cell i (F_{i+1/2})\n            # Upwind flux uses rho_i since u >= 0\n            flux_right = u_faces * rho_cons\n            # Flux at left face of each cell i (F_{i-1/2})\n            flux_left = np.roll(flux_right, 1) # Get F_{i-1/2} by rolling F_{j+1/2}\n            \n            # Update cell average density\n            rho_cons -= (t_step / dx) * (flux_right - flux_left)\n\n        # ---- 4. Post-processing for this N ----\n        # Final total mass\n        m_nc_final = np.sum(rho_nc) * dx\n        m_cons_final = np.sum(rho_cons) * dx\n\n        # Relative mass error\n        e_nc = np.abs(m_nc_final - m0) / m0\n        e_cons = np.abs(m_cons_final - m0) / m0\n\n        e_nc_results.append(e_nc)\n        e_cons_results.append(e_cons)\n\n    # ---- 5. Empirical Error Scaling Analysis ----\n    dx_values = L / np.array(TEST_CASES_N)\n    log_dx = np.log(dx_values)\n    log_e_nc = np.log(np.array(e_nc_results))\n    \n    # Fit log(error) vs log(dx) to a line y = mx + c. The slope m is the order q.\n    q_exponent, _ = np.polyfit(log_dx, log_e_nc, 1)\n\n    # Get the maximum error for the conservative scheme\n    max_e_cons = np.max(e_cons_results)\n\n    # ---- 6. Final Output ----\n    final_results = e_nc_results + [q_exponent, max_e_cons]\n    \n    # Format the numbers to a reasonable precision for consistent output\n    formatted_results = [f\"{val:.10f}\" for val in final_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        },
        {
            "introduction": "在理解了守恒格式的重要性之后，接下来的实践将聚焦于如何构建一个确保质量守恒的数值方案。我们将运用广泛使用的有限体积法（FVM），为单元交界面上的密度实现一个经典的保守插值方案——迎风格式。通过这个练习，你将从理论上证明并从数值上验证，正确的通量定义如何确保离散系统中的总质量得到精确守恒。",
            "id": "4082087",
            "problem": "考虑一个由质量密度场 $\\rho(\\mathbf{x},t)$ 和速度场 $\\mathbf{u}(\\mathbf{x},t)$ 描述的连续介质的质量守恒。在一个边界为 $\\partial V$ 的固定控制体 $V$ 上，质量守恒的积分形式为\n$$\n\\frac{d}{dt}\\int_V \\rho \\, dV + \\int_{\\partial V} \\rho \\, \\mathbf{u}\\cdot\\mathbf{n}\\, dA = 0,\n$$\n其中 $\\mathbf{n}$ 是 $\\partial V$ 上的外向单位法向量。在有限体积法 (FVM) 中，我们将域划分为多个控制体，并将通量积分近似为在各个单元面上的求和。在同位网格布置中，$\\rho$ 和 $\\mathbf{u}$ 存储在单元中心，而面上的物理量则通过插值获得。\n\n您的任务是，在一个均匀、周期性的二维笛卡尔同位网格 FVM 中，为密度 $\\rho$ 实现一个能够避免棋盘格现象的保守面插值格式，并证明离散连续性方程在此意义下是精确的：即共享面上的通量在相邻单元之间成对抵消。\n\n使用以下背景和定义：\n\n- 设域为 $[0,L_x]\\times[0,L_y]$，其中 $L_x=L_y=1$。考虑一个在 $x$ 方向有 $N_x$ 个单元、在 $y$ 方向有 $N_y$ 个单元的均匀网格。单元中心位于 $(x_i,y_j)$，间距为 $\\Delta x = L_x/N_x$ 和 $\\Delta y = L_y/N_y$。\n- 对于每个单元 $(i,j)$，其体积记为 $V_{ij} = \\Delta x \\Delta y$，其面集记为 $\\partial (i,j)$。对于位于“左”单元 $L$ 和“右”单元 $R$ 之间的每个面 $f$，将面法向速度定义为 $u_f = \\mathbf{u}_f \\cdot \\mathbf{n}_f$，面面积定义为 $A_f$。面质量通量为 $F_f = u_f A_f$。在笛卡尔网格上，垂直面的 $A_f$ 等于 $\\Delta y$，水平面的 $A_f$ 等于 $\\Delta x$。周期性边界条件将域边界上的面对应起来，确保每个面都恰好由两个单元共享。\n- 单元 $(i,j)$ 的离散连续性方程为\n$$\n\\frac{d}{dt} \\left( \\rho_{ij} V_{ij} \\right) + \\sum_{f \\in \\partial (i,j)} F_f \\, \\rho_f = 0,\n$$\n其中 $\\rho_f$ 是在面 $f$ 上计算的密度。\n\n您必须：\n\n1. 为 $\\rho_f$ 实现一个保守且能通过使用质量通量迎风格式来避免棋盘格现象的面插值：\n$$\n\\rho_f =\n\\begin{cases}\n\\rho_L, & F_f \\ge 0, \\\\\n\\rho_R, & F_f < 0,\n\\end{cases}\n$$\n并约定当 $F_f=0$ 时，您可以使用有界算术平均 $\\rho_f = \\tfrac{1}{2}(\\rho_L+\\rho_R)$。此处 $\\rho_L$ 和 $\\rho_R$ 分别是沿外法向 $\\mathbf{n}_f$ 方向位于面 $f$ 左侧和右侧单元的中心密度。\n2. 使用速度场的解析表达式直接在面中心 $(x_f,y_f)$ 计算面法向速度 $\\mathbf{u}_f$，即 $u_f = \\mathbf{u}(x_f,y_f)\\cdot \\mathbf{n}_f$。这可以避免额外的速度插值伪影，并将测试重点放在密度面插值上。\n3. 在您的解法中，从质量守恒的积分形式出发，证明对于上述 $\\rho_f$ 的选择，离散连续性陈述是精确的，即穿过任意共享内部面 $f$ 的质量通量对于相邻单元 $L$ 和 $R$ 来说是大小相等、方向相反的，因此在对所有单元求和时，内部贡献会完全抵消；并且在周期性边界条件下，全局离散质量变化恒为零。\n\n需要使用的数值实现细节：\n\n- 将单元中心坐标定义为 $x_i = (i+\\tfrac{1}{2})\\Delta x$（其中 $i=0,\\dots,N_x-1$）和 $y_j = (j+\\tfrac{1}{2})\\Delta y$（其中 $j=0,\\dots,N_y-1$）。\n- 将垂直面（位于 $(i,j)$ 和 $(i+1,j)$ 之间）的面中心坐标定义为 $x_{i+\\tfrac{1}{2}} = \\tfrac{1}{2}(x_i+x_{i+1})$ 和 $y_j$，将水平面（位于 $(i,j)$ 和 $(i,j+1)$ 之间）的面中心坐标定义为 $x_i$ 和 $y_{j+\\tfrac{1}{2}} = \\tfrac{1}{2}(y_j+y_{j+1})$。\n- 必须使用周期性索引：索引循环，使得当 $i=N_x-1$ 时，$i+1$ 映射到 $0$；当 $j=N_y-1$ 时，$j+1$ 映射到 $0$。\n\n设计程序以计算并报告每个测试案例的以下内容：\n\n- 离散连续性方程的全局残差，定义为\n$$\nr_{\\text{global}} = \\left| \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\left( \\sum_{f \\in \\partial (i,j)} F_f \\rho_f \\right) \\right|,\n$$\n当面通量被一致共享时，对于周期性边界，该值必须为 $0$。\n- 最大共享面不匹配度，定义为在所有面 $f$ 上，由左侧单元报告的外向质量通量与由右侧单元报告的穿过同一面的外向质量通量之和的绝对值的最大值。对于保守的面插值，所有内部面的该值必须恒为 $0$：\n$$\nr_{\\text{mismatch}} = \\max_{f} \\left| (F_f \\rho_f)_{\\text{left,out}} + (F_f \\rho_f)_{\\text{right,out}} \\right|.\n$$\n- 使用大小为 $\\Delta t$ 的前向欧拉步对单元质量进行一次显式更新后的全局质量变化，定义为\n$$\nr_{\\text{mass\\_change}} = \\left| \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\left( \\rho_{ij}^{n+1} - \\rho_{ij}^{n} \\right) V_{ij} \\right|,\n$$\n其中\n$$\n\\rho_{ij}^{n+1} = \\rho_{ij}^{n} - \\frac{\\Delta t}{V_{ij}} \\sum_{f \\in \\partial (i,j)} F_f \\rho_f.\n$$\n在周期性边界和共享面守恒的条件下，$r_{\\text{mass\\_change}}$ 必须为 $0$。\n\n本问题中所有量均为无量纲量，因此不需要单位。\n\n测试套件：\n\n- 案例1（“光滑，无散度”）：$N_x=16$, $N_y=16$, $\\Delta t = 10^{-3}$。密度场和速度场：\n$$\n\\rho(x,y) = 1 + 0.2 \\sin(2\\pi x)\\cos(2\\pi y), \\quad\nu_x(x,y) = \\sin(2\\pi y), \\quad\nu_y(x,y) = \\sin(2\\pi x).\n$$\n- 案例2（“零速度，随机密度”）：$N_x=16$, $N_y=16$, $\\Delta t = 10^{-3}$。密度：\n$$\n\\rho(x,y) \\text{ 是一个种子为 42 的固定伪随机场},\n$$\n速度为\n$$\nu_x(x,y) = 0, \\quad u_y(x,y) = 0.\n$$\n- 案例3（“可压缩，光滑”）：$N_x=31$, $N_y=17$, $\\Delta t = 5\\times 10^{-4}$。密度场和速度场：\n$$\n\\rho(x,y) = \\exp\\left(0.3\\sin(2\\pi x) + 0.3\\cos(2\\pi y)\\right), \\quad\nu_x(x,y) = \\cos(2\\pi y) + \\sin(4\\pi x), \\quad\nu_y(x,y) = \\sin(2\\pi x) - \\cos(4\\pi y).\n$$\n- 案例4（“线性场，可压缩”）：$N_x=8$, $N_y=12$, $\\Delta t = 2\\times 10^{-3}$。密度场和速度场：\n$$\n\\rho(x,y) = 0.5 + x, \\quad\nu_x(x,y) = y, \\quad\nu_y(x,y) = -x.\n$$\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起，顺序如下\n$$\n[ r_{\\text{global}}^{(1)}, r_{\\text{mismatch}}^{(1)}, r_{\\text{mass\\_change}}^{(1)}, r_{\\text{global}}^{(2)}, r_{\\text{mismatch}}^{(2)}, r_{\\text{mass\\_change}}^{(2)}, r_{\\text{global}}^{(3)}, r_{\\text{mismatch}}^{(3)}, r_{\\text{mass\\_change}}^{(3)}, r_{\\text{global}}^{(4)}, r_{\\text{mismatch}}^{(4)}, r_{\\text{mass\\_change}}^{(4)} ].\n$$\n每个条目必须是浮点数。程序必须是完全自包含的，并且不得从用户读取输入。",
            "solution": "该问题要求在周期性二维笛卡尔网格上，实现并验证质量守恒方程的保守有限体积离散化。任务的核心是证明，一种基于迎风格式的面密度插值方案能够实现离散守恒，即共享面上的通量完全抵消，并且总质量随时间守恒。\n\n首先，我们必须按要求从理论上证明所选的数值方案是保守的。\n\n### 离散守恒的理论证明\n\n对于一个固定控制体 $V$，质量守恒定律的积分形式为：\n$$\n\\frac{d}{dt}\\int_V \\rho \\, dV + \\int_{\\partial V} \\rho \\, \\mathbf{u}\\cdot\\mathbf{n}\\, dA = 0\n$$\n在有限体积法（FVM）中，我们将此定律应用于每个网格单元（控制体）$V_{ij}$。对于一个此处用索引 $P$ 表示的单元，其半离散方程为：\n$$\n\\frac{d}{dt} \\left( \\rho_P V_P \\right) + \\sum_{f \\in \\partial P} (\\dot{m}_f)_{\\text{out}} = 0\n$$\n其中 $\\rho_P$ 是单元平均密度，$V_P$ 是单元体积，$(\\dot{m}_f)_{\\text{out}}$ 是通过面 $f$ 离开单元 $P$ 的质量通量。这个外向质量通量由 $(\\dot{m}_f)_{\\text{out}} = \\rho_f F_f$ 给出，其中 $F_f = (\\mathbf{u}_f \\cdot \\mathbf{n}_f) A_f$ 是通过该面的体积通量，而 $\\mathbf{n}_f$ 是从单元 $P$ 指出的外向法向量。\n\n离散守恒的关键在于确保，穿过一个共享面离开一个单元的通量，与穿过同一个面离开相邻单元的通量大小相等、方向相反。换句话说，进入邻近单元的通量必须与离开第一个单元的通量完全相同。让我们考虑两个共享一个公共面 $f$ 的相邻单元 $L$（“左”）和 $R$（“右”）。我们定义面 $f$ 上的法向量 $\\mathbf{n}_f$ 指向从单元 $L$ 到单元 $R$ 的方向。\n\n1.  **从单元 L 的角度看通量：**\n    从单元 $L$ 在面 $f$ 处的外向法向量是 $\\mathbf{n}_f$。体积通量为 $F_f = (\\mathbf{u}_f \\cdot \\mathbf{n}_f) A_f$。通过面 $f$ 流出单元 $L$ 的质量通量为：\n    $$ (\\dot{m}_f)_{\\text{out}, L} = \\rho_f F_f $$\n    问题指定了面密度 $\\rho_f$ 的迎风格式：\n    $$\n    \\rho_f =\n    \\begin{cases}\n    \\rho_L, & \\text{如果 } F_f \\ge 0 \\quad (\\text{流动方向从 L 到 R}) \\\\\n    \\rho_R, & \\text{如果 } F_f < 0 \\quad (\\text{流动方向从 R 到 L})\n    \\end{cases}\n    $$\n    此处，$\\rho_L$ 和 $\\rho_R$ 分别是单元 $L$ 和 $R$ 中的单元中心密度。\n\n2.  **从单元 R 的角度看通量：**\n    从单元 $R$ 在面 $f$ 处的外向法向量是 $-\\mathbf{n}_f$。\n    从 $R$ 的角度来看，体积通量为 $F'_f = (\\mathbf{u}_f \\cdot (-\\mathbf{n}_f)) A_f = -F_f$。\n    为了找到通过面 $f$ 流出单元 $R$ 的质量通量 $(\\dot{m}_f)_{\\text{out}, R}$，我们必须从 $R$ 的角度应用迎风格式。对于单元 $R$，其穿过面 $f$ 的邻居是单元 $L$。在其外向法向量 $-\\mathbf{n}_f$ 方向上的“左”单元是 $R$，“右”单元是 $L$。面密度 $\\rho'_f$ 为：\n    $$\n    \\rho'_f =\n    \\begin{cases}\n    \\rho_R, & \\text{如果 } F'_f \\ge 0 \\implies -F_f \\ge 0 \\implies F_f \\le 0 \\\\\n    \\rho_L, & \\text{如果 } F'_f < 0 \\implies -F_f < 0 \\implies F_f > 0\n    \\end{cases}\n    $$\n    流出 $R$ 的质量通量是 $(\\dot{m}_f)_{\\text{out}, R} = \\rho'_f F'_f = \\rho'_f (-F_f)$。\n\n3.  **面上守恒性的验证：**\n    我们必须证明，穿过共享面的两个单元的外向通量之和为零：$(\\dot{m}_f)_{\\text{out}, L} + (\\dot{m}_f)_{\\text{out}, R} = 0$。\n    *   **情况 i：$F_f > 0$。**流动方向从 $L$ 到 $R$。\n        $$ (\\dot{m}_f)_{\\text{out}, L} = \\rho_L F_f $$\n        $$ (\\dot{m}_f)_{\\text{out}, R} = \\rho'_f (-F_f) = \\rho_L (-F_f) = - \\rho_L F_f $$\n        和为 $(\\dot{m}_f)_{\\text{out}, L} + (\\dot{m}_f)_{\\text{out}, R} = \\rho_L F_f - \\rho_L F_f = 0$。守恒成立。\n    *   **情况 ii：$F_f < 0$。**流动方向从 $R$ 到 $L$。\n        $$ (\\dot{m}_f)_{\\text{out}, L} = \\rho_R F_f $$\n        $$ (\\dot{m}_f)_{\\text{out}, R} = \\rho'_f (-F_f) = \\rho_R (-F_f) = - \\rho_R F_f $$\n        和为 $(\\dot{m}_f)_{\\text{out}, L} + (\\dot{m}_f)_{\\text{out}, R} = \\rho_R F_f - \\rho_R F_f = 0$。守恒成立。\n    *   **情况 iii：$F_f = 0$。**无流动。\n        $$ (\\dot{m}_f)_{\\text{out}, L} = \\rho_L \\cdot 0 = 0 $$\n        $$ (\\dot{m}_f)_{\\text{out}, R} = \\rho_R \\cdot (-0) = 0 $$\n        和为 $0$。守恒成立。\n\n由于对于任意面 $f$，通量都能完美抵消，因此该格式是局部守恒的，也因而是全局守恒的。\n\n### 对周期性域的影响\n\n在具有周期性边界条件的域中，每个面都是一个恰好由两个单元共享的内部面。\n1.  **最大共享面不匹配度 ($r_{\\text{mismatch}}$):** 其定义为 $\\max_{f} \\left| (\\dot{m}_f)_{\\text{out}, L} + (\\dot{m}_f)_{\\text{out}, R} \\right|$。如上所证，对于每个面，绝对值内的项恒为零。因此，$r_{\\text{mismatch}}$ 必须精确为 $0$。\n\n2.  **全局残差 ($r_{\\text{global}}$):** 这是域中所有单元净质量通量之和的绝对值：$r_{\\text{global}} = \\left| \\sum_{i,j} \\sum_{f \\in \\partial (i,j)} (\\dot{m}_f)_{\\text{out}} \\right|$。这个求和可以重组为对域中所有面的求和。由于每个面都由两个单元 $L$ 和 $R$ 共享，该求和变为：\n    $$ \\sum_{\\text{所有面 } f} \\left( (\\dot{m}_f)_{\\text{out}, L} + (\\dot{m}_f)_{\\text{out}, R} \\right) $$\n    由于此和中的每一项都为零，总和也为零。因此，$r_{\\text{global}}$ 必须为 $0$（在求和过程中可能存在浮点精度误差）。\n\n3.  **全局质量变化 ($r_{\\text{mass\\_change}}$):** 这是一个时间步后的总质量变化。使用前向欧拉更新：\n    $$ \\rho_{ij}^{n+1} V_{ij} - \\rho_{ij}^{n} V_{ij} = -\\Delta t \\sum_{f \\in \\partial (i,j)} (\\dot{m}_f)_{\\text{out}} $$\n    对所有单元求和得到总质量变化：\n    $$ \\sum_{i,j} \\left( \\rho_{ij}^{n+1} - \\rho_{ij}^{n} \\right) V_{ij} = - \\Delta t \\sum_{i,j} \\sum_{f \\in \\partial (i,j)} (\\dot{m}_f)_{\\text{out}} $$\n    其绝对值为：\n    $$ r_{\\text{mass\\_change}} = \\Delta t \\left| \\sum_{i,j} \\sum_{f \\in \\partial (i,j)} (\\dot{m}_f)_{\\text{out}} \\right| = \\Delta t \\cdot r_{\\text{global}} $$\n    由于 $r_{\\text{global}}$ 为零，因此 $r_{\\text{mass\\_change}}$ 也必须为零（在浮点精度范围内）。\n\n下面的数值实现将针对给定的测试案例验证这些理论结果。我们将计算这三个度量指标，并预期它们为零或非常接近于零，从而证实理论和实现的正确性。我们将使用 `numpy` 及其 `roll` 函数的矢量化操作来高效处理周期性边界条件和相邻单元的相互作用。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_case(Nx, Ny, dt, rho_initial, ux_func, uy_func, L=1.0):\n    \"\"\"\n    Computes conservation residuals for a single test case.\n    \"\"\"\n    # 1. Grid and Domain Setup\n    dx = L / Nx\n    dy = L / Ny\n    V_cell = dx * dy\n\n    # 2. Evaluate Fields\n    \n    # Cell-centered density field is provided\n    rho = rho_initial\n\n    # Face-centered coordinates for velocity evaluation\n    # ---- Vertical (east) faces of cell (i,j)\n    x_c_coords = (np.arange(Nx) + 0.5) * dx\n    y_c_coords = (np.arange(Ny) + 0.5) * dy\n    x_fx_coords = (np.arange(Nx) + 1.0) * dx\n    # meshgrid with 'ij' indexing ensures (Nx, Ny) shape which is different from numpy default 'xy'\n    # Here, to match loop-based logic, we need yy_fx to be (Ny, Nx) and then transpose\n    xx_fx_T, yy_fx_T = np.meshgrid(x_fx_coords, y_c_coords)\n    xx_fx = xx_fx_T.T\n    yy_fx = yy_fx_T.T\n\n    # ---- Horizontal (north) faces of cell (i,j)\n    y_fy_coords = (np.arange(Ny) + 1.0) * dy\n    xx_fy_T, yy_fy_T = np.meshgrid(x_c_coords, y_fy_coords)\n    xx_fy = xx_fy_T.T\n    yy_fy = yy_fy_T.T\n\n    # Face-normal velocities (evaluated at face centers)\n    u_fx = ux_func(xx_fx, yy_fx)  # Normal velocity on vertical faces\n    u_fy = uy_func(xx_fy, yy_fy)  # Normal velocity on horizontal faces\n\n    # Face volume fluxes. F_fx[i,j] is flux across face between (i,j) and (i+1,j)\n    F_fx = u_fx * dy\n    F_fy = u_fy * dx\n\n    # 3. Upwind Interpolation and Mass Flux Calculation\n    \n    # For vertical (east) faces, the right neighbor is at index i+1\n    rho_R_x = np.roll(rho, -1, axis=0)\n    rho_fx = np.where(F_fx >= 0, rho, rho_R_x)\n    mass_flux_x = F_fx * rho_fx\n\n    # For horizontal (north) faces, the right neighbor is at index j+1\n    rho_R_y = np.roll(rho, -1, axis=1)\n    rho_fy = np.where(F_fy >= 0, rho, rho_R_y)\n    mass_flux_y = F_fy * rho_fy\n\n    # 4. Compute Residuals\n\n    # Global Residual (r_global)\n    # Net flux out of cell (i,j) = (flux_east - flux_west) + (flux_north - flux_south)\n    # This is done by differencing the face flux arrays.\n    net_flux = (mass_flux_x - np.roll(mass_flux_x, 1, axis=0)) + \\\n               (mass_flux_y - np.roll(mass_flux_y, 1, axis=1))\n    \n    r_global = np.abs(np.sum(net_flux))\n\n    # Shared-Face Mismatch (r_mismatch)\n    # We calculate the outward flux from each cell through its 4 faces.\n    # flux_E[i,j] is the outward flux from cell (i,j) through its east face.\n    flux_E = mass_flux_x\n    flux_W = -np.roll(mass_flux_x, 1, axis=0) # Inward flux from west is mass_flux_x[i-1,j]\n    flux_N = mass_flux_y\n    flux_S = -np.roll(mass_flux_y, 1, axis=1) # Inward flux from south is mass_flux_y[i,j-1]\n    \n    # Mismatch at vertical faces: | flux_E[i,j] + flux_W[i+1,j] |\n    # flux_W[i+1,j] is computed by rolling flux_W by -1 along axis 0\n    mismatch_x = np.abs(flux_E + np.roll(flux_W, -1, axis=0))\n\n    # Mismatch at horizontal faces: | flux_N[i,j] + flux_S[i,j+1] |\n    mismatch_y = np.abs(flux_N + np.roll(flux_S, -1, axis=1))\n    \n    r_mismatch = max(np.max(mismatch_x), np.max(mismatch_y))\n\n    # Global Mass Change (r_mass_change)\n    rho_new = rho - (dt / V_cell) * net_flux\n    r_mass_change = np.abs(np.sum(rho_new - rho) * V_cell)\n\n    return r_global, r_mismatch, r_mass_change\n\ndef solve():\n    \"\"\"\n    Sets up and runs the test cases, then prints the results.\n    \"\"\"\n    test_cases = [\n        # Case 1: smooth, divergence-free\n        {\n            \"name\": \"smooth, divergence-free\", \"Nx\": 16, \"Ny\": 16, \"dt\": 1e-3,\n            \"rho_func\": lambda x, y: 1 + 0.2 * np.sin(2 * np.pi * x) * np.cos(2 * np.pi * y),\n            \"ux_func\": lambda x, y: np.sin(2 * np.pi * y),\n            \"uy_func\": lambda x, y: np.sin(2 * np.pi * x),\n        },\n        # Case 2: zero velocity, random density\n        {\n            \"name\": \"zero velocity, random density\", \"Nx\": 16, \"Ny\": 16, \"dt\": 1e-3,\n            \"rho_func\": None, # Will be handled specially\n            \"ux_func\": lambda x, y: 0.0 * x,\n            \"uy_func\": lambda x, y: 0.0 * y,\n        },\n        # Case 3: compressible, smooth\n        {\n            \"name\": \"compressible, smooth\", \"Nx\": 31, \"Ny\": 17, \"dt\": 5e-4,\n            \"rho_func\": lambda x, y: np.exp(0.3 * np.sin(2 * np.pi * x) + 0.3 * np.cos(2 * np.pi * y)),\n            \"ux_func\": lambda x, y: np.cos(2 * np.pi * y) + np.sin(4 * np.pi * x),\n            \"uy_func\": lambda x, y: np.sin(2 * np.pi * x) - np.cos(4 * np.pi * y),\n        },\n        # Case 4: linear fields, compressible\n        {\n            \"name\": \"linear fields, compressible\", \"Nx\": 8, \"Ny\": 12, \"dt\": 2e-3,\n            \"rho_func\": lambda x, y: 0.5 + x,\n            \"ux_func\": lambda x, y: y,\n            \"uy_func\": lambda x, y: -x,\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, Ny = case[\"Nx\"], case[\"Ny\"]\n        dx, dy = 1.0 / Nx, 1.0 / Ny\n        \n        # Create cell-centered coordinates for initial density evaluation\n        x_c = (np.arange(Nx) + 0.5) * dx\n        y_c = (np.arange(Ny) + 0.5) * dy\n        # Correct meshgrid indexing for vectorized functions\n        xx_c_T, yy_c_T = np.meshgrid(x_c, y_c)\n        xx_c = xx_c_T.T\n        yy_c = yy_c_T.T\n\n\n        if case[\"name\"] == \"zero velocity, random density\":\n            rng = np.random.default_rng(42)\n            rho_initial = rng.random((Nx, Ny))\n        else:\n            rho_initial = case[\"rho_func\"](xx_c, yy_c)\n        \n        res_tuple = run_case(\n            Nx, Ny, case[\"dt\"], rho_initial, \n            case[\"ux_func\"], case[\"uy_func\"]\n        )\n        results.extend(res_tuple)\n    \n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后一个实践练习将我们的注意力转向一个特殊但极其重要的应用：不可压缩流。在这种情况下，质量守恒定律简化为速度场的无散度约束$\\nabla \\cdot \\mathbf{u} = 0$。本练习将介绍一种强大而精确的谱方法，通过执行投影步骤来严格满足这一约束，该方法是现代不可压缩流求解器的核心技术之一。",
            "id": "4082126",
            "problem": "要求您在不可压缩复杂流体的分数步法中设计并实现一个质量守恒的投影步，该步骤在新的时间层级上强制执行离散的质量守恒。从质量守恒和不可压缩性的定义出发，构建一个投影，将一个中间速度场映射到一个二维周期性域上的无散场。该域是具有周期性边界条件的单位环面，即 $[0,1]^2$，在一个均匀网格上离散化，该网格在 $x$ 方向有 $N_x$ 个点，在 $y$ 方向有 $N_y$ 个点。在显式非压力更新后，时间层级 $n$ 的中间速度场表示为 $\\mathbf{u}^\\star(x,y) = (u^\\star(x,y), v^\\star(x,y))$，目标是生成满足 $\\nabla \\cdot \\mathbf{u}^{n+1}(x,y) = 0$ 的 $\\mathbf{u}^{n+1}(x,y)$，在离散层面上达到机器精度。\n\n您的构建必须基于一对在周期性网格上共轭的离散梯度和散度算子，以使投影步能够精确地强制执行离散连续性方程，直至浮点舍入误差。这一步在概念上必须为一个标量势求解一个离散泊松方程，该标量势校正中间速度并保证得到一个无散的结果。核心科学基础必须从质量守恒定律和不可压缩性的定义开始。在问题陈述中不允许使用任何捷径公式；请在您的解法中推导出所需内容。\n\n以一种在周期性单位正方形上可复现且数值稳健的方式实现您的投影。所有计算都应是无量纲的。如果存在角度，则隐式地以弧度解释，因为所用的函数是标准数学意义上的三角函数；但是，您不需要在输出中报告任何角度。\n\n您的程序必须：\n- 在给定网格上构建测试速度场 $\\mathbf{u}^\\star(x,y)$。\n- 应用您的质量守恒投影以获得 $\\mathbf{u}^{n+1}(x,y)$。\n- 使用构成您投影机制基础的相同离散算子，计算 $\\mathbf{u}^{n+1}(x,y)$ 的离散散度。\n- 对每个测试案例，报告网格上离散散度的最大绝对值，作为一个浮点数。\n\n测试套件：\n- 案例1：$N_x = 32$, $N_y = 32$。对于整数 $i \\in \\{0,\\dots,N_x-1\\}$ 和 $j \\in \\{0,\\dots,N_y-1\\}$，定义 $x_i = i/N_x$, $y_j = j/N_y$。令标量场 $\\psi(x,y) = \\sin(2\\pi x)\\cos(2\\pi y)$ 和 $\\phi(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$。定义一个势流梯度分量 $\\mathbf{u}_{\\mathrm{grad}} = \\nabla \\psi$ 和一个无散的旋转分量 $\\mathbf{u}_{\\mathrm{vort}} = (-\\partial_y \\phi, \\partial_x \\phi)$。设置 $\\mathbf{u}^\\star = \\mathbf{u}_{\\mathrm{grad}} + \\mathbf{u}_{\\mathrm{vort}} + 0.1\\,\\boldsymbol{\\eta}$，其中 $\\boldsymbol{\\eta}$ 是一个确定性的伪随机场，从种子设置为 $0$ 的标准正态分布中抽取，并且每个分量的形状均为 $(N_x,N_y)$。\n- 案例2：$N_x = 33$, $N_y = 17$。令 $\\mathbf{u}^\\star = \\boldsymbol{\\eta} + \\mathbf{c}$，其中 $\\boldsymbol{\\eta}$ 如上所述，但种子设置为 $0$，且 $\\mathbf{c} = (1.5, -0.75)$ 是一个恒定的均匀速度矢量。\n- 案例3：$N_x = 64$, $N_y = 64$。令 $\\psi(x,y) = \\cos(4\\pi x)\\sin(2\\pi y)$ 并设置 $\\mathbf{u}^\\star = \\nabla \\psi$（一个纯梯度场）。\n- 案例4：$N_x = 8$, $N_y = 8$。令 $\\phi(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$ 并设置 $\\mathbf{u}^\\star = 3\\,(-\\partial_y \\phi, \\partial_x \\phi)$（一个缩放后的无散场）。\n- 案例5：$N_x = 16$, $N_y = 24$。令 $\\mathbf{u}^\\star = \\boldsymbol{\\eta}$，种子设置为 $42$，其分量从标准正态分布中抽取。\n\n定义和要求：\n- 使用与周期性边界条件一致的离散傅里叶变换来实现离散梯度、散度和泊松方程的求解。使用快速傅里叶变换（FFT）作为变换的数值机制。\n- 离散散度必须使用投影构建中采用的相同波数进行谱方法计算，以确保共轭性和精确抵消，直至浮点精度。\n- 对每个案例，计算 $\\mathbf{u}^{n+1}$ 的最大绝对离散散度，并将其作为浮点值返回。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[\\mathrm{result}_1,\\mathrm{result}_2,\\mathrm{result}_3,\\mathrm{result}_4,\\mathrm{result}_5]$）。每个结果都必须是一个浮点数。",
            "solution": "该问题要求在一个二维周期性域上为不可压缩流体设计并实现一个质量守恒的投影步。解决方案必须从第一性原理，特别是质量守恒，推导得出，并使用基于快速傅里叶变换（FFT）的谱方法实现。\n\n控制流体运动的基本原理是质量守恒，由连续性方程表示：\n$$\n\\frac{\\partial \\rho}{\\partial t} + \\nabla \\cdot (\\rho \\mathbf{u}) = 0\n$$\n其中 $\\rho$ 是流体密度，$\\mathbf{u}$ 是速度场。对于被视为不可压缩的复杂流体，密度 $\\rho$ 被假定在空间和时间上都是恒定的。因此，其偏导数为零，即 $\\frac{\\partial \\rho}{\\partial t} = 0$ 和 $\\nabla \\rho = \\mathbf{0}$。连续性方程简化为：\n$$\n\\rho (\\nabla \\cdot \\mathbf{u}) = 0\n$$\n由于 $\\rho > 0$，这就得出了不可压缩性约束，这是对速度场的一个运动学条件：\n$$\n\\nabla \\cdot \\mathbf{u} = 0\n$$\n该方程表明，不可压缩流的速度场必须是无散的。\n\n分数步法，或称投影法，常用于求解不可压缩流的时间相关纳维-斯托克斯方程。它们将速度和压力的计算解耦。在一个典型的两步方案中，首先通过推进不含压力梯度项的动量方程，在时间层级 $n+1$ 计算出一个中间速度场，记为 $\\mathbf{u}^\\star$。这个场 $\\mathbf{u}^\\star$ 通常不满足不可压缩性约束。\n\n第二步，即投影步，校正 $\\mathbf{u}^\\star$ 以产生一个离散无散的速度场 $\\mathbf{u}^{n+1}$。这是通过引入压力梯度的影响来实现的。校正由以下公式给出：\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^\\star}{\\Delta t} = -\\nabla p^{n+1}\n$$\n其中 $p^{n+1}$ 与压力有关，$\\Delta t$ 是时间步长。对于我们的无量纲问题，我们可以将 $\\Delta t$ 吸收到一个标量势 $\\Phi$ 中，使得更新为：\n$$\n\\mathbf{u}^{n+1} = \\mathbf{u}^\\star - \\nabla \\Phi\n$$\n这是亥姆霍兹-霍奇分解 (Helmholtz-Hodge decomposition) 的一个陈述，该分解指出任何向量场 $\\mathbf{u}^\\star$ 都可以唯一地分解为一个无散分量（$\\mathbf{u}^{n+1}$）和一个无旋（梯度）分量（$\\nabla \\Phi$）。\n\n为了找到势 $\\Phi$，我们对最终速度场施加不可压缩性约束，即 $\\nabla \\cdot \\mathbf{u}^{n+1} = 0$。对校正方程应用散度算子，我们得到：\n$$\n\\nabla \\cdot \\mathbf{u}^{n+1} = \\nabla \\cdot \\mathbf{u}^\\star - \\nabla \\cdot (\\nabla \\Phi)\n$$\n设置 $\\nabla \\cdot \\mathbf{u}^{n+1} = 0$ 会导出一个关于标量势 $\\Phi$ 的泊松方程：\n$$\n\\nabla^2 \\Phi = \\nabla \\cdot \\mathbf{u}^\\star\n$$\n求解这个关于 $\\Phi$ 的方程，使我们能够计算梯度 $\\nabla \\Phi$，并随后计算出最终的无散速度场 $\\mathbf{u}^{n+1}$。\n\n对于指定的周期性域 $[0,1]^2$，使用离散傅里叶变换（DFT）的谱方法因其高精度和 FFT 算法的效率而特别适用。在傅里叶空间中，微分算子变成了代数乘法算子。网格上的函数 $f(x,y)$ 被变换为其傅里叶系数 $\\hat{f}(k_x, k_y)$，其中 $k_x$ 和 $k_y$ 是波数。导数算子变换如下：\n$$\n\\mathcal{F}\\left(\\frac{\\partial f}{\\partial x}\\right) = i k_x \\hat{f} \\quad \\text{and} \\quad \\mathcal{F}\\left(\\frac{\\partial f}{\\partial y}\\right) = i k_y \\hat{f}\n$$\n其中 $\\mathcal{F}$ 表示傅里叶变换。\n\n对于尺寸为 $L_x=1$、$L_y=1$ 且具有 $N_x$ 和 $N_y$ 个点的域，其离散波数由 $k_x = 2\\pi m$ 和 $k_y = 2\\pi n$ 给出，其中 $m$ 和 $n$ 是整数模。这些波数是使用 `scipy.fft.fftfreq` 计算的。具体来说，$k_x = 2\\pi \\times \\text{fftfreq}(N_x, 1/N_x)$ 和 $k_y = 2\\pi \\times \\text{fftfreq}(N_y, 1/N_y)$。\n\n对泊松方程 $\\nabla^2 \\Phi = \\nabla \\cdot \\mathbf{u}^\\star$ 应用傅里叶变换：\n$$\n\\mathcal{F}(\\nabla^2 \\Phi) = \\mathcal{F}(\\nabla \\cdot \\mathbf{u}^\\star)\n$$\n左手边变为：\n$$\n\\mathcal{F}(\\nabla^2 \\Phi) = \\mathcal{F}\\left(\\frac{\\partial^2 \\Phi}{\\partial x^2} + \\frac{\\partial^2 \\Phi}{\\partial y^2}\\right) = ((ik_x)^2 + (ik_y)^2)\\hat{\\Phi} = -(k_x^2 + k_y^2)\\hat{\\Phi}\n$$\n右手边，即 $\\mathbf{u}^\\star = (u^\\star, v^\\star)$ 的散度，变为：\n$$\n\\mathcal{F}(\\nabla \\cdot \\mathbf{u}^\\star) = \\mathcal{F}\\left(\\frac{\\partial u^\\star}{\\partial x} + \\frac{\\partial v^\\star}{\\partial y}\\right) = i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star\n$$\n将这些结合起来，得到傅里叶空间中关于 $\\hat{\\Phi}$ 的代数方程：\n$$\n-(k_x^2 + k_y^2)\\hat{\\Phi} = i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star\n$$\n我们可以解出 $\\hat{\\Phi}$：\n$$\n\\hat{\\Phi}(k_x, k_y) = - \\frac{i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star}{k_x^2 + k_y^2}\n$$\n对于零波数模式 $(k_x, k_y) = (0,0)$ 会出现一个特殊情况，此时分母 $k_x^2+k_y^2$ 为零。该模式对应于场的平均值。对于此模式，分子也为零，$i(0)\\hat{u}^\\star_{0,0} + i(0)\\hat{v}^\\star_{0,0} = 0$。这种 $0/0$ 的不确定性反映了势 $\\Phi$ 仅能确定到一个任意常数。我们可以通过设置 $\\hat{\\Phi}(0,0) = 0$ 来解决这个问题，这对应于选择具有零空间平均值的唯一势。\n\n一旦知道了 $\\hat{\\Phi}$，我们就可以找到投影速度 $\\mathbf{u}^{n+1} = \\mathbf{u}^\\star - \\nabla \\Phi$ 的傅里叶变换：\n$$\n\\hat{u}^{n+1} = \\hat{u}^\\star - i k_x \\hat{\\Phi}\n$$\n$$\n\\hat{v}^{n+1} = \\hat{v}^\\star - i k_y \\hat{\\Phi}\n$$\n最后，通过应用傅里叶逆变换 $\\mathcal{F}^{-1}$ 来恢复实空间速度场 $\\mathbf{u}^{n+1}$。\n\n为了验证结果，我们使用相同的谱算子计算 $\\mathbf{u}^{n+1}$ 的离散散度。在傅里叶空间中，这表示为：\n$$\n\\widehat{\\nabla \\cdot \\mathbf{u}^{n+1}} = i k_x \\hat{u}^{n+1} + i k_y \\hat{v}^{n+1}\n$$\n代入 $\\hat{u}^{n+1}$ 和 $\\hat{v}^{n+1}$ 的表达式：\n$$\n\\widehat{\\nabla \\cdot \\mathbf{u}^{n+1}} = i k_x (\\hat{u}^\\star - i k_x \\hat{\\Phi}) + i k_y (\\hat{v}^\\star - i k_y \\hat{\\Phi})\n= (i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star) - ( (ik_x)^2 + (ik_y)^2 ) \\hat{\\Phi}\n= (i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star) + (k_x^2 + k_y^2) \\hat{\\Phi}\n$$\n代入 $\\hat{\\Phi}$ 的解：\n$$\n= (i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star) + (k_x^2 + k_y^2) \\left( - \\frac{i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star}{k_x^2 + k_y^2} \\right) = 0\n$$\n这对所有 $(k_x, k_y) \\neq (0,0)$ 都成立。对于 $(k_x, k_y)=(0,0)$，所有项均为零。因此，投影场的散度在傅里叶空间中解析地为零。其逆变换将为零，直至浮点舍入误差。该场的最大绝对值即为所要求的输出。",
            "answer": "```python\nimport numpy as np\nimport scipy.fft\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n\n    test_cases = [\n        {'Nx': 32, 'Ny': 32, 'case_type': 'grad_vort_noise', 'seed': 0},\n        {'Nx': 33, 'Ny': 17, 'case_type': 'noise_const', 'seed': 0},\n        {'Nx': 64, 'Ny': 64, 'case_type': 'pure_grad', 'seed': None},\n        {'Nx': 8, 'Ny': 8, 'case_type': 'pure_vort', 'seed': None},\n        {'Nx': 16, 'Ny': 24, 'case_type': 'pure_noise', 'seed': 42},\n    ]\n\n    results = []\n    for params in test_cases:\n        result = _solve_single_case(params)\n        results.append(result)\n\n    print(f\"[{','.join(f'{r:.16e}' for r in results)}]\")\n\ndef _solve_single_case(params):\n    \"\"\"\n    Solves a single test case for the projection problem.\n    \"\"\"\n    Nx = params['Nx']\n    Ny = params['Ny']\n    case_type = params['case_type']\n    seed = params['seed']\n    \n    # 1. Construct the grid\n    x = np.arange(Nx) / Nx\n    y = np.arange(Ny) / Ny\n    xx, yy = np.meshgrid(x, y, indexing='ij')\n\n    # 2. Construct the intermediate velocity field u_star\n    pi = np.pi\n    u_star, v_star = None, None\n    rng = np.random.default_rng(seed) if seed is not None else None\n\n    if case_type == 'grad_vort_noise':\n        # Case 1: Grad + Vort + Noise\n        psi = np.sin(2 * pi * xx) * np.cos(2 * pi * yy)\n        dpsi_dx = 2 * pi * np.cos(2 * pi * xx) * np.cos(2 * pi * yy)\n        dpsi_dy = -2 * pi * np.sin(2 * pi * xx) * np.sin(2 * pi * yy)\n\n        phi_vort = np.sin(2 * pi * xx) * np.sin(2 * pi * yy)\n        dphi_dx = 2 * pi * np.cos(2 * pi * xx) * np.sin(2 * pi * yy)\n        dphi_dy = 2 * pi * np.sin(2 * pi * xx) * np.cos(2 * pi * yy)\n        \n        eta_x = rng.standard_normal(size=(Nx, Ny))\n        eta_y = rng.standard_normal(size=(Nx, Ny))\n\n        u_star = dpsi_dx - dphi_dy + 0.1 * eta_x\n        v_star = dpsi_dy + dphi_dx + 0.1 * eta_y\n\n    elif case_type == 'noise_const':\n        # Case 2: Noise + Constant\n        c = (1.5, -0.75)\n        eta_x = rng.standard_normal(size=(Nx, Ny))\n        eta_y = rng.standard_normal(size=(Nx, Ny))\n        u_star = eta_x + c[0]\n        v_star = eta_y + c[1]\n\n    elif case_type == 'pure_grad':\n        # Case 3: Pure gradient field\n        psi = np.cos(4 * pi * xx) * np.sin(2 * pi * yy)\n        u_star = -4 * pi * np.sin(4 * pi * xx) * np.sin(2 * pi * yy)\n        v_star = 2 * pi * np.cos(4 * pi * xx) * np.cos(2 * pi * yy)\n\n    elif case_type == 'pure_vort':\n        # Case 4: Purely rotational (divergence-free) field\n        phi_vort = np.sin(2 * pi * xx) * np.sin(2 * pi * yy)\n        dphi_dx = 2 * pi * np.cos(2 * pi * xx) * np.sin(2 * pi * yy)\n        dphi_dy = 2 * pi * np.sin(2 * pi * xx) * np.cos(2 * pi * yy)\n        u_star = 3.0 * (-dphi_dy)\n        v_star = 3.0 * (dphi_dx)\n\n    elif case_type == 'pure_noise':\n        # Case 5: Pure noise\n        u_star = rng.standard_normal(size=(Nx, Ny))\n        v_star = rng.standard_normal(size=(Nx, Ny))\n    \n    # 3. Perform the projection\n    u_proj, v_proj = _project_velocity(u_star, v_star, Nx, Ny)\n\n    # 4. Compute the divergence of the projected field\n    divergence_field = _calculate_divergence(u_proj, v_proj, Nx, Ny)\n\n    # 5. Return the maximum absolute divergence\n    return np.max(np.abs(divergence_field))\n\ndef _project_velocity(u, v, Nx, Ny):\n    \"\"\"\n    Projects a velocity field (u, v) onto its divergence-free part.\n    \"\"\"\n    # Create wavenumber grids\n    kx_1d = 2 * np.pi * scipy.fft.fftfreq(Nx, d=1.0/Nx)\n    ky_1d = 2 * np.pi * scipy.fft.fftfreq(Ny, d=1.0/Ny)\n    kx, ky = np.meshgrid(kx_1d, ky_1d, indexing='ij')\n\n    # FFT of the velocity field\n    u_hat = scipy.fft.fft2(u)\n    v_hat = scipy.fft.fft2(v)\n\n    # Compute FFT of divergence of (u, v)\n    div_u_hat = 1j * kx * u_hat + 1j * ky * v_hat\n\n    # Solve Poisson equation for the potential phi in Fourier space\n    k_squared = kx**2 + ky**2\n    # Handle the k=0 mode to avoid division by zero\n    k_squared[0, 0] = 1.0\n    \n    phi_hat = -div_u_hat / k_squared\n    phi_hat[0, 0] = 0.0 # Explicitly set the mean of the potential to zero\n\n    # Correct the velocity field in Fourier space\n    u_proj_hat = u_hat - 1j * kx * phi_hat\n    v_proj_hat = v_hat - 1j * ky * phi_hat\n\n    # Inverse FFT to get the projected velocity field in real space\n    u_proj = scipy.fft.ifft2(u_proj_hat).real\n    v_proj = scipy.fft.ifft2(v_proj_hat).real\n    \n    return u_proj, v_proj\n\ndef _calculate_divergence(u, v, Nx, Ny):\n    \"\"\"\n    Computes the divergence of a velocity field (u, v) using spectral methods.\n    \"\"\"\n    # Create wavenumber grids\n    kx_1d = 2 * np.pi * scipy.fft.fftfreq(Nx, d=1.0/Nx)\n    ky_1d = 2 * np.pi * scipy.fft.fftfreq(Ny, d=1.0/Ny)\n    kx, ky = np.meshgrid(kx_1d, ky_1d, indexing='ij')\n\n    # FFT of the velocity field\n    u_hat = scipy.fft.fft2(u)\n    v_hat = scipy.fft.fft2(v)\n\n    # Compute divergence in Fourier space\n    div_u_hat = 1j * kx * u_hat + 1j * ky * v_hat\n\n    # Inverse FFT to get divergence in real space\n    divergence = scipy.fft.ifft2(div_u_hat).real\n    \n    return divergence\n\nsolve()\n```"
        }
    ]
}