{
    "hands_on_practices": [
        {
            "introduction": "The finite volume method (FVM) is built upon the integral form of conservation laws, making it naturally suited for ensuring physical quantities are conserved at a discrete level. This foundational practice guides you through implementing and verifying the core principle of a conservative scheme: the perfect cancellation of mass fluxes across shared cell faces. Mastering this concept is the first and most critical step in building robust and physically accurate fluid dynamics solvers.",
            "id": "4082087",
            "problem": "Consider the conservation of mass for a continuum described by the mass density field $\\rho(\\mathbf{x},t)$ and velocity field $\\mathbf{u}(\\mathbf{x},t)$. The integral statement of conservation of mass over a fixed control volume $V$ with boundary $\\partial V$ is\n$$\n\\frac{d}{dt}\\int_V \\rho \\, dV + \\int_{\\partial V} \\rho \\, \\mathbf{u}\\cdot\\mathbf{n}\\, dA = 0,\n$$\nwhere $\\mathbf{n}$ is the outward unit normal on $\\partial V$. In the Finite Volume Method (FVM), one partitions the domain into control volumes and approximates the flux integrals as sums over cell faces. In a collocated arrangement, $\\rho$ and $\\mathbf{u}$ are stored at cell centers and face quantities are obtained by interpolation.\n\nYour task is to implement a conservative face interpolation for the density $\\rho$ in a collocated FVM on a uniform, periodic, two-dimensional Cartesian grid that avoids checkerboarding, and to demonstrate that the discrete continuity statement remains exact in the sense that shared-face fluxes cancel pairwise between adjacent cells.\n\nUse the following context and definitions:\n\n- Let the domain be $[0,L_x]\\times[0,L_y]$ with $L_x=L_y=1$. Consider a uniform grid with $N_x$ cells in the $x$-direction and $N_y$ cells in the $y$-direction. Cell centers are at $(x_i,y_j)$ with spacings $\\Delta x = L_x/N_x$ and $\\Delta y = L_y/N_y$.\n- For each cell $(i,j)$, denote its volume by $V_{ij} = \\Delta x \\Delta y$ and its set of faces by $\\partial (i,j)$. For each face $f$ between a \"left\" cell $L$ and a \"right\" cell $R$, define the face-normal velocity as $u_f = \\mathbf{u}_f \\cdot \\mathbf{n}_f$ and the face area as $A_f$. The face mass flux is $F_f = u_f A_f$. On a Cartesian grid, $A_f$ equals $\\Delta y$ for vertical faces and $\\Delta x$ for horizontal faces. Periodic boundary conditions identify faces across domain boundaries, ensuring each face is shared by exactly two cells.\n- The discrete continuity equation for a cell $(i,j)$ is\n$$\n\\frac{d}{dt} \\left( \\rho_{ij} V_{ij} \\right) + \\sum_{f \\in \\partial (i,j)} F_f \\, \\rho_f = 0,\n$$\nwhere $\\rho_f$ is the density evaluated at face $f$.\n\nYou must:\n\n1. Implement a face interpolation for $\\rho_f$ that is conservative and avoids checkerboarding by using mass-flux upwinding:\n$$\n\\rho_f =\n\\begin{cases}\n\\rho_L,  F_f \\ge 0, \\\\\n\\rho_R,  F_f  0,\n\\end{cases}\n$$\nwith the convention that when $F_f=0$ you may use the bounded arithmetic average $\\rho_f = \\tfrac{1}{2}(\\rho_L+\\rho_R)$. Here $\\rho_L$ and $\\rho_R$ are the cell-centered densities in the cells left and right of face $f$ along the outward normal $\\mathbf{n}_f$.\n2. Use analytic expressions for the velocity field to evaluate face-normal velocities $\\mathbf{u}_f$ directly at face centers $(x_f,y_f)$, so that $u_f = \\mathbf{u}(x_f,y_f)\\cdot \\mathbf{n}_f$. This avoids additional velocity interpolation artifacts and focuses the test on the density face interpolation.\n3. Prove, in your solution, starting from the integral conservation of mass, that with the above choice of $\\rho_f$, the discrete continuity statement is exact in the sense that the mass flux across any shared interior face $f$ is identical and opposite for the adjacent cells $L$ and $R$, so internal contributions cancel exactly when summing over all cells, and with periodic boundaries the global discrete mass change is identically zero.\n\nNumerical implementation details to be used:\n\n- Define cell-centered coordinates as $x_i = (i+\\tfrac{1}{2})\\Delta x$ for $i=0,\\dots,N_x-1$ and $y_j = (j+\\tfrac{1}{2})\\Delta y$ for $j=0,\\dots,N_y-1$.\n- Define face-centered coordinates for vertical faces (between $(i,j)$ and $(i+1,j)$) as $x_{i+\\tfrac{1}{2}} = \\tfrac{1}{2}(x_i+x_{i+1})$ and $y_j$, and for horizontal faces (between $(i,j)$ and $(i,j+1)$) as $x_i$ and $y_{j+\\tfrac{1}{2}} = \\tfrac{1}{2}(y_j+y_{j+1})$.\n- Periodic indexing must be used: indices wrap so that $i+1$ maps to $0$ when $i=N_x-1$, and $j+1$ maps to $0$ when $j=N_y-1$.\n\nDesign the program to compute and report, for each test case:\n\n- The global residual of the discrete continuity, defined as\n$$\nr_{\\text{global}} = \\left| \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\left( \\sum_{f \\in \\partial (i,j)} F_f \\rho_f \\right) \\right|,\n$$\nwhich must be $0$ for periodic boundaries when face fluxes are shared consistently.\n- The maximum shared-face mismatch, defined as the maximum over all faces $f$ of the absolute difference between the outward mass flux reported by the left cell and the outward mass flux reported by the right cell across the same face. With a conservative face interpolation, this must be identically $0$ for all interior faces:\n$$\nr_{\\text{mismatch}} = \\max_{f} \\left| (F_f \\rho_f)_{\\text{left,out}} + (F_f \\rho_f)_{\\text{right,out}} \\right|.\n$$\n- The global mass change after one explicit update of the cell masses using a forward Euler step of size $\\Delta t$, defined as\n$$\nr_{\\text{mass\\_change}} = \\left| \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\left( \\rho_{ij}^{n+1} - \\rho_{ij}^{n} \\right) V_{ij} \\right|,\n$$\nwhere\n$$\n\\rho_{ij}^{n+1} = \\rho_{ij}^{n} - \\frac{\\Delta t}{V_{ij}} \\sum_{f \\in \\partial (i,j)} F_f \\rho_f.\n$$\nUnder periodic boundaries and shared-face conservation, $r_{\\text{mass\\_change}}$ must be $0$.\n\nAll quantities in this problem are dimensionless, so no units are required.\n\nTest suite:\n\n- Case $1$ (\"smooth, divergence-free\"): $N_x=16$, $N_y=16$, $\\Delta t = 10^{-3}$. Density and velocity fields:\n$$\n\\rho(x,y) = 1 + 0.2 \\sin(2\\pi x)\\cos(2\\pi y), \\quad\nu_x(x,y) = \\sin(2\\pi y), \\quad\nu_y(x,y) = \\sin(2\\pi x).\n$$\n- Case $2$ (\"zero velocity, random density\"): $N_x=16$, $N_y=16$, $\\Delta t = 10^{-3}$. Density:\n$$\n\\rho(x,y) \\text{ is a fixed pseudo-random field with seed } 42,\n$$\nand velocity\n$$\nu_x(x,y) = 0, \\quad u_y(x,y) = 0.\n$$\n- Case $3$ (\"compressible, smooth\"): $N_x=31$, $N_y=17$, $\\Delta t = 5\\times 10^{-4}$. Density and velocity fields:\n$$\n\\rho(x,y) = \\exp\\left(0.3\\sin(2\\pi x) + 0.3\\cos(2\\pi y)\\right), \\quad\nu_x(x,y) = \\cos(2\\pi y) + \\sin(4\\pi x), \\quad\nu_y(x,y) = \\sin(2\\pi x) - \\cos(4\\pi y).\n$$\n- Case $4$ (\"linear fields, compressible\"): $N_x=8$, $N_y=12$, $\\Delta t = 2\\times 10^{-3}$. Density and velocity fields:\n$$\n\\rho(x,y) = 0.5 + x, \\quad\nu_x(x,y) = y, \\quad\nu_y(x,y) = -x.\n$$\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order\n$$\n[ r_{\\text{global}}^{(1)}, r_{\\text{mismatch}}^{(1)}, r_{\\text{mass\\_change}}^{(1)}, r_{\\text{global}}^{(2)}, r_{\\text{mismatch}}^{(2)}, r_{\\text{mass\\_change}}^{(2)}, r_{\\text{global}}^{(3)}, r_{\\text{mismatch}}^{(3)}, r_{\\text{mass\\_change}}^{(3)}, r_{\\text{global}}^{(4)}, r_{\\text{mismatch}}^{(4)}, r_{\\text{mass\\_change}}^{(4)} ].\n$$\nEach entry must be a floating-point number. The program must be fully self-contained and must not read input from the user.",
            "solution": "The problem requires the implementation and validation of a conservative finite volume discretization for the mass conservation equation on a periodic two-dimensional Cartesian grid. The core of the task is to demonstrate that an upwind-based interpolation for face densities results in a scheme that is discretely conservative, meaning shared-face fluxes cancel perfectly and the total mass is conserved over time.\n\nFirst, we must prove theoretically that the chosen numerical scheme is conservative, as requested.\n\n### Theoretical Proof of Discrete Conservation\n\nThe integral form of the mass conservation law for a fixed control volume $V$ is:\n$$\n\\frac{d}{dt}\\int_V \\rho \\, dV + \\int_{\\partial V} \\rho \\, \\mathbf{u}\\cdot\\mathbf{n}\\, dA = 0\n$$\nIn the Finite Volume Method (FVM), we apply this law to each grid cell (control volume) $V_{ij}$. The semi-discrete equation for a cell, denoted here by an index $P$, is:\n$$\n\\frac{d}{dt} \\left( \\rho_P V_P \\right) + \\sum_{f \\in \\partial P} (\\dot{m}_f)_{\\text{out}} = 0\n$$\nwhere $\\rho_P$ is the cell-averaged density, $V_P$ is the cell volume, and $(\\dot{m}_f)_{\\text{out}}$ is the mass flux leaving cell $P$ through face $f$. This outward mass flux is given by $(\\dot{m}_f)_{\\text{out}} = \\rho_f F_f$, where $F_f = (\\mathbf{u}_f \\cdot \\mathbf{n}_f) A_f$ is the volume flux through the face, and $\\mathbf{n}_f$ is the outward normal from cell $P$.\n\nThe key to discrete conservation lies in ensuring that the flux leaving one cell across a shared face is equal and opposite to the flux leaving the neighboring cell across the same face. In other words, the flux entering the neighbor must be identical to the flux leaving the first cell. Let's consider two adjacent cells, $L$ (\"left\") and $R$ (\"right\"), sharing a common face $f$. We define the normal vector $\\mathbf{n}_f$ on face $f$ to point from cell $L$ to cell $R$.\n\n1.  **Flux from Cell L's perspective:**\n    The outward normal from cell $L$ at face $f$ is $\\mathbf{n}_f$. The volume flux is $F_f = (\\mathbf{u}_f \\cdot \\mathbf{n}_f) A_f$. The mass flux out of cell $L$ through face $f$ is:\n    $$ (\\dot{m}_f)_{\\text{out}, L} = \\rho_f F_f $$\n    The problem specifies an upwind scheme for the face density $\\rho_f$:\n    $$\n    \\rho_f =\n    \\begin{cases}\n    \\rho_L,  \\text{if } F_f \\ge 0 \\quad (\\text{flow is from L to R}) \\\\\n    \\rho_R,  \\text{if } F_f  0 \\quad (\\text{flow is from R to L})\n    \\end{cases}\n    $$\n    Here, $\\rho_L$ and $\\rho_R$ are the cell-centered densities in cells $L$ and $R$, respectively.\n\n2.  **Flux from Cell R's perspective:**\n    The outward normal from cell $R$ at face $f$ is $-\\mathbf{n}_f$.\n    The volume flux from $R$'s perspective is $F'_f = (\\mathbf{u}_f \\cdot (-\\mathbf{n}_f)) A_f = -F_f$.\n    To find the mass flux out of cell $R$ through face $f$, $(\\dot{m}_f)_{\\text{out}, R}$, we must apply the upwind rule from $R$'s perspective. For cell $R$, its neighbor across face $f$ is cell $L$. The \"left\" cell (in the direction of its outward normal $-\\mathbf{n}_f$) is $R$, and the \"right\" cell is $L$. The face density $\\rho'_f$ is:\n    $$\n    \\rho'_f =\n    \\begin{cases}\n    \\rho_R,  \\text{if } F'_f \\ge 0 \\implies -F_f \\ge 0 \\implies F_f \\le 0 \\\\\n    \\rho_L,  \\text{if } F'_f  0 \\implies -F_f  0 \\implies F_f  0\n    \\end{cases}\n    $$\n    The mass flux out of $R$ is $(\\dot{m}_f)_{\\text{out}, R} = \\rho'_f F'_f = \\rho'_f (-F_f)$.\n\n3.  **Verification of Conservation at the Face:**\n    We must show that the sum of the outward fluxes from both cells across the shared face is zero: $(\\dot{m}_f)_{\\text{out}, L} + (\\dot{m}_f)_{\\text{out}, R} = 0$.\n    *   **Case i: $F_f > 0$.** Flow is from $L$ to $R$.\n        $$ (\\dot{m}_f)_{\\text{out}, L} = \\rho_L F_f $$\n        $$ (\\dot{m}_f)_{\\text{out}, R} = \\rho'_f (-F_f) = \\rho_L (-F_f) = - \\rho_L F_f $$\n        The sum is $(\\dot{m}_f)_{\\text{out}, L} + (\\dot{m}_f)_{\\text{out}, R} = \\rho_L F_f - \\rho_L F_f = 0$. Conservation holds.\n    *   **Case ii: $F_f  0$.** Flow is from $R$ to $L$.\n        $$ (\\dot{m}_f)_{\\text{out}, L} = \\rho_R F_f $$\n        $$ (\\dot{m}_f)_{\\text{out}, R} = \\rho'_f (-F_f) = \\rho_R (-F_f) = - \\rho_R F_f $$\n        The sum is $(\\dot{m}_f)_{\\text{out}, L} + (\\dot{m}_f)_{\\text{out}, R} = \\rho_R F_f - \\rho_R F_f = 0$. Conservation holds.\n    *   **Case iii: $F_f = 0$.** No flow.\n        $$ (\\dot{m}_f)_{\\text{out}, L} = \\rho_L \\cdot 0 = 0 $$\n        $$ (\\dot{m}_f)_{\\text{out}, R} = \\rho_R \\cdot (-0) = 0 $$\n        The sum is $0$. Conservation holds.\n\nSince the fluxes cancel perfectly for any arbitrary face $f$, the scheme is\nlocally and therefore globally conservative.\n\n### Implications for a Periodic Domain\n\nIn a domain with periodic boundary conditions, every face is an interior face shared by exactly two cells.\n1.  **Maximum Shared-Face Mismatch ($r_{\\text{mismatch}}$):** This is defined as $\\max_{f} \\left| (\\dot{m}_f)_{\\text{out}, L} + (\\dot{m}_f)_{\\text{out}, R} \\right|$. As proven above, the term inside the absolute value is identically zero for every face. Therefore, $r_{\\text{mismatch}}$ must be exactly $0$.\n\n2.  **Global Residual ($r_{\\text{global}}$):** This is the absolute sum of the net mass flux over all cells in the domain: $r_{\\text{global}} = \\left| \\sum_{i,j} \\sum_{f \\in \\partial (i,j)} (\\dot{m}_f)_{\\text{out}} \\right|$. This sum can be re-grouped as a sum over all faces in the domain. Since each face is shared by two cells, $L$ and $R$, the sum becomes:\n    $$ \\sum_{\\text{all faces } f} \\left( (\\dot{m}_f)_{\\text{out}, L} + (\\dot{m}_f)_{\\text{out}, R} \\right) $$\n    As each term in this sum is zero, the total sum is zero. Thus, $r_{\\text{global}}$ must be $0$ (up to floating-point precision errors from the summation).\n\n3.  **Global Mass Change ($r_{\\text{mass\\_change}}$):** This is the total change in mass after one time step. Using a forward Euler update:\n    $$ \\rho_{ij}^{n+1} V_{ij} - \\rho_{ij}^{n} V_{ij} = -\\Delta t \\sum_{f \\in \\partial (i,j)} (\\dot{m}_f)_{\\text{out}} $$\n    Summing over all cells gives the total mass change:\n    $$ \\sum_{i,j} \\left( \\rho_{ij}^{n+1} - \\rho_{ij}^{n} \\right) V_{ij} = - \\Delta t \\sum_{i,j} \\sum_{f \\in \\partial (i,j)} (\\dot{m}_f)_{\\text{out}} $$\n    The absolute value of this is:\n    $$ r_{\\text{mass\\_change}} = \\Delta t \\left| \\sum_{i,j} \\sum_{f \\in \\partial (i,j)} (\\dot{m}_f)_{\\text{out}} \\right| = \\Delta t \\cdot r_{\\text{global}} $$\n    Since $r_{\\text{global}}$ is zero, $r_{\\text{mass\\_change}}$ must also be zero (up to floating-point precision).\n\nThe numerical implementation below will verify these theoretical results for the given test cases. We will calculate the three metrics and expect them to be zero or very close to zero, confirming the correctness of both the theory and the implementation. Vectorized operations using `numpy` and its `roll` function will be employed to efficiently handle the periodic boundary conditions and neighbor cell interactions.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_case(Nx, Ny, dt, rho_initial, ux_func, uy_func, L=1.0):\n    \"\"\"\n    Computes conservation residuals for a single test case.\n    \"\"\"\n    # 1. Grid and Domain Setup\n    dx = L / Nx\n    dy = L / Ny\n    V_cell = dx * dy\n\n    # 2. Evaluate Fields\n    \n    # Cell-centered density field is provided\n    rho = rho_initial\n\n    # Face-centered coordinates for velocity evaluation\n    # ---- Vertical (east) faces of cell (i,j)\n    x_c_coords = (np.arange(Nx) + 0.5) * dx\n    y_c_coords = (np.arange(Ny) + 0.5) * dy\n    x_fx_coords = (np.arange(Nx) + 1.0) * dx\n    # meshgrid with 'ij' indexing ensures (Nx, Ny) shape\n    xx_fx, yy_fx = np.meshgrid(x_fx_coords, y_c_coords, indexing='ij')\n\n    # ---- Horizontal (north) faces of cell (i,j)\n    y_fy_coords = (np.arange(Ny) + 1.0) * dy\n    xx_fy, yy_fy = np.meshgrid(x_c_coords, y_fy_coords, indexing='ij')\n\n    # Face-normal velocities (evaluated at face centers)\n    u_fx = ux_func(xx_fx, yy_fx)  # Normal velocity on vertical faces\n    u_fy = uy_func(xx_fy, yy_fy)  # Normal velocity on horizontal faces\n\n    # Face volume fluxes. F_fx[i,j] is flux across face between (i,j) and (i+1,j)\n    F_fx = u_fx * dy\n    F_fy = u_fy * dx\n\n    # 3. Upwind Interpolation and Mass Flux Calculation\n    \n    # For vertical (east) faces, the right neighbor is at index i+1\n    rho_R_x = np.roll(rho, -1, axis=0)\n    rho_fx = np.where(F_fx >= 0, rho, rho_R_x)\n    mass_flux_x = F_fx * rho_fx\n\n    # For horizontal (north) faces, the right neighbor is at index j+1\n    rho_R_y = np.roll(rho, -1, axis=1)\n    rho_fy = np.where(F_fy >= 0, rho, rho_R_y)\n    mass_flux_y = F_fy * rho_fy\n\n    # 4. Compute Residuals\n\n    # Global Residual (r_global)\n    # Net flux out of cell (i,j) = (flux_east - flux_west) + (flux_north - flux_south)\n    # This is done by differencing the face flux arrays.\n    net_flux = (mass_flux_x - np.roll(mass_flux_x, 1, axis=0)) + \\\n               (mass_flux_y - np.roll(mass_flux_y, 1, axis=1))\n    \n    r_global = np.abs(np.sum(net_flux))\n\n    # Shared-Face Mismatch (r_mismatch)\n    # We calculate the outward flux from each cell through its 4 faces.\n    # flux_E[i,j] is the outward flux from cell (i,j) through its east face.\n    flux_E = mass_flux_x\n    flux_W = -np.roll(mass_flux_x, 1, axis=0) # Inward flux from west is mass_flux_x[i-1,j]\n    flux_N = mass_flux_y\n    flux_S = -np.roll(mass_flux_y, 1, axis=1) # Inward flux from south is mass_flux_y[i,j-1]\n    \n    # Mismatch at vertical faces: | flux_E[i,j] + flux_W[i+1,j] |\n    # flux_W[i+1,j] is computed by rolling flux_W by -1 along axis 0\n    mismatch_x = np.abs(flux_E + np.roll(flux_W, -1, axis=0))\n\n    # Mismatch at horizontal faces: | flux_N[i,j] + flux_S[i,j+1] |\n    mismatch_y = np.abs(flux_N + np.roll(flux_S, -1, axis=1))\n    \n    r_mismatch = max(np.max(mismatch_x), np.max(mismatch_y))\n\n    # Global Mass Change (r_mass_change)\n    rho_new = rho - (dt / V_cell) * net_flux\n    r_mass_change = np.abs(np.sum(rho_new - rho) * V_cell)\n\n    return r_global, r_mismatch, r_mass_change\n\ndef solve():\n    \"\"\"\n    Sets up and runs the test cases, then prints the results.\n    \"\"\"\n    test_cases = [\n        # Case 1: smooth, divergence-free\n        {\n            \"name\": \"smooth, divergence-free\", \"Nx\": 16, \"Ny\": 16, \"dt\": 1e-3,\n            \"rho_func\": lambda x, y: 1 + 0.2 * np.sin(2 * np.pi * x) * np.cos(2 * np.pi * y),\n            \"ux_func\": lambda x, y: np.sin(2 * np.pi * y),\n            \"uy_func\": lambda x, y: np.sin(2 * np.pi * x),\n        },\n        # Case 2: zero velocity, random density\n        {\n            \"name\": \"zero velocity, random density\", \"Nx\": 16, \"Ny\": 16, \"dt\": 1e-3,\n            \"rho_func\": None, # Will be handled specially\n            \"ux_func\": lambda x, y: 0.0 * x,\n            \"uy_func\": lambda x, y: 0.0 * y,\n        },\n        # Case 3: compressible, smooth\n        {\n            \"name\": \"compressible, smooth\", \"Nx\": 31, \"Ny\": 17, \"dt\": 5e-4,\n            \"rho_func\": lambda x, y: np.exp(0.3 * np.sin(2 * np.pi * x) + 0.3 * np.cos(2 * np.pi * y)),\n            \"ux_func\": lambda x, y: np.cos(2 * np.pi * y) + np.sin(4 * np.pi * x),\n            \"uy_func\": lambda x, y: np.sin(2 * np.pi * x) - np.cos(4 * np.pi * y),\n        },\n        # Case 4: linear fields, compressible\n        {\n            \"name\": \"linear fields, compressible\", \"Nx\": 8, \"Ny\": 12, \"dt\": 2e-3,\n            \"rho_func\": lambda x, y: 0.5 + x,\n            \"ux_func\": lambda x, y: y,\n            \"uy_func\": lambda x, y: -x,\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, Ny = case[\"Nx\"], case[\"Ny\"]\n        dx, dy = 1.0 / Nx, 1.0 / Ny\n        \n        # Create cell-centered coordinates for initial density evaluation\n        x_c = (np.arange(Nx) + 0.5) * dx\n        y_c = (np.arange(Ny) + 0.5) * dy\n        xx_c, yy_c = np.meshgrid(x_c, y_c, indexing='ij')\n\n        if case[\"name\"] == \"zero velocity, random density\":\n            rng = np.random.default_rng(42)\n            rho_initial = rng.random((Nx, Ny))\n        else:\n            rho_initial = case[\"rho_func\"](xx_c, yy_c)\n        \n        res_tuple = run_case(\n            Nx, Ny, case[\"dt\"], rho_initial, \n            case[\"ux_func\"], case[\"uy_func\"]\n        )\n        results.extend(res_tuple)\n    \n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While different mathematical forms of the continuity equation may be equivalent analytically, their numerical discretizations can behave very differently. This exercise provides a crucial lesson by contrasting a conservative finite-volume scheme with a non-conservative semi-Lagrangian scheme for a simple advection problem. You will computationally demonstrate and quantify how failing to discretize the flux-divergence form of the equation leads to artificial mass loss, a critical error in long-term simulations.",
            "id": "4082100",
            "problem": "Consider a one-dimensional periodic domain of length $L$ with spatial coordinate $x \\in [0,L)$. A scalar density field $\\rho(x,t)$ is advected by a prescribed, time-independent velocity field $u(x)$ according to the continuity equation (conservation of mass)\n$$\n\\frac{\\partial \\rho}{\\partial t} + \\frac{\\partial}{\\partial x}(\\rho u) = 0,\n$$\nwith periodic boundary conditions. All quantities are non-dimensional, and no physical units are required.\n\nYour task is to demonstrate, by computational example, that advecting density using a non-conservative scheme leads to artificial loss (or gain) of total mass, and to measure how this mass error scales with grid refinement. Use the following mathematically and computationally well-posed setup:\n\n- Domain length $L = 1$.\n- Velocity field $u(x) = \\tfrac{1}{2} + \\tfrac{1}{2}\\sin(2\\pi x)$, which is strictly positive and spatially varying.\n- Initial density\n$$\n\\rho(x,0) = 1 + 0.3\\sin(2\\pi x) + 0.8\\exp\\!\\left(-\\frac{(x-0.3)^2}{0.01}\\right),\n$$\nwhich is strictly positive and smooth.\n- Total simulation time $T = 1$.\n- Courant–Friedrichs–Lewy (CFL) number $\\mathrm{CFL} = 0.4$, to select the nominal time step $\\Delta t = \\mathrm{CFL}\\,\\Delta x / \\max_x u(x)$, where $\\Delta x = L/N$ and $N$ is the number of grid points. Use $\\Delta t$ repeatedly for as many whole steps as fit into $T$, and then one final step with the remaining time to achieve exactly $T$.\n\nImplement and compare two time-stepping schemes on a uniform grid with $N$ points, with periodic boundary conditions:\n\n1. A non-conservative semi-Lagrangian pointwise advection scheme with first-order backtracking and linear interpolation on the fixed Eulerian grid. For each grid point $x_i$, compute the backtracked foot $x_i^{\\star} = x_i - u(x_i)\\,\\Delta t$ (wrapped periodically), and update $\\rho_i^{n+1}$ by linear interpolation of $\\rho^n$ at $x_i^{\\star}$.\n\n2. A conservative finite-volume upwind flux scheme formulated in flux-divergence form. Discretize the flux at cell faces $x_{i+1/2}$ as $F_{i+1/2} = u(x_{i+1/2})\\,\\rho_i$ for $u(x_{i+1/2}) > 0$ (which holds here), and update cell averages by the flux difference $\\rho_i^{n+1} = \\rho_i^n - (\\Delta t/\\Delta x)\\left(F_{i+1/2} - F_{i-1/2}\\right)$.\n\nFor each $N$, compute the initial total mass $M_0 = \\int_0^L \\rho(x,0)\\,dx$ approximated by the Riemann sum $M_0 \\approx \\sum_i \\rho_i^0\\,\\Delta x$, and the final total masses $M_{\\mathrm{nc}}(T)$ and $M_{\\mathrm{cons}}(T)$ produced by the non-conservative and conservative schemes, respectively. Define the relative mass error for each scheme by $e_{\\mathrm{nc}} = \\lvert M_{\\mathrm{nc}}(T) - M_0 \\rvert / M_0$ and $e_{\\mathrm{cons}} = \\lvert M_{\\mathrm{cons}}(T) - M_0 \\rvert / M_0$, expressed as decimals.\n\nTest Suite:\n\n- Use the grid sizes $N \\in \\{50, 100, 200, 400, 800\\}$.\n- For each $N$, compute $e_{\\mathrm{nc}}$ and $e_{\\mathrm{cons}}$.\n- Estimate the empirical error-scaling exponent $q$ for the non-conservative scheme by fitting a straight line to $\\log(e_{\\mathrm{nc}})$ versus $\\log(\\Delta x)$ across the test suite, so that $e_{\\mathrm{nc}} \\approx C\\,(\\Delta x)^q$.\n\nFinal Output Format:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order:\n$$\n[ e_{\\mathrm{nc}}(N{=}50), e_{\\mathrm{nc}}(N{=}100), e_{\\mathrm{nc}}(N{=}200), e_{\\mathrm{nc}}(N{=}400), e_{\\mathrm{nc}}(N{=}800), q, \\max\\{ e_{\\mathrm{cons}}(N) : N \\in \\{50,100,200,400,800\\} \\} ].\n$$\nAll entries must be decimal numbers (floats). This single-line output is the only required output of the program.",
            "solution": "The problem requires a computational demonstration of mass conservation failure in a non-conservative numerical scheme versus the mass conservation property of a conservative scheme for the one-dimensional continuity equation. We will implement and compare two specified schemes, compute the mass conservation error for a range of grid resolutions, and determine the empirical scaling of the error with the grid spacing for the non-conservative scheme.\n\nThe governing equation is the continuity equation in one dimension, which expresses the conservation of a scalar quantity $\\rho$ (density) being transported by a velocity field $u$:\n$$\n\\frac{\\partial \\rho}{\\partial t} + \\frac{\\partial}{\\partial x}(\\rho u) = 0\n$$\nThis is known as the conservative form, as the spatial derivative acts on the flux, $F = \\rho u$. A key property of this form is that the total mass in a closed or periodic domain, $M = \\int \\rho \\, dx$, is constant over time. This can be seen by integrating the equation over the domain $[0,L]$:\n$$\n\\frac{dM}{dt} = \\frac{d}{dt}\\int_0^L \\rho \\, dx = -\\int_0^L \\frac{\\partial}{\\partial x}(\\rho u) \\, dx = -[\\rho u]_0^L = 0\n$$\nThe final equality holds due to the periodic boundary conditions, where $\\rho(0,t)u(0) = \\rho(L,t)u(L)$. A numerical scheme that directly discretizes this flux-divergence form is called a \"conservative scheme\" and is expected to preserve the discrete total mass to machine precision.\n\nUsing the product rule, the continuity equation can be rewritten in a non-conservative or advective form:\n$$\n\\frac{\\partial \\rho}{\\partial t} + u \\frac{\\partial \\rho}{\\partial x} + \\rho \\frac{\\partial u}{\\partial x} = 0\n$$\nNumerical schemes that approximate a simplified version, such as the simple advection equation $\\frac{\\partial \\rho}{\\partial t} + u \\frac{\\partial \\rho}{\\partial x} = 0$, are termed \"non-conservative\" when the velocity field $u(x)$ is spatially varying. These schemes fail to account for the term $\\rho \\frac{\\partial u}{\\partial x}$, which represents the change in density due to the convergence or divergence of the velocity field. This omission leads to an artificial source or sink of mass, causing the total mass to drift over time.\n\nWe will set up a numerical experiment on a uniform grid with $N$ points, spatial resolution $\\Delta x = L/N$, and cell-centered coordinates $x_i = i \\Delta x$ for $i=0, \\dots, N-1$. The time step $\\Delta t$ is determined by the CFL condition, $\\Delta t = \\mathrm{CFL} \\cdot \\Delta x / \\max_x |u(x)|$. With $L=1$, $\\mathrm{CFL}=0.4$, and $u(x) = \\frac{1}{2} + \\frac{1}{2}\\sin(2\\pi x)$, we find $\\max_x u(x) = 1$, thus $\\Delta t = 0.4 \\Delta x$. The total simulation time $T=1$ is covered by a sequence of time steps.\n\n**1. Non-Conservative Semi-Lagrangian Scheme**\nThis method is based on the Lagrangian perspective of fluid motion. The equation $\\frac{D\\rho}{Dt} = \\frac{\\partial \\rho}{\\partial t} + u \\frac{\\partial \\rho}{\\partial x} = 0$ implies that $\\rho$ is constant along characteristic curves defined by $\\frac{dx}{dt} = u$. To update the density at a fixed Eulerian grid point $x_i$ from time $t^n$ to $t^{n+1} = t^n + \\Delta t$, we trace the characteristic back in time to find the departure point $x_i^\\star$ at time $t^n$. A first-order approximation gives:\n$$\nx_i^\\star = x_i - u(x_i) \\Delta t\n$$\nThe new density at $x_i$ is simply the density at the departure point, $\\rho_i^{n+1} = \\rho^n(x_i^\\star)$. Since $x_i^\\star$ will not in general coincide with a grid point, this value must be found by interpolating the known grid values of $\\rho^n$. The problem specifies linear interpolation. The value $\\rho_i^{n+1}$ is computed by finding the two grid points $x_j$ and $x_{j+1}$ that bracket the periodically wrapped coordinate $x_i^\\star$ and performing linear interpolation between $\\rho_j^n$ and $\\rho_{j+1}^n$. This interpolation step does not enforce the conservation of total mass, and the accumulation of these small errors leads to a significant drift in the total mass over time.\n\n**2. Conservative Finite-Volume Upwind Scheme**\nThis scheme starts from the integral form of the conservation law over each grid cell (control volume) $[x_{i-1/2}, x_{i+1/2}]$, where $x_{i\\pm1/2} = x_i \\pm \\Delta x/2$.\n$$\n\\frac{d}{dt} \\int_{x_{i-1/2}}^{x_{i+1/2}} \\rho \\, dx = (\\rho u)|_{x_{i-1/2}} - (\\rho u)|_{x_{i+1/2}}\n$$\nApproximating the cell-average density $\\rho_i \\approx \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} \\rho \\, dx$ and using a forward Euler time step, we get the discretized flux-divergence form:\n$$\n\\rho_i^{n+1} = \\rho_i^n - \\frac{\\Delta t}{\\Delta x} (F_{i+1/2} - F_{i-1/2})\n$$\nwhere $F_{i\\pm1/2}$ is the numerical flux at the cell face. For the first-order upwind scheme, the flux is determined by the state in the \"upwind\" cell. Since the given velocity field $u(x) \\geq 0$ for all $x$, the flow is always from left to right (or stationary). Thus, the state at any face is determined by the cell to its left:\n$$\nF_{i+1/2} = u(x_{i+1/2}) \\rho_i^n\n$$\nWhen we sum the update rule over all cells $i=0, \\dots, N-1$, the flux differences form a telescoping sum: $\\sum_i (F_{i+1/2} - F_{i-1/2})$. Due to periodicity ($F_{-1/2} = F_{N-1/2}$), this sum is exactly zero. Consequently, $\\sum_i \\rho_i^{n+1} = \\sum_i \\rho_i^n$, and the discrete total mass $M = \\sum_i \\rho_i \\Delta x$ is conserved to the limits of floating-point arithmetic.\n\n**3. Error Analysis**\nFor each grid size $N$, we compute the initial mass $M_0 = \\sum_i \\rho(x_i, 0) \\Delta x$ and the final masses $M_{\\mathrm{nc}}(T)$ and $M_{\\mathrm{cons}}(T)$. The relative mass errors, $e_{\\mathrm{nc}} = |M_{\\mathrm{nc}}(T) - M_0| / M_0$ and $e_{\\mathrm{cons}} = |M_{\\mathrm{cons}}(T) - M_0| / M_0$, are calculated. We expect $e_{\\mathrm{cons}}$ to be near machine epsilon, while $e_{\\mathrm{nc}}$ will be significant and should decrease as the grid is refined.\nTo find the empirical order of convergence $q$ for the non-conservative scheme's mass error, we assume a power-law relationship $e_{\\mathrm{nc}} \\approx C (\\Delta x)^q$, where $C$ is a constant. Taking the logarithm gives a linear relationship:\n$$\n\\log(e_{\\mathrm{nc}}) \\approx \\log(C) + q \\log(\\Delta x)\n$$\nBy performing a linear regression on the computed values of $\\log(e_{\\mathrm{nc}})$ against $\\log(\\Delta x)$ for the given series of grid sizes $N$, the slope of the best-fit line provides an estimate for the scaling exponent $q$.\n\nThe implementation will follow these principles, performing the simulations for the specified range of $N$, calculating the errors, and fitting for $q$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D advection problem using non-conservative and conservative schemes,\n    computes mass errors, and determines the error scaling for the non-conservative scheme.\n    \"\"\"\n    # Problem parameters\n    L = 1.0\n    T = 1.0\n    CFL = 0.4\n    TEST_CASES_N = [50, 100, 200, 400, 800]\n\n    # Field definitions\n    def u_field(x):\n        return 0.5 + 0.5 * np.sin(2 * np.pi * x / L)\n\n    def rho_initial(x):\n        return 1.0 + 0.3 * np.sin(2 * np.pi * x / L) + 0.8 * np.exp(-((x - 0.3*L)**2) / 0.01)\n\n    e_nc_results = []\n    e_cons_results = []\n\n    for N in TEST_CASES_N:\n        # ---- 1. Grid and Initial Conditions Setup ----\n        dx = L / N\n        # Cell-centered grid\n        x_nodes = np.arange(N) * dx\n        \n        # Initial density at cell centers\n        rho0 = rho_initial(x_nodes)\n        \n        # Initial total mass\n        m0 = np.sum(rho0) * dx\n\n        # ---- 2. Time-stepping Setup ----\n        u_max = 1.0  # Max of u_field is 0.5 + 0.5*1 = 1.0\n        dt = CFL * dx / u_max\n        \n        num_steps = int(T / dt)\n        last_dt = T - num_steps * dt\n        \n        timesteps = [dt] * num_steps\n        if last_dt > 1e-12:  # Add final smaller step if needed\n            timesteps.append(last_dt)\n\n        # ---- 3. Simulation Loop ----\n        # Initialize densities for both schemes\n        rho_nc = rho0.copy()\n        rho_cons = rho0.copy()\n\n        # Pre-compute velocities for efficiency\n        # Velocities at cell centers (for non-conservative scheme)\n        u_nodes = u_field(x_nodes)\n        # Velocities at cell faces (for conservative scheme)\n        x_faces = (np.arange(N) + 0.5) * dx\n        u_faces = u_field(x_faces)\n\n        for t_step in timesteps:\n            # --- Update Non-Conservative (Semi-Lagrangian) Scheme ---\n            # Compute departure points\n            x_star = x_nodes - u_nodes * t_step\n            # Linearly interpolate to find new density. np.interp handles periodicity.\n            rho_nc = np.interp(x_star, x_nodes, rho_nc, period=L)\n\n            # --- Update Conservative (Finite-Volume Upwind) Scheme ---\n            # Flux at right face of each cell i (F_{i+1/2})\n            # Upwind flux uses rho_i since u >= 0\n            flux_right = u_faces * rho_cons\n            # Flux at left face of each cell i (F_{i-1/2})\n            flux_left = np.roll(flux_right, 1) # Get F_{i-1/2} by rolling F_{j+1/2}\n            \n            # Update cell average density\n            rho_cons -= (t_step / dx) * (flux_right - flux_left)\n\n        # ---- 4. Post-processing for this N ----\n        # Final total mass\n        m_nc_final = np.sum(rho_nc) * dx\n        m_cons_final = np.sum(rho_cons) * dx\n\n        # Relative mass error\n        e_nc = np.abs(m_nc_final - m0) / m0\n        e_cons = np.abs(m_cons_final - m0) / m0\n\n        e_nc_results.append(e_nc)\n        e_cons_results.append(e_cons)\n\n    # ---- 5. Empirical Error Scaling Analysis ----\n    dx_values = L / np.array(TEST_CASES_N)\n    log_dx = np.log(dx_values)\n    log_e_nc = np.log(np.array(e_nc_results))\n    \n    # Fit log(error) vs log(dx) to a line y = mx + c. The slope m is the order q.\n    q_exponent, _ = np.polyfit(log_dx, log_e_nc, 1)\n\n    # Get the maximum error for the conservative scheme\n    max_e_cons = np.max(e_cons_results)\n\n    # ---- 6. Final Output ----\n    final_results = e_nc_results + [q_exponent, max_e_cons]\n    \n    # Format the numbers to a reasonable precision for consistent output\n    formatted_results = [f\"{val:.10f}\" for val in final_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        },
        {
            "introduction": "For incompressible flows, the conservation of mass simplifies to the kinematic constraint that the velocity field must be divergence-free, $\\nabla \\cdot \\mathbf{u} = 0$. This advanced practice introduces the projection method, a cornerstone algorithm in incompressible computational fluid dynamics used to enforce this constraint. You will implement a highly accurate spectral projection method using the Fast Fourier Transform (FFT) to guarantee that the velocity field is discretely divergence-free to machine precision.",
            "id": "4082126",
            "problem": "You are asked to design and implement a mass-conservative projection step in a fractional-step method for incompressible complex fluids that enforces the discrete conservation of mass at the new time level. Starting from the conservation of mass and the definition of incompressibility, construct a projection that maps an intermediate velocity field to a divergence-free field on a two-dimensional periodic domain. The domain is the unit torus with periodic boundary conditions, namely $[0,1]^2$, discretized on a uniform grid with $N_x$ points in the $x$-direction and $N_y$ points in the $y$-direction. The intermediate velocity field at time level $n$ after the explicit non-pressure update is denoted by $\\mathbf{u}^\\star(x,y) = (u^\\star(x,y), v^\\star(x,y))$, and the objective is to produce $\\mathbf{u}^{n+1}(x,y)$ satisfying $\\nabla \\cdot \\mathbf{u}^{n+1}(x,y) = 0$ at the discrete level to machine precision.\n\nYour construction must be based on a consistent pair of discrete gradient and divergence operators that are adjoint on the periodic grid so that the projection step enforces the discrete continuity equation exactly up to floating-point rounding. This step must conceptually solve a discrete Poisson equation for a scalar potential that corrects the intermediate velocity and guarantees a divergence-free result. The core scientific base must begin from the law of conservation of mass and the definition of incompressibility. No shortcut formulas are permitted in the problem statement; derive what is needed in your solution.\n\nImplement your projection in a way that is reproducible and numerically robust on the periodic unit square. All computations are to be non-dimensional. Angles, if any, are interpreted implicitly in radians because the functions employed are trigonometric in the standard mathematical sense; however, you do not need to report any angles in the output.\n\nYour program must:\n- Construct the test velocity fields $\\mathbf{u}^\\star(x,y)$ on given grids.\n- Apply your mass-conservative projection to obtain $\\mathbf{u}^{n+1}(x,y)$.\n- Compute the discrete divergence of $\\mathbf{u}^{n+1}(x,y)$ using the same discrete operators that underlie your projection mechanism.\n- Report, for each test case, the maximum absolute value of the discrete divergence over the grid as a floating-point number.\n\nTest suite:\n- Case $1$: $N_x = 32$, $N_y = 32$. Define $x_i = i/N_x$, $y_j = j/N_y$ for integers $i \\in \\{0,\\dots,N_x-1\\}$ and $j \\in \\{0,\\dots,N_y-1\\}$. Let the scalar field $\\psi(x,y) = \\sin(2\\pi x)\\cos(2\\pi y)$ and $\\phi(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$. Define a potential-flow gradient component $\\mathbf{u}_{\\mathrm{grad}} = \\nabla \\psi$ and a divergence-free rotational component $\\mathbf{u}_{\\mathrm{vort}} = (-\\partial_y \\phi, \\partial_x \\phi)$. Set $\\mathbf{u}^\\star = \\mathbf{u}_{\\mathrm{grad}} + \\mathbf{u}_{\\mathrm{vort}} + 0.1\\,\\boldsymbol{\\eta}$, where $\\boldsymbol{\\eta}$ is a deterministic pseudorandom field drawn from a standard normal distribution with seed set to $0$ and shaped to $(N_x,N_y)$ for each component.\n- Case $2$: $N_x = 33$, $N_y = 17$. Let $\\mathbf{u}^\\star = \\boldsymbol{\\eta} + \\mathbf{c}$, where $\\boldsymbol{\\eta}$ is as above but with seed set to $0$, and $\\mathbf{c} = (1.5, -0.75)$ is a constant uniform velocity vector.\n- Case $3$: $N_x = 64$, $N_y = 64$. Let $\\psi(x,y) = \\cos(4\\pi x)\\sin(2\\pi y)$ and set $\\mathbf{u}^\\star = \\nabla \\psi$ (a pure gradient field).\n- Case $4$: $N_x = 8$, $N_y = 8$. Let $\\phi(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$ and set $\\mathbf{u}^\\star = 3\\,(-\\partial_y \\phi, \\partial_x \\phi)$ (a scaled divergence-free field).\n- Case $5$: $N_x = 16$, $N_y = 24$. Let $\\mathbf{u}^\\star = \\boldsymbol{\\eta}$ with seed set to $42$ and components drawn from a standard normal distribution.\n\nDefinitions and requirements:\n- Use the discrete Fourier transform consistent with periodic boundary conditions to realize the discrete gradient, divergence, and the solution of the Poisson equation. Use Fast Fourier Transform (FFT) as the numerical mechanism for transforms.\n- The discrete divergence must be computed spectrally using the same wavenumbers employed in the projection construction, ensuring adjointness and exact cancellation up to floating point.\n- For each case, compute the maximum absolute discrete divergence of $\\mathbf{u}^{n+1}$ and return it as a floating-point value.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[\\mathrm{result}_1,\\mathrm{result}_2,\\mathrm{result}_3,\\mathrm{result}_4,\\mathrm{result}_5]$). Each result must be a floating-point number.",
            "solution": "The problem requires the design and implementation of a mass-conservative projection step for an incompressible fluid on a two-dimensional periodic domain. The solution must be derived from first principles, specifically the conservation of mass, and implemented using spectral methods based on the Fast Fourier Transform (FFT).\n\nThe fundamental principle governing fluid motion is the conservation of mass, expressed by the continuity equation:\n$$\n\\frac{\\partial \\rho}{\\partial t} + \\nabla \\cdot (\\rho \\mathbf{u}) = 0\n$$\nwhere $\\rho$ is the fluid density and $\\mathbf{u}$ is the velocity field. For a complex fluid treated as incompressible, the density $\\rho$ is assumed to be constant in both space and time. Consequently, its partial derivatives are zero, $\\frac{\\partial \\rho}{\\partial t} = 0$ and $\\nabla \\rho = \\mathbf{0}$. The continuity equation simplifies to:\n$$\n\\rho (\\nabla \\cdot \\mathbf{u}) = 0\n$$\nSince $\\rho > 0$, this yields the incompressibility constraint, which is a kinematic condition on the velocity field:\n$$\n\\nabla \\cdot \\mathbf{u} = 0\n$$\nThis equation states that the velocity field of an incompressible flow must be divergence-free.\n\nFractional-step methods, or projection methods, are commonly used to solve the time-dependent Navier-Stokes equations for incompressible flows. They decouple the computation of velocity and pressure. In a typical two-step scheme, an intermediate velocity field, denoted $\\mathbf{u}^\\star$, is first computed at time level $n+1$ by advancing the momentum equation without the pressure gradient term. This field $\\mathbf{u}^\\star$ will not, in general, satisfy the incompressibility constraint.\n\nThe second step, the projection step, corrects $\\mathbf{u}^\\star$ to produce a velocity field $\\mathbf{u}^{n+1}$ that is discretely divergence-free. This is achieved by incorporating the effect of the pressure gradient. The correction is given by:\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^\\star}{\\Delta t} = -\\nabla p^{n+1}\n$$\nwhere $p^{n+1}$ is related to the pressure and $\\Delta t$ is the time step. For our non-dimensional problem, we can absorb $\\Delta t$ into a scalar potential, $\\Phi$, such that the update is:\n$$\n\\mathbf{u}^{n+1} = \\mathbf{u}^\\star - \\nabla \\Phi\n$$\nThis is a statement of the Helmholtz-Hodge decomposition, which states that any vector field $\\mathbf{u}^\\star$ can be uniquely decomposed into a divergence-free component ($\\mathbf{u}^{n+1}$) and a curl-free (gradient) component ($\\nabla \\Phi$).\n\nTo find the potential $\\Phi$, we enforce the incompressibility constraint on the final velocity field, $\\nabla \\cdot \\mathbf{u}^{n+1} = 0$. Applying the divergence operator to the correction equation, we get:\n$$\n\\nabla \\cdot \\mathbf{u}^{n+1} = \\nabla \\cdot \\mathbf{u}^\\star - \\nabla \\cdot (\\nabla \\Phi)\n$$\nSetting $\\nabla \\cdot \\mathbf{u}^{n+1} = 0$ leads to a Poisson equation for the scalar potential $\\Phi$:\n$$\n\\nabla^2 \\Phi = \\nabla \\cdot \\mathbf{u}^\\star\n$$\nSolving this equation for $\\Phi$ allows us to compute the gradient $\\nabla \\Phi$ and subsequently the final divergence-free velocity field $\\mathbf{u}^{n+1}$.\n\nFor the specified periodic domain $[0,1]^2$, spectral methods using the Discrete Fourier Transform (DFT) are exceptionally well-suited due to their high accuracy and the efficiency of the FFT algorithm. In Fourier space, differential operators become algebraic multiplication operators. A function $f(x,y)$ on the grid is transformed to its Fourier coefficients $\\hat{f}(k_x, k_y)$, where $k_x$ and $k_y$ are the wavenumbers. The derivative operators transform as:\n$$\n\\mathcal{F}\\left(\\frac{\\partial f}{\\partial x}\\right) = i k_x \\hat{f} \\quad \\text{and} \\quad \\mathcal{F}\\left(\\frac{\\partial f}{\\partial y}\\right) = i k_y \\hat{f}\n$$\nwhere $\\mathcal{F}$ denotes the Fourier transform.\n\nThe discrete wavenumbers for a domain of size $L_x=1$, $L_y=1$ with $N_x$ and $N_y$ points are given by $k_x = 2\\pi m$ and $k_y = 2\\pi n$ for integer modes $m$ and $n$. These are calculated using `scipy.fft.fftfreq`. Specifically, $k_x = 2\\pi \\times \\text{fftfreq}(N_x, 1/N_x)$ and $k_y = 2\\pi \\times \\text{fftfreq}(N_y, 1/N_y)$.\n\nApplying the Fourier transform to the Poisson equation $\\nabla^2 \\Phi = \\nabla \\cdot \\mathbf{u}^\\star$:\n$$\n\\mathcal{F}(\\nabla^2 \\Phi) = \\mathcal{F}(\\nabla \\cdot \\mathbf{u}^\\star)\n$$\nThe left-hand side becomes:\n$$\n\\mathcal{F}(\\nabla^2 \\Phi) = \\mathcal{F}\\left(\\frac{\\partial^2 \\Phi}{\\partial x^2} + \\frac{\\partial^2 \\Phi}{\\partial y^2}\\right) = ((ik_x)^2 + (ik_y)^2)\\hat{\\Phi} = -(k_x^2 + k_y^2)\\hat{\\Phi}\n$$\nThe right-hand side, the divergence of $\\mathbf{u}^\\star = (u^\\star, v^\\star)$, becomes:\n$$\n\\mathcal{F}(\\nabla \\cdot \\mathbf{u}^\\star) = \\mathcal{F}\\left(\\frac{\\partial u^\\star}{\\partial x} + \\frac{\\partial v^\\star}{\\partial y}\\right) = i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star\n$$\nCombining these yields the algebraic equation for $\\hat{\\Phi}$ in Fourier space:\n$$\n-(k_x^2 + k_y^2)\\hat{\\Phi} = i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star\n$$\nWe can solve for $\\hat{\\Phi}$:\n$$\n\\hat{\\Phi}(k_x, k_y) = - \\frac{i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star}{k_x^2 + k_y^2}\n$$\nA special case arises for the zero-wavenumber mode $(k_x, k_y) = (0,0)$, where the denominator $k_x^2+k_y^2$ is zero. This mode corresponds to the mean value of the fields. For this mode, the numerator is also zero, $i(0)\\hat{u}^\\star_{0,0} + i(0)\\hat{v}^\\star_{0,0} = 0$. This $0/0$ indeterminacy reflects that the potential $\\Phi$ is determined only up to an arbitrary constant. We can resolve this by setting $\\hat{\\Phi}(0,0) = 0$, which corresponds to choosing the unique potential with a zero spatial mean.\n\nOnce $\\hat{\\Phi}$ is known, we find the Fourier transform of the projected velocity $\\mathbf{u}^{n+1} = \\mathbf{u}^\\star - \\nabla \\Phi$:\n$$\n\\hat{u}^{n+1} = \\hat{u}^\\star - i k_x \\hat{\\Phi}\n$$\n$$\n\\hat{v}^{n+1} = \\hat{v}^\\star - i k_y \\hat{\\Phi}\n$$\nFinally, the real-space velocity field $\\mathbf{u}^{n+1}$ is recovered by applying the inverse Fourier transform $\\mathcal{F}^{-1}$.\n\nTo verify the result, we compute the discrete divergence of $\\mathbf{u}^{n+1}$ using the same spectral operator. In Fourier space, this is:\n$$\n\\widehat{\\nabla \\cdot \\mathbf{u}^{n+1}} = i k_x \\hat{u}^{n+1} + i k_y \\hat{v}^{n+1}\n$$\nSubstituting the expressions for $\\hat{u}^{n+1}$ and $\\hat{v}^{n+1}$:\n$$\n\\widehat{\\nabla \\cdot \\mathbf{u}^{n+1}} = i k_x (\\hat{u}^\\star - i k_x \\hat{\\Phi}) + i k_y (\\hat{v}^\\star - i k_y \\hat{\\Phi})\n= (i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star) - ( (ik_x)^2 + (ik_y)^2 ) \\hat{\\Phi}\n= (i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star) + (k_x^2 + k_y^2) \\hat{\\Phi}\n$$\nSubstituting the solution for $\\hat{\\Phi}$:\n$$\n= (i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star) + (k_x^2 + k_y^2) \\left( - \\frac{i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star}{k_x^2 + k_y^2} \\right) = 0\n$$\nThis holds for all $(k_x, k_y) \\neq (0,0)$. For $(k_x, k_y)=(0,0)$, all terms are zero. Thus, the divergence of the projected field is analytically zero in Fourier space. Its inverse transform will be zero up to floating-point rounding errors. The maximum absolute value of this field is the required output.",
            "answer": "```python\nimport numpy as np\nimport scipy.fft\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n\n    test_cases = [\n        {'Nx': 32, 'Ny': 32, 'case_type': 'grad_vort_noise', 'seed': 0},\n        {'Nx': 33, 'Ny': 17, 'case_type': 'noise_const', 'seed': 0},\n        {'Nx': 64, 'Ny': 64, 'case_type': 'pure_grad', 'seed': None},\n        {'Nx': 8, 'Ny': 8, 'case_type': 'pure_vort', 'seed': None},\n        {'Nx': 16, 'Ny': 24, 'case_type': 'pure_noise', 'seed': 42},\n    ]\n\n    results = []\n    for params in test_cases:\n        result = _solve_single_case(params)\n        results.append(result)\n\n    print(f\"[{','.join(f'{r:.16e}' for r in results)}]\")\n\ndef _solve_single_case(params):\n    \"\"\"\n    Solves a single test case for the projection problem.\n    \"\"\"\n    Nx = params['Nx']\n    Ny = params['Ny']\n    case_type = params['case_type']\n    seed = params['seed']\n    \n    # 1. Construct the grid\n    x = np.arange(Nx) / Nx\n    y = np.arange(Ny) / Ny\n    xx, yy = np.meshgrid(x, y, indexing='ij')\n\n    # 2. Construct the intermediate velocity field u_star\n    pi = np.pi\n    u_star, v_star = None, None\n    rng = np.random.default_rng(seed) if seed is not None else None\n\n    if case_type == 'grad_vort_noise':\n        # Case 1: Grad + Vort + Noise\n        psi = np.sin(2 * pi * xx) * np.cos(2 * pi * yy)\n        dpsi_dx = 2 * pi * np.cos(2 * pi * xx) * np.cos(2 * pi * yy)\n        dpsi_dy = -2 * pi * np.sin(2 * pi * xx) * np.sin(2 * pi * yy)\n\n        phi_vort = np.sin(2 * pi * xx) * np.sin(2 * pi * yy)\n        dphi_dx = 2 * pi * np.cos(2 * pi * xx) * np.sin(2 * pi * yy)\n        dphi_dy = 2 * pi * np.sin(2 * pi * xx) * np.cos(2 * pi * yy)\n        \n        eta_x = rng.standard_normal(size=(Nx, Ny))\n        eta_y = rng.standard_normal(size=(Nx, Ny))\n\n        u_star = dpsi_dx - dphi_dy + 0.1 * eta_x\n        v_star = dpsi_dy + dphi_dx + 0.1 * eta_y\n\n    elif case_type == 'noise_const':\n        # Case 2: Noise + Constant\n        c = (1.5, -0.75)\n        eta_x = rng.standard_normal(size=(Nx, Ny))\n        eta_y = rng.standard_normal(size=(Nx, Ny))\n        u_star = eta_x + c[0]\n        v_star = eta_y + c[1]\n\n    elif case_type == 'pure_grad':\n        # Case 3: Pure gradient field\n        psi = np.cos(4 * pi * xx) * np.sin(2 * pi * yy)\n        u_star = -4 * pi * np.sin(4 * pi * xx) * np.sin(2 * pi * yy)\n        v_star = 2 * pi * np.cos(4 * pi * xx) * np.cos(2 * pi * yy)\n\n    elif case_type == 'pure_vort':\n        # Case 4: Purely rotational (divergence-free) field\n        phi_vort = np.sin(2 * pi * xx) * np.sin(2 * pi * yy)\n        dphi_dx = 2 * pi * np.cos(2 * pi * xx) * np.sin(2 * pi * yy)\n        dphi_dy = 2 * pi * np.sin(2 * pi * xx) * np.cos(2 * pi * yy)\n        u_star = 3.0 * (-dphi_dy)\n        v_star = 3.0 * (dphi_dx)\n\n    elif case_type == 'pure_noise':\n        # Case 5: Pure noise\n        u_star = rng.standard_normal(size=(Nx, Ny))\n        v_star = rng.standard_normal(size=(Nx, Ny))\n    \n    # 3. Perform the projection\n    u_proj, v_proj = _project_velocity(u_star, v_star, Nx, Ny)\n\n    # 4. Compute the divergence of the projected field\n    divergence_field = _calculate_divergence(u_proj, v_proj, Nx, Ny)\n\n    # 5. Return the maximum absolute divergence\n    return np.max(np.abs(divergence_field))\n\ndef _project_velocity(u, v, Nx, Ny):\n    \"\"\"\n    Projects a velocity field (u, v) onto its divergence-free part.\n    \"\"\"\n    # Create wavenumber grids\n    kx_1d = 2 * np.pi * scipy.fft.fftfreq(Nx, d=1.0/Nx)\n    ky_1d = 2 * np.pi * scipy.fft.fftfreq(Ny, d=1.0/Ny)\n    kx, ky = np.meshgrid(kx_1d, ky_1d, indexing='ij')\n\n    # FFT of the velocity field\n    u_hat = scipy.fft.fft2(u)\n    v_hat = scipy.fft.fft2(v)\n\n    # Compute FFT of divergence of (u, v)\n    div_u_hat = 1j * kx * u_hat + 1j * ky * v_hat\n\n    # Solve Poisson equation for the potential phi in Fourier space\n    k_squared = kx**2 + ky**2\n    # Handle the k=0 mode to avoid division by zero\n    k_squared[0, 0] = 1.0  # Denominator is non-zero\n    \n    phi_hat = -div_u_hat / k_squared\n    # The numerator at k=0 is already zero, so this enforces phi_hat(0,0)=0\n\n    # Correct the velocity field in Fourier space\n    u_proj_hat = u_hat - 1j * kx * phi_hat\n    v_proj_hat = v_hat - 1j * ky * phi_hat\n\n    # Inverse FFT to get the projected velocity field in real space\n    u_proj = scipy.fft.ifft2(u_proj_hat).real\n    v_proj = scipy.fft.ifft2(v_proj_hat).real\n    \n    return u_proj, v_proj\n\ndef _calculate_divergence(u, v, Nx, Ny):\n    \"\"\"\n    Computes the divergence of a velocity field (u, v) using spectral methods.\n    \"\"\"\n    # Create wavenumber grids\n    kx_1d = 2 * np.pi * scipy.fft.fftfreq(Nx, d=1.0/Nx)\n    ky_1d = 2 * np.pi * scipy.fft.fftfreq(Ny, d=1.0/Ny)\n    kx, ky = np.meshgrid(kx_1d, ky_1d, indexing='ij')\n\n    # FFT of the velocity field\n    u_hat = scipy.fft.fft2(u)\n    v_hat = scipy.fft.fft2(v)\n\n    # Compute divergence in Fourier space\n    div_u_hat = 1j * kx * u_hat + 1j * ky * v_hat\n\n    # Inverse FFT to get divergence in real space\n    divergence = scipy.fft.ifft2(div_u_hat).real\n    \n    return divergence\n\nsolve()\n```"
        }
    ]
}