{
    "hands_on_practices": [
        {
            "introduction": "有限体积法的核心在于离散控制体上的守恒原理，而守恒量在这些控制体之间的交换是通过它们共享界面上的通量来实现的。这个练习将引导你对单个控制体界面上的对流-扩散组合通量进行具体的动手计算。通过手动应用一阶迎风格式和中心差分等标准离散格式，你将巩固对如何将抽象的守恒定律转化为可计算的数值的理解，而这正是任何有限体积法模拟的基础构件 。",
            "id": "4087700",
            "problem": "考虑一个无源标量场 $\\phi$，它代表在密度为 $\\rho$ 的稳态、不可压缩复杂流体中输运的胶束质量分数（无量纲）。两个相邻的有限体积共享一个面积为 $A_f$ 的平面 $f$，其外向单位法向量 $\\boldsymbol{n}_f$ 是相对于左侧单元 $L$ 定义的。面面积矢量为 $\\boldsymbol{S}_f = A_f \\boldsymbol{n}_f$。左侧和右侧单元的中心分别位于位置 $\\boldsymbol{x}_L$ 和 $\\boldsymbol{x}_R$，面心速度为 $\\boldsymbol{u}_f$。材料扩散率为 $D$（菲克扩散），因此守恒形式 $\\nabla \\cdot (\\Gamma \\nabla \\phi)$ 中的扩散输运系数为 $\\Gamma = \\rho D$。\n\n给定：\n- $\\rho = 1050\\,\\mathrm{kg\\,m^{-3}}$，\n- $\\boldsymbol{u}_f = (0.6,\\,0.2,\\,0.1)\\,\\mathrm{m\\,s^{-1}}$，\n- $A_f = 0.010\\,\\mathrm{m^2}$，\n- $\\boldsymbol{n}_f = \\frac{1}{\\sqrt{11}}(3,\\,1,\\,1)$，\n- $\\boldsymbol{x}_L = (0.010,\\,0.020,\\,0.000)\\,\\mathrm{m}$，\n- $\\boldsymbol{x}_R = (0.022,\\,0.025,\\,0.003)\\,\\mathrm{m}$，\n- $\\phi_L = 0.24$，$\\phi_R = 0.18$，\n- $D = 2.0 \\times 10^{-9}\\,\\mathrm{m^2\\,s^{-1}}$。\n\n从左侧控制体积上 $\\phi$ 的积分守恒定律和扩散通量的本构关系（菲克定律）出发，推导离开单元 $L$、穿过面 $f$ 的对流-扩散通量，该通量为对流贡献和扩散贡献之和。采用以下在有限体积法（FVM）中标准的建模和离散化假设：\n- 面上的对流值 $\\phi_f$ 是根据穿过该面的质量流率的符号，通过一阶迎风格式获得的。\n- 面法向扩散通量使用两点近似，该近似基于 $\\phi$ 在 $\\boldsymbol{x}_L$ 和 $\\boldsymbol{x}_R$ 之间的线性变化，以及单元中心连线矢量在面法线上的投影。\n- 忽略超出此投影的任何非正交修正。\n\n将来自面 $f$ 的左侧单元残差贡献定义为离开单元 $L$、穿过面 $f$ 的净向外通量。计算这个单一的数值。将最终数值答案四舍五入到四位有效数字，并以 $\\mathrm{kg\\,s^{-1}}$ 为单位表示。",
            "solution": "首先根据指定标准对问题进行验证。\n给定的参数逐字提取如下：\n- 密度：$\\rho = 1050\\,\\mathrm{kg\\,m^{-3}}$\n- 面心速度：$\\boldsymbol{u}_f = (0.6,\\,0.2,\\,0.1)\\,\\mathrm{m\\,s^{-1}}$\n- 面面积：$A_f = 0.010\\,\\mathrm{m^2}$\n- 面外向单位法向量（从单元 $L$）：$\\boldsymbol{n}_f = \\frac{1}{\\sqrt{11}}(3,\\,1,\\,1)$\n- 左侧单元中心位置：$\\boldsymbol{x}_L = (0.010,\\,0.020,\\,0.000)\\,\\mathrm{m}$\n- 右侧单元中心位置：$\\boldsymbol{x}_R = (0.022,\\,0.025,\\,0.003)\\,\\mathrm{m}$\n- 左侧和右侧单元标量值：$\\phi_L = 0.24$，$\\phi_R = 0.18$\n- 材料扩散率：$D = 2.0 \\times 10^{-9}\\,\\mathrm{m^2\\,s^{-1}}$\n- 扩散输运系数：$\\Gamma = \\rho D$\n- 对流通量离散化：一阶迎风格式。\n- 扩散通量离散化：使用单元中心连线矢量在面法线上的投影进行两点近似。\n\n验证：\n该问题具有科学依据，使用计算流体动力学的基石——有限体积法，描述了一个标准的输运现象（对流-扩散）。所有术语都已定义，物理原理（菲克定律、质量守恒）均为标准。问题是适定的，因为计算唯一数值答案所需的所有数据和离散化方案都已提供。语言客观、精确。未发现违反验证标准的情况。该问题被认为是有效的。\n\n在控制体积 $V$ 上，无源标量 $\\phi$ 的稳态积分守恒定律由下式给出：\n$$ \\oint_{\\partial V} (\\rho \\phi \\boldsymbol{u} - \\Gamma \\nabla\\phi) \\cdot d\\boldsymbol{S} = 0 $$\n积分内的项是总通量矢量 $\\boldsymbol{F} = \\rho \\phi \\boldsymbol{u} - \\Gamma \\nabla\\phi$。题目要求的是来自面 $f$ 的左侧单元 $L$ 的“残差贡献”，其定义为离开单元 $L$、穿过面 $f$ 的净向外通量。我们将这个量记为 $F_f$，它是通量矢量在面面积 $A_f$ 上的面积分。使用标准的有限体积近似，该积分近似为：\n$$ F_f \\approx \\boldsymbol{F}_f \\cdot \\boldsymbol{S}_f = (\\rho \\phi \\boldsymbol{u})_f \\cdot \\boldsymbol{S}_f - (\\Gamma \\nabla\\phi)_f \\cdot \\boldsymbol{S}_f $$\n其中 $\\boldsymbol{S}_f = A_f \\boldsymbol{n}_f$ 是面面积矢量，下标 $f$ 表示在面中心处求得的值。我们可以将其分解为对流贡献 $F_{f, \\text{adv}}$ 和扩散贡献 $F_{f, \\text{diff}}$。注意，扩散通量矢量为 $\\boldsymbol{j}_d = -\\Gamma \\nabla\\phi$，因此对向外通量的扩散贡献是 $(-\\Gamma\\nabla\\phi)_f \\cdot \\boldsymbol{S}_f$。\n$$ F_f = F_{f, \\text{adv}} + F_{f, \\text{diff}} $$\n其中\n$$ F_{f, \\text{adv}} = (\\rho \\boldsymbol{u})_f \\cdot \\boldsymbol{S}_f \\phi_f $$\n$$ F_{f, \\text{diff}} = -(\\Gamma \\nabla\\phi)_f \\cdot \\boldsymbol{S}_f $$\n\n首先，我们计算对流通量 $F_{f, \\text{adv}}$。这需要穿过面的质量流率 $\\dot{m}_f$ 和面上的标量值 $\\phi_f$。\n质量流率为 $\\dot{m}_f = \\rho \\boldsymbol{u}_f \\cdot \\boldsymbol{S}_f = \\rho A_f (\\boldsymbol{u}_f \\cdot \\boldsymbol{n}_f)$。\n让我们计算点积 $\\boldsymbol{u}_f \\cdot \\boldsymbol{n}_f$：\n$$ \\boldsymbol{u}_f \\cdot \\boldsymbol{n}_f = (0.6, 0.2, 0.1) \\cdot \\frac{1}{\\sqrt{11}}(3, 1, 1) = \\frac{1}{\\sqrt{11}}(0.6 \\times 3 + 0.2 \\times 1 + 0.1 \\times 1) = \\frac{1}{\\sqrt{11}}(1.8 + 0.2 + 0.1) = \\frac{2.1}{\\sqrt{11}} \\,\\mathrm{m\\,s^{-1}} $$\n现在，我们计算 $\\dot{m}_f$：\n$$ \\dot{m}_f = \\rho A_f (\\boldsymbol{u}_f \\cdot \\boldsymbol{n}_f) = (1050\\,\\mathrm{kg\\,m^{-3}}) \\times (0.010\\,\\mathrm{m^2}) \\times \\left(\\frac{2.1}{\\sqrt{11}}\\,\\mathrm{m\\,s^{-1}}\\right) = \\frac{10.5 \\times 2.1}{\\sqrt{11}} = \\frac{22.05}{\\sqrt{11}}\\,\\mathrm{kg\\,s^{-1}} $$\n由于 $\\dot{m}_f > 0$，质量流从单元 $L$ 指向外。一阶迎风格式规定，面上的对流标量值 $\\phi_f$ 取自上游单元，即单元 $L$。\n$$ \\phi_f = \\phi_L = 0.24 $$\n对流通量为：\n$$ F_{f, \\text{adv}} = \\dot{m}_f \\phi_f = \\left(\\frac{22.05}{\\sqrt{11}}\\right) \\times 0.24 = \\frac{5.292}{\\sqrt{11}}\\,\\mathrm{kg\\,s^{-1}} $$\n\n接下来，我们计算扩散通量 $F_{f, \\text{diff}} = -(\\Gamma \\nabla\\phi)_f \\cdot \\boldsymbol{S}_f = -\\Gamma A_f ((\\nabla\\phi)_f \\cdot \\boldsymbol{n}_f)$。题目指定使用两点模板和单元中心连线矢量在面法线上的投影来近似面法向梯度 $(\\nabla\\phi)_f \\cdot \\boldsymbol{n}_f$。\n连接单元中心的矢量是 $\\boldsymbol{d}_{LR} = \\boldsymbol{x}_R - \\boldsymbol{x}_L$：\n$$ \\boldsymbol{d}_{LR} = (0.022 - 0.010, 0.025 - 0.020, 0.003 - 0.000) = (0.012, 0.005, 0.003)\\,\\mathrm{m} $$\n用于梯度近似的有效距离是 $\\boldsymbol{d}_{LR}$ 在 $\\boldsymbol{n}_f$ 上的投影，我们记为 $d_n$：\n$$ d_n = \\boldsymbol{d}_{LR} \\cdot \\boldsymbol{n}_f = (0.012, 0.005, 0.003) \\cdot \\frac{1}{\\sqrt{11}}(3, 1, 1) = \\frac{1}{\\sqrt{11}}(0.012 \\times 3 + 0.005 \\times 1 + 0.003 \\times 1) = \\frac{0.036 + 0.005 + 0.003}{\\sqrt{11}} = \\frac{0.044}{\\sqrt{11}}\\,\\mathrm{m} $$\n面法向梯度近似为：\n$$ (\\nabla\\phi)_f \\cdot \\boldsymbol{n}_f \\approx \\frac{\\phi_R - \\phi_L}{d_n} = \\frac{0.18 - 0.24}{0.044/\\sqrt{11}} = \\frac{-0.06\\sqrt{11}}{0.044}\\,\\mathrm{m^{-1}} $$\n扩散输运系数为 $\\Gamma = \\rho D$：\n$$ \\Gamma = (1050\\,\\mathrm{kg\\,m^{-3}}) \\times (2.0 \\times 10^{-9}\\,\\mathrm{m^2\\,s^{-1}}) = 2100 \\times 10^{-9} = 2.1 \\times 10^{-6}\\,\\mathrm{kg\\,m^{-1}\\,s^{-1}} $$\n现在计算扩散通量：\n$$ F_{f, \\text{diff}} = -\\Gamma A_f \\left(\\frac{\\phi_R - \\phi_L}{d_n}\\right) = -(2.1 \\times 10^{-6}\\,\\mathrm{kg\\,m^{-1}\\,s^{-1}}) \\times (0.010\\,\\mathrm{m^2}) \\times \\left(\\frac{-0.06\\sqrt{11}}{0.044}\\,\\mathrm{m^{-1}}\\right) $$\n$$ F_{f, \\text{diff}} = (2.1 \\times 10^{-8}) \\times \\frac{0.06\\sqrt{11}}{0.044}\\,\\mathrm{kg\\,s^{-1}} = \\frac{0.126\\sqrt{11}}{0.044} \\times 10^{-8}\\,\\mathrm{kg\\,s^{-1}} $$\n\n从单元 $L$ 穿过面 $f$ 的总净向外通量是对流通量和扩散通量之和：\n$$ F_f = F_{f, \\text{adv}} + F_{f, \\text{diff}} = \\frac{5.292}{\\sqrt{11}} + \\frac{0.126\\sqrt{11}}{0.044} \\times 10^{-8}\\,\\mathrm{kg\\,s^{-1}} $$\n现在，我们对该表达式进行数值计算：\n$$ \\sqrt{11} \\approx 3.31662479 $$\n$$ F_{f, \\text{adv}} \\approx \\frac{5.292}{3.31662479} \\approx 1.59554709\\,\\mathrm{kg\\,s^{-1}} $$\n$$ F_{f, \\text{diff}} \\approx \\frac{0.126 \\times 3.31662479}{0.044} \\times 10^{-8} \\approx \\frac{0.4178947}{0.044} \\times 10^{-8} \\approx 9.497607 \\times 10^{-8}\\,\\mathrm{kg\\,s^{-1}} $$\n$$ F_f \\approx 1.59554709 + 0.00000009497607 = 1.595547185\\,\\mathrm{kg\\,s^{-1}} $$\n题目要求将最终答案四舍五入到四位有效数字。\n$$ F_f \\approx 1.596\\,\\mathrm{kg\\,s^{-1}} $$",
            "answer": "$$ \\boxed{1.596} $$"
        },
        {
            "introduction": "虽然一阶迎风格式简单且稳健，但它并非没有缺点。其最显著的弊端之一是会引入人为的数值扩散，这会模糊解中的尖锐特征。本实践将从单个通量计算转向完整的线性平流方程模拟。你将通过实现一阶迎风格式，亲眼观察数值扩散效应，并建立一个量化此误差的度量方法，从而将理论分析与可触摸的模拟结果联系起来。这个练习对于培养对数值解质量的批判性眼光以及理解选择离散格式时固有的权衡至关重要 。",
            "id": "2394306",
            "problem": "考虑一维线性平流方程，\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0,\n$$\n其定义在长度为 $L$ 的周期性域上，即 $x \\in [0,L)$，并具有周期性边界条件。平流速度 $a$ 是一个正常数。从积分守恒定律和均匀网格上有限体积平均的定义出发，推导一个与 $a>0$ 的信息传播物理特性相符的一阶、显式、守恒的有限体积方法。\n\n你将通过模拟方块阶跃函数的平流过程来研究数值扩散，并量化界面随时间的模糊程度。使用一个包含 $N$ 个单元的均匀网格，空间步长为 $\\Delta x = L/N$，单元中心为 $x_i = (i+\\tfrac{1}{2})\\Delta x$，其中 $i=0,1,\\dots,N-1$。设初始条件为方块函数\n$$\nu(x,0) = \\begin{cases}\n1,  x \\in [x_L, x_R),\\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\n其中 $x_L = 0.2\\,L$ 且 $x_R = 0.7\\,L$。使用一阶有限体积格式来演化解，其显式时间步长 $\\Delta t$ 的选择应满足一个给定的 Courant–Friedrichs–Lewy (CFL) 数 $\\nu = a\\,\\Delta t/\\Delta x$。在给定的模拟中，所有时间步均使用相同的常数 $\\nu$。让模拟运行至一个给定的最终时间 $T$；使用整数个时间步 $n = \\text{round}(T/\\Delta t)$，以使模拟时间为 $t_n = n\\,\\Delta t$。\n\n将在时间 $t_n$ 下降界面的“模糊宽度”定义为：从单元中心剖面下穿 $\\theta_{\\text{hi}} = 0.9$ 水平的点，到其后下穿 $\\theta_{\\text{lo}} = 0.1$ 水平的点之间的最小空间距离（沿周期性域测量）。使用相邻单元中心的单元中心值进行线性插值来计算这些穿越点。在存在多个下降界面（由于周期性）的情况下，计算每个下降界面周围的模糊宽度，并报告最小宽度。宽度应以与 $L$ 相同的无量纲长度单位表示。\n\n在单个程序中实现模拟和宽度测量。对于下面的每个测试用例，输出在时间 $t_n$ 测得的模糊宽度，四舍五入到8位小数。\n\n使用以下测试套件，参数为 $(N,\\ \\nu,\\ T,\\ a,\\ L)$：\n- 用例 1：$(200,\\ 0.5,\\ 0.2,\\ 1.0,\\ 1.0)$。\n- 用例 2：$(200,\\ 0.9,\\ 0.2,\\ 1.0,\\ 1.0)$。\n- 用例 3：$(200,\\ 0.2,\\ 0.2,\\ 1.0,\\ 1.0)$。\n- 用例 4：$(50,\\ 0.5,\\ 0.2,\\ 1.0,\\ 1.0)$。\n- 用例 5：$(200,\\ 1.0,\\ 0.2,\\ 1.0,\\ 1.0)$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。例如，它应该看起来像\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5],\n$$\n其中每个 $\\text{result}_k$ 是用例 $k$ 的模糊宽度，四舍五入到8位小数。不允许有其他输出。",
            "solution": "我们从平流方程的积分守恒形式开始，\n$$\n\\partial_t u(x,t) + \\partial_x f(u) = 0,\\quad f(u) = a u,\\quad a>0.\n$$\n设 $\\mathcal{C}_i = [x_{i-\\tfrac{1}{2}}, x_{i+\\tfrac{1}{2}}]$ 是一个宽度均匀的控制体，其宽度为 $\\Delta x = x_{i+\\tfrac{1}{2}} - x_{i-\\tfrac{1}{2}}$，单元中心为 $x_i = (i+\\tfrac{1}{2})\\Delta x$，并采用周期性索引。定义单元平均值\n$$\n\\bar{u}_i(t) = \\frac{1}{\\Delta x}\\int_{\\mathcal{C}_i} u(x,t)\\,dx.\n$$\n将守恒定律在 $\\mathcal{C}_i$ 上积分，得到\n$$\n\\frac{d}{dt}\\left( \\int_{\\mathcal{C}_i} u(x,t)\\,dx \\right) + \\left[ f(u(x_{i+\\tfrac{1}{2}},t)) - f(u(x_{i-\\tfrac{1}{2}},t)) \\right] = 0,\n$$\n等价地，\n$$\n\\frac{d\\bar{u}_i}{dt} = -\\frac{1}{\\Delta x}\\left( f_{i+\\tfrac{1}{2}} - f_{i-\\tfrac{1}{2}} \\right),\n$$\n其中 $f_{i\\pm \\tfrac{1}{2}}$ 是通过单元交界面的通量。采用时间步长为 $\\Delta t$ 的一阶显式时间离散可得\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\frac{\\Delta t}{\\Delta x}\\left( \\hat{f}_{i+\\tfrac{1}{2}}^n - \\hat{f}_{i-\\tfrac{1}{2}}^n \\right),\n$$\n其中数值通量 $\\hat{f}_{i+\\tfrac{1}{2}}^n$ 与物理特性一致。对于 $a>0$ 的线性平流，信息从左向右传播，每个界面上的精确 Riemann 解仅取决于左侧的状态。因此，Godunov 迎风数值通量为\n$$\n\\hat{f}_{i+\\tfrac{1}{2}}^n = a\\,\\bar{u}_i^n\\quad\\text{for }a>0.\n$$\n引入 Courant–Friedrichs–Lewy (CFL) 数 $\\nu = a\\,\\Delta t/\\Delta x$，更新格式简化为一阶迎风格式\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\nu\\left(\\bar{u}_i^n - \\bar{u}_{i-1}^n\\right),\\quad a>0,\n$$\n其中 $i$ 采用周期性索引。\n\n为了将此离散方法与连续过程联系起来并揭示数值扩散，我们进行修正方程分析。记 $\\bar{u}_i^n \\approx u(x_i,t^n)$，其中 $t^n = n\\Delta t$。在时间上进行泰勒展开可得\n$$\n\\bar{u}_i^{n+1} - \\bar{u}_i^n = \\Delta t\\,u_t(x_i,t^n) + \\mathcal{O}(\\Delta t^2).\n$$\n对后向差分在空间上进行泰勒展开可得\n$$\n\\bar{u}_i^n - \\bar{u}_{i-1}^n = \\Delta x\\,u_x(x_i,t^n) - \\frac{\\Delta x^2}{2}u_{xx}(x_i,t^n) + \\frac{\\Delta x^3}{6}u_{xxx}(x_i,t^n) + \\mathcal{O}(\\Delta x^4).\n$$\n代入格式中得到\n$$\n\\Delta t\\,u_t = -\\nu\\left[ \\Delta x\\,u_x - \\frac{\\Delta x^2}{2}u_{xx} + \\frac{\\Delta x^3}{6}u_{xxx} + \\cdots \\right] + \\mathcal{O}(\\Delta t^2).\n$$\n两边除以 $\\Delta t$ 并回顾 $\\nu = a\\Delta t/\\Delta x$，\n$$\nu_t + a\\,u_x = \\frac{a\\,\\Delta x}{2}(1 - \\nu)\\,u_{xx} - \\frac{a\\,\\Delta x^2}{6}\\left(1 - 3\\nu + 2\\nu^2\\right)u_{xxx} + \\cdots.\n$$\n首项修正是一个扩散项，其有效（或人为）扩散系数为\n$$\nD_{\\text{num}} = \\frac{a\\,\\Delta x}{2}(1 - \\nu).\n$$\n因此，对于 $0  \\nu  1$，一阶迎风法会引入数值扩散，使间断在宽度上被模糊，其宽度增长规律类似于 $\\sqrt{D_{\\text{num}}\\,t}$，而当 $\\nu=1$ 时，首项扩散项消失，该方法简化为网格上的纯粹平移算子。\n\n为了量化阶跃的模糊程度，我们定义 $10$–$90$ 厚度。考虑一个下降界面，其中 $u$ 的值从接近 $1$ 降至接近 $0$。设 $\\theta_{\\text{hi}} = 0.9$ 和 $\\theta_{\\text{lo}} = 0.1$。在分段常数的单元中心剖面 $\\{\\bar{u}_i^n\\}$ 上，我们通过在相邻单元中心之间进行线性插值来确定 $u=\\theta$ 的近似位置。具体来说，对于下降锋面上一对相邻索引 $(i,i+1)$，且满足 $\\bar{u}_i^n \\ge \\theta > \\bar{u}_{i+1}^n$ 的情况，\n$$\nx(\\theta) \\approx x_i + \\Delta x \\frac{\\bar{u}_i^n - \\theta}{\\bar{u}_i^n - \\bar{u}_{i+1}^n}.\n$$\n我们收集整个域内（考虑周期性）所有向下的 $\\theta_{\\text{hi}}$ 穿越点和所有向下的 $\\theta_{\\text{lo}}$ 穿越点，对于每个 $\\theta_{\\text{hi}}$ 穿越点，我们确定沿周期性坐标到其后的 $\\theta_{\\text{lo}}$ 穿越点的距离。这样的最小距离，记为 $w_{10\\text{–}90}$，就是测得的模糊宽度。该宽度以与 $L$ 相同的长度单位报告。\n\n算法设计：\n- 空间离散：均匀单元，周期性边界条件，对于 $a>0$ 使用一阶迎风通量 $\\hat{f}_{i+\\tfrac{1}{2}}^n = a\\,\\bar{u}_i^n$。\n- 时间步进：采用前向欧拉法，固定 $\\Delta t$ 以满足给定的 $\\nu = a\\,\\Delta t/\\Delta x$；推进 $n=\\text{round}(T/\\Delta t)$ 步。\n- 初始化：在 $[0.2L, 0.7L)$ 上 $u(x,0)=1$，在 $[0,L)$ 的其他位置为 $0$，在单元中心处采样。\n- 宽度测量：使用单元中心值的线性插值计算 $w_{10\\text{–}90}$，并取下降界面上 $\\theta_{\\text{hi}}$ 和 $\\theta_{\\text{lo}}$ 穿越点之间的最小下游距离；使用周期性展开来处理 $x=0$ 附近的界面。\n\n基于 $D_{\\text{num}}$ 的定性预期：对于固定的 $a$、$L$ 和 $T$，更精细的网格（更小的 $\\Delta x$）会减小 $D_{\\text{num}}$，从而减少模糊；更大的 $\\nu$（更接近 $1$）也会减小 $D_{\\text{num}}$，产生更窄的界面；在 $\\nu=1$ 时，首项扩散项消失，界面基本上被限制在网格尺度的厚度。程序精确地实现了该格式和测量方法，并对每个指定的测试用例 $(N,\\nu,T,a,L)$，输出模糊宽度 $w_{10\\text{–}90}(t_n)$，四舍五入到8位小数，并按要求将结果汇总为单行列表。",
            "answer": "```python\nimport numpy as np\n\ndef upwind_fvm_step(u, nu):\n    \"\"\"\n    First-order upwind finite volume update for a  0:\n    u_i^{n+1} = u_i^n - nu * (u_i^n - u_{i-1}^n), with periodic indexing.\n    \"\"\"\n    return u - nu * (u - np.roll(u, 1))\n\ndef initialize_block(N, L, xL_frac=0.2, xR_frac=0.7):\n    \"\"\"\n    Initialize u(x,0) = 1 on [x_L, x_R) and 0 elsewhere on [0,L), sampled at cell centers.\n    x_L = xL_frac * L, x_R = xR_frac * L.\n    \"\"\"\n    dx = L / N\n    x = (np.arange(N) + 0.5) * dx\n    xL = xL_frac * L\n    xR = xR_frac * L\n    u0 = np.where((x = xL)  (x  xR), 1.0, 0.0)\n    return x, u0\n\ndef interpolate_crossing_pos(x_i, x_ip1, u_i, u_ip1, theta, L):\n    \"\"\"\n    Linear interpolation between (x_i, u_i) and (x_ip1, u_ip1) to find x where u=theta.\n    The positions x_i and x_ip1 are assumed to be neighbors on a uniform periodic grid.\n    Returns position wrapped into [0, L).\n    \"\"\"\n    # Handle periodic wrap for positions if necessary (assume uniform spacing)\n    # For uniform grid, x_ip1 - x_i = dx and we do not need special position handling for periodicity;\n    # after computing the position, wrap into [0, L).\n    denom = (u_i - u_ip1)\n    if denom == 0.0:\n        return None\n    frac = (u_i - theta) / denom\n    # x along the straight line between centers\n    xi = x_i + (x_ip1 - x_i) * frac\n    # Wrap into [0, L)\n    xi_wrapped = xi % L\n    return xi_wrapped\n\ndef measure_smearing_width(u, x, L, theta_hi=0.9, theta_lo=0.1):\n    \"\"\"\n    Measure the 10-90 smearing width on descending interfaces using linear interpolation\n    between neighboring cell centers. Returns the minimal width among all descending interfaces.\n    \"\"\"\n    N = len(u)\n    dx = L / N\n    # Build arrays of theta_hi and theta_lo crossing positions for descending fronts\n    hi_positions = []\n    lo_positions = []\n    for i in range(N):\n        ip1 = (i + 1) % N\n        u_i = u[i]\n        u_ip1 = u[ip1]\n        # Descending segment if u_i  u_ip1 (strict to avoid degenerate flat segments)\n        if u_i  u_ip1:\n            # theta_hi crossing: u_i = theta_hi  u_ip1\n            if (u_i = theta_hi) and (u_ip1  theta_hi):\n                xi = interpolate_crossing_pos(x[i], x[ip1], u_i, u_ip1, theta_hi, L)\n                if xi is not None:\n                    hi_positions.append(xi)\n            # theta_lo crossing: u_i = theta_lo  u_ip1\n            if (u_i = theta_lo) and (u_ip1  theta_lo):\n                xl = interpolate_crossing_pos(x[i], x[ip1], u_i, u_ip1, theta_lo, L)\n                if xl is not None:\n                    lo_positions.append(xl)\n\n    # Sort positions\n    hi_positions = np.sort(np.array(hi_positions, dtype=float)) if len(hi_positions)  0 else np.array([], dtype=float)\n    lo_positions = np.sort(np.array(lo_positions, dtype=float)) if len(lo_positions)  0 else np.array([], dtype=float)\n\n    if hi_positions.size == 0 or lo_positions.size == 0:\n        # No descending interfaces detected; width undefined. Return 0.0 as fallback.\n        return 0.0\n\n    # For each hi crossing, find the next downstream lo crossing (with periodicity)\n    widths = []\n    for h in hi_positions:\n        # Compute downstream distances to all lo positions with periodic wrap\n        dists = []\n        for l in lo_positions:\n            d = l - h\n            if d  0:\n                d += L\n            dists.append(d)\n        if len(dists)  0:\n            widths.append(min(dists))\n    if len(widths) == 0:\n        return 0.0\n    return float(min(widths))\n\ndef simulate_and_measure(N, nu, T, a, L):\n    \"\"\"\n    Run the first-order upwind FVM for linear advection with given parameters and\n    measure the 10-90 smearing width at time ~ T.\n    \"\"\"\n    dx = L / N\n    dt = nu * dx / a\n    # Number of steps to approximate T with fixed dt\n    nsteps = int(np.round(T / dt))\n    # Initialize\n    x, u = initialize_block(N, L, xL_frac=0.2, xR_frac=0.7)\n    # Time-stepping\n    for _ in range(nsteps):\n        u = upwind_fvm_step(u, nu)\n    # Measure width\n    width = measure_smearing_width(u, x, L, theta_hi=0.9, theta_lo=0.1)\n    return width\n\ndef solve():\n    # Define the test cases: (N, nu, T, a, L)\n    test_cases = [\n        (200, 0.5, 0.2, 1.0, 1.0),  # Case 1\n        (200, 0.9, 0.2, 1.0, 1.0),  # Case 2\n        (200, 0.2, 0.2, 1.0, 1.0),  # Case 3\n        (50,  0.5, 0.2, 1.0, 1.0),  # Case 4\n        (200, 1.0, 0.2, 1.0, 1.0),  # Case 5\n    ]\n\n    results = []\n    for N, nu, T, a, L in test_cases:\n        width = simulate_and_measure(N, nu, T, a, L)\n        # Round to 8 decimal places as required\n        results.append(width)\n\n    # Final print statement in the exact required format with rounding\n    print(\"[\" + \",\".join(f\"{w:.8f}\" for w in results) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "许多现实世界中的物理系统，例如可压缩气体动力学，是由非线性守恒律支配的。对于这些系统，用于线性平流的简单迎风格式是不够的，因为波的相互作用可以产生激波等复杂结构。最后一个练习将引导你进入非线性问题的领域，挑战无粘性伯格斯方程。你将实现并比较一个基本的迎风通量和一个更复杂的 Harten-Lax-van Leer (HLL) 近似黎曼求解器，后者是现代计算流体动力学中的一个基础工具。这次实践让你初步了解如何构建能够准确捕捉激波和其他非线性现象的稳健数值格式 。",
            "id": "2394328",
            "problem": "实现一个一维有限体积法求解器，用于求解无粘伯格斯方程。使用两种不同的数值通量，并比较它们捕捉激波和稀疏波的能力。求解的起点是守恒律及其积分形式。从基本守恒陈述开始：对于一个密度为 $u(x,t)$、通量为 $f(u)$ 的守恒量，其局部守恒律为 $u_t + f(u)_x = 0$。在一个控制体 $[x_{i-\\frac{1}{2}}, x_{i+\\frac{1}{2}}]$ 上，其积分形式为 $\\frac{d}{dt}\\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} u(x,t)\\,dx + \\left.f(u)\\right|_{x_{i+\\frac{1}{2}}} - \\left.f(u)\\right|_{x_{i-\\frac{1}{2}}} = 0$。将此式离散化，得到单元平均值 $U_i^n$（在时间 $t^n$）的一阶有限体积更新式。其中时间步长为 $\\Delta t$，单元宽度为 $\\Delta x$，并用近似局部黎曼问题解的数值通量来替代界面上的物理通量。问题陈述中未提供其他公式；您必须从这些原理出发推导出离散更新式和数值通量。\n\n使用具体的守恒律 $u_t + \\left(\\frac{1}{2}u^2\\right)_x = 0$，即通量为 $f(u)=\\frac{1}{2}u^2$ 的无粘伯格斯方程。在每个单元界面上，基于左、右状态 $u_L$ 和 $u_R$ 实现两种数值通量：\n- Harten–Lax–van Leer (HLL) 近似黎曼求解器，通过最小和最大特征速度来限定信号速度，并对近似黎曼扇进行积分推导得出。对于标量情况，当波被左、右特征速度正确定界时，该通量可简化为 Godunov 型通量。\n- 一种基本的迎风格式通量，通过使用由界面状态计算出的单一对流速度对非线性通量进行局部线性化，并根据该速度的符号应用施主单元迎风格式法则获得。\n\n算法要求：\n- 在域 $[x_L,x_R] = [-1,1]$ 上使用包含 $N$ 个单元的均匀网格，单元中心位于 $x_i = x_L + \\left(i + \\frac{1}{2}\\right)\\Delta x$，$i=0,1,\\dots,N-1$，其中 $\\Delta x = \\frac{x_R - x_L}{N}$。\n- 初始化一个在 $x=0$ 处有间断的黎曼问题：当 $x  0$ 时 $u(x,0) = u_L$，当 $x \\ge 0$ 时 $u(x,0) = u_R$。\n- 使用显式前向欧拉法进行有限体积更新，将时间推进到最终时刻 $T$，并在每个时间步长强制执行基于域中最大特征速度 $|f'(u)| = |u|$ 的 Courant–Friedrichs–Lewy (CFL) 稳定性条件。使用 $\\Delta t \\le \\nu \\frac{\\Delta x}{\\max_i |u_i|}$，其中选择的 CFL 数 $\\nu$ 严格小于 $1$。\n- 应用透射（零梯度）边界条件，通过在每侧设置一个虚拟单元，并在每个时间步将最近的内部值复制到相应的虚拟单元中来实现。\n\n用于误差评估的参考解：\n- 推导并使用无粘伯格斯方程的精确自相似黎曼解，以计算单元中心的参考值 $u(x_i,T)$。对于 $u_L > u_R$ 的情况，解是一个激波，其速度由 Rankine–Hugoniot 条件给出。对于 $u_L  u_R$ 的情况，解是一个中心稀疏扇，其在左、右特征速度之间呈线性分布。\n\n测试套件与输出：\n- 所有测试均使用 $N=400$，$\\nu=0.9$，域 $[x_L,x_R]=[-1,1]$，间断点在 $x=0$，最终时间 $T=0.3$。定义三种初始状态 $(u_L,u_R)$：\n  1. $u_L=2.0$, $u_R=0.0$ (激波主导情况)。\n  2. $u_L=0.0$, $u_R=2.0$ (扩展稀疏波情况)。\n  3. $u_L=-1.0$, $u_R=1.0$ (跨音速稀疏波情况)。\n- 对于每个测试用例 $k \\in \\{1,2,3\\}$，计算每种数值通量格式相对于精确解的离散 $L^1$ 误差：\n  $$E_{\\mathrm{HLL}}^{(k)} = \\Delta x \\sum_{i=0}^{N-1} \\left| U_{i,\\mathrm{HLL}}(T) - u_{\\mathrm{exact}}(x_i,T) \\right|,$$\n  $$E_{\\mathrm{UP}}^{(k)} = \\Delta x \\sum_{i=0}^{N-1} \\left| U_{i,\\mathrm{UP}}(T) - u_{\\mathrm{exact}}(x_i,T) \\right|.$$\n- 对每个测试，还要计算一个指示符 $I^{(k)}$，如果 $E_{\\mathrm{HLL}}^{(k)}  E_{\\mathrm{UP}}^{(k)}$，则其值为整数 $1$，否则为 $0$。\n\n单位：所有量均为无量纲；仅报告无量纲数。\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含一个方括号括起来的逗号分隔列表，按以下顺序排列九个结果：\n  $$\\left[ E_{\\mathrm{HLL}}^{(1)}, E_{\\mathrm{UP}}^{(1)}, I^{(1)}, E_{\\mathrm{HLL}}^{(2)}, E_{\\mathrm{UP}}^{(2)}, I^{(2)}, E_{\\mathrm{HLL}}^{(3)}, E_{\\mathrm{UP}}^{(3)}, I^{(3)} \\right],$$\n  其中每个误差 $E_{\\mathrm{HLL}}^{(k)}$ 和 $E_{\\mathrm{UP}}^{(k)}$ 必须四舍五入到恰好六位小数，每个指示符 $I^{(k)}$ 均为整数。例如，打印的字符串应类似于 $[\\dots]$，包含恰好九个逗号分隔的条目，且无附加文本。",
            "solution": "问题陈述已经过严谨分析，并被认定为有效。它在计算物理学领域内构成了一个适定且具有科学依据的问题。所有必要的参数和定义均已提供，从而可以明确地构建和验证数值解。要求从第一性原理推导基本公式是一项标准的教学练习，旨在检验基础理解，并非问题规范中的缺陷。\n\n我们继续进行解的推导和实现。\n\n**1. 有限体积法离散化**\n\n起点是守恒量 $u$ 在一个宽度为 $\\Delta x = x_{i+1/2} - x_{i-1/2}$ 的控制体（或单元）$C_i = [x_{i-1/2}, x_{i+1/2}]$ 上的积分形式守恒律：\n$$\n\\frac{d}{dt}\\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t)\\,dx + f(u(x_{i+1/2},t)) - f(u(x_{i-1/2},t)) = 0\n$$\n我们将 $u$ 在单元 $C_i$ 上的单元平均值定义为 $U_i(t) = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x, t) dx$。将此定义代入积分守恒律，得到一个关于单元平均值演化的精确方程：\n$$\n\\frac{d}{dt} (\\Delta x U_i(t)) + f_{i+1/2} - f_{i-1/2} = 0\n$$\n其中 $f_{i \\pm 1/2}$ 表示在单元界面 $x_{i \\pm 1/2}$ 处的瞬时物理通量 $f(u)$。假设网格均匀，$\\Delta x$ 为常数，则上式简化为：\n$$\n\\frac{dU_i}{dt} = - \\frac{1}{\\Delta x} (f_{i+1/2} - f_{i-1/2})\n$$\n有限体积法的核心原理是用数值通量 $\\hat{f}_{i \\pm 1/2}$ 替代未知的逐点物理通量 $f_{i \\pm 1/2}$。在单元 $i$ 和单元 $i+1$ 之间的界面上的数值通量，记作 $\\hat{f}_{i+1/2}$，是相邻单元的单元平均值状态的函数，即 $\\hat{f}_{i+1/2} = \\hat{f}(U_i, U_{i+1})$。由此得到的半离散格式为：\n$$\n\\frac{dU_i}{dt} = - \\frac{1}{\\Delta x} \\left( \\hat{f}(U_i, U_{i+1}) - \\hat{f}(U_{i-1}, U_i) \\right)\n$$\n为了获得全离散格式，我们使用显式前向欧拉法对时间进行离散。对于时间步长 $\\Delta t$，时间步 $n+1$ 处的单元平均值由时间步 $n$ 处的值给出：\n$$\n\\frac{U_i^{n+1} - U_i^n}{\\Delta t} = - \\frac{1}{\\Delta x} \\left( \\hat{f}(U_i^n, U_{i+1}^n) - \\hat{f}(U_{i-1}^n, U_i^n) \\right)\n$$\n这给出了一阶精度的更新公式：\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x} \\left( \\hat{f}(U_i^n, U_{i+1}^n) - \\hat{f}(U_{i-1}^n, U_i^n) \\right)\n$$\n\n**2. 数值通量函数**\n\n问题指定了无粘伯格斯方程 $u_t + \\left(\\frac{1}{2}u^2\\right)_x = 0$。其通量为 $f(u) = \\frac{1}{2}u^2$，其雅可比矩阵（代表特征速度）为 $f'(u) = u$。我们推导所需的两种数值通量 $\\hat{f}(u_L, u_R)$，其中 $u_L$ 和 $u_R$ 是单元界面左右两侧的重构状态。对于我们的一阶格式，它们就是相邻单元的单元平均值。\n\n**2.1. 基本迎风格式通量**\n该通量基于线性化对流方程 $u_t + a u_x = 0$ 的解，其中信息以速度 $a$ 传播。对于非线性的伯格斯方程，我们在界面处定义一个局部单一对流速度 $a(u_L, u_R)$。一个常见的选择（对应于该方程的 Roe 平均）是算术平均：\n$$\na(u_L, u_R) = \\frac{u_L + u_R}{2}\n$$\n这个速度也是 Rankine-Hugoniot 激波速度。迎风通量从“上游”一侧选取通量，这由对流速度的符号决定：\n$$\n\\hat{f}_{\\text{upwind}}(u_L, u_R) = \\begin{cases} f(u_L)  \\text{若 } a(u_L, u_R) \\ge 0 \\\\ f(u_R)  \\text{若 } a(u_L, u_R)  0 \\end{cases}\n$$\n\n**2.2. Harten-Lax-van Leer (HLL) 通量**\nHLL 通量是基于一个假定为双波模型的近似黎曼求解器构建的。它假定界面处的解由三个常数状态（$u_L$、$u^*$、$u_R$）组成，由两个速度为 $S_L$ 和 $S_R$ 的波分隔。这些速度必须包围真实黎曼解的所有特征速度。对于标量伯格斯方程，真实的波速被 $\\min(u_L, u_R)$ 和 $\\max(u_L, u_R)$ 所界定。因此，我们选择它们作为我们的信号速度估计值：\n$$\nS_L = \\min(u_L, u_R) \\quad \\text{和} \\quad S_R = \\max(u_L, u_R)\n$$\n通过在一个包含波结构的控制体上应用积分守恒律，可以推导出 HLL 通量。其公式取决于波相对于单元界面（其中 $x/t = 0$）的传播方向：\n- 若 $S_L \\ge 0$，则整个波结构向右传播。界面处的状态是 $u_L$，通量为 $\\hat{f}_{\\text{HLL}} = f(u_L)$。\n- 若 $S_R \\le 0$，则整个结构向左传播。界面处的状态是 $u_R$，通量为 $\\hat{f}_{\\text{HLL}} = f(u_R)$。\n- 若 $S_L  0  S_R$，则界面位于两个波之间。通量是一个确保守恒的加权平均值：\n  $$\n  \\hat{f}_{\\text{HLL}}(u_L, u_R) = \\frac{S_R f(u_L) - S_L f(u_R) + S_L S_R (u_R - u_L)}{S_R - S_L}\n  $$\n这个组合公式提供了一个鲁棒且守恒的数值通量。\n\n**3. 无粘伯格斯方程的精确黎曼解**\n\n伯格斯方程黎曼问题的精确解是自相似的，仅依赖于变量 $\\xi = x/t$。解的性质由初始左右状态 $u_L$ 和 $u_R$ 之间的关系决定。\n\n- **激波 ($u_L > u_R$)**：形成一个单一间断，并以恒定速度 $s$ 传播，速度由 Rankine-Hugoniot 条件给出：\n  $$\n  s = \\frac{f(u_R) - f(u_L)}{u_R - u_L} = \\frac{\\frac{1}{2}u_R^2 - \\frac{1}{2}u_L^2}{u_R - u_L} = \\frac{u_L + u_R}{2}\n  $$\n  解是一个阶跃函数：\n  $$\n  u(x,t) = \\begin{cases} u_L,  \\text{若 } x/t  s \\\\ u_R,  \\text{若 } x/t > s \\end{cases}\n  $$\n\n- **稀疏波 ($u_L  u_R$)**：解是一个连接左右状态的连续“扇形”。在扇形区域内，解由 $u(x,t) = x/t$ 给出。该扇形区域跨越特征速度 $\\lambda(u_L)=u_L$ 和 $\\lambda(u_R)=u_R$ 之间的区域。完整的解是：\n  $$\n  u(x,t) = \\begin{cases} u_L,  \\text{若 } x/t \\le u_L \\\\ x/t,  \\text{若 } u_L  x/t  u_R \\\\ u_R,  \\text{若 } x/t \\ge u_R \\end{cases}\n  $$\n这个精确解将作为计算数值格式 $L^1$ 误差的参考。\n\n**4. 数值算法总结**\n\n求解器基于以下规范实现：\n- **域和网格**：$[x_L, x_R] = [-1, 1]$，有 $N=400$ 个单元，因此 $\\Delta x = (1 - (-1))/400 = 0.005$。\n- **状态向量**：使用一个大小为 $N+2$ 的 NumPy 数组，其中索引 $1, \\dots, N$ 代表上述单元，索引 $0$ 和 $N+1$ 分别代表左、右虚拟单元。\n- **初始条件**：根据单元中心相对于 $x=0$ 处间断的位置来初始化单元平均值。\n- **边界条件**：在每个时间步通过将虚拟单元的值设置为相邻内部单元的值来强制执行透射（零梯度）条件：$U_0^n = U_1^n$ 和 $U_{N+1}^n = U_N^n$。\n- **时间步进**：模拟从 $t=0$ 运行到 $T=0.3$。时间步长 $\\Delta t$ 在每一步动态计算，以满足 Courant-Friedrichs-Lewy (CFL) 条件：$\\Delta t = \\nu \\frac{\\Delta x}{\\max_i |U_i^n|}$，其中 CFL 数 $\\nu=0.9$。最后的时间步长会进行调整，以确保恰好在 $T$ 时刻结束。\n- **误差计算**：对于每个测试用例和通量类型，离散 $L^1$ 误差计算为 $E = \\Delta x \\sum_{i=0}^{N-1} |U_{i,\\text{num}}(T) - u_{\\text{exact}}(x_i,T)|$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the final results.\n    \"\"\"\n    \n    # --- Problem Parameters ---\n    N = 400\n    x_L, x_R = -1.0, 1.0\n    T_final = 0.3\n    nu = 0.9  # CFL number\n    \n    test_cases = [\n        (2.0, 0.0),  # Case 1: Shock\n        (0.0, 2.0),  # Case 2: Rarefaction\n        (-1.0, 1.0), # Case 3: Transonic Rarefaction\n    ]\n\n    all_results = []\n\n    for k, (u_L, u_R) in enumerate(test_cases):\n        \n        # --- Run simulation with HLL flux ---\n        u_hll = run_simulation(N, x_L, x_R, T_final, nu, u_L, u_R, 'hll')\n        \n        # --- Run simulation with Upwind flux ---\n        u_upwind = run_simulation(N, x_L, x_R, T_final, nu, u_L, u_R, 'upwind')\n        \n        # --- Compute L1 errors ---\n        dx = (x_R - x_L) / N\n        x_centers = x_L + (np.arange(N) + 0.5) * dx\n\n        # Error for HLL\n        u_exact_vals = exact_solution(x_centers, T_final, u_L, u_R)\n        e_hll = dx * np.sum(np.abs(u_hll - u_exact_vals))\n        \n        # Error for Upwind\n        e_upwind = dx * np.sum(np.abs(u_upwind - u_exact_vals))\n\n        # Indicator\n        indicator = 1 if e_hll  e_upwind else 0\n\n        # Append results for this test case\n        all_results.extend([round(e_hll, 6), round(e_upwind, 6), indicator])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\n\ndef run_simulation(N, x_L, x_R, T_final, nu, u_L, u_R, flux_type):\n    \"\"\"\n    Runs a single 1D FVM simulation for the Burgers equation.\n    \n    Args:\n        N (int): Number of cells.\n        x_L (float): Left boundary of the domain.\n        x_R (float): Right boundary of the domain.\n        T_final (float): Final simulation time.\n        nu (float): CFL number.\n        u_L (float): Initial left state.\n        u_R (float): Initial right state.\n        flux_type (str): 'hll' or 'upwind'.\n        \n    Returns:\n        numpy.ndarray: The solution array u_n at the final time in the physical domain.\n    \"\"\"\n    dx = (x_R - x_L) / N\n    x_centers = x_L + (np.arange(N) + 0.5) * dx\n\n    # Initialize solution array with 1 ghost cell on each side\n    u_n = np.zeros(N + 2)\n    u_n[1:-1] = np.where(x_centers  0, u_L, u_R)\n\n    t = 0.0\n    \n    flux_func = get_flux_function(flux_type)\n\n    while t  T_final:\n        # Apply transmissive (zero-gradient) boundary conditions\n        u_n[0] = u_n[1]\n        u_n[-1] = u_n[-2]\n\n        # Calculate time step based on CFL condition\n        max_abs_u = np.max(np.abs(u_n))\n        if max_abs_u  1e-9:\n            max_abs_u = 1e-9 # Avoid division by zero\n            \n        dt = nu * dx / max_abs_u\n        if t + dt  T_final:\n            dt = T_final - t\n\n        # Calculate fluxes at interfaces\n        # F[j] is the flux at the interface between cell j and j+1 (in the padded array)\n        fluxes = np.zeros(N + 1)\n        for j in range(N + 1):\n            fluxes[j] = flux_func(u_n[j], u_n[j+1])\n        \n        # Update solution using first-order finite volume scheme\n        u_np1 = np.copy(u_n)\n        for i in range(1, N + 1): # Iterate over physical cells\n            u_np1[i] = u_n[i] - (dt / dx) * (fluxes[i] - fluxes[i-1])\n\n        u_n = u_np1\n        t += dt\n\n    return u_n[1:-1] # Return only the physical domain\n\ndef get_flux_function(flux_type):\n    \"\"\"Returns the chosen numerical flux function.\"\"\"\n    if flux_type == 'hll':\n        return hll_flux\n    elif flux_type == 'upwind':\n        return upwind_flux\n    else:\n        raise ValueError(\"Invalid flux type specified.\")\n\ndef flux(u):\n    \"\"\"Physical flux for Burgers' equation.\"\"\"\n    return 0.5 * u**2\n\ndef upwind_flux(u_l, u_r):\n    \"\"\"Computes the basic upwind flux.\"\"\"\n    a = 0.5 * (u_l + u_r) # Roe average speed\n    if a = 0:\n        return flux(u_l)\n    else:\n        return flux(u_r)\n\ndef hll_flux(u_l, u_r):\n    \"\"\"Computes the HLL flux.\"\"\"\n    if np.isclose(u_l, u_r):\n        return flux(u_l)\n        \n    f_l = flux(u_l)\n    f_r = flux(u_r)\n    \n    # Estimate signal speeds\n    s_l = min(u_l, u_r)\n    s_r = max(u_l, u_r)\n    \n    if s_l = 0:\n        return f_l\n    elif s_r = 0:\n        return f_r\n    else: # s_l  0  s_r\n        return (s_r * f_l - s_l * f_r + s_l * s_r * (u_r - u_l)) / (s_r - s_l)\n\ndef exact_solution(x, t, u_l, u_r):\n    \"\"\"Computes the exact Riemann solution for the Burgers equation.\"\"\"\n    if np.isclose(t, 0):\n        return np.where(x  0, u_l, u_r)\n    \n    if u_l  u_r:  # Shock\n        s = 0.5 * (u_l + u_r)\n        return np.where(x / t  s, u_l, u_r)\n    else:  # Rarefaction\n        xi = x / t\n        solution = np.piecewise(xi, [xi = u_l, (xi  u_l)  (xi  u_r), xi = u_r],\n                                [u_l, lambda val: val, u_r])\n        return solution\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}