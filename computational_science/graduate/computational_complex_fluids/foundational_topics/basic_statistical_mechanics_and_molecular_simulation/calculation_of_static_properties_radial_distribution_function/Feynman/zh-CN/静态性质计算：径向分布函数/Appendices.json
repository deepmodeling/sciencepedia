{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握径向分布函数，第一步是亲手实现其从原始粒子坐标出发的计算过程。本练习将引导你关注其中的实践细节，例如如何对粒子对间距进行直方图统计，如何进行至关重要的归一化，以及如何应用高斯平滑等后处理技术。通过建立客观的评估指标，你将学会如何系统地评估计算结果的质量，并理解箱体宽度等参数选择的重要性。",
            "id": "4081106",
            "problem": "你需要设计并实现一个程序，用于计算在周期性边界条件下由点粒子采样的三维复杂流体的径向分布函数（RDF）。重点在于有原则的组距选择、分辨率控制和高斯平滑。RDF 是根据构型的对统计（pair statistics）定义的静态属性。你的程序必须遵循从核心定义和经过充分检验的统计规则出发的原则性构建，并且必须生成单一、可测试的输出行，该行汇总了固定测试套件的结果。\n\n从以下基础开始。考虑一个边长为 $L$ 的立方周期性盒子，其中包含 $N$ 个点粒子，数密度为 $\\rho = N / V$，其中 $V = L^3$。对于一个统计上均匀且各向同性的系统，将径向分布函数 $g(r)$ 定义为在分离距离 $r$ 处的局部对密度与理想气体参考密度之比。在实践中，$g(r)$ 是通过将对分离距离累积到半径为 $r$、厚度为 $\\Delta r$ 的球壳中，然后按球壳体积和可用对数进行归一化来构建的。在周期性盒子中计算距离时，请使用最小镜像约定，并将分析限制在分离距离 $r$ 严格小于 $r_{\\max} = L/2$ 的范围内。\n\n你必须从无序对（每对仅计数一次）构建 $g(r)$，并对其进行归一化，使得对于空间均匀的理想气体，其期望值为 $g(r) = 1$（对于 $0  r  r_{\\max}$），只存在有限样本涨落。在均匀分箱上构建未经平滑的 $g(r)$ 后，可选择性地应用高斯核平滑，其标准差以与 $r$ 相同的物理长度单位指定。\n\n你的程序必须实现有科学依据的组距选择方法，而不是使用问题陈述中的简化公式。具体而言：\n- 一种情况要求根据 Freedman–Diaconis 法则选择 $\\Delta r$，使用严格小于 $r_{\\max}$ 的对分离距离的经验分布。\n- 一种情况要求根据 Scott 法则选择 $\\Delta r$，使用严格小于 $r_{\\max}$ 的对分离距离的经验标准差。\n- 一种情况使用以物理单位提供的固定目标 $\\Delta r$；通过 $M = \\lfloor r_{\\max} / \\Delta r_{\\mathrm{target}} \\rfloor$ 将其转换为 $[0, r_{\\max}]$ 上的整数箱数 $M$，然后使用均匀组距 $\\Delta r = r_{\\max} / M$，以使箱体精确划分该区间。\n\n平滑是通过将 $g(r)$ 与一个高斯函数进行卷积来执行的，该高斯函数的标准差是根据分箱方法选择的有效 $\\Delta r$ 的一个乘法因子给出的。设 $\\sigma_{\\mathrm{smooth}} = \\alpha \\Delta r$，其中 $\\alpha$ 是提供的平滑因子；如果 $\\alpha = 0$，则不应用平滑。由于实现是离散的，高斯平滑必须使用以组元单位（bin units）度量的标准差来实现，即 $\\sigma_{\\mathrm{bins}} = \\sigma_{\\mathrm{smooth}} / \\Delta r = \\alpha$。\n\n定义以下定量诊断指标以评估分辨率和平滑效果：\n- $[0, r_{\\max}]$ 上的箱数 $M$，用作分辨率的度量。\n- 平滑后的 RDF 与理想气体值 $1$ 的平均绝对偏差，定义为\n$$ D = \\frac{1}{M} \\sum_{i=1}^{M} \\left| g(r_i) - 1 \\right|, $$\n其中 $r_i$ 是第 $i$ 个箱的中心，$g(r_i)$ 是在该中心的平滑 RDF 值。\n- 截至截断半径 $r_c$ 的配位数误差，定义为\n$$ E = n(r_c) - \\rho \\frac{4\\pi}{3} r_c^3, \\quad \\text{其中} \\quad n(r_c) = 4\\pi \\rho \\int_{0}^{r_c} g(r)\\, r^2 \\, dr, $$\n该积分通过在均匀箱上的中点黎曼和进行评估：$n(r_c) \\approx 4\\pi \\rho \\sum_{i: r_i \\le r_c} g(r_i)\\, r_i^2 \\, \\Delta r.$\n\n为强制实现科学真实性的实现细节：\n- 使用指定的随机种子，在立方体 $[0, L)^3$ 中均匀且独立地放置 $N$ 个粒子来生成合成构型。使用最小镜像约定计算无序对距离 $r$，方法是将位移分量包裹到区间 $[-L/2, L/2]$，然后取其欧几里得范数。\n- 仅累积严格小于 $r_{\\max} = L/2$ 的距离。\n- 从箱区间 $[0, r_{\\max}]$ 上的直方图计数 $n_i$（中心为 $r_i$，均匀宽度为 $\\Delta r$）构建 $g(r)$，使用与无序对一致的归一化方法，该方法使得对于均匀理想气体，期望值为 $g(r) = 1$。对第 $i$ 个箱使用球壳体积 $V_{\\mathrm{shell},i} = 4\\pi r_i^2 \\Delta r$。\n\n单位和输出格式：\n- 所有长度必须以纳米（nm）为单位处理。以 $\\mathrm{nm}$ 为单位报告组距 $\\Delta r$。\n- 平均绝对偏差 $D$ 和配位数误差 $E$ 是无量纲的。\n- 你的程序应生成单行输出，其中包含一个由三个子列表组成的逗号分隔列表，每个子列表对应一个测试用例，并按顺序包含 $[\\Delta r, M, D, E]$。例如，一个有效的输出格式是 \"[[dr1,M1,D1,E1],[dr2,M2,D2,E2],[dr3,M3,D3,E3]]\"，并用数值替换。该行必须只包含此单个列表，不含任何额外文本。\n\n测试套件规范（所有长度单位均为 $\\mathrm{nm}$）：\n- 情况 A（理想路径）：$N = 64$，$L = 10$，随机种子 $42$，分箱方法 \"Freedman–Diaconis\"，平滑因子 $\\alpha = 1.0$，截断半径 $r_c = L/4$。\n- 情况 B（高分辨率，无平滑）：$N = 16$，$L = 10$，随机种子 $777$，固定目标组距 $\\Delta r_{\\mathrm{target}} = 0.05$，平滑因子 $\\alpha = 0.0$，截断半径 $r_c = L/4$。\n- 情况 C（替代法则，更强平滑）：$N = 64$，$L = 10$，随机种子 $2024$，分箱方法 \"Scott\"，平滑因子 $\\alpha = 2.0$，截断半径 $r_c = L/3$。\n\n你的程序必须为每种情况实现上述流程，遵守指定的单位，并按 A、B、C 的顺序汇总三个情况的结果，以所描述的精确格式打印单行输出。",
            "solution": "该问题要求设计并实现一个程序，用于计算在周期性边界条件下，一个边长为 $L$ 的立方盒子内 $N$ 个点粒子系统的径向分布函数 $g(r)$。计算必须遵循关于分箱、平滑和评估的特定方法论。该分析从第一性原理出发。\n\n首先，我们定义系统和基本量。系统由体积 $V = L^3$ 内的 $N$ 个粒子组成，对应数密度为 $\\rho = N/V$。径向分布函数 $g(r)$ 量化了在分离距离为 $r$ 处找到一对粒子的概率，相对于相同密度下理想气体的概率。对于一个统计上均匀且各向同性的系统，$g(r)$ 的定义使得 $\\rho g(r)$ 是距离任意中心粒子 $r$ 处的局部数密度。\n\n对间距 $r_{ij} = |\\vec{r}_j - \\vec{r}_i|$ 的计算必须考虑周期性边界条件。这通过使用最小镜像约定来完成。对于位移矢量 $\\Delta\\vec{r} = (\\Delta x, \\Delta y, \\Delta z)$，每个分量都被包裹到区间 $[-L/2, L/2]$ 内。例如，最小镜像位移的 x 分量是 $\\Delta x' = \\Delta x - L \\cdot \\text{round}(\\Delta x / L)$。然后，距离的平方为 $r_{ij}^2 = (\\Delta x')^2 + (\\Delta y')^2 + (\\Delta z')^2$。分析被限制在分离距离 $r  r_{\\max} = L/2$ 的范围内，以避免跨越周期性边界的模糊性和自相互作用。\n\n任务的核心是通过对对间距进行分箱来构建 $g(r)$ 的离散近似。区间 $[0, r_{\\max})$ 被划分为 $M$ 个宽度为 $\\Delta r = r_{\\max} / M$ 的均匀箱。第 $i$ 个箱（$i=0, 1, \\dots, M-1$）的中心是 $r_i = (i+0.5)\\Delta r$。通过统计分离距离落在第 $i$ 个箱内的无序粒子对的数量 $n_i$，来构建一个直方图。\n\n$g(r_i)$ 的归一化至关重要，并且必须与其定义一致，即对于均匀理想气体，期望值 $\\langle g(r_i) \\rangle = 1$。系统中唯一对的总数为 $N(N-1)/2$。对于理想气体（空间不相关的粒子），第 $i$ 个球壳中的期望对数是总对数乘以球壳体积与总体积之比：\n$$\n\\langle n_i \\rangle_{\\text{ideal}} = \\frac{N(N-1)}{2} \\frac{V_{\\mathrm{shell},i}}{V}\n$$\n对应于第 $i$ 个箱的球壳体积近似为 $V_{\\mathrm{shell},i} \\approx 4\\pi r_i^2 \\Delta r$，这在 $\\Delta r$ 很小时是准确的。径向分布函数则是观测到的计数 $n_i$ 与此理想气体期望值之比：\n$$\ng(r_i) = \\frac{n_i}{\\langle n_i \\rangle_{\\text{ideal}}} = \\frac{n_i}{\\frac{N(N-1)}{2V} (4\\pi r_i^2 \\Delta r)} = \\frac{2 V n_i}{4\\pi N(N-1) r_i^2 \\Delta r}\n$$\n当观测到的计数 $n_i$ 与理想气体期望值匹配时，这种归一化正确地得到 $g(r_i) = 1$。对于 $r_i$ 接近零的箱，该表达式在数值上很敏感，但由于箱中心 $r_i$ 总是正的（$r_0 = \\Delta r / 2$），分母是良定义的。\n\n问题指定了三种确定组距 $\\Delta r$ 的方法：\n1.  **Freedman–Diaconis 法则：** 组距由所有对间距 $d$（其中 $d  r_{\\max}$）分布的四分位距（IQR）和此类距离的数量 $n_{\\text{pairs}}$ 导出。公式为 $\\Delta r_{\\text{rule}} = 2 \\cdot \\text{IQR} \\cdot n_{\\text{pairs}}^{-1/3}$。\n2.  **Scott 法则：** 该法则使用相同对间距数据的标准差 $\\sigma_d$：$\\Delta r_{\\text{rule}} = 3.5 \\cdot \\sigma_d \\cdot n_{\\text{pairs}}^{-1/3}$。\n对于这两种法则，箱数随后被设置为 $M = \\lfloor r_{\\max} / \\Delta r_{\\text{rule}} \\rfloor$，并且最终的有效组距被重新计算为 $\\Delta r = r_{\\max} / M$，以确保箱体完美地覆盖区间 $[0, r_{\\max}]$。\n3.  **固定目标组距：** 给定一个目标宽度 $\\Delta r_{\\mathrm{target}}$。箱数是 $M = \\lfloor r_{\\max} / \\Delta r_{\\mathrm{target}} \\rfloor$，有效宽度同样是 $\\Delta r = r_{\\max} / M$。\n\n计算原始 $g(r)$ 后，可以应用高斯平滑。这是离散 $g(r_i)$ 数组与高斯核的卷积。核的标准差由 $\\sigma_{\\mathrm{smooth}} = \\alpha \\Delta r$ 给出，其中 $\\alpha$ 是一个指定的平滑因子。对于离散卷积，这等效于以箱索引为单位的标准差 $\\sigma_{\\mathrm{bins}} = \\alpha$。如果 $\\alpha=0$，则不应用平滑。\n\n最后，我们计算三个诊断量：\n1.  箱数 $M$。\n2.  与理想气体值 $1$ 的平均绝对偏差：$D = \\frac{1}{M} \\sum_{i=0}^{M-1} | g(r_i) - 1 |$。\n3.  截至截断半径 $r_c$ 的配位数误差 $E$。配位数 $n(r_c)$ 是中心粒子周围半径 $r_c$ 内的期望粒子数。它通过对 $\\rho g(r)$ 积分计算得出：\n    $$\n    n(r_c) = 4\\pi \\rho \\int_{0}^{r_c} g(r) r^2 dr\n    $$\n    该积分使用在箱上的中点黎曼和进行近似：\n    $$\n    n(r_c) \\approx 4\\pi \\rho \\sum_{i: r_i \\le r_c} g(r_i) r_i^2 \\Delta r\n    $$\n    误差 $E$ 是这个计算值与理想气体配位数（即半径为 $r_c$ 的球体中的粒子数）的偏差：\n    $$\n    E = n(r_c) - \\rho \\frac{4\\pi}{3} r_c^3\n    $$\n\n每个测试用例的总体算法如下：\n1.  使用指定的随机种子，在立方体 $[0, L)^3$ 中为 $k=1, \\dots, N$ 均匀生成 $N$ 个粒子位置 $\\vec{r}_k$。\n2.  应用最小镜像约定，计算所有唯一的无序对距离 $r_{ij}$（对于 $j>i$），并仅保留那些 $r_{ij}  r_{\\max}$ 的距离。\n3.  根据指定的分箱方法确定箱数 $M$ 和有效组距 $\\Delta r$。\n4.  构建距离的直方图，以获得每个箱的计数 $n_i$。\n5.  归一化计数以获得原始的 $g(r_i)$。\n6.  如果 $\\alpha > 0$，应用高斯平滑以得到最终的 $g(r_i)$。\n7.  计算诊断指标 $M$、$D$ 和 $E$。\n8.  收集结果 $[\\Delta r, M, D, E]$ 以供输出。\n这个过程提供了一种科学上严谨且数值上可验证的方法来计算和分析径向分布函数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.ndimage import gaussian_filter1d\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        # Case A: N=64, L=10, seed=42, Freedman-Diaconis, alpha=1.0, rc=L/4\n        {'N': 64, 'L': 10.0, 'seed': 42, 'binning_method': 'Freedman-Diaconis', \n         'bin_params': {}, 'smoothing_alpha': 1.0, 'rc': 10.0 / 4.0},\n        # Case B: N=16, L=10, seed=777, fixed target dr=0.05, alpha=0.0, rc=L/4\n        {'N': 16, 'L': 10.0, 'seed': 777, 'binning_method': 'fixed_target', \n         'bin_params': {'delta_r_target': 0.05}, 'smoothing_alpha': 0.0, 'rc': 10.0 / 4.0},\n        # Case C: N=64, L=10, seed=2024, Scott, alpha=2.0, rc=L/3\n        {'N': 64, 'L': 10.0, 'seed': 2024, 'binning_method': 'Scott', \n         'bin_params': {}, 'smoothing_alpha': 2.0, 'rc': 10.0 / 3.0}\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_rdf_diagnostics(\n            N=case['N'],\n            L=case['L'],\n            seed=case['seed'],\n            binning_method=case['binning_method'],\n            bin_params=case['bin_params'],\n            smoothing_alpha=case['smoothing_alpha'],\n            rc=case['rc']\n        )\n        results.append(result)\n\n    # Format the final output string exactly as required, removing all spaces.\n    print(str(results).replace(\" \", \"\"))\n\ndef compute_rdf_diagnostics(N, L, seed, binning_method, bin_params, smoothing_alpha, rc):\n    \"\"\"\n    Computes the RDF and its diagnostics for a single case.\n    \"\"\"\n    # 1. Generate particle positions\n    rng = np.random.default_rng(seed)\n    positions = rng.uniform(0, L, size=(N, 3))\n\n    # 2. Calculate pairwise distances with minimum image convention\n    r_max = L / 2.0\n    distances = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            delta = positions[j] - positions[i]\n            # Apply minimum image convention\n            delta = delta - L * np.round(delta / L)\n            dist = np.linalg.norm(delta)\n            if dist  r_max:\n                distances.append(dist)\n    distances = np.array(distances)\n    \n    n_pairs = len(distances)\n    if n_pairs == 0: # Handle edge case of no pairs in range\n      if binning_method == 'fixed_target':\n        M = int(np.floor(r_max / bin_params['delta_r_target']))\n      else:\n        M = 100 # Default if no data to estimate from\n      if M == 0: M = 1\n      delta_r = r_max / M\n      return [delta_r, M, 1.0, - (N/L**3) * (4.0/3.0) * np.pi * rc**3]\n\n    # 3. Determine bin width (delta_r) and number of bins (M)\n    if binning_method == 'Freedman-Diaconis':\n        q1, q3 = np.percentile(distances, [25, 75])\n        iqr = q3 - q1\n        # Avoid division by zero if all distances are the same\n        if iqr == 0:\n            iqr = np.std(distances)\n        if iqr == 0: # still zero?\n            delta_r_rule = r_max / 100.0 # fallback\n        else:\n            delta_r_rule = 2.0 * iqr * (n_pairs ** (-1.0/3.0))\n        \n        M = int(np.floor(r_max / delta_r_rule)) if delta_r_rule > 0 else 100\n        if M == 0: M = 1\n        delta_r = r_max / M\n\n    elif binning_method == 'Scott':\n        std_dev = np.std(distances)\n        if std_dev == 0:\n            delta_r_rule = r_max / 100.0\n        else:\n            delta_r_rule = 3.5 * std_dev * (n_pairs ** (-1.0/3.0))\n        \n        M = int(np.floor(r_max / delta_r_rule)) if delta_r_rule > 0 else 100\n        if M == 0: M = 1\n        delta_r = r_max / M\n\n    elif binning_method == 'fixed_target':\n        delta_r_target = bin_params['delta_r_target']\n        M = int(np.floor(r_max / delta_r_target))\n        if M == 0: M = 1\n        delta_r = r_max / M\n        \n    else:\n        raise ValueError(f\"Unknown binning method: {binning_method}\")\n\n    # 4. Construct histogram and calculate g(r)\n    counts, bin_edges = np.histogram(distances, bins=M, range=(0, r_max))\n    bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2.0\n\n    V = L**3\n    rho = N / V\n    # Normalization factor for each bin\n    # Ideal gas count = (Total pairs) * (Shell Volume / Total Box Volume)\n    # Total pairs = N*(N-1)/2\n    shell_volumes = 4.0 * np.pi * bin_centers**2 * delta_r\n    ideal_gas_counts = (N * (N - 1) / 2.0) * shell_volumes / V\n    \n    # Calculate g(r) with protection against division by zero\n    g_r = np.zeros_like(ideal_gas_counts)\n    nonzero_mask = ideal_gas_counts > 0\n    g_r[nonzero_mask] = counts[nonzero_mask] / ideal_gas_counts[nonzero_mask]\n    \n    # 5. Apply Gaussian smoothing\n    if smoothing_alpha > 0:\n        g_r_smoothed = gaussian_filter1d(g_r, sigma=smoothing_alpha, mode='nearest')\n    else:\n        g_r_smoothed = g_r\n\n    # 6. Compute diagnostics\n    # Mean absolute deviation D\n    D = np.mean(np.abs(g_r_smoothed - 1.0))\n    \n    # Coordination number error E\n    indices_to_sum = np.where(bin_centers = rc)[0]\n    integral_sum = np.sum(g_r_smoothed[indices_to_sum] * bin_centers[indices_to_sum]**2)\n    n_rc_computed = 4.0 * np.pi * rho * delta_r * integral_sum\n    n_rc_ideal = rho * (4.0/3.0) * np.pi * rc**3\n    E = n_rc_computed - n_rc_ideal\n    \n    return [delta_r, M, D, E]\n\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        },
        {
            "introduction": "径向分布函数$g(r)$不仅是一个结构描述符，它更是连接微观结构与宏观热力学性质的桥梁。本练习将探讨硬球系统中的一个经典且基本的关联：径向分布函数在接触距离处的值$g(\\sigma^{+})$与系统压力（通过压缩因子$Z$体现）之间的关系。通过推导这一关系，你将深刻理解$g(r)$的短程特征所蕴含的物理意义。",
            "id": "4081099",
            "problem": "考虑一个三维 (3D) 单分散硬球流体，其数密度为 $\\rho$，硬核直径为 $\\sigma$。堆积分数定义为 $\\eta = \\frac{\\pi}{6}\\,\\rho\\,\\sigma^{3}$。径向分布函数 (RDF)，记作 $g(r)$，是在相同密度下，相对于理想气体，在参考粒子距离 $r$ 处找到另一个粒子的概率密度。硬球对势为：当 $r  \\sigma$ 时 $u(r)=\\infty$，当 $r\\ge\\sigma$ 时 $u(r)=0$。压缩因子 $Z$ 定义为 $Z=\\frac{\\beta p}{\\rho}$，其中 $p$ 是压力，$\\beta=1/(k_{B}T)$，$k_{B}$ 是玻尔兹曼常数，$T$ 是绝对温度。\n\n从球对称成对相加流体的压力维里表达式和硬球势的性质出发，推导连接压缩因子 $Z$ 和径向分布函数的接触值 $g(\\sigma^{+})$ 的关系式，其中 $\\sigma^{+}$ 表示 $r$ 从上方趋近于 $\\sigma$ 的极限。然后，使用给定的 Carnahan–Starling (CS) 状态方程：\n$$\nZ_{\\mathrm{CS}}(\\eta)=\\frac{1+\\eta+\\eta^{2}-\\eta^{3}}{(1-\\eta)^{3}},\n$$\n得到 $g(\\sigma^{+})$ 作为 $\\eta$ 函数的闭合形式解析表达式。最后，计算在堆积分数 $\\eta=0.37$ 时 $g(\\sigma^{+})$ 的值。将你的数值答案四舍五入到四位有效数字。将最终答案表示为一个无量纲数（无单位）。",
            "solution": "该问题要求我们首先推导硬球流体的压缩因子 $Z$ 与径向分布函数的接触值 $g(\\sigma^{+})$ 之间的关系。然后，利用给定的 Carnahan–Starling 状态方程，我们必须找到 $g(\\sigma^{+})$ 关于堆积分数 $\\eta$ 的显式表达式，并最终计算其在 $\\eta=0.37$ 时的值。\n\n推导始于具有球对称、成对相加势 $u(r)$ 的流体的压力 $p$ 的维里方程：\n$$\nZ = \\frac{\\beta p}{\\rho} = 1 - \\frac{\\rho}{6k_{B}T} \\int_{0}^{\\infty} r \\frac{du(r)}{dr} g(r) 4\\pi r^2 dr\n$$\n其中 $\\rho$ 是数密度，$\\beta = 1/(k_{B}T)$，$k_{B}$ 是玻尔兹曼常数，$T$ 是温度，$g(r)$ 是径向分布函数。这可以重写为：\n$$\nZ = 1 - \\frac{2\\pi\\rho}{3k_{B}T} \\int_{0}^{\\infty} r^3 g(r) \\frac{du(r)}{dr} dr\n$$\n对于硬球流体，对势 $u(r)$ 由以下公式给出：\n$$\nu(r) = \\begin{cases} \\infty  \\text{for } r  \\sigma \\\\ 0  \\text{for } r \\ge \\sigma \\end{cases}\n$$\n其中 $\\sigma$ 是硬球直径。由于粒子重叠会产生无限大的势能代价，因此对于 $r  \\sigma$，$g(r)$ 必须为零。$g(r)$ 和 $u(r)$ 之间的关系由空腔函数 $y(r)$ 介导，它是一个连续函数。关系式为 $g(r) = y(r)\\exp(-\\beta u(r))$。\n对于 $r  \\sigma$，$u(r) = \\infty$，所以 $\\exp(-\\beta u(r)) = 0$，这保证了 $g(r) = 0$。\n对于 $r \\ge \\sigma$，$u(r) = 0$，所以 $\\exp(-\\beta u(r)) = 1$，因此 $g(r) = y(r)$。\n由于 $y(r)$ 是连续的，RDF 的接触值 $g(\\sigma^{+})$ 等于 $y(\\sigma)$。\n\n导数 $\\frac{du(r)}{dr}$ 仅在不连续点 $r=\\sigma$ 处非零，其行为类似于狄拉克δ函数。为了严格处理这个奇点，我们可以使用恒等式：\n$$\n\\frac{du(r)}{dr} \\exp(-\\beta u(r)) = -k_{B}T \\frac{d}{dr}\\left[\\exp(-\\beta u(r))\\right]\n$$\n将 $g(r) = y(r)\\exp(-\\beta u(r))$ 代入维里方程：\n$$\nZ = 1 - \\frac{2\\pi\\rho}{3k_{B}T} \\int_{0}^{\\infty} r^3 y(r) \\exp(-\\beta u(r)) \\frac{du(r)}{dr} dr\n$$\n使用上述恒等式，这变为：\n$$\nZ = 1 - \\frac{2\\pi\\rho}{3k_{B}T} \\int_{0}^{\\infty} r^3 y(r) \\left(-k_{B}T \\frac{d}{dr}\\left[\\exp(-\\beta u(r))\\right]\\right) dr\n$$\n$$\nZ = 1 + \\frac{2\\pi\\rho}{3} \\int_{0}^{\\infty} r^3 y(r) \\frac{d}{dr}\\left[\\exp(-\\beta u(r))\\right] dr\n$$\n对于硬球，函数 $\\exp(-\\beta u(r))$ 是亥维赛阶跃函数 $H(r-\\sigma)$。其导数是狄拉克δ函数 $\\delta(r-\\sigma)$。\n$$\n\\frac{d}{dr}\\left[\\exp(-\\beta u(r))\\right] = \\frac{d}{dr}H(r-\\sigma) = \\delta(r-\\sigma)\n$$\n将此代入 $Z$ 的表达式中：\n$$\nZ = 1 + \\frac{2\\pi\\rho}{3} \\int_{0}^{\\infty} r^3 y(r) \\delta(r-\\sigma) dr\n$$\n利用狄拉克δ函数的筛选性质，积分的计算结果为：\n$$\n\\int_{0}^{\\infty} r^3 y(r) \\delta(r-\\sigma) dr = \\sigma^3 y(\\sigma)\n$$\n如前所述，$y(\\sigma) = g(\\sigma^{+})$。因此：\n$$\nZ = 1 + \\frac{2\\pi\\rho}{3} \\sigma^3 g(\\sigma^{+})\n$$\n堆积分数 $\\eta$ 定义为 $\\eta = \\frac{\\pi}{6}\\rho\\sigma^3$。我们可以用 $\\eta$ 来表示 $\\rho\\sigma^3$：$\\rho\\sigma^3 = \\frac{6\\eta}{\\pi}$。将此代入 $Z$ 的方程中：\n$$\nZ = 1 + \\frac{2\\pi}{3} \\left(\\frac{6\\eta}{\\pi}\\right) g(\\sigma^{+}) = 1 + 4\\eta g(\\sigma^{+})\n$$\n这就是连接硬球流体的压缩因子和 RDF 接触值的所求关系式。\n\n接下来，我们使用 Carnahan–Starling (CS) 状态方程：\n$$\nZ_{\\mathrm{CS}}(\\eta) = \\frac{1+\\eta+\\eta^{2}-\\eta^{3}}{(1-\\eta)^{3}}\n$$\n通过令两个 $Z$ 的表达式相等，我们可以解出 $g(\\sigma^{+})$：\n$$\n1 + 4\\eta g(\\sigma^{+}) = \\frac{1+\\eta+\\eta^{2}-\\eta^{3}}{(1-\\eta)^{3}}\n$$\n$$\n4\\eta g(\\sigma^{+}) = \\frac{1+\\eta+\\eta^{2}-\\eta^{3}}{(1-\\eta)^{3}} - 1\n$$\n为了合并右侧的项，我们找到一个公分母：\n$$\n4\\eta g(\\sigma^{+}) = \\frac{1+\\eta+\\eta^{2}-\\eta^{3} - (1-\\eta)^3}{(1-\\eta)^{3}}\n$$\n我们展开 $(1-\\eta)^3 = 1 - 3\\eta + 3\\eta^2 - \\eta^3$。将其代入分子：\n$$\n\\text{Numerator} = (1+\\eta+\\eta^{2}-\\eta^{3}) - (1 - 3\\eta + 3\\eta^2 - \\eta^3) = 1+\\eta+\\eta^{2}-\\eta^{3} - 1 + 3\\eta - 3\\eta^2 + \\eta^3 = 4\\eta - 2\\eta^2\n$$\n所以方程变为：\n$$\n4\\eta g(\\sigma^{+}) = \\frac{4\\eta - 2\\eta^2}{(1-\\eta)^3}\n$$\n对于非零密度的流体（$\\eta \\neq 0$），我们可以除以 $4\\eta$：\n$$\ng(\\sigma^{+}) = \\frac{4\\eta - 2\\eta^2}{4\\eta(1-\\eta)^3} = \\frac{2\\eta(2-\\eta)}{4\\eta(1-\\eta)^3} = \\frac{2-\\eta}{2(1-\\eta)^3}\n$$\n这可以写成：\n$$\ng(\\sigma^{+}) = \\frac{1-\\frac{\\eta}{2}}{(1-\\eta)^3}\n$$\n这就是 $g(\\sigma^{+})$ 作为 $\\eta$ 函数的闭合形式解析表达式。\n\n最后，我们计算在给定堆积分数 $\\eta=0.37$ 时该表达式的值：\n$$\ng(\\sigma^{+}) = \\frac{1-\\frac{0.37}{2}}{(1-0.37)^3} = \\frac{1-0.185}{(0.63)^3} = \\frac{0.815}{0.250047}\n$$\n$$\ng(\\sigma^{+}) \\approx 3.25936412\n$$\n将此结果四舍五入到四位有效数字，得到 $3.259$。",
            "answer": "$$ \\boxed{3.259} $$"
        },
        {
            "introduction": "现实世界中的复杂流体通常是多组分混合物。为了描述这类体系的结构，我们需要将径向分布函数的概念推广，引入偏径向分布函数$g_{\\alpha\\beta}(r)$，它能精确描述不同物种之间的特定关联。在本练习中，你将学习如何调整计算和归一化方法，以正确地计算这些描述混合物结构的关键函数。",
            "id": "4081089",
            "problem": "考虑一个边长为 $L$ 的三维周期性立方模拟盒子，其中包含 $N$ 个点状粒子，其位置为 $\\{\\mathbf{r}_i\\}_{i=1}^N$，每个粒子都由一个物种索引 $s_i \\in \\{\\alpha_1,\\alpha_2,\\dots,\\alpha_K\\}$ 标记。平衡态下的静态结构由径向分布函数 (RDF) 来量化。对于多组分混合物，RDF通过偏径向分布函数 $g_{\\alpha\\beta}(r)$ 来定义，其中 $\\alpha$ 和 $\\beta$ 表示物种标签。径向分布函数 (RDF) 是指在间距为 $r$ 处的粒子对密度与其在相同数密度下的理想（不相关）参考值之比。你的任务是从第一性原理出发，为总 RDF $g(r)$ 和所有偏 RDF $g_{\\alpha\\beta}(r)$ 推导出一个计算估计量，并将其实现为一个程序，用以处理指定的测试套件。\n\n使用以下基本依据和定律：\n- 系统在一个体积为 $V = L^3$ 的立方盒子中，处于平衡态的三维均匀且各向同性的状态，通过最小镜像约定施加周期性边界条件。粒子 $i$ 和 $j$ 之间的最小镜像位移为 $\\Delta\\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i - L \\,\\mathrm{round}\\left((\\mathbf{r}_j - \\mathbf{r}_i)/L\\right)$。\n- 物种 $\\alpha$ 的数密度为 $\\rho_\\alpha = N_\\alpha/V$，其中 $N_\\alpha$ 是物种 $\\alpha$ 的粒子数，总数密度为 $\\rho = N/V$。\n- 在一个内径为 $r$、厚度为 $\\Delta r$ 的球壳中，理想气体中粒子对计数的参考值与球壳体积 $V_{\\mathrm{shell}}(r;\\Delta r) = \\frac{4\\pi}{3}\\left((r+\\Delta r)^3 - r^3\\right)$ 和相应的数密度之积成正比。对于无序对计数（每个不同的对只计数一次），理想混合物中的期望计数，对于 $\\alpha \\neq \\beta$ 的情况，与 $N_\\alpha \\rho_\\beta V_{\\mathrm{shell}}(r;\\Delta r)$ 成正比；对于 $\\alpha = \\beta$ 的情况，与 $\\frac{1}{2}N_\\alpha \\rho_\\alpha V_{\\mathrm{shell}}(r;\\Delta r)$ 成正比。对于所有粒子对的总和，期望计数与 $\\frac{1}{2} N \\rho V_{\\mathrm{shell}}(r;\\Delta r)$ 成比例。\n\n严格基于以上依据，推导一个算法以实现以下功能：\n1. 对所有满足 $i  j$ 的无序对计算最小镜像距离，并构建总计数和偏计数的直方图。\n2. 对于每个径向分箱，使用适当的归一化因子将计数的直方图转换为 $g(r)$ 和 $g_{\\alpha\\beta}(r)$ 的估计值。\n3. 将结果输出为一个包含分箱中心、总 RDF 以及按物种索引顺序排列的所有唯一偏 RDF（例如，$g_{AA}$，$g_{AB}$，$g_{BB}$）的列表。\n\n为强制实现科学真实性的实现细节：\n- 物种标签在输入中作为字符串提供，但必须按给定的 `species_order` 列表映射到从零开始的整数索引（$0, 1, \\dots, K-1$）进行处理。\n- 最终输出中偏 RDF 的顺序必须遵循此整数索引的规范排序：$g_{00}, g_{01}, \\dots, g_{0,K-1}, g_{11}, g_{12}, \\dots, g_{K-1,K-1}$。\n- 所有计算必须在浮点精度下进行。如果任何归一化因子为零（例如，如果某个物种的粒子数少于 2 个），则相应的 RDF 值应报告为 $0.0$。\n\n单位和输出格式：\n- 所有长度必须以问题中指定的单位进行处理。\n- 你的程序应生成单行输出，其中包含一个列表，列表的每个元素都是一个测试用例的结果。每个测试用例的结果本身就是一个列表，其结构如下：`[bin_centers, g_total, g_partial_00, g_partial_01, ..., g_partial_KK]`。例如，一个有效的输出格式是 `[[[c1,c2,...],[g1,g2,...],[gp1,gp2,...]], ...]`。该行必须只包含此单个列表，不含任何额外文本或空格。",
            "solution": "该问题要求针对周期性立方盒子中的多组分粒子系统，推导并实现用于计算总径向分布函数 (RDF) $g(r)$ 和所有偏 RDF $g_{\\alpha\\beta}(r)$ 的计算估计量。推导将严格基于所提供的原理和定义。\n\n**1. 系统与离散化**\n\n系统包含 $N$ 个粒子，位于边长为 $L$、体积为 $V=L^3$ 的立方盒子中。粒子的位置为 $\\{\\mathbf{r}_i\\}_{i=1}^N$，并按物种标签 $\\{s_i\\}_{i=1}^N$ 分类。假设有 $K$ 个独特物种，由一个有序标签列表 $(\\alpha_1, \\alpha_2, \\dots, \\alpha_K)$ 表示。物种 $\\alpha$ 的粒子数为 $N_\\alpha$，且 $\\sum_{\\alpha} N_\\alpha = N$。物种 $\\alpha$ 的数密度为 $\\rho_\\alpha = N_\\alpha/V$，总数密度为 $\\rho = N/V$。\n\nRDF $g(r)$ 是径向距离 $r$ 的连续函数。为了从离散的粒子位置计算它，我们将径向距离离散化为一系列分箱。我们定义 $M = \\lfloor r_{\\max}/\\Delta r \\rfloor$ 个分箱，其中 $\\Delta r$ 是分箱宽度，$r_{\\max}$ 是我们感兴趣的最大半径，满足 $r_{\\max} \\le L/2$。第 $k$ 个分箱（对于 $k=0, 1, \\dots, M-1$）对应于径向区间 $[r_k, r_{k+1})$，其中 $r_k = k\\,\\Delta r$。这个分箱代表一个球壳。\n\n该球壳的体积由下式给出：\n$$\nV_{\\mathrm{shell},k} = \\frac{4\\pi}{3}\\left(r_{k+1}^3 - r_k^3\\right) = \\frac{4\\pi}{3}\\left((k+1)^3\\Delta r^3 - k^3\\Delta r^3\\right) = \\frac{4\\pi\\Delta r^3}{3}\\left(3k^2 + 3k + 1\\right)\n$$\nRDF 值将在每个分箱的中心 $c_k = r_k + \\Delta r/2 = (k+0.5)\\Delta r$ 处报告。\n\n**2. 粒子对距离计算与直方图统计**\n\n计算的核心在于确定间距落在每个径向分箱内的粒子对数量。我们考虑所有满足 $i  j$ 的无序粒子对 $(i, j)$，以避免重复计数。\n\n对于每一对粒子，位移矢量为 $\\mathbf{d}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i$。为了考虑周期性边界条件 (PBC)，我们使用最小镜像约定 (MIC)。最小镜像位移矢量 $\\Delta\\mathbf{r}_{ij}$ 由下式给出：\n$$\n\\Delta\\mathbf{r}_{ij} = \\mathbf{d}_{ij} - L \\cdot \\mathrm{round}\\left(\\frac{\\mathbf{d}_{ij}}{L}\\right)\n$$\n其中 `round` 函数是逐分量应用的。这对粒子之间的距离是该矢量的模：\n$$\nd_{ij} = \\|\\Delta\\mathbf{r}_{ij}\\|\n$$\n如果此距离 $d_{ij}$ 小于 $r_{\\max}$，它将被分配到分箱 $k = \\lfloor d_{ij}/\\Delta r \\rfloor$。\n\n我们在直方图中累积这些计数。设 $H_{\\text{total}}(k)$ 为分箱 $k$ 中粒子对的总数。类似地，设 $H_{\\alpha\\beta}(k)$ 为分箱 $k$ 中一个粒子属于物种 $\\alpha$ 而另一个属于物种 $\\beta$ 的粒子对数量。遵循问题中对无序对的约定，物种对通过 $(\\min(s_i, s_j), \\max(s_j, s_i))$ 来标识，以确保规范计数。\n\n**3. 归一化与 RDF 估计**\n\nRDF 定义为在相同总粒子密度下，测得的粒子对密度与理想气体（一个完全不相关的系统）中的期望粒子对密度之比。所提供的归一化因子是基于无序对计数的。\n\n**总 RDF, $g(r)$**\n\n在分箱 $k$ 中测得的粒子对数量为 $H_{\\text{total}}(k)$。在同一球壳体积 $V_{\\mathrm{shell},k}$ 内，理想气体中的期望粒子对数量被给出为与 $\\frac{1}{2} N \\rho V_{\\mathrm{shell},k}$ 成正比。这作为我们的归一化因子。\n$$\nN_{\\text{ideal, total}}(k) = \\frac{1}{2} N \\rho V_{\\mathrm{shell},k} = \\frac{N^2}{2V} V_{\\mathrm{shell},k}\n$$\n在分箱中心 $c_k$ 处的总 RDF 估计量是观测计数与理想计数之比：\n$$\ng(c_k) = \\frac{H_{\\text{total}}(k)}{N_{\\text{ideal, total}}(k)}\n$$\n\n**偏 RDF, $g_{\\alpha\\beta}(r)$**\n\n同样的原理适用于偏 RDF，但使用特定于物种的密度和计数。\n\n对于**同种粒子对**（例如，物种 $\\alpha$ 与物种 $\\alpha$），观测计数为 $H_{\\alpha\\alpha}(k)$。无序对的理想计数指定为：\n$$\nN_{\\text{ideal}, \\alpha\\alpha}(k) = \\frac{1}{2} N_\\alpha \\rho_\\alpha V_{\\mathrm{shell},k} = \\frac{N_\\alpha^2}{2V} V_{\\mathrm{shell},k}\n$$\n同种偏 RDF 的估计量为：\n$$\ng_{\\alpha\\alpha}(c_k) = \\frac{H_{\\alpha\\alpha}(k)}{N_{\\text{ideal}, \\alpha\\alpha}(k)}\n$$\n如果 $N_\\alpha  2$，计数 $H_{\\alpha\\alpha}(k)$ 将始终为 $0$，归一化因子也为零或不明确。在这种情况下，我们定义 $g_{\\alpha\\alpha}(c_k) = 0$。\n\n对于**异种粒子对**（物种 $\\alpha$ 与物种 $\\beta$，其中 $\\alpha \\neq \\beta$），观测计数为 $H_{\\alpha\\beta}(k)$。理想计数由下式给出：\n$$\nN_{\\text{ideal}, \\alpha\\beta}(k) = N_\\alpha \\rho_\\beta V_{\\mathrm{shell},k} = \\frac{N_\\alpha N_\\beta}{V} V_{\\mathrm{shell},k}\n$$\n异种偏 RDF 的估计量为：\n$$\ng_{\\alpha\\beta}(c_k) = \\frac{H_{\\alpha\\beta}(k)}{N_{\\text{ideal}, \\alpha\\beta}(k)}\n$$\n如果 $N_\\alpha=0$ 或 $N_\\beta=0$，则观测计数和理想计数均为零，因此我们定义 $g_{\\alpha\\beta}(c_k)=0$。\n\n**4. 算法实现大纲**\n\n每个测试用例的算法流程如下：\n1.  解析输入参数：$L$、粒子位置和物种、$\\Delta r$ 和 $r_{\\max}$。为提高计算效率，将位置合并到单个数组中，并将物种合并到相应的整数索引数组中。\n2.  计算系统范围的属性：体积 $V=L^3$、总粒子数 $N$、各物种粒子数 $N_\\alpha$ 以及密度 $\\rho$ 和 $\\rho_\\alpha$。\n3.  将总计数和偏计数的直方图数组初始化为零。分箱数量为 $M = \\lfloor r_{\\max}/\\Delta r \\rfloor$。\n4.  遍历所有满足 $i  j$ 的唯一粒子对 $(i,j)$。\n    a. 使用最小镜像约定计算距离 $d_{ij}$。\n    b. 如果 $d_{ij}  r_{\\max}$，找到分箱索引 $k = \\lfloor d_{ij}/\\Delta r \\rfloor$。\n    c. 将总计数 `H_total[k]` 加一。\n    d. 识别该对的物种索引 $(s_i, s_j)$，确定规范的粒子对索引 $(\\min(s_i, s_j), \\max(s_i, s_j))$，并增加相应的偏计数 `H_partial[min(s_i,s_j)][max(s_i,s_j)][k]`。\n5.  将 $g(c_k)$ 和所有 $g_{\\alpha\\beta}(c_k)$ 的结果数组初始化为零。\n6.  从分箱 $k=0$ 遍历到 $M-1$：\n    a. 计算球壳体积 $V_{\\mathrm{shell},k}$。\n    b. 计算所有归一化因子（$N_{\\text{ideal, total}}$、$N_{\\text{ideal}, \\alpha\\alpha}$、$N_{\\text{ideal}, \\alpha\\beta}$）。\n    c. 如果归一化因子非零，则通过将直方图计数除以该因子来计算相应的 RDF 值。否则，RDF 值保持为 $0$。\n7.  收集分箱中心列表和所有计算出的 RDF 数组。按照问题陈述中指定的嵌套列表结构格式化这些数据，确保偏 RDF 的顺序符合规定。\n\n此过程构成了一个完整且确定性的算法，用于根据问题中阐述的第一性原理计算所需的 RDF。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are used.\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It processes each test case, calculates the RDFs, and prints the final result.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"L\": 10.0,\n            \"positions\": {\n                \"A\": [[1.0, 1.0, 1.0], [1.0, 3.0, 1.0], [4.0, 4.0, 4.0]],\n                \"B\": [[8.0, 1.0, 1.0], [5.0, 4.0, 4.5], [1.0, 8.0, 1.0]]\n            },\n            \"species_order\": [\"A\", \"B\"],\n            \"dr\": 0.5,\n            \"r_max\": 5.0\n        },\n        {\n            \"L\": 12.0,\n            \"positions\": {\n                \"C\": [[1.0, 1.0, 1.0], [11.0, 1.0, 1.0], [6.0, 6.0, 6.0], [1.0, 11.0, 11.0]]\n            },\n            \"species_order\": [\"C\"],\n            \"dr\": 1.0,\n            \"r_max\": 6.0\n        },\n        {\n            \"L\": 10.0,\n            \"positions\": {\n                \"A\": [[2.0, 2.0, 2.0]],\n                \"B\": [[2.5, 2.0, 2.0], [7.0, 7.0, 7.0], [7.5, 7.0, 7.0], [7.0, 7.5, 7.0], [7.0, 7.0, 7.5], [9.0, 9.0, 9.0], [9.5, 9.0, 9.0]]\n            },\n            \"species_order\": [\"A\", \"B\"],\n            \"dr\": 0.4,\n            \"r_max\": 4.0\n        },\n        {\n            \"L\": 8.0,\n            \"positions\": {\n                \"A\": [[0.5, 0.5, 0.5], [4.0, 4.0, 4.0]],\n                \"B\": [[7.5, 7.5, 7.5], [4.0, 0.5, 7.5]]\n            },\n            \"species_order\": [\"A\", \"B\"],\n            \"dr\": 0.5,\n            \"r_max\": 4.0\n        },\n        {\n            \"L\": 9.0,\n            \"positions\": {\n                \"A\": [[1.0, 1.0, 1.0], [3.0, 1.0, 1.0]],\n                \"B\": [[5.0, 5.0, 5.0], [5.5, 5.0, 5.5]],\n                \"C\": [[8.0, 8.0, 8.0]]\n            },\n            \"species_order\": [\"A\", \"B\", \"C\"],\n            \"dr\": 0.6,\n            \"r_max\": 4.0\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = calculate_rdf(\n            case[\"L\"],\n            case[\"positions\"],\n            case[\"species_order\"],\n            case[\"dr\"],\n            case[\"r_max\"]\n        )\n        all_results.append(result)\n\n    # Final print statement in the exact required format.\n    def format_list(item):\n        if isinstance(item, list):\n            return f\"[{','.join(format_list(sub_item) for sub_item in item)}]\"\n        elif isinstance(item, np.ndarray):\n            return format_list(item.tolist())\n        else:\n            return repr(item)\n\n    final_output_str = format_list(all_results).replace(\" \", \"\")\n    print(final_output_str)\n\ndef calculate_rdf(L, positions_dict, species_order, dr, r_max):\n    \"\"\"\n    Calculates total and partial RDFs for a given particle configuration.\n    \"\"\"\n    # 1. Prepare data structures\n    V = L**3\n    species_map = {name: i for i, name in enumerate(species_order)}\n    num_species = len(species_order)\n\n    all_pos = []\n    all_species_indices = []\n    species_counts = np.zeros(num_species, dtype=int)\n\n    for species_name, pos_list in positions_dict.items():\n        if species_name in species_map:\n            idx = species_map[species_name]\n            all_pos.extend(pos_list)\n            all_species_indices.extend([idx] * len(pos_list))\n            species_counts[idx] = len(pos_list)\n\n    all_pos = np.array(all_pos, dtype=float)\n    all_species_indices = np.array(all_species_indices, dtype=int)\n    N = len(all_pos)\n    \n    num_bins = int(np.floor(r_max / dr))\n    bin_centers = (np.arange(num_bins) + 0.5) * dr if num_bins > 0 else np.array([])\n    \n    if N  2: # Handle empty or single particle system case\n        g_total = np.zeros(num_bins)\n        results = [bin_centers.tolist(), g_total.tolist()]\n        for i in range(num_species):\n            for j in range(i, num_species):\n                 results.append(np.zeros(num_bins).tolist())\n        return results\n\n    rho = N / V\n    species_rhos = species_counts / V\n\n    # 2. Setup bins and histograms\n    total_counts = np.zeros(num_bins, dtype=int)\n    partial_counts = np.zeros((num_species, num_species, num_bins), dtype=int)\n\n    # 3. Pair distance calculation and binning\n    for i in range(N):\n        for j in range(i + 1, N):\n            rij = all_pos[j] - all_pos[i]\n            rij -= L * np.round(rij / L) # Minimum image convention\n            dist = np.linalg.norm(rij)\n\n            if dist  r_max:\n                bin_idx = int(np.floor(dist / dr))\n                if bin_idx  num_bins:\n                    total_counts[bin_idx] += 1\n                    \n                    s_i, s_j = all_species_indices[i], all_species_indices[j]\n                    # Canonical species pair indexing\n                    idx1, idx2 = min(s_i, s_j), max(s_i, s_j)\n                    partial_counts[idx1, idx2, bin_idx] += 1\n\n    # 4. Normalization\n    g_total = np.zeros(num_bins, dtype=float)\n    g_partials = { (i,j): np.zeros(num_bins, dtype=float) for i in range(num_species) for j in range(i,num_species) }\n\n    for k in range(num_bins):\n        r_in = k * dr\n        r_out = (k + 1) * dr\n        shell_volume = (4.0 / 3.0) * np.pi * (r_out**3 - r_in**3)\n\n        # Total RDF\n        norm_total = 0.5 * N * rho * shell_volume\n        if norm_total > 0:\n            g_total[k] = total_counts[k] / norm_total\n        \n        # Partial RDFs\n        for i in range(num_species):\n            for j in range(i, num_species):\n                count = partial_counts[i, j, k]\n                if i == j: # Homogeneous\n                    if species_counts[i] >= 2:\n                        norm_partial = 0.5 * species_counts[i] * species_rhos[i] * shell_volume\n                        if norm_partial > 0:\n                           g_partials[(i,j)][k] = count / norm_partial\n                else: # Heterogeneous\n                    if species_counts[i] > 0 and species_counts[j] > 0:\n                        norm_partial = species_counts[i] * species_rhos[j] * shell_volume\n                        if norm_partial > 0:\n                            g_partials[(i,j)][k] = count / norm_partial\n    \n    # 5. Assemble results in specified order\n    final_results_list = [bin_centers.tolist(), g_total.tolist()]\n    for i in range(num_species):\n        for j in range(i, num_species):\n            final_results_list.append(g_partials[(i,j)].tolist())\n            \n    return final_results_list\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        }
    ]
}