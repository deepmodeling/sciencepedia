{
    "hands_on_practices": [
        {
            "introduction": "在将恒温器用于复杂模拟之前，验证其能否正确生成目标统计系综至关重要。这个基础练习将引导您推导正则系综中恒容热容 $C_V$ 与总能量涨落之间的关系。掌握这一联系将为您提供一个强有力的工具，通过分析模拟产生的能量时间序列来验证恒温器的性能 。",
            "id": "4109965",
            "problem": "一个复杂流体的分子动力学 (MD) 模拟在固定体积的立方盒子中进行，使用 Andersen 恒温器（随机速度重采样）或 Nosé–Hoover 恒温器（确定性扩展系统耦合）来控制温度。在适当条件下，这两种恒温器都旨在生成与温度 $T$ 下的正则系综一致的采样。考虑嵌入在流体中的最简单参考系统：$N$ 个质量为 $m$ 的相同单原子示踪粒子，在采样时间尺度上，它们的相互势能可以忽略不计，因此哈密顿量为 $H(\\boldsymbol{\\Gamma})=E(\\boldsymbol{\\Gamma})=K(\\mathbf{p})=\\sum_{i=1}^{N}\\sum_{\\alpha=1}^{3}\\frac{p_{i,\\alpha}^{2}}{2m}$，其中 $\\boldsymbol{\\Gamma}$ 表示相空间微观状态，$\\mathbf{p}$ 包含所有动量。恒温器对微观状态施加了正则分布，其概率密度函数 (PDF) 为 $f(\\boldsymbol{\\Gamma}) \\propto \\exp(-\\beta H(\\boldsymbol{\\Gamma}))$，其中 $\\beta = 1/(k_{B}T)$，$k_{B}$ 是玻尔兹曼常数。\n\n从正则系综的定义和统计力学的基本关系出发，推导该系统总能量 $E$ 的期望平均值 $\\langle E \\rangle$ 和方差 $\\operatorname{Var}(E)$。然后，仅使用正则系综的推理，推导一个将恒容热容 $C_{V}$ 与能量涨落联系起来的表达式。将该表达式应用于这个特定的纯动能系统，以获得一个用 $N$ 和 $k_{B}$ 表示的 $C_{V}$ 的封闭形式解析表达式。\n\n以一个用 $N$ 和 $k_{B}$ 表示的 $C_{V}$ 的单一封闭形式表达式给出最终答案。将 $C_{V}$ 的单位表示为焦耳每开尔文。",
            "solution": "该问题是有效的，因为它在科学上基于经典统计力学，定义良好，具有明确的系统和目标，并且不包含矛盾或模糊之处。我们按要求进行推导。\n\n该系统由 $N$ 个质量为 $m$ 的相同单原子粒子组成。势能可以忽略不计，因此总能量 $E$ 完全是动能。哈密顿量由 $H(\\boldsymbol{\\Gamma}) = K(\\mathbf{p}) = \\sum_{i=1}^{N}\\sum_{\\alpha=1}^{3}\\frac{p_{i,\\alpha}^{2}}{2m}$ 给出，其中 $\\mathbf{p}$ 代表所有粒子的动量。系统维持在恒定温度 $T$ 和体积 $V$下，这对应于正则系综。一个微观状态 $\\boldsymbol{\\Gamma}$ 的概率密度函数为 $f(\\boldsymbol{\\Gamma}) \\propto \\exp(-\\beta E(\\boldsymbol{\\Gamma}))$，其中 $\\beta = 1/(k_{B}T)$。\n\n首先，我们推导平均能量 $\\langle E \\rangle$ 和能量的方差 $\\operatorname{Var}(E)$。这些量可以从正则配分函数 $Q(N, V, T)$ 推导出来。\n配分函数的定义为：\n$$Q = \\frac{1}{N! h^{3N}} \\int \\exp(-\\beta H(\\boldsymbol{\\Gamma})) d\\boldsymbol{\\Gamma} = \\frac{1}{N! h^{3N}} \\int d^{3N}\\mathbf{r} \\int d^{3N}\\mathbf{p} \\exp(-\\beta K(\\mathbf{p}))$$\n由于哈密顿量仅依赖于动量，对空间坐标 $\\mathbf{r}$ 的积分就是总体积的 $N$ 次方，即 $V^N$。动量积分可以分解为 $3N$ 个独立的、相同的积分，每个动量分量 $p_{i,\\alpha}$ 对应一个：\n$$\\int d^{3N}\\mathbf{p} \\exp\\left(-\\beta \\sum_{j=1}^{3N} \\frac{p_j^2}{2m}\\right) = \\left[ \\int_{-\\infty}^{\\infty} dp \\exp\\left(-\\frac{\\beta p^2}{2m}\\right) \\right]^{3N}$$\n其中索引 $j$ 从 $1$ 到 $3N$。这是一个标准的高斯积分，形式为 $\\int_{-\\infty}^{\\infty} \\exp(-ax^2)dx = \\sqrt{\\pi/a}$。在这里，$a = \\beta/(2m)$。因此，每个积分的计算结果为 $\\sqrt{2\\pi m/\\beta}$。\n完整的配分函数是：\n$$Q = \\frac{V^N}{N! h^{3N}} \\left(\\frac{2\\pi m}{\\beta}\\right)^{3N/2}$$\n为了我们的计算，使用配分函数的自然对数 $\\ln Q$ 更为方便：\n$$\\ln Q = N \\ln V - \\ln(N!) - 3N \\ln h + \\frac{3N}{2} \\ln(2\\pi m) - \\frac{3N}{2} \\ln \\beta$$\n\n期望平均能量 $\\langle E \\rangle$ 从以下关系式获得：\n$$\\langle E \\rangle = -\\frac{\\partial (\\ln Q)}{\\partial \\beta}$$\n将此应用于我们的 $\\ln Q$ 表达式，我们对 $\\beta$ 求导。除了最后一项，所有项相对于 $\\beta$ 都是常数。\n$$\\langle E \\rangle = -\\frac{\\partial}{\\partial \\beta} \\left(-\\frac{3N}{2} \\ln \\beta\\right) = \\frac{3N}{2\\beta}$$\n代入 $\\beta = 1/(k_B T)$，我们得到平均能量：\n$$\\langle E \\rangle = \\frac{3N}{2} k_B T$$\n\n能量的方差 $\\operatorname{Var}(E)$，量化了能量涨落，由 $\\ln Q$ 的二阶导数给出：\n$$\\operatorname{Var}(E) = \\langle (E - \\langle E \\rangle)^2 \\rangle = \\frac{\\partial^2 (\\ln Q)}{\\partial \\beta^2}$$\n或者，我们可以将其计算为 $\\operatorname{Var}(E) = -\\frac{\\partial \\langle E \\rangle}{\\partial \\beta}$。使用 $\\langle E \\rangle = \\frac{3N}{2\\beta}$ 的表达式：\n$$\\operatorname{Var}(E) = -\\frac{\\partial}{\\partial \\beta} \\left(\\frac{3N}{2\\beta}\\right) = - \\left(-\\frac{3N}{2\\beta^2}\\right) = \\frac{3N}{2\\beta^2}$$\n代入 $\\beta = 1/(k_B T)$，方差为：\n$$\\operatorname{Var}(E) = \\frac{3N}{2} (k_B T)^2$$\n\n接下来，我们推导正则系综中恒容热容 $C_V$ 与能量涨落之间的一般关系。$C_V$ 的定义是：\n$$C_V = \\left(\\frac{\\partial \\langle E \\rangle}{\\partial T}\\right)_{V, N}$$\n为了将其与我们依赖于 $\\beta$ 的统计表达式联系起来，我们使用链式法则将求导变量从 $T$ 变为 $\\beta$：\n$$\\frac{\\partial}{\\partial T} = \\frac{d\\beta}{dT} \\frac{\\partial}{\\partial \\beta}$$\n由于 $\\beta = 1/(k_B T)$，我们有 $\\frac{d\\beta}{dT} = -\\frac{1}{k_B T^2}$。将此代入 $C_V$ 的定义中：\n$$C_V = \\left(-\\frac{1}{k_B T^2}\\right) \\left(\\frac{\\partial \\langle E \\rangle}{\\partial \\beta}\\right)_{V, N}$$\n我们之前已经确定 $\\operatorname{Var}(E) = -\\frac{\\partial \\langle E \\rangle}{\\partial \\beta}$。将此代入 $C_V$ 的表达式中：\n$$C_V = \\left(-\\frac{1}{k_B T^2}\\right) (-\\operatorname{Var}(E)) = \\frac{\\operatorname{Var}(E)}{k_B T^2}$$\n这是将热容与能量方差联系起来的基本涨落-耗散定理。\n\n最后，我们将此通用公式应用于我们的特定系统。我们将推导出的能量方差表达式 $\\operatorname{Var}(E) = \\frac{3N}{2} (k_B T)^2$ 代入 $C_V$ 的公式中：\n$$C_V = \\frac{\\frac{3N}{2} (k_B T)^2}{k_B T^2}$$\n分子和分母中的 $k_B T^2$ 项相互抵消，得到热容的最终表达式：\n$$C_V = \\frac{3N}{2} k_B$$\n这个结果与能量均分定理一致，该定理指出每个二次自由度对平均能量的贡献为 $\\frac{1}{2} k_B T$。对于 $N$ 个单原子粒子，有 $3N$ 个平动自由度，因此 $\\langle E \\rangle = \\frac{3N}{2}k_B T$，从而 $C_V = (\\partial \\langle E \\rangle / \\partial T)_V = \\frac{3N}{2}k_B$。我们从第一性原理和涨落理论出发的推导证实了这一结果。最终表达式给出了用 $N$ 和 $k_B$ 表示的 $C_V$，其单位按要求是焦耳每开尔文。",
            "answer": "$$\\boxed{\\frac{3N}{2} k_B}$$"
        },
        {
            "introduction": "Nosé-Hoover 恒温器因其能够保持系统动力学的确定性特性而备受赞誉，但它并非没有缺陷。本实践练习将探索经典的 Nosé-Hoover 恒温谐振子系统，该系统以展现从周期性到混沌的惊人丰富的行为谱而闻名。通过编写模拟程序并对其动力学行为进行分类，您将亲身体验遍历性这一关键问题，并理解为何审慎选择参数对于可靠的正则系综抽样至关重要 。",
            "id": "4109985",
            "problem": "考虑一个一维谐振子与单个 Nosé-Hoover 恒温器耦合，用于对正则系综进行采样。该物理振子质量为 $m$，弹簧常数为 $k$，并与温度为 $T$ 的热浴接触。该恒温器引入了一个额外的变量 $\\zeta$（一个类摩擦变量）和一个恒温器惯量（类质量参数）$Q$。该系统在计算复杂流体框架内进行研究。\n\n从基本定律和核心定义出发，推导振子坐标 $x$、其共轭动量 $p$ 以及恒温器变量 $\\zeta$ 的运动方程。推导必须基于第一性原理：适用于谐振子的牛顿第二定律，以及强制瞬时动能温度弛豫到目标温度的 Nosé-Hoover 扩展动力学方案。明确定义所有使用的假设和标度变换。\n\n然后分析所得动力学系统的不动点。确定当 $T>0$ 时是否存在不动点，如果存在，则通过在这些点周围进行动力学线性化来对其稳定性进行分类。你的分析必须是自洽的，并且不得先验地假设任何目标公式。\n\n最后，实现一个数值程序，将 Nosé-Hoover 振子作为 $Q$ 的函数的长时间行为分为三类之一：周期性、准周期性或混沌。分类必须基于以下纯数学术语表述的算法标准：\n\n- 使用应用于所推导的常微分方程组的标准切空间 (Benettin) 方法，计算最大李雅普诺夫指数 $\\lambda_{\\max}$。使用固定步长的显式积分器来演化两个邻近的轨道，并周期性地重新归一化它们的间距。如果 $\\lambda_{\\max}$ 严格大于阈值 $\\lambda_{\\text{thr}}$，则将动力学行为分类为混沌。使用 $\\lambda_{\\text{thr}}=10^{-3}$。\n- 如果 $\\lambda_{\\max} \\le \\lambda_{\\text{thr}}$，则计算坐标 $x(t)$ 稳态部分的离散时间傅里叶变换以估计功率谱。排除零频率模式，并计数显著峰值的数量，显著峰值定义为振幅超过谱中全局非零最大振幅固定比例 $f_{\\text{peak}}$ 的局部最大值。使用 $f_{\\text{peak}}=0.15$。如果恰好存在一个显著峰值，则分类为周期性；如果存在多个显著峰值，则分类为准周期性。\n\n在模拟中采用以下无量纲化方案：设置 $m=1$，$k=1$ 和 $k_{\\mathrm{B}}T=1$，其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，因此时间、长度和能量均以相应的自然单位度量。使用初始条件 $x(0)=1$，$p(0)=0$ 和 $\\zeta(0)=0$。积分总时间为 $t_{\\text{total}}=200$（无量纲时间单位），固定时间步长为 $dt=2\\times 10^{-3}$，并在形成功率谱时舍弃初始瞬态 $t_{\\text{discard}}=50$。对于李雅普诺夫指数，使用两个轨道间的初始间距 $\\delta_0=10^{-6}$，并每隔 $\\tau= k_{\\text{norm}}\\,dt$（其中 $k_{\\text{norm}}=20$ 步）重新归一化间距。\n\n测试套件：\n评估以下五个恒温器惯量值的分类：\n- $Q=0.05$\n- $Q=0.2$\n- $Q=1.0$\n- $Q=3.0$\n- $Q=10.0$\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。对于每个测试用例，输出分类的整数代码：$0$ 表示周期性，$1$ 表示准周期性，$2$ 表示混沌。例如，输出形式可能为 $[0,1,2,1,0]$。由于系统是在无量纲单位下定义的，因此不需要物理单位。不涉及角度。",
            "solution": "该问题被评估为 **有效**。这是一个在计算物理学中提法恰当、有科学依据且客观的问题，需要推导、分析和数值实现。\n\n### 第 1 部分：运动方程的推导\n\n该系统由一个一维谐振子与一个 Nosé-Hoover 恒温器耦合而成。恒温器的目标是确保系统在目标温度 $T$ 下对正则 (NVT) 系综进行采样。这是通过引入扩展的动力学变量来实现的。\n\n设振子的位置为 $x$，动量为 $p$。该谐振子质量为 $m$，弹簧常数为 $k$。其物理哈密顿量为 $H(x,p) = \\frac{p^2}{2m} + V(x)$，势能为 $V(x) = \\frac{1}{2}kx^2$。\n\nNosé-Hoover 形式主义通过引入一个随时间变化的摩擦系数 $\\zeta$（其本身也是一个动力学变量）来修改标准的哈密顿运动方程。该方程组基于两个原理构建：\n\n1.  **修正的牛顿动力学**：物理粒子的力方程增加了一个摩擦项，$-\\zeta p$，该项可以向系统增加或移除能量。\n    $$ \\dot{p} = F(x) - \\zeta p = -\\frac{\\partial V}{\\partial x} - \\zeta p = -kx - \\zeta p $$\n    位置根据动量的标准定义演化：\n    $$ \\dot{x} = \\frac{p}{m} $$\n\n2.  **恒温器动力学**：恒温器变量 $\\zeta$ 的演化方式旨在将瞬时动能 $K = \\frac{p^2}{2m}$ 驱动至其对于单自由度的正则系综平均值 $\\langle K \\rangle = \\frac{1}{2} k_{\\mathrm{B}}T$，其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数。$\\zeta$ 的运动方程被设计为提供负反馈。一个常见的选择，源自更形式化的扩展拉格朗日方法，是：\n    $$ \\dot{\\zeta} = \\frac{1}{Q} \\left( 2K - k_{\\mathrm{B}} T \\right) = \\frac{1}{Q} \\left( \\frac{p^2}{m} - k_{\\mathrm{B}} T \\right) $$\n    此处，$Q>0$ 是一个代表恒温器惯量或“质量”的参数，它控制着温度波动的时间尺度。小的 $Q$ 对应于快速响应的恒温器，而大的 $Q$ 则对应于缓慢、弱耦合的恒温器。\n\n将这些结合起来，得到扩展系统 $(x, p, \\zeta)$ 的完整运动方程组：\n$$\n\\begin{cases}\n\\dot{x} = \\frac{p}{m} \\\\\n\\dot{p} = -kx - \\zeta p \\\\\n\\dot{\\zeta} = \\frac{1}{Q} \\left( \\frac{p^2}{m} - k_{\\mathrm{B}}T \\right)\n\\end{cases}\n$$\n问题指定了无量纲化方案，其中 $m=1$，$k=1$ 和 $k_{\\mathrm{B}}T=1$。应用这些设置，得到待模拟的无量纲运动方程：\n$$\n\\begin{cases}\n\\dot{x} = p \\\\\n\\dot{p} = -x - \\zeta p \\\\\n\\dot{\\zeta} = \\frac{1}{Q} (p^2 - 1)\n\\end{cases}\n$$\n\n### 第 2 部分：不动点分析\n\n动力学系统的一个不动点是状态 $(\\bar{x}, \\bar{p}, \\bar{\\zeta})$，在该状态下所有时间导数均为零。我们在无量纲方程中设置 $\\dot{x}=0$，$\\dot{p}=0$ 和 $\\dot{\\zeta}=0$。\n\n1.  从 $\\dot{x} = 0$，我们得到 $\\bar{p} = 0$。\n2.  从 $\\dot{p} = 0$，我们得到 $-\\bar{x} - \\bar{\\zeta} \\bar{p} = 0$。代入第一个方程的 $\\bar{p}=0$，我们发现 $-\\bar{x} = 0$，这意味着 $\\bar{x}=0$。\n3.  从 $\\dot{\\zeta} = 0$，我们得到 $\\frac{1}{Q} (\\bar{p}^2 - 1) = 0$。代入第一个方程的 $\\bar{p}=0$，我们得到 $\\frac{1}{Q} (0^2 - 1) = -\\frac{1}{Q} = 0$。\n\n对于任何有限、非零的恒温器惯量 $Q$，条件 $-\\frac{1}{Q} = 0$ 都无法满足。这构成了一个矛盾，意味着没有解能同时满足所有三个条件。\n\n因此，对于任何温度 $T>0$（在无量纲系统中对应于 $k_{\\mathrm{B}}T=1$），Nosé-Hoover 振子系统**没有不动点**。这是其设计的一个基本特征；恒温器必须持续与系统交换能量以探索相空间并采样正则分布，从而防止其稳定在静态平衡态。由于没有不动点，对其稳定性的分析不适用。\n\n### 第 3 部分：数值实现策略\n\n问题的最后一部分要求实现一个数值程序来对系统的动力学行为进行分类。策略如下：\n\n1.  **数值积分**：使用固定步长的显式积分器对包含三个常微分方程 (ODE) 的系统进行数值求解。四阶龙格－库塔 (RK4) 方法因其准确性和稳定性而成为一个合适的选择。\n\n2.  **李雅普诺夫指数计算**：使用 Benettin 算法计算最大李雅普诺夫指数 $\\lambda_{\\max}$。两个邻近的轨道，一个基准轨道 $\\mathbf{y}(t) = (x(t), p(t), \\zeta(t))$ 和一个微扰轨道 $\\mathbf{y}'(t)$，被同时积分。初始分离向量 $\\mathbf{y}'(0) - \\mathbf{y}(0)$ 有一个很小的模 $\\delta_0$。经过固定步数后，测量两个轨道之间的分离距离。然后将微扰轨道沿着分离向量的方向重新缩放回与基准轨道的距离为 $\\delta_0$ 的位置。这种分离的平均对数增长率给出了 $\\lambda_{\\max}$。如果 $\\lambda_{\\max} > \\lambda_{\\text{thr}}$，系统被分类为混沌。\n\n3.  **功率谱分析**：如果动力学行为不是混沌的，则在频域中分析坐标 $x(t)$ 的长时间行为。轨道的初始瞬态部分被舍弃。计算 $x(t)$ 稳态时间序列的离散时间傅里叶变换 (DFT)。功率谱是 DFT 系数的模的平方。\n\n4.  **峰值计数与分类**：排除零频 (DC) 分量后，识别功率谱中的显著峰值。峰值是一个局部最大值，其振幅超过了由谱中最大峰值振幅的一个比例 $f_{\\text{peak}}$ 定义的阈值。\n    - 如果显著峰值的数量恰好为一，则该运动被分类为周期性。\n    - 如果显著峰值的数量大于一，则被分类为准周期性。\n    - 如果显著峰值的数量为零，它也被分类为周期性，代表一个稳定的、非振荡的状态。\n\n此算法程序将应用于测试套件中指定的每个恒温器惯量 $Q$ 值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import fft\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem. It iterates through test cases,\n    classifies the dynamics of the Nosé-Hoover oscillator for each,\n    and prints the results.\n    \"\"\"\n\n    def dynamics(y, Q_val):\n        \"\"\"\n        Defines the system of ODEs for the Nosé-Hoover oscillator.\n        y = [x, p, zeta]\n        dy/dt = [p, -x - zeta*p, (p**2 - 1)/Q]\n        \"\"\"\n        x, p, zeta = y[0], y[1], y[2]\n        dxdt = p\n        dpdt = -x - zeta * p\n        dzetadt = (p**2 - 1.0) / Q_val\n        return np.array([dxdt, dpdt, dzetadt], dtype=np.float64)\n\n    def rk4_step(y, Q_val, dt, f):\n        \"\"\"\n        Performs a single step of the 4th-order Runge-Kutta method.\n        \"\"\"\n        k1 = f(y, Q_val)\n        k2 = f(y + 0.5 * dt * k1, Q_val)\n        k3 = f(y + 0.5 * dt * k2, Q_val)\n        k4 = f(y + dt * k3, Q_val)\n        return y + (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n\n    def find_significant_peaks(spectrum, max_val, peak_fraction_threshold):\n        \"\"\"\n        Counts local maxima in a spectrum that are above a given threshold.\n        \"\"\"\n        threshold = peak_fraction_threshold * max_val\n        count = 0\n        # Iterate from the second to the second-to-last element\n        for i in range(1, len(spectrum) - 1):\n            is_peak = spectrum[i] > spectrum[i-1] and spectrum[i] > spectrum[i+1]\n            if is_peak and spectrum[i] > threshold:\n                count += 1\n        return count\n\n    def classify_dynamics(Q):\n        \"\"\"\n        Runs the simulation and classifies the dynamics for a given Q.\n        Returns: 0 for periodic, 1 for quasiperiodic, 2 for chaotic.\n        \"\"\"\n        # --- Simulation Parameters ---\n        # Initial conditions\n        y0 = np.array([1.0, 0.0, 0.0], dtype=np.float64)\n        \n        # Time parameters\n        t_total = 200.0\n        dt = 2e-3\n        t_discard = 50.0\n        \n        # Classification thresholds\n        lambda_thr = 1e-3\n        f_peak = 0.15\n        \n        # Lyapunov exponent parameters\n        delta0 = 1e-6\n        k_norm = 20\n        tau = k_norm * dt\n        \n        num_steps = int(t_total / dt)\n        discard_steps = int(t_discard / dt)\n\n        # --- Simulation and Lyapunov Exponent Calculation ---\n        y = np.copy(y0)\n        y_pert = y + np.array([delta0, 0.0, 0.0], dtype=np.float64) # Perturb position\n        \n        x_history = np.zeros(num_steps, dtype=np.float64)\n        lyap_sum = 0.0\n\n        for i in range(num_steps):\n            x_history[i] = y[0]\n            \n            # Evolve both trajectories\n            y = rk4_step(y, Q, dt, dynamics)\n            y_pert = rk4_step(y_pert, Q, dt, dynamics)\n            \n            # Renormalization for Lyapunov exponent\n            if (i + 1) % k_norm == 0:\n                delta_vec = y_pert - y\n                dist = np.linalg.norm(delta_vec)\n                \n                if dist > 0:\n                    lyap_sum += np.log(dist / delta0)\n                    y_pert = y + delta_vec * (delta0 / dist) # Renormalize\n\n        # Finalize Lyapunov exponent calculation\n        num_renorms = num_steps // k_norm\n        lambda_max = lyap_sum / (num_renorms * tau)\n\n        # --- Classification Step 1: Check for Chaos ---\n        if lambda_max > lambda_thr:\n            return 2  # Chaotic\n\n        # --- Classification Step 2: Power Spectrum Analysis ---\n        x_steady_state = x_history[discard_steps:]\n        N_ss = len(x_steady_state)\n        \n        if N_ss < 3: # Not enough data points to find peaks\n            return 0 \n            \n        # Compute Power Spectrum using SciPy's FFT\n        yf = fft(x_steady_state)\n        # Power is magnitude squared; use first half (Nyquist)\n        power_spectrum = np.abs(yf[:N_ss//2])**2\n        \n        # Exclude DC component (zero-frequency)\n        power_spectrum_no_dc = power_spectrum[1:]\n        \n        if len(power_spectrum_no_dc) < 3: # Need at least 3 points for peak finding\n            return 0\n\n        max_power = np.max(power_spectrum_no_dc)\n        \n        if max_power == 0:\n            return 0 # Flat spectrum implies periodic (non-oscillatory)\n\n        # Count significant peaks\n        num_peaks = find_significant_peaks(power_spectrum_no_dc, max_power, f_peak)\n        \n        if num_peaks > 1:\n            return 1  # Quasiperiodic\n        else: # Covers num_peaks == 1 or num_peaks == 0\n            return 0  # Periodic\n\n    # Define the test suite from the problem statement.\n    test_cases = [0.05, 0.2, 1.0, 3.0, 10.0]\n\n    results = []\n    for q_val in test_cases:\n        result_code = classify_dynamics(q_val)\n        results.append(result_code)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "与确定性的 Nosé-Hoover 方法不同，Andersen 恒温器通过随机碰撞来确保遍历性，但这种鲁棒性是有代价的。本实践旨在量化 Andersen 碰撞对动态属性（如自扩散系数）测量所引入的系统性偏差。您将使用 Green-Kubo 关系从第一性原理出发推导这一效应，并开发一种实用算法来确定一个可将此偏差控制在微小范围内的操作区间 。",
            "id": "4110025",
            "problem": "考虑一个单组分 Lennard–Jones 流体的简单模型，使用所有量均为无量纲的约化 Lennard–Jones 单位。平衡自扩散系数由 Green–Kubo 关系定义，该关系将扩散系数表示为速度自相关函数的时间积分。Andersen 恒温器以指定的碰撞率在泊松分布的时间点上施加速度随机化。您的目标是量化碰撞率如何改变测得的自扩散系数，并设计一个操作方案，使得诱导的偏差可以忽略不计。\n\n出发点和假设：\n- 使用自扩散的 Green–Kubo 关系，该关系将扩散系数表示为平衡速度自相关函数 (VACF) 的时间积分。\n- 将 Andersen 恒温器碰撞建模为一个速率参数为 $\\nu$ 的泊松过程，该过程独立于粒子的位置和速度，并在碰撞时通过从目标温度下的 Maxwell–Boltzmann 分布中抽样来完全随机化粒子的速度。\n- 假设在没有恒温器碰撞的情况下，VACF 可以表示为衰减指数的有限和，\n$$\nC^{(0)}(t)=\\sum_{i=1}^{N} a_i \\exp\\!\\left(-\\frac{t}{\\tau_i}\\right),\n$$\n其中 $a_i>0$ 和 $\\tau_i>0$。这是简单流体中 VACF 的一种广泛使用的参数化表示。\n\n任务：\n1) 从自扩散系数的 Green–Kubo 定义和上述 Andersen 恒温器碰撞的随机描述出发，从第一性原理推导速率为 $\\nu$ 的碰撞的存在如何改变 VACF，从而改变测得的扩散系数 $D(\\nu)$。提供 $D(\\nu)$ 的小$\\nu$展开式至一阶，并定义相对偏差\n$$\nb(\\nu)=\\frac{D(\\nu)-D(0)}{D(0)}.\n$$\n2) 对于上述多指数 VACF 模型，设计一个算法，给定 $\\{a_i\\}_{i=1}^{N}$、$\\{\\tau_i\\}_{i=1}^{N}$、碰撞率 $\\nu$ 和容差 $\\varepsilon$（一个正常数），计算：\n- 相对偏差 $b(\\nu)$（以十进制数表示，而非百分比）。\n- 精确值 $\\nu_{\\max}$，使得对于所有 $\\nu\\in[0,\\nu_{\\max}]$，$\\lvert b(\\nu)\\rvert\\le \\varepsilon$ 成立，并且对于所有 $\\nu>\\nu_{\\max}$，$\\lvert b(\\nu)\\rvert> \\varepsilon$ 成立。\n- 从您的小$\\nu$展开式得到的一阶小$\\nu$近似值 $\\nu_{\\max}^{\\text{approx}}$。\n\n您的算法应仅依赖于从出发点和假设推导出的有数学依据的步骤，并且不得调用任何外部数据。所有报告的量在约化 Lennard–Jones 单位中必须是无量纲的。\n\n测试套件：\n实现您的算法，并在以下五个测试用例上进行评估。每个测试用例指定 $(\\{a_i\\},\\{\\tau_i\\},\\nu,\\varepsilon)$，所有数值均为无量纲：\n- 情况 A: $\\{a_i\\}=[1.0], \\{\\tau_i\\}=[0.5], \\nu=0.1, \\varepsilon=0.05$\n- 情况 B: $\\{a_i\\}=[0.8, 0.2], \\{\\tau_i\\}=[0.1, 1.0], \\nu=0.5, \\varepsilon=0.1$\n- 情况 C: $\\{a_i\\}=[0.6, 0.3, 0.1], \\{\\tau_i\\}=[0.02, 0.2, 2.0], \\nu=2.0, \\varepsilon=0.2$\n- 情况 D: $\\{a_i\\}=[1.0], \\{\\tau_i\\}=[0.5], \\nu=0.0001, \\varepsilon=0.001$\n- 情况 E: $\\{a_i\\}=[1.0], \\{\\tau_i\\}=[0.5], \\nu=10.0, \\varepsilon=0.5$\n\n最终输出格式：\n您的程序应生成一行输出，其中包含所有五个测试用例的结果，形式为方括号内以逗号分隔的列表。对于从 A 到 E 的每个测试用例，您必须按此确切顺序输出三个浮点数：$b(\\nu)$，然后是 $\\nu_{\\max}$，然后是 $\\nu_{\\max}^{\\text{approx}}$。因此，最终输出必须包含一个包含 $15$ 个浮点数的扁平列表：\n$$\n[b_A, \\nu_{\\max,A}, \\nu_{\\max,A}^{\\text{approx}}, b_B, \\nu_{\\max,B}, \\nu_{\\max,B}^{\\text{approx}}, \\dots, b_E, \\nu_{\\max,E}, \\nu_{\\max,E}^{\\text{approx}}].\n$$\n所有输出都是无量纲的，应以普通十进制数打印。不出现角度，也不需要其他物理单位。",
            "solution": "该问题是有效的，因为它在统计力学中有科学依据，是适定的、客观的且内部一致的。我们将进行完整的推导和求解。\n\n### 第 1 部分：扩散系数和相对偏差的推导\n\n自扩散系数 $D$ 由 Green-Kubo 关系给出，作为速度自相关函数 (VACF) $C(t)$ 的时间积分。假设进行一维处理或吸收维度前因子，我们有：\n$$\nD = \\int_0^\\infty C(t) \\, dt\n$$\n在没有恒温器碰撞的情况下，VACF 表示为 $C^{(0)}(t)$，相应的扩散系数为 $D(0)$。\n$$\nD(0) = \\int_0^\\infty C^{(0)}(t) \\, dt\n$$\nAndersen 恒温器引入了随机碰撞，使粒子的速度随机化。这些碰撞被建模为具有恒定速率 $\\nu$ 的泊松过程。一个粒子在时间 $t$ 的速度 $\\mathbf{v}(t)$ 仅当它在时间间隔 $[0, t]$ 内没有经历任何恒温器碰撞时，才与其初始速度 $\\mathbf{v}(0)$ 保持相关。如果发生碰撞，新速度将从 Maxwell-Boltzmann 分布中抽取，并且与碰撞前的速度完全不相关。\n\n令 $P(\\text{no collision in } [0, t])$ 为在持续时间为 $t$ 的时间间隔内没有发生碰撞的概率。对于速率为 $\\nu$ 的泊松过程，此生存概率由下式给出：\n$$\nP(\\text{no collision in } [0, t]) = e^{-\\nu t}\n$$\n存在恒温器时的 VACF，$C^{(\\nu)}(t)$，是未受扰动的 VACF，$C^{(0)}(t)$，乘以该生存概率，因为任何相关性在第一次碰撞时即被破坏：\n$$\nC^{(\\nu)}(t) = C^{(0)}(t) \\cdot P(\\text{no collision in } [0, t]) = C^{(0)}(t) e^{-\\nu t}\n$$\n问题陈述，未受扰动的 VACF 可建模为指数和：\n$$\nC^{(0)}(t) = \\sum_{i=1}^{N} a_i \\exp\\left(-\\frac{t}{\\tau_i}\\right)\n$$\n其中 $a_i > 0$ 和 $\\tau_i > 0$。\n\n将此代入 $C^{(\\nu)}(t)$ 的表达式中，我们得到：\n$$\nC^{(\\nu)}(t) = \\left( \\sum_{i=1}^{N} a_i e^{-t/\\tau_i} \\right) e^{-\\nu t} = \\sum_{i=1}^{N} a_i \\exp\\left(-t \\left(\\frac{1}{\\tau_i} + \\nu\\right)\\right)\n$$\n存在恒温器时的扩散系数 $D(\\nu)$ 是 $C^{(\\nu)}(t)$ 的积分：\n$$\nD(\\nu) = \\int_0^\\infty C^{(\\nu)}(t) \\, dt = \\int_0^\\infty \\sum_{i=1}^{N} a_i \\exp\\left(-t \\left(\\frac{1}{\\tau_i} + \\nu\\right)\\right) \\, dt\n$$\n交换积分和有限和，这里是允许的：\n$$\nD(\\nu) = \\sum_{i=1}^{N} a_i \\int_0^\\infty \\exp\\left(-t \\left(\\frac{1}{\\tau_i} + \\nu\\right)\\right) \\, dt\n$$\n该积分的计算结果为 $\\left(\\frac{1}{\\tau_i} + \\nu\\right)^{-1}$。因此：\n$$\nD(\\nu) = \\sum_{i=1}^{N} a_i \\frac{1}{\\frac{1}{\\tau_i} + \\nu} = \\sum_{i=1}^{N} \\frac{a_i \\tau_i}{1 + \\nu \\tau_i}\n$$\n未受扰动的扩散系数 $D(0)$ 通过设置 $\\nu=0$ 获得：\n$$\nD(0) = \\sum_{i=1}^{N} a_i \\tau_i\n$$\n相对偏差 $b(\\nu)$ 定义为：\n$$\nb(\\nu) = \\frac{D(\\nu) - D(0)}{D(0)} = \\frac{D(\\nu)}{D(0)} - 1\n$$\n代入我们对 $D(\\nu)$ 和 $D(0)$ 的表达式：\n$$\nb(\\nu) = \\frac{\\sum_{i=1}^{N} \\frac{a_i \\tau_i}{1 + \\nu \\tau_i}}{\\sum_{j=1}^{N} a_j \\tau_j} - 1\n$$\n这是相对偏差的精确表达式。由于 $a_i > 0$，$\\tau_i > 0$，且 $\\nu > 0$，很明显 $D(\\nu) < D(0)$，这意味着对于 $\\nu > 0$，$b(\\nu) < 0$。\n\n### 第 2 部分：小$\\nu$展开\n\n为了找到小 $\\nu$ 的一阶近似，我们对 $D(\\nu)$ 在 $\\nu=0$ 附近进行泰勒展开。我们使用展开式 $\\frac{1}{1+x} = 1 - x + O(x^2)$ 处理小 $x$。这里，$x=\\nu\\tau_i$。\n$$\n\\frac{a_i \\tau_i}{1+\\nu\\tau_i} = a_i\\tau_i (1 - \\nu\\tau_i + O(\\nu^2)) = a_i\\tau_i - \\nu a_i\\tau_i^2 + O(\\nu^2)\n$$\n对 $i$ 求和：\n$$\nD(\\nu) = \\sum_{i=1}^{N} (a_i\\tau_i - \\nu a_i\\tau_i^2) + O(\\nu^2) = \\left(\\sum_{i=1}^{N} a_i\\tau_i\\right) - \\nu \\left(\\sum_{i=1}^{N} a_i\\tau_i^2\\right) + O(\\nu^2)\n$$\n将第一项识别为 $D(0)$，我们有：\n$$\nD(\\nu) \\approx D(0) - \\nu \\sum_{i=1}^{N} a_i\\tau_i^2\n$$\n那么相对偏差的一阶近似为：\n$$\nb(\\nu) \\approx \\frac{(D(0) - \\nu \\sum_{i=1}^{N} a_i\\tau_i^2) - D(0)}{D(0)} = -\\nu \\frac{\\sum_{i=1}^{N} a_i\\tau_i^2}{\\sum_{j=1}^{N} a_j\\tau_j}\n$$\n\n### 第 3 部分：算法设计\n\n给定参数 $\\{a_i\\}_{i=1}^{N}$、$\\{\\tau_i\\}_{i=1}^{N}$、$\\nu$ 和 $\\varepsilon$，我们需要计算三个量。\n\n**1. 相对偏差 $b(\\nu)$：**\n这可以直接使用上面推导的精确公式计算：\n$$\nb(\\nu) = \\frac{\\sum_{i=1}^{N} a_i \\tau_i / (1 + \\nu \\tau_i)}{\\sum_{j=1}^{N} a_j \\tau_j} - 1\n$$\n\n**2. 近似最大碰撞率 $\\nu_{\\max}^{\\text{approx}}$：**\n我们使用偏差的一阶近似 $b_{\\text{approx}}(\\nu)$。条件是 $|b(\\nu)| \\le \\varepsilon$。由于 $b(\\nu) \\le 0$，这等价于 $b(\\nu) \\ge -\\varepsilon$。在线性近似中，这在边界处变为等式：$b_{\\text{approx}}(\\nu_{\\max}^{\\text{approx}}) = -\\varepsilon$。\n$$\n-\\nu_{\\max}^{\\text{approx}} \\frac{\\sum a_i\\tau_i^2}{\\sum a_j\\tau_j} = -\\varepsilon\n$$\n解出 $\\nu_{\\max}^{\\text{approx}}$ 得：\n$$\n\\nu_{\\max}^{\\text{approx}} = \\varepsilon \\frac{\\sum_{j=1}^{N} a_j\\tau_j}{\\sum_{i=1}^{N} a_i\\tau_i^2}\n$$\n\n**3. 精确最大碰撞率 $\\nu_{\\max}$：**\n我们需要为 $\\nu_{\\max}$ 解方程 $|b(\\nu_{\\max})| = \\varepsilon$。由于 $b(\\nu)$ 对于 $\\nu \\ge 0$ 是单调递减的（其导数为 $\\frac{d b}{d\\nu} = \\frac{1}{D(0)}\\sum_i \\frac{-a_i\\tau_i^2}{(1+\\nu\\tau_i)^2} < 0$），对于给定的 $\\varepsilon \\in (0, 1)$，存在一个唯一的 $\\nu_{\\max} > 0$ 满足 $b(\\nu_{\\max}) = -\\varepsilon$。这个方程是：\n$$\n\\frac{\\sum_{i=1}^{N} \\frac{a_i \\tau_i}{1 + \\nu_{\\max} \\tau_i}}{\\sum_{j=1}^{N} a_j \\tau_j} - 1 = -\\varepsilon\n$$\n$$\n\\sum_{i=1}^{N} \\frac{a_i \\tau_i}{1 + \\nu_{\\max} \\tau_i} = (1 - \\varepsilon) \\sum_{j=1}^{N} a_j \\tau_j\n$$\n这是一个关于 $\\nu_{\\max}$ 的非线性方程。我们可以定义一个函数 $g(\\nu')$ 并找到它的根：\n$$\ng(\\nu') = \\left(\\sum_{i=1}^{N} \\frac{a_i \\tau_i}{1 + \\nu' \\tau_i}\\right) - (1 - \\varepsilon) D(0) = 0\n$$\n由于 $g(\\nu')$ 是单调的，我们可以使用像 Newton-Raphson 这样的数值方法可靠地找到唯一的根。更新规则是 $\\nu'_{k+1} = \\nu'_k - g(\\nu'_k)/g'(\\nu'_k)$，其中导数 $g'(\\nu')$ 是：\n$$\ng'(\\nu') = \\frac{d}{d\\nu'} \\sum_{i=1}^{N} \\frac{a_i \\tau_i}{1 + \\nu' \\tau_i} = -\\sum_{i=1}^{N} \\frac{a_i \\tau_i^2}{(1 + \\nu' \\tau_i)^2}\n$$\n一个合适的迭代初始猜测是一阶近似值 $\\nu'_0 = \\nu_{\\max}^{\\text{approx}}$。持续迭代直到收敛到所需精度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    # Test cases as specified in the problem statement.\n    # Each case is a tuple: (a_i, tau_i, nu, epsilon)\n    test_cases = [\n        # Case A\n        (np.array([1.0]), np.array([0.5]), 0.1, 0.05),\n        # Case B\n        (np.array([0.8, 0.2]), np.array([0.1, 1.0]), 0.5, 0.1),\n        # Case C\n        (np.array([0.6, 0.3, 0.1]), np.array([0.02, 0.2, 2.0]), 2.0, 0.2),\n        # Case D\n        (np.array([1.0]), np.array([0.5]), 0.0001, 0.001),\n        # Case E\n        (np.array([1.0]), np.array([0.5]), 10.0, 0.5),\n    ]\n\n    results = []\n    for params in test_cases:\n        a_i, tau_i, nu, epsilon = params\n        \n        # 1. Calculate the relative bias b(nu)\n        \n        # D(0) is the sum of a_i * tau_i\n        D0 = np.sum(a_i * tau_i)\n        \n        # D(nu) is the sum of a_i * tau_i / (1 + nu * tau_i)\n        D_nu = np.sum(a_i * tau_i / (1.0 + nu * tau_i))\n        \n        # Relative bias b(nu)\n        b_nu = D_nu / D0 - 1.0\n        \n        # 2. Calculate the first-order approximation nu_max_approx\n        \n        # Calculate the moments required for the approximation\n        M1 = D0  # sum(a_i * tau_i)\n        M2 = np.sum(a_i * tau_i**2) # sum(a_i * tau_i^2)\n        \n        if M2 == 0:\n            # This case should not happen given tau_i > 0 and a_i > 0\n            nu_max_approx = float('inf')\n        else:\n            nu_max_approx = epsilon * M1 / M2\n            \n        # 3. Calculate the exact value nu_max using Newton's method\n        \n        # Define the function g(v) whose root is nu_max\n        # g(v) = D(v) - (1 - epsilon) * D(0) = 0\n        target = (1.0 - epsilon) * D0\n        \n        def g(v, a, tau, t):\n            return np.sum(a * tau / (1.0 + v * tau)) - t\n\n        def g_prime(v, a, tau):\n            return -np.sum(a * tau**2 / (1.0 + v * tau)**2)\n\n        # Initial guess for Newton's method\n        v_k = nu_max_approx\n        \n        # Iterate Newton's method to find the root\n        max_iter = 100\n        tolerance = 1e-15\n        for _ in range(max_iter):\n            g_val = g(v_k, a_i, tau_i, target)\n            gp_val = g_prime(v_k, a_i, tau_i)\n            \n            if abs(gp_val) < 1e-20:  # Avoid division by zero\n                break\n                \n            step = g_val / gp_val\n            v_k = v_k - step\n            \n            if abs(step) < tolerance:\n                break\n        \n        nu_max = v_k\n        \n        # Store the results for the current test case\n        results.extend([b_nu, nu_max, nu_max_approx])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}