{
    "hands_on_practices": [
        {
            "introduction": "Before delving into the complexities of self-avoiding walks, it is essential to master the foundational model of an ideal polymer chain. This exercise  guides you through the first-principles derivation of the mean-square end-to-end distance, $\\langle R^2 \\rangle$, for a freely-jointed chain. By performing this fundamental calculation, you will see precisely how the statistical independence of bond vectors leads to the classic random-walk scaling, providing a critical baseline for understanding the impact of excluded volume.",
            "id": "4101369",
            "problem": "A polymer in a theta solvent can be modeled as an ideal freely jointed chain with $N$ statistically independent bond vectors $\\{\\mathbf{b}_{i}\\}_{i=1}^{N}$, each of fixed length $b$ and isotropically oriented. The end-to-end vector is $\\mathbf{R}=\\sum_{i=1}^{N}\\mathbf{b}_{i}$. Assume that the bond vectors are independent and identically distributed with $\\langle \\mathbf{b}_{i} \\rangle=\\mathbf{0}$ and that the distribution is isotropic in space.\n\nStarting only from these assumptions and from basic properties of ensemble averages, compute the exact ensemble-averaged mean-square end-to-end distance $\\langle R^{2} \\rangle$ as a function of $N$ and $b$. Then, justify how the independence and isotropy of bond vectors determine the scaling of $\\langle R^{2} \\rangle$ with respect to $N$ and $b$ in this ideal-chain limit, in contrast to a real chain with excluded volume (self-avoiding walk).\n\nExpress your final answer as a single closed-form symbolic expression in terms of $N$ and $b$. Do not include units in the final boxed answer.",
            "solution": "The problem statement is scientifically sound, well-posed, and contains all necessary information to derive a unique solution. It describes the freely jointed chain model, a cornerstone of polymer statistical mechanics, and asks for the derivation of a fundamental result. Therefore, a solution will be provided.\n\nThe primary quantity of interest is the mean-square end-to-end distance, $\\langle R^{2} \\rangle$. The end-to-end vector, $\\mathbf{R}$, is defined as the sum of the individual bond vectors, $\\{\\mathbf{b}_{i}\\}_{i=1}^{N}$:\n$$\n\\mathbf{R} = \\sum_{i=1}^{N} \\mathbf{b}_{i}\n$$\nThe squared end-to-end distance, $R^{2}$, is the scalar product of the vector $\\mathbf{R}$ with itself:\n$$\nR^{2} = \\mathbf{R} \\cdot \\mathbf{R} = \\left(\\sum_{i=1}^{N} \\mathbf{b}_{i}\\right) \\cdot \\left(\\sum_{j=1}^{N} \\mathbf{b}_{j}\\right)\n$$\nExpanding this product yields a double summation:\n$$\nR^{2} = \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\mathbf{b}_{i} \\cdot \\mathbf{b}_{j}\n$$\nWe are asked to compute the ensemble average of this quantity, $\\langle R^{2} \\rangle$. The ensemble average operator, $\\langle \\cdot \\rangle$, is linear. Therefore, we can move the operator inside the summations:\n$$\n\\langle R^{2} \\rangle = \\left\\langle \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\mathbf{b}_{i} \\cdot \\mathbf{b}_{j} \\right\\rangle = \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\langle \\mathbf{b}_{i} \\cdot \\mathbf{b}_{j} \\rangle\n$$\nTo evaluate this double summation, it is instructive to separate the terms where the indices are equal ($i=j$) from the terms where they are different ($i \\neq j$):\n$$\n\\langle R^{2} \\rangle = \\sum_{i=1}^{N} \\langle \\mathbf{b}_{i} \\cdot \\mathbf{b}_{i} \\rangle + \\sum_{i=1}^{N} \\sum_{j \\neq i}^{N} \\langle \\mathbf{b}_{i} \\cdot \\mathbf{b}_{j} \\rangle\n$$\nLet us analyze each of these two sums separately.\n\nFor the first sum, the term $\\mathbf{b}_{i} \\cdot \\mathbf{b}_{i}$ is the squared magnitude of the $i$-th bond vector, $|\\mathbf{b}_{i}|^{2}$. The problem statement specifies that each bond has a fixed length $b$. Thus, for any bond $i$, $|\\mathbf{b}_{i}| = b$, which implies $|\\mathbf{b}_{i}|^{2} = b^{2}$. Since $b^{2}$ is a constant, its ensemble average is simply the constant itself:\n$$\n\\langle \\mathbf{b}_{i} \\cdot \\mathbf{b}_{i} \\rangle = \\langle |\\mathbf{b}_{i}|^{2} \\rangle = \\langle b^{2} \\rangle = b^{2}\n$$\nThe first sum, which contains $N$ such identical terms, becomes:\n$$\n\\sum_{i=1}^{N} \\langle \\mathbf{b}_{i} \\cdot \\mathbf{b}_{i} \\rangle = \\sum_{i=1}^{N} b^{2} = N b^{2}\n$$\n\nFor the second sum, we consider the terms where $i \\neq j$. The problem states that the bond vectors are statistically independent. For two independent random variables (in this case, vectors $\\mathbf{b}_{i}$ and $\\mathbf{b}_{j}$), the expectation of their product is the product of their expectations. Although the dot product is not a simple product of scalars, we can leverage the independence. For $i \\neq j$, the vectors $\\mathbf{b}_{i}$ and $\\mathbf{b}_{j}$ are uncorrelated. A key property derived from statistical independence is that the average of the product is the product of the averages. Thus:\n$$\n\\langle \\mathbf{b}_{i} \\cdot \\mathbf{b}_{j} \\rangle = \\langle \\mathbf{b}_{i} \\rangle \\cdot \\langle \\mathbf{b}_{j} \\rangle \\quad \\text{for } i \\neq j\n$$\nThe problem provides that the mean of any bond vector is zero, $\\langle \\mathbf{b}_{i} \\rangle = \\mathbf{0}$ for all $i$. This is a direct consequence of the stated isotropic orientation of the bonds; there is no preferred direction in space. Substituting this into the expression for the cross-terms gives:\n$$\n\\langle \\mathbf{b}_{i} \\cdot \\mathbf{b}_{j} \\rangle = \\mathbf{0} \\cdot \\mathbf{0} = 0\n$$\nSince every term in the second sum over $i \\neq j$ is zero, the entire sum vanishes:\n$$\n\\sum_{i=1}^{N} \\sum_{j \\neq i}^{N} \\langle \\mathbf{b}_{i} \\cdot \\mathbf{b}_{j} \\rangle = 0\n$$\nCombining the results for both sums, we arrive at the exact expression for the mean-square end-to-end distance:\n$$\n\\langle R^{2} \\rangle = N b^{2} + 0 = N b^{2}\n$$\n\nThe justification for the scaling of $\\langle R^{2} \\rangle$ with respect to $N$ and $b$ is embedded in this derivation. The linear scaling with the number of segments, $\\langle R^{2} \\rangle \\propto N$, is a hallmark of a random walk process. It arises directly from the statistical independence of the bond vectors, which causes all the orientational cross-correlations $\\langle \\mathbf{b}_{i} \\cdot \\mathbf{b}_{j} \\rangle$ for $i \\neq j$ to vanish. The isotropy assumption guarantees $\\langle\\mathbf{b}_{i}\\rangle = \\mathbf{0}$, which is essential for this cancellation. The scaling with $b^{2}$ simply reflects that the fundamental step length of this random walk is $b$.\n\nIn contrast, a real polymer chain cannot be modeled as a simple random walk. The primary physical constraint not present in the ideal chain model is the excluded volume effect: two parts of the chain cannot occupy the same location in space. This constraint introduces long-range correlations between segments that are far apart along the chain contour but may be close in space. The chain trajectory becomes a self-avoiding walk (SAW) rather than a simple random walk. Consequently, the assumption of statistical independence for $\\mathbf{b}_{i}$ and $\\mathbf{b}_{j}$ breaks down, and $\\langle \\mathbf{b}_{i} \\cdot \\mathbf{b}_{j} \\rangle \\neq 0$ even for large $|i-j|$. These correlations are, on average, positive (the chain tends to swell to avoid itself), leading to a more expanded conformation than an ideal chain. For a self-avoiding walk in $d=3$ dimensions, Flory theory and more refined renormalization group calculations predict a different scaling law:\n$$\n\\langle R^{2} \\rangle \\sim N^{2\\nu}\n$$\nwhere $\\nu$ is the Flory exponent. For $d=3$, $\\nu \\approx 0.588$, which is significantly larger than the ideal chain exponent $\\nu = 1/2$ (since $\\langle R^{2} \\rangle = N b^{2} = N^{2(1/2)} b^{2}$). This indicates that a real chain in a good solvent swells to a much larger size than an ideal chain of the same length $N$. The ideal chain model corresponds to the special case of a theta solvent, where attractive monomer-solvent interactions exactly balance the repulsive excluded volume effect, causing the chain to effectively behave as a random walk.",
            "answer": "$$\n\\boxed{N b^{2}}\n$$"
        },
        {
            "introduction": "Real polymer chains, unlike ideal ones, cannot pass through themselves. This \"excluded volume\" effect dramatically alters their conformation, and Flory theory provides a beautifully simple yet powerful mean-field argument to account for this reality. In this practice , you will apply this theory by balancing the chain's entropic elasticity against a repulsive interaction energy to derive the famous Flory exponent, $\\nu$, which captures how a real chain swells in a good solvent.",
            "id": "4101378",
            "problem": "Consider a long polymer modeled as a self-avoiding walk in a good solvent in spatial dimension $d$. The polymer has $N$ Kuhn segments of length $a$, and a positive two-body excluded volume parameter $v$ with $v = c_{v}\\,a^{d}$, where $c_{v}$ is a dimensionless constant of order unity. In Floryâ€™s mean-field approach, the Helmholtz free energy (in units of $k_{B}T$) of a conformation with end-to-end distance $R$ is estimated as the sum of an entropic elasticity term and a mean-field interaction term. Use the following base assumptions, which are standard and well-tested in the theory of real polymer chains:\n- The entropic elasticity of a Gaussian chain contributes $F_{\\mathrm{el}}/(k_{B}T) \\sim c_{1}\\,R^{2}/(a^{2}N)$, where $c_{1}$ is an order-one constant.\n- The repulsive two-body interactions at the level of the second virial approximation contribute $F_{\\mathrm{int}}/(k_{B}T) \\sim c_{2}\\,v\\,N^{2}/R^{d}$, where $c_{2}$ is an order-one constant.\n\nStarting from these ingredients, do the following:\n1. Minimize the total free energy with respect to $R$ to obtain the scaling form of the mean-square end-to-end distance $\\langle R^{2} \\rangle$ as a function of $N$, $a$, $d$, and $v$, retaining the dependence on $c_{1}$ and $c_{2}$.\n2. Define the Flory exponent $\\nu_{F}$ through $\\langle R^{2} \\rangle \\sim a^{2}N^{2\\nu_{F}}$ and extract the dimensionless amplitude $C_{F}(d,c_{1},c_{2},c_{v})$ defined by\n$$\n\\langle R^{2} \\rangle \\equiv C_{F}(d,c_{1},c_{2},c_{v})\\,a^{2}\\,N^{2\\nu_{F}}.\n$$\n3. Specialize to three dimensions with $d=3$ and take $c_{1}=1$, $c_{2}=1$, and $c_{v}=1$. Compute the resulting dimensionless prefactor $C_{F}(3,1,1,1)$ as an exact expression. Your final answer must be this single value. Do not round.\n4. Briefly comment, in words, on the limitations of this prefactor and exponent relative to results from the renormalization group (RG).\n\nYour final answer must be a single exact real number. No units are required in the final answer because it is dimensionless. Do not provide any inequalities or equations as your final answer.",
            "solution": "The problem statement is first subjected to validation.\n\n**Step 1: Extract Givens**\n- Polymer model: a self-avoiding walk in a good solvent.\n- Spatial dimension: $d$.\n- Number of segments: $N$.\n- Segment length: $a$.\n- Two-body excluded volume parameter: $v  0$.\n- Relation for excluded volume: $v = c_{v}\\,a^{d}$, where $c_{v}$ is a dimensionless constant of order unity.\n- Entropic elasticity free energy: $F_{\\mathrm{el}}/(k_{B}T) \\sim c_{1}\\,R^{2}/(a^{2}N)$, with $c_{1}$ as an order-one constant.\n- Mean-field interaction free energy: $F_{\\mathrm{int}}/(k_{B}T) \\sim c_{2}\\,v\\,N^{2}/R^{d}$, with $c_{2}$ as an order-one constant.\n- Total free energy: $F = F_{\\mathrm{el}} + F_{\\mathrm{int}}$.\n- Definition of Flory exponent $\\nu_{F}$: $\\langle R^{2} \\rangle \\sim a^{2}N^{2\\nu_{F}}$.\n- Definition of dimensionless amplitude: $\\langle R^{2} \\rangle \\equiv C_{F}(d,c_{1},c_{2},c_{v})\\,a^{2}\\,N^{2\\nu_{F}}$.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded:** The problem is a classic and fundamental exercise in theoretical polymer physics, based on the well-established Flory mean-field theory. All concepts and equations are standard in the field.\n- **Well-Posed:** The problem is clearly structured with a sequence of tasks that lead to a unique solution based on the provided assumptions.\n- **Objective:** The language is formal and precise, free of any subjective or ambiguous terms.\n- **Completeness and Consistency:** All necessary information is provided. The use of proportionality `~` is clarified by the instruction to retain the constants $c_{1}$ and $c_{2}$, effectively treating the relations as equalities for the purpose of the calculation. The givens are mutually consistent.\n- **Other Flaws:** The problem is free from the other listed flaws such as being unrealistic, ill-posed, or trivial.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A solution will be provided.\n\nThe total Helmholtz free energy $F$ of a polymer conformation with end-to-end distance $R$, in units of $k_{B}T$, is the sum of the entropic elasticity term and the interaction term. Denoting $f(R) = F/(k_{B}T)$, we have:\n$$\nf(R) = \\frac{F_{\\mathrm{el}}}{k_{B}T} + \\frac{F_{\\mathrm{int}}}{k_{B}T} = c_{1}\\frac{R^{2}}{a^{2}N} + c_{2}\\frac{v N^{2}}{R^{d}}\n$$\nwhere the use of equality is justified by the instruction to retain the constants $c_{1}$ and $c_{2}$.\n\n**1. Minimization of the Free Energy**\nTo find the equilibrium end-to-end distance, which we denote as $R_{F}$, we minimize the free energy $f(R)$ with respect to $R$. This is done by finding the derivative of $f(R)$ with respect to $R$ and setting it to zero.\n$$\n\\frac{df}{dR} = \\frac{d}{dR} \\left( c_{1}R^{2}(a^{2}N)^{-1} + c_{2}vN^{2}R^{-d} \\right) = 2c_{1}R(a^{2}N)^{-1} - dc_{2}vN^{2}R^{-d-1}\n$$\nSetting the derivative to zero to find the minimum:\n$$\n\\frac{2c_{1}R_{F}}{a^{2}N} - \\frac{dc_{2}vN^{2}}{R_{F}^{d+1}} = 0\n$$\n$$\n\\frac{2c_{1}R_{F}}{a^{2}N} = \\frac{dc_{2}vN^{2}}{R_{F}^{d+1}}\n$$\nWe solve for $R_{F}$:\n$$\nR_{F}^{d+2} = \\frac{dc_{2}vN^{2}a^{2}N}{2c_{1}} = \\left( \\frac{dc_{2}v}{2c_{1}} \\right) a^{2}N^{3}\n$$\nTo confirm this is a minimum, we check the second derivative:\n$$\n\\frac{d^{2}f}{dR^{2}} = \\frac{2c_{1}}{a^{2}N} + d(d+1)c_{2}vN^{2}R^{-d-2}\n$$\nSince all parameters ($c_{1}$, $c_{2}$, $v$, $N$, $a$, $d$) are positive, $\\frac{d^{2}f}{dR^{2}}  0$ for all $R0$, confirming that $R_{F}$ corresponds to a minimum of the free energy.\n\nThe mean-square end-to-end distance $\\langle R^{2} \\rangle$ is identified with $R_{F}^{2}$ in this mean-field approximation.\n$$\n\\langle R^{2} \\rangle = R_{F}^{2} = \\left[ \\left( \\frac{dc_{2}v}{2c_{1}} \\right) a^{2}N^{3} \\right]^{\\frac{2}{d+2}} = \\left( \\frac{dc_{2}v}{2c_{1}} \\right)^{\\frac{2}{d+2}} a^{\\frac{4}{d+2}} N^{\\frac{6}{d+2}}\n$$\nThis is the scaling form of $\\langle R^{2} \\rangle$.\n\n**2. Flory Exponent and Amplitude**\nWe are given the definition $\\langle R^{2} \\rangle \\sim a^{2}N^{2\\nu_{F}}$. Comparing this with our derived scaling for $N$, $\\langle R^{2} \\rangle \\propto N^{\\frac{6}{d+2}}$, we identify:\n$$\n2\\nu_{F} = \\frac{6}{d+2} \\implies \\nu_{F} = \\frac{3}{d+2}\n$$\nThis is the celebrated Flory exponent.\n\nTo find the dimensionless amplitude $C_{F}$, we use the definition $\\langle R^{2} \\rangle \\equiv C_{F}(d,c_{1},c_{2},c_{v})\\,a^{2}\\,N^{2\\nu_{F}}$. We first substitute $v = c_{v}a^{d}$ into our expression for $\\langle R^{2} \\rangle$:\n$$\n\\langle R^{2} \\rangle = \\left( \\frac{dc_{2}(c_{v}a^{d})}{2c_{1}} \\right)^{\\frac{2}{d+2}} a^{\\frac{4}{d+2}} N^{\\frac{6}{d+2}}\n$$\n$$\n\\langle R^{2} \\rangle = \\left( \\frac{dc_{2}c_{v}}{2c_{1}} \\right)^{\\frac{2}{d+2}} (a^{d})^{\\frac{2}{d+2}} a^{\\frac{4}{d+2}} N^{\\frac{6}{d+2}}\n$$\n$$\n\\langle R^{2} \\rangle = \\left( \\frac{dc_{2}c_{v}}{2c_{1}} \\right)^{\\frac{2}{d+2}} a^{\\frac{2d}{d+2}} a^{\\frac{4}{d+2}} N^{\\frac{6}{d+2}}\n$$\n$$\n\\langle R^{2} \\rangle = \\left( \\frac{dc_{2}c_{v}}{2c_{1}} \\right)^{\\frac{2}{d+2}} a^{\\frac{2d+4}{d+2}} N^{\\frac{6}{d+2}} = \\left( \\frac{dc_{2}c_{v}}{2c_{1}} \\right)^{\\frac{2}{d+2}} a^{2} N^{\\frac{6}{d+2}}\n$$\nComparing this result with the definition $\\langle R^{2} \\rangle \\equiv C_{F}\\,a^{2}\\,N^{2\\nu_{F}}$ and noting that $2\\nu_{F} = 6/(d+2)$, we can directly identify the amplitude $C_{F}$:\n$$\nC_{F}(d,c_{1},c_{2},c_{v}) = \\left( \\frac{dc_{2}c_{v}}{2c_{1}} \\right)^{\\frac{2}{d+2}}\n$$\n\n**3. Specific Value for $C_{F}$**\nWe specialize to three dimensions ($d=3$) and set the order-one constants to unity: $c_{1}=1$, $c_{2}=1$, and $c_{v}=1$.\n$$\nC_{F}(3,1,1,1) = \\left( \\frac{(3)(1)(1)}{2(1)} \\right)^{\\frac{2}{3+2}} = \\left( \\frac{3}{2} \\right)^{\\frac{2}{5}}\n$$\nThis is the requested exact value.\n\n**4. Commentary on Limitations**\nThe Flory theory provides a powerful yet simple physical argument. However, it is a mean-field theory and has known limitations when compared to more rigorous approaches like the renormalization group (RG) and high-precision computer simulations.\n- **Exponent $\\nu_{F}$**: For $d=3$, the Flory exponent is $\\nu_{F} = 3/(3+2) = 3/5 = 0.6$. This is remarkably close to the best-known value from RG and simulations, which is $\\nu \\approx 0.588$. While an excellent approximation, the Flory exponent is not exact for $d=3$. The discrepancy arises because the mean-field treatment of interactions and the Gaussian approximation for the chain's entropy are not fully consistent and neglect subtle spatial correlations.\n- **Prefactor $C_{F}$**: The numerical value of the prefactor $C_{F}$ is highly dependent on the non-universal, order-one constants $c_{1}$, $c_{2}$, and $c_{v}$. These constants absorb all the microscopic details of the polymer and solvent that are not captured by the scaling variables $N$ and $v$. RG theory establishes that while exponents like $\\nu$ are universal (independent of microscopic details), amplitudes are generally not. Thus, the calculated value of $C_{F}(3,1,1,1)$ should be viewed as a model-dependent estimate rather than a fundamental physical constant. RG can predict universal ratios of amplitudes, but not their absolute values.",
            "answer": "$$\\boxed{\\left(\\frac{3}{2}\\right)^{\\frac{2}{5}}}$$"
        },
        {
            "introduction": "While analytical models like Flory theory offer profound insights, many properties of self-avoiding walks (SAWs) are not exactly solvable and require computational investigation. This exercise  takes you directly to the heart of the problem from a computational standpoint. You will implement a backtracking algorithm to perform an exact enumeration of SAWs on a square lattice, giving you a concrete understanding of the combinatorial challenge and allowing you to observe the asymptotic behavior of key quantities like the connective constant from finite-size data.",
            "id": "4101356",
            "problem": "A self-avoiding walk (SAW) on the integer square lattice $\\mathbb{Z}^2$ is a nearest-neighbor path that does not visit any lattice site more than once. In computational complex fluids, real polymer chains in a good solvent can be modeled by SAWs to capture excluded volume effects. Consider the set of SAWs of length $N$ steps starting from the origin $(0,0)$, where each step moves by one unit in one of the four cardinal directions. Let $c_N$ denote the total number of such SAWs of length $N$.\n\nStarting only from the fundamental definition of a self-avoiding walk as a path with distinct visited sites, and the well-tested fact of submultiplicativity for counts under concatenation of path segments (that is, $c_{M+N} \\le c_M c_N$ due to the impossibility of arbitrary concatenations to remain self-avoiding), construct an algorithm that enumerates all SAWs of length $N$ with $N \\le 6$ on the square lattice.\n\nYour task is to:\n- Derive from first principles an enumeration strategy that systematically generates all SAWs of length $N$ by exploring the complete search tree of nearest-neighbor steps while enforcing self-avoidance, and use it to compute $c_N$ for $N \\in \\{0,1,2,3,4,5,6\\}$.\n- Use the enumerated counts to characterize the growth pattern by computing, for each $N \\ge 1$, the ratio $r_N = c_N / c_{N-1}$ and the root estimator $g_N = c_N^{1/N}$, which are classical finite-$N$ estimators of the connective constant $\\mu$.\n- Verify the submultiplicativity inequality $c_{M+N} \\le c_M c_N$ for the test pairs $(M,N) \\in \\{(1,1),(2,2),(3,3)\\}$, returning a boolean for each check.\n\nNo physical units are involved since $c_N$, $r_N$, and $g_N$ are dimensionless quantities. Angles are not part of this computation. All outputs must be numerical and quantifiable.\n\nTest suite:\n- Enumeration cases: $N \\in \\{0,1,2,3,4,5,6\\}$.\n- Submultiplicativity checks: $(M,N) \\in \\{(1,1),(2,2),(3,3)\\}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with no spaces, in the following order:\n  1. The seven integers $c_0,c_1,c_2,c_3,c_4,c_5,c_6$.\n  2. The six floats $r_1,r_2,r_3,r_4,r_5,r_6$, each rounded to six decimal places.\n  3. The six floats $g_1,g_2,g_3,g_4,g_5,g_6$, each rounded to six decimal places.\n  4. The three booleans for the submultiplicativity checks corresponding to $(M,N)=(1,1),(2,2),(3,3)$, in that order.\n\nFor clarity, the required output will therefore contain 22 entries in a single flat list. For example, the output must have the exact form $[c_0,c_1,\\dots,c_6,r_1,\\dots,r_6,g_1,\\dots,g_6,b_{11},b_{22},b_{33}]$, where $b_{11},b_{22},b_{33}$ are the booleans for the three inequality checks.",
            "solution": "The problem statement has been validated and is deemed **valid**. It is scientifically grounded in the established theory of self-avoiding walks, a cornerstone of statistical mechanics models for polymers. The problem is well-posed, with clear, objective definitions and a computable, unique solution. All necessary conditions are provided, and there are no contradictions.\n\nThe solution is developed in three parts as requested: enumeration of walk counts, analysis of their growth pattern, and verification of a fundamental mathematical property.\n\n### Part 1: Enumeration of Self-Avoiding Walks ($c_N$)\n\nA self-avoiding walk (SAW) of length $N$ on the square lattice $\\mathbb{Z}^2$ is a sequence of distinct vertices $(p_0, p_1, \\dots, p_N)$ where $p_0 = (0,0)$ and each subsequent vertex $p_{i+1}$ is a nearest neighbor of its predecessor $p_i$. The number of such walks is denoted by $c_N$.\n\nTo compute $c_N$ from first principles, we develop a systematic enumeration strategy based on recursive backtracking. This algorithm explores the tree of all possible nearest-neighbor paths starting from the origin, pruning any branch that attempts to revisit a site.\n\nThe algorithm can be formulated as a recursive function, let's call it `CountWalks(current_pos, visited_sites, steps_remaining)`.\n- **State Representation**: The state of the search at any point is defined by three elements:\n    1. `current_pos`: The current coordinates $(x,y)$ of the endpoint of the walk.\n    2. `visited_sites`: A set data structure containing all unique vertices visited so far, including the starting point. Using a set allows for efficient (average $O(1)$ time) checking of the self-avoiding constraint.\n    3. `steps_remaining`: The number of steps yet to be taken to reach the total length $N$.\n\n- **Recursive Logic**:\n    - **Base Case**: If `steps_remaining` is $0$, it signifies that a valid SAW of length $N$ has been constructed. The function returns $1$ to count this single successful path.\n    - **Recursive Step**: If `steps_remaining` is greater than $0$, the function iterates through the four cardinal neighbors of `current_pos`. For each potential `next_pos`:\n        1. It checks if `next_pos` is already in the `visited_sites` set.\n        2. If it is not, the path is valid so far. The algorithm then:\n            a. Adds `next_pos` to `visited_sites`.\n            b. Makes a recursive call: `CountWalks(next_pos, visited_sites, steps_remaining - 1)`.\n            c. Adds the integer returned by this recursive call to a running total for the current level.\n            d. **Backtracks** by removing `next_pos` from `visited_sites`. This is a critical step that allows the search to explore other branches from `current_pos`.\n    - The function returns the accumulated total count from all valid recursive branches.\n\n- **Initial Call**: To compute $c_N$, the initial call to the function is `CountWalks(current_pos=(0,0), visited_sites={(0,0)}, steps_remaining=N)`. The count for $N=0$ is $c_0=1$ by definition, representing a walk of zero steps that remains at the origin.\n\nExecuting this algorithm for $N \\in \\{0, 1, 2, 3, 4, 5, 6\\}$ yields the following counts:\n- $c_0 = 1$\n- $c_1 = 4$\n- $c_2 = 12$\n- $c_3 = 36$\n- $c_4 = 100$\n- $c_5 = 284$\n- $c_6 = 780$\n\n### Part 2: Growth Pattern Characterization ($r_N$ and $g_N$)\n\nWith the exact counts $c_N$ enumerated, we analyze the growth pattern using two standard finite-$N$ estimators for the connective constant $\\mu$.\n1.  The ratio of successive terms, $r_N = c_N / c_{N-1}$.\n2.  The root estimator, $g_N = c_N^{1/N}$.\n\nFor large $N$, both $r_N$ and $g_N$ are known to converge to $\\mu$. The calculations for $N \\in \\{1, 2, 3, 4, 5, 6\\}$ are as follows:\n\n- **Ratios $r_N$**:\n  - $r_1 = c_1 / c_0 = 4 / 1 = 4.0$\n  - $r_2 = c_2 / c_1 = 12 / 4 = 3.0$\n  - $r_3 = c_3 / c_2 = 36 / 12 = 3.0$\n  - $r_4 = c_4 / c_3 = 100 / 36 \\approx 2.777778$\n  - $r_5 = c_5 / c_4 = 284 / 100 = 2.84$\n  - $r_6 = c_6 / c_5 = 780 / 284 \\approx 2.746479$\n\n- **Root Estimators $g_N$**:\n  - $g_1 = c_1^{1/1} = 4^{1} = 4.0$\n  - $g_2 = c_2^{1/2} = 12^{1/2} \\approx 3.464102$\n  - $g_3 = c_3^{1/3} = 36^{1/3} \\approx 3.301927$\n  - $g_4 = c_4^{1/4} = 100^{1/4} \\approx 3.162278$\n  - $g_5 = c_5^{1/5} = 284^{1/5} \\approx 3.097014$\n  - $g_6 = c_6^{1/6} = 780^{1/6} \\approx 3.033621$\n\n### Part 3: Submultiplicativity Verification\n\nThe problem requires verification of the submultiplicativity inequality, $c_{M+N} \\le c_M c_N$, for specified pairs. This property arises because concatenating two SAWs does not guarantee the resulting walk is self-avoiding, meaning the number of combined walks $c_{M+N}$ must be less than or equal to the product of the number of constituent walks $c_M c_N$.\n\nWe check this for the test pairs $(M,N) \\in \\{(1,1), (2,2), (3,3)\\}$.\n\n- **Case $(M,N) = (1,1)$**:\n  - We check if $c_{1+1} \\le c_1 \\times c_1$.\n  - This translates to $c_2 \\le c_1^2$.\n  - Plugging in the values: $12 \\le 4^2 \\implies 12 \\le 16$. This is true.\n\n- **Case $(M,N) = (2,2)$**:\n  - We check if $c_{2+2} \\le c_2 \\times c_2$.\n  - This translates to $c_4 \\le c_2^2$.\n  - Plugging in the values: $100 \\le 12^2 \\implies 100 \\le 144$. This is true.\n\n- **Case $(M,N) = (3,3)$**:\n  - We check if $c_{3+3} \\le c_3 \\times c_3$.\n  - This translates to $c_6 \\le c_3^2$.\n  - Plugging in the values: $780 \\le 36^2 \\implies 780 \\le 1296$. This is true.\n\nAll three checks confirm the submultiplicativity property for the given pairs. The final program will systematically compute these values and booleans and format them as specified.\n\n```python\n# The complete and runnable Python 3 code that generates the answer.\ndef solve():\n    \"\"\"\n    Computes properties of self-avoiding walks (SAWs) on a 2D square lattice.\n    - Enumerates the number of SAWs c_N for lengths N = 0 to 6.\n    - Calculates growth estimators r_N and g_N.\n    - Verifies the submultiplicativity property for specific cases.\n    \"\"\"\n    \n    def _count_recursive(pos, visited_sites, steps_left):\n        \"\"\"\n        Recursively counts SAWs from a given state using backtracking.\n        \"\"\"\n        if steps_left == 0:\n            return 1\n        \n        count = 0\n        x, y = pos\n        \n        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            next_pos = (x + dx, y + dy)\n            \n            if next_pos not in visited_sites:\n                visited_sites.add(next_pos)\n                count += _count_recursive(next_pos, visited_sites, steps_left - 1)\n                visited_sites.remove(next_pos)\n                \n        return count\n\n    def get_cn(n):\n        \"\"\"\n        Computes the number of SAWs of length n, c_n.\n        \"\"\"\n        if n == 0:\n            return 1\n            \n        start_pos = (0, 0)\n        visited_sites = {start_pos}\n        return _count_recursive(start_pos, visited_sites, n)\n\n    # 1. Enumerate c_N for N in {0, ..., 6}\n    cn_values = [get_cn(n) for n in range(7)]\n\n    # 2. Compute ratios r_N = c_N / c_{N-1}\n    rn_values = []\n    for i in range(1, 7):\n        val = cn_values[i] / cn_values[i-1]\n        rn_values.append(\"{:.6f}\".format(val))\n\n    # 3. Compute root estimators g_N = c_N^(1/N)\n    gn_values = []\n    for i in range(1, 7):\n        val = cn_values[i] ** (1/i)\n        gn_values.append(\"{:.6f}\".format(val))\n\n    # 4. Verify submultiplicativity property: c_{M+N} = c_M * c_N\n    bool_values = []\n    for m in [1, 2, 3]:\n        is_valid = cn_values[m + m] = cn_values[m] * cn_values[m]\n        bool_values.append(str(is_valid))\n\n    # Combine all results into a single list in the specified order.\n    all_results = list(map(str, cn_values)) + rn_values + gn_values + bool_values\n    \n    # Format the final output string as a comma-separated list in brackets.\n    output_str = f\"[{','.join(all_results)}]\"\n    \n    # This function would print the output string if run.\n    # print(output_str)\n\n```",
            "answer": "[1,4,12,36,100,284,780,4.000000,3.000000,3.000000,2.777778,2.840000,2.746479,4.000000,3.464102,3.301927,3.162278,3.097014,3.033621,True,True,True]"
        }
    ]
}