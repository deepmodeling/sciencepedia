{
    "hands_on_practices": [
        {
            "introduction": "To truly grasp a complex numerical procedure like the SIMPLE algorithm, it is essential to move beyond abstract flowcharts and engage with its mechanics directly. This first practice exercise demystifies the predictor-corrector sequence by walking through a single, complete SIMPLE iteration on a simplified one-dimensional grid. By manually computing the predicted velocities, solving the pressure-correction equation, and updating the mass fluxes, you will gain a concrete understanding of how momentum prediction and mass conservation are coupled .",
            "id": "4100265",
            "problem": "Consider an incompressible two-dimensional lid-driven cavity flow and focus on a one-dimensional, four-cell uniform control-volume line along the horizontal direction at a fixed vertical location. Use the Semi-Implicit Method for Pressure-Linked Equations (SIMPLE) to perform a single predictor-corrector iteration restricted to this line. Assume nondimensional variables so that spatial spacing, face area, and density are all unity. The purpose is to compute a single SIMPLE iteration consisting of predicted velocities, solution of the pressure-correction equation, and updated mass flux on a selected interior face.\n\nBase the derivation on the following fundamental laws and definitions:\n- The incompressible continuity equation is $ \\nabla \\cdot \\boldsymbol{u} = 0 $.\n- The incompressible momentum equation in integral form over a control volume states that the time rate of change of momentum equals the sum of surface fluxes and body forces; upon standard finite-volume spatial discretization and linearization, each component yields a linear algebraic equation of the form $ a_P u_P = \\sum_{N} a_N u_N + b $, where $ a_P $ is a positive diagonal coefficient, $ a_N $ are neighbor coefficients, and $ b $ is the assembled source term including explicit contributions (e.g., from the pressure gradient at the previous iteration).\n- In the SIMPLE algorithm, predicted velocities $ u^* $ are obtained by solving the linearized momentum equations with the current pressure field. Pressure correction $ p' $ enforces continuity, and updated velocities and fluxes are formed by applying the pressure correction.\n\nSimplify to a one-dimensional four-cell line with cell indices $ i \\in \\{0,1,2,3\\} $ and interior cells $ i \\in \\{1,2\\} $. Let $ u_i $ denote the cell-centered horizontal velocity at cell $ i $. Cells $ i = 0 $ and $ i = 3 $ are boundaries with prescribed velocities (nondimensional). Assume the following for this single SIMPLE iteration:\n1. Predictor step (momentum): For each interior cell $ i \\in \\{1,2\\} $, compute the predicted velocities $ u_i^* $ using a single Jacobi-like update,\n   $$ u_i^* = \\frac{a_{W,i} \\, u_{i-1}^{\\text{old}} + a_{E,i} \\, u_{i+1}^{\\text{old}} + b_i}{a_{P,i}} $$,\n   where $ a_{P,i} > 0 $ is the diagonal coefficient, $ a_{W,i} \\ge 0 $ and $ a_{E,i} \\ge 0 $ are neighbor coefficients to the west and east, respectively, and $ b_i $ is the source term. Boundary values $ u_0^* $ and $ u_3^* $ are equal to their prescribed values $ u_0^{\\text{old}} $ and $ u_3^{\\text{old}} $.\n2. Predicted face mass fluxes: For faces between cells $ (0|1) $, $ (1|2) $, and $ (2|3) $, compute predicted mass fluxes using arithmetic interpolation,\n   $$ F_{i,i+1}^* = \\frac{u_i^* + u_{i+1}^*}{2} $$,\n   noting that density and face area are unity in these nondimensional units.\n3. Continuity residuals: For interior cells $ i \\in \\{1,2\\} $, define the residual as the net outflow,\n   $$ r_i = F_{i-1,i}^* - F_{i,i+1}^* $$.\n   Continuity requires $ r_i = 0 $; nonzero $ r_i $ drives the pressure correction.\n4. Pressure-correction equation: Define face coefficients\n   $$ d_{0.5} = \\frac{1}{a_{P,1}}, \\quad d_{1.5} = \\frac{1}{2} \\left( \\frac{1}{a_{P,1}} + \\frac{1}{a_{P,2}} \\right), \\quad d_{2.5} = \\frac{1}{a_{P,2}} $$,\n   corresponding to faces $ (0|1) $, $ (1|2) $, and $ (2|3) $, respectively. With Dirichlet pressure-correction values $ p_0' = 0 $ and $ p_3' = 0 $ at the boundaries, assemble the linear system for $ p_1' $ and $ p_2' $:\n   $$ (d_{0.5} + d_{1.5}) \\, p_1' - d_{1.5} \\, p_2' = - r_1, $$\n   $$ - d_{1.5} \\, p_1' + (d_{1.5} + d_{2.5}) \\, p_2' = - r_2. $$\n   Solve this $ 2 \\times 2 $ system for $ p_1' $ and $ p_2' $.\n5. Flux correction and update at the selected interior face: For the selected interior face $ (1|2) $, update the mass flux using\n   $$ F_{1,2} = F_{1,2}^* - d_{1.5} \\left( p_2' - p_1' \\right) $$.\n\nAll quantities are nondimensional. No physical units are required. Angles are not involved. No percentages are involved.\n\nTest suite and required outputs:\n- For each test case, you are given $ a_{P,1} $, $ a_{P,2} $, $ a_{W,1} $, $ a_{E,1} $, $ a_{W,2} $, $ a_{E,2} $, $ b_1 $, $ b_2 $, and the boundary and interior initial guesses $ u_0^{\\text{old}} $, $ u_1^{\\text{old}} $, $ u_2^{\\text{old}} $, $ u_3^{\\text{old}} $. Apply the steps above to compute and return the list $ [u_1^*, u_2^*, p_1', p_2', F_{1,2}] $ for each test case, with each value rounded to six decimal places.\n- Use the following three test cases:\n  1. Case A (typical): $ a_{P,1} = 10.0 $, $ a_{P,2} = 12.0 $, $ a_{W,1} = 2.0 $, $ a_{E,1} = 3.0 $, $ a_{W,2} = 1.5 $, $ a_{E,2} = 2.5 $, $ b_1 = 1.5 $, $ b_2 = 1.0 $, $ u_0^{\\text{old}} = 0.0 $, $ u_1^{\\text{old}} = 0.2 $, $ u_2^{\\text{old}} = 0.1 $, $ u_3^{\\text{old}} = 0.0 $.\n  2. Case B (balanced-zero predictor): $ a_{P,1} = 8.0 $, $ a_{P,2} = 8.0 $, $ a_{W,1} = 2.0 $, $ a_{E,1} = 2.0 $, $ a_{W,2} = 2.0 $, $ a_{E,2} = 2.0 $, $ b_1 = 0.0 $, $ b_2 = 0.0 $, $ u_0^{\\text{old}} = 0.0 $, $ u_1^{\\text{old}} = 0.0 $, $ u_2^{\\text{old}} = 0.0 $, $ u_3^{\\text{old}} = 0.0 $.\n  3. Case C (weak diagonal, large correction): $ a_{P,1} = 1.5 $, $ a_{P,2} = 1.2 $, $ a_{W,1} = 0.5 $, $ a_{E,1} = 0.7 $, $ a_{W,2} = 0.6 $, $ a_{E,2} = 0.4 $, $ b_1 = 0.8 $, $ b_2 = 0.6 $, $ u_0^{\\text{old}} = 0.0 $, $ u_1^{\\text{old}} = 0.2 $, $ u_2^{\\text{old}} = -0.1 $, $ u_3^{\\text{old}} = 0.0 $.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list of lists, each inner list ordered as $ [u_1^*, u_2^*, p_1', p_2', F_{1,2}] $ with values rounded to six decimal places, enclosed in a single pair of square brackets. For example, an output with two cases would look like $ [[\\dots],[\\dots]] $.",
            "solution": "The problem statement is evaluated for validity before proceeding to a solution.\n\n### Step 1: Extract Givens\n\nThe problem provides a detailed, step-by-step procedure for a single iteration of the Semi-Implicit Method for Pressure Linked Equations (SIMPLE) on a simplified one-dimensional, four-cell computational grid. The key elements are:\n\n**Governing Principles and Definitions:**\n- Incompressible continuity equation: $ \\nabla \\cdot \\boldsymbol{u} = 0 $.\n- Discretized incompressible momentum equation form: $ a_P u_P = \\sum_{N} a_N u_N + b $.\n- Grid: One-dimensional four-cell line with indices $ i \\in \\{0,1,2,3\\} $. Interior cells are $ i \\in \\{1,2\\} $.\n- Nondimensionalization: Spatial spacing, face area, and density are all unity ($1$).\n- Boundary Conditions: Cells $ i = 0 $ and $ i = 3 $ have prescribed velocities. Pressure correction at boundaries is zero: $ p_0' = 0 $ and $ p_3' = 0 $.\n\n**Algorithmic Steps for a Single Iteration:**\n1.  **Predictor Step**: For interior cells $ i \\in \\{1,2\\} $, the predicted velocity $ u_i^* $ is computed from old-time values $ u^{\\text{old}} $ using a Jacobi-like update:\n    $$ u_i^* = \\frac{a_{W,i} \\, u_{i-1}^{\\text{old}} + a_{E,i} \\, u_{i+1}^{\\text{old}} + b_i}{a_{P,i}} $$\n    Boundary velocities are fixed: $ u_0^* = u_0^{\\text{old}} $ and $ u_3^* = u_3^{\\text{old}} $.\n2.  **Predicted Face Mass Fluxes**: For faces between cells, fluxes $ F^* $ are computed by arithmetic interpolation:\n    $$ F_{i,i+1}^* = \\frac{u_i^* + u_{i+1}^*}{2} $$\n3.  **Continuity Residuals**: For interior cells $ i \\in \\{1,2\\} $, the residual $ r_i $ is the net mass outflow:\n    $$ r_i = F_{i-1,i}^* - F_{i,i+1}^* $$\n4.  **Pressure-Correction Equation**: Face coefficients $ d $ are defined as:\n    $$ d_{0.5} = \\frac{1}{a_{P,1}}, \\quad d_{1.5} = \\frac{1}{2} \\left( \\frac{1}{a_{P,1}} + \\frac{1}{a_{P,2}} \\right), \\quad d_{2.5} = \\frac{1}{a_{P,2}} $$\n    The pressure-correction values for interior cells, $ p_1' $ and $ p_2' $, are found by solving the $ 2 \\times 2 $ linear system:\n    $$ (d_{0.5} + d_{1.5}) \\, p_1' - d_{1.5} \\, p_2' = - r_1 $$\n    $$ - d_{1.5} \\, p_1' + (d_{1.5} + d_{2.5}) \\, p_2' = - r_2 $$\n5.  **Flux Correction**: The mass flux at the interior face $ (1|2) $ is updated:\n    $$ F_{1,2} = F_{1,2}^* - d_{1.5} \\left( p_2' - p_1' \\right) $$\n\n**Test Cases and Output Requirements:**\n- Three test cases (A, B, C) are provided, each with a full set of parameters: $ a_{P,1}, a_{P,2}, a_{W,1}, a_{E,1}, a_{W,2}, a_{E,2}, b_1, b_2, u_0^{\\text{old}}, u_1^{\\text{old}}, u_2^{\\text{old}}, u_3^{\\text{old}} $.\n- The required output for each case is the list $ [u_1^*, u_2^*, p_1', p_2', F_{1,2}] $, with values rounded to six decimal places.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem is assessed against the validation criteria.\n\n-   **Scientifically Grounded**: The problem is an application of the SIMPLE algorithm, a cornerstone of computational fluid dynamics (CFD) for solving incompressible flows. The equations provided, though simplified for a one-dimensional case, correctly represent the fundamental steps of the algorithm: momentum prediction, calculation of mass imbalance (continuity residual), formulation of a Poisson-like equation for pressure correction, and a subsequent correction of velocities/fluxes. This is a standard and valid framework in the field.\n-   **Well-Posed**: The problem is structured as a sequence of explicit calculations. The inputs for each step are outputs from the previous one. The critical step is solving the $ 2 \\times 2 $ linear system for the pressure correction. The system matrix is $ \\boldsymbol{A} = \\begin{pmatrix} d_{0.5} + d_{1.5} & -d_{1.5} \\\\ -d_{1.5} & d_{1.5} + d_{2.5} \\end{pmatrix} $. The problem states $ a_{P,i} > 0 $, which implies all $ d $ coefficients ($d_{0.5}, d_{1.5}, d_{2.5}$) are strictly positive. The determinant of this matrix is $ \\det(\\boldsymbol{A}) = (d_{0.5} + d_{1.5})(d_{1.5} + d_{2.5}) - d_{1.5}^2 = d_{0.5}d_{1.5} + d_{0.5}d_{2.5} + d_{1.5}d_{2.5} $. Since all $ d $ coefficients are positive, the determinant is also strictly positive. Therefore, the matrix is always invertible, and a unique solution for $ (p_1', p_2') $ exists. The problem is well-posed.\n-   **Objective**: The problem is stated in precise, quantitative, and unambiguous terms. It is entirely free of subjective or opinion-based content.\n-   **Complete and Consistent**: All necessary data, including coefficients, initial conditions, and boundary conditions, are provided for each test case. The algorithmic steps are clearly delineated and do not contain internal contradictions.\n-   **Other Flaws**: The problem is not trivial, as it requires a multi-step calculation involving the solution of a linear system. It is a concrete computational problem, not a metaphor or tautology. The parameters given are physically plausible for a discretized flow problem.\n\nThe problem statement is a valid, well-defined computational task based on established principles of CFD.\n\n### Step 3: Verdict and Action\n\nThe problem is **valid**. A solution will be provided by systematically applying the prescribed algorithm to the given test cases.\n\n### Solution\n\nThe solution involves executing the five specified steps for each test case. The process is demonstrated below for Case A, and the final program will compute the results for all three cases.\n\n**Case A Walkthrough**\n\n**Given Data for Case A:**\n- Coefficients: $ a_{P,1} = 10.0 $, $ a_{P,2} = 12.0 $, $ a_{W,1} = 2.0 $, $ a_{E,1} = 3.0 $, $ a_{W,2} = 1.5 $, $ a_{E,2} = 2.5 $\n- Source terms: $ b_1 = 1.5 $, $ b_2 = 1.0 $\n- Initial velocities: $ u_0^{\\text{old}} = 0.0 $, $ u_1^{\\text{old}} = 0.2 $, $ u_2^{\\text{old}} = 0.1 $, $ u_3^{\\text{old}} = 0.0 $\n\n**1. Predictor Step**\nThe predicted velocities $ u_1^* $ and $ u_2^* $ for the interior cells are calculated. Boundary velocities are fixed.\n$ u_0^* = u_0^{\\text{old}} = 0.0 $\n$ u_3^* = u_3^{\\text{old}} = 0.0 $\n$$ u_1^* = \\frac{a_{W,1} \\, u_{0}^{\\text{old}} + a_{E,1} \\, u_{2}^{\\text{old}} + b_1}{a_{P,1}} = \\frac{(2.0)(0.0) + (3.0)(0.1) + 1.5}{10.0} = \\frac{0.3 + 1.5}{10.0} = 0.18 $$\n$$ u_2^* = \\frac{a_{W,2} \\, u_{1}^{\\text{old}} + a_{E,2} \\, u_{3}^{\\text{old}} + b_2}{a_{P,2}} = \\frac{(1.5)(0.2) + (2.5)(0.0) + 1.0}{12.0} = \\frac{0.3 + 1.0}{12.0} = \\frac{1.3}{12.0} \\approx 0.108333 $$\n\n**2. Predicted Face Mass Fluxes**\nThe predicted mass fluxes $ F^* $ at the cell faces are computed.\n$$ F_{0,1}^* = \\frac{u_0^* + u_1^*}{2} = \\frac{0.0 + 0.18}{2} = 0.09 $$\n$$ F_{1,2}^* = \\frac{u_1^* + u_2^*}{2} = \\frac{0.18 + 1.3/12.0}{2} \\approx \\frac{0.288333}{2} \\approx 0.144167 $$\n$$ F_{2,3}^* = \\frac{u_2^* + u_3^*}{2} = \\frac{1.3/12.0 + 0.0}{2} \\approx \\frac{0.108333}{2} \\approx 0.054167 $$\n\n**3. Continuity Residuals**\nThe mass imbalance (residuals) $ r_1 $ and $ r_2 $ for the interior cells are found.\n$$ r_1 = F_{0,1}^* - F_{1,2}^* \\approx 0.09 - 0.144167 = -0.054167 $$\n$$ r_2 = F_{1,2}^* - F_{2,3}^* \\approx 0.144167 - 0.054167 = 0.09 $$\n\n**4. Pressure-Correction Equation**\nFirst, calculate the face coefficients $ d $.\n$$ d_{0.5} = \\frac{1}{a_{P,1}} = \\frac{1}{10.0} = 0.1 $$\n$$ d_{1.5} = \\frac{1}{2} \\left( \\frac{1}{a_{P,1}} + \\frac{1}{a_{P,2}} \\right) = \\frac{1}{2} \\left( \\frac{1}{10.0} + \\frac{1}{12.0} \\right) = \\frac{1}{2} \\left( \\frac{11}{60} \\right) = \\frac{11}{120} \\approx 0.091667 $$\n$$ d_{2.5} = \\frac{1}{a_{P,2}} = \\frac{1}{12.0} \\approx 0.083333 $$\nAssemble and solve the $ 2 \\times 2 $ system for $ p_1' $ and $ p_2' $.\nThe system is $ \\boldsymbol{A} \\boldsymbol{p'} = \\boldsymbol{b} $, where $ \\boldsymbol{p'} = [p_1', p_2']^T $, $ \\boldsymbol{b} = [-r_1, -r_2]^T $, and the matrix is:\n$$ \\boldsymbol{A} = \\begin{pmatrix} d_{0.5} + d_{1.5} & -d_{1.5} \\\\ -d_{1.5} & d_{1.5} + d_{2.5} \\end{pmatrix} \\approx \\begin{pmatrix} 0.1 + 0.091667 & -0.091667 \\\\ -0.091667 & 0.091667 + 0.083333 \\end{pmatrix} = \\begin{pmatrix} 0.191667 & -0.091667 \\\\ -0.091667 & 0.175 \\end{pmatrix} $$\nThe right-hand side is $ \\boldsymbol{b} \\approx [0.054167, -0.09]^T $.\nSolving this system yields:\n$$ p_1' \\approx 0.048895 $$\n$$ p_2' \\approx -0.488674 $$\n\n**5. Flux Correction**\nFinally, update the mass flux $ F_{1,2} $ on the interior face.\n$$ F_{1,2} = F_{1,2}^* - d_{1.5} ( p_2' - p_1' ) $$\n$$ F_{1,2} \\approx 0.144167 - (0.091667) (-0.488674 - 0.048895) $$\n$$ F_{1,2} \\approx 0.144167 - (0.091667) (-0.537569) \\approx 0.144167 + 0.049277 \\approx 0.193444 $$\n\nThe final result vector for Case A, rounded to six decimal places, is $ [0.180000, 0.108333, 0.048895, -0.488674, 0.193444] $. The same procedure is applied to all test cases in the provided code.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D SIMPLE algorithm problem for a set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (typical)\n        {\n            \"coeffs\": (10.0, 12.0, 2.0, 3.0, 1.5, 2.5),\n            \"sources\": (1.5, 1.0),\n            \"u_old\": (0.0, 0.2, 0.1, 0.0)\n        },\n        # Case B (balanced-zero predictor)\n        {\n            \"coeffs\": (8.0, 8.0, 2.0, 2.0, 2.0, 2.0),\n            \"sources\": (0.0, 0.0),\n            \"u_old\": (0.0, 0.0, 0.0, 0.0)\n        },\n        # Case C (weak diagonal, large correction)\n        {\n            \"coeffs\": (1.5, 1.2, 0.5, 0.7, 0.6, 0.4),\n            \"sources\": (0.8, 0.6),\n            \"u_old\": (0.0, 0.2, -0.1, 0.0)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters for the current case\n        a_P1, a_P2, a_W1, a_E1, a_W2, a_E2 = case[\"coeffs\"]\n        b1, b2 = case[\"sources\"]\n        u0_old, u1_old, u2_old, u3_old = case[\"u_old\"]\n\n        # Step 1: Predictor step\n        # Boundary velocities are fixed\n        u0_star = u0_old\n        u3_star = u3_old\n        \n        # Predicted velocities for interior cells\n        u1_star = (a_W1 * u0_old + a_E1 * u2_old + b1) / a_P1\n        u2_star = (a_W2 * u1_old + a_E2 * u3_old + b2) / a_P2\n\n        # Step 2: Predicted face mass fluxes\n        F_01_star = (u0_star + u1_star) / 2.0\n        F_12_star = (u1_star + u2_star) / 2.0\n        F_23_star = (u2_star + u3_star) / 2.0\n\n        # Step 3: Continuity residuals\n        r1 = F_01_star - F_12_star\n        r2 = F_12_star - F_23_star\n\n        # Step 4: Pressure-correction equation\n        # Define face coefficients d\n        d_05 = 1.0 / a_P1\n        d_15 = 0.5 * (1.0 / a_P1 + 1.0 / a_P2)\n        d_25 = 1.0 / a_P2\n\n        # Assemble the 2x2 linear system A * p' = b_p\n        A_p = np.array([\n            [d_05 + d_15, -d_15],\n            [-d_15, d_15 + d_25]\n        ])\n        b_p = np.array([-r1, -r2])\n\n        # Solve for pressure correction values [p1', p2']\n        p_prime = np.linalg.solve(A_p, b_p)\n        p1_prime = p_prime[0]\n        p2_prime = p_prime[1]\n\n        # Step 5: Flux correction and update\n        F_12 = F_12_star - d_15 * (p2_prime - p1_prime)\n\n        # Assemble the result vector and round to six decimal places\n        case_result = [\n            round(u1_star, 6),\n            round(u2_star, 6),\n            round(p1_prime, 6),\n            round(p2_prime, 6),\n            round(F_12, 6)\n        ]\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The default string representation of a list is desired\n    # so we convert the final list of lists to string.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "At the heart of both SIMPLE and PISO algorithms lies the solution of a Poisson-like equation for the pressure correction, which enforces mass conservation. A crucial feature of this equation in closed domains is that it determines the pressure correction only up to an arbitrary constant, resulting in a singular linear system. This exercise confronts this fundamental numerical challenge head-on, tasking you with computationally verifying the singularity and implementing two standard, robust strategies—pinning a value and enforcing a zero-mean constraint—to render the system solvable .",
            "id": "4100333",
            "problem": "Consider incompressible flow in the context of pressure-velocity coupling algorithms, specifically the Semi-Implicit Method for Pressure-Linked Equations (SIMPLE) and Pressure-Implicit with Splitting of Operators (PISO). The discrete pressure correction equation in these algorithms arises from enforcing mass conservation on a provisional velocity field. Starting from the incompressible continuity equation $ \\nabla \\cdot \\mathbf{u} = 0 $ and the momentum balance, a provisional velocity $ \\mathbf{u}^{\\ast} $ is corrected by a pressure increment (pressure correction) $ p' $ to enforce $ \\nabla \\cdot \\mathbf{u} = 0 $. In both SIMPLE and PISO, a Poisson-like equation of the form $ \\nabla^2 p' = \\text{source} $ is constructed, where the pressure correction boundary conditions are typically homogeneous Neumann ($\\partial p'/\\partial n = 0$), reflecting the fact that $ p' $ is a relative adjustment. Without a reference pressure or a mean constraint, the pressure correction is determined only up to an additive constant; hence the discrete pressure correction matrix has a null space spanned by the constant vector.\n\nYour task is to demonstrate, through a computational construction, that the discrete pressure correction matrix $ \\mathbf{A} $ (a discrete Laplacian with homogeneous Neumann boundary conditions) is singular when no reference pressure is enforced, and to implement two strategies that remove the null space to produce a unique, well-posed linear system:\n\n- Strategy 1 (Dirichlet pinning): Set one pressure correction degree of freedom to zero, i.e., enforce $ p'_k = 0 $ at a single index $ k $.\n- Strategy 2 (Zero-mean enforcement): Impose $ \\sum_i p'_i = 0 $ via a Lagrange multiplier $ \\lambda $, thereby solving the augmented system\n$$\n\\begin{bmatrix}\n\\mathbf{A} & \\mathbf{1} \\\\\n\\mathbf{1}^\\top & 0\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{p}' \\\\ \\lambda\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{b} \\\\ 0\n\\end{bmatrix},\n$$\nwhere $ \\mathbf{1} $ is the vector of ones, $ \\mathbf{p}' $ is the vector of nodal pressure corrections, and $ \\mathbf{b} $ is the discrete source derived from the divergence of the provisional velocity $ \\mathbf{u}^\\ast $.\n\nFundamental base for the derivation:\n- Incompressible continuity $ \\nabla \\cdot \\mathbf{u} = 0 $ and the pressure correction linking velocity correction $ \\delta \\mathbf{u} $ to pressure correction $ p' $ through the gradient, i.e., $ \\delta \\mathbf{u} \\propto -\\nabla p' $; enforcing continuity yields a Poisson equation for $ p' $.\n- Discrete Laplacian with homogeneous Neumann boundary conditions has a constant null space, rendering the system singular without an additional constraint.\n\nImplement a complete, runnable program that:\n1. Builds the discrete Laplacian matrix $ \\mathbf{A} $ with homogeneous Neumann boundary conditions on a uniform grid with spacing $ \\Delta x = \\Delta y = 1 $ for one-dimensional and two-dimensional cases. For a one-dimensional grid with $ N $ points, use the stencil $ [-1, +1] $ at boundaries and $ [+1, -2, +1] $ in the interior. For a two-dimensional grid with $ N_x \\times N_y $ points, use a five-point stencil where the diagonal entry is $ -n_{\\text{nbr}} $ with $ n_{\\text{nbr}} $ equal to the number of valid neighbors (from $ \\{ \\text{left}, \\text{right}, \\text{top}, \\text{bottom} \\} $), and off-diagonal entries of $ +1 $ for each neighbor, ensuring that row sums are zero so that the constant vector is in the null space.\n2. Verifies singularity of $ \\mathbf{A} $ by computing the singular values and checking whether the smallest singular value $ \\sigma_{\\min} $ satisfies $ \\sigma_{\\min} \\leq \\epsilon \\, \\sigma_{\\max} $ with $ \\epsilon = 10^{-10} $; treat $ \\mathbf{A} $ as singular if $ \\sigma_{\\max} = 0 $.\n3. Implements Strategy 1 by pinning one degree of freedom $ p'_k = 0 $ via modification of $ \\mathbf{A} $: set row $ k $ and column $ k $ to zero, set the diagonal entry $ A_{kk} = 1 $, and set the right-hand side $ b_k = 0 $. Solve $ \\mathbf{A}_{\\text{pin}} \\mathbf{p}' = \\mathbf{b}_{\\text{pin}} $ and compute the normalized residual $ r_{\\text{pin}} = \\|\\mathbf{A}_{\\text{pin}} \\mathbf{p}' - \\mathbf{b}_{\\text{pin}}\\|_2 / \\|\\mathbf{b}_{\\text{pin}}\\|_2 $.\n4. Implements Strategy 2 by solving the augmented system with a Lagrange multiplier as above and computing the normalized residual of the augmented system $ r_{\\text{mean}} = \\sqrt{\\|\\mathbf{A} \\mathbf{p}' + \\mathbf{1} \\lambda - \\mathbf{b}\\|_2^2 + (\\mathbf{1}^\\top \\mathbf{p}')^2} / \\sqrt{\\|\\mathbf{b}\\|_2^2 + 0} $.\n5. For each test case, outputs a list of the form $ [\\text{is\\_singular}, r_{\\text{pin}}, r_{\\text{mean}}] $, where $ \\text{is\\_singular} $ is a boolean, and $ r_{\\text{pin}} $ and $ r_{\\text{mean}} $ are floats.\n\nUse the following test suite:\n- Test case 1 (happy path, one-dimensional): $ N = 5 $, $ \\mathbf{b} $ defined by $ b_i = \\sin(0.3 (i+1)) + 0.1 (i+1) $ for $ i = 0, \\dots, 4 $, pin index $ k = 0 $.\n- Test case 2 (two-dimensional, moderate size): $ N_x = 4 $, $ N_y = 3 $, $ \\mathbf{b} $ defined by $ b_{i,j} = \\sin(0.2 (i+1)) + \\cos(0.3 (j+1)) $ for $ i = 0, \\dots, 3 $, $ j = 0, \\dots, 2 $, flattened in row-major order; pin index $ k = 0 $.\n- Test case 3 (edge case, single cell): $ N_x = 1 $, $ N_y = 1 $, $ \\mathbf{b} = [2.0] $, pin index $ k = 0 $.\n\nNo physical units are required as the system is nondimensionalized with unit grid spacing.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case contributes a sub-list in the form $ [\\text{is\\_singular}, r_{\\text{pin}}, r_{\\text{mean}}] $. The final line must be a single list aggregating the three sub-lists, for example, $ [[\\text{bool}, \\text{float}, \\text{float}], [\\text{bool}, \\text{float}, \\text{float}], [\\text{bool}, \\text{float}, \\text{float}]] $.",
            "solution": "The problem at hand addresses a fundamental numerical issue in the simulation of incompressible fluid flows using projection methods, such as the SIMPLE (Semi-Implicit Method for Pressure-Linked Equations) and PISO (Pressure-Implicit with Splitting of Operators) algorithms. The core of these methods is the enforcement of the incompressibility constraint, expressed by the continuity equation $\\nabla \\cdot \\mathbf{u} = 0$, where $\\mathbf{u}$ is the velocity field.\n\nThe process typically involves two stages. First, a provisional velocity field, denoted $\\mathbf{u}^{\\ast}$, is computed from the momentum equations, but this field does not generally satisfy the incompressibility constraint, i.e., $\\nabla \\cdot \\mathbf{u}^{\\ast} \\neq 0$. Second, a correction step is performed to project this velocity field onto the subspace of divergence-free fields. The corrected velocity $\\mathbf{u}$ and pressure $p$ are related to their provisional counterparts ($\\mathbf{u}^{\\ast}$, $p^{\\ast}$) through corrections $\\delta\\mathbf{u}$ and $p'$:\n$$ \\mathbf{u} = \\mathbf{u}^{\\ast} + \\delta\\mathbf{u} $$\n$$ p = p^{\\ast} + p' $$\nA simplified form of the momentum equation links the velocity correction to the gradient of the pressure correction, $\\delta\\mathbf{u} \\propto -\\nabla p'$. By substituting this into the continuity equation for the final velocity, $\\nabla \\cdot \\mathbf{u} = 0$, we obtain a Poisson equation for the pressure correction $p'$:\n$$ \\nabla \\cdot (\\mathbf{u}^{\\ast} - C \\nabla p') = 0 \\implies \\nabla^2 p' = \\frac{1}{C} \\nabla \\cdot \\mathbf{u}^{\\ast} $$\nwhere $C$ is a constant incorporating the time step and other discretization factors. The term on the right-hand side represents the mass imbalance of the provisional velocity field and acts as the source term for the Poisson equation.\n\nWhen this equation is discretized on a computational grid, it yields a linear system of equations of the form $\\mathbf{A} \\mathbf{p}' = \\mathbf{b}$, where $\\mathbf{p}'$ is the vector of unknown pressure corrections at grid points, $\\mathbf{b}$ is the discretized source term ($\\nabla \\cdot \\mathbf{u}^{\\ast}$), and $\\mathbf{A}$ is the discrete Laplacian operator. A crucial aspect is the boundary conditions for $p'$. At boundaries where the velocity is specified (e.g., inlets, fixed walls), the normal component of the velocity correction is zero. This translates to a homogeneous Neumann boundary condition for the pressure correction: $\\frac{\\partial p'}{\\partial n} = 0$, where $n$ is the direction normal to the boundary.\n\nThe discrete Laplacian matrix $\\mathbf{A}$ constructed with these homogeneous Neumann boundary conditions has a specific property: the sum of the entries in each row is zero. This implies that $\\mathbf{A}\\mathbf{1} = \\mathbf{0}$, where $\\mathbf{1}$ is a column vector of ones. Mathematically, this means that the vector $\\mathbf{1}$ is an eigenvector of $\\mathbf{A}$ with a corresponding eigenvalue of $0$. Consequently, $\\mathbf{A}$ has a non-trivial null space, is singular, and the system $\\mathbf{A} \\mathbf{p}' = \\mathbf{b}$ does not have a unique solution. If $\\mathbf{p}'_s$ is a particular solution, then $\\mathbf{p}'_s + c\\mathbf{1}$ is also a solution for any arbitrary constant $c$, since $\\mathbf{A}(\\mathbf{p}'_s + c\\mathbf{1}) = \\mathbf{A}\\mathbf{p}'_s + c(\\mathbf{A}\\mathbf{1}) = \\mathbf{b} + \\mathbf{0} = \\mathbf{b}$. This ambiguity reflects the physical fact that pressure in an incompressible flow is only determined up to an additive constant. To obtain a unique solution, an additional constraint must be imposed.\n\nThis exercise demonstrates the singularity computationally and implements two standard strategies to regularize the system.\n\n**1. Matrix Construction and Singularity Verification**\nThe discrete Laplacian matrix $\\mathbf{A}$ is constructed for one-dimensional and two-dimensional uniform grids with spacing $\\Delta x = \\Delta y = 1$. The construction ensures that for any row $i$, the diagonal element $A_{ii}$ is the negative sum of the off-diagonal elements in that row, i.e., $A_{ii} = -\\sum_{j \\neq i} A_{ij}$, which enforces the zero row-sum property.\n- For a 1D grid with $N$ points, the interior points use a $[+1, -2, +1]$ stencil, and boundary points use a stencil leading to a zero row-sum (e.g., $[-1, +1]$).\n- For a 2D grid, a five-point stencil is used where $A_{kk} = -n_{\\text{nbr}}$ (number of neighbors) and off-diagonal entries corresponding to neighbors are $+1$.\nThe singularity of $\\mathbf{A}$ is verified numerically by computing its singular values via Singular Value Decomposition (SVD). A matrix is singular if its smallest singular value, $\\sigma_{\\min}$, is zero. In finite-precision arithmetic, we test if $\\sigma_{\\min}$ is negligibly small compared to the largest singular value, $\\sigma_{\\max}$, i.e., $\\sigma_{\\min} \\leq \\epsilon \\, \\sigma_{\\max}$ for a small tolerance $\\epsilon = 10^{-10}$. If $\\sigma_{\\max} = 0$, the matrix (e.g., the zero matrix for a $1 \\times 1$ grid) is also singular.\n\n**2. Regularization Strategies**\n\n**Strategy 1: Dirichlet Pinning**\nThis method removes the ambiguity by fixing the pressure correction at a single point $k$ to a reference value, typically zero: $p'_k = 0$. This is equivalent to setting a reference pressure. Algorithmically, this is implemented by modifying the system $\\mathbf{A} \\mathbf{p}' = \\mathbf{b}$:\n- The $k$-th row of $\\mathbf{A}$ is replaced with zeros except for a $1$ on the diagonal, and the $k$-th element of $\\mathbf{b}$ is set to $0$. This enforces $p'_k = 0$.\n- To maintain symmetry (if desired for certain solvers), the $k$-th column of $\\mathbf{A}$ is also typically zeroed out (except for the diagonal).\nThe resulting system, $\\mathbf{A}_{\\text{pin}} \\mathbf{p}' = \\mathbf{b}_{\\text{pin}}$, is non-singular and can be solved uniquely. The quality of the solution is assessed by the normalized residual $r_{\\text{pin}} = \\frac{\\|\\mathbf{A}_{\\text{pin}} \\mathbf{p}' - \\mathbf{b}_{\\text{pin}}\\|_2}{\\|\\mathbf{b}_{\\text{pin}}\\|_2}$.\n\n**Strategy 2: Zero-Mean Enforcement**\nThis strategy imposes a global constraint on the solution, requiring the mean of the pressure correction to be zero: $\\sum_i p'_i = 0$, which can be written as $\\mathbf{1}^\\top \\mathbf{p}' = 0$. This constraint removes the constant component from the solution space. The constraint is incorporated into the linear system using a Lagrange multiplier, $\\lambda$, resulting in the augmented (saddle-point) system:\n$$\n\\begin{bmatrix}\n\\mathbf{A} & \\mathbf{1} \\\\\n\\mathbf{1}^\\top & 0\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{p}' \\\\ \\lambda\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{b} \\\\ 0\n\\end{bmatrix}\n$$\nThe augmented matrix is non-singular (provided $\\mathbf{A}$'s null space is spanned only by $\\mathbf{1}$), and solving this system yields a unique solution for both $\\mathbf{p}'$ (with zero mean) and $\\lambda$. The residual for this augmented system is normalized as $r_{\\text{mean}} = \\frac{\\sqrt{\\|\\mathbf{A} \\mathbf{p}' + \\mathbf{1} \\lambda - \\mathbf{b}\\|_2^2 + (\\mathbf{1}^\\top \\mathbf{p}')^2}}{\\|\\mathbf{b}\\|_2}$.\n\nThe implementation below constructs the matrices for the given test cases, verifies their singularity, and applies both regularization strategies to solve for the pressure correction, reporting the respective normalized residuals.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_laplacian_1d(N):\n    \"\"\"\n    Builds the 1D discrete Laplacian matrix A with homogeneous Neumann BCs.\n    The matrix will have zero row sums.\n    \"\"\"\n    if N == 1:\n        return np.array([[0.0]])\n    \n    A = np.zeros((N, N))\n    \n    # Interior points: stencil [+1, -2, +1]\n    for i in range(1, N - 1):\n        A[i, i - 1] = 1.0\n        A[i, i] = -2.0\n        A[i, i + 1] = 1.0\n        \n    # Boundary points: stencil ensures row sum is zero\n    # i=0: -p'_0 + p'_1 = 0\n    A[0, 0] = -1.0\n    A[0, 1] = 1.0\n    # i=N-1: p'_{N-2} - p'_{N-1} = 0\n    A[N - 1, N - 2] = 1.0\n    A[N - 1, N - 1] = -1.0\n    \n    return A\n\ndef build_laplacian_2d(Nx, Ny):\n    \"\"\"\n    Builds the 2D discrete Laplacian matrix A with homogeneous Neumann BCs\n    on a Nx x Ny grid. The matrix will have zero row sums.\n    \"\"\"\n    N = Nx * Ny\n    A = np.zeros((N, N))\n\n    for j in range(Ny):\n        for i in range(Nx):\n            k = j * Nx + i  # Row-major index\n            neighbors = []\n            \n            # Left neighbor\n            if i > 0:\n                neighbors.append(k - 1)\n            # Right neighbor\n            if i < Nx - 1:\n                neighbors.append(k + 1)\n            # Bottom neighbor\n            if j > 0:\n                neighbors.append(k - Nx)\n            # Top neighbor\n            if j < Ny - 1:\n                neighbors.append(k + Nx)\n            \n            # Set off-diagonal entries\n            for neighbor_idx in neighbors:\n                A[k, neighbor_idx] = 1.0\n            \n            # Set diagonal entry\n            A[k, k] = -len(neighbors)\n            \n    return A\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and generate the final output.\n    \"\"\"\n    test_cases = [\n        {\n            \"dim\": 1, \"N\": 5, \"Nx\": 5, \"Ny\": 1, \"pin_k\": 0,\n            \"b_func\": lambda i, j: np.sin(0.3 * (i + 1)) + 0.1 * (i + 1)\n        },\n        {\n            \"dim\": 2, \"N\": 12, \"Nx\": 4, \"Ny\": 3, \"pin_k\": 0,\n            \"b_func\": lambda i, j: np.sin(0.2 * (i + 1)) + np.cos(0.3 * (j + 1))\n        },\n        {\n            \"dim\": 2, \"N\": 1, \"Nx\": 1, \"Ny\": 1, \"pin_k\": 0,\n            \"b_func\": lambda i, j: 2.0\n        }\n    ]\n    \n    epsilon = 1e-10\n    results = []\n\n    for case in test_cases:\n        N = case[\"N\"]\n        Nx = case[\"Nx\"]\n        Ny = case[\"Ny\"]\n        pin_k = case[\"pin_k\"]\n\n        # 1. Build matrix A and vector b\n        if case[\"dim\"] == 1:\n            A = build_laplacian_1d(N)\n            b = np.array([case[\"b_func\"](i, 0) for i in range(N)])\n        else: # dim == 2\n            A = build_laplacian_2d(Nx, Ny)\n            b = np.array([case[\"b_func\"](i, j) for j in range(Ny) for i in range(Nx)])\n        \n        # 2. Verify singularity\n        if N > 0:\n            s = np.linalg.svd(A, compute_uv=False)\n            sigma_max = s[0] if len(s) > 0 else 0.0\n            sigma_min = s[-1] if len(s) > 0 else 0.0\n        \n            if sigma_max == 0:\n                is_singular = True\n            else:\n                is_singular = (sigma_min / sigma_max) <= epsilon\n        else: # N=0 case\n             is_singular = False # Or debatable, but not in test cases\n\n        # 3. Strategy 1: Pinning\n        A_pin = A.copy()\n        b_pin = b.copy()\n        \n        A_pin[pin_k, :] = 0.0\n        A_pin[:, pin_k] = 0.0\n        A_pin[pin_k, pin_k] = 1.0\n        b_pin[pin_k] = 0.0\n        \n        p_pin = np.linalg.solve(A_pin, b_pin)\n        \n        norm_b_pin = np.linalg.norm(b_pin)\n        if norm_b_pin == 0.0:\n            r_pin = 0.0\n        else:\n            residual_vec_pin = A_pin @ p_pin - b_pin\n            r_pin = np.linalg.norm(residual_vec_pin) / norm_b_pin\n\n        # 4. Strategy 2: Zero-mean\n        if N > 0:\n            A_aug = np.zeros((N + 1, N + 1))\n            ones_vec = np.ones(N)\n            \n            A_aug[:N, :N] = A\n            A_aug[:N, N] = ones_vec\n            A_aug[N, :N] = ones_vec.T\n            \n            b_aug = np.zeros(N + 1)\n            b_aug[:N] = b\n            \n            sol_aug = np.linalg.solve(A_aug, b_aug)\n            p_mean = sol_aug[:N]\n            lambda_ = sol_aug[N]\n            \n            norm_b = np.linalg.norm(b)\n            if norm_b == 0.0:\n                 r_mean = 0.0\n            else:\n                num_term1_norm = np.linalg.norm(A @ p_mean + ones_vec * lambda_ - b)\n                num_term2 = np.dot(ones_vec.T, p_mean)\n                numerator = np.sqrt(num_term1_norm**2 + num_term2**2)\n                r_mean = numerator / norm_b\n        else:\n            r_mean = 0.0\n        \n        results.append([is_singular, r_pin, r_mean])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Our final practice builds upon the preceding concepts by applying the pressure-correction mechanism to one of the most common and critical scenarios in computational fluid dynamics: enforcing boundary conditions at a solid wall. In collocated grid arrangements, ensuring the corrected velocity field respects the physical no-slip and impermeability conditions requires careful formulation of the corrector step at the boundary. This problem provides a focused analysis of how the pressure-correction gradient is calculated to precisely nullify any spurious mass flux predicted at a wall, ensuring the final velocity field is physically consistent .",
            "id": "4100343",
            "problem": "Consider a two-dimensional incompressible Newtonian fluid discretized by a collocated finite-volume method in a predictor-corrector algorithm for pressure-velocity coupling such as Semi-Implicit Method for Pressure Linked Equations (SIMPLE) or Pressure-Implicit with Splitting of Operators (PISO). A control volume with center $P$ is adjacent to a planar, impermeable, no-slip wall whose outward unit normal is $\\hat{n}$ and unit tangent is $\\hat{t}$. After the momentum predictor, the wall-face normal mass flux (based on the predicted velocity field) is $\\dot{m}_f^{*}$, which is not necessarily zero. The subsequent pressure-correction step updates the cell-centered velocity by subtracting a pressure-correction gradient scaled by an effective coefficient. Assume the following data:\n- Fluid density $\\rho = 1000$ kilograms per cubic meter (kg/m$^{3}$).\n- Wall-face area $S_f = 0.08$ square meters (m$^{2}$).\n- Predicted wall-face normal mass flux $\\dot{m}_f^{*} = 0.1$ kilograms per second (kg/s).\n- Effective face coefficient $d_f = 4.0 \\times 10^{-4}$ cubic meters times seconds per kilogram (m$^{3}$ s/kg) relating the normal component of the pressure-correction gradient at the face to the change in the wall-normal velocity at that face.\n- Effective cell-center coefficient $d_P = 5.0 \\times 10^{-4}$ cubic meters times seconds per kilogram (m$^{3}$ s/kg) relating the pressure-correction gradient at $P$ to the velocity correction at $P$.\n\nAssume the pressure-correction field has a wall-normal component of its gradient that is uniform between the cell center $P$ and the wall face, and that the wall-tangential component of the pressure-correction gradient at the wall is zero so that the no-slip condition is preserved by the corrector. Using only\n- the incompressible mass conservation with impermeability at the wall, and\n- the linearized momentum corrector that subtracts an appropriately scaled pressure-correction gradient from the predicted velocity,\n\nderive and compute the corrections to the wall-normal and wall-tangential components of the velocity at the cell center $P$ produced by the pressure-correction step. Express your final answer as a $1 \\times 2$ row matrix $[\\Delta u_n \\;\\; \\Delta u_t]$ in meters per second, and round your answer to four significant figures.",
            "solution": "We start from the incompressible continuity equation and the impermeable wall condition. The impermeability requires that the wall-normal velocity at the wall face is zero. In a predictor-corrector scheme, the momentum predictor provides a provisional velocity that generally does not satisfy the discrete continuity constraint. The corrector then applies a pressure-correction gradient to adjust the velocity field to enforce continuity. For a collocated finite-volume method, a standard linearization of the momentum operator implies that the velocity correction is proportional to the gradient of the pressure correction.\n\nLet $\\mathbf{u}^{*}$ denote the predicted velocity and $\\mathbf{u}'$ the corrected velocity at the pressure-correction step. At the cell center $P$, the linearized momentum corrector takes the form\n$$\n\\mathbf{u}'(P) \\;=\\; \\mathbf{u}^{*}(P) \\;-\\; d_P \\,\\nabla p'(P) $$,\nwhere $d_P$ is an effective scalar coefficient that encapsulates the local inverse diagonal of the linearized momentum operator, and $p'$ is the pressure correction. Taking components along the wall-normal and wall-tangential directions, we obtain the cell-centered velocity corrections\n$$\n\\Delta u_n(P) \\;=\\; -\\, d_P \\, \\left(\\nabla p'\\right)(P)\\cdot \\hat{n}, \\qquad \\Delta u_t(P) \\;=\\; -\\, d_P \\, \\left(\\nabla p'\\right)(P)\\cdot \\hat{t} $$.\nAt the wall face, the normal mass flux based on the corrected velocity must vanish by impermeability. Let $\\dot{m}_f^{*}$ be the predicted wall-face normal mass flux (based on $\\mathbf{u}^{*}$), and let $\\dot{m}_f'$ be the corrected wall-face normal mass flux. Mass conservation at the impermeable wall imposes\n$$\n\\dot{m}_f' \\;=\\; 0 $$.\nThe pressure correction modifies the wall-face normal velocity and hence the wall-face normal mass flux. Under a linear face interpolation consistent with the same momentum linearization, the change in wall-face normal mass flux due to the pressure correction is proportional to the wall-normal component of the pressure-correction gradient at the face:\n$$\n\\Delta \\dot{m}_f \\;=\\; \\dot{m}_f' - \\dot{m}_f^{*} \\;=\\; -\\, \\rho \\, S_f \\, d_f \\; \\left(\\nabla p'\\right)_f \\cdot \\hat{n} $$.\nEnforcing $\\dot{m}_f' = 0$ gives\n$$\n0 \\;=\\; \\dot{m}_f^{*} - \\rho \\, S_f \\, d_f \\; \\left(\\nabla p'\\right)_f \\cdot \\hat{n} \\;\\;\\Longrightarrow\\;\\; \\left(\\nabla p'\\right)_f \\cdot \\hat{n} \\;=\\; \\frac{\\dot{m}_f^{*}}{\\rho \\, S_f \\, d_f} $$.\nBy the stated assumption that the wall-normal component of $\\nabla p'$ is uniform between $P$ and the wall face, we take\n$$\n\\left(\\nabla p'\\right)(P)\\cdot \\hat{n} \\;=\\; \\left(\\nabla p'\\right)_f \\cdot \\hat{n} \\;=\\; \\frac{\\dot{m}_f^{*}}{\\rho \\, S_f \\, d_f} $$.\nTherefore, the cell-centered wall-normal velocity correction is\n$$\n\\Delta u_n(P) \\;=\\; -\\, d_P \\, \\frac{\\dot{m}_f^{*}}{\\rho \\, S_f \\, d_f} $$.\nTo preserve the no-slip condition in the corrector, we enforce that the pressure-correction gradient has no tangential component at the wall. With the stated assumption that the wall-tangential component is zero at the wall, and given that the same tangential component applies at $P$ for the corrector under linearization, we have\n$$\n\\left(\\nabla p'\\right)(P)\\cdot \\hat{t} \\;=\\; 0 \\;\\;\\Longrightarrow\\;\\; \\Delta u_t(P) \\;=\\; 0 $$.\n\nWe now evaluate the numerical values using the given parameters:\n- $\\rho = 1000$ kg/m$^{3}$,\n- $S_f = 0.08$ m$^{2}$,\n- $d_f = 4.0 \\times 10^{-4}$ m$^{3}$ s/kg,\n- $d_P = 5.0 \\times 10^{-4}$ m$^{3}$ s/kg,\n- $\\dot{m}_f^{*} = 0.1$ kg/s.\n\nFirst compute the wall-normal component of the pressure-correction gradient:\n$$\n\\left(\\nabla p'\\right)\\cdot \\hat{n} \\;=\\; \\frac{\\dot{m}_f^{*}}{\\rho \\, S_f \\, d_f}\n\\;=\\; \\frac{0.1}{1000 \\times 0.08 \\times 4.0 \\times 10^{-4}}\n\\;=\\; \\frac{0.1}{0.032}\n\\;=\\; 3.125.\n$$\nThis value has units of pressure gradient, consistent with kilograms per meter squared per second squared. The cell-centered wall-normal velocity correction is then\n$$\n\\Delta u_n(P) \\;=\\; -\\, d_P \\, \\left(\\nabla p'\\right)\\cdot \\hat{n}\n\\;=\\; -\\, \\left(5.0 \\times 10^{-4}\\right) \\times 3.125\n\\;=\\; -\\, 1.5625 \\times 10^{-3}.\n$$\nThus, in meters per second, $\\Delta u_n(P) = -0.0015625$ m/s. The wall-tangential correction is\n$$\n\\Delta u_t(P) \\;=\\; 0.\n$$\nRounding to four significant figures and expressing the result as a $1 \\times 2$ row matrix in meters per second gives\n$$\n[\\Delta u_n \\;\\; \\Delta u_t] \\;=\\; [-0.001563 \\;\\; 0].\n$$",
            "answer": "$$\\boxed{\\begin{pmatrix}-0.001563 & 0\\end{pmatrix}}$$"
        }
    ]
}