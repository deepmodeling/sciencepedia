{
    "hands_on_practices": [
        {
            "introduction": "任何稳定且物理意义明确的数值模拟都始于一个能够反映其连续对应物性质的离散算子。此练习旨在指导您构建一个离散的扩散算子，该算子需具备对称性和半正定性，这对于保证数值方案的稳定性和物理真实性至关重要。通过这个实践，您将掌握将连续的数学物理模型转化为稳健计算代码的核心技术。",
            "id": "3981941",
            "problem": "考虑计算聚变科学与工程中 Fokker–Planck 碰撞算子里的速度空间扩散项，其散度形式写作 $\\nabla_{\\mathbf{v}} \\cdot \\mathbf{D}(\\mathbf{v}) \\cdot \\nabla_{\\mathbf{v}} f$，其中 $\\mathbf{v}$ 是无量纲速度，$\\mathbf{D}(\\mathbf{v})$ 是一个对称、半正定的扩散张量。您的任务是，从第一性原理出发，在一个均匀的、笛卡尔坐标系的、无量纲速度网格上，推导一组最近邻模板系数。这些系数产生一个离散算子，该算子在齐次 Neumann 边界条件下是对称且半正定的，在齐次 Dirichlet 边界条件下是对称且正定的。推导必须从与散度结构一致的守恒和对称性原理开始，并且必须避免使用任何非从这些原理得到的公式。然后，在一个程序中实现这些系数，该程序能够组装全局离散矩阵，并使用下面提供的测试套件对所需的性质进行数值验证。\n\n您必须在无量纲速度域 $[-U,U] \\times [-U,U]$ 中使用一个二维、均匀的笛卡尔网格，在 $v_x$ 方向上有 $N_x$ 个点，在 $v_y$ 方向上有 $N_y$ 个点。网格间距为 $h_x = \\frac{2U}{N_x - 1}$ 和 $h_y = \\frac{2U}{N_y - 1}$。未知量 $f$ 存储在网格节点 $(i,j)$ 上，其索引为 $i \\in \\{0,1,\\dots,N_x-1\\}$ 和 $j \\in \\{0,1,\\dots,N_y-1\\}$，对应的坐标为 $v_x(i) = -U + i h_x$ 和 $v_y(j) = -U + j h_y$。对于下述测试套件，请限制为对角扩散张量，形式为 $\\mathbf{D}(\\mathbf{v}) = \\mathrm{diag}(D_x(v_x,v_y), D_y(v_x,v_y))$，且 $D_x(v_x,v_y) \\ge 0$ 和 $D_y(v_x,v_y) \\ge 0$。您必须使用有限体积法或等效的守恒离散化方法跨网格面组装一个线性算子矩阵 $\\mathbf{A} \\in \\mathbb{R}^{(N_x N_y) \\times (N_x N_y)}$，使得：\n\n- 该算子是线性的、对称的，并且对于齐次 Neumann 边界条件（通过边界的扩散通量为零），其离散二次型是非负的。\n- 该算子是线性的、对称的，并且对于齐次 Dirichlet 边界条件（边界上 $f=0$），其离散二次型是严格为正的，除非是所有条目都恒等于零的平凡情况。\n- 模板只耦合跨面的最近邻，并且任何边界处理都必须与指定的边界条件类型一致。\n\n您的程序必须为每个测试用例构建 $\\mathbf{A}$，数值上验证对称性和半正定性，并生成所需的输出。\n\n请使用以下测试套件。所有速度都是无量纲的（无需物理单位），所有扩散系数也是无量纲且非负的：\n\n- 测试用例 1：$N_x=3$, $N_y=3$, $U=1$，齐次 Neumann 边界条件，$D_x(v_x,v_y)=1$，$D_y(v_x,v_y)=1$。\n- 测试用例 2：$N_x=4$, $N_y=3$, $U=2$，齐次 Neumann 边界条件，$D_x(v_x,v_y)=1+0.5\\,v_x^2$，$D_y(v_x,v_y)=1+0.3\\,v_y^2$。\n- 测试用例 3：$N_x=5$, $N_y=4$, $U=1.5$，齐次 Neumann 边界条件，$D_x(v_x,v_y)=\\begin{cases}10^{-8}, & |v_x|<0.2 \\text{ 且 } |v_y|<0.2\\\\ 1+0.5\\,v_x^2, & \\text{其他情况}\\end{cases}$，$D_y(v_x,v_y)=0.8+0.2\\,v_y^2$。\n- 测试用例 4：$N_x=3$, $N_y=3$, $U=1$，齐次 Dirichlet 边界条件，$D_x(v_x,v_y)=1$，$D_y(v_x,v_y)=1$。\n\n算法约束：\n\n- 通过对网格面的贡献求和来组装 $\\mathbf{A}$，以使生成的矩阵通过构造即为对称。\n- 对于齐次 Neumann 边界条件，在离散意义上强制通过区域边界的扩散通量为零。\n- 对于齐次 Dirichlet 边界条件，强制边界值为 $f=0$，并以保持对称性和正定性的方式合并边界贡献。\n- 在测试套件中将扩散张量视为对角张量，仅包含最近邻耦合；不要引入交叉导数耦合。\n\n验证要求：\n\n- 对称性检查：对于一个小的容差 $\\varepsilon$（请在您的实现中选择 $\\varepsilon$），确认 $\\|\\mathbf{A} - \\mathbf{A}^\\top\\|_\\infty \\le \\varepsilon$。\n- 半正定性检查：确认 $\\mathbf{A}$ 的所有特征值都大于或等于 $-\\varepsilon$。对于齐次 Dirichlet 情况，最小特征值应严格为正（大于 $\\varepsilon$），但您仍应使用相同的准则检查非负性，以提供单个布尔值结果。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。对于每个测试用例，按顺序输出两个布尔值：对称性检查布尔值，后跟半正定性检查布尔值。例如，输出必须是 $[\\text{sym}_1,\\text{psd}_1,\\text{sym}_2,\\text{psd}_2,\\text{sym}_3,\\text{psd}_3,\\text{sym}_4,\\text{psd}_4]$ 的形式，其中每个条目都是由编程语言打印的 $\\text{True}$ 或 $\\text{False}$。",
            "solution": "该问题要求在一个均匀笛卡尔网格上推导并实现一个离散扩散算子，该算子对于齐次 Neumann 边界条件是对称且半正定的，对于齐次 Dirichlet 边界条件是对称且正定的。连续算子是速度空间扩散项 $\\nabla_{\\mathbf{v}} \\cdot \\mathbf{D}(\\mathbf{v}) \\cdot \\nabla_{\\mathbf{v}} f$，其中 $\\mathbf{D}$ 是一个对称、半正定的张量。对于指定的测试用例，$\\mathbf{D}$ 是对角的。\n\n具有这些性质的标准离散算子是通过对散度形式的负值进行离散化得到的，即 $L(f) = -\\nabla_{\\mathbf{v}} \\cdot (\\mathbf{D}(\\mathbf{v}) \\nabla_{\\mathbf{v}} f)$。这个选择产生了一个特征值非负的算子，与“半正定”的要求一致。因此，我们将推导 $L(f)$ 的离散形式。\n\n推导将基于有限体积法，该方法植根于守恒原理。我们在围绕每个网格节点 $(v_x(i), v_y(j))$ 的一个小的控制体积 $V_{i,j}$ 上对算子 $L(f)$ 进行积分。网格由 $N_x \\times N_y$ 个节点组成，由 $i \\in \\{0, \\dots, N_x-1\\}$ 和 $j \\in \\{0, \\dots, N_y-1\\}$ 索引。对于一个内部节点，控制体积 $V_{i,j}$ 是矩形区域 $[v_x(i) - h_x/2, v_x(i) + h_x/2] \\times [v_y(j) - h_y/2, v_y(j) + h_y/2]$，其中 $h_x$ 和 $h_y$ 是网格间距。\n\n对 $L(f)$ 在 $V_{i,j}$ 上的积分应用散度定理可得：\n$$ \\int_{V_{i,j}} L(f) \\, d\\mathbf{v} = \\int_{V_{i,j}} -\\nabla_{\\mathbf{v}} \\cdot (\\mathbf{D} \\nabla_{\\mathbf{v}} f) \\, d\\mathbf{v} = - \\oint_{\\partial V_{i,j}} (\\mathbf{D} \\nabla_{\\mathbf{v}} f) \\cdot \\mathbf{n} \\, dS $$\n其中 $\\mathbf{n}$ 是指向控制体积边界 $\\partial V_{i,j}$ 外部的单位法向量。令 $\\mathbf{J} = -\\mathbf{D} \\nabla_{\\mathbf{v}} f$ 为扩散通量。该积分变为流出控制体积的净通量。\n\n左侧近似为 $(L f)_{i,j} \\cdot \\text{Area}(V_{i,j}) = (L f)_{i,j} h_x h_y$。右侧是跨越矩形控制体积四个面的通量之和。我们用它们的位置来表示这些面，例如，$i+1/2$ 表示节点 $i$ 和 $i+1$ 之间的面。由于 $\\mathbf{D}$ 是对角的，$\\mathbf{D} = \\text{diag}(D_x, D_y)$，通量分量为 $J_x = -D_x \\frac{\\partial f}{\\partial v_x}$ 和 $J_y = -D_y \\frac{\\partial f}{\\partial v_y}$。\n\n净通量是穿过东、西、南、北四个面的通量之和：\n$$ \\oint_{\\partial V_{i,j}} \\mathbf{J} \\cdot \\mathbf{n} \\, dS \\approx (J_x)_{i+1/2,j} h_y - (J_x)_{i-1/2,j} h_y + (J_y)_{i,j+1/2} h_x - (J_y)_{i,j-1/2} h_x $$\n单元面上的通量使用二阶中心差分来近似梯度：\n$$ (J_x)_{i+1/2,j} \\approx -D_x(v_{x,i+1/2}, v_{y,j}) \\frac{f_{i+1,j} - f_{i,j}}{h_x} $$\n这里 $f_{i,j}$ 是节点 $(i,j)$ 处 $f$ 的值，$D_x$ 在面中心 $(v_x(i)+h_x/2, v_y(j))$ 处求值。其他三个面也采用类似的近似。\n\n结合这些表达式，离散算子 $(\\mathbf{A}\\mathbf{f})_k$（其中 $k$ 是节点 $(i,j)$ 的全局索引）为：\n$$ (\\mathbf{A}\\mathbf{f})_k \\approx \\frac{1}{h_x h_y} \\left[ \\left( D_x \\frac{f_{i,j}-f_{i+1,j}}{h_x} \\right)_{i+1/2,j} h_y - \\left( D_x \\frac{f_{i-1,j}-f_{i,j}}{h_x} \\right)_{i-1/2,j} h_y + \\dots \\right] $$\n为 $f_{i,j}$ 及其最近邻（$f_{i\\pm1, j}$, $f_{i, j\\pm1}$）重排各项，得到矩阵 $\\mathbf{A}$ 的 5 点模板系数。设 $k_1$ 是 $(i,j)$ 的索引，$k_2$ 是 $(i+1,j)$ 的索引。它们之间的耦合产生于跨共享面的通量。系数为 $c_{i+1/2,j} = \\frac{D_x(v_{x,i+1/2}, v_{y,j})}{h_x^2}$。\n矩阵元素则为：\n\\begin{itemize}\n    \\item 节点 $(i,j)$ 的对角元：\n    $$ A_{k,k} = \\frac{D_{x,i+1/2,j} + D_{x,i-1/2,j}}{h_x^2} + \\frac{D_{y,i,j+1/2} + D_{y,i,j-1/2}}{h_y^2} $$\n    \\item 邻居 $(i+1,j)$ 的非对角元：\n    $$ A_{k,k+1} = -\\frac{D_{x,i+1/2,j}}{h_x^2} $$\n    \\item 邻居 $(i-1,j)$ 的非对角元：\n    $$ A_{k,k-1} = -\\frac{D_{x,i-1/2,j}}{h_x^2} $$\n    \\item 邻居 $(i,j+1)$ 的非对角元：\n    $$ A_{k,k+N_x} = -\\frac{D_{y,i,j+1/2}}{h_y^2} $$\n    \\item 邻居 $(i,j-1)$ 的非对角元：\n    $$ A_{k,k-N_x} = -\\frac{D_{y,i,j-1/2}}{h_y^2} $$\n\\end{itemize}\n此形式假设所有邻居都在网格内部。边界条件通过在边界处修改这些公式来处理。\n\n**对称性和半正定性**\n此构造在设计上是对称的。耦合节点 $k$ 和节点 $l$ 的矩阵元素 $A_{k,l}$ 由它们之间面的性质决定。由于决定耦合 $A_{l,k}$ 的是同一个面，我们有 $A_{k,l} = A_{l,k}$，因此 $\\mathbf{A} = \\mathbf{A}^\\top$。\n\n半正定性可以通过考察二次型 $\\mathbf{f}^\\top \\mathbf{A} \\mathbf{f}$ 来证明。通过离散分部求和（这是格林第一恒等式的代数等价形式），这个二次型可以表示为在所有网格面上的求和：\n$$ \\mathbf{f}^\\top \\mathbf{A} \\mathbf{f} = \\sum_{j=0}^{N_y-1}\\sum_{i=0}^{N_x-2} \\frac{D_{x,i+1/2,j}}{h_x^2} (f_{i+1,j} - f_{i,j})^2 + \\sum_{j=0}^{N_y-2}\\sum_{i=0}^{N_x-1} \\frac{D_{y,i,j+1/2}}{h_y^2} (f_{i,j+1} - f_{i,j})^2 $$\n由于 $D_x, D_y \\geq 0$，此和中的每一项都是非负的。因此，对于任何向量 $\\mathbf{f}$，都有 $\\mathbf{f}^\\top \\mathbf{A} \\mathbf{f} \\geq 0$，这就是半正定矩阵的定义。\n\n**边界条件**\n1.  **齐次 Neumann**：此条件意味着在区域边界处的通量为零（$\\mathbf{J} \\cdot \\mathbf{n} = 0$）。在我们的有限体积格式中，这通过不包括任何来自位于边界上的面的通量贡献来自然实现。例如，对于左边界上的节点 $(0,j)$，涉及在 $i=-1/2$ 处通量的项被省略。所得矩阵保持了对称、半正定的结构。二次型为零当且仅当跨面的所有差值 $(f_k - f_l)$ 都为零，这意味着 $f$ 必须是一个常数向量。因此，$\\mathbf{A}$ 有一个由全一向量张成的一维零空间，以及一个相应的零特征值。\n\n2.  **齐次 Dirichlet**：此条件强制所有边界节点上的 $f=0$。我们构造一个全局矩阵 $\\mathbf{A} \\in \\mathbb{R}^{(N_x N_y) \\times (N_x N_y)}$。我们首先像处理 Neumann 条件一样组装矩阵。然后，为对每个边界节点索引 $k$ 强制 $f_k=0$，我们修改矩阵以保持对称性。对于每个这样的 $k$，我们将第 $k$ 行和第 $k$ 列设为零，并将对角元素 $A_{k,k}$ 设为 $1$。这将边界节点与内部分离开来，边界节点得到的方程为 $f_k=0$。整体矩阵保持对称。对应于内部节点的子矩阵是正定的：如果二次型为零，所有内部的 $f_i$ 必须等于一个常数 $c$。但由于内部节点与 $f=0$ 的边界节点耦合，二次型中诸如 $(f_{\\text{interior}} - f_{\\text{boundary}})^2 = (c-0)^2$ 的项也必须为零，这意味着 $c=0$。因此，只有 $\\mathbf{f}=\\mathbf{0}$ 才能使 $\\mathbf{f}^\\top \\mathbf{A} \\mathbf{f}=0$ 成立，从而证明了内部问题的正定性。完整矩阵的特征值要么是 $1$（来自修改后的边界行/列），要么是内部问题的特征值，而后者都是严格为正的。因此，完整矩阵是正定的。\n\n以下实现遵循此推导。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, assembles, and verifies the properties of a discrete Fokker-Planck\n    diffusion operator for a series of test cases.\n    \"\"\"\n    \n    test_cases = [\n        {\n            'Nx': 3, 'Ny': 3, 'U': 1.0, 'BC': 'Neumann',\n            'Dx_func': lambda vx, vy: 1.0 + 0.0 * vx,  # Use vx to depend on it\n            'Dy_func': lambda vx, vy: 1.0 + 0.0 * vy\n        },\n        {\n            'Nx': 4, 'Ny': 3, 'U': 2.0, 'BC': 'Neumann',\n            'Dx_func': lambda vx, vy: 1.0 + 0.5 * vx**2,\n            'Dy_func': lambda vx, vy: 1.0 + 0.3 * vy**2\n        },\n        {\n            'Nx': 5, 'Ny': 4, 'U': 1.5, 'BC': 'Neumann',\n            'Dx_func': lambda vx, vy: 1e-8 if np.abs(vx)  0.2 and np.abs(vy)  0.2 else 1.0 + 0.5 * vx**2,\n            'Dy_func': lambda vx, vy: 0.8 + 0.2 * vy**2\n        },\n        {\n            'Nx': 3, 'Ny': 3, 'U': 1.0, 'BC': 'Dirichlet',\n            'Dx_func': lambda vx, vy: 1.0 + 0.0 * vx,\n            'Dy_func': lambda vx, vy: 1.0 + 0.0 * vy\n        },\n    ]\n\n    results = []\n    # Machine precision tolerance for numerical checks\n    epsilon = 1e-12\n\n    for case in test_cases:\n        Nx, Ny, U, BC = case['Nx'], case['Ny'], case['U'], case['BC']\n        Dx_func, Dy_func = case['Dx_func'], case['Dy_func']\n\n        # 1. Setup Grid\n        total_nodes = Nx * Ny\n        # Handle case with single point in a direction\n        hx = (2.0 * U / (Nx - 1)) if Nx > 1 else 0.0\n        hy = (2.0 * U / (Ny - 1)) if Ny > 1 else 0.0\n        \n        vx_nodes = np.linspace(-U, U, Nx)\n        vy_nodes = np.linspace(-U, U, Ny)\n\n        # 2. Assemble Matrix A\n        # The matrix represents the operator -div(D grad(f))\n        A = np.zeros((total_nodes, total_nodes))\n\n        # Helper for 2D to 1D index mapping\n        def k_map(i, j):\n            return i + j * Nx\n\n        # Assemble based on face contributions to guarantee symmetry\n        # Horizontal faces (coupling in x)\n        if Nx > 1:\n            for j in range(Ny):\n                for i in range(Nx - 1):\n                    k1 = k_map(i, j)\n                    k2 = k_map(i + 1, j)\n\n                    # Properties at the face center\n                    vx_face = vx_nodes[i] + hx / 2.0\n                    vy_face = vy_nodes[j]\n                    D_val = Dx_func(vx_face, vy_face)\n                    \n                    coeff = D_val / (hx * hx)\n                    \n                    A[k1, k1] += coeff\n                    A[k2, k2] += coeff\n                    A[k1, k2] -= coeff\n                    A[k2, k1] -= coeff\n\n        # Vertical faces (coupling in y)\n        if Ny > 1:\n            for i in range(Nx):\n                for j in range(Ny - 1):\n                    k1 = k_map(i, j)\n                    k2 = k_map(i, j + 1)\n                    \n                    # Properties at the face center\n                    vx_face = vx_nodes[i]\n                    vy_face = vy_nodes[j] + hy / 2.0\n                    D_val = Dy_func(vx_face, vy_face)\n\n                    coeff = D_val / (hy * hy)\n\n                    A[k1, k1] += coeff\n                    A[k2, k2] += coeff\n                    A[k1, k2] -= coeff\n                    A[k2, k1] -= coeff\n        \n        # 3. Apply Boundary Conditions\n        if BC == 'Dirichlet':\n            boundary_indices = set()\n            for j in range(Ny):\n                boundary_indices.add(k_map(0, j))\n                boundary_indices.add(k_map(Nx - 1, j))\n            for i in range(Nx):\n                boundary_indices.add(k_map(i, 0))\n                boundary_indices.add(k_map(i, Ny - 1))\n            \n            for k in boundary_indices:\n                A[k, :] = 0.0\n                A[:, k] = 0.0\n                A[k, k] = 1.0\n\n        # 4. Verify Properties\n        # Symmetry check\n        is_symmetric = np.linalg.norm(A - A.T, ord=np.inf) = epsilon\n\n        # Positive Semidefiniteness check\n        # Use eigvalsh as the matrix is constructed to be symmetric\n        eigenvalues = np.linalg.eigvalsh(A)\n        min_eigenvalue = np.min(eigenvalues)\n        is_positive_semidefinite = min_eigenvalue >= -epsilon\n        \n        results.extend([is_symmetric, is_positive_semidefinite])\n\n    # Final Output Formatting\n    print(f\"[{','.join(map(str, results))}]\")\n\n\nsolve()\n```"
        },
        {
            "introduction": "许多物理问题，尤其是在等离子体物理中，具有球对称性，使得球坐标成为描述速度空间的自然选择。然而，这种选择在原点（$v=0$）引入了一个坐标奇点，需要精细的数值处理以避免解的发散。本练习提供了一个在原点处制定和实施边界条件的实践机会，以确保解的正则性和数值方案的稳定性。",
            "id": "3981954",
            "problem": "考虑聚变等离子体中单个物种的球对称速度分布函数 $f(v,t)$，该函数受各向同性碰撞的影响。其在速度空间中的演化由速度空间连续性方程以及碰撞通量的本构关系共同决定。使用以下基本原理：\n\n- 速度空间中的粒子数守恒意味着球对称分布的速度空间连续性定律：\n$$\n\\frac{\\partial f}{\\partial t} + \\frac{1}{v^2} \\frac{\\partial}{\\partial v} \\left( v^2 J_v \\right) = 0\n$$\n其中 $J_v$ 是速度空间中的径向通量。\n\n- 各向同性 Fokker–Planck 碰撞通量的一个经过充分检验的表达式为\n$$\nJ_v = A(v)\\, f + D(v)\\, \\frac{\\partial f}{\\partial v}\n$$\n其中 $A(v)$ 是拖拽（摩擦）系数，$D(v)$ 是扩散系数。\n\n你的任务是，通过施加 $\\frac{\\partial f}{\\partial v}(0)=0$ 并确保通量在 $v=0$ 处保持有界，来为 $v=0$ 处制定并实施边界条件，以避免奇点并维持各向同性碰撞解的正则性。你必须以纯粹的数学和计算方式完成此任务，不假设任何物理单位：所有量均为无量纲。在均匀、以单元为中心的速度网格上设计一个类有限体积离散化方法，并计算用以量化边界条件是否避免了奇点的诊断指标。\n\n网格和离散化规范：\n\n- 设速度网格为 $v_i = i\\, \\Delta v$，其中整数 $i \\in \\{0,1,\\dots,N-1\\}$，且 $\\Delta v = v_{\\max}/(N-1)$。\n\n- 定义面元位置为 $v_{i+\\frac{1}{2}} = \\frac{v_i + v_{i+1}}{2}$，其中 $i \\in \\{0,1,\\dots,N-2\\}$。\n\n- 对内部面元，使用二阶中心量近似面元中心的通量：\n$$\nF_{i+\\frac{1}{2}} = v_{i+\\frac{1}{2}}^2 \\left[ A(v_{i+\\frac{1}{2}})\\, f_{i+\\frac{1}{2}} + D(v_{i+\\frac{1}{2}})\\, \\left( \\frac{f_{i+1} - f_i}{\\Delta v} \\right) \\right]\n$$\n其中 $f_{i+\\frac{1}{2}} = \\frac{f_i + f_{i+1}}{2}$。\n\n- 在 $v=0$ 处实施边界条件，以强制执行约束 $\\frac{\\partial f}{\\partial v}(0)=0$ 和边界通量有界。实施时必须确保离散算子不会产生奇异值，并且边界上的数值通量保持有限。\n\n- 将内部单元中心 $i \\ge 1$ 处的离散碰撞算子定义为\n$$\nQ_i = \\frac{F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}}{v_i^2 \\, \\Delta v}\n$$\n\n需要计算的诊断指标：\n\n- 边界上的有界通量指标 $M_F = \\left| F_{-\\frac{1}{2}} \\right|$。\n\n- 在 $v=0$ 处用于数值通量的正则导数指标 $M_D = \\left| \\left. \\frac{\\partial f}{\\partial v} \\right|_{v=0} \\right|$。\n\n- 近边界算子指标 $M_Q = \\left| Q_1 \\right|$。\n\n你的程序必须构建速度网格，计算系数 $A(v)$ 和 $D(v)$，使用上述离散化方法构建面元通量 $F_{i+\\frac{1}{2}}$，在 $v=0$ 处应用与约束条件 $\\frac{\\partial f}{\\partial v}(0)=0$ 和有界通量一致的边界条件，并计算三个指标 $M_F$、$M_D$ 和 $M_Q$。\n\n测试套件：\n\n实现以下四个测试用例，所有单位均为无量纲：\n\n1) $N=101$, $v_{\\max}=5.0$, $A(v) = -\\nu v$ 其中 $\\nu=0.3$, $D(v) = D_0$ 为常数，其中 $D_0 = 0.1$, 以及 $f(v) = \\exp(-\\alpha v^2)$ 其中 $\\alpha = 1.0$。\n\n2) $N=3$, $v_{\\max}=1.0$, $A(v) = -\\nu v$ 其中 $\\nu=0.3$, $D(v) = D_0$ 为常数，其中 $D_0 = 0.1$, 以及 $f(v) = \\exp(-\\alpha v^2)$ 其中 $\\alpha = 0.5$。\n\n3) $N=101$, $v_{\\max}=5.0$, $A(v) = -\\nu v$ 其中 $\\nu=1.0$, $D(v) = D_0$ 为常数，其中 $D_0 = 10^{-6}$, 以及 $f(v) = \\exp(-\\alpha v^2)$ 其中 $\\alpha = 1.0$。\n\n4) $N=51$, $v_{\\max}=5.0$, $A(v) = -\\nu v$ 其中 $\\nu=0.1$, $D(v) = D_0 (1 + v^2)$ 其中 $D_0 = 0.5$, 以及 $f(v) = \\exp(-\\alpha v^2)$ 其中 $\\alpha = 0.2$。\n\n要求的最终输出格式：\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[M_{F}^{(1)}, M_{D}^{(1)}, M_{Q}^{(1)}, M_{F}^{(2)}, M_{D}^{(2)}, M_{Q}^{(2)}, M_{F}^{(3)}, M_{D}^{(3)}, M_{Q}^{(3)}, M_{F}^{(4)}, M_{D}^{(4)}, M_{Q}^{(4)}]$，其中上标表示测试用例索引。所有值都必须是无量纲浮点数。不允许有其他输出。",
            "solution": "该问题要求为球速度坐标系中的各向同性 Fokker–Planck 碰撞算子制定并实施一种数值边界条件，旨在确保解在原点 $v=0$ 处的正则性。然后，我们被要求计算一组诊断指标，用以量化该边界条件在几个测试用例中的属性。\n\n球对称速度分布函数 $f(v,t)$ 的控制方程是速度空间连续性方程：\n$$\n\\frac{\\partial f}{\\partial t} + \\frac{1}{v^2} \\frac{\\partial}{\\partial v} \\left( v^2 J_v \\right) = 0\n$$\n其中 $v$ 是速率（速度的模，$v \\ge 0$），$J_v$ 是速度空间中的碰撞通量。问题提供了该通量的标准 Fokker–Planck 表达式：\n$$\nJ_v = A(v) f(v) + D(v) \\frac{\\partial f}{\\partial v}\n$$\n此处，$A(v)$ 是拖拽系数，$D(v)$ 是扩散系数。连续性方程中的 $v^2$ 项源于从笛卡尔坐标系到球坐标系在速度空间中变换的雅可比行列式。该项在 $v=0$ 处引入了一个坐标奇点，必须小心处理以维持物理上和数学上正则的解。\n\n让我们将总通量定义为 $F(v) = v^2 J_v$。连续性方程可以写成 $\\frac{\\partial f}{\\partial t} = - \\frac{1}{v^2} \\frac{\\partial F}{\\partial v}$。为使右侧在 $v \\to 0$ 时为有限值，我们要求 $\\frac{\\partial F}{\\partial v}$ 的消失速度快于 $v^2$。$F(v)$ 在 $v=0$ 附近的泰勒展开为 $F(v) = F(0) + F'(0)v + \\frac{1}{2}F''(0)v^2 + O(v^3)$。为使项 $\\frac{1}{v^2} \\frac{\\partial F}{\\partial v} = \\frac{1}{v^2}(F'(0) + F''(0)v + O(v^2))$ 表现良好，我们必须有 $F'(0) = 0$。为使完整算子非奇异，可以证明我们必须在 $v \\to 0$ 时有 $F(v) \\sim O(v^3)$。这意味着以下条件：\n$$\n\\lim_{v \\to 0} F(v) = 0, \\quad \\lim_{v \\to 0} \\frac{\\partial F}{\\partial v} = 0, \\quad \\text{and} \\quad \\lim_{v \\to 0} \\frac{\\partial^2 F}{\\partial v^2} = 0\n$$\n从物理角度看，粒子群的分布函数 $f(v)$ 必须是速度的光滑函数。对于一个球对称函数，原点的光滑性要求其关于任何单个笛卡尔速度分量的所有奇次导数都为零。这意味着如果将 $f(v)$ 扩展到负的 $v$ 值，它必须是 $v$ 的偶函数，从而得出在原点处关于速率 $v$ 的导数为零的条件：\n$$\n\\left. \\frac{\\partial f}{\\partial v} \\right|_{v=0} = 0\n$$\n让我们用这个条件来检验通量 $J_v$。拖拽和扩散系数在 $v=0$ 附近通常表现为 $A(v) \\sim v$ 和 $D(v) \\sim \\text{const}$。在 $\\left. \\frac{\\partial f}{\\partial v} \\right|_{v=0} = 0$ 的条件下，$J_v=A(v) f + D(v) \\frac{\\partial f}{\\partial v}$ 中的两项在 $v=0$ 处都为零，因此 $J_v(0)=0$。这意味着总通量 $F(v) = v^2 J_v$ 在 $v=0$ 处为零，与我们的要求一致。\n\n现在，我们将这些连续性原理转化为离散的数值格式。问题指定了一个以单元为中心的网格 $v_i = i \\Delta v$，其中 $i \\in \\{0, 1, \\dots, N-1\\}$。第一个单元的中心在 $v_0 = 0$。在有限体积法中，第一个单元（单元 0）将被定义在一个控制体积上，例如 $[v_{-1/2}, v_{1/2}]$。根据网格定义，面元位置的自然选择是 $v_{i+1/2} = (i+1/2)\\Delta v$，这意味着单元 0 左侧的面元位于 $v_{-1/2}=0$（因为 $v$ 必须为非负），而其右侧的面元位于 $v_{1/2}=\\Delta v/2$。\n\n在单元中心 $v_i$ 处，碰撞算子的离散形式由下式给出：\n$$\nQ_i = \\frac{F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}}{v_i^2 \\, \\Delta v}\n$$\n由于分母中存在 $v_0^2=0$，该表达式在 $i=0$ 处有问题。问题的表述巧妙地避免了计算 $Q_0$，而是要求提供与边界和第一个内部单元 $Q_1$ 相关的指标。\n\n我们的任务是制定边界条件，这包括定义边界上的通量 $F_{-1/2}$ 以及原点处导数的数值表示。\n1.  **有界通量指标 ($M_F$)**: 连续理论要求总通量 $F(v)$ 在 $v=0$ 时为零。我们通过将边界 $v=0$ 处的离散通量设置为零来直接实现这一原理。该边界面对应于索引 $i=-1/2$。因此，我们设定 $F_{-1/2} = 0$。因此，指标 $M_F = |F_{-1/2}|$ 根据构造恒为零。\n2.  **正则导数指标 ($M_D$)**: 问题要求施加正则性条件 $\\frac{\\partial f}{\\partial v}(0)=0$。这个条件是推导 $F(0)=0$ 的基础。当报告用于*数值通量*的此导数值的诊断指标时，最直接的解释是陈述该格式所基于的数值。由于我们明确地施加了此条件，其数值被精确地取为零。因此，指标 $M_D = |\\left. \\frac{\\partial f}{\\partial v} \\right|_{v=0}|$ 也恒为零。\n3.  **近边界算子指标 ($M_Q$)**: 该指标 $M_Q = |Q_1|$ 测试了离散算子在第一个内部网格点 $v_1 = \\Delta v$ 处的行为。其计算需要单元 1 两个面上的通量，即 $F_{1/2}$ 和 $F_{3/2}$。$Q_1$ 的公式为：\n    $$\n    Q_1 = \\frac{F_{3/2} - F_{1/2}}{v_1^2 \\, \\Delta v}\n    $$\n    我们可以使用为内部面元提供的公式来计算这些通量：\n    $$\n    F_{i+\\frac{1}{2}} = v_{i+\\frac{1}{2}}^2 \\left[ A(v_{i+\\frac{1}{2}})\\, f_{i+\\frac{1}{2}} + D(v_{i+\\frac{1}{2}})\\, \\left( \\frac{f_{i+1} - f_i}{\\Delta v} \\right) \\right]\n    $$\n    其中 $f_{i+\\frac{1}{2}} = \\frac{f_i + f_{i+1}}{2}$。此公式适用于 $i=0$（求 $F_{1/2}$）和 $i=1$（求 $F_{3/2}$）。\n\n每个测试用例的计算过程如下：\n1.  设置网格参数 $N$ 和 $v_{\\max}$，并计算 $\\Delta v = v_{\\max}/(N-1)$。\n2.  定义速度网格 $v_i = i \\Delta v$，其中 $i \\in \\{0, \\dots, N-1\\}$。\n3.  为特定情况定义函数 $A(v)$、$D(v)$ 和 $f(v)$。\n4.  计算 $f_i = f(v_i)$，其中 $i=0, 1, 2$。我们只需要前三个点来计算 $Q_1$。\n5.  设置指标 $M_F = 0.0$ 和 $M_D = 0.0$。\n6.  计算 $F_{1/2}$（使用 $i=0$）：\n    -   $v_{1/2} = (v_0+v_1)/2 = \\Delta v/2$。\n    -   $f_{1/2} = (f_0+f_1)/2$。\n    -   计算 $A_{1/2} = A(v_{1/2})$ 和 $D_{1/2} = D(v_{1/2})$。\n    -   计算 $F_{1/2} = v_{1/2}^2 [ A_{1/2} f_{1/2} + D_{1/2} (f_1-f_0)/\\Delta v ]$。\n7.  计算 $F_{3/2}$（使用 $i=1$）：\n    -   $v_{3/2} = (v_1+v_2)/2 = 3\\Delta v/2$。\n    -   $f_{3/2} = (f_1+f_2)/2$。\n    -   计算 $A_{3/2} = A(v_{3/2})$ 和 $D_{3/2} = D(v_{3/2})$。\n    -   计算 $F_{3/2} = v_{3/2}^2 [ A_{3/2} f_{3/2} + D_{3/2} (f_2-f_1)/\\Delta v ]$。\n8.  计算 $Q_1 = (F_{3/2} - F_{1/2})/(v_1^2 \\Delta v)$，其中 $v_1 = \\Delta v$。\n9.  该案例的最终指标是 $M_Q = |Q_1|$。\n10. 收集三个指标 $(M_F, M_D, M_Q)$ 并对所有测试用例重复此过程。\n\n此过程遵循了原点正则性的物理原理，同时一致地应用了指定的数值离散化方法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating diagnostic metrics for the Fokker-Planck\n    collision operator boundary conditions for four test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1\n        {'N': 101, 'v_max': 5.0,\n         'A_func': lambda v, nu=0.3: -nu * v,\n         'D_func': lambda v, D0=0.1: D0,\n         'f_func': lambda v, alpha=1.0: np.exp(-alpha * v**2)},\n        # Case 2\n        {'N': 3, 'v_max': 1.0,\n         'A_func': lambda v, nu=0.3: -nu * v,\n         'D_func': lambda v, D0=0.1: D0,\n         'f_func': lambda v, alpha=0.5: np.exp(-alpha * v**2)},\n        # Case 3\n        {'N': 101, 'v_max': 5.0,\n         'A_func': lambda v, nu=1.0: -nu * v,\n         'D_func': lambda v, D0=1e-6: D0,\n         'f_func': lambda v, alpha=1.0: np.exp(-alpha * v**2)},\n        # Case 4\n        {'N': 51, 'v_max': 5.0,\n         'A_func': lambda v, nu=0.1: -nu * v,\n         'D_func': lambda v, D0=0.5: D0 * (1.0 + v**2),\n         'f_func': lambda v, alpha=0.2: np.exp(-alpha * v**2)},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        N = case['N']\n        v_max = case['v_max']\n        A_func = case['A_func']\n        D_func = case['D_func']\n        f_func = case['f_func']\n\n        # Step 1: Set up the grid\n        # Avoid division by zero if N=1, though test cases have N>1\n        if N > 1:\n            dv = v_max / (N - 1)\n        else:\n            dv = 0.0\n            \n        # v_i = i * dv for i in {0, 1, ..., N-1}\n        # We only need the first 3 points (i=0, 1, 2) to compute Q_1\n        v = np.array([0.0, 1.0 * dv, 2.0 * dv])\n\n        # Step 2: Evaluate f(v) on the grid points\n        f = f_func(v)\n        f_0, f_1, f_2 = f[0], f[1], f[2]\n\n        # Step 3: Compute diagnostic metrics\n        # M_F: Bounded-flux metric at the boundary face v=0\n        # The physical condition F(0)=0 is imposed by setting F_{-1/2}=0.\n        M_F = 0.0\n\n        # M_D: Regular-derivative metric at v=0\n        # The condition df/dv(0)=0 is imposed. The metric is the numerical value used.\n        M_D = 0.0\n\n        # M_Q: Near-boundary operator metric |Q_1|\n        \n        # Calculate flux F_{1/2} (face between cells 0 and 1)\n        v_half = (v[0] + v[1]) / 2.0\n        f_half = (f_0 + f_1) / 2.0\n        df_dv__half = (f_1 - f_0) / dv if dv != 0 else 0.0\n        A_half = A_func(v_half)\n        D_half = D_func(v_half)\n        F_half = v_half**2 * (A_half * f_half + D_half * df_dv__half)\n\n        # Calculate flux F_{3/2} (face between cells 1 and 2)\n        v_three_half = (v[1] + v[2]) / 2.0\n        f_three_half = (f_1 + f_2) / 2.0\n        df_dv_three_half = (f_2 - f_1) / dv if dv != 0 else 0.0\n        A_three_half = A_func(v_three_half)\n        D_three_half = D_func(v_three_half)\n        F_three_half = v_three_half**2 * (A_three_half * f_three_half + D_three_half * df_dv_three_half)\n\n        # Calculate Q_1\n        v1_sq_dv = v[1]**2 * dv\n        if v1_sq_dv == 0:\n            # This case happens if dv=0 (N=1) or if v[1]=0.\n            # Avoid division by zero. A well-behaved operator would be 0.\n            Q_1 = 0.0\n        else:\n            Q_1 = (F_three_half - F_half) / v1_sq_dv\n        \n        M_Q = np.abs(Q_1)\n\n        results.extend([M_F, M_D, M_Q])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "高阶数值格式因其高精度而备受青睐，但它们在保持物理守恒律（如分布函数的非负性）方面常常面临挑战。本练习将引导您实现通量修正输运（FCT）方法，这是一种通过巧妙地混合低阶和高阶格式来强制执行解的非负性的强大技术。掌握FCT对于开发能够处理Fokker-Planck方程中常见的刚性和守恒性挑战的数值求解器至关重要。",
            "id": "3981932",
            "problem": "你需要为源于 Fokker–Planck 碰撞算子的碰撞弛豫模型，在一位速度空间中实现一个单步守恒的有限体积更新。该更新需使用通量修正输运 (Flux-Corrected Transport, FCT) 限制器，以在最小化数值扩散的同时保持分布函数的正定性。其控制演化方程以守恒形式写为分布函数 $f(v,t)$ 在速度空间上的连续性方程，\n$$\n\\frac{\\partial f}{\\partial t} + \\frac{\\partial J}{\\partial v} = 0\n$$\n其中包含一个具有物理动机的碰撞通量\n$$\nJ(v,t) = -D(v)\\,\\frac{\\partial f}{\\partial v} - F(v)\\,f\n$$\n其中 $D(v)$ 是速度空间扩散系数，$F(v)$ 是拖拽系数。有限体积离散化建立在均匀速度网格 $v_i \\in [v_{\\min}, v_{\\max}]$ 上，其中 $i \\in \\{0,\\dots,N-1\\}$，网格宽度为 $\\Delta v$。在 $v=v_{\\min}$ 和 $v=v_{\\max}$ 处施加无通量边界条件，即 $J(v_{\\min},t)=0$ 和 $J(v_{\\max},t)=0$。未知量是网格平均值 $f_i^n \\approx f(v_i,t^n)$。\n\n从基本定律出发：\n- 粒子数守恒意味着速度空间中的连续性方程，当边界通量为零时，$f$ 的总积分保持不变。\n- 一维碰撞 Fokker–Planck 形式允许分解为一个与 $\\frac{\\partial f}{\\partial v}$ 成正比的扩散项和一个与 $f$ 成正比的漂移项。\n\n使用具有各向同性系数的物理上合理的碰撞模型\n$$\nD(v) = D_0, \\quad F(v) = \\nu\\,v\n$$\n其中 $D_0$ 和 $\\nu$ 是常数。\n\n以两种方式离散化每个网格交界面 $v_{i+\\frac{1}{2}}$ 处的面通量：\n- 一个低阶保正通量 $J_{\\text{lo}}$，其对流部分采用一阶迎风格式定义，扩散部分采用两点中心差分定义。\n- 一个高阶通量 $J_{\\text{hi}}$，其对流部分采用中心平均定义，扩散部分采用两点中心差分定义。\n\n令 $\\lambda = \\Delta t / \\Delta v$。使用每种通量的显式有限体积更新给出\n$$\nf_i^{n+1} = f_i^n - \\lambda \\left( J_{i+\\frac{1}{2}} - J_{i-\\frac{1}{2}} \\right)\n$$\n其中 $J_{-\\frac{1}{2}} = 0$ 和 $J_{N-\\frac{1}{2}} = 0$ 用于施加无通量边界。按如下方式构建通量修正输运 (FCT) 修正步骤：\n1. 计算低阶更新 $f_{\\text{lo}}^{n+1}$。\n2. 计算高阶更新 $f_{\\text{hi}}^{n+1}$。\n3. 形成反扩散面通量差 $\\delta J_{i+\\frac{1}{2}} = J_{\\text{hi},\\, i+\\frac{1}{2}} - J_{\\text{lo},\\, i+\\frac{1}{2}}$。\n4. 限制每个面上的修正，以防止任何网格在加上总修正后变为负值，同时保持守恒性。使用一个限制器，该限制器仅通过其可用容量 $f_{\\text{lo},i}^{n+1}$ 来约束损失单元（即反扩散通量将从中移除质量的单元）。对于正定性，增益不受约束。将受限的修正作为通量应用，以使净修正既守恒又局部。\n\n单步输出 $f_{\\text{fct}}^{n+1}$ 必须非负，在数值舍入误差范围内总质量守恒，并且在满足正定性约束的前提下尽可能接近 $f_{\\text{hi}}^{n+1}$。\n\n您的程序必须实现此算法，并报告每个测试用例的以下指标：\n- 正定性检查（布尔值）：是否对所有 $i$ 都有 $f_{\\text{fct},i}^{n+1} \\ge 0$。\n- 相对质量误差（浮点数）：$\\left| \\sum_i f_{\\text{fct},i}^{n+1}\\,\\Delta v - \\sum_i f_i^n\\,\\Delta v \\right| \\big/ \\left( \\sum_i f_i^n\\,\\Delta v \\right)$，无量纲。\n- 扩散比率（浮点数）：$\\lVert f_{\\text{hi}}^{n+1} - f_{\\text{fct}}^{n+1} \\rVert_2 \\big/ \\lVert f_{\\text{hi}}^{n+1} - f_{\\text{lo}}^{n+1} \\rVert_2$，无量纲，约定如果分母为零，则返回 $0$。\n\n物理单位：\n- 速度 $v$ 的单位是 $\\mathrm{m/s}$，时间 $t$ 的单位是 $\\mathrm{s}$，分布 $f$ 的单位是 $\\mathrm{m^{-3}\\,(m/s)^{-1}}$。按规定将所有输出报告为无量纲的浮点数或布尔值。\n\n角度单位不适用。\n\n不允许使用百分比；相对质量误差必须是小数。\n\n使用以下参数实现该步骤。对每个案例，执行恰好一个显式时间步长 $\\Delta t$ 并计算所需的指标。\n\n测试组：\n- 案例 1 (正常路径，麦克斯韦分布):\n  - 网格：$N=200$, $v_{\\min}=-6$, $v_{\\max}=6$。\n  - 碰撞：$\\nu=0.5$, $D_0=0.1$。\n  - 时间步长：$\\Delta t=0.001$。\n  - 热速度：$v_{\\text{th}}=1.0$。\n  - 初始分布：麦克斯韦分布 $f(v,0)=\\dfrac{n_0}{\\sqrt{\\pi}\\,v_{\\text{th}}}\\exp\\!\\left(-\\dfrac{v^2}{v_{\\text{th}}^2}\\right)$，其中 $n_0=1.0$。\n\n- 案例 2 (带凹口的陡峭梯度):\n  - 网格：$N=200$, $v_{\\min}=-6$, $v_{\\max}=6$。\n  - 碰撞：$\\nu=1.0$, $D_0=0.2$。\n  - 时间步长：$\\Delta t=0.003$。\n  - 热速度：$v_{\\text{th}}=1.0$。\n  - 初始分布：$f(v,0)=\\dfrac{n_0}{\\sqrt{\\pi}\\,v_{\\text{th}}}\\exp\\!\\left(-\\dfrac{v^2}{v_{\\text{th}}^2}\\right)\\left[1-0.4\\,\\exp\\!\\left(-\\dfrac{(v-2)^2}{0.2^2}\\right)\\right]$，其中 $n_0=1.0$。\n\n- 案例 3 (近真空尾部):\n  - 网格：$N=200$, $v_{\\min}=-6$, $v_{\\max}=6$。\n  - 碰撞：$\\nu=0.3$, $D_0=0.05$。\n  - 时间步长：$\\Delta t=0.002$。\n  - 热速度：$v_{\\text{th}}=1.0$。\n  - 初始分布：$f(v,0)=\\dfrac{n_0}{\\sqrt{\\pi}\\,v_{\\text{th}}}\\exp\\!\\left(-\\dfrac{v^2}{v_{\\text{th}}^2}\\right)+5\\times 10^{-5}\\,\\exp\\!\\left(-\\dfrac{(v-4)^2}{0.3^2}\\right)$，其中 $n_0=10^{-3}$。\n\n- 案例 4 (近稳定时间步长，双峰分布):\n  - 网格：$N=80$, $v_{\\min}=-6$, $v_{\\max}=6$。\n  - 碰撞：$\\nu=0.8$, $D_0=0.5$。\n  - 时间步长：$\\Delta t=0.02$。\n  - 热速度：$v_{\\text{th}}=0.8$。\n  - 初始分布：$f(v,0)=\\dfrac{0.5}{\\sqrt{\\pi}\\,v_{\\text{th}}}\\exp\\!\\left(-\\dfrac{(v-2)^2}{v_{\\text{th}}^2}\\right)+\\dfrac{0.5}{\\sqrt{\\pi}\\,v_{\\text{th}}}\\exp\\!\\left(-\\dfrac{(v+2)^2}{v_{\\text{th}}^2}\\right)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列\n$$\n[\\text{pos}_1,\\text{err}_1,\\text{ratio}_1, \\text{pos}_2,\\text{err}_2,\\text{ratio}_2, \\text{pos}_3,\\text{err}_3,\\text{ratio}_3, \\text{pos}_4,\\text{err}_4,\\text{ratio}_4]\n$$\n每个 $\\text{pos}_k$ 是一个布尔值，每个 $\\text{err}_k$ 和 $\\text{ratio}_k$ 是一个浮点数。",
            "solution": "用户提供的问题是有效的。它在科学上基于动力学理论和计算流体动力学的原理，特别涉及 Fokker–Planck 碰撞算子和守恒数值格式。该问题是适定的，提供了一整套方程、边界条件、初始条件和数值参数。其语言客观而精确。\n\n我们现在将构建一个解决方案。该问题要求使用通量修正输运 (FCT) 限制器，为一维 Fokker–Planck 方程实现一个单步守恒的有限体积更新。控制方程为\n$$\n\\frac{\\partial f}{\\partial t} + \\frac{\\partial J}{\\partial v} = 0,\n$$\n碰撞通量由下式给出\n$$\nJ(v,t) = -D(v)\\,\\frac{\\partial f}{\\partial v} - F(v)\\,f.\n$$\n指定的速度空间扩散系数和拖拽系数为 $D(v) = D_0$ 和 $F(v) = \\nu\\,v$，其中 $D_0$ 和 $\\nu$ 是正常数。\n\n首先，我们建立有限体积离散化。速度域 $[v_{\\min}, v_{\\max}]$ 被划分为 $N$ 个宽度为 $\\Delta v = (v_{\\max} - v_{\\min}) / N$ 的均匀网格。网格中心表示为 $v_i = v_{\\min} + (i+0.5)\\Delta v$（其中 $i \\in \\{0, \\dots, N-1\\}$），网格交界面位于 $v_{i+\\frac{1}{2}} = v_{\\min} + (i+1)\\Delta v$（其中 $i \\in \\{-1, \\dots, N-1\\}$）。我们关心的是网格平均分布函数 $f_i^n \\approx f(v_i, t^n)$。\n\n将控制方程在网格 $i$ 上从 $v_{i-\\frac{1}{2}}$ 到 $v_{i+\\frac{1}{2}}$ 进行积分，得到网格平均值的精确更新：\n$$\n\\frac{d f_i}{d t} = -\\frac{1}{\\Delta v} \\left( J(v_{i+\\frac{1}{2}}, t) - J(v_{i-\\frac{1}{2}}, t) \\right).\n$$\n使用时间步长为 $\\Delta t$ 的一阶显式欧拉时间积分，我们得到通用的有限体积格式：\n$$\nf_i^{n+1} = f_i^n - \\frac{\\Delta t}{\\Delta v} \\left( J_{i+\\frac{1}{2}} - J_{i-\\frac{1}{2}} \\right).\n$$\n问题指定了无通量边界条件，这意味着 $J_{-\\frac{1}{2}} = 0$ 和 $J_{N-\\frac{1}{2}} = 0$。\n\n该方法的核心在于网格交界面处数值通量 $J_{i+\\frac{1}{2}}$ 的定义。总通量是扩散通量 $J_{D}$ 和对流（或漂移）通量 $J_{F}$ 的和。在交界面 $v_{i+\\frac{1}{2}}$ 处，我们有：\n$$\nJ_{i+\\frac{1}{2}} = J_{D, i+\\frac{1}{2}} + J_{F, i+\\frac{1}{2}}.\n$$\n对于低阶和高阶格式，扩散部分都使用标准的两点中心差分进行离散化：\n$$\nJ_{D, i+\\frac{1}{2}} = -D_0 \\frac{f_{i+1}^n - f_i^n}{\\Delta v}.\n$$\n对流通量的离散化定义了低阶和高阶格式之间的差异。\n对于**低阶通量** $J_{\\text{lo}}$，我们对对流项使用一阶迎风格式。迎风的方向取决于拖拽系数 $F(v_{i+\\frac{1}{2}}) = \\nu v_{i+\\frac{1}{2}}$ 的符号。假设 $\\nu > 0$：\n$$\nJ_{F, \\text{lo}, i+\\frac{1}{2}} = -F(v_{i+\\frac{1}{2}}) \\times\n\\begin{cases}\nf_i^n  \\text{if } v_{i+\\frac{1}{2}} > 0 \\\\\nf_{i+1}^n  \\text{if } v_{i+\\frac{1}{2}}  0\n\\end{cases}.\n$$\n对于**高阶通量** $J_{\\text{hi}}$，我们对对流项使用二阶中心平均：\n$$\nJ_{F, \\text{hi}, i+\\frac{1}{2}} = -F(v_{i+\\frac{1}{2}}) \\frac{f_i^n + f_{i+1}^n}{2}.\n$$\n这就完全定义了通量 $J_{\\text{lo}}$ 和 $J_{\\text{hi}}$，由此我们可以计算出下一时间步长的低阶和高阶解 $f_{\\text{lo}}^{n+1}$ 和 $f_{\\text{hi}}^{n+1}$。低阶迎风格式具有数值扩散性，但在合适的 CFL 条件下能保证解的正定性；而中心高阶格式扩散性较小，但可能引入非物理振荡和负值。\n\n通量修正输运 (FCT) 算法结合这两种格式，以获得一个既能保证正定性又尽可能接近高阶解的解。步骤如下：\n\n1.  **计算低阶和高阶解：**\n    $$\n    f_{\\text{lo}, i}^{n+1} = f_i^n - \\frac{\\Delta t}{\\Delta v} \\left( J_{\\text{lo}, i+\\frac{1}{2}} - J_{\\text{lo}, i-\\frac{1}{2}} \\right) \\\\\n    f_{\\text{hi}, i}^{n+1} = f_i^n - \\frac{\\Delta t}{\\Delta v} \\left( J_{\\text{hi}, i+\\frac{1}{2}} - J_{\\text{hi}, i-\\frac{1}{2}} \\right)\n    $$\n    低阶解 $f_{\\text{lo}}^{n+1}$ 保证为非负。\n\n2.  **定义反扩散通量：** 高阶通量和低阶通量之差即为反扩散通量，其目的是抵消低阶格式的数值扩散。\n    $$\n    \\delta J_{i+\\frac{1}{2}} = J_{\\text{hi}, i+\\frac{1}{2}} - J_{\\text{lo}, i+\\frac{1}{2}}\n    $$\n    高阶解可以表示为低阶解加上一个修正项：\n    $$\n    f_{\\text{hi}, i}^{n+1} = f_{\\text{lo}, i}^{n+1} - \\frac{\\Delta t}{\\Delta v} \\left( \\delta J_{i+\\frac{1}{2}} - \\delta J_{i-\\frac{1}{2}} \\right).\n    $$\n\n3.  **限制反扩散通量：** 应用全部反扩散通量可能会破坏正定性。我们必须通过乘以一个修正因子 $C_{i+\\frac{1}{2}} \\in [0, 1]$ 来限制它。最终的 FCT 解则为：\n    $$\n    f_{\\text{fct}, i}^{n+1} = f_{\\text{lo}, i}^{n+1} - \\frac{\\Delta t}{\\Delta v} \\left( C_{i+\\frac{1}{2}}\\delta J_{i+\\frac{1}{2}} - C_{i-\\frac{1}{2}}\\delta J_{i-\\frac{1}{2}} \\right).\n    $$\n    为确定因子 $C_{i+\\frac{1}{2}}$，我们使用 Zalesak FCT 限制器，这与问题的要求一致。该方法确保施加到任何网格上的总反扩散修正不会使其值变为负。\n    a.  对每个网格 $i$，确定在不违反正定性的前提下可以从中移除的最大“质量”量。这即为其低阶解的值：$Q_i^- = f_{\\text{lo}, i}^{n+1}$。问题陈述中提到增益不受约束，因此最大增加量为 $Q_i^+ = \\infty$。\n    b.  对每个网格 $i$，通过对两个相邻通量的效应求和，计算总的原始反扩散出流 $A_i^-$（待移除量）和入流 $A_i^+$（待增加量）。令 $\\Phi_{i+\\frac{1}{2}} = \\frac{\\Delta t}{\\Delta v} \\delta J_{i+\\frac{1}{2}}$ 为反扩散修正项。\n        $$\n        A_i^- = \\max(0, -\\Phi_{i-\\frac{1}{2}}) + \\max(0, \\Phi_{i+\\frac{1}{2}}) \\\\\n        A_i^+ = \\max(0, \\Phi_{i-\\frac{1}{2}}) + \\max(0, -\\Phi_{i+\\frac{1}{2}})\n        $$\n    c.  对每个网格 $i$，计算出流的限制比率：\n        $$\n        R_i^- = \\begin{cases} \\min(1, Q_i^- / A_i^-)  \\text{if } A_i^- > 0 \\\\ 1  \\text{if } A_i^- = 0 \\end{cases}\n        $$\n        由于对于正定性，增益不受约束，因此入流比率为 $R_i^+=1$。\n    d.  通量 $\\delta J_{i+\\frac{1}{2}}$ 的修正因子 $C_{i+\\frac{1}{2}}$ 取决于哪个网格是供给单元（损失质量）。\n        - 如果 $\\delta J_{i+\\frac{1}{2}} > 0$，网格 $i$ 是供给单元。修正受供给单元的出流比率 $R_i^-$ 和接收单元 ($i+1$) 的入流比率 $R_{i+1}^+$ 的限制。因此，$C_{i+\\frac{1}{2}} = \\min(R_i^-, R_{i+1}^+) = R_i^-$。\n        - 如果 $\\delta J_{i+\\frac{1}{2}}  0$，网格 $i+1$ 是供给单元。修正受 $R_{i+1}^-$ 和 $R_i^+$ 的限制。因此，$C_{i+\\frac{1}{2}} = \\min(R_{i+1}^-, R_i^+) = R_{i+1}^-$。\n        - 如果 $\\delta J_{i+\\frac{1}{2}} = 0$，$C_{i+\\frac{1}{2}}$ 可设为 $0$。\n\n4.  **计算最终解：** 使用受限通量 $J_{\\text{lim}, i+\\frac{1}{2}} = C_{i+\\frac{1}{2}}\\delta J_{i+\\frac{1}{2}}$ 执行最终更新。此过程在构造上是守恒的。\n\n最后，我们为每个测试用例计算所需的指标：\n-   **正定性检查：** 一个布尔值，指示是否所有 $f_{\\text{fct}, i}^{n+1} \\ge 0$。\n-   **相对质量误差：** $\\left| \\sum_i f_{\\text{fct},i}^{n+1}\\,\\Delta v - \\sum_i f_i^n\\,\\Delta v \\right| \\big/ \\left( \\sum_i f_i^n\\,\\Delta v \\right)$。由于采用了守恒通量公式，该误差应接近机器精度。\n-   **扩散比率：** $\\lVert f_{\\text{hi}}^{n+1} - f_{\\text{fct}}^{n+1} \\rVert_2 \\big/ \\lVert f_{\\text{hi}}^{n+1} - f_{\\text{lo}}^{n+1} \\rVert_2$，该值量化了反扩散修正被限制器抑制的程度。接近 $0$ 的值表示 FCT 解接近高阶解。\n\n该算法针对提供的四个测试用例分别实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_single_step(N, vmin, vmax, nu, D0, dt, f_initial_func):\n    \"\"\"\n    Performs a single conservative finite-volume step with an FCT limiter.\n    \"\"\"\n    # 1. Grid and Initial Conditions\n    dv = (vmax - vmin) / N\n    v_centers = np.linspace(vmin + dv / 2.0, vmax - dv / 2.0, N)\n    v_faces = np.linspace(vmin, vmax, N + 1)\n    f_n = f_initial_func(v_centers)\n\n    # 2. Flux Calculations\n    # Fluxes are computed at the N-1 interior faces\n    f_left = f_n[:-1]   # f_i\n    f_right = f_n[1:]   # f_{i+1}\n    interior_v_faces = v_faces[1:-1] # v_{i+1/2}\n\n    # Diffusive flux (same for low and high order)\n    Jd_face = -D0 * (f_right - f_left) / dv\n\n    # Convective flux coefficient\n    F_face = nu * interior_v_faces\n\n    # Low-order convective flux (upwind)\n    f_upwind = np.where(F_face > 0, f_left, f_right)\n    Jf_lo_face = -F_face * f_upwind\n\n    # High-order convective flux (centered)\n    f_centered = 0.5 * (f_left + f_right)\n    Jf_hi_face = -F_face * f_centered\n\n    # Total fluxes at interior faces\n    J_lo_face = Jd_face + Jf_lo_face\n    J_hi_face = Jd_face + Jf_hi_face\n\n    # Embed in full flux arrays (with zero boundary fluxes)\n    J_lo = np.zeros(N + 1)\n    J_hi = np.zeros(N + 1)\n    J_lo[1:-1] = J_lo_face\n    J_hi[1:-1] = J_hi_face\n\n    # 3. Finite Volume Updates (Low and High Order)\n    f_lo_np1 = f_n - (dt / dv) * (J_lo[1:] - J_lo[:-1])\n    f_hi_np1 = f_n - (dt / dv) * (J_hi[1:] - J_hi[:-1])\n    \n    # Check if low-order solution is non-negative\n    if np.any(f_lo_np1  0):\n        # This can happen if CFL is violated, but the problem parameters should be stable.\n        # We proceed, though the FCT guarantee relies on f_lo_np1 >= 0.\n        f_lo_np1 = np.maximum(0, f_lo_np1)\n\n    # 4. FCT Correction\n    # Anti-diffusive fluxes at interior faces and padded array\n    delta_J_face = J_hi_face - J_lo_face\n    delta_J = np.zeros(N + 1)\n    delta_J[1:-1] = delta_J_face\n    \n    # Zalesak FCT Limiter\n    # a. Max removable mass from each cell\n    Q_minus = f_lo_np1.copy()\n\n    # b. Raw anti-diffusive influx/outflux for each cell\n    phi = (dt / dv) * delta_J\n    A_minus = np.maximum(0, -phi[:-1]) + np.maximum(0, phi[1:])\n    \n    # c. Cell-based limiting ratio for outfluxes\n    R_minus = np.ones(N)\n    # Use a small tolerance to avoid division by zero for negligible fluxes\n    idx_nonzero_A = np.where(A_minus > 1e-16)\n    R_minus[idx_nonzero_A] = np.minimum(1.0, Q_minus[idx_nonzero_A] / A_minus[idx_nonzero_A])\n\n    # d. Face-based correction factors\n    # R_minus[:-1] -> R_i for flux i+1/2\n    # R_minus[1:]  -> R_{i+1} for flux i+1/2\n    C_face = np.where(delta_J_face > 0, R_minus[:-1], R_minus[1:])\n    C_face = np.where(np.abs(delta_J_face)  1e-16, 0.0, C_face)\n\n    # e. Apply limited fluxes to get final solution\n    delta_J_lim = np.zeros(N + 1)\n    delta_J_lim[1:-1] = C_face * delta_J_face\n    f_fct_np1 = f_lo_np1 - (dt / dv) * (delta_J_lim[1:] - delta_J_lim[:-1])\n\n    # 5. Calculate Metrics\n    # Positivity check (allowing for small floating point errors)\n    positivity = np.all(f_fct_np1 >= -1e-15)\n\n    # Relative mass error\n    mass_n = np.sum(f_n) * dv\n    mass_np1 = np.sum(f_fct_np1) * dv\n    if mass_n == 0:\n        mass_error = 0.0 if mass_np1 == 0 else np.inf\n    else:\n        mass_error = np.abs(mass_np1 - mass_n) / mass_n\n\n    # Diffusion ratio\n    norm_num = np.linalg.norm(f_hi_np1 - f_fct_np1)\n    norm_den = np.linalg.norm(f_hi_np1 - f_lo_np1)\n    if norm_den  1e-16:\n        diffusion_ratio = 0.0\n    else:\n        diffusion_ratio = norm_num / norm_den\n\n    return positivity, mass_error, diffusion_ratio\n\n\ndef solve():\n    test_cases = [\n        # Case 1 (happy path, Maxwellian)\n        {\n            \"N\": 200, \"vmin\": -6.0, \"vmax\": 6.0,\n            \"nu\": 0.5, \"D0\": 0.1, \"dt\": 0.001,\n            \"f_initial_func\": lambda v, n0=1.0, vth=1.0: (\n                n0 / (np.sqrt(np.pi) * vth) * np.exp(-v**2 / vth**2)\n            )\n        },\n        # Case 2 (sharp gradient with notch)\n        {\n            \"N\": 200, \"vmin\": -6.0, \"vmax\": 6.0,\n            \"nu\": 1.0, \"D0\": 0.2, \"dt\": 0.003,\n            \"f_initial_func\": lambda v, n0=1.0, vth=1.0: (\n                (n0 / (np.sqrt(np.pi) * vth) * np.exp(-v**2 / vth**2)) *\n                (1.0 - 0.4 * np.exp(-(v - 2.0)**2 / 0.2**2))\n            )\n        },\n        # Case 3 (near-vacuum tails)\n        {\n            \"N\": 200, \"vmin\": -6.0, \"vmax\": 6.0,\n            \"nu\": 0.3, \"D0\": 0.05, \"dt\": 0.002,\n            \"f_initial_func\": lambda v, n0=1e-3, vth=1.0: (\n                (n0 / (np.sqrt(np.pi) * vth) * np.exp(-v**2 / vth**2)) +\n                5e-5 * np.exp(-(v - 4.0)**2 / 0.3**2)\n            )\n        },\n        # Case 4 (near-stability time step, bimodal)\n        {\n            \"N\": 80, \"vmin\": -6.0, \"vmax\": 6.0,\n            \"nu\": 0.8, \"D0\": 0.5, \"dt\": 0.02,\n            \"f_initial_func\": lambda v, vth=0.8: (\n                (0.5 / (np.sqrt(np.pi) * vth) * np.exp(-(v - 2.0)**2 / vth**2)) +\n                (0.5 / (np.sqrt(np.pi) * vth) * np.exp(-(v + 2.0)**2 / vth**2))\n            )\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        pos, err, ratio = run_single_step(**case)\n        results.extend([pos, err, ratio])\n    \n    # Format booleans as lowercase strings for consistency with examples.\n    formatted_results = [str(r).lower() if isinstance(r, bool) else str(r) for r in results]\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}