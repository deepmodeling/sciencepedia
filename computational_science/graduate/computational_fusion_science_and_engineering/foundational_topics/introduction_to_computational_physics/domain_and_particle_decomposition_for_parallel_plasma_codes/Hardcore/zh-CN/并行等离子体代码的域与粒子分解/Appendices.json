{
    "hands_on_practices": [
        {
            "introduction": "在并行计算中，网格区域分解是有限差分等方法的核心策略。为了在每个子区域的边界上正确计算场，处理器需要从其邻居那里获取数据，这个过程称为“晕环交换”（halo exchange）。本练习将引导你通过交换“幽灵单元”（ghost cells）中的数据来满足计算模板的需求，并从第一性原理推导通信数据量，帮助你掌握量化并行代码中通信开销的基本技能。",
            "id": "3968570",
            "problem": "在计算聚变科学中，一个三维时域有限差分（FDTD）麦克斯韦求解器在大小为 $N_x \\times N_y \\times N_z$ 的结构化网格上推进电磁场。其并行化采用三维块状（笛卡尔）区域分解，包含 $P_x \\times P_y \\times P_z$ 个进程，因此每个进程拥有一个内部大小为 $n_x \\times n_y \\times n_z$ 的矩形子域，其中 $n_x = N_x / P_x$，$n_y = N_y / P_y$，$n_z = N_z / P_z$。在所有三个方向上都施加了周期性边界条件，并且所有进程在拓扑上都是等价的。为了使用一个各向同性模板计算一次场更新（该模板需要在 $x$、$y$ 和 $z$ 每个方向上获取半径为 $h$ 个单元的数据），代码执行一次单阶段晕圈交换（halo exchange），通过向所有 $26$ 个邻近进程发送不相交的面、边和角子块，来完全填充一个厚度为 $h$ 个单元的幽灵层（ghost layer）。\n\n假设每个网格单元存储 $s$ 个实值状态变量，每个变量均为双精度（每个变量 $8$ 字节）。忽略所有消息头、填充和网络协议开销。仅使用模板局部性和分解所隐含的几何计数第一性原理，推导出在一次足以将场推进一个时间步长的单阶段晕圈交换中，每个进程的总出站消息体积（以字节为单位）。\n\n请以 $N_x$、$N_y$、$N_z$、$P_x$、$P_y$、$P_z$、$h$ 和 $s$ 的单个闭式表达式形式提供最终答案。最终体积以字节表示。不要简化为数值。最终的方框答案中不要包含单位。",
            "solution": "该问题陈述已经过验证，被认为是有效的。它具有科学依据、是适定的、客观的且内部一致，描述了并行科学计算中的一个标准场景。\n\n目标是推导出一个闭式表达式，表示在一次晕圈交换步骤中，单个进程的总出站消息体积（以字节为单位）。该问题涉及用于有限差分求解器的三维区域分解。\n\n每个进程负责一个内部网格单元大小为 $n_x \\times n_y \\times n_z$ 的矩形子域。该子域的维度由以下公式给出：\n$$n_x = \\frac{N_x}{P_x}$$\n$$n_y = \\frac{N_y}{P_y}$$\n$$n_z = \\frac{N_z}{P_z}$$\n其中 $N_x, N_y, N_z$ 是全局网格的维度，$P_x, P_y, P_z$ 是进程网格的维度。\n\n计算模板需要来自邻近单元直至半径为 $h$ 的数据。这意味着，为了让一个进程更新其内部域边界上的场值，它需要来自其邻近进程的数据。这些从邻近进程所需的数据存储在一个围绕该进程内部域的“幽灵层”或“晕圈”区域中。该晕圈被指定为在每个方向上厚度为 $h$ 个单元。\n\n由于周期性边界条件以及所有进程在拓扑上等价的陈述，系统是对称的。因此，一个进程*发送*给其邻近进程的总数据体积等于它*接收*自其邻近进程以填充自身幽灵层的总数据体积。因此，我们可以计算填充单个进程的幽灵层所需的数据体积。\n\n一个进程的内部域体积为 $V_{interior} = n_x n_y n_z$ 个单元。\n一个进程的逻辑网格，包括其在所有侧面（即 $x$、$y$ 和 $z$ 各个方向的正负面）厚度为 $h$ 的幽灵层，其维度为 $(n_x + 2h) \\times (n_y + 2h) \\times (n_z + 2h)$。这个扩展网格的总体积为：\n$$V_{total} = (n_x + 2h)(n_y + 2h)(n_z + 2h)$$\n\n幽灵层中的单元数 $V_{ghost\\_cells}$ 是扩展网格的总体积减去内部域的体积：\n$$V_{ghost\\_cells} = V_{total} - V_{interior}$$\n$$V_{ghost\\_cells} = (n_x + 2h)(n_y + 2h)(n_z + 2h) - n_x n_y n_z$$\n\n问题陈述指出，每个网格单元存储 $s$ 个实值状态变量，每个变量以双精度存储，对应 $8$ 字节。因此，每个网格单元的数据量为 $8s$ 字节。\n\n总出站消息体积（以字节为单位）$M_{volume}$ 是幽灵层中的单元数乘以每个单元的数据体积。\n$$M_{volume} = 8s \\times V_{ghost\\_cells}$$\n$$M_{volume} = 8s \\left[ (n_x + 2h)(n_y + 2h)(n_z + 2h) - n_x n_y n_z \\right]$$\n\n最后，我们代入 $n_x$、$n_y$ 和 $n_z$ 的表达式，以按要求用全局问题参数表示体积。\n$$n_x = \\frac{N_x}{P_x}, \\quad n_y = \\frac{N_y}{P_y}, \\quad n_z = \\frac{N_z}{P_z}$$\n将这些代入 $M_{volume}$ 的表达式中：\n$$M_{volume} = 8s \\left[ \\left(\\frac{N_x}{P_x} + 2h\\right)\\left(\\frac{N_y}{P_y} + 2h\\right)\\left(\\frac{N_z}{P_z} + 2h\\right) - \\frac{N_x N_y N_z}{P_x P_y P_z} \\right]$$\n\n这就是最终的闭式表达式，表示每个进程的总出站消息体积（以字节为单位），它是根据指定的几何计数第一性原理推导出来的。该表达式正确地计算了构成晕圈数据的面、边和角子块的体积。",
            "answer": "$$\n\\boxed{8s \\left[ \\left(\\frac{N_x}{P_x} + 2h\\right)\\left(\\frac{N_y}{P_y} + 2h\\right)\\left(\\frac{N_z}{P_z} + 2h\\right) - \\frac{N_x N_y N_z}{P_x P_y P_z} \\right]}\n$$"
        },
        {
            "introduction": "现在我们将关注点从网格转移到粒子，探讨粒子数据的内存组织方式。在实践中，两种基本的数据布局——结构数组（AoS）和数组结构（SoA）——各有优劣 。本练习要求你分析这两种布局下的内存占用和访存流量，并考虑现代计算机体系结构中的对齐和写分配策略等因素，这对于编写能在现代处理器上高效运行的高性能粒子代码至关重要。",
            "id": "3968569",
            "problem": "考虑一个使用区域分解的计算聚变科学与工程代码中的大规模并行粒子模拟（particle-in-cell）推进过程。我们关注一个包含 $N_p$ 个粒子的子域，每个粒子有 $k$ 个标量属性（例如，电荷、质量、三个位置分量、三个速度分量和一个单元索引）。每个属性以 $s$ 字节的固定宽度二进制格式存储。在实践中，使用两种典型的内存布局：结构体数组（AoS）和数组结构体（SoA）。在结构体数组（AoS）布局中，每个粒子作为一个包含其 $k$ 个属性的连续记录存储，并且每条记录都会被填充以满足 $a$ 字节的对齐约束。在数组结构体（SoA）布局中，每个属性都存储在自己的长度为 $N_p$ 的连续数组中，在数组基地址处对齐，但没有针对单个粒子的填充。\n\n假设一个时间步进核函数，对于每个粒子，它会读取所有 $k$ 个属性，执行算术运算，然后写回所有 $k$ 个属性（对完整的粒子状态进行读-改-写操作）。内存子系统在存储时使用写分配策略，并可能进行所有权读取（RFO）。用参数 $\\rho \\in \\{0,1\\}$ 来对 RFO 效应建模，其中 $\\rho=1$ 表示带 RFO 的写分配，其流量等于写入数据的体积；$\\rho=0$ 表示非临时性存储或以其他方式避免了 RFO。\n\n从第一性原理出发——即内存占用定义为存储的总字节数，内存流量定义为内核在主存和处理单元之间读取和写入的字节总和——推导以下各项的符号表达式：\n- 结构体数组（array-of-structures）下粒子数组的总内存占用，$M_{\\mathrm{AoS}}$，以字节为单位，\n- 数组结构体（structure-of-arrays）下的总内存占用，$M_{\\mathrm{SoA}}$，以字节为单位，\n- 结构体数组下每时间步的总内存流量，$B_{\\mathrm{AoS}}$，以字节/时间步为单位，\n- 数组结构体下每时间步的总内存流量，$B_{\\mathrm{SoA}}$，以字节/时间步为单位。\n\n您的推导应明确考虑结构体数组布局中每个粒子的对齐填充以及由参数 $\\rho$ 决定的所有权读取效应。您的最终答案应以字节表示。请将最终答案以单行矩阵的形式提供，依次包含 $M_{\\mathrm{AoS}}$、$M_{\\mathrm{SoA}}$、$B_{\\mathrm{AoS}}$ 和 $B_{\\mathrm{SoA}}$。不需要进行数值计算，也不需要四舍五入。请勿在最终答案框内包含单位；内存占用和每时间步内存流量的单位均为字节。",
            "solution": "问题陈述已经过验证，被认为是合理的。它在科学上基于计算机内存组织和性能建模的原理，问题提出得当，提供了所有必要信息，并且语言客观。因此，我们可以继续对所要求的量进行形式化推导。\n\n问题要求推导与并行粒子模拟代码中内存使用相关的四个表达式：结构体数组（$M_{\\mathrm{AoS}}$）和数组结构体（$M_{\\mathrm{SoA}}$）布局的内存占用，以及相应的每时间步内存流量（$B_{\\mathrm{AoS}}$ 和 $B_{\\mathrm{SoA}}$）。推导将从每种布局的定义和内存流量模型出发。\n\n给定的参数是：\n- $N_p$：粒子数量。\n- $k$：每个粒子的标量属性数量。\n- $s$：每个属性的大小（以字节为单位）。\n- $a$：结构体数组布局的对齐约束（以字节为单位）。\n- $\\rho$：一个参数，取值为 0 或 1，用于对所有权读取（RFO）流量效应进行建模。\n\n**1. 结构体数组（AoS）的内存占用（$M_{\\mathrm{AoS}}$）**\n\n在结构体数组（AoS）布局中，单个粒子的 $k$ 个属性是连续存储的。单个粒子属性的总数据大小是属性数量 $k$ 和每个属性大小 $s$ 的乘积。\n$$ \\text{每个粒子数据大小} = k \\times s \\text{ 字节} $$\n问题陈述指出，每个粒子记录都被填充以满足 $a$ 字节的对齐约束。这意味着为每个粒子记录分配的总大小必须是大于或等于实际数据大小 $ks$ 的 $a$ 的最小倍数。这可以用向上取整函数（ceiling function）来正式表示。设 $S_{\\mathrm{AoS\\_record}}$ 为一个填充后的粒子记录的大小。\n$$ S_{\\mathrm{AoS\\_record}} = a \\times \\left\\lceil \\frac{k s}{a} \\right\\rceil $$\n总内存占用 $M_{\\mathrm{AoS}}$ 是一个填充后记录的大小乘以粒子总数 $N_p$。\n$$ M_{\\mathrm{AoS}} = N_p \\times S_{\\mathrm{AoS\\_record}} = N_p a \\left\\lceil \\frac{k s}{a} \\right\\rceil $$\n\n**2. 数组结构体（SoA）的内存占用（$M_{\\mathrm{SoA}}$）**\n\n在数组结构体（SoA）布局中， $k$ 个属性中的每一个都存储在各自独立的连续数组中。这些数组中的每一个都保存了所有 $N_p$ 个粒子特定属性的数据。问题明确指出，在这种布局中没有针对单个粒子的填充。\n对于单个属性，这样一个数组的大小是粒子数 $N_p$ 乘以属性大小 $s$。\n$$ \\text{一个属性数组的大小} = N_p \\times s \\text{ 字节} $$\n由于有 $k$ 个这样的数组，总内存占用 $M_{\\mathrm{SoA}}$ 是单个属性数组大小的 $k$ 倍。\n$$ M_{\\mathrm{SoA}} = k \\times (N_p \\times s) = N_p k s $$\n\n**3. 结构体数组（AoS）的内存流量（$B_{\\mathrm{AoS}}$）**\n\n内存流量定义为从主存读取和写入主存的字节总和。核函数对每个粒子的所有属性执行读-改-写循环。\n\n在 AoS 布局中，数据的基本单位是粒子记录。对粒子任一属性的访问很可能涉及传输包含整个填充后记录的缓存行。因此，我们基于填充后的记录大小 $S_{\\mathrm{AoS\\_record}}$ 来对流量进行建模。\n\n- **读取流量**：为了执行计算，核函数必须读取所有 $N_p$ 个粒子的初始状态。这构成了 $N_p \\times S_{\\mathrm{AoS\\_record}}$ 的读取流量。\n- **写入流量**：修改后，核函数写回所有 $N_p$ 个粒子的新状态。这构成了 $N_p \\times S_{\\mathrm{AoS\\_record}}$ 的写入流量。\n- **所有权读取（RFO）流量**：问题引入了一个参数 $\\rho$ 来对 RFO 流量进行建模，这是由写分配策略在写未命中时产生的额外读取流量分量。RFO 流量等于 $\\rho$ 乘以写入数据的体积。写入数据的体积就是上面计算的写入流量。\n  $$ \\text{RFO 流量} = \\rho \\times (\\text{写入流量}) = \\rho \\times (N_p \\times S_{\\mathrm{AoS\\_record}}) $$\n\n总内存流量 $B_{\\mathrm{AoS}}$ 是这三个分量的总和。\n$$ B_{\\mathrm{AoS}} = (\\text{读取流量}) + (\\text{写入流量}) + (\\text{RFO 流量}) $$\n$$ B_{\\mathrm{AoS}} = (N_p S_{\\mathrm{AoS\\_record}}) + (N_p S_{\\mathrm{AoS\\_record}}) + (\\rho N_p S_{\\mathrm{AoS\\_record}}) $$\n$$ B_{\\mathrm{AoS}} = (1 + 1 + \\rho) N_p S_{\\mathrm{AoS\\_record}} = (2 + \\rho) N_p S_{\\mathrm{AoS\\_record}} $$\n代入 $S_{\\mathrm{AoS\\_record}}$ 的表达式：\n$$ B_{\\mathrm{AoS}} = (2 + \\rho) N_p a \\left\\lceil \\frac{k s}{a} \\right\\rceil $$\n\n**4. 数组结构体（SoA）的内存流量（$B_{\\mathrm{SoA}}$）**\n\n对于 SoA 布局，逻辑是类似的，但数据体积的计算方式不同。所有粒子的总数据有效载荷与内存占用 $M_{\\mathrm{SoA}}$ 相同。我们用 $V_{\\mathrm{payload}} = N_p k s$ 表示这个体积。\n\n核函数读取所有 $N_p$ 个粒子的所有 $k$ 个属性，然后再将它们写回。\n- **读取流量**：核函数读取所有属性数组。总读取体积为 $V_{\\mathrm{payload}} = N_p k s$。\n- **写入流量**：核函数写入所有属性数组。总写入体积为 $V_{\\mathrm{payload}} = N_p k s$。\n- **所有权读取（RFO）流量**：这是 $\\rho$ 乘以写入数据的体积。\n  $$ \\text{RFO 流量} = \\rho \\times (\\text{写入流量}) = \\rho \\times (N_p k s) $$\n\n总内存流量 $B_{\\mathrm{SoA}}$ 是这些分量的总和。\n$$ B_{\\mathrm{SoA}} = (\\text{读取流量}) + (\\text{写入流量}) + (\\text{RFO 流量}) $$\n$$ B_{\\mathrm{SoA}} = (N_p k s) + (N_p k s) + (\\rho N_p k s) $$\n$$ B_{\\mathrm{SoA}} = (1 + 1 + \\rho) N_p k s = (2 + \\rho) N_p k s $$\n\n总结一下，推导出的四个表达式是：\n- $M_{\\mathrm{AoS}} = N_p a \\lceil \\frac{ks}{a} \\rceil$\n- $M_{\\mathrm{SoA}} = N_p k s$\n- $B_{\\mathrm{AoS}} = (2 + \\rho) N_p a \\lceil \\frac{ks}{a} \\rceil$\n- $B_{\\mathrm{SoA}} = (2 + \\rho) N_p k s$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\nN_p a \\left\\lceil \\frac{ks}{a} \\right\\rceil  N_p k s  (2 + \\rho) N_p a \\left\\lceil \\frac{ks}{a} \\right\\rceil  (2 + \\rho) N_p k s\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "高性能并行算法的设计不仅要考虑速度，还必须保证对物理定律的精确维持。本练习模拟了一个在并行PIC代码中可能出现的微妙问题：由于异步通信，粒子跨越子区域边界的物理迁移与其数据在处理器间的传递存在时间延迟 。你将分析这种延迟如何导致电荷不守恒，并推导出一个“延迟电流补偿”方案来修正这个误差，这个实践揭示了在复杂的并行环境中维护数值稳定性和物理守恒性的重要性。",
            "id": "3968634",
            "problem": "考虑一个电荷守恒的质点网格 (PIC) 算法，该算法在一个一维 ($1\\mathrm{D}$) 均匀网格上运行，该网格通过区域分解分为两个子域 $\\Omega_{\\mathrm{A}}$ 和 $\\Omega_{\\mathrm{B}}$，它们由位于 $x=x_b$ 处的界面隔开。其基本控制平衡是电荷连续性方程 $\\partial \\rho / \\partial t + \\nabla \\cdot \\mathbf{J} = 0$，其中 $\\rho$ 是电荷密度，$\\mathbf{J}$ 是电流密度。在从 $t^n$ 到 $t^{n+1}=t^n+\\Delta t$ 的离散时间步内，电荷守恒的 PIC 电流分配方案确保离散连续性方程在每个子域上精确成立，前提是粒子在该时间步内被分配到它们物理上移动到的位置。\n\n假设在时间 $t^n$ 和 $t^{n+1}$ 之间，三个宏粒子从 $\\Omega_{\\mathrm{A}}$ 越过界面迁移到 $\\Omega_{\\mathrm{B}}$。它们的电荷分别为 $q_1=1.2 \\times 10^{-9}\\ \\mathrm{C}$、$q_2=-0.8 \\times 10^{-9}\\ \\mathrm{C}$ 和 $q_3=0.5 \\times 10^{-9}\\ \\mathrm{C}$。在此时间步内，它们的轨迹完全越过界面，因此它们应对从 $\\Omega_{\\mathrm{A}}$ 流入 $\\Omega_{\\mathrm{B}}$ 的界面电流通量做出贡献。离散时间步长为 $\\Delta t=5.0 \\times 10^{-9}\\ \\mathrm{s}$。然而，由于一个并行通信调度决策，到 $\\Omega_{\\mathrm{B}}$ 的粒子迁移被精确地延迟了一个时间步：接收子域 $\\Omega_{\\mathrm{B}}$ 不在时间 $t^{n+1}$ 分配这些粒子，而是在时间 $t^{n+2}$ 接收并分配它们。\n\n从电荷连续性方程和跨子域界面的离散通量定义出发，推导在时间 $t^{n+1}$ 时，由于这一步延迟在 $\\Omega_{\\mathrm{B}}$ 上引入的净离散电荷守恒误差，该误差表示为电荷变化与分配电流散度之间的不匹配。然后，提出一种延迟电流补偿方案，通过从 $\\Omega_{\\mathrm{A}}$ 向 $\\Omega_{\\mathrm{B}}$ 分配一个等于延迟步骤中遗漏的界面通量的界面校正电流，以在 $t^{n+1}$ 时恢复 $\\Omega_{\\mathrm{B}}$ 上的离散电荷连续性。计算此校正电流的大小，该电流被解释为在时间间隔 $[t^n, t^{n+1}]$ 内必须跨越 $x=x_b$ 添加的总界面电流（而非电流密度）。\n\n将您的最终答案四舍五入到四位有效数字。以 $\\mathrm{A}$（安培）为单位表示最终电流大小。",
            "solution": "用户希望我按照以下步骤解决问题：\n1.  **验证问题**：我将首先检查问题是否适定、有科学依据且没有致命缺陷。\n2.  **推导解法**：如果问题有效，我将从第一性原理推导出答案。\n3.  **最终格式化**：我必须对所有数学实体使用 LaTeX，并以特定的方框格式呈现最终答案。\n\n### 步骤 1：提取已知条件\n-   **系统**：一维 ($1\\mathrm{D}$) 质点网格 (PIC) 模拟，通过区域分解分为两个子域 $\\Omega_{\\mathrm{A}}$ 和 $\\Omega_{\\mathrm{B}}$。\n-   **界面**：子域由位于 $x=x_b$ 处的界面隔开。\n-   **控制原理**：电荷连续性方程，$\\frac{\\partial \\rho}{\\partial t} + \\nabla \\cdot \\mathbf{J} = 0$。\n-   **粒子迁移**：在时间步 $[t^n, t^{n+1}]$ 内，三个宏粒子从 $\\Omega_{\\mathrm{A}}$ 迁移到 $\\Omega_{\\mathrm{B}}$。\n-   **粒子电荷**：$q_1 = 1.2 \\times 10^{-9}\\ \\mathrm{C}$，$q_2 = -0.8 \\times 10^{-9}\\ \\mathrm{C}$，$q_3 = 0.5 \\times 10^{-9}\\ \\mathrm{C}$。\n-   **时间步长**：$\\Delta t = t^{n+1} - t^n = 5.0 \\times 10^{-9}\\ \\mathrm{s}$。\n-   **数值缺陷**：由于通信延迟，子域 $\\Omega_{\\mathrm{B}}$ 在时间 $t^{n+1}$ 不处理迁移的粒子。它们的并入被延迟到 $t^{n+2}$。\n-   **任务 1**：推导在时间 $t^{n+1}$ 时 $\\Omega_{\\mathrm{B}}$ 上的净离散电荷守恒误差。\n-   **任务 2**：提出一种延迟电流补偿方案以恢复电荷连续性。\n-   **任务 3**：计算界面所需的校正电流的大小。\n-   **输出格式**：最终数值答案必须四舍五入到四位有效数字，并以安培 ($\\mathrm{A}$) 为单位表示。\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **科学依据**：该问题在计算等离子体物理学中有充分的依据。并行 PIC 代码中的电荷守恒、区域分解以及界面处的通量校正是该领域中标准且关键的课题。连续性方程是物理学的基本定律。所描述的情景是并行算法设计中一个现实且常见的挑战。该问题在科学上是合理的。\n-   **适定性**：问题提供了计算所需电流的所有必要数据（$q_1, q_2, q_3, \\Delta t$）。目标陈述清晰，存在唯一且有意义的解。\n-   **客观性**：问题以精确、客观、技术性的语言陈述，没有任何主观或模糊的术语。\n-   **缺陷清单**：问题未违反任何无效性标准。它在科学上是有效的、可形式化的、完整的、现实的且适定的。\n\n### 步骤 3：结论与行动\n问题是**有效的**。现在开始求解过程。\n\n### 解法推导\n\n支配电荷守恒的基本原理是连续性方程，其在控制体积 $V$ 上的积分形式为：\n$$\n\\frac{d}{dt} \\int_V \\rho \\, dV + \\oint_{\\partial V} \\mathbf{J} \\cdot d\\mathbf{S} = 0\n$$\n其中 $\\rho$ 是电荷密度，$\\mathbf{J}$ 是电流密度，$V$ 是体积，$\\partial V$ 是其边界面。令 $Q_V = \\int_V \\rho \\, dV$ 为体积内的总电荷。该方程表明，一个体积内总电荷的变化率等于流入其中的净电流。\n\n对于占据空间中一个区域的一维子域 $\\Omega_{\\mathrm{B}}$，方程变为：\n$$\n\\frac{dQ_{\\mathrm{B}}}{dt} = I_{\\text{net, in}}\n$$\n其中 $Q_{\\mathrm{B}}$ 是 $\\Omega_{\\mathrm{B}}$ 中的总电荷，$I_{\\text{net, in}}$ 是流经其边界的总净电流。在这个问题中，相关的边界是位于 $x=x_b$ 的界面，电流从 $\\Omega_{\\mathrm{A}}$ 流向 $\\Omega_{\\mathrm{B}}$。我们将此界面电流表示为 $I_b(t)$。\n\n一个电荷守恒的 PIC 算法必须对每个时间步 $\\Delta t = t^{n+1} - t^n$ 满足此方程的离散模拟形式。将方程在时间间隔 $[t^n, t^{n+1}]$ 上积分，得到：\n$$\n\\int_{t^n}^{t^{n+1}} \\frac{dQ_{\\mathrm{B}}}{dt} dt = \\int_{t^n}^{t^{n+1}} I_b(t) dt\n$$\n$$\nQ_{\\mathrm{B}}^{n+1} - Q_{\\mathrm{B}}^n = \\bar{I}_b \\Delta t\n$$\n其中 $Q_{\\mathrm{B}}^n$ 是时间 $t^n$ 时 $\\Omega_{\\mathrm{B}}$ 中的总电荷，$\\bar{I}_b = \\frac{1}{\\Delta t} \\int_{t^n}^{t^{n+1}} I_b(t) dt$ 是该时间步内跨界面的时间平均电流。项 $\\bar{I}_b \\Delta t$ 表示跨边界传输的总电荷，即所有穿过界面的粒子的净电荷。\n\n在物理系统中，三个带有电荷 $q_1$、$q_2$ 和 $q_3$ 的粒子从 $\\Omega_{\\mathrm{A}}$ 越过界面进入 $\\Omega_{\\mathrm{B}}$。物理上进入 $\\Omega_{\\mathrm{B}}$ 的总电荷是：\n$$\n\\Delta Q_{\\text{mig}} = q_1 + q_2 + q_3\n$$\n为了守恒电荷，$\\Omega_{\\mathrm{B}}$ 中记录的电荷变化必须等于这个量，并且这个变化必须由边界处相应的已分配电流通量来解释。物理上正确的时间平均界面电流是：\n$$\n\\bar{I}_{\\text{phys}} = \\frac{\\Delta Q_{\\text{mig}}}{\\Delta t}\n$$\n\n问题指出通信存在一步延迟。对于时间步 $t^n \\to t^{n+1}$，子域 $\\Omega_{\\mathrm{B}}$ 没有收到三个迁移粒子的数据。因此：\n1.  属于 $\\Omega_{\\mathrm{B}}$ 的粒子列表没有用新到达的粒子更新。代码计算出的 $\\Omega_{\\mathrm{B}}$ 中的总电荷在此迁移事件中保持不变，因此代码计算 $\\Delta Q_{\\mathrm{B}, \\text{code}} = Q_{\\mathrm{B}}^{n+1} - Q_{\\mathrm{B}}^n = 0$（相对于迁移的粒子）。\n2.  由于 $\\Omega_{\\mathrm{B}}$ 没有关于粒子穿过其边界的信息，它在界面 $x=x_b$ 处从这些粒子分配的电流为零。分配的界面电流为 $\\bar{I}_{b, \\text{dep}} = 0$。\n\n$\\Omega_{\\mathrm{B}}$ 上的离散电荷守恒误差是物理电荷变化与由分配电流所解释的电荷之间的不匹配。\n$$\n\\text{误差} = \\Delta Q_{\\text{phys}} - (\\bar{I}_{b, \\text{dep}} \\Delta t)\n$$\n在这种情况下，$\\Delta Q_{\\text{phys}} = \\Delta Q_{\\text{mig}}$ 且 $\\bar{I}_{b, \\text{dep}} = 0$。因此误差为：\n$$\n\\text{误差} = \\Delta Q_{\\text{mig}} - 0 = \\Delta Q_{\\text{mig}}\n$$\n这意味着一个净电荷 $\\Delta Q_{\\text{mig}}$ 物理上出现在了域区域 $\\Omega_{\\mathrm{B}}$ 中，而该子域中的代码没有记录任何相应的电流。这违反了网格上的离散形式的高斯定律，会导致非物理的静电场。\n\n为了在 $t^{n+1}$ 时恢复离散电荷连续性，提出了一个“延迟电流补偿”方案。这涉及到在 $\\Omega_{\\mathrm{B}}$ 一侧的网格界面上分配一个校正电流 $I_{\\text{corr}}$。这个校正必须等于“遗漏的界面通量”，即本应被分配的电流，也就是 $\\bar{I}_{\\text{phys}}$。\n$$\nI_{\\text{corr}} = \\bar{I}_{\\text{phys}} = \\frac{\\Delta Q_{\\text{mig}}}{\\Delta t}\n$$\n通过这个校正，$\\Omega_{\\mathrm{B}}$ 网格上的离散连续性方程将得到满足，因为由分配的电流引起的网格电荷变化将是 $I_{\\text{corr}} \\Delta t = \\Delta Q_{\\text{mig}}$，正确地反映了物理电荷的进入（尽管粒子对象本身是稍后才被计入的）。\n\n我们现在计算这个校正电流的大小。\n首先，计算迁移粒子的总电荷：\n$$\n\\Delta Q_{\\text{mig}} = q_1 + q_2 + q_3 = (1.2 \\times 10^{-9}) + (-0.8 \\times 10^{-9}) + (0.5 \\times 10^{-9}) \\ \\mathrm{C}\n$$\n$$\n\\Delta Q_{\\text{mig}} = (1.2 - 0.8 + 0.5) \\times 10^{-9}\\ \\mathrm{C} = 0.9 \\times 10^{-9}\\ \\mathrm{C}\n$$\n时间步长给定为 $\\Delta t = 5.0 \\times 10^{-9}\\ \\mathrm{s}$。\n校正电流的大小为：\n$$\nI_{\\text{corr}} = \\frac{\\Delta Q_{\\text{mig}}}{\\Delta t} = \\frac{0.9 \\times 10^{-9}\\ \\mathrm{C}}{5.0 \\times 10^{-9}\\ \\mathrm{s}}\n$$\n$$\nI_{\\text{corr}} = \\frac{0.9}{5.0}\\ \\mathrm{A} = 0.18\\ \\mathrm{A}\n$$\n问题要求答案四舍五入到四位有效数字。\n$$\nI_{\\text{corr}} = 0.1800\\ \\mathrm{A}\n$$\n这个校正电流从 $\\Omega_{\\mathrm{A}}$（它知道粒子已经离开并能计算通量）传递到 $\\Omega_{\\mathrm{B}}$，从而允许在每个时间步都维持网格上的全局电荷守恒，尽管粒子数据传输存在延迟。",
            "answer": "$$\n\\boxed{0.1800}\n$$"
        }
    ]
}