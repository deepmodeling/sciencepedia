{
    "hands_on_practices": [
        {
            "introduction": "在优化I/O性能之前，我们必须首先掌握描述数据布局的基本任务。这个练习将挑战你像MPI-IO库本身一样思考，即在不使用高级库调用的情况下，为一个三维子数组计算其在文件中的精确偏移量。掌握这项技能有助于你理解文件视图和派生数据类型的底层机制，这对于处理等离子体模拟中常见的结构化网格至关重要。",
            "id": "4026018",
            "problem": "考虑一个表示在结构化网格上采样的标量场的全局三维数组，该数组源于计算聚变科学中的等离子体模拟。该全局数组的维度为 $(N_x,N_y,N_z)$，其中 $N_x,N_y,N_z \\in \\mathbb{N}$，其元素在文件中以行主序（C语言）或列主序（Fortran）连续存储。每个并行进程拥有一个由其起始索引 $(s_x,s_y,s_z)$ 和范围 $(n_x,n_y,n_z)$ 定义的矩形子域，满足 $0 \\le s_x  N_x$，$0 \\le s_y  N_y$，$0 \\le s_z  N_z$ 以及 $1 \\le n_x \\le N_x - s_x$，$1 \\le n_y \\le N_y - s_y$，$1 \\le n_z \\le N_z - s_z$。目标是设计一个等效于消息传递接口（MPI）中派生数据类型及关联的输入/输出（I/O）文件视图的映射，该映射能够在不实际使用MPI的情况下，识别出每个进程将要写入的非连续文件偏移量。您的任务是，从第一性原理出发，计算出覆盖进程子数组的连续块起始位置列表和相应的块长度（以元素为单位），这需要针对两种支持的存储顺序进行。\n\n使用的基本定义：\n- 三维数组的行主序（C语言）线性化由线性索引映射给出\n$$L_C(x,y,z) = \\big((x \\cdot N_y) + y\\big)\\cdot N_z + z,$$\n其中 $(x,y,z)$ 是从零开始的索引，满足 $0 \\le x  N_x$，$0 \\le y  N_y$，$0 \\le z  N_z$。\n- 列主序（Fortran）线性化由以下公式给出\n$$L_F(x,y,z) = x + N_x \\cdot \\big(y + N_y \\cdot z\\big).$$\n- 一个起始于 $(s_x,s_y,s_z)$、大小为 $(n_x,n_y,n_z)$ 的矩形子数组，在行主序（C语言）下，分解为 $n_x \\cdot n_y$ 个连续块，每个块的长度为 $n_z$ 个元素，块的起始索引为\n$$B_{C}(i,j) = L_C(s_x + i, s_y + j, s_z), \\quad 0 \\le i  n_x, \\quad 0 \\le j  n_y.$$\n- 一个起始于 $(s_x,s_y,s_z)$、大小为 $(n_x,n_y,n_z)$ 的矩形子数组，在列主序（Fortran）下，分解为 $n_y \\cdot n_z$ 个连续块，每个块的长度为 $n_x$ 个元素，块的起始索引为\n$$B_{F}(j,k) = L_F(s_x, s_y + j, s_z + k), \\quad 0 \\le j  n_y, \\quad 0 \\le k  n_z.$$\n\n假设元素大小均为 $e$ 字节（例如，双精度浮点数使用 $e = 8$）。对于下方的每个测试用例，计算：\n1. 块的数量（整数）。\n2. 块长度，以元素为单位（整数）。\n3. 第一个块的起始偏移量，以元素为单位（整数）。\n4. 最后一个块的起始偏移量，以元素为单位（整数）。\n5. 子数组的总字节覆盖范围（整数），该值必须等于 $n_x \\cdot n_y \\cdot n_z \\cdot e$。\n6. 所有块起始偏移量（以元素为单位）之和对素数 $p = 1000003$ 取模的结果，作为整数返回。\n\n您的程序必须生成单行输出，其中包含一个以逗号分隔的列表，并用方括号括起来（例如，$\\texttt{[result1,result2,result3]}$）。每个对应于一个测试用例的 $\\texttt{result}$ 本身必须是按上述顺序排列的整数列表。\n\n测试套件（每个用例为 $(N_x,N_y,N_z)$、$(s_x,s_y,s_z)$、$(n_x,n_y,n_z)$、存储顺序、$e$）：\n- 用例 $1$ （典型路径，行主序，完整的z轴线）：$(64,32,16)$, $(16,8,0)$, $(8,4,16)$, C, $8$。\n- 用例 $2$ （边缘情况，接触z轴上边界，且$n_z$最小）：$(30,20,10)$, $(3,7,9)$, $(2,3,1)$, C, $8$。\n- 用例 $3$ （行主序下沿y轴的薄片）：$(10,10,10)$, $(5,2,3)$, $(1,5,4)$, C, $8$。\n- 用例 $4$ （单进程处理整个域，行主序）：$(4,3,2)$, $(0,0,0)$, $(4,3,2)$, C, $8$。\n- 用例 $5$ （列主序，每块在x轴上完全连续）：$(5,4,3)$, $(1,2,0)$, $(2,1,3)$, F, $8$。\n\n您的实现必须严格遵守上述定义，并为每个测试用例计算所需的整数。程序输出的最后一行必须是单个列表，该列表按测试套件的顺序汇总了每个用例的列表。",
            "solution": "该问题要求计算与一个三维子数组在磁盘上的布局相关的几个属性。该子数组由一个并行进程所有，并位于一个更大的全局三维数组之内。这些属性必须根据子数组到连续块的特定分解方式，针对行主序（C语言）和列主序（Fortran）两种存储顺序进行确定。解决方案涉及直接应用和解析性地评估所提供的线性化公式和块分解规则。\n\n全局数组的维度为 $(N_x, N_y, N_z)$。一个进程拥有一个从 $(s_x, s_y, s_z)$ 开始、范围为 $(n_x, n_y, n_z)$ 的子数组。元素大小为 $e$ 字节。我们必须为每个测试用例计算六个量：（$1$）块的数量，（$2$）块的长度，（$3$）第一个块的起始偏移量，（$4$）最后一个块的起始偏移量，（$5$）总字节覆盖范围，以及（$6$）所有块起始偏移量之和对 $p = 1000003$ 取模的结果。\n\n推导过程通过分别考虑每种存储顺序来进行。\n\n**行主序（C语言）分析**\n\n对于行主序存储，坐标为 $(x, y, z)$ 的元素的线性索引由以下公式给出：\n$$L_C(x,y,z) = \\big((x \\cdot N_y) + y\\big)\\cdot N_z + z$$\n子数组被分解为 $n_x \\cdot n_y$ 个连续块，每个块的长度为 $n_z$ 个元素。由 $(i,j)$（其中 $0 \\le i  n_x$ 且 $0 \\le j  n_y$）索引的块的起始偏移量为：\n$$B_{C}(i,j) = L_C(s_x + i, s_y + j, s_z)$$\n\n所需的六个量推导如下：\n\n1.  **块的数量**：针对C序分解的问题定义明确指出块的数量是 $n_x \\cdot n_y$。\n\n2.  **块长度**：问题定义每个块是子数组沿z轴的连续段。该段的长度是子数组在z方向上的范围，即 $n_z$ 个元素。\n\n3.  **第一个块的起始偏移量**：块的索引从 $(i,j) = (0,0)$ 到 $(n_x-1, n_y-1)$。第一个块对应于 $(i,j) = (0,0)$。其起始偏移量为：\n    $$B_{C}(0,0) = L_C(s_x, s_y, s_z) = \\big((s_x \\cdot N_y) + s_y\\big)\\cdot N_z + s_z$$\n\n4.  **最后一个块的起始偏移量**：最后一个块对应于最大的索引值 $(i,j) = (n_x-1, n_y-1)$。其起始偏移量为：\n    $$B_{C}(n_x-1, n_y-1) = L_C(s_x + n_x - 1, s_y + n_y - 1, s_z)$$\n\n5.  **总字节覆盖范围**：子数组形成一个维度为 $n_x \\times n_y \\times n_z$ 的矩形棱柱。元素总数为 $n_x \\cdot n_y \\cdot n_z$。每个元素占用 $e$ 字节，因此总字节覆盖范围为 $n_x \\cdot n_y \\cdot n_z \\cdot e$。\n\n6.  **所有块起始偏移量之和**：这需要对所有的 $i$ 和 $j$ 求 $B_C(i,j)$ 的和。\n    $$S_C = \\sum_{i=0}^{n_x-1} \\sum_{j=0}^{n_y-1} B_{C}(i,j) = \\sum_{i=0}^{n_x-1} \\sum_{j=0}^{n_y-1} L_C(s_x+i, s_y+j, s_z)$$\n    我们展开 $L_C$ 的表达式：\n    $$L_C(s_x+i, s_y+j, s_z) = \\big(((s_x+i) \\cdot N_y) + (s_y+j)\\big)\\cdot N_z + s_z = (s_x N_y + i N_y + s_y + j) N_z + s_z$$\n    $$= (s_x N_y N_z + s_y N_z + s_z) + i \\cdot (N_y N_z) + j \\cdot N_z = L_C(s_x, s_y, s_z) + i N_y N_z + j N_z$$\n    总和变为：\n    $$S_C = \\sum_{i=0}^{n_x-1} \\sum_{j=0}^{n_y-1} \\big( L_C(s_x, s_y, s_z) + i N_y N_z + j N_z \\big)$$\n    分离各项：\n    $$S_C = (n_x n_y) L_C(s_x, s_y, s_z) + (N_y N_z) \\sum_{j=0}^{n_y-1} \\sum_{i=0}^{n_x-1} i + N_z \\sum_{i=0}^{n_x-1} \\sum_{j=0}^{n_y-1} j$$\n    使用等差数列求和公式 $\\sum_{k=0}^{m-1} k = \\frac{m(m-1)}{2}$：\n    $$S_C = (n_x n_y) L_C(s_x, s_y, s_z) + (N_y N_z) n_y \\frac{n_x(n_x-1)}{2} + N_z n_x \\frac{n_y(n_y-1)}{2}$$\n    这个封闭形式的表达式可以进行高效计算。最终结果是此和对 $p = 1000003$ 取模。\n\n**列主序（Fortran）分析**\n\n对于列主序存储，线性索引由以下公式给出：\n$$L_F(x,y,z) = x + N_x \\cdot \\big(y + N_y \\cdot z\\big)$$\n子数组被分解为 $n_y \\cdot n_z$ 个连续块，每个块的长度为 $n_x$ 个元素。由 $(j,k)$（其中 $0 \\le j  n_y$ 且 $0 \\le k  n_z$）索引的块的起始偏移量为：\n$$B_{F}(j,k) = L_F(s_x, s_y + j, s_z + k)$$\n\n所需的六个量推导如下：\n\n1.  **块的数量**：针对Fortran序分解的定义给出的块数量为 $n_y \\cdot n_z$。\n\n2.  **块长度**：每个块是沿x轴的连续段，因此其长度为 $n_x$ 个元素。\n\n3.  **第一个块的起始偏移量**：第一个块对应于 $(j,k) = (0,0)$。其起始偏移量为：\n    $$B_{F}(0,0) = L_F(s_x, s_y, s_z) = s_x + N_x \\cdot (s_y + N_y \\cdot s_z)$$\n\n4.  **最后一个块的起始偏移量**：最后一个块对应于 $(j,k) = (n_y-1, n_z-1)$。其起始偏移量为：\n    $$B_{F}(n_y-1, n_z-1) = L_F(s_x, s_y + n_y - 1, s_z + n_z - 1)$$\n\n5.  **总字节覆盖范围**：这与存储顺序无关，仍然是 $n_x \\cdot n_y \\cdot n_z \\cdot e$。\n\n6.  **所有块起始偏移量之和**：这需要对所有的 $j$ 和 $k$ 求 $B_F(j,k)$ 的和。\n    $$S_F = \\sum_{j=0}^{n_y-1} \\sum_{k=0}^{n_z-1} B_{F}(j,k) = \\sum_{j=0}^{n_y-1} \\sum_{k=0}^{n_z-1} L_F(s_x, s_y+j, s_z+k)$$\n    展开 $L_F$ 的表达式：\n    $$L_F(s_x, s_y+j, s_z+k) = s_x + N_x \\big((s_y+j) + N_y(s_z+k)\\big) = s_x + N_x s_y + j N_x + N_x N_y s_z + k N_x N_y$$\n    $$= (s_x + N_x s_y + N_x N_y s_z) + j N_x + k N_x N_y = L_F(s_x, s_y, s_z) + j N_x + k N_x N_y$$\n    总和变为：\n    $$S_F = \\sum_{j=0}^{n_y-1} \\sum_{k=0}^{n_z-1} \\big( L_F(s_x, s_y, s_z) + j N_x + k N_x N_y \\big)$$\n    分离各项并使用等差数列求和公式：\n    $$S_F = (n_y n_z) L_F(s_x, s_y, s_z) + N_x n_z \\sum_{j=0}^{n_y-1} j + (N_x N_y) n_y \\sum_{k=0}^{n_z-1} k$$\n    $$S_F = (n_y n_z) L_F(s_x, s_y, s_z) + (N_x n_z) \\frac{n_y(n_y-1)}{2} + (N_x N_y n_y) \\frac{n_z(n_z-1)}{2}$$\n    最终结果是此和对 $p = 1000003$ 取模。\n\n这些推导出的公式被实现以解决给定的测试套件。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes subarray decomposition properties for parallel I/O.\n    \"\"\"\n    # The prime modulus for the sum of offsets calculation.\n    p = 1000003\n\n    def L_C(x, y, z, Ny, Nz):\n        \"\"\"Computes the linear index for row-major (C) order.\"\"\"\n        return ((x * Ny) + y) * Nz + z\n\n    def L_F(x, y, z, Nx, Ny):\n        \"\"\"Computes the linear index for column-major (Fortran) order.\"\"\"\n        return x + Nx * (y + Ny * z)\n\n    def solve_c_order(N_dims, s_dims, n_dims, e):\n        \"\"\"Calculates the 6 required quantities for a C-order case.\"\"\"\n        Nx, Ny, Nz = N_dims\n        sx, sy, sz = s_dims\n        nx, ny, nz = n_dims\n\n        # 1. Number of blocks: Defined as nx * ny for C-order.\n        num_blocks = nx * ny\n\n        # 2. Block length: Defined as nz for C-order.\n        block_length = nz\n\n        # 3. First block start offset: Corresponds to block (i=0, j=0).\n        first_block_start = L_C(sx, sy, sz, Ny, Nz)\n\n        # 4. Last block start offset: Corresponds to block (i=nx-1, j=ny-1).\n        last_block_start = L_C(sx + nx - 1, sy + ny - 1, sz, Ny, Nz)\n\n        # 5. Total byte coverage: Volume of the subarray times element size.\n        total_byte_coverage = nx * ny * nz * e\n\n        # 6. Sum of all block start offsets mod p, using the derived analytic formula.\n        # S = (nx*ny)*L_C(sx,sy,sz) + (Ny*Nz*ny)*nx*(nx-1)/2 + (Nz*nx)*ny*(ny-1)/2\n        term1 = num_blocks * first_block_start\n        term2 = (Ny * Nz * ny) * (nx * (nx - 1) // 2)\n        term3 = (Nz * nx) * (ny * (ny - 1) // 2)\n        \n        sum_of_offsets = (term1 + term2 + term3) % p\n        \n        return [num_blocks, block_length, first_block_start, last_block_start, total_byte_coverage, sum_of_offsets]\n\n    def solve_f_order(N_dims, s_dims, n_dims, e):\n        \"\"\"Calculates the 6 required quantities for a Fortran-order case.\"\"\"\n        Nx, Ny, Nz = N_dims\n        sx, sy, sz = s_dims\n        nx, ny, nz = n_dims\n        \n        # 1. Number of blocks: Defined as ny * nz for F-order.\n        num_blocks = ny * nz\n\n        # 2. Block length: Defined as nx for F-order.\n        block_length = nx\n\n        # 3. First block start offset: Corresponds to block (j=0, k=0).\n        first_block_start = L_F(sx, sy, sz, Nx, Ny)\n\n        # 4. Last block start offset: Corresponds to block (j=ny-1, k=nz-1).\n        last_block_start = L_F(sx, sy + ny - 1, sz + nz - 1, Nx, Ny)\n\n        # 5. Total byte coverage: Volume of the subarray times element size.\n        total_byte_coverage = nx * ny * nz * e\n\n        # 6. Sum of all block start offsets mod p, using the derived analytic formula.\n        # S = (ny*nz)*L_F(sx,sy,sz) + (Nx*nz)*ny*(ny-1)/2 + (Nx*Ny*ny)*nz*(nz-1)/2\n        term1 = num_blocks * first_block_start\n        term2 = (Nx * nz) * (ny * (ny - 1) // 2)\n        term3 = (Nx * Ny * ny) * (nz * (nz - 1) // 2)\n\n        sum_of_offsets = (term1 + term2 + term3) % p\n        \n        return [num_blocks, block_length, first_block_start, last_block_start, total_byte_coverage, sum_of_offsets]\n\n    # Test cases as defined in the problem statement.\n    # Format: ( (Nx,Ny,Nz), (sx,sy,sz), (nx,ny,nz), storage_order, element_size_e )\n    test_cases = [\n        ((64, 32, 16), (16, 8, 0), (8, 4, 16), 'C', 8),\n        ((30, 20, 10), (3, 7, 9), (2, 3, 1), 'C', 8),\n        ((10, 10, 10), (5, 2, 3), (1, 5, 4), 'C', 8),\n        ((4, 3, 2), (0, 0, 0), (4, 3, 2), 'C', 8),\n        ((5, 4, 3), (1, 2, 0), (2, 1, 3), 'F', 8)\n    ]\n    \n    results = []\n    for case in test_cases:\n        N_dims, s_dims, n_dims, order, e = case\n        if order == 'C':\n            result = solve_c_order(N_dims, s_dims, n_dims, e)\n        elif order == 'F':\n            result = solve_f_order(N_dims, s_dims, n_dims, e)\n        else:\n            # This path should not be taken with the given test cases.\n            raise ValueError(\"Invalid storage order specified.\")\n        results.append(result)\n        \n    # Format the final output as a string representing a list of lists, with no spaces.\n    # e.g., [[val1,val2],[val3,val4]]\n    output_str = str(results).replace(\" \", \"\")\n\n    # Final print statement in the exact required format.\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在独立I/O和集体I/O之间做出选择是一项关键的性能决策。这个练习将引导你从定性分析转向定量分析，要求你建立一个简单但功能强大的性能模型。通过基于单次请求开销和持续带宽计算总写入时间，你将具体地理解为何以及何时集体I/O的请求合并策略能够克服写入大量小数据块所带来的高延迟成本。",
            "id": "4026071",
            "problem": "一个用于聚变等离子体的回旋动理学湍流代码，在结构化网格上演化一个分布函数，并定期将全局检查点写入并行文件系统（PFS）。该作业使用 $P=512$ 个消息传递接口（MPI）进程。全局检查点大小为 $S=2\\,\\mathrm{TB}$，每次写入系统调用以大小为 $r=64\\,\\mathrm{KB}$ 的固定大小块进行写入。假设 I/O 系统具有以下特征：由于元数据和远程过程调用处理，每个输入/输出（I/O）请求在存储接口处产生 $\\alpha=100\\,\\mu\\mathrm{s}$ 的固定单次请求开销，并且当作业使存储服务器饱和时，作业观察到的端到端可持续 PFS 带宽为 $b=300\\,\\mathrm{MB/s}$。再进一步假设，单次请求开销在存储接口处是串行化的（即它们不重叠），而批量数据传输以可持续带宽 $b$进行；与存储端成本相比，计算端的互连和聚合开销可以忽略不计；存储系统已饱和，因此总数据传输时间仅取决于 $S$ 和 $b$；集体 I/O 通过将 $A$ 个相邻的块写入完美合并为一个存储请求，从而将存储 I/O 请求的数量减少了聚合因子 $A=8$，且不改变总数据量。\n\n对两种策略进行建模：\n1. 独立 I/O：每个进程直接向 PFS 发出自己的大小为 $r$ 的写入操作。\n2. 集体 I/O：在聚合器上使用完美聚合因子 $A=8$ 的两阶段 I/O。\n\n将 $\\mathrm{KB}$、$\\mathrm{MB}$ 和 $\\mathrm{TB}$ 解读为二进制单位（kibibyte, mebibyte, tebibyte）。仅使用上述假设以及关于固定单次请求开销和可持续批量带宽的基本原理，推导出独立 I/O 和集体 I/O 下的总墙上时钟写入时间。然后计算独立 I/O 时间与集体 I/O 时间之比。将最终比率四舍五入到四位有效数字，并表示为一个无单位的纯数。",
            "solution": "该问题陈述已经过验证，被认为是有效的。它在科学上基于标准的 I/O 性能建模，问题设定良好，数据充分且一致，并以客观、正式的语言表述。我们可以开始求解。\n\n写入检查点的总墙上时钟时间 $T$ 被建模为两个部分之和：由单次请求延迟产生的总开销时间 $T_{overhead}$，以及批量数据传输的总时间 $T_{transfer}$。\n$$T = T_{overhead} + T_{transfer}$$\n问题陈述中提到“单次请求开销在存储接口处是串行化的”。这意味着总开销时间是请求数量 $N_{req}$ 与单次请求开销 $\\alpha$ 的乘积。\n$$T_{overhead} = N_{req} \\alpha$$\n问题还陈述“总数据传输时间仅取决于 $S$ 和 $b$”。这意味着批量数据传输时间是总数据大小 $S$ 除以可持续带宽 $b$。这个部分与 I/O 策略（独立 vs. 集体）无关，因为在这两种情况下，传输到饱和系统的总数据量是相同的。\n$$T_{transfer} = \\frac{S}{b}$$\n因此，总写入时间的一般模型为：\n$$T = N_{req} \\alpha + \\frac{S}{b}$$\n我们首先将给定的量转换为一组一致的基本单位（大小用字节，时间用秒）。问题指明 $\\mathrm{KB}$、$\\mathrm{MB}$ 和 $\\mathrm{TB}$ 是二进制单位（kibibyte, mebibyte, tebibyte）。\n- 全局检查点大小: $S = 2\\,\\mathrm{TB} = 2 \\times (2^{10})^4\\,\\text{bytes} = 2 \\times 2^{40}\\,\\text{bytes} = 2^{41}\\,\\text{bytes}$。\n- 数据块大小: $r = 64\\,\\mathrm{KB} = 64 \\times 2^{10}\\,\\text{bytes} = 2^6 \\times 2^{10}\\,\\text{bytes} = 2^{16}\\,\\text{bytes}$。\n- 单次请求开销: $\\alpha = 100\\,\\mu\\mathrm{s} = 100 \\times 10^{-6}\\,\\mathrm{s} = 10^{-4}\\,\\mathrm{s}$。\n- 可持续带宽: $b = 300\\,\\mathrm{MB/s} = 300 \\times (2^{10})^2\\,\\text{bytes/s} = 300 \\times 2^{20}\\,\\text{bytes/s}$。\n- 聚合因子: $A = 8 = 2^3$。\nMPI 进程数 $P=512$ 不直接参与计算，因为假设开销在存储接口处串行化，使得总开销时间仅取决于应用程序生成的总请求数，而与这些请求如何在进程间分布无关。\n\n首先，我们计算构成全局检查点的总块数 $N_{chunks}$。\n$$N_{chunks} = \\frac{S}{r} = \\frac{2^{41}\\,\\text{bytes}}{2^{16}\\,\\text{bytes}} = 2^{41-16} = 2^{25}$$\n\n接下来，我们分析两种 I/O 策略。\n\n策略 1：独立 I/O\n在此策略中，每个进程发出自己的写入操作。由于没有聚合，每个大小为 $r$ 的块写入对应一个存储 I/O 请求。因此，总请求数 $N_{req, ind}$ 等于总块数。\n$$N_{req, ind} = N_{chunks} = 2^{25}$$\n独立 I/O 的总时间 $T_{ind}$ 为：\n$$T_{ind} = N_{req, ind} \\alpha + \\frac{S}{b} = \\left(\\frac{S}{r}\\right)\\alpha + \\frac{S}{b}$$\n\n策略 2：集体 I/O\n在此策略中，集体 I/O 机制将 $A$ 个块写入合并成一个更大的单一存储请求。这将发送到存储系统的总请求数减少了因子 $A$。\n$$N_{req, coll} = \\frac{N_{chunks}}{A} = \\frac{2^{25}}{8} = \\frac{2^{25}}{2^3} = 2^{22}$$\n集体 I/O 的总时间 $T_{coll}$ 为：\n$$T_{coll} = N_{req, coll} \\alpha + \\frac{S}{b} = \\left(\\frac{S}{rA}\\right)\\alpha + \\frac{S}{b}$$\n\n我们需要计算独立 I/O 时间与集体 I/O 时间之比。\n$$ \\text{Ratio} = \\frac{T_{ind}}{T_{coll}} = \\frac{(S/r)\\alpha + S/b}{(S/rA)\\alpha + S/b} $$\n现在我们代入数值。首先，我们计算两个时间分量：独立 I/O 的开销分量和公共的传输分量。\n$$ T_{overhead, ind} = N_{req, ind} \\alpha = 2^{25} \\times 10^{-4}\\,\\mathrm{s} = 33,554,432 \\times 10^{-4}\\,\\mathrm{s} = 3355.4432\\,\\mathrm{s} $$\n$$ T_{transfer} = \\frac{S}{b} = \\frac{2^{41}\\,\\text{bytes}}{300 \\times 2^{20}\\,\\text{bytes/s}} = \\frac{2^{21}}{300}\\,\\mathrm{s} = \\frac{2,097,152}{300}\\,\\mathrm{s} \\approx 6990.5067\\,\\mathrm{s} $$\n集体 I/O 的开销分量是：\n$$ T_{overhead, coll} = N_{req, coll} \\alpha = 2^{22} \\times 10^{-4}\\,\\mathrm{s} = 4,194,304 \\times 10^{-4}\\,\\mathrm{s} = 419.4304\\,\\mathrm{s} $$\n注意 $T_{overhead, coll} = T_{overhead, ind} / A = 3355.4432 / 8 = 419.4304\\,\\mathrm{s}$。\n\n现在我们可以计算每种策略的总时间。\n$$T_{ind} = T_{overhead, ind} + T_{transfer} \\approx 3355.4432\\,\\mathrm{s} + 6990.5067\\,\\mathrm{s} \\approx 10345.9499\\,\\mathrm{s}$$\n$$T_{coll} = T_{overhead, coll} + T_{transfer} \\approx 419.4304\\,\\mathrm{s} + 6990.5067\\,\\mathrm{s} \\approx 7409.9371\\,\\mathrm{s}$$\n最后，我们计算比率：\n$$ \\text{Ratio} = \\frac{T_{ind}}{T_{coll}} \\approx \\frac{10345.9499}{7409.9371} \\approx 1.3962260 $$\n将结果四舍五入到四位有效数字，得到 $1.396$。",
            "answer": "$$\\boxed{1.396}$$"
        },
        {
            "introduction": "另一种缓解I/O压力的强大技术是减少写入磁盘的数据量。本练习探讨了在线数据压缩，即在数据写入前进行实时压缩。你将把这个过程建模为一个两阶段流水线，并学习如何识别决定整体性能的瓶颈，这是在任何高性能计算环境中设计高效数据处理工作流的一项关键技能。",
            "id": "4026026",
            "problem": "一次磁化等离子体湍流的直接数值模拟在一个时间窗口结束时，产生了一个大小为 $S=4\\,\\mathrm{TB}$ 的三维标量场。该场被写入一个并行文件系统（PFS; Parallel File System），其持续聚合带宽为 $6\\,\\mathrm{GB/s}$。为减少 I/O 数据量，在写入前，计算节点上应用了一个在线无损压缩器，实现了 $\\rho=8$ 的压缩比，并在中央处理器（CPU; central processing unit）上获得了 $2\\,\\mathrm{GB/s}$ 的持续端到端压缩吞吐率。假设采用一个带有双缓冲的两阶段流式管线，允许在稳态下压缩与 PFS 写入之间实现完美重叠，并假设元数据和同步延迟与批量传输相比可以忽略不计。\n\n仅使用以下基本定义：(i) 吞吐率是单位时间的字节数，(ii) 压缩比 $\\rho$ 将输入大小 $S$ 映射为输出大小 $S/\\rho$，以及 (iii) 对于足够大的 $S$，在完美重叠的两阶段管线中，墙上时钟完成时间由较慢的阶段决定。请推导启用压缩时完成写入所需的墙上时钟时间。然后，将 CPU 开销定义为管线墙上时钟时间内 CPU 压缩无法被并发 PFS 写入所隐藏的部分所占的比例，并计算该比例。\n\n使用以 10 为底的单位，其中 $1\\,\\mathrm{TB}=10^{12}\\,\\mathrm{bytes}$，$1\\,\\mathrm{GB/s}=10^{9}\\,\\mathrm{bytes/s}$。将墙上时钟时间以秒表示，开销以无量纲小数表示。将两个量均四舍五入至四位有效数字。将您的最终答案以行矩阵 $\\begin{pmatrix} T_{\\mathrm{total}}  O \\end{pmatrix}$ 的形式报告，其中 $T_{\\mathrm{total}}$ 是启用压缩时的墙上时钟时间，$O$ 是如上定义的 CPU 开销比例。",
            "solution": "首先验证问题，以确保其科学上合理、定义明确且客观。\n\n**步骤 1：提取已知条件**\n- 未压缩数据大小：$S = 4\\,\\mathrm{TB}$\n- 并行文件系统 (PFS) 聚合带宽：$B_w = 6\\,\\mathrm{GB/s}$\n- 无损压缩比：$\\rho = 8$\n- 持续压缩吞吐率：$B_c = 2\\,\\mathrm{GB/s}$\n- 管线模型：一个带有双缓冲和完美重叠的两阶段流式管线（压缩和写入）。\n- 假设：元数据和同步延迟可忽略不计。\n- 定义 (i)：吞吐率是单位时间的字节数。\n- 定义 (ii)：压缩比 $\\rho$ 将输入大小 $S$ 映射为输出大小 $S/\\rho$。\n- 定义 (iii)：在完美重叠的管线中，墙上时钟完成时间由较慢的阶段决定。\n- CPU 开销的定义：管线墙上时钟时间内 CPU 压缩无法被并发 PFS 写入所隐藏的部分所占的比例。\n- 单位转换：$1\\,\\mathrm{TB} = 10^{12}\\,\\mathrm{bytes}$，$1\\,\\mathrm{GB/s} = 10^{9}\\,\\mathrm{bytes/s}$。\n- 输出要求：报告墙上时钟时间 $T_{\\mathrm{total}}$ 和 CPU 开销比例 $O$，四舍五入至四位有效数字。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题在科学上是合理的，基于计算机科学和高性能计算的标准原理（I/O 性能、管线化、瓶颈）。该问题定义明确，为得到唯一解提供了所有必要的数据和定义。语言客观而精确。给定的参数（$S$, $B_w$, $B_c$, $\\rho$）对于大规模科学模拟是切合实际的。完美重叠和可忽略延迟的假设是此类性能建模问题的标准简化。该问题有效。\n\n**步骤 3：结论与行动**\n该问题被认定为有效。将提供完整的解答。\n\n**解答推导**\n\n首先，我们将所有给定数量转换为以字节和字节/秒为基本单位，以确保计算的一致性。\n未压缩数据大小为 $S = 4\\,\\mathrm{TB} = 4 \\times 10^{12}\\,\\mathrm{bytes}$。\n压缩吞吐率为 $B_c = 2\\,\\mathrm{GB/s} = 2 \\times 10^{9}\\,\\mathrm{bytes/s}$。\nPFS 写入带宽为 $B_w = 6\\,\\mathrm{GB/s} = 6 \\times 10^{9}\\,\\mathrm{bytes/s}$。\n压缩比是一个无量纲量，$\\rho = 8$。\n\n该过程被建模为一个两阶段管线：\n阶段 1：压缩。此阶段以 $B_c$ 的吞吐率处理大小为 $S$ 的原始数据。如果单独运行，此阶段完成所需的时间为 $T_c$。\n$$T_c = \\frac{S}{B_c}$$\n阶段 2：写入。此阶段处理压缩后的数据。压缩后数据的大小为 $S' = S/\\rho$。此阶段以 PFS 写入带宽 $B_w$ 运行。如果单独运行，此阶段完成所需的时间为 $T_w$。\n$$T_w = \\frac{S'}{B_w} = \\frac{S/\\rho}{B_w} = \\frac{S}{\\rho B_w}$$\n\n根据问题陈述，对于一个完美重叠的两阶段管线，总墙上时钟时间 $T_{\\mathrm{total}}$ 由瓶颈决定，即两个阶段中较慢的那个。\n$$T_{\\mathrm{total}} = \\max(T_c, T_w)$$\n\n我们现在代入数值来确定每个阶段的持续时间并识别瓶颈。\n$$T_c = \\frac{4 \\times 10^{12}\\,\\mathrm{bytes}}{2 \\times 10^{9}\\,\\mathrm{bytes/s}} = 2000\\,\\mathrm{s}$$\n$$T_w = \\frac{4 \\times 10^{12}\\,\\mathrm{bytes}}{8 \\times (6 \\times 10^{9}\\,\\mathrm{bytes/s})} = \\frac{4 \\times 10^{12}\\,\\mathrm{bytes}}{48 \\times 10^{9}\\,\\mathrm{bytes/s}} = \\frac{1}{12} \\times 10^3\\,\\mathrm{s} \\approx 83.33\\,\\mathrm{s}$$\n\n比较这两个时间，我们发现 $T_c  T_w$ ($2000\\,\\mathrm{s}  83.33\\,\\mathrm{s}$)。因此，压缩阶段是瓶颈。完成写入的总墙上时钟时间由压缩时间决定。\n$$T_{\\mathrm{total}} = T_c = 2000\\,\\mathrm{s}$$\n问题要求将此值四舍五入至四位有效数字。为了用四位有效数字表示 $2000$，我们使用科学记数法：$2.000 \\times 10^3\\,\\mathrm{s}$。\n\n接下来，我们计算 CPU 开销比例 $O$。这被定义为在总管线时间内，CPU 压缩无法被并发 PFS 写入所隐藏的时间所占的比例。CPU 用于压缩的总活动时间是 $T_c$。PFS 用于写入的总活动时间是 $T_w$。由于管线重叠，被并发 I/O 活动“隐藏”的 CPU 时间量等于较快阶段的持续时间，即 $T_w$。未被“隐藏”的 CPU 时间是 I/O 系统空闲时 CPU 工作的时间，即差值 $T_c - T_w$ (因为 $T_c  T_w$)。\n\n开销比例 $O$ 是这个未隐藏时间与总管线墙上时钟时间 $T_{\\mathrm{total}}$ 的比率。\n$$O = \\frac{\\text{unhidden CPU time}}{T_{\\mathrm{total}}} = \\frac{T_c - T_w}{T_{\\mathrm{total}}}$$\n由于压缩阶段是瓶颈，所以 $T_{\\mathrm{total}} = T_c$。\n$$O = \\frac{T_c - T_w}{T_c} = 1 - \\frac{T_w}{T_c}$$\n我们可以代入 $T_c$ 和 $T_w$ 的符号表达式，以找到此瓶颈情况下的开销通用公式。\n$$O = 1 - \\frac{S/(\\rho B_w)}{S/B_c} = 1 - \\frac{B_c}{\\rho B_w}$$\n代入数值：\n$$O = 1 - \\frac{2 \\times 10^{9}\\,\\mathrm{bytes/s}}{8 \\times (6 \\times 10^{9}\\,\\mathrm{bytes/s})} = 1 - \\frac{2}{48} = 1 - \\frac{1}{24} = \\frac{23}{24}$$\n作为小数，此值为 $O \\approx 0.958333...$。四舍五入至四位有效数字得到：\n$$O = 0.9583$$\n\n最终答案包含墙上时钟时间 $T_{\\mathrm{total}}$ 和开销比例 $O$，以行矩阵形式报告。\n$T_{\\mathrm{total}} = 2.000 \\times 10^3$ 秒。\n$O = 0.9583$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2.000 \\times 10^{3}  0.9583\n\\end{pmatrix}\n}\n$$"
        }
    ]
}