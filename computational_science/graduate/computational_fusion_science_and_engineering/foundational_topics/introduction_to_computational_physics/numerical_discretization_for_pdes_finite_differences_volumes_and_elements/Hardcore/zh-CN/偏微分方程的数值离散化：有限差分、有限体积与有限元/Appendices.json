{
    "hands_on_practices": [
        {
            "introduction": "许多数值方法的基石在于如何精确地逼近微分算子。本练习  将指导你完成一项关键的推导：在非均匀网格上构建二阶导数的有限差分格式。在需要网格加密的真实世界模拟中，非均匀网格是一种常见情况。这项练习不仅能提升你运用泰勒级数进行分析的技巧，还能揭示网格的非均匀性如何影响数值格式的精度。",
            "id": "4022699",
            "problem": "在磁约束聚变等离子体的平行热传导建模中，沿磁力线参数 $s$ 的温度场 $T(s,t)$ 满足形式为 $\\partial T/\\partial t = \\partial/\\partial s \\left( \\kappa_{\\parallel}(s) \\, \\partial T/\\partial s \\right)$ 的一维偏微分方程 (PDE)，其中 $\\kappa_{\\parallel}(s)$ 是平行热导率。高保真计算聚变科学与工程求解器通常沿 $s$ 方向采用非均匀网格，以解析偏滤器靶板附近和强磁通扩展区域中的陡峭梯度。考虑三个连续的网格点 $s_{i-1}$、$s_i$ 和 $s_{i+1}$，其局部间距为 $h_{i-1} = s_i - s_{i-1}$ 和 $h_i = s_{i+1} - s_i$，这些间距无需相等。\n\n从一阶和二阶导数的定义出发，使用 $T(s)$ 在 $s_i$ 点的泰勒级数展开至足够高的阶数，构建一个三点有限差分公式，该公式仅根据 $T_{i-1} = T(s_{i-1})$、$T_i = T(s_i)$ 和 $T_{i+1} = T(s_{i+1})$ 以及局部间距 $h_{i-1}$ 和 $h_i$ 来近似此非均匀网格上的二阶导数 $T''(s_i)$。然后，推导并给出主截断误差项，将其明确表示为 $h_{i-1}$、$h_i$ 以及在 $s_i$ 点计算的 T 的导数的函数。\n\n您的最终答案必须包含离散二阶导数近似的单个解析表达式和其主截断误差项的单个解析表达式，两者共同以单行矩阵的形式呈现。无需进行数值计算，也无需四舍五入。最终答案中请勿包含物理单位。",
            "solution": "用户提供了一个来自计算科学与工程领域的有效且适定的问题陈述。任务是推导非均匀网格上二阶导数的三点有限差分公式及其相关的主截断误差。这是数值分析中的一个标准且可验证的推导。\n\n目标是利用三个非均匀间隔点 $T_{i-1} = T(s_{i-1})$、$T_i = T(s_i)$ 和 $T_{i+1} = T(s_{i+1})$ 处的函数值，求出函数 $T(s)$ 在点 $s_i$ 的二阶导数（记为 $T''(s_i)$）的近似值。间距定义为 $h_{i-1} = s_i - s_{i-1}$ 和 $h_i = s_{i+1} - s_i$。推导过程利用 $T(s)$ 在点 $s_i$ 附近的泰勒级数展开。\n\n首先，我们写出 $T(s_{i+1})$ 在 $s_i$ 点的泰勒级数展开。位移为 $s_{i+1} - s_i = h_i$。\n$$T_{i+1} = T(s_i + h_i) = T(s_i) + h_i T'(s_i) + \\frac{h_i^2}{2!} T''(s_i) + \\frac{h_i^3}{3!} T'''(s_i) + O(h_i^4)$$\n为清晰起见，我们使用简写符号 $T_j = T(s_j)$ 并省略导数的求值点 $s_i$，可得：\n$$T_{i+1} = T_i + h_i T' + \\frac{h_i^2}{2} T'' + \\frac{h_i^3}{6} T''' + \\dots \\quad (1)$$\n\n接下来，我们写出 $T(s_{i-1})$ 在 $s_i$ 点的泰勒级数展开。位移为 $s_{i-1} - s_i = -h_{i-1}$。\n$$T_{i-1} = T(s_i - h_{i-1}) = T(s_i) - h_{i-1} T'(s_i) + \\frac{(-h_{i-1})^2}{2!} T''(s_i) + \\frac{(-h_{i-1})^3}{3!} T'''(s_i) + O(h_{i-1}^4)$$\n$$T_{i-1} = T_i - h_{i-1} T' + \\frac{h_{i-1}^2}{2} T'' - \\frac{h_{i-1}^3}{6} T''' + \\dots \\quad (2)$$\n\n我们的目标是构造方程 $(1)$ 和 $(2)$ 的线性组合，以消去一阶导数项 $T'$，并求解二阶导数项 $T''$。我们可以重新整理方程 $(1)$ 和 $(2)$ 来表示一阶导数：\n由 $(1)$ 得：\n$$h_i T' = T_{i+1} - T_i - \\frac{h_i^2}{2} T'' - \\frac{h_i^3}{6} T''' - \\dots$$\n由 $(2)$ 得：\n$$h_{i-1} T' = T_i - T_{i-1} + \\frac{h_{i-1}^2}{2} T'' - \\frac{h_{i-1}^3}{6} T''' + \\dots$$\n\n为了消去 $T'$，我们可以写出：\n$$T' = \\frac{T_{i+1} - T_i}{h_i} - \\frac{h_i}{2} T'' - \\frac{h_i^2}{6} T''' - \\dots$$\n$$T' = \\frac{T_i - T_{i-1}}{h_{i-1}} + \\frac{h_{i-1}}{2} T'' - \\frac{h_{i-1}^2}{6} T''' + \\dots$$\n\n令这两个 $T'$ 的表达式相等，可得：\n$$\\frac{T_{i+1} - T_i}{h_i} - \\frac{h_i}{2} T'' - \\dots = \\frac{T_i - T_{i-1}}{h_{i-1}} + \\frac{h_{i-1}}{2} T'' - \\dots$$\n\n重新整理以求解 $T''$：\n$$\\frac{T_{i+1} - T_i}{h_i} - \\frac{T_i - T_{i-1}}{h_{i-1}} = \\left(\\frac{h_i}{2} + \\frac{h_{i-1}}{2}\\right)T'' + \\left(\\frac{h_i^2}{6} - \\frac{h_{i-1}^2}{6}\\right)T''' + \\dots$$\n$$\\frac{T_{i+1} - T_i}{h_i} - \\frac{T_i - T_{i-1}}{h_{i-1}} = \\frac{h_i + h_{i-1}}{2} T'' + \\frac{h_i^2 - h_{i-1}^2}{6} T''' + \\dots$$\n\n求解 $T''$，我们得到：\n$$T'' = \\frac{2}{h_i + h_{i-1}} \\left( \\frac{T_{i+1} - T_i}{h_i} - \\frac{T_i - T_{i-1}}{h_{i-1}} \\right) - \\frac{h_i^2 - h_{i-1}^2}{3(h_i + h_{i-1})} T''' - \\dots$$\n$$T'' = \\frac{2}{h_i + h_{i-1}} \\left( \\frac{T_{i+1} - T_i}{h_i} - \\frac{T_i - T_{i-1}}{h_{i-1}} \\right) - \\frac{h_i - h_{i-1}}{3} T''' - \\dots$$\n\n$T''(s_i)$ 的有限差分近似是等式右边的第一项。这个表达式在物理上是直观的，因为它表示由有效网格间距 $\\frac{1}{2}(h_i+h_{i-1})$ 归一化的有限差分一阶导数的空间导数。\n$$T''(s_i) \\approx \\frac{2}{h_i + h_{i-1}} \\left( \\frac{T_{i+1} - T_i}{h_i} - \\frac{T_i - T_{i-1}}{h_{i-1}} \\right)$$\n\n截断误差 $\\tau_i$ 定义为离散算子与作用于精确解的连续算子之差，即 $\\tau_i = T''(s_i)_{\\text{approx}} - T''(s_i)$。根据我们的推导：\n$$T''(s_i)_{\\text{approx}} = T''(s_i) + \\frac{h_i - h_{i-1}}{3} T'''(s_i) + O(h^2, h_{i-1}h_i, \\dots)$$\n因此，主截断误差项为：\n$$\\tau_{i, \\text{leading}} = \\frac{1}{3}(h_i - h_{i-1}) T'''(s_i)$$\n\n该误差项表明，在 $h_i \\neq h_{i-1}$ 的一般非均匀网格上，该近似是一阶精确的，即 $O(\\max(h_i, h_{i-1}))$。如果网格是均匀的，使得 $h_i = h_{i-1} = h$，则主误差项消失。在这种特殊情况下，必须将泰勒级数展开到更高一阶才能找到新的主误差项，即 $\\frac{h^2}{12}T^{(4)}(s_i)$，这导致了标准中心差分格式众所周知的二阶精度。由于问题指定的是可能非均匀的网格，因此一阶项是正确的主误差项。\n\n为了将近似公式表示为单个解析表达式，我们可以将各项合并为单个分数：\n$$\\frac{2}{h_i + h_{i-1}} \\left( \\frac{h_{i-1}(T_{i+1} - T_i) - h_i(T_i - T_{i-1})}{h_i h_{i-1}} \\right) = \\frac{2(h_{i-1}T_{i+1} - (h_i+h_{i-1})T_i + h_i T_{i-1})}{h_i h_{i-1} (h_i + h_{i-1})}$$\n然而，基于差分的差分的形式是标准的，并且由于其与底层物理和数学的清晰联系而通常更受青睐。两者是等价的。\n最终答案的第一部分是 $T''(s_i)$ 的近似，第二部分是主截断误差项。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{2}{h_{i-1}+h_i} \\left( \\frac{T_{i+1}-T_i}{h_i} - \\frac{T_i-T_{i-1}}{h_{i-1}} \\right)  \\frac{1}{3} (h_i - h_{i-1}) T'''(s_i)\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在掌握了基本算子的构建之后，下一步是建立完整的求解器。本练习  要求你针对同一个一维扩散问题，实现并比较三种核心的离散化技术：有限差分法 (FDM)、有限体积法 (FVM) 和有限元法 (FEM)。通过采用“精确解方法”(Method of Manufactured Solutions)，你将能够严格验证代码的正确性，并直接比较这些基本方法的性能与精度。",
            "id": "4022645",
            "problem": "考虑在区间 $[0,1]$ 上的稳态一维扩散问题，该问题由通量守恒定律给出，其中未知标量场 $u(x)$ 满足守恒形式的线性常微分方程，\n$$-\\frac{d}{dx}\\left(\\kappa(x)\\,\\frac{du}{dx}\\right)=f(x),$$\n边界条件为狄利克雷（Dirichlet）边界条件 $u(0)=u_0$ 和 $u(1)=u_1$。设空间变化的传导系数为 $\\kappa(x)=e^x$，并选择解析解 $u^\\star(x)=\\sin(\\pi x)$，这使得 $u_0=\\sin(\\pi\\cdot 0)=0$ 且 $u_1=\\sin(\\pi\\cdot 1)=0$。通过将 $u^\\star(x)$ 直接代入控制方程，源项 $f(x)$ 由 $u^\\star(x)$ 是精确解的要求唯一确定。三角函数中的角度必须以弧度为单位处理。\n\n您的任务是：\n\n1. 从守恒定律的积分形式和数值近似的标准定义出发，推导在均匀网格上的二阶精确中心有限差分法。该网格将 $[0,1]$ 等分为 $N$ 个子区间，网格间距为 $h=1/N$，节点为 $x_i=i\\,h$，其中整数 $i\\in\\{0,1,\\dots,N\\}$。在单元面上使用中点值评估材料属性，在 $x=0$ 和 $x=1$ 处强施加边界条件，并在内部节点处使用 $f(x)$ 的逐点近似。\n\n2. 从相同的积分守恒定律出发，在相同的均匀剖分上推导有限体积法。在面上使用中心差分计算梯度和中点材料属性，但通过在每个控制体上使用两点高斯-勒让德（Gauss-Legendre）求积来近似单元积分源项 $\\int_{x_{i-1/2}}^{x_{i+1/2}} f(x)\\,dx$，以获得二阶精确的单元平均源。强施加狄利克雷（Dirichlet）边界条件。\n\n3. 使用问题的弱形式推导标准的连续伽辽金（Galerkin）线性有限元法。在相同的均匀网格上使用分段线性基函数。通过在每个单元上精确积分 $\\int_{x_e^-}^{x_e^+}\\kappa(x)\\,\\phi'_a(x)\\,\\phi'_b(x)\\,dx$ 来组装刚度矩阵，并通过对 $\\int_{x_e^-}^{x_e^+}f(x)\\,\\phi_a(x)\\,dx$ 使用三点高斯-勒让德（Gauss-Legendre）求积来组装载荷向量。在端点处强施加狄利克雷（Dirichlet）边界条件。\n\n通过 $u^\\star(x)=\\sin(\\pi x)$ 定义解析解，该解通过代入控制方程来确定源项 $f(x)$，并确保在连续情况下问题由 $u^\\star(x)$ 精确满足。所有三角函数求值必须使用弧度。\n\n实现这三种离散化方法，并求解得到的线性系统以获得节点 $x_i$ 上的离散解。对于每种离散化，计算最大绝对节点误差\n$$E_\\infty=\\max_{i\\in\\{0,1,\\dots,N\\}} \\left|u_i - u^\\star(x_i)\\right|,$$\n其中 $u_i$ 是在强施加狄利克雷（Dirichlet）边界条件并求解内部自由度后的离散节点值。\n\n使用以下由均匀子区间数 $N$ 指定的测试套件：\n- 情况 1：$N=2$。\n- 情况 2：$N=8$。\n- 情况 3：$N=64$。\n- 情况 4：$N=256$。\n\n对于每种情况，计算并记录三个值 $(E_\\infty^{\\text{FD}}, E_\\infty^{\\text{FV}}, E_\\infty^{\\text{FE}})$，分别对应于有限差分法、有限体积法和有限元法。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下\n$$[E_\\infty^{\\text{FD}}(N=2),E_\\infty^{\\text{FV}}(N=2),E_\\infty^{\\text{FE}}(N=2),E_\\infty^{\\text{FD}}(N=8),E_\\infty^{\\text{FV}}(N=8),E_\\infty^{\\text{FE}}(N=8),E_\\infty^{\\text{FD}}(N=64),E_\\infty^{\\text{FV}}(N=64),E_\\infty^{\\text{FE}}(N=64),E_\\infty^{\\text{FD}}(N=256),E_\\infty^{\\text{FV}}(N=256),E_\\infty^{\\text{FE}}(N=256)],$$\n其中每个条目都是一个浮点数。由于所有量都是无量纲的且角度以弧度为单位，因此不需要单位。",
            "solution": "用户为一维扩散方程提供了一个适定（well-posed）的问题陈述。验证过程，如说明中所述，如下所示。\n\n### 步骤 1：提取已知条件\n- **控制方程**：稳态一维扩散方程以守恒形式给出：\n$$-\\frac{d}{dx}\\left(\\kappa(x)\\,\\frac{du}{dx}\\right)=f(x)$$\n定义域为 $x \\in [0,1]$。\n- **传导系数**：空间变化的传导系数为 $\\kappa(x)=e^x$。\n- **边界条件**：指定了狄利克雷（Dirichlet）边界条件 $u(0)=u_0$ 和 $u(1)=u_1$。\n- **解析解**：提供了一个精确解 $u^\\star(x)=\\sin(\\pi x)$，其中角度以弧度为单位。这意味着 $u_0 = u^\\star(0) = \\sin(0) = 0$ 且 $u_1 = u^\\star(1) = \\sin(\\pi) = 0$。\n- **源项**：源项 $f(x)$ 的定义使得 $u^\\star(x)$ 是控制方程的精确解。\n- **离散化**：使用具有 $N$ 个子区间的均匀网格，网格间距为 $h=1/N$，节点为 $x_i=i\\,h$，其中 $i \\in \\{0, 1, \\dots, N\\}$。\n- **特定于方法的近似**：\n    1.  **有限差分法 (FDM)**：二阶精确中心差分，在单元面（$x_{i\\pm 1/2}$）处使用中点值评估 $\\kappa(x)$，强施加边界条件，并在内部节点（$x_i$）处逐点评估 $f(x)$。\n    2.  **有限体积法 (FVM)**：积分守恒定律，在面处使用中心差分计算梯度，使用中点值评估 $\\kappa(x)$，强施加边界条件，并对每个控制体上的积分源项 $\\int_{x_{i-1/2}}^{x_{i+1/2}} f(x)\\,dx$ 使用两点高斯-勒让德（Gauss-Legendre）求积。\n    3.  **有限元法 (FEM)**：使用分段线性基函数（$\\phi_i(x)$）的连续伽辽金（Galerkin）法，问题的弱形式，对刚度矩阵元素 $\\int \\kappa \\phi'_a \\phi'_b dx$ 进行精确积分，对每个单元上的载荷向量元素 $\\int f \\phi_a dx$ 使用三点高斯-勒让德（Gauss-Legendre）求积，并强施加边界条件。\n- **误差度量**：最大绝对节点误差，$E_\\infty=\\max_{i\\in\\{0,1,\\dots,N\\}} \\left|u_i - u^\\star(x_i)\\right|$。\n- **测试用例**：必须对 $N \\in \\{2, 8, 64, 256\\}$ 求解该问题。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题描述了一个线性二阶常微分方程，这是遍布 STEM 领域中扩散过程的基本模型。使用制造解来测试数值方法是科学计算中一种标准且严谨的验证技术。该问题在科学和数学上是合理的。\n- **适定性**：该问题是一个带有狄利克雷（Dirichlet）边界条件的斯特姆-刘维尔（Sturm-Liouville）问题。由于在定义域上 $\\kappa(x)=e^x  0$，保证存在唯一解。\n- **客观性**：该问题使用精确、无歧义的数学和数值分析术语进行陈述。所有参数和方法都经过了形式化定义。\n- **完整性**：所有必要信息（方程、定义域、边界条件、材料属性、数值格式细节）均已提供。该问题是自洽的。\n\n### 步骤 3：结论与行动\n该问题是**有效**的。这是一个数值分析中的标准、适定且完全指定的问题。可以继续求解过程。\n\n### 源项的推导\n为确保 $u^\\star(x)=\\sin(\\pi x)$ 是精确解，我们将其代入控制方程以找到所需的源项 $f(x)$。首先，我们计算通量 $J(x) = -\\kappa(x) \\frac{du}{dx}$。\n$$ \\frac{du^\\star}{dx} = \\frac{d}{dx}(\\sin(\\pi x)) = \\pi \\cos(\\pi x) $$\n通量为：\n$$ J^\\star(x) = -e^x (\\pi \\cos(\\pi x)) = -\\pi e^x \\cos(\\pi x) $$\n源项是通量的负散度，$f(x) = -\\frac{dJ^\\star}{dx}$（注意：问题陈述的控制方程为 $-\\frac{d}{dx}(\\kappa u') = f$，因此基于所给方程，$f = -\\frac{d}{dx}(-\\kappa u') = \\frac{d J}{dx}$ 是不正确的。$f = -\\frac{d}{dx}(\\kappa u')$ 才是正确的关系。这里，我对 $J$ 的定义存在符号差异。我们改用通量 $F(x) = \\kappa \\frac{du}{dx}$。那么 $-\\frac{dF}{dx}=f$。\n$F^\\star(x) = \\kappa(x) \\frac{du^\\star}{dx} = e^x (\\pi \\cos(\\pi x))$。\n$f(x) = -\\frac{dF^\\star}{dx} = -\\frac{d}{dx}(\\pi e^x \\cos(\\pi x))$。\n使用乘法法则：\n$$ f(x) = -\\pi \\left( (e^x)\\cos(\\pi x) + e^x(-\\pi\\sin(\\pi x)) \\right) $$\n$$ f(x) = -\\pi e^x (\\cos(\\pi x) - \\pi\\sin(\\pi x)) $$\n$$ f(x) = \\pi e^x (\\pi\\sin(\\pi x) - \\cos(\\pi x)) $$\n这就是解析源项函数。\n\n### 数值格式的推导\n\n对于所有格式，我们求解 $N-1$ 个未知的内部节点值 $u_1, u_2, \\dots, u_{N-1}$，因为 $u_0=0$ 和 $u_N=0$ 是给定的。\n\n**1. 有限差分法 (FDM)**\n我们在内部节点 $x_i$（其中 $i \\in \\{1, \\dots, N-1\\}$）处对控制方程进行离散化。微分算子的二阶中心差分近似为：\n$$ \\left. \\frac{d}{dx}\\left(\\kappa(x)\\,\\frac{du}{dx}\\right) \\right|_{x_i} \\approx \\frac{1}{h} \\left[ \\left(\\kappa\\frac{du}{dx}\\right)_{i+1/2} - \\left(\\kappa\\frac{du}{dx}\\right)_{i-1/2} \\right] $$\n在单元半点 $x_{i\\pm 1/2} = (i\\pm 1/2)h$ 处的通量使用中心差分近似：\n$$ \\left(\\kappa\\frac{du}{dx}\\right)_{i+1/2} \\approx \\kappa(x_{i+1/2}) \\frac{u_{i+1}-u_i}{h} = \\kappa_{i+1/2} \\frac{u_{i+1}-u_i}{h} $$\n$$ \\left(\\kappa\\frac{du}{dx}\\right)_{i-1/2} \\approx \\kappa(x_{i-1/2}) \\frac{u_i-u_{i-1}}{h} = \\kappa_{i-1/2} \\frac{u_i-u_{i-1}}{h} $$\n其中 $\\kappa_{i\\pm 1/2} = e^{x_{i\\pm 1/2}}$。将这些代入控制方程 $-\\frac{d}{dx}(\\dots)=f(x)$ 在 $x_i$ 处的值：\n$$ -\\frac{1}{h} \\left( \\kappa_{i+1/2} \\frac{u_{i+1}-u_i}{h} - \\kappa_{i-1/2} \\frac{u_i-u_{i-1}}{h} \\right) = f(x_i) $$\n整理各项，得到节点 $i$ 的线性方程：\n$$ -\\kappa_{i-1/2} u_{i-1} + (\\kappa_{i-1/2} + \\kappa_{i+1/2}) u_i - \\kappa_{i+1/2} u_{i+1} = h^2 f(x_i) $$\n该方程对 $i=1, \\dots, N-1$ 成立。对于 $i=1$，使用 $u_0=0$；对于 $i=N-1$，使用 $u_N=0$。这就构成了一个 $(N-1) \\times (N-1)$ 的三对角线性系统 $A_{FD} \\mathbf{u} = \\mathbf{b}_{FD}$。\n\n**2. 有限体积法 (FVM)**\n我们从守恒定律在以节点 $x_i$ 为中心的控制体 $V_i = [x_{i-1/2}, x_{i+1/2}]$ 上的积分形式开始：\n$$ -\\int_{x_{i-1/2}}^{x_{i+1/2}} \\frac{d}{dx}\\left(\\kappa\\frac{du}{dx}\\right) dx = \\int_{x_{i-1/2}}^{x_{i+1/2}} f(x) dx $$\n对左侧应用微积分基本定理：\n$$ -\\left[ \\kappa\\frac{du}{dx} \\right]_{x_{i-1/2}}^{x_{i+1/2}} = -\\left( \\left(\\kappa\\frac{du}{dx}\\right)_{i+1/2} - \\left(\\kappa\\frac{du}{dx}\\right)_{i-1/2} \\right) = \\int_{V_i} f(x) dx $$\n通量近似与 FDM 情况相同。右侧的源项使用在长度为 $h$ 的区间 $[x_{i-1/2}, x_{i+1/2}]$ 上的两点高斯-勒让德（Gauss-Legendre）求积进行近似：\n$$ \\int_{x_{i-1/2}}^{x_{i+1/2}} f(x) dx \\approx \\frac{h}{2} \\sum_{k=1}^2 w_k f(x_k) = \\frac{h}{2} \\left[ f\\left(x_i - \\frac{h}{2\\sqrt{3}}\\right) + f\\left(x_i + \\frac{h}{2\\sqrt{3}}\\right) \\right] $$\n其中权重为 $w_{1,2}=1$，横坐标为 $\\xi_{1,2} = \\pm 1/\\sqrt{3}$。单元 $i$ 的离散方程为：\n$$ -\\kappa_{i-1/2} u_{i-1} + (\\kappa_{i-1/2} + \\kappa_{i+1/2}) u_i - \\kappa_{i+1/2} u_{i+1} = \\frac{h^2}{2} \\left[ f\\left(x_i - \\frac{h}{2\\sqrt{3}}\\right) + f\\left(x_i + \\frac{h}{2\\sqrt{3}}\\right) \\right] $$\n左侧矩阵 $A_{FV}$ 与 $A_{FD}$ 相同，但右侧向量 $\\mathbf{b}_{FV}$ 不同。\n\n**3. 有限元法 (FEM)**\n弱形式是通过将常微分方程乘以一个来自空间 $H_0^1(0,1)$ 的测试函数 $v(x)$（该空间中的函数平方可积，其导数也平方可积，并且在边界上为零），并在整个定义域上积分得到的：\n$$ -\\int_0^1 \\frac{d}{dx}\\left(\\kappa\\frac{du}{dx}\\right) v(x) dx = \\int_0^1 f(x) v(x) dx $$\n对左侧进行分部积分可得：\n$$ \\left[-\\kappa\\frac{du}{dx}v(x)\\right]_0^1 + \\int_0^1 \\kappa(x) \\frac{du}{dx} \\frac{dv}{dx} dx = \\int_0^1 f(x) v(x) dx $$\n由于 $v \\in H_0^1(0,1)$，$v(0)=v(1)=0$，所以边界项消失。弱形式为：找到 $u \\in H^1(0,1)$，满足 $u(0)=0, u(1)=0$，使得对于所有 $v \\in H_0^1(0,1)$：\n$$ \\int_0^1 \\kappa(x) u'(x) v'(x) dx = \\int_0^1 f(x) v(x) dx $$\n我们通过寻求近似解 $u_h(x) = \\sum_{j=1}^{N-1} u_j \\phi_j(x)$ 来进行离散化，其中 $\\phi_j(x)$ 是分段线性的“帽”状基函数。我们用 $v_h(x) = \\phi_i(x)$（其中 $i=1, \\dots, N-1$）进行测试。这会得到线性系统 $K \\mathbf{u} = \\mathbf{F}$，其中：\n- **刚度矩阵**：$K_{ij} = \\int_0^1 \\kappa(x) \\phi'_j(x) \\phi'_i(x) dx$。对于均匀网格上的分段线性基函数，$\\phi'_i(x)$ 是分段常数：在 $(x_{i-1}, x_i)$ 上为 $1/h$，在 $(x_i, x_{i+1})$ 上为 $-1/h$，在其他地方为 $0$。结果得到一个三对角矩阵：\n    - 对角线元素：$K_{i,i} = \\int_{x_{i-1}}^{x_{i+1}} \\kappa(x) (\\phi'_i)^2 dx = \\frac{1}{h^2} \\int_{x_{i-1}}^{x_i} e^x dx + \\frac{1}{h^2} \\int_{x_i}^{x_{i+1}} e^x dx = \\frac{1}{h^2} (e^{x_{i+1}}-e^{x_{i-1}})$。\n    - 非对角线元素：$K_{i,i+1} = \\int_{x_i}^{x_{i+1}} \\kappa(x) \\phi'_i \\phi'_{i+1} dx = \\int_{x_i}^{x_{i+1}} e^x (-\\frac{1}{h})(\\frac{1}{h}) dx = -\\frac{1}{h^2} (e^{x_{i+1}}-e^{x_i})$。\n- **载荷向量**：$F_i = \\int_0^1 f(x) \\phi_i(x) dx = \\int_{x_{i-1}}^{x_{i+1}} f(x) \\phi_i(x) dx$。该积分被分成两个单元 $[x_{i-1}, x_i]$ 和 $[x_i, x_{i+1}]$ 上的积分。每个单元积分都按规定使用三点高斯-勒让德（Gauss-Legendre）求积计算。对于一个单元 $[x_a, x_b]$，$g(x)$ 的积分近似为 $\\frac{x_b-x_a}{2} \\sum_{k=1}^3 w_k g(x(\\xi_k))$，其中 $w = [5/9, 8/9, 5/9]$ 且 $\\xi = [-\\sqrt{3/5}, 0, \\sqrt{3/5}]$。组装后的向量 $\\mathbf{F}$ 构成了系统的右侧。\n\n推导出这三个线性方程组后，我们就可以实现它们，求解未知的节点值，并计算所需的误差。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D diffusion problem using FDM, FVM, and FEM, and computes errors.\n    \"\"\"\n\n    # --- Problem Definition ---\n    PI = np.pi\n    SQRT3 = np.sqrt(3.0)\n\n    def kappa(x):\n        \"\"\"Conductivity function kappa(x) = e^x.\"\"\"\n        return np.exp(x)\n\n    def u_analytic(x):\n        \"\"\"Analytic solution u*(x) = sin(pi*x).\"\"\"\n        return np.sin(PI * x)\n\n    def f_source(x):\n        \"\"\"Source term f(x) derived from the analytic solution.\"\"\"\n        return PI * np.exp(x) * (PI * np.sin(PI * x) - np.cos(PI * x))\n\n    def solve_fdm(N):\n        \"\"\"Solves the problem using the Finite Difference Method.\"\"\"\n        h = 1.0 / N\n        x = np.linspace(0, 1, N + 1)\n        \n        # We solve for N-1 interior nodes\n        dim = N - 1\n        if dim == 0: return 0.0\n        A = np.zeros((dim, dim))\n        b = np.zeros(dim)\n\n        for i in range(1, N):\n            # Row index in the (N-1)x(N-1) system\n            row_idx = i - 1\n            \n            x_i = x[i]\n            x_im_half = x_i - 0.5 * h\n            x_ip_half = x_i + 0.5 * h\n\n            kappa_im_half = kappa(x_im_half)\n            kappa_ip_half = kappa(x_ip_half)\n            \n            # Diagonal entry\n            A[row_idx, row_idx] = kappa_im_half + kappa_ip_half\n            \n            # Off-diagonal entries\n            if i > 1:\n                A[row_idx, row_idx - 1] = -kappa_im_half\n            if i  N - 1:\n                A[row_idx, row_idx + 1] = -kappa_ip_half\n            \n            # RHS vector\n            b[row_idx] = h**2 * f_source(x_i)\n\n        u_interior = np.linalg.solve(A, b)\n        u_numerical = np.concatenate(([0.0], u_interior, [0.0]))\n        u_exact = u_analytic(x)\n        \n        return np.max(np.abs(u_numerical - u_exact))\n\n    def solve_fvm(N):\n        \"\"\"Solves the problem using the Finite Volume Method.\"\"\"\n        h = 1.0 / N\n        x = np.linspace(0, 1, N + 1)\n        \n        dim = N - 1\n        if dim == 0: return 0.0\n        A = np.zeros((dim, dim))\n        b = np.zeros(dim)\n\n        # 2-point Gauss-Legendre quadrature points for source term integration\n        gl_pt_offset = h / (2.0 * SQRT3)\n\n        for i in range(1, N):\n            row_idx = i - 1\n            \n            x_i = x[i]\n            x_im_half = x_i - 0.5 * h\n            x_ip_half = x_i + 0.5 * h\n\n            kappa_im_half = kappa(x_im_half)\n            kappa_ip_half = kappa(x_ip_half)\n            \n            # Matrix assembly (same as FDM)\n            A[row_idx, row_idx] = kappa_im_half + kappa_ip_half\n            if i > 1:\n                A[row_idx, row_idx - 1] = -kappa_im_half\n            if i  N - 1:\n                A[row_idx, row_idx + 1] = -kappa_ip_half\n            \n            # RHS vector with Gauss quadrature\n            f_at_gl_pts = f_source(x_i - gl_pt_offset) + f_source(x_i + gl_pt_offset)\n            b[row_idx] = (h**2 / 2.0) * f_at_gl_pts\n\n        u_interior = np.linalg.solve(A, b)\n        u_numerical = np.concatenate(([0.0], u_interior, [0.0]))\n        u_exact = u_analytic(x)\n        \n        return np.max(np.abs(u_numerical - u_exact))\n\n    def solve_fem(N):\n        \"\"\"Solves the problem using the Finite Element Method.\"\"\"\n        h = 1.0 / N\n        x = np.linspace(0, 1, N + 1)\n\n        dim = N - 1\n        if dim == 0: return 0.0\n        K = np.zeros((dim, dim))\n        F = np.zeros(dim)\n        \n        # --- Assemble Stiffness Matrix K ---\n        for i in range(1, N):\n            row_idx = i - 1\n            # Diagonal term K_ii\n            K[row_idx, row_idx] = (1/h**2) * (kappa(x[i+1]) - kappa(x[i-1]))\n            # Off-diagonal K_{i,i-1}\n            if i > 1:\n                K[row_idx, row_idx - 1] = -(1/h**2) * (kappa(x[i]) - kappa(x[i-1]))\n            # Off-diagonal K_{i,i+1}\n            if i  N - 1:\n                 K[row_idx, row_idx + 1] = -(1/h**2) * (kappa(x[i+1]) - kappa(x[i]))\n        \n        # --- Assemble Load Vector F ---\n        # 3-point Gauss-Legendre quadrature data for [-1, 1]\n        gl_xi = np.array([-np.sqrt(3.0/5.0), 0, np.sqrt(3.0/5.0)])\n        gl_w = np.array([5.0/9.0, 8.0/9.0, 5.0/9.0])\n        \n        # Loop over elements to assemble F\n        for e in range(N):\n            x_a, x_b = x[e], x[e+1]\n            h_e = x_b - x_a\n            jacobian = h_e / 2.0\n            \n            # Quadrature points in physical space for this element\n            x_q = 0.5 * h_e * gl_xi + 0.5 * (x_b + x_a)\n            \n            f_q = f_source(x_q)\n            \n            # Local basis functions evaluated at quadrature points\n            phi_a_q = (x_b - x_q) / h_e # Corresponds to node e\n            phi_b_q = (x_q - x_a) / h_e # Corresponds to node e+1\n\n            # elemental load vector calculation\n            F_e_a = jacobian * np.sum(gl_w * f_q * phi_a_q)\n            F_e_b = jacobian * np.sum(gl_w * f_q * phi_b_q)\n\n            # Assemble into global vector F (for interior nodes)\n            if e > 0:\n                F[e - 1] += F_e_a\n            if e  N - 1:\n                F[e] += F_e_b\n\n        u_interior = np.linalg.solve(K, F)\n        u_numerical = np.concatenate(([0.0], u_interior, [0.0]))\n        u_exact = u_analytic(x)\n\n        return np.max(np.abs(u_numerical - u_exact))\n    \n    # --- Main Execution Logic ---\n    test_cases = [2, 8, 64, 256]\n    results = []\n\n    for N in test_cases:\n        e_fd = solve_fdm(N)\n        e_fv = solve_fvm(N)\n        e_fe = solve_fem(N)\n        results.extend([e_fd, e_fv, e_fe])\n    \n    # Format and print the final output string\n    print(f\"[{','.join(f'{r:.16e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实世界的物理系统，尤其是在聚变等离子体中，其内部现象往往发生在迥异的时间尺度上，这会导致方程组呈现出“刚性”特征。本练习  通过分析一个各向异性扩散问题来探索这一关键挑战，在这种问题中，显式时间步进格式会面临极其严苛的稳定性限制。你将推导显式方法的稳定性极限，并分析无条件稳定的隐式方法的计算成本，从而深入理解算法复杂性与稳定性之间的重要权衡。",
            "id": "4022703",
            "problem": "考虑单位正方形上的各向异性热扩散方程，其具有齐次狄利克雷边界条件，由守恒定律和 Fick 各向异性扩散定律定义：\n$$\n\\frac{\\partial u}{\\partial t} = \\nabla \\cdot \\left( \\mathbf{D} \\nabla u \\right), \\quad \\text{on } (x,y) \\in (0,1) \\times (0,1), \\quad u|_{\\partial \\Omega} = 0,\n$$\n其中扩散张量是呈对角线形式的常数矩阵，\n$$\n\\mathbf{D} = \\begin{pmatrix} D_x  0 \\\\ 0  D_y \\end{pmatrix}, \\quad D_x  0, \\; D_y  0.\n$$\n我们使用一个包含 $N_x \\times N_y$ 个点的均匀内部网格对空间进行离散化，其间距为 $dx = \\frac{1}{N_x+1}$ 和 $dy = \\frac{1}{N_y+1}$，并通过标准的五点二阶中心差分格式（有限差分法（FDM）的一个特例）来近似空间导数。令 $u_{i,j}^n$ 表示在网格点 $(i,j)$ 和时间层 $t^n$ 处对 $u$ 的近似值。\n\n任务：\n1) 从守恒形式和 Fick 定律出发，推导半离散算子 $K$（矩阵形式），使得\n$$\n\\frac{d \\mathbf{u}}{dt} = K \\mathbf{u},\n$$\n其中 $\\mathbf{u}$ 堆叠了内部网格点的值。证明 $K$ 是由 $D_x$ 和 $D_y$ 缩放的一维二阶差分算子的克罗内克和，其元素为\n$$\nK u_{i,j} = \\frac{D_x}{dx^2}\\left(u_{i+1,j} - 2u_{i,j} + u_{i-1,j}\\right) + \\frac{D_y}{dy^2}\\left(u_{i,j+1} - 2u_{i,j} + u_{i,j-1}\\right).\n$$\n\n2) 对于前向欧拉（显式）时间步，\n$$\n\\mathbf{u}^{n+1} = \\mathbf{u}^n + \\Delta t \\, K \\mathbf{u}^n,\n$$\n使用冯·诺依曼分析方法，根据 $K$ 的最大模特征值来获得稳定性约束。对于与网格对齐的对角各向异性和齐次狄利克雷边界，推导出显式时间步长界\n$$\n\\Delta t_{\\text{exp}} \\le \\frac{1}{2\\left(\\frac{D_x}{dx^2} + \\frac{D_y}{dy^2}\\right)}.\n$$\n\n3) 对于后向欧拉（隐式）时间步进，\n$$\n\\left(I - \\Delta t \\, K\\right)\\mathbf{u}^{n+1} = \\mathbf{u}^n,\n$$\n证明系统矩阵\n$$\nA = I - \\Delta t \\, K\n$$\n是对称正定（Symmetric Positive Definite, SPD）的。令 $M = -K$ 表示半正定离散扩散算子。使用狄利克雷问题的离散正弦基的已知特征值，\n$$\n\\mu_{m,n} = \\frac{4D_x}{dx^2}\\sin^2\\!\\left(\\frac{m\\pi}{2(N_x+1)}\\right) + \\frac{4D_y}{dy^2}\\sin^2\\!\\left(\\frac{n\\pi}{2(N_y+1)}\\right), \\quad 1 \\le m \\le N_x, \\; 1 \\le n \\le N_y,\n$$\n推导出 $A$ 的条件数\n$$\n\\kappa(A) = \\frac{1 + \\Delta t \\, \\mu_{\\max}}{1 + \\Delta t \\, \\mu_{\\min}},\n$$\n其中\n$$\n\\mu_{\\min} = \\mu_{1,1}, \\quad \\mu_{\\max} = \\mu_{N_x,N_y}.\n$$\n使用对称正定矩阵的经典共轭梯度（Conjugate Gradient, CG）迭代界，\n$$\n\\frac{\\|\\mathbf{e}_k\\|_A}{\\|\\mathbf{e}_0\\|_A} \\le 2\\left(\\frac{\\sqrt{\\kappa(A)} - 1}{\\sqrt{\\kappa(A)} + 1}\\right)^k,\n$$\n推导出将误差的 $A$-范数减小到容差 $\\epsilon$ 以下所需的最小迭代次数 $k$：\n$$\nk \\ge \\left\\lceil \\frac{\\log(\\epsilon/2)}{\\log\\left(\\frac{\\sqrt{\\kappa(A)} - 1}{\\sqrt{\\kappa(A)} + 1}\\right)} \\right\\rceil.\n$$\n\n4) 实现一个程序，该程序：\n- 使用具有齐次狄利克雷边界条件的一维二阶差分矩阵的克罗内克积构造 $K$。\n- 选择一个初始条件\n$$\nu(x,y,0) = \\sin(\\pi x)\\sin(\\pi y),\n$$\n并在内部网格上采样。\n- 从 $t=0$ 到 $t=T$ 前进一个隐式后向欧拉步，步长为 $\\Delta t_{\\text{imp}} = T$，通过求解\n$$\nA \\mathbf{u}^{1} = \\mathbf{u}^{0}, \\quad A = I - \\Delta t_{\\text{imp}} K,\n$$\n使用稀疏直接求解器得到 $\\mathbf{u}^{1}$。\n- 为比较计算成本（不测量挂钟时间），计算以下内容：\n  - 稳定的显式时间步长 $\\Delta t_{\\text{exp}}$。\n  - 显式步数 $N_{\\text{exp}} = \\left\\lceil \\frac{T}{\\Delta t_{\\text{exp}}} \\right\\rceil$。\n  - 以“稀疏矩阵向量乘法单元”为单位的工作模型：对于显式方法，\n$$\nW_{\\text{exp}} = N_{\\text{exp}} \\cdot \\operatorname{nnz}(K),\n$$\n其中 $\\operatorname{nnz}(\\cdot)$ 计算非零元个数；对于使用 CG 的隐式方法，\n$$\nW_{\\text{imp}} = N_{\\text{imp}} \\cdot k \\cdot \\operatorname{nnz}(A),\n$$\n其中 $N_{\\text{imp}} = 1$，k 来自上述界限，$\\epsilon = 10^{-8}$。同时报告比率\n$$\nR = \\frac{W_{\\text{exp}}}{W_{\\text{imp}}}.\n$$\n\n测试套件：\n提供以下测试用例，每个用例由 $(N_x,N_y,D_x,D_y,T)$ 指定，并按描述评估所有量：\n- 用例 1 (理想路径，中等各向异性): $(64,64,1.0,0.01,0.1)$。\n- 用例 2 (各向同性，中等网格): $(32,32,1.0,1.0,0.1)$。\n- 用例 3 (刚性极端各向异性): $(32,32,10^6,1.0,0.1)$。\n- 用例 4 (小网格，低扩散率): $(8,8,0.1,0.1,0.05)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。每个测试用例贡献一个形如 $[\\Delta t_{\\text{exp}}, N_{\\text{exp}}, W_{\\text{exp}}, W_{\\text{imp}}, R]$ 的列表。因此，最终输出格式是包含四个测试用例的四个列表的列表，例如：\n\"[[dt1,n1,wexp1,wimp1,r1],[dt2,n2,wexp2,wimp2,r2],[dt3,n3,wexp3,wimp3,r3],[dt4,n4,wexp4,wimp4,r4]]\"。\n所有数值输出均为无量纲的浮点数或整数；不需要物理单位。",
            "solution": "所呈现的问题是偏微分方程数值分析中的一个综合性练习，具体涉及各向异性热扩散方程。它具有科学依据，是适定的，并且所有提供的信息都是自洽和一致的。这些任务涉及计算科学中的标准推导和计算，并且没有任何使其无效的缺陷。因此，我们可以进行完整的求解。\n\n该问题围绕单位正方形 $\\Omega = (0,1) \\times (0,1)$ 上的各向异性热扩散方程展开：\n$$\n\\frac{\\partial u}{\\partial t} = \\nabla \\cdot \\left( \\mathbf{D} \\nabla u \\right)\n$$\n边界条件为齐次狄利克雷条件 $u|_{\\partial \\Omega} = 0$。扩散张量 $\\mathbf{D}$ 是常数对角矩阵：\n$$\n\\mathbf{D} = \\begin{pmatrix} D_x  0 \\\\ 0  D_y \\end{pmatrix}, \\quad D_x  0, \\; D_y  0\n$$\n展开散度项，偏微分方程变为：\n$$\n\\frac{\\partial u}{\\partial t} = \\frac{\\partial}{\\partial x}\\left(D_x \\frac{\\partial u}{\\partial x}\\right) + \\frac{\\partial}{\\partial y}\\left(D_y \\frac{\\partial u}{\\partial y}\\right) = D_x \\frac{\\partial^2 u}{\\partial x^2} + D_y \\frac{\\partial^2 u}{\\partial y^2}\n$$\n\n我们在一个有 $N_x \\times N_y$ 个内部点的均匀网格上离散化该方程。网格间距为 $dx = \\frac{1}{N_x+1}$ 和 $dy = \\frac{1}{N_y+1}$。网格点为 $(x_i, y_j) = (i \\cdot dx, j \\cdot dy)$，其中 $i=1, \\dots, N_x$ 和 $j=1, \\dots, N_y$。令 $u_{i,j}(t)$ 为 $u(x_i, y_j, t)$ 的近似值。\n\n**任务 1: 半离散算子 K 的推导**\n\n我们使用二阶中心差分公式来近似二阶偏导数：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(x_i, y_j)} \\approx \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{dx^2}\n$$\n$$\n\\frac{\\partial^2 u}{\\partial y^2}\\bigg|_{(x_i, y_j)} \\approx \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{dy^2}\n$$\n将这些代入偏微分方程，得到半离散的常微分方程组 (ODEs)：\n$$\n\\frac{d u_{i,j}}{dt} = D_x \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{dx^2} + D_y \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{dy^2}\n$$\n该方程定义了线性算子 K 在网格值上的作用。如果我们令 $\\mathbf{u}$ 为通过堆叠所有 $u_{i,j}$ 值（例如，按列堆叠）得到的向量，则系统变为 $\\frac{d\\mathbf{u}}{dt} = K\\mathbf{u}$。上述表达式正是问题陈述中提供的 $(K\\mathbf{u})_{i,j}$ 的逐项定义。\n\n为了证明 K 是一个克罗内克和，我们先定义一维二阶差分矩阵。$N \\times N$ 矩阵 $T_N = \\text{tridiag}(1, -2, 1)$ 表示具有齐次狄利克雷边界条件的未缩放的二阶差分算子。令 $K_{1D,x} = \\frac{1}{dx^2} T_{N_x}$ 和 $K_{1D,y} = \\frac{1}{dy^2} T_{N_y}$ 分别为 x 和 y 方向上的一维离散拉普拉斯算子。令 U 为网格值 $u_{i,j}$ 组成的 $N_x \\times N_y$ 矩阵。半离散方程可以写成矩阵形式：\n$$\n\\frac{dU}{dt} = D_x (K_{1D,x} U) + D_y (U K_{1D,y}^T)\n$$\n由于 $T_{N_y}$ 是对称的，所以 $K_{1D,y}^T = K_{1D,y}$。令 $\\mathbf{u} = \\text{vec}(U)$ 为 U 按列堆叠的向量化形式。使用恒等式 $\\text{vec}(AXB) = (B^T \\otimes A) \\text{vec}(X)$，我们可以将矩阵方程向量化：\n$$\n\\frac{d\\mathbf{u}}{dt} = D_x \\text{vec}(K_{1D,x} U I_{N_y}) + D_y \\text{vec}(I_{N_x} U K_{1D,y})\n$$\n$$\n\\frac{d\\mathbf{u}}{dt} = D_x (I_{N_y} \\otimes K_{1D,x}) \\mathbf{u} + D_y (K_{1D,y} \\otimes I_{N_x}) \\mathbf{u}\n$$\n因此，算子 K 是矩阵：\n$$\nK = D_x (I_{N_y} \\otimes K_{1D,x}) + D_y (K_{1D,y} \\otimes I_{N_x})\n$$\n这正是缩放后的一维算子的克罗内克和的定义，从而证实了该论断。\n\n**任务 2: 前向欧拉稳定性分析**\n\n对于 $\\frac{d\\mathbf{u}}{dt} = K\\mathbf{u}$ 的前向欧拉方法是：\n$$\n\\mathbf{u}^{n+1} = \\mathbf{u}^n + \\Delta t \\, K \\mathbf{u}^n = (I + \\Delta t K) \\mathbf{u}^n\n$$\n对于冯·诺依曼稳定性分析，我们考虑在无限网格上的单个傅里叶模式解：$u_{i,j}^n = \\xi^n e^{\\mathrm{i} k_x (i \\, dx)} e^{\\mathrm{i} k_y (j \\, dy)}$，其中 $\\mathrm{i} = \\sqrt{-1}$，$\\xi$ 是放大因子。将此代入离散化方程：\n$$\n\\xi = 1 + \\Delta t \\left[ \\frac{D_x}{dx^2} (e^{\\mathrm{i} k_x dx} - 2 + e^{-\\mathrm{i} k_x dx}) + \\frac{D_y}{dy^2} (e^{\\mathrm{i} k_y dy} - 2 + e^{-\\mathrm{i} k_y dy}) \\right]\n$$\n使用恒等式 $e^{\\mathrm{i}\\theta} + e^{-\\mathrm{i}\\theta} = 2\\cos(\\theta)$，这可以简化为：\n$$\n\\xi = 1 + \\Delta t \\left[ \\frac{2 D_x}{dx^2} (\\cos(k_x dx) - 1) + \\frac{2 D_y}{dy^2} (\\cos(k_y dy) - 1) \\right]\n$$\n使用恒等式 $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$：\n$$\n\\xi = 1 - \\Delta t \\left[ \\frac{4 D_x}{dx^2} \\sin^2(k_x dx / 2) + \\frac{4 D_y}{dy^2} \\sin^2(k_y dy / 2) \\right]\n$$\n为了保证稳定性，我们要求 $|\\xi| \\le 1$。由于括号中的项是非负的，$\\xi$ 总是小于或等于 $1$。该条件变为 $\\xi \\ge -1$：\n$$\n1 - \\Delta t \\left[ \\dots \\right] \\ge -1 \\implies 2 \\ge \\Delta t \\left[ \\frac{4 D_x}{dx^2} \\sin^2(k_x dx / 2) + \\frac{4 D_y}{dy^2} \\sin^2(k_y dy / 2) \\right]\n$$\n当括号中的项最大化时，出现最严格的条件。这发生在最高频率模式下，此时 $\\sin^2(\\cdot)$ 最大化。在有限网格上，波数 $k_x$ 和 $k_y$ 对应于特征向量。对于一般性分析，我们取 $\\sin^2(\\cdot) \\to 1$ 的极限。\n$$\n\\Delta t \\le \\frac{2}{\\frac{4 D_x}{dx^2} + \\frac{4 D_y}{dy^2}} = \\frac{1}{2\\left(\\frac{D_x}{dx^2} + \\frac{D_y}{dy^2}\\right)}\n$$\n这就是显式时间步长界。这也可以从 K 的特征值得出。前向欧拉的稳定性条件是 $\\Delta t |\\lambda_{\\max}(K)| \\le 2$。K 的特征值是 $\\lambda_{m,n} = -\\mu_{m,n}$，其中 $\\mu_{m,n}$ 是半正定算子 $M = -K$ 的特征值。因此，K 的最大模特征值是 $-\\mu_{\\max}$。稳定性极限是 $\\Delta t \\le 2/\\mu_{\\max}$。对于大的 $N_x, N_y$，$\\mu_{\\max} \\approx \\frac{4D_x}{dx^2} + \\frac{4D_y}{dy^2}$，这给出了相同的界限。\n\n**任务 3: 后向欧拉与共轭梯度分析**\n\n后向欧拉方法由下式给出：\n$$\n\\mathbf{u}^{n+1} = \\mathbf{u}^n + \\Delta t \\, K \\mathbf{u}^{n+1} \\implies (I - \\Delta t K) \\mathbf{u}^{n+1} = \\mathbf{u}^n\n$$\n令系统矩阵为 $A = I - \\Delta t K$。\n首先，我们证明 A 是对称正定 (SPD) 的。\n对称性：算子 K 是使用对称格式对自伴微分算子的离散表示，因此 K 是一个对称矩阵。由于单位矩阵 I 是对称的，且 $\\Delta t$ 是一个标量，因此 $A = I - \\Delta t K$ 也是对称的。\n正定性：令 $\\mathbf{v}$ 为任意非零向量，其大小为 $N_x N_y$。K 的特征值，记作 $\\lambda(K)$，是实数且非正的，因为 K 代表扩散（一个能量耗散过程）。具体来说，对于我们的具有齐次狄利克雷条件的有限维问题，特征值是严格为负的，所以 K 是负定的。令 $\\lambda_k(K)  0$ 为 K 的一个特征值。那么对于任何非零向量 $\\mathbf{v}$，我们有 $\\mathbf{v}^T K \\mathbf{v}  0$。考虑二次型：\n$$\n\\mathbf{v}^T A \\mathbf{v} = \\mathbf{v}^T (I - \\Delta t K) \\mathbf{v} = \\mathbf{v}^T\\mathbf{v} - \\Delta t \\mathbf{v}^T K \\mathbf{v} = \\|\\mathbf{v}\\|_2^2 - \\Delta t (\\mathbf{v}^T K \\mathbf{v})\n$$\n由于 $\\|\\mathbf{v}\\|_2^2  0$，$\\Delta t  0$，且 $\\mathbf{v}^T K \\mathbf{v}  0$，和中的两项都是正的。因此，对于所有 $\\mathbf{v} \\neq \\mathbf{0}$，$\\mathbf{v}^T A \\mathbf{v}  0$，所以 A 是正定的。\n\n$M = -K$ 的特征值由 $\\mu_{m,n}$ 给出。因此 K 的特征值是 $-\\mu_{m,n}$。$A = I - \\Delta t K$ 的特征值是 $\\lambda(A) = 1 - \\Delta t \\lambda(K) = 1 + \\Delta t \\mu_{m,n}$。A 的所有特征值都大于 $1$。\nA 的谱条件数是其最大特征值与最小特征值之比：\n$$\n\\kappa(A) = \\frac{\\lambda_{\\max}(A)}{\\lambda_{\\min}(A)} = \\frac{1 + \\Delta t \\, \\mu_{\\max}}{1 + \\Delta t \\, \\mu_{\\min}}\n$$\n其中 $\\mu_{\\min} = \\mu_{1,1}$ 和 $\\mu_{\\max} = \\mu_{N_x, N_y}$ 分别是 M 的最小和最大特征值。\n\n求解 $A\\mathbf{x}=\\mathbf{b}$ 的共轭梯度 (CG) 法的收敛性由以下公式界定：\n$$\n\\frac{\\|\\mathbf{e}_k\\|_A}{\\|\\mathbf{e}_0\\|_A} \\le 2\\left(\\frac{\\sqrt{\\kappa(A)} - 1}{\\sqrt{\\kappa(A)} + 1}\\right)^k\n$$\n其中 $\\mathbf{e}_k$ 是第 k 次迭代时的误差。我们想找到将误差减小到容差 $\\epsilon$ 以下所需的最小迭代次数 k，即 $\\|\\mathbf{e}_k\\|_A / \\|\\mathbf{e}_0\\|_A \\le \\epsilon$。\n$$\n2\\left(\\frac{\\sqrt{\\kappa(A)} - 1}{\\sqrt{\\kappa(A)} + 1}\\right)^k \\le \\epsilon\n$$\n令 $\\rho = \\frac{\\sqrt{\\kappa(A)} - 1}{\\sqrt{\\kappa(A)} + 1}$。我们有 $\\rho^k \\le \\epsilon/2$。对两边取自然对数：\n$$\nk \\ln(\\rho) \\le \\ln(\\epsilon/2)\n$$\n由于 $\\kappa(A)  1$，我们有 $0  \\rho  1$，这意味着 $\\ln(\\rho)$ 是负数。除以 $\\ln(\\rho)$ 会反转不等号：\n$$\nk \\ge \\frac{\\ln(\\epsilon/2)}{\\ln(\\rho)} = \\frac{\\ln(\\epsilon/2)}{\\ln\\left(\\frac{\\sqrt{\\kappa(A)} - 1}{\\sqrt{\\kappa(A)} + 1}\\right)}\n$$\n由于 k 必须是整数，我们对此表达式取上整，这与所提供的公式相匹配。\n\n**任务 4: 实现与成本比较**\n\n最后的任务是为几个测试用例实现这些计算。对于每个用例，我们将计算用于显式和隐式时间积分的计算工作量模型。\n- $\\Delta t_{\\text{exp}}$ 由任务2中推导的稳定性界限计算得出。\n- $N_{\\text{exp}} = \\lceil T / \\Delta t_{\\text{exp}} \\rceil$ 是显式方法达到时间 T 所需的步数。\n- $W_{\\text{exp}} = N_{\\text{exp}} \\cdot \\operatorname{nnz}(K)$ 为显式方法的工作量模型，与步数乘以矩阵中的非零元数量成正比，代表稀疏矩阵向量乘积。\n- 对于隐式方法，我们取一个大步长 $\\Delta t_{\\text{imp}} = T$。成本模型基于使用 CG 求解线性系统。k 是任务3中为容差 $\\epsilon = 10^{-8}$ 估算的 CG 迭代次数。\n- $W_{\\text{imp}} = N_{\\text{imp}} \\cdot k \\cdot \\operatorname{nnz}(A)$，其中 $N_{\\text{imp}} = 1$。由于 $A = I - \\Delta t K$，稀疏模式相同，所以 $\\operatorname{nnz}(A) = \\operatorname{nnz}(K)$。\n- $R = W_{\\text{exp}} / W_{\\text{imp}}$ 是计算工作量模型的比率。\n\n程序将按照推导使用克罗内克积构建稀疏矩阵 K，计算特征值 $\\mu_{\\min}$ 和 $\\mu_{\\max}$，然后为每个测试用例计算所有上述量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags, identity, kron\n\ndef solve():\n    \"\"\"\n    Solves the anisotropic heat equation problem as specified, calculating\n    and comparing computational cost models for explicit and implicit methods.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Nx, Ny, Dx, Dy, T)\n        (64, 64, 1.0, 0.01, 0.1),\n        (32, 32, 1.0, 1.0, 0.1),\n        (32, 32, 1e6, 1.0, 0.1),\n        (8, 8, 0.1, 0.1, 0.05),\n    ]\n\n    results = []\n    # Tolerance for CG iteration estimate\n    epsilon = 1e-8\n\n    for case in test_cases:\n        Nx, Ny, Dx, Dy, T = case\n        \n        # Grid spacings\n        dx = 1.0 / (Nx + 1)\n        dy = 1.0 / (Ny + 1)\n        \n        # Construct the 1D second-difference matrices (unscaled)\n        T_Nx = diags([1, -2, 1], [-1, 0, 1], shape=(Nx, Nx), format='csr')\n        T_Ny = diags([1, -2, 1], [-1, 0, 1], shape=(Ny, Ny), format='csr')\n        \n        # Scaled 1D discrete Laplacians\n        Kx_1D = (1 / dx**2) * T_Nx\n        Ky_1D = (1 / dy**2) * T_Ny\n        \n        # Identity matrices for Kronecker products\n        Ix = identity(Nx)\n        Iy = identity(Ny)\n        \n        # Construct the full 2D discrete Laplacian K using Kronecker sum\n        K = Dx * kron(Iy, Kx_1D) + Dy * kron(Ky_1D, Ix)\n        \n        # --- Explicit Method Calculations ---\n        \n        # Stable explicit time step\n        dt_exp = 1.0 / (2 * (Dx / dx**2 + Dy / dy**2))\n        \n        # Number of explicit steps\n        N_exp = int(np.ceil(T / dt_exp))\n        \n        # Non-zero entries in K (and A)\n        nnz_K = K.getnnz()\n        \n        # Work model for explicit method\n        W_exp = N_exp * nnz_K\n        \n        # --- Implicit Method Calculations ---\n        \n        dt_imp = T\n        \n        # Calculate min and max eigenvalues of M = -K\n        # mu_min for m=1, n=1\n        sinarg_x_min = np.pi / (2 * (Nx + 1))\n        sinarg_y_min = np.pi / (2 * (Ny + 1))\n        mu_min = (4 * Dx / dx**2) * np.sin(sinarg_x_min)**2 + \\\n                 (4 * Dy / dy**2) * np.sin(sinarg_y_min)**2\n                 \n        # mu_max for m=Nx, n=Ny\n        sinarg_x_max = np.pi * Nx / (2 * (Nx + 1))\n        sinarg_y_max = np.pi * Ny / (2 * (Ny + 1))\n        mu_max = (4 * Dx / dx**2) * np.sin(sinarg_x_max)**2 + \\\n                 (4 * Dy / dy**2) * np.sin(sinarg_y_max)**2\n        \n        # Condition number of A = I - dt_imp * K\n        kappa_A = (1 + dt_imp * mu_max) / (1 + dt_imp * mu_min)\n        \n        # Estimated number of CG iterations\n        if kappa_A == 1:\n            k = 1 # The system is perfectly conditioned\n        else:\n            rho = (np.sqrt(kappa_A) - 1) / (np.sqrt(kappa_A) + 1)\n            # Handle rho -> 1 case for stability if kappa_A is huge\n            if rho == 1.0:\n                 # This would imply infinite iterations, practically indicates\n                 # a very hard problem. A large number can be a substitute\n                 # but for numerical stability in the log, we can use an approximation\n                 # log( (sqrt(k)-1)/(sqrt(k)+1) ) ~ -2/sqrt(k) for large k\n                 k_float = np.log(epsilon / 2) / (-2.0 / np.sqrt(kappa_A))\n            else:\n                 k_float = np.log(epsilon / 2) / np.log(rho)\n            k = int(np.ceil(k_float))\n\n        # Work model for implicit method (N_imp = 1)\n        nnz_A = nnz_K # Sparsity pattern is the same\n        W_imp = k * nnz_A\n        \n        # Ratio of work\n        R = W_exp / W_imp if W_imp > 0 else float('inf')\n        \n        current_results = [dt_exp, int(N_exp), int(W_exp), int(W_imp), R]\n        results.append(current_results)\n    \n    # Format the final output string\n    # e.g., \"[[dt1,n1,wexp1,wimp1,r1],[dt2,n2,wexp2,wimp2,r2],...]\"\n    result_strings = []\n    for res_list in results:\n        result_strings.append(f\"[{','.join(map(str, res_list))}]\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        }
    ]
}