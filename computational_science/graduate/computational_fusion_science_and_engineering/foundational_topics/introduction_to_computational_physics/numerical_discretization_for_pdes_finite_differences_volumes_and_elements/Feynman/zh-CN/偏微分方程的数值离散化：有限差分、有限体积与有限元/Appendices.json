{
    "hands_on_practices": [
        {
            "introduction": "在真实的科学与工程计算中，为了高效地解析局部区域的剧烈梯度（例如在聚变等离子体偏滤器附近），我们常常采用非均匀网格。本练习旨在训练一项基本技能：在此类网格上推导有限差分近似。我们将运用数值分析的基石——泰勒级数展开，来构建二阶导数的离散格式，这对于求解各类扩散型偏微分方程至关重要。",
            "id": "4022699",
            "problem": "在磁约束聚变等离子体的平行热传导模型中，沿磁力线参数 $s$ 的温度场 $T(s,t)$ 满足形式为 $\\partial T/\\partial t = \\partial/\\partial s \\left( \\kappa_{\\parallel}(s) \\, \\partial T/\\partial s \\right)$ 的一维偏微分方程(PDE)，其中 $\\kappa_{\\parallel}(s)$ 是平行热导率。高保真度计算聚变科学与工程求解器通常沿 $s$ 方向采用非均匀网格，以解析偏滤器靶板附近和强磁通扩展区域中的陡峭梯度。考虑三个连续的网格点 $s_{i-1}$、$s_i$ 和 $s_{i+1}$，其局部间距为 $h_{i-1} = s_i - s_{i-1}$ 和 $h_i = s_{i+1} - s_i$，这些间距不必相等。\n\n从一阶和二阶导数的定义出发，使用 $T(s)$ 在 $s_i$ 点附近足够高阶的 Taylor 级数展开，构建一个三点有限差分公式，该公式仅用 $T_{i-1} = T(s_{i-1})$、$T_i = T(s_i)$、$T_{i+1} = T(s_{i+1})$ 以及局部间距 $h_{i-1}$ 和 $h_i$ 来近似该非均匀网格上的二阶导数 $T''(s_i)$。然后，推导并明确给出作为 $h_{i-1}$、$h_i$ 以及在 $s_i$ 处求值的 $T$ 的导数的函数的主截断误差项。\n\n你的最终答案必须包含离散二阶导数近似的单个解析表达式和其主截断误差项的单个解析表达式，并以单行矩阵的形式一同呈现。不需要进行数值计算，也不需要四舍五入。最终答案中不要包含物理单位。",
            "solution": "用户提供了来自计算科学与工程领域的一个有效且适定的问题陈述。任务是推导非均匀网格上二阶导数的三点有限差分公式及其相关的主截断误差。这是数值分析中的一个标准且可验证的推导。\n\n目标是利用三个非均匀间隔点上的函数值：$T_{i-1} = T(s_{i-1})$、$T_i = T(s_i)$ 和 $T_{i+1} = T(s_{i+1})$，来寻找函数 $T(s)$ 在点 $s_i$ 处二阶导数 $T''(s_i)$ 的近似值。间距定义为 $h_{i-1} = s_i - s_{i-1}$ 和 $h_i = s_{i+1} - s_i$。推导过程利用了 $T(s)$ 在点 $s_i$ 附近的 Taylor 级数展开。\n\n首先，我们写出 $T(s_{i+1})$ 在 $s_i$ 点的 Taylor 级数展开。位移为 $s_{i+1} - s_i = h_i$。\n$$T_{i+1} = T(s_i + h_i) = T(s_i) + h_i T'(s_i) + \\frac{h_i^2}{2!} T''(s_i) + \\frac{h_i^3}{3!} T'''(s_i) + O(h_i^4)$$\n使用简写符号 $T_j = T(s_j)$ 并为清晰起见省略导数的求值点 $s_i$，我们得到：\n$$T_{i+1} = T_i + h_i T' + \\frac{h_i^2}{2} T'' + \\frac{h_i^3}{6} T''' + \\dots \\quad (1)$$\n\n接下来，我们写出 $T(s_{i-1})$ 在 $s_i$ 点的 Taylor 级数展开。位移为 $s_{i-1} - s_i = -h_{i-1}$。\n$$T_{i-1} = T(s_i - h_{i-1}) = T(s_i) - h_{i-1} T'(s_i) + \\frac{(-h_{i-1})^2}{2!} T''(s_i) + \\frac{(-h_{i-1})^3}{3!} T'''(s_i) + O(h_{i-1}^4)$$\n$$T_{i-1} = T_i - h_{i-1} T' + \\frac{h_{i-1}^2}{2} T'' - \\frac{h_{i-1}^3}{6} T''' + \\dots \\quad (2)$$\n\n我们的目标是构造方程(1)和(2)的线性组合，以消去一阶导数项 $T'$，并求解二阶导数项 $T''$。我们可以重新整理方程(1)和(2)来表示一阶导数：\n由(1)得：\n$$h_i T' = T_{i+1} - T_i - \\frac{h_i^2}{2} T'' - \\frac{h_i^3}{6} T''' - \\dots$$\n由(2)得：\n$$h_{i-1} T' = T_i - T_{i-1} + \\frac{h_{i-1}^2}{2} T'' - \\frac{h_{i-1}^3}{6} T''' + \\dots$$\n\n为了消去 $T'$，我们可以写出：\n$$T' = \\frac{T_{i+1} - T_i}{h_i} - \\frac{h_i}{2} T'' - \\frac{h_i^2}{6} T''' - \\dots$$\n$$T' = \\frac{T_i - T_{i-1}}{h_{i-1}} + \\frac{h_{i-1}}{2} T'' - \\frac{h_{i-1}^2}{6} T''' + \\dots$$\n\n令这两个 $T'$ 的表达式相等，得到：\n$$\\frac{T_{i+1} - T_i}{h_i} - \\frac{h_i}{2} T'' - \\dots = \\frac{T_i - T_{i-1}}{h_{i-1}} + \\frac{h_{i-1}}{2} T'' - \\dots$$\n\n重新整理以求解 $T''$：\n$$\\frac{T_{i+1} - T_i}{h_i} - \\frac{T_i - T_{i-1}}{h_{i-1}} = \\left(\\frac{h_i}{2} + \\frac{h_{i-1}}{2}\\right)T'' + \\left(\\frac{h_i^2}{6} - \\frac{h_{i-1}^2}{6}\\right)T''' + \\dots$$\n$$\\frac{T_{i+1} - T_i}{h_i} - \\frac{T_i - T_{i-1}}{h_{i-1}} = \\frac{h_i + h_{i-1}}{2} T'' + \\frac{h_i^2 - h_{i-1}^2}{6} T''' + \\dots$$\n\n求解 $T''$，我们得到：\n$$T'' = \\frac{2}{h_i + h_{i-1}} \\left( \\frac{T_{i+1} - T_i}{h_i} - \\frac{T_i - T_{i-1}}{h_{i-1}} \\right) - \\frac{h_i^2 - h_{i-1}^2}{3(h_i + h_{i-1})} T''' - \\dots$$\n$$T'' = \\frac{2}{h_i + h_{i-1}} \\left( \\frac{T_{i+1} - T_i}{h_i} - \\frac{T_i - T_{i-1}}{h_{i-1}} \\right) - \\frac{h_i - h_{i-1}}{3} T''' - \\dots$$\n\n$T''(s_i)$ 的有限差分近似是等式右边的第一项。这个表达式在物理上是直观的，因为它表示了有限差分形式一阶导数的空间导数，并通过有效网格间距 $\\frac{1}{2}(h_i+h_{i-1})$ 进行了归一化。\n$$T''(s_i) \\approx \\frac{2}{h_i + h_{i-1}} \\left( \\frac{T_{i+1} - T_i}{h_i} - \\frac{T_i - T_{i-1}}{h_{i-1}} \\right)$$\n\n截断误差 $\\tau_i$ 定义为作用在精确解上的离散算子与连续算子之差，即 $\\tau_i = T''(s_i)_{\\text{approx}} - T''(s_i)$。根据我们的推导：\n$$T''(s_i)_{\\text{approx}} = T''(s_i) + \\frac{h_i - h_{i-1}}{3} T'''(s_i) + O(h^2, h_{i-1}h_i, \\dots)$$\n因此，主截断误差项为：\n$$\\tau_{i, \\text{leading}} = \\frac{1}{3}(h_i - h_{i-1}) T'''(s_i)$$\n\n该误差项表明，在 $h_i \\neq h_{i-1}$ 的一般非均匀网格上，该近似是具有一阶精度 $O(\\max(h_i, h_{i-1}))$ 的。如果网格是均匀的，即 $h_i = h_{i-1} = h$，则主误差项消失。在这种特殊情况下，必须将 Taylor 级数展开到更高一阶才能找到新的主误差项，即 $\\frac{h^2}{12}T^{(4)}(s_i)$，这导致了标准中心差分格式众所周知的二阶精度。由于问题指定了可能是非均匀的网格，因此一阶项是正确的主误差项。\n\n为了将近似公式表示为单个解析表达式，我们可以将各项合并为一个分数：\n$$\\frac{2}{h_i + h_{i-1}} \\left( \\frac{h_{i-1}(T_{i+1} - T_i) - h_i(T_i - T_{i-1})}{h_i h_{i-1}} \\right) = \\frac{2(h_{i-1}T_{i+1} - (h_i+h_{i-1})T_i + h_i T_{i-1})}{h_i h_{i-1} (h_i + h_{i-1})}$$\n然而，基于差分的差分形式是标准的，并且由于其与底层物理和数学的清晰联系而通常更受欢迎。两者是等价的。\n最终答案的第一部分是 $T''(s_i)$ 的近似值，第二部分是主截断误差项。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{2}{h_{i-1}+h_i} \\left( \\frac{T_{i+1}-T_i}{h_i} - \\frac{T_i-T_{i-1}}{h_{i-1}} \\right)  \\frac{1}{3} (h_i - h_{i-1}) T'''(s_i)\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "掌握了单个离散格式的构建后，下一步是将其应用于求解一个完整的边值问题。本练习将引导你对比三种主流的数值方法：有限差分法（FDM）、有限体积法（FVM）和有限元法（FEM）。通过为同一个一维扩散问题编写并实现这三种方法的求解器，你将亲身体验它们在公式推导和程序实现上的差异，并学会如何通过精确解来验证数值解的收敛阶，这是计算科学家必须具备的一项核心能力。",
            "id": "4022645",
            "problem": "考虑区间 $[0,1]$ 上的稳态一维扩散问题，该问题由通量守恒定律给出，其中未知标量场 $u(x)$ 满足守恒形式的线性常微分方程，\n$$-\\frac{d}{dx}\\left(\\kappa(x)\\,\\frac{du}{dx}\\right)=f(x),$$\n边界条件为狄利克雷（Dirichlet）边界条件 $u(0)=u_0$ 和 $u(1)=u_1$。设空间变化的传导系数为 $\\kappa(x)=e^x$，并选择解析解 $u^\\star(x)=\\sin(\\pi x)$，这使得 $u_0=\\sin(\\pi\\cdot 0)=0$ 和 $u_1=\\sin(\\pi\\cdot 1)=0$。通过将 $u^\\star(x)$ 直接代入控制方程，源项 $f(x)$ 由 $u^\\star(x)$ 是精确解这一要求唯一确定。三角函数中的角度必须以弧度处理。\n\n您的任务是：\n\n1.  从守恒定律的积分形式和数值近似的标准定义出发，推导一个在均匀网格上的二阶精度中心有限差分法。该网格包含 $N$ 个 $[0,1]$ 上的等分，网格间距为 $h=1/N$，节点为 $x_i=i\\,h$，其中整数 $i\\in\\{0,1,\\dots,N\\}$。在单元面上使用中点值评估材料属性，在 $x=0$ 和 $x=1$ 处强施加边界条件，并在内部节点处对 $f(x)$ 进行逐点近似。\n\n2.  从相同的积分守恒定律出发，在相同的均匀分区上推导一个有限体积法。在面上使用中心差分计算梯度，在面上使用中点材料属性，但通过在每个控制体积上使用两点高斯-勒让德（Gauss-Legendre）求积来近似单元积分源项 $\\int_{x_{i-1/2}}^{x_{i+1/2}} f(x)\\,dx$，以获得二阶精度的单元平均源项。强施加狄利克雷边界条件。\n\n3.  利用问题的弱形式，推导标准的连续伽辽金（Galerkin）线性有限元法。在相同的均匀网格上使用分片线性基函数。通过对每个单元上的 $\\int_{x_e^-}^{x_e^+}\\kappa(x)\\,\\phi'_a(x)\\,\\phi'_b(x)\\,dx$ 进行精确积分来组装刚度矩阵，并通过对 $\\int_{x_e^-}^{x_e^+}f(x)\\,\\phi_a(x)\\,dx$ 使用三点高斯-勒让德求积来组装载荷向量。在端点处强施加狄利克雷边界条件。\n\n定义解析解为 $u^\\star(x)=\\sin(\\pi x)$，通过将其代入控制方程来确定源项 $f(x)$，并确保在连续设定下该问题由 $u^\\star(x)$ 精确满足。所有三角函数求值必须使用弧度。\n\n实现这三种离散化方法，并求解得到的线性系统以获得节点 $x_i$ 上的离散解。对于每种离散化方法，计算最大绝对节点误差\n$$E_\\infty=\\max_{i\\in\\{0,1,\\dots,N\\}} \\left|u_i - u^\\star(x_i)\\right|,$$\n其中 $u_i$ 是在强施加狄利克雷边界条件并求解内部自由度后的离散节点值。\n\n使用以下由均匀子区间数 $N$ 指定的测试套件：\n- 情况 1：$N=2$。\n- 情况 2：$N=8$。\n- 情况 3：$N=64$。\n- 情况 4：$N=256$。\n\n对于每种情况，计算并记录三个值 $(E_\\infty^{\\text{FD}}, E_\\infty^{\\text{FV}}, E_\\infty^{\\text{FE}})$，分别对应于有限差分法、有限体积法和有限元法。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序如下\n$$[E_\\infty^{\\text{FD}}(N{=}2),E_\\infty^{\\text{FV}}(N{=}2),E_\\infty^{\\text{FE}}(N{=}2),E_\\infty^{\\text{FD}}(N{=}8),E_\\infty^{\\text{FV}}(N{=}8),E_\\infty^{\\text{FE}}(N{=}8),E_\\infty^{\\text{FD}}(N{=}64),E_\\infty^{\\text{FV}}(N{=}64),E_\\infty^{\\text{FE}}(N{=}64),E_\\infty^{\\text{FD}}(N{=}256),E_\\infty^{\\text{FV}}(N{=}256),E_\\infty^{\\text{FE}}(N{=}256)],$$\n其中每个条目都是一个浮点数。由于所有量都是无量纲的，且角度以弧度为单位，因此不需要单位。",
            "solution": "用户提供了一个适定的一维扩散方程问题陈述。根据说明，验证过程如下。\n\n### 第 1 步：提取已知条件\n- **控制方程**：稳态一维扩散方程以守恒形式给出：\n$$-\\frac{d}{dx}\\left(\\kappa(x)\\,\\frac{du}{dx}\\right)=f(x)$$\n在定义域 $x \\in [0,1]$ 上。\n- **传导系数**：空间变化的传导系数为 $\\kappa(x)=e^x$。\n- **边界条件**：指定了狄利克雷边界条件为 $u(0)=u_0$ 和 $u(1)=u_1$。\n- **解析解**：提供了一个精确解 $u^\\star(x)=\\sin(\\pi x)$，其中角度以弧度为单位。这意味着 $u_0 = u^\\star(0) = \\sin(0) = 0$ 且 $u_1 = u^\\star(1) = \\sin(\\pi) = 0$。\n- **源项**：源项 $f(x)$ 的定义使得 $u^\\star(x)$ 是控制方程的精确解。\n- **离散化**：使用具有 $N$ 个子区间的均匀网格，网格间距为 $h=1/N$，节点为 $x_i=i\\,h$，其中 $i \\in \\{0, 1, \\dots, N\\}$。\n- **特定方法的近似**：\n    1.  **有限差分法 (FDM)**：二阶精度中心差分，在单元面 $x_{i\\pm 1/2}$ 处对 $\\kappa(x)$ 进行中点评估，强施加边界条件，以及在内部节点 $x_i$ 处对 $f(x)$ 进行逐点评估。\n    2.  **有限体积法 (FVM)**：积分守恒定律，面上梯度的中心差分，面上的中点 $\\kappa(x)$ 评估，强施加边界条件，以及在每个控制体积上对积分源项 $\\int_{x_{i-1/2}}^{x_{i+1/2}} f(x)\\,dx$ 使用两点高斯-勒让德求积。\n    3.  **有限元法 (FEM)**：使用分片线性基函数 ($\\phi_i(x)$) 的连续伽辽金法，问题的弱形式，对刚度矩阵元素 $\\int \\kappa \\phi'_a \\phi'_b dx$ 进行精确积分，对每个单元上的载荷向量元素 $\\int f \\phi_a dx$ 使用三点高斯-勒让德求积，以及强施加边界条件。\n- **误差度量**：最大绝对节点误差，$E_\\infty=\\max_{i\\in\\{0,1,\\dots,N\\}} \\left|u_i - u^\\star(x_i)\\right|$。\n- **测试用例**：必须对 $N \\in \\{2, 8, 64, 256\\}$ 求解该问题。\n\n### 第 2 步：使用提取的已知条件进行验证\n- **科学基础**：该问题描述了一个线性二阶常微分方程，是 STEM 领域中扩散过程的基本模型。使用构造解来测试数值方法是科学计算中一种标准且严谨的验证技术。该问题在科学上和数学上是合理的。\n- **适定性**：该问题是一个带有狄利克雷边界条件的 Sturm-Liouville 问题。由于在定义域上 $\\kappa(x)=e^x  0$，保证存在唯一解。\n- **客观性**：该问题使用精确、无歧义的数学和数值分析术语进行陈述。所有参数和方法都经过了正式定义。\n- **完整性**：提供了所有必要的信息（方程、定义域、边界条件、材料属性、数值格式细节）。该问题是自洽的。\n\n### 第 3 步：结论与行动\n该问题是**有效的**。它是一个标准的、适定的、完全指定的数值分析问题。可以继续求解过程。\n\n### 源项的推导\n为确保 $u^\\star(x)=\\sin(\\pi x)$ 是精确解，我们将其代入控制方程以求得所需的源项 $f(x)$。首先，我们计算通量，$J(x) = -\\kappa(x) \\frac{du}{dx}$。\n$$ \\frac{du^\\star}{dx} = \\frac{d}{dx}(\\sin(\\pi x)) = \\pi \\cos(\\pi x) $$\n通量为：\n$$ J^\\star(x) = -e^x (\\pi \\cos(\\pi x)) = -\\pi e^x \\cos(\\pi x) $$\n源项是通量的负散度，$f(x) = -\\frac{dJ^\\star}{dx}$（注意：问题陈述的控制方程为 $-\\frac{d}{dx}(\\kappa u') = f$，因此 $f = -\\frac{d}{dx}(-\\kappa u') = \\frac{d J}{dx}$ 根据所给方程是不正确的。$f = -\\frac{d}{dx}(\\kappa u')$ 是正确的关系。此处，我对 $J$ 的定义有一个符号差异。让我们使用通量 $F(x) = \\kappa \\frac{du}{dx}$。那么 $-\\frac{dF}{dx}=f$。\n$F^\\star(x) = \\kappa(x) \\frac{du^\\star}{dx} = e^x (\\pi \\cos(\\pi x))$。\n$f(x) = -\\frac{dF^\\star}{dx} = -\\frac{d}{dx}(\\pi e^x \\cos(\\pi x))$。\n使用乘积法则：\n$$ f(x) = -\\pi \\left( (e^x)\\cos(\\pi x) + e^x(-\\pi\\sin(\\pi x)) \\right) $$\n$$ f(x) = -\\pi e^x (\\cos(\\pi x) - \\pi\\sin(\\pi x)) $$\n$$ f(x) = \\pi e^x (\\pi\\sin(\\pi x) - \\cos(\\pi x)) $$\n这是解析源项函数。\n\n### 数值格式的推导\n\n对于所有格式，我们求解 $N-1$ 个未知的内部节点值 $u_1, u_2, \\dots, u_{N-1}$，因为 $u_0=0$ 和 $u_N=0$ 是已知的。\n\n**1. 有限差分法 (FDM)**\n我们在内部节点 $x_i$（其中 $i \\in \\{1, \\dots, N-1\\}$）处对控制方程进行离散化。导数算子的二阶中心差分近似为：\n$$ \\left. \\frac{d}{dx}\\left(\\kappa(x)\\,\\frac{du}{dx}\\right) \\right|_{x_i} \\approx \\frac{1}{h} \\left[ \\left(\\kappa\\frac{du}{dx}\\right)_{i+1/2} - \\left(\\kappa\\frac{du}{dx}\\right)_{i-1/2} \\right] $$\n在单元半点 $x_{i\\pm 1/2} = (i\\pm 1/2)h$ 处的通量使用中心差分进行近似：\n$$ \\left(\\kappa\\frac{du}{dx}\\right)_{i+1/2} \\approx \\kappa(x_{i+1/2}) \\frac{u_{i+1}-u_i}{h} = \\kappa_{i+1/2} \\frac{u_{i+1}-u_i}{h} $$\n$$ \\left(\\kappa\\frac{du}{dx}\\right)_{i-1/2} \\approx \\kappa(x_{i-1/2}) \\frac{u_i-u_{i-1}}{h} = \\kappa_{i-1/2} \\frac{u_i-u_{i-1}}{h} $$\n其中 $\\kappa_{i\\pm 1/2} = e^{x_{i\\pm 1/2}}$。将这些代入控制方程 $-\\frac{d}{dx}(\\dots)=f(x)$ 在 $x_i$ 处：\n$$ -\\frac{1}{h} \\left( \\kappa_{i+1/2} \\frac{u_{i+1}-u_i}{h} - \\kappa_{i-1/2} \\frac{u_i-u_{i-1}}{h} \\right) = f(x_i) $$\n整理各项得到节点 $i$ 的线性方程：\n$$ -\\kappa_{i-1/2} u_{i-1} + (\\kappa_{i-1/2} + \\kappa_{i+1/2}) u_i - \\kappa_{i+1/2} u_{i+1} = h^2 f(x_i) $$\n该方程对 $i=1, \\dots, N-1$ 成立。对于 $i=1$，使用 $u_0=0$；对于 $i=N-1$，使用 $u_N=0$。这构成一个 $(N-1) \\times (N-1)$ 的三对角线性系统 $A_{FD} \\mathbf{u} = \\mathbf{b}_{FD}$。\n\n**2. 有限体积法 (FVM)**\n我们从围绕节点 $x_i$ 的控制体积 $V_i = [x_{i-1/2}, x_{i+1/2}]$ 上的守恒定律积分形式开始：\n$$ -\\int_{x_{i-1/2}}^{x_{i+1/2}} \\frac{d}{dx}\\left(\\kappa\\frac{du}{dx}\\right) dx = \\int_{x_{i-1/2}}^{x_{i+1/2}} f(x) dx $$\n对左侧应用微积分基本定理：\n$$ -\\left[ \\kappa\\frac{du}{dx} \\right]_{x_{i-1/2}}^{x_{i+1/2}} = -\\left( \\left(\\kappa\\frac{du}{dx}\\right)_{i+1/2} - \\left(\\kappa\\frac{du}{dx}\\right)_{i-1/2} \\right) = \\int_{V_i} f(x) dx $$\n通量近似与 FDM 情况相同。右侧的源项通过在长度为 $h$ 的区间 $[x_{i-1/2}, x_{i+1/2}]$ 上使用两点高斯-勒让德求积进行近似：\n$$ \\int_{x_{i-1/2}}^{x_{i+1/2}} f(x) dx \\approx \\frac{h}{2} \\sum_{k=1}^2 w_k f(x_k) = \\frac{h}{2} \\left[ f\\left(x_i - \\frac{h}{2\\sqrt{3}}\\right) + f\\left(x_i + \\frac{h}{2\\sqrt{3}}\\right) \\right] $$\n其中权重为 $w_{1,2}=1$，横坐标点为 $\\xi_{1,2} = \\pm 1/\\sqrt{3}$。单元 $i$ 的离散方程为：\n$$ -\\kappa_{i-1/2} u_{i-1} + (\\kappa_{i-1/2} + \\kappa_{i+1/2}) u_i - \\kappa_{i+1/2} u_{i+1} = \\frac{h^2}{2} \\left[ f\\left(x_i - \\frac{h}{2\\sqrt{3}}\\right) + f\\left(x_i + \\frac{h}{2\\sqrt{3}}\\right) \\right] $$\n左侧矩阵 $A_{FV}$ 与 $A_{FD}$ 相同，但右侧向量 $\\mathbf{b}_{FV}$ 不同。\n\n**3. 有限元法 (FEM)**\n弱形式是通过将常微分方程乘以一个来自空间 $H_0^1(0,1)$（函数平方可积，其导数也平方可积，并在边界处为零）的检验函数 $v(x)$，并在定义域上积分得到的：\n$$ -\\int_0^1 \\frac{d}{dx}\\left(\\kappa\\frac{du}{dx}\\right) v(x) dx = \\int_0^1 f(x) v(x) dx $$\n对左侧进行分部积分得到：\n$$ \\left[-\\kappa\\frac{du}{dx}v(x)\\right]_0^1 + \\int_0^1 \\kappa(x) \\frac{du}{dx} \\frac{dv}{dx} dx = \\int_0^1 f(x) v(x) dx $$\n由于 $v \\in H_0^1(0,1)$，$v(0)=v(1)=0$，所以边界项消失。弱形式是：找到 $u \\in H^1(0,1)$ 且满足 $u(0)=0, u(1)=0$，使得对于所有 $v \\in H_0^1(0,1)$：\n$$ \\int_0^1 \\kappa(x) u'(x) v'(x) dx = \\int_0^1 f(x) v(x) dx $$\n我们通过寻找近似解 $u_h(x) = \\sum_{j=1}^{N-1} u_j \\phi_j(x)$ 来进行离散化，其中 $\\phi_j(x)$ 是分片线性的“帽状”基函数。我们用 $v_h(x) = \\phi_i(x)$（其中 $i=1, \\dots, N-1$）进行检验。这导致线性系统 $K \\mathbf{u} = \\mathbf{F}$，其中：\n- **刚度矩阵**：$K_{ij} = \\int_0^1 \\kappa(x) \\phi'_j(x) \\phi'_i(x) dx$。对于均匀网格上的分片线性基函数，$\\phi'_i(x)$ 是分片常数：在 $(x_{i-1}, x_i)$ 上为 $1/h$，在 $(x_i, x_{i+1})$ 上为 $-1/h$，其他地方为 $0$。得到一个三对角矩阵：\n    - 对角项：$K_{i,i} = \\int_{x_{i-1}}^{x_{i+1}} \\kappa(x) (\\phi'_i)^2 dx = \\frac{1}{h^2} \\int_{x_{i-1}}^{x_i} e^x dx + \\frac{1}{h^2} \\int_{x_i}^{x_{i+1}} e^x dx = \\frac{1}{h^2} (e^{x_{i+1}}-e^{x_{i-1}})$。\n    - 非对角项：$K_{i,i+1} = \\int_{x_i}^{x_{i+1}} \\kappa(x) \\phi'_i \\phi'_{i+1} dx = \\int_{x_i}^{x_{i+1}} e^x (-\\frac{1}{h})(\\frac{1}{h}) dx = -\\frac{1}{h^2} (e^{x_{i+1}}-e^{x_i})$。\n- **载荷向量**：$F_i = \\int_0^1 f(x) \\phi_i(x) dx = \\int_{x_{i-1}}^{x_{i+1}} f(x) \\phi_i(x) dx$。这个积分被分成两个单元 $[x_{i-1}, x_i]$ 和 $[x_i, x_{i+1}]$ 上的积分。每个单元积分都按要求使用三点高斯-勒让德求积计算。对于一个单元 $[x_a, x_b]$，$g(x)$ 的积分近似为 $\\frac{x_b-x_a}{2} \\sum_{k=1}^3 w_k g(x(\\xi_k))$，其中 $w = [5/9, 8/9, 5/9]$ 且 $\\xi = [-\\sqrt{3/5}, 0, \\sqrt{3/5}]$。组装后的向量 $\\mathbf{F}$ 构成了系统的右侧。\n\n推导出这三个线性方程组后，我们可以实现它们，求解未知的节点值，并计算所需的误差。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D diffusion problem using FDM, FVM, and FEM, and computes errors.\n    \"\"\"\n\n    # --- Problem Definition ---\n    PI = np.pi\n    SQRT3 = np.sqrt(3.0)\n\n    def kappa(x):\n        \"\"\"Conductivity function kappa(x) = e^x.\"\"\"\n        return np.exp(x)\n\n    def u_analytic(x):\n        \"\"\"Analytic solution u*(x) = sin(pi*x).\"\"\"\n        return np.sin(PI * x)\n\n    def f_source(x):\n        \"\"\"Source term f(x) derived from the analytic solution.\"\"\"\n        return PI * np.exp(x) * (PI * np.sin(PI * x) - np.cos(PI * x))\n\n    def solve_fdm(N):\n        \"\"\"Solves the problem using the Finite Difference Method.\"\"\"\n        h = 1.0 / N\n        x = np.linspace(0, 1, N + 1)\n        \n        # We solve for N-1 interior nodes\n        dim = N - 1\n        if dim == 0: return 0.0\n        A = np.zeros((dim, dim))\n        b = np.zeros(dim)\n\n        for i in range(1, N):\n            # Row index in the (N-1)x(N-1) system\n            row_idx = i - 1\n            \n            x_i = x[i]\n            x_im_half = x_i - 0.5 * h\n            x_ip_half = x_i + 0.5 * h\n\n            kappa_im_half = kappa(x_im_half)\n            kappa_ip_half = kappa(x_ip_half)\n            \n            # Diagonal entry\n            A[row_idx, row_idx] = kappa_im_half + kappa_ip_half\n            \n            # Off-diagonal entries\n            if i  1:\n                A[row_idx, row_idx - 1] = -kappa_im_half\n            if i  N - 1:\n                A[row_idx, row_idx + 1] = -kappa_ip_half\n            \n            # RHS vector\n            b[row_idx] = h**2 * f_source(x_i)\n\n        u_interior = np.linalg.solve(A, b)\n        u_numerical = np.concatenate(([0.0], u_interior, [0.0]))\n        u_exact = u_analytic(x)\n        \n        return np.max(np.abs(u_numerical - u_exact))\n\n    def solve_fvm(N):\n        \"\"\"Solves the problem using the Finite Volume Method.\"\"\"\n        h = 1.0 / N\n        x = np.linspace(0, 1, N + 1)\n        \n        dim = N - 1\n        if dim == 0: return 0.0\n        A = np.zeros((dim, dim))\n        b = np.zeros(dim)\n\n        # 2-point Gauss-Legendre quadrature points for source term integration\n        gl_pt_offset = h / (2.0 * SQRT3)\n\n        for i in range(1, N):\n            row_idx = i - 1\n            \n            x_i = x[i]\n            x_im_half = x_i - 0.5 * h\n            x_ip_half = x_i + 0.5 * h\n\n            kappa_im_half = kappa(x_im_half)\n            kappa_ip_half = kappa(x_ip_half)\n            \n            # Matrix assembly (same as FDM)\n            A[row_idx, row_idx] = kappa_im_half + kappa_ip_half\n            if i  1:\n                A[row_idx, row_idx - 1] = -kappa_im_half\n            if i  N - 1:\n                A[row_idx, row_idx + 1] = -kappa_ip_half\n            \n            # RHS vector with Gauss quadrature\n            f_at_gl_pts = f_source(x_i - gl_pt_offset) + f_source(x_i + gl_pt_offset)\n            b[row_idx] = (h**2 / 2.0) * f_at_gl_pts\n\n        u_interior = np.linalg.solve(A, b)\n        u_numerical = np.concatenate(([0.0], u_interior, [0.0]))\n        u_exact = u_analytic(x)\n        \n        return np.max(np.abs(u_numerical - u_exact))\n\n    def solve_fem(N):\n        \"\"\"Solves the problem using the Finite Element Method.\"\"\"\n        h = 1.0 / N\n        x = np.linspace(0, 1, N + 1)\n\n        dim = N - 1\n        if dim == 0: return 0.0\n        K = np.zeros((dim, dim))\n        F = np.zeros(dim)\n        \n        # --- Assemble Stiffness Matrix K ---\n        for i in range(1, N):\n            row_idx = i - 1\n            # Diagonal term K_ii\n            K[row_idx, row_idx] = (1/h**2) * (kappa(x[i+1]) - kappa(x[i-1]))\n            # Off-diagonal K_{i,i-1}\n            if i  1:\n                K[row_idx, row_idx - 1] = -(1/h**2) * (kappa(x[i]) - kappa(x[i-1]))\n            # Off-diagonal K_{i,i+1}\n            if i  N - 1:\n                 K[row_idx, row_idx + 1] = -(1/h**2) * (kappa(x[i+1]) - kappa(x[i]))\n        \n        # --- Assemble Load Vector F ---\n        # 3-point Gauss-Legendre quadrature data for [-1, 1]\n        gl_xi = np.array([-np.sqrt(3.0/5.0), 0, np.sqrt(3.0/5.0)])\n        gl_w = np.array([5.0/9.0, 8.0/9.0, 5.0/9.0])\n        \n        # Loop over elements to assemble F\n        for e in range(N):\n            x_a, x_b = x[e], x[e+1]\n            h_e = x_b - x_a\n            jacobian = h_e / 2.0\n            \n            # Quadrature points in physical space for this element\n            x_q = 0.5 * h_e * gl_xi + 0.5 * (x_b + x_a)\n            \n            f_q = f_source(x_q)\n            \n            # Local basis functions evaluated at quadrature points\n            phi_a_q = (x_b - x_q) / h_e # Corresponds to node e\n            phi_b_q = (x_q - x_a) / h_e # Corresponds to node e+1\n\n            # elemental load vector calculation\n            F_e_a = jacobian * np.sum(gl_w * f_q * phi_a_q)\n            F_e_b = jacobian * np.sum(gl_w * f_q * phi_b_q)\n\n            # Assemble into global vector F (for interior nodes)\n            if e  0:\n                F[e - 1] += F_e_a\n            if e  N - 1:\n                F[e] += F_e_b\n\n        u_interior = np.linalg.solve(K, F)\n        u_numerical = np.concatenate(([0.0], u_interior, [0.0]))\n        u_exact = u_analytic(x)\n\n        return np.max(np.abs(u_numerical - u_exact))\n    \n    # --- Main Execution Logic ---\n    test_cases = [2, 8, 64, 256]\n    results = []\n\n    for N in test_cases:\n        e_fd = solve_fdm(N)\n        e_fv = solve_fvm(N)\n        e_fe = solve_fem(N)\n        results.extend([e_fd, e_fv, e_fe])\n    \n    # Format and print the final output string\n    print(f\"[{','.join(f'{r:.16e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后的实践环节将聚焦于一个在模拟中普遍存在的关键挑战：刚性问题（stiffness），这在模拟聚变等离子体中的各向异性输运等场景时尤为突出。本练习通过一个二维各向异性热扩散问题，深入对比了受稳定性条件严格限制的显式时间积分方法和无条件稳定的隐式方法。通过理论分析和计算成本建模，你将理解这两种方法之间的权衡，并认识到为何隐式求解器尽管单步计算成本更高，但对于高效求解刚性问题却是不可或缺的。",
            "id": "4022703",
            "problem": "考虑单位正方形上的各向异性热扩散方程，其具有齐次狄利克雷边界条件，由守恒律和各向异性扩散的菲克定律定义：$$\\frac{\\partial u}{\\partial t} = \\nabla \\cdot \\left( \\mathbf{D} \\nabla u \\right), \\quad \\text{on } (x,y) \\in (0,1) \\times (0,1), \\quad u|_{\\partial \\Omega} = 0,$$ 其中扩散张量是常对角阵，$$\\mathbf{D} = \\begin{pmatrix} D_x  0 \\\\ 0  D_y \\end{pmatrix}, \\quad D_x  0, \\; D_y  0.$$ 我们使用一个包含 $N_x \\times N_y$ 个点的均匀内部网格对空间进行离散化，网格间距为 $dx = \\frac{1}{N_x+1}$ 和 $dy = \\frac{1}{N_y+1}$，并通过标准的五点二阶中心差分格式（有限差分法（FDM）的一种特例）来近似空间导数。令 $u_{i,j}^n$ 表示在网格点 $(i,j)$ 和时间层 $t^n$ 处对 $u$ 的近似值。\n\n任务：\n1) 根据守恒形式和菲克定律，导出半离散算子 $K$（矩阵形式），使得 $$\\frac{d \\mathbf{u}}{dt} = K \\mathbf{u},$$ 其中 $\\mathbf{u}$ 是将内部网格值堆叠而成的向量。证明 $K$ 是由 $D_x$ 和 $D_y$ 缩放的一维二阶差分算子的克罗内克和，其各项为 $$K u_{i,j} = \\frac{D_x}{dx^2}\\left(u_{i+1,j} - 2u_{i,j} + u_{i-1,j}\\right) + \\frac{D_y}{dy^2}\\left(u_{i,j+1} - 2u_{i,j} + u_{i,j-1}\\right).$$\n\n2) 对于前向欧拉（显式）时间步长，$$\\mathbf{u}^{n+1} = \\mathbf{u}^n + \\Delta t \\, K \\mathbf{u}^n,$$ 使用冯·诺依曼分析得到关于 $K$ 的最大模特征值的稳定性约束。对于与网格对齐的对角各向异性和齐次狄利克雷边界，推导出显式时间步长界 $$\\Delta t_{\\text{exp}} \\le \\frac{1}{2\\left(\\frac{D_x}{dx^2} + \\frac{D_y}{dy^2}\\right)}.$$\n\n3) 对于后向欧拉（隐式）时间步进，$$\\left(I - \\Delta t \\, K\\right)\\mathbf{u}^{n+1} = \\mathbf{u}^n,$$ 证明系统矩阵 $A = I - \\Delta t \\, K$ 是对称正定（SPD）的。令 $M = -K$ 表示半正定离散扩散算子。使用狄利克雷问题的离散正弦基的已知特征值，$$\\mu_{m,n} = \\frac{4D_x}{dx^2}\\sin^2\\!\\left(\\frac{m\\pi}{2(N_x+1)}\\right) + \\frac{4D_y}{dy^2}\\sin^2\\!\\left(\\frac{n\\pi}{2(N_y+1)}\\right), \\quad 1 \\le m \\le N_x, \\; 1 \\le n \\le N_y,$$ 推导出 $A$ 的条件数 $$\\kappa(A) = \\frac{1 + \\Delta t \\, \\mu_{\\max}}{1 + \\Delta t \\, \\mu_{\\min}},$$ 其中 $$\\mu_{\\min} = \\mu_{1,1}, \\quad \\mu_{\\max} = \\mu_{N_x,N_y}.$$ 使用对称正定矩阵的经典共轭梯度（CG）迭代界，定义为共轭梯度（CG），$$\\frac{\\|\\mathbf{e}_k\\|_A}{\\|\\mathbf{e}_0\\|_A} \\le 2\\left(\\frac{\\sqrt{\\kappa(A)} - 1}{\\sqrt{\\kappa(A)} + 1}\\right)^k,$$ 推导出将误差的 $A$-范数减小到容差 $\\epsilon$ 以下所需的最小迭代次数 $k$：\n$$k \\ge \\left\\lceil \\frac{\\log(\\epsilon/2)}{\\log\\left(\\frac{\\sqrt{\\kappa(A)} - 1}{\\sqrt{\\kappa(A)} + 1}\\right)} \\right\\rceil.$$\n\n4) 实现一个程序，该程序：\n- 使用一维二阶差分矩阵（带齐次狄利克雷边界条件）的克罗内克积构造 $K$。\n- 选择一个初始条件 $$u(x,y,0) = \\sin(\\pi x)\\sin(\\pi y),$$ 并在内部网格上采样。\n- 通过求解 $$A \\mathbf{u}^{1} = \\mathbf{u}^{0}, \\quad A = I - \\Delta t_{\\text{imp}} K,$$ 从 $t=0$ 到 $t=T$ 推进一个隐式后向欧拉步，其中 $\\Delta t_{\\text{imp}} = T$，使用稀疏直接求解器得到 $\\mathbf{u}^{1}$。\n- 为了在不测量实测运行时间的情况下比较计算成本，计算以下量：\n  - 稳定的显式时间步长 $\\Delta t_{\\text{exp}}$。\n  - 显式步数 $N_{\\text{exp}} = \\left\\lceil \\frac{T}{\\Delta t_{\\text{exp}}} \\right\\rceil$。\n  - 一个以“稀疏矩阵-向量乘法单元”为单位的工作模型：对于显式方法，$$W_{\\text{exp}} = N_{\\text{exp}} \\cdot \\operatorname{nnz}(K),$$ 其中 $\\operatorname{nnz}(\\cdot)$ 计算非零元个数；对于使用 CG 的隐式方法，$$W_{\\text{imp}} = N_{\\text{imp}} \\cdot k \\cdot \\operatorname{nnz}(A),$$ 其中 $N_{\\text{imp}} = 1$，而 $k$ 来自上述界限（$\\epsilon = 10^{-8}$）。同时报告比率 $$R = \\frac{W_{\\text{exp}}}{W_{\\text{imp}}}.$$\n\n测试套件：\n提供以下测试用例，每个用例由 $(N_x,N_y,D_x,D_y,T)$ 指定，并按描述评估所有量：\n- 用例 1（理想情况，中等各向异性）：$(64,64,1.0,0.01,0.1)$。\n- 用例 2（各向同性，中等网格）：$(32,32,1.0,1.0,0.1)$。\n- 用例 3（刚性极端各向异性）：$(32,32,10^6,1.0,0.1)$。\n- 用例 4（小网格，低扩散率）：$(8,8,0.1,0.1,0.05)$。\n\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表。每个测试用例贡献一个形如 $[\\Delta t_{\\text{exp}}, N_{\\text{exp}}, W_{\\text{exp}}, W_{\\text{imp}}, R]$ 的列表。因此，最终输出格式是包含四个列表的列表，对应四个测试用例，例如：\n\"[[dt1,n1,wexp1,wimp1,r1],[dt2,n2,wexp2,wimp2,r2],[dt3,n3,wexp3,wimp3,r3],[dt4,n4,wexp4,wimp4,r4]]\"。\n所有数值输出均为无量纲的浮点数或整数；不需要物理单位。",
            "solution": "所给问题是偏微分方程数值分析中的一个综合性练习，具体涉及各向异性热扩散方程。该问题在科学上是合理的、适定的，且所有提供的信息都是自洽且一致的。各项任务涉及计算科学中的标准推导和计算，没有任何使其无效的缺陷。因此，我们可以着手给出一个完整的解。\n\n该问题围绕单位正方形 $\\Omega = (0,1) \\times (0,1)$ 上的各向异性热扩散方程展开：\n$$\n\\frac{\\partial u}{\\partial t} = \\nabla \\cdot \\left( \\mathbf{D} \\nabla u \\right)\n$$\n边界条件为齐次狄利克雷条件 $u|_{\\partial \\Omega} = 0$。扩散张量 $\\mathbf{D}$ 是常数对角阵：\n$$\n\\mathbf{D} = \\begin{pmatrix} D_x  0 \\\\ 0  D_y \\end{pmatrix}, \\quad D_x  0, \\; D_y  0\n$$\n展开散度项，偏微分方程变为：\n$$\n\\frac{\\partial u}{\\partial t} = \\frac{\\partial}{\\partial x}\\left(D_x \\frac{\\partial u}{\\partial x}\\right) + \\frac{\\partial}{\\partial y}\\left(D_y \\frac{\\partial u}{\\partial y}\\right) = D_x \\frac{\\partial^2 u}{\\partial x^2} + D_y \\frac{\\partial^2 u}{\\partial y^2}\n$$\n\n我们在一个包含 $N_x \\times N_y$ 个内部点的均匀网格上离散化此方程。网格间距为 $dx = \\frac{1}{N_x+1}$ 和 $dy = \\frac{1}{N_y+1}$。网格点为 $(x_i, y_j) = (i \\cdot dx, j \\cdot dy)$，其中 $i=1, \\dots, N_x$ 且 $j=1, \\dots, N_y$。令 $u_{i,j}(t)$ 为 $u(x_i, y_j, t)$ 的近似值。\n\n**任务 1: 半离散算子 K 的推导**\n\n我们使用二阶中心差分公式来近似二阶偏导数：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(x_i, y_j)} \\approx \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{dx^2}\n$$\n$$\n\\frac{\\partial^2 u}{\\partial y^2}\\bigg|_{(x_i, y_j)} \\approx \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{dy^2}\n$$\n将这些代入偏微分方程，得到常微分方程（ODE）的半离散系统：\n$$\n\\frac{d u_{i,j}}{dt} = D_x \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{dx^2} + D_y \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{dy^2}\n$$\n这个方程定义了线性算子 $K$ 在网格值上的作用。如果我们令 $\\mathbf{u}$ 为将所有 $u_{i,j}$ 值（例如，按列）堆叠得到的向量，则系统变为 $\\frac{d\\mathbf{u}}{dt} = K\\mathbf{u}$。上面的表达式正是问题陈述中提供的 $(K\\mathbf{u})_{i,j}$ 的逐项定义。\n\n为了证明 $K$ 是克罗内克和，我们定义一维二阶差分矩阵。$N \\times N$ 矩阵 $T_N = \\text{tridiag}(1, -2, 1)$ 表示带有齐次狄利克雷边界条件的未缩放二阶差分算子。令 $K_{1D,x} = \\frac{1}{dx^2} T_{N_x}$ 和 $K_{1D,y} = \\frac{1}{dy^2} T_{N_y}$ 分别为 x 和 y 方向上的一维离散拉普拉斯算子。令 $U$ 为网格值 $u_{i,j}$ 构成的 $N_x \\times N_y$ 矩阵。半离散方程可以写成矩阵形式：\n$$\n\\frac{dU}{dt} = D_x (K_{1D,x} U) + D_y (U K_{1D,y}^T)\n$$\n由于 $T_{N_y}$ 是对称的，所以 $K_{1D,y}^T = K_{1D,y}$。令 $\\mathbf{u} = \\text{vec}(U)$ 为将 $U$ 的列堆叠得到的向量化形式。使用恒等式 $\\text{vec}(AXB) = (B^T \\otimes A) \\text{vec}(X)$，我们可以将矩阵方程向量化：\n$$\n\\frac{d\\mathbf{u}}{dt} = D_x \\text{vec}(K_{1D,x} U I_{N_y}) + D_y \\text{vec}(I_{N_x} U K_{1D,y})\n$$\n$$\n\\frac{d\\mathbf{u}}{dt} = D_x (I_{N_y} \\otimes K_{1D,x}) \\mathbf{u} + D_y (K_{1D,y} \\otimes I_{N_x}) \\mathbf{u}\n$$\n因此，算子 $K$ 是矩阵：\n$$\nK = D_x (I_{N_y} \\otimes K_{1D,x}) + D_y (K_{1D,y} \\otimes I_{N_x})\n$$\n这是缩放后的一维算子的克罗内克和的定义，证实了这一论断。\n\n**任务 2: 前向欧拉稳定性分析**\n\n对于 $\\frac{d\\mathbf{u}}{dt} = K\\mathbf{u}$，前向欧拉方法为：\n$$\n\\mathbf{u}^{n+1} = \\mathbf{u}^n + \\Delta t \\, K \\mathbf{u}^n = (I + \\Delta t K) \\mathbf{u}^n\n$$\n对于冯·诺依曼稳定性分析，我们考虑在无限网格上的单个傅里叶模态作为解：$u_{i,j}^n = \\xi^n e^{\\mathrm{i} k_x (i \\, dx)} e^{\\mathrm{i} k_y (j \\, dy)}$，其中 $\\mathrm{i} = \\sqrt{-1}$，$\\xi$ 是放大因子。将此代入离散化方程：\n$$\n\\xi = 1 + \\Delta t \\left[ \\frac{D_x}{dx^2} (e^{\\mathrm{i} k_x dx} - 2 + e^{-\\mathrm{i} k_x dx}) + \\frac{D_y}{dy^2} (e^{\\mathrm{i} k_y dy} - 2 + e^{-\\mathrm{i} k_y dy}) \\right]\n$$\n使用恒等式 $e^{\\mathrm{i}\\theta} + e^{-\\mathrm{i}\\theta} = 2\\cos(\\theta)$，这可以简化为：\n$$\n\\xi = 1 + \\Delta t \\left[ \\frac{2 D_x}{dx^2} (\\cos(k_x dx) - 1) + \\frac{2 D_y}{dy^2} (\\cos(k_y dy) - 1) \\right]\n$$\n使用恒等式 $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$:\n$$\n\\xi = 1 - \\Delta t \\left[ \\frac{4 D_x}{dx^2} \\sin^2(k_x dx / 2) + \\frac{4 D_y}{dy^2} \\sin^2(k_y dy / 2) \\right]\n$$\n为保证稳定性，我们需要 $|\\xi| \\le 1$。由于方括号中的项是非负的，$\\xi$ 总是小于或等于 $1$。条件变为 $\\xi \\ge -1$:\n$$\n1 - \\Delta t \\left[ \\dots \\right] \\ge -1 \\implies 2 \\ge \\Delta t \\left[ \\frac{4 D_x}{dx^2} \\sin^2(k_x dx / 2) + \\frac{4 D_y}{dy^2} \\sin^2(k_y dy / 2) \\right]\n$$\n当方括号中的项最大化时，约束条件最严格。这发生于最高频率的模态，此时 $\\sin^2(\\cdot)$ 最大化。在有限网格上，波数 $k_x$ 和 $k_y$ 对应于特征向量。对于一般分析，我们取 $\\sin^2(\\cdot) \\to 1$ 的极限。\n$$\n\\Delta t \\le \\frac{2}{\\frac{4 D_x}{dx^2} + \\frac{4 D_y}{dy^2}} = \\frac{1}{2\\left(\\frac{D_x}{dx^2} + \\frac{D_y}{dy^2}\\right)}\n$$\n这是显式时间步长界。这也可以从 $K$ 的特征值推导出来。前向欧拉的稳定性条件是 $\\Delta t |\\lambda_{\\max}(K)| \\le 2$。$K$ 的特征值是 $\\lambda_{m,n} = -\\mu_{m,n}$，其中 $\\mu_{m,n}$ 是半正定算子 $M = -K$ 的特征值。因此，$K$ 的最大模特征值是 $-\\mu_{\\max}$。稳定性限制是 $\\Delta t \\le 2/\\mu_{\\max}$。对于大的 $N_x, N_y$，$\\mu_{\\max} \\approx \\frac{4D_x}{dx^2} + \\frac{4D_y}{dy^2}$，这给出了相同的界限。\n\n**任务 3: 后向欧拉和共轭梯度分析**\n\n后向欧拉方法由下式给出：\n$$\n\\mathbf{u}^{n+1} = \\mathbf{u}^n + \\Delta t \\, K \\mathbf{u}^{n+1} \\implies (I - \\Delta t K) \\mathbf{u}^{n+1} = \\mathbf{u}^n\n$$\n令系统矩阵为 $A = I - \\Delta t K$。\n首先，我们证明 $A$ 是对称正定（SPD）的。\n对称性：算子 $K$ 是使用对称格式对自伴微分算子进行的离散化表示，因此 $K$ 是对称矩阵。由于单位矩阵 $I$ 是对称的，且 $\\Delta t$ 是一个标量，所以 $A = I - \\Delta t K$ 也是对称的。\n正定性：令 $\\mathbf{v}$ 为任意非零向量，大小为 $N_x N_y$。$K$ 的特征值（记为 $\\lambda(K)$）是实数且非正，因为 $K$ 代表扩散（一个能量耗散过程）。具体来说，对于我们具有齐次狄利克雷条件的有限维问题，特征值是严格为负的，所以 $K$ 是负定的。令 $\\lambda_k(K)  0$ 为 $K$ 的一个特征值。那么对于任何非零 $\\mathbf{v}$，我们有 $\\mathbf{v}^T K \\mathbf{v}  0$。考虑二次型：\n$$\n\\mathbf{v}^T A \\mathbf{v} = \\mathbf{v}^T (I - \\Delta t K) \\mathbf{v} = \\mathbf{v}^T\\mathbf{v} - \\Delta t \\mathbf{v}^T K \\mathbf{v} = \\|\\mathbf{v}\\|_2^2 - \\Delta t (\\mathbf{v}^T K \\mathbf{v})\n$$\n由于 $\\|\\mathbf{v}\\|_2^2  0$、$\\Delta t  0$ 且 $\\mathbf{v}^T K \\mathbf{v}  0$，和中的两项均为正数。因此，对于所有 $\\mathbf{v} \\neq \\mathbf{0}$，$\\mathbf{v}^T A \\mathbf{v}  0$，所以 $A$ 是正定的。\n\n$M = -K$ 的特征值由 $\\mu_{m,n}$ 给出。因此，$K$ 的特征值为 $-\\mu_{m,n}$。$A = I - \\Delta t K$ 的特征值为 $\\lambda(A) = 1 - \\Delta t \\lambda(K) = 1 + \\Delta t \\mu_{m,n}$。$A$ 的所有特征值都大于 $1$。\n$A$ 的谱条件数是其最大特征值与最小特征值之比：\n$$\n\\kappa(A) = \\frac{\\lambda_{\\max}(A)}{\\lambda_{\\min}(A)} = \\frac{1 + \\Delta t \\, \\mu_{\\max}}{1 + \\Delta t \\, \\mu_{\\min}}\n$$\n其中 $\\mu_{\\min} = \\mu_{1,1}$ 和 $\\mu_{\\max} = \\mu_{N_x, N_y}$ 是 $M$ 的最小和最大特征值。\n\n求解 $A\\mathbf{x}=\\mathbf{b}$ 的共轭梯度（CG）法的收敛性由下式界定：\n$$\n\\frac{\\|\\mathbf{e}_k\\|_A}{\\|\\mathbf{e}_0\\|_A} \\le 2\\left(\\frac{\\sqrt{\\kappa(A)} - 1}{\\sqrt{\\kappa(A)} + 1}\\right)^k\n$$\n其中 $\\mathbf{e}_k$ 是第 $k$ 次迭代的误差。我们想找到使误差低于容差 $\\epsilon$ 所需的最小迭代次数 $k$，即 $\\|\\mathbf{e}_k\\|_A / \\|\\mathbf{e}_0\\|_A \\le \\epsilon$。\n$$\n2\\left(\\frac{\\sqrt{\\kappa(A)} - 1}{\\sqrt{\\kappa(A)} + 1}\\right)^k \\le \\epsilon\n$$\n令 $\\rho = \\frac{\\sqrt{\\kappa(A)} - 1}{\\sqrt{\\kappa(A)} + 1}$。我们有 $\\rho^k \\le \\epsilon/2$。对两边取自然对数：\n$$\nk \\ln(\\rho) \\le \\ln(\\epsilon/2)\n$$\n由于 $\\kappa(A)  1$，我们有 $0  \\rho  1$，这意味着 $\\ln(\\rho)$ 是负数。除以 $\\ln(\\rho)$ 会反转不等号：\n$$\nk \\ge \\frac{\\ln(\\epsilon/2)}{\\ln(\\rho)} = \\frac{\\ln(\\epsilon/2)}{\\ln\\left(\\frac{\\sqrt{\\kappa(A)} - 1}{\\sqrt{\\kappa(A)} + 1}\\right)}\n$$\n由于 $k$ 必须是整数，我们取该表达式的上取整，这与所给公式相符。\n\n**任务 4: 实现与成本比较**\n\n最后的任务是为几个测试用例实现这些计算。对于每个用例，我们将计算用于显式和隐式时间积分的计算工作模型量。\n- $\\Delta t_{\\text{exp}}$ 由任务 2 中推导的稳定性界计算得出。\n- $N_{\\text{exp}} = \\lceil T / \\Delta t_{\\text{exp}} \\rceil$ 是显式方法达到时间 $T$ 所需的步数。\n- $W_{\\text{exp}} = N_{\\text{exp}} \\cdot \\operatorname{nnz}(K)$ 为显式方法的工作成本建模，与步数乘以矩阵中的非零元数成正比，代表稀疏矩阵-向量乘法。\n- 对于隐式方法，我们取一个大步长 $\\Delta t_{\\text{imp}} = T$。成本模型基于用 CG 求解线性系统。$k$ 是任务 3 中为容差 $\\epsilon = 10^{-8}$ 估计的 CG 迭代次数。\n- $W_{\\text{imp}} = N_{\\text{imp}} \\cdot k \\cdot \\operatorname{nnz}(A)$，其中 $N_{\\text{imp}} = 1$。由于 $A = I - \\Delta t K$，稀疏模式相同，所以 $\\operatorname{nnz}(A) = \\operatorname{nnz}(K)$。\n- $R = W_{\\text{exp}} / W_{\\text{imp}}$ 是计算工作模型的比率。\n\n程序将使用推导出的克罗内克积构造稀疏矩阵 $K$，计算特征值 $\\mu_{\\min}$ 和 $\\mu_{\\max}$，然后为每个测试用例计算上述所有量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags, identity, kron\n\ndef solve():\n    \"\"\"\n    Solves the anisotropic heat equation problem as specified, calculating\n    and comparing computational cost models for explicit and implicit methods.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Nx, Ny, Dx, Dy, T)\n        (64, 64, 1.0, 0.01, 0.1),\n        (32, 32, 1.0, 1.0, 0.1),\n        (32, 32, 1e6, 1.0, 0.1),\n        (8, 8, 0.1, 0.1, 0.05),\n    ]\n\n    results = []\n    # Tolerance for CG iteration estimate\n    epsilon = 1e-8\n\n    for case in test_cases:\n        Nx, Ny, Dx, Dy, T = case\n        \n        # Grid spacings\n        dx = 1.0 / (Nx + 1)\n        dy = 1.0 / (Ny + 1)\n        \n        # Construct the 1D second-difference matrices (unscaled)\n        T_Nx = diags([1, -2, 1], [-1, 0, 1], shape=(Nx, Nx), format='csr')\n        T_Ny = diags([1, -2, 1], [-1, 0, 1], shape=(Ny, Ny), format='csr')\n        \n        # Scaled 1D discrete Laplacians\n        Kx_1D = (1 / dx**2) * T_Nx\n        Ky_1D = (1 / dy**2) * T_Ny\n        \n        # Identity matrices for Kronecker products\n        Ix = identity(Nx)\n        Iy = identity(Ny)\n        \n        # Construct the full 2D discrete Laplacian K using Kronecker sum\n        K = Dx * kron(Iy, Kx_1D) + Dy * kron(Ky_1D, Ix)\n        \n        # --- Explicit Method Calculations ---\n        \n        # Stable explicit time step\n        dt_exp = 1.0 / (2 * (Dx / dx**2 + Dy / dy**2))\n        \n        # Number of explicit steps\n        N_exp = int(np.ceil(T / dt_exp))\n        \n        # Non-zero entries in K (and A)\n        nnz_K = K.getnnz()\n        \n        # Work model for explicit method\n        W_exp = N_exp * nnz_K\n        \n        # --- Implicit Method Calculations ---\n        \n        dt_imp = T\n        \n        # Calculate min and max eigenvalues of M = -K\n        # mu_min for m=1, n=1\n        sinarg_x_min = np.pi / (2 * (Nx + 1))\n        sinarg_y_min = np.pi / (2 * (Ny + 1))\n        mu_min = (4 * Dx / dx**2) * np.sin(sinarg_x_min)**2 + \\\n                 (4 * Dy / dy**2) * np.sin(sinarg_y_min)**2\n                 \n        # mu_max for m=Nx, n=Ny\n        sinarg_x_max = np.pi * Nx / (2 * (Nx + 1))\n        sinarg_y_max = np.pi * Ny / (2 * (Ny + 1))\n        mu_max = (4 * Dx / dx**2) * np.sin(sinarg_x_max)**2 + \\\n                 (4 * Dy / dy**2) * np.sin(sinarg_y_max)**2\n        \n        # Condition number of A = I - dt_imp * K\n        kappa_A = (1 + dt_imp * mu_max) / (1 + dt_imp * mu_min)\n        \n        # Estimated number of CG iterations\n        if kappa_A == 1:\n            k = 1 # The system is perfectly conditioned\n        else:\n            rho = (np.sqrt(kappa_A) - 1) / (np.sqrt(kappa_A) + 1)\n            # Handle rho - 1 case for stability if kappa_A is huge\n            if rho == 1.0:\n                 # This would imply infinite iterations, practically indicates\n                 # a very hard problem. A large number can be a substitute\n                 # but for numerical stability in the log, we can use an approximation\n                 # log( (sqrt(k)-1)/(sqrt(k)+1) ) ~ -2/sqrt(k) for large k\n                 k_float = np.log(epsilon / 2) / (-2.0 / np.sqrt(kappa_A))\n            else:\n                 k_float = np.log(epsilon / 2) / np.log(rho)\n            k = int(np.ceil(k_float))\n\n        # Work model for implicit method (N_imp = 1)\n        nnz_A = nnz_K # Sparsity pattern is the same\n        W_imp = k * nnz_A\n        \n        # Ratio of work\n        R = W_exp / W_imp if W_imp  0 else float('inf')\n        \n        current_results = [dt_exp, int(N_exp), int(W_exp), int(W_imp), R]\n        results.append(current_results)\n    \n    # Format the final output string\n    # e.g., \"[[dt1,n1,wexp1,wimp1,r1],[dt2,n2,wexp2,wimp2,r2],...]\"\n    result_strings = []\n    for res_list in results:\n        result_strings.append(f\"[{','.join(map(str, res_list))}]\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        }
    ]
}