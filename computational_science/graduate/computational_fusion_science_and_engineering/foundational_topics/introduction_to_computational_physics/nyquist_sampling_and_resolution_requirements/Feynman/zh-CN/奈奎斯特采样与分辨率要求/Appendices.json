{
    "hands_on_practices": [
        {
            "introduction": "在磁约束聚变实验中，精确测量等离子体中的磁扰动模式对于理解和控制不稳定性至关重要。这项实践将我们带回第一性原理，推导空间采样中的混叠现象。通过分析在环向均匀分布的有限数量探头如何区分不同的环向模数，我们能够从根本上理解奈奎斯特空间采样准则，并确定唯一解析给定模数范围所需的最小探头数量。",
            "id": "4024285",
            "problem": "在一个环形磁约束装置中，一组共 $N$ 个相同的拾取线圈安装在均匀分布的环向角 $\\phi_{j} = \\frac{2\\pi j}{N}$ 处，其中 $j \\in \\{0,1,\\ldots,N-1\\}$。测得的信号是一个环向周期场 $B(\\phi)$，它可以分解为关于整数环向模数 $n \\in \\mathbb{Z}$ 的傅里叶级数，即 $B(\\phi) = \\sum_{n \\in \\mathbb{Z}} A_{n} \\exp(i n \\phi)$，其中 $A_{n} \\in \\mathbb{C}$ 是复振幅，$\\phi$ 以弧度为单位测量。该仪器同时记录所有 $N$ 个位置的 $B(\\phi_{j})$，人们希望通过离散傅里叶分析从这些样本中推断出 $B(\\phi)$ 的环向模数成分，这在计算分析以及计算聚变科学与工程中基于快速傅里叶变换(FFT)的流程中是标准做法。\n\n仅从周期域上的均匀角度采样和 $B(\\phi)$ 的整数谐波表示的定义出发，且不引用任何现成的混叠公式，回答以下问题：\n\n- 推导出一个充分必要条件，在该条件下，两个不同的整数环向模数 $n,n' \\in \\mathbb{Z}$ 在所有 $N$ 个探头处产生相同的采样值。表示出与给定模数 $n$ 不可区分的所有模数 $n'$ 的集合。\n\n- 假设物理和诊断方面的考虑意味着存在一个严格的带限 $|n| \\le n_{\\max}$，其中 $n_{\\max} \\ge 1$ 是某个已知的有限整数。确定最小整数 $N_{\\min}$，使得对于每个容许的模数 $|n| \\le n_{\\max}$，在 $N_{\\min}$ 个探头上采样时，没有其他容许的模数与之不可区分。\n\n将最终答案表示为关于 $n_{\\max}$ 的闭式解析表达式。最终答案无需单位。角度以弧度为单位测量。",
            "solution": "该问题要求我们首先推导两个不同环向模在被有限数量的探头采样时变得不可区分的条件，其次，确定唯一识别指定带限内所有模所需的最小探头数量。我们将从所给定义出发进行形式化推导。\n\n首先，我们来处理不可区分性的条件。一个模数为 $n \\in \\mathbb{Z}$ 的单环向模由复指数函数 $\\exp(i n \\phi)$ 表示。如果两个不同的整数模数 $n$ 和 $n'$ 对应的基函数在所有 $N$ 个采样位置 $\\phi_j = \\frac{2\\pi j}{N}$（其中 $j \\in \\{0, 1, \\ldots, N-1\\}$）处产生相同的值，则称它们对于该测量系统是不可区分的或“混叠”的。该条件在数学上表示为：\n$$ \\exp(i n \\phi_j) = \\exp(i n' \\phi_j) \\quad \\forall j \\in \\{0, 1, \\ldots, N-1\\} $$\n将两边同除以 $\\exp(i n' \\phi_j)$ (其值恒不为零)，我们得到：\n$$ \\exp(i n \\phi_j - i n' \\phi_j) = 1 $$\n$$ \\exp\\left(i (n - n') \\phi_j\\right) = 1 $$\n代入采样角 $\\phi_j$ 的定义：\n$$ \\exp\\left(i (n - n') \\frac{2\\pi j}{N}\\right) = 1 $$\n复指数 $\\exp(i\\theta)$ 等于 $1$ 的充分必要条件是其宗量 $\\theta$ 是 $2\\pi$ 的整数倍。因此，对于每个 $j$，必须存在一个整数 $k_j$ 使得：\n$$ (n - n') \\frac{2\\pi j}{N} = 2\\pi k_j $$\n这可以简化为条件：对于所有 $j \\in \\{0, 1, \\ldots, N-1\\}$，$(n - n') \\frac{j}{N}$ 必须是整数。\n对于 $j=0$，条件是 $0 = 0$，这是平凡满足的，不提供任何约束。\n让我们考虑 $j=1$ 的情况。条件要求 $(n - n') \\frac{1}{N}$ 必须是整数。设这个整数为 $m \\in \\mathbb{Z}$。\n$$ \\frac{n - n'}{N} = m $$\n$$ n - n' = mN $$\n这是从 $j=1$ 的情况推导出的必要条件。我们现在必须验证它对于所有其他 $j$ 值是否充分。如果我们假设对于某个整数 $m$，有 $n - n' = mN$，那么我们指数方程的左边变为：\n$$ \\exp\\left(i (mN) \\frac{2\\pi j}{N}\\right) = \\exp(i m j 2\\pi) $$\n由于 $m$ 和 $j$ 都是整数，它们的乘积 $mj$ 也是一个整数。指数函数宗量中 $2\\pi i$ 的任何整数倍都会导致函数值为 $1$。因此，该条件对所有 $j$ 都成立。\n问题陈述了模是不同的，所以 $n \\neq n'$，这意味着 $m \\neq 0$。\n因此，两个不同整数环向模数 $n$ 和 $n'$ 不可区分的充分必要条件是，它们的差是采样数 $N$ 的一个非零整数倍。与给定模 $n$ 不可区分的所有模数 $n'$ 的集合由下式给出：\n$$ \\{ n' \\in \\mathbb{Z} \\mid n' = n + mN, \\text{ for some } m \\in \\mathbb{Z} \\} $$\n\n接下来，我们处理问题的第二部分。我们被给予一个严格的带限，使得唯一物理上相关的模是那些满足 $|n| \\le n_{\\max}$ 的模，其中 $n_{\\max} \\ge 1$ 是某个整数。容许模数的集合是 $\\mathcal{S} = \\{n \\in \\mathbb{Z} \\mid -n_{\\max} \\le n \\le n_{\\max}\\}$。我们必须找到最小探头数 $N_{\\min}$，使得该集合中没有任意两个不同的模是不可区分的。\n\n这意味着对于 $\\mathcal{S}$ 中的任意两个不同模 $n, n'$（即 $n \\neq n'$），它们必须是可区分的。这等价于要求对于 $\\mathcal{S}$ 中任意一对不同的模，不可区分的条件永远不被满足。根据我们之前的推导，这意味着我们必须确保：\n$$ n - n' \\neq mN \\quad \\forall n, n' \\in \\mathcal{S} \\text{ with } n \\neq n', \\text{ and } \\forall m \\in \\mathbb{Z} \\setminus \\{0\\} $$\n让我们分析差值 $n - n'$ 的可能取值范围。由于 $n, n' \\in [-n_{\\max}, n_{\\max}]$，差值的最大可能值为 $n_{\\max} - (-n_{\\max}) = 2n_{\\max}$，最小值为 $-n_{\\max} - n_{\\max} = -2n_{\\max}$。由于 $n \\neq n'$，差值 $n - n'$ 是一个非零整数。因此，所有可能差值的集合是：\n$$ \\Delta = \\{ k \\in \\mathbb{Z} \\mid -2n_{\\max} \\le k \\le 2n_{\\max}, k \\neq 0 \\} $$\n对于任何非零整数 $m$，$n - n' \\neq mN$ 的要求意味着 $N$ 的任何非零倍数都不能是集合 $\\Delta$ 的元素。$N$ 的非零倍数是 $\\{ \\pm N, \\pm 2N, \\pm 3N, \\ldots \\}$。为确保与 $\\Delta$ 没有重叠，$N$ 的非零倍数的最小量级（即 $N$ 本身，因为 $N \\ge 1$）必须大于 $\\Delta$ 中任何元素的最大量级。\n$\\Delta$ 中的最大绝对值是 $|2n_{\\max}| = 2n_{\\max}$。\n所以，我们必须满足以下条件：\n$$ N > 2n_{\\max} $$\n问题要求满足此条件的最小整数 $N_{\\min}$。严格大于 $2n_{\\max}$ 的最小整数是 $2n_{\\max} + 1$。\n因此，$N_{\\min} = 2n_{\\max} + 1$。\n\n为了验证这个结果，让我们考虑 $N = 2n_{\\max}$ 的情况。如果我们选择 $n=n_{\\max}$ 和 $n'=-n_{\\max}$，这两个模都在容许集 $\\mathcal{S}$ 中。它们的差是 $n-n' = n_{\\max}-(-n_{\\max}) = 2n_{\\max} = 1 \\cdot N$。由于它们的差是 $N$ 的倍数，这两个模将会发生混叠，因此不可区分。这证实了 $N=2n_{\\max}$ 是不够的。因此，所需的最小整数探头数确实是 $2n_{\\max} + 1$。这对应于奈奎斯特-香农采样定理应用于一个周期信号，其傅里叶谱包含在模数范围 $[-n_{\\max}, n_{\\max}]$ 内，总跨度为 $2n_{\\max}$。",
            "answer": "$$\\boxed{2n_{\\max} + 1}$$"
        },
        {
            "introduction": "在信号处理中，一个常见的误区是将在时域信号末尾补零 (zero padding) 后得到的更平滑、更密集的频谱图误解为分辨率的提升。本实践通过一个编码练习，直观且定量地揭示频谱分辨率的真正来源。您将生成一个包含两个邻近频率成分的合成信号，并比较补零前后频谱的差异，从而深刻理解物理分辨率由观测时长决定，而与傅里叶变换的点数无关。",
            "id": "4024315",
            "problem": "考虑一个代表在环形聚变装置中测量的等离子体模式的合成磁涨落信号。该信号被建模为两个相干模式与弱宽带湍流之和，并在有限的观测时间内进行均匀采样。设采样率为每秒 $f_s$ 个样本，采集的样本数为 $N_0$，总观测时间为 $T_{\\text{obs}} = N_0 / f_s$。您将比较两个离散谱：一个是采集的 $N_0$ 个样本的离散傅里叶变换 (DFT)，另一个是将时间序列补零至更长长度 $N_{\\text{fft}}$（其中 $N_{\\text{fft}} = \\text{pad\\_factor} \\times N_0$）后的 DFT。目标是从第一性原理出发，证明补零只增加了频谱采样密度（即更多的 DFT 点），而不会改变由有限观测时间决定的内在分辨率。\n\n您的任务是：\n\n1. 生成一个离散时间信号 $x[n]$，其中 $n = 0,1,\\dots,N_0-1$，采样间隔为 $\\Delta t = 1/f_s$，其形式为\n$$\nx[n] = A_1 \\sin\\left(2\\pi f_1 n \\Delta t \\right) + A_2 \\sin\\left(2\\pi f_2 n \\Delta t \\right) + \\eta[n],\n$$\n其中 $A_1$ 和 $A_2$ 是振幅，$\\eta[n]$ 是具有小方差的独立同分布零均值高斯噪声。这两个相干分量可以解释为，例如，等离子体中存在的阿尔芬模式和漂移波模式。假设 $f_1$ 和 $f_2$ 严格低于奈奎斯特频率 $f_s/2$。\n\n2. 使用快速傅里叶变换 (FFT) 计算两个单边幅值谱：一个使用原始长度 $N_0$，另一个使用补零后的长度 $N_{\\text{fft}}$。对于两者，都使用返回非负频率分量的实数到复数 FFT。设相应的离散频率数组为 $f_k^{(0)}$ 和 $f_k^{(\\text{pad})}$，幅值为 $|X^{(0)}[k]|$ 和 $|X^{(\\text{pad})}[k]|$。\n\n3. 仅根据观测时间 $T_{\\text{obs}}$ 确定由有限观测时间所隐含的内在分辨率，记为 $\\Delta f_{\\text{intrinsic}}$。以赫兹为单位表示 $\\Delta f_{\\text{intrinsic}}$。\n\n4. 对未补零和补零后的两种频谱，确定频谱采样密度（定义为 DFT 频率仓间距）。设 $\\Delta f_{\\text{bin}}^{(0)}$ 为未补零的频率仓间距，$\\Delta f_{\\text{bin}}^{(\\text{pad})}$ 为补零后的频率仓间距。两者均以赫兹为单位表示。\n\n5. 对每个频谱执行一个感知分辨率的峰值计数程序，如下所示：\n   - 在幅值谱 $|X[k]|$ 中识别局部最大值，其值需超过全局最大幅值的一个分数（使用最大值的固定分数 $0.2$）。\n   - 使用相应的 $f_k$ 数组将峰值索引转换为频率位置。\n   - 将间距小于 $\\Delta f_{\\text{intrinsic}}$ 的峰值聚类为单个可分辨特征。将聚类的数量计为可分辨峰值的数量。\n\n6. 对于下方的每个测试用例，计算并报告一个五元素列表 $[\\Delta f_{\\text{intrinsic}}, \\Delta f_{\\text{bin}}^{(0)}, \\Delta f_{\\text{bin}}^{(\\text{pad})}, N_{\\text{res}}^{(0)}, N_{\\text{res}}^{(\\text{pad})}]$，其中 $N_{\\text{res}}^{(0)}$ 和 $N_{\\text{res}}^{(\\text{pad})}$ 是整数，分别代表未补零和补零后频谱中可分辨峰值的数量。\n\n使用以下测试套件，其旨在探究与计算聚变信号分析相关的典型、边界和亚分辨率情况。在所有情况下，使用 $A_1 = A_2 = 1$ 和噪声标准差 $0.02$（单位与 $x[n]$ 相同）：\n- 用例 1 (典型分离): $f_s = 20000$ Hz, $N_0 = 2048$, $\\text{pad\\_factor} = 8$, $f_1 = 1200$ Hz, $f_2 = f_1 + 5 \\times \\Delta f_{\\text{intrinsic}}$。\n- 用例 2 (类 Rayleigh 边界): $f_s = 20000$ Hz, $N_0 = 2048$, $\\text{pad\\_factor} = 8$, $f_1 = 3000$ Hz, $f_2 = f_1 + \\Delta f_{\\text{intrinsic}}$。\n- 用例 3 (亚分辨率分离): $f_s = 20000$ Hz, $N_0 = 2048$, $\\text{pad\\_factor} = 8$, $f_1 = 4500$ Hz, $f_2 = f_1 + 0.6 \\times \\Delta f_{\\text{intrinsic}}$。\n\n要求：\n- 所有频率量均以赫兹表示。\n- 最终程序输出必须是单行，包含一个由三个五元素列表组成的逗号分隔列表，用方括号括起来，并严格按照测试用例的顺序排列。例如，输出必须形如 $[[a_1,a_2,a_3,a_4,a_5],[b_1,b_2,b_3,b_4,b_5],[c_1,c_2,c_3,c_4,c_5]]$，其中每个 $a_i, b_i, c_i$ 是一个数字（计数为整数，频率量为以赫兹为单位的浮点数）。",
            "solution": "该问题要求通过分析离散谱来证明频谱分辨率是总观测时间的函数，而不是离散傅里叶变换 (DFT) 的点数（可以通过补零人为增加）的函数。这是信号处理中的一个基本概念，其根源在于傅里叶变换的性质。\n\n### 理论原理\n\n1.  **有限观测与频谱泄漏**：任何测量的持续时间都是有限的。在时间间隔 $T_{\\text{obs}}$ 内观测到的信号 $x(t)$ 在数学上可以建模为“真实”的无限信号乘以一个矩形窗函数 $w(t)$，该函数在观测期间为 $1$，其他时间为 $0$。根据卷积定理，时域中的这种乘法对应于频域中的卷积。矩形窗的傅里叶变换是一个 sinc 函数：$\\text{FT}\\{w(t)\\} \\propto \\text{sinc}(\\pi f T_{\\text{obs}})$，其中 $f$ 是频率。因此，任何信号分量（例如，纯正弦波，在频域中是一个 δ 函数）的测量频谱都与此 sinc 函数进行卷积。这会将尖锐谱线的能量扩散成一个带有旁瓣的宽峰，这种现象被称为频谱泄漏。\n\n2.  **内在分辨率**：区分两个相邻频率分量的能力称为频谱分辨率。在此背景下应用的 Rayleigh 判据指出，如果一个分量的 sinc 图样的峰值与另一个分量的第一个零点重合，则这两个分量恰好可分辨。$\\text{sinc}(\\pi f T_{\\text{obs}})$ 函数的第一个零点出现在 $f = \\pm 1/T_{\\text{obs}}$。因此，最小可分辨频率间隔由观测时间决定。这就给出了内在频率分辨率：\n    $$\n    \\Delta f_{\\text{intrinsic}} = \\frac{1}{T_{\\text{obs}}} = \\frac{f_s}{N_0}\n    $$\n    其中 $f_s$ 是采样率，$N_0$ 是样本数。这个分辨率极限是根本性的，无法通过对采集的 $N_0$ 个样本进行后期处理来克服。\n\n3.  **DFT 频率仓间距与分辨率**：离散傅里叶变换 (DFT) 在离散的频率点（或称“频率仓”）上计算频谱。对于长度为 $N_{\\text{fft}}$ 的 DFT，这些频率仓之间的间距为：\n    $$\n    \\Delta f_{\\text{bin}} = \\frac{f_s}{N_{\\text{fft}}}\n    $$\n    在执行 DFT 之前，将时域信号从其原始长度 $N_0$ 补零到新的长度 $N_{\\text{fft}} > N_0$，并不会增加新的信息，也不会增加 $T_{\\text{obs}}$。它只增加了 $N_{\\text{fft}}$。这减小了频率仓间距 $\\Delta f_{\\text{bin}}$，从而有效地对频谱进行内插。它提供了对底层 sinc 形频谱特征的更密集的采样和更平滑的图形，但并不能改变这些特征的宽度。因此，补零提高了*频谱采样密度*，但没有提高*内在分辨率*。\n\n### 算法流程\n\n遵循这些原理，通过实施指定的流程来解决该问题。\n\n1.  **信号生成**：对于每个测试用例，合成一个离散时间信号 $x[n]$。它由两个振幅为 $A_1=1$ 和 $A_2=1$、频率为 $f_1$ 和 $f_2$ 的正弦波，加上标准差为 $0.02$ 的零均值高斯噪声 $\\eta[n]$ 组成。时间轴由 $n=0, 1, \\dots, N_0-1$ 定义，采样间隔为 $\\Delta t = 1/f_s$。\n\n2.  **参数计算**：为每个用例计算关键频率指标。给定 $f_s = 20000$ Hz 和 $N_0 = 2048$：\n    -   观测时间: $T_{\\text{obs}} = N_0/f_s = 2048 / 20000 = 0.1024$ s。\n    -   内在分辨率: $\\Delta f_{\\text{intrinsic}} = 1/T_{\\text{obs}} = 1/0.1024 \\approx 9.7656$ Hz。\n    -   未补零的频率仓间距: $\\Delta f_{\\text{bin}}^{(0)} = f_s/N_0 = 20000/2048 \\approx 9.7656$ Hz。注意 $\\Delta f_{\\text{intrinsic}} = \\Delta f_{\\text{bin}}^{(0)}$。\n    -   补零后长度: $N_{\\text{fft}} = \\text{pad\\_factor} \\times N_0 = 8 \\times 2048 = 16384$。\n    -   补零后的频率仓间距: $\\Delta f_{\\text{bin}}^{(\\text{pad})} = f_s/N_{\\text{fft}} = 20000/16384 \\approx 1.2207$ Hz。\n\n3.  **频谱分析**：对于原始长度为 $N_0$ 的信号和补零后长度为 $N_{\\text{fft}}$ 的信号，使用实数到复数的快速傅里叶变换 (`scipy.fft.rfft`) 计算单边幅值谱。这会产生幅值数组 $|X^{(0)}[k]|$ 和 $|X^{(\\text{pad})}[k]|$ 以及它们相应的频率数组 $f_k^{(0)}$ 和 $f_k^{(\\text{pad})}$。\n\n4.  **感知分辨率的峰值计数**：一个自定义程序确定可分辨峰值的数量。\n    a.  识别幅值谱中的局部最大值。如果一个点 $|X[k]|$ 大于其直接相邻值 $|X[k-1]|$ 和 $|X[k+1]|$，则它是一个局部最大值。\n    b.  对这些最大值进行筛选，只保留超过全局最大值 $0.2$ 倍阈值的峰值。此步骤可排除由噪声引起的次要峰值。\n    c.  收集幸存峰值的频率。\n    d.  对峰值进行聚类。从频率最低的峰值开始，如果后续峰值与已排序列表中前一个峰值的频率间隔小于 $\\Delta f_{\\text{intrinsic}}$，则将它们分到同一聚类中。如果间隔更大，则开始一个新的聚类。\n    e.  聚类的总数 $N_{\\text{res}}$ 即为可分辨频谱特征的计数。此过程应用于未补零和补零后的两种频谱。\n\n### 分用例结果\n\n对三个指定的测试用例执行此程序。\n\n-   **用例 1 (典型分离)**：$f_2 - f_1 = 5 \\times \\Delta f_{\\text{intrinsic}} \\approx 48.83$ Hz。频率分离良好。分析在未补零和补零后的频谱中都能正确识别出两个清晰的峰值。我们预期 $N_{\\text{res}}^{(0)} = 2$ 和 $N_{\\text{res}}^{(\\text{pad})} = 2$。\n\n-   **用例 2 (类 Rayleigh 边界)**：$f_2 - f_1 = \\Delta f_{\\text{intrinsic}} \\approx 9.77$ Hz。频率间隔恰好等于内在分辨率极限。频谱特征（sinc 函数）显著重叠，但两个主峰之间应仍存在一个凹陷，使得局部最大值查找器能够识别出两个峰。预期两种分析都能将它们分辨出来，得到 $N_{\\text{res}}^{(0)} = 2$ 和 $N_{\\text{res}}^{(\\text{pad})} = 2$。补零后的频谱通过更好地采样连续形状，在视觉上更清晰地展示了两个峰的存在。\n\n-   **用例 3 (亚分辨率分离)**：$f_2 - f_1 = 0.6 \\times \\Delta f_{\\text{intrinsic}} \\approx 5.86$ Hz。频率间隔比分辨率极限更近。两个重叠的 sinc 图样合并成一个更宽的单峰。峰值计数算法将在感兴趣的区域只找到一个局部最大值。预期两种分析都无法分辨这两个模式，得到 $N_{\\text{res}}^{(0)} = 1$ 和 $N_{\\text{res}}^{(\\text{pad})} = 1$。这个用例关键地展示了，尽管补零使单个峰的形状更平滑，但它无法分离不可分辨的分量。\n\n最终输出将包含每个用例的五元素列表 $[\\Delta f_{\\text{intrinsic}}, \\Delta f_{\\text{bin}}^{(0)}, \\Delta f_{\\text{bin}}^{(\\text{pad})}, N_{\\text{res}}^{(0)}, N_{\\text{res}}^{(\\text{pad})}]$，从而证实 $N_{\\text{res}}^{(0)}$ 和 $N_{\\text{res}}^{(\\text{pad})}$ 在所有场景中都是相同的，进而验证了其基本原理。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import fft\n\ndef count_resolved_peaks(mag_spec, freq_array, delta_f_intrinsic, threshold_frac=0.2):\n    \"\"\"\n    Identifies and clusters peaks in a spectrum to count resolvable features.\n    \n    Args:\n        mag_spec (np.ndarray): The magnitude spectrum.\n        freq_array (np.ndarray): The corresponding frequency array.\n        delta_f_intrinsic (float): The intrinsic frequency resolution.\n        threshold_frac (float): Fraction of the global maximum for peak thresholding.\n        \n    Returns:\n        int: The number of resolvable peaks (clusters).\n    \"\"\"\n    if len(mag_spec)  3:\n        return 0\n\n    global_max = np.max(mag_spec)\n    if global_max == 0:\n        return 0\n    threshold = threshold_frac * global_max\n\n    # Find indices of all local maxima\n    local_max_indices = []\n    for i in range(1, len(mag_spec) - 1):\n        if mag_spec[i] > mag_spec[i-1] and mag_spec[i] > mag_spec[i+1]:\n            local_max_indices.append(i)\n\n    # Filter maxima by the amplitude threshold\n    peak_indices = [i for i in local_max_indices if mag_spec[i] > threshold]\n    \n    if not peak_indices:\n        return 0\n\n    # Get frequencies of the filtered peaks\n    peak_freqs = freq_array[peak_indices]\n    \n    # Cluster peaks based on intrinsic resolution\n    clusters = [[peak_freqs[0]]]\n    for i in range(1, len(peak_freqs)):\n        freq = peak_freqs[i]\n        # Compare with the last frequency in the last cluster\n        if freq - clusters[-1][-1]  delta_f_intrinsic:\n            clusters[-1].append(freq)\n        else:\n            # Start a new cluster\n            clusters.append([freq])\n            \n    return len(clusters)\n\ndef analyze_case(fs, N0, pad_factor, f1_base, f2_offset_factor, A1, A2, noise_stddev, seed):\n    \"\"\"\n    Performs the full analysis for a single test case.\n    \n    Args:\n        fs (float): Sampling frequency in Hz.\n        N0 (int): Number of initial samples.\n        pad_factor (int): Zero-padding factor.\n        f1_base (float): Base frequency for the first sinusoid in Hz.\n        f2_offset_factor (float): Multiplier for delta_f_intrinsic to get f2's offset.\n        A1 (float): Amplitude of the first sinusoid.\n        A2 (float): Amplitude of the second sinusoid.\n        noise_stddev (float): Standard deviation of the Gaussian noise.\n        seed (int): Seed for the random number generator.\n        \n    Returns:\n        list: A five-element list with the analysis results.\n    \"\"\"\n    # 1. Calculate intrinsic resolution and bin spacings\n    T_obs = N0 / fs\n    delta_f_intrinsic = 1.0 / T_obs\n    \n    delta_f_bin_0 = fs / N0\n    \n    N_fft = pad_factor * N0\n    delta_f_bin_pad = fs / N_fft\n\n    # Determine component frequencies for the case\n    f1 = f1_base\n    f2 = f1_base + f2_offset_factor * delta_f_intrinsic\n\n    # 2. Generate the signal\n    rng = np.random.default_rng(seed)\n    delta_t = 1.0 / fs\n    n = np.arange(N0)\n    t = n * delta_t\n    noise = rng.normal(loc=0.0, scale=noise_stddev, size=N0)\n    x = A1 * np.sin(2 * np.pi * f1 * t) + A2 * np.sin(2 * np.pi * f2 * t) + noise\n\n    # 3. Analyze unpadded spectrum\n    X0_k = fft.rfft(x)\n    mag_X0 = np.abs(X0_k)\n    freqs_0 = fft.rfftfreq(N0, d=delta_t)\n    N_res_0 = count_resolved_peaks(mag_X0, freqs_0, delta_f_intrinsic)\n\n    # 4. Analyze zero-padded spectrum\n    Xpad_k = fft.rfft(x, n=N_fft)\n    mag_Xpad = np.abs(Xpad_k)\n    freqs_pad = fft.rfftfreq(N_fft, d=delta_t)\n    N_res_pad = count_resolved_peaks(mag_Xpad, freqs_pad, delta_f_intrinsic)\n    \n    return [delta_f_intrinsic, delta_f_bin_0, delta_f_bin_pad, N_res_0, N_res_pad]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    # Define common parameters for all test cases\n    common_params = {\n        'fs': 20000.0,\n        'N0': 2048,\n        'pad_factor': 8,\n        'A1': 1.0,\n        'A2': 1.0,\n        'noise_stddev': 0.02\n    }\n\n    # Define the specific parameters for each test case\n    test_cases = [\n        # (f1_base, f2_offset_factor, seed)\n        {'f1_base': 1200.0, 'f2_offset_factor': 5.0, 'seed': 42}, # Case 1\n        {'f1_base': 3000.0, 'f2_offset_factor': 1.0, 'seed': 43}, # Case 2\n        {'f1_base': 4500.0, 'f2_offset_factor': 0.6, 'seed': 44}  # Case 3\n    ]\n    \n    results = []\n    for case_params in test_cases:\n        # Combine common and case-specific parameters\n        params = {**common_params, **case_params}\n        res = analyze_case(**params)\n        results.append(res)\n    \n    # Format the final output string exactly as required\n    case_results_str = []\n    for case_result in results:\n        case_results_str.append(f\"[{','.join(map(str, case_result))}]\")\n    \n    final_output = f\"[{','.join(case_results_str)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "将理论付诸实践，本练习探讨了在数据采集系统中一个核心的工程问题：如何在降低数据采样率（抽取）的同时，保证信号不被破坏。您将为一个高采样率的干涉仪数据设计一个多级抽取链，其中关键任务是为每个抽取阶段设计合适的抗混叠滤波器。这个过程将加深您对滤波器设计中过渡带、阻带衰减和计算成本之间权衡的理解，并巩固抗混叠在实际多速率信号处理中的核心作用。",
            "id": "4024333",
            "problem": "您正在为计算聚变科学与工程中的干涉仪数据设计一个多级抽取链。目标是使用级联抽取器将以 $f_{s,0} = 5\\,\\text{MHz}$ 采样的离散时间高率信号转换为 $f_{\\text{out}} = 500\\,\\text{kHz}$ 的低率数据流，同时保留截至保证通带边缘 $f_p$ 的信号内容，并实现最小为 $A$ 分贝 ($\\text{dB}$) 的混叠抑制。该抽取链由一系列整数抽取因子 $\\{M_i\\}_{i=1}^L$ 指定，满足 $\\prod_{i=1}^L M_i = f_{s,0}/f_{\\text{out}}$。每个抽取器前都有一个低通抗混叠滤波器。\n\n从 Shannon-Nyquist 采样定理和整数因子下采样的定义出发，推导每个抽取级之前的抗混叠滤波器必须满足的条件，以防止带外内容混叠到保留频带中。将每个阶段 $i$ 建模如下：\n- 第 $i$ 级的输入采样率为 $f_{s,i-1}$，其中 $f_{s,0} = 5\\,\\text{MHz}$。\n- 抽取因子为 $M_i \\in \\mathbb{Z}_{\\ge 2}$，该级的输出采样率为 $f_{s,i} = f_{s,i-1}/M_i$。\n- 第 $i$ 级的折叠（混叠）频率为 $f_{\\text{fold},i} = f_{s,i-1}/(2 M_i)$。\n- 必须端到端保留的通带边缘是 $f_p$，为确保带外内容不产生混叠，阻带的起始频率不得晚于 $f_{\\text{fold},i}$。\n- 第 $i$ 级的过渡带宽为 $\\Delta f_i = f_{\\text{fold},i} - f_p$，为使该级可行，此值必须为严格正数。\n\n假设每个阶段都采用通过传统 Kaiser 窗方法设计的线性相位有限冲激响应 (FIR) 低通原型滤波器。使用一个经过充分测试的合成界限来确定最小 FIR 阶数 $N_i$，该阶数在给定过渡带宽 $\\Delta \\omega_i$（单位为弧度/样本）的情况下，保证阻带衰减至少为 $A$ 分贝 ($\\text{dB}$)，其中 $\\Delta \\omega_i = 2\\pi \\Delta f_i / f_{s,i-1}$。滤波器阶数 $N_i$ 定义为延迟元件的数量，即抽头数减一。使用满足该界限的最小整数 $N_i$。保守地处理每个阶段的衰减要求，即要求每个阶段自身都必须满足完整的 $A$ 分贝衰减。如果任何阶段的 $\\Delta f_i \\le 0$，则声明该链为不可行。\n\n所有涉及频率的量都必须以 $\\text{Hz}$ 表示。角度以弧度表示。预期的输出是每个阶段的整数滤波器阶数。如果一个测试用例不可行（例如，如果 $\\prod_i M_i \\ne f_{s,0}/f_{\\text{out}}$ 作为整数不成立，或任何阶段的 $\\Delta f_i \\le 0$），则对该用例返回单元素列表 $[-1]$。\n\n您的程序必须实现上述逻辑，并为以下每个测试用例计算各级滤波器阶数的列表，每个用例指定为元组 $(f_{s,0}, f_{\\text{out}}, f_p, A, [M_1, M_2, \\dots, M_L])$：\n- 案例 A（正常多级路径）：$(5{,}000{,}000, 500{,}000, 200{,}000, 80, [5, 2])$。\n- 案例 B（备选级序）：$(5{,}000{,}000, 500{,}000, 200{,}000, 80, [2, 5])$。\n- 案例 C（单级基准）：$(5{,}000{,}000, 500{,}000, 200{,}000, 80, [10])$。\n- 案例 D（近边界保留）：$(5{,}000{,}000, 500{,}000, 245{,}000, 80, [2, 5])$。\n- 案例 E（不可行的保留请求）：$(5{,}000{,}000, 500{,}000, 260{,}000, 80, [2, 5])$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表的每个元素是代表该测试用例各级滤波器阶数的整数列表（如果不可行，则为 $[-1]$）。例如，一个包含两个案例的输出应类似于 $[[N_{1,A},N_{2,A}], [N_{1,B},N_{2,B}]]$，其中所有 $N$ 均为整数，且无附加文本。",
            "solution": "问题要求推导并实现一个设计多级抽取滤波链的程序。设计目标是确定一系列有限冲激响应 (FIR) 抗混叠滤波器所需的最小阶数。\n\n### 步骤 1：提取已知条件\n- 初始采样率：$f_{s,0} = 5\\,\\text{MHz} = 5,000,000\\,\\text{Hz}$\n- 最终输出采样率：$f_{\\text{out}} = 500\\,\\text{kHz} = 500,000\\,\\text{Hz}$\n- 总抽取因子：$\\prod_{i=1}^L M_i = f_{s,0}/f_{\\text{out}}$\n- $L$ 级的整数抽取因子序列：$\\{M_i\\}_{i=1}^L$，其中 $M_i \\in \\mathbb{Z}_{\\ge 2}$\n- 保证的通带边缘：$f_p$\n- 每级最小混叠抑制：$A$ (dB)\n- 第 $i$ 级的输入采样率：$f_{s,i-1}$\n- 第 $i$ 级的输出采样率：$f_{s,i} = f_{s,i-1}/M_i$\n- 第 $i$ 级的折叠频率：$f_{\\text{fold},i} = f_{s,i-1}/(2 M_i)$\n- 第 $i$ 级的过渡带宽：$\\Delta f_i = f_{\\text{fold},i} - f_p$\n- 第 $i$ 级的可行性条件：$\\Delta f_i  0$\n- FIR 滤波器设计方法：Kaiser 窗\n- 第 $i$ 级的归一化过渡带宽：$\\Delta \\omega_i = 2\\pi \\Delta f_i / f_{s,i-1}$\n- FIR 滤波器阶数界限：满足阻带衰减为 $A\\,\\text{dB}$ 的界限的最小整数 $N_i$。\n- 链不可行的条件：对于任何级 $i$，$\\Delta f_i \\le 0$，或 $\\prod M_i \\neq f_{s,0}/f_{\\text{out}}$。在这种情况下，输出为 $[-1]$。\n- 测试用例：\n  - 案例 A: $(f_{s,0}=5000000, f_{\\text{out}}=500000, f_p=200000, A=80, M=[5, 2])$\n  - 案例 B: $(f_{s,0}=5000000, f_{\\text{out}}=500000, f_p=200000, A=80, M=[2, 5])$\n  - 案例 C: $(f_{s,0}=5000000, f_{\\text{out}}=500000, f_p=200000, A=80, M=[10])$\n  - 案例 D: $(f_{s,0}=5000000, f_{\\text{out}}=500000, f_p=245000, A=80, M=[2, 5])$\n  - 案例 E: $(f_{s,0}=5000000, f_{\\text{out}}=500000, f_p=260000, A=80, M=[2, 5])$\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在科学上基于数字信号处理的既定原则，特别是多速率系统和 FIR 滤波器设计。问题陈述清晰，提供了为每个测试用例得出唯一解所需的所有参数、定义和约束。语言客观、正式。所描述的任务是数据采集系统设计中的一个标准工程问题。该问题未违反任何无效性标准。\n\n### 步骤 3：结论与行动\n问题有效。将提供完整解决方案。\n\n### 基于原理的设计与推导\n\n通过整数因子 $M$ 进行抽取（或下采样）的过程会降低离散信号的采样率。如果此操作不谨慎执行，可能导致混叠，即原始信号中的高频内容在下采样后的信号中伪装成低频内容。Shannon-Nyquist 采样定理规定了避免这种情况的条件。\n\n对于输入采样率为 $f_{s,i-1}$、抽取因子为 $M_i$ 的抽取级 $i$，输出采样率变为 $f_{s,i} = f_{s,i-1}/M_i$。新的奈奎斯特频率是 $f_{s,i}/2$。输入信号中介于 $f_{s,i}/2$ 和 $f_{s,i-1}/2$ 之间的任何频率内容都将“折叠”到基带 $[0, f_{s,i}/2]$ 中。\n\n为防止这种失真，必须在下采样之前应用抗混叠低通滤波器。此滤波器必须满足两个主要约束：\n1.  **通带**：必须保留所需的信号内容。问题指定必须保留所有频率高达通带边缘 $f_p$ 的内容。因此，滤波器的通带必须延伸至 $f_p$。\n2.  **阻带**：必须充分衰减会混叠到保留通带中的频率。第一个也是最关键的折叠作用发生在新奈奎斯特频率周围，问题将其定义为折叠频率 $f_{\\text{fold},i} = f_{s,i-1}/(2M_i) = f_{s,i}/2$。为保守地防止任何混叠，滤波器的阻带必须在该频率或之前开始。\n\n从通带到阻带的过渡不可能瞬时完成。通带结束点 $f_p$ 和阻带起始点 $f_{\\text{stop},i}$ 之间的频率范围是过渡带宽。为了最大化此带宽从而最小化滤波器复杂度（阶数），我们将阻带的起始点精确地设置在折叠频率处，即 $f_{\\text{stop},i} = f_{\\text{fold},i}$。\n\n因此，第 $i$ 级滤波器的过渡带宽 $\\Delta f_i$ 为：\n$$ \\Delta f_i = f_{\\text{stop},i} - f_p = f_{\\text{fold},i} - f_p = \\frac{f_{s,i-1}}{2M_i} - f_p $$\n对于一个物理可实现的滤波器，此过渡带宽必须为严格正数，$\\Delta f_i  0$。如果 $f_p \\ge f_{\\text{fold},i}$，则不可能同时满足通带和阻带的要求，从而使该级的设计不可行。\n\nFIR 滤波器的所需阶数主要由阻带衰减 $A$ 和归一化过渡带宽 $\\Delta \\omega$ 决定。归一化是相对于滤波器输入采样率 $f_{s,i-1}$ 进行的。\n$$ \\Delta \\omega_i = 2\\pi \\frac{\\Delta f_i}{f_{s,i-1}} $$\n对于使用 Kaiser 窗方法设计的 FIR 滤波器，一个广泛使用的用于估算最小滤波器阶数 $N$（定义为抽头数减一）的经验公式为：\n$$ N \\ge \\frac{A - 8}{2.285 \\, \\Delta\\omega} $$\n其中 $A$ 是以分贝 ($\\text{dB}$) 为单位的阻带衰减，且大于 21。问题要求采用保守方法，即每个级都必须提供完整的衰减 $A$。因此，对于每个级 $i$，我们计算满足此界限的最小整数阶数 $N_i$：\n$$ N_i = \\left\\lceil \\frac{A - 8}{2.285 \\, \\Delta\\omega_i} \\right\\rceil $$\n\n对于给定的测试用例 $(f_{s,0}, f_{\\text{out}}, f_p, A, [M_1, \\dots, M_L])$，总体算法如下：\n1.  验证总抽取因子：检查是否 $f_{s,0} = f_{\\text{out}} \\times \\prod_{i=1}^L M_i$。如果不是，则该链无效。\n2.  初始化当前采样率：$f_{s,\\text{current}} \\leftarrow f_{s,0}$。初始化一个空列表 `orders` 用于存放滤波器阶数。\n3.  对每个级 $i=1, \\dots, L$（抽取因子为 $M_i$）进行迭代：\n    a.  设置该级的输入采样率：$f_{s,i-1} = f_{s,\\text{current}}$。\n    b.  计算折叠频率：$f_{\\text{fold},i} = f_{s,i-1} / (2 M_i)$。\n    c.  计算过渡带宽：$\\Delta f_i = f_{\\text{fold},i} - f_p$。\n    d.  检查可行性：如果 $\\Delta f_i \\le 0$，则该链不可行。中止并返回 $[-1]$。\n    e.  计算归一化过渡带宽：$\\Delta \\omega_i = (2\\pi \\Delta f_i) / f_{s,i-1}$。\n    f.  计算所需滤波器阶数：$N_i = \\lceil (A - 8) / (2.285 \\Delta \\omega_i) \\rceil$。\n    g.  将整数 $N_i$ 附加到 `orders` 列表中。\n    h.  为下一级更新当前采样率：$f_{s,\\text{current}} = f_{s,i-1} / M_i$。\n4.  如果循环成功完成，返回列表 `orders`。\n\n此程序将应用于每个测试用例以生成最终结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to solve the multistage decimation filter design problem.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (fs_0, f_out, f_p, A, [M1, M2, ...])\n        (5000000, 500000, 200000, 80, [5, 2]),      # Case A\n        (5000000, 500000, 200000, 80, [2, 5]),      # Case B\n        (5000000, 500000, 200000, 80, [10]),       # Case C\n        (5000000, 500000, 245000, 80, [2, 5]),      # Case D\n        (5000000, 500000, 260000, 80, [2, 5]),      # Case E\n    ]\n\n    def calculate_filter_orders(fs_0, f_out, f_p, A, M_list):\n        \"\"\"\n        Calculates the required FIR filter orders for a multistage decimation chain.\n\n        Args:\n            fs_0 (int): Initial sampling rate in Hz.\n            f_out (int): Final output sampling rate in Hz.\n            f_p (int): Passband edge to be preserved in Hz.\n            A (float): Required stopband attenuation in dB.\n            M_list (list of int): List of integer decimation factors.\n\n        Returns:\n            list of int: A list of calculated filter orders for each stage,\n                         or [-1] if the chain is infeasible.\n        \"\"\"\n        # Validate total decimation factor. The problem implies integer arithmetic.\n        total_m = np.prod(M_list)\n        if fs_0 != f_out * total_m:\n            return [-1]\n\n        orders = []\n        current_fs = float(fs_0)\n        \n        for M_i in M_list:\n            if M_i  2:  # Decimation factors must be integers >= 2\n                return [-1]\n\n            fs_in_stage = current_fs\n            \n            # Calculate the folding frequency for the current stage\n            f_fold_i = fs_in_stage / (2.0 * M_i)\n            \n            # Calculate the transition width\n            delta_f_i = f_fold_i - f_p\n            \n            # Check for feasibility: transition width must be positive\n            if delta_f_i = 0:\n                return [-1]\n            \n            # Calculate the normalized transition width (radians per sample)\n            delta_omega_i = 2.0 * math.pi * delta_f_i / fs_in_stage\n            \n            # Estimate filter order N using Kaiser's formula\n            # N_i = ceil((A - 8) / (2.285 * delta_omega_i))\n            # The formula is valid for A > 21 dB.\n            if A = 8: # Avoid division by zero or negative arguments to ceil if A is low\n                N_i = 0\n            else:\n                numerator = A - 8.0\n                denominator = 2.285 * delta_omega_i\n                N_i = math.ceil(numerator / denominator)\n            \n            orders.append(int(N_i))\n            \n            # Update the sampling rate for the next stage\n            current_fs /= M_i\n            \n        return orders\n\n    results = []\n    for case in test_cases:\n        result = calculate_filter_orders(*case)\n        results.append(result)\n\n    # Format the final output string exactly as required, without spaces in lists.\n    # E.g., [[84,101],[-1]]\n    str_results = [str(res).replace(\" \", \"\") for res in results]\n    final_output_string = f\"[{','.join(str_results)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}