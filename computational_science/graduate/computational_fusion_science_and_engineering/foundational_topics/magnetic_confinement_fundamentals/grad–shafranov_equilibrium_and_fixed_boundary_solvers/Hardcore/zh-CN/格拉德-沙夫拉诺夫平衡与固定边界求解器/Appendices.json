{
    "hands_on_practices": [
        {
            "introduction": "在数值求解Grad-Shafranov方程之前，我们必须首先将其微分算子 $\\Delta^\\star$ 在离散网格上进行表示。本实践专注于推导一个二阶精度的有限差分格式，这是任何固定边界求解器的基本构建模块。通过实施并对照已知的解析解来测试这个格式，您将直接体验将连续物理模型转化为计算算法并验证其准确性的关键步骤 。",
            "id": "3986297",
            "problem": "考虑计算聚变科学与工程中用于 Grad–Shafranov 方程固定边界求解器的轴对称磁静力学平衡。从磁静力学的基本定律，即安培定律 $\\nabla \\times \\mathbf{B} = \\mu_{0}\\mathbf{J}$ 和磁高斯定律 $\\nabla \\cdot \\mathbf{B} = 0$，以及磁流体动力学力平衡 $\\mathbf{J} \\times \\mathbf{B} = \\nabla p$ 和磁场在柱坐标 $(R,\\phi,Z)$ 中无环向变化的轴对称表示出发。基于这些基本原理和柱坐标微分算子的标准定义，可以推导出一个关于极向磁通函数 $\\psi(R,Z)$ 的椭圆型偏微分方程 (PDE)，其中一个线性自伴算子作用于 $\\psi(R,Z)$。\n\n你的任务是，在一个均匀的 $(R,Z)$ 网格上，为这个作用于 $\\psi(R,Z)$ 的线性算子推导一个二阶精度的有限差分格式。特别地，该算子包含一个形式为 $R \\,\\partial/\\partial R$ 的加权径向导数，作用于一个包含因子 $1/R$ 的量。你必须清楚地表述如何在一个均匀网格上，使用面心权重以一种守恒且二阶精度的方式来近似这个径向部分。然后，通过添加具有二阶精度的 $Z$ 轴向部分来完成二维格式。\n\n在符号上推导出该格式后，在一个程序中实现它，并通过与解析解的比较来验证其二阶精度。使用一个均匀的张量积网格，在 $R$ 方向上有 $N_{R}$ 个点，在 $Z$ 方向上有 $N_{Z}$ 个点，均包含边界。设网格节点为 $R_{i}$（$i = 0,\\dots,N_{R}-1$）和 $Z_{j}$（$j = 0,\\dots,N_{Z}-1$），间距分别为 $\\Delta R = (R_{\\max}-R_{\\min})/(N_{R}-1)$ 和 $\\Delta Z = (Z_{\\max}-Z_{\\min})/(N_{Z}-1)$。通过在边界上计算精确的解析解 $\\psi(R,Z)$ 来施加固定的（狄利克雷）边界值。仅在索引 $i=1,\\dots,N_{R}-2$ 和 $j=1,\\dots,N_{Z}-2$ 范围内的内部点上应用你的内部格式。三角函数中的所有角度都必须以弧度为单位。所有量都是无量纲的，因此以无量纲数的形式报告误差。\n\n使用以下参数值的测试套件。对于每种情况，计算最大范数误差 $E_{\\infty}$，其定义为你的离散算子应用于 $\\psi$ 的结果与在内部节点上计算的精确解析算子之间的最大绝对差。\n\n- 测试用例 1（加权径向项的零空间检验）：\n  - 区域：$R \\in [0.8,\\,1.2]$, $Z \\in [-0.5,\\,0.5]$。\n  - 分辨率：$N_{R} = 33$, $N_{Z} = 33$。\n  - 解析场：$\\psi(R,Z) = \\frac{1}{2} R^{2}$。\n- 测试用例 2（中等网格上的多项式）：\n  - 区域：$R \\in [1.0,\\,2.0]$, $Z \\in [-1.0,\\,1.0]$。\n  - 分辨率：$N_{R} = 33$, $N_{Z} = 33$。\n  - 解析场：$\\psi(R,Z) = R^{4} + Z^{4} + R^{2} Z$。\n- 测试用例 3（加密网格上的多项式以评估收敛性）：\n  - 区域：$R \\in [1.0,\\,2.0]$, $Z \\in [-1.0,\\,1.0]$。\n  - 分辨率：$N_{R} = 65$, $N_{Z} = 65$。\n  - 解析场：$\\psi(R,Z) = R^{4} + Z^{4} + R^{2} Z$。\n- 测试用例 4（较小 $R$ 值域上的三角-双曲场）：\n  - 区域：$R \\in [0.2,\\,0.9]$, $Z \\in [-0.3,\\,0.3]$。\n  - 分辨率：$N_{R} = 49$, $N_{Z} = 49$。\n  - 解析场：$\\psi(R,Z) = \\sin(R)\\,\\cosh(Z)$。\n- 测试用例 5（测试用例 4 的加密）：\n  - 区域：$R \\in [0.2,\\,0.9]$, $Z \\in [-0.3,\\,0.3]$。\n  - 分辨率：$N_{R} = 97$, $N_{Z} = 97$。\n  - 解析场：$\\psi(R,Z) = \\sin(R)\\,\\cosh(Z)$。\n\n你的程序必须：\n- 为每个测试用例构建网格，从解析解 $\\psi(R,Z)$ 计算边界数据，在内部节点上应用推导出的二阶格式，并计算每种情况下的 $E_{\\infty}$。\n- 最终输出必须为单行，包含一个 Python 风格的列表，其中按测试用例的顺序列出五个 $E_{\\infty}$ 值，不含任何额外文本。例如，输出必须看起来像 $[e_{1},e_{2},e_{3},e_{4},e_{5}]$，其中每个 $e_{k}$ 都是一个浮点数。",
            "solution": "该问题要求为 Grad–Shafranov 方程中的线性算子推导一个二阶精度的有限差分格式，并随后通过编程实现来验证其精度。\n\n### Grad–Shafranov 算子的推导\n\n我们从等离子体中磁静力学的基本方程开始，假设为静态平衡（$\\partial/\\partial t = 0$）：\n1.  安培定律：$\\nabla \\times \\mathbf{B} = \\mu_0 \\mathbf{J}$\n2.  磁高斯定律：$\\nabla \\cdot \\mathbf{B} = 0$\n3.  力平衡：$\\mathbf{J} \\times \\mathbf{B} = \\nabla p$\n\n我们在柱坐标 $(R, \\phi, Z)$ 中进行分析，并假设轴对称性，这意味着所有物理量都与环向角 $\\phi$ 无关，即 $\\partial/\\partial\\phi = 0$。\n\n根据 $\\nabla \\cdot \\mathbf{B} = 0$，磁场 $\\mathbf{B}$ 可以表示为矢量势 $\\mathbf{A}$ 的旋度。对于轴对称系统，可以方便地定义极向磁通函数 $\\psi(R,Z)$，使得磁场的极向分量由下式给出：\n$$ \\mathbf{B}_p = B_R \\hat{R} + B_Z \\hat{Z} = \\frac{1}{R} \\nabla\\psi \\times \\hat{\\phi} $$\n展开此定义，我们得到分量：\n$$ B_R(R,Z) = -\\frac{1}{R}\\frac{\\partial\\psi}{\\partial Z} \\quad \\text{和} \\quad B_Z(R,Z) = \\frac{1}{R}\\frac{\\partial\\psi}{\\partial R} $$\n这种形式自动满足了高斯定律的极向部分，$\\nabla \\cdot \\mathbf{B}_p = \\frac{1}{R}\\frac{\\partial}{\\partial R}(R B_R) + \\frac{\\partial B_Z}{\\partial Z} = 0$。完整的磁场还包括一个环向分量，$\\mathbf{B} = \\mathbf{B}_p + B_\\phi(R,Z)\\hat{\\phi}$。\n\n接下来，我们使用安培定律将磁场与电流密度 $\\mathbf{J}$ 联系起来。电流密度的环向分量 $J_\\phi$ 与极向磁场有关：\n$$ \\mu_0 J_\\phi = (\\nabla \\times \\mathbf{B}_p) \\cdot \\hat{\\phi} = \\frac{\\partial B_R}{\\partial Z} - \\frac{\\partial B_Z}{\\partial R} $$\n将以 $\\psi$ 表示的 $B_R$ 和 $B_Z$ 的表达式代入：\n$$ \\mu_0 J_\\phi = \\frac{\\partial}{\\partial Z}\\left(-\\frac{1}{R}\\frac{\\partial\\psi}{\\partial Z}\\right) - \\frac{\\partial}{\\partial R}\\left(\\frac{1}{R}\\frac{\\partial\\psi}{\\partial R}\\right) $$\n$$ \\mu_0 J_\\phi = -\\frac{1}{R}\\frac{\\partial^2\\psi}{\\partial Z^2} - \\left(-\\frac{1}{R^2}\\frac{\\partial\\psi}{\\partial R} + \\frac{1}{R}\\frac{\\partial^2\\psi}{\\partial R^2}\\right) = -\\frac{1}{R}\\left(\\frac{\\partial^2\\psi}{\\partial R^2} - \\frac{1}{R}\\frac{\\partial\\psi}{\\partial R} + \\frac{\\partial^2\\psi}{\\partial Z^2}\\right) $$\n此表达式定义了 Grad–Shafranov 算子，记作 $\\Delta^*$：\n$$ \\Delta^*\\psi \\equiv \\frac{\\partial^2\\psi}{\\partial R^2} - \\frac{1}{R}\\frac{\\partial\\psi}{\\partial R} + \\frac{\\partial^2\\psi}{\\partial Z^2} $$\n力平衡方程将其与压强 $p$ 和环向场函数 $F(\\psi) = R B_\\phi$ 联系起来，从而得到完整的 Grad–Shafranov 方程 $\\Delta^*\\psi = - \\mu_0 R^2 \\frac{dp}{d\\psi} - F \\frac{dF}{d\\psi}$。当前的任务是离散化作用于 $\\psi$ 的线性微分算子 $\\Delta^*$。为了得到一个守恒的有限差分公式，最好将算子写成其自伴形式，正如问题陈述所建议的：\n$$ \\Delta^*\\psi = R\\frac{\\partial}{\\partial R}\\left(\\frac{1}{R}\\frac{\\partial\\psi}{\\partial R}\\right) + \\frac{\\partial^2\\psi}{\\partial Z^2} $$\n这就是我们将要离散化的算子。\n\n### 有限差分格式的推导\n\n我们考虑一个均匀的张量积网格，其节点为 $(R_i, Z_j)$，其中 $R_i = R_{\\min} + i\\Delta R$ ($i=0, \\dots, N_R-1$)，$Z_j = Z_{\\min} + j\\Delta Z$ ($j=0, \\dots, N_Z-1$)。网格间距为 $\\Delta R = (R_{\\max}-R_{\\min})/(N_R-1)$ 和 $\\Delta Z = (Z_{\\max}-Z_{\\min})/(N_Z-1)$。令 $\\psi_{i,j} = \\psi(R_i, Z_j)$。\n\n离散化在内部网格节点 $(i,j)$ 上进行，其中 $1 \\le i \\le N_R-2$ 且 $1 \\le j \\le N_Z-2$。\n\n**轴向部分：** 关于 $Z$ 的二阶偏导数使用标准的二阶中心差分公式来近似：\n$$ \\left. \\frac{\\partial^2\\psi}{\\partial Z^2} \\right|_{i,j} \\approx \\frac{\\psi_{i,j+1} - 2\\psi_{i,j} + \\psi_{i,j-1}}{(\\Delta Z)^2} $$\n\n**径向部分：** 算子的径向部分是 $L_R\\psi = R\\frac{\\partial}{\\partial R}\\left(\\frac{1}{R}\\frac{\\partial\\psi}{\\partial R}\\right)$。为了实现一个守恒且二阶精度的离散化，我们采用一种“面心”或类有限体积的方法。令 $F_R(R) = \\frac{1}{R}\\frac{\\partial\\psi}{\\partial R}$ 为径向通量。$R_i$ 处的算子是 $R_i \\frac{\\partial F_R}{\\partial R}|_{R_i}$。我们使用在单元面上的中心差分来近似通量的导数，这些面位于半整数网格索引 $R_{i\\pm 1/2} = R_i \\pm \\Delta R/2$ 处：\n$$ \\left. \\frac{\\partial F_R}{\\partial R} \\right|_{R_i} \\approx \\frac{F_R(R_{i+1/2}) - F_R(R_{i-1/2})}{\\Delta R} $$\n在这些面心处的通量 $F_R$ 本身也使用关于 $\\psi$ 导数的二阶中心差分来近似：\n$$ F_R(R_{i+1/2}) = \\left. \\frac{1}{R}\\frac{\\partial\\psi}{\\partial R} \\right|_{R_{i+1/2}} \\approx \\frac{1}{R_{i+1/2}} \\frac{\\psi_{i+1,j} - \\psi_{i,j}}{\\Delta R} $$\n$$ F_R(R_{i-1/2}) = \\left. \\frac{1}{R}\\frac{\\partial\\psi}{\\partial R} \\right|_{R_{i-1/2}} \\approx \\frac{1}{R_{i-1/2}} \\frac{\\psi_{i,j} - \\psi_{i-1,j}}{\\Delta R} $$\n将这些代入算子的表达式中，离散的径向算子 $(L_R\\psi)_{i,j}$ 变为：\n$$ (L_R\\psi)_{i,j} \\approx R_i \\frac{1}{\\Delta R} \\left( \\frac{1}{R_{i+1/2}} \\frac{\\psi_{i+1,j} - \\psi_{i,j}}{\\Delta R} - \\frac{1}{R_{i-1/2}} \\frac{\\psi_{i,j} - \\psi_{i-1,j}}{\\Delta R} \\right) $$\n$$ (L_R\\psi)_{i,j} \\approx \\frac{R_i}{(\\Delta R)^2} \\left[ \\frac{1}{R_{i-1/2}}\\psi_{i-1,j} - \\left(\\frac{1}{R_{i+1/2}} + \\frac{1}{R_{i-1/2}}\\right)\\psi_{i,j} + \\frac{1}{R_{i+1/2}}\\psi_{i+1,j} \\right] $$\n其中 $R_{i\\pm 1/2} = R_i \\pm \\Delta R/2$。\n\n**完整格式：** 结合径向和轴向部分，我们得到 $(\\Delta^*\\psi)_{i,j}$ 的完整 5 点格式：\n$$ (\\Delta^*\\psi)_{i,j} \\approx \\frac{R_i}{(\\Delta R)^2} \\left[ \\frac{\\psi_{i-1,j}}{R_i-\\frac{\\Delta R}{2}} - \\left(\\frac{1}{R_i+\\frac{\\Delta R}{2}} + \\frac{1}{R_i-\\frac{\\Delta R}{2}}\\right)\\psi_{i,j} + \\frac{\\psi_{i+1,j}}{R_i+\\frac{\\Delta R}{2}} \\right] + \\frac{\\psi_{i,j-1} - 2\\psi_{i,j} + \\psi_{i,j+1}}{(\\Delta Z)^2} $$\n该格式在 $\\Delta R$ 和 $\\Delta Z$ 上都是二阶精度的。\n\n### 验证与实现\n\n为了验证二阶精度，我们将此离散算子应用于已知的解析函数 $\\psi(R,Z)$，并将其结果与 $\\Delta^*\\psi$ 的精确解析计算值进行比较。在所有内部网格点上计算最大范数误差 $E_{\\infty}$：\n$$ E_{\\infty} = \\max_{1\\le i \\le N_R-2, 1\\le j \\le N_Z-2} \\left| (\\Delta^*\\psi)_{i,j}^{\\text{numerical}} - (\\Delta^*\\psi)(R_i,Z_j)^{\\text{analytic}} \\right| $$\n所提供的测试用例可以检验径向算子的零空间性质并评估收敛率，该收敛率应为二次的（$E_{\\infty} \\propto (\\Delta R)^2, (\\Delta Z)^2$）。对于网格分辨率加倍的成对测试用例，误差预计将减少约 4 倍。\n实现将遵循推导出的格式，将其应用于区域的内部，而完整的 $\\psi$ 值网格（包括边界）则由给定的解析函数计算得出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef apply_operator(psi, R, Z):\n    \"\"\"\n    Applies the discretized Grad-Shafranov operator Delta* to a function psi.\n\n    Args:\n        psi (np.ndarray): 2D array of psi values on the (R, Z) grid.\n        R (np.ndarray): 1D array of R-coordinates.\n        Z (np.ndarray): 1D array of Z-coordinates.\n\n    Returns:\n        np.ndarray: 2D array of the operator applied to psi.\n    \"\"\"\n    N_R, N_Z = psi.shape\n    if N_R  3 or N_Z  3:\n        return np.zeros_like(psi)\n\n    delta_R = R[1] - R[0]\n    delta_Z = Z[1] - Z[0]\n    \n    L_psi = np.zeros_like(psi)\n\n    # Vectorized computation for interior points\n    # psi slices for stencil\n    psi_mid = psi[1:-1, 1:-1]\n    psi_im1 = psi[:-2, 1:-1]\n    psi_ip1 = psi[2:, 1:-1]\n    psi_jm1 = psi[1:-1, :-2]\n    psi_jp1 = psi[1:-1, 2:]\n\n    # R-coordinates for interior points and faces\n    R_int = R[1:-1]\n    R_face_m = R_int - delta_R / 2.0\n    R_face_p = R_int + delta_R / 2.0\n\n    # Reshape R arrays for broadcasting\n    R_int_col = R_int[:, np.newaxis]\n    R_face_m_col = R_face_m[:, np.newaxis]\n    R_face_p_col = R_face_p[:, np.newaxis]\n\n    # Radial part of the operator\n    # Note: A check for R_face_m_col == 0 is needed if R_min=0 and N_R is even,\n    # but the test cases avoid this.\n    term_im1 = psi_im1 / R_face_m_col\n    term_ip1 = psi_ip1 / R_face_p_col\n    term_i = -(1.0/R_face_p_col + 1.0/R_face_m_col) * psi_mid\n    L_R_psi = (R_int_col / (delta_R**2)) * (term_im1 + term_i + term_ip1)\n\n    # Axial part of the operator\n    L_Z_psi = (psi_jp1 - 2.0 * psi_mid + psi_jm1) / (delta_Z**2)\n\n    # Combine parts and store in the interior of the result matrix\n    L_psi[1:-1, 1:-1] = L_R_psi + L_Z_psi\n\n    return L_psi\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute errors.\n    \"\"\"\n    test_cases = [\n        {\n            \"domain\": (0.8, 1.2, -0.5, 0.5),\n            \"resolution\": (33, 33),\n            \"psi_func\": lambda R, Z: 0.5 * R**2,\n            \"L_psi_func\": lambda R, Z: np.zeros_like(R),\n        },\n        {\n            \"domain\": (1.0, 2.0, -1.0, 1.0),\n            \"resolution\": (33, 33),\n            \"psi_func\": lambda R, Z: R**4 + Z**4 + R**2 * Z,\n            \"L_psi_func\": lambda R, Z: 8.0 * R**2 + 12.0 * Z**2,\n        },\n        {\n            \"domain\": (1.0, 2.0, -1.0, 1.0),\n            \"resolution\": (65, 65),\n            \"psi_func\": lambda R, Z: R**4 + Z**4 + R**2 * Z,\n            \"L_psi_func\": lambda R, Z: 8.0 * R**2 + 12.0 * Z**2,\n        },\n        {\n            \"domain\": (0.2, 0.9, -0.3, 0.3),\n            \"resolution\": (49, 49),\n            \"psi_func\": lambda R, Z: np.sin(R) * np.cosh(Z),\n            \"L_psi_func\": lambda R, Z: -np.cos(R) * np.cosh(Z) / R,\n        },\n        {\n            \"domain\": (0.2, 0.9, -0.3, 0.3),\n            \"resolution\": (97, 97),\n            \"psi_func\": lambda R, Z: np.sin(R) * np.cosh(Z),\n            \"L_psi_func\": lambda R, Z: -np.cos(R) * np.cosh(Z) / R,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        R_min, R_max, Z_min, Z_max = case[\"domain\"]\n        N_R, N_Z = case[\"resolution\"]\n        psi_func = case[\"psi_func\"]\n        L_psi_func = case[\"L_psi_func\"]\n\n        # 1. Construct the grid\n        R_coords = np.linspace(R_min, R_max, N_R)\n        Z_coords = np.linspace(Z_min, Z_max, N_Z)\n        R_grid, Z_grid = np.meshgrid(R_coords, Z_coords, indexing='ij')\n\n        # 2. Evaluate analytic psi on the grid\n        psi_analytic = psi_func(R_grid, Z_grid)\n\n        # 3. Apply the discrete operator\n        L_psi_numerical = apply_operator(psi_analytic, R_coords, Z_coords)\n\n        # 4. Evaluate the exact analytic operator\n        L_psi_analytic = L_psi_func(R_grid, Z_grid)\n\n        # 5. Compute the maximum-norm error on the interior\n        error_matrix = L_psi_numerical - L_psi_analytic\n        interior_error = error_matrix[1:-1, 1:-1]\n        E_inf = np.max(np.abs(interior_error))\n        \n        results.append(E_inf)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "有了离散算子之后，下一个挑战是求解完整且通常为非线性的Grad-Shafranov方程。本实践将指导您实现牛顿法，这是一种求解此类方程组的强大迭代技术。为了确保求解器在初始猜测远离真实解时仍能收敛，您将引入线搜索全局化策略，这是稳健的科学计算代码中一个标准且至关重要的特性 。",
            "id": "3986269",
            "problem": "考虑轴对称磁流体动力学平衡，其中静力平衡由压力梯度和洛伦兹力相等给出，写为 $\\nabla p = \\mathbf{j} \\times \\mathbf{B}$。在柱坐标 $(R,\\phi,Z)$ 的轴对称条件下，极向磁通函数 $\\Psi(R,Z)$ 满足带有固定边界条件的 Grad–Shafranov 方程。Grad–Shafranov 算子定义为\n$$\n\\Delta^\\star \\Psi \\equiv R \\frac{\\partial}{\\partial R} \\left( \\frac{1}{R} \\frac{\\partial \\Psi}{\\partial R} \\right) + \\frac{\\partial^2 \\Psi}{\\partial Z^2}.\n$$\n平衡方程的形式为\n$$\n\\Delta^\\star \\Psi = - \\mu_0 R^2 \\frac{dp}{d\\Psi} - F(\\Psi) \\frac{dF}{d\\Psi},\n$$\n其中 $p(\\Psi)$ 是压力分布，$F(\\Psi)$ 是环向场函数。假设进行无量纲归一化，使得自由空间磁导率 $\\mu_0$ 设置为 $\\mu_0 = 1$，且所有量均为无量纲。\n\n您必须设计并实现一个牛顿法的全局化策略，该策略使用带充分下降条件的线搜索（Armijo 回溯），以在具有狄利克雷边界条件的矩形计算域上求解非线性固定边界 Grad–Shafranov 方程。该域定义为 $R \\in [R_{\\min}, R_{\\max}]$ 和 $Z \\in [Z_{\\min}, Z_{\\max}]$，并在均匀网格上进行离散化。在整个边界上规定了固定边界条件 $\\Psi_b(R,Z) = R^2$，这是 $\\Delta^\\star \\Psi = 0$ 的一个真空解。\n\n在均匀网格上，使用二阶有限差分方法对 $\\Delta^\\star$ 进行离散化，在 $R$ 方向上采用变系数自伴形式。令 $R_i$ 和 $Z_k$ 表示网格节点，并令 $a(R) = 1/R$，其中点值为 $a_{i+1/2} = \\frac{1}{2}\\left( \\frac{1}{R_i} + \\frac{1}{R_{i+1}} \\right)$ 和 $a_{i-1/2} = \\frac{1}{2}\\left( \\frac{1}{R_i} + \\frac{1}{R_{i-1}} \\right)$。对于任何内部节点 $(i,k)$，写出离散算子\n$$\n(\\Delta^\\star \\Psi)_{i,k} \\approx R_i \\frac{1}{\\Delta R^2} \\left[ a_{i+1/2} \\left( \\Psi_{i+1,k} - \\Psi_{i,k} \\right) - a_{i-1/2} \\left( \\Psi_{i,k} - \\Psi_{i-1,k} \\right) \\right] + \\frac{\\Psi_{i,k+1} - 2\\Psi_{i,k} + \\Psi_{i,k-1}}{\\Delta Z^2},\n$$\n并通过将相邻边界的贡献移到右侧来并入固定边界值 $\\Psi_b$。将未知量表示为内部节点的向量。\n\n对源项使用以下参数形式：\n$$\np(\\Psi) = \\alpha \\Psi + \\beta \\Psi^2, \\quad \\frac{dp}{d\\Psi} = \\alpha + 2\\beta \\Psi, \\quad F(\\Psi) = \\gamma + \\delta \\Psi, \\quad \\frac{dF}{d\\Psi} = \\delta.\n$$\n为内部未知量 $\\mathbf{\\Psi}$ 定义残差向量：\n$$\n\\mathbf{r}(\\mathbf{\\Psi}) = \\mathbf{L}\\mathbf{\\Psi} + \\mathbf{g} + \\mathbf{s}(\\mathbf{\\Psi}),\n$$\n其中 $\\mathbf{L}$ 是表示作用于内部节点的 $\\Delta^\\star$ 的离散矩阵，$\\mathbf{g}$ 表示来自 $\\Psi_b$ 的边界贡献，非线性源项为\n$$\n\\mathbf{s}(\\mathbf{\\Psi}) = R^2 \\left( \\alpha + 2\\beta \\mathbf{\\Psi} \\right) + \\delta \\left( \\gamma + \\delta \\mathbf{\\Psi} \\right).\n$$\n此处 $R^2$ 表示在内部节点处元素为 $R_i^2$ 的对角向量。\n\n应用牛顿法，在每次迭代中求解线性系统\n$$\n\\mathbf{J}(\\mathbf{\\Psi}) \\mathbf{s} = -\\mathbf{r}(\\mathbf{\\Psi}),\n$$\n其中雅可比矩阵为\n$$\n\\mathbf{J}(\\mathbf{\\Psi}) = \\mathbf{L} + \\operatorname{diag}\\left( R^2 \\cdot \\frac{d^2 p}{d\\Psi^2} + \\left( \\frac{dF}{d\\Psi} \\right)^2 + F(\\Psi) \\frac{d^2F}{d\\Psi^2} \\right).\n$$\n对于所选的分布，$\\frac{d^2 p}{d\\Psi^2} = 2\\beta$ 且 $\\frac{d^2F}{d\\Psi^2} = 0$，这意味着\n$$\n\\mathbf{J} = \\mathbf{L} + \\operatorname{diag}\\left( 2\\beta R^2 + \\delta^2 \\right).\n$$\n\n使用基于评价函数 $\\Phi(\\mathbf{\\Psi}) = \\frac{1}{2} \\lVert \\mathbf{r}(\\mathbf{\\Psi}) \\rVert_2^2$ 的线搜索来全局化牛顿法，并采用 Armijo 回溯：给定牛顿步长 $\\mathbf{s}$，通过回溯 $\\alpha \\leftarrow \\tau \\alpha$（其中 $\\tau \\in (0,1)$）来选择步长 $\\alpha \\in (0,1]$，直到满足\n$$\n\\Phi(\\mathbf{\\Psi} + \\alpha \\mathbf{s}) \\le \\Phi(\\mathbf{\\Psi}) - c \\alpha \\lVert \\mathbf{r}(\\mathbf{\\Psi}) \\rVert_2^2,\n$$\n其中 $c \\in (0,1)$ 是用户指定的参数，确保充分下降。回溯时使用 $\\tau = 1/2$。当 $\\lVert \\mathbf{r}(\\mathbf{\\Psi}) \\rVert_2 \\le \\varepsilon$ 或达到最大牛顿迭代次数时终止。\n\n在域 $R \\in [1.0,1.4]$，$Z \\in [-0.2,0.2]$ 上，使用具有 $N_R = 22$ 和 $N_Z = 22$ 个节点的均匀网格实现求解器。边界条件为在所有边界节点上 $\\Psi_b(R,Z) = R^2$。对内部节点使用两种可能的初始猜测：真空猜测 $\\Psi^{(0)} = R^2$ 或零猜测 $\\Psi^{(0)} = 0$。\n\n您的程序必须实现上述离散化和全局化策略，并运行以下测试套件。对于每个测试用例，输出一个列表，其中包含最终残差范数 $\\lVert \\mathbf{r} \\rVert_2$（浮点数）、执行的牛顿迭代次数（整数）、所有迭代中的总回溯缩减次数（整数）以及一个成功标志（整数，如果 $\\lVert \\mathbf{r} \\rVert_2 \\le \\varepsilon$ 则为 $1$，否则为 $0$）。使用 $\\varepsilon = 10^{-6}$ 和最大 $50$ 次牛顿迭代。\n\n测试套件参数集为 $(\\alpha,\\beta,\\gamma,\\delta,c,\\text{init})$：\n1. $(0.2, 0.05, 1.0, 0.1, 10^{-4}, \\text{vacuum})$ 作为一般情况。\n2. $(0.0, 0.0, 1.0, 0.0, 10^{-4}, \\text{vacuum})$ 作为真空边界和真空内部情况。\n3. $(0.6, 0.3, 0.8, 0.3, 10^{-3}, \\text{vacuum})$ 作为强非线性情况。\n4. $(0.6, 0.3, 0.8, 0.3, 10^{-4}, \\text{zero})$ 作为初始猜测不佳的情况。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个结果本身是一个格式为 $[\\,\\lVert \\mathbf{r} \\rVert_2, \\text{迭代次数}, \\text{回溯次数}, \\text{成功标志}\\,]$ 的列表。例如：“[[r1,it1,bt1,s1],[r2,it2,bt2,s2],[r3,it3,bt3,s3],[r4,it4,bt4,s4]]”。所有量都是无量纲的，如果存在角度，则必须以弧度为单位；本问题中没有出现角度。",
            "solution": "用户提供了一个需要为 Grad–Shafranov 方程开发数值求解器的问题。按照规定进行的验证过程确认该问题具有科学依据、是适定的且客观的。它为计算等离子体物理中的固定边界平衡问题提供了一套完整且一致的规范。所有必需的方程、离散化方案、边界条件、数值参数和测试用例都得到了明确定义。\n\n一个重要的分析观察是，为压力 $p(\\Psi) = \\alpha \\Psi + \\beta \\Psi^2$ 和环向场函数 $F(\\Psi) = \\gamma + \\delta \\Psi$ 选择的特定参数形式，导致 Grad–Shafranov 方程在通量函数 $\\Psi$ 上是线性的。其控制偏微分方程形式为\n$$\n\\Delta^\\star \\Psi + \\left( 2\\beta R^2 + \\delta^2 \\right) \\Psi = - \\alpha R^2 - \\gamma\\delta,\n$$\n这是一个线性、非齐次、椭圆型偏微分方程。因此，当离散化时，这将产生一个形如 $\\mathbf{J}\\mathbf{\\Psi} = \\mathbf{b}$ 的线性代数方程组。\n\n该问题指示实现牛顿法——一种用于求解*非线性*系统的技术，并使用 Armijo 线搜索进行全局化。当应用于线性系统 $\\mathbf{A}\\mathbf{x} - \\mathbf{b} = 0$ 时，只要初始猜测不是解本身，牛顿迭代就会在单步内以步长 $\\alpha=1$ 收敛。残差 $\\mathbf{r}(\\mathbf{x}) = \\mathbf{A}\\mathbf{x} - \\mathbf{b}$ 的雅可比矩阵就是常数矩阵 $\\mathbf{A}$，而牛顿更新 $\\mathbf{x}_{k+1} = \\mathbf{x}_k - \\mathbf{A}^{-1}(\\mathbf{A}\\mathbf{x}_k - \\mathbf{b})$ 简化为 $\\mathbf{x}_{k+1} = \\mathbf{A}^{-1}\\mathbf{b}$，即精确解。线搜索全局化策略虽然是实现所要求的，但对于收敛并非严格必要，并且预计将在第一次迭代中接受完整步长 $\\alpha=1$，从而以零次回溯缩减实现收敛。\n\n虽然这种线性简化了问题的动力学特性，但并未使问题无效。该任务仍然是为通用 Grad–Shafranov 求解器构建必要的数值机制（离散化矩阵、残差和雅可比矩阵的构建，以及 Newton-Armijo 循环结构）的一个有效且定义明确的练习，此处在一个特定的线性案例上进行测试。解决方案将忠实地实现所要求的算法，并报告其在给定测试用例上的行为。\n\n解题过程如下：\n1.  **离散化**：计算域 $R \\in [R_{\\min}, R_{\\max}]$，$Z \\in [Z_{\\min}, Z_{\\max}]$ 在一个 $N_R \\times N_Z$ 个节点的均匀网格上进行离散化。极向通量 $\\Psi$ 由其在网格节点 $(R_i, Z_k)$ 上的值 $\\Psi_{i,k}$ 表示。问题未知量是 $(N_R-2) \\times (N_Z-2)$ 个内部节点上的 $\\Psi$ 值，这些值被展平为长度为 $N = (N_R-2)(N_Z-2)$ 的单个向量 $\\mathbf{\\Psi}$。\n\n2.  **矩阵构建**：Grad–Shafranov 方程的有限差分近似被转换为矩阵系统。\n    -   作用于内部节点的离散算子 $\\Delta^\\star$ 由一个大小为 $N \\times N$ 的稀疏矩阵 $\\mathbf{L}$ 表示。\n    -   狄利克雷边界条件 $\\Psi = \\Psi_b$ 贡献一个长度为 $N$ 的常数向量 $\\mathbf{g}$。\n    -   加入非线性源项，对于给定的分布，该项为 $\\mathbf{s}(\\mathbf{\\Psi}) = R^2 (\\alpha + 2\\beta \\mathbf{\\Psi}) + \\delta(\\gamma + \\delta \\mathbf{\\Psi})$。\n    待求解的方程组为 $\\mathbf{r}(\\mathbf{\\Psi}) = 0$，其中残差向量定义为 $\\mathbf{r}(\\mathbf{\\Psi}) = \\mathbf{L}\\mathbf{\\Psi} + \\mathbf{g} + \\mathbf{s}(\\mathbf{\\Psi})$。\n\n3.  **Newton-Armijo 求解器**：方程组 $\\mathbf{r}(\\mathbf{\\Psi}) = 0$ 通过迭代求解。\n    -   **初始化**：根据指定，从真空解或零值构成初始猜测 $\\mathbf{\\Psi}^{(0)}$。\n    -   **迭代**：在第 $k$ 步，我们求解线性系统以获得牛顿更新量 $\\mathbf{s}^{(k)}$：\n      $$\n      \\mathbf{J}(\\mathbf{\\Psi}^{(k)}) \\mathbf{s}^{(k)} = -\\mathbf{r}(\\mathbf{\\Psi}^{(k)})\n      $$\n      雅可比矩阵 $\\mathbf{J}$ 是残差 $\\mathbf{r}$ 关于 $\\mathbf{\\Psi}$ 的导数。对于给定的分布，它是一个常数矩阵：\n      $$\n      \\mathbf{J} = \\mathbf{L} + \\text{diag}(2\\beta R^2 + \\delta^2)\n      $$\n    -   **线搜索**：解通过 $\\mathbf{\\Psi}^{(k+1)} = \\mathbf{\\Psi}^{(k)} + \\alpha_k \\mathbf{s}^{(k)}$ 进行更新，其中步长 $\\alpha_k \\in (0, 1]$ 由 Armijo 回溯条件确定。我们从 $\\alpha_k=1$ 开始，并将其乘以一个因子 $\\tau = 1/2$，直到满足评价函数 $\\Phi(\\mathbf{\\Psi}) = \\frac{1}{2} \\lVert \\mathbf{r}(\\mathbf{\\Psi}) \\rVert_2^2$ 的充分下降条件：\n      $$\n      \\Phi(\\mathbf{\\Psi}^{(k)} + \\alpha_k \\mathbf{s}^{(k)}) \\le \\Phi(\\mathbf{\\Psi}^{(k)}) - c \\alpha_k \\lVert \\mathbf{r}(\\mathbf{\\Psi}^{(k)}) \\rVert_2^2\n      $$\n    -   **终止**：当残差的欧几里得范数低于容差 $\\lVert \\mathbf{r}(\\mathbf{\\Psi}^{(k)}) \\rVert_2 \\le \\varepsilon$ 或达到最大迭代次数时，过程终止。\n\n该实现将构建矩阵 $\\mathbf{L}$ 和 $\\mathbf{J}$，以及向量 $\\mathbf{g}$ 和 $\\mathbf{s}$，然后为每个指定的测试用例执行 Newton-Armijo 循环，报告最终残差范数、迭代次数、总回溯缩减次数和成功标志。",
            "answer": "```python\nimport numpy as np\n\ndef build_operator(R_min, R_max, Z_min, Z_max, N_R, N_Z):\n    \"\"\"\n    Constructs the discrete Grad-Shafranov operator matrix L,\n    the boundary contribution vector g, and related grid information.\n    \"\"\"\n    R_nodes = np.linspace(R_min, R_max, N_R)\n    Z_nodes = np.linspace(Z_min, Z_max, N_Z)\n    delta_R = (R_max - R_min) / (N_R - 1)\n    delta_Z = (Z_max - Z_min) / (N_Z - 1)\n    \n    N_int_R = N_R - 2\n    N_int_Z = N_Z - 2\n    N_int = N_int_R * N_int_Z\n\n    L = np.zeros((N_int, N_int))\n    g = np.zeros(N_int)\n    \n    # Flattened R^2 vector for interior points (row-major)\n    R_int_grid = R_nodes[1:-1, np.newaxis] * np.ones((1, N_int_Z))\n    R2_vec = (R_int_grid.flatten(order='C'))**2\n    \n    for i in range(N_int_R):\n        for k in range(N_int_Z):\n            m = i * N_int_Z + k\n            \n            i_grid, k_grid = i + 1, k + 1\n            \n            R_i = R_nodes[i_grid]\n            \n            # R-derivative coefficients\n            a_ip_half = 0.5 * (1.0/R_nodes[i_grid] + 1.0/R_nodes[i_grid+1])\n            a_im_half = 0.5 * (1.0/R_nodes[i_grid] + 1.0/R_nodes[i_grid-1])\n            \n            c_i = -R_i * (a_ip_half + a_im_half) / (delta_R**2)\n            c_ip1 = R_i * a_ip_half / (delta_R**2)\n            c_im1 = R_i * a_im_half / (delta_R**2)\n            \n            # Z-derivative coefficients\n            c_k = -2.0 / (delta_Z**2)\n            c_kp1 = 1.0 / (delta_Z**2)\n            c_km1 = 1.0 / (delta_Z**2)\n            \n            # Diagonal element\n            L[m, m] = c_i + c_k\n\n            # Off-diagonal elements for interior neighbors\n            if i > 0:\n                L[m, m - N_int_Z] = c_im1  # Psi_{i-1, k}\n            if i  N_int_R - 1:\n                L[m, m + N_int_Z] = c_ip1  # Psi_{i+1, k}\n            if k > 0:\n                L[m, m - 1] = c_km1      # Psi_{i, k-1}\n            if k  N_int_Z - 1:\n                L[m, m + 1] = c_kp1      # Psi_{i, k+1}\n\n            # Boundary contributions moved to RHS vector g\n            # Boundary condition is Psi_b(R,Z) = R^2\n            if i == 0:\n                g[m] -= c_im1 * (R_nodes[0]**2)\n            if i == N_int_R - 1:\n                g[m] -= c_ip1 * (R_nodes[-1]**2)\n            if k == 0:\n                # Psi_b = R_i^2 at Z_min boundary\n                g[m] -= c_km1 * (R_nodes[i_grid]**2)\n            if k == N_int_Z - 1:\n                # Psi_b = R_i^2 at Z_max boundary\n                g[m] -= c_kp1 * (R_nodes[i_grid]**2)\n    \n    return L, g, R2_vec, R_nodes, Z_nodes\n\ndef run_solver(params, L, g, R2_vec, R_nodes, Z_nodes):\n    \"\"\"\n    Executes the Newton-Armijo solver for a given set of parameters.\n    \"\"\"\n    alpha_p, beta_p, gamma_p, delta_p, c, init_type = params\n    \n    N_R = len(R_nodes)\n    N_Z = len(Z_nodes)\n    N_int_R = N_R - 2\n    N_int_Z = N_Z - 2\n    max_iter = 50\n    epsilon = 1e-6\n    tau = 0.5\n\n    # Initialize solution vector Psi\n    R_grid_full, _ = np.meshgrid(R_nodes, Z_nodes, indexing='ij')\n    \n    # Set initial guess for interior nodes\n    if init_type == 'vacuum':\n        Psi_initial_interior = R_grid_full[1:-1, 1:-1]**2\n    else: # zero guess\n        Psi_initial_interior = np.zeros((N_int_R, N_int_Z))\n\n    Psi_vec = Psi_initial_interior.flatten(order='C')\n\n    # Since the Jacobian is constant for this problem, compute it once\n    J = L + np.diag(2 * beta_p * R2_vec + delta_p**2)\n\n    iter_count = 0\n    total_backtracks = 0\n    final_r_norm = -1.0 # Default value\n\n    while iter_count  max_iter:\n        # Calculate residual vector r\n        s_vec = R2_vec * (alpha_p + 2 * beta_p * Psi_vec) + delta_p * (gamma_p + delta_p * Psi_vec)\n        r_vec = L @ Psi_vec + g + s_vec\n        \n        r_norm = np.linalg.norm(r_vec)\n        \n        if r_norm = epsilon:\n            final_r_norm = r_norm\n            break\n        \n        # Calculate Newton step s\n        step_s = np.linalg.solve(J, -r_vec)\n        \n        # Armijo backtracking line search\n        step_alpha = 1.0\n        phi_current = 0.5 * r_norm**2\n        armijo_rhs_term = c * r_norm**2\n        \n        local_backtracks = 0\n        while True:\n            Psi_vec_new = Psi_vec + step_alpha * step_s\n            \n            s_new = R2_vec * (alpha_p + 2 * beta_p * Psi_vec_new) + delta_p * (gamma_p + delta_p * Psi_vec_new)\n            r_new = L @ Psi_vec_new + g + s_new\n            phi_new = 0.5 * np.linalg.norm(r_new)**2\n            \n            if phi_new = phi_current - step_alpha * armijo_rhs_term:\n                Psi_vec = Psi_vec_new\n                total_backtracks += local_backtracks\n                break\n            \n            step_alpha *= tau\n            local_backtracks += 1\n            if step_alpha  1e-12: # Safety break for line search\n                # This indicates a failure in finding a step length\n                # and loop will terminate due to max_iter\n                break\n                \n        iter_count += 1\n    \n    # Final residual after loop\n    s_final = R2_vec * (alpha_p + 2 * beta_p * Psi_vec) + delta_p * (gamma_p + delta_p * Psi_vec)\n    r_final = L @ Psi_vec + g + s_final\n    final_r_norm = np.linalg.norm(r_final)\n\n    success = 1 if final_r_norm = epsilon else 0\n    \n    return [final_r_norm, iter_count, total_backtracks, success]\n\n\ndef solve():\n    \"\"\"\n    Main function to set up the problem and run the test suite.\n    \"\"\"\n    R_min, R_max = 1.0, 1.4\n    Z_min, Z_max = -0.2, 0.2\n    N_R, N_Z = 22, 22\n\n    test_cases = [\n        # (alpha, beta, gamma, delta, c, init)\n        (0.2, 0.05, 1.0, 0.1, 1e-4, 'vacuum'),\n        (0.0, 0.0, 1.0, 0.0, 1e-4, 'vacuum'),\n        (0.6, 0.3, 0.8, 0.3, 1e-3, 'vacuum'),\n        (0.6, 0.3, 0.8, 0.3, 1e-4, 'zero'),\n    ]\n\n    # Pre-compute grid-dependent quantities\n    L, g, R2_vec, R_nodes, Z_nodes = build_operator(R_min, R_max, Z_min, Z_max, N_R, N_Z)\n\n    results = []\n    for case_params in test_cases:\n        result = run_solver(case_params, L, g, R2_vec, R_nodes, Z_nodes)\n        results.append(result)\n\n    # Format output as specified\n    output_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]},{r[2]},{r[3]}]\" for r in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "求解极向磁通函数 $\\psi(R,Z)$ 是GS求解器的主要目标，但其真正价值在于我们能从中获得的物理洞察。本实践演示了如何对数值平衡进行后处理，以计算安全因子 $q(\\psi)$——一个对等离子体稳定性至关重要的参数。您将实现一个算法来追踪磁通面并执行必要的线积分，同时处理在磁分界面附近出现的重要的数值挑战 。",
            "id": "3986339",
            "problem": "给定一个固定边界的轴对称磁流体动力学平衡，由极向磁通函数 $ \\psi(R,Z) $ 和一个指定的环向场函数 $ F(\\psi) $ 描述，其中 $ F(\\psi) = R B_{\\varphi} $，$ B_{\\varphi} $ 是环向磁场。仅使用 Grad–Shafranov 平衡的基本定律和核心定义，推导一个计算程序，用于评估最后闭合磁面内部的闭合磁面 $ \\psi = \\text{const} $ 上的安全因子 $ q(\\psi) $。安全因子的定义是环向磁通量与极向磁通量之比，在轴对称情况下，可以表示为极向截面上的线积分。从柱坐标 $ (R,\\varphi,Z) $ 中的磁场定义和轴对称平衡出发，推导一个计算以下公式的算法：\n$$\nq(\\psi) = \\frac{1}{2\\pi} \\oint_{\\psi=\\text{const}} \\frac{F(\\psi)}{R^2} \\frac{dl_p}{B_p},\n$$\n其中 $ dl_p $ 是极向弧长元，$ B_p = \\lvert \\nabla \\psi \\rvert / R $ 是极向磁场的大小。您必须构建该算法，使得积分可以通过沿 $ \\psi = \\text{const} $ 的离散点进行数值近似，这些离散点是通过从磁轴出发使用基于射线的求根法追踪等值线得到的。您的程序必须明确识别并解释在磁分界面（一个 $ X $ 点）附近（此处 $ B_p \\to 0 $）出现的数值计算挑战，并且必须包含一个稳健的策略来检测和正则化这些挑战。\n\n您的任务是实现一个完整、可运行的程序，该程序：\n1. 将推导过程编码为一个数值算法，该算法使用基于射线的求根法，从给定的磁轴位置 $ (R_0, Z_0) $ 构建磁面等值线 $ \\psi = \\psi_t $。\n2. 使用 $ N_{\\theta} $ 个在 $ \\theta \\in [0,2\\pi) $ 上均匀分布的角度，通过对上述线积分的离散近似来计算 $ q(\\psi_t) $。\n3. 为每次计算报告一个诊断信息，特别是沿等值线的最小极向场强 $ \\min B_p $，作为磁分界面邻近度和数值刚性的量化指标。\n\n本问题中所有量均为无量纲。角度必须以弧度为单位。您的数值算法必须在一小组涵盖各种固定边界平衡的测试套件中表现出稳健性。在每个测试中，$ \\psi(R,Z) $ 和 $ F(\\psi) $ 均通过解析方式指定，以确保闭合磁面和已知的磁轴，并规定了目标等值 $ \\psi_t $。使用以下测试套件，每一项都完全确定了 $ \\psi(R,Z) $、$ \\nabla \\psi(R,Z) $、$ F(\\psi) $、磁轴以及目标 $ \\psi_t $：\n\n- 测试用例1（圆形磁面，常数 $ F $）：$ \\psi(R,Z) = A \\big[(R-R_0)^2 + Z^2\\big] $，其中 $ A = 0.8 $，$ R_0 = 3.0 $，磁轴位于 $ (R_0,0) $。设 $ F(\\psi) = F_0 $，其中 $ F_0 = 6.0 $。目标等值为 $ \\psi_t = A r^2 $，其中 $ r = 0.5 $。\n- 测试用例2（较大圆形半径，常数 $ F $）：$ \\psi(R,Z) = A \\big[(R-R_0)^2 + Z^2\\big] $，其中 $ A = 0.8 $，$ R_0 = 3.0 $，磁轴位于 $ (R_0,0) $。设 $ F(\\psi) = F_0 $，其中 $ F_0 = 6.0 $。目标等值为 $ \\psi_t = A r^2 $，其中 $ r = 2.5 $。\n- 测试用例3（椭圆拉伸，线性 $ F(\\psi) $）：$ \\psi(R,Z) = A \\big[(R-R_0)^2 + (Z/\\kappa)^2\\big] $，其中 $ A = 0.6 $，$ \\kappa = 1.7 $，$ R_0 = 3.0 $，磁轴位于 $ (R_0,0) $。设 $ F(\\psi) = F_0 + \\alpha \\psi $，其中 $ F_0 = 5.0 $，$ \\alpha = 0.2 $。目标等值为 $ \\psi_t = A r^2 $，其中 $ r = 1.2 $。\n- 测试用例4（由局部凸起引起的近磁分界面畸变，常数 $ F $）：$ \\psi(R,Z) = A \\big[(R-R_0)^2 + Z^2\\big] - \\varepsilon \\exp\\big(-((R-R_x)^2 + (Z-Z_x)^2)/\\sigma^2\\big) $，其中 $ A = 0.5 $，$ R_0 = 3.0 $，$ R_x = R_0 + 1.7 $，$ Z_x = 0.0 $，$ \\sigma = 0.2 $，$ \\varepsilon = 0.35 $，磁轴位于 $ (R_0,0) $。设 $ F(\\psi) = F_0 $，其中 $ F_0 = 6.0 $。目标等值为 $ \\psi_t = A r^2 - 0.5 \\varepsilon $，其中 $ r = 1.7 $。\n\n您的程序必须：\n- 使用 $ N_{\\theta} = 1024 $ 个角度进行等值线构建和积分。\n- 使用基于射线的搜索距离上限 $ s_{\\max} = 3.5 $，并且每个角度至少使用 $ 200 $ 个径向样本来包围根，然后对每个根使用二分法直到达到机器精度容差。\n- 通过对连续等值线点之间的直线段求和来近似线积分，在被积函数中使用中点值来评估 $ B_p $ 和 $ R $。\n- 通过报告沿等值线的 $ \\min B_p $ 来检测近磁分界面刚性。为确保数值稳定性，在积分过程中通过将被分母中任何低于小阈值 $ \\epsilon_{B_p} $ 的 $ B_p $ 替换为 $ \\epsilon_{B_p} $ 来正则化被积函数，同时仍然报告真实的 $ \\min B_p $ 以量化刚性。使用 $ \\epsilon_{B_p} = 10^{-6} $。\n\n最终输出格式：\n您的程序应生成单行输出，包含一个结果列表，每个测试用例一个结果，其中每个结果本身是包含两个浮点数 $ [q(\\psi_t), \\min B_p] $ 的列表，对应于指定的 $ \\psi_t $。总输出必须是方括号内由逗号分隔的列表，各项按测试用例的顺序排列，例如 $ [[q_1,\\min B_{p,1}],[q_2,\\min B_{p,2}],[q_3,\\min B_{p,3}],[q_4,\\min B_{p,4}]] $。\n\n本问题中没有物理单位，因为所有量都是无量纲的。角度必须以弧度为单位。程序必须是自包含的，不需要任何输入。",
            "solution": "该问题是有效的。它提出了一个在计算等离子体物理学领域内适定的、有科学依据的任务，该任务是完整且可形式化的。所提供的测试用例是标准的、解析定义的平衡态，用于验证求解磁流体动力学（MHD）平衡性质的数值代码。任务是推导并实现一个计算程序，用以计算指定磁面上的安全因子 $q(\\psi)$。\n\n安全因子 $q$ 是磁约束聚变中的一个关键参数，表示磁力线每进行一次极向穿行时环向运行的圈数。对于轴对称平衡，它是极向磁通 $\\psi$ 的函数，可通过以下线积分计算：\n$$\nq(\\psi) = \\frac{1}{2\\pi} \\oint_{\\psi=\\text{const}} \\frac{F(\\psi)}{R^2} \\frac{dl_p}{B_p}\n$$\n在这里，积分是沿着极向平面 $(R,Z)$ 中恒定极向磁通 $\\psi(R,Z) = \\psi_t$ 的等值线进行的。$F(\\psi) = R B_{\\varphi}$ 是极向电流函数，$dl_p$ 是极向弧长元，$B_p$ 是极向磁场的大小。极向磁场 $\\vec{B}_p$ 与 $\\psi$ 的关系为 $\\vec{B}_p = \\frac{1}{R} (\\nabla\\psi \\times \\hat{\\varphi})$，其大小为 $B_p = \\frac{|\\nabla\\psi|}{R}$。\n\n计算过程包括两个主要步骤：首先，确定积分路径（磁面等值线），其次，沿此路径对积分进行数值评估。\n\n**1. 通过基于射线的求根法构建等值线**\n\n积分路径是水平集 $\\psi(R,Z) = \\psi_t$。为了获得该等值线的离散表示，我们采用一种从磁轴 $(R_0, Z_0)$ 出发的基于射线的求根方法。磁轴是磁通函数的极值点，在该点 $\\nabla\\psi=0$。\n\n该过程如下：\n- 定义一组 $N_{\\theta} = 1024$ 个离散角度 $\\theta_j = \\frac{2\\pi j}{N_{\\theta}}$，其中 $j \\in \\{0, 1, \\dots, N_{\\theta}-1\\}$。\n- 对于每个角度 $\\theta_j$，从磁轴 $(R_0, Z_0)$ 发出一条射线。射线上距离为 $s$ 的点由 $(R(s), Z(s)) = (R_0 + s\\cos\\theta_j, Z_0 + s\\sin\\theta_j)$ 给出。\n- 目标是找到沿此射线的距离 $s^*$，使得磁通函数等于目标值 $\\psi_t$。这需要求解非线性标量方程 $g(s) = \\psi(R(s), Z(s)) - \\psi_t = 0$ 以得到 $s$。\n- 为了求解 $s^*$，我们首先包围根。由于 $\\psi$ 在 $s=0$（磁轴）处达到极值，$g(0) = \\psi_{axis} - \\psi_t$ 将是非零的（通常为负）。我们通过在一系列采样点上评估 $g(s)$，沿射线搜索至最大距离 $s_{max}$。第一个满足 $g(s_k) \\cdot g(s_{k+1})  0$ 的区间 $[s_k, s_{k+1}]$ 为根提供了一个包围。\n- 在根被包围后，使用像二分法这样的稳健数值方法来找到满足指定容差的 $s^*$。\n- 对所有 $N_\\theta$ 个角度重复此过程，会得到一组 $N_\\theta$ 个有序点 $\\{P_j = (R_j, Z_j)\\}_{j=0}^{N_\\theta-1}$，这些点离散化了磁面等值线。\n\n**2. 安全因子的数值积分**\n\n利用离散的等值线点 $\\{P_j\\}$，$q(\\psi_t)$ 的线积分被近似为连接连续点的 $N_\\theta$ 个直线段上的总和。根据规定，对每个线段使用中点法则来近似积分。\n\n近似公式为：\n$$\nq(\\psi_t) \\approx \\frac{1}{2\\pi} \\sum_{j=0}^{N_{\\theta}-1} \\left( \\frac{F(\\psi_t)}{R_{mid,j}^2 \\, B_{p,mid,j}} \\right) \\Delta l_{p,j}\n$$\n对于从点 $P_j=(R_j, Z_j)$ 到 $P_{j+1}=(R_{j+1}, Z_{j+1})$ 的每个线段（其中 $P_{N_\\theta} = P_0$）：\n- 线段长度为 $\\Delta l_{p,j} = \\sqrt{(R_{j+1}-R_j)^2 + (Z_{j+1}-Z_j)^2}$。\n- 中点为 $(R_{mid,j}, Z_{mid,j}) = \\left(\\frac{R_j+R_{j+1}}{2}, \\frac{Z_j+Z_{j+1}}{2}\\right)$。\n- 极向磁场大小 $B_{p,mid,j}$ 在此中点进行评估。这需要解析梯度 $\\nabla\\psi$：\n  $$B_{p,mid,j} = \\frac{\\left|\\nabla\\psi(R_{mid,j}, Z_{mid,j})\\right|}{R_{mid,j}}$$\n- 对于给定的等值线，环向场函数 $F(\\psi_t)$ 是恒定的。\n\n**3. 磁分界面附近的数值稳定性**\n\n当磁面靠近包含一个或多个X点的磁分界面时，会出现一个关键的数值挑战。在X点，极向磁场为零，即 $B_p=0$，因为在此处 $\\nabla\\psi=0$。当等值线 $\\psi = \\psi_t$ 接近磁分界面时，沿等值线的 $B_p$ 最小值 $\\min B_p$ 趋近于零。\n\n这种行为导致被积项 $\\frac{1}{B_p}$ 发散，从而导致严重的数值不稳定性和不准确的积分结果。为了解决这个问题，需要一种正则化策略：\n- 在分母中使用之前，每个中点计算出的 $B_p$ 值被限制在一个小的正阈值 $\\epsilon_{B_p} = 10^{-6}$ 上。计算中使用的值为 $B_{p,reg} = \\max(B_p, \\epsilon_{B_p})$。\n- 这可以防止除以零或除以一个极小的数，从而稳定数值积分。\n- 沿等值线遇到的 *未经正则化* 的 $B_p$ 最小值会被追踪并作为诊断信息报告。一个接近 $\\epsilon_{B_p}$（或低于它）的 $\\min B_p$ 值强烈表明磁面靠近一个X点，并且正则化已被激活。这个诊断信息量化了问题的“刚性”。测试用例4就是专门设计来展示这种行为的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import bisect\n\ndef solve():\n    \"\"\"\n    Main solver function to compute safety factor q for a series of test cases.\n    \"\"\"\n    \n    # Define numerical parameters\n    N_theta = 1024\n    s_max = 3.5\n    n_samples_brackening = 250  # >= 200 as required\n    eps_Bp = 1e-6\n\n    # Test Case 1: circular surfaces, constant F\n    A1, R01 = 0.8, 3.0\n    r1 = 0.5\n    psi1 = lambda R, Z: A1 * ((R - R01)**2 + Z**2)\n    grad_psi1 = lambda R, Z: np.array([2 * A1 * (R - R01), 2 * A1 * Z])\n    F1 = lambda psi: 6.0\n    psi_t1 = A1 * r1**2\n\n    # Test Case 2: larger circular radius, constant F\n    A2, R02 = 0.8, 3.0\n    r2 = 2.5\n    psi2 = lambda R, Z: A2 * ((R - R02)**2 + Z**2)\n    grad_psi2 = lambda R, Z: np.array([2 * A2 * (R - R02), 2 * A2 * Z])\n    F2 = lambda psi: 6.0\n    psi_t2 = A2 * r2**2\n\n    # Test Case 3: elliptical elongation, linear F\n    A3, kappa3, R03 = 0.6, 1.7, 3.0\n    F0_3, alpha3 = 5.0, 0.2\n    r3 = 1.2\n    psi3 = lambda R, Z: A3 * ((R - R03)**2 + (Z / kappa3)**2)\n    grad_psi3 = lambda R, Z: np.array([2 * A3 * (R - R03), 2 * A3 * Z / kappa3**2])\n    F3 = lambda psi: F0_3 + alpha3 * psi\n    psi_t3 = A3 * r3**2\n\n    # Test Case 4: near-separatrix distortion\n    A4, R04, Rx4, Zx4, sigma4, eps4 = 0.5, 3.0, 4.7, 0.0, 0.2, 0.35\n    F0_4 = 6.0\n    r4 = 1.7\n    exp_term4 = lambda R, Z: np.exp(-((R - Rx4)**2 + (Z - Zx4)**2) / sigma4**2)\n    psi4 = lambda R, Z: A4 * ((R - R04)**2 + Z**2) - eps4 * exp_term4(R, Z)\n    grad_psi4 = lambda R, Z: np.array([\n        2 * A4 * (R - R04) - eps4 * exp_term4(R, Z) * (-2 * (R - Rx4) / sigma4**2),\n        2 * A4 * Z           - eps4 * exp_term4(R, Z) * (-2 * (Z - Zx4) / sigma4**2)\n    ])\n    F4 = lambda psi: F0_4\n    psi_t4 = A4 * r4**2 - 0.5 * eps4\n    \n    test_cases = [\n        {'psi': psi1, 'grad_psi': grad_psi1, 'F': F1, 'psi_t': psi_t1, 'R0': R01, 'Z0': 0.0},\n        {'psi': psi2, 'grad_psi': grad_psi2, 'F': F2, 'psi_t': psi_t2, 'R0': R02, 'Z0': 0.0},\n        {'psi': psi3, 'grad_psi': grad_psi3, 'F': F3, 'psi_t': psi_t3, 'R0': R03, 'Z0': 0.0},\n        {'psi': psi4, 'grad_psi': grad_psi4, 'F': F4, 'psi_t': psi_t4, 'R0': R04, 'Z0': 0.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_q_and_min_bp(\n            case['psi'], case['grad_psi'], case['F'], case['psi_t'],\n            case['R0'], case['Z0'], N_theta, s_max, n_samples_brackening, eps_Bp\n        )\n        results.append(result)\n\n    # Format the final output string exactly as specified.\n    inner_results = [f\"[{r[0]},{r[1]}]\" for r in results]\n    final_output = f\"[{','.join(inner_results)}]\"\n    print(final_output)\n\ndef compute_q_and_min_bp(psi_func, grad_psi_func, F_func, psi_t, R0, Z0, N_theta, s_max, n_samples, eps_Bp):\n    \"\"\"\n    Computes the safety factor q and minimum poloidal field Bp on a flux surface.\n\n    Args:\n        psi_func: Function for psi(R, Z).\n        grad_psi_func: Function for the gradient of psi(R, Z).\n        F_func: Function for F(psi).\n        psi_t: Target psi level for the contour.\n        R0, Z0: Coordinates of the magnetic axis.\n        N_theta: Number of points on the contour.\n        s_max: Maximum search radius for root finding.\n        n_samples: Number of samples for bracketing the root.\n        eps_Bp: Regularization threshold for Bp.\n\n    Returns:\n        A list [q_value, min_Bp_value].\n    \"\"\"\n    # 1. Construct the contour\n    angles = np.linspace(0, 2 * np.pi, N_theta, endpoint=False)\n    contour_points = np.zeros((N_theta, 2))\n\n    for i, theta in enumerate(angles):\n        cos_theta = np.cos(theta)\n        sin_theta = np.sin(theta)\n\n        # Define the function whose root we want to find along the ray\n        g = lambda s: psi_func(R0 + s * cos_theta, Z0 + s * sin_theta) - psi_t\n\n        # Bracket the root\n        s_vals = np.linspace(0, s_max, n_samples + 1)\n        g_vals = np.array([g(s) for s in s_vals])\n        \n        root_bracket = None\n        for j in range(n_samples):\n            if g_vals[j] * g_vals[j+1]  0:\n                root_bracket = (s_vals[j], s_vals[j+1])\n                break\n        \n        if root_bracket is None:\n            raise RuntimeError(f\"Root not bracketed for theta={theta}. Increase s_max or sample density.\")\n        \n        # Find the root using bisection\n        s_root = bisect(g, root_bracket[0], root_bracket[1])\n        contour_points[i] = [R0 + s_root * cos_theta, Z0 + s_root * sin_theta]\n\n    # 2. Perform numerical integration\n    q_integral = 0.0\n    min_Bp = np.inf\n    F_val = F_func(psi_t)\n\n    for i in range(N_theta):\n        p1 = contour_points[i]\n        p2 = contour_points[(i + 1) % N_theta]  # Wrap around for the last segment\n        \n        R1, Z1 = p1\n        R2, Z2 = p2\n\n        # Midpoint of the segment\n        R_mid, Z_mid = (R1 + R2) / 2, (Z1 + Z2) / 2\n        \n        # Length of the segment\n        dl_p = np.sqrt((R2 - R1)**2 + (Z2 - Z1)**2)\n        \n        # Calculate poloidal field Bp at the midpoint\n        grad = grad_psi_func(R_mid, Z_mid)\n        norm_grad = np.sqrt(grad[0]**2 + grad[1]**2)\n        \n        if R_mid == 0: # Safety check, should not happen in these cases\n             Bp = np.inf\n        else:\n             Bp = norm_grad / R_mid\n\n        # Update the minimum Bp found so far\n        min_Bp = min(min_Bp, Bp)\n        \n        # Regularize Bp to avoid division by zero\n        Bp_reg = max(Bp, eps_Bp)\n        \n        # Add the contribution of the segment to the integral\n        integrand = F_val / (R_mid**2 * Bp_reg)\n        q_integral += integrand * dl_p\n        \n    q_value = q_integral / (2 * np.pi)\n    \n    return [q_value, min_Bp]\n\nsolve()\n```"
        }
    ]
}