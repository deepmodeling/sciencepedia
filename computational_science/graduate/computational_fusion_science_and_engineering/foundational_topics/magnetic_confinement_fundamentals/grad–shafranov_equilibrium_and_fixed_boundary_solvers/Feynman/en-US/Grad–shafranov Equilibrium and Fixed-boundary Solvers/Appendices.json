{
    "hands_on_practices": [
        {
            "introduction": "Before solving the full Grad–Shafranov equation, it is essential to accurately represent its linear differential operator, $\\Delta^\\star$, in a discrete form. This exercise guides you through the derivation and implementation of a second-order accurate finite difference stencil for this operator, emphasizing a conservative formulation that is crucial for preserving physical properties in simulations. By verifying your implementation against known analytic solutions, you will build a robust foundation for more complex equilibrium solvers .",
            "id": "3986297",
            "problem": "Consider axisymmetric magnetostatic equilibrium used in computational fusion science and engineering for fixed-boundary solvers of the Grad–Shafranov equation. Begin from the fundamental laws of magnetostatics, namely Ampère’s law $\\nabla \\times \\mathbf{B} = \\mu_{0}\\mathbf{J}$ and Gauss’s law for magnetism $\\nabla \\cdot \\mathbf{B} = 0$, together with the magnetohydrodynamic force balance $\\mathbf{J} \\times \\mathbf{B} = \\nabla p$, and the axisymmetric representation of the magnetic field in cylindrical coordinates $(R,\\phi,Z)$ with no toroidal variation. From these fundamental bases and standard definitions of cylindrical-coordinate differential operators, one arrives at an elliptic partial differential equation (partial differential equation (PDE)) for the poloidal flux function $\\psi(R,Z)$ in which a linear, self-adjoint operator acts on $\\psi(R,Z)$.\n\nYour task is to derive a second-order accurate, finite difference stencil on a uniform $(R,Z)$ grid for this linear operator applied to $\\psi(R,Z)$. In particular, the operator contains a weighted radial derivative of the form $R \\frac{\\partial}{\\partial R}$ acting on a quantity that includes a factor $1/R$. You must express clearly how to approximate this radial part in a conservative, second-order accurate manner using face-centered weights on a uniform grid. Then complete the two-dimensional stencil by adding the axial part in $Z$ with second-order accuracy.\n\nAfter deriving the stencil symbolically, implement it in a program and verify second-order accuracy by comparing against analytic solutions. Use a uniform tensor-product grid with $N_{R}$ points in $R$ and $N_{Z}$ points in $Z$ including boundaries. Let the grid nodes be $R_{i}$ for $i = 0,\\dots,N_{R}-1$ and $Z_{j}$ for $j = 0,\\dots,N_{Z}-1$, with spacings $\\Delta R = (R_{\\max}-R_{\\min})/(N_{R}-1)$ and $\\Delta Z = (Z_{\\max}-Z_{\\min})/(N_{Z}-1)$. Impose fixed (Dirichlet) boundary values by evaluating the exact analytic $\\psi(R,Z)$ on the boundary. Apply your interior stencil only on indices $i=1,\\dots,N_{R}-2$ and $j=1,\\dots,N_{Z}-2$. All angles in trigonometric functions must be interpreted in radians. All quantities are dimensionless, so report errors as dimensionless numbers.\n\nUse the following test suite of parameter values. For each case, compute the maximum-norm error $E_{\\infty}$, defined as the maximum absolute difference between your discrete operator applied to $\\psi$ and the exact analytic operator evaluated at interior nodes.\n\n- Test case $1$ (null-space check for the weighted radial term):\n  - Domain: $R \\in [0.8,\\,1.2]$, $Z \\in [-0.5,\\,0.5]$.\n  - Resolution: $N_{R} = 33$, $N_{Z} = 33$.\n  - Analytic field: $\\psi(R,Z) = \\tfrac{1}{2} R^{2}$.\n- Test case $2$ (polynomial on a moderate grid):\n  - Domain: $R \\in [1.0,\\,2.0]$, $Z \\in [-1.0,\\,1.0]$.\n  - Resolution: $N_{R} = 33$, $N_{Z} = 33$.\n  - Analytic field: $\\psi(R,Z) = R^{4} + Z^{4} + R^{2} Z$.\n- Test case $3$ (polynomial on a refined grid to assess convergence):\n  - Domain: $R \\in [1.0,\\,2.0]$, $Z \\in [-1.0,\\,1.0]$.\n  - Resolution: $N_{R} = 65$, $N_{Z} = 65$.\n  - Analytic field: $\\psi(R,Z) = R^{4} + Z^{4} + R^{2} Z$.\n- Test case $4$ (trigonometric–hyperbolic field on a domain with smaller $R$):\n  - Domain: $R \\in [0.2,\\,0.9]$, $Z \\in [-0.3,\\,0.3]$.\n  - Resolution: $N_{R} = 49$, $N_{Z} = 49$.\n  - Analytic field: $\\psi(R,Z) = \\sin(R)\\,\\cosh(Z)$.\n- Test case $5$ (refinement of test case $4$):\n  - Domain: $R \\in [0.2,\\,0.9]$, $Z \\in [-0.3,\\,0.3]$.\n  - Resolution: $N_{R} = 97$, $N_{Z} = 97$.\n  - Analytic field: $\\psi(R,Z) = \\sin(R)\\,\\cosh(Z)$.\n\nYour program must:\n- Construct the grid for each test case, evaluate the boundary data from the analytic $\\psi(R,Z)$, apply the derived second-order stencil at interior nodes, and compute $E_{\\infty}$ for each case.\n- Produce as final output a single line containing a Python-style list of the five $E_{\\infty}$ values in the order of the test cases, with no additional text. For example, the output must look like $[e_{1},e_{2},e_{3},e_{4},e_{5}]$ where each $e_{k}$ is a floating-point number.",
            "solution": "The problem requires the derivation of a second-order accurate finite difference stencil for the linear operator found in the Grad–Shafranov equation and its subsequent implementation to verify accuracy.\n\n### Derivation of the Grad–Shafranov Operator\n\nWe begin with the fundamental equations of magnetostatics in a plasma, assuming a static equilibrium ($\\partial/\\partial t = 0$):\n1.  Ampère's Law: $\\nabla \\times \\mathbf{B} = \\mu_0 \\mathbf{J}$\n2.  Gauss's Law for Magnetism: $\\nabla \\cdot \\mathbf{B} = 0$\n3.  Force Balance: $\\mathbf{J} \\times \\mathbf{B} = \\nabla p$\n\nWe work in cylindrical coordinates $(R, \\phi, Z)$ and assume axisymmetry, which means all quantities are independent of the toroidal angle $\\phi$, i.e., $\\partial/\\partial\\phi = 0$.\n\nFrom $\\nabla \\cdot \\mathbf{B} = 0$, the magnetic field $\\mathbf{B}$ can be expressed as the curl of a vector potential $\\mathbf{A}$. For an axisymmetric system, it is convenient to define the poloidal magnetic flux function, $\\psi(R,Z)$, such that the poloidal components of the magnetic field are given by:\n$$ \\mathbf{B}_p = B_R \\hat{R} + B_Z \\hat{Z} = \\frac{1}{R} \\nabla\\psi \\times \\hat{\\phi} $$\nExpanding this definition, we obtain the components:\n$$ B_R(R,Z) = -\\frac{1}{R}\\frac{\\partial\\psi}{\\partial Z} \\quad \\text{and} \\quad B_Z(R,Z) = \\frac{1}{R}\\frac{\\partial\\psi}{\\partial R} $$\nThis form automatically satisfies the poloidal part of Gauss's law, $\\nabla \\cdot \\mathbf{B}_p = \\frac{1}{R}\\frac{\\partial}{\\partial R}(R B_R) + \\frac{\\partial B_Z}{\\partial Z} = 0$. The full magnetic field includes a toroidal component, $\\mathbf{B} = \\mathbf{B}_p + B_\\phi(R,Z)\\hat{\\phi}$.\n\nNext, we use Ampère's law to relate the magnetic field to the current density $\\mathbf{J}$. The toroidal component of the current density, $J_\\phi$, is related to the poloidal magnetic field:\n$$ \\mu_0 J_\\phi = (\\nabla \\times \\mathbf{B}_p) \\cdot \\hat{\\phi} = \\frac{\\partial B_R}{\\partial Z} - \\frac{\\partial B_Z}{\\partial R} $$\nSubstituting the expressions for $B_R$ and $B_Z$ in terms of $\\psi$:\n$$ \\mu_0 J_\\phi = \\frac{\\partial}{\\partial Z}\\left(-\\frac{1}{R}\\frac{\\partial\\psi}{\\partial Z}\\right) - \\frac{\\partial}{\\partial R}\\left(\\frac{1}{R}\\frac{\\partial\\psi}{\\partial R}\\right) $$\n$$ \\mu_0 J_\\phi = -\\frac{1}{R}\\frac{\\partial^2\\psi}{\\partial Z^2} - \\left(-\\frac{1}{R^2}\\frac{\\partial\\psi}{\\partial R} + \\frac{1}{R}\\frac{\\partial^2\\psi}{\\partial R^2}\\right) = -\\frac{1}{R}\\left(\\frac{\\partial^2\\psi}{\\partial R^2} - \\frac{1}{R}\\frac{\\partial\\psi}{\\partial R} + \\frac{\\partial^2\\psi}{\\partial Z^2}\\right) $$\nThis expression defines the Grad–Shafranov operator, denoted $\\Delta^*$:\n$$ \\Delta^*\\psi \\equiv \\frac{\\partial^2\\psi}{\\partial R^2} - \\frac{1}{R}\\frac{\\partial\\psi}{\\partial R} + \\frac{\\partial^2\\psi}{\\partial Z^2} $$\nThe force balance equation relates this to the pressure $p$ and the toroidal field function $F(\\psi) = R B_\\phi$, yielding the full Grad–Shafranov equation $\\Delta^*\\psi = - \\mu_0 R^2 \\frac{dp}{d\\psi} - F \\frac{dF}{d\\psi}$. The present task is to discretize the linear differential operator $\\Delta^*$ acting on $\\psi$. For a conservative finite difference formulation, it is best to write the operator in its self-adjoint form, as suggested by the problem statement:\n$$ \\Delta^*\\psi = R\\frac{\\partial}{\\partial R}\\left(\\frac{1}{R}\\frac{\\partial\\psi}{\\partial R}\\right) + \\frac{\\partial^2\\psi}{\\partial Z^2} $$\nThis is the operator we will discretize.\n\n### Finite Difference Stencil Derivation\n\nWe consider a uniform tensor-product grid with nodes $(R_i, Z_j)$, where $R_i = R_{\\min} + i\\Delta R$ for $i=0, \\dots, N_R-1$ and $Z_j = Z_{\\min} + j\\Delta Z$ for $j=0, \\dots, N_Z-1$. The grid spacings are $\\Delta R = (R_{\\max}-R_{\\min})/(N_R-1)$ and $\\Delta Z = (Z_{\\max}-Z_{\\min})/(N_Z-1)$. Let $\\psi_{i,j} = \\psi(R_i, Z_j)$.\n\nThe discretization is performed at an interior grid node $(i,j)$ where $1 \\le i \\le N_R-2$ and $1 \\le j \\le N_Z-2$.\n\n**Axial Part:** The second partial derivative with respect to $Z$ is approximated using a standard second-order central difference formula:\n$$ \\left. \\frac{\\partial^2\\psi}{\\partial Z^2} \\right|_{i,j} \\approx \\frac{\\psi_{i,j+1} - 2\\psi_{i,j} + \\psi_{i,j-1}}{(\\Delta Z)^2} $$\n\n**Radial Part:** The radial part of the operator is $L_R\\psi = R\\frac{\\partial}{\\partial R}\\left(\\frac{1}{R}\\frac{\\partial\\psi}{\\partial R}\\right)$. To achieve a conservative and second-order accurate discretization, we use a \"face-centered\" or finite-volume-like approach. Let $F_R(R) = \\frac{1}{R}\\frac{\\partial\\psi}{\\partial R}$ be the radial flux. The operator at $R_i$ is $R_i \\frac{\\partial F_R}{\\partial R}|_{R_i}$. We approximate the derivative of the flux using central differences on the cell faces, which are located at half-integer grid indices $R_{i\\pm 1/2} = R_i \\pm \\Delta R/2$:\n$$ \\left. \\frac{\\partial F_R}{\\partial R} \\right|_{R_i} \\approx \\frac{F_R(R_{i+1/2}) - F_R(R_{i-1/2})}{\\Delta R} $$\nThe flux $F_R$ at these face centers is itself approximated using second-order central differences for the derivative of $\\psi$:\n$$ F_R(R_{i+1/2}) = \\left. \\frac{1}{R}\\frac{\\partial\\psi}{\\partial R} \\right|_{R_{i+1/2}} \\approx \\frac{1}{R_{i+1/2}} \\frac{\\psi_{i+1,j} - \\psi_{i,j}}{\\Delta R} $$\n$$ F_R(R_{i-1/2}) = \\left. \\frac{1}{R}\\frac{\\partial\\psi}{\\partial R} \\right|_{R_{i-1/2}} \\approx \\frac{1}{R_{i-1/2}} \\frac{\\psi_{i,j} - \\psi_{i-1,j}}{\\Delta R} $$\nSubstituting these into the expression for the operator, the discrete radial operator $(L_R\\psi)_{i,j}$ becomes:\n$$ (L_R\\psi)_{i,j} \\approx R_i \\frac{1}{\\Delta R} \\left( \\frac{1}{R_{i+1/2}} \\frac{\\psi_{i+1,j} - \\psi_{i,j}}{\\Delta R} - \\frac{1}{R_{i-1/2}} \\frac{\\psi_{i,j} - \\psi_{i-1,j}}{\\Delta R} \\right) $$\n$$ (L_R\\psi)_{i,j} \\approx \\frac{R_i}{(\\Delta R)^2} \\left[ \\frac{1}{R_{i-1/2}}\\psi_{i-1,j} - \\left(\\frac{1}{R_{i+1/2}} + \\frac{1}{R_{i-1/2}}\\right)\\psi_{i,j} + \\frac{1}{R_{i+1/2}}\\psi_{i+1,j} \\right] $$\nwhere $R_{i\\pm 1/2} = R_i \\pm \\Delta R/2$.\n\n**Complete Stencil:** Combining the radial and axial parts, we get the complete 5-point stencil for $(\\Delta^*\\psi)_{i,j}$:\n$$ (\\Delta^*\\psi)_{i,j} \\approx \\frac{R_i}{(\\Delta R)^2} \\left[ \\frac{\\psi_{i-1,j}}{R_i-\\frac{\\Delta R}{2}} - \\left(\\frac{1}{R_i+\\frac{\\Delta R}{2}} + \\frac{1}{R_i-\\frac{\\Delta R}{2}}\\right)\\psi_{i,j} + \\frac{\\psi_{i+1,j}}{R_i+\\frac{\\Delta R}{2}} \\right] + \\frac{\\psi_{i,j-1} - 2\\psi_{i,j} + \\psi_{i,j+1}}{(\\Delta Z)^2} $$\nThis stencil is second-order accurate in both $\\Delta R$ and $\\Delta Z$.\n\n### Verification and Implementation\n\nTo verify the second-order accuracy, we apply this discrete operator to known analytic functions $\\psi(R,Z)$ and compare the result with the exact analytical evaluation of $\\Delta^*\\psi$. The maximum-norm error $E_{\\infty}$ over all interior grid points is computed:\n$$ E_{\\infty} = \\max_{1\\le i \\le N_R-2, 1\\le j \\le N_Z-2} \\left| (\\Delta^*\\psi)_{i,j}^{\\text{numerical}} - (\\Delta^*\\psi)(R_i,Z_j)^{\\text{analytic}} \\right| $$\nThe provided test cases allow for checking the null-space property of the radial operator and assessing the convergence rate, which should be quadratic ($E_{\\infty} \\propto (\\Delta R)^2, (\\Delta Z)^2$). For pairs of test cases where the grid resolution is doubled, the error is expected to decrease by a factor of approximately $4$.\nThe implementation will follow the derived stencil, applying it to the interior of the domain, with the full grid of $\\psi$ values (including boundaries) computed from the given analytic functions.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef apply_operator(psi, R, Z):\n    \"\"\"\n    Applies the discretized Grad-Shafranov operator Delta* to a function psi.\n\n    Args:\n        psi (np.ndarray): 2D array of psi values on the (R, Z) grid.\n        R (np.ndarray): 1D array of R-coordinates.\n        Z (np.ndarray): 1D array of Z-coordinates.\n\n    Returns:\n        np.ndarray: 2D array of the operator applied to psi.\n    \"\"\"\n    N_R, N_Z = psi.shape\n    if N_R < 3 or N_Z < 3:\n        return np.zeros_like(psi)\n\n    delta_R = R[1] - R[0]\n    delta_Z = Z[1] - Z[0]\n    \n    L_psi = np.zeros_like(psi)\n\n    # Vectorized computation for interior points\n    # psi slices for stencil\n    psi_mid = psi[1:-1, 1:-1]\n    psi_im1 = psi[:-2, 1:-1]\n    psi_ip1 = psi[2:, 1:-1]\n    psi_jm1 = psi[1:-1, :-2]\n    psi_jp1 = psi[1:-1, 2:]\n\n    # R-coordinates for interior points and faces\n    R_int = R[1:-1]\n    R_face_m = R_int - delta_R / 2.0\n    R_face_p = R_int + delta_R / 2.0\n\n    # Reshape R arrays for broadcasting\n    R_int_col = R_int[:, np.newaxis]\n    R_face_m_col = R_face_m[:, np.newaxis]\n    R_face_p_col = R_face_p[:, np.newaxis]\n\n    # Radial part of the operator\n    # Note: A check for R_face_m_col == 0 is needed if R_min=0 and N_R is even,\n    # but the test cases avoid this.\n    term_im1 = psi_im1 / R_face_m_col\n    term_ip1 = psi_ip1 / R_face_p_col\n    term_i = -(1.0/R_face_p_col + 1.0/R_face_m_col) * psi_mid\n    L_R_psi = (R_int_col / (delta_R**2)) * (term_im1 + term_i + term_ip1)\n\n    # Axial part of the operator\n    L_Z_psi = (psi_jp1 - 2.0 * psi_mid + psi_jm1) / (delta_Z**2)\n\n    # Combine parts and store in the interior of the result matrix\n    L_psi[1:-1, 1:-1] = L_R_psi + L_Z_psi\n\n    return L_psi\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute errors.\n    \"\"\"\n    test_cases = [\n        {\n            \"domain\": (0.8, 1.2, -0.5, 0.5),\n            \"resolution\": (33, 33),\n            \"psi_func\": lambda R, Z: 0.5 * R**2,\n            \"L_psi_func\": lambda R, Z: np.zeros_like(R),\n        },\n        {\n            \"domain\": (1.0, 2.0, -1.0, 1.0),\n            \"resolution\": (33, 33),\n            \"psi_func\": lambda R, Z: R**4 + Z**4 + R**2 * Z,\n            \"L_psi_func\": lambda R, Z: 8.0 * R**2 + 12.0 * Z**2,\n        },\n        {\n            \"domain\": (1.0, 2.0, -1.0, 1.0),\n            \"resolution\": (65, 65),\n            \"psi_func\": lambda R, Z: R**4 + Z**4 + R**2 * Z,\n            \"L_psi_func\": lambda R, Z: 8.0 * R**2 + 12.0 * Z**2,\n        },\n        {\n            \"domain\": (0.2, 0.9, -0.3, 0.3),\n            \"resolution\": (49, 49),\n            \"psi_func\": lambda R, Z: np.sin(R) * np.cosh(Z),\n            \"L_psi_func\": lambda R, Z: -np.cos(R) * np.cosh(Z) / R,\n        },\n        {\n            \"domain\": (0.2, 0.9, -0.3, 0.3),\n            \"resolution\": (97, 97),\n            \"psi_func\": lambda R, Z: np.sin(R) * np.cosh(Z),\n            \"L_psi_func\": lambda R, Z: -np.cos(R) * np.cosh(Z) / R,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        R_min, R_max, Z_min, Z_max = case[\"domain\"]\n        N_R, N_Z = case[\"resolution\"]\n        psi_func = case[\"psi_func\"]\n        L_psi_func = case[\"L_psi_func\"]\n\n        # 1. Construct the grid\n        R_coords = np.linspace(R_min, R_max, N_R)\n        Z_coords = np.linspace(Z_min, Z_max, N_Z)\n        R_grid, Z_grid = np.meshgrid(R_coords, Z_coords, indexing='ij')\n\n        # 2. Evaluate analytic psi on the grid\n        psi_analytic = psi_func(R_grid, Z_grid)\n\n        # 3. Apply the discrete operator\n        L_psi_numerical = apply_operator(psi_analytic, R_coords, Z_coords)\n\n        # 4. Evaluate the exact analytic operator\n        L_psi_analytic = L_psi_func(R_grid, Z_grid)\n\n        # 5. Compute the maximum-norm error on the interior\n        error_matrix = L_psi_numerical - L_psi_analytic\n        interior_error = error_matrix[1:-1, 1:-1]\n        E_inf = np.max(np.abs(interior_error))\n        \n        results.append(E_inf)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "With a discrete operator in hand, the next step is to tackle the full Grad–Shafranov equation, including its pressure and magnetic field source terms. This practice introduces the powerful method of manufactured solutions, a standard technique for code verification where you begin with a chosen analytic form for the flux function $\\psi$ and derive the source terms that make it an exact solution. This process allows you to create a definitive test case to confirm that your implementation of the complete equilibrium equation is correct .",
            "id": "3986305",
            "problem": "Consider an axisymmetric plasma equilibrium in Magnetohydrodynamics (MHD), with cylindrical coordinates $(R,\\phi,Z)$ and no dependence on the toroidal angle $\\phi$. Let the poloidal magnetic flux function be $\\psi(R,Z)$, the plasma pressure be $p(\\psi)$, and the toroidal field function be $F(\\psi) = R B_{\\phi}$, where $B_{\\phi}$ is the toroidal magnetic field. The Grad–Shafranov equation is the condition for static force balance and compatibility with Maxwell’s equations in such axisymmetric systems, and can be written in the operator form\n$$\n\\Delta^{\\star} \\psi = - \\mu_0 R^2 \\frac{dp}{d\\psi} - \\frac{1}{2} \\frac{d(F^2)}{d\\psi},\n$$\nwhere $\\mu_0$ is the magnetic permeability, and the Grad–Shafranov operator is\n$$\n\\Delta^{\\star} \\psi \\equiv R \\frac{\\partial}{\\partial R} \\left( \\frac{1}{R} \\frac{\\partial \\psi}{\\partial R} \\right) + \\frac{\\partial^2 \\psi}{\\partial Z^2}.\n$$\nIn fixed-boundary solvers, the domain boundary is prescribed and one verifies an equilibrium by ensuring the residual of the Grad–Shafranov equation vanishes throughout the domain for consistent choices of $p(\\psi)$ and $F(\\psi)$.\n\nYour task is to use the method of manufactured solutions to construct an analytic equilibrium suitable for code verification in a dimensionless formulation with $\\mu_0 = 1$. Specifically:\n\n1. Choose the analytic flux\n$$\n\\psi(R,Z) = k R^4 + m Z^2 + \\psi_0,\n$$\nwith constants $k$, $m$, and $\\psi_0$.\n\n2. Starting from the definition of $\\Delta^{\\star}$, compute $\\Delta^{\\star}\\psi$ for this choice of $\\psi(R,Z)$, and then infer functions $p(\\psi)$ and $F(\\psi)$ (equivalently $F^2(\\psi)$) such that the Grad–Shafranov equation is satisfied pointwise in the domain. You must express $p(\\psi)$ and $F^2(\\psi)$ explicitly and ensure that $\\frac{dp}{d\\psi}$ and $\\frac{d(F^2)}{d\\psi}$ depend only on $\\psi$, as required by the physics.\n\n3. Implement a program that evaluates the maximum absolute residual\n$$\n\\mathcal{R}_{\\max} = \\max_{(R,Z) \\in \\Omega} \\left| \\Delta^{\\star}\\psi + R^2 \\frac{dp}{d\\psi} + \\frac{1}{2} \\frac{d(F^2)}{d\\psi} \\right|\n$$\nover a rectangular domain\n$$\n\\Omega = \\{ (R,Z) \\mid R \\in [R_{\\min}, R_{\\max}],\\, Z \\in [-Z_{\\max}, Z_{\\max}] \\},\n$$\non a uniform grid with $N_R$ points in $R$ and $N_Z$ points in $Z$.\n\n4. Use the following test suite of parameters, all dimensionless, to evaluate $\\mathcal{R}_{\\max}$ in each case:\n- Case $1$: $k = 0.25$, $m = 0.75$, $\\psi_0 = 0$, $R_{\\min} = 1$, $R_{\\max} = 3$, $Z_{\\max} = 1$, $N_R = 101$, $N_Z = 101$, $p_0 = 0$, $f_0 = 10$.\n- Case $2$: $k = 0$, $m = 0.5$, $\\psi_0 = 0$, $R_{\\min} = 1$, $R_{\\max} = 3$, $Z_{\\max} = 1$, $N_R = 101$, $N_Z = 101$, $p_0 = 0$, $f_0 = 10$.\n- Case $3$: $k = -0.125$, $m = 0.3$, $\\psi_0 = 0$, $R_{\\min} = 1$, $R_{\\max} = 3$, $Z_{\\max} = 1$, $N_R = 101$, $N_Z = 101$, $p_0 = 0$, $f_0 = 10$.\n- Case $4$: $k = 0.2$, $m = -0.4$, $\\psi_0 = 0$, $R_{\\min} = 1$, $R_{\\max} = 3$, $Z_{\\max} = 1$, $N_R = 101$, $N_Z = 101$, $p_0 = 0$, $f_0 = 10$.\n\nThe constants $p_0$ and $f_0$ are arbitrary offsets for $p(\\psi)$ and $F^2(\\psi)$ that do not affect the residual because only derivatives with respect to $\\psi$ appear. They are included for completeness.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,r_3,r_4]$), where $r_i$ is the computed $\\mathcal{R}_{\\max}$ (a float) for Case $i$ in the test suite. Angles do not appear in this problem, and all quantities are dimensionless by construction; therefore, no units are required in the output.",
            "solution": "The user wants me to solve a problem on the Grad-Shafranov equation.\n\n### Problem Validation\n\n#### Step 1: Extract Givens\n\n-   **Governing Equation (Grad–Shafranov)**:\n    $$\n    \\Delta^{\\star} \\psi = - \\mu_0 R^2 \\frac{dp}{d\\psi} - \\frac{1}{2} \\frac{d(F^2)}{d\\psi}\n    $$\n-   **Grad–Shafranov Operator**:\n    $$\n    \\Delta^{\\star} \\psi \\equiv R \\frac{\\partial}{\\partial R} \\left( \\frac{1}{R} \\frac{\\partial \\psi}{\\partial R} \\right) + \\frac{\\partial^2 \\psi}{\\partial Z^2}\n    $$\n-   **Definitions**:\n    -   $\\psi(R,Z)$: Poloidal magnetic flux function.\n    -   $p(\\psi)$: Plasma pressure.\n    -   $F(\\psi) = R B_{\\phi}$: Toroidal field function.\n    -   $(R,\\phi,Z)$: Cylindrical coordinates.\n-   **Assumptions/Conditions**:\n    -   Axisymmetric equilibrium ($\\partial/\\partial\\phi = 0$).\n    -   Static force balance.\n    -   Dimensionless formulation with magnetic permeability $\\mu_0 = 1$.\n-   **Manufactured Solution Form**:\n    $$\n    \\psi(R,Z) = k R^4 + m Z^2 + \\psi_0\n    $$\n-   **Task**:\n    1.  Compute $\\Delta^{\\star}\\psi$ for the given $\\psi(R,Z)$.\n    2.  Infer functions $p(\\psi)$ and $F^2(\\psi)$ such that the Grad–Shafranov equation is satisfied.\n    3.  Implement a program to evaluate the maximum absolute residual $\\mathcal{R}_{\\max}$ over a specified domain $\\Omega$.\n-   **Residual Definition**:\n    $$\n    \\mathcal{R}_{\\max} = \\max_{(R,Z) \\in \\Omega} \\left| \\Delta^{\\star}\\psi + R^2 \\frac{dp}{d\\psi} + \\frac{1}{2} \\frac{d(F^2)}{d\\psi} \\right|\n    $$\n-   **Domain**:\n    $$\n    \\Omega = \\{ (R,Z) \\mid R \\in [R_{\\min}, R_{\\max}],\\, Z \\in [-Z_{\\max}, Z_{\\max}] \\}\n    $$\n-   **Grid**: Uniform grid with $N_R$ points in $R$ and $N_Z$ points in $Z$.\n-   **Test Suite**:\n    -   **Case 1**: $k = 0.25$, $m = 0.75$, $\\psi_0 = 0$, $R_{\\min} = 1$, $R_{\\max} = 3$, $Z_{\\max} = 1$, $N_R = 101$, $N_Z = 101$, $p_0 = 0$, $f_0 = 10$.\n    -   **Case 2**: $k = 0$, $m = 0.5$, $\\psi_0 = 0$, $R_{\\min} = 1$, $R_{\\max} = 3$, $Z_{\\max} = 1$, $N_R = 101$, $N_Z = 101$, $p_0 = 0$, $f_0 = 10$.\n    -   **Case 3**: $k = -0.125$, $m = 0.3$, $\\psi_0 = 0$, $R_{\\min} = 1$, $R_{\\max} = 3$, $Z_{\\max} = 1$, $N_R = 101$, $N_Z = 101$, $p_0 = 0$, $f_0 = 10$.\n    -   **Case 4**: $k = 0.2$, $m = -0.4$, $\\psi_0 = 0$, $R_{\\min} = 1$, $R_{\\max} = 3$, $Z_{\\max} = 1$, $N_R = 101$, $N_Z = 101$, $p_0 = 0$, $f_0 = 10$.\n\n#### Step 2: Validate Using Extracted Givens\n\n-   **Scientifically Grounded**: The problem is based on the Grad–Shafranov equation, a cornerstone of magnetohydrodynamics (MHD) for describing tokamak equilibria. The method of manufactured solutions is a standard, rigorous technique for the verification of numerical codes in computational science and engineering. All elements are firmly rooted in established plasma physics and numerical analysis.\n-   **Well-Posed**: The problem is constructive and well-defined. It asks to first derive analytic source terms for a given solution form and then to compute the residual of the governing equation. This process is guaranteed to have a unique and stable solution (analytically, the residual is zero).\n-   **Objective**: The problem is stated using precise mathematical definitions and provides objective numerical parameters for evaluation. There is no subjective or ambiguous language.\n-   **Completeness and Consistency**: All necessary equations, boundary conditions (in the form of a specified domain), functional forms, and parameters are provided. The requirement that $\\frac{dp}{d\\psi}$ and $\\frac{d(F^2)}{d\\psi}$ depend only on $\\psi$ is a key physical constraint that can be consistently satisfied by the proposed procedure. The problem is self-contained and free of contradictions. The inclusion of constants $p_0$ and $f_0$ is correctly noted as irrelevant to the residual calculation, which is consistent with the physics.\n\n#### Step 3: Verdict and Action\n\nThe problem is valid. It is a well-posed, scientifically sound exercise in applying the method of manufactured solutions to the Grad-Shafranov equation.\n\n### Solution Derivation\n\nThe objective is to find source functions $p(\\psi)$ and $F(\\psi)$ that satisfy the Grad-Shafranov equation for a prescribed analytic form of $\\psi(R,Z)$. This manufactured solution then provides a test case for which the exact solution is known, allowing for the verification of a numerical solver by checking if it recovers this solution with a residual close to machine precision.\n\nLet the dimensionless Grad-Shafranov equation be\n$$\n\\Delta^{\\star} \\psi = - R^2 \\frac{dp}{d\\psi} - \\frac{1}{2} \\frac{d(F^2)}{d\\psi}\n$$\nwith the operator\n$$\n\\Delta^{\\star} \\psi \\equiv R \\frac{\\partial}{\\partial R} \\left( \\frac{1}{R} \\frac{\\partial \\psi}{\\partial R} \\right) + \\frac{\\partial^2 \\psi}{\\partial Z^2}\n$$\nThe prescribed analytic flux function is\n$$\n\\psi(R,Z) = k R^4 + m Z^2 + \\psi_0\n$$\n\nFirst, we compute the left-hand side, $\\Delta^{\\star}\\psi$, by evaluating the necessary partial derivatives.\nThe partial derivative with respect to $R$ is:\n$$\n\\frac{\\partial \\psi}{\\partial R} = 4k R^3\n$$\nDividing by $R$:\n$$\n\\frac{1}{R} \\frac{\\partial \\psi}{\\partial R} = 4k R^2\n$$\nTaking the derivative with respect to $R$ again:\n$$\n\\frac{\\partial}{\\partial R} \\left( \\frac{1}{R} \\frac{\\partial \\psi}{\\partial R} \\right) = \\frac{\\partial}{\\partial R} (4k R^2) = 8k R\n$$\nMultiplying by $R$ gives the first term of the operator:\n$$\nR \\frac{\\partial}{\\partial R} \\left( \\frac{1}{R} \\frac{\\partial \\psi}{\\partial R} \\right) = R (8k R) = 8k R^2\n$$\nNext, we compute the partial derivatives with respect to $Z$:\n$$\n\\frac{\\partial \\psi}{\\partial Z} = 2m Z\n$$\n$$\n\\frac{\\partial^2 \\psi}{\\partial Z^2} = 2m\n$$\nCombining these results, we obtain the expression for $\\Delta^{\\star}\\psi$:\n$$\n\\Delta^{\\star}\\psi = 8k R^2 + 2m\n$$\nNow, we substitute this result into the Grad-Shafranov equation:\n$$\n8k R^2 + 2m = - R^2 \\frac{dp}{d\\psi} - \\frac{1}{2} \\frac{d(F^2)}{d\\psi}\n$$\nTo satisfy the physical constraint that the source terms $\\frac{dp}{d\\psi}$ and $\\frac{d(F^2)}{d\\psi}$ must be functions of $\\psi$ only (and thus independent of explicit $(R,Z)$ coordinates), we can rearrange the equation by grouping terms with and without $R^2$:\n$$\n\\left( 8k + \\frac{dp}{d\\psi} \\right) R^2 + \\left( 2m + \\frac{1}{2} \\frac{d(F^2)}{d\\psi} \\right) = 0\n$$\nFor this equation to hold for all values of $R$ and $Z$ within the domain, the coefficients of the powers of $R$ (in this case, $R^2$ and $R^0$) must vanish independently. This yields a system of two equations:\n$$\n8k + \\frac{dp}{d\\psi} = 0 \\implies \\frac{dp}{d\\psi} = -8k\n$$\n$$\n2m + \\frac{1}{2} \\frac{d(F^2)}{d\\psi} = 0 \\implies \\frac{d(F^2)}{d\\psi} = -4m\n$$\nSince $k$ and $m$ are constants, the derivatives $\\frac{dp}{d\\psi}$ and $\\frac{d(F^2)}{d\\psi}$ are also constants. A constant is trivially a function of $\\psi$, so these choices are valid.\nWe can integrate these expressions to find the full forms of $p(\\psi)$ and $F^2(\\psi)$:\n$$\np(\\psi) = \\int (-8k) \\, d\\psi = -8k\\psi + C_p\n$$\n$$\nF^2(\\psi) = \\int (-4m) \\, d\\psi = -4m\\psi + C_f\n$$\nThe integration constants $C_p$ and $C_f$ correspond to the arbitrary offsets $p_0$ and $f_0$ mentioned in the problem, which do not affect the residual calculation.\n\nWith these derived source-term derivatives, the residual of the Grad-Shafranov equation is, by construction, identically zero for all $(R,Z)$:\n$$\n\\mathcal{R}(R,Z) = \\Delta^{\\star}\\psi + R^2 \\frac{dp}{d\\psi} + \\frac{1}{2} \\frac{d(F^2)}{d\\psi}\n$$\n$$\n\\mathcal{R}(R,Z) = (8k R^2 + 2m) + R^2(-8k) + \\frac{1}{2}(-4m)\n$$\n$$\n\\mathcal{R}(R,Z) = 8k R^2 + 2m - 8k R^2 - 2m = 0\n$$\nThe task is to implement a program that calculates this residual on a discrete grid. Due to floating-point arithmetic, the numerically computed residual may not be exactly zero. The program will evaluate $\\mathcal{R}_{\\max} = \\max |\\mathcal{R}(R,Z)|$ over the grid for each test case. This value should be on the order of machine precision, confirming the correctness of the derivation and its implementation.\nThe implementation will proceed as follows:\n1.  For each test case, define the parameters $k, m, R_{\\min}, R_{\\max}, Z_{\\max}, N_R, N_Z$.\n2.  Create a 2D grid of $(R,Z)$ points using `numpy.linspace` and `numpy.meshgrid`.\n3.  On this grid, compute the terms of the residual:\n    -   The manufactured Grad-Shafranov operator term: $(\\Delta^{\\star}\\psi)_{\\text{grid}} = 8k R_{\\text{grid}}^2 + 2m$.\n    -   The manufactured pressure term: $(R^2 \\frac{dp}{d\\psi})_{\\text{grid}} = R_{\\text{grid}}^2 (-8k)$.\n    -   The manufactured magnetic field term: $(\\frac{1}{2} \\frac{d(F^2)}{d\\psi})_{\\text{grid}} = \\frac{1}{2} (-4m) = -2m$.\n4.  Sum these terms to get the residual at each grid point.\n5.  Find the maximum absolute value of the residual array.\n6.  Collect the results for all test cases and print them in the specified format. The constants $\\psi_0$, $p_0$, and $f_0$ are not needed for this calculation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the maximum absolute residual of a manufactured Grad-Shafranov\n    equilibrium for a series of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (k, m, psi_0, R_min, R_max, Z_max, N_R, N_Z, p_0, f_0)\n    test_cases = [\n        (0.25, 0.75, 0, 1, 3, 1, 101, 101, 0, 10),\n        (0, 0.5, 0, 1, 3, 1, 101, 101, 0, 10),\n        (-0.125, 0.3, 0, 1, 3, 1, 101, 101, 0, 10),\n        (0.2, -0.4, 0, 1, 3, 1, 101, 101, 0, 10),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters for the current case.\n        # psi_0, p_0, and f_0 are not used in the residual calculation.\n        k, m, _, r_min, r_max, z_max, n_r, n_z, _, _ = case\n\n        # Create the computational grid.\n        # R-coordinates for the grid points.\n        R = np.linspace(r_min, r_max, n_r)\n        # Z-coordinates for the grid points.\n        Z = np.linspace(-z_max, z_max, n_z)\n        # Create 2D meshgrid. R_grid varies along columns, Z_grid along rows.\n        # This is the standard 'xy' indexing.\n        R_grid, Z_grid = np.meshgrid(R, Z)\n\n        # Analytically derive the source term derivatives from the manufactured solution.\n        # The form psi = k*R^4 + m*Z^2 + psi_0 requires:\n        # dp/dpsi = -8*k\n        # d(F^2)/dpsi = -4*m\n        dp_dpsi = -8.0 * k\n        dF2_dpsi = -4.0 * m\n        \n        # Calculate each term of the Grad-Shafranov equation residual.\n        # Term 1: Delta_star_psi = 8*k*R^2 + 2*m\n        delta_star_psi_grid = 8.0 * k * R_grid**2 + 2.0 * m\n        \n        # Term 2: R^2 * dp/dpsi\n        pressure_term = R_grid**2 * dp_dpsi\n        \n        # Term 3: (1/2) * d(F^2)/dpsi\n        field_term = 0.5 * dF2_dpsi\n        \n        # The residual is the sum of these terms. By construction, it should be\n        # analytically zero. The numerical result will be close to machine epsilon.\n        # residual = (8*k*R^2 + 2*m) + R^2*(-8*k) + (1/2)*(-4*m)\n        #          = 8*k*R^2 + 2*m - 8*k*R^2 - 2*m = 0\n        residual_grid = delta_star_psi_grid + pressure_term + field_term\n        \n        # Calculate the maximum absolute residual over the entire domain.\n        max_abs_residual = np.max(np.abs(residual_grid))\n        \n        results.append(max_abs_residual)\n\n    # Final print statement in the exact required format.\n    # The output values are very small floats representing numerical noise,\n    # as the analytical residual is zero.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "A computed equilibrium solution is only useful if we can extract physical insights from it. This final practice focuses on post-processing the poloidal flux function $\\psi$ to calculate one of the most important parameters in fusion science: the safety factor, $q(\\psi)$. You will implement an algorithm to trace flux surfaces and perform the necessary line integral, confronting real-world numerical challenges such as the singularity that arises near a magnetic separatrix .",
            "id": "3986339",
            "problem": "You are given a fixed-boundary axisymmetric magnetohydrodynamic equilibrium described by a poloidal flux function $ \\psi(R,Z) $ and a specified toroidal field function $ F(\\psi) $, where $ F(\\psi) = R B_{\\varphi} $ and $ B_{\\varphi} $ is the toroidal magnetic field. Using only fundamental laws and core definitions of the Grad–Shafranov equilibrium, derive a computational procedure to evaluate the safety factor $ q(\\psi) $ on closed flux surfaces $ \\psi = \\text{const} $ inside the last closed flux surface. The safety factor is defined as the ratio of toroidal magnetic flux to poloidal magnetic flux and, in axisymmetry, is expressible as a line integral over the poloidal cross-section. Starting from the definitions of magnetic fields in cylindrical coordinates $ (R,\\varphi,Z) $ and axisymmetric equilibrium, derive an algorithm that computes\n$$\nq(\\psi) = \\frac{1}{2\\pi} \\oint_{\\psi=\\text{const}} \\frac{F(\\psi)}{R^2} \\frac{dl_p}{B_p},\n$$\nwhere $ dl_p $ is the poloidal arc length element and $ B_p = \\lvert \\nabla \\psi \\rvert / R $ is the poloidal magnetic field magnitude. You must construct the algorithm so that the integral is approximated numerically from discrete points along $ \\psi = \\text{const} $, obtained by tracing the contour using ray-based root finding from the magnetic axis. Your procedure must explicitly identify and explain numerical challenges that arise near a separatrix (an $ X $-point), where $ B_p \\to 0 $, and must incorporate a robust strategy to detect and regularize these challenges.\n\nYour task is to implement a complete, runnable program that:\n1. Encodes the derivation into a numerical algorithm that constructs flux-surface contours $ \\psi = \\psi_t $ using ray-based root finding from a given magnetic axis location $ (R_0, Z_0) $.\n2. Computes $ q(\\psi_t) $ via the discrete approximation of the line integral above using $ N_{\\theta} $ uniformly spaced angles $ \\theta \\in [0,2\\pi) $.\n3. Reports a diagnostic for each computation, specifically the minimum poloidal field magnitude along the contour, $ \\min B_p $, as a quantitative indicator of separatrix proximity and numerical stiffness.\n\nAll quantities are dimensionless in this problem. Angles must be treated in radians. Your numerical algorithm must be demonstrably robust across a small test suite that covers a variety of fixed-boundary equilibria. In each test, $ \\psi(R,Z) $ and $ F(\\psi) $ are specified analytically to ensure closed surfaces and known magnetic axis, and the target level $ \\psi_t $ is prescribed. Use the following test suite, each item fully determines $ \\psi(R,Z) $, $ \\nabla \\psi(R,Z) $, $ F(\\psi) $, the magnetic axis, and the target $ \\psi_t $:\n\n- Test Case 1 (circular surfaces, constant $ F $): $ \\psi(R,Z) = A \\big[(R-R_0)^2 + Z^2\\big] $, with $ A = 0.8 $, $ R_0 = 3.0 $, magnetic axis at $ (R_0,0) $. Let $ F(\\psi) = F_0 $ with $ F_0 = 6.0 $. The target level is $ \\psi_t = A r^2 $ with $ r = 0.5 $.\n- Test Case 2 (larger circular radius, constant $ F $): $ \\psi(R,Z) = A \\big[(R-R_0)^2 + Z^2\\big] $, with $ A = 0.8 $, $ R_0 = 3.0 $, magnetic axis at $ (R_0,0) $. Let $ F(\\psi) = F_0 $ with $ F_0 = 6.0 $. The target level is $ \\psi_t = A r^2 $ with $ r = 2.5 $.\n- Test Case 3 (elliptical elongation, linear $ F(\\psi) $): $ \\psi(R,Z) = A \\big[(R-R_0)^2 + (Z/\\kappa)^2\\big] $, with $ A = 0.6 $, $ \\kappa = 1.7 $, $ R_0 = 3.0 $, magnetic axis at $ (R_0,0) $. Let $ F(\\psi) = F_0 + \\alpha \\psi $ with $ F_0 = 5.0 $, $ \\alpha = 0.2 $. The target level is $ \\psi_t = A r^2 $ with $ r = 1.2 $.\n- Test Case 4 (near-separatrix-like distortion by a localized bump, constant $ F $): $ \\psi(R,Z) = A \\big[(R-R_0)^2 + Z^2\\big] - \\varepsilon \\exp\\big(-((R-R_x)^2 + (Z-Z_x)^2)/\\sigma^2\\big) $, with $ A = 0.5 $, $ R_0 = 3.0 $, $ R_x = R_0 + 1.7 $, $ Z_x = 0.0 $, $ \\sigma = 0.2 $, $ \\varepsilon = 0.35 $, magnetic axis at $ (R_0,0) $. Let $ F(\\psi) = F_0 $ with $ F_0 = 6.0 $. The target level is $ \\psi_t = A r^2 - 0.5 \\varepsilon $ with $ r = 1.7 $.\n\nYour program must:\n- Use $ N_{\\theta} = 1024 $ angles for the contour construction and integration.\n- Use a ray-based search distance upper bound $ s_{\\max} = 3.5 $ and at least $ 200 $ radial samples per angle to bracket roots, followed by bisection to machine precision tolerance for each root.\n- Approximate the line integral by summing over straight segments between successive contour points using midpoint evaluation for $ B_p $ and $ R $ in the integrand.\n- Detect near-separatrix stiffness by reporting $ \\min B_p $ along the contour. To ensure numerical stability, regularize the integrand by replacing any $ B_p $ below a small threshold $ \\epsilon_{B_p} $ with $ \\epsilon_{B_p} $ in the denominator during integration, while still reporting the true $ \\min B_p $ to quantify stiffness. Use $ \\epsilon_{B_p} = 10^{-6} $.\n\nFinal Output Format:\nYour program should produce a single line of output containing a list of results, one per test case, where each item is itself a list with two floats $ [q(\\psi_t), \\min B_p] $ for the specified $ \\psi_t $. The overall output must be a comma-separated list enclosed in square brackets with items in order of the test cases, for example, $ [[q_1,\\min B_{p,1}],[q_2,\\min B_{p,2}],[q_3,\\min B_{p,3}],[q_4,\\min B_{p,4}]] $.\n\nThere are no physical units in this problem because all quantities are dimensionless. Angles must be in radians. The program must be self-contained and require no input.",
            "solution": "The problem is valid. It presents a well-posed, scientifically grounded task in computational plasma physics that is complete and formalizable. The provided test cases are standard, analytically defined equilibria used for verifying numerical codes that solve for magnetohydrodynamic (MHD) equilibrium properties. The task is to derive and implement a computational procedure to calculate the safety factor, $q(\\psi)$, for specified magnetic flux surfaces.\n\nThe safety factor, $q$, is a crucial parameter in magnetic confinement fusion, representing the number of times a magnetic field line travels toroidally for each poloidal transit. For an axisymmetric equilibrium, it is a function of the poloidal flux $\\psi$ and can be calculated via the line integral:\n$$\nq(\\psi) = \\frac{1}{2\\pi} \\oint_{\\psi=\\text{const}} \\frac{F(\\psi)}{R^2} \\frac{dl_p}{B_p}\n$$\nHere, the integral is taken along a contour of constant poloidal flux $\\psi(R,Z) = \\psi_t$ in the poloidal plane $(R,Z)$. $F(\\psi) = R B_{\\varphi}$ is the poloidal current function, $dl_p$ is the element of poloidal arc length, and $B_p$ is the magnitude of the poloidal magnetic field. The poloidal magnetic field $\\vec{B}_p$ is related to $\\psi$ by $\\vec{B}_p = \\frac{1}{R} (\\nabla\\psi \\times \\hat{\\varphi})$, which gives its magnitude as $B_p = \\frac{|\\nabla\\psi|}{R}$.\n\nThe computational procedure involves two main steps: first, determining the path of integration (the flux surface contour), and second, evaluating the integral numerically along this path.\n\n**1. Contour Construction via Ray-Based Root Finding**\n\nThe integration path is the level set $\\psi(R,Z) = \\psi_t$. To obtain a discrete representation of this contour, we employ a ray-based root-finding method originating from the magnetic axis, given as $(R_0, Z_0)$. The magnetic axis is the extremum of the flux function, where $\\nabla\\psi=\\mathbf{0}$.\n\nThe procedure is as follows:\n- A set of $N_{\\theta} = 1024$ discrete angles, $\\theta_j = \\frac{2\\pi j}{N_{\\theta}}$ for $j \\in \\{0, 1, \\dots, N_{\\theta}-1\\}$, is defined.\n- For each angle $\\theta_j$, a ray is cast from the magnetic axis $(R_0, Z_0)$. A point on this ray at a distance $s$ is given by $(R(s), Z(s)) = (R_0 + s\\cos\\theta_j, Z_0 + s\\sin\\theta_j)$.\n- The goal is to find the distance $s^*$ along this ray where the flux function equals the target value $\\psi_t$. This requires solving the nonlinear scalar equation $g(s) = \\psi(R(s), Z(s)) - \\psi_t = 0$ for $s$.\n- To solve for $s^*$, we first bracket the root. Since $\\psi$ is at an extremum at $s=0$ (the magnetic axis), $g(0) = \\psi_{axis} - \\psi_t$ will be non-zero (typically negative). We search along the ray up to a maximum distance $s_{max}$ by evaluating $g(s)$ at a series of sample points. The first interval $[s_k, s_{k+1}]$ where $g(s_k) \\cdot g(s_{k+1}) < 0$ provides a bracket for the root.\n- With the root bracketed, a robust numerical method like bisection is used to find $s^*$ to a specified tolerance.\n- Repeating this for all $N_\\theta$ angles yields a set of $N_\\theta$ ordered points $\\{P_j = (R_j, Z_j)\\}_{j=0}^{N_\\theta-1}$ that discretize the flux surface contour.\n\n**2. Numerical Integration of the Safety Factor**\n\nWith the discrete contour points $\\{P_j\\}$, the line integral for $q(\\psi_t)$ is approximated as a sum over the $N_\\theta$ straight line segments connecting successive points. The integral is approximated using the midpoint rule for each segment, as specified.\n\nThe formula for the approximation is:\n$$\nq(\\psi_t) \\approx \\frac{1}{2\\pi} \\sum_{j=0}^{N_{\\theta}-1} \\left( \\frac{F(\\psi_t)}{R_{mid,j}^2 \\, B_{p,mid,j}} \\right) \\Delta l_{p,j}\n$$\nFor each segment from point $P_j=(R_j, Z_j)$ to $P_{j+1}=(R_{j+1}, Z_{j+1})$ (with $P_{N_\\theta} = P_0$):\n- The segment length is $\\Delta l_{p,j} = \\sqrt{(R_{j+1}-R_j)^2 + (Z_{j+1}-Z_j)^2}$.\n- The midpoint is $(R_{mid,j}, Z_{mid,j}) = \\left(\\frac{R_j+R_{j+1}}{2}, \\frac{Z_j+Z_{j+1}}{2}\\right)$.\n- The poloidal field magnitude $B_{p,mid,j}$ is evaluated at this midpoint. This requires the analytical gradient $\\nabla\\psi$:\n  $$B_{p,mid,j} = \\frac{\\left|\\nabla\\psi(R_{mid,j}, Z_{mid,j})\\right|}{R_{mid,j}}$$\n- The toroidal field function $F(\\psi_t)$ is constant for the given contour.\n\n**3. Numerical Stability near a Separatrix**\n\nA critical numerical challenge arises when a flux surface is near a separatrix, which contains one or more X-points. At an X-point, the poloidal magnetic field vanishes, i.e., $B_p=0$, because $\\nabla\\psi=\\mathbf{0}$ there. As a contour $\\psi = \\psi_t$ approaches a separatrix, the minimum value of $B_p$ along the contour, $\\min B_p$, approaches zero.\n\nThis behavior causes the integrand term $\\frac{1}{B_p}$ to diverge, leading to severe numerical instability and inaccurate results for the integral. To address this, a regularization strategy is required:\n- Before its use in the denominator, the computed $B_p$ value at each midpoint is floored at a small positive threshold, $\\epsilon_{B_p} = 10^{-6}$. The value used in the calculation is $B_{p,reg} = \\max(B_p, \\epsilon_{B_p})$.\n- This prevents division by zero or by an extremely small number, stabilizing the numerical integration.\n- The minimum *unregularized* value of $B_p$ encountered along the contour is tracked and reported as a diagnostic. A value of $\\min B_p$ close to $\\epsilon_{B_p}$ (or below it) is a strong indicator that the flux surface is near an X-point and that the regularization was activated. This diagnostic quantifies the \"stiffness\" of the problem. Test Case $4$ is specifically designed to exhibit this behavior.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import bisect\n\ndef solve():\n    \"\"\"\n    Main solver function to compute safety factor q for a series of test cases.\n    \"\"\"\n    \n    # Define numerical parameters\n    N_theta = 1024\n    s_max = 3.5\n    n_samples_brackening = 250  # >= 200 as required\n    eps_Bp = 1e-6\n\n    # Test Case 1: circular surfaces, constant F\n    A1, R01 = 0.8, 3.0\n    r1 = 0.5\n    psi1 = lambda R, Z: A1 * ((R - R01)**2 + Z**2)\n    grad_psi1 = lambda R, Z: np.array([2 * A1 * (R - R01), 2 * A1 * Z])\n    F1 = lambda psi: 6.0\n    psi_t1 = A1 * r1**2\n\n    # Test Case 2: larger circular radius, constant F\n    A2, R02 = 0.8, 3.0\n    r2 = 2.5\n    psi2 = lambda R, Z: A2 * ((R - R02)**2 + Z**2)\n    grad_psi2 = lambda R, Z: np.array([2 * A2 * (R - R02), 2 * A2 * Z])\n    F2 = lambda psi: 6.0\n    psi_t2 = A2 * r2**2\n\n    # Test Case 3: elliptical elongation, linear F\n    A3, kappa3, R03 = 0.6, 1.7, 3.0\n    F0_3, alpha3 = 5.0, 0.2\n    r3 = 1.2\n    psi3 = lambda R, Z: A3 * ((R - R03)**2 + (Z / kappa3)**2)\n    grad_psi3 = lambda R, Z: np.array([2 * A3 * (R - R03), 2 * A3 * Z / kappa3**2])\n    F3 = lambda psi: F0_3 + alpha3 * psi\n    psi_t3 = A3 * r3**2\n\n    # Test Case 4: near-separatrix distortion\n    A4, R04, Rx4, Zx4, sigma4, eps4 = 0.5, 3.0, 4.7, 0.0, 0.2, 0.35\n    F0_4 = 6.0\n    r4 = 1.7\n    exp_term4 = lambda R, Z: np.exp(-((R - Rx4)**2 + (Z - Zx4)**2) / sigma4**2)\n    psi4 = lambda R, Z: A4 * ((R - R04)**2 + Z**2) - eps4 * exp_term4(R, Z)\n    grad_psi4 = lambda R, Z: np.array([\n        2 * A4 * (R - R04) - eps4 * exp_term4(R, Z) * (-2 * (R - Rx4) / sigma4**2),\n        2 * A4 * Z           - eps4 * exp_term4(R, Z) * (-2 * (Z - Zx4) / sigma4**2)\n    ])\n    F4 = lambda psi: F0_4\n    psi_t4 = A4 * r4**2 - 0.5 * eps4\n    \n    test_cases = [\n        {'psi': psi1, 'grad_psi': grad_psi1, 'F': F1, 'psi_t': psi_t1, 'R0': R01, 'Z0': 0.0},\n        {'psi': psi2, 'grad_psi': grad_psi2, 'F': F2, 'psi_t': psi_t2, 'R0': R02, 'Z0': 0.0},\n        {'psi': psi3, 'grad_psi': grad_psi3, 'F': F3, 'psi_t': psi_t3, 'R0': R03, 'Z0': 0.0},\n        {'psi': psi4, 'grad_psi': grad_psi4, 'F': F4, 'psi_t': psi_t4, 'R0': R04, 'Z0': 0.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_q_and_min_bp(\n            case['psi'], case['grad_psi'], case['F'], case['psi_t'],\n            case['R0'], case['Z0'], N_theta, s_max, n_samples_brackening, eps_Bp\n        )\n        results.append(result)\n\n    # Format the final output string exactly as specified.\n    inner_results = [f\"[{r[0]},{r[1]}]\" for r in results]\n    final_output = f\"[{','.join(inner_results)}]\"\n    print(final_output)\n\ndef compute_q_and_min_bp(psi_func, grad_psi_func, F_func, psi_t, R0, Z0, N_theta, s_max, n_samples, eps_Bp):\n    \"\"\"\n    Computes the safety factor q and minimum poloidal field Bp on a flux surface.\n\n    Args:\n        psi_func: Function for psi(R, Z).\n        grad_psi_func: Function for the gradient of psi(R, Z).\n        F_func: Function for F(psi).\n        psi_t: Target psi level for the contour.\n        R0, Z0: Coordinates of the magnetic axis.\n        N_theta: Number of points on the contour.\n        s_max: Maximum search radius for root finding.\n        n_samples: Number of samples for bracketing the root.\n        eps_Bp: Regularization threshold for Bp.\n\n    Returns:\n        A list [q_value, min_Bp_value].\n    \"\"\"\n    # 1. Construct the contour\n    angles = np.linspace(0, 2 * np.pi, N_theta, endpoint=False)\n    contour_points = np.zeros((N_theta, 2))\n\n    for i, theta in enumerate(angles):\n        cos_theta = np.cos(theta)\n        sin_theta = np.sin(theta)\n\n        # Define the function whose root we want to find along the ray\n        g = lambda s: psi_func(R0 + s * cos_theta, Z0 + s * sin_theta) - psi_t\n\n        # Bracket the root\n        s_vals = np.linspace(0, s_max, n_samples + 1)\n        g_vals = np.array([g(s) for s in s_vals])\n        \n        root_bracket = None\n        for j in range(n_samples):\n            if g_vals[j] * g_vals[j+1] < 0:\n                root_bracket = (s_vals[j], s_vals[j+1])\n                break\n        \n        if root_bracket is None:\n            raise RuntimeError(f\"Root not bracketed for theta={theta}. Increase s_max or sample density.\")\n        \n        # Find the root using bisection\n        s_root = bisect(g, root_bracket[0], root_bracket[1])\n        contour_points[i] = [R0 + s_root * cos_theta, Z0 + s_root * sin_theta]\n\n    # 2. Perform numerical integration\n    q_integral = 0.0\n    min_Bp = np.inf\n    F_val = F_func(psi_t)\n\n    for i in range(N_theta):\n        p1 = contour_points[i]\n        p2 = contour_points[(i + 1) % N_theta]  # Wrap around for the last segment\n        \n        R1, Z1 = p1\n        R2, Z2 = p2\n\n        # Midpoint of the segment\n        R_mid, Z_mid = (R1 + R2) / 2, (Z1 + Z2) / 2\n        \n        # Length of the segment\n        dl_p = np.sqrt((R2 - R1)**2 + (Z2 - Z1)**2)\n        \n        # Calculate poloidal field Bp at the midpoint\n        grad = grad_psi_func(R_mid, Z_mid)\n        norm_grad = np.sqrt(grad[0]**2 + grad[1]**2)\n        \n        if R_mid <= 0: # Safety check, should not happen in these cases\n             Bp = np.inf\n        else:\n             Bp = norm_grad / R_mid\n\n        # Update the minimum Bp found so far\n        min_Bp = min(min_Bp, Bp)\n        \n        # Regularize Bp to avoid division by zero\n        Bp_reg = max(Bp, eps_Bp)\n        \n        # Add the contribution of the segment to the integral\n        integrand = F_val / (R_mid**2 * Bp_reg)\n        q_integral += integrand * dl_p\n        \n    q_value = q_integral / (2 * np.pi)\n    \n    return [q_value, min_Bp]\n\nsolve()\n```"
        }
    ]
}