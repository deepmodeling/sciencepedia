{
    "hands_on_practices": [
        {
            "introduction": "任何偏微分方程求解器的核心在于其对微分算子的离散化。这项实践将指导您为 Grad-Shafranov 算子 $\\Delta^\\star$ 推导一个二阶精度的有限差分格式，特别关注如何以守恒的方式处理与径向坐标 $R$ 相关的项。通过对照解析解进行代码验证，您将掌握验证数值算子准确性的基本技能 。",
            "id": "3986297",
            "problem": "考虑用于计算聚变科学与工程中 Grad–Shafranov 方程固定边界求解器的轴对称磁静力学平衡。从磁静力学的基本定律出发，即安培定律 $\\nabla \\times \\mathbf{B} = \\mu_{0}\\mathbf{J}$ 和磁高斯定律 $\\nabla \\cdot \\mathbf{B} = 0$，结合磁流体力学力平衡方程 $\\mathbf{J} \\times \\mathbf{B} = \\nabla p$，以及在柱坐标 $(R,\\phi,Z)$ 中无环向变化的磁场的轴对称表示。基于这些基本原理和柱坐标微分算子的标准定义，可以推导出一个关于极向磁通函数 $\\psi(R,Z)$ 的椭圆型偏微分方程（PDE），其中一个线性自伴算子作用于 $\\psi(R,Z)$。\n\n你的任务是，在一个均匀的 $(R,Z)$ 网格上，为这个作用于 $\\psi(R,Z)$ 的线性算子推导一个二阶精度的有限差分格式。特别地，该算子包含一个形式为 $R \\,\\partial/\\partial R$ 的加权径向导数，作用于一个包含因子 $1/R$ 的量。你必须清楚地表述如何在一个均匀网格上，使用面心权重以保守且二阶精度的方式来近似这个径向部分。然后，通过加入具有二阶精度的 $Z$ 方向轴向部分，来完成这个二维格式。\n\n在符号上推导出该格式后，在一个程序中实现它，并通过与解析解的比较来验证其二阶精度。使用一个均匀的张量积网格，在 $R$ 方向有 $N_{R}$ 个点，在 $Z$ 方向有 $N_{Z}$ 个点（包括边界）。设网格节点为 $R_{i}$（$i = 0,\\dots,N_{R}-1$）和 $Z_{j}$（$j = 0,\\dots,N_{Z}-1$），间距分别为 $\\Delta R = (R_{\\max}-R_{\\min})/(N_{R}-1)$ 和 $\\Delta Z = (Z_{\\max}-Z_{\\min})/(N_{Z}-1)$。通过在边界上计算精确解析解 $\\psi(R,Z)$ 来施加固定的（狄利克雷）边界值。你的内部格式仅应用于索引 $i=1,\\dots,N_{R}-2$ 和 $j=1,\\dots,N_{Z}-2$。三角函数中的所有角度都必须以弧度为单位。所有量都是无量纲的，因此报告的误差也应为无量纲数。\n\n使用以下参数值测试套件。对于每种情况，计算最大范数误差 $E_{\\infty}$，其定义为你的离散算子应用于 $\\psi$ 的结果与在内部节点上计算的精确解析算子之间的最大绝对差。\n\n- 测试用例 1（加权径向项的零空间检验）：\n  - 定义域：$R \\in [0.8,\\,1.2]$，$Z \\in [-0.5,\\,0.5]$。\n  - 分辨率：$N_{R} = 33$，$N_{Z} = 33$。\n  - 解析场：$\\psi(R,Z) = \\tfrac{1}{2} R^{2}$。\n- 测试用例 2（中等网格上的多项式）：\n  - 定义域：$R \\in [1.0,\\,2.0]$，$Z \\in [-1.0,\\,1.0]$。\n  - 分辨率：$N_{R} = 33$，$N_{Z} = 33$。\n  - 解析场：$\\psi(R,Z) = R^{4} + Z^{4} + R^{2} Z$。\n- 测试用例 3（细化网格上的多项式以评估收敛性）：\n  - 定义域：$R \\in [1.0,\\,2.0]$，$Z \\in [-1.0,\\,1.0]$。\n  - 分辨率：$N_{R} = 65$，$N_{Z} = 65$。\n  - 解析场：$\\psi(R,Z) = R^{4} + Z^{4} + R^{2} Z$。\n- 测试用例 4（较小 $R$ 值域上的三角-双曲场）：\n  - 定义域：$R \\in [0.2,\\,0.9]$，$Z \\in [-0.3,\\,0.3]$。\n  - 分辨率：$N_{R} = 49$，$N_{Z} = 49$。\n  - 解析场：$\\psi(R,Z) = \\sin(R)\\,\\cosh(Z)$。\n- 测试用例 5（测试用例 4 的细化）：\n  - 定义域：$R \\in [0.2,\\,0.9]$，$Z \\in [-0.3,\\,0.3]$。\n  - 分辨率：$N_{R} = 97$，$N_{Z} = 97$。\n  - 解析场：$\\psi(R,Z) = \\sin(R)\\,\\cosh(Z)$。\n\n你的程序必须：\n- 为每个测试用例构建网格，从解析解 $\\psi(R,Z)$ 计算边界数据，在内部节点上应用推导的二阶格式，并为每种情况计算 $E_{\\infty}$。\n- 最终输出必须是一行包含五个 $E_{\\infty}$ 值的 Python 风格列表，按测试用例的顺序排列，不含任何额外文本。例如，输出必须形如 $[e_{1},e_{2},e_{3},e_{4},e_{5}]$，其中每个 $e_{k}$ 是一个浮点数。",
            "solution": "该问题要求为 Grad–Shafranov 方程中的线性算子推导一个二阶精度的有限差分格式，并随后通过编程实现来验证其精度。\n\n### Grad–Shafranov 算子的推导\n\n我们从等离子体中的磁静力学基本方程开始，假设为静态平衡（$\\partial/\\partial t = 0$）：\n1.  安培定律：$\\nabla \\times \\mathbf{B} = \\mu_0 \\mathbf{J}$\n2.  磁高斯定律：$\\nabla \\cdot \\mathbf{B} = 0$\n3.  力平衡：$\\mathbf{J} \\times \\mathbf{B} = \\nabla p$\n\n我们在柱坐标系 $(R, \\phi, Z)$ 中进行分析，并假设轴对称性，这意味着所有物理量都与环向角 $\\phi$ 无关，即 $\\partial/\\partial\\phi = 0$。\n\n根据 $\\nabla \\cdot \\mathbf{B} = 0$，磁场 $\\mathbf{B}$ 可以表示为矢量势 $\\mathbf{A}$ 的旋度。对于轴对称系统，可以方便地定义极向磁通函数 $\\psi(R,Z)$，使得磁场的极向分量由下式给出：\n$$ \\mathbf{B}_p = B_R \\hat{R} + B_Z \\hat{Z} = \\frac{1}{R} \\nabla\\psi \\times \\hat{\\phi} $$\n展开此定义，我们得到以下分量：\n$$ B_R(R,Z) = -\\frac{1}{R}\\frac{\\partial\\psi}{\\partial Z} \\quad \\text{和} \\quad B_Z(R,Z) = \\frac{1}{R}\\frac{\\partial\\psi}{\\partial R} $$\n这种形式自动满足高斯定律的极向部分，$\\nabla \\cdot \\mathbf{B}_p = \\frac{1}{R}\\frac{\\partial}{\\partial R}(R B_R) + \\frac{\\partial B_Z}{\\partial Z} = 0$。完整的磁场还包括一个环向分量，$\\mathbf{B} = \\mathbf{B}_p + B_\\phi(R,Z)\\hat{\\phi}$。\n\n接下来，我们使用安培定律将磁场与电流密度 $\\mathbf{J}$ 联系起来。电流密度的环向分量 $J_\\phi$ 与极向磁场相关：\n$$ \\mu_0 J_\\phi = (\\nabla \\times \\mathbf{B}_p) \\cdot \\hat{\\phi} = \\frac{\\partial B_R}{\\partial Z} - \\frac{\\partial B_Z}{\\partial R} $$\n将以 $\\psi$ 表示的 $B_R$ 和 $B_Z$ 的表达式代入：\n$$ \\mu_0 J_\\phi = \\frac{\\partial}{\\partial Z}\\left(-\\frac{1}{R}\\frac{\\partial\\psi}{\\partial Z}\\right) - \\frac{\\partial}{\\partial R}\\left(\\frac{1}{R}\\frac{\\partial\\psi}{\\partial R}\\right) $$\n$$ \\mu_0 J_\\phi = -\\frac{1}{R}\\frac{\\partial^2\\psi}{\\partial Z^2} - \\left(-\\frac{1}{R^2}\\frac{\\partial\\psi}{\\partial R} + \\frac{1}{R}\\frac{\\partial^2\\psi}{\\partial R^2}\\right) = -\\frac{1}{R}\\left(\\frac{\\partial^2\\psi}{\\partial R^2} - \\frac{1}{R}\\frac{\\partial\\psi}{\\partial R} + \\frac{\\partial^2\\psi}{\\partial Z^2}\\right) $$\n此表达式定义了 Grad–Shafranov 算子，记为 $\\Delta^*$：\n$$ \\Delta^*\\psi \\equiv \\frac{\\partial^2\\psi}{\\partial R^2} - \\frac{1}{R}\\frac{\\partial\\psi}{\\partial R} + \\frac{\\partial^2\\psi}{\\partial Z^2} $$\n力平衡方程将此与压强 $p$ 和环向场函数 $F(\\psi) = R B_\\phi$ 联系起来，从而得出完整的 Grad–Shafranov 方程 $\\Delta^*\\psi = - \\mu_0 R^2 \\frac{dp}{d\\psi} - F \\frac{dF}{d\\psi}$。当前的任务是离散化作用于 $\\psi$ 的线性微分算子 $\\Delta^*$。为了得到一个保守的有限差分形式，最好将算子写成其自伴形式，正如问题陈述所建议的：\n$$ \\Delta^*\\psi = R\\frac{\\partial}{\\partial R}\\left(\\frac{1}{R}\\frac{\\partial\\psi}{\\partial R}\\right) + \\frac{\\partial^2\\psi}{\\partial Z^2} $$\n这就是我们将要离散化的算子。\n\n### 有限差分格式的推导\n\n我们考虑一个均匀的张量积网格，其节点为 $(R_i, Z_j)$，其中 $R_i = R_{\\min} + i\\Delta R$（$i=0, \\dots, N_R-1$），$Z_j = Z_{\\min} + j\\Delta Z$（$j=0, \\dots, N_Z-1$）。网格间距为 $\\Delta R = (R_{\\max}-R_{\\min})/(N_R-1)$ 和 $\\Delta Z = (Z_{\\max}-Z_{\\min})/(N_Z-1)$。令 $\\psi_{i,j} = \\psi(R_i, Z_j)$。\n\n离散化在内部网格节点 $(i,j)$ 上进行，其中 $1 \\le i \\le N_R-2$ 且 $1 \\le j \\le N_Z-2$。\n\n**轴向部分：** 关于 $Z$ 的二阶偏导数使用标准的二阶中心差分公式来近似：\n$$ \\left. \\frac{\\partial^2\\psi}{\\partial Z^2} \\right|_{i,j} \\approx \\frac{\\psi_{i,j+1} - 2\\psi_{i,j} + \\psi_{i,j-1}}{(\\Delta Z)^2} $$\n\n**径向部分：** 算子的径向部分为 $L_R\\psi = R\\frac{\\partial}{\\partial R}\\left(\\frac{1}{R}\\frac{\\partial\\psi}{\\partial R}\\right)$。为实现保守且二阶精度的离散化，我们采用一种“面心”或类似有限体积的方法。令径向通量为 $F_R(R) = \\frac{1}{R}\\frac{\\partial\\psi}{\\partial R}$。在 $R_i$ 处的算子为 $R_i \\frac{\\partial F_R}{\\partial R}|_{R_i}$。我们使用位于半整数网格索引 $R_{i\\pm 1/2} = R_i \\pm \\Delta R/2$ 处的单元面上的中心差分来近似通量的导数：\n$$ \\left. \\frac{\\partial F_R}{\\partial R} \\right|_{R_i} \\approx \\frac{F_R(R_{i+1/2}) - F_R(R_{i-1/2})}{\\Delta R} $$\n在这些面心处的通量 $F_R$ 本身也使用关于 $\\psi$ 导数的二阶中心差分来近似：\n$$ F_R(R_{i+1/2}) = \\left. \\frac{1}{R}\\frac{\\partial\\psi}{\\partial R} \\right|_{R_{i+1/2}} \\approx \\frac{1}{R_{i+1/2}} \\frac{\\psi_{i+1,j} - \\psi_{i,j}}{\\Delta R} $$\n$$ F_R(R_{i-1/2}) = \\left. \\frac{1}{R}\\frac{\\partial\\psi}{\\partial R} \\right|_{R_{i-1/2}} \\approx \\frac{1}{R_{i-1/2}} \\frac{\\psi_{i,j} - \\psi_{i-1,j}}{\\Delta R} $$\n将这些代入算子表达式中，离散径向算子 $(L_R\\psi)_{i,j}$ 变为：\n$$ (L_R\\psi)_{i,j} \\approx R_i \\frac{1}{\\Delta R} \\left( \\frac{1}{R_{i+1/2}} \\frac{\\psi_{i+1,j} - \\psi_{i,j}}{\\Delta R} - \\frac{1}{R_{i-1/2}} \\frac{\\psi_{i,j} - \\psi_{i-1,j}}{\\Delta R} \\right) $$\n$$ (L_R\\psi)_{i,j} \\approx \\frac{R_i}{(\\Delta R)^2} \\left[ \\frac{1}{R_{i-1/2}}\\psi_{i-1,j} - \\left(\\frac{1}{R_{i+1/2}} + \\frac{1}{R_{i-1/2}}\\right)\\psi_{i,j} + \\frac{1}{R_{i+1/2}}\\psi_{i+1,j} \\right] $$\n其中 $R_{i\\pm 1/2} = R_i \\pm \\Delta R/2$。\n\n**完整格式：** 结合径向和轴向部分，我们得到 $(\\Delta^*\\psi)_{i,j}$ 的完整 5 点格式：\n$$ (\\Delta^*\\psi)_{i,j} \\approx \\frac{R_i}{(\\Delta R)^2} \\left[ \\frac{\\psi_{i-1,j}}{R_i-\\frac{\\Delta R}{2}} - \\left(\\frac{1}{R_i+\\frac{\\Delta R}{2}} + \\frac{1}{R_i-\\frac{\\Delta R}{2}}\\right)\\psi_{i,j} + \\frac{\\psi_{i+1,j}}{R_i+\\frac{\\Delta R}{2}} \\right] + \\frac{\\psi_{i,j-1} - 2\\psi_{i,j} + \\psi_{i,j+1}}{(\\Delta Z)^2} $$\n该格式在 $\\Delta R$ 和 $\\Delta Z$ 上均具有二阶精度。\n\n### 验证与实现\n\n为了验证二阶精度，我们将此离散算子应用于已知的解析函数 $\\psi(R,Z)$，并将其结果与 $\\Delta^*\\psi$ 的精确解析计算值进行比较。在所有内部网格点上计算最大范数误差 $E_{\\infty}$：\n$$ E_{\\infty} = \\max_{1\\le i \\le N_R-2, 1\\le j \\le N_Z-2} \\left| (\\Delta^*\\psi)_{i,j}^{\\text{numerical}} - (\\Delta^*\\psi)(R_i,Z_j)^{\\text{analytic}} \\right| $$\n所提供的测试用例可用于检验径向算子的零空间性质并评估收敛率，收敛率应为二次的（$E_{\\infty} \\propto (\\Delta R)^2, (\\Delta Z)^2$）。对于网格分辨率加倍的成对测试用例，误差预计将减少约 4 倍。\n实现将遵循推导出的格式，将其应用于域的内部，而 $\\psi$ 值的整个网格（包括边界）则由给定的解析函数计算得出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef apply_operator(psi, R, Z):\n    \"\"\"\n    Applies the discretized Grad-Shafranov operator Delta* to a function psi.\n\n    Args:\n        psi (np.ndarray): 2D array of psi values on the (R, Z) grid.\n        R (np.ndarray): 1D array of R-coordinates.\n        Z (np.ndarray): 1D array of Z-coordinates.\n\n    Returns:\n        np.ndarray: 2D array of the operator applied to psi.\n    \"\"\"\n    N_R, N_Z = psi.shape\n    if N_R  3 or N_Z  3:\n        return np.zeros_like(psi)\n\n    delta_R = R[1] - R[0]\n    delta_Z = Z[1] - Z[0]\n    \n    L_psi = np.zeros_like(psi)\n\n    # Vectorized computation for interior points\n    # psi slices for stencil\n    psi_mid = psi[1:-1, 1:-1]\n    psi_im1 = psi[:-2, 1:-1]\n    psi_ip1 = psi[2:, 1:-1]\n    psi_jm1 = psi[1:-1, :-2]\n    psi_jp1 = psi[1:-1, 2:]\n\n    # R-coordinates for interior points and faces\n    R_int = R[1:-1]\n    R_face_m = R_int - delta_R / 2.0\n    R_face_p = R_int + delta_R / 2.0\n\n    # Reshape R arrays for broadcasting\n    R_int_col = R_int[:, np.newaxis]\n    R_face_m_col = R_face_m[:, np.newaxis]\n    R_face_p_col = R_face_p[:, np.newaxis]\n\n    # Radial part of the operator\n    # Note: A check for R_face_m_col == 0 is needed if R_min=0 and N_R is even,\n    # but the test cases avoid this.\n    term_im1 = psi_im1 / R_face_m_col\n    term_ip1 = psi_ip1 / R_face_p_col\n    term_i = -(1.0/R_face_p_col + 1.0/R_face_m_col) * psi_mid\n    L_R_psi = (R_int_col / (delta_R**2)) * (term_im1 + term_i + term_ip1)\n\n    # Axial part of the operator\n    L_Z_psi = (psi_jp1 - 2.0 * psi_mid + psi_jm1) / (delta_Z**2)\n\n    # Combine parts and store in the interior of the result matrix\n    L_psi[1:-1, 1:-1] = L_R_psi + L_Z_psi\n\n    return L_psi\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute errors.\n    \"\"\"\n    test_cases = [\n        {\n            \"domain\": (0.8, 1.2, -0.5, 0.5),\n            \"resolution\": (33, 33),\n            \"psi_func\": lambda R, Z: 0.5 * R**2,\n            \"L_psi_func\": lambda R, Z: np.zeros_like(R),\n        },\n        {\n            \"domain\": (1.0, 2.0, -1.0, 1.0),\n            \"resolution\": (33, 33),\n            \"psi_func\": lambda R, Z: R**4 + Z**4 + R**2 * Z,\n            \"L_psi_func\": lambda R, Z: 8.0 * R**2 + 12.0 * Z**2,\n        },\n        {\n            \"domain\": (1.0, 2.0, -1.0, 1.0),\n            \"resolution\": (65, 65),\n            \"psi_func\": lambda R, Z: R**4 + Z**4 + R**2 * Z,\n            \"L_psi_func\": lambda R, Z: 8.0 * R**2 + 12.0 * Z**2,\n        },\n        {\n            \"domain\": (0.2, 0.9, -0.3, 0.3),\n            \"resolution\": (49, 49),\n            \"psi_func\": lambda R, Z: np.sin(R) * np.cosh(Z),\n            \"L_psi_func\": lambda R, Z: -np.cos(R) * np.cosh(Z) / R,\n        },\n        {\n            \"domain\": (0.2, 0.9, -0.3, 0.3),\n            \"resolution\": (97, 97),\n            \"psi_func\": lambda R, Z: np.sin(R) * np.cosh(Z),\n            \"L_psi_func\": lambda R, Z: -np.cos(R) * np.cosh(Z) / R,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        R_min, R_max, Z_min, Z_max = case[\"domain\"]\n        N_R, N_Z = case[\"resolution\"]\n        psi_func = case[\"psi_func\"]\n        L_psi_func = case[\"L_psi_func\"]\n\n        # 1. Construct the grid\n        R_coords = np.linspace(R_min, R_max, N_R)\n        Z_coords = np.linspace(Z_min, Z_max, N_Z)\n        R_grid, Z_grid = np.meshgrid(R_coords, Z_coords, indexing='ij')\n\n        # 2. Evaluate analytic psi on the grid\n        psi_analytic = psi_func(R_grid, Z_grid)\n\n        # 3. Apply the discrete operator\n        L_psi_numerical = apply_operator(psi_analytic, R_coords, Z_coords)\n\n        # 4. Evaluate the exact analytic operator\n        L_psi_analytic = L_psi_func(R_grid, Z_grid)\n\n        # 5. Compute the maximum-norm error on the interior\n        error_matrix = L_psi_numerical - L_psi_analytic\n        interior_error = error_matrix[1:-1, 1:-1]\n        E_inf = np.max(np.abs(interior_error))\n        \n        results.append(E_inf)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在开发复杂的科学计算代码时，确保其正确性至关重要。“人造解方法”（Method of Manufactured Solutions）是一种强大的代码验证技术，它通过预设一个解析解来反向推导源项，从而构造一个我们已知精确解的测试问题。在此实践中 ，您将为一个特定的人造解 $\\psi(R,Z)$ 推导相容的等离子体压力 $p(\\psi)$ 和环向场函数 $F(\\psi)$，以验证 Grad-Shafranov 方程求解器的完整实现。",
            "id": "3986305",
            "problem": "考虑磁流体力学 (MHD) 中的一个轴对称等离子体平衡，采用柱坐标 $(R,\\phi,Z)$，且物理量不依赖于环向角 $\\phi$。设极向磁通函数为 $\\psi(R,Z)$，等离子体压强为 $p(\\psi)$，环向场函数为 $F(\\psi) = R B_{\\phi}$，其中 $B_{\\phi}$ 是环向磁场。Grad–Shafranov 方程是在此类轴对称系统中静力平衡以及与麦克斯韦方程组相容的条件，可以写成如下算子形式\n$$\n\\Delta^{\\star} \\psi = - \\mu_0 R^2 \\frac{dp}{d\\psi} - \\frac{1}{2} \\frac{d(F^2)}{d\\psi},\n$$\n其中 $\\mu_0$ 是磁导率，Grad–Shafranov 算子为\n$$\n\\Delta^{\\star} \\psi \\equiv R \\frac{\\partial}{\\partial R} \\left( \\frac{1}{R} \\frac{\\partial \\psi}{\\partial R} \\right) + \\frac{\\partial^2 \\psi}{\\partial Z^2}.\n$$\n在固定边界求解器中，区域边界是预先设定的，通过确保对于协调的 $p(\\psi)$ 和 $F(\\psi)$ 函数选择，Grad–Shafranov 方程的残差在整个区域内为零，来验证一个平衡。\n\n您的任务是使用人工解方法，在一个 $\\mu_0 = 1$ 的无量纲公式中，构建一个适用于程序验证的解析平衡。具体而言：\n\n1. 选择解析磁通\n$$\n\\psi(R,Z) = k R^4 + m Z^2 + \\psi_0,\n$$\n其中 $k$、$m$ 和 $\\psi_0$ 为常数。\n\n2. 从 $\\Delta^{\\star}$ 的定义出发，计算所选 $\\psi(R,Z)$ 的 $\\Delta^{\\star}\\psi$，然后推断出函数 $p(\\psi)$ 和 $F(\\psi)$ (等价于 $F^2(\\psi)$)，使得 Grad–Shafranov 方程在区域内逐点成立。您必须明确地表示出 $p(\\psi)$ 和 $F^2(\\psi)$，并确保 $\\frac{dp}{d\\psi}$ 和 $\\frac{d(F^2)}{d\\psi}$ 仅依赖于 $\\psi$，正如物理学所要求的那样。\n\n3. 实现一个程序，在一个 $R$ 方向有 $N_R$ 个点、$Z$ 方向有 $N_Z$ 个点的均匀网格上，计算矩形区域\n$$\n\\Omega = \\{ (R,Z) \\mid R \\in [R_{\\min}, R_{\\max}],\\, Z \\in [-Z_{\\max}, Z_{\\max}] \\},\n$$\n上的最大绝对残差\n$$\n\\mathcal{R}_{\\max} = \\max_{(R,Z) \\in \\Omega} \\left| \\Delta^{\\star}\\psi + R^2 \\frac{dp}{d\\psi} + \\frac{1}{2} \\frac{d(F^2)}{d\\psi} \\right|\n$$\n\n4. 使用以下均为无量纲的参数测试套件，在每种情况下计算 $\\mathcal{R}_{\\max}$：\n- 情况 1：$k = 0.25$, $m = 0.75$, $\\psi_0 = 0$, $R_{\\min} = 1$, $R_{\\max} = 3$, $Z_{\\max} = 1$, $N_R = 101$, $N_Z = 101$, $p_0 = 0$, $f_0 = 10$。\n- 情况 2：$k = 0$, $m = 0.5$, $\\psi_0 = 0$, $R_{\\min} = 1$, $R_{\\max} = 3$, $Z_{\\max} = 1$, $N_R = 101$, $N_Z = 101$, $p_0 = 0$, $f_0 = 10$。\n- 情况 3：$k = -0.125$, $m = 0.3$, $\\psi_0 = 0$, $R_{\\min} = 1$, $R_{\\max} = 3$, $Z_{\\max} = 1$, $N_R = 101$, $N_Z = 101$, $p_0 = 0$, $f_0 = 10$。\n- 情况 4：$k = 0.2$, $m = -0.4$, $\\psi_0 = 0$, $R_{\\min} = 1$, $R_{\\max} = 3$, $Z_{\\max} = 1$, $N_R = 101$, $N_Z = 101$, $p_0 = 0$, $f_0 = 10$。\n\n常数 $p_0$ 和 $f_0$ 是 $p(\\psi)$ 和 $F^2(\\psi)$ 的任意偏移量，它们不影响残差，因为方程中只出现关于 $\\psi$ 的导数。包含它们是为了完整性。\n\n您的程序应产生单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[r_1,r_2,r_3,r_4]$），其中 $r_i$ 是测试套件中第 $i$ 种情况下计算出的 $\\mathcal{R}_{\\max}$（一个浮点数）。此问题中不涉及角度，并且所有量根据构造都是无量纲的；因此，输出中不需要单位。",
            "solution": "用户希望我解决一个关于 Grad-Shafranov 方程的问题。\n\n### 问题验证\n\n#### 第 1 步：提取已知条件\n\n-   **控制方程 (Grad–Shafranov)**:\n    $$\n    \\Delta^{\\star} \\psi = - \\mu_0 R^2 \\frac{dp}{d\\psi} - \\frac{1}{2} \\frac{d(F^2)}{d\\psi}\n    $$\n-   **Grad–Shafranov 算子**:\n    $$\n    \\Delta^{\\star} \\psi \\equiv R \\frac{\\partial}{\\partial R} \\left( \\frac{1}{R} \\frac{\\partial \\psi}{\\partial R} \\right) + \\frac{\\partial^2 \\psi}{\\partial Z^2}\n    $$\n-   **定义**:\n    -   $\\psi(R,Z)$: 极向磁通函数。\n    -   $p(\\psi)$: 等离子体压强。\n    -   $F(\\psi) = R B_{\\phi}$: 环向场函数。\n    -   $(R,\\phi,Z)$: 柱坐标。\n-   **假设/条件**:\n    -   轴对称平衡 ($\\partial/\\partial\\phi = 0$)。\n    -   静力平衡。\n    -   无量纲公式，磁导率 $\\mu_0 = 1$。\n-   **人工解形式**:\n    $$\n    \\psi(R,Z) = k R^4 + m Z^2 + \\psi_0\n    $$\n-   **任务**:\n    1.  对于给定的 $\\psi(R,Z)$，计算 $\\Delta^{\\star}\\psi$。\n    2.  推断函数 $p(\\psi)$ 和 $F^2(\\psi)$，以满足 Grad–Shafranov 方程。\n    3.  实现一个程序，用于在指定区域 $\\Omega$ 上计算最大绝对残差 $\\mathcal{R}_{\\max}$。\n-   **残差定义**:\n    $$\n    \\mathcal{R}_{\\max} = \\max_{(R,Z) \\in \\Omega} \\left| \\Delta^{\\star}\\psi + R^2 \\frac{dp}{d\\psi} + \\frac{1}{2} \\frac{d(F^2)}{d\\psi} \\right|\n    $$\n-   **区域**:\n    $$\n    \\Omega = \\{ (R,Z) \\mid R \\in [R_{\\min}, R_{\\max}],\\, Z \\in [-Z_{\\max}, Z_{\\max}] \\}\n    $$\n-   **网格**: $R$ 方向有 $N_R$ 个点、$Z$ 方向有 $N_Z$ 个点的均匀网格。\n-   **测试套件**:\n    -   **情况 1**: $k = 0.25$, $m = 0.75$, $\\psi_0 = 0$, $R_{\\min} = 1$, $R_{\\max} = 3$, $Z_{\\max} = 1$, $N_R = 101$, $N_Z = 101$, $p_0 = 0$, $f_0 = 10$。\n    -   **情况 2**: $k = 0$, $m = 0.5$, $\\psi_0 = 0$, $R_{\\min} = 1$, $R_{\\max} = 3$, $Z_{\\max} = 1$, $N_R = 101$, $N_Z = 101$, $p_0 = 0$, $f_0 = 10$。\n    -   **情况 3**: $k = -0.125$, $m = 0.3$, $\\psi_0 = 0$, $R_{\\min} = 1$, $R_{\\max} = 3$, $Z_{\\max} = 1$, $N_R = 101$, $N_Z = 101$, $p_0 = 0$, $f_0 = 10$。\n    -   **情况 4**: $k = 0.2$, $m = -0.4$, $\\psi_0 = 0$, $R_{\\min} = 1$, $R_{\\max} = 3$, $Z_{\\max} = 1$, $N_R = 101$, $N_Z = 101$, $p_0 = 0$, $f_0 = 10$。\n\n#### 第 2 步：使用提取的已知条件进行验证\n\n-   **科学基础**：该问题基于 Grad–Shafranov 方程，这是描述托卡马克平衡的磁流体力学 (MHD) 的基石。人工解方法是计算科学与工程中用于验证数值程序的标准、严谨的技术。所有要素都牢固地植根于成熟的等离子体物理和数值分析。\n-   **适定性**：该问题是构造性的且定义明确。它要求首先为给定的解形式推导解析源项，然后计算控制方程的残差。这个过程保证有唯一且稳定的解（解析上，残差为零）。\n-   **客观性**：该问题使用精确的数学定义进行陈述，并提供了用于评估的客观数值参数。没有主观或模糊的语言。\n-   **完整性与一致性**：所有必要的方程、边界条件（以指定区域的形式）、函数形式和参数都已提供。$\\frac{dp}{d\\psi}$ 和 $\\frac{d(F^2)}{d\\psi}$ 仅依赖于 $\\psi$ 的要求是一个关键的物理约束，所提出的步骤可以一致地满足这一约束。该问题是自洽的，没有矛盾。包含常数 $p_0$ 和 $f_0$ 被正确地指出与残差计算无关，这与物理学一致。\n\n#### 第 3 步：结论与行动\n\n该问题是有效的。这是一个将人工解方法应用于 Grad-Shafranov 方程的适定且科学上合理的练习。\n\n### 解题推导\n\n目标是找到源函数 $p(\\psi)$ 和 $F(\\psi)$，使其对于预设的 $\\psi(R,Z)$ 解析形式满足 Grad-Shafranov 方程。这个人工解随后提供了一个已知精确解的测试案例，通过检查数值求解器是否能恢复此解且残差接近机器精度，从而可以验证该求解器。\n\n设无量纲 Grad-Shafranov 方程为\n$$\n\\Delta^{\\star} \\psi = - R^2 \\frac{dp}{d\\psi} - \\frac{1}{2} \\frac{d(F^2)}{d\\psi}\n$$\n算子为\n$$\n\\Delta^{\\star} \\psi \\equiv R \\frac{\\partial}{\\partial R} \\left( \\frac{1}{R} \\frac{\\partial \\psi}{\\partial R} \\right) + \\frac{\\partial^2 \\psi}{\\partial Z^2}\n$$\n预设的解析磁通函数为\n$$\n\\psi(R,Z) = k R^4 + m Z^2 + \\psi_0\n$$\n\n首先，我们通过计算必要的偏导数来计算左侧的 $\\Delta^{\\star}\\psi$。\n关于 $R$ 的偏导数为：\n$$\n\\frac{\\partial \\psi}{\\partial R} = 4k R^3\n$$\n除以 $R$：\n$$\n\\frac{1}{R} \\frac{\\partial \\psi}{\\partial R} = 4k R^2\n$$\n再次对 $R$ 求导：\n$$\n\\frac{\\partial}{\\partial R} \\left( \\frac{1}{R} \\frac{\\partial \\psi}{\\partial R} \\right) = \\frac{\\partial}{\\partial R} (4k R^2) = 8k R\n$$\n乘以 $R$ 得到算子的第一项：\n$$\nR \\frac{\\partial}{\\partial R} \\left( \\frac{1}{R} \\frac{\\partial \\psi}{\\partial R} \\right) = R (8k R) = 8k R^2\n$$\n接下来，我们计算关于 $Z$ 的偏导数：\n$$\n\\frac{\\partial \\psi}{\\partial Z} = 2m Z\n$$\n$$\n\\frac{\\partial^2 \\psi}{\\partial Z^2} = 2m\n$$\n结合这些结果，我们得到 $\\Delta^{\\star}\\psi$ 的表达式：\n$$\n\\Delta^{\\star}\\psi = 8k R^2 + 2m\n$$\n现在，我们将此结果代入 Grad-Shafranov 方程：\n$$\n8k R^2 + 2m = - R^2 \\frac{dp}{d\\psi} - \\frac{1}{2} \\frac{d(F^2)}{d\\psi}\n$$\n为了满足源项 $\\frac{dp}{d\\psi}$ 和 $\\frac{d(F^2)}{d\\psi}$ 必须仅为 $\\psi$ 的函数（从而与显式的 $(R,Z)$ 坐标无关）这一物理约束，我们可以通过对包含和不包含 $R^2$ 的项进行分组来重新排列方程：\n$$\n\\left( 8k + \\frac{dp}{d\\psi} \\right) R^2 + \\left( 2m + \\frac{1}{2} \\frac{d(F^2)}{d\\psi} \\right) = 0\n$$\n为了使该方程在区域内对所有 $R$ 和 $Z$ 值都成立，$R$ 的幂次（本例中为 $R^2$ 和 $R^0$）的系数必须独立地为零。这产生了一个包含两个方程的方程组：\n$$\n8k + \\frac{dp}{d\\psi} = 0 \\implies \\frac{dp}{d\\psi} = -8k\n$$\n$$\n2m + \\frac{1}{2} \\frac{d(F^2)}{d\\psi} = 0 \\implies \\frac{d(F^2)}{d\\psi} = -4m\n$$\n由于 $k$ 和 $m$ 是常数，导数 $\\frac{dp}{d\\psi}$ 和 $\\frac{d(F^2)}{d\\psi}$ 也是常数。常数可以平凡地视为 $\\psi$ 的函数，因此这些选择是有效的。\n我们可以对这些表达式积分，以找到 $p(\\psi)$ 和 $F^2(\\psi)$ 的完整形式：\n$$\np(\\psi) = \\int (-8k) \\, d\\psi = -8k\\psi + C_p\n$$\n$$\nF^2(\\psi) = \\int (-4m) \\, d\\psi = -4m\\psi + C_f\n$$\n积分常数 $C_p$ 和 $C_f$ 对应于问题中提到的任意偏移量 $p_0$ 和 $f_0$，它们不影响残差的计算。\n\n利用这些推导出的源项导数，根据构造，Grad-Shafranov 方程的残差对于所有 $(R,Z)$ 恒为零：\n$$\n\\mathcal{R}(R,Z) = \\Delta^{\\star}\\psi + R^2 \\frac{dp}{d\\psi} + \\frac{1}{2} \\frac{d(F^2)}{d\\psi}\n$$\n$$\n\\mathcal{R}(R,Z) = (8k R^2 + 2m) + R^2(-8k) + \\frac{1}{2}(-4m)\n$$\n$$\n\\mathcal{R}(R,Z) = 8k R^2 + 2m - 8k R^2 - 2m = 0\n$$\n任务是实现一个在离散网格上计算此残差的程序。由于浮点运算，数值计算的残差可能不完全为零。该程序将对每个测试案例在网格上评估 $\\mathcal{R}_{\\max} = \\max |\\mathcal{R}(R,Z)|$。这个值应该在机器精度的数量级，从而证实推导及其实现的正确性。\n实现将按以下步骤进行：\n1.  对每个测试案例，定义参数 $k, m, R_{\\min}, R_{\\max}, Z_{\\max}, N_R, N_Z$。\n2.  使用 `numpy.linspace` 和 `numpy.meshgrid` 创建 $(R,Z)$ 点的二维网格。\n3.  在此网格上，计算残差的各项：\n    -   人工的 Grad-Shafranov 算子项：$(\\Delta^{\\star}\\psi)_{\\text{grid}} = 8k R_{\\text{grid}}^2 + 2m$。\n    -   人工的压强项：$(R^2 \\frac{dp}{d\\psi})_{\\text{grid}} = R_{\\text{grid}}^2 (-8k)$。\n    -   人工的磁场项：$(\\frac{1}{2} \\frac{d(F^2)}{d\\psi})_{\\text{grid}} = \\frac{1}{2} (-4m) = -2m$。\n4.  将这些项相加，得到每个网格点的残差。\n5.  找到残差数组的最大绝对值。\n6.  收集所有测试案例的结果，并以指定格式打印。此计算不需要常数 $\\psi_0$、$p_0$ 和 $f_0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the maximum absolute residual of a manufactured Grad-Shafranov\n    equilibrium for a series of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (k, m, psi_0, R_min, R_max, Z_max, N_R, N_Z, p_0, f_0)\n    test_cases = [\n        (0.25, 0.75, 0, 1, 3, 1, 101, 101, 0, 10),\n        (0, 0.5, 0, 1, 3, 1, 101, 101, 0, 10),\n        (-0.125, 0.3, 0, 1, 3, 1, 101, 101, 0, 10),\n        (0.2, -0.4, 0, 1, 3, 1, 101, 101, 0, 10),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters for the current case.\n        # psi_0, p_0, and f_0 are not used in the residual calculation.\n        k, m, _, r_min, r_max, z_max, n_r, n_z, _, _ = case\n\n        # Create the computational grid.\n        # R-coordinates for the grid points.\n        R = np.linspace(r_min, r_max, n_r)\n        # Z-coordinates for the grid points.\n        Z = np.linspace(-z_max, z_max, n_z)\n        # Create 2D meshgrid. R_grid varies along columns, Z_grid along rows.\n        # This is the standard 'xy' indexing.\n        R_grid, Z_grid = np.meshgrid(R, Z)\n\n        # Analytically derive the source term derivatives from the manufactured solution.\n        # The form psi = k*R^4 + m*Z^2 + psi_0 requires:\n        # dp/dpsi = -8*k\n        # d(F^2)/dpsi = -4*m\n        dp_dpsi = -8.0 * k\n        dF2_dpsi = -4.0 * m\n        \n        # Calculate each term of the Grad-Shafranov equation residual.\n        # Term 1: Delta_star_psi = 8*k*R^2 + 2*m\n        delta_star_psi_grid = 8.0 * k * R_grid**2 + 2.0 * m\n        \n        # Term 2: R^2 * dp/dpsi\n        pressure_term = R_grid**2 * dp_dpsi\n        \n        # Term 3: (1/2) * d(F^2)/dpsi\n        field_term = 0.5 * dF2_dpsi\n        \n        # The residual is the sum of these terms. By construction, it should be\n        # analytically zero. The numerical result will be close to machine epsilon.\n        # residual = (8*k*R^2 + 2*m) + R^2*(-8*k) + (1/2)*(-4*m)\n        #          = 8*k*R^2 + 2*m - 8*k*R^2 - 2*m = 0\n        residual_grid = delta_star_psi_grid + pressure_term + field_term\n        \n        # Calculate the maximum absolute residual over the entire domain.\n        max_abs_residual = np.max(np.abs(residual_grid))\n        \n        results.append(max_abs_residual)\n\n    # Final print statement in the exact required format.\n    # The output values are very small floats representing numerical noise,\n    # as the analytical residual is zero.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Grad-Shafranov 方程通常是非线性的，需要使用迭代方法求解。这项综合实践将指导您构建一个完整的固定边界求解器，其核心是采用带有 Armijo 回溯线搜索策略的牛顿法，以确保全局收敛性 。您将学习如何构建雅可比矩阵，并实现一个稳健的非线性求解循环，这是解决等离子体平衡等复杂物理问题的关键计算能力。",
            "id": "3986269",
            "problem": "考虑轴对称磁流体动力学平衡，其中静态力平衡由压力梯度和洛伦兹力相等给出，写作 $\\nabla p = \\mathbf{j} \\times \\mathbf{B}$。在柱坐标 $(R,\\phi,Z)$ 的轴对称条件下，极向磁通函数 $\\Psi(R,Z)$ 满足带固定边界条件的 Grad–Shafranov 方程。Grad–Shafranov 算子定义为\n$$\n\\Delta^\\star \\Psi \\equiv R \\frac{\\partial}{\\partial R} \\left( \\frac{1}{R} \\frac{\\partial \\Psi}{\\partial R} \\right) + \\frac{\\partial^2 \\Psi}{\\partial Z^2}.\n$$\n平衡方程的形式为\n$$\n\\Delta^\\star \\Psi = - \\mu_0 R^2 \\frac{dp}{d\\Psi} - F(\\Psi) \\frac{dF}{d\\Psi},\n$$\n其中 $p(\\Psi)$ 是压力剖面，$F(\\Psi)$ 是环向场函数。假设无量纲归一化，使得自由空间磁导率 $\\mu_0$ 设为 $\\mu_0 = 1$，且所有量均为无量纲。\n\n您必须设计并实现一个牛顿法的全局化策略，该策略使用带充分下降（Armijo 回溯）的线搜索，以求解矩形计算域上带 Dirichlet 边界条件的非线性固定边界 Grad–Shafranov 方程。该域定义为 $R \\in [R_{\\min}, R_{\\max}]$ 和 $Z \\in [Z_{\\min}, Z_{\\max}]$，并在均匀网格上离散化。在整个边界上规定了固定边界条件 $\\Psi_b(R,Z) = R^2$，这是 $\\Delta^\\star \\Psi = 0$ 的一个真空解。\n\n在均匀网格上使用二阶有限差分对 $\\Delta^\\star$ 进行离散化，在 $R$ 方向上采用变系数自伴形式。令 $R_i$ 和 $Z_k$ 表示网格节点，并令 $a(R) = 1/R$ 且中点值为 $a_{i+1/2} = \\frac{1}{2}\\left( \\frac{1}{R_i} + \\frac{1}{R_{i+1}} \\right)$ 和 $a_{i-1/2} = \\frac{1}{2}\\left( \\frac{1}{R_i} + \\frac{1}{R_{i-1}} \\right)$。对于任意内部节点 $(i,k)$，写出离散算子\n$$\n(\\Delta^\\star \\Psi)_{i,k} \\approx R_i \\frac{1}{\\Delta R^2} \\left[ a_{i+1/2} \\left( \\Psi_{i+1,k} - \\Psi_{i,k} \\right) - a_{i-1/2} \\left( \\Psi_{i,k} - \\Psi_{i-1,k} \\right) \\right] + \\frac{\\Psi_{i,k+1} - 2\\Psi_{i,k} + \\Psi_{i,k-1}}{\\Delta Z^2},\n$$\n并通过将相邻边界的贡献移到右侧来合并固定边界值 $\\Psi_b$。将未知数表示为内部节点的向量。\n\n对源项使用以下参数化形式：\n$$\np(\\Psi) = \\alpha \\Psi + \\beta \\Psi^2, \\quad \\frac{dp}{d\\Psi} = \\alpha + 2\\beta \\Psi, \\quad F(\\Psi) = \\gamma + \\delta \\Psi, \\quad \\frac{dF}{d\\Psi} = \\delta.\n$$\n为内部未知数 $\\mathbf{\\Psi}$ 定义残差向量：\n$$\n\\mathbf{r}(\\mathbf{\\Psi}) = \\mathbf{L}\\mathbf{\\Psi} + \\mathbf{g} + \\mathbf{s}(\\mathbf{\\Psi}),\n$$\n其中 $\\mathbf{L}$ 是表示作用于内部节点的 $\\Delta^\\star$ 的离散矩阵，$\\mathbf{g}$ 编码了来自 $\\Psi_b$ 的边界贡献，非线性源项为\n$$\n\\mathbf{s}(\\mathbf{\\Psi}) = R^2 \\left( \\alpha + 2\\beta \\mathbf{\\Psi} \\right) + \\delta \\left( \\gamma + \\delta \\mathbf{\\Psi} \\right).\n$$\n此处 $R^2$ 表示在内部节点处，条目为 $R_i^2$ 的对角向量。\n\n应用牛顿法，在每次迭代中求解线性系统\n$$\n\\mathbf{J}(\\mathbf{\\Psi}) \\mathbf{s} = -\\mathbf{r}(\\mathbf{\\Psi}),\n$$\n其中雅可比矩阵为\n$$\n\\mathbf{J}(\\mathbf{\\Psi}) = \\mathbf{L} + \\operatorname{diag}\\left( R^2 \\cdot \\frac{d^2 p}{d\\Psi^2} + \\left( \\frac{dF}{d\\Psi} \\right)^2 + F(\\Psi) \\frac{d^2F}{d\\Psi^2} \\right).\n$$\n对于所选的剖面，$\\frac{d^2 p}{d\\Psi^2} = 2\\beta$ 和 $\\frac{d^2F}{d\\Psi^2} = 0$，这意味着\n$$\n\\mathbf{J} = \\mathbf{L} + \\operatorname{diag}\\left( 2\\beta R^2 + \\delta^2 \\right).\n$$\n\n使用基于价值函数的线搜索来全局化牛顿法\n$$\n\\Phi(\\mathbf{\\Psi}) = \\frac{1}{2} \\lVert \\mathbf{r}(\\mathbf{\\Psi}) \\rVert_2^2,\n$$\n采用 Armijo 回溯：给定牛顿步长 $\\mathbf{s}$，通过回溯 $\\alpha \\leftarrow \\tau \\alpha$ (其中 $\\tau \\in (0,1)$) 来选择步长 $\\alpha \\in (0,1]$，直到满足\n$$\n\\Phi(\\mathbf{\\Psi} + \\alpha \\mathbf{s}) \\le \\Phi(\\mathbf{\\Psi}) - c \\alpha \\lVert \\mathbf{r}(\\mathbf{\\Psi}) \\rVert_2^2,\n$$\n对于用户指定的参数 $c \\in (0,1)$，确保充分下降。使用 $\\tau = 1/2$ 进行回溯。当 $\\lVert \\mathbf{r}(\\mathbf{\\Psi}) \\rVert_2 \\le \\varepsilon$ 或达到最大牛顿迭代次数后终止。\n\n在域 $R \\in [1.0,1.4]$，$Z \\in [-0.2,0.2]$ 上实现求解器，使用具有 $N_R = 22$ 和 $N_Z = 22$ 个节点的均匀网格。所有边界节点上的边界条件为 $\\Psi_b(R,Z) = R^2$。对内部节点使用两种可能的初始猜测：真空猜测 $\\Psi^{(0)} = R^2$ 或零猜测 $\\Psi^{(0)} = 0$。\n\n您的程序必须实现上述离散化和全局化策略，并运行以下测试套件。对于每个测试用例，输出一个列表，其中包含最终残差范数 $\\lVert \\mathbf{r} \\rVert_2$ (浮点数)、执行的牛顿迭代次数 (整数)、所有迭代中的回溯减少总数 (整数) 和一个成功标志 (整数，如果 $\\lVert \\mathbf{r} \\rVert_2 \\le \\varepsilon$ 则为 $1$，否则为 $0$)。使用 $\\varepsilon = 10^{-6}$ 和最大 $50$ 次牛顿迭代。\n\n测试套件参数集为 $(\\alpha,\\beta,\\gamma,\\delta,c,\\text{init})$：\n1. $(0.2, 0.05, 1.0, 0.1, 10^{-4}, \\text{vacuum})$ 作为一般情况。\n2. $(0.0, 0.0, 1.0, 0.0, 10^{-4}, \\text{vacuum})$ 作为真空边界和真空内部情况。\n3. $(0.6, 0.3, 0.8, 0.3, 10^{-3}, \\text{vacuum})$ 作为强非线性情况。\n4. $(0.6, 0.3, 0.8, 0.3, 10^{-4}, \\text{zero})$ 作为不良初始猜测情况。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个结果本身都是一个格式为 $[\\,\\lVert \\mathbf{r} \\rVert_2, \\text{iterations}, \\text{backtracks}, \\text{success}\\,]$ 的列表。例如：\"[[r1,it1,bt1,s1],[r2,it2,bt2,s2],[r3,it3,bt3,s3],[r4,it4,bt4,s4]]\"。所有量都是无量纲的，如果存在角度，则必须以弧度为单位；本问题中没有出现角度。",
            "solution": "用户提供了一个问题，要求为 Grad–Shafranov 方程开发一个数值求解器。根据规定进行的验证过程确认了该问题具有科学依据、是适定的且客观的。它为计算等离子体物理中的固定边界平衡问题提供了一套完整且一致的规范。所有必需的方程、离散化方案、边界条件、数值参数和测试用例都已明确定义。\n\n一个重要的分析观察是，为压力 $p(\\Psi) = \\alpha \\Psi + \\beta \\Psi^2$ 和环向场函数 $F(\\Psi) = \\gamma + \\delta \\Psi$ 所选的特定参数化形式，导致 Grad–Shafranov 方程在通量函数 $\\Psi$ 上是线性的。控制偏微分方程（PDE）的形式为\n$$\n\\Delta^\\star \\Psi + \\left( 2\\beta R^2 + \\delta^2 \\right) \\Psi = - \\alpha R^2 - \\gamma\\delta,\n$$\n这是一个线性的、非齐次的椭圆偏微分方程。因此，当离散化时，会得到一个形如 $\\mathbf{J}\\mathbf{\\Psi} = \\mathbf{b}$ 的线性代数方程组。\n\n该问题指示实现牛顿法，这是一种求解*非线性*系统的方法，并使用 Armijo 线搜索进行全局化。当应用于线性系统 $\\mathbf{A}\\mathbf{x} - \\mathbf{b} = 0$ 时，只要初始猜测不是解本身，牛顿迭代就会在单步内以步长 $\\alpha=1$ 收敛。残差 $\\mathbf{r}(\\mathbf{x}) = \\mathbf{A}\\mathbf{x} - \\mathbf{b}$ 的雅可比矩阵就是常数矩阵 $\\mathbf{A}$，并且牛顿更新 $\\mathbf{x}_{k+1} = \\mathbf{x}_k - \\mathbf{A}^{-1}(\\mathbf{A}\\mathbf{x}_k - \\mathbf{b})$ 简化为 $\\mathbf{x}_{k+1} = \\mathbf{A}^{-1}\\mathbf{b}$，这正是精确解。尽管实现中要求使用线搜索全局化策略，但它对于收敛并非严格必要，并且预计在第一次迭代中会接受完整步长 $\\alpha=1$，从而以零次回溯折减实现收敛。\n\n虽然这种线性简化了问题的动力学，但并未使问题无效。该任务仍然是为通用 Grad–Shafranov 求解器构建必要数值机制（离散化矩阵、残差和雅可比公式、以及 Newton-Armijo 循环结构）的一个有效且定义明确的练习，此处在一个特定的线性案例上进行测试。解决方案将忠实地实现所要求的算法，并报告其在给定测试用例上的行为。\n\n求解过程如下：\n1.  **离散化**：计算域 $R \\in [R_{\\min}, R_{\\max}]$, $Z \\in [Z_{\\min}, Z_{\\max}]$ 在一个 $N_R \\times N_Z$ 节点的均匀网格上被离散化。极向通量 $\\Psi$ 由其在网格节点 $(R_i, Z_k)$ 上的值 $\\Psi_{i,k}$ 表示。问题未知数是 $\\Psi$ 在 $(N_R-2) \\times (N_Z-2)$ 个内部节点上的值，这些值被展平成一个长度为 $N = (N_R-2)(N_Z-2)$ 的单一向量 $\\mathbf{\\Psi}$。\n\n2.  **矩阵公式化**：Grad–Shafranov 方程的有限差分近似被转换成一个矩阵系统。\n    - 作用于内部节点的离散算子 $\\Delta^\\star$ 由一个大小为 $N \\times N$ 的稀疏矩阵 $\\mathbf{L}$ 表示。\n    - Dirichlet 边界条件 $\\Psi = \\Psi_b$ 贡献了一个长度为 $N$ 的常数向量 $\\mathbf{g}$。\n    - 非线性源项，对于给定的剖面为 $\\mathbf{s}(\\mathbf{\\Psi}) = R^2 (\\alpha + 2\\beta \\mathbf{\\Psi}) + \\delta(\\gamma + \\delta \\mathbf{\\Psi})$，被加入。\n    待求解的方程组是 $\\mathbf{r}(\\mathbf{\\Psi}) = 0$，其中残差向量定义为 $\\mathbf{r}(\\mathbf{\\Psi}) = \\mathbf{L}\\mathbf{\\Psi} + \\mathbf{g} + \\mathbf{s}(\\mathbf{\\Psi})$。\n\n3.  **Newton-Armijo 求解器**：系统 $\\mathbf{r}(\\mathbf{\\Psi}) = 0$ 被迭代求解。\n    - **初始化**：根据指定，从真空解或零值形成初始猜测 $\\mathbf{\\Psi}^{(0)}$。\n    - **迭代**：在每一步 $k$，我们求解线性系统以获得牛顿更新 $\\mathbf{s}^{(k)}$：\n      $$\n      \\mathbf{J}(\\mathbf{\\Psi}^{(k)}) \\mathbf{s}^{(k)} = -\\mathbf{r}(\\mathbf{\\Psi}^{(k)})\n      $$\n      雅可比矩阵 $\\mathbf{J}$ 是残差 $\\mathbf{r}$ 相对于 $\\mathbf{\\Psi}$ 的导数。对于给定的剖面，这是一个常数矩阵：\n      $$\n      \\mathbf{J} = \\mathbf{L} + \\text{diag}(2\\beta R^2 + \\delta^2)\n      $$\n    - **线搜索**：解通过 $\\mathbf{\\Psi}^{(k+1)} = \\mathbf{\\Psi}^{(k)} + \\alpha_k \\mathbf{s}^{(k)}$ 进行更新，其中步长 $\\alpha_k \\in (0, 1]$ 由 Armijo 回溯条件确定。我们从 $\\alpha_k=1$ 开始，并以 $\\tau = 1/2$ 的因子减小它，直到满足关于价值函数 $\\Phi(\\mathbf{\\Psi}) = \\frac{1}{2} \\lVert \\mathbf{r}(\\mathbf{\\Psi}) \\rVert_2^2$ 的充分下降条件：\n      $$\n      \\Phi(\\mathbf{\\Psi}^{(k)} + \\alpha_k \\mathbf{s}^{(k)}) \\le \\Phi(\\mathbf{\\Psi}^{(k)}) - c \\alpha_k \\lVert \\mathbf{r}(\\mathbf{\\Psi}^{(k)}) \\rVert_2^2\n      $$\n    - **终止**：当残差的欧几里得范数低于容差 $\\lVert \\mathbf{r}(\\mathbf{\\Psi}^{(k)}) \\rVert_2 \\le \\varepsilon$，或达到最大迭代次数时，过程停止。\n\n该实现将构建矩阵 $\\mathbf{L}$ 和 $\\mathbf{J}$，以及向量 $\\mathbf{g}$ 和 $\\mathbf{s}$，然后为每个指定的测试用例执行 Newton-Armijo 循环，报告最终的残差范数、迭代计数、总回溯折减次数和成功标志。",
            "answer": "```python\nimport numpy as np\n\ndef build_operator(R_min, R_max, Z_min, Z_max, N_R, N_Z):\n    \"\"\"\n    Constructs the discrete Grad-Shafranov operator matrix L,\n    the boundary contribution vector g, and related grid information.\n    \"\"\"\n    R_nodes = np.linspace(R_min, R_max, N_R)\n    Z_nodes = np.linspace(Z_min, Z_max, N_Z)\n    delta_R = (R_max - R_min) / (N_R - 1)\n    delta_Z = (Z_max - Z_min) / (N_Z - 1)\n    \n    N_int_R = N_R - 2\n    N_int_Z = N_Z - 2\n    N_int = N_int_R * N_int_Z\n\n    L = np.zeros((N_int, N_int))\n    g = np.zeros(N_int)\n    \n    # Flattened R^2 vector for interior points (row-major)\n    R_int_grid = R_nodes[1:-1, np.newaxis] * np.ones((N_int_R, N_int_Z))\n    R2_vec = (R_int_grid.flatten(order='C'))**2\n    \n    for i in range(N_int_R):\n        for k in range(N_int_Z):\n            m = i * N_int_Z + k\n            \n            i_grid, k_grid = i + 1, k + 1\n            \n            R_i = R_nodes[i_grid]\n            \n            # R-derivative coefficients\n            a_ip_half = 0.5 * (1.0/R_nodes[i_grid] + 1.0/R_nodes[i_grid+1])\n            a_im_half = 0.5 * (1.0/R_nodes[i_grid] + 1.0/R_nodes[i_grid-1])\n            \n            c_i = -R_i * (a_ip_half + a_im_half) / (delta_R**2)\n            c_ip1 = R_i * a_ip_half / (delta_R**2)\n            c_im1 = R_i * a_im_half / (delta_R**2)\n            \n            # Z-derivative coefficients\n            c_k = -2.0 / (delta_Z**2)\n            c_kp1 = 1.0 / (delta_Z**2)\n            c_km1 = 1.0 / (delta_Z**2)\n            \n            # Diagonal element\n            L[m, m] = c_i + c_k\n\n            # Off-diagonal elements for interior neighbors\n            if i  0:\n                L[m, m - N_int_Z] = c_im1  # Psi_{i-1, k}\n            if i  N_int_R - 1:\n                L[m, m + N_int_Z] = c_ip1  # Psi_{i+1, k}\n            if k  0:\n                L[m, m - 1] = c_km1      # Psi_{i, k-1}\n            if k  N_int_Z - 1:\n                L[m, m + 1] = c_kp1      # Psi_{i, k+1}\n\n            # Boundary contributions moved to RHS vector g\n            # Boundary condition is Psi_b(R,Z) = R^2\n            if i == 0:\n                g[m] -= c_im1 * (R_nodes[0]**2)\n            if i == N_int_R - 1:\n                g[m] -= c_ip1 * (R_nodes[-1]**2)\n            if k == 0:\n                # Psi_b = R_i^2 at Z_min boundary\n                g[m] -= c_km1 * (R_nodes[i_grid]**2)\n            if k == N_int_Z - 1:\n                # Psi_b = R_i^2 at Z_max boundary\n                g[m] -= c_kp1 * (R_nodes[i_grid]**2)\n    \n    return L, g, R2_vec, R_nodes, Z_nodes\n\ndef run_solver(params, L, g, R2_vec, R_nodes, Z_nodes):\n    \"\"\"\n    Executes the Newton-Armijo solver for a given set of parameters.\n    \"\"\"\n    alpha_p, beta_p, gamma_p, delta_p, c, init_type = params\n    \n    N_R = len(R_nodes)\n    N_Z = len(Z_nodes)\n    N_int_R = N_R - 2\n    N_int_Z = N_Z - 2\n    max_iter = 50\n    epsilon = 1e-6\n    tau = 0.5\n\n    # Initialize solution vector Psi\n    R_grid_full, _ = np.meshgrid(R_nodes, Z_nodes, indexing='ij')\n    \n    # Set initial guess for interior nodes\n    if init_type == 'vacuum':\n        Psi_initial_interior = R_grid_full[1:-1, 1:-1]**2\n    else: # zero guess\n        Psi_initial_interior = np.zeros((N_int_R, N_int_Z))\n\n    Psi_vec = Psi_initial_interior.flatten(order='C')\n\n    # Since the Jacobian is constant for this problem, compute it once\n    J = L + np.diag(2 * beta_p * R2_vec + delta_p**2)\n\n    iter_count = 0\n    total_backtracks = 0\n    final_r_norm = -1.0 # Default value\n\n    while iter_count  max_iter:\n        # Calculate residual vector r\n        s_vec = R2_vec * (alpha_p + 2 * beta_p * Psi_vec) + delta_p * (gamma_p + delta_p * Psi_vec)\n        r_vec = L @ Psi_vec + g + s_vec\n        \n        r_norm = np.linalg.norm(r_vec)\n        \n        if r_norm = epsilon:\n            final_r_norm = r_norm\n            break\n        \n        # Calculate Newton step s\n        step_s = np.linalg.solve(J, -r_vec)\n        \n        # Armijo backtracking line search\n        step_alpha = 1.0\n        phi_current = 0.5 * r_norm**2\n        armijo_rhs_term = c * r_norm**2\n        \n        local_backtracks = 0\n        while True:\n            Psi_vec_new = Psi_vec + step_alpha * step_s\n            \n            s_new = R2_vec * (alpha_p + 2 * beta_p * Psi_vec_new) + delta_p * (gamma_p + delta_p * Psi_vec_new)\n            r_new = L @ Psi_vec_new + g + s_new\n            phi_new = 0.5 * np.linalg.norm(r_new)**2\n            \n            if phi_new = phi_current - step_alpha * armijo_rhs_term:\n                Psi_vec = Psi_vec_new\n                total_backtracks += local_backtracks\n                break\n            \n            step_alpha *= tau\n            local_backtracks += 1\n            if step_alpha  1e-12: # Safety break for line search\n                # This indicates a failure in finding a step length\n                # and loop will terminate due to max_iter\n                break\n                \n        iter_count += 1\n    \n    # Final residual after loop\n    s_final = R2_vec * (alpha_p + 2 * beta_p * Psi_vec) + delta_p * (gamma_p + delta_p * Psi_vec)\n    r_final = L @ Psi_vec + g + s_final\n    final_r_norm = np.linalg.norm(r_final)\n\n    success = 1 if final_r_norm = epsilon else 0\n    \n    return [final_r_norm, iter_count, total_backtracks, success]\n\n\ndef solve():\n    \"\"\"\n    Main function to set up the problem and run the test suite.\n    \"\"\"\n    R_min, R_max = 1.0, 1.4\n    Z_min, Z_max = -0.2, 0.2\n    N_R, N_Z = 22, 22\n\n    test_cases = [\n        # (alpha, beta, gamma, delta, c, init)\n        (0.2, 0.05, 1.0, 0.1, 1e-4, 'vacuum'),\n        (0.0, 0.0, 1.0, 0.0, 1e-4, 'vacuum'),\n        (0.6, 0.3, 0.8, 0.3, 1e-3, 'vacuum'),\n        (0.6, 0.3, 0.8, 0.3, 1e-4, 'zero'),\n    ]\n\n    # Pre-compute grid-dependent quantities\n    L, g, R2_vec, R_nodes, Z_nodes = build_operator(R_min, R_max, Z_min, Z_max, N_R, N_Z)\n\n    results = []\n    for case_params in test_cases:\n        result = run_solver(case_params, L, g, R2_vec, R_nodes, Z_nodes)\n        results.append(result)\n\n    # Format output as specified\n    output_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]},{r[2]},{r[3]}]\" for r in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}