{
    "hands_on_practices": [
        {
            "introduction": "This practice serves as the foundation for our exploration of toroidal geometry. We begin with the most intuitive parameterization of a torus and derive its metric tensor, the mathematical object that encodes all local geometric properties like distance, angle, and volume. By explicitly calculating the metric components and the Jacobian , you will build the core skill of translating a geometric definition into the language of differential geometry, a crucial step for writing physical laws in arbitrary coordinate systems.",
            "id": "3960114",
            "problem": "In a circular, concentric, axisymmetric torus representative of a magnetic confinement fusion (MCF) tokamak, introduce the standard toroidal coordinates $\\left(r,\\theta,\\phi\\right)$ with major radius $R_{0}$ and minor radius $r$, where $0 \\le r \\ll R_{0}$. The geometric mapping into Cartesian space $\\left(x,y,z\\right)$ is defined by the cylindrical variables $R$ and $Z$ through\n$$\nR\\left(r,\\theta\\right)=R_{0}+r\\cos\\theta,\\qquad Z\\left(r,\\theta\\right)=r\\sin\\theta,\n$$\nand\n$$\nx=R\\cos\\phi,\\qquad y=R\\sin\\phi,\\qquad z=Z,\n$$\nwith both angles $\\theta$ and $\\phi$ measured in radians.\n\nStarting from the coordinate geometry fundamentals\n- the covariant basis vectors $\\mathbf{e}_{i}=\\partial \\mathbf{x}/\\partial q^{i}$ for $q^{i}\\in\\{r,\\theta,\\phi\\}$,\n- the metric tensor components $g_{ij}=\\mathbf{e}_{i}\\cdot \\mathbf{e}_{j}$,\n- the Jacobian $\\sqrt{g}=\\mathbf{e}_{r}\\cdot\\left(\\mathbf{e}_{\\theta}\\times \\mathbf{e}_{\\phi}\\right)=\\sqrt{\\det\\left[g_{ij}\\right]}$,\n\nderive the exact metric tensor $g_{ij}$ and the exact Jacobian $\\sqrt{g}$ for these coordinates. Then, introduce the large-aspect-ratio parameter $\\epsilon=r/R_{0}$ and simplify both the metric and the Jacobian in the asymptotic limit $\\epsilon\\ll 1$. For each nontrivial component, estimate the lowest-order nonvanishing correction in powers of $\\epsilon$ relative to the leading term.\n\nAnswer specification:\n- Provide the final answer as the first-order (in $\\epsilon$) asymptotic expression for the Jacobian $\\sqrt{g}$ as a function of $r$, $\\theta$, and $R_{0}$.\n- Express angles in radians.\n- The final answer must be a single closed-form analytic expression with no units and no remainder notation.",
            "solution": "The problem requires the derivation of the metric tensor, $g_{ij}$, and the Jacobian, $\\sqrt{g}$, for a standard toroidal coordinate system $(r, \\theta, \\phi)$, followed by a large-aspect-ratio asymptotic analysis.\n\nThe position vector $\\mathbf{x}$ in Cartesian coordinates $(x, y, z)$ is given in terms of the toroidal coordinates $(r, \\theta, \\phi)$ by the relations:\n$$\nx = (R_0 + r\\cos\\theta)\\cos\\phi\n$$\n$$\ny = (R_0 + r\\cos\\theta)\\sin\\phi\n$$\n$$\nz = r\\sin\\theta\n$$\nWe can write the position vector as:\n$$\n\\mathbf{x}(r, \\theta, \\phi) = (R_0 + r\\cos\\theta)\\cos\\phi \\, \\hat{\\mathbf{i}} + (R_0 + r\\cos\\theta)\\sin\\phi \\, \\hat{\\mathbf{j}} + r\\sin\\theta \\, \\hat{\\mathbf{k}}\n$$\nwhere $R_0$ is the major radius and $r$ is the minor radius.\n\nFirst, we compute the covariant basis vectors, $\\mathbf{e}_i = \\frac{\\partial \\mathbf{x}}{\\partial q^i}$, for $q^i \\in \\{r, \\theta, \\phi\\}$.\n\nThe basis vector in the $r$ direction is:\n$$\n\\mathbf{e}_r = \\frac{\\partial \\mathbf{x}}{\\partial r} = (\\cos\\theta\\cos\\phi)\\,\\hat{\\mathbf{i}} + (\\cos\\theta\\sin\\phi)\\,\\hat{\\mathbf{j}} + (\\sin\\theta)\\,\\hat{\\mathbf{k}}\n$$\n\nThe basis vector in the $\\theta$ direction is:\n$$\n\\mathbf{e}_\\theta = \\frac{\\partial \\mathbf{x}}{\\partial \\theta} = (-r\\sin\\theta\\cos\\phi)\\,\\hat{\\mathbf{i}} + (-r\\sin\\theta\\sin\\phi)\\,\\hat{\\mathbf{j}} + (r\\cos\\theta)\\,\\hat{\\mathbf{k}}\n$$\n\nThe basis vector in the $\\phi$ direction is:\n$$\n\\mathbf{e}_\\phi = \\frac{\\partial \\mathbf{x}}{\\partial \\phi} = -(R_0 + r\\cos\\theta)\\sin\\phi\\,\\hat{\\mathbf{i}} + (R_0 + r\\cos\\theta)\\cos\\phi\\,\\hat{\\mathbf{j}}\n$$\n\nNext, we calculate the components of the metric tensor, $g_{ij} = \\mathbf{e}_i \\cdot \\mathbf{e}_j$.\n\nFor the diagonal components:\n$$\ng_{rr} = \\mathbf{e}_r \\cdot \\mathbf{e}_r = (\\cos^2\\theta\\cos^2\\phi) + (\\cos^2\\theta\\sin^2\\phi) + \\sin^2\\theta = \\cos^2\\theta(\\cos^2\\phi+\\sin^2\\phi) + \\sin^2\\theta = \\cos^2\\theta + \\sin^2\\theta = 1\n$$\n$$\ng_{\\theta\\theta} = \\mathbf{e}_\\theta \\cdot \\mathbf{e}_\\theta = (r^2\\sin^2\\theta\\cos^2\\phi) + (r^2\\sin^2\\theta\\sin^2\\phi) + (r^2\\cos^2\\theta) = r^2\\sin^2\\theta(\\cos^2\\phi+\\sin^2\\phi) + r^2\\cos^2\\theta = r^2(\\sin^2\\theta + \\cos^2\\theta) = r^2\n$$\n$$\ng_{\\phi\\phi} = \\mathbf{e}_\\phi \\cdot \\mathbf{e}_\\phi = (R_0 + r\\cos\\theta)^2\\sin^2\\phi + (R_0 + r\\cos\\theta)^2\\cos^2\\phi = (R_0 + r\\cos\\theta)^2(\\sin^2\\phi+\\cos^2\\phi) = (R_0 + r\\cos\\theta)^2\n$$\n\nFor the off-diagonal components, we check for orthogonality:\n$$\ng_{r\\theta} = \\mathbf{e}_r \\cdot \\mathbf{e}_\\theta = -r\\sin\\theta\\cos\\theta\\cos^2\\phi - r\\sin\\theta\\cos\\theta\\sin^2\\phi + r\\sin\\theta\\cos\\theta = -r\\sin\\theta\\cos\\theta + r\\sin\\theta\\cos\\theta = 0\n$$\n$$\ng_{r\\phi} = \\mathbf{e}_r \\cdot \\mathbf{e}_\\phi = -\\cos\\theta\\cos\\phi(R_0 + r\\cos\\theta)\\sin\\phi + \\cos\\theta\\sin\\phi(R_0 + r\\cos\\theta)\\cos\\phi = 0\n$$\n$$\ng_{\\theta\\phi} = \\mathbf{e}_\\theta \\cdot \\mathbf{e}_\\phi = r\\sin\\theta\\cos\\phi(R_0 + r\\cos\\theta)\\sin\\phi - r\\sin\\theta\\sin\\phi(R_0 + r\\cos\\theta)\\cos\\phi = 0\n$$\nSince all off-diagonal components are zero, the coordinate system is orthogonal, and the metric tensor is diagonal. The exact metric tensor is:\n$$\n[g_{ij}] = \\begin{pmatrix} 1  0  0 \\\\ 0  r^2  0 \\\\ 0  0  (R_0 + r\\cos\\theta)^2 \\end{pmatrix}\n$$\n\nThe Jacobian (volume element scale factor) $\\sqrt{g}$ is given by $\\sqrt{\\det[g_{ij}]}$.\n$$\n\\det[g_{ij}] = g_{rr} g_{\\theta\\theta} g_{\\phi\\phi} = (1)(r^2)(R_0 + r\\cos\\theta)^2\n$$\nTaking the square root (and noting that the geometric volume element must be positive, so we take the positive root, which is justified as $r \\ge 0$ and $R_0 + r\\cos\\theta > 0$ for a tokamak), we find the exact Jacobian:\n$$\n\\sqrt{g} = \\sqrt{r^2 (R_0 + r\\cos\\theta)^2} = r(R_0 + r\\cos\\theta)\n$$\n\nNow, we introduce the large-aspect-ratio parameter $\\epsilon = r/R_0$ and analyze the behavior in the limit $\\epsilon \\ll 1$.\n\nThe metric components $g_{rr}=1$ and $g_{\\theta\\theta}=r^2$ are exact and independent of $R_0$, so their asymptotic forms are themselves. The component $g_{\\phi\\phi}$ depends on the aspect ratio:\n$$\ng_{\\phi\\phi} = (R_0 + r\\cos\\theta)^2 = R_0^2 \\left(1 + \\frac{r}{R_0}\\cos\\theta\\right)^2 = R_0^2(1 + \\epsilon\\cos\\theta)^2\n$$\nExpanding in powers of $\\epsilon$:\n$$\ng_{\\phi\\phi} = R_0^2 (1 + 2\\epsilon\\cos\\theta + \\epsilon^2\\cos^2\\theta)\n$$\nIn the asymptotic limit $\\epsilon \\ll 1$, the leading term is $R_0^2$. The lowest-order nonvanishing correction is the term linear in $\\epsilon$, which is $2R_0^2\\epsilon\\cos\\theta = 2R_0 r \\cos\\theta$. The relative correction is $2\\epsilon\\cos\\theta$.\n\nNext, we analyze the Jacobian $\\sqrt{g}$:\n$$\n\\sqrt{g} = r(R_0 + r\\cos\\theta)\n$$\nWe can factor out $R_0$ to make the dependence on $\\epsilon$ explicit:\n$$\n\\sqrt{g} = rR_0 \\left(1 + \\frac{r}{R_0}\\cos\\theta\\right) = rR_0(1 + \\epsilon\\cos\\theta)\n$$\nThis expression is exact and is already a finite polynomial of first order in $\\epsilon = r/R_0$. Therefore, this expression itself is the requested \"first-order (in $\\epsilon$) asymptotic expression\". The leading term, corresponding to the cylindrical limit ($\\epsilon \\to 0$), is $rR_0$. The lowest-order nonvanishing correction term is $rR_0(\\epsilon\\cos\\theta) = r^2\\cos\\theta$. The final expression for the Jacobian as a function of $r$, $\\theta$, and $R_0$ is the exact form.\n\nFinal expression for the Jacobian:\n$$\n\\sqrt{g} = r(R_0 + r\\cos\\theta)\n$$",
            "answer": "$$\n\\boxed{r(R_0 + r\\cos\\theta)}\n$$"
        },
        {
            "introduction": "Building on the foundational skills from the previous exercise, we now move from purely geometric coordinates to a system rooted in the physics of magnetic confinement. Here, we replace the simple minor radius with the poloidal magnetic flux function, $\\psi$, which naturally labels the nested magnetic surfaces of a tokamak equilibrium. This practice  demonstrates how to derive the metric tensor in these physics-based \"flux coordinates,\" a critical step for analyzing plasma stability and transport, where physical phenomena are often constant on flux surfaces.",
            "id": "3960084",
            "problem": "Consider an axisymmetric magnetostatic equilibrium in a toroidal confinement device described in cylindrical coordinates $(R,\\phi,Z)$, where $\\phi$ is the toroidal angle measured in radians. The equilibrium is governed by the Gradâ€“Shafranov equation,\n$$\n\\Delta^{*}\\psi(R,Z) \\equiv R \\frac{\\partial}{\\partial R}\\left(\\frac{1}{R}\\frac{\\partial \\psi}{\\partial R}\\right) + \\frac{\\partial^{2}\\psi}{\\partial Z^{2}} = -\\mu_{0} R^{2} \\, p'(\\psi) - F(\\psi) F'(\\psi),\n$$\nwith $\\psi(R,Z)$ the poloidal magnetic flux function labeling nested magnetic flux surfaces, $p(\\psi)$ the scalar pressure, $F(\\psi) \\equiv R B_{\\phi}$ the toroidal field function, and $\\mu_{0}$ the permeability of free space. Assume a large-aspect-ratio tokamak with circular, concentric flux surfaces about a major radius $R_{0}$, negligible pressure gradient $p'(\\psi)=0$, and $F(\\psi) = B_{0} R_{0}$ constant, consistent with a dominant toroidal magnetic field. Under these assumptions, the poloidal flux function $\\psi(R,Z)$ yields closed, nested flux surfaces that can be parameterized by a minor radius $r$ and a poloidal angle $\\theta$ (measured in radians) according to\n$$\nR = R_{0} + r \\cos\\theta,\\qquad Z = r \\sin\\theta,\n$$\nand the flux surface label may be taken as a monotonic function of $r$, i.e., $\\psi = \\psi(r)$ with $r = r(\\psi)$ invertible.\n\nUsing the coordinate map $(\\psi,\\theta,\\phi)\\mapsto (R(\\psi,\\theta),Z(\\psi,\\theta),\\phi)$, derive the local line element $ds^{2}$ and the associated covariant metric tensor components $g_{ij}$ in the $(\\psi,\\theta,\\phi)$ coordinates. Then compute the determinant $g \\equiv \\det(g_{ij})$ of the covariant metric tensor. Express your final answer as a single closed-form analytic expression for $g(\\psi,\\theta,\\phi)$ in terms of $R_{0}$, $r(\\psi)$, $\\frac{dr}{d\\psi}$, and $\\theta$. No numerical evaluation is required, and angles must be in radians. The final answer should be the analytic expression for $g$ only and should not include any units.",
            "solution": "The objective is to compute the determinant $g$ of the covariant metric tensor $g_{ij}$ in a toroidal coordinate system $(\\psi, \\theta, \\phi)$. The starting point is the differential line element, $ds^{2}$, in standard cylindrical coordinates $(R, \\phi, Z)$:\n$$ds^{2} = dR^{2} + dZ^{2} + R^{2} d\\phi^{2}$$\nThe problem provides the coordinate transformation from the toroidal coordinates $(\\psi, \\theta, \\phi)$ to the cylindrical coordinates $(R, Z, \\phi)$ for a circular, large-aspect-ratio tokamak model:\n$$R(\\psi, \\theta) = R_{0} + r(\\psi) \\cos\\theta$$\n$$Z(\\psi, \\theta) = r(\\psi) \\sin\\theta$$\nThe toroidal angle $\\phi$ remains unchanged. The minor radius $r$ is a monotonic, invertible function of the poloidal flux $\\psi$, which we denote as $r(\\psi)$.\n\nTo transform the line element, we first compute the total differentials of $R$ and $Z$ in terms of the new coordinates $\\psi$ and $\\theta$. We apply the chain rule for multivariable functions.\n$$dR = \\frac{\\partial R}{\\partial \\psi} d\\psi + \\frac{\\partial R}{\\partial \\theta} d\\theta$$\n$$dZ = \\frac{\\partial Z}{\\partial \\psi} d\\psi + \\frac{\\partial Z}{\\partial \\theta} d\\theta$$\nThe required partial derivatives are calculated as follows, letting $r'(\\psi) \\equiv \\frac{dr}{d\\psi}$:\n$$\\frac{\\partial R}{\\partial \\psi} = \\frac{\\partial}{\\partial \\psi} (R_{0} + r(\\psi)\\cos\\theta) = \\frac{dr}{d\\psi} \\cos\\theta = r'(\\psi) \\cos\\theta$$\n$$\\frac{\\partial R}{\\partial \\theta} = \\frac{\\partial}{\\partial \\theta} (R_{0} + r(\\psi)\\cos\\theta) = -r(\\psi) \\sin\\theta$$\n$$\\frac{\\partial Z}{\\partial \\psi} = \\frac{\\partial}{\\partial \\psi} (r(\\psi)\\sin\\theta) = \\frac{dr}{d\\psi} \\sin\\theta = r'(\\psi) \\sin\\theta$$\n$$\\frac{\\partial Z}{\\partial \\theta} = \\frac{\\partial}{\\partial \\theta} (r(\\psi)\\sin\\theta) = r(\\psi) \\cos\\theta$$\nSubstituting these expressions into the formulas for $dR$ and $dZ$:\n$$dR = (r'(\\psi) \\cos\\theta) d\\psi - (r(\\psi) \\sin\\theta) d\\theta$$\n$$dZ = (r'(\\psi) \\sin\\theta) d\\psi + (r(\\psi) \\cos\\theta) d\\theta$$\nNext, we find the squares of these differentials, $dR^{2}$ and $dZ^{2}$:\n$$dR^{2} = \\left(r'(\\psi) \\cos\\theta \\, d\\psi - r(\\psi) \\sin\\theta \\, d\\theta\\right)^{2} = (r'(\\psi))^{2} \\cos^{2}\\theta \\, d\\psi^{2} - 2r(\\psi)r'(\\psi) \\sin\\theta \\cos\\theta \\, d\\psi d\\theta + r(\\psi)^{2} \\sin^{2}\\theta \\, d\\theta^{2}$$\n$$dZ^{2} = \\left(r'(\\psi) \\sin\\theta \\, d\\psi + r(\\psi) \\cos\\theta \\, d\\theta\\right)^{2} = (r'(\\psi))^{2} \\sin^{2}\\theta \\, d\\psi^{2} + 2r(\\psi)r'(\\psi) \\sin\\theta \\cos\\theta \\, d\\psi d\\theta + r(\\psi)^{2} \\cos^{2}\\theta \\, d\\theta^{2}$$\nSumming these two expressions, the cross-product terms $d\\psi d\\theta$ cancel:\n$$dR^{2} + dZ^{2} = \\left((r'(\\psi))^{2} \\cos^{2}\\theta + (r'(\\psi))^{2} \\sin^{2}\\theta\\right) d\\psi^{2} + \\left(r(\\psi)^{2} \\sin^{2}\\theta + r(\\psi)^{2} \\cos^{2}\\theta\\right) d\\theta^{2}$$\nUsing the fundamental trigonometric identity $\\sin^{2}\\theta + \\cos^{2}\\theta = 1$, the expression simplifies to:\n$$dR^{2} + dZ^{2} = (r'(\\psi))^{2} d\\psi^{2} + r(\\psi)^{2} d\\theta^{2} = \\left(\\frac{dr}{d\\psi}\\right)^{2} d\\psi^{2} + r(\\psi)^{2} d\\theta^{2}$$\nSubstituting this result and the expression for $R$ into the original line element $ds^{2}$ yields:\n$$ds^{2} = \\left(\\frac{dr}{d\\psi}\\right)^{2} d\\psi^{2} + r(\\psi)^{2} d\\theta^{2} + (R_{0} + r(\\psi)\\cos\\theta)^{2} d\\phi^{2}$$\nThe general form of the line element is $ds^{2} = \\sum_{i,j=1}^{3} g_{ij} dx^{i} dx^{j}$, where the coordinates are $(x^{1}, x^{2}, x^{3}) = (\\psi, \\theta, \\phi)$. By comparing our result to this general form, we identify the components of the covariant metric tensor $g_{ij}$. Since there are no cross-terms (e.g., $d\\psi d\\theta$), the metric is diagonal. The diagonal components are:\n$$g_{\\psi\\psi} = \\left(\\frac{dr}{d\\psi}\\right)^{2}$$\n$$g_{\\theta\\theta} = r(\\psi)^{2}$$\n$$g_{\\phi\\phi} = (R_{0} + r(\\psi)\\cos\\theta)^{2}$$\nAll off-diagonal components are zero, $g_{ij} = 0$ for $i \\neq j$. The metric tensor in matrix representation is:\n$$ g_{ij} = \\begin{pmatrix} \\left(\\frac{dr}{d\\psi}\\right)^{2}  0  0 \\\\ 0  r(\\psi)^{2}  0 \\\\ 0  0  (R_{0} + r(\\psi)\\cos\\theta)^{2} \\end{pmatrix} $$\nThe final step is to calculate the determinant of this tensor, $g \\equiv \\det(g_{ij})$. For a diagonal matrix, the determinant is the product of its diagonal elements:\n$$g = g_{\\psi\\psi} \\, g_{\\theta\\theta} \\, g_{\\phi\\phi}$$\n$$g = \\left(\\frac{dr}{d\\psi}\\right)^{2} r(\\psi)^{2} (R_{0} + r(\\psi)\\cos\\theta)^{2}$$\nThis is the final expression for the determinant of the metric tensor in the specified toroidal coordinates, expressed in terms of the required variables.",
            "answer": "$$\n\\boxed{r(\\psi)^{2} \\left(\\frac{dr}{d\\psi}\\right)^{2} (R_{0} + r(\\psi)\\cos\\theta)^{2}}\n$$"
        },
        {
            "introduction": "This final practice bridges the gap between analytical theory and practical computation, where the concepts we've developed find their ultimate application. You are tasked with implementing a field-aligned mesh, a grid structure that is optimally oriented with the magnetic field lines, which significantly improves the accuracy and efficiency of plasma simulations. By programming the coordinate transformations and using the metric tensor to perform an accurate interpolation , you will gain direct experience with the computational techniques at the heart of modern fusion modeling codes.",
            "id": "3960106",
            "problem": "Implement a complete program that constructs a field-aligned mesh on a single toroidal magnetic flux surface and computes metric-aware interpolation weights for query points. The setting is an axisymmetric, large-aspect-ratio, circular tokamak model where a flux surface of minor radius $r$ is embedded in three-dimensional Euclidean space using cylindrical coordinates. All angles must be expressed in radians, and all lengths must be expressed in meters in the International System of Units (SI). The final output must be dimensionless, rounded to $8$ decimal places.\n\nYou must start from the following fundamental base and core definitions, without introducing any additional assumptions beyond those listed here.\n\n- The three-dimensional Euclidean line element in cylindrical coordinates $(R,\\phi,Z)$ is given by the quadratic form $ds^2 = dR^2 + R^2 d\\phi^2 + dZ^2$.\n- A circular, concentric, axisymmetric tokamak flux surface is parameterized by the major radius $R_0$ and the minor radius $r$, with poloidal angle $\\theta$ and toroidal angle $\\zeta$ defined such that $R(\\theta) = R_0 + r \\cos\\theta$, $Z(\\theta) = r \\sin\\theta$, and $\\phi = \\zeta$.\n- The magnetic safety factor $q$ is defined as the ratio $d\\zeta/d\\theta$ along a magnetic field line on the surface (i.e., a field line advances toroidally by $q$ turns when advancing poloidally by one turn). This implies that a field-line aligned coordinate can be formed by $\\alpha = \\theta - \\zeta/q$, which is constant along a field line.\n\nYour program must implement the following tasks in a mathematically principled way.\n\n1. Construct a uniform, field-aligned, doubly periodic mesh on the given flux surface using coordinates $(\\alpha,\\zeta)$ with $\\alpha \\in [0,2\\pi)$ and $\\zeta \\in [0,2\\pi)$. Use $N_\\alpha$ uniformly spaced nodes in $\\alpha$ and $N_\\zeta$ uniformly spaced nodes in $\\zeta$. Map each mesh node $(\\alpha_i,\\zeta_j)$ to the geometric angles $(\\theta_{i,j},\\zeta_{j})$ on the surface via $\\theta_{i,j} = \\alpha_i + \\zeta_j/q$.\n2. For each query point $(\\theta_q,\\zeta_q)$, determine the indices of the four neighboring mesh nodes in $(\\alpha,\\zeta)$-space that form the smallest surrounding cell under periodicity on $[0,2\\pi)$ in each angular direction. Make sure to apply periodic wrap-around at the boundaries.\n3. Compute the covariant metric tensor on the flux surface induced by the Euclidean line element, using the chain rule applied to the surface parameterization. Then transform this metric into the field-aligned coordinate basis $(\\alpha,\\zeta)$ at the query location. Do not assume orthogonality in the transformed basis.\n4. For the four identified neighboring nodes, compute the metric-aware distances from the query point using the quadratic form induced by the covariant metric tensor in $(\\alpha,\\zeta)$. Use the principal value of angular differences in each periodic direction to form the displacement vector in $(\\alpha,\\zeta)$ coordinates, and evaluate the quadratic form at the query location. Use the inverse-distance weighting rule with exponent $p = 1$ to define interpolation weights, normalized so that they sum to one. If the query point coincides exactly with a mesh node (to within a small tolerance), assign weight $1$ to that node and weight $0$ to the other three.\n5. Output, for each query point, the ordered list of four weights corresponding to the four corners of the surrounding cell, in the order $[\\text{lower-left},\\text{lower-right},\\text{upper-left},\\text{upper-right}]$ with respect to increasing $(\\alpha,\\zeta)$. Each weight must be rounded to $8$ decimal places. The list is dimensionless.\n\nAngle unit requirement: All angles must be in radians. Length unit requirement: All lengths must be in meters.\n\nTest suite and parameters:\n- Geometry and mesh parameters common to all test cases: $R_0 = 3.0$, $r = 0.3$, $q = 2.2$, $N_\\alpha = 16$, $N_\\zeta = 12$.\n- Query points $(\\theta_q,\\zeta_q)$ to be evaluated:\n  - Case $1$ (general interior case): $(\\theta_q,\\zeta_q) = (1.3, 2.0)$.\n  - Case $2$ (near-periodic wrap-around): $(\\theta_q,\\zeta_q) = (6.1, 6.0)$.\n  - Case $3$ (exact node co-location): $(\\theta_q,\\zeta_q) = (0.0, 0.0)$.\n\nFinal output format:\n- Your program should produce a single line of output containing the three results as a comma-separated list enclosed in square brackets, where each result is itself a list of four decimal numbers rounded to $8$ decimal places. For example, the overall format must be exactly\n[ [w00_case1,w10_case1,w01_case1,w11_case1], [w00_case2,w10_case2,w01_case2,w11_case2], [w00_case3,w10_case3,w01_case3,w11_case3] ]\nbut without spaces. Your program should therefore print a single line:\n\"[[w00_case1,w10_case1,w01_case1,w11_case1],[w00_case2,w10_case2,w01_case2,w11_case2],[w00_case3,w10_case3,w01_case3,w11_case3]]\"\nwith each $w$ rounded to $8$ decimal places.\n\nNotes:\n- Your implementation must not hard-code the metric components; instead, derive them from the specified fundamental base in your code.\n- All intermediate computations must be consistent with the stated units. The output weights are dimensionless and must be reported as decimal numbers rounded to $8$ decimal places.",
            "solution": "The objective is to compute metric-aware interpolation weights for specified query points on a toroidal magnetic flux surface. The solution is developed through a sequence of principled steps: derivation of the surface metric tensor, construction of a field-aligned coordinate system and mesh, identification of neighboring mesh nodes, and application of an inverse-distance weighting scheme.\n\n**1. Coordinate Systems and Mesh Definition**\n\nThe problem defines a toroidal flux surface within a three-dimensional Euclidean space described by cylindrical coordinates $(R, \\phi, Z)$. The line element in this space is $ds^2 = dR^2 + R^2 d\\phi^2 + dZ^2$. The surface itself is parameterized using a poloidal angle $\\theta$ and a toroidal angle $\\zeta$, where the mapping to cylindrical coordinates is given by:\n$$R(\\theta) = R_0 + r \\cos\\theta$$\n$$Z(\\theta) = r \\sin\\theta$$\n$$\\phi = \\zeta$$\nHere, $R_0$ is the major radius of the torus and $r$ is the minor radius of the flux surface.\n\nA field-aligned coordinate system $(\\alpha, \\zeta)$ is introduced. The coordinate $\\alpha$ is constant along a magnetic field line and is defined by the relation $\\alpha = \\theta - \\zeta/q$, where $q$ is the safety factor. This implies the transformation from the computational coordinates $(\\alpha, \\zeta)$ to the geometric angles $(\\theta, \\zeta)$ is:\n$$\\theta(\\alpha, \\zeta) = \\alpha + \\frac{\\zeta}{q}$$\n$$\\zeta(\\alpha, \\zeta) = \\zeta$$\nA uniform, doubly periodic mesh is constructed in the computational domain $(\\alpha, \\zeta) \\in [0, 2\\pi) \\times [0, 2\\pi)$. With $N_\\alpha$ nodes in the $\\alpha$ direction and $N_\\zeta$ nodes in the $\\zeta$ direction, the mesh points $(\\alpha_i, \\zeta_j)$ are given by:\n$$\\alpha_i = i \\frac{2\\pi}{N_\\alpha}, \\quad i \\in \\{0, 1, \\dots, N_\\alpha - 1\\}$$\n$$\\zeta_j = j \\frac{2\\pi}{N_\\zeta}, \\quad j \\in \\{0, 1, \\dots, N_\\zeta - 1\\}$$\n\n**2. Covariant Metric Tensor Derivation**\n\nTo calculate distances on the surface, we first derive the covariant metric tensor $g_{\\mu\\nu}$ induced by the Euclidean embedding. The line element on the surface is $ds^2 = g_{\\mu\\nu} du^\\mu du^\\nu$, where $u^\\mu$ are the surface coordinates.\n\nFirst, we find the metric in the $(\\theta, \\zeta)$ basis. The tangent vectors are $\\mathbf{e}_\\theta = \\frac{\\partial\\mathbf{x}}{\\partial\\theta}$ and $\\mathbf{e}_\\zeta = \\frac{\\partial\\mathbf{x}}{\\partial\\zeta}$, where $\\mathbf{x} = (R\\cos\\phi, R\\sin\\phi, Z)$ is the position vector in Cartesian coordinates.\nThe partial derivatives are:\n$$\\frac{\\partial\\mathbf{x}}{\\partial\\theta} = \\begin{pmatrix} -r\\sin\\theta\\cos\\zeta \\\\ -r\\sin\\theta\\sin\\zeta \\\\ r\\cos\\theta \\end{pmatrix}$$\n$$\\frac{\\partial\\mathbf{x}}{\\partial\\zeta} = \\begin{pmatrix} -(R_0 + r\\cos\\theta)\\sin\\zeta \\\\ (R_0 + r\\cos\\theta)\\cos\\zeta \\\\ 0 \\end{pmatrix}$$\nThe metric components are the dot products of these tangent vectors:\n$$g_{\\theta\\theta} = \\frac{\\partial\\mathbf{x}}{\\partial\\theta} \\cdot \\frac{\\partial\\mathbf{x}}{\\partial\\theta} = r^2\\sin^2\\theta(\\cos^2\\zeta + \\sin^2\\zeta) + r^2\\cos^2\\theta = r^2$$\n$$g_{\\zeta\\zeta} = \\frac{\\partial\\mathbf{x}}{\\partial\\zeta} \\cdot \\frac{\\partial\\mathbf{x}}{\\partial\\zeta} = (R_0+r\\cos\\theta)^2(\\sin^2\\zeta + \\sin^2\\zeta) = (R_0+r\\cos\\theta)^2$$\n$$g_{\\theta\\zeta} = \\frac{\\partial\\mathbf{x}}{\\partial\\theta} \\cdot \\frac{\\partial\\mathbf{x}}{\\partial\\zeta} = 0$$\nThe metric tensor in the $(\\theta, \\zeta)$ basis, which we denote $g$, is diagonal:\n$$g_{(\\theta,\\zeta)} = \\begin{pmatrix} r^2  0 \\\\ 0  (R_0+r\\cos\\theta)^2 \\end{pmatrix}$$\n\nNext, we transform this metric to the field-aligned $(\\alpha, \\zeta)$ basis. The transformation rule for a covariant tensor of rank 2 is $g' = J^T g J$, where $J$ is the Jacobian matrix of the transformation from the new coordinates $(\\alpha, \\zeta)$ to the old coordinates $(\\theta, \\zeta)$.\n$$J = \\frac{\\partial(\\theta, \\zeta)}{\\partial(\\alpha, \\zeta)} = \\begin{pmatrix} \\frac{\\partial\\theta}{\\partial\\alpha}  \\frac{\\partial\\theta}{\\partial\\zeta} \\\\ \\frac{\\partial\\zeta}{\\partial\\alpha}  \\frac{\\partial\\zeta}{\\partial\\zeta} \\end{pmatrix} = \\begin{pmatrix} 1  1/q \\\\ 0  1 \\end{pmatrix}$$\nPerforming the matrix multiplication:\n$$g'_{(\\alpha,\\zeta)} = \\begin{pmatrix} 1  0 \\\\ 1/q  1 \\end{pmatrix} \\begin{pmatrix} r^2  0 \\\\ 0  (R_0+r\\cos\\theta)^2 \\end{pmatrix} \\begin{pmatrix} 1  1/q \\\\ 0  1 \\end{pmatrix}$$\n$$g'_{(\\alpha,\\zeta)} = \\begin{pmatrix} r^2  r^2/q \\\\ r^2/q  r^2/q^2 + (R_0+r\\cos\\theta)^2 \\end{pmatrix}$$\nThe components of the metric in the non-orthogonal $(\\alpha, \\zeta)$ basis are:\n$$g_{\\alpha\\alpha} = r^2$$\n$$g_{\\alpha\\zeta} = g_{\\zeta\\alpha} = \\frac{r^2}{q}$$\n$$g_{\\zeta\\zeta} = \\frac{r^2}{q^2} + (R_0+r\\cos\\theta)^2$$\nNote that the components depend on the geometric angle $\\theta$, which must be evaluated at the location of interest.\n\n**3. Interpolation Algorithm**\n\nFor a given query point $(\\theta_q, \\zeta_q)$, the interpolation weights are computed as follows:\n\n1.  **Coordinate Transformation**: The query point is transformed into the computational $(\\alpha, \\zeta)$ coordinates:\n    $$\\alpha_q = \\theta_q - \\zeta_q/q$$\n    $$\\zeta_q = \\zeta_q$$\n    These angles are then wrapped to the principal domain $[0, 2\\pi)$ using the modulo operation. Let the wrapped coordinates be $(\\alpha'_q, \\zeta'_q)$.\n\n2.  **Neighbor Identification**: The indices $(i_0, j_0)$ of the lower-left mesh node of the cell containing the query point are found by:\n    $$i_0 = \\left\\lfloor \\frac{\\alpha'_q}{\\Delta\\alpha} \\right\\rfloor, \\quad j_0 = \\left\\lfloor \\frac{\\zeta'_q}{\\Delta\\zeta} \\right\\rfloor$$\n    where $\\Delta\\alpha = 2\\pi/N_\\alpha$ and $\\Delta\\zeta = 2\\pi/N_\\zeta$ are the mesh spacings. The four surrounding cell corners are at indices $(i_0, j_0)$, $(i_0+1, j_0)$, $(i_0, j_0+1)$, and $(i_0+1, j_0+1)$, with indices taken modulo $N_\\alpha$ and $N_\\zeta$ respectively to handle periodicity.\n\n3.  **Distance Calculation**: The squared distance $d_k^2$ from the query point $(\\alpha'_q, \\zeta'_q)$ to each neighboring node $k$ at $(\\alpha_k, \\zeta_k)$ is computed using the quadratic form induced by the metric $g'_{(\\alpha,\\zeta)}$ evaluated at $\\theta_q$:\n    $$d_k^2 = g_{\\alpha\\alpha}(\\Delta\\alpha_k)^2 + 2 g_{\\alpha\\zeta}(\\Delta\\alpha_k)(\\Delta\\zeta_k) + g_{\\zeta\\zeta}(\\Delta\\zeta_k)^2$$\n    The displacements $(\\Delta\\alpha_k, \\Delta\\zeta_k) = (\\alpha'_q - \\alpha_k, \\zeta'_q - \\zeta_k)$ must be calculated as the shortest angle on the circle (principal value) to respect the periodic nature of the domain. For an angular difference $\\delta$, the principal value is $(\\delta + \\pi) \\pmod{2\\pi} - \\pi$, which lies in $(-\\pi, \\pi]$.\n\n4.  **Weight Computation**: The interpolation weights are determined using an inverse-distance scheme with exponent $p=1$. The unnormalized weight for node $k$ is $w'_k = 1/d_k$. These are then normalized to sum to unity:\n    $$w_k = \\frac{w'_k}{\\sum_{m} w'_m} = \\frac{1/d_k}{\\sum_{m} 1/d_m}$$\n    In the special case where a query point coincides with a mesh node (i.e., $d_k$ is below a small numerical tolerance), the weight for that node is set to $1$ and all other weights are set to $0$.\n\nThe resulting four weights, corresponding to the cell corners in the order [lower-left, lower-right, upper-left, upper-right], are then reported for each query point.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the full problem specification: constructing a field-aligned mesh,\n    computing the metric tensor, and calculating metric-aware interpolation weights.\n    \"\"\"\n    R0 = 3.0\n    r = 0.3\n    q = 2.2\n    N_alpha = 16\n    N_zeta = 12\n\n    test_cases = [\n        (1.3, 2.0),   # Case 1 (general interior case)\n        (6.1, 6.0),   # Case 2 (near-periodic wrap-around)\n        (0.0, 0.0),   # Case 3 (exact node co-location)\n    ]\n\n    all_results = []\n    \n    # Mesh spacings\n    d_alpha = 2 * np.pi / N_alpha\n    d_zeta = 2 * np.pi / N_zeta\n    \n    # Numerical tolerance for co-location check\n    epsilon = 1e-12\n\n    for theta_q, zeta_q in test_cases:\n        # Step 3: Compute the covariant metric tensor at the query location\n        g_aa = r**2\n        g_az = r**2 / q\n        # The metric depends on the geometric angle theta_q\n        g_zz = (r / q)**2 + (R0 + r * np.cos(theta_q))**2\n\n        # Step 1 (cont.)  2: Transform query point and find neighbors\n        # Transform query point to computational coordinates\n        alpha_q_raw = theta_q - zeta_q / q\n        zeta_q_raw = zeta_q\n\n        # Wrap coordinates to the principal domain [0, 2*pi)\n        alpha_q = alpha_q_raw % (2 * np.pi)\n        zeta_q = zeta_q_raw % (2 * np.pi)\n\n        # Find indices of the lower-left node of the containing cell\n        i0 = int(np.floor(alpha_q / d_alpha))\n        j0 = int(np.floor(zeta_q / d_zeta))\n\n        # Node index offsets for the four corners of the cell\n        # Order: lower-left, lower-right, upper-left, upper-right\n        corner_offsets = [(0, 0), (1, 0), (0, 1), (1, 1)]\n        \n        distances = []\n        is_colocated = False\n        colocated_weights = []\n\n        # Step 4: Compute metric-aware distances and weights\n        for i_offset, j_offset in corner_offsets:\n            # Get node indices with periodic wrapping\n            i = (i0 + i_offset) % N_alpha\n            j = (j0 + j_offset) % N_zeta\n            \n            # Node coordinates in (alpha, zeta) space\n            alpha_k = i * d_alpha\n            zeta_k = j * d_zeta\n            \n            # Compute displacement vector using principal value of angular difference\n            delta_alpha = (alpha_q - alpha_k + np.pi) % (2 * np.pi) - np.pi\n            delta_zeta = (zeta_q - zeta_k + np.pi) % (2 * np.pi) - np.pi\n            \n            # Distance calculation using the quadratic form from the metric\n            d_squared = (g_aa * delta_alpha**2 +\n                         2 * g_az * delta_alpha * delta_zeta +\n                         g_zz * delta_zeta**2)\n            \n            # Avoid sqrt of negative due to floating point error\n            if d_squared  0:\n                d_squared = 0\n            \n            dist = np.sqrt(d_squared)\n            \n            # Check for co-location\n            if dist  epsilon:\n                is_colocated = True\n                # Assign 1 to this node, 0 to others\n                colocated_weights = [0.0] * 4\n                current_node_index = corner_offsets.index((i_offset, j_offset))\n                colocated_weights[current_node_index] = 1.0\n                break # Exit the corner loop\n            \n            distances.append(dist)\n        \n        if is_colocated:\n            weights = colocated_weights\n        else:\n            # Inverse-distance weighting with p=1\n            inv_distances = [1.0 / d for d in distances]\n            sum_inv_distances = sum(inv_distances)\n            \n            weights = [inv_d / sum_inv_distances for inv_d in inv_distances]\n\n        all_results.append(weights)\n\n    # Final output formatting\n    # Format each weight to 8 decimal places\n    formatted_results = []\n    for res in all_results:\n        formatted_res = [f\"{w:.8f}\" for w in res]\n        formatted_results.append(f\"[{','.join(formatted_res)}]\")\n    \n    final_output_string = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}