{
    "hands_on_practices": [
        {
            "introduction": "在我们能够控制等离子体剖面之前，我们必须首先建立一个能够预测其演化的数学模型。本练习将指导您完成一个基础过程：将描述等离子体输运的连续偏微分方程（PDE）转化为适合计算机处理的离散状态空间表示。您将学习如何应用有限差分法并正确实施物理边界条件，这些是为模型预测控制（MPC）开发任何高保真度预测模型所必需的关键技能 。",
            "id": "4013847",
            "problem": "在用于等离子体剖面演化的模型预测控制 (MPC) 中，预测模型通常包含一个描述一维小半径坐标 $x \\in [0,L]$ 上电子温度剖面 $T_{e}(x,t)$ 和电子密度剖面 $n_{e}(x,t)$ 的扩散偏微分方程 (PDE)。考虑以下常数扩散系数的扩散模型\n$$\\frac{\\partial T_{e}}{\\partial t} = \\frac{\\partial}{\\partial x}\\!\\left(\\chi_{e}\\,\\frac{\\partial T_{e}}{\\partial x}\\right), \\qquad \\frac{\\partial n_{e}}{\\partial t} = \\frac{\\partial}{\\partial x}\\!\\left(D_{n}\\,\\frac{\\partial n_{e}}{\\partial x}\\right),$$\n其边界条件源于托卡马克的对称性和边缘控制：\n$$\\frac{\\partial T_{e}}{\\partial x}(0,t)=0,\\quad \\frac{\\partial n_{e}}{\\partial x}(0,t)=0 \\quad \\text{（磁轴处为诺伊曼(Neumann)条件）},$$\n$$T_{e}(L,t)=T_{L},\\quad n_{e}(L,t)=n_{L} \\quad \\text{（边缘处为狄利克雷(Dirichlet)条件）}。$$\n你将使用均匀网格和二阶中心差分方法对这些方程进行空间离散化，以构建 MPC 线性预测模型中使用的离散扩散算子。\n\n使用以下规格：\n- 区域长度 $L = 1\\,\\mathrm{m}$，使用均匀网格，有 $N=3$ 个内部未知数，位于 $x_{i}=i\\,\\Delta x$ 处，其中 $i\\in\\{1,2,3\\}$ 且 $\\Delta x = L/(N+1)$。\n- 对于 $x=0$ 处的左侧诺伊曼边界，使用与中心差分二阶相容的虚拟点构造来施加零梯度条件。\n- 对于 $x=L$ 处的右侧狄利克雷边界，将边界值消去并移至右侧项，使得算子矩阵仅与内部未知数 $\\{T_{e}(x_{i}),n_{e}(x_{i})\\}_{i=1}^{3}$ 相乘。\n- 电子热扩散系数 $\\chi_{e} = 3.0\\,\\mathrm{m^{2}\\,s^{-1}}$ 和粒子扩散系数 $D_{n} = 1.5\\,\\mathrm{m^{2}\\,s^{-1}}$ 是常数。\n- 考虑一个时间步长为 $\\Delta t = 10^{-3}\\,\\mathrm{s}$ 的隐式欧拉步，因此对于堆叠状态向量 $\\left[T_{e}(x_{1}),T_{e}(x_{2}),T_{e}(x_{3}),n_{e}(x_{1}),n_{e}(x_{2}),n_{e}(x_{3})\\right]^{\\top}$，其块对角状态转移矩阵为\n$$M \\;=\\; I_{2N} \\;-\\; \\Delta t \\,\\mathrm{diag}\\!\\big(\\,\\chi_{e} L,\\; D_{n} L\\,\\big),$$\n其中 $L\\in\\mathbb{R}^{N\\times N}$ 是与上述边界条件相容的离散拉普拉斯算子，而 $I_{2N}$ 是 $2N\\times 2N$ 的单位矩阵。\n\n任务：\n1. 从菲克定律 (Fick’s law) $q=-\\kappa \\,\\partial u/\\partial x$ 的守恒形式出发，在均匀网格上使用二阶中心差分，清晰地解释如何施加左侧诺伊曼和右侧狄利克雷边界条件，以获得作用于内部未知数的离散算子 $L$。你的解释必须明确使用虚拟点处理诺伊曼条件，并使用消元法处理狄利克雷条件。\n2. 对于给定的网格和边界条件，显式地计算矩阵 $L$ 的所有元素。\n3. 构建块 $\\chi_{e} L$ 和 $D_{n} L$，然后组装 $6\\times 6$ 矩阵 $M$。\n4. 以纯数形式（无单位）报告矩阵 $M$ 的 (2,2) 元素。将答案四舍五入到四位有效数字。",
            "solution": "首先对问题进行验证，以确保其科学上合理、适定且客观。\n\n### 问题验证\n\n**1. 提取已知条件：**\n- **偏微分方程：** $\\frac{\\partial T_{e}}{\\partial t} = \\frac{\\partial}{\\partial x}\\!\\left(\\chi_{e}\\,\\frac{\\partial T_{e}}{\\partial x}\\right)$ 和 $\\frac{\\partial n_{e}}{\\partial t} = \\frac{\\partial}{\\partial x}\\!\\left(D_{n}\\,\\frac{\\partial n_{e}}{\\partial x}\\right)$。\n- **区域：** $x \\in [0,L]$。\n- **边界条件：**\n    - $x=0$ 处的诺伊曼条件：$\\frac{\\partial T_{e}}{\\partial x}(0,t)=0$, $\\frac{\\partial n_{e}}{\\partial x}(0,t)=0$。\n    - $x=L$ 处的狄利克雷条件：$T_{e}(L,t)=T_{L}$, $n_{e}(L,t)=n_{L}$。\n- **离散化：**\n    - 均匀网格，有 $N=3$ 个内部未知数，位于 $x_{i}=i\\,\\Delta x$ 处，其中 $i\\in\\{1,2,3\\}$。\n    - 网格间距：$\\Delta x = L/(N+1)$。\n    - 左边界条件：使用二阶虚拟点构造施加零梯度。\n    - 右边界条件：消元并移至右侧项。\n- **常数：**\n    - $L = 1\\,\\mathrm{m}$。\n    - $\\chi_{e} = 3.0\\,\\mathrm{m^{2}\\,s^{-1}}$。\n    - $D_{n} = 1.5\\,\\mathrm{m^{2}\\,s^{-1}}$。\n    - $\\Delta t = 10^{-3}\\,\\mathrm{s}$。\n- **矩阵模型：** $M = I_{2N} - \\Delta t \\,\\mathrm{diag}\\!\\big(\\,\\chi_{e} L,\\; D_{n} L\\,\\big)$，其中 $N=3$ 且 $L \\in \\mathbb{R}^{N \\times N}$。状态向量堆叠为 $\\left[T_{e}(x_1), T_{e}(x_2), T_{e}(x_3), n_{e}(x_1), n_{e}(x_2), n_{e}(x_3)\\right]^{\\top}$。\n- **任务：**\n    1. 推导离散算子 $L$。\n    2. 计算矩阵 $L$。\n    3. 组装 $6\\times 6$ 矩阵 $M$。\n    4. 将 $M_{22}$ 报告至四位有效数字。\n\n**2. 验证分析：**\n该问题有科学依据，描述了等离子体输运的标准扩散模型及其通过直线法进行的数值求解，这些都是计算物理学中的成熟做法。该问题是适定的，为求得唯一解提供了所有必要的参数和条件。所用术语客观而精确。在控制理论中，将 $M$ 称为“状态转移矩阵”的措辞略有不当，因为 $M$ 是隐式系统 $(I - \\Delta t A) y^{k+1} = y^k$ 的矩阵，而不是显式传播子 $y^{k+1} = A_d y^k$。然而，$M$ 的数学定义是明确的，因此这不构成一个缺陷。因此，该问题被认为是有效的。\n\n### 解答\n\n解答过程首先离散化通用常数扩散系数扩散方程 $\\frac{\\partial u}{\\partial t} = D \\frac{\\partial^2 u}{\\partial x^2}$ 以构建离散拉普拉斯算子 $L$，然后组装矩阵 $M$。\n\n**任务1：离散算子 $L$ 的推导**\n\n区域 $[0, L]$ 被离散化为 $N=3$ 个内部点。网格点为 $x_0=0, x_1, x_2, x_3, x_4=L$。网格间距为 $\\Delta x = \\frac{L}{N+1} = \\frac{1}{3+1} = \\frac{1}{4}$。对于单个剖面 $u(x,t)$，未知数的状态向量为 $\\vec{u}(t) = [u(x_1,t), u(x_2,t), u(x_3,t)]^{\\top} = [u_1, u_2, u_3]^{\\top}$。\n\n对于常数扩散系数 $D$，守恒形式 $\\frac{\\partial u}{\\partial t} = -\\frac{\\partial q}{\\partial x}$ 和菲克定律 (Fick's law) $q = -D \\frac{\\partial u}{\\partial x}$ 可简化为 $\\frac{\\partial u}{\\partial t} = D \\frac{\\partial^2 u}{\\partial x^2}$。我们使用二阶中心差分来近似空间二阶导数：\n$$ \\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{x_i} \\approx \\frac{u_{i+1} - 2u_i + u_{i-1}}{(\\Delta x)^2} $$\n这就得到了半离散化的常微分方程 (ODE) 系统 $\\frac{d\\vec{u}}{dt} = D L \\vec{u} + \\vec{b}$，其中 $L$ 是离散拉普拉斯算子。\n\n- **内部节点 ($i=2$):** 对于节点 $x_2$，其所有相邻点 ($x_1, x_3$) 都是内部点。离散化是标准的：\n$$ \\frac{du_2}{dt} = D \\frac{u_3 - 2u_2 + u_1}{(\\Delta x)^2} $$\n这对应于 $L$ 的第二行为 $\\frac{1}{(\\Delta x)^2}[1, -2, 1]$。\n\n- **左边界（$x=0$ 处的诺伊曼条件，影响节点 $i=1$）：**\n$u_1$ 的方程为 $\\frac{du_1}{dt} = D \\frac{u_2 - 2u_1 + u_0}{(\\Delta x)^2}$，其中 $u_0 = u(0,t)$ 是边界点的值。为了以二阶精度施加诺伊曼边界条件 $\\frac{\\partial u}{\\partial x}(0,t) = 0$，我们使用一个单侧差分公式来表示 $u_0$。在 $x=0$ 处的二阶前向差分近似为：\n$$ \\frac{\\partial u}{\\partial x}\\bigg|_{x=0} \\approx \\frac{-3u_0 + 4u_1 - u_2}{2\\Delta x} = 0 $$\n由此可解得 $u_0 = \\frac{4u_1 - u_2}{3}$。这个代数关系是二阶精确的。将其代入 $u_1$ 的常微分方程：\n$$ \\frac{du_1}{dt} = \\frac{D}{(\\Delta x)^2} \\left(u_2 - 2u_1 + \\frac{4u_1 - u_2}{3}\\right) = \\frac{D}{(\\Delta x)^2} \\left( -\\frac{2}{3}u_1 + \\frac{2}{3}u_2 \\right) $$\n这给出了算子 $L$ 的第一行。\n\n- **右边界（$x=L$ 处的狄利克雷条件，影响节点 $i=3$）：**\n$u_3$ 的方程为 $\\frac{du_3}{dt} = D \\frac{u_4 - 2u_3 + u_2}{(\\Delta x)^2}$。边界条件为 $u(L,t) = u_4 = u_L$。如问题所述，这个非齐次边界条件被消去并移至一个源项。\n$$ \\frac{du_3}{dt} = \\frac{D}{(\\Delta x)^2} (u_2 - 2u_3) + \\frac{D u_L}{(\\Delta x)^2} $$\n算子 $L$ 作用于状态向量 $[u_1, u_2, u_3]^{\\top}$。因此，$L$ 的第三行为 $\\frac{1}{(\\Delta x)^2}[0, 1, -2]$。\n\n**任务2：矩阵 $L$ 的计算**\n\n当 $L=1$ 且 $N=3$ 时，我们有 $\\Delta x = \\frac{1}{4}$，所以 $\\frac{1}{(\\Delta x)^2} = 16$。组装上面推导出的各行：\n$$ L = \\frac{1}{(\\Delta x)^2} \\begin{pmatrix} -2/3 & 2/3 & 0 \\\\ 1 & -2 & 1 \\\\ 0 & 1 & -2 \\end{pmatrix} = 16 \\begin{pmatrix} -2/3 & 2/3 & 0 \\\\ 1 & -2 & 1 \\\\ 0 & 1 & -2 \\end{pmatrix} = \\begin{pmatrix} -32/3 & 32/3 & 0 \\\\ 16 & -32 & 16 \\\\ 0 & 16 & -32 \\end{pmatrix} $$\n\n**任务3：$6 \\times 6$ 矩阵 $M$ 的组装**\n\n矩阵 $M$ 定义为 $M = I_{6} - \\Delta t \\,\\mathrm{diag}\\!\\big(\\,\\chi_{e} L,\\; D_{n} L\\,\\big)$。这是一个块对角矩阵：\n$$ M = \\begin{pmatrix} I_3 - \\Delta t \\chi_e L & 0 \\\\ 0 & I_3 - \\Delta t D_n L \\end{pmatrix} $$\n状态向量的顺序为 $[T_{e1}, T_{e2}, T_{e3}, n_{e1}, n_{e2}, n_{e3}]^{\\top}$。因此，$M$ 的 (2,2) 元素是左上角块 $M_{TT} = I_3 - \\Delta t \\chi_e L$ 的 (2,2) 元素。\n该块的 (i,j) 元素为 $(M_{TT})_{ij} = \\delta_{ij} - \\Delta t \\chi_e L_{ij}$，其中 $\\delta_{ij}$ 是克罗内克 δ (Kronecker delta)。\n\n**任务4：报告 $M$ 的 (2,2) 元素**\n\n我们需要计算 $M_{22}$。\n$$ M_{22} = (I_3)_{22} - \\Delta t \\chi_{e} L_{22} $$\n根据任务2中计算的矩阵 $L$，$L_{22} = -32$。\n给定的常数为 $\\Delta t = 10^{-3}\\,\\mathrm{s}$ 和 $\\chi_{e} = 3.0\\,\\mathrm{m^{2}\\,s^{-1}}$。\n$$ M_{22} = 1 - (10^{-3}) \\times (3.0) \\times (-32) $$\n$$ M_{22} = 1 - (0.003) \\times (-32) $$\n$$ M_{22} = 1 + 0.096 $$\n$$ M_{22} = 1.096 $$\n问题要求将答案四舍五入到四位有效数字。数字 $1.096$ 已经有四位有效数字。",
            "answer": "$$\\boxed{1.096}$$"
        },
        {
            "introduction": "模型预测控制（MPC）的一个关键挑战是保证控制器在长时间运行中保持稳定和安全，尤其是在模型存在不确定性的情况下。本练习深入探讨了鲁棒终端集这一先进概念，它是确保鲁棒MPC递归可行性和稳定性的基石。通过设计一个镇定反馈律并计算一个鲁棒正不变集，您将学习如何从形式上保证控制器始终能将等离子体状态维持在安全的操作范围内 。",
            "id": "4013766",
            "problem": "考虑一个具有有界建模误差的离散时间线性化等离子体剖面模型。设采样时刻 $k$ 的状态偏差为 $x_k \\in \\mathbb{R}^n$，执行器输入为 $u_k \\in \\mathbb{R}^m$，有界建模误差为 $w_k \\in \\mathbb{R}^n$。该线性化模型为\n$$\nx_{k+1} = A x_k + B u_k + w_k,\n$$\n其中 $A \\in \\mathbb{R}^{n \\times n}$ 和 $B \\in \\mathbb{R}^{n \\times m}$ 是已知矩阵，通过对一个标称平衡点附近的输运主导的等离子体剖面演化进行线性化得到。建模误差被假设为分量上可加且有界，即 $w_k \\in W$，其中\n$$\nW = \\{ w \\in \\mathbb{R}^n : |w_i| \\le w_{\\max,i}, \\; i = 1, \\dots, n \\}.\n$$\n我们施加严格的按分量施加的状态和输入约束\n$$\nX = \\{ x \\in \\mathbb{R}^n : |x_i| \\le x_{\\max,i}, \\; i = 1, \\dots, n \\}, \\quad U = \\{ u \\in \\mathbb{R}^m : |u_j| \\le u_{\\max,j}, \\; j = 1, \\dots, m \\}.\n$$\n在模型预测控制 (MPC) 中，鲁棒终端集 $X_f \\subseteq X$ 与辅助线性状态反馈控制律 $u_k = K x_k$ 结合使用，以保证递推可行性和闭环稳定性。增益 $K \\in \\mathbb{R}^{m \\times n}$ 必须选择以稳定该线性化模型，并且鲁棒终端集在所有建模误差 $w_k \\in W$ 下必须是正不变的，且对于所有 $x \\in X_f$ 都必须满足输入约束。\n\n如果对于闭环系统的所有 $x \\in S$ 和所有 $w \\in W$，其后继状态 $x^+ = (A + B K) x + w$ 满足 $x^+ \\in S$，则集合 $S \\subseteq \\mathbb{R}^n$ 被称为鲁棒正不变 (RPI) 集。在输入约束 $U$ 和控制律 $u_k = K x_k$ 下，$X$ 的最大鲁棒正不变 (mRPI) 子集是最大的子集 $S^\\star \\subseteq X$，该子集是 RPI 且满足 $K S^\\star \\subseteq U$。\n\n您必须通过以下方式设计一个鲁棒终端集：\n- 使用离散线性二次调节器 (DLQR) 结构，从离散代数黎卡提方程 (DARE) 中选择一个稳定的线性状态反馈增益 $K$，其对状态和输入具有二次代价。使用传统的 DLQR 代价选择 $J = \\sum_{k=0}^{\\infty} (x_k^\\top Q x_k + u_k^\\top R u_k)$，其中 $Q \\succeq 0$ 且 $R \\succ 0$，并使用最小化代价的符号约定来实现控制律 $u_k = K x_k$。\n- 构建一个鲁棒终端集 $X_f$，它是一个与坐标轴对齐的超矩形 $X_f = \\{ x : |x_i| \\le r_i \\}$，该超矩形在所有 $w \\in W$ 下都是正不变的，并满足输入约束，然后计算其包含在 $X$ 中的最大鲁棒正不变子集。\n\n对于以下测试套件，计算每种情况下 $S^\\star$，并报告每种情况下超矩形的按分量半径（如果非空）。如果 $S^\\star$ 为空（在约束下不存在非空 RPI 子集），则为该情况输出数字 $-1.0$。不需要物理单位；所有量均为无量纲。不涉及角度。您的程序必须生成一行包含 Python 风格列表的输出，该列表按本问题末尾描述的精确格式聚合所有测试用例的结果。\n\n测试套件：\n- 情况 1（一维）：\n  - $n = 1$，$m = 1$。\n  - $A = [0.5]$，$B = [0.7]$。\n  - $Q = [1.0]$，$R = [1.0]$。\n  - $x_{\\max} = [2.0]$，$u_{\\max} = [2.0]$。\n  - $w_{\\max} = [0.1]$。\n- 情况 2（二维，对角线，设计上解耦）：\n  - $n = 2$，$m = 2$。\n  - $A = \\begin{bmatrix} 0.7 & 0.0 \\\\ 0.0 & 0.55 \\end{bmatrix}$，$B = \\begin{bmatrix} 0.6 & 0.0 \\\\ 0.0 & 0.4 \\end{bmatrix}$。\n  - $Q = \\begin{bmatrix} 1.0 & 0.0 \\\\ 0.0 & 0.8 \\end{bmatrix}$，$R = \\begin{bmatrix} 0.3 & 0.0 \\\\ 0.0 & 0.3 \\end{bmatrix}$。\n  - $x_{\\max} = [1.0, 0.6]$，$u_{\\max} = [2.0, 1.0]$。\n  - $w_{\\max} = [0.05, 0.02]$。\n- 情况 3（一维，由于大型建模误差和接近边缘稳定性的弱致动而不可行）：\n  - $n = 1$，$m = 1$。\n  - $A = [0.95]$，$B = [0.05]$。\n  - $Q = [1.0]$，$R = [1.0]$。\n  - $x_{\\max} = [0.5]$，$u_{\\max} = [10.0]$。\n  - $w_{\\max} = [0.2]$。\n\n输出规范：\n- 对于每种情况，如果存在非空的 $S^\\star$，计算最大鲁棒正不变超矩形 $S^\\star = \\{ x : |x_i| \\le r_i \\}$ 的按分量半径 $r_i$，需满足 $S^\\star \\subseteq X$ 和 $K S^\\star \\subseteq U$；否则返回数字 $-1.0$。\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，按测试用例的顺序排列结果。例如，对于三个测试用例，结果分别为 $r^{(1)}$、$[r^{(2)}_1, r^{(2)}_2]$ 和 $-1.0$，输出必须严格遵循格式 $\\texttt{[r^{(1)},[r^{(2)}_1,r^{(2)}_2],-1.0]}$。",
            "solution": "该问题要求为有界不确定性下的离散时间线性化等离子体剖面模型设计一个鲁棒终端集。这涉及两个主要步骤：首先，确定一个稳定的状态反馈增益 $K$；其次，构建一个满足给定状态和输入约束的尽可能大的鲁棒正不变 (RPI) 超矩形集。\n\n设系统动力学为 $x_{k+1} = A x_k + B u_k + w_k$，其中状态为 $x_k \\in \\mathbb{R}^n$，输入为 $u_k \\in \\mathbb{R}^m$，扰动为 $w_k \\in W = \\{ w \\in \\mathbb{R}^n : |w_i| \\le w_{\\max,i} \\}$。约束条件为 $|x_i| \\le x_{\\max,i}$ 和 $|u_j| \\le u_{\\max,j}$。控制律为线性反馈 $u_k = K x_k$。因此，闭环动力学为 $x_{k+1} = (A+BK)x_k + w_k = A_{cl}x_k + w_k$。\n\n### 步骤1：通过 DLQR 进行状态反馈增益综合\n\n问题指定使用离散线性二次调节器 (DLQR) 框架来寻找一个稳定的增益 $K$。需要最小化的代价函数是 $J = \\sum_{k=0}^{\\infty} (x_k^\\top Q x_k + u_k^\\top R u_k)$。最小化此代价的最优控制律是 $u_k = -K_{lqr} x_k$，其中增益 $K_{lqr}$ 由下式给出：\n$$\nK_{lqr} = (B^\\top P B + R)^{-1} B^\\top P A\n$$\n这里，$P$ 是离散代数黎卡提方程 (DARE) 的唯一对称半正定解：\n$$\nP = A^\\top P A - (A^\\top P B)(B^\\top P B + R)^{-1}(B^\\top P A) + Q\n$$\n问题将控制律定义为 $u_k = K x_k$。为与 DLQR 的代价最小化约定保持一致，我们设置控制增益 $K = -K_{lqr}$。可以使用 `scipy.linalg.solve_discrete_are` 函数求解 DARE 以得到 $P$。得到的闭环矩阵为 $A_{cl} = A + B K$。DARE 的解保证了 $A_{cl}$ 是舒尔稳定的（其所有特征值的模都小于1），前提是当 $Q=C^T C$ 时，对 $(A, B)$ 是可镇定的，对 $(A, C)$ 是可检测的。\n\n### 步骤2：最大鲁棒正不变 (RPI) 超矩形\n\n我们寻求最大的超矩形 $S^\\star = \\{ x \\in \\mathbb{R}^n : |x_i| \\le r_i, i=1,\\dots,n \\}$，它是一个对于闭环系统鲁棒正不变的集合，并且满足所有约束。设半径由向量 $r = [r_1, \\dots, r_n]^\\top$ 表示。\n\n$S^\\star$ 成为一个有效终端集的条件是：\n\n1.  **鲁棒正不变性**：对于任意状态 $x \\in S^\\star$ 和任意扰动 $w \\in W$，后继状态 $x^+ = A_{cl}x + w$ 也必须在 $S^\\star$ 中。\n    这意味着对于所有 $|x| \\le r$ 和 $|w| \\le w_{\\max}$，都有 $|A_{cl}x + w| \\le r$（按分量）。使用三角不等式，一个充分条件是 $|A_{cl}x| + |w| \\le r$。最坏情况的值在集合的顶点处实现，从而得到条件：\n    $$ |A_{cl}|r + w_{\\max} \\le r \\implies (I - |A_{cl}|)r \\ge w_{\\max} $$\n    其中 $|A_{cl}|$ 是 $A_{cl}$ 各项绝对值组成的矩阵。为了存在一个非平凡解（对于 $w_{\\max} > 0$ 有 $r \\ge 0$），矩阵 $(I-|A_{cl}|)$ 必须是一个非奇异M矩阵，这要求 $|A_{cl}|$ 的谱半径，记作 $\\rho(|A_{cl}|)$，小于 $1$。如果 $\\rho(|A_{cl}|) < 1$，我们可以找到任何 RPI 超矩形所需的最小半径：\n    $$ r_{\\min} = (I - |A_{cl}|)^{-1} w_{\\max} $$\n    任何具有半径 $r$ 的 RPI 超矩形必须按分量满足 $r \\ge r_{\\min}$。\n\n2.  **状态约束**：集合 $S^\\star$ 必须是允许状态空间 $X$ 的子集。这转化为对半径的条件：\n    $$ r \\le x_{\\max} $$\n\n3.  **输入约束**：对于任何状态 $x \\in S^\\star$，相应的输入 $u=Kx$ 必须在允许的输入空间 $U$ 中。这意味着 $|Kx| \\le u_{\\max}$。最坏情况的输入发生在 $S^\\star$ 的顶点处，从而得到条件：\n    $$ |K|r \\le u_{\\max} $$\n\n### 步骤3：最大半径的计算\n\n我们需要找到同时满足以下三个条件的按分量最大的向量 $r$：\n1. $r \\ge r_{\\min}$\n2. $r \\le x_{\\max}$\n3. $|K|r \\le u_{\\max}$\n\n如果不存在这样的 $r \\ge 0$，则最大 RPI 集为空。存在非空 RPI 超矩形的充要条件是，最小集（半径为 $r_{\\min}$）本身满足状态和输入约束。也就是说，$r_{\\min} \\le x_{\\max}$ 和 $|K|r_{\\min} \\le u_{\\max}$。如果此检查失败，则不存在解。\n\n如果存在解，我们寻求可行集中的按分量最大的向量 $r$。对于系统是解耦的特殊情况（即矩阵 $A, B, Q, R$ 都是对角矩阵），增益矩阵 $K$ 和闭环矩阵 $A_{cl}$ 也是对角的。向量不等式解耦为一组 $n$ 个独立的标量不等式。对于每个分量 $i=1,\\dots,n$：\n1. $r_i \\ge r_{\\min,i} = w_{\\max,i} / (1 - |(A_{cl})_{ii}|)$\n2. $r_i \\le x_{\\max,i}$\n3. $|K_{ii}|r_i \\le u_{\\max,i} \\implies r_i \\le u_{\\max,i} / |K_{ii}|$ (如果 $K_{ii} \\ne 0$)\n\n每个 $r_i$ 的可行范围是 $[r_{\\min,i}, \\min(x_{\\max,i}, u_{\\max,i}/|K_{ii}|)]$。为了找到最大集，我们应该为每个分量选择可能的最大半径，即该区间的上界：\n$$ r_i^* = \\min(x_{\\max,i}, \\frac{u_{\\max,i}}{|K_{ii}|}) $$\n我们必须通过检查 $r_i^* \\ge r_{\\min,i}$ 来验证解是否存在。如果这对所有 $i$ 都成立，则最大半径由向量 $r^*$ 给出。如果对于任何分量失败，则不存在非空的 RPI 超矩形。所提供的测试用例要么是一维的，要么具有解耦结构，因此这种简化的分析是足够的。\n\n### 算法摘要\n对于每个测试用例：\n1.  求解 DARE 得到 $P$，以计算增益 $K=- (B^\\top P B + R)^{-1} B^\\top P A$。\n2.  构建 $A_{cl} = A+BK$。\n3.  检查系统是否解耦。这里所有的测试用例都是如此。\n4.  对于每个分量 $i$：\n    a. 计算所需的最小半径 $r_{\\min,i} = w_{\\max,i} / (1 - |(A_{cl})_{ii}|)$，首先检查 $|(A_{cl})_{ii}| < 1$。\n    b. 从约束条件计算最大允许半径：$r_{\\text{bound},i} = \\min(x_{\\max,i}, u_{\\max,i}/|K_{ii}|)$。\n    c. 如果 $r_{\\text{bound},i} < r_{\\min,i}$，则该分量的问题是不可行的。总体结果为 $-1.0$。\n    d. 否则，最大半径的分量为 $r_i^* = r_{\\text{bound},i}$。\n5.  如果所有分量都可行，则收集半径 $[r_1^*, \\dots, r_n^*]$。如果 $n=1$，则这是一个标量。\n6.  如果在任何阶段，存在的条件（例如，可镇定性、$\\rho(|A_{cl}|)<1$ 或 $r_{\\text{bound}} \\ge r_{\\min}$）不满足，则结果为 $-1.0$。\n\n对于情况 3，我们预期 $r_{\\min} > r_{\\text{bound}}$，导致不可行的结果。\n- $A_{cl} \\approx 0.93$。\n- $r_{\\min} = 0.2 / (1-0.93) \\approx 2.86$。\n- $r_{\\text{bound}} = x_{\\max} = 0.5$。\n由于 $r_{\\min} > r_{\\text{bound}}$，不存在解。",
            "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Solves the robust terminal set problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"n\": 1, \"m\": 1,\n            \"A\": np.array([[0.5]]), \"B\": np.array([[0.7]]),\n            \"Q\": np.array([[1.0]]), \"R\": np.array([[1.0]]),\n            \"x_max\": np.array([2.0]), \"u_max\": np.array([2.0]),\n            \"w_max\": np.array([0.1])\n        },\n        {\n            \"n\": 2, \"m\": 2,\n            \"A\": np.array([[0.7, 0.0], [0.0, 0.55]]), \n            \"B\": np.array([[0.6, 0.0], [0.0, 0.4]]),\n            \"Q\": np.array([[1.0, 0.0], [0.0, 0.8]]), \n            \"R\": np.array([[0.3, 0.0], [0.0, 0.3]]),\n            \"x_max\": np.array([1.0, 0.6]), \n            \"u_max\": np.array([2.0, 1.0]),\n            \"w_max\": np.array([0.05, 0.02])\n        },\n        {\n            \"n\": 1, \"m\": 1,\n            \"A\": np.array([[0.95]]), \"B\": np.array([[0.05]]),\n            \"Q\": np.array([[1.0]]), \"R\": np.array([[1.0]]),\n            \"x_max\": np.array([0.5]), \"u_max\": np.array([10.0]),\n            \"w_max\": np.array([0.2])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _solve_case(\n            case[\"n\"], case[\"m\"], case[\"A\"], case[\"B\"],\n            case[\"Q\"], case[\"R\"], case[\"x_max\"], case[\"u_max\"], case[\"w_max\"]\n        )\n        results.append(result)\n    \n    # Format the final output string exactly as specified.\n    # The default str() for a list is '[...]', which matches the requirement.\n    # A scalar result should not be in a list.\n    formatted_results = []\n    for res in results:\n        if isinstance(res, np.ndarray):\n            formatted_results.append(str(res.tolist()))\n        else:\n            formatted_results.append(str(res))\n\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef _solve_case(n, m, A, B, Q, R, x_max, u_max, w_max):\n    \"\"\"\n    Computes the radii of the maximal robust positively invariant hyper-rectangle.\n    \"\"\"\n    # Step 1: Solve the Discrete Algebraic Riccati Equation (DARE) for P\n    try:\n        P = linalg.solve_discrete_are(A, B, Q, R)\n    except linalg.LinAlgError:\n        # DARE has no finite positive-semidefinite solution (e.g., not stabilizable)\n        return -1.0\n\n    # Step 2: Compute the LQR gain K and closed-loop matrix A_cl\n    try:\n        K = -np.linalg.inv(B.T @ P @ B + R) @ B.T @ P @ A\n    except np.linalg.LinAlgError:\n        # Should not happen if R is positive definite\n        return -1.0\n        \n    A_cl = A + B @ K\n    Abs_A_cl = np.abs(A_cl)\n    Abs_K = np.abs(K)\n\n    # Step 3: For decoupled systems, analyze each component independently\n    # All test cases are either 1D or have diagonal matrices ensuring decoupling.\n    final_radii = np.zeros(n)\n    \n    # A sufficient condition for existence of a bounded RPI hyperrectangle\n    # is that the spectral radius of |A_cl| is less than 1.\n    # For diagonal A_cl, this simplifies to |A_cl_ii|  1 for all i.\n    for i in range(n):\n        A_cl_ii = Abs_A_cl[i, i]\n        \n        if A_cl_ii = 1.0 and w_max[i]  1e-9:\n            return -1.0\n        \n        # Calculate the minimum radius required for RPI property\n        r_min_i = w_max[i] / (1.0 - A_cl_ii) if (1.0 - A_cl_ii)  1e-9 else np.inf\n\n        # Calculate the maximum radius allowed by state and input constraints\n        K_ii = Abs_K[i, i]\n        r_bound_u = u_max[i] / K_ii if K_ii  1e-9 else np.inf\n        r_bound_i = min(x_max[i], r_bound_u)\n\n        # Check for feasibility\n        if r_bound_i  r_min_i:\n            return -1.0\n        \n        final_radii[i] = r_bound_i\n\n    if n == 1:\n        return final_radii[0]\n    else:\n        return final_radii\n\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "设计并模拟控制器后，最后一步是评估其性能。本练习提供了一个定量框架，用于根据预期的结果和操作约束来验证您的MPC设计。您将实现并计算关键性能指标，如跟踪误差、约束违反频率和致动器能量消耗，从而学习如何将原始模拟数据转化为关于控制器有效性的有意义的见解 。",
            "id": "4013753",
            "problem": "一个受控的等离子体剖面在模型预测控制（MPC）规划的执行器作用下演化，并与参考数据集进行验证。考虑一个离散时间、离散空间的设置，时间索引为 $k \\in \\{0,\\dots,N-1\\}$，径向网格索引为 $i \\in \\{0,\\dots,M-1\\}$。令 $x^{\\text{ref}}_{k,i}$（单位：千电子伏特，keV）表示期望的参考剖面，令 $x^{\\text{mpc}}_{k,i}$（单位：千电子伏特，keV）表示在 MPC 控制下达到的剖面。令执行器指令为 $u_{k,a}$（单位：兆瓦，MW），执行器索引为 $a \\in \\{0,\\dots,A-1\\}$，每个执行器的最大值为 $u^{\\max}_a$（单位：兆瓦，MW）。令每个径向位置的界限为 $\\underline{x}_i$ 和 $\\overline{x}_i$（单位：千电子伏特，keV），假定它们在时间上是恒定的，但可能随径向位置变化。定义一个公差 $\\epsilon$（单位：千电子伏特，keV），用于开区间边界比较，以避免在相等情况下的数值模糊性。使用离散时间信号范数和基于第一性原理的计数方法，实现以下验证指标：\n\n- 均方根跟踪误差（$\\text{RMSE}$），单位为千电子伏特（keV），作用于整个时空网格。该值由跟踪误差的离散 $L^2$ 范数定义，通过样本总数进行聚合和归一化。\n- 约束违反频率（$\\phi$），一个在 $[0,1]$ 区间内的小数，等于所达到的剖面严格超出公差范围违反边界的时空样本所占的比例，即 $x^{\\text{mpc}}_{k,i}  \\underline{x}_i - \\epsilon$ 或 $x^{\\text{mpc}}_{k,i}  \\overline{x}_i + \\epsilon$ 的情况。\n- 执行器使用统计数据，跨执行器聚合：\n  1. 平均绝对使用量（$\\mu_u$），单位为兆瓦（MW），定义为所有时间和所有执行器上 $|u_{k,a}|$ 的算术平均值。\n  2. 总变差（$\\text{TV}_u$），单位为兆瓦（MW），定义为在连续时间 $k$ 上绝对差值 $|u_{k,a} - u_{k-1,a}|$ 之和在所有执行器上的平均值。\n  3. 饱和分数（$\\sigma_u$），一个小数，等于执行器样本中 $|u_{k,a}| \\ge u^{\\max}_a$ 的比例。\n\n你的任务是为以下三个测试案例计算这些指标。所有剖面值以千电子伏特（keV）给出，所有执行器指令和最大值以兆瓦（MW）给出，$\\epsilon$ 以千电子伏特（keV）给出。按指定格式输出每个测试案例的指标。在边界上使用严格相等作为非违规情况，并且仅在处理开区间边界比较时使用给定的公差。\n\n测试套件：\n\n案例 $1$（理想路径：良好跟踪，无剖面违规，执行器使用适度）：\n- $N = 5$, $M = 4$, $A = 2$, $\\epsilon = 10^{-12}$。\n- $x^{\\text{ref}}$:\n  - $k=0$: $\\{3.0, 2.5, 2.0, 1.5\\}$\n  - $k=1$: $\\{3.2, 2.7, 2.1, 1.6\\}$\n  - $k=2$: $\\{3.4, 2.9, 2.2, 1.7\\}$\n  - $k=3$: $\\{3.5, 3.0, 2.4, 1.8\\}$\n  - $k=4$: $\\{3.6, 3.1, 2.5, 1.9\\}$\n- $x^{\\text{mpc}}$:\n  - $k=0$: $\\{3.0, 2.6, 1.9, 1.5\\}$\n  - $k=1$: $\\{3.1, 2.7, 2.2, 1.7\\}$\n  - $k=2$: $\\{3.3, 2.8, 2.3, 1.8\\}$\n  - $k=3$: $\\{3.6, 3.1, 2.5, 1.9\\}$\n  - $k=4$: $\\{3.7, 3.0, 2.4, 1.8\\}$\n- 各径向位置的界限：$\\underline{x} = \\{1.0, 1.0, 1.0, 1.0\\}$, $\\overline{x} = \\{4.0, 3.5, 3.0, 2.5\\}$。\n- 执行器最大值：$u^{\\max} = \\{2.5, 5.0\\}$。\n- 执行器指令 $u$：\n  - $k=0$: $\\{1.0, 2.0\\}$\n  - $k=1$: $\\{1.2, 2.1\\}$\n  - $k=2$: $\\{1.4, 2.2\\}$\n  - $k=3$: $\\{1.6, 2.4\\}$\n  - $k=4$: $\\{1.8, 2.6\\}$\n\n案例 $2$（较大跟踪误差，频繁约束违规，执行器饱和事件）：\n- $N = 5$, $M = 4$, $A = 2$, $\\epsilon = 10^{-12}$。\n- $x^{\\text{ref}}$:\n  - $k=0$: $\\{2.0, 2.0, 2.0, 2.0\\}$\n  - $k=1$: $\\{2.5, 2.4, 2.3, 2.2\\}$\n  - $k=2$: $\\{3.0, 2.8, 2.6, 2.4\\}$\n  - $k=3$: $\\{3.5, 3.2, 2.9, 2.6\\}$\n  - $k=4$: $\\{4.0, 3.6, 3.2, 2.8\\}$\n- $x^{\\text{mpc}}$:\n  - $k=0$: $\\{1.0, 1.2, 1.1, 1.0\\}$\n  - $k=1$: $\\{1.5, 1.6, 1.5, 1.6\\}$\n  - $k=2$: $\\{2.0, 2.0, 1.9, 2.0\\}$\n  - $k=3$: $\\{2.5, 2.4, 2.3, 2.4\\}$\n  - $k=4$: $\\{5.0, 4.0, 3.6, 3.0\\}$\n- 各径向位置的界限：$\\underline{x} = \\{1.5, 1.5, 1.5, 1.5\\}$, $\\overline{x} = \\{3.5, 3.0, 2.8, 2.5\\}$。\n- 执行器最大值：$u^{\\max} = \\{2.0, 4.0\\}$。\n- 执行器指令 $u$：\n  - $k=0$: $\\{0.0, 0.0\\}$\n  - $k=1$: $\\{2.5, 4.5\\}$\n  - $k=2$: $\\{2.5, 4.0\\}$\n  - $k=3$: $\\{2.0, 3.5\\}$\n  - $k=4$: $\\{2.2, 4.6\\}$\n\n案例 $3$（在严格界限下完美跟踪，大部分时间使用量为零，瞬态执行器活动）：\n- $N = 5$, $M = 4$, $A = 2$, $\\epsilon = 10^{-12}$。\n- $x^{\\text{ref}}$:\n  - $k=0$: $\\{3.0, 3.0, 3.0, 3.0\\}$\n  - $k=1$: $\\{3.0, 3.0, 3.0, 3.0\\}$\n  - $k=2$: $\\{3.0, 3.0, 3.0, 3.0\\}$\n  - $k=3$: $\\{3.0, 3.0, 3.0, 3.0\\}$\n  - $k=4$: $\\{3.0, 3.0, 3.0, 3.0\\}$\n- $x^{\\text{mpc}}$:\n  - $k=0$: $\\{3.0, 3.0, 3.0, 3.0\\}$\n  - $k=1$: $\\{3.0, 3.0, 3.0, 3.0\\}$\n  - $k=2$: $\\{3.0, 3.0, 3.0, 3.0\\}$\n  - $k=3$: $\\{3.0, 3.0, 3.0, 3.0\\}$\n  - $k=4$: $\\{3.0, 3.0, 3.0, 3.0\\}$\n- 各径向位置的界限：$\\underline{x} = \\{3.0, 3.0, 3.0, 3.0\\}$, $\\overline{x} = \\{3.0, 3.0, 3.0, 3.0\\}$。\n- 执行器最大值：$u^{\\max} = \\{3.0, 6.0\\}$。\n- 执行器指令 $u$：\n  - $k=0$: $\\{0.0, 0.0\\}$\n  - $k=1$: $\\{0.0, 0.0\\}$\n  - $k=2$: $\\{0.0, 0.0\\}$\n  - $k=3$: $\\{1.0, 2.0\\}$\n  - $k=4$: $\\{0.0, 0.0\\}$\n\n最终输出格式：你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素是测试案例的子列表，形式为 $[\\text{RMSE}, \\phi, \\mu_u, \\text{TV}_u, \\sigma_u]$。例如，输出必须看起来像 $[[r_1, v_1, m_1, tv_1, s_1],[r_2, v_2, m_2, tv_2, s_2],[r_3, v_3, m_3, tv_3, s_3]]$，所有数字都表示为小数。跟踪误差以千电子伏特（keV）表示，执行器使用量以兆瓦（MW）表示，频率以小数表示。本问题不涉及角度。不使用百分比；分数必须表示为小数。程序必须是自包含的，并且不需要用户输入。",
            "solution": "用户提供的问题已经过分析，并被认为是有效的。它在科学上基于计算等离子体物理和控制理论，问题阐述清晰明确，并且是自包含的，提供了所有必要的数据。任务是为涉及等离子体剖面的模型预测控制（MPC）系统的三个不同测试案例计算一组验证指标。我们将首先形式化所需指标的定义，然后实现它们来处理给定的数据。\n\n### 基于原理的指标制定\n\n问题为五个指标提供了描述性定义。我们将使用所提供的符号来形式化这些定义。离散网格由时间索引 $k \\in \\{0, \\dots, N-1\\}$ 和径向索引 $i \\in \\{0, \\dots, M-1\\}$ 定义。执行器空间由索引 $a \\in \\{0, \\dots, A-1\\}$ 定义。\n\n1.  **均方根跟踪误差 ($\\text{RMSE}$)**\n    每个时空点的跟踪误差为 $e_{k,i} = x^{\\text{mpc}}_{k,i} - x^{\\text{ref}}_{k,i}$。$\\text{RMSE}$ 是整个网格上误差平方的均值的平方根。时空样本总数为 $N \\times M$。\n    $$\n    \\text{RMSE} = \\sqrt{\\frac{1}{NM} \\sum_{k=0}^{N-1} \\sum_{i=0}^{M-1} (x^{\\text{mpc}}_{k,i} - x^{\\text{ref}}_{k,i})^2}\n    $$\n    该指标对应于误差信号的离散 $L^2$-范数，通过样本数的平方根进行归一化。它以千电子伏特（keV）为单位，提供了跟踪性能的聚合度量。\n\n2.  **约束违反频率 ($\\phi$)**\n    如果在 $(k, i)$ 点，所达到的剖面 $x^{\\text{mpc}}_{k,i}$ 超出允许界限 $[\\underline{x}_i, \\overline{x}_i]$ 并超过给定的公差 $\\epsilon$，则发生约束违反。令 $V_{k,i}$ 为违规事件的指示变量。\n    $$\n    V_{k,i} = \\begin{cases} 1  \\text{if } x^{\\text{mpc}}_{k,i}  \\underline{x}_i - \\epsilon \\text{ or } x^{\\text{mpc}}_{k,i}  \\overline{x}_i + \\epsilon \\\\ 0  \\text{otherwise} \\end{cases}\n    $$\n    频率 $\\phi$ 是处于违规状态的时空样本总数的比例。\n    $$\n    \\phi = \\frac{1}{NM} \\sum_{k=0}^{N-1} \\sum_{i=0}^{M-1} V_{k,i}\n    $$\n    这是一个在 $[0, 1]$ 范围内的无量纲指标。\n\n3.  **平均绝对执行器使用量 ($\\mu_u$)**\n    该指标衡量控制作用的平均幅度。它是所有时间步和所有执行器上所有执行器指令绝对值 $|u_{k,a}|$ 的算术平均值。执行器样本总数为 $N \\times A$。\n    $$\n    \\mu_u = \\frac{1}{NA} \\sum_{k=0}^{N-1} \\sum_{a=0}^{A-1} |u_{k,a}|\n    $$\n    该指标的单位是兆瓦（MW）。\n\n4.  **执行器使用量的总变差 ($\\text{TV}_u$)**\n    该指标量化了执行器信号的“抖动”或快速变化。对于每个执行器 $a$，总变差是连续指令绝对差值的总和。最终指标是这些总变差在所有执行器上的平均值。\n    $$\n    \\text{TV}_u = \\frac{1}{A} \\sum_{a=0}^{A-1} \\left( \\sum_{k=1}^{N-1} |u_{k,a} - u_{k-1,a}| \\right)\n    $$\n    注意，内部求和从 $k=1$ 到 $N-1$，涵盖 $N-1$ 个差值。该指标的单位是兆瓦（MW）。\n\n5.  **执行器饱和分数 ($\\sigma_u$)**\n    当执行器指令的幅度 $|u_{k,a}|$ 达到或超过其物理极限 $u^{\\max}_a$ 时，就会发生饱和。令 $S_{k,a}$ 为饱和事件的指示变量。\n    $$\n    S_{k,a} = \\begin{cases} 1  \\text{if } |u_{k,a}| \\ge u^{\\max}_a \\\\ 0  \\text{otherwise} \\end{cases}\n    $$\n    饱和分数 $\\sigma_u$ 是饱和的执行器样本总数的比例。\n    $$\n    \\sigma_u = \\frac{1}{NA} \\sum_{k=0}^{N-1} \\sum_{a=0}^{A-1} S_{k,a}\n    $$\n    这是一个在 $[0, 1]$ 范围内的无量纲指标。\n\n### 实现与计算\n\n我们使用 `numpy` 库在一个 Python 脚本中实现这些公式，以进行高效的基于数组的计算。该脚本将处理提供的三个测试案例中的每一个，并计算五个指标。然后将最终结果格式化为指定的输出结构。利用 `numpy` 中的广播规则来简化不同维度数组之间的比较，例如将 $N \\times M$ 剖面数据与 $M$ 维边界进行比较。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_metrics(case_data):\n    \"\"\"\n    Computes the validation metrics for a single test case.\n    \n    Args:\n        case_data (dict): A dictionary containing all data for a single test case.\n        \n    Returns:\n        list: A list of the computed metrics [RMSE, phi, mu_u, TV_u, sigma_u].\n    \"\"\"\n    x_ref = np.array(case_data['x_ref'])\n    x_mpc = np.array(case_data['x_mpc'])\n    u = np.array(case_data['u'])\n    x_lower = np.array(case_data['x_lower'])\n    x_upper = np.array(case_data['x_upper'])\n    u_max = np.array(case_data['u_max'])\n    epsilon = case_data['epsilon']\n    \n    N, M = x_mpc.shape\n    _N_u, A = u.shape\n    \n    # 1. Root-mean-square tracking error (RMSE)\n    error = x_mpc - x_ref\n    rmse = np.sqrt(np.mean(error**2))\n    \n    # 2. Constraint violation frequency (phi)\n    # Broadcasting x_lower/x_upper (shape (M,)) against x_mpc (shape (N, M))\n    lower_violation = x_mpc  (x_lower - epsilon)\n    upper_violation = x_mpc  (x_upper + epsilon)\n    violations = lower_violation | upper_violation\n    phi = np.mean(violations)\n    \n    # 3. Mean absolute usage (mu_u)\n    mu_u = np.mean(np.abs(u))\n    \n    # 4. Total variation (TV_u)\n    # np.diff computes u[k] - u[k-1] along axis=0\n    # sum along axis=0 sums over time steps for each actuator\n    # mean computes the average across actuators\n    tv_u = np.mean(np.sum(np.abs(np.diff(u, axis=0)), axis=0))\n    \n    # 5. Saturation fraction (sigma_u)\n    # Broadcasting u_max (shape (A,)) against u (shape (N, A))\n    saturations = np.abs(u) = u_max\n    sigma_u = np.mean(saturations)\n    \n    return [rmse, phi, mu_u, tv_u, sigma_u]\n\ndef solve():\n    \"\"\"\n    Defines test cases, computes metrics for each, and prints the results.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {\n            \"epsilon\": 1e-12,\n            \"x_ref\": [\n                [3.0, 2.5, 2.0, 1.5], [3.2, 2.7, 2.1, 1.6], [3.4, 2.9, 2.2, 1.7],\n                [3.5, 3.0, 2.4, 1.8], [3.6, 3.1, 2.5, 1.9]\n            ],\n            \"x_mpc\": [\n                [3.0, 2.6, 1.9, 1.5], [3.1, 2.7, 2.2, 1.7], [3.3, 2.8, 2.3, 1.8],\n                [3.6, 3.1, 2.5, 1.9], [3.7, 3.0, 2.4, 1.8]\n            ],\n            \"x_lower\": [1.0, 1.0, 1.0, 1.0],\n            \"x_upper\": [4.0, 3.5, 3.0, 2.5],\n            \"u_max\": [2.5, 5.0],\n            \"u\": [\n                [1.0, 2.0], [1.2, 2.1], [1.4, 2.2], [1.6, 2.4], [1.8, 2.6]\n            ]\n        },\n        # Case 2\n        {\n            \"epsilon\": 1e-12,\n            \"x_ref\": [\n                [2.0, 2.0, 2.0, 2.0], [2.5, 2.4, 2.3, 2.2], [3.0, 2.8, 2.6, 2.4],\n                [3.5, 3.2, 2.9, 2.6], [4.0, 3.6, 3.2, 2.8]\n            ],\n            \"x_mpc\": [\n                [1.0, 1.2, 1.1, 1.0], [1.5, 1.6, 1.5, 1.6], [2.0, 2.0, 1.9, 2.0],\n                [2.5, 2.4, 2.3, 2.4], [5.0, 4.0, 3.6, 3.0]\n            ],\n            \"x_lower\": [1.5, 1.5, 1.5, 1.5],\n            \"x_upper\": [3.5, 3.0, 2.8, 2.5],\n            \"u_max\": [2.0, 4.0],\n            \"u\": [\n                [0.0, 0.0], [2.5, 4.5], [2.5, 4.0], [2.0, 3.5], [2.2, 4.6]\n            ]\n        },\n        # Case 3\n        {\n            \"epsilon\": 1e-12,\n            \"x_ref\": [[3.0, 3.0, 3.0, 3.0]] * 5,\n            \"x_mpc\": [[3.0, 3.0, 3.0, 3.0]] * 5,\n            \"x_lower\": [3.0, 3.0, 3.0, 3.0],\n            \"x_upper\": [3.0, 3.0, 3.0, 3.0],\n            \"u_max\": [3.0, 6.0],\n            \"u\": [\n                [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [1.0, 2.0], [0.0, 0.0]\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Calculate metrics for the current case\n        metrics = compute_metrics(case)\n        results.append(metrics)\n    \n    # Format the final list of lists into the required string representation\n    # This correctly handles converting each sublist into its string form.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}