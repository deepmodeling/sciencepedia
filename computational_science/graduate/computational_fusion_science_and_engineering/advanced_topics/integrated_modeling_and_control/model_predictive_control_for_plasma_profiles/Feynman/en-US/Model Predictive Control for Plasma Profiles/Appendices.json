{
    "hands_on_practices": [
        {
            "introduction": "The first step in designing a controller for a distributed parameter system, like a plasma profile, is to create a finite-dimensional model. This involves approximating the governing partial differential equation (PDE) on a discrete spatial grid. This practice provides essential experience in translating the continuous physics of diffusion into a discrete, matrix-based representation, which forms the core of the MPC prediction model, including the crucial handling of realistic boundary conditions .",
            "id": "4013847",
            "problem": "In model predictive control (MPC) for plasma profile evolution, the prediction model often includes a diffusive partial differential equation (PDE) for the electron temperature profile $T_{e}(x,t)$ and the electron density profile $n_{e}(x,t)$ in a one-dimensional minor-radius coordinate $x \\in [0,L]$. Consider the constant-diffusivity diffusion models\n$$\\frac{\\partial T_{e}}{\\partial t} = \\frac{\\partial}{\\partial x}\\!\\left(\\chi_{e}\\,\\frac{\\partial T_{e}}{\\partial x}\\right), \\qquad \\frac{\\partial n_{e}}{\\partial t} = \\frac{\\partial}{\\partial x}\\!\\left(D_{n}\\,\\frac{\\partial n_{e}}{\\partial x}\\right),$$\nwith boundary conditions motivated by tokamak symmetry and edge control:\n$$\\frac{\\partial T_{e}}{\\partial x}(0,t)=0,\\quad \\frac{\\partial n_{e}}{\\partial x}(0,t)=0 \\quad \\text{(Neumann at the magnetic axis)},$$\n$$T_{e}(L,t)=T_{L},\\quad n_{e}(L,t)=n_{L} \\quad \\text{(Dirichlet at the edge)}.$$\nYou will discretize these equations in space using a uniform grid and second-order central differences to form the discrete diffusion operator used in the MPC linear prediction model.\n\nUse the following specifications:\n- Domain length $L = 1\\,\\mathrm{m}$ and a uniform grid with $N=3$ interior unknowns located at $x_{i}=i\\,\\Delta x$ for $i\\in\\{1,2,3\\}$, where $\\Delta x = L/(N+1)$.\n- For the left Neumann boundary at $x=0$, enforce zero gradient using a ghost-point construction that is second-order consistent with central differences.\n- For the right Dirichlet boundary at $x=L$, eliminate the boundary value into the right-hand side so that the operator matrix multiplies only the interior unknowns $\\{T_{e}(x_{i}),n_{e}(x_{i})\\}_{i=1}^{3}$.\n- Electron heat diffusivity $\\chi_{e} = 3.0\\,\\mathrm{m^{2}\\,s^{-1}}$ and particle diffusivity $D_{n} = 1.5\\,\\mathrm{m^{2}\\,s^{-1}}$ are constants.\n- Consider one implicit Euler step with time step $\\Delta t = 10^{-3}\\,\\mathrm{s}$, so that the block-diagonal state-transition matrix for the stacked state vector $\\left[T_{e}(x_{1}),T_{e}(x_{2}),T_{e}(x_{3}),n_{e}(x_{1}),n_{e}(x_{2}),n_{e}(x_{3})\\right]^{\\top}$ is\n$$M \\;=\\; I_{2N} \\;-\\; \\Delta t \\,\\mathrm{diag}\\!\\big(\\,\\chi_{e} L,\\; D_{n} L\\,\\big),$$\nwhere $L\\in\\mathbb{R}^{N\\times N}$ is the discrete Laplacian consistent with the above boundary conditions, and $I_{2N}$ is the $2N\\times 2N$ identity.\n\nTasks:\n1. Starting from the conservation form with Fick’s law $q=-\\kappa \\,\\partial u/\\partial x$ and using second-order central differences on the uniform grid, explain clearly how the left Neumann and right Dirichlet boundary conditions are imposed to obtain the discrete operator $L$ acting on the interior unknowns. Your explanation must make explicit use of a ghost point for the Neumann condition and elimination for the Dirichlet condition.\n2. Compute all entries of the matrix $L$ explicitly for the given grid and boundary conditions.\n3. Form the blocks $\\chi_{e} L$ and $D_{n} L$, and then assemble the $6\\times 6$ matrix $M$.\n4. Report the $(2,2)$ entry of $M$ as a pure number (no units). Round your answer to four significant figures.",
            "solution": "The problem is first validated to ensure it is scientifically sound, well-posed, and objective.\n\n### Problem Validation\n\n**1. Extraction of Givens:**\n- **PDEs:** $\\frac{\\partial T_{e}}{\\partial t} = \\frac{\\partial}{\\partial x}\\!\\left(\\chi_{e}\\,\\frac{\\partial T_{e}}{\\partial x}\\right)$ and $\\frac{\\partial n_{e}}{\\partial t} = \\frac{\\partial}{\\partial x}\\!\\left(D_{n}\\,\\frac{\\partial n_{e}}{\\partial x}\\right)$.\n- **Domain:** $x \\in [0,L]$.\n- **Boundary Conditions:**\n    - Neumann at $x=0$: $\\frac{\\partial T_{e}}{\\partial x}(0,t)=0$, $\\frac{\\partial n_{e}}{\\partial x}(0,t)=0$.\n    - Dirichlet at $x=L$: $T_{e}(L,t)=T_{L}$, $n_{e}(L,t)=n_{L}$.\n- **Discretization:**\n    - Uniform grid with $N=3$ interior unknowns at $x_{i}=i\\,\\Delta x$ for $i\\in\\{1,2,3\\}$.\n    - Grid spacing: $\\Delta x = L/(N+1)$.\n    - Left BC: Second-order ghost-point construction for zero gradient.\n    - Right BC: Elimination into the right-hand side.\n- **Constants:**\n    - $L = 1\\,\\mathrm{m}$.\n    - $\\chi_{e} = 3.0\\,\\mathrm{m^{2}\\,s^{-1}}$.\n    - $D_{n} = 1.5\\,\\mathrm{m^{2}\\,s^{-1}}$.\n    - $\\Delta t = 10^{-3}\\,\\mathrm{s}$.\n- **Matrix model:** $M = I_{2N} - \\Delta t \\,\\mathrm{diag}\\!\\big(\\,\\chi_{e} L,\\; D_{n} L\\,\\big)$, with $N=3$ and $L \\in \\mathbb{R}^{N \\times N}$. The state vector is stacked as $\\left[T_{e}(x_1), T_{e}(x_2), T_{e}(x_3), n_{e}(x_1), n_{e}(x_2), n_{e}(x_3)\\right]^{\\top}$.\n- **Tasks:**\n    1. Derive the discrete operator $L$.\n    2. Compute the matrix $L$.\n    3. Assemble the $6\\times 6$ matrix $M$.\n    4. Report $M_{22}$ to four significant figures.\n\n**2. Validation Analysis:**\nThe problem is scientifically grounded, describing a standard diffusion model for plasma transport and its numerical solution via the method of lines, which are well-established practices in computational physics. The problem is well-posed, with all necessary parameters and conditions provided for a unique solution. The terminology is objective and precise. The phrasing \"state-transition matrix\" for $M$ is a slight misnomer in control theory, as $M$ is the matrix of the implicit system $(I - \\Delta t A) y^{k+1} = y^k$, not the explicit propagator $y^{k+1} = A_d y^k$. However, the mathematical definition of $M$ is unambiguous, so this does not constitute a flaw. The problem is thus deemed valid.\n\n### Solution\n\nThe solution proceeds by discretizing the generic constant-diffusivity diffusion equation, $\\frac{\\partial u}{\\partial t} = D \\frac{\\partial^2 u}{\\partial x^2}$, to construct the discrete Laplacian operator $L$, and then assembling the matrix $M$.\n\n**Task 1: Derivation of the discrete operator $L$**\n\nThe domain $[0, L]$ is discretized with $N=3$ interior points. The grid points are $x_0=0, x_1, x_2, x_3, x_4=L$. The grid spacing is $\\Delta x = \\frac{L}{N+1} = \\frac{1}{3+1} = \\frac{1}{4}$. The state vector of unknowns for a single profile $u(x,t)$ is $\\vec{u}(t) = [u(x_1,t), u(x_2,t), u(x_3,t)]^{\\top} = [u_1, u_2, u_3]^{\\top}$.\n\nThe conservation form $\\frac{\\partial u}{\\partial t} = -\\frac{\\partial q}{\\partial x}$ with Fick's law $q = -D \\frac{\\partial u}{\\partial x}$ simplifies to $\\frac{\\partial u}{\\partial t} = D \\frac{\\partial^2 u}{\\partial x^2}$ for constant diffusivity $D$. We use a second-order central difference to approximate the spatial second derivative:\n$$ \\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{x_i} \\approx \\frac{u_{i+1} - 2u_i + u_{i-1}}{(\\Delta x)^2} $$\nThis leads to the semi-discretized system of ordinary differential equations (ODEs), $\\frac{d\\vec{u}}{dt} = D L \\vec{u} + \\vec{b}$, where $L$ is the discrete Laplacian.\n\n- **Interior node ($i=2$):** For the node $x_2$, all neighbors ($x_1, x_3$) are interior points. The discretization is standard:\n$$ \\frac{du_2}{dt} = D \\frac{u_3 - 2u_2 + u_1}{(\\Delta x)^2} $$\nThis corresponds to the second row of $L$ being $\\frac{1}{(\\Delta x)^2}[1, -2, 1]$.\n\n- **Left boundary (Neumann at $x=0$, affecting node $i=1$):**\nThe equation for $u_1$ is $\\frac{du_1}{dt} = D \\frac{u_2 - 2u_1 + u_0}{(\\Delta x)^2}$, where $u_0 = u(0,t)$. To handle the Neumann boundary condition $\\frac{\\partial u}{\\partial x}(0,t) = 0$ with second-order accuracy, we must express the boundary value $u_0$ in terms of interior points. A second-order accurate one-sided finite difference formula for the derivative at $x_0=0$ is $\\frac{\\partial u}{\\partial x}(0) \\approx \\frac{-3u_0 + 4u_1 - u_2}{2\\Delta x}$. Setting this to zero gives $3u_0 = 4u_1 - u_2$, which yields the required expression for the boundary value:\n$$ u_0 = \\frac{4u_1 - u_2}{3} $$\nSubstituting this into the ODE for $u_1$:\n$$ \\frac{du_1}{dt} = \\frac{D}{(\\Delta x)^2} \\left(u_2 - 2u_1 + \\frac{4u_1 - u_2}{3}\\right) = \\frac{D}{(\\Delta x)^2} \\left( -\\frac{2}{3}u_1 + \\frac{2}{3}u_2 \\right) $$\nThe first row of $L$ is therefore $\\frac{1}{(\\Delta x)^2}[-2/3, 2/3, 0]$.\n\n- **Right boundary (Dirichlet at $x=L$, affecting node $i=3$):**\nThe equation for $u_3$ is $\\frac{du_3}{dt} = D \\frac{u_4 - 2u_3 + u_2}{(\\Delta x)^2}$. The boundary condition is $u(L,t) = u_4 = u_L$. As stated in the problem, this non-homogeneous BC is eliminated into a source term.\n$$ \\frac{du_3}{dt} = \\frac{D}{(\\Delta x)^2} (u_2 - 2u_3) + \\frac{D u_L}{(\\Delta x)^2} $$\nThe operator $L$ acts on the state vector $[u_1, u_2, u_3]^{\\top}$. Thus, the third row of $L$ is $\\frac{1}{(\\Delta x)^2}[0, 1, -2]$.\n\n**Task 2: Computation of matrix $L$**\n\nWith $L=1$ and $N=3$, we have $\\Delta x = \\frac{1}{4}$, so $\\frac{1}{(\\Delta x)^2} = 16$. Assembling the rows derived above:\n$$ L = \\frac{1}{(\\Delta x)^2} \\begin{pmatrix} -2/3  2/3  0 \\\\ 1  -2  1 \\\\ 0  1  -2 \\end{pmatrix} = 16 \\begin{pmatrix} -2/3  2/3  0 \\\\ 1  -2  1 \\\\ 0  1  -2 \\end{pmatrix} = \\begin{pmatrix} -32/3  32/3  0 \\\\ 16  -32  16 \\\\ 0  16  -32 \\end{pmatrix} $$\n\n**Task 3: Assembly of the $6 \\times 6$ matrix $M$**\n\nThe matrix $M$ is defined as $M = I_{6} - \\Delta t \\,\\mathrm{diag}\\!\\big(\\,\\chi_{e} L,\\; D_{n} L\\,\\big)$. This is a block-diagonal matrix:\n$$ M = \\begin{pmatrix} I_3 - \\Delta t \\chi_e L  0 \\\\ 0  I_3 - \\Delta t D_n L \\end{pmatrix} $$\nThe state vector is ordered as $[T_{e1}, T_{e2}, T_{e3}, n_{e1}, n_{e2}, n_{e3}]^{\\top}$. The $(2,2)$ entry of $M$ is therefore the $(2,2)$ entry of the upper-left block, $M_{TT} = I_3 - \\Delta t \\chi_e L$.\nThe $(i,j)$ entry of this block is $(M_{TT})_{ij} = \\delta_{ij} - \\Delta t \\chi_e L_{ij}$, where $\\delta_{ij}$ is the Kronecker delta.\n\n**Task 4: Report the $(2,2)$ entry of $M$**\n\nWe need to compute $M_{22}$.\n$$ M_{22} = (I_3)_{22} - \\Delta t \\chi_{e} L_{22} $$\nFrom the matrix $L$ computed in Task 2, $L_{22} = -32$.\nThe given constants are $\\Delta t = 10^{-3}\\,\\mathrm{s}$ and $\\chi_{e} = 3.0\\,\\mathrm{m^{2}\\,s^{-1}}$.\n$$ M_{22} = 1 - (10^{-3}) \\times (3.0) \\times (-32) $$\n$$ M_{22} = 1 - (0.003) \\times (-32) $$\n$$ M_{22} = 1 + 0.096 $$\n$$ M_{22} = 1.096 $$\nThe problem asks for the answer to be rounded to four significant figures. The number $1.096$ already has four significant figures.",
            "answer": "$$\\boxed{1.096}$$"
        },
        {
            "introduction": "With a spatially discretized model in hand, the next step is to convert this system of continuous-time ordinary differential equations (ODEs) into a discrete-time form that an MPC algorithm can use for prediction. This exercise demonstrates this vital conversion using the implicit Euler method, a robust choice for the stiff systems typical of diffusion phenomena . You will also derive the model's Jacobians, which are fundamental inputs for the optimization solver within the MPC.",
            "id": "4013855",
            "problem": "Consider a simplified one-dimensional transport model for a tokamak plasma profile, where the profile state is discretized on $N$ radial nodes to produce the state vector $x(t)\\in\\mathbb{R}^{N}$ and the actuator vector $u(t)\\in\\mathbb{R}^{m}$. Starting from conservation of energy and Fick’s law of diffusion, a standard finite-volume discretization with homogeneous Neumann boundary conditions yields a linear ordinary differential equation (ODE) model around a chosen operating point with constant thermal diffusivity,\n$$\n\\dot{x}(t)=D\\,L\\,x(t)+H\\,u(t)+s,\n$$\nwhere $D0$ is the effective diffusivity, $L\\in\\mathbb{R}^{N\\times N}$ is the discrete Laplacian matrix consistent with the boundary conditions, $H\\in\\mathbb{R}^{N\\times m}$ maps actuators to their radial deposition, and $s\\in\\mathbb{R}^{N}$ is a constant source term representing the linearized background heating. Let the sampling period be $\\Delta t0$. Assume that $I-\\Delta t\\,D\\,L$ is nonsingular, where $I\\in\\mathbb{R}^{N\\times N}$ is the identity matrix.\n\nUsing the implicit Euler time-stepping method grounded in the definition of numerical integration for stiff linear systems, formulate the discrete-time model $x_{k+1}=F(x_k,u_k)$ for Model Predictive Control (MPC), where $x_k\\equiv x(k\\Delta t)$ and $u_k\\equiv u(k\\Delta t)$. Then derive the Jacobians $\\partial F/\\partial x$ and $\\partial F/\\partial u$ needed for linearization within MPC about the point $(x_k,u_k)$.\n\nYour derivation must begin from the ODE above and the definition of the implicit Euler method. Express your final answer as closed-form analytic expressions in terms of $I$, $\\Delta t$, $D$, $L$, $H$, $s$, $x_k$, and $u_k$. Provide your final answer as a single row matrix containing $F(x_k,u_k)$, $\\partial F/\\partial x$, and $\\partial F/\\partial u$. No numerical evaluation or rounding is required. Do not include units in the final expressions.",
            "solution": "The problem will first be validated against the required criteria.\n\n### Step 1: Extract Givens\n-   **System Model**: A simplified one-dimensional transport model for a tokamak plasma profile.\n-   **State Vector**: $x(t) \\in \\mathbb{R}^{N}$, representing the profile discretized on $N$ radial nodes.\n-   **Actuator Vector**: $u(t) \\in \\mathbb{R}^{m}$.\n-   **Continuous-Time ODE**: $\\dot{x}(t) = D\\,L\\,x(t) + H\\,u(t) + s$.\n-   **Parameters**:\n    -   $D  0$: effective diffusivity (constant).\n    -   $L \\in \\mathbb{R}^{N \\times N}$: discrete Laplacian matrix.\n    -   $H \\in \\mathbb{R}^{N \\times m}$: actuator deposition map.\n    -   $s \\in \\mathbb{R}^{N}$: constant source term (linearized background heating).\n-   **Discretization**:\n    -   Sampling period: $\\Delta t  0$.\n    -   Discrete state: $x_k \\equiv x(k\\Delta t)$.\n    -   Discrete input: $u_k \\equiv u(k\\Delta t)$.\n-   **Assumption**: The matrix $I - \\Delta t\\,D\\,L$ is nonsingular, where $I \\in \\mathbb{R}^{N \\times N}$ is the identity matrix.\n-   **Task**:\n    1.  Formulate the discrete-time model $x_{k+1} = F(x_k, u_k)$ using the implicit Euler time-stepping method.\n    2.  Derive the Jacobians $\\partial F/\\partial x$ and $\\partial F/\\partial u$ about the point $(x_k, u_k)$.\n\n### Step 2: Validate Using Extracted Givens\n-   **Scientifically Grounded**: The problem describes the discretization of a linear diffusion-reaction type equation, which is a standard and fundamental approach for modeling transport phenomena in physics and engineering, including plasma physics. The model $\\dot{x} = Ax + Bu + c$ is a canonical linear time-invariant (LTI) state-space representation. The use of an implicit Euler method is appropriate and standard for numerically solving stiff differential equations, which commonly arise from the spatial discretization of diffusion equations (parabolic PDEs). The setup is scientifically and mathematically sound.\n-   **Well-Posed**: The problem is well-posed. It provides all necessary information: the continuous-time model, the specific numerical integration scheme to use (implicit Euler), and all relevant symbolic variables. The explicit assumption that the matrix $(I - \\Delta t D L)$ is nonsingular is crucial as it guarantees that the implicit step has a unique solution, making the derivation of $F(x_k, u_k)$ possible.\n-   **Objective**: The problem is stated in precise, objective mathematical language. Terminology such as \"discrete Laplacian,\" \"implicit Euler,\" and \"Jacobian\" are standard and unambiguous in this context. There are no subjective or opinion-based statements.\n\n### Step 3: Verdict and Action\nThe problem is valid as it is scientifically grounded, well-posed, and objective. A complete, reasoned solution will be provided.\n\nThe continuous-time linear ordinary differential equation (ODE) model is given by:\n$$\n\\dot{x}(t) = D L x(t) + H u(t) + s\n$$\nWe are tasked with finding the discrete-time model $x_{k+1} = F(x_k, u_k)$ using the implicit Euler method. The general form of the implicit (or backward) Euler method for an ODE $\\dot{y}(t) = f(y(t), t)$ is:\n$$\ny_{k+1} = y_k + \\Delta t f(y_{k+1}, t_{k+1})\n$$\nwhere $y_k = y(k\\Delta t)$ and $\\Delta t$ is the time step.\n\nFor the given system, the function $f$ depends on the state $x(t)$ and the input $u(t)$. In a discrete-time control setting, the input $u_k$ is applied over the interval $[k\\Delta t, (k+1)\\Delta t)$. Therefore, the system dynamics over this interval are driven by the constant input $u_k$. Applying the implicit Euler scheme to our specific ODE involves evaluating the state-dependent part of the dynamics at the next time step, $x_{k+1}$, and the input-dependent part at the current time step, $u_k$. This yields:\n$$\nx_{k+1} = x_k + \\Delta t \\left( D L x_{k+1} + H u_k + s \\right)\n$$\nHere, we have used $u_k$ on the right-hand side, which is standard practice for deriving discrete-time models for control where the control action is held constant over the sampling period (zero-order hold).\n\nOur goal is to solve for $x_{k+1}$ to find the form $x_{k+1} = F(x_k, u_k)$. We rearrange the equation to group all terms involving $x_{k+1}$ on one side:\n$$\nx_{k+1} - \\Delta t D L x_{k+1} = x_k + \\Delta t H u_k + \\Delta t s\n$$\nFactoring out $x_{k+1}$ on the left-hand side, we use the identity matrix $I$:\n$$\n(I - \\Delta t D L) x_{k+1} = x_k + \\Delta t (H u_k + s)\n$$\nThe problem statement provides the crucial assumption that the matrix $(I - \\Delta t D L)$ is nonsingular. This allows us to multiply both sides by its inverse, $(I - \\Delta t D L)^{-1}$, to isolate $x_{k+1}$:\n$$\nx_{k+1} = (I - \\Delta t D L)^{-1} \\left( x_k + \\Delta t (H u_k + s) \\right)\n$$\nThis is the discrete-time model $x_{k+1} = F(x_k, u_k)$. We can now explicitly write the function $F(x_k, u_k)$:\n$$\nF(x_k, u_k) = (I - \\Delta t D L)^{-1} (x_k + \\Delta t H u_k + \\Delta t s)\n$$\n\nNext, we derive the Jacobians of $F$ with respect to the state $x$ and the input $u$, evaluated at the point $(x_k, u_k)$. For clarity in differentiation, let's denote the arguments as generic vectors $x$ and $u$.\n$$\nF(x, u) = (I - \\Delta t D L)^{-1} (x + \\Delta t H u + \\Delta t s)\n$$\nLet's define the constant matrix $M = (I - \\Delta t D L)^{-1}$. The expression for $F$ becomes:\n$$\nF(x, u) = M(x + \\Delta t H u + \\Delta t s) = M x + M \\Delta t H u + M \\Delta t s\n$$\nThis function is linear in both $x$ and $u$.\n\nThe Jacobian of $F$ with respect to $x$ is the matrix of partial derivatives $\\frac{\\partial F_i}{\\partial x_j}$ for all components $i$ and $j$. For a linear function of the form $g(x) = Ax + b$, the Jacobian $\\frac{\\partial g}{\\partial x}$ is simply the matrix $A$. In our case, the term $M x$ is linear in $x$, while the other terms are constant with respect to $x$.\n$$\n\\frac{\\partial F}{\\partial x} = \\frac{\\partial}{\\partial x} (M x + M \\Delta t H u + M \\Delta t s) = M\n$$\nSubstituting back the definition of $M$:\n$$\n\\frac{\\partial F}{\\partial x} = (I - \\Delta t D L)^{-1}\n$$\n\nSimilarly, the Jacobian of $F$ with respect to $u$ is the matrix of partial derivatives $\\frac{\\partial F_i}{\\partial u_j}$. The term $M \\Delta t H u$ is linear in $u$, while the other terms are constant with respect to $u$.\n$$\n\\frac{\\partial F}{\\partial u} = \\frac{\\partial}{\\partial u} (M x + M \\Delta t H u + M \\Delta t s) = M \\Delta t H\n$$\nSubstituting back the definition of $M$:\n$$\n\\frac{\\partial F}{\\partial u} = (I - \\Delta t D L)^{-1} \\Delta t H\n$$\nSince the system is linear, the Jacobians are constant matrices and do not depend on the specific point $(x_k, u_k)$ at which they are evaluated.\n\nThe three required expressions are:\n1.  The discrete-time state-update function: $F(x_k, u_k) = (I - \\Delta t D L)^{-1} (x_k + \\Delta t H u_k + \\Delta t s)$.\n2.  The Jacobian with respect to state: $\\frac{\\partial F}{\\partial x} = (I - \\Delta t D L)^{-1}$.\n3.  The Jacobian with respect to input: $\\frac{\\partial F}{\\partial u} = (I - \\Delta t D L)^{-1} \\Delta t H$.\nThese will be presented in a single row matrix as requested.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n(I - \\Delta t D L)^{-1} (x_k + \\Delta t H u_k + \\Delta t s)\n (I - \\Delta t D L)^{-1}\n (I - \\Delta t D L)^{-1} \\Delta t H\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "After designing and implementing an MPC controller, the final and most critical task is to rigorously evaluate its performance. This requires objective, quantitative metrics to assess how well the controller tracks the desired profile, respects operational constraints, and utilizes actuator resources. This hands-on exercise guides you through the process of calculating key performance indicators (KPIs) from simulation data, a skill essential for validating, comparing, and tuning control strategies in any practical engineering application .",
            "id": "4013753",
            "problem": "A controlled plasma profile evolves under the action of actuators planned by Model Predictive Control (MPC), and it is validated against a reference dataset. Consider a discrete-time, discrete-space setting with time indices $k \\in \\{0,\\dots,N-1\\}$ and radial grid indices $i \\in \\{0,\\dots,M-1\\}$. Let $x^{\\text{ref}}_{k,i}$ in kiloelectronvolt (keV) denote the desired reference profile and $x^{\\text{mpc}}_{k,i}$ in kiloelectronvolt (keV) denote the achieved profile under MPC. Let actuator commands be $u_{k,a}$ in megawatt (MW) for actuator index $a \\in \\{0,\\dots,A-1\\}$ with per-actuator maximum $u^{\\max}_a$ in megawatt (MW). Let the per-radius bounds be $\\underline{x}_i$ and $\\overline{x}_i$ in kiloelectronvolt (keV), assumed constant in time but potentially varying in radius. Define a tolerance $\\epsilon$ in kiloelectronvolt (keV) for open-bound comparisons to avoid numerical ambiguity at equality. Using discrete-time signal norms and counting measures from first principles, implement the following validation metrics:\n\n- The root-mean-square tracking error $\\text{RMSE}$ in kiloelectronvolt (keV) over the entire space-time grid, defined from the discrete $L^2$ norm of the tracking error, aggregated and normalized by the total number of samples.\n- The constraint violation frequency $\\phi$ as a decimal over $[0,1]$ equal to the fraction of space-time samples where the achieved profile violates the bounds strictly beyond tolerance, that is where $x^{\\text{mpc}}_{k,i}  \\underline{x}_i - \\epsilon$ or $x^{\\text{mpc}}_{k,i}  \\overline{x}_i + \\epsilon$.\n- Actuator usage statistics, aggregating across actuators:\n  1. The mean absolute usage $\\mu_u$ in megawatt (MW) defined as the arithmetic mean of $|u_{k,a}|$ over all time and actuators.\n  2. The total variation $\\text{TV}_u$ in megawatt (MW) defined as the average across actuators of the sum of absolute differences $|u_{k,a} - u_{k-1,a}|$ over consecutive times $k$.\n  3. The saturation fraction $\\sigma_u$ as a decimal equal to the fraction of actuator samples where $|u_{k,a}| \\ge u^{\\max}_a$.\n\nYour task is to compute these metrics for the following three test cases. All profile values are given in kiloelectronvolt (keV), all actuator commands and maxima in megawatt (MW), and $\\epsilon$ in kiloelectronvolt (keV). Output the metrics per test case in the specified format. Use strict equality at bounds as non-violating, and use the given tolerance only to treat open-bound comparisons.\n\nTest Suite:\n\nCase $1$ (happy path: good tracking, no profile violations, moderate actuator use):\n- $N = 5$, $M = 4$, $A = 2$, $\\epsilon = 10^{-12}$.\n- $x^{\\text{ref}}$:\n  - $k=0$: $\\{3.0, 2.5, 2.0, 1.5\\}$\n  - $k=1$: $\\{3.2, 2.7, 2.1, 1.6\\}$\n  - $k=2$: $\\{3.4, 2.9, 2.2, 1.7\\}$\n  - $k=3$: $\\{3.5, 3.0, 2.4, 1.8\\}$\n  - $k=4$: $\\{3.6, 3.1, 2.5, 1.9\\}$\n- $x^{\\text{mpc}}$:\n  - $k=0$: $\\{3.0, 2.6, 1.9, 1.5\\}$\n  - $k=1$: $\\{3.1, 2.7, 2.2, 1.7\\}$\n  - $k=2$: $\\{3.3, 2.8, 2.3, 1.8\\}$\n  - $k=3$: $\\{3.6, 3.1, 2.5, 1.9\\}$\n  - $k=4$: $\\{3.7, 3.0, 2.4, 1.8\\}$\n- Bounds per radius: $\\underline{x} = \\{1.0, 1.0, 1.0, 1.0\\}$, $\\overline{x} = \\{4.0, 3.5, 3.0, 2.5\\}$.\n- Actuator maxima: $u^{\\max} = \\{2.5, 5.0\\}$.\n- Actuator commands $u$:\n  - $k=0$: $\\{1.0, 2.0\\}$\n  - $k=1$: $\\{1.2, 2.1\\}$\n  - $k=2$: $\\{1.4, 2.2\\}$\n  - $k=3$: $\\{1.6, 2.4\\}$\n  - $k=4$: $\\{1.8, 2.6\\}$\n\nCase $2$ (larger tracking error, frequent constraint violations, actuator saturation events):\n- $N = 5$, $M = 4$, $A = 2$, $\\epsilon = 10^{-12}$.\n- $x^{\\text{ref}}$:\n  - $k=0$: $\\{2.0, 2.0, 2.0, 2.0\\}$\n  - $k=1$: $\\{2.5, 2.4, 2.3, 2.2\\}$\n  - $k=2$: $\\{3.0, 2.8, 2.6, 2.4\\}$\n  - $k=3$: $\\{3.5, 3.2, 2.9, 2.6\\}$\n  - $k=4$: $\\{4.0, 3.6, 3.2, 2.8\\}$\n- $x^{\\text{mpc}}$:\n  - $k=0$: $\\{1.0, 1.2, 1.1, 1.0\\}$\n  - $k=1$: $\\{1.5, 1.6, 1.5, 1.6\\}$\n  - $k=2$: $\\{2.0, 2.0, 1.9, 2.0\\}$\n  - $k=3$: $\\{2.5, 2.4, 2.3, 2.4\\}$\n  - $k=4$: $\\{5.0, 4.0, 3.6, 3.0\\}$\n- Bounds per radius: $\\underline{x} = \\{1.5, 1.5, 1.5, 1.5\\}$, $\\overline{x} = \\{3.5, 3.0, 2.8, 2.5\\}$.\n- Actuator maxima: $u^{\\max} = \\{2.0, 4.0\\}$.\n- Actuator commands $u$:\n  - $k=0$: $\\{0.0, 0.0\\}$\n  - $k=1$: $\\{2.5, 4.5\\}$\n  - $k=2$: $\\{2.5, 4.0\\}$\n  - $k=3$: $\\{2.0, 3.5\\}$\n  - $k=4$: $\\{2.2, 4.6\\}$\n\nCase $3$ (perfect tracking at tight bounds, zero usage most of the time, transient actuator activity):\n- $N = 5$, $M = 4$, $A = 2$, $\\epsilon = 10^{-12}$.\n- $x^{\\text{ref}}$:\n  - $k=0$: $\\{3.0, 3.0, 3.0, 3.0\\}$\n  - $k=1$: $\\{3.0, 3.0, 3.0, 3.0\\}$\n  - $k=2$: $\\{3.0, 3.0, 3.0, 3.0\\}$\n  - $k=3$: $\\{3.0, 3.0, 3.0, 3.0\\}$\n  - $k=4$: $\\{3.0, 3.0, 3.0, 3.0\\}$\n- $x^{\\text{mpc}}$:\n  - $k=0$: $\\{3.0, 3.0, 3.0, 3.0\\}$\n  - $k=1$: $\\{3.0, 3.0, 3.0, 3.0\\}$\n  - $k=2$: $\\{3.0, 3.0, 3.0, 3.0\\}$\n  - $k=3$: $\\{3.0, 3.0, 3.0, 3.0\\}$\n  - $k=4$: $\\{3.0, 3.0, 3.0, 3.0\\}$\n- Bounds per radius: $\\underline{x} = \\{3.0, 3.0, 3.0, 3.0\\}$, $\\overline{x} = \\{3.0, 3.0, 3.0, 3.0\\}$.\n- Actuator maxima: $u^{\\max} = \\{3.0, 6.0\\}$.\n- Actuator commands $u$:\n  - $k=0$: $\\{0.0, 0.0\\}$\n  - $k=1$: $\\{0.0, 0.0\\}$\n  - $k=2$: $\\{0.0, 0.0\\}$\n  - $k=3$: $\\{1.0, 2.0\\}$\n  - $k=4$: $\\{0.0, 0.0\\}$\n\nFinal Output Format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is a sublist for a test case of the form $[\\text{RMSE}, \\phi, \\mu_u, \\text{TV}_u, \\sigma_u]$. For example, the output must look like $[[r_1, v_1, m_1, tv_1, s_1],[r_2, v_2, m_2, tv_2, s_2],[r_3, v_3, m_3, tv_3, s_3]]$, with all numbers expressed as decimals. Express the tracking error in kiloelectronvolt (keV), actuator usage quantities in megawatt (MW), and frequencies as decimals. Angles do not appear in this problem. Percentages are not used; fractions must be expressed as decimals. The program must be self-contained and require no user input.",
            "solution": "The user-provided problem has been analyzed and is deemed valid. It is scientifically grounded in computational plasma physics and control theory, well-posed with clear and unambiguous definitions, and self-contained with all necessary data provided. The task is to compute a set of validation metrics for three distinct test cases involving a model predictive control (MPC) system for plasma profiles. We will first formalize the definitions of the required metrics and then implement them to process the given data.\n\n### Principle-Based Metric Formulation\n\nThe problem provides descriptive definitions for five metrics. We will formalize these using the provided notation. The discrete grid is defined by time indices $k \\in \\{0, \\dots, N-1\\}$ and radial indices $i \\in \\{0, \\dots, M-1\\}$. The actuator space is defined by an index $a \\in \\{0, \\dots, A-1\\}$.\n\n1.  **Root-Mean-Square Tracking Error ($\\text{RMSE}$)**\n    The tracking error at each space-time point is $e_{k,i} = x^{\\text{mpc}}_{k,i} - x^{\\text{ref}}_{k,i}$. The $\\text{RMSE}$ is the square root of the mean of the squared errors over the entire grid. The total number of space-time samples is $N \\times M$.\n    $$\n    \\text{RMSE} = \\sqrt{\\frac{1}{NM} \\sum_{k=0}^{N-1} \\sum_{i=0}^{M-1} (x^{\\text{mpc}}_{k,i} - x^{\\text{ref}}_{k,i})^2}\n    $$\n    This metric corresponds to the discrete $L^2$-norm of the error signal, normalized by the square root of the number of samples. It provides an aggregate measure of tracking performance in units of kiloelectronvolts (keV).\n\n2.  **Constraint Violation Frequency ($\\phi$)**\n    A constraint violation occurs at $(k, i)$ if the achieved profile $x^{\\text{mpc}}_{k,i}$ falls outside the allowed bounds $[\\underline{x}_i, \\overline{x}_i]$ by more than a given tolerance $\\epsilon$. Let $V_{k,i}$ be an indicator variable for a violation event.\n    $$\n    V_{k,i} = \\begin{cases} 1  \\text{if } x^{\\text{mpc}}_{k,i}  \\underline{x}_i - \\epsilon \\text{ or } x^{\\text{mpc}}_{k,i}  \\overline{x}_i + \\epsilon \\\\ 0  \\text{otherwise} \\end{cases}\n    $$\n    The frequency $\\phi$ is the fraction of total space-time samples that are in violation.\n    $$\n    \\phi = \\frac{1}{NM} \\sum_{k=0}^{N-1} \\sum_{i=0}^{M-1} V_{k,i}\n    $$\n    This is a dimensionless metric in the range $[0, 1]$.\n\n3.  **Mean Absolute Actuator Usage ($\\mu_u$)**\n    This metric measures the average magnitude of the control effort. It is the arithmetic mean of the absolute values of all actuator commands $|u_{k,a}|$ over all time steps and all actuators. The total number of actuator samples is $N \\times A$.\n    $$\n    \\mu_u = \\frac{1}{NA} \\sum_{k=0}^{N-1} \\sum_{a=0}^{A-1} |u_{k,a}|\n    $$\n    This metric has units of megawatts (MW).\n\n4.  **Total Variation of Actuator Usage ($\\text{TV}_u$)**\n    This metric quantifies the \"chatter\" or rapid changes in the actuator signals. For each actuator $a$, the total variation is the sum of the absolute differences of consecutive commands. The final metric is the average of these total variations over all actuators.\n    $$\n    \\text{TV}_u = \\frac{1}{A} \\sum_{a=0}^{A-1} \\left( \\sum_{k=1}^{N-1} |u_{k,a} - u_{k-1,a}| \\right)\n    $$\n    Note that the inner summation runs from $k=1$ to $N-1$ over $N-1$ differences. This metric has units of megawatts (MW).\n\n5.  **Actuator Saturation Fraction ($\\sigma_u$)**\n    Saturation occurs when an actuator command magnitude $|u_{k,a}|$ meets or exceeds its physical limit $u^{\\max}_a$. Let $S_{k,a}$ be an indicator variable for a saturation event.\n    $$\n    S_{k,a} = \\begin{cases} 1  \\text{if } |u_{k,a}| \\ge u^{\\max}_a \\\\ 0  \\text{otherwise} \\end{cases}\n    $$\n    The saturation fraction $\\sigma_u$ is the fraction of total actuator samples that are saturated.\n    $$\n    \\sigma_u = \\frac{1}{NA} \\sum_{k=0}^{N-1} \\sum_{a=0}^{A-1} S_{k,a}\n    $$\n    This is a dimensionless metric in the range $[0, 1]$.\n\n### Implementation and Calculation\n\nWe implement these formulas in a Python script using the `numpy` library for efficient array-based computations. The script will process each of the three provided test cases and compute the five metrics. The final results are then formatted into the specified output structure. Broadcasting rules in `numpy` are leveraged to simplify comparisons between arrays of different dimensions, such as comparing the $N \\times M$ profile data against the $M$-dimensional bounds.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_metrics(case_data):\n    \"\"\"\n    Computes the validation metrics for a single test case.\n    \n    Args:\n        case_data (dict): A dictionary containing all data for a single test case.\n        \n    Returns:\n        list: A list of the computed metrics [RMSE, phi, mu_u, TV_u, sigma_u].\n    \"\"\"\n    x_ref = np.array(case_data['x_ref'])\n    x_mpc = np.array(case_data['x_mpc'])\n    u = np.array(case_data['u'])\n    x_lower = np.array(case_data['x_lower'])\n    x_upper = np.array(case_data['x_upper'])\n    u_max = np.array(case_data['u_max'])\n    epsilon = case_data['epsilon']\n    \n    N, M = x_mpc.shape\n    _N_u, A = u.shape\n    \n    # 1. Root-mean-square tracking error (RMSE)\n    error = x_mpc - x_ref\n    rmse = np.sqrt(np.mean(error**2))\n    \n    # 2. Constraint violation frequency (phi)\n    # Broadcasting x_lower/x_upper (shape (M,)) against x_mpc (shape (N, M))\n    lower_violation = x_mpc  (x_lower - epsilon)\n    upper_violation = x_mpc  (x_upper + epsilon)\n    violations = lower_violation | upper_violation\n    phi = np.mean(violations)\n    \n    # 3. Mean absolute usage (mu_u)\n    mu_u = np.mean(np.abs(u))\n    \n    # 4. Total variation (TV_u)\n    # np.diff computes u[k] - u[k-1] along axis=0\n    # sum along axis=0 sums over time steps for each actuator\n    # mean computes the average across actuators\n    tv_u = np.mean(np.sum(np.abs(np.diff(u, axis=0)), axis=0))\n    \n    # 5. Saturation fraction (sigma_u)\n    # Broadcasting u_max (shape (A,)) against u (shape (N, A))\n    saturations = np.abs(u) = u_max\n    sigma_u = np.mean(saturations)\n    \n    return [rmse, phi, mu_u, tv_u, sigma_u]\n\ndef solve():\n    \"\"\"\n    Defines test cases, computes metrics for each, and prints the results.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {\n            \"epsilon\": 1e-12,\n            \"x_ref\": [\n                [3.0, 2.5, 2.0, 1.5], [3.2, 2.7, 2.1, 1.6], [3.4, 2.9, 2.2, 1.7],\n                [3.5, 3.0, 2.4, 1.8], [3.6, 3.1, 2.5, 1.9]\n            ],\n            \"x_mpc\": [\n                [3.0, 2.6, 1.9, 1.5], [3.1, 2.7, 2.2, 1.7], [3.3, 2.8, 2.3, 1.8],\n                [3.6, 3.1, 2.5, 1.9], [3.7, 3.0, 2.4, 1.8]\n            ],\n            \"x_lower\": [1.0, 1.0, 1.0, 1.0],\n            \"x_upper\": [4.0, 3.5, 3.0, 2.5],\n            \"u_max\": [2.5, 5.0],\n            \"u\": [\n                [1.0, 2.0], [1.2, 2.1], [1.4, 2.2], [1.6, 2.4], [1.8, 2.6]\n            ]\n        },\n        # Case 2\n        {\n            \"epsilon\": 1e-12,\n            \"x_ref\": [\n                [2.0, 2.0, 2.0, 2.0], [2.5, 2.4, 2.3, 2.2], [3.0, 2.8, 2.6, 2.4],\n                [3.5, 3.2, 2.9, 2.6], [4.0, 3.6, 3.2, 2.8]\n            ],\n            \"x_mpc\": [\n                [1.0, 1.2, 1.1, 1.0], [1.5, 1.6, 1.5, 1.6], [2.0, 2.0, 1.9, 2.0],\n                [2.5, 2.4, 2.3, 2.4], [5.0, 4.0, 3.6, 3.0]\n            ],\n            \"x_lower\": [1.5, 1.5, 1.5, 1.5],\n            \"x_upper\": [3.5, 3.0, 2.8, 2.5],\n            \"u_max\": [2.0, 4.0],\n            \"u\": [\n                [0.0, 0.0], [2.5, 4.5], [2.5, 4.0], [2.0, 3.5], [2.2, 4.6]\n            ]\n        },\n        # Case 3\n        {\n            \"epsilon\": 1e-12,\n            \"x_ref\": [[3.0, 3.0, 3.0, 3.0]] * 5,\n            \"x_mpc\": [[3.0, 3.0, 3.0, 3.0]] * 5,\n            \"x_lower\": [3.0, 3.0, 3.0, 3.0],\n            \"x_upper\": [3.0, 3.0, 3.0, 3.0],\n            \"u_max\": [3.0, 6.0],\n            \"u\": [\n                [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [1.0, 2.0], [0.0, 0.0]\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Calculate metrics for the current case\n        metrics = compute_metrics(case)\n        results.append(metrics)\n    \n    # Format the final list of lists into the required string representation\n    # This correctly handles converting each sublist into its string form.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}