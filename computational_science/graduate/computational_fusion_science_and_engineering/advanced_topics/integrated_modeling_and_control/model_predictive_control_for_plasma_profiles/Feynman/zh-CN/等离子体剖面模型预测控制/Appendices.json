{
    "hands_on_practices": [
        {
            "introduction": "模型预测控制（MPC）的核心是其预测模型，它本质上是受控对象（在这里是等离子体）的“数字孪生”。本实践将引导你完成构建该模型的第一步：对描述等离子体输运的偏微分方程进行空间离散化。通过这个练习，你将掌握如何将连续的物理定律转化为计算机可以处理的方程组，并学会处理托卡马克中常见的边界条件，这是将理论应用于实践的关键一步。",
            "id": "4013847",
            "problem": "在用于等离子体剖面演化的模型预测控制 (MPC) 中，预测模型通常包含一个针对一维小半径坐标 $x \\in [0,L]$ 中的电子温度剖面 $T_{e}(x,t)$ 和电子密度剖面 $n_{e}(x,t)$ 的扩散偏微分方程 (PDE)。考虑以下常数扩散系数的扩散模型\n$$\\frac{\\partial T_{e}}{\\partial t} = \\frac{\\partial}{\\partial x}\\left(\\chi_{e}\\,\\frac{\\partial T_{e}}{\\partial x}\\right), \\qquad \\frac{\\partial n_{e}}{\\partial t} = \\frac{\\partial}{\\partial x}\\left(D_{n}\\,\\frac{\\partial n_{e}}{\\partial x}\\right),$$\n其边界条件源于托卡马克对称性和边缘控制：\n$$\\frac{\\partial T_{e}}{\\partial x}(0,t)=0,\\quad \\frac{\\partial n_{e}}{\\partial x}(0,t)=0 \\quad \\text{(磁轴处的诺伊曼 (Neumann) 条件)},$$\n$$T_{e}(L,t)=T_{L},\\quad n_{e}(L,t)=n_{L} \\quad \\text{(边缘处的狄利克雷 (Dirichlet) 条件)}.$$\n您将使用均匀网格和二阶中心差分在空间上对这些方程进行离散化，以形成 MPC 线性预测模型中使用的离散扩散算子。\n\n使用以下参数：\n- 域长度 $L = 1\\,\\mathrm{m}$，一个具有 $N=3$ 个内部未知数的均匀网格，这些未知数位于 $x_{i}=i\\,\\Delta x$ 处，其中 $i\\in\\{1,2,3\\}$，$\\Delta x = L/(N+1)$。\n- 对于 $x=0$ 处的左侧诺伊曼边界，使用与中心差分二阶相容的虚拟点构造法施加零梯度。\n- 对于 $x=L$ 处的右侧狄利克雷边界，将边界值消去到右端项中，使得算子矩阵仅与内部未知数 $\\{T_{e}(x_{i}),n_{e}(x_{i})\\}_{i=1}^{3}$ 相乘。\n- 电子热扩散系数 $\\chi_{e} = 3.0\\,\\mathrm{m^{2}\\,s^{-1}}$ 和粒子扩散系数 $D_{n} = 1.5\\,\\mathrm{m^{2}\\,s^{-1}}$ 均为常数。\n- 考虑一个时间步长为 $\\Delta t = 10^{-3}\\,\\mathrm{s}$ 的隐式欧拉步，因此对于堆叠状态向量 $\\left[T_{e}(x_{1}),T_{e}(x_{2}),T_{e}(x_{3}),n_{e}(x_{1}),n_{e}(x_{2}),n_{e}(x_{3})\\right]^{\\top}$，其分块对角状态转移矩阵为\n$$M \\;=\\; I_{2N} \\;-\\; \\Delta t \\,\\mathrm{diag}\\big(\\,\\chi_{e} L,\\; D_{n} L\\,\\big),$$\n其中 $L\\in\\mathbb{R}^{N\\times N}$ 是与上述边界条件一致的离散拉普拉斯算子，而 $I_{2N}$ 是 $2N\\times 2N$ 单位矩阵。\n\n任务：\n1. 从具有菲克定律 (Fick's law) $q=-\\kappa \\,\\partial u/\\partial x$ 的守恒形式出发，并在均匀网格上使用二阶中心差分，清晰地解释如何施加左侧诺伊曼和右侧狄利克雷边界条件，以获得作用于内部未知数的离散算子 $L$。您的解释必须明确使用虚拟点处理诺伊曼条件，并使用消元法处理狄利克雷条件。\n2. 对于给定的网格和边界条件，显式计算矩阵 $L$ 的所有元素。\n3. 构建分块 $\\chi_{e} L$ 和 $D_{n} L$，然后组装 $6\\times 6$ 矩阵 $M$。\n4. 报告 $M$ 的 $(2,2)$ 元素，作为一个纯数（无单位）。将您的答案四舍五入到四位有效数字。",
            "solution": "首先对问题进行验证，以确保其科学合理、适定且客观。\n\n### 问题验证\n\n**1. 提取已知条件：**\n- **偏微分方程 (PDEs)：** $\\frac{\\partial T_{e}}{\\partial t} = \\frac{\\partial}{\\partial x}\\left(\\chi_{e}\\,\\frac{\\partial T_{e}}{\\partial x}\\right)$ 和 $\\frac{\\partial n_{e}}{\\partial t} = \\frac{\\partial}{\\partial x}\\left(D_{n}\\,\\frac{\\partial n_{e}}{\\partial x}\\right)$。\n- **域：** $x \\in [0,L]$。\n- **边界条件：**\n    - $x=0$ 处的诺伊曼条件：$\\frac{\\partial T_{e}}{\\partial x}(0,t)=0$, $\\frac{\\partial n_{e}}{\\partial x}(0,t)=0$。\n    - $x=L$ 处的狄利克雷条件：$T_{e}(L,t)=T_{L}$, $n_{e}(L,t)=n_{L}$。\n- **离散化：**\n    - 具有 $N=3$ 个内部未知数的均匀网格，位于 $x_{i}=i\\,\\Delta x$ (对于 $i\\in\\{1,2,3\\}$)。\n    - 网格间距：$\\Delta x = L/(N+1)$。\n    - 左边界条件：用于零梯度的二阶虚拟点构造法。\n    - 右边界条件：消去到右端项。\n- **常数：**\n    - $L = 1\\,\\mathrm{m}$。\n    - $\\chi_{e} = 3.0\\,\\mathrm{m^{2}\\,s^{-1}}$。\n    - $D_{n} = 1.5\\,\\mathrm{m^{2}\\,s^{-1}}$。\n    - $\\Delta t = 10^{-3}\\,\\mathrm{s}$。\n- **矩阵模型：** $M = I_{2N} - \\Delta t \\,\\mathrm{diag}\\big(\\,\\chi_{e} L,\\; D_{n} L\\,\\big)$，其中 $N=3$ 且 $L \\in \\mathbb{R}^{N \\times N}$。状态向量堆叠为 $\\left[T_{e}(x_1), T_{e}(x_2), T_{e}(x_3), n_{e}(x_1), n_{e}(x_2), n_{e}(x_3)\\right]^{\\top}$。\n- **任务：**\n    1. 推导离散算子 $L$。\n    2. 计算矩阵 $L$。\n    3. 组装 $6\\times 6$ 矩阵 $M$。\n    4. 报告 $M_{22}$ 到四位有效数字。\n\n**2. 验证分析：**\n该问题有科学依据，描述了等离子体输运的标准扩散模型及其通过线方法进行的数值求解，这些都是计算物理学中的成熟实践。该问题是适定的，为获得唯一解提供了所有必要的参数和条件。术语客观而精确。将 $M$ 称为“状态转移矩阵”在控制理论中是一个轻微的用词不当，因为 $M$ 是隐式系统 $(I - \\Delta t A) y^{k+1} = y^k$ 的矩阵，而不是显式传播算子 $y^{k+1} = A_d y^k$。然而，$M$ 的数学定义是明确的，因此这不构成缺陷。因此，该问题被认为是有效的。\n\n### 解答\n\n解答过程首先离散化通用的常数扩散系数扩散方程 $\\frac{\\partial u}{\\partial t} = D \\frac{\\partial^2 u}{\\partial x^2}$，以构建离散拉普拉斯算子 $L$，然后组装矩阵 $M$。\n\n**任务 1：离散算子 $L$ 的推导**\n\n域 $[0, L]$ 用 $N=3$ 个内部点进行离散化。网格点为 $x_0=0, x_1, x_2, x_3, x_4=L$。网格间距为 $\\Delta x = \\frac{L}{N+1} = \\frac{1}{3+1} = \\frac{1}{4}$。单个剖面 $u(x,t)$ 的未知数状态向量是 $\\vec{u}(t) = [u(x_1,t), u(x_2,t), u(x_3,t)]^{\\top} = [u_1, u_2, u_3]^{\\top}$。\n\n对于常数扩散系数 $D$，守恒形式 $\\frac{\\partial u}{\\partial t} = -\\frac{\\partial q}{\\partial x}$ 与菲克定律 (Fick's law) $q = -D \\frac{\\partial u}{\\partial x}$ 简化为 $\\frac{\\partial u}{\\partial t} = D \\frac{\\partial^2 u}{\\partial x^2}$。我们使用二阶中心差分来近似空间二阶导数：\n$$ \\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{x_i} \\approx \\frac{u_{i+1} - 2u_i + u_{i-1}}{(\\Delta x)^2} $$\n这导出了半离散化的常微分方程组 (ODEs)，$\\frac{d\\vec{u}}{dt} = D L \\vec{u} + \\vec{b}$，其中 $L$ 是离散拉普拉斯算子。\n\n- **内部节点 ($i=2$)：** 对于节点 $x_2$，所有相邻点 ($x_1, x_3$) 都是内部点。离散化是标准的：\n$$ \\frac{du_2}{dt} = D \\frac{u_3 - 2u_2 + u_1}{(\\Delta x)^2} $$\n这对应于 $L$ 的第二行为 $\\frac{1}{(\\Delta x)^2}[1, -2, 1]$。\n\n- **左边界（$x=0$ 处的诺伊曼条件，影响节点 $i=1$）：**\n$u_1$ 的方程是 $\\frac{du_1}{dt} = D \\frac{u_2 - 2u_1 + u_0}{(\\Delta x)^2}$，其中 $u_0 = u(0,t)$。为了保持二阶精度格式且仅使用内部未知数，$u_0$ 必须用 $u_1$ 和 $u_2$ 来表示。诺伊曼边界条件为 $\\frac{\\partial u}{\\partial x}(0,t) = 0$。一种二阶相容的方法是假设边界附近存在与中心差分格式相容的局部二次剖面。$u(x)$ 在 $x=0$ 附近的泰勒级数展开为 $u(x) = u(0) + x u'(0) + \\frac{x^2}{2}u''(0) + O(x^3)$。由于 $u'(0)=0$，我们有 $u(x) \\approx u_0 + \\frac{x^2}{2}u''(0)$。\n在 $x_1=\\Delta x$ 和 $x_2=2\\Delta x$ 处应用此公式：\n$$ u_1 \\approx u_0 + \\frac{(\\Delta x)^2}{2}u''(0) $$\n$$ u_2 \\approx u_0 + \\frac{(2\\Delta x)^2}{2}u''(0) = u_0 + 2(\\Delta x)^2 u''(0) $$\n从第一个方程得到 $\\frac{(\\Delta x)^2}{2}u''(0) \\approx u_1 - u_0$。将其代入第二个方程得到 $u_2 \\approx u_0 + 4(u_1 - u_0) = 4u_1 - 3u_0$。整理得到 $u_0$ 的表达式：\n$$ u_0 = \\frac{4u_1 - u_2}{3} $$\n这个代数关系是二阶精确的。将其代入 $u_1$ 的常微分方程中：\n$$ \\frac{du_1}{dt} = \\frac{D}{(\\Delta x)^2} \\left(u_2 - 2u_1 + \\frac{4u_1 - u_2}{3}\\right) = \\frac{D}{(\\Delta x)^2} \\left( -\\frac{2}{3}u_1 + \\frac{2}{3}u_2 \\right) $$\n该方法与使用虚拟点 $u_{-1}=u_1$ 来构建修正的模板是一致的。$L$ 的第一行为 $\\frac{1}{(\\Delta x)^2}[-2/3, 2/3, 0]$。\n\n- **右边界（$x=L$ 处的狄利克雷条件，影响节点 $i=3$）：**\n$u_3$ 的方程是 $\\frac{du_3}{dt} = D \\frac{u_4 - 2u_3 + u_2}{(\\Delta x)^2}$。边界条件为 $u(L,t) = u_4 = u_L$。如问题所述，这个非齐次边界条件被消去并移至源项。\n$$ \\frac{du_3}{dt} = \\frac{D}{(\\Delta x)^2} (u_2 - 2u_3) + \\frac{D u_L}{(\\Delta x)^2} $$\n算子 $L$ 作用于状态向量 $[u_1, u_2, u_3]^{\\top}$。因此，$L$ 的第三行为 $\\frac{1}{(\\Delta x)^2}[0, 1, -2]$。\n\n**任务 2：矩阵 $L$ 的计算**\n\n已知 $L=1$ 和 $N=3$，我们有 $\\Delta x = \\frac{1}{4}$，所以 $\\frac{1}{(\\Delta x)^2} = 16$。组装上面推导出的各行：\n$$ L = \\frac{1}{(\\Delta x)^2} \\begin{pmatrix} -2/3 & 2/3 & 0 \\\\ 1 & -2 & 1 \\\\ 0 & 1 & -2 \\end{pmatrix} = 16 \\begin{pmatrix} -2/3 & 2/3 & 0 \\\\ 1 & -2 & 1 \\\\ 0 & 1 & -2 \\end{pmatrix} = \\begin{pmatrix} -32/3 & 32/3 & 0 \\\\ 16 & -32 & 16 \\\\ 0 & 16 & -32 \\end{pmatrix} $$\n\n**任务 3：$6 \\times 6$ 矩阵 $M$ 的组装**\n\n矩阵 $M$ 定义为 $M = I_{6} - \\Delta t \\,\\mathrm{diag}\\big(\\,\\chi_{e} L,\\; D_{n} L\\,\\big)$。这是一个分块对角矩阵：\n$$ M = \\begin{pmatrix} I_3 - \\Delta t \\chi_e L & 0 \\\\ 0 & I_3 - \\Delta t D_n L \\end{pmatrix} $$\n状态向量的顺序是 $[T_{e1}, T_{e2}, T_{e3}, n_{e1}, n_{e2}, n_{e3}]^{\\top}$。因此，$M$ 的 (2,2) 元素是左上分块 $M_{TT} = I_3 - \\Delta t \\chi_e L$ 的 (2,2) 元素。\n该分块的 $(i,j)$ 元素是 $(M_{TT})_{ij} = \\delta_{ij} - \\Delta t \\chi_e L_{ij}$，其中 $\\delta_{ij}$ 是克罗内克 δ (Kronecker delta)。\n\n**任务 4：报告 $M$ 的 (2,2) 元素**\n\n我们需要计算 $M_{22}$。\n$$ M_{22} = (I_3)_{22} - \\Delta t \\chi_{e} L_{22} $$\n从任务 2 中计算出的矩阵 $L$ 可知，$L_{22} = -32$。\n给定的常数是 $\\Delta t = 10^{-3}\\,\\mathrm{s}$ 和 $\\chi_{e} = 3.0\\,\\mathrm{m^{2}\\,s^{-1}}$。\n$$ M_{22} = 1 - (10^{-3}) \\times (3.0) \\times (-32) $$\n$$ M_{22} = 1 - (0.003) \\times (-32) $$\n$$ M_{22} = 1 + 0.096 $$\n$$ M_{22} = 1.096 $$\n问题要求答案四舍五入到四位有效数字。数字 $1.096$ 已经有四位有效数字。",
            "answer": "$$\\boxed{1.096}$$"
        },
        {
            "introduction": "在完成空间离散化后，我们得到了一个描述等离子体剖面演化的常微分方程（ODE）组。然而，数字控制器在离散的时间步长上运行，因此本实践将指导你如何使用适用于输运模型常见刚性问题的隐式欧拉法，将连续时间模型转换为离散时间形式 $x_{k+1}=F(x_k, u_k)$。此外，你还将推导该模型的雅可比矩阵，这是MPC优化求解器高效寻找最优控制序列所必需的关键信息。",
            "id": "4013855",
            "problem": "考虑一个简化的托卡马克等离子体剖面一维输运模型，其中剖面状态在 $N$ 个径向节点上离散化，得到状态向量 $x(t)\\in\\mathbb{R}^{N}$ 和执行器向量 $u(t)\\in\\mathbb{R}^{m}$。从能量守恒和菲克扩散定律出发，采用标准的有限体积法离散化，并施加齐次诺伊曼边界条件，可得到在选定工作点附近、热扩散系数为常数情况下的线性常微分方程（ODE）模型，\n$$\n\\dot{x}(t)=D\\,L\\,x(t)+H\\,u(t)+s,\n$$\n其中 $D>0$ 是有效扩散系数，$L\\in\\mathbb{R}^{N\\times N}$ 是与边界条件一致的离散拉普拉斯矩阵，$H\\in\\mathbb{R}^{N\\times m}$ 将执行器映射到其径向沉积位置，$s\\in\\mathbb{R}^{N}$ 是代表线性化背景加热的恒定源项。设采样周期为 $\\Delta t>0$。假设 $I-\\Delta t\\,D\\,L$ 是非奇异的，其中 $I\\in\\mathbb{R}^{N\\times N}$ 是单位矩阵。\n\n基于刚性线性系统数值积分的定义，使用隐式欧拉时间步进法，为模型预测控制（MPC）构建离散时间模型 $x_{k+1}=F(x_k,u_k)$，其中 $x_k\\equiv x(k\\Delta t)$ 且 $u_k\\equiv u(k\\Delta t)$。然后推导在MPC中围绕点 $(x_k,u_k)$ 进行线性化所需的雅可比矩阵 $\\partial F/\\partial x$ 和 $\\partial F/\\partial u$。\n\n你的推导必须从上述ODE和隐式欧拉法的定义开始。请用 $I$、$\\Delta t$、$D$、$L$、$H$、$s$、$x_k$ 和 $u_k$ 的封闭形式解析表达式来表示最终答案。将最终答案以包含 $F(x_k,u_k)$、$\\partial F/\\partial x$ 和 $\\partial F/\\partial u$ 的单行矩阵形式给出。不需要进行数值计算或四舍五入。最终表达式中不应包含单位。",
            "solution": "首先将根据所需标准对问题进行验证。\n\n### 步骤1：提取已知条件\n-   **系统模型**：一个简化的托卡马克等离子体剖面一维输运模型。\n-   **状态向量**：$x(t) \\in \\mathbb{R}^{N}$，表示在 $N$ 个径向节点上离散化的剖面。\n-   **执行器向量**：$u(t) \\in \\mathbb{R}^{m}$。\n-   **连续时间ODE**：$\\dot{x}(t) = D\\,L\\,x(t) + H\\,u(t) + s$。\n-   **参数**：\n    -   $D > 0$：有效扩散系数（常数）。\n    -   $L \\in \\mathbb{R}^{N \\times N}$：离散拉普拉斯矩阵。\n    -   $H \\in \\mathbb{R}^{N \\times m}$：执行器沉积图。\n    -   $s \\in \\mathbb{R}^{N}$：恒定源项（线性化背景加热）。\n-   **离散化**：\n    -   采样周期：$\\Delta t > 0$。\n    -   离散状态：$x_k \\equiv x(k\\Delta t)$。\n    -   离散输入：$u_k \\equiv u(k\\Delta t)$。\n-   **假设**：矩阵 $I - \\Delta t\\,D\\,L$ 是非奇异的，其中 $I \\in \\mathbb{R}^{N \\times N}$ 是单位矩阵。\n-   **任务**：\n    1.  使用隐式欧拉时间步进法构建离散时间模型 $x_{k+1} = F(x_k, u_k)$。\n    2.  推导在点 $(x_k, u_k)$ 附近的雅可比矩阵 $\\partial F/\\partial x$ 和 $\\partial F/\\partial u$。\n\n### 步骤2：使用提取的已知条件进行验证\n-   **科学依据**：该问题描述了一个线性扩散-反应型方程的离散化，这是对物理学和工程学（包括等离子体物理学）中输运现象进行建模的一种标准和基本方法。模型 $\\dot{x} = Ax + Bu + c$ 是一个典型的线性时不变（LTI）状态空间表示。使用隐式欧拉法是数值求解刚性微分方程的恰当和标准方法，这类方程通常由扩散方程（抛物线型偏微分方程）的空间离散化产生。该设置在科学上和数学上都是合理的。\n-   **适定性**：该问题是适定的。它提供了所有必要的信息：连续时间模型、要使用的具体数值积分方案（隐式欧拉法），以及所有相关的符号变量。明确假设矩阵 $(I - \\Delta t D L)$ 是非奇异的，这一点至关重要，因为它保证了隐式步骤有唯一解，从而使得 $F(x_k, u_k)$ 的推导成为可能。\n-   **客观性**：问题以精确、客观的数学语言陈述。诸如“离散拉普拉斯”、“隐式欧拉”和“雅可比”等术语在此上下文中是标准且明确的。没有主观或基于观点的陈述。\n\n### 步骤3：结论与行动\n该问题是有效的，因为它具有科学依据、适定且客观。将提供一个完整的、有理有据的解答。\n\n连续时间线性常微分方程（ODE）模型由下式给出：\n$$\n\\dot{x}(t) = D L x(t) + H u(t) + s\n$$\n我们的任务是使用隐式欧拉法求出离散时间模型 $x_{k+1} = F(x_k, u_k)$。对于一个ODE $\\dot{y}(t) = f(y(t), t)$，隐式（或后向）欧拉法的一般形式为：\n$$\ny_{k+1} = y_k + \\Delta t f(y_{k+1}, t_{k+1})\n$$\n其中 $y_k = y(k\\Delta t)$，$\\Delta t$ 是时间步长。\n\n对于给定的系统，函数 $f$ 取决于状态 $x(t)$ 和输入 $u(t)$。在离散时间控制设置中，输入 $u_k$ 在区间 $[k\\Delta t, (k+1)\\Delta t)$ 上施加。因此，该区间内的系统动力学由恒定输入 $u_k$ 驱动。将隐式欧拉格式应用于我们的特定ODE，需要在下一个时间步 $x_{k+1}$ 处评估动力学中与状态相关的部分，在当前时间步 $u_k$ 处评估与输入相关的部分。这得到：\n$$\nx_{k+1} = x_k + \\Delta t \\left( D L x_{k+1} + H u_k + s \\right)\n$$\n这里，我们在右侧使用了 $u_k$，这是推导离散时间控制模型的标准做法，其中控制作用在采样周期内保持恒定（零阶保持）。\n\n我们的目标是求解 $x_{k+1}$ 以找到 $x_{k+1} = F(x_k, u_k)$ 的形式。我们重新整理方程，将所有包含 $x_{k+1}$ 的项归到一边：\n$$\nx_{k+1} - \\Delta t D L x_{k+1} = x_k + \\Delta t H u_k + \\Delta t s\n$$\n在左侧提出 $x_{k+1}$ 的公因子，我们使用单位矩阵 $I$：\n$$\n(I - \\Delta t D L) x_{k+1} = x_k + \\Delta t (H u_k + s)\n$$\n问题陈述中给出了一个关键假设，即矩阵 $(I - \\Delta t D L)$ 是非奇异的。这使我们可以在等式两边同乘以其逆矩阵 $(I - \\Delta t D L)^{-1}$，从而分离出 $x_{k+1}$：\n$$\nx_{k+1} = (I - \\Delta t D L)^{-1} \\left( x_k + \\Delta t (H u_k + s) \\right)\n$$\n这就是离散时间模型 $x_{k+1} = F(x_k, u_k)$。我们现在可以明确地写出函数 $F(x_k, u_k)$：\n$$\nF(x_k, u_k) = (I - \\Delta t D L)^{-1} (x_k + \\Delta t H u_k + \\Delta t s)\n$$\n\n接下来，我们推导 $F$ 相对于状态 $x$ 和输入 $u$ 的雅可比矩阵，并在点 $(x_k, u_k)$ 处进行评估。为了求导清晰，我们将参数表示为通用向量 $x$ 和 $u$。\n$$\nF(x, u) = (I - \\Delta t D L)^{-1} (x + \\Delta t H u + \\Delta t s)\n$$\n我们定义常数矩阵 $M = (I - \\Delta t D L)^{-1}$。$F$ 的表达式变为：\n$$\nF(x, u) = M(x + \\Delta t H u + \\Delta t s) = M x + M \\Delta t H u + M \\Delta t s\n$$\n这个函数在 $x$ 和 $u$ 上都是线性的。\n\nF 相对于 $x$ 的雅可比矩阵是偏导数矩阵 $\\frac{\\partial F_i}{\\partial x_j}$（对所有分量 $i$ 和 $j$）。对于形式为 $g(x) = Ax + b$ 的线性函数，其雅可比矩阵 $\\frac{\\partial g}{\\partial x}$ 就是矩阵 $A$。在我们的例子中，$M x$ 项是关于 $x$ 的线性项，而其他项相对于 $x$ 是常数。\n$$\n\\frac{\\partial F}{\\partial x} = \\frac{\\partial}{\\partial x} (M x + M \\Delta t H u + M \\Delta t s) = M\n$$\n代回 $M$ 的定义：\n$$\n\\frac{\\partial F}{\\partial x} = (I - \\Delta t D L)^{-1}\n$$\n\n类似地，$F$ 相对于 $u$ 的雅可比矩阵是偏导数矩阵 $\\frac{\\partial F_i}{\\partial u_j}$。项 $M \\Delta t H u$ 是关于 $u$ 的线性项，而其他项相对于 $u$ 是常数。\n$$\n\\frac{\\partial F}{\\partial u} = \\frac{\\partial}{\\partial u} (M x + M \\Delta t H u + M \\Delta t s) = M \\Delta t H\n$$\n代回 $M$ 的定义：\n$$\n\\frac{\\partial F}{\\partial u} = (I - \\Delta t D L)^{-1} \\Delta t H\n$$\n由于系统是线性的，雅可比矩阵是常数矩阵，不依赖于评估它们的具体点 $(x_k, u_k)$。\n\n所需的三个表达式是：\n1.  离散时间状态更新函数：$F(x_k, u_k) = (I - \\Delta t D L)^{-1} (x_k + \\Delta t H u_k + \\Delta t s)$。\n2.  关于状态的雅可比矩阵：$\\frac{\\partial F}{\\partial x} = (I - \\Delta t D L)^{-1}$。\n3.  关于输入的雅可比矩阵：$\\frac{\\partial F}{\\partial u} = (I - \\Delta t D L)^{-1} \\Delta t H$。\n这些将按要求以单行矩阵的形式呈现。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n(I - \\Delta t D L)^{-1} (x_k + \\Delta t H u_k + \\Delta t s) & (I - \\Delta t D L)^{-1} & (I - \\Delta t D L)^{-1} \\Delta t H\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "控制器设计工作的完成并非终点，真正的考验在于其在实际或模拟环境中的性能表现。本实践聚焦于控制工程中的关键环节——验证，你将学习如何量化评估MPC控制器的性能。通过计算跟踪误差、约束违反频率和执行器活动等一系列标准指标，你将能够客观地评判控制器在不同工况下的表现，从而做出改进决策。",
            "id": "4013753",
            "problem": "一个受控的等离子体剖面在模型预测控制（MPC）规划的执行器作用下演化，并与参考数据集进行验证。考虑一个离散时间、离散空间的设定，时间索引为 $k \\in \\{0,\\dots,N-1\\}$，径向网格索引为 $i \\in \\{0,\\dots,M-1\\}$。设 $x^{\\text{ref}}_{k,i}$（单位：千电子伏，keV）表示期望的参考剖面，$x^{\\text{mpc}}_{k,i}$（单位：千电子伏，keV）表示在 MPC 控制下达到的剖面。设执行器指令为 $u_{k,a}$（单位：兆瓦，MW），其中执行器索引 $a \\in \\{0,\\dots,A-1\\}$，每个执行器的最大值为 $u^{\\max}_a$（单位：兆瓦，MW）。设每个半径的界限为 $\\underline{x}_i$ 和 $\\overline{x}_i$（单位：千电子伏，keV），假定它们在时间上恒定，但可能随半径变化。定义一个容差 $\\epsilon$（单位：千电子伏，keV），用于开区间边界比较，以避免在相等时的数值模糊性。请使用离散时间信号范数和从第一性原理出发的计数方法，实现以下验证指标：\n\n- 均方根跟踪误差 $\\text{RMSE}$（单位：千电子伏，keV），作用于整个时空网格，由跟踪误差的离散 $L^2$ 范数定义，通过样本总数进行聚合和归一化。\n- 约束违反频率 $\\phi$，一个在 $[0,1]$ 范围的小数，等于在时空样本中，所达到的剖面严格超出容差范围并违反界限的样本比例，即 $x^{\\text{mpc}}_{k,i}  \\underline{x}_i - \\epsilon$ 或 $x^{\\text{mpc}}_{k,i} > \\overline{x}_i + \\epsilon$ 的情况。\n- 执行器使用统计数据，跨执行器聚合：\n  1. 平均绝对使用量 $\\mu_u$（单位：兆瓦，MW），定义为所有时间和所有执行器上 $|u_{k,a}|$ 的算术平均值。\n  2. 总变差 $\\text{TV}_u$（单位：兆瓦，MW），定义为在连续时间 $k$ 上绝对差值 $|u_{k,a} - u_{k-1,a}|$ 之和在所有执行器上的平均值。\n  3. 饱和分数 $\\sigma_u$，一个小数，等于执行器样本中 $|u_{k,a}| \\ge u^{\\max}_a$ 的样本比例。\n\n您的任务是为以下三个测试案例计算这些指标。所有剖面值均以千电子伏（keV）为单位，所有执行器指令和最大值均以兆瓦（MW）为单位，$\\epsilon$ 以千电子伏（keV）为单位。按指定格式输出每个测试案例的指标。在界限处的严格相等情况视为不违规，且仅在处理开区间边界比较时使用给定的容差。\n\n测试套件：\n\n案例 $1$（理想情况：良好跟踪，无剖面违规，执行器使用适度）：\n- $N = 5$, $M = 4$, $A = 2$, $\\epsilon = 10^{-12}$。\n- $x^{\\text{ref}}$:\n  - $k=0$: $\\{3.0, 2.5, 2.0, 1.5\\}$\n  - $k=1$: $\\{3.2, 2.7, 2.1, 1.6\\}$\n  - $k=2$: $\\{3.4, 2.9, 2.2, 1.7\\}$\n  - $k=3$: $\\{3.5, 3.0, 2.4, 1.8\\}$\n  - $k=4$: $\\{3.6, 3.1, 2.5, 1.9\\}$\n- $x^{\\text{mpc}}$:\n  - $k=0$: $\\{3.0, 2.6, 1.9, 1.5\\}$\n  - $k=1$: $\\{3.1, 2.7, 2.2, 1.7\\}$\n  - $k=2$: $\\{3.3, 2.8, 2.3, 1.8\\}$\n  - $k=3$: $\\{3.6, 3.1, 2.5, 1.9\\}$\n  - $k=4$: $\\{3.7, 3.0, 2.4, 1.8\\}$\n- 各半径的界限：$\\underline{x} = \\{1.0, 1.0, 1.0, 1.0\\}$, $\\overline{x} = \\{4.0, 3.5, 3.0, 2.5\\}$。\n- 执行器最大值：$u^{\\max} = \\{2.5, 5.0\\}$。\n- 执行器指令 $u$:\n  - $k=0$: $\\{1.0, 2.0\\}$\n  - $k=1$: $\\{1.2, 2.1\\}$\n  - $k=2$: $\\{1.4, 2.2\\}$\n  - $k=3$: $\\{1.6, 2.4\\}$\n  - $k=4$: $\\{1.8, 2.6\\}$\n\n案例 $2$（较大跟踪误差，频繁约束违规，执行器饱和事件）：\n- $N = 5$, $M = 4$, $A = 2$, $\\epsilon = 10^{-12}$。\n- $x^{\\text{ref}}$:\n  - $k=0$: $\\{2.0, 2.0, 2.0, 2.0\\}$\n  - $k=1$: $\\{2.5, 2.4, 2.3, 2.2\\}$\n  - $k=2$: $\\{3.0, 2.8, 2.6, 2.4\\}$\n  - $k=3$: $\\{3.5, 3.2, 2.9, 2.6\\}$\n  - $k=4$: $\\{4.0, 3.6, 3.2, 2.8\\}$\n- $x^{\\text{mpc}}$:\n  - $k=0$: $\\{1.0, 1.2, 1.1, 1.0\\}$\n  - $k=1$: $\\{1.5, 1.6, 1.5, 1.6\\}$\n  - $k=2$: $\\{2.0, 2.0, 1.9, 2.0\\}$\n  - $k=3$: $\\{2.5, 2.4, 2.3, 2.4\\}$\n  - $k=4$: $\\{5.0, 4.0, 3.6, 3.0\\}$\n- 各半径的界限：$\\underline{x} = \\{1.5, 1.5, 1.5, 1.5\\}$, $\\overline{x} = \\{3.5, 3.0, 2.8, 2.5\\}$。\n- 执行器最大值：$u^{\\max} = \\{2.0, 4.0\\}$。\n- 执行器指令 $u$:\n  - $k=0$: $\\{0.0, 0.0\\}$\n  - $k=1$: $\\{2.5, 4.5\\}$\n  - $k=2$: $\\{2.5, 4.0\\}$\n  - $k=3$: $\\{2.0, 3.5\\}$\n  - $k=4$: $\\{2.2, 4.6\\}$\n\n案例 $3$（在严格界限下完美跟踪，大部分时间使用量为零，瞬态执行器活动）：\n- $N = 5$, $M = 4$, $A = 2$, $\\epsilon = 10^{-12}$。\n- $x^{\\text{ref}}$:\n  - $k=0$: $\\{3.0, 3.0, 3.0, 3.0\\}$\n  - $k=1$: $\\{3.0, 3.0, 3.0, 3.0\\}$\n  - $k=2$: $\\{3.0, 3.0, 3.0, 3.0\\}$\n  - $k=3$: $\\{3.0, 3.0, 3.0, 3.0\\}$\n  - $k=4$: $\\{3.0, 3.0, 3.0, 3.0\\}$\n- $x^{\\text{mpc}}$:\n  - $k=0$: $\\{3.0, 3.0, 3.0, 3.0\\}$\n  - $k=1$: $\\{3.0, 3.0, 3.0, 3.0\\}$\n  - $k=2$: $\\{3.0, 3.0, 3.0, 3.0\\}$\n  - $k=3$: $\\{3.0, 3.0, 3.0, 3.0\\}$\n  - $k=4$: $\\{3.0, 3.0, 3.0, 3.0\\}$\n- 各半径的界限：$\\underline{x} = \\{3.0, 3.0, 3.0, 3.0\\}$, $\\overline{x} = \\{3.0, 3.0, 3.0, 3.0\\}$。\n- 执行器最大值：$u^{\\max} = \\{3.0, 6.0\\}$。\n- 执行器指令 $u$:\n  - $k=0$: $\\{0.0, 0.0\\}$\n  - $k=1$: $\\{0.0, 0.0\\}$\n  - $k=2$: $\\{0.0, 0.0\\}$\n  - $k=3$: $\\{1.0, 2.0\\}$\n  - $k=4$: $\\{0.0, 0.0\\}$\n\n最终输出格式：您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素是形如 $[\\text{RMSE}, \\phi, \\mu_u, \\text{TV}_u, \\sigma_u]$ 的测试案例子列表。例如，输出必须看起来像 $[[r_1, v_1, m_1, tv_1, s_1],[r_2, v_2, m_2, tv_2, s_2],[r_3, v_3, m_3, tv_3, s_3]]$，所有数字都表示为小数。请将跟踪误差以千电子伏（keV）表示，执行器使用量以兆瓦（MW）表示，频率以小数表示。此问题不涉及角度。不使用百分比；分数必须表示为小数。程序必须是自包含的，并且不需要用户输入。",
            "solution": "用户提供的问题已经过分析，并被认为是有效的。该问题在计算等离子体物理和控制理论方面有科学依据，定义清晰明确，问题阐述良好，并且自包含所有必要数据。任务是为一个用于等离子体剖面的模型预测控制（MPC）系统，计算三个不同测试案例的一组验证指标。我们将首先形式化所需指标的定义，然后实现它们以处理给定数据。\n\n### 基于原理的指标形式化\n\n问题为五个指标提供了描述性定义。我们将使用所提供的符号将这些定义形式化。离散网格由时间索引 $k \\in \\{0, \\dots, N-1\\}$ 和径向索引 $i \\in \\{0, \\dots, M-1\\}$ 定义。执行器空间由索引 $a \\in \\{0, \\dots, A-1\\}$ 定义。\n\n1.  **均方根跟踪误差（$\\text{RMSE}$）**\n    每个时空点的跟踪误差为 $e_{k,i} = x^{\\text{mpc}}_{k,i} - x^{\\text{ref}}_{k,i}$。$\\text{RMSE}$ 是整个网格上误差平方均值的平方根。时空样本总数为 $N \\times M$。\n    $$\n    \\text{RMSE} = \\sqrt{\\frac{1}{NM} \\sum_{k=0}^{N-1} \\sum_{i=0}^{M-1} (x^{\\text{mpc}}_{k,i} - x^{\\text{ref}}_{k,i})^2}\n    $$\n    该指标对应于误差信号的离散 $L^2$-范数，通过样本数的平方根进行归一化。它以千电子伏（keV）为单位，提供了跟踪性能的综合度量。\n\n2.  **约束违反频率（$\\phi$）**\n    如果在 $(k, i)$ 处，所达到的剖面 $x^{\\text{mpc}}_{k,i}$ 超出允许界限 $[\\underline{x}_i, \\overline{x}_i]$ 并超过给定容差 $\\epsilon$，则发生约束违反。设 $V_{k,i}$ 为违规事件的指示变量。\n    $$\n    V_{k,i} = \\begin{cases} 1  \\text{if } x^{\\text{mpc}}_{k,i}  \\underline{x}_i - \\epsilon \\text{ or } x^{\\text{mpc}}_{k,i} > \\overline{x}_i + \\epsilon \\\\ 0  \\text{otherwise} \\end{cases}\n    $$\n    频率 $\\phi$ 是处于违规状态的时空样本总数的比例。\n    $$\n    \\phi = \\frac{1}{NM} \\sum_{k=0}^{N-1} \\sum_{i=0}^{M-1} V_{k,i}\n    $$\n    这是一个在 $[0, 1]$ 范围内的无量纲指标。\n\n3.  **执行器平均绝对使用量（$\\mu_u$）**\n    该指标衡量控制努力的平均幅度。它是所有时间步和所有执行器上执行器指令绝对值 $|u_{k,a}|$ 的算术平均值。执行器样本总数为 $N \\times A$。\n    $$\n    \\mu_u = \\frac{1}{NA} \\sum_{k=0}^{N-1} \\sum_{a=0}^{A-1} |u_{k,a}|\n    $$\n    该指标的单位是兆瓦（MW）。\n\n4.  **执行器使用总变差（$\\text{TV}_u$）**\n    该指标量化了执行器信号的“抖动”或快速变化。对于每个执行器 $a$，总变差是连续指令绝对差值的和。最终指标是这些总变差在所有执行器上的平均值。\n    $$\n    \\text{TV}_u = \\frac{1}{A} \\sum_{a=0}^{A-1} \\left( \\sum_{k=1}^{N-1} |u_{k,a} - u_{k-1,a}| \\right)\n    $$\n    注意，内部求和从 $k=1$ 到 $N-1$ 遍历 $N-1$ 个差值。该指标的单位是兆瓦（MW）。\n\n5.  **执行器饱和分数（$\\sigma_u$）**\n    当执行器指令的幅度 $|u_{k,a}|$ 达到或超过其物理极限 $u^{\\max}_a$ 时，发生饱和。设 $S_{k,a}$ 为饱和事件的指示变量。\n    $$\n    S_{k,a} = \\begin{cases} 1  \\text{if } |u_{k,a}| \\ge u^{\\max}_a \\\\ 0  \\text{otherwise} \\end{cases}\n    $$\n    饱和分数 $\\sigma_u$ 是饱和的执行器样本占总样本的比例。\n    $$\n    \\sigma_u = \\frac{1}{NA} \\sum_{k=0}^{N-1} \\sum_{a=0}^{A-1} S_{k,a}\n    $$\n    这是一个在 $[0, 1]$ 范围内的无量纲指标。\n\n### 实现与计算\n\n我们在一个 Python 脚本中使用 `numpy` 库来实现这些公式，以进行高效的基于数组的计算。该脚本将处理所提供的三个测试案例中的每一个，并计算五个指标。然后将最终结果格式化为指定的输出结构。我们利用 `numpy` 中的广播规则来简化不同维度数组之间的比较，例如将 $N \\times M$ 的剖面数据与 $M$ 维的界限进行比较。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_metrics(case_data):\n    \"\"\"\n    Computes the validation metrics for a single test case.\n    \n    Args:\n        case_data (dict): A dictionary containing all data for a single test case.\n        \n    Returns:\n        list: A list of the computed metrics [RMSE, phi, mu_u, TV_u, sigma_u].\n    \"\"\"\n    x_ref = np.array(case_data['x_ref'])\n    x_mpc = np.array(case_data['x_mpc'])\n    u = np.array(case_data['u'])\n    x_lower = np.array(case_data['x_lower'])\n    x_upper = np.array(case_data['x_upper'])\n    u_max = np.array(case_data['u_max'])\n    epsilon = case_data['epsilon']\n    \n    N, M = x_mpc.shape\n    _N_u, A = u.shape\n    \n    # 1. Root-mean-square tracking error (RMSE)\n    error = x_mpc - x_ref\n    rmse = np.sqrt(np.mean(error**2))\n    \n    # 2. Constraint violation frequency (phi)\n    # Broadcasting x_lower/x_upper (shape (M,)) against x_mpc (shape (N, M))\n    lower_violation = x_mpc  (x_lower - epsilon)\n    upper_violation = x_mpc > (x_upper + epsilon)\n    violations = lower_violation | upper_violation\n    phi = np.mean(violations)\n    \n    # 3. Mean absolute usage (mu_u)\n    mu_u = np.mean(np.abs(u))\n    \n    # 4. Total variation (TV_u)\n    # np.diff computes u[k] - u[k-1] along axis=0\n    # sum along axis=0 sums over time steps for each actuator\n    # mean computes the average across actuators\n    tv_u = np.mean(np.sum(np.abs(np.diff(u, axis=0)), axis=0))\n    \n    # 5. Saturation fraction (sigma_u)\n    # Broadcasting u_max (shape (A,)) against u (shape (N, A))\n    saturations = np.abs(u) >= u_max\n    sigma_u = np.mean(saturations)\n    \n    return [rmse, phi, mu_u, tv_u, sigma_u]\n\ndef solve():\n    \"\"\"\n    Defines test cases, computes metrics for each, and prints the results.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {\n            \"epsilon\": 1e-12,\n            \"x_ref\": [\n                [3.0, 2.5, 2.0, 1.5], [3.2, 2.7, 2.1, 1.6], [3.4, 2.9, 2.2, 1.7],\n                [3.5, 3.0, 2.4, 1.8], [3.6, 3.1, 2.5, 1.9]\n            ],\n            \"x_mpc\": [\n                [3.0, 2.6, 1.9, 1.5], [3.1, 2.7, 2.2, 1.7], [3.3, 2.8, 2.3, 1.8],\n                [3.6, 3.1, 2.5, 1.9], [3.7, 3.0, 2.4, 1.8]\n            ],\n            \"x_lower\": [1.0, 1.0, 1.0, 1.0],\n            \"x_upper\": [4.0, 3.5, 3.0, 2.5],\n            \"u_max\": [2.5, 5.0],\n            \"u\": [\n                [1.0, 2.0], [1.2, 2.1], [1.4, 2.2], [1.6, 2.4], [1.8, 2.6]\n            ]\n        },\n        # Case 2\n        {\n            \"epsilon\": 1e-12,\n            \"x_ref\": [\n                [2.0, 2.0, 2.0, 2.0], [2.5, 2.4, 2.3, 2.2], [3.0, 2.8, 2.6, 2.4],\n                [3.5, 3.2, 2.9, 2.6], [4.0, 3.6, 3.2, 2.8]\n            ],\n            \"x_mpc\": [\n                [1.0, 1.2, 1.1, 1.0], [1.5, 1.6, 1.5, 1.6], [2.0, 2.0, 1.9, 2.0],\n                [2.5, 2.4, 2.3, 2.4], [5.0, 4.0, 3.6, 3.0]\n            ],\n            \"x_lower\": [1.5, 1.5, 1.5, 1.5],\n            \"x_upper\": [3.5, 3.0, 2.8, 2.5],\n            \"u_max\": [2.0, 4.0],\n            \"u\": [\n                [0.0, 0.0], [2.5, 4.5], [2.5, 4.0], [2.0, 3.5], [2.2, 4.6]\n            ]\n        },\n        # Case 3\n        {\n            \"epsilon\": 1e-12,\n            \"x_ref\": [[3.0, 3.0, 3.0, 3.0]] * 5,\n            \"x_mpc\": [[3.0, 3.0, 3.0, 3.0]] * 5,\n            \"x_lower\": [3.0, 3.0, 3.0, 3.0],\n            \"x_upper\": [3.0, 3.0, 3.0, 3.0],\n            \"u_max\": [3.0, 6.0],\n            \"u\": [\n                [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [1.0, 2.0], [0.0, 0.0]\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Calculate metrics for the current case\n        metrics = compute_metrics(case)\n        results.append(metrics)\n    \n    # Format the final list of lists into the required string representation\n    # This correctly handles converting each sublist into its string form.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}