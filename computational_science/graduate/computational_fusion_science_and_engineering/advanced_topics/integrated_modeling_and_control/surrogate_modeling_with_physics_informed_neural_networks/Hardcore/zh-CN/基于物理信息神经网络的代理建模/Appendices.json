{
    "hands_on_practices": [
        {
            "introduction": "在求解偏微分方程时，施加边界条件是至关重要的一步。与其将边界条件作为损失函数中的软约束，我们可以通过巧妙设计网络输出架构来“硬性”施加这些条件，从而保证解在边界上始终是正确的。本练习  将介绍一种强大的技术，即使用符号距离函数（Signed Distance Function, SDF）来构建输出变换，从而确保狄利克雷（Dirichlet）边界条件在结构上得到满足。掌握此方法是构建稳健、准确的物理信息神经网络（PINN）的关键一步。",
            "id": "4050755",
            "problem": "考虑一个带有真空室边界的轴对称环形聚变装置的二维极向截面。极向磁通函数 $\\psi(\\mathbf{x})$ 是 Grad-Shafranov 平衡方程中关注的标量状态，在真空室边界 $\\partial \\Omega$ 上，对所有 $\\mathbf{x} \\in \\partial \\Omega$ 施加狄利克雷边界条件 $\\psi(\\mathbf{x}) = \\psi_{\\text{wall}}$。在使用物理信息神经网络（PINNs）进行代理建模时，需要设计网络输出，使其无论训练如何都能精确满足边界条件。您的任务是基于一个有符号距离函数构建一个输出变换，该变换在 $\\partial \\Omega$ 上强制施加边界条件 $\\psi = \\psi_{\\text{wall}}$，从第一性原理出发解释其工作原理，并为一个圆形真空室实现该变换。\n\n从边值问题定义出发，利用有符号距离函数 $s(\\mathbf{x})$ 的概念，推导出一个输出变换，该变换能将任何无约束的标量函数映射为一个在边界上精确满足 $\\psi(\\mathbf{x}) = \\psi_{\\text{wall}}$ 的函数。该有符号距离函数应相对于真空室边界定义，几乎处处可微，并在 $\\partial \\Omega$ 上为零。请提供一个基于狄利克雷边界条件定义和有符号距离函数性质的清晰推理路径，不要使用快捷公式。\n\n然后，为一个以原点为中心、半径为 $R$ 的圆形真空室实现该变换。使用相对于该圆的有符号距离函数。设无约束的代理输出为一个平滑函数 $\\phi(x,y)$，其表达式为 $\\phi(x,y) = \\sin(k_{x} x)\\,\\cos(k_{y} y) + c$，其中 $k_{x}$ 和 $k_{y}$ 是波数，$c$ 是一个常数偏移。使用以下参数值：\n- $R = 1.0\\,\\mathrm{m}$，\n- $\\psi_{\\text{wall}} = 0.8\\,\\mathrm{Wb/rad}$，\n- $k_{x} = 3.0\\,\\mathrm{rad/m}$，\n- $k_{y} = 2.0\\,\\mathrm{rad/m}$，\n- $c = 0.1$。\n\n您的程序必须计算在指定测试位置处变换后的输出 $\\tilde{\\psi}(x,y)$（单位为 $\\mathrm{Wb/rad}$），并验证在边界点上边界条件是否被强制施加。使用以弧度为单位的角度。对于边界上的数值验证，如果绝对差 $|\\tilde{\\psi}(x,y) - \\psi_{\\text{wall}}|$ 小于或等于容差 $\\tau$（其中 $\\tau = 10^{-12}\\,\\mathrm{Wb/rad}$），则认为条件已满足。\n\n测试套件（提供覆盖所有场景的测试）：\n- 圆上角度为 $\\theta = 0$、$\\theta = \\pi/4$ 和 $\\theta = \\pi/2$ 的边界点，坐标为 $(x,y) = (R\\cos\\theta, R\\sin\\theta)$。在这些点上验证边界条件，并报告每个点的布尔结果（在容差范围内满足则为真，否则为假）。\n- 极坐标为 $(r,\\theta) = (0.5R,\\pi/3)$ 的一个内部点，转换为 $(x,y)$，并报告浮点数值 $\\tilde{\\psi}(x,y)$，单位为 $\\mathrm{Wb/rad}$。\n- 极坐标为 $(r,\\theta) = (1.5R,\\pi/6)$ 的一个外部点，转换为 $(x,y)$，并报告浮点数值 $\\tilde{\\psi}(x,y)$，单位为 $\\mathrm{Wb/rad}$。\n- 中心点 $(x,y) = (0,0)$，并报告浮点数值 $\\tilde{\\psi}(0,0)$，单位为 $\\mathrm{Wb/rad}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下：\n$[$在 $\\theta=0$ 处的边界检查，在 $\\theta=\\pi/4$ 处的边界检查，在 $\\theta=\\pi/2$ 处的边界检查，内部点的 $\\tilde{\\psi}$ 值，外部点的 $\\tilde{\\psi}$ 值，中心点的 $\\tilde{\\psi}$ 值$]$。\n布尔条目必须是 Python 布尔值，浮点条目必须是数值，单位为 $\\mathrm{Wb/rad}$。角度单位为弧度。不应打印任何额外文本。",
            "solution": "为极向磁通 $\\psi(\\mathbf{x})$ 构建一个能精确满足狄利克雷边界条件的代理模型，是计算科学中的一个适定问题。我们将首先从第一性原理出发，对所需的输出变换进行严格推导，然后针对指定场景进行实现。\n\n**1. 输出变换的推导**\n\n设 $\\phi(\\mathbf{x}): \\mathbb{R}^n \\to \\mathbb{R}$ 为一个任意的、无约束的且表现良好的标量函数，代表代理模型的直接输出。我们需要找到一个映射 $\\tilde{\\psi}(\\mathbf{x}) = f(\\mathbf{x}, \\phi(\\mathbf{x}))$，使得 $\\tilde{\\psi}(\\mathbf{x})|_{\\mathbf{x} \\in \\partial\\Omega} = \\psi_{\\text{wall}}$。\n\n此构建的关键工具是相对于边界 $\\partial\\Omega$ 定义的有符号距离函数（SDF）$s(\\mathbf{x})$。SDF 的定义属性是，$s(\\mathbf{x}) = 0$ 当且仅当点 $\\mathbf{x}$ 位于边界 $\\partial\\Omega$ 上。对于不在边界上的点，$s(\\mathbf{x}) \\neq 0$。\n\n一个通用且有效的变换结构是，一个设定边界值的项与一个包含无约束函数 $\\phi(\\mathbf{x})$ 的项的线性组合。我们提出以下形式：\n$$\n\\tilde{\\psi}(\\mathbf{x}) = A(\\mathbf{x}) + B(\\mathbf{x})\\phi(\\mathbf{x})\n$$\n其中 $A(\\mathbf{x})$ 和 $B(\\mathbf{x})$ 是待定函数。\n\n为了在 $\\partial\\Omega$ 上满足边界条件 $\\tilde{\\psi}(\\mathbf{x}) = \\psi_{\\text{wall}}$，我们在任意点 $\\mathbf{x}_b \\in \\partial\\Omega$ 处计算该表达式：\n$$\n\\tilde{\\psi}(\\mathbf{x}_b) = A(\\mathbf{x}_b) + B(\\mathbf{x}_b)\\phi(\\mathbf{x}_b) = \\psi_{\\text{wall}}\n$$\n此等式必须对任何函数 $\\phi(\\mathbf{x})$ 都成立。这意味着包含 $\\phi(\\mathbf{x})$ 的项必须在边界上为零。因此，我们要求对于所有 $\\mathbf{x}_b \\in \\partial\\Omega$，都有 $B(\\mathbf{x}_b) = 0$。\n\n有符号距离函数 $s(\\mathbf{x})$ 正好具有此性质。通过设置 $B(\\mathbf{x}) = s(\\mathbf{x})$，我们确保项 $s(\\mathbf{x})\\phi(\\mathbf{x})$ 在 $\\partial\\Omega$ 上恒等于零。所提出的变换变为：\n$$\n\\tilde{\\psi}(\\mathbf{x}) = A(\\mathbf{x}) + s(\\mathbf{x})\\phi(\\mathbf{x})\n$$\n在边界 $\\partial\\Omega$ 上对此进行计算，得到：\n$$\n\\tilde{\\psi}(\\mathbf{x})|_{\\mathbf{x} \\in \\partial\\Omega} = A(\\mathbf{x})|_{\\mathbf{x} \\in \\partial\\Omega} + s(\\mathbf{x})|_{\\mathbf{x} \\in \\partial\\Omega} \\cdot \\phi(\\mathbf{x})|_{\\mathbf{x} \\in \\partial\\Omega} = A(\\mathbf{x})|_{\\mathbf{x} \\in \\partial\\Omega} + 0 \\cdot \\phi(\\mathbf{x})|_{\\mathbf{x} \\in \\partial\\Omega} = A(\\mathbf{x})|_{\\mathbf{x} \\in \\partial\\Omega}\n$$\n为了满足狄利克雷条件，我们必须有 $A(\\mathbf{x})|_{\\mathbf{x} \\in \\partial\\Omega} = \\psi_{\\text{wall}}$。对于 $A(\\mathbf{x})$，满足此条件的最简单选择是对所有边界点都成立的常数函数 $A(\\mathbf{x}) = \\psi_{\\text{wall}}$。\n\n将这些对 $A(\\mathbf{x})$ 和 $B(\\mathbf{x})$ 的选择代入，得到最终的精确输出变换：\n$$\n\\tilde{\\psi}(\\mathbf{x}) = \\psi_{\\text{wall}} + s(\\mathbf{x})\\phi(\\mathbf{x})\n$$\n这种形式保证了边界条件通过构造得到满足，而与无约束函数 $\\phi(\\mathbf{x})$ 的行为无关。\n\n**2. 在圆形真空室上的应用**\n\n问题指定了一个以原点 $(0,0)$ 为中心、半径为 $R$ 的圆形真空室。边界 $\\partial\\Omega$ 是满足 $x^2+y^2=R^2$ 的点集 $(x,y)$。\n\n对于此几何形状，有符号距离函数 $s(x,y)$ 是点 $(x,y)$ 到原点的距离减去半径 $R$。我们将其定义为：\n$$\ns(x,y) = \\sqrt{x^2+y^2} - R\n$$\n该函数在圆内为负，圆外为正，在圆上为零，符合要求。它除了在原点外处处可微，满足了“几乎处处可微”的条件。\n\n无约束代理输出由平滑函数给出：\n$$\n\\phi(x,y) = \\sin(k_{x} x)\\,\\cos(k_{y} y) + c\n$$\n\n将这些具体形式代入通用变换中，我们得到变换后的极向磁通的表达式：\n$$\n\\tilde{\\psi}(x,y) = \\psi_{\\text{wall}} + \\left(\\sqrt{x^2+y^2} - R\\right) \\left( \\sin(k_{x} x)\\,\\cos(k_{y} y) + c \\right)\n$$\n\n**3. 数值评估**\n\n问题提供了以下参数值：\n- 半径 $R = 1.0\\,\\mathrm{m}$\n- 边界值 $\\psi_{\\text{wall}} = 0.8\\,\\mathrm{Wb/rad}$\n- 波数 $k_{x} = 3.0\\,\\mathrm{rad/m}$，$k_{y} = 2.0\\,\\mathrm{rad/m}$\n- 偏移量 $c = 0.1$\n- 容差 $\\tau = 10^{-12}\\,\\mathrm{Wb/rad}$\n\n我们现在将在指定的测试位置评估 $\\tilde{\\psi}(x,y)$。对于以极坐标 $(r,\\theta)$ 给出的点，我们使用转换 $x=r\\cos\\theta$ 和 $y=r\\sin\\theta$。\n\n- **边界点**：对于边界上的任何点，$r=R$，这意味着 $\\sqrt{x^2+y^2} = R$。项 $(\\sqrt{x^2+y^2} - R)$ 变为零。因此，$\\tilde{\\psi}(x,y) = \\psi_{\\text{wall}} + 0 = \\psi_{\\text{wall}}$。绝对差 $|\\tilde{\\psi}(x,y) - \\psi_{\\text{wall}}|$ 为 $0$，小于容差 $\\tau$。因此，边界条件被精确满足，检查将返回真。\n\n- **内部点、外部点和中心点**：对于不在边界上的点，我们将使用完整表达式和给定的参数计算 $\\tilde{\\psi}(x,y)$ 的值。实现过程将以数值方式执行这些计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the transformed poloidal flux function output at specified test locations.\n    The transform enforces Dirichlet boundary conditions for a circular domain.\n    \"\"\"\n    # Define constants from the problem statement.\n    R = 1.0           # Vessel radius in meters\n    psi_wall = 0.8    # Boundary value in Wb/rad\n    kx = 3.0          # Wavenumber in x-direction in rad/m\n    ky = 2.0          # Wavenumber in y-direction in rad/m\n    c = 0.1           # Constant offset, dimensionless\n    tau = 1.0e-12     # Tolerance for boundary check in Wb/rad\n\n    def s(x, y):\n        \"\"\"Signed distance function for a circle centered at the origin.\"\"\"\n        return np.sqrt(x**2 + y**2) - R\n\n    def phi(x, y):\n        \"\"\"Unconstrained surrogate model output.\"\"\"\n        return np.sin(kx * x) * np.cos(ky * y) + c\n\n    def psi_tilde(x, y):\n        \"\"\"Transformed output function enforcing the boundary condition.\"\"\"\n        return psi_wall + s(x, y) * phi(x, y)\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (description, type_of_test, coordinates)\n    test_cases = [\n        # Boundary points\n        (\"Boundary at theta=0\", \"boundary_check\", (R * np.cos(0), R * np.sin(0))),\n        (\"Boundary at theta=pi/4\", \"boundary_check\", (R * np.cos(np.pi / 4), R * np.sin(np.pi / 4))),\n        (\"Boundary at theta=pi/2\", \"boundary_check\", (R * np.cos(np.pi / 2), R * np.sin(np.pi / 2))),\n        # Interior point\n        (\"Interior at (0.5R, pi/3)\", \"value\", (0.5 * R * np.cos(np.pi / 3), 0.5 * R * np.sin(np.pi / 3))),\n        # Exterior point\n        (\"Exterior at (1.5R, pi/6)\", \"value\", (1.5 * R * np.cos(np.pi / 6), 1.5 * R * np.sin(np.pi / 6))),\n        # Center point\n        (\"Center at (0,0)\", \"value\", (0.0, 0.0)),\n    ]\n\n    results = []\n    for description, test_type, coords in test_cases:\n        x, y = coords\n        val = psi_tilde(x, y)\n        \n        if test_type == \"boundary_check\":\n            # Verify if the boundary condition is satisfied within the tolerance.\n            is_satisfied = np.abs(val - psi_wall) = tau\n            results.append(is_satisfied)\n        elif test_type == \"value\":\n            # Report the float value of psi_tilde.\n            results.append(val)\n\n    # Final print statement in the exact required format.\n    # str() on a boolean produces 'True' or 'False'.\n    # str() on a float produces its string representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "物理信息神经网络的训练过程可能非常不稳定，这通常是由于梯度尺度不佳或损失项不平衡所致。对控制方程和变量进行适当的缩放和无量纲化，可以显著改善训练问题的条件数。本练习  将引导你理解为什么无量纲化是开发物理信息神经网络的一项最佳实践，它展示了这一应用数学中的经典技术对于稳定物理问题的深度神经网络训练是何等重要。",
            "id": "4050743",
            "problem": "我们训练一个物理信息神经网络 (PINN) 代理模型，用于模拟磁化聚变等离子体中沿磁力线的平行热输运。沿弧长 $s$ 的温度场 $T(s,t)$ 的控制方程是各向异性热传导平衡方程\n$$\n\\frac{\\partial T}{\\partial t}(s,t) \\;=\\; \\chi_{\\parallel} \\,\\frac{\\partial^2 T}{\\partial s^2}(s,t) \\;+\\; Q(s,t),\n$$\n其中 $\\chi_{\\parallel}$ 是平行热扩散系数，$Q(s,t)$ 是单位热容的体积热源。参数为 $\\theta$ 的神经网络输出 $\\widehat{T}_{\\theta}(s,t)$，并使用自动微分来计算残差中关于 $s$ 和 $t$ 的导数。为了减轻训练不稳定性，一位工程师通过定义仿射变换来重新缩放网络输出\n$$\n\\widetilde{T}(s,t) \\;=\\; \\frac{\\widehat{T}_{\\theta}(s,t) - T_{\\mathrm{ref}}}{S_T},\n$$\n其中包含一个常数平移 $T_{\\mathrm{ref}}$ 和一个尺度 $S_T  0$。最初没有对 $s$ 或 $t$ 进行重新缩放。复合损失函数包含诊断点处 $T$ 的数据失配的均方误差，以及域内偏微分方程残差的均方误差。\n\n从第一性原理出发，分析 $S_T$ 的选择如何影响自动微分中二阶导数计算的量级和条件性，以及残差中各项的相对尺度。然后，确定哪种归一化策略在这种情况下，在符合物理上合理的无量纲化的前提下，能最好地最小化由尺度不当的二阶导数项和不平衡的损失分量引起的训练不稳定性。\n\n哪个选项是最合适的归一化选择？\n\nA. 仅重新缩放输出，选择 $S_T$ 等于物理温度范围 $\\Delta T \\equiv T_{\\max} - T_{\\min}$，并保持 $s$ 和 $t$ 为有量纲的；不修改损失权重。因为因子 $S_T$ 以相同方式乘上 $T$ 的所有导数，所以这个选择实际上使偏微分方程残差保持不变，因此对于二阶导数的自动微分的条件性是最佳的。\n\nB. 按物理范围重新缩放输出，并通过特征尺度对输入进行无量纲化：选择 $S_T = \\Delta T$，$s = L\\,\\widetilde{s}$，以及 $t = \\tau\\,\\widetilde{t}$，其中 $\\tau = L^2/\\chi_{\\parallel}$，并用无量纲变量和场重写损失函数。这得到了无量纲平衡方程 $\\partial_{\\widetilde{t}} \\widetilde{T} = \\partial_{\\widetilde{s}\\widetilde{s}} \\widetilde{T} + \\widetilde{Q}$，其中 $\\widetilde{Q} = Q\\,\\tau/S_T$，使得系数为 $\\mathcal{O}(1)$ 且自动微分的二阶导数为 $\\mathcal{O}(1)$，从而改善了条件性并减少了训练不稳定性。\n\nC. 用物理范围的平方重新缩放输出，$S_T = (\\Delta T)^2$，这样二阶导数就被 $(\\Delta T)^2$ 除，从而在自动微分中积极地抑制其量级并防止训练中的梯度爆炸，同时保持输入为有量纲的。\n\nD. 不重新缩放输出或输入；而是通过一个大因子增加损失函数中偏微分方程残差项的权重，使得自动微分的二阶导数在反向传播中占主导地位，并通过强力执行物理规律来稳定训练。",
            "solution": "我们从热传导平衡方程开始\n$$\n\\frac{\\partial T}{\\partial t} \\;=\\; \\chi_{\\parallel}\\,\\frac{\\partial^2 T}{\\partial s^2} \\;+\\; Q,\n$$\n和仿射输出变换\n$$\n\\widehat{T}_{\\theta}(s,t) \\;=\\; T_{\\mathrm{ref}} + S_T\\,\\widetilde{T}(s,t).\n$$\n基本微积分和链式法则表明，通过 $S_T$ 进行常数仿射缩放会使所有同阶导数乘以相同的因子。具体来说，\n$$\n\\frac{\\partial \\widehat{T}_{\\theta}}{\\partial t} \\;=\\; S_T\\,\\frac{\\partial \\widetilde{T}}{\\partial t},\\qquad \\frac{\\partial^2 \\widehat{T}_{\\theta}}{\\partial s^2} \\;=\\; S_T\\,\\frac{\\partial^2 \\widetilde{T}}{\\partial s^2}.\n$$\n用神经网络输出评估的偏微分方程残差是\n$$\n\\mathcal{R}(s,t;\\theta) \\;=\\; \\frac{\\partial \\widehat{T}_{\\theta}}{\\partial t} \\;-\\; \\chi_{\\parallel}\\,\\frac{\\partial^2 \\widehat{T}_{\\theta}}{\\partial s^2} \\;-\\; Q \\;=\\; S_T\\Big(\\frac{\\partial \\widetilde{T}}{\\partial t} \\;-\\; \\chi_{\\parallel}\\,\\frac{\\partial^2 \\widetilde{T}}{\\partial s^2}\\Big)\\;-\\;Q.\n$$\n由此直接得出两个关于条件性的方面。\n\n$1.$ 对二阶导数自动微分的影响。通过自动微分计算的 $\\frac{\\partial^2 \\widehat{T}_{\\theta}}{\\partial s^2}$ 的量级与 $S_T$ 呈线性关系。因此，如果 $S_T$ 非常大，二阶导数值及其参数敏感性将被放大，从而引发梯度爆炸；如果 $S_T$ 非常小，它们将被衰减，从而引发梯度消失。此外，深度网络中非线性激活函数的内部参数会间接受到目标尺度的影响：尺度不佳的目标通常会驱使权重变得很大，将激活函数推入饱和区，在饱和区高阶导数很小，从而降低了二阶导数自动微分的准确性和稳定性。\n\n$2.$ 对残差缩放和损失平衡的影响。在 $\\mathcal{R}$ 中，时间和空间导数项共享公共前置因子 $S_T$，但源项 $Q$ 没有。因此，仅重新缩放输出会改变导数块 $S_T(\\partial_t \\widetilde{T} - \\chi_{\\parallel}\\partial_{ss}\\widetilde{T})$ 相对于源项 $Q$ 的相对量级。如果损失是 $\\mathcal{R}$ 的均方误差，那么不佳的 $S_T$ 选择可能会使源项相对于导数项的权重过高或过低，导致复合损失中梯度不平衡。此外，由于数据失配通常是在 $T$ 本身上测量的，因此重新缩放 $T$ 会改变数据损失与偏微分方程残差损失的相对尺度。\n\n从量纲分析来看，一条通往条件良好的二阶导数计算和平衡的损失量级的物理上合理的路径是进行无量纲化，使得控制系数为 $\\mathcal{O}(1)$，并且典型的导数量级为 $\\mathcal{O}(1)$。引入沿磁力线的特征长度 $L$ 和特征时间 $\\tau = L^2/\\chi_{\\parallel}$，并定义\n$$\ns \\;=\\; L\\,\\widetilde{s},\\qquad t \\;=\\; \\tau\\,\\widetilde{t},\\qquad \\widetilde{T} \\;=\\; \\frac{T - T_{\\mathrm{ref}}}{S_T},\\qquad \\widetilde{Q} \\;=\\; \\frac{Q\\,\\tau}{S_T}.\n$$\n根据链式法则，\n$$\n\\frac{\\partial}{\\partial t} \\;=\\; \\frac{1}{\\tau}\\frac{\\partial}{\\partial \\widetilde{t}}, \\qquad \\frac{\\partial^2}{\\partial s^2} \\;=\\; \\frac{1}{L^2}\\frac{\\partial^2}{\\partial \\widetilde{s}^2}.\n$$\n将 $T \\,=\\, T_{\\mathrm{ref}} + S_T \\widetilde{T}$ 代入控制方程，并除以 $S_T/\\tau$，得到无量纲平衡方程\n$$\n\\frac{\\partial \\widetilde{T}}{\\partial \\widetilde{t}} \\;=\\; \\frac{\\chi_{\\parallel}\\,\\tau}{L^2}\\,\\frac{\\partial^2 \\widetilde{T}}{\\partial \\widetilde{s}^2} \\;+\\; \\frac{Q\\,\\tau}{S_T} \\;=\\; \\frac{\\partial^2 \\widetilde{T}}{\\partial \\widetilde{s}^2} \\;+\\; \\widetilde{Q},\n$$\n因为 $\\tau = L^2/\\chi_{\\parallel}$。通过这种选择，乘以二阶导数的系数恰好为1，并且只要 $S_T$ 被选为像 $\\Delta T$ 这样的物理振幅，$\\partial_{\\widetilde{t}}\\widetilde{T}$ 和 $\\partial_{\\widetilde{s}\\widetilde{s}}\\widetilde{T}$ 的典型量级都将是 $\\mathcal{O}(1)$。在这种无量纲化形式下，对无量纲输入 $\\widetilde{s}$ 进行二阶导数的自动微分避免了巨大或微小的前置因子，从而仅因缩放问题就降低了梯度爆炸或消失的风险。在用无量纲单位表示所有项后，它还使残差损失和数据损失具有可比性，并且如果需要，可以添加适度的平衡权重。\n\n我们现在分析每个选项。\n\n选项A：通过 $S_T$ 进行仿射常数缩放确实会同等地乘上时间和空间导数项；然而，在残差 $\\mathcal{R}$ 中，源项 $Q$ 仍未被缩放，数据失配项也受到 $S_T$ 选择的影响。更重要的是，二阶导数的自动微分产生的值与 $S_T$ 成正比，因此极端的 $S_T$ 会加剧梯度缩放的病态问题。当典型 $L$ 很大或很小时，保持 $s$ 和 $t$ 为有量纲的也会导致绝对曲率很大或很小，从而进一步恶化条件性。因此，声称这对条件性是最佳的说法是不正确的。结论：不正确。\n\n选项B：该选项执行了标准的无量纲化：对输出使用 $S_T = \\Delta T$，以及 $s = L\\widetilde{s}$、$t = \\tau \\widetilde{t}$，其中 $\\tau = L^2/\\chi_{\\parallel}$。无量纲形式 $\\partial_{\\widetilde{t}}\\widetilde{T} = \\partial_{\\widetilde{s}\\widetilde{s}}\\widetilde{T} + \\widetilde{Q}$ 的系数为单位阶，并且相对于 $\\widetilde{s}$ 的典型二阶导数为 $\\mathcal{O}(1)$，因为 $\\partial_{ss} T \\sim \\Delta T/L^2$ 意味着 $\\partial_{\\widetilde{s}\\widetilde{s}}\\widetilde{T} \\sim \\mathcal{O}(1)$。这改善了二阶导数自动微分的数值条件性，并在用无量纲单位表示时平衡了残差损失和数据损失中的贡献。这直接解决了导数条件性和损失平衡两个问题。结论：正确。\n\n选项C：输出的二阶导数与 $S_T$ 呈线性关系，而非二次关系。选择 $S_T = (\\Delta T)^2$ 是任意的，并将缩放与物理振幅脱钩，导致导数相对于源项和数据被过度衰减或放大。它既没有消除曲率项前的有量纲系数，也不能保证自动微分中导数的量级为 $\\mathcal{O}(1)$。结论：不正确。\n\n选项D：在不进行重新缩放的情况下增加残差的权重，并不能改善二阶导数自动微分的内在条件性。它实际上可能通过迫使优化器追逐尺度不佳的残差，放大来自条件恶劣的曲率项的梯度，从而加剧不稳定性。它也未解决有量纲系数 $\\chi_{\\parallel}$ 和域尺度 $L$ 和 $\\tau$ 的问题。结论：不正确。\n\n因此，能够最小化与二阶导数计算相关的训练不稳定性并平衡损失的归一化选择，是选项B中基于物理动机的无量纲化方法。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "如果一个代理模型只提供单点预测，而没有对其不确定性进行估计，那么它的科学价值是有限的。集成方法为量化不确定性提供了一种实用而强大的途径，通过训练多个模型并分析其预测的差异来实现。这项高级实践  将多个概念融合成一个综合性项目：求解Grad-Shafranov方程、施加边界条件，以及实现一个基于集成的不确定性量化框架，为我们从简单的代理建模迈向生成预测性分布提供了一个范本。",
            "id": "4050744",
            "problem": "您需要设计并实现一个集成物理信息神经网络 (PINN) 代理模型，用于在与计算聚变科学与工程相关的简化设置中，对磁静力平衡极向磁通函数 $\\psi(R,Z)$ 进行建模。目标是通过聚合集成中的物理残差和诊断拟合误差，来计算 $\\psi(R,Z)$ 的预测不确定性区间。您编写的程序必须是一个完整的、可运行的 Python $3.12$ 脚本，并遵守后面指定的约束。本问题中的所有量都是无量纲的（归一化单位），输出必须是浮点数或布尔值，不附加任何物理单位。\n\n本问题的基础始于归一化单位下的轴对称 Grad–Shafranov 算子。考虑一个矩形域，其径向坐标 $R \\in [R_{\\min},R_{\\max}]$，垂直坐标 $Z \\in [Z_{\\min},Z_{\\max}]$，其中 $R_{\\min} = 1.0$，$R_{\\max} = 2.0$，$Z_{\\min} = -1.0$，且 $Z_{\\max} = 1.0$。简化的磁静力平衡算子为\n$$\n\\mathcal{L}[\\psi](R,Z) \\equiv \\frac{\\partial}{\\partial R}\\left(\\frac{1}{R}\\frac{\\partial \\psi}{\\partial R}\\right) + \\frac{\\partial^2 \\psi}{\\partial Z^2},\n$$\n平衡关系为\n$$\n\\mathcal{L}[\\psi](R,Z) = - R j(R,Z),\n$$\n其中 $j(R,Z)$ 是给定的归一化单位下的环向电流密度。在矩形边界上，强制施加狄利克雷条件 $\\psi = 0$。\n\n为了给 PINN 合成物理上一致的训练目标，定义一个满足边界条件的解析真值磁通函数，\n$$\np(R) = (R - R_{\\min})(R_{\\max} - R), \\quad q(Z) = (Z - Z_{\\min})(Z_{\\max} - Z),\n$$\n$$\ns_R(R) = \\sin\\left(\\pi \\frac{R - R_{\\min}}{R_{\\max} - R_{\\min}}\\right), \\quad c_Z(Z) = \\cos\\left(\\pi \\frac{Z - Z_{\\min}}{Z_{\\max} - Z_{\\min}}\\right),\n$$\n$$\n\\psi_{\\text{true}}(R,Z) = p(R) \\, q(Z) \\, s_R(R) \\, c_Z(Z).\n$$\n使用平衡算子，通过 $\\psi_{\\text{true}}(R,Z)$ 定义电流密度 $j(R,Z)$：\n$$\nj(R,Z) = -\\frac{1}{R}\\,\\mathcal{L}[\\psi_{\\text{true}}](R,Z).\n$$\n评估 $\\mathcal{L}[\\psi_{\\text{true}}](R,Z)$ 所需的导数必须使用乘法法则和链式法则从第一性原理推导：\n- $p_R(R) = R_{\\min} + R_{\\max} - 2R$, $p_{RR}(R) = -2$,\n- $q_Z(Z) = Z_{\\min} + Z_{\\max} - 2Z$, $q_{ZZ}(Z) = -2$,\n- $s_R'(R) = \\pi \\cos\\left(\\pi \\frac{R - R_{\\min}}{R_{\\max} - R_{\\min}}\\right)$, $s_R''(R) = -\\pi^2 s_R(R)$,\n- $c_Z'(Z) = -\\frac{\\pi}{2} \\sin\\left(\\pi \\frac{Z - Z_{\\min}}{Z_{\\max} - Z_{\\min}}\\right)$, $c_Z''(Z) = -\\frac{\\pi^2}{4} c_Z(Z)$.\n然后\n$$\n\\frac{\\partial \\psi_{\\text{true}}}{\\partial R} = q(Z)c_Z(Z)\\left[p_R(R) s_R(R) + p(R) s_R'(R)\\right], \n$$\n$$\n\\frac{\\partial^2 \\psi_{\\text{true}}}{\\partial R^2} = q(Z)c_Z(Z)\\left[p_{RR}(R) s_R(R) + 2 p_R(R) s_R'(R) + p(R) s_R''(R)\\right],\n$$\n$$\n\\frac{\\partial \\psi_{\\text{true}}}{\\partial Z} = p(R) s_R(R)\\left[q_Z(Z) c_Z(Z) + q(Z) c_Z'(Z)\\right],\n$$\n$$\n\\frac{\\partial^2 \\psi_{\\text{true}}}{\\partial Z^2} = p(R)s_R(R)\\left[q_{ZZ}(Z) c_Z(Z) + 2 q_Z(Z) c_Z'(Z) + q(Z) c_Z''(Z)\\right].\n$$\n因此，\n$$\n\\mathcal{L}[\\psi_{\\text{true}}](R,Z) = -\\frac{1}{R^2}\\frac{\\partial \\psi_{\\text{true}}}{\\partial R} + \\frac{1}{R}\\frac{\\partial^2 \\psi_{\\text{true}}}{\\partial R^2} + \\frac{\\partial^2 \\psi_{\\text{true}}}{\\partial Z^2}.\n$$\n\n您将构建一个集成物理信息神经网络代理模型，该模型使用固定随机特征，其系数通过最小化物理残差和拟合诊断数据来确定。使用一个满足边界条件的面具函数 $B(R,Z) = p(R) q(Z)$，使得代理模型在边界上自动满足 $\\psi(R,Z) = 0$。定义一个随机特征代理模型\n$$\n\\psi_{\\text{model}}(R,Z) = B(R,Z)\\sum_{i=1}^{n_f} c_i \\,\\phi_i(R,Z),\n$$\n其中每个特征为 $\\phi_i(R,Z) = \\tanh(w_i R + v_i Z + b_i)$，具有固定的随机参数 $(w_i,v_i,b_i)$ 和可训练的线性系数 $c_i$。为了施加物理算子，对于任何特征，将作用于 $B\\phi_i$ 的算子表示为\n$$\n\\mathcal{L}[B\\phi_i](R,Z) = \\frac{\\partial}{\\partial R}\\left(\\frac{1}{R}\\frac{\\partial (B\\phi_i)}{\\partial R}\\right) + \\frac{\\partial^2 (B\\phi_i)}{\\partial Z^2}.\n$$\n使用乘法法则，写出\n$$\n\\frac{\\partial (B\\phi)}{\\partial R} = B_R \\phi + B \\phi_R, \\quad \\frac{\\partial^2 (B\\phi)}{\\partial R^2} = B_{RR}\\phi + 2 B_R \\phi_R + B \\phi_{RR},\n$$\n$$\n\\frac{\\partial^2 (B\\phi)}{\\partial Z^2} = B_{ZZ}\\phi + 2 B_Z \\phi_Z + B \\phi_{ZZ},\n$$\n并组合得到\n$$\n\\mathcal{L}[B\\phi](R,Z) = -\\frac{1}{R^2}\\left(B_R \\phi + B \\phi_R\\right) + \\frac{1}{R}\\left(B_{RR}\\phi + 2 B_R \\phi_R + B \\phi_{RR}\\right) + \\left(B_{ZZ}\\phi + 2 B_Z \\phi_Z + B \\phi_{ZZ}\\right).\n$$\n对于 $\\phi(R,Z)=\\tanh(a)$ 且 $a=w R + v Z + b$，\n$$\n\\phi_R = \\operatorname{sech}^2(a)\\, w, \\quad \\phi_Z = \\operatorname{sech}^2(a)\\, v, \\quad \\phi_{RR} = -2 w^2 \\operatorname{sech}^2(a)\\tanh(a), \\quad \\phi_{ZZ} = -2 v^2 \\operatorname{sech}^2(a)\\tanh(a).\n$$\n\n为了训练系数 $c_i$，通过堆叠两种类型的行来组建一个线性最小二乘系统：\n- 来自域内配置点 $(R_k,Z_k)$ 的物理行，强制 $\\sum_i c_i \\,\\mathcal{L}[B\\phi_i](R_k,Z_k) \\approx - R_k j(R_k,Z_k)$，\n- 来自测量点 $(\\hat{R}_\\ell,\\hat{Z}_\\ell)$ 的诊断行，强制 $\\sum_i c_i \\, B(\\hat{R}_\\ell,\\hat{Z}_\\ell)\\,\\phi_i(\\hat{R}_\\ell,\\hat{Z}_\\ell) \\approx \\psi_{\\text{true}}(\\hat{R}_\\ell,\\hat{Z}_\\ell)$。\n\n求解线性最小二乘问题得到 $c = (c_1,\\ldots,c_{n_f})$。通过使用独立重采样的随机特征以及独立重采样的配置点和诊断点重复训练过程，创建一个集成。对于每个集成成员 $m$，计算：\n- 在其诊断点上的标量诊断均方根误差 $e_m$，\n- 在测试位置 $(R,Z)$ 的物理残差，$\\rho_m(R,Z) = \\sum_i c_i \\,\\mathcal{L}[B\\phi_i](R,Z) + R j(R,Z)$，\n- 预测值 $\\psi_m(R,Z) = B(R,Z)\\sum_i c_i \\phi_i(R,Z)$。\n\n通过定义 $\\{\\psi_m(R,Z)\\}$ 的集成均值 $\\mu(R,Z)$ 和样本方差 $s^2_{\\text{ens}}(R,Z)$，然后在 $(R,Z)$ 处聚合不确定性，形成\n$$\nv(R,Z) = s^2_{\\text{ens}}(R,Z) + \\overline{\\rho(R,Z)^2} + \\overline{e^2},\n$$\n其中 $\\overline{\\rho(R,Z)^2}$ 是 $\\rho_m(R,Z)^2$ 的集成平均值，$\\overline{e^2}$ 是 $e_m^2$ 的集成平均值。在 $95\\%$ 置信水平下的预测区间为\n$$\n\\left[\\mu(R,Z) - 1.96 \\sqrt{v(R,Z)}, \\, \\mu(R,Z) + 1.96 \\sqrt{v(R,Z)}\\right].\n$$\n\n按照描述实现集成 PINN，并使用以下固定选项以确保可复现性：\n- 集成大小 $M = 8$，\n- 每个模型的随机特征数量 $n_f = 25$，\n- 从开放内部 $(R_{\\min},R_{\\max}) \\times (Z_{\\min},Z_{\\max})$ 均匀采样的物理配置点数量 $N_c = 500$，\n- 从同一内部均匀采样的诊断点数量 $N_d = 50$，\n- 在最小二乘中添加的微小的吉洪诺夫正则化，参数为 $\\lambda_{\\text{reg}} = 10^{-6}$，作为系数平方惩罚项。\n\n您的程序必须在以下四个测试点评估 $95\\%$ 预测区间的覆盖情况（所有量均为无量纲的归一化单位）：\n- 测试用例 1：$(R,Z) = (1.5,0.0)$，\n- 测试用例 2：$(R,Z) = (1.05,0.95)$，\n- 测试用例 3（边界边缘情况）：$(R,Z) = (1.0,0.0)$，\n- 测试用例 4（角点边界边缘情况）：$(R,Z) = (2.0,1.0)$。\n\n对于每个测试用例，计算集成预测区间，并返回一个布尔值，指示真值 $\\psi_{\\text{true}}(R,Z)$ 是否位于 $95\\%$ 预测区间内。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，`\"[True,False,True,True]\"`）。\n\n因此，测试套件是上述四个 $(R,Z)$ 对的有序列表，您的程序必须按相同顺序输出一个包含四个布尔值的列表。布尔值必须是唯一的输出。",
            "solution": "用户要求设计并实现一个集成物理信息神经网络 (PINN) 代理模型，以解决一个简化的磁静力平衡问题，并计算预测不确定性区间。\n\n### 第一步：提取已知条件\n\n- **域：** 一个矩形域，其径向坐标 $R \\in [R_{\\min},R_{\\max}]$，垂直坐标 $Z \\in [Z_{\\min},Z_{\\max}]$，其中 $R_{\\min} = 1.0$，$R_{\\max} = 2.0$，$Z_{\\min} = -1.0$，且 $Z_{\\max} = 1.0$。\n- **控制算子：** 简化的 Grad–Shafranov 算子是 $\\mathcal{L}[\\psi](R,Z) \\equiv \\frac{\\partial}{\\partial R}\\left(\\frac{1}{R}\\frac{\\partial \\psi}{\\partial R}\\right) + \\frac{\\partial^2 \\psi}{\\partial Z^2}$。\n- **平衡方程：** $\\mathcal{L}[\\psi](R,Z) = - R j(R,Z)$，其中 $j(R,Z)$ 是给定的环向电流密度。\n- **边界条件：** 在域边界上施加狄利克雷条件 $\\psi = 0$。\n- **解析真值解：** $\\psi_{\\text{true}}(R,Z) = p(R) \\, q(Z) \\, s_R(R) \\, c_Z(Z)$，其中：\n  - $p(R) = (R - R_{\\min})(R_{\\max} - R)$\n  - $q(Z) = (Z - Z_{\\min})(Z_{\\max} - Z)$\n  - $s_R(R) = \\sin\\left(\\pi \\frac{R - R_{\\min}}{R_{\\max} - R_{\\min}}\\right)$\n  - $c_Z(Z) = \\cos\\left(\\pi \\frac{Z - Z_{\\min}}{Z_{\\max} - Z_{\\min}}\\right)$\n- **电流密度定义：** $j(R,Z) = -\\frac{1}{R}\\,\\mathcal{L}[\\psi_{\\text{true}}](R,Z)$。\n- **给定的 $\\psi_{\\text{true}}$ 的导数：** 提供了 $\\psi_{\\text{true}}$ 关于 $R$ 和 $Z$ 的一阶和二阶偏导数表达式，以及展开式 $\\mathcal{L}[\\psi_{\\text{true}}] = -\\frac{1}{R^2}\\frac{\\partial \\psi_{\\text{true}}}{\\partial R} + \\frac{1}{R}\\frac{\\partial^2 \\psi_{\\text{true}}}{\\partial R^2} + \\frac{\\partial^2 \\psi_{\\text{true}}}{\\partial Z^2}$。\n- **代理模型：** 定义了一个带有满足边界条件的面具函数 $B(R,Z) = p(R) q(Z)$ 的随机特征模型，其形式为 $\\psi_{\\text{model}}(R,Z) = B(R,Z)\\sum_{i=1}^{n_f} c_i \\,\\phi_i(R,Z)$。\n- **模型特征：** $\\phi_i(R,Z) = \\tanh(w_i R + v_i Z + b_i)$，其中 $(w_i,v_i,b_i)$ 是固定的随机参数。\n- **给定的模型基上的算子：** 提供了 $\\mathcal{L}[B\\phi]$ 的表达式，以及 $\\phi$ 的导数。\n- **训练过程：** 通过求解一个由以下部分构建的线性最小二乘问题来确定可训练系数 $c_i$：\n  - 物理约束：在 $N_c$ 个配置点上，$\\sum_i c_i \\,\\mathcal{L}[B\\phi_i](R_k,Z_k) \\approx - R_k j(R_k,Z_k)$。\n  - 诊断约束：在 $N_d$ 个诊断点上，$\\sum_i c_i \\, B(\\hat{R}_\\ell,\\hat{Z}_\\ell)\\,\\phi_i(\\hat{R}_\\ell,\\hat{Z}_\\ell) \\approx \\psi_{\\text{true}}(\\hat{R}_\\ell,\\hat{Z}_\\ell)$。\n- **集成与不确定性量化：**\n  - 通过重采样特征和点来创建 $M$ 个模型的集成。\n  - 对于每个成员 $m$，计算其诊断均方根误差 $e_m$、预测值 $\\psi_m(R,Z)$ 和在测试点上的物理残差 $\\rho_m(R,Z)$。\n  - 总方差定义为 $v(R,Z) = s^2_{\\text{ens}}(R,Z) + \\overline{\\rho(R,Z)^2} + \\overline{e^2}$，其中 $s^2_{\\text{ens}}$ 是预测值的样本方差，$\\overline{(\\cdot)}$ 表示集成平均。\n  - $95\\%$ 预测区间为 $[\\mu(R,Z) - 1.96 \\sqrt{v(R,Z)}, \\, \\mu(R,Z) + 1.96 \\sqrt{v(R,Z)}]$。\n- **固定参数：**\n  - 集成大小 $M = 8$。\n  - 每个模型的特征数 $n_f = 25$。\n  - 物理点数 $N_c = 500$。\n  - 诊断点数 $N_d = 50$。\n  - 吉洪诺夫正则化 $\\lambda_{\\text{reg}} = 10^{-6}$。\n  - 点从域的开放内部采样。\n- **任务：** 对于四个指定的测试点 $(1.5,0.0)$, $(1.05,0.95)$, $(1.0,0.0)$ 和 $(2.0,1.0)$，评估 $\\psi_{\\text{true}}(R,Z)$ 是否位于 $95\\%$ 预测区间内。\n- **输出：** 表示四个布尔值列表的单个字符串，例如 `\"[True,False,True,True]\"`。\n\n### 第二步：使用提取的已知条件进行验证\n\n- **科学依据：** 该问题牢固地植根于计算等离子体物理学（Grad-Shafranov 方程）和用于求解微分方程的现代机器学习技术（PINN，随机特征模型）。人造解法是一种标准的验证技术。不确定性量化的启发式方法，虽然具体，但是是模型方差、物理违背和数据失配的一种合理组合。该问题在科学上是合理的。\n- **良定性：** 问题陈述异常详细，提供了所有必要的方程、参数和算法步骤。使用人造解法确保了已知真值的存在。最小二乘问题是正则化的，保证了模型系数的唯一解。整个过程是确定性的且定义明确。为了可复现性，需要一个固定的随机种子，这是此类计算任务中隐含要求的标准实践。\n- **客观性：** 该问题使用精确的数学形式主义和客观语言描述，没有任何主观或模棱两可的陈述。\n- **一致性与完整性：** 所提供的定义和方程是内部一致的。对 $\\psi_{\\text{true}}$ 组件和特征函数 $\\phi_i$ 的导数进行的检查证实了它们的正确性。Grad-Shafranov 算子 $\\mathcal{L}$ 的展开也是正确的。该问题是自包含的，并提供了完整实现所需的所有信息。唯一的小模糊之处是随机特征参数的分布，可以通过采用标准选择（例如，标准正态分布）来解决，这在此背景下是一个合理的假设。\n- **其他缺陷：** 该问题没有表现出任何其他缺陷，如不切实际、结构不良、过于简单或无法验证。测试用例适当地包含了内部点和边界点，以测试解决方案的鲁棒性。\n\n### 第三步：结论与行动\n该问题被判定为**有效**。这是一个定义明确、有科学依据且计算上可行的应用集成 PINN 代理模型的练习。我现在将着手构建解决方案。\n\n### 基于原理的设计与求解\n\n解决方案的核心在于忠实地实现所提供的数学框架。该方法被分解为模块化组件：用于真值的函数、用于代理模型基的函数，以及一个用于管理集成训练和不确定性评估的主程序。\n\n首先，我们定义一组函数来计算真值解 $\\psi_{\\text{true}}(R,Z)$ 和相关的源电流密度 $j(R,Z)$。这是基于人造解法，其中 $\\psi_{\\text{true}}$ 被解析定义，并使用控制方程来导出相应的源项 $j(R,Z) = - \\frac{1}{R}\\mathcal{L}[\\psi_{\\text{true}}](R,Z)$。这需要仔细实现为 $\\psi_{\\text{true}}$ 的导数提供的表达式。这些函数必须被向量化，以高效地对坐标数组进行操作，这是使用 Python 进行科学计算的标准实践。\n\n其次，我们实现代理模型的组件，$\\psi_{\\text{model}}(R,Z) = B(R,Z) \\sum_{i=1}^{n_f} c_i \\phi_i(R,Z)$。满足边界条件的面具函数 $B(R,Z)$ 确保在边界上 $\\psi_{\\text{model}} = 0$，自动满足狄利克雷条件。随机特征 $\\phi_i(R,Z) = \\tanh(w_i R + v_i Z + b_i)$ 构成了神经网络的基础。一个关键部分是实现应用于每个基函数的算子 $\\mathcal{L}[B(R,Z)\\phi_i(R,Z)]$。这涉及应用问题陈述中指定的链式法则和乘法法则，并组合众多的导数项。\n\n第三，对于集成的 $M$ 个成员中的每一个，构建一个线性最小二乘系统来找到最优系数 $c_i$。该系统 $A\\mathbf{c} \\approx \\mathbf{y}$ 结合了两种类型的约束。前 $N_c$ 行在域内部的随机配置点上强制执行 Grad-Shafranov 方程的物理规律。接下来的 $N_d$ 行强制模型在随机的“诊断”测量点上匹配真值解。一个吉洪诺夫正则化项 $\\lambda_{\\text{reg}}\\|\\mathbf{c}\\|_2^2$ 被添加到最小二乘目标中，以改善条件数并防止过拟合。通过增广系统矩阵 $A$ 和目标向量 $\\mathbf{y}$，并使用像 `numpy.linalg.lstsq` 这样的标准最小二乘求解器来解决这个正则化问题。\n\n第四，在训练完所有 $M$ 个集成成员后，我们在每个给定的测试点上评估预测不确定性。对于一个测试点 $(R,Z)$，我们计算预测集 $\\{\\psi_m(R,Z)\\}_{m=1}^M$ 和物理残差集 $\\{\\rho_m(R,Z)\\}_{m=1}^M$。问题为总预测方差 $v(R,Z)$ 定义了一个特定的启发式方法，它聚合了三个不确定性来源：集成预测的方差（$s^2_{\\text{ens}}$）、均方物理残差（$\\overline{\\rho^2}$）和来自训练的均方诊断误差（$\\overline{e^2}$）。从这个总方差中，构建一个 $95\\%$ 的预测区间。\n\n最后，我们检查已知的真值 $\\psi_{\\text{true}}(R,Z)$ 是否落在为每个测试用例计算的这个区间内。结果被收集到一个布尔值列表中，并格式化为最终输出。通过使用一个固定的主随机种子，并从中派生出单个集成成员的种子，整个过程变得可复现，确保了点和特征参数的随机采样在每次运行时都是相同的。",
            "answer": "```python\nimport numpy as np\n\n# A meticulous and exacting professor in the STEM fields.\n\n# ----[ Global Constants and Domain Definition ]----\nR_min, R_max = 1.0, 2.0\nZ_min, Z_max = -1.0, 1.0\npi = np.pi\nR_w, Z_w = R_max - R_min, Z_max - Z_min\n\n# ----[ Ground Truth Functions: psi_true and its components ]----\ndef p(R):\n    return (R - R_min) * (R_max - R)\n\ndef p_R(R):\n    return R_min + R_max - 2 * R\n\ndef p_RR(R):\n    return -2.0 * np.ones_like(R)\n\ndef q(Z):\n    return (Z - Z_min) * (Z_max - Z)\n\ndef q_Z(Z):\n    return Z_min + Z_max - 2 * Z\n\ndef q_ZZ(Z):\n    return -2.0 * np.ones_like(Z)\n\ndef s_R(R):\n    return np.sin(pi * (R - R_min) / R_w)\n\ndef s_R_p(R):\n    return (pi / R_w) * np.cos(pi * (R - R_min) / R_w)\n\ndef s_R_pp(R):\n    return -(pi / R_w)**2 * s_R(R)\n\ndef c_Z(Z):\n    return np.cos(pi * (Z - Z_min) / Z_w)\n\ndef c_Z_p(Z):\n    return -(pi / Z_w) * np.sin(pi * (Z - Z_min) / Z_w)\n\ndef c_Z_pp(Z):\n    return -(pi / Z_w)**2 * c_Z(Z)\n\ndef psi_true(R, Z):\n    # Handle scalar inputs\n    R_ = np.atleast_1d(R)\n    Z_ = np.atleast_1d(Z)\n    val = p(R_) * q(Z_) * s_R(R_) * c_Z(Z_)\n    return val.item() if np.isscalar(R) else val\n\ndef L_psi_true(R, Z):\n    # Handle scalar inputs\n    R_ = np.atleast_1d(R)\n    Z_ = np.atleast_1d(Z)\n    \n    # Partial derivatives of psi_true\n    dpsi_dR = q(Z_) * c_Z(Z_) * (p_R(R_) * s_R(R_) + p(R_) * s_R_p(R_))\n    d2psi_dR2 = q(Z_) * c_Z(Z_) * (p_RR(R_) * s_R(R_) + 2 * p_R(R_) * s_R_p(R_) + p(R_) * s_R_pp(R_))\n    d2psi_dZ2 = p(R_) * s_R(R_) * (q_ZZ(Z_) * c_Z(Z_) + 2 * q_Z(Z_) * c_Z_p(Z_) + q(Z_) * c_Z_pp(Z_))\n    \n    # Grad-Shafranov operator on psi_true\n    # Suppress division by zero warnings for R=0, though R is always > 0 in this domain.\n    with np.errstate(divide='ignore', invalid='ignore'):\n        L_val = -1.0 / R_**2 * dpsi_dR + 1.0 / R_ * d2psi_dR2 + d2psi_dZ2\n    \n    return L_val.item() if np.isscalar(R) else L_val\n\ndef j_true(R, Z):\n    R_ = np.atleast_1d(R)\n    L_psi_val = L_psi_true(R, Z)\n    with np.errstate(divide='ignore', invalid='ignore'):\n        J = -1.0 / R_ * L_psi_val\n    return J.item() if np.isscalar(R) else J\n\n\n# ----[ Surrogate Model Functions: Basis, Mask, and Operator ]----\ndef B(R, Z):\n    return p(R) * q(Z)\n\ndef B_R(R, Z): return p_R(R) * q(Z)\ndef B_Z(R, Z): return p(R) * q_Z(Z)\ndef B_RR(R, Z): return p_RR(R) * q(Z)\ndef B_ZZ(R, Z): return p(R) * q_ZZ(Z)\n\ndef phi(R, Z, w, v, b):\n    a = w * R + v * Z + b\n    return np.tanh(a)\n\ndef phi_R(R, Z, w, v, b):\n    a = w * R + v * Z + b\n    return w * (1.0 / np.cosh(a))**2\n\ndef phi_Z(R, Z, w, v, b):\n    a = w * R + v * Z + b\n    return v * (1.0 / np.cosh(a))**2\n\ndef phi_RR(R, Z, w, v, b):\n    a = w * R + v * Z + b\n    return -2 * w**2 * np.tanh(a) * (1.0 / np.cosh(a))**2\n\ndef phi_ZZ(R, Z, w, v, b):\n    a = w * R + v * Z + b\n    return -2 * v**2 * np.tanh(a) * (1.0 / np.cosh(a))**2\n\ndef L_B_phi(R, Z, w, v, b):\n    R_ = np.atleast_1d(R)\n    Z_ = np.atleast_1d(Z)\n    \n    phi_val = phi(R_, Z_, w, v, b)\n    phi_R_val = phi_R(R_, Z_, w, v, b)\n    phi_Z_val = phi_Z(R_, Z_, w, v, b)\n    phi_RR_val = phi_RR(R_, Z_, w, v, b)\n    phi_ZZ_val = phi_ZZ(R_, Z_, w, v, b)\n\n    B_val = B(R_, Z_)\n    B_R_val = B_R(R_, Z_)\n    B_Z_val = B_Z(R_, Z_)\n    B_RR_val = B_RR(R_, Z_)\n    B_ZZ_val = B_ZZ(R_, Z_)\n\n    term1 = B_R_val * phi_val + B_val * phi_R_val\n    term2 = B_RR_val * phi_val + 2 * B_R_val * phi_R_val + B_val * phi_RR_val\n    term3 = B_ZZ_val * phi_val + 2 * B_Z_val * phi_Z_val + B_val * phi_ZZ_val\n\n    with np.errstate(divide='ignore', invalid='ignore'):\n      L_val = -1.0/R_**2 * term1 + 1.0/R_ * term2 + term3\n\n    return L_val.item() if np.isscalar(R) else L_val\n\n\ndef solve():\n    # ----[ Problem Configuration ]----\n    M = 8\n    n_f = 25\n    N_c = 500\n    N_d = 50\n    lambda_reg = 1e-6\n    test_cases = [\n        (1.5, 0.0),\n        (1.05, 0.95),\n        (1.0, 0.0),\n        (2.0, 1.0),\n    ]\n\n    main_seed = 42\n    rng_main = np.random.default_rng(main_seed)\n    ensemble_seeds = rng_main.integers(low=0, high=2**31 - 1, size=M)\n\n    ensemble_members = []\n    ensemble_e_sq = []\n\n    for m in range(M):\n        rng_member = np.random.default_rng(ensemble_seeds[m])\n\n        # Sample features and points\n        features = rng_member.standard_normal(size=(n_f, 3))  # (w, v, b)\n        R_c = rng_member.uniform(R_min, R_max, N_c)\n        Z_c = rng_member.uniform(Z_min, Z_max, N_c)\n        R_d = rng_member.uniform(R_min, R_max, N_d)\n        Z_d = rng_member.uniform(Z_min, Z_max, N_d)\n\n        # Build least-squares system\n        A = np.zeros((N_c + N_d, n_f))\n        y = np.zeros(N_c + N_d)\n\n        # Physics rows\n        y[:N_c] = -R_c * j_true(R_c, Z_c)\n        for i in range(n_f):\n            w_i, v_i, b_i = features[i]\n            A[:N_c, i] = L_B_phi(R_c, Z_c, w_i, v_i, b_i)\n\n        # Diagnostic rows\n        y[N_c:] = psi_true(R_d, Z_d)\n        B_vals_d = B(R_d, Z_d)\n        for i in range(n_f):\n            w_i, v_i, b_i = features[i]\n            phi_vals_d = phi(R_d, Z_d, w_i, v_i, b_i)\n            A[N_c:, i] = B_vals_d * phi_vals_d\n\n        # Solve for coefficients with Tikhonov regularization\n        A_aug = np.vstack([A, np.sqrt(lambda_reg) * np.eye(n_f)])\n        y_aug = np.concatenate([y, np.zeros(n_f)])\n        coeffs, _, _, _ = np.linalg.lstsq(A_aug, y_aug, rcond=None)\n        \n        # Calculate diagnostic error e_m\n        psi_pred_d = np.zeros(N_d)\n        B_vals_d = B(R_d, Z_d)\n        for i in range(n_f):\n            w_i, v_i, b_i = features[i]\n            psi_pred_d += coeffs[i] * B_vals_d * phi(R_d, Z_d, w_i, v_i, b_i)\n        \n        e_m_sq = np.mean((psi_pred_d - y[N_c:])**2)\n        \n        ensemble_members.append({'coeffs': coeffs, 'features': features})\n        ensemble_e_sq.append(e_m_sq)\n\n    # ----[ Uncertainty Evaluation at Test Points ]----\n    results = []\n    mean_e_sq = np.mean(ensemble_e_sq)\n\n    for R_test, Z_test in test_cases:\n        psi_m_list = []\n        rho_m_sq_list = []\n\n        is_boundary = np.isclose(R_test, R_min) or np.isclose(R_test, R_max) or \\\n                      np.isclose(Z_test, Z_min) or np.isclose(Z_test, Z_max)\n\n        for member in ensemble_members:\n            c = member['coeffs']\n            feats = member['features']\n            \n            # Prediction psi_m\n            if is_boundary:\n                psi_m = 0.0\n            else:\n                psi_m = np.sum([\n                    c[i] * B(R_test, Z_test) * phi(R_test, Z_test, *feats[i]) \n                    for i in range(n_f)]\n                )\n            \n            # Physics residual rho_m\n            L_psi_model = np.sum([\n                c[i] * L_B_phi(R_test, Z_test, *feats[i]) \n                for i in range(n_f)]\n            )\n            rho_m = L_psi_model + R_test * j_true(R_test, Z_test)\n\n            psi_m_list.append(psi_m)\n            rho_m_sq_list.append(rho_m**2)\n\n        # Aggregate uncertainties\n        psi_m_array = np.array(psi_m_list)\n        mu = np.mean(psi_m_array)\n        s2_ens = np.var(psi_m_array, ddof=1) if M > 1 else 0.0\n        mean_rho_sq = np.mean(rho_m_sq_list)\n        \n        v = s2_ens + mean_rho_sq + mean_e_sq\n\n        # Form interval and check coverage\n        half_width = 1.96 * np.sqrt(v)\n        interval_lower = mu - half_width\n        interval_upper = mu + half_width\n        \n        psi_t = psi_true(R_test, Z_test)\n        is_covered = (psi_t >= interval_lower) and (psi_t = interval_upper)\n        results.append(is_covered)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}