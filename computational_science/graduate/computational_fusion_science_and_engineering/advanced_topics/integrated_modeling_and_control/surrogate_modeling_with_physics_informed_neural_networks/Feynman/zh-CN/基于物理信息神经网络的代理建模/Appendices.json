{
    "hands_on_practices": [
        {
            "introduction": "在求解偏微分方程时，精确施加边界条件是至关重要的。本练习介绍一种强大的技术，即使用符号距离函数（SDF）来构造神经网络输出，从而“通过构造”精确满足狄利克雷边界条件 。通过这个实践，你将学会如何将物理边界的几何信息直接编码到模型架构中，这是构建稳健可靠的PINN代理模型的基础一步。",
            "id": "4050755",
            "problem": "考虑一个轴对称环形聚变装置的二维磁极截面，该装置具有真空室边界。在Grad–Shafranov平衡方程中，我们关注的标量状态是磁极通量函数 $\\psi(\\mathbf{x})$。在真空室边界 $\\partial \\Omega$ 上，施加了狄利克雷边界条件 $\\psi(\\mathbf{x}) = \\psi_{\\text{wall}}$，适用于所有 $\\mathbf{x} \\in \\partial \\Omega$。在使用物理信息神经网络 (PINN) 进行代理建模时，目标是设计网络输出，使其无论训练如何，都能精确满足边界条件。您的任务是基于一个符号距离函数构建一个输出变换，该变换在边界 $\\partial \\Omega$ 上强制施加边界条件 $\\psi = \\psi_{\\text{wall}}$，从第一性原理出发解释其工作原理，并为一个圆形真空室实现该变换。\n\n从边界值问题的定义出发，使用符号距离函数 $s(\\mathbf{x})$ 的概念，推导出一个输出变换，该变换能将任何无约束标量函数映射为一个在边界上精确满足 $\\psi(\\mathbf{x}) = \\psi_{\\text{wall}}$ 的函数。符号距离函数应相对于真空室边界定义，几乎处处可微，并在 $\\partial \\Omega$ 上为零。请提供一个清晰的推理路径，该路径基于狄利克雷边界条件的定义和符号距离函数的性质，不要使用简便公式。\n\n然后，为一个以原点为中心、半径为 $R$ 的圆形真空室实现该变换。使用相对于该圆的符号距离函数。设无约束代理输出为一个平滑函数 $\\phi(x,y)$，其表达式为 $\\phi(x,y) = \\sin(k_{x} x)\\,\\cos(k_{y} y) + c$，其中 $k_{x}$ 和 $k_{y}$ 是波数，$c$ 是一个常数偏移。使用以下参数值：\n- $R = 1.0\\,\\mathrm{m}$，\n- $\\psi_{\\text{wall}} = 0.8\\,\\mathrm{Wb/rad}$，\n- $k_{x} = 3.0\\,\\mathrm{rad/m}$，\n- $k_{y} = 2.0\\,\\mathrm{rad/m}$，\n- $c = 0.1$。\n\n您的程序必须计算在指定测试位置变换后的输出 $\\tilde{\\psi}(x,y)$（单位为 $\\mathrm{Wb/rad}$），并验证在边界点上边界条件是否被强制施加。角度以弧度为单位。对于边界上的数值验证，如果绝对差 $|\\tilde{\\psi}(x,y) - \\psi_{\\text{wall}}|$ 小于或等于容差 $\\tau$（其中 $\\tau = 10^{-12}\\,\\mathrm{Wb/rad}$），则视为条件已满足。\n\n测试套件（请覆盖各种场景）：\n- 圆上角度为 $\\theta = 0$、$\\theta = \\pi/4$ 和 $\\theta = \\pi/2$ 的边界点，坐标为 $(x,y) = (R\\cos\\theta, R\\sin\\theta)$。在这些点上验证边界条件，并报告每个点的布尔结果（若在容差范围内满足则为true，否则为false）。\n- 一个位于极坐标 $(r,\\theta) = (0.5R,\\pi/3)$ 的内部点，转换为 $(x,y)$ 坐标后，报告浮点数值 $\\tilde{\\psi}(x,y)$（单位为 $\\mathrm{Wb/rad}$）。\n- 一个位于极坐标 $(r,\\theta) = (1.5R,\\pi/6)$ 的外部点，转换为 $(x,y)$ 坐标后，报告浮点数值 $\\tilde{\\psi}(x,y)$（单位为 $\\mathrm{Wb/rad}$）。\n- 中心点 $(x,y) = (0,0)$，报告浮点数值 $\\tilde{\\psi}(0,0)$（单位为 $\\mathrm{Wb/rad}$）。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起，顺序如下：\n$[$在 $\\theta=0$ 处的边界检查，在 $\\theta=\\pi/4$ 处的边界检查，在 $\\theta=\\pi/2$ 处的边界检查，内部点的 $\\tilde{\\psi}$ 值，外部点的 $\\tilde{\\psi}$ 值，中心点的 $\\tilde{\\psi}$ 值$]$。\n布尔条目必须是 Python 布尔值，浮点条目必须是数值（单位为 $\\mathrm{Wb/rad}$）。角度以弧度为单位。不应打印任何额外文本。",
            "solution": "构建一个能精确满足狄利克雷边界条件的磁极通量 $\\psi(\\mathbf{x})$ 代理模型，是计算科学中一个适定问题。我们将首先从第一性原理出发，严格推导所需的输出变换，然后针对指定场景进行实现。\n\n**1. 输出变换的推导**\n\n设 $\\phi(\\mathbf{x}): \\mathbb{R}^n \\to \\mathbb{R}$ 为一个任意的、无约束且表现良好的标量函数，代表代理模型的直接输出。我们需要找到一个映射 $\\tilde{\\psi}(\\mathbf{x}) = f(\\mathbf{x}, \\phi(\\mathbf{x}))$，使得 $\\tilde{\\psi}(\\mathbf{x})|_{\\mathbf{x} \\in \\partial\\Omega} = \\psi_{\\text{wall}}$。\n\n此构建的关键工具是相对于边界 $\\partial\\Omega$ 定义的符号距离函数 (SDF) $s(\\mathbf{x})$。SDF的定义属性是，当且仅当点 $\\mathbf{x}$ 位于边界 $\\partial\\Omega$ 上时，$s(\\mathbf{x}) = 0$。对于不在边界上的点，$s(\\mathbf{x}) \\neq 0$。\n\n一个通用且有效的变换结构是，一个设定边界值的项和一个包含无约束函数 $\\phi(\\mathbf{x})$ 的项的线性组合。我们提出以下形式：\n$$\n\\tilde{\\psi}(\\mathbf{x}) = A(\\mathbf{x}) + B(\\mathbf{x})\\phi(\\mathbf{x})\n$$\n其中 $A(\\mathbf{x})$ 和 $B(\\mathbf{x})$ 是待定函数。\n\n为了在 $\\partial\\Omega$ 上满足边界条件 $\\tilde{\\psi}(\\mathbf{x}) = \\psi_{\\text{wall}}$，我们在任意一点 $\\mathbf{x}_b \\in \\partial\\Omega$ 处计算该表达式：\n$$\n\\tilde{\\psi}(\\mathbf{x}_b) = A(\\mathbf{x}_b) + B(\\mathbf{x}_b)\\phi(\\mathbf{x}_b) = \\psi_{\\text{wall}}\n$$\n此等式必须对任何函数 $\\phi(\\mathbf{x})$ 都成立。这意味着包含 $\\phi(\\mathbf{x})$ 的项必须在边界上为零。因此，我们要求对于所有 $\\mathbf{x}_b \\in \\partial\\Omega$，$B(\\mathbf{x}_b) = 0$。\n\n符号距离函数 $s(\\mathbf{x})$ 正好具有此性质。通过设置 $B(\\mathbf{x}) = s(\\mathbf{x})$，我们确保了项 $s(\\mathbf{x})\\phi(\\mathbf{x})$ 在 $\\partial\\Omega$ 上恒等于零。因此，提出的变换变为：\n$$\n\\tilde{\\psi}(\\mathbf{x}) = A(\\mathbf{x}) + s(\\mathbf{x})\\phi(\\mathbf{x})\n$$\n在边界 $\\partial\\Omega$ 上计算此式可得：\n$$\n\\tilde{\\psi}(\\mathbf{x})|_{\\mathbf{x} \\in \\partial\\Omega} = A(\\mathbf{x})|_{\\mathbf{x} \\in \\partial\\Omega} + s(\\mathbf{x})|_{\\mathbf{x} \\in \\partial\\Omega} \\cdot \\phi(\\mathbf{x})|_{\\mathbf{x} \\in \\partial\\Omega} = A(\\mathbf{x})|_{\\mathbf{x} \\in \\partial\\Omega} + 0 \\cdot \\phi(\\mathbf{x})|_{\\mathbf{x} \\in \\partial\\Omega} = A(\\mathbf{x})|_{\\mathbf{x} \\in \\partial\\Omega}\n$$\n为了满足狄利克雷条件，我们必须有 $A(\\mathbf{x})|_{\\mathbf{x} \\in \\partial\\Omega} = \\psi_{\\text{wall}}$。对于 $A(\\mathbf{x})$，满足此条件且适用于边界上所有点的最简单选择是常数函数 $A(\\mathbf{x}) = \\psi_{\\text{wall}}$。\n\n将 $A(\\mathbf{x})$ 和 $B(\\mathbf{x})$ 的这些选择代入，得到最终的精确输出变换：\n$$\n\\tilde{\\psi}(\\mathbf{x}) = \\psi_{\\text{wall}} + s(\\mathbf{x})\\phi(\\mathbf{x})\n$$\n这种形式通过构造保证了边界条件得到满足，而与无约束函数 $\\phi(\\mathbf{x})$ 的行为无关。\n\n**2. 在圆形真空室中的应用**\n\n问题指定了一个以原点 $(0,0)$ 为中心、半径为 $R$ 的圆形真空室。边界 $\\partial\\Omega$ 是满足 $x^2+y^2=R^2$ 的点集 $(x,y)$。\n\n对于此几何形状，符号距离函数 $s(x,y)$ 是点 $(x,y)$ 到原点的距离减去半径 $R$。我们将其定义为：\n$$\ns(x,y) = \\sqrt{x^2+y^2} - R\n$$\n该函数在圆内为负，圆外为正，在圆上为零，符合要求。除原点外，它处处可微，满足“几乎处处可微”的条件。\n\n无约束代理输出由平滑函数给出：\n$$\n\\phi(x,y) = \\sin(k_{x} x)\\,\\cos(k_{y} y) + c\n$$\n\n将这些具体形式代入通用变换中，我们得到变换后磁极通量的表达式：\n$$\n\\tilde{\\psi}(x,y) = \\psi_{\\text{wall}} + \\left(\\sqrt{x^2+y^2} - R\\right) \\left( \\sin(k_{x} x)\\,\\cos(k_{y} y) + c \\right)\n$$\n\n**3. 数值评估**\n\n问题提供了以下参数值：\n- 半径 $R = 1.0\\,\\mathrm{m}$\n- 边界值 $\\psi_{\\text{wall}} = 0.8\\,\\mathrm{Wb/rad}$\n- 波数 $k_{x} = 3.0\\,\\mathrm{rad/m}$，$k_{y} = 2.0\\,\\mathrm{rad/m}$\n- 偏移量 $c = 0.1$\n- 容差 $\\tau = 10^{-12}\\,\\mathrm{Wb/rad}$\n\n我们现在将在指定的测试位置评估 $\\tilde{\\psi}(x,y)$。对于以极坐标 $(r,\\theta)$ 给出的点，我们使用转换 $x=r\\cos\\theta$ 和 $y=r\\sin\\theta$。\n\n- **边界点**：对于边界上的任何点，$r=R$，这意味着 $\\sqrt{x^2+y^2} = R$。项 $(\\sqrt{x^2+y^2} - R)$ 变为零。因此，$\\tilde{\\psi}(x,y) = \\psi_{\\text{wall}} + 0 = \\psi_{\\text{wall}}$。绝对差 $|\\tilde{\\psi}(x,y) - \\psi_{\\text{wall}}|$ 为 $0$，小于容差 $\\tau$。因此，边界条件被精确满足，检查将返回true。\n\n- **内部、外部和中心点**：对于不在边界上的点，我们将使用完整表达式和给定的参数计算 $\\tilde{\\psi}(x,y)$ 的值。实现过程将以数值方式执行这些计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the transformed poloidal flux function output at specified test locations.\n    The transform enforces Dirichlet boundary conditions for a circular domain.\n    \"\"\"\n    # Define constants from the problem statement.\n    R = 1.0           # Vessel radius in meters\n    psi_wall = 0.8    # Boundary value in Wb/rad\n    kx = 3.0          # Wavenumber in x-direction in rad/m\n    ky = 2.0          # Wavenumber in y-direction in rad/m\n    c = 0.1           # Constant offset, dimensionless\n    tau = 1.0e-12     # Tolerance for boundary check in Wb/rad\n\n    def s(x, y):\n        \"\"\"Signed distance function for a circle centered at the origin.\"\"\"\n        return np.sqrt(x**2 + y**2) - R\n\n    def phi(x, y):\n        \"\"\"Unconstrained surrogate model output.\"\"\"\n        return np.sin(kx * x) * np.cos(ky * y) + c\n\n    def psi_tilde(x, y):\n        \"\"\"Transformed output function enforcing the boundary condition.\"\"\"\n        return psi_wall + s(x, y) * phi(x, y)\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (description, type_of_test, coordinates)\n    test_cases = [\n        # Boundary points\n        (\"Boundary at theta=0\", \"boundary_check\", (R * np.cos(0), R * np.sin(0))),\n        (\"Boundary at theta=pi/4\", \"boundary_check\", (R * np.cos(np.pi / 4), R * np.sin(np.pi / 4))),\n        (\"Boundary at theta=pi/2\", \"boundary_check\", (R * np.cos(np.pi / 2), R * np.sin(np.pi / 2))),\n        # Interior point\n        (\"Interior at (0.5R, pi/3)\", \"value\", (0.5 * R * np.cos(np.pi / 3), 0.5 * R * np.sin(np.pi / 3))),\n        # Exterior point\n        (\"Exterior at (1.5R, pi/6)\", \"value\", (1.5 * R * np.cos(np.pi / 6), 1.5 * R * np.sin(np.pi / 6))),\n        # Center point\n        (\"Center at (0,0)\", \"value\", (0.0, 0.0)),\n    ]\n\n    results = []\n    for description, test_type, coords in test_cases:\n        x, y = coords\n        val = psi_tilde(x, y)\n        \n        if test_type == \"boundary_check\":\n            # Verify if the boundary condition is satisfied within the tolerance.\n            is_satisfied = np.abs(val - psi_wall) = tau\n            results.append(is_satisfied)\n        elif test_type == \"value\":\n            # Report the float value of psi_tilde.\n            results.append(val)\n\n    # Final print statement in the exact required format.\n    # str() on a boolean produces 'True' or 'False'.\n    # str() on a float produces its string representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "许多物理量，如等离子体密度和温度，天然具有正定性。本练习探讨了如何通过指数或softplus等非线性变换来强制施加这些物理约束，并分析了这种做法对训练动态的深层影响 。你将通过微积分推导，揭示这些变换如何改变物理残差中高阶导数的结构，从而影响梯度计算和模型的收敛性。",
            "id": "4050793",
            "problem": "考虑磁约束聚变等离子体的一维平板近似，其中碰撞跨场输运通过粒子密度的扩散和温度的热传导来建模。设粒子密度为 $n(x,t)$，温度为 $T(x,t)$，两者均为正值。粒子通量由菲克定律 (Fick's law) $J_{n} = -D_{n} \\,\\partial_{x} n$ 给出，热通量由傅里叶定律 (Fourier's law) $q = -\\chi \\,\\partial_{x} T$ 给出，其中 $D_{n}  0$ 和 $\\chi  0$ 是常数输运系数。在点 $(x_{0},t_{0})$ 处忽略源和汇，物理信息神经网络 (PINN) 中扩散算子的残差是由输运系数加权的二阶空间导数，即在 $(x_{0},t_{0})$ 点计算的密度残差算子 $R_{n} = -D_{n} \\,\\partial_{x}^{2} n$ 和温度残差算子 $R_{T} = -\\chi \\,\\partial_{x}^{2} T$。为了在神经网络代理模型中强制实现正定性，假设 PINN 输出两个预激活场 $u(x,t)$ 和 $v(x,t)$，我们通过指数映射 $n = \\exp(u)$ 和 softplus 映射 $T = s(v)$（其中 $s(v) = \\ln(1+\\exp(v))$）来定义物理输出。从这些定义和链式法则出发，推导出关于 $u$、$v$ 及其空间导数的 $\\partial_{x} n$、$\\partial_{x}^{2} n$、$\\partial_{x} T$ 和 $\\partial_{x}^{2} T$ 的表达式。明确指出 $\\partial_{x}^{2} n$ 中乘以 $(\\partial_{x} u)^{2}$ 的系数以及 $\\partial_{x}^{2} T$ 中乘以 $(\\partial_{x} v)^{2}$ 的系数。然后，在点 $(x_{0},t_{0})$ 处，定义无量纲比率\n$$\n\\mathcal{R} \\equiv \\frac{\\text{coefficient of }(\\partial_{x} u)^{2}\\text{ in }R_{n}}{\\text{coefficient of }(\\partial_{x} v)^{2}\\text{ in }R_{T}} \\, ,\n$$\n该比率量化了由 PINN 残差中的保正变换引起的梯度平方缩放的相对大小。计算当 $D_{n} = 0.25$、$\\chi = 1.5$、$u(x_{0},t_{0}) = 0.3$ 和 $v(x_{0},t_{0}) = -2.0$ 时 $\\mathcal{R}$ 的值。将 $\\mathcal{R}$ 的最终数值答案四舍五入到四位有效数字。最终答案必须表示为一个无量纲数。",
            "solution": "该问题要求我们分析两种不同的保正变换（指数函数和softplus函数）如何影响PINN物理残差中导数项的结构。我们将通过微积分严格推导所需表达式，然后计算一个量化这两种变换相对影响的比率。\n\n### 1. 密度项 $n = \\exp(u)$ 的导数推导\n\n首先，我们推导与粒子密度相关的导数。粒子密度 $n$ 定义为预激活场 $u$ 的指数函数：\n$n(x,t) = \\exp(u(x,t))$\n\n使用链式法则计算一阶空间导数 $\\partial_x n$：\n$$\n\\partial_x n = \\frac{dn}{du} \\frac{\\partial u}{\\partial x} = \\exp(u) \\, \\partial_x u\n$$\n\n接着，对上述表达式使用乘法法则和链式法则来计算二阶空间导数 $\\partial_x^2 n$：\n$$\n\\partial_x^2 n = \\partial_x (\\exp(u) \\, \\partial_x u) = (\\partial_x \\exp(u))(\\partial_x u) + \\exp(u)(\\partial_x^2 u) = (\\exp(u) \\, \\partial_x u)(\\partial_x u) + \\exp(u) \\, \\partial_x^2 u\n$$\n整理后得到：\n$$\n\\partial_x^2 n = \\exp(u) (\\partial_x u)^2 + \\exp(u) \\, \\partial_x^2 u\n$$\n因此，$\\partial_x^2 n$ 中 $(\\partial_x u)^2$ 的系数是 $\\exp(u)$。\n\n密度残差 $R_n$ 定义为 $R_n = -D_n \\partial_x^2 n$。代入 $\\partial_x^2 n$ 的表达式：\n$$\nR_n = -D_n \\left( \\exp(u) (\\partial_x u)^2 + \\exp(u) \\, \\partial_x^2 u \\right)\n$$\n所以，$R_n$ 中 $(\\partial_x u)^2$ 的系数是 $-D_n \\exp(u)$。\n\n### 2. 温度项 $T = \\ln(1+\\exp(v))$ 的导数推导\n\n接下来，我们推导与温度相关的导数。温度 $T$ 定义为预激活场 $v$ 的softplus函数：\n$T(x,t) = s(v(x,t)) = \\ln(1 + \\exp(v(x,t)))$\n\n首先，计算softplus函数 $s(v)$ 对其参数 $v$ 的导数：\n$$\n\\frac{ds}{dv} = \\frac{1}{1 + \\exp(v)} \\cdot \\exp(v) = \\frac{\\exp(v)}{1 + \\exp(v)}\n$$\n这个结果是逻辑S型函数（logistic sigmoid function），通常记为 $\\sigma(v)$。\n使用链式法则计算一阶空间导数 $\\partial_x T$：\n$$\n\\partial_x T = \\frac{ds}{dv} \\frac{\\partial v}{\\partial x} = \\sigma(v) \\, \\partial_x v\n$$\n\n为了计算二阶导数 $\\partial_x^2 T$，我们需要 $\\sigma(v)$ 对 $v$ 的导数：\n$$\n\\frac{d\\sigma}{dv} = \\frac{d}{dv} \\left( \\frac{\\exp(v)}{1 + \\exp(v)} \\right) = \\frac{\\exp(v)(1+\\exp(v)) - \\exp(v)\\exp(v)}{(1+\\exp(v))^2} = \\frac{\\exp(v)}{(1+\\exp(v))^2} = \\sigma(v)(1-\\sigma(v))\n$$\n现在，对 $\\partial_x T$ 应用乘法法则和链式法则：\n$$\n\\partial_x^2 T = \\partial_x (\\sigma(v) \\, \\partial_x v) = \\left(\\frac{d\\sigma}{dv} \\frac{\\partial v}{\\partial x}\\right)(\\partial_x v) + \\sigma(v) (\\partial_x^2 v)\n$$\n整理后得到：\n$$\n\\partial_x^2 T = \\frac{\\exp(v)}{(1+\\exp(v))^2} (\\partial_x v)^2 + \\frac{\\exp(v)}{1+\\exp(v)} \\partial_x^2 v\n$$\n因此，$\\partial_x^2 T$ 中 $(\\partial_x v)^2$ 的系数是 $\\frac{\\exp(v)}{(1+\\exp(v))^2}$。\n\n温度残差 $R_T$ 定义为 $R_T = -\\chi \\partial_x^2 T$。代入 $\\partial_x^2 T$ 的表达式：\n$$\nR_T = -\\chi \\left( \\frac{\\exp(v)}{(1+\\exp(v))^2} (\\partial_x v)^2 + \\frac{\\exp(v)}{1+\\exp(v)} \\partial_x^2 v \\right)\n$$\n所以，$R_T$ 中 $(\\partial_x v)^2$ 的系数是 $-\\chi \\frac{\\exp(v)}{(1+\\exp(v))^2}$。\n\n### 3. 计算比率 $\\mathcal{R}$\n\n根据定义，无量纲比率 $\\mathcal{R}$ 是：\n$$\n\\mathcal{R} = \\frac{\\text{coefficient of }(\\partial_{x} u)^{2}\\text{ in }R_{n}}{\\text{coefficient of }(\\partial_{x} v)^{2}\\text{ in }R_{T}} = \\frac{-D_n \\exp(u)}{-\\chi \\frac{\\exp(v)}{(1+\\exp(v))^2}}\n$$\n简化表达式：\n$$\n\\mathcal{R} = \\frac{D_n}{\\chi} \\frac{\\exp(u) (1+\\exp(v))^2}{\\exp(v)}\n$$\n现在，代入给定的数值：$D_n = 0.25$，$\\chi = 1.5$，$u = 0.3$，以及 $v = -2.0$。\n$$\n\\mathcal{R} = \\frac{0.25}{1.5} \\frac{\\exp(0.3) (1+\\exp(-2.0))^2}{\\exp(-2.0)}\n$$\n分别计算各项：\n- $\\frac{D_n}{\\chi} = \\frac{0.25}{1.5} = \\frac{1}{6}$\n- $\\exp(0.3) \\approx 1.3498588$\n- $\\exp(-2.0) \\approx 0.1353353$\n- $(1+\\exp(-2.0))^2 \\approx (1+0.1353353)^2 = 1.1353353^2 \\approx 1.28899$\n\n代入计算 $\\mathcal{R}$：\n$$\n\\mathcal{R} \\approx \\frac{1}{6} \\frac{1.3498588 \\times 1.28899}{0.1353353} \\approx \\frac{1}{6} \\times 12.85725 \\approx 2.142875\n$$\n将结果四舍五入到四位有效数字，得到 $2.143$。",
            "answer": "$$\\boxed{2.143}$$"
        },
        {
            "introduction": "任何模型的预测都伴随着不确定性，而量化这种不确定性对于科学应用至关重要。这项高级练习将引导你构建一个集成的PINN模型，用于对聚变等离子体中的磁平衡进行不确定性量化（UQ）分析 。你将学习如何综合利用模型分歧、物理残差和数据拟合误差，来构建一个全面的预测区间，从而评估代理模型的可靠性。",
            "id": "4050744",
            "problem": "要求您设计并实现一个系综物理信息神经网络（PINN）代理模型，用于在与计算聚变科学和工程相关的简化设置中，对磁静力平衡极向磁通函数 $\\psi(R,Z)$ 进行建模。目标是通过在系综中聚合物理残差和诊断拟合误差，来计算 $\\psi(R,Z)$ 的预测不确定性区间。您生成的程序必须是一个完整的、可运行的 Python $3.12$ 脚本，并遵守后面指定的约束条件。本问题中的所有量都是无量纲的（归一化单位），输出必须是浮点数或布尔值，不附带任何物理单位。\n\n本问题的基础始于归一化单位下的轴对称 Grad–Shafranov 算子。考虑一个矩形域，其径向坐标 $R \\in [R_{\\min},R_{\\max}]$，垂向坐标 $Z \\in [Z_{\\min},Z_{\\max}]$，其中 $R_{\\min} = 1.0$，$R_{\\max} = 2.0$，$Z_{\\min} = -1.0$，$Z_{\\max} = 1.0$。简化的磁静力平衡算子为\n$$\n\\mathcal{L}[\\psi](R,Z) \\equiv \\frac{\\partial}{\\partial R}\\left(\\frac{1}{R}\\frac{\\partial \\psi}{\\partial R}\\right) + \\frac{\\partial^2 \\psi}{\\partial Z^2},\n$$\n平衡关系为\n$$\n\\mathcal{L}[\\psi](R,Z) = - R j(R,Z),\n$$\n其中 $j(R,Z)$ 是指定的归一化单位下的环向电流密度。在矩形边界上，强制施加狄利克雷条件 $\\psi = 0$。\n\n为了给 PINN 合成物理一致的训练目标，定义一个满足边界条件的解析基准磁通函数，\n$$\np(R) = (R - R_{\\min})(R_{\\max} - R), \\quad q(Z) = (Z - Z_{\\min})(Z_{\\max} - Z),\n$$\n$$\ns_R(R) = \\sin\\left(\\pi \\frac{R - R_{\\min}}{R_{\\max} - R_{\\min}}\\right), \\quad c_Z(Z) = \\cos\\left(\\pi \\frac{Z - Z_{\\min}}{Z_{\\max} - Z_{\\min}}\\right),\n$$\n$$\n\\psi_{\\text{true}}(R,Z) = p(R) \\, q(Z) \\, s_R(R) \\, c_Z(Z).\n$$\n使用平衡算子，通过 $\\psi_{\\text{true}}(R,Z)$ 定义电流密度 $j(R,Z)$ 如下\n$$\nj(R,Z) = -\\frac{1}{R}\\,\\mathcal{L}[\\psi_{\\text{true}}](R,Z).\n$$\n评估 $\\mathcal{L}[\\psi_{\\text{true}}](R,Z)$ 所需的导数必须使用乘法法则和链式法则从第一性原理导出：\n- $p_R(R) = R_{\\min} + R_{\\max} - 2R$, $p_{RR}(R) = -2$,\n- $q_Z(Z) = Z_{\\min} + Z_{\\max} - 2Z$, $q_{ZZ}(Z) = -2$,\n- $s_R'(R) = \\frac{\\pi}{R_{\\max} - R_{\\min}} \\cos\\left(\\pi \\frac{R - R_{\\min}}{R_{\\max} - R_{\\min}}\\right)$, $s_R''(R) = -(\\frac{\\pi}{R_{\\max} - R_{\\min}})^2 s_R(R)$,\n- $c_Z'(Z) = -\\frac{\\pi}{Z_{\\max} - Z_{\\min}} \\sin\\left(\\pi \\frac{Z - Z_{\\min}}{Z_{\\max} - Z_{\\min}}\\right)$, $c_Z''(Z) = -(\\frac{\\pi}{Z_{\\max} - Z_{\\min}})^2 c_Z(Z)$.\n然后\n$$\n\\frac{\\partial \\psi_{\\text{true}}}{\\partial R} = q(Z)c_Z(Z)\\left[p_R(R) s_R(R) + p(R) s_R'(R)\\right], \n$$\n$$\n\\frac{\\partial^2 \\psi_{\\text{true}}}{\\partial R^2} = q(Z)c_Z(Z)\\left[p_{RR}(R) s_R(R) + 2 p_R(R) s_R'(R) + p(R) s_R''(R)\\right],\n$$\n$$\n\\frac{\\partial \\psi_{\\text{true}}}{\\partial Z} = p(R) s_R(R)\\left[q_Z(Z) c_Z(Z) + q(Z) c_Z'(Z)\\right],\n$$\n$$\n\\frac{\\partial^2 \\psi_{\\text{true}}}{\\partial Z^2} = p(R)s_R(R)\\left[q_{ZZ}(Z) c_Z(Z) + 2 q_Z(Z) c_Z'(Z) + q(Z) c_Z''(Z)\\right].\n$$\n因此，\n$$\n\\mathcal{L}[\\psi_{\\text{true}}](R,Z) = -\\frac{1}{R^2}\\frac{\\partial \\psi_{\\text{true}}}{\\partial R} + \\frac{1}{R}\\frac{\\partial^2 \\psi_{\\text{true}}}{\\partial R^2} + \\frac{\\partial^2 \\psi_{\\text{true}}}{\\partial Z^2}.\n$$\n\n您将构建一个物理信息神经网络代理模型的系综，该模型使用固定的随机特征，其系数通过最小化物理残差和拟合诊断数据来确定。使用一个满足边界条件的面具函数 $B(R,Z) = p(R) q(Z)$，使得代理模型在边界上自动满足 $\\psi(R,Z) = 0$。定义一个随机特征代理模型\n$$\n\\psi_{\\text{model}}(R,Z) = B(R,Z)\\sum_{i=1}^{n_f} c_i \\,\\phi_i(R,Z),\n$$\n其中每个特征为 $\\phi_i(R,Z) = \\tanh(w_i R + v_i Z + b_i)$，具有固定的随机参数 $(w_i,v_i,b_i)$ 和可训练的线性系数 $c_i$。为强制执行物理算子，将作用于任意特征 $B\\phi_i$ 的算子表示为\n$$\n\\mathcal{L}[B\\phi_i](R,Z) = \\frac{\\partial}{\\partial R}\\left(\\frac{1}{R}\\frac{\\partial (B\\phi_i)}{\\partial R}\\right) + \\frac{\\partial^2 (B\\phi_i)}{\\partial Z^2}.\n$$\n使用乘法法则，可写出\n$$\n\\frac{\\partial (B\\phi)}{\\partial R} = B_R \\phi + B \\phi_R, \\quad \\frac{\\partial^2 (B\\phi)}{\\partial R^2} = B_{RR}\\phi + 2 B_R \\phi_R + B \\phi_{RR},\n$$\n$$\n\\frac{\\partial^2 (B\\phi)}{\\partial Z^2} = B_{ZZ}\\phi + 2 B_Z \\phi_Z + B \\phi_{ZZ},\n$$\n组合可得\n$$\n\\mathcal{L}[B\\phi](R,Z) = -\\frac{1}{R^2}\\left(B_R \\phi + B \\phi_R\\right) + \\frac{1}{R}\\left(B_{RR}\\phi + 2 B_R \\phi_R + B \\phi_{RR}\\right) + \\left(B_{ZZ}\\phi + 2 B_Z \\phi_Z + B \\phi_{ZZ}\\right).\n$$\n对于 $\\phi(R,Z)=\\tanh(a)$，其中 $a=w R + v Z + b$，\n$$\n\\phi_R = \\operatorname{sech}^2(a)\\, w, \\quad \\phi_Z = \\operatorname{sech}^2(a)\\, v, \\quad \\phi_{RR} = -2 w^2 \\operatorname{sech}^2(a)\\tanh(a), \\quad \\phi_{ZZ} = -2 v^2 \\operatorname{sech}^2(a)\\tanh(a).\n$$\n\n为了训练系数 $c_i$，通过堆叠两种类型的行来组合一个线性最小二乘系统：\n- 来自域内配置点 $(R_k,Z_k)$ 的物理行，强制 $\\sum_i c_i \\,\\mathcal{L}[B\\phi_i](R_k,Z_k) \\approx - R_k j(R_k,Z_k)$，\n- 来自测量点 $(\\hat{R}_\\ell,\\hat{Z}_\\ell)$ 的诊断行，强制 $\\sum_i c_i \\, B(\\hat{R}_\\ell,\\hat{Z}_\\ell)\\,\\phi_i(\\hat{R}_\\ell,\\hat{Z}_\\ell) \\approx \\psi_{\\text{true}}(\\hat{R}_\\ell,\\hat{Z}_\\ell)$。\n\n求解关于 $c = (c_1,\\ldots,c_{n_f})$ 的线性最小二乘问题。通过使用独立重采样的随机特征以及独立重采样的配置点和诊断点重复训练过程，来创建一个系综。对于每个系综成员 $m$，计算：\n- 其诊断点上的标量诊断均方根误差 $e_m$，\n- 在测试位置 $(R,Z)$ 的物理残差，$\\rho_m(R,Z) = \\sum_i c_i \\,\\mathcal{L}[B\\phi_i](R,Z) + R j(R,Z)$，\n- 预测值 $\\psi_m(R,Z) = B(R,Z)\\sum_i c_i \\phi_i(R,Z)$。\n\n通过定义 $\\{\\psi_m(R,Z)\\}$ 的系综均值 $\\mu(R,Z)$ 和样本方差 $s^2_{\\text{ens}}(R,Z)$，然后构建\n$$\nv(R,Z) = s^2_{\\text{ens}}(R,Z) + \\overline{\\rho(R,Z)^2} + \\overline{e^2},\n$$\n来聚合在 $(R,Z)$ 处的不确定性，其中 $\\overline{\\rho(R,Z)^2}$ 是 $\\rho_m(R,Z)^2$ 的系综平均值，$\\overline{e^2}$ 是 $e_m^2$ 的系综平均值。$95\\%$ 置信水平下的预测区间为\n$$\n\\left[\\mu(R,Z) - 1.96 \\sqrt{v(R,Z)}, \\, \\mu(R,Z) + 1.96 \\sqrt{v(R,Z)}\\right].\n$$\n\n按照描述实现系综 PINN，并采用以下固定选择以确保可复现性：\n- 系综大小 $M = 8$，\n- 每个模型的随机特征数量 $n_f = 25$，\n- 物理配置点数量 $N_c = 500$，从开放内部 $(R_{\\min},R_{\\max}) \\times (Z_{\\min},Z_{\\max})$ 均匀采样，\n- 诊断点数量 $N_d = 50$，从相同内部均匀采样，\n- 带有参数 $\\lambda_{\\text{reg}} = 10^{-6}$ 的微小 Tikhonov 正则化，在最小二乘中作为系数平方惩罚项添加。\n\n您的程序必须在以下四个测试点评估 $95\\%$ 预测区间的覆盖率（所有量均为无量纲的归一化单位）：\n- 测试用例 1：$(R,Z) = (1.5,0.0)$，\n- 测试用例 2：$(R,Z) = (1.05,0.95)$，\n- 测试用例 3（边界边缘情况）：$(R,Z) = (1.0,0.0)$，\n- 测试用例 4（角点边界边缘情况）：$(R,Z) = (2.0,1.0)$。\n\n对于每个测试用例，计算系综预测区间，并返回一个布尔值，指示真实值 $\\psi_{\\text{true}}(R,Z)$ 是否位于 $95\\%$ 预测区间内。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，`\"[True,False,True,True]\"`）。\n\n因此，测试套件是上述四个 $(R,Z)$ 对的有序列表，您的程序必须按相同顺序输出一个包含四个布尔值的列表。这些布尔值必须是唯一的输出。",
            "solution": "该解决方案的核心是忠实地实现问题陈述中详细描述的数学和算法框架。此方法被分解为几个模块化组件：用于基准真相的函数、用于代理模型基的函数，以及一个用于管理系综训练和不确定性评估的主程序。\n\n首先，我们定义一组函数来计算基准解 $\\psi_{\\text{true}}(R,Z)$ 和相关的源电流密度 $j(R,Z)$。这遵循“人造解”方法，其中 $\\psi_{\\text{true}}$ 是解析定义的，然后使用控制方程来导出相应的源项 $j(R,Z) = - \\frac{1}{R}\\mathcal{L}[\\psi_{\\text{true}}](R,Z)$。这需要仔细实现为 $\\psi_{\\text{true}}$ 的导数提供的表达式。这些函数被矢量化以便高效地对坐标数组进行操作，这是在Python中进行科学计算的标准做法。\n\n其次，我们实现代理模型的组件，$\\psi_{\\text{model}}(R,Z) = B(R,Z) \\sum_{i=1}^{n_f} c_i \\phi_i(R,Z)$。一个满足边界条件的“面具”函数 $B(R,Z)$ 确保在边界上 $\\psi_{\\text{model}} = 0$，从而自动满足狄利克雷条件。随机特征 $\\phi_i(R,Z) = \\tanh(w_i R + v_i Z + b_i)$ 构成了神经网络的基础。一个关键部分是实现作用于每个基函数的算子 $\\mathcal{L}[B(R,Z)\\phi_i(R,Z)]$。这涉及应用问题陈述中指定的链式法则和乘法法则，并组合众多的导数项。\n\n第三，对于系综的 $M$ 个成员中的每一个，构建一个线性最小二乘系统以找到最优系数 $c_i$。这个系统 $A\\mathbf{c} \\approx \\mathbf{y}$ 结合了两种类型的约束。前 $N_c$ 行在域内部的随机配置点上强制执行Grad-Shafranov方程。接下来的 $N_d$ 行强制模型在随机的“诊断”测量点上匹配基准解。一个Tikhonov正则化项 $\\lambda_{\\text{reg}}\\|\\mathbf{c}\\|_2^2$ 被添加到最小二乘目标中，以改善条件数并防止过拟合。通过增广系统矩阵 $A$ 和目标向量 $\\mathbf{y}$，并使用像 `numpy.linalg.lstsq` 这样的标准最小二乘求解器来解决这个正则化问题。\n\n第四，在训练完所有 $M$ 个系综成员后，我们在每个给定的测试点评估预测不确定性。对于一个测试点 $(R,Z)$，我们计算预测集 $\\{\\psi_m(R,Z)\\}_{m=1}^M$ 和物理残差集 $\\{\\rho_m(R,Z)\\}_{m=1}^M$。问题为总预测方差 $v(R,Z)$ 定义了一个特定的启发式方法，该方法聚合了三个不确定性来源：系综预测的方差（$s^2_{\\text{ens}}$）、均方物理残差（$\\overline{\\rho^2}$）和训练中的均方诊断误差（$\\overline{e^2}$）。从这个总方差中，构建一个 $95\\%$ 的预测区间。\n\n最后，我们检查已知的基准值 $\\psi_{\\text{true}}(R,Z)$ 是否落在为每个测试用例计算的这个区间内。结果被收集到一个布尔值列表中，并格式化为最终输出。通过使用一个固定的主随机种子，从中派生出单个系综成员的种子，整个过程变得可复现，确保了点和特征参数的随机抽样在每次运行时都是相同的。",
            "answer": "```python\nimport numpy as np\n\n# A meticulous and exacting professor in the STEM fields.\n\n# ----[ Global Constants and Domain Definition ]----\nR_min, R_max = 1.0, 2.0\nZ_min, Z_max = -1.0, 1.0\npi = np.pi\nR_w, Z_w = R_max - R_min, Z_max - Z_min\n\n# ----[ Ground Truth Functions: psi_true and its components ]----\ndef p(R):\n    return (R - R_min) * (R_max - R)\n\ndef p_R(R):\n    return R_min + R_max - 2 * R\n\ndef p_RR(R):\n    return -2.0 * np.ones_like(R)\n\ndef q(Z):\n    return (Z - Z_min) * (Z_max - Z)\n\ndef q_Z(Z):\n    return Z_min + Z_max - 2 * Z\n\ndef q_ZZ(Z):\n    return -2.0 * np.ones_like(Z)\n\ndef s_R(R):\n    return np.sin(pi * (R - R_min) / R_w)\n\ndef s_R_p(R):\n    return (pi / R_w) * np.cos(pi * (R - R_min) / R_w)\n\ndef s_R_pp(R):\n    return -(pi / R_w)**2 * s_R(R)\n\ndef c_Z(Z):\n    return np.cos(pi * (Z - Z_min) / Z_w)\n\ndef c_Z_p(Z):\n    return -(pi / Z_w) * np.sin(pi * (Z - Z_min) / Z_w)\n\ndef c_Z_pp(Z):\n    return -(pi / Z_w)**2 * c_Z(Z)\n\ndef psi_true(R, Z):\n    # Handle scalar inputs\n    R_ = np.atleast_1d(R)\n    Z_ = np.atleast_1d(Z)\n    val = p(R_) * q(Z_) * s_R(R_) * c_Z(Z_)\n    return val.item() if np.isscalar(R) else val\n\ndef L_psi_true(R, Z):\n    # Handle scalar inputs\n    R_ = np.atleast_1d(R)\n    Z_ = np.atleast_1d(Z)\n    \n    # Partial derivatives of psi_true\n    dpsi_dR = q(Z_) * c_Z(Z_) * (p_R(R_) * s_R(R_) + p(R_) * s_R_p(R_))\n    d2psi_dR2 = q(Z_) * c_Z(Z_) * (p_RR(R_) * s_R(R_) + 2 * p_R(R_) * s_R_p(R_) + p(R_) * s_R_pp(R_))\n    d2psi_dZ2 = p(R_) * s_R(R_) * (q_ZZ(Z_) * c_Z(Z_) + 2 * q_Z(Z_) * c_Z_p(Z_) + q(Z_) * c_Z_pp(Z_))\n    \n    # Grad-Shafranov operator on psi_true\n    # Suppress division by zero warnings for R=0, though R is always > 0 in this domain.\n    with np.errstate(divide='ignore', invalid='ignore'):\n        L_val = -1.0 / R_**2 * dpsi_dR + 1.0 / R_ * d2psi_dR2 + d2psi_dZ2\n    \n    return L_val.item() if np.isscalar(R) else L_val\n\ndef j_true(R, Z):\n    R_ = np.atleast_1d(R)\n    L_psi_val = L_psi_true(R, Z)\n    with np.errstate(divide='ignore', invalid='ignore'):\n        J = -1.0 / R_ * L_psi_val\n    return J.item() if np.isscalar(R) else J\n\n\n# ----[ Surrogate Model Functions: Basis, Mask, and Operator ]----\ndef B(R, Z):\n    return p(R) * q(Z)\n\ndef B_R(R, Z): return p_R(R) * q(Z)\ndef B_Z(R, Z): return p(R) * q_Z(Z)\ndef B_RR(R, Z): return p_RR(R) * q(Z)\ndef B_ZZ(R, Z): return p(R) * q_ZZ(Z)\n\ndef phi(R, Z, w, v, b):\n    a = w * R + v * Z + b\n    return np.tanh(a)\n\ndef phi_R(R, Z, w, v, b):\n    a = w * R + v * Z + b\n    return w * (1.0 / np.cosh(a))**2\n\ndef phi_Z(R, Z, w, v, b):\n    a = w * R + v * Z + b\n    return v * (1.0 / np.cosh(a))**2\n\ndef phi_RR(R, Z, w, v, b):\n    a = w * R + v * Z + b\n    return -2 * w**2 * np.tanh(a) * (1.0 / np.cosh(a))**2\n\ndef phi_ZZ(R, Z, w, v, b):\n    a = w * R + v * Z + b\n    return -2 * v**2 * np.tanh(a) * (1.0 / np.cosh(a))**2\n\ndef L_B_phi(R, Z, w, v, b):\n    R_ = np.atleast_1d(R)\n    Z_ = np.atleast_1d(Z)\n    \n    phi_val = phi(R_, Z_, w, v, b)\n    phi_R_val = phi_R(R_, Z_, w, v, b)\n    phi_Z_val = phi_Z(R_, Z_, w, v, b)\n    phi_RR_val = phi_RR(R_, Z_, w, v, b)\n    phi_ZZ_val = phi_ZZ(R_, Z_, w, v, b)\n\n    B_val = B(R_, Z_)\n    B_R_val = B_R(R_, Z_)\n    B_Z_val = B_Z(R_, Z_)\n    B_RR_val = B_RR(R_, Z_)\n    B_ZZ_val = B_ZZ(R_, Z_)\n\n    term1 = B_R_val * phi_val + B_val * phi_R_val\n    term2 = B_RR_val * phi_val + 2 * B_R_val * phi_R_val + B_val * phi_RR_val\n    term3 = B_ZZ_val * phi_val + 2 * B_Z_val * phi_Z_val + B_val * phi_ZZ_val\n\n    with np.errstate(divide='ignore', invalid='ignore'):\n      L_val = -1.0/R_**2 * term1 + 1.0/R_ * term2 + term3\n\n    return L_val.item() if np.isscalar(R) else L_val\n\n\ndef solve():\n    # ----[ Problem Configuration ]----\n    M = 8\n    n_f = 25\n    N_c = 500\n    N_d = 50\n    lambda_reg = 1e-6\n    test_cases = [\n        (1.5, 0.0),\n        (1.05, 0.95),\n        (1.0, 0.0),\n        (2.0, 1.0),\n    ]\n\n    main_seed = 42\n    rng_main = np.random.default_rng(main_seed)\n    ensemble_seeds = rng_main.integers(low=0, high=2**31 - 1, size=M)\n\n    ensemble_members = []\n    ensemble_e_sq = []\n\n    for m in range(M):\n        rng_member = np.random.default_rng(ensemble_seeds[m])\n\n        # Sample features and points\n        features = rng_member.standard_normal(size=(n_f, 3))  # (w, v, b)\n        R_c = rng_member.uniform(R_min, R_max, N_c)\n        Z_c = rng_member.uniform(Z_min, Z_max, N_c)\n        R_d = rng_member.uniform(R_min, R_max, N_d)\n        Z_d = rng_member.uniform(Z_min, Z_max, N_d)\n\n        # Build least-squares system\n        A = np.zeros((N_c + N_d, n_f))\n        y = np.zeros(N_c + N_d)\n\n        # Physics rows\n        y[:N_c] = -R_c * j_true(R_c, Z_c)\n        for i in range(n_f):\n            w_i, v_i, b_i = features[i]\n            A[:N_c, i] = L_B_phi(R_c, Z_c, w_i, v_i, b_i)\n\n        # Diagnostic rows\n        y[N_c:] = psi_true(R_d, Z_d)\n        B_vals_d = B(R_d, Z_d)\n        for i in range(n_f):\n            w_i, v_i, b_i = features[i]\n            phi_vals_d = phi(R_d, Z_d, w_i, v_i, b_i)\n            A[N_c:, i] = B_vals_d * phi_vals_d\n\n        # Solve for coefficients with Tikhonov regularization\n        A_aug = np.vstack([A, np.sqrt(lambda_reg) * np.eye(n_f)])\n        y_aug = np.concatenate([y, np.zeros(n_f)])\n        coeffs, _, _, _ = np.linalg.lstsq(A_aug, y_aug, rcond=None)\n        \n        # Calculate diagnostic error e_m\n        psi_pred_d = np.zeros(N_d)\n        B_vals_d = B(R_d, Z_d)\n        for i in range(n_f):\n            w_i, v_i, b_i = features[i]\n            psi_pred_d += coeffs[i] * B_vals_d * phi(R_d, Z_d, w_i, v_i, b_i)\n        \n        e_m_sq = np.mean((psi_pred_d - y[N_c:])**2)\n        \n        ensemble_members.append({'coeffs': coeffs, 'features': features})\n        ensemble_e_sq.append(e_m_sq)\n\n    # ----[ Uncertainty Evaluation at Test Points ]----\n    results = []\n    mean_e_sq = np.mean(ensemble_e_sq)\n\n    for R_test, Z_test in test_cases:\n        psi_m_list = []\n        rho_m_sq_list = []\n\n        is_boundary = np.isclose(R_test, R_min) or np.isclose(R_test, R_max) or \\\n                      np.isclose(Z_test, Z_min) or np.isclose(Z_test, Z_max)\n\n        for member in ensemble_members:\n            c = member['coeffs']\n            feats = member['features']\n            \n            # Prediction psi_m\n            if is_boundary:\n                psi_m = 0.0\n            else:\n                psi_m = np.sum([\n                    c[i] * B(R_test, Z_test) * phi(R_test, Z_test, *feats[i]) \n                    for i in range(n_f)]\n                )\n            \n            # Physics residual rho_m\n            L_psi_model = np.sum([\n                c[i] * L_B_phi(R_test, Z_test, *feats[i]) \n                for i in range(n_f)]\n            )\n            rho_m = L_psi_model + R_test * j_true(R_test, Z_test)\n\n            psi_m_list.append(psi_m)\n            rho_m_sq_list.append(rho_m**2)\n\n        # Aggregate uncertainties\n        psi_m_array = np.array(psi_m_list)\n        mu = np.mean(psi_m_array)\n        s2_ens = np.var(psi_m_array, ddof=1) if M > 1 else 0.0\n        mean_rho_sq = np.mean(rho_m_sq_list)\n        \n        v = s2_ens + mean_rho_sq + mean_e_sq\n\n        # Form interval and check coverage\n        half_width = 1.96 * np.sqrt(v)\n        interval_lower = mu - half_width\n        interval_upper = mu + half_width\n        \n        psi_t = psi_true(R_test, Z_test)\n        is_covered = (psi_t >= interval_lower) and (psi_t = interval_upper)\n        results.append(is_covered)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}