{
    "hands_on_practices": [
        {
            "introduction": "Validating magnetohydrodynamic (MHD) equilibrium reconstructions is a foundational task in fusion science. This first practice provides a direct, hands-on opportunity to build a synthetic diagnostic for one of the most common measurements: magnetic flux loops. By implementing a simplified forward model of the poloidal magnetic flux $\\psi(R,Z)$ and comparing its predictions to mock data using the Root Mean Square Error (RMSE), you will gain fundamental skills in model-data comparison .",
            "id": "3948442",
            "problem": "Consider an axisymmetric tokamak equilibrium described by the Grad–Shafranov equation, where the poloidal magnetic flux function $\\psi(R,Z)$ encodes the equilibrium magnetic field in cylindrical coordinates $(R,\\phi,Z)$, with $R$ the major radius and $Z$ the vertical coordinate. Under axisymmetry, define $\\psi(R,Z)$ such that the poloidal magnetic field $\\mathbf{B}_{\\mathrm{pol}}$ satisfies $\\mathbf{B}_{\\mathrm{pol}} = \\frac{1}{R} \\nabla \\psi(R,Z) \\times \\hat{\\boldsymbol{\\phi}}$, and the poloidal magnetic flux linking a toroidal loop at $(R,Z)$ equals $2\\pi \\psi(R,Z)$. A Magnetic Flux Loop (MFL) is a toroidally oriented conductor that measures the poloidal magnetic flux linking it; in equilibrium (steady-state), the static signal is proportional to $\\psi(R,Z)$, up to a constant that can be fixed by calibration. We will treat all signals as normalized poloidal flux per radian, i.e., $\\psi$ has units of Weber per radian (Wb/rad).\n\nTo compute synthetic diagnostic signals for validation, assume a near-axis truncated second-order model for the poloidal flux,\n$$\n\\psi(R,Z) = \\psi_0 + \\frac{a}{2}\\left(R^2 - R_0^2\\right) + \\frac{b}{2} Z^2,\n$$\nwhere $\\psi_0$, $R_0$, $a$, and $b$ are equilibrium parameters. This model is consistent with a local Taylor expansion of axisymmetric equilibria that satisfy the Grad–Shafranov balance for smoothly varying pressure and toroidal field functions near the magnetic axis.\n\nYour task: For each test case, compute synthetic Magnetic Flux Loop signals by evaluating $\\psi(R_i,Z_i)$ at the loop coordinates $(R_i,Z_i)$, compare them to measured values $m_i$, and report the Root Mean Square Error (RMSE) defined by\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} \\left[\\psi(R_i,Z_i) - m_i\\right]^2},\n$$\nwhere $N$ is the number of loops in the test case. All quantities are scalars, and RMSE must be expressed in Weber per radian (Wb/rad). Use the International System of Units (SI), with $R$ and $Z$ in meters (m) and $\\psi$ and $m_i$ in Weber per radian (Wb/rad). No angles appear, so no angle unit is required.\n\nTest suite specification:\n- Test Case $1$ (general consistency, five loops):\n  - Equilibrium parameters: $\\psi_0 = 0.0$ (Wb/rad), $R_0 = 1.7$ (m), $a = 0.45$ (Wb/rad/m$^2$), $b = 0.6$ (Wb/rad/m$^2$).\n  - Loop coordinates $(R_i,Z_i)$ in meters: $\\left[(1.7,0.0),(1.85,0.2),(1.5,-0.3),(1.95,-0.1),(1.6,0.35)\\right]$.\n  - Measured values $m_i$ in Wb/rad: $\\left[-0.0008, 0.1330125, -0.1175, 0.2092125, -0.0385\\right]$.\n- Test Case $2$ (includes magnetic axis loop, four loops):\n  - Equilibrium parameters: $\\psi_0 = 0.02$ (Wb/rad), $R_0 = 1.8$ (m), $a = 0.40$ (Wb/rad/m$^2$), $b = 0.55$ (Wb/rad/m$^2$).\n  - Loop coordinates $(R_i,Z_i)$ in meters: $\\left[(1.8,0.0),(1.85,0.0),(1.75,0.1),(1.9,-0.2)\\right]$.\n  - Measured values $m_i$ in Wb/rad: $\\left[0.02, 0.0563, -0.01265, 0.1047\\right]$.\n- Test Case $3$ (systematic inconsistency, five loops):\n  - Equilibrium parameters: $\\psi_0 = -0.01$ (Wb/rad), $R_0 = 1.6$ (m), $a = 0.50$ (Wb/rad/m$^2$), $b = 0.65$ (Wb/rad/m$^2$).\n  - Loop coordinates $(R_i,Z_i)$ in meters: $\\left[(1.6,0.0),(1.7,0.2),(1.5,-0.25),(1.8,0.35),(1.55,-0.4)\\right]$.\n  - Measured values $m_i$ in Wb/rad: $\\left[0.0055, 0.0998, -0.0519875, 0.2137125, 0.017625\\right]$.\n\nYour program should produce a single line of output containing the RMSE values for the three test cases as a comma-separated list enclosed in square brackets (e.g., $\\left[\\mathrm{RMSE}_1,\\mathrm{RMSE}_2,\\mathrm{RMSE}_3\\right]$). The output values must be numeric floats in Weber per radian (Wb/rad).",
            "solution": "The problem presented is a well-defined computational task in the domain of computational fusion science, specifically concerning the validation of an equilibrium model against synthetic diagnostic data. A thorough analysis of the problem statement confirms its validity.\n\n1.  **Scientific Grounding**: The problem is based on fundamental principles of magnetohydrodynamics (MHD) in toroidal confinement systems (tokamaks). The Grad-Shafranov equation, the concept of poloidal magnetic flux $\\psi(R,Z)$, and the use of a local second-order Taylor expansion near the magnetic axis are all standard and scientifically sound concepts in plasma physics. The use of Magnetic Flux Loops as a diagnostic and the Root Mean Square Error (RMSE) as a validation metric are standard practices in experimental and computational science. All units are consistent within the International System of Units (SI).\n\n2.  **Well-Posedness**: The problem is mathematically unambiguous. It provides a closed-form analytical model for the poloidal flux, a clear definition of the error metric to be computed, and a complete set of input data for three distinct test cases. For each case, the parameters of the model, the coordinates of the measurement points, and the corresponding measured values are all explicitly given. This ensures that a unique and stable numerical solution exists for each case.\n\n3.  **Objectivity**: The problem is stated in precise, objective language, free of ambiguity or subjective claims. The task is a direct application of mathematical formulas to numerical data.\n\nThe problem is therefore deemed valid. We proceed with the solution.\n\nThe core of the problem is to quantify the discrepancy between a model prediction and a set of measurements. The model for the poloidal magnetic flux $\\psi$ at a given cylindrical coordinate point $(R, Z)$ is given by a truncated second-order expansion:\n$$\n\\psi(R,Z) = \\psi_0 + \\frac{a}{2}\\left(R^2 - R_0^2\\right) + \\frac{b}{2} Z^2\n$$\nHere, $\\psi_0$ is the flux at the magnetic axis, which is located at $(R_0, 0)$. The parameters $a$ and $b$ are related to the curvature of the flux surfaces and are determined by the plasma pressure and current profiles near the axis.\n\nThe objective is to compute the Root Mean Square Error (RMSE) between the synthetic flux values calculated from this model, $\\psi(R_i,Z_i)$, and a set of $N$ measured values, $m_i$, at corresponding locations $(R_i,Z_i)$. The RMSE is defined as:\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} \\left[\\psi(R_i,Z_i) - m_i\\right]^2}\n$$\nThis metric provides a measure of the average magnitude of the error between the model and the data, in the same units as the measured quantity (Weber per radian).\n\nThe computational procedure is as follows:\n1.  For each test case, the set of equilibrium parameters $(\\psi_0, R_0, a, b)$, the set of $N$ loop coordinates $\\{(R_i,Z_i)\\}_{i=1}^N$, and the set of $N$ measured values $\\{m_i\\}_{i=1}^N$ are provided.\n2.  For each loop $i$ from $1$ to $N$, the synthetic flux $\\psi(R_i, Z_i)$ is calculated by substituting the loop's coordinates $(R_i, Z_i)$ and the equilibrium parameters into the model equation.\n3.  The squared error for each loop, $(\\psi(R_i,Z_i) - m_i)^2$, is computed.\n4.  The Mean Squared Error (MSE) is calculated by averaging these squared errors: $\\mathrm{MSE} = \\frac{1}{N}\\sum_{i=1}^{N} (\\psi(R_i,Z_i) - m_i)^2$.\n5.  The RMSE is obtained by taking the square root of the MSE: $\\mathrm{RMSE} = \\sqrt{\\mathrm{MSE}}$.\n\nThis procedure is applied independently to each of the three test cases specified in the problem statement. The resulting three RMSE values are then reported. The implementation will utilize vector operations for efficiency, where the synthetic flux values for all loops in a given test case are computed simultaneously.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Root Mean Square Error (RMSE) between synthetic magnetic flux loop\n    signals and measured values for three test cases in a tokamak.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple containing:\n    # 1. A tuple of equilibrium parameters: (psi_0, R_0, a, b)\n    # 2. A list of loop coordinates: [(R_i, Z_i), ...]\n    # 3. A list of measured values: [m_i, ...]\n    test_cases = [\n        # Test Case 1: general consistency, five loops\n        (\n            (0.0, 1.7, 0.45, 0.6),  # (psi0, R0, a, b)\n            [(1.7, 0.0), (1.85, 0.2), (1.5, -0.3), (1.95, -0.1), (1.6, 0.35)],  # (R_i, Z_i)\n            [-0.0008, 0.1330125, -0.1175, 0.2092125, -0.0385]  # m_i\n        ),\n        # Test Case 2: includes magnetic axis loop, four loops\n        (\n            (0.02, 1.8, 0.40, 0.55),  # (psi0, R0, a, b)\n            [(1.8, 0.0), (1.85, 0.0), (1.75, 0.1), (1.9, -0.2)],  # (R_i, Z_i)\n            [0.02, 0.0563, -0.01265, 0.1047]  # m_i\n        ),\n        # Test Case 3: systematic inconsistency, five loops\n        (\n            (-0.01, 1.6, 0.50, 0.65),  # (psi0, R0, a, b)\n            [(1.6, 0.0), (1.7, 0.2), (1.5, -0.25), (1.8, 0.35), (1.55, -0.4)],  # (R_i, Z_i)\n            [0.0055, 0.0998, -0.0519875, 0.2137125, 0.017625]  # m_i\n        )\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        params, coords, measurements = case\n        psi0, R0, a, b = params\n        \n        # Convert lists to NumPy arrays for efficient, vectorized calculations.\n        coords_arr = np.array(coords)\n        measurements_arr = np.array(measurements)\n        \n        # Extract R and Z coordinates into separate vectors.\n        R = coords_arr[:, 0]\n        Z = coords_arr[:, 1]\n        \n        # Calculate synthetic flux values for all points simultaneously.\n        # psi(R,Z) = psi0 + (a/2)*(R^2 - R0^2) + (b/2)*Z^2\n        psi_synthetic = psi0 + (a / 2.0) * (R**2 - R0**2) + (b / 2.0) * Z**2\n        \n        # Calculate the Root Mean Square Error (RMSE).\n        # RMSE = sqrt(mean((psi_synthetic - measurements)^2))\n        rmse = np.sqrt(np.mean((psi_synthetic - measurements_arr)**2))\n        \n        results.append(rmse)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Building a forward model is the first step, but understanding its mathematical properties is crucial for inverting experimental data to infer physical parameters. This exercise transitions from simply predicting a signal to analyzing the structure of the forward operator itself, a key concept in tomographic reconstruction. You will construct the forward operator matrix $\\mathbf{H}$ for a set of chordal measurements and analyze its rank and condition number to explore the fundamental challenges of identifiability and numerical stability in inverse problems .",
            "id": "3948452",
            "problem": "You are tasked with building a synthetic diagnostic forward operator for axisymmetric chord-integrated measurements of radiative emissivity in a toroidal magnetic confinement device. The aim is to examine how discretization of a continuous forward operator $H$ into a matrix $\\mathbf{H}$ affects identifiability by computing the matrix rank and the $2$-norm condition number under various chordal measurement setups. Your program must implement the geometry and compute the requested properties for a specified test suite, and then output the results in a single line.\n\nFundamental base and physical model:\n- Consider a circular poloidal cross-section of radius $R$ (in $\\mathrm{m}$) and an axisymmetric, nonnegative emissivity field $\\epsilon(r)$ that depends only on the radial coordinate $r$, with $0 \\le r \\le R$.\n- Measurements are obtained by straight lines-of-sight (chords) intersecting the cross-section. Each chord is defined by its impact parameter $b$ (in $\\mathrm{m}$), which is the minimum distance between the chord and the center of the cross-section. Assume the chords are sufficiently long to fully traverse the cross-section.\n- Under the axisymmetry assumption, each chord-integrated signal is a line integral of $\\epsilon(r)$ along the chord path through the plasma. If the emissivity is piecewise constant over concentric annuli, the measurement becomes a linear combination of annulus contributions proportional to the path lengths intersected by the chord within each annulus.\n\nDiscretization:\n- Discretize $[0,R]$ into $N$ concentric annuli (zones) with uniform boundaries $r_0, r_1, \\dots, r_N$, where $r_0 = 0$ and $r_n = R \\cdot n / N$ for $n = 1,2,\\dots,N$.\n- Let $f_n$ denote the constant emissivity (in arbitrary units) in the $n$-th annulus $(r_{n-1}, r_n]$. For a chord with impact parameter $b$, its measurement $s(b)$ is discretized as $s(b) = \\sum_{n=1}^{N} H_{n}(b) f_n$, where $H_n(b)$ is the path length (in $\\mathrm{m}$) of the chord within annulus $n$.\n- For $M$ chords with impact parameters $b_m$ for $m=1,\\dots,M$, this yields a linear system $\\mathbf{s} = \\mathbf{H} \\mathbf{f}$, where $\\mathbf{H} \\in \\mathbb{R}^{M \\times N}$.\n\nGeometric determination of $\\mathbf{H}$:\n- For each chord with impact parameter $b$, the intersection length with a circle of radius $a$ is $2\\sqrt{a^2 - b^2}$ if $b < a$ and $0$ otherwise. The path length within the annulus $(r_{n-1}, r_n]$ is the difference between the intersection lengths with $r_n$ and $r_{n-1}$. If an instrument aperture limits the observable radius to $R_{\\mathrm{ap}} \\le R$, then the effective outer boundary is $\\min(r_n, R_{\\mathrm{ap}})$ and the effective inner boundary is $\\min(r_{n-1}, R_{\\mathrm{ap}})$.\n\nIdentifiability metrics:\n- The matrix rank of $\\mathbf{H}$ indicates the dimension of the subspace of emissivity profiles identifiable from the chordal measurements. If $\\mathrm{rank}(\\mathbf{H}) = N$, then $\\mathbf{f}$ is identifiable in the linear sense; if $\\mathrm{rank}(\\mathbf{H}) < N$, then some components are unobservable.\n- The $2$-norm condition number $\\kappa_2(\\mathbf{H})$ equals the ratio of the largest singular value to the smallest singular value. A large $\\kappa_2(\\mathbf{H})$ implies ill-conditioning and high sensitivity of inferred $\\mathbf{f}$ to measurement noise. If the smallest singular value is $0$, then $\\kappa_2(\\mathbf{H})$ is infinite.\n\nTasks:\n1. Construct $\\mathbf{H}$ using the above geometric rules for each test case.\n2. Compute $\\mathrm{rank}(\\mathbf{H})$ and $\\kappa_2(\\mathbf{H})$ (use the matrix $2$-norm condition number).\n3. Output the results in the specified format.\n\nTest suite:\n- All test cases use $R = 1.0$ $\\mathrm{m}$ and uniform annuli.\n- Case $1$ (baseline, square system): $N = 8$, $M = 8$, impact parameters $b_m = R \\cdot [0.000, 0.125, 0.250, 0.375, 0.500, 0.625, 0.750, 0.875]$, no aperture limit.\n- Case $2$ (overdetermined): $N = 8$, $M = 16$, $b_m$ linearly spaced in $[0, 0.95 R]$, no aperture limit.\n- Case $3$ (underdetermined): $N = 8$, $M = 5$, impact parameters $b_m = R \\cdot [0.000, 0.200, 0.400, 0.600, 0.800]$, no aperture limit.\n- Case $4$ (clustered chords, near-degenerate sampling): $N = 8$, $M = 8$, impact parameters $b_m = R \\cdot [0.680, 0.690, 0.700, 0.710, 0.720, 0.730, 0.740, 0.750]$, no aperture limit.\n- Case $5$ (limited aperture): $N = 8$, $M = 8$, same $b_m$ as Case $1$, with $R_{\\mathrm{ap}} = 0.700 R$.\n\nOutput specification:\n- For each case, compute the integer rank and the float $2$-norm condition number rounded to $6$ decimal places. Collect all results in order as a single list with alternating rank and condition number values, i.e., $[\\mathrm{rank}_1, \\kappa_2(\\mathbf{H}_1), \\mathrm{rank}_2, \\kappa_2(\\mathbf{H}_2), \\dots]$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,c_1,r_2,c_2,\\dots]$). No additional text should be printed.\n\nAngle unit:\n- No angles are used; chords are characterized solely by their impact parameters.\n\nUnits:\n- Geometry is defined in $\\mathrm{m}$, but the output quantities $\\mathrm{rank}(\\mathbf{H})$ and $\\kappa_2(\\mathbf{H})$ are dimensionless. No physical units are required for the output.\n\nConstraints:\n- Implement using standard linear algebra tools appropriate for graduate-level computation, without invoking any shortcut formulas beyond the fundamental base. Ensure numerical robustness when handling square roots and singular values.",
            "solution": "The problem statement is assessed to be valid. It is scientifically grounded, well-posed, and provides a complete and consistent set of requirements for a computational task in the field of fusion plasma diagnostics. The problem asks for the construction and analysis of a forward operator, which is a standard procedure in synthetic diagnostics for comparing computational models with experimental measurements.\n\nThe core of the problem is to design a synthetic diagnostic that models chord-integrated emissivity measurements in a toroidal plasma with an assumed axisymmetric cross-section. This is mathematically equivalent to the Abel transform problem. We are tasked with discretizing this continuous operator and evaluating the properties of the resulting matrix representation, $\\mathbf{H}$, for several measurement configurations. The key metrics for evaluation are the matrix rank, $\\mathrm{rank}(\\mathbf{H})$, and the $2$-norm condition number, $\\kappa_2(\\mathbf{H})$.\n\nFirst, we formalize the model. The continuous emissivity profile, $\\epsilon(r)$, is assumed to depend only on the minor radius $r$, where $0 \\le r \\le R$. We discretize this profile into $N$ concentric annuli of uniform width. The annuli are defined by radii $r_n = R \\cdot n / N$ for $n=0, 1, \\dots, N$. Within each annulus $(r_{n-1}, r_n]$, the emissivity is assumed to be a constant value, $f_n$. This constitutes a piecewise constant approximation of the true profile $\\epsilon(r)$.\n\nA measurement is taken along a straight line-of-sight, or chord, defined by its impact parameter $b$, which is its minimum distance to the center of the circular cross-section. The measured signal $s(b)$ is the line integral of the emissivity along this chord. In our discretized model, this integral becomes a sum:\n$$\ns(b) = \\sum_{n=1}^{N} H_{n}(b) f_n\n$$\nwhere $H_{n}(b)$ is the path length of the chord with impact parameter $b$ through the $n$-th annulus. For a set of $M$ measurements with impact parameters $b_1, \\dots, b_M$, we obtain a linear system of equations:\n$$\n\\mathbf{s} = \\mathbf{H} \\mathbf{f}\n$$\nHere, $\\mathbf{s} \\in \\mathbb{R}^M$ is the vector of measurements, $\\mathbf{f} \\in \\mathbb{R}^N$ is the vector of unknown annulus emissivities, and $\\mathbf{H} \\in \\mathbb{R}^{M \\times N}$ is the forward operator matrix we must construct. The element $H_{mn}$ of this matrix is the path length for the $m$-th chord ($b_m$) through the $n$-th annulus.\n\nThe geometric calculation of the matrix elements $H_{mn}$ is central. The total path length of a chord with impact parameter $b$ through a circle of radius $a$ (where $b < a$) is given by elementary geometry as $L(a, b) = 2\\sqrt{a^2 - b^2}$. If $b \\ge a$, the chord does not intersect the circle, and the path length is $0$. The path length through an annulus $(r_{n-1}, r_n]$ is the difference between the path lengths through the circles defined by its outer and inner radii:\n$$\nH_{mn} = L(r_n, b_m) - L(r_{n-1}, b_m)\n$$\nThis formula holds provided we define $L(a, b) = 0$ for $b \\ge a$.\n\nThe problem also introduces an optional instrument aperture, $R_{\\mathrm{ap}}$, which limits the observable region to $r \\le R_{\\mathrm{ap}}$. To account for this, we must use effective radii. The path length through the $n$-th annulus is calculated using radii that are clipped by the aperture: $r'_n = \\min(r_n, R_{\\mathrm{ap}})$ and $r'_{n-1} = \\min(r_{n-1}, R_{\\mathrm{ap}})$. The formula for the matrix element becomes:\n$$\nH_{mn} = L(r'_n, b_m) - L(r'_{n-1}, b_m)\n$$\nDuring numerical implementation, care must be taken when $b_m$ is very close to an effective radius $r'$, as floating-point inaccuracies could make the term $(r')^2 - b_m^2$ slightly negative. We must ensure the argument of the square root is non-negative.\n\nOnce the matrix $\\mathbf{H}$ is constructed for a given test case, we analyze its properties.\n$1$. The rank of $\\mathbf{H}$, $\\mathrm{rank}(\\mathbf{H})$, is computed. The rank gives the number of linearly independent rows (or columns), which corresponds to the dimension of the data space spanned by the measurements. If $\\mathrm{rank}(\\mathbf{H}) = N$ (the number of unknowns), the emissivity profile $\\mathbf{f}$ is uniquely identifiable from the measurements $\\mathbf{s}$, assuming a square or overdetermined system. If $\\mathrm{rank}(\\mathbf{H}) < N$, the system is underdetermined or rank-deficient, and a unique solution for $\\mathbf{f}$ does not exist.\n$2$. The $2$-norm condition number, $\\kappa_2(\\mathbf{H})$, is computed. It is the ratio of the largest to the smallest singular value of $\\mathbf{H}$, $\\kappa_2(\\mathbf{H}) = \\sigma_{\\max} / \\sigma_{\\min}$. A large condition number indicates an ill-conditioned problem, where small errors or noise in the measurement vector $\\mathbf{s}$ can lead to large errors in the inferred solution $\\mathbf{f}$. If $\\mathbf{H}$ is singular or rank-deficient (i.e., $\\sigma_{\\min} = 0$), the condition number is infinite.\n\nThe implementation will proceed by iterating through the five specified test cases. For each case, we define the parameters ($N, M, R, \\{b_m\\}, R_{\\mathrm{ap}}$), construct the matrix $\\mathbf{H}$ element by element using the geometric formula, and then use standard numerical linear algebra routines to compute its rank and condition number. The results will be collected and formatted as specified.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and analyzes a forward operator matrix for synthetic chord-integrated\n    emissivity measurements in a toroidal plasma cross-section.\n    \"\"\"\n\n    def get_h_matrix(R, N, M, b_params, R_ap=None):\n        \"\"\"\n        Constructs the forward operator matrix H.\n\n        Args:\n            R (float): Radius of the circular cross-section.\n            N (int): Number of concentric annuli (emissivity zones).\n            M (int): Number of measurement chords.\n            b_params (np.ndarray): Array of impact parameters for the chords.\n            R_ap (float, optional): Aperture radius limit. Defaults to None.\n\n        Returns:\n            np.ndarray: The M x N forward operator matrix H.\n        \"\"\"\n        # Define annulus radii\n        r = R * np.arange(N + 1) / N\n\n        # Initialize the H matrix\n        H = np.zeros((M, N))\n\n        # Helper function for chord length through a circle of radius 'a'\n        def chord_length(a, b):\n            # Numerically robust calculation of 2 * sqrt(a^2 - b^2)\n            if b >= a:\n                return 0.0\n            return 2.0 * np.sqrt(a**2 - b**2)\n\n        # Populate the H matrix\n        for m in range(M):\n            b = b_params[m]\n            for n in range(N):\n                r_inner = r[n]\n                r_outer = r[n + 1]\n\n                # Apply aperture limit if specified\n                r_eff_inner = r_inner\n                r_eff_outer = r_outer\n                if R_ap is not None:\n                    r_eff_inner = min(r_inner, R_ap)\n                    r_eff_outer = min(r_outer, R_ap)\n\n                # Path length is the difference of lengths through the outer and inner circles\n                # of the (effective) annulus.\n                len_outer = chord_length(r_eff_outer, b)\n                len_inner = chord_length(r_eff_inner, b)\n                H[m, n] = len_outer - len_inner\n        \n        return H\n\n    # Common parameters\n    R_base = 1.0\n\n    # Test suite definition\n    test_cases = [\n        # Case 1: baseline, square system\n        {'N': 8, 'M': 8, 'b_params': R_base * np.array([0.000, 0.125, 0.250, 0.375, 0.500, 0.625, 0.750, 0.875]), 'R_ap': None},\n        # Case 2: overdetermined\n        {'N': 8, 'M': 16, 'b_params': np.linspace(0, 0.95 * R_base, 16), 'R_ap': None},\n        # Case 3: underdetermined\n        {'N': 8, 'M': 5, 'b_params': R_base * np.array([0.000, 0.200, 0.400, 0.600, 0.800]), 'R_ap': None},\n        # Case 4: clustered chords, near-degenerate sampling\n        {'N': 8, 'M': 8, 'b_params': R_base * np.array([0.680, 0.690, 0.700, 0.710, 0.720, 0.730, 0.740, 0.750]), 'R_ap': None},\n        # Case 5: limited aperture\n        {'N': 8, 'M': 8, 'b_params': R_base * np.array([0.000, 0.125, 0.250, 0.375, 0.500, 0.625, 0.750, 0.875]), 'R_ap': 0.700 * R_base},\n    ]\n\n    results = []\n    for case in test_cases:\n        H = get_h_matrix(R_base, case['N'], case['M'], case['b_params'], case['R_ap'])\n\n        # Compute rank and condition number\n        rank = np.linalg.matrix_rank(H)\n        cond_num = np.linalg.cond(H)\n\n        results.append(rank)\n        \n        # Format condition number. np.inf will be handled by str() conversion later\n        if np.isinf(cond_num):\n            results.append(cond_num)\n        else:\n            results.append(round(cond_num, 6))\n\n    # Format the final output string as specified\n    # map(str, ...) correctly handles integers, floats, and np.inf\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A key aspect of advanced validation is not just assessing model-data agreement, but also understanding the limitations of the model itself. This final practice addresses the critical issue of systematic error that arises from model incompleteness. By analyzing a simplified neutron diagnostic model that neglects the physical effect of scattering, you will derive and quantify the resulting bias $\\Delta R$ in an inferred physical parameter, a vital skill for interpreting any validation study and making informed judgments about model fidelity .",
            "id": "3948453",
            "problem": "Consider a synthetic diagnostic design task for a neutron detector in a fusion environment, where the detector receives contributions from prompt neutrons emitted directly from a pointlike source and from neutrons scattered by surrounding structures. The detector is modeled as an ideal circular aperture with effective area $A$ and energy-independent efficiency $\\epsilon$. The source is an isotropic emitter of fusion neutrons with emission rate $S$ in units of $\\mathrm{s^{-1}}$, located on the detector line-of-sight at distance $R$ in meters. Assume monoenergetic neutrons typical of Deuterium-Tritium (D-T) fusion. The detector count rate is modeled by a linear superposition of two response functions: a prompt response function $g_{\\mathrm{p}}(R)$ and a scattered response function $g_{\\mathrm{s}}(R)$, such that the total measured rate $M(R)$ in $\\mathrm{s^{-1}}$ satisfies\n$$\nM(R) = S\\big(g_{\\mathrm{p}}(R) + g_{\\mathrm{s}}(R)\\big).\n$$\nFor prompt neutrons, use geometric attenuation as the base law and take\n$$\ng_{\\mathrm{p}}(R) = \\frac{\\epsilon A}{4\\pi R^{2}}.\n$$\nFor scattered neutrons, adopt the common first-order approximation that the diffuse multiple-scatter background intercepted by the detector in a fixed environment is weakly dependent on $R$ over the range of interest and model it as\n$$\ng_{\\mathrm{s}}(R) = C,\n$$\nwhere $C$ is a dimensionless constant capturing the effective coupling of the environment to the detector.\n\nSuppose an analyst infers the source-to-detector distance by inverting the prompt-only model, i.e., by assuming $M(R) \\approx S g_{\\mathrm{p}}(R)$ and solving for $R$ from the measured $M(R)$. This neglect of scattering induces a bias in the inferred distance. Your tasks are:\n\n1. Starting from the stated base laws and definitions, derive an explicit analytic expression for the inferred distance $R_{\\mathrm{inf}}$ obtained by inverting the prompt-only model using the measured $M(R)$ that includes both prompt and scattered contributions. Express $R_{\\mathrm{inf}}$ in terms of $R$, $A$, $\\epsilon$, $S$, and $C$.\n2. Derive the bias $\\Delta R = R_{\\mathrm{inf}} - R$ and its sign as a function of the parameters. Your derivation must be based only on the stated fundamental geometrical attenuation and linearity assumptions, without introducing any shortcut formulas.\n3. Implement a program that computes $\\Delta R$ for the following test suite of parameter values. All distances are in meters, areas in $\\mathrm{m^{2}}$, efficiencies are dimensionless, emission rates in $\\mathrm{s^{-1}}$, and $C$ is dimensionless. Express each bias in meters, rounded to six decimal places.\n\nTest suite:\n- Case 1 (general validation case): $R = 1.5$, $A = 0.01$, $\\epsilon = 0.25$, $S = 5\\times 10^{14}$, $C = 10^{-4}$.\n- Case 2 (no scattering baseline): $R = 1.5$, $A = 0.01$, $\\epsilon = 0.25$, $S = 5\\times 10^{14}$, $C = 0$.\n- Case 3 (far source, low area): $R = 6.0$, $A = 0.01$, $\\epsilon = 0.20$, $S = 1\\times 10^{15}$, $C = 10^{-5}$.\n- Case 4 (small aperture, notable scatter): $R = 3.0$, $A = 10^{-4}$, $\\epsilon = 0.30$, $S = 2\\times 10^{14}$, $C = 10^{-5}$.\n- Case 5 (larger aperture, weak scatter): $R = 2.0$, $A = 0.02$, $\\epsilon = 0.18$, $S = 1\\times 10^{14}$, $C = 5\\times 10^{-6}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result1,result2,result3]$). Each element must be the floating-point value of $\\Delta R$ for the corresponding case in the order listed above, in meters, rounded to exactly six decimal places.",
            "solution": "The problem requires deriving and calculating the bias in an inferred source distance when a simplified physical model is used for inversion. The \"true\" measurement model, which includes both prompt and scattered neutrons, gives a total count rate $M(R)$ of:\n$$\nM(R) = S\\left(g_{\\mathrm{p}}(R) + g_{\\mathrm{s}}(R)\\right) = S\\left(\\frac{\\epsilon A}{4\\pi R^{2}} + C\\right)\n$$\nAn analyst using an incomplete, prompt-only model assumes the measured rate follows:\n$$\nM(R) \\approx \\frac{\\epsilon A S}{4\\pi R_{\\mathrm{inf}}^{2}}\n$$\nwhere $R_{\\mathrm{inf}}$ is the distance they would infer. To find $R_{\\mathrm{inf}}$, we set the two expressions for $M(R)$ equal and solve for $R_{\\mathrm{inf}}$:\n$$\nS\\left(\\frac{\\epsilon A}{4\\pi R^{2}} + C\\right) = \\frac{\\epsilon A S}{4\\pi R_{\\mathrm{inf}}^{2}}\n$$\nSolving for $R_{\\mathrm{inf}}$ yields:\n$$\nR_{\\mathrm{inf}} = \\sqrt{\\frac{\\epsilon A S}{4\\pi S\\left(\\frac{\\epsilon A}{4\\pi R^{2}} + C\\right)}} = \\sqrt{\\frac{1}{\\frac{1}{R^{2}} + \\frac{4\\pi C}{\\epsilon A}}}\n$$\nThe bias, $\\Delta R$, is the difference between the inferred and true distances:\n$$\n\\Delta R = R_{\\mathrm{inf}} - R = \\sqrt{\\frac{1}{\\frac{1}{R^{2}} + \\frac{4\\pi C}{\\epsilon A}}} - R\n$$\nSince all parameters are positive, the term $\\frac{4\\pi C}{\\epsilon A}$ is positive, which means $R_{\\mathrm{inf}} < R$. Therefore, the bias $\\Delta R$ will be negative, indicating an underestimation of the true distance.\n\nThe computational task is to implement this final formula for $\\Delta R$ for each of the five test cases, using the provided parameter values and rounding the results as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the bias in inferred source distance due to neglecting neutron scattering.\n    \"\"\"\n\n    def calculate_bias(R, A, epsilon, C):\n        \"\"\"\n        Calculates the bias Delta_R = R_inferred - R.\n        The formula is derived from the problem statement. Note that the source\n        strength S cancels out and is not needed for the bias calculation.\n        \n        Args:\n            R (float): True source-to-detector distance.\n            A (float): Detector effective area.\n            epsilon (float): Detector efficiency.\n            C (float): Scattered response function constant.\n            \n        Returns:\n            float: The bias Delta_R in meters.\n        \"\"\"\n        if C == 0:\n            return 0.0\n            \n        pi = np.pi\n        \n        # Calculate R_inferred based on the derived formula\n        r_inf_squared_inv = (1 / R**2) + (4 * pi * C) / (epsilon * A)\n        r_inf = np.sqrt(1 / r_inf_squared_inv)\n        \n        return r_inf - R\n\n    # Define the test cases from the problem statement.\n    # Each case: (R [m], A [m^2], eps [dimensionless], S [1/s], C [dimensionless])\n    # The source strength S is not needed for the bias calculation but is kept for consistency.\n    test_cases = [\n        (1.5, 0.01, 0.25, 5e14, 1e-4),      # Case 1\n        (1.5, 0.01, 0.25, 5e14, 0.0),       # Case 2\n        (6.0, 0.01, 0.20, 1e15, 1e-5),      # Case 3\n        (3.0, 1e-4, 0.30, 2e14, 1e-5),      # Case 4\n        (2.0, 0.02, 0.18, 1e14, 5e-6),      # Case 5\n    ]\n\n    results = []\n    for R, A, eps, S, C in test_cases:\n        delta_R = calculate_bias(R, A, eps, C)\n        # Round to exactly six decimal places and format as a string\n        results.append(f\"{delta_R:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\n# The python code in the original answer was slightly different.\n# Let's use the original one as it is also correct and follows the minimalist principle.\ndef inferred_bias_original(R, A, eps, S, C):\n    \"\"\"\n    Compute bias Delta R = R_inf - R when scattering is neglected.\n    Model:\n      M_total = S * (eps*A/(4*pi*R^2) + C)\n      Prompt-only inversion: M_total = S * eps*A/(4*pi*R_inf^2)\n      => R_inf = sqrt( eps*A*S / (4*pi*M_total) )\n    \"\"\"\n    pi = np.pi\n    if C == 0.0:\n      # If there's no scattering, M_total is just the prompt part, so R_inf = R and bias is 0.\n      return 0.0\n    M_total = S * (eps * A / (4.0 * pi * R**2) + C)\n    R_inf = np.sqrt((eps * A * S) / (4.0 * pi * M_total))\n    return R_inf - R\n\ndef solve_original():\n    test_cases = [\n        (1.5, 0.01, 0.25, 5e14, 1e-4),      # Case 1\n        (1.5, 0.01, 0.25, 5e14, 0.0),       # Case 2\n        (6.0, 0.01, 0.20, 1e15, 1e-5),      # Case 3\n        (3.0, 1e-4, 0.30, 2e14, 1e-5),      # Case 4\n        (2.0, 0.02, 0.18, 1e14, 5e-6),      # Case 5\n    ]\n    results = []\n    for R, A, eps, S, C in test_cases:\n        delta_R = inferred_bias_original(R, A, eps, S, C)\n        results.append(f\"{delta_R:.6f}\")\n    print(f\"[{','.join(results)}]\")\n\nsolve_original()\n```"
        }
    ]
}