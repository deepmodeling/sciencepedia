{
    "hands_on_practices": [
        {
            "introduction": "本练习将指导您构建一个基础的综合诊断。您将使用一个简化的磁平衡模型，即Grad-Shafranov方程的近轴展开，来计算磁通探头应该测得的信号。通过将计算得到的“综合”信号与给定的“测量”值进行比较，您可以量化模型与数据之间的一致性，这是验证物理模型的首要步骤。这项实践旨在通过一个清晰的代数示例，让您掌握验证循环的核心思想 。",
            "id": "3948442",
            "problem": "考虑一个由 Grad–Shafranov 方程描述的轴对称托卡马克平衡，其中极向磁通函数 $\\psi(R,Z)$ 在柱坐标 $(R,\\phi,Z)$ 中编码了平衡磁场，$R$ 是大半径，$Z$ 是垂直坐标。在轴对称条件下，定义 $\\psi(R,Z)$ 使得极向磁场 $\\mathbf{B}_{\\mathrm{pol}}$ 满足 $\\mathbf{B}_{\\mathrm{pol}} = \\frac{1}{R} \\nabla \\psi(R,Z) \\times \\hat{\\boldsymbol{\\phi}}$，且与位于 $(R,Z)$ 的环向回路相链接的极向磁通量等于 $2\\pi \\psi(R,Z)$。磁通环 (MFL) 是一种环向放置的导体，用于测量与其链接的极向磁通量；在平衡（稳态）下，其静态信号与 $\\psi(R,Z)$ 成正比，相差一个可通过标定确定的常数。我们将所有信号视为归一化的单位弧度极向磁通量，即 $\\psi$ 的单位是韦伯/弧度 (Wb/rad)。\n\n为了计算用于验证的合成诊断信号，假设极向磁通采用一个近轴截断二阶模型，\n$$\n\\psi(R,Z) = \\psi_0 + \\frac{a}{2}\\left(R^2 - R_0^2\\right) + \\frac{b}{2} Z^2,\n$$\n其中 $\\psi_0$、$R_0$、$a$ 和 $b$ 是平衡参数。该模型与满足 Grad–Shafranov 平衡的轴对称平衡在磁轴附近对平滑变化的压强和环向场函数进行的局域泰勒展开是一致的。\n\n您的任务是：对于每个测试用例，通过在磁通环坐标 $(R_i,Z_i)$ 处计算 $\\psi(R_i,Z_i)$ 来得出合成磁通环信号，将其与测量值 $m_i$ 进行比较，并报告由下式定义的均方根误差 (RMSE)：\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} \\left[\\psi(R_i,Z_i) - m_i\\right]^2},\n$$\n其中 $N$ 是测试用例中的磁通环数量。所有量均为标量，RMSE 必须以韦伯/弧度 (Wb/rad) 表示。使用国际单位制 (SI)，其中 $R$ 和 $Z$ 的单位是米 (m)，$\\psi$ 和 $m_i$ 的单位是韦伯/弧度 (Wb/rad)。没有出现角度，因此不需要角度单位。\n\n测试套件规范：\n- 测试用例 $1$ (一般一致性，五个磁通环):\n  - 平衡参数：$\\psi_0 = 0.0$ (Wb/rad)，$R_0 = 1.7$ (m)，$a = 0.45$ (Wb/rad/m$^2$)，$b = 0.6$ (Wb/rad/m$^2$)。\n  - 磁通环坐标 $(R_i,Z_i)$ (单位：米)：$\\left[(1.7,0.0),(1.85,0.2),(1.5,-0.3),(1.95,-0.1),(1.6,0.35)\\right]$。\n  - 测量值 $m_i$ (单位：Wb/rad)：$\\left[-0.0008, 0.1330125, -0.1175, 0.2092125, -0.0385\\right]$。\n- 测试用例 $2$ (包含磁轴磁通环，四个磁通环):\n  - 平衡参数：$\\psi_0 = 0.02$ (Wb/rad)，$R_0 = 1.8$ (m)，$a = 0.40$ (Wb/rad/m$^2$)，$b = 0.55$ (Wb/rad/m$^2$)。\n  - 磁通环坐标 $(R_i,Z_i)$ (单位：米)：$\\left[(1.8,0.0),(1.85,0.0),(1.75,0.1),(1.9,-0.2)\\right]$。\n  - 测量值 $m_i$ (单位：Wb/rad)：$\\left[0.02, 0.0563, -0.01265, 0.1047\\right]$。\n- 测试用例 $3$ (系统性不一致，五个磁通环):\n  - 平衡参数：$\\psi_0 = -0.01$ (Wb/rad)，$R_0 = 1.6$ (m)，$a = 0.50$ (Wb/rad/m$^2$)，$b = 0.65$ (Wb/rad/m$^2$)。\n  - 磁通环坐标 $(R_i,Z_i)$ (单位：米)：$\\left[(1.6,0.0),(1.7,0.2),(1.5,-0.25),(1.8,0.35),(1.55,-0.4)\\right]$。\n  - 测量值 $m_i$ (单位：Wb/rad)：$\\left[0.0055, 0.0998, -0.0519875, 0.2137125, 0.017625\\right]$。\n\n您的程序应生成单行输出，其中包含三个测试用例的 RMSE 值，格式为用方括号括起来的逗号分隔列表（例如，$\\left[\\mathrm{RMSE}_1,\\mathrm{RMSE}_2,\\mathrm{RMSE}_3\\right]$）。输出必须是数值浮点数，单位为韦伯/弧度 (Wb/rad)。",
            "solution": "所提出的问题是在计算聚变科学领域内一个定义明确的计算任务，具体涉及基于合成诊断数据来验证一个平衡模型。对问题陈述的全面分析证实了其有效性。\n\n1.  **科学基础**：该问题基于环向约束系统（托卡马克）中磁流体动力学（MHD）的基本原理。Grad-Shafranov方程、极向磁通 $\\psi(R,Z)$ 的概念，以及在磁轴附近使用局域二阶泰勒展开，都是等离子体物理学中标准且科学上合理的概念。使用磁通环作为诊断工具和使用均方根误差（RMSE）作为验证指标是实验科学和计算科学中的标准做法。所有单位在国际单位制（SI）内保持一致。\n\n2.  **适定性**：该问题在数学上是明确的。它为极向磁通提供了一个封闭形式的解析模型，一个明确定义的待计算误差指标，以及为三个不同测试用例提供的一整套输入数据。对于每个用例，模型的参数、测量点的坐标以及相应的测量值都已明确给出。这确保了每个用例都存在唯一且稳定的数值解。\n\n3.  **客观性**：问题以精确、客观的语言陈述，没有歧义或主观论断。该任务是数学公式对数值数据的直接应用。\n\n因此，该问题被认为是有效的。我们继续进行求解。\n\n问题的核心是量化模型预测与一组测量值之间的差异。在给定柱坐标点 $(R, Z)$ 处的极向磁通 $\\psi$ 的模型由一个截断的二阶展开给出：\n$$\n\\psi(R,Z) = \\psi_0 + \\frac{a}{2}\\left(R^2 - R_0^2\\right) + \\frac{b}{2} Z^2\n$$\n这里，$\\psi_0$ 是位于 $(R_0, 0)$ 的磁轴处的磁通。参数 $a$ 和 $b$ 与磁通面的曲率有关，由磁轴附近的等离子体压强和电流分布确定。\n\n目标是计算由该模型计算出的合成磁通值 $\\psi(R_i,Z_i)$ 与在相应位置 $(R_i,Z_i)$ 处的一组 $N$ 个测量值 $m_i$ 之间的均方根误差 (RMSE)。RMSE 定义为：\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} \\left[\\psi(R_i,Z_i) - m_i\\right]^2}\n$$\n该指标提供了模型与数据之间误差平均大小的度量，其单位与测量量（韦伯/弧度）相同。\n\n计算过程如下：\n1.  对于每个测试用例，提供一组平衡参数 $(\\psi_0, R_0, a, b)$、一组 $N$ 个磁通环坐标 $\\{(R_i,Z_i)\\}_{i=1}^N$ 和一组 $N$ 个测量值 $\\{m_i\\}_{i=1}^N$。\n2.  对于从 $1$ 到 $N$ 的每个磁通环 $i$，通过将磁通环的坐标 $(R_i, Z_i)$ 和平衡参数代入模型方程来计算合成磁通 $\\psi(R_i, Z_i)$。\n3.  计算每个磁通环的平方误差 $(\\psi(R_i,Z_i) - m_i)^2$。\n4.  通过对这些平方误差求平均值来计算均方误差 (MSE)：$\\mathrm{MSE} = \\frac{1}{N}\\sum_{i=1}^{N} (\\psi(R_i,Z_i) - m_i)^2$。\n5.  通过取 MSE 的平方根来获得 RMSE：$\\mathrm{RMSE} = \\sqrt{\\mathrm{MSE}}$。\n\n此过程独立应用于问题陈述中指定的三个测试用例中的每一个。然后报告所得的三个 RMSE 值。实现将利用向量运算以提高效率，其中给定测试用例中所有磁通环的合成磁通值将同时计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Root Mean Square Error (RMSE) between synthetic magnetic flux loop\n    signals and measured values for three test cases in a tokamak.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple containing:\n    # 1. A tuple of equilibrium parameters: (psi_0, R_0, a, b)\n    # 2. A list of loop coordinates: [(R_i, Z_i), ...]\n    # 3. A list of measured values: [m_i, ...]\n    test_cases = [\n        # Test Case 1: general consistency, five loops\n        (\n            (0.0, 1.7, 0.45, 0.6),  # (psi0, R0, a, b)\n            [(1.7, 0.0), (1.85, 0.2), (1.5, -0.3), (1.95, -0.1), (1.6, 0.35)],  # (R_i, Z_i)\n            [-0.0008, 0.1330125, -0.1175, 0.2092125, -0.0385]  # m_i\n        ),\n        # Test Case 2: includes magnetic axis loop, four loops\n        (\n            (0.02, 1.8, 0.40, 0.55),  # (psi0, R0, a, b)\n            [(1.8, 0.0), (1.85, 0.0), (1.75, 0.1), (1.9, -0.2)],  # (R_i, Z_i)\n            [0.02, 0.0563, -0.01265, 0.1047]  # m_i\n        ),\n        # Test Case 3: systematic inconsistency, five loops\n        (\n            (-0.01, 1.6, 0.50, 0.65),  # (psi0, R0, a, b)\n            [(1.6, 0.0), (1.7, 0.2), (1.5, -0.25), (1.8, 0.35), (1.55, -0.4)],  # (R_i, Z_i)\n            [0.0055, 0.0998, -0.0519875, 0.2137125, 0.017625]  # m_i\n        )\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        params, coords, measurements = case\n        psi0, R0, a, b = params\n        \n        # Convert lists to NumPy arrays for efficient, vectorized calculations.\n        coords_arr = np.array(coords)\n        measurements_arr = np.array(measurements)\n        \n        # Extract R and Z coordinates into separate vectors.\n        R = coords_arr[:, 0]\n        Z = coords_arr[:, 1]\n        \n        # Calculate synthetic flux values for all points simultaneously.\n        # psi(R,Z) = psi0 + (a/2)*(R^2 - R0^2) + (b/2)*Z^2\n        psi_synthetic = psi0 + (a / 2.0) * (R**2 - R0**2) + (b / 2.0) * Z**2\n        \n        # Calculate the Root Mean Square Error (RMSE).\n        # RMSE = sqrt(mean((psi_synthetic - measurements)^2))\n        rmse = np.sqrt(np.mean((psi_synthetic - measurements_arr)**2))\n        \n        results.append(rmse)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基础的正向建模之后，下一个挑战是从第一性原理构建一个更复杂的诊断模型。本练习聚焦于中子相机，这是一种测量聚变反应率的关键诊断工具。您需要推导并实现一个模型，该模型综合考虑了源发射、几何稀释（立体角）、材料衰减（屏蔽）以及仪器准直等多种物理效应。这项实践将让您体验如何通过整合不同的物理定律来从头开始构建一个高保真度的综合诊断工具 。",
            "id": "3948431",
            "problem": "需要构建一个用于中子相机 (NC) 的模拟诊断工具，以计算从中子体源沿准直视线 (LoS)、通过有限孔径立体角和结构屏蔽进行观测时所探测到的计数率。目标是从第一性原理出发，推导并实现一个数值算法，该算法能为预设场景输出探测到的计数率。角度必须以弧度表示，所有物理单位必须在国际单位制 (SI) 中处理。最终的数值答案必须以 $\\mathrm{s^{-1}}$ 表示。\n\n出发点和假设：\n- 沿直线LoS的中子输运通过沿特征线的一维平衡方程来建模：定向强度的变化率等于局部源项减去由物质相互作用引起的衰减。令 $s$ 表示沿LoS从孔径平面向等离子体内部测量的坐标，其中 $s \\in [s_0,s_1]$，$s_0 \\gt 0$。\n- 体中子源在局部是各向同性的，并以简化形式表示为线积分发射率密度 $q(s)$，单位为 $\\mathrm{s^{-1}\\,m^{-1}}$，理解为沿LoS单位长度的发射率（例如，通过将体发射率在细视管的LoS横截面上积分得到）。\n- 孔径为圆形，半径为 $a$，面积为 $A = \\pi a^2$，其后是一个长度为 $L$ 的圆柱形准直器。接收半角为 $\\theta_c = \\arctan\\!\\left(\\frac{a}{L}\\right)$，只有与孔径轴线所成夹角在此角锥内的射线才能通过。\n- 对于小孔径，位置 $s$ 处的点观察孔径的立体角为 $\\Omega(s) = \\frac{A \\cos\\delta}{s^2}$，其中 $\\delta$ 是LoS方向与孔径轴线之间的固定偏置角。如果 $\\delta \\le \\theta_c$，通过准直器的透射率为 $1$，否则为 $0$。\n- 沿路径的结构屏蔽由通过均匀材料段 $i$ 的路径积分衰减表示，这些材料段具有宏观衰减系数 $\\mu_i$（单位 $\\mathrm{m^{-1}}$）和厚度 $t_i$（单位 $\\mathrm{m}$），产生总透射因子 $T = \\exp\\!\\left(-\\sum_i \\mu_i t_i\\right)$，假定对于所有 $s \\in [s_0,s_1]$，该因子为常数。\n- 对于相关的中子能量范围，探测器具有恒定的探测效率 $\\epsilon$（无量纲）。\n\n基本原理：\n- 使用稳态条件下沿LoS的一维衰减-源平衡的特征线解，结合由平方反比衰减和孔径立体角分数引起的几何稀释。不要假设任何预先推导的最终诊断公式；相反，应通过对由几何和衰减因子加权的 $q(s)$ 的贡献进行积分，从第一性原理推导探测到的计数率。\n\n要求的推导与计算：\n- 将探测到的计数率 $C$ 推导为在 $s \\in [s_0,s_1]$ 上的线积分，积分项为局部源 $q(s)$ 乘以进入孔径的各向同性发射分数 $\\frac{\\Omega(s)}{4\\pi}$、透射率 $T$ 和探测效率 $\\epsilon$，并通过 $\\delta$ 和 $\\theta_c$ 满足准直器接收约束。\n- 实现一个数值求积方法来计算通用 $q(s)$ 的积分。当 $s_0$ 很小时，对 $s \\approx s_0$ 附近的陡峭贡献使用适当的绝对和相对容差。角度必须以弧度为单位。以 $\\mathrm{s^{-1}}$ 表示最终探测到的计数率。\n\n测试套件：\n为以下参数集实现计算。在每种情况下，产生一个单位为 $\\mathrm{s^{-1}}$ 的标量输出 $C$。\n\n- 情况1（理想路径，轴对齐，恒定发射率，中等屏蔽）：\n  - $a = 0.015\\,\\mathrm{m}$，$L = 0.300\\,\\mathrm{m}$，因此 $\\theta_c = \\arctan\\!\\left(\\frac{0.015}{0.300}\\right)$。\n  - $\\delta = 0.000\\,\\mathrm{rad}$。\n  - $s_0 = 0.200\\,\\mathrm{m}$，$s_1 = 2.500\\,\\mathrm{m}$。\n  - $q(s) = q_0$，其中 $q_0 = 1.0\\times 10^8\\,\\mathrm{s^{-1}\\,m^{-1}}$。\n  - 屏蔽段：钢，$\\mu = 8.0\\,\\mathrm{m^{-1}}$，$t = 0.100\\,\\mathrm{m}$；混凝土，$\\mu = 1.2\\,\\mathrm{m^{-1}}$，$t = 0.500\\,\\mathrm{m}$；硼化聚乙烯，$\\mu = 3.0\\,\\mathrm{m^{-1}}$，$t = 0.050\\,\\mathrm{m}$。\n  - $\\epsilon = 1.0\\times 10^{-6}$。\n\n- 情况2（轴对齐，指数衰减发射率，无屏蔽）：\n  - $a = 0.008\\,\\mathrm{m}$，$L = 0.200\\,\\mathrm{m}$，因此 $\\theta_c = \\arctan\\!\\left(\\frac{0.008}{0.200}\\right)$。\n  - $\\delta = 0.020\\,\\mathrm{rad}$。\n  - $s_0 = 0.500\\,\\mathrm{m}$，$s_1 = 1.500\\,\\mathrm{m}$。\n  - $q(s) = q_0 \\exp\\!\\left(-\\frac{s}{\\lambda}\\right)$，其中 $q_0 = 5.0\\times 10^8\\,\\mathrm{s^{-1}\\,m^{-1}}$，$\\lambda = 0.700\\,\\mathrm{m}$。\n  - 屏蔽段：无（设置所有 $t_i = 0.000\\,\\mathrm{m}$）。\n  - $\\epsilon = 2.0\\times 10^{-6}$。\n\n- 情况3（离轴，被准直器阻挡，恒定发射率）：\n  - $a = 0.005\\,\\mathrm{m}$，$L = 0.050\\,\\mathrm{m}$，因此 $\\theta_c = \\arctan\\!\\left(\\frac{0.005}{0.050}\\right)$。\n  - $\\delta = 0.120\\,\\mathrm{rad}$。\n  - $s_0 = 0.300\\,\\mathrm{m}$，$s_1 = 1.300\\,\\mathrm{m}$。\n  - $q(s) = q_0$，其中 $q_0 = 1.0\\times 10^8\\,\\mathrm{s^{-1}\\,m^{-1}}$。\n  - 屏蔽段：钢，$\\mu = 8.0\\,\\mathrm{m^{-1}}$，$t = 0.200\\,\\mathrm{m}$；钨，$\\mu = 25.0\\,\\mathrm{m^{-1}}$，$t = 0.100\\,\\mathrm{m}$。\n  - $\\epsilon = 1.0\\times 10^{-6}$。\n\n- 情况4（近孔径弦，高斯发射率峰值，重屏蔽）：\n  - $a = 0.012\\,\\mathrm{m}$，$L = 0.500\\,\\mathrm{m}$，因此 $\\theta_c = \\arctan\\!\\left(\\frac{0.012}{0.500}\\right)$。\n  - $\\delta = 0.000\\,\\mathrm{rad}$。\n  - $s_0 = 0.050\\,\\mathrm{m}$，$s_1 = 0.500\\,\\mathrm{m}$。\n  - $q(s) = q_0 \\exp\\!\\left(-\\frac{(s - s_c)^2}{2\\sigma^2}\\right)$，其中 $q_0 = 1.0\\times 10^9\\,\\mathrm{s^{-1}\\,m^{-1}}$，$s_c = 0.200\\,\\mathrm{m}$，$\\sigma = 0.050\\,\\mathrm{m}$。\n  - 屏蔽段：铅，$\\mu = 12.0\\,\\mathrm{m^{-1}}$，$t = 0.300\\,\\mathrm{m}$；混凝土，$\\mu = 1.0\\,\\mathrm{m^{-1}}$，$t = 0.700\\,\\mathrm{m}$。\n  - $\\epsilon = 5.0\\times 10^{-7}$。\n\n- 情况5（角度略低于截止角，线性斜坡发射率，中等屏蔽）：\n  - $a = 0.010\\,\\mathrm{m}$，$L = 0.100\\,\\mathrm{m}$，因此 $\\theta_c = \\arctan\\!\\left(\\frac{0.010}{0.100}\\right)$。\n  - $\\delta = 0.095\\,\\mathrm{rad}$。\n  - $s_0 = 0.400\\,\\mathrm{m}$，$s_1 = 1.800\\,\\mathrm{m}$。\n  - $q(s) = q_0 \\frac{s - s_0}{s_1 - s_0}$ 对于 $s \\in [s_0,s_1]$，其中 $q_0 = 2.0\\times 10^8\\,\\mathrm{s^{-1}\\,m^{-1}}$。\n  - 屏蔽段：硼化聚乙烯，$\\mu = 3.0\\,\\mathrm{m^{-1}}$，$t = 0.100\\,\\mathrm{m}$。\n  - $\\epsilon = 1.0\\times 10^{-6}$。\n\n最终输出格式要求：\n- 您的程序应产生单行输出，其中包含五个案例的探测计数率，以逗号分隔的列表形式包含在方括号内，并按上述案例的顺序排列（例如，$[c_1,c_2,c_3,c_4,c_5]$）。每个 $c_i$ 必须是一个单位为 $\\mathrm{s^{-1}}$ 的浮点数。",
            "solution": "我们从第一性原理出发，使用沿直线视线（LoS）的带有源项的衰减特征形式来构建模拟中子相机响应。令 $s$ 表示从孔径平面到等离子体内部的距离，其中 $s \\in [s_0,s_1]$，令 $q(s)$ 表示线积分发射率密度，单位为 $\\mathrm{s^{-1}\\,m^{-1}}$。\n\n基于原理的推导：\n1.  考虑位置 $s$ 处的一个无穷小段 $ds$。该段的各向同性发射通过有限孔径对探测器产生贡献。对于各向同性源，进入孔径的中子发射分数是孔径立体角与全空间立体角之比：\n    $$ f_{\\Omega}(s) = \\frac{\\Omega(s)}{4\\pi} $$\n    对于面积为 $A = \\pi a^2$ 的小圆形孔径，从距离 $s$ 处以相对于孔径法线为 $\\delta$ 的偏置角观察，小孔径立体角为：\n    $$ \\Omega(s) = \\frac{A \\cos\\delta}{s^2} $$\n    这源于在孔径平面上对 $r = s$ 求值时的微分立体角定义 $d\\Omega = \\frac{dA \\cos\\delta}{r^2}$。\n\n2.  准直器施加了角度接收限制。一个半径为 $a$、长度为 $L$ 的圆柱形准直器允许半角\n    $$ \\theta_c = \\arctan\\!\\left(\\frac{a}{L}\\right) $$\n    内的射线通过。对于固定的LoS偏置角 $\\delta$，通过准直器的透射率为：\n    $$ \\chi(\\delta) = \\begin{cases} 1, & \\delta \\le \\theta_c, \\\\ 0, & \\delta > \\theta_c. \\end{cases} $$\n\n3.  结构衰减通过比尔-朗伯定律沿屏蔽材料路径段建模。对于宏观衰减系数为 $\\mu_i$、厚度为 $t_i$ 的段 $i$，总透射因子为：\n    $$ T = \\exp\\!\\left(-\\sum_i \\mu_i t_i\\right) $$\n    在假设屏蔽位于孔径和等离子体之间，并且对于所有沿 $s \\in [s_0,s_1]$ 的贡献都被同样地穿过的条件下，$T$ 相对于 $s$ 是一个常数。\n\n4.  相关中子能量的探测效率 $\\epsilon$ 乘以计数率。\n\n将这些部分组合在一起，来自无穷小段 $ds$ 的贡献 $dC$ 为：\n$$ dC = q(s) \\, ds \\times \\frac{\\Omega(s)}{4\\pi} \\times \\chi(\\delta) \\times T \\times \\epsilon $$\n代入 $\\Omega(s)$ 的表达式得到：\n$$ dC = q(s) \\, ds \\times \\frac{A \\cos\\delta}{4\\pi s^2} \\times \\chi(\\delta) \\times T \\times \\epsilon $$\n对 $s \\in [s_0,s_1]$ 进行积分，得到探测到的计数率：\n$$ C = \\left( \\frac{A \\cos\\delta}{4\\pi} \\right) \\chi(\\delta) \\, T \\, \\epsilon \\int_{s_0}^{s_1} \\frac{q(s)}{s^2} \\, ds $$\n该表达式是基于第一性原理构建的特征线解：它整合了各向同性发射、通过平方反比定律的几何稀释、立体角孔径分数、准直器接收、结构衰减和探测器效率。请注意，如果 $\\delta > \\theta_c$，则 $\\chi(\\delta) = 0$ 且 $C = 0$。\n\n算法设计：\n- 对于给定的 $a$ 和 $L$，计算 $A = \\pi a^2$ 和 $\\theta_c = \\arctan\\!\\left(\\frac{a}{L}\\right)$。\n- 通过比较 $\\delta$ 和 $\\theta_c$ 来计算 $\\chi(\\delta)$。\n- 根据屏蔽段列表，使用 $T = \\exp\\!\\left(-\\sum_i \\mu_i t_i\\right)$ 计算 $T$。\n- 根据测试案例定义 $q(s)$：\n  - 恒定: $q(s) = q_0$。\n  - 指数: $q(s) = q_0 \\exp\\!\\left(-\\frac{s}{\\lambda}\\right)$。\n  - 高斯: $q(s) = q_0 \\exp\\!\\left(-\\frac{(s - s_c)^2}{2\\sigma^2}\\right)$。\n  - 线性斜坡: $q(s) = q_0 \\frac{s - s_0}{s_1 - s_0}$。\n- 使用鲁棒的求积方法（例如，通过数值积分的自适应高斯-克龙罗德方法）数值计算积分\n  $$ I = \\int_{s_0}^{s_1} \\frac{q(s)}{s^2} \\, ds $$\n  ，使用适合预期动态范围的绝对容差和相对容差。根据构造，下限 $s_0$ 严格为正以避免发散。\n- 计算\n  $$ C = \\left( \\frac{A \\cos\\delta}{4\\pi} \\right) \\chi(\\delta) \\, T \\, \\epsilon \\, I $$\n\n单位与验证：\n- $a$、$L$、$s_0$、$s_1$、$\\lambda$、$s_c$、$\\sigma$ 和 $t_i$ 的单位是 $\\mathrm{m}$。\n- $\\mu_i$ 的单位是 $\\mathrm{m^{-1}}$。\n- $q_0$ 和 $q(s)$ 的单位是 $\\mathrm{s^{-1}\\,m^{-1}}$。\n- $\\epsilon$ 是无量纲的。\n- $\\delta$ 和 $\\theta_c$ 的单位是弧度。\n- 输出 $C$ 的单位是 $\\mathrm{s^{-1}}$。\n- 特殊情况处理：如果 $\\delta > \\theta_c$，输出 $C = 0$；如果屏蔽为零，$T = 1$。\n\n测试套件覆盖范围说明：\n- 情况1 在长弦上使用多种屏蔽材料和恒定 $q(s)$ 来检验通用流程。\n- 情况2 测试非均匀 $q(s)$ 和无屏蔽的情况。\n- 情况3 验证当 $\\delta > \\theta_c$ 时准直器的拒绝功能。\n- 情况4 在重屏蔽条件下，通过较小的 $s_0$ 和峰值高斯 $q(s)$ 来探测近孔径行为。\n- 情况5 探讨使用线性变化的 $q(s)$ 在准直边界附近的操作。\n\n程序输出规范：\n- 以 $[c_1,c_2,c_3,c_4,c_5]$ 的格式生成单行输出，其中每个 $c_i$ 是对应案例计算出的浮点计数率，单位为 $\\mathrm{s^{-1}}$，按所列顺序排列。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef attenuation_transmission(materials):\n    \"\"\"\n    Compute total transmission T = exp(-sum(mu_i * t_i)) for given shielding segments.\n    materials: list of (mu, t) pairs with mu in m^-1 and t in m.\n    \"\"\"\n    total_mu_t = sum(mu * t for (mu, t) in materials)\n    return np.exp(-total_mu_t)\n\ndef acceptance_half_angle(a, L):\n    \"\"\"\n    Compute collimator acceptance half-angle theta_c = arctan(a / L).\n    \"\"\"\n    return np.arctan(a / L)\n\ndef solid_angle_factor(a, delta):\n    \"\"\"\n    Compute aperture geometric factor A*cos(delta)/(4*pi) with A = pi*a^2.\n    \"\"\"\n    A = np.pi * a * a\n    return (A * np.cos(delta)) / (4.0 * np.pi)\n\ndef line_integral_q_over_s2(q_func, s0, s1):\n    \"\"\"\n    Numerically compute integral I = int_{s0}^{s1} q(s)/s^2 ds using adaptive quadrature.\n    \"\"\"\n    # Use Gauss-Kronrod (quad) with tolerances suitable for potentially sharp features.\n    I, err = integrate.quad(lambda s: q_func(s) / (s * s), s0, s1, epsabs=1e-9, epsrel=1e-9, limit=200)\n    return I\n\ndef case_constant_q(q0):\n    return lambda s: q0\n\ndef case_exponential_q(q0, lam):\n    return lambda s: q0 * np.exp(-s / lam)\n\ndef case_gaussian_q(q0, sc, sigma):\n    return lambda s: q0 * np.exp(-((s - sc) ** 2) / (2.0 * sigma * sigma))\n\ndef case_linear_ramp_q(q0, s0, s1):\n    span = s1 - s0\n    return lambda s: q0 * ((s - s0) / span)\n\ndef compute_count_rate(a, L, delta, s0, s1, q_func, materials, epsilon):\n    \"\"\"\n    Compute detected count rate C for given parameters under the model:\n    C = [A*cos(delta)/(4*pi)] * chi(delta) * T * epsilon * integral_{s0}^{s1} q(s)/s^2 ds,\n    where chi(delta) is 1 if delta = theta_c, else 0.\n    \"\"\"\n    theta_c = acceptance_half_angle(a, L)\n    if delta > theta_c:\n        return 0.0  # Collimator blocks off-axis LoS\n    T = attenuation_transmission(materials)\n    geom = solid_angle_factor(a, delta)\n    I = line_integral_q_over_s2(q_func, s0, s1)\n    C = geom * T * epsilon * I\n    return C\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"a\": 0.015,\n            \"L\": 0.300,\n            \"delta\": 0.0,\n            \"s0\": 0.200,\n            \"s1\": 2.500,\n            \"q_func\": case_constant_q(1.0e8),\n            \"materials\": [(8.0, 0.100), (1.2, 0.500), (3.0, 0.050)],\n            \"epsilon\": 1.0e-6,\n        },\n        # Case 2\n        {\n            \"a\": 0.008,\n            \"L\": 0.200,\n            \"delta\": 0.020,\n            \"s0\": 0.500,\n            \"s1\": 1.500,\n            \"q_func\": case_exponential_q(5.0e8, 0.700),\n            \"materials\": [],  # No shielding\n            \"epsilon\": 2.0e-6,\n        },\n        # Case 3\n        {\n            \"a\": 0.005,\n            \"L\": 0.050,\n            \"delta\": 0.120,\n            \"s0\": 0.300,\n            \"s1\": 1.300,\n            \"q_func\": case_constant_q(1.0e8),\n            \"materials\": [(8.0, 0.200), (25.0, 0.100)],\n            \"epsilon\": 1.0e-6,\n        },\n        # Case 4\n        {\n            \"a\": 0.012,\n            \"L\": 0.500,\n            \"delta\": 0.0,\n            \"s0\": 0.050,\n            \"s1\": 0.500,\n            \"q_func\": case_gaussian_q(1.0e9, 0.200, 0.050),\n            \"materials\": [(12.0, 0.300), (1.0, 0.700)],\n            \"epsilon\": 5.0e-7,\n        },\n        # Case 5\n        {\n            \"a\": 0.010,\n            \"L\": 0.100,\n            \"delta\": 0.095,\n            \"s0\": 0.400,\n            \"s1\": 1.800,\n            \"q_func\": case_linear_ramp_q(2.0e8, 0.400, 1.800),\n            \"materials\": [(3.0, 0.100)],\n            \"epsilon\": 1.0e-6,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        a = case[\"a\"]\n        L = case[\"L\"]\n        delta = case[\"delta\"]\n        s0 = case[\"s0\"]\n        s1 = case[\"s1\"]\n        q_func = case[\"q_func\"]\n        materials = case[\"materials\"]\n        epsilon = case[\"epsilon\"]\n\n        C = compute_count_rate(a, L, delta, s0, s1, q_func, materials, epsilon)\n        results.append(C)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "一个成功的诊断不仅需要精确的正向模型，还需要能够从测量数据中可靠地反演出我们关心的物理量。本练习将您的注意力从构建模型转移到分析其数学特性上，特别是针对弦积分测量（如Abel反演问题）。您将构建一个将局部发射率剖面映射到弦积分测量的正向算符矩阵，并分析其秩和条件数。这项实践将通过一个具体的几何问题，帮助您理解可识别性（identifiability）和不适定性（ill-conditioning）等关键的逆问题概念，并揭示测量系统的设计对物理量重构的决定性影响 。",
            "id": "3948452",
            "problem": "您的任务是为环形磁约束装置中辐射发射率的轴对称弦积分测量构建一个合成诊断正向算子。其目的是通过计算不同弦测量设置下的矩阵秩和 $2$-范数条件数，来研究将连续正向算子 $H$ 离散化为矩阵 $\\mathbf{H}$ 如何影响可辨识性。您的程序必须实现几何计算，为指定的测试套件计算所要求的属性，然后将结果单行输出。\n\n基本基础和物理模型：\n- 考虑一个半径为 $R$（单位 $\\mathrm{m}$）的圆形极向截面，以及一个仅依赖于径向坐标 $r$（其中 $0 \\le r \\le R$）的轴对称非负发射率场 $\\epsilon(r)$。\n- 测量是通过与截面相交的直线视线（弦）获得的。每条弦由其碰撞参数 $b$（单位 $\\mathrm{m}$）定义，即弦与截面中心之间的最小距离。假设弦足够长，可以完全穿过截面。\n- 在轴对称假设下，每个弦积分信号是 $\\epsilon(r)$ 沿着穿过等离子体的弦路径的线积分。如果发射率在同心环带上是分段常数，则测量值成为各环带贡献的线性组合，其系数与弦在每个环带内截断的路径长度成正比。\n\n离散化：\n- 将 $[0,R]$ 离散化为 $N$ 个具有均匀边界 $r_0, r_1, \\dots, r_N$ 的同心环带（区域），其中 $r_0 = 0$ 且 $r_n = R \\cdot n / N$ 对于 $n = 1,2,\\dots,N$。\n- 令 $f_n$ 表示第 $n$ 个环带 $(r_{n-1}, r_n]$ 中的常数发射率（单位任意）。对于一条碰撞参数为 $b$ 的弦，其测量值 $s(b)$ 离散化为 $s(b) = \\sum_{n=1}^{N} H_{n}(b) f_n$，其中 $H_n(b)$ 是弦在第 $n$ 个环带内的路径长度（单位 $\\mathrm{m}$）。\n- 对于具有碰撞参数 $b_m$（$m=1,\\dots,M$）的 $M$ 条弦，这会产生一个线性系统 $\\mathbf{s} = \\mathbf{H} \\mathbf{f}$，其中 $\\mathbf{H} \\in \\mathbb{R}^{M \\times N}$。\n\n$\\mathbf{H}$ 的几何确定：\n- 对于每条碰撞参数为 $b$ 的弦，如果 $b  a$，其与半径为 $a$ 的圆的相交长度为 $2\\sqrt{a^2 - b^2}$，否则为 $0$。在环带 $(r_{n-1}, r_n]$ 内的路径长度是与 $r_n$ 和 $r_{n-1}$ 相交长度之差。如果仪器孔径将可观测半径限制为 $R_{\\mathrm{ap}} \\le R$，则有效外边界为 $\\min(r_n, R_{\\mathrm{ap}})$，有效内边界为 $\\min(r_{n-1}, R_{\\mathrm{ap}})$。\n\n可辨识性度量：\n- $\\mathbf{H}$ 的矩阵秩表示可从弦测量中辨识的发射率剖面子空间的维度。如果 $\\mathrm{rank}(\\mathbf{H}) = N$，则 $\\mathbf{f}$ 在线性意义上是可辨识的；如果 $\\mathrm{rank}(\\mathbf{H})  N$，则某些分量是不可观测的。\n- $2$-范数条件数 $\\kappa_2(\\mathbf{H})$ 等于最大奇异值与最小奇异值之比。大的 $\\kappa_2(\\mathbf{H})$ 意味着病态问题，以及推断出的 $\\mathbf{f}$ 对测量噪声的高度敏感性。如果最小奇异值为 $0$，则 $\\kappa_2(\\mathbf{H})$ 为无穷大。\n\n任务：\n1.  根据上述几何规则为每个测试用例构建 $\\mathbf{H}$。\n2.  计算 $\\mathrm{rank}(\\mathbf{H})$ 和 $\\kappa_2(\\mathbf{H})$（使用矩阵 $2$-范数条件数）。\n3.  按指定格式输出结果。\n\n测试套件：\n- 所有测试用例均使用 $R = 1.0$ $\\mathrm{m}$ 和均匀环带。\n- 案例 1（基准，方阵系统）：$N = 8$，$M = 8$，碰撞参数 $b_m = R \\cdot [0.000, 0.125, 0.250, 0.375, 0.500, 0.625, 0.750, 0.875]$，无孔径限制。\n- 案例 2（超定）：$N = 8$，$M = 16$，$b_m$ 在 $[0, 0.95 R]$ 内线性间隔，无孔径限制。\n- 案例 3（欠定）：$N = 8$，$M = 5$，碰撞参数 $b_m = R \\cdot [0.000, 0.200, 0.400, 0.600, 0.800]$，无孔径限制。\n- 案例 4（弦密集，近简并采样）：$N = 8$，$M = 8$，碰撞参数 $b_m = R \\cdot [0.680, 0.690, 0.700, 0.710, 0.720, 0.730, 0.740, 0.750]$，无孔径限制。\n- 案例 5（有限孔径）：$N = 8$，$M = 8$，与案例 1 相同的 $b_m$，但 $R_{\\mathrm{ap}} = 0.700 R$。\n\n输出规范：\n- 对于每个案例，计算整数秩和浮点 $2$-范数条件数，四舍五入到 $6$ 位小数。将所有结果按顺序收集到一个列表中，交替出现秩和条件数值，即 $[\\mathrm{rank}_1, \\kappa_2(\\mathbf{H}_1), \\mathrm{rank}_2, \\kappa_2(\\mathbf{H}_2), \\dots]$。\n- 您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如 $[r_1,c_1,r_2,c_2,\\dots]$）。不应打印任何附加文本。\n\n角度单位：\n- 不使用角度；弦仅由其碰撞参数表征。\n\n单位：\n- 几何结构以 $\\mathrm{m}$ 为单位定义，但输出量 $\\mathrm{rank}(\\mathbf{H})$ 和 $\\kappa_2(\\mathbf{H})$ 是无量纲的。输出不需要物理单位。\n\n约束条件：\n- 使用适合研究生水平计算的标准线性代数工具实现，除了基本基础知识外，不要调用任何捷径公式。在处理平方根和奇异值时，确保数值稳健性。",
            "solution": "问题陈述经评估有效。它具有科学依据，提法恰当，并为聚变等离子体诊断领域的计算任务提供了一套完整且一致的要求。该问题要求构建和分析一个正向算子，这是合成诊断中用于比较计算模型与实验测量的标准流程。\n\n问题的核心是设计一种合成诊断，用于模拟具有假定轴对称截面的环形等离子体中的弦积分发射率测量。这在数学上等同于 Abel 变换问题。我们的任务是离散化这个连续算子，并针对几种测量配置评估所得矩阵表示 $\\mathbf{H}$ 的属性。评估的关键指标是矩阵秩 $\\mathrm{rank}(\\mathbf{H})$ 和 $2$-范数条件数 $\\kappa_2(\\mathbf{H})$。\n\n首先，我们对模型进行形式化。连续发射率剖面 $\\epsilon(r)$ 假定仅依赖于小半径 $r$，其中 $0 \\le r \\le R$。我们将此剖面离散化为 $N$ 个宽度均匀的同心环带。这些环带由半径 $r_n = R \\cdot n / N$ 定义，其中 $n=0, 1, \\dots, N$。在每个环带 $(r_{n-1}, r_n]$ 内，假定发射率为常数值 $f_n$。这构成了对真实剖面 $\\epsilon(r)$ 的分段常数近似。\n\n测量是沿着一条直线视线（或称弦）进行的，该弦由其碰撞参数 $b$ 定义，即弦到圆形截面中心的最小距离。测量的信号 $s(b)$ 是发射率沿着该弦的线积分。在我们的离散模型中，该积分变为一个和：\n$$\ns(b) = \\sum_{n=1}^{N} H_{n}(b) f_n\n$$\n其中 $H_{n}(b)$ 是碰撞参数为 $b$ 的弦穿过第 $n$ 个环带的路径长度。对于一组具有碰撞参数 $b_1, \\dots, b_M$ 的 $M$ 次测量，我们得到一个线性方程组：\n$$\n\\mathbf{s} = \\mathbf{H} \\mathbf{f}\n$$\n这里，$\\mathbf{s} \\in \\mathbb{R}^M$ 是测量向量，$\\mathbf{f} \\in \\mathbb{R}^N$ 是未知的环带发射率向量，而 $\\mathbf{H} \\in \\mathbb{R}^{M \\times N}$ 是我们必须构建的正向算子矩阵。该矩阵的元素 $H_{mn}$ 是第 $m$ 条弦（$b_m$）穿过第 $n$ 个环带的路径长度。\n\n矩阵元素 $H_{mn}$ 的几何计算是核心。碰撞参数为 $b$ 的弦穿过半径为 $a$ 的圆（其中 $b  a$）的总路径长度由初等几何给出，为 $L(a, b) = 2\\sqrt{a^2 - b^2}$。如果 $b \\ge a$，弦不与圆相交，路径长度为 $0$。穿过环带 $(r_{n-1}, r_n]$ 的路径长度是穿过由其外半径和内半径定义的圆的路径长度之差：\n$$\nH_{mn} = L(r_n, b_m) - L(r_{n-1}, b_m)\n$$\n此公式成立的前提是我们定义当 $b \\ge a$ 时 $L(a, b) = 0$。\n\n问题还引入了一个可选的仪器孔径 $R_{\\mathrm{ap}}$，它将可观测区域限制在 $r \\le R_{\\mathrm{ap}}$。为了考虑这一点，我们必须使用有效半径。穿过第 $n$ 个环带的路径长度是使用被孔径裁剪的半径计算的：$r'_n = \\min(r_n, R_{\\mathrm{ap}})$ 和 $r'_{n-1} = \\min(r_{n-1}, R_{\\mathrm{ap}})$。矩阵元素的公式变为：\n$$\nH_{mn} = L(r'_n, b_m) - L(r'_{n-1}, b_m)\n$$\n在数值实现过程中，当 $b_m$ 非常接近有效半径 $r'$ 时必须小心，因为浮点数的不精确性可能导致 $(r')^2 - b_m^2$ 项略微为负。我们必须确保平方根的参数为非负数。\n\n一旦为给定的测试用例构建了矩阵 $\\mathbf{H}$，我们就分析其属性。\n1.  计算 $\\mathbf{H}$ 的秩 $\\mathrm{rank}(\\mathbf{H})$。秩给出了线性无关的行（或列）的数量，这对应于由测量张成的数据空间的维度。如果 $\\mathrm{rank}(\\mathbf{H}) = N$（未知数的数量），则在方形或超定系统的情况下，发射率剖面 $\\mathbf{f}$ 可以从测量值 $\\mathbf{s}$ 中唯一确定。如果 $\\mathrm{rank}(\\mathbf{H})  N$，则系统是欠定的或秩亏的，$\\mathbf{f}$ 的唯一解不存在。\n2.  计算 $2$-范数条件数 $\\kappa_2(\\mathbf{H})$。它是 $\\mathbf{H}$ 的最大奇异值与最小奇异值之比，$\\kappa_2(\\mathbf{H}) = \\sigma_{\\max} / \\sigma_{\\min}$。大的条件数表示一个病态问题，其中测量向量 $\\mathbf{s}$ 中的小误差或噪声可能导致推断解 $\\mathbf{f}$ 中的大误差。如果 $\\mathbf{H}$ 是奇异的或秩亏的（即 $\\sigma_{\\min} = 0$），则条件数为无穷大。\n\n实现将通过迭代五个指定的测试用例来进行。对于每个案例，我们定义参数（$N, M, R, \\{b_m\\}, R_{\\mathrm{ap}}$），使用几何公式逐个元素构建矩阵 $\\mathbf{H}$，然后使用标准的数值线性代数程序计算其秩和条件数。结果将按规定格式收集和格式化。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and analyzes a forward operator matrix for synthetic chord-integrated\n    emissivity measurements in a toroidal plasma cross-section.\n    \"\"\"\n\n    def get_h_matrix(R, N, M, b_params, R_ap=None):\n        \"\"\"\n        Constructs the forward operator matrix H.\n\n        Args:\n            R (float): Radius of the circular cross-section.\n            N (int): Number of concentric annuli (emissivity zones).\n            M (int): Number of measurement chords.\n            b_params (np.ndarray): Array of impact parameters for the chords.\n            R_ap (float, optional): Aperture radius limit. Defaults to None.\n\n        Returns:\n            np.ndarray: The M x N forward operator matrix H.\n        \"\"\"\n        # Define annulus radii\n        r = R * np.arange(N + 1) / N\n\n        # Initialize the H matrix\n        H = np.zeros((M, N))\n\n        # Helper function for chord length through a circle of radius 'a'\n        def chord_length(a, b):\n            # Numerically robust calculation of 2 * sqrt(a^2 - b^2)\n            if b >= a:\n                return 0.0\n            return 2.0 * np.sqrt(a**2 - b**2)\n\n        # Populate the H matrix\n        for m in range(M):\n            b = b_params[m]\n            for n in range(N):\n                r_inner = r[n]\n                r_outer = r[n + 1]\n\n                # Apply aperture limit if specified\n                r_eff_inner = r_inner\n                r_eff_outer = r_outer\n                if R_ap is not None:\n                    r_eff_inner = min(r_inner, R_ap)\n                    r_eff_outer = min(r_outer, R_ap)\n\n                # Path length is the difference of lengths through the outer and inner circles\n                # of the (effective) annulus.\n                len_outer = chord_length(r_eff_outer, b)\n                len_inner = chord_length(r_eff_inner, b)\n                H[m, n] = len_outer - len_inner\n        \n        return H\n\n    # Common parameters\n    R_base = 1.0\n\n    # Test suite definition\n    test_cases = [\n        # Case 1: baseline, square system\n        {'N': 8, 'M': 8, 'b_params': R_base * np.array([0.000, 0.125, 0.250, 0.375, 0.500, 0.625, 0.750, 0.875]), 'R_ap': None},\n        # Case 2: overdetermined\n        {'N': 8, 'M': 16, 'b_params': np.linspace(0, 0.95 * R_base, 16), 'R_ap': None},\n        # Case 3: underdetermined\n        {'N': 8, 'M': 5, 'b_params': R_base * np.array([0.000, 0.200, 0.400, 0.600, 0.800]), 'R_ap': None},\n        # Case 4: clustered chords, near-degenerate sampling\n        {'N': 8, 'M': 8, 'b_params': R_base * np.array([0.680, 0.690, 0.700, 0.710, 0.720, 0.730, 0.740, 0.750]), 'R_ap': None},\n        # Case 5: limited aperture\n        {'N': 8, 'M': 8, 'b_params': R_base * np.array([0.000, 0.125, 0.250, 0.375, 0.500, 0.625, 0.750, 0.875]), 'R_ap': 0.700 * R_base},\n    ]\n\n    results = []\n    for case in test_cases:\n        H = get_h_matrix(R_base, case['N'], case['M'], case['b_params'], case['R_ap'])\n\n        # Compute rank and condition number\n        rank = np.linalg.matrix_rank(H)\n        cond_num = np.linalg.cond(H)\n\n        results.append(rank)\n        \n        # Format condition number. np.inf will be handled by str() conversion later\n        if np.isinf(cond_num):\n            results.append(cond_num)\n        else:\n            results.append(round(cond_num, 6))\n\n    # Format the final output string as specified\n    # map(str, ...) correctly handles integers, floats, and np.inf\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}