{
    "hands_on_practices": [
        {
            "introduction": "理论知识到实际应用的转化是计算科学的核心。本实践从电磁学的第一性原理出发，要求您将毕奥-萨伐尔定律和洛伦兹力定律转化为可执行的计算程序，用于求解线圈间的电磁力。这个练习的价值不仅在于实现基本的物理公式，更在于解决一个关键的数值挑战：当观测点靠近载流导线时，积分核会呈现近奇异性。通过实现自适应的数值积分方案，您将掌握处理此类问题的稳健方法，为更复杂的电磁仿真打下坚实的基础。",
            "id": "3970518",
            "problem": "一个半径为 $a$、载有稳恒电流 $I$ 的单匝完美导电圆形线圈，其中心位于原点，并置于 $z=0$ 平面内。该线圈在观测点 $\\mathbf{r}$ 处产生的磁场由毕奥-萨伐尔定律定义，该定律指出，对于局限于一维曲线的电流分布，磁场由以下形式的积分给出\n$$\n\\mathbf{B}(\\mathbf{r}) = \\frac{\\mu_0}{4\\pi}\\int_{\\mathcal{C}} \\frac{I\\,d\\boldsymbol{\\ell}\\times\\mathbf{\\hat{R}}}{R^2},\n$$\n其中 $\\mu_0$ 是自由空间磁导率，$d\\boldsymbol{\\ell}$ 是沿线圈中心线 $\\mathcal{C}$ 的微分线元，$\\mathbf{R}=\\mathbf{r}-\\boldsymbol{\\ell}$ 是从线圈上的源点到观测点的矢量，$R=\\|\\mathbf{R}\\|$，且 $\\mathbf{\\hat{R}}=\\mathbf{R}/R$。\n\n除磁场外，再考虑一个半径同样为 $a$、载有电流 $I_2$ 的第二个圆形线圈，它与第一个线圈共轴，但沿 $z$ 轴平移了偏移量 $z_2$。由第一个线圈产生的磁场对第二个线圈施加的洛伦兹力由洛伦兹力磁场部分的线积分给出，\n$$\n\\mathbf{F} = \\int_{\\mathcal{C}_2} I_2\\, d\\boldsymbol{\\ell}_2 \\times \\mathbf{B}_1(\\boldsymbol{\\ell}_2),\n$$\n其中 $\\mathbf{B}_1$ 是由第一个线圈产生的磁场，$d\\boldsymbol{\\ell}_2$ 是沿第二个线圈 $\\mathcal{C}_2$ 的微分线元。\n\n从这些基本定律出发，编写一个完整、可运行的程序，该程序：\n- 以参数化方式表示圆形线圈中心线，并使用数值稳健的求积法计算毕奥-萨伐尔积分，以在任意点 $\\mathbf{r}$ 处评估 $\\mathbf{B}(\\mathbf{r})$。\n- 实现带有分片高斯规则的复合求积法，并结合当观测点靠近线圈时触发的局部分片细化，以便精确解析被积函数的近奇异行为。\n- 使用第一个线圈产生的磁场和洛伦兹力定律的磁场部分，计算作用在第二个线圈上的合力 $\\mathbf{F}$。\n\n您的解法必须以弧度处理角度。所有物理量必须用国际单位制（SI）表示。具体而言：\n- 磁场矢量 $\\mathbf{B}$ 以特斯拉（Tesla）为单位。\n- 力矢量 $\\mathbf{F}$ 以牛顿（Newtons）为单位。\n\n设计求积法，使其对于不精确位于线圈中心线上的观测点是数值稳定的。在您的解法叙述中，从第一性原理出发，解释当观测点接近线圈时如何构造一个能够感知奇异性的数值求积法，并概述当观测点位于线圈上时如何对奇异行为进行正则化或减除。\n\n测试套件：\n使用以下参数集和观测点。在所有情况下，除非另有说明，线圈半径为 $a=0.5\\,\\mathrm{m}$，源线圈中的电流为 $I_1=15000\\,\\mathrm{A}$。\n\n1. 轴上一点的磁场：$\\mathbf{r}=(0,0,0.1)\\,\\mathrm{m}$。\n2. 靠近导线的离轴点的磁场：$\\mathbf{r}=(0.49,0.0,0.0)\\,\\mathrm{m}$。\n3. 远离导线的离轴点的磁场：$\\mathbf{r}=(1.5,0.0,0.2)\\,\\mathrm{m}$。\n4. 位于 $z=z_2=0.05\\,\\mathrm{m}$、载有电流 $I_2=12000\\,\\mathrm{A}$、半径为 $a=0.5\\,\\mathrm{m}$ 的第二个共轴线圈，受到位于 $z=0$、载有电流 $I_1=15000\\,\\mathrm{A}$ 的第一个线圈作用的合力。\n\n对于前三种情况，计算磁场矢量 $\\mathbf{B}$（单位：特斯拉）。对于第四种情况，计算合力矢量 $\\mathbf{F}$（单位：牛顿）。您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，列表中的每个条目都是一个包含三个浮点数的列表：\n$$\n[\\,[B_{x,1},B_{y,1},B_{z,1}],\\,[B_{x,2},B_{y,2},B_{z,2}],\\,[B_{x,3},B_{y,3},B_{z,3}],\\,[F_x,F_y,F_z]\\,].\n$$\n所有角度必须以弧度处理。所有物理量必须以国际单位制（SI）表示。数值必须以浮点数形式返回。最终的打印输出必须只包含这一行嵌套的结果列表，不带任何额外的解释性文本。",
            "solution": "该问题要求数值计算由圆形灯丝电流环路产生的磁场 $\\mathbf{B}$ 以及两个共轴环路之间的磁力 $\\mathbf{F}$。这通过使用稳健的数值求积方案来计算毕奥-萨伐尔定律和洛伦兹力定律的积分来实现。问题的核心在于处理当观测点靠近载流导线时，毕奥-萨伐尔被积函数的近奇异行为。\n\n**1. 参数化表示与控制方程**\n\n一个半径为 $a$、中心在原点、位于 $z=0$ 平面内的圆形灯丝线圈可以通过角度 $\\phi \\in [0, 2\\pi]$ 进行参数化。线圈上的一个源点 $\\boldsymbol{\\ell}$ 由下式给出：\n$$\n\\boldsymbol{\\ell}(\\phi) = (a \\cos\\phi, a \\sin\\phi, 0)\n$$\n微分线元 $d\\boldsymbol{\\ell}$ 与线圈相切，通过对 $\\boldsymbol{\\ell}(\\phi)$ 关于参数 $\\phi$ 求导得到：\n$$\nd\\boldsymbol{\\ell} = \\frac{d\\boldsymbol{\\ell}}{d\\phi}d\\phi = (-a \\sin\\phi, a \\cos\\phi, 0) d\\phi\n$$\n毕奥-萨伐尔定律给出了在观测点 $\\mathbf{r}=(x, y, z)$ 处由线圈中稳恒电流 $I$ 产生的磁场 $\\mathbf{B}$：\n$$\n\\mathbf{B}(\\mathbf{r}) = \\frac{\\mu_0 I}{4\\pi}\\int_{\\mathcal{C}} \\frac{d\\boldsymbol{\\ell} \\times \\mathbf{R}}{R^3}\n$$\n其中 $\\mathbf{R} = \\mathbf{r} - \\boldsymbol{\\ell}(\\phi)$ 是从源点到观测点的矢量，$R = \\|\\mathbf{R}\\|$。代入参数化形式，积分变为：\n$$\n\\mathbf{B}(\\mathbf{r}) = \\frac{\\mu_0 I}{4\\pi} \\int_0^{2\\pi} \\frac{(d\\boldsymbol{\\ell}/d\\phi) \\times (\\mathbf{r} - \\boldsymbol{\\ell}(\\phi))}{\\|\\mathbf{r} - \\boldsymbol{\\ell}(\\phi)\\|^3} d\\phi\n$$\n这是一个关于参数 $\\phi$ 的矢量值定积分。被积函数是一个函数 $\\mathbf{f}(\\phi) = (f_x(\\phi), f_y(\\phi), f_z(\\phi))$，每个分量都必须进行数值积分。\n\n由第一个线圈的磁场 $\\mathbf{B}_1$ 对载有电流 $I_2$ 的第二个线圈 $\\mathcal{C}_2$ 施加的洛伦兹力为：\n$$\n\\mathbf{F} = I_2 \\int_{\\mathcal{C}_2} d\\boldsymbol{\\ell}_2 \\times \\mathbf{B}_1(\\boldsymbol{\\ell}_2)\n$$\n对于共轴设置，轴对称性会带来显著的简化，这将在第4节中讨论。\n\n**2. 数值求积策略：复合高斯求积法**\n\n积分采用复合高斯-勒让德求积法计算。积分区间 $[0, 2\\pi]$ 被划分为多个更小的区间，或称分片。在每个分片 $[\\phi_a, \\phi_b]$ 上，应用一个 $N_p$ 点的高斯-勒让德求积法则。该法则通过加权和来近似积分：\n$$\n\\int_{\\phi_a}^{\\phi_b} f(\\phi) d\\phi \\approx \\frac{\\phi_b - \\phi_a}{2} \\sum_{i=1}^{N_p} w_i f\\left(\\frac{\\phi_b - \\phi_a}{2} \\xi_i + \\frac{\\phi_a + \\phi_b}{2}\\right)\n$$\n其中 $\\xi_i$ 和 $w_i$ 是区间 $[-1, 1]$ 上的标准高斯-勒让德节点和权重。对于光滑的被积函数，此方法非常精确。\n\n**3. 针对近奇异点的自适应细化**\n\n主要的数值挑战在于，当观测点 $\\mathbf{r}$ 非常靠近线圈时，毕奥-萨伐尔被积函数的行为。分母 $R^3 = \\|\\mathbf{r} - \\boldsymbol{\\ell}(\\phi)\\|^3$ 趋近于零，导致被积函数出现尖峰。一个均匀的求积网格需要极大量的点才能准确解析这个尖峰。\n\n为解决这个问题，采用了自适应网格细化策略。细化基于一个几何准则：\n1. 观测点在柱坐标系中的方位角 $\\phi_{obs} = \\operatorname{atan2}(y, x)$ 对应于线圈上离观测点在 $xy$ 平面上的投影最近的点。\n2. 积分区间 $[0, 2\\pi]$ 最初被划分为一组分片。\n3. 检查每个分片是否需要细化。如果一个分片 $[\\phi_a, \\phi_b]$ 包含最接近的区域，并且在该分片内从 $\\mathbf{r}$ 到线圈段的最小距离 $R_{min}$ 与分片的弧长 $a(\\phi_b - \\phi_a)$ 相比很小，则对其进行细分。一个典型的准则是，如果 $R_{min}  C \\cdot a(\\phi_b - \\phi_a)$（对于一个选定的常数 $C > 1$），则进行细分。\n4. 这个过程被递归地应用，创建了一个在 $\\phi_{obs}$ 附近非常精细、在其他地方则较粗糙的非均匀分片网格。这将计算量集中在被积函数变化最快的地方，确保了准确性和效率。\n\n**4. 通过对称性计算力**\n\n对于两个共轴线圈，力的计算可以大大简化。设线圈1位于 $z=0$，线圈2位于 $z=z_2$，两者半径均为 $a$。力为 $\\mathbf{F} = I_2 \\int_0^{2\\pi} (d\\boldsymbol{\\ell}_2/d\\phi_2) \\times \\mathbf{B}_1(\\boldsymbol{\\ell}_2(\\phi_2)) d\\phi_2$。\n\n由于轴对称性，在第二个线圈上的任何一点 $\\boldsymbol{\\ell}_2(\\phi_2) = (a \\cos\\phi_2, a \\sin\\phi_2, z_2)$ 处的磁场 $\\mathbf{B}_1$，在与该点对齐的柱坐标系中，仅有径向和轴向分量。这些分量的大小 $B_\\rho$ 和 $B_z$ 对于线圈2上的所有点都是恒定的。在笛卡尔坐标系中，场矢量为 $\\mathbf{B}_1(\\phi_2) = (B_\\rho \\cos\\phi_2, B_\\rho \\sin\\phi_2, B_z)$，其中 $B_\\rho$ 和 $B_z$ 可以通过计算单个点（例如 $(a, 0, z_2)$）处的场来找到。在该点，$B_\\rho = B_x$。\n\n微分力元为 $d\\mathbf{F} = I_2 (d\\boldsymbol{\\ell}_2/d\\phi_2) \\times \\mathbf{B}_1 d\\phi_2$。进行叉乘并对 $\\phi_2 \\in [0, 2\\pi]$ 进行积分：\n$$\nd\\mathbf{F} = I_2 \\left( (a B_z \\cos\\phi_2)\\mathbf{\\hat{i}} + (a B_z \\sin\\phi_2)\\mathbf{\\hat{j}} - (a B_\\rho)\\mathbf{\\hat{k}} \\right) d\\phi_2\n$$\n$\\cos\\phi_2$ 和 $\\sin\\phi_2$ 项在 $[0, 2\\pi]$ 上的积分为零。因此，净横向力（$F_x, F_y$）为零，正如对称性所预期的那样。净轴向力为：\n$$\n\\mathbf{F} = \\int_0^{2\\pi} I_2 (-a B_\\rho) \\mathbf{\\hat{k}} d\\phi_2 = -2\\pi a I_2 B_\\rho \\mathbf{\\hat{k}}\n$$\n因此，总力可以通过仅计算第二个线圈上一点（例如 $\\mathbf{r} = (a, 0, z_2)$）的磁场 $\\mathbf{B}_1$，取其径向分量（在该点为 $B_x$），并应用 $F_z$ 的公式来求得。\n\n**5. 针对线圈上奇异点的正则化**\n\n该问题要求概述如何处理观测点 $\\mathbf{r}$ *恰好*位于灯丝线圈上的情况。在这个理想化模型中，$\\mathbf{B}$ 的积分是发散的。这是零厚度假设所导致的非物理假象。\n\n为了获得有物理意义的结果，必须对积分进行正则化。一个常用的方法是**奇异点减除法**。其步骤如下：\n1. 识别奇异点 $\\phi_0$，使得 $\\boldsymbol{\\ell}(\\phi_0) = \\mathbf{r}$。\n2. 用一个能够捕捉相同奇异行为但可以解析积分的更简单的函数 $f_{sing}(\\phi)$ 来近似 $\\phi_0$ 附近的被积函数 $f(\\phi)$。对于弯曲导线，局部奇异行为类似于在 $\\phi_0$ 处与曲线相切的无限长直导线。\n3. 将积分重写为：\n    $$\n    \\int_0^{2\\pi} f(\\phi) d\\phi = \\int_0^{2\\pi} (f(\\phi) - f_{sing}(\\phi)) d\\phi + \\int_0^{2\\pi} f_{sing}(\\phi) d\\phi\n    $$\n4. 第一项，即“正则化后的积分”，其奇异性被抵消。被积函数现在是良态的，可以用数值求积法精确计算。\n5. 第二项，即“奇异部分”，进行解析计算。这两部分之和给出了场的正则化值，这对应于一个物理模型（例如，在有限半径导线中心处的场）。\n这种方法将积分中存在问题的部分分离出来进行解析处理，留下一个良态的数值问题。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\n\n# Physical constants\nMU_0 = 4 * np.pi * 1.0e-7  # Magnetic permeability of free space (T*m/A)\n\ndef _gauss_legendre_quad(func, panel, n_points, func_args):\n    \"\"\"\n    Performs N-point Gauss-Legendre quadrature on a single panel.\n    \n    Args:\n        func: The vector-valued function to integrate.\n        panel: A tuple (a, b) defining the integration interval.\n        n_points: The number of Gaussian points to use.\n        func_args: A tuple of additional arguments to pass to func.\n\n    Returns:\n        np.ndarray: The result of the vector integration.\n    \"\"\"\n    a, b = panel\n    nodes, weights = roots_legendre(n_points)\n    \n    # Map nodes from [-1, 1] to [a, b]\n    mapped_nodes = 0.5 * (b - a) * nodes + 0.5 * (b + a)\n    \n    # Evaluate the function at all mapped nodes\n    # The function is expected to return a (3, k) array where k is the number of nodes\n    f_vals = func(mapped_nodes, *func_args)\n    \n    # Perform the weighted sum for each component (x, y, z)\n    integral_val = 0.5 * (b - a) * np.sum(f_vals * weights[np.newaxis, :], axis=1)\n    \n    return integral_val\n\ndef _calculate_b_integrand(phi, r_obs, a):\n    \"\"\"\n    Calculates the vector integrand of the Biot-Savart law for a circular coil.\n    Expects phi to be a numpy array of evaluation points.\n\n    Args:\n        phi (np.ndarray): Array of angles (source point parameter).\n        r_obs (np.ndarray): Observation point (x, y, z).\n        a (float): Radius of the coil.\n\n    Returns:\n        np.ndarray: A (3, N) array of the vector integrand values.\n    \"\"\"\n    # Source points l(phi) = (a*cos(phi), a*sin(phi), 0)\n    # The shape of phi is (k,), so l_vec has shape (3, k)\n    l_vec = np.array([a * np.cos(phi), a * np.sin(phi), np.zeros_like(phi)])\n    \n    # Differential line elements dl(phi)/dphi = (-a*sin(phi), a*cos(phi), 0)\n    dl_dphi = np.array([-a * np.sin(phi), a * np.cos(phi), np.zeros_like(phi)])\n    \n    # Vector R from source to observation point: R = r_obs - l(phi)\n    # r_obs has shape (3,), we reshape to (3, 1) for broadcasting with l_vec (3, k)\n    r_vec = r_obs.reshape(3, 1) - l_vec\n    \n    # Magnitude of R, with a small epsilon to avoid division by zero if r_obs is on the coil\n    r_mag = np.linalg.norm(r_vec, axis=0)\n    # Add a small machine-epsilon-level value for absolute stability on-coil.\n    r_mag[r_mag == 0] = 1e-15\n\n    # Integrand: (dl/dphi x R) / |R|^3\n    cross_product = np.cross(dl_dphi, r_vec, axisa=0, axisb=0, axisc=0)\n    integrand = cross_product / r_mag**3\n    \n    return integrand\n\ndef calculate_b(r_obs, a, I, n_gauss_points=16, initial_panels=16, refinement_factor=2.0, max_depth=15):\n    \"\"\"\n    Calculates the magnetic field B at an observation point r_obs.\n\n    Uses composite Gauss quadrature with adaptive panel refinement based on\n    proximity to the coil.\n    \"\"\"\n    r_obs = np.array(r_obs, dtype=float)\n    \n    # List to store the final panel intervals for integration\n    final_panels = []\n    \n    # Initial queue of panels to process for refinement\n    # Panel is defined by (start_angle, end_angle, depth)\n    panel_queue = [(i * 2 * np.pi / initial_panels, (i + 1) * 2 * np.pi / initial_panels, 0) for i in range(initial_panels)]\n\n    # Cylindrical coordinates of observation point for distance checking\n    rho_obs = np.sqrt(r_obs[0]**2 + r_obs[1]**2)\n    phi_obs = np.arctan2(r_obs[1], r_obs[0])\n    if phi_obs  0:\n        phi_obs += 2 * np.pi\n\n    while panel_queue:\n        phi_start, phi_end, depth = panel_queue.pop(0)\n\n        # Find minimum distance from r_obs to the coil segment in this panel\n        min_dist_sq = -1.0\n        if phi_start = phi_obs = phi_end:\n            # Point of closest approach is inside the panel's angular range\n            min_dist_sq = (rho_obs - a)**2 + r_obs[2]**2\n        else:\n            # Check endpoints\n            l_start = np.array([a * np.cos(phi_start), a * np.sin(phi_start), 0.0])\n            l_end = np.array([a * np.cos(phi_end), a * np.sin(phi_end), 0.0])\n            dist_sq_start = np.sum((r_obs - l_start)**2)\n            dist_sq_end = np.sum((r_obs - l_end)**2)\n            min_dist_sq = min(dist_sq_start, dist_sq_end)\n\n        min_dist = np.sqrt(min_dist_sq)\n\n        # Refinement condition\n        panel_arc_length = a * (phi_end - phi_start)\n        if depth  max_depth and min_dist  refinement_factor * panel_arc_length:\n            phi_mid = (phi_start + phi_end) / 2\n            panel_queue.append((phi_start, phi_mid, depth + 1))\n            panel_queue.append((phi_mid, phi_end, depth + 1))\n        else:\n            final_panels.append((phi_start, phi_end))\n\n    # Integrate over all the final panels\n    b_integral = np.zeros(3)\n    for panel in final_panels:\n        b_integral += _gauss_legendre_quad(\n            _calculate_b_integrand, panel, n_gauss_points, (r_obs, a)\n        )\n\n    return (MU_0 * I / (4 * np.pi)) * b_integral\n\ndef calculate_f(a, I1, I2, z2):\n    \"\"\"\n    Calculates the force on a second coaxial coil.\n    \"\"\"\n    # By symmetry, we only need the field at one point on the second coil,\n    # e.g., at (a, 0, z2), to find the total force.\n    r_obs_force = np.array([a, 0.0, z2])\n    \n    # Calculate B-field from coil 1 at this point\n    # Parameters for high accuracy required for this near-singular case\n    b_field = calculate_b(r_obs_force, a, I1, n_gauss_points=32, initial_panels=32, refinement_factor=2.0, max_depth=20)\n    \n    # The radial component of the B-field is B_x at (a, 0, z2)\n    b_radial = b_field[0]\n    \n    # Force F_z = -2 * pi * a * I2 * B_radial\n    # F_x and F_y are zero by symmetry.\n    fz = -2 * np.pi * a * I2 * b_radial\n    \n    return np.array([0.0, 0.0, fz])\n\ndef solve():\n    # Define the test cases from the problem statement.\n    a = 0.5  # m\n    I1 = 15000.0  # A\n\n    test_cases = [\n        {'type': 'B', 'params': {'r_obs': (0.0, 0.0, 0.1), 'a': a, 'I': I1}},\n        {'type': 'B', 'params': {'r_obs': (0.49, 0.0, 0.0), 'a': a, 'I': I1}},\n        {'type': 'B', 'params': {'r_obs': (1.5, 0.0, 0.2), 'a': a, 'I': I1}},\n        {'type': 'F', 'params': {'a': a, 'I1': I1, 'I2': 12000.0, 'z2': 0.05}}\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'B':\n            result = calculate_b(**case['params'])\n        elif case['type'] == 'F':\n            result = calculate_f(**case['params'])\n        # Convert to a standard list of floats for the output format\n        results.append([float(f) for f in result])\n\n    # Final print statement in the exact required format.\n    # The format uses list-of-lists, so we convert python lists to string representation.\n    # Note: Using repr() on each list ensures the correct bracket format.\n    print(f\"[{','.join(map(repr, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在工程实际中，线圈的几何形状往往包含锐角等不光滑特征，这给力计算带来了独特的挑战。本实践探讨了在理想化的尖角几何模型中，电磁场和力的奇异行为。您将分析为何局部的洛伦兹力密度 $\\mathbf{J} \\times \\mathbf{B}$ 在尖角处会变得无界，并认识到这种奇异性是物理模型理想化的产物。通过这项练习，您将学会两种应对策略：一是采用物理上更真实的圆角模型进行正则化，二是通过麦克斯韦应力张量在远离奇异点的光滑表面上进行积分，从而获得稳健且与网格无关的总力。",
            "id": "3970469",
            "problem": "在静磁学中，考虑一个用于聚变装置线圈包中的薄载流导体的拐角区域，该区域被建模为理想电导体（PEC）。电流沿平面外方向流动，导体边界的二维横截面具有一个尖锐的、零半径的拐角。假设电磁场通过有限元法（FEM）计算，其中磁矢量势采用基于边的基函数（第一类 Nédélec 单元）。假设为准静态条件，因此位移电流可以忽略不计，并在导体中适当使用欧姆定律。从静磁学 Maxwell 方程组出发，即 $\\nabla \\times \\mathbf{B} = \\mu_0 \\mathbf{J}$ 和 $\\nabla \\cdot \\mathbf{B} = 0$，以及 Lorentz 力密度 $\\mathbf{f} = \\mathbf{J} \\times \\mathbf{B}$。\n\n从理想电导体（PEC）边界的楔边渐近理论可知，在尖锐拐角附近，沿边界弧坐标 $r$ 的表面电流密度行为如 $J_s(r) \\sim C_J r^{-1/2}$，导体外部的切向磁场行为如 $B_t(r) \\sim C_B r^{-1/2}$，其中 $C_J$ 和 $C_B$ 是由全局几何形状和总电流决定的正常数。将 $\\mathbf{J}_s$ 解释为表面电流密度，将 $B_t$ 解释为理想电导体（PEC）边界外侧的切向磁场。\n\n使用这些渐近行为，回答以下问题：\n\n- 推导拐角附近局部表面力密度 $\\mathbf{f}_s(r) = \\mathbf{J}_s(r) \\times \\mathbf{B}_t(r)$ 的主阶标度关系，并评估在拐角周围大小为 $R$ 的邻域内力密度的可积性。具体来说，分析积分 $\\int_{0}^{R} \\lVert \\mathbf{f}_s(r) \\rVert \\, \\mathrm{d}r$ 的行为，并说明当积分下限趋于 $0$ 时它是否收敛。\n\n- 解释为什么在使用基于边的基函数的有限元法（FEM）中，拐角附近的逐点场表示会导致 $\\lVert \\mathbf{J} \\times \\mathbf{B} \\rVert$ 出现依赖于网格的尖峰，并讨论通过在一个包围导体并与边界保持有限距离的光滑表面上对 Maxwell 应力张量进行积分所计算出的总线圈力是否预期是有界的和与网格无关的。\n\n- 考虑在存在几何奇异性的情况下，可用于计算聚变线圈力以获得稳健结果的补救措施。选择所有正确的陈述。\n\n选项：\nA. 因为 $\\lVert \\mathbf{f}_s(r) \\rVert$ 的标度关系类似于 $r^{-1}$，所以在任何包含拐角且未经正则化的邻域上对局部力密度进行积分会呈对数发散，因此拐角处的逐点或单元局部力是不收敛的；通过在一个与导体保持有限距离的光滑表面上对 Maxwell 应力张量进行积分来评估总力，会得到一个有界的、与网格无关的结果。\n\nB. 使用 Nédélec 边元，它们所强制的切向连续性消除了几何奇异性，因此拐角处的逐点力密度 $\\lVert \\mathbf{J} \\times \\mathbf{B} \\rVert$ 会随着网格细化而收敛。\n\nC. 从基于边的（Nédélec）单元切换到基于节点的（Lagrange）单元可以消除拐角奇异性，并确保 $\\lVert \\mathbf{J} \\times \\mathbf{B} \\rVert$ 的收敛。\n\nD. 通过与宽度等于制造或测量的拐角半径 $r_c$ 的核进行卷积来引入具有物理动机的场平滑，或使用子网格模型将尖锐拐角替换为半径为 $r_c$ 的圆角，可以产生有界的、与网格无关的计算力密度和总力，与物理现实一致。\n\nE. 仅使用导体内部的局部体积公式 $\\mathbf{f} = \\mathbf{J} \\times \\mathbf{B}$ 来计算线圈力总是优于 Maxwell 应力方法，因为它避免了在具有奇异场的区域上进行积分，从而保证了与网格无关的结果。\n\n选择所有正确的选项。",
            "solution": "在进行求解之前，对问题陈述进行严格验证。\n\n### 第 1 步：提取已知条件\n\n-   **模型**：一个薄载流导体的二维横截面，被建模为具有尖锐、零半径拐角的理想电导体（PEC）。\n-   **物理背景**：准静态条件下的静磁学。\n-   **控制方程**：$\\nabla \\times \\mathbf{B} = \\mu_0 \\mathbf{J}$，$\\nabla \\cdot \\mathbf{B} = 0$。\n-   **力密度**：Lorentz 力密度 $\\mathbf{f} = \\mathbf{J} \\times \\mathbf{B}$。\n-   **数值方法**：有限元法（FEM），磁矢量势采用第一类 Nédélec 边基函数。\n-   **渐近行为**：在拐角附近，沿边界弧坐标 $r$：\n    -   表面电流密度 $J_s(r) \\sim C_J r^{-1/2}$，其中 $C_J  0$。\n    -   切向磁场（外部）$B_t(r) \\sim C_B r^{-1/2}$，其中 $C_B  0$。\n-   **关注量**：\n    -   局部表面力密度 $\\mathbf{f}_s(r) = \\mathbf{J}_s(r) \\times \\mathbf{B}_t(r)$。\n    -   $\\int_{0}^{R} \\lVert \\mathbf{f}_s(r) \\rVert \\, \\mathrm{d}r$ 的可积性。\n    -   FEM 中 $\\lVert \\mathbf{J} \\times \\mathbf{B} \\rVert$ 的网格依赖性。\n    -   通过 Maxwell 应力张量积分得到的总力的网格依赖性。\n    -   计算力时的补救措施。\n\n### 第 2 步：使用提取的已知条件进行验证\n\n-   **科学依据**：该问题牢固地植根于经典电磁学（静磁学）和计算电磁学。所给的 Maxwell 控制方程、Lorentz 力定律和理想电导体（PEC）模型都是标准内容。对此类问题使用带有 Nédélec 单元的有限元法（FEM）是一种先进技术。所述的尖锐边缘附近场的渐近行为（$r^{-1/2}$ 奇异性）是带拐角域中椭圆偏微分方程理论的一个著名结果，对应于外角为 $2\\pi$ 的拐角（“刀刃”）。该问题在科学上是合理的。\n-   **适定性**：该问题提供了分析力密度标度关系及其可积性所需的所有信息。提出的问题是精确的，可以通过基于已知条件的逻辑推导来回答。该问题是自洽且适定的。\n-   **客观性**：问题以精确、客观和技术性的语言陈述，没有歧义或主观论断。\n\n### 第 3 步：结论与行动\n\n问题陈述有效。它描述了计算工程物理学中的一个经典且实际的问题。将推导完整的解决方案。\n\n### 推导与分析\n\n**第 1 部分：局部力标度关系与可积性**\n\n问题要求局部表面力密度 $\\mathbf{f}_s(r) = \\mathbf{J}_s(r) \\times \\mathbf{B}_t(r)$ 的标度关系。电流 $\\mathbf{J}_s(r)$ 是平面外的。我们可以调整坐标系，使得 $\\mathbf{J}_s(r) = J_s(r) \\hat{\\mathbf{z}}$。切向磁场 $\\mathbf{B}_t(r)$ 位于 $xy$ 平面内，与导体边界相切。因此，$\\mathbf{J}_s(r)$ 处处垂直于 $\\mathbf{B}_t(r)$。\n\n表面力密度的大小由下式给出\n$$ \\lVert \\mathbf{f}_s(r) \\rVert = \\lVert \\mathbf{J}_s(r) \\times \\mathbf{B}_t(r) \\rVert = J_s(r) B_t(r) \\sin(\\pi/2) = J_s(r) B_t(r) $$\n使用给定的 $r \\to 0$ 时的渐近行为：\n$$ \\lVert \\mathbf{f}_s(r) \\rVert \\sim (C_J r^{-1/2}) (C_B r^{-1/2}) = C_J C_B r^{-1} $$\n局部表面力密度的大小在尖锐拐角附近按 $r^{-1}$ 标度。\n\n接下来，我们评估该力密度在拐角（$r=0$ 处）周围大小为 $R$ 的邻域内的可积性。我们考察力大小的积分：\n$$ F_{local} = \\int_{0}^{R} \\lVert \\mathbf{f}_s(r) \\rVert \\, \\mathrm{d}r $$\n由于 $r^{-1}$ 的标度关系，该积分的行为类似于：\n$$ \\int_{\\epsilon}^{R} \\frac{C}{r} \\, \\mathrm{d}r = C [\\ln(r)]_{\\epsilon}^{R} = C (\\ln(R) - \\ln(\\epsilon)) $$\n其中 $C = C_J C_B$。当积分下限 $\\epsilon$ 趋近于 $0$ 时，$\\ln(\\epsilon) \\to -\\infty$。因此，该积分发散。这是一种对数发散。\n这意味着，在零半径拐角的理想化模型中，作用在包含该拐角的任何有限长度导体上的总力是无穷大的。\n\n**第 2 部分：有限元法行为与 Maxwell 应力张量**\n\n在数值有限元法的背景下，基函数（包括 Nédélec 单元）在每个单元内是固定的低阶多项式。这类函数是光滑的，无法再现场 $\\mathbf{B}$ 和 $\\mathbf{J}$ 的奇异 $r^{-1/2}$ 行为。有限元解试图逼近这种奇异性。随着拐角附近网格的细化，单元尺寸减小。为了逼近一个迅速增长到无穷大的函数，拐角附近小单元中基函数的系数必须变得越来越大。这导致计算出的 $\\mathbf{J}$ 和 $\\mathbf{B}$ 的逐点值呈现出巨大的、依赖于网格的尖峰，且不收敛于一个有限值。因此，逐点乘积 $\\lVert \\mathbf{J} \\times \\mathbf{B} \\rVert$ 也将是不收敛的，并随着网格细化而增长。\n\n载流体上的总电磁力可以通过在任何包围该物体的封闭表面 $S$ 上对 Maxwell 应力张量 $\\mathbf{T}$ 进行积分来计算：\n$$ \\mathbf{F} = \\oint_S \\mathbf{T} \\cdot d\\mathbf{a} $$\n其中 $\\mathbf{T}_{ij} = \\frac{1}{\\mu_0}(B_i B_j - \\frac{1}{2} \\delta_{ij} B^2)$。这是一个强大的恒等式。如果我们选择积分表面 $S$ 是光滑的，并且与导体保持有限距离，那么我们就是在场是光滑且行为良好的区域内评估积分。对于像静磁学这样的椭圆问题，有限元解在远离奇异点的区域收敛得很好。因此，在这个远离奇异点的表面 $S$ 上计算出的磁场 $\\mathbf{B}$ 将随着网格细化而收敛。结果是，在 $S$ 上对 Maxwell 应力张量的积分将收敛到一个明确定义的、有界的、与网格无关的总力。这种方法有效地绕过了局部的、不可积的奇异性。\n\n### 逐项分析\n\n**A. 因为 $\\lVert \\mathbf{f}_s(r) \\rVert$ 的标度关系类似于 $r^{-1}$，所以在任何包含拐角且未经正则化的邻域上对局部力密度进行积分会呈对数发散，因此拐角处的逐点或单元局部力是不收敛的；通过在一个与导体保持有限距离的光滑表面上对 Maxwell 应力张量进行积分来评估总力，会得到一个有界的、与网格无关的结果。**\n该陈述是对分析的完整而准确的总结。力密度的标度关系为 $r^{-1}$，其积分呈对数发散，局部力在数值上不收敛。它正确地指出，在远离奇异性的表面上应用 Maxwell 应力张量方法，可以为总力提供一个稳健的、与网格收敛的值。\n**结论：正确。**\n\n**B. 使用 Nédélec 边元，它们所强制的切向连续性消除了几何奇异性，因此拐角处的逐点力密度 $\\lVert \\mathbf{J} \\times \\mathbf{B} \\rVert$ 会随着网格细化而收敛。**\n这是不正确的。Nédélec 单元旨在正确表示电磁场的函数空间（例如，确保 $\\mathbf{A}$ 或 $\\mathbf{E}$ 的切向连续性），这对于物理一致性至关重要（例如，$\\nabla \\cdot \\mathbf{B} = 0$）。然而，它们仍然是基于多项式的，无法消除或精确表示控制偏微分方程真实解中存在的奇异性。奇异性是给定几何形状下连续问题的属性，而不是数值伪影。因此，奇异点处的逐点值不会收敛。\n**结论：不正确。**\n\n**C. 从基于边的（Nédélec）单元切换到基于节点的（Lagrange）单元可以消除拐角奇异性，并确保 $\\lVert \\mathbf{J} \\times \\mathbf{B} \\rVert$ 的收敛。**\n这是不正确的。Lagrange 单元也是基于多项式的，在表示奇异函数时面临同样的基本限制。切换多项式基函数的类型不会改变底层解析解的奇异性质。此外，对于电磁学中的矢量场问题，节点单元通常不如边单元适用，因为它们可能引入其他困难，例如无法正确强制无散度条件。奇异性没有被消除，收敛性也无法实现。\n**结论：不正确。**\n\n**D. 通过与宽度等于制造或测量的拐角半径 $r_c$ 的核进行卷积来引入具有物理动机的场平滑，或使用子网格模型将尖锐拐角替换为半径为 $r_c$ 的圆角，可以产生有界的、与网格无关的计算力密度和总力，与物理现实一致。**\n该陈述描述了标准的且具有物理合理性的正则化技术。“零半径”拐角是一种不符合物理现实的理想化。现实世界中的导体具有有限的拐角半径 $r_c$。修改几何形状以包含半径为 $r_c$ 的圆角可以消除数学上的奇异性。这个修改后的、符合物理现实的问题的解是光滑且有界的。然后，有限元法可以计算出局部力和总力的收敛解。或者，场卷积或使用子网格模型等后处理技术可以达到类似的正则化效果。这些方法对于获得具有物理意义和数值稳定性（与网格无关）的结果至关重要。\n**结论：正确。**\n\n**E. 仅使用导体内部的局部体积公式 $\\mathbf{f} = \\mathbf{J} \\times \\mathbf{B}$ 来计算线圈力总是优于 Maxwell 应力方法，因为它避免了在具有奇异场的区域上进行积分，从而保证了与网格无关的结果。**\n这个陈述在事实上是颠倒的。局部公式 $\\mathbf{f} = \\mathbf{J} \\times \\mathbf{B}$ 需要评估导体*内部*直到其边界的场。正是这种方法直接面对奇异性，导致局部力和（如果天真地积分）总力的结果不收敛且依赖于网格。Maxwell 应力张量方法才是通过在光滑区域选择积分路径来*避免*奇异场区域的方法。因此，该陈述的推理和结论都是错误的。\n**结论：不正确。**",
            "answer": "$$\\boxed{AD}$$"
        },
        {
            "introduction": "电磁力计算的最终目标之一是指导和优化线圈设计，而不仅仅是分析现有设计。本综合实践将带您从分析转向综合，要求您构建一个优化问题，以最小化线圈中的峰值洛伦兹力，同时满足特定的磁场性能约束。此练习的核心是引入并应用伴随方法来高效计算目标函数相对于大量设计变量（线圈电流）的梯度。掌握伴随法是解决大规模工程设计优化问题的关键技能，它将物理仿真与自动化设计流程紧密地联系在一起。",
            "id": "3970528",
            "problem": "要求您为与计算聚变科学与工程中电磁线圈力计算相关的优化问题，建立并验证一种基于伴随的梯度计算方法。考虑一个线圈系统，其被离散化为 $M$ 个几何形状固定的直导体段，电流 $\\{I_m\\}_{m=1}^M$ 未知。每个导体段 $m$ 的中心位置为 $\\mathbf{x}_m \\in \\mathbb{R}^3$，方向由单位向量 $\\hat{\\mathbf{s}}_m$ 给出，长度为 $L_m$，截面积为 $A_m$。由于线圈段的存在，在一组 $K$ 个目标点 $\\{\\mathbf{x}_k\\}_{k=1}^K$ 处的静磁场由毕奥-萨伐尔定律给出，其连续形式是一条基本定律：\n$$\n\\mathbf{B}(\\mathbf{x}) \\;=\\; \\frac{\\mu_0}{4\\pi} \\int \\frac{I\\, d\\boldsymbol{\\ell} \\times (\\mathbf{x}-\\mathbf{r})}{\\|\\mathbf{x}-\\mathbf{r}\\|^3} \\, ,\n$$\n其中 $\\mu_0$ 是自由空间磁导率。在使用 $N_q$ 个求积节点对每个直导体段进行离散化后，目标点处的法向分量（此处选择 $z$ 分量）是电流的线性函数，由矩阵 $\\mathbf{G} \\in \\mathbb{R}^{K\\times M}$ 描述：\n$$\n\\mathbf{b}(\\mathbf{I}) \\;=\\; \\mathbf{G}\\,\\mathbf{I} \\, ,\n$$\n其中 $\\mathbf{I} = [I_1,\\dots,I_M]^T$ 且 $\\mathbf{b}(\\mathbf{I}) \\in \\mathbb{R}^K$ 汇集了 $K$ 个目标点处的 $z$ 分量。场性能约束是一个等式 $\\mathbf{G}\\,\\mathbf{I} = \\mathbf{b}_{\\mathrm{target}}$。\n\n由于给定的背景磁场 $\\mathbf{B}_{\\mathrm{back}}(\\mathbf{x})$（例如，环形背景场及其空间变化），每个导体段都会受到洛伦兹力密度。局部洛伦兹力密度的基本表达式为\n$$\n\\mathbf{f}(\\mathbf{x}) \\;=\\; \\mathbf{J}(\\mathbf{x}) \\times \\mathbf{B}(\\mathbf{x}) \\, .\n$$\n通过带有平滑的 $\\ell_q$-范数来近似沿导体段的峰值，为导体段 $m$ 定义平滑后的局部大小\n$$\nf_m(\\mathbf{I}) \\;=\\; \\frac{\\sqrt{I_m^2 + \\varepsilon^2}}{A_m}\\,\\big\\| \\hat{\\mathbf{s}}_m \\times \\mathbf{B}_{\\mathrm{back}}(\\mathbf{x}_m)\\big\\| \\, ,\n$$\n其中平滑参数 $\\varepsilon  0$。峰值代理目标是 $\\ell_q$ 范数\n$$\nF_q(\\mathbf{I}) \\;=\\; \\left( \\sum_{m=1}^M \\left[ f_m(\\mathbf{I}) \\right]^q \\right)^{1/q} \\, ,\n$$\n对于某个 $q \\ge 2$。为了在保持计算易处理性的同时强制执行场性能约束，考虑使用权重为 $\\mu  0$ 的二次惩罚公式：\n$$\nJ_{\\mu}(\\mathbf{I}) \\;=\\; F_q(\\mathbf{I}) \\;+\\; \\frac{\\mu}{2}\\,\\left\\| \\mathbf{G}\\,\\mathbf{I} - \\mathbf{b}_{\\mathrm{target}} \\right\\|_2^2 \\, .\n$$\n\n您的任务是：\n$1.$ 仅从上述基本定律（毕奥-萨伐尔定律和洛伦兹力密度）出发，使用伴随方法的观点推导 $J_{\\mu}(\\mathbf{I})$ 相对于 $\\mathbf{I}$ 的梯度。清晰地引入一个伴随变量，并展示如何在不显式对前向映射进行超出初等线性代数运算的微分的情况下，构建该梯度。\n\n$2.$ 实现一个程序，该程序\n$2.1.$ 通过将每个直导体段离散化为 $N_q$ 个均匀求积节点，并计算每个目标点处由毕奥-萨伐尔积分得到的 $z$ 分量，来数值化构建 $\\mathbf{G}$（假设自由空间磁导率 $\\mu_0 = 4\\pi \\times 10^{-7}$ H/m）。\n$2.2.$ 将背景场 $\\mathbf{B}_{\\mathrm{back}}(\\mathbf{x})$ 定义为\n$$\n\\mathbf{B}_{\\mathrm{back}}(x,y,z) \\;=\\; \\begin{bmatrix} 0.10\\,z \\\\ 0 \\\\ 1.50 \\;+\\; 0.05\\,x \\end{bmatrix} \\quad \\text{单位：特斯拉} \\, ,\n$$\n并在每个导体段中心评估该场以计算 $\\big\\|\\hat{\\mathbf{s}}_m \\times \\mathbf{B}_{\\mathrm{back}}(\\mathbf{x}_m)\\big\\|$。\n$2.3.$ 使用以下固定的线圈几何形状和目标点：\n$M = 4$ 个直导体段，每个长度 $L_m = 0.40$ 米，中心位置为\n$$\n\\mathbf{x}_1 = [-0.30,\\, 0.00,\\, 0.00]^T,\\;\\; \\mathbf{x}_2 = [-0.10,\\, 0.00,\\, 0.00]^T,\\;\\; \\mathbf{x}_3 = [0.10,\\, 0.00,\\, 0.00]^T,\\;\\; \\mathbf{x}_4 = [0.30,\\, 0.00,\\, 0.00]^T \\, ,\n$$\n所有 $m$ 的方向均为 $\\hat{\\mathbf{s}}_m = [0,\\,1,\\,0]^T$，截面积为\n$$\nA_1 = 5.0\\times 10^{-4},\\;\\; A_2 = 4.0\\times 10^{-4},\\;\\; A_3 = 6.0\\times 10^{-4},\\;\\; A_4 = 5.0\\times 10^{-4} \\quad \\text{单位：} \\mathrm{m}^2 \\, 。\n$$\n设 $K = 2$ 个目标点为\n$$\n\\mathbf{x}_{\\mathrm{t},1} = [0.00,\\, 0.00,\\, 0.20]^T,\\qquad \\mathbf{x}_{\\mathrm{t},2} = [0.00,\\, 0.00,\\, 0.35]^T \\, 。\n$$\n将目标 $z$ 分量（单位：特斯拉）定义为\n$$\n\\mathbf{b}_{\\mathrm{target}} = \\begin{bmatrix} 1.0\\times 10^{-5} \\\\ -0.5\\times 10^{-5} \\end{bmatrix} \\, 。\n$$\n对毕奥-萨伐尔离散化，每个导体段使用 $N_q = 200$ 个求积节点。\n$2.4.$ 对每个测试用例，通过求解吉洪诺夫（Tikhonov）正则化最小二乘问题来构建一个基准电流向量 $\\mathbf{I}$\n$$\n\\mathbf{I}^\\star \\;=\\; \\arg\\min_{\\mathbf{I}} \\left\\| \\mathbf{G}\\,\\mathbf{I} - \\mathbf{b}_{\\mathrm{target}} \\right\\|_2^2 \\;+\\; \\alpha \\left\\| \\mathbf{I} \\right\\|_2^2 \\, ,\n$$\n其中 $\\alpha = 1.0\\times 10^{-6}$，并使用此 $\\mathbf{I}^\\star$ 来评估梯度。\n$2.5.$ 计算您在任务1中推导的基于伴随的梯度 $\\nabla J_{\\mu}(\\mathbf{I}^\\star)$，并使用中心有限差分近似对其进行验证，步长为 $h$：\n$$\n\\left[\\nabla J_{\\mu}(\\mathbf{I}^\\star)\\right]_m \\;\\approx\\; \\frac{J_{\\mu}(\\mathbf{I}^\\star + h\\,\\mathbf{e}_m) - J_{\\mu}(\\mathbf{I}^\\star - h\\,\\mathbf{e}_m)}{2h} \\, ,\n$$\n其中 $\\{\\mathbf{e}_m\\}$ 是标准基。\n$2.6.$ 对每个测试用例，报告相对梯度误差\n$$\n\\mathrm{err} \\;=\\; \\frac{\\left\\|\\nabla J_{\\mu}^{\\mathrm{adj}} - \\nabla J_{\\mu}^{\\mathrm{FD}}\\right\\|_2}{\\max\\left(1, \\left\\|\\nabla J_{\\mu}^{\\mathrm{FD}}\\right\\|_2\\right)} \\, ,\n$$\n该误差是无量纲的。将所有报告的输出表示为不带单位的纯数字。\n\n测试套件。精确运行以下三个测试用例，每个用例由 $(q,\\mu,\\varepsilon,h)$ 指定：\n$1.$ $(4,\\, 5.0,\\, 1.0\\times 10^{-6},\\, 1.0\\times 10^{-7})$。\n$2.$ $(8,\\, 1.0,\\, 1.0\\times 10^{-8},\\, 5.0\\times 10^{-8})$。\n$3.$ $(16,\\, 0.5,\\, 1.0\\times 10^{-10},\\, 2.0\\times 10^{-8})$。\n\n最终输出格式。您的程序应生成一行输出，其中包含三个测试用例的相对梯度误差，按测试用例的顺序排列，形式为逗号分隔的列表，并用方括号括起来，例如 $[\\mathrm{err}_1,\\mathrm{err}_2,\\mathrm{err}_3]$。输出是无量纲的实数。",
            "solution": "该问题要求对一个与聚变科学中电磁线圈设计相关的特定优化泛函 $J_{\\mu}(\\mathbf{I})$，推导并实现一种基于伴随的梯度计算方法。推导必须源于所提供的基本物理定律，并且实现必须通过与有限差分近似的对比进行验证。\n\n首先，使用伴随方法公式推导梯度 $\\nabla_{\\mathbf{I}} J_{\\mu}(\\mathbf{I})$。目标泛函为：\n$$\nJ_{\\mu}(\\mathbf{I}) = F_q(\\mathbf{I}) + \\frac{\\mu}{2}\\,\\left\\| \\mathbf{G}\\,\\mathbf{I} - \\mathbf{b}_{\\mathrm{target}} \\right\\|_2^2\n$$\n该泛函由两项组成。第一项 $F_q(\\mathbf{I})$ 直接依赖于优化变量（电流 $\\mathbf{I}$）。第二项是一个二次惩罚项，它通过一个线性的“前向映射” $\\mathbf{b}(\\mathbf{I}) = \\mathbf{G}\\mathbf{I}$ 依赖于 $\\mathbf{I}$，该映射代表离散化的毕奥-萨伐尔定律。$J_{\\mu}$ 的梯度是这两项梯度之和。\n\n我们首先从伴随的角度分析惩罚项。我们可以将泛函的这一部分写成 $P(\\mathbf{b}(\\mathbf{I}))$，其中状态变量为 $\\mathbf{b} \\in \\mathbb{R}^K$，目标部分为 $P(\\mathbf{b}) = \\frac{\\mu}{2}\\|\\mathbf{b} - \\mathbf{b}_{\\mathrm{target}}\\|_2^2$。将控制变量 $\\mathbf{I}$ 映射到状态变量 $\\mathbf{b}$ 的前向算子是 $\\mathbf{b}(\\mathbf{I}) = \\mathbf{G}\\mathbf{I}$。\n\n$P$ 相对于 $\\mathbf{I}$ 的全导数由链式法则给出：\n$$\n\\nabla_{\\mathbf{I}} P = \\left(\\frac{d\\mathbf{b}}{d\\mathbf{I}}\\right)^T \\frac{\\partial P}{\\partial \\mathbf{b}}\n$$\n项 $\\frac{d\\mathbf{b}}{d\\mathbf{I}}$ 是前向映射的雅可比矩阵，即矩阵 $\\mathbf{G}$。项 $\\frac{\\partial P}{\\partial \\mathbf{b}}$ 是目标函数相对于状态的梯度。在伴随方法的背景下，此项被定义为伴随变量 $\\boldsymbol{\\lambda}$。\n$$\n\\boldsymbol{\\lambda} \\equiv \\frac{\\partial P}{\\partial \\mathbf{b}} = \\nabla_{\\mathbf{b}} \\left( \\frac{\\mu}{2} (\\mathbf{b} - \\mathbf{b}_{\\mathrm{target}})^T (\\mathbf{b} - \\mathbf{b}_{\\mathrm{target}}) \\right) = \\mu (\\mathbf{b} - \\mathbf{b}_{\\mathrm{target}})\n$$\n代入 $\\mathbf{b}=\\mathbf{G}\\mathbf{I}$，伴随变量在前向求解后计算得出：\n$$\n\\boldsymbol{\\lambda} = \\mu (\\mathbf{G}\\mathbf{I} - \\mathbf{b}_{\\mathrm{target}})\n$$\n然后，通过将伴随变量与前向映射雅可比矩阵的转置相乘，来构建惩罚项相对于 $\\mathbf{I}$ 的梯度：\n$$\n\\nabla_{\\mathbf{I}} \\left( \\frac{\\mu}{2}\\,\\left\\| \\mathbf{G}\\,\\mathbf{I} - \\mathbf{b}_{\\mathrm{target}} \\right\\|_2^2 \\right) = \\mathbf{G}^T \\boldsymbol{\\lambda} = \\mu \\mathbf{G}^T (\\mathbf{G}\\mathbf{I} - \\mathbf{b}_{\\mathrm{target}})\n$$\n此公式展示了伴随方法的核心思想：导数对扰动 $\\delta\\mathbf{I}$ 的作用通过首先计算状态扰动 $\\delta\\mathbf{b} = \\mathbf{G}\\delta\\mathbf{I}$，然后与伴随变量 $\\boldsymbol{\\lambda}$（该变量编码了目标对状态的敏感度）进行内积来评估。这转置为 $\\delta\\mathbf{I}^T (\\mathbf{G}^T \\boldsymbol{\\lambda})$ 以找到相对于 $\\mathbf{I}$ 的梯度。\n\n接下来，我们处理第一项 $F_q(\\mathbf{I})$，其定义为：\n$$\nF_q(\\mathbf{I}) = \\left( \\sum_{m=1}^M \\left[ f_m(\\mathbf{I}) \\right]^q \\right)^{1/q}\n$$\n由于每个 $f_m(\\mathbf{I})$ 仅依赖于相应的电流分量 $I_m$，其梯度可以通过应用链式法则直接计算。梯度 $\\nabla_{\\mathbf{I}} F_q(\\mathbf{I})$ 的第 $j$ 个分量是：\n$$\n\\frac{\\partial F_q}{\\partial I_j} = \\frac{1}{q} \\left( \\sum_{m=1}^M [f_m]^q \\right)^{\\frac{1}{q}-1} \\cdot q [f_j]^{q-1} \\frac{\\partial f_j}{\\partial I_j} = \\left( F_q(\\mathbf{I}) \\right)^{1-q} [f_j(\\mathbf{I})]^{q-1} \\frac{d f_j}{d I_j}\n$$\n导体段 $m$ 的力大小代理 $f_m$ 为：\n$$\nf_m(\\mathbf{I}) = \\frac{\\sqrt{I_m^2 + \\varepsilon^2}}{A_m}\\,\\big\\| \\hat{\\mathbf{s}}_m \\times \\mathbf{B}_{\\mathrm{back}}(\\mathbf{x}_m)\\big\\|\n$$\n其相对于 $I_m$ 的导数为：\n$$\n\\frac{d f_m}{d I_m} = \\frac{I_m}{\\sqrt{I_m^2 + \\varepsilon^2}} \\frac{\\big\\| \\hat{\\mathbf{s}}_m \\times \\mathbf{B}_{\\mathrm{back}}(\\mathbf{x}_m)\\big\\|}{A_m}\n$$\n结合这些结果，$F_q$ 梯度的第 $j$ 个分量是：\n$$\n[\\nabla_{\\mathbf{I}} F_q(\\mathbf{I})]_j = \\left( F_q(\\mathbf{I}) \\right)^{1-q} [f_j(\\mathbf{I})]^{q-1} \\frac{I_j}{\\sqrt{I_j^2 + \\varepsilon^2}} \\frac{\\|\\hat{\\mathbf{s}}_j \\times \\mathbf{B}_{\\mathrm{back}}(\\mathbf{x}_j)\\|}{A_j}\n$$\n\n最后，目标泛函 $J_{\\mu}(\\mathbf{I})$ 的完整梯度是其两部分梯度之和：\n$$\n\\nabla_{\\mathbf{I}} J_{\\mu}(\\mathbf{I}) = \\nabla_{\\mathbf{I}} F_q(\\mathbf{I}) + \\mu \\mathbf{G}^T (\\mathbf{G}\\mathbf{I} - \\mathbf{b}_{\\mathrm{target}})\n$$\n这就是基于伴随的梯度的解析表达式。\n\n实现计划如下：\n$1.$ 响应矩阵 $\\mathbf{G} \\in \\mathbb{R}^{K \\times M}$ 是数值构建的。每个元素 $G_{km}$ 是由单位电流的导体段 $m$ 在目标点 $\\mathbf{x}_{\\mathrm{t},k}$ 处产生的磁场的 $z$ 分量。这是通过使用 $N_q=200$ 个求积点离散化直导体段的毕奥-萨伐尔积分来计算的。对于 $\\mathbf{r}(t) = \\mathbf{x}_m + t\\hat{\\mathbf{s}}_m$（其中 $t \\in [-L_m/2, L_m/2]$）和 $\\Delta t = L_m/N_q$，公式为：\n$$\nG_{km} = \\frac{\\mu_0}{4\\pi} \\sum_{i_q=0}^{N_q-1} \\left[ \\frac{\\hat{\\mathbf{s}}_m \\times (\\mathbf{x}_{\\mathrm{t},k} - \\mathbf{r}(t_{i_q}))}{\\|\\mathbf{x}_{\\mathrm{t},k} - \\mathbf{r}(t_{i_q})\\|^3} \\right]_z \\Delta t\n$$\n其中 $t_{i_q}$ 是求积子区间的中点。\n$2.$ 通过求解吉洪诺夫（Tikhonov）正则化最小二乘问题 $\\min_{\\mathbf{I}} \\left\\| \\mathbf{G}\\,\\mathbf{I} - \\mathbf{b}_{\\mathrm{target}} \\right\\|_2^2 + \\alpha \\left\\| \\mathbf{I} \\right\\|_2^2$ 来确定基准电流向量 $\\mathbf{I}^\\star$。解通过正规方程组找到：$\\mathbf{I}^\\star = (\\mathbf{G}^T \\mathbf{G} + \\alpha \\mathbf{I}_{\\text{identity}})^{-1} \\mathbf{G}^T \\mathbf{b}_{\\mathrm{target}}$。\n$3.$ 使用推导出的公式计算伴随梯度 $\\nabla J_{\\mu}^{\\mathrm{adj}}(\\mathbf{I}^\\star)$。\n$4.$ 使用中心有限差分公式计算验证梯度 $\\nabla J_{\\mu}^{\\mathrm{FD}}(\\mathbf{I}^\\star)$，对每个分量 $m$：$[\\nabla J_{\\mu}^{\\mathrm{FD}}]_m = \\frac{J_{\\mu}(\\mathbf{I}^\\star + h\\mathbf{e}_m) - J_{\\mu}(\\mathbf{I}^\\star - h\\mathbf{e}_m)}{2h}$。\n$5.$ 两个梯度之间的相对误差计算为 $\\mathrm{err} = \\frac{\\|\\nabla J_{\\mu}^{\\mathrm{adj}} - \\nabla J_{\\mu}^{\\mathrm{FD}}\\|_2}{\\max(1, \\|\\nabla J_{\\mu}^{\\mathrm{FD}}\\|_2)}$。对每个测试用例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to derive and verify the adjoint-based gradient for the coil optimization problem.\n    \"\"\"\n    #\n    # Step 2.1  2.3: Define fixed geometry, targets, and constants\n    #\n    MU0 = 4 * np.pi * 1e-7  # Permeability of free space (H/m)\n    M = 4  # Number of coil segments\n    K = 2  # Number of target points\n    N_q = 200 # Number of quadrature nodes per segment\n    ALPHA = 1.0e-6 # Tikhonov regularization parameter\n\n    # Coil segment properties\n    L_m = 0.40  # Length of each segment (m)\n    centers = np.array([\n        [-0.30, 0.00, 0.00],\n        [-0.10, 0.00, 0.00],\n        [0.10, 0.00, 0.00],\n        [0.30, 0.00, 0.00]\n    ])\n    orientations = np.array([[0.0, 1.0, 0.0]] * M)\n    areas = np.array([5.0e-4, 4.0e-4, 6.0e-4, 5.0e-4]) # m^2\n\n    # Target point properties\n    target_points = np.array([\n        [0.00, 0.00, 0.20],\n        [0.00, 0.00, 0.35]\n    ])\n    b_target = np.array([1.0e-5, -0.5e-5]) # Tesla\n\n    #\n    # Helper function for background magnetic field\n    #\n    def B_back(p):\n        x, y, z = p\n        return np.array([0.10 * z, 0.0, 1.50 + 0.05 * x])\n\n    # Pre-compute constants for force calculation\n    C_m = np.array([\n        np.linalg.norm(np.cross(orientations[m], B_back(centers[m])))\n        for m in range(M)\n    ])\n\n    #\n    # Step 2.1: Construct the response matrix G\n    #\n    G = np.zeros((K, M))\n    dt = L_m / N_q\n    t_nodes = -L_m / 2 + (np.arange(N_q) + 0.5) * dt\n\n    for k in range(K):\n        for m in range(M):\n            g_km = 0.0\n            x_t = target_points[k]\n            x_m = centers[m]\n            s_m = orientations[m]\n            \n            for t in t_nodes:\n                r_line = x_m + t * s_m\n                R_vec = x_t - r_line\n                R_norm = np.linalg.norm(R_vec)\n                \n                integrand_vec = np.cross(s_m, R_vec) / (R_norm**3)\n                g_km += integrand_vec[2] # z-component\n\n            G[k, m] = (MU0 / (4 * np.pi)) * g_km * dt\n\n    #\n    # Step 2.4: Compute the baseline current vector I_star\n    #\n    G_T_G = G.T @ G\n    reg_matrix = G_T_G + ALPHA * np.identity(M)\n    rhs = G.T @ b_target\n    I_star = linalg.solve(reg_matrix, rhs, assume_a='sym')\n\n    #\n    # Define objective function and its gradient components\n    #\n    def compute_f_m(I, epsilon):\n        # Smoothed force magnitude proxy for each segment\n        return (np.sqrt(I**2 + epsilon**2) / areas) * C_m\n\n    def compute_F_q(I, q, epsilon):\n        # L_q norm of the force proxies\n        f_vals = compute_f_m(I, epsilon)\n        return np.sum(f_vals**q)**(1.0 / q)\n\n    def compute_J_mu(I, q, mu, epsilon):\n        # Full objective functional\n        F_q_val = compute_F_q(I, q, epsilon)\n        penalty = (mu / 2.0) * np.linalg.norm(G @ I - b_target)**2\n        return F_q_val + penalty\n\n    def compute_adjoint_gradient(I, q, mu, epsilon):\n        # Adjoint-based gradient\n        # Gradient of the penalty term\n        grad_penalty = mu * G.T @ (G @ I - b_target)\n\n        # Gradient of the force term F_q\n        f_vals = compute_f_m(I, epsilon)\n        F_q_val = np.sum(f_vals**q)**(1.0 / q)\n        \n        df_dI = (I / np.sqrt(I**2 + epsilon**2)) * (C_m / areas)\n        \n        # Handle case where F_q is very close to zero\n        if F_q_val  1e-16:\n             grad_Fq = np.zeros_like(I)\n        else:\n            grad_Fq = (F_q_val**(1 - q)) * (f_vals**(q - 1)) * df_dI\n\n        return grad_Fq + grad_penalty\n\n    def compute_fd_gradient(I, q, mu, epsilon, h):\n        # Central finite-difference gradient for verification\n        grad_fd = np.zeros(M)\n        for m in range(M):\n            I_plus = I.copy()\n            I_plus[m] += h\n            I_minus = I.copy()\n            I_minus[m] -= h\n\n            J_plus = compute_J_mu(I_plus, q, mu, epsilon)\n            J_minus = compute_J_mu(I_minus, q, mu, epsilon)\n            \n            grad_fd[m] = (J_plus - J_minus) / (2.0 * h)\n        return grad_fd\n\n    #\n    # Test suite execution\n    #\n    test_cases = [\n        (4, 5.0, 1.0e-6, 1.0e-7),\n        (8, 1.0, 1.0e-8, 5.0e-8),\n        (16, 0.5, 1.0e-10, 2.0e-8),\n    ]\n\n    results = []\n    for q, mu, epsilon, h in test_cases:\n        # Step 2.5: Compute gradients\n        grad_adj = compute_adjoint_gradient(I_star, q, mu, epsilon)\n        grad_fd = compute_fd_gradient(I_star, q, mu, epsilon, h)\n\n        # Step 2.6: Compute relative error\n        norm_fd = np.linalg.norm(grad_fd)\n        norm_diff = np.linalg.norm(grad_adj - grad_fd)\n        \n        err = norm_diff / max(1.0, norm_fd)\n        results.append(err)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}