{
    "hands_on_practices": [
        {
            "introduction": "The first step in mastering computational electromagnetics is to translate fundamental physical laws into robust numerical code. This practice focuses on the direct implementation of the Biot-Savart law for magnetic fields and the Lorentz force law for calculating interactions between currents. You will develop a program to compute the field from a current loop, tackling the critical numerical challenge of integrating a near-singular function by implementing an adaptive quadrature scheme . This exercise builds a foundational skill set in scientific computing, emphasizing the importance of numerical stability and accuracy when dealing with idealized physical models.",
            "id": "3970518",
            "problem": "A single, perfectly conducting, circular filamentary coil with radius $a$ carrying steady current $I$ is centered at the origin and lies in the plane $z=0$. The magnetic field at an observation point $\\mathbf{r}$ due to this coil is defined by the Biot–Savart law, which states that for a current distribution confined to a one-dimensional curve, the magnetic field is given by an integral of the form\n$$\n\\mathbf{B}(\\mathbf{r}) = \\frac{\\mu_0}{4\\pi}\\int_{\\mathcal{C}} \\frac{I\\,d\\boldsymbol{\\ell}\\times\\mathbf{\\hat{R}}}{R^2},\n$$\nwhere $\\mu_0$ is the magnetic permeability of free space, $d\\boldsymbol{\\ell}$ is the differential line element along the coil centerline $\\mathcal{C}$, $\\mathbf{R}=\\mathbf{r}-\\boldsymbol{\\ell}$ is the vector from a source point on the coil to the observation point, $R=\\|\\mathbf{R}\\|$, and $\\mathbf{\\hat{R}}=\\mathbf{R}/R$.\n\nIn addition to the magnetic field, consider a second circular filamentary coil with the same radius $a$ and current $I_2$, coaxial with the first coil but displaced along the $z$-axis by an offset $z_2$. The Lorentz force on the second coil due to the magnetic field generated by the first coil is given by a line integral of the magnetic part of the Lorentz force,\n$$\n\\mathbf{F} = \\int_{\\mathcal{C}_2} I_2\\, d\\boldsymbol{\\ell}_2 \\times \\mathbf{B}_1(\\boldsymbol{\\ell}_2),\n$$\nwhere $\\mathbf{B}_1$ is the field generated by the first coil, and $d\\boldsymbol{\\ell}_2$ is the differential line element along the second coil $\\mathcal{C}_2$.\n\nStarting from these fundamental laws, write a complete, runnable program that:\n- Represents the circular coil centerline parametrically and evaluates $\\mathbf{B}(\\mathbf{r})$ at arbitrary points $\\mathbf{r}$ using numerically robust quadrature of the Biot–Savart integral.\n- Implements composite quadrature with panel-wise Gaussian rules, together with local panel refinement that triggers when the observation point is close to the coil, in order to accurately resolve near-singular behavior of the integrand.\n- Computes the net force $\\mathbf{F}$ on a second coil using the magnetic field due to the first coil and the magnetic part of the Lorentz force law.\n\nYour solution must treat angles in radians. All physical quantities must be expressed in International System of Units (SI). Specifically:\n- Express magnetic field vectors $\\mathbf{B}$ in Tesla.\n- Express force vectors $\\mathbf{F}$ in Newtons.\n\nDesign the quadrature so that it is numerically stable for observation points not located exactly on the coil centerline. In your solution narrative, explain, from first principles, how to construct a singularity-aware numerical quadrature for the case when the observation point approaches the coil, and outline how one would regularize or subtract singular behavior when the point lies on the coil.\n\nTest Suite:\nUse the following parameter sets and observation points. The coil radius is $a=0.5\\,\\mathrm{m}$ and the current in the source coil is $I_1=15000\\,\\mathrm{A}$ in all cases unless otherwise specified.\n\n1. Magnetic field at an on-axis point: $\\mathbf{r}=(0,0,0.1)\\,\\mathrm{m}$.\n2. Magnetic field at a near-wire off-axis point: $\\mathbf{r}=(0.49,0.0,0.0)\\,\\mathrm{m}$.\n3. Magnetic field at a far off-axis point: $\\mathbf{r}=(1.5,0.0,0.2)\\,\\mathrm{m}$.\n4. Net force on a second coaxial coil located at $z=z_2=0.05\\,\\mathrm{m}$ with current $I_2=12000\\,\\mathrm{A}$ and radius $a=0.5\\,\\mathrm{m}$, due to the first coil at $z=0$ with current $I_1=15000\\,\\mathrm{A}$.\n\nFor each of the first three cases, compute the magnetic field vector $\\mathbf{B}$ in Tesla. For the fourth case, compute the net force vector $\\mathbf{F}$ in Newtons. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry is a list of three floating-point numbers:\n$$ [[B_{x,1},B_{y,1},B_{z,1}], [B_{x,2},B_{y,2},B_{z,2}], [B_{x,3},B_{y,3},B_{z,3}], [F_x,F_y,F_z]] $$\nAll angles must be handled in radians. All physical quantities must be expressed in SI units. The numerical values must be returned as floating-point numbers. The final printout must contain only this single line with the nested list of results, without any additional explanatory text.",
            "solution": "The problem requires the numerical computation of the magnetic field $\\mathbf{B}$ generated by a circular filamentary current loop and the magnetic force $\\mathbf{F}$ between two coaxial loops. This is achieved by evaluating the Biot-Savart law and the Lorentz force law integrals using a robust numerical quadrature scheme. The core of the problem lies in handling the near-singular behavior of the Biot-Savart integrand when the observation point is close to the current-carrying wire.\n\n**1. Parametric Representation and Governing Equations**\n\nA circular filamentary coil of radius $a$ centered at the origin in the $z=0$ plane can be parameterized by an angle $\\phi \\in [0, 2\\pi]$. A source point $\\boldsymbol{\\ell}$ on the coil is given by:\n$$\n\\boldsymbol{\\ell}(\\phi) = (a \\cos\\phi, a \\sin\\phi, 0)\n$$\nThe differential line element $d\\boldsymbol{\\ell}$ is tangent to the coil and is found by differentiating $\\boldsymbol{\\ell}(\\phi)$ with respect to the parameter $\\phi$:\n$$\nd\\boldsymbol{\\ell} = \\frac{d\\boldsymbol{\\ell}}{d\\phi}d\\phi = (-a \\sin\\phi, a \\cos\\phi, 0) d\\phi\n$$\nThe Biot-Savart law gives the magnetic field $\\mathbf{B}$ at an observation point $\\mathbf{r}=(x, y, z)$ due to a steady current $I$ in the coil:\n$$\n\\mathbf{B}(\\mathbf{r}) = \\frac{\\mu_0 I}{4\\pi}\\int_{\\mathcal{C}} \\frac{d\\boldsymbol{\\ell} \\times \\mathbf{R}}{R^3}\n$$\nwhere $\\mathbf{R} = \\mathbf{r} - \\boldsymbol{\\ell}(\\phi)$ is the vector from the source point to the observation point, and $R = \\|\\mathbf{R}\\|$. Substituting the parametric forms, the integral becomes:\n$$\n\\mathbf{B}(\\mathbf{r}) = \\frac{\\mu_0 I}{4\\pi} \\int_0^{2\\pi} \\frac{(d\\boldsymbol{\\ell}/d\\phi) \\times (\\mathbf{r} - \\boldsymbol{\\ell}(\\phi))}{\\|\\mathbf{r} - \\boldsymbol{\\ell}(\\phi)\\|^3} d\\phi\n$$\nThis is a vector-valued definite integral over the parameter $\\phi$. The integrand is a function $\\mathbf{f}(\\phi) = (f_x(\\phi), f_y(\\phi), f_z(\\phi))$, and each component must be integrated numerically.\n\nThe Lorentz force on a second coil $\\mathcal{C}_2$ with current $I_2$ due to the field $\\mathbf{B}_1$ from the first coil is:\n$$\n\\mathbf{F} = I_2 \\int_{\\mathcal{C}_2} d\\boldsymbol{\\ell}_2 \\times \\mathbf{B}_1(\\boldsymbol{\\ell}_2)\n$$\nFor a coaxial setup, significant simplifications arise from axisymmetry, which will be discussed in Section 4.\n\n**2. Numerical Quadrature Strategy: Composite Gaussian Quadrature**\n\nThe integrals are computed using composite Gauss-Legendre quadrature. The integration domain $[0, 2\\pi]$ is divided into multiple smaller intervals, or panels. On each panel $[\\phi_a, \\phi_b]$, an $N_p$-point Gauss-Legendre quadrature rule is applied. This rule approximates the integral by a weighted sum:\n$$\n\\int_{\\phi_a}^{\\phi_b} f(\\phi) d\\phi \\approx \\frac{\\phi_b - \\phi_a}{2} \\sum_{i=1}^{N_p} w_i f\\left(\\frac{\\phi_b - \\phi_a}{2} \\xi_i + \\frac{\\phi_a + \\phi_b}{2}\\right)\n$$\nwhere $\\xi_i$ and $w_i$ are the standard Gauss-Legendre nodes and weights on the interval $[-1, 1]$. This method is highly accurate for smooth integrands.\n\n**3. Adaptive Refinement for Near-Singularities**\n\nThe primary numerical challenge is the behavior of the Biot-Savart integrand when the observation point $\\mathbf{r}$ is very close to the coil. The denominator $R^3 = \\|\\mathbf{r} - \\boldsymbol{\\ell}(\\phi)\\|^3$ approaches zero, causing the integrand to become sharply peaked. A uniform quadrature grid would require an extremely large number of points to resolve this peak accurately.\n\nTo overcome this, an adaptive mesh refinement strategy is employed. The refinement is based on a geometric criterion:\n1.  The azimuthal angle of the observation point in cylindrical coordinates, $\\phi_{obs} = \\operatorname{atan2}(y, x)$, corresponds to the point on the coil closest to the observation point's projection on the $xy$-plane.\n2.  The integration interval $[0, 2\\pi]$ is initially divided into a set of panels.\n3.  Each panel is checked for possible refinement. A panel $[\\phi_a, \\phi_b]$ is subdivided if it contains the region of closest approach and the minimum distance $R_{min}$ from $\\mathbf{r}$ to the coil segment within that panel is small compared to the panel's arc length, $a(\\phi_b - \\phi_a)$. A typical criterion is to subdivide if $R_{min} < C \\cdot a(\\phi_b - \\phi_a)$ for a chosen constant $C > 1$.\n4.  This process is applied recursively, creating a non-uniform mesh of panels that is very fine near $\\phi_{obs}$ and coarse elsewhere. This concentrates computational effort where the integrand varies most rapidly, ensuring both accuracy and efficiency.\n\n**4. Force Calculation via Symmetry**\n\nFor two coaxial coils, the force calculation can be greatly simplified. Let coil 1 be at $z=0$ and coil 2 be at $z=z_2$, both with radius $a$. The force is $\\mathbf{F} = I_2 \\int_0^{2\\pi} (d\\boldsymbol{\\ell}_2/d\\phi_2) \\times \\mathbf{B}_1(\\boldsymbol{\\ell}_2(\\phi_2)) d\\phi_2$.\n\nDue to axisymmetry, the magnetic field $\\mathbf{B}_1$ at any point $\\boldsymbol{\\ell}_2(\\phi_2) = (a \\cos\\phi_2, a \\sin\\phi_2, z_2)$ on the second coil has only a radial and an axial component in a cylindrical coordinate system aligned with the point. The magnitude of these components, $B_\\rho$ and $B_z$, is constant for all points on coil 2. The field vector in Cartesian coordinates is $\\mathbf{B}_1(\\phi_2) = (B_\\rho \\cos\\phi_2, B_\\rho \\sin\\phi_2, B_z)$, where $B_\\rho$ and $B_z$ can be found by computing the field at a single point, e.g., $(a, 0, z_2)$. At this point, $B_\\rho = B_x$.\n\nThe differential force element is $d\\mathbf{F} = I_2 (d\\boldsymbol{\\ell}_2/d\\phi_2) \\times \\mathbf{B}_1 d\\phi_2$. Performing the cross product and integrating over $\\phi_2 \\in [0, 2\\pi]$:\n$$\nd\\mathbf{F} = I_2 \\left( (a B_z \\cos\\phi_2)\\mathbf{\\hat{i}} + (a B_z \\sin\\phi_2)\\mathbf{\\hat{j}} - (a B_\\rho)\\mathbf{\\hat{k}} \\right) d\\phi_2\n$$\nThe integrals of the $\\cos\\phi_2$ and $\\sin\\phi_2$ terms over $[0, 2\\pi]$ are zero. Thus, the net transverse forces ($F_x, F_y$) are zero, as expected from symmetry. The net axial force is:\n$$\n\\mathbf{F} = \\int_0^{2\\pi} I_2 (-a B_\\rho) \\mathbf{\\hat{k}} d\\phi_2 = -2\\pi a I_2 B_\\rho \\mathbf{\\hat{k}}\n$$\nTherefore, the total force can be found by computing the magnetic field $\\mathbf{B}_1$ at just one point on the second coil, e.g., $\\mathbf{r} = (a, 0, z_2)$, taking its radial component ($B_x$ at this point), and applying the formula for $F_z$.\n\n**5. Regularization for On-Coil Singularities**\n\nThe problem requires an outline for handling the case where the observation point $\\mathbf{r}$ lies *exactly* on the filamentary coil. In this idealized model, the integral for $\\mathbf{B}$ diverges. This is an unphysical artifact of the zero-thickness assumption.\n\nTo obtain a physically meaningful result, one must regularize the integral. A common method is **singularity subtraction**. The procedure is as follows:\n1.  Identify the singular point $\\phi_0$ such that $\\boldsymbol{\\ell}(\\phi_0) = \\mathbf{r}$.\n2.  Approximate the integrand $f(\\phi)$ near $\\phi_0$ with a simpler function $f_{sing}(\\phi)$ that captures the same singular behavior but can be integrated analytically. For a curved wire, the local singular behavior is like that of an infinite straight wire tangent to the curve at $\\phi_0$.\n3.  Rewrite the integral as:\n    $$\n    \\int_0^{2\\pi} f(\\phi) d\\phi = \\int_0^{2\\pi} (f(\\phi) - f_{sing}(\\phi)) d\\phi + \\int_0^{2\\pi} f_{sing}(\\phi) d\\phi\n    $$\n4.  The first term, the \"regularized integral,\" has its singularity canceled. The integrand is now well-behaved and can be computed accurately with numerical quadrature.\n5.  The second term, the \"singular part,\" is evaluated analytically. The sum of these two parts gives the regularized value of the field, which corresponds to a physical model (e.g., the field at the center of a wire of finite radius).\nThis approach separates the problematic part of the integral for analytical treatment, leaving a well-behaved numerical problem.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\n\n# Physical constants\nMU_0 = 4 * np.pi * 1.0e-7  # Magnetic permeability of free space (T*m/A)\n\ndef _gauss_legendre_quad(func, panel, n_points, func_args):\n    \"\"\"\n    Performs N-point Gauss-Legendre quadrature on a single panel.\n    \n    Args:\n        func: The vector-valued function to integrate.\n        panel: A tuple (a, b) defining the integration interval.\n        n_points: The number of Gaussian points to use.\n        func_args: A tuple of additional arguments to pass to func.\n\n    Returns:\n        np.ndarray: The result of the vector integration.\n    \"\"\"\n    a, b = panel\n    nodes, weights = roots_legendre(n_points)\n    \n    # Map nodes from [-1, 1] to [a, b]\n    mapped_nodes = 0.5 * (b - a) * nodes + 0.5 * (b + a)\n    \n    # Evaluate the function at all mapped nodes\n    # The function is expected to return a (3, k) array where k is the number of nodes\n    f_vals = func(mapped_nodes, *func_args)\n    \n    # Perform the weighted sum for each component (x, y, z)\n    integral_val = 0.5 * (b - a) * np.sum(f_vals * weights[np.newaxis, :], axis=1)\n    \n    return integral_val\n\ndef _calculate_b_integrand(phi, r_obs, a):\n    \"\"\"\n    Calculates the vector integrand of the Biot-Savart law for a circular coil.\n    Expects phi to be a numpy array of evaluation points.\n\n    Args:\n        phi (np.ndarray): Array of angles (source point parameter).\n        r_obs (np.ndarray): Observation point (x, y, z).\n        a (float): Radius of the coil.\n\n    Returns:\n        np.ndarray: A (3, N) array of the vector integrand values.\n    \"\"\"\n    # Source points l(phi) = (a*cos(phi), a*sin(phi), 0)\n    # The shape of phi is (k,), so l_vec has shape (3, k)\n    l_vec = np.array([a * np.cos(phi), a * np.sin(phi), np.zeros_like(phi)])\n    \n    # Differential line elements dl(phi)/dphi = (-a*sin(phi), a*cos(phi), 0)\n    dl_dphi = np.array([-a * np.sin(phi), a * np.cos(phi), np.zeros_like(phi)])\n    \n    # Vector R from source to observation point: R = r_obs - l(phi)\n    # r_obs has shape (3,), we reshape to (3, 1) for broadcasting with l_vec (3, k)\n    r_vec = r_obs.reshape(3, 1) - l_vec\n    \n    # Magnitude of R, with a small epsilon to avoid division by zero if r_obs is on the coil\n    r_mag = np.linalg.norm(r_vec, axis=0)\n    # Add a small machine-epsilon-level value for absolute stability on-coil.\n    r_mag[r_mag == 0] = 1e-15\n\n    # Integrand: (dl/dphi x R) / |R|^3\n    cross_product = np.cross(dl_dphi, r_vec, axisa=0, axisb=0, axisc=0)\n    integrand = cross_product / r_mag**3\n    \n    return integrand\n\ndef calculate_b(r_obs, a, I, n_gauss_points=16, initial_panels=16, refinement_factor=2.0, max_depth=15):\n    \"\"\"\n    Calculates the magnetic field B at an observation point r_obs.\n\n    Uses composite Gauss quadrature with adaptive panel refinement based on\n    proximity to the coil.\n    \"\"\"\n    r_obs = np.array(r_obs, dtype=float)\n    \n    # List to store the final panel intervals for integration\n    final_panels = []\n    \n    # Initial queue of panels to process for refinement\n    # Panel is defined by (start_angle, end_angle, depth)\n    panel_queue = [(i * 2 * np.pi / initial_panels, (i + 1) * 2 * np.pi / initial_panels, 0) for i in range(initial_panels)]\n\n    # Cylindrical coordinates of observation point for distance checking\n    rho_obs = np.sqrt(r_obs[0]**2 + r_obs[1]**2)\n    phi_obs = np.arctan2(r_obs[1], r_obs[0])\n    if phi_obs < 0:\n        phi_obs += 2 * np.pi\n\n    while panel_queue:\n        phi_start, phi_end, depth = panel_queue.pop(0)\n\n        # Find minimum distance from r_obs to the coil segment in this panel\n        min_dist_sq = -1.0\n        if phi_start <= phi_obs < phi_end:\n            # Point of closest approach is inside the panel's angular range\n            min_dist_sq = (rho_obs - a)**2 + r_obs[2]**2\n        else:\n            # Check endpoints\n            l_start = np.array([a * np.cos(phi_start), a * np.sin(phi_start), 0.0])\n            l_end = np.array([a * np.cos(phi_end), a * np.sin(phi_end), 0.0])\n            dist_sq_start = np.sum((r_obs - l_start)**2)\n            dist_sq_end = np.sum((r_obs - l_end)**2)\n            min_dist_sq = min(dist_sq_start, dist_sq_end)\n\n        min_dist = np.sqrt(min_dist_sq)\n\n        # Refinement condition\n        panel_arc_length = a * (phi_end - phi_start)\n        if depth < max_depth and min_dist < refinement_factor * panel_arc_length:\n            phi_mid = (phi_start + phi_end) / 2\n            panel_queue.append((phi_start, phi_mid, depth + 1))\n            panel_queue.append((phi_mid, phi_end, depth + 1))\n        else:\n            final_panels.append((phi_start, phi_end))\n\n    # Integrate over all the final panels\n    b_integral = np.zeros(3)\n    for panel in final_panels:\n        b_integral += _gauss_legendre_quad(\n            _calculate_b_integrand, panel, n_gauss_points, (r_obs, a)\n        )\n\n    return (MU_0 * I / (4 * np.pi)) * b_integral\n\ndef calculate_f(a, I1, I2, z2):\n    \"\"\"\n    Calculates the force on a second coaxial coil.\n    \"\"\"\n    # By symmetry, we only need the field at one point on the second coil,\n    # e.g., at (a, 0, z2), to find the total force.\n    r_obs_force = np.array([a, 0.0, z2])\n    \n    # Calculate B-field from coil 1 at this point\n    # Parameters for high accuracy required for this near-singular case\n    b_field = calculate_b(r_obs_force, a, I1, n_gauss_points=32, initial_panels=32, refinement_factor=2.0, max_depth=20)\n    \n    # The radial component of the B-field is B_x at (a, 0, z2)\n    b_radial = b_field[0]\n    \n    # Force F_z = -2 * pi * a * I2 * B_radial\n    # F_x and F_y are zero by symmetry.\n    fz = -2 * np.pi * a * I2 * b_radial\n    \n    return np.array([0.0, 0.0, fz])\n\ndef solve():\n    # Define the test cases from the problem statement.\n    a = 0.5  # m\n    I1 = 15000.0  # A\n\n    test_cases = [\n        {'type': 'B', 'params': {'r_obs': (0.0, 0.0, 0.1), 'a': a, 'I': I1}},\n        {'type': 'B', 'params': {'r_obs': (0.49, 0.0, 0.0), 'a': a, 'I': I1}},\n        {'type': 'B', 'params': {'r_obs': (1.5, 0.0, 0.2), 'a': a, 'I': I1}},\n        {'type': 'F', 'params': {'a': a, 'I1': I1, 'I2': 12000.0, 'z2': 0.05}}\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'B':\n            result = calculate_b(**case['params'])\n        elif case['type'] == 'F':\n            result = calculate_f(**case['params'])\n        # Convert to a standard list of floats for the output format\n        results.append([float(f) for f in result])\n\n    # Final print statement in the exact required format.\n    # The format uses list-of-lists, so we convert python lists to string representation.\n    # Note: Using repr() on each list ensures the correct bracket format.\n    print(f\"[{','.join(map(repr, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world engineering components often feature geometric complexities, such as sharp corners, that are idealized in simple models. This practice explores the consequences of such idealizations, focusing on the singular behavior of electromagnetic fields and forces near a sharp conductor edge . By analyzing the scaling of the force density and contrasting local force calculations with the globally-conserved Maxwell Stress Tensor, you will learn to identify non-physical artifacts in simulations and apply regularization techniques. This critical-thinking exercise is essential for interpreting numerical results correctly and building physically meaningful models of complex devices.",
            "id": "3970469",
            "problem": "In magnetostatics, consider a corner region of a thin, current-carrying conductor used in a fusion device coil pack, modeled as a Perfect Electric Conductor (PEC). The current flows along the out-of-plane direction, and the two-dimensional cross-section of the conductor boundary has a sharp, zero-radius corner. Let the electromagnetic fields be computed by the Finite Element Method (FEM) with edge-based basis functions (first family of Nédélec elements) for the magnetic vector potential. Assume quasi-static conditions, so displacement currents are negligible, and use Ohm’s law in the conductor where appropriate. Start from the magnetostatic Maxwell equations, namely $\\nabla \\times \\mathbf{B} = \\mu_0 \\mathbf{J}$ and $\\nabla \\cdot \\mathbf{B} = 0$, and the Lorentz force density $\\mathbf{f} = \\mathbf{J} \\times \\mathbf{B}$.\n\nIt is known from wedge-edge asymptotics for PEC boundaries that the surface current density near a sharp corner along the boundary arc coordinate $r$ behaves as $J_s(r) \\sim C_J r^{-1/2}$ and the tangential magnetic field just outside the conductor behaves as $B_t(r) \\sim C_B r^{-1/2}$, where $C_J$ and $C_B$ are positive constants determined by global geometry and total current. Interpret $\\mathbf{J}_s$ as the surface current density and $B_t$ as the tangential magnetic field on the exterior side of the PEC boundary.\n\nUsing these asymptotics, answer the following:\n\n- Derive the leading-order scaling of the local surface force density $\\mathbf{f}_s(r) = \\mathbf{J}_s(r) \\times \\mathbf{B}_t(r)$ near the corner and assess the integrability of the force density in a neighborhood of size $R$ around the corner. Specifically, analyze the behavior of the integral $\\int_{0}^{R} \\lVert \\mathbf{f}_s(r) \\rVert \\, \\mathrm{d}r$ and state whether it converges as the lower limit tends to $0$.\n\n- Explain why, in the FEM with edge-based basis functions, the pointwise field representation near the corner can lead to mesh-dependent spikes in $\\lVert \\mathbf{J} \\times \\mathbf{B} \\rVert$, and discuss whether the total coil force computed by integrating the Maxwell stress tensor over a smooth surface that encloses the conductor and remains a finite offset from the boundary is expected to be bounded and mesh-independent.\n\n- Consider remedies that can be used in computational fusion coil force calculations to obtain robust forces in the presence of geometric singularities. Choose all statements that are correct.\n\nOptions:\n\nA. Because $\\lVert \\mathbf{f}_s(r) \\rVert$ scales like $r^{-1}$, the integral of the local force density over any neighborhood that includes the corner without regularization diverges logarithmically, so pointwise or cell-local forces at the corner are non-convergent; evaluating the total force via the Maxwell stress tensor on a smooth surface that remains a finite offset from the conductor yields a bounded, mesh-independent result.\n\nB. With Nédélec edge elements, the tangential continuity they enforce removes geometric singularities, so the pointwise force density $\\lVert \\mathbf{J} \\times \\mathbf{B} \\rVert$ at the corner converges with mesh refinement.\n\nC. Switching from edge-based (Nédélec) elements to nodal (Lagrange) elements eliminates the corner singularity and ensures convergence of $\\lVert \\mathbf{J} \\times \\mathbf{B} \\rVert$.\n\nD. Introducing a physically motivated smoothing of the fields via convolution with a kernel of width equal to a manufactured or measured corner radius $r_c$, or using a subgrid model that replaces the sharp corner by a fillet of radius $r_c$, produces bounded and mesh-independent computed force densities and total forces consistent with physical reality.\n\nE. Computing coil forces using only the local volumetric formula $\\mathbf{f} = \\mathbf{J} \\times \\mathbf{B}$ inside the conductor is always preferable to a Maxwell stress approach because it avoids integrating over regions with singular fields and thus guarantees mesh-independent results.\n\nSelect all correct options.",
            "solution": "The problem statement is critically validated before proceeding to a solution.\n\n### Step 1: Extract Givens\n\n-   **Model**: A two-dimensional cross-section of a thin, current-carrying conductor, modeled as a Perfect Electric Conductor (PEC), with a sharp, zero-radius corner.\n-   **Physics**: Magnetostatics under quasi-static conditions.\n-   **Governing Equations**: $\\nabla \\times \\mathbf{B} = \\mu_0 \\mathbf{J}$, $\\nabla \\cdot \\mathbf{B} = 0$.\n-   **Force Density**: Lorentz force density $\\mathbf{f} = \\mathbf{J} \\times \\mathbf{B}$.\n-   **Numerical Method**: Finite Element Method (FEM) with first family Nédélec edge-based basis functions for the magnetic vector potential.\n-   **Asymptotic Behavior**: Near the corner, along the boundary arc coordinate $r$:\n    -   Surface current density $J_s(r) \\sim C_J r^{-1/2}$, where $C_J > 0$.\n    -   Tangential magnetic field (exterior) $B_t(r) \\sim C_B r^{-1/2}$, where $C_B > 0$.\n-   **Quantities of Interest**:\n    -   Local surface force density $\\mathbf{f}_s(r) = \\mathbf{J}_s(r) \\times \\mathbf{B}_t(r)$.\n    -   Integrability of $\\int_{0}^{R} \\lVert \\mathbf{f}_s(r) \\rVert \\, \\mathrm{d}r$.\n    -   Mesh dependence of $\\lVert \\mathbf{J} \\times \\mathbf{B} \\rVert$ in FEM.\n    -   Mesh dependence of total force from Maxwell stress tensor integration.\n    -   Remedies for computational force calculations.\n\n### Step 2: Validate Using Extracted Givens\n\n-   **Scientific Groundedness**: The problem is firmly rooted in classical electromagnetism (magnetostatics) and computational electromagnetics. The governing Maxwell equations, the Lorentz force law, and the PEC model are standard. The use of FEM with Nédélec elements is a state-of-the-art technique for such problems. The stated asymptotic behavior of fields near a sharp edge ($r^{-1/2}$ singularity) is a well-known result from the theory of elliptic partial differential equations in domains with corners, corresponding to a corner with an external angle of $2\\pi$ (a \"knife-edge\"). The problem is scientifically sound.\n-   **Well-Posedness**: The problem provides all necessary information to analyze the scaling of the force density and its integrability. The questions posed are precise and can be answered through logical derivation based on the givens. The problem is self-contained and well-posed.\n-   **Objectivity**: The problem is stated in precise, objective, and technical language, free from ambiguity or subjective claims.\n\n### Step 3: Verdict and Action\n\nThe problem statement is valid. It describes a classic and practical issue in computational engineering physics. A full solution will be derived.\n\n### Derivation and Analysis\n\n**Part 1: Local Force Scaling and Integrability**\n\nThe problem asks for the scaling of the local surface force density, $\\mathbf{f}_s(r) = \\mathbf{J}_s(r) \\times \\mathbf{B}_t(r)$. The current $\\mathbf{J}_s(r)$ is out-of-plane. We can align our coordinate system such that $\\mathbf{J}_s(r) = J_s(r) \\hat{\\mathbf{z}}$. The tangential magnetic field $\\mathbf{B}_t(r)$ lies in the $xy$-plane, tangent to the conductor's boundary. Therefore, $\\mathbf{J}_s(r)$ is everywhere perpendicular to $\\mathbf{B}_t(r)$.\n\nThe magnitude of the surface force density is given by\n$$ \\lVert \\mathbf{f}_s(r) \\rVert = \\lVert \\mathbf{J}_s(r) \\times \\mathbf{B}_t(r) \\rVert = J_s(r) B_t(r) \\sin(\\pi/2) = J_s(r) B_t(r) $$\nUsing the provided asymptotic behaviors for $r \\to 0$:\n$$ \\lVert \\mathbf{f}_s(r) \\rVert \\sim (C_J r^{-1/2}) (C_B r^{-1/2}) = C_J C_B r^{-1} $$\nThe local surface force density magnitude scales as $r^{-1}$ near the sharp corner.\n\nNext, we assess the integrability of this force density over a neighborhood of size $R$ around the corner (at $r=0$). We examine the integral of the force magnitude:\n$$ F_{local} = \\int_{0}^{R} \\lVert \\mathbf{f}_s(r) \\rVert \\, \\mathrm{d}r $$\nDue to the $r^{-1}$ scaling, this integral behaves like:\n$$ \\int_{\\epsilon}^{R} \\frac{C}{r} \\, \\mathrm{d}r = C [\\ln(r)]_{\\epsilon}^{R} = C (\\ln(R) - \\ln(\\epsilon)) $$\nwhere $C = C_J C_B$. As the lower limit of integration $\\epsilon$ approaches $0$, $\\ln(\\epsilon) \\to -\\infty$. Therefore, the integral diverges. This is a logarithmic divergence.\nThis implies that in the idealized model of a zero-radius corner, the total force acting on any finite length of the conductor that includes the corner is infinite.\n\n**Part 2: FEM Behavior and Maxwell Stress Tensor**\n\nIn a numerical FEM context, the basis functions (including Nédélec elements) are polynomials of a fixed, low order within each element. Such functions are smooth and cannot reproduce the singular $r^{-1/2}$ behavior of the fields $\\mathbf{B}$ and $\\mathbf{J}$. The FEM solution attempts to approximate this singularity. As the mesh is refined near the corner, the element sizes decrease. To approximate a function that is rapidly growing towards infinity, the coefficients of the basis functions in the small elements near the corner must become increasingly large. This results in the computed pointwise values of $\\mathbf{J}$ and $\\mathbfB$ exhibiting large, mesh-dependent spikes that do not converge to a finite value. Consequently, the pointwise product $\\lVert \\mathbf{J} \\times \\mathbf{B} \\rVert$ will also be non-convergent and grow with mesh refinement.\n\nThe total electromagnetic force on a current-carrying body can be calculated by integrating the Maxwell stress tensor $\\mathbf{T}$ over any closed surface $S$ that encloses the body:\n$$ \\mathbf{F} = \\oint_S \\mathbf{T} \\cdot d\\mathbf{a} $$\nwhere $\\mathbf{T}_{ij} = \\frac{1}{\\mu_0}(B_i B_j - \\frac{1}{2} \\delta_{ij} B^2)$. This is a powerful identity. If we choose the integration surface $S$ to be smooth and to maintain a finite distance from the conductor, we are evaluating the integral in a region where the fields are smooth and well-behaved. For elliptic problems like magnetostatics, the FEM solution converges well in regions away from singularities. Therefore, the computed magnetic field $\\mathbf{B}$ on this remote surface $S$ will converge with mesh refinement. As a result, the integral of the Maxwell stress tensor over $S$ will converge to a well-defined, bounded, and mesh-independent total force. This method effectively bypasses the local, non-integrable singularity.\n\n### Option-by-Option Analysis\n\n**A. Because $\\lVert \\mathbf{f}_s(r) \\rVert$ scales like $r^{-1}$, the integral of the local force density over any neighborhood that includes the corner without regularization diverges logarithmically, so pointwise or cell-local forces at the corner are non-convergent; evaluating the total force via the Maxwell stress tensor on a smooth surface that remains a finite offset from the conductor yields a bounded, mesh-independent result.**\nThis statement is a complete and accurate summary of the analysis. The force density scales as $r^{-1}$, its integral diverges logarithmically, and local forces are numerically non-convergent. It correctly states that the Maxwell stress tensor method, applied on a surface away from the singularity, provides a robust, mesh-convergent value for the total force.\n**Verdict: Correct.**\n\n**B. With Nédélec edge elements, the tangential continuity they enforce removes geometric singularities, so the pointwise force density $\\lVert \\mathbf{J} \\times \\mathbf{B} \\rVert$ at the corner converges with mesh refinement.**\nThis is incorrect. Nédélec elements are designed to correctly represent the function space for electromagnetic fields (e.g., ensuring tangential continuity of $\\mathbf{A}$ or $\\mathbf{E}$), which is vital for physical consistency (e.g., $\\nabla \\cdot \\mathbf{B} = 0$). However, they are still polynomial-based and cannot remove or exactly represent a singularity present in the true solution of the governing partial differential equation. The singularity is a property of the continuous problem with the given geometry, not a numerical artifact. Therefore, pointwise values at the singularity will not converge.\n**Verdict: Incorrect.**\n\n**C. Switching from edge-based (Nédélec) elements to nodal (Lagrange) elements eliminates the corner singularity and ensures convergence of $\\lVert \\mathbf{J} \\times \\mathbf{B} \\rVert$.**\nThis is incorrect. Lagrange elements are also polynomial-based and face the same fundamental limitation in representing a singular function. Switching the polynomial basis function type does not alter the singular nature of the underlying analytical solution. Furthermore, for vector field problems in electromagnetism, nodal elements are generally less suitable than edge elements as they can introduce other difficulties, such as failing to properly enforce the divergence-free condition. The singularity is not eliminated, and convergence is not achieved.\n**Verdict: Incorrect.**\n\n**D. Introducing a physically motivated smoothing of the fields via convolution with a kernel of width equal to a manufactured or measured corner radius $r_c$, or using a subgrid model that replaces the sharp corner by a fillet of radius $r_c$, produces bounded and mesh-independent computed force densities and total forces consistent with physical reality.**\nThis statement describes standard and physically justified regularization techniques. A \"zero-radius\" corner is an unphysical idealization. Real-world conductors have a finite corner radius $r_c$. Modifying the geometry to include a fillet of radius $r_c$ removes the mathematical singularity. The solution to this modified, physically realistic problem is smooth and bounded. FEM can then compute a convergent solution for both local and total forces. Alternatively, post-processing techniques like field convolution or using a subgrid model can achieve a similar regularization effect. These methods are essential for obtaining physically meaningful and numerically stable (mesh-independent) results.\n**Verdict: Correct.**\n\n**E. Computing coil forces using only the local volumetric formula $\\mathbf{f} = \\mathbf{J} \\times \\mathbf{B}$ inside the conductor is always preferable to a Maxwell stress approach because it avoids integrating over regions with singular fields and thus guarantees mesh-independent results.**\nThis statement is factually inverted. The local formula $\\mathbf{f} = \\mathbf{J} \\times \\mathbf{B}$ requires evaluating the fields *inside* the conductor and up to its boundary. It is precisely this approach that confronts the singularity directly, leading to non-convergent, mesh-dependent results for the local forces and the total force if integrated naively. The Maxwell stress tensor method is the one that *avoids* a region of singular fields by choosing an integration path in a smooth region. Therefore, this statement's reasoning and conclusion are both false.\n**Verdict: Incorrect.**",
            "answer": "$$\\boxed{AD}$$"
        },
        {
            "introduction": "Beyond analysis, a primary goal of computational engineering is design and optimization. This final practice elevates the preceding concepts by embedding the physics of force calculation within an optimization framework to design a better coil system . You will tackle a problem aimed at minimizing peak electromagnetic stress, a critical constraint in high-field magnets. The core task involves deriving and implementing an adjoint-based method to efficiently compute the gradients of an objective function, a state-of-the-art technique in large-scale design optimization that is vastly more efficient than conventional finite-difference methods.",
            "id": "3970528",
            "problem": "You are asked to formulate and verify an adjoint-based gradient computation for an optimization problem relevant to electromagnetic coil force calculations in computational fusion science and engineering. Consider a coil system discretized into $M$ straight conductor segments with fixed geometry and unknown currents $\\{I_m\\}_{m=1}^M$. Each segment $m$ has center at position $\\mathbf{x}_m \\in \\mathbb{R}^3$, orientation given by a unit vector $\\hat{\\mathbf{s}}_m$, length $L_m$, and cross-sectional area $A_m$. The magnetostatic magnetic field at a set of $K$ target points $\\{\\mathbf{x}_k\\}_{k=1}^K$ due to the coil segments is given by the Biot–Savart law, which in continuous form is a fundamental law:\n$$\n\\mathbf{B}(\\mathbf{x}) \\;=\\; \\frac{\\mu_0}{4\\pi} \\int \\frac{I\\, d\\boldsymbol{\\ell} \\times (\\mathbf{x}-\\mathbf{r})}{\\|\\mathbf{x}-\\mathbf{r}\\|^3} \\, ,\n$$\nwhere $\\mu_0$ is the permeability of free space. Upon discretization along each straight segment using $N_q$ quadrature nodes, the normal component (here, choose the $z$-component) at the target points is a linear function of the currents described by a matrix $\\mathbf{G} \\in \\mathbb{R}^{K\\times M}$:\n$$\n\\mathbf{b}(\\mathbf{I}) \\;=\\; \\mathbf{G}\\,\\mathbf{I} \\, ,\n$$\nwhere $\\mathbf{I} = [I_1,\\dots,I_M]^T$ and $\\mathbf{b}(\\mathbf{I}) \\in \\mathbb{R}^K$ collects the $z$-components at the $K$ targets. The field performance constraint is an equality $\\mathbf{G}\\,\\mathbf{I} = \\mathbf{b}_{\\mathrm{target}}$.\n\nEach segment experiences a Lorentz force density due to a prescribed background magnetic field $\\mathbf{B}_{\\mathrm{back}}(\\mathbf{x})$ (for example, a toroidal background field and its spatial variation). The local Lorentz force density is the fundamental expression\n$$\n\\mathbf{f}(\\mathbf{x}) \\;=\\; \\mathbf{J}(\\mathbf{x}) \\times \\mathbf{B}(\\mathbf{x}) \\, .\n$$\nApproximating the peak along segments by an $\\ell_q$-norm with smoothing, define for segment $m$ the smoothed local magnitude\n$$\nf_m(\\mathbf{I}) \\;=\\; \\frac{\\sqrt{I_m^2 + \\varepsilon^2}}{A_m}\\,\\big\\| \\hat{\\mathbf{s}}_m \\times \\mathbf{B}_{\\mathrm{back}}(\\mathbf{x}_m)\\big\\| \\, ,\n$$\nwith smoothing parameter $\\varepsilon > 0$. The peak proxy objective is the $\\ell_q$ norm\n$$\nF_q(\\mathbf{I}) \\;=\\; \\left( \\sum_{m=1}^M \\left[ f_m(\\mathbf{I}) \\right]^q \\right)^{1/q} \\, ,\n$$\nfor some $q \\ge 2$. To enforce the field performance constraint while maintaining computational tractability, consider a quadratic penalty formulation with weight $\\mu > 0$:\n$$\nJ_{\\mu}(\\mathbf{I}) \\;=\\; F_q(\\mathbf{I}) \\;+\\; \\frac{\\mu}{2}\\,\\left\\| \\mathbf{G}\\,\\mathbf{I} - \\mathbf{b}_{\\mathrm{target}} \\right\\|_2^2 \\, .\n$$\n\nYour tasks are:\n$1.$ Starting only from the fundamental laws stated above (the Biot–Savart law and the Lorentz force density), derive the gradient of $J_{\\mu}(\\mathbf{I})$ with respect to $\\mathbf{I}$ using an adjoint-method viewpoint. Clearly introduce an adjoint variable and show how the gradient can be assembled without explicitly differentiating the forward map beyond first-order linear algebraic operations.\n\n$2.$ Implement a program that\n$2.1.$ Constructs $\\mathbf{G}$ numerically by discretizing each straight segment into $N_q$ uniform quadrature nodes and evaluating the Biot–Savart integral for the $z$-component at each target point (assume the magnetic permeability of free space is $\\mu_0 = 4\\pi \\times 10^{-7}$ in $\\mathrm{H/m}$).\n$2.2.$ Defines the background field $\\mathbf{B}_{\\mathrm{back}}(\\mathbf{x})$ as\n$$\n\\mathbf{B}_{\\mathrm{back}}(x,y,z) \\;=\\; \\begin{bmatrix} 0.10\\,z \\\\ 0 \\\\ 1.50 \\;+\\; 0.05\\,x \\end{bmatrix} \\quad \\text{in Tesla} \\, ,\n$$\nand evaluates it at each segment center to compute $\\big\\|\\hat{\\mathbf{s}}_m \\times \\mathbf{B}_{\\mathrm{back}}(\\mathbf{x}_m)\\big\\|$.\n$2.3.$ Uses the following fixed coil geometry and targets:\n$M = 4$ straight segments, each of length $L_m = 0.40$ in $\\mathrm{m}$, centered at positions\n$$\n\\mathbf{x}_1 = [-0.30,\\, 0.00,\\, 0.00]^T,\\;\\; \\mathbf{x}_2 = [-0.10,\\, 0.00,\\, 0.00]^T,\\;\\; \\mathbf{x}_3 = [0.10,\\, 0.00,\\, 0.00]^T,\\;\\; \\mathbf{x}_4 = [0.30,\\, 0.00,\\, 0.00]^T \\, ,\n$$\nwith orientations $\\hat{\\mathbf{s}}_m = [0,\\,1,\\,0]^T$ for all $m$, and cross-sectional areas\n$$\nA_1 = 5.0\\times 10^{-4},\\;\\; A_2 = 4.0\\times 10^{-4},\\;\\; A_3 = 6.0\\times 10^{-4},\\;\\; A_4 = 5.0\\times 10^{-4} \\quad \\text{in } \\mathrm{m}^2 \\, .\n$$\nLet the $K = 2$ target points be\n$$\n\\mathbf{x}_{\\mathrm{t},1} = [0.00,\\, 0.00,\\, 0.20]^T,\\qquad \\mathbf{x}_{\\mathrm{t},2} = [0.00,\\, 0.00,\\, 0.35]^T \\, .\n$$\nDefine the target $z$-components in Tesla as\n$$\n\\mathbf{b}_{\\mathrm{target}} = \\begin{bmatrix} 1.0\\times 10^{-5} \\\\ -0.5\\times 10^{-5} \\end{bmatrix} \\, .\n$$\nUse $N_q = 200$ quadrature nodes per segment for the Biot–Savart discretization.\n$2.4.$ For each test case, construct a baseline current vector $\\mathbf{I}$ by solving the Tikhonov-regularized least-squares problem\n$$\n\\mathbf{I}^\\star \\;=\\; \\arg\\min_{\\mathbf{I}} \\left\\| \\mathbf{G}\\,\\mathbf{I} - \\mathbf{b}_{\\mathrm{target}} \\right\\|_2^2 \\;+\\; \\alpha \\left\\| \\mathbf{I} \\right\\|_2^2 \\, ,\n$$\nwith $\\alpha = 1.0\\times 10^{-6}$, and use this $\\mathbf{I}^\\star$ to evaluate gradients.\n$2.5.$ Compute the adjoint-based gradient $\\nabla J_{\\mu}(\\mathbf{I}^\\star)$ you derived in task $1$, and verify it against a central finite-difference approximation with step size $h$ for each component:\n$$\n\\left[\\nabla J_{\\mu}(\\mathbf{I}^\\star)\\right]_m \\;\\approx\\; \\frac{J_{\\mu}(\\mathbf{I}^\\star + h\\,\\mathbf{e}_m) - J_{\\mu}(\\mathbf{I}^\\star - h\\,\\mathbf{e}_m)}{2h} \\, ,\n$$\nwhere $\\{\\mathbf{e}_m\\}$ is the standard basis.\n$2.6.$ Report for each test case the relative gradient error\n$$\n\\mathrm{err} \\;=\\; \\frac{\\left\\|\\nabla J_{\\mu}^{\\mathrm{adj}} - \\nabla J_{\\mu}^{\\mathrm{FD}}\\right\\|_2}{\\max\\left(1, \\left\\|\\nabla J_{\\mu}^{\\mathrm{FD}}\\right\\|_2\\right)} \\, ,\n$$\nwhich is dimensionless. Express all reported outputs as pure numbers without units.\n\nTest suite. Run exactly the following three test cases, each specified by $(q,\\mu,\\varepsilon,h)$:\n$1.$ $(4,\\, 5.0,\\, 1.0\\times 10^{-6},\\, 1.0\\times 10^{-7})$.\n$2.$ $(8,\\, 1.0,\\, 1.0\\times 10^{-8},\\, 5.0\\times 10^{-8})$.\n$3.$ $(16,\\, 0.5,\\, 1.0\\times 10^{-10},\\, 2.0\\times 10^{-8})$.\n\nFinal output format. Your program should produce a single line of output containing the three relative gradient errors in the order of the test cases as a comma-separated list enclosed in square brackets, for example, $[\\mathrm{err}_1,\\mathrm{err}_2,\\mathrm{err}_3]$. The outputs are dimensionless real numbers.",
            "solution": "The problem requires the derivation and implementation of an adjoint-based gradient calculation for a specific optimization functional $J_{\\mu}(\\mathbf{I})$ relevant to electromagnetic coil design in fusion science. The derivation must originate from the fundamental physical laws provided, and the implementation must be validated against a finite-difference approximation.\n\nFirst, the derivation of the gradient $\\nabla_{\\mathbf{I}} J_{\\mu}(\\mathbf{I})$ is performed using an adjoint method formulation. The objective functional is given as:\n$$\nJ_{\\mu}(\\mathbf{I}) = F_q(\\mathbf{I}) + \\frac{\\mu}{2}\\,\\left\\| \\mathbf{G}\\,\\mathbf{I} - \\mathbf{b}_{\\mathrm{target}} \\right\\|_2^2\n$$\nThis functional consists of two terms. The first, $F_q(\\mathbf{I})$, depends directly on the optimization variables (currents $\\mathbf{I}$). The second is a quadratic penalty term that depends on $\\mathbf{I}$ through a linear \"forward map\" $\\mathbf{b}(\\mathbf{I}) = \\mathbf{G}\\mathbf{I}$, which represents the discretized Biot-Savart law. The gradient of $J_{\\mu}$ is the sum of the gradients of these two terms.\n\nLet's analyze the penalty term first from an adjoint perspective. We can write this part of the functional as $P(\\mathbf{b}(\\mathbf{I}))$, where the state variable is $\\mathbf{b} \\in \\mathbb{R}^K$ and the objective part is $P(\\mathbf{b}) = \\frac{\\mu}{2}\\|\\mathbf{b} - \\mathbf{b}_{\\mathrm{target}}\\|_2^2$. The forward operator mapping the control variables $\\mathbf{I}$ to the state variables $\\mathbf{b}$ is $\\mathbf{b}(\\mathbf{I}) = \\mathbf{G}\\mathbf{I}$.\n\nThe total derivative of $P$ with respect to $\\mathbf{I}$ is given by the chain rule:\n$$\n\\nabla_{\\mathbf{I}} P = \\left(\\frac{d\\mathbf{b}}{d\\mathbf{I}}\\right)^T \\frac{\\partial P}{\\partial \\mathbf{b}}\n$$\nThe term $\\frac{d\\mathbf{b}}{d\\mathbf{I}}$ is the Jacobian of the forward map, which is simply the matrix $\\mathbf{G}$. The term $\\frac{\\partial P}{\\partial \\mathbf{b}}$ is the gradient of the objective with respect to the state. In the context of adjoint methods, this term is defined as the adjoint variable, $\\boldsymbol{\\lambda}$.\n$$\n\\boldsymbol{\\lambda} \\equiv \\frac{\\partial P}{\\partial \\mathbf{b}} = \\nabla_{\\mathbf{b}} \\left( \\frac{\\mu}{2} (\\mathbf{b} - \\mathbf{b}_{\\mathrm{target}})^T (\\mathbf{b} - \\mathbf{b}_{\\mathrm{target}}) \\right) = \\mu (\\mathbf{b} - \\mathbf{b}_{\\mathrm{target}})\n$$\nSubstituting $\\mathbf{b}=\\mathbf{G}\\mathbf{I}$, the adjoint variable is computed after the forward solve:\n$$\n\\boldsymbol{\\lambda} = \\mu (\\mathbf{G}\\mathbf{I} - \\mathbf{b}_{\\mathrm{target}})\n$$\nThe gradient of the penalty term with respect to $\\mathbf{I}$ is then assembled by multiplying the adjoint variable by the transpose of the forward map's Jacobian:\n$$\n\\nabla_{\\mathbf{I}} \\left( \\frac{\\mu}{2}\\,\\left\\| \\mathbf{G}\\,\\mathbf{I} - \\mathbf{b}_{\\mathrm{target}} \\right\\|_2^2 \\right) = \\mathbf{G}^T \\boldsymbol{\\lambda} = \\mu \\mathbf{G}^T (\\mathbf{G}\\mathbf{I} - \\mathbf{b}_{\\mathrm{target}})\n$$\nThis formulation demonstrates the core idea of the adjoint method: the action of the derivative on a perturbation $\\delta\\mathbf{I}$ is evaluated by first computing the state perturbation $\\delta\\mathbf{b} = \\mathbf{G}\\delta\\mathbf{I}$, then taking an inner product with the adjoint variable $\\boldsymbol{\\lambda}$, which encodes the sensitivity of the objective to the state. This transposes into $\\delta\\mathbf{I}^T (\\mathbf{G}^T \\boldsymbol{\\lambda})$ to find the gradient with respect to $\\mathbf{I}$.\n\nNext, we address the first term, $F_q(\\mathbf{I})$, which is defined as:\n$$\nF_q(\\mathbf{I}) = \\left( \\sum_{m=1}^M \\left[ f_m(\\mathbf{I}) \\right]^q \\right)^{1/q}\n$$\nSince each $f_m(\\mathbf{I})$ depends only on the corresponding current component $I_m$, its gradient can be computed directly by applying the chain rule. The $j$-th component of the gradient $\\nabla_{\\mathbf{I}} F_q(\\mathbf{I})$ is:\n$$\n\\frac{\\partial F_q}{\\partial I_j} = \\frac{1}{q} \\left( \\sum_{m=1}^M [f_m]^q \\right)^{\\frac{1}{q}-1} \\cdot q [f_j]^{q-1} \\frac{\\partial f_j}{\\partial I_j} = \\left( F_q(\\mathbf{I}) \\right)^{1-q} [f_j(\\mathbf{I})]^{q-1} \\frac{d f_j}{d I_j}\n$$\nThe force magnitude proxy $f_m$ for segment $m$ is:\n$$\nf_m(\\mathbf{I}) = \\frac{\\sqrt{I_m^2 + \\varepsilon^2}}{A_m}\\,\\big\\| \\hat{\\mathbf{s}}_m \\times \\mathbf{B}_{\\mathrm{back}}(\\mathbf{x}_m)\\big\\|\n$$\nIts derivative with respect to $I_m$ is:\n$$\n\\frac{d f_m}{d I_m} = \\frac{I_m}{\\sqrt{I_m^2 + \\varepsilon^2}} \\frac{\\big\\| \\hat{\\mathbf{s}}_m \\times \\mathbf{B}_{\\mathrm{back}}(\\mathbf{x}_m)\\big\\|}{A_m}\n$$\nCombining these results, the $j$-th component of the gradient of $F_q$ is:\n$$\n[\\nabla_{\\mathbf{I}} F_q(\\mathbf{I})]_j = \\left( F_q(\\mathbf{I}) \\right)^{1-q} [f_j(\\mathbf{I})]^{q-1} \\frac{I_j}{\\sqrt{I_j^2 + \\varepsilon^2}} \\frac{\\|\\hat{\\mathbf{s}}_j \\times \\mathbf{B}_{\\mathrm{back}}(\\mathbf{x}_j)\\|}{A_j}\n$$\n\nFinally, the full gradient of the objective functional $J_{\\mu}(\\mathbf{I})$ is the sum of the gradients of its two parts:\n$$\n\\nabla_{\\mathbf{I}} J_{\\mu}(\\mathbf{I}) = \\nabla_{\\mathbf{I}} F_q(\\mathbf{I}) + \\mu \\mathbf{G}^T (\\mathbf{G}\\mathbf{I} - \\mathbf{b}_{\\mathrm{target}})\n$$\nThis is the analytical expression for the adjoint-based gradient.\n\nThe implementation plan is as follows:\n$1.$ The response matrix $\\mathbf{G} \\in \\mathbb{R}^{K \\times M}$ is constructed numerically. Each element $G_{km}$ is the $z$-component of the magnetic field at target point $\\mathbf{x}_{\\mathrm{t},k}$ generated by segment $m$ with unit current. This is computed by discretizing the Biot-Savart integral for a straight segment using $N_q=200$ quadrature points. With $\\mathbf{r}(t) = \\mathbf{x}_m + t\\hat{\\mathbf{s}}_m$ for $t \\in [-L_m/2, L_m/2]$ and $\\Delta t = L_m/N_q$, the formula is:\n$$\nG_{km} = \\frac{\\mu_0}{4\\pi} \\sum_{i_q=0}^{N_q-1} \\left[ \\frac{\\hat{\\mathbf{s}}_m \\times (\\mathbf{x}_{\\mathrm{t},k} - \\mathbf{r}(t_{i_q}))}{\\|\\mathbf{x}_{\\mathrm{t},k} - \\mathbf{r}(t_{i_q})\\|^3} \\right]_z \\Delta t\n$$\nwhere $t_{i_q}$ are the midpoints of the quadrature subintervals.\n$2.$ A baseline current vector $\\mathbf{I}^\\star$ is determined by solving the Tikhonov-regularized least-squares problem $\\min_{\\mathbf{I}} \\left\\| \\mathbf{G}\\,\\mathbf{I} - \\mathbf{b}_{\\mathrm{target}} \\right\\|_2^2 + \\alpha \\left\\| \\mathbf{I} \\right\\|_2^2$. The solution is found via the normal equations: $\\mathbf{I}^\\star = (\\mathbf{G}^T \\mathbf{G} + \\alpha \\mathbf{I}_{\\text{identity}})^{-1} \\mathbf{G}^T \\mathbf{b}_{\\mathrm{target}}$.\n$3.$ The adjoint gradient $\\nabla J_{\\mu}^{\\mathrm{adj}}(\\mathbf{I}^\\star)$ is computed using the derived formula.\n$4.$ A validation gradient $\\nabla J_{\\mu}^{\\mathrm{FD}}(\\mathbf{I}^\\star)$ is computed using the central finite-difference formula for each component $m$: $[\\nabla J_{\\mu}^{\\mathrm{FD}}]_m = \\frac{J_{\\mu}(\\mathbf{I}^\\star + h\\mathbf{e}_m) - J_{\\mu}(\\mathbf{I}^\\star - h\\mathbf{e}_m)}{2h}$.\n$5.$ The relative error between the two gradients is calculated as $\\mathrm{err} = \\frac{\\|\\nabla J_{\\mu}^{\\mathrm{adj}} - \\nabla J_{\\mu}^{\\mathrm{FD}}\\|_2}{\\max(1, \\|\\nabla J_{\\mu}^{\\mathrm{FD}}\\|_2)}$. This process is repeated for each test case.",
            "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to derive and verify the adjoint-based gradient for the coil optimization problem.\n    \"\"\"\n    #\n    # Step 2.1 and 2.3: Define fixed geometry, targets, and constants\n    #\n    MU0 = 4 * np.pi * 1e-7  # Permeability of free space (H/m)\n    M = 4  # Number of coil segments\n    K = 2  # Number of target points\n    N_q = 200 # Number of quadrature nodes per segment\n    ALPHA = 1.0e-6 # Tikhonov regularization parameter\n\n    # Coil segment properties\n    L_m = 0.40  # Length of each segment (m)\n    centers = np.array([\n        [-0.30, 0.00, 0.00],\n        [-0.10, 0.00, 0.00],\n        [0.10, 0.00, 0.00],\n        [0.30, 0.00, 0.00]\n    ])\n    orientations = np.array([[0.0, 1.0, 0.0]] * M)\n    areas = np.array([5.0e-4, 4.0e-4, 6.0e-4, 5.0e-4]) # m^2\n\n    # Target point properties\n    target_points = np.array([\n        [0.00, 0.00, 0.20],\n        [0.00, 0.00, 0.35]\n    ])\n    b_target = np.array([1.0e-5, -0.5e-5]) # Tesla\n\n    #\n    # Helper function for background magnetic field\n    #\n    def B_back(p):\n        x, y, z = p\n        return np.array([0.10 * z, 0.0, 1.50 + 0.05 * x])\n\n    # Pre-compute constants for force calculation\n    C_m = np.array([\n        np.linalg.norm(np.cross(orientations[m], B_back(centers[m])))\n        for m in range(M)\n    ])\n\n    #\n    # Step 2.1: Construct the response matrix G\n    #\n    G = np.zeros((K, M))\n    dt = L_m / N_q\n    t_nodes = -L_m / 2 + (np.arange(N_q) + 0.5) * dt\n\n    for k in range(K):\n        for m in range(M):\n            g_km = 0.0\n            x_t = target_points[k]\n            x_m = centers[m]\n            s_m = orientations[m]\n            \n            for t in t_nodes:\n                r_line = x_m + t * s_m\n                R_vec = x_t - r_line\n                R_norm = np.linalg.norm(R_vec)\n                \n                integrand_vec = np.cross(s_m, R_vec) / (R_norm**3)\n                g_km += integrand_vec[2] # z-component\n\n            G[k, m] = (MU0 / (4 * np.pi)) * g_km * dt\n\n    #\n    # Step 2.4: Compute the baseline current vector I_star\n    #\n    G_T_G = G.T @ G\n    reg_matrix = G_T_G + ALPHA * np.identity(M)\n    rhs = G.T @ b_target\n    I_star = linalg.solve(reg_matrix, rhs, assume_a='sym')\n\n    #\n    # Define objective function and its gradient components\n    #\n    def compute_f_m(I, epsilon):\n        # Smoothed force magnitude proxy for each segment\n        return (np.sqrt(I**2 + epsilon**2) / areas) * C_m\n\n    def compute_F_q(I, q, epsilon):\n        # L_q norm of the force proxies\n        f_vals = compute_f_m(I, epsilon)\n        return np.sum(f_vals**q)**(1.0 / q)\n\n    def compute_J_mu(I, q, mu, epsilon):\n        # Full objective functional\n        F_q_val = compute_F_q(I, q, epsilon)\n        penalty = (mu / 2.0) * np.linalg.norm(G @ I - b_target)**2\n        return F_q_val + penalty\n\n    def compute_adjoint_gradient(I, q, mu, epsilon):\n        # Adjoint-based gradient\n        # Gradient of the penalty term\n        grad_penalty = mu * G.T @ (G @ I - b_target)\n\n        # Gradient of the force term F_q\n        f_vals = compute_f_m(I, epsilon)\n        F_q_val = np.sum(f_vals**q)**(1.0 / q)\n        \n        df_dI = (I / np.sqrt(I**2 + epsilon**2)) * (C_m / areas)\n        \n        # Handle case where F_q is very close to zero\n        if F_q_val < 1e-16:\n             grad_Fq = np.zeros_like(I)\n        else:\n            grad_Fq = (F_q_val**(1 - q)) * (f_vals**(q - 1)) * df_dI\n\n        return grad_Fq + grad_penalty\n\n    def compute_fd_gradient(I, q, mu, epsilon, h):\n        # Central finite-difference gradient for verification\n        grad_fd = np.zeros(M)\n        for m in range(M):\n            I_plus = I.copy()\n            I_plus[m] += h\n            I_minus = I.copy()\n            I_minus[m] -= h\n\n            J_plus = compute_J_mu(I_plus, q, mu, epsilon)\n            J_minus = compute_J_mu(I_minus, q, mu, epsilon)\n            \n            grad_fd[m] = (J_plus - J_minus) / (2.0 * h)\n        return grad_fd\n\n    #\n    # Test suite execution\n    #\n    test_cases = [\n        (4, 5.0, 1.0e-6, 1.0e-7),\n        (8, 1.0, 1.0e-8, 5.0e-8),\n        (16, 0.5, 1.0e-10, 2.0e-8),\n    ]\n\n    results = []\n    for q, mu, epsilon, h in test_cases:\n        # Step 2.5: Compute gradients\n        grad_adj = compute_adjoint_gradient(I_star, q, mu, epsilon)\n        grad_fd = compute_fd_gradient(I_star, q, mu, epsilon, h)\n\n        # Step 2.6: Compute relative error\n        norm_fd = np.linalg.norm(grad_fd)\n        norm_diff = np.linalg.norm(grad_adj - grad_fd)\n        \n        err = norm_diff / max(1.0, norm_fd)\n        results.append(err)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}