{
    "hands_on_practices": [
        {
            "introduction": "毕奥-萨伐尔定律是计算稳恒电流产生磁场的基石。本实践将指导您从这一基本定律出发，编写程序计算圆形电流线圈的磁场以及两个此类线圈之间的作用力。这项数值任务中的一个关键挑战是处理当观测点靠近导线时被积函数的近奇异行为；本练习将展示自适应求积法在实现高精度和高效率方面的威力。",
            "id": "3970518",
            "problem": "一个半径为 $a$、载有稳恒电流 $I$ 的单匝、理想导电的圆形丝状线圈以原点为中心，位于 $z=0$ 平面内。该线圈在观测点 $\\mathbf{r}$ 处产生的磁场由 Biot–Savart 定律定义，该定律指出，对于限制在一维曲线上的电流分布，磁场由以下形式的积分给出：\n$$\n\\mathbf{B}(\\mathbf{r}) = \\frac{\\mu_0}{4\\pi}\\int_{\\mathcal{C}} \\frac{I\\,d\\boldsymbol{\\ell}\\times\\mathbf{\\hat{R}}}{R^2},\n$$\n其中 $\\mu_0$ 是自由空间的磁导率，$d\\boldsymbol{\\ell}$ 是沿线圈中心线 $\\mathcal{C}$ 的微分线元，$\\mathbf{R}=\\mathbf{r}-\\boldsymbol{\\ell}$ 是从线圈上的源点到观测点的矢量，$R=\\|\\mathbf{R}\\|$，且 $\\mathbf{\\hat{R}}=\\mathbf{R}/R$。\n\n除磁场外，考虑第二个圆形丝状线圈，其半径同为 $a$，电流为 $I_2$，与第一个线圈共轴，但沿 $z$ 轴有 $z_2$ 的偏移。由第一个线圈产生的磁场对第二个线圈施加的洛伦兹力由洛伦兹力的磁分量的线积分给出：\n$$\n\\mathbf{F} = \\int_{\\mathcal{C}_2} I_2\\, d\\boldsymbol{\\ell}_2 \\times \\mathbf{B}_1(\\boldsymbol{\\ell}_2),\n$$\n其中 $\\mathbf{B}_1$ 是由第一个线圈产生的磁场，$d\\boldsymbol{\\ell}_2$ 是沿第二个线圈 $\\mathcal{C}_2$ 的微分线元。\n\n从这些基本定律出发，编写一个完整、可运行的程序，该程序：\n- 以参数化方式表示圆形线圈中心线，并使用对 Biot–Savart 积分的数值稳健求积法，在任意点 $\\mathbf{r}$ 处计算 $\\mathbf{B}(\\mathbf{r})$。\n- 实现复合求积法，采用分片高斯法则，并结合局部面板细化，当观测点靠近线圈时触发，以便精确解析被积函数的近奇异行为。\n- 使用第一个线圈产生的磁场和洛伦兹力定律的磁部分计算第二个线圈上的合力 $\\mathbf{F}$。\n\n您的解答必须以弧度处理角度。所有物理量必须以国际单位制（SI）表示。具体来说：\n- 以特斯拉（Tesla）表示磁场矢量 $\\mathbf{B}$。\n- 以牛顿（Newtons）表示力矢量 $\\mathbf{F}$。\n\n设计的求积法应在观测点不精确位于线圈中心线上的情况下保持数值稳定。在您的解答叙述中，从第一性原理出发，解释如何为观测点接近线圈的情况构建一个能够感知奇点的数值求积法，并概述当点位于线圈上时如何对奇异行为进行正则化或减去。\n\n测试套件：\n使用以下参数集和观测点。除非另有说明，在所有情况下，线圈半径均为 $a=0.5\\,\\mathrm{m}$，源线圈中的电流为 $I_1=15000\\,\\mathrm{A}$。\n\n1.  轴上一点的磁场：$\\mathbf{r}=(0,0,0.1)\\,\\mathrm{m}$。\n2.  近导线轴外一点的磁场：$\\mathbf{r}=(0.49,0.0,0.0)\\,\\mathrm{m}$。\n3.  远轴外一点的磁场：$\\mathbf{r}=(1.5,0.0,0.2)\\,\\mathrm{m}$。\n4.  位于 $z=z_2=0.05\\,\\mathrm{m}$ 处的第二个共轴线圈（电流 $I_2=12000\\,\\mathrm{A}$，半径 $a=0.5\\,\\mathrm{m}$）因位于 $z=0$ 处的第一个线圈（电流 $I_1=15000\\,\\mathrm{A}$）而受到的合力。\n\n对于前三种情况的每一种，计算磁场矢量 $\\mathbf{B}$（单位：特斯拉）。对于第四种情况，计算合力矢量 $\\mathbf{F}$（单位：牛顿）。您的程序应生成单行输出，其中包含一个以逗号分隔的结果列表，并用方括号括起来，其中每个条目是包含三个浮点数的列表：\n$$\n[\\,[B_{x,1},B_{y,1},B_{z,1}],\\,[B_{x,2},B_{y,2},B_{z,2}],\\,[B_{x,3},B_{y,3},B_{z,3}],\\,[F_x,F_y,F_z]\\,].\n$$\n所有角度必须以弧度处理。所有物理量必须以国际单位制（SI）表示。数值必须作为浮点数返回。最终的打印输出必须只包含这一行嵌套的结果列表，不带任何额外的解释性文本。",
            "solution": "该问题要求数值计算由圆形丝状电流回路产生的磁场 $\\mathbf{B}$ 以及两个共轴回路之间的磁力 $\\mathbf{F}$。这是通过使用稳健的数值求积方案计算 Biot-Savart 定律和洛伦兹力定律积分来实现的。问题的核心在于处理当观测点靠近载流导线时，Biot-Savart 被积函数的近奇异行为。\n\n**1. 参数化表示与控制方程**\n\n一个半径为 $a$、位于 $z=0$ 平面且以原点为中心的圆形丝状线圈，可以通过角度 $\\phi \\in [0, 2\\pi]$ 进行参数化。线圈上的源点 $\\boldsymbol{\\ell}$ 由下式给出：\n$$\n\\boldsymbol{\\ell}(\\phi) = (a \\cos\\phi, a \\sin\\phi, 0)\n$$\n微分线元 $d\\boldsymbol{\\ell}$ 与线圈相切，通过对 $\\boldsymbol{\\ell}(\\phi)$ 关于参数 $\\phi$ 求导得到：\n$$\nd\\boldsymbol{\\ell} = \\frac{d\\boldsymbol{\\ell}}{d\\phi}d\\phi = (-a \\sin\\phi, a \\cos\\phi, 0) d\\phi\n$$\nBiot-Savart 定律给出了线圈中稳恒电流 $I$ 在观测点 $\\mathbf{r}=(x, y, z)$ 处产生的磁场 $\\mathbf{B}$：\n$$\n\\mathbf{B}(\\mathbf{r}) = \\frac{\\mu_0 I}{4\\pi}\\int_{\\mathcal{C}} \\frac{d\\boldsymbol{\\ell} \\times \\mathbf{R}}{R^3}\n$$\n其中 $\\mathbf{R} = \\mathbf{r} - \\boldsymbol{\\ell}(\\phi)$ 是从源点到观测点的矢量，$R = \\|\\mathbf{R}\\|$。代入参数化形式，积分变为：\n$$\n\\mathbf{B}(\\mathbf{r}) = \\frac{\\mu_0 I}{4\\pi} \\int_0^{2\\pi} \\frac{(d\\boldsymbol{\\ell}/d\\phi) \\times (\\mathbf{r} - \\boldsymbol{\\ell}(\\phi))}{\\|\\mathbf{r} - \\boldsymbol{\\ell}(\\phi)\\|^3} d\\phi\n$$\n这是一个关于参数 $\\phi$ 的矢量值定积分。被积函数是一个矢量函数 $\\mathbf{f}(\\phi) = (f_x(\\phi), f_y(\\phi), f_z(\\phi))$，每个分量都必须进行数值积分。\n\n由第一个线圈的磁场 $\\mathbf{B}_1$ 施加于带有电流 $I_2$ 的第二个线圈 $\\mathcal{C}_2$ 上的洛伦兹力为：\n$$\n\\mathbf{F} = I_2 \\int_{\\mathcal{C}_2} d\\boldsymbol{\\ell}_2 \\times \\mathbf{B}_1(\\boldsymbol{\\ell}_2)\n$$\n对于共轴设置，轴对称性带来了显著的简化，这将在第4节中讨论。\n\n**2. 数值求积策略：复合高斯求积法**\n\n积分采用复合 Gauss-Legendre 求积法计算。积分域 $[0, 2\\pi]$被划分为多个较小的区间，即“面板”（panels）。在每个面板 $[\\phi_a, \\phi_b]$上，应用一个 $N_p$ 点的 Gauss-Legendre 求积法则。该法则通过加权和来近似积分：\n$$\n\\int_{\\phi_a}^{\\phi_b} f(\\phi) d\\phi \\approx \\frac{\\phi_b - \\phi_a}{2} \\sum_{i=1}^{N_p} w_i f\\left(\\frac{\\phi_b - \\phi_a}{2} \\xi_i + \\frac{\\phi_a + \\phi_b}{2}\\right)\n$$\n其中 $\\xi_i$ 和 $w_i$ 是区间 $[-1, 1]$ 上的标准 Gauss-Legendre 节点和权重。对于光滑的被积函数，此方法非常精确。\n\n**3. 针对近奇点的自适应细化**\n\n主要的数值挑战在于当观测点 $\\mathbf{r}$ 非常靠近线圈时 Biot-Savart 被积函数的行为。分母 $R^3 = \\|\\mathbf{r} - \\boldsymbol{\\ell}(\\phi)\\|^3$ 趋近于零，导致被积函数出现尖峰。均匀的求积网格需要极大量的点才能准确解析这个尖峰。\n\n为了克服这个问题，采用了自适应网格细化策略。细化基于一个几何准则：\n1.  观测点在柱坐标系中的方位角 $\\phi_{obs} = \\operatorname{atan2}(y, x)$，对应于线圈上与观测点在 $xy$ 平面上的投影最接近的点。\n2.  积分区间 $[0, 2\\pi]$ 最初被划分为一组面板。\n3.  检查每个面板是否需要细化。如果一个面板 $[\\phi_a, \\phi_b]$ 包含最接近区域，并且从 $\\mathbf{r}$ 到该面板内线圈段的最小距离 $R_{min}$ 与面板的弧长 $a(\\phi_b - \\phi_a)$ 相比很小，则该面板被细分。一个典型的准则是，如果 $R_{min}  C \\cdot a(\\phi_b - \\phi_a)$（对于一个选定的常数 $C > 1$），则进行细分。\n4.  这个过程被递归应用，创建一个在 $\\phi_{obs}$ 附近非常精细而在其他地方较粗糙的非均匀面板网格。这将计算量集中在被积函数变化最快的地方，从而确保了准确性和效率。\n\n**4. 通过对称性计算力**\n\n对于两个共轴线圈，力的计算可以大大简化。设线圈1位于 $z=0$，线圈2位于 $z=z_2$，两者半径均为 $a$。力为 $\\mathbf{F} = I_2 \\int_0^{2\\pi} (d\\boldsymbol{\\ell}_2/d\\phi_2) \\times \\mathbf{B}_1(\\boldsymbol{\\ell}_2(\\phi_2)) d\\phi_2$。\n\n由于轴对称性，在第二个线圈上的任何一点 $\\boldsymbol{\\ell}_2(\\phi_2) = (a \\cos\\phi_2, a \\sin\\phi_2, z_2)$ 处的磁场 $\\mathbf{B}_1$，在一个与该点对齐的柱坐标系中，仅有径向和轴向分量。这些分量的大小 $B_\\rho$ 和 $B_z$ 对线圈2上的所有点都是恒定的。在笛卡尔坐标系中，场矢量为 $\\mathbf{B}_1(\\phi_2) = (B_\\rho \\cos\\phi_2, B_\\rho \\sin\\phi_2, B_z)$，其中 $B_\\rho$ 和 $B_z$ 可以通过计算单个点（例如 $(a, 0, z_2)$）处的场来找到。在该点，$B_\\rho = B_x$。\n\n微分力元为 $d\\mathbf{F} = I_2 (d\\boldsymbol{\\ell}_2/d\\phi_2) \\times \\mathbf{B}_1 d\\phi_2$。执行叉乘并在 $\\phi_2 \\in [0, 2\\pi]$ 上积分：\n$$\nd\\mathbf{F} = I_2 \\left( (a B_z \\cos\\phi_2)\\mathbf{\\hat{i}} + (a B_z \\sin\\phi_2)\\mathbf{\\hat{j}} - (a B_\\rho)\\mathbf{\\hat{k}} \\right) d\\phi_2\n$$\n$\\cos\\phi_2$ 和 $\\sin\\phi_2$ 项在 $[0, 2\\pi]$ 上的积分为零。因此，净横向力（$F_x, F_y$）为零，这与对称性的预期相符。净轴向力为：\n$$\n\\mathbf{F} = \\int_0^{2\\pi} I_2 (-a B_\\rho) \\mathbf{\\hat{k}} d\\phi_2 = -2\\pi a I_2 B_\\rho \\mathbf{\\hat{k}}\n$$\n因此，总力可以通过仅计算第二个线圈上一点（例如 $\\mathbf{r} = (a, 0, z_2)$）的磁场 $\\mathbf{B}_1$，取其径向分量（在该点为 $B_x$），并应用 $F_z$ 的公式来求得。\n\n**5. 针对线圈上奇点的正则化**\n\n该问题要求概述如何处理观测点 $\\mathbf{r}$ *恰好* 位于丝状线圈上的情况。在这个理想化的模型中，$\\mathbf{B}$ 的积分是发散的。这是零厚度假设所导致的一个非物理假象。\n\n为了获得有物理意义的结果，必须对积分进行正则化。一种常见的方法是**奇点减去法**（singularity subtraction）。其步骤如下：\n1.  识别奇点 $\\phi_0$，使得 $\\boldsymbol{\\ell}(\\phi_0) = \\mathbf{r}$。\n2.  用一个能捕捉到相同奇异行为但可以解析积分的更简单的函数 $f_{sing}(\\phi)$ 来近似 $\\phi_0$ 附近的被积函数 $f(\\phi)$。对于弯曲导线，局部奇异行为类似于在 $\\phi_0$ 处与曲线相切的无限长直导线的行为。\n3.  将积分重写为：\n    $$\n    \\int_0^{2\\pi} f(\\phi) d\\phi = \\int_0^{2\\pi} (f(\\phi) - f_{sing}(\\phi)) d\\phi + \\int_0^{2\\pi} f_{sing}(\\phi) d\\phi\n    $$\n4.  第一项，即“正则化积分”，其奇点已被抵消。被积函数现在是良态的，可以用数值求积法精确计算。\n5.  第二项，即“奇异部分”，进行解析计算。这两部分之和给出了场的正则化值，这对应于一个物理模型（例如，在有限半径导线中心处的场）。\n这种方法将积分中有问题的部分分离出来进行解析处理，留下一个良态的数值问题。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\n\n# Physical constants\nMU_0 = 4 * np.pi * 1.0e-7  # Magnetic permeability of free space (T*m/A)\n\ndef _gauss_legendre_quad(func, panel, n_points, func_args):\n    \"\"\"\n    Performs N-point Gauss-Legendre quadrature on a single panel.\n    \n    Args:\n        func: The vector-valued function to integrate.\n        panel: A tuple (a, b) defining the integration interval.\n        n_points: The number of Gaussian points to use.\n        func_args: A tuple of additional arguments to pass to func.\n\n    Returns:\n        np.ndarray: The result of the vector integration.\n    \"\"\"\n    a, b = panel\n    nodes, weights = roots_legendre(n_points)\n    \n    # Map nodes from [-1, 1] to [a, b]\n    mapped_nodes = 0.5 * (b - a) * nodes + 0.5 * (b + a)\n    \n    # Evaluate the function at all mapped nodes\n    # The function is expected to return a (3, k) array where k is the number of nodes\n    f_vals = func(mapped_nodes, *func_args)\n    \n    # Perform the weighted sum for each component (x, y, z)\n    integral_val = 0.5 * (b - a) * np.sum(f_vals * weights[np.newaxis, :], axis=1)\n    \n    return integral_val\n\ndef _calculate_b_integrand(phi, r_obs, a):\n    \"\"\"\n    Calculates the vector integrand of the Biot-Savart law for a circular coil.\n    Expects phi to be a numpy array of evaluation points.\n\n    Args:\n        phi (np.ndarray): Array of angles (source point parameter).\n        r_obs (np.ndarray): Observation point (x, y, z).\n        a (float): Radius of the coil.\n\n    Returns:\n        np.ndarray: A (3, N) array of the vector integrand values.\n    \"\"\"\n    # Source points l(phi) = (a*cos(phi), a*sin(phi), 0)\n    # The shape of phi is (k,), so l_vec has shape (3, k)\n    l_vec = np.array([a * np.cos(phi), a * np.sin(phi), np.zeros_like(phi)])\n    \n    # Differential line elements dl(phi)/dphi = (-a*sin(phi), a*cos(phi), 0)\n    dl_dphi = np.array([-a * np.sin(phi), a * np.cos(phi), np.zeros_like(phi)])\n    \n    # Vector R from source to observation point: R = r_obs - l(phi)\n    # r_obs has shape (3,), we reshape to (3, 1) for broadcasting with l_vec (3, k)\n    r_vec = r_obs.reshape(3, 1) - l_vec\n    \n    # Magnitude of R, with a small epsilon to avoid division by zero if r_obs is on the coil\n    r_mag = np.linalg.norm(r_vec, axis=0)\n    # Add a small machine-epsilon-level value for absolute stability on-coil.\n    r_mag[r_mag == 0] = 1e-15\n\n    # Integrand: (dl/dphi x R) / |R|^3\n    cross_product = np.cross(dl_dphi, r_vec, axisa=0, axisb=0, axisc=0)\n    integrand = cross_product / r_mag**3\n    \n    return integrand\n\ndef calculate_b(r_obs, a, I, n_gauss_points=16, initial_panels=16, refinement_factor=2.0, max_depth=15):\n    \"\"\"\n    Calculates the magnetic field B at an observation point r_obs.\n\n    Uses composite Gauss quadrature with adaptive panel refinement based on\n    proximity to the coil.\n    \"\"\"\n    r_obs = np.array(r_obs, dtype=float)\n    \n    # List to store the final panel intervals for integration\n    final_panels = []\n    \n    # Initial queue of panels to process for refinement\n    # Panel is defined by (start_angle, end_angle, depth)\n    panel_queue = [(i * 2 * np.pi / initial_panels, (i + 1) * 2 * np.pi / initial_panels, 0) for i in range(initial_panels)]\n\n    # Cylindrical coordinates of observation point for distance checking\n    rho_obs = np.sqrt(r_obs[0]**2 + r_obs[1]**2)\n    phi_obs = np.arctan2(r_obs[1], r_obs[0])\n    if phi_obs  0:\n        phi_obs += 2 * np.pi\n\n    while panel_queue:\n        phi_start, phi_end, depth = panel_queue.pop(0)\n\n        # Find minimum distance from r_obs to the coil segment in this panel\n        min_dist_sq = -1.0\n        if phi_start = phi_obs  phi_end:\n            # Point of closest approach is inside the panel's angular range\n            min_dist_sq = (rho_obs - a)**2 + r_obs[2]**2\n        else:\n            # Check endpoints\n            l_start = np.array([a * np.cos(phi_start), a * np.sin(phi_start), 0.0])\n            l_end = np.array([a * np.cos(phi_end), a * np.sin(phi_end), 0.0])\n            dist_sq_start = np.sum((r_obs - l_start)**2)\n            dist_sq_end = np.sum((r_obs - l_end)**2)\n            min_dist_sq = min(dist_sq_start, dist_sq_end)\n\n        min_dist = np.sqrt(min_dist_sq)\n\n        # Refinement condition\n        panel_arc_length = a * (phi_end - phi_start)\n        if depth  max_depth and min_dist  refinement_factor * panel_arc_length:\n            phi_mid = (phi_start + phi_end) / 2\n            panel_queue.append((phi_start, phi_mid, depth + 1))\n            panel_queue.append((phi_mid, phi_end, depth + 1))\n        else:\n            final_panels.append((phi_start, phi_end))\n\n    # Integrate over all the final panels\n    b_integral = np.zeros(3)\n    for panel in final_panels:\n        b_integral += _gauss_legendre_quad(\n            _calculate_b_integrand, panel, n_gauss_points, (r_obs, a)\n        )\n\n    return (MU_0 * I / (4 * np.pi)) * b_integral\n\ndef calculate_f(a, I1, I2, z2):\n    \"\"\"\n    Calculates the force on a second coaxial coil.\n    \"\"\"\n    # By symmetry, we only need the field at one point on the second coil,\n    # e.g., at (a, 0, z2), to find the total force.\n    r_obs_force = np.array([a, 0.0, z2])\n    \n    # Calculate B-field from coil 1 at this point\n    # Parameters for high accuracy required for this near-singular case\n    b_field = calculate_b(r_obs_force, a, I1, n_gauss_points=32, initial_panels=32, refinement_factor=2.0, max_depth=20)\n    \n    # The radial component of the B-field is B_x at (a, 0, z2)\n    b_radial = b_field[0]\n    \n    # Force F_z = -2 * pi * a * I2 * B_radial\n    # F_x and F_y are zero by symmetry.\n    fz = -2 * np.pi * a * I2 * b_radial\n    \n    return np.array([0.0, 0.0, fz])\n\ndef solve():\n    # Define the test cases from the problem statement.\n    a = 0.5  # m\n    I1 = 15000.0  # A\n\n    test_cases = [\n        {'type': 'B', 'params': {'r_obs': (0.0, 0.0, 0.1), 'a': a, 'I': I1}},\n        {'type': 'B', 'params': {'r_obs': (0.49, 0.0, 0.0), 'a': a, 'I': I1}},\n        {'type': 'B', 'params': {'r_obs': (1.5, 0.0, 0.2), 'a': a, 'I': I1}},\n        {'type': 'F', 'params': {'a': a, 'I1': I1, 'I2': 12000.0, 'z2': 0.05}}\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'B':\n            result = calculate_b(**case['params'])\n        elif case['type'] == 'F':\n            result = calculate_f(**case['params'])\n        # Convert to a standard list of floats for the output format\n        results.append([float(f) for f in result])\n\n    # Final print statement in the exact required format.\n    # The format uses list-of-lists, so we convert python lists to string representation.\n    # Note: Using repr() on each list ensures the correct bracket format.\n    print(f\"[{','.join(map(repr, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "计算物理中的一个关键步骤是数值代码的验证。本实践介绍了一个经典的基准问题——置于均匀磁场中的电流线圈，其净受力在解析上已知为零。通过比较三种独立方法（洛伦兹力直接积分、麦克斯韦应力张量积分和能量梯度法）的计算结果，您不仅可以验证程序的正确性，还能深入理解这些强大的力计算方法在概念和计算上的差异。",
            "id": "3970467",
            "problem": "一个真空中的圆形电流环被置于一个外部施加的均匀磁场中。目标是构建一个数值基准，该基准基于第一性原理，通过三种独立的方法计算环上的净电磁力，并将其输出与规定的容差进行比较。这三种方法是：洛伦兹力的线积分（毕奥-萨伐尔定律用于计算外部场中电流元受力的方法）、麦克斯韦应力张量的数值面积分（在球形控制面上进行有限元法（FEM）风格的离散化），以及基于磁偶极子能量的能量梯度法。该基准必须实现为一个完整的、可运行的程序，并生成一个单行输出，汇总所有测试用例的结果。\n\n使用的基本原理：\n- 电流元的洛伦兹力定律指出，线电流在磁场 $\\mathbf{B}$ 中受到的无穷小力 $d\\mathbf{F}$ 为 $d\\mathbf{F} = I\\,d\\boldsymbol{\\ell} \\times \\mathbf{B}$，其中 $I$ 是电流，$d\\boldsymbol{\\ell}$ 是沿导线的无穷小有向长度元。\n- 麦克斯韦应力张量定义为 $\\mathbf{T} = \\frac{1}{\\mu_0}\\left(\\mathbf{B}\\mathbf{B}^\\top - \\frac{1}{2}|\\mathbf{B}|^2\\mathbf{I}\\right)$，其中 $\\mu_0$ 是自由空间磁导率，$\\mathbf{I}$ 是单位张量，$\\mathbf{B}\\mathbf{B}^\\top$ 是外积。由外法线为 $\\mathbf{n}$ 的闭合曲面所包围的物质上的净电磁力 $\\mathbf{F}$ 由 $\\mathbf{F} = \\oint_S \\mathbf{T}\\cdot\\mathbf{n}\\,dS$ 给出。\n- 平面环的磁偶极矩为 $\\mathbf{m} = I\\,A\\,\\mathbf{n}$，其中 $A$ 是环的面积，$\\mathbf{n}$ 是环平面的单位法向量。磁场中的磁能为 $U = -\\mathbf{m}\\cdot\\mathbf{B}$，力为 $\\mathbf{F} = \\nabla(\\mathbf{m}\\cdot\\mathbf{B})$。\n\n待实现的问题描述：\n- 考虑一个半径为 $R$、携带稳定电流 $I$ 的单个圆形环，环心位于原点，环平面单位法向量为 $\\mathbf{n}$。外部施加的场 $\\mathbf{B}_0$ 是空间均匀且不随时间变化的。真空磁导率为 $\\mu_0 = 4\\pi\\times10^{-7}\\,\\mathrm{H/m}$。\n- 方法 $1$（外部场中电流元所受的毕奥-萨伐尔力）：通过角度 $\\phi$ 对环进行参数化，并将环离散化为 $N_{\\text{loop}}$ 个段，数值计算闭合线积分 $I\\,d\\boldsymbol{\\ell}\\times \\mathbf{B}_0$。这将得到一个以 $\\mathrm{N}$ 为单位的净力矢量。\n- 方法 $2$（有限元法风格的麦克斯韦应力张量面积分）：使用一个由 $N_\\theta$ 个极向分割和 $N_\\phi$ 个方位角分割离散化的球坐标网格，在以原点为中心、半径为 $R_s$ 的球面上数值近似计算 $\\oint_S \\mathbf{T}(\\mathbf{B}_0)\\cdot\\mathbf{n}\\,dS$。在每个曲面点上使用外部场 $\\mathbf{B}_0$ 定义张量。这将得到一个以 $\\mathrm{N}$ 为单位的净力矢量。\n- 方法 $3$（能量梯度）：计算 $\\mathbf{m} = I\\,\\pi R^2\\,\\mathbf{n}$，并使用对称步长 $h$ 在每个笛卡尔方向上评估 $\\nabla(\\mathbf{m}\\cdot\\mathbf{B}_0)$ 的有限差分近似，以获得以 $\\mathrm{N}$ 为单位的净力矢量。\n- 单位：所有力必须以 $\\mathrm{N}$ 计算，长度以 $\\mathrm{m}$ 计算，电流以 $\\mathrm{A}$ 计算，磁场以 $\\mathrm{T}$ 计算；角度以弧度为单位。\n\n测试套件规范：\n- 案例 $1$ (基准): $R = 0.5\\,\\mathrm{m}$，$I = 10{,}000\\,\\mathrm{A}$，$\\mathbf{B}_0 = (2.0, 0.0, 0.0)\\,\\mathrm{T}$，$\\mathbf{n} = (1.0, 0.0, 0.0)$，$R_s = 1.0\\,\\mathrm{m}$，$N_{\\text{loop}} = 2000$，$N_\\theta = 60$，$N_\\phi = 120$，$h = 10^{-4}\\,\\mathrm{m}$，力大小的绝对容差 $t_f = 10^{-4}\\,\\mathrm{N}$，两两一致性容差 $t_a = 5\\times10^{-5}\\,\\mathrm{N}$。\n- 案例 $2$ (倾斜方向): $R = 0.7\\,\\mathrm{m}$，$I = 5000\\,\\mathrm{A}$，$\\mathbf{B}_0 = (1.0, 1.0, 0.0)\\,\\mathrm{T}$，$\\mathbf{n} = (0.0, 0.0, 1.0)$，$R_s = 1.2\\,\\mathrm{m}$，$N_{\\text{loop}} = 1500$，$N_\\theta = 60$，$N_\\phi = 120$，$h = 5\\times10^{-5}\\,\\mathrm{m}$，$t_f = 2\\times10^{-4}\\,\\mathrm{N}$，$t_a = 10^{-4}\\,\\mathrm{N}$。\n- 案例 $3$ (小尺度/大电流): $R = 10^{-6}\\,\\mathrm{m}$，$I = 10^{6}\\,\\mathrm{A}$，$\\mathbf{B}_0 = (0.5, -0.3, 0.2)\\,\\mathrm{T}$，$\\mathbf{n} = (0.577350269, 0.577350269, 0.577350269)$，$R_s = 2\\times10^{-2}\\,\\mathrm{m}$，$N_{\\text{loop}} = 400$，$N_\\theta = 60$，$N_\\phi = 120$，$h = 10^{-6}\\,\\mathrm{m}$，$t_f = 10^{-3}\\,\\mathrm{N}$，$t_a = 5\\times10^{-4}\\,\\mathrm{N}$。\n\n验证任务：\n- 对于每个案例，计算三个力矢量。验证每个方法独立产生的力的大小是否小于 $t_f$，以及所有力矢量之间的两两差值的大小是否小于 $t_a$。对于每个案例，如果两个条件都满足，则返回布尔值 $\\mathrm{True}$，否则返回 $\\mathrm{False}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 $[\\mathrm{result}_1,\\mathrm{result}_2,\\mathrm{result}_3]$，其中每个 $\\mathrm{result}_i$ 是遵循上述验证规则的案例 $i$ 的布尔值。",
            "solution": "问题陈述被评估为**有效**。它提出了一个在计算电磁学领域中定义明确且具有科学依据的任务。该问题要求建立一个数值基准，用于比较三种计算均匀外磁场中圆形电流环所受电磁力的独立方法。该场景是一个标准的教科书案例，其净力的解析解已知为零。因此，该问题可作为对不同计算物理算法的数值准确性和一致性的验证测试。所提供的数据、参数和验证标准是完整、一致和客观的。\n\n**解析基准真相**\n对于一个处于空间均匀磁场 $\\mathbf{B}_0$ 中的闭合电流环（电流为 $I$），其所受的净电磁力在解析上为零。这可以从洛伦兹力定律推导得出：\n$$ \\mathbf{F} = \\oint I \\, d\\boldsymbol{\\ell} \\times \\mathbf{B}_0 $$\n由于电流 $I$ 和磁场 $\\mathbf{B}_0$ 在积分路径上都是恒定的，它们可以从积分中提出：\n$$ \\mathbf{F} = I \\left( \\oint d\\boldsymbol{\\ell} \\right) \\times \\mathbf{B}_0 $$\n路径元 $d\\boldsymbol{\\ell}$ 沿任何闭合环路的矢量积分为零矢量，即 $\\oint d\\boldsymbol{\\ell} = \\mathbf{0}$。因此，净力为零：\n$$ \\mathbf{F} = I (\\mathbf{0}) \\times \\mathbf{B}_0 = \\mathbf{0} $$\n在无限离散化的极限下，所有三种数值方法都应得出这个零结果。实际实现将测试在给定的数值参数下，它们的结果多接近于零以及彼此之间的一致性。\n\n**方法1：洛伦兹力线积分**\n此方法直接近似积分 $\\mathbf{F} = \\oint I \\, d\\boldsymbol{\\ell} \\times \\mathbf{B}_0$。半径为 $R$ 的圆形环被离散化为 $N_{\\text{loop}}$ 个直线段。\n首先，构建一个标准正交基 $(\\mathbf{u}, \\mathbf{v}, \\mathbf{n})$，其中 $\\mathbf{n}$ 是给定的环法线，$(\\mathbf{u}, \\mathbf{v})$ 张成环所在的平面。环上的一个点可以通过角度 $\\phi \\in [0, 2\\pi]$ 进行参数化：\n$$ \\mathbf{r}(\\phi) = R(\\cos\\phi \\, \\mathbf{u} + \\sin\\phi \\, \\mathbf{v}) $$\n通过取 $N_{\\text{loop}}$ 个点 $\\mathbf{r}_k = \\mathbf{r}(k \\cdot 2\\pi/N_{\\text{loop}})$（其中 $k = 0, 1, \\dots, N_{\\text{loop}}$）来离散化环路。第 $k$ 个线元矢量为 $\\Delta\\boldsymbol{\\ell}_k = \\mathbf{r}_{k+1} - \\mathbf{r}_k$。总力则通过计算每个段上力的矢量和得出：\n$$ \\mathbf{F}_1 \\approx \\sum_{k=0}^{N_{\\text{loop}}-1} I (\\Delta\\boldsymbol{\\ell}_k \\times \\mathbf{B}_0) $$\n在数值上，和 $\\sum \\Delta\\boldsymbol{\\ell}_k$ 将是一个接近零的小矢量，导致力矢量 $\\mathbf{F}_1$ 的大小预计会很小。\n\n**方法2：麦克斯韦应力张量面积分**\n此方法通过在包围电流环的封闭控制曲面 $S$ 上对麦克斯韦应力张量 $\\mathbf{T}$ 进行积分来计算力。问题指定仅使用由外部场 $\\mathbf{B}_0$ 定义的张量：\n$$ \\mathbf{T}(\\mathbf{B}_0) = \\frac{1}{\\mu_0}\\left(\\mathbf{B}_0\\mathbf{B}_0^\\top - \\frac{1}{2}|\\mathbf{B}_0|^2\\mathbf{I}\\right) $$\n其中 $\\mu_0$ 是自由空间磁导率，$\\mathbf{I}$ 是 $3 \\times 3$ 单位张量。总力由面积分给出：\n$$ \\mathbf{F}_2 = \\oint_S \\mathbf{T}(\\mathbf{B}_0)\\cdot\\mathbf{n}_{\\text{surf}}\\,dS $$\n由于 $\\mathbf{B}_0$ 是均匀的，张量 $\\mathbf{T}(\\mathbf{B}_0)$ 是恒定的。积分简化为 $\\mathbf{F}_2 = \\mathbf{T}(\\mathbf{B}_0) \\cdot \\oint_S \\mathbf{n}_{\\text{surf}}\\,dS$。外法线向量 $\\mathbf{n}_{\\text{surf}}$ 在任何闭合曲面上的积分都为零。因此，解析结果为 $\\mathbf{F}_2 = \\mathbf{0}$。\n对于数值实现，指定的半径为 $R_s$ 的球形控制曲面使用球坐标 $(\\theta, \\phi)$ 被离散化为 $N_\\theta \\times N_\\phi$ 个面元。对于每个以 $(\\theta_i, \\phi_j)$ 为中心的面元，计算其面积 $\\Delta S_{ij} = R_s^2 \\sin\\theta_i \\Delta\\theta \\Delta\\phi$ 和法向量 $\\mathbf{n}_{ij}$。总力通过求和近似得到：\n$$ \\mathbf{F}_2 \\approx \\sum_{i=0}^{N_{\\theta}-1} \\sum_{j=0}^{N_{\\phi}-1} (\\mathbf{T}(\\mathbf{B}_0) \\cdot \\mathbf{n}_{ij}) \\Delta S_{ij} $$\n这个和近似于 $\\mathbf{T}(\\mathbf{B}_0) \\cdot (\\sum \\mathbf{n}_{ij} \\Delta S_{ij})$，由于面积加权法线的和近似为零矢量，因此得到的力 $\\mathbf{F}_2$ 应接近于零。\n\n**方法3：能量梯度法**\n此方法基于磁偶极子 $\\mathbf{m}$ 在磁场 $\\mathbf{B}$ 中的势能 $U$，其中力由 $\\mathbf{F} = \\nabla(\\mathbf{m}\\cdot\\mathbf{B})$ 给出。对于平面电流环，磁偶极矩为 $\\mathbf{m} = I A \\mathbf{n} = I (\\pi R^2) \\mathbf{n}$。此偶极子在位置 $\\mathbf{r}$ 处的外部场 $\\mathbf{B}_0$ 中的势能为 $U(\\mathbf{r}) = -\\mathbf{m} \\cdot \\mathbf{B}_0(\\mathbf{r})$。\n由于场 $\\mathbf{B}_0$ 是均匀的，它不随位置变化，即 $\\mathbf{B}_0(\\mathbf{r})$ 是一个常数矢量。因此，势能 $U$ 在整个空间中是恒定的，其梯度为零：\n$$ \\mathbf{F}_3 = \\nabla U = \\nabla(-\\mathbf{m}\\cdot\\mathbf{B}_0) = \\mathbf{0} $$\n数值方法使用步长为 $h$ 的对称有限差分格式来近似梯度。例如，力的 $x$ 分量为：\n$$ F_{3,x} \\approx \\frac{U(\\mathbf{r} + (h/2)\\hat{\\mathbf{x}}) - U(\\mathbf{r} - (h/2)\\hat{\\mathbf{x}})}{h} $$\n由于 $U$ 在空间上是恒定的，分子在解析上为零。因此，数值计算将得出 $\\mathbf{F}_3 = \\mathbf{0}$，其精度受限于浮点精度。\n\n**验证**\n对于每个测试案例，计算出的三个力矢量 $\\mathbf{F}_1$、$\\mathbf{F}_2$ 和 $\\mathbf{F}_3$ 都需要经过两项检查。\n1. 力大小检查：每个力矢量的大小必须小于给定的绝对容差 $t_f$。\n   $$ |\\mathbf{F}_i|  t_f \\quad \\text{for } i \\in \\{1, 2, 3\\} $$\n2. 两两一致性检查：任意两种方法得到的力矢量之差的大小必须小于给定的一致性容差 $t_a$。\n   $$ |\\mathbf{F}_i - \\mathbf{F}_j|  t_a \\quad \\text{for } i, j \\in \\{1, 2, 3\\}, i \\neq j $$\n只有当两个条件都满足时，测试案例才通过并返回 $\\mathrm{True}$。否则，它将失败并返回 $\\mathrm{False}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.constants import mu_0, pi\n\ndef calculate_force_lorentz(R, I, B0, n, N_loop):\n    \"\"\"\n    Computes the force on a circular loop using the integrated Lorentz force law.\n    Method 1.\n    \"\"\"\n    # Normalize the normal vector to be safe\n    n = n / np.linalg.norm(n)\n    \n    # Create an orthonormal basis (u, v, n) for the loop's plane.\n    # A robust way to find a perpendicular vector 'w' for the cross product\n    w = np.array([1.0, 0.0, 0.0])\n    if np.allclose(np.abs(n), w): # if n is parallel to x-axis\n        w = np.array([0.0, 1.0, 0.0])\n    \n    u = np.cross(w, n)\n    u /= np.linalg.norm(u)\n    v = np.cross(n, u)\n\n    # Discretize the loop into N_loop+1 points to get N_loop segments\n    phi_pts = np.linspace(0, 2 * pi, N_loop + 1, endpoint=True)\n    \n    # Points on the loop: r(phi) = R * (cos(phi) * u + sin(phi) * v)\n    r = R * (np.cos(phi_pts)[:, np.newaxis] * u + np.sin(phi_pts)[:, np.newaxis] * v)\n\n    # Line element vectors dl for each segment\n    dl_segments = r[1:] - r[:-1]\n    \n    # Force F = sum(I * dl x B0)\n    force = I * np.sum(np.cross(dl_segments, B0), axis=0)\n    \n    return force\n\ndef calculate_force_mst(B0, Rs, N_theta, N_phi):\n    \"\"\"\n    Computes the force using the Maxwell Stress Tensor surface integral.\n    Method 2.\n    \"\"\"\n    # Maxwell stress tensor for uniform external field B0\n    B0_outer = np.outer(B0, B0)\n    B0_mag_sq = np.dot(B0, B0)\n    identity = np.identity(3)\n    T = (1.0 / mu_0) * (B0_outer - 0.5 * B0_mag_sq * identity)\n    \n    # Discretize the spherical surface using midpoint rule for integration\n    d_theta = pi / N_theta\n    d_phi = 2 * pi / N_phi\n    \n    theta_centers = np.linspace(d_theta / 2.0, pi - d_theta / 2.0, N_theta)\n    phi_centers = np.linspace(d_phi / 2.0, 2 * pi - d_phi / 2.0, N_phi)\n\n    force = np.zeros(3)\n\n    for theta_i in theta_centers:\n        for phi_j in phi_centers:\n            # Surface element area at the patch center\n            dS = Rs**2 * np.sin(theta_i) * d_theta * d_phi\n            \n            # Outward normal vector at the patch center\n            nx = np.sin(theta_i) * np.cos(phi_j)\n            ny = np.sin(theta_i) * np.sin(phi_j)\n            nz = np.cos(theta_i)\n            normal = np.array([nx, ny, nz])\n            \n            # Force contribution: dF = T . n dS\n            dF = T @ normal * dS\n            force += dF\n            \n    return force\n\ndef calculate_force_energy(R, I, n, B0, h):\n    \"\"\"\n    Computes the force using the energy-gradient method.\n    Method 3.\n    \"\"\"\n    # Magnetic dipole moment\n    n_normalized = n / np.linalg.norm(n)\n    m = I * pi * R**2 * n_normalized\n    \n    # Potential energy U(pos) = -m . B(pos).\n    # Since B is uniform B0, U is constant.\n    def U_potential(pos, m_dipole, B_field):\n      # This function is written for generality, but B_field is constant.\n      return -np.dot(m_dipole, B_field)\n\n    # The finite difference of a constant function is zero to machine precision.\n    # We implement it symbolically for correctness.\n    Fx = (U_potential(np.array([h/2, 0, 0]), m, B0) - U_potential(np.array([-h/2, 0, 0]), m, B0)) / h\n    Fy = (U_potential(np.array([0, h/2, 0]), m, B0) - U_potential(np.array([0, -h/2, 0]), m, B0)) / h\n    Fz = (U_potential(np.array([0, 0, h/2]), m, B0) - U_potential(np.array([0, 0, -h/2]), m, B0)) / h\n    \n    force = np.array([Fx, Fy, Fz])\n    return force\n\ndef verify_case(forces, tf, ta):\n    \"\"\"\n    Verifies the computed forces against magnitude and agreement tolerances.\n    \"\"\"\n    F1, F2, F3 = forces\n\n    # Condition 1: Each force magnitude is less than tf\n    mag_cond = (np.linalg.norm(F1)  tf and \n                np.linalg.norm(F2)  tf and \n                np.linalg.norm(F3)  tf)\n\n    # Condition 2: Pairwise differences are less than ta\n    agree_cond = (np.linalg.norm(F1 - F2)  ta and\n                  np.linalg.norm(F1 - F3)  ta and\n                  np.linalg.norm(F2 - F3)  ta)\n\n    return mag_cond and agree_cond\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1 (baseline)\n        {\n            \"R\": 0.5, \"I\": 10000.0, \"B0\": np.array([2.0, 0.0, 0.0]),\n            \"n\": np.array([1.0, 0.0, 0.0]), \"Rs\": 1.0, \"N_loop\": 2000,\n            \"N_theta\": 60, \"N_phi\": 120, \"h\": 1e-4, \"tf\": 1e-4, \"ta\": 5e-5\n        },\n        # Case 2 (oblique orientation)\n        {\n            \"R\": 0.7, \"I\": 5000.0, \"B0\": np.array([1.0, 1.0, 0.0]),\n            \"n\": np.array([0.0, 0.0, 1.0]), \"Rs\": 1.2, \"N_loop\": 1500,\n            \"N_theta\": 60, \"N_phi\": 120, \"h\": 5e-5, \"tf\": 2e-4, \"ta\": 1e-4\n        },\n        # Case 3 (small scale/high current)\n        {\n            \"R\": 1e-6, \"I\": 1e6, \"B0\": np.array([0.5, -0.3, 0.2]),\n            \"n\": np.array([0.577350269, 0.577350269, 0.577350269]), \"Rs\": 2e-2,\n            \"N_loop\": 400, \"N_theta\": 60, \"N_phi\": 120, \"h\": 1e-6, \"tf\": 1e-3, \"ta\": 5e-4\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        F1 = calculate_force_lorentz(case[\"R\"], case[\"I\"], case[\"B0\"], case[\"n\"], case[\"N_loop\"])\n        F2 = calculate_force_mst(case[\"B0\"], case[\"Rs\"], case[\"N_theta\"], case[\"N_phi\"])\n        F3 = calculate_force_energy(case[\"R\"], case[\"I\"], case[\"n\"], case[\"B0\"], case[\"h\"])\n        \n        is_valid = verify_case([F1, F2, F3], case[\"tf\"], case[\"ta\"])\n        results.append(is_valid)\n        \n    print(f\"[{','.join(map(str, results))}]\".replace(\"True\", \"true\").replace(\"False\", \"false\"))\n\nsolve()\n```"
        },
        {
            "introduction": "除了简单的分析，计算工具对于工程设计和优化也是不可或缺的。这个高级实践将解决一个现实问题：优化线圈电流以最小化峰值结构力，同时满足特定的磁场目标。您将使用伴随法推导并实现一个复杂目标函数的梯度，这是一种对于解决聚变工程等领域中大規模、基于梯度的优化问题至关重要的高效技术。",
            "id": "3970528",
            "problem": "要求您为与计算聚变科学和工程中的电磁线圈力计算相关的优化问题，建立并验证一种基于伴随的梯度计算方法。考虑一个离散为 $M$ 个直导体段的线圈系统，其几何形状固定，电流 $\\{I_m\\}_{m=1}^M$ 未知。每个导体段 $m$ 的中心位置为 $\\mathbf{x}_m \\in \\mathbb{R}^3$，方向由单位向量 $\\hat{\\mathbf{s}}_m$ 给出，长度为 $L_m$，横截面积为 $A_m$。由线圈段在 $K$ 个目标点 $\\{\\mathbf{x}_k\\}_{k=1}^K$ 处产生的静磁场由毕奥-萨伐尔定律给出，其连续形式是一项基本定律：\n$$\n\\mathbf{B}(\\mathbf{x}) \\;=\\; \\frac{\\mu_0}{4\\pi} \\int \\frac{I\\, d\\boldsymbol{\\ell} \\times (\\mathbf{x}-\\mathbf{r})}{\\|\\mathbf{x}-\\mathbf{r}\\|^3} \\, ,\n$$\n其中 $\\mu_0$ 是自由空间磁导率。在使用 $N_q$ 个求积节点对每个直段进行离散化后，目标点处的法向分量（此处选择 $z$ 分量）是电流的线性函数，由矩阵 $\\mathbf{G} \\in \\mathbb{R}^{K\\times M}$ 描述：\n$$\n\\mathbf{b}(\\mathbf{I}) \\;=\\; \\mathbf{G}\\,\\mathbf{I} \\, ,\n$$\n其中 $\\mathbf{I} = [I_1,\\dots,I_M]^T$，$\\mathbf{b}(\\mathbf{I}) \\in \\mathbb{R}^K$ 汇集了 $K$ 个目标点处的 $z$ 分量。场性能约束是一个等式 $\\mathbf{G}\\,\\mathbf{I} = \\mathbf{b}_{\\mathrm{target}}$。\n\n由于给定的背景磁场 $\\mathbf{B}_{\\mathrm{back}}(\\mathbf{x})$（例如，环形背景场及其空间变化），每个导体段都会受到洛伦兹力密度。局部洛伦兹力密度是基本表达式：\n$$\n\\mathbf{f}(\\mathbf{x}) \\;=\\; \\mathbf{J}(\\mathbf{x}) \\times \\mathbf{B}(\\mathbf{x}) \\, .\n$$\n通过带平滑的 $\\ell_q$ 范数来近似导体段上的峰值，为导体段 $m$ 定义平滑后的局部大小：\n$$\nf_m(\\mathbf{I}) \\;=\\; \\frac{\\sqrt{I_m^2 + \\varepsilon^2}}{A_m}\\,\\big\\| \\hat{\\mathbf{s}}_m \\times \\mathbf{B}_{\\mathrm{back}}(\\mathbf{x}_m)\\big\\| \\, ,\n$$\n其中平滑参数 $\\varepsilon > 0$。峰值代理目标是 $\\ell_q$ 范数：\n$$\nF_q(\\mathbf{I}) \\;=\\; \\left( \\sum_{m=1}^M \\left[ f_m(\\mathbf{I}) \\right]^q \\right)^{1/q} \\, ,\n$$\n对于某个 $q \\ge 2$。为了在保持计算易处理性的同时强制执行场性能约束，考虑使用权重 $\\mu > 0$ 的二次惩罚公式：\n$$\nJ_{\\mu}(\\mathbf{I}) \\;=\\; F_q(\\mathbf{I}) \\;+\\; \\frac{\\mu}{2}\\,\\left\\| \\mathbf{G}\\,\\mathbf{I} - \\mathbf{b}_{\\mathrm{target}} \\right\\|_2^2 \\, .\n$$\n\n您的任务是：\n$1.$ 仅从上述基本定律（毕奥-萨伐尔定律和洛伦兹力密度）出发，使用伴随方法推导 $J_{\\mu}(\\mathbf{I})$ 相对于 $\\mathbf{I}$ 的梯度。清晰地引入一个伴随变量，并展示如何在不显式对前向映射进行超出初等线性代数运算的微分的情况下组合梯度。\n\n$2.$ 实现一个程序，该程序：\n$2.1.$ 通过将每个直段离散为 $N_q$ 个均匀求积节点，并为每个目标点评估毕奥-萨伐尔积分的 $z$ 分量，来数值化地构造 $\\mathbf{G}$（假设自由空间磁导率为 $\\mu_0 = 4\\pi \\times 10^{-7}$ in $\\mathrm{H/m}$）。\n$2.2.$ 将背景场 $\\mathbf{B}_{\\mathrm{back}}(\\mathbf{x})$ 定义为：\n$$\n\\mathbf{B}_{\\mathrm{back}}(x,y,z) \\;=\\; \\begin{bmatrix} 0.10\\,z \\\\ 0 \\\\ 1.50 \\;+\\; 0.05\\,x \\end{bmatrix} \\quad \\text{单位：特斯拉} \\, ,\n$$\n并在每个导体段中心对其求值，以计算 $\\big\\|\\hat{\\mathbf{s}}_m \\times \\mathbf{B}_{\\mathrm{back}}(\\mathbf{x}_m)\\big\\|$。\n$2.3.$ 使用以下固定的线圈几何形状和目标点：\n$M = 4$ 个直段，每个长度 $L_m = 0.40$ $\\mathrm{m}$，中心位于：\n$$\n\\mathbf{x}_1 = [-0.30,\\, 0.00,\\, 0.00]^T,\\;\\; \\mathbf{x}_2 = [-0.10,\\, 0.00,\\, 0.00]^T,\\;\\; \\mathbf{x}_3 = [0.10,\\, 0.00,\\, 0.00]^T,\\;\\; \\mathbf{x}_4 = [0.30,\\, 0.00,\\, 0.00]^T \\, ,\n$$\n所有 $m$ 的方向均为 $\\hat{\\mathbf{s}}_m = [0,\\,1,\\,0]^T$，横截面积为：\n$$\nA_1 = 5.0\\times 10^{-4},\\;\\; A_2 = 4.0\\times 10^{-4},\\;\\; A_3 = 6.0\\times 10^{-4},\\;\\; A_4 = 5.0\\times 10^{-4} \\quad \\text{单位：} \\mathrm{m}^2 \\, 。\n$$\n设 $K = 2$ 个目标点为：\n$$\n\\mathbf{x}_{\\mathrm{t},1} = [0.00,\\, 0.00,\\, 0.20]^T,\\qquad \\mathbf{x}_{\\mathrm{t},2} = [0.00,\\, 0.00,\\, 0.35]^T \\, .\n$$\n将目标 $z$ 分量（单位：特斯拉）定义为：\n$$\n\\mathbf{b}_{\\mathrm{target}} = \\begin{bmatrix} 1.0\\times 10^{-5} \\\\ -0.5\\times 10^{-5} \\end{bmatrix} \\, .\n$$\n对毕奥-萨伐尔离散化使用每个导体段 $N_q = 200$ 个求积节点。\n$2.4.$ 对于每个测试用例，通过求解吉洪诺夫正则化最小二乘问题来构造一个基准电流向量 $\\mathbf{I}$：\n$$\n\\mathbf{I}^\\star \\;=\\; \\arg\\min_{\\mathbf{I}} \\left\\| \\mathbf{G}\\,\\mathbf{I} - \\mathbf{b}_{\\mathrm{target}} \\right\\|_2^2 \\;+\\; \\alpha \\left\\| \\mathbf{I} \\right\\|_2^2 \\, ,\n$$\n其中 $\\alpha = 1.0\\times 10^{-6}$，并使用此 $\\mathbf{I}^\\star$ 来评估梯度。\n$2.5.$ 计算您在任务1中推导的基于伴随的梯度 $\\nabla J_{\\mu}(\\mathbf{I}^\\star)$，并使用步长为 $h$ 的中心有限差分近似进行验证，其每个分量为：\n$$\n\\left[\\nabla J_{\\mu}(\\mathbf{I}^\\star)\\right]_m \\;\\approx\\; \\frac{J_{\\mu}(\\mathbf{I}^\\star + h\\,\\mathbf{e}_m) - J_{\\mu}(\\mathbf{I}^\\star - h\\,\\mathbf{e}_m)}{2h} \\, ,\n$$\n其中 $\\{\\mathbf{e}_m\\}$ 是标准基。\n$2.6.$ 为每个测试用例报告相对梯度误差：\n$$\n\\mathrm{err} \\;=\\; \\frac{\\left\\|\\nabla J_{\\mu}^{\\mathrm{adj}} - \\nabla J_{\\mu}^{\\mathrm{FD}}\\right\\|_2}{\\max\\left(1, \\left\\|\\nabla J_{\\mu}^{\\mathrm{FD}}\\right\\|_2\\right)} \\, ,\n$$\n该误差是无量纲的。将所有报告的输出表示为不带单位的纯数字。\n\n测试套件。精确运行以下三个测试用例，每个用例由 $(q,\\mu,\\varepsilon,h)$ 指定：\n$1.$ $(4,\\, 5.0,\\, 1.0\\times 10^{-6},\\, 1.0\\times 10^{-7})$。\n$2.$ $(8,\\, 1.0,\\, 1.0\\times 10^{-8},\\, 5.0\\times 10^{-8})$。\n$3.$ $(16,\\, 0.5,\\, 1.0\\times 10^{-10},\\, 2.0\\times 10^{-8})$。\n\n最终输出格式。您的程序应生成单行输出，其中包含按测试用例顺序排列的三个相对梯度误差，格式为逗号分隔的列表并用方括号括起，例如 $[\\mathrm{err}_1,\\mathrm{err}_2,\\mathrm{err}_3]$。输出是无量纲的实数。",
            "solution": "该问题要求针对一个与聚变科学中电磁线圈设计相关的特定优化泛函 $J_{\\mu}(\\mathbf{I})$，推导并实现一种基于伴随的梯度计算方法。推导必须源于所提供的基本物理定律，并且实现必须通过与有限差分近似的对比进行验证。\n\n首先，使用伴随方法公式推导梯度 $\\nabla_{\\mathbf{I}} J_{\\mu}(\\mathbf{I})$。目标泛函为：\n$$\nJ_{\\mu}(\\mathbf{I}) = F_q(\\mathbf{I}) + \\frac{\\mu}{2}\\,\\left\\| \\mathbf{G}\\,\\mathbf{I} - \\mathbf{b}_{\\mathrm{target}} \\right\\|_2^2\n$$\n该泛函包含两项。第一项 $F_q(\\mathbf{I})$ 直接依赖于优化变量（电流 $\\mathbf{I}$）。第二项是一个二次惩罚项，它通过一个线性“前向映射” $\\mathbf{b}(\\mathbf{I}) = \\mathbf{G}\\mathbf{I}$ 依赖于 $\\mathbf{I}$，该映射表示离散化的毕奥-萨伐尔定律。$J_{\\mu}$ 的梯度是这两项梯度之和。\n\n我们首先从伴随的角度分析惩罚项。我们可以将泛函的这一部分写为 $P(\\mathbf{b}(\\mathbf{I}))$，其中状态变量是 $\\mathbf{b} \\in \\mathbb{R}^K$，目标部分是 $P(\\mathbf{b}) = \\frac{\\mu}{2}\\|\\mathbf{b} - \\mathbf{b}_{\\mathrm{target}}\\|_2^2$。将控制变量 $\\mathbf{I}$ 映射到状态变量 $\\mathbf{b}$ 的前向算子是 $\\mathbf{b}(\\mathbf{I}) = \\mathbf{G}\\mathbf{I}$。\n\n$P$ 相对于 $\\mathbf{I}$ 的全导数由链式法则给出：\n$$\n\\nabla_{\\mathbf{I}} P = \\left(\\frac{d\\mathbf{b}}{d\\mathbf{I}}\\right)^T \\frac{\\partial P}{\\partial \\mathbf{b}}\n$$\n项 $\\frac{d\\mathbf{b}}{d\\mathbf{I}}$ 是前向映射的雅可比矩阵，即矩阵 $\\mathbf{G}$。项 $\\frac{\\partial P}{\\partial \\mathbf{b}}$ 是目标函数相对于状态的梯度。在伴随方法的背景下，此项被定义为伴随变量 $\\boldsymbol{\\lambda}$。\n$$\n\\boldsymbol{\\lambda} \\equiv \\frac{\\partial P}{\\partial \\mathbf{b}} = \\nabla_{\\mathbf{b}} \\left( \\frac{\\mu}{2} (\\mathbf{b} - \\mathbf{b}_{\\mathrm{target}})^T (\\mathbf{b} - \\mathbf{b}_{\\mathrm{target}}) \\right) = \\mu (\\mathbf{b} - \\mathbf{b}_{\\mathrm{target}})\n$$\n代入 $\\mathbf{b}=\\mathbf{G}\\mathbf{I}$，伴随变量在前向求解之后计算得出：\n$$\n\\boldsymbol{\\lambda} = \\mu (\\mathbf{G}\\mathbf{I} - \\mathbf{b}_{\\mathrm{target}})\n$$\n然后，通过将伴随变量与前向映射的雅可比矩阵的转置相乘，来组合惩罚项相对于 $\\mathbf{I}$ 的梯度：\n$$\n\\nabla_{\\mathbf{I}} \\left( \\frac{\\mu}{2}\\,\\left\\| \\mathbf{G}\\,\\mathbf{I} - \\mathbf{b}_{\\mathrm{target}} \\right\\|_2^2 \\right) = \\mathbf{G}^T \\boldsymbol{\\lambda} = \\mu \\mathbf{G}^T (\\mathbf{G}\\mathbf{I} - \\mathbf{b}_{\\mathrm{target}})\n$$\n此公式展示了伴随方法的核心思想：导数对扰动 $\\delta\\mathbf{I}$ 的作用，是通过首先计算状态扰动 $\\delta\\mathbf{b} = \\mathbf{G}\\delta\\mathbf{I}$，然后与伴随变量 $\\boldsymbol{\\lambda}$ 进行内积来评估的，该伴随变量编码了目标对状态的敏感度。这转置为 $\\delta\\mathbf{I}^T (\\mathbf{G}^T \\boldsymbol{\\lambda})$ 以找到相对于 $\\mathbf{I}$ 的梯度。\n\n接下来，我们处理第一项 $F_q(\\mathbf{I})$，其定义为：\n$$\nF_q(\\mathbf{I}) = \\left( \\sum_{m=1}^M \\left[ f_m(\\mathbf{I}) \\right]^q \\right)^{1/q}\n$$\n由于每个 $f_m(\\mathbf{I})$ 仅依赖于相应的电流分量 $I_m$，其梯度可以通过应用链式法则直接计算。梯度 $\\nabla_{\\mathbf{I}} F_q(\\mathbf{I})$ 的第 $j$ 个分量是：\n$$\n\\frac{\\partial F_q}{\\partial I_j} = \\frac{1}{q} \\left( \\sum_{m=1}^M [f_m]^q \\right)^{\\frac{1}{q}-1} \\cdot q [f_j]^{q-1} \\frac{\\partial f_j}{\\partial I_j} = \\left( F_q(\\mathbf{I}) \\right)^{1-q} [f_j(\\mathbf{I})]^{q-1} \\frac{d f_j}{d I_j}\n$$\n导体段 $m$ 的力大小代理 $f_m$ 是：\n$$\nf_m(\\mathbf{I}) = \\frac{\\sqrt{I_m^2 + \\varepsilon^2}}{A_m}\\,\\big\\| \\hat{\\mathbf{s}}_m \\times \\mathbf{B}_{\\mathrm{back}}(\\mathbf{x}_m)\\big\\|\n$$\n其相对于 $I_m$ 的导数是：\n$$\n\\frac{d f_m}{d I_m} = \\frac{I_m}{\\sqrt{I_m^2 + \\varepsilon^2}} \\frac{\\big\\| \\hat{\\mathbf{s}}_m \\times \\mathbf{B}_{\\mathrm{back}}(\\mathbf{x}_m)\\big\\|}{A_m}\n$$\n结合这些结果，$F_q$ 梯度的第 $j$ 个分量是：\n$$\n[\\nabla_{\\mathbf{I}} F_q(\\mathbf{I})]_j = \\left( F_q(\\mathbf{I}) \\right)^{1-q} [f_j(\\mathbf{I})]^{q-1} \\frac{I_j}{\\sqrt{I_j^2 + \\varepsilon^2}} \\frac{\\|\\hat{\\mathbf{s}}_j \\times \\mathbf{B}_{\\mathrm{back}}(\\mathbf{x}_j)\\|}{A_j}\n$$\n\n最后，目标泛函 $J_{\\mu}(\\mathbf{I})$ 的完整梯度是其两部分梯度之和：\n$$\n\\nabla_{\\mathbf{I}} J_{\\mu}(\\mathbf{I}) = \\nabla_{\\mathbf{I}} F_q(\\mathbf{I}) + \\mu \\mathbf{G}^T (\\mathbf{G}\\mathbf{I} - \\mathbf{b}_{\\mathrm{target}})\n$$\n这是基于伴随的梯度的解析表达式。\n\n实施计划如下：\n$1.$ 响应矩阵 $\\mathbf{G} \\in \\mathbb{R}^{K \\times M}$ 是通过数值方法构建的。每个元素 $G_{km}$ 是由单位电流的导体段 $m$ 在目标点 $\\mathbf{x}_{\\mathrm{t},k}$ 处产生的磁场的 $z$ 分量。这是通过使用 $N_q=200$ 个求积点对直导体段的毕奥-萨伐尔积分进行离散化来计算的。当 $\\mathbf{r}(t) = \\mathbf{x}_m + t\\hat{\\mathbf{s}}_m$ 对于 $t \\in [-L_m/2, L_m/2]$ 且 $\\Delta t = L_m/N_q$ 时，公式为：\n$$\nG_{km} = \\frac{\\mu_0}{4\\pi} \\sum_{i_q=0}^{N_q-1} \\left[ \\frac{\\hat{\\mathbf{s}}_m \\times (\\mathbf{x}_{\\mathrm{t},k} - \\mathbf{r}(t_{i_q}))}{\\|\\mathbf{x}_{\\mathrm{t},k} - \\mathbf{r}(t_{i_q})\\|^3} \\right]_z \\Delta t\n$$\n其中 $t_{i_q}$ 是求积子区间的中点。\n$2.$ 通过求解吉洪诺夫正则化最小二乘问题 $\\min_{\\mathbf{I}} \\left\\| \\mathbf{G}\\,\\mathbf{I} - \\mathbf{b}_{\\mathrm{target}} \\right\\|_2^2 + \\alpha \\left\\| \\mathbf{I} \\right\\|_2^2$ 来确定基准电流向量 $\\mathbf{I}^\\star$。解通过正规方程找到：$\\mathbf{I}^\\star = (\\mathbf{G}^T \\mathbf{G} + \\alpha \\mathbf{I}_{\\text{identity}})^{-1} \\mathbf{G}^T \\mathbf{b}_{\\mathrm{target}}$。\n$3.$ 使用推导出的公式计算伴随梯度 $\\nabla J_{\\mu}^{\\mathrm{adj}}(\\mathbf{I}^\\star)$。\n$4.$ 使用中心有限差分公式计算验证梯度 $\\nabla J_{\\mu}^{\\mathrm{FD}}(\\mathbf{I}^\\star)$，其每个分量 $m$ 为：$[\\nabla J_{\\mu}^{\\mathrm{FD}}]_m = \\frac{J_{\\mu}(\\mathbf{I}^\\star + h\\mathbf{e}_m) - J_{\\mu}(\\mathbf{I}^\\star - h\\mathbf{e}_m)}{2h}$。\n$5.$ 两个梯度之间的相对误差计算为 $\\mathrm{err} = \\frac{\\|\\nabla J_{\\mu}^{\\mathrm{adj}} - \\nabla J_{\\mu}^{\\mathrm{FD}}\\|_2}{\\max(1, \\|\\nabla J_{\\mu}^{\\mathrm{FD}}\\|_2)}$。对每个测试用例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to derive and verify the adjoint-based gradient for the coil optimization problem.\n    \"\"\"\n    #\n    # Step 2.1 - 2.3: Define fixed geometry, targets, and constants\n    #\n    MU0 = 4 * np.pi * 1e-7  # Permeability of free space (H/m)\n    M = 4  # Number of coil segments\n    K = 2  # Number of target points\n    N_q_integration = 200 # Number of quadrature nodes per segment\n    ALPHA_REG = 1.0e-6 # Tikhonov regularization parameter\n\n    # Coil segment properties\n    L_m = 0.40  # Length of each segment (m)\n    centers = np.array([\n        [-0.30, 0.00, 0.00],\n        [-0.10, 0.00, 0.00],\n        [0.10, 0.00, 0.00],\n        [0.30, 0.00, 0.00]\n    ])\n    orientations = np.array([[0.0, 1.0, 0.0]] * M)\n    areas = np.array([5.0e-4, 4.0e-4, 6.0e-4, 5.0e-4]) # m^2\n\n    # Target point properties\n    target_points = np.array([\n        [0.00, 0.00, 0.20],\n        [0.00, 0.00, 0.35]\n    ])\n    b_target = np.array([1.0e-5, -0.5e-5]) # Tesla\n\n    #\n    # Helper function for background magnetic field\n    #\n    def B_back(p):\n        x, y, z = p\n        return np.array([0.10 * z, 0.0, 1.50 + 0.05 * x])\n\n    # Pre-compute constants for force calculation\n    C_m = np.array([\n        np.linalg.norm(np.cross(orientations[m], B_back(centers[m])))\n        for m in range(M)\n    ])\n\n    #\n    # Step 2.1: Construct the response matrix G\n    #\n    G = np.zeros((K, M))\n    dt = L_m / N_q_integration\n    t_nodes = -L_m / 2 + (np.arange(N_q_integration) + 0.5) * dt\n\n    for k in range(K):\n        for m in range(M):\n            g_km = 0.0\n            x_t = target_points[k]\n            x_m = centers[m]\n            s_m = orientations[m]\n            \n            for t in t_nodes:\n                r_line = x_m + t * s_m\n                R_vec = x_t - r_line\n                R_norm = np.linalg.norm(R_vec)\n                \n                integrand_vec = np.cross(s_m, R_vec) / (R_norm**3)\n                g_km += integrand_vec[2] # z-component\n\n            G[k, m] = (MU0 / (4 * np.pi)) * g_km * dt\n\n    #\n    # Step 2.4: Compute the baseline current vector I_star\n    #\n    G_T_G = G.T @ G\n    reg_matrix = G_T_G + ALPHA_REG * np.identity(M)\n    rhs = G.T @ b_target\n    I_star = linalg.solve(reg_matrix, rhs, assume_a='sym')\n\n    #\n    # Define objective function and its gradient components\n    #\n    def compute_f_m(I, epsilon):\n        # Smoothed force magnitude proxy for each segment\n        return (np.sqrt(I**2 + epsilon**2) / areas) * C_m\n\n    def compute_F_q(I, q, epsilon):\n        # L_q norm of the force proxies\n        f_vals = compute_f_m(I, epsilon)\n        return np.sum(f_vals**q)**(1.0 / q)\n\n    def compute_J_mu(I, q, mu, epsilon):\n        # Full objective functional\n        F_q_val = compute_F_q(I, q, epsilon)\n        penalty = (mu / 2.0) * np.linalg.norm(G @ I - b_target)**2\n        return F_q_val + penalty\n\n    def compute_adjoint_gradient(I, q, mu, epsilon):\n        # Adjoint-based gradient\n        # Gradient of the penalty term\n        grad_penalty = mu * G.T @ (G @ I - b_target)\n\n        # Gradient of the force term F_q\n        f_vals = compute_f_m(I, epsilon)\n        F_q_val = np.sum(f_vals**q)**(1.0 / q)\n        \n        df_dI = (I / np.sqrt(I**2 + epsilon**2)) * (C_m / areas)\n        \n        # Handle case where F_q is very close to zero to avoid division by zero\n        if F_q_val  1e-16:\n             grad_Fq = np.zeros_like(I)\n        else:\n            grad_Fq = (F_q_val**(1 - q)) * (f_vals**(q - 1)) * df_dI\n\n        return grad_Fq + grad_penalty\n\n    def compute_fd_gradient(I, q, mu, epsilon, h):\n        # Central finite-difference gradient for verification\n        grad_fd = np.zeros(M)\n        for m in range(M):\n            I_plus = I.copy()\n            I_plus[m] += h\n            I_minus = I.copy()\n            I_minus[m] -= h\n\n            J_plus = compute_J_mu(I_plus, q, mu, epsilon)\n            J_minus = compute_J_mu(I_minus, q, mu, epsilon)\n            \n            grad_fd[m] = (J_plus - J_minus) / (2.0 * h)\n        return grad_fd\n\n    #\n    # Test suite execution\n    #\n    test_cases = [\n        (4, 5.0, 1.0e-6, 1.0e-7),\n        (8, 1.0, 1.0e-8, 5.0e-8),\n        (16, 0.5, 1.0e-10, 2.0e-8),\n    ]\n\n    results = []\n    for q, mu, epsilon, h in test_cases:\n        # Step 2.5: Compute gradients\n        grad_adj = compute_adjoint_gradient(I_star, q, mu, epsilon)\n        grad_fd = compute_fd_gradient(I_star, q, mu, epsilon, h)\n\n        # Step 2.6: Compute relative error\n        norm_fd = np.linalg.norm(grad_fd)\n        norm_diff = np.linalg.norm(grad_adj - grad_fd)\n        \n        err = norm_diff / max(1.0, norm_fd)\n        results.append(err)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}