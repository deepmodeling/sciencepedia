{
    "hands_on_practices": [
        {
            "introduction": "在为托卡马克破裂预测建立可靠的机器学习模型时，第一步也是最关键的一步是设计一个严格的验证策略。对于时间序列数据，一个常见的陷阱是时间数据泄漏，它会导致模型性能被严重高估，从而产生一种虚假的安全感。本练习  旨在通过第一性原理阐明这种泄漏是如何发生的，并指导您设计一种能够消除泄漏并确保模型泛化能力得到真实评估的交叉验证方案。",
            "id": "4003862",
            "problem": "考虑一个从托卡马克等离子体实验中收集的数据集，该数据集由 $S$ 次放电（炮）组成，索引为 $i \\in \\{1,\\dots,S\\}$。每次放电 $i$ 提供一个多变量时间序列 $\\{x^{(i)}(t)\\}_{t=0}^{T^{(i)}}$ 的诊断信号，采样间隔为 $\\Delta t$，其中 $x^{(i)}(t) \\in \\mathbb{R}^d$ 是从时间窗口 $[t-\\tau, t]$ 因果计算出的特征，窗口长度 $\\tau$ 固定。对于发生破裂的放电，令 $t_d^{(i)}$ 表示破裂时间。破裂预警任务是仅使用特征 $x^{(i)}(t)$ 来预测一个时间点 $t$ 是否位于破裂前的时间区间 $[t_d^{(i)} - L, t_d^{(i)})$ 内，其中 $L > 0$ 为某个提前时间。因此，对于发生破裂的放电，正确的标签函数为 $y^{(i)}(t) = \\mathbb{1}\\{t \\in [t_d^{(i)} - L, t_d^{(i)})\\}$；对于未发生破裂的放电，则为 $y^{(i)}(t) = 0$。\n\n假设由于记录延迟和时钟漂移，在构建标签时引入了固定的、每次放电都不同的时间未对准量 $\\delta^{(i)}$，因此数据集使用的标签是 $\\tilde{y}^{(i)}(t) = \\mathbb{1}\\{t + \\delta^{(i)} \\in [t_d^{(i)} - L, t_d^{(i)})\\}$，其中 $\\delta^{(i)}$ 的量级为几十毫秒，且 $|\\delta^{(i)}| \\ll T^{(i)}$。特征的计算仍然是基于 $x^{(i)}(t)$ 的因果计算，不使用未来的样本。\n\n您的任务是执行 $K$ 折交叉验证（Cross-Validation, CV）来估计模型的泛化能力。考虑两种交叉验证方案：窗口级别的随机 $K$ 折交叉验证，该方案不考虑放电的身份，将单个时间窗口划分到不同的折（fold）中；以及炮级别的分组 $K$ 折交叉验证，该方案将整次放电分配到不同的折中。假设在小的延迟下，炮内的特征过程自相关性很高，即自相关函数 $\\rho^{(i)}(\\Delta) = \\mathbb{E}[\\langle x^{(i)}(t), x^{(i)}(t+\\Delta)\\rangle]/(\\|x^{(i)}(t)\\|_2 \\|x^{(i)}(t+\\Delta)\\|_2)$ 在 $|\\Delta| \\leq |\\delta^{(i)}|$ 时满足 $\\rho^{(i)}(\\Delta) \\approx 1$。\n\n请从第一性原理出发，运用因果性、训练集与测试集折之间的独立性以及自相关效应的定义，来论证在标签未对准的情况下交叉验证中的时间泄漏问题。然后，设计一个炮级别的划分方案，该方案能消除泄漏，同时最大化跨操作条件的训练数据多样性。操作条件由每次放电的标量描述符总结，例如等离子体电流 $I_p^{(i)}$、边缘安全因子 $q_{95}^{(i)}$ 和归一化比压 $\\beta_N^{(i)}$。设每次破裂放电的正样本窗口数约为 $n_+^{(i)} \\approx L/\\Delta t$，并定义每炮的类别权重 $w^{(i)}$：对于破裂放电为 $w^{(i)} = n_+^{(i)}$，对于非破裂放电为 $w^{(i)} = c \\cdot n_-^{(i)}$，其中 $c > 0$ 是一个常数，$n_-^{(i)}$ 是负样本窗口的数量。\n\n下列哪个选项正确地指出了未对准的标签如何在交叉验证中引入时间泄漏，并指定了一个有效的、能在消除泄漏的同时最大化训练多样性的炮级划分设计？\n\nA. 在窗口级别的随机 $K$ 折交叉验证中，未对准的标签 $\\tilde{y}^{(i)}(t)$ 意味着对于第 $i$ 次放电中时间点 $t$ 的一个测试窗口，存在来自同一次放电、时间点在 $t' \\approx t + \\delta^{(i)}$ 且标签相同的训练窗口。因为 $\\rho^{(i)}(\\delta^{(i)}) \\approx 1$，所以 $x^{(i)}(t)$ 和 $x^{(i)}(t')$ 几乎相同，这导致训练集中包含了与测试特征几乎重复且标签匹配的样本，从而违反了独立性并导致时间泄漏。\n\nB. 一种能消除泄漏并最大化多样性的方案是按炮进行分组 $K$ 折交叉验证，并进行每折分层，通过权重 $w^{(i)}$ 来平衡破裂炮与非破裂炮的比例，并通过最小化每折直方图之间的散度来匹配 $\\{I_p^{(i)}, q_{95}^{(i)}, \\beta_N^{(i)}\\}$ 的经验分布。这确保了来自同一次放电的所有窗口都在单个折中，消除了训练集和测试集之间的炮内时间重叠，强制执行了正确的标签对准 $y^{(i)}(t)$，并通过平衡操作条件来最大化训练多样性。\n\nC. 随机地将窗口分配到折中，同时确保每个折有相同数量的窗口，就足以消除泄漏，因为每个折的样本数量是独立性的主要决定因素。多样性也仅通过相等的数量就能最大化。\n\nD. 在保持未对准标签 $\\tilde{y}^{(i)}(t)$ 的同时，使用前瞻性窗口 $[t, t+\\tau]$ 计算特征，可以提高预测性能而不会产生泄漏，因为标签的移位 $\\delta^{(i)}$ 抵消了未来信息的使用，使任务变得适定。\n\n选择所有正确的选项。",
            "solution": "用户希望我扮演一名 STEM 教授，来验证并解决一个与聚变等离子体破裂预测中的交叉验证相关的问题。\n\n### 问题验证\n\n首先，我必须仔细验证问题陈述。\n\n**第 1 步：提取已知条件**\n\n*   **数据集：** $S$ 次托卡马克放电（炮），索引为 $i \\in \\{1,\\dots,S\\}$。\n*   **时间序列数据：** 对于每次放电 $i$，一个多变量时间序列 $\\{x^{(i)}(t)\\}_{t=0}^{T^{(i)}}$，采样间隔为 $\\Delta t$。\n*   **特征：** $x^{(i)}(t) \\in \\mathbb{R}^d$ 是从时间窗口 $[t-\\tau, t]$ 因果计算出的特征。\n*   **破裂时间：** 对于破裂炮，$t_d^{(i)}$ 是破裂时间。\n*   **提前时间：** 一个固定的提前时间 $L > 0$ 定义了预警窗口。\n*   **正确标签：** 对于破裂炮，$y^{(i)}(t) = \\mathbb{1}\\{t \\in [t_d^{(i)} - L, t_d^{(i)})\\}$；对于非破裂炮，$y^{(i)}(t) = 0$。\n*   **未对准标签：** 数据集使用标签 $\\tilde{y}^{(i)}(t) = \\mathbb{1}\\{t + \\delta^{(i)} \\in [t_d^{(i)} - L, t_d^{(i)})\\}$，这是由于固定的每炮时间未对准 $\\delta^{(i)}$。\n*   **未对准幅度：** $\\delta^{(i)}$ 的量级为几十毫秒，且 $|\\delta^{(i)}| \\ll T^{(i)}$。\n*   **交叉验证（Cross-Validation, CV）方案：**\n    1.  窗口级别的随机 $K$ 折交叉验证。\n    2.  炮级别的分组 $K$ 折交叉验证。\n*   **自相关假设：** 炮内特征自相关函数 $\\rho^{(i)}(\\Delta) = \\mathbb{E}[\\langle x^{(i)}(t), x^{(i)}(t+\\Delta)\\rangle]/(\\|x^{(i)}(t)\\|_2 \\|x^{(i)}(t+\\Delta)\\|_2)$ 在 $|\\Delta| \\leq |\\delta^{(i)}|$ 时满足 $\\rho^{(i)}(\\Delta) \\approx 1$。\n*   **炮描述符：** 每炮的标量操作条件由等离子体电流 $I_p^{(i)}$、边缘安全因子 $q_{95}^{(i)}$ 和归一化比压 $\\beta_N^{(i)}$ 给出。\n*   **窗口计数与权重：** 每个破裂炮的正样本窗口数 $n_+^{(i)} \\approx L/\\Delta t$。每炮的类别权重 $w^{(i)}$ 对于破裂炮是 $n_+^{(i)}$，对于非破裂炮是 $c \\cdot n_-^{(i)}$（$c > 0$，$n_-^{(i)}$ 是负样本窗口的数量）。\n*   **任务：** 分析由未对准标签引起的交叉验证中的时间泄漏，并设计一个无泄漏、多样性最大化的炮级划分方案。\n\n**第 2 步：使用提取的已知条件进行验证**\n\n*   **科学基础：** 该问题牢固地植根于计算聚变科学和机器学习，这是一个主要的研究领域。破裂预测、托卡马克诊断、操作参数（$I_p, q_{95}, \\beta_N$）、时间序列分析、交叉验证和时间数据泄漏都是该领域中标准的、成熟的概念。时间基准未对准（$\\delta^{(i)}$）的情景是实验物理学中一个现实的数据质量问题。\n*   **适定性：** 问题提供了一个清晰而完整的设定。所有术语都已定义，背景已明确，问题要求对一个特定现象（泄漏）进行有原则的分析，并设计一种方法来应对它。基于所提供的信息，可以进行独特且有意义的分析。\n*   **客观性：** 问题以精确、正式的语言陈述，使用数学符号和既定的技术术语。它没有主观断言或模糊之处。\n\n**第 3 步：结论与行动**\n\n问题陈述是**有效的**。它在科学上是合理的、适定的、客观的，并且与计算聚变科学的机器学习领域直接相关。我现在将进行解题推导。\n\n### 解题推导\n\n该问题有两个部分：首先，分析在给定的数据条件下，特定交叉验证方案引入的时间泄漏；其次，设计一个鲁棒的交叉验证方案。\n\n**第一部分：窗口级别交叉验证中时间泄漏的分析**\n\n交叉验证的基本原则是估计模型在未见过的数据上的泛化误差。这要求训练集和测试集是独立的。在来自单个过程（一次等离子体放电）的时间序列数据的背景下，邻近时间点的样本不是独立的；它们在时间上是相关的。\n\n1.  **交叉验证方案：** 考虑的第一个方案是窗口级别的随机 $K$ 折交叉验证。该方案将来自所有放电 $i \\in \\{1, \\dots, S\\}$ 的所有时间窗口 $(x^{(i)}(t), \\tilde{y}^{(i)}(t))$ 汇集起来，并随机将它们划分为 $K$ 个折。这意味着对于任何给定的放电 $i$，其部分时间窗口可能在训练集中，而其他部分在测试集中。\n\n2.  **自相关性：** 问题陈述指出，特征的自相关性 $\\rho^{(i)}(\\Delta)$ 对于小的延迟 $\\Delta$ 很高。具体来说，对于等于未对准时间的延迟，$\\rho^{(i)}(|\\delta^{(i)}|) \\approx 1$。这意味着对于小的 $\\Delta$，特征向量 $x^{(i)}(t)$ 和 $x^{(i)}(t+\\Delta)$ 几乎相同。\n\n3.  **违反独立性（泄漏）：** 让我们考虑一个来自放电 $i$ 的测试样本 $(x^{(i)}(t_{test}), \\tilde{y}^{(i)}(t_{test}))$。由于随机的窗口级别划分，来自同一放电、在邻近时间的样本，比如 $(x^{(i)}(t_{train}), \\tilde{y}^{(i)}(t_{train}))$ 其中 $t_{train} \\approx t_{test}$，很可能在训练集中。由于高度的自相关性，测试特征 $x^{(i)}(t_{test})$ 与训练特征 $x^{(i)}(t_{train})$ 几乎相同。如果它们的标签也相同，模型基本上可以在训练期间“记住”测试样本。这会给模型在真正新数据上的性能带来一个被人为夸大的、无效的估计。这种现象被称为时间泄漏。\n\n4.  **未对准标签的作用：** 标签未对准 $\\delta^{(i)}$ 并不导致泄漏，但它提供了一个特定的时间尺度来分析泄漏，正如选项 A 中所强调的。真正的原因是自相关性与将单个时间序列（一次放电）划分到训练/测试集中的组合。未对准的标签是 $\\tilde{y}^{(i)}(t) = \\mathbb{1}\\{t + \\delta^{(i)} \\in [t_d^{(i)} - L, t_d^{(i)}) \\}$。\n\n**第二部分：鲁棒交叉验证方案的设计**\n\n一个鲁棒的交叉验证方案必须解决上述两个主要挑战：\n\n1.  **消除泄漏：** 为了防止上述的时间泄漏，必须在独立的实验单元（即等离子体放电）的层面上强制执行训练集和测试集之间的独立性。因此，来自单次放电 $i$ 的所有数据（所有时间窗口）都必须属于同一个折。这种方案被称为分组 $K$ 折交叉验证（Group $K$-fold CV），其中每次放电 $i$ 是一个组。\n\n2.  **最大化训练多样性：** 托卡马克等离子体在不同的条件下运行，这些条件由诸如 $I_p^{(i)}, q_{95}^{(i)}, \\beta_N^{(i)}$ 等参数总结。简单地将放电随机分配到折中可能会导致某些折不能代表整个数据集。例如，一个折可能包含不成比例的高电流放电。那么在其他 $K-1$ 个折上训练的模型将在一个它没有充分接触过的区域进行测试，从而导致对泛化误差的估计不佳且方差很高。为了最大化多样性并获得稳定的估计，必须对折进行分层。这意味着划分放电，使得关键特征的分布在所有 $K$ 个折中尽可能相似。需要分层的特征是：\n    *   放电结果（破裂与非破裂），可能使用提供的权重 $w^{(i)}$ 来平衡每个类别在各折中的总“重要性”。\n    *   操作条件参数 $\\{I_p^{(i)}, q_{95}^{(i)}, \\beta_N^{(i)}\\}$。这是一个多维分层问题。一个常见且有效的方法是根据这些参数对放电进行分箱，并确保每个箱均匀分布在各个折中，或者更一般地，使用优化算法来最小化每个折中这些参数的经验分布之间的散度度量（如 Wasserstein 距离或直方图矩的差异）。\n\n这个由两部分组成的策略——按炮进行分组 $K$ 折交叉验证，再加上按炮级属性进行分层——构成了解决此问题的最先进方法。\n\n### 逐项分析\n\n**A. 在窗口级别的随机 $K$ 折交叉验证中，未对准的标签 $\\tilde{y}^{(i)}(t)$ 意味着对于第 $i$ 次放电中时间点 $t$ 的一个测试窗口，存在来自同一次放电、时间点在 $t' \\approx t + \\delta^{(i)}$ 且标签相同的训练窗口。因为 $\\rho^{(i)}(\\delta^{(i)}) \\approx 1$，所以 $x^{(i)}(t)$ 和 $x^{(i)}(t')$ 几乎相同，这导致训练集中包含了与测试特征几乎重复且标签匹配的样本，从而违反了独立性并导致时间泄漏。**\n\n该选项正确地指出了时间泄漏的机制。\n1.  它正确地指责窗口级别的随机 $K$ 折交叉验证划分了来自同一次放电的数据。\n2.  它正确地使用了给定的自相关属性 $\\rho^{(i)}(\\delta^{(i)}) \\approx 1$，来说明由 $\\delta^{(i)}$ 的延迟分隔的特征几乎相同。\n3.  它声称在 $t$ 和 $t' = t+\\delta^{(i)}$ 的窗口标签是相同的。我们来检查一下：$\\tilde{y}^{(i)}(t) = \\mathbb{1}\\{t+\\delta^{(i)} \\in [t_d^{(i)}-L, t_d^{(i)})\\}$ 和 $\\tilde{y}^{(i)}(t+\\delta^{(i)}) = \\mathbb{1}\\{t+2\\delta^{(i)} \\in [t_d^{(i)}-L, t_d^{(i)}) \\}$。由于提前时间 $L$ 通常是几百毫秒，而未对准量 $\\delta^{(i)}$ 是几十毫秒，所以 $L \\gg |\\delta^{(i)}|$。因此，对于大多数标签为 1 的时间点 $t$，其后 $\\delta^{(i)}$ 的时间点标签也为 1。对于标签为 0 的点也是如此。标签只会在预警窗口的两个边界附近有所不同。因此，“标签匹配”的说法对绝大多数样本来说是近似正确的。\n4.  其结论是，这构成了对独立性的违反并导致泄漏是正确的。模型正在用它在训练中已经见过的几乎重复的数据进行测试。\n**结论：正确。**\n\n**B. 一种能消除泄漏并最大化多样性的方案是按炮进行分组 $K$ 折交叉验证，并进行每折分层，通过权重 $w^{(i)}$ 来平衡破裂炮与非破裂炮的比例，并通过最小化每折直方图之间的散度来匹配 $\\{I_p^{(i)}, q_{95}^{(i)}, \\beta_N^{(i)}\\}$ 的经验分布。这确保了来自同一次放电的所有窗口都在单个折中，消除了训练集和测试集之间的炮内时间重叠，强制执行了正确的标签对准 $y^{(i)}(t)$，并通过平衡操作条件来最大化训练多样性。**\n\n该选项描述了上面推导出的鲁棒交叉验证方案。\n1.  `按炮进行分组 K 折交叉验证` 是消除时间泄漏的正确方法。\n2.  `每折分层` 以平衡放电类型并匹配操作参数（$\\{I_p^{(i)}, q_{95}^{(i)}, \\beta_N^{(i)}\\}$）的分布是最大化多样性并确保折具有代表性的正确方法。\n3.  `消除了训练集和测试集之间的炮内时间重叠` 的陈述是按炮分组的直接、正确的结果。\n4.  `强制执行了正确的标签对准 y^{(i)}(t)` 这个子句不精确。划分方案本身只划分数据，不修改数据。然而，按炮分组是在每个折的模型训练阶段正确处理每炮未对准量 $\\delta^{(i)}$ 的必要先决条件。没有炮级分组，就不可能对标签应用正确的每炮时间移位。从这个意义上说，所描述的方案*使得*能够强制执行正确的对准。鉴于此选项的所有其他部分都以高精度描述了理想方法，这种不精确性是措辞上的小瑕疵，而非根本性的概念错误。所描述的整体方案在科学上是正确的。\n**结论：正确。**\n\n**C. 随机地将窗口分配到折中，同时确保每个折有相同数量的窗口，就足以消除泄漏，因为每个折的样本数量是独立性的主要决定因素。多样性也仅通过相等的数量就能最大化。**\n\n这个选项根本上是错误的。\n1.  `随机地将窗口分配到折中` 是导致时间泄漏的有缺陷方法的定义，它并不能消除泄漏。\n2.  `每个折的样本数量是独立性的主要决定因素` 的说法是错误的。样本的来源和相关结构决定了独立性，而不是它们的数量。\n3.  `多样性也仅通过相等的数量就能最大化` 的说法是错误的。具有相等窗口数量的折可能在操作条件分布上差异巨大，从而导致多样性差。\n**结论：不正确。**\n\n**D. 在保持未对准标签 $\\tilde{y}^{(i)}(t)$ 的同时，使用前瞻性窗口 $[t, t+\\tau]$ 计算特征，可以提高预测性能而不会产生泄漏，因为标签的移位 $\\delta^{(i)}$ 抵消了未来信息的使用，使任务变得适定。**\n\n这个选项提出了一种非因果的建模方法。\n1.  任务是提供*预警*，这需要一个只使用过去和现在信息的因果模型。从前瞻性窗口 $[t, t+\\tau]$ 计算特征使用了未来信息，违反了因果性。\n2.  标签是 $\\tilde{y}^{(i)}(t) = y^{(i)}(t+\\delta^{(i)})$，它涉及一个在时间 $t+\\delta^{(i)}$ 发生的事件。使用来自 $[t, t+\\tau]$ 的特征来预测这一点，意味着模型被要求使用一个可能包含甚至晚于 $t+\\delta^{(i)}$（如果 $\\tau \\ge \\delta^{(i)}$）的窗口中的信息来预测在 $t+\\delta^{(i)}$ 发生的事件。这不是预测，而是插值或描述。\n3.  标签移位 `抵消` 了未来数据使用的推理是毫无根据的。使用未来数据预测未来事件是典型的因果性违规，会导致性能指标被人为夸大，并产生一个在实践中无用的模型。\n**结论：不正确。**",
            "answer": "$$\\boxed{AB}$$"
        },
        {
            "introduction": "超越简单的“是否会破裂”的二元分类，一个更高级的问题是“何时会破裂”。生存分析为这个问题提供了强大的框架，其中考克斯比例风险 (Cox Proportional Hazards, CPH) 模型是一个核心工具，它能够处理随时间变化的协变量和删失数据。本练习  将引导您从基本定义出发，推导并实现 CPH 模型的偏对数似然函数，这是训练该模型的关键，从而让您深入了解如何对随时间变化的风险进行建模。",
            "id": "4003911",
            "problem": "您的任务是形式化并计算一个用于磁约束聚变等离子体（托卡马克）中破裂时间预测的、基于风险的机器学习模型的偏对数似然。该模型是带有时变协变量的Cox比例风险（CPH）模型。您必须从第一性原理出发，使用风险率、生存函数和比例风险假设的定义，推导出在右删失情况下的偏对数似然，然后针对小的、分段常数的协变量轨迹，通过算法实现它。所有时间量必须以秒为单位表示，任何计算出的数值输出必须是无量纲的实数。\n\n需要使用的定义和假设：\n- 对于放电 $i$，$h_i(t)$ 是其瞬时风险率，定义为当 $t$ 推进时条件事件率的极限：$h_i(t) = \\lim_{\\Delta t \\to 0^+} \\frac{\\mathbb{P}(T_i \\in [t, t + \\Delta t) \\mid T_i \\ge t)}{\\Delta t}$，其中 $T_i$ 是事件时间（破裂时间）或删失时间。\n- 生存函数 $S_i(t)$ 满足 $S_i(t) = \\mathbb{P}(T_i \\ge t)$，并通过 $S_i(t) = \\exp\\left(-\\int_0^t h_i(u) \\, du\\right)$ 与风险率相关。\n- 比例风险假设假定 $h_i(t) = h_0(t) \\, \\exp\\left(\\boldsymbol{\\beta}^\\top \\mathbf{x}_i(t)\\right)$，其中 $h_0(t)$ 是一个适用于所有放电的未指定基准风险，$\\boldsymbol{\\beta}$ 是一个恒定系数向量，$\\mathbf{x}_i(t)$ 是特定于放电的、可能随时间变化的协变量向量。\n- 协变量在时间上是分段常数。对于在时间 $t_j$ 发生的任何事件（破裂），用于放电 $i$ 的协变量值必须是左极限 $\\mathbf{x}_i(t_j^-)$，即 $t_j$ 之前瞬间的值。\n- 存在右删失：如果一次放电在时间 $c_i$ 被删失，它对所有事件时间 $t \\le c_i$ 的风险集都有贡献，但不产生事件贡献。\n\n您的任务：\n- 通过在每个事件时间对风险集进行条件化来消除 $h_0(t)$，推导出仅依赖于观测事件时间的顺序和通过比例风险结构的协变量的偏对数似然。\n- 实现一个程序，该程序为给定的 $\\boldsymbol{\\beta}$ 和一个放电数据集计算偏对数似然，其中每次放电都有一个删失或事件时间以及一系列分段常数协变量段。在每个事件时间使用正确的左极限协变量求值，并将每个事件时间 $t_j$ 的风险集构建为所有满足 $t_j \\le T_i$ 的放电 $i$ （事件时间被视为在 $t_j$ 之前瞬间处于风险中）。\n- 您必须以秒为单位处理所有时间，并生成无量纲的偏对数似然值。\n\n使用的协变量：\n- 协变量向量 $\\mathbf{x}_i(t)$ 是三维的，$\\mathbf{x}_i(t) = \\left[x_{1i}(t), x_{2i}(t), x_{3i}(t)\\right]$。将 $x_{1i}(t)$ 解释为归一化等离子体电流比（无量纲），$x_{2i}(t)$ 解释为锁定模式径向磁扰动幅度，单位为特斯拉，以及 $x_{3i}(t)$ 解释为线平均密度，单位为 $10^{19}\\,\\mathrm{m}^{-3}$ （相对于此标度是无量纲的）。单位应被一致处理，但最终计算出的似然是无量纲的。\n\n测试套件：\n- 数据集A（混合事件和删失，时变协变量）：\n    - 放电 $1$：事件发生在 $3.0$ s；分段：\n        - $[0.0, 1.0)$ s: $\\mathbf{x} = (1.20, 1.0\\times 10^{-4}, 0.60)$\n        - $[1.0, 2.5)$ s: $\\mathbf{x} = (1.30, 2.0\\times 10^{-4}, 0.58)$\n        - $[2.5, 3.0)$ s: $\\mathbf{x} = (1.40, 4.0\\times 10^{-4}, 0.55)$\n    - 放电 $2$：在 $4.0$ s 删失；分段：\n        - $[0.0, 2.0)$ s: $\\mathbf{x} = (1.00, 1.0\\times 10^{-4}, 0.62)$\n        - $[2.0, 4.0)$ s: $\\mathbf{x} = (1.05, 1.5\\times 10^{-4}, 0.60)$\n    - 放电 $3$：事件发生在 $2.2$ s；分段：\n        - $[0.0, 1.0)$ s: $\\mathbf{x} = (1.50, 3.0\\times 10^{-4}, 0.50)$\n        - $[1.0, 2.2)$ s: $\\mathbf{x} = (1.60, 5.0\\times 10^{-4}, 0.49)$\n    - 放电 $4$：在 $3.5$ s 删失；分段：\n        - $[0.0, 1.5)$ s: $\\mathbf{x} = (0.90, 1.0\\times 10^{-4}, 0.65)$\n        - $[1.5, 3.5)$ s: $\\mathbf{x} = (1.00, 2.5\\times 10^{-4}, 0.64)$\n- 数据集B（全部删失）：\n    - 放电 $1$：在 $2.0$ s 删失；分段：\n        - $[0.0, 2.0)$ s: $\\mathbf{x} = (1.10, 2.0\\times 10^{-4}, 0.60)$\n    - 放电 $2$：在 $3.0$ s 删失；分段：\n        - $[0.0, 3.0)$ s: $\\mathbf{x} = (1.30, 1.0\\times 10^{-4}, 0.55)$\n- 数据集C（事件发生在协变量变化边界；确保使用左极限）：\n    - 放电 $1$：事件发生在 $1.0$ s；分段：\n        - $[0.0, 1.0)$ s: $\\mathbf{x} = (1.00, 2.0\\times 10^{-4}, 0.60)$\n        - $[1.0, 2.0)$ s: $\\mathbf{x} = (1.20, 5.0\\times 10^{-4}, 0.60)$\n    - 放电 $2$：在 $2.0$ s 删失；分段：\n        - $[0.0, 2.0)$ s: $\\mathbf{x} = (1.00, 1.0\\times 10^{-4}, 0.60)$\n- 数据集D（事件发生时只有一个对象处于风险中）：\n    - 放电 $1$：事件发生在 $2.0$ s；分段：\n        - $[0.0, 2.0)$ s: $\\mathbf{x} = (1.10, 2.0\\times 10^{-4}, 0.60)$\n    - 放电 $2$：在 $1.0$ s 删失；分段：\n        - $[0.0, 1.0)$ s: $\\mathbf{x} = (0.90, 1.0\\times 10^{-4}, 0.70)$\n\n待评估的系数向量：\n- 情况 $1$：$\\boldsymbol{\\beta} = (0.50, 3000.0, -0.50)$\n- 情况 $2$：$\\boldsymbol{\\beta} = (0.70, 4000.0, -0.90)$\n- 情况 $3$：$\\boldsymbol{\\beta} = (0.00, 0.00, 0.00)$\n\n计算要求：\n- 对于每个数据集和系数向量，使用正确的风险集构建和左极限协变量求值方法，计算偏对数似然值，作为单个实数。\n- 使用自然对数。\n- 所提供的数据集中不存在事件时间相同的情况；如果事件恰好发生在协变量段边界 $t_b$，则使用紧邻 $t_b$ 之前的段的协变量值（左极限）。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按以下顺序排列结果：\n    - 数据集A与情况1，数据集A与情况2，数据集A与情况3，数据集B与情况1，数据集C与情况2，数据集D与情况1。\n- 将每个结果表示为四舍五入到 $6$ 位小数的浮点数。\n- 格式示例：`[r_1,r_2,r_3,r_4,r_5,r_6]`，其中每个 $r_k$ 是一个无量纲的实数。",
            "solution": "该问题要求推导并实现带有事变协变量的Cox比例风险（CPH）模型的偏对数似然。推导从风险率和生存函数的基本定义开始，最终得到一个与未指定的基准风险无关的表达式。\n\n设有 $N$ 次独立的放电（研究对象）。对于每次放电 $i \\in \\{1, \\dots, N\\}$，观测数据是一个三元组 $(T_i, \\delta_i, \\mathbf{x}_i(\\cdot))$，其中 $T_i$ 是观测时间（事件时间或删失时间），$\\delta_i$ 是一个事件指示符，使得对于事件（破裂）$\\delta_i=1$，对于右删失$\\delta_i=0$，$\\mathbf{x}_i(t)$ 是放电 $i$ 在时间 $t$ 的协变量向量。\n\n放电 $i$ 在时间 $t$ 的瞬时风险率 $h_i(t)$ 定义为在给定存活到时间 $t$ 的条件下，在时间 $t$ 事件发生的瞬时速率：\n$$h_i(t) = \\lim_{\\Delta t \\to 0^+} \\frac{\\mathbb{P}(T_i \\in [t, t + \\Delta t) \\mid T_i \\ge t)}{\\Delta t}$$\n生存函数 $S_i(t) = \\mathbb{P}(T_i \\ge t)$ 与风险率通过 $S_i(t) = \\exp\\left(-\\int_0^t h_i(u) \\, du\\right)$ 相关。在时间 $t$ 发生事件的概率密度函数是 $f_i(t) = h_i(t)S_i(t)$。\n\n所有 $N$ 次放电的观测数据的全似然是经历事件的放电的概率密度和被删失的放电的生存概率的乘积：\n$$ L = \\prod_{i=1}^N [f_i(T_i)]^{\\delta_i} [S_i(T_i)]^{1-\\delta_i} = \\prod_{i=1}^N [h_i(T_i)S_i(T_i)]^{\\delta_i} [S_i(T_i)]^{1-\\delta_i} = \\prod_{i=1}^N [h_i(T_i)]^{\\delta_i} S_i(T_i) $$\n\nCox比例风险模型假设放电 $i$ 的风险率可以分解为一个公共的基准风险函数 $h_0(t)$ 和一个依赖于协变量的项：\n$$ h_i(t) = h_0(t) \\exp\\left(\\boldsymbol{\\beta}^\\top \\mathbf{x}_i(t)\\right) $$\n其中 $\\boldsymbol{\\beta}$ 是一个系数向量。将此代入全似然表达式会得到一个依赖于未知函数 $h_0(t)$ 的公式。\n\n为了消除这种依赖性，David Cox爵士提出了使用偏似然的方法。这是通过考虑不同的事件时间集合来构建的，这些时间按 $t_{(1)}  t_{(2)}  \\dots  t_{(D)}$ 排序，其中 $D$ 是观测到的事件总数。在每个事件时间 $t_{(j)}$，我们定义风险集 $\\mathcal{R}(t_{(j)})$ 为所有仍然有事件风险的放电 $i$ 的集合，即它们的事件或删失时间 $T_i$ 在 $t_{(j)}$ 或之后：$\\mathcal{R}(t_{(j)}) = \\{i \\mid T_i \\ge t_{(j)}\\}$。\n\n令 $i_j$ 是在时间 $t_{(j)}$ 唯一发生事件的放电的索引。偏似然考虑的是，在给定风险集 $\\mathcal{R}(t_{(j)})$ 中所有放电在此时间恰好发生一次事件的条件下，特别是在时间 $t_{(j)}$ 发生事件的是放电 $i_j$ 的条件概率。在一个微小的时间间隔 $[t_{(j)}, t_{(j)}+\\Delta t)$ 中，放电 $k$ 发生事件的概率约为 $h_k(t_{(j)}) \\Delta t$。那么条件概率是：\n$$ \\mathbb{P}(\\text{放电 } i_j \\text{ 发生事件} \\mid \\mathcal{R}(t_{(j)}) \\text{ 中发生一次事件}) = \\frac{h_{i_j}(t_{(j)}) \\Delta t}{\\sum_{k \\in \\mathcal{R}(t_{(j)})} h_k(t_{(j)}) \\Delta t} = \\frac{h_{i_j}(t_{(j)})}{\\sum_{k \\in \\mathcal{R}(t_{(j)})} h_k(t_{(j)})} $$\n\n将比例风险假设代入此表达式：\n$$ \\frac{h_0(t_{(j)}) \\exp\\left(\\boldsymbol{\\beta}^\\top \\mathbf{x}_{i_j}(t_{(j)})\\right)}{\\sum_{k \\in \\mathcal{R}(t_{(j)})} h_0(t_{(j)}) \\exp\\left(\\boldsymbol{\\beta}^\\top \\mathbf{x}_k(t_{(j)})\\right)} = \\frac{\\exp\\left(\\boldsymbol{\\beta}^\\top \\mathbf{x}_{i_j}(t_{(j)})\\right)}{\\sum_{k \\in \\mathcal{R}(t_{(j)})} \\exp\\left(\\boldsymbol{\\beta}^\\top \\mathbf{x}_k(t_{(j)})\\right)} $$\n基准风险 $h_0(t_{(j)})$ 被消掉了。对于时变协变量，使用的值是左极限 $\\mathbf{x}_k(t_{(j)}^-)$，即事件发生前瞬间的值。\n\n总偏似然 $L_p(\\boldsymbol{\\beta})$ 是所有 $D$ 个事件时间的这些条件概率的乘积（假设事件时间没有并列）：\n$$ L_p(\\boldsymbol{\\beta}) = \\prod_{j=1}^{D} \\frac{\\exp\\left(\\boldsymbol{\\beta}^\\top \\mathbf{x}_{i_j}(t_{(j)}^-)\\right)}{\\sum_{k \\in \\mathcal{R}(t_{(j)})} \\exp\\left(\\boldsymbol{\\beta}^\\top \\mathbf{x}_k(t_{(j)}^-)\\right)} $$\n\n偏对数似然 $\\ell_p(\\boldsymbol{\\beta})$ 是 $L_p(\\boldsymbol{\\beta})$ 的自然对数：\n$$ \\ell_p(\\boldsymbol{\\beta}) = \\ln\\left(L_p(\\boldsymbol{\\beta})\\right) = \\sum_{j=1}^{D} \\left( \\boldsymbol{\\beta}^\\top \\mathbf{x}_{i_j}(t_{(j)}^-) - \\ln\\left[\\sum_{k \\in \\mathcal{R}(t_{(j)})} \\exp\\left(\\boldsymbol{\\beta}^\\top \\mathbf{x}_k(t_{(j)}^-)\\right)\\right] \\right) $$\n如果没有事件发生（$D=0$），则求和为空，乘积是对空集的乘积，结果为1。因此，$\\ell_p(\\boldsymbol{\\beta}) = \\ln(1) = 0$。\n\n计算该值的算法如下：\n1.  将每次放电 $i$ 的数据表示为 $(T_i, \\delta_i, \\text{segments}_i)$，其中 $\\text{segments}_i$ 是一个 `(start_time, covariate_vector)` 元组的列表。\n2.  提取所有 $\\delta_i=1$ 的放电。令它们的事件时间为 $\\{t_{(1)}, t_{(2)}, \\dots, t_{(D)}\\}$，按升序排序。令相应的放电索引为 $\\{i_1, i_2, \\dots, i_D\\}$。\n3.  如果 $D=0$，则偏对数似然为 $0.0$。\n4.  初始化一个总对数似然变量 $\\ell_{total}$ 为 $0.0$。\n5.  遍历从 $1$ 到 $D$ 的每个事件 $j$，其事件时间为 $t_{(j)}$，对象索引为 $i_j$：\n    a. 构建风险集 $\\mathcal{R}(t_{(j)}) = \\{k \\mid T_k \\ge t_{(j)}\\}$。\n    b. 对于风险集 $\\mathcal{R}(t_{(j)})$ 中的每次放电 $k$，确定其在左极限时间 $t_{(j)}^-$ 的协变量向量。对于由开始时间定义的分段常数协变量，这对应于找到放电 $k$ 的开始时间 $t_s$ 满足 $t_s  t_{(j)}$ 的最大 $t_s$ 对应的段。\n    c. 为风险集 $\\mathcal{R}(t_{(j)})$ 中的每次放电 $k$ 计算风险得分 $\\eta_k = \\boldsymbol{\\beta}^\\top \\mathbf{x}_k(t_{(j)}^-)$。\n    d. 计算风险集上风险得分指数的总和：$S_j = \\sum_{k \\in \\mathcal{R}(t_{(j)})} \\exp(\\eta_k)$。\n    e. 识别发生事件的放电的风险得分 $\\eta_{i_j}$。\n    f. 此事件对对数似然的贡献是 $\\eta_{i_j} - \\ln(S_j)$。\n    g. 将此贡献加到 $\\ell_{total}$。\n6.  最终值 $\\ell_{total}$ 是偏对数似然。所有计算均使用浮点运算和自然对数。问题指定的协变量和 $\\boldsymbol{\\beta}$ 的单位确保了 $\\boldsymbol{\\beta}^\\top \\mathbf{x}$ 项是无量纲的，从而使最终的对数似然也是无量纲的。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the partial log-likelihood for the Cox Proportional Hazards model\n    for several test cases, as specified in the problem statement.\n    \"\"\"\n\n    # Data structure for shots:\n    # Each shot is a tuple: (shot_id, T, delta, segments)\n    # T: Observed time (event or censor)\n    # delta: Event indicator (1 for event, 0 for censor)\n    # segments: List of tuples (start_time, covariate_vector)\n\n    datasets = {\n        'A': [\n            (1, 3.0, 1, [(0.0, [1.20, 1.0e-4, 0.60]), (1.0, [1.30, 2.0e-4, 0.58]), (2.5, [1.40, 4.0e-4, 0.55])]),\n            (2, 4.0, 0, [(0.0, [1.00, 1.0e-4, 0.62]), (2.0, [1.05, 1.5e-4, 0.60])]),\n            (3, 2.2, 1, [(0.0, [1.50, 3.0e-4, 0.50]), (1.0, [1.60, 5.0e-4, 0.49])]),\n            (4, 3.5, 0, [(0.0, [0.90, 1.0e-4, 0.65]), (1.5, [1.00, 2.5e-4, 0.64])])\n        ],\n        'B': [\n            (1, 2.0, 0, [(0.0, [1.10, 2.0e-4, 0.60])]),\n            (2, 3.0, 0, [(0.0, [1.30, 1.0e-4, 0.55])])\n        ],\n        'C': [\n            (1, 1.0, 1, [(0.0, [1.00, 2.0e-4, 0.60]), (1.0, [1.20, 5.0e-4, 0.60])]),\n            (2, 2.0, 0, [(0.0, [1.00, 1.0e-4, 0.60])])\n        ],\n        'D': [\n            (1, 2.0, 1, [(0.0, [1.10, 2.0e-4, 0.60])]),\n            (2, 1.0, 0, [(0.0, [0.90, 1.0e-4, 0.70])])\n        ]\n    }\n\n    betas = {\n        1: np.array([0.50, 3000.0, -0.50]),\n        2: np.array([0.70, 4000.0, -0.90]),\n        3: np.array([0.00, 0.00, 0.00])\n    }\n    \n    test_cases = [\n        ('A', 1), ('A', 2), ('A', 3),\n        ('B', 1),\n        ('C', 2),\n        ('D', 1)\n    ]\n\n    def get_covariates_at_left_limit(segments, time):\n        \"\"\"\n        Finds the covariate vector for a shot at a time's left-limit.\n        This means finding the value from the time interval active just before 'time'.\n        \"\"\"\n        applicable_segments = []\n        for start_time, x_vec in segments:\n            if start_time  time:\n                applicable_segments.append((start_time, x_vec))\n        \n        if not applicable_segments:\n            raise ValueError(f\"No covariate history found for time {time}\")\n\n        # Find the segment with the latest start time before the event time\n        best_start_time = -1.0\n        covariate_vector = None\n        for start_time, x_vec in applicable_segments:\n            if start_time > best_start_time:\n                best_start_time = start_time\n                covariate_vector = x_vec\n        \n        return np.array(covariate_vector)\n\n\n    def calculate_log_likelihood(dataset, beta):\n        \"\"\"\n        Calculates the partial log-likelihood for a given dataset and beta vector.\n        \"\"\"\n        \n        # Identify event times and the corresponding shots\n        events = []\n        for shot_id, T, delta, segments in dataset:\n            if delta == 1:\n                events.append({'time': T, 'shot_id': shot_id})\n        \n        # If no events, log-likelihood is 0\n        if not events:\n            return 0.0\n\n        # Sort events by time\n        events.sort(key=lambda e: e['time'])\n        \n        total_log_likelihood = 0.0\n\n        for event in events:\n            event_time = event['time']\n            event_shot_id = event['shot_id']\n\n            # Construct risk set\n            risk_set_shots = []\n            for shot in dataset:\n                if shot[1] >= event_time:\n                    risk_set_shots.append(shot)\n            \n            # Calculate risk scores for all subjects in the risk set\n            risk_scores_exp = []\n            event_shot_risk_score_eta = None\n\n            for shot in risk_set_shots:\n                shot_id, T, delta, segments = shot\n                \n                # Get covariate vector at event_time^-\n                x_vec = get_covariates_at_left_limit(segments, event_time)\n                \n                # Calculate risk score eta = beta.T * x\n                eta = np.dot(beta, x_vec)\n                risk_scores_exp.append(np.exp(eta))\n\n                if shot_id == event_shot_id:\n                    event_shot_risk_score_eta = eta\n\n            # Sum of exponentiated risk scores\n            risk_set_sum = np.sum(risk_scores_exp)\n\n            # Add term to log-likelihood: eta_i - log(sum(exp(eta_j)))\n            if risk_set_sum > 0: # Avoid log(0) if all risk scores are -inf\n                term = event_shot_risk_score_eta - np.log(risk_set_sum)\n                total_log_likelihood += term\n\n        return total_log_likelihood\n\n    results = []\n    for d_key, b_key in test_cases:\n        dataset = datasets[d_key]\n        beta = betas[b_key]\n        result = calculate_log_likelihood(dataset, beta)\n        results.append(result)\n\n    # Format output as specified\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个成功的破裂预测模型的最终价值在于其指导实际操作的能力，例如触发缓解系统。由于假警报（错误肯定，False Positive）和错过破裂（错误否定，False Negative）的代价极不对称，因此将模型的概率输出转化为最优决策至关重要。本练习  应用贝叶斯决策理论，推导在非对称成本下最小化预期风险的最优决策阈值，将机器学习预测与实际的运行需求直接联系起来。",
            "id": "4003916",
            "problem": "在一个托卡马克破裂预测与控制系统中，一个机器学习分类器输出一个校准后的后验概率 $q(\\mathbf{x}) = P(y=1 \\mid \\mathbf{x})$，表示等离子体在短暂的时间范围 $\\Delta t$ 内将会破裂，其中 $y=1$ 表示即将发生破裂，$y=0$ 表示不会立即发生破裂。控制决策是一个二元行为：触发缓解措施 ($a=1$) 或不触发缓解措施 ($a=0$)。当 $a=1$ 且 $y=0$ 时，会发生假阳性 (FP)，产生代价 $C_{\\mathrm{FP}}$；当 $a=0$ 且 $y=1$ 时，会发生假阴性 (FN)，产生代价 $C_{\\mathrm{FN}}$。假设在先验破裂率为 $p = P(y=1)$ 的数据分布下，该分类器的概率是经过良好校准的。\n\n从风险最小化原则和对每个 $\\mathbf{x}$ 的条件期望损失（贝叶斯风险）的定义出发，推导出最优阈值 $\\tau^{\\star}$，使得在非对称代价 $C_{\\mathrm{FP}}$ 和 $C_{\\mathrm{FN}}$ 下，当且仅当 $q(\\mathbf{x}) \\ge \\tau^{\\star}$ 时触发缓解措施。然后，对于一个先验概率 $p = 0.15$，$C_{\\mathrm{FP}} = 1.7$（标准化代价单位），以及 $C_{\\mathrm{FN}} = 9.3$（标准化代价单位）的系统，数值计算 $\\tau^{\\star}$，并假设概率 $q(\\mathbf{x})$ 是相对于同一先验 $p$ 的校准后验概率。将阈值表示为不带单位的小数，并将答案四舍五入到四位有效数字。",
            "solution": "所提出的问题是有效的。这是一个贝叶斯决策理论在具有非对称代价的二元分类任务上的明确应用，也是机器学习及其应用领域中一个标准且有科学依据的问题。托卡马克破裂预测的背景是计算聚变科学中一个现实且重要的研究领域。所有必要的参数都已提供，目标也已明确陈述。\n\n我们首先建立一个最小化期望损失（也称为贝叶斯风险）的框架。对于由特征向量 $\\mathbf{x}$ 表示的每个特定等离子体状态，都需要做出触发缓解措施 ($a=1$) 或不触发 ($a=0$) 的决策。最优决策规则选择在给定观测值 $\\mathbf{x}$ 的情况下，能最小化条件期望损失的行动。\n\n分类器提供了即将发生破裂的后验概率，$q(\\mathbf{x}) = P(y=1 \\mid \\mathbf{x})$，其中 $y=1$ 表示一次破裂，$y=0$ 表示稳定运行。因此，不发生破裂的概率是 $P(y=0 \\mid \\mathbf{x}) = 1 - q(\\mathbf{x})$。\n\n该问题为错误决策定义了一个代价结构。设 $L(a, y)$ 为当真实结果为 $y$ 时采取行动 $a$ 所产生的损失。根据问题陈述：\n\\begin{itemize}\n    \\item 假阳性 (FP) 的代价：采取行动 $a=1$ (缓解)，但真实状态是 $y=0$ (无破裂)。损失为 $L(1, 0) = C_{\\mathrm{FP}}$。\n    \\item 假阴性 (FN) 的代价：采取行动 $a=0$ (不缓解)，但真实状态是 $y=1$ (破裂)。损失为 $L(0, 1) = C_{\\mathrm{FN}}$。\n\\end{itemize}\n正确决策的代价默认为零，这是专注于因错误而产生损失的标准惯例。\n\\begin{itemize}\n    \\item 真阳性 (TP) 的代价：行动为 $a=1$，真实状态为 $y=1$。损失为 $L(1, 1) = 0$。\n    \\item 真阴性 (TN) 的代价：行动为 $a=0$，真实状态为 $y=0$。损失为 $L(0, 0) = 0$。\n\\end{itemize}\n\n对于每个行动 $a$，条件期望损失（或称风险）$R(a \\mid \\mathbf{x})$ 是该行动可能产生的损失按其条件概率加权后的总和。\n\n对于行动 $a=1$ (触发缓解措施)，条件期望损失为：\n$$R(a=1 \\mid \\mathbf{x}) = L(1, 1)P(y=1 \\mid \\mathbf{x}) + L(1, 0)P(y=0 \\mid \\mathbf{x})$$\n代入已知值和概率：\n$$R(a=1 \\mid \\mathbf{x}) = (0) \\cdot q(\\mathbf{x}) + C_{\\mathrm{FP}} \\cdot (1 - q(\\mathbf{x})) = C_{\\mathrm{FP}}(1 - q(\\mathbf{x}))$$\n\n对于行动 $a=0$ (不触发缓解措施)，条件期望损失为：\n$$R(a=0 \\mid \\mathbf{x}) = L(0, 1)P(y=1 \\mid \\mathbf{x}) + L(0, 0)P(y=0 \\mid \\mathbf{x})$$\n代入已知值和概率：\n$$R(a=0 \\mid \\mathbf{x}) = C_{\\mathrm{FN}} \\cdot q(\\mathbf{x}) + (0) \\cdot (1 - q(\\mathbf{x})) = C_{\\mathrm{FN}}q(\\mathbf{x})$$\n\n贝叶斯最优决策规则是选择条件期望损失最小的行动。如果触发缓解措施的风险小于或等于不触发的风险，我们应该触发缓解措施 ($a=1$)。问题将决策规则指定为当 $q(\\mathbf{x}) \\ge \\tau^{\\star}$ 时触发，这意味着将边界情况（风险相等）分配给行动 $a=1$。因此，我们在以下情况下触发缓解措施：\n$$R(a=1 \\mid \\mathbf{x}) \\le R(a=0 \\mid \\mathbf{x})$$\n代入风险的表达式：\n$$C_{\\mathrm{FP}}(1 - q(\\mathbf{x})) \\le C_{\\mathrm{FN}}q(\\mathbf{x})$$\n我们现在对 $q(\\mathbf{x})$ 求解这个不等式，以找出缓解措施是最佳行动的条件。\n$$C_{\\mathrm{FP}} - C_{\\mathrm{FP}}q(\\mathbf{x}) \\le C_{\\mathrm{FN}}q(\\mathbf{x})$$\n$$C_{\\mathrm{FP}} \\le C_{\\mathrm{FN}}q(\\mathbf{x}) + C_{\\mathrm{FP}}q(\\mathbf{x})$$\n$$C_{\\mathrm{FP}} \\le (C_{\\mathrm{FP}} + C_{\\mathrm{FN}})q(\\mathbf{x})$$\n假设 $C_{\\mathrm{FP}} + C_{\\mathrm{FN}} > 0$，这是物理上必需的，因为代价不能为负，我们可以在不改变不等式方向的情况下进行除法：\n$$q(\\mathbf{x}) \\ge \\frac{C_{\\mathrm{FP}}}{C_{\\mathrm{FP}} + C_{\\mathrm{FN}}}$$\n这个不等式定义了决策规则。当且仅当分类器的输出概率 $q(\\mathbf{x})$ 超过某个阈值时，才选择缓解行动 $a=1$。通过将其与期望的决策规则形式 $q(\\mathbf{x}) \\ge \\tau^{\\star}$ 进行比较，我们可以直接确定最优阈值 $\\tau^{\\star}$。\n$$\\tau^{\\star} = \\frac{C_{\\mathrm{FP}}}{C_{\\mathrm{FP}} + C_{\\mathrm{FN}}}$$\n值得注意的是，这个最优阈值仅取决于错误分类的代价，并且与破裂的先验概率 $p=P(y=1)$ 无关。先验概率对于训练和校准分类器是相关的，以确保 $q(\\mathbf{x})$ 是一个正确的后验概率，但它本身不进入阈值的计算过程。\n\n现在，我们使用给定的代价 $C_{\\mathrm{FP}} = 1.7$ 和 $C_{\\mathrm{FN}} = 9.3$ 来计算 $\\tau^{\\star}$ 的数值。\n$$\\tau^{\\star} = \\frac{1.7}{1.7 + 9.3}$$\n$$\\tau^{\\star} = \\frac{1.7}{11.0}$$\n$$\\tau^{\\star} = 0.154545\\overline{45}...$$\n问题要求将答案四舍五入到四位有效数字。\n$$\\tau^{\\star} \\approx 0.1545$$\n这是触发缓解系统的最优阈值。如果 $q(\\mathbf{x}) \\ge 0.1545$，则采取行动 $a=1$，否则采取行动 $a=0$。",
            "answer": "$$\n\\boxed{0.1545}\n$$"
        }
    ]
}