{
    "hands_on_practices": [
        {
            "introduction": "Modeling heat transport in a magnetized fusion plasma presents a formidable numerical challenge due to the extreme anisotropy, where heat flows millions of times faster along magnetic field lines than across them. This disparity leads to a mathematically \"stiff\" problem, where explicit time-integration schemes are severely constrained by stability requirements. This practice demonstrates this critical issue by deriving the stability limit for an explicit diffusion solver and quantifying the immense computational performance gain offered by an implicit approach, a technique essential for efficiently simulating ELM crashes .",
            "id": "3970115",
            "problem": "Consider modeling the rapid temperature evolution along a magnetic field line during an Edge Localized Mode (ELM) crash in a tokamak pedestal using a reduced one-dimensional model for electron parallel heat transport. Let $s$ denote the arc length along the magnetic field line, and let $T(s,t)$ be the electron temperature. Assume that, over the time window of interest, the temperature dynamics along the field line are dominated by linear diffusion with a constant parallel thermal diffusivity $\\chi_{\\parallel}$, so that the governing equation is the heat equation\n$$\n\\frac{\\partial T}{\\partial t} \\;=\\; \\chi_{\\parallel}\\,\\frac{\\partial^{2}T}{\\partial s^{2}}\\,,\n$$\nposed on a parallel connection length $L_{\\parallel}$ with periodic boundary conditions. You wish to compare explicit and implicit time integration for the diffusive term during the crash.\n\nStarting from this partial differential equation and a standard second-order central finite-difference approximation in space on a uniform grid of $N$ nodes with spacing $\\Delta s \\equiv L_{\\parallel}/N$, and using a forward Euler explicit time integrator, use Fourier (von Neumann) analysis to derive the stability constraint on the timestep $\\Delta t$ in terms of $\\Delta s$ and $\\chi_{\\parallel}$. Then, evaluate the most restrictive explicit stable timestep $\\Delta t_{\\mathrm{exp}}^{\\max}$ for the following scientifically plausible pedestal-line parameters:\n- $L_{\\parallel} = 30\\,\\mathrm{m}$,\n- $N = 6000$,\n- $\\chi_{\\parallel} = 3.0 \\times 10^{8}\\,\\mathrm{m^{2}\\,s^{-1}}$.\n\nNow consider replacing the explicit integrator for the diffusion term with a fully implicit backward Euler integrator, which is unconditionally stable for the linear diffusion equation. Suppose that to resolve the global crash dynamics you target approximately $50$ time steps across a characteristic crash time $\\tau_{\\mathrm{crash}} = 0.5\\,\\mathrm{ms}$, so that the accuracy-motivated implicit timestep is $\\Delta t_{\\mathrm{imp}} = \\tau_{\\mathrm{crash}}/50$.\n\nDefine the improvement factor\n$$\nS \\;\\equiv\\; \\frac{\\Delta t_{\\mathrm{imp}}}{\\Delta t_{\\mathrm{exp}}^{\\max}}\\,.\n$$\n\nCompute $S$ for the parameters given above. Express your final numerical answer as a pure number without units and round to three significant figures. Use the International System of Units (SI) for all intermediate computations.",
            "solution": "The problem requires a two-part calculation. First, we must derive the stability constraint for a forward Euler explicit time integration scheme applied to the one-dimensional heat equation. Second, we must use this result to compute an \"improvement factor\" $S$, which compares the stability-limited explicit timestep to an accuracy-limited implicit timestep for a set of given physical parameters.\n\nThe governing partial differential equation for the electron temperature $T(s,t)$ is the heat equation:\n$$\n\\frac{\\partial T}{\\partial t} \\;=\\; \\chi_{\\parallel}\\,\\frac{\\partial^{2}T}{\\partial s^{2}}\n$$\nwhere $s$ is the arc length along the magnetic field line, $t$ is time, and $\\chi_{\\parallel}$ is the constant parallel thermal diffusivity.\n\nFirst, we discretize this equation. Let $T_j^n$ denote the temperature at spatial grid point $j$ and time level $n$, such that $s_j = j \\Delta s$ and $t_n = n \\Delta t$. We use a second-order central finite-difference for the spatial derivative and a forward Euler scheme for the time derivative.\n\nThe spatial derivative is approximated as:\n$$\n\\frac{\\partial^{2}T}{\\partial s^{2}}\\bigg|_{s_j} \\approx \\frac{T_{j+1}^n - 2T_j^n + T_{j-1}^n}{(\\Delta s)^2}\n$$\nThe time derivative is approximated as:\n$$\n\\frac{\\partial T}{\\partial t}\\bigg|_{t_n} \\approx \\frac{T_j^{n+1} - T_j^n}{\\Delta t}\n$$\nSubstituting these into the heat equation yields the fully discretized scheme:\n$$\n\\frac{T_j^{n+1} - T_j^n}{\\Delta t} = \\chi_{\\parallel} \\frac{T_{j+1}^n - 2T_j^n + T_{j-1}^n}{(\\Delta s)^2}\n$$\nRearranging for $T_j^{n+1}$, we get the update rule:\n$$\nT_j^{n+1} = T_j^n + \\frac{\\chi_{\\parallel} \\Delta t}{(\\Delta s)^2} (T_{j+1}^n - 2T_j^n + T_{j-1}^n)\n$$\nTo analyze the stability of this scheme, we perform a von Neumann stability analysis. We consider a single Fourier mode of the solution, $T_j^n = G(k)^n e^{ik s_j}$, where $k$ is the wavenumber and $G(k)$ is the amplification factor per timestep. Substituting this form into the update rule:\n$$\nG(k)^{n+1} e^{ikj\\Delta s} = G(k)^n e^{ikj\\Delta s} + \\frac{\\chi_{\\parallel} \\Delta t}{(\\Delta s)^2} \\left( G(k)^n e^{ik(j+1)\\Delta s} - 2G(k)^n e^{ikj\\Delta s} + G(k)^n e^{ik(j-1)\\Delta s} \\right)\n$$\nDividing by $G(k)^n e^{ikj\\Delta s}$ gives the expression for the amplification factor $G(k)$:\n$$\nG(k) = 1 + \\frac{\\chi_{\\parallel} \\Delta t}{(\\Delta s)^2} \\left( e^{ik\\Delta s} - 2 + e^{-ik\\Delta s} \\right)\n$$\nUsing the identity $e^{i\\theta} + e^{-i\\theta} = 2\\cos(\\theta)$, this simplifies to:\n$$\nG(k) = 1 + \\frac{\\chi_{\\parallel} \\Delta t}{(\\Delta s)^2} \\left( 2\\cos(k\\Delta s) - 2 \\right) = 1 - \\frac{2\\chi_{\\parallel} \\Delta t}{(\\Delta s)^2} \\left( 1 - \\cos(k\\Delta s) \\right)\n$$\nUsing the half-angle identity $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$, we obtain:\n$$\nG(k) = 1 - \\frac{4\\chi_{\\parallel} \\Delta t}{(\\Delta s)^2} \\sin^2\\left(\\frac{k\\Delta s}{2}\\right)\n$$\nFor the scheme to be numerically stable, the magnitude of the amplification factor must be no greater than $1$ for all possible wavenumbers $k$, i.e., $|G(k)| \\le 1$. This implies $-1 \\le G(k) \\le 1$.\n\nThe condition $G(k) \\le 1$ becomes $1 - \\frac{4\\chi_{\\parallel} \\Delta t}{(\\Delta s)^2} \\sin^2\\left(\\frac{k\\Delta s}{2}\\right) \\le 1$, which simplifies to $-\\frac{4\\chi_{\\parallel} \\Delta t}{(\\Delta s)^2} \\sin^2\\left(\\frac{k\\Delta s}{2}\\right) \\le 0$. Since $\\chi_{\\parallel}$, $\\Delta t$, $(\\Delta s)^2$, and $\\sin^2(\\cdot)$ are all non-negative, this condition is always satisfied.\n\nThe condition $G(k) \\ge -1$ is the crucial one:\n$$\n1 - \\frac{4\\chi_{\\parallel} \\Delta t}{(\\Delta s)^2} \\sin^2\\left(\\frac{k\\Delta s}{2}\\right) \\ge -1\n$$\n$$\n2 \\ge \\frac{4\\chi_{\\parallel} \\Delta t}{(\\Delta s)^2} \\sin^2\\left(\\frac{k\\Delta s}{2}\\right)\n$$\n$$\n\\frac{\\chi_{\\parallel} \\Delta t}{(\\Delta s)^2} \\le \\frac{1}{2\\sin^2\\left(\\frac{k\\Delta s}{2}\\right)}\n$$\nThis must hold for all $k$. The most restrictive condition occurs when the right-hand side is minimized, which corresponds to the denominator being maximized. The maximum value of $\\sin^2(\\cdot)$ is $1$, which occurs for the highest frequency mode the grid can resolve, $k\\Delta s = \\pi$. This yields the stability constraint:\n$$\n\\frac{\\chi_{\\parallel} \\Delta t}{(\\Delta s)^2} \\le \\frac{1}{2}\n$$\nThus, the timestep $\\Delta t$ is constrained by:\n$$\n\\Delta t \\le \\frac{(\\Delta s)^2}{2\\chi_{\\parallel}}\n$$\nThe most restrictive explicit stable timestep, $\\Delta t_{\\mathrm{exp}}^{\\max}$, is the maximum allowed value:\n$$\n\\Delta t_{\\mathrm{exp}}^{\\max} = \\frac{(\\Delta s)^2}{2\\chi_{\\parallel}}\n$$\nNow, we compute the numerical values. First, the grid spacing $\\Delta s$:\nGiven $L_{\\parallel} = 30\\,\\mathrm{m}$ and $N = 6000$.\n$$\n\\Delta s = \\frac{L_{\\parallel}}{N} = \\frac{30\\,\\mathrm{m}}{6000} = 0.005\\,\\mathrm{m} = 5 \\times 10^{-3}\\,\\mathrm{m}\n$$\nNext, we compute $\\Delta t_{\\mathrm{exp}}^{\\max}$ using $\\chi_{\\parallel} = 3.0 \\times 10^{8}\\,\\mathrm{m^{2}\\,s^{-1}}$:\n$$\n\\Delta t_{\\mathrm{exp}}^{\\max} = \\frac{(5 \\times 10^{-3}\\,\\mathrm{m})^2}{2 \\times (3.0 \\times 10^{8}\\,\\mathrm{m^{2}\\,s^{-1}})} = \\frac{25 \\times 10^{-6}\\,\\mathrm{m}^2}{6.0 \\times 10^{8}\\,\\mathrm{m^{2}\\,s^{-1}}}\n$$\n$$\n\\Delta t_{\\mathrm{exp}}^{\\max} = \\frac{25}{6.0} \\times 10^{-14}\\,\\mathrm{s} \\approx 4.1667 \\times 10^{-14}\\,\\mathrm{s}\n$$\nNext, we determine the implicit timestep $\\Delta t_{\\mathrm{imp}}$. This is set by accuracy requirements for resolving the crash dynamics over a characteristic time $\\tau_{\\mathrm{crash}} = 0.5\\,\\mathrm{ms}$ in approximately $50$ steps.\n$$\n\\tau_{\\mathrm{crash}} = 0.5\\,\\mathrm{ms} = 0.5 \\times 10^{-3}\\,\\mathrm{s} = 5 \\times 10^{-4}\\,\\mathrm{s}\n$$\n$$\n\\Delta t_{\\mathrm{imp}} = \\frac{\\tau_{\\mathrm{crash}}}{50} = \\frac{5 \\times 10^{-4}\\,\\mathrm{s}}{50} = 1 \\times 10^{-5}\\,\\mathrm{s}\n$$\nFinally, we compute the improvement factor $S$:\n$$\nS = \\frac{\\Delta t_{\\mathrm{imp}}}{\\Delta t_{\\mathrm{exp}}^{\\max}} = \\frac{1 \\times 10^{-5}\\,\\mathrm{s}}{\\frac{25}{6.0} \\times 10^{-14}\\,\\mathrm{s}} = \\frac{6.0}{25} \\times \\frac{10^{-5}}{10^{-14}} = 0.24 \\times 10^9 = 2.4 \\times 10^8\n$$\nThe problem specifies the answer should be rounded to three significant figures.\n$$\nS = 2.40 \\times 10^8\n$$\nThis very large number illustrates the extreme stiffness of the parallel heat diffusion problem in fusion plasmas and highlights the significant computational advantage of using implicit methods over explicit ones for such problems.",
            "answer": "$$ \\boxed{2.40 \\times 10^8} $$"
        },
        {
            "introduction": "After developing a numerical model, a crucial step is verification: ensuring the code correctly solves the mathematical equations it is intended to. A cornerstone of code verification is the grid convergence study, which checks if the numerical error decreases at the theoretically expected rate as the simulation's spatial resolution is increased. This hands-on practice guides you through the standard procedure of calculating the observed order of accuracy from a set of simulated data, a fundamental skill for validating any scientific computing code .",
            "id": "3970125",
            "problem": "Consider modeling the linear growth rate of an Edge Localized Mode (ELM) instability in a magnetically confined plasma using discretizations that resolve the pedestal edge region. Let the continuum (grid-independent) growth rate be denoted by $\\gamma_\\infty$ with physical units $\\mathrm{s}^{-1}$. A sequence of numerical simulations provides approximate growth rates $\\gamma(\\Delta)$ at multiple grid spacings $\\Delta$ (in meters). For a consistent discretization, the leading-order grid-induced error is well-approximated by a power law of the form\n$$\nE(\\Delta) \\equiv \\lvert \\gamma(\\Delta) - \\gamma_\\infty \\rvert \\sim C \\Delta^p,\n$$\nwhere $C$ is a constant and $p$ is the observed order of accuracy. This scaling arises from truncation error in the discretized Magnetohydrodynamics (MHD) equations that govern linear ELM growth in the plasma edge, under standard smoothness assumptions on the solution and the numerical scheme.\n\nYour task is to write a program that, for each test case provided below, estimates the observed order $p$ by fitting the model $E(\\Delta) \\approx C \\Delta^p$ using an ordinary least squares regression in logarithmic variables. Specifically, use the transformation\n$$\n\\log E(\\Delta) \\approx \\log C + p \\log \\Delta\n$$\nwith the natural logarithm, and determine $p$ as the fitted slope. Use all available points in each test case.\n\nPhysical units: All growth rates must be treated in $\\mathrm{s}^{-1}$ and all grid spacings in $\\mathrm{m}$. The final reported $p$ values are dimensionless.\n\nTest suite:\n- Case A (nominal second-order convergence, underprediction bias): $\\gamma_\\infty = 120000\\,\\mathrm{s}^{-1}$, grid spacings $\\Delta \\in \\{0.004, 0.002, 0.001, 0.0005\\}\\,\\mathrm{m}$, simulated growth rates $\\gamma(\\Delta) \\in \\{118720, 119680, 119920, 119980\\}\\,\\mathrm{s}^{-1}$.\n- Case B (nominal first-order convergence, overprediction bias): $\\gamma_\\infty = 95000\\,\\mathrm{s}^{-1}$, grid spacings $\\Delta \\in \\{0.003, 0.0015, 0.00075, 0.000375\\}\\,\\mathrm{m}$, simulated growth rates $\\gamma(\\Delta) \\in \\{95060, 95030, 95015, 95007.5\\}\\,\\mathrm{s}^{-1}$.\n- Case C (nominal third-order convergence with mild jitter, underprediction bias): $\\gamma_\\infty = 180000\\,\\mathrm{s}^{-1}$, grid spacings $\\Delta \\in \\{0.0025, 0.00125, 0.000625, 0.0003125\\}\\,\\mathrm{m}$, simulated growth rates $\\gamma(\\Delta) \\in \\{179764.6875, 179970.791015625, 179996.31958007812, 179999.5440673828\\}\\,\\mathrm{s}^{-1}$.\n\nRequirements:\n1. For each case, compute the error values $E(\\Delta) = \\lvert \\gamma(\\Delta) - \\gamma_\\infty \\rvert$.\n2. Fit the linear model in the variables $(x, y) = (\\log \\Delta, \\log E(\\Delta))$ using ordinary least squares to estimate $p$ as the slope.\n3. Round each estimated $p$ to three decimal places.\n\nFinal output format:\nYour program should produce a single line of output containing the three rounded $p$ values for Cases A, B, and C, in that order, as a comma-separated list enclosed in square brackets, for example, $[p_A,p_B,p_C]$. The numbers must be printed as decimal floats rounded to three decimal places with no additional text.",
            "solution": "The objective of this problem is to determine the observed order of accuracy, $p$, for a series of numerical simulations of an Edge Localized Mode (ELM) instability. This is a standard procedure in the verification and validation of scientific codes, where the convergence of a numerical solution to the continuum solution is assessed as the grid resolution is refined.\n\nThe theoretical basis for this analysis is the power-law relationship between the numerical error, $E(\\Delta)$, and the grid spacing, $\\Delta$. The error is defined as the absolute difference between the numerically computed growth rate, $\\gamma(\\Delta)$, and the grid-independent (continuum) growth rate, $\\gamma_\\infty$:\n$$\nE(\\Delta) = \\lvert \\gamma(\\Delta) - \\gamma_\\infty \\rvert\n$$\nFor a consistent numerical scheme of order $p$, this error is expected to scale as:\n$$\nE(\\Delta) \\approx C \\Delta^p\n$$\nwhere $C$ is a constant that depends on the magnitude of higher-order derivatives of the solution, and $p$ is the order of accuracy.\n\nTo estimate $p$ from the provided data, we linearize the model by taking the natural logarithm of both sides:\n$$\n\\ln(E(\\Delta)) \\approx \\ln(C) + p \\ln(\\Delta)\n$$\nThis equation has the form of a line, $y = b + mx$, where the variables are $y = \\ln(E(\\Delta))$ and $x = \\ln(\\Delta)$, the slope is $m = p$, and the y-intercept is $b = \\ln(C)$. We can therefore determine $p$ by performing an ordinary least squares (OLS) linear regression on the set of data points $(\\ln(\\Delta_i), \\ln(E_i))$ for each case. The slope $p$ is given by the formula:\n$$\np = \\frac{n \\sum_{i=1}^{n} (x_i y_i) - (\\sum_{i=1}^{n} x_i)(\\sum_{i=1}^{n} y_i)}{n \\sum_{i=1}^{n} (x_i^2) - (\\sum_{i=1}^{n} x_i)^2}\n$$\nwhere $n$ is the number of data points, $x_i = \\ln(\\Delta_i)$, and $y_i = \\ln(E(\\Delta_i))$. The following analysis applies this procedure to each test case.\n\n**Case A Analysis**\nThe provided data for this case are:\n-   Continuum growth rate: $\\gamma_\\infty = 120000\\,\\mathrm{s}^{-1}$\n-   Grid spacings: $\\Delta = \\{0.004, 0.002, 0.001, 0.0005\\}\\,\\mathrm{m}$\n-   Simulated growth rates: $\\gamma(\\Delta) = \\{118720, 119680, 119920, 119980\\}\\,\\mathrm{s}^{-1}$\n\nFirst, we compute the error $E(\\Delta_i) = \\lvert \\gamma(\\Delta_i) - \\gamma_\\infty \\rvert$ for each data point:\n-   $E_1 = \\lvert 118720 - 120000 \\rvert = 1280$\n-   $E_2 = \\lvert 119680 - 120000 \\rvert = 320$\n-   $E_3 = \\lvert 119920 - 120000 \\rvert = 80$\n-   $E_4 = \\lvert 119980 - 120000 \\rvert = 20$\n\nNext, we compute the log-transformed variables $x_i = \\ln(\\Delta_i)$ and $y_i = \\ln(E_i)$:\n-   $x_1 = \\ln(0.004) \\approx -5.5215$\n-   $x_2 = \\ln(0.002) \\approx -6.2146$\n-   $x_3 = \\ln(0.001) \\approx -6.9078$\n-   $x_4 = \\ln(0.0005) \\approx -7.6009$\n-   $y_1 = \\ln(1280) \\approx 7.1546$\n-   $y_2 = \\ln(320) \\approx 5.7683$\n-   $y_3 = \\ln(80) \\approx 4.3820$\n-   $y_4 = \\ln(20) \\approx 2.9957$\n\nPerforming a linear regression on these $(x_i, y_i)$ pairs yields the slope $p_A$. The error reduces by a factor of $4$ each time the grid spacing is halved, which indicates a perfect second-order convergence. The calculation confirms this.\n$p_A = 2.0$\n\n**Case B Analysis**\nThe provided data for this case are:\n-   Continuum growth rate: $\\gamma_\\infty = 95000\\,\\mathrm{s}^{-1}$\n-   Grid spacings: $\\Delta = \\{0.003, 0.0015, 0.00075, 0.000375\\}\\,\\mathrm{m}$\n-   Simulated growth rates: $\\gamma(\\Delta) = \\{95060, 95030, 95015, 95007.5\\}\\,\\mathrm{s}^{-1}$\n\nFirst, we compute the error $E(\\Delta_i)$:\n-   $E_1 = \\lvert 95060 - 95000 \\rvert = 60$\n-   $E_2 = \\lvert 95030 - 95000 \\rvert = 30$\n-   $E_3 = \\lvert 95015 - 95000 \\rvert = 15$\n-   $E_4 = \\lvert 95007.5 - 95000 \\rvert = 7.5$\n\nNext, we compute the log-transformed variables $x_i = \\ln(\\Delta_i)$ and $y_i = \\ln(E_i)$:\n-   $x_1 = \\ln(0.003) \\approx -5.8091$\n-   $x_2 = \\ln(0.0015) \\approx -6.5023$\n-   $x_3 = \\ln(0.00075) \\approx -7.1954$\n-   $x_4 = \\ln(0.000375) \\approx -7.8886$\n-   $y_1 = \\ln(60) \\approx 4.0943$\n-   $y_2 = \\ln(30) \\approx 3.4012$\n-   $y_3 = \\ln(15) \\approx 2.7081$\n-   $y_4 = \\ln(7.5) \\approx 2.0149$\n\nPerforming the linear regression on these pairs yields the slope $p_B$. In this case, the error reduces by a factor of $2$ each time the grid spacing is halved, which points to a perfect first-order convergence.\n$p_B = 1.0$\n\n**Case C Analysis**\nThe provided data for this case are:\n-   Continuum growth rate: $\\gamma_\\infty = 180000\\,\\mathrm{s}^{-1}$\n-   Grid spacings: $\\Delta = \\{0.0025, 0.00125, 0.000625, 0.0003125\\}\\,\\mathrm{m}$\n-   Simulated growth rates: $\\gamma(\\Delta) = \\{179764.6875, 179970.791015625, 179996.31958007812, 179999.5440673828\\}\\,\\mathrm{s}^{-1}$\n\nFirst, we compute the error $E(\\Delta_i)$:\n-   $E_1 = \\lvert 179764.6875 - 180000 \\rvert = 235.3125$\n-   $E_2 = \\lvert 179970.791015625 - 180000 \\rvert = 29.208984375$\n-   $E_3 = \\lvert 179996.31958007812 - 180000 \\rvert = 3.680419921875$\n-   $E_4 = \\lvert 179999.5440673828 - 180000 \\rvert \\approx 0.4559326172$\n\nNext, we compute the log-transformed variables $x_i = \\ln(\\Delta_i)$ and $y_i = \\ln(E_i)$:\n-   $x_1 = \\ln(0.0025) \\approx -5.9915$\n-   $x_2 = \\ln(0.00125) \\approx -6.6846$\n-   $x_3 = \\ln(0.000625) \\approx -7.3778$\n-   $x_4 = \\ln(0.0003125) \\approx -8.0709$\n-   $y_1 = \\ln(235.3125) \\approx 5.4609$\n-   $y_2 = \\ln(29.20898) \\approx 3.3745$\n-   $y_3 = \\ln(3.68042) \\approx 1.3030$\n-   $y_4 = \\ln(0.45593) \\approx -0.7854$\n\nPerforming the linear regression on these pairs yields the slope $p_C$. The error reduction factor between successive refinements is close to $8 = 2^3$, suggesting a third-order scheme. The OLS fit provides a precise estimate.\n$p_C \\approx 3.00397556$\n\n**Summary of Results**\nThe calculated orders of accuracy for each case, rounded to three decimal places as required, are:\n-   Case A: $p_A = 2.000$\n-   Case B: $p_B = 1.000$\n-   Case C: $p_C = 3.004$\nThese results are consistent with the descriptions of nominal second-order, first-order, and third-order convergence, respectively.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the observed order of accuracy 'p' for numerical simulation data\n    by performing a linear regression on the log-transformed error data.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"gamma_inf\": 120000.0,\n            \"delta\": np.array([0.004, 0.002, 0.001, 0.0005]),\n            \"gamma_delta\": np.array([118720, 119680, 119920, 119980])\n        },\n        {\n            \"name\": \"Case B\",\n            \"gamma_inf\": 95000.0,\n            \"delta\": np.array([0.003, 0.0015, 0.00075, 0.000375]),\n            \"gamma_delta\": np.array([95060, 95030, 95015, 95007.5])\n        },\n        {\n            \"name\": \"Case C\",\n            \"gamma_inf\": 180000.0,\n            \"delta\": np.array([0.0025, 0.00125, 0.000625, 0.0003125]),\n            \"gamma_delta\": np.array([179764.6875, 179970.791015625, 179996.31958007812, 179999.5440673828])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Step 1: Compute the error values E(Delta) = |gamma(Delta) - gamma_inf|.\n        error = np.abs(case[\"gamma_delta\"] - case[\"gamma_inf\"])\n\n        # Step 2: Transform variables for linear regression:\n        # x = log(Delta), y = log(E(Delta))\n        log_delta = np.log(case[\"delta\"])\n        log_error = np.log(error)\n\n        # Step 3: Fit the linear model y = p*x + log(C) using ordinary least squares.\n        # np.polyfit with degree 1 performs a linear regression and returns [slope, intercept].\n        # The slope 'p' is the observed order of accuracy.\n        p, _ = np.polyfit(log_delta, log_error, 1)\n        \n        # Format the result to three decimal places.\n        results.append(f\"{p:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While grid convergence studies assess the overall accuracy of a code, the Method of Manufactured Solutions (MMS) offers a more rigorous and detailed verification test. By constructing an exact analytic solution to the governing equations (including specially designed source terms), MMS allows for a precise, term-by-term quantification of the code's truncation error. This advanced exercise will guide you through implementing an MMS test for a reduced magnetohydrodynamics model, providing a powerful tool for debugging complex codes and building confidence in their numerical implementation .",
            "id": "3970135",
            "problem": "You are tasked with verifying a spatial discretization for a reduced, resistive magnetohydrodynamics (RRMHD) model relevant to edge localized mode (ELM) crash modeling. Use the method of manufactured solutions to construct analytic source terms so that a prescribed set of fields solves the target equations exactly in the continuum, and then compute the residuals obtained when those equations are assembled with second-order centered finite differences on a uniform, periodic grid. The computed residual norms constitute a quantitative test of code accuracy.\n\nConsider a two-dimensional slab domain with coordinates $(x,y)$, periodic on $[0,2\\pi)\\times[0,2\\pi)$, and time $t$. Let the electrostatic stream function be $\\phi(x,y,t)$, the magnetic flux be $\\psi(x,y,t)$, and the number density be $n(x,y,t)$. The RRMHD model consists of the following system:\n- Induction equation (from Faraday’s law and resistive Ohm’s law): \n$$\n\\partial_t \\psi + [\\phi,\\psi] = \\eta \\nabla^2 \\psi + S_\\psi,\n$$\n- Vorticity equation (from the curl of the momentum equation with kinematic viscosity):\n$$\n\\partial_t \\nabla^2 \\phi + [\\phi,\\nabla^2 \\phi] = [\\psi,\\nabla^2 \\psi] + \\nu \\nabla^4 \\phi + S_\\omega,\n$$\n- Continuity equation (number density with Fickian diffusion):\n$$\n\\partial_t n + [\\phi,n] = D \\nabla^2 n + S_n,\n$$\nwhere $[a,b] \\equiv \\partial_x a \\, \\partial_y b - \\partial_y a \\, \\partial_x b$ is the Poisson bracket, $\\eta$ is the resistivity, $\\nu$ is the kinematic viscosity, $D$ is the particle diffusivity, and $S_\\psi$, $S_\\omega$, $S_n$ are source terms to be determined by the method of manufactured solutions. Angles are in radians, and all variables are nondimensional.\n\nManufacture the following analytic fields, with $k_x, k_y \\in \\mathbb{Z}^+$:\n$$\n\\phi(x,y,t) = A_\\phi \\sin(k_x x)\\sin(k_y y)\\cos(\\omega t),\n$$\n$$\n\\psi(x,y,t) = A_\\psi \\cos(k_x x)\\sin(k_y y)\\sin(\\omega t),\n$$\n$$\nn(x,y,t) = n_0 + A_n \\sin(k_x x)\\cos(k_y y)\\cos(\\omega t),\n$$\nwith $K^2 \\equiv k_x^2 + k_y^2$. Define $S_\\psi$, $S_\\omega$, and $S_n$ so that the above $(\\phi,\\psi,n)$ satisfy the three partial differential equations exactly in the continuum:\n$$\nS_\\psi \\equiv \\partial_t \\psi + [\\phi,\\psi] - \\eta \\nabla^2 \\psi,\n$$\n$$\nS_\\omega \\equiv \\partial_t \\nabla^2 \\phi + [\\phi,\\nabla^2 \\phi] - [\\psi,\\nabla^2 \\psi] - \\nu \\nabla^4 \\phi,\n$$\n$$\nS_n \\equiv \\partial_t n + [\\phi,n] - D \\nabla^2 n.\n$$\n\nNow, for a given parameter set, do the following at a fixed evaluation time $t=t_0$:\n1. Construct $\\phi$, $\\psi$, and $n$ on a uniform grid of size $N_x\\times N_y$ over $[0,2\\pi)\\times[0,2\\pi)$ with periodic boundary conditions.\n2. Compute $S_\\psi$, $S_\\omega$, and $S_n$ analytically using the above manufactured fields and exact derivatives.\n3. Assemble the discrete residual fields $R_\\psi$, $R_\\omega$, and $R_n$ by replacing spatial derivatives in the governing equations with second-order centered finite differences (periodic) while keeping time derivatives exact from the analytic fields. Specifically,\n   - Use centered differences for $\\partial_x$, $\\partial_y$, $\\nabla^2$ and define $\\nabla^4 \\phi$ as $\\nabla^2(\\nabla^2\\phi)$.\n   - Define the discrete Poisson bracket as $[\\! [a,b]\\! ] \\equiv (\\partial_x a)(\\partial_y b) - (\\partial_y a)(\\partial_x b)$, where all spatial derivatives are approximated by second-order centered differences.\n   - Build the residuals as:\n   $$\n   R_\\psi \\equiv \\partial_t \\psi + [\\![\\phi,\\psi]\\!] - \\eta \\nabla^2_{\\Delta} \\psi - S_\\psi,\n   $$\n   $$\n   R_\\omega \\equiv \\partial_t \\nabla^2 \\phi + [\\![\\phi,\\nabla^2_{\\Delta} \\phi]\\!] - [\\![\\psi,\\nabla^2_{\\Delta} \\psi]\\!] - \\nu \\nabla^4_{\\Delta} \\phi - S_\\omega,\n   $$\n   $$\n   R_n \\equiv \\partial_t n + [\\![\\phi,n]\\!] - D \\nabla^2_{\\Delta} n - S_n,\n   $$\n   where $\\nabla^2_{\\Delta}$ and $\\nabla^4_{\\Delta}$ denote the discrete Laplacian and biharmonic constructed from centered differences.\n4. For each residual field, compute the discrete root-mean-square (RMS) norm\n$$\n\\|R\\|_2 \\equiv \\sqrt{\\frac{1}{N_x N_y} \\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1} R_{i,j}^2 }.\n$$\n\nTest Suite:\nEvaluate the RMS residual norms for the following three parameter sets. All quantities are nondimensional, and all angles are in radians.\n\n- Case A (happy path, moderate scales):\n  - $N_x = 32$, $N_y = 32$, $k_x = 2$, $k_y = 3$, $\\omega = 1.4$, $\\eta = 3\\times 10^{-3}$, $\\nu = 2\\times 10^{-3}$, $D = 10^{-3}$, $A_\\phi = 0.1$, $A_\\psi = 0.08$, $A_n = 0.02$, $n_0 = 1.0$, $t_0 = 0.37$.\n- Case B (finer grid, higher mode content):\n  - $N_x = 64$, $N_y = 64$, $k_x = 7$, $k_y = 5$, $\\omega = 0.9$, $\\eta = 10^{-4}$, $\\nu = 10^{-4}$, $D = 5\\times 10^{-4}$, $A_\\phi = 0.2$, $A_\\psi = 0.1$, $A_n = 0.05$, $n_0 = 0.8$, $t_0 = 0.37$.\n- Case C (coarser grid, relatively larger dissipation):\n  - $N_x = 16$, $N_y = 16$, $k_x = 5$, $k_y = 5$, $\\omega = 2.0$, $\\eta = 10^{-2}$, $\\nu = 2\\times 10^{-2}$, $D = 5\\times 10^{-3}$, $A_\\phi = 0.05$, $A_\\psi = 0.05$, $A_n = 0.01$, $n_0 = 1.2$, $t_0 = 0.37$.\n\nProgram requirements:\n- Implement the above in a single program with no user input.\n- For each case, compute and record the three RMS norms in the order $\\|R_\\psi\\|_2$, $\\|R_\\omega\\|_2$, $\\|R_n\\|_2$.\n- Final Output Format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with nine floating-point numbers in scientific notation with exactly eight digits after the decimal point, ordered as\n$$\n[\\|R_\\psi\\|_2^\\text{A}, \\|R_\\omega\\|_2^\\text{A}, \\|R_n\\|_2^\\text{A}, \\|R_\\psi\\|_2^\\text{B}, \\|R_\\omega\\|_2^\\text{B}, \\|R_n\\|_2^\\text{B}, \\|R_\\psi\\|_2^\\text{C}, \\|R_\\omega\\|_2^\\text{C}, \\|R_n\\|_2^\\text{C}],\n$$\nfor Cases A, B, and C respectively.",
            "solution": "The problem requires the verification of a second-order finite difference spatial discretization for a reduced resistive magnetohydrodynamics (RRMHD) model using the method of manufactured solutions (MMS). This method involves prescribing an analytic solution for the system's fields and deriving the corresponding source terms that make these fields exact solutions to the continuous equations. The core of the verification test is to then compute the residuals that arise when the governing equations are assembled using discrete numerical operators. The magnitude of these residuals, quantified by their root-mean-square (RMS) norm, serves as a direct measure of the truncation error of the numerical scheme.\n\nThe governing RRMHD equations for the electrostatic stream function $\\phi(x,y,t)$, magnetic flux $\\psi(x,y,t)$, and number density $n(x,y,t)$ are:\n$$\n\\partial_t \\psi + [\\phi,\\psi] = \\eta \\nabla^2 \\psi + S_\\psi\n$$\n$$\n\\partial_t \\nabla^2 \\phi + [\\phi,\\nabla^2 \\phi] = [\\psi,\\nabla^2 \\psi] + \\nu \\nabla^4 \\phi + S_\\omega\n$$\n$$\n\\partial_t n + [\\phi,n] = D \\nabla^2 n + S_n\n$$\nwhere $[a,b] \\equiv \\partial_x a \\, \\partial_y b - \\partial_y a \\, \\partial_x b$ is the Poisson bracket.\n\nFirst, we derive the analytic source terms $S_\\psi$, $S_\\omega$, and $S_n$ by substituting the prescribed manufactured solutions into these equations. The manufactured fields are:\n$$\n\\phi(x,y,t) = A_\\phi \\sin(k_x x)\\sin(k_y y)\\cos(\\omega t)\n$$\n$$\n\\psi(x,y,t) = A_\\psi \\cos(k_x x)\\sin(k_y y)\\sin(\\omega t)\n$$\n$$\nn(x,y,t) = n_0 + A_n \\sin(k_x x)\\cos(k_y y)\\cos(\\omega t)\n$$\nTo compute the source terms, we need the exact derivatives of these fields. The Laplacian and biharmonic operators acting on these fields simplify due to their sinusoidal nature: $\\nabla^2 f = -(k_x^2+k_y^2)f = -K^2 f$ for the oscillating parts of $\\phi$ and $\\psi$, and $\\nabla^2 n = -K^2(n-n_0)$. Consequently, $\\nabla^4 \\phi = K^4 \\phi$.\n\nThe exact source terms are defined as:\n$S_\\psi \\equiv \\partial_t \\psi + [\\phi,\\psi] - \\eta \\nabla^2 \\psi$\n$S_\\omega \\equiv \\partial_t \\nabla^2 \\phi + [\\phi,\\nabla^2 \\phi] - [\\psi,\\nabla^2 \\psi] - \\nu \\nabla^4 \\phi$\n$S_n \\equiv \\partial_t n + [\\phi,n] - D \\nabla^2 n$\n\nLet's evaluate the components:\n$\\partial_t \\psi = \\omega A_\\psi \\cos(k_x x)\\sin(k_y y)\\cos(\\omega t)$\n$\\partial_t \\phi = -\\omega A_\\phi \\sin(k_x x)\\sin(k_y y)\\sin(\\omega t)$\n$\\partial_t n = -\\omega A_n \\sin(k_x x)\\cos(k_y y)\\sin(\\omega t)$\n\nThe Poisson brackets evaluate to:\n$[\\phi,\\psi] = k_x k_y A_\\phi A_\\psi \\cos(\\omega t)\\sin(\\omega t) \\sin(k_y y)\\cos(k_y y)$\n$[\\phi,n] = -k_x k_y A_\\phi A_n \\cos^2(\\omega t) \\sin(k_x x)\\cos(k_x x)$\nA key simplification in the vorticity equation is that for any smooth function $f$, its self-Poisson bracket is zero, $[f,f]=0$. Since $\\nabla^2\\phi = -K^2\\phi$ and $\\nabla^2\\psi = -K^2\\psi$, it follows that $[\\phi, \\nabla^2\\phi] = -K^2[\\phi,\\phi] = 0$ and $[\\psi, \\nabla^2\\psi] = -K^2[\\psi,\\psi]=0$.\n\nSubstituting these into the definitions gives the analytic source terms:\n$$\nS_\\psi(x,y,t) = \\omega A_\\psi \\cos(k_x x)\\sin(k_y y)\\cos(\\omega t) + k_x k_y A_\\phi A_\\psi \\cos(\\omega t)\\sin(\\omega t)\\sin(k_y y)\\cos(k_y y) + \\eta K^2 A_\\psi \\cos(k_x x)\\sin(k_y y)\\sin(\\omega t)\n$$\n$$\nS_\\omega(x,y,t) = \\partial_t(-K^2\\phi) - \\nu(K^4\\phi) = \\omega K^2 A_\\phi \\sin(k_x x)\\sin(k_y y)\\sin(\\omega t) - \\nu K^4 A_\\phi \\sin(k_x x)\\sin(k_y y)\\cos(\\omega t)\n$$\n$$\nS_n(x,y,t) = -\\omega A_n \\sin(k_x x)\\cos(k_y y)\\sin(\\omega t) - k_x k_y A_\\phi A_n \\cos^2(\\omega t)\\sin(k_x x)\\cos(k_x x) + D K^2 A_n \\sin(k_x x)\\cos(k_y y)\\cos(\\omega t)\n$$\n\nThe next step is to compute the discrete residuals. We use a uniform grid of size $N_x \\times N_y$ over the domain $[0,2\\pi) \\times [0,2\\pi)$, giving grid spacings $\\Delta x = 2\\pi/N_x$ and $\\Delta y = 2\\pi/N_y$. The spatial derivatives are approximated using second-order centered finite differences with periodic boundary conditions. For a grid function $f_{i,j}$:\n$$\n\\partial_x^\\Delta f_{i,j} = \\frac{f_{i+1,j} - f_{i-1,j}}{2\\Delta x}, \\quad \\partial_y^\\Delta f_{i,j} = \\frac{f_{i,j+1} - f_{i,j-1}}{2\\Delta y}\n$$\n$$\n\\nabla^2_\\Delta f_{i,j} = \\frac{f_{i+1,j} - 2f_{i,j} + f_{i-1,j}}{(\\Delta x)^2} + \\frac{f_{i,j+1} - 2f_{i,j} + f_{i,j-1}}{(\\Delta y)^2}\n$$\nThe discrete biharmonic operator is $\\nabla^4_\\Delta f \\equiv \\nabla^2_\\Delta(\\nabla^2_\\Delta f)$, and the discrete Poisson bracket is $[\\![a,b]\\!] \\equiv (\\partial_x^\\Delta a)(\\partial_y^\\Delta b) - (\\partial_y^\\Delta a)(\\partial_x^\\Delta b)$.\n\nAt a fixed time $t_0$, the discrete residuals are assembled by substituting these discrete operators into the governing equations while using the exact analytic time derivatives and the exact analytic source terms:\n$$\nR_\\psi \\equiv (\\partial_t \\psi)|_{t_0} + [\\![\\phi,\\psi]\\!] - \\eta \\nabla^2_{\\Delta} \\psi - S_\\psi|_{t_0}\n$$\n$$\nR_\\omega \\equiv (\\partial_t \\nabla^2 \\phi)|_{t_0} + [\\![\\phi,\\nabla^2_{\\Delta} \\phi]\\!] - [\\![\\psi,\\nabla^2_{\\Delta} \\psi]\\!] - \\nu \\nabla^4_{\\Delta} \\phi - S_\\omega|_{t_0}\n$$\n$$\nR_n \\equiv (\\partial_t n)|_{t_0} + [\\![\\phi,n]\\!] - D \\nabla^2_{\\Delta} n - S_n|_{t_0}\n$$\nThe resulting fields $R_\\psi$, $R_\\omega$, and $R_n$ are non-zero due to the truncation error of the finite difference approximations.\n\nFinally, we compute the discrete root-mean-square (RMS) norm for each residual field as a quantitative measure of the discretization error:\n$$\n\\|R\\|_2 \\equiv \\sqrt{\\frac{1}{N_x N_y} \\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1} R_{i,j}^2 }\n$$\nThe following code implements this procedure for the three specified test cases. It defines helper functions for the discrete operators, calculates the analytic and discrete terms for each residual, and computes the RMS norms.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the RRMHD code verification problem using the method of manufactured solutions.\n    \"\"\"\n\n    test_cases = [\n        # Case A\n        {'Nx': 32, 'Ny': 32, 'kx': 2, 'ky': 3, 'omega': 1.4, 'eta': 3e-3, 'nu': 2e-3,\n         'D': 1e-3, 'Aphi': 0.1, 'Apsi': 0.08, 'An': 0.02, 'n0': 1.0, 't0': 0.37},\n        # Case B\n        {'Nx': 64, 'Ny': 64, 'kx': 7, 'ky': 5, 'omega': 0.9, 'eta': 1e-4, 'nu': 1e-4,\n         'D': 5e-4, 'Aphi': 0.2, 'Apsi': 0.1, 'An': 0.05, 'n0': 0.8, 't0': 0.37},\n        # Case C\n        {'Nx': 16, 'Ny': 16, 'kx': 5, 'ky': 5, 'omega': 2.0, 'eta': 1e-2, 'nu': 2e-2,\n         'D': 5e-3, 'Aphi': 0.05, 'Apsi': 0.05, 'An': 0.01, 'n0': 1.2, 't0': 0.37}\n    ]\n\n    results = []\n    \n    # Helper functions for discrete operators with periodic boundaries\n    def grad_x(f, dx):\n        return (np.roll(f, -1, axis=1) - np.roll(f, 1, axis=1)) / (2 * dx)\n\n    def grad_y(f, dy):\n        return (np.roll(f, -1, axis=0) - np.roll(f, 1, axis=0)) / (2 * dy)\n\n    def laplacian(f, dx, dy):\n        lap_x = (np.roll(f, -1, axis=1) - 2 * f + np.roll(f, 1, axis=1)) / dx**2\n        lap_y = (np.roll(f, -1, axis=0) - 2 * f + np.roll(f, 1, axis=0)) / dy**2\n        return lap_x + lap_y\n    \n    def biharmonic(f, dx, dy):\n        return laplacian(laplacian(f, dx, dy), dx, dy)\n\n    def poisson_bracket(a, b, dx, dy):\n        return grad_x(a, dx) * grad_y(b, dy) - grad_y(a, dx) * grad_x(b, dy)\n\n    for params in test_cases:\n        # Unpack parameters\n        Nx, Ny = params['Nx'], params['Ny']\n        kx, ky = params['kx'], params['ky']\n        omega, eta, nu, D = params['omega'], params['eta'], params['nu'], params['D']\n        Aphi, Apsi, An = params['Aphi'], params['Apsi'], params['An']\n        n0, t0 = params['n0'], params['t0']\n\n        # Grid setup\n        dx = 2 * np.pi / Nx\n        dy = 2 * np.pi / Ny\n        x = np.linspace(0, 2 * np.pi - dx, Nx)\n        y = np.linspace(0, 2 * np.pi - dy, Ny)\n        Y, X = np.meshgrid(y, x) # Note: meshgrid order matches numpy array indexing\n        Y=Y.T # transpose to get (i,j) -> (x_i, y_j)\n        X=X.T\n\n        K2 = kx**2 + ky**2\n        \n        # Time-dependent factors\n        cos_wt = np.cos(omega * t0)\n        sin_wt = np.sin(omega * t0)\n\n        # Manufactured fields on grid at t=t0\n        phi = Aphi * np.sin(kx * X) * np.sin(ky * Y) * cos_wt\n        psi = Apsi * np.cos(kx * X) * np.sin(ky * Y) * sin_wt\n        n = n0 + An * np.sin(kx * X) * np.cos(ky * Y) * cos_wt\n\n        # Analytic source terms on grid at t=t0\n        # S_psi = dt_psi + [phi,psi] - eta*lap_psi\n        dt_psi_exact = omega * Apsi * np.cos(kx * X) * np.sin(ky * Y) * cos_wt\n        poisson_phi_psi_exact = (kx * ky * Aphi * Apsi * cos_wt * sin_wt * \n                                 np.sin(ky * Y) * np.cos(ky * Y))\n        lap_psi_exact = -K2 * psi\n        S_psi = dt_psi_exact + poisson_phi_psi_exact - eta * lap_psi_exact\n\n        # S_omega = dt_lap_phi + [phi,lap_phi] - [psi,lap_psi] - nu*biharm_phi\n        lap_phi_exact = -K2 * phi\n        dt_lap_phi_exact = -K2 * (-omega * Aphi * np.sin(kx * X) * np.sin(ky * Y) * sin_wt)\n        # Poisson brackets with Laplacians are zero for these specific fields\n        biharm_phi_exact = K2**2 * phi\n        S_omega = dt_lap_phi_exact - nu * biharm_phi_exact\n\n        # S_n = dt_n + [phi,n] - D*lap_n\n        dt_n_exact = -omega * An * np.sin(kx * X) * np.cos(ky * Y) * sin_wt\n        poisson_phi_n_exact = (-kx * ky * Aphi * An * cos_wt**2 * \n                               np.sin(kx * X) * np.cos(kx * X))\n        lap_n_exact = -K2 * (n - n0)\n        S_n = dt_n_exact + poisson_phi_n_exact - D * lap_n_exact\n\n        # Assemble discrete residuals\n        # R_psi\n        R_psi = (dt_psi_exact + poisson_bracket(phi, psi, dx, dy) \n                 - eta * laplacian(psi, dx, dy) - S_psi)\n        \n        # R_omega\n        lap_phi_discrete = laplacian(phi, dx, dy)\n        lap_psi_discrete = laplacian(psi, dx, dy)\n        R_omega = (dt_lap_phi_exact \n                   + poisson_bracket(phi, lap_phi_discrete, dx, dy) \n                   - poisson_bracket(psi, lap_psi_discrete, dx, dy)\n                   - nu * biharmonic(phi, dx, dy) - S_omega)\n\n        # R_n\n        R_n = (dt_n_exact + poisson_bracket(phi, n, dx, dy)\n               - D * laplacian(n, dx, dy) - S_n)\n        \n        # Compute RMS norms\n        norm_R_psi = np.sqrt(np.mean(R_psi**2))\n        norm_R_omega = np.sqrt(np.mean(R_omega**2))\n        norm_R_n = np.sqrt(np.mean(R_n**2))\n\n        results.extend([norm_R_psi, norm_R_omega, norm_R_n])\n\n    # Format output\n    results_str = [\"{:.8e}\".format(r) for r in results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        }
    ]
}