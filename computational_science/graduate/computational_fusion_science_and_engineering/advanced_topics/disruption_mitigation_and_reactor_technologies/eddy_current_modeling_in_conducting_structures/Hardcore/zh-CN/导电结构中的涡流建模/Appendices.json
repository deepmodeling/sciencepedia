{
    "hands_on_practices": [
        {
            "introduction": "现实世界中的大多数涡流问题由于几何和材料的复杂性而缺乏解析解，因此必须依赖数值方法。本练习  聚焦于瞬态动力学仿真的时间积分方面，它采用了一个简化的电路模型来模拟等离子体破裂期间的涡流行为。通过亲手实现和比较一阶（后向欧拉）和二阶（Crank-Nicolson）时间积分格式，您将获得关于数值精度和收敛阶数的实践经验，这些都是构建可靠仿真工具的核心概念。",
            "id": "3969857",
            "problem": "聚变装置中的薄导电环形壁可近似为一个具有自感 $L$ 和电阻 $R$ 的单匝线圈。在类破裂瞬态过程中，等离子体电流可建模为 $I_{p}(t) = I_{0}\\,\\exp(-t/\\tau_{p})$（$t \\ge 0$），其中 $I_{0}$ 是初始等离子体电流，$\\tau_{p}$ 是等离子体电流衰减时间。壁线圈通过互感 $M$ 与等离子体磁耦合，因此链接壁的外部磁通量为 $\\Phi_{\\text{ext}}(t) = M I_{p}(t)$。从基本麦克斯韦-法拉第定律 $\\oint \\mathbf{E}\\cdot d\\mathbf{l} = -\\,d\\Phi/dt$、集总电阻器的欧姆定律 $v_{R} = R i$ 和电感关系 $v_{L} = L\\,di/dt$ 出发，壁电流 $i(t)$ 的回路方程为\n$$\nL\\,\\frac{di}{dt} + R\\,i(t) \\;=\\; -\\,\\frac{d\\Phi_{\\text{ext}}}{dt} \\;=\\; -\\,M\\,\\frac{dI_{p}}{dt}.\n$$\n对于指数形式的等离子体电流，定义 $\\alpha = R/L$ 和 $\\gamma = M I_{0}/(L \\tau_{p})$。那么，初值问题可以写为\n$$\n\\frac{di}{dt} \\;=\\; -\\,\\alpha\\,i(t) \\;+\\; \\gamma\\,e^{-t/\\tau_{p}}, \\qquad i(0)=0.\n$$\n$i(t)$ 的精确解为\n$$\ni(t) \\;=\\; \\frac{M I_{0}}{L}\\,\\frac{1/\\tau_{p}}{\\alpha - 1/\\tau_{p}}\\left(e^{-t/\\tau_{p}} - e^{-\\alpha t}\\right),\n$$\n该解在 $\\alpha \\neq 1/\\tau_{p}$ 时有效。峰值电流大小（对于 $t\\ge 0$）出现的时间为\n$$\nt_{\\text{peak}} \\;=\\; \\frac{1}{\\alpha - 1/\\tau_{p}}\\,\\ln\\!\\big(\\alpha\\,\\tau_{p}\\big),\n$$\n相应的精确峰值壁电流大小为 $|i(t_{\\text{peak}})|$。\n\n您将使用相同的步长时间 $\\Delta t$，通过两种时间积分格式对同一个常微分方程进行数值积分：\n- 后向欧拉法 (BE)：由 $i^{n+1} = i^{n} + \\Delta t\\, f(t^{n+1}, i^{n+1})$ 定义的单步隐式格式，其中 $f(t,i) = -\\alpha i + \\gamma e^{-t/\\tau_{p}}$。\n- Crank–Nicolson法 (CN)：由 $i^{n+1} = i^{n} + \\frac{\\Delta t}{2}\\left[f(t^{n}, i^{n}) + f(t^{n+1}, i^{n+1})\\right]$ 定义的梯形隐式格式。\n\n对于这两种格式，均使用 $t^{0}=0$ 时的 $i^{0}=0$，以固定的 $\\Delta t$ 推进到 $T_{\\text{end}} = 10\\,\\max(\\tau_{p}, L/R)$，并计算离散峰值大小 $\\max_{n} |i^{n}|$。将一种方法的相对峰值电流误差定义为\n$$\n\\varepsilon \\;=\\; \\frac{\\left|\\max_{n}|i^{n}| - |i(t_{\\text{peak}})|\\right|}{|i(t_{\\text{peak}})|}.\n$$\n您的任务是，对于下方的每个测试用例，量化当 Crank–Nicolson (CN) 和后向欧拉法 (BE) 使用相同时间步长时，它们的误差比\n$$\n\\rho \\;=\\; \\frac{\\varepsilon_{\\text{CN}}}{\\varepsilon_{\\text{BE}}},\n$$\n。所有物理参数必须采用国际单位制 (SI)：$L$ 单位为亨利，$R$ 单位为欧姆，$M$ 单位为亨利，$I_{0}$ 单位为安培，$\\tau_{p}$ 单位为秒，$\\Delta t$ 单位为秒。输出 $\\rho$ 是无量纲的。\n\n实现一个程序，为每个测试用例计算 $\\rho$ 至至少 $6$ 位正确的小数，并按测试用例的顺序将所有结果以逗号分隔列表的形式打印在单行中，并用方括号括起来。\n\n测试套件（每个元组为 $(L,\\;R,\\;M,\\;I_{0},\\;\\tau_{p},\\;\\Delta t)$）：\n- 案例 A（平衡时间尺度，中等步长）：($1.0\\times 10^{-3}$, $2.0\\times 10^{-1}$, $5.0\\times 10^{-6}$, $1.0\\times 10^{6}$, $1.0\\times 10^{-2}$, $2.0\\times 10^{-3}$)。\n- 案例 B（等离子体快速衰减，粗步长）：($1.0\\times 10^{-3}$, $2.0\\times 10^{-1}$, $5.0\\times 10^{-6}$, $1.0\\times 10^{6}$, $5.0\\times 10^{-4}$, $5.0\\times 10^{-4}$)。\n- 案例 C（壁响应慢，等离子体中速，中等步长）：($2.0\\times 10^{-3}$, $5.0\\times 10^{-2}$, $1.0\\times 10^{-5}$, $5.0\\times 10^{5}$, $2.0\\times 10^{-2}$, $5.0\\times 10^{-3}$)。\n- 案例 D（壁响应快，等离子体中快，粗步长）：($5.0\\times 10^{-4}$, $5.0\\times 10^{-1}$, $2.0\\times 10^{-6}$, $2.0\\times 10^{6}$, $2.0\\times 10^{-3}$, $1.0\\times 10^{-3}$)。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 [案例 A, 案例 B, 案例 C, 案例 D]，例如：\"[0.12345678,0.23456789,0.34567890,0.45678901]\"。",
            "solution": "问题陈述已经过仔细审查，并被确定为 **有效**。它基于电磁学和电路理论的原理，具有科学依据，提出了一个从聚变工程中标准物理模型推导出的良态初值问题。所有参数、方程和目标都得到了清晰且一致的定义，从而能够得到唯一且可验证的解。\n\n目标是计算 Crank–Nicolson (CN) 和后向欧拉 (BE) 两种数值格式，在求解一个描述涡流动力学的给定常微分方程 (ODE) 时，产生的相对误差之比 $\\rho = \\varepsilon_{\\text{CN}}/\\varepsilon_{\\text{BE}}$。每种格式的相对误差 $\\varepsilon$ 是相对于精确解析解的峰值大小定义的。\n\n控制常微分方程为：\n$$\n\\frac{di}{dt} = f(t, i) = -\\alpha i(t) + \\gamma e^{-t/\\tau_p}, \\quad i(0) = 0\n$$\n其中 $\\alpha = R/L$ 且 $\\gamma = M I_0 / (L \\tau_p)$。\n\n首先，我们必须从 BE 和 CN 格式的隐式定义中推导出 $i^{n+1}$ 的显式单步更新公式。设 $t^n = n\\Delta t$。\n\n**后向欧拉 (BE) 格式**\nBE 格式定义为：\n$$\ni^{n+1} = i^n + \\Delta t f(t^{n+1}, i^{n+1})\n$$\n代入函数 $f(t,i)$：\n$$\ni^{n+1} = i^n + \\Delta t \\left( -\\alpha i^{n+1} + \\gamma e^{-t^{n+1}/\\tau_p} \\right)\n$$\n由于该常微分方程是线性的，我们可以通过代数方法解出 $i^{n+1}$：\n$$\ni^{n+1} + \\alpha \\Delta t i^{n+1} = i^n + \\gamma \\Delta t e^{-t^{n+1}/\\tau_p}\n$$\n$$\ni^{n+1}(1 + \\alpha \\Delta t) = i^n + \\gamma \\Delta t e^{-t^{n+1}/\\tau_p}\n$$\n这就得到了 BE 格式的显式更新规则：\n$$\ni_{\\text{BE}}^{n+1} = \\frac{i^n + \\gamma \\Delta t \\exp(-t^{n+1}/\\tau_p)}{1 + \\alpha \\Delta t}\n$$\n\n**Crank–Nicolson (CN) 格式**\nCN 格式定义为：\n$$\ni^{n+1} = i^n + \\frac{\\Delta t}{2} \\left[ f(t^n, i^n) + f(t^{n+1}, i^{n+1}) \\right]\n$$\n代入函数 $f(t,i)$：\n$$\ni^{n+1} = i^n + \\frac{\\Delta t}{2} \\left[ (-\\alpha i^n + \\gamma e^{-t^n/\\tau_p}) + (-\\alpha i^{n+1} + \\gamma e^{-t^{n+1}/\\tau_p}) \\right]\n$$\n同样，我们重新整理以解出 $i^{n+1}$：\n$$\ni^{n+1} = i^n - \\frac{\\alpha \\Delta t}{2} i^n - \\frac{\\alpha \\Delta t}{2} i^{n+1} + \\frac{\\gamma \\Delta t}{2} \\left( e^{-t^n/\\tau_p} + e^{-t^{n+1}/\\tau_p} \\right)\n$$\n$$\ni^{n+1} \\left( 1 + \\frac{\\alpha \\Delta t}{2} \\right) = i^n \\left( 1 - \\frac{\\alpha \\Delta t}{2} \\right) + \\frac{\\gamma \\Delta t}{2} \\left( e^{-t^n/\\tau_p} + e^{-t^{n+1}/\\tau_p} \\right)\n$$\n这就得到了 CN 格式的显式更新规则：\n$$\ni_{\\text{CN}}^{n+1} = \\frac{i^n \\left( 1 - \\frac{\\alpha \\Delta t}{2} \\right) + \\frac{\\gamma \\Delta t}{2} \\left( \\exp(-t^n/\\tau_p) + \\exp(-t^{n+1}/\\tau_p) \\right)}{1 + \\frac{\\alpha \\Delta t}{2}}\n$$\n\n**计算算法**\n对于由元组 $(L, R, M, I_0, \\tau_p, \\Delta t)$ 指定的每个测试用例，步骤如下：\n\n1.  **参数计算**：计算派生常数：\n    -   壁时间常数：$\\tau_w = L/R$。\n    -   归一化衰减率：$\\alpha = 1/\\tau_w = R/L$。\n    -   归一化驱动振幅：$\\gamma = M I_0 / (L \\tau_p)$。\n    -   模拟结束时间：$T_{\\text{end}} = 10 \\max(\\tau_p, \\tau_w)$。\n\n2.  **精确峰值电流**：计算精确峰值壁电流的大小 $|i(t_{\\text{peak}})|$。\n    -   峰值电流时间：$t_{\\text{peak}} = \\frac{1}{\\alpha - 1/\\tau_p} \\ln(\\alpha \\tau_p)$。\n    -   精确解为 $i(t) = \\frac{M I_0}{L} \\frac{1/\\tau_p}{\\alpha - 1/\\tau_p} (e^{-t/\\tau_p} - e^{-\\alpha t})$。\n    -   精确峰值电流大小为 $i_{\\text{peak, exact}} = |i(t_{\\text{peak}})|$。对于给定参数，$i(t) \\ge 0$ (当 $t \\ge 0$ 时)，因此绝对值是多余的。\n\n3.  **数值积分**：\n    -   确定时间步数，$N = \\lfloor T_{\\text{end}} / \\Delta t \\rfloor$。\n    -   创建时间网格 $t^n = n \\Delta t$，$n = 0, 1, \\dots, N$。\n    -   初始化大小为 $N+1$ 的电流数组 $i_{\\text{BE}}$ 和 $i_{\\text{CN}}$，初始条件为 $i^0 = 0$。\n    -   从 $n = 0$ 迭代到 $N-1$，使用各自的更新公式计算 $i_{\\text{BE}}^{n+1}$ 和 $i_{\\text{CN}}^{n+1}$ 来填充数组。\n\n4.  **误差和比率计算**：\n    -   找出每种格式的离散峰值电流大小：$i_{\\text{peak, BE}} = \\max_{n} |i_{\\text{BE}}^n|$ 和 $i_{\\text{peak, CN}} = \\max_{n} |i_{\\text{CN}}^n|$。\n    -   计算相对误差：\n    $$ \\varepsilon_{\\text{BE}} = \\frac{|i_{\\text{peak, BE}} - i_{\\text{peak, exact}}|}{|i_{\\text{peak, exact}}|} $$\n    $$ \\varepsilon_{\\text{CN}} = \\frac{|i_{\\text{peak, CN}} - i_{\\text{peak, exact}}|}{|i_{\\text{peak, exact}}|} $$\n    -   最后，计算所需比率：\n    $$ \\rho = \\frac{\\varepsilon_{\\text{CN}}}{\\varepsilon_{\\text{BE}}} $$\n\n将对四个测试用例中的每一个实施此程序。已知的理论收敛阶对于 BE 是一阶 $O(\\Delta t)$，对于 CN 是二阶 $O(\\Delta t^2)$。因此，误差比 $\\rho$ 预计将远小于 $1$，并且应大致与 $\\Delta t$ 成比例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_error_ratio(L, R, M, I0, tau_p, dt):\n    \"\"\"\n    Computes the ratio of relative peak-current errors between the\n    Crank-Nicolson and Backward Euler schemes for a single test case.\n\n    Args:\n        L (float): Self-inductance (H)\n        R (float): Resistance (Ohm)\n        M (float): Mutual inductance (H)\n        I0 (float): Initial plasma current (A)\n        tau_p (float): Plasma current decay time (s)\n        dt (float): Time step (s)\n\n    Returns:\n        float: The ratio of errors, rho = eps_CN / eps_BE.\n    \"\"\"\n\n    # 1. Parameter Calculation\n    alpha = R / L\n    tau_w = L / R\n    gamma = M * I0 / (L * tau_p)\n    T_end = 10.0 * max(tau_p, tau_w)\n\n    # 2. Exact Peak Current Calculation\n    if np.isclose(alpha * tau_p, 1.0):\n        # This case is excluded by the problem statement validation.\n        raise ValueError(\"The special case alpha * tau_p = 1 is not handled.\")\n\n    t_peak = (1.0 / (alpha - 1.0 / tau_p)) * np.log(alpha * tau_p)\n    \n    prefactor = (M * I0 / L) * (1.0 / tau_p) / (alpha - 1.0 / tau_p)\n    \n    i_peak_exact = prefactor * (np.exp(-t_peak / tau_p) - np.exp(-alpha * t_peak))\n\n    # 3. Numerical Integration\n    num_steps = int(T_end / dt)\n    t = np.linspace(0, num_steps * dt, num_steps + 1)\n    \n    i_be = np.zeros(num_steps + 1)\n    i_cn = np.zeros(num_steps + 1)\n    i_be[0] = 0.0\n    i_cn[0] = 0.0\n\n    # Pre-compute constants for the loop\n    # Backward Euler\n    be_denom = 1.0 + alpha * dt\n    be_num_term2_factor = gamma * dt\n    # Crank-Nicolson\n    cn_denom = 1.0 + alpha * dt / 2.0\n    cn_num_term1_factor = 1.0 - alpha * dt / 2.0\n    cn_num_term2_factor = gamma * dt / 2.0\n\n    # Time-stepping loop\n    for n in range(num_steps):\n        t_n = t[n]\n        t_n1 = t[n+1]\n        \n        # Forcing term evaluations\n        exp_n = np.exp(-t_n / tau_p)\n        exp_n1 = np.exp(-t_n1 / tau_p)\n\n        # Backward Euler update\n        i_be[n+1] = (i_be[n] + be_num_term2_factor * exp_n1) / be_denom\n\n        # Crank-Nicolson update\n        cn_num_term1 = i_cn[n] * cn_num_term1_factor\n        cn_num_term2 = cn_num_term2_factor * (exp_n + exp_n1)\n        i_cn[n+1] = (cn_num_term1 + cn_num_term2) / cn_denom\n        \n    # 4. Error and Ratio Calculation\n    i_peak_be = np.max(np.abs(i_be))\n    i_peak_cn = np.max(np.abs(i_cn))\n\n    eps_be = np.abs(i_peak_be - i_peak_exact) / np.abs(i_peak_exact)\n    eps_cn = np.abs(i_peak_cn - i_peak_exact) / np.abs(i_peak_exact)\n\n    if np.isclose(eps_be, 0.0):\n        if np.isclose(eps_cn, 0.0):\n            return 1.0  # Or 0.0, but this indicates both are exact\n        else:\n            return np.inf\n\n    rho = eps_cn / eps_be\n    return rho\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, R, M, I0, tau_p, dt)\n        (1.0e-3, 2.0e-1, 5.0e-6, 1.0e6, 1.0e-2, 2.0e-3), # Case A\n        (1.0e-3, 2.0e-1, 5.0e-6, 1.0e6, 5.0e-4, 5.0e-4), # Case B\n        (2.0e-3, 5.0e-2, 1.0e-5, 5.0e5, 2.0e-2, 5.0e-3), # Case C\n        (5.0e-4, 5.0e-1, 2.0e-6, 2.0e6, 2.0e-3, 1.0e-3), # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_error_ratio(*case)\n        results.append(f\"{result:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了时间积分，涡流模型计算的准确性在很大程度上还取决于空间离散化的方式。本实践  深入探讨了一个更高级的主题：几何奇异点（如尖锐的凹角）对数值解收敛性的影响。通过对具有已知解析解的楔形几何进行 $h$-refinement（网格加密）研究，您将研究解的正则性如何限制标准数值方法的性能。在精确模拟聚变装置中复杂部件时，这是一个至关重要的考虑因素。",
            "id": "3969843",
            "problem": "考虑一个二维导电楔形体，在极坐标 $(r,\\theta)$ 中，其开口角为 $\\alpha$，其中 $r \\in [0,R]$ 且 $\\theta \\in [0,\\alpha]$。假设角频率为 $\\omega$ 的谐波激励，磁导率 $\\mu$ 和电导率 $\\sigma$ 为常数，并采用横电 (TE) 极化。在此极化下，平面外磁矢量势 $A_z(r,\\theta)$（下文记为 $A$）在磁准静态近似下决定了涡流响应。从麦克斯韦方程组和欧姆定律出发，可以得到导电区域中复值谐波振幅 $A$ 的标量扩散方程。当材料属性为常数且位移电流可忽略时，控制方程简化为以下形式的齐次修正亥姆霍兹方程\n$$\n\\nabla^2 A - k^2 A = 0,\n$$\n其中 $k^2 = i\\,\\omega\\,\\mu\\,\\sigma$，狄利克雷边界条件为 $A(r,0)=0$，$A(r,\\alpha)=0$。在外边界 $r=R$ 上，给定与可分离解一致的狄利克雷数据。\n\n利用楔形体中已知的可分离解族，其角向因子为 $\\sin(\\lambda \\theta)$（其中 $\\lambda = \\pi/\\alpha$），径向因子为第一类修正贝塞尔函数 $I_\\lambda$，定义精确解\n$$\nA_{\\text{exact}}(r,\\theta) = I_{\\lambda}\\!\\big(k\\,r\\big)\\,\\sin(\\lambda\\,\\theta),\n$$\n该解在 $\\lambda > 0$ 时于 $r=0$ 处是正则的，而在 $\\alpha > \\pi$（等价于 $\\lambda  1$）时其梯度在角点处表现出奇性。通过 TE 关系定义派生的电流密度幅值 $J_z$（下文记为 $J$）\n$$\nJ = -i\\,\\omega\\,\\sigma\\,A,\n$$\n此关系在库仑规范下成立，且标量势可忽略。\n\n通过在 $(r,\\theta)$ 上的均匀张量积网格上使用分段双线性插值逼近 $A_{\\text{exact}}$，来进行一次 $h$-细化研究，其中 $r$ 方向有 $N_r$ 个区间，$\\theta$ 方向有 $N_\\theta$ 个区间。对于每个网格，定义特征网格尺寸\n$$\nh = \\max\\left(\\Delta r,\\, R\\,\\Delta\\theta\\right) = \\max\\left(\\frac{R}{N_r},\\, \\frac{R\\,\\alpha}{N_\\theta}\\right).\n$$\n计算 $A$ 和 $J$ 在楔形域上关于极坐标面积测度的插值误差的 $L^2$ 范数：\n$$\n\\|e_A\\|_{L^2(\\Omega)} = \\left(\\int_{0}^{R}\\int_{0}^{\\alpha} \\left|A_{\\text{exact}}(r,\\theta) - A_{\\text{interp}}(r,\\theta)\\right|^2\\, r\\, d\\theta\\, dr\\right)^{1/2},\n$$\n$$\n\\|e_J\\|_{L^2(\\Omega)} = \\left(\\int_{0}^{R}\\int_{0}^{\\alpha} \\left|J_{\\text{exact}}(r,\\theta) - J_{\\text{interp}}(r,\\theta)\\right|^2\\, r\\, d\\theta\\, dr\\right)^{1/2}.\n$$\n使用至少三个连续的细化层级，通过 $\\log\\|e\\|$ 对 $\\log h$ 的斜率来估计收敛率 $p_A$ 和 $p_J$，其中 $\\|e\\|$ 分别是 $A$ 和 $J$ 的误差的 $L^2$ 范数。在每个单元上使用每个方向三点的乘积高斯-勒让德求积来近似计算积分。\n\n采用以下物理上合理的参数：\n- $R = 1$ (米),\n- $\\mu = 4\\pi\\times 10^{-7}$ (亨利每米),\n- $\\sigma = 10^{6}$ (西门子每米),\n- $\\omega = 10^{3}$ (弧度每秒)。\n\n使用三个细化级别 $N \\in \\{16,32,64\\}$，并设 $N_r = N_\\theta = N$。\n\n提供一个包含三个楔形角的测试套件，以探究不同的正则性情况：\n- 测试 1：$\\alpha = \\frac{\\pi}{2}$ (光滑角，无凹角行为),\n- 测试 2：$\\alpha = \\frac{3\\pi}{2}$ (凹角，$\\lambda = \\frac{2}{3}$),\n- 测试 3：$\\alpha = 1.9\\pi$ (更严重的凹角)。\n\n对于每个测试用例，通过对三个细化级别的 $\\log\\|e\\|$ 对 $\\log h$ 进行线性回归来估计 $p_A$ 和 $p_J$。由于 $p_A$ 和 $p_J$ 是无量纲指数，最终输出结果应表示为不带单位的十进制浮点数。\n\n您的程序应生成一行输出，其中包含三个测试的六个估计率，按顺序排列，格式为一个逗号分隔的列表，并用方括号括起来，具体如下\n$$\n\\left[p_A^{(1)},\\,p_J^{(1)},\\,p_A^{(2)},\\,p_J^{(2)},\\,p_A^{(3)},\\,p_J^{(3)}\\right].\n$$",
            "solution": "用户提供了一个在计算电磁学领域内科学有效且适定的问题。任务是执行一次数值 h-细化研究，以估计在楔形域中，针对磁矢量势扩散方程的一个特定解析解，分段双线性插值格式的收敛率。\n\n该问题基于麦克斯韦方程组的磁准静态 (MQS) 近似，该近似适用于良导体中位移电流可忽略的低频电磁现象。对于角频率为 $\\omega$ 的时谐激励和横电 (TE) 极化，在磁导率为 $\\mu$、电导率为 $\\sigma$ 的均匀介质中，磁矢量势的平面外分量 $A_z$ (记为 $A$) 由修正的亥姆霍兹方程控制：\n$$\n\\nabla^2 A - k^2 A = 0\n$$\n其中 $k^2 = i\\,\\omega\\,\\mu\\,\\sigma$ 且 $i = \\sqrt{-1}$。复常数 $k$ 的大小与电磁趋肤深度 $\\delta = \\sqrt{2/(\\omega\\mu\\sigma)}$ 相关。\n\n域是一个二维楔形，在极坐标 $(r,\\theta)$ 中定义为 $r \\in [0,R]$ 和 $\\theta \\in [0,\\alpha]$。问题指定了齐次狄利克雷边界条件，$A(r,0)=0$ 和 $A(r,\\alpha)=0$。求解此类偏微分方程的标准技术是分离变量法，$A(r,\\theta) = f(r)g(\\theta)$。$\\theta$ 上的边界条件导致角向解的形式为 $g(\\theta) = \\sin(\\lambda\\theta)$，其中 $\\lambda = n\\pi/\\alpha$。问题考虑基模，即 $n=1$，因此 $\\lambda = \\pi/\\alpha$。径向函数 $f(r)$ 则必须满足一个修正贝塞尔方程。在原点 $r=0$ 处保持正则的解是阶数为 $\\lambda$ 的第一类修正贝塞尔函数，记为 $I_\\lambda$。这导出了精确解析解：\n$$\nA_{\\text{exact}}(r,\\theta) = I_{\\lambda}\\!\\big(k\\,r\\big)\\,\\sin(\\lambda\\,\\theta)\n$$\n该解的正则性由指数 $\\lambda$ 决定。在原点附近 ($r \\to 0$)，其行为是 $A_{\\text{exact}}(r,\\theta) \\sim r^\\lambda \\sin(\\lambda\\theta)$。解的梯度 $\\nabla A_{\\text{exact}}$ 的行为类似于 $r^{\\lambda-1}$。如果楔形角 $\\alpha > \\pi$，则 $\\lambda  1$，梯度在角点 $r=0$ 处变得奇异。这是非凸域上椭圆偏微分方程的一个众所周知的现象。随着 $\\alpha$ 增加到 $2\\pi$（且 $\\lambda$ 减小到 $1/2$），奇性的严重程度增加。三个测试用例 $\\alpha=\\pi/2$、$\\alpha=3\\pi/2$ 和 $\\alpha=1.9\\pi$ 分别对应于 $\\lambda=2$（光滑解）、$\\lambda=2/3$（奇异梯度）和 $\\lambda=1/1.9 \\approx 0.526$（更奇异的梯度）。\n\n电流密度 $J_z$（记为 $J$）由 $J = -i\\,\\omega\\,\\sigma\\,A$ 给出。由于 $J$ 是 $A$ 的一个常数倍，它具有相同的空间正则性，并且其插值误差预期会以相同的速率收敛。因此，理论上我们预期 $p_A = p_J$。\n\n任务的核心是执行一次数值收敛性研究。精确解 $A_{\\text{exact}}$ 在 $(r,\\theta)$ 平面上的一个均匀张量积网格上被分段双线性插值 $A_{\\text{interp}}$ 所近似。这种插值的收敛性通过误差的 $L^2$ 范数 $\\|e_A\\|_{L^2(\\Omega)}$ 和 $\\|e_J\\|_{L^2(\\Omega)}$ 来衡量，其中积分是在楔形域 $\\Omega$ 上执行，面积元为 $r\\,dr\\,d\\theta$。根据插值理论，对于一个索博列夫正则性为 $u \\in H^s(\\Omega)$ 的函数 $u$，其分段双线性插值 $I_h u$ 的 $L^2$ 误差满足 $\\|u - I_h u\\|_{L^2(\\Omega)} \\propto h^{\\min(2, s)}$，其中 $h$ 是网格尺寸。函数 $A_{\\text{exact}} \\sim r^\\lambda$ 的正则性 $s$ 受角点奇性的限制，可以证明 $s  \\lambda+1$。因此，预期的收敛率是 $p = \\min(2, \\lambda+1)$。\n- 测试 1 ($\\alpha=\\pi/2, \\lambda=2$)：预期收敛率 $p = \\min(2, 2+1) = 2$。\n- 测试 2 ($\\alpha=3\\pi/2, \\lambda=2/3$)：预期收敛率 $p = \\min(2, 2/3+1) = 5/3 \\approx 1.667$。\n- 测试 3 ($\\alpha=1.9\\pi, \\lambda=1/1.9 \\approx 0.526$)：预期收敛率 $p = \\min(2, 1/1.9+1) \\approx 1.526$。\n\n估计这些收敛率的算法如下：\n1. 对于每个测试用例 $\\alpha \\in \\{\\pi/2, 3\\pi/2, 1.9\\pi\\}$：\n2. 对于每个细化级别 $N \\in \\{16, 32, 64\\}$，设置 $N_r=N_\\theta=N$ 并定义网格。\n3. 计算特征网格尺寸 $h = \\max(R/N_r, R\\alpha/N_\\theta)$。\n4. 将域细分为 $N_r \\times N_\\theta$ 个单元。对于每个单元 $[r_i, r_{i+1}] \\times [\\theta_j, \\theta_{j+1}]$：\n   a. 基于四个角点处的 $A_{\\text{exact}}$ 值定义双线性插值 $A_{\\text{interp}}$。\n   b. 使用 $3 \\times 3$ 的乘积高斯-勒让德求积法则，在该单元上数值计算误差平方 $|A_{\\text{exact}} - A_{\\text{interp}}|^2$ 的积分，并正确地包含极坐标的雅可比因子 $r$。\n5. 将所有单元的贡献相加，得到 $A$ 的总 $L^2$ 误差的平方，然后取平方根得到 $\\|e_A\\|_{L^2}$。$J$ 的误差则为 $\\|e_J\\|_{L^2} = \\omega\\sigma\\|e_A\\|_{L^2}$。\n6. 收集三个细化级别的配对 $(\\log h, \\log \\|e_A\\|)$ 和 $(\\log h, \\log \\|e_J\\|)$。\n7. 对这些对数-对数数据点进行线性回归（最小二乘拟合）。所得直线的斜率即为估计的收敛率 $p_A$ 或 $p_J$。\n8. 收集六个收敛率并按指定格式输出。\n\n此过程严谨地实现了指定的数值实验，以验证几何奇点对标准插值方法收敛性的影响。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import iv\nfrom numpy.polynomial.legendre import leggauss\n\ndef solve():\n    \"\"\"\n    Performs an h-refinement study for bilinear interpolation error of\n    the magnetic vector potential in a conducting wedge.\n    \"\"\"\n\n    # Define physical parameters\n    R = 1.0  # meters\n    mu = 4.0 * np.pi * 1e-7  # Henries per meter\n    sigma = 1.0e6  # Siemens per meter\n    omega = 1.0e3  # radians per second\n\n    # Derived physical constant k\n    k_sq = 1j * omega * mu * sigma\n    k = np.sqrt(k_sq)\n\n    # Gauss-Legendre quadrature setup (3 points on [0,1])\n    n_gauss = 3\n    # Get standard points and weights on [-1, 1]\n    gp_11, gw_11 = leggauss(n_gauss)\n    # Map to [0, 1] for local cell coordinates\n    gp_01 = 0.5 * (gp_11 + 1.0)\n    gw_01 = 0.5 * gw_11\n\n    # Define test cases and refinement levels\n    test_cases = [np.pi / 2.0, 3.0 * np.pi / 2.0, 1.9 * np.pi]\n    refinement_levels = [16, 32, 64]\n\n    all_rates = []\n\n    for alpha in test_cases:\n        # Calculate lambda for the current wedge angle\n        lam = np.pi / alpha\n\n        # Define the exact solution A(r, theta)\n        def A_exact(r, theta):\n            # The complex argument to iv is handled by scipy\n            # For r=0, A is 0 because iv(lam, 0) = 0 for lam > 0, which is true here.\n            # Scipy's iv handles scalar and array inputs correctly.\n            return iv(lam, k * r) * np.sin(lam * theta)\n\n        log_h_vals = []\n        log_err_A_vals = []\n        log_err_J_vals = []\n\n        for N in refinement_levels:\n            Nr, Ntheta = N, N\n            dr = R / Nr\n            dtheta = alpha / Ntheta\n            h = max(dr, R * dtheta)\n            log_h_vals.append(np.log(h))\n\n            # Grid nodes\n            r_nodes = np.linspace(0, R, Nr + 1)\n            theta_nodes = np.linspace(0, alpha, Ntheta + 1)\n\n            total_error_A_sq = 0.0\n\n            # Loop over all cells in the grid\n            for i in range(Nr):\n                for j in range(Ntheta):\n                    # Current cell boundaries\n                    r_i, r_i1 = r_nodes[i], r_nodes[i+1]\n                    th_j, th_j1 = theta_nodes[j], theta_nodes[j+1]\n\n                    # Exact solution at cell corners for bilinear interpolation\n                    A_vals_at_corners = A_exact(\n                        np.array([[r_i, r_i1], [r_i, r_i1]]),\n                        np.array([[th_j, th_j], [th_j1, th_j1]])\n                    )\n                    A00, A10 = A_vals_at_corners[0, 0], A_vals_at_corners[0, 1]\n                    A01, A11 = A_vals_at_corners[1, 0], A_vals_at_corners[1, 1]\n                    \n                    cell_error_sq = 0.0\n                    \n                    # Apply 3x3 product Gauss quadrature over the cell\n                    for m in range(n_gauss):\n                        xi_m = gp_01[m]\n                        w_xi = gw_01[m]\n                        r_at_gp = r_i + xi_m * dr\n                        \n                        for n in range(n_gauss):\n                            eta_n = gp_01[n]\n                            w_eta = gw_01[n]\n                            theta_at_gp = th_j + eta_n * dtheta\n                            \n                            # Bilinear interpolation at the quadrature point\n                            A_interp = (A00 * (1 - xi_m) * (1 - eta_n) +\n                                        A10 * xi_m * (1 - eta_n) +\n                                        A01 * (1 - xi_m) * eta_n +\n                                        A11 * xi_m * eta_n)\n                            \n                            # Exact value at the quadrature point\n                            A_ex = A_exact(r_at_gp, theta_at_gp)\n                            \n                            # Integrand for L2 error norm, including area element 'r'\n                            integrand = np.abs(A_ex - A_interp)**2 * r_at_gp\n                            \n                            cell_error_sq += w_xi * w_eta * integrand\n                    \n                    # Add cell's contribution to total error (with dV = dr * dtheta)\n                    total_error_A_sq += cell_error_sq * dr * dtheta\n\n            # Calculate L2 error norms for this refinement level\n            err_A = np.sqrt(total_error_A_sq)\n            err_J = omega * sigma * err_A\n            \n            log_err_A_vals.append(np.log(err_A))\n            log_err_J_vals.append(np.log(err_J))\n        \n        # Estimate convergence rates using linear regression on log-log data\n        p_A, _ = np.polyfit(log_h_vals, log_err_A_vals, 1)\n        p_J, _ = np.polyfit(log_h_vals, log_err_J_vals, 1)\n\n        all_rates.extend([p_A, p_J])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{rate:.10f}' for rate in all_rates)}]\")\n\n\nsolve()\n```"
        }
    ]
}