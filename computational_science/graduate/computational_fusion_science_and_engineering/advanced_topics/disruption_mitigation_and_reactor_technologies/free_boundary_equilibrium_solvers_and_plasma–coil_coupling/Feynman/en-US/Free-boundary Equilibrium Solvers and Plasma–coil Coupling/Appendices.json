{
    "hands_on_practices": [
        {
            "introduction": "Before we can solve for a plasma equilibrium, we must first establish the geometric framework. This exercise guides you through defining an axisymmetric plasma geometry using flux coordinates, which are natural for describing nested magnetic surfaces. You will implement the mapping from these abstract coordinates to physical space and compute essential metric coefficients and the Jacobian, providing a practical foundation for expressing physical laws in a non-Cartesian system .",
            "id": "3982360",
            "problem": "You are tasked with implementing flux-coordinate geometry for an axisymmetric free-boundary equilibrium in toroidal geometry, showing plasma–coil coupling through a coil-induced vertical magnetic field that shifts the magnetic axis. The mapping from flux coordinates to cylindrical coordinates must be used to derive metric coefficients and the Jacobian. The computations must be numerically stable across the domain, including near the magnetic axis, and must adhere to specified units.\n\nBegin from the following foundational principles appropriate to computational fusion science and engineering:\n- Maxwell’s equations imply that external coils can produce an approximately uniform vertical magnetic field in the plasma region if the coils are sufficiently far away. For a straight segment approximation with total Ampere-turns and effective length, the vertical magnetic field is taken as uniform: $$B_Z = \\mu_0 \\frac{N I}{L_{\\mathrm{eff}}},$$ where $$\\mu_0 = 4 \\pi \\times 10^{-7} \\ \\mathrm{T \\cdot m/A},$$ $$N$$ is the number of turns, $$I$$ is the coil current in $$\\mathrm{A},$$ and $$L_{\\mathrm{eff}}$$ is an effective length in $$\\mathrm{m}.$$\n- In axisymmetry, the flux surfaces can be parameterized by flux coordinates $$\\left(\\psi, \\theta, \\phi\\right)$$, where $$\\psi$$ is a dimensionless poloidal flux label (normalized to have $$\\psi \\in [0,1]$$), $$\\theta$$ is the poloidal angle in radians, and $$\\phi$$ is the toroidal angle in radians. The cylindrical coordinates $$\\left(R, Z, \\phi\\right)$$ are related to flux coordinates through a geometric mapping.\n- The plasma–coil coupling is reflected by a Shafranov-like horizontal shift of flux surfaces, modeled here by a coil-field-dependent center radius $$R_c(\\psi)$$.\n\nDefine the flux-surface mapping and its parameters as follows:\n- Major radius baseline: $$R_0 = 3.0 \\ \\mathrm{m}.$$\n- Edge minor radius: $$a_{\\mathrm{edge}} = 1.0 \\ \\mathrm{m}.$$\n- Elongation (vertical stretching): $$\\kappa = 1.7 \\ \\text{(dimensionless)}.$$\n- Coil geometry: $$N = 20 \\ \\text{turns}, \\quad L_{\\mathrm{eff}} = 8.0 \\ \\mathrm{m}.$$\n- Coil-induced vertical field: $$B_Z(I) = \\mu_0 \\frac{N I}{L_{\\mathrm{eff}}} \\ \\mathrm{T}.$$\n- Coil-induced center shift coefficient: $$\\sigma = 0.2 \\ \\mathrm{m/T}.$$\n- Center radius with coupling: $$R_c(\\psi) = R_0 + \\sigma B_Z(I) \\, \\psi.$$\n- Elliptical cross-section with minor radius profile: $$a(\\psi) = a_{\\mathrm{edge}} \\sqrt{\\max(\\psi, \\varepsilon)},$$ where $$\\varepsilon = 10^{-6}$$ is a regularization parameter to ensure numerical stability near the axis.\n- Mapping from flux coordinates to cylindrical coordinates:\n  $$R(\\psi, \\theta) = R_c(\\psi) + a(\\psi) \\cos\\theta,$$\n  $$Z(\\psi, \\theta) = \\kappa \\, a(\\psi) \\sin\\theta,$$\n  with $$\\phi$$ identified as the cylindrical toroidal angle.\n\nFrom this mapping, derive the covariant basis vectors $$\\mathbf{e}_\\psi = \\frac{\\partial \\mathbf{r}}{\\partial \\psi}, \\ \\mathbf{e}_\\theta = \\frac{\\partial \\mathbf{r}}{\\partial \\theta}, \\ \\mathbf{e}_\\phi = \\frac{\\partial \\mathbf{r}}{\\partial \\phi},$$ where $$\\mathbf{r} = R \\, \\hat{\\mathbf{e}}_R + Z \\, \\hat{\\mathbf{e}}_Z$$ in cylindrical coordinates (with $$\\hat{\\mathbf{e}}_R, \\hat{\\mathbf{e}}_\\phi, \\hat{\\mathbf{e}}_Z$$ orthonormal). Using this, compute the covariant metric components and the Jacobian:\n- Covariant metric components:\n  $$g_{\\psi\\psi} = \\mathbf{e}_\\psi \\cdot \\mathbf{e}_\\psi = \\left(\\frac{\\partial R}{\\partial \\psi}\\right)^2 + \\left(\\frac{\\partial Z}{\\partial \\psi}\\right)^2,$$\n  $$g_{\\psi\\theta} = \\mathbf{e}_\\psi \\cdot \\mathbf{e}_\\theta = \\left(\\frac{\\partial R}{\\partial \\psi}\\right)\\left(\\frac{\\partial R}{\\partial \\theta}\\right) + \\left(\\frac{\\partial Z}{\\partial \\psi}\\right)\\left(\\frac{\\partial Z}{\\partial \\theta}\\right),$$\n  $$g_{\\theta\\theta} = \\mathbf{e}_\\theta \\cdot \\mathbf{e}_\\theta = \\left(\\frac{\\partial R}{\\partial \\theta}\\right)^2 + \\left(\\frac{\\partial Z}{\\partial \\theta}\\right)^2,$$\n  $$g_{\\phi\\phi} = \\mathbf{e}_\\phi \\cdot \\mathbf{e}_\\phi = R^2.$$\n- Jacobian for the coordinate transformation $$\\left(\\psi, \\theta, \\phi\\right) \\mapsto \\left(x, y, z\\right)$$:\n  $$J(\\psi, \\theta) = \\left|\\mathbf{e}_\\psi \\cdot \\left(\\mathbf{e}_\\theta \\times \\mathbf{e}_\\phi \\right)\\right|.$$\n\nExpress all angles in radians and lengths in meters. Return the Jacobian in $$\\mathrm{m^3}$$ and $$g_{\\phi\\phi}$$ in $$\\mathrm{m^2}$$. For numerical stability, when computing $$\\frac{\\partial a}{\\partial \\psi}$$ use the regularized rule\n$$\n\\frac{\\partial a}{\\partial \\psi} =\n\\begin{cases}\n\\frac{a_{\\mathrm{edge}}}{2 \\sqrt{\\psi}}, & \\psi \\ge \\varepsilon, \\\\\n\\frac{a_{\\mathrm{edge}}}{2 \\sqrt{\\varepsilon}}, & \\psi < \\varepsilon,\n\\end{cases}\n$$\nand use $$\\frac{d R_c}{d \\psi} = \\sigma B_Z(I).$$\n\nYour program must compute, for each test case, the pair $$\\left(J(\\psi, \\theta), \\ g_{\\phi\\phi}(\\psi, \\theta)\\right)$$ and output a single line that aggregates all test case results into a comma-separated list enclosed in square brackets, ordered by test cases in the sequence given and, within each case, with $$J$$ first and then $$g_{\\phi\\phi}$$. Each float must be rounded to six decimal places.\n\nUse the following test suite, which covers a general case, a coil-on case, an edge case, and a near-axis stability case:\n1. $$I = 0 \\ \\mathrm{A}, \\ \\psi = 0.25, \\ \\theta = 0 \\ \\mathrm{rad}.$$\n2. $$I = 50{,}000 \\ \\mathrm{A}, \\ \\psi = 0.5, \\ \\theta = \\frac{\\pi}{2} \\ \\mathrm{rad}.$$\n3. $$I = 100{,}000 \\ \\mathrm{A}, \\ \\psi = 1.0, \\ \\theta = \\pi \\ \\mathrm{rad}.$$\n4. $$I = 100{,}000 \\ \\mathrm{A}, \\ \\psi = 10^{-8}, \\ \\theta = \\frac{\\pi}{3} \\ \\mathrm{rad}.$$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order:\n$$[J_1, g_{\\phi\\phi,1}, J_2, g_{\\phi\\phi,2}, J_3, g_{\\phi\\phi,3}, J_4, g_{\\phi\\phi,4}],$$\nwith each value rounded to six decimal places.",
            "solution": "The problem is valid as it is scientifically grounded in the principles of magnetohydrodynamics for toroidal plasmas, well-posed with a complete set of definitions and parameters, and objectively stated. It represents a standard computational exercise in fusion plasma physics.\n\nThe solution requires calculating the Jacobian $$J$$ of the coordinate transformation and the metric component $$g_{\\phi\\phi}$$ for a given geometric mapping from flux coordinates $$(\\psi, \\theta, \\phi)$$ to cylindrical coordinates $$(R, Z, \\phi)$$. The mapping models an elliptical, shifted plasma cross-section, where the shift depends on an external vertical magnetic field, thus coupling the plasma geometry to external coils.\n\nFirst, we define all constants and given functions:\n- Vacuum permeability: $$\\mu_0 = 4 \\pi \\times 10^{-7} \\ \\mathrm{T \\cdot m/A}$$\n- Coil parameters: $$N = 20 \\ \\text{turns}, \\ L_{\\mathrm{eff}} = 8.0 \\ \\mathrm{m}$$\n- Geometric parameters: $$R_0 = 3.0 \\ \\mathrm{m}, \\ a_{\\mathrm{edge}} = 1.0 \\ \\mathrm{m}, \\ \\kappa = 1.7$$\n- Coupling coefficient: $$\\sigma = 0.2 \\ \\mathrm{m/T}$$\n- Regularization parameter: $$\\varepsilon = 10^{-6}$$\n\nThe external vertical magnetic field $$B_Z$$ induced by the coils is given by:\n$$B_Z(I) = \\mu_0 \\frac{N I}{L_{\\mathrm{eff}}}$$\n\nThe flux-surface geometry is defined by the following mapping:\n$$R(\\psi, \\theta) = R_c(\\psi) + a(\\psi) \\cos\\theta$$\n$$Z(\\psi, \\theta) = \\kappa \\, a(\\psi) \\sin\\theta$$\nwhere the center radius $$R_c(\\psi)$$ and minor radius $$a(\\psi)$$ are:\n$$R_c(\\psi) = R_0 + \\sigma B_Z(I) \\, \\psi$$\n$$a(\\psi) = a_{\\mathrm{edge}} \\sqrt{\\max(\\psi, \\varepsilon)}$$\n\nTo compute the metric components and the Jacobian, we need the partial derivatives of $$R$$ and $$Z$$ with respect to $$\\psi$$ and $$\\theta$$. We first find the derivatives of $$R_c(\\psi)$$ and $$a(\\psi)$$ with respect to $$\\psi$$.\n$$ \\frac{dR_c}{d\\psi} = \\sigma B_Z(I) $$\nThe derivative of the minor radius, $$a'(\\psi) = \\frac{da}{d\\psi}$$, is given by the regularized, piecewise formula:\n$$\na'(\\psi) = \\frac{da}{d\\psi} =\n\\begin{cases}\n\\frac{a_{\\mathrm{edge}}}{2 \\sqrt{\\psi}}, & \\text{if } \\psi \\ge \\varepsilon \\\\\n\\frac{a_{\\mathrm{edge}}}{2 \\sqrt{\\varepsilon}}, & \\text{if } \\psi < \\varepsilon\n\\end{cases}\n$$\n\nUsing the chain rule, we find the partial derivatives of the cylindrical coordinates:\n$$ \\frac{\\partial R}{\\partial \\psi} = \\frac{dR_c}{d\\psi} + \\frac{da}{d\\psi}\\cos\\theta = \\sigma B_Z(I) + a'(\\psi)\\cos\\theta $$\n$$ \\frac{\\partial R}{\\partial \\theta} = -a(\\psi)\\sin\\theta $$\n$$ \\frac{\\partial Z}{\\partial \\psi} = \\kappa \\frac{da}{d\\psi}\\sin\\theta = \\kappa a'(\\psi)\\sin\\theta $$\n$$ \\frac{\\partial Z}{\\partial \\theta} = \\kappa a(\\psi)\\cos\\theta $$\n\nThe metric component $$g_{\\phi\\phi}$$ is defined as the square of the major radius $$R$$:\n$$ g_{\\phi\\phi}(\\psi, \\theta) = R(\\psi, \\theta)^2 = (R_c(\\psi) + a(\\psi)\\cos\\theta)^2 $$\n\nThe Jacobian of the transformation from $$(\\psi, \\theta, \\phi)$$ to Cartesian coordinates is given by $$J = \\left|\\det\\left(\\frac{\\partial(x,y,z)}{\\partial(\\psi,\\theta,\\phi)}\\right)\\right|$$. In an axisymmetric cylindrical system, this simplifies to $$J = R \\left| \\frac{\\partial R}{\\partial \\psi} \\frac{\\partial Z}{\\partial \\theta} - \\frac{\\partial R}{\\partial \\theta} \\frac{\\partial Z}{\\partial \\psi} \\right|$$. Let's compute the determinant term:\n$$ \\mathcal{J}_{2D} = \\frac{\\partial R}{\\partial \\psi} \\frac{\\partial Z}{\\partial \\theta} - \\frac{\\partial R}{\\partial \\theta} \\frac{\\partial Z}{\\partial \\psi} $$\n$$ = (\\sigma B_Z(I) + a'(\\psi)\\cos\\theta)(\\kappa a(\\psi)\\cos\\theta) - (-a(\\psi)\\sin\\theta)(\\kappa a'(\\psi)\\sin\\theta) $$\n$$ = \\kappa a(\\psi)\\sigma B_Z(I)\\cos\\theta + \\kappa a(\\psi)a'(\\psi)\\cos^2\\theta + \\kappa a(\\psi)a'(\\psi)\\sin^2\\theta $$\n$$ = \\kappa a(\\psi)\\sigma B_Z(I)\\cos\\theta + \\kappa a(\\psi)a'(\\psi)(\\cos^2\\theta + \\sin^2\\theta) $$\n$$ = \\kappa a(\\psi) (a'(\\psi) + \\sigma B_Z(I)\\cos\\theta) $$\nThe full Jacobian $$J$$ is then:\n$$ J(\\psi, \\theta) = R(\\psi, \\theta) |\\mathcal{J}_{2D}| = R(\\psi, \\theta) \\left| \\kappa a(\\psi) (a'(\\psi) + \\sigma B_Z(I)\\cos\\theta) \\right| $$\nFor typical physical parameters, the term inside the absolute value is positive, so we can write:\n$$ J(\\psi, \\theta) = \\kappa R(\\psi, \\theta) a(\\psi) (a'(\\psi) + \\sigma B_Z(I)\\cos\\theta) $$\n\nThese derived formulae are implemented numerically for each test case.\n- For Test Case 1: $$I=0$$. The system has no coil-induced shift. $$B_Z=0$$, so $$R_c(\\psi) = R_0$$. Jacobian simplifies to $$J=\\kappa R a a'$$.\n- For Test Case 2: $$I=50,000 \\ \\mathrm{A}$$. A moderate vertical field is applied, causing a $$\\psi$$-dependent shift. Since $$\\theta=\\pi/2$$, $$\\cos\\theta=0$$, which simplifies calculations for $$R$$ and $$J$$.\n- For Test Case 3: $$I=100,000 \\ \\mathrm{A}$$. A larger field is applied at the plasma edge ($$\\psi=1$$) and on the inboard side ($$\\theta=\\pi$$), where the shift has the largest effect on decreasing the major radius.\n- For Test Case 4: $$I=100,000 \\ \\mathrm{A}$$. This tests the numerical stability near the magnetic axis ($$\\psi \\to 0$$). Since $$\\psi = 10^{-8} < \\varepsilon$$, the regularized formulas for $$a(\\psi)$$ and $$a'(\\psi)$$ are invoked to prevent division by zero and maintain well-behaved geometric quantities.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Jacobian and g_phiphi metric component for a set of test cases\n    based on a model of flux-coordinate geometry for an axisymmetric toroidal plasma.\n    \"\"\"\n\n    # Define physical and geometric constants from the problem statement.\n    MU_0 = 4 * np.pi * 1e-7  # T*m/A\n    R0 = 3.0  # m\n    A_EDGE = 1.0  # m\n    KAPPA = 1.7  # dimensionless\n    N_TURNS = 20.0\n    L_EFF = 8.0  # m\n    SIGMA = 0.2  # m/T\n    EPSILON = 1e-6  # Regularization parameter\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (I [A], psi [dimless], theta [rad])\n        (0.0, 0.25, 0.0),\n        (50000.0, 0.5, np.pi / 2),\n        (100000.0, 1.0, np.pi),\n        (100000.0, 1e-8, np.pi / 3),\n    ]\n\n    results = []\n    for i_val, psi, theta in test_cases:\n        # Step 1: Calculate the coil-induced vertical magnetic field.\n        b_z = MU_0 * (N_TURNS * i_val) / L_EFF\n\n        # Step 2: Calculate psi-dependent geometric quantities with regularization.\n        psi_eff = max(psi, EPSILON)\n        a_psi = A_EDGE * np.sqrt(psi_eff)\n        \n        if psi >= EPSILON:\n            a_prime_psi = A_EDGE / (2 * np.sqrt(psi))\n        else:\n            a_prime_psi = A_EDGE / (2 * np.sqrt(EPSILON))\n\n        # Step 3: Calculate the center radius with plasma-coil coupling.\n        r_c_psi = R0 + SIGMA * b_z * psi\n\n        # Step 4: Compute the mapping to cylindrical coordinates.\n        cos_theta = np.cos(theta)\n        r_psi_theta = r_c_psi + a_psi * cos_theta\n\n        # Step 5: Compute the required metric component g_phiphi.\n        g_phiphi = r_psi_theta**2\n\n        # Step 6: Compute the Jacobian of the transformation.\n        # J = kappa * R * a * (a' + sigma * B_Z * cos(theta))\n        jacobian = KAPPA * r_psi_theta * a_psi * (a_prime_psi + SIGMA * b_z * cos_theta)\n\n        # Step 7: Append results, formatted to six decimal places.\n        results.append(f\"{jacobian:.6f}\")\n        results.append(f\"{g_phiphi:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "With the geometry defined, the next step is to solve for the magnetic field configuration itself. This practice dives into the core of equilibrium solvers by numerically tackling the Grad-Shafranov equation using the finite difference method. You will discretize the governing elliptic partial differential equation, assemble a linear system representing the plasma and external coil currents, and solve for the poloidal magnetic flux to compute a complete free-boundary equilibrium .",
            "id": "3982361",
            "problem": "A free-boundary axisymmetric equilibrium in a Tokamak is governed by magnetostatic laws and force balance. Under axisymmetry, define the poloidal flux function $\\,\\psi(R,Z)\\,$ such that the poloidal magnetic field components satisfy $\\,B_R = -\\frac{1}{R}\\frac{\\partial \\psi}{\\partial Z}\\,$ and $\\,B_Z = \\frac{1}{R}\\frac{\\partial \\psi}{\\partial R}\\,$, where $\\,R\\,$ is the cylindrical radius and $\\,Z\\,$ is the vertical coordinate. The axisymmetric toroidal current density $\\,j_\\phi\\,$ is related to the flux function by Ampère’s law, $\\,\\nabla \\times \\mathbf{B} = \\mu_0 \\mathbf{j}\\,$, giving $\\,j_\\phi = -\\frac{1}{\\mu_0 R}\\Delta^* \\psi\\,$, where the elliptic operator $\\,\\Delta^*\\,$ is defined by\n$$\n\\Delta^* \\psi \\equiv R \\frac{\\partial}{\\partial R}\\left(\\frac{1}{R} \\frac{\\partial \\psi}{\\partial R}\\right) + \\frac{\\partial^2 \\psi}{\\partial Z^2} = \\frac{\\partial^2 \\psi}{\\partial R^2} - \\frac{1}{R} \\frac{\\partial \\psi}{\\partial R} + \\frac{\\partial^2 \\psi}{\\partial Z^2}.\n$$\nIn the plasma region, force balance $\\,\\mathbf{j} \\times \\mathbf{B} = \\nabla p\\,$ combined with axisymmetry yields the Grad–Shafranov equation (GSE),\n$$\n\\Delta^* \\psi = -\\mu_0 R^2 \\frac{dp}{d\\psi} - F(\\psi) \\frac{dF}{d\\psi},\n$$\nwhere $\\,p(\\psi)\\,$ is the pressure profile and $\\,F(\\psi) \\equiv R B_\\phi\\,$ encodes the toroidal field contribution. External poloidal field coils are represented as toroidal current distributions $\\,j_{\\phi,\\text{coil}}(R,Z)\\,$ that couple to the plasma through Maxwell’s equations and contribute directly to $\\,\\Delta^* \\psi\\,$. In a free-boundary computation that includes coils within the computational domain, one may superpose coil currents and plasma currents via\n$$\n\\Delta^* \\psi = -\\mu_0 R j_{\\phi,\\text{coil}}(R,Z) - \\mu_0 R^2 \\frac{dp}{d\\psi} - F(\\psi) \\frac{dF}{d\\psi},\n$$\nand then recover $\\,j_\\phi\\,$ consistently from $\\,\\psi\\,$.\n\nUsing only the fundamental relations above, derive a finite difference discretization of the operator $\\,\\Delta^*\\,$ on a uniform rectangular grid and assemble a linear system for the unknown nodal values of $\\,\\psi\\,$ with homogeneous Dirichlet boundary conditions $\\,\\psi=0\\,$ on the boundary. Treat the coils as localized toroidal current densities modeled by normalized Gaussian rings centered at coil locations. Specifically, for a coil located at $\\,\\left(R_0,Z_0\\right)\\,$ with total current $\\,I\\,$, approximate its toroidal current density by\n$$\nj_{\\phi,\\text{coil}}(R,Z) = I \\, g(R,Z), \\quad g(R,Z) = \\frac{1}{2\\pi \\sigma_R \\sigma_Z} \\exp\\left(-\\frac{(R-R_0)^2}{2\\sigma_R^2} - \\frac{(Z-Z_0)^2}{2\\sigma_Z^2}\\right),\n$$\nand renormalize $\\,g\\,$ numerically on the discrete grid so that $\\,\\int g\\, dR\\, dZ = 1\\,$ holds to machine precision within the computational domain. Assume a simple plasma model with $\\,F(\\psi) = F_0\\,$ constant so that $\\,\\frac{dF}{d\\psi} = 0\\,$, and take $\\,\\frac{dp}{d\\psi} = p'_0\\,$ constant inside a prescribed elliptical plasma region and zero outside it. The computational domain and parameters are as follows:\n\n- Domain: $\\,R \\in [1.0,3.0]\\,$ meters and $\\,Z \\in [-1.0,1.0]\\,$ meters, uniformly discretized on $\\,N_R = 81\\,$ and $\\,N_Z = 81\\,$ nodes.\n- Permeability of free space: $\\,\\mu_0 = 4\\pi \\times 10^{-7}\\,$ henry per meter.\n- Coil Gaussian widths: $\\,\\sigma_R = 0.02\\,$ meters and $\\,\\sigma_Z = 0.02\\,$ meters.\n- Plasma region: an ellipse centered at $\\,\\left(R_c,Z_c\\right)\\,$ with semi-axes $\\,a_R\\,$ and $\\,a_Z\\,$, defined by points satisfying $\\,\\left(\\frac{R-R_c}{a_R}\\right)^2 + \\left(\\frac{Z-Z_c}{a_Z}\\right)^2 \\le 1\\,$.\n- Pressure gradient: $\\,\\frac{dp}{d\\psi} = p'_0\\,$ (units of pascal per weber), constant inside the plasma ellipse and zero outside.\n- Toroidal field function: $\\,F(\\psi) = F_0\\,$ with $\\,\\frac{dF}{d\\psi} = 0\\,$.\n\nTasks:\n\n1. Starting from the definition of $\\,\\Delta^*\\,$, derive a second-order accurate finite difference stencil on the uniform grid for interior nodes. Assemble the sparse linear system $\\,\\mathbf{A}\\mathbf{\\Psi}=\\mathbf{b}\\,$, where $\\,\\mathbf{\\Psi}\\,$ are the interior nodal values of $\\,\\psi\\,$, with homogeneous Dirichlet boundary conditions.\n2. Construct $\\,j_{\\phi,\\text{coil}}(R,Z)\\,$ on the grid as the sum of renormalized Gaussian rings for each coil, and construct the right-hand side source $\\,S(R,Z) = -\\mu_0 R j_{\\phi,\\text{coil}}(R,Z) - \\mu_0 R^2 p'_0 \\chi_{\\text{plasma}}(R,Z)\\,$, where $\\,\\chi_{\\text{plasma}}\\,$ is the indicator function of the plasma ellipse.\n3. Solve the linear system for $\\,\\psi\\,$, compute the discrete residual $\\,\\mathcal{R} = \\Delta^* \\psi - S\\,$ on interior nodes using the same stencil, and report the maximum absolute residual value in units of webers per meter squared.\n4. Compute the plasma toroidal current $\\,I_p\\,$ by integrating $\\,j_{\\phi,\\text{plasma}}(R,Z) = -\\frac{1}{\\mu_0 R}\\Delta^* \\psi(R,Z) - j_{\\phi,\\text{coil}}(R,Z)\\,$ over the plasma region. Report $\\,I_p\\,$ in amperes.\n\nDesign a program that performs the above steps for the following test suite, covering a range of plasma–coil coupling scenarios:\n\n- Test case $\\,1\\,$ (general case): $\\,p'_0 = -1.0\\times 10^6\\,$ pascal per weber, plasma ellipse with $\\,R_c = 2.0\\,$ meters, $\\,Z_c = 0.0\\,$ meters, $\\,a_R = 0.5\\,$ meters, $\\,a_Z = 0.3\\,$ meters, one coil at $\\,R_0 = 3.0\\,$ meters, $\\,Z_0 = 0.6\\,$ meters, $\\,I = 1.0 \\times 10^6\\,$ amperes.\n- Test case $\\,2\\,$ (symmetric coils): same plasma as test case $\\,1\\,$, two coils at $\\,\\left(R_0,Z_0\\right) = (3.0,0.6)\\,$ and $\\,\\left(R_0,Z_0\\right) = (3.0,-0.6)\\,$, each with $\\,I = 1.0 \\times 10^6\\,$ amperes.\n- Test case $\\,3\\,$ (vacuum limit): $\\,p'_0 = 0.0\\,$, no plasma (set $\\,a_R = 0.0\\,$ and $\\,a_Z = 0.0\\,$ so that $\\,\\chi_{\\text{plasma}}=0\\,$ everywhere), two coils at $\\,\\left(R_0,Z_0\\right) = (3.0,0.6)\\,$ and $\\,\\left(R_0,Z_0\\right) = (3.0,-0.6)\\,$, each with $\\,I = 1.0 \\times 10^6\\,$ amperes.\n- Test case $\\,4\\,$ (edge case with tiny plasma): $\\,p'_0 = -2.0\\times 10^6\\,$ pascal per weber, plasma ellipse with $\\,R_c = 2.0\\,$ meters, $\\,Z_c = 0.0\\,$ meters, $\\,a_R = 0.15\\,$ meters, $\\,a_Z = 0.10\\,$ meters, two coils at $\\,\\left(R_0,Z_0\\right) = (3.0,0.6)\\,$ and $\\,\\left(R_0,Z_0\\right) = (3.0,-0.6)\\,$, each with $\\,I = 0.5 \\times 10^6\\,$ amperes.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each test case contributing a two-element list $\\,\\left[\\text{residual\\_max}, I_p\\right]\\,$ in the order of the test suite. The first element must be the maximum absolute residual in webers per meter squared and the second element must be the plasma current in amperes. For example, the output format must be like $\\,\\left[[r_1,i_1],[r_2,i_2],[r_3,i_3],[r_4,i_4]\\right]\\,$ with numeric values substituted.",
            "solution": "The derivation begins from magnetostatics and axisymmetry. With the poloidal flux function $\\,\\psi(R,Z)\\,$ defined such that $\\,B_R = -\\frac{1}{R}\\frac{\\partial \\psi}{\\partial Z}\\,$ and $\\,B_Z = \\frac{1}{R}\\frac{\\partial \\psi}{\\partial R}\\,$, the toroidal component of the curl of $\\,\\mathbf{B}\\,$ is\n$$\n(\\nabla \\times \\mathbf{B})_\\phi = \\frac{\\partial B_R}{\\partial Z} - \\frac{\\partial B_Z}{\\partial R}.\n$$\nUsing the axisymmetric expressions for $\\,B_R\\,$ and $\\,B_Z\\,$, compute each derivative:\n$$\n\\frac{\\partial B_R}{\\partial Z} = \\frac{\\partial}{\\partial Z}\\left(-\\frac{1}{R}\\frac{\\partial \\psi}{\\partial Z}\\right) = -\\frac{1}{R} \\frac{\\partial^2 \\psi}{\\partial Z^2},\n$$\n$$\n\\frac{\\partial B_Z}{\\partial R} = \\frac{\\partial}{\\partial R}\\left(\\frac{1}{R}\\frac{\\partial \\psi}{\\partial R}\\right) = -\\frac{1}{R^2}\\frac{\\partial \\psi}{\\partial R} + \\frac{1}{R}\\frac{\\partial^2 \\psi}{\\partial R^2}.\n$$\nTherefore,\n$$\n(\\nabla \\times \\mathbf{B})_\\phi = -\\frac{1}{R}\\frac{\\partial^2 \\psi}{\\partial Z^2} - \\left(-\\frac{1}{R^2}\\frac{\\partial \\psi}{\\partial R} + \\frac{1}{R}\\frac{\\partial^2 \\psi}{\\partial R^2}\\right) = -\\frac{1}{R}\\left(\\frac{\\partial^2 \\psi}{\\partial R^2} - \\frac{1}{R}\\frac{\\partial \\psi}{\\partial R} + \\frac{\\partial^2 \\psi}{\\partial Z^2}\\right) = -\\frac{1}{R}\\Delta^* \\psi.\n$$\nAmpère’s law $\\,\\nabla \\times \\mathbf{B} = \\mu_0 \\mathbf{j}\\,$ then yields $\\,j_\\phi = \\frac{1}{\\mu_0}(\\nabla \\times \\mathbf{B})_\\phi = -\\frac{1}{\\mu_0 R}\\Delta^* \\psi\\,$. In a plasma region with pressure $\\,p(\\psi)\\,$ and toroidal field function $\\,F(\\psi) \\equiv R B_\\phi\\,$, force balance $\\,\\mathbf{j} \\times \\mathbf{B} = \\nabla p\\,$ implies the Grad–Shafranov equation\n$$\n\\Delta^* \\psi = -\\mu_0 R^2 \\frac{dp}{d\\psi} - F(\\psi) \\frac{dF}{d\\psi}.\n$$\nWhen external toroidal coil currents $\\,j_{\\phi,\\text{coil}}(R,Z)\\,$ are present alongside plasma currents, Maxwell’s relation adds them linearly to the source of $\\,\\Delta^* \\psi\\,$ since $\\,\\Delta^* \\psi = - \\mu_0 R j_\\phi\\,.$ With $\\,F(\\psi) = F_0\\,$ constant so $\\,\\frac{dF}{d\\psi} = 0\\,$, one obtains the computationally convenient form\n$$\n\\Delta^* \\psi = -\\mu_0 R j_{\\phi,\\text{coil}}(R,Z) - \\mu_0 R^2 \\frac{dp}{d\\psi}.\n$$\n\nDiscretization follows from the definition of $\\,\\Delta^*\\,$. On a uniform grid with $\\,R\\,$ spacing $\\,\\Delta R\\,$ and $\\,Z\\,$ spacing $\\,\\Delta Z\\,$, for an interior node at $\\,\\left(R_i,Z_j\\right)\\,$, approximate derivatives by second-order central differences:\n$$\n\\frac{\\partial^2 \\psi}{\\partial R^2}\\bigg|_{i,j} \\approx \\frac{\\psi_{i+1,j} - 2\\psi_{i,j} + \\psi_{i-1,j}}{\\Delta R^2},\n\\quad\n\\frac{\\partial \\psi}{\\partial R}\\bigg|_{i,j} \\approx \\frac{\\psi_{i+1,j} - \\psi_{i-1,j}}{2\\Delta R},\n$$\n$$\n\\frac{\\partial^2 \\psi}{\\partial Z^2}\\bigg|_{i,j} \\approx \\frac{\\psi_{i,j+1} - 2\\psi_{i,j} + \\psi_{i,j-1}}{\\Delta Z^2}.\n$$\nInserting these into $\\,\\Delta^* \\psi = \\frac{\\partial^2 \\psi}{\\partial R^2} - \\frac{1}{R}\\frac{\\partial \\psi}{\\partial R} + \\frac{\\partial^2 \\psi}{\\partial Z^2}\\,$ at $\\,R=R_i\\,$ yields a linear stencil:\n$$\n\\Delta^* \\psi\\big|_{i,j} \\approx \\left(\\frac{1}{\\Delta R^2} - \\frac{1}{2 R_i \\Delta R}\\right)\\psi_{i+1,j} + \\left(\\frac{1}{\\Delta R^2} + \\frac{1}{2 R_i \\Delta R}\\right)\\psi_{i-1,j} + \\frac{1}{\\Delta Z^2}\\psi_{i,j+1} + \\frac{1}{\\Delta Z^2}\\psi_{i,j-1} - \\left(\\frac{2}{\\Delta R^2} + \\frac{2}{\\Delta Z^2}\\right)\\psi_{i,j}.\n$$\nHomogeneous Dirichlet boundary conditions $\\,\\psi=0\\,$ on the domain boundary allow eliminating boundary nodes from the unknown vector and assembling a sparse matrix $\\,\\mathbf{A}\\,$ representing the stencil at interior nodes. For each interior node, coefficients multiply the unknowns at neighboring interior nodes; neighbors on the boundary contribute known values equal to zero and thus do not alter the right-hand side. The source term at each interior node is $\\,S_{i,j} = -\\mu_0 R_i j_{\\phi,\\text{coil}}(R_i,Z_j) - \\mu_0 R_i^2 p'_0 \\chi_{\\text{plasma}}(R_i,Z_j)\\,$.\n\nThe coil model $\\,j_{\\phi,\\text{coil}}\\,$ uses Gaussian rings. For each coil at $\\,\\left(R_0,Z_0\\right)\\,$ with current $\\,I\\,$, define\n$$\ng(R,Z) = \\frac{1}{2\\pi \\sigma_R \\sigma_Z} \\exp\\left(-\\frac{(R-R_0)^2}{2\\sigma_R^2} - \\frac{(Z-Z_0)^2}{2\\sigma_Z^2}\\right).\n$$\nTo ensure $\\,\\int g\\, dR\\, dZ = 1\\,$ on the discrete grid, compute the discrete sum $\\,G = \\sum_{i,j} g(R_i,Z_j)\\, \\Delta R\\, \\Delta Z\\,$ and renormalize $\\,\\tilde{g} = g/G\\,$. The coil current density contribution is then $\\,j_{\\phi,\\text{coil}} = I \\tilde{g}\\,$, and when multiple coils are present, superpose $\\,j_{\\phi,\\text{coil}} = \\sum_k I_k \\tilde{g}_k\\,$.\n\nSolving the linear system $\\,\\mathbf{A}\\mathbf{\\Psi}=\\mathbf{b}\\,$ with a sparse direct solver yields the interior values of $\\,\\psi\\,$. The discrete residual is computed by applying the same finite difference stencil to the full grid (with boundary zeros) and subtracting the source $\\,S\\,$:\n$$\n\\mathcal{R}_{i,j} = \\left(\\Delta^* \\psi\\right)_{i,j}^{\\text{disc}} - S_{i,j}.\n$$\nThe maximum norm $\\,\\max_{i,j} |\\mathcal{R}_{i,j}|\\,$ is reported in webers per meter squared. The plasma toroidal current density is extracted from the solution by subtracting coil contributions using Ampère’s relation:\n$$\nj_{\\phi,\\text{plasma}}(R_i,Z_j) = -\\frac{1}{\\mu_0 R_i}\\left(\\Delta^* \\psi\\right)_{i,j}^{\\text{disc}} - j_{\\phi,\\text{coil}}(R_i,Z_j),\n$$\nand integrating over the plasma ellipse:\n$$\nI_p = \\sum_{i,j \\in \\text{plasma}} j_{\\phi,\\text{plasma}}(R_i,Z_j)\\, \\Delta R\\, \\Delta Z.\n$$\n\nAlgorithmic steps implemented by the program:\n\n- Construct uniform grids in $\\,R\\,$ and $\\,Z\\,$ with $\\,N_R = 81\\,$ and $\\,N_Z = 81\\,$ on the specified domain, compute $\\,\\Delta R\\,$ and $\\,\\Delta Z\\,$.\n- Build the sparse matrix $\\,\\mathbf{A}\\,$ using the derived stencil coefficients, mapping each interior node $\\,\\left(i,j\\right)\\,$ to a linear index.\n- For each test case:\n  - Form the plasma indicator $\\,\\chi_{\\text{plasma}}\\,$ from the ellipse definition using provided $\\,R_c\\,$, $\\,Z_c\\,$, $\\,a_R\\,$, $\\,a_Z\\,$.\n  - Assemble $\\,j_{\\phi,\\text{coil}}\\,$ by summing renormalized Gaussian rings for all coils.\n  - Form $\\,S\\,$ from $\\,j_{\\phi,\\text{coil}}\\,$ and $\\,p'_0\\,$.\n  - Solve $\\,\\mathbf{A}\\mathbf{\\Psi}=\\mathbf{b}\\,$ for $\\,\\psi\\,$.\n  - Compute the discrete residual $\\,\\mathcal{R}\\,$ and its maximum absolute value.\n  - Compute $\\,j_{\\phi,\\text{plasma}}\\,$ from $\\,\\psi\\,$ and integrate over the plasma region to obtain $\\,I_p\\,$.\n- Produce a single-line output $\\,\\left[[r_1,i_1],[r_2,i_2],[r_3,i_3],[r_4,i_4]\\right]\\,$ where $\\,r_k\\,$ is in webers per meter squared and $\\,i_k\\,$ is in amperes.\n\nThis construction is principle-based: the operator $\\,\\Delta^*\\,$ originates from magnetostatics and the discretization uses second-order accurate finite differences consistent with the operator’s $\\,R\\,$-dependent term. Coil–plasma coupling enters through superposition in the source term using $\\,j_{\\phi,\\text{coil}}\\,$ derived from a physically plausible localized current density. The plasma current is extracted consistently from the solved $\\,\\psi\\,$ via Ampère’s relation, subtracting coil contributions to isolate the plasma component.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import coo_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef build_grid(R_min, R_max, Z_min, Z_max, NR, NZ):\n    R = np.linspace(R_min, R_max, NR)\n    Z = np.linspace(Z_min, Z_max, NZ)\n    dR = (R_max - R_min) / (NR - 1)\n    dZ = (Z_max - Z_min) / (NZ - 1)\n    return R, Z, dR, dZ\n\ndef interior_index(i, j, NZ_interior):\n    # Map interior grid (i in [1..NR-2], j in [1..NZ-2]) to linear index\n    return (i - 1) * NZ_interior + (j - 1)\n\ndef build_delta_star_matrix(R, dR, dZ):\n    NR = len(R)\n    pass\n\ndef assemble_matrix(R, dR, dZ, NR, NZ):\n    # Build sparse matrix for interior nodes\n    NZ_interior = NZ - 2\n    N_interior = (NR - 2) * (NZ - 2)\n    rows = []\n    cols = []\n    data = []\n\n    inv_dR2 = 1.0 / (dR * dR)\n    inv_dZ2 = 1.0 / (dZ * dZ)\n\n    for i in range(1, NR - 1):\n        Ri = R[i]\n        for j in range(1, NZ - 1):\n            idx = interior_index(i, j, NZ_interior)\n            # Coefficients based on stencil:\n            coeff_center = -(2.0 * inv_dR2 + 2.0 * inv_dZ2)\n            coeff_Rp = inv_dR2 - (1.0 / (2.0 * Ri * dR))\n            coeff_Rm = inv_dR2 + (1.0 / (2.0 * Ri * dR))\n            coeff_Zp = inv_dZ2\n            coeff_Zm = inv_dZ2\n\n            # Center\n            rows.append(idx); cols.append(idx); data.append(coeff_center)\n\n            # i+1,j neighbor\n            if i + 1 = NR - 2:\n                id_n = interior_index(i + 1, j, NZ_interior)\n                rows.append(idx); cols.append(id_n); data.append(coeff_Rp)\n            # i-1,j neighbor\n            if i - 1 >= 1:\n                id_n = interior_index(i - 1, j, NZ_interior)\n                rows.append(idx); cols.append(id_n); data.append(coeff_Rm)\n            # i,j+1 neighbor\n            if j + 1 = NZ - 2:\n                id_n = interior_index(i, j + 1, NZ_interior)\n                rows.append(idx); cols.append(id_n); data.append(coeff_Zp)\n            # i,j-1 neighbor\n            if j - 1 >= 1:\n                id_n = interior_index(i, j - 1, NZ_interior)\n                rows.append(idx); cols.append(id_n); data.append(coeff_Zm)\n\n    A = coo_matrix((data, (rows, cols)), shape=(N_interior, N_interior)).tocsr()\n    return A\n\ndef apply_delta_star_disc(psi, R, dR, dZ):\n    # Apply discrete Delta* operator to full grid psi (including boundary), return interior values array\n    NR = psi.shape[0]\n    NZ = psi.shape[1]\n    inv_dR2 = 1.0 / (dR * dR)\n    inv_dZ2 = 1.0 / (dZ * dZ)\n    NZ_interior = NZ - 2\n    result = np.zeros(((NR - 2) * (NZ - 2),), dtype=float)\n    for i in range(1, NR - 1):\n        Ri = R[i]\n        for j in range(1, NZ - 1):\n            idx = interior_index(i, j, NZ_interior)\n            term_R2 = (psi[i + 1, j] - 2.0 * psi[i, j] + psi[i - 1, j]) * inv_dR2\n            term_Z2 = (psi[i, j + 1] - 2.0 * psi[i, j] + psi[i, j - 1]) * inv_dZ2\n            term_R1 = (psi[i + 1, j] - psi[i - 1, j]) / (2.0 * dR)\n            result[idx] = term_R2 - (1.0 / Ri) * term_R1 + term_Z2\n    return result\n\ndef gaussian_ring(R, Z, R0, Z0, sigR, sigZ):\n    # Evaluate unnormalized Gaussian ring on grid\n    RR = R[:, None]\n    ZZ = Z[None, :]\n    g = np.exp(-0.5 * ((RR - R0) ** 2 / (sigR ** 2) + (ZZ - Z0) ** 2 / (sigZ ** 2)))\n    # Prefactor 1/(2*pi*sigR*sigZ) for proper normalization in continuous plane\n    g *= (1.0 / (2.0 * np.pi * sigR * sigZ))\n    return g\n\ndef normalize_on_grid(g, dR, dZ):\n    total = np.sum(g) * dR * dZ\n    if total = 0.0:\n        return g\n    return g / total\n\ndef build_coil_current_density(R, Z, dR, dZ, coils, sigR, sigZ):\n    # coils: list of (R0, Z0, I)\n    j = np.zeros((len(R), len(Z)), dtype=float)\n    for (R0, Z0, I) in coils:\n        g = gaussian_ring(R, Z, R0, Z0, sigR, sigZ)\n        g_norm = normalize_on_grid(g, dR, dZ)\n        j += I * g_norm\n    return j\n\ndef plasma_indicator(R, Z, Rc, Zc, aR, aZ):\n    # Ellipse indicator\n    RR = R[:, None]\n    ZZ = Z[None, :]\n    if aR = 0.0 or aZ = 0.0:\n        return np.zeros((len(R), len(Z)), dtype=float)\n    val = ((RR - Rc) / aR) ** 2 + ((ZZ - Zc) / aZ) ** 2\n    return (val = 1.0).astype(float)\n\ndef solve_case(params, grid, A):\n    R, Z, dR, dZ = grid\n    NR = len(R); NZ = len(Z)\n    NZ_interior = NZ - 2\n    mu0 = 4.0 * np.pi * 1e-7  # H/m\n\n    # Unpack params\n    pprime = params['pprime']\n    Rc, Zc = params['plasma_center']\n    aR, aZ = params['plasma_axes']\n    coils = params['coils']\n    sigR = params['sigma_R']\n    sigZ = params['sigma_Z']\n\n    # Build source terms\n    chi = plasma_indicator(R, Z, Rc, Zc, aR, aZ)\n    jcoil = build_coil_current_density(R, Z, dR, dZ, coils, sigR, sigZ)\n    # S = -mu0 * R * jcoil - mu0 * R^2 * pprime * chi\n    RR = R[:, None]\n    S = -mu0 * RR * jcoil - mu0 * (RR ** 2) * pprime * chi\n\n    # Right-hand side vector b for interior nodes\n    b = np.zeros(((NR - 2) * (NZ - 2),), dtype=float)\n    for i in range(1, NR - 1):\n        for j in range(1, NZ - 1):\n            idx = interior_index(i, j, NZ_interior)\n            b[idx] = S[i, j]\n\n    # Solve A psi_interior = b\n    psi_interior = spsolve(A, b)\n\n    # Assemble full psi grid with boundary zeros\n    psi = np.zeros((NR, NZ), dtype=float)\n    for i in range(1, NR - 1):\n        for j in range(1, NZ - 1):\n            idx = interior_index(i, j, NZ_interior)\n            psi[i, j] = psi_interior[idx]\n\n    # Compute discrete residual on interior: R_disc = Delta* psi - S\n    Lpsi_interior = apply_delta_star_disc(psi, R, dR, dZ)\n    residual_interior = Lpsi_interior - b  # since b = S at interior\n    residual_max = float(np.max(np.abs(residual_interior)))\n\n    # Compute j_phi_plasma from solution: j_plasma = -(1/(mu0 R)) Delta*psi - jcoil\n    # First, reconstruct Delta*psi on full grid interior values in array form\n    # Map Lpsi_interior back to grid\n    Lpsi_grid = np.zeros((NR, NZ), dtype=float)\n    for i in range(1, NR - 1):\n        for j in range(1, NZ - 1):\n            idx = interior_index(i, j, NZ_interior)\n            Lpsi_grid[i, j] = Lpsi_interior[idx]\n    j_plasma = np.zeros_like(Lpsi_grid)\n    # Avoid divide by zero at R=0 (not in domain)\n    j_plasma[1:NR-1, 1:NZ-1] = -(1.0 / (mu0 * RR[1:NR-1, 0][:, None])) * Lpsi_grid[1:NR-1, 1:NZ-1] - jcoil[1:NR-1, 1:NZ-1]\n    # Integrate over plasma region to get Ip\n    Ip = float(np.sum(j_plasma * chi) * dR * dZ)\n\n    return residual_max, Ip\n\ndef solve():\n    # Define grid and matrix\n    R_min, R_max = 1.0, 3.0\n    Z_min, Z_max = -1.0, 1.0\n    NR, NZ = 81, 81\n    R, Z, dR, dZ = build_grid(R_min, R_max, Z_min, Z_max, NR, NZ)\n    A = assemble_matrix(R, dR, dZ, NR, NZ)\n\n    # Define test cases\n    test_cases = [\n        # Test case 1\n        {\n            'pprime': -1.0e6,  # Pa/Wb\n            'plasma_center': (2.0, 0.0),\n            'plasma_axes': (0.5, 0.3),\n            'coils': [(3.0, 0.6, 1.0e6)],\n            'sigma_R': 0.02,\n            'sigma_Z': 0.02\n        },\n        # Test case 2\n        {\n            'pprime': -1.0e6,\n            'plasma_center': (2.0, 0.0),\n            'plasma_axes': (0.5, 0.3),\n            'coils': [(3.0, 0.6, 1.0e6), (3.0, -0.6, 1.0e6)],\n            'sigma_R': 0.02,\n            'sigma_Z': 0.02\n        },\n        # Test case 3 (vacuum, no plasma)\n        {\n            'pprime': 0.0,\n            'plasma_center': (2.0, 0.0),\n            'plasma_axes': (0.0, 0.0),  # no plasma\n            'coils': [(3.0, 0.6, 1.0e6), (3.0, -0.6, 1.0e6)],\n            'sigma_R': 0.02,\n            'sigma_Z': 0.02\n        },\n        # Test case 4 (tiny plasma)\n        {\n            'pprime': -2.0e6,\n            'plasma_center': (2.0, 0.0),\n            'plasma_axes': (0.15, 0.10),\n            'coils': [(3.0, 0.6, 0.5e6), (3.0, -0.6, 0.5e6)],\n            'sigma_R': 0.02,\n            'sigma_Z': 0.02\n        }\n    ]\n\n    grid = (R, Z, dR, dZ)\n    results = []\n    for case in test_cases:\n        residual_max, Ip = solve_case(case, grid, A)\n        results.append([residual_max, Ip])\n\n    # Final print statement in the exact required format.\n    # Ensure simple float string formatting without extra text\n    def format_list(lst):\n        return \"[\" + \",\".join(str(x) if not isinstance(x, list) else format_list(x) for x in lst) + \"]\"\n    print(format_list(results))\n\nsolve()\n```"
        },
        {
            "introduction": "A calculated equilibrium is often inherently unstable and requires active feedback to be sustained. This final exercise moves from static analysis to dynamic simulation, a critical step in understanding real-world tokamak operation. You will build and solve a system of coupled ordinary differential equations that models the plasma's vertical motion, the response of control coil circuits, and a feedback control law, providing insight into the challenges of plasma position control .",
            "id": "4056106",
            "problem": "Consider an axisymmetric tokamak free-boundary configuration in which the plasma column centroid is modeled as a thin toroidal current ring of major radius $R_p$ carrying plasma current $I_p$. Two identical Poloidal Field (PF) control coils are modeled as thin circular filaments, each of radius $a$, located at vertical positions $z_0=+z_c$ and $z_0=-z_c$, respectively. Each PF coil is driven by a voltage source and obeys the lumped circuit equation $V=L\\,\\dot I + R\\,I$, where $L$ is the coil self-inductance, $R$ is the coil resistance, $I$ is the coil current, and $V$ is the applied voltage. The plasma centroid vertical dynamics is modeled as a single-degree-of-freedom translational equation with effective inertia and passive stabilization, dynamically coupled to the PF-produced magnetic field via the Lorentz force.\n\nFundamental bases and model assumptions:\n- By the Biot–Savart law and Ampère’s law, the magnetic field generated by a circular filament of radius $a$ and current $I$ at a general point $(r,z)$ in cylindrical coordinates is axisymmetric and has radial component $B_r(r,z)$ given by the well-tested complete elliptic integral form:\n$$\nk^2 = \\frac{4 a r}{(a+r)^2 + (z-z_0)^2},\\quad K=K(k^2),\\quad E=E(k^2),\n$$\n$$\nB_r(r,z) = \\frac{\\mu_0 I (z-z_0)}{2\\pi r \\sqrt{(a+r)^2 + (z-z_0)^2}}\\left( -K + \\frac{a^2 + r^2 + (z-z_0)^2}{(a-r)^2 + (z-z_0)^2} E \\right),\n$$\nwhere $\\mu_0$ is the permeability of free space, $K(\\cdot)$ and $E(\\cdot)$ are complete elliptic integrals of the first and second kind.\n- The net vertical Lorentz force coupling a toroidal current ring to the external poloidal magnetic field is obtained from $\\mathrm{d}\\boldsymbol{F} = I_p\\,\\mathrm{d}\\boldsymbol{\\ell} \\times \\boldsymbol{B}$, with $\\mathrm{d}\\boldsymbol{\\ell}$ along the toroidal direction. Integrating around the ring yields\n$$\nF_z = I_p (2\\pi R_p)\\,B_r(R_p, z_p),\n$$\nwhere $z_p$ is the vertical position of the plasma centroid and $B_r(R_p,z_p)$ is the total radial magnetic field at the plasma ring location due to all external currents.\n- The plasma vertical dynamics follows Newton’s second law with passive stabilization modeled as linear stiffness and damping:\n$$\nm\\,\\ddot z_p + c\\,\\dot z_p + K\\,z_p = I_p (2\\pi R_p)\\,B_r^{\\mathrm{tot}}(R_p, z_p),\n$$\nwhere $m$ is the effective inertia, $c$ is damping, $K$ is net stiffness (which may be negative if the intrinsic vertical instability exceeds passive stabilization), and $B_r^{\\mathrm{tot}}$ is the superposition of the PF coils’ contributions.\n- Each PF coil current obeys the lumped circuit model:\n$$\n\\dot I_j = \\frac{V_j - R_c I_j}{L_c},\\quad j\\in\\{1,2\\},\n$$\nwhere $L_c$ and $R_c$ are the coil inductance and resistance, and $V_j$ is the applied voltage, bounded by a saturation $|V_j|\\le V_{\\max}$.\n- A simple proportional–derivative–integral control law acts on the position error $e=z_p - z_{\\mathrm{ref}}$ to select coil voltages. To distribute control effort between the two coils consistently with their magnetic-field sensitivities, define the PF coil sensitivities at the reference position $z_{\\mathrm{ref}}$:\n$$\ns_j = \\left.\\frac{\\partial B_r^{(j)}(R_p,z)}{\\partial I_j}\\right|_{z=z_{\\mathrm{ref}}} = B_r^{(j)}(R_p,z_{\\mathrm{ref}})\\ \\text{with}\\ I_j=1\\,\\mathrm{A},\n$$\nwhere $B_r^{(j)}$ is the radial field produced by coil $j$ alone. The controller sets\n$$\nV_j(t) = \\operatorname{sat}\\left( -K_p\\,s_j\\, e(t) - K_d\\,s_j\\, \\dot z_p(t) - K_i\\,s_j\\, \\int_0^t e(\\tau)\\,\\mathrm{d}\\tau,\\ V_{\\max}\\right),\n$$\nwith $\\operatorname{sat}(x,V_{\\max})=\\max(-V_{\\max},\\min(V_{\\max},x))$.\n\nYou must implement a program that:\n1. Computes $B_r(R_p,z)$ via the elliptic-integral formula for each PF coil and sums to form $B_r^{\\mathrm{tot}}(R_p,z)$.\n2. Integrates the coupled ordinary differential equations for $(z_p,\\dot z_p,I_1,I_2)$ and the controller integral state over a prescribed time interval using a fixed test suite.\n3. Reports specific quantitative measures for each test case: final displacement $z_{\\mathrm{end}}$ in $\\mathrm{m}$, peak absolute displacement $z_{\\mathrm{peak}}$ in $\\mathrm{m}$, and integral of squared error $\\int_0^{T}(z_p(t)-z_{\\mathrm{ref}})^2\\,\\mathrm{d}t$ in $\\mathrm{m}^2\\cdot \\mathrm{s}$.\n\nAngles do not appear; no angle unit specification is required. Physical units must be respected exactly as indicated above.\n\nTest suite:\nUse the following three parameter sets, representing a general case, a voltage-limited case, and an uncontrolled unstable case. For all cases, use $\\mu_0 = 4\\pi\\times 10^{-7}\\,\\mathrm{H/m}$ and $z_{\\mathrm{ref}}=0\\,\\mathrm{m}$.\n\n- Case $1$ (nominal control):\n    - PF coils: $L_c=0.20\\,\\mathrm{H}$, $R_c=0.50\\,\\Omega$, $a=2.20\\,\\mathrm{m}$, $z_c=0.70\\,\\mathrm{m}$, $V_{\\max}=500\\,\\mathrm{V}$.\n    - Plasma: $I_p=1.0\\times 10^6\\,\\mathrm{A}$, $R_p=1.60\\,\\mathrm{m}$, $m=1.00\\times 10^4\\,\\mathrm{kg}$, $c=5.00\\times 10^4\\,\\mathrm{N\\cdot s/m}$, $K=2.00\\times 10^4\\,\\mathrm{N/m}$, initial $z_p(0)=0.050\\,\\mathrm{m}$, $\\dot z_p(0)=0\\,\\mathrm{m/s}$.\n    - Controller gains: $K_p=8.00\\times 10^{10}$, $K_d=1.00\\times 10^{10}$, $K_i=0$, simulation horizon $T=0.30\\,\\mathrm{s}$.\n\n- Case $2$ (voltage-limited, larger initial error):\n    - PF coils: $L_c=0.20\\,\\mathrm{H}$, $R_c=0.50\\,\\Omega$, $a=2.20\\,\\mathrm{m}$, $z_c=0.70\\,\\mathrm{m}$, $V_{\\max}=150\\,\\mathrm{V}$.\n    - Plasma: $I_p=1.0\\times 10^6\\,\\mathrm{A}$, $R_p=1.60\\,\\mathrm{m}$, $m=1.00\\times 10^4\\,\\mathrm{kg}$, $c=5.00\\times 10^4\\,\\mathrm{N\\cdot s/m}$, $K=2.00\\times 10^4\\,\\mathrm{N/m}$, initial $z_p(0)=0.080\\,\\mathrm{m}$, $\\dot z_p(0)=0\\,\\mathrm{m/s}$.\n    - Controller gains: $K_p=6.00\\times 10^{10}$, $K_d=1.00\\times 10^{10}$, $K_i=0$, simulation horizon $T=0.30\\,\\mathrm{s}$.\n\n- Case $3$ (uncontrolled unstable):\n    - PF coils: $L_c=0.20\\,\\mathrm{H}$, $R_c=0.50\\,\\Omega$, $a=2.20\\,\\mathrm{m}$, $z_c=0.70\\,\\mathrm{m}$, $V_{\\max}=0\\,\\mathrm{V}$.\n    - Plasma: $I_p=1.0\\times 10^6\\,\\mathrm{A}$, $R_p=1.60\\,\\mathrm{m}$, $m=1.00\\times 10^4\\,\\mathrm{kg}$, $c=2.00\\times 10^4\\,\\mathrm{N\\cdot s/m}$, $K=-1.00\\times 10^4\\,\\mathrm{N/m}$, initial $z_p(0)=0.050\\,\\mathrm{m}$, $\\dot z_p(0)=0\\,\\mathrm{m/s}$.\n    - Controller gains: $K_p=0$, $K_d=0$, $K_i=0$, simulation horizon $T=0.20\\,\\mathrm{s}$.\n\nOutput specification:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, output three floats in the order $[z_{\\mathrm{end}},z_{\\mathrm{peak}},\\int_0^{T}(z_p(t)-z_{\\mathrm{ref}})^2\\,\\mathrm{d}t]$, expressed in $\\mathrm{m}$, $\\mathrm{m}$, and $\\mathrm{m}^2\\cdot \\mathrm{s}$, respectively. Aggregate all three test cases sequentially into one flat list. For example, the final output format must be $[r_1,r_2,\\dots,r_9]$ where $r_1,r_2,r_3$ correspond to Case $1$, $r_4,r_5,r_6$ to Case $2$, and $r_7,r_8,r_9$ to Case $3$.",
            "solution": "The user-provided problem has been analyzed and validated against the specified criteria.\n\n### Step 1: Extract Givens\n- **Magnetic Field Formula**: The radial magnetic field $B_r$ from a circular filament of radius $a$, current $I$, at position $(r,z)$ relative to the coil center at $z_0$ is given by\n$$\nk^2 = \\frac{4 a r}{(a+r)^2 + (z-z_0)^2}\n$$\n$$\nB_r(r,z) = \\frac{\\mu_0 I (z-z_0)}{2\\pi r \\sqrt{(a+r)^2 + (z-z_0)^2}}\\left( -K(k^2) + \\frac{a^2 + r^2 + (z-z_0)^2}{(a-r)^2 + (z-z_0)^2} E(k^2) \\right)\n$$\nwhere $K$ and $E$ are complete elliptic integrals of the first and second kind.\n- **Lorentz Force**: $F_z = I_p (2\\pi R_p)\\,B_r(R_p, z_p)$.\n- **Plasma Dynamics**: $m\\,\\ddot z_p + c\\,\\dot z_p + K\\,z_p = F_z$, where $F_z$ is from the total external field $B_r^{\\mathrm{tot}}$.\n- **Coil Circuit**: $\\dot I_j = (V_j - R_c I_j)/L_c$ for two coils $j \\in \\{1,2\\}$.\n- **Controller Law**: $V_j(t) = \\operatorname{sat}( -K_p s_j e(t) - K_d s_j \\dot z_p(t) - K_i s_j \\int_0^t e(\\tau)\\,\\mathrm{d}\\tau, V_{\\max})$, with error $e = z_p - z_{\\mathrm{ref}}$ and sensitivity $s_j = B_r^{(j)}(R_p,z_{\\mathrm{ref}})$ with unit current.\n- **Constants**: $\\mu_0 = 4\\pi\\times 10^{-7}\\,\\mathrm{H/m}$, $z_{\\mathrm{ref}}=0\\,\\mathrm{m}$.\n- **Test Cases**: Three distinct parameter sets are provided, specifying coil parameters ($L_c, R_c, a, z_c, V_{\\max}$), plasma parameters ($I_p, R_p, m, c, K$), initial conditions ($z_p(0), \\dot z_p(0)$), controller gains ($K_p, K_d, K_i$), and simulation time $T$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is based on fundamental principles of electromagnetism (Biot-Savart law), mechanics (Newton's second law), circuit theory, and control theory as applied to tokamak plasma physics. The model is a standard simplified representation for vertical stability analysis. The provided parameters are physically plausible. It is scientifically sound.\n- **Well-Posed**: The problem is formulated as an initial value problem for a system of coupled ordinary differential equations (ODEs). The initial state is fully specified (with the natural assumption of zero initial coil currents and zero initial error integral), and all parameters are defined. A unique solution exists and can be found with standard numerical methods. It is well-posed.\n- **Objective**: The problem is stated with precise mathematical equations and quantitative data. There is no subjective, ambiguous, or unverifiable content.\n- **Completeness and Consistency**: The problem is self-contained. All necessary formulas, parameters, and conditions are provided. There are no contradictions.\n\n### Step 3: Verdict and Action\nThe problem is valid. A reasoned solution will be provided.\n\n### Principle-Based Design\nThe problem requires the simulation of a closed-loop control system governing the vertical position of a tokamak plasma. The solution involves formulating and numerically integrating a system of coupled ordinary differential equations (ODEs) that model the system's dynamics.\n\n**1. System Formulation**\nThe state of the system is described by a state vector $Y(t)$ comprising the plasma's vertical position and velocity, the currents in the two poloidal field (PF) coils, and the time integral of the position error.\n$$\nY(t) = \\begin{bmatrix} z_p(t) \\\\ v_p(t) \\\\ I_1(t) \\\\ I_2(t) \\\\ E_i(t) \\end{bmatrix}\n$$\nwhere $z_p$ is the plasma position, $v_p = \\dot{z}_p$ is the plasma velocity, $I_1$ and $I_2$ are the currents in the upper and lower PF coils, respectively, and $E_i(t) = \\int_0^t (z_p(\\tau)-z_{\\mathrm{ref}})\\,\\mathrm{d}\\tau$ is the integral of the position error.\n\nThe time evolution of the system is governed by a system of first-order ODEs, $\\dot{Y}(t) = f(t, Y(t))$, defined as follows:\n$$\n\\dot{Y} = \\begin{bmatrix} \\dot{z}_p \\\\ \\dot{v}_p \\\\ \\dot{I}_1 \\\\ \\dot{I}_2 \\\\ \\dot{E}_i \\end{bmatrix} = \\begin{bmatrix} v_p \\\\ \\frac{1}{m}(F_z - c v_p - K z_p) \\\\ \\frac{1}{L_c}(V_1 - R_c I_1) \\\\ \\frac{1}{L_c}(V_2 - R_c I_2) \\\\ z_p - z_{\\mathrm{ref}} \\end{bmatrix}\n$$\n\n**2. Component Models and Coupling**\nThe components of the ODE system are derived from physical principles:\n\n- **Plasma Dynamics**: The second equation, for $\\dot{v}_p = \\ddot{z}_p$, is a direct application of Newton's second law, $m\\ddot{z}_p = F_{\\text{net}}$. The net force includes the external control force $F_z$ and the passive stabilization forces modeled as damping ($-c\\dot{z}_p$) and stiffness ($-Kz_p$). The control force is the vertical Lorentz force, $F_z = I_p (2\\pi R_p) B_r^{\\mathrm{tot}}$, exerted on the plasma current ring by the total radial magnetic field $B_r^{\\mathrm{tot}}$ from the PF coils.\n\n- **Magnetic Field Calculation**: The total field $B_r^{\\mathrm{tot}}$ at the plasma's location $(R_p, z_p)$ is the superposition of the fields from the upper coil (current $I_1$, position $z_c$) and the lower coil (current $I_2$, position $-z_c$).\n$$\nB_r^{\\mathrm{tot}}(R_p, z_p) = B_r(R_p, z_p; I_1, a, z_c) + B_r(R_p, z_p; I_2, a, -z_c)\n$$\nEach $B_r$ component is calculated using the provided formula derived from the Biot-Savart law, which involves complete elliptic integrals of the first and second kind, $K(k^2)$ and $E(k^2)$. These are computed using `scipy.special.ellipk` and `scipy.special.ellipe`.\n\n- **Coil and Controller Dynamics**: The third and fourth equations for $\\dot{I}_1$ and $\\dot{I}_2$ represent the lumped-parameter circuit model for each coil, $L_c \\dot{I} + R_c I = V$. The applied voltages $V_1$ and $V_2$ are determined by a Proportional-Derivative-Integral (PID) control law. The control action is proportional to the error $e=z_p-z_{\\mathrm{ref}}$, its derivative $\\dot{e}=\\dot{z}_p$, and its integral $E_i$. The gains ($K_p, K_d, K_i$) are scaled by coil-specific magnetic sensitivities, $s_j$. These sensitivities are calculated once per case as the radial field produced by coil $j$ at the reference position $z_{\\mathrm{ref}}=0$ with a unit current of $1\\,\\mathrm{A}$. The resulting voltages are subject to saturation at $\\pm V_{\\max}$.\n\n- **Integral State**: The fifth equation, $\\dot{E}_i = z_p - z_{\\mathrm{ref}}$, simply defines the evolution of the integral error term used by the controller.\n\n**3. Numerical Solution Strategy**\nThe solution is obtained by numerically integrating the ODE system from an initial state over a specified time horizon.\n\n- **Algorithm**: The core of the algorithm is the `scipy.integrate.solve_ivp` function, a robust numerical ODE solver.\n- **Initialization**: For each test case, the corresponding parameters are used. The initial state vector is set to $Y(0)=[z_p(0), \\dot{z}_p(0), 0, 0, 0]^T$, reflecting the given initial plasma state and assuming the coils and controller integral start at zero.\n- **Execution**: The solver is called with the ODE system function, the time interval $[0, T]$, and the initial state. The solution is evaluated at a fine grid of time points to ensure accurate calculation of the output metrics.\n\n**4. Output Metrics Calculation**\nFrom the time-dependent solution for the plasma position, $z_p(t)$, the required performance metrics are computed for each case:\n- **Final Displacement ($z_{\\mathrm{end}}$)**: The value of $z_p$ at the end of the simulation, $z_p(T)$.\n- **Peak Absolute Displacement ($z_{\\mathrm{peak}}$)**: The maximum absolute value of $z_p(t)$ over the entire simulation interval, $\\max_{t \\in [0,T]} |z_p(t)|$.\n- **Integral of Squared Error (ISE)**: The time integral of the squared deviation from the reference, $\\int_0^T (z_p(t) - z_{\\mathrm{ref}})^2 dt$. This is calculated numerically from the discrete solution points using Simpson's rule via `scipy.integrate.simpson`.\n\nThis integrated approach, combining physical models with a standard numerical solution method, provides a complete and verifiable solution to the posed problem.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import ellipk, ellipe\nfrom scipy.integrate import solve_ivp, simpson\n\ndef solve():\n    \"\"\"\n    Solves the tokamak plasma vertical stability control problem for three test cases.\n    \"\"\"\n    MU0 = 4 * np.pi * 1e-7\n\n    def B_r_field(r, z, I, coil_a, coil_z0):\n        \"\"\"\n        Calculates the radial magnetic field Br of a circular filament.\n        \"\"\"\n        if r == 0:\n            return 0.0\n\n        z_diff = z - coil_z0\n        z_diff2 = z_diff**2\n\n        k2_den = (coil_a + r)**2 + z_diff2\n        if k2_den == 0:\n            return 0.0\n        k2_num = 4 * coil_a * r\n        k2 = k2_num / k2_den\n\n        # scipy.special elliptic integrals use the parameter m = k^2\n        K_val = ellipk(k2)\n        E_val = ellipe(k2)\n\n        term1_den = 2 * np.pi * r * np.sqrt(k2_den)\n        if term1_den == 0:\n            return 0.0\n        term1 = (MU0 * I * z_diff) / term1_den\n\n        term2_den = (coil_a - r)**2 + z_diff2\n        if term2_den == 0:\n            # This singularity occurs if the evaluation point is on the filament.\n            # The problem parameters ensure this does not happen.\n            return np.inf * np.sign(term1) if term1 != 0 else 0.0\n        \n        term2_num = coil_a**2 + r**2 + z_diff2\n        term2 = -K_val + (term2_num / term2_den) * E_val\n        \n        return term1 * term2\n\n    def run_simulation(case_params):\n        \"\"\"\n        Runs the simulation for a single test case.\n        \"\"\"\n        # Unpack parameters\n        Lc, Rc, a, zc, Vmax = case_params['PF_coils']\n        Ip, Rp, m, c, K_stiffness = case_params['plasma']\n        z0_initial, v0_initial = case_params['initial_conditions']\n        Kp, Kd, Ki = case_params['controller_gains']\n        T = case_params['T']\n        z_ref = case_params['z_ref']\n\n        # Pre-calculate sensitivities\n        s1 = B_r_field(Rp, z_ref, 1.0, a, zc)\n        s2 = B_r_field(Rp, z_ref, 1.0, a, -zc)\n\n        def ode_system(t, y):\n            zp, vp, I1, I2, Ei = y\n            \n            # Total radial magnetic field at plasma position\n            Br1 = B_r_field(Rp, zp, I1, a, zc)\n            Br2 = B_r_field(Rp, zp, I2, a, -zc)\n            Br_tot = Br1 + Br2\n            \n            # Vertical Lorentz force\n            Fz = Ip * 2 * np.pi * Rp * Br_tot\n            \n            # Control law\n            e = zp - z_ref\n            V1_unsat = -Kp * s1 * e - Kd * s1 * vp - Ki * s1 * Ei\n            V2_unsat = -Kp * s2 * e - Kd * s2 * vp - Ki * s2 * Ei\n            \n            V1 = np.clip(V1_unsat, -Vmax, Vmax)\n            V2 = np.clip(V2_unsat, -Vmax, Vmax)\n            \n            # System dynamics\n            dzp_dt = vp\n            dvp_dt = (Fz - c * vp - K_stiffness * zp) / m\n            dI1_dt = (V1 - Rc * I1) / Lc\n            dI2_dt = (V2 - Rc * I2) / Lc\n            dEi_dt = e\n            \n            return [dzp_dt, dvp_dt, dI1_dt, dI2_dt, dEi_dt]\n\n        # Initial state vector: [zp, vp, I1, I2, Ei]\n        y0 = [z0_initial, v0_initial, 0.0, 0.0, 0.0]\n        t_span = [0, T]\n        \n        # Evaluate at enough points for accurate post-processing\n        t_eval = np.linspace(t_span[0], t_span[1], 2000)\n        \n        # Solve the ODE system\n        sol = solve_ivp(ode_system, t_span, y0, method='RK45', t_eval=t_eval)\n        \n        zp_t = sol.y[0]\n        t_t = sol.t\n\n        z_end = zp_t[-1]\n        z_peak = np.max(np.abs(zp_t))\n        ise = simpson((zp_t - z_ref)**2, t_t)\n        \n        return z_end, z_peak, ise\n\n    test_cases = [\n        { # Case 1\n            'PF_coils': (0.20, 0.50, 2.20, 0.70, 500.0),\n            'plasma': (1.0e6, 1.60, 1.0e4, 5.0e4, 2.0e4),\n            'initial_conditions': (0.050, 0.0),\n            'controller_gains': (8.0e10, 1.0e10, 0),\n            'T': 0.30, 'z_ref': 0.0\n        },\n        { # Case 2\n            'PF_coils': (0.20, 0.50, 2.20, 0.70, 150.0),\n            'plasma': (1.0e6, 1.60, 1.0e4, 5.0e4, 2.0e4),\n            'initial_conditions': (0.080, 0.0),\n            'controller_gains': (6.0e10, 1.0e10, 0),\n            'T': 0.30, 'z_ref': 0.0\n        },\n        { # Case 3\n            'PF_coils': (0.20, 0.50, 2.20, 0.70, 0.0),\n            'plasma': (1.0e6, 1.60, 1.0e4, 2.0e4, -1.0e4),\n            'initial_conditions': (0.050, 0.0),\n            'controller_gains': (0, 0, 0),\n            'T': 0.20, 'z_ref': 0.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        metrics = run_simulation(case)\n        results.extend(metrics)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}