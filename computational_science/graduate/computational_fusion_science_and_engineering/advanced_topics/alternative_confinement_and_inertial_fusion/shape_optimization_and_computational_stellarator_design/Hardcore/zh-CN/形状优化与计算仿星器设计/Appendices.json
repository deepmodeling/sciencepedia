{
    "hands_on_practices": [
        {
            "introduction": "理解仿星器复杂的三维形状，首先要掌握其几何描述方法。本练习从谱（傅里叶）表示出发，让您亲手计算磁通面的基本属性，如度规张量和磁力线路径，从而获得直接的实践经验。通过完成这项任务，您将掌握一项核心技能：将抽象的数学边界描述转化为具体的、具有物理意义的几何量。",
            "id": "4044780",
            "problem": "给定一个简化的、类真空的仿星器平衡模型，其中存在嵌套的磁通量面，并由磁通量标签 $\\psi$ 标记。在任意固定的磁通量面 $\\psi=\\psi_0$ 上，引入直磁力线坐标 $(\\theta,\\zeta)$，分别解释为角向角和环向角（单位为弧度）。一个光滑、闭合的磁通量面在柱坐标 $(R,\\phi,Z)$ 中用谱方法表示为\n$$\nR(\\theta,\\zeta) \\;=\\; R_0 \\;+\\; \\sum_{m,n} R_{m n} \\cos\\!\\big(m\\,\\theta - n\\,\\zeta\\big),\n\\qquad\nZ(\\theta,\\zeta) \\;=\\; \\sum_{m,n} Z_{m n} \\sin\\!\\big(m\\,\\theta - n\\,\\zeta\\big),\n$$\n其中几何环向角定义为 $\\phi=\\zeta$。笛卡尔位置矢量为\n$$\n\\mathbf{r}(\\theta,\\zeta) \\;=\\; \\big( R(\\theta,\\zeta)\\cos\\zeta,\\; R(\\theta,\\zeta)\\sin\\zeta,\\; Z(\\theta,\\zeta) \\big).\n$$\n定义曲面上的协变基矢为 $\\mathbf{e}_\\theta=\\partial\\mathbf{r}/\\partial\\theta$ 和 $\\mathbf{e}_\\zeta=\\partial\\mathbf{r}/\\partial\\zeta$，导出的曲面度规系数为\n$$\ng_{\\theta\\theta} \\;=\\; \\mathbf{e}_\\theta\\cdot\\mathbf{e}_\\theta,\\quad\ng_{\\theta\\zeta} \\;=\\; \\mathbf{e}_\\theta\\cdot\\mathbf{e}_\\zeta,\\quad\ng_{\\zeta\\zeta} \\;=\\; \\mathbf{e}_\\zeta\\cdot\\mathbf{e}_\\zeta.\n$$\n假设曲面上的磁场具有以下形式的 Clebsch 表示\n$$\n\\mathbf{B} \\;=\\; \\nabla\\psi \\times \\nabla\\alpha(\\theta,\\zeta),\\qquad \\alpha(\\theta,\\zeta) \\;=\\; \\theta \\;-\\; N\\,\\zeta,\n$$\n其中 $N$ 是给定的整数场周期性。请仅以上述内容为基本出发点。\n\n任务：\n\n$1.$ 从谱映射 $\\mathbf{r}(\\theta,\\zeta)$ 出发，通过对 $R(\\theta,\\zeta)$ 和 $Z(\\theta,\\zeta)$ 关于 $\\theta$ 和 $\\zeta$ 进行显式微分，推导并计算在指定 $(\\theta,\\zeta)$ 点的度规系数 $g_{ij}$。\n\n$2.$ 使用磁场表示 $\\mathbf{B}=\\nabla\\psi\\times\\nabla\\alpha$（其中 $\\alpha=\\theta-N\\zeta$），根据 $(\\theta,\\zeta)$ 中的局部磁力线斜率，推导曲面上旋转变换 $\\iota(\\psi)$ 的表达式并计算其值。定义磁力线螺距 $p$ 为 $p=d\\zeta/d\\theta$，并用 $\\iota(\\psi)$ 表示 $p$。\n\n$3.$ 在曲面上，线元满足 $ds^2 = g_{\\theta\\theta}\\,d\\theta^2 + 2 g_{\\theta\\zeta}\\,d\\theta\\,d\\zeta + g_{\\zeta\\zeta}\\,d\\zeta^2$。沿磁力线，微分量遵循您在任务2中得到的关系。利用此关系，在指定点处计算 $ds/d\\zeta$ 的值。\n\n所有角度必须以弧度为单位。所有长度必须以米为单位，且 $ds/d\\zeta$ 必须以米/弧度为单位报告。旋转变换 $\\iota(\\psi)$ 和螺距 $p$ 是无量纲的。您的程序必须为以下磁通量面和角度样本的测试套件计算所要求的量。\n\n测试套件：\n\n情况1：\n- $R_0 = 1.50\\ \\mathrm{m}$,\n- $R_{10} = 0.20\\ \\mathrm{m}$, $R_{11} = 0.05\\ \\mathrm{m}$,\n- $Z_{10} = 0.18\\ \\mathrm{m}$, $Z_{21} = 0.03\\ \\mathrm{m}$,\n- $N = 1$,\n- 在 $(\\theta,\\zeta)$ 等于 $(0.0,0.0)$、$(\\pi/3,\\ \\pi/7)$ 和 $(2.0,\\ 1.0)$ 处进行计算。\n\n情况2：\n- $R_0 = 1.00\\ \\mathrm{m}$,\n- $R_{20} = 0.10\\ \\mathrm{m}$, $R_{12} = 0.04\\ \\mathrm{m}$, $R_{01} = 0.02\\ \\mathrm{m}$,\n- $Z_{11} = 0.06\\ \\mathrm{m}$, $Z_{21} = 0.03\\ \\mathrm{m}$, $Z_{02} = 0.01\\ \\mathrm{m}$,\n- $N = 2$,\n- 在 $(\\theta,\\zeta)$ 等于 $(0.0,0.0)$、$(\\pi/3,\\ \\pi/7)$ 和 $(2.0,\\ 1.0)$ 处进行计算。\n\n情况3：\n- $R_0 = 1.20\\ \\mathrm{m}$,\n- $R_{10} = 0.15\\ \\mathrm{m}$, $R_{32} = 0.02\\ \\mathrm{m}$, $R_{21} = 0.04\\ \\mathrm{m}$,\n- $Z_{10} = 0.12\\ \\mathrm{m}$, $Z_{13} = 0.02\\ \\mathrm{m}$, $Z_{31} = 0.015\\ \\mathrm{m}$,\n- $N = 3$,\n- 在 $(\\theta,\\zeta)$ 等于 $(0.0,0.0)$、$(\\pi/3,\\ \\pi/7)$ 和 $(2.0,\\ 1.0)$ 处进行计算。\n\n实现要求：\n\n- 对于每种情况，计算：\n  - $\\iota(\\psi)$,\n  - $p$,\n  - 在三个指定的 $(\\theta,\\zeta)$ 点处，使用 $d\\theta$ 和 $d\\zeta$ 之间的磁力线关系计算 $ds/d\\zeta$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每种情况应按 $[\\iota(\\psi),\\ p,\\ (ds/d\\zeta)_{\\text{点1}},\\ (ds/d\\zeta)_{\\text{点2}},\\ (ds/d\\zeta)_{\\text{点3}}]$ 的顺序贡献一个子列表，最终输出必须是这三个子列表的列表，例如 $[[a_1,a_2,a_3,a_4,a_5],[b_1,b_2,b_3,b_4,b_5],[c_1,c_2,c_3,c_4,c_5]]$。所有数值条目在适用时必须是单位为米/弧度的浮点数，否则为无量纲浮点数。不应打印任何额外文本。",
            "solution": "该问题要求对由谱表示定义的仿星器磁通量面进行几何分析。我们的任务是推导并计算几个关键量：曲面的度规张量、旋转变换、磁力线螺距以及沿磁力线的微分弧长。\n\n解决方案分三个阶段进行，对应于问题陈述中概述的三个任务。首先，我们推导度规张量分量的解析表达式。其次，我们根据给定的磁场结构确定旋转变换和磁力线螺距。第三，我们结合这些结果来求取沿磁力线的弧长变化率。\n\n### 任务1：度规张量计算\n\n磁通量面上一点的位置矢量 $\\mathbf{r}$ 在笛卡尔坐标系中表示为：\n$$\n\\mathbf{r}(\\theta,\\zeta) = \\big( R(\\theta,\\zeta)\\cos\\zeta,\\; R(\\theta,\\zeta)\\sin\\zeta,\\; Z(\\theta,\\zeta) \\big)\n$$\n其中 $R(\\theta,\\zeta)$ 和 $Z(\\theta,\\zeta)$ 由其傅里叶级数定义。\n\n协变基矢 $\\mathbf{e}_\\theta$ 和 $\\mathbf{e}_\\zeta$ 是 $\\mathbf{r}$ 关于曲面坐标 $\\theta$ 和 $\\zeta$ 的偏导数。令 $R_\\theta = \\partial R/\\partial\\theta$、$R_\\zeta = \\partial R/\\partial\\zeta$、$Z_\\theta = \\partial Z/\\partial\\theta$ 和 $Z_\\zeta = \\partial Z/\\partial\\zeta$。应用链式法则，我们得到：\n$$\n\\mathbf{e}_\\theta = \\frac{\\partial\\mathbf{r}}{\\partial\\theta} = \\left( \\frac{\\partial R}{\\partial\\theta}\\cos\\zeta, \\frac{\\partial R}{\\partial\\theta}\\sin\\zeta, \\frac{\\partial Z}{\\partial\\theta} \\right) = (R_\\theta \\cos\\zeta, R_\\theta \\sin\\zeta, Z_\\theta)\n$$\n$$\n\\mathbf{e}_\\zeta = \\frac{\\partial\\mathbf{r}}{\\partial\\zeta} = \\left( \\frac{\\partial R}{\\partial\\zeta}\\cos\\zeta - R\\sin\\zeta, \\frac{\\partial R}{\\partial\\zeta}\\sin\\zeta + R\\cos\\zeta, \\frac{\\partial Z}{\\partial\\zeta} \\right) = (R_\\zeta \\cos\\zeta - R \\sin\\zeta, R_\\zeta \\sin\\zeta + R \\cos\\zeta, Z_\\zeta)\n$$\n\n导出度规张量 $g_{ij}$ 的系数是这些基矢的点积：\n$g_{\\theta\\theta} = \\mathbf{e}_\\theta \\cdot \\mathbf{e}_\\theta = (R_\\theta \\cos\\zeta)^2 + (R_\\theta \\sin\\zeta)^2 + Z_\\theta^2 = R_\\theta^2(\\cos^2\\zeta + \\sin^2\\zeta) + Z_\\theta^2 = R_\\theta^2 + Z_\\theta^2$.\n$g_{\\theta\\zeta} = \\mathbf{e}_\\theta \\cdot \\mathbf{e}_\\zeta = R_\\theta\\cos\\zeta(R_\\zeta\\cos\\zeta - R\\sin\\zeta) + R_\\theta\\sin\\zeta(R_\\zeta\\sin\\zeta + R\\cos\\zeta) + Z_\\theta Z_\\zeta = R_\\theta R_\\zeta + Z_\\theta Z_\\zeta$.\n$g_{\\zeta\\zeta} = \\mathbf{e}_\\zeta \\cdot \\mathbf{e}_\\zeta = (R_\\zeta\\cos\\zeta - R\\sin\\zeta)^2 + (R_\\zeta\\sin\\zeta + R\\cos\\zeta)^2 + Z_\\zeta^2 = R^2 + R_\\zeta^2 + Z_\\zeta^2$.\n\n要计算这些，我们需要谱表示的偏导数：\n$$\nR(\\theta,\\zeta) = R_0 + \\sum_{m,n} R_{m n} \\cos(m\\,\\theta - n\\,\\zeta)\n$$\n$$\nZ(\\theta,\\zeta) = \\sum_{m,n} Z_{m n} \\sin(m\\,\\theta - n\\,\\zeta)\n$$\n导数是：\n$$\nR_\\theta(\\theta,\\zeta) = -\\sum_{m,n} m\\,R_{mn} \\sin(m\\,\\theta - n\\,\\zeta)\n$$\n$$\nR_\\zeta(\\theta,\\zeta) = \\sum_{m,n} n\\,R_{mn} \\sin(m\\,\\theta - n\\,\\zeta)\n$$\n$$\nZ_\\theta(\\theta,\\zeta) = \\sum_{m,n} m\\,Z_{mn} \\cos(m\\,\\theta - n\\,\\zeta)\n$$\n$$\nZ_\\zeta(\\theta,\\zeta) = -\\sum_{m,n} n\\,Z_{mn} \\cos(m\\,\\theta - n\\,\\zeta)\n$$\n这些表达式允许在曲面上任意点 $(\\theta, \\zeta)$ 直接计算度规系数。\n\n### 任务2：旋转变换和磁力线螺距\n\n磁场 $\\mathbf{B}$ 以 Clebsch 表示形式给出，为 $\\mathbf{B} = \\nabla\\psi \\times \\nabla\\alpha$，其中 $\\psi$ 是磁通量标签，$\\alpha(\\theta, \\zeta) = \\theta - N\\zeta$。这种表示的一个基本性质是磁力线位于等 $\\psi$ 面（磁通量面）上，也位于等 $\\alpha$ 面上。因此，沿磁力线，微分 $d\\alpha$ 必须为零。\n$$\nd\\alpha = \\frac{\\partial\\alpha}{\\partial\\theta}d\\theta + \\frac{\\partial\\alpha}{\\partial\\zeta}d\\zeta = 0\n$$\n代入 $\\alpha$ 的表达式，我们得到：\n$$\n(1)d\\theta + (-N)d\\zeta = 0 \\quad\\implies\\quad d\\theta = N d\\zeta\n$$\n旋转变换 $\\iota(\\psi)$ 定义为沿磁力线角向角 $\\theta$ 相对于环向角 $\\zeta$ 的变化率。在直磁力线坐标中，这即是斜率 $d\\theta/d\\zeta$。\n$$\n\\iota(\\psi) = \\frac{d\\theta}{d\\zeta} = N\n$$\n问题给出 $N$ 是曲面上的一个常数整数，因此旋转变换是常数且等于 $N$。\n\n磁力线螺距 $p$ 定义为 $(\\theta, \\zeta)$ 平面中磁力线斜率的倒数：\n$$\np = \\frac{d\\zeta}{d\\theta} = \\frac{1}{d\\theta/d\\zeta} = \\frac{1}{\\iota} = \\frac{1}{N}\n$$\n由于测试用例提供的 $N \\ge 1$，螺距 $p$ 是良定义的。\n\n### 任务3：沿磁力线的微分弧长\n\n曲面上微分线元 $ds^2$ 的平方由度规给出：\n$$\nds^2 = g_{\\theta\\theta}\\,d\\theta^2 + 2 g_{\\theta\\zeta}\\,d\\theta\\,d\\zeta + g_{\\zeta\\zeta}\\,d\\zeta^2\n$$\n为了找到沿磁力线的弧长，我们使用在任务2中推导的关系 $d\\theta = N d\\zeta$。将其代入 $ds^2$ 的表达式中：\n$$\nds^2 = g_{\\theta\\theta}(N d\\zeta)^2 + 2 g_{\\theta\\zeta}(N d\\zeta)d\\zeta + g_{\\zeta\\zeta}d\\zeta^2\n$$\n提取公因式 $d\\zeta^2$，我们得到：\n$$\nds^2 = \\left( N^2 g_{\\theta\\theta} + 2N g_{\\theta\\zeta} + g_{\\zeta\\zeta} \\right) d\\zeta^2\n$$\n两边除以 $d\\zeta^2$ 并取平方根，得到沿磁力线弧长相对于环向角 $\\zeta$ 的变化率：\n$$\n\\frac{ds}{d\\zeta} = \\sqrt{N^2 g_{\\theta\\theta} + 2N g_{\\theta\\zeta} + g_{\\zeta\\zeta}}\n$$\n这个量是局部计算的，因为度规系数 $g_{ij}$ 是 $(\\theta, \\zeta)$ 的函数。\n\n### 计算算法\n\n对于每个测试用例，数值实现将按以下步骤进行：\n1.  存储输入参数：$R_0$、$N$、非零 $R_{mn}$ 和 $Z_{mn}$ 系数的字典，以及 $(\\theta, \\zeta)$ 计算点列表。\n2.  计算旋转变换 $\\iota = N$ 和螺距 $p = 1/N$。\n3.  对于每个指定的点 $(\\theta_{pt}, \\zeta_{pt})$：\n    a. 初始化 $R = R_0$，$Z=0$，以及导数 $R_\\theta, R_\\zeta, Z_\\theta, Z_\\zeta$ 为 0。\n    b. 遍历 $R_{mn}$ 和 $Z_{mn}$ 系数集中所有唯一的 $(m,n)$ 模式对。\n    c. 对每个模式 $(m, n)$，计算相位角 $\\phi_{mn} = m\\theta_{pt} - n\\zeta_{pt}$。\n    d. 使用上面推导的公式更新 $R$、$Z$ 及其导数的总和，加上当前模式的贡献。\n    e. 遍历完所有模式后，计算度规分量 $g_{\\theta\\theta} = R_\\theta^2 + Z_\\theta^2$、$g_{\\theta\\zeta} = R_\\theta R_\\zeta + Z_\\theta Z_\\zeta$ 和 $g_{\\zeta\\zeta} = R^2 + R_\\zeta^2 + Z_\\zeta^2$。\n    f. 计算 $\\frac{ds}{d\\zeta} = \\sqrt{N^2 g_{\\theta\\theta} + 2N g_{\\theta\\zeta} + g_{\\zeta\\zeta}}$。\n4.  将该情况的结果组装成一个列表：$[\\iota, p, (ds/d\\zeta)_1, (ds/d\\zeta)_2, (ds/d\\zeta)_3]$。\n5.  收集所有测试用例的列表，并将它们格式化为最终所需的输出字符串。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the stellarator surface geometry problem for a given set of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"R0\": 1.50,\n            \"N\": 1,\n            \"R_coeffs\": {(1, 0): 0.20, (1, 1): 0.05},\n            \"Z_coeffs\": {(1, 0): 0.18, (2, 1): 0.03},\n            \"points\": [(0.0, 0.0), (np.pi/3, np.pi/7), (2.0, 1.0)]\n        },\n        {\n            \"R0\": 1.00,\n            \"N\": 2,\n            \"R_coeffs\": {(2, 0): 0.10, (1, 2): 0.04, (0, 1): 0.02},\n            \"Z_coeffs\": {(1, 1): 0.06, (2, 1): 0.03, (0, 2): 0.01},\n            \"points\": [(0.0, 0.0), (np.pi/3, np.pi/7), (2.0, 1.0)]\n        },\n        {\n            \"R0\": 1.20,\n            \"N\": 3,\n            \"R_coeffs\": {(1, 0): 0.15, (3, 2): 0.02, (2, 1): 0.04},\n            \"Z_coeffs\": {(1, 0): 0.12, (1, 3): 0.02, (3, 1): 0.015},\n            \"points\": [(0.0, 0.0), (np.pi/3, np.pi/7), (2.0, 1.0)]\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        R0 = case[\"R0\"]\n        N = case[\"N\"]\n        R_coeffs = case[\"R_coeffs\"]\n        Z_coeffs = case[\"Z_coeffs\"]\n        points = case[\"points\"]\n\n        # Task 2: Compute rotational transform (iota) and pitch (p)\n        iota = float(N)\n        p = 1.0 / N\n\n        case_results = [iota, p]\n        \n        # Get the unique set of all (m,n) modes for this case\n        all_modes = set(R_coeffs.keys()) | set(Z_coeffs.keys())\n\n        for theta, zeta in points:\n            # Initialize sums for R, Z and their derivatives\n            R, Z = R0, 0.0\n            R_theta, R_zeta = 0.0, 0.0\n            Z_theta, Z_zeta = 0.0, 0.0\n\n            for m, n in all_modes:\n                phase_angle = m * theta - n * zeta\n                cos_phase = np.cos(phase_angle)\n                sin_phase = np.sin(phase_angle)\n                \n                Rmn = R_coeffs.get((m, n), 0.0)\n                Zmn = Z_coeffs.get((m, n), 0.0)\n\n                # Sum for R and Z\n                R += Rmn * cos_phase\n                Z += Zmn * sin_phase\n\n                # Sum for derivatives\n                R_theta -= m * Rmn * sin_phase\n                R_zeta += n * Rmn * sin_phase\n                Z_theta += m * Zmn * cos_phase\n                Z_zeta -= n * Zmn * cos_phase\n\n            # Task 1: Compute metric coefficients\n            g_thetatheta = R_theta**2 + Z_theta**2\n            g_thetazeta = R_theta * R_zeta + Z_theta * Z_zeta\n            g_zetazeta = R**2 + R_zeta**2 + Z_zeta**2\n\n            # Task 3: Compute ds/dzeta along the field line\n            ds_dzeta_sq = N**2 * g_thetatheta + 2 * N * g_thetazeta + g_zetazeta\n            ds_dzeta = np.sqrt(ds_dzeta_sq)\n            \n            case_results.append(ds_dzeta)\n\n        all_results.append(case_results)\n\n    # Format the final output string as specified.\n    result_str = \"[\" + \",\".join([f\"[{','.join(map(str, res))}]\" for res in all_results]) + \"]\"\n    print(result_str)\n\nsolve()\n```"
        },
        {
            "introduction": "现代仿星器设计是一个多目标优化问题，旨在平衡等离子体性能与工程约束。本练习引入了复合目标函数的关键概念，它将用于衡量约束、稳定性和线圈复杂度的指标合并为一个综合品质因数。您将推导出该目标函数的解析梯度，这是高效利用强大的梯度下降算法在庞大的设计空间中进行探索的关键一步。",
            "id": "4044763",
            "problem": "您将获得一个用于仿星器边界形状和线圈组的简化但物理上一致的代理模型，以及一个用于形状优化的复合目标函数。边界形状由柱坐标系中的截断傅里叶级数表示，而线圈则由一个调制圆形环面的标量径向傅里叶级数表示。所有角度均以弧度为单位。您的任务是实现一个完整的程序，根据基本定义推导出复合目标函数及其相对于边界傅里叶系数的梯度，并在指定的测试集上进行计算评估。\n\n基本核心定义：\n\n- 柱坐标系中的边界曲面，其大半径分量由角向角 $\\,\\theta\\,$ 和环向角 $\\,\\zeta\\,$ 的截断傅里叶级数建模，场周期数为 $\\,N_{\\text{fp}}\\,$（场周期数），表示为\n$$\nR(\\theta,\\zeta) = R_0 + \\sum_{(m,n)\\in \\mathcal{M}} a_{m,n}\\,\\cos\\!\\big(m\\,\\theta - n\\,N_{\\text{fp}}\\,\\zeta\\big),\n$$\n以及一个垂直分量\n$$\nZ(\\theta,\\zeta) = \\sum_{(m,n)\\in \\mathcal{M}} b_{m,n}\\,\\sin\\!\\big(m\\,\\theta - n\\,N_{\\text{fp}}\\,\\zeta\\big).\n$$\n边界的优化变量是模式 $\\,\\mathcal{M}\\,$ 的实数傅里叶系数 $\\,a_{m,n}\\,$ 和 $\\,b_{m,n}\\,$。角度 $\\,\\theta\\,$ 和 $\\,\\zeta\\,$ 都是 $\\,2\\pi\\,$ 周期的。\n\n- 线圈中心线被建模为一个角度为 $\\,\\phi\\in[0,2\\pi)\\,$ 的圆形环面，并带有标量径向调制\n$$\nR_{\\text{c}}(\\phi) = R_{\\text{c},0} + \\sum_{k=1}^{K_{\\text{c}}} c_k \\cos(k\\,\\phi),\n$$\n其平面嵌入为\n$$\nx(\\phi) = R_{\\text{c}}(\\phi)\\cos\\phi,\\quad y(\\phi) = R_{\\text{c}}(\\phi)\\sin\\phi,\\quad z(\\phi)=0.\n$$\n线圈平滑度惩罚项通过 $\\,R_{\\text{c}}(\\phi)\\,$ 相对于 $\\,\\phi\\,$ 的二阶导数来作为曲率代理。线圈的优化变量是傅里叶系数 $\\,c_k\\,$。\n\n- 复合目标函数为\n$$\nJ(\\mathbf{a},\\mathbf{b},\\mathbf{c}) = w_{\\epsilon}\\,\\epsilon_{\\text{eff}}(\\mathbf{a},\\mathbf{b}) \\;+\\; w_{\\iota}\\,E_{\\iota}(\\mathbf{a},\\mathbf{b}) \\;+\\; w_{\\text{coil}}\\,S_{\\text{coil}}(\\mathbf{c}),\n$$\n其中 $\\,w_{\\epsilon}>0\\,$, $\\,w_{\\iota}>0\\,$ 和 $\\,w_{\\text{coil}}>0\\,$ 是用户指定的标量权重。\n\n- 有效磁涟波代理由一个二次型定义，该二次型随非轴对称波纹的增加而增加，\n$$\n\\epsilon_{\\text{eff}}(\\mathbf{a},\\mathbf{b}) \\;=\\; \\kappa_{\\epsilon}\\sum_{(m,n)\\in\\mathcal{M}} \\gamma_{m,n}\\,\\big(a_{m,n}^2+b_{m,n}^2\\big),\n$$\n其中\n$$\n\\gamma_{m,n} \\;=\\; \\frac{m^2 + (n\\,N_{\\text{fp}})^2}{A^2},\n$$\n此处 $\\,A>0\\,$ 是一个给定的类环径比标度，$\\,\\kappa_{\\epsilon}>0\\,$ 是一个给定的归一化常数。\n\n- 旋转变换剖面代理 $\\,\\iota(s)\\,$，作为归一化环向磁通坐标 $\\,s\\in[0,1]\\,$ 的函数，定义为\n$$\n\\iota(s) \\;=\\; \\iota_{\\text{base}} \\;+\\; \\sum_{(m,n)\\in\\mathcal{M}} \\Big(\\alpha_{m,n}\\,a_{m,n}\\,s^{m} \\;+\\; \\beta_{m,n}\\,b_{m,n}\\,s^{m+1}\\Big),\n$$\n其中\n$$\n\\alpha_{m,n} \\;=\\; \\frac{\\kappa_R}{1+(n\\,N_{\\text{fp}})^2}\\left(\\frac{m}{R_0}\\right)^2,\\qquad\n\\beta_{m,n} \\;=\\; \\frac{\\kappa_Z}{1+(n\\,N_{\\text{fp}})^2}\\left(\\frac{m}{R_0}\\right).\n$$\n常数 $\\,\\kappa_R>0\\,$ 和 $\\,\\kappa_Z>0\\,$ 在此代理模型中编码了旋转变换对边界形变的线性灵敏度；$\\,R_0>0\\,$ 是大半径标度。目标旋转变换剖面是一个二次多项式\n$$\n\\iota_{\\text{target}}(s) \\;=\\; t_0 + t_1\\,s + t_2\\,s^2,\n$$\n其中 $\\,t_0,t_1,t_2\\,$ 是给定的标量。剖面误差是在 $[0,1]$ 上的平方 $\\,L^2\\,$ 距离，\n$$\nE_{\\iota}(\\mathbf{a},\\mathbf{b}) \\;=\\; \\int_{0}^{1}\\Big(\\iota(s) - \\iota_{\\text{target}}(s)\\Big)^2\\,ds.\n$$\n\n- 线圈平滑度惩罚项通过 $\\,R_{\\text{c}}(\\phi)\\,$ 的二阶导数的平方来定义，\n$$\nS_{\\text{coil}}(\\mathbf{c}) \\;=\\; \\int_{0}^{2\\pi}\\left(\\frac{d^2 R_{\\text{c}}}{d\\phi^2}(\\phi)\\right)^2\\,d\\phi.\n$$\n\n任务：\n\n1. 从以上定义以及三角函数和单项式积分的标准性质出发，推导出复合目标函数 $\\,J(\\mathbf{a},\\mathbf{b},\\mathbf{c})\\,$ 及其相对于每个优化变量 $\\,a_{m,n}\\,$, $\\,b_{m,n}\\,$ 和 $\\,c_k\\,$ 的梯度的显式表达式。仅使用以下恒等式\n$$\n\\int_{0}^{2\\pi}\\cos(k\\phi)\\cos(\\ell\\phi)\\,d\\phi \\;=\\; \\begin{cases}\n\\pi,  k=\\ell\\ge 1,\\\\\n0,  k\\ne \\ell,\n\\end{cases}\n$$\n和\n$$\n\\int_{0}^{1} s^{p}\\,ds \\;=\\; \\frac{1}{p+1},\\quad p>-1,\n$$\n以及积分的线性性质和无二项式的单项式乘积积分\n$$\n\\int_{0}^{1} s^{p+q}\\,ds \\;=\\; \\frac{1}{p+q+1}.\n$$\n\n2. 实现一个程序，对给定的参数和变量集，计算 $\\,J\\,$ 和 $\\,\\nabla J\\,$。对于每个测试用例，程序必须输出一个三元组，包括：\n   - 标量目标函数值 $\\,J\\,$，\n   - 欧几里得范数 $\\,\\|\\nabla J\\|_2\\,$，\n   - 一个布尔值，指示是否在容差 $\\,\\tau=10^{-10}\\,$ 内满足平稳性条件，即 $\\,\\|\\nabla J\\|_2 < \\tau\\,$ 是否成立。\n\n3. 角度 $\\,\\theta\\,$, $\\,\\zeta\\,$ 和 $\\,\\phi\\,$ 以弧度为单位。在此问题中，所有量在所提供的代理标度下都是无量纲的；输出中不需要物理单位。\n\n测试集：\n\n对于每个测试，您会得到 $\\,N_{\\text{fp}}\\,$, $\\,R_0\\,$, $\\,A\\,$, $\\,\\kappa_R\\,$, $\\,\\kappa_Z\\,$, $\\,\\kappa_{\\epsilon}\\,$, 权重 $\\,w_{\\epsilon}\\,$, $\\,w_{\\iota}\\,$, $\\,w_{\\text{coil}}\\,$, 模式集 $\\,\\mathcal{M}\\,$, 与 $\\,\\mathcal{M}\\,$ 对齐的边界系数 $\\,\\{a_{m,n}\\}\\,$ 和 $\\,\\{b_{m,n}\\}\\,$，对应于 $\\,k=1,\\dots,K_{\\text{c}}\\,$ 的线圈系数 $\\,\\{c_k\\}\\,$，以及剖面参数 $\\,\\iota_{\\text{base}}\\,$, $\\,t_0\\,$, $\\,t_1\\,$, $\\,t_2\\,$。\n\n- 测试用例 $\\,1\\,$：\n  - $\\,N_{\\text{fp}}=5\\,$, $\\,R_0=5.5\\,$, $\\,A=8.0\\,$, $\\,\\kappa_R=0.12\\,$, $\\,\\kappa_Z=0.07\\,$, $\\,\\kappa_{\\epsilon}=0.03\\,$.\n  - $\\,w_{\\epsilon}=1.0\\,$, $\\,w_{\\iota}=5.0\\,$, $\\,w_{\\text{coil}}=0.1\\,$.\n  - $\\,\\mathcal{M}=\\{(1,0),(2,1)\\}\\,$.\n  - $\\,\\mathbf{a}=[0.02,-0.01]\\,$, $\\,\\mathbf{b}=[0.015,0.0]\\,$.\n  - 线圈系数 $\\,\\mathbf{c}=[0.1,-0.02,0.005]\\,$ 对应于 $\\,k=1,2,3\\,$.\n  - $\\,\\iota_{\\text{base}}=0.3\\,$, $\\,t_0=0.35\\,$, $\\,t_1=0.2\\,$, $\\,t_2=-0.1\\,$.\n\n- 测试用例 $\\,2\\,$：\n  - $\\,N_{\\text{fp}}=5\\,$, $\\,R_0=5.5\\,$, $\\,A=8.0\\,$, $\\,\\kappa_R=0.12\\,$, $\\,\\kappa_Z=0.07\\,$, $\\,\\kappa_{\\epsilon}=0.03\\,$.\n  - $\\,w_{\\epsilon}=0.2\\,$, $\\,w_{\\iota}=10.0\\,$, $\\,w_{\\text{coil}}=0.0\\,$.\n  - $\\,\\mathcal{M}=\\{(1,0),(2,1)\\}\\,$.\n  - $\\,\\mathbf{a}=[0.0,0.0]\\,$, $\\,\\mathbf{b}=[0.0,0.0]\\,$.\n  - 线圈系数 $\\,\\mathbf{c}=[0.0,0.0]\\,$ 对应于 $\\,k=1,2\\,$.\n  - $\\,\\iota_{\\text{base}}=0.32\\,$, $\\,t_0=0.3\\,$, $\\,t_1=0.0\\,$, $\\,t_2=0.0\\,$.\n\n- 测试用例 $\\,3\\,$：\n  - $\\,N_{\\text{fp}}=4\\,$, $\\,R_0=6.2\\,$, $\\,A=10.0\\,$, $\\,\\kappa_R=0.1\\,$, $\\,\\kappa_Z=0.08\\,$, $\\,\\kappa_{\\epsilon}=0.05\\,$.\n  - $\\,w_{\\epsilon}=0.0\\,$, $\\,w_{\\iota}=0.0\\,$, $\\,w_{\\text{coil}}=2.0\\,$.\n  - $\\,\\mathcal{M}=\\{(1,1)\\}\\,$.\n  - $\\,\\mathbf{a}=[0.1]\\,$, $\\,\\mathbf{b}=[-0.05]\\,$.\n  - 线圈系数 $\\,\\mathbf{c}=[0.02,0.03]\\,$ 对应于 $\\,k=1,2\\,$.\n  - $\\,\\iota_{\\text{base}}=0.0\\,$, $\\,t_0=0.0\\,$, $\\,t_1=0.0\\,$, $\\,t_2=0.0\\,$.\n\n- 测试用例 $\\,4\\,$：\n  - $\\,N_{\\text{fp}}=8\\,$, $\\,R_0=4.8\\,$, $\\,A=6.0\\,$, $\\,\\kappa_R=0.14\\,$, $\\,\\kappa_Z=0.06\\,$, $\\,\\kappa_{\\epsilon}=0.02\\,$.\n  - $\\,w_{\\epsilon}=1.5\\,$, $\\,w_{\\iota}=2.5\\,$, $\\,w_{\\text{coil}}=0.05\\,$.\n  - $\\,\\mathcal{M}=\\{(0,2),(1,0),(3,2)\\}\\,$.\n  - 与 $\\,\\mathcal{M}\\,$ 对齐的 $\\,\\mathbf{a}=[0.01,-0.02,0.005]\\,$，$\\,\\mathbf{b}=[-0.012,0.004,0.0]\\,$.\n  - 线圈系数 $\\,\\mathbf{c}=[0.05,-0.01,0.002,-0.0005]\\,$ 对应于 $\\,k=1,2,3,4\\,$.\n  - $\\,\\iota_{\\text{base}}=0.4\\,$, $\\,t_0=0.38\\,$, $\\,t_1=0.05\\,$, $\\,t_2=0.02\\,$.\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含测试集的结果，形式为一个用方括号括起来的逗号分隔列表，其中每个条目本身都是 $[J,\\|\\nabla J\\|_2,\\text{stationary}]$ 形式的列表。例如，输出必须如下所示\n$$\n\\big[\\,[J_1,\\|\\nabla J\\|_{2,1},\\text{True}],\\;[J_2,\\|\\nabla J\\|_{2,2},\\text{False}],\\;\\dots\\big].\n$$\n不得打印任何额外文本。",
            "solution": "用户提供了一个计算等离子体物理领域中有效且适定的问题，具体是使用代理模型进行仿星器形状优化。任务是推导并实现复合目标函数及其梯度的计算。\n\n复合目标函数 J 是三个项的加权和：有效磁涟波代理 $\\epsilon_{\\text{eff}}$、旋转变换剖面误差 $E_{\\iota}$ 和线圈平滑度惩罚项 $S_{\\text{coil}}$。\n$$\nJ(\\mathbf{a},\\mathbf{b},\\mathbf{c}) = w_{\\epsilon}\\,\\epsilon_{\\text{eff}}(\\mathbf{a},\\mathbf{b}) \\;+\\; w_{\\iota}\\,E_{\\iota}(\\mathbf{a},\\mathbf{b}) \\;+\\; w_{\\text{coil}}\\,S_{\\text{coil}}(\\mathbf{c})\n$$\n优化变量是用于等离子体边界形状的傅里叶系数集 $\\mathbf{a} = \\{a_{m,n}\\}$、$\\mathbf{b} = \\{b_{m,n}\\}$，以及用于线圈形状的系数集 $\\mathbf{c} = \\{c_k\\}$。我们的任务是推导 J 及其梯度向量 $\\nabla J$ 的显式表达式，其分量是关于每个优化变量的偏导数。\n\n根据微分的线性性质，总目标函数 J 的梯度是其各分量梯度的加权和：\n$$\n\\nabla J \\;=\\; w_{\\epsilon}\\,\\nabla\\epsilon_{\\text{eff}} \\;+\\; w_{\\iota}\\,\\nabla E_{\\iota} \\;+\\; w_{\\text{coil}}\\,\\nabla S_{\\text{coil}}\n$$\n我们将分别推导每一项及其梯度的显式形式。\n\n**1. 有效磁涟波代理项 ($\\epsilon_{\\text{eff}}$)**\n\n有效磁涟波被给定为边界系数的一个简单的正定二次型：\n$$\n\\epsilon_{\\text{eff}}(\\mathbf{a},\\mathbf{b}) \\;=\\; \\kappa_{\\epsilon}\\sum_{(m,n)\\in\\mathcal{M}} \\gamma_{m,n}\\,\\big(a_{m,n}^2+b_{m,n}^2\\big)\n$$\n其中模式依赖权重为 $\\gamma_{m,n} \\;=\\; \\frac{m^2 + (n\\,N_{\\text{fp}})^2}{A^2}$。对总目标函数的贡献为 $J_{\\epsilon} = w_{\\epsilon} \\epsilon_{\\text{eff}}$。这个表达式已经是显式的，不需要进一步简化。\n\n关于特定系数 $a_{m',n'}$ 或 $b_{m',n'}$ 的偏导数是直接的，因为由于变量的正交性，求和会坍缩：\n$$\n\\frac{\\partial \\epsilon_{\\text{eff}}}{\\partial a_{m',n'}} \\;=\\; \\kappa_{\\epsilon} \\sum_{(m,n)\\in\\mathcal{M}} \\gamma_{m,n} \\frac{\\partial}{\\partial a_{m',n'}}(a_{m,n}^2+b_{m,n}^2) \\;=\\; \\kappa_{\\epsilon} \\gamma_{m',n'} (2a_{m',n'})\n$$\n类似地，\n$$\n\\frac{\\partial \\epsilon_{\\text{eff}}}{\\partial b_{m',n'}} \\;=\\; \\kappa_{\\epsilon} \\gamma_{m',n'} (2b_{m',n'})\n$$\n此项不依赖于线圈系数 $\\mathbf{c}$，因此对所有 $k$ 都有 $\\frac{\\partial \\epsilon_{\\text{eff}}}{\\partial c_k} = 0$。\n\n此项对总目标函数的梯度分量贡献为：\n$$\n\\frac{\\partial J_{\\epsilon}}{\\partial a_{m,n}} = 2 w_{\\epsilon} \\kappa_{\\epsilon} \\gamma_{m,n} a_{m,n} \\quad \\text{和} \\quad \\frac{\\partial J_{\\epsilon}}{\\partial b_{m,n}} = 2 w_{\\epsilon} \\kappa_{\\epsilon} \\gamma_{m,n} b_{m,n}\n$$\n\n**2. 线圈平滑度惩罚项 ($S_{\\text{coil}}$)**\n\n线圈平滑度惩罚项由线圈径向函数 $R_{\\text{c}}(\\phi) = R_{\\text{c},0} + \\sum_{k=1}^{K_{\\text{c}}} c_k \\cos(k\\,\\phi)$ 的二阶导数平方的积分定义：\n$$\nS_{\\text{coil}}(\\mathbf{c}) \\;=\\; \\int_{0}^{2\\pi}\\left(\\frac{d^2 R_{\\text{c}}}{d\\phi^2}(\\phi)\\right)^2\\,d\\phi\n$$\n首先，我们计算二阶导数：\n$$\n\\frac{d R_{\\text{c}}}{d\\phi} = -\\sum_{k=1}^{K_{\\text{c}}} k\\,c_k\\,\\sin(k\\,\\phi) \\quad \\implies \\quad \\frac{d^2 R_{\\text{c}}}{d\\phi^2} = -\\sum_{k=1}^{K_{\\text{c}}} k^2\\,c_k\\,\\cos(k\\,\\phi)\n$$\n将此代入 $S_{\\text{coil}}$ 的积分中：\n$$\nS_{\\text{coil}} = \\int_{0}^{2\\pi} \\left( \\sum_{k=1}^{K_{\\text{c}}} k^2 c_k \\cos(k\\phi) \\right) \\left( \\sum_{\\ell=1}^{K_{\\text{c}}} \\ell^2 c_{\\ell} \\cos(\\ell\\phi) \\right) d\\phi = \\sum_{k=1}^{K_c} \\sum_{\\ell=1}^{K_c} k^2 \\ell^2 c_k c_\\ell \\int_{0}^{2\\pi} \\cos(k\\phi) \\cos(\\ell\\phi) \\,d\\phi\n$$\n使用所提供的恒等式 $\\int_{0}^{2\\pi}\\cos(k\\phi)\\cos(\\ell\\phi)\\,d\\phi = \\pi \\delta_{k\\ell}$（对于 $k, \\ell \\ge 1$），其中 $\\delta_{k\\ell}$ 是克罗内克 δ，该积分仅在 $k=\\ell$ 时非零。表达式简化为：\n$$\nS_{\\text{coil}} = \\sum_{k=1}^{K_{\\text{c}}} k^4 c_k^2 (\\pi) = \\pi\\sum_{k=1}^{K_{\\text{c}}} k^4 c_k^2\n$$\n对总目标函数的贡献为 $J_{\\text{coil}} = w_{\\text{coil}} S_{\\text{coil}}$。此项仅依赖于 $\\mathbf{c}$。\n关于系数 $c_{k'}$ 的梯度是：\n$$\n\\frac{\\partial S_{\\text{coil}}}{\\partial c_{k'}} = \\pi \\frac{\\partial}{\\partial c_{k'}} \\sum_{k=1}^{K_{\\text{c}}} k^4 c_k^2 = 2\\pi (k')^4 c_{k'}\n$$\n对总目标函数的梯度分量为：\n$$\n\\frac{\\partial J_{\\text{coil}}}{\\partial c_k} = 2\\pi w_{\\text{coil}} k^4 c_k\n$$\n\n**3. 旋转变换剖面误差 ($E_{\\iota}$)**\n\n项 $E_{\\iota}$ 是代理旋转变换 $\\iota(s)$ 与目标剖面 $\\iota_{\\text{target}}(s)$ 之差的平方 $L^2$-范数：\n$$\nE_{\\iota}(\\mathbf{a},\\mathbf{b}) \\;=\\; \\int_{0}^{1}\\Big(\\iota(s) - \\iota_{\\text{target}}(s)\\Big)^2\\,ds\n$$\n令差值为 $\\Delta\\iota(s) = \\iota(s) - \\iota_{\\text{target}}(s)$。使用所提供的定义：\n$$\n\\Delta\\iota(s) = (\\iota_{\\text{base}} - t_0) - t_1 s - t_2 s^2 + \\sum_{(m,n)\\in\\mathcal{M}} \\Big(\\alpha_{m,n}\\,a_{m,n}\\,s^{m} + \\beta_{m,n}\\,b_{m,n}\\,s^{m+1}\\Big)\n$$\n为了计算 $E_\\iota$ 及其梯度，方便先定义辅助积分 $I_k = \\int_0^1 \\Delta\\iota(s) s^k ds$。根据积分的线性性质并使用恒等式 $\\int_0^1 s^p ds = \\frac{1}{p+1}$：\n$$\nI_k = \\int_0^1 \\left( (\\iota_{\\text{base}} - t_0)s^k - t_1 s^{k+1} - t_2 s^{k+2} + \\sum_{(m,n)\\in\\mathcal{M}} (\\alpha_{m,n} a_{m,n} s^{m+k} + \\beta_{m,n} b_{m,n} s^{m+1+k}) \\right) ds\n$$\n$$\nI_k = \\frac{\\iota_{\\text{base}} - t_0}{k+1} - \\frac{t_1}{k+2} - \\frac{t_2}{k+3} + \\sum_{(m,n)\\in\\mathcal{M}} \\left( \\frac{\\alpha_{m,n} a_{m,n}}{m+k+1} + \\frac{\\beta_{m,n} b_{m,n}}{m+k+2} \\right)\n$$\n$E_\\iota$ 的值可以通过展开其定义并使用 $I_k$ 积分来计算：\n$$\nE_\\iota = \\int_0^1 \\Delta\\iota(s) \\Delta\\iota(s) ds = \\int_0^1 \\Delta\\iota(s) \\left( (\\iota_{\\text{base}} - t_0) - t_1 s - t_2 s^2 + \\sum_{(m,n)\\in\\mathcal{M}} \\dots \\right) ds\n$$\n$$\nE_\\iota = (\\iota_{\\text{base}} - t_0)I_0 - t_1 I_1 - t_2 I_2 + \\sum_{(m,n)\\in\\mathcal{M}} \\left( a_{m,n} \\alpha_{m,n} I_m + b_{m,n} \\beta_{m,n} I_{m+1} \\right)\n$$\n$E_\\iota$ 的梯度使用链式法则求得。对于系数 $a_{m',n'}$：\n$$\n\\frac{\\partial E_\\iota}{\\partial a_{m',n'}} = \\int_0^1 2\\Delta\\iota(s) \\frac{\\partial \\Delta\\iota(s)}{\\partial a_{m',n'}} ds\n$$\n由于 $\\frac{\\partial \\Delta\\iota(s)}{\\partial a_{m',n'}} = \\alpha_{m',n'}s^{m'}$，我们得到：\n$$\n\\frac{\\partial E_\\iota}{\\partial a_{m',n'}} = 2\\alpha_{m',n'} \\int_0^1 \\Delta\\iota(s) s^{m'} ds = 2\\alpha_{m',n'} I_{m'}\n$$\n类似地，由于 $\\frac{\\partial \\Delta\\iota(s)}{\\partial b_{m',n'}} = \\beta_{m',n'}s^{m'+1}$：\n$$\n\\frac{\\partial E_\\iota}{\\partial b_{m',n'}} = 2\\beta_{m',n'} \\int_0^1 \\Delta\\iota(s) s^{m'+1} ds = 2\\beta_{m',n'} I_{m'+1}\n$$\n此项对总目标函数的梯度分量贡献为：\n$$\n\\frac{\\partial J_{\\iota}}{\\partial a_{m,n}} = 2 w_{\\iota} \\alpha_{m,n} I_m \\quad \\text{和} \\quad \\frac{\\partial J_{\\iota}}{\\partial b_{m,n}} = 2 w_{\\iota} \\beta_{m,n} I_{m+1}\n$$\n\n**4. 目标函数和梯度总结**\n\n总目标函数 J 是三个贡献项的和：\n$$\nJ = w_{\\epsilon} \\kappa_{\\epsilon} \\sum_{(m,n)\\in\\mathcal{M}} \\gamma_{m,n} (a_{m,n}^2 + b_{m,n}^2) \\;+\\; w_{\\iota} E_{\\iota} \\;+\\; w_{\\text{coil}} \\pi \\sum_{k=1}^{K_c} k^4 c_k^2\n$$\n总梯度分量是每一项贡献的和：\n$$\n\\frac{\\partial J}{\\partial a_{m,n}} = 2 w_{\\epsilon} \\kappa_{\\epsilon} \\gamma_{m,n} a_{m,n} + 2 w_{\\iota} \\alpha_{m,n} I_m\n$$\n$$\n\\frac{\\partial J}{\\partial b_{m,n}} = 2 w_{\\epsilon} \\kappa_{\\epsilon} \\gamma_{m,n} b_{m,n} + 2 w_{\\iota} \\beta_{m,n} I_{m+1}\n$$\n$$\n\\frac{\\partial J}{\\partial c_k} = 2\\pi w_{\\text{coil}} k^4 c_k\n$$\n整体算法首先涉及计算必要的 $\\alpha$、$\\beta$、$\\gamma$ 系数，然后是 $I_k$ 积分，最后组装总目标函数 $J$ 及其梯度的分量 $\\nabla J$。然后从该梯度向量计算欧几里得范数 $\\|\\nabla J\\|_2$。",
            "answer": "```python\nimport numpy as np\n\ndef compute_J_and_grad(Nfp, R0, A, kR, kZ, ke, we, wi, wc, M, a_coeffs, b_coeffs, c_coeffs, ibase, t0, t1, t2):\n    \"\"\"\n    Computes the composite objective J and its gradient norm for a single test case.\n    \"\"\"\n    # Tolerance for stationarity check\n    tau = 1e-10\n\n    # Map list coefficients to dictionaries keyed by mode/index for clarity\n    a = {mode: coeff for mode, coeff in zip(M, a_coeffs)}\n    b = {mode: coeff for mode, coeff in zip(M, b_coeffs)}\n    c = {k: coeff for k, coeff in enumerate(c_coeffs, 1)}\n\n    # Initialize objective and gradient components\n    J = 0.0\n    grad_a = {mode: 0.0 for mode in M}\n    grad_b = {mode: 0.0 for mode in M}\n    grad_c = {k: 0.0 for k in c.keys()}\n\n    # --- 1. Effective Ripple Term (epsilon_eff) ---\n    if we > 0.0:\n        eps_eff = 0.0\n        for m, n in M:\n            gamma_mn = (m**2 + (n * Nfp)**2) / A**2\n            a_mn = a.get((m, n), 0.0)\n            b_mn = b.get((m, n), 0.0)\n            \n            eps_eff += gamma_mn * (a_mn**2 + b_mn**2)\n            \n            # Gradient contribution\n            grad_a[(m, n)] += we * ke * 2.0 * gamma_mn * a_mn\n            grad_b[(m, n)] += we * ke * 2.0 * gamma_mn * b_mn\n            \n        J += we * ke * eps_eff\n\n    # --- 2. Coil Smoothness Term (S_coil) ---\n    if wc > 0.0:\n        S_coil = 0.0\n        for k, c_k in c.items():\n            S_coil += (k**4) * (c_k**2)\n            \n            # Gradient contribution\n            grad_c[k] += wc * np.pi * 2.0 * (k**4) * c_k\n            \n        J += wc * np.pi * S_coil\n\n    # --- 3. Rotational Transform Error Term (E_iota) ---\n    if wi > 0.0:\n        # Pre-compute alpha and beta coefficients\n        alpha = {}\n        beta = {}\n        for m, n in M:\n            nNfp_sq = (n * Nfp)**2\n            m_over_R0 = m / R0\n            alpha[(m, n)] = kR / (1.0 + nNfp_sq) * (m_over_R0**2)\n            beta[(m, n)] = kZ / (1.0 + nNfp_sq) * m_over_R0\n\n        # Determine which I_k integrals are needed\n        needed_powers = {0, 1, 2}\n        for m, n in M:\n            needed_powers.add(m)\n            needed_powers.add(m + 1)\n        \n        # Compute I_k integrals\n        I = {}\n        C0 = ibase - t0\n        for k in needed_powers:\n            sum_term = 0.0\n            for m, n in M:\n                a_mn = a.get((m, n), 0.0)\n                b_mn = b.get((m, n), 0.0)\n                sum_term += (alpha[(m, n)] * a_mn) / (m + k + 1)\n                sum_term += (beta[(m, n)] * b_mn) / (m + k + 2)\n\n            I[k] = C0 / (k + 1) - t1 / (k + 2) - t2 / (k + 3) + sum_term\n\n        # Compute E_iota\n        E_iota_sum = 0.0\n        for m, n in M:\n            a_mn = a.get((m, n), 0.0)\n            b_mn = b.get((m, n), 0.0)\n            E_iota_sum += a_mn * alpha[(m, n)] * I[m]\n            E_iota_sum += b_mn * beta[(m, n)] * I[m + 1]\n\n        E_iota = C0 * I[0] - t1 * I[1] - t2 * I[2] + E_iota_sum\n        J += wi * E_iota\n\n        # Gradient contributions\n        for m, n in M:\n            grad_a[(m, n)] += wi * 2.0 * alpha[(m, n)] * I[m]\n            grad_b[(m, n)] += wi * 2.0 * beta[(m, n)] * I[m + 1]\n\n    # --- 4. Final Gradient Norm Calculation ---\n    grad_vector = []\n    # Ensure a consistent order for reproducibility\n    sorted_modes = sorted(M)\n    for m, n in sorted_modes:\n        grad_vector.append(grad_a[(m,n)])\n    for m, n in sorted_modes:\n        grad_vector.append(grad_b[(m,n)])\n    sorted_k = sorted(c.keys())\n    for k in sorted_k:\n        grad_vector.append(grad_c[k])\n\n    grad_norm = np.linalg.norm(grad_vector)\n    is_stationary = grad_norm  tau\n    \n    return [J, grad_norm, is_stationary]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {\n            \"Nfp\": 5, \"R0\": 5.5, \"A\": 8.0, \"kR\": 0.12, \"kZ\": 0.07, \"ke\": 0.03,\n            \"we\": 1.0, \"wi\": 5.0, \"wc\": 0.1,\n            \"M\": [(1, 0), (2, 1)],\n            \"a\": [0.02, -0.01], \"b\": [0.015, 0.0],\n            \"c\": [0.1, -0.02, 0.005],\n            \"ibase\": 0.3, \"t0\": 0.35, \"t1\": 0.2, \"t2\": -0.1\n        },\n        # Test case 2\n        {\n            \"Nfp\": 5, \"R0\": 5.5, \"A\": 8.0, \"kR\": 0.12, \"kZ\": 0.07, \"ke\": 0.03,\n            \"we\": 0.2, \"wi\": 10.0, \"wc\": 0.0,\n            \"M\": [(1, 0), (2, 1)],\n            \"a\": [0.0, 0.0], \"b\": [0.0, 0.0],\n            \"c\": [0.0, 0.0],\n            \"ibase\": 0.32, \"t0\": 0.3, \"t1\": 0.0, \"t2\": 0.0\n        },\n        # Test case 3\n        {\n            \"Nfp\": 4, \"R0\": 6.2, \"A\": 10.0, \"kR\": 0.1, \"kZ\": 0.08, \"ke\": 0.05,\n            \"we\": 0.0, \"wi\": 0.0, \"wc\": 2.0,\n            \"M\": [(1, 1)],\n            \"a\": [0.1], \"b\": [-0.05],\n            \"c\": [0.02, 0.03],\n            \"ibase\": 0.0, \"t0\": 0.0, \"t1\": 0.0, \"t2\": 0.0\n        },\n        # Test case 4\n        {\n            \"Nfp\": 8, \"R0\": 4.8, \"A\": 6.0, \"kR\": 0.14, \"kZ\": 0.06, \"ke\": 0.02,\n            \"we\": 1.5, \"wi\": 2.5, \"wc\": 0.05,\n            \"M\": [(0, 2), (1, 0), (3, 2)],\n            \"a\": [0.01, -0.02, 0.005], \"b\": [-0.012, 0.004, 0.0],\n            \"c\": [0.05, -0.01, 0.002, -0.0005],\n            \"ibase\": 0.4, \"t0\": 0.38, \"t1\": 0.05, \"t2\": 0.02\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_J_and_grad(\n            case[\"Nfp\"], case[\"R0\"], case[\"A\"],\n            case[\"kR\"], case[\"kZ\"], case[\"ke\"],\n            case[\"we\"], case[\"wi\"], case[\"wc\"],\n            case[\"M\"], case[\"a\"], case[\"b\"], case[\"c\"],\n            case[\"ibase\"], case[\"t0\"], case[\"t1\"], case[\"t2\"]\n        )\n        results.append(result)\n\n    # Format the final output string exactly as required\n    results_str = \",\".join(map(str, results))\n    print(f\"[{results_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了描述几何形状和构建目标函数的方法之后，我们便可以进行一次完整的优化。本练习模拟了一个旨在实现准对称性（一种能显著改善等离子体约束的特性）的简化设计循环。您将通过实现一个正则化最小二乘优化问题，来寻找能最大程度抑制对称性破缺磁场波纹的等离子体形状参数，从而亲身体验计算仿星器设计的核心过程。",
            "id": "4044803",
            "problem": "考虑一个计算仿星器设计的简化模型，其中磁通面上的磁场大小在 Boozer 坐标中由截断的傅里叶级数表示。令极向角用 $\\theta$ 表示，环向角用 $\\zeta$ 表示，单位均为弧度。对于由 $\\rho \\in (0,1)$ 标记的给定归一化环向磁通面，将磁场大小建模为\n$$\n|B|(\\theta,\\zeta;\\rho) \\equiv \\sum_{(m,n)\\in \\mathcal{K}} b_{m,n}(\\rho)\\,\\cos(m\\theta - n\\zeta),\n$$\n其中 $\\mathcal{K}$ 是一个有限模集，$b_{m,n}(\\rho)$ 是傅里叶系数。在此模型中，当 $|B|(\\theta,\\zeta;\\rho)$ 仅取决于螺旋角 $\\alpha\\equiv M\\theta - N\\zeta$ 时，即当所有不满足 $mM - nN = 0$ 的傅里叶分量 $(m,n)$ 都可以忽略不计时，便近似实现了具有螺旋度 $(M,N)\\in \\mathbb{Z}\\times\\mathbb{Z}$ 的准对称性（QS）。如果 $mM - nN = 0$，我们称 $(m,n)$ 为共振模，否则称为非共振模。\n\n假设一个线性化形状响应模型，其中傅里叶系数 $b_{m,n}(\\rho)$ 通过以下方式依赖于一小组形状参数 ${\\bf p}\\in\\mathbb{R}^3$：\n$$\nb_{m,n}(\\rho;{\\bf p}) \\equiv a_{m,n}(\\rho) + \\sum_{i=1}^{3} S_{m,n,i}(\\rho)\\,p_i,\n$$\n其中 $a_{m,n}(\\rho)$ 是基线系数，$S_{m,n,i}(\\rho)$ 是灵敏度系数。假设使用以下模集：\n$$\n\\mathcal{K} \\equiv \\{(m,n)\\,|\\, m\\in\\{0,1,2\\},\\, n\\in\\{-1,0,1\\},\\, (m,n)\\neq(0,0)\\}.\n$$\n基线系数由以下确定性公式给出\n$$\na_{m,n}(\\rho) \\equiv 0.04 + 0.01\\,m + 0.02\\,|n| + 0.005\\,\\rho,\n$$\n灵敏度由以下公式给出\n$$\nS_{m,n,1}(\\rho) \\equiv 0.10\\,e^{-\\rho}\\,(m+1)\\,(n^2+1),\n$$\n$$\nS_{m,n,2}(\\rho) \\equiv -0.08\\,e^{-0.5\\rho}\\,(m\\,n + 1),\n$$\n$$\nS_{m,n,3}(\\rho) \\equiv 0.05\\,(m^2+n^2)\\,(1-\\rho).\n$$\n为了评估通过最小化非共振傅里叶模可实现的近似准对称程度，考虑 Tikhonov 正则化最小二乘问题\n$$\n\\min_{{\\bf p}\\in\\mathbb{R}^3}\\; J({\\bf p}) \\equiv \\sum_{\\rho\\in\\mathcal{S}} \\sum_{(m,n)\\in\\mathcal{K}\\,:\\, mM-nN\\neq 0} \\left[b_{m,n}(\\rho;{\\bf p})\\right]^2 \\;+\\; \\lambda\\,\\|{\\bf p}\\|_2^2,\n$$\n其中 $\\mathcal{S}$ 是一组选定的磁通面，$\\lambda0$ 是一个正则化参数。对于最小化参数 ${\\bf p}^\\star$，通过以下比率量化每个磁通面 $\\rho\\in\\mathcal{S}$ 上的残余对称性破缺\n$$\nR(\\rho;M,N,\\lambda) \\equiv \\frac{\\sum\\limits_{(m,n)\\in\\mathcal{K}\\,:\\, mM-nN\\neq 0}\\left[b_{m,n}(\\rho;{\\bf p}^\\star)\\right]^2}{\\sum\\limits_{(m,n)\\in\\mathcal{K}}\\left[b_{m,n}(\\rho;{\\bf p}^\\star)\\right]^2},\n$$\n该比率位于 $[0,1]$ 区间内，衡量非共振模中的谱能量相对于总能量的比例。\n\n从环面上的傅里叶表示、准对称共振条件和线性化响应模型的定义出发，推导出一个计算方法以获得 ${\\bf p}^\\star$，然后为每个 $\\rho\\in\\mathcal{S}$ 计算 $R(\\rho;M,N,\\lambda)$。\n\n角度单位说明：所有角度均以弧度为单位。\n\n您的程序必须实现上述模型，并为以下测试套件生成数值，其中螺旋度 $(M,N)$、磁通面集 $\\mathcal{S}$ 和正则化参数 $\\lambda$ 会变化以探究不同场景：\n\n- 测试用例 1 (理想情况，准轴对称)：$(M,N)=(1,0)$，$\\mathcal{S}=\\{0.3, 0.6, 0.9\\}$，$\\lambda=0.001$。\n- 测试用例 2 (螺旋准对称)：$(M,N)=(1,1)$，$\\mathcal{S}=\\{0.25, 0.5, 0.75\\}$，$\\lambda=0.001$。\n- 测试用例 3 (强正则化的边缘情况)：$(M,N)=(2,1)$，$\\mathcal{S}=\\{0.2, 0.8\\}$，$\\lambda=0.5$。\n- 测试用例 4 (共振内容有限的边界情况)：$(M,N)=(0,1)$，$\\mathcal{S}=\\{0.4\\}$，$\\lambda=0.001$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例对应一个浮点数列表，这些浮点数是 $\\mathcal{S}$ 中各磁通面的 $R(\\rho;M,N,\\lambda)$ 值，四舍五入到六位小数。例如，输出格式必须为\n$$\n[\\,[r_{1,1},r_{1,2},\\dots],\\,[r_{2,1},r_{2,2},\\dots],\\,[r_{3,1},\\dots],\\,[r_{4,1},\\dots]\\,],\n$$\n其中 $r_{k,j}$ 表示第 $k$ 个测试用例中第 $j$ 个磁通面的残余比率。不应打印任何额外文本。",
            "solution": "该问题在计算等离子体物理和优化的背景下是适定的，并且具有科学依据。它为旨在实现近似准对称性的仿星器形状优化提供了一个简化但标准的模型。所有必要的定义、公式和数据都已提供，并且没有内部矛盾或逻辑缺陷。因此，我们可以直接进行求解推导。\n\n问题的核心是找到形状参数矢量 ${\\bf p} \\in \\mathbb{R}^3$，以最小化 Tikhonov 正则化成本函数 $J({\\bf p})$：\n$$\nJ({\\bf p}) \\equiv \\sum_{\\rho\\in\\mathcal{S}} \\sum_{(m,n)\\in\\mathcal{K}_{\\text{NR}}} \\left[b_{m,n}(\\rho;{\\bf p})\\right]^2 \\;+\\; \\lambda\\,\\|{\\bf p}\\|_2^2\n$$\n其中 $\\mathcal{K}_{\\text{NR}} = \\{(m,n)\\in\\mathcal{K}\\,|\\, mM-nN\\neq 0\\}$ 是给定螺旋度 $(M,N)$ 的非共振模集。项 $\\|{\\bf p}\\|_2^2$ 是 ${\\bf p}$ 的欧几里得范数的平方，即 $p_1^2 + p_2^2 + p_3^2$。\n\n让我们将磁场系数 $b_{m,n}$ 的线性模型代入成本函数：\n$$\nb_{m,n}(\\rho;{\\bf p}) = a_{m,n}(\\rho) + \\sum_{i=1}^{3} S_{m,n,i}(\\rho)\\,p_i\n$$\n成本函数变为：\n$$\nJ({\\bf p}) = \\sum_{\\rho\\in\\mathcal{S}} \\sum_{(m,n)\\in\\mathcal{K}_{\\text{NR}}} \\left( a_{m,n}(\\rho) + \\sum_{i=1}^{3} S_{m,n,i}(\\rho)\\,p_i \\right)^2 + \\lambda \\sum_{i=1}^{3} p_i^2\n$$\n这是一个带有 Tikhonov 正则化（也称为岭回归）的标准线性最小二乘问题。我们可以用矩阵-向量形式表示它。让我们定义一个单一索引 $k$，用于枚举双重求和中出现的所有对 $(\\rho, (m,n))$。设这类项的总数为 $L$。然后我们可以定义一个大小为 $L \\times 3$ 的矩阵 $A$ 和一个大小为 $L \\times 1$ 的向量 $\\mathbf{y}$。\n\n对于每个对应于一对 $(\\rho, (m,n))$ 的 $k$，矩阵 $A$ 的第 $k$ 行由灵敏度系数给出：\n$$\nA_{k,i} = S_{m,n,i}(\\rho) \\quad \\text{for } i=1,2,3\n$$\n向量 $\\mathbf{y}$ 的第 $k$ 个元素由基线系数的负值给出：\n$$\ny_k = -a_{m,n}(\\rho)\n$$\n根据这些定义，成本函数的第一项可以写成一个向量的范数平方：\n$$\n\\sum_{k=1}^{L} \\left( y_k - \\sum_{i=1}^{3} A_{k,i}\\,p_i \\right)^2 = \\|\\mathbf{y} - A\\mathbf{p}\\|_2^2\n$$\n等一下，符号反了。求和中的项是 $(a_{m,n} + \\sum S_{m,n,i} p_i)^2 = (-y_k + \\sum A_{k,i} p_i)^2 = (A\\mathbf{p} - \\mathbf{y})_k^2$。表达式是正确的。\n\n完整的成本函数的矩阵-向量形式是：\n$$\nJ(\\mathbf{p}) = \\|A\\mathbf{p} - \\mathbf{y}\\|_2^2 + \\lambda \\|\\mathbf{p}\\|_2^2\n$$\n为了找到最小化 $J(\\mathbf{p})$ 的最优向量 $\\mathbf{p}^\\star$，我们计算 $J$ 相对于 $\\mathbf{p}$ 的梯度，并将其设为零。\n$$\n\\nabla_{\\mathbf{p}} J(\\mathbf{p}) = \\nabla_{\\mathbf{p}} \\left( (A\\mathbf{p} - \\mathbf{y})^T (A\\mathbf{p} - \\mathbf{y}) + \\lambda \\mathbf{p}^T \\mathbf{p} \\right)\n$$\n$$\n\\nabla_{\\mathbf{p}} J(\\mathbf{p}) = \\nabla_{\\mathbf{p}} \\left( \\mathbf{p}^T A^T A \\mathbf{p} - 2\\mathbf{y}^T A \\mathbf{p} + \\mathbf{y}^T \\mathbf{y} + \\lambda \\mathbf{p}^T \\mathbf{p} \\right)\n$$\n$$\n\\nabla_{\\mathbf{p}} J(\\mathbf{p}) = 2 A^T A \\mathbf{p} - 2 A^T \\mathbf{y} + 2 \\lambda \\mathbf{p}\n$$\n将梯度设为零，得到这个正则化问题的正规方程：\n$$\n2 A^T A \\mathbf{p}^\\star - 2 A^T \\mathbf{y} + 2 \\lambda \\mathbf{p}^\\star = \\mathbf{0}\n$$\n$$\n(A^T A + \\lambda I) \\mathbf{p}^\\star = A^T \\mathbf{y}\n$$\n其中 $I$ 是 $3 \\times 3$ 的单位矩阵。这是一个关于未知向量 $\\mathbf{p}^\\star$ 的 $3 \\times 3$ 线性方程组。由于 $\\lambda  0$ 且 $A^T A$ 是半正定的，矩阵 $(A^T A + \\lambda I)$ 是正定的，因此是可逆的，保证了唯一解的存在：\n$$\n\\mathbf{p}^\\star = (A^T A + \\lambda I)^{-1} A^T \\mathbf{y}\n$$\n一旦找到最优参数矢量 $\\mathbf{p}^\\star = (p_1^\\star, p_2^\\star, p_3^\\star)^T$，我们就可以为每个磁通面 $\\rho \\in \\mathcal{S}$ 评估残余对称性破缺比率 $R(\\rho)$。首先，我们为所有模 $(m,n) \\in \\mathcal{K}$ 计算优化后的傅里叶系数：\n$$\nb_{m,n}(\\rho; \\mathbf{p}^\\star) = a_{m,n}(\\rho) + S_{m,n,1}(\\rho)p_1^\\star + S_{m,n,2}(\\rho)p_2^\\star + S_{m,n,3}(\\rho)p_3^\\star\n$$\n然后，比率 $R(\\rho)$ 通过计算非共振模中的能量除以总能量得到：\n$$\nR(\\rho;M,N,\\lambda) = \\frac{\\sum\\limits_{(m,n)\\in\\mathcal{K}_{\\text{NR}}}\\left[b_{m,n}(\\rho;{\\bf p}^\\star)\\right]^2}{\\sum\\limits_{(m,n)\\in\\mathcal{K}}\\left[b_{m,n}(\\rho;{\\bf p}^\\star)\\right]^2}\n$$\n每个测试用例的计算过程如下：\n1.  定义模集 $\\mathcal{K} = \\{(m,n)\\,|\\, m\\in\\{0,1,2\\},\\, n\\in\\{-1,0,1\\},\\, (m,n)\\neq(0,0)\\}$。\n2.  给定 $(M,N)$，确定非共振模集 $\\mathcal{K}_{\\text{NR}}$。\n3.  通过遍历每个磁通面 $\\rho \\in \\mathcal{S}$ 和每个非共振模 $(m,n) \\in \\mathcal{K}_{\\text{NR}}$ 来构造矩阵 $A$ 和向量 $\\mathbf{y}$。对于每一个这样的对，计算行向量 $[S_{m,n,1}(\\rho), S_{m,n,2}(\\rho), S_{m,n,3}(\\rho)]$ 并将其附加到 $A$ 中，计算标量 $-a_{m,n}(\\rho)$ 并将其附加到 $\\mathbf{y}$ 中。\n4.  求解 $3 \\times 3$ 线性系统 $(A^T A + \\lambda I) \\mathbf{p}^\\star = A^T \\mathbf{y}$ 以找到 $\\mathbf{p}^\\star$。\n5.  对于每个 $\\rho \\in \\mathcal{S}$，计算所有 $(m,n) \\in \\mathcal{K}$ 的系数 $b_{m,n}(\\rho; \\mathbf{p}^\\star)$。\n6.  通过对相关系数的平方求和来计算 $R(\\rho)$ 的分子和分母，然后求出它们的比值。\n7.  收集 $\\mathcal{S}$ 中所有磁通面的 $R(\\rho)$ 计算值。\n对所提供的四个测试用例中的每一个都执行此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a Tikhonov-regularized least-squares problem for stellarator \n    quasisymmetry optimization and computes a residual symmetry-breaking metric.\n    \"\"\"\n    \n    # Define the mode set K = {(m,n) | m in {0,1,2}, n in {-1,0,1}} \\ {(0,0)}\n    modes_k = []\n    for m in range(3):\n        for n in range(-1, 2):\n            if m == 0 and n == 0:\n                continue\n            modes_k.append((m, n))\n\n    # Define the baseline and sensitivity coefficient functions\n    def a_mn(m, n, rho):\n        return 0.04 + 0.01 * m + 0.02 * abs(n) + 0.005 * rho\n\n    def s_mn1(m, n, rho):\n        return 0.10 * np.exp(-rho) * (m + 1) * (n**2 + 1)\n\n    def s_mn2(m, n, rho):\n        return -0.08 * np.exp(-0.5 * rho) * (m * n + 1)\n\n    def s_mn3(m, n, rho):\n        return 0.05 * (m**2 + n**2) * (1 - rho)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (M, N, S_surfaces, lambda_reg)\n        (1, 0, [0.3, 0.6, 0.9], 0.001),\n        (1, 1, [0.25, 0.5, 0.75], 0.001),\n        (2, 1, [0.2, 0.8], 0.5),\n        (0, 1, [0.4], 0.001),\n    ]\n\n    # Store results for final printing\n    results_as_strings = []\n\n    for case in test_cases:\n        M, N, S_surfaces, lambda_reg = case\n\n        # 1. Identify non-resonant modes\n        modes_k_nr = [\n            (m, n) for m, n in modes_k if m * M - n * N != 0\n        ]\n\n        # 2. Construct the matrix A and vector y\n        A_rows = []\n        y_elements = []\n        for rho in S_surfaces:\n            for m, n in modes_k_nr:\n                row = [s_mn1(m, n, rho), s_mn2(m, n, rho), s_mn3(m, n, rho)]\n                A_rows.append(row)\n                y_elements.append(-a_mn(m, n, rho))\n        \n        A = np.array(A_rows)\n        y = np.array(y_elements)\n\n        # 3. Solve for the optimal parameters p_star\n        AtA = A.T @ A\n        Aty = A.T @ y\n        # Solve (AtA + lambda * I) * p_star = Aty\n        H = AtA + lambda_reg * np.identity(3)\n        p_star = np.linalg.solve(H, Aty)\n        \n        # 4. Compute the residual ratio R for each surface\n        r_values_for_case = []\n        for rho in S_surfaces:\n            numerator = 0.0\n            denominator = 0.0\n\n            # Iterate over all modes in K to calculate total energy (denominator)\n            # and non-resonant energy (numerator)\n            for m, n in modes_k:\n                b_mn_p_star = (\n                    a_mn(m, n, rho) +\n                    s_mn1(m, n, rho) * p_star[0] +\n                    s_mn2(m, n, rho) * p_star[1] +\n                    s_mn3(m, n, rho) * p_star[2]\n                )\n                b_squared = b_mn_p_star**2\n                denominator += b_squared\n                \n                # Check if the mode is non-resonant\n                if m * M - n * N != 0:\n                    numerator += b_squared\n            \n            # Avoid division by zero, though unlikely in this problem\n            ratio = numerator / denominator if denominator != 0 else 0.0\n            r_values_for_case.append(ratio)\n        \n        # Format this test case's results for the final output string\n        formatted_r_strings = [f\"{r:.6f}\" for r in r_values_for_case]\n        sublist_string = f\"[{','.join(formatted_r_strings)}]\"\n        results_as_strings.append(sublist_string)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```"
        }
    ]
}