{
    "hands_on_practices": [
        {
            "introduction": "The design of any magnetic confinement device begins with the ability to accurately compute the magnetic field generated by its coils. This exercise provides hands-on practice with this fundamental task by starting from the Biot-Savart law for a filamentary current loop. You will implement a numerical method to approximate the integral, a core skill in magnetics modeling, and analyze its convergence to understand the trade-offs between computational cost and accuracy .",
            "id": "4044824",
            "problem": "In computational stellarator design, magnetic fields from filamentary coils are evaluated repeatedly during shape optimization. Consider a single, closed, smooth coil curve parameterized by arc length. Let the coil be a circular loop of radius $R_0$ centered at the origin in the plane $z=0$, parameterized by arc length $s \\in [0,L)$ with $L = 2\\pi R_0$ and position $\\mathbf{r}_c(s) = \\big(R_0 \\cos(s/R_0),\\, R_0 \\sin(s/R_0),\\, 0\\big)$. A steady current $I$ flows along the coil. The magnetic field $\\mathbf{B}(\\mathbf{r})$ at a point $\\mathbf{r}$ in space is given by the magnetostatic Biot–Savart law for a filamentary current,\n$$\n\\mathbf{B}(\\mathbf{r}) = \\frac{\\mu_0 I}{4\\pi} \\int_0^L \\frac{d\\mathbf{r}_c(s) \\times \\big(\\mathbf{r} - \\mathbf{r}_c(s)\\big)}{\\left\\|\\mathbf{r} - \\mathbf{r}_c(s)\\right\\|^3}\\, ds,\n$$\nwhere $\\mu_0$ is the magnetic permeability of free space and $d\\mathbf{r}_c(s) = \\frac{d\\mathbf{r}_c}{ds} ds$.\n\nTask: Starting from this fundamental law and the arc-length parameterization, design and implement a numerical method that discretizes the coil into straight segments of uniform arc length and approximates $\\mathbf{B}$ at a set of boundary points by numerical quadrature. Use a midpoint rule over segments derived from the arc-length parameterization. Quantify the error as a function of the segment length by comparing to a high-resolution reference computation, and estimate the observed convergence order.\n\nUse the following concrete and scientifically sound setup, units, and test suite:\n\n- Physical constants and parameters:\n  - Magnetic permeability: $\\mu_0 = 4\\pi \\times 10^{-7}\\,\\mathrm{T\\cdot m/A}$.\n  - Coil radius: $R_0 = 1.5\\,\\mathrm{m}$, so $L = 2\\pi R_0$.\n  - Current: $I = 5.0 \\times 10^4\\,\\mathrm{A}$.\n- Boundary (evaluation) points:\n  - Define a circle of radius $a = 0.4\\,\\mathrm{m}$ in the plane $z=z_0$ with $z_0 = 0.3\\,\\mathrm{m}$, centered on the $z$-axis. Parameterize the boundary as $\\mathbf{r}_b(\\varphi) = \\big(a\\cos\\varphi,\\, a\\sin\\varphi,\\, z_0\\big)$ with $\\varphi \\in [0,2\\pi)$ in radians. Use $M=64$ uniformly spaced angles $\\varphi_m = 2\\pi m/M$ for $m=0,1,\\dots,M-1$.\n- Discretization and numerical approximation:\n  - For a given integer $N \\ge 2$, discretize the arc-length domain $[0,L)$ into $N$ equal subintervals of length $h = L/N$. Construct straight segments between $\\mathbf{r}_c(s_i)$ and $\\mathbf{r}_c(s_{i+1})$ with $s_i = i h$ and $s_{i+1} = (i+1)h$ for $i=0,1,\\dots,N-1$, interpreting indices modulo $N$ for closure. Use a midpoint quadrature over each segment to approximate the integral. Angles in trigonometric functions must be in radians.\n  - For a high-resolution reference, use $N_\\mathrm{ref} = 8192$ to approximate $\\mathbf{B}_\\mathrm{ref}$ at the same boundary points. This serves as the ground-truth surrogate in lieu of a closed-form solution off-axis.\n- Error measure and convergence order:\n  - For each $N$ in the test suite below, compute the root-mean-square (RMS) vector error over the $M$ boundary points,\n    $$\n    E(N) = \\sqrt{\\frac{1}{M}\\sum_{m=1}^{M} \\left\\| \\mathbf{B}_N\\big(\\mathbf{r}_b(\\varphi_m)\\big) - \\mathbf{B}_\\mathrm{ref}\\big(\\mathbf{r}_b(\\varphi_m)\\big) \\right\\|_2^2 }.\n    $$\n    Express $E(N)$ in tesla ($\\mathrm{T}$).\n  - Let $h(N) = L/N$ be the segment length. Using the set $\\{(h(N), E(N))\\}$ for the test suite values of $N$, estimate the observed convergence order $p$ by fitting a straight line to $\\log E$ versus $\\log h$ using least squares and taking the slope as $p$.\n- Test suite:\n  - Use $N \\in \\{20, 40, 80, 160\\}$.\n- Required final output format:\n  - Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain the four RMS errors for the test suite $N$ values in ascending order, followed by the estimated convergence order $p$. For example, print\n    $$\n    [E(20), E(40), E(80), E(160), p].\n    $$\n  - The numerical values are unitful quantities internally, but the output list must contain only raw numbers (no units text). The errors are in $\\mathrm{T}$ and the convergence order is dimensionless.\n\nDesign your algorithm from first principles, starting from the Biot–Savart law and the arc-length parameterization. Do not invoke pre-derived shortcut formulas for finite segments in the problem statement. Ensure scientific realism by adhering to the stated geometry and units. The solution must be universally understandable by a developer and self-contained, reproducible, and numerically robust for the given parameter choices.",
            "solution": "The problem asks for the design and implementation of a numerical method to calculate the magnetic field generated by a circular current loop, based on a discretization of the Biot-Savart law. This involves approximating the continuous, curved coil with a series of straight segments and using a midpoint rule to evaluate the contribution of each segment. The accuracy of this approximation is then quantified by calculating the root-mean-square (RMS) error against a high-resolution reference computation, and the order of convergence is estimated.\n\nThe fundamental principle is the Biot-Savart law for a filamentary current loop, which gives the magnetic field $\\mathbf{B}$ at a position $\\mathbf{r}$ as an integral over the coil's path:\n$$\n\\mathbf{B}(\\mathbf{r}) = \\frac{\\mu_0 I}{4\\pi} \\int_{\\text{coil}} \\frac{d\\mathbf{l} \\times \\mathbf{d}}{\\|\\mathbf{d}\\|^3}\n$$\nwhere $d\\mathbf{l}$ is a differential vector element along the coil carrying current $I$, $\\mathbf{d} = \\mathbf{r} - \\mathbf{r}_c(s)$ is the vector from the source point on the coil $\\mathbf{r}_c(s)$ to the evaluation point $\\mathbf{r}$, and $\\mu_0 = 4\\pi \\times 10^{-7}\\,\\mathrm{T\\cdot m/A}$ is the magnetic permeability of free space. For the given problem, the coil is parameterized by arc length $s \\in [0, L)$, with $L = 2\\pi R_0$ and $\\mathbf{r}_c(s) = (R_0 \\cos(s/R_0), R_0 \\sin(s/R_0), 0)$. The differential element is $d\\mathbf{l} = \\frac{d\\mathbf{r}_c}{ds} ds$.\n\nThe core of the task is to approximate this integral numerically. The problem specifies a method wherein the smooth circular coil is replaced by a closed polygon of $N$ straight segments. The vertices of this polygon lie on the original circular path.\nLet the arc length domain $[0, L)$ be divided into $N$ equal subintervals, each of length $h = L/N$. The vertices of the approximating polygon are then given by the points $\\mathbf{p}_i = \\mathbf{r}_c(s_i)$ where $s_i = i \\cdot h$ for $i=0, 1, \\dots, N$. Since the coil is closed, $\\mathbf{p}_N = \\mathbf{p}_0$. The $i$-th straight segment connects vertex $\\mathbf{p}_i$ to $\\mathbf{p}_{i+1}$ (with the index interpreted modulo $N$).\n\nThe integral over the entire coil is then approximated by a sum of contributions from these $N$ straight segments:\n$$\n\\mathbf{B}(\\mathbf{r}) \\approx \\mathbf{B}_N(\\mathbf{r}) = \\sum_{i=0}^{N-1} \\Delta\\mathbf{B}_i(\\mathbf{r})\n$$\nwhere $\\Delta\\mathbf{B}_i(\\mathbf{r})$ is the magnetic field contribution from the $i$-th segment. The problem directs us to use a midpoint rule for each segment. This involves approximating the integral over the $i$-th segment by evaluating the integrand at the segment's geometric midpoint and using the segment's vector as the differential element.\n\nFor the $i$-th segment, which runs from $\\mathbf{p}_i$ to $\\mathbf{p}_{i+1}$:\n1.  The vector representing the entire segment is $\\Delta\\mathbf{L}_i = \\mathbf{p}_{i+1} - \\mathbf{p}_i$.\n2.  The geometric midpoint of this segment is $\\mathbf{l}_{\\text{mid}, i} = \\frac{\\mathbf{p}_i + \\mathbf{p}_{i+1}}{2}$.\n3.  The vector from the segment's midpoint to the evaluation point $\\mathbf{r}$ is $\\mathbf{d}_i = \\mathbf{r} - \\mathbf{l}_{\\text{mid}, i}$.\n\nApplying the midpoint rule, we approximate the contribution from the $i$-th segment by treating it as a single differential element $\\Delta\\mathbf{L}_i$ located at its midpoint $\\mathbf{l}_{\\text{mid}, i}$:\n$$\n\\Delta\\mathbf{B}_i(\\mathbf{r}) \\approx \\frac{\\mu_0 I}{4\\pi} \\frac{\\Delta\\mathbf{L}_i \\times \\mathbf{d}_i}{\\|\\mathbf{d}_i\\|^3} = \\frac{\\mu_0 I}{4\\pi} \\frac{(\\mathbf{p}_{i+1} - \\mathbf{p}_i) \\times \\left(\\mathbf{r} - \\frac{\\mathbf{p}_i + \\mathbf{p}_{i+1}}{2}\\right)}{\\left\\|\\mathbf{r} - \\frac{\\mathbf{p}_i + \\mathbf{p}_{i+1}}{2}\\right\\|^3}\n$$\nThe total approximated magnetic field at $\\mathbf{r}$ for a discretization level $N$ is the sum of these contributions:\n$$\n\\mathbf{B}_N(\\mathbf{r}) = \\frac{\\mu_0 I}{4\\pi} \\sum_{i=0}^{N-1} \\frac{(\\mathbf{p}_{i+1} - \\mathbf{p}_i) \\times \\left(\\mathbf{r} - \\frac{\\mathbf{p}_i + \\mathbf{p}_{i+1}}{2}\\right)}{\\left\\|\\mathbf{r} - \\frac{\\mathbf{p}_i + \\mathbf{p}_{i+1}}{2}\\right\\|^3}\n$$\nThis formula is implemented in a function that computes $\\mathbf{B}_N$ at a given set of evaluation points. The given parameters are the coil radius $R_0 = 1.5\\,\\mathrm{m}$ and current $I = 5.0 \\times 10^4\\,\\mathrm{A}$. The total arc length is $L = 2\\pi R_0 = 3\\pi\\,\\mathrm{m}$. The evaluation points lie on a circle of radius $a = 0.4\\,\\mathrm{m}$ in the plane $z = z_0 = 0.3\\,\\mathrm{m}$. There are $M=64$ such points, given by $\\mathbf{r}_b(\\varphi_m) = (a\\cos\\varphi_m, a\\sin\\varphi_m, z_0)$ for $\\varphi_m = 2\\pi m/M$.\n\nTo assess the numerical error, a high-resolution reference field, $\\mathbf{B}_\\mathrm{ref}$, is computed using the same method but with a much larger number of segments, $N_\\mathrm{ref} = 8192$. For each $N$ in the test suite $\\{20, 40, 80, 160\\}$, the approximate field $\\mathbf{B}_N$ is computed at the $M=64$ boundary points. The RMS vector error is then calculated as:\n$$\nE(N) = \\sqrt{\\frac{1}{M}\\sum_{m=0}^{M-1} \\left\\| \\mathbf{B}_N(\\mathbf{r}_m) - \\mathbf{B}_\\mathrm{ref}(\\mathbf{r}_m) \\right\\|_2^2 }\n$$\nThe convergence behavior of this numerical scheme is characterized by the relationship $E(N) \\propto h^p$, where $h = L/N$ is the characteristic length scale (the arc-length of a segment) and $p$ is the order of convergence. This implies a linear relationship in a log-log plot: $\\log E(N) = p \\log h + C$. The order $p$ is estimated by performing a linear least-squares fit to the data points $(\\log h(N), \\log E(N))$ for the\nvalues of $N$ in the test suite. The slope of the resulting line is the estimated order of convergence, $p$. This numerical scheme, which is a form of midpoint rule on a polygonally approximated curve, is expected to exhibit second-order convergence, i.e., $p \\approx 2$.\n\nThe final algorithm is as follows:\n1. Define all physical and geometric constants: $\\mu_0, I, R_0, a, z_0, M$.\n2. Generate the $M=64$ evaluation points on the boundary circle.\n3. Implement a function `compute_B(N, eval_points)` that calculates $\\mathbf{B}_N$ using the summation formula derived above.\n4. Calculate the reference field $\\mathbf{B}_\\mathrm{ref}$ by calling `compute_B` with $N_\\mathrm{ref} = 8192$.\n5. For each $N \\in \\{20, 40, 80, 160\\}$:\n   a. Calculate the approximate field $\\mathbf{B}_N$ using `compute_B(N, eval_points)`.\n   b. Compute and store the RMS error $E(N)$ with respect to $\\mathbf{B}_\\mathrm{ref}$.\n   c. Store the corresponding segment arc-length $h(N) = 2\\pi R_0 / N$.\n6. Take the logarithm of the stored error and segment length arrays.\n7. Use linear regression (e.g., `numpy.polyfit`) on the log-log data to find the slope, which is the estimated convergence order $p$.\n8. Format and output the four error values and the convergence order $p$ as specified.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes magnetic field from a circular coil, evaluates error and convergence.\n    \"\"\"\n    # 1. DEFINE CONSTANTS AND PARAMETERS\n    # Physical constants and parameters\n    mu_0 = 4.0 * np.pi * 1.0e-7  # T*m/A\n    R0 = 1.5  # m\n    I = 5.0e4  # A\n    \n    # Pre-calculate constant factor in Biot-Savart law\n    B_FACTOR = (mu_0 * I) / (4.0 * np.pi) # This simplifies to I * 1e-7\n\n    # Boundary (evaluation) points parameters\n    a = 0.4  # m\n    z0 = 0.3  # m\n    M = 64  # Number of boundary points\n\n    # Discretization and analysis parameters\n    N_ref = 8192\n    N_test_suite = [20, 40, 80, 160]\n\n    # Total arc length of the coil\n    L = 2.0 * np.pi * R0\n\n    # 2. HELPER FUNCTION TO COMPUTE B-FIELD\n    def compute_B(N, r_eval_points):\n        \"\"\"\n        Calculates the magnetic field B at specified evaluation points.\n        \n        Args:\n            N (int): Number of straight segments to approximate the coil.\n            r_eval_points (np.ndarray): Array of shape (M, 3) containing the\n                                        coordinates of the M evaluation points.\n            \n        Returns:\n            np.ndarray: Array of shape (M, 3) with the B-field vectors.\n        \"\"\"\n        # Generate the N+1 vertices of the polygonal coil approximation\n        s_values = np.linspace(0, L, N + 1)\n        angles = s_values / R0\n        px = R0 * np.cos(angles)\n        py = R0 * np.sin(angles)\n        pz = np.zeros(N + 1)\n        # coil_points is a (N+1, 3) array of vertices\n        coil_points = np.vstack((px, py, pz)).T\n\n        # Initialize B-field array for all evaluation points.\n        B_field = np.zeros_like(r_eval_points)\n        \n        # Loop over each segment of the coil\n        for i in range(N):\n            p_i = coil_points[i]\n            p_i_plus_1 = coil_points[i+1]\n            \n            # Vector for the current segment\n            delta_L_i = p_i_plus_1 - p_i\n            \n            # Midpoint of the current segment\n            l_mid_i = (p_i + p_i_plus_1) / 2.0\n            \n            # Vector from segment midpoint to each evaluation point\n            # l_mid_i is (3,), r_eval_points is (M, 3). Broadcasting expands\n            # l_mid_i to (M, 3) for vectorized subtraction.\n            d_i = r_eval_points - l_mid_i  # Shape: (M, 3)\n            \n            # Magnitude of d_i for each evaluation point\n            d_i_norm = np.linalg.norm(d_i, axis=1) # Shape: (M,)\n            \n            # Cross product: delta_L_i x d_i\n            # delta_L_i is (3,), d_i is (M, 3).\n            # np.cross handles this broadcasting.\n            cross_product = np.cross(delta_L_i, d_i) # Shape: (M, 3)\n            \n            # Denominator term ||d_i||^3\n            # We need to reshape d_i_norm to (M,1) for broadcasting with the (M,3) cross product.\n            denominator = d_i_norm[:, np.newaxis]**3\n            \n            # Add this segment's contribution to the total B-field\n            B_field += cross_product / denominator\n            \n        return B_FACTOR * B_field\n\n    # 3. SETUP SIMULATION\n    # Generate the M evaluation points on the boundary circle\n    phi_m = np.linspace(0, 2 * np.pi, M, endpoint=False)\n    r_eval_x = a * np.cos(phi_m)\n    r_eval_y = a * np.sin(phi_m)\n    r_eval_z = np.full(M, z0)\n    r_boundary = np.vstack((r_eval_x, r_eval_y, r_eval_z)).T\n\n    # 4. RUN COMPUTATIONS\n    # Compute the high-resolution reference field\n    B_ref = compute_B(N_ref, r_boundary)\n\n    errors = []\n    h_values = []\n    \n    # Loop through the test suite for N\n    for N in N_test_suite:\n        # Compute the approximate field B_N\n        B_N = compute_B(N, r_boundary)\n        \n        # Compute the difference vector for each point\n        diff_vectors = B_N - B_ref\n        \n        # Compute the squared L2 norm of each difference vector\n        squared_norms = np.sum(diff_vectors**2, axis=1)\n        \n        # Compute the mean of the squared norms\n        mean_squared_error = np.mean(squared_norms)\n        \n        # The RMS error is the square root of the MSE\n        rms_error = np.sqrt(mean_squared_error)\n        errors.append(rms_error)\n        \n        # Store the corresponding segment arc-length h\n        h = L / N\n        h_values.append(h)\n\n    # 5. ESTIMATE CONVERGENCE ORDER\n    log_E = np.log(np.array(errors))\n    log_h = np.log(np.array(h_values))\n    \n    # Fit a line (polynomial of degree 1) to the log-log data\n    # The slope is the first element of the returned coefficients\n    p = np.polyfit(log_h, log_E, 1)[0]\n\n    # 6. FORMAT AND PRINT FINAL OUTPUT\n    results = errors + [p]\n    # Use '.8e' for robust scientific notation representation\n    print(f\"[{','.join(f'{val:.8e}' for val in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Stellarator performance is intrinsically linked to the geometry of its magnetic flux surfaces. This practice delves into the connection between the mathematical representation of a flux surface—a Fourier series—and its crucial physical properties . By computing the surface metric tensor and the rotational transform, $\\iota$, you will gain a concrete understanding of how shape dictates the behavior of magnetic field lines, a key element for plasma stability and transport.",
            "id": "4044780",
            "problem": "You are given a simplified, vacuum-like equilibrium model for a stellarator in which nested magnetic flux surfaces exist and are labeled by a flux label $\\psi$. On any fixed surface $\\psi=\\psi_0$, introduce straight-field-line coordinates $(\\theta,\\zeta)$ interpreted as poloidal and toroidal angles (in radians), respectively. A smooth, closed flux surface is represented spectrally in cylindrical coordinates $(R,\\phi,Z)$ by\n$$\nR(\\theta,\\zeta) \\;=\\; R_0 \\;+\\; \\sum_{m,n} R_{m n} \\cos\\!\\big(m\\,\\theta - n\\,\\zeta\\big),\n\\qquad\nZ(\\theta,\\zeta) \\;=\\; \\sum_{m,n} Z_{m n} \\sin\\!\\big(m\\,\\theta - n\\,\\zeta\\big),\n$$\nwith the geometric toroidal angle identified as $\\phi=\\zeta$. The Cartesian position vector is\n$$\n\\mathbf{r}(\\theta,\\zeta) \\;=\\; \\big( R(\\theta,\\zeta)\\cos\\zeta,\\; R(\\theta,\\zeta)\\sin\\zeta,\\; Z(\\theta,\\zeta) \\big).\n$$\nDefine the covariant basis vectors on the surface by $\\mathbf{e}_\\theta=\\partial\\mathbf{r}/\\partial\\theta$ and $\\mathbf{e}_\\zeta=\\partial\\mathbf{r}/\\partial\\zeta$, and the induced surface metric coefficients by\n$$\ng_{\\theta\\theta} \\;=\\; \\mathbf{e}_\\theta\\cdot\\mathbf{e}_\\theta,\\quad\ng_{\\theta\\zeta} \\;=\\; \\mathbf{e}_\\theta\\cdot\\mathbf{e}_\\zeta,\\quad\ng_{\\zeta\\zeta} \\;=\\; \\mathbf{e}_\\zeta\\cdot\\mathbf{e}_\\zeta.\n$$\nAssume a Clebsch representation of the magnetic field on the surface of the form\n$$\n\\mathbf{B} \\;=\\; \\nabla\\psi \\times \\nabla\\alpha(\\theta,\\zeta),\\qquad \\alpha(\\theta,\\zeta) \\;=\\; \\theta \\;-\\; N\\,\\zeta,\n$$\nwhere $N$ is a given integer field periodicity. Use only the above as the fundamental starting point.\n\nTasks:\n\n$1.$ From the spectral map $\\mathbf{r}(\\theta,\\zeta)$, derive and compute the metric coefficients $g_{ij}$ at specified $(\\theta,\\zeta)$ points by explicit differentiation of $R(\\theta,\\zeta)$ and $Z(\\theta,\\zeta)$ with respect to $\\theta$ and $\\zeta$.\n\n$2.$ Using the field representation $\\mathbf{B}=\\nabla\\psi\\times\\nabla\\alpha$ with $\\alpha=\\theta-N\\zeta$, derive an expression for the rotational transform $\\iota(\\psi)$ on the surface in terms of the local field-line slope in $(\\theta,\\zeta)$ and compute its value. Define the field-line pitch $p$ by $p=d\\zeta/d\\theta$ and express $p$ in terms of $\\iota(\\psi)$.\n\n$3.$ On the surface, the line element satisfies $ds^2 = g_{\\theta\\theta}\\,d\\theta^2 + 2 g_{\\theta\\zeta}\\,d\\theta\\,d\\zeta + g_{\\zeta\\zeta}\\,d\\zeta^2$. Along a field line, the differentials obey the relation you obtained in Task $2$. Using this, evaluate $ds/d\\zeta$ at the specified points.\n\nAll angles must be in radians. All lengths must be in meters, and $ds/d\\zeta$ must be reported in meters per radian. The rotational transform $\\iota(\\psi)$ and pitch $p$ are dimensionless. Your program must compute the requested quantities for the following test suite of flux surfaces and angle samples.\n\nTest suite:\n\nCase $1$:\n- $R_0 = 1.50\\ \\mathrm{m}$,\n- $R_{10} = 0.20\\ \\mathrm{m}$, $R_{11} = 0.05\\ \\mathrm{m}$,\n- $Z_{10} = 0.18\\ \\mathrm{m}$, $Z_{21} = 0.03\\ \\mathrm{m}$,\n- $N = 1$,\n- Evaluate at $(\\theta,\\zeta)$ equal to $(0.0,0.0)$, $(\\pi/3,\\ \\pi/7)$, and $(2.0,\\ 1.0)$.\n\nCase $2$:\n- $R_0 = 1.00\\ \\mathrm{m}$,\n- $R_{20} = 0.10\\ \\mathrm{m}$, $R_{12} = 0.04\\ \\mathrm{m}$, $R_{01} = 0.02\\ \\mathrm{m}$,\n- $Z_{11} = 0.06\\ \\mathrm{m}$, $Z_{21} = 0.03\\ \\mathrm{m}$, $Z_{02} = 0.01\\ \\mathrm{m}$,\n- $N = 2$,\n- Evaluate at $(\\theta,\\zeta)$ equal to $(0.0,0.0)$, $(\\pi/3,\\ \\pi/7)$, and $(2.0,\\ 1.0)$.\n\nCase $3$:\n- $R_0 = 1.20\\ \\mathrm{m}$,\n- $R_{10} = 0.15\\ \\mathrm{m}$, $R_{32} = 0.02\\ \\mathrm{m}$, $R_{21} = 0.04\\ \\mathrm{m}$,\n- $Z_{10} = 0.12\\ \\mathrm{m}$, $Z_{13} = 0.02\\ \\mathrm{m}$, $Z_{31} = 0.015\\ \\mathrm{m}$,\n- $N = 3$,\n- Evaluate at $(\\theta,\\zeta)$ equal to $(0.0,0.0)$, $(\\pi/3,\\ \\pi/7)$, and $(2.0,\\ 1.0)$.\n\nImplementation requirements:\n\n- For each case, compute:\n  - $\\iota(\\psi)$,\n  - $p$,\n  - $ds/d\\zeta$ at the three specified $(\\theta,\\zeta)$ points using the field-line relation between $d\\theta$ and $d\\zeta$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each case should contribute a sublist in the order $[\\iota(\\psi),\\ p,\\ (ds/d\\zeta)_{\\text{at point 1}},\\ (ds/d\\zeta)_{\\text{at point 2}},\\ (ds/d\\zeta)_{\\text{at point 3}}]$, and the final output must be the list of these three sublists, for example, $[[a_1,a_2,a_3,a_4,a_5],[b_1,b_2,b_3,b_4,b_5],[c_1,c_2,c_3,c_4,c_5]]$. All numeric entries must be floats in meters per radian where applicable, otherwise dimensionless floats. No extra text should be printed.",
            "solution": "The problem requires a geometric analysis of a stellarator flux surface defined by a spectral representation. We are tasked with deriving and computing several key quantities: the metric tensor of the surface, the rotational transform, the field-line pitch, and the differential arc length along a magnetic field line.\n\nThe solution proceeds in three stages, corresponding to the three tasks outlined in the problem statement. First, we derive the analytical expressions for the metric tensor components. Second, we determine the rotational transform and field-line pitch from the given magnetic field structure. Third, we combine these results to find the rate of change of arc length along a field line.\n\n### Task 1: Metric Tensor Calculation\n\nThe position vector $\\mathbf{r}$ of a point on the flux surface is given in Cartesian coordinates as:\n$$\n\\mathbf{r}(\\theta,\\zeta) = \\big( R(\\theta,\\zeta)\\cos\\zeta,\\; R(\\theta,\\zeta)\\sin\\zeta,\\; Z(\\theta,\\zeta) \\big)\n$$\nwhere $R(\\theta,\\zeta)$ and $Z(\\theta,\\zeta)$ are defined by their Fourier series.\n\nThe covariant basis vectors, $\\mathbf{e}_\\theta$ and $\\mathbf{e}_\\zeta$, are the partial derivatives of $\\mathbf{r}$ with respect to the surface coordinates $\\theta$ and $\\zeta$. Let $R_\\theta = \\partial R/\\partial\\theta$, $R_\\zeta = \\partial R/\\partial\\zeta$, $Z_\\theta = \\partial Z/\\partial\\theta$, and $Z_\\zeta = \\partial Z/\\partial\\zeta$. Applying the chain rule, we find:\n$$\n\\mathbf{e}_\\theta = \\frac{\\partial\\mathbf{r}}{\\partial\\theta} = \\left( \\frac{\\partial R}{\\partial\\theta}\\cos\\zeta, \\frac{\\partial R}{\\partial\\theta}\\sin\\zeta, \\frac{\\partial Z}{\\partial\\theta} \\right) = (R_\\theta \\cos\\zeta, R_\\theta \\sin\\zeta, Z_\\theta)\n$$\n$$\n\\mathbf{e}_\\zeta = \\frac{\\partial\\mathbf{r}}{\\partial\\zeta} = \\left( \\frac{\\partial R}{\\partial\\zeta}\\cos\\zeta - R\\sin\\zeta, \\frac{\\partial R}{\\partial\\zeta}\\sin\\zeta + R\\cos\\zeta, \\frac{\\partial Z}{\\partial\\zeta} \\right) = (R_\\zeta \\cos\\zeta - R \\sin\\zeta, R_\\zeta \\sin\\zeta + R \\cos\\zeta, Z_\\zeta)\n$$\n\nThe coefficients of the induced metric tensor, $g_{ij}$, are the dot products of these basis vectors:\n$g_{\\theta\\theta} = \\mathbf{e}_\\theta \\cdot \\mathbf{e}_\\theta = (R_\\theta \\cos\\zeta)^2 + (R_\\theta \\sin\\zeta)^2 + Z_\\theta^2 = R_\\theta^2(\\cos^2\\zeta + \\sin^2\\zeta) + Z_\\theta^2 = R_\\theta^2 + Z_\\theta^2$.\n$g_{\\theta\\zeta} = \\mathbf{e}_\\theta \\cdot \\mathbf{e}_\\zeta = R_\\theta\\cos\\zeta(R_\\zeta\\cos\\zeta - R\\sin\\zeta) + R_\\theta\\sin\\zeta(R_\\zeta\\sin\\zeta + R\\cos\\zeta) + Z_\\theta Z_\\zeta = R_\\theta R_\\zeta + Z_\\theta Z_\\zeta$.\n$g_{\\zeta\\zeta} = \\mathbf{e}_\\zeta \\cdot \\mathbf{e}_\\zeta = (R_\\zeta\\cos\\zeta - R\\sin\\zeta)^2 + (R_\\zeta\\sin\\zeta + R\\cos\\zeta)^2 + Z_\\zeta^2 = R^2 + R_\\zeta^2 + Z_\\zeta^2$.\n\nTo compute these, we need the partial derivatives of the spectral representations:\n$$\nR(\\theta,\\zeta) = R_0 + \\sum_{m,n} R_{m n} \\cos(m\\,\\theta - n\\,\\zeta)\n$$\n$$\nZ(\\theta,\\zeta) = \\sum_{m,n} Z_{m n} \\sin(m\\,\\theta - n\\,\\zeta)\n$$\nThe derivatives are:\n$$\nR_\\theta(\\theta,\\zeta) = -\\sum_{m,n} m\\,R_{mn} \\sin(m\\,\\theta - n\\,\\zeta)\n$$\n$$\nR_\\zeta(\\theta,\\zeta) = \\sum_{m,n} n\\,R_{mn} \\sin(m\\,\\theta - n\\,\\zeta)\n$$\n$$\nZ_\\theta(\\theta,\\zeta) = \\sum_{m,n} m\\,Z_{mn} \\cos(m\\,\\theta - n\\,\\zeta)\n$$\n$$\nZ_\\zeta(\\theta,\\zeta) = -\\sum_{m,n} n\\,Z_{mn} \\cos(m\\,\\theta - n\\,\\zeta)\n$$\nThese expressions allow for the direct computation of the metric coefficients at any point $(\\theta, \\zeta)$ on the surface.\n\n### Task 2: Rotational Transform and Field-Line Pitch\n\nThe magnetic field $\\mathbf{B}$ is given in a Clebsch representation as $\\mathbf{B} = \\nabla\\psi \\times \\nabla\\alpha$, where $\\psi$ is the flux label and $\\alpha(\\theta, \\zeta) = \\theta - N\\zeta$. A fundamental property of this representation is that the magnetic field lines lie on surfaces of constant $\\psi$ (the flux surfaces) and also on surfaces of constant $\\alpha$. Thus, along a magnetic field line, the differential $d\\alpha$ must be zero.\n$$\nd\\alpha = \\frac{\\partial\\alpha}{\\partial\\theta}d\\theta + \\frac{\\partial\\alpha}{\\partial\\zeta}d\\zeta = 0\n$$\nSubstituting the expression for $\\alpha$, we get:\n$$\n(1)d\\theta + (-N)d\\zeta = 0 \\quad\\implies\\quad d\\theta = N d\\zeta\n$$\nThe rotational transform, $\\iota(\\psi)$, is defined as the rate of change of the poloidal angle $\\theta$ with respect to the toroidal angle $\\zeta$ along a field line. In straight-field-line coordinates, this is simply the slope $d\\theta/d\\zeta$.\n$$\n\\iota(\\psi) = \\frac{d\\theta}{d\\zeta} = N\n$$\nThe problem provides $N$ as a constant integer for the surface, thus the rotational transform is constant and equal to $N$.\n\nThe field-line pitch, $p$, is defined as the reciprocal of the field-line slope in the $(\\theta, \\zeta)$ plane:\n$$\np = \\frac{d\\zeta}{d\\theta} = \\frac{1}{d\\theta/d\\zeta} = \\frac{1}{\\iota} = \\frac{1}{N}\n$$\nSince the test cases provide $N \\ge 1$, the pitch $p$ is well-defined.\n\n### Task 3: Differential Arc Length Along a Field Line\n\nThe square of the differential line element, $ds^2$, on the surface is given by the metric:\n$$\nds^2 = g_{\\theta\\theta}\\,d\\theta^2 + 2 g_{\\theta\\zeta}\\,d\\theta\\,d\\zeta + g_{\\zeta\\zeta}\\,d\\zeta^2\n$$\nTo find the arc length along a magnetic field line, we use the relationship $d\\theta = N d\\zeta$ derived in Task 2. Substituting this into the expression for $ds^2$:\n$$\nds^2 = g_{\\theta\\theta}(N d\\zeta)^2 + 2 g_{\\theta\\zeta}(N d\\zeta)d\\zeta + g_{\\zeta\\zeta}d\\zeta^2\n$$\nFactoring out $d\\zeta^2$, we obtain:\n$$\nds^2 = \\left( N^2 g_{\\theta\\theta} + 2N g_{\\theta\\zeta} + g_{\\zeta\\zeta} \\right) d\\zeta^2\n$$\nDividing by $d\\zeta^2$ and taking the square root gives the rate of change of arc length with respect to the toroidal angle $\\zeta$ along a field line:\n$$\n\\frac{ds}{d\\zeta} = \\sqrt{N^2 g_{\\theta\\theta} + 2N g_{\\theta\\zeta} + g_{\\zeta\\zeta}}\n$$\nThis quantity is evaluated locally, as the metric coefficients $g_{ij}$ are functions of $(\\theta, \\zeta)$.\n\n### Computational Algorithm\n\nThe numerical implementation will proceed as follows for each test case:\n1.  Store the input parameters: $R_0$, $N$, the dictionaries of non-zero $R_{mn}$ and $Z_{mn}$ coefficients, and the list of $(\\theta, \\zeta)$ evaluation points.\n2.  Compute the rotational transform $\\iota = N$ and the pitch $p = 1/N$.\n3.  For each specified point $(\\theta_{pt}, \\zeta_{pt})$:\n    a. Initialize $R = R_0$, $Z=0$, and the derivatives $R_\\theta, R_\\zeta, Z_\\theta, Z_\\zeta$ to $0$.\n    b. Loop through all unique $(m,n)$ mode pairs present in the $R_{mn}$ and $Z_{mn}$ coefficient sets.\n    c. For each mode $(m, n)$, calculate the phase angle $\\phi_{mn} = m\\theta_{pt} - n\\zeta_{pt}$.\n    d. Update the sums for $R$, $Z$, and their derivatives using the formulas derived above, adding the contribution from the current mode.\n    e. After iterating through all modes, compute the metric components $g_{\\theta\\theta} = R_\\theta^2 + Z_\\theta^2$, $g_{\\theta\\zeta} = R_\\theta R_\\zeta + Z_\\theta Z_\\zeta$, and $g_{\\zeta\\zeta} = R^2 + R_\\zeta^2 + Z_\\zeta^2$.\n    f. Calculate $\\frac{ds}{d\\zeta} = \\sqrt{N^2 g_{\\theta\\theta} + 2N g_{\\theta\\zeta} + g_{\\zeta\\zeta}}$.\n4.  Assemble the results for the case into a list: $[\\iota, p, (ds/d\\zeta)_1, (ds/d\\zeta)_2, (ds/d\\zeta)_3]$.\n5.  Collect the lists from all test cases and format them into the final required output string.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the stellarator surface geometry problem for a given set of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"R0\": 1.50,\n            \"N\": 1,\n            \"R_coeffs\": {(1, 0): 0.20, (1, 1): 0.05},\n            \"Z_coeffs\": {(1, 0): 0.18, (2, 1): 0.03},\n            \"points\": [(0.0, 0.0), (np.pi/3, np.pi/7), (2.0, 1.0)]\n        },\n        {\n            \"R0\": 1.00,\n            \"N\": 2,\n            \"R_coeffs\": {(2, 0): 0.10, (1, 2): 0.04, (0, 1): 0.02},\n            \"Z_coeffs\": {(1, 1): 0.06, (2, 1): 0.03, (0, 2): 0.01},\n            \"points\": [(0.0, 0.0), (np.pi/3, np.pi/7), (2.0, 1.0)]\n        },\n        {\n            \"R0\": 1.20,\n            \"N\": 3,\n            \"R_coeffs\": {(1, 0): 0.15, (3, 2): 0.02, (2, 1): 0.04},\n            \"Z_coeffs\": {(1, 0): 0.12, (1, 3): 0.02, (3, 1): 0.015},\n            \"points\": [(0.0, 0.0), (np.pi/3, np.pi/7), (2.0, 1.0)]\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        R0 = case[\"R0\"]\n        N = case[\"N\"]\n        R_coeffs = case[\"R_coeffs\"]\n        Z_coeffs = case[\"Z_coeffs\"]\n        points = case[\"points\"]\n\n        # Task 2: Compute rotational transform (iota) and pitch (p)\n        iota = float(N)\n        p = 1.0 / N\n\n        case_results = [iota, p]\n        \n        # Get the unique set of all (m,n) modes for this case\n        all_modes = set(R_coeffs.keys()) | set(Z_coeffs.keys())\n\n        for theta, zeta in points:\n            # Initialize sums for R, Z and their derivatives\n            R, Z = R0, 0.0\n            R_theta, R_zeta = 0.0, 0.0\n            Z_theta, Z_zeta = 0.0, 0.0\n\n            for m, n in all_modes:\n                phase_angle = m * theta - n * zeta\n                cos_phase = np.cos(phase_angle)\n                sin_phase = np.sin(phase_angle)\n                \n                Rmn = R_coeffs.get((m, n), 0.0)\n                Zmn = Z_coeffs.get((m, n), 0.0)\n\n                # Sum for R and Z\n                R += Rmn * cos_phase\n                Z += Zmn * sin_phase\n\n                # Sum for derivatives\n                R_theta -= m * Rmn * sin_phase\n                R_zeta += n * Rmn * sin_phase\n                Z_theta += m * Zmn * cos_phase\n                Z_zeta -= n * Zmn * cos_phase\n\n            # Task 1: Compute metric coefficients\n            g_thetatheta = R_theta**2 + Z_theta**2\n            g_thetazeta = R_theta * R_zeta + Z_theta * Z_zeta\n            g_zetazeta = R**2 + R_zeta**2 + Z_zeta**2\n\n            # Task 3: Compute ds/dzeta along the field line\n            ds_dzeta_sq = N**2 * g_thetatheta + 2 * N * g_thetazeta + g_zetazeta\n            ds_dzeta = np.sqrt(ds_dzeta_sq)\n            \n            case_results.append(ds_dzeta)\n\n        all_results.append(case_results)\n\n    # Format the final output string as specified.\n    result_str = \"[\" + \",\".join([f\"[{','.join(map(str, res))}]\" for res in all_results]) + \"]\"\n    print(result_str)\n\nsolve()\n```"
        },
        {
            "introduction": "Modern stellarator design is a complex multi-objective optimization problem, balancing physics performance with engineering constraints. This exercise simulates this process by constructing a composite objective function from several key performance metrics, including plasma confinement and coil complexity . Deriving and implementing the objective function and its gradient provides direct experience with the mathematical machinery that powers state-of-the-art stellarator optimization codes.",
            "id": "4044763",
            "problem": "You are given a simplified, yet physically consistent, surrogate model for a stellarator boundary shape and a coil set, together with a composite objective for shape optimization. The shape is represented by a truncated Fourier series on the boundary in cylindrical coordinates, while the coils are represented by a scalar radial Fourier series that modulates a circular torus. All angles are in radians. Your task is to implement a complete program that computes the composite objective and its gradient with respect to the boundary Fourier coefficients, derived from fundamental definitions, and evaluate it on a specified test suite.\n\nFundamental base and core definitions:\n\n- The boundary surface in cylindrical coordinates has a major radius component modeled by a truncated Fourier series in poloidal angle $\\,\\theta\\,$ and toroidal angle $\\,\\zeta\\,$ with field periodicity $\\,N_{\\text{fp}}\\,$ (number of field periods), as\n$$\nR(\\theta,\\zeta) = R_0 + \\sum_{(m,n)\\in \\mathcal{M}} a_{m,n}\\,\\cos\\!\\big(m\\,\\theta - n\\,N_{\\text{fp}}\\,\\zeta\\big),\n$$\nand a vertical component\n$$\nZ(\\theta,\\zeta) = \\sum_{(m,n)\\in \\mathcal{M}} b_{m,n}\\,\\sin\\!\\big(m\\,\\theta - n\\,N_{\\text{fp}}\\,\\zeta\\big).\n$$\nThe optimization variables for the boundary are the real Fourier coefficients $\\,a_{m,n}\\,$ and $\\,b_{m,n}\\,$ for modes $\\,\\mathcal{M}\\,$. The angles $\\,\\theta\\,$ and $\\,\\zeta\\,$ are $\\,2\\pi\\,$-periodic.\n\n- The coil centerline is modeled as a circular torus of angle $\\,\\phi\\in[0,2\\pi)\\,$ with a scalar radial modulation\n$$\nR_{\\text{c}}(\\phi) = R_{\\text{c},0} + \\sum_{k=1}^{K_{\\text{c}}} c_k \\cos(k\\,\\phi),\n$$\nwith the planar embedding\n$$\nx(\\phi) = R_{\\text{c}}(\\phi)\\cos\\phi,\\quad y(\\phi) = R_{\\text{c}}(\\phi)\\sin\\phi,\\quad z(\\phi)=0.\n$$\nThe coil smoothness penalty uses the curvature surrogate via the second derivative of $\\,R_{\\text{c}}(\\phi)\\,$ with respect to $\\,\\phi\\,$. The optimization variables for the coil are the Fourier coefficients $\\,c_k\\,$.\n\n- The composite objective is\n$$\nJ(\\mathbf{a},\\mathbf{b},\\mathbf{c}) = w_{\\epsilon}\\,\\epsilon_{\\text{eff}}(\\mathbf{a},\\mathbf{b}) \\;+\\; w_{\\iota}\\,E_{\\iota}(\\mathbf{a},\\mathbf{b}) \\;+\\; w_{\\text{coil}}\\,S_{\\text{coil}}(\\mathbf{c}),\n$$\nwhere $\\,w_{\\epsilon}>0\\,$, $\\,w_{\\iota}>0\\,$, and $\\,w_{\\text{coil}}>0\\,$ are user-specified scalar weights.\n\n- The effective ripple surrogate is defined by a quadratic form that increases with non-axisymmetric corrugations,\n$$\n\\epsilon_{\\text{eff}}(\\mathbf{a},\\mathbf{b}) \\;=\\; \\kappa_{\\epsilon}\\sum_{(m,n)\\in\\mathcal{M}} \\gamma_{m,n}\\,\\big(a_{m,n}^2+b_{m,n}^2\\big),\n$$\nwith\n$$\n\\gamma_{m,n} \\;=\\; \\frac{m^2 + (n\\,N_{\\text{fp}})^2}{A^2},\n$$\nwhere $\\,A>0\\,$ is a given aspect-ratio-like scale and $\\,\\kappa_{\\epsilon}>0\\,$ is a given normalization.\n\n- The rotational transform profile surrogate $\\,\\iota(s)\\,$, as a function of normalized toroidal flux coordinate $\\,s\\in[0,1]\\,$, is defined by\n$$\n\\iota(s) \\;=\\; \\iota_{\\text{base}} \\;+\\; \\sum_{(m,n)\\in\\mathcal{M}} \\Big(\\alpha_{m,n}\\,a_{m,n}\\,s^{m} \\;+\\; \\beta_{m,n}\\,b_{m,n}\\,s^{m+1}\\Big),\n$$\nwhere\n$$\n\\alpha_{m,n} \\;=\\; \\frac{\\kappa_R}{1+(n\\,N_{\\text{fp}})^2}\\left(\\frac{m}{R_0}\\right)^2,\\qquad\n\\beta_{m,n} \\;=\\; \\frac{\\kappa_Z}{1+(n\\,N_{\\text{fp}})^2}\\left(\\frac{m}{R_0}\\right).\n$$\nThe constants $\\,\\kappa_R>0\\,$ and $\\,\\kappa_Z>0\\,$ encode the linear sensitivity of the rotational transform to boundary deformations in this surrogate; $\\,R_0>0\\,$ is the major radius scale. The target rotational transform profile is a quadratic polynomial\n$$\n\\iota_{\\text{target}}(s) \\;=\\; t_0 + t_1\\,s + t_2\\,s^2,\n$$\nwith given scalars $\\,t_0,t_1,t_2\\,$. The profile error is the squared $\\,L^2\\,$-distance on $[0,1]$,\n$$\nE_{\\iota}(\\mathbf{a},\\mathbf{b}) \\;=\\; \\int_{0}^{1}\\Big(\\iota(s) - \\iota_{\\text{target}}(s)\\Big)^2\\,ds.\n$$\n\n- The coil smoothness penalty is defined through the square of the second derivative of $\\,R_{\\text{c}}(\\phi)\\,$,\n$$\nS_{\\text{coil}}(\\mathbf{c}) \\;=\\; \\int_{0}^{2\\pi}\\left(\\frac{d^2 R_{\\text{c}}}{d\\phi^2}(\\phi)\\right)^2\\,d\\phi.\n$$\n\nTasks:\n\n1. Starting from the definitions above and standard properties of trigonometric and monomial integrals, derive explicit expressions for the composite objective $\\,J(\\mathbf{a},\\mathbf{b},\\mathbf{c})\\,$ and its gradient with respect to each optimization variable $\\,a_{m,n}\\,$, $\\,b_{m,n}\\,$, and $\\,c_k\\,$. Use only the identities\n$$\n\\int_{0}^{2\\pi}\\cos(k\\phi)\\cos(\\ell\\phi)\\,d\\phi \\;=\\; \\begin{cases}\n\\pi, & k=\\ell\\ge 1,\\\\\n0, & k\\ne \\ell,\n\\end{cases}\n$$\nand\n$$\n\\int_{0}^{1} s^{p}\\,ds \\;=\\; \\frac{1}{p+1},\\quad p>-1,\n$$\ntogether with linearity of integration and the binomial-free monomial product integral\n$$\n\\int_{0}^{1} s^{p+q}\\,ds \\;=\\; \\frac{1}{p+q+1}.\n$$\n\n2. Implement a program that evaluates $\\,J\\,$ and $\\,\\nabla J\\,$ for a given set of parameters and variables. The program must output, for each test case, a triple consisting of:\n   - the scalar objective value $\\,J\\,$,\n   - the Euclidean norm $\\,\\|\\nabla J\\|_2\\,$,\n   - a boolean indicating whether stationarity holds within tolerance $\\,\\tau=10^{-10}\\,$, i.e., whether $\\,\\|\\nabla J\\|_2 < \\tau\\,$.\n\n3. Angles $\\,\\theta\\,$, $\\,\\zeta\\,$, and $\\,\\phi\\,$ are in radians. All quantities in this problem are dimensionless under the surrogate scalings provided; no physical units are required in the output.\n\nTest suite:\n\nFor each test, you are given $\\,N_{\\text{fp}}\\,$, $\\,R_0\\,$, $\\,A\\,$, $\\,\\kappa_R\\,$, $\\,\\kappa_Z\\,$, $\\,\\kappa_{\\epsilon}\\,$, weights $\\,w_{\\epsilon}\\,$, $\\,w_{\\iota}\\,$, $\\,w_{\\text{coil}}\\,$, the mode set $\\,\\mathcal{M}\\,$, boundary coefficients $\\,\\{a_{m,n}\\}\\,$ and $\\,\\{b_{m,n}\\}\\,$ aligned with $\\,\\mathcal{M}\\,$, coil coefficients $\\,\\{c_k\\}\\,$ for $\\,k=1,\\dots,K_{\\text{c}}\\,$, and the profile parameters $\\,\\iota_{\\text{base}}\\,$, $\\,t_0\\,$, $\\,t_1\\,$, $\\,t_2\\,$.\n\n- Test case $\\,1\\,$:\n  - $\\,N_{\\text{fp}}=5\\,$, $\\,R_0=5.5\\,$, $\\,A=8.0\\,$, $\\,\\kappa_R=0.12\\,$, $\\,\\kappa_Z=0.07\\,$, $\\,\\kappa_{\\epsilon}=0.03\\,$.\n  - $\\,w_{\\epsilon}=1.0\\,$, $\\,w_{\\iota}=5.0\\,$, $\\,w_{\\text{coil}}=0.1\\,$.\n  - $\\,\\mathcal{M}=\\{(1,0),(2,1)\\}\\,$.\n  - $\\,\\mathbf{a}=[0.02,-0.01]\\,$, $\\,\\mathbf{b}=[0.015,0.0]\\,$.\n  - Coil coefficients $\\,\\mathbf{c}=[0.1,-0.02,0.005]\\,$ corresponding to $\\,k=1,2,3\\,$.\n  - $\\,\\iota_{\\text{base}}=0.3\\,$, $\\,t_0=0.35\\,$, $\\,t_1=0.2\\,$, $\\,t_2=-0.1\\,$.\n\n- Test case $\\,2\\,$:\n  - $\\,N_{\\text{fp}}=5\\,$, $\\,R_0=5.5\\,$, $\\,A=8.0\\,$, $\\,\\kappa_R=0.12\\,$, $\\,\\kappa_Z=0.07\\,$, $\\,\\kappa_{\\epsilon}=0.03\\,$.\n  - $\\,w_{\\epsilon}=0.2\\,$, $\\,w_{\\iota}=10.0\\,$, $\\,w_{\\text{coil}}=0.0\\,$.\n  - $\\,\\mathcal{M}=\\{(1,0),(2,1)\\}\\,$.\n  - $\\,\\mathbf{a}=[0.0,0.0]\\,$, $\\,\\mathbf{b}=[0.0,0.0]\\,$.\n  - Coil coefficients $\\,\\mathbf{c}=[0.0,0.0]\\,$ corresponding to $\\,k=1,2\\,$.\n  - $\\,\\iota_{\\text{base}}=0.32\\,$, $\\,t_0=0.3\\,$, $\\,t_1=0.0\\,$, $\\,t_2=0.0\\,$.\n\n- Test case $\\,3\\,$:\n  - $\\,N_{\\text{fp}}=4\\,$, $\\,R_0=6.2\\,$, $\\,A=10.0\\,$, $\\,\\kappa_R=0.1\\,$, $\\,\\kappa_Z=0.08\\,$, $\\,\\kappa_{\\epsilon}=0.05\\,$.\n  - $\\,w_{\\epsilon}=0.0\\,$, $\\,w_{\\iota}=0.0\\,$, $\\,w_{\\text{coil}}=2.0\\,$.\n  - $\\,\\mathcal{M}=\\{(1,1)\\}\\,$.\n  - $\\,\\mathbf{a}=[0.1]\\,$, $\\,\\mathbf{b}=[-0.05]\\,$.\n  - Coil coefficients $\\,\\mathbf{c}=[0.02,0.03]\\,$ corresponding to $\\,k=1,2\\,$.\n  - $\\,\\iota_{\\text{base}}=0.0\\,$, $\\,t_0=0.0\\,$, $\\,t_1=0.0\\,$, $\\,t_2=0.0\\,$.\n\n- Test case $\\,4\\,$:\n  - $\\,N_{\\text{fp}}=8\\,$, $\\,R_0=4.8\\,$, $\\,A=6.0\\,$, $\\,\\kappa_R=0.14\\,$, $\\,\\kappa_Z=0.06\\,$, $\\,\\kappa_{\\epsilon}=0.02\\,$.\n  - $\\,w_{\\epsilon}=1.5\\,$, $\\,w_{\\iota}=2.5\\,$, $\\,w_{\\text{coil}}=0.05\\,$.\n  - $\\,\\mathcal{M}=\\{(0,2),(1,0),(3,2)\\}\\,$.\n  - $\\,\\mathbf{a}=[0.01,-0.02,0.005]\\,$ aligned with $\\,\\mathcal{M}\\,$, $\\,\\mathbf{b}=[-0.012,0.004,0.0]\\,$.\n  - Coil coefficients $\\,\\mathbf{c}=[0.05,-0.01,0.002,-0.0005]\\,$ corresponding to $\\,k=1,2,3,4\\,$.\n  - $\\,\\iota_{\\text{base}}=0.4\\,$, $\\,t_0=0.38\\,$, $\\,t_1=0.05\\,$, $\\,t_2=0.02\\,$.\n\nFinal output format:\n\nYour program should produce a single line of output containing the results for the test suite as a comma-separated list enclosed in square brackets, where each entry is itself a list of the form $[J,\\|\\nabla J\\|_2,\\text{stationary}]$. For example, the output must look like\n$$\n\\big[\\,[J_1,\\|\\nabla J\\|_{2,1},\\text{True}],\\;[J_2,\\|\\nabla J\\|_{2,2},\\text{False}],\\;\\dots\\big].\n$$\nNo additional text must be printed.",
            "solution": "The user has provided a valid, well-posed problem in computational plasma physics, specifically stellarator shape optimization using surrogate models. The task is to derive and implement the calculation of a composite objective function and its gradient.\n\nThe composite objective function $J$ is a weighted sum of three terms: an effective ripple surrogate $\\epsilon_{\\text{eff}}$, a rotational transform profile error $E_{\\iota}$, and a coil smoothness penalty $S_{\\text{coil}}$.\n$$\nJ(\\mathbf{a},\\mathbf{b},\\mathbf{c}) = w_{\\epsilon}\\,\\epsilon_{\\text{eff}}(\\mathbf{a},\\mathbf{b}) \\;+\\; w_{\\iota}\\,E_{\\iota}(\\mathbf{a},\\mathbf{b}) \\;+\\; w_{\\text{coil}}\\,S_{\\text{coil}}(\\mathbf{c})\n$$\nThe optimization variables are the sets of Fourier coefficients $\\mathbf{a} = \\{a_{m,n}\\}$, $\\mathbf{b} = \\{b_{m,n}\\}$ for the plasma boundary shape, and $\\mathbf{c} = \\{c_k\\}$ for the coil shape. Our task is to derive explicit expressions for $J$ and its gradient vector $\\nabla J$, whose components are the partial derivatives with respect to each optimization variable.\n\nDue to the linearity of differentiation, the gradient of the total objective $J$ is the weighted sum of the gradients of its components:\n$$\n\\nabla J \\;=\\; w_{\\epsilon}\\,\\nabla\\epsilon_{\\text{eff}} \\;+\\; w_{\\iota}\\,\\nabla E_{\\iota} \\;+\\; w_{\\text{coil}}\\,\\nabla S_{\\text{coil}}\n$$\nWe will derive the explicit form for each term and its gradient separately.\n\n**1. Effective Ripple Surrogate Term ($\\epsilon_{\\text{eff}}$)**\n\nThe effective ripple is given as a simple positive-definite quadratic form of the boundary coefficients:\n$$\n\\epsilon_{\\text{eff}}(\\mathbf{a},\\mathbf{b}) \\;=\\; \\kappa_{\\epsilon}\\sum_{(m,n)\\in\\mathcal{M}} \\gamma_{m,n}\\,\\big(a_{m,n}^2+b_{m,n}^2\\big)\n$$\nwith mode-dependent weights $\\gamma_{m,n} \\;=\\; \\frac{m^2 + (n\\,N_{\\text{fp}})^2}{A^2}$. The contribution to the total objective is $J_{\\epsilon} = w_{\\epsilon} \\epsilon_{\\text{eff}}$. This expression is already explicit and requires no further simplification.\n\nThe partial derivatives with respect to a specific coefficient $a_{m',n'}$ or $b_{m',n'}$ are straightforward, as the sum collapses due to the orthogonality of the variables:\n$$\n\\frac{\\partial \\epsilon_{\\text{eff}}}{\\partial a_{m',n'}} \\;=\\; \\kappa_{\\epsilon} \\sum_{(m,n)\\in\\mathcal{M}} \\gamma_{m,n} \\frac{\\partial}{\\partial a_{m',n'}}(a_{m,n}^2+b_{m,n}^2) \\;=\\; \\kappa_{\\epsilon} \\gamma_{m',n'} (2a_{m',n'})\n$$\nSimilarly,\n$$\n\\frac{\\partial \\epsilon_{\\text{eff}}}{\\partial b_{m',n'}} \\;=\\; \\kappa_{\\epsilon} \\gamma_{m',n'} (2b_{m',n'})\n$$\nThis term does not depend on the coil coefficients $\\mathbf{c}$, so $\\frac{\\partial \\epsilon_{\\text{eff}}}{\\partial c_k} = 0$ for all $k$.\n\nThe gradient components for the total objective contributed by this term are:\n$$\n\\frac{\\partial J_{\\epsilon}}{\\partial a_{m,n}} = 2 w_{\\epsilon} \\kappa_{\\epsilon} \\gamma_{m,n} a_{m,n} \\quad \\text{and} \\quad \\frac{\\partial J_{\\epsilon}}{\\partial b_{m,n}} = 2 w_{\\epsilon} \\kappa_{\\epsilon} \\gamma_{m,n} b_{m,n}\n$$\n\n**2. Coil Smoothness Penalty ($S_{\\text{coil}}$)**\n\nThe coil smoothness penalty is defined by the integral of the squared second derivative of the coil's radial function $R_{\\text{c}}(\\phi) = R_{\\text{c},0} + \\sum_{k=1}^{K_{\\text{c}}} c_k \\cos(k\\,\\phi)$:\n$$\nS_{\\text{coil}}(\\mathbf{c}) \\;=\\; \\int_{0}^{2\\pi}\\left(\\frac{d^2 R_{\\text{c}}}{d\\phi^2}(\\phi)\\right)^2\\,d\\phi\n$$\nFirst, we compute the second derivative:\n$$\n\\frac{d R_{\\text{c}}}{d\\phi} = -\\sum_{k=1}^{K_{\\text{c}}} k\\,c_k\\,\\sin(k\\,\\phi) \\quad \\implies \\quad \\frac{d^2 R_{\\text{c}}}{d\\phi^2} = -\\sum_{k=1}^{K_{\\text{c}}} k^2\\,c_k\\,\\cos(k\\,\\phi)\n$$\nSubstituting this into the integral for $S_{\\text{coil}}$:\n$$\nS_{\\text{coil}} = \\int_{0}^{2\\pi} \\left( \\sum_{k=1}^{K_{\\text{c}}} k^2 c_k \\cos(k\\phi) \\right) \\left( \\sum_{\\ell=1}^{K_{\\text{c}}} \\ell^2 c_{\\ell} \\cos(\\ell\\phi) \\right) d\\phi = \\sum_{k=1}^{K_c} \\sum_{\\ell=1}^{K_c} k^2 \\ell^2 c_k c_\\ell \\int_{0}^{2\\pi} \\cos(k\\phi) \\cos(\\ell\\phi) \\,d\\phi\n$$\nUsing the provided identity $\\int_{0}^{2\\pi}\\cos(k\\phi)\\cos(\\ell\\phi)\\,d\\phi = \\pi \\delta_{k\\ell}$ for $k, \\ell \\ge 1$, where $\\delta_{k\\ell}$ is the Kronecker delta, the integral is non-zero only for $k=\\ell$. The expression simplifies to:\n$$\nS_{\\text{coil}} = \\sum_{k=1}^{K_{\\text{c}}} k^4 c_k^2 (\\pi) = \\pi\\sum_{k=1}^{K_{\\text{c}}} k^4 c_k^2\n$$\nThe contribution to the total objective is $J_{\\text{coil}} = w_{\\text{coil}} S_{\\text{coil}}$. This term depends only on $\\mathbf{c}$.\nThe gradient with respect to a coefficient $c_{k'}$ is:\n$$\n\\frac{\\partial S_{\\text{coil}}}{\\partial c_{k'}} = \\pi \\frac{\\partial}{\\partial c_{k'}} \\sum_{k=1}^{K_{\\text{c}}} k^4 c_k^2 = 2\\pi (k')^4 c_{k'}\n$$\nThe gradient component for the total objective is:\n$$\n\\frac{\\partial J_{\\text{coil}}}{\\partial c_k} = 2\\pi w_{\\text{coil}} k^4 c_k\n$$\n\n**3. Rotational Transform Profile Error ($E_{\\iota}$)**\n\nThe term $E_{\\iota}$ is the squared $L^2$-norm of the difference between the surrogate rotational transform $\\iota(s)$ and a target profile $\\iota_{\\text{target}}(s)$:\n$$\nE_{\\iota}(\\mathbf{a},\\mathbf{b}) \\;=\\; \\int_{0}^{1}\\Big(\\iota(s) - \\iota_{\\text{target}}(s)\\Big)^2\\,ds\n$$\nLet the difference be $\\Delta\\iota(s) = \\iota(s) - \\iota_{\\text{target}}(s)$. Using the provided definitions:\n$$\n\\Delta\\iota(s) = (\\iota_{\\text{base}} - t_0) - t_1 s - t_2 s^2 + \\sum_{(m,n)\\in\\mathcal{M}} \\Big(\\alpha_{m,n}\\,a_{m,n}\\,s^{m} + \\beta_{m,n}\\,b_{m,n}\\,s^{m+1}\\Big)\n$$\nTo evaluate $E_\\iota$ and its gradient, it is convenient to first define the auxiliary integrals $I_k = \\int_0^1 \\Delta\\iota(s) s^k ds$. By linearity of integration and using the identity $\\int_0^1 s^p ds = \\frac{1}{p+1}$:\n$$\nI_k = \\int_0^1 \\left( (\\iota_{\\text{base}} - t_0)s^k - t_1 s^{k+1} - t_2 s^{k+2} + \\sum_{(m,n)\\in\\mathcal{M}} (\\alpha_{m,n} a_{m,n} s^{m+k} + \\beta_{m,n} b_{m,n} s^{m+1+k}) \\right) ds\n$$\n$$\nI_k = \\frac{\\iota_{\\text{base}} - t_0}{k+1} - \\frac{t_1}{k+2} - \\frac{t_2}{k+3} + \\sum_{(m,n)\\in\\mathcal{M}} \\left( \\frac{\\alpha_{m,n} a_{m,n}}{m+k+1} + \\frac{\\beta_{m,n} b_{m,n}}{m+k+2} \\right)\n$$\nThe value of $E_\\iota$ can be computed by expanding its definition and using the $I_k$ integrals:\n$$\nE_\\iota = \\int_0^1 \\Delta\\iota(s) \\Delta\\iota(s) ds = \\int_0^1 \\Delta\\iota(s) \\left( (\\iota_{\\text{base}} - t_0) - t_1 s - t_2 s^2 + \\sum_{(m,n)\\in\\mathcal{M}} \\dots \\right) ds\n$$\n$$\nE_\\iota = (\\iota_{\\text{base}} - t_0)I_0 - t_1 I_1 - t_2 I_2 + \\sum_{(m,n)\\in\\mathcal{M}} \\left( a_{m,n} \\alpha_{m,n} I_m + b_{m,n} \\beta_{m,n} I_{m+1} \\right)\n$$\nThe gradient of $E_\\iota$ is found using the chain rule. For a coefficient $a_{m',n'}$:\n$$\n\\frac{\\partial E_\\iota}{\\partial a_{m',n'}} = \\int_0^1 2\\Delta\\iota(s) \\frac{\\partial \\Delta\\iota(s)}{\\partial a_{m',n'}} ds\n$$\nSince $\\frac{\\partial \\Delta\\iota(s)}{\\partial a_{m',n'}} = \\alpha_{m',n'}s^{m'}$, we get:\n$$\n\\frac{\\partial E_\\iota}{\\partial a_{m',n'}} = 2\\alpha_{m',n'} \\int_0^1 \\Delta\\iota(s) s^{m'} ds = 2\\alpha_{m',n'} I_{m'}\n$$\nSimilarly, since $\\frac{\\partial \\Delta\\iota(s)}{\\partial b_{m',n'}} = \\beta_{m',n'}s^{m'+1}$:\n$$\n\\frac{\\partial E_\\iota}{\\partial b_{m',n'}} = 2\\beta_{m',n'} \\int_0^1 \\Delta\\iota(s) s^{m'+1} ds = 2\\beta_{m',n'} I_{m'+1}\n$$\nThe gradient components for the total objective contributed by this term are:\n$$\n\\frac{\\partial J_{\\iota}}{\\partial a_{m,n}} = 2 w_{\\iota} \\alpha_{m,n} I_m \\quad \\text{and} \\quad \\frac{\\partial J_{\\iota}}{\\partial b_{m,n}} = 2 w_{\\iota} \\beta_{m,n} I_{m+1}\n$$\n\n**4. Summary of Objective and Gradient**\n\nThe total objective function $J$ is the sum of the three contributions:\n$$\nJ = w_{\\epsilon} \\kappa_{\\epsilon} \\sum_{(m,n)\\in\\mathcal{M}} \\gamma_{m,n} (a_{m,n}^2 + b_{m,n}^2) \\;+\\; w_{\\iota} E_{\\iota} \\;+\\; w_{\\text{coil}} \\pi \\sum_{k=1}^{K_c} k^4 c_k^2\n$$\nThe total gradient components are the sum of the contributions from each term:\n$$\n\\frac{\\partial J}{\\partial a_{m,n}} = 2 w_{\\epsilon} \\kappa_{\\epsilon} \\gamma_{m,n} a_{m,n} + 2 w_{\\iota} \\alpha_{m,n} I_m\n$$\n$$\n\\frac{\\partial J}{\\partial b_{m,n}} = 2 w_{\\epsilon} \\kappa_{\\epsilon} \\gamma_{m,n} b_{m,n} + 2 w_{\\iota} \\beta_{m,n} I_{m+1}\n$$\n$$\n\\frac{\\partial J}{\\partial c_k} = 2\\pi w_{\\text{coil}} k^4 c_k\n$$\nThe overall algorithm involves first computing the necessary $\\alpha$, $\\beta$, $\\gamma$ coefficients, then the $I_k$ integrals, and finally assembling the total objective $J$ and the components of its gradient $\\nabla J$. The Euclidean norm $\\|\\nabla J\\|_2$ is then computed from this gradient vector.",
            "answer": "```python\nimport numpy as np\n\ndef compute_J_and_grad(Nfp, R0, A, kR, kZ, ke, we, wi, wc, M, a_coeffs, b_coeffs, c_coeffs, ibase, t0, t1, t2):\n    \"\"\"\n    Computes the composite objective J and its gradient norm for a single test case.\n    \"\"\"\n    # Tolerance for stationarity check\n    tau = 1e-10\n\n    # Map list coefficients to dictionaries keyed by mode/index for clarity\n    a = {mode: coeff for mode, coeff in zip(M, a_coeffs)}\n    b = {mode: coeff for mode, coeff in zip(M, b_coeffs)}\n    c = {k: coeff for k, coeff in enumerate(c_coeffs, 1)}\n\n    # Initialize objective and gradient components\n    J = 0.0\n    grad_a = {mode: 0.0 for mode in M}\n    grad_b = {mode: 0.0 for mode in M}\n    grad_c = {k: 0.0 for k in c.keys()}\n\n    # --- 1. Effective Ripple Term (epsilon_eff) ---\n    if we > 0.0:\n        eps_eff = 0.0\n        for m, n in M:\n            gamma_mn = (m**2 + (n * Nfp)**2) / A**2\n            a_mn = a.get((m, n), 0.0)\n            b_mn = b.get((m, n), 0.0)\n            \n            eps_eff += gamma_mn * (a_mn**2 + b_mn**2)\n            \n            # Gradient contribution\n            grad_a[(m, n)] += we * ke * 2.0 * gamma_mn * a_mn\n            grad_b[(m, n)] += we * ke * 2.0 * gamma_mn * b_mn\n            \n        J += we * ke * eps_eff\n\n    # --- 2. Coil Smoothness Term (S_coil) ---\n    if wc > 0.0:\n        S_coil = 0.0\n        for k, c_k in c.items():\n            S_coil += (k**4) * (c_k**2)\n            \n            # Gradient contribution\n            grad_c[k] += wc * np.pi * 2.0 * (k**4) * c_k\n            \n        J += wc * np.pi * S_coil\n\n    # --- 3. Rotational Transform Error Term (E_iota) ---\n    if wi > 0.0:\n        # Pre-compute alpha and beta coefficients\n        alpha = {}\n        beta = {}\n        for m, n in M:\n            nNfp_sq = (n * Nfp)**2\n            m_over_R0 = m / R0\n            alpha[(m, n)] = kR / (1.0 + nNfp_sq) * (m_over_R0**2)\n            beta[(m, n)] = kZ / (1.0 + nNfp_sq) * m_over_R0\n\n        # Determine which I_k integrals are needed\n        needed_powers = {0, 1, 2}\n        for m, n in M:\n            needed_powers.add(m)\n            needed_powers.add(m + 1)\n        \n        # Compute I_k integrals\n        I = {}\n        C0 = ibase - t0\n        for k in needed_powers:\n            sum_term = 0.0\n            for m, n in M:\n                a_mn = a.get((m, n), 0.0)\n                b_mn = b.get((m, n), 0.0)\n                sum_term += (alpha[(m, n)] * a_mn) / (m + k + 1)\n                sum_term += (beta[(m, n)] * b_mn) / (m + k + 2)\n\n            I[k] = C0 / (k + 1) - t1 / (k + 2) - t2 / (k + 3) + sum_term\n\n        # Compute E_iota\n        E_iota_sum = 0.0\n        for m, n in M:\n            a_mn = a.get((m, n), 0.0)\n            b_mn = b.get((m, n), 0.0)\n            E_iota_sum += a_mn * alpha[(m, n)] * I[m]\n            E_iota_sum += b_mn * beta[(m, n)] * I[m + 1]\n\n        E_iota = C0 * I[0] - t1 * I[1] - t2 * I[2] + E_iota_sum\n        J += wi * E_iota\n\n        # Gradient contributions\n        for m, n in M:\n            grad_a[(m, n)] += wi * 2.0 * alpha[(m, n)] * I[m]\n            grad_b[(m, n)] += wi * 2.0 * beta[(m, n)] * I[m + 1]\n\n    # --- 4. Final Gradient Norm Calculation ---\n    grad_vector = []\n    # Ensure a consistent order for reproducibility\n    sorted_modes = sorted(M)\n    for m, n in sorted_modes:\n        grad_vector.append(grad_a[(m,n)])\n    for m, n in sorted_modes:\n        grad_vector.append(grad_b[(m,n)])\n    sorted_k = sorted(c.keys())\n    for k in sorted_k:\n        grad_vector.append(grad_c[k])\n\n    grad_norm = np.linalg.norm(grad_vector)\n    is_stationary = grad_norm  tau\n    \n    return [J, grad_norm, is_stationary]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {\n            \"Nfp\": 5, \"R0\": 5.5, \"A\": 8.0, \"kR\": 0.12, \"kZ\": 0.07, \"ke\": 0.03,\n            \"we\": 1.0, \"wi\": 5.0, \"wc\": 0.1,\n            \"M\": [(1, 0), (2, 1)],\n            \"a\": [0.02, -0.01], \"b\": [0.015, 0.0],\n            \"c\": [0.1, -0.02, 0.005],\n            \"ibase\": 0.3, \"t0\": 0.35, \"t1\": 0.2, \"t2\": -0.1\n        },\n        # Test case 2\n        {\n            \"Nfp\": 5, \"R0\": 5.5, \"A\": 8.0, \"kR\": 0.12, \"kZ\": 0.07, \"ke\": 0.03,\n            \"we\": 0.2, \"wi\": 10.0, \"wc\": 0.0,\n            \"M\": [(1, 0), (2, 1)],\n            \"a\": [0.0, 0.0], \"b\": [0.0, 0.0],\n            \"c\": [0.0, 0.0],\n            \"ibase\": 0.32, \"t0\": 0.3, \"t1\": 0.0, \"t2\": 0.0\n        },\n        # Test case 3\n        {\n            \"Nfp\": 4, \"R0\": 6.2, \"A\": 10.0, \"kR\": 0.1, \"kZ\": 0.08, \"ke\": 0.05,\n            \"we\": 0.0, \"wi\": 0.0, \"wc\": 2.0,\n            \"M\": [(1, 1)],\n            \"a\": [0.1], \"b\": [-0.05],\n            \"c\": [0.02, 0.03],\n            \"ibase\": 0.0, \"t0\": 0.0, \"t1\": 0.0, \"t2\": 0.0\n        },\n        # Test case 4\n        {\n            \"Nfp\": 8, \"R0\": 4.8, \"A\": 6.0, \"kR\": 0.14, \"kZ\": 0.06, \"ke\": 0.02,\n            \"we\": 1.5, \"wi\": 2.5, \"wc\": 0.05,\n            \"M\": [(0, 2), (1, 0), (3, 2)],\n            \"a\": [0.01, -0.02, 0.005], \"b\": [-0.012, 0.004, 0.0],\n            \"c\": [0.05, -0.01, 0.002, -0.0005],\n            \"ibase\": 0.4, \"t0\": 0.38, \"t1\": 0.05, \"t2\": 0.02\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_J_and_grad(\n            case[\"Nfp\"], case[\"R0\"], case[\"A\"],\n            case[\"kR\"], case[\"kZ\"], case[\"ke\"],\n            case[\"we\"], case[\"wi\"], case[\"wc\"],\n            case[\"M\"], case[\"a\"], case[\"b\"], case[\"c\"],\n            case[\"ibase\"], case[\"t0\"], case[\"t1\"], case[\"t2\"]\n        )\n        results.append(result)\n\n    # Format the final output string exactly as required\n    results_str = \",\".join(map(str, results))\n    print(f\"[{results_str}]\")\n\nsolve()\n```"
        }
    ]
}