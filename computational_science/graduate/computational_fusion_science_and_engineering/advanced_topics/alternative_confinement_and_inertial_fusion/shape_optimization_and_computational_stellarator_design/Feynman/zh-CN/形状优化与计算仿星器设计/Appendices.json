{
    "hands_on_practices": [
        {
            "introduction": "仿星器中的磁场主要由外部线圈产生。准确而高效地计算该磁场是仿星器设计中的一项基础任务。此实践将指导您完成毕奥-萨伐尔定律的数值实现，这是静磁学的基本原理。通过对线圈进行离散化并分析计算的收敛性，您将培养在数值分析方面的基本技能，并理解磁线圈建模中精度与计算成本之间的权衡 。",
            "id": "4044824",
            "problem": "在计算仿星器设计中，形状优化过程中需要反复评估丝状线圈产生的磁场。考虑一个由弧长参数化的单一、闭合、光滑的线圈曲线。设线圈为位于 $z=0$ 平面内、以原点为中心的圆形回路，其半径为 $R_0$，由弧长 $s \\in [0,L)$ 参数化，其中 $L = 2\\pi R_0$，位置为 $\\mathbf{r}_c(s) = \\big(R_0 \\cos(s/R_0),\\, R_0 \\sin(s/R_0),\\, 0\\big)$。一股稳恒电流 $I$ 沿着线圈流动。空间中一点 $\\mathbf{r}$ 处的磁场 $\\mathbf{B}(\\mathbf{r})$ 由丝状电流的静磁学 Biot–Savart 定律给出，\n$$\n\\mathbf{B}(\\mathbf{r}) = \\frac{\\mu_0 I}{4\\pi} \\int_0^L \\frac{d\\mathbf{r}_c(s) \\times \\big(\\mathbf{r} - \\mathbf{r}_c(s)\\big)}{\\left\\|\\mathbf{r} - \\mathbf{r}_c(s)\\right\\|^3}\\, ds,\n$$\n其中 $\\mu_0$ 是真空磁导率，且 $d\\mathbf{r}_c(s) = \\frac{d\\mathbf{r}_c}{ds} ds$。\n\n任务：从此基本定律和弧长参数化出发，设计并实现一个数值方法，该方法将线圈离散化为等弧长的直导线段，并通过数值积分在一些边界点上近似计算 $\\mathbf{B}$。在从弧长参数化导出的线段上使用中点法则。通过与高分辨率参考计算进行比较，将误差量化为线段长度的函数，并估计观测到的收敛阶。\n\n使用以下具体且科学可靠的设置、单位和测试套件：\n\n- 物理常数和参数：\n  - 磁导率：$\\mu_0 = 4\\pi \\times 10^{-7}\\,\\mathrm{T\\cdot m/A}$。\n  - 线圈半径：$R_0 = 1.5\\,\\mathrm{m}$，所以 $L = 2\\pi R_0$。\n  - 电流：$I = 5.0 \\times 10^4\\,\\mathrm{A}$。\n- 边界（评估）点：\n  - 在 $z=z_0$（其中 $z_0 = 0.3\\,\\mathrm{m}$）平面上定义一个半径为 $a = 0.4\\,\\mathrm{m}$、以 $z$ 轴为中心的圆。将边界参数化为 $\\mathbf{r}_b(\\varphi) = \\big(a\\cos\\varphi,\\, a\\sin\\varphi,\\, z_0\\big)$，其中 $\\varphi \\in [0,2\\pi)$ 以弧度为单位。使用 $M=64$ 个均匀分布的角度 $\\varphi_m = 2\\pi m/M$，其中 $m=0,1,\\dots,M-1$。\n- 离散化和数值近似：\n  - 对于给定的整数 $N \\ge 2$，将弧长域 $[0,L)$ 离散化为 $N$ 个长度为 $h = L/N$ 的相等子区间。在 $\\mathbf{r}_c(s_i)$ 和 $\\mathbf{r}_c(s_{i+1})$ 之间构建直导线段，其中 $s_i = i h$，$s_{i+1} = (i+1)h$，$i=0,1,\\dots,N-1$，为实现闭合，索引按模 $N$ 解释。在每个线段上使用中点积分法来近似该积分。三角函数中的角度必须以弧度为单位。\n  - 对于高分辨率参考，使用 $N_\\mathrm{ref} = 8192$ 在相同的边界点上近似计算 $\\mathbf{B}_\\mathrm{ref}$。在没有离轴闭式解的情况下，这可作为真实值的替代。\n- 误差度量和收敛阶：\n  - 对于下面测试套件中的每个 $N$，计算 $M$ 个边界点上的均方根（RMS）矢量误差，\n    $$\n    E(N) = \\sqrt{\\frac{1}{M}\\sum_{m=1}^{M} \\left\\| \\mathbf{B}_N\\big(\\mathbf{r}_b(\\varphi_m)\\big) - \\mathbf{B}_\\mathrm{ref}\\big(\\mathbf{r}_b(\\varphi_m)\\big) \\right\\|_2^2 }.\n    $$\n    将 $E(N)$ 以特斯拉（$\\mathrm{T}$）表示。\n  - 设 $h(N) = L/N$ 为线段长度。使用测试套件中 $N$ 值对应的集合 $\\{(h(N), E(N))\\}$，通过最小二乘法对 $\\log E$ 与 $\\log h$ 的关系拟合一条直线，并将该直线的斜率作为 $p$ 来估计观测到的收敛阶 $p$。\n- 测试套件：\n  - 使用 $N \\in \\{20, 40, 80, 160\\}$。\n- 要求的最终输出格式：\n  - 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按升序包含测试套件中各个 $N$ 值对应的四个 RMS 误差，其后是估计的收敛阶 $p$。例如，打印\n    $$\n    [E(20), E(40), E(80), E(160), p].\n    $$\n  - 在内部，这些数值是带单位的量，但输出列表必须只包含原始数字（不含单位文本）。误差的单位是 $\\mathrm{T}$，收敛阶是无量纲的。\n\n请从第一性原理出发设计您的算法，从 Biot–Savart 定律和弧长参数化开始。不要调用问题陈述中为有限线段预先推导的快捷公式。通过遵循所述的几何形状和单位来确保科学真实性。解决方案必须对开发者而言是普适易懂的，并且对于给定的参数选择，该方案必须是自包含、可复现且数值稳健的。",
            "solution": "该问题要求基于 Biot-Savart 定律的离散化，设计并实现一种数值方法来计算圆形电流回路产生的磁场。这涉及到用一系列直导线段来近似连续的弯曲线圈，并使用中点法则来评估每个线段的贡献。然后，通过与高分辨率参考计算对比计算均方根（RMS）误差来量化此近似的准确性，并估计其收敛阶。\n\n基本原理是丝状电流回路的 Biot-Savart 定律，它将位于位置 $\\mathbf{r}$ 的磁场 $\\mathbf{B}$ 表示为沿线圈路径的积分：\n$$\n\\mathbf{B}(\\mathbf{r}) = \\frac{\\mu_0 I}{4\\pi} \\int_{\\text{coil}} \\frac{d\\mathbf{l} \\times \\mathbf{d}}{\\|\\mathbf{d}\\|^3}\n$$\n其中 $d\\mathbf{l}$ 是沿线圈携带电流 $I$ 的一个矢量微分元，$\\mathbf{d} = \\mathbf{r} - \\mathbf{r}_c(s)$ 是从线圈上的源点 $\\mathbf{r}_c(s)$ 到评估点 $\\mathbf{r}$ 的矢量，$\\mu_0 = 4\\pi \\times 10^{-7}\\,\\mathrm{T\\cdot m/A}$ 是真空磁导率。对于给定的问题，线圈由弧长 $s \\in [0, L)$ 参数化，其中 $L = 2\\pi R_0$，$ \\mathbf{r}_c(s) = (R_0 \\cos(s/R_0), R_0 \\sin(s/R_0), 0)$。微分元为 $d\\mathbf{l} = \\frac{d\\mathbf{r}_c}{ds} ds$。\n\n任务的核心是对该积分进行数值近似。问题指定了一种方法，其中光滑的圆形线圈被一个由 $N$ 个直导线段组成的闭合多边形所取代。该多边形的顶点位于原始圆形路径上。\n设弧长域 $[0, L)$ 被划分为 $N$ 个相等的子区间，每个子区间的长度为 $h = L/N$。那么近似多边形的顶点由点 $\\mathbf{p}_i = \\mathbf{r}_c(s_i)$ 给出，其中 $s_i = i \\cdot h$，$i=0, 1, \\dots, N$。由于线圈是闭合的，$\\mathbf{p}_N = \\mathbf{p}_0$。第 $i$ 个直导线段连接顶点 $\\mathbf{p}_i$ 和 $\\mathbf{p}_{i+1}$（索引按模 $N$ 解释）。\n\n整个线圈上的积分随后被近似为这 $N$ 个直导线段贡献的总和：\n$$\n\\mathbf{B}(\\mathbf{r}) \\approx \\mathbf{B}_N(\\mathbf{r}) = \\sum_{i=0}^{N-1} \\Delta\\mathbf{B}_i(\\mathbf{r})\n$$\n其中 $\\Delta\\mathbf{B}_i(\\mathbf{r})$ 是第 $i$ 个线段的磁场贡献。问题指导我们对每个线段使用中点法则。这涉及到通过在每个线段的几何中点处计算被积函数，并使用该线段的矢量作为微分元来近似第 $i$ 个线段上的积分。\n\n对于从 $\\mathbf{p}_i$ 到 $\\mathbf{p}_{i+1}$ 的第 $i$ 个线段：\n1.  代表整个线段的矢量是 $\\Delta\\mathbf{L}_i = \\mathbf{p}_{i+1} - \\mathbf{p}_i$。\n2.  该线段的几何中点是 $\\mathbf{l}_{\\text{mid}, i} = \\frac{\\mathbf{p}_i + \\mathbf{p}_{i+1}}{2}$。\n3.  从线段中点到评估点 $\\mathbf{r}$ 的矢量是 $\\mathbf{d}_i = \\mathbf{r} - \\mathbf{l}_{\\text{mid}, i}$。\n\n应用中点法则，我们将第 $i$ 个线段的贡献近似为位于其中点 $\\mathbf{l}_{\\text{mid}, i}$ 的单个微分元 $\\Delta\\mathbf{L}_i$：\n$$\n\\Delta\\mathbf{B}_i(\\mathbf{r}) \\approx \\frac{\\mu_0 I}{4\\pi} \\frac{\\Delta\\mathbf{L}_i \\times \\mathbf{d}_i}{\\|\\mathbf{d}_i\\|^3} = \\frac{\\mu_0 I}{4\\pi} \\frac{(\\mathbf{p}_{i+1} - \\mathbf{p}_i) \\times \\left(\\mathbf{r} - \\frac{\\mathbf{p}_i + \\mathbf{p}_{i+1}}{2}\\right)}{\\left\\|\\mathbf{r} - \\frac{\\mathbf{p}_i + \\mathbf{p}_{i+1}}{2}\\right\\|^3}\n$$\n在离散化水平为 $N$ 时，位于 $\\mathbf{r}$ 处的总近似磁场是这些贡献的总和：\n$$\n\\mathbf{B}_N(\\mathbf{r}) = \\frac{\\mu_0 I}{4\\pi} \\sum_{i=0}^{N-1} \\frac{(\\mathbf{p}_{i+1} - \\mathbf{p}_i) \\times \\left(\\mathbf{r} - \\frac{\\mathbf{p}_i + \\mathbf{p}_{i+1}}{2}\\right)}{\\left\\|\\mathbf{r} - \\frac{\\mathbf{p}_i + \\mathbf{p}_{i+1}}{2}\\right\\|^3}\n$$\n该公式在一个函数中实现，用于在一组给定的评估点上计算 $\\mathbf{B}_N$。给定的参数为线圈半径 $R_0 = 1.5\\,\\mathrm{m}$ 和电流 $I = 5.0 \\times 10^4\\,\\mathrm{A}$。总弧长为 $L = 2\\pi R_0 = 3\\pi\\,\\mathrm{m}$。评估点位于 $z = z_0 = 0.3\\,\\mathrm{m}$ 平面内的一个半径为 $a = 0.4\\,\\mathrm{m}$ 的圆上。共有 $M=64$ 个这样的点，由 $\\mathbf{r}_b(\\varphi_m) = (a\\cos\\varphi_m, a\\sin\\varphi_m, z_0)$ 给出，其中 $\\varphi_m = 2\\pi m/M$。\n\n为评估数值误差，使用相同方法但采用更大数量的线段（$N_\\mathrm{ref} = 8192$）来计算高分辨率参考场 $\\mathbf{B}_\\mathrm{ref}$。对于测试套件 $\\{20, 40, 80, 160\\}$ 中的每个 $N$，在 $M=64$ 个边界点上计算近似场 $\\mathbf{B}_N$。然后，RMS 矢量误差计算如下：\n$$\nE(N) = \\sqrt{\\frac{1}{M}\\sum_{m=0}^{M-1} \\left\\| \\mathbf{B}_N(\\mathbf{r}_m) - \\mathbf{B}_\\mathrm{ref}(\\mathbf{r}_m) \\right\\|_2^2 }\n$$\n该数值方案的收敛行为由关系式 $E(N) \\propto h^p$ 表征，其中 $h = L/N$ 是特征长度尺度（一个线段的弧长），$p$ 是收敛阶。这意味着在对数-对数图中存在线性关系：$\\log E(N) = p \\log h + C$。通过对测试套件中 $N$ 值的数据点 $(\\log h(N), \\log E(N))$ 进行线性最小二乘拟合来估计收敛阶 $p$。所得直线的斜率即为估计的收敛阶 $p$。这种数值方案是在多边形近似曲线上使用的一种中点法则，预计会表现出二阶收敛，即 $p \\approx 2$。\n\n最终算法如下：\n1. 定义所有物理和几何常数：$\\mu_0, I, R_0, a, z_0, M$。\n2. 在边界圆上生成 $M=64$ 个评估点。\n3. 实现一个函数 `compute_B(N, eval_points)`，使用上面推导的求和公式计算 $\\mathbf{B}_N$。\n4. 通过使用 $N_\\mathrm{ref} = 8192$ 调用 `compute_B` 来计算参考场 $\\mathbf{B}_\\mathrm{ref}$。\n5. 对于每个 $N \\in \\{20, 40, 80, 160\\}$：\n   a. 使用 `compute_B(N, eval_points)` 计算近似场 $\\mathbf{B}_N$。\n   b. 计算并存储相对于 $\\mathbf{B}_\\mathrm{ref}$ 的 RMS 误差 $E(N)$。\n   c. 存储相应的线段弧长 $h(N) = 2\\pi R_0 / N$。\n6. 对存储的误差和线段长度数组取对数。\n7. 在对数-对数数据上使用线性回归（例如 `numpy.polyfit`）来找到斜率，即估计的收敛阶 $p$。\n8. 按规定格式化并输出四个误差值和收敛阶 $p$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes magnetic field from a circular coil, evaluates error and convergence.\n    \"\"\"\n    # 1. DEFINE CONSTANTS AND PARAMETERS\n    # Physical constants and parameters\n    mu_0 = 4.0 * np.pi * 1.0e-7  # T*m/A\n    R0 = 1.5  # m\n    I = 5.0e4  # A\n    \n    # Pre-calculate constant factor in Biot-Savart law\n    B_FACTOR = (mu_0 * I) / (4.0 * np.pi) # This simplifies to I * 1e-7\n\n    # Boundary (evaluation) points parameters\n    a = 0.4  # m\n    z0 = 0.3  # m\n    M = 64  # Number of boundary points\n\n    # Discretization and analysis parameters\n    N_ref = 8192\n    N_test_suite = [20, 40, 80, 160]\n\n    # Total arc length of the coil\n    L = 2.0 * np.pi * R0\n\n    # 2. HELPER FUNCTION TO COMPUTE B-FIELD\n    def compute_B(N, r_eval_points):\n        \"\"\"\n        Calculates the magnetic field B at specified evaluation points.\n        \n        Args:\n            N (int): Number of straight segments to approximate the coil.\n            r_eval_points (np.ndarray): Array of shape (M, 3) containing the\n                                        coordinates of the M evaluation points.\n            \n        Returns:\n            np.ndarray: Array of shape (M, 3) with the B-field vectors.\n        \"\"\"\n        # Generate the N+1 vertices of the polygonal coil approximation\n        s_values = np.linspace(0, L, N + 1)\n        angles = s_values / R0\n        px = R0 * np.cos(angles)\n        py = R0 * np.sin(angles)\n        pz = np.zeros(N + 1)\n        # coil_points is a (N+1, 3) array of vertices\n        coil_points = np.vstack((px, py, pz)).T\n\n        # Initialize B-field array for all evaluation points.\n        B_field = np.zeros_like(r_eval_points)\n        \n        # Loop over each segment of the coil\n        for i in range(N):\n            p_i = coil_points[i]\n            p_i_plus_1 = coil_points[i+1]\n            \n            # Vector for the current segment\n            delta_L_i = p_i_plus_1 - p_i\n            \n            # Midpoint of the current segment\n            l_mid_i = (p_i + p_i_plus_1) / 2.0\n            \n            # Vector from segment midpoint to each evaluation point\n            # l_mid_i is (3,), r_eval_points is (M, 3). Broadcasting expands\n            # l_mid_i to (M, 3) for vectorized subtraction.\n            d_i = r_eval_points - l_mid_i  # Shape: (M, 3)\n            \n            # Magnitude of d_i for each evaluation point\n            d_i_norm = np.linalg.norm(d_i, axis=1) # Shape: (M,)\n            \n            # Cross product: delta_L_i x d_i\n            # delta_L_i is (3,), d_i is (M, 3).\n            # np.cross handles this broadcasting.\n            cross_product = np.cross(delta_L_i, d_i) # Shape: (M, 3)\n            \n            # Denominator term ||d_i||^3\n            # We need to reshape d_i_norm to (M,1) for broadcasting with the (M,3) cross product.\n            denominator = d_i_norm[:, np.newaxis]**3\n            \n            # Add this segment's contribution to the total B-field\n            B_field += cross_product / denominator\n            \n        return B_FACTOR * B_field\n\n    # 3. SETUP SIMULATION\n    # Generate the M evaluation points on the boundary circle\n    phi_m = np.linspace(0, 2 * np.pi, M, endpoint=False)\n    r_eval_x = a * np.cos(phi_m)\n    r_eval_y = a * np.sin(phi_m)\n    r_eval_z = np.full(M, z0)\n    r_boundary = np.vstack((r_eval_x, r_eval_y, r_eval_z)).T\n\n    # 4. RUN COMPUTATIONS\n    # Compute the high-resolution reference field\n    B_ref = compute_B(N_ref, r_boundary)\n\n    errors = []\n    h_values = []\n    \n    # Loop through the test suite for N\n    for N in N_test_suite:\n        # Compute the approximate field B_N\n        B_N = compute_B(N, r_boundary)\n        \n        # Compute the difference vector for each point\n        diff_vectors = B_N - B_ref\n        \n        # Compute the squared L2 norm of each difference vector\n        squared_norms = np.sum(diff_vectors**2, axis=1)\n        \n        # Compute the mean of the squared norms\n        mean_squared_error = np.mean(squared_norms)\n        \n        # The RMS error is the square root of the MSE\n        rms_error = np.sqrt(mean_squared_error)\n        errors.append(rms_error)\n        \n        # Store the corresponding segment arc-length h\n        h = L / N\n        h_values.append(h)\n\n    # 5. ESTIMATE CONVERGENCE ORDER\n    log_E = np.log(np.array(errors))\n    log_h = np.log(np.array(h_values))\n    \n    # Fit a line (polynomial of degree 1) to the log-log data\n    # The slope is the first element of the returned coefficients\n    p = np.polyfit(log_h, log_E, 1)[0]\n\n    # 6. FORMAT AND PRINT FINAL OUTPUT\n    results = errors + [p]\n    # Use '.8e' for robust scientific notation representation\n    print(f\"[{','.join(f'{val:.8e}' for val in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "磁场一经建立，便会形成约束等离子体的嵌套磁面。为了分析和优化这些磁面，我们需要对其几何形状进行精确的数学描述。本练习侧重于由谱（傅里叶）表示法描述的磁面的微分几何。您将计算曲面度规张量和关键磁场属性（如旋转变换），从而亲身体验对直线场线坐标系的理解，这对于解释和设计仿星器平衡至关重要 。",
            "id": "4044780",
            "problem": "给定一个简化的、类真空的仿星器平衡模型，其中存在嵌套的磁通量面，并由磁通量标签 $\\psi$ 标记。在任意固定磁面 $\\psi=\\psi_0$ 上，引入直场线坐标 $(\\theta,\\zeta)$，分别解释为角向角和环向角（单位为弧度）。一个光滑的闭合磁通量面在柱坐标 $(R,\\phi,Z)$ 中通过谱方法表示为\n$$\nR(\\theta,\\zeta) \\;=\\; R_0 \\;+\\; \\sum_{m,n} R_{m n} \\cos\\!\\big(m\\,\\theta - n\\,\\zeta\\big),\n\\qquad\nZ(\\theta,\\zeta) \\;=\\; \\sum_{m,n} Z_{m n} \\sin\\!\\big(m\\,\\theta - n\\,\\zeta\\big),\n$$\n其中几何环向角定义为 $\\phi=\\zeta$。笛卡尔坐标下的位置矢量为\n$$\n\\mathbf{r}(\\theta,\\zeta) \\;=\\; \\big( R(\\theta,\\zeta)\\cos\\zeta,\\; R(\\theta,\\zeta)\\sin\\zeta,\\; Z(\\theta,\\zeta) \\big).\n$$\n定义曲面上的协变基矢为 $\\mathbf{e}_\\theta=\\partial\\mathbf{r}/\\partial\\theta$ 和 $\\mathbf{e}_\\zeta=\\partial\\mathbf{r}/\\partial\\zeta$，导出的曲面度规系数为\n$$\ng_{\\theta\\theta} \\;=\\; \\mathbf{e}_\\theta\\cdot\\mathbf{e}_\\theta,\\quad\ng_{\\theta\\zeta} \\;=\\; \\mathbf{e}_\\theta\\cdot\\mathbf{e}_\\zeta,\\quad\ng_{\\zeta\\zeta} \\;=\\; \\mathbf{e}_\\zeta\\cdot\\mathbf{e}_\\zeta.\n$$\n假设磁面上磁场的 Clebsch 表示形式为\n$$\n\\mathbf{B} \\;=\\; \\nabla\\psi \\times \\nabla\\alpha(\\theta,\\zeta),\\qquad \\alpha(\\theta,\\zeta) \\;=\\; \\theta \\;-\\; N\\,\\zeta,\n$$\n其中 $N$ 是给定的整数场周期性。仅以上述内容作为基本出发点。\n\n任务：\n\n$1.$ 从谱映射 $\\mathbf{r}(\\theta,\\zeta)$ 出发，通过对 $R(\\theta,\\zeta)$ 和 $Z(\\theta,\\zeta)$ 关于 $\\theta$ 和 $\\zeta$ 进行显式微分，推导并计算在指定 $(\\theta,\\zeta)$ 点的度规系数 $g_{ij}$。\n\n$2.$ 使用磁场表示 $\\mathbf{B}=\\nabla\\psi\\times\\nabla\\alpha$ 和 $\\alpha=\\theta-N\\zeta$，根据 $(\\theta,\\zeta)$ 中的局部场线斜率，推导磁面上旋转变换 $\\iota(\\psi)$ 的表达式并计算其值。定义场线螺距 $p$ 为 $p=d\\zeta/d\\theta$，并用 $\\iota(\\psi)$ 表示 $p$。\n\n$3.$ 在磁面上，线元满足 $ds^2 = g_{\\theta\\theta}\\,d\\theta^2 + 2 g_{\\theta\\zeta}\\,d\\theta\\,d\\zeta + g_{\\zeta\\zeta}\\,d\\zeta^2$。沿着一条磁力线，微分量满足您在任务 2 中得到的关系。使用此关系，在指定的点上计算 $ds/d\\zeta$。\n\n所有角度单位必须是弧度。所有长度单位必须是米，$ds/d\\zeta$ 的单位必须是米/弧度。旋转变换 $\\iota(\\psi)$ 和螺距 $p$ 是无量纲的。您的程序必须为以下磁通量面和角度样本的测试套件计算所要求的量。\n\n测试套件：\n\n案例 1：\n- $R_0 = 1.50\\ \\mathrm{m}$，\n- $R_{10} = 0.20\\ \\mathrm{m}$，$R_{11} = 0.05\\ \\mathrm{m}$，\n- $Z_{10} = 0.18\\ \\mathrm{m}$，$Z_{21} = 0.03\\ \\mathrm{m}$，\n- $N = 1$，\n- 在 $(\\theta,\\zeta)$ 等于 $(0.0,0.0)$、$(\\pi/3,\\ \\pi/7)$ 和 $(2.0,\\ 1.0)$ 时进行计算。\n\n案例 2：\n- $R_0 = 1.00\\ \\mathrm{m}$，\n- $R_{20} = 0.10\\ \\mathrm{m}$，$R_{12} = 0.04\\ \\mathrm{m}$，$R_{01} = 0.02\\ \\mathrm{m}$，\n- $Z_{11} = 0.06\\ \\mathrm{m}$，$Z_{21} = 0.03\\ \\mathrm{m}$，$Z_{02} = 0.01\\ \\mathrm{m}$，\n- $N = 2$，\n- 在 $(\\theta,\\zeta)$ 等于 $(0.0,0.0)$、$(\\pi/3,\\ \\pi/7)$ 和 $(2.0,\\ 1.0)$ 时进行计算。\n\n案例 3：\n- $R_0 = 1.20\\ \\mathrm{m}$，\n- $R_{10} = 0.15\\ \\mathrm{m}$，$R_{32} = 0.02\\ \\mathrm{m}$，$R_{21} = 0.04\\ \\mathrm{m}$，\n- $Z_{10} = 0.12\\ \\mathrm{m}$，$Z_{13} = 0.02\\ \\mathrm{m}$，$Z_{31} = 0.015\\ \\mathrm{m}$，\n- $N = 3$，\n- 在 $(\\theta,\\zeta)$ 等于 $(0.0,0.0)$、$(\\pi/3,\\ \\pi/7)$ 和 $(2.0,\\ 1.0)$ 时进行计算。\n\n实现要求：\n\n- 对于每个案例，计算：\n  - $\\iota(\\psi)$，\n  - $p$，\n  - 在三个指定的 $(\\theta,\\zeta)$ 点处，使用 $d\\theta$ 和 $d\\zeta$ 之间的场线关系计算 $ds/d\\zeta$。\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果。每个案例应按顺序 $[\\iota(\\psi),\\ p,\\ (ds/d\\zeta)_{\\text{在点 1}},\\ (ds/d\\zeta)_{\\text{在点 2}},\\ (ds/d\\zeta)_{\\text{在点 3}}]$ 提供一个子列表，最终输出必须是这三个子列表的列表，例如 $[[a_1,a_2,a_3,a_4,a_5],[b_1,b_2,b_3,b_4,b_5],[c_1,c_2,c_3,c_4,c_5]]$。所有数值条目必须是浮点数，适用时单位为米/弧度，否则为无量纲浮点数。不应打印任何额外文本。",
            "solution": "该问题要求对由谱表示定义的仿星器磁通量面进行几何分析。我们的任务是推导并计算几个关键量：曲面的度规张量、旋转变换、场线螺距以及沿磁力线的微分弧长。\n\n解答过程分三个阶段，对应问题陈述中列出的三个任务。首先，我们推导度规张量分量的解析表达式。其次，我们从给定的磁场结构中确定旋转变换和场线螺距。第三，我们结合这些结果来求沿磁力线的弧长变化率。\n\n### 任务 1：度规张量计算\n\n磁通量面上一点的位置矢量 $\\mathbf{r}$ 在笛卡尔坐标中给出为：\n$$\n\\mathbf{r}(\\theta,\\zeta) = \\big( R(\\theta,\\zeta)\\cos\\zeta,\\; R(\\theta,\\zeta)\\sin\\zeta,\\; Z(\\theta,\\zeta) \\big)\n$$\n其中 $R(\\theta,\\zeta)$ 和 $Z(\\theta,\\zeta)$ 由其傅里叶级数定义。\n\n协变基矢 $\\mathbf{e}_\\theta$ 和 $\\mathbf{e}_\\zeta$ 是 $\\mathbf{r}$ 关于曲面坐标 $\\theta$ 和 $\\zeta$ 的偏导数。令 $R_\\theta = \\partial R/\\partial\\theta$、$R_\\zeta = \\partial R/\\partial\\zeta$、$Z_\\theta = \\partial Z/\\partial\\theta$ 和 $Z_\\zeta = \\partial Z/\\partial\\zeta$。应用链式法则，我们得到：\n$$\n\\mathbf{e}_\\theta = \\frac{\\partial\\mathbf{r}}{\\partial\\theta} = \\left( \\frac{\\partial R}{\\partial\\theta}\\cos\\zeta, \\frac{\\partial R}{\\partial\\theta}\\sin\\zeta, \\frac{\\partial Z}{\\partial\\theta} \\right) = (R_\\theta \\cos\\zeta, R_\\theta \\sin\\zeta, Z_\\theta)\n$$\n$$\n\\mathbf{e}_\\zeta = \\frac{\\partial\\mathbf{r}}{\\partial\\zeta} = \\left( \\frac{\\partial R}{\\partial\\zeta}\\cos\\zeta - R\\sin\\zeta, \\frac{\\partial R}{\\partial\\zeta}\\sin\\zeta + R\\cos\\zeta, \\frac{\\partial Z}{\\partial\\zeta} \\right) = (R_\\zeta \\cos\\zeta - R \\sin\\zeta, R_\\zeta \\sin\\zeta + R \\cos\\zeta, Z_\\zeta)\n$$\n\n导出度规张量 $g_{ij}$ 的系数是这些基矢的点积：\n$g_{\\theta\\theta} = \\mathbf{e}_\\theta \\cdot \\mathbf{e}_\\theta = (R_\\theta \\cos\\zeta)^2 + (R_\\theta \\sin\\zeta)^2 + Z_\\theta^2 = R_\\theta^2(\\cos^2\\zeta + \\sin^2\\zeta) + Z_\\theta^2 = R_\\theta^2 + Z_\\theta^2$。\n$g_{\\theta\\zeta} = \\mathbf{e}_\\theta \\cdot \\mathbf{e}_\\zeta = R_\\theta\\cos\\zeta(R_\\zeta\\cos\\zeta - R\\sin\\zeta) + R_\\theta\\sin\\zeta(R_\\zeta\\sin\\zeta + R\\cos\\zeta) + Z_\\theta Z_\\zeta = R_\\theta R_\\zeta + Z_\\theta Z_\\zeta$。\n$g_{\\zeta\\zeta} = \\mathbf{e}_\\zeta \\cdot \\mathbf{e}_\\zeta = (R_\\zeta\\cos\\zeta - R\\sin\\zeta)^2 + (R_\\zeta\\sin\\zeta + R\\cos\\zeta)^2 + Z_\\zeta^2 = R^2 + R_\\zeta^2 + Z_\\zeta^2$。\n\n为计算这些系数，我们需要谱表示的偏导数：\n$$\nR(\\theta,\\zeta) = R_0 + \\sum_{m,n} R_{m n} \\cos(m\\,\\theta - n\\,\\zeta)\n$$\n$$\nZ(\\theta,\\zeta) = \\sum_{m,n} Z_{m n} \\sin(m\\,\\theta - n\\,\\zeta)\n$$\n其导数为：\n$$\nR_\\theta(\\theta,\\zeta) = -\\sum_{m,n} m\\,R_{mn} \\sin(m\\,\\theta - n\\,\\zeta)\n$$\n$$\nR_\\zeta(\\theta,\\zeta) = \\sum_{m,n} n\\,R_{mn} \\sin(m\\,\\theta - n\\,\\zeta)\n$$\n$$\nZ_\\theta(\\theta,\\zeta) = \\sum_{m,n} m\\,Z_{mn} \\cos(m\\,\\theta - n\\,\\zeta)\n$$\n$$\nZ_\\zeta(\\theta,\\zeta) = -\\sum_{m,n} n\\,Z_{mn} \\cos(m\\,\\theta - n\\,\\zeta)\n$$\n这些表达式允许在曲面上任意点 $(\\theta, \\zeta)$ 直接计算度规系数。\n\n### 任务 2：旋转变换与场线螺距\n\n磁场 $\\mathbf{B}$ 以 Clebsch 表示形式给出，即 $\\mathbf{B} = \\nabla\\psi \\times \\nabla\\alpha$，其中 $\\psi$ 是磁通量标签，$\\alpha(\\theta, \\zeta) = \\theta - N\\zeta$。这种表示的一个基本性质是，磁力线位于等 $\\psi$ 面（即磁通量面）上，也位于等 $\\alpha$ 面上。因此，沿着一条磁力线，微分 $d\\alpha$ 必须为零。\n$$\nd\\alpha = \\frac{\\partial\\alpha}{\\partial\\theta}d\\theta + \\frac{\\partial\\alpha}{\\partial\\zeta}d\\zeta = 0\n$$\n代入 $\\alpha$ 的表达式，我们得到：\n$$\n(1)d\\theta + (-N)d\\zeta = 0 \\quad\\implies\\quad d\\theta = N d\\zeta\n$$\n旋转变换 $\\iota(\\psi)$ 定义为沿磁力线角向角 $\\theta$ 相对于环向角 $\\zeta$ 的变化率。在直场线坐标中，这即是斜率 $d\\theta/d\\zeta$。\n$$\n\\iota(\\psi) = \\frac{d\\theta}{d\\zeta} = N\n$$\n问题给出磁面上的 $N$ 为一个恒定的整数，因此旋转变换是常数，等于 $N$。\n\n场线螺距 $p$ 定义为 $(\\theta, \\zeta)$ 平面中场线斜率的倒数：\n$$\np = \\frac{d\\zeta}{d\\theta} = \\frac{1}{d\\theta/d\\zeta} = \\frac{1}{\\iota} = \\frac{1}{N}\n$$\n由于测试案例提供 $N \\ge 1$，因此螺距 $p$ 是良定义的。\n\n### 任务 3：沿磁力线的微分弧长\n\n曲面上的微分线元平方 $ds^2$ 由度规给出：\n$$\nds^2 = g_{\\theta\\theta}\\,d\\theta^2 + 2 g_{\\theta\\zeta}\\,d\\theta\\,d\\zeta + g_{\\zeta\\zeta}\\,d\\zeta^2\n$$\n为了求得沿磁力线的弧长，我们使用在任务 2 中推导出的关系 $d\\theta = N d\\zeta$。将其代入 $ds^2$ 的表达式中：\n$$\nds^2 = g_{\\theta\\theta}(N d\\zeta)^2 + 2 g_{\\theta\\zeta}(N d\\zeta)d\\zeta + g_{\\zeta\\zeta}d\\zeta^2\n$$\n提出公因子 $d\\zeta^2$，我们得到：\n$$\nds^2 = \\left( N^2 g_{\\theta\\theta} + 2N g_{\\theta\\zeta} + g_{\\zeta\\zeta} \\right) d\\zeta^2\n$$\n两边同除以 $d\\zeta^2$ 并取平方根，得到沿磁力线弧长相对于环向角 $\\zeta$ 的变化率：\n$$\n\\frac{ds}{d\\zeta} = \\sqrt{N^2 g_{\\theta\\theta} + 2N g_{\\theta\\zeta} + g_{\\zeta\\zeta}}\n$$\n该量是局部计算的，因为度规系数 $g_{ij}$ 是 $(\\theta, \\zeta)$ 的函数。\n\n### 计算算法\n\n对于每个测试案例，数值实现将按以下步骤进行：\n1.  存储输入参数：$R_0$、$N$、非零 $R_{mn}$ 和 $Z_{mn}$ 系数的字典，以及 $(\\theta, \\zeta)$ 计算点的列表。\n2.  计算旋转变换 $\\iota = N$ 和螺距 $p = 1/N$。\n3.  对于每个指定的点 $(\\theta_{pt}, \\zeta_{pt})$：\n    a. 初始化 $R = R_0$，$Z=0$，以及导数 $R_\\theta, R_\\zeta, Z_\\theta, Z_\\zeta$ 为 0。\n    b. 遍历 $R_{mn}$ 和 $Z_{mn}$ 系数集中所有唯一的 $(m,n)$ 模式对。\n    c. 对于每个模式 $(m, n)$，计算相位角 $\\phi_{mn} = m\\theta_{pt} - n\\zeta_{pt}$。\n    d. 使用上面推导的公式更新 $R$、$Z$ 及其导数的总和，加上当前模式的贡献。\n    e. 遍历所有模式后，计算度规分量 $g_{\\theta\\theta} = R_\\theta^2 + Z_\\theta^2$、$g_{\\theta\\zeta} = R_\\theta R_\\zeta + Z_\\theta Z_\\zeta$ 和 $g_{\\zeta\\zeta} = R^2 + R_\\zeta^2 + Z_\\zeta^2$。\n    f. 计算 $\\frac{ds}{d\\zeta} = \\sqrt{N^2 g_{\\theta\\theta} + 2N g_{\\theta\\zeta} + g_{\\zeta\\zeta}}$。\n4.  将该案例的结果组合成一个列表：$[\\iota, p, (ds/d\\zeta)_1, (ds/d\\zeta)_2, (ds/d\\zeta)_3]$。\n5.  收集所有测试案例的列表，并将它们格式化为最终要求的输出字符串。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the stellarator surface geometry problem for a given set of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"R0\": 1.50,\n            \"N\": 1,\n            \"R_coeffs\": {(1, 0): 0.20, (1, 1): 0.05},\n            \"Z_coeffs\": {(1, 0): 0.18, (2, 1): 0.03},\n            \"points\": [(0.0, 0.0), (np.pi/3, np.pi/7), (2.0, 1.0)]\n        },\n        {\n            \"R0\": 1.00,\n            \"N\": 2,\n            \"R_coeffs\": {(2, 0): 0.10, (1, 2): 0.04, (0, 1): 0.02},\n            \"Z_coeffs\": {(1, 1): 0.06, (2, 1): 0.03, (0, 2): 0.01},\n            \"points\": [(0.0, 0.0), (np.pi/3, np.pi/7), (2.0, 1.0)]\n        },\n        {\n            \"R0\": 1.20,\n            \"N\": 3,\n            \"R_coeffs\": {(1, 0): 0.15, (3, 2): 0.02, (2, 1): 0.04},\n            \"Z_coeffs\": {(1, 0): 0.12, (1, 3): 0.02, (3, 1): 0.015},\n            \"points\": [(0.0, 0.0), (np.pi/3, np.pi/7), (2.0, 1.0)]\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        R0 = case[\"R0\"]\n        N = case[\"N\"]\n        R_coeffs = case[\"R_coeffs\"]\n        Z_coeffs = case[\"Z_coeffs\"]\n        points = case[\"points\"]\n\n        # Task 2: Compute rotational transform (iota) and pitch (p)\n        iota = float(N)\n        p = 1.0 / N\n\n        case_results = [iota, p]\n        \n        # Get the unique set of all (m,n) modes for this case\n        all_modes = set(R_coeffs.keys()) | set(Z_coeffs.keys())\n\n        for theta, zeta in points:\n            # Initialize sums for R, Z and their derivatives\n            R, Z = R0, 0.0\n            R_theta, R_zeta = 0.0, 0.0\n            Z_theta, Z_zeta = 0.0, 0.0\n\n            for m, n in all_modes:\n                phase_angle = m * theta - n * zeta\n                cos_phase = np.cos(phase_angle)\n                sin_phase = np.sin(phase_angle)\n                \n                Rmn = R_coeffs.get((m, n), 0.0)\n                Zmn = Z_coeffs.get((m, n), 0.0)\n\n                # Sum for R and Z\n                R += Rmn * cos_phase\n                Z += Zmn * sin_phase\n\n                # Sum for derivatives\n                R_theta -= m * Rmn * sin_phase\n                R_zeta += n * Rmn * sin_phase\n                Z_theta += m * Zmn * cos_phase\n                Z_zeta -= n * Zmn * cos_phase\n\n            # Task 1: Compute metric coefficients\n            g_thetatheta = R_theta**2 + Z_theta**2\n            g_thetazeta = R_theta * R_zeta + Z_theta * Z_zeta\n            g_zetazeta = R**2 + R_zeta**2 + Z_zeta**2\n\n            # Task 3: Compute ds/dzeta along the field line\n            ds_dzeta_sq = N**2 * g_thetatheta + 2 * N * g_thetazeta + g_zetazeta\n            ds_dzeta = np.sqrt(ds_dzeta_sq)\n            \n            case_results.append(ds_dzeta)\n\n        all_results.append(case_results)\n\n    # Format the final output string as specified.\n    result_str = \"[\" + \",\".join([f\"[{','.join(map(str, res))}]\" for res in all_results]) + \"]\"\n    print(result_str)\n\nsolve()\n```"
        },
        {
            "introduction": "计算仿星器设计的最终目标是找到一个能够同时优化多个物理和工程目标的等离子体形状及线圈位形。这需要构建一个单一的复合目标函数并找到其最小值。这项终极实践将您置于优化过程的核心。您将推导并实现一个复合目标函数，以及至关重要的、其相对于形状参数的解析梯度，这是高效的基于梯度的优化算法所必需的步骤 。",
            "id": "4044763",
            "problem": "给定一个简化但物理上一致的仿星器边界形状和线圈组的代理模型，以及一个用于形状优化的复合目标函数。形状由柱坐标中边界上的截断傅里叶级数表示，而线圈由一个调制圆形环面的标量径向傅里叶级数表示。所有角度均以弧度为单位。您的任务是实现一个完整的程序，该程序根据基本定义计算复合目标函数及其相对于边界傅里叶系数的梯度，并在指定的测试套件上进行评估。\n\n基本和核心定义：\n\n- 在柱坐标中，边界曲面的大半径分量由角向角 $\\,\\theta\\,$ 和环向角 $\\,\\zeta\\,$ 的截断傅里叶级数建模，场周期数为 $\\,N_{\\text{fp}}\\,$（number of field periods），形式如下\n$$\nR(\\theta,\\zeta) = R_0 + \\sum_{(m,n)\\in \\mathcal{M}} a_{m,n}\\,\\cos\\!\\big(m\\,\\theta - n\\,N_{\\text{fp}}\\,\\zeta\\big),\n$$\n垂直分量为\n$$\nZ(\\theta,\\zeta) = \\sum_{(m,n)\\in \\mathcal{M}} b_{m,n}\\,\\sin\\!\\big(m\\,\\theta - n\\,N_{\\text{fp}}\\,\\zeta\\big).\n$$\n边界的优化变量是针对模式 $\\,\\mathcal{M}\\,$ 的实傅里叶系数 $\\,a_{m,n}\\,$ 和 $\\,b_{m,n}\\,$。角度 $\\,\\theta\\,$ 和 $\\,\\zeta\\,$ 是 $\\,2\\pi\\,$ 周期的。\n\n- 线圈中心线被建模为一个角度为 $\\,\\phi\\in[0,2\\pi)\\,$ 的圆形环面，带有标量径向调制\n$$\nR_{\\text{c}}(\\phi) = R_{\\text{c},0} + \\sum_{k=1}^{K_{\\text{c}}} c_k \\cos(k\\,\\phi),\n$$\n其平面嵌入为\n$$\nx(\\phi) = R_{\\text{c}}(\\phi)\\cos\\phi,\\quad y(\\phi) = R_{\\text{c}}(\\phi)\\sin\\phi,\\quad z(\\phi)=0.\n$$\n线圈平滑度惩罚项通过 $\\,R_{\\text{c}}(\\phi)\\,$ 相对于 $\\,\\phi\\,$ 的二阶导数的曲率代理来计算。线圈的优化变量是傅里叶系数 $\\,c_k\\,$.\n\n- 复合目标函数为\n$$\nJ(\\mathbf{a},\\mathbf{b},\\mathbf{c}) = w_{\\epsilon}\\,\\epsilon_{\\text{eff}}(\\mathbf{a},\\mathbf{b}) \\;+\\; w_{\\iota}\\,E_{\\iota}(\\mathbf{a},\\mathbf{b}) \\;+\\; w_{\\text{coil}}\\,S_{\\text{coil}}(\\mathbf{c}),\n$$\n其中 $\\,w_{\\epsilon}0\\,$, $\\,w_{\\iota}0\\,$ 和 $\\,w_{\\text{coil}}0\\,$ 是用户指定的标量权重。\n\n- 有效波纹代理由一个二次型定义，该二次型随非轴对称波纹的增加而增加，\n$$\n\\epsilon_{\\text{eff}}(\\mathbf{a},\\mathbf{b}) \\;=\\; \\kappa_{\\epsilon}\\sum_{(m,n)\\in\\mathcal{M}} \\gamma_{m,n}\\,\\big(a_{m,n}^2+b_{m,n}^2\\big),\n$$\n其中\n$$\n\\gamma_{m,n} \\;=\\; \\frac{m^2 + (n\\,N_{\\text{fp}})^2}{A^2},\n$$\n$\\,A0\\,$ 是给定的类环径比尺度，$\\,\\kappa_{\\epsilon}0\\,$ 是给定的归一化系数。\n\n- 旋转变换剖面代理 $\\,\\iota(s)\\,$，作为归一化环向磁通坐标 $\\,s\\in[0,1]\\,$ 的函数，定义为\n$$\n\\iota(s) \\;=\\; \\iota_{\\text{base}} \\;+\\; \\sum_{(m,n)\\in\\mathcal{M}} \\Big(\\alpha_{m,n}\\,a_{m,n}\\,s^{m} \\;+\\; \\beta_{m,n}\\,b_{m,n}\\,s^{m+1}\\Big),\n$$\n其中\n$$\n\\alpha_{m,n} \\;=\\; \\frac{\\kappa_R}{1+(n\\,N_{\\text{fp}})^2}\\left(\\frac{m}{R_0}\\right)^2,\\qquad\n\\beta_{m,n} \\;=\\; \\frac{\\kappa_Z}{1+(n\\,N_{\\text{fp}})^2}\\left(\\frac{m}{R_0}\\right).\n$$\n常数 $\\,\\kappa_R0\\,$ 和 $\\,\\kappa_Z0\\,$ 在此代理中编码了旋转变换对边界形变的线性灵敏度；$\\,R_00\\,$ 是大半径尺度。目标旋转变换剖面是一个二次多项式\n$$\n\\iota_{\\text{target}}(s) \\;=\\; t_0 + t_1\\,s + t_2\\,s^2,\n$$\n其中标量 $\\,t_0,t_1,t_2\\,$ 是给定的。剖面误差是在 $[0,1]$ 上的平方 $\\,L^2\\,$ 距离，\n$$\nE_{\\iota}(\\mathbf{a},\\mathbf{b}) \\;=\\; \\int_{0}^{1}\\Big(\\iota(s) - \\iota_{\\text{target}}(s)\\Big)^2\\,ds.\n$$\n\n- 线圈平滑度惩罚项通过 $\\,R_{\\text{c}}(\\phi)\\,$ 的二阶导数的平方来定义，\n$$\nS_{\\text{coil}}(\\mathbf{c}) \\;=\\; \\int_{0}^{2\\pi}\\left(\\frac{d^2 R_{\\text{c}}}{d\\phi^2}(\\phi)\\right)^2\\,d\\phi.\n$$\n\n任务：\n\n1.  从上述定义以及三角函数和单项式积分的标准性质出发，推导出复合目标函数 $\\,J(\\mathbf{a},\\mathbf{b},\\mathbf{c})\\,$ 及其相对于每个优化变量 $\\,a_{m,n}\\,$, $\\,b_{m,n}\\,$ 和 $\\,c_k\\,$ 的梯度的显式表达式。仅使用以下恒等式\n$$\n\\int_{0}^{2\\pi}\\cos(k\\phi)\\cos(\\ell\\phi)\\,d\\phi \\;=\\; \\begin{cases}\n\\pi,  k=\\ell\\ge 1,\\\\\n0,  k\\ne \\ell,\n\\end{cases}\n$$\n和\n$$\n\\int_{0}^{1} s^{p}\\,ds \\;=\\; \\frac{1}{p+1},\\quad p-1,\n$$\n以及积分的线性和无二项式的单项式乘积积分\n$$\n\\int_{0}^{1} s^{p+q}\\,ds \\;=\\; \\frac{1}{p+q+1}.\n$$\n\n2.  实现一个程序，用于为给定的一组参数和变量评估 $\\,J\\,$ 和 $\\,\\nabla J\\,$。对于每个测试用例，程序必须输出一个三元组，包括：\n   - 标量目标值 $\\,J\\,$，\n   - 欧几里得范数 $\\,\\|\\nabla J\\|_2\\,$，\n   - 一个布尔值，指示平稳性是否在容差 $\\,\\tau=10^{-10}\\,$ 内成立，即 $\\,\\|\\nabla J\\|_2  \\tau\\,$ 是否成立。\n\n3.  角度 $\\,\\theta\\,$, $\\,\\zeta\\,$ 和 $\\,\\phi\\,$ 均以弧度为单位。在此问题中，所有量在所提供的代理标度下都是无量纲的；输出中不需要物理单位。\n\n测试套件：\n\n对于每个测试，给定 $\\,N_{\\text{fp}}\\,$, $\\,R_0\\,$, $\\,A\\,$, $\\,\\kappa_R\\,$, $\\,\\kappa_Z\\,$, $\\,\\kappa_{\\epsilon}\\,$，权重 $\\,w_{\\epsilon}\\,$, $\\,w_{\\iota}\\,$, $\\,w_{\\text{coil}}\\,$，模式集 $\\,\\mathcal{M}\\,$，与 $\\,\\mathcal{M}\\,$ 对齐的边界系数 $\\,\\{a_{m,n}\\}\\,$ 和 $\\,\\{b_{m,n}\\}\\,$，对应于 $\\,k=1,\\dots,K_{\\text{c}}\\,$ 的线圈系数 $\\,\\{c_k\\}\\,$，以及剖面参数 $\\,\\iota_{\\text{base}}\\,$, $\\,t_0\\,$, $\\,t_1\\,$, $\\,t_2\\,$.\n\n- 测试用例 $1$：\n  - $\\,N_{\\text{fp}}=5\\,$, $\\,R_0=5.5\\,$, $\\,A=8.0\\,$, $\\,\\kappa_R=0.12\\,$, $\\,\\kappa_Z=0.07\\,$, $\\,\\kappa_{\\epsilon}=0.03\\,$.\n  - $\\,w_{\\epsilon}=1.0\\,$, $\\,w_{\\iota}=5.0\\,$, $\\,w_{\\text{coil}}=0.1\\,$.\n  - $\\,\\mathcal{M}=\\{(1,0),(2,1)\\}\\,$.\n  - $\\,\\mathbf{a}=[0.02,-0.01]\\,$, $\\,\\mathbf{b}=[0.015,0.0]\\,$.\n  - 线圈系数 $\\,\\mathbf{c}=[0.1,-0.02,0.005]\\,$ 对应于 $\\,k=1,2,3\\,$.\n  - $\\,\\iota_{\\text{base}}=0.3\\,$, $\\,t_0=0.35\\,$, $\\,t_1=0.2\\,$, $\\,t_2=-0.1\\,$.\n\n- 测试用例 $2$：\n  - $\\,N_{\\text{fp}}=5\\,$, $\\,R_0=5.5\\,$, $\\,A=8.0\\,$, $\\,\\kappa_R=0.12\\,$, $\\,\\kappa_Z=0.07\\,$, $\\,\\kappa_{\\epsilon}=0.03\\,$.\n  - $\\,w_{\\epsilon}=0.2\\,$, $\\,w_{\\iota}=10.0\\,$, $\\,w_{\\text{coil}}=0.0\\,$.\n  - $\\,\\mathcal{M}=\\{(1,0),(2,1)\\}\\,$.\n  - $\\,\\mathbf{a}=[0.0,0.0]\\,$, $\\,\\mathbf{b}=[0.0,0.0]\\,$.\n  - 线圈系数 $\\,\\mathbf{c}=[0.0,0.0]\\,$ 对应于 $\\,k=1,2\\,$.\n  - $\\,\\iota_{\\text{base}}=0.32\\,$, $\\,t_0=0.3\\,$, $\\,t_1=0.0\\,$, $\\,t_2=0.0\\,$.\n\n- 测试用例 $3$：\n  - $\\,N_{\\text{fp}}=4\\,$, $\\,R_0=6.2\\,$, $\\,A=10.0\\,$, $\\,\\kappa_R=0.1\\,$, $\\,\\kappa_Z=0.08\\,$, $\\,\\kappa_{\\epsilon}=0.05\\,$.\n  - $\\,w_{\\epsilon}=0.0\\,$, $\\,w_{\\iota}=0.0\\,$, $\\,w_{\\text{coil}}=2.0\\,$.\n  - $\\,\\mathcal{M}=\\{(1,1)\\}\\,$.\n  - $\\,\\mathbf{a}=[0.1]\\,$, $\\,\\mathbf{b}=[-0.05]\\,$.\n  - 线圈系数 $\\,\\mathbf{c}=[0.02,0.03]\\,$ 对应于 $\\,k=1,2\\,$.\n  - $\\,\\iota_{\\text{base}}=0.0\\,$, $\\,t_0=0.0\\,$, $\\,t_1=0.0\\,$, $\\,t_2=0.0\\,$.\n\n- 测试用例 $4$：\n  - $\\,N_{\\text{fp}}=8\\,$, $\\,R_0=4.8\\,$, $\\,A=6.0\\,$, $\\,\\kappa_R=0.14\\,$, $\\,\\kappa_Z=0.06\\,$, $\\,\\kappa_{\\epsilon}=0.02\\,$.\n  - $\\,w_{\\epsilon}=1.5\\,$, $\\,w_{\\iota}=2.5\\,$, $\\,w_{\\text{coil}}=0.05\\,$.\n  - $\\,\\mathcal{M}=\\{(0,2),(1,0),(3,2)\\}\\,$.\n  - 与 $\\,\\mathcal{M}\\,$ 对齐的 $\\,\\mathbf{a}=[0.01,-0.02,0.005]\\,$，$\\,\\mathbf{b}=[-0.012,0.004,0.0]\\,$.\n  - 线圈系数 $\\,\\mathbf{c}=[0.05,-0.01,0.002,-0.0005]\\,$ 对应于 $\\,k=1,2,3,4\\,$.\n  - $\\,\\iota_{\\text{base}}=0.4\\,$, $\\,t_0=0.38\\,$, $\\,t_1=0.05\\,$, $\\,t_2=0.02\\,$.\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含测试套件的结果，格式为一个由方括号括起来的逗号分隔列表，其中每个条目本身都是一个形如 $[J,\\|\\nabla J\\|_2,\\text{stationary}]$ 的列表。例如，输出必须如下所示\n$$\n\\big[\\,[J_1,\\|\\nabla J\\|_{2,1},\\text{True}],\\;[J_2,\\|\\nabla J\\|_{2,2},\\text{False}],\\;\\dots\\big].\n$$\n不得打印任何附加文本。",
            "solution": "用户提供了一个计算等离子体物理学中有效且适定的问题，具体是使用代理模型进行仿星器形状优化。任务是推导并实现一个复合目标函数及其梯度的计算。\n\n复合目标函数 $J$ 是三个项的加权和：一个有效波纹代理 $\\epsilon_{\\text{eff}}$，一个旋转变换剖面误差 $E_{\\iota}$，以及一个线圈平滑度惩罚项 $S_{\\text{coil}}$。\n$$\nJ(\\mathbf{a},\\mathbf{b},\\mathbf{c}) = w_{\\epsilon}\\,\\epsilon_{\\text{eff}}(\\mathbf{a},\\mathbf{b}) \\;+\\; w_{\\iota}\\,E_{\\iota}(\\mathbf{a},\\mathbf{b}) \\;+\\; w_{\\text{coil}}\\,S_{\\text{coil}}(\\mathbf{c})\n$$\n优化变量是用于等离子体边界形状的傅里叶系数集 $\\mathbf{a} = \\{a_{m,n}\\}$、$\\mathbf{b} = \\{b_{m,n}\\}$，以及用于线圈形状的 $\\mathbf{c} = \\{c_k\\}$。我们的任务是推导 $J$ 及其梯度向量 $\\nabla J$ 的显式表达式，其分量是关于每个优化变量的偏导数。\n\n根据微分的线性性质，总目标函数 $J$ 的梯度是其各分量梯度的加权和：\n$$\n\\nabla J \\;=\\; w_{\\epsilon}\\,\\nabla\\epsilon_{\\text{eff}} \\;+\\; w_{\\iota}\\,\\nabla E_{\\iota} \\;+\\; w_{\\text{coil}}\\,\\nabla S_{\\text{coil}}\n$$\n我们将分别推导每一项及其梯度的显式形式。\n\n**1. 有效波纹代理项 ($\\epsilon_{\\text{eff}}$)**\n\n有效波纹被定义为边界系数的一个简单的正定二次型：\n$$\n\\epsilon_{\\text{eff}}(\\mathbf{a},\\mathbf{b}) \\;=\\; \\kappa_{\\epsilon}\\sum_{(m,n)\\in\\mathcal{M}} \\gamma_{m,n}\\,\\big(a_{m,n}^2+b_{m,n}^2\\big)\n$$\n其中模式相关的权重为 $\\gamma_{m,n} \\;=\\; \\frac{m^2 + (n\\,N_{\\text{fp}})^2}{A^2}$。对总目标函数的贡献是 $J_{\\epsilon} = w_{\\epsilon} \\epsilon_{\\text{eff}}$。此表达式已经很明确，无需进一步简化。\n\n关于特定系数 $a_{m',n'}$ 或 $b_{m',n'}$ 的偏导数很容易求得，因为由于变量的正交性，求和会塌缩：\n$$\n\\frac{\\partial \\epsilon_{\\text{eff}}}{\\partial a_{m',n'}} \\;=\\; \\kappa_{\\epsilon} \\sum_{(m,n)\\in\\mathcal{M}} \\gamma_{m,n} \\frac{\\partial}{\\partial a_{m',n'}}(a_{m,n}^2+b_{m,n}^2) \\;=\\; \\kappa_{\\epsilon} \\gamma_{m',n'} (2a_{m',n'})\n$$\n类似地，\n$$\n\\frac{\\partial \\epsilon_{\\text{eff}}}{\\partial b_{m',n'}} \\;=\\; \\kappa_{\\epsilon} \\gamma_{m',n'} (2b_{m',n'})\n$$\n此项不依赖于线圈系数 $\\mathbf{c}$，因此对所有 $k$ 都有 $\\frac{\\partial \\epsilon_{\\text{eff}}}{\\partial c_k} = 0$。\n\n此项对总目标函数的梯度分量贡献为：\n$$\n\\frac{\\partial J_{\\epsilon}}{\\partial a_{m,n}} = 2 w_{\\epsilon} \\kappa_{\\epsilon} \\gamma_{m,n} a_{m,n} \\quad \\text{和} \\quad \\frac{\\partial J_{\\epsilon}}{\\partial b_{m,n}} = 2 w_{\\epsilon} \\kappa_{\\epsilon} \\gamma_{m,n} b_{m,n}\n$$\n\n**2. 线圈平滑度惩罚项 ($S_{\\text{coil}}$)**\n\n线圈平滑度惩罚项由线圈径向函数 $R_{\\text{c}}(\\phi) = R_{\\text{c},0} + \\sum_{k=1}^{K_{\\text{c}}} c_k \\cos(k\\,\\phi)$ 的二阶导数平方的积分定义：\n$$\nS_{\\text{coil}}(\\mathbf{c}) \\;=\\; \\int_{0}^{2\\pi}\\left(\\frac{d^2 R_{\\text{c}}}{d\\phi^2}(\\phi)\\right)^2\\,d\\phi\n$$\n首先，我们计算二阶导数：\n$$\n\\frac{d R_{\\text{c}}}{d\\phi} = -\\sum_{k=1}^{K_{\\text{c}}} k\\,c_k\\,\\sin(k\\,\\phi) \\quad \\implies \\quad \\frac{d^2 R_{\\text{c}}}{d\\phi^2} = -\\sum_{k=1}^{K_{\\text{c}}} k^2\\,c_k\\,\\cos(k\\,\\phi)\n$$\n将此代入 $S_{\\text{coil}}$ 的积分中：\n$$\nS_{\\text{coil}} = \\int_{0}^{2\\pi} \\left( \\sum_{k=1}^{K_{\\text{c}}} k^2 c_k \\cos(k\\phi) \\right) \\left( \\sum_{\\ell=1}^{K_{\\text{c}}} \\ell^2 c_{\\ell} \\cos(\\ell\\phi) \\right) d\\phi = \\sum_{k=1}^{K_c} \\sum_{\\ell=1}^{K_c} k^2 \\ell^2 c_k c_\\ell \\int_{0}^{2\\pi} \\cos(k\\phi) \\cos(\\ell\\phi) \\,d\\phi\n$$\n使用给定的恒等式 $\\int_{0}^{2\\pi}\\cos(k\\phi)\\cos(\\ell\\phi)\\,d\\phi = \\pi \\delta_{k\\ell}$（对于 $k, \\ell \\ge 1$），其中 $\\delta_{k\\ell}$ 是克罗内克δ函数，该积分仅在 $k=\\ell$ 时非零。表达式简化为：\n$$\nS_{\\text{coil}} = \\sum_{k=1}^{K_{\\text{c}}} k^4 c_k^2 (\\pi) = \\pi\\sum_{k=1}^{K_{\\text{c}}} k^4 c_k^2\n$$\n对总目标函数的贡献是 $J_{\\text{coil}} = w_{\\text{coil}} S_{\\text{coil}}$。此项仅依赖于 $\\mathbf{c}$。\n关于系数 $c_{k'}$ 的梯度为：\n$$\n\\frac{\\partial S_{\\text{coil}}}{\\partial c_{k'}} = \\pi \\frac{\\partial}{\\partial c_{k'}} \\sum_{k=1}^{K_{\\text{c}}} k^4 c_k^2 = 2\\pi (k')^4 c_{k'}\n$$\n对总目标函数的梯度分量为：\n$$\n\\frac{\\partial J_{\\text{coil}}}{\\partial c_k} = 2\\pi w_{\\text{coil}} k^4 c_k\n$$\n\n**3. 旋转变换剖面误差 ($E_{\\iota}$)**\n\n$E_{\\iota}$ 项是代理旋转变换 $\\iota(s)$ 与目标剖面 $\\iota_{\\text{target}}(s)$ 之间差值的平方 $L^2$ 范数：\n$$\nE_{\\iota}(\\mathbf{a},\\mathbf{b}) \\;=\\; \\int_{0}^{1}\\Big(\\iota(s) - \\iota_{\\text{target}}(s)\\Big)^2\\,ds\n$$\n令差值为 $\\Delta\\iota(s) = \\iota(s) - \\iota_{\\text{target}}(s)$。使用给定的定义：\n$$\n\\Delta\\iota(s) = (\\iota_{\\text{base}} - t_0) - t_1 s - t_2 s^2 + \\sum_{(m,n)\\in\\mathcal{M}} \\Big(\\alpha_{m,n}\\,a_{m,n}\\,s^{m} + \\beta_{m,n}\\,b_{m,n}\\,s^{m+1}\\Big)\n$$\n为了计算 $E_\\iota$ 及其梯度，方便先定义辅助积分 $I_k = \\int_0^1 \\Delta\\iota(s) s^k ds$。根据积分的线性和使用恒等式 $\\int_0^1 s^p ds = \\frac{1}{p+1}$：\n$$\nI_k = \\int_0^1 \\left( (\\iota_{\\text{base}} - t_0)s^k - t_1 s^{k+1} - t_2 s^{k+2} + \\sum_{(m,n)\\in\\mathcal{M}} (\\alpha_{m,n} a_{m,n} s^{m+k} + \\beta_{m,n} b_{m,n} s^{m+1+k}) \\right) ds\n$$\n$$\nI_k = \\frac{\\iota_{\\text{base}} - t_0}{k+1} - \\frac{t_1}{k+2} - \\frac{t_2}{k+3} + \\sum_{(m,n)\\in\\mathcal{M}} \\left( \\frac{\\alpha_{m,n} a_{m,n}}{m+k+1} + \\frac{\\beta_{m,n} b_{m,n}}{m+k+2} \\right)\n$$\n$E_\\iota$ 的值可以通过展开其定义并使用 $I_k$ 积分来计算：\n$$\nE_\\iota = \\int_0^1 \\Delta\\iota(s) \\Delta\\iota(s) ds = \\int_0^1 \\Delta\\iota(s) \\left( (\\iota_{\\text{base}} - t_0) - t_1 s - t_2 s^2 + \\sum_{(m,n)\\in\\mathcal{M}} \\dots \\right) ds\n$$\n$$\nE_\\iota = (\\iota_{\\text{base}} - t_0)I_0 - t_1 I_1 - t_2 I_2 + \\sum_{(m,n)\\in\\mathcal{M}} \\left( a_{m,n} \\alpha_{m,n} I_m + b_{m,n} \\beta_{m,n} I_{m+1} \\right)\n$$\n$E_\\iota$ 的梯度使用链式法则求得。对于系数 $a_{m',n'}$：\n$$\n\\frac{\\partial E_\\iota}{\\partial a_{m',n'}} = \\int_0^1 2\\Delta\\iota(s) \\frac{\\partial \\Delta\\iota(s)}{\\partial a_{m',n'}} ds\n$$\n由于 $\\frac{\\partial \\Delta\\iota(s)}{\\partial a_{m',n'}} = \\alpha_{m',n'}s^{m'}$，我们得到：\n$$\n\\frac{\\partial E_\\iota}{\\partial a_{m',n'}} = 2\\alpha_{m',n'} \\int_0^1 \\Delta\\iota(s) s^{m'} ds = 2\\alpha_{m',n'} I_{m'}\n$$\n类似地，由于 $\\frac{\\partial \\Delta\\iota(s)}{\\partial b_{m',n'}} = \\beta_{m',n'}s^{m'+1}$：\n$$\n\\frac{\\partial E_\\iota}{\\partial b_{m',n'}} = 2\\beta_{m',n'} \\int_0^1 \\Delta\\iota(s) s^{m'+1} ds = 2\\beta_{m',n'} I_{m'+1}\n$$\n此项对总目标函数的梯度分量贡献为：\n$$\n\\frac{\\partial J_{\\iota}}{\\partial a_{m,n}} = 2 w_{\\iota} \\alpha_{m,n} I_m \\quad \\text{和} \\quad \\frac{\\partial J_{\\iota}}{\\partial b_{m,n}} = 2 w_{\\iota} \\beta_{m,n} I_{m+1}\n$$\n\n**4. 目标函数和梯度总结**\n\n总目标函数 $J$ 是三项贡献之和：\n$$\nJ = w_{\\epsilon} \\kappa_{\\epsilon} \\sum_{(m,n)\\in\\mathcal{M}} \\gamma_{m,n} (a_{m,n}^2 + b_{m,n}^2) \\;+\\; w_{\\iota} E_{\\iota} \\;+\\; w_{\\text{coil}} \\pi \\sum_{k=1}^{K_c} k^4 c_k^2\n$$\n总梯度分量是每一项贡献之和：\n$$\n\\frac{\\partial J}{\\partial a_{m,n}} = 2 w_{\\epsilon} \\kappa_{\\epsilon} \\gamma_{m,n} a_{m,n} + 2 w_{\\iota} \\alpha_{m,n} I_m\n$$\n$$\n\\frac{\\partial J}{\\partial b_{m,n}} = 2 w_{\\epsilon} \\kappa_{\\epsilon} \\gamma_{m,n} b_{m,n} + 2 w_{\\iota} \\beta_{m,n} I_{m+1}\n$$\n$$\n\\frac{\\partial J}{\\partial c_k} = 2\\pi w_{\\text{coil}} k^4 c_k\n$$\n总体算法首先涉及计算必要的 $\\alpha$、$\\beta$、$\\gamma$ 系数，然后是 $I_k$ 积分，最后组装总目标函数 $J$ 及其梯度 $\\nabla J$ 的分量。然后从此梯度向量计算欧几里得范数 $\\|\\nabla J\\|_2$。",
            "answer": "```python\nimport numpy as np\n\ndef compute_J_and_grad(Nfp, R0, A, kR, kZ, ke, we, wi, wc, M, a_coeffs, b_coeffs, c_coeffs, ibase, t0, t1, t2):\n    \"\"\"\n    Computes the composite objective J and its gradient norm for a single test case.\n    \"\"\"\n    # Tolerance for stationarity check\n    tau = 1e-10\n\n    # Map list coefficients to dictionaries keyed by mode/index for clarity\n    a = {mode: coeff for mode, coeff in zip(M, a_coeffs)}\n    b = {mode: coeff for mode, coeff in zip(M, b_coeffs)}\n    c = {k: coeff for k, coeff in enumerate(c_coeffs, 1)}\n\n    # Initialize objective and gradient components\n    J = 0.0\n    grad_a = {mode: 0.0 for mode in M}\n    grad_b = {mode: 0.0 for mode in M}\n    grad_c = {k: 0.0 for k in c.keys()}\n\n    # --- 1. Effective Ripple Term (epsilon_eff) ---\n    if we > 0.0:\n        eps_eff = 0.0\n        for m, n in M:\n            gamma_mn = (m**2 + (n * Nfp)**2) / A**2\n            a_mn = a.get((m, n), 0.0)\n            b_mn = b.get((m, n), 0.0)\n            \n            eps_eff += gamma_mn * (a_mn**2 + b_mn**2)\n            \n            # Gradient contribution\n            grad_a[(m, n)] += we * ke * 2.0 * gamma_mn * a_mn\n            grad_b[(m, n)] += we * ke * 2.0 * gamma_mn * b_mn\n            \n        J += we * ke * eps_eff\n\n    # --- 2. Coil Smoothness Term (S_coil) ---\n    if wc > 0.0:\n        S_coil = 0.0\n        for k, c_k in c.items():\n            S_coil += (k**4) * (c_k**2)\n            \n            # Gradient contribution\n            grad_c[k] += wc * np.pi * 2.0 * (k**4) * c_k\n            \n        J += wc * np.pi * S_coil\n\n    # --- 3. Rotational Transform Error Term (E_iota) ---\n    if wi > 0.0:\n        # Pre-compute alpha and beta coefficients\n        alpha = {}\n        beta = {}\n        for m, n in M:\n            nNfp_sq = (n * Nfp)**2\n            m_over_R0 = m / R0\n            alpha[(m, n)] = kR / (1.0 + nNfp_sq) * (m_over_R0**2)\n            beta[(m, n)] = kZ / (1.0 + nNfp_sq) * m_over_R0\n\n        # Determine which I_k integrals are needed\n        needed_powers = {0, 1, 2}\n        for m, n in M:\n            needed_powers.add(m)\n            needed_powers.add(m + 1)\n        \n        # Compute I_k integrals\n        I = {}\n        C0 = ibase - t0\n        for k in needed_powers:\n            sum_term = 0.0\n            for m, n in M:\n                a_mn = a.get((m, n), 0.0)\n                b_mn = b.get((m, n), 0.0)\n                sum_term += (alpha[(m, n)] * a_mn) / (m + k + 1)\n                sum_term += (beta[(m, n)] * b_mn) / (m + k + 2)\n\n            I[k] = C0 / (k + 1) - t1 / (k + 2) - t2 / (k + 3) + sum_term\n\n        # Compute E_iota\n        E_iota_sum = 0.0\n        for m, n in M:\n            a_mn = a.get((m, n), 0.0)\n            b_mn = b.get((m, n), 0.0)\n            E_iota_sum += a_mn * alpha[(m, n)] * I[m]\n            E_iota_sum += b_mn * beta[(m, n)] * I[m + 1]\n\n        E_iota = C0 * I[0] - t1 * I[1] - t2 * I[2] + E_iota_sum\n        J += wi * E_iota\n\n        # Gradient contributions\n        for m, n in M:\n            grad_a[(m, n)] += wi * 2.0 * alpha[(m, n)] * I[m]\n            grad_b[(m, n)] += wi * 2.0 * beta[(m, n)] * I[m + 1]\n\n    # --- 4. Final Gradient Norm Calculation ---\n    grad_vector = []\n    # Ensure a consistent order for reproducibility\n    sorted_modes = sorted(M)\n    for m, n in sorted_modes:\n        grad_vector.append(grad_a[(m,n)])\n    for m, n in sorted_modes:\n        grad_vector.append(grad_b[(m,n)])\n    sorted_k = sorted(c.keys())\n    for k in sorted_k:\n        grad_vector.append(grad_c[k])\n\n    grad_norm = np.linalg.norm(grad_vector)\n    is_stationary = grad_norm  tau\n    \n    return [J, grad_norm, is_stationary]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {\n            \"Nfp\": 5, \"R0\": 5.5, \"A\": 8.0, \"kR\": 0.12, \"kZ\": 0.07, \"ke\": 0.03,\n            \"we\": 1.0, \"wi\": 5.0, \"wc\": 0.1,\n            \"M\": [(1, 0), (2, 1)],\n            \"a\": [0.02, -0.01], \"b\": [0.015, 0.0],\n            \"c\": [0.1, -0.02, 0.005],\n            \"ibase\": 0.3, \"t0\": 0.35, \"t1\": 0.2, \"t2\": -0.1\n        },\n        # Test case 2\n        {\n            \"Nfp\": 5, \"R0\": 5.5, \"A\": 8.0, \"kR\": 0.12, \"kZ\": 0.07, \"ke\": 0.03,\n            \"we\": 0.2, \"wi\": 10.0, \"wc\": 0.0,\n            \"M\": [(1, 0), (2, 1)],\n            \"a\": [0.0, 0.0], \"b\": [0.0, 0.0],\n            \"c\": [0.0, 0.0],\n            \"ibase\": 0.32, \"t0\": 0.3, \"t1\": 0.0, \"t2\": 0.0\n        },\n        # Test case 3\n        {\n            \"Nfp\": 4, \"R0\": 6.2, \"A\": 10.0, \"kR\": 0.1, \"kZ\": 0.08, \"ke\": 0.05,\n            \"we\": 0.0, \"wi\": 0.0, \"wc\": 2.0,\n            \"M\": [(1, 1)],\n            \"a\": [0.1], \"b\": [-0.05],\n            \"c\": [0.02, 0.03],\n            \"ibase\": 0.0, \"t0\": 0.0, \"t1\": 0.0, \"t2\": 0.0\n        },\n        # Test case 4\n        {\n            \"Nfp\": 8, \"R0\": 4.8, \"A\": 6.0, \"kR\": 0.14, \"kZ\": 0.06, \"ke\": 0.02,\n            \"we\": 1.5, \"wi\": 2.5, \"wc\": 0.05,\n            \"M\": [(0, 2), (1, 0), (3, 2)],\n            \"a\": [0.01, -0.02, 0.005], \"b\": [-0.012, 0.004, 0.0],\n            \"c\": [0.05, -0.01, 0.002, -0.0005],\n            \"ibase\": 0.4, \"t0\": 0.38, \"t1\": 0.05, \"t2\": 0.02\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_J_and_grad(\n            case[\"Nfp\"], case[\"R0\"], case[\"A\"],\n            case[\"kR\"], case[\"kZ\"], case[\"ke\"],\n            case[\"we\"], case[\"wi\"], case[\"wc\"],\n            case[\"M\"], case[\"a\"], case[\"b\"], case[\"c\"],\n            case[\"ibase\"], case[\"t0\"], case[\"t1\"], case[\"t2\"]\n        )\n        results.append(result)\n\n    # Format the final output string exactly as required\n    results_str = \",\".join(map(str, results))\n    print(f\"[{results_str}]\")\n\nsolve()\n```"
        }
    ]
}