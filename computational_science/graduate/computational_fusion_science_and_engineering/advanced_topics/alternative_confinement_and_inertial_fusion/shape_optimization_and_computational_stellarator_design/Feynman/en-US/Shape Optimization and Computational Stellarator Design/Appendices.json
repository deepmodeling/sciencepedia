{
    "hands_on_practices": [
        {
            "introduction": "The magnetic fields that confine a stellarator plasma are produced by an intricate set of external coils. This exercise provides hands-on practice with the fundamental first step in stellarator design: computing the magnetic field from a current-carrying wire using the Biot-Savart law, $\\mathbf{B}(\\mathbf{r}) = \\frac{\\mu_0 I}{4\\pi} \\int \\frac{d\\mathbf{l} \\times (\\mathbf{r} - \\mathbf{r}_c)}{\\|\\mathbf{r} - \\mathbf{r}_c\\|^3}$. By discretizing a coil into straight segments and implementing a numerical quadrature, you will develop a core computational skill and understand how numerical accuracy depends on the resolution of the model .",
            "id": "4044824",
            "problem": "In computational stellarator design, magnetic fields from filamentary coils are evaluated repeatedly during shape optimization. Consider a single, closed, smooth coil curve parameterized by arc length. Let the coil be a circular loop of radius $R_0$ centered at the origin in the plane $z=0$, parameterized by arc length $s \\in [0,L)$ with $L = 2\\pi R_0$ and position $\\mathbf{r}_c(s) = \\big(R_0 \\cos(s/R_0),\\, R_0 \\sin(s/R_0),\\, 0\\big)$. A steady current $I$ flows along the coil. The magnetic field $\\mathbf{B}(\\mathbf{r})$ at a point $\\mathbf{r}$ in space is given by the magnetostatic Biot–Savart law for a filamentary current,\n$$\n\\mathbf{B}(\\mathbf{r}) = \\frac{\\mu_0 I}{4\\pi} \\int_0^L \\frac{d\\mathbf{r}_c(s) \\times \\big(\\mathbf{r} - \\mathbf{r}_c(s)\\big)}{\\left\\|\\mathbf{r} - \\mathbf{r}_c(s)\\right\\|^3}\\, ds,\n$$\nwhere $\\mu_0$ is the magnetic permeability of free space and $d\\mathbf{r}_c(s) = \\frac{d\\mathbf{r}_c}{ds} ds$.\n\nTask: Starting from this fundamental law and the arc-length parameterization, design and implement a numerical method that discretizes the coil into straight segments of uniform arc length and approximates $\\mathbf{B}$ at a set of boundary points by numerical quadrature. Use a midpoint rule over segments derived from the arc-length parameterization. Quantify the error as a function of the segment length by comparing to a high-resolution reference computation, and estimate the observed convergence order.\n\nUse the following concrete and scientifically sound setup, units, and test suite:\n\n- Physical constants and parameters:\n  - Magnetic permeability: $\\mu_0 = 4\\pi \\times 10^{-7}\\,\\mathrm{T\\cdot m/A}$.\n  - Coil radius: $R_0 = 1.5\\,\\mathrm{m}$, so $L = 2\\pi R_0$.\n  - Current: $I = 5.0 \\times 10^4\\,\\mathrm{A}$.\n- Boundary (evaluation) points:\n  - Define a circle of radius $a = 0.4\\,\\mathrm{m}$ in the plane $z=z_0$ with $z_0 = 0.3\\,\\mathrm{m}$, centered on the $z$-axis. Parameterize the boundary as $\\mathbf{r}_b(\\varphi) = \\big(a\\cos\\varphi,\\, a\\sin\\varphi,\\, z_0\\big)$ with $\\varphi \\in [0,2\\pi)$ in radians. Use $M=64$ uniformly spaced angles $\\varphi_m = 2\\pi m/M$ for $m=0,1,\\dots,M-1$.\n- Discretization and numerical approximation:\n  - For a given integer $N \\ge 2$, discretize the arc-length domain $[0,L)$ into $N$ equal subintervals of length $h = L/N$. Construct straight segments between $\\mathbf{r}_c(s_i)$ and $\\mathbf{r}_c(s_{i+1})$ with $s_i = i h$ and $s_{i+1} = (i+1)h$ for $i=0,1,\\dots,N-1$, interpreting indices modulo $N$ for closure. Use a midpoint quadrature over each segment to approximate the integral. Angles in trigonometric functions must be in radians.\n  - For a high-resolution reference, use $N_\\mathrm{ref} = 8192$ to approximate $\\mathbf{B}_\\mathrm{ref}$ at the same boundary points. This serves as the ground-truth surrogate in lieu of a closed-form solution off-axis.\n- Error measure and convergence order:\n  - For each $N$ in the test suite below, compute the root-mean-square (RMS) vector error over the $M$ boundary points,\n    $$\n    E(N) = \\sqrt{\\frac{1}{M}\\sum_{m=0}^{M-1} \\left\\| \\mathbf{B}_N\\big(\\mathbf{r}_b(\\varphi_m)\\big) - \\mathbf{B}_\\mathrm{ref}\\big(\\mathbf{r}_b(\\varphi_m)\\big) \\right\\|_2^2 }.\n    $$\n    Express $E(N)$ in tesla ($\\mathrm{T}$).\n  - Let $h(N) = L/N$ be the segment length. Using the set $\\{(h(N), E(N))\\}$ for the test suite values of $N$, estimate the observed convergence order $p$ by fitting a straight line to $\\log E$ versus $\\log h$ using least squares and taking the slope as $p$.\n- Test suite:\n  - Use $N \\in \\{20, 40, 80, 160\\}$.\n- Required final output format:\n  - Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain the four RMS errors for the test suite $N$ values in ascending order, followed by the estimated convergence order $p$. For example, print\n    $$\n    [E(20), E(40), E(80), E(160), p].\n    $$\n  - The numerical values are unitful quantities internally, but the output list must contain only raw numbers (no units text). The errors are in $\\mathrm{T}$ and the convergence order is dimensionless.\n\nDesign your algorithm from first principles, starting from the Biot–Savart law and the arc-length parameterization. Do not invoke pre-derived shortcut formulas for finite segments in the problem statement. Ensure scientific realism by adhering to the stated geometry and units. The solution must be universally understandable by a developer and self-contained, reproducible, and numerically robust for the given parameter choices.",
            "solution": "The problem asks for the design and implementation of a numerical method to calculate the magnetic field generated by a circular current loop, based on a discretization of the Biot-Savart law. This involves approximating the continuous, curved coil with a series of straight segments and using a midpoint rule to evaluate the contribution of each segment. The accuracy of this approximation is then quantified by calculating the root-mean-square (RMS) error against a high-resolution reference computation, and the order of convergence is estimated.\n\nThe fundamental principle is the Biot-Savart law for a filamentary current loop, which gives the magnetic field $\\mathbf{B}$ at a position $\\mathbf{r}$ as an integral over the coil's path:\n$$\n\\mathbf{B}(\\mathbf{r}) = \\frac{\\mu_0 I}{4\\pi} \\int_{\\text{coil}} \\frac{d\\mathbf{l} \\times \\mathbf{d}}{\\|\\mathbf{d}\\|^3}\n$$\nwhere $d\\mathbf{l}$ is a differential vector element along the coil carrying current $I$, $\\mathbf{d} = \\mathbf{r} - \\mathbf{r}_c(s)$ is the vector from the source point on the coil $\\mathbf{r}_c(s)$ to the evaluation point $\\mathbf{r}$, and $\\mu_0 = 4\\pi \\times 10^{-7}\\,\\mathrm{T\\cdot m/A}$ is the magnetic permeability of free space. For the given problem, the coil is parameterized by arc length $s \\in [0, L)$, with $L = 2\\pi R_0$ and $\\mathbf{r}_c(s) = (R_0 \\cos(s/R_0), R_0 \\sin(s/R_0), 0)$. The differential element is $d\\mathbf{l} = \\frac{d\\mathbf{r}_c}{ds} ds$.\n\nThe core of the task is to approximate this integral numerically. The problem specifies a method wherein the smooth circular coil is replaced by a closed polygon of $N$ straight segments. The vertices of this polygon lie on the original circular path.\nLet the arc length domain $[0, L)$ be divided into $N$ equal subintervals, each of length $h = L/N$. The vertices of the approximating polygon are then given by the points $\\mathbf{p}_i = \\mathbf{r}_c(s_i)$ where $s_i = i \\cdot h$ for $i=0, 1, \\dots, N$. Since the coil is closed, $\\mathbf{p}_N = \\mathbf{p}_0$. The $i$-th straight segment connects vertex $\\mathbf{p}_i$ to $\\mathbf{p}_{i+1}$ (with the index interpreted modulo $N$).\n\nThe integral over the entire coil is then approximated by a sum of contributions from these $N$ straight segments:\n$$\n\\mathbf{B}(\\mathbf{r}) \\approx \\mathbf{B}_N(\\mathbf{r}) = \\sum_{i=0}^{N-1} \\Delta\\mathbf{B}_i(\\mathbf{r})\n$$\nwhere $\\Delta\\mathbf{B}_i(\\mathbf{r})$ is the magnetic field contribution from the $i$-th segment. The problem directs us to use a midpoint rule for each segment. This involves approximating the integral over the $i$-th segment by evaluating the integrand at the segment's geometric midpoint and using the segment's vector as the differential element.\n\nFor the $i$-th segment, which runs from $\\mathbf{p}_i$ to $\\mathbf{p}_{i+1}$:\n1.  The vector representing the entire segment is $\\Delta\\mathbf{L}_i = \\mathbf{p}_{i+1} - \\mathbf{p}_i$.\n2.  The geometric midpoint of this segment is $\\mathbf{l}_{\\text{mid}, i} = \\frac{\\mathbf{p}_i + \\mathbf{p}_{i+1}}{2}$.\n3.  The vector from the segment's midpoint to the evaluation point $\\mathbf{r}$ is $\\mathbf{d}_i = \\mathbf{r} - \\mathbf{l}_{\\text{mid}, i}$.\n\nApplying the midpoint rule, we approximate the contribution from the $i$-th segment by treating it as a single differential element $\\Delta\\mathbf{L}_i$ located at its midpoint $\\mathbf{l}_{\\text{mid}, i}$:\n$$\n\\Delta\\mathbf{B}_i(\\mathbf{r}) \\approx \\frac{\\mu_0 I}{4\\pi} \\frac{\\Delta\\mathbf{L}_i \\times \\mathbf{d}_i}{\\|\\mathbf{d}_i\\|^3} = \\frac{\\mu_0 I}{4\\pi} \\frac{(\\mathbf{p}_{i+1} - \\mathbf{p}_i) \\times \\left(\\mathbf{r} - \\frac{\\mathbf{p}_i + \\mathbf{p}_{i+1}}{2}\\right)}{\\left\\|\\mathbf{r} - \\frac{\\mathbf{p}_i + \\mathbf{p}_{i+1}}{2}\\right\\|^3}\n$$\nThe total approximated magnetic field at $\\mathbf{r}$ for a discretization level $N$ is the sum of these contributions:\n$$\n\\mathbf{B}_N(\\mathbf{r}) = \\frac{\\mu_0 I}{4\\pi} \\sum_{i=0}^{N-1} \\frac{(\\mathbf{p}_{i+1} - \\mathbf{p}_i) \\times \\left(\\mathbf{r} - \\frac{\\mathbf{p}_i + \\mathbf{p}_{i+1}}{2}\\right)}{\\left\\|\\mathbf{r} - \\frac{\\mathbf{p}_i + \\mathbf{p}_{i+1}}{2}\\right\\|^3}\n$$\nThis formula is implemented in a function that computes $\\mathbf{B}_N$ at a given set of evaluation points. The given parameters are the coil radius $R_0 = 1.5\\,\\mathrm{m}$ and current $I = 5.0 \\times 10^4\\,\\mathrm{A}$. The total arc length is $L = 2\\pi R_0 = 3\\pi\\,\\mathrm{m}$. The evaluation points lie on a circle of radius $a = 0.4\\,\\mathrm{m}$ in the plane $z = z_0 = 0.3\\,\\mathrm{m}$. There are $M=64$ such points, given by $\\mathbf{r}_b(\\varphi_m) = (a\\cos\\varphi_m, a\\sin\\varphi_m, z_0)$ for $\\varphi_m = 2\\pi m/M$.\n\nTo assess the numerical error, a high-resolution reference field, $\\mathbf{B}_\\mathrm{ref}$, is computed using the same method but with a much larger number of segments, $N_\\mathrm{ref} = 8192$. For each $N$ in the test suite $\\{20, 40, 80, 160\\}$, the approximate field $\\mathbf{B}_N$ is computed at the $M=64$ boundary points. The RMS vector error is then calculated as:\n$$\nE(N) = \\sqrt{\\frac{1}{M}\\sum_{m=0}^{M-1} \\left\\| \\mathbf{B}_N(\\mathbf{r}_m) - \\mathbf{B}_\\mathrm{ref}(\\mathbf{r}_m) \\right\\|_2^2 }\n$$\nThe convergence behavior of this numerical scheme is characterized by the relationship $E(N) \\propto h^p$, where $h = L/N$ is the characteristic length scale (the arc-length of a segment) and $p$ is the order of convergence. This implies a linear relationship in a log-log plot: $\\log E(N) = p \\log h + C$. The order $p$ is estimated by performing a linear least-squares fit to the data points $(\\log h(N), \\log E(N))$ for the\nvalues of $N$ in the test suite. The slope of the resulting line is the estimated order of convergence, $p$. This numerical scheme, which is a form of midpoint rule on a polygonally approximated curve, is expected to exhibit second-order convergence, i.e., $p \\approx 2$.\n\nThe final algorithm is as follows:\n1. Define all physical and geometric constants: $\\mu_0, I, R_0, a, z_0, M$.\n2. Generate the $M=64$ evaluation points on the boundary circle.\n3. Implement a function `compute_B(N, eval_points)` that calculates $\\mathbf{B}_N$ using the summation formula derived above.\n4. Calculate the reference field $\\mathbf{B}_\\mathrm{ref}$ by calling `compute_B` with $N_\\mathrm{ref} = 8192$.\n5. For each $N \\in \\{20, 40, 80, 160\\}$:\n   a. Calculate the approximate field $\\mathbf{B}_N$ using `compute_B(N, eval_points)`.\n   b. Compute and store the RMS error $E(N)$ with respect to $\\mathbf{B}_\\mathrm{ref}$.\n   c. Store the corresponding segment arc-length $h(N) = 2\\pi R_0 / N$.\n6. Take the logarithm of the stored error and segment length arrays.\n7. Use linear regression (e.g., `numpy.polyfit`) on the log-log data to find the slope, which is the estimated convergence order $p$.\n8. Format and output the four error values and the convergence order $p$ as specified.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes magnetic field from a circular coil, evaluates error and convergence.\n    \"\"\"\n    # 1. DEFINE CONSTANTS AND PARAMETERS\n    # Physical constants and parameters\n    mu_0 = 4.0 * np.pi * 1.0e-7  # T*m/A\n    R0 = 1.5  # m\n    I = 5.0e4  # A\n    \n    # Pre-calculate constant factor in Biot-Savart law\n    B_FACTOR = (mu_0 * I) / (4.0 * np.pi) # This simplifies to I * 1e-7\n\n    # Boundary (evaluation) points parameters\n    a = 0.4  # m\n    z0 = 0.3  # m\n    M = 64  # Number of boundary points\n\n    # Discretization and analysis parameters\n    N_ref = 8192\n    N_test_suite = [20, 40, 80, 160]\n\n    # Total arc length of the coil\n    L = 2.0 * np.pi * R0\n\n    # 2. HELPER FUNCTION TO COMPUTE B-FIELD\n    def compute_B(N, r_eval_points):\n        \"\"\"\n        Calculates the magnetic field B at specified evaluation points.\n        \n        Args:\n            N (int): Number of straight segments to approximate the coil.\n            r_eval_points (np.ndarray): Array of shape (M, 3) containing the\n                                        coordinates of the M evaluation points.\n            \n        Returns:\n            np.ndarray: Array of shape (M, 3) with the B-field vectors.\n        \"\"\"\n        # Generate the N+1 vertices of the polygonal coil approximation\n        s_values = np.linspace(0, L, N + 1)\n        angles = s_values / R0\n        px = R0 * np.cos(angles)\n        py = R0 * np.sin(angles)\n        pz = np.zeros(N + 1)\n        # coil_points is a (N+1, 3) array of vertices\n        coil_points = np.vstack((px, py, pz)).T\n\n        # Initialize B-field array for all evaluation points.\n        B_field = np.zeros_like(r_eval_points)\n        \n        # Loop over each segment of the coil\n        for i in range(N):\n            p_i = coil_points[i]\n            p_i_plus_1 = coil_points[i+1]\n            \n            # Vector for the current segment\n            delta_L_i = p_i_plus_1 - p_i\n            \n            # Midpoint of the current segment\n            l_mid_i = (p_i + p_i_plus_1) / 2.0\n            \n            # Vector from segment midpoint to each evaluation point\n            # l_mid_i is (3,), r_eval_points is (M, 3). Broadcasting expands\n            # l_mid_i to (M, 3) for vectorized subtraction.\n            d_i = r_eval_points - l_mid_i  # Shape: (M, 3)\n            \n            # Magnitude of d_i for each evaluation point\n            d_i_norm = np.linalg.norm(d_i, axis=1) # Shape: (M,)\n            \n            # Cross product: delta_L_i x d_i\n            # delta_L_i is (3,), d_i is (M, 3).\n            # np.cross handles this broadcasting.\n            cross_product = np.cross(delta_L_i, d_i) # Shape: (M, 3)\n            \n            # Denominator term ||d_i||^3\n            # We need to reshape d_i_norm to (M,1) for broadcasting with the (M,3) cross product.\n            denominator = d_i_norm[:, np.newaxis]**3\n            \n            # Add this segment's contribution to the total B-field\n            B_field += cross_product / denominator\n            \n        return B_FACTOR * B_field\n\n    # 3. SETUP SIMULATION\n    # Generate the M evaluation points on the boundary circle\n    phi_m = np.linspace(0, 2 * np.pi, M, endpoint=False)\n    r_eval_x = a * np.cos(phi_m)\n    r_eval_y = a * np.sin(phi_m)\n    r_eval_z = np.full(M, z0)\n    r_boundary = np.vstack((r_eval_x, r_eval_y, r_eval_z)).T\n\n    # 4. RUN COMPUTATIONS\n    # Compute the high-resolution reference field\n    B_ref = compute_B(N_ref, r_boundary)\n\n    errors = []\n    h_values = []\n    \n    # Loop through the test suite for N\n    for N in N_test_suite:\n        # Compute the approximate field B_N\n        B_N = compute_B(N, r_boundary)\n        \n        # Compute the difference vector for each point\n        diff_vectors = B_N - B_ref\n        \n        # Compute the squared L2 norm of each difference vector\n        squared_norms = np.sum(diff_vectors**2, axis=1)\n        \n        # Compute the mean of the squared norms\n        mean_squared_error = np.mean(squared_norms)\n        \n        # The RMS error is the square root of the MSE\n        rms_error = np.sqrt(mean_squared_error)\n        errors.append(rms_error)\n        \n        # Store the corresponding segment arc-length h\n        h = L / N\n        h_values.append(h)\n\n    # 5. ESTIMATE CONVERGENCE ORDER\n    log_E = np.log(np.array(errors))\n    log_h = np.log(np.array(h_values))\n    \n    # Fit a line (polynomial of degree 1) to the log-log data\n    # The slope is the first element of the returned coefficients\n    p = np.polyfit(log_h, log_E, 1)[0]\n\n    # 6. FORMAT AND PRINT FINAL OUTPUT\n    results = errors + [p]\n    # Use '.8e' for robust scientific notation representation\n    print(f\"[{','.join(f'{val:.8e}' for val in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "One of the most important figures of merit in modern stellarator design is quasisymmetry, a property of the magnetic field that ensures good plasma confinement. This exercise frames the search for quasisymmetry as a practical optimization problem, where the goal is to adjust the shape of the plasma to minimize the Fourier modes of the magnetic field strength that break this symmetry. You will implement a Tikhonov-regularized least-squares solution, a powerful technique used to find stable and physically meaningful designs in the face of ill-posed problems .",
            "id": "4044803",
            "problem": "Consider a simplified model of computational stellarator design in which the magnitude of the magnetic field on a flux surface is represented in Boozer coordinates by a truncated Fourier series. Let the poloidal angle be denoted by $\\theta$ and the toroidal angle be denoted by $\\zeta$, both in radians. For a given normalized toroidal flux surface labeled by $\\rho \\in (0,1)$, model the magnitude of the magnetic field as\n$$\n|B|(\\theta,\\zeta;\\rho) \\equiv \\sum_{(m,n)\\in \\mathcal{K}} b_{m,n}(\\rho)\\,\\cos(m\\theta - n\\zeta),\n$$\nwhere $\\mathcal{K}$ is a finite mode set and $b_{m,n}(\\rho)$ are the Fourier coefficients. Quasisymmetry (QS) with helicity $(M,N)\\in \\mathbb{Z}\\times\\mathbb{Z}$ is approximated in this model when $|B|(\\theta,\\zeta;\\rho)$ depends only on the helical angle $\\alpha\\equiv M\\theta - N\\zeta$, that is, when all Fourier components with $(m,n)$ not satisfying $mN - nM = 0$ are negligible. We call $(m,n)$ resonant if $mN - nM = 0$ and nonresonant otherwise.\n\nAssume a linearized shape response model in which the Fourier coefficients $b_{m,n}(\\rho)$ depend on a small set of shape parameters $\\mathbf{p}\\in\\mathbb{R}^3$ via\n$$\nb_{m,n}(\\rho;\\mathbf{p}) \\equiv a_{m,n}(\\rho) + \\sum_{i=1}^{3} S_{m,n,i}(\\rho)\\,p_i,\n$$\nwhere $a_{m,n}(\\rho)$ are baseline coefficients and $S_{m,n,i}(\\rho)$ are sensitivity coefficients. Assume the following mode set:\n$$\n\\mathcal{K} \\equiv \\{(m,n)\\,|\\, m\\in\\{0,1,2\\},\\, n\\in\\{-1,0,1\\},\\, (m,n)\\neq(0,0)\\}.\n$$\nThe baseline coefficients are given by the deterministic formula\n$$\na_{m,n}(\\rho) \\equiv 0.04 + 0.01\\,m + 0.02\\,|n| + 0.005\\,\\rho,\n$$\nand the sensitivities are given by\n$$\nS_{m,n,1}(\\rho) \\equiv 0.10\\,e^{-\\rho}\\,(m+1)\\,(n^2+1),\n$$\n$$\nS_{m,n,2}(\\rho) \\equiv -0.08\\,e^{-0.5\\rho}\\,(m\\,n + 1),\n$$\n$$\nS_{m,n,3}(\\rho) \\equiv 0.05\\,(m^2+n^2)\\,(1-\\rho).\n$$\nTo evaluate the extent of approximate quasisymmetry achievable by minimizing nonresonant Fourier modes, consider the Tikhonov-regularized least-squares problem\n$$\n\\min_{\\mathbf{p}\\in\\mathbb{R}^3}\\; J(\\mathbf{p}) \\equiv \\sum_{\\rho\\in\\mathcal{S}} \\sum_{(m,n)\\in\\mathcal{K}\\,:\\, mN-nM\\neq 0} \\left[b_{m,n}(\\rho;\\mathbf{p})\\right]^2 \\;+\\; \\lambda\\,\\|\\mathbf{p}\\|_2^2,\n$$\nwhere $\\mathcal{S}$ is a set of selected flux surfaces and $\\lambda>0$ is a regularization parameter. For the minimizing $\\mathbf{p}^\\star$, quantify residual symmetry breaking on each surface $\\rho\\in\\mathcal{S}$ via the ratio\n$$\nR(\\rho;M,N,\\lambda) \\equiv \\frac{\\sum\\limits_{(m,n)\\in\\mathcal{K}\\,:\\, mN-nM\\neq 0}\\left[b_{m,n}(\\rho;\\mathbf{p}^\\star)\\right]^2}{\\sum\\limits_{(m,n)\\in\\mathcal{K}}\\left[b_{m,n}(\\rho;\\mathbf{p}^\\star)\\right]^2},\n$$\nwhich lies in $[0,1]$ and measures the fraction of spectral energy in nonresonant modes relative to the total.\n\nStarting from the definitions of Fourier representation on the torus, the quasisymmetry resonance condition, and the linearized response model, derive a computational method to obtain $\\mathbf{p}^\\star$ and then compute $R(\\rho;M,N,\\lambda)$ for each $\\rho\\in\\mathcal{S}$.\n\nAngle unit specification: all angles are in radians.\n\nYour program must implement the above model and produce numerical values for the following test suite, where the helicity $(M,N)$, the flux surface set $\\mathcal{S}$, and the regularization $\\lambda$ are varied to probe different scenarios:\n\n- Test case $1$ (happy path, quasi-axisymmetry): $(M,N)=(1,0)$, $\\mathcal{S}=\\{0.3, 0.6, 0.9\\}$, $\\lambda=0.001$.\n- Test case $2$ (helical quasisymmetry): $(M,N)=(1,1)$, $\\mathcal{S}=\\{0.25, 0.5, 0.75\\}$, $\\lambda=0.001$.\n- Test case $3$ (edge case with strong regularization): $(M,N)=(2,1)$, $\\mathcal{S}=\\{0.2, 0.8\\}$, $\\lambda=0.5$.\n- Test case $4$ (boundary case with limited resonant content): $(M,N)=(0,1)$, $\\mathcal{S}=\\{0.4\\}$, $\\lambda=0.001$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a list of floating-point numbers corresponding to $R(\\rho;M,N,\\lambda)$ for the surfaces in $\\mathcal{S}$, rounded to six decimal places. For example, the output format must be\n$$\n[\\,[r_{1,1},r_{1,2},\\dots],\\,[r_{2,1},r_{2,2},\\dots],\\,[r_{3,1},\\dots],\\,[r_{4,1},\\dots]\\,],\n$$\nwhere $r_{k,j}$ denotes the residual ratio for the $j$-th surface in the $k$-th test case. No additional text should be printed.",
            "solution": "The problem is well-posed and scientifically grounded within the context of computational plasma physics and optimization. It presents a simplified but standard model for stellarator shape optimization aimed at achieving approximate quasisymmetry. All necessary definitions, formulas, and data are provided, and there are no internal contradictions or logical flaws. We may therefore proceed directly to the derivation of the solution.\n\nThe core of the problem is to find the shape parameter vector $\\mathbf{p} \\in \\mathbb{R}^3$ that minimizes the Tikhonov-regularized cost function $J(\\mathbf{p})$:\n$$\nJ(\\mathbf{p}) \\equiv \\sum_{\\rho\\in\\mathcal{S}} \\sum_{(m,n)\\in\\mathcal{K}_{\\text{NR}}} \\left[b_{m,n}(\\rho;\\mathbf{p})\\right]^2 \\;+\\; \\lambda\\,\\|\\mathbf{p}\\|_2^2\n$$\nwhere $\\mathcal{K}_{\\text{NR}} = \\{(m,n)\\in\\mathcal{K}\\,|\\, mN-nM\\neq 0\\}$ is the set of nonresonant modes for a given helicity $(M,N)$. The term $\\|{\\mathbf{p}}\\|_2^2$ is the squared Euclidean norm of $\\mathbf{p}$, i.e., $p_1^2 + p_2^2 + p_3^2$.\n\nLet us substitute the linear model for the magnetic field coefficients $b_{m,n}$ into the cost function:\n$$\nb_{m,n}(\\rho;\\mathbf{p}) = a_{m,n}(\\rho) + \\sum_{i=1}^{3} S_{m,n,i}(\\rho)\\,p_i\n$$\nThe cost function becomes:\n$$\nJ(\\mathbf{p}) = \\sum_{\\rho\\in\\mathcal{S}} \\sum_{(m,n)\\in\\mathcal{K}_{\\text{NR}}} \\left( a_{m,n}(\\rho) + \\sum_{i=1}^{3} S_{m,n,i}(\\rho)\\,p_i \\right)^2 + \\lambda \\sum_{i=1}^{3} p_i^2\n$$\nThis is a standard linear least-squares problem with Tikhonov regularization (also known as ridge regression). We can express this in matrix-vector form. Let us define a single index $k$ that enumerates all pairs $(\\rho, (m,n))$ appearing in the double summation. Let the total number of such terms be $L$. We can then define a matrix $A$ of size $L \\times 3$ and a vector $\\mathbf{y}$ of size $L \\times 1$.\n\nFor each $k$ corresponding to a pair $(\\rho, (m,n))$, the $k$-th row of the matrix $A$ is given by the sensitivity coefficients:\n$$\nA_{k,i} = S_{m,n,i}(\\rho) \\quad \\text{for } i=1,2,3\n$$\nand the $k$-th element of the vector $\\mathbf{y}$ is given by the negative of the baseline coefficient:\n$$\ny_k = -a_{m,n}(\\rho)\n$$\nWith these definitions, the first term of the cost function can be written as the squared norm of a vector:\n$$\n\\sum_{k=1}^{L} \\left( y_k - \\sum_{i=1}^{3} A_{k,i}\\,p_i \\right)^2 = \\|\\mathbf{y} - A\\mathbf{p}\\|_2^2\n$$\nWait, the signs are flipped. The term in the sum is $(a_{m,n} + \\sum S_{m,n,i} p_i)^2 = (-y_k + \\sum A_{k,i} p_i)^2 = (A\\mathbf{p} - \\mathbf{y})_k^2$. The expression is correct.\n\nThe complete cost function in matrix-vector form is:\n$$\nJ(\\mathbf{p}) = \\|A\\mathbf{p} - \\mathbf{y}\\|_2^2 + \\lambda \\|\\mathbf{p}\\|_2^2\n$$\nTo find the optimal vector $\\mathbf{p}^\\star$ that minimizes $J(\\mathbf{p})$, we compute the gradient of $J$ with respect to $\\mathbf{p}$ and set it to zero.\n$$\n\\nabla_{\\mathbf{p}} J(\\mathbf{p}) = \\nabla_{\\mathbf{p}} \\left( (A\\mathbf{p} - \\mathbf{y})^T (A\\mathbf{p} - \\mathbf{y}) + \\lambda \\mathbf{p}^T \\mathbf{p} \\right)\n$$\n$$\n\\nabla_{\\mathbf{p}} J(\\mathbf{p}) = \\nabla_{\\mathbf{p}} \\left( \\mathbf{p}^T A^T A \\mathbf{p} - 2\\mathbf{y}^T A \\mathbf{p} + \\mathbf{y}^T \\mathbf{y} + \\lambda \\mathbf{p}^T \\mathbf{p} \\right)\n$$\n$$\n\\nabla_{\\mathbf{p}} J(\\mathbf{p}) = 2 A^T A \\mathbf{p} - 2 A^T \\mathbf{y} + 2 \\lambda \\mathbf{p}\n$$\nSetting the gradient to zero gives the normal equations for this regularized problem:\n$$\n2 A^T A \\mathbf{p}^\\star - 2 A^T \\mathbf{y} + 2 \\lambda \\mathbf{p}^\\star = \\mathbf{0}\n$$\n$$\n(A^T A + \\lambda I) \\mathbf{p}^\\star = A^T \\mathbf{y}\n$$\nwhere $I$ is the $3 \\times 3$ identity matrix. This is a $3 \\times 3$ system of linear equations for the unknown vector $\\mathbf{p}^\\star$. Since $\\lambda > 0$ and $A^T A$ is positive semi-definite, the matrix $(A^T A + \\lambda I)$ is positive definite and therefore invertible, guaranteeing a unique solution:\n$$\n\\mathbf{p}^\\star = (A^T A + \\lambda I)^{-1} A^T \\mathbf{y}\n$$\nOnce the optimal parameter vector $\\mathbf{p}^\\star = (p_1^\\star, p_2^\\star, p_3^\\star)^T$ is found, we can evaluate the residual symmetry breaking ratio $R(\\rho)$ for each surface $\\rho \\in \\mathcal{S}$. First, we compute the optimized Fourier coefficients for all modes $(m,n) \\in \\mathcal{K}$:\n$$\nb_{m,n}(\\rho; \\mathbf{p}^\\star) = a_{m,n}(\\rho) + S_{m,n,1}(\\rho)p_1^\\star + S_{m,n,2}(\\rho)p_2^\\star + S_{m,n,3}(\\rho)p_3^\\star\n$$\nThe ratio $R(\\rho)$ is then calculated as the energy in nonresonant modes divided by the total energy:\n$$\nR(\\rho;M,N,\\lambda) = \\frac{\\sum\\limits_{(m,n)\\in\\mathcal{K}_{\\text{NR}}}\\left[b_{m,n}(\\rho;\\mathbf{p}^\\star)\\right]^2}{\\sum\\limits_{(m,n)\\in\\mathcal{K}}\\left[b_{m,n}(\\rho;\\mathbf{p}^\\star)\\right]^2}\n$$\nThe computational procedure for each test case is as follows:\n1.  Define the mode set $\\mathcal{K} = \\{(m,n)\\,|\\, m\\in\\{0,1,2\\},\\, n\\in\\{-1,0,1\\},\\, (m,n)\\neq(0,0)\\}$.\n2.  Given $(M,N)$, identify the set of nonresonant modes $\\mathcal{K}_{\\text{NR}}$.\n3.  Construct the matrix $A$ and vector $\\mathbf{y}$ by iterating through each surface $\\rho \\in \\mathcal{S}$ and each nonresonant mode $(m,n) \\in \\mathcal{K}_{\\text{NR}}$. For each such pair, compute the row vector $[S_{m,n,1}(\\rho), S_{m,n,2}(\\rho), S_{m,n,3}(\\rho)]$ and append it to $A$, and compute the scalar $-a_{m,n}(\\rho)$ and append it to $\\mathbf{y}$.\n4.  Solve the $3 \\times 3$ linear system $(A^T A + \\lambda I) \\mathbf{p}^\\star = A^T \\mathbf{y}$ to find $\\mathbf{p}^\\star$.\n5.  For each $\\rho \\in \\mathcal{S}$, calculate all coefficients $b_{m,n}(\\rho; \\mathbf{p}^\\star)$ for all $(m,n) \\in \\mathcal{K}$.\n6.  Compute the numerator and denominator of $R(\\rho)$ by summing the squares of the relevant coefficients, and find their ratio.\n7.  Collect the computed values of $R(\\rho)$ for all surfaces in $\\mathcal{S}$.\nThis procedure is implemented for each of the four test cases provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a Tikhonov-regularized least-squares problem for stellarator \n    quasisymmetry optimization and computes a residual symmetry-breaking metric.\n    \"\"\"\n    \n    # Define the mode set K = {(m,n) | m in {0,1,2}, n in {-1,0,1}} \\ {(0,0)}\n    modes_k = []\n    for m in range(3):\n        for n in range(-1, 2):\n            if m == 0 and n == 0:\n                continue\n            modes_k.append((m, n))\n\n    # Define the baseline and sensitivity coefficient functions\n    def a_mn(m, n, rho):\n        return 0.04 + 0.01 * m + 0.02 * abs(n) + 0.005 * rho\n\n    def s_mn1(m, n, rho):\n        return 0.10 * np.exp(-rho) * (m + 1) * (n**2 + 1)\n\n    def s_mn2(m, n, rho):\n        return -0.08 * np.exp(-0.5 * rho) * (m * n + 1)\n\n    def s_mn3(m, n, rho):\n        return 0.05 * (m**2 + n**2) * (1 - rho)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (M, N, S_surfaces, lambda_reg)\n        (1, 0, [0.3, 0.6, 0.9], 0.001),\n        (1, 1, [0.25, 0.5, 0.75], 0.001),\n        (2, 1, [0.2, 0.8], 0.5),\n        (0, 1, [0.4], 0.001),\n    ]\n\n    # Store results for final printing\n    results_as_strings = []\n\n    for case in test_cases:\n        M, N, S_surfaces, lambda_reg = case\n\n        # 1. Identify non-resonant modes\n        modes_k_nr = [\n            (m, n) for m, n in modes_k if m * N - n * M != 0\n        ]\n\n        # 2. Construct the matrix A and vector y\n        A_rows = []\n        y_elements = []\n        for rho in S_surfaces:\n            for m, n in modes_k_nr:\n                row = [s_mn1(m, n, rho), s_mn2(m, n, rho), s_mn3(m, n, rho)]\n                A_rows.append(row)\n                y_elements.append(-a_mn(m, n, rho))\n        \n        A = np.array(A_rows)\n        y = np.array(y_elements)\n\n        # 3. Solve for the optimal parameters p_star\n        AtA = A.T @ A\n        Aty = A.T @ y\n        # Solve (AtA + lambda * I) * p_star = Aty\n        H = AtA + lambda_reg * np.identity(3)\n        p_star = np.linalg.solve(H, Aty)\n        \n        # 4. Compute the residual ratio R for each surface\n        r_values_for_case = []\n        for rho in S_surfaces:\n            numerator = 0.0\n            denominator = 0.0\n\n            # Iterate over all modes in K to calculate total energy (denominator)\n            # and non-resonant energy (numerator)\n            for m, n in modes_k:\n                b_mn_p_star = (\n                    a_mn(m, n, rho) +\n                    s_mn1(m, n, rho) * p_star[0] +\n                    s_mn2(m, n, rho) * p_star[1] +\n                    s_mn3(m, n, rho) * p_star[2]\n                )\n                b_squared = b_mn_p_star**2\n                denominator += b_squared\n                \n                # Check if the mode is non-resonant\n                if m * N - n * M != 0:\n                    numerator += b_squared\n            \n            # Avoid division by zero, though unlikely in this problem\n            ratio = numerator / denominator if denominator != 0 else 0.0\n            r_values_for_case.append(ratio)\n        \n        # Format this test case's results for the final output string\n        formatted_r_strings = [f\"{r:.6f}\" for r in r_values_for_case]\n        sublist_string = f\"[{','.join(formatted_r_strings)}]\"\n        results_as_strings.append(sublist_string)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A successful stellarator design must balance competing physics goals, such as good confinement and a stable plasma profile, with engineering constraints, like manufacturable coils. This exercise simulates this multi-objective challenge by asking you to build a composite objective function, $J = w_{\\epsilon}\\,\\epsilon_{\\text{eff}} + w_{\\iota}\\,E_{\\iota} + w_{\\text{coil}}\\,S_{\\text{coil}}$, from several surrogate models representing plasma performance and coil complexity. By deriving and implementing the analytical gradient $\\nabla J$, you will be taking the essential step required to apply powerful, large-scale gradient-based optimization algorithms that are at the heart of modern stellarator design .",
            "id": "4044763",
            "problem": "You are given a simplified, yet physically consistent, surrogate model for a stellarator boundary shape and a coil set, together with a composite objective for shape optimization. The shape is represented by a truncated Fourier series on the boundary in cylindrical coordinates, while the coils are represented by a scalar radial Fourier series that modulates a circular torus. All angles are in radians. Your task is to implement a complete program that computes the composite objective and its gradient with respect to the boundary Fourier coefficients, derived from fundamental definitions, and evaluate it on a specified test suite.\n\nFundamental base and core definitions:\n\n- The boundary surface in cylindrical coordinates has a major radius component modeled by a truncated Fourier series in poloidal angle $\\,\\theta\\,$ and toroidal angle $\\,\\zeta\\,$ with field periodicity $\\,N_{\\text{fp}}\\,$ (number of field periods), as\n$$\nR(\\theta,\\zeta) = R_0 + \\sum_{(m,n)\\in \\mathcal{M}} a_{m,n}\\,\\cos\\!\\big(m\\,\\theta - n\\,N_{\\text{fp}}\\,\\zeta\\big),\n$$\nand a vertical component\n$$\nZ(\\theta,\\zeta) = \\sum_{(m,n)\\in \\mathcal{M}} b_{m,n}\\,\\sin\\!\\big(m\\,\\theta - n\\,N_{\\text{fp}}\\,\\zeta\\big).\n$$\nThe optimization variables for the boundary are the real Fourier coefficients $\\,a_{m,n}\\,$ and $\\,b_{m,n}\\,$ for modes $\\,\\mathcal{M}\\,$. The angles $\\,\\theta\\,$ and $\\,\\zeta\\,$ are $\\,2\\pi\\,$-periodic.\n\n- The coil centerline is modeled as a circular torus of angle $\\,\\phi\\in[0,2\\pi)\\,$ with a scalar radial modulation\n$$\nR_{\\text{c}}(\\phi) = R_{\\text{c},0} + \\sum_{k=1}^{K_{\\text{c}}} c_k \\cos(k\\,\\phi),\n$$\nwith the planar embedding\n$$\nx(\\phi) = R_{\\text{c}}(\\phi)\\cos\\phi,\\quad y(\\phi) = R_{\\text{c}}(\\phi)\\sin\\phi,\\quad z(\\phi)=0.\n$$\nThe coil smoothness penalty uses the curvature surrogate via the second derivative of $\\,R_{\\text{c}}(\\phi)\\,$ with respect to $\\,\\phi\\,$. The optimization variables for the coil are the Fourier coefficients $\\,c_k\\,$.\n\n- The composite objective is\n$$\nJ(\\mathbf{a},\\mathbf{b},\\mathbf{c}) = w_{\\epsilon}\\,\\epsilon_{\\text{eff}}(\\mathbf{a},\\mathbf{b}) \\;+\\; w_{\\iota}\\,E_{\\iota}(\\mathbf{a},\\mathbf{b}) \\;+\\; w_{\\text{coil}}\\,S_{\\text{coil}}(\\mathbf{c}),\n$$\nwhere $\\,w_{\\epsilon}>0\\,$, $\\,w_{\\iota}>0\\,$, and $\\,w_{\\text{coil}}>0\\,$ are user-specified scalar weights.\n\n- The effective ripple surrogate is defined by a quadratic form that increases with non-axisymmetric corrugations,\n$$\n\\epsilon_{\\text{eff}}(\\mathbf{a},\\mathbf{b}) \\;=\\; \\kappa_{\\epsilon}\\sum_{(m,n)\\in\\mathcal{M}} \\gamma_{m,n}\\,\\big(a_{m,n}^2+b_{m,n}^2\\big),\n$$\nwith\n$$\n\\gamma_{m,n} \\;=\\; \\frac{m^2 + (n\\,N_{\\text{fp}})^2}{A^2},\n$$\nwhere $\\,A>0\\,$ is a given aspect-ratio-like scale and $\\,\\kappa_{\\epsilon}>0\\,$ is a given normalization.\n\n- The rotational transform profile surrogate $\\,\\iota(s)\\,$, as a function of normalized toroidal flux coordinate $\\,s\\in[0,1]\\,$, is defined by\n$$\n\\iota(s) \\;=\\; \\iota_{\\text{base}} \\;+\\; \\sum_{(m,n)\\in\\mathcal{M}} \\Big(\\alpha_{m,n}\\,a_{m,n}\\,s^{m} \\;+\\; \\beta_{m,n}\\,b_{m,n}\\,s^{m+1}\\Big),\n$$\nwhere\n$$\n\\alpha_{m,n} \\;=\\; \\frac{\\kappa_R}{1+(n\\,N_{\\text{fp}})^2}\\left(\\frac{m}{R_0}\\right)^2,\\qquad\n\\beta_{m,n} \\;=\\; \\frac{\\kappa_Z}{1+(n\\,N_{\\text{fp}})^2}\\left(\\frac{m}{R_0}\\right).\n$$\nThe constants $\\,\\kappa_R>0\\,$ and $\\,\\kappa_Z>0\\,$ encode the linear sensitivity of the rotational transform to boundary deformations in this surrogate; $\\,R_0>0\\,$ is the major radius scale. The target rotational transform profile is a quadratic polynomial\n$$\n\\iota_{\\text{target}}(s) \\;=\\; t_0 + t_1\\,s + t_2\\,s^2,\n$$\nwith given scalars $\\,t_0,t_1,t_2\\,$. The profile error is the squared $\\,L^2\\,$-distance on $[0,1]$,\n$$\nE_{\\iota}(\\mathbf{a},\\mathbf{b}) \\;=\\; \\int_{0}^{1}\\Big(\\iota(s) - \\iota_{\\text{target}}(s)\\Big)^2\\,ds.\n$$\n\n- The coil smoothness penalty is defined through the square of the second derivative of $\\,R_{\\text{c}}(\\phi)\\,$,\n$$\nS_{\\text{coil}}(\\mathbf{c}) \\;=\\; \\int_{0}^{2\\pi}\\left(\\frac{d^2 R_{\\text{c}}}{d\\phi^2}(\\phi)\\right)^2\\,d\\phi.\n$$\n\nTasks:\n\n1. Starting from the definitions above and standard properties of trigonometric and monomial integrals, derive explicit expressions for the composite objective $\\,J(\\mathbf{a},\\mathbf{b},\\mathbf{c})\\,$ and its gradient with respect to each optimization variable $\\,a_{m,n}\\,$, $\\,b_{m,n}\\,$, and $\\,c_k\\,$. Use only the identities\n$$\n\\int_{0}^{2\\pi}\\cos(k\\phi)\\cos(\\ell\\phi)\\,d\\phi \\;=\\; \\begin{cases}\n\\pi, & k=\\ell\\ge 1,\\\\\n0, & k\\ne \\ell,\n\\end{cases}\n$$\nand\n$$\n\\int_{0}^{1} s^{p}\\,ds \\;=\\; \\frac{1}{p+1},\\quad p>-1,\n$$\ntogether with linearity of integration and the binomial-free monomial product integral\n$$\n\\int_{0}^{1} s^{p+q}\\,ds \\;=\\; \\frac{1}{p+q+1}.\n$$\n\n2. Implement a program that evaluates $\\,J\\,$ and $\\,\\nabla J\\,$ for a given set of parameters and variables. The program must output, for each test case, a triple consisting of:\n   - the scalar objective value $\\,J\\,$,\n   - the Euclidean norm $\\,\\|\\nabla J\\|_2\\,$,\n   - a boolean indicating whether stationarity holds within tolerance $\\,\\tau=10^{-10}\\,$, i.e., whether $\\,\\|\\nabla J\\|_2 < \\tau\\,$.\n\n3. Angles $\\,\\theta\\,$, $\\,\\zeta\\,$, and $\\,\\phi\\,$ are in radians. All quantities in this problem are dimensionless under the surrogate scalings provided; no physical units are required in the output.\n\nTest suite:\n\nFor each test, you are given $\\,N_{\\text{fp}}\\,$, $\\,R_0\\,$, $\\,A\\,$, $\\,\\kappa_R\\,$, $\\,\\kappa_Z\\,$, $\\,\\kappa_{\\epsilon}\\,$, weights $\\,w_{\\epsilon}\\,$, $\\,w_{\\iota}\\,$, $\\,w_{\\text{coil}}\\,$, the mode set $\\,\\mathcal{M}\\,$, boundary coefficients $\\,\\{a_{m,n}\\}\\,$ and $\\,\\{b_{m,n}\\}\\,$ aligned with $\\,\\mathcal{M}\\,$, coil coefficients $\\,\\{c_k\\}\\,$ for $\\,k=1,\\dots,K_{\\text{c}}\\,$, and the profile parameters $\\,\\iota_{\\text{base}}\\,$, $\\,t_0\\,$, $\\,t_1\\,$, $\\,t_2\\,$.\n\n- Test case $\\,1\\,$:\n  - $\\,N_{\\text{fp}}=5\\,$, $\\,R_0=5.5\\,$, $\\,A=8.0\\,$, $\\,\\kappa_R=0.12\\,$, $\\,\\kappa_Z=0.07\\,$, $\\,\\kappa_{\\epsilon}=0.03\\,$.\n  - $\\,w_{\\epsilon}=1.0\\,$, $\\,w_{\\iota}=5.0\\,$, $\\,w_{\\text{coil}}=0.1\\,$.\n  - $\\,\\mathcal{M}=\\{(1,0),(2,1)\\}\\,$.\n  - $\\,\\mathbf{a}=[0.02,-0.01]\\,$, $\\,\\mathbf{b}=[0.015,0.0]\\,$.\n  - Coil coefficients $\\,\\mathbf{c}=[0.1,-0.02,0.005]\\,$ corresponding to $\\,k=1,2,3\\,$.\n  - $\\,\\iota_{\\text{base}}=0.3\\,$, $\\,t_0=0.35\\,$, $\\,t_1=0.2\\,$, $\\,t_2=-0.1\\,$.\n\n- Test case $\\,2\\,$:\n  - $\\,N_{\\text{fp}}=5\\,$, $\\,R_0=5.5\\,$, $\\,A=8.0\\,$, $\\,\\kappa_R=0.12\\,$, $\\,\\kappa_Z=0.07\\,$, $\\,\\kappa_{\\epsilon}=0.03\\,$.\n  - $\\,w_{\\epsilon}=0.2\\,$, $\\,w_{\\iota}=10.0\\,$, $\\,w_{\\text{coil}}=0.0\\,$.\n  - $\\,\\mathcal{M}=\\{(1,0),(2,1)\\}\\,$.\n  - $\\,\\mathbf{a}=[0.0,0.0]\\,$, $\\,\\mathbf{b}=[0.0,0.0]\\,$.\n  - Coil coefficients $\\,\\mathbf{c}=[0.0,0.0]\\,$ corresponding to $\\,k=1,2\\,$.\n  - $\\,\\iota_{\\text{base}}=0.32\\,$, $\\,t_0=0.3\\,$, $\\,t_1=0.0\\,$, $\\,t_2=0.0\\,$.\n\n- Test case $\\,3\\,$:\n  - $\\,N_{\\text{fp}}=4\\,$, $\\,R_0=6.2\\,$, $\\,A=10.0\\,$, $\\,\\kappa_R=0.1\\,$, $\\,\\kappa_Z=0.08\\,$, $\\,\\kappa_{\\epsilon}=0.05\\,$.\n  - $\\,w_{\\epsilon}=0.0\\,$, $\\,w_{\\iota}=0.0\\,$, $\\,w_{\\text{coil}}=2.0\\,$.\n  - $\\,\\mathcal{M}=\\{(1,1)\\}\\,$.\n  - $\\,\\mathbf{a}=[0.1]\\,$, $\\,\\mathbf{b}=[-0.05]\\,$.\n  - Coil coefficients $\\,\\mathbf{c}=[0.02,0.03]\\,$ corresponding to $\\,k=1,2\\,$.\n  - $\\,\\iota_{\\text{base}}=0.0\\,$, $\\,t_0=0.0\\,$, $\\,t_1=0.0\\,$, $\\,t_2=0.0\\,$.\n\n- Test case $\\,4\\,$:\n  - $\\,N_{\\text{fp}}=8\\,$, $\\,R_0=4.8\\,$, $\\,A=6.0\\,$, $\\,\\kappa_R=0.14\\,$, $\\,\\kappa_Z=0.06\\,$, $\\,\\kappa_{\\epsilon}=0.02\\,$.\n  - $\\,w_{\\epsilon}=1.5\\,$, $\\,w_{\\iota}=2.5\\,$, $\\,w_{\\text{coil}}=0.05\\,$.\n  - $\\,\\mathcal{M}=\\{(0,2),(1,0),(3,2)\\}\\,$.\n  - $\\,\\mathbf{a}=[0.01,-0.02,0.005]\\,$ aligned with $\\,\\mathcal{M}\\,$, $\\,\\mathbf{b}=[-0.012,0.004,0.0]\\,$.\n  - Coil coefficients $\\,\\mathbf{c}=[0.05,-0.01,0.002,-0.0005]\\,$ corresponding to $\\,k=1,2,3,4\\,$.\n  - $\\,\\iota_{\\text{base}}=0.4\\,$, $\\,t_0=0.38\\,$, $\\,t_1=0.05\\,$, $\\,t_2=0.02\\,$.\n\nFinal output format:\n\nYour program should produce a single line of output containing the results for the test suite as a comma-separated list enclosed in square brackets, where each entry is itself a list of the form $[J,\\|\\nabla J\\|_2,\\text{stationary}]$. For example, the output must look like\n$$\n\\big[\\,[J_1,\\|\\nabla J\\|_{2,1},\\text{True}],\\;[J_2,\\|\\nabla J\\|_{2,2},\\text{False}],\\;\\dots\\big].\n$$\nNo additional text must be printed.",
            "solution": "The user has provided a valid, well-posed problem in computational plasma physics, specifically stellarator shape optimization using surrogate models. The task is to derive and implement the calculation of a composite objective function and its gradient.\n\nThe composite objective function $J$ is a weighted sum of three terms: an effective ripple surrogate $\\epsilon_{\\text{eff}}$, a rotational transform profile error $E_{\\iota}$, and a coil smoothness penalty $S_{\\text{coil}}$.\n$$\nJ(\\mathbf{a},\\mathbf{b},\\mathbf{c}) = w_{\\epsilon}\\,\\epsilon_{\\text{eff}}(\\mathbf{a},\\mathbf{b}) \\;+\\; w_{\\iota}\\,E_{\\iota}(\\mathbf{a},\\mathbf{b}) \\;+\\; w_{\\text{coil}}\\,S_{\\text{coil}}(\\mathbf{c})\n$$\nThe optimization variables are the sets of Fourier coefficients $\\mathbf{a} = \\{a_{m,n}\\}$, $\\mathbf{b} = \\{b_{m,n}\\}$ for the plasma boundary shape, and $\\mathbf{c} = \\{c_k\\}$ for the coil shape. Our task is to derive explicit expressions for $J$ and its gradient vector $\\nabla J$, whose components are the partial derivatives with respect to each optimization variable.\n\nDue to the linearity of differentiation, the gradient of the total objective $J$ is the weighted sum of the gradients of its components:\n$$\n\\nabla J \\;=\\; w_{\\epsilon}\\,\\nabla\\epsilon_{\\text{eff}} \\;+\\; w_{\\iota}\\,\\nabla E_{\\iota} \\;+\\; w_{\\text{coil}}\\,\\nabla S_{\\text{coil}}\n$$\nWe will derive the explicit form for each term and its gradient separately.\n\n**1. Effective Ripple Surrogate Term ($\\epsilon_{\\text{eff}}$)**\n\nThe effective ripple is given as a simple positive-definite quadratic form of the boundary coefficients:\n$$\n\\epsilon_{\\text{eff}}(\\mathbf{a},\\mathbf{b}) \\;=\\; \\kappa_{\\epsilon}\\sum_{(m,n)\\in\\mathcal{M}} \\gamma_{m,n}\\,\\big(a_{m,n}^2+b_{m,n}^2\\big)\n$$\nwith mode-dependent weights $\\gamma_{m,n} \\;=\\; \\frac{m^2 + (n\\,N_{\\text{fp}})^2}{A^2}$. The contribution to the total objective is $J_{\\epsilon} = w_{\\epsilon} \\epsilon_{\\text{eff}}$. This expression is already explicit and requires no further simplification.\n\nThe partial derivatives with respect to a specific coefficient $a_{m',n'}$ or $b_{m',n'}$ are straightforward, as the sum collapses due to the orthogonality of the variables:\n$$\n\\frac{\\partial \\epsilon_{\\text{eff}}}{\\partial a_{m',n'}} \\;=\\; \\kappa_{\\epsilon} \\sum_{(m,n)\\in\\mathcal{M}} \\gamma_{m,n} \\frac{\\partial}{\\partial a_{m',n'}}(a_{m,n}^2+b_{m,n}^2) \\;=\\; \\kappa_{\\epsilon} \\gamma_{m',n'} (2a_{m',n'})\n$$\nSimilarly,\n$$\n\\frac{\\partial \\epsilon_{\\text{eff}}}{\\partial b_{m',n'}} \\;=\\; \\kappa_{\\epsilon} \\gamma_{m',n'} (2b_{m',n'})\n$$\nThis term does not depend on the coil coefficients $\\mathbf{c}$, so $\\frac{\\partial \\epsilon_{\\text{eff}}}{\\partial c_k} = 0$ for all $k$.\n\nThe gradient components for the total objective contributed by this term are:\n$$\n\\frac{\\partial J_{\\epsilon}}{\\partial a_{m,n}} = 2 w_{\\epsilon} \\kappa_{\\epsilon} \\gamma_{m,n} a_{m,n} \\quad \\text{and} \\quad \\frac{\\partial J_{\\epsilon}}{\\partial b_{m,n}} = 2 w_{\\epsilon} \\kappa_{\\epsilon} \\gamma_{m,n} b_{m,n}\n$$\n\n**2. Coil Smoothness Penalty ($S_{\\text{coil}}$)**\n\nThe coil smoothness penalty is defined by the integral of the squared second derivative of the coil's radial function $R_{\\text{c}}(\\phi) = R_{\\text{c},0} + \\sum_{k=1}^{K_{\\text{c}}} c_k \\cos(k\\,\\phi)$:\n$$\nS_{\\text{coil}}(\\mathbf{c}) \\;=\\; \\int_{0}^{2\\pi}\\left(\\frac{d^2 R_{\\text{c}}}{d\\phi^2}(\\phi)\\right)^2\\,d\\phi\n$$\nFirst, we compute the second derivative:\n$$\n\\frac{d R_{\\text{c}}}{d\\phi} = -\\sum_{k=1}^{K_{\\text{c}}} k\\,c_k\\,\\sin(k\\,\\phi) \\quad \\implies \\quad \\frac{d^2 R_{\\text{c}}}{d\\phi^2} = -\\sum_{k=1}^{K_{\\text{c}}} k^2\\,c_k\\,\\cos(k\\,\\phi)\n$$\nSubstituting this into the integral for $S_{\\text{coil}}$:\n$$\nS_{\\text{coil}} = \\int_{0}^{2\\pi} \\left( \\sum_{k=1}^{K_{\\text{c}}} k^2 c_k \\cos(k\\phi) \\right) \\left( \\sum_{\\ell=1}^{K_{\\text{c}}} \\ell^2 c_{\\ell} \\cos(\\ell\\phi) \\right) d\\phi = \\sum_{k=1}^{K_c} \\sum_{\\ell=1}^{K_c} k^2 \\ell^2 c_k c_\\ell \\int_{0}^{2\\pi} \\cos(k\\phi) \\cos(\\ell\\phi) \\,d\\phi\n$$\nUsing the provided identity $\\int_{0}^{2\\pi}\\cos(k\\phi)\\cos(\\ell\\phi)\\,d\\phi = \\pi \\delta_{k\\ell}$ for $k, \\ell \\ge 1$, where $\\delta_{k\\ell}$ is the Kronecker delta, the integral is non-zero only for $k=\\ell$. The expression simplifies to:\n$$\nS_{\\text{coil}} = \\sum_{k=1}^{K_{\\text{c}}} k^4 c_k^2 (\\pi) = \\pi\\sum_{k=1}^{K_{\\text{c}}} k^4 c_k^2\n$$\nThe contribution to the total objective is $J_{\\text{coil}} = w_{\\text{coil}} S_{\\text{coil}}$. This term depends only on $\\mathbf{c}$.\nThe gradient with respect to a coefficient $c_{k'}$ is:\n$$\n\\frac{\\partial S_{\\text{coil}}}{\\partial c_{k'}} = \\pi \\frac{\\partial}{\\partial c_{k'}} \\sum_{k=1}^{K_{\\text{c}}} k^4 c_k^2 = 2\\pi (k')^4 c_{k'}\n$$\nThe gradient component for the total objective is:\n$$\n\\frac{\\partial J_{\\text{coil}}}{\\partial c_k} = 2\\pi w_{\\text{coil}} k^4 c_k\n$$\n\n**3. Rotational Transform Profile Error ($E_{\\iota}$)**\n\nThe term $E_{\\iota}$ is the squared $L^2$-norm of the difference between the surrogate rotational transform $\\iota(s)$ and a target profile $\\iota_{\\text{target}}(s)$:\n$$\nE_{\\iota}(\\mathbf{a},\\mathbf{b}) \\;=\\; \\int_{0}^{1}\\Big(\\iota(s) - \\iota_{\\text{target}}(s)\\Big)^2\\,ds\n$$\nLet the difference be $\\Delta\\iota(s) = \\iota(s) - \\iota_{\\text{target}}(s)$. Using the provided definitions:\n$$\n\\Delta\\iota(s) = (\\iota_{\\text{base}} - t_0) - t_1 s - t_2 s^2 + \\sum_{(m,n)\\in\\mathcal{M}} \\Big(\\alpha_{m,n}\\,a_{m,n}\\,s^{m} + \\beta_{m,n}\\,b_{m,n}\\,s^{m+1}\\Big)\n$$\nTo evaluate $E_\\iota$ and its gradient, it is convenient to first define the auxiliary integrals $I_k = \\int_0^1 \\Delta\\iota(s) s^k ds$. By linearity of integration and using the identity $\\int_0^1 s^p ds = \\frac{1}{p+1}$:\n$$\nI_k = \\int_0^1 \\left( (\\iota_{\\text{base}} - t_0)s^k - t_1 s^{k+1} - t_2 s^{k+2} + \\sum_{(m,n)\\in\\mathcal{M}} (\\alpha_{m,n} a_{m,n} s^{m+k} + \\beta_{m,n} b_{m,n} s^{m+1+k}) \\right) ds\n$$\n$$\nI_k = \\frac{\\iota_{\\text{base}} - t_0}{k+1} - \\frac{t_1}{k+2} - \\frac{t_2}{k+3} + \\sum_{(m,n)\\in\\mathcal{M}} \\left( \\frac{\\alpha_{m,n} a_{m,n}}{m+k+1} + \\frac{\\beta_{m,n} b_{m,n}}{m+k+2} \\right)\n$$\nThe value of $E_\\iota$ can be computed by expanding its definition and using the $I_k$ integrals:\n$$\nE_\\iota = \\int_0^1 \\Delta\\iota(s) \\Delta\\iota(s) ds = \\int_0^1 \\Delta\\iota(s) \\left( (\\iota_{\\text{base}} - t_0) - t_1 s - t_2 s^2 + \\sum_{(m,n)\\in\\mathcal{M}} \\dots \\right) ds\n$$\n$$\nE_\\iota = (\\iota_{\\text{base}} - t_0)I_0 - t_1 I_1 - t_2 I_2 + \\sum_{(m,n)\\in\\mathcal{M}} \\left( a_{m,n} \\alpha_{m,n} I_m + b_{m,n} \\beta_{m,n} I_{m+1} \\right)\n$$\nThe gradient of $E_\\iota$ is found using the chain rule. For a coefficient $a_{m',n'}$:\n$$\n\\frac{\\partial E_\\iota}{\\partial a_{m',n'}} = \\int_0^1 2\\Delta\\iota(s) \\frac{\\partial \\Delta\\iota(s)}{\\partial a_{m',n'}} ds\n$$\nSince $\\frac{\\partial \\Delta\\iota(s)}{\\partial a_{m',n'}} = \\alpha_{m',n'}s^{m'}$, we get:\n$$\n\\frac{\\partial E_\\iota}{\\partial a_{m',n'}} = 2\\alpha_{m',n'} \\int_0^1 \\Delta\\iota(s) s^{m'} ds = 2\\alpha_{m',n'} I_{m'}\n$$\nSimilarly, since $\\frac{\\partial \\Delta\\iota(s)}{\\partial b_{m',n'}} = \\beta_{m',n'}s^{m'+1}$:\n$$\n\\frac{\\partial E_\\iota}{\\partial b_{m',n'}} = 2\\beta_{m',n'} \\int_0^1 \\Delta\\iota(s) s^{m'+1} ds = 2\\beta_{m',n'} I_{m'+1}\n$$\nThe gradient components for the total objective contributed by this term are:\n$$\n\\frac{\\partial J_{\\iota}}{\\partial a_{m,n}} = 2 w_{\\iota} \\alpha_{m,n} I_m \\quad \\text{and} \\quad \\frac{\\partial J_{\\iota}}{\\partial b_{m,n}} = 2 w_{\\iota} \\beta_{m,n} I_{m+1}\n$$\n\n**4. Summary of Objective and Gradient**\n\nThe total objective function $J$ is the sum of the three contributions:\n$$\nJ = w_{\\epsilon} \\kappa_{\\epsilon} \\sum_{(m,n)\\in\\mathcal{M}} \\gamma_{m,n} (a_{m,n}^2 + b_{m,n}^2) \\;+\\; w_{\\iota} E_{\\iota} \\;+\\; w_{\\text{coil}} \\pi \\sum_{k=1}^{K_c} k^4 c_k^2\n$$\nThe total gradient components are the sum of the contributions from each term:\n$$\n\\frac{\\partial J}{\\partial a_{m,n}} = 2 w_{\\epsilon} \\kappa_{\\epsilon} \\gamma_{m,n} a_{m,n} + 2 w_{\\iota} \\alpha_{m,n} I_m\n$$\n$$\n\\frac{\\partial J}{\\partial b_{m,n}} = 2 w_{\\epsilon} \\kappa_{\\epsilon} \\gamma_{m,n} b_{m,n} + 2 w_{\\iota} \\beta_{m,n} I_{m+1}\n$$\n$$\n\\frac{\\partial J}{\\partial c_k} = 2\\pi w_{\\text{coil}} k^4 c_k\n$$\nThe overall algorithm involves first computing the necessary $\\alpha$, $\\beta$, $\\gamma$ coefficients, then the $I_k$ integrals, and finally assembling the total objective $J$ and the components of its gradient $\\nabla J$. The Euclidean norm $\\|\\nabla J\\|_2$ is then computed from this gradient vector.",
            "answer": "```python\nimport numpy as np\n\ndef compute_J_and_grad(Nfp, R0, A, kR, kZ, ke, we, wi, wc, M, a_coeffs, b_coeffs, c_coeffs, ibase, t0, t1, t2):\n    \"\"\"\n    Computes the composite objective J and its gradient norm for a single test case.\n    \"\"\"\n    # Tolerance for stationarity check\n    tau = 1e-10\n\n    # Map list coefficients to dictionaries keyed by mode/index for clarity\n    a = {mode: coeff for mode, coeff in zip(M, a_coeffs)}\n    b = {mode: coeff for mode, coeff in zip(M, b_coeffs)}\n    c = {k: coeff for k, coeff in enumerate(c_coeffs, 1)}\n\n    # Initialize objective and gradient components\n    J = 0.0\n    grad_a = {mode: 0.0 for mode in M}\n    grad_b = {mode: 0.0 for mode in M}\n    grad_c = {k: 0.0 for k in c.keys()}\n\n    # --- 1. Effective Ripple Term (epsilon_eff) ---\n    if we > 0.0:\n        eps_eff = 0.0\n        for m, n in M:\n            gamma_mn = (m**2 + (n * Nfp)**2) / A**2\n            a_mn = a.get((m, n), 0.0)\n            b_mn = b.get((m, n), 0.0)\n            \n            eps_eff += gamma_mn * (a_mn**2 + b_mn**2)\n            \n            # Gradient contribution\n            grad_a[(m, n)] += we * ke * 2.0 * gamma_mn * a_mn\n            grad_b[(m, n)] += we * ke * 2.0 * gamma_mn * b_mn\n            \n        J += we * ke * eps_eff\n\n    # --- 2. Coil Smoothness Term (S_coil) ---\n    if wc > 0.0:\n        S_coil = 0.0\n        for k, c_k in c.items():\n            S_coil += (k**4) * (c_k**2)\n            \n            # Gradient contribution\n            grad_c[k] += wc * np.pi * 2.0 * (k**4) * c_k\n            \n        J += wc * np.pi * S_coil\n\n    # --- 3. Rotational Transform Error Term (E_iota) ---\n    if wi > 0.0:\n        # Pre-compute alpha and beta coefficients\n        alpha = {}\n        beta = {}\n        for m, n in M:\n            nNfp_sq = (n * Nfp)**2\n            m_over_R0 = m / R0\n            alpha[(m, n)] = kR / (1.0 + nNfp_sq) * (m_over_R0**2)\n            beta[(m, n)] = kZ / (1.0 + nNfp_sq) * m_over_R0\n\n        # Determine which I_k integrals are needed\n        needed_powers = {0, 1, 2}\n        for m, n in M:\n            needed_powers.add(m)\n            needed_powers.add(m + 1)\n        \n        # Compute I_k integrals\n        I = {}\n        C0 = ibase - t0\n        for k in needed_powers:\n            sum_term = 0.0\n            for m, n in M:\n                a_mn = a.get((m, n), 0.0)\n                b_mn = b.get((m, n), 0.0)\n                sum_term += (alpha[(m, n)] * a_mn) / (m + k + 1)\n                sum_term += (beta[(m, n)] * b_mn) / (m + k + 2)\n\n            I[k] = C0 / (k + 1) - t1 / (k + 2) - t2 / (k + 3) + sum_term\n\n        # Compute E_iota\n        E_iota_sum = 0.0\n        for m, n in M:\n            a_mn = a.get((m, n), 0.0)\n            b_mn = b.get((m, n), 0.0)\n            E_iota_sum += a_mn * alpha[(m, n)] * I[m]\n            E_iota_sum += b_mn * beta[(m, n)] * I[m + 1]\n\n        E_iota = C0 * I[0] - t1 * I[1] - t2 * I[2] + E_iota_sum\n        J += wi * E_iota\n\n        # Gradient contributions\n        for m, n in M:\n            grad_a[(m, n)] += wi * 2.0 * alpha[(m, n)] * I[m]\n            grad_b[(m, n)] += wi * 2.0 * beta[(m, n)] * I[m + 1]\n\n    # --- 4. Final Gradient Norm Calculation ---\n    grad_vector = []\n    # Ensure a consistent order for reproducibility\n    sorted_modes = sorted(M)\n    for m, n in sorted_modes:\n        grad_vector.append(grad_a[(m,n)])\n    for m, n in sorted_modes:\n        grad_vector.append(grad_b[(m,n)])\n    sorted_k = sorted(c.keys())\n    for k in sorted_k:\n        grad_vector.append(grad_c[k])\n\n    grad_norm = np.linalg.norm(grad_vector)\n    is_stationary = grad_norm  tau\n    \n    return [J, grad_norm, is_stationary]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {\n            \"Nfp\": 5, \"R0\": 5.5, \"A\": 8.0, \"kR\": 0.12, \"kZ\": 0.07, \"ke\": 0.03,\n            \"we\": 1.0, \"wi\": 5.0, \"wc\": 0.1,\n            \"M\": [(1, 0), (2, 1)],\n            \"a\": [0.02, -0.01], \"b\": [0.015, 0.0],\n            \"c\": [0.1, -0.02, 0.005],\n            \"ibase\": 0.3, \"t0\": 0.35, \"t1\": 0.2, \"t2\": -0.1\n        },\n        # Test case 2\n        {\n            \"Nfp\": 5, \"R0\": 5.5, \"A\": 8.0, \"kR\": 0.12, \"kZ\": 0.07, \"ke\": 0.03,\n            \"we\": 0.2, \"wi\": 10.0, \"wc\": 0.0,\n            \"M\": [(1, 0), (2, 1)],\n            \"a\": [0.0, 0.0], \"b\": [0.0, 0.0],\n            \"c\": [0.0, 0.0],\n            \"ibase\": 0.32, \"t0\": 0.3, \"t1\": 0.0, \"t2\": 0.0\n        },\n        # Test case 3\n        {\n            \"Nfp\": 4, \"R0\": 6.2, \"A\": 10.0, \"kR\": 0.1, \"kZ\": 0.08, \"ke\": 0.05,\n            \"we\": 0.0, \"wi\": 0.0, \"wc\": 2.0,\n            \"M\": [(1, 1)],\n            \"a\": [0.1], \"b\": [-0.05],\n            \"c\": [0.02, 0.03],\n            \"ibase\": 0.0, \"t0\": 0.0, \"t1\": 0.0, \"t2\": 0.0\n        },\n        # Test case 4\n        {\n            \"Nfp\": 8, \"R0\": 4.8, \"A\": 6.0, \"kR\": 0.14, \"kZ\": 0.06, \"ke\": 0.02,\n            \"we\": 1.5, \"wi\": 2.5, \"wc\": 0.05,\n            \"M\": [(0, 2), (1, 0), (3, 2)],\n            \"a\": [0.01, -0.02, 0.005], \"b\": [-0.012, 0.004, 0.0],\n            \"c\": [0.05, -0.01, 0.002, -0.0005],\n            \"ibase\": 0.4, \"t0\": 0.38, \"t1\": 0.05, \"t2\": 0.02\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_J_and_grad(\n            case[\"Nfp\"], case[\"R0\"], case[\"A\"],\n            case[\"kR\"], case[\"kZ\"], case[\"ke\"],\n            case[\"we\"], case[\"wi\"], case[\"wc\"],\n            case[\"M\"], case[\"a\"], case[\"b\"], case[\"c\"],\n            case[\"ibase\"], case[\"t0\"], case[\"t1\"], case[\"t2\"]\n        )\n        results.append(result)\n\n    # Format the final output string exactly as required\n    results_str = \",\".join(map(str, results))\n    print(f\"[{results_str}]\")\n\nsolve()\n```"
        }
    ]
}