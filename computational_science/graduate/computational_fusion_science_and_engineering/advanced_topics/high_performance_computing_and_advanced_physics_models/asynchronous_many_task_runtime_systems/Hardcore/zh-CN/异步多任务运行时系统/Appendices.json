{
    "hands_on_practices": [
        {
            "introduction": "在异步多任务（AMT）系统中，计算工作被分解为许多独立的任务，但调度每个任务都会带来不可避免的开销。本练习旨在帮助您掌握任务粒度这一核心概念，它决定了有用计算和系统开销之间的平衡。通过建立一个简单的性能模型，您将学习如何量化这一权衡，并为一个给定的计算内核选择最佳的任务大小，以最大限度地提高并行效率。",
            "id": "3951831",
            "problem": "一个计算聚变科学代码中的异步多任务 (AMT) 运行时调度细粒度任务，每个任务在一个大小为 $b$ 的网格数据块上应用局部算子。在目标平台上的经验性微基准测试表明，该运行时会产生一个恒定的每批次调度开销 $o = 15~\\mathrm{\\mu s}$，而一个批次的有用内核时间由于具有立方复杂度的密集局部操作而按 $t(b) = 1.2\\,b^{3}~\\mathrm{\\mu s}$ 的规律扩展。假设有一个由 $M$ 个相同批次组成的大型固定问题，其中 $M \\gg P$，并且在 $P = 64$ 个相同的 worker 之间实现了完美的负载均衡，任务并行性足以使所有 worker 保持忙碌。假设 AMT 运行时对每个批次的开销和有用内核时间是累加执行的， $o$ 和 $t(b)$ 之间没有重叠，并且除了 $o$ 之外的通信和同步成本可以忽略不计，在稳态下不会引入额外的串行化。\n\n从第一性原理出发，将并行效率定义为 $E = \\frac{T_{\\text{ideal}}}{T_{\\text{actual}}}$，其中 $T_{\\text{ideal}}$ 是忽略运行时开销的并行运行时间，$T_{\\text{actual}}$ 是包含每批次开销 $o$ 的实测并行运行时间。使用这些定义，推导出一个关于 $b$ 的条件，以保证对于给定的这个大型固定问题，在 $P = 64$ 个 worker 上效率至少为 $0.90$。报告满足此条件的最小整数 $b$。将你的最终答案表示为一个无量纲的整数。",
            "solution": "问题要求找到能确保并行效率至少为 $0.90$ 的最小整数块大小 $b$。我们按照要求从第一性原理开始分析问题。\n\n整个问题由 $P$ 个 worker 处理 $M$ 个相同的批次组成。\n与单个批次相关的工作有两个组成部分：\n1.  有用内核工作，持续时间为 $t(b) = 1.2\\,b^{3}~\\mathrm{\\mu s}$。\n2.  运行时调度开销，持续时间为 $o = 15~\\mathrm{\\mu s}$。\n\n问题陈述，对于每个批次，开销和有用内核时间是累加的。因此，在单个 worker 上处理一个批次的总时间为 $t_{batch}(b) = t(b) + o$。\n\n对于由 $M$ 个批次组成的整个问题，我们可以定义总有用功和总开销功。我们将总有用计算功表示为 $W_{\\text{useful}}$，总开销表示为 $W_{\\text{overhead}}$。\n$$ W_{\\text{useful}} = M \\cdot t(b) = M \\cdot (1.2\\,b^{3}) $$\n$$ W_{\\text{overhead}} = M \\cdot o = M \\cdot 15 $$\n总实际功 $W_{\\text{actual}}$ 是有用功和开销的总和。\n$$ W_{\\text{actual}} = W_{\\text{useful}} + W_{\\text{overhead}} = M \\cdot (t(b) + o) $$\n\n问题指明了关键假设：完美的负载均衡，足够的任务并行性以保持所有 $P=64$ 个 worker 忙碌，以及超出每批次开销 $o$ 的通信和同步成本可以忽略不计。在这些假设下，总工作被均匀地分配给 $P$ 个 worker。\n\n我们现在可以定义并行运行时间 $T_{\\text{ideal}}$ 和 $T_{\\text{actual}}$。\n$T_{\\text{ideal}}$ 是在没有开销 ($o=0$) 情况下的并行运行时间。它是总有用功除以 worker 的数量。\n$$ T_{\\text{ideal}} = \\frac{W_{\\text{useful}}}{P} = \\frac{M \\cdot t(b)}{P} $$\n$T_{\\text{actual}}$ 是包含开销的实测并行运行时间。它是总实际功除以 worker 的数量。\n$$ T_{\\text{actual}} = \\frac{W_{\\text{actual}}}{P} = \\frac{M \\cdot (t(b) + o)}{P} $$\n\n并行效率 $E$ 定义为理想并行运行时间与实际并行运行时间的比率。\n$$ E = \\frac{T_{\\text{ideal}}}{T_{\\text{actual}}} $$\n代入 $T_{\\text{ideal}}$ 和 $T_{\\text{actual}}$ 的表达式：\n$$ E = \\frac{\\frac{M \\cdot t(b)}{P}}{\\frac{M \\cdot (t(b) + o)}{P}} $$\n$M$ 和 $P$ 项相互抵消。这表明对于此模型，效率与总问题大小和 worker 数量无关，而是由单个任务的“粒度”决定，即其有用功与其开销的比率。\n$$ E = \\frac{t(b)}{t(b) + o} $$\n这个表达式代表了用于有用计算的时间所占的比例。\n\n给定的条件是效率必须至少为 $0.90$。\n$$ E \\ge 0.90 $$\n$$ \\frac{t(b)}{t(b) + o} \\ge 0.90 $$\n\n现在，我们代入 $t(b)$ 和 $o$ 的给定表达式。单位 ($\\mathrm{\\mu s}$) 是一致的，将会被抵消，所以我们可以直接使用数值进行计算。\n$t(b) = 1.2\\,b^3$\n$o = 15$\n$$ \\frac{1.2\\,b^3}{1.2\\,b^3 + 15} \\ge 0.90 $$\n为了求解 $b$，我们重排不等式。因为 $b$ 是一个块大小，$b>0$，这意味着 $1.2\\,b^3 + 15$ 是一个正数，所以我们可以在不等式两边同时乘以它而不用改变不等号的方向。\n$$ 1.2\\,b^3 \\ge 0.90 \\cdot (1.2\\,b^3 + 15) $$\n$$ 1.2\\,b^3 \\ge 0.90 \\cdot 1.2\\,b^3 + 0.90 \\cdot 15 $$\n$$ 1.2\\,b^3 \\ge 1.08\\,b^3 + 13.5 $$\n现在，我们分离出包含 $b^3$ 的项。\n$$ 1.2\\,b^3 - 1.08\\,b^3 \\ge 13.5 $$\n$$ 0.12\\,b^3 \\ge 13.5 $$\n$$ b^3 \\ge \\frac{13.5}{0.12} $$\n$$ b^3 \\ge \\frac{1350}{12} $$\n化简分数：\n$$ b^3 \\ge \\frac{450}{4} = \\frac{225}{2} = 112.5 $$\n为了找到关于 $b$ 的条件，我们对两边取立方根。\n$$ b \\ge \\sqrt[3]{112.5} $$\n我们需要找到满足此条件的最小整数 $b$。我们可以通过检查整数的立方来估算该值：\n$4^3 = 64$\n$5^3 = 125$\n因为 $64  112.5  125$，我们知道 $4  \\sqrt[3]{112.5}  5$。\n不等式 $b \\ge \\sqrt[3]{112.5}$ 要求 $b$ 大于一个介于 $4$ 和 $5$ 之间的数。由于 $b$ 必须是整数，满足此条件的最小整数值为 $5$。\n\n为了验证，我们来检查 $b=4$ 和 $b=5$ 时的效率。\n对于 $b=4$：\n$t(4) = 1.2 \\cdot 4^3 = 1.2 \\cdot 64 = 76.8$。\n$E(4) = \\frac{76.8}{76.8 + 15} = \\frac{76.8}{91.8} \\approx 0.8366$，该值小于 $0.90$。\n对于 $b=5$：\n$t(5) = 1.2 \\cdot 5^3 = 1.2 \\cdot 125 = 150$。\n$E(5) = \\frac{150}{150 + 15} = \\frac{150}{165} = \\frac{10}{11} \\approx 0.9091$，该值大于 $0.90$。\n因此，满足所需效率目标的最小整数 $b$ 值为 $5$。",
            "answer": "$$ \\boxed{5} $$"
        },
        {
            "introduction": "现实世界中的科学模拟通常涉及具有复杂依赖关系的多个计算阶段，这些依赖关系构成了一个任务图。异步多任务运行时的核心优势在于能够根据这些依赖关系自动并发执行独立的任务链。本练习将通过一个简化的计算管线，引导您分析任务依赖图并找出其中的“关键路径”，从而理解它如何决定了整个工作流的最小可能执行时间（即完工时间）。",
            "id": "3951863",
            "problem": "一个计算聚变科学控制回路采用异步多任务 (AMT) 运行时，其中计算被组织为由依赖 future 链接的任务。考虑一个单一的流水线调用，其中四个计算阶段代表不同的物理模块：阶段 $1$（例如，快速平衡预处理器）、阶段 $2$（例如，磁流体动力学更新）、阶段 $3$（例如，射频加热核心）和阶段 $4$（例如，诊断数据同化）。AMT 运行时使用 future 来链接任务，使得一个任务在其所有输入 future 都被满足时便有资格开始，并且如果资源可用，就绪的任务可以并发执行。假设一个理想化的机器模型，它有足够的执行单元（worker）来并发运行任意数量的就绪任务，并且调度开销可以忽略不计。\n\n阶段 $1$、$2$、$3$ 和 $4$ 的持续时间分别为 $2$、$3$、$1$ 和 $4$ 毫秒。依赖结构如下：阶段 $2$ 依赖于阶段 $1$；阶段 $4$ 依赖于阶段 $3$；阶段 $1$ 和 $3$ 是独立的。不存在其他依赖关系。该流水线处理单个输入，AMT 运行时在依赖关系满足后立即调度任务。\n\n仅使用基于 AMT 任务调度和遵守依赖的执行的核心定义的第一性原理推理（例如，就绪任务可以在时间 $0$ 开始，以及任务的最早开始时间由其前驱任务的完成时间决定），确定最小完工时间（makespan），定义为在给定假设下所有四个阶段都完成的最早时间。以毫秒 (ms) 为单位表示您的最终答案。无需四舍五入；以单个实数形式提供精确值。",
            "solution": "该问题要求计算由理想化的异步多任务 (AMT) 运行时执行的一组四个具有指定持续时间和依赖关系的计算任务的最小完工时间。完工时间是从第一个任务开始到最后一个任务完成所经过的总时间。此问题等同于在任务依赖图中找到关键路径的长度。\n\n设 $S_i$ 为阶段 $i$ 的开始时间，$C_i$ 为其完成时间，其中 $i \\in \\{1, 2, 3, 4\\}$。阶段 $i$ 的持续时间表示为 $T_i$。这些量之间的关系是 $C_i = S_i + T_i$。\n\n根据带 future 的 AMT 调度规则：\n1.  没有依赖关系的任务可以在时间 $t=0$ 开始。\n2.  有依赖关系的任务只有在其所有前驱任务都完成后才能开始。在立即调度的假设下，其开始时间是其所有直接前驱任务完成时间的最大值。\n\n该问题指明了两个独立的计算链：\n-   链 A：阶段 $1 \\rightarrow$ 阶段 $2$\n-   链 B：阶段 $3 \\rightarrow$ 阶段 $4$\n\n由于阶段 $1$ 和 $3$ 是独立的且没有前驱任务，它们都可以从时间 $t=0$ 开始。具有足够执行单元的理想化机器模型允许这两条链并发执行。\n\n我们来分析链 A：\n-   阶段 $1$ 没有前驱任务。其开始时间为 $S_1 = 0$ 毫秒。\n-   阶段 $1$ 的持续时间为 $T_1 = 2$ 毫秒。\n-   阶段 $1$ 的完成时间为 $C_1 = S_1 + T_1 = 0 + 2 = 2$ 毫秒。\n-   阶段 $2$ 依赖于阶段 $1$。因此，其最早开始时间是阶段 $1$ 的完成时间。\n-   阶段 $2$ 的开始时间为 $S_2 = C_1 = 2$ 毫秒。\n-   阶段 $2$ 的持续时间为 $T_2 = 3$ 毫秒。\n-   阶段 $2$ 的完成时间为 $C_2 = S_2 + T_2 = 2 + 3 = 5$ 毫秒。\n完成链 A 的总时间是 $C_2 = 5$ 毫秒。\n\n现在，我们来分析与链 A 并行运行的链 B：\n-   阶段 $3$ 没有前驱任务。其开始时间为 $S_3 = 0$ 毫秒。\n-   阶段 $3$ 的持续时间为 $T_3 = 1$ 毫秒。\n-   阶段 $3$ 的完成时间为 $C_3 = S_3 + T_3 = 0 + 1 = 1$ 毫秒。\n-   阶段 $4$ 依赖于阶段 $3$。因此，其最早开始时间是阶段 $3$ 的完成时间。\n-   阶段 $4$ 的开始时间为 $S_4 = C_3 = 1$ 毫秒。\n-   阶段 $4$ 的持续时间为 $T_4 = 4$ 毫秒。\n-   阶段 $4$ 的完成时间为 $C_4 = S_4 + T_4 = 1 + 4 = 5$ 毫秒。\n完成链 B 的总时间是 $C_4 = 5$ 毫秒。\n\n完工时间定义为*所有*四个阶段都完成的最早时间。这是所有任务完成时间的最大值。\n完工时间 = $\\max(C_1, C_2, C_3, C_4)$。\n代入计算出的值：\n完工时间 = $\\max(2~\\mathrm{ms}, 5~\\mathrm{ms}, 1~\\mathrm{ms}, 5~\\mathrm{ms})$。\n这些值的最大值是 $5$ 毫秒。\n\n关键路径是依赖图中的最长路径。在这种情况下，有两条等长的关键路径：$1 \\rightarrow 2$ 和 $3 \\rightarrow 4$。路径 $1 \\rightarrow 2$ 的长度是 $T_1 + T_2 = 2+3 = 5$ 毫秒。路径 $3 \\rightarrow 4$ 的长度是 $T_3 + T_4 = 1+4 = 5$ 毫秒。完工时间由最长路径的长度决定，即 $5$ 毫秒。\n因此，最小完工时间是 $5$ 毫秒。",
            "answer": "$$\n\\boxed{5}\n$$"
        },
        {
            "introduction": "在并行计算中，确保正确性比追求速度更为根本，而内存一致性是其中最微妙的挑战之一。由于现代处理器存在内存操作重排序，一个任务对共享数据的写入可能不会立即对其他任务可见，从而导致难以察觉的数据竞争错误。本练习要求您构建一个具体的反例，以揭示在缺乏同步机制的情况下，简单的标志位如何导致读取到过时数据，然后通过实现具有“释放-获取”语义的通信通道来修复此问题，从而保证计算结果的正确性。",
            "id": "3951864",
            "problem": "给定一个受计算聚变科学与工程中使用的异步多任务运行时系统启发的场景，其中一个全局归约操作会聚合由独立子域任务产生的部分结果。每个子域 $i \\in \\{1,\\dots,n\\}$ 产生一个部分标量值 $x_i^{\\text{new}}$，用以替换一个旧的存储值 $x_i^{\\text{old}}$。聚合器必须计算出正确的总和 $S^{\\star} = \\sum_{i=1}^{n} x_i^{\\text{new}}$。在一个典型的非同步设计中，每个生产者按程序顺序执行两个操作：首先将 $x_i^{\\text{new}}$ 写入一个共享内存位置，然后设置一个就绪标志 $f_i \\leftarrow 1$ 以表示完成。聚合器轮询这些标志，对于每个 $f_i = 1$ 的 $i$，它会读取相应的共享内存单元以归约其值。您必须构建一个反例，证明在没有显式同步的弱内存模型下，这种设计会引入竞争，违反预期的先行发生关系，从而允许聚合器在观察到 $f_i = 1$ 的同时，仍然读取到过时的值 $x_i^{\\text{old}}$ 而非 $x_i^{\\text{new}}$，最终产生不正确的归约结果。然后，您必须使用具有释放-获取语义的单生产者单消费者 (SPSC) 通道来修复此设计，以消除竞争并保证归约的正确性。\n\n使用的基本原理和定义：当不同任务对同一内存位置的两个操作没有通过先行发生关系排序，其中至少一个是写操作，并且没有中间的同步操作时，就会发生数据竞争。释放-获取语义建立了一个先行发生顺序，使得对于一个在写入数据后执行释放操作的生产者，以及一个在读取数据前执行获取操作的消费者，生产者在释放之前的所有写操作，对于消费者在获取之后的所有读操作都变得可见。归约的正确性属性是，聚合器必须计算出 $S^{\\star} = \\sum_{i=1}^{n} x_i^{\\text{new}}$，而不是任何 $x_i^{\\text{old}}$ 和 $x_i^{\\text{new}}$ 值的混合。\n\n您的程序必须实现一个离散事件模型，该模型能捕捉基于标志的非同步设计和 SPSC 通道修复方案。对于非同步模型，您应通过指定一个索引集合 $U \\subseteq \\{1,\\dots,n\\}$ 来模拟一种敌对性交错。对于这些索引，聚合器在观察到 $f_i = 1$ 后，由于重排序和缺少同步，仍然会读取到 $x_i^{\\text{old}}$。对于 SPSC 模型，您应实现以下逻辑语义：每个生产者在将 $x_i^{\\text{new}}$ 发送到通道中时执行一次释放操作，聚合器在接收时执行一次获取操作，从而保证为归约操作观察到的值是 $x_i^{\\text{new}}$。您可以将通道和内存模型实现为纯函数，而无需使用实际线程；但是，逻辑语义必须遵循释放-获取顺序。\n\n测试套件如下，每个案例由三元组 $(n, \\mathbf{x}^{\\text{old}}, \\mathbf{x}^{\\text{new}}, U)$ 指定，其中 $\\mathbf{x}^{\\text{old}}$ 和 $\\mathbf{x}^{\\text{new}}$ 是整数列表：\n- 案例 1：$n = 4$，$\\mathbf{x}^{\\text{old}} = [1,2,3,4]$，$\\mathbf{x}^{\\text{new}} = [2,3,4,5]$，$U = \\varnothing$。\n- 案例 2：$n = 4$，$\\mathbf{x}^{\\text{old}} = [5,1,7,0]$，$\\mathbf{x}^{\\text{new}} = [6,2,8,3]$，$U = \\{2\\}$ 表示索引 2 使用了过时数据。\n- 案例 3 (边界情况)：$n = 0$，$\\mathbf{x}^{\\text{old}} = []$，$\\mathbf{x}^{\\text{new}} = []$，$U = \\varnothing$。\n- 案例 4：$n = 3$，$\\mathbf{x}^{\\text{old}} = [10,20,30]$，$\\mathbf{x}^{\\text{new}} = [11,21,31]$，$U = \\{1,2,3\\}$ 表示所有索引都使用了过时数据。\n\n对于每个案例，您的程序必须计算：\n- 预期的正确归约值 $S^{\\star} = \\sum_{i=1}^{n} x_i^{\\text{new}}$。\n- 非同步归约值 $S^{\\text{unsync}} = \\sum_{i \\in \\{1,\\dots,n\\} \\setminus U} x_i^{\\text{new}} + \\sum_{i \\in U} x_i^{\\text{old}}$。\n- SPSC 释放-获取归约值 $S^{\\text{ra}} = \\sum_{i=1}^{n} x_i^{\\text{new}}$，根据其构造，该值必须等于 $S^{\\star}$。\n\n您的程序必须为每个案例生成一个列表 $[E, C]$，其中 $E = |S^{\\star} - S^{\\text{unsync}}|$ 是一个整数表示的绝对误差，而 $C$ 是一个布尔值，指示 $S^{\\text{ra}} = S^{\\star}$ 是否成立。最终的程序输出必须是一行，其中包含所有案例的结果，形式为这些单个案例列表的逗号分隔列表，并用方括号括起来，例如 $[[0,\\text{True}],\\dots]$。不涉及物理单位。不涉及角度。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，列表内无空格，其中每个元素都是完全按照上述指定的单个案例列表 $[E,C]$。",
            "solution": "本问题要求分析和建模一个并行计算中常见的数据竞争场景，特别是在异步多任务运行时系统的背景下。我们被要求首先为一个因弱内存一致性效应而存在缺陷的非同步归约操作建模，然后为一个采用释放-获取语义的修正版本建模。\n\n根本问题源于比顺序一致性更弱的内存模型。在此类模型中，为了性能原因，处理器核心被允许对内存操作进行重排序，只要该核心上的本地程序顺序看起来得到了维持。然而，这些重排序可能对其他核心可见，从而导致对全局事件顺序的直观假设被违反。\n\n**第一部分：基于标志的非同步设计及其失效模式**\n\n在朴素设计中，每个生产者任务按程序顺序执行两个不同的操作：1. 写入新值：生产者计算 $x_i^{\\text{new}}$ 并将其写入一个共享内存位置，我们称之为 `data[i]`。2. 设置标志：生产者设置一个就绪标志以表示完成，$f_i \\leftarrow 1$。\n\n一个聚合器任务轮询这些标志。一旦观察到 $f_i = 1$，它就会读取 `data[i]` 并将其添加到一个全局总和中。这里的隐含假设是，观察到 $f_i=1$ 意味着对 `data[i]` 的写入也已完成并且对聚合器可见。这建立了一个*先行发生*关系：$x_i^{\\text{new}}$ 的写入*先行发生于*对 $f_i$ 的写入，而后者又*先行发生于*聚合器对 $f_i$ 的读取，后者又*先行发生于*聚合器对 `data[i]` 的读取。\n\n然而，在没有显式同步指令（内存栅栏或屏障）的情况下，弱序架构不需要强制执行这种线程间的先行发生关系。系统可能会从生产者的角度对写入进行重排序，或者这些写入通过内存系统的传播顺序也可能被重排。因此，对标志 $f_i$ 的写入可能会在对 $x_i^{\\text{new}}$ 的写入之前对聚合器的核心变得可见。这就造成了数据竞争：聚合器看到 $f_i=1$ 并尝试读取 `data[i]`，但由于新数据尚未到达其本地缓存或内存视图，它读取到的是过时的值 $x_i^{\\text{old}}$。\n\n为了对这种敌对性交错进行建模，问题定义了一个集合 $U \\subseteq \\{1, \\dots, n\\}$，其中包含出现此竞争条件的任务索引。因此，得到的非同步总和 $S^{\\text{unsync}}$ 是新旧值的混合：\n$$S^{\\text{unsync}} = \\sum_{i \\in \\{1,\\dots,n\\} \\setminus U} x_i^{\\text{new}} + \\sum_{i \\in U} x_i^{\\text{old}}$$\n在顺序一致性内存模型下将获得的理想正确总和是：\n$$S^{\\star} = \\sum_{i=1}^{n} x_i^{\\text{new}}$$\n由数据竞争引入的误差是绝对差 $E = |S^{\\star} - S^{\\text{unsync}}|$。\n\n**第二部分：使用释放-获取语义的修复设计**\n\n数据竞争通过引入显式的内存排序约束来解决，特别是释放-获取语义，这通常使用原子操作或 SPSC (单生产者单消费者) 队列来实现。\n\n- **释放语义 (生产者)**：当生产者任务完成其所有写入操作（即计算并存储了 $x_i^{\\text{new}}$）后，它会执行一个*释放*操作。一个常见的例子是带有释放语义的原子存储。此操作起到内存栅栏的作用，确保在程序顺序中位于其前的所有内存写入，在释放操作本身变得可见之前，对其他核心变得可见。\n\n- **获取语义 (消费者)**：消费者任务（我们的聚合器）执行一个*获取*操作来检测就绪状态。一个例子是带有获取语义的原子加载。此操作也起到内存栅栏的作用，确保在程序顺序中位于其后的任何内存读取执行之前，获取操作已完成。\n\n当生产者的释放操作与观察到该释放结果的消费者的获取操作配对时，就在两个线程之间建立了一个先行发生关系。生产者在释放之前的所有内存写入，都保证对消费者在获取之后的所有内存读取可见。\n\n在我们的问题中，这被建模为一个 SPSC 通道。生产者发送 $x_i^{\\text{new}}$ 构成了一次释放操作。聚合器从通道接收则构成了一次获取操作。这种设计保证了如果聚合器接收到子域 $i$ 的值，它必定是 $x_i^{\\text{new}}$，因为 $x_i^{\\text{new}}$ 的写入被保证发生在接收之前。过时的值 $x_i^{\\text{old}}$ 永远不会被观察到。\n\n因此，使用释放-获取模型计算的总和 $S^{\\text{ra}}$ 被保证是正确的：\n$$S^{\\text{ra}} = \\sum_{i=1}^{n} x_i^{\\text{new}} = S^{\\star}$$\n正确性检查 $C$ 被定义为布尔比较 $S^{\\text{ra}} = S^{\\star}$，根据其构造，该表达式必须始终为真。\n\n**算法实现**\n\n程序将遍历每个测试用例 $(n, \\mathbf{x}^{\\text{old}}, \\mathbf{x}^{\\text{new}}, U)$。对于每个案例：\n1. 通过对 $\\mathbf{x}^{\\text{new}}$ 向量的所有元素求和来计算正确的总和 $S^{\\star}$。\n2. 计算非同步总和 $S^{\\text{unsync}}$。我们从 $i=0$ 迭代到 $n-1$。如果对应的基于1的索引 $i+1$ 在集合 $U$ 中，我们将 $\\mathbf{x}^{\\text{old}}[i]$ 加到总和中；否则，我们添加 $\\mathbf{x}^{\\text{new}}[i]$。\n3. 释放-获取总和 $S^{\\text{ra}}$ 根据定义等于 $S^{\\star}$。\n4. 绝对误差 $E$ 计算为 $|S^{\\star} - S^{\\text{unsync}}|$。\n5. 正确性检查 $C$ 由布尔表达式 $S^{\\text{ra}} == S^{\\star}$ 确定。\n6. 存储得到的结果对 $[E, C]$。最后，所有结果按规定格式化为单个字符串。对于边界情况 $n=0$，所有总和都正确地计算为 $0$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by modeling and comparing unsynchronized and synchronized\n    parallel reduction schemes.\n    \"\"\"\n    test_cases = [\n        # Case 1: n = 4, x_old = [1,2,3,4], x_new = [2,3,4,5], U = {}\n        (4, [1, 2, 3, 4], [2, 3, 4, 5], set()),\n        # Case 2: n = 4, x_old = [5,1,7,0], x_new = [6,2,8,3], U = {2}\n        (4, [5, 1, 7, 0], [6, 2, 8, 3], {2}),\n        # Case 3 (boundary): n = 0, x_old = [], x_new = [], U = {}\n        (0, [], [], set()),\n        # Case 4: n = 3, x_old = [10,20,30], x_new = [11,21,31], U = {1,2,3}\n        (3, [10, 20, 30], [11, 21, 31], {1, 2, 3}),\n    ]\n\n    results = []\n    \n    for n, x_old, x_new, U in test_cases:\n        # Calculate the expected correct reduction S_star\n        # S_star = sum(x_i_new for all i)\n        s_star = np.sum(x_new)\n\n        # Calculate the unsynchronized reduction S_unsync\n        # This simulates a race condition where for indices in U, the old value is read.\n        # Note: The problem uses 1-based indexing for U, so we adjust for 0-based list access.\n        s_unsync = 0\n        for i in range(n):\n            if (i + 1) in U:\n                # Adversarial interleaving: read stale data\n                s_unsync += x_old[i]\n            else:\n                # Correct read\n                s_unsync += x_new[i]\n        \n        # Calculate the SPSC release-acquire reduction S_ra\n        # By construction with release-acquire semantics, this must always be correct.\n        s_ra = np.sum(x_new)\n\n        # Compute the absolute error E for the unsynchronized model\n        # E = |S_star - S_unsync|\n        e = abs(s_star - s_unsync)\n        \n        # Compute the correctness check C for the SPSC model\n        # C = (S_ra == S_star)\n        c = (s_ra == s_star)\n        \n        results.append([e, c])\n\n    # Format the final output string exactly as specified: a list of lists,\n    # with no spaces within the sub-lists or between them.\n    # e.g., \"[[0,True],[1,True],[0,True],[3,True]]\"\n    formatted_results = [f\"[{e},{c}]\" for e, c in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}