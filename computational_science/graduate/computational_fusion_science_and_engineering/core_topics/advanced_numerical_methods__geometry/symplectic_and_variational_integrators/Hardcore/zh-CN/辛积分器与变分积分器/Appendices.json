{
    "hands_on_practices": [
        {
            "introduction": "简谐振子是物理学中的一个基石模型，其应用范围从经典力学到等离子体物理学。本练习将通过一个具体的动手实践，比较一个辛积分器（蛙跳法）和一个非辛积分器（显式欧拉法）的性能。通过推导和比较它们各自的相位与振幅行为，您将对辛方法为何对振荡系统的长期保真度至关重要获得基本的理解。",
            "id": "4051345",
            "problem": "考虑一个单自由度哈密顿谐振子，其哈密顿量为 $H(q,p) = \\tfrac{1}{2}\\big(p^{2} + \\omega^{2} q^{2}\\big)$，其中 $q$ 和 $p$ 分别是正则坐标和正则动量，而 $\\omega \\gt 0$ 是真实角频率。运动方程为哈密顿方程 $\\dot{q} = \\partial H / \\partial p$ 和 $\\dot{p} = - \\partial H / \\partial q$，由此可得线性系统 $\\dot{q} = p$ 和 $\\dot{p} = - \\omega^{2} q$。此类线性振荡动力学在与计算聚变科学与工程相关的磁化等离子体中带电粒子轨道计算中作为局部模型出现，其中几何结构的长期保真度至关重要。\n\n您需要将时间步长为 $h \\gt 0$ 的辛蛙跳（也称Störmer–Verlet）积分器应用于此系统，并推导该方法的修正角频率 $\\tilde{\\omega}$，使得该方法的一个步骤将解推进一个有效相角 $\\theta = h \\tilde{\\omega}$，该相角满足方法的离散色散关系。另外，将具有相同 $h$ 的非辛显式欧拉方法应用于同一一阶系统，并确定其有效角频率 $\\omega_{\\mathrm{E}}$，其意义是显式欧拉方法的一个步骤通过一个复特征值来推进状态，该特征值的辐角为 $\\phi = h \\,\\omega_{\\mathrm{E}}$。所有角度和角频率均使用弧度，时间使用秒。\n\n仅从上述基本定义和两种方法的算法描述（蛙跳法为标准的半步动量更新、全步位置更新、半步动量更新；显式欧拉法为作用于一阶系统的前向单步显式方法）出发，执行以下任务：\n\n- 推导蛙跳积分器所满足的位置变量 $q_{n}$ 的线性递推关系，并由此获得修正频率 $\\tilde{\\omega}$ 作为 $\\omega$ 和 $h$ 的函数的精确闭式表达式。将单位时间蛙跳相位误差定义为 $\\delta_{\\mathrm{LF}} = \\tilde{\\omega} - \\omega$（单位为弧度/秒）。\n- 推导显式欧拉方法的单步放大矩阵，确定其特征值，将每步有效相角 $\\phi$ 定义为特征值的辐角，并获得 $\\omega_{\\mathrm{E}} = \\phi / h$ 作为 $\\omega$ 和 $h$ 的函数的精确闭式表达式。将单位时间欧拉相位误差定义为 $\\delta_{\\mathrm{E}} = \\omega_{\\mathrm{E}} - \\omega$（单位为弧度/秒）。\n\n您的程序必须为下面的每个测试用例计算由四个实数组成的元组 $(\\tilde{\\omega}, \\omega_{\\mathrm{E}}, \\delta_{\\mathrm{LF}}, \\delta_{\\mathrm{E}})$，所有数值均以弧度/秒表示。请使用您推导出的精确解析公式；不要从模拟轨迹中估计相位。\n\n角度单位要求：所有角度均以弧度为单位。物理单位要求：所有角频率和相位误差必须以弧度/秒为单位给出。\n\n测试套件（每个用例是一对 $(\\omega, h)$，其中 $\\omega$ 的单位为弧度/秒， $h$ 的单位为秒）：\n\n- 用例1：$(\\omega, h) = (\\,1.0,\\, 0.1\\,)$。\n- 用例2：$(\\omega, h) = (\\,1.0,\\, 1.999\\,)$。\n- 用例3：$(\\omega, h) = (\\,10.0,\\, 0.05\\,)$。\n- 用例4：$(\\omega, h) = (\\,2.0,\\, 1.0\\,)$。\n\n覆盖性设计原理：用例1是小步长的“理想路径”；用例2探测蛙跳法稳定性边界 $h\\omega \\lesssim 2$；用例3测试一个具有中等类Courant数 $h\\,\\omega$ 的高频振荡器；用例4位于蛙跳法稳定性边界 $h\\omega = 2$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于按上述顺序列出的每个测试用例，按顺序追加四个值 $(\\tilde{\\omega}, \\omega_{\\mathrm{E}}, \\delta_{\\mathrm{LF}}, \\delta_{\\mathrm{E}})$，最终形成一个包含16个浮点数的扁平列表。例如，输出必须具有以下形式\n\"[wtilde1,wE1,dLF1,dE1,wtilde2,wE2,dLF2,dE2,wtilde3,wE3,dLF3,dE3,wtilde4,wE4,dLF4,dE4]\"。",
            "solution": "问题陈述要求推导和计算分别应用于单自由度简谐振子的辛蛙跳法和显式欧拉方法的修正角频率和有效角频率。\n\n该系统由哈密顿量 $H(q,p) = \\frac{1}{2}(p^2 + \\omega^2 q^2)$ 定义，其中 $\\omega  0$。运动方程为哈密顿方程：\n$$\n\\dot{q} = \\frac{\\partial H}{\\partial p} = p\n$$\n$$\n\\dot{p} = -\\frac{\\partial H}{\\partial q} = -\\omega^2 q\n$$\n这些方程构成一个线性常微分方程组。给定一个离散时间步长 $h  0$。\n\n首先，我们分析辛蛙跳（Störmer–Verlet）积分器。问题通过三个顺序步骤定义了其将状态从时间 $t_n$ 推进到 $t_{n+1} = t_n + h$ 的应用过程：\n1. 动量的半步更新：$p_{n+1/2} = p_n + \\frac{h}{2}\\dot{p}(q_n) = p_n - \\frac{h^2\\omega^2}{2}q_n$。\n2. 使用半步动量进行位置的全步更新：$q_{n+1} = q_n + h\\dot{q}(p_{n+1/2}) = q_n + hp_{n+1/2}$。\n3. 最后的动量半步更新：$p_{n+1} = p_{n+1/2} + \\frac{h}{2}\\dot{p}(q_{n+1}) = p_{n+1/2} - \\frac{h^2\\omega^2}{2}q_{n+1}$。\n\n为了推导位置变量 $q_n$ 的线性递推关系，我们将动量用位置来表示。从步骤2，我们有 $p_{n+1/2} = \\frac{q_{n+1}-q_n}{h}$。将索引后移一步得到 $p_{n-1/2} = \\frac{q_n-q_{n-1}}{h}$。动量通常被看作是在交错网格上更新的。从 $p_{n-1/2}$ 到 $p_{n+1/2}$ 的更新发生在一个完整的时间步长 $h$ 内，并由中间时刻 $t_n$ 的力驱动：\n$$\np_{n+1/2} = p_{n-1/2} + h \\dot{p}(q_n) = p_{n-1/2} - h\\omega^2 q_n\n$$\n将动量的位置表达式代入此方程，得到：\n$$\n\\frac{q_{n+1}-q_n}{h} = \\frac{q_n-q_{n-1}}{h} - h\\omega^2 q_n\n$$\n两边乘以 $h$ 并重新整理，得到所需的 $q_n$ 的三项递推关系：\n$$\nq_{n+1} - 2q_n + q_{n-1} = -h^2\\omega^2 q_n\n$$\n$$\nq_{n+1} - (2 - (h\\omega)^2)q_n + q_{n-1} = 0\n$$\n这是一个线性齐次差分方程。我们寻求 $q_n = \\lambda^n$ 形式的解。将此试探解代入递推关系，得到特征方程：\n$$\n\\lambda^2 - (2 - (h\\omega)^2)\\lambda + 1 = 0\n$$\n这个二次方程的根是离散时间演化算子的特征值。根由以下公式给出：\n$$\n\\lambda_{\\pm} = \\frac{(2 - (h\\omega)^2) \\pm \\sqrt{(2 - (h\\omega)^2)^2 - 4}}{2}\n$$\n为使数值解是振荡的（稳定的），判别式必须为非正，这要求 $(2 - (h\\omega)^2)^2 - 4 \\le 0$。这意味着 $-2 \\le 2 - (h\\omega)^2 \\le 2$。右侧不等式为 $(h\\omega)^2 \\ge 0$，对于 $h, \\omega  0$ 恒成立。左侧不等式为 $(h\\omega)^2 \\le 4$，这给出了蛙跳法著名的类CFL稳定性条件：$h\\omega \\le 2$。对于边界情况 $h\\omega=2$，根是实数且等于 $-1$。对于 $h\\omega  2$，根是实数，其中一个的模大于1，导致指数增长。\n\n假设稳定性条件 $h\\omega \\le 2$ 成立，特征值为一对共轭复数 $\\lambda_{\\pm} = e^{\\pm i\\theta}$，其中 $\\theta = h\\tilde{\\omega}$ 是每步的数值相移，$\\tilde{\\omega}$ 是修正角频率。根的和为 $\\lambda_+ + \\lambda_- = e^{i\\theta} + e^{-i\\theta} = 2\\cos(\\theta)$。根据应用于特征方程的韦达定理，根的和也等于 $2 - (h\\omega)^2$。令二者相等得到色散关系：\n$$\n2\\cos(h\\tilde{\\omega}) = 2 - (h\\omega)^2 \\implies \\cos(h\\tilde{\\omega}) = 1 - \\frac{(h\\omega)^2}{2}\n$$\n解出 $\\tilde{\\omega}$ 得到修正角频率的精确闭式表达式：\n$$\n\\tilde{\\omega} = \\frac{1}{h}\\arccos\\left(1 - \\frac{(h\\omega)^2}{2}\\right)\n$$\n此表达式对 $0 \\lt h\\omega \\le 2$ 有效。单位时间相位误差则定义为：\n$$\n\\delta_{\\mathrm{LF}} = \\tilde{\\omega} - \\omega\n$$\n\n接下来，我们分析非辛显式欧拉方法。系统的一阶矩阵形式为 $\\dot{\\mathbf{z}} = A\\mathbf{z}$，其中 $\\mathbf{z} = \\begin{pmatrix} q \\\\ p \\end{pmatrix}$ 且 $A = \\begin{pmatrix} 0  1 \\\\ -\\omega^2  0 \\end{pmatrix}$。显式欧拉方法由更新规则 $\\mathbf{z}_{n+1} = \\mathbf{z}_n + h \\dot{\\mathbf{z}}_n$ 定义。对于我们的系统，这变为：\n$$\n\\mathbf{z}_{n+1} = \\mathbf{z}_n + hA\\mathbf{z}_n = (I + hA)\\mathbf{z}_n\n$$\n因此，单步放大矩阵为 $M_{\\mathrm{E}} = I + hA$。\n$$\nM_{\\mathrm{E}} = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} + h\\begin{pmatrix} 0  1 \\\\ -\\omega^2  0 \\end{pmatrix} = \\begin{pmatrix} 1  h \\\\ -h\\omega^2  1 \\end{pmatrix}\n$$\n$M_{\\mathrm{E}}$ 的特征值 $\\lambda$ 决定了该方法的稳定性和相位特性。通过求解特征方程 $\\det(M_{\\mathrm{E}} - \\lambda I) = 0$ 可以找到它们：\n$$\n\\det\\begin{pmatrix} 1-\\lambda  h \\\\ -h\\omega^2  1-\\lambda \\end{pmatrix} = (1-\\lambda)^2 + h^2\\omega^2 = 0\n$$\n这得到 $(1-\\lambda)^2 = - (h\\omega)^2$，因此 $1-\\lambda = \\pm i h\\omega$。因此特征值为一对共轭复数：\n$$\n\\lambda_{\\pm} = 1 \\pm i h\\omega\n$$\n这些特征值的模为 $|\\lambda_{\\pm}| = \\sqrt{1^2 + (\\pm h\\omega)^2} = \\sqrt{1 + (h\\omega)^2}$。由于对于任何 $h,\\omega  0$ 都有 $|\\lambda_{\\pm}|  1$，该方法对于谐振子是无条件不稳定的；数值振幅会指数增长。\n\n问题将每步有效相角 $\\phi$ 定义为特征值的辐角。为遵循正相角约定，我们选择具有正虚部的特征值 $\\lambda_+ = 1+ih\\omega$。其辐角为 $\\phi = \\arg(1 + i h\\omega)$。在复平面中，这对应于一个实部为 $1$、虚部为 $h\\omega$ 的点。该角度由下式给出：\n$$\n\\phi = \\arctan(h\\omega)\n$$\n其中 `arctan` 指的是主值，返回一个在 $(-\\pi/2, \\pi/2)$ 区间内的角度。由于 $h\\omega  0$，$\\phi$ 在 $(0, \\pi/2)$ 区间内。\n有效角频率 $\\omega_{\\mathrm{E}}$ 由 $\\phi = h\\omega_{\\mathrm{E}}$ 定义。这得到：\n$$\n\\omega_{\\mathrm{E}} = \\frac{\\phi}{h} = \\frac{1}{h}\\arctan(h\\omega)\n$$\n单位时间欧拉相位误差则定义为：\n$$\n\\delta_{\\mathrm{E}} = \\omega_{\\mathrm{E}} - \\omega\n$$\n这些推导出的 $\\tilde{\\omega}$、$\\delta_{\\mathrm{LF}}$、$\\omega_{\\mathrm{E}}$ 和 $\\delta_{\\mathrm{E}}$ 的公式将用于数值计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of finding modified/effective frequencies and phase errors\n    for leapfrog and explicit Euler integrators for the harmonic oscillator.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (omega, h).\n    test_cases = [\n        (1.0, 0.1),\n        (1.0, 1.999),\n        (10.0, 0.05),\n        (2.0, 1.0),\n    ]\n\n    results = []\n    for omega, h in test_cases:\n        # --- Leapfrog Integrator Calculations ---\n\n        # The modified angular frequency for leapfrog is derived from the\n        # dispersion relation: cos(h*w_tilde) = 1 - 0.5*(h*omega)^2.\n        # This is valid for h*omega = 2.\n        hw = h * omega\n        \n        # Argument for arccos. It is guaranteed to be in [-1, 1] for the test cases.\n        arg_acos = 1.0 - 0.5 * hw**2\n        \n        # np.arccos returns the principal value in [0, pi].\n        # The result is guaranteed to be non-negative.\n        w_tilde = (1.0 / h) * np.arccos(arg_acos)\n        \n        # Phase error per unit time for leapfrog.\n        delta_LF = w_tilde - omega\n        \n        # --- Explicit Euler Integrator Calculations ---\n\n        # The effective angular frequency for explicit Euler is derived from\n        # the argument of its amplification matrix eigenvalues: phi = arctan(h*omega).\n        # w_E = phi / h.\n        w_E = (1.0 / h) * np.arctan(hw)\n        \n        # Phase error per unit time for explicit Euler.\n        delta_E = w_E - omega\n        \n        # Append the four computed values for the current test case.\n        results.extend([w_tilde, w_E, delta_LF, delta_E])\n\n    # Final print statement in the exact required format.\n    # The list 'results' is a flat list of all 16 numbers.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在观察到辛积分器的优越性能之后，我们现在深入探讨保证这种行为的底层数学结构。本练习将从数值观察转向解析证明。通过为一般的二次哈密顿量推导隐式中点法的雅可比矩阵，并代数验证辛条件 $J^{\\top} \\Omega J = \\Omega$，您将对所要保持的几何性质建立一个严谨的理解。",
            "id": "4051356",
            "problem": "考虑与计算聚变科学和工程相关的 $2n$ 维相空间上的正则哈密顿动力学，其中带电粒子和场线运动的长时间精确模拟要求保持正则辛二形式。令 $z \\in \\mathbb{R}^{2n}$ 表示正则坐标 $z = (q, p)$，并令正则辛矩阵为\n$$\n\\Omega = \\begin{pmatrix} 0  I_n \\\\ -I_n  0 \\end{pmatrix},\n$$\n该矩阵编码了正则辛形式。假设哈密顿量是二次的，\n$$\nH(z) = \\frac{1}{2} z^{\\top} K z + b^{\\top} z + c,\n$$\n其中 $K \\in \\mathbb{R}^{2n \\times 2n}$ 是一个常对称矩阵，$b \\in \\mathbb{R}^{2n}$，且 $c \\in \\mathbb{R}$。连续时间动力学由哈密顿方程给出，\n$$\n\\dot{z} = \\Omega \\nabla H(z).\n$$\n定义步长为 $h  0$ 的隐式中点单步法，其更新 $\\Phi_h: z \\mapsto z_{+}$ 通过以下方式隐式确定\n$$\nz_{+} = z + h \\, \\Omega \\, \\nabla H\\!\\left(\\frac{z + z_{+}}{2}\\right).\n$$\n从这些原理和定义出发，为上述给出的通用二次哈密顿量推导单步映射 $\\Phi_h$ 的雅可比矩阵 $J = \\frac{\\partial z_{+}}{\\partial z}$。将 $J$ 仅用 $h$、$\\Omega$ 和 $K$ 显式表示，避免对 $z$、$b$ 或 $c$ 的任何依赖。然后，仅利用 $\\Omega$ 的结构性质和 $K$ 的对称性，对所有使得矩阵 $I_{2n} - \\frac{h}{2} \\Omega K$ 可逆的步长 $h$，验证离散辛性条件\n$$\nJ^{\\top} \\Omega J = \\Omega\n$$\n。请以仅包含 $h$、$\\Omega$ 和 $K$ 的单个闭式解析表达式的形式给出你的最终答案。不需要数值近似，最终表达式中也不需要单位。",
            "solution": "问题陈述已经过验证，被认为是哈密顿系统几何数值积分领域中一个适定且有科学依据的问题。我们可以进行形式化求解。\n\n目标是首先为由隐式中点法定义的映射 $\\Phi_h: z \\mapsto z_{+}$ 推导出雅可比矩阵 $J = \\frac{\\partial z_{+}}{\\partial z}$，然后验证该映射是辛映射。\n\n哈密顿量被给出为正则坐标 $z \\in \\mathbb{R}^{2n}$ 的二次函数：\n$$\nH(z) = \\frac{1}{2} z^{\\top} K z + b^{\\top} z + c\n$$\n这里，$K \\in \\mathbb{R}^{2n \\times 2n}$ 是一个对称矩阵 ($K = K^{\\top}$)，$b \\in \\mathbb{R}^{2n}$，并且 $c \\in \\mathbb{R}$。\n\n首先，我们计算哈密顿量的梯度 $\\nabla H(z)$。利用向量微积分的标准法则和 $K$ 的对称性：\n$$\n\\nabla H(z) = \\frac{1}{2} (K + K^{\\top})z + b = \\frac{1}{2} (2K)z + b = Kz + b\n$$\n因此，哈密顿量的海森矩阵是常数矩阵 $\\nabla^2 H(z) = K$。\n\n隐式中点单步法由以下关系定义：\n$$\nz_{+} = z + h \\, \\Omega \\, \\nabla H\\!\\left(\\frac{z + z_{+}}{2}\\right)\n$$\n其中 $z$ 是步长开始时的状态，$z_{+}$ 是结束时的状态，$h  0$ 是步长，$\\Omega = \\begin{pmatrix} 0  I_n \\\\ -I_n  0 \\end{pmatrix}$ 是正则辛矩阵。\n\n将梯度的表达式代入更新法则得到：\n$$\nz_{+} = z + h \\, \\Omega \\, \\left[ K\\left(\\frac{z + z_{+}}{2}\\right) + b \\right]\n$$\n我们可以展开并重排此方程，以 $z$ 来求解 $z_{+}$：\n$$\nz_{+} = z + \\frac{h}{2} \\Omega K (z + z_{+}) + h \\Omega b\n$$\n$$\nz_{+} = z + \\frac{h}{2} \\Omega K z + \\frac{h}{2} \\Omega K z_{+} + h \\Omega b\n$$\n将包含 $z_{+}$ 的项收集到左侧，将包含 $z$ 的项收集到右侧：\n$$\nz_{+} - \\frac{h}{2} \\Omega K z_{+} = z + \\frac{h}{2} \\Omega K z + h \\Omega b\n$$\n将 $z_{+}$ 和 $z$ 因子分解出来：\n$$\n\\left(I_{2n} - \\frac{h}{2} \\Omega K\\right) z_{+} = \\left(I_{2n} + \\frac{h}{2} \\Omega K\\right) z + h \\Omega b\n$$\n其中 $I_{2n}$ 是 $2n \\times 2n$ 的单位矩阵。\n\n问题陈述指出矩阵 $\\left(I_{2n} - \\frac{h}{2} \\Omega K\\right)$ 是可逆的。因此，我们可以通过左乘其逆矩阵来获得 $z_{+}$ 的显式表达式：\n$$\nz_{+} = \\left(I_{2n} - \\frac{h}{2} \\Omega K\\right)^{-1} \\left[ \\left(I_{2n} + \\frac{h}{2} \\Omega K\\right) z + h \\Omega b \\right]\n$$\n映射 $\\Phi_h: z \\mapsto z_{+}$ 是一个形式为 $z_{+} = M z + v$ 的仿射变换。雅可比矩阵 $J = \\frac{\\partial z_{+}}{\\partial z}$ 是此变换的线性部分，即矩阵 $M$。\n$$\nJ = \\frac{\\partial z_{+}}{\\partial z} = \\left(I_{2n} - \\frac{h}{2} \\Omega K\\right)^{-1} \\left(I_{2n} + \\frac{h}{2} \\Omega K\\right)\n$$\n这个 $J$ 的表达式只依赖于 $h$、$\\Omega$ 和 $K$，符合要求。这完成了问题的第一部分。\n\n接下来，我们必须验证离散辛性条件 $J^{\\top} \\Omega J = \\Omega$。此条件意味着数值流映射 $\\Phi_h$ 保持了正则辛二形式。\n\n我们首先注意所涉及矩阵的基本性质：\n1. $K$ 是对称的：$K^{\\top} = K$。\n2. $\\Omega$ 是斜对称的：$\\Omega^{\\top} = -\\Omega$。\n3. 根据其定义，$\\Omega^2 = -I_{2n}$，这意味着 $\\Omega^{-1} = -\\Omega$。因此，$\\Omega^{\\top} = \\Omega^{-1}$。\n\n我们定义矩阵 $S = \\frac{h}{2} \\Omega K$。雅可比矩阵可以写为 $J = (I_{2n} - S)^{-1}(I_{2n} + S)$。为简化起见，我们将省略单位矩阵的下标，用 $I$ 表示 $I_{2n}$。\n$J$ 的转置是 $J^{\\top} = \\left((I-S)^{-1}(I+S)\\right)^{\\top} = (I+S)^{\\top} \\left((I-S)^{-1}\\right)^{\\top} = (I+S^{\\top})(I-S^{\\top})^{-1}$。\n\n我们来考察 $S^{\\top}$：\n$$\nS^{\\top} = \\left(\\frac{h}{2} \\Omega K\\right)^{\\top} = \\frac{h}{2} K^{\\top} \\Omega^{\\top} = \\frac{h}{2} K (-\\Omega) = -\\frac{h}{2} K \\Omega\n$$\n现在，我们利用 $\\Omega$ 建立一个联系 $S$ 和 $S^\\top$ 的关键恒等式：\n$$\n\\Omega S \\Omega^{-1} = \\Omega \\left(\\frac{h}{2} \\Omega K\\right) \\Omega^{-1} = \\frac{h}{2} \\Omega^2 K \\Omega^{-1} = \\frac{h}{2}(-I) K (-\\Omega) = \\frac{h}{2} K \\Omega\n$$\n将此与 $S^{\\top}$ 的表达式进行比较，我们看到 $\\Omega S \\Omega^{-1} = -S^{\\top}$。\n\n现在我们将这个恒等式代入 $J^{\\top}$ 的表达式中：\n$$\nJ^{\\top} = (I + S^{\\top})(I - S^{\\top})^{-1} = (I - \\Omega S \\Omega^{-1}) (I + \\Omega S \\Omega^{-1})^{-1}\n$$\n我们可以将 $\\Omega$ 和 $\\Omega^{-1}$ 因子分解出来：\n$$\nI - \\Omega S \\Omega^{-1} = \\Omega \\Omega^{-1} - \\Omega S \\Omega^{-1} = \\Omega(I-S)\\Omega^{-1}\n$$\n$$\nI + \\Omega S \\Omega^{-1} = \\Omega \\Omega^{-1} + \\Omega S \\Omega^{-1} = \\Omega(I+S)\\Omega^{-1}\n$$\n逆矩阵项变为：\n$$\n(I + \\Omega S \\Omega^{-1})^{-1} = [\\Omega(I+S)\\Omega^{-1}]^{-1} = (\\Omega^{-1})^{-1}(I+S)^{-1}\\Omega^{-1} = \\Omega(I+S)^{-1}\\Omega^{-1}\n$$\n将这些代回到 $J^{\\top}$ 的表达式中：\n$$\nJ^{\\top} = \\left[\\Omega(I-S)\\Omega^{-1}\\right] \\left[\\Omega(I+S)^{-1}\\Omega^{-1}\\right] = \\Omega(I-S)(\\Omega^{-1}\\Omega)(I+S)^{-1}\\Omega^{-1}\n$$\n$$\nJ^{\\top} = \\Omega(I-S)(I+S)^{-1}\\Omega^{-1}\n$$\n$J$ 的逆是 $J^{-1} = ((I-S)^{-1}(I+S))^{-1} = (I+S)^{-1}(I-S)$。因为 $(I-S)$ 和 $(I+S)$ 可交换，我们也可以写成 $J^{-1} = (I-S)(I+S)^{-1}$。\n因此，我们找到了关系式 $J^{\\top} = \\Omega J^{-1} \\Omega^{-1}$。\n\n最后，我们用这个关系来验证辛性条件：\n$$\nJ^{\\top} \\Omega J = (\\Omega J^{-1} \\Omega^{-1}) \\Omega J\n$$\n利用矩阵乘法的结合律：\n$$\nJ^{\\top} \\Omega J = \\Omega J^{-1} (\\Omega^{-1} \\Omega) J = \\Omega J^{-1} I J = \\Omega (J^{-1}J) = \\Omega I = \\Omega\n$$\n这证实了 $J^{\\top} \\Omega J = \\Omega$。对于二次哈密顿量，由隐式中点法定义的映射在其雅可比矩阵良定义的任何步长 $h$ 下确实是辛的。\n最终要求的表达式是雅可比矩阵 $J$ 的表达式。",
            "answer": "$$\\boxed{\\left(I_{2n} - \\frac{h}{2} \\Omega K\\right)^{-1} \\left(I_{2n} + \\frac{h}{2} \\Omega K\\right)}$$"
        },
        {
            "introduction": "最后一个练习旨在弥合抽象理论与计算科学中长期模拟的实际挑战之间的鸿沟。您将把一个变分积分器（Störmer-Verlet法）应用于一个非线性系统，以展示辛方法最著名的特性：卓越的长期能量守恒性。通过分析模拟结果，您将把观察到的有界能量振荡与强大的后向误差分析概念联系起来，该分析揭示了数值轨迹是一个邻近的、被修正的哈密顿系统的精确解。",
            "id": "4051315",
            "problem": "考虑一个一维哈密顿系统，其哈密顿量定义为 $H(q,p) = \\frac{p^2}{2m} + V(q)$，势能为 $V(q) = \\frac{1}{2}k q^2 + \\alpha q^4$。正则运动方程由哈密顿方程导出，并定义了保持辛二形式和哈密顿量不变的精确流。你的任务是研究一个源于离散作用量原理的二阶辛变分积分器所产生的数值能量的长时间行为。具体来说，使用对连续拉格朗日量 $L(q,\\dot{q}) = \\frac{1}{2}m \\dot{q}^2 - V(q)$ 的一致二阶近似，实现一个与离散 Euler–Lagrange 构造相符的位置-动量更新方法，然后使用此更新方法对运动进行积分，时长为 $10^4$ 个参考周期。\n\n推导和分析的基本依据：\n- 使用拉格朗日量 $L(q,\\dot{q})$ 和作用量泛函的定义，通过将驻点作用量原理应用于一个二阶精度的离散拉格朗日量，从离散作用量中推导出离散运动方程。这必须得到一个二阶的、辛的、时间可逆的格式。\n- 对给定的可分哈密顿量使用哈密顿方程，来论证流的分裂以及辛积分器的性质。\n- 使用后向误差分析（BEA）的概念来解释有界的能量振荡以及修正哈密顿量的近似守恒。BEA 被定义为研究一个修正微分方程，该方程的精确流比原始系统的精确流更接近数值方法。\n\n程序要求：\n1. 为可分哈密顿量 $H(q,p) = \\frac{p^2}{2m} + V(q)$（其中 $V(q) = \\frac{1}{2}k q^2 + \\alpha q^4$）实现一个二阶辛变分积分器。该更新方法必须从离散变分力学的第一性原理推导得出，并且必须是辛的和时间可逆的。\n2. 对于每个测试用例，计算近似参考周期 $T_0 = 2\\pi \\sqrt{\\frac{m}{k}}$（单位：秒），定义时间步长 $h = \\frac{T_0}{N_{\\text{pp}}}$（单位：秒），其中 $N_{\\text{pp}}$ 表示每个参考周期内的步数，并积分 $N_{\\text{per}} = 10^4$ 个参考周期，总积分时间为 $T_{\\text{tot}} = N_{\\text{per}} T_0$（单位：秒）。\n3. 使用 $q(0) = q_0$（单位：米）和 $p(0) = 0$（单位：千克·米/秒）进行初始化。\n4. 在积分过程中，每一步都计算瞬时能量 $H(q(t),p(t))$（单位：焦耳），并记录：\n   - 在整个模拟过程中的最大相对能量偏差，定义为 $\\max_{0 \\le t \\le T_{\\text{tot}}} \\left| \\frac{H(t) - H(0)}{H(0)} \\right|$（无量纲小数）。\n   - 能量的归一化线性漂移率，计算为 $H(t)$ 相对于 $t$ 的最小二乘线性拟合的斜率除以 $H(0)$，其单位为秒的倒数。具体而言，如果最小二乘斜率为 $s$（单位：焦耳/秒），则报告 $\\frac{s}{H(0)}$（单位：秒的倒数）。\n5. 定性解释观测到的振荡和小漂移率如何与后向误差分析（BEA）相关联。BEA 预测存在一个修正哈密顿量 $\\tilde{H} = H + h^2 \\Delta H + \\mathcal{O}(h^4)$，该哈密顿量被二阶辛格式近似守恒，其能量误差呈振荡性，振幅尺度为 $\\mathcal{O}(h^2)$。\n\n物理和数值单位：\n- 能量以焦耳报告，时间以秒，质量以千克，位置以米，刚度以牛顿/米，$\\alpha$ 以牛顿/米³。\n- 漂移率必须以秒的倒数报告。\n- 任何分数量必须表示为小数。\n\n测试套件：\n使用以下四个科学合理的测试用例，以覆盖谐振、弱非线性、接近稳定性的粗略步长和精细步长等情况。对于所有测试用例，将参考周期数设置为 $N_{\\text{per}} = 10^4$。\n- 用例1（谐振基准）：$m = 1.0$ 千克，$k = 1.0$ 牛顿/米，$\\alpha = 0.0$ 牛顿/米³，$q_0 = 0.2$ 米，$N_{\\text{pp}} = 20$。\n- 用例2（弱非线性中等步长）：$m = 1.0$ 千克，$k = 1.0$ 牛顿/米，$\\alpha = 0.01$ 牛顿/米³，$q_0 = 0.2$ 米，$N_{\\text{pp}} = 20$。\n- 用例3（弱非线性粗略步长，接近稳定性边界）：$m = 1.0$ 千克，$k = 1.0$ 牛顿/米，$\\alpha = 0.01$ 牛顿/米³，$q_0 = 0.2$ 米，$N_{\\text{pp}} = 4$。\n- 用例4（较强非线性精细步长）：$m = 1.0$ 千克，$k = 1.0$ 牛顿/米，$\\alpha = 0.05$ 牛顿/米³，$q_0 = 0.3$ 米，$N_{\\text{pp}} = 100$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，列表中的每个元素是对应测试用例的一个双元素列表。每个双元素列表必须按 $[$最大相对能量偏差, 归一化线性漂移率（单位：秒的倒数）$]$ 的顺序排列。例如，输出应类似于 $[[x_1,y_1],[x_2,y_2],[x_3,y_3],[x_4,y_4]]$，值为小数。",
            "solution": "所述问题是科学合理的、自洽的且适定的。它提出了计算动力学中的一个标准任务：使用辛数值方法对保守哈密顿系统进行长期积分。所有参数、初始条件和分析要求都已明确规定。其基本原理——哈密顿力学、离散变分原理和后向误差分析——是该领域的基石。因此，我将进行完整的推导和求解。\n\n目标是为一维非线性振子实现一个二阶、辛、变分积分器，并分析其长期能量守恒特性。该系统由可分哈密顿量 $H(q,p) = T(p) + V(q)$ 描述，其中动能为 $T(p) = \\frac{p^2}{2m}$，势能为 $V(q) = \\frac{1}{2}k q^2 + \\alpha q^4$。\n\n如果一个数值方法可以从哈密顿驻点作用量原理的离散版本推导出来，则称其为变分方法。连续作用量泛函为 $S[q] = \\int L(q(t), \\dot{q}(t)) dt$，其中拉格朗日量为 $L = T - V$。我们构造一个离散拉格朗日量 $L_d(q_n, q_{n+1})$ 来近似 $\\int_{t_n}^{t_{n+1}} L(q(t), \\dot{q}(t)) dt$。一种常见的二阶精度选择是：对速度使用有限差分，对势能使用梯形法则，得到：\n$$\nL_d(q_n, q_{n+1}) = h \\left[ \\frac{1}{2}m \\left(\\frac{q_{n+1}-q_n}{h}\\right)^2 - \\frac{1}{2}\\left(V(q_n) + V(q_{n+1})\\right) \\right]\n$$\n离散作用量是其总和 $S_d = \\sum_n L_d(q_n, q_{n+1})$。对于在端点处为零的变分 $\\delta q_n$，驻点作用量原理 $\\delta S_d = 0$ 导出离散的 Euler-Lagrange 方程：\n$$\n\\frac{\\partial L_d(q_{n-1}, q_n)}{\\partial q_n} + \\frac{\\partial L_d(q_n, q_{n+1})}{\\partial q_n} = 0\n$$\n计算偏导数：\n$$\n\\frac{\\partial L_d(q_{n-1}, q_n)}{\\partial q_n} = \\frac{m}{h}(q_n - q_{n-1}) - \\frac{h}{2} V'(q_n)\n$$\n$$\n\\frac{\\partial L_d(q_n, q_{n+1})}{\\partial q_n} = -\\frac{m}{h}(q_{n+1} - q_n) - \\frac{h}{2} V'(q_n)\n$$\n将这些代入离散 Euler-Lagrange 方程可得：\n$$\n\\frac{m}{h}(q_n - q_{n-1}) - \\frac{h}{2} V'(q_n) - \\frac{m}{h}(q_{n+1} - q_n) - \\frac{h}{2} V'(q_n) = 0\n$$\n整理各项可得著名的 Störmer-Verlet（或位置 Verlet）算法：\n$$\nm \\frac{q_{n+1} - 2q_n + q_{n-1}}{h^2} = -V'(q_n) = F(q_n)\n$$\n其中 $F(q) = -V'(q)$ 是力。虽然这种形式很优雅，但它是一个关于位置的三项递推关系，并且没有显式地使用动量变量 $p$。对于相空间分析，使用“速度 Verlet”格式是等价的，而且通常更方便，它是一种在 $(q, p)$ 空间中的单步方法。该算法通过分裂 Liouville 算子得到，并且是已知的辛算法。通过定义一个中间动量可以证明其等价性。对于给定系统，速度 Verlet 算法如下：\n1. 第一步：动量的半步推进：$p_{n+1/2} = p_n - \\frac{h}{2} \\frac{\\partial V}{\\partial q}(q_n) = p_n + \\frac{h}{2} F(q_n)$\n2. 第二步：位置的整步漂移：$q_{n+1} = q_n + h \\frac{\\partial T}{\\partial p}(p_{n+1/2}) = q_n + \\frac{h}{m} p_{n+1/2}$\n3. 第三步：动量的第二个半步推进：$p_{n+1} = p_{n+1/2} - \\frac{h}{2} \\frac{\\partial V}{\\partial q}(q_{n+1}) = p_{n+1/2} + \\frac{h}{2} F(q_{n+1})$\n\n这个积分器是显式定义的、二阶精确的、时间可逆的，而且最重要的是，它是辛的。辛性意味着数值流映射 $\\Phi_h: (q_n, p_n) \\to (q_{n+1}, p_{n+1})$ 保持辛二形式 $dq \\wedge dp$ 不变。正是这个性质使得该积分器具有优异的长期行为。\n\n观测到的数值结果——有界的能量振荡和可忽略的长期能量漂移——是辛积分器的典型特征，并可由后向误差分析（BEA）严格解释。BEA 指出，由辛积分器生成的数值解，虽然不在原始哈密顿量 H 的精确轨道上，但它确实位于一个邻近的、修正的哈密顿量 $\\tilde{H}$ 的精确轨道上。对于像速度 Verlet 这样的二阶、时间可逆格式，这个修正的哈密顿量具有一个关于时间步长 $h$ 的偶次幂的渐近展开式：\n$$\n\\tilde{H}(q,p,h) = H(q,p) + h^2 H_2(q,p) + h^4 H_4(q,p) + \\mathcal{O}(h^6)\n$$\n该数值积分器在指数级长的时间内以非常高的精度（通常达到机器精度）守恒 $\\tilde{H}$。因此，沿着数值轨道 $(q_n, p_n)$，我们有 $\\tilde{H}(q_n, p_n) \\approx \\text{constant}$。\n我们计算的能量是原始能量 $H(q_n, p_n)$。根据展开式，我们可以写出：\n$$\nH(q_n, p_n) \\approx \\tilde{H}(q_n, p_n) - h^2 H_2(q_n, p_n)\n$$\n由于 $\\tilde{H}$ 近似恒定，原始能量 $H$ 随时间的变化主要由 $-h^2 H_2(q_n, p_n)$ 项主导。随着系统的演化，点 $(q_n, p_n)$ 在其相空间轨道上移动，导致 $H_2(q_n, p_n)$ 发生振荡。因此，测得的能量 $H(q_n, p_n)$ 表现为围绕一个常数的有界振荡。这些振荡的振幅尺度为 $\\mathcal{O}(h^2)$。这就解释了为什么最大相对能量偏差不会随时间增长，而是保持有界。\n\n$\\tilde{H}$ 展开式中缺少 $h$ 的奇次幂（例如，$h^1, h^3$）是积分器时间可逆性的直接结果。这一点至关重要，因为它消除了会导致能量出现长期或线性漂移的项。在模拟中观测到的任何残余线性漂移都可归因于展开式中非常高阶项的影响，以及更实际地，数百万步中浮点舍入误差的累积。对于一个解析良好的模拟（$h$ 足够小），预计这种漂移会非常小，这一点将由计算出的归一化线性漂移率证实，该值应接近于零。所提供的测试用例将展示这些特性：较大的步长（用例3）将导致更大但仍有界的能量振荡，而较小的步长（用例4）将显示出小得多的振荡。谐振用例（用例1）作为基准，非线性用例则展示了该方法的鲁棒性。\n\n数值实现将遵循速度 Verlet 算法。对于每个测试用例，我们初始化 $(q_0, p_0 = 0)$，根据 $T_0 = 2\\pi\\sqrt{m/k}$、$h=T_0/N_{\\text{pp}}$ 和 $T_{\\text{tot}} = N_{\\text{per}} T_0$ 计算总步数。在每一步，我们记录时间 $t$ 和哈密顿量值 $H(q(t), p(t))$。最后，我们计算最大相对能量偏差以及对能量时间序列进行线性拟合得到的归一化斜率。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of integrating a nonlinear oscillator using a symplectic\n    integrator and analyzing its energy conservation properties.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (harmonic baseline)\n        {'m': 1.0, 'k': 1.0, 'alpha': 0.0, 'q0': 0.2, 'N_pp': 20},\n        # Case 2 (weakly nonlinear moderate step)\n        {'m': 1.0, 'k': 1.0, 'alpha': 0.01, 'q0': 0.2, 'N_pp': 20},\n        # Case 3 (weakly nonlinear coarse step near stability boundary)\n        {'m': 1.0, 'k': 1.0, 'alpha': 0.01, 'q0': 0.2, 'N_pp': 4},\n        # Case 4 (stronger nonlinearity fine step)\n        {'m': 1.0, 'k': 1.0, 'alpha': 0.05, 'q0': 0.3, 'N_pp': 100},\n    ]\n\n    # Universal simulation parameter\n    N_per = 10000\n\n    results = []\n    \n    for case in test_cases:\n        m = case['m']\n        k = case['k']\n        alpha = case['alpha']\n        q0 = case['q0']\n        N_pp = case['N_pp']\n        \n        # Initial conditions\n        q = q0\n        p = 0.0\n        \n        # Simulation time parameters\n        # For k=0, T0 is undefined. The problem guarantees k  0.\n        T0 = 2.0 * np.pi * np.sqrt(m / k)\n        h = T0 / N_pp\n        total_steps = int(N_per * N_pp)\n        \n        # Define the force and Hamiltonian functions\n        def force(pos):\n            return -(k * pos + 4.0 * alpha * pos**3)\n\n        def hamiltonian(pos, mom):\n            V = 0.5 * k * pos**2 + alpha * pos**4\n            T = 0.5 * mom**2 / m\n            return T + V\n\n        # Store initial energy\n        H0 = hamiltonian(q, p)\n        if H0 == 0:\n            # Avoid division by zero, although not expected for given cases.\n            # In this case, relative error is ill-defined.\n            # Let's set results to NaN to indicate a problem.\n            results.append([np.nan, np.nan])\n            continue\n\n        # Arrays to store time and energy history for analysis\n        energy_history = np.zeros(total_steps + 1)\n        time_history = np.zeros(total_steps + 1)\n        \n        energy_history[0] = H0\n        time_history[0] = 0.0\n\n        # Main integration loop using Velocity Verlet algorithm\n        for i in range(total_steps):\n            # 1. First half-kick for momentum\n            p_half = p + 0.5 * h * force(q)\n            \n            # 2. Full drift for position\n            q = q + h * p_half / m\n            \n            # 3. Second half-kick for momentum\n            p = p_half + 0.5 * h * force(q)\n            \n            # Store results\n            current_time = (i + 1) * h\n            current_energy = hamiltonian(q, p)\n            time_history[i+1] = current_time\n            energy_history[i+1] = current_energy\n\n        # Post-simulation analysis\n        # 1. Maximum relative energy deviation\n        # The deviation is |H(t) - H(0)| / |H(0)| since H(0) can be negative\n        # but in this problem, H(0) is always positive.\n        rel_energy_dev = np.abs((energy_history - H0) / H0)\n        max_rel_dev = np.max(rel_energy_dev)\n        \n        # 2. Normalized linear drift rate\n        # Perform a linear least-squares fit of H(t) vs t\n        # polyfit returns [slope, intercept]\n        slope, _ = np.polyfit(time_history, energy_history, 1)\n        normalized_drift = slope / H0\n        \n        results.append([max_rel_dev, normalized_drift])\n\n    # Final print statement in the exact required format.\n    # Format each number to avoid ambiguity, e.g., using scientific notation\n    # for small numbers.\n    formatted_results = []\n    for res_pair in results:\n        formatted_pair = f\"[{res_pair[0]:.8e},{res_pair[1]:.8e}]\"\n        formatted_results.append(formatted_pair)\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}