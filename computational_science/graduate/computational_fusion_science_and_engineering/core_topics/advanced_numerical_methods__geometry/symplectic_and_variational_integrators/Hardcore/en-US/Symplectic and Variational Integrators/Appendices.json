{
    "hands_on_practices": [
        {
            "introduction": "This first practice () provides a quantitative look at a key difference between symplectic and non-symplectic integrators. By applying the leapfrog (symplectic) and explicit Euler (non-symplectic) methods to the simple harmonic oscillator, you will derive and compare their respective numerical phase errors. This exercise highlights how symplectic methods excel at preserving the geometric structure of oscillatory motion, a crucial feature for long-term simulations in physics.",
            "id": "4051345",
            "problem": "Consider the one-degree-of-freedom Hamiltonian harmonic oscillator with Hamiltonian $H(q,p) = \\tfrac{1}{2}\\big(p^{2} + \\omega^{2} q^{2}\\big)$, where $q$ and $p$ are canonical position and momentum, respectively, and $\\omega \\gt 0$ is the true angular frequency. The equations of motion are Hamilton's equations $\\dot{q} = \\partial H / \\partial p$ and $\\dot{p} = - \\partial H / \\partial q$, which yield the linear system $\\dot{q} = p$ and $\\dot{p} = - \\omega^{2} q$. Such linear oscillatory dynamics arise as local models in charged-particle orbit calculations in magnetized plasmas relevant to computational fusion science and engineering, where long-time fidelity of geometric structure is essential.\n\nYou are to apply the symplectic leapfrog (also known as Störmer–Verlet) integrator with time step $h \\gt 0$ to this system, and derive the method's modified angular frequency $\\tilde{\\omega}$ such that one step of the method advances the solution by an effective phase angle $\\theta = h \\tilde{\\omega}$ satisfying the discrete dispersion relation of the method. Separately, apply the non-symplectic explicit Euler method with the same $h$ to the same first-order system and determine its effective angular frequency $\\omega_{\\mathrm{E}}$ in the sense that one step of explicit Euler advances the state by a complex eigenvalue whose argument is an angle $\\phi = h \\,\\omega_{\\mathrm{E}}$. Use radians for all angles and angular frequencies, and seconds for time.\n\nStarting only from the fundamental definitions above and from the algorithmic description of the two methods (leapfrog as the canonical half-step momentum update, full-step position update, half-step momentum update; explicit Euler as the forward one-step explicit method on the first-order system), perform the following tasks:\n\n- Derive the linear recurrence for the position variable $q_{n}$ satisfied by the leapfrog integrator and, from it, obtain the exact closed-form expression of the modified frequency $\\tilde{\\omega}$ as a function of $\\omega$ and $h$. Define the leapfrog phase error per unit time as $\\delta_{\\mathrm{LF}} = \\tilde{\\omega} - \\omega$ (in radians per second).\n- Derive the one-step amplification matrix of the explicit Euler method, determine its eigenvalues, define the effective per-step phase angle $\\phi$ as the argument of the eigenvalues, and obtain the exact closed-form expression of $\\omega_{\\mathrm{E}} = \\phi / h$ as a function of $\\omega$ and $h$. Define the Euler phase error per unit time as $\\delta_{\\mathrm{E}} = \\omega_{\\mathrm{E}} - \\omega$ (in radians per second).\n\nYour program must compute, for each test case below, the tuple of four real numbers $(\\tilde{\\omega}, \\omega_{\\mathrm{E}}, \\delta_{\\mathrm{LF}}, \\delta_{\\mathrm{E}})$, all expressed in radians per second. Use the exact analytic formulas you derived; do not estimate phases from simulated trajectories.\n\nAngle unit requirement: all angles are in radians. Physical unit requirement: all angular frequencies and phase errors must be given in radians per second.\n\nTest suite (each case is a pair $(\\omega, h)$ with $\\omega$ in radians per second and $h$ in seconds):\n\n- Case $1$: $(\\omega, h) = (\\,1.0,\\, 0.1\\,)$.\n- Case $2$: $(\\omega, h) = (\\,1.0,\\, 1.999\\,)$.\n- Case $3$: $(\\omega, h) = (\\,10.0,\\, 0.05\\,)$.\n- Case $4$: $(\\omega, h) = (\\,2.0,\\, 1.0\\,)$.\n\nDesign-for-coverage rationale: Case $1$ is a small-step \"happy path\"; Case $2$ probes the leapfrog stability edge $h\\,\\omega \\lesssim 2$; Case $3$ tests a high-frequency oscillator with a moderate Courant-like number $h\\,\\omega$; Case $4$ sits at the leapfrog stability boundary $h\\,\\omega = 2$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case in the order listed above, append the four values $(\\tilde{\\omega}, \\omega_{\\mathrm{E}}, \\delta_{\\mathrm{LF}}, \\delta_{\\mathrm{E}})$, in that order, resulting in a flat list of $16$ floating-point numbers. For example, the output must have the form\n\"[wtilde1,wE1,dLF1,dE1,wtilde2,wE2,dLF2,dE2,wtilde3,wE3,dLF3,dE3,wtilde4,wE4,dLF4,dE4]\".",
            "solution": "The problem statement requires the derivation and computation of the modified and effective angular frequencies for the symplectic leapfrog and explicit Euler methods, respectively, as applied to the one-degree-of-freedom simple harmonic oscillator.\n\nThe system is defined by the Hamiltonian $H(q,p) = \\frac{1}{2}(p^2 + \\omega^2 q^2)$, with $\\omega > 0$. The equations of motion are Hamilton's equations:\n$$\n\\dot{q} = \\frac{\\partial H}{\\partial p} = p\n$$\n$$\n\\dot{p} = -\\frac{\\partial H}{\\partial q} = -\\omega^2 q\n$$\nThese form a linear system of ordinary differential equations. We are given a discrete time step $h > 0$.\n\nFirst, we analyze the symplectic leapfrog (Störmer–Verlet) integrator. The problem defines its application through three sequential steps for advancing the state from time $t_n$ to $t_{n+1} = t_n + h$:\n$1$. A half-step update of momentum: $p_{n+1/2} = p_n + \\frac{h}{2}\\dot{p}(q_n) = p_n - \\frac{h^2\\omega^2}{2}q_n$.\n$2$. A full-step update of position using the half-step momentum: $q_{n+1} = q_n + h\\dot{q}(p_{n+1/2}) = q_n + hp_{n+1/2}$.\n$3$. A final half-step update of momentum: $p_{n+1} = p_{n+1/2} + \\frac{h}{2}\\dot{p}(q_{n+1}) = p_{n+1/2} - \\frac{h^2\\omega^2}{2}q_{n+1}$.\n\nTo derive the linear recurrence for the position variable $q_n$, we express the momenta in terms of positions. From step $2$, we have $p_{n+1/2} = \\frac{q_{n+1}-q_n}{h}$. Shifting the index back by one step gives $p_{n-1/2} = \\frac{q_n-q_{n-1}}{h}$. The momentum is typically viewed as being updated on a staggered grid. The update from $p_{n-1/2}$ to $p_{n+1/2}$ occurs over a full time step $h$ and is driven by the force at the intermediate time $t_n$:\n$$\np_{n+1/2} = p_{n-1/2} + h \\dot{p}(q_n) = p_{n-1/2} - h\\omega^2 q_n\n$$\nSubstituting the expressions for the momenta in terms of positions into this equation yields:\n$$\n\\frac{q_{n+1}-q_n}{h} = \\frac{q_n-q_{n-1}}{h} - h\\omega^2 q_n\n$$\nMultiplying by $h$ and rearranging gives the desired three-term recurrence relation for $q_n$:\n$$\nq_{n+1} - 2q_n + q_{n-1} = -h^2\\omega^2 q_n\n$$\n$$\nq_{n+1} - (2 - (h\\omega)^2)q_n + q_{n-1} = 0\n$$\nThis is a linear homogeneous difference equation. We seek a solution of the form $q_n = \\lambda^n$. Substituting this ansatz into the recurrence yields the characteristic equation:\n$$\n\\lambda^2 - (2 - (h\\omega)^2)\\lambda + 1 = 0\n$$\nThe roots of this quadratic equation are the eigenvalues of the discrete time-evolution operator. The roots are given by:\n$$\n\\lambda_{\\pm} = \\frac{(2 - (h\\omega)^2) \\pm \\sqrt{(2 - (h\\omega)^2)^2 - 4}}{2}\n$$\nFor the numerical solution to be oscillatory (stable), the discriminant must be negative, which requires $(2 - (h\\omega)^2)^2 - 4 < 0$. This implies $-2 < 2 - (h\\omega)^2 < 2$. The right inequality is $(h\\omega)^2 > 0$, which is always true for $h, \\omega > 0$. The left inequality is $(h\\omega)^2 < 4$, which gives the well-known CFL-type stability condition for the leapfrog method: $h\\omega < 2$. For the boundary case $h\\omega=2$, the roots are real and equal to $-1$. For $h\\omega > 2$, the roots are real and one has magnitude greater than $1$, leading to exponential growth.\n\nAssuming the stability condition $h\\omega \\le 2$ holds, the eigenvalues are a complex conjugate pair $\\lambda_{\\pm} = e^{\\pm i\\theta}$, where $\\theta = h\\tilde{\\omega}$ is the numerical phase advance per step and $\\tilde{\\omega}$ is the modified angular frequency. The sum of the roots is $\\lambda_+ + \\lambda_- = e^{i\\theta} + e^{-i\\theta} = 2\\cos(\\theta)$. From Vieta's formulas applied to the characteristic equation, the sum of the roots is also $2 - (h\\omega)^2$. Equating these gives the dispersion relation:\n$$\n2\\cos(h\\tilde{\\omega}) = 2 - (h\\omega)^2 \\implies \\cos(h\\tilde{\\omega}) = 1 - \\frac{(h\\omega)^2}{2}\n$$\nSolving for $\\tilde{\\omega}$ gives the exact closed-form expression for the modified angular frequency:\n$$\n\\tilde{\\omega} = \\frac{1}{h}\\arccos\\left(1 - \\frac{(h\\omega)^2}{2}\\right)\n$$\nThis expression is valid for $0 \\lt h\\omega \\le 2$. The phase error per unit time is then defined as:\n$$\n\\delta_{\\mathrm{LF}} = \\tilde{\\omega} - \\omega\n$$\n\nNext, we analyze the non-symplectic explicit Euler method. The system in first-order matrix form is $\\dot{\\mathbf{z}} = A\\mathbf{z}$, where $\\mathbf{z} = \\begin{pmatrix} q \\\\ p \\end{pmatrix}$ and $A = \\begin{pmatrix} 0 & 1 \\\\ -\\omega^2 & 0 \\end{pmatrix}$. The explicit Euler method is defined by the update rule $\\mathbf{z}_{n+1} = \\mathbf{z}_n + h \\dot{\\mathbf{z}}_n$. For our system, this becomes:\n$$\n\\mathbf{z}_{n+1} = \\mathbf{z}_n + hA\\mathbf{z}_n = (I + hA)\\mathbf{z}_n\n$$\nThe one-step amplification matrix is therefore $M_{\\mathrm{E}} = I + hA$.\n$$\nM_{\\mathrm{E}} = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} + h\\begin{pmatrix} 0 & 1 \\\\ -\\omega^2 & 0 \\end{pmatrix} = \\begin{pmatrix} 1 & h \\\\ -h\\omega^2 & 1 \\end{pmatrix}\n$$\nThe eigenvalues $\\lambda$ of $M_{\\mathrm{E}}$ determine the stability and phase properties of the method. They are found by solving the characteristic equation $\\det(M_{\\mathrm{E}} - \\lambda I) = 0$:\n$$\n\\det\\begin{pmatrix} 1-\\lambda & h \\\\ -h\\omega^2 & 1-\\lambda \\end{pmatrix} = (1-\\lambda)^2 + h^2\\omega^2 = 0\n$$\nThis gives $(1-\\lambda)^2 = - (h\\omega)^2$, so $1-\\lambda = \\pm i h\\omega$. The eigenvalues are thus a complex conjugate pair:\n$$\n\\lambda_{\\pm} = 1 \\mp i h\\omega\n$$\nThe magnitude of these eigenvalues is $|\\lambda_{\\pm}| = \\sqrt{1^2 + (\\mp h\\omega)^2} = \\sqrt{1 + (h\\omega)^2}$. Since $|\\lambda_{\\pm}| > 1$ for any $h,\\omega > 0$, the method is unconditionally unstable for the harmonic oscillator; the numerical amplitude grows exponentially.\n\nThe problem defines the effective phase angle per step, $\\phi$, as the argument of the eigenvalues. For a positive phase angle convention, we select the eigenvalue with the positive imaginary part, $\\lambda = 1 + i h\\omega$. The argument of this complex number is $\\phi = \\arg(1 + i h\\omega)$. In the complex plane, this corresponds to a point with real part $1$ and imaginary part $h\\omega$. The angle is given by:\n$$\n\\phi = \\arctan(h\\omega)\n$$\nwhere `arctan` refers to the principal value, returning an angle in $(-\\pi/2, \\pi/2)$. Since $h\\omega > 0$, $\\phi$ is in $(0, \\pi/2)$.\nThe effective angular frequency $\\omega_{\\mathrm{E}}$ is defined by $\\phi = h\\omega_{\\mathrm{E}}$. This gives:\n$$\n\\omega_{\\mathrm{E}} = \\frac{\\phi}{h} = \\frac{1}{h}\\arctan(h\\omega)\n$$\nThe Euler phase error per unit time is then defined as:\n$$\n\\delta_{\\mathrm{E}} = \\omega_{\\mathrm{E}} - \\omega\n$$\nThese derived formulas for $\\tilde{\\omega}$, $\\delta_{\\mathrm{LF}}$, $\\omega_{\\mathrm{E}}$, and $\\delta_{\\mathrm{E}}$ will be used for the numerical computation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of finding modified/effective frequencies and phase errors\n    for leapfrog and explicit Euler integrators for the harmonic oscillator.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (omega, h).\n    test_cases = [\n        (1.0, 0.1),\n        (1.0, 1.999),\n        (10.0, 0.05),\n        (2.0, 1.0),\n    ]\n\n    results = []\n    for omega, h in test_cases:\n        # --- Leapfrog Integrator Calculations ---\n\n        # The modified angular frequency for leapfrog is derived from the\n        # dispersion relation: cos(h*w_tilde) = 1 - 0.5*(h*omega)^2.\n        # This is valid for h*omega <= 2.\n        hw = h * omega\n        \n        # Argument for arccos. It is guaranteed to be in [-1, 1] for the test cases.\n        arg_acos = 1.0 - 0.5 * hw**2\n        \n        # np.arccos returns the principal value in [0, pi].\n        # The result is guaranteed to be non-negative.\n        w_tilde = (1.0 / h) * np.arccos(arg_acos)\n        \n        # Phase error per unit time for leapfrog.\n        delta_LF = w_tilde - omega\n        \n        # --- Explicit Euler Integrator Calculations ---\n\n        # The effective angular frequency for explicit Euler is derived from\n        # the argument of its amplification matrix eigenvalues: phi = arctan(h*omega).\n        # w_E = phi / h.\n        w_E = (1.0 / h) * np.arctan(hw)\n        \n        # Phase error per unit time for explicit Euler.\n        delta_E = w_E - omega\n        \n        # Append the four computed values for the current test case.\n        results.extend([w_tilde, w_E, delta_LF, delta_E])\n\n    # Final print statement in the exact required format.\n    # The list 'results' is a flat list of all 16 numbers.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having observed the practical benefits of a symplectic integrator, this exercise () moves to the formal proof of this property. You will derive the Jacobian of the one-step map for the implicit midpoint method applied to a general quadratic Hamiltonian. By directly verifying the algebraic condition $J^{\\top} \\Omega J = \\Omega$, you will gain a deeper understanding of the mathematical structure that defines a symplectic map.",
            "id": "4051356",
            "problem": "Consider canonical Hamiltonian dynamics on a phase space of dimension $2n$ relevant to computational fusion science and engineering, where long-time accurate simulation of charged particle and field-line motion demands preservation of the canonical symplectic two-form. Let $z \\in \\mathbb{R}^{2n}$ denote the canonical coordinates $z = (q, p)$, and let the canonical symplectic matrix be\n$$\n\\Omega = \\begin{pmatrix} 0 & I_n \\\\ -I_n & 0 \\end{pmatrix},\n$$\nwhich encodes the canonical symplectic form. The Hamiltonian is assumed to be quadratic,\n$$\nH(z) = \\frac{1}{2} z^{\\top} K z + b^{\\top} z + c,\n$$\nwhere $K \\in \\mathbb{R}^{2n \\times 2n}$ is a constant symmetric matrix, $b \\in \\mathbb{R}^{2n}$, and $c \\in \\mathbb{R}$. The continuous-time dynamics are given by Hamilton's equations,\n$$\n\\dot{z} = \\Omega \\nabla H(z).\n$$\nDefine the implicit midpoint one-step method with step size $h > 0$ by the update $\\Phi_h: z \\mapsto z_{+}$ determined implicitly through\n$$\nz_{+} = z + h \\, \\Omega \\, \\nabla H\\!\\left(\\frac{z + z_{+}}{2}\\right).\n$$\nStarting from these principles and definitions, derive the Jacobian matrix $J = \\frac{\\partial z_{+}}{\\partial z}$ of the one-step map $\\Phi_h$ for the general quadratic Hamiltonian given above. Express $J$ explicitly in terms of $h$, $\\Omega$, and $K$ only, avoiding any dependence on $z$, $b$, or $c$. Then, using only the structural properties of $\\Omega$ and the symmetry of $K$, verify the discrete symplecticity condition\n$$\nJ^{\\top} \\Omega J = \\Omega\n$$\nfor all step sizes $h$ such that the matrix $I_{2n} - \\frac{h}{2} \\Omega K$ is invertible. Provide your final answer as a single closed-form analytic expression for $J$ in terms of $h$, $\\Omega$, and $K$. No numerical approximation is required, and no units are needed in the final expression.",
            "solution": "The problem statement has been validated and is deemed a well-posed, scientifically grounded problem in the field of geometric numerical integration for Hamiltonian systems. We may proceed with a formal solution.\n\nThe objective is to first derive the Jacobian matrix $J = \\frac{\\partial z_{+}}{\\partial z}$ for the map $\\Phi_h: z \\mapsto z_{+}$ defined by the implicit midpoint rule, and then to verify that this map is symplectic.\n\nThe Hamiltonian is given as a quadratic function of the canonical coordinates $z \\in \\mathbb{R}^{2n}$:\n$$\nH(z) = \\frac{1}{2} z^{\\top} K z + b^{\\top} z + c\n$$\nHere, $K \\in \\mathbb{R}^{2n \\times 2n}$ is a symmetric matrix ($K = K^{\\top}$), $b \\in \\mathbb{R}^{2n}$, and $c \\in \\mathbb{R}$.\n\nFirst, we compute the gradient of the Hamiltonian, $\\nabla H(z)$. Using standard rules of vector calculus and the symmetry of $K$:\n$$\n\\nabla H(z) = \\frac{1}{2} (K + K^{\\top})z + b = \\frac{1}{2} (2K)z + b = Kz + b\n$$\nThe Hessian of the Hamiltonian is therefore the constant matrix $\\nabla^2 H(z) = K$.\n\nThe implicit midpoint one-step method is defined by the relation:\n$$\nz_{+} = z + h \\, \\Omega \\, \\nabla H\\!\\left(\\frac{z + z_{+}}{2}\\right)\n$$\nwhere $z$ is the state at the beginning of the step, $z_{+}$ is the state at the end, $h > 0$ is the step size, and $\\Omega = \\begin{pmatrix} 0 & I_n \\\\ -I_n & 0 \\end{pmatrix}$ is the canonical symplectic matrix.\n\nSubstituting the expression for the gradient into the update rule gives:\n$$\nz_{+} = z + h \\, \\Omega \\, \\left[ K\\left(\\frac{z + z_{+}}{2}\\right) + b \\right]\n$$\nWe can expand and rearrange this equation to solve for $z_{+}$ in terms of $z$:\n$$\nz_{+} = z + \\frac{h}{2} \\Omega K (z + z_{+}) + h \\Omega b\n$$\n$$\nz_{+} = z + \\frac{h}{2} \\Omega K z + \\frac{h}{2} \\Omega K z_{+} + h \\Omega b\n$$\nCollecting terms involving $z_{+}$ on the left-hand side and terms involving $z$ on the right-hand side:\n$$\nz_{+} - \\frac{h}{2} \\Omega K z_{+} = z + \\frac{h}{2} \\Omega K z + h \\Omega b\n$$\nFactoring out $z_{+}$ and $z$:\n$$\n\\left(I_{2n} - \\frac{h}{2} \\Omega K\\right) z_{+} = \\left(I_{2n} + \\frac{h}{2} \\Omega K\\right) z + h \\Omega b\n$$\nwhere $I_{2n}$ is the $2n \\times 2n$ identity matrix.\n\nThe problem states that the matrix $\\left(I_{2n} - \\frac{h}{2} \\Omega K\\right)$ is invertible. We can therefore pre-multiply by its inverse to obtain an explicit expression for $z_{+}$:\n$$\nz_{+} = \\left(I_{2n} - \\frac{h}{2} \\Omega K\\right)^{-1} \\left[ \\left(I_{2n} + \\frac{h}{2} \\Omega K\\right) z + h \\Omega b \\right]\n$$\nThe mapping $\\Phi_h: z \\mapsto z_{+}$ is an affine transformation of the form $z_{+} = M z + v$. The Jacobian matrix $J = \\frac{\\partial z_{+}}{\\partial z}$ is the linear part of this transformation, which is the matrix $M$.\n$$\nJ = \\frac{\\partial z_{+}}{\\partial z} = \\left(I_{2n} - \\frac{h}{2} \\Omega K\\right)^{-1} \\left(I_{2n} + \\frac{h}{2} \\Omega K\\right)\n$$\nThis expression for $J$ depends only on $h$, $\\Omega$, and $K$, as required. This completes the first part of the problem.\n\nNext, we must verify the discrete symplecticity condition $J^{\\top} \\Omega J = \\Omega$. This condition means the numerical flow map $\\Phi_h$ preserves the canonical symplectic two-form.\n\nWe start by noting the fundamental properties of the involved matrices:\n1. $K$ is symmetric: $K^{\\top} = K$.\n2. $\\Omega$ is skew-symmetric: $\\Omega^{\\top} = -\\Omega$.\n3. From its definition, $\\Omega^2 = -I_{2n}$, which implies $\\Omega^{-1} = -\\Omega$. Thus, $\\Omega^{\\top} = \\Omega^{-1}$.\n\nLet us define the matrix $S = \\frac{h}{2} \\Omega K$. The Jacobian can be written as $J = (I_{2n} - S)^{-1}(I_{2n} + S)$. For simplicity, we shall omit the subscript on the identity matrix, letting $I$ denote $I_{2n}$.\nThe transpose of $J$ is $J^{\\top} = \\left((I-S)^{-1}(I+S)\\right)^{\\top} = (I+S)^{\\top} \\left((I-S)^{-1}\\right)^{\\top} = (I+S^{\\top})(I-S^{\\top})^{-1}$.\n\nLet's examine $S^{\\top}$:\n$$\nS^{\\top} = \\left(\\frac{h}{2} \\Omega K\\right)^{\\top} = \\frac{h}{2} K^{\\top} \\Omega^{\\top} = \\frac{h}{2} K (-\\Omega) = -\\frac{h}{2} K \\Omega\n$$\nNow, we establish a key identity relating $S$ and $S^\\top$ using $\\Omega$:\n$$\n\\Omega S \\Omega^{-1} = \\Omega \\left(\\frac{h}{2} \\Omega K\\right) \\Omega^{-1} = \\frac{h}{2} \\Omega^2 K \\Omega^{-1} = \\frac{h}{2}(-I) K (-\\Omega) = \\frac{h}{2} K \\Omega\n$$\nComparing this with the expression for $S^{\\top}$, we see that $\\Omega S \\Omega^{-1} = -S^{\\top}$.\n\nNow we substitute this identity into the expression for $J^{\\top}$:\n$$\nJ^{\\top} = (I + S^{\\top})(I - S^{\\top})^{-1} = (I - \\Omega S \\Omega^{-1}) (I + \\Omega S \\Omega^{-1})^{-1}\n$$\nWe can factor out $\\Omega$ and $\\Omega^{-1}$:\n$$\nI - \\Omega S \\Omega^{-1} = \\Omega \\Omega^{-1} - \\Omega S \\Omega^{-1} = \\Omega(I-S)\\Omega^{-1}\n$$\n$$\nI + \\Omega S \\Omega^{-1} = \\Omega \\Omega^{-1} + \\Omega S \\Omega^{-1} = \\Omega(I+S)\\Omega^{-1}\n$$\nThe inverse term becomes:\n$$\n(I + \\Omega S \\Omega^{-1})^{-1} = [\\Omega(I+S)\\Omega^{-1}]^{-1} = (\\Omega^{-1})^{-1}(I+S)^{-1}\\Omega^{-1} = \\Omega(I+S)^{-1}\\Omega^{-1}\n$$\nSubstituting these back into the expression for $J^{\\top}$:\n$$\nJ^{\\top} = \\left[\\Omega(I-S)\\Omega^{-1}\\right] \\left[\\Omega(I+S)^{-1}\\Omega^{-1}\\right] = \\Omega(I-S)(\\Omega^{-1}\\Omega)(I+S)^{-1}\\Omega^{-1}\n$$\n$$\nJ^{\\top} = \\Omega(I-S)(I+S)^{-1}\\Omega^{-1}\n$$\nThe inverse of $J$ is $J^{-1} = ((I-S)^{-1}(I+S))^{-1} = (I+S)^{-1}(I-S)$. Since $(I-S)$ and $(I+S)$ commute, we can also write $J^{-1} = (I-S)(I+S)^{-1}$.\nTherefore, we have found the relation $J^{\\top} = \\Omega J^{-1} \\Omega^{-1}$.\n\nFinally, we use this relation to verify the symplecticity condition:\n$$\nJ^{\\top} \\Omega J = (\\Omega J^{-1} \\Omega^{-1}) \\Omega J\n$$\nUsing the associativity of matrix multiplication:\n$$\nJ^{\\top} \\Omega J = \\Omega J^{-1} (\\Omega^{-1} \\Omega) J = \\Omega J^{-1} I J = \\Omega (J^{-1}J) = \\Omega I = \\Omega\n$$\nThis confirms that $J^{\\top} \\Omega J = \\Omega$. The map defined by the implicit midpoint method for a quadratic Hamiltonian is indeed symplectic for any step size $h$ for which its Jacobian is well-defined.\nThe final required expression is that for the Jacobian matrix $J$.",
            "answer": "$$\\boxed{\\left(I_{2n} - \\frac{h}{2} \\Omega K\\right)^{-1} \\left(I_{2n} + \\frac{h}{2} \\Omega K\\right)}$$"
        },
        {
            "introduction": "This final practice () explores the profound long-term consequences of using a symplectic integrator on a nonlinear system, a scenario common in fusion plasma physics. You will simulate a nonlinear oscillator over thousands of periods using the Störmer-Verlet method and analyze the characteristic bounded oscillations in the computed energy. This exercise connects your numerical results to the powerful theory of Backward Error Analysis, which explains the remarkable long-term fidelity of symplectic schemes.",
            "id": "4051315",
            "problem": "Consider a one-dimensional Hamiltonian system defined by the Hamiltonian $H(q,p) = \\frac{p^2}{2m} + V(q)$ with potential $V(q) = \\frac{1}{2}k q^2 + \\alpha q^4$. The canonical equations of motion follow from Hamilton's equations and define the exact flow that preserves the symplectic two-form and the Hamiltonian. Your task is to study the long-time behavior of the numerical energy produced by a second-order symplectic, variational integrator derived from a discrete action principle. Specifically, implement a position-momentum update that is consistent with a discrete Euler–Lagrange construction using a consistent second-order approximation to the continuous Lagrangian $L(q,\\dot{q}) = \\frac{1}{2}m \\dot{q}^2 - V(q)$, and then use this update to integrate the motion for $10^4$ reference periods.\n\nFundamental base for derivation and analysis:\n- Use the definition of the Lagrangian $L(q,\\dot{q})$ and the action functional, and derive discrete equations of motion from the discrete action by applying the principle of stationary action to a second-order accurate discrete Lagrangian. This must yield a symplectic, time-reversible scheme of second order.\n- Use Hamilton's equations for the given separable Hamiltonian to reason about the splitting of the flow and the properties of symplectic integrators.\n- Use the concept of Backward Error Analysis (BEA), defined as the study of a modified differential equation whose exact flow is closer to the numerical method than the original system, to explain bounded energy oscillations and near-conservation of a modified Hamiltonian.\n\nProgram requirements:\n1. Implement a second-order symplectic, variational integrator for the separable Hamiltonian $H(q,p) = \\frac{p^2}{2m} + V(q)$ with $V(q) = \\frac{1}{2}k q^2 + \\alpha q^4$. The update must be derived from first principles of discrete variational mechanics, and must be symplectic and time-reversible.\n2. For each test case, compute an approximate reference period $T_0 = 2\\pi \\sqrt{\\frac{m}{k}}$ (in seconds), define the time step $h = \\frac{T_0}{N_{\\text{pp}}}$ (in seconds) where $N_{\\text{pp}}$ denotes the number of steps per reference period, and integrate for $N_{\\text{per}} = 10^4$ reference periods for a total integration time $T_{\\text{tot}} = N_{\\text{per}} T_0$ (in seconds).\n3. Initialize with $q(0) = q_0$ (in meters) and $p(0) = 0$ (in kilogram meter per second).\n4. During integration, compute the instantaneous energy $H(q(t),p(t))$ (in joules) at every step and record:\n   - The maximum relative energy deviation over the entire simulation, defined as $\\max_{0 \\le t \\le T_{\\text{tot}}} \\left| \\frac{H(t) - H(0)}{H(0)} \\right|$ (dimensionless decimal).\n   - The normalized linear drift rate of the energy, computed as the slope of the least-squares linear fit of $H(t)$ versus $t$ divided by $H(0)$, which has units of inverse seconds. Explicitly, if the least-squares slope is $s$ (in joules per second), report $\\frac{s}{H(0)}$ (in inverse seconds).\n5. Explain qualitatively how the observed oscillations and small drift rates relate to Backward Error Analysis (BEA), which predicts the existence of a modified Hamiltonian $\\tilde{H} = H + h^2 \\Delta H + \\mathcal{O}(h^4)$ that is nearly conserved by symplectic second-order schemes, with oscillatory energy errors of amplitude scaling like $\\mathcal{O}(h^2)$.\n\nPhysical and numerical units:\n- Report energies in joules, time in seconds, mass in kilograms, position in meters, stiffness in newtons per meter, and $\\alpha$ in newtons per meter cubed.\n- The drift rate must be reported in inverse seconds.\n- Any fractional quantity must be expressed as a decimal.\n\nTest suite:\nUse the following four scientifically sound test cases to cover harmonic, weakly nonlinear, coarse step near stability, and fine step regimes. For all test cases, set the number of reference periods to $N_{\\text{per}} = 10^4$.\n- Case $1$ (harmonic baseline): $m = 1.0$ kilograms, $k = 1.0$ newtons per meter, $\\alpha = 0.0$ newtons per meter cubed, $q_0 = 0.2$ meters, $N_{\\text{pp}} = 20$.\n- Case $2$ (weakly nonlinear moderate step): $m = 1.0$ kilograms, $k = 1.0$ newtons per meter, $\\alpha = 0.01$ newtons per meter cubed, $q_0 = 0.2$ meters, $N_{\\text{pp}} = 20$.\n- Case $3$ (weakly nonlinear coarse step near stability boundary): $m = 1.0$ kilograms, $k = 1.0$ newtons per meter, $\\alpha = 0.01$ newtons per meter cubed, $q_0 = 0.2$ meters, $N_{\\text{pp}} = 4$.\n- Case $4$ (stronger nonlinearity fine step): $m = 1.0$ kilograms, $k = 1.0$ newtons per meter, $\\alpha = 0.05$ newtons per meter cubed, $q_0 = 0.3$ meters, $N_{\\text{pp}} = 100$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is a two-element list for the corresponding test case. Each two-element list must be ordered as $[$maximum relative energy deviation, normalized linear drift rate in inverse seconds$]$. For example, the output should look like $[[x_1,y_1],[x_2,y_2],[x_3,y_3],[x_4,y_4]]$ with decimal values.",
            "solution": "The problem as stated is scientifically sound, self-contained, and well-posed. It presents a standard task in computational dynamics: the long-term integration of a conservative Hamiltonian system using a symplectic numerical method. All parameters, initial conditions, and analysis requirements are specified unambiguously. The underlying principles—Hamiltonian mechanics, discrete variational principles, and backward error analysis—are cornerstones of the field. Therefore, I will proceed with a full derivation and solution.\n\nThe objective is to implement a second-order, symplectic, variational integrator for a one-dimensional nonlinear oscillator and analyze its long-term energy conservation properties. The system is described by the separable Hamiltonian $H(q,p) = T(p) + V(q)$, where the kinetic energy is $T(p) = \\frac{p^2}{2m}$ and the potential energy is $V(q) = \\frac{1}{2}k q^2 + \\alpha q^4$.\n\nA numerical method is termed variational if it can be derived from a discrete version of Hamilton's principle of stationary action. The continuous action functional is $S[q] = \\int L(q(t), \\dot{q}(t)) dt$, where the Lagrangian is $L = T - V$. We construct a discrete Lagrangian $L_d(q_n, q_{n+1})$ that approximates $\\int_{t_n}^{t_{n+1}} L(q(t), \\dot{q}(t)) dt$. A common second-order accurate choice uses a finite difference for the velocity and a trapezoidal rule for the potential, yielding:\n$$\nL_d(q_n, q_{n+1}) = h \\left[ \\frac{1}{2}m \\left(\\frac{q_{n+1}-q_n}{h}\\right)^2 - \\frac{1}{2}\\left(V(q_n) + V(q_{n+1})\\right) \\right]\n$$\nThe discrete action is the sum $S_d = \\sum_n L_d(q_n, q_{n+1})$. The principle of stationary action, $\\delta S_d = 0$, for variations $\\delta q_n$ vanishing at the endpoints, leads to the discrete Euler-Lagrange equations:\n$$\n\\frac{\\partial L_d(q_{n-1}, q_n)}{\\partial q_n} + \\frac{\\partial L_d(q_n, q_{n+1})}{\\partial q_n} = 0\n$$\nComputing the partial derivatives:\n$$\n\\frac{\\partial L_d(q_{n-1}, q_n)}{\\partial q_n} = \\frac{m}{h}(q_n - q_{n-1}) - \\frac{h}{2} V'(q_n)\n$$\n$$\n\\frac{\\partial L_d(q_n, q_{n+1})}{\\partial q_n} = -\\frac{m}{h}(q_{n+1} - q_n) - \\frac{h}{2} V'(q_n)\n$$\nSubstituting these into the discrete Euler-Lagrange equation gives:\n$$\n\\frac{m}{h}(q_n - q_{n-1}) - \\frac{h}{2} V'(q_n) - \\frac{m}{h}(q_{n+1} - q_n) - \\frac{h}{2} V'(q_n) = 0\n$$\nRearranging terms yields the celebrated Störmer-Verlet (or position Verlet) algorithm:\n$$\nm \\frac{q_{n+1} - 2q_n + q_{n-1}}{h^2} = -V'(q_n) = F(q_n)\n$$\nwhere $F(q) = -V'(q)$ is the force. While this form is elegant, it is a three-term recurrence in position and does not explicitly use the momentum variable $p$. For phase space analysis, it is equivalent and often more convenient to use the \"velocity Verlet\" formulation, which is a one-step method in $(q, p)$ space. This algorithm is derived by splitting the Liouville operator and is known to be symplectic. The equivalence can be shown by defining an intermediate momentum. The velocity Verlet algorithm for the given system is:\n1. First half-kick for momentum: $p_{n+1/2} = p_n - \\frac{h}{2} \\frac{\\partial V}{\\partial q}(q_n) = p_n + \\frac{h}{2} F(q_n)$\n2. Full drift for position: $q_{n+1} = q_n + h \\frac{\\partial T}{\\partial p}(p_{n+1/2}) = q_n + \\frac{h}{m} p_{n+1/2}$\n3. Second half-kick for momentum: $p_{n+1} = p_{n+1/2} - \\frac{h}{2} \\frac{\\partial V}{\\partial q}(q_{n+1}) = p_{n+1/2} + \\frac{h}{2} F(q_{n+1})$\n\nThis integrator is explicitly defined, second-order accurate, time-reversible, and, most importantly, symplectic. Symplecticness means the numerical flow map $\\Phi_h: (q_n, p_n) \\to (q_{n+1}, p_{n+1})$ preserves the symplectic two-form $dq \\wedge dp$. This property is responsible for the excellent long-term behavior of the integrator.\n\nThe observed numerical results—bounded energy oscillations and negligible long-term energy drift—are quintessential features of symplectic integrators and are rigorously explained by Backward Error Analysis (BEA). BEA states that the numerical solution generated by a symplectic integrator, while not lying on the exact trajectory of the original Hamiltonian $H$, does lie on the exact trajectory of a nearby, modified Hamiltonian $\\tilde{H}$. For a second-order, time-reversible scheme like velocity Verlet, this modified Hamiltonian has an asymptotic expansion in even powers of the time step $h$:\n$$\n\\tilde{H}(q,p,h) = H(q,p) + h^2 H_2(q,p) + h^4 H_4(q,p) + \\mathcal{O}(h^6)\n$$\nThe numerical integrator conserves $\\tilde{H}$ to a very high degree (typically to machine precision) over exponentially long times. Thus, along the numerical trajectory $(q_n, p_n)$, we have $\\tilde{H}(q_n, p_n) \\approx \\text{constant}$.\nThe energy we compute is the original energy $H(q_n, p_n)$. From the expansion, we can write:\n$$\nH(q_n, p_n) \\approx \\tilde{H}(q_n, p_n) - h^2 H_2(q_n, p_n)\n$$\nSince $\\tilde{H}$ is nearly constant, the change in the original energy $H$ over time is dominated by the term $-h^2 H_2(q_n, p_n)$. As the system evolves, the point $(q_n, p_n)$ traverses its phase space orbit, causing $H_2(q_n, p_n)$ to oscillate. Consequently, the measured energy $H(q_n, p_n)$ exhibits bounded oscillations around a constant value. The amplitude of these oscillations scales as $\\mathcal{O}(h^2)$. This explains why the maximum relative energy deviation does not grow over time but remains bounded.\n\nThe absence of odd powers of $h$ (e.g., $h^1, h^3$) in the expansion of $\\tilde{H}$ is a direct consequence of the integrator's time-reversibility. This is crucial because it eliminates terms that would cause secular, or linear, drift in the energy. Any residual linear drift observed in a simulation is attributable to the influence of very high-order terms in the expansion and, more practically, to the accumulation of floating-point rounding errors over millions of steps. For a well-resolved simulation ($h$ is sufficiently small), this drift is expected to be extremely small, as confirmed by the calculated normalized linear drift rate, which should be close to zero. The provided test cases will demonstrate these properties: larger step sizes (Case $3$) will lead to larger, but still bounded, energy oscillations, while smaller step sizes (Case $4$) will show much smaller oscillations. The harmonic case (Case $1$) serves as a baseline, and the nonlinear cases show the robustness of the method.\n\nThe numerical implementation will follow the velocity Verlet algorithm. For each test case, we initialize $(q_0, p_0 = 0)$, compute the total number of steps from $T_0 = 2\\pi\\sqrt{m/k}$, $h=T_0/N_{\\text{pp}}$, and $T_{\\text{tot}} = N_{\\text{per}} T_0$. At each step, we record the time $t$ and the Hamiltonian value $H(q(t), p(t))$. Finally, we compute the maximum relative energy deviation and the normalized slope of a linear fit to the energy time series.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of integrating a nonlinear oscillator using a symplectic\n    integrator and analyzing its energy conservation properties.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (harmonic baseline)\n        {'m': 1.0, 'k': 1.0, 'alpha': 0.0, 'q0': 0.2, 'N_pp': 20},\n        # Case 2 (weakly nonlinear moderate step)\n        {'m': 1.0, 'k': 1.0, 'alpha': 0.01, 'q0': 0.2, 'N_pp': 20},\n        # Case 3 (weakly nonlinear coarse step near stability boundary)\n        {'m': 1.0, 'k': 1.0, 'alpha': 0.01, 'q0': 0.2, 'N_pp': 4},\n        # Case 4 (stronger nonlinearity fine step)\n        {'m': 1.0, 'k': 1.0, 'alpha': 0.05, 'q0': 0.3, 'N_pp': 100},\n    ]\n\n    # Universal simulation parameter\n    N_per = 10000\n\n    results = []\n    \n    for case in test_cases:\n        m = case['m']\n        k = case['k']\n        alpha = case['alpha']\n        q0 = case['q0']\n        N_pp = case['N_pp']\n        \n        # Initial conditions\n        q = q0\n        p = 0.0\n        \n        # Simulation time parameters\n        # For k=0, T0 is undefined. The problem guarantees k > 0.\n        T0 = 2.0 * np.pi * np.sqrt(m / k)\n        h = T0 / N_pp\n        total_steps = int(N_per * N_pp)\n        \n        # Define the force and Hamiltonian functions\n        def force(pos):\n            return -(k * pos + 4.0 * alpha * pos**3)\n\n        def hamiltonian(pos, mom):\n            V = 0.5 * k * pos**2 + alpha * pos**4\n            T = 0.5 * mom**2 / m\n            return T + V\n\n        # Store initial energy\n        H0 = hamiltonian(q, p)\n        if H0 == 0:\n            # Avoid division by zero, although not expected for given cases.\n            # In this case, relative error is ill-defined.\n            # Let's set results to NaN to indicate a problem.\n            results.append([np.nan, np.nan])\n            continue\n\n        # Arrays to store time and energy history for analysis\n        energy_history = np.zeros(total_steps + 1)\n        time_history = np.zeros(total_steps + 1)\n        \n        energy_history[0] = H0\n        time_history[0] = 0.0\n\n        # Main integration loop using Velocity Verlet algorithm\n        for i in range(total_steps):\n            # 1. First half-kick for momentum\n            p_half = p + 0.5 * h * force(q)\n            \n            # 2. Full drift for position\n            q = q + h * p_half / m\n            \n            # 3. Second half-kick for momentum\n            p = p_half + 0.5 * h * force(q)\n            \n            # Store results\n            current_time = (i + 1) * h\n            current_energy = hamiltonian(q, p)\n            time_history[i+1] = current_time\n            energy_history[i+1] = current_energy\n\n        # Post-simulation analysis\n        # 1. Maximum relative energy deviation\n        # The deviation is |H(t) - H(0)| / |H(0)| since H(0) can be negative\n        # but in this problem, H(0) is always positive.\n        rel_energy_dev = np.abs((energy_history - H0) / H0)\n        max_rel_dev = np.max(rel_energy_dev)\n        \n        # 2. Normalized linear drift rate\n        # Perform a linear least-squares fit of H(t) vs t\n        # polyfit returns [slope, intercept]\n        slope, _ = np.polyfit(time_history, energy_history, 1)\n        normalized_drift = slope / H0\n        \n        results.append([max_rel_dev, normalized_drift])\n\n    # Final print statement in the exact required format.\n    # Format each number to avoid ambiguity, e.g., using scientific notation\n    # for small numbers.\n    formatted_results = []\n    for res_pair in results:\n        formatted_pair = f\"[{res_pair[0]:.8e},{res_pair[1]:.8e}]\"\n        formatted_results.append(formatted_pair)\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}