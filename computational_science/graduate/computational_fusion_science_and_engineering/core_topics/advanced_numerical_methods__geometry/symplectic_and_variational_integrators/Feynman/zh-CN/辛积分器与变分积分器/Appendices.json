{
    "hands_on_practices": [
        {
            "introduction": "本实践将通过将辛积分器与非辛积分器应用于简谐振子，来探讨两者之间的一个根本区别。通过推导和比较辛蛙跳法的修正频率与显式欧拉法的有效频率，我们将具体理解辛方法如何通过卓越的相位精度来保持系统的定性振荡行为。",
            "id": "4051345",
            "problem": "考虑一个单自由度的哈密顿谐振子，其哈密顿量为 $H(q,p) = \\frac{1}{2}\\left(p^{2} + \\omega^{2} q^{2}\\right)$，其中 $q$ 和 $p$ 分别是正则位置和正则动量，$\\omega > 0$ 是真实角频率。运动方程为哈密顿方程 $\\dot{q} = \\partial H / \\partial p$ 和 $\\dot{p} = - \\partial H / \\partial q$，由此可得线性系统 $\\dot{q} = p$ 和 $\\dot{p} = - \\omega^{2} q$。此类线性振荡动力学作为局部模型出现于计算聚变科学与工程中相关的磁化等离子体中的带电粒子轨道计算，在这些计算中，几何结构的长期保真度至关重要。\n\n您需要将时间步长为 $h > 0$ 的辛蛙跳（也称为 Störmer–Verlet）积分方法应用于此系统，并推导该方法的修正角频率 $\\tilde{\\omega}$，使得该方法的一步演进使解前进一个有效相角 $\\theta = h \\tilde{\\omega}$，该相角满足方法的离散色散关系。另外，将时间步长同样为 $h$ 的非辛显式欧拉方法应用于相同的一阶系统，并确定其有效角频率 $\\omega_{\\mathrm{E}}$，其意义是显式欧拉法的一步演进使状态前进一个复特征值，该特征值的辐角为 $\\phi = h \\,\\omega_{\\mathrm{E}}$。所有角度和角频率均使用弧度，时间使用秒。\n\n仅从上述基本定义以及两种方法的算法描述（蛙跳法定义为正则的半步动量更新、全步位置更新、半步动量更新；显式欧拉法定义为作用于一阶系统的前向单步显式方法）出发，执行以下任务：\n\n- 推导蛙跳积分方法所满足的位置变量 $q_{n}$ 的线性递推关系，并由此获得修正频率 $\\tilde{\\omega}$ 作为 $\\omega$ 和 $h$ 的函数的精确闭式表达式。将蛙跳法的单位时间相误差定义为 $\\delta_{\\mathrm{LF}} = \\tilde{\\omega} - \\omega$（单位：弧度/秒）。\n- 推导显式欧拉法的单步放大矩阵，确定其特征值，将每步有效相角 $\\phi$ 定义为特征值的辐角，并获得 $\\omega_{\\mathrm{E}} = \\phi / h$ 作为 $\\omega$ 和 $h$ 的函数的精确闭式表达式。将欧拉法的单位时间相误差定义为 $\\delta_{\\mathrm{E}} = \\omega_{\\mathrm{E}} - \\omega$（单位：弧度/秒）。\n\n您的程序必须为下面的每个测试用例计算由四个实数组成的元组 $(\\tilde{\\omega}, \\omega_{\\mathrm{E}}, \\delta_{\\mathrm{LF}}, \\delta_{\\mathrm{E}})$，所有值均以弧度/秒表示。使用您推导出的精确解析公式；不要从模拟轨迹中估计相位。\n\n角度单位要求：所有角度均为弧度。物理单位要求：所有角频率和相误差必须以弧度/秒为单位给出。\n\n测试套件（每个用例是一个 $(\\omega, h)$ 对，$\\omega$ 的单位是弧度/秒， $h$ 的单位是秒）：\n\n- 用例 1：$(\\omega, h) = (\\,1.0,\\, 0.1\\,)$。\n- 用例 2：$(\\omega, h) = (\\,1.0,\\, 1.999\\,)$。\n- 用例 3：$(\\omega, h) = (\\,10.0,\\, 0.05\\,)$。\n- 用例 4：$(\\omega, h) = (\\,2.0,\\, 1.0\\,)$。\n\n覆盖率设计理由：用例 1 是小步长的“理想情况”；用例 2 探测蛙跳法的稳定性边界 $h\\,\\omega \\lesssim 2$；用例 3 测试一个具有中等类 Courant 数 $h\\,\\omega$ 的高频振荡器；用例 4 位于蛙跳法的稳定性边界 $h\\,\\omega = 2$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。对于上面列出的每个测试用例，按顺序附加四个值 $(\\tilde{\\omega}, \\omega_{\\mathrm{E}}, \\delta_{\\mathrm{LF}}, \\delta_{\\mathrm{E}})$，最终形成一个包含 16 个浮点数的扁平列表。例如，输出必须具有以下形式：\n\"[wtilde1,wE1,dLF1,dE1,wtilde2,wE2,dLF2,dE2,wtilde3,wE3,dLF3,dE3,wtilde4,wE4,dLF4,dE4]\"。",
            "solution": "问题陈述要求推导和计算应用于单自由度简谐振子的辛蛙跳法和显式欧拉法的修正角频率和有效角频率。\n\n该系统由哈密顿量 $H(q,p) = \\frac{1}{2}(p^2 + \\omega^2 q^2)$ 定义，其中 $\\omega > 0$。运动方程为哈密顿方程：\n$$\n\\dot{q} = \\frac{\\partial H}{\\partial p} = p\n$$\n$$\n\\dot{p} = -\\frac{\\partial H}{\\partial q} = -\\omega^2 q\n$$\n这些构成了一个线性常微分方程组。我们给定一个离散时间步长 $h > 0$。\n\n首先，我们分析辛蛙跳（Störmer–Verlet）积分方法。问题通过三个连续步骤来定义其将状态从时间 $t_n$ 推进到 $t_{n+1} = t_n + h$ 的过程：\n1. 动量的半步更新：$p_{n+1/2} = p_n + \\frac{h}{2}\\dot{p}(q_n) = p_n - \\frac{h\\omega^2}{2}q_n$。\n2. 使用半步动量进行位置的全步更新：$q_{n+1} = q_n + h\\dot{q}(p_{n+1/2}) = q_n + hp_{n+1/2}$。\n3. 动量的最终半步更新：$p_{n+1} = p_{n+1/2} + \\frac{h}{2}\\dot{p}(q_{n+1}) = p_{n+1/2} - \\frac{h\\omega^2}{2}q_{n+1}$。\n\n为了推导位置变量 $q_n$ 的线性递推关系，我们将动量用位置表示。从第 2 步，我们有 $p_{n+1/2} = \\frac{q_{n+1}-q_n}{h}$。将索引后移一步，得到 $p_{n-1/2} = \\frac{q_n-q_{n-1}}{h}$。动量通常被视为在交错网格上更新。从 $p_{n-1/2}$ 到 $p_{n+1/2}$ 的更新发生在一个完整的时间步长 $h$ 内，并由中间时刻 $t_n$ 的力驱动：\n$$\np_{n+1/2} = p_{n-1/2} + h \\dot{p}(q_n) = p_{n-1/2} - h\\omega^2 q_n\n$$\n将动量的表达式代入此方程，可得：\n$$\n\\frac{q_{n+1}-q_n}{h} = \\frac{q_n-q_{n-1}}{h} - h\\omega^2 q_n\n$$\n两边乘以 $h$ 并整理，得到所需的 $q_n$ 的三项递推关系：\n$$\nq_{n+1} - 2q_n + q_{n-1} = -h^2\\omega^2 q_n\n$$\n$$\nq_{n+1} - (2 - (h\\omega)^2)q_n + q_{n-1} = 0\n$$\n这是一个线性齐次差分方程。我们寻求形式为 $q_n = \\lambda^n$ 的解。将此 ansatz 代入递推关系，得到特征方程：\n$$\n\\lambda^2 - (2 - (h\\omega)^2)\\lambda + 1 = 0\n$$\n这个二次方程的根是离散时间演化算子的特征值。根由以下公式给出：\n$$\n\\lambda_{\\pm} = \\frac{(2 - (h\\omega)^2) \\pm \\sqrt{(2 - (h\\omega)^2)^2 - 4}}{2}\n$$\n为了使数值解是振荡的（稳定的），判别式必须为负，这要求 $(2 - (h\\omega)^2)^2 - 4  0$。这意味着 $-2  2 - (h\\omega)^2  2$。右侧不等式为 $(h\\omega)^2 > 0$，对于 $h, \\omega > 0$ 恒成立。左侧不等式为 $(h\\omega)^2  4$，这给出了蛙跳法著名的类CFL稳定性条件：$h\\omega  2$。对于边界情况 $h\\omega=2$，根是实数且等于 $-1$。对于 $h\\omega > 2$，根是实数，其中一个的模大于 $1$，导致指数增长。\n\n假设稳定性条件 $h\\omega \\le 2$ 成立，特征值为一个共轭复数对 $\\lambda_{\\pm} = e^{\\pm i\\theta}$，其中 $\\theta = h\\tilde{\\omega}$ 是每步的数值相移，$\\tilde{\\omega}$ 是修正角频率。根的和为 $\\lambda_+ + \\lambda_- = e^{i\\theta} + e^{-i\\theta} = 2\\cos(\\theta)$。根据韦达定理应用于特征方程，根的和也为 $2 - (h\\omega)^2$。令两者相等，得到色散关系：\n$$\n2\\cos(h\\tilde{\\omega}) = 2 - (h\\omega)^2 \\implies \\cos(h\\tilde{\\omega}) = 1 - \\frac{(h\\omega)^2}{2}\n$$\n求解 $\\tilde{\\omega}$，得到修正角频率的精确闭式表达式：\n$$\n\\tilde{\\omega} = \\frac{1}{h}\\arccos\\left(1 - \\frac{(h\\omega)^2}{2}\\right)\n$$\n此表达式在 $0  h\\omega \\le 2$ 时有效。单位时间的相误差定义为：\n$$\n\\delta_{\\mathrm{LF}} = \\tilde{\\omega} - \\omega\n$$\n\n接下来，我们分析非辛显式欧拉方法。该系统的一阶矩阵形式为 $\\dot{\\mathbf{z}} = A\\mathbf{z}$，其中 $\\mathbf{z} = \\begin{pmatrix} q \\\\ p \\end{pmatrix}$ 且 $A = \\begin{pmatrix} 0  1 \\\\ -\\omega^2  0 \\end{pmatrix}$。显式欧拉方法由更新规则 $\\mathbf{z}_{n+1} = \\mathbf{z}_n + h \\dot{\\mathbf{z}}_n$ 定义。对于我们的系统，这变为：\n$$\n\\mathbf{z}_{n+1} = \\mathbf{z}_n + hA\\mathbf{z}_n = (I + hA)\\mathbf{z}_n\n$$\n因此，单步放大矩阵为 $M_{\\mathrm{E}} = I + hA$。\n$$\nM_{\\mathrm{E}} = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} + h\\begin{pmatrix} 0  1 \\\\ -\\omega^2  0 \\end{pmatrix} = \\begin{pmatrix} 1  h \\\\ -h\\omega^2  1 \\end{pmatrix}\n$$\n$M_{\\mathrm{E}}$ 的特征值 $\\lambda$ 决定了该方法的稳定性和相位特性。通过求解特征方程 $\\det(M_{\\mathrm{E}} - \\lambda I) = 0$ 来找到它们：\n$$\n\\det\\begin{pmatrix} 1-\\lambda  h \\\\ -h\\omega^2  1-\\lambda \\end{pmatrix} = (1-\\lambda)^2 + h^2\\omega^2 = 0\n$$\n这得到 $(1-\\lambda)^2 = - (h\\omega)^2$，所以 $1-\\lambda = \\pm i h\\omega$。因此，特征值是一个共轭复数对：\n$$\n\\lambda_{\\pm} = 1 \\mp i h\\omega\n$$\n这些特征值的模为 $|\\lambda_{\\pm}| = \\sqrt{1^2 + (\\mp h\\omega)^2} = \\sqrt{1 + (h\\omega)^2}$。由于对于任何 $h,\\omega > 0$ 都有 $|\\lambda_{\\pm}| > 1$，该方法对于谐振子是无条件不稳定的；数值振幅呈指数增长。\n\n问题将每步的有效相角 $\\phi$ 定义为特征值的辐角。为了定义一个明确的正相角，我们选择具有正虚部的特征值 $\\lambda_+ = 1 + i h\\omega$。其辐角为 $\\phi = \\arg(1 + i h\\omega)$。在复平面中，这对应于实部为 $1$、虚部为 $h\\omega$ 的点。该角度由以下公式给出：\n$$\n\\phi = \\arctan(h\\omega)\n$$\n其中 `arctan` 指的是主值，返回一个在 $(-\\pi/2, \\pi/2)$ 范围内的角度。由于 $h\\omega > 0$，$\\phi$ 在 $(0, \\pi/2)$ 内。\n有效角频率 $\\omega_{\\mathrm{E}}$ 由 $\\phi = h\\omega_{\\mathrm{E}}$ 定义。这给出：\n$$\n\\omega_{\\mathrm{E}} = \\frac{\\phi}{h} = \\frac{1}{h}\\arctan(h\\omega)\n$$\n欧拉法的单位时间相误差则定义为：\n$$\n\\delta_{\\mathrm{E}} = \\omega_{\\mathrm{E}} - \\omega\n$$\n这些推导出的 $\\tilde{\\omega}$、$\\delta_{\\mathrm{LF}}$、$\\omega_{\\mathrm{E}}$ 和 $\\delta_{\\mathrm{E}}$ 的公式将用于数值计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of finding modified/effective frequencies and phase errors\n    for leapfrog and explicit Euler integrators for the harmonic oscillator.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (omega, h).\n    test_cases = [\n        (1.0, 0.1),\n        (1.0, 1.999),\n        (10.0, 0.05),\n        (2.0, 1.0),\n    ]\n\n    results = []\n    for omega, h in test_cases:\n        # --- Leapfrog Integrator Calculations ---\n\n        # The modified angular frequency for leapfrog is derived from the\n        # dispersion relation: cos(h*w_tilde) = 1 - 0.5*(h*omega)^2.\n        # This is valid for h*omega = 2.\n        hw = h * omega\n        \n        # Argument for arccos. It is guaranteed to be in [-1, 1] for the test cases.\n        arg_acos = 1.0 - 0.5 * hw**2\n        \n        # np.arccos returns the principal value in [0, pi].\n        # The result is guaranteed to be non-negative.\n        w_tilde = (1.0 / h) * np.arccos(arg_acos)\n        \n        # Phase error per unit time for leapfrog.\n        delta_LF = w_tilde - omega\n        \n        # --- Explicit Euler Integrator Calculations ---\n\n        # The effective angular frequency for explicit Euler is derived from\n        # the argument of its amplification matrix eigenvalues: phi = arctan(h*omega).\n        # w_E = phi / h.\n        w_E = (1.0 / h) * np.arctan(hw)\n        \n        # Phase error per unit time for explicit Euler.\n        delta_E = w_E - omega\n        \n        # Append the four computed values for the current test case.\n        results.extend([w_tilde, w_E, delta_LF, delta_E])\n\n    # Final print statement in the exact required format.\n    # The list 'results' is a flat list of all 16 numbers.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然辛积分器并不精确守恒系统的原始能量，但它们以其出色的长期能量行为而闻名。本练习将模拟一个非线性振子在多个周期内的运动，以观察其特有的有界能量振荡，这与非辛方法中出现的长期漂移形成鲜明对比。通过分析模拟数据，您将把这些实际观测结果与强大的后向误差分析理论联系起来，该理论通过一个守恒的修正哈密顿量的存在来解释这种行为。",
            "id": "4051315",
            "problem": "考虑一个一维哈密顿系统，其哈密顿量定义为 $H(q,p) = \\frac{p^2}{2m} + V(q)$，其中势函数为 $V(q) = \\frac{1}{2}k q^2 + \\alpha q^4$。其正则运动方程由哈密顿方程导出，并定义了保持辛二形式和哈密顿量的精确流。您的任务是研究由离散作用量原理推导的二阶辛变分积分子所产生的数值能量的长时间行为。具体而言，您需要实现一个与离散欧拉-拉格朗日构造一致的位置-动量更新方法，该方法使用对连续拉格朗日量 $L(q,\\dot{q}) = \\frac{1}{2}m \\dot{q}^2 - V(q)$ 的一致二阶近似，然后使用此更新方法对运动进行积分，时长为 $10^4$ 个参考周期。\n\n推导与分析的基本依据：\n- 使用拉格朗日量 $L(q,\\dot{q})$ 的定义和作用量泛函，通过对一个二阶精确的离散拉格朗日量应用驻定作用量原理，从离散作用量中推导出离散运动方程。这必须得到一个二阶的辛、时间可逆格式。\n- 对给定的可分离哈密顿量，使用哈密顿方程来论证流的分解以及辛积分子的性质。\n- 使用后向误差分析（Backward Error Analysis, BEA）的概念来解释有界的能量振荡和修正哈密顿量的近似守恒。BEA被定义为研究一个修正微分方程，该方程的精确流比原始系统的精确流更接近数值方法的结果。\n\n程序要求：\n1. 为可分离哈密顿量 $H(q,p) = \\frac{p^2}{2m} + V(q)$（其中 $V(q) = \\frac{1}{2}k q^2 + \\alpha q^4$）实现一个二阶辛变分积分子。该更新方法必须从离散变分力学的第一性原理推导得出，并且必须是辛和时间可逆的。\n2. 对每个测试案例，计算近似参考周期 $T_0 = 2\\pi \\sqrt{\\frac{m}{k}}$（单位为秒），定义时间步长 $h = \\frac{T_0}{N_{\\text{pp}}}$（单位为秒），其中 $N_{\\text{pp}}$ 表示每个参考周期的步数，并积分 $N_{\\text{per}} = 10^4$ 个参考周期，总积分时间为 $T_{\\text{tot}} = N_{\\text{per}} T_0$（单位为秒）。\n3. 使用 $q(0) = q_0$（单位为米）和 $p(0) = 0$（单位为千克·米/秒）进行初始化。\n4. 在积分过程中，计算每一步的瞬时能量 $H(q(t),p(t))$（单位为焦耳）并记录：\n   - 整个模拟过程中的最大相对能量偏差，定义为 $\\max_{0 \\le t \\le T_{\\text{tot}}} \\left| \\frac{H(t) - H(0)}{H(0)} \\right|$（无量纲小数）。\n   - 能量的归一化线性漂移率，计算方法为 $H(t)$ 相对于 $t$ 的最小二乘线性拟合的斜率除以 $H(0)$，其单位为反秒。具体来说，如果最小二乘斜率为 $s$（单位为焦耳/秒），则报告 $\\frac{s}{H(0)}$（单位为反秒）。\n5. 定性解释观测到的振荡和微小漂移率如何与后向误差分析（BEA）相关。BEA预测存在一个修正哈密顿量 $\\tilde{H} = H + h^2 \\Delta H + \\mathcal{O}(h^4)$，它被二阶辛格式近似守恒，其能量误差的振荡幅度与 $\\mathcal{O}(h^2)$ 成比例。\n\n物理和数值单位：\n- 能量以焦耳报告，时间以秒，质量以千克，位置以米，刚度以牛顿/米，$\\alpha$ 以牛顿/米的三次方。\n- 漂移率必须以反秒报告。\n- 任何分数量必须表示为小数。\n\n测试套件：\n使用以下四个科学合理的测试案例，以覆盖谐振、弱非线性、接近稳定性边界的粗步长以及细步长等情况。对于所有测试案例，将参考周期数设置为 $N_{\\text{per}} = 10^4$。\n- 案例 $1$ (谐振基线): $m = 1.0$ 千克, $k = 1.0$ 牛顿/米, $\\alpha = 0.0$ 牛顿/米的三次方, $q_0 = 0.2$ 米, $N_{\\text{pp}} = 20$。\n- 案例 $2$ (弱非线性中等步长): $m = 1.0$ 千克, $k = 1.0$ 牛顿/米, $\\alpha = 0.01$ 牛顿/米的三次方, $q_0 = 0.2$ 米, $N_{\\text{pp}} = 20$。\n- 案例 $3$ (弱非线性粗步长，接近稳定性边界): $m = 1.0$ 千克, $k = 1.0$ 牛顿/米, $\\alpha = 0.01$ 牛顿/米的三次方, $q_0 = 0.2$ 米, $N_{\\text{pp}} = 4$。\n- 案例 $4$ (较强非线性细步长): $m = 1.0$ 千克, $k = 1.0$ 牛顿/米, $\\alpha = 0.05$ 牛顿/米的三次方, $q_0 = 0.3$ 米, $N_{\\text{pp}} = 100$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素是对应测试案例的一个双元素列表。每个双元素列表必须按 [最大相对能量偏差, 归一化线性漂移率（单位为反秒）] 的顺序排列。例如，输出应类似于 $[[x_1,y_1],[x_2,y_2],[x_3,y_3],[x_4,y_4]]$，其中值为小数。",
            "solution": "所述问题在科学上是合理的、自洽的且适定的。它提出了计算动力学中的一个标准任务：使用辛数值方法对守恒哈密顿系统进行长期积分。所有参数、初始条件和分析要求都已明确指定。其基本原理——哈密顿力学、离散变分原理和后向误差分析——是该领域的基石。因此，我将进行完整的推导和求解。\n\n目标是为一维非线性振子实现一个二阶辛变分积分子，并分析其长期能量守恒特性。该系统由可分离哈密顿量 $H(q,p) = T(p) + V(q)$ 描述，其中动能为 $T(p) = \\frac{p^2}{2m}$，势能为 $V(q) = \\frac{1}{2}k q^2 + \\alpha q^4$。\n\n如果一个数值方法可以从哈密顿驻定作用量原理的离散版本推导出来，则称其为变分方法。连续作用量泛函为 $S[q] = \\int L(q(t), \\dot{q}(t)) dt$，其中拉格朗日量为 $L = T - V$。我们构造一个离散拉格朗日量 $L_d(q_n, q_{n+1})$，它近似于 $\\int_{t_n}^{t_{n+1}} L(q(t), \\dot{q}(t)) dt$。一种常见的二阶精确选择是对速度使用有限差分，对势能使用梯形法则，得到：\n$$\nL_d(q_n, q_{n+1}) = h \\left[ \\frac{1}{2}m \\left(\\frac{q_{n+1}-q_n}{h}\\right)^2 - \\frac{1}{2}\\left(V(q_n) + V(q_{n+1})\\right) \\right]\n$$\n离散作用量是其总和 $S_d = \\sum_n L_d(q_n, q_{n+1})$。对于在端点处消失的变分 $\\delta q_n$，驻定作用量原理 $\\delta S_d = 0$ 导出离散欧拉-拉格朗日方程：\n$$\n\\frac{\\partial L_d(q_{n-1}, q_n)}{\\partial q_n} + \\frac{\\partial L_d(q_n, q_{n+1})}{\\partial q_n} = 0\n$$\n计算偏导数：\n$$\n\\frac{\\partial L_d(q_{n-1}, q_n)}{\\partial q_n} = \\frac{m}{h}(q_n - q_{n-1}) - \\frac{h}{2} V'(q_n)\n$$\n$$\n\\frac{\\partial L_d(q_n, q_{n+1})}{\\partial q_n} = -\\frac{m}{h}(q_{n+1} - q_n) - \\frac{h}{2} V'(q_n)\n$$\n将这些代入离散欧拉-拉格朗日方程可得：\n$$\n\\frac{m}{h}(q_n - q_{n-1}) - \\frac{h}{2} V'(q_n) - \\frac{m}{h}(q_{n+1} - q_n) - \\frac{h}{2} V'(q_n) = 0\n$$\n整理各项可得到著名的 Störmer-Verlet（或位置Verlet）算法：\n$$\nm \\frac{q_{n+1} - 2q_n + q_{n-1}}{h^2} = -V'(q_n) = F(q_n)\n$$\n其中 $F(q) = -V'(q)$ 是力。虽然这种形式很优雅，但它是一个关于位置的三项递推关系，并且没有显式地使用动量变量 $p$。对于相空间分析，使用“速度Verlet”格式是等价的，并且通常更方便，它是一种在 $(q, p)$ 空间中的单步法。该算法通过分解Liouville算子推导得出，并且已知是辛的。通过定义一个中间动量可以证明其等价性。给定系统的速度Verlet算法如下：\n1. 动量的第一步半踢： $p_{n+1/2} = p_n - \\frac{h}{2} \\frac{\\partial V}{\\partial q}(q_n) = p_n + \\frac{h}{2} F(q_n)$\n2. 位置的整步漂移： $q_{n+1} = q_n + h \\frac{\\partial T}{\\partial p}(p_{n+1/2}) = q_n + \\frac{h}{m} p_{n+1/2}$\n3. 动量的第二步半踢： $p_{n+1} = p_{n+1/2} - \\frac{h}{2} \\frac{\\partial V}{\\partial q}(q_{n+1}) = p_{n+1/2} + \\frac{h}{2} F(q_{n+1})$\n\n这个积分子是显式定义的、二阶精确的、时间可逆的，最重要的是，它是辛的。辛性意味着数值流映射 $\\Phi_h: (q_n, p_n) \\to (q_{n+1}, p_{n+1})$ 保持辛二形式 $dq \\wedge dp$ 不变。此性质是该积分子具有优异长期行为的原因。\n\n观测到的数值结果——有界的能量振荡和可忽略的长期能量漂移——是辛积分子的典型特征，并可通过后向误差分析（BEA）进行严格解释。BEA指出，由辛积分子生成的数值解，虽然不在原始哈密顿量 $H$ 的精确轨道上，但它确实位于一个邻近的、修正哈密顿量 $\\tilde{H}$ 的精确轨道上。对于像速度Verlet这样的二阶、时间可逆格式，这个修正哈密顿量具有一个关于时间步长 $h$ 的偶数次幂的渐近展开：\n$$\n\\tilde{H}(q,p,h) = H(q,p) + h^2 H_2(q,p) + h^4 H_4(q,p) + \\mathcal{O}(h^6)\n$$\n数值积分子在指数级长的时间内以非常高的精度（通常达到机器精度）保持 $\\tilde{H}$ 守恒。因此，沿着数值轨道 $(q_n, p_n)$，我们有 $\\tilde{H}(q_n, p_n) \\approx \\text{constant}$。\n我们计算的能量是原始能量 $H(q_n, p_n)$。从展开式中，我们可以写出：\n$$\nH(q_n, p_n) \\approx \\tilde{H}(q_n, p_n) - h^2 H_2(q_n, p_n)\n$$\n由于 $\\tilde{H}$ 近似恒定，原始能量 $H$ 随时间的变化主要由 $-h^2 H_2(q_n, p_n)$ 项决定。随着系统的演化，点 $(q_n, p_n)$ 遍历其相空间轨道，导致 $H_2(q_n, p_n)$ 发生振荡。因此，测得的能量 $H(q_n, p_n)$ 表现出围绕一个恒定值的有界振荡。这些振荡的振幅与 $\\mathcal{O}(h^2)$ 成比例。这解释了为什么最大相对能量偏差不会随时间增长，而是保持有界。\n\n在 $\\tilde{H}$ 的展开式中缺少 $h$ 的奇数次幂（例如 $h^1, h^3$），是积分子时间可逆性的直接结果。这一点至关重要，因为它消除了会导致能量出现长期（或线性）漂移的项。在模拟中观测到的任何残余线性漂移，都可归因于展开式中非常高阶项的影响，以及更实际地，数百万步中浮点舍入误差的累积。对于一个分辨率充分的模拟（$h$ 足够小），这种漂移预计会非常小，这一点将由计算出的接近于零的归一化线性漂移率所证实。所提供的测试案例将展示这些特性：较大的步长（案例3）将导致更大但仍有界的能量振荡，而较小的步长（案例4）将显示出小得多的振荡。谐振情况（案例1）作为基线，而非线性情况则展示了该方法的鲁棒性。\n\n数值实现将遵循速度Verlet算法。对于每个测试案例，我们初始化 $(q_0, p_0 = 0)$，根据 $T_0 = 2\\pi\\sqrt{m/k}$、$h=T_0/N_{\\text{pp}}$ 和 $T_{\\text{tot}} = N_{\\text{per}} T_0$ 计算总步数。在每一步，我们记录时间 $t$ 和哈密顿量的值 $H(q(t), p(t))$。最后，我们计算最大相对能量偏差和对能量时间序列进行线性拟合的归一化斜率。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of integrating a nonlinear oscillator using a symplectic\n    integrator and analyzing its energy conservation properties.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (harmonic baseline)\n        {'m': 1.0, 'k': 1.0, 'alpha': 0.0, 'q0': 0.2, 'N_pp': 20},\n        # Case 2 (weakly nonlinear moderate step)\n        {'m': 1.0, 'k': 1.0, 'alpha': 0.01, 'q0': 0.2, 'N_pp': 20},\n        # Case 3 (weakly nonlinear coarse step near stability boundary)\n        {'m': 1.0, 'k': 1.0, 'alpha': 0.01, 'q0': 0.2, 'N_pp': 4},\n        # Case 4 (stronger nonlinearity fine step)\n        {'m': 1.0, 'k': 1.0, 'alpha': 0.05, 'q0': 0.3, 'N_pp': 100},\n    ]\n\n    # Universal simulation parameter\n    N_per = 10000\n\n    results = []\n    \n    for case in test_cases:\n        m = case['m']\n        k = case['k']\n        alpha = case['alpha']\n        q0 = case['q0']\n        N_pp = case['N_pp']\n        \n        # Initial conditions\n        q = q0\n        p = 0.0\n        \n        # Simulation time parameters\n        # For k=0, T0 is undefined. The problem guarantees k > 0.\n        T0 = 2.0 * np.pi * np.sqrt(m / k)\n        h = T0 / N_pp\n        total_steps = int(N_per * N_pp)\n        \n        # Define the force and Hamiltonian functions\n        def force(pos):\n            return -(k * pos + 4.0 * alpha * pos**3)\n\n        def hamiltonian(pos, mom):\n            V = 0.5 * k * pos**2 + alpha * pos**4\n            T = 0.5 * mom**2 / m\n            return T + V\n\n        # Store initial energy\n        H0 = hamiltonian(q, p)\n        if H0 == 0:\n            # Avoid division by zero, although not expected for given cases.\n            # In this case, relative error is ill-defined.\n            # Let's set results to NaN to indicate a problem.\n            results.append([np.nan, np.nan])\n            continue\n\n        # Arrays to store time and energy history for analysis\n        energy_history = np.zeros(total_steps + 1)\n        time_history = np.zeros(total_steps + 1)\n        \n        energy_history[0] = H0\n        time_history[0] = 0.0\n\n        # Main integration loop using Velocity Verlet algorithm\n        for i in range(total_steps):\n            # 1. First half-kick for momentum\n            p_half = p + 0.5 * h * force(q)\n            \n            # 2. Full drift for position\n            q = q + h * p_half / m\n            \n            # 3. Second half-kick for momentum\n            p = p_half + 0.5 * h * force(q)\n            \n            # Store results\n            current_time = (i + 1) * h\n            current_energy = hamiltonian(q, p)\n            time_history[i+1] = current_time\n            energy_history[i+1] = current_energy\n\n        # Post-simulation analysis\n        # 1. Maximum relative energy deviation\n        # The deviation is |H(t) - H(0)| / |H(0)| since H(0) can be negative\n        # but in this problem, H(0) is always positive.\n        rel_energy_dev = np.abs((energy_history - H0) / H0)\n        max_rel_dev = np.max(rel_energy_dev)\n        \n        # 2. Normalized linear drift rate\n        # Perform a linear least-squares fit of H(t) vs t\n        # polyfit returns [slope, intercept]\n        slope, _ = np.polyfit(time_history, energy_history, 1)\n        normalized_drift = slope / H0\n        \n        results.append([max_rel_dev, normalized_drift])\n\n    # Final print statement in the exact required format.\n    # Format each number to avoid ambiguity, e.g., using scientific notation\n    # for small numbers.\n    formatted_results = []\n    for res_pair in results:\n        formatted_pair = f\"[{res_pair[0]:.8e},{res_pair[1]:.8e}]\"\n        formatted_results.append(formatted_pair)\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "辛映射的定义性特征是其保持辛二形式，这一条件可由矩阵方程 $J^T \\Omega J = \\Omega$ 来概括。本实践将从观察辛性的结果转向直接验证其属性。您将开发一个数值工具来近似计算一个“黑箱”积分器的雅可比矩阵并计算其辛性缺陷，从而提供一种强大的、动手的诊断方法，用以判断一个实现是否真正保持了系统的几何结构。",
            "id": "4051312",
            "problem": "考虑一个 $2n$ 维的正则哈密顿动力学系统，由位置坐标 $q \\in \\mathbb{R}^{n}$ 和动量坐标 $p \\in \\mathbb{R}^{n}$ 定义，并汇集成一个单一的状态向量 $z = (q,p) \\in \\mathbb{R}^{2n}$。$z$ 的演化由给定哈密顿量 $H(q,p)$ 推导出的哈密顿方程决定，即 $\\dot{q} = \\partial H / \\partial p$ 和 $\\dot{p} = - \\partial H / \\partial q$。正则辛形式由常数矩阵 $\\Omega \\in \\mathbb{R}^{2n \\times 2n}$ 表示，其分块结构为\n$$\n\\Omega = \\begin{bmatrix} 0  I_n \\\\ -I_n  0 \\end{bmatrix},\n$$\n其中 $I_n$ 表示 $n \\times n$ 的单位矩阵。一个离散时间单步积分器 $\\Phi_h : \\mathbb{R}^{2n} \\to \\mathbb{R}^{2n}$，映射 $z_{k+1} = \\Phi_h(z_k)$，时间步长为 $h$，如果其雅可比矩阵 $J(z) = D\\Phi_h(z)$ 对所有 $z$ 都满足辛条件\n$$\nJ(z)^{\\top}\\,\\Omega\\,J(z) = \\Omega\n$$\n则称该积分器是保辛的。\n\n从这些基本定义出发，设计并实现一个数值程序。对于给定的黑箱单步映射 $\\Phi_h$ 和哈密顿量 $H(q,p)$，该程序通过使用中心有限差分近似雅可比矩阵 $J(z)$，然后计算残差矩阵 $J(z)^{\\top} \\Omega J(z) - \\Omega$ 的弗罗贝尼烏斯范数，来检验在点 $z$ 处的保辛性。矩阵 $A$ 的弗罗贝尼烏斯范数定义为 $\\|A\\|_F = \\sqrt{\\sum_{i,j} A_{ij}^2}$。\n\n您的程序必须：\n\n- 适用于二维空间（$n=2$）中的特定可分哈密顿量，该哈密顿量在计算聚变科学与工程中被广泛用作磁约束系统中线性化粒子运动的无量纲模型：\n$$\nH(q,p) = T(p) + V(q), \\quad T(p) = \\frac{1}{2m}\\,\\|p\\|^2, \\quad V(q) = \\frac{1}{2}\\,m\\,\\omega^2\\,\\|q\\|^2,\n$$\n其中参数 $m > 0$ 和 $\\omega > 0$。\n- 为此哈密顿量实现两个黑箱积分器：\n  1. 一个保辛的 Störmer–Verlet 方法（踢-漂移-踢分裂），使用上面给出的 $T(p)$ 和 $V(q)$。\n  2. 一个非保辛的显式欧拉方法，使用相同的 $T(p)$ 和 $V(q)$。\n- 对于给定的 $z$ 和步长 $h$，使用中心有限差分近似 $J(z)$：对于第 $i$ 个标准基向量 $e_i \\in \\mathbb{R}^{4}$，计算 $J$ 的第 $i$ 列为\n$$\nJ_{:,i} \\approx \\frac{\\Phi_h(z + \\varepsilon e_i) - \\Phi_h(z - \\varepsilon e_i)}{2\\varepsilon},\n$$\n其中 $\\varepsilon > 0$ 是一个小的有限差分增量。然后计算标量残差\n$$\nr(z; h, \\varepsilon) = \\left\\| J(z)^{\\top}\\,\\Omega\\,J(z) - \\Omega \\right\\|_F.\n$$\n- 生成的结果为浮点数，不带物理单位，因为在此设置中所有变量和参数都是无量纲的。\n\n测试套件规范：\n\n使用 $n=2$，因此 $z \\in \\mathbb{R}^{4}$，其中 $q = (q_1,q_2)$ 和 $p = (p_1,p_2)$。对于下面的每个测试用例，评估残差 $r(z; h, \\varepsilon)$ 并返回它。\n\n定义以下八个测试用例，每个测试用例由一个元组 $(\\text{method}, m, \\omega, h, \\varepsilon, z)$ 组成：\n1. $(\\text{SV}, 1.0, 1.0, 0.1, 10^{-6}, (q=(1.0,-0.5), p=(0.3,1.2)))$，其中 $\\text{SV}$ 表示 Störmer–Verlet 方法。\n2. $(\\text{EE}, 1.0, 1.0, 0.1, 10^{-6}, (q=(1.0,-0.5), p=(0.3,1.2)))$，其中 $\\text{EE}$ 表示显式欧拉方法。\n3. $(\\text{SV}, 1.0, 1.0, 1.0, 10^{-6}, (q=(1.0,-0.5), p=(0.3,1.2)))$。\n4. $(\\text{EE}, 1.0, 1.0, 1.0, 10^{-6}, (q=(1.0,-0.5), p=(0.3,1.2)))$。\n5. $(\\text{SV}, 1.0, 10.0, 0.05, 10^{-6}, (q=(0.2, -0.1), p=(0.05, 0.3)))$。\n6. $(\\text{EE}, 1.0, 10.0, 0.05, 10^{-6}, (q=(0.2, -0.1), p=(0.05, 0.3)))$。\n7. $(\\text{SV}, 1.0, 1.0, 0.1, 10^{-6}, (q=(0.0, 0.0), p=(0.0, 0.0)))$，以探究在平衡点处的行为。\n8. $(\\text{SV}, 1.0, 1.0, 0.1, 10^{-3}, (q=(1.0,-0.5), p=(0.3,1.2)))$，以评估对较大有限差分增量的敏感性。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含按上述顺序排列的八个残差，形式为方括号内以逗号分隔的列表。例如，输出格式必须完全如下所示：\n$[r_1,r_2,r_3,r_4,r_5,r_6,r_7,r_8]$,\n其中每个 $r_i$ 是对应于测试用例 $i$ 的一个浮点数。除了浮点数的标准字符串格式化所隐含的内容外，不应打印任何额外的文本或空格。",
            "solution": "该问题要求设计并实现一个数值测试，用于检验正则哈密顿系统单步积分器的保辛性。这涉及到定义系统、积分器和测试过程本身。\n\n所考虑的系统是一个 $2n$ 维的正则哈密顿系统，其状态向量为 $z=(q,p)$，其中 $q \\in \\mathbb{R}^n$ 是位置坐标，$p \\in \\mathbb{R}^n$ 是动量坐标。对于给定的哈密顿量 $H(q,p)$，其动力学由哈密顿方程 $\\dot{q} = \\partial H / \\partial p$ 和 $\\dot{p} = - \\partial H / \\partial q$ 决定。问题指定了一个用于二维谐振子（$n=2$）的可分哈密顿量，这是物理学中的一个基本模型，包括用于磁约束装置中线性化粒子运动的模型。该哈密顿量是：\n$$\nH(q,p) = T(p) + V(q) = \\frac{1}{2m} \\|p\\|^2 + \\frac{1}{2} m \\omega^2 \\|q\\|^2\n$$\n这里，$q=(q_1, q_2)$，$p=(p_1, p_2)$，$m > 0$ 是质量，$\\omega > 0$ 是角频率。所有量都是无量纲的。相应的运动方程是：\n$$\n\\dot{q} = \\frac{\\partial H}{\\partial p} = \\frac{p}{m}\n$$\n$$\n\\dot{p} = -\\frac{\\partial H}{\\partial q} = -m \\omega^2 q\n$$\n完整的状态向量是 $z = (q_1, q_2, p_1, p_2) \\in \\mathbb{R}^4$。\n\n单步数值积分器是一个映射 $\\Phi_h: \\mathbb{R}^{2n} \\to \\mathbb{R}^{2n}$，它近似系统在时间步长 $h$ 内的流，使得 $z_{k+1} = \\Phi_h(z_k)$。如果映射的雅可比矩阵 $J(z) = D\\Phi_h(z)$ 对所有 $z$ 都满足条件 $J(z)^\\top \\Omega J(z) = \\Omega$，则该映射是保辛的，其中 $\\Omega$ 是正则辛矩阵。对于 $n=2$，$\\Omega$ 是 $4 \\times 4$ 矩阵：\n$$\n\\Omega = \\begin{bmatrix} 0_2  I_2 \\\\ -I_2  0_2 \\end{bmatrix} = \\begin{pmatrix} 0  0  1  0 \\\\ 0  0  0  1 \\\\ -1  0  0  0 \\\\ 0  -1  0  0 \\end{pmatrix}\n$$\n其中 $I_2$ 是 $2 \\times 2$ 单位矩阵，$0_2$ 是 $2 \\times 2$ 零矩阵。\n\n我们必须为此系统实现两个积分器。\n\n1.  **显式欧拉 (EE) 方法**：这是一种一阶、非保辛的方法。更新规则通过对时间导数进行前向差分近似得到：$z_{k+1} = z_k + h \\dot{z}_k$。\n    $$\n    q_{k+1} = q_k + h \\dot{q}_k = q_k + \\frac{h}{m} p_k\n    $$\n    $$\n    p_{k+1} = p_k + h \\dot{p}_k = p_k - h m \\omega^2 q_k\n    $$\n\n2.  **Störmer–Verlet (SV) 方法**：对于可分哈密顿量，此方法通过算子分裂构建。指定的“踢-漂移-踢”方案对应于形式为 $\\Phi_h = \\Phi_{h/2}^V \\circ \\Phi_h^T \\circ \\Phi_{h/2}^V$ 的二阶 Strang 分裂，其中 $\\Phi_h^V$ 是在势能部分 $V(q)$ 下的精确流，$\\Phi_h^T$ 是在动能部分 $T(p)$ 下的精确流。\n    操作顺序如下：\n    -   **踢 ($h/2$)**：使用来自势能的力，更新动量半个时间步长。\n        $$ p_{k+1/2} = p_k - \\frac{h}{2} \\nabla_q V(q_k) = p_k - \\frac{h}{2} m \\omega^2 q_k $$\n    -   **漂移 ($h$)**：使用新的动量，更新位置一个完整的时间步长。\n        $$ q_{k+1} = q_k + h \\nabla_p T(p_{k+1/2}) = q_k + h \\frac{p_{k+1/2}}{m} $$\n    -   **踢 ($h/2$)**：再次使用在新位置上的力，更新动量另外半个时间步长。\n        $$ p_{k+1} = p_{k+1/2} - \\frac{h}{2} \\nabla_q V(q_{k+1}) = p_{k+1/2} - \\frac{h}{2} m \\omega^2 q_{k+1} $$\n    已知此方法对于可分哈密顿量是精确保辛的。\n\n任务的核心是通过计算残差 $r = \\| J^\\top \\Omega J - \\Omega \\|_F$来数值验证保辛性，其中 $\\|\\cdot\\|_F$ 是弗罗贝尼烏斯范数。雅可比矩阵 $J(z)$ 使用中心有限差分进行近似。$J$ 的第 $j$ 列由以下公式给出：\n$$\nJ_{:,j} \\approx \\frac{\\Phi_h(z + \\varepsilon e_j) - \\Phi_h(z - \\varepsilon e_j)}{2\\varepsilon}\n$$\n其中 $e_j$ 是 $\\mathbb{R}^4$ 中的第 $j$ 个标准基向量，$\\varepsilon$ 是一个小的微扰。\n\n对于这个特定问题，一个关键的观察是哈密顿量是二次的，这使得哈密顿方程是线性的。因此，显式欧拉和 Störmer-Verlet 积分器都是线性映射，即它们可以写成 $z_{k+1} = M z_k$ 的形式，其中 $M$ 是某个常数矩阵。对于这样的线性映射，雅可比矩阵是常数，$J(z)=M$，并且用于雅可比矩阵的中心差分公式是精确的，与 $\\varepsilon$ 的值无关（前提是 $\\varepsilon$ 不会小到引起浮点相消误差）。\n$$\n\\frac{\\Phi_h(z + \\varepsilon e_j) - \\Phi_h(z - \\varepsilon e_j)}{2\\varepsilon} = \\frac{M(z + \\varepsilon e_j) - M(z - \\varepsilon e_j)}{2\\varepsilon} = \\frac{Mz + \\varepsilon M e_j - Mz + \\varepsilon M e_j}{2\\varepsilon} = M e_j = J_{:,j}\n$$\n因此，我们的数值测试将以非常高的精度计算雅可比矩阵，仅受机器精度的限制。\n\n对于显式欧拉方法，我们可以解析地计算残差。映射矩阵为 $J_{EE} = \\begin{pmatrix} I_2  (h/m)I_2 \\\\ -hm\\omega^2 I_2  I_2 \\end{pmatrix}$。残差矩阵为 $J_{EE}^\\top \\Omega J_{EE} - \\Omega = \\begin{pmatrix} 0_2  h^2\\omega^2 I_2 \\\\ -h^2\\omega^2 I_2  0_2 \\end{pmatrix}$。该矩阵的弗罗贝尼烏斯范数为 $\\|R\\|_F = \\sqrt{2n (h^2\\omega^2)^2} = \\sqrt{2(2)} (h^2\\omega^2) = 2h^2\\omega^2$。\n\n对于 Störmer-Verlet 方法，积分器是精确保辛的，这意味着其雅可比矩阵 $J_{SV}$ 满足 $J_{SV}^\\top \\Omega J_{SV} = \\Omega$。由于我们的数值方法可以精确计算雅可比矩阵（在浮点误差范围内），计算出的残差范数应该在机器精度（例如，约 $10^{-15}$）的量级上。与非保辛欧拉方法的残差相比，这个值应该非常小，并且基本上对参数 $h, \\omega, \\varepsilon$ 和点 $z$ 的选择不敏感。数值程序将为指定的测试用例计算这些残差。",
            "answer": "```python\nimport numpy as np\n\ndef euler_step(z, h, m, omega):\n    \"\"\"\n    Performs one step of the explicit Euler method.\n\n    Args:\n        z (np.ndarray): State vector [q1, q2, p1, p2].\n        h (float): Time step.\n        m (float): Mass parameter.\n        omega (float): Frequency parameter.\n\n    Returns:\n        np.ndarray: The new state vector.\n    \"\"\"\n    q, p = z[:2], z[2:]\n    q_next = q + (h / m) * p\n    p_next = p - h * m * (omega**2) * q\n    return np.concatenate([q_next, p_next])\n\ndef verlet_step(z, h, m, omega):\n    \"\"\"\n    Performs one step of the Störmer-Verlet (velocity Verlet) method.\n\n    Args:\n        z (np.ndarray): State vector [q1, q2, p1, p2].\n        h (float): Time step.\n        m (float): Mass parameter.\n        omega (float): Frequency parameter.\n\n    Returns:\n        np.ndarray: The new state vector.\n    \"\"\"\n    q, p = z[:2], z[2:]\n    \n    # Kick (half step)\n    force_q = -m * (omega**2) * q\n    p_half = p + (h / 2.0) * force_q\n    \n    # Drift (full step)\n    velocity_phalf = p_half / m\n    q_next = q + h * velocity_phalf\n    \n    # Kick (half step)\n    force_q_next = -m * (omega**2) * q_next\n    p_next = p_half + (h / 2.0) * force_q_next\n    \n    return np.concatenate([q_next, p_next])\n\ndef compute_residual(integrator_func, z0, h, m, omega, eps):\n    \"\"\"\n    Computes the symplecticity residual for a given integrator.\n\n    Args:\n        integrator_func (function): The one-step integrator (euler_step or verlet_step).\n        z0 (np.ndarray): The state vector at which to test.\n        h (float): Time step.\n        m (float): Mass parameter.\n        omega (float): Frequency parameter.\n        eps (float): Finite difference increment.\n\n    Returns:\n        float: The Frobenius norm of the residual matrix.\n    \"\"\"\n    dim = 4\n    J = np.zeros((dim, dim))\n    Omega = np.array([[0, 0, 1, 0], \n                      [0, 0, 0, 1], \n                      [-1, 0, 0, 0], \n                      [0, -1, 0, 0]])\n\n    # Approximate Jacobian using central finite differences\n    for j in range(dim):\n        e_j = np.zeros(dim)\n        e_j[j] = 1.0\n        \n        z_plus = z0 + eps * e_j\n        z_minus = z0 - eps * e_j\n        \n        phi_plus = integrator_func(z_plus, h, m, omega)\n        phi_minus = integrator_func(z_minus, h, m, omega)\n        \n        J[:, j] = (phi_plus - phi_minus) / (2 * eps)\n\n    # Compute the residual matrix and its Frobenius norm\n    residual_matrix = J.T @ Omega @ J - Omega\n    residual_norm = np.linalg.norm(residual_matrix, 'fro')\n    \n    return residual_norm\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (method, m, omega, h, eps, z)\n        ('SV', 1.0, 1.0, 0.1, 1e-6, np.array([1.0, -0.5, 0.3, 1.2])),\n        ('EE', 1.0, 1.0, 0.1, 1e-6, np.array([1.0, -0.5, 0.3, 1.2])),\n        ('SV', 1.0, 1.0, 1.0, 1e-6, np.array([1.0, -0.5, 0.3, 1.2])),\n        ('EE', 1.0, 1.0, 1.0, 1e-6, np.array([1.0, -0.5, 0.3, 1.2])),\n        ('SV', 1.0, 10.0, 0.05, 1e-6, np.array([0.2, -0.1, 0.05, 0.3])),\n        ('EE', 1.0, 10.0, 0.05, 1e-6, np.array([0.2, -0.1, 0.05, 0.3])),\n        ('SV', 1.0, 1.0, 0.1, 1e-6, np.array([0.0, 0.0, 0.0, 0.0])),\n        ('SV', 1.0, 1.0, 0.1, 1e-3, np.array([1.0, -0.5, 0.3, 1.2])),\n    ]\n\n    integrator_map = {\n        'SV': verlet_step,\n        'EE': euler_step\n    }\n\n    results = []\n    for case in test_cases:\n        method_name, m, omega, h, eps, z0 = case\n        integrator_func = integrator_map[method_name]\n        \n        residual = compute_residual(integrator_func, z0, h, m, omega, eps)\n        results.append(residual)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}