{
    "hands_on_practices": [
        {
            "introduction": "The first step in appreciating symplectic integrators is to see how they differ from simpler methods on a fundamental level. For oscillatory systems, a key metric of performance is how well an integrator preserves the phase of the motion over long times. This practice  has you contrast the symplectic Leapfrog method with the non-symplectic explicit Euler method on the quintessential harmonic oscillator, revealing how symplectic schemes preserve the geometric character of the flow. You will derive and observe that this manifests as a slightly modified, but stable, oscillation frequency, a stark contrast to the artificial energy growth and phase inaccuracies introduced by the simpler scheme.",
            "id": "4051345",
            "problem": "Consider the one-degree-of-freedom Hamiltonian harmonic oscillator with Hamiltonian $H(q,p) = \\tfrac{1}{2}\\big(p^{2} + \\omega^{2} q^{2}\\big)$, where $q$ and $p$ are canonical position and momentum, respectively, and $\\omega \\gt 0$ is the true angular frequency. The equations of motion are Hamilton's equations $\\dot{q} = \\partial H / \\partial p$ and $\\dot{p} = - \\partial H / \\partial q$, which yield the linear system $\\dot{q} = p$ and $\\dot{p} = - \\omega^{2} q$. Such linear oscillatory dynamics arise as local models in charged-particle orbit calculations in magnetized plasmas relevant to computational fusion science and engineering, where long-time fidelity of geometric structure is essential.\n\nYou are to apply the symplectic leapfrog (also known as Störmer–Verlet) integrator with time step $h \\gt 0$ to this system, and derive the method's modified angular frequency $\\tilde{\\omega}$ such that one step of the method advances the solution by an effective phase angle $\\theta = h \\tilde{\\omega}$ satisfying the discrete dispersion relation of the method. Separately, apply the non-symplectic explicit Euler method with the same $h$ to the same first-order system and determine its effective angular frequency $\\omega_{\\mathrm{E}}$ in the sense that one step of explicit Euler advances the state by a complex eigenvalue whose argument is an angle $\\phi = h \\,\\omega_{\\mathrm{E}}$. Use radians for all angles and angular frequencies, and seconds for time.\n\nStarting only from the fundamental definitions above and from the algorithmic description of the two methods (leapfrog as the canonical half-step momentum update, full-step position update, half-step momentum update; explicit Euler as the forward one-step explicit method on the first-order system), perform the following tasks:\n\n- Derive the linear recurrence for the position variable $q_{n}$ satisfied by the leapfrog integrator and, from it, obtain the exact closed-form expression of the modified frequency $\\tilde{\\omega}$ as a function of $\\omega$ and $h$. Define the leapfrog phase error per unit time as $\\delta_{\\mathrm{LF}} = \\tilde{\\omega} - \\omega$ (in radians per second).\n- Derive the one-step amplification matrix of the explicit Euler method, determine its eigenvalues, define the effective per-step phase angle $\\phi$ as the argument of the eigenvalues, and obtain the exact closed-form expression of $\\omega_{\\mathrm{E}} = \\phi / h$ as a function of $\\omega$ and $h$. Define the Euler phase error per unit time as $\\delta_{\\mathrm{E}} = \\omega_{\\mathrm{E}} - \\omega$ (in radians per second).\n\nYour program must compute, for each test case below, the tuple of four real numbers $(\\tilde{\\omega}, \\omega_{\\mathrm{E}}, \\delta_{\\mathrm{LF}}, \\delta_{\\mathrm{E}})$, all expressed in radians per second. Use the exact analytic formulas you derived; do not estimate phases from simulated trajectories.\n\nAngle unit requirement: all angles are in radians. Physical unit requirement: all angular frequencies and phase errors must be given in radians per second.\n\nTest suite (each case is a pair $(\\omega, h)$ with $\\omega$ in radians per second and $h$ in seconds):\n\n- Case $1$: $(\\omega, h) = (\\,1.0,\\, 0.1\\,)$.\n- Case $2$: $(\\omega, h) = (\\,1.0,\\, 1.999\\,)$.\n- Case $3$: $(\\omega, h) = (\\,10.0,\\, 0.05\\,)$.\n- Case $4$: $(\\omega, h) = (\\,2.0,\\, 1.0\\,)$.\n\nDesign-for-coverage rationale: Case $1$ is a small-step \"happy path\"; Case $2$ probes the leapfrog stability edge $h\\,\\omega \\lesssim 2$; Case $3$ tests a high-frequency oscillator with a moderate Courant-like number $h\\,\\omega$; Case $4$ sits at the leapfrog stability boundary $h\\,\\omega = 2$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case in the order listed above, append the four values $(\\tilde{\\omega}, \\omega_{\\mathrm{E}}, \\delta_{\\mathrm{LF}}, \\delta_{\\mathrm{E}})$, in that order, resulting in a flat list of $16$ floating-point numbers. For example, the output must have the form\n\"[wtilde1,wE1,dLF1,dE1,wtilde2,wE2,dLF2,dE2,wtilde3,wE3,dLF3,dE3,wtilde4,wE4,dLF4,dE4]\".",
            "solution": "The problem statement requires the derivation and computation of the modified and effective angular frequencies for the symplectic leapfrog and explicit Euler methods, respectively, as applied to the one-degree-of-freedom simple harmonic oscillator.\n\nThe system is defined by the Hamiltonian $H(q,p) = \\frac{1}{2}(p^2 + \\omega^2 q^2)$, with $\\omega > 0$. The equations of motion are Hamilton's equations:\n$$\n\\dot{q} = \\frac{\\partial H}{\\partial p} = p\n$$\n$$\n\\dot{p} = -\\frac{\\partial H}{\\partial q} = -\\omega^2 q\n$$\nThese form a linear system of ordinary differential equations. We are given a discrete time step $h > 0$.\n\nFirst, we analyze the symplectic leapfrog (Störmer–Verlet) integrator. The problem defines its application through three sequential steps for advancing the state from time $t_n$ to $t_{n+1} = t_n + h$:\n$1$. A half-step update of momentum: $p_{n+1/2} = p_n + \\frac{h}{2}\\dot{p}(q_n) = p_n - \\frac{h^2\\omega^2}{2}q_n$.\n$2$. A full-step update of position using the half-step momentum: $q_{n+1} = q_n + h\\dot{q}(p_{n+1/2}) = q_n + hp_{n+1/2}$.\n$3$. A final half-step update of momentum: $p_{n+1} = p_{n+1/2} + \\frac{h}{2}\\dot{p}(q_{n+1}) = p_{n+1/2} - \\frac{h^2\\omega^2}{2}q_{n+1}$.\n\nTo derive the linear recurrence for the position variable $q_n$, we express the momenta in terms of positions. From step $2$, we have $p_{n+1/2} = \\frac{q_{n+1}-q_n}{h}$. Shifting the index back by one step gives $p_{n-1/2} = \\frac{q_n-q_{n-1}}{h}$. The momentum is typically viewed as being updated on a staggered grid. The update from $p_{n-1/2}$ to $p_{n+1/2}$ occurs over a full time step $h$ and is driven by the force at the intermediate time $t_n$:\n$$\np_{n+1/2} = p_{n-1/2} + h \\dot{p}(q_n) = p_{n-1/2} - h\\omega^2 q_n\n$$\nSubstituting the expressions for the momenta in terms of positions into this equation yields:\n$$\n\\frac{q_{n+1}-q_n}{h} = \\frac{q_n-q_{n-1}}{h} - h\\omega^2 q_n\n$$\nMultiplying by $h$ and rearranging gives the desired three-term recurrence relation for $q_n$:\n$$\nq_{n+1} - 2q_n + q_{n-1} = -h^2\\omega^2 q_n\n$$\n$$\nq_{n+1} - (2 - (h\\omega)^2)q_n + q_{n-1} = 0\n$$\nThis is a linear homogeneous difference equation. We seek a solution of the form $q_n = \\lambda^n$. Substituting this ansatz into the recurrence yields the characteristic equation:\n$$\n\\lambda^2 - (2 - (h\\omega)^2)\\lambda + 1 = 0\n$$\nThe roots of this quadratic equation are the eigenvalues of the discrete time-evolution operator. The roots are given by:\n$$\n\\lambda_{\\pm} = \\frac{(2 - (h\\omega)^2) \\pm \\sqrt{(2 - (h\\omega)^2)^2 - 4}}{2}\n$$\nFor the numerical solution to be oscillatory (stable), the discriminant must be negative, which requires $(2 - (h\\omega)^2)^2 - 4 < 0$. This implies $-2 < 2 - (h\\omega)^2 < 2$. The right inequality is $(h\\omega)^2 > 0$, which is always true for $h, \\omega > 0$. The left inequality is $(h\\omega)^2 < 4$, which gives the well-known CFL-type stability condition for the leapfrog method: $h\\omega < 2$. For the boundary case $h\\omega=2$, the roots are real and equal to $-1$. For $h\\omega > 2$, the roots are real and one has magnitude greater than $1$, leading to exponential growth.\n\nAssuming the stability condition $h\\omega \\le 2$ holds, the eigenvalues are a complex conjugate pair $\\lambda_{\\pm} = e^{\\pm i\\theta}$, where $\\theta = h\\tilde{\\omega}$ is the numerical phase advance per step and $\\tilde{\\omega}$ is the modified angular frequency. The sum of the roots is $\\lambda_+ + \\lambda_- = e^{i\\theta} + e^{-i\\theta} = 2\\cos(\\theta)$. From Vieta's formulas applied to the characteristic equation, the sum of the roots is also $2 - (h\\omega)^2$. Equating these gives the dispersion relation:\n$$\n2\\cos(h\\tilde{\\omega}) = 2 - (h\\omega)^2 \\implies \\cos(h\\tilde{\\omega}) = 1 - \\frac{(h\\omega)^2}{2}\n$$\nSolving for $\\tilde{\\omega}$ gives the exact closed-form expression for the modified angular frequency:\n$$\n\\tilde{\\omega} = \\frac{1}{h}\\arccos\\left(1 - \\frac{(h\\omega)^2}{2}\\right)\n$$\nThis expression is valid for $0 \\lt h\\omega \\le 2$. The phase error per unit time is then defined as:\n$$\n\\delta_{\\mathrm{LF}} = \\tilde{\\omega} - \\omega\n$$\n\nNext, we analyze the non-symplectic explicit Euler method. The system in first-order matrix form is $\\dot{\\mathbf{z}} = A\\mathbf{z}$, where $\\mathbf{z} = \\begin{pmatrix} q \\\\ p \\end{pmatrix}$ and $A = \\begin{pmatrix} 0 & 1 \\\\ -\\omega^2 & 0 \\end{pmatrix}$. The explicit Euler method is defined by the update rule $\\mathbf{z}_{n+1} = \\mathbf{z}_n + h \\dot{\\mathbf{z}}_n$. For our system, this becomes:\n$$\n\\mathbf{z}_{n+1} = \\mathbf{z}_n + hA\\mathbf{z}_n = (I + hA)\\mathbf{z}_n\n$$\nThe one-step amplification matrix is therefore $M_{\\mathrm{E}} = I + hA$.\n$$\nM_{\\mathrm{E}} = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} + h\\begin{pmatrix} 0 & 1 \\\\ -\\omega^2 & 0 \\end{pmatrix} = \\begin{pmatrix} 1 & h \\\\ -h\\omega^2 & 1 \\end{pmatrix}\n$$\nThe eigenvalues $\\lambda$ of $M_{\\mathrm{E}}$ determine the stability and phase properties of the method. They are found by solving the characteristic equation $\\det(M_{\\mathrm{E}} - \\lambda I) = 0$:\n$$\n\\det\\begin{pmatrix} 1-\\lambda & h \\\\ -h\\omega^2 & 1-\\lambda \\end{pmatrix} = (1-\\lambda)^2 + h^2\\omega^2 = 0\n$$\nThis gives $(1-\\lambda)^2 = - (h\\omega)^2$, so $1-\\lambda = \\pm i h\\omega$. The eigenvalues are thus a complex conjugate pair:\n$$\n\\lambda_{\\pm} = 1 \\mp i h\\omega\n$$\nThe magnitude of these eigenvalues is $|\\lambda_{\\pm}| = \\sqrt{1^2 + (\\mp h\\omega)^2} = \\sqrt{1 + (h\\omega)^2}$. Since $|\\lambda_{\\pm}| > 1$ for any $h,\\omega > 0$, the method is unconditionally unstable for the harmonic oscillator; the numerical amplitude grows exponentially.\n\nThe problem defines the effective phase angle per step, $\\phi$, as the argument of the eigenvalues. We choose the eigenvalue with a positive imaginary part, $\\lambda_+ = 1 - i h\\omega$. This is a mistake in reasoning. The eigenvalues are $1 \\pm i h\\omega$. Let us select $\\lambda = 1+ih\\omega$ for a positive phase angle convention. The argument is $\\phi = \\arg(1 + i h\\omega)$. In the complex plane, this corresponds to a point with real part $1$ and imaginary part $h\\omega$. The angle is given by:\n$$\n\\phi = \\arctan(h\\omega)\n$$\nwhere `arctan` refers to the principal value, returning an angle in $(-\\pi/2, \\pi/2)$. Since $h\\omega > 0$, $\\phi$ is in $(0, \\pi/2)$.\nThe effective angular frequency $\\omega_{\\mathrm{E}}$ is defined by $\\phi = h\\omega_{\\mathrm{E}}$. This gives:\n$$\n\\omega_{\\mathrm{E}} = \\frac{\\phi}{h} = \\frac{1}{h}\\arctan(h\\omega)\n$$\nThe Euler phase error per unit time is then defined as:\n$$\n\\delta_{\\mathrm{E}} = \\omega_{\\mathrm{E}} - \\omega\n$$\nThese derived formulas for $\\tilde{\\omega}$, $\\delta_{\\mathrm{LF}}$, $\\omega_{\\mathrm{E}}$, and $\\delta_{\\mathrm{E}}$ will be used for the numerical computation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of finding modified/effective frequencies and phase errors\n    for leapfrog and explicit Euler integrators for the harmonic oscillator.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (omega, h).\n    test_cases = [\n        (1.0, 0.1),\n        (1.0, 1.999),\n        (10.0, 0.05),\n        (2.0, 1.0),\n    ]\n\n    results = []\n    for omega, h in test_cases:\n        # --- Leapfrog Integrator Calculations ---\n\n        # The modified angular frequency for leapfrog is derived from the\n        # dispersion relation: cos(h*w_tilde) = 1 - 0.5*(h*omega)^2.\n        # This is valid for h*omega <= 2.\n        hw = h * omega\n        \n        # Argument for arccos. It is guaranteed to be in [-1, 1] for the test cases.\n        arg_acos = 1.0 - 0.5 * hw**2\n        \n        # np.arccos returns the principal value in [0, pi].\n        # The result is guaranteed to be non-negative.\n        w_tilde = (1.0 / h) * np.arccos(arg_acos)\n        \n        # Phase error per unit time for leapfrog.\n        delta_LF = w_tilde - omega\n        \n        # --- Explicit Euler Integrator Calculations ---\n\n        # The effective angular frequency for explicit Euler is derived from\n        # the argument of its amplification matrix eigenvalues: phi = arctan(h*omega).\n        # w_E = phi / h.\n        w_E = (1.0 / h) * np.arctan(hw)\n        \n        # Phase error per unit time for explicit Euler.\n        delta_E = w_E - omega\n        \n        # Append the four computed values for the current test case.\n        results.extend([w_tilde, w_E, delta_LF, delta_E])\n\n    # Final print statement in the exact required format.\n    # The list 'results' is a flat list of all 16 numbers.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having observed the superior performance of a symplectic integrator, a natural question is how to verify if an arbitrary numerical method possesses this crucial, structure-preserving property. While analytical proofs are possible for simple integrators, a numerical diagnostic is an invaluable tool for complex, 'black-box' methods. In this exercise , you will build such a tool by using finite differences to approximate an integrator's Jacobian matrix, $J$, and then evaluating the residual of the algebraic condition for symplecticity, $J^{\\top} \\Omega J = \\Omega$. This provides a direct, hands-on method for testing the geometric fidelity of any one-step map.",
            "id": "4051312",
            "problem": "Consider canonical Hamiltonian dynamics in $2n$ dimensions, defined by position coordinates $q \\in \\mathbb{R}^{n}$ and momentum coordinates $p \\in \\mathbb{R}^{n}$, collected into a single state vector $z = (q,p) \\in \\mathbb{R}^{2n}$. The evolution of $z$ is governed by Hamilton's equations derived from a given Hamiltonian $H(q,p)$, namely $\\dot{q} = \\partial H / \\partial p$ and $\\dot{p} = - \\partial H / \\partial q$. The canonical symplectic form is represented by the constant matrix $\\Omega \\in \\mathbb{R}^{2n \\times 2n}$ with block structure\n$$\n\\Omega = \\begin{bmatrix} 0 & I_n \\\\ -I_n & 0 \\end{bmatrix},\n$$\nwhere $I_n$ denotes the $n \\times n$ identity matrix. A discrete-time one-step integrator $\\Phi_h : \\mathbb{R}^{2n} \\to \\mathbb{R}^{2n}$, mapping $z_{k+1} = \\Phi_h(z_k)$ with time-step $h$, is called symplectic if its Jacobian $J(z) = D\\Phi_h(z)$ satisfies the symplectic condition\n$$\nJ(z)^{\\top}\\,\\Omega\\,J(z) = \\Omega\n$$\nfor all $z$.\n\nStarting from these fundamental definitions, design and implement a numerical procedure that, for a given black-box one-step map $\\Phi_h$ and Hamiltonian $H(q,p)$, tests symplecticity at a point $z$ by approximating the Jacobian $J(z)$ using central finite differences and then evaluating the Frobenius norm of the residual matrix $J(z)^{\\top} \\Omega J(z) - \\Omega$. The Frobenius norm of a matrix $A$ is defined as $\\|A\\|_F = \\sqrt{\\sum_{i,j} A_{ij}^2}$.\n\nYour program must:\n\n- Work for the specific separable Hamiltonian in two spatial dimensions ($n=2$) that is widely used as a dimensionless model for linearized particle motion in magnetic confinement systems in computational fusion science and engineering:\n$$\nH(q,p) = T(p) + V(q), \\quad T(p) = \\frac{1}{2m}\\,\\|p\\|^2, \\quad V(q) = \\frac{1}{2}\\,m\\,\\omega^2\\,\\|q\\|^2,\n$$\nwith parameters $m > 0$ and $\\omega > 0$.\n- Implement two black-box integrators for this Hamiltonian:\n  1. A symplectic Störmer–Verlet method (kick–drift–kick splitting) that uses $T(p)$ and $V(q)$ as given above.\n  2. A non-symplectic explicit Euler method using the same $T(p)$ and $V(q)$.\n- Approximate $J(z)$ for a given $z$ and step size $h$ using central finite differences: for the $i$-th canonical basis vector $e_i \\in \\mathbb{R}^{4}$, compute the $i$-th column of $J$ as\n$$\nJ_{:,i} \\approx \\frac{\\Phi_h(z + \\varepsilon e_i) - \\Phi_h(z - \\varepsilon e_i)}{2\\varepsilon},\n$$\nwhere $\\varepsilon > 0$ is a small finite-difference increment. Then compute the scalar residual\n$$\nr(z; h, \\varepsilon) = \\left\\| J(z)^{\\top}\\,\\Omega\\,J(z) - \\Omega \\right\\|_F.\n$$\n- Produce results as floating-point numbers without physical units because all variables and parameters are dimensionless in this setup.\n\nTest Suite Specification:\n\nUse $n=2$ so that $z \\in \\mathbb{R}^{4}$ with $q = (q_1,q_2)$ and $p = (p_1,p_2)$. For each test case below, evaluate the residual $r(z; h, \\varepsilon)$ and return it.\n\nDefine the following eight test cases, each consisting of a tuple $(\\text{method}, m, \\omega, h, \\varepsilon, z)$:\n1. $(\\text{SV}, 1.0, 1.0, 0.1, 10^{-6}, (q=(1.0,-0.5), p=(0.3,1.2)))$ where $\\text{SV}$ denotes the Störmer–Verlet method.\n2. $(\\text{EE}, 1.0, 1.0, 0.1, 10^{-6}, (q=(1.0,-0.5), p=(0.3,1.2)))$ where $\\text{EE}$ denotes the explicit Euler method.\n3. $(\\text{SV}, 1.0, 1.0, 1.0, 10^{-6}, (q=(1.0,-0.5), p=(0.3,1.2)))$.\n4. $(\\text{EE}, 1.0, 1.0, 1.0, 10^{-6}, (q=(1.0,-0.5), p=(0.3,1.2)))$.\n5. $(\\text{SV}, 1.0, 10.0, 0.05, 10^{-6}, (q=(0.2, -0.1), p=(0.05, 0.3)))$.\n6. $(\\text{EE}, 1.0, 10.0, 0.05, 10^{-6}, (q=(0.2, -0.1), p=(0.05, 0.3)))$.\n7. $(\\text{SV}, 1.0, 1.0, 0.1, 10^{-6}, (q=(0.0, 0.0), p=(0.0, 0.0)))$ to probe behavior at the equilibrium.\n8. $(\\text{SV}, 1.0, 1.0, 0.1, 10^{-3}, (q=(1.0,-0.5), p=(0.3,1.2)))$ to assess sensitivity to a larger finite-difference increment.\n\nFinal Output Format:\n\nYour program should produce a single line of output containing the eight residuals in the order above, as a comma-separated list enclosed in square brackets. For example, the output format must be exactly like\n$[r_1,r_2,r_3,r_4,r_5,r_6,r_7,r_8]$,\nwhere each $r_i$ is a floating-point number corresponding to test case $i$. No additional text or whitespace beyond what is implied by the standard string formatting of floating-point numbers should be printed.",
            "solution": "The problem requires the design and implementation of a numerical test for the symplecticity of one-step integrators for a canonical Hamiltonian system. This involves defining the system, the integrators, and the test procedure itself.\n\nThe system under consideration is a $2n$-dimensional canonical Hamiltonian system with state vector $z=(q,p)$, where $q \\in \\mathbb{R}^n$ are the position coordinates and $p \\in \\mathbb{R}^n$ are the momentum coordinates. The dynamics are governed by Hamilton's equations, $\\dot{q} = \\partial H / \\partial p$ and $\\dot{p} = - \\partial H / \\partial q$, for a given Hamiltonian $H(q,p)$. The problem specifies a separable Hamiltonian for a $2$-dimensional harmonic oscillator ($n=2$), which is a fundamental model in physics, including for linearized particle motion in magnetic confinement devices. The Hamiltonian is:\n$$\nH(q,p) = T(p) + V(q) = \\frac{1}{2m} \\|p\\|^2 + \\frac{1}{2} m \\omega^2 \\|q\\|^2\n$$\nHere, $q=(q_1, q_2)$, $p=(p_1, p_2)$, $m > 0$ is the mass, and $\\omega > 0$ is the angular frequency. All quantities are dimensionless. The corresponding equations of motion are:\n$$\n\\dot{q} = \\frac{\\partial H}{\\partial p} = \\frac{p}{m}\n$$\n$$\n\\dot{p} = -\\frac{\\partial H}{\\partial q} = -m \\omega^2 q\n$$\nThe full state vector is $z = (q_1, q_2, p_1, p_2) \\in \\mathbb{R}^4$.\n\nA one-step numerical integrator is a map $\\Phi_h: \\mathbb{R}^{2n} \\to \\mathbb{R}^{2n}$ that approximates the flow of the system over a time step $h$, such that $z_{k+1} = \\Phi_h(z_k)$. The map is symplectic if its Jacobian, $J(z) = D\\Phi_h(z)$, satisfies the condition $J(z)^\\top \\Omega J(z) = \\Omega$ for all $z$, where $\\Omega$ is the canonical symplectic matrix. For $n=2$, $\\Omega$ is the $4 \\times 4$ matrix:\n$$\n\\Omega = \\begin{bmatrix} 0_2 & I_2 \\\\ -I_2 & 0_2 \\end{bmatrix} = \\begin{pmatrix} 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\\\ -1 & 0 & 0 & 0 \\\\ 0 & -1 & 0 & 0 \\end{pmatrix}\n$$\nwhere $I_2$ is the $2 \\times 2$ identity matrix and $0_2$ is the $2 \\times 2$ zero matrix.\n\nWe must implement two integrators for this system.\n\n1.  **Explicit Euler (EE) Method**: This is a first-order, non-symplectic method. The update rule is derived by a forward difference approximation of the time derivative: $z_{k+1} = z_k + h \\dot{z}_k$.\n    $$\n    q_{k+1} = q_k + h \\dot{q}_k = q_k + \\frac{h}{m} p_k\n    $$\n    $$\n    p_{k+1} = p_k + h \\dot{p}_k = p_k - h m \\omega^2 q_k\n    $$\n\n2.  **Störmer–Verlet (SV) Method**: For a separable Hamiltonian, this method is constructed via operator splitting. The specified \"kick-drift-kick\" scheme corresponds to a second-order Strang splitting of the form $\\Phi_h = \\Phi_{h/2}^V \\circ \\Phi_h^T \\circ \\Phi_{h/2}^V$, where $\\Phi_h^V$ is the exact flow under the potential part $V(q)$ and $\\Phi_h^T$ is the exact flow under the kinetic part $T(p)$.\n    The sequence of operations is as follows:\n    -   **Kick ($h/2$)**: Update momentum using the force from the potential for a half time step.\n        $$ p_{k+1/2} = p_k - \\frac{h}{2} \\nabla_q V(q_k) = p_k - \\frac{h}{2} m \\omega^2 q_k $$\n    -   **Drift ($h$)**: Update position using the new momentum for a full time step.\n        $$ q_{k+1} = q_k + h \\nabla_p T(p_{k+1/2}) = q_k + h \\frac{p_{k+1/2}}{m} $$\n    -   **Kick ($h/2$)**: Update momentum again using the force at the new position for another half time step.\n        $$ p_{k+1} = p_{k+1/2} - \\frac{h}{2} \\nabla_q V(q_{k+1}) = p_{k+1/2} - \\frac{h}{2} m \\omega^2 q_{k+1} $$\n    This method is known to be exactly symplectic for separable Hamiltonians.\n\nThe core of the task is to numerically verify symplecticity by computing the residual $r = \\| J^\\top \\Omega J - \\Omega \\|_F$, where $\\|\\cdot\\|_F$ is the Frobenius norm. The Jacobian $J(z)$ is approximated using central finite differences. The $j$-th column of $J$ is given by:\n$$\nJ_{:,j} \\approx \\frac{\\Phi_h(z + \\varepsilon e_j) - \\Phi_h(z - \\varepsilon e_j)}{2\\varepsilon}\n$$\nwhere $e_j$ is the $j$-th canonical basis vector in $\\mathbb{R}^4$ and $\\varepsilon$ is a small perturbation.\n\nA crucial observation for this specific problem is that the Hamiltonian is quadratic, which makes Hamilton's equations linear. Consequently, both the explicit Euler and Störmer-Verlet integrators are linear maps, i.e., they can be written as $z_{k+1} = M z_k$ for some constant matrix $M$. For such linear maps, the Jacobian is constant, $J(z)=M$, and the central difference formula for the Jacobian is exact, independent of the value of $\\varepsilon$ (provided $\\varepsilon$ is not so small that it causes floating-point cancellation errors).\n$$\n\\frac{\\Phi_h(z + \\varepsilon e_j) - \\Phi_h(z - \\varepsilon e_j)}{2\\varepsilon} = \\frac{M(z + \\varepsilon e_j) - M(z - \\varepsilon e_j)}{2\\varepsilon} = \\frac{Mz + \\varepsilon M e_j - Mz + \\varepsilon M e_j}{2\\varepsilon} = M e_j = J_{:,j}\n$$\nTherefore, our numerical test will compute the Jacobian with very high accuracy, limited only by machine precision.\n\nFor the explicit Euler method, we can analytically compute the residual. The map matrix is $J_{EE} = \\begin{pmatrix} I_2 & (h/m)I_2 \\\\ -hm\\omega^2 I_2 & I_2 \\end{pmatrix}$. The residual matrix is $J_{EE}^\\top \\Omega J_{EE} - \\Omega = \\begin{pmatrix} 0_2 & h^2\\omega^2 I_2 \\\\ -h^2\\omega^2 I_2 & 0_2 \\end{pmatrix}$. The Frobenius norm of this matrix is $\\|R\\|_F = \\sqrt{2n (h^2\\omega^2)^2} = \\sqrt{2(2)} (h^2\\omega^2) = 2h^2\\omega^2$.\n\nFor the Störmer-Verlet method, the integrator is exactly symplectic, meaning its Jacobian $J_{SV}$ satisfies $J_{SV}^\\top \\Omega J_{SV} = \\Omega$. Since our numerical method computes the Jacobian exactly (up to floating-point error), the computed residual norm should be on the order of machine epsilon (e.g., $\\approx 10^{-15}$). This value should be very small compared to the residuals for the non-symplectic Euler method and largely insensitive to the choice of parameters $h, \\omega, \\varepsilon$, and the point $z$. The numerical procedure will compute these residuals for the specified test cases.",
            "answer": "```python\nimport numpy as np\n\ndef euler_step(z, h, m, omega):\n    \"\"\"\n    Performs one step of the explicit Euler method.\n\n    Args:\n        z (np.ndarray): State vector [q1, q2, p1, p2].\n        h (float): Time step.\n        m (float): Mass parameter.\n        omega (float): Frequency parameter.\n\n    Returns:\n        np.ndarray: The new state vector.\n    \"\"\"\n    q, p = z[:2], z[2:]\n    q_next = q + (h / m) * p\n    p_next = p - h * m * (omega**2) * q\n    return np.concatenate([q_next, p_next])\n\ndef verlet_step(z, h, m, omega):\n    \"\"\"\n    Performs one step of the Störmer-Verlet (velocity Verlet) method.\n\n    Args:\n        z (np.ndarray): State vector [q1, q2, p1, p2].\n        h (float): Time step.\n        m (float): Mass parameter.\n        omega (float): Frequency parameter.\n\n    Returns:\n        np.ndarray: The new state vector.\n    \"\"\"\n    q, p = z[:2], z[2:]\n    \n    # Kick (half step)\n    force_q = -m * (omega**2) * q\n    p_half = p + (h / 2.0) * force_q\n    \n    # Drift (full step)\n    velocity_phalf = p_half / m\n    q_next = q + h * velocity_phalf\n    \n    # Kick (half step)\n    force_q_next = -m * (omega**2) * q_next\n    p_next = p_half + (h / 2.0) * force_q_next\n    \n    return np.concatenate([q_next, p_next])\n\ndef compute_residual(integrator_func, z0, h, m, omega, eps):\n    \"\"\"\n    Computes the symplecticity residual for a given integrator.\n\n    Args:\n        integrator_func (function): The one-step integrator (euler_step or verlet_step).\n        z0 (np.ndarray): The state vector at which to test.\n        h (float): Time step.\n        m (float): Mass parameter.\n        omega (float): Frequency parameter.\n        eps (float): Finite difference increment.\n\n    Returns:\n        float: The Frobenius norm of the residual matrix.\n    \"\"\"\n    dim = 4\n    J = np.zeros((dim, dim))\n    Omega = np.array([[0, 0, 1, 0], \n                      [0, 0, 0, 1], \n                      [-1, 0, 0, 0], \n                      [0, -1, 0, 0]])\n\n    # Approximate Jacobian using central finite differences\n    for j in range(dim):\n        e_j = np.zeros(dim)\n        e_j[j] = 1.0\n        \n        z_plus = z0 + eps * e_j\n        z_minus = z0 - eps * e_j\n        \n        phi_plus = integrator_func(z_plus, h, m, omega)\n        phi_minus = integrator_func(z_minus, h, m, omega)\n        \n        J[:, j] = (phi_plus - phi_minus) / (2 * eps)\n\n    # Compute the residual matrix and its Frobenius norm\n    residual_matrix = J.T @ Omega @ J - Omega\n    residual_norm = np.linalg.norm(residual_matrix, 'fro')\n    \n    return residual_norm\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (method, m, omega, h, eps, z)\n        ('SV', 1.0, 1.0, 0.1, 1e-6, np.array([1.0, -0.5, 0.3, 1.2])),\n        ('EE', 1.0, 1.0, 0.1, 1e-6, np.array([1.0, -0.5, 0.3, 1.2])),\n        ('SV', 1.0, 1.0, 1.0, 1e-6, np.array([1.0, -0.5, 0.3, 1.2])),\n        ('EE', 1.0, 1.0, 1.0, 1e-6, np.array([1.0, -0.5, 0.3, 1.2])),\n        ('SV', 1.0, 10.0, 0.05, 1e-6, np.array([0.2, -0.1, 0.05, 0.3])),\n        ('EE', 1.0, 10.0, 0.05, 1e-6, np.array([0.2, -0.1, 0.05, 0.3])),\n        ('SV', 1.0, 1.0, 0.1, 1e-6, np.array([0.0, 0.0, 0.0, 0.0])),\n        ('SV', 1.0, 1.0, 0.1, 1e-3, np.array([1.0, -0.5, 0.3, 1.2])),\n    ]\n\n    integrator_map = {\n        'SV': verlet_step,\n        'EE': euler_step\n    }\n\n    results = []\n    for case in test_cases:\n        method_name, m, omega, h, eps, z0 = case\n        integrator_func = integrator_map[method_name]\n        \n        residual = compute_residual(integrator_func, z0, h, m, omega, eps)\n        results.append(residual)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The ultimate payoff for using symplectic integrators is their exceptional stability in long-term simulations, which is essential for applications like modeling charged-particle orbits in fusion plasmas. This practice  demonstrates this by applying the symplectic Störmer-Verlet integrator to a nonlinear oscillator, a step closer to realistic physical systems. You will observe that the numerical energy does not drift away over thousands of periods but instead exhibits bounded oscillations. This remarkable behavior is explained by Backward Error Analysis, which posits that the integrator exactly conserves a nearby 'modified' Hamiltonian, $\\tilde{H}$. This exercise solidifies the connection between the abstract symplectic property and the concrete, long-term fidelity that makes these methods indispensable.",
            "id": "4051315",
            "problem": "Consider a one-dimensional Hamiltonian system defined by the Hamiltonian $H(q,p) = \\frac{p^2}{2m} + V(q)$ with potential $V(q) = \\frac{1}{2}k q^2 + \\alpha q^4$. The canonical equations of motion follow from Hamilton's equations and define the exact flow that preserves the symplectic two-form and the Hamiltonian. Your task is to study the long-time behavior of the numerical energy produced by a second-order symplectic, variational integrator derived from a discrete action principle. Specifically, implement a position-momentum update that is consistent with a discrete Euler–Lagrange construction using a consistent second-order approximation to the continuous Lagrangian $L(q,\\dot{q}) = \\frac{1}{2}m \\dot{q}^2 - V(q)$, and then use this update to integrate the motion for $10^4$ reference periods.\n\nFundamental base for derivation and analysis:\n- Use the definition of the Lagrangian $L(q,\\dot{q})$ and the action functional, and derive discrete equations of motion from the discrete action by applying the principle of stationary action to a second-order accurate discrete Lagrangian. This must yield a symplectic, time-reversible scheme of second order.\n- Use Hamilton's equations for the given separable Hamiltonian to reason about the splitting of the flow and the properties of symplectic integrators.\n- Use the concept of Backward Error Analysis (BEA), defined as the study of a modified differential equation whose exact flow is closer to the numerical method than the original system, to explain bounded energy oscillations and near-conservation of a modified Hamiltonian.\n\nProgram requirements:\n1. Implement a second-order symplectic, variational integrator for the separable Hamiltonian $H(q,p) = \\frac{p^2}{2m} + V(q)$ with $V(q) = \\frac{1}{2}k q^2 + \\alpha q^4$. The update must be derived from first principles of discrete variational mechanics, and must be symplectic and time-reversible.\n2. For each test case, compute an approximate reference period $T_0 = 2\\pi \\sqrt{\\frac{m}{k}}$ (in seconds), define the time step $h = \\frac{T_0}{N_{\\text{pp}}}$ (in seconds) where $N_{\\text{pp}}$ denotes the number of steps per reference period, and integrate for $N_{\\text{per}} = 10^4$ reference periods for a total integration time $T_{\\text{tot}} = N_{\\text{per}} T_0$ (in seconds).\n3. Initialize with $q(0) = q_0$ (in meters) and $p(0) = 0$ (in kilogram meter per second).\n4. During integration, compute the instantaneous energy $H(q(t),p(t))$ (in joules) at every step and record:\n   - The maximum relative energy deviation over the entire simulation, defined as $\\max_{0 \\le t \\le T_{\\text{tot}}} \\left| \\frac{H(t) - H(0)}{H(0)} \\right|$ (dimensionless decimal).\n   - The normalized linear drift rate of the energy, computed as the slope of the least-squares linear fit of $H(t)$ versus $t$ divided by $H(0)$, which has units of inverse seconds. Explicitly, if the least-squares slope is $s$ (in joules per second), report $\\frac{s}{H(0)}$ (in inverse seconds).\n5. Explain qualitatively how the observed oscillations and small drift rates relate to Backward Error Analysis (BEA), which predicts the existence of a modified Hamiltonian $\\tilde{H} = H + h^2 \\Delta H + \\mathcal{O}(h^4)$ that is nearly conserved by symplectic second-order schemes, with oscillatory energy errors of amplitude scaling like $\\mathcal{O}(h^2)$.\n\nPhysical and numerical units:\n- Report energies in joules, time in seconds, mass in kilograms, position in meters, stiffness in newtons per meter, and $\\alpha$ in newtons per meter cubed.\n- The drift rate must be reported in inverse seconds.\n- Any fractional quantity must be expressed as a decimal.\n\nTest suite:\nUse the following four scientifically sound test cases to cover harmonic, weakly nonlinear, coarse step near stability, and fine step regimes. For all test cases, set the number of reference periods to $N_{\\text{per}} = 10^4$.\n- Case $1$ (harmonic baseline): $m = 1.0$ kilograms, $k = 1.0$ newtons per meter, $\\alpha = 0.0$ newtons per meter cubed, $q_0 = 0.2$ meters, $N_{\\text{pp}} = 20$.\n- Case $2$ (weakly nonlinear moderate step): $m = 1.0$ kilograms, $k = 1.0$ newtons per meter, $\\alpha = 0.01$ newtons per meter cubed, $q_0 = 0.2$ meters, $N_{\\text{pp}} = 20$.\n- Case $3$ (weakly nonlinear coarse step near stability boundary): $m = 1.0$ kilograms, $k = 1.0$ newtons per meter, $\\alpha = 0.01$ newtons per meter cubed, $q_0 = 0.2$ meters, $N_{\\text{pp}} = 4$.\n- Case $4$ (stronger nonlinearity fine step): $m = 1.0$ kilograms, k = 1.0$ newtons per meter, $\\alpha = 0.05$ newtons per meter cubed, $q_0 = 0.3$ meters, $N_{\\text{pp}} = 100$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is a two-element list for the corresponding test case. Each two-element list must be ordered as $[$maximum relative energy deviation, normalized linear drift rate in inverse seconds$]$. For example, the output should look like $[[x_1,y_1],[x_2,y_2],[x_3,y_3],[x_4,y_4]]$ with decimal values.",
            "solution": "The problem as stated is scientifically sound, self-contained, and well-posed. It presents a standard task in computational dynamics: the long-term integration of a conservative Hamiltonian system using a symplectic numerical method. All parameters, initial conditions, and analysis requirements are specified unambiguously. The underlying principles—Hamiltonian mechanics, discrete variational principles, and backward error analysis—are cornerstones of the field. Therefore, I will proceed with a full derivation and solution.\n\nThe objective is to implement a second-order, symplectic, variational integrator for a one-dimensional nonlinear oscillator and analyze its long-term energy conservation properties. The system is described by the separable Hamiltonian $H(q,p) = T(p) + V(q)$, where the kinetic energy is $T(p) = \\frac{p^2}{2m}$ and the potential energy is $V(q) = \\frac{1}{2}k q^2 + \\alpha q^4$.\n\nA numerical method is termed variational if it can be derived from a discrete version of Hamilton's principle of stationary action. The continuous action functional is $S[q] = \\int L(q(t), \\dot{q}(t)) dt$, where the Lagrangian is $L = T - V$. We construct a discrete Lagrangian $L_d(q_n, q_{n+1})$ that approximates $\\int_{t_n}^{t_{n+1}} L(q(t), \\dot{q}(t)) dt$. A common second-order accurate choice uses a finite difference for the velocity and a trapezoidal rule for the potential, yielding:\n$$\nL_d(q_n, q_{n+1}) = h \\left[ \\frac{1}{2}m \\left(\\frac{q_{n+1}-q_n}{h}\\right)^2 - \\frac{1}{2}\\left(V(q_n) + V(q_{n+1})\\right) \\right]\n$$\nThe discrete action is the sum $S_d = \\sum_n L_d(q_n, q_{n+1})$. The principle of stationary action, $\\delta S_d = 0$, for variations $\\delta q_n$ vanishing at the endpoints, leads to the discrete Euler-Lagrange equations:\n$$\n\\frac{\\partial L_d(q_{n-1}, q_n)}{\\partial q_n} + \\frac{\\partial L_d(q_n, q_{n+1})}{\\partial q_n} = 0\n$$\nComputing the partial derivatives:\n$$\n\\frac{\\partial L_d(q_{n-1}, q_n)}{\\partial q_n} = \\frac{m}{h}(q_n - q_{n-1}) - \\frac{h}{2} V'(q_n)\n$$\n$$\n\\frac{\\partial L_d(q_n, q_{n+1})}{\\partial q_n} = -\\frac{m}{h}(q_{n+1} - q_n) - \\frac{h}{2} V'(q_n)\n$$\nSubstituting these into the discrete Euler-Lagrange equation gives:\n$$\n\\frac{m}{h}(q_n - q_{n-1}) - \\frac{h}{2} V'(q_n) - \\frac{m}{h}(q_{n+1} - q_n) - \\frac{h}{2} V'(q_n) = 0\n$$\nRearranging terms yields the celebrated Störmer-Verlet (or position Verlet) algorithm:\n$$\nm \\frac{q_{n+1} - 2q_n + q_{n-1}}{h^2} = -V'(q_n) = F(q_n)\n$$\nwhere $F(q) = -V'(q)$ is the force. While this form is elegant, it is a three-term recurrence in position and does not explicitly use the momentum variable $p$. For phase space analysis, it is equivalent and often more convenient to use the \"velocity Verlet\" formulation, which is a one-step method in $(q, p)$ space. This algorithm is derived by splitting the Liouville operator and is known to be symplectic. The equivalence can be shown by defining an intermediate momentum. The velocity Verlet algorithm for the given system is:\n1. First half-kick for momentum: $p_{n+1/2} = p_n - \\frac{h}{2} \\frac{\\partial V}{\\partial q}(q_n) = p_n + \\frac{h}{2} F(q_n)$\n2. Full drift for position: $q_{n+1} = q_n + h \\frac{\\partial T}{\\partial p}(p_{n+1/2}) = q_n + \\frac{h}{m} p_{n+1/2}$\n3. Second half-kick for momentum: $p_{n+1} = p_{n+1/2} - \\frac{h}{2} \\frac{\\partial V}{\\partial q}(q_{n+1}) = p_{n+1/2} + \\frac{h}{2} F(q_{n+1})$\n\nThis integrator is explicitly defined, second-order accurate, time-reversible, and, most importantly, symplectic. Symplecticness means the numerical flow map $\\Phi_h: (q_n, p_n) \\to (q_{n+1}, p_{n+1})$ preserves the symplectic two-form $dq \\wedge dp$. This property is responsible for the excellent long-term behavior of the integrator.\n\nThe observed numerical results—bounded energy oscillations and negligible long-term energy drift—are quintessential features of symplectic integrators and are rigorously explained by Backward Error Analysis (BEA). BEA states that the numerical solution generated by a symplectic integrator, while not lying on the exact trajectory of the original Hamiltonian $H$, does lie on the exact trajectory of a nearby, modified Hamiltonian $\\tilde{H}$. For a second-order, time-reversible scheme like velocity Verlet, this modified Hamiltonian has an asymptotic expansion in even powers of the time step $h$:\n$$\n\\tilde{H}(q,p,h) = H(q,p) + h^2 H_2(q,p) + h^4 H_4(q,p) + \\mathcal{O}(h^6)\n$$\nThe numerical integrator conserves $\\tilde{H}$ to a very high degree (typically to machine precision) over exponentially long times. Thus, along the numerical trajectory $(q_n, p_n)$, we have $\\tilde{H}(q_n, p_n) \\approx \\text{constant}$.\nThe energy we compute is the original energy $H(q_n, p_n)$. From the expansion, we can write:\n$$\nH(q_n, p_n) \\approx \\tilde{H}(q_n, p_n) - h^2 H_2(q_n, p_n)\n$$\nSince $\\tilde{H}$ is nearly constant, the change in the original energy $H$ over time is dominated by the term $-h^2 H_2(q_n, p_n)$. As the system evolves, the point $(q_n, p_n)$ traverses its phase space orbit, causing $H_2(q_n, p_n)$ to oscillate. Consequently, the measured energy $H(q_n, p_n)$ exhibits bounded oscillations around a constant value. The amplitude of these oscillations scales as $\\mathcal{O}(h^2)$. This explains why the maximum relative energy deviation does not grow over time but remains bounded.\n\nThe absence of odd powers of $h$ (e.g., $h^1, h^3$) in the expansion of $\\tilde{H}$ is a direct consequence of the integrator's time-reversibility. This is crucial because it eliminates terms that would cause secular, or linear, drift in the energy. Any residual linear drift observed in a simulation is attributable to the influence of very high-order terms in the expansion and, more practically, to the accumulation of floating-point rounding errors over millions of steps. For a well-resolved simulation ($h$ is sufficiently small), this drift is expected to be extremely small, as confirmed by the calculated normalized linear drift rate, which should be close to zero. The provided test cases will demonstrate these properties: larger step sizes (Case $3$) will lead to larger, but still bounded, energy oscillations, while smaller step sizes (Case $4$) will show much smaller oscillations. The harmonic case (Case $1$) serves as a baseline, and the nonlinear cases show the robustness of the method.\n\nThe numerical implementation will follow the velocity Verlet algorithm. For each test case, we initialize $(q_0, p_0 = 0)$, compute the total number of steps from $T_0 = 2\\pi\\sqrt{m/k}$, $h=T_0/N_{\\text{pp}}$, and $T_{\\text{tot}} = N_{\\text{per}} T_0$. At each step, we record the time $t$ and the Hamiltonian value $H(q(t), p(t))$. Finally, we compute the maximum relative energy deviation and the normalized slope of a linear fit to the energy time series.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of integrating a nonlinear oscillator using a symplectic\n    integrator and analyzing its energy conservation properties.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (harmonic baseline)\n        {'m': 1.0, 'k': 1.0, 'alpha': 0.0, 'q0': 0.2, 'N_pp': 20},\n        # Case 2 (weakly nonlinear moderate step)\n        {'m': 1.0, 'k': 1.0, 'alpha': 0.01, 'q0': 0.2, 'N_pp': 20},\n        # Case 3 (weakly nonlinear coarse step near stability boundary)\n        {'m': 1.0, 'k': 1.0, 'alpha': 0.01, 'q0': 0.2, 'N_pp': 4},\n        # Case 4 (stronger nonlinearity fine step)\n        {'m': 1.0, 'k': 1.0, 'alpha': 0.05, 'q0': 0.3, 'N_pp': 100},\n    ]\n\n    # Universal simulation parameter\n    N_per = 10000\n\n    results = []\n    \n    for case in test_cases:\n        m = case['m']\n        k = case['k']\n        alpha = case['alpha']\n        q0 = case['q0']\n        N_pp = case['N_pp']\n        \n        # Initial conditions\n        q = q0\n        p = 0.0\n        \n        # Simulation time parameters\n        # For k=0, T0 is undefined. The problem guarantees k > 0.\n        T0 = 2.0 * np.pi * np.sqrt(m / k)\n        h = T0 / N_pp\n        total_steps = int(N_per * N_pp)\n        \n        # Define the force and Hamiltonian functions\n        def force(pos):\n            return -(k * pos + 4.0 * alpha * pos**3)\n\n        def hamiltonian(pos, mom):\n            V = 0.5 * k * pos**2 + alpha * pos**4\n            T = 0.5 * mom**2 / m\n            return T + V\n\n        # Store initial energy\n        H0 = hamiltonian(q, p)\n        if H0 == 0:\n            # Avoid division by zero, although not expected for given cases.\n            # In this case, relative error is ill-defined.\n            # Let's set results to NaN to indicate a problem.\n            results.append([np.nan, np.nan])\n            continue\n\n        # Arrays to store time and energy history for analysis\n        energy_history = np.zeros(total_steps + 1)\n        time_history = np.zeros(total_steps + 1)\n        \n        energy_history[0] = H0\n        time_history[0] = 0.0\n\n        # Main integration loop using Velocity Verlet algorithm\n        for i in range(total_steps):\n            # 1. First half-kick for momentum\n            p_half = p + 0.5 * h * force(q)\n            \n            # 2. Full drift for position\n            q = q + h * p_half / m\n            \n            # 3. Second half-kick for momentum\n            p = p_half + 0.5 * h * force(q)\n            \n            # Store results\n            current_time = (i + 1) * h\n            current_energy = hamiltonian(q, p)\n            time_history[i+1] = current_time\n            energy_history[i+1] = current_energy\n\n        # Post-simulation analysis\n        # 1. Maximum relative energy deviation\n        # The deviation is |H(t) - H(0)| / |H(0)| since H(0) can be negative\n        # but in this problem, H(0) is always positive.\n        rel_energy_dev = np.abs((energy_history - H0) / H0)\n        max_rel_dev = np.max(rel_energy_dev)\n        \n        # 2. Normalized linear drift rate\n        # Perform a linear least-squares fit of H(t) vs t\n        # polyfit returns [slope, intercept]\n        slope, _ = np.polyfit(time_history, energy_history, 1)\n        normalized_drift = slope / H0\n        \n        results.append([max_rel_dev, normalized_drift])\n\n    # Final print statement in the exact required format.\n    # Format each number to avoid ambiguity, e.g., using scientific notation\n    # for small numbers.\n    formatted_results = []\n    for res_pair in results:\n        formatted_pair = f\"[{res_pair[0]:.8e},{res_pair[1]:.8e}]\"\n        formatted_results.append(formatted_pair)\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}