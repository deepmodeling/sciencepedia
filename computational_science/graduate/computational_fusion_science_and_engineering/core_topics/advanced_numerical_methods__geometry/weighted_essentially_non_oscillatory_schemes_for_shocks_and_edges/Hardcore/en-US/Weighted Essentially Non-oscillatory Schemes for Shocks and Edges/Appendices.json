{
    "hands_on_practices": [
        {
            "introduction": "High-order accuracy in finite volume methods relies on reconstructing the solution within each cell using polynomials. While effective in smooth regions, this approach can fail dramatically near shocks or sharp edges. This first practice exercise  guides you through the construction of a basic third-order polynomial reconstruction to demonstrate precisely how and why unphysical oscillations—a manifestation of the Gibbs phenomenon—arise when the reconstruction stencil crosses a discontinuity. Understanding this failure is the crucial first step toward appreciating the sophisticated design of non-oscillatory schemes like WENO.",
            "id": "4065325",
            "problem": "A one-dimensional hyperbolic conservation law $\\partial_t u + \\partial_x f(u) = 0$ is discretized by a finite volume method on a uniform grid with spacing $\\Delta x$, cell centers $x_i$, and interfaces $x_{i\\pm 1/2}$. The cell average in cell $i$ is $\\bar{u}_i(t) = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) \\, dx$. To compute high-order interface fluxes for fusion edge-transport simulations where steep gradients and shocks occur, a piecewise polynomial reconstruction is needed to obtain a left-sided point value $u_{i+1/2}^- = \\lim_{x \\to x_{i+1/2}^-} u_h(x)$.\n\nStarting from the fundamental finite volume definition of cell averages and the requirement that a reconstruction match them, construct within cell $i$ a quadratic polynomial $p_i(x)$ on the stencil of three neighboring cell averages $\\{\\bar{u}_{i-1}, \\bar{u}_i, \\bar{u}_{i+1}\\}$ such that the average of $p_i(x)$ over each cell $i-1$, $i$, and $i+1$ equals the corresponding $\\bar{u}_j$. Use only the uniform-grid geometry and the average constraints to determine the coefficients. Then evaluate the left-sided interface value $u_{i+1/2}^- = p_i(x_{i+1/2})$ explicitly as a closed-form function of $\\bar{u}_{i-1}$, $\\bar{u}_i$, and $\\bar{u}_{i+1}$.\n\nFinally, to highlight oscillations when the stencil crosses a shock, consider a dimensionless fusion edge profile with a discontinuity: take $\\bar{u}_{i-1} = 1$, $\\bar{u}_i = 0$, and $\\bar{u}_{i+1} = 0$, and compute the numerical value of the reconstructed $u_{i+1/2}^-$. Explain briefly why this outcome indicates oscillatory behavior of the linear third-order reconstruction across a discontinuity, and comment (qualitatively) on how Weighted Essentially Non-Oscillatory (WENO) schemes would modify the stencil contribution in this situation.\n\nState your final answer as the explicit closed-form expression for $u_{i+1/2}^-$ in terms of $\\bar{u}_{i-1}$, $\\bar{u}_i$, and $\\bar{u}_{i+1}$. No rounding is required, and no units are needed.",
            "solution": "The problem is valid as it is scientifically grounded, well-posed, and objective. It poses a standard, non-trivial problem in the field of numerical methods for hyperbolic conservation laws, specifically focusing on high-order polynomial reconstruction, which is a foundational concept for schemes like WENO used in computational science and engineering.\n\nThe process to solve the problem involves three main steps: 1) defining a quadratic polynomial and setting up a system of linear equations based on the given cell average constraints; 2) solving this system to find the polynomial's coefficients in terms of the cell averages; and 3) evaluating the polynomial at the cell interface to find the desired reconstructed value.\n\nLet the uniform grid have cell spacing $\\Delta x$. We define a local coordinate $\\xi$ centered in cell $i$, such that $x = x_i + \\xi \\Delta x$. In this local coordinate system, cell $i$ corresponds to $\\xi \\in [-\\frac{1}{2}, \\frac{1}{2}]$, cell $i-1$ to $\\xi \\in [-\\frac{3}{2}, -\\frac{1}{2}]$, and cell $i+1$ to $\\xi \\in [\\frac{1}{2}, \\frac{3}{2}]$.\n\nWe seek a quadratic polynomial $p_i(x)$, which we write in terms of the local coordinate $\\xi$ as:\n$$\np_i(\\xi) = a_0 + a_1 \\xi + a_2 \\xi^2\n$$\nThe coefficients $a_0$, $a_1$, and $a_2$ are determined by the constraint that the average of this single polynomial over each of the three cells in the stencil $\\{\\text{cell } i-1, \\text{cell } i, \\text{cell } i+1\\}$ must equal the corresponding known cell average $\\{\\bar{u}_{i-1}, \\bar{u}_i, \\bar{u}_{i+1}\\}$.\n\nThe average of a function $g(\\xi)$ over an interval $[\\alpha, \\beta]$ is $\\frac{1}{\\beta-\\alpha} \\int_\\alpha^\\beta g(\\xi) d\\xi$. Since our intervals have length $1$ in the $\\xi$ coordinate, the average is simply the integral.\n\n1.  **Constraint on cell $i$**: The average of $p_i(\\xi)$ over cell $i$ ($[-\\frac{1}{2}, \\frac{1}{2}]$) must be $\\bar{u}_i$.\n    $$\n    \\bar{u}_i = \\int_{-1/2}^{1/2} (a_0 + a_1 \\xi + a_2 \\xi^2) \\, d\\xi = [a_0 \\xi + \\frac{a_1}{2}\\xi^2 + \\frac{a_2}{3}\\xi^3]_{-1/2}^{1/2}\n    $$\n    $$\n    \\bar{u}_i = a_0(\\frac{1}{2} - (-\\frac{1}{2})) + \\frac{a_1}{2}((\\frac{1}{2})^2 - (-\\frac{1}{2})^2) + \\frac{a_2}{3}((\\frac{1}{2})^3 - (-\\frac{1}{2})^3) = a_0(1) + \\frac{a_1}{2}(0) + \\frac{a_2}{3}(\\frac{1}{8} + \\frac{1}{8})\n    $$\n    $$\n    \\bar{u}_i = a_0 + \\frac{a_2}{12} \\quad (1)\n    $$\n\n2.  **Constraint on cell $i+1$**: The average of $p_i(\\xi)$ over cell $i+1$ ($[\\frac{1}{2}, \\frac{3}{2}]$) must be $\\bar{u}_{i+1}$.\n    $$\n    \\bar{u}_{i+1} = \\int_{1/2}^{3/2} (a_0 + a_1 \\xi + a_2 \\xi^2) \\, d\\xi = [a_0 \\xi + \\frac{a_1}{2}\\xi^2 + \\frac{a_2}{3}\\xi^3]_{1/2}^{3/2}\n    $$\n    $$\n    \\bar{u}_{i+1} = a_0(\\frac{3}{2} - \\frac{1}{2}) + \\frac{a_1}{2}((\\frac{3}{2})^2 - (\\frac{1}{2})^2) + \\frac{a_2}{3}((\\frac{3}{2})^3 - (\\frac{1}{2})^3) = a_0(1) + \\frac{a_1}{2}(\\frac{9}{4} - \\frac{1}{4}) + \\frac{a_2}{3}(\\frac{27}{8} - \\frac{1}{8})\n    $$\n    $$\n    \\bar{u}_{i+1} = a_0 + a_1 + \\frac{13}{12} a_2 \\quad (2)\n    $$\n\n3.  **Constraint on cell $i-1$**: The average of $p_i(\\xi)$ over cell $i-1$ ($[-\\frac{3}{2}, -\\frac{1}{2}]$) must be $\\bar{u}_{i-1}$.\n    $$\n    \\bar{u}_{i-1} = \\int_{-3/2}^{-1/2} (a_0 + a_1 \\xi + a_2 \\xi^2) \\, d\\xi = [a_0 \\xi + \\frac{a_1}{2}\\xi^2 + \\frac{a_2}{3}\\xi^3]_{-3/2}^{-1/2}\n    $$\n    $$\n    \\bar{u}_{i-1} = a_0(-\\frac{1}{2} - (-\\frac{3}{2})) + \\frac{a_1}{2}((-\\frac{1}{2})^2 - (-\\frac{3}{2})^2) + \\frac{a_2}{3}((-\\frac{1}{2})^3 - (-\\frac{3}{2})^3) = a_0(1) + \\frac{a_1}{2}(\\frac{1}{4} - \\frac{9}{4}) + \\frac{a_2}{3}(-\\frac{1}{8} + \\frac{27}{8})\n    $$\n    $$\n    \\bar{u}_{i-1} = a_0 - a_1 + \\frac{13}{12} a_2 \\quad (3)\n    $$\n\nWe now solve the system of linear equations $(1)$, $(2)$, and $(3)$ for $a_0, a_1, a_2$.\nSubtracting equation $(3)$ from $(2)$:\n$$\n\\bar{u}_{i+1} - \\bar{u}_{i-1} = (a_0 + a_1 + \\frac{13}{12} a_2) - (a_0 - a_1 + \\frac{13}{12} a_2) = 2 a_1\n$$\n$$\na_1 = \\frac{1}{2}(\\bar{u}_{i+1} - \\bar{u}_{i-1})\n$$\nAdding equations $(2)$ and $(3)$:\n$$\n\\bar{u}_{i+1} + \\bar{u}_{i-1} = (a_0 + a_1 + \\frac{13}{12} a_2) + (a_0 - a_1 + \\frac{13}{12} a_2) = 2 a_0 + \\frac{13}{6} a_2\n$$\nFrom equation $(1)$, we have $a_0 = \\bar{u}_i - \\frac{a_2}{12}$. Substituting this into the summed equation:\n$$\n\\bar{u}_{i+1} + \\bar{u}_{i-1} = 2(\\bar{u}_i - \\frac{a_2}{12}) + \\frac{13}{6} a_2 = 2\\bar{u}_i - \\frac{1}{6} a_2 + \\frac{13}{6} a_2 = 2\\bar{u}_i + \\frac{12}{6} a_2 = 2\\bar{u}_i + 2 a_2\n$$\nRearranging to solve for $a_2$:\n$$\n2 a_2 = \\bar{u}_{i+1} - 2\\bar{u}_i + \\bar{u}_{i-1}\n$$\n$$\na_2 = \\frac{1}{2}(\\bar{u}_{i-1} - 2\\bar{u}_i + \\bar{u}_{i+1})\n$$\nHaving found $a_1$ and $a_2$, we can find $a_0$ from equation (1):\n$$\na_0 = \\bar{u}_i - \\frac{1}{12} a_2 = \\bar{u}_i - \\frac{1}{24}(\\bar{u}_{i-1} - 2\\bar{u}_i + \\bar{u}_{i+1})\n$$\nThe problem asks for the left-sided point value at the interface $x_{i+1/2}$, which is $u_{i+1/2}^- = p_i(x_{i+1/2})$. In the local coordinate system, $x_{i+1/2}$ corresponds to $\\xi = \\frac{1}{2}$. We evaluate $p_i(\\frac{1}{2})$:\n$$\nu_{i+1/2}^- = p_i(\\xi=\\frac{1}{2}) = a_0 + a_1(\\frac{1}{2}) + a_2(\\frac{1}{2})^2 = a_0 + \\frac{1}{2} a_1 + \\frac{1}{4} a_2\n$$\nSubstituting the expressions for the coefficients:\n$$\nu_{i+1/2}^- = \\left( \\bar{u}_i - \\frac{1}{24}(\\bar{u}_{i-1} - 2\\bar{u}_i + \\bar{u}_{i+1}) \\right) + \\frac{1}{2} \\left( \\frac{1}{2}(\\bar{u}_{i+1} - \\bar{u}_{i-1}) \\right) + \\frac{1}{4} \\left( \\frac{1}{2}(\\bar{u}_{i-1} - 2\\bar{u}_i + \\bar{u}_{i+1}) \\right)\n$$\n$$\nu_{i+1/2}^- = \\bar{u}_i - \\frac{1}{24}(\\bar{u}_{i-1} - 2\\bar{u}_i + \\bar{u}_{i+1}) + \\frac{1}{4}(\\bar{u}_{i+1} - \\bar{u}_{i-1}) + \\frac{1}{8}(\\bar{u}_{i-1} - 2\\bar{u}_i + \\bar{u}_{i+1})\n$$\nCollecting terms for each cell average $\\bar{u}_j$:\n- For $\\bar{u}_{i-1}$: $-\\frac{1}{24} - \\frac{1}{4} + \\frac{1}{8} = \\frac{-1 - 6 + 3}{24} = -\\frac{4}{24} = -\\frac{1}{6}$\n- For $\\bar{u}_i$: $1 - \\frac{-2}{24} - \\frac{2}{8} = 1 + \\frac{1}{12} - \\frac{1}{4} = \\frac{12 + 1 - 3}{12} = \\frac{10}{12} = \\frac{5}{6}$\n- For $\\bar{u}_{i+1}$: $-\\frac{1}{24} + \\frac{1}{4} + \\frac{1}{8} = \\frac{-1 + 6 + 3}{24} = \\frac{8}{24} = \\frac{1}{3}$\n\nCombining these coefficients gives the closed-form expression for the reconstructed value:\n$$\nu_{i+1/2}^- = -\\frac{1}{6}\\bar{u}_{i-1} + \\frac{5}{6}\\bar{u}_i + \\frac{1}{3}\\bar{u}_{i+1}\n$$\n\nFor the final part of the problem, we consider a profile with a discontinuity where $\\bar{u}_{i-1} = 1$, $\\bar{u}_i = 0$, and $\\bar{u}_{i+1} = 0$. Substituting these values into the formula:\n$$\nu_{i+1/2}^- = -\\frac{1}{6}(1) + \\frac{5}{6}(0) + \\frac{1}{3}(0) = -\\frac{1}{6}\n$$\nThis result indicates oscillatory behavior. The input cell averages are all non-negative ($1$ and $0$). However, the high-order polynomial reconstruction produces a negative value, $-\\frac{1}{6}$, which is an undershoot. For physical quantities like density or temperature, this would be an unphysical result. This is a manifestation of the Gibbs phenomenon, where a smooth function (the polynomial) attempts to approximate a discontinuity, leading to oscillations.\n\nA Weighted Essentially Non-Oscillatory (WENO) scheme is designed to prevent this. Instead of using one fixed stencil, WENO considers multiple candidate stencils (e.g., $\\{\\bar{u}_{i-2}, \\bar{u}_{i-1}, \\bar{u}_i\\}$, $\\{\\bar{u}_{i-1}, \\bar{u}_i, \\bar{u}_{i+1}\\}$, $\\{\\bar{u}_i, \\bar{u}_{i+1}, \\bar{u}_{i+2}\\}$). It computes a \"smoothness indicator\" for each stencil. The stencil that crosses the shock, $\\{\\bar{u}_{i-1}, \\bar{u}_i, \\bar{u}_{i+1}\\} = \\{1, 0, 0\\}$, is highly non-smooth and its smoothness indicator would be large. A stencil lying in a smooth region, such as $\\{\\bar{u}_i, \\bar{u}_i, \\bar{u}_{i+2}\\} = \\{0, 0, 0\\}$ (assuming the shock has passed), is perfectly smooth and has a small indicator. WENO then assigns a nonlinear weight to the reconstruction from each stencil, giving a very small weight to the oscillatory one and a large weight to the smooth ones. The final reconstructed value is a weighted average that is dominated by the contribution from the smoothest stencil(s), effectively suppressing the oscillations and producing a value close to $0$ in this case.\n\nThe final answer required is the closed-form expression for $u_{i+1/2}^-$.",
            "answer": "$$\n\\boxed{-\\frac{1}{6}\\bar{u}_{i-1} + \\frac{5}{6}\\bar{u}_i + \\frac{1}{3}\\bar{u}_{i+1}}\n$$"
        },
        {
            "introduction": "Having seen the failure of fixed-stencil reconstructions, we now turn to the adaptive logic at the heart of Weighted Essentially Non-Oscillatory (WENO) schemes. This computational practice  involves implementing the fifth-order WENO-JS algorithm to see its mechanism in action on a steep but continuous profile, a common feature in fusion plasma pedestals. By calculating the smoothness indicators and nonlinear weights, you will directly observe how WENO penalizes stencils crossing sharp gradients to suppress oscillations, while automatically reverting to a high-order linear scheme in smooth regions.",
            "id": "4065296",
            "problem": "Consider one-dimensional scalar advection governed by the conservation law $u_t + a u_x = 0$ with constant advection speed $a$. In computational fusion science and engineering, steep but continuous edge gradients arise, for example, in pedestal-like profiles. Weighted Essentially Non-Oscillatory (WENO) schemes are designed to reconstruct high-order interface values while attenuating spurious oscillations near shocks or sharp edges.\n\nStarting from the fundamental definition of conservation laws and the need to reconstruct interface states for numerical fluxes on a uniform grid, derive and implement the fifth-order Weighted Essentially Non-Oscillatory-Jiang-Shu (WENO-JS) procedure to reconstruct the left state at the interface $x_{i+1/2}$ from point samples $u_i = u(x_i)$ on a uniform grid with periodic boundary conditions and grid spacing $\\Delta x$. Use the standard left-biased three-stencil reconstruction, the WENO-JS smoothness indicators $\\beta_k$ ($k \\in \\{0,1,2\\}$) as derived from local polynomial approximations on candidate stencils, the nonlinear weights defined by $\\alpha_k = d_k / (\\varepsilon + \\beta_k)^p$ and $\\omega_k = \\alpha_k / \\sum_{m=0}^2 \\alpha_m$, and the ideal linear weights $d_0 = 1/10$, $d_1 = 6/10$, $d_2 = 3/10$. Choose $p = 2$ and $\\varepsilon = 10^{-6}$. Do not use any flux splitting beyond the left-state reconstruction.\n\nInvestigate the effect of a sharp but continuous edge by taking the profile $u(x) = \\tanh\\!\\left(\\dfrac{x - x_0}{\\delta}\\right)$ on the periodic domain $x \\in [0,1]$. For each test case, let $N$ be the number of uniformly spaced grid points, $x_j = j \\Delta x$ for $j \\in \\{0,1,\\dots,N-1\\}$, $x_0$ the edge location, and $\\delta$ the gradient-controlling parameter. Treat all quantities as dimensionless; no physical units are involved.\n\nFor each test case, perform the following steps:\n- Compute the discrete samples $u_j = u(x_j)$ for $j = 0,1,\\dots,N-1$.\n- Identify the index $i^\\ast$ that minimizes $|x_i - x_0|$ (the \"edge cell\").\n- Identify a \"smooth cell\" index $i_s$ as the index with $x_i$ closest to $0.1$.\n- At $i^\\ast$ and at $i_s$, compute the WENO-JS smoothness indicators $\\beta_0$, $\\beta_1$, $\\beta_2$ using periodic indexing for the necessary neighbor values.\n- At $i^\\ast$ and at $i_s$, compute the nonlinear weights $\\omega_k$ from the $\\beta_k$ and the given $(p,\\varepsilon,d_k)$.\n- Define the following three test metrics:\n  1. $R = \\dfrac{\\beta_0 + \\beta_1 + \\beta_2 \\ \\text{at}\\ i^\\ast}{\\beta_0 + \\beta_1 + \\beta_2 \\ \\text{at}\\ i_s}$, which measures the relative amplification of smoothness indicators near the edge.\n  2. $D_{\\text{edge}} = \\sum_{k=0}^2 \\left|\\omega_k(i^\\ast) - d_k\\right|$, which measures deviation of nonlinear weights from the ideal linear weights near the edge.\n  3. $D_{\\text{smooth}} = \\sum_{k=0}^2 \\left|\\omega_k(i_s) - d_k\\right|$, which measures deviation of nonlinear weights from the ideal linear weights in a smooth region.\n\nInterpretation requirement: Use first principles of polynomial reconstruction and smoothness indicators to explain why, for a sharp but continuous edge, the smoothness indicators penalize stencils crossing the edge (increasing $\\beta_k$), thereby reducing the corresponding nonlinear weights and attenuating oscillations, while in smooth regions the indicators remain small and comparable across stencils, yielding $\\omega_k \\approx d_k$ and recovering high-order accuracy.\n\nTest Suite:\n- Test Case $1$: $N = 200$, $x_0 = 0.5$, $\\delta = 0.02$.\n- Test Case $2$: $N = 200$, $x_0 = 0.47$, $\\delta = 0.05$.\n- Test Case $3$: $N = 200$, $x_0 = 0.5$, $\\delta = 0.20$.\n\nAnswer specifications:\n- For each test case, compute the three metrics $(R, D_{\\text{edge}}, D_{\\text{smooth}})$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered by test case and metric: $[R_1, D_{\\text{edge},1}, D_{\\text{smooth},1}, R_2, D_{\\text{edge},2}, D_{\\text{smooth},2}, R_3, D_{\\text{edge},3}, D_{\\text{smooth},3}]$.",
            "solution": "The problem requires the derivation and implementation of the fifth-order Weighted Essentially Non-Oscillatory-Jiang-Shu (WENO-JS) reconstruction procedure to analyze its behavior on a sharp but continuous edge profile, motivated by applications in computational fusion science. The analysis will be conducted by computing specific metrics related to the scheme's smoothness indicators and nonlinear weights.\n\n### 1. Theoretical Framework: WENO-JS Reconstruction\n\nWe consider the one-dimensional scalar advection equation, $u_t + a u_x = 0$, on a uniform grid $\\{x_i\\}$ with spacing $\\Delta x$. Numerical schemes for this equation, particularly those based on finite volume or finite difference methods, require the reconstruction of solution values at cell interfaces, e.g., $x_{i+1/2} = x_i + \\Delta x/2$. The WENO methodology provides a high-order, non-oscillatory reconstruction by adaptively combining several lower-order reconstructions.\n\nFor a fifth-order accurate scheme, we use a global stencil of five points. To reconstruct the state at the interface $x_{i+1/2}$ from the left (assuming advection speed $a  0$), we use the left-biased stencil $\\{u_{i-2}, u_{i-1}, u_i, u_{i+1}, u_{i+2}\\}$. This global stencil is partitioned into three candidate stencils, each containing three points:\n-   $S_0 = \\{x_{i-2}, x_{i-1}, x_i\\}$\n-   $S_1 = \\{x_{i-1}, x_i, x_{i+1}\\}$\n-   $S_2 = \\{x_i, x_{i+1}, x_{i+2}\\}$\n\nOn each stencil $S_k$, a unique quadratic polynomial $p_k(x)$ is constructed that interpolates the solution values at the corresponding grid points. These polynomials provide third-order candidate reconstructions of the interface value $u_{i+1/2}$, denoted $\\hat{u}_{i+1/2}^{(k)}$. The explicit formulas for these reconstructions are:\n$$ \\hat{u}_{i+1/2}^{(0)} = \\frac{1}{3}u_{i-2} - \\frac{7}{6}u_{i-1} + \\frac{11}{6}u_i $$\n$$ \\hat{u}_{i+1/2}^{(1)} = -\\frac{1}{6}u_{i-1} + \\frac{5}{6}u_{i} + \\frac{1}{3}u_{i+1} $$\n$$ \\hat{u}_{i+1/2}^{(2)} = \\frac{1}{3}u_{i} + \\frac{5}{6}u_{i+1} - \\frac{1}{6}u_{i+2} $$\n\nThe final fifth-order reconstruction is a convex combination of these candidate values:\n$$ u_{i+1/2} = \\sum_{k=0}^{2} \\omega_k \\hat{u}_{i+1/2}^{(k)} $$\nwhere $\\omega_k$ are the nonlinear weights.\n\n### 2. Smoothness Indicators and Nonlinear Weights\n\nThe core of the WENO scheme lies in the definition of the weights $\\omega_k$. They are designed to depend on the smoothness of the function represented by the interpolating polynomial $p_k(x)$ over its corresponding stencil $S_k$.\n\n**Smoothness Indicators ($\\beta_k$)**: The smoothness of each polynomial $p_k(x)$ is measured by a smoothness indicator, $\\beta_k$. The standard definition for $\\beta_k$ sums the normalized squared $L^2$-norms of the derivatives of $p_k(x)$ over the interval $[x_{i-1/2}, x_{i+1/2}]$:\n$$ \\beta_k = \\sum_{l=1}^{2} \\int_{x_{i-1/2}}^{x_{i+1/2}} (\\Delta x)^{2l-1} \\left( \\frac{d^l p_k(x)}{dx^l} \\right)^2 dx $$\nFor a uniform grid, these integrals can be evaluated explicitly in terms of the point values $u_j$. The resulting formulas are:\n$$ \\beta_0 = \\frac{13}{12}(u_{i-2} - 2u_{i-1} + u_i)^2 + \\frac{1}{4}(u_{i-2} - 4u_{i-1} + 3u_i)^2 $$\n$$ \\beta_1 = \\frac{13}{12}(u_{i-1} - 2u_i + u_{i+1})^2 + \\frac{1}{4}(u_{i-1} - u_{i+1})^2 $$\n$$ \\beta_2 = \\frac{13}{12}(u_i - 2u_{i+1} + u_{i+2})^2 + \\frac{1}{4}(3u_i - 4u_{i+1} + u_{i+2})^2 $$\nEach term in the $\\beta_k$ expressions approximates scaled derivatives of the solution. For example, $(u_{i-1} - 2u_i + u_{i+1})$ is proportional to a second derivative, while $(u_{i+1} - u_{i-1})$ is proportional to a first derivative. Thus, $\\beta_k$ is large if the solution exhibits large derivatives (i.e., is non-smooth) on the stencil $S_k$.\n\n**Nonlinear Weights ($\\omega_k$)**: The nonlinear weights $\\omega_k$ are calculated from the smoothness indicators $\\beta_k$. The process begins with ideal linear weights, $d_k$, which are chosen such that if $\\omega_k = d_k$, the reconstruction is fifth-order accurate in smooth regions. The problem specifies $d_0 = 1/10$, $d_1 = 6/10$, and $d_2 = 3/10$. Note that $\\sum d_k = 1$.\n\nThe nonlinear weights are computed as follows:\n1.  Un-normalized weights $\\alpha_k$ are defined:\n    $$ \\alpha_k = \\frac{d_k}{(\\varepsilon + \\beta_k)^p} $$\n    Here, $\\varepsilon$ is a small positive number to prevent division by zero in perfectly smooth regions (where $\\beta_k=0$), and $p$ is a positive integer that controls the sensitivity of the weights to the smoothness indicators. The problem specifies $p=2$ and $\\varepsilon=10^{-6}$.\n\n2.  The final normalized weights $\\omega_k$ are computed by:\n    $$ \\omega_k = \\frac{\\alpha_k}{\\sum_{m=0}^{2} \\alpha_m} $$\n    This ensures that $\\sum \\omega_k = 1$, making the final reconstruction a convex combination.\n\n### 3. Interpretation of WENO-JS Behavior\n\nThe design of the WENO-JS weights provides its adaptive, non-oscillatory character.\n\n-   **In Smooth Regions**: Where the solution $u(x)$ is smooth, the derivatives are small. Consequently, the smoothness indicators $\\beta_k$ for all three overlapping stencils will be small and of similar magnitude ($\\beta_k \\approx 0$). In this case, $\\alpha_k \\approx d_k / \\varepsilon^p$. The normalization step then yields:\n    $$ \\omega_k = \\frac{d_k/\\varepsilon^p}{\\sum_m d_m/\\varepsilon^p} = \\frac{d_k}{\\sum_m d_m} = d_k $$\n    The nonlinear weights approximate the ideal linear weights, and the scheme recovers the optimal fifth-order accuracy of the underlying linear reconstruction. The metric $D_{\\text{smooth}}$, which measures the deviation $|\\omega_k - d_k|$, will be very small.\n\n-   **Near Sharp Edges**: Near a steep gradient or discontinuity, at least one stencil will cross this feature. For that stencil, say $S_j$, the interpolating polynomial $p_j(x)$ must accommodate a large variation, leading to large derivatives. This results in a very large value for the corresponding smoothness indicator, $\\beta_j \\gg \\varepsilon$. The un-normalized weight $\\alpha_j = d_j/(\\varepsilon+\\beta_j)^p$ becomes extremely small. Consequently, the final weight $\\omega_j$ also becomes nearly zero. The scheme effectively \"switches off\" the contribution from the non-smooth stencil, assigning its weight to the stencils that lie in smoother regions. This dynamic re-weighting prevents the use of high-order polynomials across sharp features, which would otherwise introduce spurious oscillations (Gibbs phenomenon). The metrics $R$ and $D_{\\text{edge}}$ will be large, reflecting the large $\\beta$ values and the significant deviation of $\\omega_k$ from the ideal weights $d_k$.\n\n### 4. Implementation for Test Cases\n\nThe provided test cases use the profile $u(x) = \\tanh((x - x_0)/\\delta)$ on a periodic domain $[0,1]$. We will discretize this function on a grid of $N$ points and compute the smoothness indicators and weights at a point near the edge center ($i^\\ast$) and a point in a smooth region ($i_s$). The calculation requires access to five neighboring points $\\{u_{j-2}, \\dots, u_{j+2}\\}$ for a given index $j$. On a periodic domain, indices are handled using the modulo operator, e.g., $u_{j \\pmod N}$. The specified metrics $R$, $D_{\\text{edge}}$, and $D_{\\text{smooth}}$ are then computed based on these quantities.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# No other libraries are permitted.\n\ndef solve():\n    \"\"\"\n    Computes WENO-JS metrics for given test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (200, 0.5, 0.02),  # Test Case 1: N, x0, delta\n        (200, 0.47, 0.05), # Test Case 2\n        (200, 0.5, 0.20),  # Test Case 3\n    ]\n\n    # WENO-JS parameters\n    d_k = np.array([0.1, 0.6, 0.3])\n    p = 2\n    epsilon = 1e-6\n\n    full_results = []\n\n    def compute_weno_quantities(i, u_data, N):\n        \"\"\"\n        Computes WENO smoothness indicators and nonlinear weights for index i.\n        \n        Args:\n            i (int): The index for which to compute the reconstruction stencil.\n            u_data (np.array): The array of discrete solution values.\n            N (int): The number of grid points.\n\n        Returns:\n            tuple: A tuple containing (betas, omegas) as numpy arrays.\n        \"\"\"\n        # Get the 5-point stencil using periodic boundary conditions\n        # The modulo operator handles periodicity correctly.\n        um2 = u_data[(i - 2) % N]\n        um1 = u_data[(i - 1) % N]\n        ui0 = u_data[i % N]\n        up1 = u_data[(i + 1) % N]\n        up2 = u_data[(i + 2) % N]\n\n        # Calculate smoothness indicators (beta_k)\n        beta0 = (13./12.) * (um2 - 2*um1 + ui0)**2 + (1./4.) * (um2 - 4*um1 + 3*ui0)**2\n        beta1 = (13./12.) * (um1 - 2*ui0 + up1)**2 + (1./4.) * (um1 - up1)**2\n        beta2 = (13./12.) * (ui0 - 2*up1 + up2)**2 + (1./4.) * (3*ui0 - 4*up1 + up2)**2\n        betas = np.array([beta0, beta1, beta2])\n\n        # Calculate nonlinear weights (omega_k)\n        alphas = d_k / (epsilon + betas)**p\n        alpha_sum = np.sum(alphas)\n        omegas = alphas / alpha_sum\n        \n        return betas, omegas\n\n    for case in test_cases:\n        N, x0, delta = case\n        \n        # 1. Compute discrete samples\n        dx = 1.0 / N\n        x = np.linspace(0, 1.0 - dx, N)\n        u = np.tanh((x - x0) / delta)\n        \n        # 2. Identify indices i_star (edge) and i_s (smooth)\n        i_star = np.argmin(np.abs(x - x0))\n        i_s = np.argmin(np.abs(x - 0.1))\n\n        # 3. Compute smoothness indicators and weights at i_star and i_s\n        betas_edge, omegas_edge = compute_weno_quantities(i_star, u, N)\n        betas_smooth, omegas_smooth = compute_weno_quantities(i_s, u, N)\n        \n        # 4. Compute the three test metrics\n        # Metric 1: R\n        sum_beta_edge = np.sum(betas_edge)\n        sum_beta_smooth = np.sum(betas_smooth)\n        R = sum_beta_edge / sum_beta_smooth if sum_beta_smooth != 0 else float('inf')\n\n        # Metric 2: D_edge\n        D_edge = np.sum(np.abs(omegas_edge - d_k))\n\n        # Metric 3: D_smooth\n        D_smooth = np.sum(np.abs(omegas_smooth - d_k))\n\n        full_results.extend([R, D_edge, D_smooth])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, full_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The final practice moves from understanding the WENO mechanism to its practical application and evaluation in a scenario directly relevant to fusion energy science. This exercise  challenges you to implement and compare the classic WENO-JS scheme against a more recent variant, WENO-Z, for reconstructing steep density and temperature profiles found at the plasma edge. By quantifying performance through critical metrics like edge location accuracy and the suppression of unphysical overshoots, you will develop the skills to critically assess which numerical tool is best suited for a given computational science problem.",
            "id": "4065384",
            "problem": "Consider a one-dimensional radial-like coordinate $x \\in [0,1]$ measured in meters, representing a flux-surface label in a magnetically confined fusion plasma. The core-edge transition is modeled by steep gradients in the plasma density $n(x)$ (in $\\mathrm{m}^{-3}$) and electron temperature $T(x)$ (in $\\mathrm{eV}$). The goal is to compare two high-order, non-oscillatory finite-volume reconstructions widely used for hyperbolic conservation laws with shocks and edges: the Jiang–Shu Weighted Essentially Non-Oscillatory ($\\mathrm{WENO\\!-\\!JS}$) scheme and the $\\mathrm{WENO\\!-\\!Z}$ scheme. The principles should be derived from the conservation form and smoothness selection principles, not from pre-provided formulas.\n\nStart from the following bases:\n\n- The conservation law form for advection in one dimension, $\\partial_t u + \\partial_x f(u) = 0$, motivates reconstructing interfacial states $u_{i+1/2}^{L}$ and $u_{i+1/2}^{R}$ using high-order biased polynomials on cell-centered data $u_i$ sampled on a uniform grid with spacing $\\Delta x$.\n- The Essentially Non-Oscillatory (ENO) and Weighted Essentially Non-Oscillatory (WENO) methodology select among candidate stencils by smoothness arguments (low-variation bias) to avoid Gibbs-like oscillations near steep gradients or discontinuities.\n\nYou must implement $5$th-order reconstructions of left states $u_{i+1/2}^{L}$ at cell interfaces for both $\\mathrm{WENO\\!-\\!JS}$ and $\\mathrm{WENO\\!-\\!Z}$, operating on cell-centered samples of the following fusion-relevant edge profiles:\n$$\nS(x) = \\tfrac{1}{2}\\left(1 + \\tanh\\!\\left(\\frac{x_0 - x}{w}\\right)\\right),\\quad\nn(x) = n_{\\mathrm{sep}} + \\left(n_{\\mathrm{core}} - n_{\\mathrm{sep}}\\right) S(x),\\quad\nT(x) = T_{\\mathrm{sep}} + \\left(T_{\\mathrm{core}} - T_{\\mathrm{sep}}\\right) S(x),\n$$\nwhere $x_0$ is the edge location (in meters) and $w$ sets the gradient width (in meters). Use $x_0 = 0.7$ and the physically plausible parameters $n_{\\mathrm{core}} = 9\\times 10^{19}\\ \\mathrm{m}^{-3}$, $n_{\\mathrm{sep}} = 1\\times 10^{19}\\ \\mathrm{m}^{-3}$, $T_{\\mathrm{core}} = 5\\times 10^{3}\\ \\mathrm{eV}$, and $T_{\\mathrm{sep}} = 50\\ \\mathrm{eV}$. Sample $n(x)$ and $T(x)$ on a uniform grid of $N$ cells over $[0,1]$ at cell centers $x_i = (i+\\tfrac{1}{2})\\Delta x$ with $\\Delta x = 1/N$ and populate two ghost cells on each boundary by evaluating the analytic profiles at ghost cell centers outside $[0,1]$.\n\nFor each scheme ($\\mathrm{WENO\\!-\\!JS}$ and $\\mathrm{WENO\\!-\\!Z}$), and for each field $n(x)$ and $T(x)$, compute:\n\n1. The estimated edge location $x_{\\mathrm{est}}$ (in meters) from the discrete gradient\n$$\nG_i = \\frac{\\left|u_{i+1/2}^{L} - u_{i-1/2}^{L}\\right|}{\\Delta x},\n$$\nevaluated at cell centers $i$ where the stencils are fully interior. Define $x_{\\mathrm{est}}$ as the cell-center position corresponding to $\\max_i G_i$. Then report the absolute edge-location error $|x_{\\mathrm{est}} - x_0|$ in meters.\n\n2. The overshoot amplitude (in physical units) measured on the set of reconstructed left states at interfaces, $\\{u_{i+1/2}^{L}\\}$, relative to the true variable bounds over $[0,1]$. For density, the true bounds are $[\\min(n_{\\mathrm{core}},n_{\\mathrm{sep}}),\\max(n_{\\mathrm{core}},n_{\\mathrm{sep}})]$ in $\\mathrm{m}^{-3}$; for temperature, they are $[\\min(T_{\\mathrm{core}},T_{\\mathrm{sep}}),\\max(T_{\\mathrm{core}},T_{\\mathrm{sep}})]$ in $\\mathrm{eV}$. Define the overshoot amplitude as\n$$\n\\mathrm{overshoot}(u) = \\max\\!\\left(\\, \\max_{i}\\{u_{i+1/2}^{L}\\} - u_{\\max}^{\\mathrm{true}},\\ u_{\\min}^{\\mathrm{true}} - \\min_{i}\\{u_{i+1/2}^{L}\\},\\ 0\\,\\right).\n$$\nExpress density overshoot in $\\mathrm{m}^{-3}$ and temperature overshoot in $\\mathrm{eV}$.\n\nImplement both reconstructions, apply them to $n(x)$ and $T(x)$, and report the metrics for the following test suite of parameter pairs $(N,w)$:\n\n- Test $1$: $N=256$, $w=0.02$.\n- Test $2$: $N=64$, $w=0.02$.\n- Test $3$: $N=256$, $w=0.005$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case in the order listed, append eight floating-point numbers in the exact order:\n$[\\,|x_{\\mathrm{est}} - x_0|_{\\mathrm{n,JS}},\\ |x_{\\mathrm{est}} - x_0|_{\\mathrm{n,Z}},\\ \\mathrm{overshoot}_{\\mathrm{n,JS}},\\ \\mathrm{overshoot}_{\\mathrm{n,Z}},\\ |x_{\\mathrm{est}} - x_0|_{\\mathrm{T,JS}},\\ |x_{\\mathrm{est}} - x_0|_{\\mathrm{T,Z}},\\ \\mathrm{overshoot}_{\\mathrm{T,JS}},\\ \\mathrm{overshoot}_{\\mathrm{T,Z}}\\,]$, with edge-location errors in meters, density overshoots in $\\mathrm{m}^{-3}$, and temperature overshoots in $\\mathrm{eV}$. Concatenate the results across all tests, producing one flat list. No other text should be printed.",
            "solution": "The user has provided a valid problem.\n\n### Step 1: Extract Givens\n- **Coordinate and Domain**: One-dimensional radial-like coordinate $x \\in [0,1]$ meters.\n- **Physical Profiles**:\n  - Shape function: $S(x) = \\tfrac{1}{2}\\left(1 + \\tanh\\!\\left(\\frac{x_0 - x}{w}\\right)\\right)$\n  - Density: $n(x) = n_{\\mathrm{sep}} + \\left(n_{\\mathrm{core}} - n_{\\mathrm{sep}}\\right) S(x)$ in $\\mathrm{m}^{-3}$.\n  - Temperature: $T(x) = T_{\\mathrm{sep}} + \\left(T_{\\mathrm{core}} - T_{\\mathrm{sep}}\\right) S(x)$ in $\\mathrm{eV}$.\n- **Profile Parameters**:\n  - Edge location: $x_0 = 0.7$ m.\n  - Gradient width: $w$ (variable, specified in tests).\n  - Core density: $n_{\\mathrm{core}} = 9\\times 10^{19}\\ \\mathrm{m}^{-3}$.\n  - Separatrix density: $n_{\\mathrm{sep}} = 1\\times 10^{19}\\ \\mathrm{m}^{-3}$.\n  - Core temperature: $T_{\\mathrm{core}} = 5\\times 10^{3}\\ \\mathrm{eV}$.\n  - Separatrix temperature: $T_{\\mathrm{sep}} = 50\\ \\mathrm{eV}$.\n- **Grid Discretization**:\n  - Uniform grid with $N$ cells (variable).\n  - Cell spacing: $\\Delta x = 1/N$.\n  - Cell centers: $x_i = (i+\\tfrac{1}{2})\\Delta x$ for physical cells $i=0, \\dots, N-1$.\n  - Ghost cells: Two ghost cells on each boundary, populated with analytic profile values at their respective centers.\n- **Numerical Schemes**: $5$th-order Weighted Essentially Non-Oscillatory schemes, $\\mathrm{WENO\\!-\\!JS}$ and $\\mathrm{WENO\\!-\\!Z}$, for reconstructing the left state $u_{i+1/2}^{L}$ at cell interfaces.\n- **Metrics to Compute**:\n  1.  **Absolute edge-location error**: $|x_{\\mathrm{est}} - x_0|$.\n      - The estimated edge location $x_{\\mathrm{est}}$ is the cell-center position $x_i$ that maximizes the discrete gradient $G_i$.\n      - Discrete gradient: $G_i = \\frac{\\left|u_{i+1/2}^{L} - u_{i-1/2}^{L}\\right|}{\\Delta x}$, evaluated at cell centers $i$ where stencils are fully interior.\n  2.  **Overshoot amplitude**: $\\mathrm{overshoot}(u) = \\max\\!\\left(\\, \\max_{i}\\{u_{i+1/2}^{L}\\} - u_{\\max}^{\\mathrm{true}},\\ u_{\\min}^{\\mathrm{true}} - \\min_{i}\\{u_{i+1/2}^{L}\\},\\ 0\\,\\right)$.\n      - True bounds for density: $[\\min(n_{\\mathrm{core}},n_{\\mathrm{sep}}),\\max(n_{\\mathrm{core}},n_{\\mathrm{sep}})]$.\n      - True bounds for temperature: $[\\min(T_{\\mathrm{core}},T_{\\mathrm{sep}}),\\max(T_{\\mathrm{core}},T_{\\mathrm{sep}})]$.\n- **Test Suite**:\n  - Test 1: $N=256$, $w=0.02$.\n  - Test 2: $N=64$, $w=0.02$.\n  - Test 3: $N=256$, $w=0.005$.\n- **Output Format**: A single flat comma-separated list of 24 floating-point numbers enclosed in square brackets, with results ordered as specified for each test case.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is grounded in the well-established field of numerical methods for hyperbolic conservation laws, a cornerstone of computational fluid dynamics and plasma physics. The $\\mathrm{WENO}$ schemes are standard, state-of-the-art methods. The plasma profiles are simplified but physically motivated models of the core-edge transition in a fusion device. The problem is scientifically sound.\n- **Well-Posed**: The problem is well-posed. The inputs are clearly defined, and the required calculations lead to a unique set of numerical outputs. The schemes and metrics are deterministic.\n- **Objective**: The problem is stated in objective, mathematical language. It requires quantitative comparison based on precisely defined metrics.\n- **Completeness**: The problem provides all necessary parameters, equations, and definitions to proceed with a solution. While some numerical parameters like the $\\epsilon$ in the WENO formulation are not specified, their choice is part of standard practice in implementing these schemes, and a reasonable, documented choice is acceptable. The phrase \"where the stencils are fully interior\" for the gradient calculation is slightly ambiguous but has a standard interpretation in this context (i.e., not at the very first physical cell boundary), which does not invalidate the problem.\n- **No other flaws are present.** The problem is not metaphorical, trivial, or unverifiable.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A complete, reasoned solution will be provided.\n\n### Solution Derivation and Implementation Strategy\n\nThe task is to implement and compare fifth-order $\\mathrm{WENO\\!-\\!JS}$ and $\\mathrm{WENO\\!-\\!Z}$ schemes. The solution begins from the principles of finite-volume methods for hyperbolic conservation laws of the form $\\partial_t u + \\partial_x f(u) = 0$.\n\nA finite-volume method evolves cell-averaged quantities $u_i(t) = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) dx$. The semi-discrete form of the conservation law is $\\frac{du_i}{dt} + \\frac{1}{\\Delta x}(\\hat{f}_{i+1/2} - \\hat{f}_{i-1/2}) = 0$, where $\\hat{f}_{i\\pm 1/2}$ are numerical fluxes at the cell interfaces. These fluxes are functions of the reconstructed states at the interface, $u_{i\\pm 1/2}^L$ and $u_{i\\pm 1/2}^R$. This problem focuses solely on the reconstruction step, specifically finding the left-biased state $u_{i+1/2}^L$.\n\nA high-order accurate and non-oscillatory reconstruction near discontinuities is achieved with $\\mathrm{WENO}$ schemes. A high-order reconstruction is built as a weighted average of several lower-order reconstructions over different stencils. This adaptive weighting is the key to avoiding spurious oscillations.\n\nFor a fifth-order reconstruction at interface $x_{i+1/2}$, we use a five-point stencil of cell averages $\\{u_{i-2}, u_{i-1}, u_i, u_{i+1}, u_{i+2}\\}$. This stencil contains three candidate three-point stencils, each supporting a quadratic polynomial:\n- Stencil $S_0: \\{u_{i-2}, u_{i-1}, u_i\\}$\n- Stencil $S_1: \\{u_{i-1}, u_i, u_{i+1}\\}$\n- Stencil $S_2: \\{u_i, u_{i+1}, u_{i+2}\\}$\n\nFor each stencil $S_k$, a polynomial $p_k(x)$ is constructed such that its cell average over cell $j$ equals $u_j$. Evaluating these polynomials at the interface $x_{i+1/2}$ yields three candidate reconstructions, $\\hat{u}_k = p_k(x_{i+1/2})$. The standard formulas for a uniform grid are:\n$$\n\\hat{u}_0 = \\frac{2}{6}u_{i-2} - \\frac{7}{6}u_{i-1} + \\frac{11}{6}u_i \\\\\n\\hat{u}_1 = -\\frac{1}{6}u_{i-1} + \\frac{5}{6}u_i + \\frac{2}{6}u_{i+1} \\\\\n\\hat{u}_2 = \\frac{2}{6}u_i + \\frac{5}{6}u_{i+1} - \\frac{1}{6}u_{i+2}\n$$\nThe final reconstructed value is a convex combination: $u_{i+1/2}^L = \\sum_{k=0}^2 \\omega_k \\hat{u}_k$. The weights $\\omega_k$ determine the properties of the scheme.\n\nIn a smooth region, the weights should approach a set of \"optimal\" linear weights, $\\{d_0, d_1, d_2\\}$, that combine the $\\hat{u}_k$ to form the unique fifth-order polynomial over the full five-point stencil. For the fifth-order scheme, these are:\n$$\nd_0 = \\frac{1}{10}, \\quad d_1 = \\frac{6}{10}, \\quad d_2 = \\frac{3}{10}\n$$\n\nNear discontinuities, the weights are adapted based on the smoothness of the data in each stencil. This smoothness is measured by smoothness indicators, $\\beta_k$, defined as a sum of squared, scaled derivatives of the reconstruction polynomial $p_k(x)$. The standard formulas are:\n$$\n\\beta_0 = \\frac{13}{12}(u_{i-2} - 2u_{i-1} + u_i)^2 + \\frac{1}{4}(u_{i-2} - 4u_{i-1} + 3u_i)^2 \\\\\n\\beta_1 = \\frac{13}{12}(u_{i-1} - 2u_i + u_{i+1})^2 + \\frac{1}{4}(u_{i-1} - u_{i+1})^2 \\\\\n\\beta_2 = \\frac{13}{12}(u_i - 2u_{i+1} + u_{i+2})^2 + \\frac{1}{4}(3u_i - 4u_{i+1} + u_{i+2})^2\n$$\nA smaller $\\beta_k$ indicates a smoother function on stencil $S_k$.\n\n**$\\mathrm{WENO\\!-\\!JS}$ Scheme (Jiang  Shu, 1996)**\nThe non-linear weights are designed to approach zero for stencils crossing a discontinuity (large $\\beta_k$).\n$$\n\\omega_k^{\\mathrm{JS}} = \\frac{\\alpha_k^{\\mathrm{JS}}}{\\sum_{j=0}^2 \\alpha_j^{\\mathrm{JS}}}, \\quad \\text{with} \\quad \\alpha_k^{\\mathrm{JS}} = \\frac{d_k}{(\\beta_k + \\epsilon)^p}\n$$\nHere, $\\epsilon$ is a small positive number to prevent division by zero, and the exponent $p$ controls the scheme's sensitivity to smoothness; $p=2$ is standard for a fifth-order scheme.\n\n**$\\mathrm{WENO\\!-\\!Z}$ Scheme (Borges et al., 2008)**\nThis scheme was designed to improve upon $\\mathrm{WENO\\!-\\!JS}$, which can exhibit a loss of accuracy at critical points of smooth functions. It modifies the unnormalized weights to achieve a higher order of accuracy in smooth regions.\nThe weights depend on a global smoothness indicator, $\\tau_5 = |\\beta_0 - \\beta_2|$, which measures the relative smoothness across the entire 5-point stencil.\n$$\n\\omega_k^{\\mathrm{Z}} = \\frac{\\alpha_k^{\\mathrm{Z}}}{\\sum_{j=0}^2 \\alpha_j^{\\mathrm{Z}}}, \\quad \\text{with} \\quad \\alpha_k^{\\mathrm{Z}} = d_k \\left(1 + \\left(\\frac{\\tau_5}{\\beta_k + \\epsilon}\\right)^q\\right)\n$$\nThe exponent $q$ is typically set to $1$ or $2$; we will use $q=1$. The term involving $\\tau_5$ enhances the weights' ability to revert to the optimal linear weights in smooth regions, improving accuracy. A small constant $\\epsilon=10^{-40}$ will be used for both schemes to handle the wide dynamic range of the input data without introducing artifacts.\n\n**Implementation Plan:**\nFor each test case $(N, w)$:\n1.  Define the grid of $N$ cells on $[0,1]$, with cell spacing $\\Delta x = 1/N$. Create an extended grid (size $N+4$) including two ghost cells on each side. The centers are $x_j = (j-2+0.5)\\Delta x$ for array index $j=0, \\dots, N+3$.\n2.  Populate arrays for cell-centered density $n$ and temperature $T$ on this extended grid using the provided analytical formulas.\n3.  For each field ($n$ and $T$), apply both the $\\mathrm{WENO\\!-\\!JS}$ and $\\mathrm{WENO\\!-\\!Z}$ reconstruction procedures. This will be done vectorially for efficiency. Shifted views of the data array will be used to represent the stencils for all interfaces simultaneously.\n4.  This yields four sets of reconstructed left-interface values: $\\{n_{i+1/2}^{L,\\mathrm{JS}}\\}$, $\\{n_{i+1/2}^{L,\\mathrm{Z}}\\}$, $\\{T_{i+1/2}^{L,\\mathrm{JS}}\\}$, and $\\{T_{i+1/2}^{L,\\mathrm{Z}}\\}$ for interfaces $i=0, \\dots, N-1$.\n5.  For each of the four sets of results, compute the required metrics:\n    a.  **Edge Location Error**: Calculate the discrete gradient $G_i$ for $i=1, \\dots, N-1$. Find the cell index $i_{\\max}$ where $G_i$ is maximal. The estimated location is the center of this cell, $x_{\\mathrm{est}} = (i_{\\max}+0.5)\\Delta x$. The error is $|x_{\\mathrm{est}} - x_0|$.\n    b.  **Overshoot Amplitude**: Find the maximum and minimum values in the set of reconstructed interface states. Compare these to the true physical bounds of the profile to calculate the overshoot as defined in the problem statement.\n6.  Collect the eight calculated metrics for the test case and append them to a results list.\n7.  After all test cases are processed, format the final list of $24$ values into the specified string format.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares 5th-order WENO-JS and WENO-Z schemes for reconstructing\n    fusion plasma edge profiles and computes specified performance metrics.\n    \"\"\"\n\n    # Physical and profile parameters\n    x0 = 0.7\n    n_core = 9e19\n    n_sep = 1e19\n    T_core = 5e3\n    T_sep = 50.0\n\n    n_max_true = max(n_core, n_sep)\n    n_min_true = min(n_core, n_sep)\n    T_max_true = max(T_core, T_sep)\n    T_min_true = min(T_core, T_sep)\n\n    # WENO-5 scheme constants\n    d0, d1, d2 = 0.1, 0.6, 0.3\n    eps = 1e-40 # Small constant for stability\n\n    test_cases = [\n        (256, 0.02),\n        (64, 0.02),\n        (256, 0.005),\n    ]\n\n    results = []\n\n    def S_profile(x, x0_val, w_val):\n        return 0.5 * (1.0 + np.tanh((x0_val - x) / w_val))\n\n    def get_reconstructions(u_data):\n        \"\"\"Computes WENO-JS and WENO-Z reconstructions for a given data array.\"\"\"\n        \n        # Slices for vectorized stencil operations.\n        # These correspond to u_{i-2}, u_{i-1}, u_{i}, u_{i+1}, u_{i+2} for i=0..N-1\n        u_im2 = u_data[0:-4]\n        u_im1 = u_data[1:-3]\n        u_i   = u_data[2:-2]\n        u_ip1 = u_data[3:-1]\n        u_ip2 = u_data[4:]\n\n        # Smoothness indicators (beta_k)\n        beta0 = (13./12.) * (u_im2 - 2*u_im1 + u_i)**2   + (1./4.) * (u_im2 - 4*u_im1 + 3*u_i)**2\n        beta1 = (13./12.) * (u_im1 - 2*u_i   + u_ip1)**2 + (1./4.) * (u_im1 - u_ip1)**2\n        beta2 = (13./12.) * (u_i   - 2*u_ip1 + u_ip2)**2 + (1./4.) * (3*u_i - 4*u_ip1 + u_ip2)**2\n\n        # Candidate reconstructions (u_hat_k)\n        u_hat0 = (2./6.)*u_im2 - (7./6.)*u_im1 + (11./6.)*u_i\n        u_hat1 = (-1./6.)*u_im1 + (5./6.)*u_i   + (2./6.)*u_ip1\n        u_hat2 = (2./6.)*u_i   + (5./6.)*u_ip1 - (1./6.)*u_ip2\n\n        # WENO-JS weights\n        p = 2\n        alpha0_js = d0 / (beta0 + eps)**p\n        alpha1_js = d1 / (beta1 + eps)**p\n        alpha2_js = d2 / (beta2 + eps)**p\n        sum_alpha_js = alpha0_js + alpha1_js + alpha2_js\n        \n        w0_js = alpha0_js / sum_alpha_js\n        w1_js = alpha1_js / sum_alpha_js\n        w2_js = alpha2_js / sum_alpha_js\n\n        u_L_js = w0_js * u_hat0 + w1_js * u_hat1 + w2_js * u_hat2\n\n        # WENO-Z weights\n        q = 1\n        tau5 = np.abs(beta0 - beta2)\n        alpha0_z = d0 * (1.0 + (tau5 / (beta0 + eps))**q)\n        alpha1_z = d1 * (1.0 + (tau5 / (beta1 + eps))**q)\n        alpha2_z = d2 * (1.0 + (tau5 / (beta2 + eps))**q)\n        sum_alpha_z = alpha0_z + alpha1_z + alpha2_z\n\n        w0_z = alpha0_z / sum_alpha_z\n        w1_z = alpha1_z / sum_alpha_z\n        w2_z = alpha2_z / sum_alpha_z\n\n        u_L_z = w0_z * u_hat0 + w1_z * u_hat1 + w2_z * u_hat2\n\n        return u_L_js, u_L_z\n\n    def calculate_metrics(u_L, dx, u_max_true, u_min_true):\n        \"\"\"Calculates edge location error and overshoot for a reconstruction.\"\"\"\n        # Gradient is computed at cell centers i=1..N-1\n        G = np.abs(u_L[1:] - u_L[:-1]) / dx\n        # argmax finds index in G (0 to N-2), corresponding to cell index i=1 to N-1\n        i_max_G = np.argmax(G)\n        i_cell_max_grad = i_max_G + 1\n        \n        x_est = (i_cell_max_grad + 0.5) * dx\n        edge_error = np.abs(x_est - x0)\n\n        overshoot = np.maximum(np.max(u_L) - u_max_true, u_min_true - np.min(u_L))\n        overshoot = np.maximum(overshoot, 0.0)\n        \n        return edge_error, overshoot\n\n    for N, w in test_cases:\n        dx = 1.0 / N\n        num_ghosts = 2\n        \n        # Grid indices i from -2 to N+1. Array index j = i + num_ghosts.\n        # Cell centers for physical domain (i=0..N-1) and ghost cells.\n        cell_indices = np.arange(-num_ghosts, N + num_ghosts)\n        x_centers = (cell_indices + 0.5) * dx\n\n        # Populate data arrays with profiles including ghost cells\n        S_vals = S_profile(x_centers, x0, w)\n        n_data = n_sep + (n_core - n_sep) * S_vals\n        T_data = T_sep + (T_core - T_sep) * S_vals\n\n        # Get reconstructions for density\n        n_L_js, n_L_z = get_reconstructions(n_data)\n        \n        # Calculate metrics for density\n        err_n_js, over_n_js = calculate_metrics(n_L_js, dx, n_max_true, n_min_true)\n        err_n_z, over_n_z = calculate_metrics(n_L_z, dx, n_max_true, n_min_true)\n\n        # Get reconstructions for temperature\n        T_L_js, T_L_z = get_reconstructions(T_data)\n\n        # Calculate metrics for temperature\n        err_T_js, over_T_js = calculate_metrics(T_L_js, dx, T_max_true, T_min_true)\n        err_T_z, over_T_z = calculate_metrics(T_L_z, dx, T_max_true, T_min_true)\n\n        results.extend([\n            err_n_js, err_n_z, over_n_js, over_n_z,\n            err_T_js, err_T_z, over_T_js, over_T_z\n        ])\n\n    # Format output as a single-line comma-separated list in brackets\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}