{
    "hands_on_practices": [
        {
            "introduction": "The power of Adaptive Mesh Refinement (AMR) lies in its ability to dynamically focus computational effort where it is most needed. This practice dives into the 'brain' of an AMR system: the refinement criterion itself . You will derive a physics-based trigger from quantities like current density and vorticity, and design a hysteresis policy to prevent inefficient grid 'thrashing', providing a robust foundation for the adaptive engine.",
            "id": "3946761",
            "problem": "You are tasked with designing a refinement threshold and a hysteresis policy for adaptive mesh refinement in a one-dimensional magnetohydrodynamics (MHD) plasma simulation using the current-density magnitude and vorticity. The aim is to decide, for each mesh cell and at each discrete time step, whether it should be flagged as refined or coarse, while preventing rapid oscillation of refinement decisions as the fields evolve. You must derive the thresholds from first principles and implement the hysteresis policy algorithmically.\n\nFundamental base and definitions:\n- Maxwell–Ampère law (quasi-static limit without displacement current): $\\nabla \\times \\mathbf{B} = \\mu_0 \\mathbf{J}$, where $\\mathbf{B}$ is magnetic field, $\\mathbf{J}$ is current density, and $\\mu_0$ is the permeability of free space.\n- Vorticity definition: $\\boldsymbol{\\omega} = \\nabla \\times \\mathbf{u}$, where $\\mathbf{u}$ is fluid velocity.\n- Characteristic scales: a reference magnetic-field magnitude $B_0$ (in Tesla, $\\,\\mathrm{T}$), a reference flow speed $U_0$ (in meters per second, $\\,\\mathrm{m/s}$), and a reference macroscopic length $L_0$ (in meters, $\\,\\mathrm{m}$).\n- Mesh spacing: $h$ (in meters, $\\,\\mathrm{m}$).\n- Current-density magnitude $J = \\|\\mathbf{J}\\|$ (in amperes per square meter, $\\,\\mathrm{A/m^2}$) and vorticity magnitude $\\omega = \\|\\boldsymbol{\\omega}\\|$ (in inverse seconds, $\\,\\mathrm{s^{-1}}$).\n\nDerivation mandate:\n- Starting from the above fundamental laws and definitions, derive a refinement threshold that responds to the smallest of the implied physical length scales associated with current sheets and shear layers. Use the fact that a magnetic variation over a length scale $\\ell_B$ implies $J \\sim B_0/(\\mu_0 \\ell_B)$, whereas a velocity variation over $\\ell_u$ implies $\\omega \\sim U_0/\\ell_u$. Define suitable characteristic normalizations $J_0$ and $\\omega_0$ from $B_0$, $U_0$, and $L_0$, and then construct a dimensionless trigger metric based on $J/J_0$ and $\\omega/\\omega_0$. You must logically justify the combination rule you use to merge the two triggers into a single refinement decision. Do not assume or quote a pre-made refinement formula; derive it from the requirement that the mesh should resolve the smallest active scale relative to $h$.\n- Design a hysteresis policy with two distinct thresholds (one for refinement and one for coarsening) and temporal dwell-time conditions (minimum consecutive time steps) to prevent rapid back-and-forth toggling when the metric fluctuates near a threshold. Explain why the policy avoids thrashing and respects the physics-derived threshold.\n\nAlgorithmic requirements:\n- The refinement state of each cell at each time step is binary: refined or coarse.\n- Use a single scalar dimensionless trigger metric per cell per time $M(t,i)$ derived from $J(t,i)$ and $\\omega(t,i)$ and the characteristic scales.\n- Define a refinement threshold $T_{\\mathrm{refine}}$ and a coarsening threshold $T_{\\mathrm{coarsen}}$, with $T_{\\mathrm{coarsen}}  T_{\\mathrm{refine}}$ to implement hysteresis, and dwell-time integers $N_{\\uparrow}$ and $N_{\\downarrow}$ for refinement and coarsening persistence, respectively.\n- Initialization: all cells start as coarse at the first time step.\n- State update at each time step:\n  - If $M(t,i) \\ge T_{\\mathrm{refine}}$ for at least $N_{\\uparrow}$ consecutive steps, switch the cell to refined.\n  - If $M(t,i) \\le T_{\\mathrm{coarsen}}$ for at least $N_{\\downarrow}$ consecutive steps, switch the cell to coarse.\n  - Otherwise, maintain the current state.\n- Count the total number of state toggles across all cells and time steps for each test case.\n- The units for physical quantities are mandatory:\n  - $J$ must be in $\\,\\mathrm{A/m^2}$.\n  - $\\omega$ must be in $\\,\\mathrm{s^{-1}}$.\n  - $B_0$ in $\\,\\mathrm{T}$.\n  - $U_0$ in $\\,\\mathrm{m/s}$.\n  - $L_0$ and $h$ in $\\,\\mathrm{m}$.\n\nTest suite and parameters:\n- Use $\\mu_0 = 4\\pi \\times 10^{-7}\\,\\mathrm{H/m}$.\n\n- Test Case 1 (happy path):\n  - $B_0 = 5\\,\\mathrm{T}$, $U_0 = 2 \\times 10^{4}\\,\\mathrm{m/s}$, $L_0 = 0.1\\,\\mathrm{m}$, $h = 0.01\\,\\mathrm{m}$, $\\kappa = 2$ (resolution factor), $\\gamma = 0.7$ (hysteresis ratio), $N_{\\uparrow} = 2$, $N_{\\downarrow} = 3$.\n  - Time steps: $T = 8$, cells: $N = 8$.\n  - Define dimensionless multipliers for current density and vorticity as follows, and then set $J(t,i) = J_0 \\times a_{t,i}$ and $\\omega(t,i) = \\omega_0 \\times b_{t,i}$, where $J_0 = B_0/(\\mu_0 L_0)$ and $\\omega_0 = U_0/L_0$:\n    - For cells $i \\in \\{0,1,2,3\\}$, $a_{t,i} = [6,6,6,4,4,4,4,4]$, $b_{t,i} = [2,2,2,2,2,2,2,2]$.\n    - For cells $i \\in \\{4,5,6,7\\}$, $a_{t,i} = [3,3,3,3,3,3,3,3]$, $b_{t,i} = [3,3,3,3,3,3,3,3]$.\n\n- Test Case 2 (boundary conditions near thresholds):\n  - $B_0 = 5\\,\\mathrm{T}$, $U_0 = 2 \\times 10^{4}\\,\\mathrm{m/s}$, $L_0 = 0.1\\,\\mathrm{m}$, $h = 0.02\\,\\mathrm{m}$, $\\kappa = 2$, $\\gamma = 0.8$, $N_{\\uparrow} = 2$, $N_{\\downarrow} = 3$.\n  - Time steps: $T = 8$, cells: $N = 8$.\n  - Dimensionless multipliers:\n    - For cells $i \\in \\{0,1\\}$, $a_{t,i} = [2.5,2.5,2.4,2.4,2.4,2.0,2.0,2.0]$, $b_{t,i} = [0,0,0,0,0,0,0,0]$.\n    - For cells $i \\in \\{2,3\\}$, $a_{t,i} = [2.5,2.4,2.5,2.4,2.5,2.4,2.5,2.4]$, $b_{t,i} = [0,0,0,0,0,0,0,0]$.\n    - For cells $i \\in \\{4,5,6,7\\}$, $a_{t,i} = [1.8,1.8,1.8,1.8,1.8,1.8,1.8,1.8]$, $b_{t,i} = [0,0,0,0,0,0,0,0]$.\n\n- Test Case 3 (spiky signals and hysteresis robustness):\n  - $B_0 = 5\\,\\mathrm{T}$, $U_0 = 2 \\times 10^{4}\\,\\mathrm{m/s}$, $L_0 = 0.1\\,\\mathrm{m}$, $h = 0.01\\,\\mathrm{m}$, $\\kappa = 2$, $\\gamma = 0.7$, $N_{\\uparrow} = 2$, $N_{\\downarrow} = 3$.\n  - Time steps: $T = 10$, cells: $N = 10$.\n  - Dimensionless multipliers:\n    - For cells $i \\in \\{0,1,2,3,4\\}$, $a_{t,i} = [6,3,6,3,6,3,6,3,6,3]$, $b_{t,i} = [0,0,0,0,0,0,0,0,0,0]$.\n    - For cells $i \\in \\{5,6,7\\}$, $a_{t,i} = [6,6,3,3,6,6,3,3,6,6]$, $b_{t,i} = [0,0,0,0,0,0,0,0,0,0]$.\n    - For cells $i \\in \\{8,9\\}$, $a_{t,i} = [6,6,6,6,6,6,6,6,6,6]$, $b_{t,i} = [0,0,0,0,0,0,0,0,0,0]$.\n\nOutput specification:\n- For each test case, after processing all time steps, compute:\n  1. The final count of refined cells (an integer).\n  2. The total number of refinement-state toggles across all cells and times (an integer).\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a two-element list of the form $[R_{\\mathrm{final}},T_{\\mathrm{toggles}}]$. For example: $[[r_1,t_1],[r_2,t_2],[r_3,t_3]]$.\n\nAll numerical values and outputs must be computed in the specified units, and angles, if any appear, must be in radians; however, no angles are used in this problem. The final output must be a list of lists as described and must be printed exactly as one line.",
            "solution": "We begin by establishing a physically motivated refinement criterion from the fundamental laws of magnetohydrodynamics (MHD). MHD couples Maxwell’s equations and fluid dynamics. In the quasi-static limit without displacement current, the Maxwell–Ampère law gives $\\nabla \\times \\mathbf{B} = \\mu_0 \\mathbf{J}$. Consider a magnetic field $\\mathbf{B}$ that varies over a characteristic length scale $\\ell_B$ with magnitude $B_0$. Dimensionally, this implies $J \\sim B_0 / (\\mu_0 \\ell_B)$. Similarly, for the fluid velocity $\\mathbf{u}$ varying over a length scale $\\ell_u$ with magnitude $U_0$, the vorticity magnitude obeys $\\omega \\sim U_0 / \\ell_u$. These relations show that large current density ($J$) and vorticity ($\\omega$) indicate the presence of small physical structures (current sheets and shear layers) that demand finer resolution.\n\nTo create dimensionless triggers, we define reference scales based on macroscopic variations over length $L_0$: $J_0 \\equiv B_0 / (\\mu_0 L_0)$ and $\\omega_0 \\equiv U_0 / L_0$. The normalized quantities are then related to the physical length scales: $J/J_0 \\sim L_0 / \\ell_B$ and $\\omega/\\omega_0 \\sim L_0 / \\ell_u$. Refinement should be triggered when the mesh spacing $h$ is no longer sufficient to resolve the smallest active physical scale, $\\ell_{\\min} = \\min(\\ell_B,\\ell_u)$. We can express this condition as $\\ell_{\\min} \\le \\kappa h$, where $\\kappa$ is a resolution factor (e.g., $\\kappa=2$ would trigger refinement when a structure becomes smaller than two grid cells across). Using our normalized quantities, the condition $\\ell_B \\le \\kappa h$ becomes $L_0 / (J/J_0) \\le \\kappa h$, which rearranges to $J/J_0 \\ge L_0/(\\kappa h)$. Similarly, $\\ell_u \\le \\kappa h$ implies $\\omega/\\omega_0 \\ge L_0/(\\kappa h)$.\n\nA conservative single scalar trigger metric should respond to the smallest scale, so the maximum of the two normalized indicators is the appropriate choice:\n$$\nM \\equiv \\max\\!\\left(\\frac{J}{J_0},\\,\\frac{\\omega}{\\omega_0}\\right).\n$$\nThis choice follows directly from the need to detect the minimum of $\\ell_B$ and $\\ell_u$: since $J/J_0 \\sim L_0/\\ell_B$ and $\\omega/\\omega_0 \\sim L_0/\\ell_u$, taking the maximum of these ratios corresponds to the minimum of the associated length scales.\n\nTherefore, the physics-derived refinement threshold becomes\n$$\nT_{\\mathrm{refine}} = \\frac{L_0}{\\kappa h},\n$$\nand a cell should be refined when $M \\ge T_{\\mathrm{refine}}$. To avoid refinement thrashing, we introduce hysteresis via a coarsening threshold $T_{\\mathrm{coarsen}} = \\gamma\\, T_{\\mathrm{refine}}$ with $0  \\gamma  1$, and we impose dwell-time requirements: $N_{\\uparrow}$ consecutive time steps above $T_{\\mathrm{refine}}$ are required to refine, and $N_{\\downarrow}$ consecutive time steps below $T_{\\mathrm{coarsen}}$ are required to coarsen. Values of $M$ between thresholds, i.e., $T_{\\mathrm{coarsen}}  M  T_{\\mathrm{refine}}$, do not change the state and reset the counters. This policy creates a buffer band and persistence criteria that eliminate rapid toggling due to small oscillations in $M$.\n\nAlgorithm design:\n1. Compute $J_0 = B_0/(\\mu_0 L_0)$ and $\\omega_0 = U_0/L_0$ (note that $B_0$ is in $\\mathrm{T}$, $U_0$ in $\\mathrm{m/s}$, $L_0$ in $\\mathrm{m}$, so $J_0$ is in $\\mathrm{A/m^2}$ and $\\omega_0$ in $\\mathrm{s^{-1}}$).\n2. For each cell $i$ and time $t$, compute the dimensionless metric\n   $$\n   M(t,i) = \\max\\!\\left(\\frac{J(t,i)}{J_0},\\,\\frac{\\omega(t,i)}{\\omega_0}\\right).\n   $$\n3. Compute thresholds $T_{\\mathrm{refine}} = L_0/(\\kappa h)$ and $T_{\\mathrm{coarsen}} = \\gamma T_{\\mathrm{refine}}$.\n4. Initialize all cells as coarse. Maintain two counters per cell: $c_{\\uparrow}(i)$ and $c_{\\downarrow}(i)$.\n5. For each time step:\n   - If $M(t,i) \\ge T_{\\mathrm{refine}}$, set $c_{\\uparrow}(i) \\leftarrow c_{\\uparrow}(i) + 1$, $c_{\\downarrow}(i) \\leftarrow 0$. If the cell is coarse and $c_{\\uparrow}(i) \\ge N_{\\uparrow}$, switch it to refined and increment the global toggle counter.\n   - Else if $M(t,i) \\le T_{\\mathrm{coarsen}}$, set $c_{\\downarrow}(i) \\leftarrow c_{\\downarrow}(i) + 1$, $c_{\\uparrow}(i) \\leftarrow 0$. If the cell is refined and $c_{\\downarrow}(i) \\ge N_{\\downarrow}$, switch it to coarse and increment the global toggle counter.\n   - Else (within the hysteresis band), reset both counters to zero and keep the current state.\n6. After the last time step, count the number of refined cells and report the total number of toggles.\n\nWhy this avoids thrashing:\n- The two-threshold band $[T_{\\mathrm{coarsen}}, T_{\\mathrm{refine}}]$ ensures that small fluctuations that cross a single threshold do not immediately reverse the decision; in physical terms, it respects the uncertainty band where neither strong current sheets nor strong shear layers are definitively present relative to the mesh spacing.\n- The dwell times $N_{\\uparrow}$ and $N_{\\downarrow}$ enforce persistence, requiring sustained evidence of under-resolution or over-resolution before making changes, which is consistent with the practical evolution of plasma structures in magnetohydrodynamics.\n\nApplication to the test suite:\n- Test Case 1 uses $B_0 = 5$, $U_0 = 2 \\times 10^{4}$, $L_0 = 0.1$, $h = 0.01$, $\\kappa = 2$, $\\gamma = 0.7$, $N_{\\uparrow} = 2$, $N_{\\downarrow} = 3$, implying $J_0 = B_0 / (\\mu_0 L_0)$ and $\\omega_0 = U_0 / L_0$, with $T_{\\mathrm{refine}} = L_0/(\\kappa h) = 0.1/(2 \\cdot 0.01) = 5$ and $T_{\\mathrm{coarsen}} = \\gamma T_{\\mathrm{refine}} = 3.5$. The provided signals cause early refinement of the first four cells with no coarsening, yielding a nonzero refined count and a small number of toggles.\n- Test Case 2 uses $h = 0.02$, $\\gamma = 0.8$, so $T_{\\mathrm{refine}} = 2.5$ and $T_{\\mathrm{coarsen}} = 2.0$. Designed oscillations near thresholds with equality test cases exercise the hysteresis: refinement requires persistence above $2.5$, and coarsening requires persistence at or below $2.0$; the specified sequences cause refinement followed by coarsening for the first two cells, while others do not toggle.\n- Test Case 3 replicates spiky signals, $T = 10$, $N = 10$, $h = 0.01$, $\\gamma = 0.7$. Alternating high-low values with $N_{\\uparrow} = 2$ and $N_{\\downarrow} = 3$ prevent coarsening during brief low intervals and thus avoid thrashing; cells with sustained high signals refine once and remain refined.\n\nThe program computes $J_0$, $\\omega_0$, thresholds, applies the hysteresis logic across time steps, and produces the final counts and toggle totals for each test case. The final output format is a single line containing a list of lists: $[[R_{\\mathrm{final}},T_{\\mathrm{toggles}}],\\ldots]$, as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nMU0 = 4.0 * np.pi * 1e-7  # Permeability of free space (H/m)\n\ndef apply_hysteresis(J, W, B0, U0, L0, h, kappa, gamma, N_up, N_down):\n    \"\"\"\n    Apply refinement hysteresis policy to time series of J and vorticity W.\n    J, W: arrays of shape (T, N) with physical units (A/m^2) and (1/s).\n    Returns (final_refined_count, total_toggles).\n    \"\"\"\n    T, N = J.shape\n\n    # Characteristic scales\n    J0 = B0 / (MU0 * L0)\n    W0 = U0 / L0\n\n    # Dimensionless metric M = max(J/J0, W/W0)\n    M = np.maximum(J / J0, W / W0)\n\n    # Thresholds\n    T_refine = L0 / (kappa * h)\n    T_coarsen = gamma * T_refine\n\n    # State and counters\n    refined = np.zeros(N, dtype=bool)\n    up_count = np.zeros(N, dtype=int)\n    down_count = np.zeros(N, dtype=int)\n    toggles = 0\n\n    for t in range(T):\n        mt = M[t]\n        # Update counters and states per cell\n        for i in range(N):\n            if mt[i] = T_refine:\n                up_count[i] += 1\n                down_count[i] = 0\n                if (not refined[i]) and (up_count[i] = N_up):\n                    refined[i] = True\n                    toggles += 1\n            elif mt[i] = T_coarsen:\n                down_count[i] += 1\n                up_count[i] = 0\n                if refined[i] and (down_count[i] = N_down):\n                    refined[i] = False\n                    toggles += 1\n            else:\n                # Within hysteresis band: reset counters\n                up_count[i] = 0\n                down_count[i] = 0\n\n    final_refined_count = int(np.sum(refined))\n    return final_refined_count, toggles\n\ndef build_case_1():\n    # Parameters\n    B0 = 5.0       # Tesla\n    U0 = 2.0e4     # m/s\n    L0 = 0.1       # m\n    h = 0.01       # m\n    kappa = 2.0\n    gamma = 0.7\n    N_up = 2\n    N_down = 3\n\n    T = 8\n    N = 8\n\n    # Dimensionless multipliers a (for J) and b (for W)\n    a = np.zeros((T, N))\n    b = np.zeros((T, N))\n\n    # Cells 0..3: a_t = [6,6,6,4,4,4,4,4], b_t = [2,2,2,2,2,2,2,2]\n    pattern_a_early = [6, 6, 6, 4, 4, 4, 4, 4]\n    pattern_b_early = [2, 2, 2, 2, 2, 2, 2, 2]\n    for i in range(4):\n        a[:, i] = pattern_a_early\n        b[:, i] = pattern_b_early\n\n    # Cells 4..7: a_t = [3]*8, b_t = [3]*8\n    pattern_a_late = [3]*T\n    pattern_b_late = [3]*T\n    for i in range(4, 8):\n        a[:, i] = pattern_a_late\n        b[:, i] = pattern_b_late\n\n    # Convert to physical units\n    J0 = B0 / (MU0 * L0)\n    W0 = U0 / L0\n    J = a * J0\n    W = b * W0\n\n    return (J, W, B0, U0, L0, h, kappa, gamma, N_up, N_down)\n\ndef build_case_2():\n    # Parameters\n    B0 = 5.0       # Tesla\n    U0 = 2.0e4     # m/s\n    L0 = 0.1       # m\n    h = 0.02       # m\n    kappa = 2.0\n    gamma = 0.8\n    N_up = 2\n    N_down = 3\n\n    T = 8\n    N = 8\n\n    a = np.zeros((T, N))\n    b = np.zeros((T, N))\n\n    # Cells 0..1: a_t = [2.5,2.5,2.4,2.4,2.4,2.0,2.0,2.0], b_t = zeros\n    pattern_a_01 = [2.5, 2.5, 2.4, 2.4, 2.4, 2.0, 2.0, 2.0]\n    for i in range(2):\n        a[:, i] = pattern_a_01\n        b[:, i] = [0]*T\n\n    # Cells 2..3: a_t alternating 2.5 and 2.4, b_t zeros\n    pattern_a_23 = [2.5, 2.4, 2.5, 2.4, 2.5, 2.4, 2.5, 2.4]\n    for i in range(2, 4):\n        a[:, i] = pattern_a_23\n        b[:, i] = [0]*T\n\n    # Cells 4..7: a_t = [1.8]*8, b_t = zeros\n    pattern_a_47 = [1.8]*T\n    for i in range(4, 8):\n        a[:, i] = pattern_a_47\n        b[:, i] = [0]*T\n\n    # Convert to physical units\n    J0 = B0 / (MU0 * L0)\n    W0 = U0 / L0\n    J = a * J0\n    W = b * W0\n\n    return (J, W, B0, U0, L0, h, kappa, gamma, N_up, N_down)\n\ndef build_case_3():\n    # Parameters\n    B0 = 5.0       # Tesla\n    U0 = 2.0e4     # m/s\n    L0 = 0.1       # m\n    h = 0.01       # m\n    kappa = 2.0\n    gamma = 0.7\n    N_up = 2\n    N_down = 3\n\n    T = 10\n    N = 10\n\n    a = np.zeros((T, N))\n    b = np.zeros((T, N))\n\n    # Cells 0..4: a_t = [6,3,6,3,6,3,6,3,6,3], b_t zeros\n    pattern_a_04 = [6, 3, 6, 3, 6, 3, 6, 3, 6, 3]\n    for i in range(5):\n        a[:, i] = pattern_a_04\n        b[:, i] = [0]*T\n\n    # Cells 5..7: a_t = [6,6,3,3,6,6,3,3,6,6], b_t zeros\n    pattern_a_57 = [6, 6, 3, 3, 6, 6, 3, 3, 6, 6]\n    for i in range(5, 8):\n        a[:, i] = pattern_a_57\n        b[:, i] = [0]*T\n\n    # Cells 8..9: a_t = [6]*10, b_t zeros\n    pattern_a_89 = [6]*T\n    for i in range(8, 10):\n        a[:, i] = pattern_a_89\n        b[:, i] = [0]*T\n\n    # Convert to physical units\n    J0 = B0 / (MU0 * L0)\n    W0 = U0 / L0\n    J = a * J0\n    W = b * W0\n\n    return (J, W, B0, U0, L0, h, kappa, gamma, N_up, N_down)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        build_case_1(),\n        build_case_2(),\n        build_case_3(),\n    ]\n\n    results = []\n    for case in test_cases:\n        J, W, B0, U0, L0, h, kappa, gamma, N_up, N_down = case\n        final_refined_count, toggles = apply_hysteresis(\n            J, W, B0, U0, L0, h, kappa, gamma, N_up, N_down\n        )\n        results.append([final_refined_count, toggles])\n\n    # Final print statement in the exact required format.\n    # Single line output: list of [R_final, T_toggles] per test case.\n    print(f\"[{','.join(str(item) for item in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Creating refined patches introduces interfaces between coarse and fine grids, which require careful handling. This exercise  addresses the crucial task of managing data across these boundaries. You will determine the minimum required 'ghost cell' width, a buffer region of cells needed to correctly apply numerical stencils near an interface, based on the scheme's stencil size and the grid refinement ratio.",
            "id": "3946715",
            "problem": "Consider a one-dimensional patch-based Adaptive Mesh Refinement (AMR) discretization for a resistive Magnetohydrodynamics (MHD) plasma simulation, with refinement ratio $r \\in \\mathbb{N}$ between a coarse level and a fine level. The fine-level cell size is $h_{f} = h_{c}/r$, where $h_{c}$ is the coarse-level cell size. The time advance on the fine level uses a $p$-th order, symmetric, cell-centered, explicit finite-volume scheme whose spatial discretization requires a compact symmetric stencil of radius $s$ fine cells on each side of the target fine cell (that is, the stencil touches $2s+1$ fine cells centered at the target).\n\nAt a coarse-fine interface, the fine level abuts the coarse level directly. The fine level maintains a ghost layer of width $g$ fine cells outside the patch boundary to enable valid stencil evaluations for fine-level cells adjacent to the interface. Ghost values are populated from the coarse level by a conservative prolongation consistent with the same accuracy order $p$, using a compact, symmetric stencil in coarse cells that does not require data beyond coarse interior cells directly adjacent to the interface. To ensure conservative flux reconciliation and avoid fractional coarse supports, the ghost region must align to complete coarse-cell blocks, so $g$ must be a multiple of $r$.\n\nStarting from these definitions and constraints, derive the minimal fine-level ghost width $g$ (in fine cells) as a function of the fine-level stencil radius $s$ and the integer refinement ratio $r$, such that:\n- Every fine-level stencil centered at any fine interior cell that touches the interface (i.e., within the first $s$ fine cells next to the boundary) is entirely covered by either fine interior or fine ghost data.\n- The coarse-to-fine prolongation needed to populate the fine ghost layer can be formed from complete coarse-cell blocks immediately adjoining the interface, with no requirement of accessing coarse data beyond the nearest coarse interior cells.\n\nGive your final answer as a closed-form analytical expression $g(s,r)$.",
            "solution": "The problem asks for the minimal fine-level ghost width, denoted by $g$, as a function of the fine-level stencil radius, $s$, and the integer refinement ratio, $r$. The derivation must satisfy two principal constraints outlined in the problem statement.\n\nFirst, we analyze the constraint imposed by the fine-level numerical stencil. The scheme is described as using a compact symmetric stencil of radius $s$ fine cells. This means that to compute the updated value for a fine cell at index $i$, data from all cells in the closed interval $[i-s, i+s]$ are required.\n\nLet us define the one-dimensional domain such that the fine-level patch occupies the region $x > 0$, with the coarse-fine interface located at $x=0$. The fine-level cells are indexed $j=1, 2, 3, \\dots$ for interior cells. The ghost cells, which are required to provide boundary data, will occupy the region $x  0$ and can be indexed $j=0, -1, -2, \\dots$.\n\nThe problem states that the ghost layer must be sufficiently wide so that \"Every fine-level stencil centered at any fine interior cell that touches the interface (i.e., within the first $s$ fine cells next to the boundary) is entirely covered by either fine interior or fine ghost data.\"\n\nLet's consider the fine interior cell that imposes the most stringent requirement on the ghost-cell width. This is the cell closest to the interface, at index $j=1$. The stencil for this cell spans from index $1-s$ to $1+s$. The cells with indices from $1$ to $1+s$ are within the fine-level patch's interior. The cells with indices from $1-s$ to $0$ must be provided by the ghost layer.\n\nThe required ghost-cell indices are $\\{0, -1, \\dots, 1-s\\}$. The number of cells in this set is $0 - (1-s) + 1 = s$. Therefore, to service the stencil of the first interior fine cell, the ghost layer must have a width of at least $s$ cells. This gives us our first constraint on $g$:\n$$\ng \\ge s\n$$\nAny other interior cell $j$ where $1  j \\le s$ also has a stencil that crosses the interface, requiring ghost cells with indices from $j-s$ to $0$. Since $j1$, the lowest index required is $j-s  1-s$, so the requirement from cell $j=1$ is indeed the most demanding.\n\nSecond, we analyze the constraint related to the grid structure and the prolongation operator. The problem explicitly states that \"To ensure conservative flux reconciliation and avoid fractional coarse supports, the ghost region must align to complete coarse-cell blocks, so $g$ must be a multiple of $r$.\"\n\nHere, $r$ is the refinement ratio, meaning one coarse cell has the same width as $r$ fine cells ($h_c = r h_f$). The constraint that the ghost region of width $g h_f$ must be made of \"complete coarse-cell blocks\" means its total width must be an integer multiple of the coarse cell width $h_c$.\n$$\ng h_f = k h_c\n$$\nfor some positive integer $k \\in \\mathbb{N}$ (since $g0$). Substituting $h_c = r h_f$, we get:\n$$\ng h_f = k (r h_f)\n$$\n$$\ng = k r\n$$\nThis provides the second constraint: $g$ must be an integer multiple of $r$. The information about the prolongation stencil's order $p$ and its symmetry serves as the physical and numerical justification for this structural constraint, ensuring that the source data for interpolation (the coarse cells) align perfectly with the target region (the fine ghost cells). The problem formulation implies that satisfying this structural alignment is sufficient, and we do not need to independently use $p$ to determine the stencil width of the prolongation operator itself.\n\nWe must find the minimal value of $g$ that satisfies both constraints simultaneously:\n1. $g \\ge s$\n2. $g = k r$ for some $k \\in \\{1, 2, 3, \\dots\\}$\n\nCombining these two conditions, we have:\n$$\nk r \\ge s\n$$\nSolving for the integer $k$:\n$$\nk \\ge \\frac{s}{r}\n$$\nSince we seek the minimal possible value for $g$, we must find the smallest integer $k$ that satisfies this inequality. The smallest integer greater than or equal to a real number $x$ is given by the ceiling function, $\\lceil x \\rceil$.\nTherefore, the minimal integer value for $k$ is:\n$$\nk_{min} = \\left\\lceil \\frac{s}{r} \\right\\rceil\n$$\nSubstituting this minimal value of $k$ back into the expression for $g$, we obtain the minimal required ghost width:\n$$\ng(s, r) = k_{min} \\cdot r = r \\left\\lceil \\frac{s}{r} \\right\\rceil\n$$\nThis expression gives the smallest number of ghost cells, $g$, that is both larger than or equal to the stencil radius $s$ and is an integer multiple of the refinement ratio $r$.",
            "answer": "$$\n\\boxed{r \\left\\lceil \\frac{s}{r} \\right\\rceil}\n$$"
        },
        {
            "introduction": "A sophisticated numerical method is only useful if it respects the underlying physics. This practice  tackles a critical challenge in applying AMR to magnetohydrodynamics (MHD): the violation of the solenoidal magnetic field constraint, $\\nabla \\cdot \\mathbf{B} = 0$, by interpolation operations. You will first quantify this interpolation-induced error and then implement a standard projection method to 'clean' the field, ensuring the simulation remains physically valid.",
            "id": "3946755",
            "problem": "In magnetohydrodynamics (MHD), Maxwell’s equations require a solenoidal magnetic field, so that $\\nabla \\cdot \\mathbf{B} = 0$. In Adaptive Mesh Refinement (AMR), coarse-to-fine interpolation can introduce a spurious divergence on refined patches if the interpolation does not preserve the discrete solenoidal constraint. Consider a two-dimensional refined patch corresponding to a single coarse cell occupying the unit square $\\Omega = [0,1] \\times [0,1]$ with spatial coordinates $(x,y)$ and refinement ratio $r=2$ (so that the patch is composed of four fine cells). The coarse-level magnetic field is obtained from a scalar potential $\\psi(x,y)$ through a two-dimensional curl, $\\mathbf{B} = \\nabla \\times (\\psi \\,\\hat{\\mathbf{z}})$, where $\\hat{\\mathbf{z}}$ is the unit vector in the out-of-plane direction, so that $B_x = \\partial \\psi / \\partial y$ and $B_y = -\\partial \\psi / \\partial x$. Let the coarse-level scalar potential be $\\psi(x,y) = x^{2}y - \\frac{1}{3}y^{3}$, which yields a divergence-free magnetic field on the coarse level.\n\nOn the refined patch, define the interpolation as follows: for each component of $\\mathbf{B}$, construct the bilinear interpolant on $\\Omega$ from the coarse-cell corner values at $(0,0)$, $(1,0)$, $(0,1)$, and $(1,1)$; denote this interpolated field by $\\widehat{\\mathbf{B}}(x,y) = (\\widehat{B}_x(x,y),\\widehat{B}_y(x,y))$. The discrete divergence on the refined patch is then approximated by the continuous divergence of the bilinear interpolant, namely $\\nabla \\cdot \\widehat{\\mathbf{B}}(x,y)$.\n\nStarting from the MHD solenoidal constraint and the AMR interpolation definition above, derive the divergence error $\\nabla \\cdot \\widehat{\\mathbf{B}}(x,y)$ induced by the bilinear interpolation on the refined patch. Then, design a projection-based correction on the refined patch: find a scalar potential $\\phi(x,y)$ solving the Poisson equation with homogeneous Neumann boundary conditions,\n$$\n\\nabla^{2}\\phi(x,y) = \\nabla \\cdot \\widehat{\\mathbf{B}}(x,y), \\quad \\text{with } \\frac{\\partial \\phi}{\\partial n}\\bigg|_{\\partial \\Omega} = 0,\n$$\nsuch that the corrected field $\\mathbf{B}_{\\text{corr}} = \\widehat{\\mathbf{B}} - \\nabla \\phi$ is divergence-free and preserves the coarse-level normal components on the patch boundary. Provide a closed-form analytic expression for $\\phi(x,y)$. If you choose a constant of integration, fix it by requiring $\\phi(0,0) = 0$. Your final answer must be a single closed-form analytic expression for $\\phi(x,y)$; do not include any units.",
            "solution": "The problem is first validated to ensure it is scientifically grounded, well-posed, and self-consistent.\n\n**Step 1: Extract Givens**\n-   The domain is the unit square $\\Omega = [0,1] \\times [0,1]$ in coordinates $(x,y)$.\n-   The coarse-level magnetic field $\\mathbf{B}$ is derived from a scalar potential $\\psi(x,y) = x^{2}y - \\frac{1}{3}y^{3}$ via $\\mathbf{B} = \\nabla \\times (\\psi \\,\\hat{\\mathbf{z}})$.\n-   The explicit form of the coarse-level field components is $B_x = \\frac{\\partial \\psi}{\\partial y}$ and $B_y = -\\frac{\\partial \\psi}{\\partial x}$.\n-   The interpolated field on the refined patch, $\\widehat{\\mathbf{B}}(x,y)$, is obtained by bilinear interpolation of the coarse field values at the corners of $\\Omega$: $(0,0)$, $(1,0)$, $(0,1)$, and $(1,1)$.\n-   A correction potential $\\phi(x,y)$ must be found by solving the Poisson equation $\\nabla^{2}\\phi(x,y) = \\nabla \\cdot \\widehat{\\mathbf{B}}(x,y)$.\n-   The boundary conditions for $\\phi$ are homogeneous Neumann: $\\frac{\\partial \\phi}{\\partial n}\\big|_{\\partial \\Omega} = 0$.\n-   A condition to fix the integration constant is provided: $\\phi(0,0) = 0$.\n-   The corrected field is defined as $\\mathbf{B}_{\\text{corr}} = \\widehat{\\mathbf{B}} - \\nabla \\phi$.\n\n**Step 2: Validate Using Extracted Givens**\n-   **Scientific Grounding**: The problem addresses a standard numerical issue in magnetohydrodynamics (MHD) related to preserving the solenoidal constraint $\\nabla \\cdot \\mathbf{B} = 0$ in Adaptive Mesh Refinement (AMR). The use of a vector potential (here, a 2D scalar potential $\\psi$) to define a divergence-free field, the concept of interpolation-induced divergence, and the use of a projection method (solving a Poisson equation) to correct this divergence are all standard and well-established techniques in computational physics.\n-   **Well-Posedness**: The problem defines a complete mathematical task. The initial field is explicitly given. The interpolation scheme is specified (bilinear). The equation for the correction potential is a well-defined Poisson equation. The boundary conditions (homogeneous Neumann) and the pinning condition ($\\phi(0,0)=0$) are sufficient to guarantee a unique solution. The coarse-level field is verified to be divergence-free: $B_x = x^2 - y^2$, $B_y = -2xy$, so $\\nabla \\cdot \\mathbf{B} = \\frac{\\partial}{\\partial x}(x^2 - y^2) + \\frac{\\partial}{\\partial y}(-2xy) = 2x - 2x = 0$. The setup is consistent.\n-   **Objectivity**: The problem is stated in precise, objective mathematical language.\n\n**Verdict and Action**\nThe problem is valid as it is scientifically sound, well-posed, and internally consistent. We will now proceed with the solution.\n\n**Step 3: Solution Derivation**\n\nFirst, we determine the coarse-level magnetic field, $\\mathbf{B}(x,y)$, using the given scalar potential $\\psi(x,y) = x^{2}y - \\frac{1}{3}y^{3}$.\nThe components of the magnetic field are:\n$$\nB_x(x,y) = \\frac{\\partial \\psi}{\\partial y} = \\frac{\\partial}{\\partial y}\\left(x^{2}y - \\frac{1}{3}y^{3}\\right) = x^{2} - y^{2}\n$$\n$$\nB_y(x,y) = -\\frac{\\partial \\psi}{\\partial x} = -\\frac{\\partial}{\\partial x}\\left(x^{2}y - \\frac{1}{3}y^{3}\\right) = -2xy\n$$\nSo, the coarse-level field is $\\mathbf{B}(x,y) = (x^{2} - y^{2}, -2xy)$.\n\nNext, we evaluate this field at the four corners of the unit square $\\Omega$:\n-   At $(0,0)$: $\\mathbf{B}(0,0) = (0^{2} - 0^{2}, -2(0)(0)) = (0,0)$.\n-   At $(1,0)$: $\\mathbf{B}(1,0) = (1^{2} - 0^{2}, -2(1)(0)) = (1,0)$.\n-   At $(0,1)$: $\\mathbf{B}(0,1) = (0^{2} - 1^{2}, -2(0)(1)) = (-1,0)$.\n-   At $(1,1)$: $\\mathbf{B}(1,1) = (1^{2} - 1^{2}, -2(1)(1)) = (0,-2)$.\n\nNow, we construct the bilinear interpolant $\\widehat{\\mathbf{B}}(x,y) = (\\widehat{B}_x(x,y), \\widehat{B}_y(x,y))$ on $\\Omega$. The general form for a function $f$ on the unit square is given by:\n$$\n\\widehat{f}(x,y) = f(0,0)(1-x)(1-y) + f(1,0)x(1-y) + f(0,1)(1-x)y + f(1,1)xy\n$$\nApplying this to each component of $\\mathbf{B}$:\nFor $\\widehat{B}_x(x,y)$:\n$$\n\\widehat{B}_x(x,y) = (0)(1-x)(1-y) + (1)x(1-y) + (-1)(1-x)y + (0)xy\n$$\n$$\n\\widehat{B}_x(x,y) = x(1-y) - (1-x)y = x - xy - y + xy = x - y\n$$\nFor $\\widehat{B}_y(x,y)$:\n$$\n\\widehat{B}_y(x,y) = (0)(1-x)(1-y) + (0)x(1-y) + (0)(1-x)y + (-2)xy\n$$\n$$\n\\widehat{B}_y(x,y) = -2xy\n$$\nThe interpolated magnetic field is $\\widehat{\\mathbf{B}}(x,y) = (x-y, -2xy)$.\n\nThe next step is to compute the divergence error, $\\nabla \\cdot \\widehat{\\mathbf{B}}(x,y)$.\n$$\n\\nabla \\cdot \\widehat{\\mathbf{B}} = \\frac{\\partial \\widehat{B}_x}{\\partial x} + \\frac{\\partial \\widehat{B}_y}{\\partial y} = \\frac{\\partial}{\\partial x}(x-y) + \\frac{\\partial}{\\partial y}(-2xy) = 1 - 2x\n$$\nThis non-zero result is the spurious divergence introduced by the interpolation.\n\nWe now need to find the scalar potential $\\phi(x,y)$ by solving the Poisson equation $\\nabla^{2}\\phi = 1 - 2x$ with homogeneous Neumann boundary conditions on $\\Omega$. The equation is:\n$$\n\\frac{\\partial^{2}\\phi}{\\partial x^{2}} + \\frac{\\partial^{2}\\phi}{\\partial y^{2}} = 1 - 2x\n$$\nThe boundary conditions are:\n-   $\\frac{\\partial \\phi}{\\partial x}(0,y) = 0$ for $y \\in [0,1]$\n-   $\\frac{\\partial \\phi}{\\partial x}(1,y) = 0$ for $y \\in [0,1]$\n-   $\\frac{\\partial \\phi}{\\partial y}(x,0) = 0$ for $x \\in [0,1]$\n-   $\\frac{\\partial \\phi}{\\partial y}(x,1) = 0$ for $x \\in [0,1]$\n\nSince the source term $1-2x$ is independent of $y$, and the boundary conditions on the horizontal boundaries ($y=0$ and $y=1$) are homogeneous for the $y$-derivative, we can seek a solution that is only a function of $x$, i.e., $\\phi(x,y) = \\phi(x)$. With this assumption, $\\frac{\\partial^{2}\\phi}{\\partial y^{2}} = 0$, and the boundary conditions on $y$ are automatically satisfied.\nThe problem reduces to a one-dimensional ordinary differential equation:\n$$\n\\frac{d^{2}\\phi}{dx^{2}} = 1 - 2x\n$$\nwith boundary conditions $\\frac{d\\phi}{dx}(0) = 0$ and $\\frac{d\\phi}{dx}(1) = 0$.\n\nIntegrating with respect to $x$ once:\n$$\n\\frac{d\\phi}{dx} = \\int (1-2x) \\,dx = x - x^{2} + C_1\n$$\nApplying the first boundary condition, $\\frac{d\\phi}{dx}(0)=0$:\n$$\n0 - 0^{2} + C_1 = 0 \\implies C_1=0\n$$\nThis gives $\\frac{d\\phi}{dx} = x - x^{2}$. Let's verify with the second boundary condition, $\\frac{d\\phi}{dx}(1)=0$:\n$$\n1 - 1^{2} = 0\n$$\nThe condition is satisfied, so our form of the derivative is correct.\n\nIntegrating $\\frac{d\\phi}{dx}$ again with respect to $x$:\n$$\n\\phi(x) = \\int (x - x^{2}) \\,dx = \\frac{1}{2}x^{2} - \\frac{1}{3}x^{3} + C_2\n$$\nThe solution is of the form $\\phi(x,y) = \\frac{1}{2}x^{2} - \\frac{1}{3}x^{3} + C_2$. To determine the constant $C_2$, we use the final condition $\\phi(0,0) = 0$:\n$$\n\\phi(0,0) = \\frac{1}{2}(0)^{2} - \\frac{1}{3}(0)^{3} + C_2 = 0 \\implies C_2 = 0\n$$\nThus, the unique scalar potential that satisfies all the given conditions is:\n$$\n\\phi(x,y) = \\frac{1}{2}x^{2} - \\frac{1}{3}x^{3}\n$$\nThis expression constitutes the closed-form analytic expression required. The corrected field $\\mathbf{B}_{\\text{corr}} = \\widehat{\\mathbf{B}} - \\nabla \\phi$ is guaranteed to be divergence-free by construction since $\\nabla \\cdot \\mathbf{B}_{\\text{corr}} = \\nabla \\cdot \\widehat{\\mathbf{B}} - \\nabla^2\\phi = (1-2x) - (1-2x) = 0$. The homogeneous Neumann boundary conditions ensure that the normal component of the correction term $\\nabla \\phi$ vanishes on the boundary, thus preserving the normal component of the interpolated field $\\widehat{\\mathbf{B}}$.",
            "answer": "$$\n\\boxed{\\frac{1}{2}x^{2} - \\frac{1}{3}x^{3}}\n$$"
        }
    ]
}