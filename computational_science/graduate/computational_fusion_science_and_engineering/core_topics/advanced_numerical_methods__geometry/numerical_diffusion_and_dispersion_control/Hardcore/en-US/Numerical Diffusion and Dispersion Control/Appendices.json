{
    "hands_on_practices": [
        {
            "introduction": "The first step in developing trustworthy scientific software is verification: ensuring the code correctly solves the equations it claims to solve. This practice provides a foundational method for verifying the implementation of a numerical scheme for a hyperbolic partial differential equation. By simulating the evolution of a single Fourier mode and analyzing the output, you will learn to directly measure the numerical dispersion and diffusion, and compare these empirical results to the theoretical predictions from Von Neumann analysis . This exercise is a cornerstone of computational physics, bridging the gap between analytical theory and practical code implementation.",
            "id": "4022200",
            "problem": "Consider the one-dimensional linear advection equation $ \\partial_t u + a \\, \\partial_x u = 0 $ on a periodic domain of length $ L $, discretized on a uniform grid with $ N_x $ points and spacing $ \\Delta x = L/N_x $. Use the first-order upwind finite-difference method with Courant–Friedrichs–Lewy number $ \\lambda = a \\Delta t / \\Delta x $ for $ a > 0 $ and discrete time step $ \\Delta t $, namely the update rule $ u_i^{n+1} = u_i^n - \\lambda \\left( u_i^n - u_{i-1}^n \\right) $ with periodic indexing. This scheme is widely used in Computational Fluid Dynamics and Computational Fusion Science and Engineering to manage numerical diffusion and dispersion in hyperbolic transport, and it serves as a controlled setting to verify numerical dispersion and damping against von Neumann analysis.\n\nYour task is to design and implement a complete, runnable program that:\n\n1. Initializes the field with a single complex Fourier mode $ u_i^0 = \\exp\\!\\left( i k x_i \\right) $ where $ k = 2\\pi m/L $, $ x_i = i \\Delta x $, and $ m \\in \\{0,1,\\dots,N_x-1\\} $ is an integer mode index.\n2. Advances the solution in time using the above upwind scheme for $ N_t $ time steps.\n3. At each time step $ n $, extracts the complex amplitude of the selected spatial Fourier mode $ m $ via a discrete spatial Fourier projection $ a_m^n = \\frac{1}{N_x} \\sum_{i=0}^{N_x-1} u_i^n \\exp\\!\\left( - i k x_i \\right) $.\n4. From the temporal sequence $ \\{ a_m^n \\}_{n=0}^{N_t-1} $, performs a temporal Fast Fourier Transform (FFT) to estimate the numerical angular frequency $ \\omega_{\\text{num}}(k) $ and the numerical growth (damping) rate $ \\gamma_{\\text{num}}(k) $ for that mode:\n   - Define the discrete angular frequency grid $ \\omega_j = 2\\pi f_j $ where $ f_j $ are the FFT frequencies in cycles per unit time with spacing $ \\Delta t $. Identify $ \\omega_{\\text{num}}(k) $ as the angular frequency corresponding to the maximum of the power spectrum $ P(\\omega) = | \\mathcal{F}[a_m^n](\\omega) |^2 $.\n   - Estimate $ \\gamma_{\\text{num}}(k) $ directly from the temporal spectrum using the full width at half maximum (FWHM) of the dominant spectral peak, taking $ \\gamma_{\\text{num}}(k) = -\\frac{1}{2} \\text{FWHM} $. If the peak lies at a frequency boundary such that only a one-sided half-maximum crossing is available, approximate $ \\text{FWHM} $ by twice the one-sided half-width.\n5. Independently perform a von Neumann stability and dispersion analysis for the same scheme to obtain the amplification factor $ G(k) $, and from it the predicted angular frequency and growth rate via $ \\omega_{\\text{vn}}(k) = -\\arg(G(k))/\\Delta t $ and $ \\gamma_{\\text{vn}}(k) = \\ln |G(k)| / \\Delta t $.\n6. Compare your measured $ \\omega_{\\text{num}}(k) $ and $ \\gamma_{\\text{num}}(k) $ from the temporal FFT to the von Neumann predictions $ \\omega_{\\text{vn}}(k) $ and $ \\gamma_{\\text{vn}}(k) $ by reporting the absolute differences $ |\\omega_{\\text{num}}(k) - \\omega_{\\text{vn}}(k)| $ and $ |\\gamma_{\\text{num}}(k) - \\gamma_{\\text{vn}}(k)| $.\n\nAssume non-dimensional units with $ a = 1 $ in length per unit time, so that angular frequencies $ \\omega $ must be expressed in radians per unit time and growth/damping rates $ \\gamma $ must be expressed in inverse unit time. Angles are measured in radians.\n\nYour program must use the following fixed parameters common to all tests: $ N_x = 256 $, $ L = 1 $, $ a = 1 $, and $ N_t = 4096 $. Construct the test suite using the triplets $ (\\lambda, m) $ listed below, which probe distinct regimes:\n- General case: $ (\\lambda, m) = (0.5, 12) $.\n- Boundary Courant number (no numerical diffusion when $ k \\neq 0 $): $ (\\lambda, m) = (1.0, 20) $.\n- High wavenumber near the Nyquist mode: $ (\\lambda, m) = (0.9, 128) $.\n\nFor each test case, compute the two absolute differences described in item $ 6 $ as floating-point numbers.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a two-element list $ [|\\omega_{\\text{num}}-\\omega_{\\text{vn}}|, |\\gamma_{\\text{num}}-\\gamma_{\\text{vn}}|] $. For example, the output format must be $ [[d_{\\omega,1},d_{\\gamma,1}],[d_{\\omega,2},d_{\\gamma,2}],[d_{\\omega,3},d_{\\gamma,3}]] $ with all entries in the units specified above.",
            "solution": "The problem as stated is scientifically sound, self-contained, and well-posed. It presents a standard verification and validation exercise in computational physics, specifically for numerical methods applied to hyperbolic partial differential equations. The parameters, initial conditions, numerical scheme, and analysis methods are all clearly and correctly defined. No flaws, contradictions, or ambiguities were detected. We may therefore proceed with a formal solution.\n\nThe solution process involves two parallel tracks: a theoretical analysis using the von Neumann method and a direct numerical simulation. The results from both are then compared.\n\n### 1. Theoretical Analysis: Von Neumann Dispersion and Stability\n\nWe analyze the numerical properties of the first-order upwind scheme,\n$$ u_i^{n+1} = u_i^n - \\lambda \\left( u_i^n - u_{i-1}^n \\right) $$\nwhere $\\lambda = a \\Delta t / \\Delta x$ is the Courant number. We substitute a single Fourier mode ansatz, $u_i^n = \\hat{u}^n(k) e^{i k x_i}$, into the scheme. The amplitude $\\hat{u}^n(k)$ is expected to evolve according to $\\hat{u}^{n+1}(k) = G(k) \\hat{u}^n(k)$, where $G(k)$ is the complex amplification factor.\n\nSubstituting the ansatz and using $x_i = i \\Delta x$:\n$$ G(k) \\hat{u}^n(k) e^{i k i \\Delta x} = \\hat{u}^n(k) e^{i k i \\Delta x} - \\lambda \\left( \\hat{u}^n(k) e^{i k i \\Delta x} - \\hat{u}^n(k) e^{i k (i-1) \\Delta x} \\right) $$\nDividing by the common factor $\\hat{u}^n(k) e^{i k i \\Delta x}$:\n$$ G(k) = 1 - \\lambda \\left( 1 - e^{-i k \\Delta x} \\right) $$\nLet $\\tilde{k} = k \\Delta x$ be the normalized wavenumber. The amplification factor is:\n$$ G(\\tilde{k}) = 1 - \\lambda (1 - e^{-i\\tilde{k}}) = 1 - \\lambda + \\lambda e^{-i\\tilde{k}} = (1 - \\lambda + \\lambda \\cos\\tilde{k}) - i (\\lambda \\sin\\tilde{k}) $$\nThe exact solution to the advection equation $\\partial_t u + a \\partial_x u = 0$ for a mode $e^{ikx}$ is $e^{ik(x-at)}$, which has an amplification factor over one time step $\\Delta t$ of $G_{\\text{exact}} = e^{-i a k \\Delta t}$. The numerical scheme introduces both amplitude error (numerical diffusion) and phase error (numerical dispersion).\n\nFrom the amplification factor $G(k)$, we can extract the theoretical numerical growth rate $\\gamma_{\\text{vn}}(k)$ and angular frequency $\\omega_{\\text{vn}}(k)$. The evolution of a mode over a time step $\\Delta t$ can be written as $e^{(\\gamma_{\\text{vn}} - i\\omega_{\\text{vn}})\\Delta t}$. This means the amplification factor is $G(k) = |G(k)|e^{i\\arg(G(k))} = e^{\\gamma_{\\text{vn}}\\Delta t} e^{-i\\omega_{\\text{vn}}\\Delta t}$. From this, we derive the standard relations:\n$$ \\gamma_{\\text{vn}}(k) = \\frac{\\ln|G(k)|}{\\Delta t} $$\n$$ \\omega_{\\text{vn}}(k) = -\\frac{\\arg(G(k))}{\\Delta t} $$\nThese will be calculated for each test case triplet $(\\lambda, m)$.\n\n### 2. Numerical Simulation and Measurement\n\nThe core of the numerical part is to simulate the evolution of a single, pure Fourier mode and analyze its behavior over time.\n\n**Initialization:** The spatial grid has $N_x=256$ points over a domain of length $L=1$, so $\\Delta x = L/N_x = 1/256$. The initial condition is a single complex mode $u_i^0 = \\exp(i k x_i)$ with wavenumber $k = 2 \\pi m / L$.\n\n**Time Evolution:** The field $u$ is advanced for $N_t = 4096$ steps using the upwind scheme. At each step $n$, we project the solution onto the initial Fourier mode to get its complex amplitude:\n$$ a_m^n = \\frac{1}{N_x} \\sum_{i=0}^{N_x-1} u_i^n \\exp(-i k x_i) $$\nThis is equivalent to the $m$-th component of a discrete Fourier transform of the field $u^n$. The sequence $\\{a_m^n\\}_{n=0}^{N_t-1}$ tracks the amplitude and phase of our mode of interest over time. For an ideal scheme, we would have $a_m^n = (G(k))^n$.\n\n**Spectral Analysis:** We perform a temporal Fast Fourier Transform (FFT) on the complex time series $\\{a_m^n\\}$. The discrete time step is $\\Delta t = \\lambda \\Delta x / a$.\n$$ \\mathcal{F}[a_m^n](\\omega_j) = \\sum_{n=0}^{N_t-1} a_m^n e^{-i \\omega_j n \\Delta t} $$\nThe resulting power spectrum, $P(\\omega_j) = |\\mathcal{F}[a_m^n](\\omega_j)|^2$, will be sharply peaked.\n\n**Parameter Estimation:**\n1.  **Numerical Frequency $\\omega_{\\text{num}}(k)$**: This is identified as the angular frequency $\\omega_j$ corresponding to the maximum value of the power spectrum $P(\\omega_j)$.\n2.  **Numerical Growth Rate $\\gamma_{\\text{num}}(k)$**: This is estimated from the Full Width at Half Maximum (FWHM) of the spectral peak. The relationship between the FWHM of the power spectrum of a decaying exponential signal ($e^{-\\gamma_0 t}$) and the decay rate $\\gamma_0$ is, for a Lorentzian peak, $\\text{FWHM} = 2\\gamma_0$. The problem defines the estimate as $\\gamma_{\\text{num}}(k) = -\\frac{1}{2}\\text{FWHM}$. The negative sign correctly converts the width (a positive quantity) into a damping rate (a negative growth rate). To find the FWHM, we locate the peak, find the half-maximum power level, and then find the frequencies on either side of the peak where the spectrum crosses this level. Linear interpolation between discrete frequency points is used for accuracy. If the peak is at a frequency boundary (e.g., Nyquist), a one-sided width is found and doubled, as specified.\n\n### 3. Comparison\n\nFinally, for each test case, the absolute differences between the theoretically predicted and numerically measured values are computed:\n$$ d_\\omega = |\\omega_{\\text{num}}(k) - \\omega_{\\text{vn}}(k)| $$\n$$ d_\\gamma = |\\gamma_{\\text{num}}(k) - \\gamma_{\\text{vn}}(k)| $$\nThese differences quantify the accuracy of the temporal FFT-based measurement technique in recovering the properties predicted by von Neumann analysis. The implementation will follow these steps precisely.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing numerical vs. theoretical dispersion and diffusion\n    for the 1D linear advection equation.\n    \"\"\"\n\n    # --- Fixed Parameters ---\n    N_x = 256\n    L = 1.0\n    a = 1.0\n    N_t = 4096\n    \n    # --- Test Suite ---\n    test_cases = [\n        (0.5, 12),   # General case\n        (1.0, 20),   # Boundary Courant number (exact translation)\n        (0.9, 128),  # High wavenumber (Nyquist mode)\n    ]\n\n    results = []\n\n    def _calculate_fwhm(omega_axis, power_spectrum):\n        \"\"\"\n        Calculates the Full Width at Half Maximum (FWHM) of a peak in a power spectrum.\n        Uses linear interpolation for sub-grid accuracy. Handles boundary peaks.\n        \"\"\"\n        if not np.any(power_spectrum):\n            return 0.0\n\n        peak_idx = np.argmax(power_spectrum)\n        peak_omega = omega_axis[peak_idx]\n        peak_power = power_spectrum[peak_idx]\n        \n        if peak_power == 0:\n            return 0.0\n\n        half_max_power = peak_power / 2.0\n\n        # --- Find left crossing ---\n        # Find indices of points to the left of the peak that are below half-max\n        left_indices = np.where(power_spectrum[:peak_idx]  half_max_power)[0]\n        omega_left = None\n        if left_indices.size  0:\n            idx1 = left_indices[-1]\n            idx2 = idx1 + 1\n            if idx2  peak_idx + 1:\n                p1, p2 = power_spectrum[idx1], power_spectrum[idx2]\n                w1, w2 = omega_axis[idx1], omega_axis[idx2]\n                if (p2 - p1) != 0:\n                    omega_left = w1 + (w2 - w1) * (half_max_power - p1) / (p2 - p1)\n\n        # --- Find right crossing ---\n        # Find indices of points to the right of the peak that are below half-max\n        right_indices = np.where(power_spectrum[peak_idx + 1:]  half_max_power)[0]\n        omega_right = None\n        if right_indices.size  0:\n            idx2 = right_indices[0] + peak_idx + 1\n            idx1 = idx2 - 1\n            if idx1  peak_idx -1:\n                p1, p2 = power_spectrum[idx1], power_spectrum[idx2]\n                w1, w2 = omega_axis[idx1], omega_axis[idx2]\n                if (p2 - p1) != 0:\n                    omega_right = w1 + (w2 - w1) * (half_max_power - p1) / (p2 - p1)\n        \n        # --- Calculate FWHM based on available crossings ---\n        if omega_left is not None and omega_right is not None:\n            return omega_right - omega_left\n        elif omega_left is not None: # Right crossing not found (peak at boundary)\n            return 2 * (peak_omega - omega_left)\n        elif omega_right is not None: # Left crossing not found (peak at boundary)\n            return 2 * (omega_right - peak_omega)\n        else: # No crossings found (e.g., a single delta-function-like peak)\n            return 0.0\n\n    for lam, m in test_cases:\n        # --- Derived Parameters ---\n        delta_x = L / N_x\n        delta_t = lam * delta_x / a\n        k = 2 * np.pi * m / L\n\n        # --- 1. Theoretical (von Neumann) Analysis ---\n        k_tilde = k * delta_x\n        # Amplification factor G = 1 - lambda * (1 - exp(-i*k_tilde))\n        G = 1.0 - lam * (1.0 - np.exp(-1j * k_tilde))\n        \n        # Theoretical growth rate and angular frequency\n        gamma_vn = np.log(np.abs(G)) / delta_t\n        omega_vn = -np.angle(G) / delta_t\n\n        # --- 2. Numerical Simulation ---\n        # Initialize field u with a single Fourier mode\n        x_grid = np.arange(N_x) * delta_x\n        u = np.exp(1j * k * x_grid)\n        \n        a_m_series = np.zeros(N_t, dtype=np.complex128)\n\n        # Time evolution loop\n        for n in range(N_t):\n            # Project onto the mode m to get its amplitude\n            # This is equivalent to the m-th component of the un-normalized FFT divided by N_x\n            a_m_series[n] = np.fft.fft(u)[m] / N_x\n            \n            # Update u using first-order upwind scheme with periodic boundaries\n            u_prev = np.roll(u, 1)\n            u = u - lam * (u - u_prev)\n            \n        # --- 3. Numerical Measurement from Simulation ---\n        # Temporal FFT of the modal amplitude time series\n        temporal_freqs = np.fft.fftfreq(N_t, d=delta_t)\n        temporal_omega = 2 * np.pi * temporal_freqs\n        \n        spectrum = np.fft.fft(a_m_series)\n        power_spectrum = np.abs(spectrum)**2\n\n        # For FWHM calculation, it's easier to work with a shifted spectrum\n        shifted_omega = np.fft.fftshift(temporal_omega)\n        shifted_power = np.fft.fftshift(power_spectrum)\n\n        # Find numerical frequency from the peak of the power spectrum\n        peak_idx = np.argmax(power_spectrum)\n        omega_num = temporal_omega[peak_idx]\n\n        # Estimate numerical growth rate from FWHM of the spectral peak\n        fwhm = _calculate_fwhm(shifted_omega, shifted_power)\n        gamma_num = -0.5 * fwhm\n\n        # --- 4. Comparison ---\n        diff_omega = np.abs(omega_num - omega_vn)\n        diff_gamma = np.abs(gamma_num - gamma_vn)\n        \n        results.append([diff_omega, diff_gamma])\n\n    # --- Final Output Formatting ---\n    # Create the final string in the format [[d_w1, d_g1],[d_w2, d_g2],...]\n    result_strings = [f\"[{r[0]},{r[1]}]\" for r in results]\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "Beyond verifying a single scheme, a crucial skill is the quantitative comparison of different numerical methods to select the best one for a given problem. This practice moves from simple verification to a formal comparative analysis of the first-order upwind and second-order Lax-Wendroff schemes. You will use Fourier analysis to dissect their performance, separating phase (dispersive) errors from amplitude (dissipative) errors, and apply Richardson extrapolation to numerically confirm their theoretical orders of accuracy . Mastering this technique is essential for assessing code quality and understanding the convergence properties of your simulations.",
            "id": "4022216",
            "problem": "Consider the one-dimensional linear advection equation in conservative form with a constant phase speed, given by $u_t + c\\,u_x = 0$, where $u(x,t)$ denotes a scalar field and $c$ is the physical advection speed. The objective is to quantify and control numerical diffusion and dispersion by using Fourier analysis and Richardson extrapolation across grid refinements. Work in the context of computational fusion science and engineering, where accurate wave propagation (e.g., magnetohydrodynamic wave packets) requires separating dispersive error (phase speed distortion) from dissipative error (amplitude decay).\n\nYou will analyze two explicit finite difference schemes on a uniform grid:\n- First-order upwind scheme (forward Euler in time, first-order upwind in space), defined by the update equation\n$$\nu_j^{n+1} = u_j^n - \\lambda\\left(u_j^n - u_{j-1}^n\\right),\n$$\nwhere $u_j^n$ approximates $u(jh, n\\Delta t)$, $h$ is the grid spacing, $\\Delta t$ is the time step, $j$ and $n$ are integers, and $\\lambda = c\\,\\Delta t / h$ is the Courant-Friedrichs-Lewy (CFL) number.\n- Second-order Lax–Wendroff scheme (second-order in time and space), defined by\n$$\nu_j^{n+1} = u_j^n - \\frac{\\lambda}{2}\\left(u_{j+1}^n - u_{j-1}^n\\right) + \\frac{\\lambda^2}{2}\\left(u_{j+1}^n - 2u_j^n + u_{j-1}^n\\right).\n$$\n\nUse Von Neumann Fourier analysis: substitute a single Fourier mode $u_j^n = \\hat{u}^n \\exp(i k j h)$, with wavenumber $k$ in radians per meter, and derive the complex amplification factor $G(\\theta,\\lambda)$, where $\\theta = k h$ is the nondimensional phase angle per grid cell. The complex amplification factor is related to the numerical angular frequency $\\omega_{\\mathrm{num}}$ and damping rate $\\sigma_{\\mathrm{num}}$ by $G = \\exp((\\sigma_{\\mathrm{num}} - i \\omega_{\\mathrm{num}}) \\Delta t)$. This definition leads to $\\omega_{\\mathrm{num}} = -\\arg(G) / \\Delta t$ and $\\sigma_{\\mathrm{num}} = \\ln|G| / \\Delta t$. The exact angular frequency is $\\omega_{\\mathrm{exact}} = c\\,k$, and the exact damping rate for the advection equation is $\\sigma_{\\mathrm{exact}} = 0$. The numerical phase speed is $c_{\\mathrm{num}} = \\omega_{\\mathrm{num}}/k$.\n\nDefine the dispersive error magnitude as $E_{\\mathrm{disp}}(h) = |c_{\\mathrm{num}}(h) - c|$ and the dissipative error magnitude as $E_{\\mathrm{diss}}(h) = |\\sigma_{\\mathrm{num}}(h) - \\sigma_{\\mathrm{exact}}| = |\\sigma_{\\mathrm{num}}(h)|$. For a fixed CFL number $\\lambda$ and a fixed physical advection speed $c$, refine the grid by halving $h$ and halving $\\Delta t$ accordingly (to keep $\\lambda$ constant). Use Richardson extrapolation to estimate the observed convergence order $p$ of each error component via\n$$\np \\approx \\frac{\\log\\left(E(h)/E(h/2)\\right)}{\\log(2)}.\n$$\nCompute this $p$ separately for dispersive and dissipative errors, for each scheme.\n\nAngle quantities must be treated in radians. The physical advection speed $c$ must be expressed and interpreted in $\\mathrm{m/s}$, the wavenumber $k$ in $\\mathrm{rad/m}$, the grid spacing $h$ in $\\mathrm{m}$, the time step $\\Delta t$ in $\\mathrm{s}$, and damping rates in $\\mathrm{s}^{-1}$. All outputs must be dimensionless floats.\n\nImplement a program that:\n- For each test case and each scheme, uses Fourier analysis to compute the amplification factors for two refinements $h$ and $h/2$ at a fixed $\\lambda$, then computes $E_{\\mathrm{disp}}(h)$, $E_{\\mathrm{disp}}(h/2)$, $E_{\\mathrm{diss}}(h)$, and $E_{\\mathrm{diss}}(h/2)$, and finally returns the Richardson order estimates $p_{\\mathrm{disp}}$ and $p_{\\mathrm{diss}}$.\n- Aggregates all results into a single line, formatted as a comma-separated list enclosed in square brackets, ordered per test case as $[p_{\\mathrm{disp}}^{\\mathrm{upwind}}, p_{\\mathrm{diss}}^{\\mathrm{upwind}}, p_{\\mathrm{disp}}^{\\mathrm{LW}}, p_{\\mathrm{diss}}^{\\mathrm{LW}}]$, concatenated for all test cases.\n\nUse the following test suite of parameter values to ensure coverage:\n- Test Case $1$ (general case): $c = 1.7\\,\\mathrm{m/s}$, $\\lambda = 0.65$, $k = 7.5\\,\\mathrm{rad/m}$, $h = 0.12\\,\\mathrm{m}$, $h/2 = 0.06\\,\\mathrm{m}$.\n- Test Case $2$ (long-wave limit): $c = 1.7\\,\\mathrm{m/s}$, $\\lambda = 0.65$, $k = 1.2\\,\\mathrm{rad/m}$, $h = 0.12\\,\\mathrm{m}$, $h/2 = 0.06\\,\\mathrm{m}$.\n- Test Case $3$ (near-Nyquist challenge): $c = 1.7\\,\\mathrm{m/s}$, $\\lambda = 0.65$, $k = 26.0\\,\\mathrm{rad/m}$, $h = 0.12\\,\\mathrm{m}$, $h/2 = 0.06\\,\\mathrm{m}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered for Test Case $1$, then Test Case $2$, then Test Case $3$, with each test case contributing four floats in the order described above, for a total of twelve floats, for example, $[r_1,r_2,r_3,r_4,r_5,r_6,r_7,r_8,r_9,r_{10},r_{11},r_{12}]$.",
            "solution": "The analysis of the problem begins by validating its premises. The problem is a standard exercise in the numerical analysis of partial differential equations, specifically employing Von Neumann stability and phase error analysis to study finite difference schemes for the linear advection equation. All provided equations, definitions, and parameters are scientifically sound, well-posed, and consistent. The problem is therefore deemed valid and a full solution can be constructed.\n\nThe core of the problem is to quantify numerical errors in wave propagation simulations, which is a critical aspect of computational fusion science where phenomena like magnetohydrodynamic waves must be modeled with high fidelity. The analysis separates errors into two categories: dissipative (or damping) error, which causes unphysical amplitude decay, and dispersive error, which causes waves of different wavelengths to travel at incorrect speeds.\n\nThe governing equation is the one-dimensional linear advection equation:\n$$\n\\frac{\\partial u}{\\partial t} + c \\frac{\\partial u}{\\partial x} = 0\n$$\nwhere $u(x,t)$ is a scalar quantity and $c$ is the constant advection speed. The exact solution for an initial profile $u(x,0) = f(x)$ is $u(x,t) = f(x-ct)$, representing a pure translation of the initial profile at speed $c$. For a single Fourier mode, $u(x,t) = \\exp(i(kx - \\omega t))$, the exact dispersion relation is $\\omega = ck$, and the exact damping rate is $\\sigma_{\\mathrm{exact}} = 0$.\n\nWe analyze two finite difference schemes on a uniform grid with spacing $h$ and time step $\\Delta t$.\n\n**First-Order Upwind (FOU) Scheme**\nFor a positive advection speed $c > 0$, the spatially upwind direction is to the left. Using a forward difference in time and a backward difference in space, the scheme is:\n$$\n\\frac{u_j^{n+1} - u_j^n}{\\Delta t} + c \\frac{u_j^n - u_{j-1}^n}{h} = 0\n$$\nRearranging gives the update equation from the problem statement:\n$$\nu_j^{n+1} = u_j^n - \\lambda \\left(u_j^n - u_{j-1}^n\\right)\n$$\nwhere $\\lambda = c \\Delta t / h$ is the Courant-Friedrichs-Lewy (CFL) number.\n\n**Second-Order Lax–Wendroff (LW) Scheme**\nThis scheme is derived from a Taylor series expansion in time to second order and is given by:\n$$\nu_j^{n+1} = u_j^n - \\frac{\\lambda}{2}\\left(u_{j+1}^n - u_{j-1}^n\\right) + \\frac{\\lambda^2}{2}\\left(u_{j+1}^n - 2u_j^n + u_{j-1}^n\\right)\n$$\n\n**Von Neumann Fourier Analysis**\nTo find the numerical properties of each scheme, we substitute a single Fourier mode, $u_j^n = \\hat{u}^n \\exp(ikjh)$, where $k$ is the wavenumber and $j$ is the spatial index. The solution is advanced one time step via the complex amplification factor $G$, such that $u_j^{n+1} = G u_j^n$.\n\nFor the FOU scheme, substitution yields:\n$$\nG \\hat{u}^n e^{ikjh} = \\hat{u}^n e^{ikjh} - \\lambda \\left(\\hat{u}^n e^{ikjh} - \\hat{u}^n e^{ik(j-1)h}\\right)\n$$\nDividing by $\\hat{u}^n e^{ikjh}$ and introducing the nondimensional phase angle $\\theta = kh$:\n$$\nG_{\\mathrm{FOU}}(\\theta, \\lambda) = 1 - \\lambda(1 - e^{-i\\theta}) = 1 - \\lambda(1 - (\\cos\\theta - i\\sin\\theta))\n$$\n$$\nG_{\\mathrm{FOU}}(\\theta, \\lambda) = \\left(1 - \\lambda(1-\\cos\\theta)\\right) + i\\lambda\\sin\\theta\n$$\n\nFor the LW scheme, substitution yields:\n$$\nG = 1 - \\frac{\\lambda}{2}(e^{i\\theta} - e^{-i\\theta}) + \\frac{\\lambda^2}{2}(e^{i\\theta} - 2 + e^{-i\\theta})\n$$\nUsing the identities $e^{i\\theta} - e^{-i\\theta} = 2i\\sin\\theta$ and $e^{i\\theta} + e^{-i\\theta} = 2\\cos\\theta$:\n$$\nG_{\\mathrm{LW}}(\\theta, \\lambda) = 1 - i\\lambda\\sin\\theta + \\lambda^2(\\cos\\theta - 1)\n$$\n$$\nG_{\\mathrm{LW}}(\\theta, \\lambda) = \\left(1 - \\lambda^2(1-\\cos\\theta)\\right) - i\\lambda\\sin\\theta\n$$\n\n**Error Quantification**\nThe complex amplification factor $G$ encodes a numerical damping rate $\\sigma_{\\mathrm{num}}$ and a numerical frequency $\\omega_{\\mathrm{num}}$ through the relations:\n$$\n|G| = e^{\\sigma_{\\mathrm{num}}\\Delta t} \\quad \\text{and} \\quad \\arg(G) = -\\omega_{\\mathrm{num}}\\Delta t\n$$\nFrom these, we derive the numerical properties:\n$$\n\\sigma_{\\mathrm{num}}(h) = \\frac{\\ln|G(kh, \\lambda)|}{\\Delta t} = \\frac{c}{\\lambda h}\\ln|G(kh, \\lambda)|\n$$\n$$\n\\omega_{\\mathrm{num}}(h) = -\\frac{\\arg(G(kh, \\lambda))}{\\Delta t} = -\\frac{c}{\\lambda h}\\arg(G(kh, \\lambda))\n$$\nThe numerical phase speed is $c_{\\mathrm{num}} = \\omega_{\\mathrm{num}}/k$. The errors are then defined as:\n- Dissipative Error: $E_{\\mathrm{diss}}(h) = |\\sigma_{\\mathrm{num}}(h) - \\sigma_{\\mathrm{exact}}| = |\\sigma_{\\mathrm{num}}(h)|$, since $\\sigma_{\\mathrm{exact}}=0$.\n- Dispersive Error: $E_{\\mathrm{disp}}(h) = |c_{\\mathrm{num}}(h) - c|$.\n\n**Richardson Extrapolation for Convergence Order**\nFor a numerical method with an error $E(h)$ that behaves as $E(h) \\approx C h^p$ for some constant $C$ and convergence order $p$, we can estimate $p$ by comparing the error on two different grids, $h$ and $h/2$:\n$$\nE(h) \\approx C h^p \\quad \\text{and} \\quad E(h/2) \\approx C (h/2)^p = C h^p / 2^p\n$$\nTaking the ratio gives $E(h)/E(h/2) \\approx 2^p$. Solving for $p$ yields the formula provided in the problem:\n$$\np \\approx \\frac{\\log(E(h)/E(h/2))}{\\log(2)}\n$$\nThis calculation is performed for both $E_{\\mathrm{disp}}$ and $E_{\\mathrm{diss}}$ for each scheme to find their respective observed orders of convergence, $p_{\\mathrm{disp}}$ and $p_{\\mathrm{diss}}$. The implementation will loop through the given test cases, calculate these four order parameters for each, and aggregate the results.\n\nTheoretically, the FOU scheme is first-order in space and time, so we expect $p_{\\mathrm{disp}} \\approx 1$ and $p_{\\mathrm{diss}} \\approx 1$. The LW scheme is second-order, with a leading truncation error term proportional to $u_{xxx}$ that causes dispersion, and a higher-order term proportional to $u_{xxxx}$ that causes dissipation. We therefore expect $p_{\\mathrm{disp}} \\approx 2$ and $p_{\\mathrm{diss}} \\approx 3$. The provided test cases explore different regimes of $\\theta=kh$ to check if these theoretical orders hold.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the numerical diffusion and dispersion problem by implementing\n    Von Neumann analysis and Richardson extrapolation for two finite difference schemes.\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1 (general case)\n        {'c': 1.7, 'lam': 0.65, 'k': 7.5, 'h1': 0.12, 'h2': 0.06},\n        # Test Case 2 (long-wave limit)\n        {'c': 1.7, 'lam': 0.65, 'k': 1.2, 'h1': 0.12, 'h2': 0.06},\n        # Test Case 3 (near-Nyquist challenge)\n        {'c': 1.7, 'lam': 0.65, 'k': 26.0, 'h1': 0.12, 'h2': 0.06},\n    ]\n\n    def calculate_errors(c, lam, k, h, scheme):\n        \"\"\"\n        Calculates the dispersive and dissipative errors for a given scheme and parameters.\n\n        Args:\n            c (float): Physical advection speed.\n            lam (float): CFL number.\n            k (float): Wavenumber.\n            h (float): Grid spacing.\n            scheme (str): 'upwind' or 'lw' (Lax-Wendroff).\n\n        Returns:\n            tuple: A tuple containing (E_disp, E_diss).\n        \"\"\"\n        theta = k * h\n        delta_t = lam * h / c\n\n        if scheme == 'upwind':\n            # G = 1 - lam * (1 - exp(-i*theta))\n            G = 1.0 - lam * (1.0 - np.exp(-1j * theta))\n        elif scheme == 'lw':\n            # G = 1 - lam^2*(1-cos(theta)) - i*lam*sin(theta)\n            G = 1.0 - lam**2 * (1.0 - np.cos(theta)) - 1j * lam * np.sin(theta)\n        else:\n            raise ValueError(\"Unknown scheme type\")\n\n        mag_G = np.abs(G)\n        arg_G = np.angle(G)\n\n        # Handle the case where mag_G is 0 or 1 to avoid log errors or division by zero.\n        if mag_G  1e-15:\n            sigma_num = np.log(mag_G) / delta_t\n        else:\n            # If magnitude is zero, damping is effectively infinite.\n            # Using a large negative number.\n            sigma_num = -np.inf\n        \n        omega_num = -arg_G / delta_t\n        c_num = omega_num / k\n\n        E_disp = np.abs(c_num - c)\n        E_diss = np.abs(sigma_num)\n\n        return E_disp, E_diss\n\n    def calculate_p(E_h, E_h_half):\n        \"\"\"\n        Calculates the observed order of convergence p using Richardson extrapolation.\n        \"\"\"\n        # If the error at the finer grid is zero or negative (due to floating point),\n        # convergence order calculation is not meaningful.\n        if E_h_half = 0 or E_h =0:\n            return np.nan # Not a number indicates failure to compute order.\n        \n        ratio = E_h / E_h_half\n        # If the ratio is = 1, it means the error is not decreasing,\n        # so the order is non-positive or undefined.\n        if ratio = 1.0:\n            return np.log2(ratio)\n\n        return np.log2(ratio)\n\n    results = []\n    for case in test_cases:\n        c, lam, k, h1, h2 = case['c'], case['lam'], case['k'], case['h1'], case['h2']\n\n        # Upwind Scheme\n        E_disp_up_h1, E_diss_up_h1 = calculate_errors(c, lam, k, h1, 'upwind')\n        E_disp_up_h2, E_diss_up_h2 = calculate_errors(c, lam, k, h2, 'upwind')\n        p_disp_up = calculate_p(E_disp_up_h1, E_disp_up_h2)\n        p_diss_up = calculate_p(E_diss_up_h1, E_diss_up_h2)\n\n        # Lax-Wendroff Scheme\n        E_disp_lw_h1, E_diss_lw_h1 = calculate_errors(c, lam, k, h1, 'lw')\n        E_disp_lw_h2, E_diss_lw_h2 = calculate_errors(c, lam, k, h2, 'lw')\n        p_disp_lw = calculate_p(E_disp_lw_h1, E_disp_lw_h2)\n        p_diss_lw = calculate_p(E_diss_lw_h1, E_diss_lw_h2)\n        \n        results.extend([p_disp_up, p_diss_up, p_disp_lw, p_diss_lw])\n\n    # Format output as a comma-separated list of floats within brackets.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Advanced numerical schemes for fusion plasma simulations, such as those for magnetohydrodynamics (MHD), often involve trade-offs between accuracy and robustness. This practice delves into such a trade-off by analyzing a positivity-preserving modification to a numerical flux, a technique vital for preventing unphysical states like negative density or pressure. You will quantify the \"cost\" of this robustness by measuring the additional numerical diffusion and dispersion it introduces into the simulation of fundamental plasma waves . This analysis provides critical insight into the practical design and tuning of algorithms for complex, real-world fusion modeling.",
            "id": "4022280",
            "problem": "You are tasked with designing and analyzing a positivity-preserving numerical flux modification for one-dimensional compressible Magnetohydrodynamics (MHD) and quantifying its side effects on numerical diffusion and dispersion in linear wave tests representative of fusion plasma modeling. Start from the conservation-law form of one-dimensional ideal compressible MHD and the Finite Volume Method (FVM) with uniform grid spacing. Use the following foundational base:\n\n- Conservation laws for mass, momentum, and energy in one-dimensional ideal compressible Magnetohydrodynamics (MHD).\n- The sound speed definition $c_s$ given by $c_s^2 = \\gamma p / \\rho$ for adiabatic index $\\gamma$, pressure $p$, and density $\\rho$.\n- The Alfvén speed definition $c_A$ given by $c_A^2 = B^2 / (\\mu_0 \\rho)$ for magnetic field magnitude $B$ and permeability of free space $\\mu_0$.\n- For parallel propagation relative to the background magnetic field, the fast and slow magnetosonic characteristic speeds are $c_f = \\max(c_s, c_A)$ and $c_{slow} = \\min(c_s, c_A)$.\n- The Courant-Friedrichs-Lewy (CFL) number is $\\mathrm{CFL} = a \\Delta t / \\Delta x$, where $a$ is a chosen characteristic speed used in a Rusanov (Local Lax-Friedrichs) flux, $\\Delta t$ is the time step, and $\\Delta x$ is the grid spacing.\n\nDesign a positivity-preserving flux modification within the Rusanov flux framework by increasing its dissipation coefficient through a multiplicative factor, and analyze the induced changes in numerical diffusion and dispersion. The Rusanov flux parameter $a$ must be chosen as a physically justifiable upper bound on the characteristic speeds relevant to the wave under consideration. The positivity-preserving modification is modeled as scaling the Rusanov viscosity by a factor $ \\beta \\ge 1$, applied uniformly to all characteristic fields. Under linearization and characteristic decomposition, treat each compressive wave as a decoupled scalar advection mode with speed $c$.\n\nFor a linear Fourier mode with wavenumber $k$ and grid spacing $\\Delta x$, define the dimensionless wavenumber $\\kappa = k \\Delta x$. Using a first-order explicit Euler time advancement and a first-order Rusanov flux with dissipation scaled by $\\beta$, derive the discrete amplification factor $g(\\kappa)$ for the scalar characteristic field and use it to compute the numerical angular frequency $\\omega_{\\mathrm{num}}$ and damping rate $\\gamma_{\\mathrm{num}}$ via the complex logarithm of $g$. Then compute the numerical phase speed $c_{\\mathrm{num}} = \\omega_{\\mathrm{num}} / k$. Quantify the side effects of the positivity-preserving modification by the differences, relative to the unmodified baseline ($\\beta = 1$), in:\n- the relative phase speed error, defined as $\\Delta \\varepsilon = \\left(\\frac{c_{\\mathrm{num}}^{(\\beta)} - c_{\\mathrm{num}}^{(1)}}{c}\\right)$ (dimensionless), and\n- the excess damping rate, defined as $\\Delta \\gamma = \\gamma_{\\mathrm{num}}^{(\\beta)} - \\gamma_{\\mathrm{num}}^{(1)}$ (in $\\mathrm{s}^{-1}$).\n\nYou must implement these computations in a single, complete, runnable program, adhering to the execution environment constraints stated in the final answer specification. All quantities with physical units must be handled consistently and reported in the requested units. Angles are always in radians.\n\nUse the following test suite of parameter sets; each test defines the physical and numerical parameters for one linear wave, and must be processed independently:\n\n- Test 1 (Acoustic wave, no magnetic field): $c_s = 2.0 \\times 10^{5}\\ \\mathrm{m/s}$, $B = 0$ so $c_A = 0$, select $c = c_s$, select $a = c$, grid spacing $\\Delta x = 1.0 \\times 10^{-3}\\ \\mathrm{m}$, dimensionless wavenumber $\\kappa = \\pi/3$, $\\mathrm{CFL} = 0.8$, positivity scaling $\\beta = 1.4$.\n- Test 2 (Fast magnetosonic wave, parallel propagation): $c_s = 1.0 \\times 10^{5}\\ \\mathrm{m/s}$, $c_A = 2.0 \\times 10^{5}\\ \\mathrm{m/s}$, select $c = c_f = \\max(c_s, c_A)$, select $a = c_f$, grid spacing $\\Delta x = 1.0 \\times 10^{-3}\\ \\mathrm{m}$, dimensionless wavenumber $\\kappa = 0.5$, $\\mathrm{CFL} = 0.9$, positivity scaling $\\beta = 1.2$.\n- Test 3 (Slow magnetosonic wave, parallel propagation, high wavenumber): $c_s = 1.0 \\times 10^{5}\\ \\mathrm{m/s}$, $c_A = 2.0 \\times 10^{5}\\ \\mathrm{m/s}$, select $c = c_{slow} = \\min(c_s, c_A)$, select $a = c_f = \\max(c_s, c_A)$, grid spacing $\\Delta x = 1.0 \\times 10^{-3}\\ \\mathrm{m}$, dimensionless wavenumber $\\kappa = 0.9\\pi$, $\\mathrm{CFL} = 0.9$, positivity scaling $\\beta = 1.2$.\n- Test 4 (Acoustic wave near stability limit): $c_s = 1.5 \\times 10^{5}\\ \\mathrm{m/s}$, $B = 0$ so $c_A = 0$, select $c = c_s$, select $a = c$, grid spacing $\\Delta x = 1.0 \\times 10^{-3}\\ \\mathrm{m}$, dimensionless wavenumber $\\kappa = \\pi/8$, $\\mathrm{CFL} = 0.99$, positivity scaling $\\beta = 1.6$.\n\nFor each test, compute:\n- the difference in relative phase speed error $\\Delta \\varepsilon$ (dimensionless), and\n- the excess damping rate $\\Delta \\gamma$ in $\\mathrm{s}^{-1}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the exact format:\n$[ [\\Delta \\varepsilon_1, \\Delta \\gamma_1], [\\Delta \\varepsilon_2, \\Delta \\gamma_2], [\\Delta \\varepsilon_3, \\Delta \\gamma_3], [\\Delta \\varepsilon_4, \\Delta \\gamma_4] ]$.",
            "solution": "We begin from the one-dimensional ideal compressible Magnetohydrodynamics (MHD) conservation laws, discretized with the Finite Volume Method (FVM) on a uniform grid of spacing $\\Delta x$. For linear analysis, around a uniform equilibrium with constant density, pressure, and magnetic field aligned with the $x$-axis, the characteristic fields decouple into waves that advect information at constant speeds. In parallel propagation, the compressive modes are the fast and slow magnetosonic waves with speeds $c_f = \\max(c_s, c_A)$ and $c_{slow} = \\min(c_s, c_A)$, and in the absence of magnetic field ($B=0$), the compressive wave reduces to an acoustic wave with speed $c = c_s$.\n\nWe consider a first-order explicit Euler time advancement and a first-order Rusanov (Local Lax-Friedrichs) flux for a single characteristic scalar field $u(x,t)$ obeying $\\partial_t u + c \\partial_x u = 0$ in the linearized setting. The numerical flux at interface $j+1/2$ is defined as\n$$\nF_{j+1/2} = \\frac{1}{2} c \\left(u_j + u_{j+1} \\right) - \\frac{1}{2} \\beta a \\left(u_{j+1} - u_j \\right) ,\n$$\nwhere $a$ is the chosen characteristic speed used by the Rusanov flux, and $\\beta \\ge 1$ is a multiplicative scaling that enhances numerical viscosity as a positivity-preserving modification. The forward Euler update for the cell average $u_j^n$ at time level $n$ is\n$$\nu_j^{n+1} = u_j^{n} - \\frac{\\Delta t}{\\Delta x} \\left( F_{j+1/2} - F_{j-1/2} \\right) .\n$$\n\nTo analyze dispersion and diffusion for Fourier modes, consider a mode $u_j^n = U^n e^{\\mathrm{i} j \\kappa}$, where $\\kappa = k \\Delta x$ is the dimensionless wavenumber, $k$ is the physical wavenumber in $\\mathrm{rad/m}$, and $j$ is the grid index. Using discrete Fourier identities for this mode, $u_{j+1} - u_{j-1} = 2\\mathrm{i} \\sin(\\kappa) u_j$ and $u_{j+1} - 2u_j + u_{j-1} = -4 \\sin^2\\left(\\frac{\\kappa}{2}\\right) u_j$. Substituting these into the update rule allows us to derive the discrete amplification factor $g(\\kappa)$:\n$$\ng(\\kappa) = 1 - \\mathrm{i} \\lambda \\sin(\\kappa) - 2 \\beta \\left(\\frac{a \\Delta t}{\\Delta x}\\right) \\sin^2\\left(\\frac{\\kappa}{2}\\right)\n$$\nwhere $\\lambda = \\frac{c \\Delta t}{\\Delta x}$ is the advection Courant number. The complex amplification factor $g$ governs both dispersion and diffusion. The problem defines the evolution of a mode $U$ over a single time step as $U(t+\\Delta t) = \\exp\\left( -(\\gamma_{\\mathrm{num}} + \\mathrm{i}\\omega_{\\mathrm{num}}) \\Delta t \\right) U(t)$, where $\\gamma_{\\mathrm{num}}$ is a positive damping rate. Therefore, the amplification factor is $g = \\exp\\left( -(\\gamma_{\\mathrm{num}} + \\mathrm{i}\\omega_{\\mathrm{num}}) \\Delta t \\right)$, and its complex logarithm is\n$$\n\\ln(g) = -\\gamma_{\\mathrm{num}} \\Delta t - \\mathrm{i}\\omega_{\\mathrm{num}} \\Delta t .\n$$\nThus, the numerical angular frequency $\\omega_{\\mathrm{num}}$ and damping rate $\\gamma_{\\mathrm{num}}$ are obtained from the complex logarithm of $g$:\n$$\n\\omega_{\\mathrm{num}} = - \\frac{\\operatorname{Im} (\\ln g)}{\\Delta t}, \\quad \\gamma_{\\mathrm{num}} = - \\frac{\\operatorname{Re} (\\ln g)}{\\Delta t} .\n$$\nThe numerical phase speed is $c_{\\mathrm{num}} = \\omega_{\\mathrm{num}} / k$ since $k$ is in $\\mathrm{rad/m}$ and $\\omega_{\\mathrm{num}}$ is in $\\mathrm{rad/s}$.\n\nPositivity-preserving design rationale: In multiple space dimensions and for full compressible MHD, positivity of density and pressure can be enforced in high-order schemes by blending a low-order monotone flux (such as the Rusanov flux) into the high-order flux when a positivity violation is detected. A sufficient condition for monotonicity of the first-order scheme is that the update for $u_j$ be a convex combination of neighboring states, which holds when the coefficients of $u_{j-1}$, $u_j$, and $u_{j+1}$ are nonnegative and sum to one. For the scalar linear advection with the modified Rusanov flux, a conservative update can be expressed as\n$$\nu_j^{n+1} = \\alpha_{-1} u_{j-1}^{n} + \\alpha_0 u_j^n + \\alpha_{+1} u_{j+1}^n\n$$\nwith\n$$\n\\alpha_{\\pm 1} = \\frac{\\Delta t}{2\\Delta x} \\left( \\beta a \\mp c \\right), \\quad \\alpha_0 = 1 - \\frac{\\Delta t}{\\Delta x} \\beta a .\n$$\nNonnegativity of $\\alpha_{\\pm 1}$ and $\\alpha_0$ requires\n$$\n\\frac{\\Delta t}{\\Delta x} \\beta a \\le 1 \\quad \\text{and} \\quad \\beta a \\ge |c|,\n$$\nthe latter being automatic if we choose $a$ as an upper bound on all characteristic speeds and $\\beta \\ge 1$. Under these conditions the scheme is monotone and thus positivity-preserving for convex invariants at the linear level, which motivates increasing $\\beta$ to prevent negativity in density and pressure when applied as a fallback in nonlinear MHD. The side effect of increasing $\\beta$ is increased artificial viscosity, which reduces the magnitude of $g(\\kappa)$ (stronger damping) and also modifies its phase (dispersion).\n\nAlgorithmic steps to compute the required metrics for each test case:\n1. Determine the physical wave speed $c$ appropriate to the test: for acoustic, $c = c_s$; for fast magnetosonic, $c = c_f = \\max(c_s, c_A)$; for slow magnetosonic, $c = c_{slow} = \\min(c_s, c_A)$.\n2. Select the Rusanov characteristic speed $a$ based on the test specification (usually $a = c_f$ for MHD and $a = c_s$ for acoustic).\n3. Given the grid spacing $\\Delta x$ and dimensionless wavenumber $\\kappa$, compute the physical wavenumber $k = \\kappa / \\Delta x$ in $\\mathrm{rad/m}$.\n4. Compute the time step $\\Delta t = \\mathrm{CFL} \\, \\Delta x / a$ using the specified Courant-Friedrichs-Lewy number.\n5. Form the amplification factor $g(\\kappa)$ for the baseline ($\\beta = 1$) and for the positivity-preserving modification ($\\beta$ as specified) via\n$$\ng(\\kappa) = 1 - \\mathrm{i} \\left(\\frac{c \\Delta t}{\\Delta x}\\right) \\sin(\\kappa) - 2 \\beta \\left(\\frac{a \\Delta t}{\\Delta x}\\right) \\sin^2\\left(\\frac{\\kappa}{2}\\right) .\n$$\n6. Compute $\\ln(g)$ for both cases, then $\\omega_{\\mathrm{num}}$ and $\\gamma_{\\mathrm{num}}$ as above, and obtain $c_{\\mathrm{num}} = \\omega_{\\mathrm{num}}/k$.\n7. Report the differences $\\Delta \\varepsilon = \\left(\\frac{c_{\\mathrm{num}}^{(\\beta)} - c_{\\mathrm{num}}^{(1)}}{c}\\right)$ (dimensionless) and $\\Delta \\gamma = \\gamma_{\\mathrm{num}}^{(\\beta)} - \\gamma_{\\mathrm{num}}^{(1)}$ in $\\mathrm{s}^{-1}$.\n\nScientific realism: The chosen speeds and grid spacings are consistent with fusion plasma parameters where $c_s$ and $c_A$ can be on the order of $10^5\\ \\mathrm{m/s}$, and $\\Delta x = 10^{-3}\\ \\mathrm{m}$ is a plausible discretization at reduced-model scales. The analysis adheres to linearized characteristic fields, a standard and well-tested approach for dispersion-diffusion studies. Units are consistently handled: $c$ and $a$ in $\\mathrm{m/s}$, $\\Delta x$ in $\\mathrm{m}$, $\\Delta t$ in $\\mathrm{s}$, $\\kappa$ in radians, $k$ in $\\mathrm{rad/m}$, $\\omega_{\\mathrm{num}}$ in $\\mathrm{rad/s}$, and $\\gamma_{\\mathrm{num}}$ in $\\mathrm{s}^{-1}$.\n\nThe test suite consists of four cases spanning acoustic and magnetosonic waves, moderate and near-boundary CFL numbers, and low and high wavenumbers, ensuring coverage of dispersion and diffusion behaviors. The final program output is a single line containing a list of pairs $[\\Delta \\varepsilon_i, \\Delta \\gamma_i]$ for $i=1,2,3,4$, precisely in the format $[ [\\Delta \\varepsilon_1, \\Delta \\gamma_1], [\\Delta \\varepsilon_2, \\Delta \\gamma_2], [\\Delta \\varepsilon_3, \\Delta \\gamma_3], [\\Delta \\varepsilon_4, \\Delta \\gamma_4] ]$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_metrics(c, a, dx, kappa, CFL, beta_pos):\n    \"\"\"\n    Compute delta phase error (dimensionless) and excess damping rate (1/s)\n    due to positivity-preserving modification (beta_pos) relative to baseline (beta=1).\n    Parameters:\n        c       : physical wave speed (m/s)\n        a       : Rusanov characteristic speed (m/s)\n        dx      : grid spacing (m)\n        kappa   : dimensionless wavenumber (radians)\n        CFL     : Courant-Friedrichs-Lewy number (dimensionless)\n        beta_pos: positivity scaling factor (=1, dimensionless)\n    Returns:\n        (delta_rel_phase_error, delta_damping_rate)\n    \"\"\"\n    # Physical wavenumber (rad/m)\n    k = kappa / dx\n    # Time step from CFL\n    dt = CFL * dx / a\n\n    # Helper to compute amplification factor g for given beta\n    def amplification(beta):\n        lam_adv = (c * dt) / dx\n        lam_diss = (a * dt) / dx\n        g = 1.0 - 1j * lam_adv * np.sin(kappa) - 2.0 * beta * lam_diss * (np.sin(kappa / 2.0) ** 2)\n        return g\n\n    # Baseline (beta=1.0) and positivity-preserving (beta=beta_pos)\n    g_base = amplification(1.0)\n    g_pos = amplification(beta_pos)\n\n    # Complex logarithm to get numerical angular frequency and damping rate\n    ln_base = np.log(g_base)\n    ln_pos = np.log(g_pos)\n\n    omega_base = -np.imag(ln_base) / dt  # rad/s\n    omega_pos = -np.imag(ln_pos) / dt    # rad/s\n\n    gamma_base = -np.real(ln_base) / dt  # 1/s\n    gamma_pos = -np.real(ln_pos) / dt    # 1/s\n\n    # Numerical phase speeds (m/s)\n    c_num_base = omega_base / k\n    c_num_pos = omega_pos / k\n\n    # Side effects: differences relative to baseline\n    delta_rel_phase_error = (c_num_pos - c_num_base) / c  # dimensionless\n    delta_damping_rate = gamma_pos - gamma_base           # 1/s\n\n    return float(delta_rel_phase_error), float(delta_damping_rate)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (c_s, c_A, choose_c, a, dx, kappa, CFL, beta_pos)\n    # For acoustic waves, c_A = 0; choose_c indicates selection rule (\"acoustic\", \"fast\", \"slow\").\n    test_cases = [\n        # Test 1: Acoustic wave, no magnetic field\n        {\"c_s\": 2.0e5, \"c_A\": 0.0, \"choose_c\": \"acoustic\", \"a_rule\": \"acoustic\",\n         \"dx\": 1.0e-3, \"kappa\": np.pi/3.0, \"CFL\": 0.8, \"beta_pos\": 1.4},\n        # Test 2: Fast magnetosonic wave, parallel propagation\n        {\"c_s\": 1.0e5, \"c_A\": 2.0e5, \"choose_c\": \"fast\", \"a_rule\": \"fast\",\n         \"dx\": 1.0e-3, \"kappa\": 0.5, \"CFL\": 0.9, \"beta_pos\": 1.2},\n        # Test 3: Slow magnetosonic wave, high wavenumber\n        {\"c_s\": 1.0e5, \"c_A\": 2.0e5, \"choose_c\": \"slow\", \"a_rule\": \"fast\",\n         \"dx\": 1.0e-3, \"kappa\": 0.9*np.pi, \"CFL\": 0.9, \"beta_pos\": 1.2},\n        # Test 4: Acoustic wave near stability limit\n        {\"c_s\": 1.5e5, \"c_A\": 0.0, \"choose_c\": \"acoustic\", \"a_rule\": \"acoustic\",\n         \"dx\": 1.0e-3, \"kappa\": np.pi/8.0, \"CFL\": 0.99, \"beta_pos\": 1.6},\n    ]\n\n    results = []\n    for case in test_cases:\n        c_s = case[\"c_s\"]\n        c_A = case[\"c_A\"]\n        # Select wave speed c\n        if case[\"choose_c\"] == \"acoustic\":\n            c = c_s\n        elif case[\"choose_c\"] == \"fast\":\n            c = max(c_s, c_A)\n        elif case[\"choose_c\"] == \"slow\":\n            c = min(c_s, c_A)\n        else:\n            raise ValueError(\"Unknown choose_c rule\")\n\n        # Select Rusanov speed a\n        if case[\"a_rule\"] == \"acoustic\":\n            a = c_s\n        elif case[\"a_rule\"] == \"fast\":\n            a = max(c_s, c_A)\n        else:\n            raise ValueError(\"Unknown a_rule\")\n\n        dx = case[\"dx\"]\n        kappa = case[\"kappa\"]\n        CFL = case[\"CFL\"]\n        beta_pos = case[\"beta_pos\"]\n\n        delta_rel_phase_error, delta_damping_rate = compute_metrics(\n            c=c, a=a, dx=dx, kappa=kappa, CFL=CFL, beta_pos=beta_pos\n        )\n        results.append([delta_rel_phase_error, delta_damping_rate])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(item) for item in results)}]\")\n\nsolve()\n```"
        }
    ]
}