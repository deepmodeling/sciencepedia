{
    "hands_on_practices": [
        {
            "introduction": "A deep connection exists between the variational principles of classical mechanics and the construction of structure-preserving algorithms. This exercise explores this link by asking you to derive a symplectic integrator from first principles using a Type-1 generating function . By applying a symmetric discretization to the action integral for a simple harmonic oscillator, you will construct a time-reversible, second-order map and see how the fundamental properties of the integrator emerge directly from the underlying Hamiltonian structure.",
            "id": "4049887",
            "problem": "In a reduced single-degree-of-freedom model for small-amplitude radial oscillations of a guiding-center near the magnetic axis in a toroidal confinement device, the dynamics in canonical coordinates are approximated by the quadratic Hamiltonian\n$$\nH(q,p) \\;=\\; \\frac{1}{2 m}\\,p^{2} \\;+\\; \\frac{1}{2}\\,k\\,q^{2},\n$$\nwhere $m>0$ is an effective mass parameter and $k>0$ encodes the local quadratic curvature of the effective potential. Let $h>0$ be a fixed time step. Using only fundamental variational principles and the definition of canonical transformations, construct a symplectic one-step method by introducing a Type-1 generating function $S_{1}(q,Q;h)$, where $q$ and $Q$ denote the old and new configuration positions at consecutive time nodes separated by $h$. The construction must begin from Hamilton’s principle and the definition of a generating function of the first kind, and it must employ a symmetric approximation of the action over one time step to obtain a second-order, time-reversible map. From the resulting $S_{1}(q,Q;h)$, derive the explicit update relations mapping $(q_{n},p_{n})$ to $(q_{n+1},p_{n+1})$, demonstrating that the map is linear and symplectic. Express all intermediate relations symbolically in terms of $m$, $k$, and $h$.\n\nProvide as your final answer the closed-form expression for the generating function $S_{1}(q,Q;h)$ in terms of $m$, $k$, and $h$. Do not include any numerical evaluation or rounding. No physical units are required in the final answer.",
            "solution": "The problem requires the construction of a symplectic one-step method for a simple harmonic oscillator using a Type-1 generating function, $S_{1}(q,Q;h)$. The construction must be derived from first principles, specifically Hamilton's principle, and employ a symmetric approximation for the action integral.\n\nThe Hamiltonian for the system is given by\n$$ H(q,p) = \\frac{1}{2 m}\\,p^{2} + \\frac{1}{2}\\,k\\,q^{2} $$\nwhere $q$ is the position, $p$ is the momentum, $m>0$ is the effective mass, and $k>0$ is the spring constant. The corresponding Lagrangian $L(q, \\dot{q}) = p\\dot{q} - H$ is found by first expressing $p$ in terms of $\\dot{q}$. From Hamilton's equation $\\dot{q} = \\frac{\\partial H}{\\partial p} = \\frac{p}{m}$, we have $p = m\\dot{q}$. Substituting this into the definition of the Lagrangian gives\n$$ L(q, \\dot{q}) = (m\\dot{q})\\dot{q} - \\left(\\frac{1}{2m}(m\\dot{q})^2 + \\frac{1}{2}kq^2\\right) = \\frac{1}{2}m\\dot{q}^2 - \\frac{1}{2}kq^2 $$\n\nHamilton's principle states that the trajectory of a system between two points in configuration space, $q(t_n)$ and $q(t_{n+1})$, extremizes the action integral $A = \\int_{t_n}^{t_{n+1}} L(q(t), \\dot{q}(t)) dt$. In the theory of canonical transformations, a Type-1 generating function $S_1(q, Q; h)$ connects the old coordinates $(q,p)$ at time $t_n$ to the new coordinates $(Q,P)$ at time $t_{n+1} = t_n+h$ via the relations\n$$ p = \\frac{\\partial S_1}{\\partial q} \\quad \\text{and} \\quad P = -\\frac{\\partial S_1}{\\partial Q} $$\nThe generating function itself is an approximation to the action integral along the true path: $S_1(q, Q; h) \\approx \\int_{t_n}^{t_{n+1}} L(q(t), \\dot{q}(t)) dt$.\n\nTo construct a second-order, time-reversible map, we must use a symmetric approximation for the action integral. The most natural symmetric approximation is the midpoint rule, where the continuous Lagrangian $L(q(t), \\dot{q}(t))$ over the interval $[t_n, t_{n+1}]$ of duration $h$ is approximated by its value at the midpoint in time, $t_n + h/2$. The position and velocity at the midpoint are approximated by symmetric finite differences:\n$$ q(t_n+h/2) \\approx \\frac{q+Q}{2} \\quad \\text{and} \\quad \\dot{q}(t_n+h/2) \\approx \\frac{Q-q}{h} $$\nwhere $q = q(t_n)$ and $Q = q(t_{n+1})$. The action integral is then approximated as\n$$ A \\approx h \\cdot L\\left(\\frac{q+Q}{2}, \\frac{Q-q}{h}\\right) $$\nSubstituting the expression for the Lagrangian, we define our generating function as:\n$$ S_1(q, Q; h) = h \\left[ \\frac{1}{2}m\\left(\\frac{Q-q}{h}\\right)^2 - \\frac{1}{2}k\\left(\\frac{q+Q}{2}\\right)^2 \\right] $$\n$$ S_1(q, Q; h) = \\frac{m}{2h}(Q-q)^2 - \\frac{kh}{8}(q+Q)^2 $$\nThis is the required generating function.\n\nNext, we derive the explicit update relations mapping $(q_n, p_n)$ to $(q_{n+1}, p_{n+1})$. We identify $q=q_n$, $p=p_n$, $Q=q_{n+1}$, and $P=p_{n+1}$. Using the defining relations for $S_1$:\n$$ p_n = \\frac{\\partial S_1}{\\partial q_n} = \\frac{m}{2h} \\cdot 2(q_{n+1}-q_n)(-1) - \\frac{kh}{8} \\cdot 2(q_n+q_{n+1})(1) = -\\frac{m}{h}(q_{n+1}-q_n) - \\frac{kh}{4}(q_n+q_{n+1}) $$\n$$ p_{n+1} = -\\frac{\\partial S_1}{\\partial q_{n+1}} = -\\left[ \\frac{m}{2h} \\cdot 2(q_{n+1}-q_n)(1) - \\frac{kh}{8} \\cdot 2(q_n+q_{n+1})(1) \\right] = -\\frac{m}{h}(q_{n+1}-q_n) + \\frac{kh}{4}(q_n+q_{n+1}) $$\nThese two equations implicitly define the map. We rearrange them to solve for $(q_{n+1}, p_{n+1})$ as an explicit function of $(q_n, p_n)$. First, isolate the terms with $q_n$ and $q_{n+1}$:\n$$ p_n = \\left(\\frac{m}{h} - \\frac{kh}{4}\\right)q_n - \\left(\\frac{m}{h} + \\frac{kh}{4}\\right)q_{n+1} \\quad (1) $$\n$$ p_{n+1} = \\left(\\frac{m}{h} + \\frac{kh}{4}\\right)q_n - \\left(\\frac{m}{h} - \\frac{kh}{4}\\right)q_{n+1} \\quad (2) $$\nFrom equation (1), we solve for $q_{n+1}$:\n$$ \\left(\\frac{m}{h} + \\frac{kh}{4}\\right)q_{n+1} = \\left(\\frac{m}{h} - \\frac{kh}{4}\\right)q_n - p_n $$\n$$ q_{n+1} = \\frac{\\frac{m}{h} - \\frac{kh}{4}}{\\frac{m}{h} + \\frac{kh}{4}} q_n - \\frac{1}{\\frac{m}{h} + \\frac{kh}{4}} p_n = \\frac{4m-kh^2}{4m+kh^2}q_n - \\frac{4h}{4m+kh^2}p_n $$\nNow we find $p_{n+1}$ by substituting this expression for $q_{n+1}$ into equation (2). For algebraic simplicity, let $A = \\frac{m}{h} + \\frac{kh}{4}$ and $B = \\frac{m}{h} - \\frac{kh}{4}$. The map is $q_{n+1} = \\frac{B}{A}q_n - \\frac{1}{A}p_n$ and $p_{n+1} = A q_n - B q_{n+1}$.\n$$ p_{n+1} = A q_n - B\\left(\\frac{B}{A}q_n - \\frac{1}{A}p_n\\right) = \\left(A - \\frac{B^2}{A}\\right)q_n + \\frac{B}{A}p_n = \\frac{A^2-B^2}{A}q_n + \\frac{B}{A}p_n $$\nWe calculate the terms:\n$$ A^2 - B^2 = (A-B)(A+B) = \\left( \\frac{kh}{2} \\right) \\left( \\frac{2m}{h} \\right) = km $$\nSo, the coefficient of $q_n$ is $\\frac{km}{A} = \\frac{km}{\\frac{m}{h} + \\frac{kh}{4}} = \\frac{4hkm}{4m+kh^2}$. The coefficient of $p_n$ is $\\frac{B}{A} = \\frac{4m-kh^2}{4m+kh^2}$.\nThe complete update relations are:\n$$ q_{n+1} = \\frac{4m-kh^2}{4m+kh^2}\\,q_n - \\frac{4h}{4m+kh^2}\\,p_n $$\n$$ p_{n+1} = \\frac{4hkm}{4m+kh^2}\\,q_n + \\frac{4m-kh^2}{4m+kh^2}\\,p_n $$\nThis transformation is linear, as it can be expressed in matrix form. Let $z_n = \\begin{pmatrix} q_n \\\\ p_n \\end{pmatrix}$. Then $z_{n+1} = M z_n$, where the map matrix $M$ is\n$$ M = \\frac{1}{4m+kh^2} \\begin{pmatrix} 4m - kh^2 & -4h \\\\ 4hkm & 4m - kh^2 \\end{pmatrix} $$\nTo demonstrate that the map is symplectic, we must show that the Jacobian matrix $M$ satisfies $M^T J M = J$, where $J = \\begin{pmatrix} 0 & 1 \\\\ -1 & 0 \\end{pmatrix}$. For a $2 \\times 2$ matrix, this condition is equivalent to $\\det(M)=1$.\n$$ \\det(M) = \\left( \\frac{1}{4m+kh^2} \\right)^2 \\left[ (4m-kh^2)^2 - (-4h)(4hkm) \\right] $$\n$$ \\det(M) = \\frac{1}{(4m+kh^2)^2} \\left[ (16m^2 - 8mkh^2 + k^2h^4) + 16h^2km \\right] $$\n$$ \\det(M) = \\frac{1}{(4m+kh^2)^2} \\left[ 16m^2 + 8mkh^2 + k^2h^4 \\right] = \\frac{(4m+kh^2)^2}{(4m+kh^2)^2} = 1 $$\nSince $\\det(M)=1$, the map is symplectic. This method, derived from a symmetric approximation of the action, is the implicit midpoint rule, which is a second-order, time-reversible, and symplectic integrator. The construction fulfills all requirements of the problem.\n\nThe problem asks for the closed-form expression of the generating function $S_1(q,Q;h)$. Based on the derivation above, this is:\n$$ S_1(q, Q; h) = \\frac{m}{2h}(Q-q)^2 - \\frac{kh}{8}(q+Q)^2 $$",
            "answer": "$$ \\boxed{ \\frac{m}{2h}(Q-q)^2 - \\frac{kh}{8}(q+Q)^2 } $$"
        },
        {
            "introduction": "Beyond variational methods, operator splitting offers a versatile and powerful framework for designing geometric integrators, especially for systems where the dynamics can be decomposed into simpler, exactly solvable parts. This practice focuses on the motion of a charged particle in a magnetic field, a core problem in fusion science, guiding you to construct the celebrated Boris algorithm through symmetric splitting . You will then computationally verify the algorithm's exact time-reversibility, a hallmark of its geometric nature and a key to its excellent long-term fidelity.",
            "id": "4049930",
            "problem": "Consider the motion of a single charged particle in a static magnetic field within the context of magnetized plasma dynamics relevant to computational fusion science and engineering. The particle of charge $q$ and mass $m$ obeys Newton’s second law with the Lorentz magnetic force: $m \\,\\dfrac{d\\mathbf{v}}{dt} = q\\,\\mathbf{v}\\times\\mathbf{B}(\\mathbf{r})$ and $\\dfrac{d\\mathbf{r}}{dt} = \\mathbf{v}$, where $\\mathbf{r}\\in\\mathbb{R}^3$ is position, $\\mathbf{v}\\in\\mathbb{R}^3$ is velocity, and $\\mathbf{B}(\\mathbf{r})\\in\\mathbb{R}^3$ is a divergence-free magnetic field. Starting from these fundamental laws, construct a one-step, explicit, structure-preserving geometric algorithm that is reversible in time. The algorithm must be derived from first principles using a symmetric splitting of the flow that preserves the canonical geometric properties of the pure magnetic dynamics, namely phase-space volume preservation and exact time symmetry. Your derived scheme should not introduce any artificial dissipation and must be consistent with the invariance of the kinetic energy in a static magnetic field (since $\\mathbf{v}\\cdot(\\mathbf{v}\\times\\mathbf{B})=0$).\n\nYour program must implement the derived reversible scheme and numerically demonstrate its exact time symmetry property by performing the following computational experiment for each test case: integrate forward $N$ steps with time step $h$ from $(\\mathbf{r}_0,\\mathbf{v}_0)$ to $(\\mathbf{r}_N,\\mathbf{v}_N)$, then integrate backward $N$ steps with time step $-h$ from $(\\mathbf{r}_N,\\mathbf{v}_N)$, and verify that the final state $(\\mathbf{r}_{\\text{rev}},\\mathbf{v}_{\\text{rev}})$ matches the initial state $(\\mathbf{r}_0,\\mathbf{v}_0)$ to within numerical precision. Conclude time symmetry if both $ \\| \\mathbf{r}_{\\text{rev}} - \\mathbf{r}_0 \\|_{\\infty} $ and $ \\| \\mathbf{v}_{\\text{rev}} - \\mathbf{v}_0 \\|_{\\infty} $ are less than a tolerance proportional to machine precision times the scale of the initial data. All quantities in the program must be treated in the International System of Units (SI units): meters (m), seconds (s), kilograms (kg), and Coulombs (C). Angles, if internally used, must be interpreted in radians.\n\nThe test suite consists of five scientifically plausible parameter sets, chosen to probe different regimes and edge cases of magnetized motion:\n- Test 1 (uniform field, moderate step): $q=1.602176634\\times 10^{-19}\\,\\text{C}$, $m=1.67262192369\\times 10^{-27}\\,\\text{kg}$, $\\mathbf{B}(\\mathbf{r})=\\left[0,0,B_0\\right]$ with $B_0=3\\,\\text{T}$, $h=1.0\\times 10^{-9}\\,\\text{s}$, $N=100$, $\\mathbf{r}_0=[0.1,0.0,0.0]\\,\\text{m}$, $\\mathbf{v}_0=[1.0\\times 10^{5},2.0\\times 10^{5},0.0]\\,\\text{m/s}$.\n- Test 2 (zero field boundary case): $q=1.602176634\\times 10^{-19}\\,\\text{C}$, $m=1.67262192369\\times 10^{-27}\\,\\text{kg}$, $\\mathbf{B}(\\mathbf{r})=\\left[0,0,0\\right]\\,\\text{T}$, $h=2.0\\times 10^{-9}\\,\\text{s}$, $N=50$, $\\mathbf{r}_0=[-0.3,0.2,0.0]\\,\\text{m}$, $\\mathbf{v}_0=[-5.0\\times 10^{4},1.0\\times 10^{5},1.0\\times 10^{5}]\\,\\text{m/s}$.\n- Test 3 (nonuniform divergence-free field): $q=1.602176634\\times 10^{-19}\\,\\text{C}$, $m=1.67262192369\\times 10^{-27}\\,\\text{kg}$, $\\mathbf{B}(\\mathbf{r})=\\left[\\alpha x,-\\alpha y,B_0\\right]$ with $\\alpha=0.5\\,\\text{T/m}$ and $B_0=1.0\\,\\text{T}$, $h=5.0\\times 10^{-10}\\,\\text{s}$, $N=200$, $\\mathbf{r}_0=[0.0,0.0,0.0]\\,\\text{m}$, $\\mathbf{v}_0=[2.0\\times 10^{5},0.0,1.0\\times 10^{5}]\\,\\text{m/s}$.\n- Test 4 (strong field, small step): $q=1.602176634\\times 10^{-19}\\,\\text{C}$, $m=1.67262192369\\times 10^{-27}\\,\\text{kg}$, $\\mathbf{B}(\\mathbf{r})=\\left[0,0,B_0\\right]$ with $B_0=10\\,\\text{T}$, $h=1.0\\times 10^{-10}\\,\\text{s}$, $N=1000$, $\\mathbf{r}_0=[0.0,0.5,0.0]\\,\\text{m}$, $\\mathbf{v}_0=[3.0\\times 10^{5},-1.0\\times 10^{5},0.0]\\,\\text{m/s}$.\n- Test 5 (long integration, small step, random initial state): $q=1.602176634\\times 10^{-19}\\,\\text{C}$, $m=1.67262192369\\times 10^{-27}\\,\\text{kg}$, $\\mathbf{B}(\\mathbf{r})=\\left[\\alpha x,-\\alpha y,B_0\\right]$ with $\\alpha=0.2\\,\\text{T/m}$ and $B_0=2.0\\,\\text{T}$, $h=2.0\\times 10^{-10}\\,\\text{s}$, $N=2000$, $\\mathbf{r}_0=[0.2,-0.1,0.05]\\,\\text{m}$, $\\mathbf{v}_0=[1.5\\times 10^{5},1.2\\times 10^{5},-0.5\\times 10^{5}]\\,\\text{m/s}$.\n\nFor each test, compute a boolean indicating whether the integrator is time-symmetric to within numerical precision, defined as $ \\| \\mathbf{r}_{\\text{rev}} - \\mathbf{r}_0 \\|_{\\infty} \\le \\varepsilon_r $ and $ \\| \\mathbf{v}_{\\text{rev}} - \\mathbf{v}_0 \\|_{\\infty} \\le \\varepsilon_v $ with tolerances $\\varepsilon_r = 10^{-11}\\max\\{1,\\|\\mathbf{r}_0\\|_2\\}$ and $\\varepsilon_v = 10^{-11}\\max\\{1,\\|\\mathbf{v}_0\\|_2\\}$. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5]\"), where each \"result\" is the boolean for the corresponding test in the order given above.",
            "solution": "## Problem Validation\n\n### Step 1: Extract Givens\n\nThe problem provides the following physical laws and definitions:\n- Equation of motion for position: $\\dfrac{d\\mathbf{r}}{dt} = \\mathbf{v}$.\n- Equation of motion for velocity (Lorentz force): $m \\,\\dfrac{d\\mathbf{v}}{dt} = q\\,\\mathbf{v}\\times\\mathbf{B}(\\mathbf{r})$.\n- Variables: position $\\mathbf{r}\\in\\mathbb{R}^3$, velocity $\\mathbf{v}\\in\\mathbb{R}^3$, charge $q$, mass $m$.\n- Magnetic field: $\\mathbf{B}(\\mathbf{r})\\in\\mathbb{R}^3$, which is static and divergence-free ($\\nabla \\cdot \\mathbf{B} = 0$).\n\nThe computational task requires:\n- Construction of a one-step, explicit, structure-preserving geometric algorithm that is reversible in time.\n- The algorithm must be derived from first principles using symmetric splitting.\n- The algorithm must demonstrate time symmetry numerically.\n- A forward integration by $N$ steps of size $h$ is followed by a backward integration by $N$ steps of size $-h$.\n- Time symmetry is confirmed if $\\|\\mathbf{r}_{\\text{rev}}-\\mathbf{r}_0\\|_\\infty \\le \\varepsilon_r$ and $\\|\\mathbf{v}_{\\text{rev}}-\\mathbf{v}_0\\|_\\infty \\le \\varepsilon_v$.\n- Tolerances: $\\varepsilon_r = 10^{-11}\\max\\{1,\\|\\mathbf{r}_0\\|_2\\}$ and $\\varepsilon_v = 10^{-11}\\max\\{1,\\|\\mathbf{v}_0\\|_2\\}$.\n\nThe problem provides five test cases with the following parameters:\n- **Test 1:** $q=1.602176634\\times 10^{-19}\\,\\text{C}$, $m=1.67262192369\\times 10^{-27}\\,\\text{kg}$, $\\mathbf{B}(\\mathbf{r})=\\left[0,0,3\\right]\\,\\text{T}$, $h=1.0\\times 10^{-9}\\,\\text{s}$, $N=100$, $\\mathbf{r}_0=[0.1,0.0,0.0]\\,\\text{m}$, $\\mathbf{v}_0=[1.0\\times 10^{5},2.0\\times 10^{5},0.0]\\,\\text{m/s}$.\n- **Test 2:** $q=1.602176634\\times 10^{-19}\\,\\text{C}$, $m=1.67262192369\\times 10^{-27}\\,\\text{kg}$, $\\mathbf{B}(\\mathbf{r})=\\left[0,0,0\\right]\\,\\text{T}$, $h=2.0\\times 10^{-9}\\,\\text{s}$, $N=50$, $\\mathbf{r}_0=[-0.3,0.2,0.0]\\,\\text{m}$, $\\mathbf{v}_0=[-5.0\\times 10^{4},1.0\\times 10^{5},1.0\\times 10^{5}]\\,\\text{m/s}$.\n- **Test 3:** $q=1.602176634\\times 10^{-19}\\,\\text{C}$, $m=1.67262192369\\times 10^{-27}\\,\\text{kg}$, $\\mathbf{B}(\\mathbf{r})=\\left[\\alpha x,-\\alpha y,B_0\\right]$ with $\\alpha=0.5\\,\\text{T/m}$, $B_0=1.0\\,\\text{T}$, $h=5.0\\times 10^{-10}\\,\\text{s}$, $N=200$, $\\mathbf{r}_0=[0.0,0.0,0.0]\\,\\text{m}$, $\\mathbf{v}_0=[2.0\\times 10^{5},0.0,1.0\\times 10^{5}]\\,\\text{m/s}$.\n- **Test 4:** $q=1.602176634\\times 10^{-19}\\,\\text{C}$, $m=1.67262192369\\times 10^{-27}\\,\\text{kg}$, $\\mathbf{B}(\\mathbf{r})=\\left[0,0,10\\right]\\,\\text{T}$, $h=1.0\\times 10^{-10}\\,\\text{s}$, $N=1000$, $\\mathbf{r}_0=[0.0,0.5,0.0]\\,\\text{m}$, $\\mathbf{v}_0=[3.0\\times 10^{5},-1.0\\times 10^{5},0.0]\\,\\text{m/s}$.\n- **Test 5:** $q=1.602176634\\times 10^{-19}\\,\\text{C}$, $m=1.67262192369\\times 10^{-27}\\,\\text{kg}$, $\\mathbf{B}(\\mathbf{r})=\\left[\\alpha x,-\\alpha y,B_0\\right]$ with $\\alpha=0.2\\,\\text{T/m}$, $B_0=2.0\\,\\text{T}$, $h=2.0\\times 10^{-10}\\,\\text{s}$, $N=2000$, $\\mathbf{r}_0=[0.2,-0.1,0.05]\\,\\text{m}$, $\\mathbf{v}_0=[1.5\\times 10^{5},1.2\\times 10^{5},-0.5\\times 10^{5}]\\,\\text{m/s}$.\n\n### Step 2: Validate Using Extracted Givens\n\n1.  **Scientifically Grounded:** The problem is based on the fundamental laws of classical electrodynamics—Newton's second law with the Lorentz force, which accurately describes charged particle motion in a magnetic field. The specified particle parameters correspond to a proton, and the magnetic field strengths and velocities are characteristic of fusion plasma environments. The non-uniform magnetic field $\\mathbf{B}(\\mathbf{r})=\\left[\\alpha x,-\\alpha y,B_0\\right]$ is physically valid as it is divergence-free: $\\nabla \\cdot \\mathbf{B} = \\frac{\\partial(\\alpha x)}{\\partial x} + \\frac{\\partial(-\\alpha y)}{\\partial y} + \\frac{\\partial B_0}{\\partial z} = \\alpha - \\alpha + 0 = 0$.\n2.  **Well-Posed:** The problem of constructing a time-reversible geometric integrator for this system is a classic topic in computational physics. The requirements for the algorithm are specific and lead to a well-defined family of solutions (symmetric splitting schemes). The numerical experiment to verify time symmetry is clearly defined with specific tolerances. All necessary data are provided.\n3.  **Objective:** The problem is stated in precise, objective, and mathematical language. There are no subjective or opinion-based claims.\n4.  **Relevant:** The problem explicitly falls within the specified domain of *structure-preserving geometric algorithms* for *computational fusion science and engineering*.\n\nThe problem is free of scientific flaws, contradictions, and ambiguities.\n\n### Step 3: Verdict and Action\nThe problem is valid. A solution will be provided.\n\n## Algorithm Derivation and Solution\n\nThe objective is to construct a structure-preserving numerical integrator for the system of ordinary differential equations governing a charged particle's motion in a magnetic field:\n$$\n\\frac{d\\mathbf{r}}{dt} = \\mathbf{v}\n$$\n$$\n\\frac{d\\mathbf{v}}{dt} = \\frac{q}{m} \\mathbf{v} \\times \\mathbf{B}(\\mathbf{r})\n$$\nLet the state of the system be denoted by the phase-space vector $\\mathbf{z} = (\\mathbf{r}, \\mathbf{v})$. The evolution of the system over a time step $h$ can be represented by a flow map $\\Phi_h$ such that $\\mathbf{z}(t+h) = \\Phi_h(\\mathbf{z}(t))$. A structure-preserving geometric integrator is an approximation of $\\Phi_h$ that preserves key geometric properties of the true flow, such as phase-space volume (symplecticity) and time-reversibility.\n\nA standard method to construct such an integrator is operator splitting. The vector field governing the dynamics, $\\dot{\\mathbf{z}} = F(\\mathbf{z})$, is split into two or more parts, where each part corresponds to an exactly solvable subsystem. For this problem, we can split the dynamics into a free-streaming part (A) and a velocity rotation part (B):\n- **Part A (Free-streaming/Drift):**\n$$\n\\frac{d\\mathbf{r}}{dt} = \\mathbf{v}, \\quad \\frac{d\\mathbf{v}}{dt} = \\mathbf{0}\n$$\nThe exact flow $\\Phi_A^h$ for a time step $h$ is:\n$$\n\\mathbf{r}(t+h) = \\mathbf{r}(t) + h \\mathbf{v}(t), \\quad \\mathbf{v}(t+h) = \\mathbf{v}(t)\n$$\n- **Part B (Velocity Rotation/Kick):**\n$$\n\\frac{d\\mathbf{r}}{dt} = \\mathbf{0}, \\quad \\frac{d\\mathbf{v}}{dt} = \\frac{q}{m} \\mathbf{v} \\times \\mathbf{B}(\\mathbf{r})\n$$\nThe exact flow $\\Phi_B^h$ for a time step $h$ keeps the position constant, $\\mathbf{r}(t+h) = \\mathbf{r}(t)$, and rotates the velocity vector $\\mathbf{v}$ around the axis defined by the magnetic field vector $\\mathbf{B}(\\mathbf{r})$ with a cyclotron frequency $\\omega_c = |q|\\|\\mathbf{B}\\|/m$. Since $\\mathbf{r}$ is constant during this sub-step, $\\mathbf{B}(\\mathbf{r})$ is also constant, and this subsystem describes a pure rotation. This rotation preserves the magnitude of the velocity, $\\|\\mathbf{v}\\|$, and thus conserves kinetic energy.\n\nTo construct an integrator that is time-reversible, we use a symmetric composition of these exact flows. The Strang splitting method provides a second-order accurate and symmetric scheme:\n$$\n\\Phi_h^{\\text{approx}} = \\Phi_A^{h/2} \\circ \\Phi_B^h \\circ \\Phi_A^{h/2}\n$$\nThis composition is read from right to left: a half-step drift, a full-step rotation, followed by another half-step drift. Let's translate this into an explicit algorithm to update the state from $(\\mathbf{r}_n, \\mathbf{v}_n)$ at time $t_n$ to $(\\mathbf{r}_{n+1}, \\mathbf{v}_{n+1})$ at time $t_{n+1} = t_n + h$:\n\n1.  **First Half-Drift (apply $\\Phi_A^{h/2}$):** The position is advanced by a half time step using the current velocity.\n    $$\n    \\mathbf{r}_{n+1/2} = \\mathbf{r}_n + \\frac{h}{2} \\mathbf{v}_n\n    $$\n2.  **Full-Step Rotation (apply $\\Phi_B^h$):** The velocity is rotated for a full time step. The crucial insight of this scheme is to evaluate the magnetic field $\\mathbf{B}$ at the time-centered position $\\mathbf{r}_{n+1/2}$. This centering is key to the symmetry and accuracy of the method. The velocity update solves $\\frac{d\\mathbf{v}}{dt} = \\frac{q}{m} \\mathbf{v} \\times \\mathbf{B}(\\mathbf{r}_{n+1/2})$. A standard, computationally efficient, and exact implementation for this rotation sub-problem is the Boris algorithm. It is derived from a centered-difference approximation to the velocity equation:\n    $$\n    \\frac{\\mathbf{v}_{n+1} - \\mathbf{v}_n}{h} = \\frac{q}{m} \\left( \\frac{\\mathbf{v}_{n+1} + \\mathbf{v}_n}{2} \\right) \\times \\mathbf{B}(\\mathbf{r}_{n+1/2})\n    $$\n    This equation can be solved explicitly for $\\mathbf{v}_{n+1}$ giving the following steps:\n    a. Define the dimensionless rotation vector $\\boldsymbol{\\tau} = \\frac{q h}{2m} \\mathbf{B}(\\mathbf{r}_{n+1/2})$.\n    b. Calculate an intermediate velocity $\\mathbf{v}' = \\mathbf{v}_n + \\mathbf{v}_n \\times \\boldsymbol{\\tau}$.\n    c. Calculate the new velocity $\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\frac{2}{1 + \\|\\boldsymbol{\\tau}\\|^2} (\\mathbf{v}' \\times \\boldsymbol{\\tau})$.\n\n3.  **Second Half-Drift (apply $\\Phi_A^{h/2}$):** The final position is computed by advancing the mid-step position $\\mathbf{r}_{n+1/2}$ for a half time step using the *newly computed* velocity $\\mathbf{v}_{n+1}$.\n    $$\n    \\mathbf{r}_{n+1} = \\mathbf{r}_{n+1/2} + \\frac{h}{2} \\mathbf{v}_{n+1}\n    $$\nThis three-step procedure constitutes one full time step of the integrator. It is explicit, as each step can be computed directly from the result of the previous one. It is volume-preserving because the flows $\\Phi_A$ (a shear transformation) and $\\Phi_B$ (a rotation in a subspace) both have Jacobians with determinant $1$, and the overall Jacobian is the product of these. It is time-reversible because the composition is symmetric. Applying the scheme with a time step $-h$ exactly inverts the transformation performed with step $h$, a property that will be verified numerically. Finally, this scheme is consistent with energy conservation. For a uniform magnetic field, kinetic energy is exactly conserved. For a non-uniform field, the total energy is not exactly conserved but exhibits excellent long-term behavior with bounded oscillations, a characteristic of geometric integrators.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a structure-preserving geometric algorithm (Boris algorithm) for\n    charged particle motion in a magnetic field and verifies its time symmetry.\n    \"\"\"\n\n    # Define physical constants for the proton\n    Q_PROTON = 1.602176634e-19  # Elementary charge in Coulombs\n    M_PROTON = 1.67262192369e-27 # Proton mass in kg\n\n    # Define the test cases as specified in the problem statement\n    test_cases = [\n        {\n            \"q\": Q_PROTON, \"m\": M_PROTON, \"B_func_type\": \"uniform\",\n            \"B_params\": {\"B0\": 3.0}, \"h\": 1.0e-9, \"N\": 100,\n            \"r0\": np.array([0.1, 0.0, 0.0]),\n            \"v0\": np.array([1.0e5, 2.0e5, 0.0])\n        },\n        {\n            \"q\": Q_PROTON, \"m\": M_PROTON, \"B_func_type\": \"zero\",\n            \"B_params\": {}, \"h\": 2.0e-9, \"N\": 50,\n            \"r0\": np.array([-0.3, 0.2, 0.0]),\n            \"v0\": np.array([-5.0e4, 1.0e5, 1.0e5])\n        },\n        {\n            \"q\": Q_PROTON, \"m\": M_PROTON, \"B_func_type\": \"linear_nonuniform\",\n            \"B_params\": {\"alpha\": 0.5, \"B0\": 1.0}, \"h\": 5.0e-10, \"N\": 200,\n            \"r0\": np.array([0.0, 0.0, 0.0]),\n            \"v0\": np.array([2.0e5, 0.0, 1.0e5])\n        },\n        {\n            \"q\": Q_PROTON, \"m\": M_PROTON, \"B_func_type\": \"uniform\",\n            \"B_params\": {\"B0\": 10.0}, \"h\": 1.0e-10, \"N\": 1000,\n            \"r0\": np.array([0.0, 0.5, 0.0]),\n            \"v0\": np.array([3.0e5, -1.0e5, 0.0])\n        },\n        {\n            \"q\": Q_PROTON, \"m\": M_PROTON, \"B_func_type\": \"linear_nonuniform\",\n            \"B_params\": {\"alpha\": 0.2, \"B0\": 2.0}, \"h\": 2.0e-10, \"N\": 2000,\n            \"r0\": np.array([0.2, -0.1, 0.05]),\n            \"v0\": np.array([1.5e5, 1.2e5, -0.5e5])\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        q = case[\"q\"]\n        m = case[\"m\"]\n        h = case[\"h\"]\n        N = case[\"N\"]\n        r0 = case[\"r0\"]\n        v0 = case[\"v0\"]\n        \n        # Define the magnetic field function based on test case parameters\n        if case[\"B_func_type\"] == \"uniform\":\n            B0 = case[\"B_params\"][\"B0\"]\n            B_func = lambda r: np.array([0.0, 0.0, B0])\n        elif case[\"B_func_type\"] == \"zero\":\n            B_func = lambda r: np.array([0.0, 0.0, 0.0])\n        elif case[\"B_func_type\"] == \"linear_nonuniform\":\n            alpha = case[\"B_params\"][\"alpha\"]\n            B0 = case[\"B_params\"][\"B0\"]\n            B_func = lambda r: np.array([alpha * r[0], -alpha * r[1], B0])\n        \n        # Pre-calculate charge-to-mass ratio for efficiency\n        q_over_m = q / m\n\n        def boris_step(r, v, time_step):\n            \"\"\"\n            Performs one step of the Boris algorithm.\n            \"\"\"\n            # First half position drift\n            r_half = r + 0.5 * time_step * v\n            \n            # Evaluate B-field at the midpoint position\n            B_mid = B_func(r_half)\n            \n            # Velocity rotation\n            t_vec = (q_over_m * time_step / 2.0) * B_mid\n            t_mag_sq = np.dot(t_vec, t_vec)\n            \n            v_prime = v + np.cross(v, t_vec)\n            s_vec = (2.0 / (1.0 + t_mag_sq)) * t_vec\n            v_new = v + np.cross(v_prime, s_vec)\n            \n            # Second half position drift\n            r_new = r_half + 0.5 * time_step * v_new\n            \n            return r_new, v_new\n            \n        # Forward integration\n        r_fwd, v_fwd = np.copy(r0), np.copy(v0)\n        for _ in range(N):\n            r_fwd, v_fwd = boris_step(r_fwd, v_fwd, h)\n            \n        # Backward integration\n        r_rev, v_rev = np.copy(r_fwd), np.copy(v_fwd)\n        for _ in range(N):\n            r_rev, v_rev = boris_step(r_rev, v_rev, -h)\n            \n        # Verification of time symmetry\n        eps_r_scale = max(1.0, np.linalg.norm(r0))\n        eps_v_scale = max(1.0, np.linalg.norm(v0))\n        \n        tol_r = 1e-11 * eps_r_scale\n        tol_v = 1e-11 * eps_v_scale\n        \n        err_r = np.linalg.norm(r_rev - r0, ord=np.inf)\n        err_v = np.linalg.norm(v_rev - v0, ord=np.inf)\n        \n        is_symmetric = (err_r <= tol_r) and (err_v <= tol_v)\n        results.append(is_symmetric)\n\n    # Format the final output as a comma-separated list of lowercase booleans\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The primary advantage of geometric integrators lies in their superior long-term performance, which can be rigorously understood through Backward Error Analysis (BEA). This exercise delves into the crucial topic of phase accuracy for charged particle gyromotion, a ubiquitous fast-timescale motion in magnetized plasmas . By analytically and numerically comparing the phase error of a symplectic integrator against a standard high-order Runge-Kutta method, you will quantify the qualitative difference in their long-term behavior and gain insight into the concept of a conserved modified Hamiltonian.",
            "id": "4049892",
            "problem": "Consider the planar gyromotion of a singly charged ion in a uniform magnetic field as a baseline model for the fast dynamics encountered in magnetically confined fusion devices. Use the Lorentz force law as the fundamental base and formulate the problem in purely mathematical terms as follows.\n\nStart from the Lorentz force law for a particle of charge $q$ and mass $m$ in a uniform magnetic field $\\mathbf{B} = B \\,\\hat{\\mathbf{z}}$, with no electric field present. Let $\\mathbf{r}(t) = (x(t), y(t))$ be the position and $\\mathbf{v}(t) = (v_x(t), v_y(t))$ be the velocity in the plane perpendicular to $\\mathbf{B}$. The governing equations are\n$$\nm \\,\\frac{d\\mathbf{v}}{dt} = q\\,\\mathbf{v} \\times \\mathbf{B}, \\qquad \\frac{d\\mathbf{r}}{dt} = \\mathbf{v}.\n$$\nDefine the cyclotron frequency $\\Omega = \\frac{q B}{m}$ and the $2\\times 2$ canonical symplectic matrix $J = \\begin{pmatrix} 0 & 1 \\\\ -1 & 0 \\end{pmatrix}$. Then the in-plane velocity evolution is a linear Hamiltonian system\n$$\n\\frac{d\\mathbf{v}}{dt} = \\Omega\\,J\\,\\mathbf{v}.\n$$\n\nTasks to be completed:\n\n1. Using Hamiltonian structure and Backward Error Analysis (BEA), derive the modified frequency for the symplectic implicit midpoint method applied to the linear system $\\frac{d\\mathbf{v}}{dt} = \\Omega\\,J\\,\\mathbf{v}$. From first principles, show how the method’s one-step map can be expressed in terms of the Cayley transform of the generator and obtain a modified angular increment per step. Use this to derive an expression for the long-time phase error of the implicit midpoint method over total time $T$.\n\n2. For a classical explicit fourth-order Runge–Kutta method (Runge–Kutta of order four), compute its one-step map applied to the same linear system by evaluating its stability polynomial on the generator. Determine the per-step angular increment as the complex argument of the stability function evaluated at the purely imaginary step parameter. Use this to derive the long-time phase error over total time $T$.\n\n3. Define the phase error as the principal value in $[-\\pi,\\pi]$ (angles in radians) of the difference between the numerically accumulated phase and the exact accumulated phase $ \\Omega T $. Explicitly, if $\\theta_{\\text{num}}$ is the total numerical phase after time $T$, then the phase error is the wrapped angle\n$$\n\\Delta\\phi = \\mathrm{wrap}\\!\\left(\\theta_{\\text{num}} - \\Omega T\\right),\n$$\nwhere $\\mathrm{wrap}(\\phi) = \\left((\\phi + \\pi) \\bmod 2\\pi\\right) - \\pi$.\n\n4. Implement a complete, runnable program that computes, for the given test suite, three quantities per case:\n   - the BEA-predicted long-time phase error for the implicit midpoint method,\n   - the numerically accumulated long-time phase error for the implicit midpoint method (using the derived per-step angular increment),\n   - the numerically accumulated long-time phase error for the fourth-order Runge–Kutta method (using the complex argument of its stability function).\n   All angles must be in radians.\n\nUse the following test suite, which spans a general case, a fine time-step regime, and increasingly coarse regimes to probe long-time behavior:\n- Physical parameters (constant across all cases): $q = 1.602\\times 10^{-19}$ Coulomb, $m = 3.34358\\times 10^{-27}$ kilogram, $B = 3.5$ Tesla.\n- From these, compute $\\Omega = \\frac{qB}{m}$ and the cyclotron period $T_c = \\frac{2\\pi}{\\Omega}$.\n- Cases are specified by the number of steps per period $N_p$ and the number of periods $N_{\\text{per}}$ to be simulated:\n  1. Case A (happy path): $N_p = 64$, $N_{\\text{per}} = 1000$.\n  2. Case B (fine step, very long time): $N_p = 128$, $N_{\\text{per}} = 50000$.\n  3. Case C (moderately coarse): $N_p = 8$, $N_{\\text{per}} = 2000$.\n  4. Case D (coarse, near the edge where non-symplectic artifacts are visible): $N_p = 4$, $N_{\\text{per}} = 500$.\n\nFor each case, compute the time-step $h = \\frac{T_c}{N_p}$, the total time $T = N_{\\text{per}}\\,T_c$, and the integer number of steps $N = \\frac{T}{h} = N_{\\text{per}}\\,N_p$. Angles must be in radians.\n\nYour program should produce a single line of output containing the results as a comma-separated list of four sublists, one sublist per test case, each sublist containing the three phase errors in the order specified. For example, the format must be\n[[e_{A,\\mathrm{BEA}},e_{A,\\mathrm{IM}},e_{A,\\mathrm{RK4}}],[e_{B,\\mathrm{BEA}},e_{B,\\mathrm{IM}},e_{B,\\mathrm{RK4}}],[e_{C,\\mathrm{BEA}},e_{C,\\mathrm{IM}},e_{C,\\mathrm{RK4}}],[e_{D,\\mathrm{BEA}},e_{D,\\mathrm{IM}},e_{D,\\mathrm{RK4}}]],\nwith all eight numerical quantities in radians. The final output must be exactly one line in this bracketed comma-separated format, and all entries must be floating-point numbers (no units printed, but angles are in radians by definition in the problem).",
            "solution": "The user has provided a problem statement that is scientifically grounded, well-posed, objective, and complete. It is a standard problem in computational physics and numerical analysis, focusing on the properties of geometric integrators for Hamiltonian systems. The problem is valid and can be solved as stated.\n\nThe problem asks for the analysis and computation of phase errors for two numerical methods—the symplectic implicit midpoint method and the explicit fourth-order Runge–Kutta (RK4) method—applied to the planar gyromotion of a charged particle in a uniform magnetic field. The governing equation for the velocity $\\mathbf{v} \\in \\mathbb{R}^2$ is the linear Hamiltonian system:\n$$\n\\frac{d\\mathbf{v}}{dt} = \\Omega J \\mathbf{v},\n$$\nwhere $\\Omega = \\frac{qB}{m}$ is the cyclotron frequency and $J = \\begin{pmatrix} 0 & 1 \\\\ -1 & 0 \\end{pmatrix}$ is the canonical symplectic matrix. The exact solution is a rotation in the velocity plane, given by $\\mathbf{v}(t) = e^{t\\Omega J} \\mathbf{v}(0)$, where $e^{t\\Omega J} = \\begin{pmatrix} \\cos(\\Omega t) & \\sin(\\Omega t) \\\\ -\\sin(\\Omega t) & \\cos(\\Omega t) \\end{pmatrix}$. The total phase accumulated over a time $T$ is $\\theta_{\\text{exact}} = \\Omega T$.\n\n**1. Implicit Midpoint Method Analysis**\n\nThe implicit midpoint method for an ordinary differential equation (ODE) $\\frac{d\\mathbf{y}}{dt} = f(\\mathbf{y})$ is given by:\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + h f\\left(\\frac{\\mathbf{y}_n + \\mathbf{y}_{n+1}}{2}\\right),\n$$\nwhere $h$ is the time step. For our linear system, $f(\\mathbf{v}) = \\Omega J \\mathbf{v}$, this becomes:\n$$\n\\mathbf{v}_{n+1} = \\mathbf{v}_n + h \\Omega J \\left(\\frac{\\mathbf{v}_n + \\mathbf{v}_{n+1}}{2}\\right).\n$$\nTo find the one-step map $\\mathbf{v}_{n+1} = S_{\\text{IM}} \\mathbf{v}_n$, we solve for $\\mathbf{v}_{n+1}$:\n$$\n\\left(I - \\frac{h\\Omega}{2}J\\right) \\mathbf{v}_{n+1} = \\left(I + \\frac{h\\Omega}{2}J\\right) \\mathbf{v}_n.\n$$\n$$\nS_{\\text{IM}} = \\left(I - \\frac{h\\Omega}{2}J\\right)^{-1} \\left(I + \\frac{h\\Omega}{2}J\\right).\n$$\nThis expression is the Cayley transform of the matrix $\\frac{h\\Omega J}{2}$. Since $\\Omega J$ is a skew-symmetric matrix, the map $S_{\\text{IM}}$ is orthogonal and preserves the quadratic invariant $\\mathbf{v}^T\\mathbf{v}$ (kinetic energy), hence it is a symplectic map. It represents an exact rotation by some numerical angle $\\theta_{\\text{step,IM}}$.\n\nTo find this angle, we analyze the eigenvalues of the map. The eigenvalues of the generator matrix $\\Omega J$ are $\\pm i\\Omega$. The eigenvalues of the one-step map $S_{\\text{IM}}$ are given by applying the Cayley transform as a scalar function $c(\\lambda) = \\frac{1+\\lambda/2}{1-\\lambda/2}$ to the eigenvalues of $h\\Omega J$, which are $\\pm i h\\Omega$. Let $\\alpha = h\\Omega$. The eigenvalue of $S_{\\text{IM}}$ is:\n$$\n\\lambda_{\\text{IM}} = \\frac{1 + i\\alpha/2}{1 - i\\alpha/2}.\n$$\nThis is a complex number on the unit circle, which we can write as $e^{i\\theta_{\\text{step,IM}}}$. The per-step angular increment is the argument of this eigenvalue:\n$$\n\\theta_{\\text{step,IM}} = \\arg\\left(\\frac{1 + i\\alpha/2}{1 - i\\alpha/2}\\right) = 2 \\arctan\\left(\\frac{\\alpha}{2}\\right).\n$$\nThe total numerical phase accumulated after $N$ steps is $\\theta_{\\text{num,IM}} = N \\theta_{\\text{step,IM}}$. The phase error relative to the exact phase $\\Omega T = N\\alpha$ is $\\Delta\\phi_{\\text{IM}} = \\mathrm{wrap}(N\\theta_{\\text{step,IM}} - N\\alpha)$.\n\nBackward Error Analysis (BEA) for a symplectic method asserts that the numerical flow is the exact flow of a modified Hamiltonian. This means the numerical solution evolves according to a modified frequency $\\tilde{\\Omega}$. The modified frequency is defined such that the exact evolution over one step $h$ with this frequency matches the numerical angular increment: $\\tilde{\\Omega} h = \\theta_{\\text{step,IM}}$.\n$$\n\\tilde{\\Omega} = \\frac{\\theta_{\\text{step,IM}}}{h} = \\frac{2}{h} \\arctan\\left(\\frac{h\\Omega}{2}\\right) = \\frac{2}{h} \\arctan\\left(\\frac{\\alpha}{2}\\right).\n$$\nThe BEA-predicted phase error over a total time $T$ is the difference between the total phase accumulated with the modified frequency and the exact frequency:\n$$\n\\Delta\\phi_{\\text{BEA}} = \\mathrm{wrap}(\\tilde{\\Omega}T - \\Omega T) = \\mathrm{wrap}((\\tilde{\\Omega} - \\Omega)T).\n$$\nSubstituting $T=Nh$ and the expression for $\\tilde{\\Omega}$, we find:\n$$\n(\\tilde{\\Omega} - \\Omega)T = \\left(\\frac{2}{h} \\arctan\\left(\\frac{\\alpha}{2}\\right) - \\Omega\\right)Nh = N\\left(2\\arctan\\left(\\frac{\\alpha}{2}\\right) - \\Omega h\\right) = N(\\theta_{\\text{step,IM}} - \\alpha).\n$$\nThus, the BEA-predicted phase error and the directly computed numerical phase error are identical expressions, as expected.\n\n**2. Fourth-Order Runge–Kutta Method Analysis**\n\nFor a linear ODE $\\frac{d\\mathbf{y}}{dt} = A\\mathbf{y}$, a Runge-Kutta method yields a one-step map $\\mathbf{y}_{n+1} = R(hA)\\mathbf{y}_n$, where $R(z)$ is the stability function of the method. For the classical fourth-order Runge-Kutta (RK4) method, the stability function is the truncated Taylor series of the exponential function up to degree $4$:\n$$\nR(z) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24}.\n$$\nThe one-step map for our system is $\\mathbf{v}_{n+1} = R(h\\Omega J)\\mathbf{v}_n$. The evolution of the eigenmodes is governed by the eigenvalues of this map, which are $R(\\pm i h\\Omega)$. Let $\\alpha = h\\Omega$. We evaluate $R(i\\alpha)$:\n$$\nR(i\\alpha) = 1 + (i\\alpha) + \\frac{(i\\alpha)^2}{2} + \\frac{(i\\alpha)^3}{6} + \\frac{(i\\alpha)^4}{24} = \\left(1 - \\frac{\\alpha^2}{2} + \\frac{\\alpha^4}{24}\\right) + i\\left(\\alpha - \\frac{\\alpha^3}{6}\\right).\n$$\nThis method is not symplectic; the modulus $|R(i\\alpha)|$ is not identically $1$ for $\\alpha \\neq 0$. The per-step angular increment is the complex argument of $R(i\\alpha)$:\n$$\n\\theta_{\\text{step,RK4}} = \\arg(R(i\\alpha)) = \\mathrm{atan2}\\left(\\alpha - \\frac{\\alpha^3}{6}, 1 - \\frac{\\alpha^2}{2} + \\frac{\\alpha^4}{24}\\right).\n$$\nThe total numerical phase accumulated after $N$ steps is $\\theta_{\\text{num,RK4}} = N \\theta_{\\text{step,RK4}}$. The phase error is:\n$$\n\\Delta\\phi_{\\text{RK4}} = \\mathrm{wrap}(\\theta_{\\text{num,RK4}} - \\Omega T) = \\mathrm{wrap}(N(\\theta_{\\text{step,RK4}} - \\alpha)).\n$$\n\n**3. Summary of Formulae for Computation**\n\nFor each test case defined by ($N_p$, $N_{\\text{per}}$):\n- Time step parameter: $\\alpha = h\\Omega = (\\frac{T_c}{N_p})\\Omega = (\\frac{2\\pi/\\Omega}{N_p})\\Omega = \\frac{2\\pi}{N_p}$.\n- Total number of steps: $N = N_p N_{\\text{per}}$.\n- Phase error definition: $\\mathrm{wrap}(\\phi) = ((\\phi + \\pi) \\pmod{2\\pi}) - \\pi$.\n- Implicit Midpoint (BEA and numerical) phase error:\n$$\ne_{\\text{IM}} = \\mathrm{wrap}\\left(N \\left(2\\arctan\\left(\\frac{\\alpha}{2}\\right) - \\alpha\\right)\\right).\n$$\n- Fourth-Order Runge-Kutta phase error:\n$$\ne_{\\text{RK4}} = \\mathrm{wrap}\\left(N \\left(\\mathrm{atan2}\\left(\\alpha - \\frac{\\alpha^3}{6}, 1 - \\frac{\\alpha^2}{2} + \\frac{\\alpha^4}{24}\\right) - \\alpha\\right)\\right).\n$$\nThese formulae are implemented directly in the provided program.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and prints the phase errors for numerical integrators applied to\n    charged particle gyromotion, as specified in the problem statement.\n    \"\"\"\n\n    # Physical parameters\n    q = 1.602e-19  # Charge in Coulombs\n    m = 3.34358e-27  # Mass in kilograms (Deuteron)\n    B = 3.5  # Magnetic field in Tesla\n\n    # Derived physical quantities\n    Omega = (q * B) / m  # Cyclotron frequency in rad/s\n\n    # Test cases: (Number of steps per period, Number of periods)\n    test_cases = [\n        (64, 1000),      # Case A\n        (128, 50000),    # Case B\n        (8, 2000),       # Case C\n        (4, 500),        # Case D\n    ]\n\n    # Wrapper function to map an angle to the interval [-pi, pi]\n    def wrap_angle(phi):\n        return ((phi + np.pi) % (2 * np.pi)) - np.pi\n\n    all_results = []\n    \n    for case in test_cases:\n        Np, Nper = case\n        \n        # Total number of steps\n        N = Np * Nper\n        \n        # Dimensionless step size parameter a = h*Omega\n        # h = Tc / Np = (2*pi/Omega) / Np = 2*pi / (Omega * Np)\n        # a = h * Omega = 2*pi / Np\n        alpha = 2 * np.pi / Np\n\n        # --- 1. Implicit Midpoint (IM) Method Phase Error ---\n        # The BEA-predicted error and the numerically accumulated error are\n        # mathematically identical for this problem.\n        \n        # Per-step angular increment for IM\n        theta_step_im = 2 * np.arctan(alpha / 2)\n        \n        # Total difference in accumulated angle over N steps\n        # This is N * (numerical_angle_per_step - exact_angle_per_step)\n        total_phase_diff_im = N * (theta_step_im - alpha)\n        \n        # Wrap the final error to [-pi, pi]\n        error_im = wrap_angle(total_phase_diff_im)\n        error_bea = error_im  # As derived, they are the same\n\n        # --- 2. Fourth-Order Runge-Kutta (RK4) Method Phase Error ---\n        \n        # Real and imaginary parts of the stability function R(i*alpha)\n        # R(z) = 1 + z + z^2/2 + z^3/6 + z^4/24\n        # R(i*a) = (1 - a^2/2 + a^4/24) + i*(a - a^3/6)\n        rk4_re = 1 - (alpha**2) / 2 + (alpha**4) / 24\n        rk4_im = alpha - (alpha**3) / 6\n        \n        # Per-step angular increment for RK4 is the argument of R(i*alpha)\n        theta_step_rk4 = np.arctan2(rk4_im, rk4_re)\n        \n        # Total difference in accumulated angle over N steps\n        total_phase_diff_rk4 = N * (theta_step_rk4 - alpha)\n        \n        # Wrap the final error to [-pi, pi]\n        error_rk4 = wrap_angle(total_phase_diff_rk4)\n\n        all_results.append([error_bea, error_im, error_rk4])\n\n    # Format the final output string exactly as specified.\n    # The output should be a single line: [[...],[...],[...],[...]]\n    result_str = \"[\" + ','.join([f\"[{e[0]},{e[1]},{e[2]}]\" for e in all_results]) + \"]\"\n    \n    print(result_str)\n\nsolve()\n```"
        }
    ]
}