{
    "hands_on_practices": [
        {
            "introduction": "几何算法的核心在于其构建方式，这与传统数值方法有着本质区别。本次实践将引导你并非套用现成公式，而是从哈密顿原理这一物理学第一性原理出发，亲手构建一个辛积分器。这个练习旨在揭示物理学中的变分原理与所得数值格式的保结构特性之间的深刻联系 。",
            "id": "4049887",
            "problem": "在一个用于描述环形约束装置中靠近磁轴的导心小振幅径向振荡的简化单自由度模型中，其在正则坐标下的动力学可由以下二次哈密顿量近似：\n$$\nH(q,p) \\;=\\; \\frac{1}{2 m}\\,p^{2} \\;+\\; \\frac{1}{2}\\,k\\,q^{2},\n$$\n其中 $m>0$ 是一个等效质量参数，$k>0$ 则代表了等效势的局部二次曲率。设 $h>0$ 为一个固定的时间步长。仅使用基本变分原理和正则变换的定义，通过引入一个第一类生成函数 $S_{1}(q,Q;h)$ 来构造一个辛单步法，其中 $q$ 和 $Q$ 分别表示相隔时间 $h$ 的连续时间节点上的旧位形位置和新位形位置。此构造必须从哈密顿原理和第一类生成函数的定义出发，并且必须对一个时间步长内的作用量采用对称近似，以获得一个二阶、时间可逆的映射。从得到的 $S_{1}(q,Q;h)$ 出发，推导将 $(q_{n},p_{n})$ 映射到 $(q_{n+1},p_{n+1})$ 的显式更新关系，并证明该映射是线性的和辛的。将所有中间关系用 $m$、$k$ 和 $h$ 的符号形式表示。\n\n给出生成函数 $S_{1}(q,Q;h)$ 关于 $m$、$k$ 和 $h$ 的闭式表达式作为最终答案。不应包含任何数值计算或舍入。最终答案中无需物理单位。",
            "solution": "问题要求使用第一类生成函数 $S_{1}(q,Q;h)$ 为简谐振子构造一个辛单步法。此构造必须从第一性原理（特别是哈密顿原理）推导，并对作用量积分采用对称近似。\n\n系统的哈密顿量由下式给出\n$$ H(q,p) = \\frac{1}{2 m}\\,p^{2} + \\frac{1}{2}\\,k\\,q^{2} $$\n其中 $q$ 是位置，$p$ 是动量，$m>0$ 是等效质量，$k>0$ 是弹簧常数。相应的拉格朗日量 $L(q, \\dot{q}) = p\\dot{q} - H$ 可通过首先用 $\\dot{q}$ 表示 $p$ 来求得。根据哈密顿方程 $\\dot{q} = \\frac{\\partial H}{\\partial p} = \\frac{p}{m}$，我们有 $p = m\\dot{q}$。将此代入拉格朗日量的定义中，得到\n$$ L(q, \\dot{q}) = (m\\dot{q})\\dot{q} - \\left(\\frac{1}{2m}(m\\dot{q})^2 + \\frac{1}{2}kq^2\\right) = \\frac{1}{2}m\\dot{q}^2 - \\frac{1}{2}kq^2 $$\n\n哈密顿原理指出，系统在位形空间中两点 $q(t_n)$ 和 $q(t_{n+1})$ 之间的轨迹会使作用量积分 $A = \\int_{t_n}^{t_{n+1}} L(q(t), \\dot{q}(t)) dt$ 取极值。在正则变换理论中，第一类生成函数 $S_1(q, Q; h)$ 通过以下关系将时间 $t_n$ 的旧坐标 $(q,p)$ 与时间 $t_{n+1} = t_n+h$ 的新坐标 $(Q,P)$ 联系起来：\n$$ p = \\frac{\\partial S_1}{\\partial q} \\quad \\text{和} \\quad P = -\\frac{\\partial S_1}{\\partial Q} $$\n生成函数本身是真实路径上作用量积分的近似：$S_1(q, Q; h) \\approx \\int_{t_n}^{t_{n+1}} L(q(t), \\dot{q}(t)) dt$。\n\n为了构造一个二阶、时间可逆的映射，我们必须对作用量积分使用对称近似。最自然的对称近似是中点法则，其中在时长为 $h$ 的区间 $[t_n, t_{n+1}]$ 上的连续拉格朗日量 $L(q(t), \\dot{q}(t))$ 由其在时间中点 $t_n + h/2$ 的值来近似。中点处的位置和速度通过对称有限差分来近似：\n$$ q(t_n+h/2) \\approx \\frac{q+Q}{2} \\quad \\text{和} \\quad \\dot{q}(t_n+h/2) \\approx \\frac{Q-q}{h} $$\n其中 $q = q(t_n)$ 且 $Q = q(t_{n+1})$。作用量积分于是近似为\n$$ A \\approx h \\cdot L\\left(\\frac{q+Q}{2}, \\frac{Q-q}{h}\\right) $$\n代入拉格朗日量的表达式，我们将生成函数定义为：\n$$ S_1(q, Q; h) = h \\left[ \\frac{1}{2}m\\left(\\frac{Q-q}{h}\\right)^2 - \\frac{1}{2}k\\left(\\frac{q+Q}{2}\\right)^2 \\right] $$\n$$ S_1(q, Q; h) = \\frac{m}{2h}(Q-q)^2 - \\frac{kh}{8}(q+Q)^2 $$\n这就是所求的生成函数。\n\n接下来，我们推导将 $(q_n, p_n)$ 映射到 $(q_{n+1}, p_{n+1})$ 的显式更新关系。我们认定 $q=q_n$，$p=p_n$，$Q=q_{n+1}$，以及 $P=p_{n+1}$。使用 $S_1$ 的定义关系：\n$$ p_n = \\frac{\\partial S_1}{\\partial q_n} = \\frac{m}{2h} \\cdot 2(q_{n+1}-q_n)(-1) - \\frac{kh}{8} \\cdot 2(q_n+q_{n+1})(1) = -\\frac{m}{h}(q_{n+1}-q_n) - \\frac{kh}{4}(q_n+q_{n+1}) $$\n$$ p_{n+1} = -\\frac{\\partial S_1}{\\partial q_{n+1}} = -\\left[ \\frac{m}{2h} \\cdot 2(q_{n+1}-q_n)(1) - \\frac{kh}{8} \\cdot 2(q_n+q_{n+1})(1) \\right] = -\\frac{m}{h}(q_{n+1}-q_n) + \\frac{kh}{4}(q_n+q_{n+1}) $$\n这两个方程隐式地定义了该映射。我们重新整理它们，以解出作为 $(q_n, p_n)$ 显式函数的 $(q_{n+1}, p_{n+1})$。首先，分离含有 $q_n$ 和 $q_{n+1}$ 的项：\n$$ p_n = \\left(\\frac{m}{h} - \\frac{kh}{4}\\right)q_n - \\left(\\frac{m}{h} + \\frac{kh}{4}\\right)q_{n+1} \\quad (1) $$\n$$ p_{n+1} = \\left(\\frac{m}{h} + \\frac{kh}{4}\\right)q_n - \\left(\\frac{m}{h} - \\frac{kh}{4}\\right)q_{n+1} \\quad (2) $$\n从方程（1），我们解出 $q_{n+1}$：\n$$ \\left(\\frac{m}{h} + \\frac{kh}{4}\\right)q_{n+1} = \\left(\\frac{m}{h} - \\frac{kh}{4}\\right)q_n - p_n $$\n$$ q_{n+1} = \\frac{\\frac{m}{h} - \\frac{kh}{4}}{\\frac{m}{h} + \\frac{kh}{4}} q_n - \\frac{1}{\\frac{m}{h} + \\frac{kh}{4}} p_n = \\frac{4m-kh^2}{4m+kh^2}q_n - \\frac{4h}{4m+kh^2}p_n $$\n现在我们将 $q_{n+1}$ 的这个表达式代入方程（2）来求 $p_{n+1}$。为简化代数运算，设 $A = \\frac{m}{h} + \\frac{kh}{4}$ 且 $B = \\frac{m}{h} - \\frac{kh}{4}$。该映射为 $q_{n+1} = \\frac{B}{A}q_n - \\frac{1}{A}p_n$ 和 $p_{n+1} = A q_n - B q_{n+1}$。\n$$ p_{n+1} = A q_n - B\\left(\\frac{B}{A}q_n - \\frac{1}{A}p_n\\right) = \\left(A - \\frac{B^2}{A}\\right)q_n + \\frac{B}{A}p_n = \\frac{A^2-B^2}{A}q_n + \\frac{B}{A}p_n $$\n我们计算各项：\n$$ A^2 - B^2 = (A-B)(A+B) = \\left( \\frac{kh}{2} \\right) \\left( \\frac{2m}{h} \\right) = km $$\n所以，$q_n$ 的系数是 $\\frac{km}{A} = \\frac{km}{\\frac{m}{h} + \\frac{kh}{4}} = \\frac{4hkm}{4m+kh^2}$。$p_n$ 的系数是 $\\frac{B}{A} = \\frac{4m-kh^2}{4m+kh^2}$。\n完整的更新关系是：\n$$ q_{n+1} = \\frac{4m-kh^2}{4m+kh^2}\\,q_n - \\frac{4h}{4m+kh^2}\\,p_n $$\n$$ p_{n+1} = \\frac{4hkm}{4m+kh^2}\\,q_n + \\frac{4m-kh^2}{4m+kh^2}\\,p_n $$\n这个变换是线性的，因为它可以表示成矩阵形式。设 $z_n = \\begin{pmatrix} q_n \\\\ p_n \\end{pmatrix}$。那么 $z_{n+1} = M z_n$，其中映射矩阵 $M$ 是\n$$ M = \\frac{1}{4m+kh^2} \\begin{pmatrix} 4m - kh^2 & -4h \\\\ 4hkm & 4m - kh^2 \\end{pmatrix} $$\n为了证明该映射是辛的，我们必须证明雅可比矩阵 $M$ 满足 $M^T J M = J$，其中 $J = \\begin{pmatrix} 0 & 1 \\\\ -1 & 0 \\end{pmatrix}$。对于一个 $2 \\times 2$ 矩阵，这个条件等价于 $\\det(M)=1$。\n$$ \\det(M) = \\left( \\frac{1}{4m+kh^2} \\right)^2 \\left[ (4m-kh^2)^2 - (-4h)(4hkm) \\right] $$\n$$ \\det(M) = \\frac{1}{(4m+kh^2)^2} \\left[ (16m^2 - 8mkh^2 + k^2h^4) + 16h^2km \\right] $$\n$$ \\det(M) = \\frac{1}{(4m+kh^2)^2} \\left[ 16m^2 + 8mkh^2 + k^2h^4 \\right] = \\frac{(4m+kh^2)^2}{(4m+kh^2)^2} = 1 $$\n由于 $\\det(M)=1$，该映射是辛的。这个方法从作用量的对称近似推导而来，是隐式中点法则，它是一个二阶、时间可逆的辛积分器。此构造满足了问题的所有要求。\n\n问题要求生成函数 $S_1(q,Q;h)$ 的闭式表达式。根据以上推导，其表达式为：\n$$ S_1(q, Q; h) = \\frac{m}{2h}(Q-q)^2 - \\frac{kh}{8}(q+Q)^2 $$",
            "answer": "$$ \\boxed{ \\frac{m}{2h}(Q-q)^2 - \\frac{kh}{8}(q+Q)^2 } $$"
        },
        {
            "introduction": "从普适的理论构建，我们转向一个聚变科学中的关键应用：带电粒子在磁场中的运动。本次实践要求实现著名的 Boris 算法，这是一个通过对称分裂方法推导出的经典几何积分器。练习的重点将是通过数值实验验证其时间可逆性，这是确保长期模拟保真度、避免虚假能量漂移的关键特性 。",
            "id": "4049930",
            "problem": "考虑在与计算聚变科学和工程相关的磁化等离子体动力学背景下，单个带电粒子在静磁场中的运动。一个电荷为 $q$、质量为 $m$ 的粒子遵循牛顿第二定律，并受到洛伦兹磁力的作用：$m \\,\\dfrac{d\\mathbf{v}}{dt} = q\\,\\mathbf{v}\\times\\mathbf{B}(\\mathbf{r})$ 和 $\\dfrac{d\\mathbf{r}}{dt} = \\mathbf{v}$，其中 $\\mathbf{r}\\in\\mathbb{R}^3$ 是位置，$\\mathbf{v}\\in\\mathbb{R}^3$ 是速度，$\\mathbf{B}(\\mathbf{r})\\in\\mathbb{R}^3$ 是一个无散磁场。从这些基本定律出发，构建一个单步、显式、保结构的几何算法，该算法在时间上是可逆的。该算法必须从第一性原理出发，使用流的对称分裂方法推导得出，以保持纯磁动力学的典范几何性质，即相空间体积守恒和精确的时间对称性。您推导的格式不应引入任何人为耗散，并且必须与动能在静磁场中的不变性相一致（因为 $\\mathbf{v}\\cdot(\\mathbf{v}\\times\\mathbf{B})=0$）。\n\n您的程序必须实现所推导的可逆格式，并通过对每个测试案例执行以下计算实验来数值地展示其精确的时间对称性：从 $(\\mathbf{r}_0,\\mathbf{v}_0)$ 开始，使用时间步长 $h$ 向前积分 $N$ 步到 $(\\mathbf{r}_N,\\mathbf{v}_N)$，然后从 $(\\mathbf{r}_N,\\mathbf{v}_N)$ 开始，使用时间步长 $-h$ 向后积分 $N$ 步，并验证最终状态 $(\\mathbf{r}_{\\text{rev}},\\mathbf{v}_{\\text{rev}})$ 在数值精度范围内与初始状态 $(\\mathbf{r}_0,\\mathbf{v}_0)$ 相匹配。如果 $\\|\\mathbf{r}_{\\text{rev}}-\\mathbf{r}_0\\|_\\infty$ 和 $\\|\\mathbf{v}_{\\text{rev}}-\\mathbf{v}_0\\|_\\infty$ 都小于一个与机器精度乘以初始数据尺度成比例的容差，则判定其具有时间对称性。程序中的所有量都必须以国际单位制（SI单位）处理：米（m）、秒（s）、千克（kg）和库仑（C）。如果内部使用角度，必须以弧度为单位。\n\n测试套件包含五个科学上合理的参数集，旨在探测磁化运动的不同机制和边界情况：\n- 测试 1 (均匀场，中等步长): $q=1.602176634\\times 10^{-19}\\,\\text{C}$， $m=1.67262192369\\times 10^{-27}\\,\\text{kg}$， $\\mathbf{B}(\\mathbf{r})=\\left[0,0,B_0\\right]$ 其中 $B_0=3\\,\\text{T}$， $h=1.0\\times 10^{-9}\\,\\text{s}$， $N=100$， $\\mathbf{r}_0=[0.1,0.0,0.0]\\,\\text{m}$， $\\mathbf{v}_0=[1.0\\times 10^{5},2.0\\times 10^{5},0.0]\\,\\text{m/s}$。\n- 测试 2 (零场边界情况): $q=1.602176634\\times 10^{-19}\\,\\text{C}$， $m=1.67262192369\\times 10^{-27}\\,\\text{kg}$， $\\mathbf{B}(\\mathbf{r})=\\left[0,0,0\\right]\\,\\text{T}$， $h=2.0\\times 10^{-9}\\,\\text{s}$， $N=50$， $\\mathbf{r}_0=[-0.3,0.2,0.0]\\,\\text{m}$， $\\mathbf{v}_0=[-5.0\\times 10^{4},1.0\\times 10^{5},1.0\\times 10^{5}]\\,\\text{m/s}$。\n- 测试 3 (非均匀无散场): $q=1.602176634\\times 10^{-19}\\,\\text{C}$， $m=1.67262192369\\times 10^{-27}\\,\\text{kg}$， $\\mathbf{B}(\\mathbf{r})=\\left[\\alpha x,-\\alpha y,B_0\\right]$ 其中 $\\alpha=0.5\\,\\text{T/m}$ 且 $B_0=1.0\\,\\text{T}$， $h=5.0\\times 10^{-10}\\,\\text{s}$， $N=200$， $\\mathbf{r}_0=[0.0,0.0,0.0]\\,\\text{m}$， $\\mathbf{v}_0=[2.0\\times 10^{5},0.0,1.0\\times 10^{5}]\\,\\text{m/s}$。\n- 测试 4 (强场，小步长): $q=1.602176634\\times 10^{-19}\\,\\text{C}$， $m=1.67262192369\\times 10^{-27}\\,\\text{kg}$， $\\mathbf{B}(\\mathbf{r})=\\left[0,0,B_0\\right]$ 其中 $B_0=10\\,\\text{T}$， $h=1.0\\times 10^{-10}\\,\\text{s}$， $N=1000$， $\\mathbf{r}_0=[0.0,0.5,0.0]\\,\\text{m}$， $\\mathbf{v}_0=[3.0\\times 10^{5},-1.0\\times 10^{5},0.0]\\,\\text{m/s}$。\n- 测试 5 (长积分，小步长，随机初始状态): $q=1.602176634\\times 10^{-19}\\,\\text{C}$， $m=1.67262192369\\times 10^{-27}\\,\\text{kg}$， $\\mathbf{B}(\\mathbf{r})=\\left[\\alpha x,-\\alpha y,B_0\\right]$ 其中 $\\alpha=0.2\\,\\text{T/m}$ 且 $B_0=2.0\\,\\text{T}$， $h=2.0\\times 10^{-10}\\,\\text{s}$， $N=2000$， $\\mathbf{r}_0=[0.2,-0.1,0.05]\\,\\text{m}$， $\\mathbf{v}_0=[1.5\\times 10^{5},1.2\\times 10^{5},-0.5\\times 10^{5}]\\,\\text{m/s}$。\n\n对于每个测试，计算一个布尔值，指示积分器是否在数值精度范围内具有时间对称性，定义为 $\\|\\mathbf{r}_{\\text{rev}}-\\mathbf{r}_0\\|_\\infty \\le \\varepsilon_r$ 和 $\\|\\mathbf{v}_{\\text{rev}}-\\mathbf{v}_0\\|_\\infty \\le \\varepsilon_v$，其中容差为 $\\varepsilon_r = 10^{-11}\\max\\{1,\\|\\mathbf{r}_0\\|_2\\}$ 和 $\\varepsilon_v = 10^{-11}\\max\\{1,\\|\\mathbf{v}_0\\|_2\\}$。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，\"[result1,result2,result3,result4,result5]\"），其中每个“result”是按上述顺序对应测试的布尔值。",
            "solution": "## 问题验证\n\n### 步骤1：提取已知条件\n\n问题提供了以下物理定律和定义：\n- 位置运动方程：$\\dfrac{d\\mathbf{r}}{dt} = \\mathbf{v}$。\n- 速度运动方程（洛伦兹力）：$m \\,\\dfrac{d\\mathbf{v}}{dt} = q\\,\\mathbf{v}\\times\\mathbf{B}(\\mathbf{r})$。\n- 变量：位置 $\\mathbf{r}\\in\\mathbb{R}^3$，速度 $\\mathbf{v}\\in\\mathbb{R}^3$，电荷 $q$，质量 $m$。\n- 磁场：$\\mathbf{B}(\\mathbf{r})\\in\\mathbb{R}^3$，是静态且无散的（$\\nabla \\cdot \\mathbf{B} = 0$）。\n\n计算任务要求：\n- 构建一个单步、显式、保结构的几何算法，该算法在时间上是可逆的。\n- 算法必须使用对称分裂从第一性原理推导。\n- 算法必须在数值上展示时间对称性。\n- 先以步长 $h$ 进行 $N$ 步前向积分，再以步长 $-h$ 进行 $N$ 步后向积分。\n- 如果 $\\|\\mathbf{r}_{\\text{rev}}-\\mathbf{r}_0\\|_\\infty \\le \\varepsilon_r$ 且 $\\|\\mathbf{v}_{\\text{rev}}-\\mathbf{v}_0\\|_\\infty \\le \\varepsilon_v$，则确认时间对称性。\n- 容差：$\\varepsilon_r = 10^{-11}\\max\\{1,\\|\\mathbf{r}_0\\|_2\\}$ 和 $\\varepsilon_v = 10^{-11}\\max\\{1,\\|\\mathbf{v}_0\\|_2\\}$。\n\n问题提供了五个测试案例及其参数：\n- **测试 1:** $q=1.602176634\\times 10^{-19}\\,\\text{C}$， $m=1.67262192369\\times 10^{-27}\\,\\text{kg}$， $\\mathbf{B}(\\mathbf{r})=\\left[0,0,3\\right]\\,\\text{T}$， $h=1.0\\times 10^{-9}\\,\\text{s}$， $N=100$， $\\mathbf{r}_0=[0.1,0.0,0.0]\\,\\text{m}$， $\\mathbf{v}_0=[1.0\\times 10^{5},2.0\\times 10^{5},0.0]\\,\\text{m/s}$。\n- **测试 2:** $q=1.602176634\\times 10^{-19}\\,\\text{C}$， $m=1.67262192369\\times 10^{-27}\\,\\text{kg}$， $\\mathbf{B}(\\mathbf{r})=\\left[0,0,0\\right]\\,\\text{T}$， $h=2.0\\times 10^{-9}\\,\\text{s}$， $N=50$， $\\mathbf{r}_0=[-0.3,0.2,0.0]\\,\\text{m}$， $\\mathbf{v}_0=[-5.0\\times 10^{4},1.0\\times 10^{5},1.0\\times 10^{5}]\\,\\text{m/s}$。\n- **测试 3:** $q=1.602176634\\times 10^{-19}\\,\\text{C}$， $m=1.67262192369\\times 10^{-27}\\,\\text{kg}$， $\\mathbf{B}(\\mathbf{r})=\\left[\\alpha x,-\\alpha y,B_0\\right]$ 其中 $\\alpha=0.5\\,\\text{T/m}$， $B_0=1.0\\,\\text{T}$， $h=5.0\\times 10^{-10}\\,\\text{s}$， $N=200$， $\\mathbf{r}_0=[0.0,0.0,0.0]\\,\\text{m}$， $\\mathbf{v}_0=[2.0\\times 10^{5},0.0,1.0\\times 10^{5}]\\,\\text{m/s}$。\n- **测试 4:** $q=1.602176634\\times 10^{-19}\\,\\text{C}$， $m=1.67262192369\\times 10^{-27}\\,\\text{kg}$， $\\mathbf{B}(\\mathbf{r})=\\left[0,0,10\\right]\\,\\text{T}$， $h=1.0\\times 10^{-10}\\,\\text{s}$， $N=1000$， $\\mathbf{r}_0=[0.0,0.5,0.0]\\,\\text{m}$， $\\mathbf{v}_0=[3.0\\times 10^{5},-1.0\\times 10^{5},0.0]\\,\\text{m/s}$。\n- **测试 5:** $q=1.602176634\\times 10^{-19}\\,\\text{C}$， $m=1.67262192369\\times 10^{-27}\\,\\text{kg}$， $\\mathbf{B}(\\mathbf{r})=\\left[\\alpha x,-\\alpha y,B_0\\right]$ 其中 $\\alpha=0.2\\,\\text{T/m}$， $B_0=2.0\\,\\text{T}$， $h=2.0\\times 10^{-10}\\,\\text{s}$， $N=2000$， $\\mathbf{r}_0=[0.2,-0.1,0.05]\\,\\text{m}$， $\\mathbf{v}_0=[1.5\\times 10^{5},1.2\\times 10^{5},-0.5\\times 10^{5}]\\,\\text{m/s}$。\n\n### 步骤2：使用提取的已知条件进行验证\n\n1.  **科学依据：** 该问题基于经典电动力学的基本定律——牛顿第二定律和洛伦兹力，这准确描述了带电粒子在磁场中的运动。指定的粒子参数对应于质子，磁场强度和速度是聚变等离子体环境中的典型值。非均匀磁场 $\\mathbf{B}(\\mathbf{r})=\\left[\\alpha x,-\\alpha y,B_0\\right]$ 在物理上是有效的，因为它是无散的：$\\nabla \\cdot \\mathbf{B} = \\frac{\\partial(\\alpha x)}{\\partial x} + \\frac{\\partial(-\\alpha y)}{\\partial y} + \\frac{\\partial B_0}{\\partial z} = \\alpha - \\alpha + 0 = 0$。\n2.  **适定性：** 为该系统构建时间可逆的几何积分器是计算物理学中的一个经典课题。对算法的要求是具体的，并导向一个明确定义的解族（对称分裂格式）。验证时间对称性的数值实验定义清晰，容差具体。所有必要的数据都已提供。\n3.  **客观性：** 问题以精确、客观和数学的语言陈述。没有主观或基于意见的主张。\n4.  **相关性：** 问题明确属于*计算聚变科学与工程*领域中的*保结构几何算法*。\n\n该问题没有科学缺陷、矛盾和歧义。\n\n### 步骤3：结论与行动\n该问题有效。将提供解决方案。\n\n## 算法推导与求解\n\n目标是为控制带电粒子在磁场中运动的常微分方程组构建一个保结构的数值积分器：\n$$\n\\frac{d\\mathbf{r}}{dt} = \\mathbf{v}\n$$\n$$\n\\frac{d\\mathbf{v}}{dt} = \\frac{q}{m} \\mathbf{v} \\times \\mathbf{B}(\\mathbf{r})\n$$\n令系统状态由相空间向量 $\\mathbf{z} = (\\mathbf{r}, \\mathbf{v})$ 表示。系统在一个时间步长 $h$ 内的演化可以用一个流映射 $\\Phi_h$ 表示，使得 $\\mathbf{z}(t+h) = \\Phi_h(\\mathbf{z}(t))$。保结构的几何积分器是 $\\Phi_h$ 的一种近似，它保留了真实流的关键几何性质，如相空间体积（辛性）和时间可逆性。\n\n构建此类积分器的一种标准方法是算子分裂。控制动力学的向量场 $\\dot{\\mathbf{z}} = F(\\mathbf{z})$ 被分裂成两个或多个部分，其中每个部分对应一个可以精确求解的子系统。对于这个问题，我们可以将动力学分裂为自由漂流部分（A）和速度旋转部分（B）：\n- **A部分（自由漂流/漂移）：**\n$$\n\\frac{d\\mathbf{r}}{dt} = \\mathbf{v}, \\quad \\frac{d\\mathbf{v}}{dt} = \\mathbf{0}\n$$\n在一个时间步长 $h$ 内的精确流 $\\Phi_A^h$ 是：\n$$\n\\mathbf{r}(t+h) = \\mathbf{r}(t) + h \\mathbf{v}(t), \\quad \\mathbf{v}(t+h) = \\mathbf{v}(t)\n$$\n- **B部分（速度旋转/踢动）：**\n$$\n\\frac{d\\mathbf{r}}{dt} = \\mathbf{0}, \\quad \\frac{d\\mathbf{v}}{dt} = \\frac{q}{m} \\mathbf{v} \\times \\mathbf{B}(\\mathbf{r})\n$$\n在一个时间步长 $h$ 内的精确流 $\\Phi_B^h$ 保持位置不变，即 $\\mathbf{r}(t+h) = \\mathbf{r}(t)$，并将速度向量 $\\mathbf{v}$ 围绕由磁场向量 $\\mathbf{B}(\\mathbf{r})$ 定义的轴旋转，回旋频率为 $\\omega_c = |q|\\|\\mathbf{B}\\|/m$。由于在此子步骤中 $\\mathbf{r}$ 是恒定的，$\\mathbf{B}(\\mathbf{r})$ 也是恒定的，因此该子系统描述了一个纯粹的旋转。这种旋转保持速度的大小 $\\|\\mathbf{v}\\|$ 不变，从而守恒动能。\n\n为了构建一个时间可逆的积分器，我们使用这些精确流的对称组合。Strang 分裂法提供了一个二阶精确且对称的格式：\n$$\n\\Phi_h^{\\text{approx}} = \\Phi_A^{h/2} \\circ \\Phi_B^h \\circ \\Phi_A^{h/2}\n$$\n此组合从右到左解读：一个半步漂移，一个整步旋转，然后是另一个半步漂移。让我们将其转化为一个显式算法，以将状态从 $t_n$ 时的 $(\\mathbf{r}_n, \\mathbf{v}_n)$ 更新到 $t_{n+1} = t_n + h$ 时的 $(\\mathbf{r}_{n+1}, \\mathbf{v}_{n+1})$：\n\n1.  **第一个半步漂移（应用 $\\Phi_A^{h/2}$）：** 使用当前速度将位置推进半个时间步。\n    $$\n    \\mathbf{r}_{n+1/2} = \\mathbf{r}_n + \\frac{h}{2} \\mathbf{v}_n\n    $$\n2.  **整步旋转（应用 $\\Phi_B^h$）：** 将速度旋转一个完整的时间步。此格式的关键在于在时间中心的位置 $\\mathbf{r}_{n+1/2}$ 处评估磁场 $\\mathbf{B}$。这种中心化是该方法对称性和准确性的关键。速度更新求解 $\\frac{d\\mathbf{v}}{dt} = \\frac{q}{m} \\mathbf{v} \\times \\mathbf{B}(\\mathbf{r}_{n+1/2})$。对此旋转子问题，一个标准的、计算高效且精确的实现是 Boris 算法。它由速度方程的中心差分近似推导而来：\n    $$\n    \\frac{\\mathbf{v}_{n+1} - \\mathbf{v}_n}{h} = \\frac{q}{m} \\left( \\frac{\\mathbf{v}_{n+1} + \\mathbf{v}_n}{2} \\right) \\times \\mathbf{B}(\\mathbf{r}_{n+1/2})\n    $$\n    该方程可以显式地求解 $\\mathbf{v}_{n+1}$，得到以下步骤：\n    a. 定义无量纲旋转向量 $\\boldsymbol{\\tau} = \\frac{q h}{2m} \\mathbf{B}(\\mathbf{r}_{n+1/2})$。\n    b. 计算一个中间速度 $\\mathbf{v}' = \\mathbf{v}_n + \\mathbf{v}_n \\times \\boldsymbol{\\tau}$。\n    c. 计算新速度 $\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\frac{2}{1 + \\|\\boldsymbol{\\tau}\\|^2} (\\mathbf{v}' \\times \\boldsymbol{\\tau})$。\n\n3.  **第二个半步漂移（应用 $\\Phi_A^{h/2}$）：** 使用*新计算出*的速度 $\\mathbf{v}_{n+1}$，将中间位置 $\\mathbf{r}_{n+1/2}$ 推进半个时间步，从而计算出最终位置。\n    $$\n    \\mathbf{r}_{n+1} = \\mathbf{r}_{n+1/2} + \\frac{h}{2} \\mathbf{v}_{n+1}\n    $$\n这个三步过程构成积分器的一个完整时间步。它是显式的，因为每一步都可以直接从前一步的结果计算得出。它是保体积的，因为流 $\\Phi_A$（一个剪切变换）和 $\\Phi_B$（一个子空间中的旋转）的雅可比矩阵行列式都为1，而总的雅可比矩阵是它们的乘积。它是时间可逆的，因为组合是对称的。使用时间步长 $-h$ 应用该格式可以精确地反转用步长 $h$ 执行的变换，这一性质将在数值上得到验证。最后，该格式与能量守恒一致。对于均匀磁场，动能是精确守恒的。对于非均匀磁场，总能量不是精确守恒的，但表现出优秀的长期行为，具有有界振荡，这是几何积分器的一个特征。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a structure-preserving geometric algorithm (Boris algorithm) for\n    charged particle motion in a magnetic field and verifies its time symmetry.\n    \"\"\"\n\n    # Define physical constants for the proton\n    Q_PROTON = 1.602176634e-19  # Elementary charge in Coulombs\n    M_PROTON = 1.67262192369e-27 # Proton mass in kg\n\n    # Define the test cases as specified in the problem statement\n    test_cases = [\n        {\n            \"q\": Q_PROTON, \"m\": M_PROTON, \"B_func_type\": \"uniform\",\n            \"B_params\": {\"B0\": 3.0}, \"h\": 1.0e-9, \"N\": 100,\n            \"r0\": np.array([0.1, 0.0, 0.0]),\n            \"v0\": np.array([1.0e5, 2.0e5, 0.0])\n        },\n        {\n            \"q\": Q_PROTON, \"m\": M_PROTON, \"B_func_type\": \"zero\",\n            \"B_params\": {}, \"h\": 2.0e-9, \"N\": 50,\n            \"r0\": np.array([-0.3, 0.2, 0.0]),\n            \"v0\": np.array([-5.0e4, 1.0e5, 1.0e5])\n        },\n        {\n            \"q\": Q_PROTON, \"m\": M_PROTON, \"B_func_type\": \"linear_nonuniform\",\n            \"B_params\": {\"alpha\": 0.5, \"B0\": 1.0}, \"h\": 5.0e-10, \"N\": 200,\n            \"r0\": np.array([0.0, 0.0, 0.0]),\n            \"v0\": np.array([2.0e5, 0.0, 1.0e5])\n        },\n        {\n            \"q\": Q_PROTON, \"m\": M_PROTON, \"B_func_type\": \"uniform\",\n            \"B_params\": {\"B0\": 10.0}, \"h\": 1.0e-10, \"N\": 1000,\n            \"r0\": np.array([0.0, 0.5, 0.0]),\n            \"v0\": np.array([3.0e5, -1.0e5, 0.0])\n        },\n        {\n            \"q\": Q_PROTON, \"m\": M_PROTON, \"B_func_type\": \"linear_nonuniform\",\n            \"B_params\": {\"alpha\": 0.2, \"B0\": 2.0}, \"h\": 2.0e-10, \"N\": 2000,\n            \"r0\": np.array([0.2, -0.1, 0.05]),\n            \"v0\": np.array([1.5e5, 1.2e5, -0.5e5])\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        q = case[\"q\"]\n        m = case[\"m\"]\n        h = case[\"h\"]\n        N = case[\"N\"]\n        r0 = case[\"r0\"]\n        v0 = case[\"v0\"]\n        \n        # Define the magnetic field function based on test case parameters\n        if case[\"B_func_type\"] == \"uniform\":\n            B0 = case[\"B_params\"][\"B0\"]\n            B_func = lambda r: np.array([0.0, 0.0, B0])\n        elif case[\"B_func_type\"] == \"zero\":\n            B_func = lambda r: np.array([0.0, 0.0, 0.0])\n        elif case[\"B_func_type\"] == \"linear_nonuniform\":\n            alpha = case[\"B_params\"][\"alpha\"]\n            B0 = case[\"B_params\"][\"B0\"]\n            B_func = lambda r: np.array([alpha * r[0], -alpha * r[1], B0])\n        \n        # Pre-calculate charge-to-mass ratio for efficiency\n        q_over_m = q / m\n\n        def boris_step(r, v, time_step):\n            \"\"\"\n            Performs one step of the Boris algorithm.\n            \"\"\"\n            # First half position drift\n            r_half = r + 0.5 * time_step * v\n            \n            # Evaluate B-field at the midpoint position\n            B_mid = B_func(r_half)\n            \n            # Velocity rotation\n            t_vec = (q_over_m * time_step / 2.0) * B_mid\n            t_mag_sq = np.dot(t_vec, t_vec)\n            \n            v_prime = v + np.cross(v, t_vec)\n            s_vec = (2.0 / (1.0 + t_mag_sq)) * t_vec\n            v_new = v + np.cross(v_prime, s_vec)\n            \n            # Second half position drift\n            r_new = r_half + 0.5 * time_step * v_new\n            \n            return r_new, v_new\n            \n        # Forward integration\n        r_fwd, v_fwd = np.copy(r0), np.copy(v0)\n        for _ in range(N):\n            r_fwd, v_fwd = boris_step(r_fwd, v_fwd, h)\n            \n        # Backward integration\n        r_rev, v_rev = np.copy(r_fwd), np.copy(v_fwd)\n        for _ in range(N):\n            r_rev, v_rev = boris_step(r_rev, v_rev, -h)\n            \n        # Verification of time symmetry\n        eps_r_scale = max(1.0, np.linalg.norm(r0))\n        eps_v_scale = max(1.0, np.linalg.norm(v0))\n        \n        tol_r = 1e-11 * eps_r_scale\n        tol_v = 1e-11 * eps_v_scale\n        \n        err_r = np.linalg.norm(r_rev - r0, ord=np.inf)\n        err_v = np.linalg.norm(v_rev - v0, ord=np.inf)\n        \n        is_symmetric = (err_r = tol_r) and (err_v = tol_v)\n        results.append(is_symmetric)\n\n    # Format the final output as a comma-separated list of lowercase booleans\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在构建并验证了一个几何积分器之后，最后一步是定量地理解它为何优越。本次实践将通过比较一个辛积分器和一个标准的高阶方法 (RK4)，深入探讨数值方法的长期行为。借助后向误差分析 (Backward Error Analysis, BEA) 的视角，你将发现几何积分器如何产生有界的“相位误差”而非累积的“振幅误差”，从而在极长的时间尺度上保持系统的定性动力学特征 。",
            "id": "4049892",
            "problem": "考虑均匀磁场中单电荷离子的平面回旋运动，以此作为磁约束聚变装置中快动力学的基准模型。使用洛伦兹力定律作为基本依据，将问题纯粹用数学术语表述如下。\n\n从洛伦兹力定律出发，考虑一个电荷为 $q$、质量为 $m$ 的粒子在均匀磁场 $\\mathbf{B} = B \\,\\hat{\\mathbf{z}}$ 中运动，且不存在电场。设 $\\mathbf{r}(t) = (x(t), y(t))$ 为位置，$\\mathbf{v}(t) = (v_x(t), v_y(t))$ 为垂直于磁场 $\\mathbf{B}$ 的平面内的速度。其控制方程为\n$$\nm \\,\\frac{d\\mathbf{v}}{dt} = q\\,\\mathbf{v} \\times \\mathbf{B}, \\qquad \\frac{d\\mathbf{r}}{dt} = \\mathbf{v}.\n$$\n定义回旋频率 $\\Omega = \\frac{q B}{m}$ 和 $2\\times 2$ 典范辛矩阵 $J = \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix}$。则平面内速度的演化是一个线性哈密顿系统\n$$\n\\frac{d\\mathbf{v}}{dt} = \\Omega\\,J\\,\\mathbf{v}.\n$$\n\n待完成的任务：\n\n1. 利用哈密顿结构和后向误差分析 (BEA)，推导应用于线性系统 $\\frac{d\\mathbf{v}}{dt} = \\Omega\\,J\\,\\mathbf{v}$ 的辛隐式中点法的修正频率。从第一性原理出发，展示该方法的单步映射如何用生成元的凯莱变换表示，并获得每步的修正角增量。利用此结果推导隐式中点法在总时间 $T$ 内的长时间相位误差表达式。\n\n2. 对于经典显式四阶龙格-库塔方法（四阶龙格-库塔法），通过在其生成元上评估其稳定多项式，计算其应用于相同线性系统的单步映射。将每步的角增量确定为在纯虚步长参数处评估的稳定函数的复辐角。利用此结果推导在总时间 $T$ 内的长时间相位误差。\n\n3. 将相位误差定义为数值累积相位与精确累积相位 $ \\Omega T $ 之差在 $[-\\pi,\\pi]$ 内的主值（角度以弧度为单位）。具体而言，若 $\\theta_{\\text{num}}$ 是时间 $T$ 后的总数值相位，则相位误差为包裹角\n$$\n\\Delta\\phi = \\mathrm{wrap}\\!\\left(\\theta_{\\text{num}} - \\Omega T\\right),\n$$\n其中 $\\mathrm{wrap}(\\phi) = \\left((\\phi + \\pi) \\bmod 2\\pi\\right) - \\pi$。\n\n4. 实现一个完整的、可运行的程序，该程序针对给定的测试套件，为每个案例计算三个量：\n   - 对于隐式中点法，由 BEA 预测的长时间相位误差，\n   - 对于隐式中点法，数值累积的长时间相位误差（使用推导出的每步角增量），\n   - 对于四阶龙格-库塔方法，数值累积的长时间相位误差（使用其稳定函数的复辐角）。\n   所有角度必须以弧度为单位。\n\n使用以下测试套件，该套件涵盖了一般情况、细时间步长范围以及用于探究长时间行为的逐渐增大的粗糙范围：\n- 物理参数（所有案例中保持不变）：$q = 1.602\\times 10^{-19}$ 库仑，$m = 3.34358\\times 10^{-27}$ 千克，$B = 3.5$ 特斯拉。\n- 根据这些参数，计算回旋频率 $\\Omega = \\frac{qB}{m}$ 和回旋周期 $T_c = \\frac{2\\pi}{\\Omega}$。\n- 案例由每个周期的步数 $N_p$ 和要模拟的周期数 $N_{\\text{per}}$ 指定：\n  1. 案例 A (理想情况): $N_p = 64$, $N_{\\text{per}} = 1000$。\n  2. 案例 B (细步长，极长时间): $N_p = 128$, $N_{\\text{per}} = 50000$。\n  3. 案例 C (中等粗糙): $N_p = 8$, $N_{\\text{per}} = 2000$。\n  4. 案例 D (粗糙，接近非辛伪影可见的边缘): $N_p = 4$, $N_{\\text{per}} = 500$。\n\n对于每个案例，计算时间步长 $h = \\frac{T_c}{N_p}$、总时间 $T = N_{\\text{per}}\\,T_c$ 以及整数步数 $N = \\frac{T}{h} = N_{\\text{per}}\\,N_p$。角度必须以弧度为单位。\n\n你的程序应生成单行输出，其中包含一个由四个子列表组成的逗号分隔列表，每个子列表对应一个测试案例，并按指定顺序列出三个相位误差。例如，格式必须为\n$$\n[\\,[e_{A,\\mathrm{BEA}},e_{A,\\mathrm{IM}},e_{A,\\mathrm{RK4}}],\\,[e_{B,\\mathrm{BEA}},e_{B,\\mathrm{IM}},e_{B,\\mathrm{RK4}}],\\,[e_{C,\\mathrm{BEA}},e_{C,\\mathrm{IM}},e_{C,\\mathrm{RK4}}],\\,[e_{D,\\mathrm{BEA}},e_{D,\\mathrm{IM}},e_{D,\\mathrm{RK4}}]\\,],\n$$\n所有数值量均以弧度为单位。最终输出必须是严格符合此方括号逗号分隔格式的单行文本，并且所有条目都必须是浮点数（不打印单位，但根据问题定义，角度以弧度为单位）。",
            "solution": "用户提供的问题陈述具有科学依据、问题定义清晰、客观且完整。这是一个计算物理和数值分析中的标准问题，重点关注哈密顿系统的几何积分子的性质。该问题是有效的，并且可以按所述方式解决。\n\n该问题要求分析和计算两种数值方法——辛隐式中点法和显式四阶龙格-库塔 (RK4) 方法——在应用于均匀磁场中带电粒子平面回旋运动时的相位误差。速度 $\\mathbf{v} \\in \\mathbb{R}^2$ 的控制方程是线性哈密顿系统：\n$$\n\\frac{d\\mathbf{v}}{dt} = \\Omega J \\mathbf{v},\n$$\n其中 $\\Omega = \\frac{qB}{m}$ 是回旋频率，$J = \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix}$ 是典范辛矩阵。精确解是速度平面上的一个旋转，由 $\\mathbf{v}(t) = e^{t\\Omega J} \\mathbf{v}(0)$ 给出，其中 $e^{t\\Omega J} = \\begin{pmatrix} \\cos(\\Omega t)  \\sin(\\Omega t) \\\\ -\\sin(\\Omega t)  \\cos(\\Omega t) \\end{pmatrix}$。在时间 $T$ 内累积的总相位为 $\\theta_{\\text{exact}} = \\Omega T$。\n\n**1. 隐式中点法分析**\n\n对于常微分方程 (ODE) $\\frac{d\\mathbf{y}}{dt} = f(\\mathbf{y})$，隐式中点法由下式给出：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + h f\\left(\\frac{\\mathbf{y}_n + \\mathbf{y}_{n+1}}{2}\\right),\n$$\n其中 $h$ 是时间步长。对于我们的线性系统 $f(\\mathbf{v}) = \\Omega J \\mathbf{v}$，该方法变为：\n$$\n\\mathbf{v}_{n+1} = \\mathbf{v}_n + h \\Omega J \\left(\\frac{\\mathbf{v}_n + \\mathbf{v}_{n+1}}{2}\\right).\n$$\n为求得单步映射 $\\mathbf{v}_{n+1} = S_{\\text{IM}} \\mathbf{v}_n$，我们求解 $\\mathbf{v}_{n+1}$：\n$$\n\\left(I - \\frac{h\\Omega}{2}J\\right) \\mathbf{v}_{n+1} = \\left(I + \\frac{h\\Omega}{2}J\\right) \\mathbf{v}_n.\n$$\n$$\nS_{\\text{IM}} = \\left(I - \\frac{h\\Omega}{2}J\\right)^{-1} \\left(I + \\frac{h\\Omega}{2}J\\right).\n$$\n此表达式是矩阵 $\\frac{h\\Omega J}{2}$ 的凯莱变换。由于 $\\Omega J$ 是一个斜对称矩阵，映射 $S_{\\text{IM}}$ 是正交的，并保持二次不变量 $\\mathbf{v}^T\\mathbf{v}$（动能），因此它是一个辛映射。它表示一个以某个数值角度 $\\theta_{\\text{step,IM}}$进行的精确旋转。\n\n为求得此角度，我们分析该映射的特征值。生成元矩阵 $\\Omega J$ 的特征值为 $\\pm i\\Omega$。单步映射 $S_{\\text{IM}}$ 的特征值可通过将凯莱变换作为标量函数 $c(\\lambda) = \\frac{1+\\lambda/2}{1-\\lambda/2}$ 应用于 $h\\Omega J$ 的特征值（即 $\\pm i h\\Omega$）来得到。令 $\\alpha = h\\Omega$。$S_{\\text{IM}}$ 的特征值为：\n$$\n\\lambda_{\\text{IM}} = \\frac{1 + i\\alpha/2}{1 - i\\alpha/2}.\n$$\n这是一个单位圆上的复数，我们可以将其写作 $e^{i\\theta_{\\text{step,IM}}}$。每步的角增量是该特征值的辐角：\n$$\n\\theta_{\\text{step,IM}} = \\arg\\left(\\frac{1 + i\\alpha/2}{1 - i\\alpha/2}\\right) = 2 \\arctan\\left(\\frac{\\alpha}{2}\\right).\n$$\n经过 $N$ 步后累积的总数值相位为 $\\theta_{\\text{num,IM}} = N \\theta_{\\text{step,IM}}$。相对于精确相位 $\\Omega T = N\\alpha$ 的相位误差为 $\\Delta\\phi_{\\text{IM}} = \\mathrm{wrap}(N\\theta_{\\text{step,IM}} - N\\alpha)$。\n\n对于辛方法，后向误差分析 (BEA) 指出，数值流是某个修正哈密顿量的精确流。这意味着数值解根据一个修正频率 $\\tilde{\\Omega}$ 演化。修正频率的定义是：使用该频率经过一个步长 $h$ 的精确演化与数值角增量相匹配，即 $\\tilde{\\Omega} h = \\theta_{\\text{step,IM}}$。\n$$\n\\tilde{\\Omega} = \\frac{\\theta_{\\text{step,IM}}}{h} = \\frac{2}{h} \\arctan\\left(\\frac{h\\Omega}{2}\\right) = \\frac{2}{h} \\arctan\\left(\\frac{\\alpha}{2}\\right).\n$$\n在总时间 $T$ 内，由 BEA 预测的相位误差是使用修正频率累积的总相位与使用精确频率累积的总相位之差：\n$$\n\\Delta\\phi_{\\text{BEA}} = \\mathrm{wrap}(\\tilde{\\Omega}T - \\Omega T) = \\mathrm{wrap}((\\tilde{\\Omega} - \\Omega)T).\n$$\n代入 $T=Nh$ 和 $\\tilde{\\Omega}$ 的表达式，我们发现：\n$$\n(\\tilde{\\Omega} - \\Omega)T = \\left(\\frac{2}{h} \\arctan\\left(\\frac{\\alpha}{2}\\right) - \\Omega\\right)Nh = N\\left(2\\arctan\\left(\\frac{\\alpha}{2}\\right) - \\Omega h\\right) = N(\\theta_{\\text{step,IM}} - \\alpha).\n$$\n因此，正如预期的那样，由 BEA 预测的相位误差与直接计算的数值相位误差具有相同的表达式。\n\n**2. 四阶龙格-库塔方法分析**\n\n对于线性常微分方程 $\\frac{d\\mathbf{y}}{dt} = A\\mathbf{y}$，龙格-库塔方法产生一个单步映射 $\\mathbf{y}_{n+1} = R(hA)\\mathbf{y}_n$，其中 $R(z)$ 是该方法的稳定函数。对于经典四阶龙格-库塔 (RK4) 方法，其稳定函数是指数函数到 4 次项的截断泰勒级数：\n$$\nR(z) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24}.\n$$\n我们系统的单步映射是 $\\mathbf{v}_{n+1} = R(h\\Omega J)\\mathbf{v}_n$。本征模式的演化由该映射的特征值 $R(\\pm i h\\Omega)$ 控制。令 $\\alpha = h\\Omega$。我们计算 $R(i\\alpha)$：\n$$\nR(i\\alpha) = 1 + (i\\alpha) + \\frac{(i\\alpha)^2}{2} + \\frac{(i\\alpha)^3}{6} + \\frac{(i\\alpha)^4}{24} = \\left(1 - \\frac{\\alpha^2}{2} + \\frac{\\alpha^4}{24}\\right) + i\\left(\\alpha - \\frac{\\alpha^3}{6}\\right).\n$$\n该方法不是辛方法；对于 $\\alpha \\neq 0$，$|R(i\\alpha)|$ 的模不恒为 $1$。每步的角增量是 $R(i\\alpha)$ 的复辐角：\n$$\n\\theta_{\\text{step,RK4}} = \\arg(R(i\\alpha)) = \\mathrm{atan2}\\left(\\alpha - \\frac{\\alpha^3}{6}, 1 - \\frac{\\alpha^2}{2} + \\frac{\\alpha^4}{24}\\right).\n$$\n经过 $N$ 步后累积的总数值相位为 $\\theta_{\\text{num,RK4}} = N \\theta_{\\text{step,RK4}}$。相位误差为：\n$$\n\\Delta\\phi_{\\text{RK4}} = \\mathrm{wrap}(\\theta_{\\text{num,RK4}} - \\Omega T) = \\mathrm{wrap}(N(\\theta_{\\text{step,RK4}} - \\alpha)).\n$$\n\n**3. 用于计算的公式总结**\n\n对于每个由 ($N_p$, $N_{\\text{per}}$) 定义的测试案例：\n- 时间步长参数：$\\alpha = h\\Omega = (\\frac{T_c}{N_p})\\Omega = (\\frac{2\\pi/\\Omega}{N_p})\\Omega = \\frac{2\\pi}{N_p}$。\n- 总步数：$N = N_p N_{\\text{per}}$。\n- 相位误差定义：$\\mathrm{wrap}(\\phi) = ((\\phi + \\pi) \\pmod{2\\pi}) - \\pi$。\n- 隐式中点法（BEA 和数值）相位误差：\n$$\ne_{\\text{IM}} = \\mathrm{wrap}\\left(N \\left(2\\arctan\\left(\\frac{\\alpha}{2}\\right) - \\alpha\\right)\\right).\n$$\n- 四阶龙格-库塔相位误差：\n$$\ne_{\\text{RK4}} = \\mathrm{wrap}\\left(N \\left(\\mathrm{atan2}\\left(\\alpha - \\frac{\\alpha^3}{6}, 1 - \\frac{\\alpha^2}{2} + \\frac{\\alpha^4}{24}\\right) - \\alpha\\right)\\right).\n$$\n这些公式在提供的程序中直接实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and prints the phase errors for numerical integrators applied to\n    charged particle gyromotion, as specified in the problem statement.\n    \"\"\"\n\n    # Physical parameters\n    q = 1.602e-19  # Charge in Coulombs\n    m = 3.34358e-27  # Mass in kilograms (Deuteron)\n    B = 3.5  # Magnetic field in Tesla\n\n    # Derived physical quantities\n    Omega = (q * B) / m  # Cyclotron frequency in rad/s\n\n    # Test cases: (Number of steps per period, Number of periods)\n    test_cases = [\n        (64, 1000),      # Case A\n        (128, 50000),    # Case B\n        (8, 2000),       # Case C\n        (4, 500),        # Case D\n    ]\n\n    # Wrapper function to map an angle to the interval [-pi, pi]\n    def wrap_angle(phi):\n        return ((phi + np.pi) % (2 * np.pi)) - np.pi\n\n    all_results = []\n    \n    for case in test_cases:\n        Np, Nper = case\n        \n        # Total number of steps\n        N = Np * Nper\n        \n        # Dimensionless step size parameter a = h*Omega\n        # h = Tc / Np = (2*pi/Omega) / Np = 2*pi / (Omega * Np)\n        # a = h * Omega = 2*pi / Np\n        alpha = 2 * np.pi / Np\n\n        # --- 1. Implicit Midpoint (IM) Method Phase Error ---\n        # The BEA-predicted error and the numerically accumulated error are\n        # mathematically identical for this problem.\n        \n        # Per-step angular increment for IM\n        theta_step_im = 2 * np.arctan(alpha / 2)\n        \n        # Total difference in accumulated angle over N steps\n        # This is N * (numerical_angle_per_step - exact_angle_per_step)\n        total_phase_diff_im = N * (theta_step_im - alpha)\n        \n        # Wrap the final error to [-pi, pi]\n        error_im = wrap_angle(total_phase_diff_im)\n        error_bea = error_im  # As derived, they are the same\n\n        # --- 2. Fourth-Order Runge-Kutta (RK4) Method Phase Error ---\n        \n        # Real and imaginary parts of the stability function R(i*alpha)\n        # R(z) = 1 + z + z^2/2 + z^3/6 + z^4/24\n        # R(i*a) = (1 - a^2/2 + a^4/24) + i*(a - a^3/6)\n        rk4_re = 1 - (alpha**2) / 2 + (alpha**4) / 24\n        rk4_im = alpha - (alpha**3) / 6\n        \n        # Per-step angular increment for RK4 is the argument of R(i*alpha)\n        theta_step_rk4 = np.arctan2(rk4_im, rk4_re)\n        \n        # Total difference in accumulated angle over N steps\n        total_phase_diff_rk4 = N * (theta_step_rk4 - alpha)\n        \n        # Wrap the final error to [-pi, pi]\n        error_rk4 = wrap_angle(total_phase_diff_rk4)\n\n        all_results.append([error_bea, error_im, error_rk4])\n\n    # Format the final output string exactly as specified.\n    # The output should be a single line: [[...],[...],[...],[...]]\n    result_str = \"[\" + ','.join([f\"[{e[0]},{e[1]},{e[2]}]\" for e in all_results]) + \"]\"\n    \n    print(result_str)\n\nsolve()\n```"
        }
    ]
}