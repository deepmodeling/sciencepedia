{
    "hands_on_practices": [
        {
            "introduction": "为了掌握守恒重映射的核心思想，我们从一个基本的手工计算练习开始。此练习  要求我们直接应用守恒定律，通过精确计算源网格与目标网格之间的几何重叠面积，来推导目标单元上的场平均值。这项实践旨在将抽象的守恒公式与具体的几何计算联系起来，从而加深对守恒重映射本质的理解，即它是一种以重叠面积为权重的加权平均过程。",
            "id": "3958249",
            "problem": "在计算聚变科学与工程的守恒重映中，目标是在网格间传递数据时保持广延量的积分。考虑一个极向截面上的氘面密度场，该场在由两个矩形单元组成的源网格上离散化，并重映到单个三角形目标单元上。重映必须是守恒的，这意味着目标单元上的面密度积分应等于其与重叠的源单元贡献的总和。\n\n假设源网格由笛卡尔平面内的两个轴对齐的矩形单元组成，坐标单位为米：\n- 源单元 $\\mathcal{S}_1$ 的顶点为 $(0,0)$、$(2,0)$、$(2,1)$、$(0,1)$，面积为 $A_{\\mathcal{S}_1}$。\n- 源单元 $\\mathcal{S}_2$ 的顶点为 $(2,0)$、$(5,0)$、$(5,1)$、$(2,1)$，面积为 $A_{\\mathcal{S}_2}$。\n\n目标单元 $\\mathcal{T}$ 是一个三角形，其顶点为 $(1,0)$、$(4,0)$、$(2.5,1)$，面积为 $A_{\\mathcal{T}}$。\n\n设源单元平均的氘面密度在每个源单元内是均匀的，$\\mathcal{S}_1$ 中为 $q_1 = 2$ $\\mathrm{mg/m^2}$，$\\mathcal{S}_2$ 中为 $q_2 = 8$ $\\mathrm{mg/m^2}$。重映通过在源单元和目标三角形之间强制执行精确的多边形相交面积，来实现广延量的精确守恒，从而构建目标单元的平均值 $q_{\\mathcal{T}}$。\n\n从单元平均的基本定义和守恒原理出发，通过以下步骤推导并计算目标单元平均值 $q_{\\mathcal{T}}$ 的精确值：\n- 使用精确的相交面积，将 $\\mathcal{T}$ 上的积分守恒表示为源贡献的总和，\n- 使用三角形的解析边界计算 $\\mathcal{S}_1 \\cap \\mathcal{T}$ 和 $\\mathcal{S}_2 \\cap \\mathcal{T}$ 的精确面积，\n- 计算 $A_{\\mathcal{T}}$，\n- 结合这些结果得到 $q_{\\mathcal{T}}$。\n\n请用 $\\mathrm{mg/m^2}$ 作为单位表示最终答案。无需四舍五入；请提供精确值。",
            "solution": "该问题是有效的，因为它科学地基于守恒数值方法的原理，是具有唯一解的适定问题，并且客观地陈述了所有必要的数据。我们开始解题。\n\n守恒重映的基本原理是，在从源网格向目标网格传递广延量时，其积分保持不变。设广延量为氘的总质量 $M$，其对应的面密度（库存）为 $q$。一个区域 $\\mathcal{A}$ 上的总质量由 $M = \\int_{\\mathcal{A}} q \\, dA$ 给出。\n\n对于一个目标单元 $\\mathcal{T}$，其总质量 $M_{\\mathcal{T}}$ 由其单元平均密度 $q_{\\mathcal{T}}$ 和面积 $A_{\\mathcal{T}}$ 定义为 $M_{\\mathcal{T}} = q_{\\mathcal{T}} A_{\\mathcal{T}}$。守恒原理规定，这个质量必须等于所有与 $\\mathcal{T}$ 重叠的源单元 $\\mathcal{S}_i$ 的质量贡献之和。来自源单元 $\\mathcal{S}_i$ 的贡献是其密度场在相交区域 $\\mathcal{S}_i \\cap \\mathcal{T}$ 上的积分。\n因此，我们可以将守恒定律写为：\n$$M_{\\mathcal{T}} = \\sum_i \\int_{\\mathcal{S}_i \\cap \\mathcal{T}} q_i(\\mathbf{x}) \\, dA$$\n其中 $q_i(\\mathbf{x})$ 是源单元 $\\mathcal{S}_i$ 中的密度场。\n\n在本题中，源密度在每个单元内是均匀的，因此 $q_i(\\mathbf{x}) = q_i$ 是一个常数。方程简化为：\n$$q_{\\mathcal{T}} A_{\\mathcal{T}} = \\sum_i q_i A_{\\mathcal{S}_i \\cap \\mathcal{T}}$$\n其中 $A_{\\mathcal{S}_i \\cap \\mathcal{T}}$ 是源单元 $\\mathcal{S}_i$ 和目标单元 $\\mathcal{T}$ 之间相交区域的面积。\n\n对于给定的具有两个源单元 $\\mathcal{S}_1$ 和 $\\mathcal{S}_2$ 的问题，这变为：\n$$q_{\\mathcal{T}} A_{\\mathcal{T}} = q_1 A_{\\mathcal{S}_1 \\cap \\mathcal{T}} + q_2 A_{\\mathcal{S}_2 \\cap \\mathcal{T}}$$\n因此，目标单元平均密度 $q_{\\mathcal{T}}$ 可以计算为：\n$$q_{\\mathcal{T}} = \\frac{q_1 A_{\\mathcal{S}_1 \\cap \\mathcal{T}} + q_2 A_{\\mathcal{S}_2 \\cap \\mathcal{T}}}{A_{\\mathcal{T}}}$$\n\n我们必须计算三个面积：$A_{\\mathcal{T}}$、$A_{\\mathcal{S}_1 \\cap \\mathcal{T}}$ 和 $A_{\\mathcal{S}_2 \\cap \\mathcal{T}}$。\n\n1.  **计算目标单元的面积 $A_{\\mathcal{T}}$**。\n    目标单元 $\\mathcal{T}$ 是一个顶点为 $(1,0)$、$(4,0)$ 和 $(2.5,1)$ 的三角形。三角形的底边位于 $x$ 轴上，长度为 $4 - 1 = 3$ 米。三角形的高度是第三个顶点的 $y$ 坐标，即 $1$ 米。\n    面积由以下公式给出：\n    $$A_{\\mathcal{T}} = \\frac{1}{2} \\times \\text{底} \\times \\text{高} = \\frac{1}{2} \\times 3 \\times 1 = \\frac{3}{2} \\, \\mathrm{m^2}$$\n\n2.  **计算相交面积**。\n    源单元是 $\\mathcal{S}_1$，即由 $0 \\le x \\le 2$ 和 $0 \\le y \\le 1$ 定义的区域，以及 $\\mathcal{S}_2$，即由 $2 \\le x \\le 5$ 和 $0 \\le y \\le 1$ 定义的区域。它们之间的边界是垂直线 $x=2$。目标三角形 $\\mathcal{T}$ 被这条线分成两部分。\n\n    让我们求出三角形 $\\mathcal{T}$ 的非水平边的方程。\n    -   左边连接 $(1,0)$ 和 $(2.5,1)$。斜率为 $m_1 = \\frac{1-0}{2.5-1} = \\frac{1}{1.5} = \\frac{2}{3}$。方程为 $y - 0 = \\frac{2}{3}(x-1)$，简化为 $y = \\frac{2}{3}(x-1)$。\n    -   右边连接 $(4,0)$ 和 $(2.5,1)$。斜率为 $m_2 = \\frac{1-0}{2.5-4} = \\frac{1}{-1.5} = -\\frac{2}{3}$。方程为 $y - 0 = -\\frac{2}{3}(x-4)$，简化为 $y = -\\frac{2}{3}(x-4)$。\n\n    **$\\mathcal{S}_1 \\cap \\mathcal{T}$ 的面积**：\n    这是三角形 $\\mathcal{T}$ 位于区域 $x \\le 2$ 内的部分的面积。由于三角形从 $x=1$ 开始，这对应于三角形在 $1 \\le x \\le 2$ 范围内的区域。在此 $x$ 范围内，三角形的上边界是其左边，$y = \\frac{2}{3}(x-1)$。\n    相交区域 $\\mathcal{S}_1 \\cap \\mathcal{T}$ 是一个由 $x=1$、$x=2$、$y=0$ 和 $y = \\frac{2}{3}(x-1)$ 界定的多边形。其顶点是 $(1,0)$、$(2,0)$ 以及在 $x=2$ 处位于左边上的点。该点的 $y$ 坐标是 $y = \\frac{2}{3}(2-1) = \\frac{2}{3}$。所以第三个顶点是 $(2, 2/3)$。\n    这个形状是一个直角三角形，底边长为 $2-1=1$，高为 $2/3$。\n    其面积为：\n    $$A_{\\mathcal{S}_1 \\cap \\mathcal{T}} = \\frac{1}{2} \\times 1 \\times \\frac{2}{3} = \\frac{1}{3} \\, \\mathrm{m^2}$$\n\n    **$\\mathcal{S}_2 \\cap \\mathcal{T}$ 的面积**：\n    这是三角形的剩余部分面积，其中 $x \\ge 2$。由于源单元不重叠且它们的并集包含目标单元，因此相交面积之和必须等于目标单元的总面积。\n    $$A_{\\mathcal{S}_1 \\cap \\mathcal{T}} + A_{\\mathcal{S}_2 \\cap \\mathcal{T}} = A_{\\mathcal{T}}$$\n    因此，我们可以通过减法求出 $A_{\\mathcal{S}_2 \\cap \\mathcal{T}}$：\n    $$A_{\\mathcal{S}_2 \\cap \\mathcal{T}} = A_{\\mathcal{T}} - A_{\\mathcal{S}_1 \\cap \\mathcal{T}} = \\frac{3}{2} - \\frac{1}{3} = \\frac{9}{6} - \\frac{2}{6} = \\frac{7}{6} \\, \\mathrm{m^2}$$\n\n3.  **计算目标单元平均密度 $q_{\\mathcal{T}}$**。\n    我们现在有了所有必要的组成部分。源密度为 $q_1 = 2 \\, \\mathrm{mg/m^2}$ 和 $q_2 = 8 \\, \\mathrm{mg/m^2}$。\n    将这些值代入守恒方程：\n    $$q_{\\mathcal{T}} = \\frac{q_1 A_{\\mathcal{S}_1 \\cap \\mathcal{T}} + q_2 A_{\\mathcal{S}_2 \\cap \\mathcal{T}}}{A_{\\mathcal{T}}} = \\frac{(2) \\left(\\frac{1}{3}\\right) + (8) \\left(\\frac{7}{6}\\right)}{\\frac{3}{2}}$$\n    现在，我们简化表达式：\n    $$q_{\\mathcal{T}} = \\frac{\\frac{2}{3} + \\frac{56}{6}}{\\frac{3}{2}} = \\frac{\\frac{4}{6} + \\frac{56}{6}}{\\frac{3}{2}} = \\frac{\\frac{60}{6}}{\\frac{3}{2}} = \\frac{10}{\\frac{3}{2}}$$\n    $$q_{\\mathcal{T}} = 10 \\times \\frac{2}{3} = \\frac{20}{3}$$\n    单位是 $\\mathrm{mg/m^2}$。目标单元平均密度的精确值是 $\\frac{20}{3} \\, \\mathrm{mg/m^2}$。",
            "answer": "$$\\boxed{\\frac{20}{3}}$$"
        },
        {
            "introduction": "在实际的计算应用中，守恒重映射依赖于复杂的几何算法来精确计算网格间的重叠。为了确保这些几何计算的正确性，我们引入一种标准的验证测试，即“精确解检验”。此练习要求将一个常数场和一个线性场在两个随机扰动的网格之间进行重映射，并通过检验这些场是否能被精确重现（在机器精度范围内），来诊断几何计算（如多边形裁剪和矩的计算）中可能存在的错误。",
            "id": "3958224",
            "problem": "实现一个程序，该程序在单位正方形域 $[0,1] \\times [0,1]$ 上构建两个独立随机扰动的逻辑矩形网格，通过精确重叠积分将两个解析场（一个常数场和一个线性场）从源网格严格保守地重映到目标网格，并报告与精确值的偏差。其目标是通过测量在使用一致的几何重叠积分计算时，常数场和线性场是否能被保守重映精确再现，从而诊断几何误差。\n\n使用以下基本原理：\n- 标量密度场的守恒要求，场在任何目标控制体上的积分等于其与源控制体交集上的积分之和，该和遍及所有交集。如果一个标量场是 $f(x,y)$，一个目标单元是一个多边形区域 $\\Omega_t$，那么目标单元的平均值为 $\\bar{f}_t = \\frac{1}{|\\Omega_t|} \\int_{\\Omega_t} f(x,y)\\,\\mathrm{d}A$，其中 $|\\Omega_t|$ 是 $\\Omega_t$ 的面积。从源网格到目标网格的保守重映必须满足 $\\int_{\\Omega_t} f(x,y)\\,\\mathrm{d}A = \\sum_{s} \\int_{\\Omega_t \\cap \\Omega_s} f(x,y)\\,\\mathrm{d}A$，其中求和遍及所有与 $\\Omega_t$ 的交集非空的源单元 $\\Omega_s$。\n- 对于多边形区域，重叠区域也是多边形。对于任何多边形区域 $\\Omega$，常数场 $f(x,y)=c$ 的积分为 $c \\, |\\Omega|$，线性场 $f(x,y)=\\alpha x + \\beta y + \\gamma$ 的积分为 $\\alpha \\int_{\\Omega} x \\,\\mathrm{d}A + \\beta \\int_{\\Omega} y \\,\\mathrm{d}A + \\gamma \\, |\\Omega|$。要精确计算这些积分，需要多边形的面积和一阶矩，这些都可以通过格林定理无近似地推导出来。\n- 在计算聚变科学与工程中，网格间的保守重映用于极向截面和环向投影上的诊断和多物理场求解器的耦合，而常数场和线性场的精确性检验被广泛用于检测网格重叠计算中的几何不一致性。\n\n网格构建协议：\n- 令 $N \\in \\mathbb{Z}$ 且 $N \\ge 2$ 为一个覆盖 $[0,1]\\times[0,1]$ 的逻辑矩形网格在每个方向上的单元数。未扰动节点的坐标为 $(i/N,j/N)$，其中整数 $i,j \\in \\{0,1,\\dots,N\\}$。\n- 令 $\\varepsilon \\in \\mathbb{R}$ 为一个非负的扰动幅度，解释为局部网格间距的一部分。仅对内部节点进行扰动，方法是在两个坐标方向上都加上区间 $[-\\varepsilon/N,\\varepsilon/N]$ 内的独立均匀随机位移。保持域边界上的边界节点不变，以维持 $[0,1]\\times[0,1]$ 的范围。\n- 使用两个独立的随机种子，通过上述扰动协议生成一个源网格和一个目标网格。\n\n重叠与积分协议：\n- 将每个网格单元视为一个由其四个角点按逆时针顺序给出的简单四边形多边形。假设 $\\varepsilon$ 足够小，以至于所有单元都保持为简单（非自交）多边形。\n- 对于每个目标单元多边形 $\\Omega_t$，使用鲁棒的多边形凸裁剪算法，计算其与每个源单元多边形 $\\Omega_s$ 的精确交集多边形。利用从格林定理推导出的公式，根据交集多边形的顶点精确计算面积 $|\\Omega_t \\cap \\Omega_s|$ 和一阶矩 $\\int_{\\Omega_t \\cap \\Omega_s} x \\,\\mathrm{d}A$ 及 $\\int_{\\Omega_t \\cap \\Omega_s} y \\,\\mathrm{d}A$。\n- 保守重映通过在每个重叠区域 $\\Omega_t \\cap \\Omega_s$ 上精确积分解析场，并将结果除以 $|\\Omega_t|$ 进行归一化，从而将场值从源传递到目标。\n\n待测试的场：\n- 一个常数场 $f_c(x,y) = c$，其中 $c = 0.731$。\n- 一个线性场 $f_\\ell(x,y) = \\alpha x + \\beta y + \\gamma$，其中 $\\alpha = 0.83$，$\\beta = -0.27$，$\\gamma = 0.19$。\n\n误差度量：\n- 对于常数场，对每个目标单元 $\\Omega_t$，计算重映后的平均值 $\\bar{f}_{t,c}$ 并与 $\\Omega_t$ 上的精确平均值（即 $c$）进行比较。记录所有目标单元上的最大绝对偏差 $E_c = \\max_{\\Omega_t} |\\bar{f}_{t,c} - c|$。\n- 对于线性场，对每个目标单元 $\\Omega_t$，计算重映后的平均值 $\\bar{f}_{t,\\ell}$ 并与从目标多边形的一阶矩计算出的精确平均值 $\\bar{f}_{t,\\ell}^{\\mathrm{exact}} = \\frac{1}{|\\Omega_t|}\\left(\\alpha \\int_{\\Omega_t} x \\,\\mathrm{d}A + \\beta \\int_{\\Omega_t} y \\,\\mathrm{d}A + \\gamma |\\Omega_t|\\right)$ 进行比较。记录所有目标单元上的最大绝对偏差 $E_\\ell = \\max_{\\Omega_t} |\\bar{f}_{t,\\ell} - \\bar{f}_{t,\\ell}^{\\mathrm{exact}}|$。\n\n测试套件：\n- 源网格使用四组参数集 $(N,\\varepsilon,\\text{seed})$，目标网格的种子设为 $\\text{seed}+1$：\n    1. $(N,\\varepsilon,\\text{seed}) = (4, 0.0, 7)$。\n    2. $(N,\\varepsilon,\\text{seed}) = (8, 0.1, 42)$。\n    3. $(N,\\varepsilon,\\text{seed}) = (12, 0.2, 11)$。\n    4. $(N,\\varepsilon,\\text{seed}) = (6, 0.15, 99)$。\n- 对每个参数集，构建两个网格并计算如上定义的 $(E_c, E_\\ell)$。\n\n最终输出格式：\n- 你的程序应生成一行输出，其中包含八个浮点数结果，格式为用方括号括起来的逗号分隔列表，顺序为 $[E_{c,1},E_{\\ell,1},E_{c,2},E_{\\ell,2},E_{c,3},E_{\\ell,3},E_{c,4},E_{\\ell,4}]$，其中下标表示测试用例编号。每个数字必须格式化为具有十二位有效数字的科学记数法（例如，$1.23456789012\\mathrm{e}{-06}$）。\n- 不允许用户输入或外部文件。程序必须完全基于提供的种子确定性地运行。",
            "solution": "我们需要一个保守重映测试，通过检查在对网格重叠区域进行解析积分时，常数场和线性场的精确性来检测几何误差。其原理是，保守重映保持单元积分不变，对于至多是线性的场，其精确性完全取决于重叠多边形的精确几何（面积和一阶矩）。\n\n从守恒和精确积分开始。令 $\\Omega_s$ 表示一个源单元多边形，$\\Omega_t$ 表示一个目标单元多边形，$f(x,y)$ 表示一个标量场。一个保守重映满足\n$$\n\\int_{\\Omega_t} f(x,y)\\,\\mathrm{d}A = \\sum_{s} \\int_{\\Omega_t \\cap \\Omega_s} f(x,y)\\,\\mathrm{d}A,\n$$\n因此，重映后的目标单元平均值为\n$$\n\\bar{f}_t = \\frac{1}{|\\Omega_t|} \\sum_{s} \\int_{\\Omega_t \\cap \\Omega_s} f(x,y)\\,\\mathrm{d}A.\n$$\n这个恒等式仅使用了目标单元积分可被其与源单元的不相交重叠区域所划分这一性质，这也是保守重映的定义属性。\n\n为了诊断几何误差，我们选择那些在多边形上的积分可以以闭式解计算的场。对于常数场 $f_c(x,y) = c$，\n$$\n\\int_{\\Omega} f_c \\,\\mathrm{d}A = c \\int_{\\Omega} 1 \\,\\mathrm{d}A = c \\, |\\Omega|,\n$$\n所以精确的重映目标平均值为 $\\bar{f}_{t,c} = c$。任何偏差都必须源于几何不一致性，例如不正确的重叠面积计算或数值裁剪误差。\n\n对于线性场 $f_\\ell(x,y) = \\alpha x + \\beta y + \\gamma$，利用积分的线性性质：\n$$\n\\int_{\\Omega} f_\\ell \\,\\mathrm{d}A = \\alpha \\int_{\\Omega} x \\,\\mathrm{d}A + \\beta \\int_{\\Omega} y \\,\\mathrm{d}A + \\gamma \\int_{\\Omega} 1 \\,\\mathrm{d}A = \\alpha M_x(\\Omega) + \\beta M_y(\\Omega) + \\gamma |\\Omega|,\n$$\n其中 $M_x(\\Omega) = \\int_{\\Omega} x \\,\\mathrm{d}A$ 和 $M_y(\\Omega) = \\int_{\\Omega} y \\,\\mathrm{d}A$ 是一阶矩。对于目标单元 $\\Omega_t$，\n$$\n\\bar{f}^{\\mathrm{exact}}_{t,\\ell} = \\frac{\\alpha M_x(\\Omega_t) + \\beta M_y(\\Omega_t) + \\gamma |\\Omega_t|}{|\\Omega_t|}.\n$$\n因此，如果重叠多边形及其一阶矩被精确计算，并且对重叠区域的求和能够恢复 $\\int_{\\Omega_t} f_\\ell \\,\\mathrm{d}A$，那么该重映也精确地保持了线性。与精确值的偏差则表明存在几何误差，如不精确的裁剪、方向错误或数值累积问题。\n\n我们现在从格林定理推导所需的多边形面积和一阶矩公式。设一个简单多边形 $\\Omega$ 的顶点为 $(x_i,y_i)$，其中索引 $i=0,1,\\dots,n-1$ 按逆时针顺序排列，且 $(x_n,y_n)\\equiv (x_0,y_0)$。格林定理对光滑函数 $P(x,y)$ 和 $Q(x,y)$ 表述为：\n$$\n\\int_{\\Omega} \\left(\\frac{\\partial Q}{\\partial x} - \\frac{\\partial P}{\\partial y}\\right) \\,\\mathrm{d}A = \\oint_{\\partial \\Omega} \\left(P \\,\\mathrm{d}x + Q \\,\\mathrm{d}y\\right).\n$$\n选择 $(P,Q)=(0,\\tfrac{1}{2} x)$ 可得\n$$\n\\int_{\\Omega} \\frac{\\partial Q}{\\partial x} \\,\\mathrm{d}A = \\int_{\\Omega} \\frac{1}{2} \\,\\mathrm{d}A = \\oint_{\\partial \\Omega} Q \\,\\mathrm{d}y = \\frac{1}{2}\\oint_{\\partial \\Omega} x \\,\\mathrm{d}y,\n$$\n这导出了经典的面积鞋带公式：\n$$\n|\\Omega| = \\frac{1}{2}\\sum_{i=0}^{n-1} (x_i y_{i+1} - x_{i+1} y_i).\n$$\n类似地，选择 $(P,Q)=(-\\tfrac{1}{2} x^2,0)$ 来求 $\\int x\\,\\mathrm{d}A$：\n$$\n\\int_{\\Omega} -\\frac{\\partial P}{\\partial y} \\,\\mathrm{d}A = \\int_{\\Omega} 0 \\,\\mathrm{d}A = \\oint_{\\partial \\Omega} P \\,\\mathrm{d}x = -\\frac{1}{2}\\oint_{\\partial \\Omega} x^2 \\,\\mathrm{d}x,\n$$\n当沿多边形边缘离散化时，得到一阶矩公式\n$$\nM_x(\\Omega) = \\int_{\\Omega} x \\,\\mathrm{d}A = \\frac{1}{6} \\sum_{i=0}^{n-1} (x_i + x_{i+1})(x_i y_{i+1} - x_{i+1} y_i).\n$$\n一个对称的选择得到\n$$\nM_y(\\Omega) = \\int_{\\Omega} y \\,\\mathrm{d}A = \\frac{1}{6} \\sum_{i=0}^{n-1} (y_i + y_{i+1})(x_i y_{i+1} - x_{i+1} y_i).\n$$\n这些恒等式对简单多边形成立，并在浮点数运算中给出精确到舍入误差的面积和一阶矩。\n\n为了计算重叠多边形，我们使用 Sutherland–Hodgman 多边形裁剪算法，该算法迭代地用凸裁剪多边形的每条边所定义的半平面来裁剪主题多边形。该算法保持裁剪区域的凸性，并产生一个（可能为非凸的）主题多边形与一个凸裁剪多边形的精确交集多边形。在我们的设置中，由于扰动很小，网格单元保持为凸四边形。对于从点 $\\mathbf{p}$ 到点 $\\mathbf{q}$ 的每条裁剪边，如果一个点 $\\mathbf{x}$ 位于有向边的左侧，即 $(\\mathbf{q}-\\mathbf{p}) \\times (\\mathbf{x}-\\mathbf{p}) \\ge 0$，则该点在内部，其中二维叉积为 $(a_x,a_y)\\times(b_x,b_y)=a_x b_y - a_y b_x$。主题边与裁剪边的交点通过求解两条线的交点来计算，使用叉积形式。通过在内部测试中使用一个小的容差 $\\delta > 0$ 可以提高对浮点误差的鲁棒性。\n\n算法步骤如下：\n1. 构建源网格和目标网格，作为 $N \\times N$ 单元的扰动结构化网格。将边界节点固定在 $x=0$、$x=1$、$y=0$、$y=1$ 处，并对内部节点施加在 $[-\\varepsilon/N,\\varepsilon/N]$ 区间内的独立均匀位移。\n2. 确保每个单元多边形按逆时针方向定向。预先计算边界框，以快速拒绝不重叠的单元对。\n3. 对每个目标单元多边形，遍历其边界框与之重叠的源单元。对每一对这样的单元，使用 Sutherland–Hodgman 算法，用目标多边形裁剪源多边形，计算交集多边形。对于得到的交集多边形，通过上述多边形矩公式计算 $|\\Omega_t \\cap \\Omega_s|$、$M_x(\\Omega_t \\cap \\Omega_s)$ 和 $M_y(\\Omega_t \\cap \\Omega_s)$。\n4. 对于常数场 $f_c(x,y)=c$，累加 $\\sum_s c \\, |\\Omega_t \\cap \\Omega_s|$，除以 $|\\Omega_t|$，并与 $c$ 比较。\n5. 对于线性场 $f_\\ell(x,y)=\\alpha x + \\beta y + \\gamma$，累加 $\\sum_s \\left(\\alpha M_x(\\Omega_t \\cap \\Omega_s) + \\beta M_y(\\Omega_t \\cap \\Omega_s) + \\gamma |\\Omega_t \\cap \\Omega_s|\\right)$，除以 $|\\Omega_t|$，并与从目标单元多边形矩得到的精确目标平均值 $\\frac{\\alpha M_x(\\Omega_t) + \\beta M_y(\\Omega_t) + \\gamma |\\Omega_t|}{|\\Omega_t|}$ 进行比较。\n6. 记录所有目标单元上的最大值 $E_c$ 和 $E_\\ell$。\n7. 对每个测试用例，使用指定的 $(N,\\varepsilon,\\text{seed})$ 构建源网格，并使用 $\\text{seed}+1$ 作为目标网格的种子，重复以上步骤。\n\n预期行为：当重叠几何被一致地计算时，常数场应能再现到浮点舍入误差范围内，使得 $E_c$ 达到机器精度的量级。如果一阶矩是从交集多边形精确计算的，线性场也应能再现到舍入误差范围内。任何显著的偏差都表明在多边形裁剪或矩计算中存在几何误差。\n\n最终程序实现了这些步骤，并打印出一行列表 $[E_{c,1},E_{\\ell,1},E_{c,2},E_{\\ell,2},E_{c,3},E_{\\ell,3},E_{c,4},E_{\\ell,4}]$，采用具有十二位有效数字的科学记数法，对应于四个指定的测试用例。",
            "answer": "```python\nimport numpy as np\n\n# Conservative remapping test between randomly perturbed meshes\n# Environment: Python 3.12, numpy 1.23.5\n\ndef polygon_area_moments(poly):\n    \"\"\"\n    Compute area and first moments \\int x dA, \\int y dA for a simple polygon.\n    poly: array of shape (m,2) with vertices in order (preferably CCW).\n    Returns (area, Mx, My) with area >= 0.\n    \"\"\"\n    x = poly[:, 0]\n    y = poly[:, 1]\n    n = len(poly)\n    # roll for next vertex\n    x1 = np.roll(x, -1)\n    y1 = np.roll(y, -1)\n    cross = x * y1 - x1 * y\n    area2 = np.sum(cross)  # 2 * signed area\n    Mx6 = np.sum((x + x1) * cross)\n    My6 = np.sum((y + y1) * cross)\n    area = 0.5 * area2\n    Mx = Mx6 / 6.0\n    My = My6 / 6.0\n    # Ensure positive area and corresponding moments\n    if area  0:\n        area = -area\n        Mx = -Mx\n        My = -My\n    return area, Mx, My\n\ndef polygon_signed_area(poly):\n    x = poly[:, 0]\n    y = poly[:, 1]\n    x1 = np.roll(x, -1)\n    y1 = np.roll(y, -1)\n    return 0.5 * np.sum(x * y1 - x1 * y)\n\ndef ensure_ccw(poly):\n    if polygon_signed_area(poly)  0:\n        return poly[::-1].copy()\n    return poly\n\ndef suther_hodgman_clip(subject, clip):\n    \"\"\"\n    Clip polygon 'subject' by convex polygon 'clip' (both CCW).\n    Returns intersection polygon as list of points (numpy array shape (k,2)).\n    \"\"\"\n    def is_inside(p, a, b):\n        # Left of directed edge a->b\n        return (b[0]-a[0])*(p[1]-a[1]) - (b[1]-a[1])*(p[0]-a[0]) >= -1e-14\n\n    def line_intersection(p, r, q, s):\n        # Solve p + t r and q + u s intersection; return p + t r\n        # r = e - s for subject edge; s = b - a for clip edge\n        rxs = r[0]*s[1] - r[1]*s[0]\n        qp = p - q\n        qpxs = qp[0]*s[1] - qp[1]*s[0]\n        if abs(rxs)  1e-18:\n            # Parallel or nearly so; return midpoint as fallback (should be rare)\n            return (p + (p + r)) * 0.5\n        t = (-qpxs) / rxs\n        return p + t * r\n\n    output = subject.copy()\n    m = len(clip)\n    if len(output) == 0:\n        return output\n    for i in range(m):\n        a = clip[i]\n        b = clip[(i+1) % m]\n        input_list = output\n        output = []\n        if len(input_list) == 0:\n            break\n        s = input_list[-1]\n        for e in input_list:\n            s_inside = is_inside(s, a, b)\n            e_inside = is_inside(e, a, b)\n            if e_inside:\n                if not s_inside:\n                    # compute intersection of segment s->e with line a->b\n                    inter = line_intersection(s, e - s, a, b - a)\n                    output.append(inter)\n                output.append(e)\n            else:\n                if s_inside:\n                    inter = line_intersection(s, e - s, a, b - a)\n                    output.append(inter)\n            s = e\n        if len(output) == 0:\n            break\n        output = np.array(output, dtype=float)\n    return output\n\ndef bbox(poly):\n    x = poly[:, 0]\n    y = poly[:, 1]\n    return (np.min(x), np.max(x), np.min(y), np.max(y))\n\ndef bbox_overlap(b1, b2):\n    return not (b1[1]  b2[0] or b2[1]  b1[0] or b1[3]  b2[2] or b2[3]  b1[2])\n\ndef build_mesh(N, eps, seed):\n    \"\"\"\n    Build a perturbed logically rectangular mesh over [0,1]^2.\n    N: number of cells per direction.\n    eps: perturbation magnitude as a fraction of 1/N.\n    seed: RNG seed.\n    Returns list of cell polygons (numpy arrays) and list of bounding boxes.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    # Base grid nodes\n    coords = np.zeros((N+1, N+1, 2), dtype=float)\n    xs = np.linspace(0.0, 1.0, N+1)\n    ys = np.linspace(0.0, 1.0, N+1)\n    for i in range(N+1):\n        for j in range(N+1):\n            coords[i, j, 0] = xs[i]\n            coords[i, j, 1] = ys[j]\n    # Perturb interior nodes\n    if eps > 0.0:\n        # Displacements scaled by 1/N\n        scale = eps / N\n        disp = rng.uniform(-scale, scale, size=(N-1, N-1, 2))\n        coords[1:N, 1:N, :] += disp\n    # Build cell polygons in CCW order\n    polys = []\n    bboxes = []\n    for i in range(N):\n        for j in range(N):\n            v00 = coords[i, j]\n            v10 = coords[i+1, j]\n            v11 = coords[i+1, j+1]\n            v01 = coords[i, j+1]\n            poly = np.array([v00, v10, v11, v01], dtype=float)\n            poly = ensure_ccw(poly)\n            polys.append(poly)\n            bboxes.append(bbox(poly))\n    return polys, bboxes\n\ndef conservative_remap_errors(N, eps, seed, c=0.731, alpha=0.83, beta=-0.27, gamma=0.19):\n    # Build source and target meshes with independent seeds\n    src_polys, src_bboxes = build_mesh(N, eps, seed)\n    tgt_polys, tgt_bboxes = build_mesh(N, eps, seed + 1)\n    # Precompute target areas and moments\n    tgt_geom = []\n    for poly in tgt_polys:\n        A_t, Mx_t, My_t = polygon_area_moments(poly)\n        tgt_geom.append((A_t, Mx_t, My_t))\n    # Loop over target cells\n    E_const = 0.0\n    E_linear = 0.0\n    n_cells = len(tgt_polys)\n    for t_idx in range(n_cells):\n        tpoly = tgt_polys[t_idx]\n        Abox = tgt_bboxes[t_idx]\n        At, Mxt, Myt = tgt_geom[t_idx]\n        # Exact target averages\n        exact_const = c\n        exact_linear = (alpha * Mxt + beta * Myt + gamma * At) / At\n        # Accumulate overlap integrals\n        sum_const = 0.0\n        sum_linear = 0.0\n        for s_idx in range(len(src_polys)):\n            if not bbox_overlap(Abox, src_bboxes[s_idx]):\n                continue\n            spoly = src_polys[s_idx]\n            # Intersection of source and target polygon\n            inter = suther_hodgman_clip(spoly, tpoly)\n            if inter is None or len(inter)  3:\n                continue\n            Aint, Mxint, Myint = polygon_area_moments(inter)\n            if Aint == 0.0:\n                continue\n            # Integrals over intersection\n            sum_const += c * Aint\n            sum_linear += alpha * Mxint + beta * Myint + gamma * Aint\n        # Remapped averages\n        remap_const = sum_const / At\n        remap_linear = sum_linear / At\n        # Errors\n        E_const = max(E_const, abs(remap_const - exact_const))\n        E_linear = max(E_linear, abs(remap_linear - exact_linear))\n    return E_const, E_linear\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (N, eps, seed)\n    test_cases = [\n        (4, 0.0, 7),\n        (8, 0.1, 42),\n        (12, 0.2, 11),\n        (6, 0.15, 99),\n    ]\n    results = []\n    for (N, eps, seed) in test_cases:\n        Ec, El = conservative_remap_errors(N, eps, seed)\n        results.append(Ec)\n        results.append(El)\n    # Format with scientific notation with twelve significant digits\n    formatted = \",\".join(f\"{x:.12e}\" for x in results)\n    print(f\"[{formatted}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "即使几何计算完美无瑕，有限精度的浮点运算仍会引入数值误差，这为验证全局守恒性带来了挑战。本练习  旨在解决一个关键问题：如何区分真实的守恒律破坏与预期的计算噪声。我们将通过浮点误差分析推导出一个合理的容差，并设计一个算法来判断全局守恒残差是否在该容差范围内，从而学习一种严谨的数值验证方法。",
            "id": "3958266",
            "problem": "在计算聚变科学与工程中，标量场（例如，极向平均能量密度）通常会从源网格重映射到目标网格。如果标量场在整个域上的总积分保持不变，则该重映射是守恒的。基于离散网格的积分由单元度量和单元平均值表示。设源网格的单元索引为 $i$，其度量为 $\\lvert S_i \\rvert$，单元平均值为 $\\bar{u}_i$；目标网格的单元索引为 $j$，其度量为 $\\lvert T_j \\rvert$，单元平均值为 $\\bar{u}_j$。守恒要求\n$$\n\\sum_{j} \\lvert T_j \\rvert \\, \\bar{u}_j = \\sum_{i} \\lvert S_i \\rvert \\, \\bar{u}_i.\n$$\n在浮点运算中，检测到的不守恒必须根据该运算的舍入特性来解释。定义残差\n$$\nR = \\sum_{j} \\lvert T_j \\rvert \\, \\bar{u}_j - \\sum_{i} \\lvert S_i \\rvert \\, \\bar{u}_i.\n$$\n目标是构建一个测试：如果 $\\lvert R \\rvert$ 受一个基于标准浮点误差分析推导出的有原则的容差限制，则宣布守恒成立；否则宣布不守恒。\n\n使用以下基础：\n- 守恒的定义：如上所述，重映射前后积分相等。\n- 浮点运算中广泛接受的舍入模型：在 IEEE-754（电气与电子工程师协会标准 754）binary64 算术中，两个有限实数 $x$ 和 $y$ 之间的任何基本运算 $op$ 返回 $\\mathrm{fl}(op(x,y)) = op(x,y) \\, (1 + \\delta)$，其中 $\\lvert \\delta \\rvert \\le \\epsilon_{\\mathrm{mach}}$，$\\epsilon_{\\mathrm{mach}}$ 是单位舍入误差。\n- 来自后向误差分析的、经过充分检验的求和误差界：对于 $N$ 项之和，计算结果与精确和之间的相对误差由 $\\gamma_N = \\dfrac{N \\, \\epsilon_{\\mathrm{mach}}}{1 - N \\, \\epsilon_{\\mathrm{mach}}}$ 界定，该界应用于量值之和的适当度量。\n\n仅从这些基础出发，推导一个可实现的容差，该容差考虑了 $R$ 中的两个有限和，并设计一个返回布尔值的算法决策规则：如果守恒满足，则返回 $true$；否则返回 $false$。证明推导的每一步，并明确说明您引入的任何安全系数。\n\n编写一个程序：\n- 为每个测试用例计算 $R$。\n- 使用上述原则和明确说明的安全系数计算容差。\n- 如果 $\\lvert R \\rvert$ 小于或等于容差，则返回 $true$；否则返回 $false$。\n\n测试套件：\n- 用例 1（理想路径，恒定场，分区不等但积分相等）：\n  - 源度量：条目 $1.0$, $2.0$, $3.0$, $4.0$。\n  - 源平均值：条目 $10.0$, $10.0$, $10.0$, $10.0$。\n  - 目标度量：条目 $2.0$, $4.0$, $4.0$。\n  - 目标平均值：条目 $10.0$, $10.0$, $10.0$。\n- 用例 2（大动态范围，构造上守恒）：\n  - 源度量：条目 $10^{-6}$, $10^{-4}$, $10^{-2}$, $10^{0}$, $10^{1}$, $10^{2}$, $10^{3}$, $10^{4}$。\n  - 源平均值：条目 $10^{10}$, $10^{8}$, $10^{6}$, $10^{4}$, $10^{3}$, $10^{2}$, $10^{1}$, $10^{0}$。\n  - 目标度量：条目 $0.5$, $1.5$, $2.5$, $4.5$, $8.0$。\n  - 目标平均值：选择一个单一常数值，使得 $\\sum_j \\lvert T_j \\rvert \\bar{u}_j = \\sum_i \\lvert S_i \\rvert \\bar{u}_i$。\n- 用例 3（故意非守恒重映射）：\n  - 与用例 2 相同的源和目标度量。\n  - 目标平均值：用例 2 中的常数增加 $1.0$。\n- 用例 4（近似抵消，带符号量，残差接近舍入误差）：\n  - 源度量：$100$ 个条目，每个都等于 $1.0$。\n  - 源平均值：$100$ 个条目，在 $+1.0$ 和 $-1.0$ 之间交替，以 $+1.0$ 开始。\n  - 目标度量：与源度量相同。\n  - 目标平均值：与源平均值相同，除了最后一个条目是 $-1.0 + 10^{-12}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个用例的结果，格式为方括号内的逗号分隔列表，例如 $\\texttt{[true,false,true,true]}$。使用 Python 布尔字面量 $True$ 和 $False$，由该语言呈现，采用精确的逗号分隔列表格式，无任何附加文本。",
            "solution": "该问题要求推导并实现一个决策规则，用于在两个网格之间重映射标量场时测试数值守恒性。该测试必须基于一个从浮点误差分析原理推导出的容差。\n\n设源网格有 $N_S$ 个单元，其度量为 $\\lvert S_i \\rvert$，单元平均标量值为 $\\bar{u}_i$，其中 $i=1, \\dots, N_S$。源网格上的总积分为 $I_S = \\sum_{i=1}^{N_S} \\lvert S_i \\rvert \\bar{u}_i$。\n设目标网格有 $N_T$ 个单元，其度量为 $\\lvert T_j \\rvert$，单元平均标量值为 $\\bar{u}_j$，其中 $j=1, \\dots, N_T$。目标网格上的总积分为 $I_T = \\sum_{j=1}^{N_T} \\lvert T_j \\rvert \\bar{u}_j$。\n\n精确守恒意味着 $I_S = I_T$。残差定义为 $R = I_T - I_S$。因此，对于精确守恒，有 $R=0$。在浮点运算中，我们计算 $I_S$ 和 $I_T$ 的近似值，分别表示为 $\\hat{I}_S$ 和 $\\hat{I}_T$。计算出的残差为 $\\hat{R} = \\mathrm{fl}(\\hat{I}_T - \\hat{I}_S)$。我们的目标是，在考虑舍入误差影响的情况下，确定计算出的残差的量值 $|\\hat{R}|$ 是否与精确残差 $R=0$ 一致。\n\n我们将推导一个容差 $\\tau$，使得如果 $|\\hat{R}| \\le \\tau$，我们就可以宣布数值上满足守恒。推导过程从所提供的基础出发：基本浮点运算的误差模型和求和的误差界。\n\n每个积分的计算，例如 $I_S = \\sum_{i=1}^{N_S} \\lvert S_i \\rvert \\bar{u}_i$，是乘积之和，等同于点积。对于此类运算，问题提供了来自后向误差分析的标准结果。具体来说，对于 $N$ 个乘积的和，计算和 $\\hat{S}$ 与精确和 $S$ 之间的绝对误差有界：\n$$\n|\\hat{S} - S| \\le \\gamma_N \\sum_{k=1}^N |a_k b_k|\n$$\n其中和的项是 $a_k b_k$，且 $\\gamma_N = \\frac{N \\epsilon_{\\mathrm{mach}}}{1 - N \\epsilon_{\\mathrm{mach}}}$。项 $\\epsilon_{\\mathrm{mach}}$ 表示单位舍入误差，对于 IEEE-754 binary64（双精度）算术，其值为 $2^{-53}$。\n\n将此界应用于我们的源积分和目标积分：\n计算出的源积分 $\\hat{I}_S$ 的误差有界：\n$$\n|\\hat{I}_S - I_S| \\le \\gamma_{N_S} \\sum_{i=1}^{N_S} |\\lvert S_i \\rvert \\bar{u}_i|\n$$\n由于单元度量 $\\lvert S_i \\rvert$ 是非负的，这可以简化为 $|\\hat{I}_S - I_S| \\le \\gamma_{N_S} \\sum_{i=1}^{N_S} \\lvert S_i \\rvert |\\bar{u}_i|$。我们定义源的量值之和为 $M_S = \\sum_{i=1}^{N_S} \\lvert S_i \\rvert |\\bar{u}_i|$。则误差界为 $|\\Delta_S| = |\\hat{I}_S - I_S| \\le \\gamma_{N_S} M_S$。\n\n同样，对于目标积分 $\\hat{I}_T$：\n$$\n|\\hat{I}_T - I_T| \\le \\gamma_{N_T} \\sum_{j=1}^{N_T} |\\lvert T_j \\rvert \\bar{u}_j|\n$$\n定义目标的量值之和为 $M_T = \\sum_{j=1}^{N_T} \\lvert T_j \\rvert |\\bar{u}_j|$，则误差界为 $|\\Delta_T| = |\\hat{I}_T - I_T| \\le \\gamma_{N_T} M_T$。\n\n现在，我们分析计算出的残差 $\\hat{R}$。它是计算出的积分 $\\hat{I}_S$ 和 $\\hat{I}_T$ 进行单次浮点减法的结果：\n$$\n\\hat{R} = \\mathrm{fl}(\\hat{I}_T - \\hat{I}_S) = (\\hat{I}_T - \\hat{I}_S)(1 + \\delta_{sub})\n$$\n其中 $|\\delta_{sub}| \\le \\epsilon_{\\mathrm{mach}}$。\n\n我们假设原假设成立：即精确守恒成立，即 $I_S = I_T$。我们想在此假设下找到 $\\hat{R}$ 的最大期望量值。我们可以用精确积分及其误差来表示计算出的积分：$\\hat{I}_S = I_S + \\Delta_S$ 和 $\\hat{I}_T = I_T + \\Delta_T$。\n将这些代入 $\\hat{R}$ 的表达式中：\n$$\n\\hat{R} = ( (I_T + \\Delta_T) - (I_S + \\Delta_S) )(1 + \\delta_{sub})\n$$\n由于我们假设 $I_S = I_T$，这可以简化为：\n$$\n\\hat{R} = (\\Delta_T - \\Delta_S)(1 + \\delta_{sub})\n$$\n我们可以使用三角不等式来界定 $\\hat{R}$ 的量值：\n$$\n|\\hat{R}| = |\\Delta_T - \\Delta_S| |1 + \\delta_{sub}| \\le (|\\Delta_T| + |\\Delta_S|) (1 + |\\delta_{sub}|)\n$$\n代入 $|\\Delta_S|$、$|\\Delta_T|$ 和 $|\\delta_{sub}|$ 的界：\n$$\n|\\hat{R}| \\le (\\gamma_{N_T} M_T + \\gamma_{N_S} M_S)(1 + \\epsilon_{\\mathrm{mach}})\n$$\n当重映射真正守恒时，这个不等式为计算出的残差的量值提供了一个有原则的上限。我们使用这个界来定义我们的容差 $\\tau$。\n\n然而，来自后向误差分析的误差界是针对最坏情况的。为了创建一个稳健的实用测试，以避免假阴性（错误地将守恒重映射标记为非守恒），引入一个小的安全系数 $F$ 是审慎的。这个系数考虑了模型中的任何近似以及舍入误差的统计性质，因为舍入误差通常不会累加到产生最坏情况的结果。我们选择安全系数 $F=3$，这是一个提供合理余地的小整数值。\n\n因此，最终的容差 $\\tau$ 是：\n$$\n\\tau = F \\cdot (1 + \\epsilon_{\\mathrm{mach}}) \\left( \\gamma_{N_S} M_S + \\gamma_{N_T} M_T \\right)\n$$\n其中 $F=3$，且 $M_S = \\sum_{i=1}^{N_S} \\lvert S_i \\rvert |\\bar{u}_i|$，$M_T = \\sum_{j=1}^{N_T} \\lvert T_j \\rvert |\\bar{u}_j|$，$\\gamma_N = \\frac{N \\epsilon_{\\mathrm{mach}}}{1 - N \\epsilon_{\\mathrm{mach}}}$，以及 $\\epsilon_{\\mathrm{mach}} = 2^{-53}$。\n\n算法决策规则如下：\n1. 计算源积分 $\\hat{I}_S = \\mathrm{fl}(\\sum_i \\lvert S_i \\rvert \\bar{u}_i)$ 和目标积分 $\\hat{I}_T = \\mathrm{fl}(\\sum_j \\lvert T_j \\rvert \\bar{u}_j)$。\n2. 计算残差 $\\hat{R} = \\mathrm{fl}(\\hat{I}_T - \\hat{I}_S)$。\n3. 计算源量值和 $M_S = \\mathrm{fl}(\\sum_i \\lvert S_i \\rvert |\\bar{u}_i|)$ 和目标量值和 $M_T = \\mathrm{fl}(\\sum_j \\lvert T_j \\rvert |\\bar{u}_j|)$。请注意，我们使用计算出的量值和，因为它们是最佳的可用估计。\n4. 使用上面推导的公式计算容差 $\\tau$。\n5. 如果 $|\\hat{R}| \\le \\tau$，测试返回 $true$；否则返回 $false$。这构成了一个严格、合理的数值守恒性测试。",
            "answer": "```python\nimport numpy as np\n\ndef check_conservation(source_measures, source_averages, target_measures, target_averages):\n    \"\"\"\n    Checks if a remapping is conservative within a tolerance derived from floating-point error analysis.\n\n    Args:\n        source_measures (np.ndarray): Array of measures for source cells.\n        source_averages (np.ndarray): Array of scalar averages for source cells.\n        target_measures (np.ndarray): Array of measures for target cells.\n        target_averages (np.ndarray): Array of scalar averages for target cells.\n\n    Returns:\n        bool: True if conservation is satisfied, False otherwise.\n    \"\"\"\n    # 1. Define constants\n    # Unit roundoff for IEEE-754 binary64 (double precision)\n    # np.finfo(float).eps is machine epsilon (2^-52)\n    # Unit roundoff is eps/2 = 2^-53\n    eps_mach = np.finfo(np.float64).eps / 2.0\n    \n    # Safety factor to make the test robust. A value of 3 is a reasonable choice.\n    safety_factor = 3.0\n\n    # 2. Compute source and target integrals\n    # Using np.dot is equivalent to sum(m*u) and is often optimized for accuracy.\n    integral_source = np.dot(source_measures, source_averages)\n    integral_target = np.dot(target_measures, target_averages)\n\n    # 3. Compute the residual\n    residual = integral_target - integral_source\n\n    # 4. Compute the tolerance\n    n_s = len(source_measures)\n    n_t = len(target_measures)\n\n    # Compute sum of magnitudes for source and target terms.\n    # Measures are non-negative, so abs is only needed for averages.\n    mag_sum_source = np.dot(source_measures, np.abs(source_averages))\n    mag_sum_target = np.dot(target_measures, np.abs(target_averages))\n\n    # Compute gamma_N terms from backward error analysis.\n    # gamma_N = (N * eps_mach) / (1 - N * eps_mach)\n    gamma_ns = (n_s * eps_mach) / (1.0 - n_s * eps_mach)\n    gamma_nt = (n_t * eps_mach) / (1.0 - n_t * eps_mach)\n\n    # Calculate the tolerance based on the derived formula\n    # tau = F * (1+eps) * (gamma_Ns*Ms + gamma_Nt*Mt)\n    tolerance = safety_factor * (1.0 + eps_mach) * \\\n                (gamma_ns * mag_sum_source + gamma_nt * mag_sum_target)\n\n    # 5. Perform the check\n    return np.abs(residual) = tolerance\n\ndef solve():\n    \"\"\"\n    Runs the conservation check on the test suite defined in the problem.\n    \"\"\"\n\n    # === Test Case 1: Happy path, constant field ===\n    s_m1 = np.array([1.0, 2.0, 3.0, 4.0])\n    s_u1 = np.array([10.0, 10.0, 10.0, 10.0])\n    t_m1 = np.array([2.0, 4.0, 4.0])\n    t_u1 = np.array([10.0, 10.0, 10.0])\n    # Exact aum_source = 100.0, sum_target = 100.0. Should be conservative.\n    case1 = (s_m1, s_u1, t_m1, t_u1)\n\n    # === Test Case 2: Large dynamic range, conservative by construction ===\n    s_m2 = np.array([1e-6, 1e-4, 1e-2, 1e0, 1e1, 1e2, 1e3, 1e4])\n    s_u2 = np.array([1e10, 1e8, 1e6, 1e4, 1e3, 1e2, 1e1, 1e0])\n    t_m2 = np.array([0.5, 1.5, 2.5, 4.5, 8.0])\n    # Compute target average to make it conservative\n    # sum_source = 8 * 10^4 = 80000\n    # sum_target_measures = 17.0\n    # target_avg = 80000 / 17.0\n    integral_s2 = np.dot(s_m2, s_u2)\n    sum_tm2 = np.sum(t_m2)\n    const_avg_t2 = integral_s2 / sum_tm2\n    t_u2 = np.full_like(t_m2, const_avg_t2)\n    case2 = (s_m2, s_u2, t_m2, t_u2)\n\n    # === Test Case 3: Intentional non-conservative remap ===\n    # Same measures as Case 2\n    s_m3, s_u3, t_m3 = s_m2, s_u2, t_m2\n    # Target average is increased by 1.0, introducing a large residual\n    const_avg_t3 = const_avg_t2 + 1.0\n    t_u3 = np.full_like(t_m3, const_avg_t3)\n    # Exact residual is sum_target_measures * 1.0 = 17.0\n    case3 = (s_m3, s_u3, t_m3, t_u3)\n    \n    # === Test Case 4: Near-cancellation, residual near roundoff ===\n    n_4 = 100\n    s_m4 = np.ones(n_4)\n    s_u4 = np.ones(n_4)\n    s_u4[1::2] = -1.0 # Alternating +1, -1, ..., sum is 0\n    t_m4 = np.copy(s_m4)\n    t_u4 = np.copy(s_u4)\n    t_u4[-1] = -1.0 + 1e-12 # Last entry perturbed\n    # Exact residual is 1e-12. Check if this is within tolerance.\n    case4 = (s_m4, s_u4, t_m4, t_u4)\n    \n    test_cases = [case1, case2, case3, case4]\n\n    results = []\n    for case in test_cases:\n        sm, su, tm, tu = case\n        result = check_conservation(sm, su, tm, tu)\n        results.append(result)\n\n    # Final print statement must match the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}