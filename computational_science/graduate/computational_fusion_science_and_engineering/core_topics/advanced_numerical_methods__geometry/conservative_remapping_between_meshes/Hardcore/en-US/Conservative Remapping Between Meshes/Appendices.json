{
    "hands_on_practices": [
        {
            "introduction": "The bedrock of conservative remapping is the preservation of integral quantities. This first exercise provides a direct, hands-on application of this principle through a \"pencil-and-paper\" calculation. By manually computing the exact intersection areas between simple source and target cells, you will translate the abstract conservation formula into a concrete numerical value, solidifying your understanding of how quantities are partitioned and transferred between meshes .",
            "id": "3958249",
            "problem": "In conservative remapping within computational fusion science and engineering, the goal is to preserve integrals of extensive quantities when transferring data between meshes. Consider a deuterium areal inventory field on a poloidal cross-section, discretized on a source mesh of two rectangular cells and remapped to a single triangular target cell. The remap must be conservative, meaning the integral of the areal inventory over the target should equal the sum of its contributions from overlapping source cells.\n\nAssume the source mesh consists of two axis-aligned rectangular cells in the Cartesian plane with coordinates in meters:\n- Source cell $\\mathcal{S}_1$ with vertices at $(0,0)$, $(2,0)$, $(2,1)$, $(0,1)$ and area $A_{\\mathcal{S}_1}$.\n- Source cell $\\mathcal{S}_2$ with vertices at $(2,0)$, $(5,0)$, $(5,1)$, $(2,1)$ and area $A_{\\mathcal{S}_2}$.\n\nThe target cell $\\mathcal{T}$ is a triangle with vertices at $(1,0)$, $(4,0)$, $(2.5,1)$ and area $A_{\\mathcal{T}}$.\n\nLet the source cell-averaged deuterium areal inventories be uniform within each source cell and given by $q_1 = 2$ $\\mathrm{mg/m^2}$ in $\\mathcal{S}_1$ and $q_2 = 8$ $\\mathrm{mg/m^2}$ in $\\mathcal{S}_2$. The remapping constructs the target cell average $q_{\\mathcal{T}}$ by enforcing exact conservation of the extensive quantity via exact polygon intersection areas between the source cells and the target triangle.\n\nStarting from the fundamental definition of a cell average and the conservation principle, derive and compute the exact value of the target cell average $q_{\\mathcal{T}}$ by:\n- Expressing the conservation of the integral over $\\mathcal{T}$ as a sum over source contributions using exact intersection areas,\n- Computing the exact areas of $\\mathcal{S}_1 \\cap \\mathcal{T}$ and $\\mathcal{S}_2 \\cap \\mathcal{T}$ using the analytic boundary of the triangle,\n- Computing $A_{\\mathcal{T}}$,\n- Combining these to obtain $q_{\\mathcal{T}}$.\n\nExpress your final answer in $\\mathrm{mg/m^2}$. No rounding is required; provide the exact value.",
            "solution": "The problem is valid as it is scientifically grounded in the principles of conservative numerical methods, is well-posed with a unique solution, and is stated objectively with all necessary data. We proceed with the solution.\n\nThe fundamental principle of conservative remapping is the preservation of the integral of an extensive quantity when it is transferred from a source mesh to a target mesh. Let the extensive quantity be the total mass of deuterium, $M$, and its corresponding areal density (inventory) be $q$. The total mass over a region $\\mathcal{A}$ is given by $M = \\int_{\\mathcal{A}} q \\, dA$.\n\nFor a target cell $\\mathcal{T}$, the total mass $M_{\\mathcal{T}}$ is defined in terms of its cell-averaged inventory $q_{\\mathcal{T}}$ and its area $A_{\\mathcal{T}}$ as $M_{\\mathcal{T}} = q_{\\mathcal{T}} A_{\\mathcal{T}}$. The conservation principle dictates that this mass must be equal to the sum of the mass contributions from all source cells $\\mathcal{S}_i$ that overlap with $\\mathcal{T}$. The contribution from a source cell $\\mathcal{S}_i$ is the integral of its inventory field over the intersection area $\\mathcal{S}_i \\cap \\mathcal{T}$.\nThus, we can write the conservation law as:\n$$M_{\\mathcal{T}} = \\sum_i \\int_{\\mathcal{S}_i \\cap \\mathcal{T}} q_i(\\mathbf{x}) \\, dA$$\nwhere $q_i(\\mathbf{x})$ is the inventory field in source cell $\\mathcal{S}_i$.\n\nIn this problem, the source inventories are uniform within each cell, so $q_i(\\mathbf{x}) = q_i$, a constant. The equation simplifies to:\n$$q_{\\mathcal{T}} A_{\\mathcal{T}} = \\sum_i q_i A_{\\mathcal{S}_i \\cap \\mathcal{T}}$$\nwhere $A_{\\mathcal{S}_i \\cap \\mathcal{T}}$ is the area of the intersection between source cell $\\mathcal{S}_i$ and target cell $\\mathcal{T}$.\n\nFor the given problem with two source cells, $\\mathcal{S}_1$ and $\\mathcal{S}_2$, this becomes:\n$$q_{\\mathcal{T}} A_{\\mathcal{T}} = q_1 A_{\\mathcal{S}_1 \\cap \\mathcal{T}} + q_2 A_{\\mathcal{S}_2 \\cap \\mathcal{T}}$$\nThe target cell average $q_{\\mathcal{T}}$ can therefore be computed as:\n$$q_{\\mathcal{T}} = \\frac{q_1 A_{\\mathcal{S}_1 \\cap \\mathcal{T}} + q_2 A_{\\mathcal{S}_2 \\cap \\mathcal{T}}}{A_{\\mathcal{T}}}$$\n\nWe must compute the three areas: $A_{\\mathcal{T}}$, $A_{\\mathcal{S}_1 \\cap \\mathcal{T}}$, and $A_{\\mathcal{S}_2 \\cap \\mathcal{T}}$.\n\n1.  **Compute the area of the target cell, $A_{\\mathcal{T}}$**.\n    The target cell $\\mathcal{T}$ is a triangle with vertices at $(1,0)$, $(4,0)$, and $(2.5,1)$. The base of the triangle lies on the $x$-axis and has a length of $4 - 1 = 3$ meters. The height of the triangle is the $y$-coordinate of the third vertex, which is $1$ meter.\n    The area is given by:\n    $$A_{\\mathcal{T}} = \\frac{1}{2} \\times \\text{base} \\times \\text{height} = \\frac{1}{2} \\times 3 \\times 1 = \\frac{3}{2} \\, \\mathrm{m^2}$$\n\n2.  **Compute the intersection areas**.\n    The source cells are $\\mathcal{S}_1$, the region defined by $0 \\le x \\le 2$ and $0 \\le y \\le 1$, and $\\mathcal{S}_2$, the region defined by $2 \\le x \\le 5$ and $0 \\le y \\le 1$. The boundary between them is the vertical line $x=2$. The target triangle $\\mathcal{T}$ is split into two parts by this line.\n\n    Let's find the equations for the non-horizontal edges of the triangle $\\mathcal{T}$.\n    -   The left edge connects $(1,0)$ and $(2.5,1)$. The slope is $m_1 = \\frac{1-0}{2.5-1} = \\frac{1}{1.5} = \\frac{2}{3}$. The equation is $y - 0 = \\frac{2}{3}(x-1)$, which simplifies to $y = \\frac{2}{3}(x-1)$.\n    -   The right edge connects $(4,0)$ and $(2.5,1)$. The slope is $m_2 = \\frac{1-0}{2.5-4} = \\frac{1}{-1.5} = -\\frac{2}{3}$. The equation is $y - 0 = -\\frac{2}{3}(x-4)$, which simplifies to $y = -\\frac{2}{3}(x-4)$.\n\n    **Area of $\\mathcal{S}_1 \\cap \\mathcal{T}$**:\n    This is the area of the portion of the triangle $\\mathcal{T}$ that lies in the region $x \\le 2$. Since the triangle starts at $x=1$, this corresponds to the region of the triangle for $1 \\le x \\le 2$. In this range of $x$, the top boundary of the triangle is its left edge, $y = \\frac{2}{3}(x-1)$.\n    The intersection region $\\mathcal{S}_1 \\cap \\mathcal{T}$ is a polygon bounded by $x=1$, $x=2$, $y=0$, and $y = \\frac{2}{3}(x-1)$. Its vertices are $(1,0)$, $(2,0)$, and the point on the left edge at $x=2$. The $y$-coordinate of this point is $y = \\frac{2}{3}(2-1) = \\frac{2}{3}$. So the third vertex is $(2, 2/3)$.\n    This shape is a right-angled triangle with a base of length $2-1=1$ and a height of $2/3$.\n    Its area is:\n    $$A_{\\mathcal{S}_1 \\cap \\mathcal{T}} = \\frac{1}{2} \\times 1 \\times \\frac{2}{3} = \\frac{1}{3} \\, \\mathrm{m^2}$$\n\n    **Area of $\\mathcal{S}_2 \\cap \\mathcal{T}$**:\n    This is the area of the remaining portion of the triangle, where $x \\ge 2$. Since the source cells are non-overlapping and their union contains the target cell, the intersection areas must sum to the total area of the target cell.\n    $$A_{\\mathcal{S}_1 \\cap \\mathcal{T}} + A_{\\mathcal{S}_2 \\cap \\mathcal{T}} = A_{\\mathcal{T}}$$\n    Therefore, we can find $A_{\\mathcal{S}_2 \\cap \\mathcal{T}}$ by subtraction:\n    $$A_{\\mathcal{S}_2 \\cap \\mathcal{T}} = A_{\\mathcal{T}} - A_{\\mathcal{S}_1 \\cap \\mathcal{T}} = \\frac{3}{2} - \\frac{1}{3} = \\frac{9}{6} - \\frac{2}{6} = \\frac{7}{6} \\, \\mathrm{m^2}$$\n\n3.  **Compute the target cell average, $q_{\\mathcal{T}}$**.\n    We now have all the necessary components. The source inventories are $q_1 = 2 \\, \\mathrm{mg/m^2}$ and $q_2 = 8 \\, \\mathrm{mg/m^2}$.\n    Substituting the values into the conservation equation:\n    $$q_{\\mathcal{T}} = \\frac{q_1 A_{\\mathcal{S}_1 \\cap \\mathcal{T}} + q_2 A_{\\mathcal{S}_2 \\cap \\mathcal{T}}}{A_{\\mathcal{T}}} = \\frac{(2) \\left(\\frac{1}{3}\\right) + (8) \\left(\\frac{7}{6}\\right)}{\\frac{3}{2}}$$\n    Now, we simplify the expression:\n    $$q_{\\mathcal{T}} = \\frac{\\frac{2}{3} + \\frac{56}{6}}{\\frac{3}{2}} = \\frac{\\frac{4}{6} + \\frac{56}{6}}{\\frac{3}{2}} = \\frac{\\frac{60}{6}}{\\frac{3}{2}} = \\frac{10}{\\frac{3}{2}}$$\n    $$q_{\\mathcal{T}} = 10 \\times \\frac{2}{3} = \\frac{20}{3}$$\n    The units are $\\mathrm{mg/m^2}$. The exact value of the target cell average inventory is $\\frac{20}{3} \\, \\mathrm{mg/m^2}$.",
            "answer": "$$\\boxed{\\frac{20}{3}}$$"
        },
        {
            "introduction": "Moving from analytic calculation to robust implementation requires rigorous verification. This practice addresses a critical aspect of code development: ensuring the correctness of the underlying geometric algorithms. You will implement a standard verification test for remapping schemes by checking if they exactly preserve constant and linear fields . Since any deviation from exactness in this controlled scenario points to errors in the geometric calculations, such as polygon clipping or moment integration, this test is an essential tool for building a reliable remapping library.",
            "id": "3958224",
            "problem": "Implement a program that constructs two independently and randomly perturbed, logically rectangular meshes over the unit square domain $[0,1] \\times [0,1]$, performs strictly conservative remapping of two analytic fields (a constant field and a linear field) from the source mesh to the target mesh via exact overlap integration, and reports deviations from exactness. The goal is to diagnose geometric errors by measuring whether constant and linear fields are exactly reproduced by a conservative remap when geometric overlap integrals are computed consistently.\n\nUse the following fundamental base:\n- Conservation of a scalar density-like field requires that the integral of the field over any target control volume equals the sum over intersections with source control volumes of the integrals over those intersections. If a scalar field is $f(x,y)$ and a target cell is a polygonal region $\\Omega_t$, then the target cell average is $\\bar{f}_t = \\frac{1}{|\\Omega_t|} \\int_{\\Omega_t} f(x,y)\\,\\mathrm{d}A$, where $|\\Omega_t|$ is the area of $\\Omega_t$. A conservative remap from a source mesh to a target mesh must satisfy $\\int_{\\Omega_t} f(x,y)\\,\\mathrm{d}A = \\sum_{s} \\int_{\\Omega_t \\cap \\Omega_s} f(x,y)\\,\\mathrm{d}A$, where the sum is over all source cells $\\Omega_s$ whose intersection with $\\Omega_t$ is nonempty.\n- For polygonal regions, overlap regions are polygonal. For any polygonal region $\\Omega$, the integral of the constant field $f(x,y)=c$ is $c \\, |\\Omega|$, and the integral of the linear field $f(x,y)=\\alpha x + \\beta y + \\gamma$ is $\\alpha \\int_{\\Omega} x \\,\\mathrm{d}A + \\beta \\int_{\\Omega} y \\,\\mathrm{d}A + \\gamma \\, |\\Omega|$. Evaluating these integrals exactly requires polygon area and first moments, which can be derived from Green’s theorem without approximation.\n- Conservative remapping between meshes in computational fusion science and engineering is used for diagnostics and coupling of multi-physics solvers over poloidal cross-sections and toroidal projections, and the exactness tests for constant and linear fields are widely used to detect geometric inconsistencies in the mesh overlap computation.\n\nMesh construction protocol:\n- Let $N \\in \\mathbb{Z}$ with $N \\ge 2$ be the number of cells per direction in a logically rectangular mesh spanning $[0,1]\\times[0,1]$. The unperturbed node coordinates are $(i/N,j/N)$ for integers $i,j \\in \\{0,1,\\dots,N\\}$.\n- Let $\\varepsilon \\in \\mathbb{R}$ be a nonnegative perturbation magnitude, interpreted as a fraction of the local grid spacing. Perturb only interior nodes by adding independent uniform random displacements in both coordinates in the interval $[-\\varepsilon/N,\\varepsilon/N]$. Leave boundary nodes on the domain boundary to maintain $[0,1]\\times[0,1]$.\n- Use two independent random seeds to generate a source mesh and a target mesh by the above perturbation protocol.\n\nOverlap and integration protocol:\n- Treat each mesh cell as a simple quadrilateral polygon given by its four corner nodes in counterclockwise order. Assume $\\varepsilon$ is small enough that all cells remain simple (non-self-intersecting) polygons.\n- For each target cell polygon $\\Omega_t$, form its exact intersection polygon with each source cell polygon $\\Omega_s$ using a robust convex clip of polygons. Compute the area $|\\Omega_t \\cap \\Omega_s|$ and first moments $\\int_{\\Omega_t \\cap \\Omega_s} x \\,\\mathrm{d}A$ and $\\int_{\\Omega_t \\cap \\Omega_s} y \\,\\mathrm{d}A$ exactly from the intersection polygon vertices using formulas derived from Green’s theorem.\n- The conservative remap sends a field value from source to target by integrating the analytic field exactly over each overlap $\\Omega_t \\cap \\Omega_s$ and normalizing by $|\\Omega_t|$.\n\nFields to test:\n- A constant field $f_c(x,y) = c$ with $c = 0.731$.\n- A linear field $f_\\ell(x,y) = \\alpha x + \\beta y + \\gamma$ with $\\alpha = 0.83$, $\\beta = -0.27$, and $\\gamma = 0.19$.\n\nError measures:\n- For the constant field, for each target cell $\\Omega_t$, compute the remapped average $\\bar{f}_{t,c}$ and compare to the exact average over $\\Omega_t$, which equals $c$. Record the maximum absolute deviation over all target cells, $E_c = \\max_{\\Omega_t} |\\bar{f}_{t,c} - c|$.\n- For the linear field, for each target cell $\\Omega_t$, compute the remapped average $\\bar{f}_{t,\\ell}$ and compare to the exact average $\\bar{f}_{t,\\ell}^{\\mathrm{exact}} = \\frac{1}{|\\Omega_t|}\\left(\\alpha \\int_{\\Omega_t} x \\,\\mathrm{d}A + \\beta \\int_{\\Omega_t} y \\,\\mathrm{d}A + \\gamma |\\Omega_t|\\right)$ computed from the target polygon’s first moments. Record the maximum absolute deviation over all target cells, $E_\\ell = \\max_{\\Omega_t} |\\bar{f}_{t,\\ell} - \\bar{f}_{t,\\ell}^{\\mathrm{exact}}|$.\n\nTest suite:\n- Use four parameter sets $(N,\\varepsilon,\\text{seed})$ for the source mesh, and set the target mesh seed to be $\\text{seed}+1$:\n    1. $(N,\\varepsilon,\\text{seed}) = (4, 0.0, 7)$.\n    2. $(N,\\varepsilon,\\text{seed}) = (8, 0.1, 42)$.\n    3. $(N,\\varepsilon,\\text{seed}) = (12, 0.2, 11)$.\n    4. $(N,\\varepsilon,\\text{seed}) = (6, 0.15, 99)$.\n- For each parameter set, build the two meshes and compute $(E_c, E_\\ell)$ as defined above.\n\nFinal output format:\n- Your program should produce a single line of output containing the eight floating-point results as a comma-separated list enclosed in square brackets in the order $[E_{c,1},E_{\\ell,1},E_{c,2},E_{\\ell,2},E_{c,3},E_{\\ell,3},E_{c,4},E_{\\ell,4}]$, where the index indicates the test case number. Each number must be formatted in scientific notation with twelve significant digits (for example, $1.23456789012\\mathrm{e}{-06}$).\n- No user input or external files are allowed. The program must be fully deterministic based on the provided seeds.",
            "solution": "We require a conservative remapping test that detects geometric errors by checking exactness for constant and linear fields when analytically integrated over mesh overlaps. The principle is that conservative remapping preserves cell integrals, and for fields that are at most linear, exactness is determined solely by exact geometry (areas and first moments) of overlap polygons.\n\nStart from conservation and exact integration. Let $\\Omega_s$ denote a source cell polygon, $\\Omega_t$ a target cell polygon, and $f(x,y)$ a scalar field. A conservative remap satisfies\n$$\n\\int_{\\Omega_t} f(x,y)\\,\\mathrm{d}A = \\sum_{s} \\int_{\\Omega_t \\cap \\Omega_s} f(x,y)\\,\\mathrm{d}A,\n$$\nhence the remapped target cell average is\n$$\n\\bar{f}_t = \\frac{1}{|\\Omega_t|} \\sum_{s} \\int_{\\Omega_t \\cap \\Omega_s} f(x,y)\\,\\mathrm{d}A.\n$$\nThis identity uses only partition of the target cell integral by disjoint overlaps with source cells and is the defining property of conservative remapping.\n\nTo diagnose geometric errors, pick fields whose integrals over polygons can be computed in closed form. For constant $f_c(x,y) = c$,\n$$\n\\int_{\\Omega} f_c \\,\\mathrm{d}A = c \\int_{\\Omega} 1 \\,\\mathrm{d}A = c \\, |\\Omega|,\n$$\nso the exact remapped target average is $\\bar{f}_{t,c} = c$. Any deviation must arise from geometric inconsistencies such as incorrect overlap area computation or numerical clipping errors.\n\nFor linear $f_\\ell(x,y) = \\alpha x + \\beta y + \\gamma$, use linearity of the integral:\n$$\n\\int_{\\Omega} f_\\ell \\,\\mathrm{d}A = \\alpha \\int_{\\Omega} x \\,\\mathrm{d}A + \\beta \\int_{\\Omega} y \\,\\mathrm{d}A + \\gamma \\int_{\\Omega} 1 \\,\\mathrm{d}A = \\alpha M_x(\\Omega) + \\beta M_y(\\Omega) + \\gamma |\\Omega|,\n$$\nwhere $M_x(\\Omega) = \\int_{\\Omega} x \\,\\mathrm{d}A$ and $M_y(\\Omega) = \\int_{\\Omega} y \\,\\mathrm{d}A$ are the first moments. For the target cell $\\Omega_t$,\n$$\n\\bar{f}^{\\mathrm{exact}}_{t,\\ell} = \\frac{\\alpha M_x(\\Omega_t) + \\beta M_y(\\Omega_t) + \\gamma |\\Omega_t|}{|\\Omega_t|}.\n$$\nThus, if overlap polygons and their first moments are computed exactly and the sum over overlaps recovers $\\int_{\\Omega_t} f_\\ell \\,\\mathrm{d}A$, then the remap is exactly linearity-preserving as well. Deviations from exactness then indicate geometric errors such as inexact clipping, orientation errors, or numerical accumulation issues.\n\nWe now derive the required polygon area and first-moment formulas from Green’s theorem. Let a simple polygon $\\Omega$ have vertices $(x_i,y_i)$ for indices $i=0,1,\\dots,n-1$ ordered counterclockwise, with $(x_n,y_n)\\equiv (x_0,y_0)$. Green’s theorem states for smooth functions $P(x,y)$ and $Q(x,y)$:\n$$\n\\int_{\\Omega} \\left(\\frac{\\partial Q}{\\partial x} - \\frac{\\partial P}{\\partial y}\\right) \\,\\mathrm{d}A = \\oint_{\\partial \\Omega} \\left(P \\,\\mathrm{d}x + Q \\,\\mathrm{d}y\\right).\n$$\nChoose $(P,Q)=(0,\\tfrac{1}{2} x)$ to obtain\n$$\n\\int_{\\Omega} \\frac{\\partial Q}{\\partial x} \\,\\mathrm{d}A = \\int_{\\Omega} \\frac{1}{2} \\,\\mathrm{d}A = \\oint_{\\partial \\Omega} Q \\,\\mathrm{d}y = \\frac{1}{2}\\oint_{\\partial \\Omega} x \\,\\mathrm{d}y,\n$$\nwhich implies the classical shoelace formula for area:\n$$\n|\\Omega| = \\frac{1}{2}\\sum_{i=0}^{n-1} (x_i y_{i+1} - x_{i+1} y_i).\n$$\nSimilarly, choose $(P,Q)=(-\\tfrac{1}{2} x^2,0)$ to target $\\int x\\,\\mathrm{d}A$:\n$$\n\\int_{\\Omega} -\\frac{\\partial P}{\\partial y} \\,\\mathrm{d}A = \\int_{\\Omega} 0 \\,\\mathrm{d}A = \\oint_{\\partial \\Omega} P \\,\\mathrm{d}x = -\\frac{1}{2}\\oint_{\\partial \\Omega} x^2 \\,\\mathrm{d}x,\n$$\nwhich, when discretized along polygon edges, yields the first-moment formula\n$$\nM_x(\\Omega) = \\int_{\\Omega} x \\,\\mathrm{d}A = \\frac{1}{6} \\sum_{i=0}^{n-1} (x_i + x_{i+1})(x_i y_{i+1} - x_{i+1} y_i).\n$$\nA symmetric choice yields\n$$\nM_y(\\Omega) = \\int_{\\Omega} y \\,\\mathrm{d}A = \\frac{1}{6} \\sum_{i=0}^{n-1} (y_i + y_{i+1})(x_i y_{i+1} - x_{i+1} y_i).\n$$\nThese identities hold for simple polygons and give exact area and first moments in floating-point arithmetic up to round-off.\n\nTo compute overlap polygons, we use Sutherland–Hodgman polygon clipping, which iteratively clips a subject polygon against each half-plane defined by an edge of the convex clip polygon. The algorithm maintains convexity of the clip region and produces the exact intersection polygon of a (possibly nonconvex) subject with a convex clip. In our setting, with small perturbations, mesh cells remain convex quadrilaterals. For each clip edge from point $\\mathbf{p}$ to point $\\mathbf{q}$, a point $\\mathbf{x}$ is inside if it lies to the left of the directed edge, i.e., $(\\mathbf{q}-\\mathbf{p}) \\times (\\mathbf{x}-\\mathbf{p}) \\ge 0$, where the $2$-D cross product is $(a_x,a_y)\\times(b_x,b_y)=a_x b_y - a_y b_x$. Intersections of a subject edge with a clip edge are computed by solving for the intersection of two lines, using the cross-product form. Robustness to floating-point error is improved by a small tolerance $\\delta > 0$ in the inside test.\n\nThe algorithmic steps are:\n1. Construct the source and target meshes as perturbed structured grids of $N \\times N$ cells. Leave boundary nodes fixed at $x=0$, $x=1$, $y=0$, $y=1$, and perturb interior nodes by independent uniform displacements in $[-\\varepsilon/N,\\varepsilon/N]$.\n2. Ensure each cell polygon is oriented counterclockwise. Precompute bounding boxes for quick rejection of non-overlapping cell pairs.\n3. For each target cell polygon, loop over source cells whose bounding boxes overlap. For each such pair, compute the intersection polygon using Sutherland–Hodgman clipping of the source polygon by the target polygon. For the resulting polygon, compute $|\\Omega_t \\cap \\Omega_s|$, $M_x(\\Omega_t \\cap \\Omega_s)$, and $M_y(\\Omega_t \\cap \\Omega_s)$ via the polygon moment formulas above.\n4. For the constant field $f_c(x,y)=c$, accumulate $\\sum_s c \\, |\\Omega_t \\cap \\Omega_s|$, divide by $|\\Omega_t|$, and compare with $c$.\n5. For the linear field $f_\\ell(x,y)=\\alpha x + \\beta y + \\gamma$, accumulate $\\sum_s \\left(\\alpha M_x(\\Omega_t \\cap \\Omega_s) + \\beta M_y(\\Omega_t \\cap \\Omega_s) + \\gamma |\\Omega_t \\cap \\Omega_s|\\right)$, divide by $|\\Omega_t|$, and compare with the exact target average $\\frac{\\alpha M_x(\\Omega_t) + \\beta M_y(\\Omega_t) + \\gamma |\\Omega_t|}{|\\Omega_t|}$ obtained from the target cell polygon moments.\n6. Record the maxima $E_c$ and $E_\\ell$ over all target cells.\n7. Repeat for each test case using the specified $(N,\\varepsilon,\\text{seed})$ for the source mesh and $\\text{seed}+1$ for the target mesh.\n\nExpected behavior: When overlap geometry is computed consistently, the constant field should be reproduced to within floating-point round-off, giving $E_c$ on the order of machine precision. The linear field should also be reproduced to round-off, provided first moments are computed exactly from the intersection polygons. Any significant deviation indicates geometric errors in polygon clipping or moment evaluation.\n\nThe final program implements these steps and prints a single-line list $[E_{c,1},E_{\\ell,1},E_{c,2},E_{\\ell,2},E_{c,3},E_{\\ell,3},E_{c,4},E_{\\ell,4}]$ in scientific notation with twelve significant digits, corresponding to the four prescribed test cases.",
            "answer": "```python\nimport numpy as np\n\n# Conservative remapping test between randomly perturbed meshes\n# Environment: Python 3.12, numpy 1.23.5\n\ndef polygon_area_moments(poly):\n    \"\"\"\n    Compute area and first moments \\int x dA, \\int y dA for a simple polygon.\n    poly: array of shape (m,2) with vertices in order (preferably CCW).\n    Returns (area, Mx, My) with area >= 0.\n    \"\"\"\n    x = poly[:, 0]\n    y = poly[:, 1]\n    n = len(poly)\n    # roll for next vertex\n    x1 = np.roll(x, -1)\n    y1 = np.roll(y, -1)\n    cross = x * y1 - x1 * y\n    area2 = np.sum(cross)  # 2 * signed area\n    Mx6 = np.sum((x + x1) * cross)\n    My6 = np.sum((y + y1) * cross)\n    area = 0.5 * area2\n    Mx = Mx6 / 6.0\n    My = My6 / 6.0\n    # Ensure positive area and corresponding moments\n    if area < 0:\n        area = -area\n        Mx = -Mx\n        My = -My\n    return area, Mx, My\n\ndef polygon_signed_area(poly):\n    x = poly[:, 0]\n    y = poly[:, 1]\n    x1 = np.roll(x, -1)\n    y1 = np.roll(y, -1)\n    return 0.5 * np.sum(x * y1 - x1 * y)\n\ndef ensure_ccw(poly):\n    if polygon_signed_area(poly) < 0:\n        return poly[::-1].copy()\n    return poly\n\ndef suther_hodgman_clip(subject, clip):\n    \"\"\"\n    Clip polygon 'subject' by convex polygon 'clip' (both CCW).\n    Returns intersection polygon as list of points (numpy array shape (k,2)).\n    \"\"\"\n    def is_inside(p, a, b):\n        # Left of directed edge a->b\n        return (b[0]-a[0])*(p[1]-a[1]) - (b[1]-a[1])*(p[0]-a[0]) >= -1e-14\n\n    def line_intersection(p, r, q, s):\n        # Solve p + t r and q + u s intersection; return p + t r\n        # r = e - s for subject edge; s = b - a for clip edge\n        rxs = r[0]*s[1] - r[1]*s[0]\n        qp = p - q\n        qpxs = qp[0]*s[1] - qp[1]*s[0]\n        if abs(rxs) < 1e-18:\n            # Parallel or nearly so; return midpoint as fallback (should be rare)\n            return (p + (p + r)) * 0.5\n        t = (-qpxs) / rxs\n        return p + t * r\n\n    output = subject.copy()\n    m = len(clip)\n    if len(output) == 0:\n        return output\n    for i in range(m):\n        a = clip[i]\n        b = clip[(i+1) % m]\n        input_list = output\n        output = []\n        if len(input_list) == 0:\n            break\n        s = input_list[-1]\n        for e in input_list:\n            s_inside = is_inside(s, a, b)\n            e_inside = is_inside(e, a, b)\n            if e_inside:\n                if not s_inside:\n                    # compute intersection of segment s->e with line a->b\n                    inter = line_intersection(s, e - s, a, b - a)\n                    output.append(inter)\n                output.append(e)\n            else:\n                if s_inside:\n                    inter = line_intersection(s, e - s, a, b - a)\n                    output.append(inter)\n            s = e\n        if len(output) == 0:\n            break\n        output = np.array(output, dtype=float)\n    return output\n\ndef bbox(poly):\n    x = poly[:, 0]\n    y = poly[:, 1]\n    return (np.min(x), np.max(x), np.min(y), np.max(y))\n\ndef bbox_overlap(b1, b2):\n    return not (b1[1] < b2[0] or b2[1] < b1[0] or b1[3] < b2[2] or b2[3] < b1[2])\n\ndef build_mesh(N, eps, seed):\n    \"\"\"\n    Build a perturbed logically rectangular mesh over [0,1]^2.\n    N: number of cells per direction.\n    eps: perturbation magnitude as a fraction of 1/N.\n    seed: RNG seed.\n    Returns list of cell polygons (numpy arrays) and list of bounding boxes.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    # Base grid nodes\n    coords = np.zeros((N+1, N+1, 2), dtype=float)\n    xs = np.linspace(0.0, 1.0, N+1)\n    ys = np.linspace(0.0, 1.0, N+1)\n    for i in range(N+1):\n        for j in range(N+1):\n            coords[i, j, 0] = xs[i]\n            coords[i, j, 1] = ys[j]\n    # Perturb interior nodes\n    if eps > 0.0:\n        # Displacements scaled by 1/N\n        scale = eps / N\n        disp = rng.uniform(-scale, scale, size=(N-1, N-1, 2))\n        coords[1:N, 1:N, :] += disp\n    # Build cell polygons in CCW order\n    polys = []\n    bboxes = []\n    for i in range(N):\n        for j in range(N):\n            v00 = coords[i, j]\n            v10 = coords[i+1, j]\n            v11 = coords[i+1, j+1]\n            v01 = coords[i, j+1]\n            poly = np.array([v00, v10, v11, v01], dtype=float)\n            poly = ensure_ccw(poly)\n            polys.append(poly)\n            bboxes.append(bbox(poly))\n    return polys, bboxes\n\ndef conservative_remap_errors(N, eps, seed, c=0.731, alpha=0.83, beta=-0.27, gamma=0.19):\n    # Build source and target meshes with independent seeds\n    src_polys, src_bboxes = build_mesh(N, eps, seed)\n    tgt_polys, tgt_bboxes = build_mesh(N, eps, seed + 1)\n    # Precompute target areas and moments\n    tgt_geom = []\n    for poly in tgt_polys:\n        A_t, Mx_t, My_t = polygon_area_moments(poly)\n        tgt_geom.append((A_t, Mx_t, My_t))\n    # Loop over target cells\n    E_const = 0.0\n    E_linear = 0.0\n    n_cells = len(tgt_polys)\n    for t_idx in range(n_cells):\n        tpoly = tgt_polys[t_idx]\n        Abox = tgt_bboxes[t_idx]\n        At, Mxt, Myt = tgt_geom[t_idx]\n        # Exact target averages\n        exact_const = c\n        exact_linear = (alpha * Mxt + beta * Myt + gamma * At) / At\n        # Accumulate overlap integrals\n        sum_const = 0.0\n        sum_linear = 0.0\n        for s_idx in range(len(src_polys)):\n            if not bbox_overlap(Abox, src_bboxes[s_idx]):\n                continue\n            spoly = src_polys[s_idx]\n            # Intersection of source and target polygon\n            inter = suther_hodgman_clip(spoly, tpoly)\n            if inter is None or len(inter) < 3:\n                continue\n            Aint, Mxint, Myint = polygon_area_moments(inter)\n            if Aint <= 0.0:\n                continue\n            # Integrals over intersection\n            sum_const += c * Aint\n            sum_linear += alpha * Mxint + beta * Myint + gamma * Aint\n        # Remapped averages\n        remap_const = sum_const / At\n        remap_linear = sum_linear / At\n        # Errors\n        E_const = max(E_const, abs(remap_const - exact_const))\n        E_linear = max(E_linear, abs(remap_linear - exact_linear))\n    return E_const, E_linear\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (N, eps, seed)\n    test_cases = [\n        (4, 0.0, 7),\n        (8, 0.1, 42),\n        (12, 0.2, 11),\n        (6, 0.15, 99),\n    ]\n    results = []\n    for (N, eps, seed) in test_cases:\n        Ec, El = conservative_remap_errors(N, eps, seed)\n        results.append(Ec)\n        results.append(El)\n    # Format with scientific notation with twelve significant digits\n    formatted = \",\".join(f\"{x:.12e}\" for x in results)\n    print(f\"[{formatted}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "With a framework for implementing and verifying geometric operations, we can now tackle more complex, physically-motivated problems. Many applications in fusion and fluid dynamics involve multi-material systems where interfaces must be tracked. This advanced practice introduces Piecewise Linear Interface Calculation (PLIC), a common technique where the remapping process is preceded by a geometric reconstruction step . You will first reconstruct a material interface from volume fraction data and then conservatively remap the resulting material polygon, a task that combines root-finding, geometric clipping, and integral conservation.",
            "id": "3958262",
            "problem": "A two-dimensional conservative remapping procedure is required to transfer a material’s volume fraction from a source mesh to a target mesh. The source mesh consists of rectangular cells, and within each source cell the material interface is reconstructed by a Piecewise Linear Interface Calculation (PLIC). In each source cell, the PLIC interface is a straight line defined by the halfspace $\\{\\mathbf{x} \\in \\mathbb{R}^2 : \\mathbf{n} \\cdot \\mathbf{x} \\le \\alpha\\}$, where $\\mathbf{n} \\in \\mathbb{R}^2$ is a unit normal vector and $\\alpha \\in \\mathbb{R}$ is chosen so that the area of the clipped region inside the source cell matches the prescribed volume fraction in that cell. The remapping is performed by integrating the area of the material sub-polygon inside each source cell over its intersections with the target mesh cells. The goal is to ensure exact conservation of the total material volume (area in two dimensions).\n\nFundamental base:\n- Conservation of mass: the integral of a conserved quantity over any region must equal the sum of its contributions mapped into any partition of that region. In two dimensions, this quantity is the material area.\n- Volume fraction definition: for a source cell $S_i$ with area $A_i$, the material area inside $S_i$ is $f_i A_i$, where $f_i \\in [0,1]$ is the dimensionless fraction.\n- Geometric measure: the area of a convex polygon can be computed from its vertices via Green’s theorem.\n\nDefinitions and requirements:\n1. Source mesh cells $S_i$ are axis-aligned rectangles. For each $S_i$, a unit normal vector $\\mathbf{n}$ and a fraction $f_i$ are given. The PLIC interface is the halfspace boundary $\\mathbf{n} \\cdot \\mathbf{x} = \\alpha_i$ with material region $M_i = S_i \\cap \\{\\mathbf{x}: \\mathbf{n} \\cdot \\mathbf{x} \\le \\alpha_i\\}$, where $\\alpha_i$ must be determined such that $\\text{area}(M_i) = f_i \\, \\text{area}(S_i)$.\n2. Target mesh cells $T_j$ are axis-aligned rectangles covering the same domain as the source mesh. The remapped material area in target cell $T_j$ is $A_j^{\\text{remap}} = \\sum_i \\text{area}(M_i \\cap T_j)$.\n3. Conservation target: $\\sum_j A_j^{\\text{remap}}$ must equal $\\sum_i f_i \\, \\text{area}(S_i)$ within numerical tolerance.\n\nAngles must be specified in radians. All areas are dimensionless.\n\nAlgorithmic tasks to implement:\n- Given a rectangle $S_i$ and unit normal $\\mathbf{n}$, determine $\\alpha_i$ by solving the equation $\\text{area}(S_i \\cap \\{\\mathbf{x} : \\mathbf{n} \\cdot \\mathbf{x} \\le \\alpha_i\\}) = f_i \\, \\text{area}(S_i)$. Use a robust root-finding method (e.g., bisection) exploiting the monotonicity of the area function with respect to $\\alpha_i$ over the interval $[\\min_{\\mathbf{x} \\in S_i} \\mathbf{n}\\cdot \\mathbf{x}, \\max_{\\mathbf{x} \\in S_i} \\mathbf{n}\\cdot \\mathbf{x}]$.\n- Implement convex polygon clipping:\n  - Clip a convex polygon by a halfspace of the form $\\{\\mathbf{x} : \\mathbf{n} \\cdot \\mathbf{x} \\le \\alpha\\}$.\n  - Clip a convex polygon by an axis-aligned rectangle using four halfspace clips.\n- Compute polygon areas using the shoelace formula.\n\nTest suite:\nUse the following three test cases, all on the common domain $[0,2] \\times [0,2]$ with the same source and target meshes.\n\nCommon source mesh $S_i$ (four cells):\n- $S_0 = [0,1] \\times [0,1]$,\n- $S_1 = [1,2] \\times [0,1]$,\n- $S_2 = [0,1] \\times [1,2]$,\n- $S_3 = [1,2] \\times [1,2]$.\nIndexing is row-major: $S_0, S_1$ are the bottom row, $S_2, S_3$ are the top row.\n\nCommon target mesh $T_j$ (four cells), shifted internal lines but covering the same domain:\n- $T_0 = [0.0, 1.2] \\times [0.0, 1.2]$,\n- $T_1 = [1.2, 2.0] \\times [0.0, 1.2]$,\n- $T_2 = [0.0, 1.2] \\times [1.2, 2.0]$,\n- $T_3 = [1.2, 2.0] \\times [1.2, 2.0]$.\n\nCase 1 (general orientation):\n- Unit normal $\\mathbf{n} = (\\cos \\theta, \\sin \\theta)$ with $\\theta = \\pi/6$ (radians).\n- Fractions $f = [0.2, 0.5, 0.7, 0.9]$ in the order $[S_0, S_1, S_2, S_3]$.\n\nCase 2 (axis-aligned and extremes):\n- Unit normal $\\mathbf{n} = (1, 0)$.\n- Fractions $f = [0.0, 0.5, 1.0, 0.25]$ in the same order.\n\nCase 3 (diagonal symmetry):\n- Unit normal $\\mathbf{n} = (\\cos(\\pi/4), \\sin(\\pi/4))$.\n- Fractions $f = [0.5, 0.5, 0.5, 0.5]$.\n\nFor each case, compute the absolute conservation error\n$$\nE = \\left| \\sum_{j=0}^{3} A_j^{\\text{remap}} - \\sum_{i=0}^{3} f_i \\, \\text{area}(S_i) \\right|.\n$$\n\nFinal output format:\nYour program should produce a single line of output containing the three conservation errors, one per test case, as a comma-separated list enclosed in square brackets (e.g., \"[e1,e2,e3]\"). Each entry must be a float.",
            "solution": "The problem requires the implementation and verification of a two-dimensional conservative remapping algorithm. This procedure transfers a scalar quantity, specifically the volume fraction of a material, from a rectilinear source mesh to a rectilinear target mesh. The material distribution within each source cell is represented using a Piecewise Linear Interface Calculation (PLIC), which defines a linear interface separating two materials. The core principle to be upheld is the conservation of the total material area throughout the remapping process.\n\nThe solution is structured as a sequence of algorithmic steps, grounded in principles of computational geometry and numerical analysis.\n\n**1. PLIC Interface Reconstruction**\n\nFor each source cell $S_i$, we are given a unit normal vector $\\mathbf{n} \\in \\mathbb{R}^2$ and a material fraction $f_i \\in [0,1]$. The material is defined to occupy the region $M_i = S_i \\cap \\{\\mathbf{x} : \\mathbf{n} \\cdot \\mathbf{x} \\le \\alpha_i\\}$. The scalar $\\alpha_i$ is an offset that positions the line interface $\\mathbf{n} \\cdot \\mathbf{x} = \\alpha_i$ such that the area of the material region is precisely equal to the prescribed fraction of the cell's area. That is, we must solve for $\\alpha_i$ in the equation:\n$$ \\text{area}(S_i \\cap \\{\\mathbf{x} : \\mathbf{n} \\cdot \\mathbf{x} \\le \\alpha_i\\}) = f_i \\cdot \\text{area}(S_i) $$\nLet's define a function $A(\\alpha) = \\text{area}(S_i \\cap \\{\\mathbf{x} : \\mathbf{n} \\cdot \\mathbf{x} \\le \\alpha\\})$. This function represents the area of the source cell $S_i$ clipped by the half-space defined by $\\mathbf{n}$ and $\\alpha$. The function $A(\\alpha)$ is monotonically increasing with $\\alpha$. This property makes the equation amenable to solution via a root-finding algorithm, such as the bisection method.\n\nTo apply the bisection method, we first need to establish a search interval $[\\alpha_{min}, \\alpha_{max}]$ for $\\alpha_i$. The value of $\\mathbf{n} \\cdot \\mathbf{x}$ is bounded for any point $\\mathbf{x}$ within the compact set $S_i$. The minimum and maximum values of $\\mathbf{n} \\cdot \\mathbf{x}$ occur at the vertices of the rectangular cell $S_i$. Let the vertices of $S_i$ be $\\{\\mathbf{v}_k\\}_{k=1}^4$. Then, the search interval is:\n$$ \\alpha_{min} = \\min_{k} (\\mathbf{n} \\cdot \\mathbf{v}_k) $$\n$$ \\alpha_{max} = \\max_{k} (\\mathbf{n} \\cdot \\mathbf{v}_k) $$\nFor any $\\alpha < \\alpha_{min}$, the clipped area is $0$. For any $\\alpha > \\alpha_{max}$, the clipped area is the full area of $S_i$.\n\nThe bisection algorithm proceeds by iteratively bisecting the interval $[\\alpha_{min}, \\alpha_{max}]$ and converging on the root of the error function $g(\\alpha) = A(\\alpha) - f_i \\cdot \\text{area}(S_i)$. At each step, we evaluate $g(\\alpha_{mid})$ where $\\alpha_{mid} = (\\alpha_{min}+\\alpha_{max})/2$. If $g(\\alpha_{mid}) > 0$, the area is too large, so we set $\\alpha_{max} = \\alpha_{mid}$. Otherwise, the area is too small, and we set $\\alpha_{min} = \\alpha_{mid}$. This is repeated until the interval width becomes smaller than a prescribed tolerance.\n\nThe evaluation of $A(\\alpha)$ itself requires two geometric primitives: a convex polygon clipping algorithm and a polygon area calculation.\n\n**2. Geometric Primitives**\n\n**2.1. Polygon Area Calculation**\nThe area of a simple, non-self-intersecting polygon with vertices $(\\mathbf{x}_0, \\mathbf{x}_1, \\dots, \\mathbf{x}_{N-1})$ ordered counter-clockwise can be computed using the shoelace formula (a discrete form of Green's theorem):\n$$ \\text{Area} = \\frac{1}{2} \\sum_{k=0}^{N-1} (x_k y_{k+1} - x_{k+1} y_k) $$\nwhere $(x_k, y_k)$ are the coordinates of vertex $\\mathbf{x}_k$, and $\\mathbf{x}_N = \\mathbf{x}_0$. This formula provides a robust and efficient way to compute the area of the polygons generated during the clipping process.\n\n**2.2. Convex Polygon Clipping**\nThe core geometric operation is the clipping of a convex polygon against a half-space. The Sutherland-Hodgman algorithm is ideally suited for this. Given a subject polygon (initially, the source cell rectangle $S_i$) and a clipping half-space (e.g., $\\mathbf{n} \\cdot \\mathbf{x} \\le \\alpha$), the algorithm processes each edge of the polygon in sequence. For an edge from vertex $\\mathbf{p}_1$ to $\\mathbf{p}_2$, there are four cases:\n1.  Both $\\mathbf{p}_1$ and $\\mathbf{p}_2$ are inside the half-space: The output list of vertices includes $\\mathbf{p}_2$.\n2.  $\\mathbf{p}_1$ is inside and $\\mathbf{p}_2$ is outside: The output list includes the intersection point of the edge with the clipping line.\n3.  Both $\\mathbf{p}_1$ and $\\mathbf{p}_2$ are outside: No vertices are output.\n4.  $\\mathbf{p}_1$ is outside and $\\mathbf{p}_2$ is inside: The output list includes the intersection point and then $\\mathbf{p}_2$.\n\nA point $\\mathbf{p}$ is inside the half-space $\\{\\mathbf{x} : \\mathbf{n} \\cdot \\mathbf{x} \\le \\alpha\\}$ if $\\mathbf{n} \\cdot \\mathbf{p} - \\alpha \\le 0$. The intersection point $\\mathbf{p}_{int}$ of the line segment $\\mathbf{p}_1\\mathbf{p}_2$ and the line $\\mathbf{n} \\cdot \\mathbf{x} = \\alpha$ can be found parametrically as $\\mathbf{p}_{int} = \\mathbf{p}_1 + t(\\mathbf{p}_2 - \\mathbf{p}_1)$, where the parameter $t$ is given by $t = \\frac{\\alpha - \\mathbf{n} \\cdot \\mathbf{p}_1}{\\mathbf{n} \\cdot (\\mathbf{p}_2 - \\mathbf{p}_1)}$.\nThis clipping process results in a new convex polygon (which may be empty or degenerate). A rectangle can be clipped by another rectangle by performing four successive half-space clips, one for each edge of the clipping rectangle.\n\n**3. Remapping and Conservation Verification**\n\nThe complete remapping procedure is as follows:\n1.  Initialize the total remapped area $A^{\\text{total}}_{\\text{remap}} = 0$ and the total initial material area $A^{\\text{total}}_{\\text{initial}} = 0$. Create an array to store the remapped area for each target cell $T_j$, initialized to zeros.\n2.  Iterate through each source cell $S_i$ with its given fraction $f_i$ and normal $\\mathbf{n}$:\n    a. Calculate the initial material area in this cell, $f_i \\cdot \\text{area}(S_i)$, and add it to $A^{\\text{total}}_{\\text{initial}}$. Note that in this problem, $\\text{area}(S_i)=1$ for all $i$.\n    b. Handle trivial cases: if $f_i=0$, the material polygon $M_i$ is empty. If $f_i=1$, $M_i$ is the entire cell $S_i$. Otherwise:\n    c. Use the bisection method described in Step 1 to find the value of $\\alpha_i$ that satisfies the volume fraction constraint.\n    d. Construct the material polygon $M_i$ by clipping the rectangle $S_i$ with the half-space $\\{\\mathbf{x} : \\mathbf{n} \\cdot \\mathbf{x} \\le \\alpha_i\\}$. The vertices of $S_i$ must be in a consistent order (e.g., counter-clockwise).\n    e. Iterate through each target cell $T_j$:\n        i.  Calculate the intersection polygon $C_{ij} = M_i \\cap T_j$. Since $T_j$ is a rectangle, this is done by clipping the convex polygon $M_i$ against the four half-spaces defining the boundaries of $T_j$.\n        ii. Compute the area of the resulting intersection polygon $C_{ij}$ using the shoelace formula.\n        iii. Add this area to the accumulator for target cell $T_j$.\n3.  After iterating through all source cells, the total remapped area is the sum of the areas in all target cell accumulators: $A^{\\text{total}}_{\\text{remap}} = \\sum_j A_j^{\\text{remap}}$.\n4.  The absolute conservation error is then computed as $E = \\left| A^{\\text{total}}_{\\text{remap}} - A^{\\text{total}}_{\\text{initial}} \\right|$.\n\nBy construction, the remapping is a geometric decomposition and reconstruction. Since the target mesh cells $\\{T_j\\}$ form a partition of the domain, we have $\\sum_j \\text{area}(M_i \\cap T_j) = \\text{area}(M_i)$. Summing over all source cells,\n$$ \\sum_j A_j^{\\text{remap}} = \\sum_j \\sum_i \\text{area}(M_i \\cap T_j) = \\sum_i \\sum_j \\text{area}(M_i \\cap T_j) = \\sum_i \\text{area}(M_i) $$\nAnd since we enforce $\\text{area}(M_i) = f_i \\cdot \\text{area}(S_i)$, it follows that:\n$$ \\sum_j A_j^{\\text{remap}} = \\sum_i f_i \\cdot \\text{area}(S_i) $$\nThus, in exact arithmetic, the conservation error $E$ must be zero. The numerically computed error will be a small value on the order of machine precision, which serves as a rigorous check on the correctness and precision of the geometric implementation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# A small tolerance for floating point comparisons\nEPS = 1e-15\n\ndef polygon_area(vertices):\n    \"\"\"\n    Computes the area of a polygon using the shoelace formula.\n    Assumes vertices are ordered counter-clockwise.\n    \"\"\"\n    if len(vertices) < 3:\n        return 0.0\n    \n    # Vertices is a list of [x, y] pairs or an Nx2 numpy array\n    verts = np.asarray(vertices)\n    x = verts[:, 0]\n    y = verts[:, 1]\n    \n    # Shift coordinates to avoid large numbers if needed, though not critical here.\n    area = 0.5 * np.abs(np.dot(x, np.roll(y, -1)) - np.dot(y, np.roll(x, -1)))\n    return area\n\ndef clip_polygon_by_halfspace(polygon_verts, n, alpha):\n    \"\"\"\n    Clips a convex polygon using the Sutherland-Hodgman algorithm against a half-space n.x <= alpha.\n    \"\"\"\n    if not polygon_verts:\n        return []\n\n    output_verts = []\n    \n    # Ensure n is a unit vector for numerical stability, though logic holds for any n\n    # n = n / np.linalg.norm(n) \n    \n    S = polygon_verts[-1]\n    for P in polygon_verts:\n        # Signed distance from the line n.x - alpha = 0\n        dist_S = np.dot(n, S) - alpha\n        dist_P = np.dot(n, P) - alpha\n        \n        # Case 1: P is inside (or on the line)\n        if dist_P <= EPS:\n            # S is outside\n            if dist_S > EPS:\n                # Intersection point\n                t = dist_S / (dist_S - dist_P)\n                I = S + t * (P - S)\n                output_verts.append(I)\n            output_verts.append(P)\n        # Case 2: P is outside\n        elif dist_S <= EPS:\n            # S is inside\n            t = dist_S / (dist_S - dist_P)\n            I = S + t * (P - S)\n            output_verts.append(I)\n        S = P\n        \n    return output_verts\n\ndef find_alpha(cell_rect, n, fraction):\n    \"\"\"\n    Finds the line constant alpha for a given volume fraction using bisection.\n    \"\"\"\n    cell_verts = [\n        np.array([cell_rect[0], cell_rect[2]]),\n        np.array([cell_rect[1], cell_rect[2]]),\n        np.array([cell_rect[1], cell_rect[3]]),\n        np.array([cell_rect[0], cell_rect[3]]),\n    ]\n    cell_area = (cell_rect[1] - cell_rect[0]) * (cell_rect[3] - cell_rect[2])\n    target_area = fraction * cell_area\n\n    if np.isclose(target_area, 0.0):\n        # Find alpha such that the entire cell is 'outside'\n        alpha = min(np.dot(n, v) for v in cell_verts) - 1.0 # a safe lower bound\n        return alpha\n    if np.isclose(target_area, cell_area):\n        # Find alpha such that the entire cell is 'inside'\n        alpha = max(np.dot(n, v) for v in cell_verts) + 1.0 # a safe upper bound\n        return alpha\n\n    dot_products = [np.dot(n, v) for v in cell_verts]\n    alpha_min, alpha_max = min(dot_products), max(dot_products)\n\n    def get_area_error(alpha):\n        clipped_poly = clip_polygon_by_halfspace(cell_verts, n, alpha)\n        area = polygon_area(clipped_poly)\n        return area - target_area\n\n    # Bisection method\n    low, high = alpha_min, alpha_max\n    for _ in range(100): # 100 iterations offer sufficient precision\n        mid = (low + high) / 2\n        error = get_area_error(mid)\n        if error > 0:\n            high = mid\n        else:\n            low = mid\n        # Check for convergence to avoid unnecessary iterations\n        if high-low < 1e-14:\n            break\n            \n    return (low + high) / 2\n\ndef solve():\n    \"\"\"\n    Main solver function to run the remapping tests.\n    \"\"\"\n    # Common source mesh (4 cells, 1x1)\n    source_cells = [\n        [0.0, 1.0, 0.0, 1.0],  # S0\n        [1.0, 2.0, 0.0, 1.0],  # S1\n        [0.0, 1.0, 1.0, 2.0],  # S2\n        [1.0, 2.0, 1.0, 2.0],  # S3\n    ]\n    source_areas = [(c[1] - c[0]) * (c[3] - c[2]) for c in source_cells]\n\n    # Common target mesh (4 cells)\n    target_cells = [\n        [0.0, 1.2, 0.0, 1.2],  # T0\n        [1.2, 2.0, 0.0, 1.2],  # T1\n        [0.0, 1.2, 1.2, 2.0],  # T2\n        [1.2, 2.0, 1.2, 2.0],  # T3\n    ]\n    \n    test_cases = [\n        {\n            'n': np.array([np.cos(np.pi / 6), np.sin(np.pi / 6)]),\n            'fractions': [0.2, 0.5, 0.7, 0.9],\n        },\n        {\n            'n': np.array([1.0, 0.0]),\n            'fractions': [0.0, 0.5, 1.0, 0.25],\n        },\n        {\n            'n': np.array([np.cos(np.pi / 4), np.sin(np.pi / 4)]),\n            'fractions': [0.5, 0.5, 0.5, 0.5],\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        n = case['n']\n        fractions = case['fractions']\n        \n        total_initial_area = sum(f * a for f, a in zip(fractions, source_areas))\n        \n        target_cell_areas = np.zeros(len(target_cells))\n\n        for i, (source_rect, f) in enumerate(zip(source_cells, fractions)):\n            if np.isclose(f, 0.0):\n                continue\n\n            source_verts_list = [\n                np.array([source_rect[0], source_rect[2]]),\n                np.array([source_rect[1], source_rect[2]]),\n                np.array([source_rect[1], source_rect[3]]),\n                np.array([source_rect[0], source_rect[3]]),\n            ]\n            \n            if np.isclose(f, 1.0):\n                material_polygon = source_verts_list\n            else:\n                alpha = find_alpha(source_rect, n, f)\n                material_polygon = clip_polygon_by_halfspace(source_verts_list, n, alpha)\n\n            if not material_polygon:\n                continue\n                \n            for j, target_rect in enumerate(target_cells):\n                # Clip material polygon by the target cell rectangle\n                xmin, xmax, ymin, ymax = target_rect\n                \n                # Clip against the 4 half-spaces of the target rectangle\n                clipped_poly = clip_polygon_by_halfspace(material_polygon, np.array([1.0, 0.0]), xmax)\n                clipped_poly = clip_polygon_by_halfspace(clipped_poly, np.array([-1.0, 0.0]), -xmin)\n                clipped_poly = clip_polygon_by_halfspace(clipped_poly, np.array([0.0, 1.0]), ymax)\n                clipped_poly = clip_polygon_by_halfspace(clipped_poly, np.array([0.0, -1.0]), -ymin)\n                \n                intersect_area = polygon_area(clipped_poly)\n                target_cell_areas[j] += intersect_area\n\n        total_remapped_area = np.sum(target_cell_areas)\n        conservation_error = np.abs(total_remapped_area - total_initial_area)\n        results.append(conservation_error)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}