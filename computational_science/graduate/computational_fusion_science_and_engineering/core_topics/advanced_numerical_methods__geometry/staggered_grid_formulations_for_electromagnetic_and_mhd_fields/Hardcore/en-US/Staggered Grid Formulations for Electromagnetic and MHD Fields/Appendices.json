{
    "hands_on_practices": [
        {
            "introduction": "The Constrained Transport (CT) method is a cornerstone of modern magnetohydrodynamic (MHD) simulations, designed specifically to enforce the divergence-free constraint, $\\nabla \\cdot \\mathbf{B} = 0$, at the discrete level. This hands-on problem guides you through the implementation of the CT algorithm for a 2D rotating flow, a classic and illustrative test case. By developing the code and comparing its output to a known analytic solution, you will gain direct experience with staggered grid updates and numerically verify the method's crucial divergence-preserving properties .",
            "id": "4048221",
            "problem": "Consider the ideal Magnetohydrodynamics (MHD) induction equation, which states that the magnetic field evolves according to Faraday's law with the ideal Ohm's law. The fundamental base is that the electric field satisfies $\\,\\mathbf{E} = -\\mathbf{v} \\times \\mathbf{B}\\,$ and Faraday's law is $\\,\\partial_t \\mathbf{B} = -\\nabla \\times \\mathbf{E}\\,$. Constrained Transport (CT) is a staggered-grid discretization strategy that updates face-centered magnetic field components using edge-centered electromotive forces to ensure a discrete divergence-free condition is preserved.\n\nYou are to implement the CT update on a uniform two-dimensional grid for a rigidly rotating flow. The velocity field is analytic and incompressible, given by a rigid rotation about the domain center with angular speed $\\Omega$ about the $\\hat{\\mathbf{z}}$ axis, namely $\\,\\mathbf{v}(x,y) = \\left(-\\Omega (y - L_y/2),\\, \\Omega (x - L_x/2)\\right)\\,$. The initial magnetic field is uniform in the plane, $\\,\\mathbf{B}(x,y,0) = \\left(B_x(0),\\, B_y(0)\\right)\\,$. Under the ideal MHD induction equation, the analytic solution in this case is a uniform rigid rotation of the magnetic field vector: $\\,\\partial_t \\mathbf{B} = \\boldsymbol{\\Omega} \\times \\mathbf{B}\\,$ where $\\,\\boldsymbol{\\Omega} = (0,0,\\Omega)\\,$, so that\n$$\nB_x(t) = B_x(0)\\cos(\\Omega t) - B_y(0)\\sin(\\Omega t), \\quad\nB_y(t) = B_x(0)\\sin(\\Omega t) + B_y(0)\\cos(\\Omega t).\n$$\n\nUse a uniform Cartesian mesh covering $[0,L_x]\\times[0,L_y]$ with $N_x$ by $N_y$ rectangular cells of width $\\Delta x = L_x/N_x$ and height $\\Delta y = L_y/N_y$. Store $\\,B_x\\,$ at faces normal to $\\,\\hat{\\mathbf{x}}\\,$ (indices $\\,i=0,\\dots,N_x\\,$, $\\,j=0,\\dots,N_y-1\\,$) and $\\,B_y\\,$ at faces normal to $\\,\\hat{\\mathbf{y}}\\,$ (indices $\\,i=0,\\dots,N_x-1\\,$, $\\,j=0,\\dots,N_y\\,$). Store the edge-centered electromotive force $\\,E_z\\,$ at edge points (indices $\\,i=0,\\dots,N_x\\,$, $\\,j=0,\\dots,N_y\\,$), and apply periodic boundary conditions in both directions. The CT update is to be derived from Stokes' theorem applied to Faraday's law: each face-centered magnetic component changes by the line integral of $\\,E_z\\,$ around its bounding edges divided by the face area. Use a second-order accurate explicit time integrator in time (for example, a midpoint method) for the CT update. Interpolate face-centered $\\,\\mathbf{B}\\,$ to edges consistently to compute $\\,E_z = -(\\mathbf{v}\\times\\mathbf{B})\\cdot\\hat{\\mathbf{z}}\\,$ at edges. All quantities are nondimensional and angles are in radians.\n\nYour program must:\n- Implement the staggered-grid CT update with periodic boundaries and a second-order explicit time integrator.\n- Advance the magnetic field for a prescribed number of time steps starting from a uniform initial field.\n- Compute the discrete divergence at cell centers,\n$$\n(\\nabla\\cdot\\mathbf{B})_{i,j} = \\frac{B_{x,i+1,j} - B_{x,i,j}}{\\Delta x} + \\frac{B_{y,i,j+1} - B_{y,i,j}}{\\Delta y},\n$$\nand report the maximum absolute value over all cells at the final time as a float.\n- Compute the spatial average of a cell-centered magnetic field vector constructed from face-centered values via cell-centered averaging,\n$$\nB_x^{\\mathrm{cell}}(i,j) = \\tfrac{1}{2}\\left(B_{x,i,j} + B_{x,i+1,j}\\right), \\quad\nB_y^{\\mathrm{cell}}(i,j) = \\tfrac{1}{2}\\left(B_{y,i,j} + B_{y,i,j+1}\\right),\n$$\nthen average over all cells to obtain $\\,\\bar{B}_x(t)\\,$ and $\\,\\bar{B}_y(t)\\,$. Compare this average to the analytic solution above evaluated at the final time and report the Euclidean norm of the difference $\\,\\sqrt{\\left(\\bar{B}_x(t) - B_x^{\\mathrm{analytic}}(t)\\right)^2 + \\left(\\bar{B}_y(t) - B_y^{\\mathrm{analytic}}(t)\\right)^2}\\,$ as a float.\n\nTest Suite:\nUse the following parameter sets, each specified as $[N_x,N_y,L_x,L_y,\\Omega,\\Delta t,n,B_x(0),B_y(0)]$ with all quantities nondimensional:\n- Case $\\,A$: $[\\,32,\\,32,\\,1,\\,1,\\,1,\\,0.0025,\\,400,\\,1,\\,0\\,]$ so that $\\,t = n\\,\\Delta t = 1\\,$ and the analytic rotation angle is $\\,\\Omega t = 1\\,$.\n- Case $\\,B$: $[\\,4,\\,4,\\,1,\\,1,\\,0.5,\\,0.01,\\,200,\\,0.7,\\,0.3\\,]$ so that $\\,t = 2\\,$ and the analytic rotation angle is $\\,\\Omega t = 1\\,.$\n- Case $\\,C$: $[\\,2,\\,2,\\,1,\\,1,\\,2,\\,0.05,\\,40,\\,1,\\,{-0.5}\\,]$ so that $\\,t = 2\\,$ and the analytic rotation angle is $\\,\\Omega t = 4\\,.$\n\nRequired final output format:\nYour program should produce a single line of output containing the results as a comma-separated list of three pairs, each pair being $[\\,\\text{max\\_abs\\_div},\\,\\text{avg\\_B\\_error}\\,]$ for Cases $\\,A$, $\\,B$, and $\\,C$ respectively, with no spaces. For example: $[[a_1,b_1],[a_2,b_2],[a_3,b_3]]$, where each $\\,a_k\\,$ and $\\,b_k\\,$ is a float.",
            "solution": "The problem requires the implementation of the Constrained Transport (CT) method to solve the ideal Magnetohydrodynamics (MHD) induction equation on a two-dimensional Cartesian grid with periodic boundaries. The physical system is governed by Faraday's law of induction, $\\,\\partial_t \\mathbf{B} = -\\nabla \\times \\mathbf{E}\\,$, combined with the ideal Ohm's law, $\\,\\mathbf{E} = -\\mathbf{v} \\times \\mathbf{B}\\,$. Combining these gives the evolution equation for the magnetic field $\\,\\mathbf{B}\\,$ in a perfectly conducting fluid moving with velocity $\\,\\mathbf{v}\\,$:\n$$\n\\partial_t \\mathbf{B} = \\nabla \\times (\\mathbf{v} \\times \\mathbf{B})\n$$\n\nThe solution is developed by discretizing this equation using the CT method, which is specifically designed to preserve the divergence-free condition, $\\,\\nabla \\cdot \\mathbf{B} = 0\\,$, at the discrete level.\n\n**Discretization and Staggered Grid**\nWe employ a uniform Cartesian grid with $\\,N_x \\times N_y\\,$ cells over the domain $\\,[0, L_x] \\times [0, L_y]\\,$. The cell dimensions are $\\,\\Delta x = L_x/N_x\\,$ and $\\,\\Delta y = L_y/N_y\\,$. The CT method relies on a staggered grid (a Yee grid), where different field components are located at different positions relative to a grid cell.\n- The x-component of the magnetic field, $\\,B_x\\,$, is located at the center of cell faces oriented normal to the $\\,\\hat{\\mathbf{x}}\\,$ axis. We denote these as $\\,B_{x, i, j}\\,$ for $\\,i=0, \\dots, N_x\\,$ and $\\,j=0, \\dots, N_y-1\\,$.\n- The y-component, $\\,B_y\\,$, is at the center of faces normal to the $\\,\\hat{\\mathbf{y}}\\,$ axis, denoted $\\,B_{y, i, j}\\,$ for $\\,i=0, \\dots, N_x-1\\,$ and $\\,j=0, \\dots, N_y\\,$.\n- The out-of-plane electric field (or electromotive force, EMF), $\\,E_z\\,$, is located at the cell corners (or edges in 2D), denoted $\\,E_{z, i, j}\\,$ for $\\,i=0, \\dots, N_x\\,$ and $\\,j=0, \\dots, N_y\\,$.\n\n**Constrained Transport Algorithm**\nThe CT method applies the integral form of Faraday's law, $\\,\\oint_{\\partial S} \\mathbf{E} \\cdot d\\mathbf{l} = -\\frac{d}{dt} \\int_S \\mathbf{B} \\cdot d\\mathbf{a}\\,$, to each cell face.\nFor a face normal to $\\,\\hat{\\mathbf{x}}\\,$ at location $\\,(i, j)\\,$ with area $\\,\\Delta y \\cdot 1\\,$, the magnetic flux is $\\,\\Phi_{x,i,j} = B_{x,i,j} \\Delta y\\,$. Its rate of change is the line integral of $\\,\\mathbf{E}\\,$ around its boundary. The boundary consists of four edges, where the $\\,\\hat{\\mathbf{z}}\\,$ component of the EMF, $\\,E_z\\,$, is defined. This leads to the discrete update equation:\n$$\n\\frac{dB_{x,i,j}}{dt} = -\\frac{E_{z,i,j+1} - E_{z,i,j}}{\\Delta y}\n$$\nSimilarly, for a face normal to $\\,\\hat{\\mathbf{y}}\\,$:\n$$\n\\frac{dB_{y,i,j}}{dt} = \\frac{E_{z,i+1,j} - E_{z,i,j}}{\\Delta x}\n$$\nThese equations are the spatial discretization of $\\,\\partial_t \\mathbf{B} = -(\\nabla \\times \\mathbf{E})\\,$. A key property of this scheme is that it guarantees the preservation of the discrete divergence, $\\,(\\nabla\\cdot\\mathbf{B})_{i,j} = \\frac{B_{x,i+1,j} - B_{x,i,j}}{\\Delta x} + \\frac{B_{y,i,j+1} - B_{y,i,j}}{\\Delta y}\\,$, which will remain zero to machine precision if it is initially zero.\n\nThe electromotive force $\\,E_z\\,$ is computed at the grid nodes from $\\,E_z = -(\\mathbf{v} \\times \\mathbf{B})_z = v_y B_x - v_x B_y\\,$. Since $\\,\\mathbf{v}\\,$ is given analytically, we evaluate it directly at the node coordinates $\\,(x_i, y_j)\\,$. The magnetic field components $\\,B_x\\,$ and $\\,B_y\\,$, which are defined at face centers, must be interpolated to the nodes. A second-order accurate approach is to average the values from the four nearest faces, which simplifies in this staggered arrangement to a two-point average for each component:\n- $\\,B_x^{\\text{node}}(i,j) \\approx \\frac{1}{2}(B_{x,i,j} + B_{x,i,j-1})\\,$\n- $\\,B_y^{\\text{node}}(i,j) \\approx \\frac{1}{2}(B_{y,i,j} + B_{y,i-1,j})\\,$\nPeriodic boundary conditions are handled by wrapping around the array indices.\n\n**Time Integration**\nThe system of ordinary differential equations is advanced in time using a second-order explicit midpoint method (a type of Runge-Kutta method, RK2). For an equation $\\,\\frac{d\\mathbf{B}}{dt} = F(\\mathbf{B})\\,$, where $\\,F\\,$ represents the CT spatial operator, one time step from $\\,t_n\\,$ to $\\,t_{n+1} = t_n + \\Delta t\\,$ proceeds as:\n1. **Predictor Step**: Compute a half-step estimate $\\,\\mathbf{B}^* = \\mathbf{B}^n + \\frac{\\Delta t}{2} F(\\mathbf{B}^n)\\,$.\n2. **Corrector Step**: Use the EMF evaluated at this midpoint state to take the full step: $\\,\\mathbf{B}^{n+1} = \\mathbf{B}^n + \\Delta t F(\\mathbf{B}^*)\\,$.\n\n**Implementation and Analysis**\nThe algorithm is implemented in Python using the NumPy library. The staggered grid is represented by arrays of appropriate dimensions (e.g., $\\,(N_x+1, N_y)\\,$ for $\\,B_x\\,$). The core logic is encapsulated in a function that computes the right-hand side (the time derivatives $\\,d\\mathbf{B}/dt\\,$) for a given state $\\,\\mathbf{B}\\,$. This function performs the interpolation of $\\,\\mathbf{B}\\,$ to nodes, calculates $\\,E_z\\,$, and then computes its discrete curl. The main loop iterates through the required number of time steps, applying the RK2 integration scheme.\n\nFinally, two metrics are calculated:\n1. The maximum absolute value of the discrete divergence of $\\,\\mathbf{B}\\,$ across all cells. As the initial uniform field has zero divergence, this value serves as a check on the correctness of the CT implementation, and it is expected to be close to machine precision.\n2. The error between the spatially averaged numerical magnetic field and the exact analytic solution for a rigid rotation. The numerical field is first averaged to cell centers, then averaged over the entire domain. This metric evaluates the accuracy of the overall scheme in capturing the physical advection.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_rhs(Bx, By, Nx, Ny, dx, dy, Lx, Ly, Omega):\n    \"\"\"\n    Computes the right-hand side of the induction equation using Constrained Transport.\n    This function calculates d(B)/dt = -curl(E) where E = -v x B.\n    \"\"\"\n    # 1. Compute velocities at edges/nodes\n    # Ez is defined at nodes (i, j) for i=0..Nx, j=0..Ny\n    x_edge = np.linspace(0, Lx, Nx + 1)\n    y_edge = np.linspace(0, Ly, Ny + 1)\n    xx_edge, yy_edge = np.meshgrid(x_edge, y_edge, indexing='ij')\n\n    vx = -Omega * (yy_edge - Ly / 2)\n    vy = Omega * (xx_edge - Lx / 2)\n\n    # 2. Interpolate B to edges/nodes where Ez is defined (size (Nx+1, Ny+1))\n    Ez_size = (Nx + 1, Ny + 1)\n    Bx_at_Ez = np.zeros(Ez_size)\n    By_at_Ez = np.zeros(Ez_size)\n\n    # Interpolate Bx (defined at x-face centers) to nodes\n    # Averages Bx values from faces above and below the node\n    Bx_at_Ez[:, 1:Ny] = 0.5 * (Bx[:, 1:Ny] + Bx[:, 0:Ny-1])\n    # Periodic wrap for j=0 edge\n    Bx_at_Ez[:, 0] = 0.5 * (Bx[:, 0] + Bx[:, Ny-1])\n    # Enforce periodicity for j=Ny edge\n    Bx_at_Ez[:, Ny] = Bx_at_Ez[:, 0]\n\n    # Interpolate By (defined at y-face centers) to nodes\n    # Averages By values from faces left and right of the node\n    By_at_Ez[1:Nx, :] = 0.5 * (By[1:Nx, :] + By[0:Nx-1, :])\n    # Periodic wrap for i=0 edge\n    By_at_Ez[0, :] = 0.5 * (By[0, :] + By[Nx-1, :])\n    # Enforce periodicity for i=Nx edge\n    By_at_Ez[Nx, :] = By_at_Ez[0, :]\n\n    # 3. Compute Ez = v_y * B_x - v_x * B_y at nodes\n    Ez = vy * Bx_at_Ez - vx * By_at_Ez\n\n    # 4. Compute curl of E to get dB/dt\n    # dBx/dt = -dEz/dy, located at x-faces\n    dBx_dt = -(Ez[:, 1:Ny+1] - Ez[:, 0:Ny]) / dy\n    \n    # dBy/dt = +dEz/dx, located at y-faces\n    dBy_dt = (Ez[1:Nx+1, :] - Ez[0:Nx, :]) / dx\n    \n    return dBx_dt, dBy_dt\n\ndef run_simulation(Nx, Ny, Lx, Ly, Omega, dt, n_steps, Bx0, By0):\n    \"\"\"\n    Runs a single simulation case for the 2D induction equation.\n    \"\"\"\n    # Grid setup\n    dx = Lx / float(Nx)\n    dy = Ly / float(Ny)\n\n    # Initialize face-centered magnetic fields\n    # Bx has shape (Nx+1, Ny), By has shape (Nx, Ny+1)\n    Bx = np.full((Nx + 1, Ny), Bx0, dtype=float)\n    By = np.full((Nx, Ny + 1), By0, dtype=float)\n\n    # Time integration loop (RK2-midpoint)\n    for _ in range(n_steps):\n        # Predictor step (half step)\n        dBx1, dBy1 = compute_rhs(Bx, By, Nx, Ny, dx, dy, Lx, Ly, Omega)\n        Bx_star = Bx + 0.5 * dt * dBx1\n        By_star = By + 0.5 * dt * dBy1\n\n        # Periodic BCs for intermediate step (optional but good practice)\n        Bx_star[Nx, :] = Bx_star[0, :]\n        By_star[:, Ny] = By_star[:, 0]\n        \n        # Corrector step (full step using midpoint evaluation)\n        dBx2, dBy2 = compute_rhs(Bx_star, By_star, Nx, Ny, dx, dy, Lx, Ly, Omega)\n        Bx = Bx + dt * dBx2\n        By = By + dt * dBy2\n\n        # Enforce periodic BCs after full step\n        Bx[Nx, :] = Bx[0, :]\n        By[:, Ny] = By[:, 0]\n\n    # --- Post-simulation analysis ---\n    # 1. Compute discrete divergence at cell centers\n    # divB has shape (Nx, Ny)\n    divB = (Bx[1:Nx+1, :] - Bx[0:Nx, :]) / dx + \\\n           (By[:, 1:Ny+1] - By[:, 0:Ny]) / dy\n    max_abs_div = np.max(np.abs(divB))\n\n    # 2. Compute error in spatially averaged magnetic field\n    # Average face-centered B to cell centers\n    Bx_cell = 0.5 * (Bx[0:Nx, :] + Bx[1:Nx+1, :])\n    By_cell = 0.5 * (By[:, 0:Ny] + By[:, 1:Ny+1])\n    \n    # Average cell-centered field over the whole domain\n    Bx_avg_num = np.mean(Bx_cell)\n    By_avg_num = np.mean(By_cell)\n\n    # Compute analytic solution at final time\n    t_final = n_steps * dt\n    angle = Omega * t_final\n    Bx_ana = Bx0 * np.cos(angle) - By0 * np.sin(angle)\n    By_ana = Bx0 * np.sin(angle) + By0 * np.cos(angle)\n    \n    # Compute Euclidean norm of the error vector\n    avg_B_error = np.sqrt((Bx_avg_num - Bx_ana)**2 + (By_avg_num - By_ana)**2)\n\n    return max_abs_div, avg_B_error\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # [Nx, Ny, Lx, Ly, Omega, dt, n_steps, Bx0, By0]\n        [32, 32, 1.0, 1.0, 1.0, 0.0025, 400, 1.0, 0.0],  # Case A\n        [4, 4, 1.0, 1.0, 0.5, 0.01, 200, 0.7, 0.3],    # Case B\n        [2, 2, 1.0, 1.0, 2.0, 0.05, 40, 1.0, -0.5],   # Case C\n    ]\n\n    results = []\n    for case in test_cases:\n        max_div, b_error = run_simulation(*case)\n        results.append([max_div, b_error])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'[{r[0]},{r[1]}]' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Beyond preserving the divergence of the magnetic field, ensuring the conservation of energy is paramount for the long-term stability and physical realism of electromagnetic simulations. This theoretical practice delves into the subtle but critical details of how the staggered Yee scheme achieves discrete energy conservation. You will derive the discrete form of Poynting's theorem, demonstrating how an inconsistent calculation of energy flux can create non-physical artifacts, and then formulate a consistent approach that guarantees exact energy conservation in a source-free system .",
            "id": "4048168",
            "problem": "Consider electromagnetic wave propagation in one spatial dimension, with electric field component $E_{y}(x,t)$ and magnetic field component $H_{z}(x,t)$ satisfying Maxwell’s equations in a homogeneous, source-free medium with constant permittivity $\\varepsilon$ and permeability $\\mu$. The continuous energy density is $u = \\frac{\\varepsilon}{2} |E_{y}|^{2} + \\frac{\\mu}{2} |H_{z}|^{2}$ and the Poynting vector is $\\mathbf{S} = \\mathbf{E} \\times \\mathbf{H}$, whose $x$-component is $S_{x} = E_{y} H_{z}$. The continuous energy balance for a periodic domain states that the time rate of change of the total energy equals the negative of the net flux of $S_{x}$ across the domain boundaries, which is zero.\n\nNow discretize the spatial domain of length $L$ with $N$ uniform cells of spacing $\\Delta x = L/N$ and periodic boundary conditions. Use the canonical staggered Yee lattice: store $E_{y}$ at cell centers indexed by $i \\in \\{0,1,\\dots,N-1\\}$ at integer times $t^{n} = n \\Delta t$, and store $H_{z}$ at cell faces indexed by $i+\\frac{1}{2}$ at half times $t^{n+\\frac{1}{2}} = \\left(n+\\frac{1}{2}\\right) \\Delta t$. Assume the standard leapfrog Finite-Difference Time-Domain (FDTD) scheme (Yee updates) that is consistent with Maxwell’s equations and the above staggering.\n\nTasks:\n\n1. Define the discrete total electromagnetic energy $W^{n}$ at time $t^{n}$ using the staggered field locations described above and the cell volume $\\Delta x$. Then, starting from the discrete update equations implied by the Yee scheme and Maxwell’s equations, derive a fully discrete energy balance for $W^{n+1}-W^{n}$ by multiplying each update by an appropriate space-time average of the corresponding field and summing over the grid. Express the resulting discrete energy change as a discrete divergence of a face-centered and time-centered Poynting flux $S_{x}^{n+\\frac{1}{2}}(i+\\frac{1}{2})$.\n\n2. Show that if, instead, one computes a cell-centered and time-centered Poynting vector $\\tilde{S}_{x}^{n+\\frac{1}{2}}(i)$ by first interpolating $H_{z}^{n+\\frac{1}{2}}(i+\\frac{1}{2})$ to the cell center via arithmetic averaging and then forming the product with the time-centered $E_{y}$, i.e.,\n$$\n\\tilde{S}_{x}^{n+\\frac{1}{2}}(i) = \\left( \\frac{E_{y}^{n+1}(i) + E_{y}^{n}(i)}{2} \\right) \\left( \\frac{H_{z}^{n+\\frac{1}{2}}(i+\\frac{1}{2}) + H_{z}^{n+\\frac{1}{2}}(i-\\frac{1}{2})}{2} \\right),\n$$\nthe discrete energy change $W^{n+1}-W^{n}$ contains a residual “aliasing” term that does not cancel and can be positive for certain discrete modes. Derive a closed-form expression for this residual term in one dimension and explain briefly why it can be non-physical (i.e., lead to $W^{n+1} > W^{n}$ in a source-free periodic domain).\n\n3. Propose a consistent averaging scheme for the face-centered and time-centered Poynting flux\n$$\nS_{x}^{n+\\frac{1}{2}}(i+\\frac{1}{2}) = E_{y}^{n+\\frac{1}{2}}(i+\\frac{1}{2}) \\, H_{z}^{n+\\frac{1}{2}}(i+\\frac{1}{2}),\n$$\nthat uses a space-time average of $E_{y}$ to the face $i+\\frac{1}{2}$ at time $t^{n+\\frac{1}{2}}$ while leaving $H_{z}$ at its native staggered location and time. Your scheme must be explicit, second-order accurate, and constructed only from the nearest-neighbor values implied by the Yee staggering. Show that with this scheme, the discrete energy balance reduces to a pure telescoping sum of fluxes across faces and therefore exactly conserves energy in a source-free periodic domain.\n\nFinally, under the consistent face-centered and time-centered averaging scheme you propose in Task 3 and the periodic boundary conditions specified, compute the discrete energy growth rate\n$$\n\\frac{W^{n+1} - W^{n}}{\\Delta t}\n$$\nand express your answer in Joules per second. You do not need to round your answer.",
            "solution": "We start from Maxwell’s equations in a homogeneous, source-free medium:\n$$\n\\frac{\\partial \\mathbf{D}}{\\partial t} = \\nabla \\times \\mathbf{H}, \\quad \\frac{\\partial \\mathbf{B}}{\\partial t} = - \\nabla \\times \\mathbf{E}, \\quad \\mathbf{D} = \\varepsilon \\mathbf{E}, \\quad \\mathbf{B} = \\mu \\mathbf{H}.\n$$\nIn one spatial dimension with transverse fields $E_{y}(x,t)$ and $H_{z}(x,t)$, these reduce to\n$$\n\\varepsilon \\frac{\\partial E_{y}}{\\partial t} = \\frac{\\partial H_{z}}{\\partial x}, \\quad \\mu \\frac{\\partial H_{z}}{\\partial t} = \\frac{\\partial E_{y}}{\\partial x}.\n$$\nThe continuous energy density is $u = \\frac{\\varepsilon}{2} |E_{y}|^{2} + \\frac{\\mu}{2} |H_{z}|^{2}$ and the Poynting flux in the $x$-direction is $S_{x} = E_{y} H_{z}$. The continuous energy balance is\n$$\n\\frac{d}{dt} \\int_{0}^{L} \\left( \\frac{\\varepsilon}{2} |E_{y}|^{2} + \\frac{\\mu}{2} |H_{z}|^{2} \\right) \\, dx = - \\left[ E_{y} H_{z} \\right]_{x=0}^{x=L}.\n$$\nFor periodic boundary conditions, the right-hand side vanishes and the total energy is conserved.\n\nWe now discretize using the Yee lattice and the leapfrog Finite-Difference Time-Domain (FDTD) method. Let $E_{y}^{n}(i)$ denote $E_{y}$ at cell center $x_{i} = i \\Delta x$ and time $t^{n} = n \\Delta t$, and $H_{z}^{n+\\frac{1}{2}}(i+\\frac{1}{2})$ denote $H_{z}$ at face $x_{i+\\frac{1}{2}} = \\left(i+\\frac{1}{2}\\right)\\Delta x$ and time $t^{n+\\frac{1}{2}} = \\left(n+\\frac{1}{2}\\right)\\Delta t$. The standard Yee updates for the one-dimensional transverse electromagnetic mode are\n$$\n\\varepsilon \\frac{E_{y}^{n+1}(i) - E_{y}^{n}(i)}{\\Delta t} = \\frac{H_{z}^{n+\\frac{1}{2}}(i+\\frac{1}{2}) - H_{z}^{n+\\frac{1}{2}}(i-\\frac{1}{2})}{\\Delta x},\n$$\n$$\n\\mu \\frac{H_{z}^{n+\\frac{1}{2}}(i+\\frac{1}{2}) - H_{z}^{n-\\frac{1}{2}}(i+\\frac{1}{2})}{\\Delta t} = \\frac{E_{y}^{n}(i+1) - E_{y}^{n}(i)}{\\Delta x}.\n$$\n\nTask 1: Define the discrete total energy $W^{n}$ and derive the discrete energy balance. We define\n$$\nW^{n} = \\sum_{i=0}^{N-1} \\left[ \\frac{\\varepsilon}{2} \\left| E_{y}^{n}(i) \\right|^{2} + \\frac{\\mu}{2} \\left| H_{z}^{n-\\frac{1}{2}}(i+\\frac{1}{2}) \\right|^{2} \\right] \\Delta x,\n$$\nwhich is a natural energy at time $t^{n}$ consistent with the leapfrog staggering. To derive $W^{n+1} - W^{n}$, multiply the discrete Ampère update by the time-centered electric field at the same cell center,\n$$\nE_{y}^{n+\\frac{1}{2}}(i) \\equiv \\frac{E_{y}^{n+1}(i) + E_{y}^{n}(i)}{2},\n$$\nand the discrete Faraday update by the time-centered magnetic field at the same face,\n$$\nH_{z}^{n}(i+\\frac{1}{2}) \\equiv \\frac{H_{z}^{n+\\frac{1}{2}}(i+\\frac{1}{2}) + H_{z}^{n-\\frac{1}{2}}(i+\\frac{1}{2})}{2}.\n$$\nWe obtain\n$$\n\\varepsilon \\frac{E_{y}^{n+1}(i) - E_{y}^{n}(i)}{\\Delta t} \\, E_{y}^{n+\\frac{1}{2}}(i) = \\frac{H_{z}^{n+\\frac{1}{2}}(i+\\frac{1}{2}) - H_{z}^{n+\\frac{1}{2}}(i-\\frac{1}{2})}{\\Delta x} \\, E_{y}^{n+\\frac{1}{2}}(i),\n$$\n$$\n\\mu \\frac{H_{z}^{n+\\frac{1}{2}}(i+\\frac{1}{2}) - H_{z}^{n-\\frac{1}{2}}(i+\\frac{1}{2})}{\\Delta t} \\, H_{z}^{n}(i+\\frac{1}{2}) = \\frac{E_{y}^{n}(i+1) - E_{y}^{n}(i)}{\\Delta x} \\, H_{z}^{n}(i+\\frac{1}{2}).\n$$\nSumming over $i$ and multiplying by $\\Delta x$, the left-hand sides become discrete time differences of energy pieces:\n$$\n\\sum_{i} \\varepsilon \\frac{E_{y}^{n+1}(i) - E_{y}^{n}(i)}{\\Delta t} \\, E_{y}^{n+\\frac{1}{2}}(i) \\, \\Delta x = \\frac{1}{\\Delta t} \\sum_{i} \\frac{\\varepsilon}{2} \\left( \\left| E_{y}^{n+1}(i) \\right|^{2} - \\left| E_{y}^{n}(i) \\right|^{2} \\right) \\Delta x,\n$$\n$$\n\\sum_{i} \\mu \\frac{H_{z}^{n+\\frac{1}{2}}(i+\\frac{1}{2}) - H_{z}^{n-\\frac{1}{2}}(i+\\frac{1}{2})}{\\Delta t} \\, H_{z}^{n}(i+\\frac{1}{2}) \\, \\Delta x = \\frac{1}{\\Delta t} \\sum_{i} \\frac{\\mu}{2} \\left( \\left| H_{z}^{n+\\frac{1}{2}}(i+\\frac{1}{2}) \\right|^{2} - \\left| H_{z}^{n-\\frac{1}{2}}(i+\\frac{1}{2}) \\right|^{2} \\right) \\Delta x.\n$$\nThus\n$$\n\\frac{W^{n+1} - W^{n}}{\\Delta t} = \\sum_{i} \\left[ \\frac{H_{z}^{n+\\frac{1}{2}}(i+\\frac{1}{2}) - H_{z}^{n+\\frac{1}{2}}(i-\\frac{1}{2})}{\\Delta x} \\, E_{y}^{n+\\frac{1}{2}}(i) + \\frac{E_{y}^{n}(i+1) - E_{y}^{n}(i)}{\\Delta x} \\, H_{z}^{n}(i+\\frac{1}{2}) \\right] \\Delta x.\n$$\nWe now transform the right-hand side into a discrete divergence of a face-centered and time-centered Poynting flux by employing a discrete summation-by-parts identity. First, rewrite the sum over cells as a sum over faces to expose telescoping structure. For the first term,\n$$\n\\sum_{i} \\left[ H_{z}^{n+\\frac{1}{2}}(i+\\frac{1}{2}) - H_{z}^{n+\\frac{1}{2}}(i-\\frac{1}{2}) \\right] E_{y}^{n+\\frac{1}{2}}(i) = \\sum_{i} H_{z}^{n+\\frac{1}{2}}(i+\\frac{1}{2}) \\left[ E_{y}^{n+\\frac{1}{2}}(i) - E_{y}^{n+\\frac{1}{2}}(i+1) \\right],\n$$\nusing an index shift on the second sum. For the second term,\n$$\n\\sum_{i} \\left[ E_{y}^{n}(i+1) - E_{y}^{n}(i) \\right] H_{z}^{n}(i+\\frac{1}{2}) = - \\sum_{i} H_{z}^{n}(i+\\frac{1}{2}) \\left[ E_{y}^{n}(i+1) - E_{y}^{n}(i) \\right],\n$$\nwhich is already in face-centered form. Combining, and dividing by $\\Delta x$, we obtain\n$$\n\\frac{W^{n+1} - W^{n}}{\\Delta t} = - \\sum_{i} \\frac{1}{\\Delta x} \\left[ E_{y}^{n+\\frac{1}{2}}(i+1) - E_{y}^{n+\\frac{1}{2}}(i) \\right] H_{z}^{n+\\frac{1}{2}}(i+\\frac{1}{2}) \\, \\Delta x,\n$$\nprovided we consistently time-center the second term to $t^{n+\\frac{1}{2}}$ by replacing $H_{z}^{n}(i+\\frac{1}{2})$ with $H_{z}^{n+\\frac{1}{2}}(i+\\frac{1}{2})$ plus a truncation of order $\\mathcal{O}(\\Delta t^{2})$, which is appropriate for second-order accuracy. The remaining subtlety is the placement of $E_{y}^{n+\\frac{1}{2}}$ at the face location. To ensure both time- and space-centering consistent with the Yee curl locations, define\n$$\nE_{y}^{n+\\frac{1}{2}}(i+\\frac{1}{2}) \\equiv \\frac{1}{2} \\left( \\frac{E_{y}^{n+1}(i+1) + E_{y}^{n+1}(i)}{2} + \\frac{E_{y}^{n}(i+1) + E_{y}^{n}(i)}{2} \\right),\n$$\nwhich is the arithmetic average of the nearest-neighbor $E_{y}$ to the face at both $t^{n}$ and $t^{n+1}$. Then the discrete gradient satisfies\n$$\nE_{y}^{n+\\frac{1}{2}}(i+1) - E_{y}^{n+\\frac{1}{2}}(i) = \\frac{E_{y}^{n+1}(i+1) - E_{y}^{n+1}(i)}{2} + \\frac{E_{y}^{n}(i+1) - E_{y}^{n}(i)}{2},\n$$\nand the discrete energy balance becomes\n$$\n\\frac{W^{n+1} - W^{n}}{\\Delta t} = - \\sum_{i} \\frac{S_{x}^{n+\\frac{1}{2}}(i+\\frac{1}{2}) - S_{x}^{n+\\frac{1}{2}}(i-\\frac{1}{2})}{\\Delta x} \\, \\Delta x,\n$$\nwith the consistent, face-centered and time-centered Poynting flux\n$$\nS_{x}^{n+\\frac{1}{2}}(i+\\frac{1}{2}) \\equiv E_{y}^{n+\\frac{1}{2}}(i+\\frac{1}{2}) \\, H_{z}^{n+\\frac{1}{2}}(i+\\frac{1}{2}).\n$$\nThis is a discrete analog of the Poynting theorem. The sum on the right-hand side telescopes to boundary contributions, which vanish in a periodic domain, establishing energy conservation at the fully discrete level.\n\nTask 2: Show that improper interpolation produces a non-physical residual. Consider the naive cell-centered and time-centered Poynting vector\n$$\n\\tilde{S}_{x}^{n+\\frac{1}{2}}(i) = E_{y}^{n+\\frac{1}{2}}(i) \\, \\tilde{H}_{z}^{n+\\frac{1}{2}}(i),\n$$\nwith\n$$\nE_{y}^{n+\\frac{1}{2}}(i) \\equiv \\frac{E_{y}^{n+1}(i) + E_{y}^{n}(i)}{2}, \\quad \\tilde{H}_{z}^{n+\\frac{1}{2}}(i) \\equiv \\frac{H_{z}^{n+\\frac{1}{2}}(i+\\frac{1}{2}) + H_{z}^{n+\\frac{1}{2}}(i-\\frac{1}{2})}{2}.\n$$\nIf one attempts to write\n$$\n\\frac{W^{n+1} - W^{n}}{\\Delta t} \\stackrel{?}{=} - \\sum_{i} \\frac{\\tilde{S}_{x}^{n+\\frac{1}{2}}(i+1) - \\tilde{S}_{x}^{n+\\frac{1}{2}}(i)}{\\Delta x} \\, \\Delta x,\n$$\nand uses the discrete updates to manipulate the right-hand side into cell-centered expressions, a mismatch occurs because $\\tilde{H}_{z}^{n+\\frac{1}{2}}(i)$ is not at the face where the curl naturally lives, breaking the discrete summation-by-parts pairing. The precise residual aliasing term that contaminates the energy balance is\n$$\n\\mathcal{R}^{n+\\frac{1}{2}} \\equiv \\sum_{i=0}^{N-1} \\frac{1}{4} \\left[ E_{y}^{n+1}(i) - E_{y}^{n}(i) \\right] \\left[ H_{z}^{n+\\frac{1}{2}}(i+\\frac{1}{2}) - H_{z}^{n+\\frac{1}{2}}(i-\\frac{1}{2}) \\right].\n$$\nThis term arises from the cross-products created when expanding $\\tilde{S}_{x}^{n+\\frac{1}{2}}(i)$ and attempting to shift sums. It does not reduce to a pure telescoping face flux, and it can be positive for certain discrete Fourier modes. For example, take\n$$\nE_{y}^{n+1}(i) - E_{y}^{n}(i) = \\alpha \\cos(k x_{i}), \\quad H_{z}^{n+\\frac{1}{2}}(i+\\frac{1}{2}) - H_{z}^{n+\\frac{1}{2}}(i-\\frac{1}{2}) = \\beta \\cos(k x_{i}),\n$$\nwith $k \\Delta x$ small and $\\alpha, \\beta$ in phase; then $\\mathcal{R}^{n+\\frac{1}{2}}$ is proportional to $\\sum_{i} \\cos^{2}(k x_{i})$, which is strictly positive. In a source-free periodic domain, this positivity corresponds to spurious energy growth $W^{n+1} > W^{n}$ solely due to inconsistent interpolation, which is non-physical.\n\nTask 3: Propose a consistent averaging scheme and show conservation. The scheme is:\n- Keep $H_{z}$ at its native face-centered, time-centered location $H_{z}^{n+\\frac{1}{2}}(i+\\frac{1}{2})$.\n- Define the space-time averaged electric field at the face as\n$$\nE_{y}^{n+\\frac{1}{2}}(i+\\frac{1}{2}) = \\frac{1}{2} \\left( \\frac{E_{y}^{n+1}(i+1) + E_{y}^{n+1}(i)}{2} + \\frac{E_{y}^{n}(i+1) + E_{y}^{n}(i)}{2} \\right).\n$$\n- Form the face-centered and time-centered Poynting flux\n$$\nS_{x}^{n+\\frac{1}{2}}(i+\\frac{1}{2}) = E_{y}^{n+\\frac{1}{2}}(i+\\frac{1}{2}) \\, H_{z}^{n+\\frac{1}{2}}(i+\\frac{1}{2}).\n$$\nWith this construction, the discrete energy balance becomes\n$$\n\\frac{W^{n+1} - W^{n}}{\\Delta t} = - \\sum_{i=0}^{N-1} \\frac{S_{x}^{n+\\frac{1}{2}}(i+\\frac{1}{2}) - S_{x}^{n+\\frac{1}{2}}(i-\\frac{1}{2})}{\\Delta x} \\, \\Delta x,\n$$\nwhich is a telescoping sum over faces. For periodic boundaries, the sum of differences vanishes exactly:\n$$\n\\sum_{i=0}^{N-1} \\left[ S_{x}^{n+\\frac{1}{2}}(i+\\frac{1}{2}) - S_{x}^{n+\\frac{1}{2}}(i-\\frac{1}{2}) \\right] = 0,\n$$\nand therefore, in a source-free periodic domain,\n$$\n\\frac{W^{n+1} - W^{n}}{\\Delta t} = 0.\n$$\n\nFinal computation: Under the consistent face-centered and time-centered averaging scheme, with periodic boundaries and no sources, the discrete energy growth rate is exactly zero. Expressed in Joules per second, the rate is zero. No rounding is required.",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "In realistic plasma simulations, electromagnetic fields are coupled to charge and current sources, but numerical methods for depositing these sources can violate the charge continuity equation, leading to unphysical violations of Gauss's law. This advanced practice addresses this critical challenge by tasking you with implementing a standard correction algorithm. By using a Poisson solver to project the current density onto a charge-conserving space, you will develop a \"divergence cleaning\" technique essential for building robust and accurate coupled simulation codes .",
            "id": "4048223",
            "problem": "Consider a two-dimensional, uniform, periodic Yee-type staggered grid used in finite-difference time-domain electromagnetic calculations for computational fusion science and engineering. In such grids, the charge density is stored at cell centers, and the current density components are stored on cell faces: the $x$-component of current density $J_x$ is stored on faces normal to the $x$-direction (right faces), and the $y$-component $J_y$ is stored on faces normal to the $y$-direction (top faces). The MagnetoHydroDynamics (MHD) system couples plasma fluid with electromagnetic fields, and, in charge-conserving schemes, the discrete continuity equation must hold to preserve Gauss’s law. The discrete continuity equation over one time step is that the charge update and the face-deposited currents satisfy the cell-centered relation\n$$\n\\frac{\\rho^{n+1}_{i,j}-\\rho^{n}_{i,j}}{\\Delta t} + \\left(\\nabla_h\\cdot \\mathbf{J}\\right)_{i,j} = 0,\n$$\nwhere $\\rho$ is the charge density, $\\Delta t$ is the time step, and $\\nabla_h\\cdot \\mathbf{J}$ is the discrete divergence constructed from face-centered $J_x$ and $J_y$. In practical particle-in-cell style depositions or MHD closures, inconsistent current deposition can violate this equation and induce a discrete Gauss’s law error.\n\nYou are to derive, implement, and test a correction algorithm that redistributes current locally to adjacent faces to recover discrete continuity, and quantify the associated Gauss’s law error before and after correction. Work in normalized units with vacuum permittivity $\\epsilon_0 = 1$, grid spacings $\\Delta x = 1$ and $\\Delta y = 1$, and express all outputs as dimensionless floats or booleans with no physical unit symbols.\n\nStarting from Maxwell’s equations and the continuum continuity equation, derive a discrete relation that links the per-cell Gauss’s law error increment to the residual of the discrete continuity equation over one time step. Design a projection-based current correction that computes a cell-centered scalar potential whose face-centered discrete gradient is subtracted from the deposited current to enforce the discrete continuity constraint. Use periodic boundary conditions and a Fourier-based solution of the discrete Poisson equation. Explicitly define the discrete operators consistent with the staggered placement: for a cell indexed by $(i,j)$, define the discrete divergence of face-centered currents by\n$$\n\\left(\\nabla_h\\cdot \\mathbf{J}\\right)_{i,j} = \\frac{1}{\\Delta x}\\left(J_x\\big|_{\\text{right face of }(i,j)} - J_x\\big|_{\\text{right face of }(i-1,j)}\\right) + \\frac{1}{\\Delta y}\\left(J_y\\big|_{\\text{top face of }(i,j)} - J_y\\big|_{\\text{top face of }(i,j-1)}\\right),\n$$\nwith indices interpreted modulo the grid size to enforce periodicity. Define the discrete face-centered gradient of a cell-centered scalar field $\\phi_{i,j}$ as\n$$\n\\left(\\nabla_h \\phi\\right)_x\\big|_{\\text{right face of }(i,j)} = \\frac{\\phi_{i+1,j} - \\phi_{i,j}}{\\Delta x}, \\quad\n\\left(\\nabla_h \\phi\\right)_y\\big|_{\\text{top face of }(i,j)} = \\frac{\\phi_{i,j+1} - \\phi_{i,j}}{\\Delta y}.\n$$\nThese definitions ensure that $\\nabla_h\\cdot \\nabla_h \\phi$ is the standard periodic discrete Laplacian acting on cell centers.\n\nLet the per-cell continuity residual be defined by\n$$\nr_{i,j} = \\frac{\\rho^{n+1}_{i,j}-\\rho^{n}_{i,j}}{\\Delta t} + \\left(\\nabla_h\\cdot \\mathbf{J}\\right)_{i,j}.\n$$\nYou must\n- derive the discrete relation between the Gauss’s law error increment and $r_{i,j}$, assuming $\\epsilon_0 = 1$ and an initial state satisfying discrete Gauss’s law,\n- formulate a correction that finds $\\phi$ from the discrete Poisson equation\n$$\n\\nabla_h\\cdot \\nabla_h \\phi = r,\n$$\nwith the periodic $k=\\left(0,0\\right)$ mode set so that $\\phi$ has zero mean, and then defines corrected currents by\n$$\nJ_x^{\\mathrm{corr}}\\big|_{\\text{right face of }(i,j)} = J_x\\big|_{\\text{right face of }(i,j)} - \\left(\\nabla_h \\phi\\right)_x\\big|_{\\text{right face of }(i,j)}, \\quad\nJ_y^{\\mathrm{corr}}\\big|_{\\text{top face of }(i,j)} = J_y\\big|_{\\text{top face of }(i,j)} - \\left(\\nabla_h \\phi\\right)_y\\big|_{\\text{top face of }(i,j)}.\n$$\nThis redistribution of current is local to adjacent faces because each face correction depends only on differences of neighboring cell-centered potentials.\n\nDefine the Gauss’s law error magnitude per time step as the maximum over cells of the absolute value of the Gauss’s law violation after the step, and use the discrete relation you derive to compute this quantity directly from $r_{i,j}$ without explicitly advancing the electric field. In normalized units with $\\epsilon_0 = 1$, this magnitude is\n$$\nE_{\\mathrm{Gauss}} = \\Delta t \\cdot \\max_{i,j} \\left| r_{i,j} \\right|.\n$$\nAfter correction, recompute the residual with the corrected current and recompute $E_{\\mathrm{Gauss}}$.\n\nImplement the above in a single, self-contained program in the specified runtime environment that constructs the following deterministic test suite. For each case, you must build $\\rho^n$, $J_x$, $J_y$, and $\\rho^{n+1}$ using the specified formulas. Use $i\\in\\{0,\\ldots,N_x-1\\}$ and $j\\in\\{0,\\ldots,N_y-1\\}$ indices with periodicity, and define the dimensionless phase variables $x_c = \\frac{2\\pi (i+0.5)}{N_x}$, $y_c = \\frac{2\\pi (j+0.5)}{N_y}$ to reference cell centers, and, for face-centered currents, reuse these phases in the specified formulas.\n\nTest suite:\n- Case 1 (general nonzero mean-zero residual, happy path):\n  - Grid size $N_x = 8$, $N_y = 8$, time step $\\Delta t = 0.2$.\n  - Build $\\rho^n_{i,j} = 0.5 \\,\\sin(x_c)\\,\\cos(y_c)$.\n  - Build $J_x\\big|_{\\text{right face of }(i,j)} = 0.4 \\,\\sin(x_c)\\,\\sin(y_c)$ and $J_y\\big|_{\\text{top face of }(i,j)} = -0.3 \\,\\cos(x_c)\\,\\sin(y_c)$.\n  - Define a mean-zero inconsistency (fudge) $f_{i,j} = 0.01 \\,\\sin(x_c)\\,\\sin(y_c)$ and set $\\rho^{n+1}_{i,j} = \\rho^n_{i,j} - \\Delta t \\cdot \\left(\\nabla_h\\cdot \\mathbf{J}\\right)_{i,j} + f_{i,j}$.\n- Case 2 (nonzero mean residual, global mode not correctable on a periodic domain):\n  - Grid size $N_x = 8$, $N_y = 8$, time step $\\Delta t = 0.2$.\n  - Use the same $\\rho^n$, $J_x$, and $J_y$ as in Case 1.\n  - Define a constant inconsistency $f_{i,j} = 0.02$ and set $\\rho^{n+1}_{i,j} = \\rho^n_{i,j} - \\Delta t \\cdot \\left(\\nabla_h\\cdot \\mathbf{J}\\right)_{i,j} + f_{i,j}$.\n- Case 3 (exactly consistent deposition, boundary condition check):\n  - Grid size $N_x = 8$, $N_y = 8$, time step $\\Delta t = 0.2$.\n  - Use the same $\\rho^n$, $J_x$, and $J_y$ as in Case 1.\n  - Define $f_{i,j} = 0$ and set $\\rho^{n+1}_{i,j} = \\rho^n_{i,j} - \\Delta t \\cdot \\left(\\nabla_h\\cdot \\mathbf{J}\\right)_{i,j}$.\n- Case 4 (localized inconsistency with zero mean, edge-case structure):\n  - Grid size $N_x = 6$, $N_y = 6$, time step $\\Delta t = 0.15$.\n  - Build $\\rho^n_{i,j} = 0.3 \\,\\sin(x_c)\\,\\cos(y_c)$.\n  - Build $J_x\\big|_{\\text{right face of }(i,j)} = 0.25 \\,\\sin(x_c)\\,\\sin(y_c)$ and $J_y\\big|_{\\text{top face of }(i,j)} = 0.1 \\,\\cos(x_c)\\,\\sin(y_c)$.\n  - Define $f_{i,j}$ zero everywhere except $f_{2,1} = 0.05$ and $f_{4,3} = -0.05$, and set $\\rho^{n+1}_{i,j} = \\rho^n_{i,j} - \\Delta t \\cdot \\left(\\nabla_h\\cdot \\mathbf{J}\\right)_{i,j} + f_{i,j}$.\n\nFor each case, compute the initial continuity residual $r$ from $\\rho^n$, $\\rho^{n+1}$, $J_x$, and $J_y$; compute the initial Gauss’s law error magnitude $E_{\\mathrm{Gauss}}$; compute the correction potential by solving the discrete Poisson equation in Fourier space (periodic boundary conditions, zeroing the $k=\\left(0,0\\right)$ mode); correct the currents by subtracting the discrete face-centered gradient of the potential; recompute the residual and the corrected $E_{\\mathrm{Gauss}}$. For each case, also determine a boolean flag indicating whether the corrected error is less than or equal to the initial error.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is a three-element list $[$initial error magnitude, corrected error magnitude, reduction boolean$]$, one per test case, in the order Case 1, Case 2, Case 3, Case 4. For example, the output must look like $[[e_{1,\\mathrm{init}},e_{1,\\mathrm{corr}},b_1],[e_{2,\\mathrm{init}},e_{2,\\mathrm{corr}},b_2],[e_{3,\\mathrm{init}},e_{3,\\mathrm{corr}},b_3],[e_{4,\\mathrm{init}},e_{4,\\mathrm{corr}},b_4]]$ with floats and booleans only.",
            "solution": "The problem requires the derivation and implementation of a current correction algorithm to enforce the discrete charge continuity equation on a two-dimensional, periodic, staggered Yee grid. We will first derive the necessary theoretical relations, then outline the numerical algorithm, and finally provide the implementation.\n\n### Derivation of the Gauss's Law Error Evolution\n\nThe Maxwell-Faraday and Ampere-Maxwell equations, along with Gauss's laws for electricity and magnetism, form a complete system. Charge conservation is an inherent consequence of this system. The continuum continuity equation is\n$$\n\\frac{\\partial \\rho}{\\partial t} + \\nabla \\cdot \\mathbf{J} = 0\n$$\nwhere $\\rho$ is the charge density and $\\mathbf{J}$ is the current density. Gauss's law for electricity states\n$$\n\\nabla \\cdot \\mathbf{E} = \\frac{\\rho}{\\epsilon_0}\n$$\nTaking the time derivative of Gauss's law yields\n$$\n\\frac{\\partial}{\\partial t} \\left( \\nabla \\cdot \\mathbf{E} - \\frac{\\rho}{\\epsilon_0} \\right) = \\nabla \\cdot \\frac{\\partial \\mathbf{E}}{\\partial t} - \\frac{1}{\\epsilon_0}\\frac{\\partial \\rho}{\\partial t} = 0\n$$\nFrom the Ampere-Maxwell law, $\\frac{\\partial \\mathbf{E}}{\\partial t} = \\frac{1}{\\epsilon_0} \\left( \\frac{1}{\\mu_0}\\nabla\\times\\mathbf{B} - \\mathbf{J} \\right)$. Substituting this into the previous equation and using the vector identity $\\nabla \\cdot (\\nabla \\times \\mathbf{B}) = 0$, we find\n$$\n\\nabla \\cdot \\left( -\\frac{1}{\\epsilon_0} \\mathbf{J} \\right) - \\frac{1}{\\epsilon_0}\\frac{\\partial \\rho}{\\partial t} = 0 \\implies \\frac{\\partial \\rho}{\\partial t} + \\nabla \\cdot \\mathbf{J} = 0\n$$\nThis shows that if Gauss's law holds, the continuity equation is satisfied. Conversely, if the continuity equation is violated, Gauss's law will be violated over time. Let $G = \\nabla \\cdot \\mathbf{E} - \\rho/\\epsilon_0$ be the Gauss's law violation. Its time evolution is governed by\n$$\n\\frac{\\partial G}{\\partial t} = \\frac{1}{\\epsilon_0} \\left( \\frac{\\partial \\rho}{\\partial t} + \\nabla \\cdot \\mathbf{J} \\right)\n$$\nIn a numerical scheme, we work with discrete analogues. Let $G_{i,j}^n = (\\nabla_h \\cdot \\mathbf{E}^n)_{i,j} - \\rho_{i,j}^n/\\epsilon_0$ be the discrete Gauss's law violation at cell $(i,j)$ and time step $n$. A first-order time discretization of the evolution equation gives\n$$\n\\frac{G_{i,j}^{n+1} - G_{i,j}^{n}}{\\Delta t} = \\frac{1}{\\epsilon_0} \\left( \\frac{\\rho_{i,j}^{n+1} - \\rho_{i,j}^{n}}{\\Delta t} + (\\nabla_h \\cdot \\mathbf{J})_{i,j} \\right)\n$$\nThe term in the parenthesis is the discrete continuity equation residual, $r_{i,j}$, as defined in the problem.\n$$\nr_{i,j} = \\frac{\\rho_{i,j}^{n+1} - \\rho_{i,j}^{n}}{\\Delta t} + (\\nabla_h \\cdot \\mathbf{J})_{i,j}\n$$\nThus, the change in Gauss's law violation over one time step is\n$$\nG_{i,j}^{n+1} - G_{i,j}^{n} = \\frac{\\Delta t}{\\epsilon_0} r_{i,j}\n$$\nThe problem states that the initial state satisfies discrete Gauss's law, so $G_{i,j}^n = 0$. With the normalized unit $\\epsilon_0 = 1$, the violation at the next time step is\n$$\nG_{i,j}^{n+1} = \\Delta t \\cdot r_{i,j}\n$$\nThe Gauss's law error magnitude, $E_{\\mathrm{Gauss}}$, is defined as the maximum absolute violation across the grid. This leads directly to the problem's given formula:\n$$\nE_{\\mathrm{Gauss}} = \\max_{i,j} |G_{i,j}^{n+1}| = \\Delta t \\cdot \\max_{i,j} |r_{i,j}|\n$$\nThis derivation validates the relationship we are asked to use.\n\n### Current Correction via Projection Method\n\nThe goal is to find a corrected current, $\\mathbf{J}^{\\mathrm{corr}}$, such that the discrete continuity equation is satisfied exactly. This means the corrected residual, $r^{\\mathrm{corr}}$, must be zero.\n$$\n\\frac{\\rho^{n+1}_{i,j}-\\rho^{n}_{i,j}}{\\Delta t} + (\\nabla_h\\cdot \\mathbf{J}^{\\mathrm{corr}})_{i,j} = 0\n$$\nThe correction should be minimal in some sense. A standard approach, based on the Helmholtz-Hodge decomposition, is to assume the correction is the gradient of a scalar potential, $\\phi$. This ensures the curl of the correction is zero, which is desirable as it does not introduce spurious magnetic fields. We define the corrected current $\\mathbf{J}^{\\mathrm{corr}}$ as\n$$\n\\mathbf{J}^{\\mathrm{corr}} = \\mathbf{J} - \\nabla_h \\phi\n$$\nwhere $\\mathbf{J}$ is the original, inconsistent current. Substituting this into the target continuity equation:\n$$\n\\frac{\\rho^{n+1}_{i,j}-\\rho^{n}_{i,j}}{\\Delta t} + (\\nabla_h\\cdot (\\mathbf{J} - \\nabla_h \\phi))_{i,j} = 0\n$$\nUsing the linearity of the divergence operator, we get\n$$\n\\left( \\frac{\\rho^{n+1}_{i,j}-\\rho^{n}_{i,j}}{\\Delta t} + (\\nabla_h\\cdot \\mathbf{J})_{i,j} \\right) - (\\nabla_h\\cdot \\nabla_h \\phi)_{i,j} = 0\n$$\nThe term in the parenthesis is the original residual, $r_{i,j}$. This leads to a discrete Poisson equation for the correction potential $\\phi$:\n$$\n\\nabla_h \\cdot \\nabla_h \\phi = r\n$$\nThe operator $\\nabla_h \\cdot \\nabla_h$ is the discrete Laplacian. Given the staggered grid definitions for divergence and gradient, and with $\\Delta x = \\Delta y = 1$, it is the standard $5$-point stencil acting on the cell-centered field $\\phi$:\n$$\n(\\nabla_h^2 \\phi)_{i,j} = (\\phi_{i+1,j} - 2\\phi_{i,j} + \\phi_{i-1,j}) + (\\phi_{i,j+1} - 2\\phi_{i,j} + \\phi_{i,j-1})\n$$\n\n### Fourier-Based Poisson Solver\n\nFor periodic boundary conditions, the discrete Poisson equation is efficiently solved in Fourier space. Let $\\hat{\\phi}$ and $\\hat{r}$ be the two-dimensional discrete Fourier transforms (DFTs) of $\\phi$ and $r$, respectively. The DFT transforms discrete convolution (the Laplacian is a convolution) into element-wise multiplication. The Fourier-space representation of the Poisson equation is\n$$\n\\hat{L}(k_x, k_y) \\cdot \\hat{\\phi}(k_x, k_y) = \\hat{r}(k_x, k_y)\n$$\nwhere $\\hat{L}(k_x, k_y)$ is the Fourier symbol of the discrete Laplacian operator. For the $5$-point stencil with $\\Delta x = \\Delta y = 1$, this is\n$$\n\\hat{L}(k_x, k_y) = (e^{ik_x} - 2 + e^{-ik_x}) + (e^{ik_y} - 2 + e^{-ik_y}) = 2(\\cos(k_x) - 1) + 2(\\cos(k_y) - 1)\n$$\nwhere $k_x = 2\\pi m / N_x$ and $k_y = 2\\pi n / N_y$ are the discrete wavenumbers for modes $(m, n)$.\n\nThe potential $\\hat{\\phi}$ can be found by division: $\\hat{\\phi} = \\hat{r} / \\hat{L}$. However, a singularity exists for the $k=(0,0)$ mode (i.e., $m=n=0$), where $k_x=k_y=0$ and $\\hat{L}(0,0) = 0$. This corresponds to the fact that a Poisson equation on a periodic domain is only solvable if the source term has a zero mean. The $(0,0)$ Fourier mode, $\\hat{r}(0,0)$, is proportional to the sum (mean) of $r_{i,j}$ over the grid. If $\\hat{r}(0,0) \\neq 0$, no solution exists.\nThe problem specifies a unique solution by requiring that $\\phi$ has zero mean, which corresponds to setting $\\hat{\\phi}(0,0) = 0$. The overall procedure is:\n1. Compute the residual field $r$.\n2. Compute its DFT, $\\hat{r}$.\n3. Construct the Laplacian symbol $\\hat{L}$. To avoid division by zero, we can regularize $\\hat{L}(0,0)$ to a non-zero value, e.g., $1$.\n4. Compute $\\hat{\\phi} = \\hat{r} / \\hat{L}$.\n5. Enforce the zero-mean condition on the potential by setting $\\hat{\\phi}(0,0) = 0$. This step effectively projects the residual $r$ onto the space of mean-zero fields, discarding any non-zero mean component. The non-correctable part of the residual will be its mean value.\n6. Compute the inverse DFT of $\\hat{\\phi}$ to obtain the real-space potential $\\phi$.\n\n### Summary of the Computational steps\nFor each test case, the algorithm proceeds as follows:\n1. Construct the grid and initial fields $\\rho^n$, $J_x$, $J_y$, and the inconsistency term $f_{i,j}$ according to the case specifications.\n2. Compute the discrete divergence $(\\nabla_h \\cdot \\mathbf{J})_{i,j}$ using periodic shifts.\n3. Compute $\\rho^{n+1}_{i,j} = \\rho^n_{i,j} - \\Delta t \\cdot (\\nabla_h\\cdot \\mathbf{J})_{i,j} + f_{i,j}$.\n4. Compute the initial residual $r_{i,j} = (\\rho^{n+1}_{i,j} - \\rho^n_{i,j}) / \\Delta t + (\\nabla_h \\cdot \\mathbf{J})_{i,j}$. As derived, this simplifies to $r_{i,j} = f_{i,j}/\\Delta t$.\n5. Compute the initial Gauss's law error magnitude $E_{\\mathrm{Gauss, init}} = \\Delta t \\cdot \\max_{i,j}|r_{i,j}| = \\max_{i,j}|f_{i,j}|$.\n6. Solve the discrete Poisson equation $\\nabla_h^2\\phi = r$ using the Fourier method described above to find $\\phi$.\n7. Compute the discrete gradient of $\\phi$ to find the correction for the currents: $(\\nabla_h\\phi)_x$ and $(\\nabla_h\\phi)_y$.\n8. Calculate the corrected currents: $J_x^{\\mathrm{corr}} = J_x - (\\nabla_h\\phi)_x$ and $J_y^{\\mathrm{corr}} = J_y - (\\nabla_h\\phi)_y$.\n9. Recompute the residual $r^{\\mathrm{corr}}$ using the corrected currents $J_x^{\\mathrm{corr}}, J_y^{\\mathrm{corr}}$.\n10. Compute the corrected Gauss's law error magnitude $E_{\\mathrm{Gauss, corr}} = \\Delta t \\cdot \\max_{i,j}|r^{\\mathrm{corr}}_{i,j}|$.\n11. Determine the boolean flag indicating if $E_{\\mathrm{Gauss, corr}} \\le E_{\\mathrm{Gauss, init}}$.\n\nThis procedure will be applied to each test case to produce the final results.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_poisson_fourier(r_field, dx, dy):\n    \"\"\"\n    Solves the 2D discrete Poisson equation Nabla^2(phi) = r_field\n    on a periodic domain using Fourier methods.\n    \"\"\"\n    Nx, Ny = r_field.shape\n    \n    # 1. Compute the 2D DFT of the source term r_field.\n    r_hat = np.fft.fftn(r_field)\n\n    # 2. Construct the Fourier symbol of the discrete Laplacian.\n    kx = 2 * np.pi * np.fft.fftfreq(Nx, d=dx)\n    ky = 2 * np.pi * np.fft.fftfreq(Ny, d=dy)\n    kxx, kyy = np.meshgrid(kx, ky, indexing='ij')\n    \n    lap_hat = 2 * (np.cos(kxx) - 1) / (dx**2) + 2 * (np.cos(kyy) - 1) / (dy**2)\n    \n    # 3. Regularize the k=(0,0) mode to avoid division by zero.\n    lap_hat[0, 0] = 1.0\n    \n    # 4. Solve for phi_hat in Fourier space.\n    phi_hat = r_hat / lap_hat\n    \n    # 5. Enforce zero mean for phi by setting the k=(0,0) mode to zero.\n    phi_hat[0, 0] = 0.0\n    \n    # 6. Inverse transform to get the potential phi in real space.\n    # The result should be real since the input r_field is real.\n    phi = np.fft.ifftn(phi_hat).real\n    \n    return phi\n\ndef run_case(case_params):\n    \"\"\"\n    Runs a single test case for the current correction algorithm.\n    \"\"\"\n    Nx, Ny, dt, rho_n_func, Jx_func, Jy_func, f_func = case_params\n    dx, dy = 1.0, 1.0\n\n    # Setup grid and phases\n    i = np.arange(Nx)\n    j = np.arange(Ny)\n    ii, jj = np.meshgrid(i, j, indexing='ij')\n    xc = 2 * np.pi * (ii + 0.5) / Nx\n    yc = 2 * np.pi * (jj + 0.5) / Ny\n\n    # Build initial fields\n    rho_n = rho_n_func(xc, yc)\n    Jx = Jx_func(xc, yc)\n    Jy = Jy_func(xc, yc)\n    f = f_func(xc, yc, Nx, Ny)\n\n    # Compute discrete divergence of J\n    # Jx_i-1,j is at the left face of cell (i,j)\n    Jx_left = np.roll(Jx, 1, axis=0) \n    # Jy_i,j-1 is at the bottom face of cell (i,j)\n    Jy_bottom = np.roll(Jy, 1, axis=1) \n    \n    div_J = (Jx - Jx_left) / dx + (Jy - Jy_bottom) / dy\n\n    # Define rho^{n+1} as per problem statement\n    rho_np1 = rho_n - dt * div_J + f\n\n    # --- Initial Error Calculation ---\n    # Compute initial continuity residual, r = (rho_np1 - rho_n)/dt + div_J\n    # Analytically, this simplifies to r = f / dt\n    r_init = (rho_np1 - rho_n) / dt + div_J\n    \n    # Compute initial Gauss's law error magnitude\n    E_gauss_init = dt * np.max(np.abs(r_init))\n\n    # --- Correction ---\n    # 1. Solve Poisson's equation for the correction potential phi\n    phi = solve_poisson_fourier(r_init, dx, dy)\n\n    # 2. Compute the gradient of phi\n    grad_phi_x = (np.roll(phi, -1, axis=0) - phi) / dx\n    grad_phi_y = (np.roll(phi, -1, axis=1) - phi) / dy\n\n    # 3. Correct the currents\n    Jx_corr = Jx - grad_phi_x\n    Jy_corr = Jy - grad_phi_y\n\n    # --- Corrected Error Calculation ---\n    # Recompute the divergence with corrected currents\n    Jx_corr_left = np.roll(Jx_corr, 1, axis=0)\n    Jy_corr_bottom = np.roll(Jy_corr, 1, axis=1)\n    div_J_corr = (Jx_corr - Jx_corr_left) / dx + (Jy_corr - Jy_corr_bottom) / dy\n    \n    # Recompute the residual with corrected currents\n    r_corr = (rho_np1 - rho_n) / dt + div_J_corr\n    \n    # Compute corrected Gauss's law error magnitude\n    E_gauss_corr = dt * np.max(np.abs(r_corr))\n\n    # Determine if error was reduced\n    reduction_bool = E_gauss_corr = E_gauss_init\n\n    return [E_gauss_init, E_gauss_corr, reduction_bool]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        (8, 8, 0.2, \n         lambda xc, yc: 0.5 * np.sin(xc) * np.cos(yc),\n         lambda xc, yc: 0.4 * np.sin(xc) * np.sin(yc),\n         lambda xc, yc: -0.3 * np.cos(xc) * np.sin(yc),\n         lambda xc, yc, Nx, Ny: 0.01 * np.sin(xc) * np.sin(yc)),\n        # Case 2\n        (8, 8, 0.2, \n         lambda xc, yc: 0.5 * np.sin(xc) * np.cos(yc),\n         lambda xc, yc: 0.4 * np.sin(xc) * np.sin(yc),\n         lambda xc, yc: -0.3 * np.cos(xc) * np.sin(yc),\n         lambda xc, yc, Nx, Ny: 0.02 * np.ones((Nx, Ny))),\n        # Case 3\n        (8, 8, 0.2,\n         lambda xc, yc: 0.5 * np.sin(xc) * np.cos(yc),\n         lambda xc, yc: 0.4 * np.sin(xc) * np.sin(yc),\n         lambda xc, yc: -0.3 * np.cos(xc) * np.sin(yc),\n         lambda xc, yc, Nx, Ny: np.zeros((Nx, Ny))),\n        # Case 4\n        (6, 6, 0.15,\n         lambda xc, yc: 0.3 * np.sin(xc) * np.cos(yc),\n         lambda xc, yc: 0.25 * np.sin(xc) * np.sin(yc),\n         lambda xc, yc: 0.1 * np.cos(xc) * np.sin(yc),\n         lambda xc, yc, Nx, Ny: (\n             (f_arr := np.zeros((Nx, Ny)), \n              f_arr.__setitem__((2, 1), 0.05),\n              f_arr.__setitem__((4, 3), -0.05),\n              f_arr)[-1]\n         )),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_case(case)\n        results.append(result)\n    \n    # Custom string formatting to match Python's default representation\n    # which seems to be the intended format.\n    results_str = []\n    for res in results:\n        # Format boolean as TitleCase as per Python's str(bool)\n        # Format floats with reasonable precision for clean output\n        formatted_res = f\"[{res[0]:.17g}, {res[1]:.17g}, {str(res[2])}]\"\n        results_str.append(formatted_res)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        }
    ]
}