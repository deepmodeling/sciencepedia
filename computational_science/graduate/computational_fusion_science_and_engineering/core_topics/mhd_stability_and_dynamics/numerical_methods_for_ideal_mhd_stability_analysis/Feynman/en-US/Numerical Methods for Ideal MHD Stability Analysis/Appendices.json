{
    "hands_on_practices": [
        {
            "introduction": "This first practice provides a crucial bridge from the abstract theory of the MHD energy principle to a concrete calculation. By discretizing the system onto a single basis function, you will directly evaluate the terms that contribute to the stability of a simple plasma slab. This exercise is designed to build physical intuition, revealing how stabilizing forces like magnetic field line bending and plasma compression are mathematically represented in the eigenvalue problem .",
            "id": "4022879",
            "problem": "Consider the linear stability of a static equilibrium in Ideal Magnetohydrodynamics (MHD) for a slab plasma of thickness $L$ in the $x$-direction, with uniform magnetic field $\\mathbf{B}_{0} = B_{0} \\hat{z}$, constant mass density $\\rho_{0}$, and equilibrium pressure $p_{0}(x) = p_{a} + \\alpha x$ satisfying $p_{0}(x) > 0$ for $x \\in [0,L]$. The plasma is bounded by perfectly conducting, line-tied walls at $x=0$ and $x=L$ such that the normal displacement satisfies $\\xi_{x}(0) = \\xi_{x}(L) = 0$. Assume periodicity in $z$ with a single Fourier harmonic $\\exp(i k_{z} z)$ and no variation in $y$.\n\nStarting from the linearized ideal MHD equations and the energy principle for small perturbations, formulate the self-adjoint generalized eigenvalue problem for the normal mode displacement $\\boldsymbol{\\xi}$ in the weak (variational) form $\\mathbf{A} \\mathbf{c} = \\omega^{2} \\mathbf{B} \\mathbf{c}$, where $\\omega$ is the mode frequency, $\\mathbf{A}$ is the stiffness operator arising from magnetic and pressure forces, $\\mathbf{B}$ is the mass operator, and $\\mathbf{c}$ are the coefficients in a chosen basis for $\\boldsymbol{\\xi}$. Restrict to a single basis function for the displacement of the form\n$$\n\\boldsymbol{\\xi}(x,z) = c_{1} \\, \\phi_{1}(x) \\, \\hat{x} \\, \\exp(i k_{z} z), \\quad \\phi_{1}(x) = \\sqrt{\\frac{2}{L}} \\sin\\!\\left(\\frac{\\pi x}{L}\\right),\n$$\nwhich satisfies the line-tied boundary conditions. Assemble the scalar entries $A_{11}$ and $B_{11}$ of the discrete operators $\\mathbf{A}$ and $\\mathbf{B}$ by evaluating the appropriate volume integrals over $x \\in [0,L]$ and one period in $z$; you may leave any transverse cross-sectional area factors symbolically, and you must retain all parameters symbolically, including $B_{0}$, $\\mu_{0}$, $\\gamma$, $p_{a}$, $\\alpha$, $L$, $k_{z}$, and $\\rho_{0}$. Using these explicit assembled entries, compute the resulting one-degree-of-freedom generalized eigenvalue\n$$\n\\omega^{2} = \\frac{A_{11}}{B_{11}},\n$$\nas a closed-form analytic expression. Express the final answer as a single analytic expression. No numerical substitution is required and no rounding is permitted.",
            "solution": "The problem statement has been critically validated and is deemed to be scientifically grounded, well-posed, objective, and self-contained. The provided equilibrium and perturbation forms are standard for a pedagogical problem in ideal magnetohydrodynamics (MHD) stability analysis. The task is to evaluate the generalized eigenvalue $\\omega^2$ by projecting the system's dynamics onto a single provided basis function, which is a standard application of the Rayleigh-Ritz variational method.\n\nThe starting point is the generalized eigenvalue problem derived from the linearized ideal MHD equations, expressed in weak (variational) form. For a perturbation $\\boldsymbol{\\xi}$, the equation of motion is $\\rho_0 \\frac{\\partial^2 \\boldsymbol{\\xi}}{\\partial t^2} = \\mathbf{F}(\\boldsymbol{\\xi})$, where $\\mathbf{F}(\\boldsymbol{\\xi})$ is the linear force operator. Assuming a harmonic time dependence $\\boldsymbol{\\xi} \\sim \\exp(-i\\omega t)$, this becomes $-\\omega^2 \\rho_0 \\boldsymbol{\\xi} = \\mathbf{F}(\\boldsymbol{\\xi})$.\n\nThe weak form is obtained from the energy principle. The potential energy functional $\\delta W$ and the kinetic energy functional $K$ are given by:\n$$ \\delta W(\\boldsymbol{\\xi}) = -\\frac{1}{2}\\int \\boldsymbol{\\xi}^* \\cdot \\mathbf{F}(\\boldsymbol{\\xi}) \\, dV $$\n$$ K(\\boldsymbol{\\xi}) = \\frac{1}{2}\\int \\rho_0 |\\boldsymbol{\\xi}|^2 \\, dV $$\nThe eigenvalue $\\omega^2$ is the stationary value of the Rayleigh quotient $\\omega^2 = \\delta W / K$. For the static equilibrium defined in the problem, with equilibrium current density $\\mathbf{J}_0 = \\frac{1}{\\mu_0}\\nabla \\times \\mathbf{B}_0 = 0$, the potential energy functional simplifies to:\n$$ \\delta W = \\frac{1}{2} \\int \\left[ \\frac{|\\mathbf{Q}|^2}{\\mu_0} + \\gamma p_0 |\\nabla \\cdot \\boldsymbol{\\xi}|^2 + (\\nabla \\cdot \\boldsymbol{\\xi}^*)(\\boldsymbol{\\xi} \\cdot \\nabla p_0) \\right] \\, dV $$\nwhere $\\mathbf{Q} = \\nabla \\times (\\boldsymbol{\\xi} \\times \\mathbf{B}_0)$.\n\nThe problem restricts the displacement vector to a single basis function $\\boldsymbol{\\xi}_1$:\n$$ \\boldsymbol{\\xi}(x,z,t) = c_1 \\boldsymbol{\\xi}_1(x,z) \\exp(-i\\omega t) \\quad \\text{with} \\quad \\boldsymbol{\\xi}_1(x,z) = \\phi_{1}(x) \\, \\hat{x} \\, \\exp(i k_{z} z) $$\nwhere $\\phi_1(x) = \\sqrt{\\frac{2}{L}} \\sin\\left(\\frac{\\pi x}{L}\\right)$. This basis function satisfies the boundary conditions $\\xi_x(0) = \\xi_x(L) = 0$.\n\nSubstituting this into the energy principle gives $\\omega^2 |c_1|^2 K(\\boldsymbol{\\xi}_1) = |c_1|^2 \\delta W(\\boldsymbol{\\xi}_1)$. The generalized eigenvalue problem $\\mathbf{A} \\mathbf{c} = \\omega^{2} \\mathbf{B} \\mathbf{c}$ reduces to a scalar equation $A_{11} c_1 = \\omega^2 B_{11} c_1$, where:\n$$ A_{11} = 2 \\delta W(\\boldsymbol{\\xi}_1) = \\int \\left[ \\frac{|\\mathbf{Q}_1|^2}{\\mu_0} + \\gamma p_0 |\\nabla \\cdot \\boldsymbol{\\xi}_1|^2 + (\\nabla \\cdot \\boldsymbol{\\xi}_1^*)(\\boldsymbol{\\xi}_1 \\cdot \\nabla p_0) \\right] \\, dV $$\n$$ B_{11} = 2 K(\\boldsymbol{\\xi}_1) = \\int \\rho_0 |\\boldsymbol{\\xi}_1|^2 \\, dV $$\nThe volume integral is over the domain $x \\in [0,L]$ and one period in the transverse directions. Let the cross-sectional area in the $y-z$ plane be $A_{\\perp}$.\n\nFirst, we compute the mass matrix element $B_{11}$:\n$$ \\boldsymbol{\\xi}_1 = \\phi_1(x) \\exp(ik_z z) \\hat{x} \\implies |\\boldsymbol{\\xi}_1|^2 = \\phi_1(x)^2 $$\n$$ B_{11} = \\int \\rho_0 \\phi_1(x)^2 \\, dV = \\rho_0 A_{\\perp} \\int_0^L \\phi_1(x)^2 \\, dx $$\nThe basis function is normalized such that $\\int_0^L \\phi_1(x)^2 \\, dx = \\int_0^L \\frac{2}{L} \\sin^2\\left(\\frac{\\pi x}{L}\\right) dx = \\frac{2}{L} \\frac{L}{2} = 1$.\n$$ B_{11} = \\rho_0 A_{\\perp} $$\n\nNext, we compute the stiffness matrix element $A_{11}$ by evaluating its three constituent terms.\n\nTerm 1: Magnetic field perturbation energy.\n$\\mathbf{B}_0 = B_0 \\hat{z}$ and $\\boldsymbol{\\xi}_1 = \\phi_1(x) \\exp(ik_z z) \\hat{x}$.\n$$ \\boldsymbol{\\xi}_1 \\times \\mathbf{B}_0 = -B_0 \\phi_1(x) \\exp(ik_z z) \\hat{y} $$\n$$ \\mathbf{Q}_1 = \\nabla \\times (\\boldsymbol{\\xi}_1 \\times \\mathbf{B}_0) = -B_0 \\left[ \\frac{\\partial}{\\partial z}(\\phi_1 e^{ik_z z}) \\hat{x} - \\frac{\\partial}{\\partial x}(\\phi_1 e^{ik_z z}) \\hat{z} \\right] = -B_0 e^{ik_z z} \\left( i k_z \\phi_1(x) \\hat{x} - \\phi_1'(x) \\hat{z} \\right) $$\nwhere $\\phi_1'(x) = d\\phi_1/dx$.\n$$ |\\mathbf{Q}_1|^2 = B_0^2 \\left( k_z^2 \\phi_1(x)^2 + [\\phi_1'(x)]^2 \\right) $$\nThe integral of this term is:\n$$ \\int \\frac{|\\mathbf{Q}_1|^2}{\\mu_0} dV = \\frac{A_{\\perp} B_0^2}{\\mu_0} \\int_0^L \\left( k_z^2 \\phi_1(x)^2 + [\\phi_1'(x)]^2 \\right) dx $$\nWe need the integral of $[\\phi_1'(x)]^2$:\n$$ \\phi_1'(x) = \\sqrt{\\frac{2}{L}} \\frac{\\pi}{L} \\cos\\left(\\frac{\\pi x}{L}\\right) $$\n$$ \\int_0^L [\\phi_1'(x)]^2 dx = \\frac{2\\pi^2}{L^3} \\int_0^L \\cos^2\\left(\\frac{\\pi x}{L}\\right) dx = \\frac{2\\pi^2}{L^3} \\frac{L}{2} = \\frac{\\pi^2}{L^2} $$\nUsing $\\int_0^L \\phi_1(x)^2 dx = 1$, the first term of $A_{11}$ is:\n$$ A_{11}^{(1)} = \\frac{A_{\\perp} B_0^2}{\\mu_0} \\left( k_z^2 \\cdot 1 + \\frac{\\pi^2}{L^2} \\right) $$\n\nTerm 2: Plasma compression energy.\n$$ \\nabla \\cdot \\boldsymbol{\\xi}_1 = \\frac{\\partial \\xi_{1,x}}{\\partial x} = \\phi_1'(x) \\exp(ik_z z) \\implies |\\nabla \\cdot \\boldsymbol{\\xi}_1|^2 = [\\phi_1'(x)]^2 $$\nThe integral of this term is:\n$$ \\int \\gamma p_0(x) |\\nabla \\cdot \\boldsymbol{\\xi}_1|^2 dV = A_{\\perp} \\gamma \\int_0^L p_0(x) [\\phi_1'(x)]^2 dx $$\nSubstituting $p_0(x) = p_a + \\alpha x$ and $[\\phi_1'(x)]^2 = \\frac{2\\pi^2}{L^3} \\cos^2\\left(\\frac{\\pi x}{L}\\right)$:\n$$ \\int_0^L (p_a + \\alpha x) \\frac{2\\pi^2}{L^3} \\cos^2\\left(\\frac{\\pi x}{L}\\right) dx = \\frac{2\\pi^2}{L^3} \\left[ p_a \\int_0^L \\cos^2\\left(\\frac{\\pi x}{L}\\right) dx + \\alpha \\int_0^L x \\cos^2\\left(\\frac{\\pi x}{L}\\right) dx \\right] $$\nThe integrals are $\\int_0^L \\cos^2(\\frac{\\pi x}{L}) dx = L/2$ and $\\int_0^L x \\cos^2(\\frac{\\pi x}{L}) dx = \\frac{L^2}{4}$.\nSo the integral becomes $\\frac{2\\pi^2}{L^3} \\left( p_a \\frac{L}{2} + \\alpha \\frac{L^2}{4} \\right) = \\frac{\\pi^2}{L^2} \\left( p_a + \\frac{\\alpha L}{2} \\right)$.\nThe second term of $A_{11}$ is:\n$$ A_{11}^{(2)} = A_{\\perp} \\gamma \\frac{\\pi^2}{L^2} \\left( p_a + \\frac{\\alpha L}{2} \\right) $$\n\nTerm 3: Pressure gradient energy.\nThe integrand is $(\\nabla \\cdot \\boldsymbol{\\xi}_1^*)(\\boldsymbol{\\xi}_1 \\cdot \\nabla p_0)$.\n$\\nabla p_0 = \\alpha \\hat{x}$. $\\boldsymbol{\\xi}_1 \\cdot \\nabla p_0 = \\alpha \\phi_1(x) \\exp(ik_z z)$.\n$\\nabla \\cdot \\boldsymbol{\\xi}_1^* = \\phi_1'(x) \\exp(-ik_z z)$.\nThe product is $\\alpha \\phi_1(x) \\phi_1'(x)$. The integral is:\n$$ A_{11}^{(3)} = A_{\\perp} \\alpha \\int_0^L \\phi_1(x) \\phi_1'(x) dx = A_{\\perp} \\alpha \\left[ \\frac{1}{2}\\phi_1(x)^2 \\right]_0^L = \\frac{A_{\\perp} \\alpha}{2} (\\phi_1(L)^2 - \\phi_1(0)^2) $$\nSince $\\phi_1(0)=\\phi_1(L)=0$, this term is zero: $A_{11}^{(3)} = 0$.\n\nCombining the terms, we get the total $A_{11}$:\n$$ A_{11} = A_{11}^{(1)} + A_{11}^{(2)} + A_{11}^{(3)} = A_{\\perp} \\left[ \\frac{B_0^2}{\\mu_0} \\left( k_z^2 + \\frac{\\pi^2}{L^2} \\right) + \\gamma \\frac{\\pi^2}{L^2} \\left( p_a + \\frac{\\alpha L}{2} \\right) \\right] $$\n\nFinally, the square of the mode frequency is the ratio $\\omega^2 = A_{11}/B_{11}$:\n$$ \\omega^2 = \\frac{A_{\\perp} \\left[ \\frac{B_0^2}{\\mu_0} \\left( k_z^2 + \\frac{\\pi^2}{L^2} \\right) + \\gamma \\frac{\\pi^2}{L^2} \\left( p_a + \\frac{\\alpha L}{2} \\right) \\right]}{A_{\\perp} \\rho_0} $$\nThe area factor $A_{\\perp}$ cancels, yielding the final expression:\n$$ \\omega^2 = \\frac{1}{\\rho_0} \\left[ \\frac{B_0^2}{\\mu_0} \\left( k_z^2 + \\frac{\\pi^2}{L^2} \\right) + \\gamma \\left( p_a + \\frac{\\alpha L}{2} \\right) \\frac{\\pi^2}{L^2} \\right] $$\nThis expression is always positive given $p_0(x) > 0$ on the domain, indicating that this specific mode is stable. This result corresponds to a fast magnetosonic wave, where stability is provided by magnetic field line bending and plasma compression.",
            "answer": "$$ \\boxed{ \\frac{1}{\\rho_{0}} \\left[ \\frac{B_{0}^{2}}{\\mu_{0}} \\left( k_{z}^{2} + \\frac{\\pi^{2}}{L^{2}} \\right) + \\gamma \\left( p_{a} + \\frac{\\alpha L}{2} \\right) \\frac{\\pi^{2}}{L^{2}} \\right] } $$"
        },
        {
            "introduction": "A correct numerical solver is the foundation of any computational study, but how can we be certain our code is free of bugs? This exercise introduces the Method of Manufactured Solutions (MMS), a powerful and essential technique for code verification. You will construct an analytic solution, derive the corresponding source terms, and use this manufactured problem to rigorously test that your finite-difference implementation of the MHD operator is correct, a fundamental skill for any computational scientist .",
            "id": "4022928",
            "problem": "You are to construct and verify a manufactured solution for a simplified linear operator derived from the linearized equations of ideal Magnetohydrodynamics (MHD) in slab geometry. The purpose of this manufactured solution is to validate the discrete assembly and solver pipeline against a known analytic displacement field and source terms.\n\nStart from the following foundational base and assumptions:\n\n- Ideal Magnetohydrodynamics (MHD) with adiabatic closure: linearized momentum and induction equations in a static, homogeneous equilibrium.\n- Background fields are uniform and constant: density $\\rho_0$, thermal pressure $p_0$, and magnetic field $\\mathbf{B}_0 = B_0 \\,\\hat{\\mathbf{z}}$.\n- Normal mode dependence in the ignorable directions $y$ and $z$, such that all perturbed quantities have Fourier dependence $\\exp(i k_y y + i k_z z)$, and the spatial variation is retained only along the slab coordinate $x$.\n- The displacement field $\\boldsymbol{\\xi}(x)$ is treated component-wise with a scalar self-adjoint operator representative of the combined compressional stiffness and magnetic tension in slab geometry.\n\nUnder these assumptions, consider the scalar operator acting on a generic component $\\xi(x)$ given by\n$$\n\\mathcal{L}[\\xi](x) \\equiv -\\frac{d}{dx}\\left( C \\,\\frac{d \\xi}{dx} \\right) + M \\, k_\\perp^2 \\,\\xi(x),\n$$\nwhere $C = \\gamma \\, p_0 + \\frac{B_0^2}{\\mu_0}$, $M = \\frac{B_0^2}{\\mu_0}$, and $k_\\perp^2 = k_y^2 + k_z^2$. Here $\\gamma$ is the adiabatic index, and $\\mu_0$ is the permeability of free space.\n\nDefine the manufactured analytic displacement vector field on the domain $x \\in [0,L]$ with homogeneous Dirichlet boundary conditions $\\boldsymbol{\\xi}(0) = \\boldsymbol{\\xi}(L) = \\mathbf{0}$:\n$$\n\\xi_x(x) = A \\,\\sin\\left(\\frac{\\pi x}{L}\\right), \\quad\n\\xi_y(x) = A \\,\\sin\\left(\\frac{2\\pi x}{L}\\right), \\quad\n\\xi_z(x) = A \\,\\sin\\left(\\frac{3\\pi x}{L}\\right),\n$$\nwith amplitude $A = 1 \\,\\mathrm{m}$ so that the displacement has units of meters.\n\nFor each component, define the source term by substituting the analytic $\\xi$ into the operator:\n$$\nf_x(x) = \\mathcal{L}[\\xi_x](x), \\quad f_y(x) = \\mathcal{L}[\\xi_y](x), \\quad f_z(x) = \\mathcal{L}[\\xi_z](x).\n$$\nWith constant $C$ and $M$, these source terms satisfy\n$$\nf_n(x) = \\left[ C \\left( \\frac{n\\pi}{L} \\right)^2 + M k_\\perp^2 \\right] \\xi_n(x), \\quad n \\in \\{1,2,3\\},\n$$\nwhere $\\xi_n$ denotes the component with wavenumber factor $n$ in $x$.\n\nYour task is to implement a second-order centered finite-difference discretization of the operator $\\mathcal{L}$ on a uniform grid of $N$ points over $[0,L]$ with homogeneous Dirichlet boundary conditions for each component, assemble the discrete linear system\n$$\n\\mathbf{A} \\mathbf{u}_n = \\mathbf{f}_n, \\quad n \\in \\{1,2,3\\},\n$$\nsolve for $\\mathbf{u}_n$, and compare against the discrete sampling of the manufactured analytic solution $\\boldsymbol{\\xi}(x)$ at interior points. The discrete matrix $\\mathbf{A}$ for interior points should implement\n$$\n\\mathbf{A} = -C \\,\\mathbf{D}^{(2)} + M k_\\perp^2 \\,\\mathbf{I},\n$$\nwhere $\\mathbf{D}^{(2)}$ is the standard second-derivative matrix for homogeneous Dirichlet boundaries:\n$$\n\\left(\\mathbf{D}^{(2)} \\mathbf{v}\\right)_i = \\frac{v_{i+1} - 2 v_i + v_{i-1}}{h^2}, \\quad h = \\frac{L}{N-1},\n$$\nand $\\mathbf{I}$ is the identity.\n\nCompute the maximum absolute error between the numerical solution and the manufactured analytic solution at the interior grid points for each test case. Express the error in meters. The final output should be a single list of floats, one per test case, giving the maximum absolute error across all three components for that case.\n\nUse the following physical constants and units:\n- $\\mu_0 = 4\\pi \\times 10^{-7} \\,\\mathrm{H/m}$,\n- $\\gamma$ is dimensionless,\n- $p_0$ in $\\mathrm{Pa}$,\n- $B_0$ in $\\mathrm{T}$,\n- $L$ in $\\mathrm{m}$,\n- $k_y$ and $k_z$ in $\\mathrm{rad/m}$,\n- Displacement amplitude $A$ in $\\mathrm{m}$,\n- Errors must be expressed in $\\mathrm{m}$.\n\nTest Suite:\nProvide results for the following parameter sets to ensure coverage of typical behavior, degeneracy in transverse wavenumbers, coarse resolution, and high stiffness.\n\n- Case 1 (happy path):\n  - $L = 1.0 \\,\\mathrm{m}$,\n  - $N = 200$,\n  - $\\gamma = \\frac{5}{3}$,\n  - $p_0 = 2.0 \\times 10^{3} \\,\\mathrm{Pa}$,\n  - $B_0 = 1.0 \\,\\mathrm{T}$,\n  - $k_y = 5.0 \\,\\mathrm{rad/m}$,\n  - $k_z = 3.0 \\,\\mathrm{rad/m}$.\n\n- Case 2 (transverse wavenumber degeneracy):\n  - $L = 1.0 \\,\\mathrm{m}$,\n  - $N = 50$,\n  - $\\gamma = \\frac{5}{3}$,\n  - $p_0 = 1.0 \\times 10^{3} \\,\\mathrm{Pa}$,\n  - $B_0 = 1.0 \\,\\mathrm{T}$,\n  - $k_y = 0.0 \\,\\mathrm{rad/m}$,\n  - $k_z = 0.0 \\,\\mathrm{rad/m}$.\n\n- Case 3 (coarse grid, stronger field):\n  - $L = 1.0 \\,\\mathrm{m}$,\n  - $N = 10$,\n  - $\\gamma = \\frac{5}{3}$,\n  - $p_0 = 2.0 \\times 10^{5} \\,\\mathrm{Pa}$,\n  - $B_0 = 3.0 \\,\\mathrm{T}$,\n  - $k_y = 10.0 \\,\\mathrm{rad/m}$,\n  - $k_z = 0.0 \\,\\mathrm{rad/m}$.\n\n- Case 4 (short domain, high stiffness and resolution):\n  - $L = 0.5 \\,\\mathrm{m}$,\n  - $N = 300$,\n  - $\\gamma = \\frac{5}{3}$,\n  - $p_0 = 1.0 \\times 10^{5} \\,\\mathrm{Pa}$,\n  - $B_0 = 5.0 \\,\\mathrm{T}$,\n  - $k_y = 20.0 \\,\\mathrm{rad/m}$,\n  - $k_z = 20.0 \\,\\mathrm{rad/m}$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the maximum absolute errors for the four test cases as a comma-separated list enclosed in square brackets, for example\n$$\n[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4],\n$$\nwhere each $\\varepsilon_i$ is a float in meters.",
            "solution": "We start from the linearized equations of ideal Magnetohydrodynamics (MHD) in a static, homogeneous equilibrium. The force balance for small perturbations in terms of the Lagrangian displacement $\\boldsymbol{\\xi}$ satisfies\n$$\n\\rho_0 \\frac{\\partial^2 \\boldsymbol{\\xi}}{\\partial t^2} = \\mathbf{F}(\\boldsymbol{\\xi}),\n$$\nwhere the linear force operator $\\mathbf{F}$ for adiabatic dynamics with adiabatic index $\\gamma$ is\n$$\n\\mathbf{F}(\\boldsymbol{\\xi}) = -\\nabla(\\gamma p_0 \\nabla \\cdot \\boldsymbol{\\xi}) + \\frac{1}{\\mu_0} \\left( \\nabla \\times (\\boldsymbol{\\xi} \\times \\mathbf{B}_0) \\right) \\times \\mathbf{B}_0.\n$$\nFor a uniform background magnetic field $\\mathbf{B}_0 = B_0 \\hat{\\mathbf{z}}$ and uniform pressure $p_0$, the expression simplifies while preserving self-adjointness. In slab geometry, it is standard to assume Fourier dependence in the ignorable coordinates, writing $\\exp(i k_y y + i k_z z)$, which reduces derivatives in $y$ and $z$ to multiplications by $i k_y$ and $i k_z$, respectively. The remaining spatial variation is along $x$, and one seeks a reduced ordinary differential operator in $x$.\n\nIn such a uniform medium, the compressional pressure term contributes a stiffness proportional to $\\gamma p_0$ times curvature and divergence, and the magnetic tension contributes stiffness proportional to $B_0^2/\\mu_0$ times curvature of the field lines. For the purposes of code verification with manufactured solutions, it is common and scientifically sound to adopt a self-adjoint scalar operator capturing the principal stiffness contributions component-wise:\n$$\n\\mathcal{L}[\\xi](x) \\equiv -\\frac{d}{dx}\\left( C \\,\\frac{d \\xi}{dx} \\right) + M \\, k_\\perp^2 \\,\\xi(x),\n$$\nwith constants\n$$\nC = \\gamma p_0 + \\frac{B_0^2}{\\mu_0}, \\quad M = \\frac{B_0^2}{\\mu_0}, \\quad k_\\perp^2 = k_y^2 + k_z^2.\n$$\nThis form is consistent with the energy principle in slab coordinates for uniform media and Fourier harmonics in $y$ and $z$: the term $-d/dx(C d\\xi/dx)$ models combined compressional and magnetic stiffness along $x$, and the term $M k_\\perp^2 \\xi$ models magnetic tension associated with transverse wavenumbers.\n\nTo verify the assembly and solver pipeline, we choose a manufactured analytic solution for the displacement components:\n$$\n\\xi_x(x) = A \\,\\sin\\left(\\frac{\\pi x}{L}\\right), \\quad\n\\xi_y(x) = A \\,\\sin\\left(\\frac{2\\pi x}{L}\\right), \\quad\n\\xi_z(x) = A \\,\\sin\\left(\\frac{3\\pi x}{L}\\right),\n$$\nwith $A = 1\\,\\mathrm{m}$. These satisfy homogeneous Dirichlet boundary conditions at $x=0$ and $x=L$. Substituting into the operator, and noting that for constant $C$ the second derivative is\n$$\n\\frac{d^2}{dx^2} \\sin\\left( \\frac{n\\pi x}{L} \\right) = -\\left( \\frac{n\\pi}{L} \\right)^2 \\sin\\left( \\frac{n\\pi x}{L} \\right),\n$$\nwe find the exact source terms\n$$\nf_n(x) = \\mathcal{L}[\\xi_n](x) = \\left[ C \\left( \\frac{n\\pi}{L} \\right)^2 + M k_\\perp^2 \\right] \\xi_n(x), \\quad n \\in \\{1,2,3\\}.\n$$\nThis construction ensures that solving $\\mathcal{L}[u_n] = f_n$ with the same boundary conditions yields $u_n = \\xi_n$ in the continuum.\n\nWe now design a second-order centered finite-difference discretization consistent with homogeneous Dirichlet boundaries. Let the grid be $x_j = j h$ for $j = 0,1,\\dots,N-1$, where $h = L/(N-1)$. The interior points are indexed by $j=1,\\dots,N-2$. The discrete second derivative operator $\\mathbf{D}^{(2)}$ on interior points is\n$$\n\\left(\\mathbf{D}^{(2)} \\mathbf{v}\\right)_j = \\frac{v_{j+1} - 2 v_j + v_{j-1}}{h^2}.\n$$\nBecause the boundary values are zero, no boundary contributions appear in the interior stencil. The discrete operator becomes\n$$\n\\mathbf{A} = -C \\,\\mathbf{D}^{(2)} + M k_\\perp^2 \\,\\mathbf{I},\n$$\napplied identically to each component. For each component $n \\in \\{1,2,3\\}$, the right-hand side vector is sampled from the analytic source:\n$$\n\\mathbf{f}_n = \\left[ C \\left( \\frac{n\\pi}{L} \\right)^2 + M k_\\perp^2 \\right] \\boldsymbol{\\xi}_n,\n$$\nwhere $\\boldsymbol{\\xi}_n$ is the sampling of $\\xi_n(x)$ at interior points. We then solve\n$$\n\\mathbf{A} \\mathbf{u}_n = \\mathbf{f}_n,\n$$\nusing a direct linear solver. The numerical solution $\\mathbf{u}_n$ approximates the analytic interior values $\\boldsymbol{\\xi}_n$ with second-order accuracy in $h$. The maximum absolute error for a given component is\n$$\n\\varepsilon_n = \\max_j \\left| u_{n,j} - \\xi_n(x_j) \\right|.\n$$\nWe report the maximum absolute error across all three components for each test case:\n$$\n\\varepsilon_{\\text{case}} = \\max\\{\\varepsilon_1,\\varepsilon_2,\\varepsilon_3\\}.\n$$\nAll errors are expressed in meters because the displacement amplitude $A$ is in meters.\n\nTest suite design:\n- Case $1$ uses $L = 1.0\\,\\mathrm{m}$, $N = 200$, $\\gamma = 5/3$, $p_0 = 2.0 \\times 10^3\\,\\mathrm{Pa}$, $B_0 = 1.0\\,\\mathrm{T}$, $k_y = 5.0\\,\\mathrm{rad/m}$, $k_z = 3.0\\,\\mathrm{rad/m}$, representing a well-resolved, moderate-stiffness scenario.\n- Case $2$ sets $k_\\perp = 0$ to test the pure $x$-stiffness operator with $L = 1.0\\,\\mathrm{m}$, $N = 50$, $\\gamma = 5/3$, $p_0 = 1.0 \\times 10^3\\,\\mathrm{Pa}$, $B_0 = 1.0\\,\\mathrm{T}$; this is a degeneracy check for transverse wavenumbers.\n- Case $3$ uses a coarse grid $N = 10$ and stronger field $B_0 = 3.0\\,\\mathrm{T}$ with $k_y = 10.0\\,\\mathrm{rad/m}$, $k_z = 0.0\\,\\mathrm{rad/m}$ and $p_0 = 2.0 \\times 10^5\\,\\mathrm{Pa}$ to test robustness under poor resolution.\n- Case $4$ uses a shorter domain $L = 0.5\\,\\mathrm{m}$, high stiffness with $B_0 = 5.0\\,\\mathrm{T}$, large transverse wavenumbers $k_y = 20.0\\,\\mathrm{rad/m}$ and $k_z = 20.0\\,\\mathrm{rad/m}$, and fine resolution $N = 300$.\n\nAlgorithmic steps:\n1. For each case, compute $C$ and $M$, and $k_\\perp^2$.\n2. Construct the interior grid and the second-derivative matrix $\\mathbf{D}^{(2)}$.\n3. Assemble $\\mathbf{A}$.\n4. Sample $\\boldsymbol{\\xi}_n$ for $n = 1,2,3$ and construct $\\mathbf{f}_n$.\n5. Solve $\\mathbf{A}\\mathbf{u}_n = \\mathbf{f}_n$ for each $n$.\n6. Compute maximum absolute errors $\\varepsilon_n$ and report $\\max_n \\varepsilon_n$ per case.\n\nThe program must produce a single line containing a comma-separated list of the four errors in meters enclosed in square brackets, i.e., $[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4]$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nMU0 = 4.0 * np.pi * 1e-7  # permeability of free space (H/m)\n\ndef assemble_operator(N, L, C, M, kperp2):\n    \"\"\"\n    Assemble the interior operator A = -C * D2 + M * kperp^2 * I\n    for homogeneous Dirichlet boundaries on a uniform grid.\n    \"\"\"\n    h = L / (N - 1)\n    n_interior = N - 2\n    # Second derivative matrix D2 with standard 3-point stencil\n    # D2 v_j = (v_{j+1} - 2 v_j + v_{j-1}) / h^2\n    diag = -2.0 / (h * h)\n    off = 1.0 / (h * h)\n    D2 = np.zeros((n_interior, n_interior))\n    # Fill tridiagonal\n    for i in range(n_interior):\n        D2[i, i] = diag\n        if i > 0:\n            D2[i, i - 1] = off\n        if i < n_interior - 1:\n            D2[i, i + 1] = off\n    A = -C * D2 + (M * kperp2) * np.eye(n_interior)\n    return A\n\ndef manufactured_xi_components(x, L, A_amp=1.0):\n    \"\"\"\n    Manufactured displacement components:\n    xi_x = A * sin(pi x / L)\n    xi_y = A * sin(2 pi x / L)\n    xi_z = A * sin(3 pi x / L)\n    \"\"\"\n    xi_x = A_amp * np.sin(np.pi * x / L)\n    xi_y = A_amp * np.sin(2.0 * np.pi * x / L)\n    xi_z = A_amp * np.sin(3.0 * np.pi * x / L)\n    return xi_x, xi_y, xi_z\n\ndef manufactured_sources(xi_x, xi_y, xi_z, L, C, M, kperp2):\n    \"\"\"\n    Using the analytic relation:\n    f_n = [ C * (n*pi/L)^2 + M * kperp^2 ] * xi_n\n    for n = 1,2,3 corresponding to xi_x, xi_y, xi_z.\n    \"\"\"\n    factors = np.array([\n        C * (1.0 * np.pi / L) ** 2 + M * kperp2,\n        C * (2.0 * np.pi / L) ** 2 + M * kperp2,\n        C * (3.0 * np.pi / L) ** 2 + M * kperp2\n    ])\n    f_x = factors[0] * xi_x\n    f_y = factors[1] * xi_y\n    f_z = factors[2] * xi_z\n    return f_x, f_y, f_z\n\ndef solve_case(L, N, gamma, p0, B0, ky, kz):\n    \"\"\"\n    Assemble and solve the discrete systems for the three components,\n    then compute the maximum absolute error across components at interior points.\n    \"\"\"\n    C = gamma * p0 + (B0 ** 2) / MU0\n    M = (B0 ** 2) / MU0\n    kperp2 = ky ** 2 + kz ** 2\n\n    # Grid\n    x = np.linspace(0.0, L, N)\n    x_interior = x[1:-1]\n\n    # Manufactured displacement at interior points\n    xi_x, xi_y, xi_z = manufactured_xi_components(x_interior, L, A_amp=1.0)\n\n    # Manufactured sources\n    f_x, f_y, f_z = manufactured_sources(xi_x, xi_y, xi_z, L, C, M, kperp2)\n\n    # Assemble operator\n    A = assemble_operator(N, L, C, M, kperp2)\n\n    # Solve A u = f for each component\n    # Use a robust solver; A is symmetric positive definite under given parameters.\n    u_x = np.linalg.solve(A, f_x)\n    u_y = np.linalg.solve(A, f_y)\n    u_z = np.linalg.solve(A, f_z)\n\n    # Compute maximum absolute error across components (meters)\n    err_x = np.max(np.abs(u_x - xi_x))\n    err_y = np.max(np.abs(u_y - xi_y))\n    err_z = np.max(np.abs(u_z - xi_z))\n    err_case = float(max(err_x, err_y, err_z))\n    return err_case\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path)\n        {\"L\": 1.0, \"N\": 200, \"gamma\": 5.0/3.0, \"p0\": 2.0e3, \"B0\": 1.0, \"ky\": 5.0, \"kz\": 3.0},\n        # Case 2 (transverse wavenumber degeneracy)\n        {\"L\": 1.0, \"N\": 50, \"gamma\": 5.0/3.0, \"p0\": 1.0e3, \"B0\": 1.0, \"ky\": 0.0, \"kz\": 0.0},\n        # Case 3 (coarse grid, stronger field)\n        {\"L\": 1.0, \"N\": 10, \"gamma\": 5.0/3.0, \"p0\": 2.0e5, \"B0\": 3.0, \"ky\": 10.0, \"kz\": 0.0},\n        # Case 4 (short domain, high stiffness and resolution)\n        {\"L\": 0.5, \"N\": 300, \"gamma\": 5.0/3.0, \"p0\": 1.0e5, \"B0\": 5.0, \"ky\": 20.0, \"kz\": 20.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        err = solve_case(\n            L=case[\"L\"],\n            N=case[\"N\"],\n            gamma=case[\"gamma\"],\n            p0=case[\"p0\"],\n            B0=case[\"B0\"],\n            ky=case[\"ky\"],\n            kz=case[\"kz\"],\n        )\n        results.append(err)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world MHD stability analysis often involves large-scale eigenvalue problems with complex spectra, including eigenvalues that are very close together (nearly degenerate). This practice delves into an advanced numerical challenge where finite-precision arithmetic can cause computed eigenvectors to lose their required orthogonality, leading to spurious results. You will implement and test a robust reorthogonalization procedure, a technique essential for building reliable and accurate stability codes that can handle the subtleties of physically realistic scenarios .",
            "id": "4022882",
            "problem": "Consider the linearized Ideal Magnetohydrodynamics (MHD) normal-mode stability problem, which, under standard energy principle discretizations, yields a generalized Hermitian eigenvalue system of the form $$\\mathbf{L}\\,\\mathbf{x} = \\lambda\\,\\mathbf{M}\\,\\mathbf{x},$$ where $$\\mathbf{L}$$ is a real symmetric matrix representing the discretized potential energy operator, $$\\mathbf{M}$$ is a real symmetric positive definite mass matrix defining the kinetic energy inner product, $$\\lambda$$ is a real scalar, and $$\\mathbf{x}$$ is the mode vector. For nearly degenerate eigenvalues (i.e., two eigenvalues so close that finite precision arithmetic causes significant mixing), computed eigenvectors can lose orthogonality in the $$\\mathbf{M}$$-inner product. In numerical practice, one must measure the orthogonality between two computed eigenvectors and apply a stable reorthogonalization procedure to separate them reliably under finite precision.\n\nStarting from the fundamental base that the matrix $$\\mathbf{M}$$ defines an inner product $$\\langle \\mathbf{u}, \\mathbf{v} \\rangle_{\\mathbf{M}}$$ for vectors $$\\mathbf{u}$$ and $$\\mathbf{v}$$, and that the norm induced by this inner product is $$\\|\\mathbf{u}\\|_{\\mathbf{M}}$$, design a program that:\n\n- Measures the numerical orthogonality between two given vectors with respect to the $$\\mathbf{M}$$-inner product using a dimensionless scalar that is invariant to scaling of the vectors.\n- Implements a reorthogonalization procedure that is robust in finite precision arithmetic to separate two nearly degenerate eigenvectors. The procedure must use a modified Gram-Schmidt process in the $$\\mathbf{M}$$-inner product and perform a second pass if the first pass does not reduce the correlation below a threshold tied to machine precision. If necessary, include a fallback using a transformation that leverages a factorization of $$\\mathbf{M}$$ to perform the reorthogonalization in a space where the inner product is Euclidean, then map back.\n\nYour program must follow these rules:\n\n- Work in purely mathematical terms. Use only real-valued arrays and operations.\n- Treat $$\\mathbf{M}$$ as a real symmetric positive definite matrix. The inner product $$\\langle \\mathbf{u}, \\mathbf{v} \\rangle_{\\mathbf{M}}$$, norm $$\\|\\mathbf{u}\\|_{\\mathbf{M}}$$, and orthogonality are all defined with respect to $$\\mathbf{M}$$.\n- Use a tolerance set to $$\\sqrt{\\epsilon}$$ where $$\\epsilon$$ is the machine epsilon for double precision floating-point arithmetic.\n- Do not use any external input; construct all test data internally and deterministically.\n\nYou will construct three test cases to assess the procedure with distinct coverage:\n\n- Case $$1$$ (general case): Moderate degeneracy.\n  - Dimension $$n = 50$$.\n  - Random seed $$s = 12345$$.\n  - Matrix construction: Generate $$\\mathbf{M}$$ by sampling a real matrix $$\\mathbf{A}$$ with independent standard normal entries, then set $$\\mathbf{M} = \\mathbf{A}^{\\top}\\mathbf{A} + \\beta\\,\\mathbf{I}$$ with $$\\beta = 10^{-3}$$, ensuring symmetry and positive definiteness.\n  - Vectors: Generate a random vector $$\\mathbf{x}$$ and a nearly degenerate $$\\mathbf{y}$$ by $$\\mathbf{y} = a\\,\\mathbf{x} + \\eta\\,\\mathbf{z}$$ where $$a = 0.2$$, $$\\eta = 10^{-8}$$, and $$\\mathbf{z}$$ is a random standard normal vector. Both $$\\mathbf{x}$$ and $$\\mathbf{y}$$ are then normalized in the $$\\mathbf{M}$$-norm before measuring and reorthogonalizing.\n\n- Case $$2$$ (high degeneracy, near-parallel eigenvectors): \n  - Dimension $$n = 80$$.\n  - Random seed $$s = 2024$$.\n  - Matrix construction: Same approach as Case $$1$$ with $$\\beta = 10^{-3}$$.\n  - Vectors: $$\\mathbf{y} = a\\,\\mathbf{x} + \\eta\\,\\mathbf{z}$$ with $$a = 1.0$$ and $$\\eta = 10^{-12}$$. Normalize both vectors in the $$\\mathbf{M}$$-norm before measuring and reorthogonalizing.\n\n- Case $$3$$ (edge case, one vector initially extremely small):\n  - Dimension $$n = 30$$.\n  - Random seed $$s = 7$$.\n  - Matrix construction: Same approach as Case $$1$$ with $$\\beta = 10^{-3}$$.\n  - Vectors: $$\\mathbf{y} = \\eta\\,\\mathbf{z}$$ with $$a = 0.0$$ and $$\\eta = 10^{-300}$$, while $$\\mathbf{x}$$ is random. Normalize both vectors in the $$\\mathbf{M}$$-norm before measuring and reorthogonalizing.\n\nAlgorithmic requirements:\n\n- Implement a modified Gram-Schmidt step in the $$\\mathbf{M}$$-inner product to reorthogonalize $$\\mathbf{y}$$ against $$\\mathbf{x}$$. If the absolute correlation after one pass remains above the tolerance, repeat a second pass. If it remains above the tolerance after two passes, use a fallback based on a factorization of $$\\mathbf{M}$$ to perform the projection in a Euclidean inner product induced by the factorization and then map back, followed by $$\\mathbf{M}$$-normalization.\n- Use safe normalization procedures that avoid division by zero by detecting zero $$\\mathbf{M}$$-norm and regenerating the vector if necessary (deterministically from the seeded generator to preserve reproducibility).\n\nNumerical outputs:\n\n- For each test case, compute the final absolute correlation between $$\\mathbf{x}$$ and the reorthogonalized $$\\mathbf{y}$$ in the $$\\mathbf{M}$$-inner product, i.e., a scalar in the interval $$[0,1]$$ that measures the magnitude of the cosine of the angle between the vectors in the $$\\mathbf{M}$$-inner product.\n- No physical units are involved.\n- Angles, if implicitly represented through cosine, are unitless; do not convert to radians or degrees.\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for the three cases in order, e.g., $$[r_1,r_2,r_3]$$ where each $$r_i$$ is a floating-point number representing the final absolute correlation in the $$\\mathbf{M}$$-inner product after the complete reorthogonalization procedure.",
            "solution": "The problem at hand is a canonical challenge in numerical linear algebra, specifically within the context of computational physics and engineering: the stable computation of eigenvectors for a generalized eigenvalue problem, $\\mathbf{L}\\,\\mathbf{x} = \\lambda\\,\\mathbf{M}\\,\\mathbf{x}$, particularly when eigenvalues are nearly degenerate. In such cases, eigenvectors computed by standard algorithms often suffer from a loss of orthogonality with respect to the inner product defined by the mass matrix $\\mathbf{M}$. The task is to design and implement a robust numerical procedure to restore this orthogonality.\n\nThe foundation of this problem lies in the concept of a generalized inner product. Given a real symmetric positive definite matrix $\\mathbf{M}$ of size $n \\times n$, the $\\mathbf{M}$-inner product of two vectors $\\mathbf{u}, \\mathbf{v} \\in \\mathbb{R}^n$ is defined as:\n$$ \\langle \\mathbf{u}, \\mathbf{v} \\rangle_{\\mathbf{M}} = \\mathbf{u}^{\\top} \\mathbf{M} \\mathbf{v} $$\nThis inner product induces the $\\mathbf{M}$-norm:\n$$ \\|\\mathbf{u}\\|_{\\mathbf{M}} = \\sqrt{\\langle \\mathbf{u}, \\mathbf{u} \\rangle_{\\mathbf{M}}} $$\nTwo vectors are $\\mathbf{M}$-orthogonal if $\\langle \\mathbf{u}, \\mathbf{v} \\rangle_{\\mathbf{M}} = 0$.\n\nThe first requirement is to devise a dimensionless, scale-invariant measure of numerical orthogonality. This is naturally given by the absolute value of the cosine of the angle between the two vectors in the vector space equipped with the $\\mathbf{M}$-inner product. For two non-zero vectors $\\mathbf{x}$ and $\\mathbf{y}$, this correlation measure, $C(\\mathbf{x}, \\mathbf{y})$, is:\n$$ C(\\mathbf{x}, \\mathbf{y}) = \\frac{|\\langle \\mathbf{x}, \\mathbf{y} \\rangle_{\\mathbf{M}}|}{\\|\\mathbf{x}\\|_{\\mathbf{M}} \\|\\mathbf{y}\\|_{\\mathbf{M}}} $$\nIf the vectors are pre-normalized such that $\\|\\mathbf{x}\\|_{\\mathbf{M}} = 1$ and $\\|\\mathbf{y}\\|_{\\mathbf{M}} = 1$, this simplifies to $C(\\mathbf{x}, \\mathbf{y}) = |\\langle \\mathbf{x}, \\mathbf{y} \\rangle_{\\mathbf{M}}|$. This value ranges from $0$ (perfectly $\\mathbf{M}$-orthogonal) to $1$ (perfectly $\\mathbf{M}$-collinear).\n\nThe core of the task is to implement a reorthogonalization procedure to take a vector $\\mathbf{y}$ and make it $\\mathbf{M}$-orthogonal to a reference vector $\\mathbf{x}$, assuming $\\mathbf{x}$ is already $\\mathbf{M}$-normalized. The specified method is the modified Gram-Schmidt (MGS) process, which is known for its superior numerical stability compared to the classical variant. To orthogonalize $\\mathbf{y}$ against $\\mathbf{x}$, we subtract the component of $\\mathbf{y}$ that lies in the direction of $\\mathbf{x}$:\n$$ \\mathbf{y}_{\\perp} = \\mathbf{y} - \\langle \\mathbf{y}, \\mathbf{x} \\rangle_{\\mathbf{M}}\\,\\mathbf{x} $$\nHere, $\\langle \\mathbf{y}, \\mathbf{x} \\rangle_{\\mathbf{M}}\\,\\mathbf{x}$ is the projection of $\\mathbf{y}$ onto the one-dimensional subspace spanned by $\\mathbf{x}$.\n\nIn finite-precision arithmetic, if $\\mathbf{y}$ is nearly collinear with $\\mathbf{x}$, the term $\\langle \\mathbf{y}, \\mathbf{x} \\rangle_{\\mathbf{M}}\\,\\mathbf{x}$ is almost equal to $\\mathbf{y}$. The subtraction then leads to catastrophic cancellation, where the resulting vector $\\mathbf{y}_{\\perp}$ is dominated by floating-point error and may not be numerically orthogonal to $\\mathbf{x}$. To mitigate this, an iterative refinement is employed. A second MGS step is applied to the result of the first:\n$$ \\mathbf{y}_{\\perp}^{(1)} = \\mathbf{y} - \\langle \\mathbf{y}, \\mathbf{x} \\rangle_{\\mathbf{M}}\\,\\mathbf{x} $$\n$$ \\mathbf{y}_{\\perp}^{(2)} = \\mathbf{y}_{\\perp}^{(1)} - \\langle \\mathbf{y}_{\\perp}^{(1)}, \\mathbf{x} \\rangle_{\\mathbf{M}}\\,\\mathbf{x} $$\nThis second pass removes the residual component of $\\mathbf{x}$ that \"leaked\" back into the vector due to round-off error. The procedure is to perform one pass, normalize the result, check its correlation with $\\mathbf{x}$ against a tolerance $\\tau = \\sqrt{\\epsilon}$ (where $\\epsilon$ is machine epsilon), and perform the second pass only if necessary.\n\nA crucial aspect is safe normalization. After orthogonalization, the resulting vector $\\mathbf{y}_{\\perp}$ must be normalized to unit length: $\\mathbf{y}' = \\mathbf{y}_{\\perp} / \\|\\mathbf{y}_{\\perp}\\|_{\\mathbf{M}}$. If the original $\\mathbf{y}$ was perfectly collinear with $\\mathbf{x}$, $\\mathbf{y}_{\\perp}$ will be a zero vector, and its norm will be zero. Attempting to divide by zero is an error. The prescribed remedy for such a case, or any case where the norm is smaller than a threshold related to machine precision, is to regenerate the vector deterministically using the seeded random number generator. This new vector can then be orthogonalized and normalized, effectively producing a valid vector that completes an orthonormal basis.\n\nIf two passes of MGS fail to reduce the correlation below the tolerance $\\tau$, it indicates severe numerical difficulties. A more robust fallback procedure is invoked. This method leverages the Cholesky factorization of the mass matrix, $\\mathbf{M} = \\mathbf{L}\\mathbf{L}^{\\top}$, where $\\mathbf{L}$ is a lower-triangular matrix. This factorization allows a transformation of the problem into a space where the inner product is the standard Euclidean dot product. Let us define a change of basis $\\tilde{\\mathbf{v}} = \\mathbf{L}^{\\top}\\mathbf{v}$. The $\\mathbf{M}$-inner product becomes:\n$$ \\langle \\mathbf{u}, \\mathbf{v} \\rangle_{\\mathbf{M}} = \\mathbf{u}^{\\top}\\mathbf{M}\\mathbf{v} = \\mathbf{u}^{\\top}\\mathbf{L}\\mathbf{L}^{\\top}\\mathbf{v} = (\\mathbf{L}^{\\top}\\mathbf{u})^{\\top}(\\mathbf{L}^{\\top}\\mathbf{v}) = \\langle \\tilde{\\mathbf{u}}, \\tilde{\\mathbf{v}} \\rangle_{E} $$\nThe fallback algorithm is as follows:\n1. Compute the Cholesky factor $\\mathbf{L}$ of $\\mathbf{M}$.\n2. Transform the vectors into the Euclidean space: $\\tilde{\\mathbf{x}} = \\mathbf{L}^{\\top}\\mathbf{x}$ and $\\tilde{\\mathbf{y}} = \\mathbf{L}^{\\top}\\mathbf{y}$.\n3. Perform standard Gram-Schmidt orthogonalization in this space, which is numerically stable: $\\tilde{\\mathbf{y}}_{\\perp} = \\tilde{\\mathbf{y}} - \\langle \\tilde{\\mathbf{y}}, \\tilde{\\mathbf{x}} \\rangle_{E}\\,\\tilde{\\mathbf{x}}$.\n4. Normalize the resulting vector in the Euclidean norm: $\\tilde{\\mathbf{y}}' = \\tilde{\\mathbf{y}}_{\\perp} / \\|\\tilde{\\mathbf{y}}_{\\perp}\\|_{E}$.\n5. Transform the orthogonalized, normalized vector $\\tilde{\\mathbf{y}}'$ back to the original space by solving the triangular system $\\mathbf{L}^{\\top}\\mathbf{y}' = \\tilde{\\mathbf{y}}'$. The resulting vector $\\mathbf{y}'$ is guaranteed to be both $\\mathbf{M}$-orthogonal to $\\mathbf{x}$ and have a unit $\\mathbf{M}$-norm.\n\nThe implementation will systematically apply these steps for each test case, starting from the generation of deterministic matrices and vectors, applying the two-pass MGS with the Cholesky fallback, and finally reporting the absolute correlation of the resulting vector pair.",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_triangular\n\ndef solve():\n    \"\"\"\n    Solves the reorthogonalization problem for three test cases.\n    \"\"\"\n    \n    # Define machine epsilon and the tolerance for orthogonality checks.\n    EPS = np.finfo(np.float64).eps\n    TOL = np.sqrt(EPS)\n\n    # Define the test cases as specified in the problem statement.\n    # Each tuple contains: (dimension n, random seed s, parameter a, parameter eta)\n    test_cases = [\n        (50, 12345, 0.2, 1e-8),\n        (80, 2024, 1.0, 1e-12),\n        (30, 7, 0.0, 1e-300),\n    ]\n\n    results = []\n\n    def m_inner_product(u, v, M):\n        \"\"\"Computes the M-inner product <u, v>_M = u^T M v.\"\"\"\n        return np.dot(u, M @ v)\n\n    def m_norm(v, M):\n        \"\"\"Computes the M-norm ||v||_M.\"\"\"\n        norm_sq = m_inner_product(v, v, M)\n        return np.sqrt(norm_sq) if norm_sq > 0 else 0.0\n\n    def safe_m_normalize(v, M, rng):\n        \"\"\"\n        Normalizes a vector in the M-norm, regenerating it if its norm is zero.\n        \"\"\"\n        norm_val = m_norm(v, M)\n        # Use a small threshold based on machine epsilon to detect a \"zero\" norm.\n        if norm_val < 10 * EPS:\n            # Regenerate vector deterministically to ensure reproducibility.\n            v_new = rng.standard_normal(size=v.shape)\n            norm_val_new = m_norm(v_new, M)\n            # A random vector is extremely unlikely to have a zero norm.\n            return v_new / norm_val_new\n        return v / norm_val\n\n    def reorthogonalize(x_norm, y_norm, M, tol, rng):\n        \"\"\"\n        Reorthogonalizes y_norm with respect to x_norm using a robust procedure.\n        - Assumes x_norm is already M-normalized.\n        - Implements two-pass Modified Gram-Schmidt with Cholesky fallback.\n        \"\"\"\n        \n        # --- Pass 1 of Modified Gram-Schmidt ---\n        c1 = m_inner_product(y_norm, x_norm, M)\n        y_p1 = y_norm - c1 * x_norm\n        \n        y_p1_norm_val = m_norm(y_p1, M)\n        if y_p1_norm_val < 10 * EPS:\n            # Original y was nearly collinear with x. Information is lost.\n            # Generate a new random direction and orthogonalize it.\n            z = rng.standard_normal(size=x_norm.shape)\n            cz = m_inner_product(z, x_norm, M)\n            y_final = z - cz * x_norm\n            return safe_m_normalize(y_final, M, rng)\n        \n        y_p1_n = y_p1 / y_p1_norm_val\n        corr1 = abs(m_inner_product(y_p1_n, x_norm, M))\n        \n        if corr1 <= tol:\n            return y_p1_n\n        \n        # --- Pass 2 of Modified Gram-Schmidt ---\n        # The second projection must use the unnormalized result from the first pass.\n        c2 = m_inner_product(y_p1, x_norm, M)\n        y_p2 = y_p1 - c2 * x_norm\n        \n        y_p2_norm_val = m_norm(y_p2, M)\n        if y_p2_norm_val < 10 * EPS:\n            # Collinearity detected after refinement. Generate new direction.\n            z = rng.standard_normal(size=x_norm.shape)\n            cz = m_inner_product(z, x_norm, M)\n            y_final = z - cz * x_norm\n            return safe_m_normalize(y_final, M, rng)\n            \n        y_p2_n = y_p2 / y_p2_norm_val\n        corr2 = abs(m_inner_product(y_p2_n, x_norm, M))\n        \n        if corr2 <= tol:\n            return y_p2_n\n            \n        # --- Fallback Procedure using Cholesky Decomposition ---\n        # This is triggered if two MGS passes are insufficient.\n        L = np.linalg.cholesky(M)\n        LT = L.T\n        \n        # Transform vectors to the space where the inner product is Euclidean.\n        x_tilde = LT @ x_norm\n        y_tilde = LT @ y_norm\n        \n        # Perform standard Gram-Schmidt in Euclidean space.\n        y_tilde_ortho = y_tilde - np.dot(y_tilde, x_tilde) * x_tilde\n        \n        # Normalize in Euclidean norm.\n        y_tilde_ortho_norm_val = np.linalg.norm(y_tilde_ortho)\n        if y_tilde_ortho_norm_val < 10 * EPS:\n            # Handle collinearity in the transformed space.\n            z = rng.standard_normal(size=x_norm.shape)\n            z_tilde = LT @ z\n            z_tilde_ortho = z_tilde - np.dot(z_tilde, x_tilde) * z_tilde\n            y_tilde_final = z_tilde_ortho / np.linalg.norm(z_tilde_ortho)\n        else:\n            y_tilde_final = y_tilde_ortho / y_tilde_ortho_norm_val\n            \n        # Transform the result back to the original space by solving L^T * y' = y_tilde'.\n        y_final = solve_triangular(LT, y_tilde_final, lower=False)\n        return y_final\n\n    for n, s, a, eta in test_cases:\n        # Initialize a seeded random number generator for reproducibility.\n        rng = np.random.default_rng(s)\n        beta = 1e-3\n\n        # Construct the symmetric positive definite matrix M.\n        A = rng.standard_normal(size=(n, n))\n        M = A.T @ A + beta * np.identity(n)\n\n        # Generate the raw vectors x and y.\n        x_raw = rng.standard_normal(size=n)\n        z_raw = rng.standard_normal(size=n)\n        y_raw = a * x_raw + eta * z_raw\n\n        # M-normalize the initial vectors.\n        x_norm = safe_m_normalize(x_raw, M, rng)\n        y_norm = safe_m_normalize(y_raw, M, rng)\n\n        # Reorthogonalize y_norm with respect to x_norm.\n        y_reortho = reorthogonalize(x_norm, y_norm, M, TOL, rng)\n\n        # Calculate the final absolute correlation.\n        final_corr = abs(m_inner_product(x_norm, y_reortho, M))\n        results.append(final_corr)\n\n    # Print the results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}