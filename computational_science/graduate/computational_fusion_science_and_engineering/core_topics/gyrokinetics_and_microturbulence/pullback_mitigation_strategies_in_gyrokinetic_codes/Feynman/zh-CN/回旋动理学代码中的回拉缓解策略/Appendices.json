{
    "hands_on_practices": [
        {
            "introduction": "回拉缓解策略的核心思想是将平行矢量势 $A_\\parallel$ 分解为一个大尺度（辛）部分和一个小尺度（哈密顿）部分。本次实践将带你亲手操作，使用傅里叶变换和时间平滑技术实现这一基本过程，将抽象的理论概念转化为可执行的算法。通过这个练习，你将掌握在回旋动理学代码中实现场分解的关键数值技术。",
            "id": "4033410",
            "problem": "考虑一个一维板状区域，其空间坐标 $x \\in [0,L)$ 具有周期性边界条件，以及一个实值的、预先设定的随时间变化的平行矢量势 $A_\\parallel(x,t)$。在回旋动理学公式中，平行安培方程中的相消问题可以通过将 $A_\\parallel$ 分解为一个辛部分 $A_\\parallel^{(s)}$ 和一个哈密顿部分 $A_\\parallel^{(h)}$ 来缓解，其中大尺度的、低垂直波数的内容被分配给 $A_\\parallel^{(s)}$，剩余的内容分配给 $A_\\parallel^{(h)}$。在板状模型中，与此思想一致的一种实用算法是在每个时间步长上使用对 $A_\\parallel$ 的低 $k_\\perp$ 傅里叶分量的投影。在此问题中，$k_\\perp$ 由沿 $x$ 方向的标量波数 $k$ 表示。\n\n从与周期域上的傅里叶分析和线性投影相关的基本原理出发，推导一个算法，该算法在每个离散时间 $t_n = n \\Delta t$ 计算 $A_\\parallel^{(s)}(x,t_n)$ 和 $A_\\parallel^{(h)}(x,t_n)$，通过：\n- 计算 $A_\\parallel(x,t_n)$ 在 $x$ 上的离散傅里叶变换，\n- 投影到由 $\\lvert k \\rvert \\le k_{\\text{cut}}$ 的傅里叶模式所张成的子空间上，以获得低 $k$ 部分，以及\n- 通过指数平均将 $A_\\parallel^{(s)}(x,t_n)$ 定义为低 $k$ 部分的时间平滑版本，并令 $A_\\parallel^{(h)}(x,t_n) = A_\\parallel(x,t_n) - A_\\parallel^{(s)}(x,t_n)$。\n\n您的推导必须从傅里叶基函数在 $[0,L)$ 上的正交性、平方可积周期函数存在完备傅里叶表示，以及到由基元所张成的子空间上的正交投影算子的定义出发。除了这些基础知识外，不要假设任何专门的公式。\n\n实现要求：\n- 空间离散化：在 $x \\in [0,L)$ 中使用 $N$ 个等距网格点，其中 $L = 2\\pi$，$N = 128$。\n- 时间离散化：使用 $N_t$ 个步长，对于 $n=0,1,\\dots,N_t-1$，$t_n = n \\Delta t$，并为每个测试案例指定 $\\Delta t$。\n- 傅里叶变换必须与离散周期网格的解释保持一致。角波数为 $k_m = \\dfrac{2\\pi m}{L}$，其中整数模式指数 $m$ 对应于离散傅里叶变换。三角函数中的角度以弧度为单位。\n- 低 $k$ 投影：保留傅里叶系数中 $\\lvert k_m \\rvert \\le k_{\\text{cut}}$ 的部分。所有其他系数均设置为零。\n- 时间平滑：对于 $n \\ge 1$，定义\n$$\nA_\\parallel^{(s)}(x,t_n) = \\alpha\\,\\Pi_{\\le k_{\\text{cut}}}\\left[A_\\parallel(x,t_n)\\right] + (1-\\alpha)\\,A_\\parallel^{(s)}(x,t_{n-1}),\n$$\n其中 $A_\\parallel^{(s)}(x,t_0) = \\Pi_{\\le k_{\\text{cut}}}\\left[A_\\parallel(x,t_0)\\right]$，$\\Pi_{\\le k_{\\text{cut}}}$ 表示低 $k$ 投影算子，$\\alpha \\in (0,1]$ 是平滑参数。然后设置 $A_\\parallel^{(h)}(x,t_n) = A_\\parallel(x,t_n) - A_\\parallel^{(s)}(x,t_n)$。\n\n定义以下诊断量：\n- $t_n$ 时刻的频谱泄漏：计算离散傅里叶变换 $\\widehat{A_\\parallel^{(s)}}(k_m,t_n)$ 和 $\\widehat{A_\\parallel^{(h)}}(k_m,t_n)$。将“向低k区的泄漏”定义为在 $\\lvert k_m \\rvert \\le k_{\\text{cut}}$ 范围内 $\\widehat{A_\\parallel^{(h)}}(k_m,t_n)$ 的最大绝对值。将“向高k区的泄漏”定义为在 $\\lvert k_m \\rvert > k_{\\text{cut}}$ 范围内 $\\widehat{A_\\parallel^{(s)}}(k_m,t_n)$ 的最大绝对值。$t_n$ 时刻的频谱泄漏度量是这两种泄漏中的最大值。一个案例的总体频谱泄漏度量是所有时间步长 $n$ 中频谱泄漏的最大值。\n- 时间变化率之比（用于平滑测试）：定义平滑低 $k$ 场在时间上连续差异的平均离散 $L^2$ 范数，\n$$\n\\mathrm{TV}_{\\text{smooth}} = \\frac{1}{N_t-1}\\sum_{n=1}^{N_t-1} \\left\\|A_\\parallel^{(s)}(x,t_n) - A_\\parallel^{(s)}(x,t_{n-1})\\right\\|_2,\n$$\n以及原始低 $k$ 投影（即不进行平滑，$\\alpha=1$）的相应值，\n$$\n\\mathrm{TV}_{\\text{raw}} = \\frac{1}{N_t-1}\\sum_{n=1}^{N_t-1} \\left\\|\\Pi_{\\le k_{\\text{cut}}}\\left[A_\\parallel(x,t_n)\\right] - \\Pi_{\\le k_{\\text{cut}}}\\left[A_\\parallel(x,t_{n-1})\\right]\\right\\|_2.\n$$\n报告比率 $R = \\mathrm{TV}_{\\text{smooth}}/\\mathrm{TV}_{\\text{raw}}$。\n\n使用快速傅里叶变换 (FFT) 算法进行离散变换。快速傅里叶变换 (FFT) 的解释应与所选的离散化方法保持一致。\n\n测试套件：\n- 案例 1（理想路径）：$L = 2\\pi$，$N = 128$，$N_t = 12$，$\\Delta t = 0.1$，$k_{\\text{cut}} = 2.0$，$\\alpha = 1.0$（无平滑）。预设\n$$\nA_\\parallel(x,t) = \\sin(1\\cdot x)\\,\\cos(1.1\\,t) + 0.2\\,\\sin(6\\cdot x)\\,\\cos(2.3\\,t).\n$$\n计算并返回总体频谱泄漏度量，结果为浮点数。\n- 案例 2（截止边界上的模式）：$L = 2\\pi$，$N = 128$，$N_t = 8$，$\\Delta t = 0.15$，$k_{\\text{cut}} = 4.0$，$\\alpha = 1.0$。预设\n$$\nA_\\parallel(x,t) = \\sin(4\\cdot x)\\,\\cos(0.9\\,t).\n$$\n计算并返回总体频谱泄漏度量，结果为浮点数。\n- 案例 3（平滑效果）：$L = 2\\pi$，$N = 128$，$N_t = 20$，$\\Delta t = 0.07$，$k_{\\text{cut}} = 3.0$，$\\alpha = 0.3$。预设\n$$\nA_\\parallel(x,t) = \\sin(2\\cdot x)\\,\\cos(1.3\\,t) + 0.7\\,\\sin(8\\cdot x)\\,\\cos(3.7\\,t).\n$$\n计算并返回时间变化率之比 $R$，结果为浮点数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3\\right]$）。这三个条目必须按顺序为案例1的浮点数、案例2的浮点数和案例3的浮点数。所有三角函数的角度均以弧度为单位。除给定规范外，不需要任何物理单位。",
            "solution": "该问题要求推导并实现一个算法，用于将随时间变化的平行矢量势 $A_\\parallel(x,t)$ 分解为一个时间平滑的低波数（辛）部分 $A_\\parallel^{(s)}(x,t)$ 和一个残余（哈密顿）部分 $A_\\parallel^{(h)}(x,t)$。此过程是回旋动理学模拟中针对相消问题的一种缓解策略。推导过程必须从傅里叶分析和线性投影的基本原理出发。\n\n### 从基本原理推导\n\n**1. 傅里叶级数表示**\n一个在域 $x \\in [0,L)$ 上周期且平方可积的函数 $f(x)$ 可以表示为傅里叶级数。该表示的基函数是复指数函数 $\\{\\phi_m(x) = e^{ik_m x}\\}$，其中 $k_m = \\frac{2\\pi m}{L}$，整数 $m \\in \\mathbb{Z}$ 为模式指数。这些基函数关于内积 $\\langle f, g \\rangle = \\int_0^L f(x)^* g(x) dx$ 是正交的。正交关系为：\n$$\n\\langle \\phi_m, \\phi_n \\rangle = \\int_0^L (e^{ik_m x})^* e^{ik_n x} dx = \\int_0^L e^{-ik_m x} e^{ik_n x} dx = L\\delta_{mn}\n$$\n其中 $\\delta_{mn}$ 是克罗内克δ函数。\n\n该基的完备性使得任何此类函数 $A_\\parallel(x,t)$（在固定时间 $t$）可以写成这些基函数的线性组合：\n$$\nA_\\parallel(x,t) = \\sum_{m=-\\infty}^{\\infty} \\widehat{A_\\parallel}(k_m,t)\\, e^{ik_m x}\n$$\n傅里叶系数 $\\widehat{A_\\parallel}(k_m,t)$ 是通过将 $A_\\parallel(x,t)$ 投影到每个基函数上确定的：\n$$\n\\widehat{A_\\parallel}(k_m,t) = \\frac{\\langle \\phi_m, A_\\parallel \\rangle}{\\langle \\phi_m, \\phi_m \\rangle} = \\frac{1}{L} \\int_0^L A_\\parallel(x,t)\\, e^{-ik_m x} dx\n$$\n\n**2. 向低波数子空间投影**\n问题将低波数内容定义为函数中对应于 $|k_m| \\le k_{\\text{cut}}$ 的傅里叶模式的部分。这对应于向子空间 $V_{\\text{low}} = \\text{span}\\{e^{ik_m x} : |k_m| \\le k_{\\text{cut}}\\}$ 的投影。正交投影算子 $\\Pi_{\\le k_{\\text{cut}}}$ 将函数映射到该子空间内的分量。对于任何函数 $A_\\parallel(x,t)$，其投影由仅对 $V_{\\text{low}}$ 中的基函数求和给出：\n$$\n\\Pi_{\\le k_{\\text{cut}}}[A_\\parallel(x,t)] = \\sum_{m \\text{ s.t. } |k_m| \\le k_{\\text{cut}}} \\widehat{A_\\parallel}(k_m,t)\\, e^{ik_m x}\n$$\n在算法上，此投影的执行步骤如下：\n1.  计算所有 $m$ 的傅里叶变换 $\\widehat{A_\\parallel}(k_m,t)$。\n2.  将 $|k_m| > k_{\\text{cut}}$ 的所有系数置零。\n3.  对修改后的系数集进行傅里叶逆变换。\n\n**3. 离散化与离散傅里叶变换 (DFT)**\n对于数值实现，连续域 $x \\in [0,L)$ 被离散化为 $N$ 个等距点，$x_j = j \\frac{L}{N}$，其中 $j=0, 1, \\dots, N-1$。函数由其在该网格上的值表示，例如 $A_{\\parallel, j}(t) = A_\\parallel(x_j,t)$。\n\n连续傅里叶变换被离散傅里叶变换 (DFT) 取代。标准的DFT对（如 `numpy.fft` 中所用）为：\n$$\n\\widehat{A}_m = \\sum_{j=0}^{N-1} A_j e^{-i 2\\pi mj/N} \\quad (\\text{正向DFT})\n$$\n$$\nA_j = \\frac{1}{N} \\sum_{m=0}^{N-1} \\widehat{A}_m e^{i 2\\pi mj/N} \\quad (\\text{逆向DFT})\n$$\nDFT的模式指数 $m$ 对应一个物理波数。对于网格间距 $\\Delta x = L/N$，与DFT指数关联的波数由 $k_m = 2\\pi f_m$ 给出，其中 $f_m$ 是空间频率。这些频率由FFT库提供，通常按特定顺序排列。对于参数 $L=2\\pi$ 和网格间距 $\\Delta x = 2\\pi/N$，对应的物理波数是整数值，$k_m = m'$，其中 $m' \\in \\{0, \\pm 1, \\dots, \\pm(N/2-1), -N/2\\}$。\n\n### 算法实现\n\n在每个离散时间步 $t_n = n \\Delta t$，执行以下过程：\n\n1.  **场值计算**：在离散空间网格 $\\{x_j\\}$ 上对预设函数 $A_\\parallel(x,t_n)$ 进行采样，得到向量 $\\mathbf{A}_{\\parallel,n}$。\n\n2.  **正向DFT**：使用快速傅里叶变换 (FFT) 算法计算 $\\mathbf{A}_{\\parallel,n}$ 的DFT：$\\widehat{\\mathbf{A}}_{\\parallel,n} = \\text{FFT}(\\mathbf{A}_{\\parallel,n})$。\n\n3.  **低k投影**：识别对应于波数 $|k_m| \\le k_{\\text{cut}}$ 的DFT系数。创建一个二进制掩码数组 $\\mathbf{M}$，其中如果 $|k_m| \\le k_{\\text{cut}}$ 则 $M_m=1$，否则 $M_m=0$。低k投影场的DFT通过逐元素相乘获得：$\\widehat{\\mathbf{A}}_{\\text{low},n} = \\widehat{\\mathbf{A}}_{\\parallel,n} \\odot \\mathbf{M}$。\n\n4.  **逆向DFT**：通过逆FFT计算实空间中的低k投影场：$\\mathbf{A}_{\\text{low},n} = \\text{iFFT}(\\widehat{\\mathbf{A}}_{\\text{low},n})$。该向量表示网格上的 $\\Pi_{\\le k_{\\text{cut}}}[A_\\parallel(x,t_n)]$。\n\n5.  **时间平滑**：使用预设的指数平均公式更新辛部分 $\\mathbf{A}_{\\parallel,n}^{(s)}$：\n    $$\n    \\mathbf{A}_{\\parallel,n}^{(s)} =\n    \\begin{cases}\n    \\mathbf{A}_{\\text{low},0}  \\text{若 } n=0 \\\\\n    \\alpha \\mathbf{A}_{\\text{low},n} + (1-\\alpha) \\mathbf{A}_{\\parallel,n-1}^{(s)}  \\text{若 } n \\ge 1\n    \\end{cases}\n    $$\n    其中 $\\mathbf{A}_{\\parallel,n-1}^{(s)}$ 是上一个时间步的结果。\n\n6.  **哈密顿部分**：通过相减计算哈密顿部分：$\\mathbf{A}_{\\parallel,n}^{(h)} = \\mathbf{A}_{\\parallel,n} - \\mathbf{A}_{\\parallel,n}^{(s)}$。\n\n### 诊断量计算\n\n**频谱泄漏度量**：\n对于每个时间步 $t_n$，在计算出 $\\mathbf{A}_{\\parallel,n}^{(s)}$ 和 $\\mathbf{A}_{\\parallel,n}^{(h)}$ 后：\n1.  计算它们的DFT：$\\widehat{\\mathbf{A}}_{\\parallel,n}^{(s)} = \\text{FFT}(\\mathbf{A}_{\\parallel,n}^{(s)})$ 和 $\\widehat{\\mathbf{A}}_{\\parallel,n}^{(h)} = \\text{FFT}(\\mathbf{A}_{\\parallel,n}^{(h)})$。\n2.  计算**向高k区的泄漏**：找出 $\\widehat{\\mathbf{A}}_{\\parallel,n}^{(s)}$ 中 $|k_m| > k_{\\text{cut}}$ 模式的系数的最大绝对值。\n3.  计算**向低k区的泄漏**：找出 $\\widehat{\\mathbf{A}}_{\\parallel,n}^{(h)}$ 中 $|k_m| \\le k_{\\text{cut}}$ 模式的系数的最大绝对值。\n4.  $t_n$ 时刻的频谱泄漏是这两个值的最大值。\n5.  总体度量是在所有时间步 $n=0, \\dots, N_t-1$ 中找到的最大泄漏值。\n\n对于 $\\alpha=1$ 的情况，我们有 $\\mathbf{A}_{\\parallel,n}^{(s)} = \\mathbf{A}_{\\text{low},n}$。根据构造，$\\widehat{\\mathbf{A}}_{\\parallel,n}^{(s)}$ 在 $|k_m| > k_{\\text{cut}}$ 处的 分量为零，因此向高k区的泄漏为零。相应地，$\\widehat{\\mathbf{A}}_{\\parallel,n}^{(h)} = \\widehat{\\mathbf{A}}_{\\parallel,n} - \\widehat{\\mathbf{A}}_{\\parallel,n}^{(s)}$ 在 $|k_m| \\le k_{\\text{cut}}$ 处的 分量将为零，使得向低k区的泄漏也为零。因此，预期结果是由浮点精度决定的值，即实际上为零。\n\n**时间变化率之比 ($R$)**：\n该度量量化了 $\\alpha  1$ 的平滑效果。在时间步 $n=1, \\dots, N_t-1$ 上累积两个和：\n1.  $\\mathrm{TV}_{\\text{smooth}}$：涉及平滑场 $\\mathbf{A}_{\\parallel}^{(s)}$。计算连续时间步之间差异的离散 $L^2$ 范数（欧几里得向量范数）$\\left\\|\\mathbf{A}_{\\parallel,n}^{(s)} - \\mathbf{A}_{\\parallel,n-1}^{(s)}\\right\\|_2$ 的运行总和。\n2.  $\\mathrm{TV}_{\\text{raw}}$：涉及原始投影场 $\\mathbf{A}_{\\text{low}}$。计算 $\\left\\|\\mathbf{A}_{\\text{low},n} - \\mathbf{A}_{\\text{low},n-1}\\right\\|_2$ 的运行总和。\n\n时间循环结束后，将两个总和都除以 $(N_t-1)$ 以找到平均时间变化。然后计算比率 $R = \\mathrm{TV}_{\\text{smooth}} / \\mathrm{TV}_{\\text{raw}}$。$R  1$ 的值表示成功的时间平滑。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem by running all test cases.\n    \"\"\"\n\n    def run_simulation(\n        L, N, Nt, dt, k_cut, alpha, A_func, metric\n    ):\n        \"\"\"\n        Runs a single simulation case for the given parameters and computes the\n        required diagnostic metric.\n        \"\"\"\n        # 1. Setup grid and wavenumbers\n        # Spatial grid in x\n        x_grid = np.linspace(0, L, N, endpoint=False)\n        # Time steps\n        t_vals = np.arange(Nt) * dt\n        # Wavenumbers k. For L=2*pi, d=L/N, so k = 2*pi*fftfreq(N,d) = N*fftfreq(N).\n        # This gives integer wavenumbers as required by the problem statement.\n        k_vals = np.fft.fftfreq(N) * N\n\n        # 2. Create the low-pass filter mask\n        low_k_mask = np.abs(k_vals) = k_cut\n\n        # 3. Initialize state variables and accumulators\n        A_s_prev = None\n        A_low_prev = None\n        max_leakage = 0.0\n        tv_smooth_sum = 0.0\n        tv_raw_sum = 0.0\n\n        # 4. Main time loop\n        for n, t in enumerate(t_vals):\n            # Evaluate A_parallel at the current time step on the grid\n            A_parallel_n = A_func(x_grid, t)\n\n            # Compute the low-k projection of A_parallel\n            A_k_n = np.fft.fft(A_parallel_n)\n            A_k_low_n = A_k_n * low_k_mask\n            A_low_n = np.fft.ifft(A_k_low_n).real\n\n            # Update the smoothed symplectic part A_s\n            if n == 0:\n                A_s_n = A_low_n\n            else:\n                A_s_n = alpha * A_low_n + (1 - alpha) * A_s_prev\n\n            # 5. Compute diagnostics based on the requested metric\n            if metric == 'leakage':\n                A_h_n = A_parallel_n - A_s_n\n                \n                A_s_k_n = np.fft.fft(A_s_n)\n                A_h_k_n = np.fft.fft(A_h_n)\n\n                leakage_to_high_k = np.max(np.abs(A_s_k_n[~low_k_mask]))\n                leakage_to_low_k = np.max(np.abs(A_h_k_n[low_k_mask]))\n                \n                current_leakage = max(leakage_to_high_k, leakage_to_low_k)\n                if current_leakage > max_leakage:\n                    max_leakage = current_leakage\n\n            elif metric == 'tv_ratio':\n                if n > 0:\n                    diff_smooth = A_s_n - A_s_prev\n                    diff_raw = A_low_n - A_low_prev\n                    tv_smooth_sum += np.linalg.norm(diff_smooth)\n                    tv_raw_sum += np.linalg.norm(diff_raw)\n\n            # 6. Store state for the next iteration\n            A_s_prev = A_s_n\n            A_low_prev = A_low_n\n\n        # 7. Finalize and return the result\n        if metric == 'leakage':\n            return max_leakage\n        elif metric == 'tv_ratio':\n            # Handle the case where raw variation is zero to avoid division by zero.\n            if tv_raw_sum == 0.0:\n                return 1.0\n            # The (Nt-1) factor cancels in the ratio\n            ratio = tv_smooth_sum / tv_raw_sum\n            return ratio\n        return None\n\n    # Define test cases from the problem statement\n    test_cases = [\n        {\n            \"L\": 2 * np.pi, \"N\": 128, \"Nt\": 12, \"dt\": 0.1,\n            \"k_cut\": 2.0, \"alpha\": 1.0, \"metric\": \"leakage\",\n            \"A_func\": lambda x, t: (\n                np.sin(1 * x) * np.cos(1.1 * t) +\n                0.2 * np.sin(6 * x) * np.cos(2.3 * t)\n            )\n        },\n        {\n            \"L\": 2 * np.pi, \"N\": 128, \"Nt\": 8, \"dt\": 0.15,\n            \"k_cut\": 4.0, \"alpha\": 1.0, \"metric\": \"leakage\",\n            \"A_func\": lambda x, t: np.sin(4 * x) * np.cos(0.9 * t)\n        },\n        {\n            \"L\": 2 * np.pi, \"N\": 128, \"Nt\": 20, \"dt\": 0.07,\n            \"k_cut\": 3.0, \"alpha\": 0.3, \"metric\": \"tv_ratio\",\n            \"A_func\": lambda x, t: (\n                np.sin(2 * x) * np.cos(1.3 * t) +\n                0.7 * np.sin(8 * x) * np.cos(3.7 * t)\n            )\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(**case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在学习了如何分解场之后，一个关键问题是：我们*为什么*要这样做？本次实践旨在揭示数值误差对基本物理定律（如电荷守恒）的影响。通过对比一个不守恒的朴素数值格式和一个采用了缓解策略的格式，你将亲眼见证回拉相关的修正技术如何恢复这一至关重要的不变性。",
            "id": "4033402",
            "problem": "你的任务是设计并实现一个离散诊断工具，用于在分布函数的回旋动理学微扰经过重复回拉更新后，验证总电荷的守恒性。目标是检查总电荷的不变性，该总电荷定义为连续量 $\\sum_{s} \\int q_{s}\\,\\delta f_{s}\\,dZ$ 的离散近似，并在多个更新步骤中进行验证。你的诊断工具必须基于第一性原理构建，不得依赖任何内置的守恒快捷方式。\n\n理论基础：在回旋动理学理论中，根据 Liouville 定理，具有哈密顿流的 Vlasov 方程保持相空间体积，并且不同表示之间的变换（回拉更新）不得改变物理上不变的积分。对于带有电荷 $q_{s}$ 的粒子种类 $s$ 的分布函数微扰 $\\delta f_{s}$，其在相空间上积分的总电荷在精确变换下必须是不变的，即 $\\frac{d}{dt}\\sum_{s}\\int q_{s}\\,\\delta f_{s}\\,dZ = 0$。在具有均匀网格的离散设置中，积分 $\\int \\cdot \\, dZ$ 通过使用单元体积的加权和来近似。\n\n你将实现一个程序，该程序：\n- 构建一个离散、均匀的笛卡尔相空间网格，坐标为 $Z = (x,y,v)$，其中 $x \\in [0,2\\pi)$，$y \\in [0,2\\pi)$，以及 $v \\in [-V,V]$。\n- 使用指定的公式和参数为每个粒子种类 $s$ 初始化 $\\delta f_{s}$。\n- 在给定的步数内重复应用指定的回拉更新算子。\n- 在每一步之后计算总电荷，并评估一个测量不变性的诊断工具。\n\n定义和要求：\n1. 设网格大小为 $N_x$、$N_y$、$N_v$，均匀间距为 $\\Delta x = \\frac{2\\pi}{N_x}$、$\\Delta y = \\frac{2\\pi}{N_y}$ 和 $\\Delta v = \\frac{2V}{N_v}$。离散单元体积为 $w = \\Delta x\\,\\Delta y\\,\\Delta v$。\n2. 对每个粒子种类 $s$，将 $\\delta f_{s}(x,y,v)$ 初始化为\n   $$\\delta f_{s}(x,y,v) = B_{s} + A_{s}\\,\\sin(k_{x} x)\\,\\cos(k_{y} y)\\,\\exp\\left(-\\frac{v^{2}}{2\\sigma^{2}}\\right),$$\n   其中 $B_{s}$ 是一个恒定偏移量，$A_{s}$ 是一个振幅，$k_{x}$ 和 $k_{y}$ 是整数波数，$\\sigma$ 是一个正常数宽度参数。\n3. 第 $n$ 步后的总离散电荷为\n   $$Q^{(n)} = \\sum_{s} q_{s}\\,w \\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1}\\sum_{k=0}^{N_v-1}\\delta f_{s}^{(n)}[i,j,k].$$\n4. 将诊断工具定义为在所有步骤 $0,1,\\dots,K$ 上的最大归一化偏差：\n   $$D = \\max_{0\\le n\\le K}\\frac{\\left|Q^{(n)} - Q^{(0)}\\right|}{\\max\\left(|Q^{(0)}|,\\varepsilon\\right)},$$\n   其中 $\\varepsilon$ 是一个用于避免除以零的小的正的常数，取值为 $\\varepsilon = 10^{-12}$（无量纲）。\n5. 实现用于测试套件的三个更新算子：\n   - 算子 $\\mathcal{A}$（精确测度保持）：对网格索引进行整数循环移位，从而精确地保持总和。具体来说，在每一步中，将 $\\delta f_{s}$ 在 $x$ 方向上循环移位 $s_{x}$ 个单元，在 $v$ 方向上循环移位 $s_{v}$ 个单元，采用周期性环绕，并保持 $y$ 不变。该算子必须对每个粒子种类都保持 $\\sum_{i,j,k}\\delta f_{s}$，从而保持 $Q^{(n)}$。\n   - 算子 $\\mathcal{B}$（非守恒）：在每一步中，在 $x$ 方向上应用小数位移并结合阻尼。对于小数位移参数 $\\alpha\\in(0,1)$ 和阻尼参数 $\\gamma\\in(0,1)$，更新为\n     $$\\delta f_{s}^{\\text{new}}[i,j,k] = (1-\\gamma)\\left((1-\\alpha)\\,\\delta f_{s}[i,j,k] + \\alpha\\,\\delta f_{s}[i-1,j,k]\\right),$$\n     在 $x$ 方向上采用非周期性边界条件，使得在 $i=0$ 的更新中，$\\delta f_{s}[-1,j,k]$ 的贡献为 $0$。该算子通常不会保持 $\\sum_{i,j,k}\\delta f_{s}$，因此也不会保持 $Q^{(n)}$。\n   - 算子 $\\mathcal{B}_{\\text{mit}}$（修正的）：应用算子 $\\mathcal{B}$，然后通过对一个粒子种类进行均匀校正来强制实现精确的总电荷不变性，以满足\n     $$\\sum_{s} q_{s}\\,w \\sum_{i,j,k} \\left(\\delta f_{s}^{\\text{corr}}[i,j,k]\\right) = Q^{(0)}.$$\n     一个具体的选择是只调整电子种类 $s=e$（其电荷 $q_{e}  0$），在 $\\mathcal{B}$ 更新后添加一个均匀偏移量 $c_{e}$，其中\n     $$c_{e} = \\frac{Q^{(0)} - Q^{\\text{temp}}}{q_{e}\\,w\\,N_x\\,N_y\\,N_v},$$\n     $Q^{\\text{temp}}$ 是应用 $\\mathcal{B}$ 之后、修正之前的总电荷。其他粒子种类保持不变。此步骤在浮点舍入误差范围内强制 $Q^{(n)}=Q^{(0)}$。\n\n6. 你必须计算并报告每个测试用例的诊断值 $D$，结果为一个无量纲单位的浮点数。不涉及角度。除了无量纲一致性外，不需要任何物理单位。\n\n测试套件：\n- 用例 1（理想路径，精确不变性）：$N_x=32$，$N_y=16$，$N_v=8$，$V=4$，粒子种类 $s\\in\\{e,i\\}$，电荷 $q_{e}=-1$，$q_{i}=+1$，偏移量 $B_{e}=10^{-2}$，$B_{i}=-9\\times 10^{-3}$，振幅 $A_{e}=10^{-1}$，$A_{i}=-7\\times 10^{-2}$，波数 $k_{x}=3$，$k_{y}=2$，宽度 $\\sigma=0.9$，步数 $K=50$，使用算子 $\\mathcal{A}$，移位 $s_{x}=3$，$s_{v}=1$。\n- 用例 2（非守恒漂移）：与用例 1 相同的 $N_x, N_y, N_v, V$，粒子电荷和初始化参数，步数 $K=50$，使用算子 $\\mathcal{B}$，参数 $\\alpha=0.37$，$\\gamma=0.01$。\n- 用例 3（修正强制不变性）：$N_x=64$，$N_y=16$，$N_v=8$，$V=4$，粒子种类 $s\\in\\{e,i\\}$，电荷 $q_{e}=-1$，$q_{i}=+1$，偏移量 $B_{e}=10^{-2}$，$B_{i}=-9\\times 10^{-3}$，振幅 $A_{e}=10^{-1}$，$A_{i}=-7\\times 10^{-2}$，波数 $k_{x}=3$，$k_{y}=2$，宽度 $\\sigma=0.9$，步数 $K=50$，使用算子 $\\mathcal{B}_{\\text{mit}}$，参数 $\\alpha=0.37$，$\\gamma=0.01$。\n\n答案规格：\n- 你的程序必须为上述三个用例中的每一个计算诊断值 $D$，并生成一行输出，其中包含三个结果，形式为方括号括起来的逗号分隔列表，例如 $[d_{1},d_{2},d_{3}]$，其中每个 $d_{i}$ 是一个浮点数。\n- 输出必须是单行，没有任何附加文本。所有值都是无量纲的。\n\n你的实现应该是通用的并且组织清晰，以便每个更新算子和诊断工具都根据上述定义明确实现。程序必须是自包含的，并且不应需要任何用户输入。你的解决方案的正确性将根据测试套件和指定的精确输出格式进行评判。",
            "solution": "问题陈述提出了一个有效且适定的计算任务，该任务基于计算等离子体物理（特别是回旋动理学）的原理。它要求实现一个数值诊断工具，以验证在将各种离散更新算子应用于回旋动理学分布函数微扰 $\\delta f_{s}$ 时总电荷的守恒性。所提供的定义、参数和测试用例是自包含、一致且科学上合理的。因此，我将着手提供一个完整、论证充分的解决方案。\n\n问题的核心在于将一个连续的物理系统离散化，然后测试数值算子如何影响一个守恒量。总电荷 $Q = \\sum_{s} \\int q_{s}\\,\\delta f_{s}\\,dZ$ 是连续 Vlasov-Maxwell 系统在哈密顿流下的一个不变量。我们的目标是构建一个数值模拟对应物，并观察其在不同离散时间演化算子下的行为。\n\n首先，我们建立离散相空间网格。连续相空间由坐标 $Z = (x,y,v)$ 在域 $[0,2\\pi) \\times [0,2\\pi) \\times [-V,V]$ 上定义。我们将此域离散化为一个大小为 $N_x \\times N_y \\times N_v$ 的均匀笛卡尔网格。离散网格点由以下公式给出：\n$x_i = i \\Delta x$，对于 $i \\in \\{0, 1, \\dots, N_x-1\\}$，其中 $\\Delta x = 2\\pi/N_x$。\n$y_j = j \\Delta y$，对于 $j \\in \\{0, 1, \\dots, N_y-1\\}$，其中 $\\Delta y = 2\\pi/N_y$。\n$v_k = -V + k \\Delta v$，对于 $k \\in \\{0, 1, \\dots, N_v-1\\}$，其中 $\\Delta v = 2V/N_v$。\n这个离散相空间的微元体积，或单元体积，在整个网格上是恒定的，由 $w = \\Delta x \\Delta y \\Delta v = \\frac{8\\pi^2 V}{N_x N_y N_v}$ 给出。每个粒子种类 $s$ 的分布函数微扰 $\\delta f_s(x,y,v)$ 由一个三维数组 $\\delta f_s[i,j,k]$ 表示，该数组存储其在每个网格点 $(x_i, y_j, v_k)$ 上的值。\n\n接下来，我们在第 $n=0$ 步初始化系统。每个粒子种类 $s$ 的初始微扰 $\\delta f_s^{(0)}$ 由以下函数定义：\n$$ \\delta f_{s}(x,y,v) = B_{s} + A_{s}\\,\\sin(k_{x} x)\\,\\cos(k_{y} y)\\,\\exp\\left(-\\frac{v^{2}}{2\\sigma^{2}}\\right) $$\n我们在每个离散网格点 $(x_i, y_j, v_k)$ 上计算此函数的值，以填充初始数组 $\\delta f_{s}^{(0)}[i,j,k]$。这里的 $B_s$、$A_s$、$k_x$、$k_y$ 和 $\\sigma$ 是给定的参数。\n\n主要关注的量是给定步骤 $n$ 的总离散电荷 $Q^{(n)}$。它是相空间积分的离散近似，通过对所有粒子种类和所有网格单元的贡献求和来计算：\n$$ Q^{(n)} = \\sum_{s} q_{s}\\,w \\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1}\\sum_{k=0}^{N_v-1}\\delta f_{s}^{(n)}[i,j,k] $$\n这个计算可以通过使用数组求和来高效实现，即 $Q^{(n)} = w \\sum_{s} q_{s} \\sum_{i,j,k} \\delta f_{s}^{(n)}[i,j,k]$。\n\n模拟的核心涉及对一个更新算子进行 $K$ 步的迭代应用。我们将实现三个指定的算子。\n\n1.  **算子 $\\mathcal{A}$（精确循环移位）**：此算子模拟了一个完全守恒的平流方案。它在 $x$ 和 $v$ 维度上对网格索引应用整数循环移位。\n    $$ \\delta f_{s}^{\\text{new}}[i,j,k] = \\delta f_{s}^{\\text{old}}[(i-s_x) \\pmod{N_x}, j, (k-s_v) \\pmod{N_v}] $$\n    其中 $s_x$ 和 $s_v$ 是整数移位量。循环移位是网格值的排列，因此对所有网格点的求和 $\\sum_{i,j,k}\\delta f_s[i,j,k]$ 对每个粒子种类都是独立且精确地保持的。因此，总电荷 $Q^{(n)}$ 必须在所有 $n$ 上保持不变，即 $Q^{(n)} = Q^{(0)}$，这在浮点运算的精度限制内成立。\n\n2.  **算子 $\\mathcal{B}$（非守恒更新）**：此算子模拟了一个简单的一阶数值方案，该方案同时引入了耗散和非守恒性。更新规则是：\n    $$ \\delta f_{s}^{\\text{new}}[i,j,k] = (1-\\gamma)\\left((1-\\alpha)\\,\\delta f_{s}^{\\text{old}}[i,j,k] + \\alpha\\,\\delta f_{s}^{\\text{old}}[i-1,j,k]\\right) $$\n    $x$ 方向上的非周期性边界条件规定，在更新网格索引 $i=0$ 时，项 $\\delta f_{s}^{\\text{old}}[-1,j,k]$ 被视为 $0$。这个边界条件以及阻尼因子 $(1-\\gamma)$ 破坏了每个粒子种类总粒子数 $\\sum \\delta f_s$ 的守恒性。因此，总电荷 $Q^{(n)}$ 预计不会守恒。\n\n3.  **算子 $\\mathcal{B}_{\\text{mit}}$（修正更新）**：此算子实现了一种常见的回拉修正策略：后验地强制一个守恒律。过程如下：\n    a. 首先，对所有粒子种类应用非守恒算子 $\\mathcal{B}$，产生一个临时分布 $\\delta f_{s}^{\\text{temp}}$ 和一个临时总电荷 $Q^{\\text{temp}}$。\n    b. 与初始电荷的偏差为 $\\Delta Q = Q^{(0)} - Q^{\\text{temp}}$。\n    c. 这个差额通过向单个粒子种类（此处选择为电子 $s=e$）的分布添加一个均匀偏移量 $c_e$ 来校正。该偏移量的计算旨在将总电荷恢复到其初始值：\n       $$ c_{e} = \\frac{Q^{(0)} - Q^{\\text{temp}}}{q_{e}\\,w\\,N_x\\,N_y\\,N_v} $$\n    d. 电子的最终更新分布为 $\\delta f_{e}^{(n)}[i,j,k] = \\delta f_{e}^{\\text{temp}}[i,j,k] + c_e$。所有其他粒子种类的分布保持不变，即对于 $s \\ne e$，$\\delta f_{s}^{(n)} = \\delta f_{s}^{\\text{temp}}$。\n    根据构造，此过程确保更新后的总电荷 $Q^{(n)}$ 等于 $Q^{(0)}$，同样在浮点精度范围内。\n\n最后，我们计算诊断值 $D$，它量化了在 $K$ 步的整个模拟过程中的最大电荷偏差。其定义为：\n$$ D = \\max_{0\\le n\\le K}\\frac{\\left|Q^{(n)} - Q^{(0)}\\right|}{\\max\\left(|Q^{(0)}|,\\varepsilon\\right)} $$\n项 $\\varepsilon = 10^{-12}$ 是一个小的正则化常数，用于防止在 $Q^{(0)}$ 恰好为零时发生除零错误，尽管在给定的测试用例中 $Q^{(0)}$ 是非零的。每个测试用例的总体算法如下：\n1.  初始化网格参数和粒子种类数据。\n2.  为所有粒子种类构建初始分布 $\\delta f_s^{(0)}$。\n3.  计算并存储初始总电荷 $Q^{(0)}$。\n4.  初始化一个电荷偏差列表，以 $|Q^{(0)} - Q^{(0)}| = 0$ 开始。\n5.  对 $n$ 从 $1$ 到 $K$ 进行循环：\n    a. 应用指定的更新算子（$\\mathcal{A}$、$\\mathcal{B}$ 或 $\\mathcal{B}_{\\text{mit}}$）以获得 $\\delta f_s^{(n)}$。\n    b. 计算新的总电荷 $Q^{(n)}$。\n    c. 计算并存储偏差 $|Q^{(n)} - Q^{(0)}|$。\n6.  在偏差列表中找到最大值。\n7.  将此最大值通过 $\\max(|Q^{(0)}|, \\varepsilon)$ 进行归一化，以获得最终的诊断值 $D$。\n\n对于用例 1（算子 $\\mathcal{A}$），由于算子是精确守恒的，我们期望 $D$ 的量级为机器精度。对于用例 2（算子 $\\mathcal{B}$），由于更新的非守恒性质，我们期望一个显著的非零 $D$。对于用例 3（算子 $\\mathcal{B}_{\\text{mit}}$），我们期望 $D$ 再次接近机器精度，这证明了修正策略在强制电荷守恒方面的有效性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    \n    epsilon = 1e-12\n\n    # Common parameters for some cases\n    common_species_params = {\n        'e': {'q': -1.0, 'B': 1e-2, 'A': 1e-1},\n        'i': {'q': 1.0, 'B': -9e-3, 'A': -7e-2}\n    }\n    common_init_params = {'kx': 3, 'ky': 2, 'sigma': 0.9}\n\n    test_cases = [\n        # Case 1: Exact invariance with operator A\n        {\n            'case_id': 1, 'operator': 'A',\n            'grid': {'Nx': 32, 'Ny': 16, 'Nv': 8, 'V': 4.0},\n            'species': common_species_params,\n            'init': common_init_params,\n            'K': 50,\n            'op_params': {'sx': 3, 'sv': 1}\n        },\n        # Case 2: Non-conservative drift with operator B\n        {\n            'case_id': 2, 'operator': 'B',\n            'grid': {'Nx': 32, 'Ny': 16, 'Nv': 8, 'V': 4.0},\n            'species': common_species_params,\n            'init': common_init_params,\n            'K': 50,\n            'op_params': {'alpha': 0.37, 'gamma': 0.01}\n        },\n        # Case 3: Mitigation enforces invariance with operator B_mit\n        {\n            'case_id': 3, 'operator': 'B_mit',\n            'grid': {'Nx': 64, 'Ny': 16, 'Nv': 8, 'V': 4.0},\n            'species': common_species_params,\n            'init': common_init_params,\n            'K': 50,\n            'op_params': {'alpha': 0.37, 'gamma': 0.01}\n        },\n    ]\n\n    results = []\n    for case_params in test_cases:\n        D = run_case(case_params, epsilon)\n        results.append(D)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef initialize_delta_f(grid_params, species_params, init_params):\n    \"\"\"\n    Initializes the distribution function perturbation delta_f for all species.\n    \"\"\"\n    Nx, Ny, Nv, V = grid_params['Nx'], grid_params['Ny'], grid_params['Nv'], grid_params['V']\n    kx, ky, sigma = init_params['kx'], init_params['ky'], init_params['sigma']\n\n    # Create grid coordinates\n    x = np.linspace(0, 2 * np.pi, Nx, endpoint=False)\n    y = np.linspace(0, 2 * np.pi, Ny, endpoint=False)\n    delta_v = 2 * V / Nv\n    v = np.linspace(-V, V - delta_v, Nv)\n    \n    xx, yy, vv = np.meshgrid(x, y, v, indexing='ij')\n\n    delta_fs = {}\n    for s_id, s_data in species_params.items():\n        B_s, A_s = s_data['B'], s_data['A']\n        \n        spatial_part = np.sin(kx * xx) * np.cos(ky * yy)\n        velocity_part = np.exp(-vv**2 / (2 * sigma**2))\n        \n        delta_fs[s_id] = B_s + A_s * spatial_part * velocity_part\n        \n    return delta_fs\n\ndef calculate_total_charge(delta_fs, grid_params, species_params):\n    \"\"\"\n    Calculates the total discrete charge Q.\n    \"\"\"\n    Nx, Ny, Nv, V = grid_params['Nx'], grid_params['Ny'], grid_params['Nv'], grid_params['V']\n    \n    delta_x = 2 * np.pi / Nx\n    delta_y = 2 * np.pi / Ny\n    delta_v = 2 * V / Nv\n    w = delta_x * delta_y * delta_v\n    \n    total_charge = 0.0\n    for s_id, f_s in delta_fs.items():\n        q_s = species_params[s_id]['q']\n        total_charge += q_s * np.sum(f_s)\n        \n    return total_charge * w\n\ndef apply_operator_A(delta_fs, op_params):\n    \"\"\"Applies the cyclic shift operator A.\"\"\"\n    sx, sv = op_params['sx'], op_params['sv']\n    new_delta_fs = {}\n    for s_id, f_s in delta_fs.items():\n        # Cyclic shift in x (axis 0)\n        f_s = np.roll(f_s, sx, axis=0)\n        # Cyclic shift in v (axis 2)\n        f_s = np.roll(f_s, sv, axis=2)\n        new_delta_fs[s_id] = f_s\n    return new_delta_fs\n\ndef apply_operator_B(delta_fs, op_params):\n    \"\"\"Applies the non-conservative operator B.\"\"\"\n    alpha, gamma = op_params['alpha'], op_params['gamma']\n    new_delta_fs = {}\n    for s_id, f_s in delta_fs.items():\n        # Vectorized implementation of the fractional shift with non-periodic BC\n        f_s_shifted = np.roll(f_s, 1, axis=0)\n        f_s_shifted[0, :, :] = 0.0  # Non-periodic boundary at i=0\n        \n        f_s_new = (1.0 - gamma) * ((1.0 - alpha) * f_s + alpha * f_s_shifted)\n        new_delta_fs[s_id] = f_s_new\n    return new_delta_fs\n\ndef apply_operator_B_mit(delta_fs, Q0, grid_params, species_params, op_params):\n    \"\"\"Applies the mitigated operator B_mit.\"\"\"\n    # Step 1: Apply operator B\n    delta_fs_temp = apply_operator_B(delta_fs, op_params)\n    \n    # Step 2: Calculate temporary charge\n    Q_temp = calculate_total_charge(delta_fs_temp, grid_params, species_params)\n    \n    # Step 3: Calculate correction for electrons\n    Nx, Ny, Nv, V = grid_params['Nx'], grid_params['Ny'], grid_params['Nv'], grid_params['V']\n    delta_x = 2 * np.pi / Nx\n    delta_y = 2 * np.pi / Ny\n    delta_v = 2 * V / Nv\n    w = delta_x * delta_y * delta_v\n    \n    q_e = species_params['e']['q']\n    total_volume = Nv * Ny * Nx * w\n    \n    c_e = (Q0 - Q_temp) / (q_e * total_volume)\n    \n    # Step 4: Apply correction\n    delta_fs_temp['e'] += c_e\n    \n    return delta_fs_temp\n\ndef run_case(params, epsilon):\n    \"\"\"\n    Runs a single simulation case and calculates the diagnostic D.\n    \"\"\"\n    # Unpack parameters\n    grid_params = params['grid']\n    species_params = params['species']\n    init_params = params['init']\n    K = params['K']\n    op_type = params['operator']\n    op_params = params['op_params']\n\n    # Initialization\n    delta_fs = initialize_delta_f(grid_params, species_params, init_params)\n    Q0 = calculate_total_charge(delta_fs, grid_params, species_params)\n    \n    max_deviation = 0.0\n    \n    for n in range(K):\n        # Apply the update operator\n        if op_type == 'A':\n            delta_fs = apply_operator_A(delta_fs, op_params)\n        elif op_type == 'B':\n            delta_fs = apply_operator_B(delta_fs, op_params)\n        elif op_type == 'B_mit':\n            delta_fs = apply_operator_B_mit(delta_fs, Q0, grid_params, species_params, op_params)\n        \n        # Calculate charge and deviation\n        Qn = calculate_total_charge(delta_fs, grid_params, species_params)\n        deviation = abs(Qn - Q0)\n        if deviation > max_deviation:\n            max_deviation = deviation\n            \n    # Calculate final diagnostic D\n    denominator = max(abs(Q0), epsilon)\n    D = max_deviation / denominator\n    \n    return D\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        },
        {
            "introduction": "回拉缓解不仅能提高精度，还对模拟的效率有深远影响。本次实践将探讨分解势场如何影响数值求解器的稳定性约束。你将设计一个能够适应问题“刚性”的子步长算法，从而证明通过减小驱动强平流的势场部分，可以显著节省计算成本。",
            "id": "4033367",
            "problem": "要求您设计并实现一种算法子步长策略，用于计算混合变量静电回旋动理学方程中的非线性项，该策略能在没有过高计算成本的情况下保持数值稳定性。该场景以纯数学术语提出，但为了科学真实性以及与计算聚变科学和工程的相关性，其基础是物理学。该策略必须在混合变量公式下从第一性原理推导得出，然后实现为一个完整、可运行的程序。\n\n混合变量静电公式将标量势分解为一个辛部分和一个哈密顿部分。具体来说，将总势写为 $\\phi = \\phi_{\\mathrm{S}} + \\phi_{\\mathrm{H}}$，并让一个用户控制的辛分数 $\\alpha \\in [0,1]$ 定义 $\\phi_{\\mathrm{S}} = \\alpha \\phi$ 和 $\\phi_{\\mathrm{H}} = (1 - \\alpha)\\phi$。在此公式中，回旋中心分布函数演化中的非线性项可以通过势的辛部分经由泊松括号生成的平流算子来表示。对于一个显式子步长方法，其主要的稳定约束来自于使用 $\\phi_{\\mathrm{S}}$ 构建的 $\\mathbf{E}\\times\\mathbf{B}$ 漂移平流速度的大小。\n\n您必须使用公认的定义和定律，基于在显式数值格式中标准的两个互补约束，推导出一个限制稳定性的子步长：\n\n- 一个从空间网格（间距为 $\\Delta x$）上的平流输运推导出的 Courant-Friedrichs-Lewy (CFL) 约束，其中相关的 $\\mathbf{E}\\times\\mathbf{B}$ 漂移大小由辛势和磁场强度 $B$ 决定。\n- 一个 Lipschitz 型局部误差控制，它使用预定的容差 $\\varepsilon$ 来限制由非线性算子在一个子步长内推进的函数的变化。Lipschitz 常数必须根据势的谱和分布函数的波数界来估计。\n\n设宏观时间步长为 $\\Delta t$。您的子步长策略必须确定最小整数子步数 $N_{\\mathrm{sub}} \\ge 1$，使得显式方法在 CFL 约束和局部误差界下都是稳定的。为确保计算实用性，每个宏观时间步长需施加一个允许的最大子步数 $N_{\\max}$；如果稳定性所需的 $N_{\\mathrm{sub}}$ 超过 $N_{\\max}$，则必须将其限制在 $N_{\\max}$，并报告在成本约束下无法保证稳定性。\n\n为了解决此问题，您应根据势的垂直谱内容来估计 $\\mathbf{E}\\times\\mathbf{B}$ 漂移速度。假设给定一组垂直波数 $\\{k_{y,i}\\}$ 和相应的势振幅 $\\{\\phi_{i}\\}$。辛势的梯度大小可以通过所有模式中 $|k_{y,i}\\,\\phi_{i}|$ 的最大值来估计，而与稳定性相关的平流速度大小与该梯度除以 $B$ 成正比。对于 Lipschitz 常数，假设被平流的量的梯度范数由一个已知的波数 $k_{\\max}$ 界定，因此由非线性算子引起的时间导数大小由漂移速度大小与 $k_{\\max}$ 的乘积界定。所有量必须使用国际单位制 (SI) 表示和使用，其中 $B$ 的单位是特斯拉，势振幅 $\\phi_{i}$ 的单位是伏特，波数的单位是米分之一，空间网格间距 $\\Delta x$ 的单位是米，$\\Delta t$ 的单位是秒，容差 $\\varepsilon$ 是无量纲的。\n\n您的程序必须为每个测试用例实现以下输出：\n- 计算在不受 $N_{\\max}$ 限制时满足两个约束的最小整数 $N_{\\mathrm{sub}}$，然后将其限制在 $N_{\\max}$。\n- 返回一个指示符，表明在成本约束下稳定性是否得到满足，即一个布尔值，如果无约束的最小 $N_{\\mathrm{sub}} \\le N_{\\max}$，则为真，否则为假。\n\n为确保可测试性，请使用以下参数值测试套件。对于每个用例，计算并返回由所选子步数和稳定性标志组成的数对。\n\n测试用例 1 (一般正常路径):\n- $\\Delta t = 1.0\\times 10^{-6}\\,\\mathrm{s}$,\n- $\\Delta x = 1.0\\times 10^{-3}\\,\\mathrm{m}$,\n- $C_{\\max} = 0.5$ (无量纲),\n- $B = 3.0\\,\\mathrm{T}$,\n- $\\alpha = 0.7$,\n- $\\{k_{y,i}\\} = [50, 100, 200]\\,\\mathrm{m}^{-1}$,\n- $\\{\\phi_{i}\\} = [5, 10, 4]\\,\\mathrm{V}$,\n- $k_{\\max} = 300\\,\\mathrm{m}^{-1}$,\n- $\\varepsilon = 0.02$ (无量纲),\n- $N_{\\max} = 20$.\n\n测试用例 2 (非线性消失的边界情况):\n- $\\Delta t = 1.0\\times 10^{-6}\\,\\mathrm{s}$,\n- $\\Delta x = 1.0\\times 10^{-3}\\,\\mathrm{m}$,\n- $C_{\\max} = 0.6$,\n- $B = 3.0\\,\\mathrm{T}$,\n- $\\alpha = 1.0$,\n- $\\{k_{y,i}\\} = [100]\\,\\mathrm{m}^{-1}$,\n- $\\{\\phi_{i}\\} = [0]\\,\\mathrm{V}$,\n- $k_{\\max} = 400\\,\\mathrm{m}^{-1}$,\n- $\\varepsilon = 0.01$,\n- $N_{\\max} = 10$.\n\n测试用例 3 (具有严重刚性和成本违规的边缘情况):\n- $\\Delta t = 1.0\\times 10^{-6}\\,\\mathrm{s}$,\n- $\\Delta x = 1.0\\times 10^{-3}\\,\\mathrm{m}$,\n- $C_{\\max} = 0.5$,\n- $B = 1.0\\,\\mathrm{T}$,\n- $\\alpha = 1.0$,\n- $\\{k_{y,i}\\} = [500, 800]\\,\\mathrm{m}^{-1}$,\n- $\\{\\phi_{i}\\} = [50, 80]\\,\\mathrm{V}$,\n- $k_{\\max} = 800\\,\\mathrm{m}^{-1}$,\n- $\\varepsilon = 0.01$,\n- $N_{\\max} = 50$.\n\n测试用例 4 (混合变量缓解降低了刚性):\n- $\\Delta t = 5.0\\times 10^{-7}\\,\\mathrm{s}$,\n- $\\Delta x = 5.0\\times 10^{-4}\\,\\mathrm{m}$,\n- $C_{\\max} = 0.7$,\n- $B = 2.5\\,\\mathrm{T}$,\n- $\\alpha = 0.2$,\n- $\\{k_{y,i}\\} = [150, 300]\\,\\mathrm{m}^{-1}$,\n- $\\{\\phi_{i}\\} = [20, 12]\\,\\mathrm{V}$,\n- $k_{\\max} = 500\\,\\mathrm{m}^{-1}$,\n- $\\varepsilon = 0.015$,\n- $N_{\\max} = 30$.\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素本身是一个双元素列表 $[N_{\\mathrm{sub}}, \\mathrm{stable}]$，$N_{\\mathrm{sub}}$ 是一个整数，$\\mathrm{stable}$ 是一个布尔值。例如，格式必须与 $[[n_{1},\\mathrm{True}],[n_{2},\\mathrm{False}],\\dots]$ 完全一样，其中 $n_{i}$ 是整数。",
            "solution": "该问题是有效的，因为它在科学上基于回旋动理学理论，在计算上与等离子体物理模拟相关，并且在数学上是适定的。所有必需的参数都已提供，目标陈述客观清晰。\n\n在此，我们按照问题陈述中阐述的方式，从第一性原理推导子步长算法。目标是确定在宏观时间步长 $\\Delta t$ 内，为使回旋动理学方程中非线性项的显式时间积分保持稳定所需的最小子步数 $N_{\\mathrm{sub}}$。\n\n不稳定性源于由 $\\mathbf{E}\\times\\mathbf{B}$ 漂移驱动的平流项，该漂移与静电势的辛部分 $\\phi_{\\mathrm{S}} = \\alpha \\phi$ 相关，其中 $\\alpha$ 是用户定义的辛分数。$\\mathbf{E}\\times\\mathbf{B}$ 漂移速度由 $\\mathbf{v}_{E} = (\\mathbf{E} \\times \\mathbf{B})/B^2$ 给出。对于辛部分，电场为 $\\mathbf{E}_{\\mathrm{S}} = -\\nabla_{\\perp} \\phi_{\\mathrm{S}}$，相应漂移速度的大小为：\n$$\nV_{\\mathrm{adv}} = |\\mathbf{v}_{\\mathrm{E,S}}| = \\frac{|\\nabla_{\\perp} \\phi_{\\mathrm{S}}|}{B}\n$$\n问题规定，总势的垂直梯度的最大值 $|\\nabla_{\\perp} \\phi|_{\\max}$，是根据其谱分量 $\\{k_{y,i}, \\phi_i\\}$ 估计为 $K_{\\phi} = \\max_{i}\\{|k_{y,i} \\phi_i|\\}$。然后，辛势的梯度估计为 $|\\nabla_{\\perp} \\phi_{\\mathrm{S}}|_{\\max} = \\alpha |\\nabla_{\\perp} \\phi|_{\\max} = \\alpha K_{\\phi}$。因此，决定稳定性的特征平流速度为：\n$$\nV_{\\mathrm{adv}} = \\frac{\\alpha K_{\\phi}}{B} = \\frac{\\alpha}{B} \\max_{i}\\{|k_{y,i} \\phi_i|\\}\n$$\n如果所有势振幅 $\\phi_i$ 均为零，则 $K_{\\phi}=0$ 且 $V_{\\mathrm{adv}}=0$，这意味着非线性项消失。\n\n每个子步长的时间步长 $\\Delta t_{\\mathrm{sub}} = \\Delta t / N_{\\mathrm{sub}}$ 必须满足两个约束。\n\n1.  **Courant-Friedrichs-Lewy (CFL) 约束：** 此条件限制了信息在单个时间步长内可以穿过一个网格单元的距离。对于平流速度为 $V_{\\mathrm{adv}}$、网格间距为 $\\Delta x$、最大 Courant 数为 $C_{\\max}$ 的情况，约束为：\n    $$\n    V_{\\mathrm{adv}} \\frac{\\Delta t_{\\mathrm{sub}}}{\\Delta x} \\le C_{\\max}\n    $$\n    代入 $\\Delta t_{\\mathrm{sub}} = \\Delta t / N_{\\mathrm{sub}}$ 并求解 $N_{\\mathrm{sub}}$，我们得到 CFL 条件所需的最小子步数：\n    $$\n    N_{\\mathrm{sub}} \\ge \\frac{V_{\\mathrm{adv}} \\Delta t}{C_{\\max} \\Delta x}\n    $$\n\n2.  **Lipschitz 型局部误差约束：** 此条件限制了被平流的函数 $f$ 在单个子步长内的变化。由非线性项引起的 $f$ 的时间演化近似为 $\\partial_t f \\approx -\\mathbf{v}_{\\mathrm{E,S}} \\cdot \\nabla_{\\perp} f$。在 $\\Delta t_{\\mathrm{sub}}$ 内 $f$ 的变化由 $\\Delta t_{\\mathrm{sub}} |V_{\\mathrm{adv}}| |\\nabla_{\\perp} f|_{\\max}$ 界定。问题为该函数的梯度范数提供了一个界，即 $|\\nabla_{\\perp} f|_{\\max} \\approx k_{\\max} |f|_{\\max}$，其中 $k_{\\max}$ 是 $f$ 的一个特征最大波数。局部相对误差必须小于容差 $\\varepsilon$：\n    $$\n    \\frac{|\\Delta f|}{|f|_{\\max}} \\approx \\frac{\\Delta t_{\\mathrm{sub}} V_{\\mathrm{adv}} k_{\\max} |f|_{\\max}}{|f|_{\\max}} = \\Delta t_{\\mathrm{sub}} V_{\\mathrm{adv}} k_{\\max} \\le \\varepsilon\n    $$\n    求解 $N_{\\mathrm{sub}}$ 得到第二个条件：\n    $$\n    N_{\\mathrm{sub}} \\ge \\frac{V_{\\mathrm{adv}} k_{\\max} \\Delta t}{\\varepsilon}\n    $$\n\n为同时满足两个约束，$N_{\\mathrm{sub}}$ 必须大于或等于两个推导出的下界中的最大值。设 $N_{\\mathrm{raw}}$ 为所需的（实值）子步数：\n$$\nN_{\\mathrm{raw}} = \\max\\left( \\frac{V_{\\mathrm{adv}} \\Delta t}{C_{\\max} \\Delta x}, \\frac{V_{\\mathrm{adv}} k_{\\max} \\Delta t}{\\varepsilon} \\right) = V_{\\mathrm{adv}} \\Delta t \\cdot \\max\\left( \\frac{1}{C_{\\max} \\Delta x}, \\frac{k_{\\max}}{\\varepsilon} \\right)\n$$\n由于子步数必须是至少为 1 的整数，因此所需的最小子步数 $N_{\\mathrm{req}}$ 为：\n$$\nN_{\\mathrm{req}} = \\max\\left(1, \\lceil N_{\\mathrm{raw}} \\rceil\\right)\n$$\n其中 $\\lceil \\cdot \\rceil$ 是上取整函数。\n\n最后，我们应用计算成本约束。要使用的子步数 $N_{\\mathrm{sub}}$ 被限制在允许的最大值 $N_{\\max}$。一个布尔标志 `stable` 指示是否能在此预算内满足稳定性要求。\n最终的子步数为 $N_{\\mathrm{sub}} = \\min(N_{\\mathrm{req}}, N_{\\max})$。\n稳定性标志为 $\\mathrm{stable} = (N_{\\mathrm{req}} \\le N_{\\max})$。\n\n为每个测试用例计算数对 $[N_{\\mathrm{sub}}, \\mathrm{stable}]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef calculate_substeps(params):\n    \"\"\"\n    Calculates the number of substeps and stability flag for a given set of parameters.\n    \n    Args:\n        params (dict): A dictionary containing all the physical and numerical parameters.\n    \n    Returns:\n        list: A two-element list [N_sub, stable_flag].\n    \"\"\"\n    delta_t = params[\"delta_t\"]\n    delta_x = params[\"delta_x\"]\n    C_max = params[\"C_max\"]\n    B = params[\"B\"]\n    alpha = params[\"alpha\"]\n    k_y = np.array(params[\"k_y_i\"])\n    phi = np.array(params[\"phi_i\"])\n    k_max = params[\"k_max\"]\n    epsilon = params[\"epsilon\"]\n    N_max = params[\"N_max\"]\n\n    # Step 1: Calculate K_phi = max(|k_y * phi|)\n    if len(k_y) == 0 or len(phi) == 0:\n        K_phi = 0.0\n    else:\n        K_phi = np.max(np.abs(k_y * phi))\n\n    # If the nonlinear term is zero, V_adv is zero, and one substep is sufficient.\n    if K_phi == 0.0:\n        N_req = 1\n    else:\n        # Step 2: Calculate the characteristic advection speed V_adv\n        V_adv = (alpha * K_phi) / B\n\n        # Step 3: Calculate the terms for CFL and Lipschitz constraints\n        cfl_term = 1.0 / (C_max * delta_x)\n        lip_term = k_max / epsilon\n        \n        # Step 4: Calculate the raw, real-valued number of substeps\n        N_raw = V_adv * delta_t * max(cfl_term, lip_term)\n        \n        # Step 5: Required N_sub is the ceiling of N_raw, with a minimum of 1\n        N_req = max(1, math.ceil(N_raw))\n\n    # Step 6: Determine stability flag based on N_max\n    is_stable = (N_req = N_max)\n\n    # Step 7: Cap the number of substeps at N_max\n    N_sub = min(N_req, N_max)\n\n    return [N_sub, is_stable]\n\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print the final output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"delta_t\": 1.0e-6, \"delta_x\": 1.0e-3, \"C_max\": 0.5, \"B\": 3.0, \n            \"alpha\": 0.7, \"k_y_i\": [50, 100, 200], \"phi_i\": [5, 10, 4],\n            \"k_max\": 300, \"epsilon\": 0.02, \"N_max\": 20\n        },\n        {\n            \"delta_t\": 1.0e-6, \"delta_x\": 1.0e-3, \"C_max\": 0.6, \"B\": 3.0,\n            \"alpha\": 1.0, \"k_y_i\": [100], \"phi_i\": [0],\n            \"k_max\": 400, \"epsilon\": 0.01, \"N_max\": 10\n        },\n        {\n            \"delta_t\": 1.0e-6, \"delta_x\": 1.0e-3, \"C_max\": 0.5, \"B\": 1.0,\n            \"alpha\": 1.0, \"k_y_i\": [500, 800], \"phi_i\": [50, 80],\n            \"k_max\": 800, \"epsilon\": 0.01, \"N_max\": 50\n        },\n        {\n            \"delta_t\": 5.0e-7, \"delta_x\": 5.0e-4, \"C_max\": 0.7, \"B\": 2.5,\n            \"alpha\": 0.2, \"k_y_i\": [150, 300], \"phi_i\": [20, 12],\n            \"k_max\": 500, \"epsilon\": 0.015, \"N_max\": 30\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_substeps(case)\n        results.append(result)\n\n    # Format the final output string exactly as specified.\n    # str([4, True]) produces \"[4, True]\". Joining these with commas\n    # and enclosing in brackets gives the desired format.\n    result_str = \",\".join(map(str, results))\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        }
    ]
}