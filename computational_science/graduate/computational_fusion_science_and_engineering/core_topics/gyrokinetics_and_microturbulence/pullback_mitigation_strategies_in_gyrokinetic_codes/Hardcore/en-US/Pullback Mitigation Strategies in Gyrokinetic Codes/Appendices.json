{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of pullback mitigation is the decomposition of electromagnetic fields into distinct components based on their spatial scale. This practice provides a direct, hands-on implementation of this core concept by developing an algorithm to split the parallel vector potential, $A_{\\parallel}$, into its low-wavenumber (symplectic) and high-wavenumber (Hamiltonian) parts. By working through the process of Fourier analysis, spectral projection, and temporal smoothing, you will build a foundational tool essential for constructing modern, cancellation-free gyrokinetic codes .",
            "id": "4033410",
            "problem": "Consider a one-dimensional slab domain with periodic boundary conditions in the spatial coordinate $x \\in [0,L)$ and a real-valued, prescribed time-dependent parallel vector potential $A_{\\parallel}(x,t)$. In gyrokinetic formulations, the cancellation problem in the parallel Ampère equation can be mitigated via a splitting of $A_{\\parallel}$ into a symplectic part $A_{\\parallel}^{(s)}$ and a Hamiltonian part $A_{\\parallel}^{(h)}$, where the large-scale, low-perpendicular-wavenumber content is assigned to $A_{\\parallel}^{(s)}$ and the remaining content to $A_{\\parallel}^{(h)}$. A practical algorithmic approach consistent with this idea in a slab is to use projection onto low-$k_\\perp$ Fourier components of $A_{\\parallel}$ at each time step. In this problem, $k_\\perp$ is represented by the scalar wavenumber $k$ along $x$.\n\nStarting from first principles relevant to Fourier analysis on periodic domains and linear projection, derive an algorithm that, for each discrete time $t_n = n \\Delta t$, computes $A_{\\parallel}^{(s)}(x,t_n)$ and $A_{\\parallel}^{(h)}(x,t_n)$ by:\n- computing the discrete Fourier transform of $A_{\\parallel}(x,t_n)$ across $x$,\n- projecting onto the subspace of Fourier modes with $\\lvert k \\rvert \\le k_{\\text{cut}}$ to obtain the low-$k$ part, and\n- defining $A_{\\parallel}^{(s)}(x,t_n)$ as a temporally smoothed version of the low-$k$ part via exponential averaging and $A_{\\parallel}^{(h)}(x,t_n) = A_{\\parallel}(x,t_n) - A_{\\parallel}^{(s)}(x,t_n)$.\n\nYour derivation must begin from the orthogonality of Fourier basis functions on $[0,L)$, the existence of a complete Fourier representation for square-integrable periodic functions, and the definition of an orthogonal projector onto a subspace spanned by basis elements. Do not assume any specialized formulas beyond these bases.\n\nImplementation requirements:\n- Spatial discretization: use $N$ equidistant grid points in $x \\in [0,L)$ with $L = 2\\pi$ and $N = 128$.\n- Time discretization: use $N_t$ steps with $t_n = n \\Delta t$ for $n=0,1,\\dots,N_t-1$ and the specified $\\Delta t$ per test case.\n- Fourier transforms must be interpreted consistently with the discrete periodic grid. The angular wavenumbers are $k_m = \\dfrac{2\\pi m}{L}$ for integer mode index $m$ corresponding to the discrete Fourier transform. Angles in trigonometric functions are in radians.\n- Low-$k$ projection: retain Fourier coefficients with $\\lvert k_m \\rvert \\le k_{\\text{cut}}$. All other coefficients are set to zero.\n- Temporal smoothing: for $n \\ge 1$, define\n$$\nA_{\\parallel}^{(s)}(x,t_n) = \\alpha\\,\\Pi_{\\le k_{\\text{cut}}}\\left[A_{\\parallel}(x,t_n)\\right] + (1-\\alpha)\\,A_{\\parallel}^{(s)}(x,t_{n-1}),\n$$\nwith $A_{\\parallel}^{(s)}(x,t_0) = \\Pi_{\\le k_{\\text{cut}}}\\left[A_{\\parallel}(x,t_0)\\right]$, where $\\Pi_{\\le k_{\\text{cut}}}$ denotes the low-$k$ projector and $\\alpha \\in (0,1]$ is the smoothing parameter. Then set $A_{\\parallel}^{(h)}(x,t_n) = A_{\\parallel}(x,t_n) - A_{\\parallel}^{(s)}(x,t_n)$.\n\nDefine the following diagnostics:\n- Spectral leakage at time $t_n$: compute the discrete Fourier transforms $\\widehat{A_{\\parallel}^{(s)}}(k_m,t_n)$ and $\\widehat{A_{\\parallel}^{(h)}}(k_m,t_n)$. Define leakage-to-low-$k$ as the maximum absolute value of $\\widehat{A_{\\parallel}^{(h)}}(k_m,t_n)$ over $\\lvert k_m \\rvert \\le k_{\\text{cut}}$. Define leakage-to-high-$k$ as the maximum absolute value of $\\widehat{A_{\\parallel}^{(s)}}(k_m,t_n)$ over $\\lvert k_m \\rvert > k_{\\text{cut}}$. The spectral leakage metric at $t_n$ is the maximum of these two leakages. The overall spectral leakage metric for a case is the maximum spectral leakage across all time steps $n$.\n- Temporal variation ratio (for the smoothing test): define the average discrete $L^2$-norm of successive differences across time for the smoothed low-$k$ field, \n$$\n\\mathrm{TV}_{\\text{smooth}} = \\frac{1}{N_t-1}\\sum_{n=1}^{N_t-1} \\left\\|A_{\\parallel}^{(s)}(x,t_n) - A_{\\parallel}^{(s)}(x,t_{n-1})\\right\\|_2,\n$$\nand for the raw low-$k$ projection (i.e., without smoothing, $\\alpha=1$),\n$$\n\\mathrm{TV}_{\\text{raw}} = \\frac{1}{N_t-1}\\sum_{n=1}^{N_t-1} \\left\\|\\Pi_{\\le k_{\\text{cut}}}\\left[A_{\\parallel}(x,t_n)\\right] - \\Pi_{\\le k_{\\text{cut}}}\\left[A_{\\parallel}(x,t_{n-1})\\right]\\right\\|_2.\n$$\nReport the ratio $R = \\mathrm{TV}_{\\text{smooth}}/\\mathrm{TV}_{\\text{raw}}$.\n\nUse the Fast Fourier Transform (FFT) algorithm for discrete transforms. Fast Fourier Transform (FFT) should be interpreted consistently with the chosen discretization.\n\nTest suite:\n- Case $1$ (happy path): $L = 2\\pi$, $N = 128$, $N_t = 12$, $\\Delta t = 0.1$, $k_{\\text{cut}} = 2.0$, $\\alpha = 1.0$ (no smoothing). Prescribe\n$$\nA_{\\parallel}(x,t) = \\sin(1\\cdot x)\\,\\cos(1.1\\,t) + 0.2\\,\\sin(6\\cdot x)\\,\\cos(2.3\\,t).\n$$\nCompute and return the overall spectral leakage metric as a float.\n- Case $2$ (boundary mode at cutoff): $L = 2\\pi$, $N = 128$, $N_t = 8$, $\\Delta t = 0.15$, $k_{\\text{cut}} = 4.0$, $\\alpha = 1.0$. Prescribe\n$$\nA_{\\parallel}(x,t) = \\sin(4\\cdot x)\\,\\cos(0.9\\,t).\n$$\nCompute and return the overall spectral leakage metric as a float.\n- Case $3$ (smoothing effectiveness): $L = 2\\pi$, $N = 128$, $N_t = 20$, $\\Delta t = 0.07$, $k_{\\text{cut}} = 3.0$, $\\alpha = 0.3$. Prescribe\n$$\nA_{\\parallel}(x,t) = \\sin(2\\cdot x)\\,\\cos(1.3\\,t) + 0.7\\,\\sin(8\\cdot x)\\,\\cos(3.7\\,t).\n$$\nCompute and return the temporal variation ratio $R$ as a float.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3\\right]$). The three entries must be, in order, the float for Case $1$, the float for Case $2$, and the float for Case $3$. All trigonometric angles are in radians. No physical units are required beyond the specification given.",
            "solution": "The problem requires the derivation and implementation of an algorithm for splitting a time-dependent parallel vector potential $A_{\\parallel}(x,t)$ into a temporally smoothed low-wavenumber (symplectic) part $A_{\\parallel}^{(s)}(x,t)$ and a residual (Hamiltonian) part $A_{\\parallel}^{(h)}(x,t)$. This procedure is a mitigation strategy for the cancellation problem in gyrokinetic simulations. The derivation must proceed from the first principles of Fourier analysis and linear projection.\n\n### Derivation from First Principles\n\n**1. Fourier Series Representation**\nA function $f(x)$ that is periodic on the domain $x \\in [0,L)$ and square-integrable can be represented as a Fourier series. The basis functions for this representation are the complex exponentials $\\{\\phi_m(x) = e^{ik_m x}\\}$, where $k_m = \\frac{2\\pi m}{L}$ for integer mode indices $m \\in \\mathbb{Z}$. These basis functions are orthogonal with respect to the inner product $\\langle f, g \\rangle = \\int_0^L f(x)^* g(x) dx$. The orthogonality relation is:\n$$\n\\langle \\phi_m, \\phi_n \\rangle = \\int_0^L (e^{ik_m x})^* e^{ik_n x} dx = \\int_0^L e^{-ik_m x} e^{ik_n x} dx = L\\delta_{mn}\n$$\nwhere $\\delta_{mn}$ is the Kronecker delta.\n\nThe completeness of this basis allows any such function $A_{\\parallel}(x,t)$ (at a fixed time $t$) to be written as a linear combination of these basis functions:\n$$\nA_{\\parallel}(x,t) = \\sum_{m=-\\infty}^{\\infty} \\widehat{A_{\\parallel}}(k_m,t)\\, e^{ik_m x}\n$$\nThe Fourier coefficients $\\widehat{A_{\\parallel}}(k_m,t)$ are determined by projecting $A_{\\parallel}(x,t)$ onto each basis function:\n$$\n\\widehat{A_{\\parallel}}(k_m,t) = \\frac{\\langle \\phi_m, A_{\\parallel} \\rangle}{\\langle \\phi_m, \\phi_m \\rangle} = \\frac{1}{L} \\int_0^L A_{\\parallel}(x,t)\\, e^{-ik_m x} dx\n$$\n\n**2. Projection onto Low-Wavenumber Subspace**\nThe problem defines the low-wavenumber content as the part of the function corresponding to Fourier modes with $|k_m| \\le k_{\\text{cut}}$. This corresponds to a projection onto the subspace $V_{\\text{low}} = \\text{span}\\{e^{ik_m x} : |k_m| \\le k_{\\text{cut}}\\}$. An orthogonal projection operator $\\Pi_{\\le k_{\\text{cut}}}$ maps a function to its component within this subspace. For any function $A_{\\parallel}(x,t)$, its projection is given by summing over only the basis functions in $V_{\\text{low}}$:\n$$\n\\Pi_{\\le k_{\\text{cut}}}[A_{\\parallel}(x,t)] = \\sum_{m \\text{ s.t. } |k_m| \\le k_{\\text{cut}}} \\widehat{A_{\\parallel}}(k_m,t)\\, e^{ik_m x}\n$$\nAlgorithmically, this projection is performed by:\n1.  Computing the Fourier transform $\\widehat{A_{\\parallel}}(k_m,t)$ for all $m$.\n2.  Setting to zero all coefficients for which $|k_m| > k_{\\text{cut}}$.\n3.  Computing the inverse Fourier transform of the modified set of coefficients.\n\n**3. Discretization and the Discrete Fourier Transform (DFT)**\nFor a numerical implementation, the continuous domain $x \\in [0,L)$ is discretized into $N$ equidistant points, $x_j = j \\frac{L}{N}$ for $j=0, 1, \\dots, N-1$. A function is represented by its values on this grid, e.g., $A_{\\parallel, j}(t) = A_\\parallel(x_j,t)$.\n\nThe continuous Fourier transform is replaced by the Discrete Fourier Transform (DFT). The standard DFT pair (as used in `numpy.fft`) is:\n$$\n\\widehat{A}_m = \\sum_{j=0}^{N-1} A_j e^{-i 2\\pi mj/N} \\quad (\\text{Forward DFT})\n$$\n$$\nA_j = \\frac{1}{N} \\sum_{m=0}^{N-1} \\widehat{A}_m e^{i 2\\pi mj/N} \\quad (\\text{Inverse DFT})\n$$\nThe DFT mode index $m$ corresponds to a physical wavenumber. For a grid spacing of $\\Delta x = L/N$, the wavenumbers associated with the DFT indices are given by $k_m = 2\\pi f_m$, where $f_m$ are the spatial frequencies. These frequencies are provided by FFT libraries, typically in a specific order. For the parameters $L=2\\pi$ and grid spacing $\\Delta x = 2\\pi/N$, the corresponding physical wavenumbers are integer valued, $k_m = m'$, where $m' \\in \\{0, \\pm 1, \\dots, \\pm(N/2-1), -N/2\\}$.\n\n### Algorithmic Implementation\n\nAt each discrete time step $t_n = n \\Delta t$, the following procedure is executed:\n\n1.  **Evaluate Field**: Sample the prescribed function $A_{\\parallel}(x,t_n)$ on the discrete spatial grid $\\{x_j\\}$, yielding the vector $\\mathbf{A}_{\\parallel,n}$.\n\n2.  **Forward DFT**: Compute the DFT of $\\mathbf{A}_{\\parallel,n}$ using the Fast Fourier Transform (FFT) algorithm: $\\widehat{\\mathbf{A}}_{\\parallel,n} = \\text{FFT}(\\mathbf{A}_{\\parallel,n})$.\n\n3.  **Low-k Projection**: Identify the DFT coefficients corresponding to wavenumbers $|k_m| \\le k_{\\text{cut}}$. Create a binary mask array $\\mathbf{M}$ where $M_m=1$ if $|k_m| \\le k_{\\text{cut}}$ and $M_m=0$ otherwise. The DFT of the low-k projected field is obtained by element-wise multiplication: $\\widehat{\\mathbf{A}}_{\\text{low},n} = \\widehat{\\mathbf{A}}_{\\parallel,n} \\odot \\mathbf{M}$.\n\n4.  **Inverse DFT**: Compute the low-k projected field in real space via the inverse FFT: $\\mathbf{A}_{\\text{low},n} = \\text{iFFT}(\\widehat{\\mathbf{A}}_{\\text{low},n})$. This vector represents $\\Pi_{\\le k_{\\text{cut}}}[A_{\\parallel}(x,t_n)]$ on the grid.\n\n5.  **Temporal Smoothing**: Update the symplectic part $\\mathbf{A}_{\\parallel,n}^{(s)}$ using the prescribed exponential averaging formula:\n    $$\n    \\mathbf{A}_{\\parallel,n}^{(s)} =\n    \\begin{cases}\n    \\mathbf{A}_{\\text{low},0} & \\text{if } n=0 \\\\\n    \\alpha \\mathbf{A}_{\\text{low},n} + (1-\\alpha) \\mathbf{A}_{\\parallel,n-1}^{(s)} & \\text{if } n \\ge 1\n    \\end{cases}\n    $$\n    where $\\mathbf{A}_{\\parallel,n-1}^{(s)}$ is the result from the previous time step.\n\n6.  **Hamiltonian Part**: Compute the Hamiltonian part by subtraction: $\\mathbf{A}_{\\parallel,n}^{(h)} = \\mathbf{A}_{\\parallel,n} - \\mathbf{A}_{\\parallel,n}^{(s)}$.\n\n### Diagnostics Calculation\n\n**Spectral Leakage Metric**:\nFor each time step $t_n$, after computing $\\mathbf{A}_{\\parallel,n}^{(s)}$ and $\\mathbf{A}_{\\parallel,n}^{(h)}$:\n1.  Compute their DFTs: $\\widehat{\\mathbf{A}}_{\\parallel,n}^{(s)} = \\text{FFT}(\\mathbf{A}_{\\parallel,n}^{(s)})$ and $\\widehat{\\mathbf{A}}_{\\parallel,n}^{(h)} = \\text{FFT}(\\mathbf{A}_{\\parallel,n}^{(h)})$.\n2.  Calculate **leakage-to-high-k**: find the maximum absolute value of coefficients in $\\widehat{\\mathbf{A}}_{\\parallel,n}^{(s)}$ for modes where $|k_m| > k_{\\text{cut}}$.\n3.  Calculate **leakage-to-low-k**: find the maximum absolute value of coefficients in $\\widehat{\\mathbf{A}}_{\\parallel,n}^{(h)}$ for modes where $|k_m| \\le k_{\\text{cut}}$.\n4.  The spectral leakage at $t_n$ is the maximum of these two values.\n5.  The overall metric is the maximum leakage found across all time steps $n=0, \\dots, N_t-1$.\n\nFor the case $\\alpha=1$, we have $\\mathbf{A}_{\\parallel,n}^{(s)} = \\mathbf{A}_{\\text{low},n}$. By construction, $\\widehat{\\mathbf{A}}_{\\parallel,n}^{(s)}$ has zero components for $|k_m| > k_{\\text{cut}}$, so leakage-to-high-k is zero. Consequently, $\\widehat{\\mathbf{A}}_{\\parallel,n}^{(h)} = \\widehat{\\mathbf{A}}_{\\parallel,n} - \\widehat{\\mathbf{A}}_{\\parallel,n}^{(s)}$ will have zero components for $|k_m| \\le k_{\\text{cut}}$, making leakage-to-low-k also zero. The expected result is therefore a value determined by floating-point precision, i.e., effectively zero.\n\n**Temporal Variation Ratio ($R$)**:\nThis metric quantifies the smoothing effect of $\\alpha < 1$. Two sums are accumulated over the time steps $n=1, \\dots, N_t-1$:\n1.  $\\mathrm{TV}_{\\text{smooth}}$: Involves the smoothed field $\\mathbf{A}_{\\parallel}^{(s)}$. A running sum of the discrete $L^2$-norm (Euclidean vector norm) of the difference between successive time steps, $\\left\\|\\mathbf{A}_{\\parallel,n}^{(s)} - \\mathbf{A}_{\\parallel,n-1}^{(s)}\\right\\|_2$, is computed.\n2.  $\\mathrm{TV}_{\\text{raw}}$: Involves the raw projected field $\\mathbf{A}_{\\text{low}}$. A running sum of $\\left\\|\\mathbf{A}_{\\text{low},n} - \\mathbf{A}_{\\text{low},n-1}\\right\\|_2$ is computed.\n\nAfter the time loop, both sums are divided by $(N_t-1)$ to find the average temporal variations. The ratio $R = \\mathrm{TV}_{\\text{smooth}} / \\mathrm{TV}_{\\text{raw}}$ is then calculated. A value of $R < 1$ indicates successful temporal smoothing.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem by running all test cases.\n    \"\"\"\n\n    def run_simulation(\n        L, N, Nt, dt, k_cut, alpha, A_func, metric\n    ):\n        \"\"\"\n        Runs a single simulation case for the given parameters and computes the\n        required diagnostic metric.\n        \"\"\"\n        # 1. Setup grid and wavenumbers\n        # Spatial grid in x\n        x_grid = np.linspace(0, L, N, endpoint=False)\n        # Time steps\n        t_vals = np.arange(Nt) * dt\n        # Wavenumbers k. For L=2*pi, d=L/N, so k = 2*pi*fftfreq(N,d) = N*fftfreq(N).\n        # This gives integer wavenumbers as required by the problem statement.\n        k_vals = np.fft.fftfreq(N) * N\n\n        # 2. Create the low-pass filter mask\n        low_k_mask = np.abs(k_vals) <= k_cut\n\n        # 3. Initialize state variables and accumulators\n        A_s_prev = None\n        A_low_prev = None\n        max_leakage = 0.0\n        tv_smooth_sum = 0.0\n        tv_raw_sum = 0.0\n\n        # 4. Main time loop\n        for n, t in enumerate(t_vals):\n            # Evaluate A_parallel at the current time step on the grid\n            A_parallel_n = A_func(x_grid, t)\n\n            # Compute the low-k projection of A_parallel\n            A_k_n = np.fft.fft(A_parallel_n)\n            A_k_low_n = A_k_n * low_k_mask\n            A_low_n = np.fft.ifft(A_k_low_n).real\n\n            # Update the smoothed symplectic part A_s\n            if n == 0:\n                A_s_n = A_low_n\n            else:\n                A_s_n = alpha * A_low_n + (1 - alpha) * A_s_prev\n\n            # 5. Compute diagnostics based on the requested metric\n            if metric == 'leakage':\n                A_h_n = A_parallel_n - A_s_n\n                \n                A_s_k_n = np.fft.fft(A_s_n)\n                A_h_k_n = np.fft.fft(A_h_n)\n\n                leakage_to_high_k = np.max(np.abs(A_s_k_n[~low_k_mask]))\n                leakage_to_low_k = np.max(np.abs(A_h_k_n[low_k_mask]))\n                \n                current_leakage = max(leakage_to_high_k, leakage_to_low_k)\n                if current_leakage > max_leakage:\n                    max_leakage = current_leakage\n\n            elif metric == 'tv_ratio':\n                if n > 0:\n                    diff_smooth = A_s_n - A_s_prev\n                    diff_raw = A_low_n - A_low_prev\n                    tv_smooth_sum += np.linalg.norm(diff_smooth)\n                    tv_raw_sum += np.linalg.norm(diff_raw)\n\n            # 6. Store state for the next iteration\n            A_s_prev = A_s_n\n            A_low_prev = A_low_n\n\n        # 7. Finalize and return the result\n        if metric == 'leakage':\n            return max_leakage\n        elif metric == 'tv_ratio':\n            # Handle the case where raw variation is zero to avoid division by zero.\n            if tv_raw_sum == 0.0:\n                return 1.0\n            # The (Nt-1) factor cancels in the ratio\n            ratio = tv_smooth_sum / tv_raw_sum\n            return ratio\n        return None\n\n    # Define test cases from the problem statement\n    test_cases = [\n        {\n            \"L\": 2 * np.pi, \"N\": 128, \"Nt\": 12, \"dt\": 0.1,\n            \"k_cut\": 2.0, \"alpha\": 1.0, \"metric\": \"leakage\",\n            \"A_func\": lambda x, t: (\n                np.sin(1 * x) * np.cos(1.1 * t) +\n                0.2 * np.sin(6 * x) * np.cos(2.3 * t)\n            )\n        },\n        {\n            \"L\": 2 * np.pi, \"N\": 128, \"Nt\": 8, \"dt\": 0.15,\n            \"k_cut\": 4.0, \"alpha\": 1.0, \"metric\": \"leakage\",\n            \"A_func\": lambda x, t: np.sin(4 * x) * np.cos(0.9 * t)\n        },\n        {\n            \"L\": 2 * np.pi, \"N\": 128, \"Nt\": 20, \"dt\": 0.07,\n            \"k_cut\": 3.0, \"alpha\": 0.3, \"metric\": \"tv_ratio\",\n            \"A_func\": lambda x, t: (\n                np.sin(2 * x) * np.cos(1.3 * t) +\n                0.7 * np.sin(8 * x) * np.cos(3.7 * t)\n            )\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(**case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A robust numerical scheme must not only be stable but also respect the fundamental conservation laws of the physical system it models. This exercise shifts our focus from implementation to verification, tasking you with building a diagnostic to test the conservation of total charge—a critical invariant in the Vlasov-Maxwell system. You will compare a perfectly conservative operator against a non-conservative one, and then implement a mitigation strategy to enforce charge conservation *a posteriori*, vividly illustrating how these corrective techniques ensure the physical fidelity of a simulation .",
            "id": "4033402",
            "problem": "You are tasked to design and implement a discrete diagnostic that verifies conservation of total charge under repeated pullback updates of the gyrokinetic perturbation to the distribution function. The objective is to check the invariance of the total charge, defined as the discrete approximation of the continuous quantity $\\sum_{s} \\int q_{s}\\,\\delta f_{s}\\,dZ$, across many update steps. Your diagnostic must be constructed from first principles and must not rely on any built-in conservation shortcuts.\n\nFoundational basis: In gyrokinetic theory, the Vlasov equation with Hamiltonian flow preserves phase-space volume by Liouville’s theorem, and transformations between representations (pullback updates) must not alter physically invariant integrals. For the perturbation to the distribution function $\\delta f_{s}$ of species $s$ with charge $q_{s}$, the total charge integrated over phase space must be invariant under exact transformations, i.e., $\\frac{d}{dt}\\sum_{s}\\int q_{s}\\,\\delta f_{s}\\,dZ = 0$. In a discrete setting with a uniform grid, the integral $\\int \\cdot \\, dZ$ is approximated by a weighted sum with cell volume.\n\nYou will implement a program that:\n- Constructs a discrete, uniform Cartesian phase-space grid for coordinates $Z = (x,y,v)$ with $x \\in [0,2\\pi)$, $y \\in [0,2\\pi)$, and $v \\in [-V,V]$.\n- Initializes $\\delta f_{s}$ for each species $s$ using a specified formula and parameters.\n- Applies specified pullback update operators repeatedly for a given number of steps.\n- Computes the total charge after each step and evaluates a diagnostic that measures invariance.\n\nDefinitions and requirements:\n1. Let the grid sizes be $N_x$, $N_y$, $N_v$, with uniform spacings $\\Delta x = \\frac{2\\pi}{N_x}$, $\\Delta y = \\frac{2\\pi}{N_y}$, and $\\Delta v = \\frac{2V}{N_v}$. The discrete cell volume is $w = \\Delta x\\,\\Delta y\\,\\Delta v$.\n2. For each species $s$, initialize $\\delta f_{s}(x,y,v)$ as\n   $$\\delta f_{s}(x,y,v) = B_{s} + A_{s}\\,\\sin(k_{x} x)\\,\\cos(k_{y} y)\\,\\exp\\left(-\\frac{v^{2}}{2\\sigma^{2}}\\right),$$\n   where $B_{s}$ is a constant offset, $A_{s}$ is an amplitude, $k_{x}$ and $k_{y}$ are integer wavenumbers, and $\\sigma$ is a positive width parameter.\n3. The total discrete charge after step $n$ is\n   $$Q^{(n)} = \\sum_{s} q_{s}\\,w \\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1}\\sum_{k=0}^{N_v-1}\\delta f_{s}^{(n)}[i,j,k].$$\n4. Define the diagnostic as the maximum normalized deviation over all steps $0,1,\\dots,K$:\n   $$D = \\max_{0\\le n\\le K}\\frac{\\left|Q^{(n)} - Q^{(0)}\\right|}{\\max\\left(|Q^{(0)}|,\\varepsilon\\right)},$$\n   where $\\varepsilon$ is a small positive constant to avoid division by zero, chosen as $\\varepsilon = 10^{-12}$ (dimensionless).\n5. Implement three update operators to be used in the test suite:\n   - Operator $\\mathcal{A}$ (exactly measure-preserving): an integer cyclic shift on the grid indices that preserves the sum exactly. Concretely, at each step, apply an integer cyclic shift of $\\delta f_{s}$ by $s_{x}$ cells in the $x$-direction and $s_{v}$ cells in the $v$-direction, with periodic wrap, leaving $y$ unchanged. This operator must preserve $\\sum_{i,j,k}\\delta f_{s}$ for each species and thereby preserve $Q^{(n)}$.\n   - Operator $\\mathcal{B}$ (non-conservative): at each step, apply a fractional shift in the $x$-direction combined with damping. For a fractional shift parameter $\\alpha\\in(0,1)$ and damping parameter $\\gamma\\in(0,1)$, update\n     $$\\delta f_{s}^{\\text{new}}[i,j,k] = (1-\\gamma)\\left((1-\\alpha)\\,\\delta f_{s}[i,j,k] + \\alpha\\,\\delta f_{s}[i-1,j,k]\\right),$$\n     with non-periodic boundary condition in $x$ so that $\\delta f_{s}[-1,j,k]$ contributes as $0$ in the update for $i=0$. This operator will generally not preserve $\\sum_{i,j,k}\\delta f_{s}$ and thus will not preserve $Q^{(n)}$.\n   - Operator $\\mathcal{B}_{\\text{mit}}$ (mitigated): apply operator $\\mathcal{B}$, then enforce exact total charge invariance via a uniform correction to one species to satisfy\n     $$\\sum_{s} q_{s}\\,w \\sum_{i,j,k} \\left(\\delta f_{s}^{\\text{corr}}[i,j,k]\\right) = Q^{(0)}.$$\n     One concrete choice is to adjust only the electron species $s=e$ (with $q_{e}<0$), by adding a uniform offset $c_{e}$ after the $\\mathcal{B}$ update, with\n     $$c_{e} = \\frac{Q^{(0)} - Q^{\\text{temp}}}{q_{e}\\,w\\,N_x\\,N_y\\,N_v},$$\n     where $Q^{\\text{temp}}$ is the total charge after applying $\\mathcal{B}$ and before mitigation. Other species remain unchanged. This step enforces $Q^{(n)}=Q^{(0)}$ up to floating-point round-off.\n\n6. You must compute and report the diagnostic $D$ for each test case as a float in dimensionless units. No angles are involved. No physical units are required beyond dimensionless consistency.\n\nTest suite:\n- Case $1$ (happy path, exact invariance): $N_x=32$, $N_y=16$, $N_v=8$, $V=4$, species $s\\in\\{e,i\\}$ with $q_{e}=-1$, $q_{i}=+1$, offsets $B_{e}=10^{-2}$, $B_{i}=-9\\times 10^{-3}$, amplitudes $A_{e}=10^{-1}$, $A_{i}=-7\\times 10^{-2}$, wavenumbers $k_{x}=3$, $k_{y}=2$, width $\\sigma=0.9$, steps $K=50$, operator $\\mathcal{A}$ with shifts $s_{x}=3$, $s_{v}=1$.\n- Case $2$ (non-conservative drift): same $N_x$, $N_y$, $N_v$, $V$, species charges and initialization parameters as Case $1$, steps $K=50$, operator $\\mathcal{B}$ with $\\alpha=0.37$, $\\gamma=0.01$.\n- Case $3$ (mitigation enforces invariance): $N_x=64$, $N_y=16$, $N_v=8$, $V=4$, species $s\\in\\{e,i\\}$ with $q_{e}=-1$, $q_{i}=+1$, offsets $B_{e}=10^{-2}$, $B_{i}=-9\\times 10^{-3}$, amplitudes $A_{e}=10^{-1}$, $A_{i}=-7\\times 10^{-2}$, wavenumbers $k_{x}=3$, $k_{y}=2$, width $\\sigma=0.9$, steps $K=50$, operator $\\mathcal{B}_{\\text{mit}}$ with $\\alpha=0.37$, $\\gamma=0.01$.\n\nAnswer specification:\n- Your program must compute the diagnostic $D$ for each of the three cases described above and produce a single line of output containing the three results as a comma-separated list enclosed in square brackets, e.g., $[d_{1},d_{2},d_{3}]$, where each $d_{i}$ is a float.\n- The output must be a single line, with no additional text. All values are dimensionless.\n\nYour implementation should be general and clearly organized so that each update operator and diagnostic are explicitly implemented according to the definitions above. The program must be self-contained and should not require any user input. The correctness of your solution will be judged against the test suite using the exact output format specified.",
            "solution": "The core of the problem lies in discretizing a continuous physical system and then testing how numerical operators affect a conserved quantity. The total charge, $Q = \\sum_{s} \\int q_{s}\\,\\delta f_{s}\\,dZ$, is an invariant in the continuous Vlasov-Maxwell system under Hamiltonian flow. Our objective is to construct a numerical analogue and observe its behavior under different discrete time-evolution operators.\n\nFirst, we establish the discrete phase-space grid. The continuous phase space is defined by coordinates $Z = (x,y,v)$ over the domain $[0,2\\pi) \\times [0,2\\pi) \\times [-V,V]$. We discretize this domain into a uniform Cartesian grid of size $N_x \\times N_y \\times N_v$. The discrete grid points are given by:\n$x_i = i \\Delta x$ for $i \\in \\{0, 1, \\dots, N_x-1\\}$, with $\\Delta x = 2\\pi/N_x$.\n$y_j = j \\Delta y$ for $j \\in \\{0, 1, \\dots, N_y-1\\}$, with $\\Delta y = 2\\pi/N_y$.\n$v_k = -V + k \\Delta v$ for $k \\in \\{0, 1, \\dots, N_v-1\\}$, with $\\Delta v = 2V/N_v$.\nThe small volume element of this discrete phase space, or cell volume, is constant across the grid and is given by $w = \\Delta x \\Delta y \\Delta v = \\frac{8\\pi^2 V}{N_x N_y N_v}$. The distribution function perturbation for each species $s$, $\\delta f_s(x,y,v)$, is represented by a $3$-dimensional array $\\delta f_s[i,j,k]$ which stores its value at each grid point $(x_i, y_j, v_k)$.\n\nNext, we initialize the system at step $n=0$. The initial perturbation $\\delta f_s^{(0)}$ for each species $s$ is defined by the function:\n$$ \\delta f_{s}(x,y,v) = B_{s} + A_{s}\\,\\sin(k_{x} x)\\,\\cos(k_{y} y)\\,\\exp\\left(-\\frac{v^{2}}{2\\sigma^{2}}\\right) $$\nWe evaluate this function at each discrete grid point $(x_i, y_j, v_k)$ to populate the initial arrays $\\delta f_{s}^{(0)}[i,j,k]$. Here, $B_s$, $A_s$, $k_x$, $k_y$, and $\\sigma$ are given parameters.\n\nThe primary quantity of interest is the total discrete charge, $Q^{(n)}$, at a given step $n$. It is the discrete approximation of the phase-space integral, calculated by summing the contributions from all species and all grid cells:\n$$ Q^{(n)} = \\sum_{s} q_{s}\\,w \\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1}\\sum_{k=0}^{N_v-1}\\delta f_{s}^{(n)}[i,j,k] $$\nThis calculation can be implemented efficiently using array summation, as $Q^{(n)} = w \\sum_{s} q_{s} \\sum_{i,j,k} \\delta f_{s}^{(n)}[i,j,k]$.\n\nThe core of the simulation involves the iterative application of an update operator for $K$ steps. We will implement the three specified operators.\n\n1.  **Operator $\\mathcal{A}$ (Exact Cyclic Shift)**: This operator models a perfectly conservative advection scheme. It applies an integer cyclic shift to the grid indices in the $x$ and $v$ dimensions.\n    $$ \\delta f_{s}^{\\text{new}}[i,j,k] = \\delta f_{s}^{\\text{old}}[(i-s_x) \\pmod{N_x}, j, (k-s_v) \\pmod{N_v}] $$\n    where $s_x$ and $s_v$ are integer shift amounts. A cyclic shift is a permutation of the grid values, so the sum over all grid points, $\\sum_{i,j,k}\\delta f_s[i,j,k]$, is preserved exactly for each species independently. Consequently, the total charge $Q^{(n)}$ must remain invariant, $Q^{(n)} = Q^{(0)}$, for all $n$, up to the limits of floating-point arithmetic.\n\n2.  **Operator $\\mathcal{B}$ (Non-Conservative Update)**: This operator models a simple, first-order numerical scheme that introduces both dissipation and non-conservation. The update rule is:\n    $$ \\delta f_{s}^{\\text{new}}[i,j,k] = (1-\\gamma)\\left((1-\\alpha)\\,\\delta f_{s}^{\\text{old}}[i,j,k] + \\alpha\\,\\delta f_{s}^{\\text{old}}[i-1,j,k]\\right) $$\n    The non-periodic boundary condition in $x$ dictates that for the update at grid index $i=0$, the term $\\delta f_{s}^{\\text{old}}[-1,j,k]$ is treated as $0$. This boundary condition, along with the damping factor $(1-\\gamma)$, breaks the conservation of the total particle number $\\sum \\delta f_s$ for each species. As a result, the total charge $Q^{(n)}$ is not expected to be conserved.\n\n3.  **Operator $\\mathcal{B}_{\\text{mit}}$ (Mitigated Update)**: This operator implements a common pullback mitigation strategy: enforcing a conservation law a posteriori. The procedure is as follows:\n    a. First, apply the non-conservative operator $\\mathcal{B}$ to all species, resulting in a temporary distribution $\\delta f_{s}^{\\text{temp}}$ and a temporary total charge $Q^{\\text{temp}}$.\n    b. The deviation from the initial charge is $\\Delta Q = Q^{(0)} - Q^{\\text{temp}}$.\n    c. This deficit is corrected by adding a uniform offset $c_e$ to the distribution of a single species, chosen here to be the electrons ($s=e$). The offset is calculated to restore the total charge to its initial value:\n       $$ c_{e} = \\frac{Q^{(0)} - Q^{\\text{temp}}}{q_{e}\\,w\\,N_x\\,N_y\\,N_v} $$\n    d. The final updated distribution for electrons is $\\delta f_{e}^{(n)}[i,j,k] = \\delta f_{e}^{\\text{temp}}[i,j,k] + c_e$. Distributions for all other species remain unchanged, i.e., $\\delta f_{s}^{(n)} = \\delta f_{s}^{\\text{temp}}$ for $s \\ne e$.\n    By construction, this procedure ensures that the total charge after the update, $Q^{(n)}$, is equal to $Q^{(0)}$, again up to floating-point precision.\n\nFinally, we compute the diagnostic $D$, which quantifies the maximum charge deviation over the entire simulation of $K$ steps. It is defined as:\n$$ D = \\max_{0\\le n\\le K}\\frac{\\left|Q^{(n)} - Q^{(0)}\\right|}{\\max\\left(|Q^{(0)}|,\\varepsilon\\right)} $$\nThe term $\\varepsilon = 10^{-12}$ is a small regularization constant to prevent division by zero if $Q^{(0)}$ happens to be zero, although in the given test cases $Q^{(0)}$ is non-zero. The overall algorithm for each test case is:\n1.  Initialize grid parameters and species data.\n2.  Construct the initial distributions $\\delta f_s^{(0)}$ for all species.\n3.  Calculate and store the initial total charge $Q^{(0)}$.\n4.  Initialize a list of charge deviations, starting with $|Q^{(0)} - Q^{(0)}| = 0$.\n5.  Loop for $n$ from $1$ to $K$:\n    a. Apply the specified update operator ($\\mathcal{A}$, $\\mathcal{B}$, or $\\mathcal{B}_{\\text{mit}}$) to obtain $\\delta f_s^{(n)}$.\n    b. Calculate the new total charge $Q^{(n)}$.\n    c. Compute and store the deviation $|Q^{(n)} - Q^{(0)}|$.\n6.  Find the maximum value in the list of deviations.\n7.  Normalize this maximum value by $\\max(|Q^{(0)}|, \\varepsilon)$ to get the final diagnostic $D$.\n\nFor Case 1 (Operator $\\mathcal{A}$), we expect $D$ to be of the order of machine epsilon, as the operator is exactly conservative. For Case 2 (Operator $\\mathcal{B}$), we expect a significant, non-zero $D$ due to the non-conservative nature of the update. For Case 3 (Operator $\\mathcal{B}_{\\text{mit}}$), we expect $D$ to be near machine epsilon again, demonstrating the effectiveness of the mitigation strategy at enforcing charge conservation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    \n    epsilon = 1e-12\n\n    # Common parameters for some cases\n    common_species_params = {\n        'e': {'q': -1.0, 'B': 1e-2, 'A': 1e-1},\n        'i': {'q': 1.0, 'B': -9e-3, 'A': -7e-2}\n    }\n    common_init_params = {'kx': 3, 'ky': 2, 'sigma': 0.9}\n\n    test_cases = [\n        # Case 1: Exact invariance with operator A\n        {\n            'case_id': 1, 'operator': 'A',\n            'grid': {'Nx': 32, 'Ny': 16, 'Nv': 8, 'V': 4.0},\n            'species': common_species_params,\n            'init': common_init_params,\n            'K': 50,\n            'op_params': {'sx': 3, 'sv': 1}\n        },\n        # Case 2: Non-conservative drift with operator B\n        {\n            'case_id': 2, 'operator': 'B',\n            'grid': {'Nx': 32, 'Ny': 16, 'Nv': 8, 'V': 4.0},\n            'species': common_species_params,\n            'init': common_init_params,\n            'K': 50,\n            'op_params': {'alpha': 0.37, 'gamma': 0.01}\n        },\n        # Case 3: Mitigation enforces invariance with operator B_mit\n        {\n            'case_id': 3, 'operator': 'B_mit',\n            'grid': {'Nx': 64, 'Ny': 16, 'Nv': 8, 'V': 4.0},\n            'species': common_species_params,\n            'init': common_init_params,\n            'K': 50,\n            'op_params': {'alpha': 0.37, 'gamma': 0.01}\n        },\n    ]\n\n    results = []\n    for case_params in test_cases:\n        D = run_case(case_params, epsilon)\n        results.append(D)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef initialize_delta_f(grid_params, species_params, init_params):\n    \"\"\"\n    Initializes the distribution function perturbation delta_f for all species.\n    \"\"\"\n    Nx, Ny, Nv, V = grid_params['Nx'], grid_params['Ny'], grid_params['Nv'], grid_params['V']\n    kx, ky, sigma = init_params['kx'], init_params['ky'], init_params['sigma']\n\n    # Create grid coordinates\n    x = np.linspace(0, 2 * np.pi, Nx, endpoint=False)\n    y = np.linspace(0, 2 * np.pi, Ny, endpoint=False)\n    delta_v = 2 * V / Nv\n    v = np.linspace(-V, V - delta_v, Nv)\n    \n    xx, yy, vv = np.meshgrid(x, y, v, indexing='ij')\n\n    delta_fs = {}\n    for s_id, s_data in species_params.items():\n        B_s, A_s = s_data['B'], s_data['A']\n        \n        spatial_part = np.sin(kx * xx) * np.cos(ky * yy)\n        velocity_part = np.exp(-vv**2 / (2 * sigma**2))\n        \n        delta_fs[s_id] = B_s + A_s * spatial_part * velocity_part\n        \n    return delta_fs\n\ndef calculate_total_charge(delta_fs, grid_params, species_params):\n    \"\"\"\n    Calculates the total discrete charge Q.\n    \"\"\"\n    Nx, Ny, Nv, V = grid_params['Nx'], grid_params['Ny'], grid_params['Nv'], grid_params['V']\n    \n    delta_x = 2 * np.pi / Nx\n    delta_y = 2 * np.pi / Ny\n    delta_v = 2 * V / Nv\n    w = delta_x * delta_y * delta_v\n    \n    total_charge = 0.0\n    for s_id, f_s in delta_fs.items():\n        q_s = species_params[s_id]['q']\n        total_charge += q_s * np.sum(f_s)\n        \n    return total_charge * w\n\ndef apply_operator_A(delta_fs, op_params):\n    \"\"\"Applies the cyclic shift operator A.\"\"\"\n    sx, sv = op_params['sx'], op_params['sv']\n    new_delta_fs = {}\n    for s_id, f_s in delta_fs.items():\n        # Cyclic shift in x (axis 0)\n        f_s = np.roll(f_s, sx, axis=0)\n        # Cyclic shift in v (axis 2)\n        f_s = np.roll(f_s, sv, axis=2)\n        new_delta_fs[s_id] = f_s\n    return new_delta_fs\n\ndef apply_operator_B(delta_fs, op_params):\n    \"\"\"Applies the non-conservative operator B.\"\"\"\n    alpha, gamma = op_params['alpha'], op_params['gamma']\n    new_delta_fs = {}\n    for s_id, f_s in delta_fs.items():\n        # Vectorized implementation of the fractional shift with non-periodic BC\n        f_s_shifted = np.roll(f_s, 1, axis=0)\n        f_s_shifted[0, :, :] = 0.0  # Non-periodic boundary at i=0\n        \n        f_s_new = (1.0 - gamma) * ((1.0 - alpha) * f_s + alpha * f_s_shifted)\n        new_delta_fs[s_id] = f_s_new\n    return new_delta_fs\n\ndef apply_operator_B_mit(delta_fs, Q0, grid_params, species_params, op_params):\n    \"\"\"Applies the mitigated operator B_mit.\"\"\"\n    # Step 1: Apply operator B\n    delta_fs_temp = apply_operator_B(delta_fs, op_params)\n    \n    # Step 2: Calculate temporary charge\n    Q_temp = calculate_total_charge(delta_fs_temp, grid_params, species_params)\n    \n    # Step 3: Calculate correction for electrons\n    Nx, Ny, Nv, V = grid_params['Nx'], grid_params['Ny'], grid_params['Nv'], grid_params['V']\n    delta_x = 2 * np.pi / Nx\n    delta_y = 2 * np.pi / Ny\n    delta_v = 2 * V / Nv\n    w = delta_x * delta_y * delta_v\n    \n    q_e = species_params['e']['q']\n    total_volume = Nv * Ny * Nx * w\n    \n    c_e = (Q0 - Q_temp) / (q_e * total_volume)\n    \n    # Step 4: Apply correction\n    delta_fs_temp['e'] += c_e\n    \n    return delta_fs_temp\n\ndef run_case(params, epsilon):\n    \"\"\"\n    Runs a single simulation case and calculates the diagnostic D.\n    \"\"\"\n    # Unpack parameters\n    grid_params = params['grid']\n    species_params = params['species']\n    init_params = params['init']\n    K = params['K']\n    op_type = params['operator']\n    op_params = params['op_params']\n\n    # Initialization\n    delta_fs = initialize_delta_f(grid_params, species_params, init_params)\n    Q0 = calculate_total_charge(delta_fs, grid_params, species_params)\n    \n    max_deviation = 0.0\n    \n    for n in range(K):\n        # Apply the update operator\n        if op_type == 'A':\n            delta_fs = apply_operator_A(delta_fs, op_params)\n        elif op_type == 'B':\n            delta_fs = apply_operator_B(delta_fs, op_params)\n        elif op_type == 'B_mit':\n            delta_fs = apply_operator_B_mit(delta_fs, Q0, grid_params, species_params, op_params)\n        \n        # Calculate charge and deviation\n        Qn = calculate_total_charge(delta_fs, grid_params, species_params)\n        deviation = abs(Qn - Q0)\n        if deviation > max_deviation:\n            max_deviation = deviation\n            \n    # Calculate final diagnostic D\n    denominator = max(abs(Q0), epsilon)\n    D = max_deviation / denominator\n    \n    return D\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        },
        {
            "introduction": "Beyond improving accuracy, a key motivation for pullback strategies is to enhance computational efficiency by taming numerical stiffness. This practice demonstrates this practical benefit by having you design an adaptive substepping algorithm for the nonlinear terms in the gyrokinetic equation. You will derive stability constraints based on Courant-Friedrichs-Lewy (CFL) and local error bounds, and in doing so, you will directly see how adjusting the symplectic fraction $\\alpha$ of the potential reduces the required number of substeps, thus lowering the overall computational cost of the simulation .",
            "id": "4033367",
            "problem": "You are asked to design and implement an algorithmic substepping strategy for evaluating nonlinear terms in the mixed-variable electrostatic gyrokinetic equations that maintains numerical stability without excessive computational cost. The scenario is posed in purely mathematical terms but is grounded in physics for scientific realism and relevance to computational fusion science and engineering. The strategy must be derived from first principles under the mixed-variable formulation and then implemented as a complete, runnable program.\n\nThe mixed-variable electrostatic formulation decomposes the scalar potential into a symplectic part and a Hamiltonian part. Specifically, write the total potential as $\\phi = \\phi_{\\mathrm{S}} + \\phi_{\\mathrm{H}}$, and let a user-controlled symplectic fraction $\\alpha \\in [0,1]$ define $\\phi_{\\mathrm{S}} = \\alpha \\phi$ and $\\phi_{\\mathrm{H}} = (1 - \\alpha)\\phi$. In this formulation, the nonlinear term in the evolution of the gyrocenter distribution function can be represented by an advective operator generated by the symplectic part of the potential through the Poisson bracket. The dominant stabilizing constraint for an explicit substepping method arises from the magnitude of the $\\mathbf{E}\\times\\mathbf{B}$ drift advection velocity constructed using $\\phi_{\\mathrm{S}}$.\n\nYou must derive, using accepted definitions and laws, a stability-limiting substep based on two complementary constraints that are standard in explicit numerical schemes:\n\n- A Courant-Friedrichs-Lewy (CFL) constraint derived from advective transport on a spatial grid with spacing $\\Delta x$, where the relevant $\\mathbf{E}\\times\\mathbf{B}$ drift magnitude is set by the symplectic potential and the magnetic field magnitude $B$.\n- A Lipschitz-type local error control that bounds the change in the function advanced by the nonlinear operator within one substep using a prescribed tolerance $\\varepsilon$. The Lipschitz constant must be estimated from the spectrum of the potential and a wavenumber bound for the distribution function.\n\nLet the macro time step be $\\Delta t$. Your substepping strategy must determine the minimal integer number of substeps $N_{\\mathrm{sub}} \\ge 1$ such that an explicit method would be stable by both the CFL constraint and the local error bound. To ensure computational practicality, impose a maximum allowable number of substeps $N_{\\max}$ per macro step; if $N_{\\mathrm{sub}}$ required by stability exceeds $N_{\\max}$, you must cap at $N_{\\max}$ and report that stability could not be guaranteed under the cost constraint.\n\nFor the purposes of this problem, you should estimate the $\\mathbf{E}\\times\\mathbf{B}$ drift speed from the potential’s perpendicular spectral content. Let a set of perpendicular wavenumbers $\\{k_{y,i}\\}$ and corresponding potential amplitudes $\\{\\phi_{i}\\}$ be provided. The gradient magnitude of the symplectic potential can be estimated by the maximum of $|k_{y,i}\\,\\phi_{i}|$ across the modes, and the advective velocity magnitude relevant for stability is proportional to this gradient divided by $B$. For the Lipschitz constant, assume that the norm of the gradient of the advected quantity is bounded by a known wavenumber $k_{\\max}$, so that the time-derivative magnitude induced by the nonlinear operator is bounded by the product of the drift speed magnitude and $k_{\\max}$. All quantities must be expressed and used in International System of Units (SI), where $B$ is in tesla, the potential amplitudes $\\phi_{i}$ are in volts, wavenumbers are in inverse meters, spatial grid spacing $\\Delta x$ is in meters, $\\Delta t$ is in seconds, and the tolerance $\\varepsilon$ is dimensionless.\n\nYour program must implement the following outputs for each test case:\n- Compute the minimal integer $N_{\\mathrm{sub}}$ that satisfies both constraints if unconstrained by $N_{\\max}$, then cap by $N_{\\max}$.\n- Return an indicator of whether stability is satisfied under the cost constraint, i.e., a boolean that is true if the unconstrained minimal $N_{\\mathrm{sub}} \\le N_{\\max}$ and false otherwise.\n\nTo ensure testability, use the following test suite of parameter values. For each case, compute and return the pair consisting of the chosen substeps and the stability flag.\n\nTest Case 1 (general happy path):\n- $\\Delta t = 1.0\\times 10^{-6}\\,\\mathrm{s}$,\n- $\\Delta x = 1.0\\times 10^{-3}\\,\\mathrm{m}$,\n- $C_{\\max} = 0.5$ (dimensionless),\n- $B = 3.0\\,\\mathrm{T}$,\n- $\\alpha = 0.7$,\n- $\\{k_{y,i}\\} = [50, 100, 200]\\,\\mathrm{m}^{-1}$,\n- $\\{\\phi_{i}\\} = [5, 10, 4]\\,\\mathrm{V}$,\n- $k_{\\max} = 300\\,\\mathrm{m}^{-1}$,\n- $\\varepsilon = 0.02$ (dimensionless),\n- $N_{\\max} = 20$.\n\nTest Case 2 (boundary case of vanishing nonlinearity):\n- $\\Delta t = 1.0\\times 10^{-6}\\,\\mathrm{s}$,\n- $\\Delta x = 1.0\\times 10^{-3}\\,\\mathrm{m}$,\n- $C_{\\max} = 0.6$,\n- $B = 3.0\\,\\mathrm{T}$,\n- $\\alpha = 1.0$,\n- $\\{k_{y,i}\\} = [100]\\,\\mathrm{m}^{-1}$,\n- $\\{\\phi_{i}\\} = [0]\\,\\mathrm{V}$,\n- $k_{\\max} = 400\\,\\mathrm{m}^{-1}$,\n- $\\varepsilon = 0.01$,\n- $N_{\\max} = 10$.\n\nTest Case 3 (edge case with severe stiffness and cost violation):\n- $\\Delta t = 1.0\\times 10^{-6}\\,\\mathrm{s}$,\n- $\\Delta x = 1.0\\times 10^{-3}\\,\\mathrm{m}$,\n- $C_{\\max} = 0.5$,\n- $B = 1.0\\,\\mathrm{T}$,\n- $\\alpha = 1.0$,\n- $\\{k_{y,i}\\} = [500, 800]\\,\\mathrm{m}^{-1}$,\n- $\\{\\phi_{i}\\} = [50, 80]\\,\\mathrm{V}$,\n- $k_{\\max} = 800\\,\\mathrm{m}^{-1}$,\n- $\\varepsilon = 0.01$,\n- $N_{\\max} = 50$.\n\nTest Case 4 (mixed-variable mitigation reduces stiffness):\n- $\\Delta t = 5.0\\times 10^{-7}\\,\\mathrm{s}$,\n- $\\Delta x = 5.0\\times 10^{-4}\\,\\mathrm{m}$,\n- $C_{\\max} = 0.7$,\n- $B = 2.5\\,\\mathrm{T}$,\n- $\\alpha = 0.2$,\n- $\\{k_{y,i}\\} = [150, 300]\\,\\mathrm{m}^{-1}$,\n- $\\{\\phi_{i}\\} = [20, 12]\\,\\mathrm{V}$,\n- $k_{\\max} = 500\\,\\mathrm{m}^{-1}$,\n- $\\varepsilon = 0.015$,\n- $N_{\\max} = 30$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a two-element list $[N_{\\mathrm{sub}}, \\mathrm{stable}]$ with $N_{\\mathrm{sub}}$ an integer and $\\mathrm{stable}$ a boolean. For example, the format must be exactly like $[[n_{1},\\mathrm{True}],[n_{2},\\mathrm{False}],\\dots]$ where $n_{i}$ are integers.",
            "solution": "Herein, we derive the substepping algorithm from first principles as laid out in the problem statement. The goal is to determine the minimum number of substeps, $N_{\\mathrm{sub}}$, required for an explicit time integration of the nonlinear term in the gyrokinetic equation to remain stable over a macro time step $\\Delta t$.\n\nThe instability arises from the advection term driven by the $\\mathbf{E}\\times\\mathbf{B}$ drift, which is associated with the symplectic part of the electrostatic potential, $\\phi_{\\mathrm{S}} = \\alpha \\phi$, where $\\alpha$ is the user-defined symplectic fraction. The $\\mathbf{E}\\times\\mathbf{B}$ drift velocity is given by $\\mathbf{v}_{E} = (\\mathbf{E} \\times \\mathbf{B})/B^2$. For the symplectic part, the electric field is $\\mathbf{E}_{\\mathrm{S}} = -\\nabla_{\\perp} \\phi_{\\mathrm{S}}$, and the magnitude of the corresponding drift velocity is:\n$$\nV_{\\mathrm{adv}} = |\\mathbf{v}_{\\mathrm{E,S}}| = \\frac{|\\nabla_{\\perp} \\phi_{\\mathrm{S}}|}{B}\n$$\nThe problem specifies that the maximum magnitude of the perpendicular gradient of the total potential, $|\\nabla_{\\perp} \\phi|_{\\max}$, is estimated from its spectral components $\\{k_{y,i}, \\phi_i\\}$ as $K_{\\phi} = \\max_{i}\\{|k_{y,i} \\phi_i|\\}$. The gradient of the symplectic potential is then estimated as $|\\nabla_{\\perp} \\phi_{\\mathrm{S}}|_{\\max} = \\alpha |\\nabla_{\\perp} \\phi|_{\\max} = \\alpha K_{\\phi}$. Thus, the characteristic advection speed governing stability is:\n$$\nV_{\\mathrm{adv}} = \\frac{\\alpha K_{\\phi}}{B} = \\frac{\\alpha}{B} \\max_{i}\\{|k_{y,i} \\phi_i|\\}\n$$\nIf all potential amplitudes $\\phi_i$ are zero, then $K_{\\phi}=0$ and $V_{\\mathrm{adv}}=0$, implying the nonlinear term vanishes.\n\nTwo constraints must be satisfied by the time step of each substep, $\\Delta t_{\\mathrm{sub}} = \\Delta t / N_{\\mathrm{sub}}$.\n\n1.  **Courant-Friedrichs-Lewy (CFL) Constraint:** This condition limits how far information can travel across a grid cell in a single time step. For an advection speed $V_{\\mathrm{adv}}$ on a grid with spacing $\\Delta x$ and a maximum Courant number $C_{\\max}$, the constraint is:\n    $$\n    V_{\\mathrm{adv}} \\frac{\\Delta t_{\\mathrm{sub}}}{\\Delta x} \\le C_{\\max}\n    $$\n    Substituting $\\Delta t_{\\mathrm{sub}} = \\Delta t / N_{\\mathrm{sub}}$ and solving for $N_{\\mathrm{sub}}$, we find the minimum number of substeps required by the CFL condition:\n    $$\n    N_{\\mathrm{sub}} \\ge \\frac{V_{\\mathrm{adv}} \\Delta t}{C_{\\max} \\Delta x}\n    $$\n\n2.  **Lipschitz-type Local Error Constraint:** This condition bounds the change of the advected function, $f$, over a single substep. The time evolution of $f$ due to the nonlinear term is approximately $\\partial_t f \\approx -\\mathbf{v}_{\\mathrm{E,S}} \\cdot \\nabla_{\\perp} f$. The change in $f$ over $\\Delta t_{\\mathrm{sub}}$ is bounded by $\\Delta t_{\\mathrm{sub}} |V_{\\mathrm{adv}}| |\\nabla_{\\perp} f|_{\\max}$. The problem provides a bound for the function's gradient norm, $|\\nabla_{\\perp} f|_{\\max} \\approx k_{\\max} |f|_{\\max}$, where $k_{\\max}$ is a characteristic maximum wavenumber of $f$. The local relative error must be less than a tolerance $\\varepsilon$:\n    $$\n    \\frac{|\\Delta f|}{|f|_{\\max}} \\approx \\frac{\\Delta t_{\\mathrm{sub}} V_{\\mathrm{adv}} k_{\\max} |f|_{\\max}}{|f|_{\\max}} = \\Delta t_{\\mathrm{sub}} V_{\\mathrm{adv}} k_{\\max} \\le \\varepsilon\n    $$\n    Solving for $N_{\\mathrm{sub}}$ gives the second condition:\n    $$\n    N_{\\mathrm{sub}} \\ge \\frac{V_{\\mathrm{adv}} k_{\\max} \\Delta t}{\\varepsilon}\n    $$\n\nTo satisfy both constraints, $N_{\\mathrm{sub}}$ must be greater than or equal to the maximum of the two derived lower bounds. Let $N_{\\mathrm{raw}}$ be the required (real-valued) number of substeps:\n$$\nN_{\\mathrm{raw}} = \\max\\left( \\frac{V_{\\mathrm{adv}} \\Delta t}{C_{\\max} \\Delta x}, \\frac{V_{\\mathrm{adv}} k_{\\max} \\Delta t}{\\varepsilon} \\right) = V_{\\mathrm{adv}} \\Delta t \\cdot \\max\\left( \\frac{1}{C_{\\max} \\Delta x}, \\frac{k_{\\max}}{\\varepsilon} \\right)\n$$\nSince the number of substeps must be an integer and at least $1$, the minimal required number of substeps, $N_{\\mathrm{req}}$, is:\n$$\nN_{\\mathrm{req}} = \\max\\left(1, \\lceil N_{\\mathrm{raw}} \\rceil\\right)\n$$\nwhere $\\lceil \\cdot \\rceil$ is the ceiling function.\n\nFinally, we apply the computational cost constraint. The number of substeps to be used, $N_{\\mathrm{sub}}$, is capped at the maximum allowed value, $N_{\\max}$. A boolean flag, `stable`, indicates whether the stability requirement could be met within this budget.\nThe final number of substeps is $N_{\\mathrm{sub}} = \\min(N_{\\mathrm{req}}, N_{\\max})$.\nThe stability flag is $\\mathrm{stable} = (N_{\\mathrm{req}} \\le N_{\\max})$.\n\nThe pair $[N_{\\mathrm{sub}}, \\mathrm{stable}]$ is computed for each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef calculate_substeps(params):\n    \"\"\"\n    Calculates the number of substeps and stability flag for a given set of parameters.\n    \n    Args:\n        params (dict): A dictionary containing all the physical and numerical parameters.\n    \n    Returns:\n        list: A two-element list [N_sub, stable_flag].\n    \"\"\"\n    delta_t = params[\"delta_t\"]\n    delta_x = params[\"delta_x\"]\n    C_max = params[\"C_max\"]\n    B = params[\"B\"]\n    alpha = params[\"alpha\"]\n    k_y = np.array(params[\"k_y_i\"])\n    phi = np.array(params[\"phi_i\"])\n    k_max = params[\"k_max\"]\n    epsilon = params[\"epsilon\"]\n    N_max = params[\"N_max\"]\n\n    # Step 1: Calculate K_phi = max(|k_y * phi|)\n    if len(k_y) == 0 or len(phi) == 0:\n        K_phi = 0.0\n    else:\n        K_phi = np.max(np.abs(k_y * phi))\n\n    # If the nonlinear term is zero, V_adv is zero, and one substep is sufficient.\n    if K_phi == 0.0:\n        N_req = 1\n    else:\n        # Step 2: Calculate the characteristic advection speed V_adv\n        V_adv = (alpha * K_phi) / B\n\n        # Step 3: Calculate the terms for CFL and Lipschitz constraints\n        cfl_term = 1.0 / (C_max * delta_x)\n        lip_term = k_max / epsilon\n        \n        # Step 4: Calculate the raw, real-valued number of substeps\n        N_raw = V_adv * delta_t * max(cfl_term, lip_term)\n        \n        # Step 5: Required N_sub is the ceiling of N_raw, with a minimum of 1\n        N_req = max(1, math.ceil(N_raw))\n\n    # Step 6: Determine stability flag based on N_max\n    is_stable = (N_req <= N_max)\n\n    # Step 7: Cap the number of substeps at N_max\n    N_sub = min(N_req, N_max)\n\n    return [N_sub, is_stable]\n\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print the final output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"delta_t\": 1.0e-6, \"delta_x\": 1.0e-3, \"C_max\": 0.5, \"B\": 3.0, \n            \"alpha\": 0.7, \"k_y_i\": [50, 100, 200], \"phi_i\": [5, 10, 4],\n            \"k_max\": 300, \"epsilon\": 0.02, \"N_max\": 20\n        },\n        {\n            \"delta_t\": 1.0e-6, \"delta_x\": 1.0e-3, \"C_max\": 0.6, \"B\": 3.0,\n            \"alpha\": 1.0, \"k_y_i\": [100], \"phi_i\": [0],\n            \"k_max\": 400, \"epsilon\": 0.01, \"N_max\": 10\n        },\n        {\n            \"delta_t\": 1.0e-6, \"delta_x\": 1.0e-3, \"C_max\": 0.5, \"B\": 1.0,\n            \"alpha\": 1.0, \"k_y_i\": [500, 800], \"phi_i\": [50, 80],\n            \"k_max\": 800, \"epsilon\": 0.01, \"N_max\": 50\n        },\n        {\n            \"delta_t\": 5.0e-7, \"delta_x\": 5.0e-4, \"C_max\": 0.7, \"B\": 2.5,\n            \"alpha\": 0.2, \"k_y_i\": [150, 300], \"phi_i\": [20, 12],\n            \"k_max\": 500, \"epsilon\": 0.015, \"N_max\": 30\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_substeps(case)\n        results.append(result)\n\n    # Format the final output string exactly as specified.\n    # str([4, True]) produces \"[4, True]\". Joining these with commas\n    # and enclosing in brackets gives the desired format.\n    result_str = \",\".join(map(str, results))\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        }
    ]
}