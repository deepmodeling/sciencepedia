{
    "hands_on_practices": [
        {
            "introduction": "The first step in implementing gyrokinetics numerically is to replace the continuous gyro-orbit integral with a discrete sum. This practice explores the most common choice: a simple trapezoidal rule with equally spaced points around the gyro-orbit. By analyzing a function with a known Fourier series, you will derive from first principles the exact error of this approximation, revealing the critical concept of aliasing and establishing a clear rule for how many quadrature points $M$ are needed to resolve a given spectrum .",
            "id": "3988377",
            "problem": "Consider the Gyrokinetic (GK) context where the gyroaverage over the gyrophase angle is a fundamental operation. Let the gyrophase angle be denoted by $\\theta$, measured in radians. The continuous gyroaverage of a scalar function $f(\\theta)$ over one full gyration is defined by the integral\n$$\n\\langle f \\rangle \\equiv \\frac{1}{2\\pi}\\int_{0}^{2\\pi} f(\\theta)\\, d\\theta.\n$$\nIn numerical practice, the trapezoidal gyroaveraging algorithm approximates the gyroaverage by sampling $M$ equispaced points on the circle:\n$$\n\\widehat{f}_M \\equiv \\frac{1}{M}\\sum_{j=0}^{M-1} f\\!\\left(\\theta_j\\right), \\quad \\theta_j \\equiv \\frac{2\\pi j}{M},\n$$\nwith angles in radians. In computational fusion science and engineering, the function $f(\\theta)$ is often represented or approximated by a truncated Fourier cosine series. In this problem, consider\n$$\nf(\\theta) = \\sum_{n=0}^{N} a_n \\cos(n\\theta),\n$$\nwhere $N$ is a nonnegative integer and the real coefficients $a_n$ are given.\n\nYour tasks are:\n- Starting from the integral definition of the gyroaverage and properties of Fourier cosine functions, derive from first principles an explicit expression for the trapezoidal gyroaveraging error\n$$\nE(M) \\equiv \\left|\\widehat{f}_M - \\langle f \\rangle\\right|\n$$\nin terms of the coefficients $a_n$ and the integer $M$. Base your derivation only on fundamental facts such as orthogonality of trigonometric functions over a full period and the evaluation of geometric series; do not assume any specialized quadrature error formulas without derivation.\n- Using the derived expression for $E(M)$, determine the minimal integer $M$ such that $E(M) < \\varepsilon$ for a given tolerance $\\varepsilon > 0$ and given coefficient set $\\{a_n\\}_{n=0}^{N}$. Then, verify the predicted error with a direct numerical experiment by computing $\\widehat{f}_M$ via the trapezoidal rule and comparing it to the exact gyroaverage $\\langle f \\rangle$. Angles must be in radians.\n\nImplement a complete, runnable program that, for each test case below, computes:\n1. The minimal $M$ such that $E(M) < \\varepsilon$.\n2. The predicted error $E(M)$ using your explicit expression.\n3. The measured error produced by the numerical trapezoidal gyroaverage with that minimal $M$.\n\nThe program must use the following test suite, where in each case $N$, $a_0$, the sequence $\\{a_n\\}_{n=1}^{N}$, and $\\varepsilon$ are specified:\n\n- Test case A (general decay, happy path):\n  - $N = 12$, $a_0 = 2.5$, $a_n = \\frac{1}{n^2}$ for $n = 1,2,\\dots,12$, $\\varepsilon = 10^{-3}$.\n- Test case B (alternating signs, cancellation behavior):\n  - $N = 30$, $a_0 = 0$, $a_n = \\frac{(-1)^n}{n^3}$ for $n = 1,2,\\dots,30$, $\\varepsilon = 10^{-4}$.\n- Test case C (boundary case where $M=1$ can be sufficient):\n  - $N = 3$, $a_0 = 1.0$, $a_n = 10^{-7}$ for $n = 1,2,3$, $\\varepsilon = 5\\times 10^{-7}$.\n- Test case D (exponential decay, larger $N$):\n  - $N = 64$, $a_0 = -0.3$, $a_n = (0.3)^n$ for $n = 1,2,\\dots,64$, $\\varepsilon = 10^{-6}$.\n\nYour program should produce a single line of output containing the results for the four test cases as a comma-separated list enclosed in square brackets. Each test case’s result must be a three-element list of the form $[M, E_{\\text{pred}}, E_{\\text{meas}}]$, where $M$ is an integer, and $E_{\\text{pred}}$ and $E_{\\text{meas}}$ are floating-point numbers. For example, the overall output format must be like\n$[[M_1,E_{\\text{pred},1},E_{\\text{meas},1}],[M_2,E_{\\text{pred},2},E_{\\text{meas},2}],[M_3,E_{\\text{pred},3},E_{\\text{meas},3}],[M_4,E_{\\text{pred},4},E_{\\text{meas},4}]]$,\nprinted as a single line. Angles must be treated in radians throughout, and no physical units other than radians are involved. The program must be fully self-contained and runnable as is, with no input required.",
            "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the principles of Fourier analysis and numerical quadrature, well-posed with a clear objective and sufficient information, and free from any scientific, logical, or formal flaws. The task requires a rigorous derivation from first principles followed by a numerical implementation, which is a standard and meaningful exercise in computational science. We may therefore proceed with the solution.\n\nThe solution is developed in three stages: first, we derive the exact value of the continuous gyroaverage $\\langle f \\rangle$; second, we derive an analytical expression for the discrete trapezoidal gyroaverage $\\widehat{f}_M$; and third, we combine these results to obtain an explicit formula for the error $E(M)$, which is then used to solve the problem.\n\n### 1. Calculation of the Exact Gyroaverage $\\langle f \\rangle$\n\nThe function under consideration is a truncated Fourier cosine series:\n$$\nf(\\theta) = \\sum_{n=0}^{N} a_n \\cos(n\\theta)\n$$\nThe exact gyroaverage is defined by the integral:\n$$\n\\langle f \\rangle \\equiv \\frac{1}{2\\pi}\\int_{0}^{2\\pi} f(\\theta)\\, d\\theta = \\frac{1}{2\\pi}\\int_{0}^{2\\pi} \\left(\\sum_{n=0}^{N} a_n \\cos(n\\theta)\\right) d\\theta\n$$\nBy the linearity of integration, we can interchange the summation and the integral:\n$$\n\\langle f \\rangle = \\sum_{n=0}^{N} a_n \\left(\\frac{1}{2\\pi}\\int_{0}^{2\\pi} \\cos(n\\theta)\\, d\\theta\\right)\n$$\nWe evaluate the integral for two cases based on the integer $n$.\n\nCase 1: $n=0$.\nThe integrand is $\\cos(0 \\cdot \\theta) = \\cos(0) = 1$. The integral becomes:\n$$\n\\frac{1}{2\\pi}\\int_{0}^{2\\pi} 1\\, d\\theta = \\frac{1}{2\\pi} [\\theta]_{0}^{2\\pi} = \\frac{2\\pi}{2\\pi} = 1\n$$\nThe contribution from this term is $a_0 \\cdot 1 = a_0$.\n\nCase 2: $n > 0$.\nThe integral is:\n$$\n\\frac{1}{2\\pi}\\int_{0}^{2\\pi} \\cos(n\\theta)\\, d\\theta = \\frac{1}{2\\pi} \\left[\\frac{\\sin(n\\theta)}{n}\\right]_{0}^{2\\pi} = \\frac{1}{2\\pi n} (\\sin(2\\pi n) - \\sin(0))\n$$\nSince $n$ is a positive integer, $\\sin(2\\pi n) = 0$. Thus, the integral evaluates to $0$.\n\nCombining these results, only the $n=0$ term survives the integration. The exact gyroaverage is therefore:\n$$\n\\langle f \\rangle = a_0\n$$\n\n### 2. Calculation of the Trapezoidal Gyroaverage $\\widehat{f}_M$\n\nThe trapezoidal gyroaveraging algorithm approximates the integral with a sum over $M$ equispaced points $\\theta_j = \\frac{2\\pi j}{M}$ for $j=0, 1, \\dots, M-1$:\n$$\n\\widehat{f}_M \\equiv \\frac{1}{M}\\sum_{j=0}^{M-1} f(\\theta_j) = \\frac{1}{M}\\sum_{j=0}^{M-1} \\left(\\sum_{n=0}^{N} a_n \\cos(n\\theta_j)\\right)\n$$\nInterchanging the order of summation gives:\n$$\n\\widehat{f}_M = \\sum_{n=0}^{N} a_n \\left(\\frac{1}{M}\\sum_{j=0}^{M-1} \\cos(n\\theta_j)\\right)\n$$\nTo evaluate the inner sum, we substitute $\\theta_j = \\frac{2\\pi j}{M}$ and use Euler's formula, $\\cos(x) = \\text{Re}(e^{ix})$:\n$$\n\\sum_{j=0}^{M-1} \\cos\\left(n \\frac{2\\pi j}{M}\\right) = \\sum_{j=0}^{M-1} \\text{Re}\\left(e^{i \\frac{2\\pi nj}{M}}\\right) = \\text{Re}\\left(\\sum_{j=0}^{M-1} \\left(e^{i \\frac{2\\pi n}{M}}\\right)^j\\right)\n$$\nThe sum is a finite geometric series with ratio $r = e^{i \\frac{2\\pi n}{M}}$.\n\nCase 1: $r=1$.\nThis occurs when the exponent $\\frac{2\\pi n}{M}$ is an integer multiple of $2\\pi$. This is equivalent to $\\frac{n}{M}$ being an integer, i.e., $n$ is a multiple of $M$.\nIn this case, each term in the sum is $1^j = 1$, so the sum is $\\sum_{j=0}^{M-1} 1 = M$.\n\nCase 2: $r \\neq 1$.\nThis occurs when $n$ is not a multiple of $M$. The sum of the geometric series is given by $\\frac{r^M - 1}{r-1}$.\nThe term $r^M$ is:\n$$\nr^M = \\left(e^{i \\frac{2\\pi n}{M}}\\right)^M = e^{i 2\\pi n} = \\cos(2\\pi n) + i \\sin(2\\pi n) = 1 + 0i = 1\n$$\nsince $n$ is an integer. The numerator is therefore $r^M - 1 = 1 - 1 = 0$. Since the denominator $r-1 \\neq 0$, the sum is $0$.\n\nIn summary, the discrete sum has the property:\n$$\n\\frac{1}{M}\\sum_{j=0}^{M-1} \\cos\\left(n \\frac{2\\pi j}{M}\\right) = \n\\begin{cases}\n1 & \\text{if } n \\text{ is a multiple of } M \\\\\n0 & \\text{if } n \\text{ is not a multiple of } M\n\\end{cases}\n$$\nApplying this to the expression for $\\widehat{f}_M$, the only non-zero contributions come from terms where the mode index $n$ is a multiple of the number of points $M$. Since the summation runs from $n=0$ to $N$, these indices are $n = 0, M, 2M, \\dots, kM$ such that $kM \\le N$. The $n=0$ term always contributes, as $0$ is a multiple of any $M$.\nTherefore, the numerical average is:\n$$\n\\widehat{f}_M = a_0 + \\sum_{k=1}^{\\lfloor N/M \\rfloor} a_{kM}\n$$\nThis phenomenon, where higher-frequency components contribute to the calculated value of lower-frequency components (here, the zeroth component), is known as aliasing.\n\n### 3. Derivation of the Error Expression $E(M)$\n\nThe trapezoidal gyroaveraging error $E(M)$ is defined as the absolute difference between the numerical and exact averages:\n$$\nE(M) \\equiv |\\widehat{f}_M - \\langle f \\rangle|\n$$\nSubstituting the expressions derived above:\n$$\nE(M) = \\left| \\left( a_0 + \\sum_{k=1}^{\\lfloor N/M \\rfloor} a_{kM} \\right) - a_0 \\right|\n$$\nThis simplifies to the final expression for the predicted error:\n$$\nE(M) = \\left| \\sum_{k=1}^{\\lfloor N/M \\rfloor} a_{kM} \\right|\n$$\nThis formula shows that the error is the magnitude of the sum of aliased coefficients. If $M > N$, then $\\lfloor N/M \\rfloor = 0$, the sum is empty (evaluates to $0$), and the error $E(M)$ is zero. This demonstrates the spectral accuracy of the trapezoidal rule for periodic analytic functions: with a sufficient number of points, the result is exact.\n\n### 4. Algorithmic Procedure\n\nTo find the minimal integer $M$ such that $E(M) < \\varepsilon$, we can perform a direct search. Since we know that $M = N+1$ guarantees zero error, the search space for $M$ is bounded. The algorithm is as follows:\n1. Iterate through integers $M$ starting from $M=1$ up to $N+1$.\n2. For each $M$, calculate the predicted error $E_{\\text{pred}}(M)$ using the derived formula: $E_{\\text{pred}}(M) = |\\sum_{k=1}^{\\lfloor N/M \\rfloor} a_{kM}|$.\n3. The first value of $M$ for which $E_{\\text{pred}}(M) < \\varepsilon$ is the minimal required number of points.\n4. For this minimal $M$, the predicted error is $E_{\\text{pred}} = E_{\\text{pred}}(M)$.\n5. The measured error $E_{\\text{meas}}$ is found by direct numerical computation using the trapezoidal rule definition: $E_{\\text{meas}} = |\\frac{1}{M}\\sum_{j=0}^{M-1} f(\\theta_j) - a_0|$, where $f(\\theta_j)$ is computed fully. This serves to verify the correctness of our derivation.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the gyroaveraging problem for a suite of test cases.\n    \"\"\"\n\n    def compute_minimal_M_and_errors(N, a_coeffs, epsilon):\n        \"\"\"\n        Computes the minimal M and the corresponding predicted and measured errors.\n\n        Args:\n            N (int): The maximum mode number in the Fourier cosine series.\n            a_coeffs (np.ndarray): Array of coefficients a_n from n=0 to N.\n            epsilon (float): The desired error tolerance.\n\n        Returns:\n            list: A list containing [minimal_M, predicted_error, measured_error].\n        \"\"\"\n        minimal_M = -1\n        E_pred = -1.0\n\n        # Search for the minimal M that satisfies the error criterion.\n        # The search is guaranteed to terminate as E(N+1) = 0.\n        for M in range(1, N + 2):\n            k_max = N // M\n            \n            # Calculate predicted error using the derived aliasing formula\n            if k_max == 0:\n                current_E_pred = 0.0\n            else:\n                aliased_indices = np.arange(1, k_max + 1) * M\n                current_E_pred = np.abs(np.sum(a_coeffs[aliased_indices]))\n\n            if current_E_pred < epsilon:\n                minimal_M = M\n                E_pred = current_E_pred\n                break\n        \n        # Perform numerical experiment to find the measured error\n        M = minimal_M\n        a0 = a_coeffs[0]\n        \n        # Define the set of angles for the trapezoidal rule\n        thetas = 2.0 * np.pi * np.arange(M) / M\n        \n        # Vectorized computation of f(theta) for all angles\n        n_vals = np.arange(N + 1)\n        # Create a matrix of cos(n*theta) values. Shape: (N+1, M)\n        cos_matrix = np.cos(np.outer(n_vals, thetas))\n        # Compute f(theta) for all thetas via a dot product. Shape: (M,)\n        f_vals = a_coeffs @ cos_matrix\n        \n        # Compute the numerical average\n        f_hat_M = np.mean(f_vals)\n        \n        # Compute the measured error\n        E_meas = np.abs(f_hat_M - a0)\n        \n        return [minimal_M, E_pred, E_meas]\n\n    # --- Test Case Definitions ---\n    # Case A: General decay\n    N_A = 12\n    a_coeffs_A = np.zeros(N_A + 1)\n    a_coeffs_A[0] = 2.5\n    n_vals_A = np.arange(1, N_A + 1)\n    a_coeffs_A[1:] = 1.0 / n_vals_A**2\n    epsilon_A = 1e-3\n\n    # Case B: Alternating signs\n    N_B = 30\n    a_coeffs_B = np.zeros(N_B + 1)\n    a_coeffs_B[0] = 0.0\n    n_vals_B = np.arange(1, N_B + 1)\n    a_coeffs_B[1:] = (-1.0)**n_vals_B / n_vals_B**3\n    epsilon_B = 1e-4\n\n    # Case C: Boundary case\n    N_C = 3\n    a_coeffs_C = np.full(N_C + 1, 1e-7)\n    a_coeffs_C[0] = 1.0\n    epsilon_C = 5e-7\n\n    # Case D: Exponential decay\n    N_D = 64\n    a_coeffs_D = np.zeros(N_D + 1)\n    a_coeffs_D[0] = -0.3\n    n_vals_D = np.arange(1, N_D + 1)\n    a_coeffs_D[1:] = 0.3**n_vals_D\n    epsilon_D = 1e-6\n    \n    test_cases = [\n        (N_A, a_coeffs_A, epsilon_A),\n        (N_B, a_coeffs_B, epsilon_B),\n        (N_C, a_coeffs_C, epsilon_C),\n        (N_D, a_coeffs_D, epsilon_D),\n    ]\n\n    results = []\n    for N, a_coeffs, epsilon in test_cases:\n        result = compute_minimal_M_and_errors(N, a_coeffs, epsilon)\n        results.append(result)\n    \n    # Format the output as specified in the problem\n    # e.g., [[M1,Epred1,Emeas1],[M2,Epred2,Emeas2],...]\n    # Using a compact representation for floats.\n    result_str = \",\".join([f\"[{r[0]},{r[1]},{r[2]}]\" for r in results])\n    print(f\"[{result_str}]\")\n\n\nsolve()\n\n```"
        },
        {
            "introduction": "While the trapezoidal rule is fundamental, applying it point-by-point to a field on a grid is inefficient. A far more powerful approach, central to continuum gyrokinetic codes, treats the gyroaverage as a convolution and leverages the Fast Fourier Transform (FFT). In this exercise, you will verify that the gyroaverage operator $\\mathcal{G}_{\\rho}$ becomes a simple multiplicative filter $J_0(k_{\\perp}\\rho)$ in Fourier space and implement this highly efficient algorithm, while also investigating the practical numerical artifacts of aliasing and spectral leakage that arise from grid discretization .",
            "id": "3988451",
            "problem": "You are asked to implement and analyze the computation of the gyroaverage operator on a two-dimensional periodic domain using the Fast Fourier Transform (FFT). The gyroaverage operator of radius $\\rho$ applied to a scalar field $f(x,y)$ is defined, for a uniform magnetic field and cold gyrocenter approximation, by\n$$\n\\mathcal{G}_{\\rho} f(\\mathbf{x}) \\equiv \\frac{1}{2\\pi}\\int_{0}^{2\\pi} f\\!\\left(\\mathbf{x} + \\rho\\,\\hat{\\mathbf{e}}(\\theta)\\right)\\,d\\theta,\n$$\nwhere $\\hat{\\mathbf{e}}(\\theta) = (\\cos\\theta,\\sin\\theta)$ and angles are measured in radians. Assume a square periodic domain of side length $L$ in both directions.\n\nStarting from the Fourier series representation of a periodic function on a square domain and the definition of the gyroaverage above, derive from first principles that the Fourier-space representation of $\\mathcal{G}_{\\rho}$ is a multiplicative filter that scales each Fourier mode of wavenumber magnitude $k_{\\perp} = \\sqrt{k_x^2 + k_y^2}$ by the zero-order Bessel function of the first kind ($J_0$), namely\n$$\n\\widehat{\\mathcal{G}_{\\rho} f}(\\mathbf{k}) = J_{0}(k_{\\perp}\\rho)\\,\\hat{f}(\\mathbf{k}).\n$$\nDo not assume this identity; instead, use fundamental definitions of the Fourier transform on a periodic domain and the angle average to deduce it.\n\nThen, implement a program that:\n- Constructs $f(x,y)$ on a uniform square grid of size $N\\times N$ over a domain of side $L$ using its analytical expression.\n- Computes $\\mathcal{G}_{\\rho} f$ numerically by:\n  1. Computing the two-dimensional discrete Fourier transform of $f$ on the grid.\n  2. Multiplying each discrete Fourier coefficient by $J_0(k_{\\perp}\\rho)$, where $k_x = \\frac{2\\pi}{L} n_x$ and $k_y = \\frac{2\\pi}{L} n_y$ for integer indices $n_x, n_y$ consistent with the discrete FFT frequency convention, and $k_{\\perp} = \\sqrt{k_x^2 + k_y^2}$.\n  3. Performing the inverse discrete Fourier transform to obtain the grid approximation of $\\mathcal{G}_{\\rho} f$.\n- Computes a reference (analytical) gyroaverage $\\mathcal{G}_{\\rho} f$ directly in real space from the closed-form analytical expression for the chosen $f$ (without using FFT), based on the Fourier-space identity above applied to the continuous function. This reference must be evaluated pointwise on the same grid to enable comparison. Angles are in radians.\n\nQuantify aliasing and finite-domain sampling errors introduced by discrete sampling of $k_{\\perp}$ and the finite domain size by computing the normalized root-mean-square (RMS) error between the FFT-based result and the analytical reference:\n$$\nE_{\\mathrm{RMS}} \\equiv \\sqrt{\\frac{\\sum_{i,j}\\left(\\mathcal{G}_{\\rho} f\\big|_{\\mathrm{FFT}}(x_i,y_j) - \\mathcal{G}_{\\rho} f\\big|_{\\mathrm{exact}}(x_i,y_j)\\right)^2}{\\sum_{i,j}\\left(\\mathcal{G}_{\\rho} f\\big|_{\\mathrm{exact}}(x_i,y_j)\\right)^2}},\n$$\nwhich is a dimensionless float.\n\nUse the following test suite, designed to probe different aspects of aliasing and discrete $k_{\\perp}$ sampling. In all cases, the domain is $L = 2\\pi$, the grid is uniform with $x_i = \\frac{iL}{N}$ and $y_j = \\frac{jL}{N}$ for $i,j = 0,1,\\dots,N-1$, and angles are in radians. The function $f(x,y)$ is a sum of cosine modes with specified amplitudes and wavenumbers:\n- Test case 1 (happy path, well-resolved modes):\n  - $N = 128$, $\\rho = 0.5$.\n  - $f(x,y) = \\cos(3x + 4y) + 0.6\\,\\cos(2x - y) - 0.4\\,\\cos(5x + 0y)$.\n- Test case 2 (aliasing due to high wavenumber beyond Nyquist):\n  - $N = 64$, $\\rho = 1.2$.\n  - $f(x,y) = \\cos(40x + 0y) + 0.3\\,\\cos(5x + 7y)$.\n- Test case 3 (discrete $k_{\\perp}$ sampling and finite-domain effects with non-integer wavenumbers):\n  - $N = 64$, $\\rho = 2.0$.\n  - $f(x,y) = \\cos(3.7x + 5.2y) + 0.5\\,\\cos(4x + 2y)$.\n\nFor each test case, compute $E_{\\mathrm{RMS}}$ as defined above. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[e_1,e_2,e_3]$), where each $e_i$ is the numerical value (a float) of $E_{\\mathrm{RMS}}$ for the corresponding test case order given above. No other output is permitted. There are no physical units in this problem; all quantities are dimensionless. All angles must be interpreted in radians.",
            "solution": "The user has provided a valid problem.\n\nThe problem asks for two main tasks: first, to derive the Fourier-space representation of the gyroaverage operator, and second, to implement a numerical algorithm based on this representation to compute the gyroaverage of given functions, quantifying the numerical error against an analytical reference.\n\n**Part 1: Derivation of the Gyroaverage Operator in Fourier Space**\n\nThe gyroaverage operator of radius $\\rho$ applied to a scalar field $f(\\mathbf{x})$ on a two-dimensional domain is defined as the average of the function over a circle of radius $\\rho$ centered at $\\mathbf{x}$:\n$$\n\\mathcal{G}_{\\rho} f(\\mathbf{x}) \\equiv \\frac{1}{2\\pi}\\int_{0}^{2\\pi} f(\\mathbf{x} + \\rho\\,\\hat{\\mathbf{e}}(\\theta))\\,d\\theta\n$$\nwhere $\\mathbf{x} = (x,y)$ and $\\hat{\\mathbf{e}}(\\theta) = (\\cos\\theta, \\sin\\theta)$.\n\nWe consider a function $f(\\mathbf{x})$ that is periodic on a square domain of side length $L$. Such a function can be represented by its Fourier series:\n$$\nf(\\mathbf{x}) = \\sum_{\\mathbf{k}} \\hat{f}(\\mathbf{k}) e^{i\\mathbf{k}\\cdot\\mathbf{x}}\n$$\nwhere the sum is over all allowed wavevectors $\\mathbf{k} = (k_x, k_y) = \\left(\\frac{2\\pi n_x}{L}, \\frac{2\\pi n_y}{L}\\right)$ for integers $n_x, n_y$. The term $\\hat{f}(\\mathbf{k})$ is the Fourier coefficient for the mode $\\mathbf{k}$.\n\nTo find the gyroaverage of $f(\\mathbf{x})$, we substitute its Fourier series representation into the definition of the gyroaverage operator:\n$$\n\\mathcal{G}_{\\rho} f(\\mathbf{x}) = \\frac{1}{2\\pi}\\int_{0}^{2\\pi} \\left( \\sum_{\\mathbf{k}} \\hat{f}(\\mathbf{k}) e^{i\\mathbf{k}\\cdot(\\mathbf{x} + \\rho\\,\\hat{\\mathbf{e}}(\\theta))} \\right) d\\theta\n$$\nAssuming the series converges uniformly, we can interchange the order of summation and integration:\n$$\n\\mathcal{G}_{\\rho} f(\\mathbf{x}) = \\sum_{\\mathbf{k}} \\hat{f}(\\mathbf{k}) \\left( \\frac{1}{2\\pi}\\int_{0}^{2\\pi} e^{i\\mathbf{k}\\cdot(\\mathbf{x} + \\rho\\,\\hat{\\mathbf{e}}(\\theta))} d\\theta \\right)\n$$\nWe can separate the exponential term inside the integral:\n$$\ne^{i\\mathbf{k}\\cdot(\\mathbf{x} + \\rho\\,\\hat{\\mathbf{e}}(\\theta))} = e^{i\\mathbf{k}\\cdot\\mathbf{x}} e^{i\\mathbf{k}\\cdot\\rho\\,\\hat{\\mathbf{e}}(\\theta)}\n$$\nThe term $e^{i\\mathbf{k}\\cdot\\mathbf{x}}$ is independent of the integration variable $\\theta$ and can be factored out of the integral:\n$$\n\\mathcal{G}_{\\rho} f(\\mathbf{x}) = \\sum_{\\mathbf{k}} \\hat{f}(\\mathbf{k}) e^{i\\mathbf{k}\\cdot\\mathbf{x}} \\left( \\frac{1}{2\\pi}\\int_{0}^{2\\pi} e^{i\\rho(\\mathbf{k}\\cdot\\hat{\\mathbf{e}}(\\theta))} d\\theta \\right)\n$$\nLet us analyze the integral factor. We represent the wavevector $\\mathbf{k}$ in polar coordinates as $\\mathbf{k} = (k_{\\perp}\\cos\\phi, k_{\\perp}\\sin\\phi)$, where $k_{\\perp} = \\sqrt{k_x^2 + k_y^2}$ is the magnitude of the wavevector and $\\phi$ is its polar angle. The dot product $\\mathbf{k}\\cdot\\hat{\\mathbf{e}}(\\theta)$ becomes:\n$$\n\\mathbf{k}\\cdot\\hat{\\mathbf{e}}(\\theta) = k_x \\cos\\theta + k_y \\sin\\theta = k_{\\perp}\\cos\\phi\\cos\\theta + k_{\\perp}\\sin\\phi\\sin\\theta = k_{\\perp}\\cos(\\theta - \\phi)\n$$\nThe integral is therefore:\n$$\n\\frac{1}{2\\pi}\\int_{0}^{2\\pi} e^{i \\rho k_{\\perp} \\cos(\\theta - \\phi)} d\\theta\n$$\nLet $u = \\theta - \\phi$. As $\\theta$ integrates over $[0, 2\\pi]$, $u$ integrates over $[-\\phi, 2\\pi-\\phi]$. Since the integrand is periodic with period $2\\pi$, we can shift the integration interval to $[0, 2\\pi]$ without changing the value of the integral:\n$$\n\\frac{1}{2\\pi}\\int_{0}^{2\\pi} e^{i (\\rho k_{\\perp}) \\cos(u)} du\n$$\nThis is the integral representation of the zero-order Bessel function of the first kind, $J_0(z)$:\n$$\nJ_0(z) = \\frac{1}{2\\pi}\\int_{0}^{2\\pi} e^{iz\\cos u} du\n$$\nThus, the integral factor is equal to $J_0(k_{\\perp}\\rho)$.\n\nSubstituting this result back into the expression for $\\mathcal{G}_{\\rho} f(\\mathbf{x})$, we get:\n$$\n\\mathcal{G}_{\\rho} f(\\mathbf{x}) = \\sum_{\\mathbf{k}} J_0(k_{\\perp}\\rho) \\hat{f}(\\mathbf{k}) e^{i\\mathbf{k}\\cdot\\mathbf{x}}\n$$\nThis expression is the Fourier series representation of the gyroaveraged function $\\mathcal{G}_{\\rho} f(\\mathbf{x})$. By comparing this to the standard form of a Fourier series, we can identify the Fourier coefficient of the gyroaveraged function, which we denote as $\\widehat{\\mathcal{G}_{\\rho}f}(\\mathbf{k})$:\n$$\n\\widehat{\\mathcal{G}_{\\rho}f}(\\mathbf{k}) = J_0(k_{\\perp}\\rho)\\,\\hat{f}(\\mathbf{k})\n$$\nThis completes the derivation. The gyroaverage operator acts as a multiplicative filter in Fourier space, scaling each Fourier mode $\\hat{f}(\\mathbf{k})$ by a factor $J_0(k_{\\perp}\\rho)$ that depends only on the magnitude of the wavevector, $k_{\\perp}$.\n\n**Part 2: Numerical Implementation and Analysis**\n\nThe derived identity forms the basis of an efficient numerical algorithm using the Fast Fourier Transform (FFT). The algorithm proceeds as follows:\n1.  Discretize the function $f(x,y)$ on a uniform $N \\times N$ grid, yielding $f_{ij} = f(x_i, y_j)$.\n2.  Compute the 2D Discrete Fourier Transform (DFT) of the grid data $f_{ij}$ to obtain its discrete Fourier coefficients, $\\hat{f}_{n_x, n_y}$. This is done efficiently using an FFT algorithm (e.g., `numpy.fft.fft2`).\n3.  Construct a grid of discrete wavenumbers $(k_x, k_y)$ corresponding to the FFT indices $(n_x, n_y)$. For a domain of size $L$ with $N$ points, the wavenumbers are given by $k = \\frac{2\\pi}{L} n$, where $n$ are the integer mode indices provided by `numpy.fft.fftfreq`.\n4.  For each discrete wavevector $\\mathbf{k} = (k_x, k_y)$, calculate the filter factor $J_0(k_{\\perp}\\rho)$, where $k_{\\perp} = \\sqrt{k_x^2 + k_y^2}$. This requires the `scipy.special.j0` function.\n5.  Multiply the Fourier coefficients of the function by the filter: $\\widehat{\\mathcal{G}_{\\rho}f}_{n_x, n_y} = J_0(k_{\\perp}\\rho) \\hat{f}_{n_x, n_y}$.\n6.  Compute the inverse 2D DFT of the filtered coefficients using an inverse FFT algorithm (e.g., `numpy.fft.ifft2`) to obtain the gyroaveraged function on the real-space grid, $(\\mathcal{G}_{\\rho} f)_{\\mathrm{FFT}}$.\n\nFor the chosen test function, which is a sum of cosine modes of the form $f(x,y) = \\sum_m A_m \\cos(k_{mx}x + k_{my}y)$, we can find the exact analytical gyroaverage. Using the linearity of the operator and the derived identity on each single mode $e^{i\\mathbf{k}_m \\cdot \\mathbf{x}}$, we find:\n$$\n\\mathcal{G}_{\\rho}[\\cos(\\mathbf{k}_m \\cdot \\mathbf{x})] = J_0(k_{m\\perp}\\rho) \\cos(\\mathbf{k}_m \\cdot \\mathbf{x})\n$$\nThus, the exact analytical solution is:\n$$\n(\\mathcal{G}_{\\rho} f)_{\\mathrm{exact}}(x,y) = \\sum_m A_m J_0(k_{m\\perp}\\rho) \\cos(k_{mx}x + k_{my}y)\n$$\nwhere $k_{m\\perp} = \\sqrt{k_{mx}^2 + k_{my}^2}$. This analytical expression is evaluated on the same grid to serve as a reference for computing the normalized RMS error, $E_{\\mathrm{RMS}}$:\n$$\nE_{\\mathrm{RMS}} \\equiv \\sqrt{\\frac{\\sum_{i,j}\\left((\\mathcal{G}_{\\rho} f)_{\\mathrm{FFT}}(x_i,y_j) - (\\mathcal{G}_{\\rho} f)_{\\mathrm{exact}}(x_i,y_j)\\right)^2}{\\sum_{i,j}\\left((\\mathcal{G}_{\\rho} f)_{\\mathrm{exact}}(x_i,y_j)\\right)^2}}\n$$\nThis error quantifies discrepancies arising from numerical approximations, such as aliasing (when signal frequencies exceed the Nyquist frequency of the grid) and spectral leakage (when the signal contains frequencies not exactly representable by the discrete Fourier basis).\n\n-   **Test Case 1** is the ideal case where all wave modes in $f(x,y)$ are low-frequency and perfectly align with the discrete Fourier grid. The error is expected to be near machine precision.\n-   **Test Case 2** includes a high-wavenumber mode ($k_x=40$) that exceeds the Nyquist limit of the grid ($N/2=32$). This will cause aliasing, where the high-frequency mode is misinterpreted as a lower-frequency mode ($k_x = 40-64 = -24$). The FFT-based method will incorrectly filter this aliased mode, leading to a significant error.\n-   **Test Case 3** includes a mode with non-integer wavenumbers ($(3.7, 5.2)$). Such a mode is not periodic on the computational domain. When sampled and transformed, its energy \"leaks\" across many of the discrete Fourier modes. The numerical method filters each of these leaked components individually, which does not match the analytical solution where a single filter-factor is applied to the original continuous mode. This spectral leakage will also introduce a noticeable error.",
            "answer": "```python\nimport numpy as np\nfrom scipy import special\n\ndef solve():\n    \"\"\"\n    Computes the RMS error for the FFT-based gyroaveraging algorithm\n    for three distinct test cases.\n    \"\"\"\n\n    def compute_gyroaverage_error(N, rho, L, f_analytic, g_analytic):\n        \"\"\"\n        Computes the normalized RMS error between FFT-based and analytical gyroaveraging.\n        \n        Args:\n            N (int): Grid size (N x N).\n            rho (float): Gyroradius.\n            L (float): Domain side length.\n            f_analytic (callable): Function f(x,y) to be averaged.\n            g_analytic (callable): Analytical solution G_rho[f](x,y).\n            \n        Returns:\n            float: The computed normalized RMS error.\n        \"\"\"\n        # 1. Construct the real and wavenumber space grids\n        # Real-space grid\n        grid_points = np.linspace(0, L, N, endpoint=False)\n        xx, yy = np.meshgrid(grid_points, grid_points, indexing='xy')\n\n        # Wavenumber-space grid\n        k_vec = 2 * np.pi * np.fft.fftfreq(N, d=L / N)\n        kx, ky = np.meshgrid(k_vec, k_vec, indexing='xy')\n        k_perp = np.sqrt(kx**2 + ky**2)\n\n        # 2. Evaluate the initial function on the grid\n        f_grid = f_analytic(xx, yy)\n\n        # 3. Compute gyroaverage using FFT method\n        # 3a. Forward FFT\n        f_hat = np.fft.fft2(f_grid)\n        \n        # 3b. Apply J0 filter in Fourier space\n        j0_filter = special.j0(k_perp * rho)\n        g_hat = f_hat * j0_filter\n        \n        # 3c. Inverse FFT to get result in real space\n        g_fft = np.real(np.fft.ifft2(g_hat))\n\n        # 4. Compute the exact analytical solution on the grid for reference\n        g_exact_grid = g_analytic(xx, yy)\n\n        # 5. Calculate the normalized RMS error\n        numerator = np.sum((g_fft - g_exact_grid)**2)\n        denominator = np.sum(g_exact_grid**2)\n        \n        if denominator == 0:\n            # Handle the case of a zero reference field\n            return 0.0 if numerator == 0.0 else np.inf\n            \n        error = np.sqrt(numerator / denominator)\n        return error\n\n    # --- Define Test Cases ---\n    L_domain = 2 * np.pi\n    \n    # Test Case 1: Well-resolved modes\n    N1, rho1 = 128, 0.5\n    f1 = lambda x, y: np.cos(3*x + 4*y) + 0.6*np.cos(2*x - y) - 0.4*np.cos(5*x)\n    g1_exact = lambda x, y: (special.j0(np.sqrt(3**2 + 4**2) * rho1) * np.cos(3*x + 4*y) +\n                             0.6 * special.j0(np.sqrt(2**2 + (-1)**2) * rho1) * np.cos(2*x - y) -\n                             0.4 * special.j0(np.sqrt(5**2 + 0**2) * rho1) * np.cos(5*x))\n\n    # Test Case 2: Aliasing\n    N2, rho2 = 64, 1.2\n    f2 = lambda x, y: np.cos(40*x) + 0.3*np.cos(5*x + 7*y)\n    g2_exact = lambda x, y: (special.j0(40 * rho2) * np.cos(40*x) +\n                             0.3 * special.j0(np.sqrt(5**2 + 7**2) * rho2) * np.cos(5*x + 7*y))\n\n    # Test Case 3: Spectral leakage\n    N3, rho3 = 64, 2.0\n    f3 = lambda x, y: np.cos(3.7*x + 5.2*y) + 0.5*np.cos(4*x + 2*y)\n    g3_exact = lambda x, y: (special.j0(np.sqrt(3.7**2 + 5.2**2) * rho3) * np.cos(3.7*x + 5.2*y) +\n                             0.5 * special.j0(np.sqrt(4**2 + 2**2) * rho3) * np.cos(4*x + 2*y))\n\n    test_cases = [\n        (N1, rho1, f1, g1_exact),\n        (N2, rho2, f2, g2_exact),\n        (N3, rho3, f3, g3_exact)\n    ]\n    \n    results = []\n    for N, rho, f, g in test_cases:\n        error = compute_gyroaverage_error(N, rho, L_domain, f, g)\n        results.append(error)\n\n    # Print the results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "While the Fourier-based method provides a numerically exact way to compute the gyroaverage, its filter function, the Bessel function $J_0(k_\\perp \\rho)$, can be computationally expensive. In many fluid models and analytical treatments, it is replaced with a simpler Finite Larmor Radius (FLR) approximation based on its Taylor series expansion. This practice challenges you to quantify the accuracy of these FLR approximations by computing a spectrum-weighted error, providing insight into the crucial trade-off between computational cost and physical fidelity in gyrokinetic modeling .",
            "id": "3988375",
            "problem": "You are asked to design and implement a computational procedure to assess the accuracy of Finite Larmor Radius (FLR) approximations within gyroaveraging algorithms by comparing truncated series approximations of the zeroth-order Bessel function of the first kind to its exact evaluation. The physical context is the gyroaverage of a perpendicular-mode spectrum, which is mathematically represented by a Fourier amplitude multiplied by a gyroaveraging factor. The gyroaveraging factor for perpendicular wavenumber $k_\\perp$ and gyroradius $\\rho$ is the zeroth-order Bessel function of the first kind $J_0(k_\\perp \\rho)$, obtained from the gyrophase average of the plane wave factor. All quantities in this problem are nondimensional.\n\nYour task is to compute a spectrum-weighted root-mean-square error of two FLR approximations evaluated across a mode spectrum $S(k)$ for wavenumber $k \\in [0,k_{\\max}]$, and to decide whether full Bessel function evaluation is required to meet a target accuracy. The gyroaveraging factor is $G(k) = J_0(k \\rho)$. The FLR approximations to be assessed are the truncated Taylor series of $J_0(x)$ at small argument $x$, specified as follows:\n- Second-order approximation: $G_2(k) = 1 - \\dfrac{(k \\rho)^2}{4}$.\n- Fourth-order approximation: $G_4(k) = 1 - \\dfrac{(k \\rho)^2}{4} + \\dfrac{(k \\rho)^4}{64}$.\n\nThe mode spectrum is defined as\n$$\nS(k) = C \\left(\\frac{k}{k_c}\\right)^\\alpha \\exp\\!\\left[-\\left(\\frac{k}{k_c}\\right)^\\beta\\right],\n$$\nwhere $k_c>0$, $\\alpha>0$, and $\\beta>0$ are parameters that shape the spectrum, and $C$ is chosen such that the spectrum has unit squared norm over the interval $[0,k_{\\max}]$:\n$$\n\\int_0^{k_{\\max}} S(k)^2 \\, \\mathrm{d}k = 1.\n$$\nLet $k_{\\mathrm{peak}}$ denote the wavenumber at which $S(k)$ attains its maximum over $[0,k_{\\max}]$. Define the gyroradius $\\rho$ by the condition\n$$\nk_{\\mathrm{peak}} \\rho = 0.5,\n$$\nwhich anchors the gyroaveraging argument at the spectral peak to the specified value $k_\\perp \\rho = 0.5$. This construction ensures that the reference argument $0.5$ is realized at the dominant mode of the spectrum while permitting systematic error assessment over the entire range of $k$.\n\nDefine the spectrum-weighted root-mean-square error for an approximation $G_p(k)$ relative to $G(k)$ as\n$$\n\\mathcal{E}_p = \\left( \\int_0^{k_{\\max}} \\left[ G(k) - G_p(k) \\right]^2 S(k)^2 \\, \\mathrm{d}k \\right)^{1/2}.\n$$\nYou must evaluate the integrals via Gauss–Legendre quadrature with $N$ nodes on $[0,k_{\\max}]$. The computation of $C$ must also use the same quadrature rule to enforce the normalization condition. If an analytical expression for $k_{\\mathrm{peak}}$ is not within the interval $[0,k_{\\max}]$ or is ill-defined for the given parameters, then $k_{\\mathrm{peak}}$ should be taken as the maximizer of $S(k)$ over the quadrature nodes.\n\nFor each test case, your program must compute:\n1. The normalization constant $C$ such that $\\int_0^{k_{\\max}} S(k)^2 \\, \\mathrm{d}k = 1$.\n2. The value of $k_{\\mathrm{peak}}$ and the corresponding $\\rho$ from $k_{\\mathrm{peak}} \\rho = 0.5$.\n3. The spectrum-weighted root-mean-square errors $\\mathcal{E}_2$ and $\\mathcal{E}_4$.\n4. A boolean decision variable `require_full` that is `True` if neither FLR approximation meets the target accuracy $\\tau$, i.e., if $\\min(\\mathcal{E}_2,\\mathcal{E}_4) > \\tau$, and `False` otherwise.\n\nUse the following test suite, which includes a general case, a low-$k_{\\max}$ regime, a high-$k_{\\max}$ regime, and a non-Gaussian tail case, to ensure coverage of typical and edge conditions:\n- Test case $1$: $k_{\\max} = 4.0$, $k_c = 1.0$, $\\alpha = 2.0$, $\\beta = 2.0$, $N = 200$, $\\tau = 10^{-4}$.\n- Test case $2$: $k_{\\max} = 2.0$, $k_c = 0.8$, $\\alpha = 0.5$, $\\beta = 2.0$, $N = 200$, $\\tau = 10^{-6}$.\n- Test case $3$: $k_{\\max} = 20.0$, $k_c = 2.0$, $\\alpha = 1.0$, $\\beta = 1.0$, $N = 400$, $\\tau = 10^{-5}$.\n- Test case $4$: $k_{\\max} = 10.0$, $k_c = 0.7$, $\\alpha = 1.5$, $\\beta = 3.0$, $N = 300$, $\\tau = 10^{-3}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order\n$$\n[\\mathcal{E}_2^{(1)}, \\mathcal{E}_4^{(1)}, \\mathrm{require\\_full}^{(1)}, \\mathcal{E}_2^{(2)}, \\mathcal{E}_4^{(2)}, \\mathrm{require\\_full}^{(2)}, \\mathcal{E}_2^{(3)}, \\mathcal{E}_4^{(3)}, \\mathrm{require\\_full}^{(3)}, \\mathcal{E}_2^{(4)}, \\mathcal{E}_4^{(4)}, \\mathrm{require\\_full}^{(4)}],\n$$\nwhere the superscript $(i)$ identifies the $i$-th test case. All outputs are nondimensional real numbers or booleans and must be reported as decimals and boolean literals on a single line.",
            "solution": "The problem is valid. It is a well-posed, scientifically grounded problem in computational plasma physics that is free of contradictions or ambiguities.\n\nThe objective is to evaluate the accuracy of two Finite Larmor Radius (FLR) approximations for the gyroaveraging factor $G(k) = J_0(k \\rho)$ against a given mode spectrum $S(k)$. The gyroaveraging factor, which is the zeroth-order Bessel function of the first kind $J_0(x)$, arises from averaging a plane wave over a gyromotion orbit. The FLR approximations are derived from the Taylor series expansion of $J_0(x)$ for small arguments $x=k\\rho$, where $k$ is the perpendicular wavenumber and $\\rho$ is the Larmor radius. The approximations to be analyzed are:\n- The second-order approximation: $G_2(k) = 1 - \\dfrac{(k \\rho)^2}{4}$\n- The fourth-order approximation: $G_4(k) = 1 - \\dfrac{(k \\rho)^2}{4} + \\dfrac{(k \\rho)^4}{64}$\n\nThe computational procedure involves several steps: numerical integration using Gauss-Legendre quadrature, normalization of the spectrum, identification of the spectral peak, determination of the gyroradius, and computation of a spectrum-weighted error metric.\n\n**1. Numerical Quadrature Scheme**\nAll integrals over the wavenumber domain $k \\in [0, k_{\\max}]$ are to be computed using Gauss-Legendre quadrature with $N$ nodes. The standard Gauss-Legendre quadrature is defined on the interval $[-1, 1]$:\n$$\n\\int_{-1}^{1} f(x) \\, \\mathrm{d}x \\approx \\sum_{i=1}^N w_i f(x_i)\n$$\nwhere $x_i$ are the nodes and $w_i$ are the corresponding weights. To apply this to an integral over $[0, k_{\\max}]$, we perform a linear change of variables:\n$$\nk = \\frac{k_{\\max}}{2}(x+1) \\quad \\implies \\quad \\mathrm{d}k = \\frac{k_{\\max}}{2} \\mathrm{d}x\n$$\nThe integral of a function $g(k)$ is then approximated as:\n$$\n\\int_0^{k_{\\max}} g(k) \\, \\mathrm{d}k = \\int_{-1}^{1} g\\left(\\frac{k_{\\max}}{2}(x+1)\\right) \\frac{k_{\\max}}{2} \\, \\mathrm{d}x \\approx \\sum_{i=1}^N \\left(w_i \\frac{k_{\\max}}{2}\\right) g(k_i)\n$$\nwhere $k_i = \\frac{k_{\\max}}{2}(x_i+1)$ are the quadrature nodes transformed to the interval $[0, k_{\\max}]$. The quadrature nodes $x_i$ lie strictly within $(-1, 1)$, so the transformed nodes $k_i$ lie strictly within $(0, k_{\\max})$.\n\n**2. Mode Spectrum Normalization**\nThe mode spectrum is given by\n$$\nS(k) = C \\left(\\frac{k}{k_c}\\right)^\\alpha \\exp\\!\\left[-\\left(\\frac{k}{k_c}\\right)^\\beta\\right]\n$$\nwhere $C$ is a normalization constant. Let the unnormalized spectrum be $S_u(k) = (k/k_c)^\\alpha \\exp[-(k/k_c)^\\beta]$. The constant $C$ is determined by the condition that the squared norm of the spectrum is unity:\n$$\n\\int_0^{k_{\\max}} S(k)^2 \\, \\mathrm{d}k = C^2 \\int_0^{k_{\\max}} S_u(k)^2 \\, \\mathrm{d}k = 1\n$$\nUsing the numerical quadrature, the integral of the squared unnormalized spectrum is computed as:\n$$\nI_{norm} = \\int_0^{k_{\\max}} S_u(k)^2 \\, \\mathrm{d}k \\approx \\sum_{i=1}^N w'_i S_u(k_i)^2\n$$\nwhere $w'_i = w_i \\frac{k_{\\max}}{2}$ are the scaled weights. The normalization constant is then $C = 1/\\sqrt{I_{norm}}$.\n\n**3. Spectral Peak and Gyroradius**\nThe gyroradius $\\rho$ is set by the condition $k_{\\mathrm{peak}}\\rho = 0.5$, where $k_{\\mathrm{peak}}$ is the wavenumber at which $S(k)$ is maximum. To find $k_{\\mathrm{peak}}$, we first seek an analytical solution by finding the maximum of $\\ln S_u(k)$, as the logarithm is a monotonic function.\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}k} \\ln S_u(k) = \\frac{\\mathrm{d}}{\\mathrm{d}k} \\left( \\alpha \\ln k - \\alpha \\ln k_c - \\left(\\frac{k}{k_c}\\right)^\\beta \\right) = \\frac{\\alpha}{k} - \\frac{\\beta}{k_c^\\beta} k^{\\beta-1}\n$$\nSetting the derivative to zero yields the analytical location of the peak:\n$$\n\\frac{\\alpha}{k} = \\frac{\\beta k^{\\beta-1}}{k_c^\\beta} \\quad \\implies \\quad k^\\beta = \\frac{\\alpha}{\\beta} k_c^\\beta \\quad \\implies \\quad k_{\\mathrm{peak, an}} = k_c \\left(\\frac{\\alpha}{\\beta}\\right)^{1/\\beta}\n$$\nSince the problem parameters are $\\alpha > 0$, $\\beta > 0$, and $k_c > 0$, this analytical peak is a positive real number. If $k_{\\mathrm{peak, an}}$ falls within the integration domain, i.e., $0 < k_{\\mathrm{peak, an}} \\le k_{\\max}$, it is used as $k_{\\mathrm{peak}}$. Otherwise, $k_{\\mathrm{peak}}$ is taken as the wavenumber $k_i$ among the quadrature nodes that maximizes the value of $S_u(k_i)$. Once $k_{\\mathrm{peak}}$ is determined, the gyroradius is calculated as $\\rho = 0.5 / k_{\\mathrm{peak}}$.\n\n**4. Spectrum-Weighted Error Calculation**\nThe spectrum-weighted root-mean-square error for an approximation $G_p(k)$ is\n$$\n\\mathcal{E}_p = \\left( \\int_0^{k_{\\max}} \\left[ G(k) - G_p(k) \\right]^2 S(k)^2 \\, \\mathrm{d}k \\right)^{1/2}\n$$\nNumerically, this is computed as:\n$$\n\\mathcal{E}_p^2 \\approx \\sum_{i=1}^N w'_i \\left[ G(k_i) - G_p(k_i) \\right]^2 S(k_i)^2\n$$\nSubstituting $S(k_i) = C S_u(k_i)$ and $C^2 = 1/I_{norm} = 1 / (\\sum_{j=1}^N w'_j S_u(k_j)^2)$, we get:\n$$\n\\mathcal{E}_p^2 \\approx \\frac{\\sum_{i=1}^N w'_i \\left[ G(k_i) - G_p(k_i) \\right]^2 S_u(k_i)^2}{\\sum_{j=1}^N w'_j S_u(k_j)^2}\n$$\nThis expression robustly computes the squared error as a weighted average of the local squared differences $[G - G_p]^2$ over the quadrature nodes, with weights given by $w'_i S_u(k_i)^2$. The errors $\\mathcal{E}_2$ and $\\mathcal{E}_4$ are obtained by taking the square root.\n\n**5. Decision Criterion**\nThe final step is to determine if the full Bessel function $J_0$ is required to meet a specified accuracy threshold $\\tau$. If both approximations fail to meet this threshold, the decision variable `require_full` is set to `True`.\n$$\n\\mathrm{require\\_full} = (\\min(\\mathcal{E}_2, \\mathcal{E}_4) > \\tau)\n$$\nThis procedure is applied to each test case to generate the required outputs.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\nfrom scipy.special import j0\n\ndef solve():\n    \"\"\"\n    Computes the accuracy of FLR approximations for gyroaveraging\n    and decides if full Bessel function evaluation is needed based on a target accuracy.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (k_max, k_c, alpha, beta, N, tau)\n        (4.0, 1.0, 2.0, 2.0, 200, 1e-4),\n        (2.0, 0.8, 0.5, 2.0, 200, 1e-6),\n        (20.0, 2.0, 1.0, 1.0, 400, 1e-5),\n        (10.0, 0.7, 1.5, 3.0, 300, 1e-3),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        k_max, k_c, alpha, beta, N, tau = case\n\n        # 1. Setup Gauss-Legendre Quadrature\n        nodes, weights = roots_legendre(N)\n        # Transform nodes from [-1, 1] to [0, k_max]\n        k_nodes = 0.5 * k_max * (nodes + 1)\n        # Transform weights for the new interval\n        k_weights = 0.5 * k_max * weights\n\n        # 2. Define and Evaluate the Unnormalized Spectrum\n        def s_unnormalized(k, kc, a, b):\n            \"\"\"Computes the unnormalized spectrum S_u(k).\"\"\"\n            # Handle k=0 where k^a can cause warnings, though result is 0 for a>0.\n            # Gauss-Legendre nodes are in (0, k_max), so k is never 0.\n            # No special handling needed for standard Gauss-Legendre.\n            ratio = k / kc\n            return np.power(ratio, a) * np.exp(-np.power(ratio, b))\n\n        s_u_values = s_unnormalized(k_nodes, k_c, alpha, beta)\n\n        # 3. Compute Normalization Integral for S(k)^2\n        # Integral of S_u(k)^2 over [0, k_max]\n        norm_integral_sq = np.sum(k_weights * (s_u_values**2))\n        \n        # The normalization constant C would be 1/sqrt(norm_integral_sq),\n        # but we can compute the weighted errors without explicitly finding C.\n\n        # 4. Determine k_peak and gyroradius rho\n        # Analytical peak location\n        k_peak_an = k_c * (alpha / beta)**(1.0 / beta)\n        \n        if 0 < k_peak_an <= k_max:\n            k_peak = k_peak_an\n        else:\n            # Numerical peak location if analytical is out of bounds\n            peak_idx = np.argmax(s_u_values)\n            k_peak = k_nodes[peak_idx]\n\n        # Gyroradius from the peak condition\n        rho = 0.5 / k_peak\n\n        # 5. Evaluate Gyroaveraging Factors and Errors\n        arg = k_nodes * rho\n        \n        # Exact gyroaveraging factor\n        G_exact = j0(arg)\n        \n        # FLR approximations\n        G_2 = 1.0 - arg**2 / 4.0\n        G_4 = 1.0 - arg**2 / 4.0 + arg**4 / 64.0\n\n        # Squared differences\n        diff_sq_2 = (G_exact - G_2)**2\n        diff_sq_4 = (G_exact - G_4)**2\n\n        # Numerators for the weighted mean square error\n        error_integral_2_num = np.sum(k_weights * diff_sq_2 * (s_u_values**2))\n        error_integral_4_num = np.sum(k_weights * diff_sq_4 * (s_u_values**2))\n        \n        # Denominator is the normalization integral\n        denominator = norm_integral_sq\n\n        # Spectrum-weighted root-mean-square errors\n        E2 = np.sqrt(error_integral_2_num / denominator)\n        E4 = np.sqrt(error_integral_4_num / denominator)\n\n        # 6. Make the Decision\n        require_full = min(E2, E4) > tau\n\n        # 7. Collect results for the current test case\n        results.extend([E2, E4, require_full])\n\n    # Final print statement in the exact required format.\n    # The format requires boolean literals True/False, which str() provides.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}