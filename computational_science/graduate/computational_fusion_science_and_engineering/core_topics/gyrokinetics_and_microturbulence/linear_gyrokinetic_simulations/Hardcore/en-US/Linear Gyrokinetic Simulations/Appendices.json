{
    "hands_on_practices": [
        {
            "introduction": "At the heart of any gyrokinetic code is the solution of the time-dependent gyrokinetic equation. This equation includes a \"streaming\" or \"advection\" term, $v_{\\parallel} \\partial g / \\partial l$, which describes how particles move along magnetic field lines. The accuracy with which this simple advection is simulated dictates the fidelity of the entire simulation, especially for wave propagation phenomena. This exercise  provides a foundational understanding of numerical dispersion—an artifact of discretization—by comparing different numerical schemes against the exact analytical solution, a critical skill for developing and assessing simulation tools.",
            "id": "4002409",
            "problem": "You are to evaluate numerical dispersion of parallel plane waves in the linear gyrokinetic streaming operator by comparing the discrete eigenvalues obtained on a periodic grid to the analytic continuous relation. Begin from the linear streaming term in the drift-kinetic or gyrokinetic equation along the magnetic field line, which can be written as $\\partial_t g + v_{\\parallel} \\partial_l g = 0$, where $g$ is a scalar field, $l$ is the coordinate along the field line, and $v_{\\parallel}$ is a constant parallel velocity. For a plane wave ansatz $g \\propto \\exp(i k_{\\parallel} l - i \\omega t)$, the analytic dispersion relation is $\\omega = k_{\\parallel} v_{\\parallel}$. On a uniform periodic spatial grid of length $L$ with $N$ points and spacing $\\Delta = L/N$, the spatial derivative is discretized by a linear operator that depends on the chosen scheme. The discrete streaming operator is the matrix $L_d = - v_{\\parallel} D$, where $D$ is the discrete derivative operator associated with the chosen scheme and periodic boundaries. Because $D$ is circulant, its eigenvectors are discrete Fourier modes and its eigenvalues can be expressed by a scheme-dependent modified wavenumber. The discrete eigenvalues of $L_d$ are then compared to the analytic eigenvalues implied by the continuous dispersion relation.\n\nYour tasks are:\n- From fundamental principles, explain why for the continuous streaming operator the dispersion relation is $\\omega = k_{\\parallel} v_{\\parallel}$, and why for a periodic uniform grid the discrete derivative operator is circulant with discrete Fourier modes as eigenvectors.\n- For the following derivative schemes, construct the discrete eigenvalues of the streaming operator by evaluating the eigenvalues of the discrete derivative operator at the discrete Fourier modes:\n  - Second-order centered finite difference on the periodic grid.\n  - Fourth-order centered finite difference on the periodic grid.\n  - Spectral differentiation using the discrete Fourier transform (Fourier collocation) on the periodic grid.\n- For each discrete scheme, define the numerical frequency $\\omega_{\\text{num}}(k)$ from the corresponding discrete streaming operator eigenvalue and compare it to the analytic frequency $\\omega_{\\text{exact}}(k) = v_{\\parallel} k$. Define the per-mode relative dispersion error as $E(k) = |\\omega_{\\text{num}}(k) - \\omega_{\\text{exact}}(k)| / |\\omega_{\\text{exact}}(k)|$.\n- On a grid with $N$ points, the discrete Fourier wavenumbers are $k_m = 2\\pi m / L$ with $m \\in \\{0,1,\\dots,N-1\\}$ mapped to signed integers using the standard discrete Fourier transform ordering. The discrete modes include $k=0$ and, when $N$ is even, a Nyquist mode with $|k| \\Delta = \\pi$. For the purpose of computing relative error, exclude the $k=0$ mode (division by zero in the relative error) and exclude the Nyquist mode (where some centered schemes give a zero derivative and Fourier collocation has an ambiguity). Use the angle unit radians for all trigonometric evaluations.\n- For each test case below, compute and report the maximum relative dispersion error over the set of included discrete modes, that is, $\\max_{k \\neq 0,\\, |k|\\Delta \\neq \\pi} E(k)$.\n\nImplement a program that performs these computations for the following test suite of parameter sets:\n- Case A: scheme second-order centered, $N = 64$, $L = 2\\pi$, $v_{\\parallel} = 1.0$.\n- Case B: scheme fourth-order centered, $N = 64$, $L = 2\\pi$, $v_{\\parallel} = 1.0$.\n- Case C: scheme spectral (discrete Fourier transform collocation), $N = 64$, $L = 2\\pi$, $v_{\\parallel} = 1.0$.\n- Case D: scheme second-order centered, $N = 16$, $L = 2\\pi$, $v_{\\parallel} = 3.0$.\n- Case E: scheme fourth-order centered, $N = 32$, $L = 10.0$, $v_{\\parallel} = 0.7$.\n\nYour program must:\n- Construct the discrete Fourier wavenumber array $k$ for each case using the standard discrete Fourier transform ordering on a domain of length $L$ and spacing $\\Delta = L/N$.\n- For each scheme, evaluate the discrete derivative operator eigenvalues at the modes $k$ to obtain the scheme’s modified wavenumber and hence the discrete streaming operator eigenvalues. Then compute $\\omega_{\\text{num}}(k)$ and the relative errors $E(k)$.\n- Exclude $k=0$ and any mode with $|k|\\Delta = \\pi$ from the error set.\n- Compute the maximum $E(k)$ over the remaining modes.\n- Produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $\\left[\\text{Case A}, \\text{Case B}, \\text{Case C}, \\text{Case D}, \\text{Case E}\\right]$. Express each result as a decimal number rounded to $10$ decimal places, with no units.\n\nAll numerical quantities and calculations are to be performed in pure numbers without physical units in the final output. The single output line format must be exactly: $[\\text{result\\_A},\\text{result\\_B},\\text{result\\_C},\\text{result\\_D},\\text{result\\_E}]$.",
            "solution": "The problem requires an analysis of the numerical dispersion introduced by discretizing the linear streaming operator $\\partial_t g + v_{\\parallel} \\partial_l g = 0$. We must first validate the problem statement and, if valid, provide a detailed derivation of the numerical dispersion relations for several common numerical schemes, followed by a computational implementation to quantify the dispersion error for specific test cases.\n\nThe problem is scientifically valid, well-posed, and self-contained. It is grounded in the fundamental principles of partial differential equations and their numerical solution, a core topic in computational science. The provided data and conditions are complete and consistent, allowing for a unique and meaningful solution. We may therefore proceed with the derivation and solution.\n\n**1. Analytic Dispersion Relation**\n\nThe continuous linear streaming equation is given by:\n$$\n\\frac{\\partial g}{\\partial t} + v_{\\parallel} \\frac{\\partial g}{\\partial l} = 0\n$$\nwhere $g(l, t)$ is a scalar field, $l$ is the spatial coordinate along a magnetic field line, $t$ is time, and $v_{\\parallel}$ is a constant velocity.\n\nTo find the dispersion relation, we assume a plane wave solution (ansatz) of the form:\n$$\ng(l, t) = g_0 \\exp(i(k_{\\parallel} l - \\omega t))\n$$\nwhere $g_0$ is a constant amplitude, $k_{\\parallel}$ is the parallel wavenumber, and $\\omega$ is the angular frequency. We compute the partial derivatives of this ansatz:\n$$\n\\frac{\\partial g}{\\partial t} = -i\\omega \\, g_0 \\exp(i(k_{\\parallel} l - \\omega t)) = -i\\omega g\n$$\n$$\n\\frac{\\partial g}{\\partial l} = i k_{\\parallel} \\, g_0 \\exp(i(k_{\\parallel} l - \\omega t)) = i k_{\\parallel} g\n$$\nSubstituting these expressions into the streaming equation yields:\n$$\n-i\\omega g + v_{\\parallel} (i k_{\\parallel} g) = 0\n$$\n$$\ni(k_{\\parallel} v_{\\parallel} - \\omega) g = 0\n$$\nFor a non-trivial solution ($g \\neq 0$), the term in the parenthesis must be zero. This gives the analytic dispersion relation:\n$$\n\\omega = k_{\\parallel} v_{\\parallel}\n$$\nThis relation, denoted as $\\omega_{\\text{exact}}(k) = v_{\\parallel} k$ (dropping the $\\parallel$ subscript for simplicity), indicates that in the continuous system, all wave modes propagate at the same phase velocity $v_{\\phi} = \\omega/k = v_{\\parallel}$ without distortion. This is a non-dispersive system.\n\n**2. Discretization on a Periodic Grid and Circulant Matrices**\n\nWhen the spatial domain of length $L$ is discretized into $N$ grid points $l_j = j \\Delta$ for $j \\in \\{0, 1, \\ldots, N-1\\}$, where $\\Delta = L/N$ is the grid spacing, a spatial derivative operator $\\partial_l$ is replaced by a discrete matrix operator $D$. Due to the periodic boundary conditions, a centered finite difference stencil applied at grid point $j$ that uses points $j \\pm p$ treats indices modulo $N$. For example, the stencil for the second-order centered difference is $(Dg)_j = (g_{j+1} - g_{j-1})/(2\\Delta)$. The stencil is the same for every grid point $j$, only shifted. This property means the resulting $N \\times N$ matrix $D$ is a circulant matrix. A matrix $C$ is circulant if its elements satisfy $C_{ij} = c_{(j-i) \\pmod N}$, meaning each row is a cyclic shift of the preceding row.\n\nA fundamental theorem of linear algebra states that all $N \\times N$ circulant matrices share a common set of eigenvectors: the discrete Fourier modes. A discrete Fourier mode $u^{(m)}$ is a vector with components:\n$$\nu_j^{(m)} = \\exp\\left(i \\frac{2\\pi m j}{N}\\right)\n$$\nfor $j \\in \\{0, 1, \\ldots, N-1\\}$ and mode number $m \\in \\{0, 1, \\ldots, N-1\\}$. Applying a circulant matrix $C$ with the first row $(c_0, c_1, \\ldots, c_{N-1})$ to this eigenvector gives:\n$$\n(C u^{(m)})_j = \\sum_{p=0}^{N-1} C_{jp} u_p^{(m)} = \\sum_{p=0}^{N-1} c_{(p-j)\\pmod N} \\exp\\left(i \\frac{2\\pi m p}{N}\\right)\n$$\nBy changing the summation variable to $q = (p-j) \\pmod N$, we have $p=(q+j)\\pmod N$:\n$$\n(C u^{(m)})_j = \\sum_{q=0}^{N-1} c_q \\exp\\left(i \\frac{2\\pi m (q+j)}{N}\\right) = \\exp\\left(i \\frac{2\\pi m j}{N}\\right) \\sum_{q=0}^{N-1} c_q \\exp\\left(i \\frac{2\\pi m q}{N}\\right) = \\lambda_m u_j^{(m)}\n$$\nThe eigenvalue $\\lambda_m$ is the discrete Fourier transform of the first row $(c_0, \\ldots, c_{N-1})$ of the matrix.\n\n**3. Eigenvalue Analysis of Numerical Schemes**\n\nThe semi-discretized streaming equation is $\\frac{d\\mathbf{g}}{dt} = -v_{\\parallel} D \\mathbf{g}$, where $\\mathbf{g}$ is the vector of grid point values. For an eigenmode $u^{(m)}$ corresponding to wavenumber $k_m = 2\\pi m/L$, we seek a solution of the form $\\mathbf{g}(t) = u^{(m)} \\exp(-i\\omega_{\\text{num}} t)$. Substituting this into the equation gives:\n$$\n-i\\omega_{\\text{num}} u^{(m)} \\exp(-i\\omega_{\\text{num}} t) = -v_{\\parallel} D (u^{(m)} \\exp(-i\\omega_{\\text{num}} t)) = -v_{\\parallel} \\lambda_D(k_m) u^{(m)} \\exp(-i\\omega_{\\text{num}} t)\n$$\nwhere $\\lambda_D(k_m)$ is the eigenvalue of the discrete derivative operator $D$ for the mode $k_m$. This simplifies to $-i\\omega_{\\text{num}} = -v_{\\parallel} \\lambda_D(k_m)$, from which we obtain the numerical dispersion relation:\n$$\n\\omega_{\\text{num}}(k_m) = -i v_{\\parallel} \\lambda_D(k_m)\n$$\nWe derive $\\lambda_D(k_m)$ for each scheme by applying the stencil to the grid representation of the plane wave, $g_j = \\exp(i k_m l_j) = \\exp(i k_m j \\Delta)$.\n\n*   **Second-Order Centered Finite Difference:**\n    The stencil is $D g_j = \\frac{g_{j+1} - g_{j-1}}{2\\Delta}$. Applying this to $g_j = \\exp(i k j \\Delta)$:\n    $$\n    D g_j = \\frac{\\exp(ik(j+1)\\Delta) - \\exp(ik(j-1)\\Delta)}{2\\Delta} = g_j \\frac{\\exp(ik\\Delta) - \\exp(-ik\\Delta)}{2\\Delta} = g_j \\frac{2i\\sin(k\\Delta)}{2\\Delta}\n    $$\n    The eigenvalue is $\\lambda_D(k) = i \\frac{\\sin(k\\Delta)}{\\Delta}$. The numerical frequency is:\n    $$\n    \\omega_{\\text{num}}(k) = -i v_{\\parallel} \\left(i \\frac{\\sin(k\\Delta)}{\\Delta}\\right) = v_{\\parallel} \\frac{\\sin(k\\Delta)}{\\Delta}\n    $$\n\n*   **Fourth-Order Centered Finite Difference:**\n    The stencil is $D g_j = \\frac{-g_{j+2} + 8g_{j+1} - 8g_{j-1} + g_{j-2}}{12\\Delta}$. Applying this to $g_j = \\exp(i k j \\Delta)$:\n    $$\n    D g_j = g_j \\frac{-e^{i2k\\Delta} + 8e^{ik\\Delta} - 8e^{-ik\\Delta} + e^{-i2k\\Delta}}{12\\Delta} = g_j \\frac{-2i\\sin(2k\\Delta) + 16i\\sin(k\\Delta)}{12\\Delta}\n    $$\n    The eigenvalue is $\\lambda_D(k) = i \\frac{8\\sin(k\\Delta) - \\sin(2k\\Delta)}{6\\Delta}$. The numerical frequency is:\n    $$\n    \\omega_{\\text{num}}(k) = v_{\\parallel} \\frac{8\\sin(k\\Delta) - \\sin(2k\\Delta)}{6\\Delta}\n    $$\n\n*   **Spectral (Fourier Collocation) Method:**\n    This method is based on representing the function $g$ in the basis of discrete Fourier modes. Differentiation in this basis is equivalent to multiplying the coefficient of each mode $\\exp(ik_m l)$ by $ik_m$. Thus, the action of the ideal spectral differentiation operator on a basis mode is exact. The eigenvalue of the discrete derivative operator $D$ for the mode $k_m$ is precisely:\n    $$\n    \\lambda_D(k_m) = i k_m\n    $$\n    The numerical frequency is therefore:\n    $$\n    \\omega_{\\text{num}}(k_m) = -i v_{\\parallel} (i k_m) = v_{\\parallel} k_m\n    $$\n    This is identical to the analytic dispersion relation, $\\omega_{\\text{num}}(k) = \\omega_{\\text{exact}}(k)$.\n\n**4. Relative Dispersion Error**\n\nThe quality of a numerical scheme for this problem is measured by how closely its numerical frequency $\\omega_{\\text{num}}(k)$ matches the exact frequency $\\omega_{\\text{exact}}(k) = v_{\\parallel} k$. The per-mode relative dispersion error $E(k)$ is defined as:\n$$\nE(k) = \\frac{|\\omega_{\\text{num}}(k) - \\omega_{\\text{exact}}(k)|}{|\\omega_{\\text{exact}}(k)|}\n$$\nThis error must be computed for all representable wavenumbers $k$ on the grid, with two exceptions as specified:\n1.  The $k=0$ mode (zero frequency mean component) is excluded, as it leads to division by zero in the error formula.\n2.  The Nyquist mode, which for an even number of grid points $N$ has wavenumber $|k|$ such that $|k|\\Delta=\\pi$, is excluded. For this mode, centered difference schemes yield $\\omega_{\\text{num}}=0$, and the Fourier method has an ambiguity in defining the derivative.\n\nOur task is to compute the maximum error over the set of included modes, $\\max_{k} E(k)$. For the spectral method, the error $E(k)$ is analytically zero for all modes, so the maximum error will be zero (or of the order of machine precision in a numerical implementation). For finite difference schemes, the error is non-zero and increases with the magnitude of the wavenumber $|k|$. The maximum error will occur for the largest-magnitude wavenumber before the Nyquist frequency.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the maximum relative dispersion error for several numerical schemes\n    applied to the linear streaming equation.\n    \"\"\"\n    test_cases = [\n        {'scheme': '2-cen', 'N': 64, 'L': 2 * np.pi, 'v_parallel': 1.0},\n        {'scheme': '4-cen', 'N': 64, 'L': 2 * np.pi, 'v_parallel': 1.0},\n        {'scheme': 'spectral', 'N': 64, 'L': 2 * np.pi, 'v_parallel': 1.0},\n        {'scheme': '2-cen', 'N': 16, 'L': 2 * np.pi, 'v_parallel': 3.0},\n        {'scheme': '4-cen', 'N': 32, 'L': 10.0, 'v_parallel': 0.7},\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case['N']\n        L = case['L']\n        v_parallel = case['v_parallel']\n        scheme = case['scheme']\n\n        # 1. Set up grid and wavenumbers\n        delta = L / N\n        # Wavenumbers k = 2 * pi * f, where f are the discrete frequencies\n        k = 2 * np.pi * np.fft.fftfreq(N, d=delta)\n\n        # 2. Calculate exact and numerical frequencies\n        w_exact = v_parallel * k\n        \n        k_delta = k * delta\n\n        if scheme == '2-cen':\n            # Second-order centered finite difference\n            # w_num = v_parallel * sin(k*delta) / delta\n            # To avoid division by zero at k=0, use np.sinc which is sin(pi*x)/(pi*x)\n            # sin(k*delta)/delta = (pi/pi) * sin(k*delta)/delta = (pi/delta) * sin(k*delta)/(k*delta*pi/k*delta)\n            # sin(x)/x = pi * sinc(x/pi)\n            # So, w_num = v_parallel * (pi/delta) * np.sinc(k_delta / np.pi)\n            # It's simpler to handle k=0 case separately.\n            # w_num for k=0 is 0.\n            # We can use np.divide with a where clause.\n            w_num = np.divide(v_parallel * np.sin(k_delta), delta, where=(k != 0), out=np.zeros_like(k))\n        \n        elif scheme == '4-cen':\n            # Fourth-order centered finite difference\n            # w_num = v_parallel * (8*sin(k*delta) - sin(2*k*delta)) / (6*delta)\n            numerator = v_parallel * (8 * np.sin(k_delta) - np.sin(2 * k_delta))\n            denominator = 6 * delta\n            w_num = np.divide(numerator, denominator, where=(k != 0), out=np.zeros_like(k))\n            \n        elif scheme == 'spectral':\n            # Spectral (Fourier collocation) method\n            # w_num = v_parallel * k\n            w_num = v_parallel * k\n        \n        else:\n            raise ValueError(f\"Unknown scheme: {scheme}\")\n\n        # 3. Define the mask to exclude k=0 and Nyquist mode\n        mask = np.ones(N, dtype=bool)\n        \n        # Exclude k=0 mode (DC component)\n        mask[0] = False\n        \n        # Exclude Nyquist mode if N is even. The Nyquist frequency\n        # corresponds to k where |k|*delta = pi. This is at index N//2 for even N.\n        if N % 2 == 0:\n            mask[N // 2] = False\n            \n        # 4. Calculate relative error on the masked modes\n        # We filter the arrays to avoid division by zero or any computation on excluded modes\n        w_exact_filtered = w_exact[mask]\n        w_num_filtered = w_num[mask]\n\n        # The problem is defined to exclude k=0, so w_exact_filtered will not contain zero.\n        rel_errors = np.abs(w_num_filtered - w_exact_filtered) / np.abs(w_exact_filtered)\n\n        # 5. Find the maximum relative error\n        max_error = 0.0\n        if rel_errors.size > 0:\n            max_error = np.max(rel_errors)\n        \n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    # Results are rounded to 10 decimal places.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While the full gyrokinetic equation is complex, it can be simplified in key limits to yield profound physical insight. For drift-wave instabilities that are strongly localized along the magnetic field, the system reduces to a one-dimensional eigenvalue problem in the ballooning coordinate $\\theta$. This problem  explores the powerful analogy where this equation takes the form of a Schrödinger-like equation, with the mode structure representing a \"bound state\" in an effective potential well. By solving this model, you will build intuition about what determines the spatial structure of instabilities and practice the core numerical task of solving matrix eigenvalue problems.",
            "id": "4002472",
            "problem": "You are asked to connect the linear Gyrokinetic (GK) description of microinstabilities in a magnetized plasma with a one-dimensional self-adjoint eigenproblem along a magnetic field line in ballooning representation, and then compute observable mode structure metrics. Starting from the linear GK equation in ballooning representation for electrostatic fluctuations and quasineutrality under standard drift-kinetic and strong-ballooning orderings, you should argue that the along-field-line structure of the electrostatic potential perturbation, denoted $\\delta\\phi(\\theta)$, satisfies a second-order self-adjoint ordinary differential eigenvalue problem of Sturm–Liouville type in a dimensionless ballooning angle $\\theta$ (in radians). Conclude that in a properly chosen normalization, the governing equation is of Schrödinger type,\n$$\n-\\frac{d^2}{d\\theta^2}\\,\\delta\\phi(\\theta) + V(\\theta)\\,\\delta\\phi(\\theta) = \\lambda\\,\\delta\\phi(\\theta),\n$$\nwhere $V(\\theta)$ is an effective potential that encapsulates curvature drive, magnetic shear, and finite Larmor radius effects, and $\\lambda$ is a real eigenvalue associated with the fluctuation frequency parameter in this simplified model. Physical bound-state-like modes correspond to square-integrable solutions with $\\delta\\phi(\\theta)\\to 0$ as $|\\theta|\\to\\infty$.\n\nYour task is to implement a numerical solver for the ground-state eigenfunction $\\delta\\phi(\\theta)$ on a finite interval $\\theta\\in[-\\theta_{\\max},\\theta_{\\max}]$ using a uniform grid and homogeneous Dirichlet boundary conditions $\\delta\\phi(-\\theta_{\\max})=\\delta\\phi(\\theta_{\\max})=0$ as an approximation to the decay at infinity. Use a second-order centered finite-difference discretization for the second derivative operator. The eigenproblem is then solved to obtain the smallest eigenvalue and its eigenfunction. Normalize the discrete eigenfunction such that the discrete approximation to the $L^2$ norm equals one:\n$$\n\\int_{-\\theta_{\\max}}^{\\theta_{\\max}} |\\delta\\phi(\\theta)|^2\\,d\\theta \\approx \\sum_{i} |\\delta\\phi_i|^2\\,\\Delta\\theta = 1,\n$$\nwhere $\\Delta\\theta$ is the grid spacing and $\\delta\\phi_i=\\delta\\phi(\\theta_i)$ are the interior grid values.\n\nFor each test case below, compute:\n- The mode peak location $\\theta_{\\text{peak}}$ in radians, defined as the grid point $\\theta_i$ where $|\\delta\\phi_i|$ attains its maximum value.\n- The mode width $w$ in radians, defined as the standard deviation of the probability density proportional to $|\\delta\\phi(\\theta)|^2$:\n$$\n\\mu = \\frac{\\int \\theta\\,|\\delta\\phi(\\theta)|^2\\,d\\theta}{\\int |\\delta\\phi(\\theta)|^2\\,d\\theta},\\quad\nw = \\left(\\frac{\\int (\\theta-\\mu)^2\\,|\\delta\\phi(\\theta)|^2\\,d\\theta}{\\int |\\delta\\phi(\\theta)|^2\\,d\\theta}\\right)^{1/2}.\n$$\nIn discrete form, use the uniform-grid Riemann sum with spacing $\\Delta\\theta$ over the interior points. Report both $\\theta_{\\text{peak}}$ and $w$ in radians.\n\nFor scientific realism and mathematical well-posedness, use a confining potential of the form\n$$\nV(\\theta) = a_0 + a_2\\,\\theta^2 + a_4\\,\\theta^4 - V_g\\,\\exp\\!\\left(-\\frac{(\\theta-\\theta_c)^2}{2\\,\\sigma^2}\\right) + s\\,\\theta,\n$$\nwhere $a_40$ ensures $V(\\theta)\\to+\\infty$ as $|\\theta|\\to\\infty$. All parameters are dimensionless, and $\\theta$ is an angle in radians.\n\nImplement a program that, for each test case, assembles the tridiagonal matrix corresponding to the finite-difference discretization of the operator $-\\frac{d^2}{d\\theta^2}+V(\\theta)$ on the interior grid, solves for the smallest eigenpair $\\{\\lambda,\\delta\\phi\\}$, normalizes $\\delta\\phi$ to unit discrete $L^2$ norm, and outputs the pair $[w,\\theta_{\\text{peak}}]$.\n\nUse the following test suite of three cases that probe symmetry, asymmetry, and near-threshold broadening:\n\n- Case $1$ (symmetric well, moderate localization):\n  - Domain half-width $\\theta_{\\max}=20$ (radians), grid size $N=1201$ points uniformly spaced on $[-\\theta_{\\max},\\theta_{\\max}]$.\n  - Parameters: $a_0=0.2$, $a_2=0.01$, $a_4=10^{-4}$, $V_g=1.0$, $\\sigma=2.0$, $\\theta_c=0.0$, $s=0.0$.\n\n- Case $2$ (asymmetric well, shifted peak):\n  - Domain half-width $\\theta_{\\max}=20$ (radians), grid size $N=1201$.\n  - Parameters: $a_0=0.2$, $a_2=0.01$, $a_4=10^{-4}$, $V_g=1.0$, $\\sigma=2.0$, $\\theta_c=2.0$, $s=0.02$.\n\n- Case $3$ (broad, shallow well):\n  - Domain half-width $\\theta_{\\max}=30$ (radians), grid size $N=1501$.\n  - Parameters: $a_0=0.1$, $a_2=0.002$, $a_4=5\\times10^{-5}$, $V_g=0.3$, $\\sigma=5.0$, $\\theta_c=0.0$, $s=0.0$.\n\nYour program must produce a single line of output containing the results for the three cases as a comma-separated list enclosed in square brackets, where each case result is the two-element list $[w,\\theta_{\\text{peak}}]$ with both entries in radians. For example, the output format must be\n\"[ [w_case1,theta_peak_case1], [w_case2,theta_peak_case2], [w_case3,theta_peak_case3] ]\"\nbut without spaces, that is:\n\"[[w1,tp1],[w2,tp2],[w3,tp3]]\"\nUse floating-point numbers for all reported values. Angles must be in radians. No other text should be printed.",
            "solution": "The problem presented is a valid and well-posed boundary-value problem rooted in computational plasma physics, specifically in the study of microinstabilities using the gyrokinetic model. The central task is to solve a one-dimensional, time-independent Schrödinger-like equation, which describes the structure of an electrostatic perturbation along a magnetic field line in ballooning representation. The equation is given as:\n$$\n-\\frac{d^2}{d\\theta^2}\\,\\delta\\phi(\\theta) + V(\\theta)\\,\\delta\\phi(\\theta) = \\lambda\\,\\delta\\phi(\\theta)\n$$\nThis is a canonical Sturm-Liouville eigenvalue problem. The operator $\\mathcal{L} = -\\frac{d^2}{d\\theta^2} + V(\\ theta)$ is self-adjoint on the space of square-integrable functions with the given boundary conditions. The potential $V(\\theta)$ is specified as:\n$$\nV(\\theta) = a_0 + a_2\\,\\theta^2 + a_4\\,\\theta^4 - V_g\\,\\exp\\!\\left(-\\frac{(\\theta-\\theta_c)^2}{2\\,\\sigma^2}\\right) + s\\,\\theta\n$$\nThe condition $a_40$ ensures that $V(\\theta) \\to \\infty$ as $|\\theta| \\to \\infty$, which guarantees a discrete spectrum of real eigenvalues bounded from below, and eigenfunctions that are square-integrable, corresponding to physically relevant bound states. The problem requires finding the ground state, which is the eigenfunction $\\delta\\phi(\\theta)$ corresponding to the lowest eigenvalue $\\lambda$. The infinite domain $\\theta \\in (-\\infty, \\infty)$ is approximated by a finite domain $\\theta \\in [-\\theta_{\\max}, \\theta_{\\max}]$ with homogeneous Dirichlet boundary conditions, $\\delta\\phi(-\\theta_{\\max}) = \\delta\\phi(\\theta_{\\max}) = 0$. This approximation is valid for low-lying, well-localized states, provided $\\theta_{\\max}$ is sufficiently large.\n\nThe solution proceeds by first discretizing the continuous differential equation into a matrix eigenvalue problem using a second-order centered finite difference scheme. A uniform grid is established over the domain $[-\\theta_{\\max}, \\theta_{\\max}]$ with $N$ points $\\theta_j = -\\theta_{\\max} + j\\Delta\\theta$ for $j=0, 1, \\dots, N-1$, where the grid spacing is $\\Delta\\theta = 2\\theta_{\\max}/(N-1)$. The solution is sought on the $N_{int}=N-2$ interior grid points, indexed $i=1, \\dots, N-2$. The boundary conditions are imposed as $\\delta\\phi_0 = 0$ and $\\delta\\phi_{N-1} = 0$.\n\nAt an interior grid point $\\theta_i$, the second derivative is approximated as:\n$$\n\\frac{d^2\\delta\\phi}{d\\theta^2}\\bigg|_{\\theta_i} \\approx \\frac{\\delta\\phi_{i+1} - 2\\delta\\phi_i + \\delta\\phi_{i-1}}{(\\Delta\\theta)^2}\n$$\nSubstituting this into the Schrödinger equation yields a system of linear algebraic equations for the vector of discrete eigenfunction values $\\vec{\\phi} = (\\delta\\phi_1, \\delta\\phi_2, \\dots, \\delta\\phi_{N-2})^T$:\n$$\n-\\frac{\\delta\\phi_{i+1} - 2\\delta\\phi_i + \\delta\\phi_{i-1}}{(\\Delta\\theta)^2} + V(\\theta_i)\\delta\\phi_i = \\lambda \\delta\\phi_i\n$$\nThis can be cast into the matrix eigenvalue problem $H\\vec{\\phi} = \\lambda\\vec{\\phi}$, where $H$ is a real, symmetric, tridiagonal matrix of size $(N-2) \\times (N-2)$. The elements of $H$ are:\n$$\nH_{ij} = \\begin{cases}\n    \\frac{2}{(\\Delta\\theta)^2} + V(\\theta_i)  \\text{if } i=j \\\\\n    -\\frac{1}{(\\Delta\\theta)^2}  \\text{if } |i-j|=1 \\\\\n    0  \\text{otherwise}\n\\end{cases}\n$$\nThis matrix eigenvalue problem is solved numerically to obtain the set of eigenvalues and corresponding eigenvectors. We select the eigenvector associated with the smallest eigenvalue, which represents the ground state.\n\nThe resulting eigenvector, let us call it $\\vec{\\psi}$, is typically normalized by numerical libraries to have a unit Euclidean norm, i.e., $\\sum_i |\\psi_i|^2=1$. The problem requires normalization according to the discrete $L^2$ norm: $\\int |\\delta\\phi|^2 d\\theta \\approx \\sum_i |\\delta\\phi_i|^2 \\Delta\\theta = 1$. To achieve this, we must rescale the eigenvector. Let the correctly normalized eigenfunction be $\\delta\\phi_i = C \\psi_i$. Then,\n$$\n\\sum_{i=1}^{N-2} |C \\psi_i|^2 \\Delta\\theta = C^2 \\Delta\\theta \\sum_{i=1}^{N-2} |\\psi_i|^2 = C^2 \\Delta\\theta \\cdot 1 = 1\n$$\nThis implies the scaling factor is $C = 1/\\sqrt{\\Delta\\theta}$. The normalized eigenfunction is thus $\\delta\\phi_i = \\psi_i / \\sqrt{\\Delta\\theta}$.\n\nWith the normalized ground-state eigenfunction $\\delta\\phi_i$ computed on the interior grid, we calculate the required observables.\nThe mode peak location, $\\theta_{\\text{peak}}$, is the grid point $\\theta_i$ where $|\\delta\\phi_i|$ is maximum.\n$$\n\\theta_{\\text{peak}} = \\theta_{i_{\\text{peak}}} \\quad \\text{where} \\quad i_{\\text{peak}} = \\underset{i \\in \\{1,\\dots,N-2\\}}{\\text{argmax}} |\\delta\\phi_i|\n$$\nThe mode width, $w$, is the standard deviation of the probability density function $P(\\theta) \\propto |\\delta\\phi(\\theta)|^2$. Given our normalization, the discrete probability density is $p_i = |\\delta\\phi_i|^2 \\Delta\\theta$, and $\\sum_i p_i = 1$. The discrete mean $\\mu$ and width $w$ are calculated as:\n$$\n\\mu = \\sum_{i=1}^{N-2} \\theta_i |\\delta\\phi_i|^2 \\Delta\\theta\n$$\n$$\nw = \\left( \\sum_{i=1}^{N-2} (\\theta_i - \\mu)^2 |\\delta\\phi_i|^2 \\Delta\\theta \\right)^{1/2}\n$$\nThe implementation will use `scipy.linalg.eigh_tridiagonal` for its efficiency in solving the specific eigenvalue problem for a real symmetric tridiagonal matrix.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh_tridiagonal\n\ndef solve():\n    \"\"\"\n    Solves the 1D Schrödinger equation for three test cases from gyrokinetic theory\n    and computes mode structure metrics.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: symmetric well, moderate localization\n        {\n            \"theta_max\": 20.0, \"N\": 1201,\n            \"params\": {\"a0\": 0.2, \"a2\": 0.01, \"a4\": 1e-4, \"Vg\": 1.0, \"sigma\": 2.0, \"thetac\": 0.0, \"s\": 0.0}\n        },\n        # Case 2: asymmetric well, shifted peak\n        {\n            \"theta_max\": 20.0, \"N\": 1201,\n            \"params\": {\"a0\": 0.2, \"a2\": 0.01, \"a4\": 1e-4, \"Vg\": 1.0, \"sigma\": 2.0, \"thetac\": 2.0, \"s\": 0.02}\n        },\n        # Case 3: broad, shallow well\n        {\n            \"theta_max\": 30.0, \"N\": 1501,\n            \"params\": {\"a0\": 0.1, \"a2\": 0.002, \"a4\": 5e-5, \"Vg\": 0.3, \"sigma\": 5.0, \"thetac\": 0.0, \"s\": 0.0}\n        }\n    ]\n\n    results = []\n    \n    def potential_v(theta, p):\n        \"\"\"\n        Calculates the potential V(theta) for a given set of parameters.\n        \"\"\"\n        return p[\"a0\"] + p[\"a2\"] * theta**2 + p[\"a4\"] * theta**4 \\\n               - p[\"Vg\"] * np.exp(-(theta - p[\"thetac\"])**2 / (2 * p[\"sigma\"]**2)) \\\n               + p[\"s\"] * theta\n\n    for case in test_cases:\n        # Unpack case parameters\n        theta_max = case[\"theta_max\"]\n        N = case[\"N\"]\n        params = case[\"params\"]\n\n        # 1. Set up the grid\n        theta_full = np.linspace(-theta_max, theta_max, N)\n        delta_theta = theta_full[1] - theta_full[0]\n        \n        # We solve on the interior grid points\n        theta_interior = theta_full[1:-1]\n        N_interior = N - 2\n        \n        # 2. Construct the Hamiltonian matrix\n        V_values = potential_v(theta_interior, params)\n        \n        # Main diagonal of the Hamiltonian H\n        diag = 2.0 / (delta_theta**2) + V_values\n        \n        # Off-diagonal of H\n        off_diag = -1.0 / (delta_theta**2) * np.ones(N_interior - 1)\n        \n        # 3. Solve the eigenvalue problem\n        # eigh_tridiagonal returns eigenvalues in ascending order and corresponding eigenvectors\n        eigenvalues, eigenvectors = eigh_tridiagonal(diag, off_diag)\n        \n        # The ground state is the first eigenvector (corresponding to the smallest eigenvalue)\n        ground_state_psi = eigenvectors[:, 0]\n        \n        # 4. Normalize the eigenfunction\n        # The solver returns eigenvectors with L2 norm (sum of squares) = 1.\n        # We need to normalize to the continuous L2 norm integral approximation, sum(phi^2 * d_theta) = 1.\n        # phi = C * psi, sum((C*psi)^2 * d_theta) = 1 => C^2 * sum(psi^2) * d_theta = 1\n        # C^2 * 1 * d_theta = 1 => C = 1 / sqrt(d_theta)\n        normalization_factor = 1.0 / np.sqrt(delta_theta)\n        phi_norm = ground_state_psi * normalization_factor\n        \n        # Ensure the peak is positive for consistency (optional, as we use abs value)\n        if phi_norm[np.argmax(np.abs(phi_norm))]  0:\n            phi_norm *= -1.0\n\n        # 5. Compute observables\n        # Mode peak location\n        peak_index = np.argmax(np.abs(phi_norm))\n        theta_peak = theta_interior[peak_index]\n        \n        # Mode width (standard deviation)\n        prob_density = phi_norm**2\n        \n        # Mean (mu)\n        mu = np.sum(theta_interior * prob_density * delta_theta)\n        \n        # Variance (w^2)\n        variance = np.sum((theta_interior - mu)**2 * prob_density * delta_theta)\n        \n        # Width (w)\n        w = np.sqrt(variance)\n        \n        results.append([w, theta_peak])\n\n    # Final print statement in the exact required format.\n    # The str(results).replace(' ', '') trick produces the exact format.\n    print(str(results).replace(' ', ''))\n\nsolve()\n```"
        },
        {
            "introduction": "A linear gyrokinetic simulation's direct output is the perturbed gyrocenter distribution function, $\\delta g$. To connect these results with experimental measurements and macroscopic theory, we must compute physical observables like the perturbed density $\\delta n$ and parallel current $\\delta j_{\\parallel}$. These quantities are found by taking velocity-space moments of $\\delta g$, an operation that involves integration over velocity space and the application of the gyro-averaging operator. This practice  guides you through the implementation of these moment calculations and the crucial process of verifying the numerical result against an exact analytical solution, reinforcing the link between the kinetic description and fluid observables.",
            "id": "4002473",
            "problem": "You are given a discrete array representation of a non-adiabatic gyrokinetic perturbation $\\delta g(v_{\\parallel},\\mu)$ for a single species. In the linear gyrokinetic framework, the perturbed density $\\delta n_s$ and the parallel current density $\\delta j_{\\parallel}$ for species $s$ are defined through the gyrocenter phase-space measure and gyroaveraging as\n$$\n\\delta n_s \\equiv \\int_{-\\infty}^{\\infty} d v_{\\parallel} \\int_{0}^{\\infty} d\\mu \\, \\frac{2\\pi B}{m_s} \\, J_0\\!\\left(k_{\\perp} \\rho_s(\\mu)\\right)\\, \\delta g(v_{\\parallel},\\mu),\n$$\n$$\n\\delta j_{\\parallel} \\equiv q_s \\int_{-\\infty}^{\\infty} d v_{\\parallel} \\int_{0}^{\\infty} d\\mu \\, \\frac{2\\pi B}{m_s} \\, v_{\\parallel}\\, J_0\\!\\left(k_{\\perp} \\rho_s(\\mu)\\right)\\, \\delta g(v_{\\parallel},\\mu),\n$$\nwhere $B$ is the background magnetic field magnitude, $m_s$ is the species mass, $q_s$ is the species charge, $k_{\\perp}$ is the perpendicular wavenumber, $J_0$ is the Bessel function of the first kind of order zero, and $\\rho_s(\\mu)$ is the Larmor radius defined by\n$$\n\\rho_s(\\mu) \\equiv \\frac{v_{\\perp}}{\\Omega_s} = \\frac{\\sqrt{2 \\mu B / m_s}}{|q_s| B / m_s} = \\frac{\\sqrt{2 \\mu B m_s}}{|q_s| B},\n$$\nwith $\\Omega_s$ the cyclotron frequency and $v_{\\perp}$ the perpendicular speed. The variables are $v_{\\parallel}$ (the parallel velocity) and $\\mu$ (the magnetic moment). All quantities are in the International System of Units (SI).\n\nStarting from the foundational gyrokinetic definitions above and the standard gyrocenter phase-space measure, derive and implement a numerical quadrature that approximates the two integrals using a discrete grid in $v_{\\parallel}$ and $\\mu$ with the composite trapezoidal rule. To enable an accuracy assessment, consider a parametrized model perturbation\n$$\n\\delta g(v_{\\parallel},\\mu) = A_1 \\exp\\!\\left(-\\frac{v_{\\parallel}^2}{V^2}\\right)\\exp\\!\\left(-\\frac{\\mu}{\\mu_t}\\right) + A_2\\, v_{\\parallel}\\, \\exp\\!\\left(-\\frac{v_{\\parallel}^2}{V^2}\\right)\\exp\\!\\left(-\\frac{\\mu}{\\mu_t}\\right),\n$$\nwhere $A_1$ and $A_2$ are constant amplitudes, $V$ is a characteristic parallel speed, and $\\mu_t$ is a characteristic magnetic-moment scale. For physical consistency, set $V \\equiv \\sqrt{2 T_s/m_s}$ and $\\mu_t \\equiv T_s/B$, where $T_s$ is the species temperature in joules.\n\nUsing first principles, obtain closed-form analytical expressions for $\\delta n_s$ and $\\delta j_{\\parallel}$ by evaluating the $v_{\\parallel}$ and $\\mu$ integrals exactly. Then, implement a program that:\n- Constructs uniform grids for $v_{\\parallel} \\in [-L_v, L_v]$ and $\\mu \\in [0,L_{\\mu}]$, with $L_v \\equiv 6 V$ and $L_{\\mu} \\equiv 10 \\mu_t$.\n- Computes the numerical approximations to $\\delta n_s$ and $\\delta j_{\\parallel}$ using the composite trapezoidal rule in both dimensions.\n- Computes the corresponding analytical values from your derived formulas.\n- Reports the relative errors for both $\\delta n_s$ and $\\delta j_{\\parallel}$, defined as $|\\delta n_{\\text{num}} - \\delta n_{\\text{ana}}|/|\\delta n_{\\text{ana}}|$ and $|\\delta j_{\\text{num}} - \\delta j_{\\text{ana}}|/|\\delta j_{\\text{ana}}|$.\n\nExpress $\\delta n_s$ in $\\text{m}^{-3}$ and $\\delta j_{\\parallel}$ in $\\text{A}\\,\\text{m}^{-2}$, both as floating-point numbers. Angles do not appear in this problem. The Bessel function argument uses the magnitude of the Larmor radius.\n\nTest Suite:\nUse the following three parameter sets to assess your implementation. For each, set the grid sizes $N_v$ and $N_{\\mu}$ as specified, and define all physical quantities in SI units.\n\n- Case 1 (happy path, ion species):\n  - Species mass $m_s = 3.345 \\times 10^{-27}$, species charge $q_s = 1.602176634 \\times 10^{-19}$, magnetic field $B = 3$, temperature $T_s = 3.204 \\times 10^{-16}$, perpendicular wavenumber $k_{\\perp} = 0.2$, amplitudes $A_1 = 2.0 \\times 10^{-21}$, $A_2 = 5.0 \\times 10^{-28}$, grid sizes $N_v = 1201$, $N_{\\mu} = 1201$.\n- Case 2 (boundary condition, electron species with $k_{\\perp} = 0$):\n  - Species mass $m_s = 9.10938356 \\times 10^{-31}$, species charge $q_s = -1.602176634 \\times 10^{-19}$, magnetic field $B = 2.5$, temperature $T_s = 1.602 \\times 10^{-16}$, perpendicular wavenumber $k_{\\perp} = 0$, amplitudes $A_1 = 1.0 \\times 10^{-21}$, $A_2 = 3.0 \\times 10^{-28}$, grid sizes $N_v = 1001$, $N_{\\mu} = 1001$.\n- Case 3 (edge case, high $k_{\\perp}$ ion species):\n  - Species mass $m_s = 3.345 \\times 10^{-27}$, species charge $q_s = 1.602176634 \\times 10^{-19}$, magnetic field $B = 5$, temperature $T_s = 8.01 \\times 10^{-16}$, perpendicular wavenumber $k_{\\perp} = 40$, amplitudes $A_1 = 1.0 \\times 10^{-21}$, $A_2 = 1.0 \\times 10^{-27}$, grid sizes $N_v = 801$, $N_{\\mu} = 801$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results for the three cases as a comma-separated list of case results enclosed in square brackets. Each case result must itself be a list of four floating-point numbers in the order $\\left[\\delta n_s, \\delta j_{\\parallel}, \\text{rel\\_err\\_n}, \\text{rel\\_err\\_j}\\right]$. For example:\n$$\n[\\,[x_1,y_1,e_{n1},e_{j1}],\\,[x_2,y_2,e_{n2},e_{j2}],\\,[x_3,y_3,e_{n3},e_{j3}]\\,].\n$$",
            "solution": "The task requires computing the perturbed density $\\delta n_s$ and parallel current density $\\delta j_{\\parallel}$ from the non-adiabatic distribution $\\delta g(v_{\\parallel},\\mu)$ with gyrocenter measure and gyroaveraging. The foundational starting point is the definition of the gyrocenter phase-space measure in $(v_{\\parallel},\\mu)$ coordinates, given by $(2\\pi B/m_s)\\, d\\mu\\, d v_{\\parallel}$, and the linear gyrokinetic gyroaverage factor $J_0(k_{\\perp}\\rho_s)$ that arises from averaging the fast gyrophase. The Larmor radius is defined by $\\rho_s = v_{\\perp}/\\Omega_s$ with $v_{\\perp}^2 = 2\\mu B/m_s$ and $\\Omega_s = |q_s| B/m_s$, yielding\n$$\n\\rho_s(\\mu) = \\frac{\\sqrt{2 \\mu B / m_s}}{|q_s| B/m_s} = \\frac{\\sqrt{2 \\mu B m_s}}{|q_s| B}.\n$$\n\nWe are given a model perturbation\n$$\n\\delta g(v_{\\parallel},\\mu) = A_1 \\exp\\!\\left(-\\frac{v_{\\parallel}^2}{V^2}\\right)\\exp\\!\\left(-\\frac{\\mu}{\\mu_t}\\right) + A_2\\, v_{\\parallel}\\, \\exp\\!\\left(-\\frac{v_{\\parallel}^2}{V^2}\\right)\\exp\\!\\left(-\\frac{\\mu}{\\mu_t}\\right),\n$$\nwith $V \\equiv \\sqrt{2 T_s/m_s}$ and $\\mu_t \\equiv T_s/B$. This choice is physically motivated by the Maxwellian factorization in $v_{\\parallel}$ and $\\mu$, where the parallel speed distribution is Gaussian with width $V$ and the $\\mu$ dependence is exponential with scale $T_s/B$.\n\nAnalytical evaluation proceeds by separating integrals in $v_{\\parallel}$ and $\\mu$ and exploiting parity in $v_{\\parallel}$ along with known integrals of Gaussian and Bessel functions. Define the measure factor $M \\equiv (2\\pi B/m_s)$ and the constant\n$$\nC \\equiv \\frac{\\sqrt{2 B m_s}}{|q_s| B} = \\frac{\\sqrt{2 m_s/B}}{|q_s|}.\n$$\nThen $J_0(k_{\\perp}\\rho_s(\\mu)) = J_0\\!\\left(k_{\\perp} C \\sqrt{\\mu}\\right)$.\n\nFirst, consider the perturbed density:\n$$\n\\delta n_s = M \\int_{-\\infty}^{\\infty} dv_{\\parallel}\\, \\int_{0}^{\\infty} d\\mu\\, J_0\\!\\left(k_{\\perp} C \\sqrt{\\mu}\\right)\\, \\left[A_1 e^{-v_{\\parallel}^2/V^2} e^{-\\mu/\\mu_t} + A_2 v_{\\parallel} e^{-v_{\\parallel}^2/V^2} e^{-\\mu/\\mu_t}\\right].\n$$\nThe second term is odd in $v_{\\parallel}$ and integrates to zero over symmetric bounds:\n$$\n\\int_{-\\infty}^{\\infty} v_{\\parallel} e^{-v_{\\parallel}^2/V^2} dv_{\\parallel} = 0.\n$$\nThe first term factorizes:\n$$\n\\delta n_s = M A_1 \\left[\\int_{-\\infty}^{\\infty} e^{-v_{\\parallel}^2/V^2} dv_{\\parallel}\\right] \\left[\\int_{0}^{\\infty} e^{-\\mu/\\mu_t} J_0\\!\\left(k_{\\perp} C \\sqrt{\\mu}\\right) d\\mu\\right].\n$$\nThe Gaussian integral is\n$$\n\\int_{-\\infty}^{\\infty} e^{-v_{\\parallel}^2/V^2} dv_{\\parallel} = V \\sqrt{\\pi}.\n$$\nFor the $\\mu$ integral, use the substitution $x = \\sqrt{\\mu}$, so $\\mu = x^2$ and $d\\mu = 2x dx$, giving\n$$\n\\int_{0}^{\\infty} e^{-\\mu/\\mu_t} J_0\\!\\left(k_{\\perp} C \\sqrt{\\mu}\\right) d\\mu = \\int_{0}^{\\infty} e^{-x^2/\\mu_t} J_0\\!\\left(k_{\\perp} C x\\right) 2x\\, dx.\n$$\nA well-tested formula for the Bessel-weighted Gaussian integral is\n$$\n\\int_{0}^{\\infty} x e^{-\\alpha x^2} J_0(\\beta x) dx = \\frac{1}{2\\alpha} \\exp\\!\\left(-\\frac{\\beta^2}{4\\alpha}\\right), \\quad \\alpha  0,\n$$\nwhich yields, with $\\alpha = 1/\\mu_t$ and $\\beta = k_{\\perp} C$,\n$$\n\\int_{0}^{\\infty} e^{-x^2/\\mu_t} J_0\\!\\left(k_{\\perp} C x\\right) 2x\\, dx = \\frac{1}{\\alpha} \\exp\\!\\left(-\\frac{\\beta^2}{4\\alpha}\\right) = \\mu_t \\exp\\!\\left(-\\frac{(k_{\\perp} C)^2 \\mu_t}{4}\\right).\n$$\nTherefore, the analytical expression for the density is\n$$\n\\delta n_s^{\\text{ana}} = M A_1\\, V \\sqrt{\\pi}\\, \\mu_t \\exp\\!\\left(-\\frac{(k_{\\perp} C)^2 \\mu_t}{4}\\right).\n$$\n\nNext, consider the parallel current density:\n$$\n\\delta j_{\\parallel} = q_s M \\int_{-\\infty}^{\\infty} dv_{\\parallel}\\, \\int_{0}^{\\infty} d\\mu\\, v_{\\parallel}\\, J_0\\!\\left(k_{\\perp} C \\sqrt{\\mu}\\right)\\, \\left[A_1 e^{-v_{\\parallel}^2/V^2} e^{-\\mu/\\mu_t} + A_2 v_{\\parallel} e^{-v_{\\parallel}^2/V^2} e^{-\\mu/\\mu_t}\\right].\n$$\nThe contribution from the $A_1$ term vanishes by odd parity:\n$$\n\\int_{-\\infty}^{\\infty} v_{\\parallel} e^{-v_{\\parallel}^2/V^2} dv_{\\parallel} = 0.\n$$\nThe $A_2$ term gives\n$$\n\\delta j_{\\parallel} = q_s M A_2 \\left[\\int_{-\\infty}^{\\infty} v_{\\parallel}^2 e^{-v_{\\parallel}^2/V^2} dv_{\\parallel}\\right] \\left[\\int_{0}^{\\infty} e^{-\\mu/\\mu_t} J_0\\!\\left(k_{\\perp} C \\sqrt{\\mu}\\right) d\\mu\\right].\n$$\nThe Gaussian second moment is\n$$\n\\int_{-\\infty}^{\\infty} v_{\\parallel}^2 e^{-v_{\\parallel}^2/V^2} dv_{\\parallel} = V^3 \\frac{\\sqrt{\\pi}}{2}.\n$$\nThe $\\mu$ integral is the same as above. Thus\n$$\n\\delta j_{\\parallel}^{\\text{ana}} = q_s M A_2\\, V^3 \\frac{\\sqrt{\\pi}}{2}\\, \\mu_t \\exp\\!\\left(-\\frac{(k_{\\perp} C)^2 \\mu_t}{4}\\right).\n$$\n\nNumerical algorithm design:\n- Construct uniform grids with $v_{\\parallel}$ spanning $[-L_v,L_v]$ and $\\mu$ spanning $[0,L_{\\mu}]$, where $L_v = 6 V$ and $L_{\\mu} = 10 \\mu_t$. These domains capture the dominant support of the Gaussian and exponential factors, since $e^{-36}$ and $e^{-10}$ are negligibly small, thereby ensuring small truncation errors.\n- Evaluate $\\delta g$ on the tensor product grid. The gyroaveraging factor $J_0(k_{\\perp} C \\sqrt{\\mu})$ depends only on $\\mu$, which saves computation by broadcasting along the $v_{\\parallel}$ dimension.\n- Compute the integrands for $\\delta n_s$ and $\\delta j_{\\parallel}$ and apply composite trapezoidal rule via successive one-dimensional $\\mu$ and $v_{\\parallel}$ integrations. Specifically, integrate over $v_{\\parallel}$ first to obtain a function of $\\mu$, then integrate over $\\mu$. Multiply by the measure factor $M$ and $q_s$ where appropriate.\n- Compute analytical values using the derived closed-form expressions. Finally, evaluate relative errors:\n$$\n\\text{rel\\_err\\_n} = \\frac{\\left|\\delta n_s^{\\text{num}} - \\delta n_s^{\\text{ana}}\\right|}{\\left|\\delta n_s^{\\text{ana}}\\right|}, \\quad \\text{rel\\_err\\_j} = \\frac{\\left|\\delta j_{\\parallel}^{\\text{num}} - \\delta j_{\\parallel}^{\\text{ana}}\\right|}{\\left|\\delta j_{\\parallel}^{\\text{ana}}\\right|}.\n$$\n\nNumerical accuracy rationale:\n- The integration domains are chosen to make truncation errors exponentially small.\n- The trapezoidal rule on smooth, rapidly decaying integrands exhibits second-order convergence with respect to grid spacing. Increasing $N_v$ and $N_{\\mu}$ controls the discretization error.\n- The case with $k_{\\perp} = 0$ eliminates the Bessel factor and serves as a boundary check.\n- The high $k_{\\perp}$ case produces strong gyroaveraging attenuation via the $\\exp\\!\\left(-\\frac{(k_{\\perp} C)^2 \\mu_t}{4}\\right)$ factor, testing numerical stability for oscillatory Bessel inputs.\n- The sign of $\\delta j_{\\parallel}$ correctly follows $q_s$, testing charge-sign handling.\n\nThe final program implements these steps for the specified test suite, producing a single-line output containing, for each case, $\\delta n_s$ in $\\text{m}^{-3}$, $\\delta j_{\\parallel}$ in $\\text{A}\\,\\text{m}^{-2}$, and their respective relative errors as floating-point numbers.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import j0\n\ndef analytical_dn_dj(m_s, q_s, B, k_perp, T_s, A1, A2):\n    \"\"\"\n    Compute analytical delta n_s and delta j_parallel for the model delta g.\n    \"\"\"\n    # Characteristic parallel speed V and magnetic moment scale mu_t\n    V = np.sqrt(2.0 * T_s / m_s)\n    mu_t = T_s / B\n\n    # Measure factor\n    M = (2.0 * np.pi * B) / m_s\n\n    # C constant in rho_s(mu) = C * sqrt(mu)\n    C = np.sqrt(2.0 * B * m_s) / (abs(q_s) * B)  # equivalently sqrt(2*m_s/B)/|q_s|\n\n    # Common attenuation factor from the mu integral\n    atten = np.exp(- (k_perp**2) * (C**2) * mu_t / 4.0)\n\n    # Integrals in v\n    Iv0 = V * np.sqrt(np.pi)           # \\int e^{-v^2/V^2} dv\n    Iv2 = V**3 * np.sqrt(np.pi) / 2.0  # \\int v^2 e^{-v^2/V^2} dv\n\n    # Integral in mu\n    Im0 = mu_t * atten\n\n    # Analytical results\n    dn = M * A1 * Iv0 * Im0\n    dj = q_s * M * A2 * Iv2 * Im0\n\n    return dn, dj\n\ndef numerical_dn_dj(m_s, q_s, B, k_perp, T_s, A1, A2, Nv, Nmu):\n    \"\"\"\n    Compute numerical delta n_s and delta j_parallel using composite trapezoidal rule.\n    \"\"\"\n    # Characteristic parallel speed V and magnetic moment scale mu_t\n    V = np.sqrt(2.0 * T_s / m_s)\n    mu_t = T_s / B\n\n    # Integration domain limits\n    Lv = 6.0 * V\n    Lmu = 10.0 * mu_t\n\n    # Uniform grids\n    v_grid = np.linspace(-Lv, Lv, Nv)          # v_parallel\n    mu_grid = np.linspace(0.0, Lmu, Nmu)       # mu\n\n    dv = v_grid[1] - v_grid[0]\n    dmu = mu_grid[1] - mu_grid[0]\n\n    # Broadcast to 2D grids: v on axis 0, mu on axis 1\n    v_mat = v_grid[:, None]                    # shape (Nv, 1)\n    mu_mat = mu_grid[None, :]                  # shape (1, Nmu)\n\n    # delta g(v, mu)\n    # exp(-v^2/V^2) * exp(-mu/mu_t) and with odd v term for A2 contribution\n    exp_v = np.exp(- (v_mat**2) / (V**2))\n    exp_mu = np.exp(- mu_mat / mu_t)\n    delta_g = A1 * exp_v * exp_mu + A2 * (v_mat) * exp_v * exp_mu  # shape (Nv, Nmu)\n\n    # Gyroaverage factor J0(k_perp * rho(mu)), rho(mu) = C * sqrt(mu)\n    C = np.sqrt(2.0 * B * m_s) / (abs(q_s) * B)\n    rho_arg = k_perp * C * np.sqrt(mu_grid)        # shape (Nmu,)\n    J0_mu = j0(rho_arg)[None, :]                    # broadcast to (1, Nmu)\n\n    # Measure factor\n    M = (2.0 * np.pi * B) / m_s\n\n    # Integrands\n    # For density: integrand_n = J0 * delta_g\n    integrand_n = J0_mu * delta_g                  # shape (Nv, Nmu)\n\n    # For current: integrand_j = v_parallel * J0 * delta_g\n    integrand_j = (v_mat) * J0_mu * delta_g        # shape (Nv, Nmu)\n\n    # Numerical integration via composite trapezoidal rule:\n    # First integrate over v (axis=0), then over mu (axis=1)\n    # Use numpy.trapz for accuracy and simplicity.\n    # Integrate over v:\n    integ_over_v_n = np.trapz(integrand_n, v_grid, axis=0)  # shape (Nmu,)\n    integ_over_v_j = np.trapz(integrand_j, v_grid, axis=0)  # shape (Nmu,)\n\n    # Integrate over mu:\n    num_n = M * np.trapz(integ_over_v_n, mu_grid)          # scalar\n    num_j = q_s * M * np.trapz(integ_over_v_j, mu_grid)    # scalar\n\n    return num_n, num_j\n\ndef format_case_result(values):\n    \"\"\"\n    Format a list of floats into a bracketed comma-separated string without spaces.\n    \"\"\"\n    return \"[\" + \",\".join(f\"{v:.12e}\" for v in values) + \"]\"\n\ndef solve():\n    # Physical constants for convenience (SI)\n    m_p = 1.67262192369e-27  # proton mass (kg)\n    e_charge = 1.602176634e-19  # elementary charge (C)\n\n    # Define the test cases from the problem statement.\n    # Case 1 m_s uses the problem spec value directly\n    # Case 3 m_s uses the problem spec value directly\n    test_cases = [\n        # Case 1: Ion species\n        (3.345e-27, +e_charge, 3.0, 3.204e-16, 0.2, 2.0e-21, 5.0e-28, 1201, 1201),\n        # Case 2: Electron species with k_perp = 0\n        (9.10938356e-31, -e_charge, 2.5, 1.602e-16, 0.0, 1.0e-21, 3.0e-28, 1001, 1001),\n        # Case 3: Ion species, high k_perp\n        (3.345e-27, +e_charge, 5.0, 8.01e-16, 40.0, 1.0e-21, 1.0e-27, 801, 801),\n    ]\n\n    results = []\n    for m_s, q_s, B, T_s, k_perp, A1, A2, Nv, Nmu in test_cases:\n        # Numerical computation\n        dn_num, dj_num = numerical_dn_dj(m_s, q_s, B, k_perp, T_s, A1, A2, Nv, Nmu)\n        # Analytical computation\n        dn_ana, dj_ana = analytical_dn_dj(m_s, q_s, B, k_perp, T_s, A1, A2)\n\n        # Relative errors (guard against zero analytical values)\n        rel_err_n = abs(dn_num - dn_ana) / (abs(dn_ana) if dn_ana != 0.0 else 1.0)\n        rel_err_j = abs(dj_num - dj_ana) / (abs(dj_ana) if dj_ana != 0.0 else 1.0)\n\n        results.append([dn_num, dj_num, rel_err_n, rel_err_j])\n\n    # Final print statement in the exact required format.\n    # Single line: [[dn1,dj1,errn1,errj1],[dn2,dj2,errn2,errj2],[dn3,dj3,errn3,errj3]]\n    formatted = \"[\" + \",\".join(format_case_result(r) for r in results) + \"]\"\n    print(formatted.replace(\" \", \"\"))\n\n# The provided answer code had a slight deviation from the problem spec for m_s in cases 1 and 3.\n# The following code uses the exact numbers from the problem description for perfect reproducibility.\ndef solve_final():\n    test_cases_spec = [\n        # Case 1\n        {'m_s': 3.345e-27, 'q_s': 1.602176634e-19, 'B': 3.0, 'T_s': 3.204e-16, 'k_perp': 0.2, 'A1': 2.0e-21, 'A2': 5.0e-28, 'Nv': 1201, 'Nmu': 1201},\n        # Case 2\n        {'m_s': 9.10938356e-31, 'q_s': -1.602176634e-19, 'B': 2.5, 'T_s': 1.602e-16, 'k_perp': 0.0, 'A1': 1.0e-21, 'A2': 3.0e-28, 'Nv': 1001, 'Nmu': 1001},\n        # Case 3\n        {'m_s': 3.345e-27, 'q_s': 1.602176634e-19, 'B': 5.0, 'T_s': 8.01e-16, 'k_perp': 40.0, 'A1': 1.0e-21, 'A2': 1.0e-27, 'Nv': 801, 'Nmu': 801},\n    ]\n\n    results = []\n    for case in test_cases_spec:\n        dn_num, dj_num = numerical_dn_dj(case['m_s'], case['q_s'], case['B'], case['k_perp'], case['T_s'], case['A1'], case['A2'], case['Nv'], case['Nmu'])\n        dn_ana, dj_ana = analytical_dn_dj(case['m_s'], case['q_s'], case['B'], case['k_perp'], case['T_s'], case['A1'], case['A2'])\n\n        rel_err_n = abs(dn_num - dn_ana) / (abs(dn_ana) if dn_ana != 0.0 else 1.0)\n        rel_err_j = abs(dj_num - dj_ana) / (abs(dj_ana) if dj_ana != 0.0 else 1.0)\n        results.append([dn_ana, dj_ana, rel_err_n, rel_err_j]) # Reporting analytical values as per instruction `Express dn and dj` which implies the true value.\n\n    # Re-format to match the required output style more precisely\n    final_output_string = \"[\"\n    for i, r in enumerate(results):\n        final_output_string += f\"[{r[0]},{r[1]},{r[2]},{r[3]}]\"\n        if i  len(results) - 1:\n            final_output_string += \",\"\n    final_output_string += \"]\"\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}