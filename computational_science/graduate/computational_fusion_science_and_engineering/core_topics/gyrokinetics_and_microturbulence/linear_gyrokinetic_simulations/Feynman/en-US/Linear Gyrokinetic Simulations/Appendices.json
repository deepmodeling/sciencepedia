{
    "hands_on_practices": [
        {
            "introduction": "The full gyrokinetic system is complex, but its behavior can often be understood through simplified models. In the ballooning representation, the structure of instabilities along the magnetic field line can be described by a one-dimensional Schrödinger-like eigenvalue problem . This exercise provides hands-on practice in solving this equation numerically, offering insight into how the 'potential well' formed by magnetic geometry and plasma profiles determines the eigenfunction's shape and the instability's character. By computing metrics like the mode's peak location and width, you will connect the mathematical solution to observable physical properties.",
            "id": "4002472",
            "problem": "You are asked to connect the linear Gyrokinetic (GK) description of microinstabilities in a magnetized plasma with a one-dimensional self-adjoint eigenproblem along a magnetic field line in ballooning representation, and then compute observable mode structure metrics. Starting from the linear GK equation in ballooning representation for electrostatic fluctuations and quasineutrality under standard drift-kinetic and strong-ballooning orderings, you should argue that the along-field-line structure of the electrostatic potential perturbation, denoted $\\delta\\phi(\\theta)$, satisfies a second-order self-adjoint ordinary differential eigenvalue problem of Sturm–Liouville type in a dimensionless ballooning angle $\\theta$ (in radians). Conclude that in a properly chosen normalization, the governing equation is of Schrödinger type,\n$$\n-\\frac{d^2}{d\\theta^2}\\,\\delta\\phi(\\theta) + V(\\theta)\\,\\delta\\phi(\\theta) = \\lambda\\,\\delta\\phi(\\theta),\n$$\nwhere $V(\\theta)$ is an effective potential that encapsulates curvature drive, magnetic shear, and finite Larmor radius effects, and $\\lambda$ is a real eigenvalue associated with the fluctuation frequency parameter in this simplified model. Physical bound-state-like modes correspond to square-integrable solutions with $\\delta\\phi(\\theta)\\to 0$ as $|\\theta|\\to\\infty$.\n\nYour task is to implement a numerical solver for the ground-state eigenfunction $\\delta\\phi(\\theta)$ on a finite interval $\\theta\\in[-\\theta_{\\max},\\theta_{\\max}]$ using a uniform grid and homogeneous Dirichlet boundary conditions $\\delta\\phi(-\\theta_{\\max})=\\delta\\phi(\\theta_{\\max})=0$ as an approximation to the decay at infinity. Use a second-order centered finite-difference discretization for the second derivative operator. The eigenproblem is then solved to obtain the smallest eigenvalue and its eigenfunction. Normalize the discrete eigenfunction such that the discrete approximation to the $L^2$ norm equals one:\n$$\n\\int_{-\\theta_{\\max}}^{\\theta_{\\max}} |\\delta\\phi(\\theta)|^2\\,d\\theta \\approx \\sum_{i} |\\delta\\phi_i|^2\\,\\Delta\\theta = 1,\n$$\nwhere $\\Delta\\theta$ is the grid spacing and $\\delta\\phi_i=\\delta\\phi(\\theta_i)$ are the interior grid values.\n\nFor each test case below, compute:\n- The mode peak location $\\theta_{\\text{peak}}$ in radians, defined as the grid point $\\theta_i$ where $|\\delta\\phi_i|$ attains its maximum value.\n- The mode width $w$ in radians, defined as the standard deviation of the probability density proportional to $|\\delta\\phi(\\theta)|^2$:\n$$\n\\mu = \\frac{\\int \\theta\\,|\\delta\\phi(\\theta)|^2\\,d\\theta}{\\int |\\delta\\phi(\\theta)|^2\\,d\\theta},\\quad\nw = \\left(\\frac{\\int (\\theta-\\mu)^2\\,|\\delta\\phi(\\theta)|^2\\,d\\theta}{\\int |\\delta\\phi(\\theta)|^2\\,d\\theta}\\right)^{1/2}.\n$$\nIn discrete form, use the uniform-grid Riemann sum with spacing $\\Delta\\theta$ over the interior points. Report both $\\theta_{\\text{peak}}$ and $w$ in radians.\n\nFor scientific realism and mathematical well-posedness, use a confining potential of the form\n$$\nV(\\theta) = a_0 + a_2\\,\\theta^2 + a_4\\,\\theta^4 - V_g\\,\\exp\\!\\left(-\\frac{(\\theta-\\theta_c)^2}{2\\,\\sigma^2}\\right) + s\\,\\theta,\n$$\nwhere $a_4>0$ ensures $V(\\theta)\\to+\\infty$ as $|\\theta|\\to\\infty$. All parameters are dimensionless, and $\\theta$ is an angle in radians.\n\nImplement a program that, for each test case, assembles the tridiagonal matrix corresponding to the finite-difference discretization of the operator $-\\frac{d^2}{d\\theta^2}+V(\\theta)$ on the interior grid, solves for the smallest eigenpair $\\{\\lambda,\\delta\\phi\\}$, normalizes $\\delta\\phi$ to unit discrete $L^2$ norm, and outputs the pair $[w,\\theta_{\\text{peak}}]$.\n\nUse the following test suite of three cases that probe symmetry, asymmetry, and near-threshold broadening:\n\n- Case $1$ (symmetric well, moderate localization):\n  - Domain half-width $\\theta_{\\max}=20$ (radians), grid size $N=1201$ points uniformly spaced on $[-\\theta_{\\max},\\theta_{\\max}]$.\n  - Parameters: $a_0=0.2$, $a_2=0.01$, $a_4=10^{-4}$, $V_g=1.0$, $\\sigma=2.0$, $\\theta_c=0.0$, $s=0.0$.\n\n- Case $2$ (asymmetric well, shifted peak):\n  - Domain half-width $\\theta_{\\max}=20$ (radians), grid size $N=1201$.\n  - Parameters: $a_0=0.2$, $a_2=0.01$, $a_4=10^{-4}$, $V_g=1.0$, $\\sigma=2.0$, $\\theta_c=2.0$, $s=0.02$.\n\n- Case $3$ (broad, shallow well):\n  - Domain half-width $\\theta_{\\max}=30$ (radians), grid size $N=1501$.\n  - Parameters: $a_0=0.1$, $a_2=0.002$, $a_4=5\\times10^{-5}$, $V_g=0.3$, $\\sigma=5.0$, $\\theta_c=0.0$, $s=0.0$.\n\nYour program must produce a single line of output containing the results for the three cases as a comma-separated list enclosed in square brackets, where each case result is the two-element list $[w,\\theta_{\\text{peak}}]$ with both entries in radians. For example, the output format must be\n\"[ [w_case1,theta_peak_case1], [w_case2,theta_peak_case2], [w_case3,theta_peak_case3] ]\"\nbut without spaces, that is:\n\"[[w1,tp1],[w2,tp2],[w3,tp3]]\"\nUse floating-point numbers for all reported values. Angles must be in radians. No other text should be printed.",
            "solution": "The problem presented is a valid and well-posed boundary-value problem rooted in computational plasma physics, specifically in the study of microinstabilities using the gyrokinetic model. The central task is to solve a one-dimensional, time-independent Schrödinger-like equation, which describes the structure of an electrostatic perturbation along a magnetic field line in ballooning representation. The equation is given as:\n$$\n-\\frac{d^2}{d\\theta^2}\\,\\delta\\phi(\\theta) + V(\\theta)\\,\\delta\\phi(\\theta) = \\lambda\\,\\delta\\phi(\\theta)\n$$\nThis is a canonical Sturm-Liouville eigenvalue problem. The operator $\\mathcal{L} = -\\frac{d^2}{d\\theta^2} + V(\\theta)$ is self-adjoint on the space of square-integrable functions with the given boundary conditions. The potential $V(\\theta)$ is specified as:\n$$\nV(\\theta) = a_0 + a_2\\,\\theta^2 + a_4\\,\\theta^4 - V_g\\,\\exp\\!\\left(-\\frac{(\\theta-\\theta_c)^2}{2\\,\\sigma^2}\\right) + s\\,\\theta\n$$\nThe condition $a_4>0$ ensures that $V(\\theta) \\to \\infty$ as $|\\theta| \\to \\infty$, which guarantees a discrete spectrum of real eigenvalues bounded from below, and eigenfunctions that are square-integrable, corresponding to physically relevant bound states. The problem requires finding the ground state, which is the eigenfunction $\\delta\\phi(\\theta)$ corresponding to the lowest eigenvalue $\\lambda$. The infinite domain $\\theta \\in (-\\infty, \\infty)$ is approximated by a finite domain $\\theta \\in [-\\theta_{\\max}, \\theta_{\\max}]$ with homogeneous Dirichlet boundary conditions, $\\delta\\phi(-\\theta_{\\max}) = \\delta\\phi(\\theta_{\\max}) = 0$. This approximation is valid for low-lying, well-localized states, provided $\\theta_{\\max}$ is sufficiently large.\n\nThe solution proceeds by first discretizing the continuous differential equation into a matrix eigenvalue problem using a second-order centered finite difference scheme. A uniform grid is established over the domain $[-\\theta_{\\max}, \\theta_{\\max}]$ with $N$ points $\\theta_j = -\\theta_{\\max} + j\\Delta\\theta$ for $j=0, 1, \\dots, N-1$, where the grid spacing is $\\Delta\\theta = 2\\theta_{\\max}/(N-1)$. The solution is sought on the $N_{int}=N-2$ interior grid points, indexed $i=1, \\dots, N-2$. The boundary conditions are imposed as $\\delta\\phi_0 = 0$ and $\\delta\\phi_{N-1} = 0$.\n\nAt an interior grid point $\\theta_i$, the second derivative is approximated as:\n$$\n\\frac{d^2\\delta\\phi}{d\\theta^2}\\bigg|_{\\theta_i} \\approx \\frac{\\delta\\phi_{i+1} - 2\\delta\\phi_i + \\delta\\phi_{i-1}}{(\\Delta\\theta)^2}\n$$\nSubstituting this into the Schrödinger equation yields a system of linear algebraic equations for the vector of discrete eigenfunction values $\\vec{\\phi} = (\\delta\\phi_1, \\delta\\phi_2, \\dots, \\delta\\phi_{N-2})^T$:\n$$\n-\\frac{\\delta\\phi_{i+1} - 2\\delta\\phi_i + \\delta\\phi_{i-1}}{(\\Delta\\theta)^2} + V(\\theta_i)\\delta\\phi_i = \\lambda \\delta\\phi_i\n$$\nThis can be cast into the matrix eigenvalue problem $H\\vec{\\phi} = \\lambda\\vec{\\phi}$, where $H$ is a real, symmetric, tridiagonal matrix of size $(N-2) \\times (N-2)$. The elements of $H$ are:\n$$\nH_{ij} = \\begin{cases}\n    \\frac{2}{(\\Delta\\theta)^2} + V(\\theta_i) & \\text{if } i=j \\\\\n    -\\frac{1}{(\\Delta\\theta)^2} & \\text{if } |i-j|=1 \\\\\n    0 & \\text{otherwise}\n\\end{cases}\n$$\nThis matrix eigenvalue problem is solved numerically to obtain the set of eigenvalues and corresponding eigenvectors. We select the eigenvector associated with the smallest eigenvalue, which represents the ground state.\n\nThe resulting eigenvector, let us call it $\\vec{\\psi}$, is typically normalized by numerical libraries to have a unit Euclidean norm, i.e., $\\sum_i |\\psi_i|^2=1$. The problem requires normalization according to the discrete $L^2$ norm: $\\int |\\delta\\phi|^2 d\\theta \\approx \\sum_i |\\delta\\phi_i|^2 \\Delta\\theta = 1$. To achieve this, we must rescale the eigenvector. Let the correctly normalized eigenfunction be $\\delta\\phi_i = C \\psi_i$. Then,\n$$\n\\sum_{i=1}^{N-2} |C \\psi_i|^2 \\Delta\\theta = C^2 \\Delta\\theta \\sum_{i=1}^{N-2} |\\psi_i|^2 = C^2 \\Delta\\theta \\cdot 1 = 1\n$$\nThis implies the scaling factor is $C = 1/\\sqrt{\\Delta\\theta}$. The normalized eigenfunction is thus $\\delta\\phi_i = \\psi_i / \\sqrt{\\Delta\\theta}$.\n\nWith the normalized ground-state eigenfunction $\\delta\\phi_i$ computed on the interior grid, we calculate the required observables.\nThe mode peak location, $\\theta_{\\text{peak}}$, is the grid point $\\theta_i$ where $|\\delta\\phi_i|$ is maximum.\n$$\n\\theta_{\\text{peak}} = \\theta_{i_{\\text{peak}}} \\quad \\text{where} \\quad i_{\\text{peak}} = \\underset{i \\in \\{1,\\dots,N-2\\}}{\\text{argmax}} |\\delta\\phi_i|\n$$\nThe mode width, $w$, is the standard deviation of the probability density function $P(\\theta) \\propto |\\delta\\phi(\\theta)|^2$. Given our normalization, the discrete probability density is $p_i = |\\delta\\phi_i|^2 \\Delta\\theta$, and $\\sum_i p_i = 1$. The discrete mean $\\mu$ and width $w$ are calculated as:\n$$\n\\mu = \\sum_{i=1}^{N-2} \\theta_i |\\delta\\phi_i|^2 \\Delta\\theta\n$$\n$$\nw = \\left( \\sum_{i=1}^{N-2} (\\theta_i - \\mu)^2 |\\delta\\phi_i|^2 \\Delta\\theta \\right)^{1/2}\n$$\nThe implementation will use `scipy.linalg.eigh_tridiagonal` for its efficiency in solving the specific eigenvalue problem for a real symmetric tridiagonal matrix.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh_tridiagonal\n\ndef solve():\n    \"\"\"\n    Solves the 1D Schrödinger equation for three test cases from gyrokinetic theory\n    and computes mode structure metrics.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: symmetric well, moderate localization\n        {\n            \"theta_max\": 20.0, \"N\": 1201,\n            \"params\": {\"a0\": 0.2, \"a2\": 0.01, \"a4\": 1e-4, \"Vg\": 1.0, \"sigma\": 2.0, \"thetac\": 0.0, \"s\": 0.0}\n        },\n        # Case 2: asymmetric well, shifted peak\n        {\n            \"theta_max\": 20.0, \"N\": 1201,\n            \"params\": {\"a0\": 0.2, \"a2\": 0.01, \"a4\": 1e-4, \"Vg\": 1.0, \"sigma\": 2.0, \"thetac\": 2.0, \"s\": 0.02}\n        },\n        # Case 3: broad, shallow well\n        {\n            \"theta_max\": 30.0, \"N\": 1501,\n            \"params\": {\"a0\": 0.1, \"a2\": 0.002, \"a4\": 5e-5, \"Vg\": 0.3, \"sigma\": 5.0, \"thetac\": 0.0, \"s\": 0.0}\n        }\n    ]\n\n    results = []\n    \n    def potential_v(theta, p):\n        \"\"\"\n        Calculates the potential V(theta) for a given set of parameters.\n        \"\"\"\n        return p[\"a0\"] + p[\"a2\"] * theta**2 + p[\"a4\"] * theta**4 \\\n               - p[\"Vg\"] * np.exp(-(theta - p[\"thetac\"])**2 / (2 * p[\"sigma\"]**2)) \\\n               + p[\"s\"] * theta\n\n    for case in test_cases:\n        # Unpack case parameters\n        theta_max = case[\"theta_max\"]\n        N = case[\"N\"]\n        params = case[\"params\"]\n\n        # 1. Set up the grid\n        theta_full = np.linspace(-theta_max, theta_max, N)\n        delta_theta = theta_full[1] - theta_full[0]\n        \n        # We solve on the interior grid points\n        theta_interior = theta_full[1:-1]\n        N_interior = N - 2\n        \n        # 2. Construct the Hamiltonian matrix\n        V_values = potential_v(theta_interior, params)\n        \n        # Main diagonal of the Hamiltonian H\n        diag = 2.0 / (delta_theta**2) + V_values\n        \n        # Off-diagonal of H\n        off_diag = -1.0 / (delta_theta**2) * np.ones(N_interior - 1)\n        \n        # 3. Solve the eigenvalue problem\n        # eigh_tridiagonal returns eigenvalues in ascending order and corresponding eigenvectors\n        eigenvalues, eigenvectors = eigh_tridiagonal(diag, off_diag)\n        \n        # The ground state is the first eigenvector (corresponding to the smallest eigenvalue)\n        ground_state_psi = eigenvectors[:, 0]\n        \n        # 4. Normalize the eigenfunction\n        # The solver returns eigenvectors with L2 norm (sum of squares) = 1.\n        # We need to normalize to the continuous L2 norm integral approximation, sum(phi^2 * d_theta) = 1.\n        # phi = C * psi, sum((C*psi)^2 * d_theta) = 1 => C^2 * sum(psi^2) * d_theta = 1\n        # C^2 * 1 * d_theta = 1 => C = 1 / sqrt(d_theta)\n        normalization_factor = 1.0 / np.sqrt(delta_theta)\n        phi_norm = ground_state_psi * normalization_factor\n        \n        # Ensure the peak is positive for consistency (optional, as we use abs value)\n        if phi_norm[np.argmax(np.abs(phi_norm))] < 0:\n            phi_norm *= -1.0\n\n        # 5. Compute observables\n        # Mode peak location\n        peak_index = np.argmax(np.abs(phi_norm))\n        theta_peak = theta_interior[peak_index]\n        \n        # Mode width (standard deviation)\n        prob_density = phi_norm**2\n        \n        # Mean (mu)\n        mu = np.sum(theta_interior * prob_density * delta_theta)\n        \n        # Variance (w^2)\n        variance = np.sum((theta_interior - mu)**2 * prob_density * delta_theta)\n        \n        # Width (w)\n        w = np.sqrt(variance)\n        \n        results.append([w, theta_peak])\n\n    # Final print statement in the exact required format.\n    # The str(results).replace(' ', '') trick produces the exact format.\n    print(str(results).replace(' ', ''))\n\nsolve()\n```"
        },
        {
            "introduction": "The accuracy of a gyrokinetic simulation depends critically on the numerical methods used to discretize the governing equations. A fundamental component is the parallel streaming term, which describes how particles move along magnetic field lines. This practice  delves into the concept of numerical dispersion, where the choice of a finite difference or spectral scheme can alter the propagation speed of waves on the computational grid. By comparing the numerical dispersion relation of different schemes to the exact analytical one, you will develop a crucial skill in evaluating the fidelity of core numerical algorithms.",
            "id": "4002409",
            "problem": "You are to evaluate numerical dispersion of parallel plane waves in the linear gyrokinetic streaming operator by comparing the discrete eigenvalues obtained on a periodic grid to the analytic continuous relation. Begin from the linear streaming term in the drift-kinetic or gyrokinetic equation along the magnetic field line, which can be written as $\\partial_t g + v_{\\parallel} \\partial_l g = 0$, where $g$ is a scalar field, $l$ is the coordinate along the field line, and $v_{\\parallel}$ is a constant parallel velocity. For a plane wave ansatz $g \\propto \\exp(i k_{\\parallel} l - i \\omega t)$, the analytic dispersion relation is $\\omega = k_{\\parallel} v_{\\parallel}$. On a uniform periodic spatial grid of length $L$ with $N$ points and spacing $\\Delta = L/N$, the spatial derivative is discretized by a linear operator that depends on the chosen scheme. The discrete streaming operator is the matrix $L_d = - v_{\\parallel} D$, where $D$ is the discrete derivative operator associated with the chosen scheme and periodic boundaries. Because $D$ is circulant, its eigenvectors are discrete Fourier modes and its eigenvalues can be expressed by a scheme-dependent modified wavenumber. The discrete eigenvalues of $L_d$ are then compared to the analytic eigenvalues implied by the continuous dispersion relation.\n\nYour tasks are:\n- From fundamental principles, explain why for the continuous streaming operator the dispersion relation is $\\omega = k_{\\parallel} v_{\\parallel}$, and why for a periodic uniform grid the discrete derivative operator is circulant with discrete Fourier modes as eigenvectors.\n- For the following derivative schemes, construct the discrete eigenvalues of the streaming operator by evaluating the eigenvalues of the discrete derivative operator at the discrete Fourier modes:\n  - Second-order centered finite difference on the periodic grid.\n  - Fourth-order centered finite difference on the periodic grid.\n  - Spectral differentiation using the discrete Fourier transform (Fourier collocation) on the periodic grid.\n- For each discrete scheme, define the numerical frequency $\\omega_{\\text{num}}(k)$ from the corresponding discrete streaming operator eigenvalue and compare it to the analytic frequency $\\omega_{\\text{exact}}(k) = v_{\\parallel} k$. Define the per-mode relative dispersion error as $E(k) = |\\omega_{\\text{num}}(k) - \\omega_{\\text{exact}}(k)| / |\\omega_{\\text{exact}}(k)|$.\n- On a grid with $N$ points, the discrete Fourier wavenumbers are $k_m = 2\\pi m / L$ with $m \\in \\{0,1,\\dots,N-1\\}$ mapped to signed integers using the standard discrete Fourier transform ordering. The discrete modes include $k=0$ and, when $N$ is even, a Nyquist mode with $|k| \\Delta = \\pi$. For the purpose of computing relative error, exclude the $k=0$ mode (division by zero in the relative error) and exclude the Nyquist mode (where some centered schemes give a zero derivative and Fourier collocation has an ambiguity). Use the angle unit radians for all trigonometric evaluations.\n- For each test case below, compute and report the maximum relative dispersion error over the set of included discrete modes, that is, $\\max_{k \\neq 0,\\, |k|\\Delta \\neq \\pi} E(k)$.\n\nImplement a program that performs these computations for the following test suite of parameter sets:\n- Case A: scheme second-order centered, $N = 64$, $L = 2\\pi$, $v_{\\parallel} = 1.0$.\n- Case B: scheme fourth-order centered, $N = 64$, $L = 2\\pi$, $v_{\\parallel} = 1.0$.\n- Case C: scheme spectral (discrete Fourier transform collocation), $N = 64$, $L = 2\\pi$, $v_{\\parallel} = 1.0$.\n- Case D: scheme second-order centered, $N = 16$, $L = 2\\pi$, $v_{\\parallel} = 3.0$.\n- Case E: scheme fourth-order centered, $N = 32$, $L = 10.0$, $v_{\\parallel} = 0.7$.\n\nYour program must:\n- Construct the discrete Fourier wavenumber array $k$ for each case using the standard discrete Fourier transform ordering on a domain of length $L$ and spacing $\\Delta = L/N$.\n- For each scheme, evaluate the discrete derivative operator eigenvalues at the modes $k$ to obtain the scheme’s modified wavenumber and hence the discrete streaming operator eigenvalues. Then compute $\\omega_{\\text{num}}(k)$ and the relative errors $E(k)$.\n- Exclude $k=0$ and any mode with $|k|\\Delta = \\pi$ from the error set.\n- Compute the maximum $E(k)$ over the remaining modes.\n- Produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $\\left[\\text{Case A}, \\text{Case B}, \\text{Case C}, \\text{Case D}, \\text{Case E}\\right]$. Express each result as a decimal number rounded to $10$ decimal places, with no units.\n\nAll numerical quantities and calculations are to be performed in pure numbers without physical units in the final output. The single output line format must be exactly: $[\\text{result\\_A},\\text{result\\_B},\\text{result\\_C},\\text{result\\_D},\\text{result\\_E}]$.",
            "solution": "The problem requires an analysis of the numerical dispersion introduced by discretizing the linear streaming operator $\\partial_t g + v_{\\parallel} \\partial_l g = 0$. We must first validate the problem statement and, if valid, provide a detailed derivation of the numerical dispersion relations for several common numerical schemes, followed by a computational implementation to quantify the dispersion error for specific test cases.\n\nThe problem is scientifically valid, well-posed, and self-contained. It is grounded in the fundamental principles of partial differential equations and their numerical solution, a core topic in computational science. The provided data and conditions are complete and consistent, allowing for a unique and meaningful solution. We may therefore proceed with the derivation and solution.\n\n**1. Analytic Dispersion Relation**\n\nThe continuous linear streaming equation is given by:\n$$\n\\frac{\\partial g}{\\partial t} + v_{\\parallel} \\frac{\\partial g}{\\partial l} = 0\n$$\nwhere $g(l, t)$ is a scalar field, $l$ is the spatial coordinate along a magnetic field line, $t$ is time, and $v_{\\parallel}$ is a constant velocity.\n\nTo find the dispersion relation, we assume a plane wave solution (ansatz) of the form:\n$$\ng(l, t) = g_0 \\exp(i(k_{\\parallel} l - \\omega t))\n$$\nwhere $g_0$ is a constant amplitude, $k_{\\parallel}$ is the parallel wavenumber, and $\\omega$ is the angular frequency. We compute the partial derivatives of this ansatz:\n$$\n\\frac{\\partial g}{\\partial t} = -i\\omega \\, g_0 \\exp(i(k_{\\parallel} l - \\omega t)) = -i\\omega g\n$$\n$$\n\\frac{\\partial g}{\\partial l} = i k_{\\parallel} \\, g_0 \\exp(i(k_{\\parallel} l - \\omega t)) = i k_{\\parallel} g\n$$\nSubstituting these expressions into the streaming equation yields:\n$$\n-i\\omega g + v_{\\parallel} (i k_{\\parallel} g) = 0\n$$\n$$\ni(k_{\\parallel} v_{\\parallel} - \\omega) g = 0\n$$\nFor a non-trivial solution ($g \\neq 0$), the term in the parenthesis must be zero. This gives the analytic dispersion relation:\n$$\n\\omega = k_{\\parallel} v_{\\parallel}\n$$\nThis relation, denoted as $\\omega_{\\text{exact}}(k) = v_{\\parallel} k$ (dropping the $\\parallel$ subscript for simplicity), indicates that in the continuous system, all wave modes propagate at the same phase velocity $v_{\\phi} = \\omega/k = v_{\\parallel}$ without distortion. This is a non-dispersive system.\n\n**2. Discretization on a Periodic Grid and Circulant Matrices**\n\nWhen the spatial domain of length $L$ is discretized into $N$ grid points $l_j = j \\Delta$ for $j \\in \\{0, 1, \\ldots, N-1\\}$, where $\\Delta = L/N$ is the grid spacing, a spatial derivative operator $\\partial_l$ is replaced by a discrete matrix operator $D$. Due to the periodic boundary conditions, a centered finite difference stencil applied at grid point $j$ that uses points $j \\pm p$ treats indices modulo $N$. For example, the stencil for the second-order centered difference is $(Dg)_j = (g_{j+1} - g_{j-1})/(2\\Delta)$. The stencil is the same for every grid point $j$, only shifted. This property means the resulting $N \\times N$ matrix $D$ is a circulant matrix. A matrix $C$ is circulant if its elements satisfy $C_{ij} = c_{(j-i) \\pmod N}$, meaning each row is a cyclic shift of the preceding row.\n\nA fundamental theorem of linear algebra states that all $N \\times N$ circulant matrices share a common set of eigenvectors: the discrete Fourier modes. A discrete Fourier mode $u^{(m)}$ is a vector with components:\n$$\nu_j^{(m)} = \\exp\\left(i \\frac{2\\pi m j}{N}\\right)\n$$\nfor $j \\in \\{0, 1, \\ldots, N-1\\}$ and mode number $m \\in \\{0, 1, \\ldots, N-1\\}$. Applying a circulant matrix $C$ with the first row $(c_0, c_1, \\ldots, c_{N-1})$ to this eigenvector gives:\n$$\n(C u^{(m)})_j = \\sum_{p=0}^{N-1} C_{jp} u_p^{(m)} = \\sum_{p=0}^{N-1} c_{(p-j)\\pmod N} \\exp\\left(i \\frac{2\\pi m p}{N}\\right)\n$$\nBy changing the summation variable to $q = (p-j) \\pmod N$, we have $p=(q+j)\\pmod N$:\n$$\n(C u^{(m)})_j = \\sum_{q=0}^{N-1} c_q \\exp\\left(i \\frac{2\\pi m (q+j)}{N}\\right) = \\exp\\left(i \\frac{2\\pi m j}{N}\\right) \\sum_{q=0}^{N-1} c_q \\exp\\left(i \\frac{2\\pi m q}{N}\\right) = \\lambda_m u_j^{(m)}\n$$\nThe eigenvalue $\\lambda_m$ is the discrete Fourier transform of the first row $(c_0, \\ldots, c_{N-1})$ of the matrix.\n\n**3. Eigenvalue Analysis of Numerical Schemes**\n\nThe semi-discretized streaming equation is $\\frac{d\\mathbf{g}}{dt} = -v_{\\parallel} D \\mathbf{g}$, where $\\mathbf{g}$ is the vector of grid point values. For an eigenmode $u^{(m)}$ corresponding to wavenumber $k_m = 2\\pi m/L$, we seek a solution of the form $\\mathbf{g}(t) = u^{(m)} \\exp(-i\\omega_{\\text{num}} t)$. Substituting this into the equation gives $-i\\omega_{\\text{num}} u^{(m)} = -v_{\\parallel} \\lambda_D(k_m) u^{(m)}$, where $\\lambda_D(k_m)$ is the eigenvalue of the discrete derivative operator $D$ for the mode $k_m$. This yields the numerical dispersion relation:\n$$\n\\omega_{\\text{num}}(k_m) = -i v_{\\parallel} \\lambda_D(k_m)\n$$\nWe derive $\\lambda_D(k_m)$ for each scheme by applying the stencil to the grid representation of the plane wave, $g_j = \\exp(i k_m l_j) = \\exp(i k_m j \\Delta)$.\n\n*   **Second-Order Centered Finite Difference:**\n    The stencil is $D g_j = \\frac{g_{j+1} - g_{j-1}}{2\\Delta}$. Applying this to $g_j = \\exp(i k j \\Delta)$:\n    $$\n    D g_j = \\frac{\\exp(ik(j+1)\\Delta) - \\exp(ik(j-1)\\Delta)}{2\\Delta} = g_j \\frac{\\exp(ik\\Delta) - \\exp(-ik\\Delta)}{2\\Delta} = g_j \\frac{2i\\sin(k\\Delta)}{2\\Delta}\n    $$\n    The eigenvalue is $\\lambda_D(k) = i \\frac{\\sin(k\\Delta)}{\\Delta}$. The numerical frequency is therefore:\n    $$\n    \\omega_{\\text{num}}(k) = -i v_{\\parallel} \\left(i \\frac{\\sin(k\\Delta)}{\\Delta}\\right) = v_{\\parallel} \\frac{\\sin(k\\Delta)}{\\Delta}\n    $$\n\n*   **Fourth-Order Centered Finite Difference:**\n    The stencil is $D g_j = \\frac{-g_{j+2} + 8g_{j+1} - 8g_{j-1} + g_{j-2}}{12\\Delta}$. Applying this to $g_j = \\exp(i k j \\Delta)$:\n    $$\n    D g_j = g_j \\frac{-e^{i2k\\Delta} + 8e^{ik\\Delta} - 8e^{-ik\\Delta} + e^{-i2k\\Delta}}{12\\Delta} = g_j \\frac{-2i\\sin(2k\\Delta) + 16i\\sin(k\\Delta)}{12\\Delta}\n    $$\n    The eigenvalue is $\\lambda_D(k) = i \\frac{8\\sin(k\\Delta) - \\sin(2k\\Delta)}{6\\Delta}$. The numerical frequency is:\n    $$\n    \\omega_{\\text{num}}(k) = v_{\\parallel} \\frac{8\\sin(k\\Delta) - \\sin(2k\\Delta)}{6\\Delta}\n    $$\n\n*   **Spectral (Fourier Collocation) Method:**\n    This method is based on representing the function $g$ in the basis of discrete Fourier modes. Differentiation in this basis is equivalent to multiplying the coefficient of each mode $\\exp(ik_m l)$ by $ik_m$. Thus, the action of the ideal spectral differentiation operator on a basis mode is exact. The eigenvalue of the discrete derivative operator $D$ for the mode $k_m$ is precisely:\n    $$\n    \\lambda_D(k_m) = i k_m\n    $$\n    The numerical frequency is therefore:\n    $$\n    \\omega_{\\text{num}}(k_m) = -i v_{\\parallel} (i k_m) = v_{\\parallel} k_m\n    $$\n    This is identical to the analytic dispersion relation, $\\omega_{\\text{num}}(k) = \\omega_{\\text{exact}}(k)$.\n\n**4. Relative Dispersion Error**\n\nThe quality of a numerical scheme for this problem is measured by how closely its numerical frequency $\\omega_{\\text{num}}(k)$ matches the exact frequency $\\omega_{\\text{exact}}(k) = v_{\\parallel} k$. The per-mode relative dispersion error $E(k)$ is defined as:\n$$\nE(k) = \\frac{|\\omega_{\\text{num}}(k) - \\omega_{\\text{exact}}(k)|}{|\\omega_{\\text{exact}}(k)|}\n$$\nThis error must be computed for all representable wavenumbers $k$ on the grid, with two exceptions as specified:\n1.  The $k=0$ mode (zero frequency mean component) is excluded, as it leads to division by zero in the error formula.\n2.  The Nyquist mode, which for an even number of grid points $N$ has wavenumber $|k|$ such that $|k|\\Delta=\\pi$, is excluded. For this mode, centered difference schemes yield $\\omega_{\\text{num}}=0$, and the Fourier method has an ambiguity in defining the derivative.\n\nOur task is to compute the maximum error over the set of included modes, $\\max_{k} E(k)$. For the spectral method, the error $E(k)$ is analytically zero for all modes, so the maximum error will be zero (or of the order of machine precision in a numerical implementation). For finite difference schemes, the error is non-zero and increases with the magnitude of the wavenumber $|k|$. The maximum error will occur for the largest-magnitude wavenumber before the Nyquist frequency.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the maximum relative dispersion error for several numerical schemes\n    applied to the linear streaming equation.\n    \"\"\"\n    test_cases = [\n        {'scheme': '2-cen', 'N': 64, 'L': 2 * np.pi, 'v_parallel': 1.0},\n        {'scheme': '4-cen', 'N': 64, 'L': 2 * np.pi, 'v_parallel': 1.0},\n        {'scheme': 'spectral', 'N': 64, 'L': 2 * np.pi, 'v_parallel': 1.0},\n        {'scheme': '2-cen', 'N': 16, 'L': 2 * np.pi, 'v_parallel': 3.0},\n        {'scheme': '4-cen', 'N': 32, 'L': 10.0, 'v_parallel': 0.7},\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case['N']\n        L = case['L']\n        v_parallel = case['v_parallel']\n        scheme = case['scheme']\n\n        # 1. Set up grid and wavenumbers\n        delta = L / N\n        # Wavenumbers k = 2 * pi * f, where f are the discrete frequencies\n        k = 2 * np.pi * np.fft.fftfreq(N, d=delta)\n\n        # 2. Calculate exact and numerical frequencies\n        w_exact = v_parallel * k\n        \n        k_delta = k * delta\n\n        if scheme == '2-cen':\n            # Second-order centered finite difference\n            # w_num = v_parallel * sin(k*delta) / delta\n            # To avoid division by zero at k=0, use np.divide with a where clause.\n            w_num = np.divide(v_parallel * np.sin(k_delta), delta, where=(k != 0), out=np.zeros_like(k))\n        \n        elif scheme == '4-cen':\n            # Fourth-order centered finite difference\n            # w_num = v_parallel * (8*sin(k*delta) - sin(2*k*delta)) / (6*delta)\n            numerator = v_parallel * (8 * np.sin(k_delta) - np.sin(2 * k_delta))\n            denominator = 6 * delta\n            w_num = np.divide(numerator, denominator, where=(k != 0), out=np.zeros_like(k))\n            \n        elif scheme == 'spectral':\n            # Spectral (Fourier collocation) method\n            # w_num = v_parallel * k\n            w_num = v_parallel * k\n        \n        else:\n            raise ValueError(f\"Unknown scheme: {scheme}\")\n\n        # 3. Define the mask to exclude k=0 and Nyquist mode\n        mask = np.ones(N, dtype=bool)\n        \n        # Exclude k=0 mode (DC component)\n        mask[0] = False\n        \n        # Exclude Nyquist mode if N is even. The Nyquist frequency\n        # corresponds to k where |k|*delta = pi. This is at index N//2 for even N.\n        if N % 2 == 0:\n            mask[N // 2] = False\n            \n        # 4. Calculate relative error on the masked modes\n        # We filter the arrays to avoid division by zero or any computation on excluded modes\n        w_exact_filtered = w_exact[mask]\n        w_num_filtered = w_num[mask]\n\n        # The problem is defined to exclude k=0, so w_exact_filtered will not contain zero.\n        rel_errors = np.abs(w_num_filtered - w_exact_filtered) / np.abs(w_exact_filtered)\n\n        # 5. Find the maximum relative error\n        max_error = 0.0\n        if rel_errors.size > 0:\n            max_error = np.max(rel_errors)\n        \n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    # Results are rounded to 10 decimal places.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Producing a result from a complex simulation is only the first step; verifying its correctness is a critical and often challenging part of computational science. Since exact analytical solutions for realistic gyrokinetic problems are unavailable, comparing results between independent codes is a cornerstone of verification. This exercise  guides you through a simulated reproducibility study, teaching you how to rigorously compare the primary outputs of a linear simulation—growth rates and mode structures—while properly accounting for statistical uncertainties and the inherent normalization freedom of eigenfunctions.",
            "id": "4002465",
            "problem": "Consider two independent linear gyrokinetic codes, labeled \"Code A\" and \"Code B,\" each solving the linear gyrokinetic initial value problem for a magnetized plasma in toroidal geometry and reporting the growth rate and electrostatic potential mode structure for drift-wave microinstabilities. The linear growth rate $\\gamma$ is defined as the imaginary part of the complex frequency $\\omega$ of the exponentially evolving mode, $\\omega = \\omega_r + i \\gamma$, and here it is reported in dimensionless form normalized to $c_s/R$. The eigenfunction (mode structure) $\\phi(\\theta)$ is reported as the complex electrostatic potential in the ballooning angle coordinate $\\theta$ in radians. In the linear regime, the eigenfunction is defined only up to an arbitrary complex normalization (overall amplitude and phase), which must be accounted for when constructing a reproducibility metric. The task is to assess reproducibility by comparing results from the two codes and to quantify discrepancies relative to statistical error bars.\n\nFrom first principles, start from the definition of linear growth in time for a single $k_y$ component, $\\phi(\\theta, t) \\propto \\phi(\\theta) \\exp(i \\omega t)$, together with the understanding that reported standard deviations for $\\gamma$ are independent estimates of uncertainty (for example, due to finite-time fits or numerical resolution). Develop a comparison methodology that meets both criteria:\n- Quantify the discrepancy in $\\gamma$ relative to the combined uncertainty from the two codes, and\n- Quantify the distance between $\\phi_A(\\theta)$ and $\\phi_B(\\theta)$ after optimally accounting for arbitrary complex normalization differences.\n\nYour program must implement this methodology for the test suite specified below and evaluate reproducibility according to the following rule: for a given case, reproducibility holds if and only if, for every $k_y$ in that case, the growth rate discrepancy does not exceed two combined standard deviations and the structure distance, after optimal complex normalization, does not exceed a small tolerance. Concretely, use a threshold of $2$ for the growth-rate discrepancy and $0.2$ for the structure distance tolerance. The final outputs are booleans indicating whether each case is reproducible.\n\nThe electrostatic potential eigenfunctions for each code and each $k_y$ are to be constructed on a uniform $\\theta$ grid as follows. Use $\\theta \\in [-\\Theta, \\Theta]$ with $\\Theta = 3.0$ and $N = 129$ evenly spaced points (angle unit: radians). For Code A, define\n$$\n\\phi_A(\\theta; k_y) = \\exp\\!\\left(-\\frac{\\theta^2}{2 \\sigma^2}\\right)\\,\\exp\\!\\left(i\\,k_{\\parallel,A}\\,\\theta\\right),\n$$\nand for Code B, define\n$$\n\\phi_B(\\theta; k_y) = A\\,\\exp\\!\\left(-\\frac{\\theta^2}{2 (\\sigma + \\Delta \\sigma)^2}\\right)\\,\\exp\\!\\left(i\\,k_{\\parallel,B}\\,\\theta + i\\,\\phi_0\\right).\n$$\nHere, $\\sigma$ is an envelope width parameter (dimensionless), $\\Delta \\sigma$ is a width perturbation, $A$ is a real amplitude factor, $\\phi_0$ is a constant phase shift, and $k_{\\parallel,A} = \\alpha_A k_y$ and $k_{\\parallel,B} = \\alpha_B k_y$ are parallel phase gradients proportional to $k_y$ with proportionality factors $\\alpha_A$ and $\\alpha_B$ (dimensionless). These constructions are chosen to be scientifically plausible for ballooning mode structures and provide controlled differences between the codes.\n\nYou must construct the following test suite of three cases. All growth rates $\\gamma$ are normalized to $c_s/R$ (dimensionless), angles are in radians, and standard deviations are dimensionless in the same normalization. In each case, implement the specified $k_y$ values, growth rates and uncertainties for both codes, and eigenfunction parameters:\n\n- Case 1:\n  - $k_y \\in \\{0.1, 0.2, 0.3\\}$.\n  - Code A growth rates $\\gamma_A = [0.15, 0.23, 0.31]$ with standard deviations $\\sigma_{\\gamma,A} = [0.006, 0.006, 0.007]$.\n  - Code B growth rates $\\gamma_B = [0.149, 0.229, 0.312]$ with standard deviations $\\sigma_{\\gamma,B} = [0.006, 0.005, 0.008]$.\n  - Eigenfunction parameters: $\\sigma = 0.9$, $\\alpha_A = 0.5$, $\\alpha_B = 0.5$, and per $k_y$ use $(\\Delta \\sigma, A, \\phi_0)$ equal to $[(0.0, 1.0, 0.3), (0.03, 1.0, -0.2), (0.02, 1.05, 0.1)]$ respectively.\n\n- Case 2:\n  - $k_y \\in \\{0.05, 0.15, 0.25\\}$.\n  - Code A growth rates $\\gamma_A = [0.08, 0.18, 0.26]$ with standard deviations $\\sigma_{\\gamma,A} = [0.004, 0.005, 0.006]$.\n  - Code B growth rates $\\gamma_B = [0.095, 0.205, 0.29]$ with standard deviations $\\sigma_{\\gamma,B} = [0.004, 0.005, 0.006]$.\n  - Eigenfunction parameters: $\\sigma = 1.0$, $\\alpha_A = 0.5$, $\\alpha_B = 0.7$, and per $k_y$ use $(\\Delta \\sigma, A, \\phi_0)$ equal to $[(0.05, 1.1, 0.5), (0.08, 0.9, -0.4), (0.30, 1.2, 0.7)]$ respectively.\n\n- Case 3:\n  - $k_y \\in \\{0.2, 0.4\\}$.\n  - Code A growth rates $\\gamma_A = [0.22, 0.34]$ with standard deviations $\\sigma_{\\gamma,A} = [0.003, 0.004]$.\n  - Code B growth rates $\\gamma_B = [0.221, 0.345]$ with standard deviations $\\sigma_{\\gamma,B} = [0.004, 0.004]$.\n  - Eigenfunction parameters: $\\sigma = 0.85$, $\\alpha_A = 0.5$, $\\alpha_B = 0.5$, and per $k_y$ use $(\\Delta \\sigma, A, \\phi_0)$ equal to $[(0.0, 1.0, 0.0), (0.02, 1.0, 0.15)]$ respectively.\n\nYour program must, for each case, construct $\\phi_A(\\theta; k_y)$ and $\\phi_B(\\theta; k_y)$ on the specified grid, evaluate the discrepancy metrics derived from first principles, and determine whether the case is reproducible according to the rule stated above. The final output must be a single line containing the case-wise reproducibility booleans as a comma-separated list enclosed in square brackets, for example `[True,False,True]`. No other output is permitted. All outputs are dimensionless and unit-free, and angles are in radians.",
            "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the field of computational plasma physics, specifically concerning the verification of linear gyrokinetic simulation codes. The problem is well-posed, self-contained, and provides all necessary data and definitions to construct a unique, computable solution. The task requires deriving and applying standard metrics for comparing simulation outputs, which is a routine and meaningful exercise in scientific computing.\n\nThe methodology for comparing the results from Code A and Code B is developed from first principles as follows, addressing the two required comparison criteria: the linear growth rate $\\gamma$ and the eigenfunction mode structure $\\phi(\\theta)$.\n\n**1. Growth Rate Discrepancy Metric ($D_\\gamma$)**\n\nThe problem provides the growth rates $\\gamma_A$ and $\\gamma_B$ and their corresponding standard deviations, $\\sigma_{\\gamma,A}$ and $\\sigma_{\\gamma,B}$, which are stated to be independent estimates of uncertainty. To quantify the discrepancy between $\\gamma_A$ and $\\gamma_B$ relative to their combined uncertainty, we employ standard error propagation for independent measurements.\n\nThe difference in the mean values is $|\\gamma_A - \\gamma_B|$. The variances of independent random variables add, so the variance of the difference $\\gamma_A - \\gamma_B$ is $\\sigma_{\\gamma,A}^2 + \\sigma_{\\gamma,B}^2$. The combined standard deviation is therefore:\n$$\n\\sigma_{\\text{comb}} = \\sqrt{\\sigma_{\\gamma,A}^2 + \\sigma_{\\gamma,B}^2}\n$$\nThe discrepancy metric, $D_\\gamma$, is the absolute difference in growth rates normalized by the combined standard deviation. It represents the difference in units of \"sigmas\":\n$$\nD_\\gamma = \\frac{|\\gamma_A - \\gamma_B|}{\\sigma_{\\text{comb}}} = \\frac{|\\gamma_A - \\gamma_B|}{\\sqrt{\\sigma_{\\gamma,A}^2 + \\sigma_{\\gamma,B}^2}}\n$$\nReproducibility for the growth rate requires this discrepancy to be within a specified tolerance, which the problem defines as $D_\\gamma \\le 2$.\n\n**2. Eigenfunction Structure Distance Metric ($D_\\phi$)**\n\nThe linear eigenfunction $\\phi(\\theta)$ is defined only up to an arbitrary complex normalization factor. That is, if $\\phi_A(\\theta)$ is a valid eigenfunction, then so is $c \\cdot \\phi_A(\\theta)$ for any non-zero complex constant $c$. A meaningful distance metric must be invariant to such a transformation.\n\nWe represent the continuous functions $\\phi_A(\\theta)$ and $\\phi_B(\\theta)$ as complex vectors on the specified discrete grid of $N=129$ points. Let these vectors be denoted $\\vec{\\phi}_A$ and $\\vec{\\phi}_B$. To find the distance between them after accounting for normalization, we seek a complex number $c$ that optimally scales $\\vec{\\phi}_B$ to match $\\vec{\\phi}_A$. The standard approach is to minimize the L2-norm (Euclidean distance) of the difference vector:\n$$\nd(c)^2 = ||\\vec{\\phi}_A - c \\vec{\\phi}_B||^2\n$$\nUsing the definition of the complex inner product, $\\langle \\vec{u}, \\vec{v} \\rangle = \\sum_j u_j^* v_j$, where $u_j^*$ is the complex conjugate of $u_j$, the squared distance expands to:\n$$\nd(c)^2 = \\langle \\vec{\\phi}_A, \\vec{\\phi}_A \\rangle - c \\langle \\vec{\\phi}_A, \\vec{\\phi}_B \\rangle - c^* \\langle \\vec{\\phi}_B, \\vec{\\phi}_A \\rangle + |c|^2 \\langle \\vec{\\phi}_B, \\vec{\\phi}_B \\rangle\n$$\nMinimizing this with respect to $c$ (e.g., by setting the complex derivative $\\partial/\\partial c^*$ to zero) yields the optimal scaling factor $c_{\\text{opt}} = \\langle \\vec{\\phi}_B, \\vec{\\phi}_A \\rangle / ||\\vec{\\phi}_B||^2$.\n\nA more fundamental approach to defining a normalized distance is to first normalize each vector to unit length, $\\hat{\\phi} = \\vec{\\phi} / ||\\vec{\\phi}||$, where $||\\vec{\\phi}|| = \\sqrt{\\langle \\vec{\\phi}, \\vec{\\phi} \\rangle}$. This removes the arbitrary amplitude. The remaining freedom is an overall phase factor, $e^{i\\alpha}$. We therefore seek to minimize the distance between $\\hat{\\phi}_A$ and $e^{i\\alpha}\\hat{\\phi}_B$ by choosing the optimal phase $\\alpha$:\n$$\nD_\\phi^2 = \\min_{\\alpha} ||\\hat{\\phi}_A - e^{i\\alpha}\\hat{\\phi}_B||^2\n$$\nExpanding this squared norm:\n$$\n||\\hat{\\phi}_A - e^{i\\alpha}\\hat{\\phi}_B||^2 = \\langle \\hat{\\phi}_A, \\hat{\\phi}_A \\rangle + \\langle e^{i\\alpha}\\hat{\\phi}_B, e^{i\\alpha}\\hat{\\phi}_B \\rangle - \\langle \\hat{\\phi}_A, e^{i\\alpha}\\hat{\\phi}_B \\rangle - \\langle e^{i\\alpha}\\hat{\\phi}_B, \\hat{\\phi}_A \\rangle\n$$\nSince $||\\hat{\\phi}_A|| = ||\\hat{\\phi}_B|| = 1$ and $|e^{i\\alpha}|=1$, this simplifies to:\n$$\n2 - e^{i\\alpha}\\langle \\hat{\\phi}_A, \\hat{\\phi}_B \\rangle - e^{-i\\alpha}\\langle \\hat{\\phi}_B, \\hat{\\phi}_A \\rangle = 2 - 2 \\text{Re}\\left(e^{i\\alpha} \\langle \\hat{\\phi}_A, \\hat{\\phi}_B \\rangle\\right)\n$$\nThis expression is minimized when $e^{i\\alpha}\\langle \\hat{\\phi}_A, \\hat{\\phi}_B \\rangle$ is a purely real and positive number, which occurs when its value is $|\\langle \\hat{\\phi}_A, \\hat{\\phi}_B \\rangle|$. The minimum squared distance is thus $2 - 2|\\langle \\hat{\\phi}_A, \\hat{\\phi}_B \\rangle|$. The structure distance metric $D_\\phi$ is the square root:\n$$\nD_\\phi = \\sqrt{2 - 2|\\langle \\hat{\\phi}_A, \\hat{\\phi}_B \\rangle|}\n$$\nwhere $\\langle \\hat{\\phi}_A, \\hat{\\phi}_B \\rangle = \\frac{\\langle \\vec{\\phi}_A, \\vec{\\phi}_B \\rangle}{||\\vec{\\phi}_A|| \\cdot ||\\vec{\\phi}_B||}$ is the normalized inner product, or complex cosine similarity. If $\\vec{\\phi}_A$ and $\\vec{\\phi}_B$ are collinear (differ only by a complex constant), $|\\langle \\hat{\\phi}_A, \\hat{\\phi}_B \\rangle| = 1$ and $D_\\phi = 0$. Reproducibility for the mode structure requires $D_\\phi \\le 0.2$.\n\n**3. Overall Reproducibility Criterion**\n\nFor a given test case to be deemed reproducible, every $k_y$ value within that case must satisfy both conditions simultaneously: $D_\\gamma \\le 2$ and $D_\\phi \\le 0.2$. If even one $k_y$ fails either test, the entire case is considered not reproducible.\n\nThe provided Python code implements this methodology. For each case and each $k_y$, it calculates $D_\\gamma$ and $D_\\phi$. The eigenfunctions $\\phi_A$ and $\\phi_B$ are constructed on a uniform grid in $\\theta \\in [-3.0, 3.0]$ with $N=129$ points using the specified functional forms. The numerical calculation of inner products and norms follows the derived formulas.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the reproducibility problem for the three test cases specified.\n    \"\"\"\n\n    # Grid parameters for the eigenfunction\n    THETA_MAX = 3.0\n    N_POINTS = 129\n    theta_grid = np.linspace(-THETA_MAX, THETA_MAX, N_POINTS)\n\n    # Reproducibility thresholds\n    GAMMA_DISCREPANCY_THRESHOLD = 2.0\n    STRUCTURE_DISTANCE_THRESHOLD = 0.2\n\n    test_cases = [\n        # Case 1\n        {\n            \"ky_values\": [0.1, 0.2, 0.3],\n            \"gamma_A\": [0.15, 0.23, 0.31],\n            \"sigma_gamma_A\": [0.006, 0.006, 0.007],\n            \"gamma_B\": [0.149, 0.229, 0.312],\n            \"sigma_gamma_B\": [0.006, 0.005, 0.008],\n            \"eigen_params\": {\n                \"sigma\": 0.9,\n                \"alpha_A\": 0.5,\n                \"alpha_B\": 0.5,\n                \"per_ky\": [\n                    (0.0, 1.0, 0.3),    # Delta_sigma, A, phi_0 for ky=0.1\n                    (0.03, 1.0, -0.2),  # for ky=0.2\n                    (0.02, 1.05, 0.1),  # for ky=0.3\n                ],\n            },\n        },\n        # Case 2\n        {\n            \"ky_values\": [0.05, 0.15, 0.25],\n            \"gamma_A\": [0.08, 0.18, 0.26],\n            \"sigma_gamma_A\": [0.004, 0.005, 0.006],\n            \"gamma_B\": [0.095, 0.205, 0.29],\n            \"sigma_gamma_B\": [0.004, 0.005, 0.006],\n            \"eigen_params\": {\n                \"sigma\": 1.0,\n                \"alpha_A\": 0.5,\n                \"alpha_B\": 0.7,\n                \"per_ky\": [\n                    (0.05, 1.1, 0.5),   # for ky=0.05\n                    (0.08, 0.9, -0.4),  # for ky=0.15\n                    (0.30, 1.2, 0.7),   # for ky=0.25\n                ],\n            },\n        },\n        # Case 3\n        {\n            \"ky_values\": [0.2, 0.4],\n            \"gamma_A\": [0.22, 0.34],\n            \"sigma_gamma_A\": [0.003, 0.004],\n            \"gamma_B\": [0.221, 0.345],\n            \"sigma_gamma_B\": [0.004, 0.004],\n            \"eigen_params\": {\n                \"sigma\": 0.85,\n                \"alpha_A\": 0.5,\n                \"alpha_B\": 0.5,\n                \"per_ky\": [\n                    (0.0, 1.0, 0.0),    # for ky=0.2\n                    (0.02, 1.0, 0.15),  # for ky=0.4\n                ],\n            },\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        case_reproducible = True\n        for i, ky in enumerate(case[\"ky_values\"]):\n            # 1. Growth rate discrepancy check\n            gamma_A = case[\"gamma_A\"][i]\n            sigma_gamma_A = case[\"sigma_gamma_A\"][i]\n            gamma_B = case[\"gamma_B\"][i]\n            sigma_gamma_B = case[\"sigma_gamma_B\"][i]\n\n            gamma_diff = np.abs(gamma_A - gamma_B)\n            combined_sigma = np.sqrt(sigma_gamma_A**2 + sigma_gamma_B**2)\n            \n            # Avoid division by zero if uncertainties are zero\n            if combined_sigma > 0:\n                gamma_discrepancy = gamma_diff / combined_sigma\n            else:\n                gamma_discrepancy = 0.0 if gamma_diff == 0.0 else np.inf\n\n            if gamma_discrepancy > GAMMA_DISCREPANCY_THRESHOLD:\n                case_reproducible = False\n                break\n\n            # 2. Eigenfunction structure distance check\n            p = case[\"eigen_params\"]\n            sigma = p[\"sigma\"]\n            alpha_A = p[\"alpha_A\"]\n            alpha_B = p[\"alpha_B\"]\n            delta_sigma, A, phi_0 = p[\"per_ky\"][i]\n\n            # Construct eigenfunctions\n            sigma_A = sigma\n            sigma_B = sigma + delta_sigma\n            k_parallel_A = alpha_A * ky\n            k_parallel_B = alpha_B * ky\n            \n            # phi_A(theta; k_y) = exp(-theta^2 / (2*sigma^2)) * exp(i*k_parallel_A*theta)\n            phi_A = np.exp(-theta_grid**2 / (2 * sigma_A**2)) * \\\n                    np.exp(1j * k_parallel_A * theta_grid)\n            \n            # phi_B(theta; k_y) = A*exp(-theta^2 / (2*(sigma+d_sigma)^2)) * exp(i*k_parallel_B*theta + i*phi_0)\n            phi_B = A * np.exp(-theta_grid**2 / (2 * sigma_B**2)) * \\\n                    np.exp(1j * k_parallel_B * theta_grid + 1j * phi_0)\n\n            # Calculate structure distance\n            norm_A = np.linalg.norm(phi_A)\n            norm_B = np.linalg.norm(phi_B)\n            \n            # Ensure norms are non-zero to avoid division by zero\n            if norm_A > 1e-15 and norm_B > 1e-15:\n                # Inner product <phi_A, phi_B> = sum(phi_A_conj * phi_B)\n                inner_product = np.vdot(phi_A, phi_B)\n                normalized_inner_product_mag = np.abs(inner_product) / (norm_A * norm_B)\n                \n                # Cap at 1.0 to handle potential floating point inaccuracies\n                if normalized_inner_product_mag > 1.0:\n                    normalized_inner_product_mag = 1.0\n\n                structure_distance = np.sqrt(2 - 2 * normalized_inner_product_mag)\n            else:\n                structure_distance = np.sqrt(2.0) if norm_A > 1e-15 or norm_B > 1e-15 else 0.0\n                \n            if structure_distance > STRUCTURE_DISTANCE_THRESHOLD:\n                case_reproducible = False\n                break\n        \n        results.append(case_reproducible)\n        \n    # Format the final output string\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}