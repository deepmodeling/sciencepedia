{
    "hands_on_practices": [
        {
            "introduction": "在理论层面掌握拉回变换的一个关键应用是简化和求解复杂的粒子动力学。本练习将引导你推导囚禁离子的弹跳中心哈密顿量，这是一个展示如何通过相平均来消除快变自由度的经典例子。通过这个练习 ，你将加深对哈密顿力学和绝热不变量在简化等离子体模型中作用的理解。",
            "id": "4033770",
            "problem": "考虑一个质量为 $m$、电荷为 $q$ 的单个俘获离子，该离子位于一个静态、轴对称、大环径比的环形磁约束装置中。离子的动力学在导心和回旋动理学框架内描述，你将通过哈密顿李变换 (Hamiltonian Lie-transform, HLT) 生成的拉回变换，构建最低阶的弹跳中心 (Bounce-Center, BC) 描述。沿选定磁力线的磁场强度在其最小值附近被建模为弧长坐标 $s$ 的一个光滑函数，\n$$\nB(s) \\equiv B_{0}\\left[1 + (R_{m}-1)\\,\\frac{s^{2}}{s_{m}^{2}}\\right],\n$$\n其中 $B_{0}$ 是 $s=0$ 处的最小场强，$s_{m}>0$ 是界定局部磁阱的转折点的弧长位置，而 $R_{m} \\equiv B_{\\max}/B_{0} > 1$ 是磁镜比。假设没有静电势，并忽略超出最低阶的漂移阶修正。该离子具有固定的磁矩 $\\mu$，并围绕 $s=0$ 进行小振幅弹跳振荡。\n\n从回旋动理学 (Gyrokinetics, GK) 中导心和弹跳中心动力学的适当基本定律和核心定义出发，包括导心哈密顿量和沿磁力线的最低阶运动方程，使用哈密顿李变换拉回以消除快弹跳相位，并构建作为弹跳作用量 $J_{b}$ 函数的最低阶弹跳中心哈密顿量 $H_{\\mathrm{BC}}^{(0)}$。你的推导必须：\n- 从用平行正则动量和磁矩表示的导心哈密顿量开始，\n- 在 $s=0$ 附近线性化平行动力学，以获得小振幅弹跳频率，\n- 定义与平行振荡相关的弹跳作用量 $J_{b}$，\n- 对弹跳相位进行最低阶平均，这与到弹跳中心的拉回变换一致。\n\n在你最终的表达式中，指出依赖于磁镜比 $R_{m}$ 和通过 $B(s)$ 在 $s=0$ 处的导数表示的局部场强曲率的项。将最终答案表示为 $H_{\\mathrm{BC}}^{(0)}$ 关于 $J_{b}$、$\\mu$、$B_{0}$、$R_{m}$、$s_{m}$ 和 $m$ 的单个闭式解析表达式。不需要进行数值计算。如果引入任何缩写词，请在首次使用时写出全称，例如，回旋动理学 (Gyrokinetic, GK)、弹跳中心 (Bounce Center, BC)、哈密顿李变换 (Hamiltonian Lie-transform, HLT)。",
            "solution": "该问题陈述是高等离子体物理学中一个适定且有科学依据的练习，特别是在回旋动理学和哈密顿力学的主题内。它要求在一组特定的有效物理近似下，推导俘获离子的最低阶弹跳中心哈密顿量。所有提供的信息都是自洽的，并且足以进行推导。因此，该问题被认为是有效的。\n\n目标是通过对俘获离子的快速弹跳运动进行平均，来构建其最低阶弹跳中心 (Bounce-Center, BC) 哈密顿量 $H_{\\mathrm{BC}}^{(0)}$。这是通过哈密顿李变换 (Hamiltonian Lie-transform, HLT) 拉回实现的，在最低阶上，这等效于相平均。推导过程分四步进行。\n\n首先，我们建立导心 (Guiding-Center, GC) 哈密顿量。在没有静电势的情况下，GC 哈密顿量 $H_{\\mathrm{GC}}$ 是用 GC 变量表示的粒子动能。它是与平行于磁场的运动相关的动能和回旋运动能量之和。\n$$\nH_{\\mathrm{GC}} = \\frac{p_{\\parallel}^{2}}{2m} + \\mu B\n$$\n这里，$p_{\\parallel} = m v_{\\parallel}$ 是平行正则动量（也是动理学动量，因为磁矢势的贡献由 GC 变换处理），$m$ 是离子质量，$\\mu$ 是磁矩（一个绝热不变量），$B$ 是磁场强度。问题给出了沿磁力线的磁场强度大小的空间依赖关系，由弧长 $s$ 参数化：\n$$\nB(s) = B_{0}\\left[1 + (R_{m}-1)\\frac{s^{2}}{s_{m}^{2}}\\right]\n$$\n其中 $B_{0}$ 是 $s=0$ 处的最小场强，$R_{m}$ 是磁镜比，$s_{m}$ 是磁阱的特征长度尺度。将此代入 GC 哈密顿量得到：\n$$\nH_{\\mathrm{GC}}(s, p_{\\parallel}) = \\frac{p_{\\parallel}^{2}}{2m} + \\mu B_{0}\\left[1 + (R_{m}-1)\\frac{s^{2}}{s_{m}^{2}}\\right]\n$$\n该哈密顿量是 GC 动力学的一个运动常数。\n\n其次，我们分析平行动力学以求出弹跳频率。平行坐标 $(s, p_{\\parallel})$ 的运动方程由哈密顿方程给出：\n$$\n\\dot{s} = \\frac{\\partial H_{\\mathrm{GC}}}{\\partial p_{\\parallel}} = \\frac{p_{\\parallel}}{m}\n$$\n$$\n\\dot{p}_{\\parallel} = -\\frac{\\partial H_{\\mathrm{GC}}}{\\partial s} = -\\mu B_{0} (R_{m}-1) \\frac{2s}{s_{m}^{2}}\n$$\n将 $\\dot{s}$ 对时间求导并代入 $\\dot{p}_{\\parallel}$，得到坐标 $s$ 的运动方程：\n$$\n\\ddot{s} = \\frac{\\dot{p}_{\\parallel}}{m} = -\\left[ \\frac{2 \\mu B_{0} (R_{m}-1)}{m s_{m}^{2}} \\right] s\n$$\n这是一个简谐振子方程，$\\ddot{s} + \\omega_{b}^{2}s = 0$。通过比较这两种形式，我们确定了小振幅弹跳频率 $\\omega_{b}$ 的平方：\n$$\n\\omega_{b}^{2} = \\frac{2 \\mu B_{0} (R_{m}-1)}{m s_{m}^{2}}\n$$\n因此，弹跳频率为：\n$$\n\\omega_{b} = \\sqrt{\\frac{2 \\mu B_{0} (R_{m}-1)}{m s_{m}^{2}}}\n$$\n\n第三，我们定义弹跳作用量 $J_{b}$。弹跳作用量是与弹跳相位角共轭的正则作用量。对于一维谐振子，作用量 $J$ 与其能量 $E_{\\mathrm{osc}}$ 和频率 $\\omega$ 的关系为 $E_{\\mathrm{osc}} = J \\omega$。在我们的例子中，“振子能量”是哈密顿量中与平行运动相关的部分，我们可以将其定义为 $H_{\\parallel} = H_{\\mathrm{GC}} - \\mu B_{0}$。\n$$\nH_{\\parallel}(s, p_{\\parallel}) = \\frac{p_{\\parallel}^{2}}{2m} + \\mu \\left( B(s) - B_{0} \\right) = \\frac{p_{\\parallel}^{2}}{2m} + \\mu B_{0} (R_{m}-1)\\frac{s^{2}}{s_{m}^{2}}\n$$\n这代表了谐波振荡的能量。由于 $H_{\\mathrm{GC}}$ 是一个运动常数，因此 $H_{\\parallel}$ 也是。弹跳作用量 $J_{b}$ 与该能量的关系为：\n$$\nJ_{b} = \\frac{H_{\\parallel}}{\\omega_{b}} = \\frac{H_{\\mathrm{GC}} - \\mu B_{0}}{\\omega_{b}}\n$$\n\n第四，我们构建最低阶弹跳中心哈密顿量 $H_{\\mathrm{BC}}^{(0)}$。到 BC 坐标系的 HLT 拉回变换旨在消除对快弹跳相位的依赖。在最低阶上，所得的哈密顿量 $H_{\\mathrm{BC}}^{(0)}$ 是原始哈密顿量 $H_{\\mathrm{GC}}$ 的弹跳平均值。平均过程将哈密顿量从 $(s, p_{\\parallel})$ 的函数转换为弹跳作用量 $J_{b}$ 的函数。根据第三步推导出的关系，我们可以完全用在一个弹跳周期内保持恒定的量来表示 $H_{\\mathrm{GC}}$：$J_{b}$、$\\mu$ 以及磁场参数。\n$$\nH_{\\mathrm{GC}} = J_{b} \\omega_{b} + \\mu B_{0}\n$$\n由于该表达式已经与弹跳相位无关，其在弹跳运动上的平均值就是其自身。因此，最低阶 BC 哈密顿量为：\n$$\nH_{\\mathrm{BC}}^{(0)}(J_{b}) = J_{b} \\omega_{b} + \\mu B_{0}\n$$\n代入 $\\omega_{b}$ 的表达式：\n$$\nH_{\\mathrm{BC}}^{(0)}(J_{b}) = J_{b} \\sqrt{\\frac{2 \\mu B_{0} (R_{m}-1)}{m s_{m}^{2}}} + \\mu B_{0}\n$$\n按要求，我们指出其中的依赖关系。第一项 $J_b \\omega_b$ 通过因子 $(R_{m}-1)$ 依赖于磁镜比 $R_{m}$。该项还依赖于 $s=0$ 处的局部场强曲率。磁场的二阶导数为 $B''(s) = \\frac{d^{2}B}{ds^{2}} = \\frac{2 B_{0} (R_{m}-1)}{s_{m}^{2}}$。因此，弹跳频率可以写成 $\\omega_{b} = \\sqrt{\\mu B''(0)/m}$。弹跳中心哈密顿量的第一项与该曲率的平方根成正比，这证明了俘获势的形状与粒子弹跳动力学之间的联系。最终表达式以给定参数的形式给出。",
            "answer": "$$\\boxed{J_{b} \\sqrt{\\frac{2 \\mu B_{0} (R_{m} - 1)}{m s_{m}^{2}}} + \\mu B_{0}}$$"
        },
        {
            "introduction": "将连续的回旋动理学理论转化为离散的数值算法是计算聚变科学中的核心挑战。本练习要求你为一个粒子模拟（PIC）代码设计一个电荷守恒的离散拉回方案。完成此练习  将帮助你理解理论与实践之间的联系，特别是如何在离散化过程中保持基本的物理守恒律，这是保证模拟稳定性和准确性的关键。",
            "id": "4033726",
            "problem": "在$\\delta f$粒子模拟(PIC)回旋动理学算法中，考虑导引中心相空间与粒子相空间之间的变换。您的任务是设计一个离散拉回方案，将粒子权重从导引中心空间映射到粒子空间，同时在一维周期性域中保持总电荷守恒。\n\n该方案必须从与电荷守恒和回旋相平均的一致性离散表示相符的第一性原理推导得出。数值实现必须对网格到粒子和粒子到网格的操作使用一阶云中格点(Cloud-In-Cell)沉积和插值。\n\n假设使用以下建模假设和计算设置：\n- 域是一维周期性的，长度为 $L$，用 $N_g$ 个均匀间隔的网格节点离散化，网格间距为 $\\Delta x = L/N_g$。\n- 每个标记粒子（计算粒子）都有一个导引中心位置 $R_p \\in [0,L)$ 和一个标量权重 $w_p^{\\mathrm{gc}}$，代表其在导引中心坐标系中的$\\delta f$权重。\n- 每个标记粒子的拉莫尔半径由标量 $\\rho_p$ 给出。为简化此一维模型，回旋相环沿域坐标投影为一组位置 $x_{p,k}$，这些位置是通过从 $R_p$ 进行带有角度采样的余弦位移得到的。\n- 回旋相采样在完整的 $2\\pi$ 旋转中使用 $N_\\theta$ 个等间距角度。所有角度必须以弧度为单位。\n- 静电势 $\\phi(x)$ 定义在网格节点上。从网格到粒子的插值使用与从粒子到网格的沉积相同的一阶云中格点权重。\n\n您的任务是：\n1. 从总电荷在拉回映射（从导引中心权重到粒子空间权重）下必须不变的要求以及一阶云中格点形函数的离散性质出发，推导出一个离散拉回规则，确保映射后沉积在网格上的电荷总和被精确保持。您必须明确定义势的离散回旋相平均以及映射如何使用它。\n2. 在一个程序中实现所推导的方案，该程序需要：\n   - 生成一组具有位置 $R_p$ 和导引中心权重 $w_p^{\\mathrm{gc}}$ 的标记粒子。\n   - 对每个标记粒子，使用 $N_\\theta$ 个采样点 $\\theta_k = 2\\pi k/N_\\theta$（其中 $k=0,1,\\ldots,N_\\theta-1$）和一维投影 $x_{p,k} = R_p + \\rho_p \\cos\\theta_k$（并进行周期性折叠到 $[0,L)$ 区间内）来构造回旋相环位置 $x_{p,k}$。\n   - 使用一阶云中格点插值在 $x_{p,k}$ 处插值 $\\phi$。\n   - 使用一阶云中格点方法将电荷沉积到网格上，来源包括：\n     (a) 导引中心表示，其中回旋相环使用原始的 $w_p^{\\mathrm{gc}}$ 离散平均到网格上；以及\n     (b) 粒子空间表示，其中映射后的粒子空间权重（待推导）从所有的 $x_{p,k}$ 处沉积。\n   - 计算映射前后网格上的总电荷，并返回其绝对差值。\n3. 使用无量纲归一化单位。无需进行物理单位转换。\n4. 使用以下包含五组参数的测试套件。对于所有测试，将随机数生成器种子设置为 $42$ 以确保任何随机初始化的可复现性：\n   - 测试 1（基线，均匀场）：$L=1$, $N_g=32$, $N_\\theta=8$，标记粒子数 $N_p=50$，所有标记粒子的 $\\rho_p=0.05$，系数 $\\alpha=0.3$，所有网格节点上的势 $\\phi(x)=0$。\n   - 测试 2（单模势）：$L=1$, $N_g=64$, $N_\\theta=16$, $N_p=100$, $\\rho_p=0.04$, $\\alpha=1.0$，在网格节点 $x_j=j\\Delta x$ 上采样的势 $\\phi(x)=0.1\\sin(2\\pi x)$。\n   - 测试 3（零拉莫尔半径）：$L=1$, $N_g=64$, $N_\\theta=8, N_p=75, \\rho_p=0.0, \\alpha=0.5$，在网格节点 $x_j=j\\Delta x$ 上采样的势 $\\phi(x)=0.05\\sin(4\\pi x)+0.02\\cos(6\\pi x)$。\n   - 测试 4（随机势）：$L=1$, $N_g=128$, $N_\\theta=12, N_p=200, \\rho_p=0.03, \\alpha=0.7$，势 $\\phi(x)$ 是一个长度为 $N_g$ 的随机数组，由独立的标准正态分布条目乘以 0.2 生成。\n   - 测试 5（高波数和最小回旋相采样）：$L=1$, $N_g=32$, $N_\\theta=1, N_p=5, \\rho_p=0.1, \\alpha=2.0$，在网格节点 $x_j=j\\Delta x$ 上采样的势 $\\phi(x)=0.1\\sin(8\\pi x)$。\n\n标记粒子的初始化：\n- 标记粒子位置 $R_p$ 必须是 $[0,L)$ 内的独立均匀采样。\n- 导引中心权重 $w_p^{\\mathrm{gc}}$ 必须是从均值为 $0$、标准差为 $0.1$ 的正态分布中进行的独立采样。\n\n数值方案细节：\n- 一阶云中格点形函数必须将位于位置 $x$ 的标记粒子沉积到最近的两个网格节点上，其权重与到节点的线性距离成比例，并采用周期性边界条件。\n- 在位置 $x$ 处对 $\\phi$ 的插值必须使用相同的云中格点权重。\n\n最终输出要求：\n- 您的程序应产生单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3]”）。\n- 对于五个测试中的每一个，结果是导引中心表示沉积的总网格电荷与拉回映射后粒子空间表示沉积的总网格电荷之间的绝对差值。每个结果都必须是浮点数。",
            "solution": "问题陈述已经过分析，并被认为是有效的。它在科学上植根于计算等离子体物理学的原理，特别是回旋动理学粒子模拟（PIC）方法。该问题定义明确、客观，并包含足够的信息来推导和实现一个独特且有意义的解决方案。问题要求推导一个从导引中心坐标到粒子空间坐标的离散拉回变换，该变换能保存在网格上沉积的总电荷。\n\n问题的核心在于建立一个一致的电荷沉积和势插值数值方案，以保证所需的守恒性质。我们将首先从第一性原理推导电荷守恒条件，然后概述其数值验证的算法。\n\n令 $S(x-x_j)$ 表示一阶云中格点（CIC）形函数，它将位于位置 $x$ 的粒子的权重分配到位置为 $x_j$ 的网格节点上。对于一个长度为 $L$、包含 $N_g$ 个大小为 $\\Delta x = L/N_g$ 的网格单元的一维周期性域，形函数具有构成单位分解的性质：对于任何位置 $x$，都有 $\\sum_{j=0}^{N_g-1} S(x-x_j) = 1$。\n\n我们被要求比较两种从一组回旋动理学标记粒子计算网格上电荷密度 $\\rho_j$ 的方法。每个标记粒子 $p$ 由其导引中心位置 $R_p$ 和导引中心权重 $w_p^{\\mathrm{gc}}$ 定义。其回旋运动由一个包含 $N_\\theta$ 个离散点的环表示，$x_{p,k} = R_p + \\rho_p \\cos\\theta_k$ for $k=0, \\dots, N_\\theta-1$，其中 $\\theta_k = 2\\pi k / N_\\theta$。所有位置都受 $[0, L)$ 上的周期性边界条件约束。\n\n**方法 (a): 导引中心表示**\n在此表示中，每个标记粒子的电荷被“弥散”在其回旋相环上。来自粒子 $p$ 对网格节点 $j$ 的电荷密度贡献是形函数的离散回旋相平均，并按导引中心权重进行缩放。将回旋相平均离散化为对 $N_\\theta$ 个环上点的求和，我们得到：\n$$\n\\rho_{p,j}^{\\mathrm{gc}} = w_p^{\\mathrm{gc}} \\left( \\frac{1}{N_\\theta} \\sum_{k=0}^{N_\\theta-1} S(x_{p,k} - x_j) \\right)\n$$\n这在数值上通过在 $N_\\theta$ 个环上点 $x_{p,k}$ 的每一个点上沉积权重 $w_p^{\\mathrm{gc}}/N_\\theta$ 来实现。\n\n此表示下网格上的总电荷 $Q^{\\mathrm{gc}}$ 是所有网格节点上电荷的总和：\n$$\nQ^{\\mathrm{gc}} = \\sum_{j=0}^{N_g-1} \\sum_{p} \\rho_{p,j}^{\\mathrm{gc}} = \\sum_p w_p^{\\mathrm{gc}} \\frac{1}{N_\\theta} \\sum_{k=0}^{N_\\theta-1} \\left( \\sum_{j=0}^{N_g-1} S(x_{p,k} - x_j) \\right)\n$$\n利用单位分解性质 $\\sum_j S(x_{p,k} - x_j) = 1$，该表达式简化为：\n$$\nQ^{\\mathrm{gc}} = \\sum_p w_p^{\\mathrm{gc}} \\frac{1}{N_\\theta} \\sum_{k=0}^{N_\\theta-1} (1) = \\sum_p w_p^{\\mathrm{gc}}\n$$\n网格上的总电荷就是导引中心权重的总和。\n\n**方法 (b): 粒子空间表示（拉回）**\n拉回变换将导引中心权重 $w_p^{\\mathrm{gc}}$ 映射到一组粒子空间权重 $w_{p,k}^{\\mathrm{ps}}$，离散回旋相环上的每个点对应一个权重。在$\\delta f$回旋动理学中，此变换的一般形式是：\n$$\nw_{p,k}^{\\mathrm{ps}} = w_p^{\\mathrm{gc}} - \\alpha \\left( \\phi(x_{p,k}) - \\langle \\phi \\rangle_{R_p} \\right)\n$$\n这里，$\\alpha$ 是一个给定的系数，$\\phi(x_{p,k})$ 是环上点 $x_{p,k}$ 处的静电势，而 $\\langle \\phi \\rangle_{R_p}$ 是粒子 $p$ 的离散回旋相平均势。我们的任务是定义 $\\langle \\phi \\rangle_{R_p}$ 以使总电荷守恒。\n\n在此表示中，从粒子 $p$ 沉积到节点 $j$ 上的电荷来自在其相应位置 $x_{p,k}$ 处沉积粒子空间权重 $w_{p,k}^{\\mathrm{ps}}$。为保持与方法(a)一致的归一化，我们在每个点 $x_{p,k}$ 处沉积权重 $w_{p,k}^{\\mathrm{ps}}/N_\\theta$：\n$$\n\\rho_{p,j}^{\\mathrm{ps}} = \\frac{1}{N_\\theta} \\sum_{k=0}^{N_\\theta-1} w_{p,k}^{\\mathrm{ps}} S(x_{p,k} - x_j)\n$$\n此表示下网格上的总电荷 $Q^{\\mathrm{ps}}$ 是：\n$$\nQ^{\\mathrm{ps}} = \\sum_{j=0}^{N_g-1} \\sum_p \\rho_{p,j}^{\\mathrm{ps}} = \\sum_p \\frac{1}{N_\\theta} \\sum_{k=0}^{N_\\theta-1} w_{p,k}^{\\mathrm{ps}} \\left( \\sum_{j=0}^{N_g-1} S(x_{p,k} - x_j) \\right)\n$$\n再次使用单位分解性质，这简化为：\n$$\nQ^{\\mathrm{ps}} = \\sum_p \\left( \\frac{1}{N_\\theta} \\sum_{k=0}^{N_\\theta-1} w_{p,k}^{\\mathrm{ps}} \\right)\n$$\n这表明，沉积在网格上的总电荷是所有粒子各自总粒子空间权重之和。\n\n**守恒规则的推导**\n我们要求网格上的总电荷在拉回变换下保持不变，即 $Q^{\\mathrm{gc}} = Q^{\\mathrm{ps}}$。为了使这对任意标记粒子分布都成立，守恒必须在单个粒子的基础上成立：即由粒子 $p$ 沉积的总电荷在两种表示中必须相同。根据上面的表达式，这意味着：\n$$\nw_p^{\\mathrm{gc}} = \\frac{1}{N_\\theta} \\sum_{k=0}^{N_\\theta-1} w_{p,k}^{\\mathrm{ps}}\n$$\n代入 $w_{p,k}^{\\mathrm{ps}}$ 的表达式：\n$$\nw_p^{\\mathrm{gc}} = \\frac{1}{N_\\theta} \\sum_{k=0}^{N_\\theta-1} \\left( w_p^{\\mathrm{gc}} - \\alpha \\left( \\phi(x_{p,k}) - \\langle \\phi \\rangle_{R_p} \\right) \\right)\n$$\n$$\nw_p^{\\mathrm{gc}} = w_p^{\\mathrm{gc}} - \\frac{\\alpha}{N_\\theta} \\sum_{k=0}^{N_\\theta-1} \\left( \\phi(x_{p,k}) - \\langle \\phi \\rangle_{R_p} \\right)\n$$\n为使此方程成立，求和项必须为零：\n$$\n\\sum_{k=0}^{N_\\theta-1} \\left( \\phi(x_{p,k}) - \\langle \\phi \\rangle_{R_p} \\right) = 0\n$$\n$$\n\\sum_{k=0}^{N_\\theta-1} \\phi(x_{p,k}) = \\sum_{k=0}^{N_\\theta-1} \\langle \\phi \\rangle_{R_p} = N_\\theta \\langle \\phi \\rangle_{R_p}\n$$\n这就得出了离散回旋相平均势所需的定义：\n$$\n\\langle \\phi \\rangle_{R_p} = \\frac{1}{N_\\theta} \\sum_{k=0}^{N_\\theta-1} \\phi(x_{p,k})\n$$\n这是回旋相环上离散点处势值的算术平均值。\n\n为了完善该方案，我们必须指定如何计算 $\\phi(x_{p,k})$，因为势 $\\phi$ 仅在网格节点 $x_j$ 上有定义。根据问题要求，我们使用一阶CIC插值，这与沉积方案是一致的：\n$$\n\\phi(x) = \\sum_{j=0}^{N_g-1} \\phi_j S(x-x_j)\n$$\n其中 $\\phi_j = \\phi(x_j)$ 是势的网格值。因此，$\\phi(x_{p,k}) = \\sum_{j=0}^{N_g-1} \\phi_j S(x_{p,k}-x_j)$。\n\n**所推导的离散拉回方案总结：**\n1. 对每个粒子 $p$，生成其回旋相环位置 $\\{x_{p,k}\\}$。\n2. 对每个环上点 $x_{p,k}$，使用CIC插值从网格值 $\\{\\phi_j\\}$ 计算插值势 $\\phi(x_{p,k})$。\n3. 将离散回旋相平均势 $\\langle \\phi \\rangle_{R_p}$ 计算为 $\\phi(x_{p,k})$ 值的算术平均值。\n4. 计算粒子空间权重 $w_{p,k}^{\\mathrm{ps}} = w_p^{\\mathrm{gc}} - \\alpha(\\phi(x_{p,k}) - \\langle \\phi \\rangle_{R_p})$。\n5. 为计算来自导引中心表示的电荷密度，使用CIC方案在每个位置 $x_{p,k}$ 沉积权重 $w_p^{\\mathrm{gc}}/N_\\theta$。\n6. 为计算来自粒子空间表示的电荷密度，使用CIC方案在每个位置 $x_{p,k}$ 沉积权重 $w_{p,k}^{\\mathrm{ps}}/N_\\theta$。\n\n通过这种构造，两种方案中所有沉积权重的总和在数学上是相同的，从而确保网格上的总电荷在浮点精度范围内是守恒的。数值实现将通过计算两种方法得出的总网格电荷的绝对差来验证这一点。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a charge-conserving pullback scheme for a 1D\n    gyrokinetic PIC model, then runs a suite of tests to verify conservation.\n    \"\"\"\n\n    def deposit(grid, pos, weight, L, Ng):\n        \"\"\"\n        Deposits a particle's weight onto the grid using a first-order\n        Cloud-In-Cell (CIC) scheme with periodic boundary conditions.\n        \"\"\"\n        dx = L / Ng\n        norm_pos = pos / dx\n        j_low = int(norm_pos)\n        h = norm_pos - j_low\n        \n        j_low_idx = j_low % Ng\n        j_high_idx = (j_low + 1) % Ng\n        \n        grid[j_low_idx] += weight * (1.0 - h)\n        grid[j_high_idx] += weight * h\n\n    def interpolate(pos, grid, L, Ng):\n        \"\"\"\n        Interpolates a grid quantity to a particle's position using a\n        first-order Cloud-In-Cell (CIC) scheme with periodic boundaries.\n        \"\"\"\n        dx = L / Ng\n        norm_pos = pos / dx\n        j_low = int(norm_pos)\n        h = norm_pos - j_low\n        \n        j_low_idx = j_low % Ng\n        j_high_idx = (j_low + 1) % Ng\n        \n        return grid[j_low_idx] * (1.0 - h) + grid[j_high_idx] * h\n\n    def run_test(L, Ng, Ntheta, Np, rho_val, alpha, phi_func):\n        \"\"\"\n        Executes a single test case for the pullback scheme verification.\n        \"\"\"\n        # --- Setup ---\n        dx = L / Ng\n        grid_nodes = np.linspace(0, L, Ng, endpoint=False)\n        phi_grid = phi_func(grid_nodes)\n        \n        rho_gc_grid = np.zeros(Ng)\n        rho_ps_grid = np.zeros(Ng)\n        \n        # --- Marker Initialization ---\n        # Set seed within the test runner for reproducibility of each test\n        # even if run in different orders or contexts. The problem states a\n        # global seed, but localizing it ensures test independence.\n        np.random.seed(42)\n        gyrocenter_positions = np.random.uniform(0, L, Np)\n        gyrocenter_weights = np.random.normal(0, 0.1, Np)\n        larmor_radii = np.full(Np, rho_val)\n\n        # --- Main Loop over Particles ---\n        for p in range(Np):\n            Rp = gyrocenter_positions[p]\n            w_gc = gyrocenter_weights[p]\n            rho_p = larmor_radii[p]\n\n            # Generate gyro-ring positions\n            thetas = 2 * np.pi * np.arange(Ntheta) / Ntheta\n            # Ensure periodic wrapping into [0, L)\n            x_pk = (Rp + rho_p * np.cos(thetas)) % L\n\n            # --- Method (a): Gyrocenter Deposition ---\n            for k in range(Ntheta):\n                deposit(rho_gc_grid, x_pk[k], w_gc / Ntheta, L, Ng)\n\n            # --- Method (b): Particle-Space Pullback and Deposition ---\n            # 1. Interpolate potential to ring points\n            phi_at_ring_points = np.zeros(Ntheta)\n            for k in range(Ntheta):\n                phi_at_ring_points[k] = interpolate(x_pk[k], phi_grid, L, Ng)\n            \n            # 2. Compute discrete gyro-averaged potential\n            gyro_avg_phi = np.mean(phi_at_ring_points)\n\n            # 3. Compute particle-space weights and deposit\n            for k in range(Ntheta):\n                # Calculate particle-space weight for this segment of the ring\n                w_ps_k = w_gc - alpha * (phi_at_ring_points[k] - gyro_avg_phi)\n                # Deposit this weight\n                deposit(rho_ps_grid, x_pk[k], w_ps_k / Ntheta, L, Ng)\n        \n        # --- Calculate Total Charge and Difference ---\n        total_charge_gc = np.sum(rho_gc_grid)\n        total_charge_ps = np.sum(rho_ps_grid)\n        \n        return abs(total_charge_gc - total_charge_ps)\n\n    # --- Test Suite Definition ---\n    test_cases = [\n        # Test 1: baseline, uniform field\n        (1.0, 32, 8, 50, 0.05, 0.3, lambda x: np.zeros_like(x)),\n        # Test 2: single-mode potential\n        (1.0, 64, 16, 100, 0.04, 1.0, lambda x: 0.1 * np.sin(2 * np.pi * x)),\n        # Test 3: zero Larmor radius\n        (1.0, 64, 8, 75, 0.0, 0.5, lambda x: 0.05 * np.sin(4 * np.pi * x) + 0.02 * np.cos(6 * np.pi * x)),\n        # Test 4: random potential\n        (1.0, 128, 12, 200, 0.03, 0.7, \n         lambda x: 0.2 * np.random.RandomState(42).standard_normal(len(x))),\n        # Test 5: high wavenumber and minimal gyrophase sampling\n        (1.0, 32, 1, 5, 0.1, 2.0, lambda x: 0.1 * np.sin(8 * np.pi * x)),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, Ng, Ntheta, Np, rho_val, alpha, phi_func = case\n        result = run_test(L, Ng, Ntheta, Np, rho_val, alpha, phi_func)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "开发复杂的科学计算代码不仅需要正确的物理模型，还需要严格的验证和确认程序。本练习将指导你设计并实现一套算法一致性检查，以确保极化和磁化闭合在离散形式下满足麦克斯韦方程组的目标阶数。通过这个练习 ，你将学习到一种重要的代码验证技术——人造解方法，并认识到确保数值模型忠实于其所代表的物理定律的重要性。",
            "id": "4033759",
            "problem": "您的任务是为无量纲回旋动理学场模型中的离散极化和磁化闭合设计并实现算法一致性检验，确保在一个小的近单位参数下，麦克斯韦方程组在目标阶上得到满足。计算环境为一个二维周期性域，其中的时变场通过势来定义。这些检验的公式必须适用于通用离散化方法，但在此任务中，您将专门研究均匀网格上的中心差分离散化。\n\n从基本定律和核心定义开始：\n- 无量纲单位（真空介电常数和磁导率均为 $1$）下，关于总源的麦克斯韦方程组为\n$$\n\\nabla \\cdot \\mathbf{E} = \\rho_{\\mathrm{tot}},\\quad \\nabla \\times \\mathbf{B} - \\frac{\\partial \\mathbf{E}}{\\partial t} = \\mathbf{J}_{\\mathrm{tot}}.\n$$\n- 通过极化强度 $\\mathbf{P}$ 和磁化强度 $\\mathbf{M}$ 将源进行本构分裂，分为自由贡献和束缚贡献：\n$$\n\\rho_{\\mathrm{tot}} = \\rho_{\\mathrm{free}} + \\rho_{\\mathrm{bound}},\\quad \\rho_{\\mathrm{bound}} = -\\nabla \\cdot \\mathbf{P},\n$$\n$$\n\\mathbf{J}_{\\mathrm{tot}} = \\mathbf{J}_{\\mathrm{free}} + \\mathbf{J}_{\\mathrm{bound}},\\quad \\mathbf{J}_{\\mathrm{bound}} = \\frac{\\partial \\mathbf{P}}{\\partial t} + \\nabla \\times \\mathbf{M}.\n$$\n- 场由势定义为\n$$\n\\mathbf{E} = - \\nabla \\phi - \\frac{\\partial \\mathbf{A}}{\\partial t},\\quad \\mathbf{B} = \\nabla \\times \\mathbf{A}.\n$$\n\n极化和磁化的闭合源于回旋动理学中的近单位拉回变换。令 $\\epsilon$ 为一个小的无量纲参数，表示近单位拉回的阶，并令 $S(x,y,t)$ 为一个光滑的标量生成函数。定义展开式\n$$\n\\mathbf{P}_{\\mathrm{exact}}(\\epsilon) = \\sum_{k=1}^{3} \\epsilon^k \\mathbf{P}_k,\\quad \\mathbf{M}_{\\mathrm{exact}}(\\epsilon) = \\sum_{k=1}^{3} \\epsilon^k \\mathbf{M}_k,\n$$\n以及通过在 $p$ 阶截断得到的目标阶闭合，\n$$\n\\mathbf{P}_{\\mathrm{trunc}}^{(p)}(\\epsilon) = \\sum_{k=1}^{p} \\epsilon^k \\mathbf{P}_k,\\quad \\mathbf{M}_{\\mathrm{trunc}}^{(p)}(\\epsilon) = \\sum_{k=1}^{p} \\epsilon^k \\mathbf{M}_k,\\quad p \\in \\{0,1,2\\},\n$$\n按照惯例，$\\mathbf{P}_0 \\equiv \\mathbf{0}$ 且 $\\mathbf{M}_0 \\equiv \\mathbf{0}$。\n\n您必须以离散形式检验，在目标阶 $p$ 上的闭合满足麦克斯韦方程组到下一阶，即高斯定律和安培-麦克斯韦定律的残差标度为 $\\mathcal{O}(\\epsilon^{p+1})$。为使问题完全指定且可测试，请使用以下数据：\n- 域：一个边长为 $L = 2\\pi$ 的二维 (2D) 周期性正方形，因此 $(x,y) \\in [0,2\\pi]\\times[0,2\\pi]$。\n- 网格：均匀网格，包含 $N_x = 64$，$N_y = 64$ 个点。\n- 时间：在 $t_0 = 0.37$ 的单个时间快照。\n- 频率：$\\omega = 1.1$。\n- 势：\n$$\n\\phi(x,y,t) = \\Phi_0 \\sin(x)\\cos(y)\\sin(\\omega t),\\quad \\Phi_0 = 0.9,\n$$\n$$\nA_x(x,y,t) = A_0 \\cos(x)\\cos(y)\\cos(\\omega t),\\quad A_0 = 0.7,\n$$\n$$\nA_y(x,y,t) = \\frac{A_0}{2} \\sin(x)\\sin(y)\\sin(\\omega t),\n$$\n$$\nA_z(x,y,t) = \\frac{A_0}{3} \\cos(x)\\sin(y)\\cos(\\omega t).\n$$\n- 生成函数：\n$$\nS(x,y,t) = \\sin(x)\\cos(y)\\cos(\\omega t).\n$$\n- 展开项的系数：\n$$\n\\alpha = 0.7,\\quad \\beta = 0.2,\\quad \\gamma = 0.1,\\quad \\delta = 0.5,\\quad \\eta = 0.3,\\quad \\theta = 0.05.\n$$\n- 在无量纲单位下，$\\mathbf{P}_k$ 和 $\\mathbf{M}_k$ 的展开项：\n$$\n\\mathbf{P}_1 = \\alpha\\, \\nabla S,\\quad \\mathbf{P}_2 = \\beta\\, \\nabla\\!\\left(S^2\\right),\\quad \\mathbf{P}_3 = \\gamma\\, \\nabla\\!\\left(S\\,\\nabla^2 S\\right),\n$$\n$$\n\\mathbf{M}_1 = \\delta\\, S\\, \\hat{\\mathbf{z}},\\quad \\mathbf{M}_2 = \\eta\\, S^2\\, \\hat{\\mathbf{z}},\\quad \\mathbf{M}_3 = \\theta\\, S\\,\\nabla^2 S\\, \\hat{\\mathbf{z}},\n$$\n其中 $\\hat{\\mathbf{z}}$ 表示 $z$ 方向的单位向量，$\\nabla^2$ 是关于 $(x,y)$ 的拉普拉斯算子。\n\n通过强制麦克斯韦方程组对精确闭合精确成立来定义自由源：\n$$\n\\rho_{\\mathrm{free}} = \\rho_{\\mathrm{tot}} + \\nabla \\cdot \\mathbf{P}_{\\mathrm{exact}},\\quad \\mathbf{J}_{\\mathrm{free}} = \\mathbf{J}_{\\mathrm{tot}} - \\frac{\\partial \\mathbf{P}_{\\mathrm{exact}}}{\\partial t} - \\nabla \\times \\mathbf{M}_{\\mathrm{exact}},\n$$\n其中 $\\rho_{\\mathrm{tot}} = \\nabla\\cdot\\mathbf{E}$ 且 $\\mathbf{J}_{\\mathrm{tot}} = \\nabla\\times\\mathbf{B} - \\partial\\mathbf{E}/\\partial t$，且所有空间导数均在给定网格上使用周期性中心差分计算。然后，对于目标阶闭合，预测的总量为\n$$\n\\rho_{\\mathrm{tot}}^{(p)} = \\rho_{\\mathrm{free}} - \\nabla \\cdot \\mathbf{P}_{\\mathrm{trunc}}^{(p)},\\quad \\mathbf{J}_{\\mathrm{tot}}^{(p)} = \\mathbf{J}_{\\mathrm{free}} + \\frac{\\partial \\mathbf{P}_{\\mathrm{trunc}}^{(p)}}{\\partial t} + \\nabla \\times \\mathbf{M}_{\\mathrm{trunc}}^{(p)}.\n$$\n\n将残差场定义为\n$$\n\\mathcal{R}_{G}^{(p)}(\\epsilon) = \\rho_{\\mathrm{tot}} - \\rho_{\\mathrm{tot}}^{(p)},\\quad \\mathcal{R}_{A}^{(p)}(\\epsilon) = \\mathbf{J}_{\\mathrm{tot}} - \\mathbf{J}_{\\mathrm{tot}}^{(p)}.\n$$\n通过网格上的均方根 (RMS) 范数来衡量残差大小，并报告无量纲的相对残差：\n$$\nr_G^{(p)}(\\epsilon) = \\frac{\\left\\|\\mathcal{R}_{G}^{(p)}(\\epsilon)\\right\\|_{2}}{\\left\\|\\rho_{\\mathrm{tot}}\\right\\|_{2}},\\quad r_A^{(p)}(\\epsilon) = \\frac{\\left\\|\\mathcal{R}_{A}^{(p)}(\\epsilon)\\right\\|_{2}}{\\left\\|\\mathbf{J}_{\\mathrm{tot}}\\right\\|_{2}}.\n$$\n使用 $\\epsilon_1 = 0.08$ 和 $\\epsilon_2 = 0.04$ 这两个值，通过以下公式计算观测到的标度指数：\n$$\n\\kappa_G^{(p)} = \\frac{\\log\\left(r_G^{(p)}(\\epsilon_2)/r_G^{(p)}(\\epsilon_1)\\right)}{\\log\\left(\\epsilon_2/\\epsilon_1\\right)},\\quad \\kappa_A^{(p)} = \\frac{\\log\\left(r_A^{(p)}(\\epsilon_2)/r_A^{(p)}(\\epsilon_1)\\right)}{\\log\\left(\\epsilon_2/\\epsilon_1\\right)}.\n$$\n\n您的任务：\n- 在 $N_x \\times N_y$ 网格上实现用于空间导数（包括梯度、散度、旋度和拉普拉斯算子）的周期性中心差分。\n- 计算势、场、精确闭合和目标阶闭合，以及它们在 $t_0$ 时刻所需的导数。\n- 构建 $\\rho_{\\mathrm{free}}$ 和 $\\mathbf{J}_{\\mathrm{free}}$，使得精确闭合满足麦克斯韦方程组，然后计算每个目标阶和每个 $\\epsilon$ 的残差和相对残差。\n- 计算标度指数 $\\kappa_G^{(p)}$ 和 $\\kappa_A^{(p)}$，其中 $p\\in\\{0,1,2\\}$。\n\n测试套件：\n- 情况 1：$p=0$，使用 $\\epsilon_1$ 和 $\\epsilon_2$。\n- 情况 2：$p=1$，使用 $\\epsilon_1$ 和 $\\epsilon_2$。\n- 情况 3：$p=2$，使用 $\\epsilon_1$ 和 $\\epsilon_2$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按以下顺序排列的六个标度指数，格式为方括号内的逗号分隔列表：\n$$\n[\\kappa_G^{(0)},\\kappa_A^{(0)},\\kappa_G^{(1)},\\kappa_A^{(1)},\\kappa_G^{(2)},\\kappa_A^{(2)}].\n$$\n所有报告值必须是无量纲浮点数。整个计算过程必须使用无量纲单位，角度应理解为弧度。不允许用户输入；所有参数和数据如上所述固定并嵌入程序中。",
            "solution": "用户提供了一个计算等离子体物理学中的良定问题，具体涉及回旋动理学模型中使用的极化和磁化闭合的验证。任务是数值验证这些闭合的截断展开在一个小参数 $\\epsilon$ 的特定阶上满足麦克斯韦方程组。这是一种标准的验证程序，通常使用制造解方法实现，即定义源项，使一个已知的解析形式成为离散方程的精确解。\n\n问题的核心在于以下关系。总电荷密度和电流密度 $\\rho_{\\mathrm{tot}}$ 和 $\\mathbf{J}_{\\mathrm{tot}}$ 被分为自由贡献和束缚贡献：$\\rho_{\\mathrm{tot}} = \\rho_{\\mathrm{free}} - \\nabla\\cdot\\mathbf{P}$，$\\mathbf{J}_{\\mathrm{tot}} = \\mathbf{J}_{\\mathrm{free}} + \\frac{\\partial\\mathbf{P}}{\\partial t} + \\nabla\\times\\mathbf{M}$。\n电磁场 $\\mathbf{E}$ 和 $\\mathbf{B}$ 由势 $\\phi$ 和 $\\mathbf{A}$ 导出：$\\mathbf{E} = -\\nabla\\phi - \\frac{\\partial\\mathbf{A}}{\\partial t}$，$\\mathbf{B} = \\nabla\\times\\mathbf{A}$。\n这些场通过麦克斯韦方程组定义了总源：$\\rho_{\\mathrm{tot}} = \\nabla\\cdot\\mathbf{E}$，$\\mathbf{J}_{\\mathrm{tot}} = \\nabla\\times\\mathbf{B} - \\frac{\\partial\\mathbf{E}}{\\partial t}$。\n极化强度 $\\mathbf{P}$ 和磁化强度 $\\mathbf{M}$ 以小参数 $\\epsilon$ 的形式幂级数给出，并在 $p \\in \\{0,1,2\\}$ 阶截断：\n$$\n\\mathbf{P}_{\\mathrm{trunc}}^{(p)}(\\epsilon) = \\sum_{k=1}^{p} \\epsilon^k \\mathbf{P}_k, \\quad \\mathbf{M}_{\\mathrm{trunc}}^{(p)}(\\epsilon) = \\sum_{k=1}^{p} \\epsilon^k \\mathbf{M}_k.\n$$\n问题设置了一个验证测试，其中“精确”闭合通过求和到 $k=3$ 来定义。然后定义“自由”源，使得麦克斯韦方程组对这些“精确”闭合精确成立。接着分析使用截断闭合所产生的残差。一个关键的见解是，残差可以仅用展开式的截断部分来表示，而无需计算自由源。\n\n令 $\\mathbf{\\Delta P}^{(p)} = \\mathbf{P}_{\\mathrm{exact}} - \\mathbf{P}_{\\mathrm{trunc}}^{(p)} = \\sum_{k=p+1}^{3} \\epsilon^k \\mathbf{P}_k$ 和 $\\mathbf{\\Delta M}^{(p)} = \\mathbf{M}_{\\mathrm{exact}} - \\mathbf{M}_{\\mathrm{trunc}}^{(p)} = \\sum_{k=p+1}^{3} \\epsilon^k \\mathbf{M}_k$。这两个差分的领头阶项均为 $\\mathcal{O}(\\epsilon^{p+1})$。\n\n高斯定律中的残差为：\n$$\n\\mathcal{R}_{G}^{(p)} = \\rho_{\\mathrm{tot}} - \\rho_{\\mathrm{tot}}^{(p)} = \\rho_{\\mathrm{tot}} - (\\rho_{\\mathrm{free}} - \\nabla\\cdot\\mathbf{P}_{\\mathrm{trunc}}^{(p)})\n$$\n代入 $\\rho_{\\mathrm{free}} = \\rho_{\\mathrm{tot}} + \\nabla\\cdot\\mathbf{P}_{\\mathrm{exact}}$ 得：\n$$\n\\mathcal{R}_{G}^{(p)} = \\rho_{\\mathrm{tot}} - (\\rho_{\\mathrm{tot}} + \\nabla\\cdot\\mathbf{P}_{\\mathrm{exact}} - \\nabla\\cdot\\mathbf{P}_{\\mathrm{trunc}}^{(p)}) = - \\nabla\\cdot(\\mathbf{P}_{\\mathrm{exact}} - \\mathbf{P}_{\\mathrm{trunc}}^{(p)}) = -\\nabla\\cdot(\\mathbf{\\Delta P}^{(p)}).\n$$\n类似地，安培-麦克斯韦定律中的残差为：\n$$\n\\mathcal{R}_{A}^{(p)} = \\mathbf{J}_{\\mathrm{tot}} - \\mathbf{J}_{\\mathrm{tot}}^{(p)} = \\mathbf{J}_{\\mathrm{tot}} - \\left(\\mathbf{J}_{\\mathrm{free}} + \\frac{\\partial \\mathbf{P}_{\\mathrm{trunc}}^{(p)}}{\\partial t} + \\nabla\\times\\mathbf{M}_{\\mathrm{trunc}}^{(p)}\\right)\n$$\n代入 $\\mathbf{J}_{\\mathrm{free}} = \\mathbf{J}_{\\mathrm{tot}} - \\frac{\\partial \\mathbf{P}_{\\mathrm{exact}}}{\\partial t} - \\nabla\\times\\mathbf{M}_{\\mathrm{exact}}$ 得：\n$$\n\\mathcal{R}_{A}^{(p)} = \\frac{\\partial}{\\partial t}(\\mathbf{P}_{\\mathrm{exact}} - \\mathbf{P}_{\\mathrm{trunc}}^{(p)}) + \\nabla\\times(\\mathbf{M}_{\\mathrm{exact}} - \\mathbf{M}_{\\mathrm{trunc}}^{(p)}) = \\frac{\\partial \\mathbf{\\Delta P}^{(p)}}{\\partial t} + \\nabla\\times\\mathbf{\\Delta M}^{(p)}.\n$$\n由于 $\\mathbf{\\Delta P}^{(p)}$ 和 $\\mathbf{\\Delta M}^{(p)}$ 是 $\\mathcal{O}(\\epsilon^{p+1})$ 阶的，残差 $\\mathcal{R}_{G}^{(p)}$ 和 $\\mathcal{R}_{A}^{(p)}$ 预期也为 $\\mathcal{O}(\\epsilon^{p+1})$ 阶。这意味着观测到的标度指数 $\\kappa^{(p)}$ 应接近 $p+1$。\n\n该解决方案涉及以下计算步骤：\n1.  **离散化**：在域 $[0, 2\\pi] \\times [0, 2\\pi]$ 上建立一个包含 $N_x = N_y = 64$ 个点的均匀网格。所有空间导数（梯度、散度、旋度、拉普拉斯算子）都使用二阶周期性中心有限差分实现。对于网格间距为 $\\Delta x, \\Delta y$ 的网格上的函数 $f_{i,j}$：\n    $$\n    (\\partial_x f)_{i,j} \\approx \\frac{f_{i,j+1} - f_{i,j-1}}{2 \\Delta x}, \\quad (\\partial_y f)_{i,j} \\approx \\frac{f_{i+1,j} - f_{i-1,j}}{2 \\Delta y}.\n    $$\n2.  **场和源的计算**：在时间 $t_0$ 在网格上计算势 $\\phi, \\mathbf{A}$ 和生成函数 $S$。使用离散微分算子从势计算电磁场 $\\mathbf{E}$ 和 $\\mathbf{B}$。随后，通过麦克斯韦方程组，再次使用离散算子从 $\\mathbf{E}$ 和 $\\mathbf{B}$ 计算总源项 $\\rho_{\\mathrm{tot}}$ 和 $\\mathbf{J}_{\\mathrm{tot}}$。这些源用作相对残差的归一化因子。\n3.  **闭合项的计算**：计算在 $t_0$ 时的基本展开项 $\\mathbf{P}_k$ 和 $\\mathbf{M}_k$ 及其时间导数。这需要计算 $S$、$\\nabla S$、$S^2$ 和 $S\\,\\nabla^2 S$，以及它们的时间导数。\n4.  **残差和标度分析**：对于每个截断阶 $p \\in \\{0, 1, 2\\}$，我们执行以下操作：\n    a. 对于每个 $\\epsilon \\in \\{\\epsilon_1, \\epsilon_2\\}$，组装差分项 $\\mathbf{\\Delta P}^{(p)}(\\epsilon)$ 和 $\\mathbf{\\Delta M}^{(p)}(\\epsilon)$ 及其时间导数。\n    b. 使用上面导出的简化表达式计算残差 $\\mathcal{R}_{G}^{(p)}(\\epsilon)$ 和 $\\mathcal{R}_{A}^{(p)}(\\epsilon)$。\n    c. 计算残差和总源的均方根（RMS）范数。然后计算相对残差 $r_G^{(p)}(\\epsilon)$ 和 $r_A^{(p)}(\\epsilon)$。\n    d. 最后，使用两点公式从 $\\epsilon_1$ 和 $\\epsilon_2$ 处的相对残差确定标度指数 $\\kappa_G^{(p)}$ 和 $\\kappa_A^{(p)}$：\n    $$\n    \\kappa^{(p)} = \\frac{\\log\\left(r^{(p)}(\\epsilon_2)/r^{(p)}(\\epsilon_1)\\right)}{\\log\\left(\\epsilon_2/\\epsilon_1\\right)}.\n    $$\n\n此过程系统地测试了截断闭合的一致性，并验证了误差如预期随展开参数 $\\epsilon$ 变化。最终输出包含六个计算出的标度指数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the gyrokinetic closure validation problem.\n    \"\"\"\n    # 1. Define constants and grid\n    # ============================\n    # Domain and Grid\n    L = 2 * np.pi\n    Nx, Ny = 64, 64\n    dx = L / Nx\n    dy = L / Ny\n    x = np.arange(Nx) * dx\n    y = np.arange(Ny) * dy\n    X, Y = np.meshgrid(x, y, indexing='xy') # Match (x,y) to (axis 1, axis 0)\n    \n    # Time and frequency\n    t0 = 0.37\n    omega = 1.1\n\n    # Amplitudes and coefficients\n    Phi0 = 0.9\n    A0 = 0.7\n    alpha = 0.7\n    beta = 0.2\n    gamma = 0.1\n    delta = 0.5\n    eta = 0.3\n    theta = 0.05\n\n    # Expansion parameters\n    eps1 = 0.08\n    eps2 = 0.04\n    epsilons = [eps1, eps2]\n\n    # 2. Define numerical derivative functions\n    # ======================================\n    def grad(f):\n        df_dx = (np.roll(f, -1, axis=1) - np.roll(f, 1, axis=1)) / (2 * dx)\n        df_dy = (np.roll(f, -1, axis=0) - np.roll(f, 1, axis=0)) / (2 * dy)\n        return df_dx, df_dy\n\n    def div(vx, vy):\n        dvx_dx = (np.roll(vx, -1, axis=1) - np.roll(vx, 1, axis=1)) / (2 * dx)\n        dvy_dy = (np.roll(vy, -1, axis=0) - np.roll(vy, 1, axis=0)) / (2 * dy)\n        return dvx_dx + dvy_dy\n\n    def curl_scalar_z(f): # Curl of a field F = (0, 0, f)\n        df_dy = (np.roll(f, -1, axis=0) - np.roll(f, 1, axis=0)) / (2 * dy)\n        df_dx = (np.roll(f, -1, axis=1) - np.roll(f, 1, axis=1)) / (2 * dx)\n        return df_dy, -df_dx\n\n    def lap(f):\n        d2f_dx2 = (np.roll(f, -1, axis=1) - 2 * f + np.roll(f, 1, axis=1)) / (dx**2)\n        d2f_dy2 = (np.roll(f, -1, axis=0) - 2 * f + np.roll(f, 1, axis=0)) / (dy**2)\n        return d2f_dx2 + d2f_dy2\n\n    def rms(field):\n        if isinstance(field, tuple) or isinstance(field, list):\n            return np.sqrt(np.mean(sum(f**2 for f in field)))\n        return np.sqrt(np.mean(field**2))\n\n    # 3. Evaluate potentials and their time derivatives at t0\n    # ========================================================\n    phi = Phi0 * np.sin(X) * np.cos(Y) * np.sin(omega * t0)\n    Ax = A0 * np.cos(X) * np.cos(Y) * np.cos(omega * t0)\n    Ay = (A0 / 2) * np.sin(X) * np.sin(Y) * np.sin(omega * t0)\n    Az = (A0 / 3) * np.cos(X) * np.sin(Y) * np.cos(omega * t0)\n\n    dphi_dt = Phi0 * omega * np.sin(X) * np.cos(Y) * np.cos(omega * t0)\n    dAx_dt = -A0 * omega * np.cos(X) * np.cos(Y) * np.sin(omega * t0)\n    dAy_dt = (A0 / 2) * omega * np.sin(X) * np.sin(Y) * np.cos(omega * t0)\n    dAz_dt = -(A0 / 3) * omega * np.cos(X) * np.sin(Y) * np.sin(omega * t0)\n    \n    # 4. Calculate E and B fields\n    # ============================\n    dphi_dx, dphi_dy = grad(phi)\n    Ex = -dphi_dx - dAx_dt\n    Ey = -dphi_dy - dAy_dt\n    Ez = -dAz_dt\n\n    dAz_dx, dAz_dy = grad(Az)\n    dAy_dx, dAy_dy = grad(Ay)\n    dAx_dx, dAx_dy = grad(Ax)\n    Bx = dAz_dy\n    By = -dAz_dx\n    Bz = dAy_dx - dAx_dy\n\n    # 5. Calculate total sources and their norms\n    # ==========================================\n    rho_tot = div(Ex, Ey)\n\n    d2phi_dt2 = -Phi0 * omega**2 * np.sin(X) * np.cos(Y) * np.sin(omega * t0)\n    d2Ax_dt2 = -A0 * omega**2 * np.cos(X) * np.cos(Y) * np.cos(omega * t0)\n    d2Ay_dt2 = -(A0 / 2) * omega**2 * np.sin(X) * np.sin(Y) * np.sin(omega * t0)\n    d2Az_dt2 = -(A0 / 3) * omega**2 * np.cos(X) * np.sin(Y) * np.cos(omega * t0)\n\n    d_dphi_dt_dx, d_dphi_dt_dy = grad(dphi_dt)\n    dEx_dt = -d_dphi_dt_dx - d2Ax_dt2\n    dEy_dt = -d_dphi_dt_dy - d2Ay_dt2\n    dEz_dt = -d2Az_dt2\n    \n    dBz_dx, dBz_dy = grad(Bz)\n    dBy_dx, dBy_dy = grad(By)\n    dBx_dx, dBx_dy = grad(Bx)\n    \n    J_tot_x = dBz_dy - dEx_dt\n    J_tot_y = -dBz_dx - dEy_dt\n    J_tot_z = dBy_dx - dBx_dy - dEz_dt\n\n    norm_rho_tot = rms(rho_tot)\n    norm_J_tot = rms([J_tot_x, J_tot_y, J_tot_z])\n\n    # 6. Calculate P_k, M_k base terms and their time derivatives\n    # ============================================================\n    S = np.sin(X) * np.cos(Y) * np.cos(omega * t0)\n    dS_dt = -omega * np.sin(X) * np.cos(Y) * np.sin(omega * t0)\n    \n    # P1, M1\n    P1_x, P1_y = grad(alpha * S)\n    M1_z = delta * S\n    dP1_dt_x, dP1_dt_y = grad(alpha * dS_dt)\n    dM1_dt_z = delta * dS_dt\n    \n    # P2, M2\n    P2_x, P2_y = grad(beta * S**2)\n    M2_z = eta * S**2\n    dP2_dt_x, dP2_dt_y = grad(beta * 2 * S * dS_dt)\n    dM2_dt_z = eta * 2 * S * dS_dt\n    \n    # P3, M3\n    lap_S = lap(S)\n    lap_dS_dt = lap(dS_dt)\n    P3_x, P3_y = grad(gamma * S * lap_S)\n    M3_z = theta * S * lap_S\n    \n    term_for_P3_M3_dt = (dS_dt * lap_S) + (S * lap_dS_dt)\n    dP3_dt_x, dP3_dt_y = grad(gamma * term_for_P3_M3_dt)\n    dM3_dt_z = theta * term_for_P3_M3_dt\n\n    Ps = [(P1_x, P1_y), (P2_x, P2_y), (P3_x, P3_y)]\n    dPs_dt = [(dP1_dt_x, dP1_dt_y), (dP2_dt_x, dP2_dt_y), (dP3_dt_x, dP3_dt_y)]\n    Ms_z = [M1_z, M2_z, M3_z]\n\n    # 7. Main calculation loop\n    # ========================\n    all_kappas = []\n    for p in range(3): # p = 0, 1, 2\n        r_G_vals, r_A_vals = [], []\n        for eps in epsilons:\n            # Assemble truncated parts of expansions\n            delta_P_x, delta_P_y = np.zeros_like(X), np.zeros_like(X)\n            d_dt_delta_P_x, d_dt_delta_P_y = np.zeros_like(X), np.zeros_like(X)\n            delta_M_z = np.zeros_like(X)\n\n            for k_idx in range(p, 3):\n                k = k_idx + 1\n                delta_P_x += eps**k * Ps[k_idx][0]\n                delta_P_y += eps**k * Ps[k_idx][1]\n                d_dt_delta_P_x += eps**k * dPs_dt[k_idx][0]\n                d_dt_delta_P_y += eps**k * dPs_dt[k_idx][1]\n                delta_M_z += eps**k * Ms_z[k_idx]\n                \n            # Calculate residuals\n            R_G = -div(delta_P_x, delta_P_y)\n            curl_delta_M_x, curl_delta_M_y = curl_scalar_z(delta_M_z)\n            \n            R_A_x = d_dt_delta_P_x + curl_delta_M_x\n            R_A_y = d_dt_delta_P_y + curl_delta_M_y\n\n            # Calculate relative residuals\n            r_G = rms(R_G) / norm_rho_tot\n            r_A = rms([R_A_x, R_A_y]) / norm_J_tot\n            r_G_vals.append(r_G)\n            r_A_vals.append(r_A)\n        \n        # Calculate scaling exponents\n        kappa_G = np.log(r_G_vals[1] / r_G_vals[0]) / np.log(eps2 / eps1)\n        kappa_A = np.log(r_A_vals[1] / r_A_vals[0]) / np.log(eps2 / eps1)\n        all_kappas.extend([kappa_G, kappa_A])\n\n    # 8. Print final results\n    # ======================\n    print(f\"[{','.join(f'{k:.6f}' for k in all_kappas)}]\")\n\nsolve()\n```"
        }
    ]
}