{
    "hands_on_practices": [
        {
            "introduction": "A powerful application of pullback transformations in gyrokinetics is the systematic reduction of complex dynamics by averaging over the fastest timescales. This exercise provides foundational practice in this technique by guiding you through the derivation of the bounce-center Hamiltonian for a trapped particle. By using a Hamiltonian Lie-transform to average over the fast bounce motion, you will connect the abstract formalism to tangible physical parameters like the magnetic mirror ratio and field curvature. ",
            "id": "4033770",
            "problem": "Consider a single, trapped ion of mass $m$ and charge $q$ in a static, axisymmetric, large-aspect-ratio toroidal magnetic confinement device. The ionâ€™s dynamics are described within the guiding-center and gyrokinetic frameworks, and you will construct the bounce-center (BC) description to leading order by means of a pullback transformation generated by a Hamiltonian Lie-transform (HLT). The magnitude of the magnetic field along a chosen field line is modeled near its minimum as a smooth function of the arclength coordinate $s$,\n$$\nB(s) \\equiv B_{0}\\left[1 + (R_{m}-1)\\,\\frac{s^{2}}{s_{m}^{2}}\\right],\n$$\nwhere $B_{0}$ is the minimum field strength at $s=0$, $s_{m}>0$ is the arclength location of the turning points that bound the local magnetic well, and $R_{m} \\equiv B_{\\max}/B_{0} > 1$ is the magnetic mirror ratio. Assume there is no electrostatic potential and neglect drift-order corrections beyond leading order. The ion has a fixed magnetic moment $\\mu$ and undergoes small-amplitude bounce oscillations about $s=0$.\n\nStarting from appropriate fundamental laws and core definitions for guiding-center and bounce-center dynamics in gyrokinetics (GK), including the guiding-center Hamiltonian and the leading-order equations of motion along the field line, use the Hamiltonian Lie-transform pullback to eliminate the fast bounce phase and construct the leading-order bounce-center Hamiltonian $H_{\\mathrm{BC}}^{(0)}$ as a function of the bounce action $J_{b}$. Your derivation must:\n- Begin from the guiding-center Hamiltonian expressed in terms of the parallel canonical momentum and the magnetic moment,\n- Linearize the parallel dynamics about $s=0$ to obtain the small-amplitude bounce frequency,\n- Define the bounce action $J_{b}$ associated with the parallel oscillation,\n- Perform the leading-order averaging over the bounce phase consistent with the pullback transformation to the bounce-center.\n\nIdentify within your final expression the terms that depend on the magnetic mirror ratio $R_{m}$ and the local field-strength curvature through derivatives of $B(s)$ at $s=0$. Express the final answer as a single closed-form analytic expression for $H_{\\mathrm{BC}}^{(0)}$ in terms of $J_{b}$, $\\mu$, $B_{0}$, $R_{m}$, $s_{m}$, and $m$. No numerical evaluation is required. If you introduce any acronyms, spell them out on first use, e.g., Gyrokinetic (GK), Bounce Center (BC), Hamiltonian Lie-transform (HLT).",
            "solution": "The problem statement is a well-posed and scientifically grounded exercise in advanced plasma physics, specifically within the topic of gyrokinetics and Hamiltonian mechanics. It requests the derivation of the leading-order bounce-center Hamiltonian for a trapped ion under a specific set of valid physical approximations. All provided information is self-consistent and sufficient for the derivation. The problem is therefore deemed valid.\n\nThe objective is to construct the leading-order bounce-center (BC) Hamiltonian, $H_{\\mathrm{BC}}^{(0)}$, for a trapped ion by averaging over its fast bounce motion. This is achieved using a Hamiltonian Lie-transform (HLT) pullback, which, to leading order, is equivalent to phase-averaging. The derivation proceeds in four steps.\n\nFirst, we establish the Guiding-Center (GC) Hamiltonian. In the absence of an electrostatic potential, the GC Hamiltonian, $H_{\\mathrm{GC}}$, is the kinetic energy of the particle expressed in GC variables. It is the sum of the kinetic energy associated with motion parallel to the magnetic field and the energy of gyromotion.\n$$\nH_{\\mathrm{GC}} = \\frac{p_{\\parallel}^{2}}{2m} + \\mu B\n$$\nHere, $p_{\\parallel} = m v_{\\parallel}$ is the parallel canonical momentum (and kinetic momentum, as the magnetic vector potential contribution is handled by the GC transformation), $m$ is the ion mass, $\\mu$ is the magnetic moment (an adiabatic invariant), and $B$ is the magnetic field strength. The problem provides the spatial dependence of the magnetic field magnitude along a field line, parameterized by the arclength $s$:\n$$\nB(s) = B_{0}\\left[1 + (R_{m}-1)\\frac{s^{2}}{s_{m}^{2}}\\right]\n$$\nwhere $B_{0}$ is the minimum field strength at $s=0$, $R_{m}$ is the mirror ratio, and $s_{m}$ is a characteristic length scale of the magnetic well. Substituting this into the GC Hamiltonian gives:\n$$\nH_{\\mathrm{GC}}(s, p_{\\parallel}) = \\frac{p_{\\parallel}^{2}}{2m} + \\mu B_{0}\\left[1 + (R_{m}-1)\\frac{s^{2}}{s_{m}^{2}}\\right]\n$$\nThis Hamiltonian is a constant of motion for the GC dynamics.\n\nSecond, we analyze the parallel dynamics to find the bounce frequency. The equations of motion for the parallel coordinates $(s, p_{\\parallel})$ are given by Hamilton's equations:\n$$\n\\dot{s} = \\frac{\\partial H_{\\mathrm{GC}}}{\\partial p_{\\parallel}} = \\frac{p_{\\parallel}}{m}\n$$\n$$\n\\dot{p}_{\\parallel} = -\\frac{\\partial H_{\\mathrm{GC}}}{\\partial s} = -\\mu B_{0} (R_{m}-1) \\frac{2s}{s_{m}^{2}}\n$$\nDifferentiating $\\dot{s}$ with respect to time and substituting $\\dot{p}_{\\parallel}$ yields the equation of motion for the coordinate $s$:\n$$\n\\ddot{s} = \\frac{\\dot{p}_{\\parallel}}{m} = -\\left[ \\frac{2 \\mu B_{0} (R_{m}-1)}{m s_{m}^{2}} \\right] s\n$$\nThis is the equation for a simple harmonic oscillator, $\\ddot{s} + \\omega_{b}^{2}s = 0$. By comparing the two forms, we identify the square of the small-amplitude bounce frequency, $\\omega_{b}$:\n$$\n\\omega_{b}^{2} = \\frac{2 \\mu B_{0} (R_{m}-1)}{m s_{m}^{2}}\n$$\nThe bounce frequency is therefore:\n$$\n\\omega_{b} = \\sqrt{\\frac{2 \\mu B_{0} (R_{m}-1)}{m s_{m}^{2}}}\n$$\n\nThird, we define the bounce action, $J_{b}$. The bounce action is the canonical action variable conjugate to the bounce phase angle. For a one-dimensional harmonic oscillator, the action $J$ is related to its energy $E_{\\mathrm{osc}}$ and frequency $\\omega$ by $E_{\\mathrm{osc}} = J \\omega$. In our case, the \"oscillator energy\" is the portion of the Hamiltonian associated with the parallel motion, which we can define as $H_{\\parallel} = H_{\\mathrm{GC}} - \\mu B_{0}$.\n$$\nH_{\\parallel}(s, p_{\\parallel}) = \\frac{p_{\\parallel}^{2}}{2m} + \\mu \\left( B(s) - B_{0} \\right) = \\frac{p_{\\parallel}^{2}}{2m} + \\mu B_{0} (R_{m}-1)\\frac{s^{2}}{s_{m}^{2}}\n$$\nThis represents the energy of the harmonic oscillation. As $H_{\\mathrm{GC}}$ is a constant of motion, so is $H_{\\parallel}$. The bounce action $J_{b}$ is related to this energy by:\n$$\nJ_{b} = \\frac{H_{\\parallel}}{\\omega_{b}} = \\frac{H_{\\mathrm{GC}} - \\mu B_{0}}{\\omega_{b}}\n$$\n\nFourth, we construct the leading-order bounce-center Hamiltonian, $H_{\\mathrm{BC}}^{(0)}$. The HLT pullback to the BC frame is designed to eliminate the dependence on the fast bounce phase. To leading order, the resulting Hamiltonian $H_{\\mathrm{BC}}^{(0)}$ is the bounce-average of the original Hamiltonian $H_{\\mathrm{GC}}$. The averaging process transforms the Hamiltonian from a function of $(s, p_{\\parallel})$ to a function of the bounce action $J_{b}$. From the relationship derived in the third step, we can express $H_{\\mathrm{GC}}$ entirely in terms of quantities that are constant over a bounce period: $J_{b}$, $\\mu$, and the parameters of the magnetic field.\n$$\nH_{\\mathrm{GC}} = J_{b} \\omega_{b} + \\mu B_{0}\n$$\nSince this expression is already independent of the bounce phase, its average over the bounce motion is simply itself. Therefore, the leading-order BC Hamiltonian is:\n$$\nH_{\\mathrm{BC}}^{(0)}(J_{b}) = J_{b} \\omega_{b} + \\mu B_{0}\n$$\nSubstituting the expression for $\\omega_{b}$:\n$$\nH_{\\mathrm{BC}}^{(0)}(J_{b}) = J_{b} \\sqrt{\\frac{2 \\mu B_{0} (R_{m}-1)}{m s_{m}^{2}}} + \\mu B_{0}\n$$\nAs requested, we identify the dependencies. The first term, $J_b \\omega_b$, depends on the magnetic mirror ratio $R_{m}$ through the factor $(R_{m}-1)$. This term also depends on the local field-strength curvature at $s=0$. The second derivative of the magnetic field is $B''(s) = \\frac{d^{2}B}{ds^{2}} = \\frac{2 B_{0} (R_{m}-1)}{s_{m}^{2}}$. Thus, the bounce frequency can be written as $\\omega_{b} = \\sqrt{\\mu B''(0)/m}$. The bounce-center Hamiltonian's first term is directly proportional to the square root of this curvature, demonstrating the link between the trapping potential's shape and the particle's bounce dynamics. The final expression is presented in terms of the given parameters.",
            "answer": "$$\\boxed{J_{b} \\sqrt{\\frac{2 \\mu B_{0} (R_{m} - 1)}{m s_{m}^{2}}} + \\mu B_{0}}$$"
        },
        {
            "introduction": "Gyrokinetic models rely on gyro-averaging, a core component of the pullback from particle to gyrocenter coordinates, which introduces operators like the Bessel function $J_0(k_{\\perp}\\rho)$. In practice, these operators are often approximated, for instance by truncating a series expansion. This practice asks you to quantify the cumulative error that arises from such a truncation, offering a concrete look at how theoretical approximations impact the long-term accuracy of simulated particle drifts. ",
            "id": "4033713",
            "problem": "Consider a uniform magnetic field $\\mathbf{B} = B \\,\\hat{\\mathbf{z}}$ and a single-mode, electrostatic, perpendicular plane-wave potential $\\phi(\\mathbf{r}) = \\Phi_0 \\cos(\\mathbf{k}_{\\perp} \\cdot \\mathbf{r})$ with $|\\mathbf{k}_{\\perp}| = k_{\\perp}$, where $\\Phi_0$ is a constant amplitude. A charged particle of mass $m$ and charge $q$ undergoes rapid gyromotion with cyclotron frequency $\\Omega \\equiv |q| B/(m c)$ and Larmor radius $\\rho \\equiv v_{\\perp}/\\Omega$, where $v_{\\perp}$ is the perpendicular speed. In the gyrokinetic description, the slow drift dynamics of the gyrocenter position $\\mathbf{X}$ are obtained by the pullback transformation from particle to gyrocenter coordinates, which renders the gyroaveraged potential entering the gyrocenter equations of motion. For a single perpendicular plane-wave mode, the gyroaveraging of the pullback transformation yields $\\phi_{\\text{gy}}(\\mathbf{X}) = \\Phi_0 J_0(k_{\\perp} \\rho) \\cos(\\mathbf{k}_{\\perp} \\cdot \\mathbf{X})$, where $J_0$ is the zero-order Bessel function of the first kind.\n\nAssume the particle remains in a small neighborhood of a point $\\mathbf{X}_0$ such that the spatial variation of $\\nabla \\phi_{\\text{gy}}$ can be treated as locally constant over the times considered (i.e., the drift displacement is small enough that $|\\mathbf{k}_{\\perp} \\cdot (\\mathbf{X}-\\mathbf{X}_0)| \\ll 1$). Under this local approximation, the gyroaveraged $\\mathbf{E}\\times\\mathbf{B}$ drift is $\\mathbf{v}_E \\approx (c/B)\\,\\hat{\\mathbf{z}} \\times \\nabla \\phi_{\\text{gy}}(\\mathbf{X}_0)$, and its magnitude is $V_E \\approx (c/B)\\,k_{\\perp} \\Phi_0 J_0(k_{\\perp} \\rho)$. Suppose, instead of evaluating $J_0(k_{\\perp} \\rho)$ exactly, one truncates its Maclaurin series at order $p \\in \\mathbb{N}_0$, using\n$$\nJ_0(x) \\approx J_0^{(p)}(x) \\equiv \\sum_{n=0}^{p} (-1)^{n} \\frac{(x^2/4)^{n}}{(n!)^2}.\n$$\nThis truncation induces an error in the drift speed, which, over time, accumulates into a phase error when the drift displacement is measured against the wave phase of the mode with wavenumber $k_{\\perp}$. Define the cumulative drift phase as $\\varphi(t) \\equiv k_{\\perp} \\Delta s(t)$, where $\\Delta s(t)$ is the drift displacement along the direction orthogonal to $\\mathbf{k}_{\\perp}$ produced by $\\mathbf{v}_E$ over time $t$. Over $N$ cyclotron periods, with $T_c \\equiv 2\\pi/\\Omega$, the cumulative phase error due to truncating the Bessel series is $\\Delta \\varphi(N) \\equiv \\varphi_{\\text{exact}}(N T_c) - \\varphi_{\\text{trunc}}(N T_c)$.\n\nStarting from the Lorentz force law and the definition of the $\\mathbf{E}\\times\\mathbf{B}$ drift, together with the gyroaveraged field provided by the pullback transformation, derive an analytic expression for $\\Delta \\varphi(N)$ in terms of $N$, $k_{\\perp}$, $\\rho$, $\\Phi_0$, $B$, $c$, and $\\Omega$, using the truncation $J_0^{(p)}(k_{\\perp} \\rho)$ specified above. Express the final phase error in radians, as a single closed-form expression.",
            "solution": "The problem has been validated and is deemed a well-posed, scientifically grounded problem in computational plasma physics. It is self-contained, consistent, and free of invalidating flaws. We proceed with the derivation.\n\nThe objective is to find the cumulative phase error $\\Delta \\varphi(N)$ which arises from truncating the Bessel function in the expression for the gyroaveraged $\\mathbf{E}\\times\\mathbf{B}$ drift. The phase error is defined as the difference between the exact phase and the truncated phase after $N$ cyclotron periods:\n$$\n\\Delta \\varphi(N) \\equiv \\varphi_{\\text{exact}}(N T_c) - \\varphi_{\\text{trunc}}(N T_c)\n$$\nwhere $T_c = 2\\pi/\\Omega$ is the cyclotron period.\n\nThe cumulative drift phase is given by $\\varphi(t) = k_{\\perp} \\Delta s(t)$, where $\\Delta s(t)$ is the displacement of the gyrocenter over time $t$ along the direction orthogonal to the wavevector $\\mathbf{k}_{\\perp}$. The problem states that the drift velocity $\\mathbf{v}_E$ is considered constant in the local approximation. The drift velocity is given by $\\mathbf{v}_E \\approx (c/B)\\,\\hat{\\mathbf{z}} \\times \\nabla \\phi_{\\text{gy}}(\\mathbf{X}_0)$. Since $\\nabla \\phi_{\\text{gy}} \\propto \\mathbf{k}_{\\perp}$ and $\\mathbf{k}_{\\perp}$ is perpendicular to $\\hat{\\mathbf{z}}$, the vector $\\hat{\\mathbf{z}} \\times \\mathbf{k}_{\\perp}$ is perpendicular to $\\mathbf{k}_{\\perp}$. Thus, the drift displacement $\\Delta \\mathbf{s}(t) = \\mathbf{v}_E t$ is entirely in the direction orthogonal to $\\mathbf{k}_{\\perp}$. The magnitude of this displacement is $\\Delta s(t) = V_E t$, where $V_E = |\\mathbf{v}_E|$.\n\nThe cumulative phase at time $t$ is therefore $\\varphi(t) = k_{\\perp} V_E t$.\nThe magnitude of the drift velocity is given as $V_E \\approx (c/B)\\,k_{\\perp} \\Phi_0 J_0(k_{\\perp} \\rho)$. This forms the basis for both the exact and truncated calculations.\n\nFirst, we calculate the exact cumulative phase, $\\varphi_{\\text{exact}}$. The exact drift speed, $V_{E, \\text{exact}}$, uses the complete Bessel function $J_0(k_{\\perp} \\rho)$:\n$$\nV_{E, \\text{exact}} = \\frac{c k_{\\perp} \\Phi_0}{B} J_0(k_{\\perp} \\rho)\n$$\nThe total time elapsed is $t = N T_c = 2\\pi N/\\Omega$. The exact phase is:\n$$\n\\varphi_{\\text{exact}}(N T_c) = k_{\\perp} V_{E, \\text{exact}} (N T_c) = k_{\\perp} \\left( \\frac{c k_{\\perp} \\Phi_0}{B} J_0(k_{\\perp} \\rho) \\right) \\left( \\frac{2\\pi N}{\\Omega} \\right)\n$$\n$$\n\\varphi_{\\text{exact}}(N T_c) = \\frac{2\\pi N c \\Phi_0 k_{\\perp}^2}{B \\Omega} J_0(k_{\\perp} \\rho)\n$$\nNext, we calculate the phase using the truncated approximation, $\\varphi_{\\text{trunc}}$. The drift speed is now based on the truncated Bessel function, $J_0^{(p)}(k_{\\perp} \\rho)$:\n$$\nJ_0^{(p)}(x) \\equiv \\sum_{n=0}^{p} (-1)^{n} \\frac{(x^2/4)^{n}}{(n!)^2}\n$$\nThe truncated drift speed is:\n$$\nV_{E, \\text{trunc}} = \\frac{c k_{\\perp} \\Phi_0}{B} J_0^{(p)}(k_{\\perp} \\rho)\n$$\nThe truncated phase is:\n$$\n\\varphi_{\\text{trunc}}(N T_c) = k_{\\perp} V_{E, \\text{trunc}} (N T_c) = k_{\\perp} \\left( \\frac{c k_{\\perp} \\Phi_0}{B} J_0^{(p)}(k_{\\perp} \\rho) \\right) \\left( \\frac{2\\pi N}{\\Omega} \\right)\n$$\n$$\n\\varphi_{\\text{trunc}}(N T_c) = \\frac{2\\pi N c \\Phi_0 k_{\\perp}^2}{B \\Omega} J_0^{(p)}(k_{\\perp} \\rho)\n$$\nThe cumulative phase error $\\Delta \\varphi(N)$ is the difference between these two quantities:\n$$\n\\Delta \\varphi(N) = \\varphi_{\\text{exact}}(N T_c) - \\varphi_{\\text{trunc}}(N T_c)\n$$\n$$\n\\Delta \\varphi(N) = \\frac{2\\pi N c \\Phi_0 k_{\\perp}^2}{B \\Omega} J_0(k_{\\perp} \\rho) - \\frac{2\\pi N c \\Phi_0 k_{\\perp}^2}{B \\Omega} J_0^{(p)}(k_{\\perp} \\rho)\n$$\nFactoring out the common terms, we get:\n$$\n\\Delta \\varphi(N) = \\frac{2\\pi N c \\Phi_0 k_{\\perp}^2}{B \\Omega} \\left( J_0(k_{\\perp} \\rho) - J_0^{(p)}(k_{\\perp} \\rho) \\right)\n$$\nSubstituting the definition of the truncated series $J_0^{(p)}$, we arrive at the final expression for the phase error:\n$$\n\\Delta \\varphi(N) = \\frac{2\\pi N c \\Phi_0 k_{\\perp}^2}{B \\Omega} \\left( J_0(k_{\\perp} \\rho) - \\sum_{n=0}^{p} \\frac{(-1)^{n}}{(n!)^2} \\left( \\frac{k_{\\perp}^2 \\rho^2}{4} \\right)^{n} \\right)\n$$\nThis expression provides the phase error in radians as a single closed-form expression, dependent on the prescribed parameters $N$, $k_{\\perp}$, $\\rho$, $\\Phi_0$, $B$, $c$, and $\\Omega$, and the truncation order $p$.\nThe term in the parenthesis represents the remainder of the Taylor series for $J_0(k_{\\perp}\\rho)$ after the $p$-th order term, which can be expressed as an infinite sum starting from $n=p+1$:\n$$\nJ_0(k_{\\perp} \\rho) - J_0^{(p)}(k_{\\perp} \\rho) = \\sum_{n=p+1}^{\\infty} \\frac{(-1)^{n}}{(n!)^2} \\left( \\frac{k_{\\perp}^2 \\rho^2}{4} \\right)^{n}\n$$\nThe derived expression is thus the complete and correct analytical result.",
            "answer": "$$\\boxed{\\frac{2\\pi N c \\Phi_0 k_{\\perp}^2}{B \\Omega} \\left( J_0(k_{\\perp} \\rho) - \\sum_{n=0}^{p} \\frac{(-1)^{n}}{(n!)^2} \\left( \\frac{k_{\\perp}^2 \\rho^2}{4} \\right)^{n} \\right)}$$"
        },
        {
            "introduction": "Bridging continuous theory and discrete computation is a critical skill in computational fusion science. This exercise challenges you to design and implement a charge-conserving pullback scheme within the framework of a Particle-In-Cell (PIC) code. You will derive a discrete rule that ensures the total charge remains invariant when transforming from gyrocenter weights to particle-space weights, a fundamental requirement for any physically meaningful simulation. ",
            "id": "4033726",
            "problem": "Consider the transformation between gyrocenter phase space and particle phase space in a delta distribution function (delta f) Particle-In-Cell (PIC) gyrokinetic algorithm. You are tasked with designing a discrete pullback scheme that maps particle weights from gyrocenter space to particle space while preserving total charge in a one-dimensional periodic domain. The scheme must be derived from first principles consistent with charge conservation and a consistent discrete representation of gyrophase averaging. The numerical implementation must use a first-order Cloud-In-Cell deposition and interpolation for grid-to-particle and particle-to-grid operations.\n\nAssume the following modeling assumptions and computational setup:\n- The domain is one-dimensional, periodic, of length $L$, discretized with $N_g$ uniformly spaced grid nodes, with grid spacing $\\Delta x = L/N_g$.\n- Each marker (computational particle) has a gyrocenter position $R_p \\in [0,L)$ and a scalar weight $w_p^{\\mathrm{gc}}$ representing its delta distribution function (delta f) weight in gyrocenter coordinates.\n- The Larmor radius is given as a scalar $\\rho_p$ for each marker. For simplicity in this one-dimensional model, the gyrophase ring is projected along the domain coordinate as a set of positions $x_{p,k}$ obtained by a cosine displacement from $R_p$ with angle samples.\n- Gyrophase sampling uses $N_\\theta$ equally spaced angles over a full $2\\pi$ revolution. All angles must be in radians.\n- Electrostatic potential $\\phi(x)$ is defined on the grid nodes. Interpolation from grid to particle uses the same first-order Cloud-In-Cell weights as deposition from particle to grid.\n\nYour task is to:\n1. Starting from the requirement that the total charge must be invariant under the pullback mapping (from gyrocenter weights to particle-space weights) and the discrete property of the first-order Cloud-In-Cell shape function, derive a discrete pullback rule that ensures that the sum of deposited charge on the grid is exactly preserved after mapping. You must explicitly define the discrete gyrophase-average of the potential and how the mapping uses it.\n2. Implement the derived scheme in a program that:\n   - Generates a set of markers with positions $R_p$ and gyrocenter weights $w_p^{\\mathrm{gc}}$.\n   - Constructs the gyrophase ring positions $x_{p,k}$ for each marker using $N_\\theta$ samples $\\theta_k = 2\\pi k/N_\\theta$ for $k=0,1,\\ldots,N_\\theta-1$, and the one-dimensional projection $x_{p,k} = R_p + \\rho_p \\cos\\theta_k$ with periodic wrapping into $[0,L)$.\n   - Interpolates $\\phi$ at $x_{p,k}$ using first-order Cloud-In-Cell interpolation.\n   - Deposits charge on the grid using first-order Cloud-In-Cell from:\n     (a) the gyrocenter representation, where the gyrophase ring is discretely averaged onto the grid with the original $w_p^{\\mathrm{gc}}$, and\n     (b) the particle-space representation, where the mapped particle-space weights (to be derived) are deposited from all $x_{p,k}$.\n   - Computes the total charge on the grid before and after the mapping and returns the absolute difference.\n3. Use dimensionless normalized units. No physical unit conversion is required.\n4. Use the following test suite of five parameter sets. For all tests, set the random number generator seed to $42$ to ensure reproducibility of any random initialization:\n   - Test 1 (baseline, uniform field): $L=1$, $N_g=32$, $N_\\theta=8$, number of markers $N_p=50$, $\\rho_p=0.05$ for all markers, coefficient $\\alpha=0.3$, potential $\\phi(x)=0$ for all grid nodes.\n   - Test 2 (single-mode potential): $L=1$, $N_g=64$, $N_\\theta=16$, $N_p=100$, $\\rho_p=0.04$, $\\alpha=1.0$, potential $\\phi(x)=0.1\\sin(2\\pi x)$ sampled at grid nodes $x_j=j\\Delta x$.\n   - Test 3 (zero Larmor radius): $L=1$, $N_g=64$, $N_\\theta=8$, $N_p=75$, $\\rho_p=0.0$, $\\alpha=0.5$, potential $\\phi(x)=0.05\\sin(4\\pi x)+0.02\\cos(6\\pi x)$ sampled at grid nodes $x_j=j\\Delta x$.\n   - Test 4 (random potential): $L=1$, $N_g=128$, $N_\\theta=12$, $N_p=200$, $\\rho_p=0.03$, $\\alpha=0.7$, potential $\\phi(x)$ is a random array of length $N_g$ generated as independent standard normal entries scaled by $0.2$.\n   - Test 5 (high wavenumber and minimal gyrophase sampling): $L=1$, $N_g=32$, $N_\\theta=1$, $N_p=5$, $\\rho_p=0.1$, $\\alpha=2.0$, potential $\\phi(x)=0.1\\sin(8\\pi x)$ sampled at grid nodes $x_j=j\\Delta x$.\n\nInitialization of markers:\n- Marker positions $R_p$ must be independent uniform samples in $[0,L)$.\n- Gyrocenter weights $w_p^{\\mathrm{gc}}$ must be independent samples from a normal distribution with mean $0$ and standard deviation $0.1$.\n\nNumerical scheme details:\n- First-order Cloud-In-Cell shape function must deposit a marker at position $x$ onto the two nearest grid nodes with weights proportional to the linear distance to the nodes, with periodic boundary conditions.\n- Interpolation of $\\phi$ at a position $x$ must use the same Cloud-In-Cell weights.\n\nFinal output requirement:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\").\n- For each of the five tests, the result is the absolute difference between total grid charge deposited from the gyrocenter representation and the total grid charge deposited from the particle-space representation after the pullback mapping. Each result must be a floating-point number.",
            "solution": "The problem statement has been analyzed and is deemed to be valid. It is scientifically grounded in the principles of computational plasma physics, specifically gyrokinetic Particle-In-Cell (PIC) methods. It is well-posed, objective, and contains sufficient information to derive and implement a unique and meaningful solution. The problem requires the derivation of a discrete pullback transformation from gyrocenter to particle-space coordinates that conserves the total charge deposited on a grid.\n\nThe core of the problem lies in establishing a consistent numerical scheme for charge deposition and potential interpolation that guarantees the desired conservation property. We will proceed by first deriving the charge conservation condition from first principles and then outlining the algorithm for its numerical verification.\n\nLet $S(x-x_j)$ represent the first-order Cloud-In-Cell (CIC) shape function, which distributes the weight of a particle at position $x$ to the grid node at position $x_j$. For a one-dimensional periodic domain of length $L$ with $N_g$ grid cells of size $\\Delta x = L/N_g$, the shape function possesses the property of forming a partition of unity: $\\sum_{j=0}^{N_g-1} S(x-x_j) = 1$ for any position $x$.\n\nWe are asked to compare two methods for calculating the charge density on the grid, $\\rho_j$, from a set of gyrokinetic markers. Each marker $p$ is defined by its gyrocenter position $R_p$ and its gyrocenter weight $w_p^{\\mathrm{gc}}$. Its gyromotion is represented by a ring of $N_\\theta$ discrete points, $x_{p,k} = R_p + \\rho_p \\cos\\theta_k$ for $k=0, \\dots, N_\\theta-1$, where $\\theta_k = 2\\pi k / N_\\theta$. All positions are subject to periodic boundary conditions on $[0, L)$.\n\n**Method (a): Gyrocenter Representation**\nIn this representation, the charge of each marker is \"smeared\" over its gyro-ring. The charge density contribution to grid node $j$ from particle $p$ is the discrete gyrophase average of the shape function, scaled by the gyrocenter weight. Discretizing the gyrophase average as a sum over the $N_\\theta$ ring points, we have:\n$$\n\\rho_{p,j}^{\\mathrm{gc}} = w_p^{\\mathrm{gc}} \\left( \\frac{1}{N_\\theta} \\sum_{k=0}^{N_\\theta-1} S(x_{p,k} - x_j) \\right)\n$$\nThis is numerically implemented by depositing a weight of $w_p^{\\mathrm{gc}}/N_\\theta$ at each of the $N_\\theta$ ring points $x_{p,k}$.\n\nThe total charge on the grid from this representation, $Q^{\\mathrm{gc}}$, is the sum of the charge on all grid nodes:\n$$\nQ^{\\mathrm{gc}} = \\sum_{j=0}^{N_g-1} \\sum_{p} \\rho_{p,j}^{\\mathrm{gc}} = \\sum_p w_p^{\\mathrm{gc}} \\frac{1}{N_\\theta} \\sum_{k=0}^{N_\\theta-1} \\left( \\sum_{j=0}^{N_g-1} S(x_{p,k} - x_j) \\right)\n$$\nUsing the partition of unity property, $\\sum_j S(x_{p,k} - x_j) = 1$, the expression simplifies to:\n$$\nQ^{\\mathrm{gc}} = \\sum_p w_p^{\\mathrm{gc}} \\frac{1}{N_\\theta} \\sum_{k=0}^{N_\\theta-1} (1) = \\sum_p w_p^{\\mathrm{gc}}\n$$\nThe total charge on the grid is simply the sum of the gyrocenter weights.\n\n**Method (b): Particle-Space Representation (Pullback)**\nThe pullback transformation maps the gyrocenter weight $w_p^{\\mathrm{gc}}$ to a set of particle-space weights $w_{p,k}^{\\mathrm{ps}}$, one for each point on the discrete gyro-ring. The general form of this transformation in delta-f gyrokinetics is:\n$$\nw_{p,k}^{\\mathrm{ps}} = w_p^{\\mathrm{gc}} - \\alpha \\left( \\phi(x_{p,k}) - \\langle \\phi \\rangle_{R_p} \\right)\n$$\nHere, $\\alpha$ is a given coefficient, $\\phi(x_{p,k})$ is the electrostatic potential at the ring point $x_{p,k}$, and $\\langle \\phi \\rangle_{R_p}$ is the discrete gyrophase-averaged potential for particle $p$. Our task is to define $\\langle \\phi \\rangle_{R_p}$ such that total charge is conserved.\n\nIn this representation, the charge deposited on node $j$ from particle $p$ arises from depositing the particle-space weights $w_{p,k}^{\\mathrm{ps}}$ at their corresponding positions $x_{p,k}$. To maintain normalization consistent with method (a), we deposit a weight of $w_{p,k}^{\\mathrm{ps}}/N_\\theta$ at each point $x_{p,k}$:\n$$\n\\rho_{p,j}^{\\mathrm{ps}} = \\frac{1}{N_\\theta} \\sum_{k=0}^{N_\\theta-1} w_{p,k}^{\\mathrm{ps}} S(x_{p,k} - x_j)\n$$\nThe total charge on the grid for this representation, $Q^{\\mathrm{ps}}$, is:\n$$\nQ^{\\mathrm{ps}} = \\sum_{j=0}^{N_g-1} \\sum_p \\rho_{p,j}^{\\mathrm{ps}} = \\sum_p \\frac{1}{N_\\theta} \\sum_{k=0}^{N_\\theta-1} w_{p,k}^{\\mathrm{ps}} \\left( \\sum_{j=0}^{N_g-1} S(x_{p,k} - x_j) \\right)\n$$\nAgain, using the partition of unity property, this simplifies to:\n$$\nQ^{\\mathrm{ps}} = \\sum_p \\left( \\frac{1}{N_\\theta} \\sum_{k=0}^{N_\\theta-1} w_{p,k}^{\\mathrm{ps}} \\right)\n$$\nThis shows that the total charge deposited on the grid is the sum over all particles of their total particle-space weight.\n\n**Derivation of the Conservation Rule**\nWe require that the total charge on the grid be preserved by the pullback transformation, i.e., $Q^{\\mathrm{gc}} = Q^{\\mathrm{ps}}$. For this to hold for any arbitrary distribution of markers, the conservation must hold on a per-particle basis: the total charge deposited by particle $p$ must be the same in both representations. From the expressions above, this means:\n$$\nw_p^{\\mathrm{gc}} = \\frac{1}{N_\\theta} \\sum_{k=0}^{N_\\theta-1} w_{p,k}^{\\mathrm{ps}}\n$$\nSubstituting the expression for $w_{p,k}^{\\mathrm{ps}}$:\n$$\nw_p^{\\mathrm{gc}} = \\frac{1}{N_\\theta} \\sum_{k=0}^{N_\\theta-1} \\left( w_p^{\\mathrm{gc}} - \\alpha \\left( \\phi(x_{p,k}) - \\langle \\phi \\rangle_{R_p} \\right) \\right)\n$$\n$$\nw_p^{\\mathrm{gc}} = w_p^{\\mathrm{gc}} - \\frac{\\alpha}{N_\\theta} \\sum_{k=0}^{N_\\theta-1} \\left( \\phi(x_{p,k}) - \\langle \\phi \\rangle_{R_p} \\right)\n$$\nFor this equation to hold, the summation term must be zero:\n$$\n\\sum_{k=0}^{N_\\theta-1} \\left( \\phi(x_{p,k}) - \\langle \\phi \\rangle_{R_p} \\right) = 0\n$$\n$$\n\\sum_{k=0}^{N_\\theta-1} \\phi(x_{p,k}) = \\sum_{k=0}^{N_\\theta-1} \\langle \\phi \\rangle_{R_p} = N_\\theta \\langle \\phi \\rangle_{R_p}\n$$\nThis yields the required definition for the discrete gyrophase-averaged potential:\n$$\n\\langle \\phi \\rangle_{R_p} = \\frac{1}{N_\\theta} \\sum_{k=0}^{N_\\theta-1} \\phi(x_{p,k})\n$$\nThis is the arithmetic mean of the potential values at the discrete points on the gyro-ring.\n\nTo complete the scheme, we must specify how to evaluate $\\phi(x_{p,k})$, since the potential $\\phi$ is only defined at the grid nodes $x_j$. As mandated by the problem, we use first-order CIC interpolation, which is consistent with the deposition scheme:\n$$\n\\phi(x) = \\sum_{j=0}^{N_g-1} \\phi_j S(x-x_j)\n$$\nwhere $\\phi_j = \\phi(x_j)$ are the grid values of the potential.\nThus, $\\phi(x_{p,k}) = \\sum_{j=0}^{N_g-1} \\phi_j S(x_{p,k}-x_j)$.\n\n**Summary of the Derived Discrete Pullback Scheme:**\n1.  For each particle $p$, generate its gyro-ring positions $\\{x_{p,k}\\}$.\n2.  For each ring point $x_{p,k}$, calculate the interpolated potential $\\phi(x_{p,k})$ from the grid values $\\{\\phi_j\\}$ using CIC interpolation.\n3.  Calculate the discrete gyro-averaged potential $\\langle \\phi \\rangle_{R_p}$ as the arithmetic mean of the $\\phi(x_{p,k})$ values.\n4.  Calculate the particle-space weights $w_{p,k}^{\\mathrm{ps}} = w_p^{\\mathrm{gc}} - \\alpha(\\phi(x_{p,k}) - \\langle \\phi \\rangle_{R_p})$.\n5.  To compute the charge density from the gyrocenter representation, deposit a weight of $w_p^{\\mathrm{gc}}/N_\\theta$ at each position $x_{p,k}$ using the CIC scheme.\n6.  To compute the charge density from the particle-space representation, deposit a weight of $w_{p,k}^{\\mathrm{ps}}/N_\\theta$ at each position $x_{p,k}$ using the CIC scheme.\n\nWith this construction, the sum of all deposited weights is mathematically identical in both schemes, ensuring that the total charge on the grid is conserved up to floating-point precision. The numerical implementation will verify this by computing the absolute difference of the total grid charge from the two methods.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a charge-conserving pullback scheme for a 1D\n    gyrokinetic PIC model, then runs a suite of tests to verify conservation.\n    \"\"\"\n\n    def deposit(grid, pos, weight, L, Ng):\n        \"\"\"\n        Deposits a particle's weight onto the grid using a first-order\n        Cloud-In-Cell (CIC) scheme with periodic boundary conditions.\n        \"\"\"\n        dx = L / Ng\n        norm_pos = pos / dx\n        j_low = int(norm_pos)\n        h = norm_pos - j_low\n        \n        j_low_idx = j_low % Ng\n        j_high_idx = (j_low + 1) % Ng\n        \n        grid[j_low_idx] += weight * (1.0 - h)\n        grid[j_high_idx] += weight * h\n\n    def interpolate(pos, grid, L, Ng):\n        \"\"\"\n        Interpolates a grid quantity to a particle's position using a\n        first-order Cloud-In-Cell (CIC) scheme with periodic boundaries.\n        \"\"\"\n        dx = L / Ng\n        norm_pos = pos / dx\n        j_low = int(norm_pos)\n        h = norm_pos - j_low\n        \n        j_low_idx = j_low % Ng\n        j_high_idx = (j_low + 1) % Ng\n        \n        return grid[j_low_idx] * (1.0 - h) + grid[j_high_idx] * h\n\n    def run_test(L, Ng, Ntheta, Np, rho_val, alpha, phi_func):\n        \"\"\"\n        Executes a single test case for the pullback scheme verification.\n        \"\"\"\n        # --- Setup ---\n        dx = L / Ng\n        grid_nodes = np.linspace(0, L, Ng, endpoint=False)\n        phi_grid = phi_func(grid_nodes)\n        \n        rho_gc_grid = np.zeros(Ng)\n        rho_ps_grid = np.zeros(Ng)\n        \n        # --- Marker Initialization ---\n        # Set seed within the test runner for reproducibility of each test\n        # even if run in different orders or contexts. The problem states a\n        # global seed, but localizing it ensures test independence.\n        np.random.seed(42)\n        gyrocenter_positions = np.random.uniform(0, L, Np)\n        gyrocenter_weights = np.random.normal(0, 0.1, Np)\n        larmor_radii = np.full(Np, rho_val)\n\n        # --- Main Loop over Particles ---\n        for p in range(Np):\n            Rp = gyrocenter_positions[p]\n            w_gc = gyrocenter_weights[p]\n            rho_p = larmor_radii[p]\n\n            # Generate gyro-ring positions\n            thetas = 2 * np.pi * np.arange(Ntheta) / Ntheta\n            # Ensure periodic wrapping into [0, L)\n            x_pk = (Rp + rho_p * np.cos(thetas)) % L\n\n            # --- Method (a): Gyrocenter Deposition ---\n            for k in range(Ntheta):\n                deposit(rho_gc_grid, x_pk[k], w_gc / Ntheta, L, Ng)\n\n            # --- Method (b): Particle-Space Pullback and Deposition ---\n            # 1. Interpolate potential to ring points\n            phi_at_ring_points = np.zeros(Ntheta)\n            for k in range(Ntheta):\n                phi_at_ring_points[k] = interpolate(x_pk[k], phi_grid, L, Ng)\n            \n            # 2. Compute discrete gyro-averaged potential\n            gyro_avg_phi = np.mean(phi_at_ring_points)\n\n            # 3. Compute particle-space weights and deposit\n            for k in range(Ntheta):\n                # Calculate particle-space weight for this segment of the ring\n                w_ps_k = w_gc - alpha * (phi_at_ring_points[k] - gyro_avg_phi)\n                # Deposit this weight\n                deposit(rho_ps_grid, x_pk[k], w_ps_k / Ntheta, L, Ng)\n        \n        # --- Calculate Total Charge and Difference ---\n        total_charge_gc = np.sum(rho_gc_grid)\n        total_charge_ps = np.sum(rho_ps_grid)\n        \n        return abs(total_charge_gc - total_charge_ps)\n\n    # --- Test Suite Definition ---\n    test_cases = [\n        # Test 1: baseline, uniform field\n        (1.0, 32, 8, 50, 0.05, 0.3, lambda x: np.zeros_like(x)),\n        # Test 2: single-mode potential\n        (1.0, 64, 16, 100, 0.04, 1.0, lambda x: 0.1 * np.sin(2 * np.pi * x)),\n        # Test 3: zero Larmor radius\n        (1.0, 64, 8, 75, 0.0, 0.5, lambda x: 0.05 * np.sin(4 * np.pi * x) + 0.02 * np.cos(6 * np.pi * x)),\n        # Test 4: random potential\n        (1.0, 128, 12, 200, 0.03, 0.7, \n         lambda x: 0.2 * np.random.RandomState(42).standard_normal(len(x))),\n        # Test 5: high wavenumber and minimal gyrophase sampling\n        (1.0, 32, 1, 5, 0.1, 2.0, lambda x: 0.1 * np.sin(8 * np.pi * x)),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, Ng, Ntheta, Np, rho_val, alpha, phi_func = case\n        result = run_test(L, Ng, Ntheta, Np, rho_val, alpha, phi_func)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}