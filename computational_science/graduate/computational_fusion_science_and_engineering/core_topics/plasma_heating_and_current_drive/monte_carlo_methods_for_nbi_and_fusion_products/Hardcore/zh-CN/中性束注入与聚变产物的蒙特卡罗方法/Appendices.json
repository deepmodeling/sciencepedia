{
    "hands_on_practices": [
        {
            "introduction": "任何蒙特卡洛模拟都始于一个基本问题：我们需要模拟多少粒子才能达到期望的统计精度？本实践提供了一种直接的、动手的方法来回答这个问题。我们将中性束能量沉积建模为一系列伯努利试验，其中每个粒子要么沉积其能量，要么穿透等离子体。通过应用基本的统计学原理，您将学会推导期望的相对误差与所需粒子历史数之间的关系，这是规划和解释任何蒙特卡洛模拟的关键技能。这个练习 () 展示了模拟需求如何根据等离子体不透明度等潜在物理特性发生巨大变化。",
            "id": "4015715",
            "problem": "一个中性束注入 (NBI) 系统以注入功率 $P$ 和粒子动能 $E_0$ 输送氘中性粒子。注入粒子率由商 $\\dot{N} = P / E_0$ 定义，使用一致的单位。考虑能量沉积份额的蒙特卡罗 (MC) 估算，方法是将沿直线束路径穿过均匀等离子体的电离事件视为空中泊松过程，其单位长度率为 $k = n_e \\sigma_i$，其中 $n_e$ 是电子数密度，$\\sigma_i$ 是有效电离截面。如果中性束在等离子体中穿过长度为 $L$ 的弦，当弦内至少发生一次电离碰撞时，记录为一次沉积历史，否则计为穿透。假设每次历史如果在等离子体内发生电离，则沉积其全部初始能量 $E_0$，否则沉积能量为零。当需要时，角度必须以弧度表示。\n\n从上述基本定义和均匀介质中碰撞的空间泊松过程标准模型出发，推导如何计算所需的统计独立的 MC 历史数量，以在平均沉积份额的估计量中达到指定的相对标准误差。您的程序必须：\n\n- 使用 $1\\,\\mathrm{eV} = 1.602176634\\times 10^{-19}\\,\\mathrm{J}$ 将 $E_0 = 80\\,\\mathrm{keV}$ 转换为焦耳，并计算 $P = 5\\,\\mathrm{MW}$ 时的注入粒子率。将注入粒子率以 $\\mathrm{s}^{-1}$ 为单位表示为浮点数。\n- 对于一组给定的等离子体条件 $\\{n_e, \\sigma_i, L\\}$，将每次历史的沉积建模为一个伯努利随机变量，其成功概率等于弦内至少发生一次碰撞的概率。利用此模型确定所需的最小历史数，以确保沉积份额的蒙特卡罗估计量的相对标准误差不大于 $r = 0.01$。\n- 设计一个 MC 源，该源从以 $E_0$ 为中心、标准差为 $2\\,\\mathrm{keV}$ 的正态分布中抽样历史能量，并从以 $0$ 为中心、标准差为 $0.02\\,\\mathrm{rad}$ 的正态分布中抽样注入角度，适用于窄束。尽管必须实现源抽样，但最终要求的数值输出是每个测试用例的粒子率和所需历史数。\n\n使用以下三个等离子体条件的测试套件来计算所需的历史数，所有截面单位为平方米，密度单位为 $\\mathrm{m}^{-3}$，长度单位为米：\n\n- 测试用例 A (中等沉积)：$n_e = 5.0\\times 10^{19}$，$\\sigma_i = 3.0\\times 10^{-20}$，$L = 1.0$。\n- 测试用例 B (低沉积)：$n_e = 1.0\\times 10^{18}$，$\\sigma_i = 3.0\\times 10^{-20}$，$L = 1.0$。\n- 测试用例 C (高沉积)：$n_e = 2.0\\times 10^{20}$，$\\sigma_i = 3.0\\times 10^{-20}$，$L = 1.0$。\n\n您的程序应生成单行输出，其中包含形如 $[\\dot{N}, N_A, N_B, N_C]$ 的方括号内逗号分隔列表的结果，其中 $\\dot{N}$ 是一个以 $\\mathrm{s}^{-1}$ 为单位的浮点数，而 $N_A, N_B, N_C$ 是整数。不应打印任何其他输出。",
            "solution": "问题陈述已经过验证，被认为是科学上可靠、适定且客观的。它基于粒子输运物理和蒙特卡罗统计分析的标准原理。为得出唯一解所需的所有数据和定义均已提供，不存在内部矛盾或科学上不合理之处。\n\n解决方案分三部分展开：首先，计算注入粒子率；其次，推导所需蒙特卡罗历史数量的公式；第三，将此公式应用于指定的测试用例。\n\n**第一部分：注入粒子率计算**\n\n问题提供了注入束功率 $P = 5\\,\\mathrm{MW}$ 和每个氘中性粒子的初始动能 $E_0 = 80\\,\\mathrm{keV}$。注入粒子率 $\\dot{N}$ 定义为功率与单个粒子能量之比，即 $\\dot{N} = P / E_0$。为确保单位一致，我们将这两个量都转换为国际单位制 (SI) 单位。\n\n功率以兆瓦为单位给出，我们将其转换为瓦特（焦耳/秒）：\n$$P = 5\\,\\mathrm{MW} = 5 \\times 10^6 \\,\\mathrm{W} = 5 \\times 10^6 \\,\\mathrm{J/s}$$\n\n粒子能量以千电子伏 ($keV$) 为单位给出，我们使用提供的转换因子 $1\\,\\mathrm{eV} = 1.602176634 \\times 10^{-19}\\,\\mathrm{J}$ 将其转换为焦耳。\n$$E_0 = 80\\,\\mathrm{keV} = 80 \\times 10^3\\,\\mathrm{eV}$$\n$$E_0 = (80 \\times 10^3\\,\\mathrm{eV}) \\times (1.602176634 \\times 10^{-19}\\,\\mathrm{J/eV}) = 1.2817413072 \\times 10^{-14}\\,\\mathrm{J}$$\n\n现在，我们可以计算注入粒子率 $\\dot{N}$：\n$$\\dot{N} = \\frac{P}{E_0} = \\frac{5 \\times 10^6 \\,\\mathrm{J/s}}{1.2817413072 \\times 10^{-14}\\,\\mathrm{J}} \\approx 3.9010006 \\times 10^{20} \\,\\mathrm{s}^{-1}$$\n这是每秒注入系统的中性粒子数量。\n\n**第二部分：所需蒙特卡罗历史数量的推导**\n\n问题将中性粒子沿其路径的电离建模为一个空间泊松过程。该过程的单位长度率为 $k = n_e \\sigma_i$，其中 $n_e$ 是电子密度，$\\sigma_i$ 是有效电离截面。对于一个穿过均匀等离子体弦长为 $L$ 的粒子，其期望碰撞次数为 $\\lambda = kL$。\n\n根据泊松分布，在这段长度上观察到恰好 $m$ 次碰撞的概率由下式给出：\n$$P(m) = \\frac{\\lambda^m e^{-\\lambda}}{m!}$$\n\n如果长度 $L$ 内至少发生一次碰撞（$m \\ge 1$），则认为该粒子历史是“沉积”的。我们记此事件的概率为 $p$，它与零次碰撞（$m=0$）的概率互补：\n$$p = P(m \\ge 1) = 1 - P(m=0)$$\n$$P(m=0) = \\frac{\\lambda^0 e^{-\\lambda}}{0!} = e^{-\\lambda} = e^{-kL}$$\n因此，沉积概率为：\n$$p = 1 - e^{-kL}$$\n\n蒙特卡罗模拟将每次粒子历史视为一次独立的伯努利试验。设随机变量 $X_i$ 代表第 $i$ 次历史的结果：若沉积，则 $X_i = 1$（概率为 $p$）；若穿透，则 $X_i = 0$（概率为 $1-p$）。问题基于此二元结果定义了沉积份额的估计量。\n\n沉积份额的真实均值（期望值）为 $\\mu = E[X_i] = 1 \\cdot p + 0 \\cdot (1-p) = p$。此伯努利随机变量的方差为 $\\sigma^2 = \\text{Var}(X_i) = p(1-p)$。\n\n对于 $N$ 次独立的蒙特卡罗历史，平均沉积份额的估计量为 $\\hat{\\mu}_N = \\frac{1}{N} \\sum_{i=1}^N X_i$。此估计量的方差为：\n$$\\text{Var}(\\hat{\\mu}_N) = \\text{Var}\\left(\\frac{1}{N}\\sum_{i=1}^N X_i\\right) = \\frac{1}{N^2}\\sum_{i=1}^N \\text{Var}(X_i) = \\frac{N\\sigma^2}{N^2} = \\frac{\\sigma^2}{N} = \\frac{p(1-p)}{N}$$\n估计量的标准误差 $SE(\\hat{\\mu}_N)$ 是其方差的平方根：\n$$SE(\\hat{\\mu}_N) = \\sqrt{\\frac{p(1-p)}{N}}$$\n\n问题要求*相对*标准误差 $r$ 不大于指定值 $r_{max} = 0.01$。相对标准误差定义为标准误差除以真实均值：\n$$r = \\frac{SE(\\hat{\\mu}_N)}{\\mu} = \\frac{\\sqrt{p(1-p)/N}}{p} = \\frac{1}{\\sqrt{N}}\\sqrt{\\frac{p(1-p)}{p^2}} = \\frac{1}{\\sqrt{N}}\\sqrt{\\frac{1-p}{p}}$$\n\n我们设定条件 $r \\le r_{max}$：\n$$\\frac{1}{\\sqrt{N}}\\sqrt{\\frac{1-p}{p}} \\le r_{max}$$\n为求解 $N$，我们将两边平方并重新整理：\n$$\\frac{1}{N}\\frac{1-p}{p} \\le r_{max}^2$$\n$$N \\ge \\frac{1-p}{p \\cdot r_{max}^2}$$\n由于 $N$ 必须是整数，所需的最小历史数是满足此不等式的最小整数，可通过对右侧表达式向上取整得到：\n$$N_{min} = \\left\\lceil \\frac{1-p}{p \\cdot r_{max}^2} \\right\\rceil$$\n代入 $p = 1 - e^{-kL}$ 和 $1-p = e^{-kL}$，我们得到最终公式：\n$$N_{min} = \\left\\lceil \\frac{e^{-kL}}{(1 - e^{-kL}) r_{max}^2} \\right\\rceil$$\n\n**第三部分：应用于测试用例**\n\n现在我们将此公式应用于三个测试用例，使用 $r_{max} = 0.01$ 和 $L = 1.0\\,\\mathrm{m}$。\n\n**测试用例 A (中等沉积)：**\n$n_e = 5.0 \\times 10^{19}\\,\\mathrm{m}^{-3}$，$\\sigma_i = 3.0 \\times 10^{-20}\\,\\mathrm{m}^2$。\n$k_A = n_e \\sigma_i = (5.0 \\times 10^{19}) \\times (3.0 \\times 10^{-20}) = 1.5\\,\\mathrm{m}^{-1}$。\n参数 $\\lambda_A = k_A L = 1.5$。\n$N_A = \\left\\lceil \\frac{e^{-1.5}}{(1 - e^{-1.5}) (0.01)^2} \\right\\rceil = \\left\\lceil \\frac{0.223130}{0.776870 \\times 10^{-4}} \\right\\rceil = \\lceil 2872.23 \\rceil = 2873$。\n\n**测试用例 B (低沉积)：**\n$n_e = 1.0 \\times 10^{18}\\,\\mathrm{m}^{-3}$，$\\sigma_i = 3.0 \\times 10^{-20}\\,\\mathrm{m}^2$。\n$k_B = n_e \\sigma_i = (1.0 \\times 10^{18}) \\times (3.0 \\times 10^{-20}) = 0.03\\,\\mathrm{m}^{-1}$。\n参数 $\\lambda_B = k_B L = 0.03$。\n$N_B = \\left\\lceil \\frac{e^{-0.03}}{(1 - e^{-0.03}) (0.01)^2} \\right\\rceil = \\left\\lceil \\frac{0.9704455}{(1 - 0.9704455) \\times 10^{-4}} \\right\\rceil = \\lceil 328390.13 \\rceil = 328391$。\n\n**测试用例 C (高沉积)：**\n$n_e = 2.0 \\times 10^{20}\\,\\mathrm{m}^{-3}$，$\\sigma_i = 3.0 \\times 10^{-20}\\,\\mathrm{m}^2$。\n$k_C = n_e \\sigma_i = (2.0 \\times 10^{20}) \\times (3.0 \\times 10^{-20}) = 6.0\\,\\mathrm{m}^{-1}$。\n参数 $\\lambda_C = k_C L = 6.0$。\n$N_C = \\left\\lceil \\frac{e^{-6.0}}{(1 - e^{-6.0}) (0.01)^2} \\right\\rceil = \\left\\lceil \\frac{0.00247875}{(1 - 0.00247875) \\times 10^{-4}} \\right\\rceil = \\lceil 24.85 \\rceil = 25$。\n\n结果是：$\\dot{N} \\approx 3.9010006 \\times 10^{20}\\,\\mathrm{s}^{-1}$，$N_A = 2873$，$N_B = 328391$，$N_C = 25$。\n\n问题还要求实现一个蒙特卡罗源抽样程序，用于从指定的正态分布中抽样粒子能量和注入角度，该程序将包含在最终的程序代码中。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Although scipy is listed as available, it is not required for this problem.\n\ndef mc_source(E0_mean_keV, E0_std_keV, angle_mean_rad, angle_std_rad):\n    \"\"\"\n    Designs and samples from a Monte Carlo source for NBI particles.\n    \n    This function implements the source sampling as required by the problem\n    statement, generating a particle's initial energy and injection angle\n    from normal distributions. This function is included to fulfill the problem\n    requirements but is not directly used to compute the final numerical outputs.\n\n    Args:\n        E0_mean_keV (float): Mean injection energy in keV.\n        E0_std_keV (float): Standard deviation of injection energy in keV.\n        angle_mean_rad (float): Mean injection angle in radians.\n        angle_std_rad (float): Standard deviation of injection angle in radians.\n\n    Returns:\n        tuple[float, float]: A tuple containing the sampled energy (keV) and angle (rad).\n    \"\"\"\n    # Sample energy from a normal distribution\n    energy_keV = np.random.normal(loc=E0_mean_keV, scale=E0_std_keV)\n    # Sample angle from a normal distribution\n    angle_rad = np.random.normal(loc=angle_mean_rad, scale=angle_std_rad)\n    return energy_keV, angle_rad\n\ndef solve():\n    \"\"\"\n    Calculates the NBI particle rate and the required number of Monte Carlo\n    histories for different plasma conditions.\n    \"\"\"\n    \n    # --- Part 1: Injected Particle Rate Calculation ---\n    \n    # Constants and Givens\n    P_MW = 5.0  # Injected power in MW\n    E0_keV = 80.0  # Particle kinetic energy in keV\n    EV_TO_JOULE = 1.602176634e-19  # Conversion factor for eV to Joules\n\n    # Convert to SI units\n    P_watts = P_MW * 1e6  # Power in Watts (J/s)\n    E0_joules = E0_keV * 1e3 * EV_TO_JOULE  # Energy in Joules\n\n    # Calculate injected particle rate\n    n_dot = P_watts / E0_joules\n\n    # --- Part 2: Required Number of Histories Calculation ---\n\n    # Test suite of plasma conditions\n    test_cases = [\n        # Case A: moderate deposition\n        {'name': 'A', 'n_e': 5.0e19, 'sigma_i': 3.0e-20, 'L': 1.0},\n        # Case B: low deposition\n        {'name': 'B', 'n_e': 1.0e18, 'sigma_i': 3.0e-20, 'L': 1.0},\n        # Case C: high deposition\n        {'name': 'C', 'n_e': 2.0e20, 'sigma_i': 3.0e-20, 'L': 1.0},\n    ]\n\n    r_max = 0.01  # Maximum relative standard error\n\n    def calculate_min_histories(n_e, sigma_i, L, r):\n        \"\"\"\n        Computes the minimum number of MC histories for a given relative error.\n        \n        Args:\n            n_e (float): Electron number density (m^-3).\n            sigma_i (float): Effective ionization cross-section (m^2).\n            L (float): Chord length in plasma (m).\n            r (float): Target relative standard error.\n\n        Returns:\n            int: The minimum number of histories required.\n        \"\"\"\n        # Rate per unit length (inverse of mean free path)\n        k = n_e * sigma_i\n        \n        # Expected number of collisions over length L\n        lambda_val = k * L\n        \n        # Deposition probability p = 1 - exp(-lambda)\n        # Shine-through probability 1-p = exp(-lambda)\n        p = 1.0 - np.exp(-lambda_val)\n        \n        # If p is very close to 0 or 1, the number of histories can be huge or small.\n        # Handle the edge case of p=0 to avoid division by zero, though unlikely here.\n        if p == 0:\n            return np.iinfo(np.int64).max # Effectively infinite\n\n        # From r = sqrt((1-p)/p) / sqrt(N), we get N >= (1-p) / (p * r**2)\n        num_histories_float = np.exp(-lambda_val) / (p * r**2)\n        \n        # The number of histories must be an integer, so take the ceiling.\n        return int(np.ceil(num_histories_float))\n\n    # Calculate required histories for each test case\n    results_N = []\n    for case in test_cases:\n        N_min = calculate_min_histories(case['n_e'], case['sigma_i'], case['L'], r_max)\n        results_N.append(N_min)\n        \n    N_A, N_B, N_C = results_N\n\n    # --- Part 3: Example call to the source sampler (not used in output) ---\n    # This call demonstrates the function's use as required by the problem.\n    E0_mean_keV_src = 80.0\n    E0_std_keV_src = 2.0\n    angle_mean_rad_src = 0.0\n    angle_std_rad_src = 0.02\n    _ = mc_source(E0_mean_keV_src, E0_std_keV_src, angle_mean_rad_src, angle_std_rad_src)\n\n    # Final print statement in the exact required format\n    # Output: [particle_rate (float), N_A (int), N_B (int), N_C (int)]\n    output_list = [n_dot, N_A, N_B, N_C]\n    print(f\"[{','.join(map(str, output_list))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在真实的输运模拟中，诸如反应截面之类的物理量并非恒定不变，而是随粒子能量而变化。这些数据通常以表格形式提供。本实践探讨了如何使用插值方法在任意能量点上精确地获取截面值。我们将比较简单的线性插值和更具物理动机的对数-对数插值方案。这项练习 () 对于理解高保真蒙特卡洛代码的数值基础至关重要。您将量化不同数值方法所带来的误差，并体会到为什么选择正确的插值方案对于保持模拟的物理准确性至关重要，特别是当数据跨越多个数量级时。",
            "id": "4015705",
            "problem": "中性束注入（NBI）和聚变产物输运蒙特卡罗（Monte Carlo）算法通过在等离子体中推进带电粒子和中性粒子，同时根据微观截面 $\\sigma(E)$（其中 $E$ 表示动能）随机抽样相互作用事件来进行模拟。单位路径长度上的相互作用概率密度与靶密度 $n$ 和截面 $\\sigma(E)$ 的乘积 $n \\sigma(E)$ 成正比，因此事件抽样的数值保真度取决于在列表能量点之间内插 $\\sigma(E)$ 值的准确性和稳定性。在高温等离子体应用中，列表化的电离截面 $\\sigma_{\\mathrm{i}}(E)$ 和电荷交换截面 $\\sigma_{\\mathrm{cx}}(E)$ 的数据通常在能量 $E$ 和截面 $\\sigma$ 上跨越多个数量级，这要求内插策略能够保持正性、避免在大动态范围内的灾难性相消，并能捕捉截面典型的近似幂律行为。\n\n从截面的基本定义（即单位相对通量的反应速率系数）以及蒙特卡罗抽样规则（即自由程分布在宏观截面 $n \\sigma(E)$ 上呈指数形式）出发，设计并实现一个满足这些约束条件的数值稳定内插方案，用于处理列表化的截面数据。具体来说，实现一个在 $\\log(E)$ 和 $\\log(\\sigma)$ 中进行线性内插的对数-对数内插方案，并量化在 $E$ 的多个数量级上，通过在 $E$ 和 $\\sigma$ 中进行简单线性内插所引入的误差。\n\n使用一组科学上合理的解析截面模型来生成列表数据，然后将内插值与已知的“基准真相”模型进行比较，以量化内插误差。对于每个测试用例，在 $E \\in \\{10^3,10^4,10^5\\}$ 电子伏特 (eV) 处构建列表能量，并通过评估指定的基准真相模型生成相应的列表截面，单位为平方米 ($\\mathrm{m}^2$)。在一个覆盖整个 $[10^3,10^5]$ eV 范围且对数间隔的密集 $E$ 值网格上评估两种内插方法。计算每种内插方法相对于基准真相模型的最大相对误差和均方根（RMS）相对误差。相对误差必须以小数形式报告（无单位）。\n\n需要比较的内插方法有：\n- 在原始 $(E,\\sigma)$ 坐标中进行线性内插。\n- 在 $(\\log(E),\\log(\\sigma))$ 坐标中进行线性内插（对数-对数内插），并通过取幂运算映射回 $\\sigma(E)$。\n\n在计算对数时，仅考虑严格为正的 $\\sigma(E)$；在所有给定的测试用例中，$\\sigma(E)$ 在指定范围内均为严格正值。\n\n能量以电子伏特 (eV) 表示，截面以平方米 ($\\mathrm{m}^2$) 表示。误差度量是无量纲的。\n\n测试套件：\n- 案例 1（类电荷交换的幂律）：$\\sigma_{\\mathrm{cx}}(E) = A E^{p}$，其中 $p = -0.5$，振幅 $A$ 的选择使得 $\\sigma_{\\mathrm{cx}}(10^3\\,\\mathrm{eV}) = 10^{-19}\\,\\mathrm{m}^2$；在 $E \\in [10^3,10^5]$ eV 范围内评估。\n- 案例 2（带峰值的类电离）：$\\sigma_{\\mathrm{i}}(E) = A E^{0.7} \\exp\\!\\left(-E/E_0\\right)$，其中 $E_0 = 3\\times 10^4$ eV，振幅 $A$ 的选择使得 $\\sigma_{\\mathrm{i}}(E_0) = 5\\times 10^{-21}\\,\\mathrm{m}^2$；在 $E \\in [10^3,10^5]$ eV 范围内评估。\n- 案例 3（平台区）：$\\sigma(E) = C$ 为常数，其中 $C = 10^{-20}\\,\\mathrm{m}^2$；在 $E \\in [10^3,10^5]$ eV 范围内评估。\n- 案例 4（陡峭的幂律）：$\\sigma(E) = A E^{p}$，其中 $p = -2.0$，振幅 $A$ 的选择使得 $\\sigma(10^3\\,\\mathrm{eV}) = 10^{-19}\\,\\mathrm{m}^2$；在 $E \\in [10^3,10^5]$ eV 范围内评估。\n\n评估网格：\n- 使用 $N = 2001$ 个评估能量点，在 $10^3$ eV 到 $10^5$ eV 之间对数等距分布。\n\n误差度量：\n- 最大相对误差：$\\max_{E}\\left|\\dfrac{\\sigma_{\\mathrm{interp}}(E) - \\sigma_{\\mathrm{true}}(E)}{\\sigma_{\\mathrm{true}}(E)}\\right|$。\n- 均方根相对误差：$\\sqrt{\\dfrac{1}{N}\\sum_{j=1}^{N}\\left(\\dfrac{\\sigma_{\\mathrm{interp}}(E_j) - \\sigma_{\\mathrm{true}}(E_j)}{\\sigma_{\\mathrm{true}}(E_j)}\\right)^2}$。\n\n您的程序必须为每个测试用例实现以下内容：\n- 在指定的列表能量点处生成列表截面。\n- 构建两种内插函数（线性和对数-对数）。\n- 在评估网格上评估内插函数并计算误差度量。\n- 生成单行输出，其中包含四个测试用例的结果列表。每个结果必须是一个包含四个浮点数的列表：$[\\text{max\\_lin}, \\text{rms\\_lin}, \\text{max\\_loglog}, \\text{rms\\_loglog}]$，其中 $\\text{max\\_lin}$ 和 $\\text{rms\\_lin}$ 是线性内插的最大和均方根相对误差，而 $\\text{max\\_loglog}$ 和 $\\text{rms\\_loglog}$ 是对数-对数内插的相应误差。程序应生成一行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，$[[a,b,c,d],[\\dots],\\dots]$）。\n\n无需用户输入。程序必须是自包含且确定性的。",
            "solution": "该问题要求为原子截面数据 $\\sigma(E)$ 设计和比较分析两种数值内插方案，其中 $E$ 表示投射粒子的动能。这是计算物理学中的一项基础任务，特别适用于模拟聚变等离子体中粒子输运的蒙特卡罗模拟，例如中性束注入（NBI）加热和高能聚变产物追踪。在给定路径长度上发生相互作用事件的概率与宏观截面 $\\Sigma(E) = n \\sigma(E)$ 成正比，其中 $n$ 是靶粒子密度。因此，这些随机事件抽样的数值保真度取决于在列表数据点之间的任意能量上准确、稳定地评估 $\\sigma(E)$ 的能力。\n\n截面数据通常在能量 $E$ 和截面 $\\sigma$ 上都跨越数个数量级。一个稳健的内插方案必须保持正性（因为 $\\sigma(E) > 0$），避免灾难性相消，并且理想情况下能捕捉到底层的物理趋势，这些趋势通常近似为幂律。该问题指定了在两个列表数据点 $(E_1, \\sigma_1)$ 和 $(E_2, \\sigma_2)$ 之间进行内插的两种方法的比较。\n\n第一种方法是在原始 $(E, \\sigma)$ 坐标系中进行标准线性内插。对于能量 $E$ 满足 $E_1 \\le E \\le E_2$，内插后的截面 $\\sigma_{\\mathrm{lin}}(E)$ 由连接这两点的直线公式给出：\n$$\n\\sigma_{\\mathrm{lin}}(E) = \\sigma_1 + (E - E_1) \\frac{\\sigma_2 - \\sigma_1}{E_2 - E_1}\n$$\n这种方法简单且计算速度快，但如果 $\\sigma$ 值接近于零且数据有噪声，它不能内在保证正性，而且可能无法很好地表示许多截面的函数形式。\n\n第二种方法，即对数-对数内插，其动机是基于一个常见的观察：许多截面至少近似地遵循幂律关系，$\\sigma(E) \\propto E^p$。取自然对数将其转换为线性关系：$\\log(\\sigma) = p \\log(E) + \\text{constant}$。这表明在 $(\\log E, \\log \\sigma)$ 空间中执行线性内插是一种更具物理基础的方法。设 $u = \\log(E)$ 和 $v = \\log(\\sigma)$。在这个变换后的空间中进行线性内插可得：\n$$\nv(u) = v_1 + (u - u_1) \\frac{v_2 - v_1}{u_2 - u_1}\n$$\n将原始变量代回，我们得到内插截面对数的表达式 $\\sigma_{\\mathrm{loglog}}(E)$：\n$$\n\\log(\\sigma_{\\mathrm{loglog}}(E)) = \\log(\\sigma_1) + (\\log(E) - \\log(E_1)) \\frac{\\log(\\sigma_2) - \\log(\\sigma_1)}{\\log(E_2) - \\log(E_1)}\n$$\n截面本身则通过取幂得到，即 $\\sigma_{\\mathrm{loglog}}(E) = \\exp(\\log(\\sigma_{\\mathrm{loglog}}(E)))$。该操作内在地保证了 $\\sigma_{\\mathrm{loglog}}(E) > 0$。这个公式可以巧妙地改写为局部幂律形式，这突出了其结构：\n$$\n\\sigma_{\\mathrm{loglog}}(E) = \\sigma_1 \\left( \\frac{E}{E_1} \\right)^m, \\quad \\text{其中指数 } m = \\frac{\\log(\\sigma_2 / \\sigma_1)}{\\log(E_2 / E_1)}\n$$\n对于任何纯幂律函数，此形式都是精确的。\n\n实现将遵循一个精确的数值实验。对于四个测试用例中的每一个，一个“基准真相”解析截面模型被用来在三个指定能量点 $E \\in \\{10^3, 10^4, 10^5\\}$ 电子伏特 (eV) 处生成一个稀疏的截面表。两种内插方案都基于这个3点表构建。然后，通过在覆盖整个能量范围 $[10^3, 10^5]\\,$eV 且对数间隔的 $N=2001$ 个点的密集评估网格上，将其值与基准真相模型进行比较，来评估每种内插的准确性。\n\n定量比较依赖于两个标准误差度量，在评估网格 $\\{E_j\\}_{j=1}^N$ 上计算：\n1. 最大相对误差，它衡量最坏情况下的偏差：\n$$\n\\text{Max Rel Err} = \\max_{j} \\left| \\frac{\\sigma_{\\mathrm{interp}}(E_j) - \\sigma_{\\mathrm{true}}(E_j)}{\\sigma_{\\mathrm{true}}(E_j)} \\right|\n$$\n2. 均方根（RMS）相对误差，它提供了一个平均误差的度量：\n$$\n\\text{RMS Rel Err} = \\sqrt{\\frac{1}{N} \\sum_{j=1}^{N} \\left( \\frac{\\sigma_{\\mathrm{interp}}(E_j) - \\sigma_{\\mathrm{true}}(E_j)}{\\sigma_{\\mathrm{true}}(E_j)} \\right)^2}\n$$\nPython 实现将为四个测试用例中的每一个计算这四个误差值（线性和对数-对数方法的最大值和均方根值）。选择这些案例是为了测试幂律（其中对数-对数内插预计是精确的）、常数（其中两者都是精确的）以及一个类似于实际电离截面的更复杂形状下的行为。结果将证明，对于这类问题，基于物理动机的对数-对数内插方案具有更优越的稳定性和准确性。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares linear and log-log interpolation for atomic cross sections.\n    \"\"\"\n    # Define tabulated energies and the evaluation grid as per the problem.\n    E_tab = np.array([1e3, 1e4, 1e5])\n    N_eval = 2001\n    E_eval = np.logspace(np.log10(E_tab[0]), np.log10(E_tab[-1]), N_eval)\n\n    # --- Define Ground Truth Models for Each Test Case ---\n\n    # Case 1: Charge exchange-like power law\n    # sigma(E) = A * E^p, with p = -0.5\n    # A is set such that sigma(1e3 eV) = 1e-19 m^2\n    A_case1 = 1e-19 / (1e3 ** -0.5)\n    def sigma_case1(E):\n        return A_case1 * E**(-0.5)\n\n    # Case 2: Ionization-like with a peak\n    # sigma(E) = A * E^0.7 * exp(-E/E0), with E0 = 3e4 eV\n    # A is set such that sigma(E0) = 5e-21 m^2\n    E0_case2 = 3e4\n    A_case2 = (5e-21 * np.e) / (E0_case2**0.7)\n    def sigma_case2(E):\n        return A_case2 * E**0.7 * np.exp(-E / E0_case2)\n\n    # Case 3: Plateau (constant)\n    # sigma(E) = 1e-20 m^2\n    def sigma_case3(E):\n        return np.full_like(E, 1e-20, dtype=float)\n\n    # Case 4: Steep power law\n    # sigma(E) = A * E^p, with p = -2.0\n    # A is set such that sigma(1e3 eV) = 1e-19 m^2\n    A_case4 = 1e-19 / (1e3 ** -2.0)\n    def sigma_case4(E):\n        return A_case4 * E**(-2.0)\n\n    test_cases = [\n        {\"name\": \"Power Law (p=-0.5)\", \"func\": sigma_case1},\n        {\"name\": \"Ionization-like\", \"func\": sigma_case2},\n        {\"name\": \"Plateau\", \"func\": sigma_case3},\n        {\"name\": \"Power Law (p=-2.0)\", \"func\": sigma_case4},\n    ]\n    \n    all_results = []\n\n    for case in test_cases:\n        sigma_true_func = case[\"func\"]\n        \n        # 1. Generate tabulated cross sections at specified energies.\n        sigma_tab = sigma_true_func(E_tab)\n        \n        # 2. Evaluate ground truth model on the dense evaluation grid.\n        sigma_true_eval = sigma_true_func(E_eval)\n\n        # 3. Construct and evaluate the linear interpolant.\n        # np.interp performs linear interpolation in (E, sigma) space.\n        sigma_lin_eval = np.interp(E_eval, E_tab, sigma_tab)\n        \n        # 4. Construct and evaluate the log-log interpolant.\n        # This is equivalent to linear interpolation in (log E, log sigma) space.\n        log_E_tab = np.log(E_tab)\n        log_sigma_tab = np.log(sigma_tab)\n        log_E_eval = np.log(E_eval)\n        \n        # Check for non-positive sigma_tab, which would invalidate log.\n        # Problem statement guarantees this will not happen for the given cases.\n        if np.any(sigma_tab = 0):\n            # This branch should not be taken in this problem.\n            # Handle error appropriately in a general-purpose code.\n            # For this problem, we can just produce NaN errors.\n            sigma_loglog_eval = np.full_like(E_eval, np.nan)\n        else:\n            log_sigma_loglog_eval = np.interp(log_E_eval, log_E_tab, log_sigma_tab)\n            sigma_loglog_eval = np.exp(log_sigma_loglog_eval)\n\n        # 5. Calculate relative errors for both methods.\n        # The denominator sigma_true_eval is strictly positive for all cases.\n        rel_err_lin = (sigma_lin_eval - sigma_true_eval) / sigma_true_eval\n        rel_err_loglog = (sigma_loglog_eval - sigma_true_eval) / sigma_true_eval\n        \n        # 6. Compute error metrics.\n        max_lin = np.max(np.abs(rel_err_lin))\n        rms_lin = np.sqrt(np.mean(rel_err_lin**2))\n        \n        max_loglog = np.max(np.abs(rel_err_loglog))\n        rms_loglog = np.sqrt(np.mean(rel_err_loglog**2))\n        \n        all_results.append([max_lin, rms_lin, max_loglog, rms_loglog])\n\n    # 7. Format the final output string as required.\n    result_str_parts = []\n    for res in all_results:\n        result_str_parts.append(f\"[{','.join(f'{x:.10g}' for x in res)}]\")\n    final_output = f\"[{','.join(result_str_parts)}]\"\n\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "在实现一个数值算法后，我们如何确信它是正确的？计算科学中的一个基本实践是代码验证，即将数值解与已知的基准进行比较。本实践关注一个用于粒子衰减的时间离散化模型。我们将检验该数值近似解在时间步长趋于零时，是否收敛于从比尔-朗伯定律推导出的精确解析解。通过执行这项收敛性研究 ()，您将学会如何通过经验确定一个数值方法的精度阶数。这是一个强有力的技术，用于验证您的代码、理解其误差特性，并在将模拟应用于没有解析解的更复杂问题之前，建立对模拟结果的信心。",
            "id": "4015723",
            "problem": "考虑一个单能的氘中性束注入（NBI）粒子，穿过一个厚度为 $L$ 的一维板状等离子体，其位置由 $x(t) = v t$ 给出，其中 $v$ 是由动能 $E_0$ 决定的速率。该等离子体具有一个随空间变化的单位长度吸收系数 $\\kappa(x)$，由 $\\kappa(x) = \\kappa_0 + \\kappa_1 x$ 给出，其中 $\\kappa_0 \\ge 0$ 且 $\\kappa_1 \\ge 0$。粒子从 $x(0)=0$ 开始，在 $x(T)=L$ 处离开，其中 $T = L / v$。我们将穿越时间 $T$ 内的时间平均功率沉积 $\\overline{P}$ 定义为总沉积能量除以 $T$。所有量必须以国际单位制（SI）计算，最终功率必须以瓦特表示。\n\n基本原理：\n- 牛顿第二定律和运动学给出了沿板状等离子体匀速运动的速度 $v$ 的位置 $x(t) = v t$ 和时间 $T = L / v$。\n- 对于连续线性衰减 $\\kappa(x)$，Beer–Lambert 衰减定律给出了穿过距离 $L$ 后的存活概率 $S(L)$ 为 $S(L) = \\exp\\left(-\\int_0^L \\kappa(x) \\, dx\\right)$。\n- 穿越过程中的期望沉积能量为 $E_0 \\left(1 - S(L)\\right)$，因此精确的时间平均功率沉积为\n$$\n\\overline{P}_{\\mathrm{exact}} = \\frac{E_0\\left(1 - \\exp\\left(-\\int_0^L \\kappa(x) \\, dx\\right)\\right)}{T}.\n$$\n\n蒙特卡洛时间离散化基准：\n- 一个标准的时间离散化蒙特卡洛（MC）存活算法通过在大小为 $\\Delta t$ 的时间步长上进行一系列独立的伯努利试验来近似连续衰减，每步的存活因子为 $1 - \\lambda(t_n)\\Delta t$，其中单位时间风险率是 $\\lambda(t) = v \\kappa(x(t))$ 且 $t_n = n \\Delta t$。\n- 对于 $N = T / \\Delta t$ 个步长，离散存活概率为\n$$\nS_{\\Delta t} = \\prod_{n=0}^{N-1}\\left(1 - \\lambda(t_n)\\Delta t\\right),\n$$\n离散时间平均功率沉积为\n$$\n\\overline{P}_{\\Delta t} = \\frac{E_0\\left(1 - S_{\\Delta t}\\right)}{T}.\n$$\n- 当 $\\Delta t \\to 0$ 时，黎曼积 $\\prod_{n}(1 - \\lambda(t_n)\\Delta t)$ 收敛于 $\\exp\\left(-\\int_0^T \\lambda(t)\\, dt\\right)$，这意味着 $\\overline{P}_{\\Delta t} \\to \\overline{P}_{\\mathrm{exact}}$。目标是经验性地证明这种收敛性，并通过在对数-对数坐标上拟合误差 $|\\overline{P}_{\\Delta t} - \\overline{P}_{\\mathrm{exact}}|$ 与 $\\Delta t$ 的关系来估计精度阶数 $p$。\n\n物理定义和单位：\n- 氘的质量 $m_{\\mathrm{D}}$ 必须取为 $m_{\\mathrm{D}} = 2.014 \\, u$，其中 $u$ 是原子质量单位， $u = 1.66053906660 \\times 10^{-27} \\, \\mathrm{kg}$。\n- 动能以千电子伏特（keV）为单位指定，必须通过 $1 \\, \\mathrm{eV} = 1.602176634 \\times 10^{-19} \\, \\mathrm{J}$ 转换为焦耳。因此 $E_0 \\, [\\mathrm{J}] = E_0 \\, [\\mathrm{keV}] \\times 10^3 \\times 1.602176634 \\times 10^{-19}$。\n- 速率由 $v = \\sqrt{2 E_0 / m_{\\mathrm{D}}}$ 计算。\n- 吸收系数 $\\kappa_0$ 的单位为 $\\mathrm{m}^{-1}$，$\\kappa_1$ 的单位为 $\\mathrm{m}^{-2}$；精确存活概率计算使用 $\\int_0^L \\kappa(x)\\, dx = \\kappa_0 L + \\frac{1}{2} \\kappa_1 L^2$。\n\n经验阶数估计：\n- 对于一组递减的时间步长 $\\Delta t_k$，计算误差 $e_k = \\left|\\overline{P}_{\\Delta t_k} - \\overline{P}_{\\mathrm{exact}}\\right|$。\n- 将 $\\log(e_k)$ 对 $\\log(\\Delta t_k)$ 的关系拟合成一条直线；其斜率 $p$ 即为经验精度阶数。\n\n测试套件：\n提供以下三个基准案例。对于每个案例，程序必须构建一个时间步长序列 $\\Delta t_k$，使得对于 $N_k \\in \\{8, 16, 32, 64, 128, 256, 512\\}$，$N_k = T / \\Delta t_k$ 为整数。\n\n- 案例A（典型粒子束和中等梯度）：\n  - $E_0 = 80 \\, \\mathrm{keV}$，\n  - $L = 1.0 \\, \\mathrm{m}$，\n  - $\\kappa_0 = 0.2 \\, \\mathrm{m}^{-1}$，\n  - $\\kappa_1 = 0.1 \\, \\mathrm{m}^{-2}$。\n- 案例B（弱吸收、均匀介质）：\n  - $E_0 = 50 \\, \\mathrm{keV}$，\n  - $L = 2.0 \\, \\mathrm{m}$，\n  - $\\kappa_0 = 0.02 \\, \\mathrm{m}^{-1}$，\n  - $\\kappa_1 = 0.0 \\, \\mathrm{m}^{-2}$。\n- 案例C（强吸收和更陡梯度）：\n  - $E_0 = 100 \\, \\mathrm{keV}$，\n  - $L = 2.0 \\, \\mathrm{m}$，\n  - $\\kappa_0 = 0.5 \\, \\mathrm{m}^{-1}$，\n  - $\\kappa_1 = 0.3 \\, \\mathrm{m}^{-2}$。\n\n所需计算：\n- 对于每个案例，计算 $v$、$T$、$\\overline{P}_{\\mathrm{exact}}$，以及当 $N_k \\in \\{8, 16, 32, 64, 128, 256, 512\\}$ 时的 $\\overline{P}_{\\Delta t_k}$。在定义 $S_{\\Delta t_k}$ 的乘积中使用 $x_n = v n \\Delta t_k$ 和 $\\lambda(t_n) = v \\left(\\kappa_0 + \\kappa_1 x_n\\right)$。确保对于每个 $k$，$\\Delta t_k = T / N_k$。\n- 计算每个 $k$ 的绝对误差 $e_k$，并通过对 $\\log(e_k)$ 与 $\\log(\\Delta t_k)$ 进行最小二乘拟合来估计经验阶数 $p$。\n\n答案规格：\n- 角度不出现；无需角度单位。\n- 时间平均功率以瓦特表示。\n- 对于每个案例，程序必须输出一个列表，其中包含：作为浮点数的估计精度阶数 $p$，以及一个指示 $p$ 是否在区间 $[0.95, 1.05]$ 内的布尔值。\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表；每个案例的结果本身应为一个双元素列表。例如，最终输出格式应类似于 $[\\,[p_A, \\mathrm{bool}_A],\\,[p_B, \\mathrm{bool}_B],\\,[p_C, \\mathrm{bool}_C]\\,]$，其中每个 $p$ 是一个浮点数，每个布尔值是 $\\mathrm{True}$ 或 $\\mathrm{False}$。\n\n科学真实性：\n以上所有参数对于磁约束等离子体中的氘中性束注入都是物理上合理的，并能得出自洽的穿越时间和衰减因子。本任务的核心在于从 Beer–Lambert 定律推导期望沉积，并将离散时间蒙特卡洛存活乘积与精确积分进行基准比较，这与计算聚变科学中模拟束流衰减和等离子体中聚变产物阻止的实践直接相关。\n\n您的程序必须是自包含的，不使用任何输入，并按所述执行所有计算，仅返回指定格式的单行输出。",
            "solution": "该问题被评估为有效的，因为它在科学上基于粒子输运和数值分析的原理，问题提法适定，提供了所有必要信息，并且其表述是客观的。\n\n解决方案首先推导时间平均功率沉积的精确解析表达式，然后基于时间离散化建立数值模型。最后，通过分析数值模型误差相对于时间步长的收敛性来确定其精度阶数。\n\n首先，我们确定物理常数和转换关系。氘粒子的质量 $m_{\\mathrm{D}}$ 设定为 $m_{\\mathrm{D}} = 2.014 \\, u$，其中原子质量单位 $u = 1.66053906660 \\times 10^{-27} \\, \\mathrm{kg}$。粒子的动能 $E_0$ 以千电子伏特（$\\mathrm{keV}$）为单位给出，使用转换因子 $1 \\, \\mathrm{eV} = 1.602176634 \\times 10^{-19} \\, \\mathrm{J}$ 将其转换为焦耳（$\\mathrm{J}$）。因此，$E_0 \\, [\\mathrm{J}] = E_0 \\, [\\mathrm{keV}] \\times 10^3 \\times 1.602176634 \\times 10^{-19}$。粒子的速率 $v$ 根据其动能使用非相对论公式 $v = \\sqrt{2 E_0 / m_{\\mathrm{D}}}$ 确定。穿越厚度为 $L$ 的板状等离子体所需的时间为 $T = L / v$。\n\n时间平均功率沉积的解析解 $\\overline{P}_{\\mathrm{exact}}$ 基于 Beer-Lambert 衰减定律。粒子穿过长度为 $L$ 的板状等离子体后存活的概率由 $S(L) = \\exp(-\\Lambda)$ 给出，其中 $\\Lambda$ 是积分衰减系数，通常称为光学深度。对于随空间变化的吸收系数 $\\kappa(x) = \\kappa_0 + \\kappa_1 x$，该积分为：\n$$\n\\Lambda = \\int_0^L \\kappa(x) \\, dx = \\int_0^L (\\kappa_0 + \\kappa_1 x) \\, dx = \\left[ \\kappa_0 x + \\frac{1}{2} \\kappa_1 x^2 \\right]_0^L = \\kappa_0 L + \\frac{1}{2}\\kappa_1 L^2\n$$\n粒子被吸收的概率为 $1 - S(L)$。由于粒子的初始能量为 $E_0$，在等离子体中沉积的期望能量为 $E_{dep} = E_0 (1 - S(L))$。时间平均功率沉积是该能量除以穿越时间 $T$：\n$$\n\\overline{P}_{\\mathrm{exact}} = \\frac{E_{dep}}{T} = \\frac{E_0 \\left(1 - \\exp\\left(-\\left(\\kappa_0 L + \\frac{1}{2}\\kappa_1 L^2\\right)\\right)\\right)}{T}\n$$\n\n接下来，我们使用时间离散化的蒙特卡洛存活模型构建数值近似解 $\\overline{P}_{\\Delta t}$。穿越时间 $T$ 被划分为 $N$ 个持续时间为 $\\Delta t = T/N$ 的相等步长。在每个时间步 $t_n = n \\Delta t$（对于 $n=0, 1, \\dots, N-1$），粒子位于位置 $x_n = v t_n$。单位时间的瞬时吸收概率，或称风险率，为 $\\lambda(t) = v \\kappa(x(t))$。在单个小时间步 $\\Delta t$ 内的存活概率近似为 $1 - \\lambda(t_n) \\Delta t$。经过 $N$ 步后的总存活概率 $S_{\\Delta t}$ 是这些独立步骤存活概率的乘积：\n$$\nS_{\\Delta t} = \\prod_{n=0}^{N-1} \\left(1 - \\lambda(t_n) \\Delta t\\right) = \\prod_{n=0}^{N-1} \\left(1 - v\\left(\\kappa_0 + \\kappa_1 (v n \\Delta t)\\right) \\Delta t\\right)\n$$\n这是存活概率微分方程 $dS/dt = -\\lambda(t)S$ 的一个显式欧拉离散化。离散时间平均功率沉积则为：\n$$\n\\overline{P}_{\\Delta t} = \\frac{E_0 (1 - S_{\\Delta t})}{T}\n$$\n\n为了确定经验精度阶数 $p$，我们分析绝对误差 $e_k = |\\overline{P}_{\\Delta t_k} - \\overline{P}_{\\mathrm{exact}}|$ 随时间步长 $\\Delta t_k$ 变化的行为。对于一个 $p$ 阶方法，误差预期会根据关系式 $e \\approx C (\\Delta t)^p$ 进行缩放，其中 $C$ 是一个常数。对两边取自然对数可得：\n$$\n\\ln(e) \\approx \\ln(C) + p \\ln(\\Delta t)\n$$\n该方程具有直线形式 $y = mx + b$，其中 $y = \\ln(e)$，$x = \\ln(\\Delta t)$，斜率为 $m=p$，y轴截距为 $b=\\ln(C)$。通过为一系列递减的时间步长 $\\Delta t_k = T/N_k$（其中 $N_k \\in \\{8, 16, 32, 64, 128, 256, 512\\}$）计算误差 $e_k$，我们可以对数据对 $(\\ln(\\Delta t_k), \\ln(e_k))$ 进行线性最小二乘拟合。拟合得到的斜率即为精度阶数 $p$ 的经验估计值。这种数值格式属于前向欧拉类型，理论上预期为一阶精确，即 $p=1$。\n\n实现将通过以下步骤处理每个测试案例：\n1.  从给定的 $E_0$ 和 $L$ 计算物理参数 $v$ 和 $T$。\n2.  计算基准值 $\\overline{P}_{\\mathrm{exact}}$。\n3.  对于每个指定的步数 $N_k$，计算相应的 $\\Delta t_k$、数值近似值 $\\overline{P}_{\\Delta t_k}$ 和绝对误差 $e_k$。\n4.  对 $\\ln(\\Delta t_k)$ 和 $\\ln(e_k)$ 集合进行线性回归，以找到斜率 $p$。\n5.  评估计算出的 $p$ 是否在范围 $[0.95, 1.05]$ 内。\n6.  将所有案例的结果汇总成指定的最终输出格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy is not strictly needed as numpy.polyfit is sufficient.\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases and print results.\n    \"\"\"\n    \n    # Define fundamental physical constants in SI units.\n    U_KG = 1.66053906660e-27  # Atomic mass unit in kg\n    EV_J = 1.602176634e-19    # Electron-volt in Joules\n    \n    # Mass of Deuterium in kg\n    M_D_KG = 2.014 * U_KG\n\n    def process_case(E0_keV, L_m, k0_m_inv, k1_m_inv_2):\n        \"\"\"\n        Processes a single test case to calculate the empirical order of accuracy.\n\n        Args:\n            E0_keV (float): Initial kinetic energy in keV.\n            L_m (float): Slab thickness in meters.\n            k0_m_inv (float): Constant part of absorption coefficient in m^-1.\n            k1_m_inv_2 (float): Linear part of absorption coefficient in m^-2.\n\n        Returns:\n            list: A list containing [estimated_order_p, is_first_order_bool].\n        \"\"\"\n        # 1. Convert units and calculate derived physical quantities.\n        E0_J = E0_keV * 1000.0 * EV_J\n        v_mps = np.sqrt(2 * E0_J / M_D_KG)\n        T_s = L_m / v_mps\n\n        # 2. Calculate the exact analytical solution for average power deposition.\n        integrated_kappa = k0_m_inv * L_m + 0.5 * k1_m_inv_2 * L_m**2\n        S_exact = np.exp(-integrated_kappa)\n        P_exact_W = E0_J * (1 - S_exact) / T_s\n\n        # 3. Calculate numerical approximations and errors for a range of time steps.\n        N_steps_list = [8, 16, 32, 64, 128, 256, 512]\n        delta_t_values = []\n        error_values = []\n\n        for N_steps in N_steps_list:\n            dt = T_s / N_steps\n            delta_t_values.append(dt)\n\n            # Calculate the discrete survival probability S_dt\n            S_dt = 1.0\n            for n in range(N_steps):\n                t_n = n * dt\n                x_n = v_mps * t_n\n                lambda_tn = v_mps * (k0_m_inv + k1_m_inv_2 * x_n)\n                # Check to ensure the survival factor is non-negative.\n                # Based on pre-analysis, this condition holds for the given test cases.\n                survival_factor = 1.0 - lambda_tn * dt\n                S_dt *= survival_factor\n\n            # Calculate the discrete average power and the absolute error\n            P_dt_W = E0_J * (1 - S_dt) / T_s\n            error = np.abs(P_dt_W - P_exact_W)\n            error_values.append(error)\n\n        # 4. Perform a least-squares fit to find the order of accuracy.\n        log_delta_t = np.log(np.array(delta_t_values))\n        log_error = np.log(np.array(error_values))\n\n        # Fit a line (polynomial of degree 1) to log(error) vs log(delta_t)\n        # The slope of this line is the empirical order of accuracy 'p'.\n        p, _ = np.polyfit(log_delta_t, log_error, 1)\n\n        # 5. Check if the order is within the expected range for a first-order method.\n        is_first_order = 0.95 = p = 1.05\n        \n        return [float(p), bool(is_first_order)]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (typical beam and moderate gradient)\n        (80.0, 1.0, 0.2, 0.1),\n        # Case B (weakly absorbing, uniform medium)\n        (50.0, 2.0, 0.02, 0.0),\n        # Case C (strong absorption and sharper gradient)\n        (100.0, 2.0, 0.5, 0.3)\n    ]\n\n    results = []\n    for case in test_cases:\n        E0_keV, L_m, k0, k1 = case\n        result = process_case(E0_keV, L_m, k0, k1)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The default string representation of a Python list and its boolean\n    # elements matches the required output style implicitly.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}