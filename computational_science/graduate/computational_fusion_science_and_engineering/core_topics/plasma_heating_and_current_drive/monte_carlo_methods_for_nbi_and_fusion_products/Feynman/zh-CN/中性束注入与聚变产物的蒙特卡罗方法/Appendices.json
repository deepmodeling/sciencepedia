{
    "hands_on_practices": [
        {
            "introduction": "任何蒙特卡洛模拟设计的第一步都是估算所需的计算资源。本练习将中性束注入（NBI）系统的物理参数（如功率和能量）与模拟的统计要求直接联系起来。通过这个实践，你将学习如何推导和计算获得特定相对误差所需的粒子历史数量，这是确保模拟结果既准确又高效的基础。",
            "id": "4015715",
            "problem": "一个中性束注入 (NBI) 系统输送氘中性粒子，注入功率为 $P$，粒子动能为 $E_0$。注入的粒子速率由商 $\\dot{N} = P / E_0$ 定义，使用一致的单位。考虑能量沉积分数的蒙特卡洛 (MC) 估计，方法是将在均匀等离子体中沿直线束路径的电离事件视为空中泊松过程，单位长度的发生率为 $k = n_e \\sigma_i$，其中 $n_e$ 是电子数密度，$\\sigma_i$ 是有效电离截面。如果中性束穿过等离子体中长度为 $L$ 的弦，当弦内发生至少一次电离碰撞时，记录为沉积历史，否则计为穿透（shine-through）。假设每次历史如果在等离子体内电离，则沉积其全部初始能量 $E_0$，否则沉积能量为零。角度，在需要时，必须以弧度表示。\n\n从上述基本定义和均匀介质中碰撞的空间泊松过程的标准模型出发，推导如何计算所需的统计独立的 MC 历史数，以解析平均沉积分数估计量的指定相对标准误差。你的程序必须：\n\n- 使用 $1\\,\\mathrm{eV} = 1.602176634\\times 10^{-19}\\,\\mathrm{J}$ 将 $E_0 = 80\\,\\mathrm{keV}$ 转换为焦耳，并计算 $P = 5\\,\\mathrm{MW}$ 时的注入粒子速率。将注入粒子速率以 $\\mathrm{s}^{-1}$ 为单位表示为浮点数。\n- 对于一组给定的等离子体条件 $\\{n_e, \\sigma_i, L\\}$，将每次历史的沉积建模为一个伯努利随机变量，其成功概率等于在弦内发生至少一次碰撞的概率。用此来确定所需的最小历史数，以确保沉积分数的蒙特卡洛估计量的相对标准误差不大于 $r = 0.01$。\n- 设计一个 MC 源，该源从以 $E_0$ 为中心、标准差为 $2\\,\\mathrm{keV}$ 的正态分布中抽样历史能量，并从以 $0$ 为中心、标准差为 $0.02\\,\\mathrm{rad}$ 的正态分布中抽样注入角度，适用于窄束。虽然必须实现源抽样，但最终所需的数值输出是每个测试案例的粒子速率和所需历史数。\n\n使用以下三个等离子体条件的测试套件来计算所需的历史数，所有截面单位为平方米，密度单位为 $\\mathrm{m}^{-3}$，长度单位为米：\n\n- 测试案例 A (中等沉积): $n_e = 5.0\\times 10^{19}$, $\\sigma_i = 3.0\\times 10^{-20}$, $L = 1.0$。\n- 测试案例 B (低沉积): $n_e = 1.0\\times 10^{18}$, $\\sigma_i = 3.0\\times 10^{-20}$, $L = 1.0$。\n- 测试案例 C (高沉积): $n_e = 2.0\\times 10^{20}$, $\\sigma_i = 3.0\\times 10^{-20}$, $L = 1.0$。\n\n你的程序应生成单行输出，包含一个逗号分隔的列表，形式为 $[\\dot{N}, N_A, N_B, N_C]$，并用方括号括起来，其中 $\\dot{N}$ 是一个以 $\\mathrm{s}^{-1}$ 为单位的浮点数，$N_A, N_B, N_C$ 是整数。不应打印其他任何输出。",
            "solution": "问题陈述已经过验证，被认为是科学上可靠、定义明确且客观的。它基于粒子输运物理和蒙特卡洛统计分析的标准原理。提供了唯一解所需的所有必要数据和定义，并且没有内部矛盾或科学上不合理的情况。\n\n解答分为三部分：首先，计算注入的粒子速率；其次，推导所需蒙特卡洛历史数的公式；第三，将此公式应用于指定的测试案例。\n\n**第一部分：注入粒子速率计算**\n\n问题提供了注入束功率 $P = 5\\,\\mathrm{MW}$ 和每个氘中性粒子的初始动能 $E_0 = 80\\,\\mathrm{keV}$。注入粒子速率 $\\dot{N}$ 定义为功率与每个粒子能量之比，即 $\\dot{N} = P / E_0$。为确保单位一致，我们将两个量都转换为国际单位制（SI）单位。\n\n功率以兆瓦为单位给出，我们将其转换为瓦特（焦耳/秒）：\n$$P = 5\\,\\mathrm{MW} = 5 \\times 10^6 \\,\\mathrm{W} = 5 \\times 10^6 \\,\\mathrm{J/s}$$\n\n粒子能量以千电子伏特 ($keV$) 为单位给出，我们使用提供的转换因子 $1\\,\\mathrm{eV} = 1.602176634\\times 10^{-19}\\,\\mathrm{J}$ 将其转换为焦耳。\n$$E_0 = 80\\,\\mathrm{keV} = 80 \\times 10^3\\,\\mathrm{eV}$$\n$$E_0 = (80 \\times 10^3\\,\\mathrm{eV}) \\times (1.602176634 \\times 10^{-19}\\,\\mathrm{J/eV}) = 1.2817413072 \\times 10^{-14}\\,\\mathrm{J}$$\n\n现在，我们可以计算注入粒子速率 $\\dot{N}$：\n$$\\dot{N} = \\frac{P}{E_0} = \\frac{5 \\times 10^6 \\,\\mathrm{J/s}}{1.2817413072 \\times 10^{-14}\\,\\mathrm{J}} \\approx 3.9010006 \\times 10^{20} \\,\\mathrm{s}^{-1}$$\n这是每秒注入系统的中性粒子数量。\n\n**第二部分：所需蒙特卡洛历史数的推导**\n\n问题将中性粒子沿其路径的电离建模为空中泊松过程。该过程的单位长度发生率为 $k = n_e \\sigma_i$，其中 $n_e$ 是电子密度，$\\sigma_i$ 是有效电离截面。对于穿过均匀等离子体中长度为 $L$ 的弦的粒子，期望的碰撞次数为 $\\lambda = kL$。\n\n根据泊松分布，在该长度上观察到恰好 $m$ 次碰撞的概率由下式给出：\n$$P(m) = \\frac{\\lambda^m e^{-\\lambda}}{m!}$$\n\n如果长度 $L$ 内发生至少一次碰撞（$m \\ge 1$），则认为该粒子历史是“沉积的”。这个事件的概率，我们记为 $p$，是零次碰撞（$m=0$）概率的补集：\n$$p = P(m \\ge 1) = 1 - P(m=0)$$\n$$P(m=0) = \\frac{\\lambda^0 e^{-\\lambda}}{0!} = e^{-\\lambda} = e^{-kL}$$\n因此，沉积概率为：\n$$p = 1 - e^{-kL}$$\n\n蒙特卡洛模拟将每次粒子历史视为独立的伯努利试验。令随机变量 $X_i$ 代表第 $i$ 次历史的结果：$X_i = 1$ 表示沉积（概率为 $p$），$X_i = 0$ 表示穿透（概率为 $1-p$）。问题基于此二元结果定义了沉积分数估计量。\n\n沉积分数的真实均值（期望值）是 $\\mu = E[X_i] = 1 \\cdot p + 0 \\cdot (1-p) = p$。\n这个伯努利随机变量的方差是 $\\sigma^2 = \\text{Var}(X_i) = p(1-p)$。\n\n对于 $N$ 次独立的蒙特卡洛历史，平均沉积分数的估计量是 $\\hat{\\mu}_N = \\frac{1}{N} \\sum_{i=1}^N X_i$。\n该估计量的方差是：\n$$\\text{Var}(\\hat{\\mu}_N) = \\text{Var}\\left(\\frac{1}{N}\\sum_{i=1}^N X_i\\right) = \\frac{1}{N^2}\\sum_{i=1}^N \\text{Var}(X_i) = \\frac{N\\sigma^2}{N^2} = \\frac{\\sigma^2}{N} = \\frac{p(1-p)}{N}$$\n估计量的标准误差 $SE(\\hat{\\mu}_N)$ 是其方差的平方根：\n$$SE(\\hat{\\mu}_N) = \\sqrt{\\frac{p(1-p)}{N}}$$\n\n问题要求*相对*标准误差 $r$ 不大于指定值 $r_{max} = 0.01$。相对标准误差定义为标准误差除以真实均值：\n$$r = \\frac{SE(\\hat{\\mu}_N)}{\\mu} = \\frac{\\sqrt{p(1-p)/N}}{p} = \\frac{1}{\\sqrt{N}}\\sqrt{\\frac{p(1-p)}{p^2}} = \\frac{1}{\\sqrt{N}}\\sqrt{\\frac{1-p}{p}}$$\n\n我们设定条件 $r \\le r_{max}$：\n$$\\frac{1}{\\sqrt{N}}\\sqrt{\\frac{1-p}{p}} \\le r_{max}$$\n求解 $N$，我们将两边平方并重新整理：\n$$\\frac{1}{N}\\frac{1-p}{p} \\le r_{max}^2$$\n$$N \\ge \\frac{1-p}{p \\cdot r_{max}^2}$$\n由于 $N$ 必须是整数，所需的最小历史数是满足此不等式的最小整数，可以通过对右侧取上整（ceiling）得到：\n$$N_{min} = \\left\\lceil \\frac{1-p}{p \\cdot r_{max}^2} \\right\\rceil$$\n代入 $p = 1 - e^{-kL}$ 和 $1-p = e^{-kL}$，我们得到最终公式：\n$$N_{min} = \\left\\lceil \\frac{e^{-kL}}{(1 - e^{-kL}) r_{max}^2} \\right\\rceil$$\n\n**第三部分：应用于测试案例**\n\n我们现在使用 $r_{max} = 0.01$ 和 $L = 1.0\\,\\mathrm{m}$ 将此公式应用于三个测试案例。\n\n**测试案例 A (中等沉积):**\n$n_e = 5.0 \\times 10^{19}\\,\\mathrm{m}^{-3}$，$\\sigma_i = 3.0 \\times 10^{-20}\\,\\mathrm{m}^2$。\n$k_A = n_e \\sigma_i = (5.0 \\times 10^{19}) \\times (3.0 \\times 10^{-20}) = 1.5\\,\\mathrm{m}^{-1}$。\n参数 $\\lambda_A = k_A L = 1.5$。\n$$N_A = \\left\\lceil \\frac{e^{-1.5}}{(1 - e^{-1.5}) (0.01)^2} \\right\\rceil = \\left\\lceil \\frac{0.223130}{0.776870 \\times 10^{-4}} \\right\\rceil = \\lceil 2872.23 \\rceil = 2873$$\n\n**测试案例 B (低沉积):**\n$n_e = 1.0 \\times 10^{18}\\,\\mathrm{m}^{-3}$，$\\sigma_i = 3.0 \\times 10^{-20}\\,\\mathrm{m}^2$。\n$k_B = n_e \\sigma_i = (1.0 \\times 10^{18}) \\times (3.0 \\times 10^{-20}) = 0.03\\,\\mathrm{m}^{-1}$。\n参数 $\\lambda_B = k_B L = 0.03$。\n$$N_B = \\left\\lceil \\frac{e^{-0.03}}{(1 - e^{-0.03}) (0.01)^2} \\right\\rceil = \\left\\lceil \\frac{0.9704455}{(1 - 0.9704455) \\times 10^{-4}} \\right\\rceil = \\lceil 328390.13 \\rceil = 328391$$\n\n**测试案例 C (高沉积):**\n$n_e = 2.0 \\times 10^{20}\\,\\mathrm{m}^{-3}$，$\\sigma_i = 3.0 \\times 10^{-20}\\,\\mathrm{m}^2$。\n$k_C = n_e \\sigma_i = (2.0 \\times 10^{20}) \\times (3.0 \\times 10^{-20}) = 6.0\\,\\mathrm{m}^{-1}$。\n参数 $\\lambda_C = k_C L = 6.0$。\n$$N_C = \\left\\lceil \\frac{e^{-6.0}}{(1 - e^{-6.0}) (0.01)^2} \\right\\rceil = \\left\\lceil \\frac{0.00247875}{(1 - 0.00247875) \\times 10^{-4}} \\right\\rceil = \\lceil 24.85 \\rceil = 25$$\n\n结果是：$\\dot{N} \\approx 3.9010006 \\times 10^{20}\\,\\mathrm{s}^{-1}$, $N_A = 2873$, $N_B = 328391$, 且 $N_C = 25$。\n\n问题还要求实现一个蒙特卡洛源抽样程序，用于从指定的正态分布中抽样粒子能量和注入角度，该程序将包含在最终的程序代码中。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Although scipy is listed as available, it is not required for this problem.\n\ndef mc_source(E0_mean_keV, E0_std_keV, angle_mean_rad, angle_std_rad):\n    \"\"\"\n    Designs and samples from a Monte Carlo source for NBI particles.\n    \n    This function implements the source sampling as required by the problem\n    statement, generating a particle's initial energy and injection angle\n    from normal distributions. This function is included to fulfill the problem\n    requirements but is not directly used to compute the final numerical outputs.\n\n    Args:\n        E0_mean_keV (float): Mean injection energy in keV.\n        E0_std_keV (float): Standard deviation of injection energy in keV.\n        angle_mean_rad (float): Mean injection angle in radians.\n        angle_std_rad (float): Standard deviation of injection angle in radians.\n\n    Returns:\n        tuple[float, float]: A tuple containing the sampled energy (keV) and angle (rad).\n    \"\"\"\n    # Sample energy from a normal distribution\n    energy_keV = np.random.normal(loc=E0_mean_keV, scale=E0_std_keV)\n    # Sample angle from a normal distribution\n    angle_rad = np.random.normal(loc=angle_mean_rad, scale=angle_std_rad)\n    return energy_keV, angle_rad\n\ndef solve():\n    \"\"\"\n    Calculates the NBI particle rate and the required number of Monte Carlo\n    histories for different plasma conditions.\n    \"\"\"\n    \n    # --- Part 1: Injected Particle Rate Calculation ---\n    \n    # Constants and Givens\n    P_MW = 5.0  # Injected power in MW\n    E0_keV = 80.0  # Particle kinetic energy in keV\n    EV_TO_JOULE = 1.602176634e-19  # Conversion factor for eV to Joules\n\n    # Convert to SI units\n    P_watts = P_MW * 1e6  # Power in Watts (J/s)\n    E0_joules = E0_keV * 1e3 * EV_TO_JOULE  # Energy in Joules\n\n    # Calculate injected particle rate\n    n_dot = P_watts / E0_joules\n\n    # --- Part 2: Required Number of Histories Calculation ---\n\n    # Test suite of plasma conditions\n    test_cases = [\n        # Case A: moderate deposition\n        {'name': 'A', 'n_e': 5.0e19, 'sigma_i': 3.0e-20, 'L': 1.0},\n        # Case B: low deposition\n        {'name': 'B', 'n_e': 1.0e18, 'sigma_i': 3.0e-20, 'L': 1.0},\n        # Case C: high deposition\n        {'name': 'C', 'n_e': 2.0e20, 'sigma_i': 3.0e-20, 'L': 1.0},\n    ]\n\n    r_max = 0.01  # Maximum relative standard error\n\n    def calculate_min_histories(n_e, sigma_i, L, r):\n        \"\"\"\n        Computes the minimum number of MC histories for a given relative error.\n        \n        Args:\n            n_e (float): Electron number density (m^-3).\n            sigma_i (float): Effective ionization cross-section (m^2).\n            L (float): Chord length in plasma (m).\n            r (float): Target relative standard error.\n\n        Returns:\n            int: The minimum number of histories required.\n        \"\"\"\n        # Rate per unit length (inverse of mean free path)\n        k = n_e * sigma_i\n        \n        # Expected number of collisions over length L\n        lambda_val = k * L\n        \n        # Deposition probability p = 1 - exp(-lambda)\n        # Shine-through probability 1-p = exp(-lambda)\n        p = 1.0 - np.exp(-lambda_val)\n        \n        # If p is very close to 0 or 1, the number of histories can be huge or small.\n        # Handle the edge case of p=0 to avoid division by zero, though unlikely here.\n        if p == 0:\n            return np.iinfo(np.int64).max # Effectively infinite\n\n        # From r = sqrt((1-p)/p) / sqrt(N), we get N >= (1-p) / (p * r^2)\n        # 1-p = exp(-lambda_val)\n        num_histories_float = np.exp(-lambda_val) / (p * r**2)\n        \n        # The number of histories must be an integer, so take the ceiling.\n        return int(np.ceil(num_histories_float))\n\n    # Calculate required histories for each test case\n    results_N = []\n    for case in test_cases:\n        N_min = calculate_min_histories(case['n_e'], case['sigma_i'], case['L'], r_max)\n        results_N.append(N_min)\n        \n    N_A, N_B, N_C = results_N\n\n    # --- Part 3: Example call to the source sampler (not used in output) ---\n    # This call demonstrates the function's use as required by the problem.\n    E0_mean_keV_src = 80.0\n    E0_std_keV_src = 2.0\n    angle_mean_rad_src = 0.0\n    angle_std_rad_src = 0.02\n    _ = mc_source(E0_mean_keV_src, E0_std_keV_src, angle_mean_rad_src, angle_std_rad_src)\n\n    # Final print statement in the exact required format\n    # Output: [particle_rate (float), N_A (int), N_B (int), N_C (int)]\n    output_list = [n_dot, N_A, N_B, N_C]\n    print(f\"[{','.join(map(str, output_list))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "蒙特卡洛模拟的保真度在很大程度上取决于其物理模型的准确性，而这通常依赖于对实验或理论数据的精确处理。本练习探讨了在聚变等离子体模拟中一个至关重要但常被忽视的方面：截面数据的插值。你将通过比较线性和对数-对数插值方案，亲身体会为什么选择正确的插值方法对于处理跨越多个数量级的物理数据至关重要，从而避免引入显著的数值误差。",
            "id": "4015705",
            "problem": "中性束注入 (NBI) 和聚变产物输运蒙特卡罗算法通过在等离子体中推进带电和中性粒子，同时对由微观截面 $\\sigma(E)$（其中 $E$ 表示动能）控制的相互作用事件进行随机抽样。单位路径长度上发生相互作用的概率密度与乘积 $n \\sigma(E)$ 成正比，其中 $n$ 是靶密度，因此事件抽样的数值保真度取决于列表能量之间插值的 $\\sigma(E)$ 值的准确性和稳定性。在高温等离子体应用中，列表化的电离截面 $\\sigma_{\\mathrm{i}}(E)$ 和电荷交换截面 $\\sigma_{\\mathrm{cx}}(E)$ 通常在 $E$ 和 $\\sigma$ 上跨越多个数量级，这要求插值策略能够保持正性、在大动态范围内避免灾难性抵消，并捕捉截面典型的近似幂律行为。\n\n从截面的基本定义（即单位相对通量的速率系数）以及蒙特卡罗抽样规则（即自由程分布在宏观截面 $n \\sigma(E)$ 上呈指数形式）出发，设计并实现一种数值稳定的列表截面插值方案，该方案需遵守这些约束。具体来说，实现一个在 $\\log(E)$ 和 $\\log(\\sigma)$ 中进行线性插值的对数-对数插值方案，并量化在 $E$ 和 $\\sigma$ 上跨越多个数量级时，简单的线性插值所引入的误差。\n\n使用一组科学上合理的解析截面模型来生成列表数据，然后将插值结果与已知的“基准真相”模型进行比较，以量化插值误差。对于每个测试案例，在 $E \\in \\{10^3,10^4,10^5\\}$ 电子伏特 (eV) 处构建列表能量，并通过评估指定的基准真相模型生成相应的列表截面（单位为平方米，$\\mathrm{m}^2$）。在整个 $[10^3,10^5]$ eV 范围内对数均匀分布的密集 $E$ 值网格上评估两种插值。计算每种插值方法相对于基准真相模型的最大相对误差和均方根 (RMS) 相对误差。相对误差必须以小数形式报告（无单位）。\n\n需要比较的插值方法有：\n- 在原始 $(E,\\sigma)$ 坐标下的线性插值。\n- 在 $(\\log(E),\\log(\\sigma))$ 坐标下的线性插值（对数-对数插值），通过取指数映射回 $\\sigma(E)$。\n\n在计算对数时，仅考虑严格为正的 $\\sigma(E)$；在所有提供的测试案例中，$\\sigma(E)$ 在指定范围内均为严格正值。\n\n能量以电子伏特 (eV) 表示，截面以平方米 ($\\mathrm{m}^2$) 表示。误差度量是无量纲的。\n\n测试套件：\n- 案例 1（类电荷交换的幂律）：$\\sigma_{\\mathrm{cx}}(E) = A E^{p}$，其中 $p = -0.5$，振幅 $A$ 的选择使得 $\\sigma_{\\mathrm{cx}}(10^3\\,\\mathrm{eV}) = 10^{-19}\\,\\mathrm{m}^2$；在 $E \\in [10^3,10^5]$ eV 上评估。\n- 案例 2（带峰值的类电离）：$\\sigma_{\\mathrm{i}}(E) = A E^{0.7} \\exp\\!\\left(-E/E_0\\right)$，其中 $E_0 = 3\\times 10^4$ eV，振幅 $A$ 的选择使得 $\\sigma_{\\mathrm{i}}(E_0) = 5\\times 10^{-21}\\,\\mathrm{m}^2$；在 $E \\in [10^3,10^5]$ eV 上评估。\n- 案例 3（平台区）：$\\sigma(E) = C$ 为常数，其中 $C = 10^{-20}\\,\\mathrm{m}^2$；在 $E \\in [10^3,10^5]$ eV 上评估。\n- 案例 4（陡峭的幂律）：$\\sigma(E) = A E^{p}$，其中 $p = -2.0$，振幅 $A$ 的选择使得 $\\sigma(10^3\\,\\mathrm{eV}) = 10^{-19}\\,\\mathrm{m}^2$；在 $E \\in [10^3,10^5]$ eV 上评估。\n\n评估网格：\n- 使用 $N = 2001$ 个评估能量，在 $10^3$ eV 到 $10^5$ eV 之间对数均匀分布。\n\n误差度量：\n- 最大相对误差：$\\max_{E}\\left|\\dfrac{\\sigma_{\\mathrm{interp}}(E) - \\sigma_{\\mathrm{true}}(E)}{\\sigma_{\\mathrm{true}}(E)}\\right|$。\n- 均方根 (RMS) 相对误差：$\\sqrt{\\dfrac{1}{N}\\sum_{j=1}^{N}\\left(\\dfrac{\\sigma_{\\mathrm{interp}}(E_j) - \\sigma_{\\mathrm{true}}(E_j)}{\\sigma_{\\mathrm{true}}(E_j)}\\right)^2}$。\n\n您的程序必须为每个测试案例实现以下功能：\n- 在指定的列表能量处生成列表截面。\n- 构建两种插值（线性和对数-对数）。\n- 在评估网格上评估插值并计算误差度量。\n- 生成最终输出，为包含四个测试案例结果列表的单行。每个结果必须是一个包含四个浮点数的列表：$[\\text{max\\_lin}, \\text{rms\\_lin}, \\text{max\\_loglog}, \\text{rms\\_loglog}]$，其中 $\\text{max\\_lin}$ 和 $\\text{rms\\_lin}$ 是线性插值的最大和 RMS 相对误差，而 $\\text{max\\_loglog}$ 和 $\\text{rms\\_loglog}$ 是对数-对数插值的相应误差。程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[[a,b,c,d],[\\dots],\\dots]$）。\n\n不需要用户输入。程序必须是自包含且确定性的。",
            "solution": "该问题要求设计并比较两种用于原子截面数据 $\\sigma(E)$ 的数值插值方案，其中 $E$ 表示射弹粒子的动能。这是计算物理学中的一项基础任务，特别是在用于模拟聚变等离子体中粒子输运的蒙特卡罗模拟中，例如中性束注入 (NBI) 加热和追踪高能聚变产物。在给定路径长度上发生相互作用事件的概率与宏观截面 $\\Sigma(E) = n \\sigma(E)$ 成正比，其中 $n$ 是靶粒子密度。因此，对这些随机事件进行抽样的数值保真度取决于在列表数据点之间准确、稳定地评估 $\\sigma(E)$ 的能力。\n\n截面数据在能量 $E$ 和截面 $\\sigma$ 上通常跨越数个数量级。一个稳健的插值方案必须保持正性（因为 $\\sigma(E) > 0$），避免灾难性抵消，并理想地捕捉通常由幂律近似的潜在物理趋势。问题指定了对两种插值方法进行比较，这两种方法用于在两个列表点 $(E_1, \\sigma_1)$ 和 $(E_2, \\sigma_2)$ 之间进行插值。\n\n第一种方法是在原始 $(E, \\sigma)$ 坐标系中的标准线性插值。对于能量 $E$ 满足 $E_1 \\le E \\le E_2$，插值截面 $\\sigma_{\\mathrm{lin}}(E)$ 由连接两点的直线公式给出：\n$$\n\\sigma_{\\mathrm{lin}}(E) = \\sigma_1 + (E - E_1) \\frac{\\sigma_2 - \\sigma_1}{E_2 - E_1}\n$$\n这种方法简单且计算速度快，但如果 $\\sigma$ 值接近于零且数据有噪声，它不能内在地保证正性，并且可能无法很好地表示许多截面的函数形式。\n\n第二种方法是对数-对数插值，其动机是许多截面至少近似遵循幂律关系 $\\sigma(E) \\propto E^p$ 这一常见观察。取自然对数将其转换为线性关系：$\\log(\\sigma) = p \\log(E) + \\text{constant}$。这表明在 $(\\log E, \\log \\sigma)$ 空间中进行线性插值是一种更具物理基础的方法。令 $u = \\log(E)$ 和 $v = \\log(\\sigma)$。在这个变换后的空间中进行线性插值得到：\n$$\nv(u) = v_1 + (u - u_1) \\frac{v_2 - v_1}{u_2 - u_1}\n$$\n将原始变量代回，我们得到插值截面 $\\sigma_{\\mathrm{loglog}}(E)$ 的对数表达式：\n$$\n\\log(\\sigma_{\\mathrm{loglog}}(E)) = \\log(\\sigma_1) + (\\log(E) - \\log(E_1)) \\frac{\\log(\\sigma_2) - \\log(\\sigma_1)}{\\log(E_2) - \\log(E_1)}\n$$\n然后通过取指数求得截面本身，$\\sigma_{\\mathrm{loglog}}(E) = \\exp(\\log(\\sigma_{\\mathrm{loglog}}(E)))$。此操作内在地保证了 $\\sigma_{\\mathrm{loglog}}(E) > 0$。这个公式可以巧妙地重写为局部幂律形式，这突出了其结构：\n$$\n\\sigma_{\\mathrm{loglog}}(E) = \\sigma_1 \\left( \\frac{E}{E_1} \\right)^m, \\quad \\text{其中指数 } m = \\frac{\\log(\\sigma_2 / \\sigma_1)}{\\log(E_2 / E_1)}\n$$\n对于任何纯幂律函数，此形式都是精确的。\n\n实现将遵循一个精确的数值实验。对于四个测试案例中的每一个，使用一个“基准真相”解析截面模型，在三个指定的能量点 $E \\in \\{10^3, 10^4, 10^5\\}$ 电子伏特 (eV) 生成一个稀疏的截面表。两种插值方案都基于这个 3 点表格构建。然后，通过在 $N=2001$ 个点的密集评估网格上将其值与基准真相模型进行比较，来评估每种插值的准确性，该网格在整个能量范围 $[10^3, 10^5]\\,$eV 上呈对数分布。\n\n定量比较依赖于在评估网格 $\\{E_j\\}_{j=1}^N$ 上计算的两种标准误差度量：\n1.  最大相对误差，用于衡量最坏情况下的偏差：\n$$\n\\text{Max Rel Err} = \\max_{j} \\left| \\frac{\\sigma_{\\mathrm{interp}}(E_j) - \\sigma_{\\mathrm{true}}(E_j)}{\\sigma_{\\mathrm{true}}(E_j)} \\right|\n$$\n2.  均方根 (RMS) 相对误差，提供平均误差的度量：\n$$\n\\text{RMS Rel Err} = \\sqrt{\\frac{1}{N} \\sum_{j=1}^{N} \\left( \\frac{\\sigma_{\\mathrm{interp}}(E_j) - \\sigma_{\\mathrm{true}}(E_j)}{\\sigma_{\\mathrm{true}}(E_j)} \\right)^2}\n$$\nPython 实现将为四个测试案例中的每一个计算这四个误差值（线性和对数-对数方法的最大和 RMS 误差）。选择这些案例是为了测试幂律（其中对数-对数预计是精确的）、常数（其中两者都是精确的）以及一个类似于实际电离截面的更复杂形状下的行为。结果将证明，对于这类问题，基于物理动机的对数-对数插值方案具有卓越的稳定性和准确性。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares linear and log-log interpolation for atomic cross sections.\n    \"\"\"\n    # Define tabulated energies and the evaluation grid as per the problem.\n    E_tab = np.array([1e3, 1e4, 1e5])\n    N_eval = 2001\n    E_eval = np.logspace(np.log10(E_tab[0]), np.log10(E_tab[-1]), N_eval)\n\n    # --- Define Ground Truth Models for Each Test Case ---\n\n    # Case 1: Charge exchange-like power law\n    # sigma(E) = A * E^p, with p = -0.5\n    # A is set such that sigma(1e3 eV) = 1e-19 m^2\n    A_case1 = 1e-19 / (1e3 ** -0.5)\n    def sigma_case1(E):\n        return A_case1 * E**(-0.5)\n\n    # Case 2: Ionization-like with a peak\n    # sigma(E) = A * E^0.7 * exp(-E/E0), with E0 = 3e4 eV\n    # A is set such that sigma(E0) = 5e-21 m^2\n    E0_case2 = 3e4\n    A_case2 = (5e-21) / (E0_case2**0.7 * np.exp(-1.0))\n    def sigma_case2(E):\n        return A_case2 * E**0.7 * np.exp(-E / E0_case2)\n\n    # Case 3: Plateau (constant)\n    # sigma(E) = 1e-20 m^2\n    def sigma_case3(E):\n        return np.full_like(E, 1e-20, dtype=float)\n\n    # Case 4: Steep power law\n    # sigma(E) = A * E^p, with p = -2.0\n    # A is set such that sigma(1e3 eV) = 1e-19 m^2\n    A_case4 = 1e-19 / (1e3 ** -2.0)\n    def sigma_case4(E):\n        return A_case4 * E**(-2.0)\n\n    test_cases = [\n        {\"name\": \"Power Law (p=-0.5)\", \"func\": sigma_case1},\n        {\"name\": \"Ionization-like\", \"func\": sigma_case2},\n        {\"name\": \"Plateau\", \"func\": sigma_case3},\n        {\"name\": \"Power Law (p=-2.0)\", \"func\": sigma_case4},\n    ]\n    \n    all_results = []\n\n    for case in test_cases:\n        sigma_true_func = case[\"func\"]\n        \n        # 1. Generate tabulated cross sections at specified energies.\n        sigma_tab = sigma_true_func(E_tab)\n        \n        # 2. Evaluate ground truth model on the dense evaluation grid.\n        sigma_true_eval = sigma_true_func(E_eval)\n\n        # 3. Construct and evaluate the linear interpolant.\n        # np.interp performs linear interpolation in (E, sigma) space.\n        sigma_lin_eval = np.interp(E_eval, E_tab, sigma_tab)\n        \n        # 4. Construct and evaluate the log-log interpolant.\n        # This is equivalent to linear interpolation in (log E, log sigma) space.\n        log_E_tab = np.log(E_tab)\n        log_sigma_tab = np.log(sigma_tab)\n        log_E_eval = np.log(E_eval)\n        \n        # Check for non-positive sigma_tab, which would invalidate log.\n        # Problem statement guarantees this will not happen for the given cases.\n        if np.any(sigma_tab = 0):\n            # This branch should not be taken in this problem.\n            # Handle error appropriately in a general-purpose code.\n            # For this problem, we can just produce NaN errors.\n            sigma_loglog_eval = np.full_like(E_eval, np.nan)\n        else:\n            log_sigma_loglog_eval = np.interp(log_E_eval, log_E_tab, log_sigma_tab)\n            sigma_loglog_eval = np.exp(log_sigma_loglog_eval)\n\n        # 5. Calculate relative errors for both methods.\n        # The denominator sigma_true_eval is strictly positive for all cases.\n        rel_err_lin = (sigma_lin_eval - sigma_true_eval) / sigma_true_eval\n        rel_err_loglog = (sigma_loglog_eval - sigma_true_eval) / sigma_true_eval\n        \n        # 6. Compute error metrics.\n        max_lin = np.max(np.abs(rel_err_lin))\n        rms_lin = np.sqrt(np.mean(rel_err_lin**2))\n        \n        max_loglog = np.max(np.abs(rel_err_loglog))\n        rms_loglog = np.sqrt(np.mean(rel_err_loglog**2))\n        \n        all_results.append([max_lin, rms_lin, max_loglog, rms_loglog])\n\n    # 7. Format the final output string as required.\n    result_str_parts = []\n    for res in all_results:\n        result_str_parts.append(f\"[{','.join(f'{x:.10g}' for x in res)}]\")\n    final_output = f\"[{','.join(result_str_parts)}]\"\n\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了蒙特卡洛模拟的基础之后，下一个挑战是提高其计算效率，尤其是在处理具有复杂空间变化的物理问题时。本练习将向你介绍一种强大的方差缩减技术——零碰撞（或称Woodcock追踪）方法。你将通过推导和实现最优的分段常数“包络截面”，学习如何从根本上优化算法，最大限度地减少不产生物理相互作用的“虚拟”计算步骤，从而显著降低模拟的计算成本。",
            "id": "4015707",
            "problem": "考虑中性束注入（NBI, Neutral Beam Injection）中性粒子或聚变产物穿过磁约束等离子体的直线零碰撞（也称 Woodcock）追踪，该过程沿由归一化环向磁通坐标 $s \\in [0,1]$ 参数化的单一特征路径建模。真实的宏观总截面分布是一个已知的非负函数 $s \\mapsto \\Sigma_t(s)$。零碰撞方法引入一个控制截面 $s \\mapsto \\hat{\\Sigma}_t(s)$，使得对于所有 $s \\in [0,1]$，都有 $\\hat{\\Sigma}_t(s) \\ge \\Sigma_t(s)$。在一个与磁通面相关联的分段常数实现中，我们将 $[0,1]$ 划分为 $K$ 个等宽区域 $[s_{i-1}, s_i]$（其中 $s_i = i/K$），并限制 $\\hat{\\Sigma}_t$ 在每个区域上为常数。在一个统一全局实现中，$\\hat{\\Sigma}_t$ 在整个 $[0,1]$ 区间上是一个单一常数。\n\n基本和建模假设：\n- 根据 Woodcock 追踪方法的构造，对于任何作为真实截面上界的容许控制截面 $s \\mapsto \\hat{\\Sigma}_t(s)$，每单位微分路径长度 $ds$ 的期望碰撞尝试次数等于 $\\hat{\\Sigma}_t(s)\\,ds$，而每单位 $ds$ 的期望真实碰撞次数等于 $\\Sigma_t(s)\\,ds$。\n- 期望和积分的线性性质适用。\n- 粒子单调地穿过整个区间 $s \\in [0,1]$ 一次，因此在归一化坐标下的路径长度为 1（无量纲）。本问题中报告的所有量均为无量纲数。\n\n任务：\n1) 从上述基础出发，从第一性原理推导出在划分 $\\{[s_{i-1}, s_i]\\}_{i=1}^K$ 上的分段常数控制函数 $s \\mapsto \\hat{\\Sigma}_t(s)$，该函数在点态约束 $\\hat{\\Sigma}_t(s) \\ge \\Sigma_t(s)$ 和分段常数限制下，最小化了在 $s \\in [0,1]$ 上的期望零碰撞次数。然后，对于统一全局控制截面，定义相应的容许常数和导致的期望零碰撞次数。解释为何这些构造对于其各自的容许类别是最优的。\n\n2) 实现一个确定性数值算法，为每个指定的测试用例计算：\n- 使用在磁通面区域上的最优分段常数控制截面时的期望零碰撞次数，\n- 使用最优统一全局控制截面时的期望零碰撞次数，\n- 以及定义为小数 $(E_{\\text{uniform}} - E_{\\text{piecewise}})/E_{\\text{uniform}}$ 的成本降低分数。\n使用至少 $N \\ge 20000$ 个点的均匀求积法来计算 $s$ 上的积分，并使用每个区域至少 $M \\ge 1000$ 个点的均匀网格来近似计算每个区域内的上确界。将报告的每个浮点数四舍五入到 $6$ 位小数。\n\n3) 设计您的程序以解决以下测试套件。对于每个用例，$K$ 表示等宽磁通面区域的数量，并指定了 $\\Sigma_t(s)$：\n- 用例 A（多项式）：$K = 4$，且\n$$\n\\Sigma_t(s) = \\Sigma_0 \\bigl(1 + \\alpha s + \\beta s^2\\bigr), \\quad \\Sigma_0 = 2.0,\\ \\alpha = 1.5,\\ \\beta = 0.5.\n$$\n- 用例 B（芯部峰值高斯）：$K = 5$，且\n$$\n\\Sigma_t(s) = \\Sigma_0 \\bigl(1 + c\\, e^{-(s/\\sigma)^2}\\bigr), \\quad \\Sigma_0 = 1.0,\\ c = 3.0,\\ \\sigma = 0.3.\n$$\n- 用例 C（边界峰值幂律）：$K = 3$，且\n$$\n\\Sigma_t(s) = \\Sigma_0 \\bigl(1 + c\\, s^p\\bigr), \\quad \\Sigma_0 = 0.5,\\ c = 5.0,\\ p = 4.\n$$\n- 用例 D（边界检查，单区域）：$K = 1$，且\n$$\n\\Sigma_t(s) = \\Sigma_0 \\bigl(1 + \\alpha s\\bigr), \\quad \\Sigma_0 = 1.2,\\ \\alpha = 2.0.\n$$\n\n输出格式：\n- 对于每个测试用例，输出一个包含三个浮点数的列表 $[E_{\\text{piecewise}}, E_{\\text{uniform}}, \\text{reduction}]$，其中 $E_{\\text{piecewise}}$ 是使用最优分段常数控制截面时的期望零碰撞次数，$E_{\\text{uniform}}$ 是使用最优统一全局控制截面时的期望零碰撞次数，$\\text{reduction}$ 是成本降低分数 $(E_{\\text{uniform}} - E_{\\text{piecewise}})/E_{\\text{uniform}}$，所有值都四舍五入到 6 位小数。\n- 您的程序应生成单行输出，其中包含用例 A–D 的结果，形式为这些列表的逗号分隔列表，按顺序排列，并用方括号括起来。例如，打印的行必须如下所示\n$[ [x_A,y_A,z_A],[x_B,y_B,z_B],[x_C,y_C,z_C],[x_D,y_D,z_D] ]$\n其中每个 $x_\\cdot$、$y_\\cdot$、$z_\\cdot$ 都四舍五入到 6 位小数。\n- 所有输出都是无量纲的。不涉及角度。\n\n您提交的必须是一个完整的、可运行的程序，该程序能完全按照规定计算这些量，并以所描述的精确格式打印单行输出。",
            "solution": "该问题要求推导和计算与计算输运理论中的零碰撞（Woodcock）追踪方法相关的量。核心任务是为给定的真实截面 $\\Sigma_t(s)$ 找到最优的控制截面 $\\hat{\\Sigma}_t(s)$，并计算由两类控制截面（分段常数和统一全局）产生的期望零碰撞次数。\n\n**1. 第一性原理推导**\n\n设 $s \\in [0,1]$ 为归一化路径长度。真实的宏观总截面是 $\\Sigma_t(s)$，控制截面是 $\\hat{\\Sigma}_t(s)$，其约束条件为对于所有 $s \\in [0,1]$，都有 $\\hat{\\Sigma}_t(s) \\ge \\Sigma_t(s)$。\n\n根据问题的假设：\n- 每单位微分路径长度 $ds$ 的期望碰撞尝试次数为 $dE_{\\text{attempts}} = \\hat{\\Sigma}_t(s) ds$。\n- 每单位微分路径长度 $ds$ 的期望真实碰撞次数为 $dE_{\\text{true}} = \\Sigma_t(s) ds$。\n\n零碰撞次数是尝试次数减去真实碰撞次数。根据期望的线性性质，每单位微分路径长度 $ds$ 的期望零碰撞次数为：\n$$ dE_{\\text{null}} = dE_{\\text{attempts}} - dE_{\\text{true}} = (\\hat{\\Sigma}_t(s) - \\Sigma_t(s)) ds $$\n\n在整个路径上，总的期望零碰撞次数 $E_{\\text{null}}$ 是此微分量在定义域 $s \\in [0,1]$ 上的积分：\n$$ E_{\\text{null}}[\\hat{\\Sigma}_t] = \\int_0^1 (\\hat{\\Sigma}_t(s) - \\Sigma_t(s)) ds $$\n这可以分为两部分：\n$$ E_{\\text{null}}[\\hat{\\Sigma}_t] = \\int_0^1 \\hat{\\Sigma}_t(s) ds - \\int_0^1 \\Sigma_t(s) ds $$\n令 $C(\\hat{\\Sigma}_t) = \\int_0^1 \\hat{\\Sigma}_t(s) ds$ 为总的期望碰撞尝试次数，这是蒙特卡洛模拟中计算成本的主要度量。令 $C_{\\text{true}} = \\int_0^1 \\Sigma_t(s) ds$ 为总的期望真实碰撞次数。对于一个给定的问题，$\\Sigma_t(s)$ 是固定的，因此 $C_{\\text{true}}$ 是一个常数。因此，最小化期望零碰撞次数 $E_{\\text{null}}$ 等价于最小化计算成本 $C(\\hat{\\Sigma}_t)$。\n\n**2. 最优分段常数控制截面**\n\n定义域 $[0,1]$ 被划分为 $K$ 个等宽区域 $R_i = [s_{i-1}, s_i]$，其中 $s_i = i/K$，对于 $i=1, \\dots, K$。控制截面 $\\hat{\\Sigma}_t(s)$ 在每个区域 $R_i$ 内被限制为一个常数值，记为 $c_i$。\n控制截面约束 $\\hat{\\Sigma}_t(s) \\ge \\Sigma_t(s)$ 意味着对于每个区域 $R_i$，常数 $c_i$ 必须满足对于所有 $s \\in R_i$ 都有 $c_i \\ge \\Sigma_t(s)$。这等价于要求 $c_i \\ge \\sup_{s \\in R_i} \\Sigma_t(s)$。\n\n要最小化的成本是 $C(\\hat{\\Sigma}_t) = \\int_0^1 \\hat{\\Sigma}_t(s) ds = \\sum_{i=1}^K \\int_{s_{i-1}}^{s_i} c_i ds$。由于区域宽度相等，为 $\\Delta s = 1/K$，这变为：\n$$ C(\\hat{\\Sigma}_t) = \\sum_{i=1}^K c_i \\cdot \\frac{1}{K} = \\frac{1}{K} \\sum_{i=1}^K c_i $$\n为了最小化这个和，我们必须在满足其约束的情况下，将每个 $c_i$ 选择得尽可能小。每个 $c_i$ 的最小容许值是 $c_i^{\\text{opt}} = \\sup_{s \\in R_i} \\Sigma_t(s)$。这个选择是最优的，因为任何更小的值都会违反控制条件，而任何更大的值都会增加成本。\n\n最优分段常数控制截面为 $\\hat{\\Sigma}_t^{\\text{piecewise}}(s) = \\sum_{i=1}^K (\\sup_{s' \\in R_i} \\Sigma_t(s')) \\cdot \\mathbb{I}_{R_i}(s)$，其中 $\\mathbb{I}_{R_i}$ 是区域 $R_i$ 的指示函数。相应的最小成本是：\n$$ C_{\\text{piecewise}} = \\frac{1}{K} \\sum_{i=1}^K \\sup_{s \\in [(i-1)/K, i/K]} \\Sigma_t(s) $$\n对于这个最优情况，问题所要求的期望零碰撞次数是：\n$$ E_{\\text{piecewise}} = C_{\\text{piecewise}} - C_{\\text{true}} = \\frac{1}{K} \\sum_{i=1}^K \\sup_{s \\in [(i-1)/K, i/K]} \\Sigma_t(s) - \\int_0^1 \\Sigma_t(s) ds $$\n\n**3. 最优统一全局控制截面**\n\n在这里，控制截面被限制为在整个区间 $[0,1]$ 上的单个常数 $C$，即 $\\hat{\\Sigma}_t(s) = C$。控制截面约束要求对于所有 $s \\in [0,1]$ 都有 $C \\ge \\Sigma_t(s)$。这等价于 $C \\ge \\sup_{s \\in [0,1]} \\Sigma_t(s)$。\n\n要最小化的成本是 $C(\\hat{\\Sigma}_t) = \\int_0^1 C ds = C$。为了在约束条件下最小化 $C$，我们必须选择可能的最小值：\n$$ C^{\\text{opt}} = \\sup_{s \\in [0,1]} \\Sigma_t(s) $$\n最优统一全局控制截面是 $\\hat{\\Sigma}_t^{\\text{uniform}}(s) = \\sup_{s' \\in [0,1]} \\Sigma_t(s')$。对于这类控制截面，相应的最小成本是：\n$$ C_{\\text{uniform}} = \\sup_{s \\in [0,1]} \\Sigma_t(s) $$\n期望零碰撞次数是：\n$$ E_{\\text{uniform}} = C_{\\text{uniform}} - C_{\\text{true}} = \\sup_{s \\in [0,1]} \\Sigma_t(s) - \\int_0^1 \\Sigma_t(s) ds $$\n\n**4. 成本降低分数**\n\n问题将此定义为 $(E_{\\text{uniform}} - E_{\\text{piecewise}})/E_{\\text{uniform}}$。代入推导出的表达式：\n$$ \\text{reduction} = \\frac{(C_{\\text{uniform}} - C_{\\text{true}}) - (C_{\\text{piecewise}} - C_{\\text{true}})}{C_{\\text{uniform}} - C_{\\text{true}}} = \\frac{C_{\\text{uniform}} - C_{\\text{piecewise}}}{E_{\\text{uniform}}} $$\n由于分段常数控制截面是一个更精细的界，我们有对于所有 $s$ 都有 $\\hat{\\Sigma}_t^{\\text{uniform}}(s) \\ge \\hat{\\Sigma}_t^{\\text{piecewise}}(s)$，这意味着 $C_{\\text{uniform}} \\ge C_{\\text{piecewise}}$ 且 $E_{\\text{uniform}} \\ge E_{\\text{piecewise}}$，因此降低量是非负的。\n\n**5. 数值算法**\n\n需要计算的三个量是 $E_{\\text{piecewise}}$，$E_{\\text{uniform}}$ 和成本降低分数。这需要对 $C_{\\text{true}}$、$C_{\\text{piecewise}}$ 和 $C_{\\text{uniform}}$ 进行数值计算。\n\n- **积分计算 ($C_{\\text{true}}$)**：积分 $\\int_0^1 \\Sigma_t(s) ds$ 使用具有 $N=20000$ 个点的均匀求积法则（中点法则）进行近似。我们创建一个网格 $s_j = (j+0.5)/N$（其中 $j=0, \\dots, N-1$），并将积分近似为 $\\frac{1}{N} \\sum_{j=0}^{N-1} \\Sigma_t(s_j)$。\n\n- **上确界近似 ($C_{\\text{piecewise}}, C_{\\text{uniform}}$)**：在区间 $[a,b]$ 上 $\\Sigma_t(s)$ 的上确界通过在该区间内一个包含 $M=1000$ 个点的精细均匀网格上找到函数的最大值来近似。\n    - 对于 $C_{\\text{piecewise}}$，此操作对 $K$ 个区域 $[(i-1)/K, i/K]$ 中的每一个都执行一次。\n    - 对于 $C_{\\text{uniform}}$，此操作在全局区间 $[0,1]$ 上执行。为保持一致性，使用一个包含 $K \\times M$ 个点的网格。\n\n最终值根据这些数值近似计算得出，并按规定四舍五入到 6 位小数。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the final output.\n    \"\"\"\n    \n    # Numerical parameters as per the problem statement\n    N_INTEGRATION_POINTS = 20000\n    M_SUPREMUM_POINTS_PER_REGION = 1000\n\n    # Define the cross-section functions for each case\n    sigma_funcs = {\n        'A': lambda s, p: p['Sigma0'] * (1 + p['alpha'] * s + p['beta'] * s**2),\n        'B': lambda s, p: p['Sigma0'] * (1 + p['c'] * np.exp(-(s / p['sigma'])**2)),\n        'C': lambda s, p: p['Sigma0'] * (1 + p['c'] * s**p['p']),\n        'D': lambda s, p: p['Sigma0'] * (1 + p['alpha'] * s),\n    }\n    \n    # Define the parameter sets for each test case\n    test_cases = [\n        ('A', {'K': 4, 'Sigma0': 2.0, 'alpha': 1.5, 'beta': 0.5}),\n        ('B', {'K': 5, 'Sigma0': 1.0, 'c': 3.0, 'sigma': 0.3}),\n        ('C', {'K': 3, 'Sigma0': 0.5, 'c': 5.0, 'p': 4.0}),\n        ('D', {'K': 1, 'Sigma0': 1.2, 'alpha': 2.0}),\n    ]\n    \n    all_results = []\n\n    for case_id, params in test_cases:\n        K = params['K']\n        sigma_t = lambda s: sigma_funcs[case_id](s, params)\n\n        # 1. Compute C_true = integral of Sigma_t(s) from 0 to 1\n        s_integral_grid = (np.arange(N_INTEGRATION_POINTS) + 0.5) / N_INTEGRATION_POINTS\n        sigma_vals_integral = sigma_t(s_integral_grid)\n        C_true = np.mean(sigma_vals_integral)\n\n        # 2. Compute C_uniform = global supremum of Sigma_t(s) on [0,1]\n        # Use a grid of K*M points for global supremum for consistency\n        num_global_sup_points = K * M_SUPREMUM_POINTS_PER_REGION\n        s_global_sup_grid = np.linspace(0.0, 1.0, num_global_sup_points)\n        sigma_vals_global_sup = sigma_t(s_global_sup_grid)\n        C_uniform = np.max(sigma_vals_global_sup)\n        \n        # 3. Compute C_piecewise\n        sum_of_suprema = 0.0\n        for i in range(K):\n            s_start = i / K\n            s_end = (i + 1) / K\n            s_local_sup_grid = np.linspace(s_start, s_end, M_SUPREMUM_POINTS_PER_REGION)\n            sigma_vals_local_sup = sigma_t(s_local_sup_grid)\n            supremum_in_region = np.max(sigma_vals_local_sup)\n            sum_of_suprema += supremum_in_region\n        C_piecewise = sum_of_suprema / K\n\n        # 4. Calculate the final quantities\n        E_piecewise = C_piecewise - C_true\n        E_uniform = C_uniform - C_true\n        \n        # Avoid division by zero if E_uniform is zero or numerically very small\n        if E_uniform  1e-12:\n            reduction = 0.0\n        else:\n            reduction = (E_uniform - E_piecewise) / E_uniform\n            \n        all_results.append([E_piecewise, E_uniform, reduction])\n\n    # Format the output as specified\n    string_results = []\n    for res in all_results:\n        s_res = [f\"{v:.6f}\" for v in res]\n        string_results.append(f\"[{','.join(s_res)}]\")\n    \n    final_output = f\"[{','.join(string_results)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}