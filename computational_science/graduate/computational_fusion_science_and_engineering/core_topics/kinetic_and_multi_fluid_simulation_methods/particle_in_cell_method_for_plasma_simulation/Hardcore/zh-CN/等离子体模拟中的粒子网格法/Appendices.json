{
    "hands_on_practices": [
        {
            "introduction": "在粒子模拟（PIC）方法中，场求解器是连接粒子与宏观电磁场的桥梁。边界条件的选择并非简单的数值设定，它深刻地影响并约束着模拟系统的物理行为。本练习将引导您亲手实现静电模拟中三种常见的边界条件——周期性、狄利克雷（Dirichlet）和诺伊曼（Neumann）边界条件，并通过实践验证它们如何与高斯定律内在的电荷守恒要求保持一致。掌握这些知识对于构建物理上自洽且有意义的模拟至关重要 。",
            "id": "4027325",
            "problem": "您必须编写一个完整、可运行的程序，在一个一维静电粒子模拟 (PIC) 系统中构建并应用三种场边界条件——周期性、狄利克雷 (Dirichlet) 和诺伊曼 (Neumann)，并证明它们在满足高斯定律约束的全局电荷中性条件下，与粒子边界选择的一致性。目标是针对指定的测试用例，验证所实现的场边界条件在全局电荷中性和高斯定律积分约束的意义上，是否与隐含的粒子边界条件相符。\n\n允许的物理模型是一维静电学，遵循以下经过充分检验且被广泛接受的基本定律和定义：\n- 在静电学中，麦克斯韦方程组简化为高斯定律，即 $\\,\\partial_x E(x) = \\rho(x)/\\varepsilon_0\\,$ 和 $\\,E(x) = -\\partial_x \\phi(x)\\,$，其中 $\\,E(x)\\,$ 是电场，$\\,\\phi(x)\\,$ 是静电势，$\\,\\rho(x)\\,$ 是电荷密度，$\\,\\varepsilon_0\\,$ 是真空介电常数。\n- 结合这些可得到泊松方程 $\\,\\partial_{xx}\\phi(x) = -\\rho(x)/\\varepsilon_0\\,$.\n- 将高斯定律在域 $[0,L]$ 上积分，得到\n$$E(L) - E(0) = \\frac{1}{\\varepsilon_0}\\int_0^L \\rho(x)\\,dx,$$\n这意味着如果 $\\,E(L) = E(0)\\,$，则全局中性条件 $\\,\\int_0^L \\rho(x)\\,dx = 0\\,$ 成立，并且更一般地，它将边界场值与总封闭电荷联系起来。\n\n您必须在 $[0,L]$ 上构建以下场边界条件：\n1. 周期性边界条件：$\\,\\phi(0) = \\phi(L)\\,$ 且 $\\,\\partial_x \\phi(0) = \\partial_x \\phi(L)\\,$，等效于 $\\,E(0) = E(L)\\,$。根据高斯定律，这要求 $\\,\\int_0^L \\rho(x)\\,dx = 0\\,$ 以保证可解性和一致性。\n2. 狄利克雷 (Dirichlet) 边界条件：$\\,\\phi(0) = \\phi_L\\,$ 且 $\\,\\phi(L) = \\phi_R\\,$（在本问题中设 $\\,\\phi_L = \\phi_R = 0\\,$）。这些条件允许非零总电荷，且高斯定律约束 $\\,E(L) - E(0) = \\frac{1}{\\varepsilon_0}\\int_0^L \\rho(x)\\,dx\\,$.\n3. 诺伊曼 (Neumann) 边界条件：$\\,\\partial_x \\phi(0) = 0\\,$ 且 $\\,\\partial_x \\phi(L) = 0\\,$，等效于 $\\,E(0) = E(L) = 0\\,$。根据高斯定律，这要求 $\\,\\int_0^L \\rho(x)\\,dx = 0\\,$ 以保证一致性。\n\n程序必须严格按照逻辑和数学术语执行以下操作：\n- 在 $[0,L]$ 上使用包含 $\\,N\\,$ 个节点的一维均匀网格，间距为 $\\,\\Delta x = L/N\\,$，并在归一化的“代码单位”下工作，其中 $\\,\\varepsilon_0 = 1\\,$，粒子电荷为 $\\,q_i \\in \\{-1,+1\\}\\,$。所有量均为无量纲。不需要报告物理单位。\n- 使用云中元 (Cloud-In-Cell, CIC) 方法，将 $\\,N_p\\,$ 个电荷为 $\\,q_i\\,$ 的点粒子放置在位置 $\\,x_i \\in [0,L)\\,$ 并分配到网格上。对于位于位置 $\\,x_i\\,$ 的粒子，令 $\\,g_i = x_i/\\Delta x\\,$，$\\,j = \\lfloor g_i \\rfloor\\,$，以及 $\\,s = g_i - j\\,$。CIC 分配方法将 $\\,q_i(1-s)/\\Delta x\\,$ 添加到节点 $\\,j\\,$，将 $\\,q_i s/\\Delta x\\,$ 添加到节点 $\\,j+1\\,$。对于周期性场边界，当 $\\,j+1 = N\\,$ 时，通过将电荷分配到节点 $\\,0\\,$ 来实现环绕。对于非周期性场边界（狄利克雷和诺伊曼），如果 $\\,j+1 = N\\,$，则仅将电荷分配到节点 $\\,j\\,$（在右边界处截断）。\n- 为每种边界条件实现场求解器/验证器：\n  - 对于周期性场，通过检查中性条件 $\\,\\sum_{j=0}^{N-1}\\rho_j \\Delta x \\approx 0\\,$ 来验证一致性，这是 $\\,E(L)=E(0)\\,$ 的要求。\n  - 对于狄利克雷场，使用二阶中心差分求解内部节点 $\\,j=1,\\dots,N-2\\,$ 的离散泊松方程，\n    $$\\frac{\\phi_{j-1} - 2\\phi_j + \\phi_{j+1}}{\\Delta x^2} = -\\rho_j,$$\n    其中 $\\,\\phi_0 = \\phi_{N-1} = 0\\,$。然后通过单边差分计算边界场 $\\,E(0) \\approx -(\\phi_1 - \\phi_0)/\\Delta x\\,$ 和 $\\,E(L) \\approx -(\\phi_{N-1}-\\phi_{N-2})/\\Delta x\\,$。验证高斯定律残差 $\\,\\mathcal{R}_D = \\left[E(L) - E(0)\\right] - \\sum_{j=0}^{N-1}\\rho_j\\,\\Delta x\\,$ 是否足够小。\n  - 对于诺伊曼场，通过从左边界开始前向积分高斯定律来强制 $\\,E(0) = E(L) = 0\\,$：\n    $$E_{j+1} = E_j + \\Delta x\\,\\rho_j,\\quad E_0 = 0,$$\n    这得到 $\\,E_N - E_0 = \\sum_{j=0}^{N-1}\\rho_j \\Delta x\\,$。通过检查 $\\,E_N \\approx 0\\,$ 和 $\\,\\sum_{j=0}^{N-1}\\rho_j \\Delta x \\approx 0\\,$ 来验证中性条件和边界一致性。\n- 对上述所有“约等于”的检查，使用固定的绝对容差 $\\,\\tau = 10^{-10}\\,$.\n\n您必须实现并评估以下测试套件，每个套件由场边界条件、粒子边界解释和明确的粒子集定义：\n- 域和网格：$\\,L = 1\\,$, $\\,N = 64\\,$, $\\,\\Delta x = L/N\\,$, $\\,\\varepsilon_0 = 1\\,$.\n- 测试用例 1（周期性场，周期性粒子，全局中性）：电子位于位置 $[0.10, 0.30, 0.50, 0.70]$，电荷为 $-1$；离子位于位置 $[0.15, 0.35, 0.55, 0.75]$，电荷为 $+1$。\n- 测试用例 2（周期性场，周期性粒子，非中性）：仅有电子，位于位置 $[0.20, 0.40, 0.60]$，电荷为 $-1$。\n- 测试用例 3（狄利克雷场，$\\,\\phi(0)=\\phi(L)=0\\,$，吸收型粒子解释，非中性）：仅有电子，位于位置 $[0.20, 0.40, 0.60]$，电荷为 $-1$。\n- 测试用例 4（诺伊曼场，$\\,E(0)=E(L)=0\\,$，反射型粒子解释，全局中性）：与测试用例 1 相同的中性粒子集。\n- 测试用例 5（诺伊曼场，$\\,E(0)=E(L)=0\\,$，反射型粒子解释，非中性）：与测试用例 2 相同的非中性粒子集。\n\n对于每个测试用例，计算一个布尔值结果，指示场边界条件是否与粒子边界解释相一致：\n- 对于周期性场：如果 $\\,\\sum_j \\rho_j \\Delta x \\,$ 与零的差在 $\\,\\tau\\,$ 以内，则返回 true，否则返回 false。\n- 对于狄利克雷场：如果残差 $\\,\\mathcal{R}_D\\,$ 与零的差在 $\\,\\tau\\,$ 以内，则返回 true，否则返回 false。\n- 对于诺伊曼场：如果 $\\,E_N\\,$ 和 $\\,\\sum_j \\rho_j \\Delta x\\,$ 与零的差均在 $\\,\\tau\\,$ 以内，则返回 true，否则返回 false。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4,result5]”），每个“result”是按上述顺序列出的相应测试用例的布尔结果。不允许用户输入，所有计算必须是自包含的。",
            "solution": "该问题要求在一维 (1D) 静电粒子模拟 (PIC) 框架内，对源于高斯定律的基本一致性条件进行数值验证。具体来说，它涉及实现三种不同类型的电场和电势边界条件——周期性、狄利克雷 (Dirichlet) 和诺伊曼 (Neumann)——并测试它们在给定的一组测试用例中与模拟域内总电荷的相容性。分析在归一化单位下进行，其中真空介电常数 $\\varepsilon_0 = 1$。\n\n基本原理是一维高斯定律 $\\,\\partial_x E(x) = \\rho(x)\\,$，其中 $\\,E\\,$ 是电场，$\\,\\rho\\,$ 是电荷密度。将其在域 $\\,[0, L]\\,$ 上积分，得到积分形式：\n$$\nE(L) - E(0) = \\int_0^L \\rho(x)\\,dx\n$$\n这个方程在边界上的电场值与域内封闭的总电荷之间建立了一个严格的约束。不同的边界条件对这种关系施加了不同的约束。\n\n解决方案分三个逻辑阶段构建：\n1.  **电荷分配**：将离散粒子的分布映射到网格上，以获得连续的电荷密度场 $\\,\\rho_j\\,$.\n2.  **场求解器/验证器实现**：为每种边界条件实现特定的数值程序，以求解场或直接检查其与高斯定律所施加约束的一致性。\n3.  **测试用例评估**：将已实现的方法应用于一组测试用例，以确定一致性条件是否得到满足。\n\n**1. 电荷分配：云中元 (CIC) 方法**\n\n每个网格节点 $\\,j\\,$ 上的电荷密度 $\\,\\rho_j\\,$ 是根据粒子位置 $\\,x_p\\,$ 和电荷 $\\,q_p\\,$ 计算得出的。我们使用一个包含 $\\,N\\,$ 个节点的均匀网格，索引为 $\\,j=0, 1, \\dots, N-1\\,$，节点位置为 $\\,x_j = j\\Delta x\\,$，其中 $\\,\\Delta x = L/N\\,$. 对于位于位置 $\\,x_p \\in [0,L)\\,$ 的粒子，其归一化位置为 $\\,g_p = x_p/\\Delta x\\,$. 左侧最近的网格点索引为 $\\,j = \\lfloor g_p \\rfloor\\,$，到该点的分数距离为 $\\,s = g_p - j\\,$. CIC 方案将粒子电荷的一部分分配给最近的两个网格节点：\n- 节点 $\\,j\\,$ 上的电荷密度贡献为 $\\,\\delta\\rho_j = q_p (1-s) / \\Delta x\\,$.\n- 节点 $\\,j+1\\,$ 上的电荷密度贡献为 $\\,\\delta\\rho_{j+1} = q_p s / \\Delta x\\,$.\n\n一个粒子分配的总电荷为 $\\,(\\delta\\rho_j + \\delta\\rho_{j+1})\\Delta x = q_p\\,$，确保了电荷守恒。右边界（节点 $\\,j+1=N\\,$）的处理取决于场边界条件：\n- 对于**周期性**条件，网格是环绕的。对节点 $\\,j+1=N\\,$ 的贡献被加到节点 $\\,0\\,$ 上。\n- 对于**非周期性**（狄利克雷、诺伊曼）条件，任何会落在网格域外的贡献通常由特定规则处理。问题指定了“截断”规则，但由于所提供的粒子位置不位于最后一个网格单元内，这个具体细节不会出现。实现将处理 $\\,j+1  N\\,$ 的粒子。\n\n**2. 场求解器和验证器**\n\n每种边界条件都意味着不同的一致性检查。所有与零的数值比较都使用 $\\,\\tau = 10^{-10}\\,$ 的容差。\n\n**A. 周期性边界条件**\n对于周期性系统，$\\,E(0) = E(L)\\,$。高斯定律的积分形式直接意味着 $\\,\\int_0^L \\rho(x)\\,dx = 0\\,$. 这是全局电荷中性条件。数值测试验证其离散对应形式：\n$$\n\\left| \\sum_{j=0}^{N-1} \\rho_j \\Delta x \\right|  \\tau\n$$\n如果系统中的总电荷不为零，则泊松方程不存在一致的周期解。如果系统是中性的，验证函数返回 `True`，否则返回 `False`。\n\n**B. 狄利克雷 (Dirichlet) 边界条件**\n在边界处具有固定电势 $\\,\\phi(0) = 0\\,$ 和 $\\,\\phi(L) = 0\\,$ 时，总电荷不必为零。该问题通过数值方法求解一维泊松方程 $\\,\\partial_{xx}\\phi = -\\rho\\,$ 来解决，对内部网格节点 $\\,j=1, \\dots, N-2\\,$ 使用二阶中心有限差分格式：\n$$\n\\frac{\\phi_{j-1} - 2\\phi_j + \\phi_{j+1}}{\\Delta x^2} = -\\rho_j\n$$\n边界条件设置在第一个和最后一个节点上：$\\,\\phi_0=0\\,$ 和 $\\,\\phi_{N-1}=0\\,$. 这构成了关于未知电势 $\\,\\phi_1, \\dots, \\phi_{N-2}\\,$ 的 $\\,N-2\\,$ 个线性方程组。该系统由一个对称三对角矩阵定义，可以高效、准确地求解。\n一旦知道了电势 $\\,\\phi_j\\,$，边界处的电场就使用单边有限差分来近似：\n$$\nE(0) \\approx E_0 = -\\frac{\\phi_1 - \\phi_0}{\\Delta x}, \\quad E(L) \\approx E_L = -\\frac{\\phi_{N-1} - \\phi_{N-2}}{\\Delta x}\n$$\n验证过程确认数值解与高斯定律的离散版本是自洽的。我们计算残差 $\\,\\mathcal{R}_D\\,$：\n$$\n\\mathcal{R}_D = \\left( E_L - E_0 \\right) - \\sum_{j=0}^{N-1} \\rho_j \\Delta x\n$$\n对于指定的数值方案，可以证明该残差为 $\\mathcal{R}_D = -(\\rho_0 + \\rho_{N-1})\\Delta x$。如果 $\\,|\\mathcal{R}_D|  \\tau\\,$，测试返回 `True`。\n\n**C. 诺伊曼 (Neumann) 边界条件**\n诺伊曼条件指定了边界处的电场（电势的导数）：$\\,E(0)=0\\,$ 和 $\\,E(L)=0\\,$. 将这些代入高斯定律的积分形式，得到 $\\,0 - 0 = \\int_0^L \\rho(x)\\,dx\\,$，这再次要求全局电荷中性。验证方法通过直接从 $\\,E_0=0\\,$ 开始在网格上积分高斯定律 $\\,\\partial_x E = \\rho\\,$ 来模拟这一点。我们使用指定的简单欧拉前向方法：\n$$\nE_{j+1} = E_j + \\rho_j \\Delta x \\quad \\text{for } j=0, \\dots, N-1\n$$\n这给出了每个节点处的场 $\\,E_j\\,$，最终得到在位置 $\\,x=L\\,$ 处的 $\\,E_N\\,$。从迭代公式可以清楚地看出 $\\,E_N = E_0 + \\sum_{j=0}^{N-1} \\rho_j \\Delta x\\,$. 一致性检查是双重的，如问题所述：\n1.  总电荷必须接近于零：$\\,\\left| \\sum_{j=0}^{N-1} \\rho_j \\Delta x \\right|  \\tau\\,$.\n2.  右边界处的场必须接近于零：$\\,|E_N|  \\tau\\,$.\n给定 $\\,E_0=0\\,$，这两个条件在数学上是等价的。只有当两者都满足时，测试才返回 `True`。\n\n**3. 测试用例的评估**\n将这些函数的实现应用于五个指定的测试用例。结果将证明：\n- （用例 1 和 2）周期性系统仅在电荷中性时才是一致的。\n- （用例 3）具有狄利克雷边界条件的系统即使非电荷中性也是一致的。该检查验证求解器的数值完整性。\n- （用例 4 和 5）具有零场诺伊曼边界的系统仅在电荷中性时才是一致的，这与周期性情况直接类似。\n最终输出是一个布尔值列表，反映了这些验证的结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef deposit_charge(particles, L, N, periodic):\n    \"\"\"\n    Deposits particle charges onto a grid using the Cloud-In-Cell (CIC) method.\n    \n    Args:\n        particles (list): A list of tuples, where each tuple is (position, charge).\n        L (float): Length of the domain.\n        N (int): Number of grid nodes.\n        periodic (bool): True for periodic boundaries, False for non-periodic.\n        \n    Returns:\n        np.ndarray: The charge density array `rho` of size N.\n    \"\"\"\n    dx = L / N\n    rho = np.zeros(N)\n    \n    for x_p, q_p in particles:\n        if not (0 = x_p  L):\n            # For this problem set, all particles are within [0, L).\n            # No special handling needed.\n            continue\n\n        g_p = x_p / dx\n        j = int(g_p)\n        s = g_p - j\n        \n        # Contribution to node j\n        rho[j] += q_p * (1 - s) / dx\n        \n        # Contribution to node j+1\n        j1 = j + 1\n        if periodic:\n            rho[j1 % N] += q_p * s / dx\n        else:\n            if j1  N:\n                rho[j1] += q_p * s / dx\n            # The problem statement's rule for j+1=N is ambiguous but the provided\n            # test cases do not trigger this condition, as no particle is in the last cell.\n            # A simple truncation is implemented.\n    \n    return rho\n\ndef validate_periodic(rho, dx, tolerance):\n    \"\"\"\n    Validates consistency for periodic boundary conditions.\n    Requires global charge neutrality.\n    \"\"\"\n    total_charge = np.sum(rho) * dx\n    return abs(total_charge)  tolerance\n\ndef validate_dirichlet(rho, dx, N, tolerance):\n    \"\"\"\n    Validates consistency for Dirichlet boundary conditions.\n    Solves Poisson's equation and checks Gauss's law.\n    \"\"\"\n    # System is for interior nodes phi_1, ..., phi_{N-2}\n    M = N - 2\n    if M = 0:\n        # Trivial case with 2 or fewer nodes.\n        # Boundary fields are ill-defined as per the problem.\n        # But for N=64, this is not a concern.\n        return True # or False based on a defined convention.\n\n    # 1. Solve the tridiagonal system A*phi_interior = b\n    # A is a matrix with -2 on the main diagonal, 1 on sub/super-diagonals.\n    # We use scipy.linalg.solve_banded for efficiency.\n    ab = np.zeros((3, M))\n    ab[0, 1:] = 1.0  # Super-diagonal\n    ab[1, :] = -2.0 # Main diagonal\n    ab[2, :-1] = 1.0 # Sub-diagonal\n    \n    b = -rho[1:N-1] * dx**2\n    \n    phi_interior = solve_banded((1, 1), ab, b)\n    \n    # 2. Reconstruct the full potential array phi\n    phi = np.zeros(N)\n    phi[1:N-1] = phi_interior\n    # phi[0] and phi[N-1] are 0 by Dirichlet condition.\n    \n    # 3. Compute boundary fields using one-sided differences\n    E0 = -(phi[1] - phi[0]) / dx\n    EL = -(phi[N-1] - phi[N-2]) / dx\n    \n    # 4. Compute total charge\n    total_charge = np.sum(rho) * dx\n    \n    # 5. Check Gauss's law residual\n    residual = (EL - E0) - total_charge\n    return abs(residual)  tolerance\n\ndef validate_neumann(rho, dx, N, tolerance):\n    \"\"\"\n    Validates consistency for Neumann boundary conditions.\n    Requires global charge neutrality.\n    \"\"\"\n    # 1. Integrate E from E_0 = 0\n    E = np.zeros(N + 1)\n    # E[0] is E_0 = 0 from the boundary condition.\n    for j in range(N):\n        E[j+1] = E[j] + rho[j] * dx\n    \n    E_N = E[N]\n    \n    # 2. Calculate total charge\n    total_charge = np.sum(rho) * dx\n    \n    # 3. Check both conditions as specified\n    check_E_L = abs(E_N)  tolerance\n    check_charge = abs(total_charge)  tolerance\n    \n    return check_E_L and check_charge\n\ndef solve():\n    \"\"\"Main function to run all test cases and print results.\"\"\"\n    # --- Problem Parameters ---\n    L = 1.0\n    N = 64\n    DX = L / N\n    TOLERANCE = 1e-10\n\n    # --- Test Case Definitions ---\n    # Test Case 1  4 Particles (globally neutral)\n    case1_particles = [\n        (0.10, -1.0), (0.30, -1.0), (0.50, -1.0), (0.70, -1.0),\n        (0.15,  1.0), (0.35,  1.0), (0.55,  1.0), (0.75,  1.0)\n    ]\n\n    # Test Case 2, 3,  5 Particles (non-neutral)\n    case2_particles = [\n        (0.20, -1.0), (0.40, -1.0), (0.60, -1.0)\n    ]\n    \n    test_suite = [\n        {'type': 'periodic',  'particles': case1_particles},\n        {'type': 'periodic',  'particles': case2_particles},\n        {'type': 'dirichlet', 'particles': case2_particles},\n        {'type': 'neumann',   'particles': case1_particles},\n        {'type': 'neumann',   'particles': case2_particles},\n    ]\n\n    results = []\n    \n    for i, case in enumerate(test_suite):\n        bc_type = case['type']\n        particles = case['particles']\n        \n        if bc_type == 'periodic':\n            rho = deposit_charge(particles, L, N, periodic=True)\n            result = validate_periodic(rho, DX, TOLERANCE)\n        elif bc_type == 'dirichlet':\n            rho = deposit_charge(particles, L, N, periodic=False)\n            result = validate_dirichlet(rho, DX, N, TOLERANCE)\n        elif bc_type == 'neumann':\n            rho = deposit_charge(particles, L, N, periodic=False)\n            result = validate_neumann(rho, DX, N, TOLERANCE)\n        else:\n            # Should not happen\n            result = False\n            \n        results.append(result)\n\n    # --- Final Output ---\n    # Convert boolean results to strings ('True', 'False') and join them.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在建立了场求解的框架后，我们转向PIC模拟的另一核心：精确地描述单个粒子的运动。Boris算法是推进带电粒子在电磁场中运动的标准工具，其性能直接决定了模拟的准确性。本练习聚焦于该算法的一个关键性能指标——模拟带电粒子在磁场中基本的回旋运动的精度。通过推导和检验为确保精度而对时间步长 $\\Delta t$ 施加的约束，您将对PIC模拟中的数值色散和稳定性有更深刻的量化理解 。",
            "id": "4027304",
            "problem": "考虑一个带电粒子在均匀磁场中运动，此问题置于计算聚变科学与工程中使用的粒子模拟（PIC, Particle-In-Cell）方法的背景下。该运动从第一性原理出发，由洛伦兹力定律支配。具体来说，对于恒定磁场 $\\mathbf{B}$ 和零电场，运动方程为 $m \\, d\\mathbf{v}/dt = q\\, \\mathbf{v}\\times\\mathbf{B}$，这会在垂直于 $\\mathbf{B}$ 的平面上产生匀速圆周运动。连续回旋角频率定义为 $\\Omega_c = |q|B/m$。\n\n您的任务是：\n\n- 从洛伦兹力定律和回旋运动的定义出发，推导连续时间匀速圆周运动的特性，并将其与标准PIC速度积分器（广为人知的Boris推进器）在零电场和均匀磁场假设下使用的离散时间更新联系起来。从保持速率并旋转速度向量的离散化更新出发，推导每时间步的离散相移，作为 $\\Delta t$ 和 $\\Omega_c$ 的函数，并由此推导出一个关于 $\\Delta t$ 的约束条件，使得每步的相对相位误差的量级不超过预设的容差 $\\eta$。使用 $\\Omega_c$ 和 $\\eta$ 将最终约束显式地表示为关于 $\\Delta t$ 的不等式（单位为秒），并指定角度单位为弧度。\n\n- 评估当 $\\Delta t$ 接近物理回旋周期 $2\\pi/\\Omega_c$ 的一个分数 $f$ 时的精度损失。通过计算以下所有指标来量化精度损失：\n    1. 相对数值回旋频率误差 $(\\Omega_{\\text{num}}/\\Omega_c - 1)$，无量纲。\n    2. 相对数值周期误差 $\\left( (2\\pi/\\Omega_{\\text{num}}) / (2\\pi/\\Omega_c) - 1 \\right)$，无量纲。\n    3. 每步相位误差（单位为弧度），定义为 $(\\theta - \\Omega_c \\Delta t)$，其中 $\\theta$ 是每步的离散相移。\n    4. 一个布尔值，指示是否满足推导出的 $\\Delta t$ 约束，即 $\\Delta t \\leq \\Delta t_{\\max}(\\eta,\\Omega_c)$ 是否成立。\n    5. 周期末位置误差（单位为米），定义为数值计算位置在一个物理回旋周期后的位置与精确位置（对于匀速圆周运动，应返回初始位置）之差的欧几里得范数。\n\n使用以下物理上一致的参数进行测试。粒子是电子，电荷量大小为 $|q| = 1.602176634\\times 10^{-19}\\ \\mathrm{C}$，质量为 $m = 9.1093837015\\times 10^{-31}\\ \\mathrm{kg}$，磁场大小为 $B = 5\\ \\mathrm{T}$，沿 $+\\hat{\\mathbf{z}}$ 轴方向。初始垂直速率为 $v_\\perp = 1.0\\times 10^{5}\\ \\mathrm{m/s}$，初始位置为 $\\mathbf{x}(0) = (r_L, 0, 0)$，初始速度为 $\\mathbf{v}(0) = (0, v_\\perp, 0)$，其中 $r_L = v_\\perp/\\Omega_c$ 是拉莫尔半径。角度必须以弧度为单位，时间以秒为单位。离散位置更新应使用与二阶精度一致的梯形法则：$\\mathbf{x}^{n+1} = \\mathbf{x}^{n} + \\Delta t \\, (\\mathbf{v}^{n} + \\mathbf{v}^{n+1})/2$。\n\n评估以下四个测试案例的指标，每个案例由一对 $(f,\\eta)$ 指定，其中 $\\Delta t = f \\times (2\\pi/\\Omega_c)$：\n\n- 案例 1：$(f=\\;0.05,\\ \\eta=\\;0.01)$。\n- 案例 2：$(f=\\;0.25,\\ \\eta=\\;0.01)$。\n- 案例 3：$(f=\\;0.50,\\ \\eta=\\;0.05)$。\n- 案例 4：$(f=\\;1.00,\\ \\eta=\\;0.01)$。\n\n对每个案例，计算并按下列固定顺序列出以下六个量：\n- 相对数值回旋频率误差 $(\\Omega_{\\text{num}}/\\Omega_c - 1)$（无量纲）。\n- 相对数值周期误差 $\\left( (2\\pi/\\Omega_{\\text{num}}) / (2\\pi/\\Omega_c) - 1 \\right)$（无量纲）。\n- 每步相位误差 $(\\theta - \\Omega_c \\Delta t)$（单位为弧度）。\n- 指示对于给定的 $\\eta$，是否满足 $\\Delta t$ 约束的布尔值。\n- 推导出的上限 $\\Delta t_{\\max}(\\eta,\\Omega_c)$（单位为秒）。\n- 周期末位置误差（单位为米）。\n\n您的程序应生成单行输出，其中包含所有四个案例的结果，按顺序串联，并以逗号分隔的列表形式封装在方括号中。例如，输出应为 $[\\text{case1\\_val1},\\text{case1\\_val2},\\ldots,\\text{case4\\_val6}]$ 的形式。所有角度必须以弧度为单位，所有时间必须以秒为单位，距离必须以米为单位。不允许使用百分号；所有相对误差必须是无量纲的实数。",
            "solution": "该问题要求对粒子模拟（PIC）方法中模拟的带电粒子在均匀磁场中的运动进行两部分分析。首先，我们必须基于一个可容忍的相位误差来推导离散时间步长 $\\Delta t$ 的一个约束条件。其次，我们必须为指定的测试案例评估几个精度指标。\n\n### 第一部分：时间步长约束的推导\n\n#### 洛伦兹力作用下的连续运动\n一个质量为 $m$、电荷为 $q$ 的粒子在磁场 $\\mathbf{B}$ 和零电场（$\\mathbf{E}=0$）中的运动由洛伦兹力定律支配：\n$$ m \\frac{d\\mathbf{v}}{dt} = q(\\mathbf{v} \\times \\mathbf{B}) $$\n设磁场是均匀的并沿 $\\hat{\\mathbf{z}}$ 轴方向，即 $\\mathbf{B} = B\\hat{\\mathbf{z}}$。运动方程可以分解为平行于 $\\mathbf{B}$ 和垂直于 $\\mathbf{B}$ 的分量。平行速度 $v_z$ 是恒定的，因为 $\\frac{dv_z}{dt}=0$。速度的垂直分量 $v_x$ 和 $v_y$ 的演化遵循：\n$$ \\frac{dv_x}{dt} = \\frac{qB}{m} v_y $$\n$$ \\frac{dv_y}{dt} = -\\frac{qB}{m} v_x $$\n对于电子，$q = -e  0$。我们定义回旋角频率为 $\\Omega_c = |q|B/m = eB/m  0$。方程变为：\n$$ \\frac{dv_x}{dt} = -\\Omega_c v_y $$\n$$ \\frac{dv_y}{dt} = \\Omega_c v_x $$\n该系统描述了在 $xy$ 平面内以角频率 $\\Omega_c$ 进行的匀速圆周运动。速度矢量 $\\mathbf{v}_\\perp = (v_x, v_y)$ 以此频率顺时针旋转。经过时间间隔 $\\Delta t$后，速度矢量会旋转一个角度 $\\phi_c = \\Omega_c \\Delta t$。\n\n#### 离散速度更新（Boris推进器）\nBoris算法是PIC代码中一种标准的速度积分器。对于 $\\mathbf{E}=0$ 的情况，从时间步 $n$ 到 $n+1$ 的速度更新简化为纯旋转。更新由下式给出：\n$$ \\mathbf{v}^{n+1} - \\mathbf{v}^n = (\\mathbf{v}^{n+1} + \\mathbf{v}^n) \\times \\mathbf{t} $$\n其中 $\\mathbf{t} = \\frac{q\\mathbf{B}\\Delta t}{2m}$。这可以重新整理以显式表示 $\\mathbf{v}^{n+1}$，从而得到对 $\\mathbf{v}^n$ 的旋转。\n\n让我们考虑垂直速度矢量 $\\mathbf{v}_\\perp$。更新对应于一个角度为 $\\theta$ 的旋转，由下式给出：\n$$ \\tan\\left(\\frac{\\theta}{2}\\right) = \\left|\\frac{qB\\Delta t}{2m}\\right| = \\frac{|q|B\\Delta t}{2m} = \\frac{\\Omega_c \\Delta t}{2} $$\n因此，每个时间步的离散相移为：\n$$ \\theta = 2 \\arctan\\left(\\frac{\\Omega_c \\Delta t}{2}\\right) $$\n因此，数值方法在每个步长 $\\Delta t$ 内将速度矢量旋转一个离散角度 $\\theta$，这是对连续旋转 $\\phi_c = \\Omega_c \\Delta t$ 的近似。\n\n#### 根据相位误差推导时间步长约束\n数值回旋频率是 $\\Omega_{\\text{num}} = \\theta / \\Delta t$。精确频率是 $\\Omega_c$。问题要求将每步相对相位误差，我们定义为 $|\\frac{\\theta-\\Omega_c\\Delta t}{\\Omega_c\\Delta t}|$，约束为小于或等于容差 $\\eta$：\n$$ \\frac{|\\theta - \\Omega_c \\Delta t|}{\\Omega_c \\Delta t} \\leq \\eta $$\n为了推导关于 $\\Delta t$ 的约束，我们使用 $\\arctan(x)$ 对小 $x$ 的泰勒级数展开：$\\arctan(x) = x - x^3/3 + O(x^5)$。令 $u = \\frac{\\Omega_c \\Delta t}{2}$。相移为：\n$$ \\theta = 2 \\arctan(u) \\approx 2\\left(u - \\frac{u^3}{3}\\right) = 2u - \\frac{2u^3}{3} = \\Omega_c \\Delta t - \\frac{2}{3}\\left(\\frac{\\Omega_c \\Delta t}{2}\\right)^3 = \\Omega_c \\Delta t - \\frac{(\\Omega_c \\Delta t)^3}{12} $$\n每步的相位误差为 $\\theta - \\Omega_c \\Delta t \\approx - \\frac{(\\Omega_c \\Delta t)^3}{12}$。对于 $\\Omega_c \\Delta t  0$，数值相移 $\\theta$ 总是略小于真实相移 $\\Omega_c \\Delta t$，这意味着数值粒子会滞后。\n\n相对相位误差的量级近似为：\n$$ \\frac{|\\theta - \\Omega_c \\Delta t|}{\\Omega_c \\Delta t} \\approx \\frac{(\\Omega_c \\Delta t)^3 / 12}{\\Omega_c \\Delta t} = \\frac{(\\Omega_c \\Delta t)^2}{12} $$\n应用容差 $\\eta$：\n$$ \\frac{(\\Omega_c \\Delta t)^2}{12} \\leq \\eta $$\n$$ (\\Omega_c \\Delta t)^2 \\leq 12\\eta $$\n$$ \\Omega_c \\Delta t \\leq \\sqrt{12\\eta} $$\n这得出了对时间步长 $\\Delta t$ 的显式约束：\n$$ \\Delta t \\leq \\frac{\\sqrt{12\\eta}}{\\Omega_c} $$\n我们定义允许的最大时间步长为 $\\Delta t_{\\max}(\\eta, \\Omega_c) = \\frac{\\sqrt{12\\eta}}{\\Omega_c}$。\n\n### 第二部分：精度指标的评估\n\n我们现在将为每个测试案例计算指定的六个指标。\n\n**物理与模拟参数：**\n- 电子电荷量：$|q| = e = 1.602176634 \\times 10^{-19}\\ \\mathrm{C}$\n- 电子质量：$m = 9.1093837015 \\times 10^{-31}\\ \\mathrm{kg}$\n- 磁场：$B = 5\\ \\mathrm{T}$\n- 初始垂直速率：$v_\\perp = 1.0 \\times 10^5\\ \\mathrm{m/s}$\n- 回旋频率：$\\Omega_c = eB/m$\n- 物理回旋周期：$T_c = 2\\pi/\\Omega_c$\n- 拉莫尔半径：$r_L = v_\\perp/\\Omega_c$\n- 初始位置：$\\mathbf{x}(0) = (r_L, 0, 0)$\n- 初始速度：$\\mathbf{v}(0) = (0, v_\\perp, 0)$\n- 时间步长：$\\Delta t = f \\cdot T_c = f \\cdot (2\\pi/\\Omega_c)$\n\n对于每个案例 $(f, \\eta)$，我们执行以下计算：\n\n1.  **相对数值回旋频率误差：**\n    $\\Omega_{\\text{num}} = \\theta/\\Delta t = \\frac{2}{\\Delta t} \\arctan(\\frac{\\Omega_c \\Delta t}{2})$。\n    误差为 $\\frac{\\Omega_{\\text{num}}}{\\Omega_c} - 1 = \\frac{2}{\\Omega_c \\Delta t}\\arctan\\left(\\frac{\\Omega_c \\Delta t}{2}\\right) - 1$。\n\n2.  **相对数值周期误差：**\n    $T_{\\text{num}} = 2\\pi/\\Omega_{\\text{num}}$。\n    误差为 $\\frac{T_{\\text{num}}}{T_c} - 1 = \\frac{2\\pi/\\Omega_{\\text{num}}}{2\\pi/\\Omega_c} - 1 = \\frac{\\Omega_c}{\\Omega_{\\text{num}}} - 1$。\n\n3.  **每步相位误差：**\n    这是离散相移与连续相移之差：$\\theta - \\Omega_c \\Delta t = 2 \\arctan(\\frac{\\Omega_c \\Delta t}{2}) - \\Omega_c \\Delta t$。\n\n4.  **$\\Delta t$ 约束检查：**\n    一个布尔值，指示 $\\Delta t \\leq \\Delta t_{\\max}(\\eta, \\Omega_c)$ 是否成立，其中 $\\Delta t_{\\max}$ 是推导出的上限。\n\n5.  **推导出的上限 $\\Delta t_{\\max}$：**\n    计算值 $\\Delta t_{\\max}(\\eta, \\Omega_c) = \\frac{\\sqrt{12\\eta}}{\\Omega_c}$。\n\n6.  **周期末位置误差：**\n    我们模拟粒子在一个物理回旋周期 $T_c$ 内的运动。步数 $N = T_c/\\Delta t = 1/f$，对于所有测试案例，这都是一个整数。一个周期后的精确最终位置是初始位置 $\\mathbf{x}_{\\text{exact}}(T_c) = \\mathbf{x}(0)$。数值最终位置 $\\mathbf{x}^N$ 是通过迭代速度和位置更新来计算的。\n    - 速度更新（顺时针旋转 $\\theta$）：\n      $$ \\begin{pmatrix} v_x^{k+1} \\\\ v_y^{k+1} \\end{pmatrix} = \\begin{pmatrix} \\cos\\theta  \\sin\\theta \\\\ -\\sin\\theta  \\cos\\theta \\end{pmatrix} \\begin{pmatrix} v_x^k \\\\ v_y^k \\end{pmatrix} $$\n    - 位置更新（梯形法则）：\n      $$ \\mathbf{x}^{k+1} = \\mathbf{x}^{k} + \\frac{\\Delta t}{2}(\\mathbf{v}^k + \\mathbf{v}^{k+1}) $$\n    我们从 $\\mathbf{x}^0 = \\mathbf{x}(0)$ 和 $\\mathbf{v}^0 = \\mathbf{v}(0)$ 开始，迭代 $N$ 次。最终位置误差是欧几里得距离 $\\|\\mathbf{x}^N - \\mathbf{x}(0)\\|$。执行直接的迭代计算，因为对于测试案例中的小 $N$ 值，这种方法既稳健又计算成本低。\n\n以下Python代码实现了此过程，用以计算四个给定测试案例所需的指标。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the particle-in-cell accuracy problem for a single electron\n    gyrating in a uniform magnetic field.\n    \"\"\"\n    # Physical constants\n    Q_E = 1.602176634e-19  # Electron charge magnitude in C\n    M_E = 9.1093837015e-31 # Electron mass in kg\n\n    # Test suite parameters\n    B_MAG = 5.0             # Magnetic field magnitude in T\n    V_PERP = 1.0e5          # Perpendicular speed in m/s\n\n    test_cases = [\n        (0.05, 0.01),\n        (0.25, 0.01),\n        (0.50, 0.05),\n        (1.00, 0.01)\n    ]\n\n    results = []\n\n    # Derived physical quantities\n    omega_c = (Q_E * B_MAG) / M_E\n    T_c = 2.0 * np.pi / omega_c\n    r_L = V_PERP / omega_c\n\n    # Initial conditions\n    x0 = np.array([r_L, 0.0, 0.0])\n    v0 = np.array([0.0, V_PERP, 0.0])\n\n    for f, eta in test_cases:\n        # Simulation parameters for the current case\n        dt = f * T_c\n        num_steps = int(round(1.0 / f))\n\n        # Argument for arctan\n        arg_tan = omega_c * dt / 2.0\n\n        # Discrete phase advance per step\n        theta = 2.0 * np.arctan(arg_tan)\n\n        # Numerical cyclotron frequency\n        omega_num = theta / dt\n\n        # --- Metric 1: Relative numerical cyclotron frequency error ---\n        rel_freq_error = omega_num / omega_c - 1.0\n\n        # --- Metric 2: Relative numerical period error ---\n        rel_period_error = omega_c / omega_num - 1.0\n\n        # --- Metric 3: Per-step phase error ---\n        phase_error_per_step = theta - omega_c * dt\n        \n        # --- Metric 5: Derived upper bound dt_max ---\n        dt_max = np.sqrt(12.0 * eta) / omega_c\n        \n        # --- Metric 4: dt constraint check ---\n        is_constraint_met = dt = dt_max\n\n        # --- Metric 6: End-of-period position error ---\n        # Initialize numerical position and velocity\n        x_num = np.copy(x0[:2]) # Use 2D vectors for simulation\n        v_num = np.copy(v0[:2])\n\n        # Rotation matrix components for clockwise rotation by theta\n        cos_theta = np.cos(theta)\n        sin_theta = np.sin(theta)\n\n        # Perform simulation for one physical period\n        for _ in range(num_steps):\n            v_old = np.copy(v_num)\n            \n            # Boris velocity update (rotation)\n            v_num[0] = v_old[0] * cos_theta + v_old[1] * sin_theta\n            v_num[1] = -v_old[0] * sin_theta + v_old[1] * cos_theta\n            \n            # Trapezoidal position update\n            x_num += 0.5 * dt * (v_old + v_num)\n\n        # Calculate final position error\n        pos_error = np.linalg.norm(x_num - x0[:2])\n\n        # Append results for the current case\n        results.extend([\n            rel_freq_error,\n            rel_period_error,\n            phase_error_per_step,\n            is_constraint_met,\n            dt_max,\n            pos_error\n        ])\n    \n    # Format the final output string\n    output_str = f\"[{','.join(f'{r:.8e}' if isinstance(r, float) else str(r) for r in results)}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "一个完整且正确的数值模拟必须遵守物理学的基本守恒定律。这最后一个练习将所有部分整合起来，要求您实现一套诊断工具来检验最重要的物理原则之一：总能量守恒。通过编程追踪能量在电磁场与等离子体粒子之间的转换与流动，您将学会如何构建关键的验证工具。这不仅能确保模拟结果的物理保真度，也是评估模拟代码长期稳定性的核心手段 。",
            "id": "4027302",
            "problem": "你需要为一个一维周期性粒子模拟（Particle-In-Cell, PIC）等离子体仿真实现诊断程序，以计算每个时间步的离散场能量和粒子动能，并验证总能量随时间的离散守恒性。程序必须是自包含的，并按照下文规定生成单行输出。所有物理量都应使用国际单位制（SI）。三角函数中的角度必须以弧度为单位。\n\n物理和数值设置为一个长度为 $L$ 的一维域，包含 $N_x$ 个均匀分布的网格点，并采用周期性边界条件。电磁场以数组形式给出，在 $N_t$ 个时间步的序列中在该网格上采样。粒子由其随时间变化的速度表示。离散诊断必须返回仿真时间序列中总能量的最大相对漂移。\n\n基本和核心定义：\n- 真空中的麦克斯韦方程组，用电场 $\\mathbf{E}$ 和磁场 $\\mathbf{B}$ 以及电荷密度 $\\rho$ 和电流密度 $\\mathbf{J}$ 表示，通过坡印廷定理导出连续能量守恒定律：\n$$\n\\frac{\\partial}{\\partial t}\\left(\\frac{\\varepsilon_0}{2}\\|\\mathbf{E}\\|^2 + \\frac{1}{2\\mu_0}\\|\\mathbf{B}\\|^2\\right) + \\nabla\\cdot\\left(\\frac{1}{\\mu_0}\\mathbf{E}\\times\\mathbf{B}\\right) = -\\mathbf{E}\\cdot\\mathbf{J}.\n$$\n在周期性边界条件下，散度项的域积分消失，电场对电荷做的功在场和粒子之间传递能量。质量为 $m_i$、速度为 $v_i$ 的粒子 $i$ 的相对论动能由下式给出\n$$\nK_i = m_i c^2(\\gamma_i - 1),\\quad \\gamma_i = \\frac{1}{\\sqrt{1 - \\frac{v_i^2}{c^2}}}.\n$$\n在所述的一维设置中，时间步 $n$ 的离散场能量必须计算为网格上的黎曼和：\n$$\nU_E^{(n)} = \\frac{\\varepsilon_0}{2}\\sum_{j=0}^{N_x-1} E_{j}^{(n)2}\\,\\Delta x,\\quad\nU_B^{(n)} = \\frac{1}{2\\mu_0}\\sum_{j=0}^{N_x-1} B_{j}^{(n)2}\\,\\Delta x,\n$$\n其中 $\\Delta x = L/N_x$，$E_j^{(n)}$ 和 $B_j^{(n)}$ 是网格点 $j$ 和时间步 $n$ 处的场采样值。时间步 $n$ 的离散粒子动能必须计算为\n$$\nU_K^{(n)} = \\sum_{i=1}^{N_p} m_i c^2\\left(\\frac{1}{\\sqrt{1 - \\frac{v_i^{(n)2}}{c^2}}} - 1\\right),\n$$\n其中 $N_p$ 是粒子数，$v_i^{(n)}$ 是粒子 $i$ 在时间步 $n$ 的速度。时间步 $n$ 的总能量是\n$$\nU_{\\text{tot}}^{(n)} = U_E^{(n)} + U_B^{(n)} + U_K^{(n)}.\n$$\n诊断程序必须计算时间序列上的最大相对漂移，对于非零的初始总能量 $U_{\\text{tot}}^{(0)}$，其定义为\n$$\n\\delta = \\frac{\\max_n U_{\\text{tot}}^{(n)} - \\min_n U_{\\text{tot}}^{(n)}}{U_{\\text{tot}}^{(0)}}.\n$$\n如果 $U_{\\text{tot}}^{(0)} = 0$，则定义 $\\delta = 0$。\n\n实现以下测试套件。对于每个案例，构建指定的场和粒子速度数组，按上述定义计算 $\\delta$，并将其添加到输出列表中。\n\n所有案例中使用的常量：\n- 光速：$c = 299{,}792{,}458\\ \\mathrm{m/s}$。\n- 真空磁导率：$\\mu_0 = 4\\pi\\times10^{-7}\\ \\mathrm{H/m}$。\n- 真空介电常数：$\\varepsilon_0 = 1/(\\mu_0 c^2)\\ \\mathrm{F/m}$。\n\n测试套件：\n1. 真空驻波，无粒子（理想情况，场能量交换无粒子能量参与）：\n   - 域长：$L = 1.0\\ \\mathrm{m}$。\n   - 网格点数：$N_x = 256$，$\\Delta x = L/N_x$。\n   - 时间步数：$N_t = 100$。\n   - 电场振幅：$E_0 = 1.0\\times10^3\\ \\mathrm{V/m}$。\n   - 波数：$k = 2\\pi/L$。\n   - 角频率：$\\omega = c k$。\n   - 周期：$T = 2\\pi/\\omega$。\n   - 时间步长：$\\Delta t = T/N_t$。\n   - 对于 $n=0,\\dots,N_t-1$，$t_n = n\\Delta t$；对于 $j=0,\\dots,N_x-1$，$x_j = j\\Delta x$。\n   - 场：\n     $$\n     E_j^{(n)} = E_0\\cos(k x_j)\\cos(\\omega t_n),\\quad B_j^{(n)} = \\frac{E_0}{c}\\cos(k x_j)\\sin(\\omega t_n).\n     $$\n   - 无粒子：$N_p = 0$。\n\n2. 零场和零粒子（能量恒为零的边界情况）：\n   - 域长：$L = 1.0\\ \\mathrm{m}$。\n   - 网格点数：$N_x = 32$。\n   - 时间步数：$N_t = 10$。\n   - 场：对于所有 $j,n$，$E_j^{(n)} = 0$，$B_j^{(n)} = 0$。\n   - 无粒子：$N_p = 0$。\n\n3. 仅有粒子，速度恒定，无场（粒子能量恒定）：\n   - 域长：$L = 1.0\\ \\mathrm{m}$。\n   - 网格点数：$N_x = 16$。\n   - 时间步数：$N_t = 50$。\n   - 场：对于所有 $j,n$，$E_j^{(n)} = 0$，$B_j^{(n)} = 0$。\n   - 粒子数：$N_p = 2$。\n   - 质量：$m_1 = 9.10938356\\times10^{-31}\\ \\mathrm{kg}$（电子），$m_2 = 3.34358372\\times10^{-27}\\ \\mathrm{kg}$（氘核）。\n   - 速度：对于所有 $n$，$v_1^{(n)} = 1.0\\times10^5\\ \\mathrm{m/s}$，$v_2^{(n)} = 2.0\\times10^5\\ \\mathrm{m/s}$。\n\n4. 场振幅缓慢漂移，无粒子（产生可测量能量漂移的边缘情况）：\n   - 域长：$L = 1.0\\ \\mathrm{m}$。\n   - 网格点数：$N_x = 256$，$\\Delta x = L/N_x$。\n   - 时间步数：$N_t = 100$。\n   - 电场振幅：$E_0 = 1.0\\times10^3\\ \\mathrm{V/m}$。\n   - 波数：$k = 2\\pi/L$。\n   - 角频率：$\\omega = c k$。\n   - 周期：$T = 2\\pi/\\omega$。\n   - 时间步长：$\\Delta t = T/N_t$。\n   - 时变振幅因子：$f_n = 1 - \\alpha\\frac{n}{N_t - 1}$，其中 $\\alpha = 0.02$。\n   - 对于 $n=0,\\dots,N_t-1$，$t_n = n\\Delta t$；对于 $j=0,\\dots,N_x-1$，$x_j = j\\Delta x$。\n   - 场：\n     $$\n     E_j^{(n)} = f_n\\,E_0\\cos(k x_j)\\cos(\\omega t_n),\\quad B_j^{(n)} = \\frac{E_0}{c}\\cos(k x_j)\\sin(\\omega t_n).\n     $$\n   - 无粒子：$N_p = 0$。\n\n输出要求：\n- 对于每个测试案例，按上述定义计算所有时间步上总能量的最大相对漂移 $\\delta$。\n- 你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表的结果（例如，\"[result1,result2,result3,result4]\"）。\n- 每个结果必须是四舍五入到八位小数的浮点数。\n\n所有计算必须以国际单位制（SI）单位进行，并且所有三角函数参数均以弧度为单位。程序不得读取任何输入，并且只能使用标准库和指定的数值库。程序应实现诊断并在给定的测试套件上进行评估，按指定格式输出单行结果。",
            "solution": "粒子模拟（PIC）中的能量诊断源于坡印廷定理和相对论粒子力学。其目标是计算每个时间步的离散电场能量、磁场能量和粒子动能，并通过测量总能量随时间的漂移来验证能量守恒。\n\n基于原理的推导：\n1. 从真空中的麦克斯韦方程组和洛伦兹力定律出发，可以得到坡印廷定理，\n$$\n\\frac{\\partial}{\\partial t}\\left(\\frac{\\varepsilon_0}{2}\\|\\mathbf{E}\\|^2 + \\frac{1}{2\\mu_0}\\|\\mathbf{B}\\|^2\\right) + \\nabla\\cdot\\left(\\frac{1}{\\mu_0}\\mathbf{E}\\times\\mathbf{B}\\right) = -\\mathbf{E}\\cdot\\mathbf{J}.\n$$\n对周期性域进行积分会因净通量为零而消除散度项，等式右侧代表电场对电荷所做的功，将能量转移为粒子动能。在没有外部源且电流沉积完美的情况下，总能量应该是守恒的。\n\n2. 在一维均匀间距 $\\Delta x$ 的离散化中，域积分变为黎曼和。在每个时间步 $n$，定义\n$$\nU_E^{(n)} = \\frac{\\varepsilon_0}{2}\\sum_{j=0}^{N_x-1} E_{j}^{(n)2}\\,\\Delta x,\\quad\nU_B^{(n)} = \\frac{1}{2\\mu_0}\\sum_{j=0}^{N_x-1} B_{j}^{(n)2}\\,\\Delta x.\n$$\n这些是在均匀网格上对连续场能量 $\\frac{\\varepsilon_0}{2}\\int E^2\\,dx$ 和 $\\frac{1}{2\\mu_0}\\int B^2\\,dx$ 的离散近似。\n\n3. 粒子动能必须进行相对论计算，以确保与等离子体模拟中可能出现的高速运动相一致。对于每个粒子 $i$，其质量为 $m_i$，在时间步 $n$ 的速度为 $v_i^{(n)}$，\n$$\nK_i^{(n)} = m_i c^2\\left(\\gamma_i^{(n)} - 1\\right),\\quad \\gamma_i^{(n)} = \\frac{1}{\\sqrt{1 - \\frac{v_i^{(n)2}}{c^2}}}.\n$$\n总粒子能量则为\n$$\nU_K^{(n)} = \\sum_{i=1}^{N_p} K_i^{(n)}.\n$$\n场和粒子的总能量为\n$$\nU_{\\text{tot}}^{(n)} = U_E^{(n)} + U_B^{(n)} + U_K^{(n)}.\n$$\n\n4. 为验证离散能量守恒，定义最大相对漂移 $\\delta$：\n$$\n\\delta = \\begin{cases}\n\\frac{\\max_n U_{\\text{tot}}^{(n)} - \\min_n U_{\\text{tot}}^{(n)}}{U_{\\text{tot}}^{(0)}}  \\text{if } U_{\\text{tot}}^{(0)} \\neq 0,\\\\\n0  \\text{if } U_{\\text{tot}}^{(0)} = 0.\n\\end{cases}\n$$\n该量是无量纲的，反映了总能量随时间的最大分数变化，并按初始能量进行归一化。对于一个精确能量守恒的离散格式和精确算术，$\\delta$ 应为零；实际上，数值舍入和离散化会产生微小的非零值。\n\n算法设计：\n- 构建空间网格 $x_j = j\\Delta x$，其中 $j=0,\\dots,N_x-1$ 且 $\\Delta x = L/N_x$。\n- 构建时间网格 $t_n = n\\Delta t$，其中 $n=0,\\dots,N_t-1$ 且 $\\Delta t$ 按规定。\n- 对于每个测试案例，根据提供的公式生成数组 $E_j^{(n)}$ 和 $B_j^{(n)}$，确保三角函数参数以弧度为单位。\n- 对于仅有粒子的案例，生成具有指定恒定速度的 $v_i^{(n)}$ 数组，并为每个粒子和时间步计算 $\\gamma_i^{(n)}$。\n- 使用常量 $\\varepsilon_0$ 和 $\\mu_0$ 通过黎曼和计算 $U_E^{(n)}$ 和 $U_B^{(n)}$。\n- 使用相对论动能公式计算粒子的 $U_K^{(n)}$。\n- 形成 $U_{\\text{tot}}^{(n)}$ 并计算 $\\delta$ 作为此时间序列的归一化最大范围；如果 $U_{\\text{tot}}^{(0)} = 0$，则设 $\\delta = 0$。\n- 对所有四个测试案例重复此过程。\n\n案例预期：\n- 在真空驻波中，$E_j^{(n)} = E_0\\cos(k x_j)\\cos(\\omega t_n)$ 且 $B_j^{(n)} = (E_0/c)\\cos(k x_j)\\sin(\\omega t_n)$，注意 $1/\\mu_0 = \\varepsilon_0 c^2$ 且 $\\cos^2(\\omega t_n) + \\sin^2(\\omega t_n) = 1$。因此，\n$$\nU_E^{(n)} + U_B^{(n)} = \\frac{\\varepsilon_0}{2}\\sum_j \\left(E_0^2\\cos^2(kx_j)\\cos^2(\\omega t_n) + c^2\\left(\\frac{E_0}{c}\\right)^2\\cos^2(kx_j)\\sin^2(\\omega t_n)\\right)\\Delta x,\n$$\n这简化为\n$$\n\\frac{\\varepsilon_0}{2}E_0^2\\sum_j \\cos^2(kx_j)\\Delta x,\n$$\n不随时间变化。由于没有粒子，总能量是恒定的，因此在数值舍入误差范围内，$\\delta$ 应该接近于零。\n\n- 零场和零粒子案例在所有时间点的能量都恒为零；根据定义，为避免除以零，设 $\\delta = 0$。\n\n- 仅有粒子且速度恒定的案例具有恒定的粒子能量和零场能量；因此 $\\delta$ 接近于零。\n\n- 场振幅漂移的案例通过因子 $f_n = 1 - \\alpha\\frac{n}{N_t - 1}$ 在 $E_j^{(n)}$ 中引入了一个受控的变化，同时保持 $B_j^{(n)}$ 的振幅不变。这会产生一个可测量的总能量漂移，因此 $\\delta$ 应该与设定的振幅变化在同一数量级。\n\n实现细节：\n- 使用数值库通过双精度浮点数进行算术运算。\n- 计算漂移值并将其四舍五入到八位小数以供输出。\n- 将四个结果汇总到一个列表中，作为单行打印。\n\n最终程序实现了该算法，并为指定的测试套件案例输出了 $\\delta$值的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Physical constants in SI units\nc = 299_792_458.0  # m/s\nmu0 = 4.0e-7 * np.pi  # H/m\neps0 = 1.0 / (mu0 * c * c)  # F/m\n\ndef compute_field_energy(E_series, B_series, dx):\n    \"\"\"\n    Compute electric and magnetic field energies for each time step.\n    E_series, B_series: arrays of shape (Nt, Nx)\n    Returns U_E (Nt,), U_B (Nt,)\n    \"\"\"\n    # Electric field energy: (eps0/2) * sum_j E^2 * dx\n    U_E = 0.5 * eps0 * np.sum(E_series**2, axis=1) * dx\n    # Magnetic field energy: (1/(2*mu0)) * sum_j B^2 * dx\n    U_B = 0.5 / mu0 * np.sum(B_series**2, axis=1) * dx\n    return U_E, U_B\n\ndef compute_particle_energy(v_series, masses):\n    \"\"\"\n    Compute relativistic particle kinetic energy for each time step.\n    v_series: array of shape (Nt, Np) giving particle speeds (1D).\n    masses: array of shape (Np,)\n    Returns U_K (Nt,)\n    \"\"\"\n    if v_series is None or masses is None or len(masses) == 0:\n        # No particles\n        return np.zeros(1)  # Will be broadcasted later to Nt\n    Nt = v_series.shape[0]\n    Np = v_series.shape[1]\n    masses = np.asarray(masses)\n    # Ensure masses align with particles\n    assert masses.shape[0] == Np, \"Masses must align with particle count.\"\n    # gamma = 1/sqrt(1 - v^2/c^2)\n    gamma = 1.0 / np.sqrt(1.0 - (v_series**2) / (c**2))\n    # K_i = m_i c^2 (gamma - 1); sum over particles\n    K = masses[np.newaxis, :] * (c**2) * (gamma - 1.0)\n    U_K = np.sum(K, axis=1)\n    return U_K\n\ndef max_relative_drift(total_energy_t):\n    \"\"\"\n    Compute maximum relative drift: (max - min) / initial.\n    If initial energy is zero, return 0.0.\n    \"\"\"\n    maxE = float(np.max(total_energy_t))\n    minE = float(np.min(total_energy_t))\n    initE = float(total_energy_t[0])\n    if abs(initE) == 0.0:\n        return 0.0\n    return (maxE - minE) / initE\n\ndef generate_case_vacuum_standing_wave():\n    # Case 1 parameters\n    L = 1.0\n    Nx = 256\n    dx = L / Nx\n    Nt = 100\n    E0 = 1.0e3\n    k = 2.0 * np.pi / L\n    omega = c * k\n    T = 2.0 * np.pi / omega\n    dt = T / Nt\n    # Grids\n    x = np.arange(Nx) * dx\n    t = np.arange(Nt) * dt\n    # Fields\n    cos_kx = np.cos(k * x)[np.newaxis, :]  # shape (1, Nx)\n    cos_om_t = np.cos(omega * t)[:, np.newaxis]  # shape (Nt, 1)\n    sin_om_t = np.sin(omega * t)[:, np.newaxis]\n    E_series = E0 * cos_kx * cos_om_t\n    B_series = (E0 / c) * cos_kx * sin_om_t\n    # No particles\n    v_series = None\n    masses = None\n    return E_series, B_series, v_series, masses, dx\n\ndef generate_case_zero():\n    # Case 2 parameters\n    L = 1.0\n    Nx = 32\n    dx = L / Nx\n    Nt = 10\n    # Fields zero\n    E_series = np.zeros((Nt, Nx), dtype=float)\n    B_series = np.zeros((Nt, Nx), dtype=float)\n    # No particles\n    v_series = None\n    masses = None\n    return E_series, B_series, v_series, masses, dx\n\ndef generate_case_particles_only():\n    # Case 3 parameters\n    L = 1.0\n    Nx = 16\n    dx = L / Nx\n    Nt = 50\n    # Fields zero\n    E_series = np.zeros((Nt, Nx), dtype=float)\n    B_series = np.zeros((Nt, Nx), dtype=float)\n    # Particles: 2, constant velocities\n    m_e = 9.10938356e-31\n    m_D = 3.34358372e-27\n    masses = np.array([m_e, m_D], dtype=float)\n    v1 = 1.0e5\n    v2 = 2.0e5\n    v_series = np.tile(np.array([v1, v2], dtype=float), (Nt, 1))\n    return E_series, B_series, v_series, masses, dx\n\ndef generate_case_drifting_fields():\n    # Case 4 parameters\n    L = 1.0\n    Nx = 256\n    dx = L / Nx\n    Nt = 100\n    E0 = 1.0e3\n    k = 2.0 * np.pi / L\n    omega = c * k\n    T = 2.0 * np.pi / omega\n    dt = T / Nt\n    alpha = 0.02\n    # Grids\n    x = np.arange(Nx) * dx\n    t = np.arange(Nt) * dt\n    # Amplitude factor f_n\n    f = 1.0 - alpha * (np.arange(Nt) / (Nt - 1))\n    f = f[:, np.newaxis]  # shape (Nt, 1)\n    cos_kx = np.cos(k * x)[np.newaxis, :]  # shape (1, Nx)\n    cos_om_t = np.cos(omega * t)[:, np.newaxis]  # shape (Nt, 1)\n    sin_om_t = np.sin(omega * t)[:, np.newaxis]\n    # Fields with drifting E amplitude; B fixed amplitude\n    E_series = (f * E0) * cos_kx * cos_om_t\n    B_series = (E0 / c) * cos_kx * sin_om_t\n    # No particles\n    v_series = None\n    masses = None\n    return E_series, B_series, v_series, masses, dx\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        generate_case_vacuum_standing_wave(),\n        generate_case_zero(),\n        generate_case_particles_only(),\n        generate_case_drifting_fields(),\n    ]\n\n    results = []\n    for (E_series, B_series, v_series, masses, dx) in test_cases:\n        Nt = E_series.shape[0]\n        # Field energies\n        U_E, U_B = compute_field_energy(E_series, B_series, dx)\n        # Particle energies\n        U_K = compute_particle_energy(v_series, masses)\n        if U_K.shape[0] != Nt:\n            # Broadcast U_K to Nt if no particles (single zero)\n            U_K = np.zeros(Nt, dtype=float)\n        # Total energy\n        U_tot = U_E + U_B + U_K\n        # Drift\n        drift = max_relative_drift(U_tot)\n        # Round to eight decimal places for output\n        results.append(f\"{drift:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}