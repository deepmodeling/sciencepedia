{
    "hands_on_practices": [
        {
            "introduction": "在应用任何数字滤波器之前，第一步是理解其在频域中的行为。本练习聚焦于一种在PIC代码中常见的标准二项式平滑滤波器 。通过推导其幅频响应和群延迟，我们将精确地了解它会衰减哪些频率以及引入多少延迟，这些都是关键的性能特征。",
            "id": "3965593",
            "problem": "考虑在粒子模拟（Particle-In-Cell, PIC）等离子体仿真中使用的一维空间平滑，以减轻均匀网格上的网格尺度噪声。设网格索引为 $n \\in \\mathbb{Z}$，网格间距为 $\\Delta x$。电流密度序列 $j[n]$ 通过一个线性时不变滤波器进行平滑，该滤波器的有限脉冲响应（FIR）核是长度为 $5$ 的双通二项式核，其系数为\n$$\nh[0] = \\frac{1}{16}, \\quad h[1] = \\frac{4}{16}, \\quad h[2] = \\frac{6}{16}, \\quad h[3] = \\frac{4}{16}, \\quad h[4] = \\frac{1}{16}.\n$$\n平滑后的序列由离散卷积定义，\n$$\ny[n] = \\sum_{m=0}^{4} h[m]\\, j[n-m].\n$$\n设输入为单空间傅里叶模式 $j[n] = \\exp\\!\\big(i k n \\Delta x\\big)$，其中 $k$ 是物理波数。定义离散弧度频率 $\\omega = k \\Delta x$。核的离散傅里叶变换（DFT）频率响应 $H(\\omega)$ 由离散时间傅里叶变换给出\n$$\nH(\\omega) = \\sum_{m=0}^{4} h[m]\\, \\exp(-i \\omega m).\n$$\n仅从离散卷积和离散时间傅里叶变换的定义出发，推导幅频响应 $|H(\\omega)|$ 和群延迟 $\\tau_{g}(\\omega)$ 的精确闭式表达式，其中群延迟定义为\n$$\n\\tau_{g}(\\omega) = -\\frac{d}{d\\omega} \\,\\phi(\\omega),\n$$\n其中 $\\phi(\\omega)$ 是 $H(\\omega)$ 的展开相位。将 $|H(\\omega)|$ 和 $\\tau_{g}(\\omega)$ 表示为 $\\omega$ 的解析函数。无需进行数值舍入。将最终答案表示为一个双元素行矩阵，第一个元素等于幅频响应 $|H(\\omega)|$，第二个元素等于群延迟 $\\tau_{g}(\\omega)$。最终答案中不包含单位。",
            "solution": "该问题要求针对给定的有限脉冲响应（FIR）滤波器，推导其幅频响应 $|H(\\omega)|$ 和群延迟 $\\tau_{g}(\\omega)$。推导应从所提供的基本定义出发。\n\nFIR滤波器由其脉冲响应（核）$h[n]$ 定义。给定的系数为：\n$h[0] = \\frac{1}{16}$，$h[1] = \\frac{4}{16}$，$h[2] = \\frac{6}{16}$，$h[3] = \\frac{4}{16}$，以及 $h[4] = \\frac{1}{16}$。\n\n频率响应 $H(\\omega)$ 是核 $h[n]$ 的离散时间傅里叶变换（DTFT），由以下公式给出：\n$$\nH(\\omega) = \\sum_{m=0}^{4} h[m]\\, \\exp(-i \\omega m)\n$$\n代入 $h[m]$ 的给定系数：\n$$\nH(\\omega) = h[0] \\exp(-i \\omega \\cdot 0) + h[1] \\exp(-i \\omega \\cdot 1) + h[2] \\exp(-i \\omega \\cdot 2) + h[3] \\exp(-i \\omega \\cdot 3) + h[4] \\exp(-i \\omega \\cdot 4)\n$$\n$$\nH(\\omega) = \\frac{1}{16} + \\frac{4}{16} \\exp(-i\\omega) + \\frac{6}{16} \\exp(-i2\\omega) + \\frac{4}{16} \\exp(-i3\\omega) + \\frac{1}{16} \\exp(-i4\\omega)\n$$\n我们可以提出公因式 $\\frac{1}{16}$：\n$$\nH(\\omega) = \\frac{1}{16} \\left( 1 + 4\\exp(-i\\omega) + 6\\exp(-i2\\omega) + 4\\exp(-i3\\omega) + \\exp(-i4\\omega) \\right)\n$$\n滤波器系数是对称的，即 $h[m] = h[4-m]$。这表明该滤波器具有广义线性相位。对于这个长度为 $N=5$（索引从 $0$ 到 $4$）的滤波器，其对称中心在 $m=2$。我们可以提出与此对称中心对应的项 $\\exp(-i2\\omega)$，以简化表达式。\n$$\nH(\\omega) = \\frac{1}{16} \\exp(-i2\\omega) \\left( \\exp(i2\\omega) + 4\\exp(i\\omega) + 6 + 4\\exp(-i\\omega) + \\exp(-i2\\omega) \\right)\n$$\n通过组合各项并使用欧拉恒等式 $\\exp(i\\theta) + \\exp(-i\\theta) = 2\\cos(\\theta)$，我们可以重写括号内的表达式：\n$$\n\\left( \\exp(i2\\omega) + \\exp(-i2\\omega) \\right) + 4 \\left( \\exp(i\\omega) + \\exp(-i\\omega) \\right) + 6 = 2\\cos(2\\omega) + 4(2\\cos(\\omega)) + 6\n$$\n因此，频率响应变为：\n$$\nH(\\omega) = \\frac{1}{16} \\exp(-i2\\omega) \\left( 2\\cos(2\\omega) + 8\\cos(\\omega) + 6 \\right)\n$$\n为简化实值振幅部分，我们使用二倍角三角恒等式 $\\cos(2\\omega) = 2\\cos^2(\\omega) - 1$：\n$$\n2(2\\cos^2(\\omega) - 1) + 8\\cos(\\omega) + 6 = 4\\cos^2(\\omega) - 2 + 8\\cos(\\omega) + 6 = 4\\cos^2(\\omega) + 8\\cos(\\omega) + 4\n$$\n这个表达式是一个完全平方：\n$$\n4(\\cos^2(\\omega) + 2\\cos(\\omega) + 1) = 4(\\cos(\\omega) + 1)^2\n$$\n将此结果代回 $H(\\omega)$ 的表达式：\n$$\nH(\\omega) = \\frac{1}{16} \\exp(-i2\\omega) \\left[ 4(\\cos(\\omega) + 1)^2 \\right] = \\frac{1}{4} \\exp(-i2\\omega) (\\cos(\\omega) + 1)^2\n$$\n现在，我们使用半角恒等式 $1 + \\cos(\\omega) = 2\\cos^2(\\frac{\\omega}{2})$：\n$$\nH(\\omega) = \\frac{1}{4} \\exp(-i2\\omega) \\left[ 2\\cos^2\\left(\\frac{\\omega}{2}\\right) \\right]^2 = \\frac{1}{4} \\exp(-i2\\omega) \\left[ 4\\cos^4\\left(\\frac{\\omega}{2}\\right) \\right]\n$$\n这可以简化为频率响应的一个非常紧凑的形式：\n$$\nH(\\omega) = \\cos^4\\left(\\frac{\\omega}{2}\\right) \\exp(-i2\\omega)\n$$\n该表达式为极坐标形式 $H(\\omega) = A(\\omega) \\exp(i\\phi(\\omega))$，其中 $A(\\omega) = \\cos^4\\left(\\frac{\\omega}{2}\\right)$ 是振幅，$\\phi(\\omega) = -2\\omega$ 是相位。\n\n首先，我们求幅频响应 $|H(\\omega)|$。它是复变函数 $H(\\omega)$ 的绝对值。\n$$\n|H(\\omega)| = \\left| \\cos^4\\left(\\frac{\\omega}{2}\\right) \\exp(-i2\\omega) \\right| = \\left| \\cos^4\\left(\\frac{\\omega}{2}\\right) \\right| \\cdot |\\exp(-i2\\omega)|\n$$\n因为 $|\\exp(-i2\\omega)| = \\sqrt{\\cos^2(-2\\omega) + \\sin^2(-2\\omega)} = 1$，并且对于实数 $\\omega$，$\\cos^4(\\frac{\\omega}{2})$ 总是非负的，所以幅频响应就是振幅函数本身：\n$$\n|H(\\omega)| = \\cos^4\\left(\\frac{\\omega}{2}\\right)\n$$\n其次，我们求群延迟 $\\tau_g(\\omega)$。群延迟定义为 $\\tau_{g}(\\omega) = -\\frac{d}{d\\omega} \\phi(\\omega)$，其中 $\\phi(\\omega)$ 是 $H(\\omega)$ 的展开相位。\n从我们的表达式 $H(\\omega) = \\cos^4(\\frac{\\omega}{2}) \\exp(-i2\\omega)$ 中，振幅项 $\\cos^4(\\frac{\\omega}{2})$ 总是非负的。因此，不存在 $\\pm\\pi$ 的相位跳变， $H(\\omega)$ 的相位直接由复指数项的辐角给出。\n相位 $\\phi(\\omega)$ 为：\n$$\n\\phi(\\omega) = -2\\omega\n$$\n由于这是 $\\omega$ 的线性函数，它已经是展开形式。我们现在可以对 $\\omega$ 求导来计算群延迟：\n$$\n\\tau_g(\\omega) = -\\frac{d}{d\\omega} (-2\\omega) = -(-2) = 2\n$$\n群延迟是一个常数，值为 $2$。这对于对称 FIR 滤波器是符合预期的，其群延迟等于核的对称中心的索引，即 $(N-1)/2 = (5-1)/2 = 2$。\n\n所要求的两个量是幅频响应 $|H(\\omega)|$ 和群延迟 $\\tau_g(\\omega)$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\cos^4\\left(\\frac{\\omega}{2}\\right)  2 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "从纯粹的分析转向一个关键应用。在PIC模拟中，数值方案必须遵守物理守恒律。本实践探讨了数字滤波与离散电荷守恒律之间的微妙关系 。通过实现Esirkepov电流沉积方案，你将通过数值方法验证，对电流进行朴素的滤波会破坏守恒性，而一致的处理方法则能保持守恒性——这是构建稳健模拟代码的至关重要的一课。",
            "id": "3965601",
            "problem": "考虑沿长度为 $L$ 的线段上的聚变等离子体切片的一维周期性粒子模拟（PIC）离散化，该线段上有 $N$ 个宽度为 $\\Delta x$ 的均匀间隔单元，使得 $L = N \\Delta x$。使用云中元（CIC）形函数进行电荷分配。单元中心的线电荷密度用 $\\rho_i$ 表示，单位为 $\\,\\mathrm{C/m}$；单元面上的面心电流用 $J_{i+1/2}$ 表示，单位为 $\\,\\mathrm{C/s}$。设时间步长为 $\\Delta t$，单位为 $\\,\\mathrm{s}$。由基本定律 $\\partial_t \\rho + \\nabla \\cdot \\mathbf{J} = 0$ 推导出的离散连续性方程，需以下列形式强制执行：\n$$\n\\frac{\\rho_i^{n+1} - \\rho_i^{n}}{\\Delta t} + \\frac{J_{i+1/2}^{n+1/2} - J_{i-1/2}^{n+1/2}}{\\Delta x} = 0,\n$$\n此方程对所有单元索引 $i$ 均成立，并采用周期性边界条件。Esirkepov 电流是一种面心电流，当使用相同的形函数进行电荷分配时，它能精确满足上述离散连续性方程。\n\n对于一组给定的粒子，其电荷为 $q_p$，在时间 $t^n$ 的位置为 $x_p^n$，在时间 $t^{n+1} = t^n + \\Delta t$ 的位置为 $x_p^{n+1}$，请按以下步骤操作：\n- 使用云中元（CIC）形函数将 $\\rho_i^n$ 和 $\\rho_i^{n+1}$ 分配到单元中心，并按单元宽度 $\\Delta x$ 进行归一化，以满足 $\\sum_i \\rho_i \\Delta x = \\sum_p q_p$。\n- 计算一个面心电流 $J_{i+1/2}^{n+1/2}$，该电流对于已分配的 $\\rho_i^n$ 和 $\\rho_i^{n+1}$ 能精确遵守离散连续性方程。\n- 对 $J_{i+1/2}^{n+1/2}$ 在空间上应用一个可分离二项式数字滤波器，其一维周期性卷积核为 $[1, 2, 1]/4$，应用指定的次数。可选择性地对 $\\rho_i^n$ 和 $\\rho_i^{n+1}$ 应用相同的空间二项式滤波器。\n- 计算每个单元的离散连续性残差，\n$$\n\\varepsilon_i = \\frac{\\rho_i^{n+1} - \\rho_i^{n}}{\\Delta t} + \\frac{J_{i+1/2}^{n+1/2} - J_{i-1/2}^{n+1/2}}{\\Delta x},\n$$\n并报告最大绝对残差 $\\max_i |\\varepsilon_i|$，单位为 $\\,\\mathrm{C/(s \\cdot m)}$。\n\n您的程序必须实现一维的周期性边界条件和 CIC 分配。可分离二项式滤波器必须实现为周期性空间卷积，并应用指定的次数。通过在对 Esirkepov 电流进行滤波前后，以及在对电荷和电流进行一致性滤波时，测量离散连续性残差，从而在数值上验证电荷守恒。\n\n使用以下参数值和粒子运动的测试套件。所有位置都在区域 $[0, L)$ 内，其中 $L = N \\Delta x$，并进行周期性回绕。使用 $N = 64$，$\\Delta x = 10^{-3}\\,\\mathrm{m}$，$\\Delta t = 10^{-9}\\,\\mathrm{s}$，电子电荷大小 $e = 1.602 \\times 10^{-19}\\,\\mathrm{C}$。每个粒子的电荷为 $q_p = -e$。\n\n定义六个测试用例，每个用例产生一个浮点数，等于 $\\max_i |\\varepsilon_i|$，单位为 $\\,\\mathrm{C/(s \\cdot m)}$：\n- 情况1（理想路径，无滤波）：两个粒子在移动时未跨越单元边界。粒子1：从 $x_1^n = 1.0 \\times 10^{-2}\\,\\mathrm{m}$ 到 $x_1^{n+1} = 1.07 \\times 10^{-2}\\,\\mathrm{m}$。粒子2：从 $x_2^n = 3.0 \\times 10^{-2}\\,\\mathrm{m}$ 到 $x_2^{n+1} = 2.96 \\times 10^{-2}\\,\\mathrm{m}$。不对 $\\rho$ 或 $J$ 进行滤波。\n- 情况2（仅对电流滤波）：与情况1相同的粒子和运动，仅对 $J$ 应用一次二项式滤波器。\n- 情况3（对两者进行一致性滤波）：与情况1相同的粒子和运动，对 $\\rho$（在时间 $t^n$ 和 $t^{n+1}$）和 $J$ 都应用一次二项式滤波器。\n- 情况4（边界情况，周期性穿越，无滤波）：粒子1：从 $x_1^n = 6.35 \\times 10^{-2}\\,\\mathrm{m}$ 到 $x_1^{n+1} = 3.0 \\times 10^{-4}\\,\\mathrm{m}$（周期性回绕）。粒子2：从 $x_2^n = 1.0 \\times 10^{-3}\\,\\mathrm{m}$ 到 $x_2^{n+1} = 2.7 \\times 10^{-3}\\,\\mathrm{m}$。不对 $\\rho$ 或 $J$ 进行滤波。\n- 情况5（边界情况，周期性穿越，仅对电流滤波）：与情况4相同的粒子和运动，仅对 $J$ 应用一次二项式滤波器。\n- 情况6（零移动）：一个粒子，其位置为 $x_1^n = 2.0 \\times 10^{-2}\\,\\mathrm{m}$ 和 $x_1^{n+1} = 2.0 \\times 10^{-2}\\,\\mathrm{m}$。仅对 $J$ 应用一次二项式滤波器。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[$r_1, r_2, r_3, r_4, r_5, r_6$]”），其中每个 $r_k$ 是情况 $k$ 的 $\\max_i |\\varepsilon_i|$ 的浮点数值，单位为 $\\,\\mathrm{C/(s \\cdot m)}$。",
            "solution": "本问题要求在不同数字滤波场景下，为一个一维粒子模拟（PIC）计算离散电荷连续性方程的残差。解决方案涉及实现云中元（CIC）电荷分配方案、计算能精确满足离散连续性方程的 Esirkepov 电流、应用二项式滤波器，并最终计算残差。\n\n物理系统是一个长度为 $L$ 的一维周期性区域，被离散化为 $N$ 个宽度为 $\\Delta x$ 的单元。单元中心的电荷密度为 $\\rho_i$，面心电流为 $J_{i+1/2}$。为简化表示，我们用索引 $i$（范围从 $0$ 到 $N-1$）表示单元中心的网格，用索引 $i$ 表示单元面的网格（对应于单元 $i$ 的左侧面）。连续性方程随后可写作：\n$$\n\\frac{\\rho_i^{n+1} - \\rho_i^{n}}{\\Delta t} + \\frac{J_{i+1} - J_i}{\\Delta x} = 0\n$$\n其中 $J_i$ 表示位于位置 $i \\Delta x$ 的面上的电流。所有索引都遵循周期性边界条件，即索引 $k$ 等价于 $k \\pmod N$。\n\n每个测试用例的总体算法如下：\n1.  将粒子电荷分配到网格上，以获得密度 $\\rho_i^n$ 和 $\\rho_i^{n+1}$。\n2.  如果指定，对电荷密度应用二项式滤波器。\n3.  计算与（可能已滤波的）电荷密度相一致的 Esirkepov 电流 $J_i$。\n4.  如果指定，对计算出的电流应用二项式滤波器。\n5.  使用最终的电荷密度和电流计算连续性残差 $\\varepsilon_i$。\n6.  报告残差的最大绝对值 $\\max_i |\\varepsilon_i|$。\n\n**步骤1：云中元（CIC）电荷分配**\nCIC 方案将位于位置 $x_p$ 的粒子的电荷 $q_p$ 分配到最近的两个网格点上。电荷密度的网格由位于位置 $x_i = (i+0.5)\\Delta x$（其中 $i=0, ..., N-1$）的单元中心组成。\n\n对于位于位置 $x_p$ 的粒子，我们首先找到其逻辑坐标 $u_p = x_p / \\Delta x$。紧邻该粒子左侧的单元中心的索引为 $i = \\lfloor u_p - 0.5 \\rfloor$。粒子与该单元中心的距离（以 $\\Delta x$ 归一化）的小数部分，作为分配给相邻单元中心的权重：\n$$\nw_{i+1} = u_p - (i + 0.5)\n$$\n分配给左侧单元中心的权重是互补的：\n$$\nw_{i} = 1 - w_{i+1}\n$$\n电荷 $q_p$ 对相应单元中心 $i$ 和 $i+1$（索引为模 $N$ 以实现周期性）处的线电荷密度 $\\rho$（单位为 $\\,\\mathrm{C/m}$）的贡献如下：\n$$\n\\delta \\rho_i = \\frac{q_p w_i}{\\Delta x}, \\quad \\delta \\rho_{i+1} = \\frac{q_p w_{i+1}}{\\Delta x}\n$$\n总电荷密度 $\\rho_i$ 是所有粒子贡献的总和。此过程分别对时间 $t^n$ 和 $t^{n+1}$ 的粒子位置执行，以得到 $\\rho_i^n$ 和 $\\rho_i^{n+1}$。\n\n**步骤2：Esirkepov 电流计算**\nEsirkepov 电流被定义为能精确满足给定电荷密度 $\\rho_i^n$ 和 $\\rho_i^{n+1}$ 的离散连续性方程的电流。重新整理连续性方程，得到电流 $J_i$ 的递推关系：\n$$\nJ_{i+1} = J_i - \\frac{\\Delta x}{\\Delta t} (\\rho_i^{n+1} - \\rho_i^n)\n$$\n令 $\\Delta\\rho_i = \\rho_i^{n+1} - \\rho_i^n$。关系式为 $J_{i+1} = J_i - \\frac{\\Delta x}{\\Delta t} \\Delta\\rho_i$。这可以通过展开递推式来求解：\n$$\nJ_i = J_0 - \\frac{\\Delta x}{\\Delta t} \\sum_{k=0}^{i-1} \\Delta\\rho_k\n$$\n这定义了电流，但存在一个常数偏移量 $J_0$。对于没有净电荷注入或外部驱动场的周期性系统，穿过整个区域的净电流必须为零。我们强制执行此条件：$\\sum_{i=0}^{N-1} J_i = 0$。\n$$\n\\sum_{i=0}^{N-1} \\left( J_0 - \\frac{\\Delta x}{\\Delta t} \\sum_{k=0}^{i-1} \\Delta\\rho_k \\right) = N J_0 - \\frac{\\Delta x}{\\Delta t} \\sum_{i=0}^{N-1} \\sum_{k=0}^{i-1} \\Delta\\rho_k = 0\n$$\n由此可以确定常数偏移量 $J_0$，从而唯一地确定了电流数组 $J$。此方法保证了当得到的电流与原始密度 $\\rho^n$ 和 $\\rho^{n+1}$ 一起使用时，将产生为零的连续性残差（在机器精度范围内）。\n\n**步骤3：二项式滤波**\n指定的二项式滤波器使用一维卷积核 $[0.25, 0.5, 0.25]$。对于给定的 1D 数组 $A_i$，滤波后的数组 $A'_i$ 计算如下：\n$$\nA'_i = \\frac{1}{4} A_{i-1} + \\frac{2}{4} A_i + \\frac{1}{4} A_{i+1}\n$$\n该卷积是周期性的，意味着索引在数组边界处回绕（例如，$A_{-1} = A_{N-1}$）。根据测试用例的要求，此操作将按指定的次数（本问题中为一次）应用于电流 $J_i$ 和/或密度 $\\rho_i^n, \\rho_i^{n+1}$。\n\n**步骤4：残差计算**\n为每个单元 $i$ 计算离散连续性残差：\n$$\n\\varepsilon_i = \\frac{\\rho_i^{n+1} - \\rho_i^{n}}{\\Delta t} + \\frac{J_{i+1} - J_i}{\\Delta x}\n$$\n此公式中使用的是最终的电荷密度和电流（经过任何滤波步骤之后）。项 $\\frac{J_{i+1} - J_i}{\\Delta x}$ 是电流的离散散度。每个测试用例的最终结果是该残差在所有单元中的最大绝对值 $\\max_i |\\varepsilon_i|$。\n\n**测试用例分析：**\n- **情况1和4（无滤波）：** 由于 Esirkepov 电流的计算方式能精确满足连续性方程，残差 $\\varepsilon_i$ 对所有 $i$ 都将为零。报告值仅因浮点运算误差而非零。\n- **情况2和5（仅对电流滤波）：** 未经滤波的密度 $\\rho$ 与滤波后的电流 $J'$ 一起使用。滤波操作修改了电流，使其不再能平衡电荷密度的变化。这破坏了离散电荷守恒，导致非零残差。\n- **情况3（对两者进行一致性滤波）：** 滤波器是线性算子。将其应用于连续性方程得到：\n$$\nF\\left(\\frac{\\Delta\\rho_i}{\\Delta t} + \\frac{\\nabla \\cdot J_i}{\\Delta x}\\right) = \\frac{F(\\Delta\\rho_i)}{\\Delta t} + \\frac{F(\\nabla \\cdot J_i)}{\\Delta x} = F(0) = 0\n$$\n因为卷积与有限差分算子是可交换的（即，$F(\\nabla \\cdot J) = \\nabla \\cdot F(J)$），这变为：\n$$\n\\frac{\\rho_i'^{n+1} - \\rho_i'^n}{\\Delta t} + \\frac{J'_{i+1} - J'_i}{\\Delta x} = 0\n$$\n其中带撇号的量是经过滤波的。这意味着如果我们对密度和电流进行一致性滤波，连续性方程仍然满足。残差应为零，在机器精度范围内。\n- **情况6（零移动）：** 没有粒子运动时，$\\rho^n = \\rho^{n+1}$。这导致对所有 $i$ 都有 $\\Delta\\rho_i = 0$，这反过来会产生零 Esirkepov 电流，即 $J_i = 0$。对零电流进行滤波仍然得到零电流。因此，残差方程中的所有项都为零，结果为零。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases for the PIC continuity residual problem.\n    \"\"\"\n    #\n    # Global Parameters\n    #\n    N = 64  # Number of cells\n    dx = 1e-3  # Cell width in meters\n    dt = 1e-9  # Time step in seconds\n    e_charge = 1.602e-19  # Elementary charge in Coulombs\n    q_p = -e_charge  # Particle charge\n    L = N * dx # Domain length\n\n    #\n    # Helper Functions\n    #\n    def cic_deposit(positions, q, N_grid, dx_grid):\n        \"\"\"\n        Deposits particle charges onto a 1D grid using the Cloud-In-Cell (CIC) method.\n        Assumes cell-centered grid.\n        \n        Args:\n            positions (np.array): Particle positions.\n            q (float): Charge of each particle.\n            N_grid (int): Number of grid cells.\n            dx_grid (float): Grid cell width.\n        \n        Returns:\n            np.array: Line charge density (C/m) on the grid.\n        \"\"\"\n        rho = np.zeros(N_grid)\n        domain_length = N_grid * dx_grid\n        \n        for pos in positions:\n            # Ensure particle is within the periodic domain [0, L)\n            pos_wrapped = pos % domain_length\n\n            # Logical coordinate (normalized by cell width)\n            u_p = pos_wrapped / dx_grid\n            \n            # Index of the left-hand cell center and weights\n            i_left_center = np.floor(u_p - 0.5)\n            w_right = u_p - (i_left_center + 0.5)\n            w_left = 1.0 - w_right\n            \n            # Grid indices with periodic wrapping\n            idx0 = int(i_left_center) % N_grid\n            idx1 = (idx0 + 1) % N_grid\n            \n            # Deposit charge, converting point charge to line density\n            rho[idx0] += q * w_left / dx_grid\n            rho[idx1] += q * w_right / dx_grid\n            \n        return rho\n\n    def calculate_esirkepov_current(rho_n, rho_n_plus_1, N_grid, dx_grid, dt_step):\n        \"\"\"\n        Calculates the face-centered current that exactly satisfies the discrete\n        continuity equation for the given cell-centered charge densities.\n        \n        Args:\n            rho_n (np.array): Charge density at time t^n.\n            rho_n_plus_1 (np.array): Charge density at time t^{n+1}.\n            N_grid, dx_grid, dt_step: Grid and time parameters.\n\n        Returns:\n            np.array: Face-centered current (C/s or Amperes).\n        \"\"\"\n        # Change in charge density times volume element, divided by dt\n        delta = -(dx_grid / dt_step) * (rho_n_plus_1 - rho_n)\n        \n        # Recurrence relation: J_{i+1} = J_i + delta_i\n        # J_i = J_0 + sum_{k=0}^{i-1} delta_k\n        S = np.zeros_like(delta)\n        S[1:] = np.cumsum(delta[:-1])\n        \n        # Impose zero net current: sum(J_i) = 0 to find J_0\n        J0 = -np.mean(S)\n        \n        # Construct the full current array\n        J = J0 + S\n        return J\n\n    def apply_binomial_filter(A):\n        \"\"\"\n        Applies a single pass of the [1, 2, 1]/4 binomial filter with periodic\n        boundary conditions.\n        \n        Args:\n            A (np.array): The 1D array to filter.\n            \n        Returns:\n            np.array: The filtered array.\n        \"\"\"\n        return 0.25 * np.roll(A, 1) + 0.5 * A + 0.25 * np.roll(A, -1)\n\n    def calculate_residual(rho_n, rho_n_plus_1, J, N_grid, dx_grid, dt_step):\n        \"\"\"\n        Calculates the maximum absolute value of the continuity equation residual.\n        \"\"\"\n        d_rho_dt = (rho_n_plus_1 - rho_n) / dt_step\n        # Discrete divergence of J: (J_{i+1} - J_i) / dx\n        div_J = (np.roll(J, -1) - J) / dx_grid\n        \n        epsilon = d_rho_dt + div_J\n        return np.max(np.abs(epsilon))\n\n    #\n    # Test Cases Definition\n    #\n    test_cases_params = [\n        # Case 1: Happy path, no filtering\n        {\n            \"particles_n\": np.array([1.0e-2, 3.0e-2]),\n            \"particles_n1\": np.array([1.07e-2, 2.96e-2]),\n            \"num_particles\": 2, \"filter_rho\": False, \"filter_J\": False\n        },\n        # Case 2: Filter current only\n        {\n            \"particles_n\": np.array([1.0e-2, 3.0e-2]),\n            \"particles_n1\": np.array([1.07e-2, 2.96e-2]),\n            \"num_particles\": 2, \"filter_rho\": False, \"filter_J\": True\n        },\n        # Case 3: Filter both consistently\n        {\n            \"particles_n\": np.array([1.0e-2, 3.0e-2]),\n            \"particles_n1\": np.array([1.07e-2, 2.96e-2]),\n            \"num_particles\": 2, \"filter_rho\": True, \"filter_J\": True\n        },\n        # Case 4: Periodic crossing, no filtering\n        {\n            \"particles_n\": np.array([6.35e-2, 1.0e-3]),\n            \"particles_n1\": np.array([3.0e-4, 2.7e-3]),\n            \"num_particles\": 2, \"filter_rho\": False, \"filter_J\": False\n        },\n        # Case 5: Periodic crossing, filter current only\n        {\n            \"particles_n\": np.array([6.35e-2, 1.0e-3]),\n            \"particles_n1\": np.array([3.0e-4, 2.7e-3]),\n            \"num_particles\": 2, \"filter_rho\": False, \"filter_J\": True\n        },\n        # Case 6: Zero motion, filter current only\n        {\n            \"particles_n\": np.array([2.0e-2]),\n            \"particles_n1\": np.array([2.0e-2]),\n            \"num_particles\": 1, \"filter_rho\": False, \"filter_J\": True\n        },\n    ]\n\n    results = []\n\n    #\n    # Main Loop\n    #\n    for params in test_cases_params:\n        # 1. Charge Deposition\n        rho_n = cic_deposit(params[\"particles_n\"], q_p, N, dx)\n        rho_n1 = cic_deposit(params[\"particles_n1\"], q_p, N, dx)\n    \n        # 2. Consistent Filtering of Rho (if applicable)\n        if params[\"filter_rho\"]:\n            rho_n_final = apply_binomial_filter(rho_n)\n            rho_n1_final = apply_binomial_filter(rho_n1)\n        else:\n            rho_n_final = rho_n\n            rho_n1_final = rho_n1\n\n        # 3. Calculate Esirkepov Current\n        # Note: current is calculated from densities *after* rho-filtering\n        J = calculate_esirkepov_current(rho_n_final, rho_n1_final, N, dx, dt)\n\n        # 4. Filter Current (if applicable)\n        if params[\"filter_J\"]:\n            J_final = apply_binomial_filter(J)\n        else:\n            J_final = J\n        \n        # 5. Calculate Residual\n        # Note: The residual must be calculated with the same densities used to generate the\n        # base current, even if the current itself is later filtered.\n        # This is because filtering J alone breaks conservation relative to the original rho.\n        # If rho is also filtered (Case 3), the residual is calculated with filtered versions of both.\n        max_residual = calculate_residual(rho_n_final, rho_n1_final, J_final, N, dx, dt)\n        results.append(max_residual)\n\n    #\n    # Final Output\n    #\n    print(f\"[{','.join(f'{r:.6e}' for r in results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "我们将概念扩展到三维，这里会出现新的挑战。沿每个轴顺序应用简单的 1D 滤波器在计算上是高效的，但这可能会引入方向性偏差，即各向异性，从而影响模拟的物理过程。这个动手编码练习将指导你量化这种各向异性，为评估 3D 滤波方案的质量提供一个实用工具 。",
            "id": "3965582",
            "problem": "您的任务是推导并实现一种三维可分离二项式数字滤波器，该滤波器适用于计算聚变科学与工程领域中使用的单元内粒子 (Particle-In-Cell, PIC) 代码中的交错 Yee 网格上的场分量。目标是设计能够保持交错分量中心位置的逐轴滤波器，然后在沿每个笛卡尔轴顺序应用滤波器时，量化所得传递函数中的各向异性。最终的程序必须计算一个与方向相关的各向异性度量，并为提供的测试套件输出结果。\n\n从以下基本原理开始：\n- 均匀网格上的离散卷积是线性和时不变的，因此其对正弦输入的响应由离散时间傅里叶变换 (DTFT) 给出的频率响应来表征。\n- $p$ 阶一维二项式滤波器的核是重复应用 $p$ 次两点移动平均的结果。其归一化核系数由 $h_p[n] = \\binom{p}{n} / 2^p$ 给出，其中 $n \\in \\{0,1,\\dots,p\\}$。\n- 用于时域有限差分 (FDTD) 电磁学的 Yee 网格对场分量进行交错排列：例如，电场 $E_x$ 的 $x$ 分量存储在位于 $(i+\\tfrac{1}{2}, j, k)$ 位置的面心， $y$ 分量 $E_y$ 存储在 $(i, j+\\tfrac{1}{2}, k)$，$z$ 分量 $E_z$ 存储在 $(i, j, k+\\tfrac{1}{2})$。与分量的原生索引对齐的对称卷积核确保了该分量的零相位幅值响应。\n\n任务要求：\n1. 推导在网格间距为 $\\Delta$ 的单个轴上应用的 $p$ 阶二项式滤波器的一维频率响应幅值。对于连续波数为 $k$ 的正弦输入，离散角频率为 $\\omega = k \\Delta$。证明其幅值响应为何是 $|H_p(\\omega)| = \\left|\\cos\\!\\left(\\tfrac{\\omega}{2}\\right)\\right|^p$，并解释当使用对称核时，Yee 分量的半单元交错为何不改变幅值响应。\n2. 推导当滤波器沿 $x, y, z$ 轴顺序逐轴应用时，其阶数分别为 $p_x, p_y, p_z$ 且网格间距分别为 $\\Delta_x, \\Delta_y, \\Delta_z$ 的三维可分离频率响应幅值。对于矢量波数为 $\\mathbf{k} = (k_x, k_y, k_z)$ 的平面波，将联合幅值响应表示为\n$$\n|H(\\mathbf{k})| = \\left|\\cos\\!\\left(\\tfrac{k_x \\Delta_x}{2}\\right)\\right|^{p_x} \\cdot \\left|\\cos\\!\\left(\\tfrac{k_y \\Delta_y}{2}\\right)\\right|^{p_y} \\cdot \\left|\\cos\\!\\left(\\tfrac{k_z \\Delta_z}{2}\\right)\\right|^{p_z}.\n$$\n3. 在固定波数大小 $k_0$ 处定义一个各向异性度量，方法是在单位球面上均匀采样一组方向 $\\hat{\\mathbf{n}}$，计算 $|H(k_0 \\hat{\\mathbf{n}})|$，并计算相对标准差\n$$\n\\mathcal{A}(k_0) = \\frac{\\sqrt{\\mathbb{E}\\big[|H|^2\\big] - \\big(\\mathbb{E}\\big[|H|\\big]\\big)^2}}{\\mathbb{E}\\big[|H|\\big]} \\, ,\n$$\n其中 $\\mathbb{E}[\\cdot]$ 表示对所有方向的平均值。三角函数的角度必须使用弧度。在概念上使用周期性边界条件，并假设采样方向足够密集以表征方向性变化。波数大小 $k_0$ 必须选择为 $k_0 = \\alpha \\cdot \\min(\\tfrac{\\pi}{\\Delta_x}, \\tfrac{\\pi}{\\Delta_y}, \\tfrac{\\pi}{\\Delta_z})$，其中 $0  \\alpha \\leq 1$，以确保所有轴上的参数都保持在主奈奎斯特范围内。\n4. 实现一个完整、可运行的 Python 程序，该程序：\n   - 为给定的阶数 $p_x, p_y, p_z$ 构建一维二项式滤波器系数。\n   - 使用具有指定点数 $M$ 的 Fibonacci 晶格，为球面上的一组方向计算三维可分离幅值传递函数 $|H(\\mathbf{k})|$。\n   - 为每个测试用例计算各向异性度量 $\\mathcal{A}(k_0)$。\n   - 生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 $[0.0,0.123,0.456]$。\n5. 确保程序不需要用户输入，并且对所有角度量均使用弧度，同时波数根据给定的网格间距一致地进行计算。\n\n测试套件：\n- 用例 1（边界情况：无滤波）：$p_x = 0$, $p_y = 0$, $p_z = 0$, $\\Delta_x = 1$, $\\Delta_y = 1$, $\\Delta_z = 1$, $\\alpha = 0.75$, $M = 128$。\n- 用例 2（各向同性平滑阶数）：$p_x = 2$, $p_y = 2$, $p_z = 2$, $\\Delta_x = 1$, $\\Delta_y = 1$, $\\Delta_z = 1$, $\\alpha = 0.5$, $M = 128$。\n- 用例 3（强各向异性平滑）：$p_x = 4$, $p_y = 0$, $p_z = 0$, $\\Delta_x = 1$, $\\Delta_y = 1$, $\\Delta_z = 1$, $\\alpha = 0.9$, $M = 128$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[result1,result2,result3]$）。输出必须是浮点数，代表上述三个用例中每个用例的 $\\mathcal{A}(k_0)$，其顺序与用例出现的顺序相同。",
            "solution": "问题陈述已经过验证，被认为是合理的。它具有科学依据，提法明确，且客观。提供了推导和实现解决方案所需的所有必要信息。\n\n### 1. 一维频率响应的推导\n\n第一个任务是推导 $p$ 阶二项式滤波器的一维频率响应幅值。一个 $p$ 阶二项式滤波器是应用 $p$ 次两点移动平均滤波器的结果。\n\n最简单的两点移动平均滤波器有一个核 $h_{MA}[n]$。为了实现所述的对称幅值响应，我们可以将核定义为 $h_{MA}[n] = \\{1/2, 1/2\\}$，其中 $n \\in \\{0, 1\\}$。这种滤波器的脉冲响应是 $y[n] = \\frac{1}{2}(x[n] + x[n-1])$。\n\n离散滤波器的频率响应由其离散时间傅里叶变换 (DTFT) 给出，定义为 $H(e^{j\\omega}) = \\sum_{n=-\\infty}^{\\infty} h[n] e^{-j\\omega n}$，其中 $\\omega = k \\Delta$ 是对应于连续波数 $k$ 和网格间距 $\\Delta$ 的离散角频率。\n\n对于两点移动平均，传递函数为：\n$$\nH_{MA}(e^{j\\omega}) = \\frac{1}{2} e^{-j\\omega \\cdot 0} + \\frac{1}{2} e^{-j\\omega \\cdot 1} = \\frac{1}{2}(1 + e^{-j\\omega})\n$$\n使用欧拉公式，这可以重写为：\n$$\nH_{MA}(e^{j\\omega}) = \\frac{1}{2} e^{-j\\omega/2} (e^{j\\omega/2} + e^{-j\\omega/2}) = e^{-j\\omega/2} \\cos\\left(\\frac{\\omega}{2}\\right)\n$$\n一个 $p$ 阶二项式滤波器等效于将输入信号与 $h_{MA}[n]$ 核进行 $p$ 次卷积。在频域中，重复卷积变成了传递函数的乘法。因此，$p$ 阶二项式滤波器的传递函数是：\n$$\nH_p(e^{j\\omega}) = \\left( H_{MA}(e^{j\\omega}) \\right)^p = \\left( e^{-j\\omega/2} \\cos\\left(\\frac{\\omega}{2}\\right) \\right)^p = e^{-jp\\omega/2} \\left(\\cos\\left(\\frac{\\omega}{2}\\right)\\right)^p\n$$\n这个复函数的幅值为：\n$$\n|H_p(\\omega)| = \\left| e^{-jp\\omega/2} \\left(\\cos\\left(\\frac{\\omega}{2}\\right)\\right)^p \\right| = |e^{-jp\\omega/2}| \\left| \\left(\\cos\\left(\\frac{\\omega}{2}\\right)\\right)^p \\right| = 1 \\cdot \\left|\\cos\\left(\\frac{\\omega}{2}\\right)\\right|^p\n$$\n这证实了所要求的表达式：$|H_p(\\omega)| = \\left|\\cos(\\frac{\\omega}{2})\\right|^p$。\n\n值得注意的是，这种形式具有线性相位响应 $\\phi(\\omega) = -p\\omega/2$，对应于 $p/2$ 个样本的群延迟。对于需要零相移的实际实现，滤波器核可以居中。对于偶数阶 $p$，核是长度为 $p+1$ 的对称核（例如，对于 $p=2$，系数为 $\\{\\frac{1}{4}, \\frac{2}{4}, \\frac{1}{4}\\}$，以索引 $0$ 为中心）。这种居中的对称滤波器具有纯实数传递函数 $H_p(\\omega) = (\\cos(\\frac{\\omega}{2}))^p$，其相位为零。对于奇数阶 $p$，核关于半整数索引对称，导致线性相位响应。在所有情况下，幅值响应保持为 $|H_p(\\omega)| = |\\cos(\\frac{\\omega}{2})|^p$。\n\nYee 网格的交错特性不会改变此幅值响应。应用于某个分量（比如 $E_x$）的滤波器，是在其自身的均匀子网格（例如 $x_i = (i + 1/2)\\Delta_x$）上的数据进行操作。滤波器模板使用同一子网格上的相邻点（例如 $x_{i-1}, x_i, x_{i+1}$）。这些点之间的相对间距是网格间距 $\\Delta_x$ 的整数倍。$1/2\\Delta_x$ 的公共偏移仅为输入信号 $e^{jk_x(i+1/2)\\Delta_x} = e^{jk_x i\\Delta_x} e^{jk_x \\Delta_x/2}$ 引入一个恒定的相位因子，这不影响滤波器传递函数的幅值。传递函数表征的是滤波器对相邻网格点之间相对相移的响应，而这完全由 $k_x\\Delta_x$ 决定。\n\n### 2. 三维可分离频率响应的推导\n\n三维可分离滤波器是一种可以实现为沿每个笛卡尔轴应用的一系列一维滤波器的滤波器。如果我们将沿 $x, y, z$ 轴的一维滤波器算子表示为 $\\mathcal{F}_x$, $\\mathcal{F}_y$ 和 $\\mathcal{F}_z$，则滤波后的场 $F'$ 是从原始场 $F$ 通过 $F' = \\mathcal{F}_z(\\mathcal{F}_y(\\mathcal{F}_x(F)))$ 获得的。\n\n根据卷积定理，空间域的卷积等效于频域的乘法。设对应于一维滤波器的传递函数为 $H_x(k_x)$, $H_y(k_y)$ 和 $H_z(k_z)$。组合的 3D 可分离滤波器的传递函数是各个一维传递函数的乘积：\n$$\nH(\\mathbf{k}) = H_x(k_x) \\cdot H_y(k_y) \\cdot H_z(k_z)\n$$\n其中 $\\mathbf{k} = (k_x, k_y, k_z)$ 是波矢量。\n\n3D 传递函数的幅值是一维传递函数幅值的乘积：\n$$\n|H(\\mathbf{k})| = |H_x(k_x)| \\cdot |H_y(k_y)| \\cdot |H_z(k_z)|\n$$\n对每个轴使用第 1 部分的结果，并考虑可能不同的滤波器阶数 ($p_x, p_y, p_z$) 和网格间距 ($\\Delta_x, \\Delta_y, \\Delta_z$)，我们代入每个分量的一维幅值响应：\n$$\n|H_x(k_x)| = \\left|\\cos\\left(\\frac{k_x \\Delta_x}{2}\\right)\\right|^{p_x}\n$$\n$$\n|H_y(k_y)| = \\left|\\cos\\left(\\frac{k_y \\Delta_y}{2}\\right)\\right|^{p_y}\n$$\n$$\n|H_z(k_z)| = \\left|\\cos\\left(\\frac{k_z \\Delta_z}{2}\\right)\\right|^{p_z}\n$$\n将这些相乘得到所需的三维可分离频率响应幅值：\n$$\n|H(\\mathbf{k})| = \\left|\\cos\\left(\\frac{k_x \\Delta_x}{2}\\right)\\right|^{p_x} \\cdot \\left|\\cos\\left(\\frac{k_y \\Delta_y}{2}\\right)\\right|^{p_y} \\cdot \\left|\\cos\\left(\\frac{k_z \\Delta_z}{2}\\right)\\right|^{p_z}\n$$\n\n### 3. 各向异性度量与数值实现\n\n各向异性度量 $\\mathcal{A}(k_0)$ 定义为传递函数幅值 $|H(\\mathbf{k})|$ 在固定波数大小 $k_0$ 下对所有方向求值后的相对标准差（或变异系数）。\n$$\n\\mathcal{A}(k_0) = \\frac{\\sigma_{|H|}}{\\mu_{|H|}} = \\frac{\\sqrt{\\mathbb{E}\\big[|H|^2\\big] - \\big(\\mathbb{E}\\big[|H|\\big]\\big)^2}}{\\mathbb{E}\\big[|H|\\big]}\n$$\n该度量量化了滤波器效果的方向性变化。一个理想的各向同性滤波器对于所有 $k_0$ 都应有 $\\mathcal{A}(k_0)=0$。\n\n数值实现过程如下：\n1.  **设置波数大小**：大小 $k_0$ 固定为最小奈奎斯特波数的一个分数 $\\alpha$：$k_0 = \\alpha \\cdot \\min(\\frac{\\pi}{\\Delta_x}, \\frac{\\pi}{\\Delta_y}, \\frac{\\pi}{\\Delta_z})$。这一选择确保了对于任何方向，分量波数 $k_x, k_y, k_z$ 都保持在网格的主无混叠区内，即 $|k_i \\Delta_i| \\le k_0 \\Delta_i \\le \\alpha \\pi \\le \\pi$。因此，余弦函数的参数 $\\frac{k_i \\Delta_i}{2}$ 保证在区间 $[-\\pi/2, \\pi/2]$ 内，这意味着其余弦值为非负。因此，在计算中可以省略余弦函数上的绝对值符号。\n\n2.  **采样方向**：期望值 $\\mathbb{E}[\\cdot]$ 通过在单位球面上均匀采样的 $M$ 个大量方向 $\\hat{\\mathbf{n}}$ 上取平均来近似。Fibonacci 晶格是生成这样一组准均匀分布点的有效方法。每个单位向量 $\\hat{\\mathbf{n}}_j = (n_{xj}, n_{yj}, n_{zj})$（其中 $j=1, \\dots, M$）的分量被用来定义波矢量 $\\mathbf{k}_j = k_0 \\hat{\\mathbf{n}}_j$。\n\n3.  **计算传递函数**：对于每个采样方向 $\\hat{\\mathbf{n}}_j$，传递函数的幅值计算如下：\n    $$\n    |H(k_0 \\hat{\\mathbf{n}}_j)| = \\left(\\cos\\left(\\frac{k_0 n_{xj} \\Delta_x}{2}\\right)\\right)^{p_x} \\cdot \\left(\\cos\\left(\\frac{k_0 n_{yj} \\Delta_y}{2}\\right)\\right)^{p_y} \\cdot \\left(\\cos\\left(\\frac{k_0 n_{zj} \\Delta_z}{2}\\right)\\right)^{p_z}\n    $$\n    这会产生一组 $M$ 个值 $\\{|H_j|\\}_{j=1}^M$。\n\n4.  **计算度量**：计算集合 $\\{|H_j|\\}$ 的样本均值和样本标准差以近似 $\\mathbb{E}[|H|]$ 和 $\\sqrt{\\mathbb{E}[|H|^2] - (\\mathbb{E}[|H|])^2}$：\n    $$\n    \\bar{H} = \\frac{1}{M}\\sum_{j=1}^M |H_j| \\qquad \\text{和} \\qquad \\sigma_H = \\sqrt{\\frac{1}{M}\\sum_{j=1}^M (|H_j| - \\bar{H})^2}\n    $$\n    然后各向异性度量计算为 $\\mathcal{A}(k_0) \\approx \\sigma_H / \\bar{H}$。如果 $\\bar{H} = 0$，则该度量无定义；然而，对于指定的问题，除了在奈奎斯特极限处的特定波数（这已通过 $k_0$ 的选择而避免）外， $|H|$ 是严格为正的。对于平凡情况 $p_x=p_y=p_z=0$，有 $|H|=1$，因此 $\\sigma_H=0$ 且 $\\mathcal{A}(k_0)=0$。\n\n提供的 Python 代码为给定的测试套件实现了这一完整过程。请注意，构建滤波器系数对于此任务不是必需的，因为传递函数幅值仅取决于阶数 $p$，而不取决于显式的系数值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating the anisotropy of a 3D separable binomial filter.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: No filtering (isotropic baseline)\n        {'px': 0, 'py': 0, 'pz': 0, 'dx': 1.0, 'dy': 1.0, 'dz': 1.0, 'alpha': 0.75, 'M': 128},\n        # Case 2: Isotropic filter orders\n        {'px': 2, 'py': 2, 'pz': 2, 'dx': 1.0, 'dy': 1.0, 'dz': 1.0, 'alpha': 0.5, 'M': 128},\n        # Case 3: Strongly anisotropic filtering\n        {'px': 4, 'py': 0, 'pz': 0, 'dx': 1.0, 'dy': 1.0, 'dz': 1.0, 'alpha': 0.9, 'M': 128},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_anisotropy_metric(**case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The format string ensures a specific number of decimal places for consistency.\n    formatted_results = [f\"{r:.10f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\ndef get_fibonacci_sphere_points(M):\n    \"\"\"\n    Generates M quasi-uniformly distributed points on a unit sphere using a Fibonacci lattice.\n    \n    Args:\n        M (int): The number of points to generate.\n    \n    Returns:\n        np.ndarray: An array of shape (M, 3) containing the Cartesian coordinates of the points.\n    \"\"\"\n    indices = np.arange(M, dtype=float) + 0.5\n    \n    # y-coordinates are spaced to ensure equal area slices\n    y = 1.0 - 2.0 * indices / M\n    \n    # Radius of each slice\n    radius = np.sqrt(1.0 - y**2)\n    \n    # Golden angle for spiral distribution\n    golden_angle = np.pi * (1.0 + np.sqrt(5.0))\n    theta = golden_angle * indices\n    \n    x = radius * np.cos(theta)\n    z = radius * np.sin(theta)\n    \n    # Combine into an (M, 3) array of unit vectors\n    unit_vectors = np.vstack([x, y, z]).T\n    return unit_vectors\n\ndef compute_anisotropy_metric(px, py, pz, dx, dy, dz, alpha, M):\n    \"\"\"\n    Computes the anisotropy metric for a given set of filter parameters.\n\n    Args:\n        px, py, pz (int): Filter orders for x, y, and z axes.\n        dx, dy, dz (float): Grid spacings for x, y, and z axes.\n        alpha (float): Scaling factor for the test wavenumber magnitude.\n        M (int): Number of points to sample on the sphere.\n\n    Returns:\n        float: The computed anisotropy metric A(k0).\n    \"\"\"\n    # Case 1: Trivial case with no filtering. Anisotropy is zero by definition.\n    if px == 0 and py == 0 and pz == 0:\n        return 0.0\n\n    # Calculate the test wavenumber magnitude k0\n    k_nyquist_min = np.pi / max(dx, dy, dz) # Equivalent to min(pi/dx, pi/dy, pi/dz)\n    k0 = alpha * k_nyquist_min\n    \n    # Generate unit vectors for sampling directions\n    unit_vectors = get_fibonacci_sphere_points(M)\n    nx, ny, nz = unit_vectors[:, 0], unit_vectors[:, 1], unit_vectors[:, 2]\n\n    # Calculate arguments for the cosine functions\n    arg_x = k0 * nx * dx / 2.0\n    arg_y = k0 * ny * dy / 2.0\n    arg_z = k0 * nz * dz / 2.0\n\n    # The choice of k0 ensures the arguments are in [-pi/2, pi/2], so cos is non-negative.\n    # We can omit the absolute value on the cosine.\n    term_x = np.cos(arg_x)**px\n    term_y = np.cos(arg_y)**py\n    term_z = np.cos(arg_z)**pz\n\n    # Compute the 3D transfer function magnitude for all sampled directions\n    H_values = term_x * term_y * term_z\n\n    # Compute the mean and standard deviation of the transfer function magnitudes\n    mean_H = np.mean(H_values)\n    std_H = np.std(H_values)\n\n    # The anisotropy metric is the relative standard deviation (coefficient of variation)\n    # A small epsilon is added to the denominator for numerical stability, though unlikely needed here.\n    if mean_H  1e-12:\n        return np.inf # Or handle as an error, but should not occur in this problem.\n        \n    anisotropy = std_H / mean_H\n    \n    return anisotropy\n\nsolve()\n```"
        }
    ]
}