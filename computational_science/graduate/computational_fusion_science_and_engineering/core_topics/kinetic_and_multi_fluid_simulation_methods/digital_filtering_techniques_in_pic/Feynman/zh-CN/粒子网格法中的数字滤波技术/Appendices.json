{
    "hands_on_practices": [
        {
            "introduction": "理解任何数字滤波器的第一步是量化其对单个傅里叶模式的影响。本练习旨在从基本原理出发，推导一种常用滤波器——二项式滤波器——的精确频率响应和群延迟，这两者可被视为其在傅里叶空间中的“指纹”。掌握这项核心分析技能对于预测滤波器在模拟中的行为，以及为特定应用设计和选择合适的滤波器至关重要。",
            "id": "3965593",
            "problem": "考虑在均匀网格上用于减轻网格尺度噪声的粒子模拟 (PIC) 等离子体仿真中的一维空间平滑。令网格索引为 $n \\in \\mathbb{Z}$，网格间距为 $\\Delta x$。一个电流密度序列 $j[n]$ 通过一个线性时不变滤波器进行平滑，该滤波器的有限冲激响应 (FIR) 核是长度为 $5$ 的双通二项式核，其系数为\n$$\nh[0] = \\frac{1}{16}, \\quad h[1] = \\frac{4}{16}, \\quad h[2] = \\frac{6}{16}, \\quad h[3] = \\frac{4}{16}, \\quad h[4] = \\frac{1}{16}.\n$$\n平滑后的序列由离散卷积定义，\n$$\ny[n] = \\sum_{m=0}^{4} h[m]\\, j[n-m].\n$$\n令输入为单一空间傅里叶模式 $j[n] = \\exp\\!\\big(i k n \\Delta x\\big)$，其中 $k$ 是物理波数。定义离散弧度频率 $\\omega = k \\Delta x$。该核的离散傅里叶变换 (DFT) 频率响应 $H(\\omega)$ 由离散时间傅里叶变换给出\n$$\nH(\\omega) = \\sum_{m=0}^{4} h[m]\\, \\exp(-i \\omega m).\n$$\n仅从离散卷积和离散时间傅里叶变换的定义出发，推导幅度响应 $|H(\\omega)|$ 和由下式定义的群延迟 $\\tau_{g}(\\omega)$ 的精确闭式表达式\n$$\n\\tau_{g}(\\omega) = -\\frac{d}{d\\omega} \\,\\phi(\\omega),\n$$\n其中 $\\phi(\\omega)$ 是 $H(\\omega)$ 的解卷相位。将 $|H(\\omega)|$ 和 $\\tau_{g}(\\omega)$ 都表示为 $\\omega$ 的解析函数。无需进行数值舍入。将你的最终答案以一个双元素行矩阵的形式给出，其中第一个元素等于幅度响应 $|H(\\omega)|$，第二个元素等于群延迟 $\\tau_{g}(\\omega)$。最终答案中不要包含单位。",
            "solution": "该问题要求推导给定有限冲激响应 (FIR) 滤波器的幅度响应 $|H(\\omega)|$ 和群延迟 $\\tau_{g}(\\omega)$。推导应从所提供的基本定义出发。\n\n该 FIR 滤波器由其冲激响应（核）$h[n]$ 定义。给定的系数是：\n$h[0] = \\frac{1}{16}$，$h[1] = \\frac{4}{16}$，$h[2] = \\frac{6}{16}$，$h[3] = \\frac{4}{16}$，以及 $h[4] = \\frac{1}{16}$。\n\n频率响应 $H(\\omega)$ 是核 $h[n]$ 的离散时间傅里叶变换 (DTFT)，由以下公式给出：\n$$\nH(\\omega) = \\sum_{m=0}^{4} h[m]\\, \\exp(-i \\omega m)\n$$\n代入 $h[m]$ 的给定系数：\n$$\nH(\\omega) = h[0] \\exp(-i \\omega \\cdot 0) + h[1] \\exp(-i \\omega \\cdot 1) + h[2] \\exp(-i \\omega \\cdot 2) + h[3] \\exp(-i \\omega \\cdot 3) + h[4] \\exp(-i \\omega \\cdot 4)\n$$\n$$\nH(\\omega) = \\frac{1}{16} + \\frac{4}{16} \\exp(-i\\omega) + \\frac{6}{16} \\exp(-i2\\omega) + \\frac{4}{16} \\exp(-i3\\omega) + \\frac{1}{16} \\exp(-i4\\omega)\n$$\n我们可以提出公因式 $\\frac{1}{16}$：\n$$\nH(\\omega) = \\frac{1}{16} \\left( 1 + 4\\exp(-i\\omega) + 6\\exp(-i2\\omega) + 4\\exp(-i3\\omega) + \\exp(-i4\\omega) \\right)\n$$\n滤波器系数是对称的，即 $h[m] = h[4-m]$。这表明该滤波器具有广义线性相位。对于这个长度为 $N=5$（索引从 $0$到 $4$）的滤波器，其对称中心在 $m=2$。我们可以提出与此对称中心对应的项 $\\exp(-i2\\omega)$ 来简化表达式。\n$$\nH(\\omega) = \\frac{1}{16} \\exp(-i2\\omega) \\left( \\exp(i2\\omega) + 4\\exp(i\\omega) + 6 + 4\\exp(-i\\omega) + \\exp(-i2\\omega) \\right)\n$$\n通过对各项进行分组并使用欧拉恒等式 $\\exp(i\\theta) + \\exp(-i\\theta) = 2\\cos(\\theta)$，我们可以重写括号内的表达式：\n$$\n\\left( \\exp(i2\\omega) + \\exp(-i2\\omega) \\right) + 4 \\left( \\exp(i\\omega) + \\exp(-i\\omega) \\right) + 6 = 2\\cos(2\\omega) + 4(2\\cos(\\omega)) + 6\n$$\n因此，频率响应变为：\n$$\nH(\\omega) = \\frac{1}{16} \\exp(-i2\\omega) \\left( 2\\cos(2\\omega) + 8\\cos(\\omega) + 6 \\right)\n$$\n为了简化实值振幅部分，我们使用二倍角三角恒等式 $\\cos(2\\omega) = 2\\cos^2(\\omega) - 1$：\n$$\n2(2\\cos^2(\\omega) - 1) + 8\\cos(\\omega) + 6 = 4\\cos^2(\\omega) - 2 + 8\\cos(\\omega) + 6 = 4\\cos^2(\\omega) + 8\\cos(\\omega) + 4\n$$\n这个表达式是一个完全平方：\n$$\n4(\\cos^2(\\omega) + 2\\cos(\\omega) + 1) = 4(\\cos(\\omega) + 1)^2\n$$\n将此代回 $H(\\omega)$ 的表达式：\n$$\nH(\\omega) = \\frac{1}{16} \\exp(-i2\\omega) \\left[ 4(\\cos(\\omega) + 1)^2 \\right] = \\frac{1}{4} \\exp(-i2\\omega) (\\cos(\\omega) + 1)^2\n$$\n现在，我们使用半角恒等式 $1 + \\cos(\\omega) = 2\\cos^2(\\frac{\\omega}{2})$：\n$$\nH(\\omega) = \\frac{1}{4} \\exp(-i2\\omega) \\left[ 2\\cos^2\\left(\\frac{\\omega}{2}\\right) \\right]^2 = \\frac{1}{4} \\exp(-i2\\omega) \\left[ 4\\cos^4\\left(\\frac{\\omega}{2}\\right) \\right]\n$$\n这可以简化为频率响应的一个非常紧凑的形式：\n$$\nH(\\omega) = \\cos^4\\left(\\frac{\\omega}{2}\\right) \\exp(-i2\\omega)\n$$\n这个表达式是极坐标形式 $H(\\omega) = A(\\omega) \\exp(i\\phi(\\omega))$，其中 $A(\\omega) = \\cos^4\\left(\\frac{\\omega}{2}\\right)$ 是振幅，$\\phi(\\omega) = -2\\omega$ 是相位。\n\n首先，我们求幅度响应 $|H(\\omega)|$。它是复函数 $H(\\omega)$ 的绝对值。\n$$\n|H(\\omega)| = \\left| \\cos^4\\left(\\frac{\\omega}{2}\\right) \\exp(-i2\\omega) \\right| = \\left| \\cos^4\\left(\\frac{\\omega}{2}\\right) \\right| \\cdot |\\exp(-i2\\omega)|\n$$\n由于 $|\\exp(-i2\\omega)| = \\sqrt{\\cos^2(-2\\omega) + \\sin^2(-2\\omega)} = 1$，并且对于实数 $\\omega$，$\\cos^4(\\frac{\\omega}{2})$ 始终为非负值，所以幅度响应就是振幅函数本身：\n$$\n|H(\\omega)| = \\cos^4\\left(\\frac{\\omega}{2}\\right)\n$$\n其次，我们求群延迟 $\\tau_g(\\omega)$。群延迟定义为 $\\tau_{g}(\\omega) = -\\frac{d}{d\\omega} \\phi(\\omega)$，其中 $\\phi(\\omega)$ 是 $H(\\omega)$ 的解卷相位。\n从我们的表达式 $H(\\omega) = \\cos^4(\\frac{\\omega}{2}) \\exp(-i2\\omega)$ 中，振幅项 $\\cos^4(\\frac{\\omega}{2})$ 始终为非负值。因此，不存在 $\\pm\\pi$ 的相位跳变， $H(\\omega)$ 的相位直接由复指数项的辐角给出。\n相位 $\\phi(\\omega)$ 是：\n$$\n\\phi(\\omega) = -2\\omega\n$$\n由于这是 $\\omega$ 的线性函数，它已经是其解卷形式。我们现在可以计算其关于 $\\omega$ 的导数来求得群延迟：\n$$\n\\tau_g(\\omega) = -\\frac{d}{d\\omega} (-2\\omega) = -(-2) = 2\n$$\n群延迟是一个常数值 $2$。这对于对称 FIR 滤波器是预料之中的，其群延迟等于核的对称中心的索引，即 $(N-1)/2 = (5-1)/2 = 2$。\n\n所求的两个量是幅度响应 $|H(\\omega)|$ 和群延迟 $\\tau_g(\\omega)$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\cos^4\\left(\\frac{\\omega}{2}\\right)  2 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在真实的PIC模拟中，滤波效应并非来自单一来源，而是粒子形状函数（一种隐式滤波）和网格上显式平滑操作的共同结果。本练习将探讨如何分析这些不同环节构成的“组合系统”的传递函数，这对于理解整个数值方案的精度和稳定性至关重要。通过计算组合系统在低波数下的通带平坦度（影响长波物理的精度）和高波数下的阻带深度（影响短波噪声的抑制能力），我们可以对数值方案的整体性能做出定量评估。",
            "id": "3965627",
            "problem": "在一维单元内粒子 (PIC) 模拟中，考虑在一个间距为 $\\Delta x$ 的均匀网格上模拟磁化聚变等离子体。我们使用三角形云 (TSC) 方法进行电荷沉积，该方法是通过将宽度为 $\\Delta x$ 的顶帽函数自身卷积 3 次形成的二次B样条。为了减轻混叠效应和高频数值噪声，在电荷沉积后，对网格电荷密度连续两次应用核为 $\\{1, 2, 1\\}/4$ 的显式二项式平滑滤波器。假设所有操作都是线性的且空间移不变的，并在连续波数域中进行所有分析。\n\n从卷积和傅里叶变换的定义出发，并仅使用关于傅里叶域中传递函数相乘的成熟结论，推导出组合波数传递函数 $T(k)$，该函数将波数为 $k$ 的底层物理电荷模式映射到滤波后的网格电荷密度。然后，按如下方式分析其低波数通带和高波数阻带：\n\n1. 通过归一化传递函数在 $k=0$ 附近的二阶泰勒展开式定义通带平坦度系数 $a$：\n$$\n\\frac{T(k)}{T(0)} = 1 - a\\,(k \\Delta x)^{2} + \\mathcal{O}\\!\\left((k \\Delta x)^{4}\\right).\n$$\n精确计算 $a$。\n\n2. 定义阻带深度 $D$ 为 $T(k)$ 在奈奎斯特波数 $k_{\\mathrm{N}} = \\pi/\\Delta x$ 处的精确值。精确计算 $D$。\n\n将您的最终答案表示为包含数对 $(a, D)$ 的行矩阵。无需四舍五入，最终报告的值中不应包含单位。",
            "solution": "本题要求推导和分析在一个单元内粒子 (PIC) 模拟中一系列操作的组合波数传递函数：首先使用三角形云 (TSC) 方案进行电荷沉积，然后连续两次应用二项式平滑滤波器。分析将在连续波数域中进行，并假设所有操作都是线性的且空间移不变的。\n\n分析线性、移不变操作序列的基本原理是，在傅里叶（波数）域中的总传递函数是每个操作的单个传递函数的乘积。设总传递函数为 $T(k)$，其中 $k$ 是波数。该过程包括一个 TSC 沉积步骤和两个相同的滤波步骤。因此，我们可以写出：\n$$\nT(k) = T_{\\mathrm{TSC}}(k) \\cdot \\left( T_{\\mathrm{filter}}(k) \\right)^2\n$$\n其中 $T_{\\mathrm{TSC}}(k)$ 是 TSC 沉积的传递函数，$T_{\\mathrm{filter}}(k)$ 是单次应用二项式滤波器的传递函数。我们现在来推导这些分量。\n\n首先，我们来推导 TSC 沉积的传递函数 $T_{\\mathrm{TSC}}(k)$。题目指出，TSC 是通过将宽度为 $\\Delta x$ 的顶帽函数自身卷积 3 次形成的二次B样条。我们定义一个归一化的顶帽函数 $S_1(x)$，使其在整个空间上的积分为 1：\n$$\nS_1(x) = \\begin{cases} \\frac{1}{\\Delta x}  |x| \\le \\frac{\\Delta x}{2} \\\\ 0  |x| > \\frac{\\Delta x}{2} \\end{cases}\n$$\n这个形函数的传递函数是它的傅里叶变换 $\\hat{S}_1(k)$：\n$$\n\\hat{S}_1(k) = \\int_{-\\infty}^{\\infty} S_1(x) e^{-ikx} \\, dx = \\frac{1}{\\Delta x} \\int_{-\\Delta x/2}^{\\Delta x/2} e^{-ikx} \\, dx\n$$\n$$\n\\hat{S}_1(k) = \\frac{1}{-ik\\Delta x} \\left( e^{-ik\\Delta x/2} - e^{ik\\Delta x/2} \\right) = \\frac{2 \\sin(k\\Delta x/2)}{k\\Delta x}\n$$\n这个表达式可以写成 $\\frac{\\sin(k\\Delta x/2)}{k\\Delta x/2}$。TSC 形函数 $S_{\\mathrm{TSC}}(x)$ 是三次这样卷积的结果：$S_{\\mathrm{TSC}}(x) = S_1(x) * S_1(x) * S_1(x)$，其中 $*$ 表示卷积。根据卷积定理，其傅里叶变换，即沉积传递函数 $T_{\\mathrm{TSC}}(k)$，是 $\\hat{S}_1(k)$ 的三次方：\n$$\nT_{\\mathrm{TSC}}(k) = \\left( \\frac{\\sin(k\\Delta x/2)}{k\\Delta x/2} \\right)^3\n$$\n\n接下来，我们推导二项式平滑滤波器的传递函数 $T_{\\mathrm{filter}}(k)$。该滤波器应用于网格上的离散电荷密度 $\\rho_j = \\rho(j\\Delta x)$。滤波器的核为 $\\{\\frac{1}{4}, \\frac{2}{4}, \\frac{1}{4}\\}$。在网格点 $j$ 处的滤波值，记为 $\\rho'_j$，是：\n$$\n\\rho'_j = \\frac{1}{4}\\rho_{j-1} + \\frac{2}{4}\\rho_j + \\frac{1}{4}\\rho_{j+1}\n$$\n为了找到传递函数，我们分析它对网格上单个傅里叶模式 $e^{ikx_j} = e^{ikj\\Delta x}$ 的影响。将滤波器应用于此模式，得到：\n$$\n\\frac{1}{4}e^{ik(j-1)\\Delta x} + \\frac{2}{4}e^{ikj\\Delta x} + \\frac{1}{4}e^{ik(j+1)\\Delta x} = e^{ikj\\Delta x} \\left( \\frac{1}{4}e^{-ik\\Delta x} + \\frac{1}{2} + \\frac{1}{4}e^{ik\\Delta x} \\right)\n$$\n括号中的项就是传递函数 $T_{\\mathrm{filter}}(k)$：\n$$\nT_{\\mathrm{filter}}(k) = \\frac{1}{2} + \\frac{1}{4}(e^{ik\\Delta x} + e^{-ik\\Delta x}) = \\frac{1}{2} + \\frac{1}{2}\\cos(k\\Delta x)\n$$\n使用半角恒等式 $1 + \\cos(\\theta) = 2\\cos^2(\\theta/2)$，我们可以简化这个表达式：\n$$\nT_{\\mathrm{filter}}(k) = \\frac{1}{2}(1 + \\cos(k\\Delta x)) = \\cos^2\\left(\\frac{k\\Delta x}{2}\\right)\n$$\n\n现在我们可以构建总传递函数 $T(k)$。为简化表示，令 $u = \\frac{k\\Delta x}{2}$。\n$$\nT_{\\mathrm{TSC}}(k) = \\left(\\frac{\\sin u}{u}\\right)^3\n$$\n$$\nT_{\\mathrm{filter}}(k) = \\cos^2(u)\n$$\n总传递函数是：\n$$\nT(k) = T_{\\mathrm{TSC}}(k) \\cdot \\left( T_{\\mathrm{filter}}(k) \\right)^2 = \\left(\\frac{\\sin u}{u}\\right)^3 \\cos^4(u)\n$$\n\n推导出总传递函数后，我们继续计算所要求的两个量。\n\n1. 通带平坦度系数 $a$：\n该系数由 $k=0$ 附近的泰勒级数展开式定义：\n$$\n\\frac{T(k)}{T(0)} = 1 - a\\,(k \\Delta x)^{2} + \\mathcal{O}\\!\\left((k \\Delta x)^{4}\\right)\n$$\n首先，我们求 $T(0)$。当 $k \\to 0$ 时，我们有 $u \\to 0$。在此极限下，$\\frac{\\sin u}{u} \\to 1$ 且 $\\cos(u) \\to 1$。因此，$T(0) = (1)^3 \\cdot (1)^4 = 1$。归一化传递函数就是 $T(k)$。\n我们必须将 $T(k)$ 展开为 $k\\Delta x$ 的幂级数，或者等价地，展开为 $u$ 的幂级数。注意到 $(k\\Delta x)^2 = (2u)^2 = 4u^2$。\n我们使用 $\\sin(u)$ 和 $\\cos(u)$ 在 $u=0$ 附近的泰勒级数：\n$$\n\\sin(u) = u - \\frac{u^3}{6} + \\mathcal{O}(u^5) \\implies \\frac{\\sin u}{u} = 1 - \\frac{u^2}{6} + \\mathcal{O}(u^4)\n$$\n$$\n\\cos(u) = 1 - \\frac{u^2}{2} + \\mathcal{O}(u^4)\n$$\n现在我们计算 $T(k)$ 所需的幂，保留到 $\\mathcal{O}(u^2)$ 的项：\n$$\n\\left(\\frac{\\sin u}{u}\\right)^3 = \\left(1 - \\frac{u^2}{6} + \\mathcal{O}(u^4)\\right)^3 = 1 - 3\\left(\\frac{u^2}{6}\\right) + \\mathcal{O}(u^4) = 1 - \\frac{u^2}{2} + \\mathcal{O}(u^4)\n$$\n$$\n\\cos^4(u) = \\left(1 - \\frac{u^2}{2} + \\mathcal{O}(u^4)\\right)^4 = 1 - 4\\left(\\frac{u^2}{2}\\right) + \\mathcal{O}(u^4) = 1 - 2u^2 + \\mathcal{O}(u^4)\n$$\n将这两个展开式相乘，得到 $T(k)$ 的展开式：\n$$\nT(k) = \\left(1 - \\frac{u^2}{2}\\right)\\left(1 - 2u^2\\right) + \\mathcal{O}(u^4) = 1 - 2u^2 - \\frac{u^2}{2} + \\mathcal{O}(u^4) = 1 - \\frac{5}{2}u^2 + \\mathcal{O}(u^4)\n$$\n现在，代回 $u = \\frac{k\\Delta x}{2}$：\n$$\nT(k) = 1 - \\frac{5}{2}\\left(\\frac{k\\Delta x}{2}\\right)^2 + \\mathcal{O}((k\\Delta x)^4) = 1 - \\frac{5}{8}(k\\Delta x)^2 + \\mathcal{O}((k\\Delta x)^4)\n$$\n将此与定义式 $T(k) = 1 - a(k\\Delta x)^2 + \\mathcal{O}((k\\Delta x)^4)$ 进行比较，我们确定系数 $a$：\n$$\na = \\frac{5}{8}\n$$\n\n2. 阻带深度 $D$：\n这被定义为 $T(k)$ 在奈奎斯特波数 $k_{\\mathrm{N}} = \\frac{\\pi}{\\Delta x}$ 处的值。\n在 $k=k_{\\mathrm{N}}$ 时，参数 $u$ 变为：\n$$\nu_{\\mathrm{N}} = \\frac{k_{\\mathrm{N}}\\Delta x}{2} = \\frac{(\\pi/\\Delta x)\\Delta x}{2} = \\frac{\\pi}{2}\n$$\n我们计算 $T(k)$ 在 $u=\\frac{\\pi}{2}$ 处的值：\n$$\nD = T(k_{\\mathrm{N}}) = \\left(\\frac{\\sin(\\pi/2)}{\\pi/2}\\right)^3 \\cos^4\\left(\\frac{\\pi}{2}\\right)\n$$\n我们知道 $\\sin(\\frac{\\pi}{2}) = 1$ 且 $\\cos(\\frac{\\pi}{2}) = 0$。\n$$\nD = \\left(\\frac{1}{\\pi/2}\\right)^3 \\cdot (0)^4 = \\left(\\frac{2}{\\pi}\\right)^3 \\cdot 0 = 0\n$$\n阻带深度恰好为零。这是二项式滤波器的传递函数 $\\cos^2(u)$ 在 $u=\\frac{\\pi}{2}$ 处有一个零点的直接结果。\n\n最终答案是数对 $(a, D)$。我们得到 $a = \\frac{5}{8}$ 和 $D=0$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{5}{8}  0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "应用数字滤波器可能会带来意想不到的严重后果，尤其是在处理基本物理守恒律时。本练习将通过一个动手编程任务，深入探究对电流密度进行空间滤波如何可能破坏离散电荷守恒方程，从而导致非物理的结果。通过对比不同滤波策略，本练习清晰地揭示了为何对电荷和电流进行“一致性”滤波是维护模拟物理真实性的关键所在，这是任何PIC代码开发者都必须掌握的重要实践。",
            "id": "3965601",
            "problem": "考虑聚变等离子体切片沿一条长度为 $L$ 的线的一维、周期性粒子模拟（PIC）离散化，该线段上有 $N$ 个宽度为 $\\Delta x$ 的均匀间隔的单元，使得 $L = N \\Delta x$。使用云中单元（CIC）形状函数进行电荷分配。位于单元中心的线电荷密度用 $\\rho_i$ 表示，单位为 $\\,\\mathrm{C/m}$，位于单元面中心的电流用 $J_{i+1/2}$ 表示，单位为 $\\,\\mathrm{C/s}$。设时间步长为 $\\Delta t$，单位为 $\\,\\mathrm{s}$。离散形式的连续性方程，由基本定律 $\\partial_t \\rho + \\nabla \\cdot \\mathbf{J} = 0$ 推导而来，需以下列形式强制执行：\n$$\n\\frac{\\rho_i^{n+1} - \\rho_i^{n}}{\\Delta t} + \\frac{J_{i+1/2}^{n+1/2} - J_{i-1/2}^{n+1/2}}{\\Delta x} = 0,\n$$\n该方程对所有单元索引 $i$ 成立，并采用周期性边界条件。Esirkepov 电流是指在使用相同形状函数进行电荷分配时，能够精确满足上述离散连续性方程的面中心电流。\n\n对于一组给定的粒子，其在时刻 $t^n$ 的电荷为 $q_p$、位置为 $x_p^n$，在时刻 $t^{n+1} = t^n + \\Delta t$ 的位置为 $x_p^{n+1}$，请按以下步骤操作：\n- 使用云中单元（CIC）形状函数将电荷分配至单元中心，得到 $\\rho_i^n$ 和 $\\rho_i^{n+1}$，并通过单元宽度 $\\Delta x$ 进行归一化，以确保 $\\sum_i \\rho_i \\Delta x = \\sum_p q_p$ 成立。\n- 计算一个面中心电流 $J_{i+1/2}^{n+1/2}$，该电流对于已分配的 $\\rho_i^n$ 和 $\\rho_i^{n+1}$ 精确满足离散连续性方程。\n- 对 $J_{i+1/2}^{n+1/2}$ 在空间上应用可分离的二项式数字滤波器，一维周期性卷积核为 $[1, 2, 1]/4$，应用指定的次数。可选择性地对 $\\rho_i^n$ 和 $\\rho_i^{n+1}$ 应用相同的空间二项式滤波器。\n- 计算每个单元的离散连续性残差，\n$$\n\\varepsilon_i = \\frac{\\rho_i^{n+1} - \\rho_i^{n}}{\\Delta t} + \\frac{J_{i+1/2}^{n+1/2} - J_{i-1/2}^{n+1/2}}{\\Delta x},\n$$\n并报告最大绝对残差 $\\max_i |\\varepsilon_i|$，单位为 $\\,\\mathrm{C/(s \\cdot m)}$。\n\n您的程序必须实现一维周期性边界条件和 CIC 电荷分配。可分离二项式滤波器必须实现为周期性空间卷积，并应用指定的次数。通过测量在对 Esirkepov 电流进行滤波前后，以及在对电荷和电流进行一致滤波时的离散连续性残差，来数值上验证电荷守恒。\n\n使用以下参数值和粒子运动的测试套件。所有位置都在域 $[0, L)$ 内，其中 $L = N \\Delta x$，并进行周期性回卷。使用 $N = 64$，$\\Delta x = 10^{-3}\\,\\mathrm{m}$，$\\Delta t = 10^{-9}\\,\\mathrm{s}$，以及电子电荷大小 $e = 1.602 \\times 10^{-19}\\,\\mathrm{C}$。每个粒子的电荷为 $q_p = -e$。\n\n定义六个测试用例，每个用例产生一个浮点数，等于 $\\max_i |\\varepsilon_i|$，单位为 $\\,\\mathrm{C/(s \\cdot m)}$：\n- 用例 1（理想情况，无滤波）：两个粒子移动但未跨越单元边界。粒子 1：从 $x_1^n = 1.0 \\times 10^{-2}\\,\\mathrm{m}$ 到 $x_1^{n+1} = 1.07 \\times 10^{-2}\\,\\mathrm{m}$。粒子 2：从 $x_2^n = 3.0 \\times 10^{-2}\\,\\mathrm{m}$ 到 $x_2^{n+1} = 2.96 \\times 10^{-2}\\,\\mathrm{m}$。不对 $\\rho$ 或 $J$ 进行滤波。\n- 用例 2（仅对电流滤波）：与用例 1 相同的粒子和运动，仅对 $J$ 应用一次二项式滤波器。\n- 用例 3（对两者进行一致滤波）：与用例 1 相同的粒子和运动，对 $\\rho$（在时刻 $t^n$ 和 $t^{n+1}$）和 $J$ 应用一次二项式滤波器。\n- 用例 4（边界情况，周期性穿越，无滤波）：粒子 1：从 $x_1^n = 6.35 \\times 10^{-2}\\,\\mathrm{m}$ 到 $x_1^{n+1} = 3.0 \\times 10^{-4}\\,\\mathrm{m}$（环绕）。粒子 2：从 $x_2^n = 1.0 \\times 10^{-3}\\,\\mathrm{m}$ 到 $x_2^{n+1} = 2.7 \\times 10^{-3}\\,\\mathrm{m}$。不对 $\\rho$ 或 $J$ 进行滤波。\n- 用例 5（边界情况，周期性穿越，仅对电流滤波）：与用例 4 相同的粒子和运动，仅对 $J$ 应用一次二项式滤波器。\n- 用例 6（零运动）：一个粒子，位置为 $x_1^n = 2.0 \\times 10^{-2}\\,\\mathrm{m}$ 和 $x_1^{n+1} = 2.0 \\times 10^{-2}\\,\\mathrm{m}$。仅对 $J$ 应用一次二项式滤波器。\n\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表（例如，“[$r_1, r_2, r_3, r_4, r_5, r_6$]”），其中每个 $r_k$ 是用例 $k$ 的 $\\max_i |\\varepsilon_i|$ 的浮点值，单位为 $\\,\\mathrm{C/(s \\cdot m)}$。",
            "solution": "该问题要求在一维粒子模拟（PIC）中，针对多种数字滤波场景，计算离散电荷连续性方程的残差。解决方案涉及实现云中单元（CIC）电荷分配方案，计算能够精确满足离散连续性方程的 Esirkepov 电流，应用二项式滤波器，并最终计算残差。\n\n物理系统是一个长度为 $L$ 的一维周期性区域，被离散化为 $N$ 个宽度为 $\\Delta x$ 的单元。单元中心的电荷密度为 $\\rho_i$，面中心的电流为 $J_{i+1/2}$。为简化表示，我们将单元中心的网格用索引 $i$（范围从 $0$ 到 $N-1$）表示，而单元面的网格也用索引 $i$ 表示（对应于单元 $i$ 的左侧面）。连续性方程随后可写为：\n$$\n\\frac{\\rho_i^{n+1} - \\rho_i^{n}}{\\Delta t} + \\frac{J_{i+1} - J_i}{\\Delta x} = 0\n$$\n其中 $J_i$ 表示位于位置 $i \\Delta x$ 的面上的电流。所有索引都遵循周期性边界条件，即索引 $k$ 等价于 $k \\pmod N$。\n\n每个测试用例的总体算法如下：\n1.  将粒子电荷分配到网格上以获得密度 $\\rho_i^n$ 和 $\\rho_i^{n+1}$。\n2.  如果指定，对电荷密度应用二项式滤波器。\n3.  计算与（可能已滤波的）电荷密度相一致的 Esirkepov 电流 $J_i$。\n4.  如果指定，对计算出的电流应用二项式滤波器。\n5.  使用最终的电荷密度和电流计算连续性残差 $\\varepsilon_i$。\n6.  报告残差的最大绝对值 $\\max_i |\\varepsilon_i|$。\n\n**步骤1：云中单元（CIC）电荷分配**\nCIC 方案将位于位置 $x_p$ 的粒子的电荷 $q_p$ 分配到最近的两个网格点上。电荷密度的网格由位于位置 $x_i = (i+0.5)\\Delta x$（$i=0, ..., N-1$）的单元中心组成。\n\n对于位于位置 $x_p$ 的粒子，我们首先找到其逻辑坐标 $u_p = x_p / \\Delta x$。粒子左侧紧邻的单元中心的索引为 $i = \\lfloor u_p - 0.5 \\rfloor$。粒子距离该单元中心的分数距离（以 $\\Delta x$ 归一化）用作相邻单元中心的权重：\n$$\nw_{i+1} = u_p - (i + 0.5)\n$$\n左侧单元中心的权重是互补的：\n$$\nw_{i} = 1 - w_{i+1}\n$$\n电荷 $q_p$ 对相应单元中心 $i$ 和 $i+1$（索引对 $N$ 取模以实现周期性）的线电荷密度 $\\rho$（单位为 $\\,\\mathrm{C/m}$）的贡献如下：\n$$\n\\delta \\rho_i = \\frac{q_p w_i}{\\Delta x}, \\quad \\delta \\rho_{i+1} = \\frac{q_p w_{i+1}}{\\Delta x}\n$$\n总电荷密度 $\\rho_i$ 是所有粒子贡献的总和。对时刻 $t^n$ 和 $t^{n+1}$ 的粒子位置执行此过程，以分别获得 $\\rho_i^n$ 和 $\\rho_i^{n+1}$。\n\n**步骤2：Esirkepov 电流计算**\nEsirkepov 电流被定义为对于给定的电荷密度 $\\rho_i^n$ 和 $\\rho_i^{n+1}$，能够精确满足离散连续性方程的电流。重新整理连续性方程可得到关于电流 $J_i$ 的递推关系：\n$$\nJ_{i+1} = J_i - \\frac{\\Delta x}{\\Delta t} (\\rho_i^{n+1} - \\rho_i^n)\n$$\n令 $\\Delta\\rho_i = \\rho_i^{n+1} - \\rho_i^n$。该关系式为 $J_{i+1} = J_i - \\frac{\\Delta x}{\\Delta t} \\Delta\\rho_i$。这可以通过展开递推关系来求解：\n$$\nJ_i = J_0 - \\frac{\\Delta x}{\\Delta t} \\sum_{k=0}^{i-1} \\Delta\\rho_k\n$$\n这就定义了电流，但存在一个常数偏移量 $J_0$。对于一个没有净电荷注入或外部驱动场的周期性系统，穿过整个区域的净电流必须为零。我们强制执行此条件：$\\sum_{i=0}^{N-1} J_i = 0$。\n$$\n\\sum_{i=0}^{N-1} \\left( J_0 - \\frac{\\Delta x}{\\Delta t} \\sum_{k=0}^{i-1} \\Delta\\rho_k \\right) = N J_0 - \\frac{\\Delta x}{\\Delta t} \\sum_{i=0}^{N-1} \\sum_{k=0}^{i-1} \\Delta\\rho_k = 0\n$$\n由此可以确定常数偏移量 $J_0$，从而唯一地定义电流数组 $J$。此方法保证，当得到的电流与原始密度 $\\rho^n$ 和 $\\rho^{n+1}$ 一起使用时，产生的连续性残差为零（在机器精度范围内）。\n\n**步骤3：二项式滤波**\n指定的二项式滤波器使用一维卷积核 $[1, 2, 1]/4$，即 $[0.25, 0.5, 0.25]$。对于给定的一维数组 $A_i$，滤波后的数组 $A'_i$ 计算如下：\n$$\nA'_i = \\frac{1}{4} A_{i-1} + \\frac{2}{4} A_i + \\frac{1}{4} A_{i+1}\n$$\n该卷积是周期性的，意味着索引在数组边界处进行环绕（例如，$A_{-1} = A_{N-1}$）。此操作将按指定次数（本问题中为一次）应用于电流 $J_i$ 和/或密度 $\\rho_i^n, \\rho_i^{n+1}$（根据测试用例的要求）。\n\n**步骤4：残差计算**\n为每个单元 $i$ 计算离散连续性残差：\n$$\n\\varepsilon_i = \\frac{\\rho_i^{n+1} - \\rho_i^{n}}{\\Delta t} + \\frac{J_{i+1} - J_i}{\\Delta x}\n$$\n此公式中使用最终的（经过任何滤波步骤后的）电荷密度和电流。项 $\\frac{J_{i+1} - J_i}{\\Delta x}$ 是电流的离散散度。每个测试用例的最终结果是该残差在所有单元上的最大绝对值 $\\max_i |\\varepsilon_i|$。\n\n**测试用例分析：**\n- **用例 1 和 4（无滤波）：** 由于 Esirkepov 电流的计算方式使其能够精确满足连续性方程，因此对所有 $i$，残差 $\\varepsilon_i$ 将为零。报告值仅会因浮点算术误差而非零。\n- **用例 2 和 5（仅对电流滤波）：** 未滤波的密度 $\\rho$ 与滤波后的电流 $J'$ 一起使用。滤波操作会修改电流，使其不再平衡电荷密度的变化。这破坏了离散电荷守恒，导致非零残差。\n- **用例 3（对两者进行一致滤波）：** 滤波器是一个线性算子。将其应用于连续性方程可得：\n$$\nF\\left(\\frac{\\Delta\\rho_i}{\\Delta t} + \\frac{\\nabla \\cdot J_i}{\\Delta x}\\right) = \\frac{F(\\Delta\\rho_i)}{\\Delta t} + \\frac{F(\\nabla \\cdot J_i)}{\\Delta x} = F(0) = 0\n$$\n因为卷积与有限差分算子是可交换的（即 $F(\\nabla \\cdot J) = \\nabla \\cdot F(J)$），所以上式变为：\n$$\n\\frac{\\rho_i'^{n+1} - \\rho_i'^n}{\\Delta t} + \\frac{J'_{i+1} - J'_i}{\\Delta x} = 0\n$$\n其中带撇号的量是经过滤波的。这意味着如果我们对密度和电流进行一致的滤波，连续性方程仍然成立。残差应为零，误差在机器精度范围内。\n- **用例 6（零运动）：** 当没有粒子运动时，$\\rho^n = \\rho^{n+1}$。这导致对所有 $i$，$\\Delta\\rho_i = 0$，进而产生零 Esirkepov 电流，$J_i = 0$。对零电流进行滤波仍得到零电流。因此，残差方程中的所有项都为零，结果为零。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases for the PIC continuity residual problem.\n    \"\"\"\n    #\n    # Global Parameters\n    #\n    N = 64  # Number of cells\n    dx = 1e-3  # Cell width in meters\n    dt = 1e-9  # Time step in seconds\n    e_charge = 1.602e-19  # Elementary charge in Coulombs\n    q_p = -e_charge  # Particle charge\n    L = N * dx # Domain length\n\n    #\n    # Helper Functions\n    #\n    def cic_deposit(positions, q, N_grid, dx_grid):\n        \"\"\"\n        Deposits particle charges onto a 1D grid using the Cloud-In-Cell (CIC) method.\n        Assumes cell-centered grid.\n        \n        Args:\n            positions (np.array): Particle positions.\n            q (float): Charge of each particle.\n            N_grid (int): Number of grid cells.\n            dx_grid (float): Grid cell width.\n        \n        Returns:\n            np.array: Line charge density (C/m) on the grid.\n        \"\"\"\n        rho = np.zeros(N_grid)\n        domain_length = N_grid * dx_grid\n        \n        for pos in positions:\n            # Ensure particle is within the periodic domain [0, L)\n            pos_wrapped = pos % domain_length\n\n            # Logical coordinate (normalized by cell width)\n            u_p = pos_wrapped / dx_grid\n            \n            # Index of the left-hand cell center and weights\n            i_left_center = np.floor(u_p - 0.5)\n            w_right = u_p - (i_left_center + 0.5)\n            w_left = 1.0 - w_right\n            \n            # Grid indices with periodic wrapping\n            idx0 = int(i_left_center) % N_grid\n            idx1 = (idx0 + 1) % N_grid\n            \n            # Deposit charge, converting point charge to line density\n            rho[idx0] += q * w_left / dx_grid\n            rho[idx1] += q * w_right / dx_grid\n            \n        return rho\n\n    def calculate_esirkepov_current(rho_n, rho_n_plus_1, N_grid, dx_grid, dt_step):\n        \"\"\"\n        Calculates the face-centered current that exactly satisfies the discrete\n        continuity equation for the given cell-centered charge densities.\n        \n        Args:\n            rho_n (np.array): Charge density at time t^n.\n            rho_n_plus_1 (np.array): Charge density at time t^{n+1}.\n            N_grid, dx_grid, dt_step: Grid and time parameters.\n\n        Returns:\n            np.array: Face-centered current (C/s or Amperes).\n        \"\"\"\n        # Change in charge density times volume element, divided by dt\n        delta = -(dx_grid / dt_step) * (rho_n_plus_1 - rho_n)\n        \n        # Recurrence relation: J_{i+1} = J_i + delta_i\n        # J_i = J_0 + sum_{k=0}^{i-1} delta_k\n        S = np.zeros_like(delta)\n        S[1:] = np.cumsum(delta[:-1])\n        \n        # Impose zero net current: sum(J_i) = 0 to find J_0\n        J0 = -np.mean(S)\n        \n        # Construct the full current array\n        J = J0 + S\n        return J\n\n    def apply_binomial_filter(A):\n        \"\"\"\n        Applies a single pass of the [1, 2, 1]/4 binomial filter with periodic\n        boundary conditions.\n        \n        Args:\n            A (np.array): The 1D array to filter.\n            \n        Returns:\n            np.array: The filtered array.\n        \"\"\"\n        return 0.25 * np.roll(A, 1) + 0.5 * A + 0.25 * np.roll(A, -1)\n\n    def calculate_residual(rho_n, rho_n_plus_1, J, N_grid, dx_grid, dt_step):\n        \"\"\"\n        Calculates the maximum absolute value of the continuity equation residual.\n        \"\"\"\n        d_rho_dt = (rho_n_plus_1 - rho_n) / dt_step\n        # Discrete divergence of J: (J_{i+1} - J_i) / dx\n        div_J = (np.roll(J, -1) - J) / dx_grid\n        \n        epsilon = d_rho_dt + div_J\n        return np.max(np.abs(epsilon))\n\n    #\n    # Test Cases Definition\n    #\n    test_cases_params = [\n        # Case 1: Happy path, no filtering\n        {\n            \"particles_n\": np.array([1.0e-2, 3.0e-2]),\n            \"particles_n1\": np.array([1.07e-2, 2.96e-2]),\n            \"num_particles\": 2, \"filter_rho\": False, \"filter_J\": False\n        },\n        # Case 2: Filter current only\n        {\n            \"particles_n\": np.array([1.0e-2, 3.0e-2]),\n            \"particles_n1\": np.array([1.07e-2, 2.96e-2]),\n            \"num_particles\": 2, \"filter_rho\": False, \"filter_J\": True\n        },\n        # Case 3: Filter both consistently\n        {\n            \"particles_n\": np.array([1.0e-2, 3.0e-2]),\n            \"particles_n1\": np.array([1.07e-2, 2.96e-2]),\n            \"num_particles\": 2, \"filter_rho\": True, \"filter_J\": True\n        },\n        # Case 4: Periodic crossing, no filtering\n        {\n            \"particles_n\": np.array([6.35e-2, 1.0e-3]),\n            \"particles_n1\": np.array([3.0e-4, 2.7e-3]),\n            \"num_particles\": 2, \"filter_rho\": False, \"filter_J\": False\n        },\n        # Case 5: Periodic crossing, filter current only\n        {\n            \"particles_n\": np.array([6.35e-2, 1.0e-3]),\n            \"particles_n1\": np.array([3.0e-4, 2.7e-3]),\n            \"num_particles\": 2, \"filter_rho\": False, \"filter_J\": True\n        },\n        # Case 6: Zero motion, filter current only\n        {\n            \"particles_n\": np.array([2.0e-2]),\n            \"particles_n1\": np.array([2.0e-2]),\n            \"num_particles\": 1, \"filter_rho\": False, \"filter_J\": True\n        },\n    ]\n\n    results = []\n\n    #\n    # Main Loop\n    #\n    for params in test_cases_params:\n        # 1. Charge Deposition\n        rho_n = cic_deposit(params[\"particles_n\"], q_p, N, dx)\n        rho_n1 = cic_deposit(params[\"particles_n1\"], q_p, N, dx)\n    \n        # 2. Consistent Filtering of Rho (if applicable)\n        if params[\"filter_rho\"]:\n            rho_n_final = apply_binomial_filter(rho_n)\n            rho_n1_final = apply_binomial_filter(rho_n1)\n        else:\n            rho_n_final = rho_n\n            rho_n1_final = rho_n1\n\n        # 3. Calculate Esirkepov Current\n        # Note: current is calculated from densities *after* rho-filtering\n        J = calculate_esirkepov_current(rho_n_final, rho_n1_final, N, dx, dt)\n\n        # 4. Filter Current (if applicable)\n        if params[\"filter_J\"]:\n            J_final = apply_binomial_filter(J)\n        else:\n            J_final = J\n        \n        # 5. Calculate Residual\n        # Note: The residual must be calculated with the same densities used to generate the\n        # base current, even if the current itself is later filtered.\n        # This is because filtering J alone breaks conservation relative to the original rho.\n        # If rho is also filtered (Case 3), the residual is calculated with filtered versions of both.\n        max_residual = calculate_residual(rho_n_final, rho_n1_final, J_final, N, dx, dt)\n        results.append(max_residual)\n\n    #\n    # Final Output\n    #\n    print(f\"[{','.join(f'{r:.6e}' for r in results)}]\")\n\nsolve()\n\n```"
        }
    ]
}