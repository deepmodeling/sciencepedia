{
    "hands_on_practices": [
        {
            "introduction": "半拉格朗日方法是求解平流主导的动力学方程的强大工具。本练习旨在通过一个具体的计算，让你亲手实践一个半隐式格式的完整时间步长 。你将沿特征线向后追溯（拉格朗日步），进行插值，并对刚性的碰撞项进行隐式求解（欧拉步），从而深入理解这类混合格式的运作机制。",
            "id": "3992583",
            "problem": "考虑一维 Bhatnagar–Gross–Krook (BGK) 对流-弛豫动理学方程\n$$\n\\frac{\\partial f}{\\partial t} + v\\,\\frac{\\partial f}{\\partial x} = \\nu \\left(f_{\\mathrm{eq}} - f\\right),\n$$\n该方程具有恒定的对流速度 $v$ 和恒定的碰撞频率 $\\nu$，定义在长度为 $L$、坐标为 $x \\in [0,L)$ 的周期性域上。一个半拉格朗日时间步在空间上向后追踪一个时间增量内的特征线，以从前一时间层获得一个对流值，然后在时间上对弛豫项进行隐式推进。从时间 $t^{n+1}$ 的欧拉网格点 $x_i$ 出发的反向特征线在时间 $t^n$ 到达出发点 $x_{\\mathrm{d}}$，其中 $x_{\\mathrm{d}}$ 是使用恒定速度特征线确定的。\n\n给定一个包含 $N=8$ 个点的均匀网格，其长度 $L=1$，网格间距 $\\Delta x = L/N$，网格点为 $x_i = i\\,\\Delta x$（$i=0,1,\\dots,7$），并采用周期性边界条件。平衡态是均匀的，$f_{\\mathrm{eq}}(x)=0.25$。时间步长为 $\\Delta t = 0.125$，恒定速度为 $v = 1.6$，碰撞频率为 $\\nu = 4.0$。时间层 $t^n$ 的离散剖面通过在网格上采样 $f^n(x)=\\sin(2\\pi x)$ 来定义，因此\n- $f^n(x_0)=0$,\n- $f^n(x_1)=\\frac{\\sqrt{2}}{2}$,\n- $f^n(x_2)=1$,\n- $f^n(x_3)=\\frac{\\sqrt{2}}{2}$,\n- $f^n(x_4)=0$,\n- $f^n(x_5)=-\\frac{\\sqrt{2}}{2}$,\n- $f^n(x_6)=-1$,\n- $f^n(x_7)=-\\frac{\\sqrt{2}}{2}$.\n\n从对流项的特征线基本定义和沿特征线的弛豫项的隐式（后向欧拉）时间离散化出发，执行一个半拉格朗日隐式时间步。具体来说：\n- 从 $x_3$ 点向后追踪 $\\Delta t$ 时间的特征线，以获得出发点 $x_{\\mathrm{d}}$。\n- 使用均匀网格上两个最近的网格点之间的一阶线性插值，计算 $f^n$ 在 $x_{\\mathrm{d}}$ 处的值。\n- 在时间间隔 $\\Delta t$ 内，于 $x_3$ 点隐式推进弛豫项。\n\n计算 $f^{n+1}(x_3)$，并将您的最终答案表示为单个精确的解析表达式。请勿对结果进行近似或四舍五入；最终值不需要单位。",
            "solution": "该问题是适定的，科学上合理，并包含计算唯一解所需的所有信息。因此，我们可以进行计算。\n\n一维 Bhatnagar–Gross–Krook (BGK) 对流-弛豫动理学方程由下式给出：\n$$\n\\frac{\\partial f}{\\partial t} + v\\,\\frac{\\partial f}{\\partial x} = \\nu \\left(f_{\\mathrm{eq}} - f\\right)\n$$\n方程左侧表示分布函数 $f$ 沿着由 $\\frac{dx}{dt} = v$ 定义的特征曲线的全导数。我们将此全导数记为 $\\frac{Df}{Dt}$。该方程可以重写为：\n$$\n\\frac{Df}{Dt} = \\nu \\left(f_{\\mathrm{eq}} - f\\right)\n$$\n半拉格朗日隐式格式对该方程进行离散化。对流部分通过在时间上向后追踪特征线来处理。弛豫（源）项则采用隐式时间步进方法处理。为了求出网格点 $x_i$ 在时间 $t^{n+1} = t^n + \\Delta t$ 处的值 $f^{n+1}(x_i)$，我们首先确定在时间 $t^{n+1}$ 到达 $x_i$ 的特征线的出发点 $x_d$。前一时间步在该出发点的 $f$ 值，$f^n(x_d)$，被用作对流值。对弛豫项应用后向欧拉（全隐式）格式，我们得到：\n$$\n\\frac{f(x_i, t^{n+1}) - f(x_d, t^n)}{\\Delta t} = \\nu \\left(f_{\\mathrm{eq}}(x_i) - f(x_i, t^{n+1})\\right)\n$$\n设 $f_i^{n+1} = f(x_i, t^{n+1})$，并设 $f^n(x_d)$ 为时间 $t^n$ 在出发点处的分布函数值。关于 $f_i^{n+1}$ 的方程为：\n$$\n\\frac{f_i^{n+1} - f^n(x_d)}{\\Delta t} = \\nu \\left(f_{\\mathrm{eq},i} - f_i^{n+1}\\right)\n$$\n其中 $f_{\\mathrm{eq},i} = f_{\\mathrm{eq}}(x_i)$。重新整理以求解 $f_i^{n+1}$：\n$$\nf_i^{n+1} - f^n(x_d) = \\nu \\Delta t f_{\\mathrm{eq},i} - \\nu \\Delta t f_i^{n+1}\n$$\n$$\nf_i^{n+1} (1 + \\nu \\Delta t) = f^n(x_d) + \\nu \\Delta t f_{\\mathrm{eq},i}\n$$\n$$\nf_i^{n+1} = \\frac{f^n(x_d) + \\nu \\Delta t f_{\\mathrm{eq},i}}{1 + \\nu \\Delta t}\n$$\n该问题要求计算 $f^{n+1}(x_3)$。计算过程分三步进行：\n\n**步骤1：确定出发点 $x_d$**\n特征方程为 $\\frac{dx}{dt} = v$。对于恒定速度 $v$，在时间 $t^{n+1}$ 到达 $x_3$ 的特征线由 $x(t) = x_d + v(t - t^n)$ 给出。在 $t=t^{n+1}$ 时，我们有 $x(t^{n+1}) = x_3$。\n$$\nx_3 = x_d + v(t^{n+1} - t^n) = x_d + v \\Delta t\n$$\n因此，时间 $t^n$ 处的出发点是：\n$$\nx_d = x_3 - v \\Delta t\n$$\n给定值为：\n- 网格点 $x_3 = 3\\,\\Delta x = 3 \\times \\frac{L}{N} = 3 \\times \\frac{1}{8} = \\frac{3}{8}$。\n- 速度 $v = 1.6 = \\frac{16}{10} = \\frac{8}{5}$。\n- 时间步长 $\\Delta t = 0.125 = \\frac{1}{8}$。\n代入这些值：\n$$\nx_d = \\frac{3}{8} - \\left(\\frac{8}{5}\\right) \\left(\\frac{1}{8}\\right) = \\frac{3}{8} - \\frac{1}{5} = \\frac{15 - 8}{40} = \\frac{7}{40}\n$$\n所以，出发点是 $x_d = \\frac{7}{40} = 0.175$。\n\n**步骤2：使用线性插值计算 $f^n$ 在 $x_d$ 处的值**\n出发点 $x_d = 0.175$ 位于网格点 $x_1$ 和 $x_2$ 之间。\n- $x_1 = 1\\,\\Delta x = \\frac{1}{8} = 0.125$。\n- $x_2 = 2\\,\\Delta x = \\frac{2}{8} = 0.25$。\n在这些点上 $f^n$ 的值是给定的：\n- $f_1^n = f^n(x_1) = \\frac{\\sqrt{2}}{2}$。\n- $f_2^n = f^n(x_2) = 1$。\n一阶线性插值的定义为：\n$$\nf^n(x_d) = f_1^n + \\frac{x_d - x_1}{x_2 - x_1} (f_2^n - f_1^n)\n$$\n插值权重为 $\\alpha = \\frac{x_d - x_1}{x_2 - x_1} = \\frac{0.175 - 0.125}{0.25 - 0.125} = \\frac{0.05}{0.125} = \\frac{50}{125} = \\frac{2}{5}$。\n插值得到的值是：\n$$\nf^n(x_d) = (1-\\alpha) f_1^n + \\alpha f_2^n = \\left(1-\\frac{2}{5}\\right) \\frac{\\sqrt{2}}{2} + \\frac{2}{5}(1) = \\frac{3}{5}\\frac{\\sqrt{2}}{2} + \\frac{2}{5}\n$$\n$$\nf^n(x_d) = \\frac{3\\sqrt{2}}{10} + \\frac{4}{10} = \\frac{3\\sqrt{2} + 4}{10}\n$$\n\n**步骤3：隐式推进弛豫项**\n现在我们使用更新公式来计算 $f^{n+1}(x_3) = f_3^{n+1}$：\n$$\nf_3^{n+1} = \\frac{f^n(x_d) + \\nu \\Delta t f_{\\mathrm{eq}}(x_3)}{1 + \\nu \\Delta t}\n$$\n剩下的参数是：\n- 碰撞频率 $\\nu = 4.0 = 4$。\n- 平衡分布 $f_{\\mathrm{eq}}(x_3) = 0.25 = \\frac{1}{4}$。\n项 $\\nu \\Delta t$ 是：\n$$\n\\nu \\Delta t = 4 \\times 0.125 = 4 \\times \\frac{1}{8} = \\frac{1}{2}\n$$\n将所有值代入更新公式：\n$$\nf_3^{n+1} = \\frac{\\left(\\frac{3\\sqrt{2} + 4}{10}\\right) + \\left(\\frac{1}{2}\\right)\\left(\\frac{1}{4}\\right)}{1 + \\frac{1}{2}} = \\frac{\\frac{3\\sqrt{2} + 4}{10} + \\frac{1}{8}}{\\frac{3}{2}}\n$$\n我们通过寻找公分母 $40$ 来简化分子：\n$$\n\\frac{3\\sqrt{2} + 4}{10} + \\frac{1}{8} = \\frac{4(3\\sqrt{2} + 4)}{40} + \\frac{5}{40} = \\frac{12\\sqrt{2} + 16 + 5}{40} = \\frac{12\\sqrt{2} + 21}{40}\n$$\n现在，我们进行除法运算：\n$$\nf_3^{n+1} = \\frac{\\frac{12\\sqrt{2} + 21}{40}}{\\frac{3}{2}} = \\frac{12\\sqrt{2} + 21}{40} \\times \\frac{2}{3} = \\frac{12\\sqrt{2} + 21}{60}\n$$\n最后，我们可以从分子中提出因子 $3$：\n$$\nf_3^{n+1} = \\frac{3(4\\sqrt{2} + 7)}{60} = \\frac{4\\sqrt{2} + 7}{20}\n$$\n这就是 $f^{n+1}(x_3)$ 的最终精确解析表达式。",
            "answer": "$$\n\\boxed{\\frac{7 + 4\\sqrt{2}}{20}}\n$$"
        },
        {
            "introduction": "当我们对非线性动力学方程（例如包含复杂碰撞算符的方程）采用全隐式格式时，会遇到求解非线性代数方程组的挑战，而牛顿法是常用的迭代求解器。然而，标准的牛顿法迭代步可能会产生非物理的负值，导致求解器崩溃。本练习要求你分析并评估多种旨在保证分布函数非负性的策略，从而深入理解如何构建稳健的非线性求解器，并区分各种方法的优劣 。",
            "id": "3992632",
            "problem": "考虑一个用于计算聚变科学与工程的单物种速度空间分布函数 $f(v,t)$ 的非线性动理学方程，其中的碰撞由一个守恒、熵耗散的算子 $C[f]$ 建模。该算子满足玻尔兹曼H定理（Boltzmann $H$-theorem）：对于任意非负的 $f$，泛函 $H(f) = \\int f \\ln f \\, dv$ 在演化 $\\partial_t f = C[f]$ 下是非增的，并且 $C[f]$ 保持质量守恒。一个后向欧拉型的隐式时间更新通过求解\n$$\nf^{n+1} - f^n = \\Delta t \\, C[f^{n+1}],\n$$\n来寻找 $f^{n+1}$，这可以写成一个残差方程 $R(f^{n+1}) = f^{n+1} - f^n - \\Delta t \\, C[f^{n+1}] = 0$。牛顿迭代通过求解线性化系统来构造一个序列 $f^{(k)}$：\n$$\nJ(f^{(k)}) \\, \\delta f^{(k)} = - R(f^{(k)}), \\quad f^{(k+1)} = f^{(k)} + \\delta f^{(k)},\n$$\n其中 $J(f)$ 是 $R$ 在 $f$ 处的 Fréchet 导数。\n\n在许多用于聚变相关碰撞动力学的物理上自洽的 $C[f]$ 离散化方法中（例如，Fokker–Planck 或 Landau 算子的离散化），诸如扩散张量和摩擦项等系数泛函依赖于 $f$，并且仅当 $f \\ge 0$ 时才有良定义。此外，离散熵泛函包含诸如 $f \\ln f$ 的项，这些项在 $f \\le 0$ 时是未定义的。观察到，无阻尼的牛顿步长可能会产生在离散表示中具有负分量的迭代值 $f^{(k)}$，从而导致以下几种失效模式：\n- 违反了正性约束，导致系数变得不物理（例如，负扩散），并且雅可比矩阵 $J(f^{(k)})$ 失去单调性或变为不定矩阵；\n- 离散熵耗散失效，因为一旦 $f^{(k)}$ 的任何分量为非正值，$H(f^{(k)})$ 就不再有定义；\n- 由于离开了 $R$ 和 $J$ 光滑定义的域，牛顿迭代发散或停滞。\n\n假设一个具有 $N$ 个单元的速度网格，一个质量守恒的 $C[f]$ 离散化，以及一个时间步长 $\\Delta t$，该步长大到需要对碰撞进行隐式处理，但又小到足以期望一个精心设计的非线性求解器能够收敛。要求您分析在非线性求解过程中强制正性并以高精度恢复收敛性的方法。\n\n下列对牛顿迭代的修改中，哪些是既能强制 $f$ 的非负性、恢复收敛性，又能在渐近区域保持牛顿法对物理允许解的快速局部收敛性的可靠方法？\n\nA. 引入一个强制可行性条件和下降条件的回溯线搜索。将 $f^{(k+1)} = f^{(k)} + \\delta f^{(k)}$ 替换为 $f^{(k+1)} = f^{(k)} + \\lambda^{(k)} \\delta f^{(k)}$，其中选择 $\\lambda^{(k)} \\in (0,1]$ 以便对于一个小的 $\\epsilon > 0$，逐分量地满足 $f^{(k)} + \\lambda^{(k)} \\delta f^{(k)} \\ge \\epsilon$，并且满足关于残差范数或离散熵耗散的 Armijo 型条件。\n\nB. 进行非线性变量替换，换成熵变量 $u = \\ln f$，从而保证 $f = e^{u} \\ge 0$。将残差重写为 $\\widehat{R}(u) = R(e^{u})$，并在 $u$ 空间中应用牛顿法，即求解 $\\widehat{J}(u^{(k)}) \\, \\delta u^{(k)} = - \\widehat{R}(u^{(k)})$，其中 $u^{(k+1)} = u^{(k)} + \\delta u^{(k)}$，然后设置 $f^{(k+1)} = e^{u^{(k+1)}}$。\n\nC. 每次牛顿更新后，通过设置 $(f^{(k+1)})_i = \\max\\{(f^{(k+1)})_i,0\\}$ 来裁剪负分量，而在后续迭代中保持雅可比矩阵和残差的计算不变。\n\nD. 减小时间步长 $\\Delta t$ 直到无阻尼牛顿法不再产生负分量，而不改变更新规则或残差定义；即使 $\\Delta t$ 比原计划小几个数量级，也接受所得的解。\n\nE. 通过求解凸优化问题\n$$\n\\min_{g \\in \\mathbb{R}^N} \\frac{1}{2} \\| g - (f^{(k)} + \\delta f^{(k)}) \\|_{M}^2 \\quad \\text{subject to} \\quad g_i \\ge \\epsilon \\ \\text{for all} \\ i, \\quad \\sum_{i=1}^{N} w_i g_i = \\sum_{i=1}^{N} w_i f^{n},\n$$\n将暂定更新 $f^{(k)} + \\delta f^{(k)}$ 投影到强制离散非负性和质量守恒的可行集上，其中 $M$ 是与离散化相关的对称正定质量矩阵，$w_i$ 是求积权重。然后设置 $f^{(k+1)} = g$，并在 $f^{(k+1)}$ 处重新计算残差和雅可比矩阵。\n\n选择所有适用项。",
            "solution": "问题陈述经过了严格验证，被认为是有效的。它在计算科学与工程领域提出了一个良定的、有科学依据的、客观的问题，专门针对非线性动理学方程的数值解法。所描述的挑战——在基于牛顿法的隐式求解器中对分布函数强制正性——是该领域一个标准且重要的问题。该问题是自洽的，并为评估所提出的方法提供了足够的背景信息。\n\n任务是确定对于求解 $R(f) = f - f^n - \\Delta t \\, C[f] = 0$ 的牛顿迭代，哪些提议的修改是既能强制非负性（$f \\ge 0$）、保证收敛，又能渐近地保持牛顿法二次收敛率的可靠方法。\n\n让我们根据非线性方程和约束优化的数值分析既定原则来分析每个选项。\n\n**A. 引入一个回溯线搜索...**\n\n此选项提出了牛顿法的一种标准全局化策略，称为线搜索。更新公式从 $f^{(k+1)} = f^{(k)} + \\delta f^{(k)}$ 修改为 $f^{(k+1)} = f^{(k)} + \\lambda^{(k)} \\delta f^{(k)}$，其中 $\\lambda^{(k)} \\in (0,1]$ 是一个步长参数。\n\n1.  **强制非负性：** 选择步长 $\\lambda^{(k)}$ 以满足可行性条件。如果当前迭代值 $f^{(k)}$ 是正的，但暂定更新 $f^{(k)} + \\delta f^{(k)}$ 有负分量，可以找到一个更小的 $\\lambda^{(k)}$ 来确保正性。对于任何 $(\\delta f^{(k)})_i  0$ 的分量 $i$，必须满足条件 $(f^{(k)})_i + \\lambda^{(k)} (\\delta f^{(k)})_i \\ge \\epsilon$。这意味着 $\\lambda^{(k)} \\le \\frac{(f^{(k)})_i - \\epsilon}{-(\\delta f^{(k)})_i}$。通过在所有更新指向边界的分量上，取 $1$ 和这些上界（乘以一个小于 $1$ 的安全因子）的最小值，可以找到一个合适的 $\\lambda^{(k)}$。这系统地防止了迭代值变为非正。\n\n2.  **恢复收敛性：** 在解附近，牛顿方向 $\\delta f^{(k)}$ 是残差范数 $\\|R(f)\\|$ 的一个下降方向。Armijo型条件，通常写成 $\\|R(f^{(k)} + \\lambda^{(k)} \\delta f^{(k)})\\|^2 \\le (1 - 2\\alpha\\lambda^{(k)})\\|R(f^{(k)})\\|^2$ (对于某个 $\\alpha \\in (0, 1/2)$)，保证了每一步都使残差有足够的减小。这可以防止迭代发散，并使远离解的初始猜测也能实现全局收敛。使用离散熵作为评价函数也是一种有物理动机且强大的方法。\n\n3.  **保持渐近收敛性：** 当迭代值 $f^{(k)}$ 接近解时，完整的牛顿步长（$\\delta f^{(k)}$）会变小，也就不太可能违反正性。因此，线搜索将开始接受完整步长，即 $\\lambda^{(k)} \\rightarrow 1$。当 $\\lambda^{(k)} = 1$ 时，该方法恢复为纯牛顿法，具有二次局部收敛性。\n\n这是一种理论上合理且被广泛使用的方法。\n\n**结论：正确**\n\n**B. 进行非线性变量替换，换成熵变量 $u = \\ln f$...**\n\n该方法用一个新变量 $u$ 重新表述问题，其中 $u$ 和 $f$ 的关系为 $f = e^u$。\n\n1.  **强制非负性：** 指数函数的值域是 $(0, \\infty)$。通过将分布函数表示为 $f=e^u$，对于任何实值迭代量 $u^{(k)}$，非负性（实际上是正性，$f>0$）被自动地、无条件地满足。这巧妙地将 $f$ 上的约束问题转换为了 $u$ 上的无约束问题。\n\n2.  **恢复收敛性：** 牛顿迭代应用于变换后的残差方程 $\\widehat{R}(u) = R(e^u) = 0$。新的雅可比矩阵 $\\widehat{J}(u)$ 通过链式法则与原始雅可比矩阵 $J(f)$ 相关：$\\widehat{J}_{ij}(u) = \\sum_l \\frac{\\partial R_i}{\\partial f_l}\\Big|_{f=e^u} \\frac{\\partial f_l}{\\partial u_j}$。由于 $f_l = e^{u_l}$，我们有 $\\frac{\\partial f_l}{\\partial u_j} = \\delta_{lj} e^{u_l} = \\delta_{lj} f_l$。因此，$\\widehat{J}(u)=J(e^u) \\text{diag}(e^u)$。只要 $J(e^u)$ 是可逆的，牛顿步长就是良定义的。众所周知，变换到对数/熵变量通常可以改善问题的条件数和线性度，有助于收敛。\n\n3.  **保持渐近收敛性：** 应用于无约束问题 $\\widehat{R}(u)=0$ 的牛顿法将在 $u$ 变量上表现出二次收敛，即 $\\|u^{(k+1)} - u^*\\| = O(\\|u^{(k)}-u^*\\|^2)$，其中 $u^*$ 是解。由于当 $f>0$ 时变换 $f=e^u$ 是光滑且局部可逆的，因此 $u$ 的二次收敛意味着 $f$ 的二次收敛。在解 $f^* = e^{u^*}$ 附近，我们有 $\\|f^{(k+1)} - f^*\\| \\approx \\|e^{u^*} (u^{(k+1)} - u^*)\\| = O(\\|u^{(k+1)} - u^*\\|)$，这意味着收敛速度得以保持。\n\n这是一种非常优雅、有充分依据且具有物理动机的技术，有时被称为在“熵变量”中求解。\n\n**结论：正确**\n\n**C. 每次牛顿更新后，裁剪负分量...**\n\n此选项提出了一种临时性修复方法。在计算标准牛顿更新 $f_{temp} = f^{(k)} + \\delta f^{(k)}$ 后，简单地设置 $f^{(k+1)}_i = \\max\\{(f_{temp})_i, 0\\}$。\n\n1.  **强制非负性：** 根据定义，这个过程确保了 $f^{(k+1)}$ 的所有分量都是非负的。\n\n2.  **恢复收敛性：** 这是其致命弱点。裁剪操作是一种非线性且不可微的投影。得到的向量 $f^{(k+1)}$ 通常不再与线性化系统 $J(f^{(k)}) \\delta f^{(k)} = -R(f^{(k)})$ 的解相关。方向 $f^{(k+1)} - f^{(k)}$ 不是牛顿方向，也不能保证是残差的下降方向。这会严重阻碍甚至完全终止迭代的收敛。这是一种众所周知的“修复”方法，在实践中通常表现很差。\n\n3.  **保持渐近收敛性：** 该方法不再是牛顿法。一旦裁剪被激活（即使在靠近位于边界的解时也可能发生），更新就被篡改了。这种修改破坏了二次收敛的理论基础。充其量只能期望线性收敛，而且通常连线性收敛都达不到。\n\n在数值分析中，这种方法不被认为是“有充分依据的”，因为它缺乏可靠的收敛理论基础。\n\n**结论：错误**\n\n**D. 减小时间步长 $\\Delta t$ 直到...**\n\n这个选项建议改变问题本身。\n\n1.  **强制非负性：** 对于足够小的时间步长 $\\Delta t$，后向欧拉解 $f^{n+1}$ 非常接近 $f^n$。如果 $f^n$ 是一个有效的分布函数，它将成为牛顿迭代的一个极好的初始猜测。牛顿步长 $\\delta f^{(k)}$ 会很小，无阻尼方法 $f^{(k+1)} = f^{(k)} + \\delta f^{(k)}$ 很可能在不违反正性的情况下收敛。所以，这个过程可以得到一个正解。\n\n2.  **恢复收敛性：** 该方法并没有为原问题“恢复收敛性”。问题陈述明确假设“时间步长 $\\Delta t$ 大到需要隐式处理”。将 $\\Delta t$ 减小几个数量级意味着放弃了原来的、具有挑战性的问题，而去解决一个更容易的问题。开发鲁棒的隐式求解器的全部目的就是为了能够采用由精度要求决定的大时间步长，而不是受限于显式方法的稳定性或简单牛顿求解器的收敛域。\n\n3.  **保持渐近收敛性：** 对于*新的*、小的 $\\Delta t$，该方法就是标准的牛顿法，并将二次收敛。然而，它没能解决原定的问题。\n\n这是一种规避方法，而不是针对所提问题的解决技术。它牺牲了隐式格式的主要效率优势。\n\n**结论：错误**\n\n**E. 将暂定更新...投影到可行集上...**\n\n此选项描述了一种投影牛顿法。它将选项 C 中的粗糙裁剪形式化为一个有原则的、带约束的优化步骤。\n\n1.  **强制非负性：** 最小化问题的解 $g$ 被明确约束为对所有 $i$ 都有 $g_i \\ge \\epsilon$。因此，设置 $f^{(k+1)} = g$ 保证了所有迭代值都是正的。此外，这种方法可以同时强制其他关键的物理约束，如质量守恒（$\\sum w_i g_i = \\text{常数}$），这是一个显著的优势。\n\n2.  **恢复收敛性：** 这是约束非线性优化中的一种成熟技术。通过求解二次规划（QP）来找到投影，确保了每次迭代都保持在物理有效域内，在该域中残差 $R(f)$ 和雅可比矩阵 $J(f)$ 都有良定义。这可以防止求解器失效，并作为一种强大的全局化策略。该问题是一个凸二次规划（在凸集上最小化二次函数），可以被高效地求解。\n\n3.  **保持渐近收敛性：** 这类投影方法旨在保持快速的局部收敛性。如果解 $f^{n+1}$ 位于可行集的内部（即对所有 $i$ 都有 $(f^{n+1})_i > \\epsilon$），那么对于足够接近 $f^{n+1}$ 的迭代值 $f^{(k)}$，未投影的牛顿步长 $f^{(k)} + \\delta f^{(k)}$ 也将位于可行集内。在这种情况下，投影是单位算子（$g = f^{(k)} + \\delta f^{(k)}$），该方法就变成了标准的牛顿法，从而实现二次收敛。即使当解位于可行集的边界上时，这些方法在适当的条件下也可以实现超线性或二次收敛。\n\n这是一种复杂而鲁棒的方法，构成了解决此类问题的先进技术。\n\n**结论：正确**",
            "answer": "$$\\boxed{ABE}$$"
        },
        {
            "introduction": "许多聚变等离子体问题具有显著的多尺度特性，其中碰撞时间尺度远小于输运或加热的时间尺度（即 $\\epsilon \\ll 1$）。渐近保持（Asymptotic-Preserving, AP）格式专为此类问题设计，其时间步长仅受慢尺度物理过程的限制，从而极大地提高了模拟效率。本练习将引导你通过编程实现一个AP隐式-显式（IMEX）格式，并直接验证其在强刚性极限下的优越性 。通过该实践，你将直观地理解AP格式如何在宏观时间步长下准确捕捉系统演化，这是多尺度动力学模拟中的一个核心高级概念。",
            "id": "3992572",
            "problem": "考虑一个无量纲单位下，用于描述磁化聚变等离子体的空间均匀一维动力学Bhatnagar-Gross-Krook (BGK) 模型，其中粒子速度表示为 $v \\in \\mathbb{R}$，分布函数为 $f(v,t) \\ge 0$。带有刚性碰撞算子和外部施加的各向同性加热源的BGK模型为\n$$\n\\partial_t f(v,t) \\;=\\; \\frac{1}{\\epsilon}\\,\\big(M[n(t),T(t)](v) - f(v,t)\\big) \\;+\\; s(v,t),\n$$\n其中 $\\epsilon > 0$ 是（无量纲的）刚性参数，$M[n,T](v)$ 是密度为 $n$、温度为 $T$ 的一维麦克斯韦分布，$s(v,t)$ 是一个在不改变密度的情况下注入能量的源项。麦克斯韦分布定义为\n$$\nM[n,T](v) \\;=\\; \\frac{n}{\\sqrt{2\\pi T}}\\,\\exp\\!\\left(-\\frac{v^2}{2T}\\right).\n$$\n宏观矩由速度积分定义\n$$\nn(t) \\;=\\; \\int_{\\mathbb{R}} f(v,t)\\,dv, \\quad E(t) \\;=\\; \\int_{\\mathbb{R}} v^2\\,f(v,t)\\,dv, \\quad T(t) \\;=\\; \\frac{E(t)}{n(t)}.\n$$\n假设能量注入源具有以下特定形式\n$$\ns(v,t) \\;=\\; \\frac{q(t)}{2\\,T(t)^2}\\,\\big(v^2 - T(t)\\big)\\,M[n(t),T(t)](v),\n$$\n其中 $q(t)$ 是一个与 $\\epsilon$ 无关的给定标量加热率。该源满足两个与聚变加热的物理建模一致的性质：它保持密度，因为 $\\int_{\\mathbb{R}} s(v,t)\\,dv = 0$；它以 $n(t)\\,q(t)$ 的速率注入能量，因为 $\\int_{\\mathbb{R}} v^2\\,s(v,t)\\,dv = n(t)\\,q(t)$。\n\n您必须对刚性动力学方程应用渐近保持隐式-显式 (AP IMEX) 时间离散化，其中 $\\epsilon = 10^{-6}$，使用时间步长 $\\Delta t = O(1)$，以便在动力学误差对 $\\epsilon$ 保持一致有界的同时，正确捕捉密度和温度的宏观演化。使用以下一阶IMEX欧拉格式：对碰撞项进行隐式处理，对源项进行显式处理。用 $f^n(v) \\approx f(v, t^n)$ 表示，其中 $t^n = n\\,\\Delta t$。要实现的格式必须仅基于上述BGK模型和定义，不得引入任何非物理近似。\n\n您的程序必须使用在 $[-V_{\\max}, V_{\\max}]$ 上的均匀网格、梯形求积和无量纲单位来离散化速度积分，网格点数至少为 $2001$ 个。角度单位不适用。输出量必须是无量纲的。使用一个既保持密度又保持能量的微扰麦克斯韦分布来初始化分布函数，\n$$\nf^0(v) \\;=\\; M[n_0, T_0](v)\\,\\big(1 + \\delta\\,P_4(v;T_0)\\big),\n$$\n其中 $P_4(v;T) = \\frac{v^4 - 6 T v^2 + 3 T^2}{T^2}$，$\\delta$ 是一个小的无量纲振幅，其选择应使 $f^0(v) \\ge 0$。\n\n从第一性原理出发，推导由AP IMEX格式所蕴含的宏观更新，并以与动力学更新一致的方式实现它。通过 $L^2$ 范数在每个时间步量化动力学误差\n$$\n\\mathcal{E}^n \\;=\\; \\left(\\int_{\\mathbb{R}} \\big(f^n(v) - M[n^n,T^n](v)\\big)^2\\,dv\\right)^{1/2},\n$$\n该范数在相同的速度网格上进行数值计算。报告每个测试中所有时间步的最大动力学误差，即 $\\max_{0 \\le n \\le N}\\mathcal{E}^n$。\n\n测试套件：\n为以下参数集实现求解器：\n- 情况A（正常情况）：$\\epsilon = 10^{-6}$，$\\Delta t = 0.5$，$N = 10$ 步，$n_0 = 1.0$，$T_0 = 1.0$，$q(t) \\equiv 0.1$，$\\delta = 10^{-3}$，$V_{\\max} = 20$。\n- 情况B（大时间步长）：$\\epsilon = 10^{-6}$，$\\Delta t = 1.5$，$N = 10$ 步，$n_0 = 1.0$，$T_0 = 0.5$，$q(t) \\equiv 0.2$，$\\delta = 10^{-3}$，$V_{\\max} = 20$。\n- 情况C（零加热，边缘情况）：$\\epsilon = 10^{-6}$，$\\Delta t = 2.0$，$N = 10$ 步，$n_0 = 1.0$，$T_0 = 1.2$，$q(t) \\equiv 0.0$，$\\delta = 10^{-3}$，$V_{\\max} = 20$。\n\n对于每种情况，运行AP IMEX格式 $N$ 步并计算：\n- 无量纲单位下的最终宏观温度 $T^{N}$。\n- 无量纲单位下的最大动力学误差 $\\max_{0 \\le n \\le N}\\mathcal{E}^n$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按顺序为 $[T^{N}_{\\text{A}}, \\max \\mathcal{E}_{\\text{A}}, T^{N}_{\\text{B}}, \\max \\mathcal{E}_{\\text{B}}, T^{N}_{\\text{C}}, \\max \\mathcal{E}_{\\text{C}}]$。",
            "solution": "该问题是有效的，因为它提出了一个计算物理领域中适定且具有科学依据的任务。它要求为Bhatnagar-Gross-Krook (BGK) 动力学方程实现一种渐近保持 (AP) 隐式-显式 (IMEX) 数值格式，该方程是等离子体物理学中的一个标准模型。所有参数、初始条件和评估指标都已明确定义，问题没有矛盾或含糊之处。\n\n在此，我们推导指定的AP IMEX格式并详述其实现。控制动力学方程为：\n$$\n\\partial_t f(v,t) \\;=\\; \\frac{1}{\\epsilon}\\,\\big(M[n(t),T(t)](v) - f(v,t)\\big) \\;+\\; s(v,t)\n$$\n其中 $f(v,t)$ 是粒子分布函数，$\\epsilon$ 是刚性参数，$M[n,T](v)$ 是麦克斯韦分布，$s(v,t)$ 是一个能量注入源项。麦克斯韦分布定义为：\n$$\nM[n,T](v) \\;=\\; \\frac{n}{\\sqrt{2\\pi T}}\\,\\exp\\!\\left(-\\frac{v^2}{2T}\\right)\n$$\n宏观密度 $n(t)$ 和温度 $T(t)$ 是分布函数的矩：\n$$\nn(t) \\;=\\; \\int_{\\mathbb{R}} f(v,t)\\,dv, \\quad T(t) \\;=\\; \\frac{1}{n(t)}\\int_{\\mathbb{R}} v^2\\,f(v,t)\\,dv\n$$\n源项 $s(v,t)$ 由下式给出：\n$$\ns(v,t) \\;=\\; \\frac{q(t)}{2\\,T(t)^2}\\,\\big(v^2 - T(t)\\big)\\,M[n(t),T(t)](v)\n$$\n该源具有性质 $\\int_{\\mathbb{R}} s(v,t) \\,dv = 0$ 和 $\\int_{\\mathbb{R}} v^2 s(v,t) \\,dv = n(t)q(t)$。\n\n我们需要应用一阶IMEX欧拉格式，对刚性碰撞项进行隐式处理，对源项进行显式处理。设 $f^n(v) \\approx f(v, t^n)$，其中 $t^n = n\\Delta t$。离散化的方程为：\n$$\n\\frac{f^{n+1}(v) - f^n(v)}{\\Delta t} \\;=\\; \\frac{1}{\\epsilon}\\,\\big(M^{n+1}(v) - f^{n+1}(v)\\big) \\;+\\; s^n(v)\n$$\n其中 $s^n(v) = s(v, t^n; n^n, T^n)$ 且 $M^{n+1}(v) = M[n^{n+1}, T^{n+1}](v)$。矩 $n^{n+1}$ 和 $T^{n+1}$ 是从 $f^{n+1}(v)$ 计算得出的，这使得该格式是隐式的。为了高效求解，我们首先在代数上求解 $f^{n+1}(v)$：\n$$\nf^{n+1}(v) \\left(1 + \\frac{\\Delta t}{\\epsilon}\\right) \\;=\\; f^n(v) + \\Delta t \\, s^n(v) + \\frac{\\Delta t}{\\epsilon} M^{n+1}(v)\n$$\n$$\nf^{n+1}(v) \\;=\\; \\frac{f^n(v) + \\Delta t \\, s^n(v) + \\frac{\\Delta t}{\\epsilon} M^{n+1}(v)}{1 + \\frac{\\Delta t}{\\epsilon}}\n$$\n这是一个关于 $f^{n+1}(v)$ 的非线性方程，因为 $M^{n+1}(v)$ 依赖于其自身的矩。AP格式的关键在于通过对该表达式取矩来推导宏观更新方程。\n\n首先，我们对 $v$ 进行积分以求得密度的更新，$n^{n+1} = \\int_{\\mathbb{R}} f^{n+1}(v) \\,dv$。利用已知的矩性质 $\\int M^{n+1} dv = n^{n+1}$，$\\int s^n dv = 0$ 和 $\\int f^n dv = n^n$：\n$$\nn^{n+1} \\;=\\; \\frac{n^n + \\Delta t (0) + \\frac{\\Delta t}{\\epsilon} n^{n+1}}{1 + \\frac{\\Delta t}{\\epsilon}}\n$$\n$$\nn^{n+1} \\left(1 + \\frac{\\Delta t}{\\epsilon}\\right) \\;=\\; n^n + \\frac{\\Delta t}{\\epsilon} n^{n+1} \\quad\\implies\\quad n^{n+1} = n^n\n$$\n该格式精确地守恒密度，这是一个关键性质。这简化了问题，因为 $n^{n+1}$ 可由上一步得知。\n\n接下来，我们通过对 $\\int_{\\mathbb{R}} v^2 (\\cdot) \\,dv$ 积分来求得能量的更新。设 $E^n = n^n T^n$。源项的矩为 $\\int v^2 s^n dv = n^n q^n$。麦克斯韦分布的矩为 $\\int v^2 M^{n+1} dv = n^{n+1}T^{n+1}$。由于 $n^{n+1}=n^n$，该值为 $n^n T^{n+1}$。能量的更新为：\n$$\nE^{n+1} \\;=\\; \\frac{E^n + \\Delta t (n^n q^n) + \\frac{\\Delta t}{\\epsilon} (n^n T^{n+1})}{1 + \\frac{\\Delta t}{\\epsilon}}\n$$\n代入 $E^{n+1} = n^{n+1}T^{n+1} = n^n T^{n+1}$ 和 $E^n=n^n T^n$，并除以 $n^n$（非零）：\n$$\nT^{n+1} \\;=\\; \\frac{T^n + \\Delta t \\, q^n + \\frac{\\Delta t}{\\epsilon} T^{n+1}}{1 + \\frac{\\Delta t}{\\epsilon}}\n$$\n$$\nT^{n+1} \\left(1 + \\frac{\\Delta t}{\\epsilon}\\right) \\;=\\; T^n + \\Delta t \\, q^n + \\frac{\\Delta t}{\\epsilon} T^{n+1} \\quad\\implies\\quad T^{n+1} = T^n + \\Delta t \\, q^n\n$$\n这为温度提供了一个简单的显式更新法则。\n\nAP IMEX算法如下：\n1.  初始化 $f^0(v) = M[n_0, T_0](v)\\,\\big(1 + \\delta\\,P_4(v;T_0)\\big)$。\n2.  对每个时间步 $n = 0, 1, \\dots, N-1$：\n    a. 给定 $f^n(v)$，计算其矩 $n^n = \\int f^n dv$ 和 $T^n = (\\int v^2 f^n dv) / n^n$。\n    b. 预测下一步的宏观量：$n^{n+1} = n^n$ 和 $T^{n+1} = T^n + \\Delta t \\, q(t^n)$。\n    c. 基于预测的矩，构建麦克斯韦分布 $M^{n+1}(v) = M[n^{n+1}, T^{n+1}](v)$。\n    d. 基于第 $n$ 步的矩，构建源项 $s^n(v) = s(v, t^n)$。\n    e. 使用现在已是显式的公式更新分布函数：\n       $$\n       f^{n+1}(v) \\;=\\; \\frac{f^n(v) + \\Delta t \\, s^n(v) + \\frac{\\Delta t}{\\epsilon} M^{n+1}(v)}{1 + \\frac{\\Delta t}{\\epsilon}}\n       $$\n3.  循环结束后，最终温度 $T^N$ 通过最终分布 $f^N(v)$ 的矩计算得出。\n\n每个时间步 $n$ 的动力学误差计算为与相应麦克斯韦分布偏差的 $L^2$ 范数：\n$$\n\\mathcal{E}^n \\;=\\; \\left(\\int_{\\mathbb{R}} \\big(f^n(v) - M[n^n,T^n](v)\\big)^2\\,dv\\right)^{1/2}\n$$\n对于每个测试案例，报告在 $n = 0, \\dots, N$ 上的这些值的最大值。速度积分使用梯形法则在 $[-V_{\\max}, V_{\\max}]$ 上的均匀网格（包含 $2001$ 个点）上进行数值计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the BGK equation using an Asymptotic-Preserving IMEX scheme\n    for the specified test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case A (happy path)\n        {'eps': 1e-6, 'dt': 0.5, 'N_steps': 10, 'n0': 1.0, 'T0': 1.0, \n         'q_func': lambda t: 0.1, 'delta': 1e-3, 'Vmax': 20},\n        # Case B (large time step)\n        {'eps': 1e-6, 'dt': 1.5, 'N_steps': 10, 'n0': 1.0, 'T0': 0.5,\n         'q_func': lambda t: 0.2, 'delta': 1e-3, 'Vmax': 20},\n        # Case C (zero heating, edge case)\n        {'eps': 1e-6, 'dt': 2.0, 'N_steps': 10, 'n0': 1.0, 'T0': 1.2,\n         'q_func': lambda t: 0.0, 'delta': 1e-3, 'Vmax': 20},\n    ]\n\n    results = []\n    \n    # Use 2001 velocity grid points as specified\n    Nv = 2001\n\n    def maxwellian(v, n, T):\n        \"\"\"Computes the 1D Maxwellian distribution.\"\"\"\n        # Handle T=0 case to avoid division by zero, although not expected here\n        if T == 0:\n            # A delta function at v=0, approximated here\n            M = np.zeros_like(v)\n            center_idx = np.argmin(np.abs(v))\n            dv = v[1] - v[0]\n            M[center_idx] = n / dv\n            return M\n        return n / np.sqrt(2 * np.pi * T) * np.exp(-v**2 / (2 * T))\n\n    def p4_poly(v, T):\n        \"\"\"Computes the P4 polynomial.\"\"\"\n        if T == 0: return np.zeros_like(v)\n        return (v**4 - 6 * T * v**2 + 3 * T**2) / T**2\n\n    def source_term(v, n, T, q):\n        \"\"\"Computes the energy-injecting source term.\"\"\"\n        if T == 0: return np.zeros_like(v)\n        M = maxwellian(v, n, T)\n        return (q / (2 * T**2)) * (v**2 - T) * M\n\n    for case in test_cases:\n        eps = case['eps']\n        dt = case['dt']\n        N_steps = case['N_steps']\n        n0 = case['n0']\n        T0 = case['T0']\n        q_func = case['q_func']\n        delta = case['delta']\n        Vmax = case['Vmax']\n\n        # Set up the velocity grid\n        v = np.linspace(-Vmax, Vmax, Nv)\n\n        # Initialize the distribution function\n        f = maxwellian(v, n0, T0) * (1 + delta * p4_poly(v, T0))\n\n        kinetic_errors = []\n        \n        # Main time-stepping loop\n        for n in range(N_steps + 1):\n            # 1. Compute moments and kinetic error for the current distribution f^n\n            current_n = np.trapz(f, v)\n            current_E = np.trapz(v**2 * f, v)\n            current_T = current_E / current_n\n            \n            M_current = maxwellian(v, current_n, current_T)\n            error_sq = np.trapz((f - M_current)**2, v)\n            kinetic_errors.append(np.sqrt(error_sq))\n\n            # Stop after computing the final state at n = N_steps\n            if n == N_steps:\n                final_T = current_T\n                break\n\n            # 2. Predict macroscopic quantities for the next step\n            t_n = n * dt\n            q_n = q_func(t_n)\n            \n            next_n = current_n\n            next_T = current_T + dt * q_n\n            \n            # 3. Construct terms for the update\n            M_next = maxwellian(v, next_n, next_T)\n            S_n = source_term(v, current_n, current_T, q_n)\n            \n            # 4. Update the distribution function f to f^{n+1}\n            dt_over_eps = dt / eps\n            f = (f + dt * S_n + dt_over_eps * M_next) / (1 + dt_over_eps)\n\n        max_kinetic_error = max(kinetic_errors)\n        results.extend([final_T, max_kinetic_error])\n\n    print(f\"[{','.join(f'{r:.6e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}