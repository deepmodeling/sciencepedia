{
    "hands_on_practices": [
        {
            "introduction": "In marker-based delta-f simulations, the initial loading of computational markers is a critical step that dictates the quality of the subsequent evolution. A \"quiet start\" is essential to ensure that the initial marker distribution does not introduce spurious charge or current perturbations, which would otherwise excite large, unphysical transient fields. This practice explores a fundamental technique to achieve this by constructing velocity-symmetric marker pairs and adjusting their weights to simultaneously nullify the net charge and parallel current moments, as detailed in . Mastering this method is key to initializing clean simulations that accurately capture the intended physical dynamics from the very first time step.",
            "id": "4008329",
            "problem": "You are tasked to derive and implement a quiet-start loading scheme for the marker-based difference distribution function (delta-$f$) method in computational fusion science and engineering. In the marker-based delta-$f$ approach, the total distribution function is decomposed as $f = f_0 + \\delta f$, where $f_0$ is a known equilibrium and $\\delta f$ is a small perturbation represented by computational markers carrying weights. The goal of a quiet-start is to initialize markers such that the net perturbation charge and the net perturbation parallel current are both zero at $t=0$, minimizing unphysical transient fields.\n\nStart from the following fundamental base:\n\n- The kinetic description of a magnetized plasma along a guiding magnetic field direction is governed by the Vlasov equation for $f(\\boldsymbol{x},\\boldsymbol{v},t)$ coupled to the Maxwell equations. For the perturbation $\\delta f$, the charge density perturbation and parallel current perturbation are given by\n$$\\delta n(\\boldsymbol{x},t) = \\int \\delta f(\\boldsymbol{x},\\boldsymbol{v},t)\\,\\mathrm{d}^3 v,\\qquad \\delta j_{\\parallel}(\\boldsymbol{x},t) = \\int v_{\\parallel}\\,\\delta f(\\boldsymbol{x},\\boldsymbol{v},t)\\,\\mathrm{d}^3 v.$$\n- In a marker-based representation, with markers indexed by $p$ having parallel velocity $v_{\\parallel p}$ and weight $w_p$ sampling an equilibrium $f_0$, the discrete moments are approximated as\n$$\\delta n \\approx \\sum_{p} w_p,\\qquad \\delta j_{\\parallel} \\approx \\sum_{p} w_p\\, v_{\\parallel p}.$$\n- Therefore, a sufficient condition for a quiet-start is\n$$\\sum_{p} w_p = 0\\quad\\text{and}\\quad \\sum_{p} w_p\\, v_{\\parallel p} = 0.$$\n\nDesign a scheme that constructs velocity-symmetric pairs and assigns weights to ensure both constraints are satisfied. The scheme must be self-consistent and physically plausible. You may assume a one-dimensional parallel velocity space and that all markers are uniformly distributed in configuration space, so spatial shape functions do not bias the sums. The parallel velocity $v_{\\parallel}$ must be expressed in meters per second (m/s). The weights $w_p$ are dimensionless.\n\nYour derivation must show, from first principles and core definitions above, why symmetric pairing in $v_{\\parallel}$ and an appropriate choice of weights achieves $\\sum_{p} w_p = 0$ and $\\sum_{p} w_p v_{\\parallel p} = 0$, including a mathematically precise way to construct weights from an even target shape function of $v_{\\parallel}$ (for example, a function of $v_{\\parallel}^2$) and to enforce the zero-net-charge constraint without breaking the zero-current constraint.\n\nThen, implement a complete, runnable program that:\n\n- Constructs $M$ velocity-symmetric pairs $\\{\\pm v_i\\}_{i=1}^M$ for a specified thermal speed $v_{\\mathrm{th}}$ in $\\mathrm{m/s}$ using either a Gauss–Hermite node set or a uniform grid in $v_{\\parallel}$.\n- Computes pair-level weights $w_i$ from a chosen even amplitude function $a(v)$ and enforces the discrete zero-net-charge constraint by a mean-removal step on the set $\\{w_i\\}_{i=1}^M$ that does not violate the zero-current condition of each pair.\n- Assigns the same weight to both markers in a pair, i.e., $w_{(+v_i)} = w_{(-v_i)} = w_i$, and constructs the full marker set of size $2M$.\n- Reports the absolute value of the net charge moment $|\\sum_p w_p|$ (dimensionless) and the absolute value of the net current moment $\\left|\\sum_p w_p v_{\\parallel p}\\right|$ in $\\mathrm{m/s}$ for each test case.\n\nTest Suite:\n\nProvide the following test cases to exercise your implementation. For all cases, angles are not used, so no angle unit is required. Ensure scientific realism by using plausible thermal speeds.\n\n- Case $1$ (happy path): $M=10$, $v_{\\mathrm{th}} = 2.0\\times 10^{5}\\,\\mathrm{m/s}$, velocity grid type \"Hermite\" with $2M$ Gauss–Hermite nodes, amplitude $a(v) = \\varepsilon \\exp\\!\\left(-\\frac{v^2}{v_{\\mathrm{th}}^2}\\right)\\left(\\frac{v^2}{v_{\\mathrm{th}}^2} - 1\\right)$ with $\\varepsilon = 10^{-3}$.\n- Case $2$ (boundary with minimal pairs): $M=1$, $v_{\\mathrm{th}} = 3.0\\times 10^{5}\\,\\mathrm{m/s}$, velocity grid type \"Uniform\" on $[0, 2 v_{\\mathrm{th}}]$, amplitude $a(v) = \\varepsilon$ with $\\varepsilon = 10^{-2}$.\n- Case $3$ (nontrivial even tail shape): $M=7$, $v_{\\mathrm{th}} = 1.5\\times 10^{5}\\,\\mathrm{m/s}$, velocity grid type \"Hermite\" with $2M$ nodes, amplitude $a(v) = \\varepsilon \\left(1 + \\left(\\frac{v}{v_{\\mathrm{th}}}\\right)^4\\right)^{-1}$ with $\\varepsilon = 5\\times 10^{-4}$.\n- Case $4$ (larger dynamic range on uniform grid): $M=16$, $v_{\\mathrm{th}} = 4.0\\times 10^{5}\\,\\mathrm{m/s}$, velocity grid type \"Uniform\" on $[0, 4 v_{\\mathrm{th}}]$, amplitude $a(v) = \\varepsilon \\left(\\frac{v}{v_{\\mathrm{th}}}\\right)^2 \\exp\\!\\left(-\\frac{v}{v_{\\mathrm{th}}}\\right)$ with $\\varepsilon = 2\\times 10^{-3}$.\n\nAnswer Specification:\n\n- For each test case, compute two floats: $|\\sum_p w_p|$ (dimensionless) and $\\left|\\sum_p w_p v_{\\parallel p}\\right|$ in $\\mathrm{m/s}$.\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, in the order of the test cases and metrics, i.e., $[c_1, j_1, c_2, j_2, c_3, j_3, c_4, j_4]$ where $c_k$ is $|\\sum_p w_p|$ and $j_k$ is $\\left|\\sum_p w_p v_{\\parallel p}\\right|$ for case $k$.",
            "solution": "The problem requires the derivation and implementation of a quiet-start loading scheme for a marker-based delta-f ($\\delta f$) particle-in-cell algorithm. A quiet start is achieved by initializing the computational markers such that the net perturbation charge and net perturbation parallel current are both zero at the initial time, $t=0$. This minimizes the generation of spurious, unphysical fields at the beginning of a simulation.\n\nBased on the provided definitions, the discrete approximations for the perturbation charge density, $\\delta n$, and parallel current density, $\\delta j_{\\parallel}$, are given by the sums over all computational markers $p$:\n$$ \\delta n \\approx \\sum_{p} w_p $$\n$$ \\delta j_{\\parallel} \\approx \\sum_{p} w_p v_{\\parallel p} $$\nwhere $w_p$ is the weight of marker $p$ and $v_{\\parallel p}$ is its parallel velocity. The quiet-start conditions are thus the constraints that these two sums must be zero:\n$$ \\sum_{p} w_p = 0 \\quad (\\text{zero net charge}) $$\n$$ \\sum_{p} w_p v_{\\parallel p} = 0 \\quad (\\text{zero net current}) $$\n\nWe will now derive a constructive algorithm to generate a set of marker velocities $\\{v_{\\parallel p}\\}$ and weights $\\{w_p\\}$ that satisfy these two conditions simultaneously.\n\nThe core of the scheme is to construct the marker population from symmetric pairs in velocity space. Let the total number of markers be $2M$, composed of $M$ pairs. For each pair, indexed by $i$ (where $i$ ranges from $1$ to $M$), we define two markers, one with positive velocity and one with negative velocity.\n\nLet the set of base positive velocities be $\\{v_i\\}_{i=1}^M$, where each $v_i \\ge 0$. The $i$-th pair of markers will have velocities:\n$$ v_{\\parallel, i, +} = +v_i $$\n$$ v_{\\parallel, i, -} = -v_i $$\nTo satisfy the zero-current condition by construction, we assign the *same* weight to both markers within a given pair. Let this pair-level weight be denoted by $w_i$.\n$$ w_{i, +} = w_i $$\n$$ w_{i, -} = w_i $$\n\nLet us verify that this construction guarantees zero net parallel current. The total sum for the current can be grouped by pairs:\n$$ \\sum_{p} w_p v_{\\parallel p} = \\sum_{i=1}^{M} \\left( w_{i,+} v_{\\parallel, i, +} + w_{i,-} v_{\\parallel, i, -} \\right) $$\nSubstituting the definitions for the paired velocities and weights:\n$$ \\sum_{i=1}^{M} \\left( w_i (+v_i) + w_i (-v_i) \\right) = \\sum_{i=1}^{M} w_i (v_i - v_i) = \\sum_{i=1}^{M} (w_i \\cdot 0) = 0 $$\nThis demonstrates that the symmetric pairing of velocities $(\\pm v_i)$ with identical weights $(w_i)$ inherently satisfies the zero-current condition, irrespective of the specific values of $v_i$ and $w_i$. This holds true even in finite-precision arithmetic, as the cancellation $(v_i - v_i)$ is exact for each pair.\n\nNext, we address the zero-charge condition, $\\sum_{p} w_p = 0$. Using the same pair-based grouping:\n$$ \\sum_{p} w_p = \\sum_{i=1}^{M} (w_{i,+} + w_{i,-}) = \\sum_{i=1}^{M} (w_i + w_i) = 2 \\sum_{i=1}^{M} w_i $$\nFor the total charge to be zero, we must therefore enforce the condition on the pair-level weights:\n$$ \\sum_{i=1}^{M} w_i = 0 $$\n\nThe pair-level weights $w_i$ are determined based on a desired initial perturbation shape in velocity space, described by an amplitude function $a(v)$. For physical perturbations that are symmetric in velocity (e.g., heating), $a(v)$ would typically be an even function of $v$, such as a function of $v^2$. We first compute a set of \"raw\" weights, $w'_i$, by evaluating the amplitude function at the positive base velocities $v_i$:\n$$ w'_i = a(v_i) \\quad \\text{for } i=1, \\dots, M $$\nThe sum of these raw weights, $S = \\sum_{i=1}^{M} w'_i$, will not be zero in general.\n\nTo enforce the zero-sum constraint, we apply a mean-removal correction. We compute the mean of the raw weights:\n$$ \\bar{w}' = \\frac{1}{M} \\sum_{j=1}^{M} w'_j $$\nThe final pair-level weights $w_i$ are then obtained by subtracting this mean from each raw weight:\n$$ w_i = w'_i - \\bar{w}' $$\nLet us verify that this set of corrected weights sums to zero:\n$$ \\sum_{i=1}^{M} w_i = \\sum_{i=1}^{M} (w'_i - \\bar{w}') = \\left(\\sum_{i=1}^{M} w'_i\\right) - \\sum_{i=1}^{M} \\bar{w}' = (M\\bar{w}') - M\\bar{w}' = 0 $$\nThis procedure successfully produces a set of pair-level weights $\\{w_i\\}$ whose sum is zero (up to machine precision), thus satisfying the zero-charge condition $\\sum_p w_p = 0$. Since this adjustment is made to the pair-level weights $w_i$ before they are assigned to the $(\\pm v_i)$ markers, the symmetric structure that guarantees zero current is preserved. The scheme is therefore self-consistent.\n\nThe set of base positive velocities $\\{v_i\\}_{i=1}^M$ can be generated in several ways. The problem specifies two:\n1.  **Uniform Grid**: For a given velocity range, say $[0, v_{\\max}]$, and $M$ pairs, the velocities can be sampled uniformly. A robust method is to choose the centers of $M$ subintervals, i.e., $v_i = (i-0.5) \\frac{v_{\\max}}{M}$ for $i=1, \\dots, M$.\n2.  **Gauss-Hermite Grid**: The nodes of Gauss-Hermite quadrature are naturally suited for sampling functions against a Gaussian weight, common in plasma physics. For $2M$ total markers, one computes the $2M$ roots of the Hermite polynomial $H_{2M}(x)$. These roots are symmetric about $x=0$. We select the $M$ positive roots, $\\{x_j\\}_{j=1}^M$. These are then scaled by a characteristic thermal speed, $v_{\\mathrm{th}}$, to obtain physical velocities: $v_i = v_{\\mathrm{th}} x_i$. This method is particularly effective when the underlying distribution function $f_0$ is Maxwellian.\n\nIn summary, the algorithm is:\n1.  Choose the number of pairs, $M$.\n2.  Generate a set of $M$ positive velocities $\\{v_i\\}_{i=1}^M$ using a specified grid type.\n3.  Compute raw weights $\\{w'_i\\}_{i=1}^M$ using a given amplitude function $a(v)$, such that $w'_i = a(v_i)$.\n4.  Compute the mean of the raw weights, $\\bar{w}' = \\frac{1}{M}\\sum_i w'_i$.\n5.  Compute the final, corrected pair-level weights $w_i = w'_i - \\bar{w}'$.\n6.  Construct the full set of $2M$ markers as $\\{(\\pm v_i, w_i)\\}_{i=1}^M$. By construction, this set of markers has $\\sum_p w_p v_{\\parallel p} = 0$ and $\\sum_p w_p = 0$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom numpy.polynomial.hermite import hermgauss\n\ndef solve():\n    \"\"\"\n    Derives and implements a quiet-start loading scheme for a marker-based\n    delta-f algorithm, ensuring zero net charge and current perturbations.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"M\": 10,\n            \"v_th\": 2.0e5,\n            \"grid_type\": \"Hermite\",\n            \"grid_param\": None,  # Not used for Hermite\n            \"a_func\": lambda v, v_th, eps: eps * np.exp(-(v/v_th)**2) * ((v/v_th)**2 - 1),\n            \"epsilon\": 1e-3,\n        },\n        {\n            \"M\": 1,\n            \"v_th\": 3.0e5,\n            \"grid_type\": \"Uniform\",\n            \"grid_param\": 2.0,  # Grid range is [0, grid_param * v_th]\n            \"a_func\": lambda v, v_th, eps: eps * np.ones_like(v),\n            \"epsilon\": 1e-2,\n        },\n        {\n            \"M\": 7,\n            \"v_th\": 1.5e5,\n            \"grid_type\": \"Hermite\",\n            \"grid_param\": None,\n            \"a_func\": lambda v, v_th, eps: eps / (1 + (v/v_th)**4),\n            \"epsilon\": 5e-4,\n        },\n        {\n            \"M\": 16,\n            \"v_th\": 4.0e5,\n            \"grid_type\": \"Uniform\",\n            \"grid_param\": 4.0,\n            \"a_func\": lambda v, v_th, eps: eps * (v/v_th)**2 * np.exp(-v/v_th),\n            \"epsilon\": 2e-3,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        M = case[\"M\"]\n        v_th = case[\"v_th\"]\n        grid_type = case[\"grid_type\"]\n        grid_param = case[\"grid_param\"]\n        a_func = case[\"a_func\"]\n        epsilon = case[\"epsilon\"]\n\n        # Step 1: Construct M positive velocities {v_i}\n        if grid_type == \"Hermite\":\n            # hermgauss provides 2M symmetric roots for H_{2M}(x)\n            # Scaling for nodes is v = v_th * x, matching exp(-v^2/v_th^2) to exp(-x^2)\n            nodes, _ = hermgauss(2 * M)\n            # Take the M positive roots\n            positive_velocities = nodes[M:] * v_th\n        elif grid_type == \"Uniform\":\n            # Generate M points on [0, v_max] as cell centers\n            # This avoids v=0 and is more robust for M=1\n            v_max = grid_param * v_th\n            delta_v = v_max / M\n            indices = np.arange(1, M + 1)\n            positive_velocities = (indices - 0.5) * delta_v\n        \n        # Step 2: Compute raw pair-level weights w'_i\n        raw_weights = a_func(positive_velocities, v_th, epsilon)\n        \n        # Step 3: Enforce zero-net-charge via mean removal\n        if M > 0:\n            mean_raw_weight = np.mean(raw_weights)\n            final_pair_weights = raw_weights - mean_raw_weight\n        else: # Handle empty case\n            final_pair_weights = np.array([])\n\n        # Step 4: Construct the full marker set and calculate moments\n        # The full set consists of M pairs: (+v_i, w_i) and (-v_i, w_i)\n        \n        # Velocities: [+v_1, ..., +v_M, -v_1, ..., -v_M]\n        full_velocities = np.concatenate([positive_velocities, -positive_velocities])\n        \n        # Weights: [w_1, ..., w_M, w_1, ..., w_M]\n        full_weights = np.concatenate([final_pair_weights, final_pair_weights])\n\n        # Calculate net charge and current moments\n        # These should be zero up to machine precision\n        net_charge = np.sum(full_weights)\n        net_current = np.sum(full_weights * full_velocities)\n        \n        results.extend([abs(net_charge), abs(net_current)])\n\n    # Format and print the final output as a single line\n    print(f\"[{','.join(f'{r:.18e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This exercise provides hands-on experience in building a fundamental component of any Particle-in-Cell code: the electrostatic field solver. It guides you through discretizing the Poisson equation, $\\nabla^2 \\phi = -\\rho$, with finite differences, properly handling fixed potential (Dirichlet) boundary conditions, and constructing the source term from marker data . This skill is central to coupling the particle dynamics to the self-consistent evolution of the electric field that governs their motion.",
            "id": "4008354",
            "problem": "You are implementing an electrostatic field solve within a marker-based delta-f algorithm for a two-dimensional rectangular domain, using a uniform Cartesian mesh. In the electrostatic limit appropriate to low-frequency fusion plasma simulations, the governing field equation for the potential is obtained from Gauss's law of electrostatics and the definition of the electric field. Starting from the fundamental relations $ \\nabla \\cdot \\mathbf{E} = \\rho / \\varepsilon_0 $ and $ \\mathbf{E} = - \\nabla \\phi $, derive the discrete operator used to compute the potential field subject to fixed Dirichlet boundary conditions (fixed potentials on the domain boundary). The algorithm must deposit marker charges to the mesh using a linear Cloud-In-Cell shape and form a consistent right-hand side incorporating the boundary treatment.\n\nBegin from the following fundamental base:\n- $ \\nabla \\cdot \\mathbf{E} = \\rho / \\varepsilon_0 $ and $ \\mathbf{E} = - \\nabla \\phi $.\n- The Poisson equation in the electrostatic limit $ \\nabla^2 \\phi = - \\rho / \\varepsilon_0 $.\n- A uniform grid with spacings $ \\Delta x $ and $ \\Delta y $ and $ N_x $ and $ N_y $ nodes in the $ x $ and $ y $ directions, respectively.\n- Marker-based delta-f representation of the charge density in which markers with positions $(x_k, y_k)$ and weights $q_k$ represent the perturbation charge. Deposit to the mesh nodes using the two-dimensional Cloud-In-Cell (CIC) scheme.\n\nDiscretize the Poisson equation using second-order central differences on interior nodes only, and impose Dirichlet boundary conditions for $\\phi$ at the boundary nodes. Construct the modified discrete operator and the corresponding right-hand side such that boundary contributions are treated correctly as known values that influence the interior equations. Your derived operator must be symmetric and positive definite on the interior unknowns and must explicitly show how boundary potentials appear in the right-hand side.\n\nUse the following precise definitions and requirements:\n\n1. The discrete interior equation at node $(i,j)$ must be derived from $ \\nabla^2 \\phi = - \\rho / \\varepsilon_0 $ as a sum of one-dimensional second differences in $x$ and $y$, resulting in a linear system for interior nodes only. Use general spacings $\\Delta x$ and $\\Delta y$ without assuming they are equal. Show how terms involving boundary neighbors are moved to the right-hand side and contribute via known boundary potentials.\n\n2. For marker deposition, use the two-dimensional Cloud-In-Cell interpolation. For a marker at position $(x_k,y_k)$ with weight $q_k$, deposit to the four surrounding mesh nodes at indices $(i_\\ell, j_\\ell)$, $(i_r, j_\\ell)$, $(i_\\ell, j_r)$, and $(i_r, j_r)$ using weights\n   $$ w_{x,\\ell} = \\frac{x_{i_r} - x_k}{\\Delta x}, \\quad w_{x,r} = \\frac{x_k - x_{i_\\ell}}{\\Delta x}, \\quad w_{y,\\ell} = \\frac{y_{j_r} - y_k}{\\Delta y}, \\quad w_{y,r} = \\frac{y_k - y_{j_\\ell}}{\\Delta y}, $$\n   and add the contribution $ q_k \\, w_{x,\\alpha} \\, w_{y,\\beta} / (\\Delta x \\Delta y) $ to the charge density $\\rho$ at the corresponding node, for $\\alpha \\in \\{\\ell, r\\}$, $\\beta \\in \\{\\ell, r\\}$. Assume $\\varepsilon_0 = 1$ in normalized units, so $\\rho$ and $\\phi$ are dimensionless.\n\n3. Dirichlet boundary conditions specify fixed potentials on the domain boundary. In tests where different constant values are assigned to each side, define the corner values as equal to the left or right side values where applicable; that is, the left and right boundary values take precedence over top and bottom at corners so that $ \\phi(0,y) $ and $ \\phi(L_x,y) $ are enforced along the entire sides including corners.\n\n4. Implement the field solve using a sparse linear operator for the interior unknowns only. The discrete operator for interior nodes must have diagonal entries and off-diagonals consistent with the second-order central differences, and the right-hand side must include both the deposited $\\rho$ at interior nodes and the contributions from adjacent boundary potentials.\n\n5. Your program must produce numerical outputs for the specified test suite. Use normalized units (no physical units required) and express all numerical results as real numbers or booleans, without percentages or angles.\n\nTest Suite:\n- Case $ 1 $ (happy path): $ N_x = 21 $, $ N_y = 21 $, $ L_x = 1.0 $, $ L_y = 1.0 $, Dirichlet boundary potentials $ \\phi = 0 $ on all sides, no markers. Output the potential at the interior center node, the residual norm $ \\| A \\phi - b \\|_2 $, and whether the operator is (weakly) diagonally dominant at all rows as a boolean.\n- Case $ 2 $ (marker-driven): $ N_x = 21 $, $ N_y = 21 $, $ L_x = 1.0 $, $ L_y = 1.0 $, Dirichlet boundary potentials $ \\phi = 0 $ on all sides, one marker at $ (0.5, 0.5) $ with $ q = 1.0 $. Output the potential at the interior center node, the residual norm $ \\| A \\phi - b \\|_2 $, and the diagonally dominant boolean.\n- Case $ 3 $ (nonzero Dirichlet): $ N_x = 21 $, $ N_y = 21 $, $ L_x = 1.0 $, $ L_y = 1.0 $, Dirichlet boundary potentials $ \\phi(0,y) = 1.0 $, $ \\phi(L_x,y) = 0.0 $, $ \\phi(x,0) = 0.0 $, $ \\phi(x,L_y) = 0.0 $, no markers. Output the potential at the interior center node, the residual norm $ \\| A \\phi - b \\|_2 $, and the diagonally dominant boolean.\n- Case $ 4 $ (edge case): $ N_x = 3 $, $ N_y = 3 $, $ L_x = 1.0 $, $ L_y = 1.0 $, Dirichlet boundary potentials $ \\phi(0,y) = 1.0 $, $ \\phi(L_x,y) = 0.0 $, $ \\phi(x,0) = 0.0 $, $ \\phi(x,L_y) = 0.0 $, no markers. Output the potential at the single interior node, the residual norm $ \\| A \\phi - b \\|_2 $, and the diagonally dominant boolean.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case must produce a list of three items $ [\\text{center\\_phi}, \\text{residual\\_norm}, \\text{is\\_diag\\_dominant}] $, and the final line must be a list of these lists, for example $ [[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3],[a_4,b_4,c_4]] $.",
            "solution": "The problem requires the derivation and implementation of a two-dimensional electrostatic Poisson solver on a uniform Cartesian mesh, subject to fixed Dirichlet boundary conditions. The charge density is sourced by discrete macroparticles (markers) using a Cloud-In-Cell (CIC) deposition scheme. This is a standard component of marker-based delta-f Particle-In-Cell (PIC) algorithms used in computational fusion science.\n\nThe fundamental governing equations in the electrostatic limit are Gauss's law, $ \\nabla \\cdot \\mathbf{E} = \\rho / \\varepsilon_0 $, and the definition of the electrostatic potential, $ \\mathbf{E} = - \\nabla \\phi $. Combining these yields the Poisson equation:\n$$ \\nabla \\cdot (-\\nabla \\phi) = \\rho / \\varepsilon_0 \\implies \\nabla^2 \\phi = - \\frac{\\rho}{\\varepsilon_0} $$\nFor this problem, we operate in normalized units where the permittivity of free space $ \\varepsilon_0 = 1 $. The equation simplifies to:\n$$ \\nabla^2 \\phi = - \\rho $$\n\nThe solution is developed in three stages: first, the discretization of the Poisson equation on a uniform grid; second, the formulation of the linear system for the unknown interior potentials, correctly incorporating boundary conditions; and third, the method for computing the charge density source term $ \\rho $ from the particle data.\n\n**1. Discretization of the Poisson Equation**\n\nWe discretize the continuous domain into a uniform grid with $ N_x $ nodes in the x-direction and $ N_y $ nodes in the y-direction. The physical domain has lengths $ L_x $ and $ L_y $, so the grid spacings are $ \\Delta x = L_x / (N_x - 1) $ and $ \\Delta y = L_y / (N_y - 1) $. A grid function $ \\phi_{i,j} $ represents the potential $ \\phi $ at the node $ (x_i, y_j) = (i \\Delta x, j \\Delta y) $, for $ i \\in [0, N_x-1] $ and $ j \\in [0, N_y-1] $.\n\nThe Laplacian operator $ \\nabla^2 = \\partial^2/\\partial x^2 + \\partial^2/\\partial y^2 $ is approximated at an interior grid node $ (i,j) $ (where $ 1 \\le i \\le N_x-2 $ and $ 1 \\le j \\le N_y-2 $) using a second-order central finite difference scheme:\n$$ \\left. \\nabla^2 \\phi \\right|_{i,j} \\approx \\frac{\\phi_{i+1,j} - 2\\phi_{i,j} + \\phi_{i-1,j}}{(\\Delta x)^2} + \\frac{\\phi_{i,j+1} - 2\\phi_{i,j} + \\phi_{i,j-1}}{(\\Delta y)^2} $$\nSubstituting this into the Poisson equation $ \\nabla^2 \\phi = -\\rho $ gives the discrete equation at node $ (i,j) $:\n$$ \\frac{\\phi_{i+1,j} - 2\\phi_{i,j} + \\phi_{i-1,j}}{(\\Delta x)^2} + \\frac{\\phi_{i,j+1} - 2\\phi_{i,j} + \\phi_{i,j-1}}{(\\Delta y)^2} = -\\rho_{i,j} $$\nRearranging to group terms involving the potential at the central node $ (i,j) $:\n$$ \\left( \\frac{-2}{(\\Delta x)^2} - \\frac{2}{(\\Delta y)^2} \\right) \\phi_{i,j} + \\frac{1}{(\\Delta x)^2}\\phi_{i-1,j} + \\frac{1}{(\\Delta x)^2}\\phi_{i+1,j} + \\frac{1}{(\\Delta y)^2}\\phi_{i,j-1} + \\frac{1}{(\\Delta y)^2}\\phi_{i,j+1} = -\\rho_{i,j} $$\nTo form a linear system with a positive definite matrix, we multiply by $ -1 $:\n$$ \\left( \\frac{2}{(\\Delta x)^2} + \\frac{2}{(\\Delta y)^2} \\right) \\phi_{i,j} - \\frac{\\phi_{i-1,j}}{(\\Delta x)^2} - \\frac{\\phi_{i+1,j}}{(\\Delta x)^2} - \\frac{\\phi_{i,j-1}}{(\\Delta y)^2} - \\frac{\\phi_{i,j+1}}{(\\Delta y)^2} = \\rho_{i,j} $$\nThis equation defines a 5-point stencil relating the potential at a node to its four nearest neighbors and the local charge density.\n\n**2. Linear System Formulation for Interior Nodes**\n\nThe problem specifies Dirichlet boundary conditions, meaning the values of $ \\phi_{i,j} $ are fixed on the boundary nodes (i.e., for $ i=0 $, $ i=N_x-1 $, $ j=0 $, or $ j=N_y-1 $). The unknowns are the potentials at the $ N_{int} = (N_x-2) \\times (N_y-2) $ interior nodes. We construct a linear system $ A \\vec{\\phi}_{int} = \\vec{b} $, where $ \\vec{\\phi}_{int} $ is a vector of the unknown interior potentials.\n\nThe stencil equation is modified for nodes adjacent to the boundary. For such a node, one or more of its neighbors lie on the boundary, and the corresponding potential values are known. These known terms are moved to the right-hand side (RHS) of the equation. For example, for an interior node $ (1,j) $ adjacent to the left boundary $ i=0 $, the term $ - \\frac{\\phi_{0,j}}{(\\Delta x)^2} $ involves a known boundary value. The equation for this node becomes:\n$$ \\left( \\frac{2}{(\\Delta x)^2} + \\frac{2}{(\\Delta y)^2} \\right) \\phi_{1,j} - \\frac{\\phi_{2,j}}{(\\Delta x)^2} - \\frac{\\phi_{1,j-1}}{(\\Delta y)^2} - \\frac{\\phi_{1,j+1}}{(\\Delta y)^2} = \\rho_{1,j} + \\frac{\\phi_{0,j}}{(\\Delta x)^2} $$\nThe term $ \\frac{\\phi_{0,j}}{(\\Delta x)^2} $ is a contribution to the RHS vector $ \\vec{b} $.\n\nThe general form of the equation for an interior node $ (i,j) $ is:\n$$ \\left( \\frac{2}{(\\Delta x)^2} + \\frac{2}{(\\Delta y)^2} \\right) \\phi_{i,j} - \\sum_{(i',j') \\in \\text{int. neighbors}} C_{i',j'} \\phi_{i',j'} = \\rho_{i,j} + \\sum_{(i'',j'') \\in \\text{bnd. neighbors}} C_{i'',j''} \\phi_{i'',j''} $$\nwhere $ C $ are the coefficients $ (1/\\Delta x^2) $ or $ (1/\\Delta y^2) $. This structure defines the sparse matrix $ A $ and the RHS vector $ \\vec{b} $. The matrix $ A $ for the interior problem is symmetric and positive-definite, and also weakly diagonally dominant, ensuring a unique solution exists.\n\n**3. Marker Charge Deposition (Cloud-In-Cell)**\n\nThe charge density $ \\rho $ is calculated by depositing the charge from discrete markers onto the grid. For a marker $ k $ with position $ (x_k, y_k) $ and charge weight $ q_k $, the CIC scheme distributes its charge to the four nearest grid nodes that form a \"cell\" around it.\nLet the cell's lower-left node be $ (i_\\ell, j_\\ell) $, where $ i_\\ell = \\lfloor x_k / \\Delta x \\rfloor $ and $ j_\\ell = \\lfloor y_k / \\Delta y \\rfloor $. The other nodes are $ (i_r, j_\\ell) = (i_\\ell+1, j_\\ell) $, $ (i_\\ell, j_r) = (i_\\ell, j_\\ell+1) $, and $ (i_r, j_r) = (i_\\ell+1, j_\\ell+1) $.\nThe deposition is based on linear interpolation, with weights defined by the marker's relative position within the cell:\n$$ w_{x,r} = \\frac{x_k - x_{i_\\ell}}{\\Delta x}, \\quad w_{x,\\ell} = 1 - w_{x,r} $$\n$$ w_{y,r} = \\frac{y_k - y_{j_\\ell}}{\\Delta y}, \\quad w_{y,\\ell} = 1 - w_{y,r} $$\nThe charge is distributed as if it were a rectangular \"cloud\" of charge, with the fraction assigned to each node proportional to the area of the cloud overlapping the quadrant diagonally opposite to that node. The charge density contribution to the grid node $ (\\alpha_i, \\beta_j) $ where $ \\alpha \\in \\{\\ell, r\\} $ and $ \\beta \\in \\{\\ell, r\\} $ is:\n$$ \\Delta \\rho_{\\alpha_i, \\beta_j} = \\frac{q_k}{\\Delta x \\Delta y} w_{x, \\alpha'} w_{y, \\beta'} $$\nwhere $ \\alpha' $ is the opposite of $ \\alpha $ (i.e., if $ \\alpha_i=i_\\ell $, $ \\alpha'=\\ell $) and likewise for $ \\beta' $. The total charge density $ \\rho $ at each node is the sum of contributions from all markers.\n\nBy combining these three components—finite difference discretization, boundary condition treatment, and CIC charge deposition—a complete and solvable linear system is formed. Solving this system yields the potential field on the interior of the domain.",
            "answer": "```python\nimport numpy as np\nimport scipy.sparse\nimport scipy.sparse.linalg\n\ndef solve():\n    \"\"\"\n    Solves the 2D Poisson equation for specified test cases using a finite difference method.\n    \"\"\"\n    test_cases = [\n        {'Nx': 21, 'Ny': 21, 'Lx': 1.0, 'Ly': 1.0, 'bc': {'left': 0.0, 'right': 0.0, 'bottom': 0.0, 'top': 0.0}, 'markers': []},\n        {'Nx': 21, 'Ny': 21, 'Lx': 1.0, 'Ly': 1.0, 'bc': {'left': 0.0, 'right': 0.0, 'bottom': 0.0, 'top': 0.0}, 'markers': [{'x': 0.5, 'y': 0.5, 'q': 1.0}]},\n        {'Nx': 21, 'Ny': 21, 'Lx': 1.0, 'Ly': 1.0, 'bc': {'left': 1.0, 'right': 0.0, 'bottom': 0.0, 'top': 0.0}, 'markers': []},\n        {'Nx': 3, 'Ny': 3, 'Lx': 1.0, 'Ly': 1.0, 'bc': {'left': 1.0, 'right': 0.0, 'bottom': 0.0, 'top': 0.0}, 'markers': []},\n    ]\n\n    results = []\n\n    for params in test_cases:\n        Nx, Ny = params['Nx'], params['Ny']\n        Lx, Ly = params['Lx'], params['Ly']\n        bc, markers = params['bc'], params['markers']\n\n        dx = Lx / (Nx - 1)\n        dy = Ly / (Ny - 1)\n        dx2 = dx**2\n        dy2 = dy**2\n        \n        # Initialize potential and charge density grids\n        phi = np.zeros((Nx, Ny))\n        rho = np.zeros((Nx, Ny))\n\n        # Apply Dirichlet boundary conditions\n        phi[0, :] = bc['left']\n        phi[Nx-1, :] = bc['right']\n        phi[1:Nx-1, 0] = bc['bottom']\n        phi[1:Nx-1, Ny-1] = bc['top']\n\n        # Corner values: left/right precedence\n        phi[0, 0] = bc['left']\n        phi[0, Ny-1] = bc['left']\n        phi[Nx-1, 0] = bc['right']\n        phi[Nx-1, Ny-1] = bc['right']\n        \n        # Cloud-In-Cell (CIC) charge deposition\n        for marker in markers:\n            x_k, y_k, q_k = marker['x'], marker['y'], marker['q']\n            \n            i_l = int(x_k / dx)\n            j_l = int(y_k / dy)\n            i_r, j_r = i_l + 1, j_l + 1\n\n            if i_r >= Nx or j_r >= Ny: continue\n\n            x_i_l = i_l * dx\n            y_j_l = j_l * dy\n\n            w_x_r = (x_k - x_i_l) / dx\n            w_x_l = 1.0 - w_x_r\n            w_y_r = (y_k - y_j_l) / dy\n            w_y_l = 1.0 - w_y_r\n            \n            cell_vol = dx * dy\n            rho[i_l, j_l] += q_k * w_x_l * w_y_l / cell_vol\n            rho[i_r, j_l] += q_k * w_x_r * w_y_l / cell_vol\n            rho[i_l, j_r] += q_k * w_x_l * w_y_r / cell_vol\n            rho[i_r, j_r] += q_k * w_x_r * w_y_r / cell_vol\n\n        # Set up the linear system for interior nodes\n        Ni = Nx - 2\n        Nj = Ny - 2\n        N_int = Ni * Nj\n\n        if N_int == 0:\n            results.append([np.nan, 0.0, True]) # Trivial case\n            continue\n            \n        A = scipy.sparse.lil_matrix((N_int, N_int))\n        b = np.zeros(N_int)\n\n        for i in range(1, Nx - 1):\n            for j in range(1, Ny - 1):\n                k = (i - 1) * Nj + (j - 1)\n                \n                # Diagonal element\n                A[k, k] = 2.0/dx2 + 2.0/dy2\n                b[k] = rho[i,j]\n\n                # Neighbors\n                # West (i-1, j)\n                if i == 1:\n                    b[k] += phi[0, j] / dx2\n                else:\n                    A[k, k - Nj] = -1.0/dx2\n                \n                # East (i+1, j)\n                if i == Nx - 2:\n                    b[k] += phi[Nx - 1, j] / dx2\n                else:\n                    A[k, k + Nj] = -1.0/dx2\n\n                # South (i, j-1)\n                if j == 1:\n                    b[k] += phi[i, 0] / dy2\n                else:\n                    A[k, k - 1] = -1.0/dy2\n\n                # North (i, j+1)\n                if j == Ny - 2:\n                    b[k] += phi[i, Ny - 1] / dy2\n                else:\n                    A[k, k + 1] = -1.0/dy2\n        \n        A_csr = A.tocsr()\n        \n        # Check for weak diagonal dominance\n        diag_abs = np.abs(A_csr.diagonal())\n        A_abs_csr = A_csr.copy()\n        A_abs_csr.data = np.abs(A_abs_csr.data)\n        row_sums_abs = np.array(A_abs_csr.sum(axis=1)).flatten()\n        off_diag_sums = row_sums_abs - diag_abs\n        is_diag_dominant = np.all(diag_abs >= off_diag_sums)\n\n        # Solve the system\n        phi_int = scipy.sparse.linalg.spsolve(A_csr, b)\n        \n        # Calculate residual\n        residual_norm = np.linalg.norm(A_csr @ phi_int - b) if N_int > 0 else 0.0\n\n        # Unpack solution into full grid\n        for i in range(1, Nx - 1):\n            for j in range(1, Ny - 1):\n                k = (i - 1) * Nj + (j - 1)\n                phi[i, j] = phi_int[k]\n\n        # Get potential at center node\n        center_i = Nx // 2\n        center_j = Ny // 2\n        center_phi = phi[center_i, center_j]\n        \n        results.append([center_phi, residual_norm, bool(is_diag_dominant)])\n\n    # Format the final output string\n    formatted_results = []\n    for res in results:\n        # Convert boolean to lowercase 'true'/'false' for JSON-like format\n        res_str = f\"[{res[0]},{res[1]},{str(res[2]).lower()}]\"\n        formatted_results.append(res_str)\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This advanced practice demystifies the essential \"twist-shift\" boundary condition used in modern gyrokinetic codes that simulate plasma in sheared magnetic fields. By starting from the invariance of the field-line label $\\alpha$, you will derive and implement the coupled boundary mapping for the poloidal and binormal coordinates that is required in the ballooning representation . Successfully implementing this condition is a gateway to understanding how local flux-tube simulations can faithfully capture the physics of a global toroidal device.",
            "id": "4008405",
            "problem": "Consider a local, field-aligned flux-tube model for gyrokinetic (GK) simulations in a sheared slab approximation with binormal coordinate $y$, radial-like coordinate $x$, and poloidal angle coordinate $\\theta$. Let the magnetic shear be constant, denoted by $\\hat{s}$. In the ballooning representation, define the Clebsch-like label $\\alpha$ along a magnetic field line by the invariant combination\n$$\n\\alpha \\equiv y - \\hat{s}\\, x\\, \\theta,\n$$\nwhich is consistent with the property that the magnetic field $\\mathbf{B}$ satisfies $\\mathbf{B}\\cdot\\nabla \\alpha = 0$ in this local model and thus the label $\\alpha$ is constant along a field line. For a flux-tube simulation with the delta distribution function ($\\delta f$) represented by markers (hereafter \"delta-$f$ markers\"), one must construct boundary conditions that enforce periodicity in both $y$ and $\\theta$ while preserving the physical invariance implied by the ballooning representation.\n\nAssume the following:\n- The binormal coordinate $y$ lives in a periodic domain of length $L_y$, so $y \\in [0,L_y)$ and values are identified modulo $L_y$.\n- The poloidal angle coordinate $\\theta$ lives in a periodic domain with endpoints identified, here taken as $\\theta \\in [-\\Theta,\\Theta]$ with $\\Theta = \\pi$, and angles are in $\\mathrm{radians}$.\n- The delta-$f$ marker carries a constant weight $w$ that must not change when a boundary mapping is applied.\n\nStarting from fundamental geometric properties consistent with magnetized plasma theory and the ballooning representation, derive the boundary maps that must be applied to a marker $(x,y,\\theta)$ whenever it crosses the poloidal angle boundary at $\\theta = \\pm \\Theta$ so that the invariance of $\\alpha$ is enforced. Then, derive how the periodicity in $y$ is enforced by wrapping $y$ into $[0,L_y)$ and explain the role of the invariant $\\alpha$ under this wrap. Your derivation must begin from the definition of $\\alpha$ above and the requirement that $\\mathbf{B}\\cdot\\nabla \\alpha = 0$ in a local sheared slab, and it must not assume any shortcut boundary condition formulas not justified by those foundations.\n\nImplement a program that:\n1. Applies a generic phase-space increment $(\\delta y, \\delta \\theta)$ to a marker state $(x,y,\\theta)$.\n2. Enforces the poloidal boundary by repeatedly mapping across $\\theta = \\pm \\Theta$ with the minimally sufficient number of $2\\pi$ shifts in $\\theta$ and compensating shifts in $y$ that preserve the invariant $\\alpha$.\n3. Enforces the $y$ periodic boundary by wrapping $y$ modulo $L_y$ into $[0,L_y)$.\n4. Verifies the invariance of $\\alpha$ modulo $L_y$, i.e., computes the minimal absolute difference\n$$\n\\epsilon_\\alpha \\equiv \\min_{n \\in \\mathbb{Z}} \\left| \\left( \\alpha_{\\text{after}} - \\alpha_{\\text{before}} \\right) - n L_y \\right|,\n$$\nand also verifies the invariance of the delta-$f$ marker weight $w$ by computing\n$$\n\\epsilon_w \\equiv \\left| w_{\\text{after}} - w_{\\text{before}} \\right|.\n$$\nYour program must produce, for a small set of test cases, the pair $[\\epsilon_\\alpha,\\epsilon_w]$ for each case.\n\nAll angles must be expressed in $\\mathrm{radians}$. There are no other physical units required; coordinates and parameters are to be treated as dimensionless reals. The output values must be floating-point numbers.\n\nUse the following test suite of input parameter sets, each specified as $(x,y,\\theta,\\hat{s},L_y,\\delta\\theta,\\delta y,w)$:\n\n- Case $1$ (happy path with positive shear and upward poloidal crossing): $(x,y,\\theta,\\hat{s},L_y,\\delta\\theta,\\delta y,w) = (0.3,\\, 0.7 \\cdot 1.0,\\, 0.9\\pi,\\, 0.8,\\, 1.0,\\, 0.3\\pi,\\, 0.15,\\, 0.5)$.\n- Case $2$ (zero shear, near boundaries): $(x,y,\\theta,\\hat{s},L_y,\\delta\\theta,\\delta y,w) = (0.5,\\, 0.95 \\cdot 1.2,\\, -0.95\\pi,\\, 0.0,\\, 1.2,\\, 0.2\\pi,\\, 0.1,\\, 1.0)$.\n- Case $3$ (exact upper boundary crossing with small binormal increment): $(x,y,\\theta,\\hat{s},L_y,\\delta\\theta,\\delta y,w) = (0.25,\\, 0.99 \\cdot 0.8,\\, \\pi,\\, 0.7,\\, 0.8,\\, 0.1\\pi,\\, 0.02,\\, 0.25)$.\n- Case $4$ (negative $x$, downward poloidal crossing and large binormal increment causing wrap): $(x,y,\\theta,\\hat{s},L_y,\\delta\\theta,\\delta y,w) = (-0.4,\\, 0.1,\\, -0.99\\pi,\\, 0.6,\\, 1.0,\\, -0.2\\pi,\\, 1.3,\\, 0.75)$.\n- Case $5$ (large shear-induced shift requiring multiple wraps): $(x,y,\\theta,\\hat{s},L_y,\\delta\\theta,\\delta y,w) = (0.7,\\, 0.05,\\, 0.95\\pi,\\, 1.5,\\, 2.0,\\, 0.3\\pi,\\, 1.1,\\, 0.33)$.\n\nFor each case:\n- Compute $\\alpha_{\\text{before}} = y - \\hat{s}\\, x\\, \\theta$.\n- Apply the increments $(\\delta y,\\delta\\theta)$.\n- Enforce $\\theta$ periodicity by applying the minimal number of shifts $\\theta \\mapsto \\theta \\pm 2\\pi$ needed to bring $\\theta$ into $[-\\pi,\\pi]$, and for each such shift apply the compensating $y$ shift $y \\mapsto y \\pm 2\\pi\\, \\hat{s}\\, x$ that preserves $\\alpha$.\n- Enforce $y$ periodicity by wrapping $y$ into $[0,L_y)$ via $y \\mapsto y \\bmod L_y$.\n- Compute $\\alpha_{\\text{after}}$ and the errors $\\epsilon_\\alpha$ and $\\epsilon_w$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each element being the list $[\\epsilon_\\alpha,\\epsilon_w]$ for the corresponding test case in the order listed above. For example, the output format must be like $[ [a_1,b_1],[a_2,b_2],\\dots,[a_5,b_5] ]$ where each $a_i$ and $b_i$ are floating-point numbers.",
            "solution": "The problem requires the derivation and implementation of boundary conditions for a delta-$f$ marker in a sheared slab geometry, ensuring the correct transformation properties consistent with the ballooning representation.\n\nWe begin from the fundamental givens of the model. The coordinates are a radial-like coordinate $x$, a binormal coordinate $y$, and a poloidal angle coordinate $\\theta$. The magnetic shear, $\\hat{s}$, is constant. A key quantity in the ballooning representation is the Clebsch-like label $\\alpha$, defined as:\n$$\n\\alpha \\equiv y - \\hat{s}\\, x\\, \\theta\n$$\nThis label is an invariant along a magnetic field line, which is mathematically expressed as $\\mathbf{B}\\cdot\\nabla \\alpha = 0$ within this local model. Our task is to construct boundary mappings for $y$ and $\\theta$ that respect this invariance property. The marker weight, $w$, is constant under these geometric transformations.\n\n**1. Derivation of the Poloidal Angle Boundary Condition**\n\nThe poloidal angle $\\theta$ is defined in a periodic domain $\\theta \\in [-\\pi, \\pi]$. The physical space is continuous at the boundaries, meaning that the point at $\\theta = \\pi$ is identified with the point at $\\theta = -\\pi$. A particle trajectory that crosses the boundary at $\\theta = \\pi$ re-emerges at $\\theta = -\\pi$. This corresponds to a mapping in the unwrapped coordinate space of the form $\\theta \\mapsto \\theta \\pm 2\\pi$.\n\nLet a marker's state be $(x, y, \\theta)$. Consider a transformation where the poloidal angle is shifted by an integer multiple of $2\\pi$, representing $k$ full poloidal turns, where $k \\in \\mathbb{Z}$:\n$$\n\\theta' = \\theta + 2\\pi k\n$$\nThe coordinates $(x, y, \\theta)$ and $(x, y', \\theta')$ must represent the same physical state, which requires that the field-line label $\\alpha$ be preserved. Let $\\alpha_{\\text{old}}$ be the value before the transformation and $\\alpha_{\\text{new}}$ be the value after.\n$$\n\\alpha_{\\text{old}} = y - \\hat{s}\\, x\\, \\theta\n$$\n$$\n\\alpha_{\\text{new}} = y' - \\hat{s}\\, x\\, \\theta' = y' - \\hat{s}\\, x\\, (\\theta + 2\\pi k)\n$$\nFor $\\alpha$ to be invariant, we must have $\\alpha_{\\text{new}} = \\alpha_{\\text{old}}$:\n$$\ny' - \\hat{s}\\, x\\, (\\theta + 2\\pi k) = y - \\hat{s}\\, x\\, \\theta\n$$\n$$\ny' - \\hat{s}\\, x\\, \\theta - 2\\pi k \\hat{s}\\, x = y - \\hat{s}\\, x\\, \\theta\n$$\nSolving for $y'$, we find the necessary compensatory shift:\n$$\ny' = y + 2\\pi k \\hat{s}\\, x\n$$\nThus, the complete transformation for a poloidal wrap-around is:\n$$\n\\theta \\mapsto \\theta' = \\theta + 2\\pi k \\\\\ny \\mapsto y' = y + 2\\pi k \\hat{s}\\, x\n$$\nThis is the well-known \"twist-shift\" boundary condition. For a marker crossing the $\\theta$ boundary, we must identify the appropriate integer $k$ that maps its new $\\theta$ coordinate back into the principal domain $[-\\pi, \\pi]$ and apply the corresponding shift to $y$.\n\n**2. Derivation of the Binormal Boundary Condition and its effect on $\\alpha$**\n\nThe binormal coordinate $y$ is periodic in a domain of length $L_y$, i.e., $y \\in [0, L_y)$. A point at $y$ is physically identical to a point at $y + n L_y$ for any integer $n \\in \\mathbb{Z}$.\n\nLet's examine how this periodicity affects the invariant $\\alpha$. Consider a transformation that only shifts $y$ by an integer multiple of its period:\n$$\ny \\mapsto y' = y + n L_y\n$$\nThe new value of $\\alpha$ is:\n$$\n\\alpha' = y' - \\hat{s}\\, x\\, \\theta = (y + n L_y) - \\hat{s}\\, x\\, \\theta = (y - \\hat{s}\\, x\\, \\theta) + n L_y\n$$\n$$\n\\alpha' = \\alpha + n L_y\n$$\nThis demonstrates that $\\alpha$ is not strictly invariant under the periodicity in $y$. Instead, $\\alpha$ is conserved *modulo* $L_y$. Physical quantities must be periodic in $y$ with period $L_y$, which implies that the field-line labels themselves must exhibit a periodic structure with the same period. This is a fundamental consistency requirement of the flux-tube model.\n\n**3. Algorithmic Procedure and Invariance Verification**\n\nThe full algorithm to update a marker's state $(x, y, \\theta)$ after an increment $(\\delta y, \\delta \\theta)$ and verify the invariances is as follows:\n\nLet the initial state be $(x_0, y_0, \\theta_0, w_0)$, with parameters $\\hat{s}$ and $L_y$.\n\n1.  **Compute Initial Invariant**: Calculate $\\alpha_{\\text{before}} = y_0 - \\hat{s}\\, x_0\\, \\theta_0$. The initial weight is $w_{\\text{before}} = w_0$.\n\n2.  **Apply Generic Increment**: The marker's coordinates are updated by the given increments, which represent a generic displacement in phase space.\n    $$\n    y_1 = y_0 + \\delta y \\\\\n    \\theta_1 = \\theta_0 + \\delta \\theta\n    $$\n\n3.  **Enforce Poloidal Periodicity**: The new angle $\\theta_1$ must be mapped back to the principal domain $[-\\pi, \\pi]$. The new angle, $\\theta_2$, is found by finding the value in $[-\\pi,\\pi]$ that is equivalent to $\\theta_1$ up to a multiple of $2\\pi$. This can be computed via a modulo operation: $\\theta_2 = (\\theta_1 + \\pi) \\pmod{2\\pi} - \\pi$. The total angular shift due to this mapping is $\\Delta\\theta_{\\text{map}} = \\theta_2 - \\theta_1$. This shift must be a multiple of $2\\pi$, so $\\Delta\\theta_{\\text{map}} = 2\\pi k$ for some integer $k$. From our derivation, the corresponding shift in $y$ is $\\Delta y_{\\text{map}} = 2\\pi k \\hat{s}\\, x_0 = \\Delta\\theta_{\\text{map}} \\hat{s}\\, x_0$. The updated coordinates are:\n    $$\n    \\theta_2 = (\\theta_1 + \\pi) \\pmod{2\\pi} - \\pi \\\\\n    y_2 = y_1 + (\\theta_2 - \\theta_1) \\hat{s}\\, x_0\n    $$\n\n4.  **Enforce Binormal Periodicity**: The coordinate $y_2$ must be mapped to the domain $[0, L_y)$. This is achieved with a modulo operation:\n    $$\n    y_3 = y_2 \\pmod{L_y}\n    $$\n\n5.  **Final State and Invariants**: The final marker state is $(x_{\\text{after}}, y_{\\text{after}}, \\theta_{\\text{after}}, w_{\\text{after}}) = (x_0, y_3, \\theta_2, w_0)$.\n    The final invariant is $\\alpha_{\\text{after}} = y_3 - \\hat{s}\\, x_0\\, \\theta_2$.\n    The marker weight is unchanged by these geometric operations, so $w_{\\text{after}} = w_0$.\n\n6.  **Verify Invariances**:\n    *   The change in the marker weight is $\\epsilon_w = |w_{\\text{after}} - w_{\\text{before}}| = |w_0 - w_0| = 0$. This must be true to within floating-point precision.\n    *   The problem asks to compute $\\epsilon_\\alpha \\equiv \\min_{n \\in \\mathbb{Z}} | (\\alpha_{\\text{after}} - \\alpha_{\\text{before}}) - n L_y |$. This quantity measures the distance of the total change in $\\alpha$ to the nearest integer multiple of $L_y$. It is a check on the conservation of $\\alpha$ modulo $L_y$. In a numerically exact implementation, this value should correspond to the physical change in $\\alpha$ over the step, modulo $L_y$. The physical change over the increment is $\\Delta\\alpha_{\\text{phys}} = \\delta y - \\hat{s}\\, x_0\\, \\delta\\theta$. The combination of the coordinate update and boundary mappings ensures that $(\\alpha_{\\text{after}} - \\alpha_{\\text{before}}) \\pmod{L_y}$ is equivalent to $\\Delta\\alpha_{\\text{phys}} \\pmod{L_y}$. The value $\\epsilon_\\alpha$ will thus be non-zero in general, reflecting this physical change, but its computation through the full coordinate mapping should be self-consistent and free of numerical artifacts from the boundary implementation itself. The most robust way to calculate $\\epsilon_\\alpha$ for a difference $\\Delta\\alpha = \\alpha_{\\text{after}} - \\alpha_{\\text{before}}$ is by finding the remainder in a symmetric interval around zero, e.g., $\\epsilon_\\alpha = |(\\Delta\\alpha + L_y/2) \\pmod{L_y} - L_y/2|$.\n\nThis completes the derivation of the principles and the algorithm for implementation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the marker boundary condition problem for a set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is (x, y, theta, s_hat, L_y, d_theta, d_y, w)\n    test_cases = [\n        (0.3, 0.7 * 1.0, 0.9 * np.pi, 0.8, 1.0, 0.3 * np.pi, 0.15, 0.5),\n        (0.5, 0.95 * 1.2, -0.95 * np.pi, 0.0, 1.2, 0.2 * np.pi, 0.1, 1.0),\n        (0.25, 0.99 * 0.8, np.pi, 0.7, 0.8, 0.1 * np.pi, 0.02, 0.25),\n        (-0.4, 0.1, -0.99 * np.pi, 0.6, 1.0, -0.2 * np.pi, 1.3, 0.75),\n        (0.7, 0.05, 0.95 * np.pi, 1.5, 2.0, 0.3 * np.pi, 1.1, 0.33),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        x, y_before, theta_before, s_hat, L_y, d_theta, d_y, w = case\n        \n        # The marker weight `w` is invariant under coordinate transformations.\n        w_before = w\n        w_after = w\n        \n        # 1. Compute initial alpha invariant\n        alpha_before = y_before - s_hat * x * theta_before\n        \n        # 2. Apply generic increments\n        y_intermediate = y_before + d_y\n        theta_intermediate = theta_before + d_theta\n        \n        # 3. Enforce poloidal periodicity (theta in [-pi, pi])\n        # The new angle is wrapped into the principal domain.\n        theta_after = (theta_intermediate + np.pi) % (2.0 * np.pi) - np.pi\n        \n        # The total change in theta due to wrapping is a multiple of 2*pi.\n        theta_shift = theta_after - theta_intermediate\n        \n        # Apply the compensating \"twist-shift\" to y to preserve alpha.\n        y_after_theta_bc = y_intermediate + theta_shift * s_hat * x\n        \n        # 4. Enforce binormal periodicity (y in [0, L_y))\n        y_after = y_after_theta_bc % L_y\n        \n        # 5. Compute final alpha invariant\n        alpha_after = y_after - s_hat * x * theta_after\n        \n        # 6. Verify invariances\n        \n        # Calculate the error in w invariance\n        epsilon_w = abs(w_after - w_before)\n        \n        # Calculate the minimal absolute difference for alpha modulo L_y.\n        # This measures the distance of the total change in alpha to the nearest\n        # integer multiple of L_y.\n        alpha_diff = alpha_after - alpha_before\n        \n        # A robust way to compute `min |alpha_diff - n*L_y|` is to find the\n        # remainder in a symmetric interval [-L_y/2, L_y/2].\n        epsilon_alpha = abs((alpha_diff + L_y / 2.0) % L_y - L_y / 2.0)\n        \n        results.append([epsilon_alpha, epsilon_w])\n\n    # Final print statement in the exact required format.\n    # The list comprehension formats each inner list [a, b] into a string \"[a,b]\".\n    # The outer join then combines them with commas.\n    print(f\"[{','.join([str(r) for r in results])}]\")\n\nsolve()\n```"
        }
    ]
}