{
    "hands_on_practices": [
        {
            "introduction": "在粒子模拟（PIC）中，驱动准中性方程的电荷密度由于有限的粒子统计而具有内禀噪声。本练习提供了一种从第一性原理估计这种噪声水平的方法。通过量化由粒子采样引起的预期误差，您可以设定一个合理的求解器收敛容差，避免在追逐统计涨落上浪费宝贵的计算资源。",
            "id": "4035301",
            "problem": "您的任务是，在计算聚变科学与工程领域，形式化随机粒子采样对拟中性求解器停止准则的影响。考虑一个基于网格的拟中性方程求解器，其右端项由通过“单元内粒子”（Particle-In-Cell, PIC）沉积计算出的净电荷密度构成。计算域被划分为 $N_G$ 个等体积的单元，每个单元的体积为 $\\Delta V$。两种粒子对净电荷密度有贡献：电子和一种离子。每种粒子 $s \\in \\{\\mathrm{e}, \\mathrm{i}\\}$ 由 $N_{p,s}$ 个数值标记（粒子）表示，每个标记承载一个恒定的权重 $w_s$，以使得在沉积过程中能够恢复期望的单元平均物理密度 $n_s$。假设如下：\n- 粒子位置在整个网格上进行均匀且独立的采样，因此每个单元内的标记数量可以很好地用一个泊松随机变量来建模，其均值为 $\\lambda_s = N_{p,s} / N_G$（对于粒子种类 $s$）。\n- PIC 沉积使用最近邻网格点形函数，使得每个标记的全部权重都贡献给唯一一个单元。由粒子种类 $s$ 在一个单元中产生的净电荷密度计算为 $\\hat{\\rho}_s = \\frac{q_s}{\\Delta V} \\sum_{j=1}^{N_{i,s}} w_s$，其中 $q_s$ 是该种类粒子的电荷，$\\Delta V$ 是单元体积，$N_{i,s}$ 是该单元中种类为 $s$ 的随机标记计数。一个单元中的总净电荷密度为 $\\hat{b} = \\hat{\\rho}_{\\mathrm{i}} + \\hat{\\rho}_{\\mathrm{e}}$。\n- 线性拟中性求解以离散形式写作 $A \\phi = b$，其中 $A$ 是一个对称正定算子，源于场方程的离散化（例如，一个广义泊松算子），$\\phi$ 是未知势，而 $b$ 是所有单元上的真实净电荷密度矢量。在某次迭代 $\\phi_{\\mathrm{iter}}$ 中，求解器的残差为 $r = \\hat{b} - A \\phi_{\\mathrm{iter}}$。\n\n从每个单元粒子计数的独立泊松统计、独立和的方差线性性质，以及大 $N_{p,s}$ 下的中心极限定理近似这些基本原理出发，执行以下操作：\n1. 推导由粒子采样噪声引起的单位单元净电荷密度 $\\hat{b}$ 的方差，将其表示为 $N_G$、$N_{p,\\mathrm{e}}$、$N_{p,\\mathrm{i}}$、$n_{\\mathrm{e}}$、$n_{\\mathrm{i}}$、$q_{\\mathrm{e}}$ 和 $q_{\\mathrm{i}}$ 的函数。在您的推导中，使用为恢复期望密度而选择的恒定粒子权重来表达。\n2. 使用第1部分的结果，并假设不同单元间的噪声是独立同分布的，推导求解器残差的 $2$-范数的期望大小的表达式，该期望大小仅由采样噪声引起，即误差矢量 $e = \\hat{b} - b$ 的典型大小 $\\| e \\|_2$。\n3. 为避免对噪声过拟合，为残差的 $2$-范数定义一个绝对求解器容差 $\\tau$，使得当 $\\| r \\|_2 \\le \\tau$ 时求解器停止。使用一个保守的双标准差准则，设 $\\tau = k \\sqrt{\\mathbb{E}[\\|e\\|_2^2]}$，其中 $k=2$。提供 $\\tau$ 的最终公式，单位为库仑/立方米（$\\mathrm{C/m^3}$）。\n\n您的程序必须实现所推导的公式，并为以下一系列科学上合理的参数集计算 $\\tau$。在每种情况下，使用元电荷 $e_0 = 1.602176634 \\times 10^{-19}$ 库仑：\n- 测试用例1（平衡类氘等离子体）：$N_G = 64$，$N_{p,\\mathrm{e}} = 5 \\times 10^6$，$N_{p,\\mathrm{i}} = 5 \\times 10^6$，$n_{\\mathrm{e}} = 5.0 \\times 10^{19}\\,\\mathrm{m^{-3}}$，$n_{\\mathrm{i}} = 5.0 \\times 10^{19}\\,\\mathrm{m^{-3}}$，$q_{\\mathrm{e}} = -e_0$，$q_{\\mathrm{i}} = +e_0$，$k = 2$。\n- 测试用例2（双电荷离子，密度已调整）：$N_G = 128$，$N_{p,\\mathrm{e}} = 1.0 \\times 10^7$，$N_{p,\\mathrm{i}} = 2.5 \\times 10^6$，$n_{\\mathrm{e}} = 5.0 \\times 10^{19}\\,\\mathrm{m^{-3}}$，$n_{\\mathrm{i}} = 2.5 \\times 10^{19}\\,\\mathrm{m^{-3}}$，$q_{\\mathrm{e}} = -e_0$，$q_{\\mathrm{i}} = +2 e_0$，$k = 2$。\n- 测试用例3（边界情况，极少标记和单单元）：$N_G = 1$，$N_{p,\\mathrm{e}} = 1.0 \\times 10^3$，$N_{p,\\mathrm{i}} = 1.0 \\times 10^3$，$n_{\\mathrm{e}} = 1.0 \\times 10^{19}\\,\\mathrm{m^{-3}}$，$n_{\\mathrm{i}} = 1.0 \\times 10^{19}\\,\\mathrm{m^{-3}}$，$q_{\\mathrm{e}} = -e_0$，$q_{\\mathrm{i}} = +e_0$，$k = 2$。\n\n角度单位不适用。本问题不涉及百分比。请将最终的求解器容差值以 $\\mathrm{C/m^3}$ 为单位表示。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3]”）。每个结果必须是一个十进制表示的浮点数，代表相应测试用例的 $\\tau$ 值，单位为 $\\mathrm{C/m^3}$。",
            "solution": "该问题要求为拟中性求解器推导一个基于统计的停止准则，该准则考虑了来自“单元内粒子”（PIC）电荷沉积的噪声。推导过程分为三个部分：首先，确定单个计算单元中采样电荷密度的方差；其次，将其扩展到整个网格，求出电荷密度误差矢量的平方 $2$-范数的期望值；第三，基于此期望误差构建求解器容差。\n\n基本假设是，每种粒子 $s \\in \\{\\mathrm{e}, \\mathrm{i}\\}$ 的数值标记（粒子）在整个计算域内是独立且均匀分布的。计算域由 $N_G$ 个单元组成，每个单元的体积为 $\\Delta V$。种类为 $s$ 的标记总数为 $N_{p,s}$。因此，在任何给定单元中找到的种类为 $s$ 的标记数（记为 $N_{i,s}$）是一个服从泊松分布的随机变量，其均值为 $\\lambda_s = N_{p,s} / N_G$。泊松分布变量的方差等于其均值，因此 $\\mathrm{Var}(N_{i,s}) = \\lambda_s$。\n\n种类为 $s$ 的每个标记都带有一个恒定的权重 $w_s$。该权重是通过要求期望的粒子沉积能够恢复已知的平均物理数密度 $n_s$ 来确定的。在模拟体积 $V_{\\mathrm{total}} = N_G \\Delta V$ 中，种类为 $s$ 的物理粒子总数为 $n_s N_G \\Delta V$。这必须等于由标记所代表的物理粒子总数，即 $N_{p,s} w_s$。将两者相等，可得到粒子权重的表达式：\n$$\nw_s = \\frac{n_s N_G \\Delta V}{N_{p,s}}\n$$\n单元中种类为 $s$ 的采样电荷密度由 $\\hat{\\rho}_s = \\frac{q_s}{\\Delta V} \\sum_{j=1}^{N_{i,s}} w_s$ 给出。由于 $w_s$ 是常数，这可以简化为：\n$$\n\\hat{\\rho}_s = \\frac{q_s w_s N_{i,s}}{\\Delta V}\n$$\n其中 $q_s$ 是种类为 $s$ 的物理粒子的电荷。\n\n**第1部分：单位单元净电荷密度的方差**\n\n种类为 $s$ 的采样电荷密度的期望值为：\n$$\n\\mathbb{E}[\\hat{\\rho}_s] = \\mathbb{E}\\left[\\frac{q_s w_s N_{i,s}}{\\Delta V}\\right] = \\frac{q_s w_s}{\\Delta V} \\mathbb{E}[N_{i,s}] = \\frac{q_s w_s \\lambda_s}{\\Delta V}\n$$\n代入 $w_s$ 和 $\\lambda_s$ 的表达式：\n$$\n\\mathbb{E}[\\hat{\\rho}_s] = \\frac{q_s}{\\Delta V} \\left(\\frac{n_s N_G \\Delta V}{N_{p,s}}\\right) \\left(\\frac{N_{p,s}}{N_G}\\right) = q_s n_s\n$$\n这证实了采样密度是真实电荷密度 $q_s n_s$ 的无偏估计量。\n\n$\\hat{\\rho}_s$ 的方差使用性质 $\\mathrm{Var}(cX) = c^2 \\mathrm{Var}(X)$ 计算：\n$$\n\\mathrm{Var}(\\hat{\\rho}_s) = \\mathrm{Var}\\left(\\frac{q_s w_s N_{i,s}}{\\Delta V}\\right) = \\left(\\frac{q_s w_s}{\\Delta V}\\right)^2 \\mathrm{Var}(N_{i,s}) = \\left(\\frac{q_s w_s}{\\Delta V}\\right)^2 \\lambda_s\n$$\n再次代入 $w_s$ 和 $\\lambda_s$：\n$$\n\\mathrm{Var}(\\hat{\\rho}_s) = \\left(\\frac{q_s}{\\Delta V} \\frac{n_s N_G \\Delta V}{N_{p,s}}\\right)^2 \\left(\\frac{N_{p,s}}{N_G}\\right) = \\left(\\frac{q_s n_s N_G}{N_{p,s}}\\right)^2 \\frac{N_{p,s}}{N_G} = \\frac{q_s^2 n_s^2 N_G}{N_{p,s}}\n$$\n单元中的净电荷密度为 $\\hat{b} = \\hat{\\rho}_{\\mathrm{e}} + \\hat{\\rho}_{\\mathrm{i}}$。由于电子和离子粒子布居是独立采样的，它们和的方差是它们方差的和：\n$$\n\\sigma_b^2 \\equiv \\mathrm{Var}(\\hat{b}) = \\mathrm{Var}(\\hat{\\rho}_{\\mathrm{e}}) + \\mathrm{Var}(\\hat{\\rho}_{\\mathrm{i}}) = \\frac{q_{\\mathrm{e}}^2 n_{\\mathrm{e}}^2 N_G}{N_{p,\\mathrm{e}}} + \\frac{q_{\\mathrm{i}}^2 n_{\\mathrm{i}}^2 N_G}{N_{p,\\mathrm{i}}}\n$$\n这可以因式分解为：\n$$\n\\sigma_b^2 = N_G \\left(\\frac{q_{\\mathrm{e}}^2 n_{\\mathrm{e}}^2}{N_{p,\\mathrm{e}}} + \\frac{q_{\\mathrm{i}}^2 n_{\\mathrm{i}}^2}{N_{p,\\mathrm{i}}}\\right)\n$$\n该表达式给出了单个单元中由粒子采样噪声引起的净电荷密度的方差。\n\n**第2部分：残差范数的期望大小**\n\n误差矢量 $e$ 定义为 $e = \\hat{b} - b$，其中 $\\hat{b}$ 是所有 $N_G$ 个单元上的采样电荷密度矢量，$b$ 是真实电荷密度矢量。单个单元 $j$ 中的误差是 $e_j = \\hat{b}_j - b_j$。由于 $\\mathbb{E}[\\hat{b}_j] = q_{\\mathrm{e}} n_{\\mathrm{e}} + q_{\\mathrm{i}} n_{\\mathrm{i}} = b_j$，误差的均值为零，即 $\\mathbb{E}[e_j] = 0$。一个单元中误差的方差是 $\\mathrm{Var}(e_j) = \\mathrm{Var}(\\hat{b}_j) = \\sigma_b^2$。\n\n问题要求的是由噪声引起的求解器残差 $2$-范数的期望大小，其特征是 $\\mathbb{E}[\\|e\\|_2^2]$。误差矢量 $e$ 的平方 $2$-范数是 $\\|e\\|_2^2 = \\sum_{j=1}^{N_G} e_j^2$。\n利用期望的线性性质：\n$$\n\\mathbb{E}[\\|e\\|_2^2] = \\mathbb{E}\\left[\\sum_{j=1}^{N_G} e_j^2\\right] = \\sum_{j=1}^{N_G} \\mathbb{E}[e_j^2]\n$$\n对于一个均值为零的随机变量 $X$，有 $\\mathbb{E}[X^2] = \\mathrm{Var}(X)$。因此，$\\mathbb{E}[e_j^2] = \\mathrm{Var}(e_j) = \\sigma_b^2$。问题指出，噪声在不同单元间是独立同分布的，所以对所有 $j$ 来说 $\\sigma_b^2$ 都是相同的。对所有 $N_G$ 个单元求和：\n$$\n\\mathbb{E}[\\|e\\|_2^2] = \\sum_{j=1}^{N_G} \\sigma_b^2 = N_G \\sigma_b^2\n$$\n代入第1部分得到的 $\\sigma_b^2$ 表达式：\n$$\n\\mathbb{E}[\\|e\\|_2^2] = N_G \\left[N_G \\left(\\frac{q_{\\mathrm{e}}^2 n_{\\mathrm{e}}^2}{N_{p,\\mathrm{e}}} + \\frac{q_{\\mathrm{i}}^2 n_{\\mathrm{i}}^2}{N_{p,\\mathrm{i}}}\\right)\\right] = N_G^2 \\left(\\frac{q_{\\mathrm{e}}^2 n_{\\mathrm{e}}^2}{N_{p,\\mathrm{e}}} + \\frac{q_{\\mathrm{i}}^2 n_{\\mathrm{i}}^2}{N_{p,\\mathrm{i}}}\\right)\n$$\n\n**第3部分：最终求解器容差公式**\n\n绝对求解器容差 $\\tau$ 是使用基于期望噪声水平的双标准差（$k=2$）准则来设定的：\n$$\n\\tau = k \\sqrt{\\mathbb{E}[\\|e\\|_2^2]}\n$$\n代入第2部分的结果，得到 $\\tau$ 的最终公式：\n$$\n\\tau = k \\sqrt{N_G^2 \\left(\\frac{q_{\\mathrm{e}}^2 n_{\\mathrm{e}}^2}{N_{p,\\mathrm{e}}} + \\frac{q_{\\mathrm{i}}^2 n_{\\mathrm{i}}^2}{N_{p,\\mathrm{i}}}\\right)} = k N_G \\sqrt{\\frac{q_{\\mathrm{e}}^2 n_{\\mathrm{e}}^2}{N_{p,\\mathrm{e}}} + \\frac{q_{\\mathrm{i}}^2 n_{\\mathrm{i}}^2}{N_{p,\\mathrm{i}}}}\n$$\n$\\tau$ 的单位与问题的要求一致。项 $q^2 n^2$ 的单位是 $(\\mathrm{C} \\cdot \\mathrm{m}^{-3})^2$。量 $k$、$N_G$ 和 $N_p$ 是无量纲的。因此，平方根项的单位是 $\\mathrm{C/m^3}$，所以 $\\tau$ 的单位是 $\\mathrm{C/m^3}$。将实现此公式来为给定的测试用例计算容差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the solver tolerance tau for a series of test cases based on a\n    derived formula for PIC simulation noise.\n    \"\"\"\n    \n    # Define physical constants\n    E0 = 1.602176634e-19  # Elementary charge in Coulombs\n\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (NG, Npe, Npi, ne, ni, qe_charge_num, qi_charge_num, k)\n    test_cases = [\n        (64, 5e6, 5e6, 5.0e19, 5.0e19, -1, 1, 2),\n        (128, 1.0e7, 2.5e6, 5.0e19, 2.5e19, -1, 2, 2),\n        (1, 1.0e3, 1.0e3, 1.0e19, 1.0e19, -1, 1, 2),\n    ]\n\n    results = []\n    for params in test_cases:\n        NG, Npe, Npi, ne, ni, qe_charge_num, qi_charge_num, k = params\n\n        # Express charges in Coulombs\n        qe = qe_charge_num * E0\n        qi = qi_charge_num * E0\n\n        # Calculate the term inside the square root of the formula for tau.\n        # tau = k * NG * sqrt((qe^2 * ne^2 / Npe) + (qi^2 * ni^2 / Npi))\n        \n        term_e = (qe**2 * ne**2) / Npe\n        term_i = (qi**2 * ni**2) / Npi\n        \n        sum_of_terms = term_e + term_i\n        \n        # Calculate tau\n        tau = k * NG * np.sqrt(sum_of_terms)\n        \n        results.append(tau)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "静电势的任意常数偏移不改变物理场，这一规范不变性在离散化的准中性方程中表现为一个奇异矩阵，导致数值解不唯一。本练习将指导您如何通过拉格朗日乘子法引入一个约束来解决这一奇异性问题，从而确保解的唯一性。掌握这项技术对于在周期性区域上构建稳健的求解器至关重要。",
            "id": "4035353",
            "problem": "你需要为静电势构建并实现一个离散拟中性求解器，该求解器通过拉格朗日乘子施加磁通面平均约束，从而在周期性域上是适定的。你必须从第一性原理推导该约束，并实现相应的增广线性系统，以使离散化的拟中性方程有唯一解。本问题中的所有量都是无量纲的，不需要物理单位。\n\n出发点和基本原理：在磁化等离子体的静电回旋动理学（GK）理论中，拟中性要求微扰电荷密度的总和为零，即\n$$\n\\left\\langle \\sum_{s} q_{s}\\,\\delta n_{s} \\right\\rangle \\;=\\; 0,\n$$\n其中 $q_{s}$ 是粒子种类 $s$ 的电荷，$\\delta n_{s}$ 是粒子种类 $s$ 的微扰密度，尖括号 $\\langle \\cdot \\rangle$ 表示磁通面平均（即在磁通面上的极向平均）。在一种常见的静电、长波排序中，静电势 $\\phi$ 和电荷不平衡之间的线性化关系可以通过一个作用于 $\\phi$ 的自伴非负极化算子来建模，该算子平衡了非玻尔兹曼响应。在一维周期性离散化中，这可以抽象为一个对称半正定矩阵方程\n$$\nA\\,\\phi \\;=\\; b,\n$$\n其中 $A \\in \\mathbb{R}^{N \\times N}$ 是一个半正定矩阵，其一维零空间由常数向量张成（由于周期性和规范自由度），$\\phi \\in \\mathbb{R}^{N}$ 是 $N$ 个网格点上势的未知向量，$b \\in \\mathbb{R}^{N}$ 是一个已知向量，表示来自动理学粒子的净电荷不平衡。周期性域意味着给 $\\phi$ 加上一个常数不会改变物理场，因此离散算子 $A$ 的零空间包含常数向量，除非有一个约束来固定 $\\phi$ 的平均值，否则该方程没有唯一解。\n\n磁通面平均约束：设 $w \\in \\mathbb{R}^{N}$ 是一个非负权重向量，满足 $\\sum_{j=0}^{N-1} w_{j} = 1$，它定义了一个离散磁通面平均。$\\phi$ 的离散磁通面平均是 $C^{T}\\phi$，其中 $C = w$。为了固定规范，施加约束\n$$\nC^{T}\\,\\phi \\;=\\; \\gamma,\n$$\n其中 $\\gamma \\in \\mathbb{R}$ 是一个给定的标量（通常 $\\gamma = 0$）。\n\n拉格朗日乘子公式：引入一个拉格朗日乘子 $\\lambda \\in \\mathbb{R}$ 来施加约束，并考虑从对称算子 $A$ 构建的受约束的二次泛函：\n$$\n\\mathcal{J}(\\phi,\\lambda) \\;=\\; \\tfrac{1}{2}\\,\\phi^{T} A \\phi \\;-\\; b^{T}\\phi \\;+\\; \\lambda \\,\\left( C^{T}\\phi - \\gamma \\right).\n$$\n通过将关于 $\\phi$ 和 $\\lambda$ 的变分设为零来推导一阶最优性条件。证明平稳条件产生了 Karush-Kuhn-Tucker (KKT) 系统\n$$\n\\begin{bmatrix}\nA  C \\\\\nC^{T}  0\n\\end{bmatrix}\n\\begin{bmatrix}\n\\phi \\\\ \\lambda\n\\end{bmatrix}\n\\;=\\;\n\\begin{bmatrix}\nb \\\\ \\gamma\n\\end{bmatrix}.\n$$\n从线性代数的角度论证，如果 $A$ 是对称半正定的，且 $\\operatorname{null}(A)=\\operatorname{span}\\{ \\mathbf{1} \\}$ 并且 $C^{T}\\mathbf{1}\\neq 0$（因为 $\\sum_{j} w_{j} = 1$ 而成立），那么该增广系统有唯一的解 $(\\phi,\\lambda)$。\n\n离散算子和可测试的实现：在一个具有 $N$ 个点的一维周期性网格上，点由 $j \\in \\{0,1,\\dots,N-1\\}$ 索引，用离散周期拉普拉斯算子近似极化算子。定义周期性二阶差分矩阵 $L \\in \\mathbb{R}^{N \\times N}$ 为\n$$\n(L\\phi)_{j} \\;=\\; \\phi_{j+1} - 2\\,\\phi_{j} + \\phi_{j-1},\n$$\n使用周期性索引，使得 $\\phi_{-1} \\equiv \\phi_{N-1}$ 且 $\\phi_{N} \\equiv \\phi_{0}$。使用半正定算子\n$$\nA \\;=\\; -\\,L,\n$$\n这样常数向量就位于 $A$ 的零空间中。如上所述，使用拉格朗日乘子来实现约束。\n\n算法任务：编写一个完整、可运行的程序，该程序\n- 为指定的 $N$ 构建矩阵 $A$；\n- 构建定义 $C=w$ 的权重向量 $w$ 和目标平均值 $\\gamma$；\n- 构建右侧项 $b$；\n- 求解增广 KKT 系统以得到 $(\\phi,\\lambda)$；\n- 计算两个残差\n$$\nr_{\\mathrm{eq}} \\;=\\; \\left\\| A\\,\\phi + C\\,\\lambda - b \\right\\|_{2}, \\qquad\nr_{\\mathrm{con}} \\;=\\; \\left| C^{T}\\phi - \\gamma \\right|,\n$$\n并返回单个标量\n$$\nr \\;=\\; \\max\\{ r_{\\mathrm{eq}},\\, r_{\\mathrm{con}} \\}.\n$$\n\n测试套件：你的程序必须为以下四个测试案例中的每一个计算标量 $r$，并在单行上输出列表 $[r_{1},r_{2},r_{3},r_{4}]$。所有量都是无量纲的，角度必须以弧度为单位。对于下面的每个案例，索引 $j$ 的范围是从 $0$ 到 $N-1$。\n\n- 案例 1（理想情况，零平均驱动）：$N=8$。权重 $w_{j} = 1/N$。目标 $\\gamma = 0$。右侧项 $b_{j} = \\sin\\!\\left( 2\\pi \\cdot 2 \\cdot j / N \\right)$。\n- 案例 2（纯规范，非零目标平均值）：$N=8$。权重 $w_{j} = 1/N$。目标 $\\gamma = 1.2$。右侧项 $b_{j} = 0$（对所有 $j$）。\n- 案例 3（非均匀平均权重和不一致的均值）：$N=8$。未归一化权重 $\\tilde{w}_{j} = 1 + 0.2\\,\\sin\\!\\left( 2\\pi \\cdot j / N \\right)$ 且 $w = \\tilde{w}/\\sum_{k}\\tilde{w}_{k}$。目标 $\\gamma = -0.4$。右侧项 $b_{j} = \\cos\\!\\left( 2\\pi \\cdot j / N \\right) + 0.1$。\n- 案例 4（小系统边界情况）：$N=3$。权重 $w_{j} = 1/N$。目标 $\\gamma = 0$。右侧项 $b = [1, -2, 1]$。\n\n最终输出格式：你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序为 $[r_{1},r_{2},r_{3},r_{4}]$，其中每个 $r_{i}$ 是为相应测试案例定义的标量。例如，根据数值舍入误差，输出行可能看起来像\n$[1e-14,1e-14,2e-14,0.0]$\n不应打印任何其他文本。",
            "solution": "该问题陈述是有效的。它在科学上植根于计算等离子体物理学的方法，特别是回旋动理学，并提出了一个定义明确的数学和算法任务。所提供的信息是完整、一致且充分的，足以推导和实现一个唯一的、可验证的解。\n\n问题的核心是为离散拟中性方程找到一个唯一解。其抽象形式是一个欠定线性系统 $A\\,\\phi = b$，其中矩阵 $A \\in \\mathbb{R}^{N \\times N}$ 是对称半正定的，其一维零空间由常数向量 $\\mathbf{1} = [1, 1, \\dots, 1]^T$ 张成。解的非唯一性源于规范自由度，这对应于系统在静电势 $\\phi$ 上增加一个常数偏移时的物理不变性。为了使系统适定，我们必须引入一个额外的约束来固定这个规范。该问题建议使用拉格朗日乘子法，对势的离散磁通面平均值施加约束 $C^T\\phi = \\gamma$。\n\n首先，我们从约束优化问题中推导增广 Karush-Kuhn-Tucker (KKT) 系统。任务是找到泛函 $\\mathcal{J}(\\phi, \\lambda)$ 相对于势 $\\phi \\in \\mathbb{R}^N$ 和拉格朗日乘子 $\\lambda \\in \\mathbb{R}$ 的一个驻点。该泛函由下式给出：\n$$\n\\mathcal{J}(\\phi,\\lambda) \\;=\\; \\tfrac{1}{2}\\,\\phi^{T} A \\phi \\;-\\; b^{T}\\phi \\;+\\; \\lambda \\,\\left( C^{T}\\phi - \\gamma \\right)\n$$\n为了找到驻点，我们将关于 $\\phi$ 和 $\\lambda$ 的梯度设为零。关于向量 $\\phi$ 的梯度是：\n$$\n\\nabla_{\\phi} \\mathcal{J} = \\frac{\\partial}{\\partial \\phi} \\left( \\tfrac{1}{2}\\,\\phi^{T} A \\phi - b^{T}\\phi + \\lambda C^{T}\\phi - \\lambda\\gamma \\right) = A\\phi - b + \\lambda C\n$$\n将其设为零得到第一个最优性条件：\n$$\nA\\phi + C\\lambda = b\n$$\n关于标量 $\\lambda$ 的梯度是：\n$$\n\\frac{\\partial}{\\partial \\lambda} \\mathcal{J} = \\frac{\\partial}{\\partial \\lambda} \\left( \\tfrac{1}{2}\\,\\phi^{T} A \\phi - b^{T}\\phi + \\lambda C^{T}\\phi - \\lambda\\gamma \\right) = C^T\\phi - \\gamma\n$$\n将其设为零得到第二个最优性条件，这正是原始的约束：\n$$\nC^T\\phi = \\gamma\n$$\n将这两个线性方程组合成一个单一的分块矩阵系统，我们得到指定的 KKT 系统：\n$$\n\\begin{bmatrix}\nA  C \\\\\nC^{T}  0\n\\end{bmatrix}\n\\begin{bmatrix}\n\\phi \\\\ \\lambda\n\\end{bmatrix}\n\\;=\\;\n\\begin{bmatrix}\nb \\\\ \\gamma\n\\end{bmatrix}\n$$\n接下来，我们必须证明这个 $(N+1) \\times (N+1)$ 的增广系统是非奇异的，因此具有唯一的解 $(\\phi, \\lambda)$。一个矩阵是非奇异的，当且仅当其零空间只包含零向量。设增广矩阵为 $M$。我们考察齐次系统 $M \\begin{pmatrix} v \\\\ \\alpha \\end{pmatrix} = \\mathbf{0}$，其中 $v \\in \\mathbb{R}^N$ 是一个向量，$\\alpha \\in \\mathbb{R}$ 是一个标量：\n$$\n\\begin{bmatrix}\nA  C \\\\\nC^{T}  0\n\\end{bmatrix}\n\\begin{bmatrix}\nv \\\\ \\alpha\n\\end{bmatrix}\n\\;=\\;\n\\begin{bmatrix}\n\\mathbf{0} \\\\ 0\n\\end{bmatrix}\n$$\n这个分块系统展开为两个方程：\n1. $Av + C\\alpha = \\mathbf{0}$\n2. $C^T v = 0$\n\n从方程($1$)，我们有 $Av = -\\alpha C$。这个线性系统存在解 $v$ 的充要条件是右侧项 $-\\alpha C$ 位于矩阵 $A$ 的值域内。根据线性代数基本定理，矩阵 $A$ 的值域是其转置矩阵零空间的正交补，即 $\\operatorname{range}(A) = (\\operatorname{null}(A^T))^{\\perp}$。由于 $A$ 是对称的（$A=A^T$），我们有 $\\operatorname{range}(A) = (\\operatorname{null}(A))^{\\perp}$。\n问题指定 $\\operatorname{null}(A) = \\operatorname{span}\\{\\mathbf{1}\\}$。因此，为了存在解，右侧项必须与 $\\mathbf{1}$ 正交：\n$$\n\\mathbf{1}^T (-\\alpha C) = 0 \\implies -\\alpha (\\mathbf{1}^T C) = 0\n$$\n向量 $C$ 被定义为权重向量 $w$，题目给出 $\\sum_{j=0}^{N-1} w_j = 1$。这个和恰好是点积 $\\mathbf{1}^T w = \\mathbf{1}^T C$。由于 $\\mathbf{1}^T C = 1 \\neq 0$，条件 $-\\alpha(\\mathbf{1}^T C) = 0$ 要求 $\\alpha = 0$。\n\n将 $\\alpha=0$ 代回方程($1$)得到 $Av = \\mathbf{0}$。这意味着 $v$ 必须在 $A$ 的零空间中。因此，$v$ 必须是常数向量的标量倍数：对于某个标量 $k$，$v = k\\mathbf{1}$。\n\n现在，我们使用方程($2$)，$C^T v = 0$。代入 $v = k\\mathbf{1}$，我们得到：\n$$\nC^T(k\\mathbf{1}) = k(C^T\\mathbf{1}) = k \\cdot 1 = 0\n$$\n这意味着 $k=0$，进而意味着 $v=\\mathbf{0}$。\n由于我们已经证明了 $\\alpha=0$ 和 $v=\\mathbf{0}$ 是齐次系统的唯一解，增广矩阵 $M$ 的零空间是平凡的。因此，$M$ 是可逆的，并且对于任意给定的 $b$ 和 $\\gamma$，KKT 系统都有唯一的解。这种拉格朗日乘子公式成功地“修正”了原始系统 $A\\phi=b$ 的不适定性。\n\n对于实现，极化算子 $A$ 取为离散一维周期拉普拉斯算子的负数，即 $A = -L$。对于大小为 $N$ 的网格，矩阵 $L$ 是一个 $N \\times N$ 的循环矩阵，其元素为：\n$$\nL_{ij} = \\begin{cases} -2  \\text{if } i=j \\\\ 1  \\text{if } |i-j|=1 \\\\ 1  \\text{if } \\{i,j\\}=\\{0, N-1\\} \\\\ 0  \\text{otherwise} \\end{cases}\n$$\n算法的步骤是为每个测试案例构建矩阵 $A$、约束向量 $C=w$、向量 $b$ 和标量 $\\gamma$。然后，组装增广的 $(N+1) \\times (N+1)$ KKT 矩阵及其对应的右侧向量。求解这个线性系统得到包含 $\\phi$ 和 $\\lambda$ 的解向量。最后，计算残差 $r_{\\mathrm{eq}} = \\left\\| A\\,\\phi + C\\,\\lambda - b \\right\\|_{2}$ 和 $r_{\\mathrm{con}} = \\left| C^{T}\\phi - \\gamma \\right|$，并报告它们的最大值。",
            "answer": "```python\nimport numpy as np\n\ndef construct_A(N):\n    \"\"\"\n    Constructs the positive semidefinite matrix A = -L, where L is the\n    1D periodic discrete Laplacian matrix of size N x N.\n    \"\"\"\n    if N  2:\n        # The periodic Laplacian definition is ambiguous for N  3, but\n        # for N=1, A should be [0]. For N=2, A should be [[2,-2],[-2,2]].\n        # The general formula below handles N=2 but not N=1. We will\n        # assume N >= 2 as per the problem context.\n        if N == 1: return np.array([[0.0]])\n        if N == 2: return np.array([[2.0, -2.0], [-2.0, 2.0]])\n\n    # Main diagonal\n    L = np.diag(-2 * np.ones(N))\n    # Super-diagonal and sub-diagonal\n    L += np.diag(np.ones(N - 1), k=1)\n    L += np.diag(np.ones(N - 1), k=-1)\n    # Periodic boundary conditions\n    L[0, N - 1] = 1.0\n    L[N - 1, 0] = 1.0\n    return -L\n\ndef solve_kkt_system(N, C, gamma, b):\n    \"\"\"\n    Solves the augmented KKT system for phi and lambda, and computes\n    the final residual r = max(r_eq, r_con).\n    \"\"\"\n    # 1. Construct the matrix A\n    A = construct_A(N)\n\n    # 2. Build the augmented KKT matrix M\n    M = np.zeros((N + 1, N + 1))\n    M[:N, :N] = A\n    M[:N, N] = C\n    M[N, :N] = C.T\n    \n    # 3. Build the augmented right-hand side vector RHS\n    RHS = np.zeros(N + 1)\n    RHS[:N] = b\n    RHS[N] = gamma\n\n    # 4. Solve the augmented system M * sol = RHS\n    try:\n        sol = np.linalg.solve(M, RHS)\n    except np.linalg.LinAlgError:\n        # In case of singularity, which shouldn't happen for a valid setup\n        return np.inf\n\n    # 5. Extract phi and the Lagrange multiplier lambda\n    phi = sol[:N]\n    lmbda = sol[N]\n\n    # 6. Compute the two residuals\n    # r_eq = || A*phi + C*lambda - b ||_2\n    r_eq = np.linalg.norm(A @ phi + C * lmbda - b)\n    \n    # r_con = | C^T*phi - gamma |\n    r_con = np.abs(C.T @ phi - gamma)\n\n    # 7. Return the maximum of the two residuals\n    return max(r_eq, r_con)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    j_indices = {\n        'case1': np.arange(8),\n        'case2': np.arange(8),\n        'case3': np.arange(8),\n        'case4': np.arange(3),\n    }\n\n    # Case 1: happy path, zero-average forcing\n    N1 = 8\n    w1 = np.full(N1, 1.0 / N1)\n    gamma1 = 0.0\n    b1 = np.sin(2.0 * np.pi * 2.0 * j_indices['case1'] / N1)\n    \n    # Case 2: pure gauge, nonzero target average\n    N2 = 8\n    w2 = np.full(N2, 1.0 / N2)\n    gamma2 = 1.2\n    b2 = np.zeros(N2)\n\n    # Case 3: nonuniform average weights and inconsistent mean\n    N3 = 8\n    j3 = j_indices['case3']\n    w_tilde3 = 1.0 + 0.2 * np.sin(2.0 * np.pi * j3 / N3)\n    w3 = w_tilde3 / np.sum(w_tilde3)\n    gamma3 = -0.4\n    b3 = np.cos(2.0 * np.pi * j3 / N3) + 0.1\n\n    # Case 4: small system edge case\n    N4 = 3\n    w4 = np.full(N4, 1.0 / N4)\n    gamma4 = 0.0\n    b4 = np.array([1.0, -2.0, 1.0])\n\n    test_cases = [\n        (N1, w1, gamma1, b1),\n        (N2, w2, gamma2, b2),\n        (N3, w3, gamma3, b3),\n        (N4, w4, gamma4, b4),\n    ]\n\n    results = []\n    for N, C, gamma, b in test_cases:\n        result = solve_kkt_system(N, C, gamma, b)\n        results.append(result)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "求解离散化准中性方程所产生的大型线性系统通常计算成本高昂，尤其是在高分辨率模拟中。本练习深入探讨预条件子的设计，这是加速迭代求解器的关键工具。您将学习如何利用物理近似——具体来说，是用一个简化的“冻结系数”算子来近似复杂的极化算子——来构建一个可以使用快速傅里叶变换（FFT）高效求解的预条件子。",
            "id": "4035336",
            "problem": "考虑出现在磁化聚变等离子体静电回旋动理学模型中的非线性准中性方程。牛顿法围绕当前静电势的迭代值将残差线性化，并需要求解一个对称正定线性系统。从准中性和线性响应的第一性原理出发，极化算子源于回旋平均的离子响应。在谱形式下，回旋动理学准中性关系由下式给出\n$$\n\\sum_{s} \\frac{q_s^2 n_{0,s}}{T_s} \\left(1 - \\Gamma_0(b_s)\\right) \\,\\hat{\\phi}_{\\boldsymbol{k}} = \\hat{\\sigma}_{\\boldsymbol{k}},\n$$\n其中 $q_s$ 是粒子电荷，$n_{0,s}$ 是背景密度，$T_s$ 是粒子温度，$\\hat{\\phi}_{\\boldsymbol{k}}$ 是静电势的傅里叶分量，$\\hat{\\sigma}_{\\boldsymbol{k}}$ 是回旋中心电荷密度的傅里叶分量，而 $\\Gamma_0(b)$ 是用于有限拉莫尔半径的零阶速度空间回旋平均因子，定义为\n$$\n\\Gamma_0(b) = I_0(b) \\,\\mathrm{e}^{-b},\n$$\n其中 $I_0(b)$ 是零阶第一类修正贝塞尔函数，$b = k_\\perp^2 \\rho_i^2$ 是无量纲有限拉莫尔半径参数（其中 $k_\\perp$ 是垂直波数，$\\rho_i$ 是离子回旋半径）。在实空间离散化中，用于牛顿线性求解的一个常见的对称正定雅可比模型可以写为\n$$\n\\mathbf{J} = \\tau \\,\\mathbf{L} + \\mathbf{S}(\\mathbf{b}),\n$$\n其中 $\\tau  0$ 是一个标量正则化因子，$\\mathbf{L}$ 是在具有 $N$ 个点和网格间距 $h$ 的均匀一维网格上的离散负拉普拉斯算子（周期性边界条件），$\\mathbf{S}(\\mathbf{b})$ 是一个对角矩阵，其元素为 $s_i = \\nu \\left(1 - \\Gamma_0(b_i)\\right)$，其中 $\\nu  0$ 是一个合并了诸如 $\\frac{q_i^2 n_{0,i}}{T_i}$ 等常数的正常数。负拉普拉斯算子定义为\n$$\n(\\mathbf{L}\\boldsymbol{\\phi})_i = \\frac{2\\phi_i - \\phi_{i-1} - \\phi_{i+1}}{h^2}, \\quad i = 0, \\dots, N-1,\n$$\n采用周期性索引，因此 $\\mathbf{L}$ 的特征值为\n$$\n\\lambda_k = \\frac{4}{h^2}\\sin^2\\left(\\frac{\\pi k}{N}\\right), \\quad k = 0, \\dots, N-1.\n$$\n为了在牛顿线性求解中加速克雷洛夫迭代，设计一个基于冻结系数极化算子的预条件子 $\\mathbf{M}$：\n$$\n\\mathbf{M} = \\tau \\,\\mathbf{L} + s_f \\mathbf{I},\n$$\n其中 $s_f$ 是通过将空间变化的极化系数冻结为一个代表值（例如，$s_i$ 的空间平均值）而选择的常数，$\\mathbf{I}$ 是单位矩阵。预条件子应通过利用 $\\mathbf{L}$ 的已知特征分解和傅里叶空间中的对角结构，使用快速傅里叶变换（FFT）高效求解 $\\mathbf{M}\\boldsymbol{x} = \\boldsymbol{y}$ 来应用：\n$$\n\\widehat{x}_k = \\frac{\\widehat{y}_k}{s_f + \\tau \\lambda_k}, \\quad k = 0, \\dots, N-1,\n$$\n其中帽子符号表示离散傅里叶变换。您的任务是：\n- 从准中性关系和线性响应出发，推导出 $\\mathbf{J}$ 和冻结系数预条件子 $\\mathbf{M}$ 的形式，并解释为什么对于 $b_i \\ge 0$ 和 $\\tau  0$，两者都是对称正定的。\n- 实现一个程序，对于给定的测试套件，构造 $\\mathbf{J}$ 和 $\\mathbf{M}$，通过求解以下方程计算矩阵对 $(\\mathbf{J}, \\mathbf{M})$ 的广义特征值 $\\lambda$\n$$\n\\mathbf{J}\\boldsymbol{v} = \\lambda \\,\\mathbf{M}\\boldsymbol{v},\n$$\n并报告谱条件数\n$$\n\\kappa = \\frac{\\max \\lambda}{\\min \\lambda}.\n$$\n- 实现一个预条件共轭梯度（PCG）求解器，使用通过 FFT 应用的预条件子 $\\mathbf{M}$ 求解\n$$\n\\mathbf{J}\\boldsymbol{x} = \\boldsymbol{r}\n$$\n对于一个固定的确定性右端项 $\\boldsymbol{r}$，并报告达到 $10^{-10}$ 相对残差容差所需的迭代次数。\n- 通过比较具有均匀 $b$、中等大空间变化的 $b$、快速振荡大变化的 $b$ 以及极端对比度的 $b$ 的情况下的 $\\kappa$ 和 PCG 迭代次数，分析对 $b$ 的大变化的鲁棒性。\n\n假设一个长度为 $L = 1$ 的一维周期性域，有 $N$ 个网格点，网格间距为 $h = L/N$，并在所有情况下使用以下固定参数：$\\tau = 1$，$\\nu = 1$，以及 $N = 64$。使用标度化的修正贝塞尔函数来稳定地计算 $\\Gamma_0(b)$：\n$$\n\\Gamma_0(b) = I_0(b)\\,\\mathrm{e}^{-b} = I_0^{(e)}(b),\n$$\n其中 $I_0^{(e)}(b)$ 表示指数标度化的零阶第一类修正贝塞尔函数。选择确定性右端项\n$$\nr_i = \\sin\\left(2\\pi \\frac{i}{N}\\right), \\quad i = 0, \\dots, N-1.\n$$\n不需要物理单位；将所有量视为无量纲。\n\n测试套件：\n- 情况 1（均匀小 $b$）：对所有 $i$，$b_i = 0.1$。\n- 情况 2（分段大变化）：对于 $x_i  0.5$，$b_i = 0.1$；对于 $x_i \\ge 0.5$，$b_i = 100$，其中 $x_i = i h$。\n- 情况 3（快速振荡，大振幅）：对所有 $i$，$b_i = 100\\left(1 + 0.99 \\sin\\left(12\\pi x_i\\right)\\right)$。\n- 情况 4（极端对比度）：对于 $x_i  0.5$，$b_i = 10^{-6}$；对于 $x_i \\ge 0.5$，$b_i = 10^{3}$。\n\n您的程序应计算每种情况下的谱条件数 $\\kappa$ 和达到指定容差的 PCG 迭代次数。将条件数表示为四舍五入到三位小数的浮点数，迭代次数表示为整数。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个案例按测试套件的顺序列为一个双元素列表，例如：$[\\,[\\kappa_1, n_1],[\\kappa_2, n_2],[\\kappa_3, n_3],[\\kappa_4, n_4]\\,]$。",
            "solution": "用户要求对一个涉及聚变等离子体准中性求解器的计算物理问题提供一个全面的解决方案。任务包括推导和论证一个雅可比矩阵和一个预条件子的结构，然后实施一个数值实验来评估预条件子的性能。\n\n### 第1部分：雅可比矩阵和预条件子的推导与分析\n\n该问题根植于非线性回旋动理学准中性方程的数值解。此类方程通常使用牛顿-拉夫逊方法求解，该方法涉及迭代求解形式为 $\\mathbf{J} \\Delta\\boldsymbol{\\phi} = -\\boldsymbol{R}$ 的线性系统，其中 $\\boldsymbol{R}$ 是当前迭代点非线性方程的残差，$\\Delta\\boldsymbol{\\phi}$ 是对静电势的更新，$\\mathbf{J}$ 是雅可比矩阵（残差相对于势的导数）。该问题为此雅可比矩阵提供了一个模型，这在实践中很常见，因为完整的雅可比矩阵很复杂，通常使用一个简化的、有物理动机的算子来代替。\n\n**J的推导与结构**\n\n给定的雅可比模型是：\n$$\n\\mathbf{J} = \\tau \\,\\mathbf{L} + \\mathbf{S}(\\mathbf{b})\n$$\n这种形式源于将电荷密度对静电势的依赖性线性化。\n1.  **拉普拉斯项 ($\\tau\\mathbf{L}$)**：矩阵 $\\mathbf{L}$ 是离散负拉普拉斯算子 $-\\nabla^2$。该算子在长波长极限下从离子极化密度响应中自然出现。从问题的谱形式推导，对于小参数 $b_i = k_\\perp^2 \\rho_i^2 \\ll 1$，回旋平均因子为 $\\Gamma_0(b_i) \\approx 1 - b_i$。离子对准中性方程的贡献变为与 $b_i \\hat{\\phi}_{\\boldsymbol{k}} = (k_\\perp^2 \\rho_i^2) \\hat{\\phi}_{\\boldsymbol{k}}$ 成比例。在实空间中，算子 $k_\\perp^2$ 对应于 $-\\nabla^2$，离散化为 $\\mathbf{L}$。标量 $\\tau  0$ 整合了物理常数，并可能包含一个正则化参数。\n2.  **极化项 ($\\mathbf{S}(\\mathbf{b})$)**：矩阵 $\\mathbf{S}(\\mathbf{b})$ 是一个对角矩阵，其元素为 $s_i = \\nu(1 - \\Gamma_0(b_i))$。该项表示有限拉莫尔半径 (FLR) 效应对极化密度的影响。它源于准中性关系中的 $(1-\\Gamma_0(b_s))$ 因子。通过将此项在实空间中设为对角矩阵，我们做了一个局部近似，忽略了完整回旋平均算子的非局域性。参数 $\\nu  0$ 组合了离子种类的常数 $\\frac{q_i^2 n_{0,i}}{T_i}$。\n\n**预条件子M的结构**\n\n建议的预条件子是：\n$$\n\\mathbf{M} = \\tau \\,\\mathbf{L} + s_f \\mathbf{I}\n$$\n这是 $\\mathbf{J}$ 的一个“冻结系数”简化。它保留了拉普拉斯结构，但用一个常数对角矩阵 $s_f\\mathbf{I}$ 替换了空间变化的对角矩阵 $\\mathbf{S}(\\mathbf{b})$。系数 $s_f$ 是空间变化系数 $s_i$ 的单一代表值，此处选择为它们的空间平均值，$s_f = \\frac{1}{N}\\sum_i s_i$。这种形式的主要优点是 $\\mathbf{M}$ 是一个线性的、常系数的微分算子。这类算子在傅里叶空间中是对角的。这意味着线性系统 $\\mathbf{M}\\boldsymbol{x}=\\boldsymbol{y}$ 可以使用快速傅里叶变换 (FFT) 非常高效地求解，正如问题陈述中所指定的，通过在谱域中进行代数除法。\n\n**对称性与正定性**\n\n$\\mathbf{J}$ 和 $\\mathbf{M}$ 都必须是对称正定 (SPD) 的，这样广义特征值问题才是适定的，预条件共轭梯度 (PCG) 方法才能适用。\n\n1.  **对称性**:\n    *   具有周期性边界条件的一维离散拉普拉斯算子的矩阵 $\\mathbf{L}$ 是一个实的、对称的、循环矩阵。\n    *   矩阵 $\\mathbf{S}(\\mathbf{b})$ 是对角的，因此是对称的。\n    *   单位矩阵 $\\mathbf{I}$ 是对称的。\n    *   由于 $\\mathbf{J} = \\tau\\mathbf{L} + \\mathbf{S}(\\mathbf{b})$ 和 $\\mathbf{M} = \\tau\\mathbf{L} + s_f\\mathbf{I}$ 是实对称矩阵的线性组合，它们也是对称的。\n\n2.  **正定性**: 一个对称矩阵当且仅当其所有特征值都严格为正时，才是正定的。\n    *   **L的特征值**: $\\mathbf{L}$ 的特征值为 $\\lambda_k = \\frac{4}{h^2}\\sin^2(\\frac{\\pi k}{N})$，其中 $k=0, \\dots, N-1$。这些都是非负的 ($\\lambda_k \\ge 0$)。$\\lambda_0 = 0$ 对应于常数向量（零频模式）。因此，$\\mathbf{L}$ 是半正定的。\n    *   **S(b)的元素**: 对角元素为 $s_i = \\nu(1 - \\Gamma_0(b_i))$。我们已知 $\\nu  0$ 和 $b_i \\ge 0$。函数 $\\Gamma_0(b) = I_0(b)e^{-b}$ 的性质是 $\\Gamma_0(0)=1$ 且对于 $b0$ 有 $0  \\Gamma_0(b)  1$。因此，$1-\\Gamma_0(b_i) \\ge 0$，这意味着 $s_i \\ge 0$。矩阵 $\\mathbf{S}(\\mathbf{b})$ 是半正定的。\n    *   **J的正定性**: 对于任何非零向量 $\\boldsymbol{x}$，二次型为 $\\boldsymbol{x}^T\\mathbf{J}\\boldsymbol{x} = \\tau \\boldsymbol{x}^T\\mathbf{L}\\boldsymbol{x} + \\boldsymbol{x}^T\\mathbf{S}(\\mathbf{b})\\boldsymbol{x}$。第一项 $\\ge 0$。第二项 $\\sum_i s_i x_i^2 \\ge 0$。和仅当两项都为零时才可能为零。$\\boldsymbol{x}^T\\mathbf{L}\\boldsymbol{x}=0$ 仅当 $\\boldsymbol{x}$ 是一个常数向量时成立（$\\boldsymbol{x}=c\\boldsymbol{1}$）。在这种情况下，$\\boldsymbol{x}^T\\mathbf{S}(\\mathbf{b})\\boldsymbol{x} = c^2\\sum_i s_i$。要使此项为零，所有的 $s_i$ 都必须为零，这意味着所有的 $b_i$ 都必须为零。所有测试用例都至少有部分 $b_i  0$，确保了 $\\sum_i s_i  0$。因此，对于所有非零 $\\boldsymbol{x}$，$\\boldsymbol{x}^T\\mathbf{J}\\boldsymbol{x}  0$，所以 $\\mathbf{J}$ 是正定的。\n    *   **M的正定性**: 二次型为 $\\boldsymbol{x}^T\\mathbf{M}\\boldsymbol{x} = \\tau \\boldsymbol{x}^T\\mathbf{L}\\boldsymbol{x} + s_f \\boldsymbol{x}^T\\mathbf{I}\\boldsymbol{x}$。第一项 $\\ge 0$。第二项是 $s_f \\|\\boldsymbol{x}\\|_2^2$。正如对 $\\mathbf{J}$ 的论证，测试用例确保了并非所有 $s_i$ 都为零，因此它们的平均值 $s_f  0$。由于 $\\boldsymbol{x}$ 非零，$\\|\\boldsymbol{x}\\|_2^20$，使得第二项严格为正。因此，$\\boldsymbol{x}^T\\mathbf{M}\\boldsymbol{x}  0$，$\\mathbf{M}$ 是正定的。\n\n### 第2部分：实现与分析\n\n以下部分展示了 Python 实现。代码首先定义了物理和数值参数。然后，它遍历参数 $b_i$ 的四个测试用例。在每个用例中，它构造矩阵 $\\mathbf{J}$ 和 $\\mathbf{M}$。预条件系统的谱条件数 $\\kappa$ 通过找到矩阵对 $(\\mathbf{J}, \\mathbf{M})$ 的广义特征值来计算。实现了一个预条件共轭梯度 (PCG) 求解器来求解线性系统 $\\mathbf{J}\\boldsymbol{x}=\\boldsymbol{r}$。预条件子求解 $\\mathbf{M}^{-1}\\boldsymbol{y}$ 使用 FFT 高效处理。记录了达到 $10^{-10}$ 相对残差容差所需的迭代次数。最后，汇总所有用例的结果并按指定格式打印。结果展示了预条件子的有效性。对于均匀的 $b_i$（情况1），$\\mathbf{J}=\\mathbf{M}$，导致完美的条件数1和一次迭代收敛。随着 $b_i$ 的空间变化增加（情况2-4），冻结系数近似变得不那么准确，导致条件数恶化和 PCG 迭代次数增加，这与预期相符。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import i0e\nfrom scipy.linalg import eigh, circulant\n\ndef solve():\n    \"\"\"\n    Solves the quasi-neutrality problem for the given test suite.\n    - Constructs the Jacobian J and preconditioner M.\n    - Computes the generalized condition number kappa.\n    - Runs a PCG solver to find the number of iterations for convergence.\n    \"\"\"\n    # Define fixed parameters\n    N = 64\n    L = 1.0\n    h = L / N\n    tau = 1.0\n    nu = 1.0\n    tol = 1e-10\n    max_iter = 1000\n\n    # Define spatial grid and test cases for b\n    x = np.arange(N) * h\n    b_cases = [\n        # Case 1: uniform small b\n        np.full(N, 0.1),\n        # Case 2: piecewise large variation\n        np.piecewise(x, [x  0.5, x >= 0.5], [0.1, 100.0]),\n        # Case 3: rapid oscillation, large amplitude\n        100.0 * (1.0 + 0.99 * np.sin(12.0 * np.pi * x)),\n        # Case 4: extreme contrast\n        np.piecewise(x, [x  0.5, x >= 0.5], [1e-6, 1e3])\n    ]\n\n    # Construct the discrete negative Laplacian matrix L\n    # The first column defines the symmetric circulant matrix\n    c = np.zeros(N)\n    c[0] = 2.0\n    c[1] = -1.0\n    c[N - 1] = -1.0\n    L_mat = circulant(c) / h**2\n\n    # Eigenvalues of L for the FFT-based preconditioner solve\n    k_modes = np.arange(N)\n    lambda_L = (4.0 / h**2) * np.sin(np.pi * k_modes / N)**2\n\n    # Define the right-hand side vector r\n    r = np.sin(2.0 * np.pi * k_modes / N)\n    norm_r = np.linalg.norm(r)\n\n    results = []\n    for b_vec in b_cases:\n        # --- Construct J and M ---\n\n        # S(b) term\n        s_i = nu * (1.0 - i0e(b_vec))\n        S_mat = np.diag(s_i)\n        \n        # Jacobian J\n        J_mat = tau * L_mat + S_mat\n\n        # Preconditioner M\n        s_f = np.mean(s_i)\n        M_mat = tau * L_mat + s_f * np.identity(N)\n\n        # --- Compute Condition Number kappa ---\n        # Solve the generalized eigenvalue problem J*v = lambda*M*v\n        try:\n            eigenvalues = eigh(J_mat, M_mat, eigvals_only=True)\n            kappa = np.max(eigenvalues) / np.min(eigenvalues)\n        except np.linalg.LinAlgError:\n            kappa = np.inf\n\n        # --- PCG Solver ---\n\n        # Preconditioner solver M*z = y applied via FFT\n        lambda_M = tau * lambda_L + s_f\n        # The k=0 mode has lambda_L[0]=0, but lambda_M[0]=s_f which is > 0\n        def apply_preconditioner(y):\n            y_hat = np.fft.fft(y)\n            z_hat = y_hat / lambda_M\n            z = np.fft.ifft(z_hat)\n            return np.real(z)\n\n        # PCG algorithm\n        x_pcg = np.zeros(N)\n        res = r.copy() # Since x_pcg is zero, initial residual is r\n        z = apply_preconditioner(res)\n        p = z.copy()\n        rs_old = np.dot(res, z)\n        iters = 0\n\n        if norm_r == 0:\n            iters = 0\n        else:\n            for i in range(1, max_iter + 1):\n                Ap = J_mat @ p\n                \n                # Check for breakdown\n                p_dot_Ap = np.dot(p, Ap)\n                if p_dot_Ap = 0: # J must be positive definite\n                    iters = -1 # Indicate failure\n                    break\n                    \n                alpha = rs_old / p_dot_Ap\n                x_pcg += alpha * p\n                res -= alpha * Ap\n\n                if np.linalg.norm(res) / norm_r  tol:\n                    iters = i\n                    break\n\n                z = apply_preconditioner(res)\n                rs_new = np.dot(res, z)\n                \n                # Check for breakdown\n                if rs_old == 0:\n                    iters = -1\n                    break\n                    \n                beta = rs_new / rs_old\n                p = z + beta * p\n                rs_old = rs_new\n            else: # If loop finishes without break\n                iters = max_iter\n\n        results.append([round(kappa, 3), iters])\n\n    # Format and print the final output\n    print(results)\n\nsolve()\n```"
        }
    ]
}