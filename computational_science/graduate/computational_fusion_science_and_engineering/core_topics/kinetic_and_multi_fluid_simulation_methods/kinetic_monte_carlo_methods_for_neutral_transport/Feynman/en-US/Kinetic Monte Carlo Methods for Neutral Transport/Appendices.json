{
    "hands_on_practices": [
        {
            "introduction": "The foundation of any Kinetic Monte Carlo (KMC) simulation is an accurate model of the rates at which physical events occur. This first exercise bridges the gap between abstract simulation parameters and concrete physics by having you calculate the fundamental collision rate, or hazard, $\\lambda$. By starting from first principles of kinetic theory, you will connect macroscopic plasma parameters like ion density $n_i$ and microscopic interaction physics, described by the cross section $\\sigma(E)$, to determine the collision frequency for a neutral particleâ€”a key parameter that governs the timescale of events in a KMC simulation .",
            "id": "3999899",
            "problem": "A neutral deuterium atom moving in the edge of a fusion plasma is simulated using Kinetic Monte Carlo (KMC), where the next event time is drawn from an exponential distribution with rate parameter (hazard) given by the collision frequency. From kinetic theory, the collision frequency for binary encounters may be written in terms of the target ion number density, energy-dependent cross section, and relative speed. Consider deuterium charge-exchange with deuterium ions of number density $n_{i} = 7.5 \\times 10^{19}\\ \\mathrm{m}^{-3}$. The energy-dependent cross section is described by $\\sigma(E) = \\sigma_{0}\\left(E/E_{0}\\right)^{1/2}$, where $\\sigma_{0} = 1.8 \\times 10^{-16}\\ \\mathrm{cm}^{2}$ and $E_{0} = 1\\ \\mathrm{eV}$. A monoenergetic neutral has kinetic energy $E = 20\\ \\mathrm{eV}$ and mass $m_{D} = 3.344 \\times 10^{-27}\\ \\mathrm{kg}$. Assume the relative speed equals the neutral speed. Starting from the fundamental definition of kinetic energy and the standard collision-frequency expression in kinetic theory, derive the rate $\\lambda$ used by KMC as a function of $n_{i}$, $\\sigma(E)$, and the neutral speed $v$, and verify dimensional consistency by explicitly converting the cross section from $\\mathrm{cm}^{2}$ to $\\mathrm{m}^{2}$ and the energy from $\\mathrm{eV}$ to $\\mathrm{J}$. Compute the numerical value of $\\lambda$ and demonstrate that its unit is $\\mathrm{s}^{-1}$. Round your final rate to four significant figures. Express the final answer in $\\mathrm{s}^{-1}$.",
            "solution": "The problem is assessed as valid as it is scientifically grounded in kinetic theory, well-posed with all necessary information provided, and objective in its language and formulation. We can therefore proceed with the solution.\n\nThe rate parameter $\\lambda$ for a collision event in a Kinetic Monte Carlo (KMC) simulation is equivalent to the total collision frequency. For binary encounters between a test particle and a population of target particles, the collision frequency is given by the expression:\n$$ \\lambda = n_{\\text{target}} \\langle \\sigma v_{\\text{rel}} \\rangle $$\nwhere $n_{\\text{target}}$ is the number density of the target particles, $\\sigma$ is the collision cross section, $v_{\\text{rel}}$ is the relative speed between the colliding particles, and the angle brackets $\\langle \\dots \\rangle$ denote an average over the velocity distributions of both populations.\n\nThe problem specifies a monoenergetic neutral deuterium atom, which means its speed is fixed. It also provides the simplifying assumption that the relative speed equals the neutral's speed, $v_{\\text{rel}} = v$. This is equivalent to assuming a stationary target of deuterium ions. Under these conditions, the averaging is unnecessary, and the expression for the rate $\\lambda$ simplifies to:\n$$ \\lambda = n_{i} \\sigma(E) v $$\nThis equation represents the derivation of $\\lambda$ as a function of the ion density $n_{i}$, the energy-dependent cross section $\\sigma(E)$, and the neutral speed $v$, as requested.\n\nTo compute the numerical value of $\\lambda$, we must first determine the neutral speed $v$ and the specific cross section $\\sigma(E)$ from the given data.\n\nThe kinetic energy of the neutral deuterium atom is given by $E = 20\\ \\mathrm{eV}$, and its mass is $m_{D} = 3.344 \\times 10^{-27}\\ \\mathrm{kg}$. The relationship between kinetic energy and speed is:\n$$ E = \\frac{1}{2} m_{D} v^2 $$\nSolving for the speed $v$ gives:\n$$ v = \\sqrt{\\frac{2E}{m_{D}}} $$\n\nThe energy-dependent charge-exchange cross section is given by the formula:\n$$ \\sigma(E) = \\sigma_{0}\\left(\\frac{E}{E_{0}}\\right)^{1/2} $$\nwhere $\\sigma_{0} = 1.8 \\times 10^{-16}\\ \\mathrm{cm}^{2}$ and $E_{0} = 1\\ \\mathrm{eV}$.\n\nBefore proceeding with numerical calculations, we must ensure all quantities are in a consistent set of units, specifically the International System of Units (SI).\nThe given values are:\n- Ion density: $n_{i} = 7.5 \\times 10^{19}\\ \\mathrm{m}^{-3}$ (SI unit)\n- Neutral mass: $m_{D} = 3.344 \\times 10^{-27}\\ \\mathrm{kg}$ (SI unit)\n- Neutral energy: $E = 20\\ \\mathrm{eV}$\n- Cross section constant: $\\sigma_{0} = 1.8 \\times 10^{-16}\\ \\mathrm{cm}^{2}$\n- Reference energy: $E_{0} = 1\\ \\mathrm{eV}$\n\nWe perform the necessary unit conversions for energy and cross section. The conversion factor between electron-volts ($\\mathrm{eV}$) and joules ($\\mathrm{J}$) is the elementary charge, $e \\approx 1.602177 \\times 10^{-19}\\ \\mathrm{C}$.\n$$ E = 20\\ \\mathrm{eV} = 20 \\times (1.602177 \\times 10^{-19})\\ \\mathrm{J} = 3.204354 \\times 10^{-18}\\ \\mathrm{J} $$\nThe conversion from square centimeters ($\\mathrm{cm}^{2}$) to square meters ($\\mathrm{m}^{2}$) is $1\\ \\mathrm{m}^{2} = (100\\ \\mathrm{cm})^{2} = 10^{4}\\ \\mathrm{cm}^{2}$, which gives $1\\ \\mathrm{cm}^{2} = 10^{-4}\\ \\mathrm{m}^{2}$.\n$$ \\sigma_{0} = 1.8 \\times 10^{-16}\\ \\mathrm{cm}^{2} = 1.8 \\times 10^{-16} \\times 10^{-4}\\ \\mathrm{m}^{2} = 1.8 \\times 10^{-20}\\ \\mathrm{m}^{2} $$\n\nNow we can compute the numerical values for $v$ and $\\sigma(E)$:\nThe speed of the neutral atom is:\n$$ v = \\sqrt{\\frac{2 \\times (3.204354 \\times 10^{-18}\\ \\mathrm{J})}{3.344 \\times 10^{-27}\\ \\mathrm{kg}}} \\approx \\sqrt{1.91648 \\times 10^{9}\\ \\frac{\\mathrm{m}^{2}}{\\mathrm{s}^{2}}} \\approx 4.37776 \\times 10^{4}\\ \\frac{\\mathrm{m}}{\\mathrm{s}} $$\nThe cross section for the collision is:\n$$ \\sigma(E) = (1.8 \\times 10^{-20}\\ \\mathrm{m}^{2}) \\left(\\frac{20\\ \\mathrm{eV}}{1\\ \\mathrm{eV}}\\right)^{1/2} = (1.8 \\times 10^{-20}\\ \\mathrm{m}^{2}) \\sqrt{20} $$\n$$ \\sigma(E) \\approx (1.8 \\times 10^{-20}\\ \\mathrm{m}^{2}) \\times 4.472136 \\approx 8.04984 \\times 10^{-20}\\ \\mathrm{m}^{2} $$\n\nWith all components calculated in SI units, we can compute the rate $\\lambda$:\n$$ \\lambda = n_{i} \\sigma(E) v $$\n$$ \\lambda \\approx (7.5 \\times 10^{19}\\ \\mathrm{m}^{-3}) \\times (8.04984 \\times 10^{-20}\\ \\mathrm{m}^{2}) \\times (4.37776 \\times 10^{4}\\ \\frac{\\mathrm{m}}{\\mathrm{s}}) $$\n$$ \\lambda \\approx (7.5 \\times 8.04984 \\times 4.37776) \\times 10^{19-20+4}\\ \\mathrm{s}^{-1} $$\n$$ \\lambda \\approx 264.295 \\times 10^{3}\\ \\mathrm{s}^{-1} = 2.64295 \\times 10^{5}\\ \\mathrm{s}^{-1} $$\n\nThe dimensional consistency is verified as follows:\n$$ [\\lambda] = [n_i] [\\sigma(E)] [v] = (\\mathrm{m}^{-3}) \\cdot (\\mathrm{m}^{2}) \\cdot (\\mathrm{m} \\cdot \\mathrm{s}^{-1}) = \\mathrm{m}^{-3+2+1} \\cdot \\mathrm{s}^{-1} = \\mathrm{m}^{0} \\cdot \\mathrm{s}^{-1} = \\mathrm{s}^{-1} $$\nThis confirms that the resulting rate $\\lambda$ has units of inverse seconds, as expected for a frequency.\n\nFinally, rounding the numerical result to four significant figures as requested:\n$$ \\lambda \\approx 2.643 \\times 10^{5}\\ \\mathrm{s}^{-1} $$",
            "answer": "$$\\boxed{2.643 \\times 10^{5}}$$"
        },
        {
            "introduction": "After establishing how to calculate the likelihood of a collision, the next logical step in a KMC simulation is to determine *where* in space that collision will happen. This is straightforward in a uniform medium, but fusion plasmas are highly inhomogeneous. This practice introduces the powerful concept of optical depth, which serves as a \"probabilistic distance\" to handle such spatial variations. You will apply this concept to track a neutral particle through a one-dimensional slab with distinct material regions, learning the core KMC algorithm for sampling a free-flight path and identifying the collision location .",
            "id": "3999930",
            "problem": "A neutral particle is transported in a one-dimensional slab in the context of kinetic Monte Carlo (KMC) methods for neutral transport. The slab occupies the interval $[0, L]$ in the coordinate $x$, with two contiguous material regions: region $1$ spans $[0, L_1]$ and region $2$ spans $[L_1, L_1 + L_2]$, so that $L = L_1 + L_2$. The neutral begins at position $x_0$ with direction toward increasing $x$ and travels through the slab without reflection. The macroscopic collision coefficient per unit length in each region is constant: $\\nu(x) = \\nu_1$ for $x \\in [0, L_1]$ and $\\nu(x) = \\nu_2$ for $x \\in [L_1, L_1 + L_2]$, with $\\nu_1 > 0$ and $\\nu_2 > 0$. The free-flight distance $s$ to the next collision is defined by the condition that the integrated collision hazard along the path equals a sampled optical depth $\\tau$, where the optical depth is sampled from the exponential law via a uniform random variate $R \\in (0,1)$ according to $\\tau = -\\ln(R)$. The collision position is $x_{\\mathrm{coll}} = x_0 + s$.\n\nAssume $L_1 = 0.06\\,\\mathrm{m}$, $L_2 = 0.04\\,\\mathrm{m}$, $x_0 = 0.02\\,\\mathrm{m}$, $\\nu_1 = 20\\,\\mathrm{m}^{-1}$, $\\nu_2 = 5\\,\\mathrm{m}^{-1}$, and $R = 0.5$. Define the entry distances along the direction of flight from the starting point to the interface and to the slab exit, respectively, as $d_1 = L_1 - x_0$ and $d_2 = L_2$. Using the definitions above and starting from first principles, determine $x_{\\mathrm{coll}}$.\n\nRound your answer to four significant figures. Express the final collision position in meters.",
            "solution": "The problem is first validated to ensure it is scientifically grounded, well-posed, and objective.\n\n**Step 1: Extract Givens**\n-   One-dimensional slab geometry: $x \\in [0, L]$.\n-   Region 1: $x \\in [0, L_1]$, with macroscopic collision coefficient $\\nu(x) = \\nu_1$.\n-   Region 2: $x \\in [L_1, L_1 + L_2]$, with macroscopic collision coefficient $\\nu(x) = \\nu_2$.\n-   Slab dimension relation: $L = L_1 + L_2$.\n-   Initial particle position: $x_0 = 0.02\\,\\mathrm{m}$.\n-   Initial particle direction: toward increasing $x$.\n-   Numerical values: $L_1 = 0.06\\,\\mathrm{m}$, $L_2 = 0.04\\,\\mathrm{m}$, $\\nu_1 = 20\\,\\mathrm{m}^{-1}$, $\\nu_2 = 5\\,\\mathrm{m}^{-1}$.\n-   Random variate for sampling: $R = 0.5$, with $R \\in (0,1)$.\n-   Definition of optical depth: $\\tau = -\\ln(R)$.\n-   Condition for free-flight distance $s$: The integrated collision hazard along the path equals $\\tau$.\n-   Definition of collision position: $x_{\\mathrm{coll}} = x_0 + s$.\n-   Auxiliary definitions: $d_1 = L_1 - x_0$ and $d_2 = L_2$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, as it describes a standard one-dimensional, two-region transport problem solved with a kinetic Monte Carlo approach. The use of macroscopic collision coefficients (cross-sections), optical depth, and inverse transform sampling ($\\tau = -\\ln(R)$) are all fundamental and correct concepts in transport theory. The problem is well-posed because all necessary data ($x_0$, $\\nu_1$, $\\nu_2$, $L_1$, $R$) and clear rules are provided to determine a unique collision position $x_{\\mathrm{coll}}$. The initial position $x_0 = 0.02\\,\\mathrm{m}$ is correctly located within Region 1 ($[0, 0.06\\,\\mathrm{m}]$). The physical units are consistent. The problem is objective and free of ambiguity for the given inputs.\n\n**Step 3: Verdict and Action**\nThe problem is deemed valid. A complete solution will be provided.\n\n**Solution Derivation**\nThe fundamental principle of kinetic Monte Carlo for particle transport is that the optical depth traversed by a particle over a free-flight path is sampled from an exponential probability distribution. The cumulative distribution function for optical depth $\\tau$ is $P(\\tau' < \\tau) = 1 - \\exp(-\\tau)$. Using inverse transform sampling with a uniform random variate $R \\in (0,1)$, we set $R = P(\\tau' < \\tau)$, which gives $R = 1 - \\exp(-\\tau)$ and leads to the prescribed relation $\\tau = -\\ln(1-R)$. Since $R$ is a uniform random variate on $(0,1)$, $1-R$ is also a uniform random variate on $(0,1)$. Therefore, for sampling purposes, we can use $\\tau = -\\ln(R)$.\n\nFor the given random variate $R=0.5$, the sampled optical depth to the next collision is:\n$$ \\tau = -\\ln(0.5) = -(\\ln(2^{-1})) = \\ln(2) $$\nThe value of the optical depth is approximately $\\tau \\approx 0.6931$.\n\nThe optical depth is also defined as the integral of the macroscopic collision coefficient $\\nu(x)$ along the particle's path, from its starting point $x_0$ to the collision point $x_{\\mathrm{coll}} = x_0 + s$:\n$$ \\tau = \\int_{x_0}^{x_0+s} \\nu(x') \\, dx' $$\n\nThe particle starts at $x_0 = 0.02\\,\\mathrm{m}$ in Region 1, where $\\nu(x) = \\nu_1 = 20\\,\\mathrm{m}^{-1}$. It travels towards positive $x$. We must first determine if the collision occurs in Region 1 or if the particle crosses the interface at $x = L_1 = 0.06\\,\\mathrm{m}$ to enter Region 2.\n\nTo do this, we calculate the optical depth required to reach the interface, $\\tau_{\\text{interface}}$. The path length to the interface is $s_1 = L_1 - x_0$.\n$$ s_1 = 0.06\\,\\mathrm{m} - 0.02\\,\\mathrm{m} = 0.04\\,\\mathrm{m} $$\nThe optical depth to traverse this path in Region 1 is:\n$$ \\tau_{\\text{interface}} = \\int_{x_0}^{L_1} \\nu_1 \\, dx' = \\nu_1 (L_1 - x_0) = \\nu_1 s_1 $$\nSubstituting the given values:\n$$ \\tau_{\\text{interface}} = (20\\,\\mathrm{m}^{-1}) \\times (0.04\\,\\mathrm{m}) = 0.8 $$\n\nWe now compare the sampled optical depth $\\tau$ with the optical depth to the interface $\\tau_{\\text{interface}}$:\n$$ \\tau = \\ln(2) \\approx 0.6931 $$\n$$ \\tau_{\\text{interface}} = 0.8 $$\nSince $\\tau < \\tau_{\\text{interface}}$, the particle does not have sufficient \"optical path\" to reach the interface. Therefore, the collision occurs within Region 1.\n\nFor a collision within Region 1, the flight distance $s$ is determined by the equation:\n$$ \\tau = \\int_{x_0}^{x_0+s} \\nu_1 \\, dx' = \\nu_1 s $$\nSolving for $s$:\n$$ s = \\frac{\\tau}{\\nu_1} = \\frac{\\ln(2)}{\\nu_1} $$\nThe position of the collision is then:\n$$ x_{\\mathrm{coll}} = x_0 + s = x_0 + \\frac{\\ln(2)}{\\nu_1} $$\nSubstituting the numerical values:\n$$ x_{\\mathrm{coll}} = 0.02\\,\\mathrm{m} + \\frac{\\ln(2)}{20\\,\\mathrm{m}^{-1}} $$\nUsing the approximation $\\ln(2) \\approx 0.693147$:\n$$ x_{\\mathrm{coll}} \\approx 0.02\\,\\mathrm{m} + \\frac{0.693147}{20}\\,\\mathrm{m} \\approx 0.02\\,\\mathrm{m} + 0.034657\\,\\mathrm{m} $$\n$$ x_{\\mathrm{coll}} \\approx 0.054657\\,\\mathrm{m} $$\nThe problem requires the answer to be rounded to four significant figures. The first four significant figures are $0$, $0$, $5$, $4$, $6$, $5$. Counting from the first non-zero digit, the significant figures are $5$, $4$, $6$, $5$. The next digit is $7$, which requires rounding up the last significant digit.\n$$ x_{\\mathrm{coll}} \\approx 0.05466\\,\\mathrm{m} $$\nThis position is within Region 1 ($x \\in [0, 0.06\\,\\mathrm{m}]$), which is consistent with our finding that the collision occurs before the interface.",
            "answer": "$$\\boxed{0.05466}$$"
        },
        {
            "introduction": "Real-world plasma profiles are rarely simple piecewise-constant functions; they typically exhibit smooth, continuous variations in density and temperature. This final, advanced practice challenges you to generalize the concept of optical depth to these more realistic scenarios. Instead of a simple comparison, finding the collision path length $s$ requires solving an integral equation, $\\int_0^s \\nu(x(\\ell))\\,d\\ell = \\tau$. You will implement a complete numerical solver using a safeguarded Newton's method and numerical quadrature, developing a robust tool that is essential for building a production-level KMC transport code .",
            "id": "3999913",
            "problem": "You are to implement a complete, runnable program that, for neutral transport in kinetic Monte Carlo, solves for the path length along a straight trajectory by root-finding the equation $$\\int_{0}^{s} \\nu(E(\\ell),x(\\ell))\\,d\\ell=\\tau,$$ where the macroscopic collision frequency per unit length is $$\\nu(E,x)=n(x)\\,\\sigma(E)$$ with nonnegative background density $$n(x)$$ and energy-dependent cross section $$\\sigma(E).$$ In neutral transport, a straight trajectory parameterization with arc length is $$x(\\ell)=x_0+\\ell$$ and the neutral energy is constant between collisions so $$E(\\ell)=E_0.$$ This equation arises from sampling the free-flight in an inhomogeneous Poisson medium via optical depth. You must implement a bracketed root-finding method that is globally convergent on monotone integrals, and return the boundary value when the root does not exist within the finite domain.\n\nStart from the foundational principle that the survival probability of a neutral to distance $$s$$ in a spatially inhomogeneous medium with macroscopic rate per unit length $$\\nu(E,x)\\ge 0$$ is $$S(s)=\\exp\\!\\big(-\\int_0^s \\nu(E(\\ell),x(\\ell))\\,d\\ell\\big),$$ and sampling a flight distance in kinetic Monte Carlo requires drawing a uniform random deviate $$r\\in(0,1)$$ and setting $$\\int_0^s \\nu(E(\\ell),x(\\ell))\\,d\\ell=-\\ln r\\equiv\\tau,$$ which you will solve deterministically for prescribed $$\\tau.$$\n\nYou must:\n- Construct a robust solver for $$F(s)\\equiv\\int_{0}^{s}\\nu(E_0,x_0+\\ell)\\,d\\ell-\\tau=0.$$\n- Use a safeguarded Newton method with bisection on a bracket $$[0,s_{\\max}]$$, where $$s_{\\max}$$ is the distance to the wall along the straight path. The derivative is $$\\frac{dF}{ds}=\\nu(E_0,x_0+s).$$ Ensure a monotone bracket update and fall back to bisection if a Newton iterate leaves the bracket.\n- Compute $$F(s)$$ by numerical quadrature, and implement a scientifically sound convergence criterion. Convergence must be declared only if $$|F(s)|\\le \\max(\\varepsilon_{\\mathrm{rel}}\\,\\tau,\\varepsilon_{\\mathrm{abs}})$$, with $$\\varepsilon_{\\mathrm{rel}}$$ and $$\\varepsilon_{\\mathrm{abs}}$$ set by you to reasonable small values appropriate to advanced graduate-level numerical work. If $$F(s_{\\max})<\\tau$$, return $$s_{\\max}$$ and declare non-convergence, because the optical depth cannot be satisfied within the domain.\n- All physical units must be respected: output path lengths $$s$$ must be in meters $$\\mathrm{m}$$, and collision frequency per unit length $$\\nu$$ has units $$\\mathrm{m}^{-1}$$.\n\nImplement the following test suite covering different neutral transport situations, with each case fully specified by $$n(x)$$, $$\\sigma(E)$$, $$x_0$$, $$E_0$$, $$s_{\\max}$$, and $$\\tau$$. In all cases, positions $$x$$ are in meters $$\\mathrm{m}$$, densities $$n$$ are in $$\\mathrm{m}^{-3}$$, cross sections $$\\sigma$$ are in $$\\mathrm{m}^2$$, and $$\\nu$$ is in $$\\mathrm{m}^{-1}$$.\n\n- Case A (exponential edge profile, solution exists): $$n(x)=n_0\\exp(-x/L_n)$$ with $$n_0=10^{19}$$, $$L_n=0.5$$; $$\\sigma(E)=\\sigma_{\\mathrm{ref}}\\sqrt{E_{\\mathrm{ref}}/E}$$ with $$\\sigma_{\\mathrm{ref}}=10^{-19}$$ at $$E_{\\mathrm{ref}}=100$$; $$x_0=0$$, $$E_0=100$$, $$s_{\\max}=2.0$$, $$\\tau=0.3$$.\n- Case B (linear decay to zero, solution exists): $$n(x)=n_0\\max\\big(0,1-x/L_{\\mathrm{lim}}\\big)$$ with $$n_0=5\\times 10^{18}$$, $$L_{\\mathrm{lim}}=1.0$$; $$\\sigma(E)=\\sigma_{\\mathrm{ref}}\\sqrt{E_{\\mathrm{ref}}/E}$$ with $$\\sigma_{\\mathrm{ref}}=2\\times 10^{-19}$$ at $$E_{\\mathrm{ref}}=50$$; $$x_0=0.2$$, $$E_0=50$$, $$s_{\\max}=L_{\\mathrm{lim}}-x_0$$, $$\\tau=0.1$$.\n- Case C (finite cosine-squared pedestal, no solution within domain): $$n(x)=n_0\\cos^2\\!\\big(\\pi x/(2L_c)\\big)$$ for $$0\\le x\\le L_c$$ and $$n(x)=0$$ otherwise, with $$n_0=2\\times 10^{18}$$, $$L_c=1.5$$; $$\\sigma(E)=\\sigma_{\\mathrm{ref}}\\sqrt{E_{\\mathrm{ref}}/E}$$ with $$\\sigma_{\\mathrm{ref}}=1.5\\times 10^{-19}$$ at $$E_{\\mathrm{ref}}=30$$; $$x_0=0$$, $$E_0=30$$, $$s_{\\max}=L_c$$, $$\\tau=0.5$$.\n- Case D (exponential profile, small optical depth): same as Case A but $$\\tau=10^{-9}$$.\n\nYour program must compute the path length $$s$$ for each case and a boolean indicating whether the convergence criteria were satisfied without hitting the wall. If $$F(s_{\\max})<\\tau$$, output $$s=s_{\\max}$$ and a boolean $$\\mathrm{False}$$. Express the path length $$s$$ in $$\\mathrm{m}$$ rounded to six decimal places. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $$[s_A,\\mathrm{conv}_A,s_B,\\mathrm{conv}_B,s_C,\\mathrm{conv}_C,s_D,\\mathrm{conv}_D]$$, for example $$[s_A,\\mathrm{conv}_A,\\dots]$$ where each $$s$$ is a decimal with exactly six places and each $$\\mathrm{conv}$$ is $$\\mathrm{True}$$ or $$\\mathrm{False}$$.",
            "solution": "The problem requires the deterministic solution of an integral equation to find the path length of a neutral particle in an inhomogeneous medium, a foundational step in kinetic Monte Carlo simulations of neutral transport. The solution is derived from first principles and implemented using a robust numerical algorithm.\n\nThe core physical principle is that the probability of a particle surviving without collision over a path length $s$ is given by $S(s)=\\exp(-\\Lambda(s))$, where $\\Lambda(s)$ is the optical depth. For a straight-line path in a one-dimensional medium, the optical depth is the integral of the macroscopic collision frequency, $\\nu$, over the path:\n$$\n\\Lambda(s) = \\int_{0}^{s} \\nu(E(\\ell), x(\\ell)) \\, d\\ell\n$$\nIn a kinetic Monte Carlo method, a path length is sampled by first drawing a uniform random number $r \\in (0,1)$ and setting the survival probability equal to it: $S(s) = r$. This is equivalent to setting the optical depth to a randomly sampled value $\\tau = -\\ln r$. Since $r \\in (0,1)$, we have $\\tau \\in (0,\\infty)$. The problem then becomes finding the path length $s$ that satisfies the equation:\n$$\n\\int_{0}^{s} \\nu(E(\\ell), x(\\ell)) \\, d\\ell = \\tau\n$$\nThe problem specifies a straight trajectory $x(\\ell) = x_0 + \\ell$ and constant energy between collisions $E(\\ell) = E_0$. The macroscopic collision frequency is defined as $\\nu(E,x) = n(x)\\,\\sigma(E)$, where $n(x)$ is the background density and $\\sigma(E)$ is the collision cross section. Both $n(x)$ and $\\sigma(E)$ are specified to be non-negative, which implies $\\nu(E,x) \\ge 0$.\n\nTo solve for an unknown path length $s$, we must find the root of the function $F(s)$:\n$$\nF(s) \\equiv \\int_{0}^{s} \\nu(E_0, x_0+\\ell)\\,d\\ell - \\tau = 0\n$$\nThis is a root-finding problem for a single variable $s$. The properties of $F(s)$ are critical for selecting a robust numerical method. Since $\\nu \\ge 0$, the integral $\\int_{0}^{s} \\nu(\\dots) \\, d\\ell$ is a monotonically non-decreasing function of its upper limit $s$. Consequently, $F(s)$ is also a monotonically non-decreasing function of $s$. Its derivative with respect to $s$ is given by the Fundamental Theorem of Calculus:\n$$\n\\frac{dF}{ds} = \\nu(E_0, x_0+s)\n$$\nAt the starting point $s=0$, the integral is zero, so $F(0) = -\\tau < 0$. The search for the root is conducted within a finite domain $[0, s_{\\max}]$, where $s_{\\max}$ is the distance to a physical boundary (a wall). Since $F(s)$ is monotonic, a unique root is guaranteed to exist within this domain if and only if $F(s_{\\max}) \\ge 0$. If $F(s_{\\max}) < 0$, it means that the particle reaches the wall before accumulating the required optical depth $\\tau$; in this scenario, the flight path is terminated at the wall, and the path length is $s = s_{\\max}$.\n\nThe numerical implementation will consist of two main components: a numerical quadrature method to evaluate the integral in $F(s)$, and a root-finding algorithm to solve $F(s)=0$.\n1.  **Numerical Quadrature**: The integral is computed using an adaptive quadrature routine, for which `scipy.integrate.quad` is a suitable and robust choice. It provides high accuracy for a wide range of well-behaved integrands, as is the case here.\n2.  **Root-Finding**: A safeguarded Newton's method is specified. This hybrid method combines the rapid local convergence of the Newton-Raphson method with the guaranteed global convergence of the bisection method. Given a bracket $[a, b]$ known to contain the root (i.e., $F(a)F(b) < 0$):\n    -   A Newton-Raphson step is calculated: $s_{\\text{newton}} = s_k - F(s_k)/F'(s_k)$, where $s_k$ is the current estimate.\n    -   If $s_{\\text{newton}}$ falls within the current bracket $[a, b]$, it is accepted as the next estimate, $s_{k+1} = s_{\\text{newton}}$. This leverages the quadratic convergence of Newton's method.\n    -   If $s_{\\text{newton}}$ falls outside the bracket, it is rejected, and the next estimate is taken from a bisection step: $s_{k+1} = (a+b)/2$. This guarantees that the process remains within a valid solution space and ensures convergence.\n    -   After each step, the bracket $[a, b]$ is updated based on the sign of $F(s_{k+1})$ to maintain the root-bracketing property. If $F(s_{k+1}) < 0$, the new lower bound becomes $a = s_{k+1}$; otherwise, the new upper bound becomes $b = s_{k+1}$.\n\nConvergence is declared when the magnitude of the function value is smaller than a specified tolerance: $|F(s)| \\le \\max(\\varepsilon_{\\mathrm{rel}}\\,\\tau, \\varepsilon_{\\mathrm{abs}})$. For this implementation, we choose tolerances appropriate for scientific computation, such as $\\varepsilon_{\\mathrm{rel}} = 10^{-10}$ and $\\varepsilon_{\\mathrm{abs}} = 10^{-12}$.\n\nThe final implementation encapsulates this logic in a single program, defining the specific physical models for $n(x)$ and $\\sigma(E)$ for each test case and applying the solver to find the corresponding path length $s$. The output will indicate both the calculated path length and a boolean flag signifying whether the solution converged within the domain or terminated at the boundary $s_{\\max}$.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the neutral transport path length solver.\n    \"\"\"\n\n    # --- Define Density and Cross Section Functions ---\n\n    def n_exp(x, n0, Ln):\n        \"\"\"Exponential density profile.\"\"\"\n        return n0 * np.exp(-x / Ln)\n\n    def n_linear(x, n0, Llim):\n        \"\"\"Linearly decaying density profile.\"\"\"\n        if x < Llim:\n            return n0 * (1.0 - x / Llim)\n        return 0.0\n\n    def n_cos2(x, n0, Lc):\n        \"\"\"Cosine-squared density profile on a finite domain.\"\"\"\n        if 0 <= x <= Lc:\n            return n0 * np.cos(np.pi * x / (2.0 * Lc))**2\n        return 0.0\n\n    def sigma_sqrt_inv_E(E, sigma_ref, E_ref):\n        \"\"\"1/sqrt(E) energy-dependent cross section.\"\"\"\n        if E <= 0: return np.inf\n        return sigma_ref * np.sqrt(E_ref / E)\n\n    # --- Define Test Cases ---\n\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"n_func\": n_exp, \"n_params\": {\"n0\": 1e19, \"Ln\": 0.5},\n            \"sigma_func\": sigma_sqrt_inv_E, \"sigma_params\": {\"sigma_ref\": 1e-19, \"E_ref\": 100.0},\n            \"x0\": 0.0, \"E0\": 100.0, \"s_max\": 2.0, \"tau\": 0.3\n        },\n        {\n            \"name\": \"B\",\n            \"n_func\": n_linear, \"n_params\": {\"n0\": 5e18, \"Llim\": 1.0},\n            \"sigma_func\": sigma_sqrt_inv_E, \"sigma_params\": {\"sigma_ref\": 2e-19, \"E_ref\": 50.0},\n            \"x0\": 0.2, \"E0\": 50.0, \"s_max\": 1.0 - 0.2, \"tau\": 0.1\n        },\n        {\n            \"name\": \"C\",\n            \"n_func\": n_cos2, \"n_params\": {\"n0\": 2e18, \"Lc\": 1.5},\n            \"sigma_func\": sigma_sqrt_inv_E, \"sigma_params\": {\"sigma_ref\": 1.5e-19, \"E_ref\": 30.0},\n            \"x0\": 0.0, \"E0\": 30.0, \"s_max\": 1.5, \"tau\": 0.5\n        },\n        {\n            \"name\": \"D\",\n            \"n_func\": n_exp, \"n_params\": {\"n0\": 1e19, \"Ln\": 0.5},\n            \"sigma_func\": sigma_sqrt_inv_E, \"sigma_params\": {\"sigma_ref\": 1e-19, \"E_ref\": 100.0},\n            \"x0\": 0.0, \"E0\": 100.0, \"s_max\": 2.0, \"tau\": 1e-9\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        s, conv = solve_path_length(\n            n_func=case[\"n_func\"], n_params=case[\"n_params\"],\n            sigma_func=case[\"sigma_func\"], sigma_params=case[\"sigma_params\"],\n            x0=case[\"x0\"], E0=case[\"E0\"], s_max=case[\"s_max\"], tau=case[\"tau\"]\n        )\n        results.append(f\"{s:.6f}\")\n        results.append(str(conv))\n\n    print(f\"[{','.join(results)}]\")\n\ndef solve_path_length(n_func, n_params, sigma_func, sigma_params, x0, E0, s_max, tau):\n    \"\"\"\n    Solves for the path length s by root-finding the optical depth equation.\n\n    Uses a safeguarded Newton-Raphson method with bisection fallback.\n    \"\"\"\n    # --- Numerical Solver Parameters ---\n    eps_rel = 1e-10\n    eps_abs = 1e-12\n    max_iter = 50\n    quad_tol = 1.49e-12\n\n    # --- Problem-Specific Functions ---\n    sigma_val = sigma_func(E0, **sigma_params)\n\n    def nu(x):\n        \"\"\"Macroscopic collision frequency nu(x) = n(x) * sigma(E0).\"\"\"\n        return n_func(x, **n_params) * sigma_val\n\n    def integrand(l):\n        \"\"\"Integrand nu(x(l)) for the optical depth integral.\"\"\"\n        return nu(x0 + l)\n\n    # Use a cache for F(s) evaluations to avoid re-computing integrals for the same s value.\n    F_cache = {}\n    def F(s):\n        \"\"\"Calculates F(s) = integral_0^s nu(l) dl - tau.\"\"\"\n        if s in F_cache:\n            return F_cache[s]\n        integral_val, _ = quad(integrand, 0, s, epsabs=quad_tol, epsrel=quad_tol)\n        result = integral_val - tau\n        F_cache[s] = result\n        return result\n\n    def F_prime(s):\n        \"\"\"Derivative dF/ds = nu(x(s)).\"\"\"\n        return integrand(s)\n\n    # --- Root-finding Algorithm ---\n\n    # 1. Check boundary condition: if optical depth at wall is insufficient.\n    F_s_max = F(s_max)\n    if F_s_max < 0:\n        return s_max, False\n\n    # 2. Initialize bracket and initial guess\n    a, b = 0.0, s_max\n    s = (a + b) / 2.0  # Start with a bisection guess\n\n     # 3. Iteration loop\n    for _ in range(max_iter):\n        f_s = F(s)\n        \n        # Check convergence\n        tolerance = max(eps_rel * abs(tau), eps_abs)\n        if abs(f_s) <= tolerance:\n            return s, True\n\n        # Update bracket based on the sign of F(s)\n        if f_s < 0:\n            a = s\n        else:\n            b = s\n        \n        # Calculate Newton step\n        fp_s = F_prime(s)\n        \n        # If derivative is non-zero, attempt Newton step, otherwise force bisection\n        if fp_s > np.finfo(float).eps:\n            s_newton = s - f_s / fp_s\n        else:\n            # Set to outside the bracket to force bisection\n            s_newton = a - 1.0\n\n        # Safeguard: check if Newton step is within the updated bracket\n        if a < s_newton < b:\n            s = s_newton\n        else:\n            # Fall back to bisection if Newton step is out of bounds\n            s = (a + b) / 2.0\n            \n        # If bracket has collapsed, we have found the root to machine precision\n        if s <= a or s >= b:\n             break\n\n    # After max iterations, return the best guess and its convergence status\n    return s, abs(F(s)) <= max(eps_rel * abs(tau), eps_abs)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}