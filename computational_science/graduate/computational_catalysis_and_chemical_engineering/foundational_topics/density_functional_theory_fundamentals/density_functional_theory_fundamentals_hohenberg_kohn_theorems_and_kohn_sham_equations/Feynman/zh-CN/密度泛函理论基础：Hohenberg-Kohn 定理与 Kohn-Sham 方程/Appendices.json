{
    "hands_on_practices": [
        {
            "introduction": "在密度泛函理论的计算实现中，连续的电子密度函数 $n(\\mathbf{r})$ 通常被表示在一个离散的网格上。任何DFT计算中的一个基本步骤是确保这种离散表示能够准确地反映物理系统。本练习  提供了对电子密度进行数值积分以获得总电子数的关键任务的动手实践，这是一个基础性的健全性检查，它将Hohenberg-Kohn的连续理论与计算模拟的离散现实联系起来。",
            "id": "3876853",
            "problem": "给定一个在密度泛函理论（DFT）背景下的表面平板模型的基态电子密度 $n(\\mathbf r)$ 的直角三维离散化。在此，密度泛函理论（DFT）指的是由 Hohenberg-Kohn 定理所确立的，从基态电子密度到系统所有可观测量之间的映射。目标是通过对模拟晶胞内的 $n(\\mathbf r)$ 进行积分来数值计算总积分电荷（以电子为单位），并验证其等于晶胞中的电子数。这与 Kohn-Sham 方程一致，该方程用一个辅助的无相互作用体系来表示相互作用体系，该辅助体系的轨道能再现相同的基态电子密度。其基本原理是，总电子数 $N$ 由以下积分给出\n$$\nN \\equiv \\int_{\\Omega} n(\\mathbf r)\\,\\mathrm d^3 \\mathbf r,\n$$\n并且，在 Kohn-Sham 表象中，密度可以表示为 $n(\\mathbf r) = \\sum_i f_i \\left|\\psi_i(\\mathbf r)\\right|^2$，其中 $f_i$ 是占据数，$\\psi_i(\\mathbf r)$ 是归一化的 Kohn-Sham 轨道。\n\n你的任务是实现一个与离散化直角网格相符的数值积分方法。电子密度 $n(\\mathbf r)$ 在网格节点 $(x_i,y_j,z_k)$ 上采样。为保证与基于节点的离散化在物理上和数值上的一致性，请使用三维梯形法则。该法则沿每个轴应用一维梯形权重，并通过张量积构成体积元：\n- 对于一维坐标数组 $\\{u_\\ell\\}_{\\ell=0}^{M-1}$（其中 $u_\\ell$ 的单位为 $\\mathrm{\\AA}$），梯形权重 $w_\\ell$（单位为 $\\mathrm{\\AA}$）定义如下\n$$\nw_0 = \\frac{u_1 - u_0}{2},\\quad\nw_\\ell = \\frac{u_{\\ell+1} - u_{\\ell-1}}{2}\\ \\text{for}\\ 1 \\le \\ell \\le M-2,\\quad\nw_{M-1} = \\frac{u_{M-1} - u_{M-2}}{2}.\n$$\n- 对于具有坐标数组 $\\{x_i\\}_{i=0}^{N_x-1}$、$\\{y_j\\}_{j=0}^{N_y-1}$ 和 $\\{z_k\\}_{k=0}^{N_z-1}$ 的三个轴，三维梯形近似为\n$$\n\\hat N = \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\sum_{k=0}^{N_z-1} n(x_i,y_j,z_k)\\, w^{(x)}_i\\, w^{(y)}_j\\, w^{(z)}_k,\n$$\n其中 $w^{(x)}_i$、$w^{(y)}_j$ 和 $w^{(z)}_k$ 是各轴特定的梯形权重。当密度 $n$ 的单位为电子数/立方埃（$\\mathrm{e}/\\mathrm{\\AA}^3$）且坐标单位为埃（$\\mathrm{\\AA}$）时，此方法计算出的 $\\hat N$ 的单位为电子数。\n\n请对以下五个测试案例实现上述方法。在所有案例中，均不涉及角度。使用 $10^{-4}$ 电子数的绝对验证容差。单位：\n- 坐标 $\\{x_i\\}, \\{y_j\\}, \\{z_k\\}$ 的单位为 $\\mathrm{\\AA}$。\n- 密度 $n(\\mathbf r)$ 的单位为 $\\mathrm{e}/\\mathrm{\\AA}^3$。\n- 积分电子数以电子为单位（无量纲）。\n\n对于每个案例，请严格按照规定构建坐标数组和离散化的密度 $n(\\mathbf r)$。\n\n案例 1（带真空层的正交平板中的均匀密度）：\n- 晶胞长度：$L_x = 5.0\\,\\mathrm{\\AA}$，$L_y = 5.0\\,\\mathrm{\\AA}$，$L_z = 20.0\\,\\mathrm{\\AA}$。\n- 网格尺寸：$N_x = 25$，$N_y = 25$，$N_z = 40$。\n- 坐标：$x_i$、$y_j$、$z_k$ 在 $0$ 与各自晶胞长度（包含端点）之间线性间隔分布。\n- 目标电子数：$N_{\\mathrm{target}} = 16$。\n- 密度：$n(\\mathbf r) = N_{\\mathrm{target}}/(L_x L_y L_z)$（均匀）。\n\n案例 2（沿 $z$ 轴非均匀间距的高斯平板密度）：\n- 晶胞长度：$L_x = 8.0\\,\\mathrm{\\AA}$，$L_y = 8.0\\,\\mathrm{\\AA}$，$L_z = 30.0\\,\\mathrm{\\AA}$。\n- 网格尺寸：$N_x = 20$，$N_y = 20$，$N_z = 60$。\n- 坐标：$x_i$、$y_j$ 在其范围内线性间隔分布；$z_k$ 是非均匀的，通过以下方式构建\n$$\nu_k = \\tanh\\!\\big(\\alpha\\, t_k\\big),\\ \\ t_k = \\frac{2k}{N_z - 1} - 1,\\ \\ \\alpha = 2.5,\n$$\n然后通过 $p_k = \\frac{u_k - \\min(u)}{\\max(u) - \\min(u)}$ 将 $\\{u_k\\}$ 重新缩放到 $[0,1]$ 区间，并设置 $z_k = L_z p_k$。\n- 目标电子数：$N_{\\mathrm{target}} = 24$。\n- 密度：一个依赖于 $z$ 的高斯函数，\n$$\nn(x,y,z) = A \\exp\\!\\left( -\\frac{(z - z_0)^2}{2\\sigma^2} \\right),\n$$\n其中 $z_0 = L_z/2$，$\\sigma = 1.0\\,\\mathrm{\\AA}$，且 $A = \\dfrac{N_{\\mathrm{target}}}{L_x L_y \\sqrt{2\\pi}\\,\\sigma}$。\n\n案例 3（代表真空中薄平板的两个局域高斯峰）：\n- 晶胞长度：$L_x = 10.0\\,\\mathrm{\\AA}$，$L_y = 10.0\\,\\mathrm{\\AA}$，$L_z = 60.0\\,\\mathrm{\\AA}$。\n- 网格尺寸：$N_x = 16$，$N_y = 16$，$N_z = 96$。\n- 坐标：$x_i$、$y_j$、$z_k$ 线性间隔分布。\n- 目标电子数：$N_{\\mathrm{target}} = 2$。\n- 密度：位于 $z_1 = 15.0\\,\\mathrm{\\AA}$ 和 $z_2 = 45.0\\,\\mathrm{\\AA}$ 的两个 $z$ 轴局域高斯函数之和，$\\sigma = 0.5\\,\\mathrm{\\AA}$，\n$$\nn(x,y,z) = \\sum_{m=1}^2 A_m \\exp\\!\\left( -\\frac{(z - z_m)^2}{2\\sigma^2} \\right),\\quad A_m = \\frac{1}{L_x L_y \\sqrt{2\\pi}\\,\\sigma},\n$$\n使得每个峰积分后为 $1$ 个电子，总计 $N_{\\mathrm{target}} = 2$。\n\n案例 4（沿所有轴均为非均匀间距的均匀密度）：\n- 晶胞长度：$L_x = 7.5\\,\\mathrm{\\AA}$，$L_y = 6.25\\,\\mathrm{\\AA}$，$L_z = 12.5\\,\\mathrm{\\AA}$。\n- 网格尺寸：$N_x = 21$，$N_y = 17$，$N_z = 19$。\n- 坐标：对每个轴，通过与案例 2 中相同的基于 $\\tanh$ 的过程构建非均匀节点，但使用不同的 $\\alpha$ 值：$\\alpha_x = 3.0$，$\\alpha_y = 1.5$，$\\alpha_z = 2.0$，并重新缩放到 $[0,L_\\bullet]$。\n- 目标电子数：$N_{\\mathrm{target}} = 11$。\n- 密度：$n(\\mathbf r) = N_{\\mathrm{target}}/(L_x L_y L_z)$（均匀）。\n\n案例 5（通过占据数从 Kohn-Sham 轨道生成密度）：\n- 晶胞长度：$L_x = 12.0\\,\\mathrm{\\AA}$，$L_y = 10.0\\,\\mathrm{\\AA}$，$L_z = 14.0\\,\\mathrm{\\AA}$。\n- 网格尺寸：$N_x = 48$，$N_y = 40$，$N_z = 56$。\n- 坐标：$x_i$、$y_j$、$z_k$ 线性间隔分布。\n- 占据数：$f_1 = 2$，$f_2 = 2$。\n- 轨道：定义\n$$\n\\psi_1(x,y,z) = \\sqrt{\\frac{8}{L_x L_y L_z}}\\,\\sin\\!\\left(\\frac{\\pi x}{L_x}\\right)\\sin\\!\\left(\\frac{\\pi y}{L_y}\\right)\\sin\\!\\left(\\frac{\\pi z}{L_z}\\right),\n$$\n$$\n\\psi_2(x,y,z) = \\sqrt{\\frac{8}{L_x L_y L_z}}\\,\\sin\\!\\left(\\frac{2\\pi x}{L_x}\\right)\\sin\\!\\left(\\frac{\\pi y}{L_y}\\right)\\sin\\!\\left(\\frac{\\pi z}{L_z}\\right),\n$$\n并将密度设置为\n$$\nn(\\mathbf r) = f_1 \\left|\\psi_1(\\mathbf r)\\right|^2 + f_2 \\left|\\psi_2(\\mathbf r)\\right|^2.\n$$\n- 目标电子数：$N_{\\mathrm{target}} = f_1 + f_2 = 4$。\n\n验证：\n- 对于每个案例，使用三维梯形法则计算 $\\hat N$，并验证 $\\left|\\hat N - N_{\\mathrm{target}}\\right| \\le 10^{-4}$ 电子数。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，格式为 $[\\hat N_1,\\mathrm{ok}_1,\\hat N_2,\\mathrm{ok}_2,\\ldots,\\hat N_5,\\mathrm{ok}_5]$。其中，每个 $\\hat N_i$ 是一个浮点数，如果验证不等式成立，则每个 $\\mathrm{ok}_i$ 为布尔值 $\\mathrm{True}$，否则为 $\\mathrm{False}$。每个 $\\hat N_i$ 的单位是电子数（无量纲）。",
            "solution": "Hohenberg-Kohn 定理的基本原理指出，基态电子密度 $n(\\mathbf r)$ 唯一地决定了系统的所有性质，包括总电子数 $N$。电子数由以下积分得到\n$$\nN = \\int_{\\Omega} n(\\mathbf r)\\,\\mathrm d^3 \\mathbf r,\n$$\n其中 $\\Omega$ 是三维空间中的模拟晶胞，$n(\\mathbf r) \\ge 0$ 的单位是电子数/立方埃（$\\mathrm{e}/\\mathrm{\\AA}^3$）。在 Kohn-Sham 构造中，同一个 $n(\\mathbf r)$ 由具有占据数 $f_i$ 的无相互作用轨道 $\\psi_i(\\mathbf r)$ 再现，且 $n(\\mathbf r) = \\sum_i f_i |\\psi_i(\\mathbf r)|^2$。由于每个归一化轨道都满足 $\\int |\\psi_i(\\mathbf r)|^2\\mathrm d^3\\mathbf r = 1$，根据线性关系可以得出 $\\int n(\\mathbf r)\\mathrm d^3\\mathbf r = \\sum_i f_i$，这使得该积分等于 Kohn-Sham 占据数所隐含的电子数。\n\n当 $n(\\mathbf r)$ 在一个由节点 $\\{(x_i,y_j,z_k)\\}$ 构成的直角网格上给出时，为进行数值积分，我们采用与基于节点的采样相一致的梯形求积法。在一维情况下，对于跨越区间 $[0,U]$ 的坐标数组 $\\{u_\\ell\\}_{\\ell=0}^{M-1}$，梯形权重 $w_\\ell$ 近似了每个节点处的线元 $\\mathrm d u$：\n$$\nw_0 = \\frac{u_1 - u_0}{2},\\quad\nw_\\ell = \\frac{u_{\\ell+1} - u_{\\ell-1}}{2}\\ \\text{for}\\ 1 \\le \\ell \\le M-2,\\quad\nw_{M-1} = \\frac{u_{M-1} - u_{M-2}}{2}.\n$$\n这些权重满足 $\\sum_{\\ell=0}^{M-1} w_\\ell \\approx U$，对于线性间隔，等号成立。在三维中，体积元的可分性意味着 $\\mathrm d^3 \\mathbf r = \\mathrm d x\\, \\mathrm d y\\, \\mathrm d z$，因此我们构建张量积权重。对于 $x$、$y$ 和 $z$ 轴，其各自的梯形权重为 $w^{(x)}_i$、$w^{(y)}_j$ 和 $w^{(z)}_k$，三维梯形法则将积分计算为\n$$\n\\hat N = \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\sum_{k=0}^{N_z-1} n(x_i,y_j,z_k)\\, w^{(x)}_i\\, w^{(y)}_j\\, w^{(z)}_k.\n$$\n当密度 $n$ 的单位为 $\\mathrm{e}/\\mathrm{\\AA}^3$ 且坐标单位为 $\\mathrm{\\AA}$ 时，此算法计算出的 $\\hat N$ 以电子为单位。梯形法则适用于 Kohn-Sham 计算中常见的平滑密度，并能确保在均匀网格上的均匀密度的计算是精确的，以及在平滑的非均匀情况下的高精度。\n\n算法步骤：\n1. 对每个测试案例，根据指定的晶胞长度和网格尺寸构建坐标数组 $\\{x_i\\}$、$\\{y_j\\}$、$\\{z_k\\}$。对于非均匀轴，使用指定的双曲正切映射 $u = \\tanh(\\alpha t)$，其中 $t$ 在 $[-1,1]$ 内均匀分布，然后将结果重新缩放到物理区间。\n2. 构建离散化密度 $n(x_i,y_j,z_k)$：\n   - 对于均匀密度案例，设置 $n(\\mathbf r) = N_{\\mathrm{target}}/(L_x L_y L_z)$。\n   - 对于仅在 $z$ 方向变化的高斯密度，设置 $n(x,y,z) = A \\exp\\!\\left( -\\frac{(z - z_0)^2}{2\\sigma^2} \\right)$，并选择 $A$ 使得连续积分近似等于 $N_{\\mathrm{target}}$：$A = \\dfrac{N_{\\mathrm{target}}}{L_x L_y \\sqrt{2\\pi}\\,\\sigma}$，其中 $z_0 = L_z/2$，且 $\\sigma$ 相对于 $L_z$ 较小以最小化截断误差。\n   - 对于两个高斯函数之和，使用叠加原理并选择振幅 $A_m$，使得每个高斯函数积分为 $1$ 个电子，确保总数为 $2$。\n   - 对于 Kohn-Sham 轨道，使用归一化常数 $\\sqrt{\\frac{8}{L_x L_y L_z}}$ 构建 $\\psi_1$ 和 $\\psi_2$，这保证了在连续情况下 $\\int |\\psi_i|^2 \\mathrm d^3 \\mathbf r = 1$ 精确成立。密度为 $n(\\mathbf r) = f_1|\\psi_1|^2 + f_2|\\psi_2|^2$。\n3. 使用差分公式计算每个轴上的一维梯形权重。这些权重的单位是 $\\mathrm{\\AA}$。\n4. 使用三重求和与张量积权重计算积分电子数，得到 $\\hat N$。\n5. 对每个案例，验证 $\\left|\\hat N - N_{\\mathrm{target}}\\right| \\le 10^{-4}$ 电子数。\n6. 将输出汇总为指定的单行格式：$[\\hat N_1,\\mathrm{ok}_1,\\hat N_2,\\mathrm{ok}_2,\\ldots,\\hat N_5,\\mathrm{ok}_5]$。\n\n该设计利用了电子数是密度积分（Hohenberg-Kohn）这一原理，并且在 Kohn-Sham 形式主义中，通过构造，由具有已知占据数的轨道导出的密度在积分后等于电子数。选择梯形积分法是因为它与平面波和基于网格的 DFT 代码通常产生的基于节点的离散化相一致，并为积分提供了一个鲁棒且收敛的近似。该测试套件包括均匀密度案例（用于验证精确性）、非均匀坐标（用于验证对可变间距的正确处理）、局域高斯密度（用于模拟真空中类似平板的电子分布），以及由归一化 Kohn-Sham 轨道构建的密度（用于探究轨道占据数与电子数之间的联系）。$10^{-4}$ 电子数的统一绝对容差考虑了离散化和求积误差，同时对于高等研究生水平的数值验证而言仍然是严格的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef trapezoid_weights(coords: np.ndarray) - np.ndarray:\n    \"\"\"\n    Compute 1D trapezoidal weights for node-based integration over the coordinate array.\n    coords: array of shape (M,) in Angstrom.\n    Returns weights array of shape (M,) in Angstrom.\n    \"\"\"\n    M = coords.size\n    if M  2:\n        raise ValueError(\"At least two points are required to form trapezoidal weights.\")\n    diffs = np.diff(coords)\n    if np.any(diffs = 0):\n        raise ValueError(\"Coordinate array must be strictly increasing.\")\n    w = np.empty(M, dtype=float)\n    w[0] = diffs[0] / 2.0\n    w[-1] = diffs[-1] / 2.0\n    if M > 2:\n        w[1:-1] = (diffs[1:] + diffs[:-1]) / 2.0\n    return w\n\ndef integrate_density(n: np.ndarray, x: np.ndarray, y: np.ndarray, z: np.ndarray) - float:\n    \"\"\"\n    Integrate a 3D density n(x_i, y_j, z_k) using tensor-product trapezoidal weights.\n    n: array of shape (Nx, Ny, Nz) in e/Angstrom^3\n    x, y, z: coordinate arrays in Angstrom\n    Returns total electrons as float.\n    \"\"\"\n    wx = trapezoid_weights(x)\n    wy = trapezoid_weights(y)\n    wz = trapezoid_weights(z)\n    # Use broadcasting to multiply weights\n    # Volume element per node = wx[i] * wy[j] * wz[k]\n    vol_weights = wx[:, None, None] * wy[None, :, None] * wz[None, None, :]\n    total_electrons = float(np.sum(n * vol_weights))\n    return total_electrons\n\ndef make_tanh_nonuniform_coords(L: float, N: int, alpha: float) - np.ndarray:\n    \"\"\"\n    Construct a nonuniform coordinate array on [0, L] using a tanh mapping with parameter alpha.\n    \"\"\"\n    t = np.linspace(-1.0, 1.0, N)\n    u = np.tanh(alpha * t)  # range approximately (-tanh(alpha), tanh(alpha))\n    # Rescale to [0, 1]\n    p = (u - u.min()) / (u.max() - u.min())\n    return L * p\n\ndef solve():\n    tol = 1e-4  # absolute tolerance in electrons\n\n    results = []\n\n    # Case 1: Uniform density in orthorhombic slab with vacuum\n    Lx1, Ly1, Lz1 = 5.0, 5.0, 20.0\n    Nx1, Ny1, Nz1 = 25, 25, 40\n    x1 = np.linspace(0.0, Lx1, Nx1)\n    y1 = np.linspace(0.0, Ly1, Ny1)\n    z1 = np.linspace(0.0, Lz1, Nz1)\n    N_target1 = 16.0\n    n1_val = N_target1 / (Lx1 * Ly1 * Lz1)\n    n1 = np.full((Nx1, Ny1, Nz1), n1_val, dtype=float)\n    N_calc1 = integrate_density(n1, x1, y1, z1)\n    ok1 = abs(N_calc1 - N_target1) = tol\n    results.extend([N_calc1, ok1])\n\n    # Case 2: Nonuniform z with Gaussian\n    Lx2, Ly2, Lz2 = 8.0, 8.0, 30.0\n    Nx2, Ny2, Nz2 = 20, 20, 60\n    x2 = np.linspace(0.0, Lx2, Nx2)\n    y2 = np.linspace(0.0, Ly2, Ny2)\n    z2 = make_tanh_nonuniform_coords(Lz2, Nz2, alpha=2.5)\n    N_target2 = 24.0\n    z0_2 = Lz2 / 2.0\n    sigma2 = 1.0\n    A2 = N_target2 / (Lx2 * Ly2 * np.sqrt(2.0 * np.pi) * sigma2)\n    # Density depends only on z\n    n2_z = A2 * np.exp(-0.5 * ((z2 - z0_2) / sigma2) ** 2)\n    # Broadcast to 3D\n    n2 = np.broadcast_to(n2_z[None, None, :], (Nx2, Ny2, Nz2)).copy()\n    N_calc2 = integrate_density(n2, x2, y2, z2)\n    ok2 = abs(N_calc2 - N_target2) = tol\n    results.extend([N_calc2, ok2])\n\n    # Case 3: Two localized Gaussians (thin slab in vacuum)\n    Lx3, Ly3, Lz3 = 10.0, 10.0, 60.0\n    Nx3, Ny3, Nz3 = 16, 16, 96\n    x3 = np.linspace(0.0, Lx3, Nx3)\n    y3 = np.linspace(0.0, Ly3, Ny3)\n    z3 = np.linspace(0.0, Lz3, Nz3)\n    N_target3 = 2.0\n    z1_3, z2_3 = 15.0, 45.0\n    sigma3 = 0.5\n    A3 = 1.0 / (Lx3 * Ly3 * np.sqrt(2.0 * np.pi) * sigma3)  # each peak 1 electron\n    n3_z = A3 * np.exp(-0.5 * ((z3 - z1_3) / sigma3) ** 2) + A3 * np.exp(-0.5 * ((z3 - z2_3) / sigma3) ** 2)\n    n3 = np.broadcast_to(n3_z[None, None, :], (Nx3, Ny3, Nz3)).copy()\n    N_calc3 = integrate_density(n3, x3, y3, z3)\n    ok3 = abs(N_calc3 - N_target3) = tol\n    results.extend([N_calc3, ok3])\n\n    # Case 4: Uniform density with nonuniform spacing on all axes\n    Lx4, Ly4, Lz4 = 7.5, 6.25, 12.5\n    Nx4, Ny4, Nz4 = 21, 17, 19\n    x4 = make_tanh_nonuniform_coords(Lx4, Nx4, alpha=3.0)\n    y4 = make_tanh_nonuniform_coords(Ly4, Ny4, alpha=1.5)\n    z4 = make_tanh_nonuniform_coords(Lz4, Nz4, alpha=2.0)\n    N_target4 = 11.0\n    n4_val = N_target4 / (Lx4 * Ly4 * Lz4)\n    n4 = np.full((Nx4, Ny4, Nz4), n4_val, dtype=float)\n    N_calc4 = integrate_density(n4, x4, y4, z4)\n    ok4 = abs(N_calc4 - N_target4) = tol\n    results.extend([N_calc4, ok4])\n\n    # Case 5: Kohn-Sham orbitals with occupations\n    Lx5, Ly5, Lz5 = 12.0, 10.0, 14.0\n    Nx5, Ny5, Nz5 = 48, 40, 56\n    x5 = np.linspace(0.0, Lx5, Nx5)\n    y5 = np.linspace(0.0, Ly5, Ny5)\n    z5 = np.linspace(0.0, Lz5, Nz5)\n    f1, f2 = 2.0, 2.0\n    N_target5 = f1 + f2\n    C5 = np.sqrt(8.0 / (Lx5 * Ly5 * Lz5))\n    # Build 3D grids via broadcasting\n    X5 = x5[:, None, None]\n    Y5 = y5[None, :, None]\n    Z5 = z5[None, None, :]\n    psi1_sq = (C5**2) * (np.sin(np.pi * X5 / Lx5) ** 2) * (np.sin(np.pi * Y5 / Ly5) ** 2) * (np.sin(np.pi * Z5 / Lz5) ** 2)\n    psi2_sq = (C5**2) * (np.sin(2.0 * np.pi * X5 / Lx5) ** 2) * (np.sin(np.pi * Y5 / Ly5) ** 2) * (np.sin(np.pi * Z5 / Lz5) ** 2)\n    n5 = f1 * psi1_sq + f2 * psi2_sq\n    N_calc5 = integrate_density(n5, x5, y5, z5)\n    ok5 = abs(N_calc5 - N_target5) = tol\n    results.extend([N_calc5, ok5])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "DFT的预测能力在很大程度上取决于对交换关联 ($E_{xc}$) 泛函所使用的近似。本练习  提供了一种具体的方法来理解两种基石近似——局域密度近似 (LDA) 和广义梯度近似 (GGA) ——之间的实际差异。通过实现这些泛函的简化模型，您将直接计算在GGA中包含密度梯度信息如何影响一个化学上重要的量——分子在催化剂表面的吸附能。",
            "id": "3876786",
            "problem": "要求您设计并实现一个程序，用于计算一个一氧化碳 (CO) 分子吸附在铂 $(111)$ 表面上时，从局域密度近似 (LDA) 迁移到广义梯度近似 (GGA) 引起的吸附能变化。此问题必须从密度泛函理论 (DFT) 的基本原理出发求解，包括 Hohenberg-Kohn 定理和 Kohn-Sham (KS) 方程。您的程序将使用提供的模型交换相关数据来计算该变化，并且必须分析在一小组测试场景中的趋势。\n\n从以下基本基础开始：\n- Hohenberg-Kohn 定理确保了相互作用电子系统的基态能量是基态电子密度 $n(\\mathbf{r})$ 的唯一泛函，并且精确的基态密度使此能量泛函最小化。\n- Kohn-Sham 方程构建了一个无相互作用的电子系统，该系统可以再现真实的基态密度，从而得到形式如下的总能量泛函\n$$\nE[n] = T_{\\mathrm{s}}[n] + \\int v_{\\mathrm{ext}}(\\mathbf{r}) n(\\mathbf{r}) \\, d\\mathbf{r} + E_{\\mathrm{H}}[n] + E_{\\mathrm{xc}}[n],\n$$\n其中 $T_{\\mathrm{s}}[n]$ 是无相互作用动能，$v_{\\mathrm{ext}}(\\mathbf{r})$ 是外势，$E_{\\mathrm{H}}[n]$ 是 Hartree 能量，$E_{\\mathrm{xc}}[n]$ 是交换相关能。\n\nCO 在 Pt$(111)$ 上的吸附能定义为\n$$\nE_{\\mathrm{ads}} = E_{\\mathrm{tot}}^{\\mathrm{slab+CO}} - E_{\\mathrm{tot}}^{\\mathrm{slab}} - E_{\\mathrm{tot}}^{\\mathrm{CO}},\n$$\n当从局域密度近似 (LDA) 迁移到广义梯度近似 (GGA) 时，吸附能的变化为\n$$\n\\Delta E_{\\mathrm{ads}} = E_{\\mathrm{ads}}^{\\mathrm{GGA}} - E_{\\mathrm{ads}}^{\\mathrm{LDA}}.\n$$\n假设 LDA 和 GGA 之间的唯一变化来自交换相关泛函 $E_{\\mathrm{xc}}[n]$，所有其他贡献在这两种近似中保持相同。在此假设下，\n$$\n\\Delta E_{\\mathrm{ads}} = \\left(E_{\\mathrm{xc}}^{\\mathrm{GGA}}(\\mathrm{slab+CO}) - E_{\\mathrm{xc}}^{\\mathrm{GGA}}(\\mathrm{slab}) - E_{\\mathrm{xc}}^{\\mathrm{GGA}}(\\mathrm{CO})\\right) - \\left(E_{\\mathrm{xc}}^{\\mathrm{LDA}}(\\mathrm{slab+CO}) - E_{\\mathrm{xc}}^{\\mathrm{LDA}}(\\mathrm{slab}) - E_{\\mathrm{xc}}^{\\mathrm{LDA}}(\\mathrm{CO})\\right).\n$$\n\n在此问题中，交换相关能量泛函在一个具有体积元 $\\Delta V$ 的均匀网格上被离散化，因此\n$$\nE_{\\mathrm{xc}}[n] \\approx \\sum_{i} n_{i} \\, \\varepsilon_{\\mathrm{xc}}(n_{i}, g_{i}) \\, \\Delta V,\n$$\n其中 $n_{i}$ 是网格点 $i$ 处的电子密度（单位为 电子/立方埃），$g_{i} = \\lvert \\nabla n \\rvert_{i}$ 是网格点 $i$ 处密度梯度的模（单位为 电子/立方埃/埃），而 $\\varepsilon_{\\mathrm{xc}}$ 是每个粒子的交换相关能。使用以下模型形式：\n- 对于局域密度近似 (LDA)，\n$$\n\\varepsilon_{\\mathrm{xc}}^{\\mathrm{LDA}}(n) = -A \\, n^{1/3},\n$$\n其中 $A$ 是一个以电子伏特为单位的正常量。\n- 对于广义梯度近似 (GGA)，使用一个约化梯度修正，\n$$\n\\varepsilon_{\\mathrm{xc}}^{\\mathrm{GGA}}(n, g) = \\frac{\\varepsilon_{\\mathrm{xc}}^{\\mathrm{LDA}}(n)}{1 + C \\, s^{2}},\n$$\n其中 $C$ 是一个正常量，$s$ 是无量纲的约化梯度\n$$\ns = \\frac{g}{2 k_{\\mathrm{F}}(n) \\, n}, \\quad k_{\\mathrm{F}}(n) = \\left(3 \\pi^{2} n\\right)^{1/3}.\n$$\n当 $n = 0$ 时，定义约化梯度 $s = 0$，且该网格点对 $E_{\\mathrm{xc}}$ 的贡献为零。\n\n单位和数值说明：\n- 以电子伏特 ($\\mathrm{eV}$) 表示 $\\Delta E_{\\mathrm{ads}}$，四舍五入到六位小数。\n- 不涉及角度；无需角度单位。\n- 不涉及百分比；不要使用百分号。\n\n测试套件和输入数据：\n对于每个测试用例，您将获得 $(A, C, \\Delta V)$ 以及用于系统 $(\\mathrm{slab+CO})$、$(\\mathrm{slab})$ 和 $(\\mathrm{CO})$ 的三个有限网格，每个网格由密度和梯度数组表示。请使用以下数据。\n\n案例 1 (中等梯度，典型场景)：\n- $A = 0.75$, $C = 0.30$, $\\Delta V = 1.0$。\n- $(\\mathrm{slab+CO})$: $n = [\\,0.10,\\,0.12,\\,0.15,\\,0.08,\\,0.20,\\,0.18\\,]$, $g = [\\,0.05,\\,0.08,\\,0.10,\\,0.04,\\,0.12,\\,0.09\\,]$。\n- $(\\mathrm{slab})$: $n = [\\,0.09,\\,0.11,\\,0.14,\\,0.08,\\,0.19,\\,0.17\\,]$, $g = [\\,0.04,\\,0.07,\\,0.08,\\,0.04,\\,0.10,\\,0.08\\,]$。\n- $(\\mathrm{CO})$: $n = [\\,0.01,\\,0.01,\\,0.01,\\,0.00,\\,0.01,\\,0.01\\,]$, $g = [\\,0.01,\\,0.01,\\,0.02,\\,0.00,\\,0.02,\\,0.01\\,]$。\n\n案例 2 (边界情况，零梯度)：\n- $A = 0.75$, $C = 0.30$, $\\Delta V = 1.0$。\n- $(\\mathrm{slab+CO})$: $n = [\\,0.10,\\,0.12,\\,0.15,\\,0.08\\,]$, $g = [\\,0.00,\\,0.00,\\,0.00,\\,0.00\\,]$。\n- $(\\mathrm{slab})$: $n = [\\,0.09,\\,0.11,\\,0.14,\\,0.08\\,]$, $g = [\\,0.00,\\,0.00,\\,0.00,\\,0.00\\,]$。\n- $(\\mathrm{CO})$: $n = [\\,0.01,\\,0.01,\\,0.01,\\,0.00\\,]$, $g = [\\,0.00,\\,0.00,\\,0.00,\\,0.00\\,]$。\n\n案例 3 (高梯度局域于吸附位点附近)：\n- $A = 0.75$, $C = 0.30$, $\\Delta V = 1.0$。\n- $(\\mathrm{slab+CO})$: $n = [\\,0.10,\\,0.12,\\,0.15,\\,0.08,\\,0.20,\\,0.18,\\,0.25,\\,0.22\\,]$, $g = [\\,0.20,\\,0.25,\\,0.30,\\,0.15,\\,0.35,\\,0.28,\\,0.40,\\,0.33\\,]$。\n- $(\\mathrm{slab})$: $n = [\\,0.09,\\,0.11,\\,0.14,\\,0.08,\\,0.19,\\,0.17,\\,0.24,\\,0.21\\,]$, $g = [\\,0.08,\\,0.10,\\,0.12,\\,0.06,\\,0.14,\\,0.12,\\,0.16,\\,0.14\\,]$。\n- $(\\mathrm{CO})$: $n = [\\,0.01,\\,0.01,\\,0.01,\\,0.00,\\,0.01,\\,0.01,\\,0.01,\\,0.01\\,]$, $g = [\\,0.03,\\,0.04,\\,0.05,\\,0.00,\\,0.05,\\,0.04,\\,0.06,\\,0.05\\,]$。\n\n案例 4 (边缘情况，真空尾部和近零密度)：\n- $A = 0.75$, $C = 0.30$, $\\Delta V = 1.0$。\n- $(\\mathrm{slab+CO})$: $n = [\\,0.00,\\,0.002,\\,0.005,\\,0.000,\\,0.001\\,]$, $g = [\\,0.000,\\,0.008,\\,0.012,\\,0.000,\\,0.006\\,]$。\n- $(\\mathrm{slab})$: $n = [\\,0.00,\\,0.0015,\\,0.0035,\\,0.000,\\,0.0008\\,]$, $g = [\\,0.000,\\,0.006,\\,0.010,\\,0.000,\\,0.004\\,]$。\n- $(\\mathrm{CO})$: $n = [\\,0.00,\\,0.0005,\\,0.0015,\\,0.000,\\,0.0003\\,]$, $g = [\\,0.000,\\,0.003,\\,0.005,\\,0.000,\\,0.002\\,]$。\n\n程序要求：\n- 根据上述模型实现 $E_{\\mathrm{xc}}^{\\mathrm{LDA}}$ 和 $E_{\\mathrm{xc}}^{\\mathrm{GGA}}$ 的计算。\n- 计算每种情况下的 $\\Delta E_{\\mathrm{ads}}$。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 $[x_{1},x_{2},x_{3},x_{4}]$，其中每个 $x_{i}$ 是测试案例 $i$ 的 $\\Delta E_{\\mathrm{ads}}$ 值（单位为 $\\mathrm{eV}$），并四舍五入到六位小数。",
            "solution": "核心任务是计算当理论描述从局域密度近似 (LDA) 变为广义梯度近似 (GGA) 时，一个 $\\mathrm{CO}$ 分子在 $\\mathrm{Pt}(111)$ 表面上的吸附能变化，记为 $\\Delta E_{\\mathrm{ads}}$。该问题从密度泛函理论 (DFT) 的基本原理入手解决。\n\n吸附能定义为组合系统的总能量减去孤立组分的总能量之和：\n$$\nE_{\\mathrm{ads}} = E_{\\mathrm{tot}}^{\\mathrm{slab+CO}} - E_{\\mathrm{tot}}^{\\mathrm{slab}} - E_{\\mathrm{tot}}^{\\mathrm{CO}}\n$$\n这个量的变化 $\\Delta E_{\\mathrm{ads}}$，是 GGA 吸附能与 LDA 吸附能之差：\n$$\n\\Delta E_{\\mathrm{ads}} = E_{\\mathrm{ads}}^{\\mathrm{GGA}} - E_{\\mathrm{ads}}^{\\mathrm{LDA}}\n$$\n问题规定了一个关键的简化假设：动能 ($T_s[n]$)、外势能和 Hartree 能量 ($E_H[n]$) 的泛函在 LDA 和 GGA 计算中是相同的，因此在求差时会相互抵消。这个近似将变化隔离到交换相关 ($E_{\\mathrm{xc}}$) 泛函上。因此，$\\Delta E_{\\mathrm{ads}}$ 的表达式简化为交换相关能量贡献的差值：\n$$\n\\Delta E_{\\mathrm{ads}} = \\left(E_{\\mathrm{xc}}^{\\mathrm{GGA}}(\\mathrm{slab+CO}) - E_{\\mathrm{xc}}^{\\mathrm{GGA}}(\\mathrm{slab}) - E_{\\mathrm{xc}}^{\\mathrm{GGA}}(\\mathrm{CO})\\right) - \\left(E_{\\mathrm{xc}}^{\\mathrm{LDA}}(\\mathrm{slab+CO}) - E_{\\mathrm{xc}}^{\\mathrm{LDA}}(\\mathrm{slab}) - E_{\\mathrm{xc}}^{\\mathrm{LDA}}(\\mathrm{CO})\\right)\n$$\n这个表达式可以通过对每个系统分组来方便地重新排列：\n$$\n\\Delta E_{\\mathrm{ads}} = \\left(E_{\\mathrm{xc}}^{\\mathrm{GGA}}(\\mathrm{slab+CO}) - E_{\\mathrm{xc}}^{\\mathrm{LDA}}(\\mathrm{slab+CO})\\right) - \\left(E_{\\mathrm{xc}}^{\\mathrm{GGA}}(\\mathrm{slab}) - E_{\\mathrm{xc}}^{\\mathrm{LDA}}(\\mathrm{slab})\\right) - \\left(E_{\\mathrm{xc}}^{\\mathrm{GGA}}(\\mathrm{CO}) - E_{\\mathrm{xc}}^{\\mathrm{LDA}}(\\mathrm{CO})\\right)\n$$\n我们将单个系统在 GGA 和 LDA 之间的交换相关能之差定义为 $\\Delta E_{\\mathrm{xc}}^{\\mathrm{sys}} = E_{\\mathrm{xc}}^{\\mathrm{GGA}}(\\mathrm{sys}) - E_{\\mathrm{xc}}^{\\mathrm{LDA}}(\\mathrm{sys})$。吸附能变化的最终表达式变为：\n$$\n\\Delta E_{\\mathrm{ads}} = \\Delta E_{\\mathrm{xc}}^{\\mathrm{slab+CO}} - \\Delta E_{\\mathrm{xc}}^{\\mathrm{slab}} - \\Delta E_{\\mathrm{xc}}^{\\mathrm{CO}}\n$$\n我们的主要任务是使用提供的离散化数据和模型泛函，为三个系统——组合系统 ($\\mathrm{slab+CO}$)、表面 ($\\mathrm{slab}$) 和分子 ($\\mathrm{CO}$)——中的每一个计算 $\\Delta E_{\\mathrm{xc}}$。\n\n交换相关能由离散网格点 $i$ 的总和给出：\n$$\nE_{\\mathrm{xc}}[n] \\approx \\sum_{i} n_{i} \\, \\varepsilon_{\\mathrm{xc}}(n_{i}, g_{i}) \\, \\Delta V\n$$\n其中 $n_i$ 是电子密度，$g_i = \\lvert \\nabla n \\rvert_i$ 是密度梯度的模，$\\Delta V$ 是体积元。\n\nLDA 单位粒子能量的模型是：\n$$\n\\varepsilon_{\\mathrm{xc}}^{\\mathrm{LDA}}(n) = -A \\, n^{1/3}\n$$\nGGA 单位粒子能量的模型包含一个梯度修正：\n$$\n\\varepsilon_{\\mathrm{xc}}^{\\mathrm{GGA}}(n, g) = \\frac{\\varepsilon_{\\mathrm{xc}}^{\\mathrm{LDA}}(n)}{1 + C \\, s^{2}}\n$$\n其中 $s$ 是无量纲的约化梯度：\n$$\ns = \\frac{g}{2 k_{\\mathrm{F}}(n) \\, n}\n$$\n其中费米波矢为 $k_{\\mathrm{F}}(n) = (3 \\pi^{2} n)^{1/3}$。\n\n我们现在可以为 $\\Delta E_{\\mathrm{xc}}^{\\mathrm{sys}}$ 构建一个显式表达式。对于单个系统，其差值为：\n$$\n\\Delta E_{\\mathrm{xc}} = E_{\\mathrm{xc}}^{\\mathrm{GGA}} - E_{\\mathrm{xc}}^{\\mathrm{LDA}} = \\sum_{i} \\left( n_{i} \\varepsilon_{\\mathrm{xc}}^{\\mathrm{GGA}}(n_i, g_i) - n_i \\varepsilon_{\\mathrm{xc}}^{\\mathrm{LDA}}(n_i) \\right) \\Delta V\n$$\n代入 $\\varepsilon_{\\mathrm{xc}}^{\\mathrm{GGA}}$ 的表达式：\n$$\n\\Delta E_{\\mathrm{xc}} = \\sum_{i} n_{i} \\left( \\frac{\\varepsilon_{\\mathrm{xc}}^{\\mathrm{LDA}}(n_i)}{1 + C s_i^2} - \\varepsilon_{\\mathrm{xc}}^{\\mathrm{LDA}}(n_i) \\right) \\Delta V\n$$\n提取公因子 $\\varepsilon_{\\mathrm{xc}}^{\\mathrm{LDA}}(n_i)$：\n$$\n\\Delta E_{\\mathrm{xc}} = \\sum_{i} n_{i} \\varepsilon_{\\mathrm{xc}}^{\\mathrm{LDA}}(n_i) \\left( \\frac{1}{1 + C s_i^2} - 1 \\right) \\Delta V = \\sum_{i} n_{i} \\varepsilon_{\\mathrm{xc}}^{\\mathrm{LDA}}(n_i) \\left( \\frac{1 - (1 + C s_i^2)}{1 + C s_i^2} \\right) \\Delta V\n$$\n$$\n\\Delta E_{\\mathrm{xc}} = \\sum_{i} n_{i} (-A n_i^{1/3}) \\left( \\frac{-C s_i^2}{1 + C s_i^2} \\right) \\Delta V\n$$\n这简化为系统 GGA-LDA 能量差的更直接公式：\n$$\n\\Delta E_{\\mathrm{xc}}^{\\mathrm{sys}} = \\sum_{i} A n_i^{4/3} \\left( \\frac{C s_i^2}{1 + C s_i^2} \\right) \\Delta V\n$$\n每个测试案例的计算过程如下：\n1. 对于每个系统（$\\mathrm{slab+CO}$、$\\mathrm{slab}$ 和 $\\mathrm{CO}$），使用推导出的公式计算 $\\Delta E_{\\mathrm{xc}}^{\\mathrm{sys}}$。\n2. $\\Delta E_{\\mathrm{xc}}^{\\mathrm{sys}}$ 的计算涉及遍历系统数据数组中的每个网格点 $i$。\n3. 对于密度 $n_i  0$ 的每个网格点 $i$：\n    a. 计算费米波矢 $k_{\\mathrm{F}}(n_i) = (3 \\pi^2 n_i)^{1/3}$。\n    b. 计算约化梯度 $s_i = g_i / (2 k_{\\mathrm{F}}(n_i) n_i)$。\n    c. 计算对总和的贡献：$A n_i^{4/3} \\frac{C s_i^2}{1 + C s_i^2} \\Delta V$。\n4. 对于任何 $n_i = 0$ 的网格点，其对任何交换相关能的贡献均为零，这既是问题的规定，也为通用 $E_{\\mathrm{xc}}$ 表达式中的 $n_i$ 因子所证实。我们推導出的 $\\Delta E_{\\mathrm{xc}}^{\\mathrm{sys}}$ 公式也因 $n_i^{4/3}$ 项而得出零贡献。\n5. 将所有网格点的这些贡献相加，得到 $\\Delta E_{\\mathrm{xc}}^{\\mathrm{sys}}$。\n6. 一旦计算出 $\\Delta E_{\\mathrm{xc}}^{\\mathrm{slab+CO}}$、$\\Delta E_{\\mathrm{xc}}^{\\mathrm{slab}}$ 和 $\\Delta E_{\\mathrm{xc}}^{\\mathrm{CO}}$，便可使用 $\\Delta E_{\\mathrm{ads}} = \\Delta E_{\\mathrm{xc}}^{\\mathrm{slab+CO}} - \\Delta E_{\\mathrm{xc}}^{\\mathrm{slab}} - \\Delta E_{\\mathrm{xc}}^{\\mathrm{CO}}$ 求得最终答案。\n7. 每个案例的最终结果四舍五入到六位小数。\n\n此过程将应用于所提供的四个测试案例中的每一个，使用它们各自的参数 $(A, C, \\Delta V)$ 以及 $n$ 和 $g$ 的数据数组。\n对于案例 2，其中所有梯度 $g_i$ 均为零，这意味着所有点的 $s_i=0$。项 $\\frac{C s_i^2}{1+C s_i^2}$ 变为零，导致所有三个系统的 $\\Delta E_{\\mathrm{xc}}^{\\mathrm{sys}}=0$。因此，该案例的 $\\Delta E_{\\mathrm{ads}}$ 将为 $0$，这是预期的结果，因为当密度梯度消失时，GGA 泛函会退化为 LDA。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the change in adsorption energy from LDA to GGA DFT.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"params\": {\"A\": 0.75, \"C\": 0.30, \"delta_V\": 1.0},\n            \"systems\": {\n                \"slab+CO\": {\n                    \"n\": np.array([0.10, 0.12, 0.15, 0.08, 0.20, 0.18]),\n                    \"g\": np.array([0.05, 0.08, 0.10, 0.04, 0.12, 0.09]),\n                },\n                \"slab\": {\n                    \"n\": np.array([0.09, 0.11, 0.14, 0.08, 0.19, 0.17]),\n                    \"g\": np.array([0.04, 0.07, 0.08, 0.04, 0.10, 0.08]),\n                },\n                \"CO\": {\n                    \"n\": np.array([0.01, 0.01, 0.01, 0.00, 0.01, 0.01]),\n                    \"g\": np.array([0.01, 0.01, 0.02, 0.00, 0.02, 0.01]),\n                },\n            },\n        },\n        {\n            \"params\": {\"A\": 0.75, \"C\": 0.30, \"delta_V\": 1.0},\n            \"systems\": {\n                \"slab+CO\": {\n                    \"n\": np.array([0.10, 0.12, 0.15, 0.08]),\n                    \"g\": np.array([0.00, 0.00, 0.00, 0.00]),\n                },\n                \"slab\": {\n                    \"n\": np.array([0.09, 0.11, 0.14, 0.08]),\n                    \"g\": np.array([0.00, 0.00, 0.00, 0.00]),\n                },\n                \"CO\": {\n                    \"n\": np.array([0.01, 0.01, 0.01, 0.00]),\n                    \"g\": np.array([0.00, 0.00, 0.00, 0.00]),\n                },\n            },\n        },\n        {\n            \"params\": {\"A\": 0.75, \"C\": 0.30, \"delta_V\": 1.0},\n            \"systems\": {\n                \"slab+CO\": {\n                    \"n\": np.array([0.10, 0.12, 0.15, 0.08, 0.20, 0.18, 0.25, 0.22]),\n                    \"g\": np.array([0.20, 0.25, 0.30, 0.15, 0.35, 0.28, 0.40, 0.33]),\n                },\n                \"slab\": {\n                    \"n\": np.array([0.09, 0.11, 0.14, 0.08, 0.19, 0.17, 0.24, 0.21]),\n                    \"g\": np.array([0.08, 0.10, 0.12, 0.06, 0.14, 0.12, 0.16, 0.14]),\n                },\n                \"CO\": {\n                    \"n\": np.array([0.01, 0.01, 0.01, 0.00, 0.01, 0.01, 0.01, 0.01]),\n                    \"g\": np.array([0.03, 0.04, 0.05, 0.00, 0.05, 0.04, 0.06, 0.05]),\n                },\n            },\n        },\n        {\n            \"params\": {\"A\": 0.75, \"C\": 0.30, \"delta_V\": 1.0},\n            \"systems\": {\n                \"slab+CO\": {\n                    \"n\": np.array([0.00, 0.002, 0.005, 0.000, 0.001]),\n                    \"g\": np.array([0.000, 0.008, 0.012, 0.000, 0.006]),\n                },\n                \"slab\": {\n                    \"n\": np.array([0.00, 0.0015, 0.0035, 0.000, 0.0008]),\n                    \"g\": np.array([0.000, 0.006, 0.010, 0.000, 0.004]),\n                },\n                \"CO\": {\n                    \"n\": np.array([0.00, 0.0005, 0.0015, 0.000, 0.0003]),\n                    \"g\": np.array([0.000, 0.003, 0.005, 0.000, 0.002]),\n                },\n            },\n        },\n    ]\n\n    def calculate_delta_exc(n_grid, g_grid, A, C, delta_V):\n        \"\"\"\n        Calculates Delta E_xc = E_xc^GGA - E_xc^LDA for a single system.\n        \"\"\"\n        total_delta_exc = 0.0\n        for i in range(len(n_grid)):\n            n = n_grid[i]\n            g = g_grid[i]\n\n            if n == 0.0:\n                continue\n\n            # Calculate Fermi wavevector, k_F = (3 * pi^2 * n)^(1/3)\n            kF = (3 * np.pi**2 * n)**(1/3)\n            \n            # Calculate dimensionless reduced gradient, s = g / (2 * k_F * n)\n            s = g / (2 * kF * n)\n            \n            # Calculate the contribution to Delta E_xc from this grid point\n            # Delta E_xc_i = A * n^(4/3) * (C * s^2 / (1 + C * s^2)) * delta_V\n            term = A * n**(4/3)\n            correction_factor = (C * s**2) / (1 + C * s**2)\n            \n            total_delta_exc += term * correction_factor * delta_V\n            \n        return total_delta_exc\n\n    results = []\n    for case in test_cases:\n        params = case[\"params\"]\n        systems = case[\"systems\"]\n        \n        A = params[\"A\"]\n        C = params[\"C\"]\n        delta_V = params[\"delta_V\"]\n        \n        delta_exc_slab_co = calculate_delta_exc(\n            systems[\"slab+CO\"][\"n\"], systems[\"slab+CO\"][\"g\"], A, C, delta_V\n        )\n        \n        delta_exc_slab = calculate_delta_exc(\n            systems[\"slab\"][\"n\"], systems[\"slab\"][\"g\"], A, C, delta_V\n        )\n        \n        delta_exc_co = calculate_delta_exc(\n            systems[\"CO\"][\"n\"], systems[\"CO\"][\"g\"], A, C, delta_V\n        )\n        \n        # Delta E_ads = Delta E_xc(slab+CO) - Delta E_xc(slab) - Delta E_xc(CO)\n        delta_E_ads = delta_exc_slab_co - delta_exc_slab - delta_exc_co\n        \n        results.append(round(delta_E_ads, 6))\n\n    # Format the final output string\n    print(f\"[{','.join(map(str, results))}]\")\n\n\nsolve()\n```"
        },
        {
            "introduction": "Kohn-Sham方程是通过自洽场 (SCF) 程序求解的，这是一个迭代过程，其收敛可能具有挑战性，特别是对于容易出现“电荷振荡”不稳定性的金属体系。这项高级练习  揭示了DFT计算中这一关键方面的神秘面纱。通过使用一个物理上合理的体系响应模型，您将探索如何优化算法参数（如混合和预处理）来抑制这些不稳定性，并加速获得收敛解的过程。",
            "id": "3876845",
            "problem": "考虑一个自洽场（SCF）程序，用于求解由密度泛函理论（DFT）产生的 Kohn-Sham 方程，该程序应用于带吸附物的催化表面平板模型。Hohenberg-Kohn 定理确立了基态电子密度 $n(\\mathbf{r})$ 唯一地决定了系统的所有性质，而 Kohn-Sham 构造将相互作用的电子问题映射到一个在有效势 $v_{\\mathrm{KS}}[n](\\mathbf{r})$ 中的非相互作用系统。一个实用的自洽场算法对密度迭代一个不动点映射，$n^{(k+1)}(\\mathbf{r}) = \\mathcal{G}[n^{(k)}](\\mathbf{r})$，其中 $\\mathcal{G}$ 表示从 $n^{(k)}(\\mathbf{r})$ 构建 Kohn-Sham 哈密顿量，求解 Kohn-Sham 轨道，并构建输出密度。将残差定义为 $R[n] = \\mathcal{G}[n] - n$。在不动点 $n^\\star(\\mathbf{r})$ 附近进行线性化，得到误差演化 $e^{(k+1)}(\\mathbf{r}) \\approx \\left(I - \\alpha \\mathcal{P}\\mathcal{J}\\right)e^{(k)}(\\mathbf{r})$，其中 $e^{(k)} = n^{(k)} - n^\\star$，$\\alpha$ 是一个标量混合参数，$\\mathcal{P}$ 是一个预处理器，而 $\\mathcal{J} = \\left.\\delta R/\\delta n\\right|_{n^\\star}$ 是残差映射的雅可比矩阵。\n\n假设使用平面波表示，使得由波矢大小 $q$ 标记的傅里叶模式在线性化下解耦。在此基底下，将 $\\mathcal{J}$ 的特征值写为 $\\lambda(q)$，预处理器写为 $P(q;k_s)$，其中 $k_s$ 是一个屏蔽参数。对于 Kerker 型预处理， $P(q;k_s) = q^2/(q^2 + k_s^2)$。于是，每个傅里叶误差分量的演化为 $e_{q}^{(k+1)} \\approx \\left(1 - \\alpha P(q;k_s)\\lambda(q)\\right) e_{q}^{(k)}$。渐近线性收敛因子是谱半径 $\\rho(\\alpha,k_s) = \\max_{q \\in \\mathcal{Q}} \\left|1 - \\alpha P(q;k_s)\\lambda(q)\\right|$，其中 $\\mathcal{Q}$ 是相关波矢的集合。如果 $\\rho(\\alpha,k_s) \\ge 1$，则线性化迭代是不稳定的。如果 $\\rho(\\alpha,k_s)  1$，则将误差范数减小一个因子 $\\delta \\in (0,1)$ 所需的迭代次数 $N$ 满足 $N \\ge \\left\\lceil \\log(\\delta) / \\log(\\rho(\\alpha,k_s)) \\right\\rceil$。\n\n给定一个简化的、具有物理动机的表面吸附计算模型，其中有效响应特征值被建模为 $\\lambda(q) = \\lambda_0 + \\lambda_1/(q^2 + \\eta)$，参数 $\\lambda_0  0$、$\\lambda_1  0$ 和 $\\eta  0$ 被选择用来代表类金属的晃动行为（大的 $\\lambda_1$ 和小的 $\\eta$）或类半导体的行为（较小的 $\\lambda_1$ 和较大的 $\\eta$）。预处理器是 Kerker 滤波器 $P(q;k_s) = q^2/(q^2 + k_s^2)$，屏蔽参数 $k_s \\ge 0$。简单混合参数是 $\\alpha \\in (0,1]$。\n\n您的任务是，对于下面的每个测试用例，在一个离散的 $(\\alpha,k_s)$ 网格上计算谱半径 $\\rho(\\alpha,k_s)$ 和预测的迭代次数 $N(\\alpha,k_s,\\delta)$，然后选择使 $N$ 最小化的 $(\\alpha,k_s)$。如果多个 $(\\alpha,k_s)$ 产生相同的最小 $N$，则通过选择具有最小 $\\rho$，然后是最小 $\\alpha$，再然后是最小 $k_s$ 的那个来打破僵局。如果网格上没有 $(\\alpha,k_s)$ 使得 $\\rho  1$，则报告该方案在此网格上不收敛。\n\n使用的基本基础和定义：\n- Hohenberg-Kohn 定理保证了最小化 $n(\\mathbf{r})$ 的能量泛函可以得到基态；Kohn-Sham 方程定义了一个不动点映射 $n \\mapsto \\mathcal{G}[n]$。\n- 线性不动点迭代 $x^{(k+1)} = M x^{(k)}$ 在 $M$ 的谱半径小于1时收敛。\n- 对于带有简单混合和线性预处理器的自洽场迭代，在傅里叶空间中，每个模式的误差放大因子是 $1 - \\alpha P(q;k_s)\\lambda(q)$。\n- $N$ 步后渐近误差减小因子约为 $\\rho^N$，要将误差范数减小一个因子 $\\delta$，需要 $N \\ge \\lceil \\log(\\delta)/\\log(\\rho) \\rceil$（当 $0  \\rho  1$ 时）。\n\n单位和数值要求：\n- 波矢 $q$ 和屏蔽参数 $k_s$ 必须以逆埃单位 $\\mathrm{\\AA}^{-1}$ 处理。\n- 混合参数 $\\alpha$ 是无量纲的。\n- 谱半径 $\\rho$ 是无量纲的。\n- 迭代次数 $N$ 是一个无量纲整数。\n- 目标误差减小因子是 $\\delta \\in (0,1)$ 且无量纲。\n\n强制执行的实现细节：\n- 对每个指定的测试用例使用模型 $\\lambda(q) = \\lambda_0 + \\lambda_1/(q^2 + \\eta)$。\n- 对 $k_s \\ge 0$ 使用 $P(q;k_s) = q^2/(q^2 + k_s^2)$。对于 $k_s = 0$，当 $q  0$ 时取 $P(q;0) = 1$。\n- 对于给定的参数对 $(\\alpha,k_s)$，计算 $\\rho(\\alpha,k_s) = \\max_{q \\in \\mathcal{Q}} |1 - \\alpha P(q;k_s)\\lambda(q)|$。\n- 如果 $\\rho(\\alpha,k_s)  1$，计算 $N(\\alpha,k_s,\\delta) = \\left\\lceil \\log(\\delta)/\\log(\\rho(\\alpha,k_s)) \\right\\rceil$。如果 $\\rho(\\alpha,k_s) = 0$，定义 $N = 1$。\n- 如果网格上没有 $(\\alpha,k_s)$ 使得 $\\rho  1$，则返回 $\\rho_{\\min} = +\\infty$, $N_{\\min} = -1$, $\\alpha_{\\mathrm{opt}} = -1$, $k_{s,\\mathrm{opt}} = -1$。\n\n测试套件：\n- 情况 1（带吸附物的金属板）：$\\mathcal{Q} = \\{0.05, 0.10, 0.20, 0.50, 1.00\\}$ $\\mathrm{\\AA}^{-1}$，$\\lambda_0 = 0.2$，$\\lambda_1 = 5.0$，$\\eta = 0.02$。\n- 情况 2（带吸附物的半导体板）：$\\mathcal{Q} = \\{0.05, 0.10, 0.20, 0.50, 1.00\\}$ $\\mathrm{\\AA}^{-1}$，$\\lambda_0 = 0.2$，$\\lambda_1 = 0.5$，$\\eta = 0.20$。\n- 情况 3（金属上的强极性吸附物）：$\\mathcal{Q} = \\{0.05, 0.10, 0.20, 0.50, 1.00\\}$ $\\mathrm{\\AA}^{-1}$，$\\lambda_0 = 0.2$，$\\lambda_1 = 20.0$，$\\eta = 0.02$。\n\n要搜索的参数网格：\n- $\\alpha \\in \\{0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0\\}$（无量纲）。\n- $k_s \\in \\{0.0, 0.2, 0.5, 1.0, 2.0\\}$ $\\mathrm{\\AA}^{-1}$。\n\n所有情况的目标误差减小量：\n- $\\delta = 10^{-6}$（无量纲）。\n\n要求的程序输出：\n- 对于三个情况中的每一个，在给定的网格上计算最优设置，并报告一个列表 $[\\rho_{\\min}, N_{\\min}, \\alpha_{\\mathrm{opt}}, k_{s,\\mathrm{opt}}]$，其中 $\\rho_{\\min}$ 四舍五入到六位小数， $N_{\\min}$ 是一个整数，$\\alpha_{\\mathrm{opt}}$ 和 $k_{s,\\mathrm{opt}}$ 四舍五入到三位小数。\n- 您的程序应生成单行输出，其中包含这三个列表组成的逗号分隔列表，并用方括号括起来（例如，$[[\\rho_1,N_1,\\alpha_1,k_{s,1}],[\\rho_2,N_2,\\alpha_2,k_{s,2}],[\\rho_3,N_3,\\alpha_3,k_{s,3}]]$）。",
            "solution": "用户提供的问题陈述已经过验证，被认为是有效的。该问题在科学上基于密度泛函理论（DFT）的原理以及求解 Kohn-Sham 方程的数值方法。它是一个适定问题，提供了所有必要的模型、参数和约束，以得到唯一解。其语言客观，任务是一个可形式化的优化问题。\n\n目标是从一个离散网格中找到最优的简单混合参数 $\\alpha$ 和 Kerker 预处理参数 $k_s$，以最小化达到指定误差减小量 $\\delta$ 所需的自洽场（SCF）迭代次数 $N$。这是计算催化和材料科学中一个常见的实际问题。\n\n该分析取决于自洽场循环的线性化收敛性。对于一组给定的参数 $(\\alpha, k_s)$，收敛性由迭代矩阵的谱半径 $\\rho(\\alpha, k_s)$ 决定。当且仅当 $\\rho(\\alpha, k_s)  1$ 时，迭代是稳定的。谱半径定义为在所有相关傅里叶模式上误差放大因子的最大幅值，这些模式由波矢大小 $q$ 索引。\n模式 $q$ 的误差放大因子由下式给出：\n$$ A_q(\\alpha, k_s) = \\left|1 - \\alpha P(q;k_s)\\lambda(q)\\right| $$\n谱半径则为：\n$$ \\rho(\\alpha, k_s) = \\max_{q \\in \\mathcal{Q}} A_q(\\alpha, k_s) $$\n其中 $\\mathcal{Q}$ 是相关波矢的离散集合。\n\n问题为雅可比矩阵特征值 $\\lambda(q)$ 和预处理器 $P(q;k_s)$ 提供了以下模型：\n1.  **雅可比特征值模型**：此模型用于模拟系统的响应。\n    $$ \\lambda(q) = \\lambda_0 + \\frac{\\lambda_1}{q^2 + \\eta} $$\n    其中 $\\lambda_0$、$\\lambda_1$ 和 $\\eta$ 是与系统相关的参数。\n2.  **Kerker 预处理器**：此预处理器旨在抑制电荷振荡不稳定性，这种不稳定性对应于小 $q$ 值下的大 $\\lambda(q)$ 值。\n    $$ P(q; k_s) = \\frac{q^2}{q^2 + k_s^2} $$\n    其中 $k_s$ 是屏蔽参数。对于 $k_s = 0$ 的特殊情况，预处理器变为 $P(q; 0) = 1$（对于 $q > 0$），这对应于不带预处理的简单混合。\n\n将误差度量减小因子 $\\delta$ 所需的迭代次数 $N$ 与谱半径 $\\rho$ 的关系如下：\n$$ N(\\alpha, k_s, \\delta) = \\left\\lceil \\frac{\\log(\\delta)}{\\log(\\rho(\\alpha, k_s))} \\right\\rceil $$\n此公式在 $0  \\rho  1$ 时有效。对于 $\\rho = 0$ 的情况，误差在单步内消除，因此 $N = 1$。如果 $\\rho \\ge 1$，迭代发散，我们认为迭代次数为无穷大。\n\n解决策略是针对每个测试用例，在所提供的 $\\alpha$ 和 $k_s$ 离散集合上执行网格搜索。\n对于每个测试用例，我们定义参数 $(\\lambda_0, \\lambda_1, \\eta)$ 和波矢集合 $\\mathcal{Q}$。\n我们初始化一个变量来保存目前找到的最佳参数，例如，一个元组 `(best_N, best_rho, best_alpha, best_ks)`，其初始值对应于发散情况（例如 $(\\infty, \\infty, -1, -1)$）。\n\n算法流程如下：\n1.  遍历每个测试用例。\n2.  对于当前测试用例，遍历其网格中的每个 $\\alpha$ 值。\n3.  对于每个 $\\alpha$，遍历其网格中的每个 $k_s$ 值。\n4.  对于当前参数对 $(\\alpha, k_s)$：\n    a. 使用提供的 $\\lambda(q)$ 和 $P(q;k_s)$ 模型，计算所有 $q \\in \\mathcal{Q}$ 的每个模式的放大因子 $A_q(\\alpha, k_s)$。\n    b. 通过找到这些放大因子的最大值来确定谱半径 $\\rho(\\alpha, k_s)$。\n    c. 检查收敛性：如果 $\\rho(\\alpha, k_s)  1$：\n        i.  计算迭代次数 $N$。如果 $\\rho(\\alpha, k_s) = 0$，则设置 $N=1$。否则，计算 $N = \\lceil \\log(\\delta) / \\log(\\rho(\\alpha, k_s)) \\rceil$。\n        ii. 将当前结果 $(N, \\rho, \\alpha, k_s)$ 与目前找到的最佳结果进行比较。问题指定了字典序的决胜规则：首先最小化 $N$，然后是 $\\rho$，接着是 $\\alpha$，最后是 $k_s$。如果新结果的 $N$ 更小，则它更优；如果 $N$ 相等，则比较 $\\rho$，以此类推。\n        iii. 如果当前结果更优，则更新存储的最佳参数。\n5.  在遍历完一个测试用例的整个 $(\\alpha, k_s)$ 网格后：\n    a. 如果没有找到收敛的参数（即初始的“最佳”值从未被更新），则此用例的结果为 $(\\rho_{\\min}, N_{\\min}, \\alpha_{\\mathrm{opt}}, k_{s,\\mathrm{opt}}) = (\\infty, -1, -1, -1)$。\n    b. 否则，结果为找到的最佳参数集。\n6.  最终输出是一个列表，其中包含三个测试用例的结果列表，并根据指定的精度进行格式化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DFT SCF convergence optimization problem for three test cases.\n    \"\"\"\n    # Define the grid of parameters to search\n    alpha_grid = np.array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0])\n    ks_grid = np.array([0.0, 0.2, 0.5, 1.0, 2.0])\n\n    # Define the target error reduction\n    delta = 1e-6\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Case 1 (metallic)\",\n            \"Q\": np.array([0.05, 0.10, 0.20, 0.50, 1.00]),\n            \"lambda0\": 0.2, \"lambda1\": 5.0, \"eta\": 0.02\n        },\n        {\n            \"name\": \"Case 2 (semiconducting)\",\n            \"Q\": np.array([0.05, 0.10, 0.20, 0.50, 1.00]),\n            \"lambda0\": 0.2, \"lambda1\": 0.5, \"eta\": 0.20\n        },\n        {\n            \"name\": \"Case 3 (strongly polar)\",\n            \"Q\": np.array([0.05, 0.10, 0.20, 0.50, 1.00]),\n            \"lambda0\": 0.2, \"lambda1\": 20.0, \"eta\": 0.02\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        q_vectors = case[\"Q\"]\n        lambda0 = case[\"lambda0\"]\n        lambda1 = case[\"lambda1\"]\n        eta = case[\"eta\"]\n\n        # Initialize tracking for the best parameters for this case\n        # (N, rho, alpha, ks) tuple allows for lexicographical comparison\n        best_params_tuple = (float('inf'), float('inf'), -1.0, -1.0)\n\n        for alpha in alpha_grid:\n            for ks in ks_grid:\n                # Calculate lambda(q) for all q in Q\n                lambda_q = lambda0 + lambda1 / (q_vectors**2 + eta)\n\n                # Calculate P(q; k_s) based on k_s value\n                if ks == 0.0:\n                    P_q_ks = np.ones_like(q_vectors)\n                else:\n                    P_q_ks = q_vectors**2 / (q_vectors**2 + ks**2)\n                \n                # Calculate amplification factors for all modes\n                amp_factors = np.abs(1.0 - alpha * P_q_ks * lambda_q)\n\n                # Spectral radius is the maximum amplification factor\n                rho = np.max(amp_factors)\n\n                if rho  1.0:\n                    # Convergent case\n                    if rho == 0.0:\n                        N = 1\n                    else:\n                        N = np.ceil(np.log(delta) / np.log(rho))\n                    \n                    current_params_tuple = (N, rho, alpha, ks)\n                    \n                    # Compare with best found so far using lexicographical tuple comparison\n                    if current_params_tuple  best_params_tuple:\n                        best_params_tuple = current_params_tuple\n        \n        # After grid search for one case, store the result\n        N_min, rho_min, alpha_opt, ks_opt = best_params_tuple\n\n        if N_min == float('inf'):\n            # No convergent parameters found on the grid\n            all_results.append(['inf', -1, -1.0, -1.0])\n        else:\n            all_results.append([rho_min, int(N_min), alpha_opt, ks_opt])\n\n    # Format the final output string\n    result_strings = []\n    for res in all_results:\n        if res[0] == 'inf':\n             result_strings.append(f\"[{res[0]}, {res[1]}, {res[2]:.3f}, {res[3]:.3f}]\")\n        else:\n            rho, N, alpha, ks_val = res\n            result_strings.append(f\"[{rho:.6f}, {N}, {alpha:.3f}, {ks_val:.3f}]\")\n\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        }
    ]
}