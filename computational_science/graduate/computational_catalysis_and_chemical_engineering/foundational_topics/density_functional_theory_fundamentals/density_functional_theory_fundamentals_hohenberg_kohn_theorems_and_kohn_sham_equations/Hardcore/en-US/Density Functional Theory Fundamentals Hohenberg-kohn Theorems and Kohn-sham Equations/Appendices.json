{
    "hands_on_practices": [
        {
            "introduction": "The cornerstone of Density Functional Theory is the electron density, $n(\\mathbf{r})$. While theoretically a continuous function, in any computational application it is represented by a set of values on a discrete grid. This practice bridges the gap between the continuous concept and its discrete implementation, focusing on the fundamental requirement that the integrated density must yield the total number of electrons in the system, $N$. By implementing a numerical integration scheme , you will develop a crucial skill for verifying the integrity of computational data and gain intuition for how physical fields are handled in a discretized space.",
            "id": "3876853",
            "problem": "You are given a rectilinear three-dimensional discretization of the ground-state electron density $n(\\mathbf r)$ for a surface slab model in the context of Density Functional Theory (DFT), where Density Functional Theory (DFT) refers to the mapping from the ground-state electron density to all observables of the system as established by the Hohenberg-Kohn theorems. The goal is to compute the integrated charge in electrons by numerically evaluating the integral of $n(\\mathbf r)$ over the simulation cell and verify that it equals the number of electrons in the unit cell, consistent with the Kohn-Sham equations, which represent the interacting system by an auxiliary non-interacting system whose orbitals reproduce the same ground-state electron density. The fundamental base is that the total electron number $N$ is given by the integral\n$$\nN \\equiv \\int_{\\Omega} n(\\mathbf r)\\,\\mathrm d^3 \\mathbf r,\n$$\nand, in the Kohn-Sham representation, the density can be expressed as $n(\\mathbf r) = \\sum_i f_i \\left|\\psi_i(\\mathbf r)\\right|^2$, where $f_i$ are the occupation numbers and $\\psi_i(\\mathbf r)$ are the normalized Kohn-Sham orbitals.\n\nYour task is to implement a numerical integration consistent with a discretized rectilinear grid. The electron density $n(\\mathbf r)$ is sampled at grid nodes $(x_i,y_j,z_k)$. To be physically and numerically consistent with a node-based discretization, use the three-dimensional trapezoidal rule, which applies one-dimensional trapezoidal weights along each axis and forms the tensor product for the volume element:\n- For a one-dimensional coordinate array $\\{u_\\ell\\}_{\\ell=0}^{M-1}$ (with $u_\\ell$ in $\\mathrm{\\AA}$), define trapezoidal weights $w_\\ell$ (in $\\mathrm{\\AA}$) as\n$$\nw_0 = \\frac{u_1 - u_0}{2},\\quad\nw_\\ell = \\frac{u_{\\ell+1} - u_{\\ell-1}}{2}\\ \\text{for}\\ 1 \\le \\ell \\le M-2,\\quad\nw_{M-1} = \\frac{u_{M-1} - u_{M-2}}{2}.\n$$\n- For three axes with coordinate arrays $\\{x_i\\}_{i=0}^{N_x-1}$, $\\{y_j\\}_{j=0}^{N_y-1}$, and $\\{z_k\\}_{k=0}^{N_z-1}$, the three-dimensional trapezoidal approximation is\n$$\n\\hat N = \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\sum_{k=0}^{N_z-1} n(x_i,y_j,z_k)\\, w^{(x)}_i\\, w^{(y)}_j\\, w^{(z)}_k,\n$$\nwhere $w^{(x)}_i$, $w^{(y)}_j$, and $w^{(z)}_k$ are the axis-specific trapezoidal weights. This produces $\\hat N$ in electrons when $n$ is in electrons per cubic angstrom ($\\mathrm{e}/\\mathrm{\\AA}^3$) and the coordinates are in angstroms ($\\mathrm{\\AA}$).\n\nImplement the above for the following test suite of five cases. In all cases, angles are not involved. Use an absolute verification tolerance of $10^{-4}$ electrons. Units:\n- Coordinates $\\{x_i\\}, \\{y_j\\}, \\{z_k\\}$ are in $\\mathrm{\\AA}$.\n- Density $n(\\mathbf r)$ is in $\\mathrm{e}/\\mathrm{\\AA}^3$.\n- Integrated electron number is in electrons (dimensionless).\n\nFor each case, construct the coordinate arrays and the discretized density $n(\\mathbf r)$ exactly as specified.\n\nCase 1 (uniform density in an orthorhombic slab with vacuum):\n- Cell lengths: $L_x = 5.0\\,\\mathrm{\\AA}$, $L_y = 5.0\\,\\mathrm{\\AA}$, $L_z = 20.0\\,\\mathrm{\\AA}$.\n- Grid sizes: $N_x = 25$, $N_y = 25$, $N_z = 40$.\n- Coordinates: $x_i$, $y_j$, $z_k$ are linearly spaced between $0$ and the respective cell lengths (inclusive).\n- Target electron number: $N_{\\mathrm{target}} = 16$.\n- Density: $n(\\mathbf r) = N_{\\mathrm{target}}/(L_x L_y L_z)$ (uniform).\n\nCase 2 (nonuniform spacing along $z$ with a Gaussian slab density):\n- Cell lengths: $L_x = 8.0\\,\\mathrm{\\AA}$, $L_y = 8.0\\,\\mathrm{\\AA}$, $L_z = 30.0\\,\\mathrm{\\AA}$.\n- Grid sizes: $N_x = 20$, $N_y = 20$, $N_z = 60$.\n- Coordinates: $x_i$, $y_j$ are linearly spaced in their ranges; $z_k$ is nonuniform, constructed by\n$$\nu_k = \\tanh\\!\\big(\\alpha\\, t_k\\big),\\ \\ t_k = \\frac{2k}{N_z - 1} - 1,\\ \\ \\alpha = 2.5,\n$$\nthen rescale $\\{u_k\\}$ to $[0,1]$ by $p_k = \\frac{u_k - \\min(u)}{\\max(u) - \\min(u)}$, and set $z_k = L_z p_k$.\n- Target electron number: $N_{\\mathrm{target}} = 24$.\n- Density: a $z$-dependent Gaussian,\n$$\nn(x,y,z) = A \\exp\\!\\left( -\\frac{(z - z_0)^2}{2\\sigma^2} \\right),\n$$\nwith $z_0 = L_z/2$, $\\sigma = 1.0\\,\\mathrm{\\AA}$, and $A = \\dfrac{N_{\\mathrm{target}}}{L_x L_y \\sqrt{2\\pi}\\,\\sigma}$.\n\nCase 3 (two localized Gaussian peaks representing a thin slab in vacuum):\n- Cell lengths: $L_x = 10.0\\,\\mathrm{\\AA}$, $L_y = 10.0\\,\\mathrm{\\AA}$, $L_z = 60.0\\,\\mathrm{\\AA}$.\n- Grid sizes: $N_x = 16$, $N_y = 16$, $N_z = 96$.\n- Coordinates: $x_i$, $y_j$, $z_k$ are linearly spaced.\n- Target electron number: $N_{\\mathrm{target}} = 2$.\n- Density: sum of two $z$-localized Gaussians at $z_1 = 15.0\\,\\mathrm{\\AA}$ and $z_2 = 45.0\\,\\mathrm{\\AA}$ with $\\sigma = 0.5\\,\\mathrm{\\AA}$,\n$$\nn(x,y,z) = \\sum_{m=1}^2 A_m \\exp\\!\\left( -\\frac{(z - z_m)^2}{2\\sigma^2} \\right),\\quad A_m = \\frac{1}{L_x L_y \\sqrt{2\\pi}\\,\\sigma},\n$$\nso that each peak integrates to $1$ electron, totaling $N_{\\mathrm{target}} = 2$.\n\nCase 4 (uniform density with nonuniform spacing along all axes):\n- Cell lengths: $L_x = 7.5\\,\\mathrm{\\AA}$, $L_y = 6.25\\,\\mathrm{\\AA}$, $L_z = 12.5\\,\\mathrm{\\AA}$.\n- Grid sizes: $N_x = 21$, $N_y = 17$, $N_z = 19$.\n- Coordinates: for each axis, construct nonuniform nodes via the same $\\tanh$-based procedure as in Case 2 but with different $\\alpha$ values: $\\alpha_x = 3.0$, $\\alpha_y = 1.5$, $\\alpha_z = 2.0$, rescaled to $[0,L_\\bullet]$.\n- Target electron number: $N_{\\mathrm{target}} = 11$.\n- Density: $n(\\mathbf r) = N_{\\mathrm{target}}/(L_x L_y L_z)$ (uniform).\n\nCase 5 (Kohn-Sham orbitals producing the density via occupations):\n- Cell lengths: $L_x = 12.0\\,\\mathrm{\\AA}$, $L_y = 10.0\\,\\mathrm{\\AA}$, $L_z = 14.0\\,\\mathrm{\\AA}$.\n- Grid sizes: $N_x = 48$, $N_y = 40$, $N_z = 56$.\n- Coordinates: $x_i$, $y_j$, $z_k$ are linearly spaced.\n- Occupations: $f_1 = 2$, $f_2 = 2$.\n- Orbitals: define\n$$\n\\psi_1(x,y,z) = \\sqrt{\\frac{8}{L_x L_y L_z}}\\,\\sin\\!\\left(\\frac{\\pi x}{L_x}\\right)\\sin\\!\\left(\\frac{\\pi y}{L_y}\\right)\\sin\\!\\left(\\frac{\\pi z}{L_z}\\right),\n$$\n$$\n\\psi_2(x,y,z) = \\sqrt{\\frac{8}{L_x L_y L_z}}\\,\\sin\\!\\left(\\frac{2\\pi x}{L_x}\\right)\\sin\\!\\left(\\frac{\\pi y}{L_y}\\right)\\sin\\!\\left(\\frac{\\pi z}{L_z}\\right),\n$$\nand set the density to\n$$\nn(\\mathbf r) = f_1 \\left|\\psi_1(\\mathbf r)\\right|^2 + f_2 \\left|\\psi_2(\\mathbf r)\\right|^2.\n$$\n- Target electron number: $N_{\\mathrm{target}} = f_1 + f_2 = 4$.\n\nVerification:\n- For each case, compute $\\hat N$ using the three-dimensional trapezoidal rule and verify $\\left|\\hat N - N_{\\mathrm{target}}\\right| \\le 10^{-4}$ electrons.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order $[\\hat N_1,\\mathrm{ok}_1,\\hat N_2,\\mathrm{ok}_2,\\ldots,\\hat N_5,\\mathrm{ok}_5]$, where each $\\hat N_i$ is a float and each $\\mathrm{ok}_i$ is a boolean equal to $\\mathrm{True}$ if the verification inequality holds and $\\mathrm{False}$ otherwise. The unit for each $\\hat N_i$ is electrons (dimensionless).",
            "solution": "The fundamental principles from the Hohenberg-Kohn theorems state that the ground-state electron density $n(\\mathbf r)$ uniquely determines all properties of the system, including the total number of electrons $N$. The number of electrons is obtained from the integral\n$$\nN = \\int_{\\Omega} n(\\mathbf r)\\,\\mathrm d^3 \\mathbf r,\n$$\nwhere $\\Omega$ is the simulation cell in three-dimensional space and $n(\\mathbf r) \\ge 0$ is measured in electrons per cubic angstrom ($\\mathrm{e}/\\mathrm{\\AA}^3$). In the Kohn-Sham construction, the same $n(\\mathbf r)$ is reproduced by non-interacting orbitals $\\psi_i(\\mathbf r)$ with occupations $f_i$, and $n(\\mathbf r) = \\sum_i f_i |\\psi_i(\\mathbf r)|^2$. Since each normalized orbital satisfies $\\int |\\psi_i(\\mathbf r)|^2\\mathrm d^3\\mathbf r = 1$, it follows by linearity that $\\int n(\\mathbf r)\\mathrm d^3\\mathbf r = \\sum_i f_i$, making the integral equal to the electron count implied by the Kohn-Sham occupations.\n\nTo compute this integral numerically when $n(\\mathbf r)$ is provided on a rectilinear grid of nodes $\\{(x_i,y_j,z_k)\\}$, we adopt the trapezoidal quadrature consistent with node-based sampling. In one dimension, for a coordinate array $\\{u_\\ell\\}_{\\ell=0}^{M-1}$ spanning the interval $[0,U]$, the trapezoidal weights $w_\\ell$ approximate the line element $\\mathrm d u$ at each node:\n$$\nw_0 = \\frac{u_1 - u_0}{2},\\quad\nw_\\ell = \\frac{u_{\\ell+1} - u_{\\ell-1}}{2}\\ \\text{for}\\ 1 \\le \\ell \\le M-2,\\quad\nw_{M-1} = \\frac{u_{M-1} - u_{M-2}}{2}.\n$$\nThese weights satisfy $\\sum_{\\ell=0}^{M-1} w_\\ell \\approx U$, with equality for linear spacing. In three dimensions, the separability of the volume element implies $\\mathrm d^3 \\mathbf r = \\mathrm d x\\, \\mathrm d y\\, \\mathrm d z$, so we form the tensor-product weights. For axes $x$, $y$, and $z$, with respective trapezoidal weights $w^{(x)}_i$, $w^{(y)}_j$, and $w^{(z)}_k$, the three-dimensional trapezoidal rule computes the integral as\n$$\n\\hat N = \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\sum_{k=0}^{N_z-1} n(x_i,y_j,z_k)\\, w^{(x)}_i\\, w^{(y)}_j\\, w^{(z)}_k.\n$$\nThis algorithm produces $\\hat N$ in electrons when the density $n$ is in $\\mathrm{e}/\\mathrm{\\AA}^3$ and the coordinates are in $\\mathrm{\\AA}$. The trapezoidal rule is appropriate for smooth densities often encountered in Kohn-Sham calculations and ensures exactness for uniform densities on uniform grids and high accuracy for smooth nonuniform cases.\n\nAlgorithmic steps:\n1. For each test case, construct coordinate arrays $\\{x_i\\}$, $\\{y_j\\}$, $\\{z_k\\}$ according to the specified cell lengths and grid sizes. For nonuniform axes, use the specified hyperbolic tangent mapping $u = \\tanh(\\alpha t)$, rescaled to the physical interval, with $t$ uniformly spaced in $[-1,1]$.\n2. Construct the discretized density $n(x_i,y_j,z_k)$:\n   - For uniform density cases, set $n(\\mathbf r) = N_{\\mathrm{target}}/(L_x L_y L_z)$.\n   - For Gaussian densities varying only in $z$, set $n(x,y,z) = A \\exp\\!\\left( -\\frac{(z - z_0)^2}{2\\sigma^2} \\right)$ and choose $A$ so that the continuous integral approximately equals $N_{\\mathrm{target}}$:\n     $A = \\dfrac{N_{\\mathrm{target}}}{L_x L_y \\sqrt{2\\pi}\\,\\sigma}$, with $z_0 = L_z/2$ and small $\\sigma$ relative to $L_z$ to minimize truncation error.\n   - For the sum of two Gaussians, use the superposition principle and choose amplitudes $A_m$ so each Gaussian integrates to $1$ electron, ensuring the total is $2$.\n   - For Kohn-Sham orbitals, construct $\\psi_1$ and $\\psi_2$ with normalization constant $\\sqrt{\\frac{8}{L_x L_y L_z}}$, which guarantees $\\int |\\psi_i|^2 \\mathrm d^3 \\mathbf r = 1$ exactly in the continuum. The density is $n(\\mathbf r) = f_1|\\psi_1|^2 + f_2|\\psi_2|^2$.\n3. Compute one-dimensional trapezoidal weights along each axis using the difference formulas. These weights have units of $\\mathrm{\\AA}$.\n4. Compute the integrated electron number using the triple sum with the tensor-product weights to get $\\hat N$.\n5. Verify $\\left|\\hat N - N_{\\mathrm{target}}\\right| \\le 10^{-4}$ electrons for each case.\n6. Aggregate outputs into the specified single-line format: $[\\hat N_1,\\mathrm{ok}_1,\\hat N_2,\\mathrm{ok}_2,\\ldots,\\hat N_5,\\mathrm{ok}_5]$.\n\nThe design leverages the principle that the number of electrons is the integral of the density (Hohenberg-Kohn), and in the Kohn-Sham formalism, the density derived from orbitals with known occupations integrates to the electron count by construction. The trapezoidal integration method is chosen because it is consistent with node-based discretizations commonly produced by plane-wave and grid-based DFT codes and provides a robust, convergent approximation of the integral. The test suite includes uniform-density cases (for exactness), nonuniform coordinates (to validate correct handling of variable spacings), localized Gaussian densities (to mimic slab-like electronic distributions in vacuum), and densities constructed from normalized Kohn-Sham orbitals (to probe the connection between orbital occupations and electron count). The uniform absolute tolerance of $10^{-4}$ electrons accounts for discretization and quadrature errors while remaining stringent for advanced graduate-level numerical validation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef trapezoid_weights(coords: np.ndarray) - np.ndarray:\n    \"\"\"\n    Compute 1D trapezoidal weights for node-based integration over the coordinate array.\n    coords: array of shape (M,) in Angstrom.\n    Returns weights array of shape (M,) in Angstrom.\n    \"\"\"\n    M = coords.size\n    if M  2:\n        raise ValueError(\"At least two points are required to form trapezoidal weights.\")\n    diffs = np.diff(coords)\n    if np.any(diffs = 0):\n        raise ValueError(\"Coordinate array must be strictly increasing.\")\n    w = np.empty(M, dtype=float)\n    w[0] = diffs[0] / 2.0\n    w[-1] = diffs[-1] / 2.0\n    if M  2:\n        w[1:-1] = (diffs[1:] + diffs[:-1]) / 2.0\n    return w\n\ndef integrate_density(n: np.ndarray, x: np.ndarray, y: np.ndarray, z: np.ndarray) - float:\n    \"\"\"\n    Integrate a 3D density n(x_i, y_j, z_k) using tensor-product trapezoidal weights.\n    n: array of shape (Nx, Ny, Nz) in e/Angstrom^3\n    x, y, z: coordinate arrays in Angstrom\n    Returns total electrons as float.\n    \"\"\"\n    wx = trapezoid_weights(x)\n    wy = trapezoid_weights(y)\n    wz = trapezoid_weights(z)\n    # Use broadcasting to multiply weights\n    # Volume element per node = wx[i] * wy[j] * wz[k]\n    vol_weights = wx[:, None, None] * wy[None, :, None] * wz[None, None, :]\n    total_electrons = float(np.sum(n * vol_weights))\n    return total_electrons\n\ndef make_tanh_nonuniform_coords(L: float, N: int, alpha: float) - np.ndarray:\n    \"\"\"\n    Construct a nonuniform coordinate array on [0, L] using a tanh mapping with parameter alpha.\n    \"\"\"\n    t = np.linspace(-1.0, 1.0, N)\n    u = np.tanh(alpha * t)  # range approximately (-tanh(alpha), tanh(alpha))\n    # Rescale to [0, 1]\n    p = (u - u.min()) / (u.max() - u.min())\n    return L * p\n\ndef solve():\n    tol = 1e-4  # absolute tolerance in electrons\n\n    results = []\n\n    # Case 1: Uniform density in orthorhombic slab with vacuum\n    Lx1, Ly1, Lz1 = 5.0, 5.0, 20.0\n    Nx1, Ny1, Nz1 = 25, 25, 40\n    x1 = np.linspace(0.0, Lx1, Nx1)\n    y1 = np.linspace(0.0, Ly1, Ny1)\n    z1 = np.linspace(0.0, Lz1, Nz1)\n    N_target1 = 16.0\n    n1_val = N_target1 / (Lx1 * Ly1 * Lz1)\n    n1 = np.full((Nx1, Ny1, Nz1), n1_val, dtype=float)\n    N_calc1 = integrate_density(n1, x1, y1, z1)\n    ok1 = abs(N_calc1 - N_target1) = tol\n    results.extend([N_calc1, ok1])\n\n    # Case 2: Nonuniform z with Gaussian\n    Lx2, Ly2, Lz2 = 8.0, 8.0, 30.0\n    Nx2, Ny2, Nz2 = 20, 20, 60\n    x2 = np.linspace(0.0, Lx2, Nx2)\n    y2 = np.linspace(0.0, Ly2, Ny2)\n    z2 = make_tanh_nonuniform_coords(Lz2, Nz2, alpha=2.5)\n    N_target2 = 24.0\n    z0_2 = Lz2 / 2.0\n    sigma2 = 1.0\n    A2 = N_target2 / (Lx2 * Ly2 * np.sqrt(2.0 * np.pi) * sigma2)\n    # Density depends only on z\n    n2_z = A2 * np.exp(-0.5 * ((z2 - z0_2) / sigma2) ** 2)\n    # Broadcast to 3D\n    n2 = np.broadcast_to(n2_z[None, None, :], (Nx2, Ny2, Nz2)).copy()\n    N_calc2 = integrate_density(n2, x2, y2, z2)\n    ok2 = abs(N_calc2 - N_target2) = tol\n    results.extend([N_calc2, ok2])\n\n    # Case 3: Two localized Gaussians (thin slab in vacuum)\n    Lx3, Ly3, Lz3 = 10.0, 10.0, 60.0\n    Nx3, Ny3, Nz3 = 16, 16, 96\n    x3 = np.linspace(0.0, Lx3, Nx3)\n    y3 = np.linspace(0.0, Ly3, Ny3)\n    z3 = np.linspace(0.0, Lz3, Nz3)\n    N_target3 = 2.0\n    z1_3, z2_3 = 15.0, 45.0\n    sigma3 = 0.5\n    A3 = 1.0 / (Lx3 * Ly3 * np.sqrt(2.0 * np.pi) * sigma3)  # each peak 1 electron\n    n3_z = A3 * np.exp(-0.5 * ((z3 - z1_3) / sigma3) ** 2) + A3 * np.exp(-0.5 * ((z3 - z2_3) / sigma3) ** 2)\n    n3 = np.broadcast_to(n3_z[None, None, :], (Nx3, Ny3, Nz3)).copy()\n    N_calc3 = integrate_density(n3, x3, y3, z3)\n    ok3 = abs(N_calc3 - N_target3) = tol\n    results.extend([N_calc3, ok3])\n\n    # Case 4: Uniform density with nonuniform spacing on all axes\n    Lx4, Ly4, Lz4 = 7.5, 6.25, 12.5\n    Nx4, Ny4, Nz4 = 21, 17, 19\n    x4 = make_tanh_nonuniform_coords(Lx4, Nx4, alpha=3.0)\n    y4 = make_tanh_nonuniform_coords(Ly4, Ny4, alpha=1.5)\n    z4 = make_tanh_nonuniform_coords(Lz4, Nz4, alpha=2.0)\n    N_target4 = 11.0\n    n4_val = N_target4 / (Lx4 * Ly4 * Lz4)\n    n4 = np.full((Nx4, Ny4, Nz4), n4_val, dtype=float)\n    N_calc4 = integrate_density(n4, x4, y4, z4)\n    ok4 = abs(N_calc4 - N_target4) = tol\n    results.extend([N_calc4, ok4])\n\n    # Case 5: Kohn-Sham orbitals with occupations\n    Lx5, Ly5, Lz5 = 12.0, 10.0, 14.0\n    Nx5, Ny5, Nz5 = 48, 40, 56\n    x5 = np.linspace(0.0, Lx5, Nx5)\n    y5 = np.linspace(0.0, Ly5, Ny5)\n    z5 = np.linspace(0.0, Lz5, Nz5)\n    f1, f2 = 2.0, 2.0\n    N_target5 = f1 + f2\n    C5 = np.sqrt(8.0 / (Lx5 * Ly5 * Lz5))\n    # Build 3D grids via broadcasting\n    X5 = x5[:, None, None]\n    Y5 = y5[None, :, None]\n    Z5 = z5[None, None, :]\n    psi1_sq = (C5**2) * (np.sin(np.pi * X5 / Lx5) ** 2) * (np.sin(np.pi * Y5 / Ly5) ** 2) * (np.sin(np.pi * Z5 / Lz5) ** 2)\n    psi2_sq = (C5**2) * (np.sin(2.0 * np.pi * X5 / Lx5) ** 2) * (np.sin(np.pi * Y5 / Ly5) ** 2) * (np.sin(np.pi * Z5 / Lz5) ** 2)\n    n5 = f1 * psi1_sq + f2 * psi2_sq\n    N_calc5 = integrate_density(n5, x5, y5, z5)\n    ok5 = abs(N_calc5 - N_target5) = tol\n    results.extend([N_calc5, ok5])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The power of DFT lies in the Kohn-Sham equations, but its practical accuracy hinges on the approximation used for the exchange-correlation ($E_{xc}$) functional. This exercise moves from handling the density to using it to compute a physically meaningful property: the adsorption energy of a molecule on a catalytic surface. By implementing simplified models of the Local Density Approximation (LDA) and the Generalized Gradient Approximation (GGA) , you will directly quantify how including the density gradient, $\\nabla n(\\mathbf{r})$, changes the predicted binding strength, offering a clear view into the hierarchy of DFT functionals.",
            "id": "3876786",
            "problem": "You are asked to design and implement a program that computes the change in adsorption energy when moving from the Local Density Approximation (LDA) to the Generalized Gradient Approximation (GGA) for a carbon monoxide (CO) molecule adsorbed on a platinum $(111)$ surface. The problem must be solved starting from the foundational principles of Density Functional Theory (DFT), including the Hohenberg-Kohn theorems and the Kohn-Sham (KS) equations. Your program will use provided model exchange-correlation data to compute the change and must analyze the trends across a small test suite of scenarios.\n\nBegin from the following fundamental basis:\n- The Hohenberg-Kohn theorems ensure that the ground-state energy of an interacting electron system is a unique functional of the ground-state electron density $n(\\mathbf{r})$, and that the exact ground-state density minimizes this energy functional.\n- The Kohn-Sham equations construct a system of non-interacting electrons that reproduce the true ground-state density, yielding a total energy functional of the form\n$$\nE[n] = T_{\\mathrm{s}}[n] + \\int v_{\\mathrm{ext}}(\\mathbf{r}) n(\\mathbf{r}) \\, d\\mathbf{r} + E_{\\mathrm{H}}[n] + E_{\\mathrm{xc}}[n],\n$$\nwhere $T_{\\mathrm{s}}[n]$ is the non-interacting kinetic energy, $v_{\\mathrm{ext}}(\\mathbf{r})$ is the external potential, $E_{\\mathrm{H}}[n]$ is the Hartree energy, and $E_{\\mathrm{xc}}[n]$ is the exchange-correlation energy.\n\nThe adsorption energy of CO on Pt$(111)$ is defined as\n$$\nE_{\\mathrm{ads}} = E_{\\mathrm{tot}}^{\\mathrm{slab+CO}} - E_{\\mathrm{tot}}^{\\mathrm{slab}} - E_{\\mathrm{tot}}^{\\mathrm{CO}},\n$$\nand the change in adsorption energy when moving from the Local Density Approximation (LDA) to the Generalized Gradient Approximation (GGA) is\n$$\n\\Delta E_{\\mathrm{ads}} = E_{\\mathrm{ads}}^{\\mathrm{GGA}} - E_{\\mathrm{ads}}^{\\mathrm{LDA}}.\n$$\nAssume that the only change between LDA and GGA arises from the exchange-correlation functional $E_{\\mathrm{xc}}[n]$, with all other contributions remaining identical across the two approximations. Under this assumption,\n$$\n\\Delta E_{\\mathrm{ads}} = \\left(E_{\\mathrm{xc}}^{\\mathrm{GGA}}(\\mathrm{slab+CO}) - E_{\\mathrm{xc}}^{\\mathrm{GGA}}(\\mathrm{slab}) - E_{\\mathrm{xc}}^{\\mathrm{GGA}}(\\mathrm{CO})\\right) - \\left(E_{\\mathrm{xc}}^{\\mathrm{LDA}}(\\mathrm{slab+CO}) - E_{\\mathrm{xc}}^{\\mathrm{LDA}}(\\mathrm{slab}) - E_{\\mathrm{xc}}^{\\mathrm{LDA}}(\\mathrm{CO})\\right).\n$$\n\nIn this problem, the exchange-correlation energy functional is discretized on a uniform grid with volume elements $\\Delta V$, so that\n$$\nE_{\\mathrm{xc}}[n] \\approx \\sum_{i} n_{i} \\, \\varepsilon_{\\mathrm{xc}}(n_{i}, g_{i}) \\, \\Delta V,\n$$\nwhere $n_{i}$ is the electron density at grid point $i$ (in electrons per cubic ångström), $g_{i} = \\lvert \\nabla n \\rvert_{i}$ is the magnitude of the density gradient at grid point $i$ (in electrons per cubic ångström per ångström), and $\\varepsilon_{\\mathrm{xc}}$ is the exchange-correlation energy per particle. Use the following model forms:\n- For Local Density Approximation (LDA),\n$$\n\\varepsilon_{\\mathrm{xc}}^{\\mathrm{LDA}}(n) = -A \\, n^{1/3},\n$$\nwhere $A$ is a positive constant in electronvolts.\n- For Generalized Gradient Approximation (GGA), use a reduced-gradient correction,\n$$\n\\varepsilon_{\\mathrm{xc}}^{\\mathrm{GGA}}(n, g) = \\frac{\\varepsilon_{\\mathrm{xc}}^{\\mathrm{LDA}}(n)}{1 + C \\, s^{2}},\n$$\nwhere $C$ is a positive constant and $s$ is the dimensionless reduced gradient\n$$\ns = \\frac{g}{2 k_{\\mathrm{F}}(n) \\, n}, \\quad k_{\\mathrm{F}}(n) = \\left(3 \\pi^{2} n\\right)^{1/3}.\n$$\nWhen $n = 0$, define the reduced gradient $s = 0$ and the contribution of that grid point to $E_{\\mathrm{xc}}$ as zero.\n\nUnits and numerical specification:\n- Express $\\Delta E_{\\mathrm{ads}}$ in electronvolts ($\\mathrm{eV}$), rounded to six decimal places.\n- Angles are not present; no angle unit is required.\n- Percentages are not present; do not use a percentage sign.\n\nTest suite and input data:\nFor each test case, you are given $(A, C, \\Delta V)$ and three finite grids for the systems $(\\mathrm{slab+CO})$, $(\\mathrm{slab})$, and $(\\mathrm{CO})$, each represented by arrays of densities and gradients. Use the data below.\n\nCase $1$ (moderate gradients, typical scenario):\n- $A = 0.75$, $C = 0.30$, $\\Delta V = 1.0$.\n- $(\\mathrm{slab+CO})$: $n = [\\,0.10,\\,0.12,\\,0.15,\\,0.08,\\,0.20,\\,0.18\\,]$, $g = [\\,0.05,\\,0.08,\\,0.10,\\,0.04,\\,0.12,\\,0.09\\,]$.\n- $(\\mathrm{slab})$: $n = [\\,0.09,\\,0.11,\\,0.14,\\,0.08,\\,0.19,\\,0.17\\,]$, $g = [\\,0.04,\\,0.07,\\,0.08,\\,0.04,\\,0.10,\\,0.08\\,]$.\n- $(\\mathrm{CO})$: $n = [\\,0.01,\\,0.01,\\,0.01,\\,0.00,\\,0.01,\\,0.01\\,]$, $g = [\\,0.01,\\,0.01,\\,0.02,\\,0.00,\\,0.02,\\,0.01\\,]$.\n\nCase $2$ (boundary case, zero gradients):\n- $A = 0.75$, $C = 0.30$, $\\Delta V = 1.0$.\n- $(\\mathrm{slab+CO})$: $n = [\\,0.10,\\,0.12,\\,0.15,\\,0.08\\,]$, $g = [\\,0.00,\\,0.00,\\,0.00,\\,0.00\\,]$.\n- $(\\mathrm{slab})$: $n = [\\,0.09,\\,0.11,\\,0.14,\\,0.08\\,]$, $g = [\\,0.00,\\,0.00,\\,0.00,\\,0.00\\,]$.\n- $(\\mathrm{CO})$: $n = [\\,0.01,\\,0.01,\\,0.01,\\,0.00\\,]$, $g = [\\,0.00,\\,0.00,\\,0.00,\\,0.00\\,]$.\n\nCase $3$ (high gradients localized near adsorption site):\n- $A = 0.75$, $C = 0.30$, $\\Delta V = 1.0$.\n- $(\\mathrm{slab+CO})$: $n = [\\,0.10,\\,0.12,\\,0.15,\\,0.08,\\,0.20,\\,0.18,\\,0.25,\\,0.22\\,]$, $g = [\\,0.20,\\,0.25,\\,0.30,\\,0.15,\\,0.35,\\,0.28,\\,0.40,\\,0.33\\,]$.\n- $(\\mathrm{slab})$: $n = [\\,0.09,\\,0.11,\\,0.14,\\,0.08,\\,0.19,\\,0.17,\\,0.24,\\,0.21\\,]$, $g = [\\,0.08,\\,0.10,\\,0.12,\\,0.06,\\,0.14,\\,0.12,\\,0.16,\\,0.14\\,]$.\n- $(\\mathrm{CO})$: $n = [\\,0.01,\\,0.01,\\,0.01,\\,0.00,\\,0.01,\\,0.01,\\,0.01,\\,0.01\\,]$, $g = [\\,0.03,\\,0.04,\\,0.05,\\,0.00,\\,0.05,\\,0.04,\\,0.06,\\,0.05\\,]$.\n\nCase $4$ (edge case, vacuum tails and near-zero density):\n- $A = 0.75$, $C = 0.30$, $\\Delta V = 1.0$.\n- $(\\mathrm{slab+CO})$: $n = [\\,0.00,\\,0.002,\\,0.005,\\,0.000,\\,0.001\\,]$, $g = [\\,0.000,\\,0.008,\\,0.012,\\,0.000,\\,0.006\\,]$.\n- $(\\mathrm{slab})$: $n = [\\,0.00,\\,0.0015,\\,0.0035,\\,0.000,\\,0.0008\\,]$, $g = [\\,0.000,\\,0.006,\\,0.010,\\,0.000,\\,0.004\\,]$.\n- $(\\mathrm{CO})$: $n = [\\,0.00,\\,0.0005,\\,0.0015,\\,0.000,\\,0.0003\\,]$, $g = [\\,0.000,\\,0.003,\\,0.005,\\,0.000,\\,0.002\\,]$.\n\nProgram requirements:\n- Implement the computation of $E_{\\mathrm{xc}}^{\\mathrm{LDA}}$ and $E_{\\mathrm{xc}}^{\\mathrm{GGA}}$ per the model above.\n- Compute $\\Delta E_{\\mathrm{ads}}$ for each case.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[x_{1},x_{2},x_{3},x_{4}]$, where each $x_{i}$ is the $\\Delta E_{\\mathrm{ads}}$ for test case $i$ in $\\mathrm{eV}$, rounded to six decimal places.",
            "solution": "The central task is to compute the change in the adsorption energy of a $\\mathrm{CO}$ molecule on a $\\mathrm{Pt}(111)$ surface, denoted $\\Delta E_{\\mathrm{ads}}$, when the theoretical description is changed from the Local Density Approximation (LDA) to the Generalized Gradient Approximation (GGA). The problem is approached from the fundamental principles of Density Functional Theory (DFT).\n\nThe adsorption energy is defined as the total energy of the combined system minus the total energies of the isolated components:\n$$\nE_{\\mathrm{ads}} = E_{\\mathrm{tot}}^{\\mathrm{slab+CO}} - E_{\\mathrm{tot}}^{\\mathrm{slab}} - E_{\\mathrm{tot}}^{\\mathrm{CO}}\n$$\nThe change in this quantity, $\\Delta E_{\\mathrm{ads}}$, is the difference between the GGA adsorption energy and the LDA adsorption energy:\n$$\n\\Delta E_{\\mathrm{ads}} = E_{\\mathrm{ads}}^{\\mathrm{GGA}} - E_{\\mathrm{ads}}^{\\mathrm{LDA}}\n$$\nThe problem stipulates a critical simplifying assumption: the functionals for kinetic energy ($T_s[n]$), external potential energy, and Hartree energy ($E_H[n]$) are identical for both LDA and GGA calculations, and thus cancel out when taking the difference. This approximation isolates the change to the exchange-correlation ($E_{\\mathrm{xc}}$) functional. Consequently, the expression for $\\Delta E_{\\mathrm{ads}}$ simplifies to a difference in exchange-correlation energy contributions:\n$$\n\\Delta E_{\\mathrm{ads}} = \\left(E_{\\mathrm{xc}}^{\\mathrm{GGA}}(\\mathrm{slab+CO}) - E_{\\mathrm{xc}}^{\\mathrm{GGA}}(\\mathrm{slab}) - E_{\\mathrm{xc}}^{\\mathrm{GGA}}(\\mathrm{CO})\\right) - \\left(E_{\\mathrm{xc}}^{\\mathrm{LDA}}(\\mathrm{slab+CO}) - E_{\\mathrm{xc}}^{\\mathrm{LDA}}(\\mathrm{slab}) - E_{\\mathrm{xc}}^{\\mathrm{LDA}}(\\mathrm{CO})\\right)\n$$\nThis expression can be conveniently rearranged by grouping terms for each system:\n$$\n\\Delta E_{\\mathrm{ads}} = \\left(E_{\\mathrm{xc}}^{\\mathrm{GGA}}(\\mathrm{slab+CO}) - E_{\\mathrm{xc}}^{\\mathrm{LDA}}(\\mathrm{slab+CO})\\right) - \\left(E_{\\mathrm{xc}}^{\\mathrm{GGA}}(\\mathrm{slab}) - E_{\\mathrm{xc}}^{\\mathrm{LDA}}(\\mathrm{slab})\\right) - \\left(E_{\\mathrm{xc}}^{\\mathrm{GGA}}(\\mathrm{CO}) - E_{\\mathrm{xc}}^{\\mathrm{LDA}}(\\mathrm{CO})\\right)\n$$\nLet us define the difference in exchange-correlation energy between GGA and LDA for a single system as $\\Delta E_{\\mathrm{xc}}^{\\mathrm{sys}} = E_{\\mathrm{xc}}^{\\mathrm{GGA}}(\\mathrm{sys}) - E_{\\mathrm{xc}}^{\\mathrm{LDA}}(\\mathrm{sys})$. The final expression for the change in adsorption energy becomes:\n$$\n\\Delta E_{\\mathrm{ads}} = \\Delta E_{\\mathrm{xc}}^{\\mathrm{slab+CO}} - \\Delta E_{\\mathrm{xc}}^{\\mathrm{slab}} - \\Delta E_{\\mathrm{xc}}^{\\mathrm{CO}}\n$$\nOur primary task is to compute $\\Delta E_{\\mathrm{xc}}$ for each of the three systems—combined ($\\mathrm{slab+CO}$), surface ($\\mathrm{slab}$), and molecule ($\\mathrm{CO}$)—using the provided discretized data and model functionals.\n\nThe exchange-correlation energy is given as a sum over discrete grid points $i$:\n$$\nE_{\\mathrm{xc}}[n] \\approx \\sum_{i} n_{i} \\, \\varepsilon_{\\mathrm{xc}}(n_{i}, g_{i}) \\, \\Delta V\n$$\nwhere $n_i$ is the electron density, $g_i = \\lvert \\nabla n \\rvert_i$ is the magnitude of the density gradient, and $\\Delta V$ is the volume element.\n\nThe model for the LDA energy per particle is:\n$$\n\\varepsilon_{\\mathrm{xc}}^{\\mathrm{LDA}}(n) = -A \\, n^{1/3}\n$$\nThe model for the GGA energy per particle includes a gradient correction:\n$$\n\\varepsilon_{\\mathrm{xc}}^{\\mathrm{GGA}}(n, g) = \\frac{\\varepsilon_{\\mathrm{xc}}^{\\mathrm{LDA}}(n)}{1 + C \\, s^{2}}\n$$\nwhere $s$ is the dimensionless reduced gradient:\n$$\ns = \\frac{g}{2 k_{\\mathrm{F}}(n) \\, n}\n$$\nwith the Fermi wavevector $k_{\\mathrm{F}}(n) = (3 \\pi^{2} n)^{1/3}$.\n\nWe can now formulate an explicit expression for $\\Delta E_{\\mathrm{xc}}^{\\mathrm{sys}}$. For a single system, the difference is:\n$$\n\\Delta E_{\\mathrm{xc}} = E_{\\mathrm{xc}}^{\\mathrm{GGA}} - E_{\\mathrm{xc}}^{\\mathrm{LDA}} = \\sum_{i} \\left( n_{i} \\varepsilon_{\\mathrm{xc}}^{\\mathrm{GGA}}(n_i, g_i) - n_i \\varepsilon_{\\mathrm{xc}}^{\\mathrm{LDA}}(n_i) \\right) \\Delta V\n$$\nSubstituting the expression for $\\varepsilon_{\\mathrm{xc}}^{\\mathrm{GGA}}$:\n$$\n\\Delta E_{\\mathrm{xc}} = \\sum_{i} n_{i} \\left( \\frac{\\varepsilon_{\\mathrm{xc}}^{\\mathrm{LDA}}(n_i)}{1 + C s_i^2} - \\varepsilon_{\\mathrm{xc}}^{\\mathrm{LDA}}(n_i) \\right) \\Delta V\n$$\nFactoring out $\\varepsilon_{\\mathrm{xc}}^{\\mathrm{LDA}}(n_i)$:\n$$\n\\Delta E_{\\mathrm{xc}} = \\sum_{i} n_{i} \\varepsilon_{\\mathrm{xc}}^{\\mathrm{LDA}}(n_i) \\left( \\frac{1}{1 + C s_i^2} - 1 \\right) \\Delta V = \\sum_{i} n_{i} \\varepsilon_{\\mathrm{xc}}^{\\mathrm{LDA}}(n_i) \\left( \\frac{1 - (1 + C s_i^2)}{1 + C s_i^2} \\right) \\Delta V\n$$\n$$\n\\Delta E_{\\mathrm{xc}} = \\sum_{i} n_{i} (-A n_i^{1/3}) \\left( \\frac{-C s_i^2}{1 + C s_i^2} \\right) \\Delta V\n$$\nThis simplifies to a more direct formula for the GGA-LDA energy difference for a system:\n$$\n\\Delta E_{\\mathrm{xc}}^{\\mathrm{sys}} = \\sum_{i} A n_i^{4/3} \\left( \\frac{C s_i^2}{1 + C s_i^2} \\right) \\Delta V\n$$\nThe calculation for each test case proceeds as follows:\n1. For each system ($\\mathrm{slab+CO}$, $\\mathrm{slab}$, and $\\mathrm{CO}$), calculate $\\Delta E_{\\mathrm{xc}}^{\\mathrm{sys}}$ using the derived formula.\n2. The calculation for $\\Delta E_{\\mathrm{xc}}^{\\mathrm{sys}}$ involves iterating over each grid point $i$ in the system's data arrays.\n3. For each grid point $i$ with density $n_i > 0$:\n    a. Calculate the Fermi wavevector $k_{\\mathrm{F}}(n_i) = (3 \\pi^2 n_i)^{1/3}$.\n    b. Calculate the reduced gradient $s_i = g_i / (2 k_{\\mathrm{F}}(n_i) n_i)$.\n    c. Calculate the contribution to the sum: $A n_i^{4/3} \\frac{C s_i^2}{1 + C s_i^2} \\Delta V$.\n4. For any grid point where $n_i = 0$, its contribution to any exchange-correlation energy is zero, as stipulated by the problem and as confirmed by the presence of the $n_i$ factor in the general $E_{\\mathrm{xc}}$ expression. Our derived formula for $\\Delta E_{\\mathrm{xc}}^{\\mathrm{sys}}$ also yields a zero contribution due to the $n_i^{4/3}$ term.\n5. Sum these contributions over all grid points to obtain $\\Delta E_{\\mathrm{xc}}^{\\mathrm{sys}}$.\n6. Once $\\Delta E_{\\mathrm{xc}}^{\\mathrm{slab+CO}}$, $\\Delta E_{\\mathrm{xc}}^{\\mathrm{slab}}$, and $\\Delta E_{\\mathrm{xc}}^{\\mathrm{CO}}$ are computed, find the final answer using $\\Delta E_{\\mathrm{ads}} = \\Delta E_{\\mathrm{xc}}^{\\mathrm{slab+CO}} - \\Delta E_{\\mathrm{xc}}^{\\mathrm{slab}} - \\Delta E_{\\mathrm{xc}}^{\\mathrm{CO}}$.\n7. The final result for each case is rounded to six decimal places.\n\nThis procedure is applied to each of the four test cases provided, using their respective parameters $(A, C, \\Delta V)$ and data arrays for $n$ and $g$.\nFor Case 2, where all gradients $g_i$ are zero, this implies $s_i=0$ for all points. The term $\\frac{C s_i^2}{1+C s_i^2}$ becomes zero, leading to $\\Delta E_{\\mathrm{xc}}^{\\mathrm{sys}}=0$ for all three systems. Consequently, $\\Delta E_{\\mathrm{ads}}$ will be $0$ for this case, which is expected as the GGA functional reduces to LDA when the density gradient vanishes.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the change in adsorption energy from LDA to GGA DFT.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"params\": {\"A\": 0.75, \"C\": 0.30, \"delta_V\": 1.0},\n            \"systems\": {\n                \"slab+CO\": {\n                    \"n\": np.array([0.10, 0.12, 0.15, 0.08, 0.20, 0.18]),\n                    \"g\": np.array([0.05, 0.08, 0.10, 0.04, 0.12, 0.09]),\n                },\n                \"slab\": {\n                    \"n\": np.array([0.09, 0.11, 0.14, 0.08, 0.19, 0.17]),\n                    \"g\": np.array([0.04, 0.07, 0.08, 0.04, 0.10, 0.08]),\n                },\n                \"CO\": {\n                    \"n\": np.array([0.01, 0.01, 0.01, 0.00, 0.01, 0.01]),\n                    \"g\": np.array([0.01, 0.01, 0.02, 0.00, 0.02, 0.01]),\n                },\n            },\n        },\n        {\n            \"params\": {\"A\": 0.75, \"C\": 0.30, \"delta_V\": 1.0},\n            \"systems\": {\n                \"slab+CO\": {\n                    \"n\": np.array([0.10, 0.12, 0.15, 0.08]),\n                    \"g\": np.array([0.00, 0.00, 0.00, 0.00]),\n                },\n                \"slab\": {\n                    \"n\": np.array([0.09, 0.11, 0.14, 0.08]),\n                    \"g\": np.array([0.00, 0.00, 0.00, 0.00]),\n                },\n                \"CO\": {\n                    \"n\": np.array([0.01, 0.01, 0.01, 0.00]),\n                    \"g\": np.array([0.00, 0.00, 0.00, 0.00]),\n                },\n            },\n        },\n        {\n            \"params\": {\"A\": 0.75, \"C\": 0.30, \"delta_V\": 1.0},\n            \"systems\": {\n                \"slab+CO\": {\n                    \"n\": np.array([0.10, 0.12, 0.15, 0.08, 0.20, 0.18, 0.25, 0.22]),\n                    \"g\": np.array([0.20, 0.25, 0.30, 0.15, 0.35, 0.28, 0.40, 0.33]),\n                },\n                \"slab\": {\n                    \"n\": np.array([0.09, 0.11, 0.14, 0.08, 0.19, 0.17, 0.24, 0.21]),\n                    \"g\": np.array([0.08, 0.10, 0.12, 0.06, 0.14, 0.12, 0.16, 0.14]),\n                },\n                \"CO\": {\n                    \"n\": np.array([0.01, 0.01, 0.01, 0.00, 0.01, 0.01, 0.01, 0.01]),\n                    \"g\": np.array([0.03, 0.04, 0.05, 0.00, 0.05, 0.04, 0.06, 0.05]),\n                },\n            },\n        },\n        {\n            \"params\": {\"A\": 0.75, \"C\": 0.30, \"delta_V\": 1.0},\n            \"systems\": {\n                \"slab+CO\": {\n                    \"n\": np.array([0.00, 0.002, 0.005, 0.000, 0.001]),\n                    \"g\": np.array([0.000, 0.008, 0.012, 0.000, 0.006]),\n                },\n                \"slab\": {\n                    \"n\": np.array([0.00, 0.0015, 0.0035, 0.000, 0.0008]),\n                    \"g\": np.array([0.000, 0.006, 0.010, 0.000, 0.004]),\n                },\n                \"CO\": {\n                    \"n\": np.array([0.00, 0.0005, 0.0015, 0.000, 0.0003]),\n                    \"g\": np.array([0.000, 0.003, 0.005, 0.000, 0.002]),\n                },\n            },\n        },\n    ]\n\n    def calculate_delta_exc(n_grid, g_grid, A, C, delta_V):\n        \"\"\"\n        Calculates Delta E_xc = E_xc^GGA - E_xc^LDA for a single system.\n        \"\"\"\n        total_delta_exc = 0.0\n        for i in range(len(n_grid)):\n            n = n_grid[i]\n            g = g_grid[i]\n\n            if n == 0.0:\n                continue\n\n            # Calculate Fermi wavevector, k_F = (3 * pi^2 * n)^(1/3)\n            kF = (3 * np.pi**2 * n)**(1/3)\n            \n            # Calculate dimensionless reduced gradient, s = g / (2 * k_F * n)\n            s = g / (2 * kF * n)\n            \n            # Calculate the contribution to Delta E_xc from this grid point\n            # Delta E_xc_i = A * n^(4/3) * (C * s^2 / (1 + C * s^2)) * delta_V\n            term = A * n**(4/3)\n            correction_factor = (C * s**2) / (1 + C * s**2)\n            \n            total_delta_exc += term * correction_factor * delta_V\n            \n        return total_delta_exc\n\n    results = []\n    for case in test_cases:\n        params = case[\"params\"]\n        systems = case[\"systems\"]\n        \n        A = params[\"A\"]\n        C = params[\"C\"]\n        delta_V = params[\"delta_V\"]\n        \n        delta_exc_slab_co = calculate_delta_exc(\n            systems[\"slab+CO\"][\"n\"], systems[\"slab+CO\"][\"g\"], A, C, delta_V\n        )\n        \n        delta_exc_slab = calculate_delta_exc(\n            systems[\"slab\"][\"n\"], systems[\"slab\"][\"g\"], A, C, delta_V\n        )\n        \n        delta_exc_co = calculate_delta_exc(\n            systems[\"CO\"][\"n\"], systems[\"CO\"][\"g\"], A, C, delta_V\n        )\n        \n        # Delta E_ads = Delta E_xc(slab+CO) - Delta E_xc(slab) - Delta E_xc(CO)\n        delta_E_ads = delta_exc_slab_co - delta_exc_slab - delta_exc_co\n        \n        results.append(round(delta_E_ads, 6))\n\n    # Format the final output string\n    print(f\"[{','.join(map(str, results))}]\")\n\n\nsolve()\n```"
        },
        {
            "introduction": "Solving the Kohn-Sham equations is not a direct calculation but an iterative process known as the Self-Consistent Field (SCF) cycle, which seeks a density that generates a potential that, in turn, reproduces the same density. This process can be slow or even unstable, particularly for metallic systems common in catalysis. This advanced practice  peels back the layers of the SCF algorithm, allowing you to model its convergence behavior and explore how numerical parameters, such as mixing schemes and preconditioners, can be optimized to ensure a fast and stable solution. This exercise transforms the SCF procedure from a black box into a comprehensible numerical method.",
            "id": "3876845",
            "problem": "Consider a self-consistent field (SCF) procedure for solving the Kohn-Sham equations arising from Density Functional Theory (DFT) for a slab model of a catalytic surface with an adsorbate. The Hohenberg-Kohn theorems establish that the ground-state electron density $n(\\mathbf{r})$ uniquely determines all properties of the system, and the Kohn-Sham construction maps the interacting electron problem onto a non-interacting system in an effective potential $v_{\\mathrm{KS}}[n](\\mathbf{r})$. A practical SCF algorithm iterates a fixed-point map for the density, $n^{(k+1)}(\\mathbf{r}) = \\mathcal{G}[n^{(k)}](\\mathbf{r})$, where $\\mathcal{G}$ denotes building the Kohn-Sham Hamiltonian from $n^{(k)}(\\mathbf{r})$, solving for Kohn-Sham orbitals, and constructing the output density. Define the residual as $R[n] = \\mathcal{G}[n] - n$. Linearizing near the fixed point $n^\\star(\\mathbf{r})$ yields an error evolution $e^{(k+1)}(\\mathbf{r}) \\approx \\left(I - \\alpha \\mathcal{P}\\mathcal{J}\\right)e^{(k)}(\\mathbf{r})$, where $e^{(k)} = n^{(k)} - n^\\star$, $\\alpha$ is a scalar mixing parameter, $\\mathcal{P}$ is a preconditioner, and $\\mathcal{J} = \\left.\\delta R/\\delta n\\right|_{n^\\star}$ is the Jacobian of the residual map.\n\nAssume a plane-wave representation so that Fourier modes labeled by wavevector magnitude $q$ decouple under linearization. In this basis, write the eigenvalues of $\\mathcal{J}$ as $\\lambda(q)$ and the preconditioner as $P(q;k_s)$, where $k_s$ is a screening parameter. For Kerker-type preconditioning, $P(q;k_s) = q^2/(q^2 + k_s^2)$. Then each Fourier error component evolves as $e_{q}^{(k+1)} \\approx \\left(1 - \\alpha P(q;k_s)\\lambda(q)\\right) e_{q}^{(k)}$. The asymptotic linear convergence factor is the spectral radius $\\rho(\\alpha,k_s) = \\max_{q \\in \\mathcal{Q}} \\left|1 - \\alpha P(q;k_s)\\lambda(q)\\right|$, where $\\mathcal{Q}$ is the set of relevant wavevectors. If $\\rho(\\alpha,k_s) \\ge 1$, the linearized iteration is unstable. If $\\rho(\\alpha,k_s)  1$, the number of iterations $N$ required to reduce the error norm by a factor $\\delta \\in (0,1)$ satisfies $N \\ge \\left\\lceil \\log(\\delta) / \\log(\\rho(\\alpha,k_s)) \\right\\rceil$.\n\nYou are given a simplified, physically motivated model for a surface adsorption calculation in which the effective response eigenvalues are modeled as $\\lambda(q) = \\lambda_0 + \\lambda_1/(q^2 + \\eta)$, with parameters $\\lambda_0  0$, $\\lambda_1  0$, and $\\eta  0$ chosen to represent metal-like sloshing (large $\\lambda_1$ and small $\\eta$) or semiconductor-like behavior (smaller $\\lambda_1$ and larger $\\eta$). The preconditioner is the Kerker filter $P(q;k_s) = q^2/(q^2 + k_s^2)$ with screening parameter $k_s \\ge 0$. The simple mixing parameter is $\\alpha \\in (0,1]$.\n\nYour task is to compute, for each test case below, the spectral radius $\\rho(\\alpha,k_s)$ and the predicted iteration count $N(\\alpha,k_s,\\delta)$ over a discrete grid of $(\\alpha,k_s)$, and then select $(\\alpha,k_s)$ that minimizes $N$. If multiple $(\\alpha,k_s)$ yield the same minimal $N$, break ties by choosing the one with the smallest $\\rho$, then the smallest $\\alpha$, then the smallest $k_s$. If no $(\\alpha,k_s)$ on the grid yields $\\rho  1$, report that the scheme is not convergent on this grid.\n\nFundamental base and definitions to use:\n- The Hohenberg-Kohn theorems guarantee that minimizing an energy functional of $n(\\mathbf{r})$ yields the ground state; the Kohn-Sham equations define a fixed-point mapping $n \\mapsto \\mathcal{G}[n]$.\n- A linear fixed-point iteration $x^{(k+1)} = M x^{(k)}$ converges if the spectral radius of $M$ is less than $1$.\n- For the SCF iteration with simple mixing and a linear preconditioner in Fourier space, the per-mode error amplification factor is $1 - \\alpha P(q;k_s)\\lambda(q)$.\n- The asymptotic error reduction factor after $N$ steps is approximately $\\rho^N$, and to reduce the error norm by a factor $\\delta$ one needs $N \\ge \\lceil \\log(\\delta)/\\log(\\rho) \\rceil$ when $0  \\rho  1$.\n\nUnits and numerical requirements:\n- Wavevectors $q$ and screening parameters $k_s$ must be treated in inverse angstrom units $\\mathrm{\\AA}^{-1}$.\n- The mixing parameter $\\alpha$ is dimensionless.\n- The spectral radius $\\rho$ is dimensionless.\n- The iteration count $N$ is a dimensionless integer.\n- The target error reduction factor is $\\delta \\in (0,1)$ and dimensionless.\n\nImplementation details to enforce:\n- Use the model $\\lambda(q) = \\lambda_0 + \\lambda_1/(q^2 + \\eta)$ for each specified test case.\n- Use $P(q;k_s) = q^2/(q^2 + k_s^2)$ for $k_s \\ge 0$. For $k_s = 0$, take $P(q;0) = 1$ for $q  0$.\n- For a given pair $(\\alpha,k_s)$, compute $\\rho(\\alpha,k_s) = \\max_{q \\in \\mathcal{Q}} |1 - \\alpha P(q;k_s)\\lambda(q)|$.\n- If $\\rho(\\alpha,k_s)  1$, compute $N(\\alpha,k_s,\\delta) = \\left\\lceil \\log(\\delta)/\\log(\\rho(\\alpha,k_s)) \\right\\rceil$. If $\\rho(\\alpha,k_s) = 0$, define $N = 1$.\n- If no $(\\alpha,k_s)$ on the grid yields $\\rho  1$, return $\\rho_{\\min} = +\\infty$, $N_{\\min} = -1$, $\\alpha_{\\mathrm{opt}} = -1$, $k_{s,\\mathrm{opt}} = -1$.\n\nTest suite:\n- Case $1$ (metallic slab with adsorbate): $\\mathcal{Q} = \\{0.05, 0.10, 0.20, 0.50, 1.00\\}$ $\\mathrm{\\AA}^{-1}$, $\\lambda_0 = 0.2$, $\\lambda_1 = 5.0$, $\\eta = 0.02$.\n- Case $2$ (semiconducting slab with adsorbate): $\\mathcal{Q} = \\{0.05, 0.10, 0.20, 0.50, 1.00\\}$ $\\mathrm{\\AA}^{-1}$, $\\lambda_0 = 0.2$, $\\lambda_1 = 0.5$, $\\eta = 0.20$.\n- Case $3$ (strongly polar adsorbate on a metal): $\\mathcal{Q} = \\{0.05, 0.10, 0.20, 0.50, 1.00\\}$ $\\mathrm{\\AA}^{-1}$, $\\lambda_0 = 0.2$, $\\lambda_1 = 20.0$, $\\eta = 0.02$.\n\nGrid of parameters to search:\n- $\\alpha \\in \\{0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0\\}$ (dimensionless).\n- $k_s \\in \\{0.0, 0.2, 0.5, 1.0, 2.0\\}$ $\\mathrm{\\AA}^{-1}$.\n\nTarget error reduction for all cases:\n- $\\delta = 10^{-6}$ (dimensionless).\n\nRequired program output:\n- For each of the three cases, compute the optimal settings on the given grid and report a list $[\\rho_{\\min}, N_{\\min}, \\alpha_{\\mathrm{opt}}, k_{s,\\mathrm{opt}}]$, where $\\rho_{\\min}$ is rounded to six decimal places, $N_{\\min}$ is an integer, and $\\alpha_{\\mathrm{opt}}$ and $k_{s,\\mathrm{opt}}$ are rounded to three decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list of these three lists enclosed in square brackets (e.g., $[[\\rho_1,N_1,\\alpha_1,k_{s,1}],[\\rho_2,N_2,\\alpha_2,k_{s,2}],[\\rho_3,N_3,\\alpha_3,k_{s,3}]]$).",
            "solution": "The user has provided a problem statement that has been validated and deemed valid. The problem is scientifically grounded in the principles of Density Functional Theory (DFT) and numerical methods for solving the Kohn-Sham equations. It is well-posed, providing all necessary models, parameters, and constraints to arrive at a unique solution. The language is objective and the task is a formalizable optimization problem.\n\nThe objective is to find the optimal simple mixing parameter $\\alpha$ and Kerker preconditioning parameter $k_s$ from a discrete grid that minimize the number of Self-Consistent Field (SCF) iterations, $N$, required to achieve a specified error reduction, $\\delta$. This is a common practical problem in computational catalysis and materials science.\n\nThe analysis hinges on the linearized convergence of the SCF cycle. For a given set of parameters $(\\alpha, k_s)$, the convergence is dictated by the spectral radius, $\\rho(\\alpha, k_s)$, of the iteration matrix. The iteration is stable if and only if $\\rho(\\alpha, k_s)  1$. The spectral radius is defined as the maximum magnitude of the error amplification factor over all relevant Fourier modes, indexed by wavevector magnitude $q$.\nThe error amplification factor for a mode $q$ is given by:\n$$ A_q(\\alpha, k_s) = \\left|1 - \\alpha P(q;k_s)\\lambda(q)\\right| $$\nThe spectral radius is then:\n$$ \\rho(\\alpha, k_s) = \\max_{q \\in \\mathcal{Q}} A_q(\\alpha, k_s) $$\nwhere $\\mathcal{Q}$ is the discrete set of relevant wavevectors.\n\nThe problem provides the following models for the Jacobian eigenvalues $\\lambda(q)$ and the preconditioner $P(q;k_s)$:\n1.  **Jacobian Eigenvalue Model**: This models the response of the system.\n    $$ \\lambda(q) = \\lambda_0 + \\frac{\\lambda_1}{q^2 + \\eta} $$\n    with system-dependent parameters $\\lambda_0$, $\\lambda_1$, and $\\eta$.\n2.  **Kerker Preconditioner**: This is designed to damp charge sloshing instabilities, which correspond to large $\\lambda(q)$ at small $q$.\n    $$ P(q; k_s) = \\frac{q^2}{q^2 + k_s^2} $$\n    where $k_s$ is the screening parameter. For the special case $k_s = 0$, the preconditioner becomes $P(q; 0) = 1$ for $q  0$, which corresponds to simple mixing without preconditioning.\n\nThe number of iterations $N$ required to reduce an error metric by a factor $\\delta$ is related to the spectral radius $\\rho$ by:\n$$ N(\\alpha, k_s, \\delta) = \\left\\lceil \\frac{\\log(\\delta)}{\\log(\\rho(\\alpha, k_s))} \\right\\rceil $$\nThis formula is valid for $0  \\rho  1$. For the case $\\rho = 0$, the error is eliminated in a single step, so $N = 1$. If $\\rho \\ge 1$, the iteration diverges, and we consider the number of iterations to be infinite.\n\nThe solution strategy is to perform a grid search over the provided discrete sets of $\\alpha$ and $k_s$ for each test case.\nFor each test case, we define the parameters $(\\lambda_0, \\lambda_1, \\eta)$ and the set of wavevectors $\\mathcal{Q}$.\nWe initialize a variable to hold the best parameters found so far, for instance, a tuple `(best_N, best_rho, best_alpha, best_ks)` with initial values corresponding to a divergent case (e.g., $(\\infty, \\infty, -1, -1)$).\n\nThe algorithm proceeds as follows:\n1.  Iterate through each test case.\n2.  For the current test case, iterate through each value of $\\alpha$ in its grid.\n3.  For each $\\alpha$, iterate through each value of $k_s$ in its grid.\n4.  For the current pair $(\\alpha, k_s)$:\n    a. Calculate the per-mode amplification factors $A_q(\\alpha, k_s)$ for all $q \\in \\mathcal{Q}$ using the provided models for $\\lambda(q)$ and $P(q;k_s)$.\n    b. Determine the spectral radius $\\rho(\\alpha, k_s)$ by finding the maximum of these amplification factors.\n    c. Check for convergence: if $\\rho(\\alpha, k_s)  1$:\n        i.  Calculate the number of iterations $N$. If $\\rho(\\alpha, k_s) = 0$, set $N=1$. Otherwise, compute $N = \\lceil \\log(\\delta) / \\log(\\rho(\\alpha, k_s)) \\rceil$.\n        ii. Compare the current result $(N, \\rho, \\alpha, k_s)$ with the best result found so far. The problem specifies a lexicographical tie-breaking rule: minimize $N$, then $\\rho$, then $\\alpha$, and finally $k_s$. A new result is better if it has a smaller $N$; if $N$ is equal, if it has a smaller $\\rho$; and so on.\n        iii. If the current result is better, update the stored best parameters.\n5.  After iterating through the entire $(\\alpha, k_s)$ grid for a test case:\n    a. If no convergent parameters were found (i.e., the initial \"best\" values were never updated), the result for this case is $(\\rho_{\\min}, N_{\\min}, \\alpha_{\\mathrm{opt}}, k_{s,\\mathrm{opt}}) = (\\infty, -1, -1, -1)$.\n    b. Otherwise, the result is the set of best parameters found.\n6.  The final output is a list containing the result lists for each of the three test cases, formatted according to the specified precision.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DFT SCF convergence optimization problem for three test cases.\n    \"\"\"\n    # Define the grid of parameters to search\n    alpha_grid = np.array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0])\n    ks_grid = np.array([0.0, 0.2, 0.5, 1.0, 2.0])\n\n    # Define the target error reduction\n    delta = 1e-6\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Case 1 (metallic)\",\n            \"Q\": np.array([0.05, 0.10, 0.20, 0.50, 1.00]),\n            \"lambda0\": 0.2, \"lambda1\": 5.0, \"eta\": 0.02\n        },\n        {\n            \"name\": \"Case 2 (semiconducting)\",\n            \"Q\": np.array([0.05, 0.10, 0.20, 0.50, 1.00]),\n            \"lambda0\": 0.2, \"lambda1\": 0.5, \"eta\": 0.20\n        },\n        {\n            \"name\": \"Case 3 (strongly polar)\",\n            \"Q\": np.array([0.05, 0.10, 0.20, 0.50, 1.00]),\n            \"lambda0\": 0.2, \"lambda1\": 20.0, \"eta\": 0.02\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        q_vectors = case[\"Q\"]\n        lambda0 = case[\"lambda0\"]\n        lambda1 = case[\"lambda1\"]\n        eta = case[\"eta\"]\n\n        # Initialize tracking for the best parameters for this case\n        # (N, rho, alpha, ks) tuple allows for lexicographical comparison\n        best_params_tuple = (float('inf'), float('inf'), -1.0, -1.0)\n\n        for alpha in alpha_grid:\n            for ks in ks_grid:\n                # Calculate lambda(q) for all q in Q\n                lambda_q = lambda0 + lambda1 / (q_vectors**2 + eta)\n\n                # Calculate P(q; k_s) based on k_s value\n                if ks == 0.0:\n                    P_q_ks = np.ones_like(q_vectors)\n                else:\n                    P_q_ks = q_vectors**2 / (q_vectors**2 + ks**2)\n                \n                # Calculate amplification factors for all modes\n                amp_factors = np.abs(1.0 - alpha * P_q_ks * lambda_q)\n\n                # Spectral radius is the maximum amplification factor\n                rho = np.max(amp_factors)\n\n                if rho  1.0:\n                    # Convergent case\n                    if rho == 0.0:\n                        N = 1\n                    else:\n                        N = np.ceil(np.log(delta) / np.log(rho))\n                    \n                    current_params_tuple = (N, rho, alpha, ks)\n                    \n                    # Compare with best found so far using lexicographical tuple comparison\n                    if current_params_tuple  best_params_tuple:\n                        best_params_tuple = current_params_tuple\n        \n        # After grid search for one case, store the result\n        N_min, rho_min, alpha_opt, ks_opt = best_params_tuple\n\n        if N_min == float('inf'):\n            # No convergent parameters found on the grid\n            all_results.append(['inf', -1, -1.0, -1.0])\n        else:\n            all_results.append([rho_min, int(N_min), alpha_opt, ks_opt])\n\n    # Format the final output string\n    result_strings = []\n    for res in all_results:\n        if res[0] == 'inf':\n             result_strings.append(f\"[{res[0]}, {res[1]}, {res[2]:.3f}, {res[3]:.3f}]\")\n        else:\n            rho, N, alpha, ks_val = res\n            result_strings.append(f\"[{rho:.6f}, {N}, {alpha:.3f}, {ks_val:.3f}]\")\n\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        }
    ]
}