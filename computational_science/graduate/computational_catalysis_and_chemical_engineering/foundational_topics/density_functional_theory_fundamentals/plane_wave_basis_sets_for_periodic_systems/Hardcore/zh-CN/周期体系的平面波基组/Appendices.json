{
    "hands_on_practices": [
        {
            "introduction": "在任何平面波计算中，首要步骤是选择动能截断能 $E_{\\text{cut}}$，它决定了我们基组的大小。这个参数直接控制着计算精度与成本之间的平衡。本练习  提供了一种基础的第一性原理方法，用于估算所需的平面波数量和内存，从而将抽象的 $E_{\\text{cut}}$ 参数转化为具体的计算资源需求。",
            "id": "3894563",
            "problem": "一位计算催化领域的研究人员正在使用平面波展开法，在周期性立方超胞中模拟一种体相氧化物。该立方晶胞边长为 $L = 15\\,\\text{\\AA}$，采用 Born–von Kármán 周期性边界条件，并在布里渊区（BZ）的单个 $\\Gamma$ 点（$\\mathbf{k} = \\mathbf{0}$）进行采样。平面波基组包含所有满足动能截断标准 $E_{\\text{kin}} \\leq E_{\\text{cut}}$ 的倒易晶格矢量 $\\mathbf{G}$。假设为非自旋极化态，并且在存储中不使用时间反演或实波函数对称性；系数以复数双精度数的形式存储。\n\n仅从以下基本定义和事实出发：\n- 对于立方晶胞，倒易晶格矢量为 $\\mathbf{G} = \\frac{2\\pi}{L}\\mathbf{n}$，其中 $\\mathbf{n} \\in \\mathbb{Z}^{3}$。\n- 对于一个质量为 $m_{e}$ 的电子，其波矢为 $\\mathbf{k} + \\mathbf{G}$ 的平面波分量的动能为 $E_{\\text{kin}} = \\frac{\\hbar^{2}}{2 m_{e}} \\lvert \\mathbf{k} + \\mathbf{G} \\rvert^{2}$。\n- 在倒易空间中使用连续介质近似，通过 $\\mathbf{G}$ 空间中一个球体的体积来估计所包含的 $\\mathbf{G}$ 矢量的数量，并包括 $\\mathbf{G} = \\mathbf{0}$ 矢量。\n\n已知：\n- $E_{\\text{cut}} = 400\\,\\text{eV}$，\n- $N_{b} = 600$ 个能带，\n- 每个复数系数以 $16$ 字节存储，\n- 使用 $1\\,\\text{GB} = 10^{9}\\,\\text{字节}$，\n- 物理常数： $\\hbar = 1.054571817 \\times 10^{-34}\\,\\text{J}\\cdot\\text{s}$， $m_{e} = 9.1093837015 \\times 10^{-31}\\,\\text{kg}$，以及 $1\\,\\text{eV} = 1.602176634 \\times 10^{-19}\\,\\text{J}$。\n\n请从第一性原理出发，推导所包含的平面波数量 $N_{G}$ 的估计值，然后估计在单个 $\\Gamma$ 点存储 $N_{b}$ 个能带的所有平面波系数所需的总内存 $M$（以吉字节为单位）。将 $N_{G}$ 和 $M$ 都四舍五入到三位有效数字。将您的最终答案表示为行矩阵 $\\begin{pmatrix} N_{G}  M \\end{pmatrix}$，其中 $M$ 的单位为吉字节（在最终的方框答案中不要包含单位）。",
            "solution": "该问题被认为是有效的，因为它具有坚实的固态物理学科学基础，问题是适定的、客观的，并包含了求解所需的所有必要信息。\n\n求解过程分为两部分：首先，我们估计基组中的平面波数量（$N_G$）；其次，我们计算存储波函数系数所需的总内存（$M$）。\n\n**第一部分：平面波数量（$N_G$）的估计**\n\n问题陈述，平面波基组包含所有其动能小于或等于截断能量 $E_{\\text{cut}}$ 的倒易晶格矢量 $\\mathbf{G}$。对于波矢为 $\\mathbf{k} + \\mathbf{G}$ 的平面波，其动能由下式给出：\n$$E_{\\text{kin}} = \\frac{\\hbar^{2}}{2 m_{e}} |\\mathbf{k} + \\mathbf{G}|^{2}$$\n计算在布里渊区的 $\\Gamma$ 点进行，该点对应 $\\mathbf{k} = \\mathbf{0}$。因此，将倒易晶格矢量 $\\mathbf{G}$ 包含在基组中的条件简化为：\n$$\\frac{\\hbar^{2}}{2 m_{e}} |\\mathbf{G}|^{2} \\leq E_{\\text{cut}}$$\n这个不等式在倒易空间（G空间）中定义了一个以 $\\mathbf{G} = \\mathbf{0}$ 为中心的球体。所有位于该球体内部或其表面上的 $\\mathbf{G}$ 矢量都包含在基组中。该球体的半径，我们记作 $G_{\\text{cut}}$，可通过整理该不等式得到：\n$$|\\mathbf{G}|^{2} \\leq \\frac{2 m_{e} E_{\\text{cut}}}{\\hbar^{2}}$$\n$$G_{\\text{cut}} = \\sqrt{\\frac{2 m_{e} E_{\\text{cut}}}{\\hbar^{2}}}$$\n因此，该球体在G空间中的体积为：\n$$V_{\\text{sphere}} = \\frac{4}{3}\\pi G_{\\text{cut}}^{3} = \\frac{4}{3}\\pi \\left(\\frac{2 m_{e} E_{\\text{cut}}}{\\hbar^{2}}\\right)^{3/2}$$\n对于边长为 $L$ 的立方晶胞，其倒易晶格矢量由 $\\mathbf{G} = \\frac{2\\pi}{L}\\mathbf{n}$ 给出，其中 $\\mathbf{n} = (n_x, n_y, n_z)$ 是一个整数矢量。这些矢量在G空间中构成一个简单立方晶格。该倒易晶格的原胞体积，即单个 $\\mathbf{G}$ 矢量所占据的体积，为：\n$$V_{\\text{cell}} = \\left(\\frac{2\\pi}{L}\\right)^{3} = \\frac{8\\pi^{3}}{L^{3}}$$\n题目要求我们使用连续介质近似来估计 $\\mathbf{G}$ 矢量的数量 $N_G$。这通过将球体的总体积除以每个 $\\mathbf{G}$ 矢量所占的体积来实现。这种方法恰当地包含了位于球体中心的 $\\mathbf{G} = \\mathbf{0}$ 矢量。\n$$N_{G} \\approx \\frac{V_{\\text{sphere}}}{V_{\\text{cell}}} = \\frac{\\frac{4}{3}\\pi \\left(\\frac{2 m_{e} E_{\\text{cut}}}{\\hbar^{2}}\\right)^{3/2}}{\\frac{8\\pi^{3}}{L^{3}}}$$\n简化此表达式可得：\n$$N_{G} \\approx \\frac{4\\pi L^{3}}{3 \\cdot 8\\pi^{3}} \\left(\\frac{2 m_{e} E_{\\text{cut}}}{\\hbar^{2}}\\right)^{3/2} = \\frac{L^{3}}{6\\pi^{2}} \\left(\\frac{2 m_{e} E_{\\text{cut}}}{\\hbar^{2}}\\right)^{3/2}$$\n现在，我们以国际单位制（SI）单位代入给定的物理常数和参数。我们使用标准转换 $1\\,\\text{\\AA} = 10^{-10}\\,\\text{m}$。\n- $L = 15\\,\\text{\\AA} = 15 \\times 10^{-10}\\,\\text{m}$\n- $E_{\\text{cut}} = 400\\,\\text{eV} = 400 \\times 1.602176634 \\times 10^{-19}\\,\\text{J} = 6.408706536 \\times 10^{-17}\\,\\text{J}$\n- $\\hbar = 1.054571817 \\times 10^{-34}\\,\\text{J}\\cdot\\text{s}$\n- $m_{e} = 9.1093837015 \\times 10^{-31}\\,\\text{kg}$\n\n首先，我们计算括号内的项：\n$$\\frac{2 m_{e} E_{\\text{cut}}}{\\hbar^{2}} = \\frac{2 \\times (9.1093837015 \\times 10^{-31}\\,\\text{kg}) \\times (6.408706536 \\times 10^{-17}\\,\\text{J})}{(1.054571817 \\times 10^{-34}\\,\\text{J}\\cdot\\text{s})^{2}}$$\n$$\\frac{2 m_{e} E_{\\text{cut}}}{\\hbar^{2}} \\approx \\frac{1.16773344 \\times 10^{-46}}{1.11212263 \\times 10^{-68}}\\,\\text{m}^{-2} \\approx 1.05000342 \\times 10^{22}\\,\\text{m}^{-2}$$\n现在我们可以计算 $N_G$：\n$$N_{G} \\approx \\frac{(15 \\times 10^{-10}\\,\\text{m})^{3}}{6\\pi^{2}} \\left(1.05000342 \\times 10^{22}\\,\\text{m}^{-2}\\right)^{3/2}$$\n$$N_{G} \\approx \\frac{3.375 \\times 10^{-27}\\,\\text{m}^{3}}{59.217626} \\left(1.0760431 \\times 10^{33}\\,\\text{m}^{-3}\\right)$$\n$$N_{G} \\approx (5.69910 \\times 10^{-29}\\,\\text{m}^{3}) \\times (1.0760431 \\times 10^{33}\\,\\text{m}^{-3})$$\n$$N_{G} \\approx 61325.8$$\n四舍五入到三位有效数字，我们得到 $N_{G} \\approx 61300$，即 $6.13 \\times 10^{4}$。\n\n**第二部分：总内存（$M$）的估计**\n\n存储平面波系数所需的总内存取决于能带数量（$N_b$）、每个能带的平面波基函数数量（$N_G$）以及存储单个系数所需的内存。\n\n每个能带的波函数在平面波基组中展开。对于在单个 $\\mathbf{k}$ 点进行的非自旋极化计算，我们需要为 $N_b$ 个能带中的每一个存储 $N_G$ 个复数系数。问题陈述中提到，没有使用对称性来减少存储空间。\n需要存储的总系数数量为 $N_{\\text{coeffs}} = N_{b} \\times N_{G}$。\n已知：\n- 能带数量，$N_{b} = 600$。\n- 平面波数量，$N_{G} \\approx 61325.8$。\n- 每个复数系数的内存 = $16\\,\\text{字节}$。\n\n总内存（以字节为单位）为：\n$$M_{\\text{bytes}} = N_{b} \\times N_{G} \\times 16\\,\\text{bytes/coeff}$$\n$$M_{\\text{bytes}} = 600 \\times 61325.8 \\times 16 = 588727680\\,\\text{bytes}$$\n问题指明使用转换关系 $1\\,\\text{GB} = 10^{9}\\,\\text{字节}$。\n$$M = \\frac{M_{\\text{bytes}}}{10^{9}} = \\frac{588727680}{10^{9}}\\,\\text{GB} = 0.58872768\\,\\text{GB}$$\n四舍五入到三位有效数字，我们得到：\n$$M \\approx 0.589\\,\\text{GB}$$\n\n最终答案是四舍五入到三位有效数字的数值对 $(N_G, M)$。\n$N_G \\approx 6.13 \\times 10^{4}$\n$M \\approx 0.589$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n6.13 \\times 10^{4}  0.589\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "对于周期性体系，特别是金属，精确计算电子性质需要对布里渊区进行积分。我们通过一个离散的 k 点网格来近似这个积分，而网格的密度是另一个关键的收敛参数。本练习  使用简化的自由电子模型来估算收敛费米能所需的 k 点数量，阐明了所需的采样密度如何依赖于材料性质和目标精度。",
            "id": "3894559",
            "problem": "给定一个假设性的单价简立方金属，其原胞中含有一个原子，在零温下具有类自由电子导带。考虑一个由晶格常数为 $a$ 的原胞构成的尺寸为 $S \\times S \\times S$ 的三维周期性超胞，并使用一个三维Monkhorst-Pack (MP) 网格对布里渊区进行采样，该网格的总$\\mathbf{k}$点数为 $N_k = N_{\\text{side}}^3$，其中 $N_{\\text{side}}$ 是每个倒易方向上的点数。您的任务是从第一性原理出发，估算所需的最小整数 $N_k$，以确保费米能 $E_F$ 的收敛精度在目标容差 $\\delta E_F$（单位为电子伏特）之内。该估算应是超胞尺寸 $S$、晶格常数 $a$（单位为埃）和每个原子的价电子数 $z$ 的函数。\n\n该估算必须从基本定义和经过充分检验的公式开始：\n- 使用布洛赫定理和简立方晶格第一布里渊区的定义，其在每个方向上的倒易晶格间距为 $2\\pi/a$。\n- 在零温下，将能带建模为自由电子色散关系 $E(\\mathbf{k}) = \\hbar^2 |\\mathbf{k}|^2 / (2m_e)$，其中 $\\hbar$ 是约化普朗克常数，$m_e$ 是电子质量。\n- 使用电子数密度与费米波矢之间的标准关系，$n = z/a^3$ 以及 $k_F = (3\\pi^2 n)^{1/3}$。\n- 将对已占据态的指示函数在$\\mathbf{k}$空间中的积分解释为在 MP 网格上的黎曼和，并将倒易空间中的离散化间距与超胞尺寸 $S$ 和 $N_{\\text{side}}$ 的共同作用联系起来。\n- 从这些原理出发，推导费米能误差 $\\delta E_F$ 相对于倒易空间网格间距的标度关系，并将其反转以获得最小的 $N_{\\text{side}}$，从而得到满足指定容差 $\\delta E_F$ 所需的最小总$\\mathbf{k}$点数 $N_k = N_{\\text{side}}^3$。\n\n最终的程序必须使用国际单位制中的物理常数对该估算进行数值实现，并报告以下测试集的整数 $N_k$。所有能量必须以电子伏特表示，所有长度必须以埃表示，本问题不使用角度。最终输出必须是单行，其中包含一个方括号括起来的逗号分隔的结果列表，顺序与测试集一致。\n\n测试集：\n1. $a = 3.000$ 埃, $z = 1$, $S = 1$, $\\delta E_F = 0.500$ 电子伏特。\n2. $a = 3.000$ 埃, $z = 1$, $S = 4$, $\\delta E_F = 0.500$ 电子伏特。\n3. $a = 3.000$ 埃, $z = 1$, $S = 2$, $\\delta E_F = 0.200$ 电子伏特。\n4. $a = 2.500$ 埃, $z = 2$, $S = 2$, $\\delta E_F = 0.300$ 电子伏特。\n5. $a = 3.500$ 埃, $z = 1$, $S = 8$, $\\delta E_F = 0.200$ 电子伏特。\n6. $a = 3.000$ 埃, $z = 1$, $S = 20$, $\\delta E_F = 1.000$ 电子伏特。\n\n您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表（例如，$[n_1,n_2,n_3,n_4,n_5,n_6]$），其中每个 $n_i$ 是相应测试用例所需的最小整数总$\\mathbf{k}$点数 $N_k$。不应打印任何其他输出。",
            "solution": "该问题被评估为有效，因为它科学地基于固态物理学原理，问题定义明确、客观且内部一致。它代表了计算材料科学中的一个标准估算问题。\n\n任务是推导出一个估算公式，用于计算将简立方金属的费米能 $E_F$ 收敛到容差 $\\delta E_F$ 内所需的最小$\\mathbf{k}$点数 $N_k$。该推导基于自由电子模型和对布里渊区的Monkhorst-Pack (MP) 网格采样。\n\n首先，我们建立基本关系。该系统是一个简立方金属，晶格常数为 $a$，每个原胞有 $z$ 个价电子。因此，电子数密度 $n$ 为 $n = z/a^3$。在零温（$T=0$）下的自由电子气模型中，已占据的电子态在倒易空间中填充一个半径为 $k_F$ 的球体，即费米球。$n$ 与 $k_F$ 之间的关系由下式给出：\n$$ n = \\frac{k_F^3}{3\\pi^2} $$\n这考虑了每个$\\mathbf{k}$矢量对应的两个自旋态。代入 $n$ 的表达式，我们得到费米波矢：\n$$ k_F = \\left(\\frac{3\\pi^2 z}{a^3}\\right)^{1/3} $$\n能带结构由自由电子色散关系 $E(\\mathbf{k}) = \\frac{\\hbar^2 |\\mathbf{k}|^2}{2m_e}$ 给出，其中 $\\hbar$ 是约化普朗克常数，$m_e$ 是电子质量。精确的费米能是费米球面上的能量：\n$$ E_F = E(k_F) = \\frac{\\hbar^2 k_F^2}{2m_e} $$\n接下来，我们考虑计算设置。我们使用一个尺寸为 $S \\times S \\times S$ 的周期性超胞，其实空间晶格常数为 $L = Sa$。该超胞的倒易晶格矢量具有特征长度 $2\\pi/L = 2\\pi/(Sa)$。超胞的第一布里渊区（BZ）是一个边长为 $2\\pi/(Sa)$ 的立方体。该 BZ 由一个 $N_{\\text{side}} \\times N_{\\text{side}} \\times N_{\\text{side}}$ 的 MP 网格进行采样。$\\mathbf{k}$点网格中沿每个笛卡尔方向的相邻点之间的间距是均匀的：\n$$ \\Delta k = \\frac{2\\pi/(Sa)}{N_{\\text{side}}} = \\frac{2\\pi}{S a N_{\\text{side}}} $$\n$\\mathbf{k}$空间的离散化意味着费米面没有被完美地表示。计算出的费米能 $E_F^{\\text{calc}}$ 是最高占据离散$\\mathbf{k}$态的能量。误差 $\\delta E_F = |E_F - E_F^{\\text{calc}}|$ 的产生是因为离散的k点并不完全落在理想的费米球上。对此能量误差的一个可靠估计是考虑在$\\mathbf{k}$空间中一个特征距离上的能量变化，该距离与网格间距 $\\Delta k$ 的量级相同。\n\n能量相对于波矢大小 $k=|\\mathbf{k}|$ 的变化由群速度关系给出：\n$$ \\frac{dE}{dk} = \\frac{d}{dk}\\left( \\frac{\\hbar^2 k^2}{2m_e} \\right) = \\frac{\\hbar^2 k}{m_e} $$\n最大能量误差将出现在费米面附近的态，其中 $k \\approx k_F$。能量误差 $\\delta E_F$ 可以通过一阶泰勒展开来近似：\n$$ \\delta E_F \\approx \\left| \\frac{dE}{dk} \\right|_{k=k_F} \\delta k $$\n其中 $\\delta k$ 是$\\mathbf{k}$空间中的有效离散化长度。我们用网格间距 $\\Delta k$ 来近似 $\\delta k$。\n$$ \\delta E_F \\approx \\frac{\\hbar^2 k_F}{m_e} \\Delta k = \\frac{\\hbar^2 k_F}{m_e} \\left( \\frac{2\\pi}{S a N_{\\text{side}}} \\right) $$\n为了满足收敛标准，我们要求网格足够精细，使得这个估算误差小于或等于目标容差，我们也用 $\\delta E_F$ 表示。我们可以重新整理方程，求解每个维度所需的网格点数 $N_{\\text{side}}$：\n$$ N_{\\text{side}} \\ge \\frac{2\\pi \\hbar^2 k_F}{m_e S a \\delta E_F} $$\n代入 $k_F = (3\\pi^2 z / a^3)^{1/3}$ 的表达式：\n$$ N_{\\text{side}} \\ge \\frac{2\\pi \\hbar^2}{m_e S a \\delta E_F} \\left(\\frac{3\\pi^2 z}{a^3}\\right)^{1/3} = \\frac{2\\pi (3\\pi^2 z)^{1/3} \\hbar^2}{m_e S a^2 \\delta E_F} $$\n由于 $N_{\\text{side}}$ 必须是整数，我们必须对一个表达式取上整，以找到满足不等式的最小整数值：\n$$ N_{\\text{side, min}} = \\left\\lceil \\frac{2\\pi (3\\pi^2 z)^{1/3} \\hbar^2}{m_e S a^2 \\delta E_F} \\right\\rceil $$\n总$\\mathbf{k}$点数为 $N_k = N_{\\text{side}}^3$。因此，所需的最小$\\mathbf{k}$点数为：\n$$ N_k = \\left( N_{\\text{side, min}} \\right)^3 = \\left( \\left\\lceil \\frac{2\\pi (3\\pi^2 z)^{1/3} \\hbar^2}{m_e S a^2 \\delta E_F} \\right\\rceil \\right)^3 $$\n该公式将被数值实现。在计算中，所有输入参数（$a$, $\\delta E_F$）必须转换为国际单位制单位（分别为米和焦耳），并且必须使用物理常数 $\\hbar$ 和 $m_e$ 的国际单位制数值。每个测试用例的最终结果是整数 $N_k$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import constants\n\ndef solve():\n    \"\"\"\n    Calculates the minimal number of k-points for a set of test cases\n    based on a derived first-principles estimate.\n    \"\"\"\n\n    # Physical constants in SI units from scipy.constants\n    # Reduced Planck constant in J·s\n    HBAR = constants.hbar\n    # Electron mass in kg\n    M_E = constants.m_e\n    # Elementary charge in C (for eV to J conversion)\n    E_CHARGE = constants.e\n    # Pi\n    PI = constants.pi\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (a, z, S, dE_F)\n    # a: lattice constant in angstrom\n    # z: valence electrons per atom\n    # S: supercell size factor\n    # dE_F: Fermi energy tolerance in electronvolts\n    test_cases = [\n        (3.000, 1, 1, 0.500),\n        (3.000, 1, 4, 0.500),\n        (3.000, 1, 2, 0.200),\n        (2.500, 2, 2, 0.300),\n        (3.500, 1, 8, 0.200),\n        (3.000, 1, 20, 1.000),\n    ]\n\n    results = []\n    \n    def estimate_nk(a_angstrom, z, S, dE_F_ev):\n        \"\"\"\n        Estimates the minimal integer N_k = N_side^3 required to meet the \n        Fermi energy convergence tolerance.\n\n        Args:\n            a_angstrom (float): Lattice constant in angstroms.\n            z (int): Valence electrons per atom.\n            S (int): Supercell size factor.\n            dE_F_ev (float): Fermi energy tolerance in eV.\n\n        Returns:\n            int: The minimal total number of k-points, N_k.\n        \"\"\"\n        # Convert inputs to SI units\n        # Angstrom to meters\n        a_si = a_angstrom * 1e-10\n        # Electronvolts to Joules\n        dE_F_si = dE_F_ev * E_CHARGE\n\n        # Calculate the expression for N_side based on the derived formula:\n        # N_side = (2*pi * (3*pi^2*z)^(1/3) * hbar^2) / (m_e * S * a^2 * dE_F)\n        \n        # Numerator of the expression\n        term_z = (3 * PI**2 * z)**(1/3)\n        numerator = 2 * PI * term_z * HBAR**2\n        \n        # Denominator of the expression\n        denominator = M_E * S * a_si**2 * dE_F_si\n        \n        # Calculate the floating-point value for N_side\n        if denominator == 0:\n            # Avoid division by zero, although not expected for the problem's constraints\n            return float('inf') \n            \n        n_side_float = numerator / denominator\n        \n        # The minimal integer N_side must be the ceiling of this value\n        n_side_min = int(np.ceil(n_side_float))\n        \n        # Total k-points N_k is N_side^3\n        nk = n_side_min**3\n        \n        return nk\n\n    for case in test_cases:\n        a, z, S, dE_F = case\n        result = estimate_nk(a, z, S, dE_F)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "我们最终的目标是充满信心地计算物理可观测量，例如反应能或吸附能。这最后一个练习  在一个真实的催化问题背景下，综合了平面波和 k 点收敛的概念。通过对一氧化碳吸附能的误差进行建模，我们将探索计算设置（$E_{\\text{cut}}$、$N_k$）与潜在物理模型的内在准确性（即，选择包含或不包含半芯态的 PAW 数据集）之间的实际权衡。",
            "id": "3894513",
            "problem": "您需要形式化、实现并评估一个基于物理动机的收敛模型，该模型用于计算在使用平面波基组时，一氧化碳在周期性过渡金属板上的吸附能。目标是量化在投影缀加波（PAW）数据集中包含半芯态对吸附能收敛性的影响，该收敛性是相对于平面波动能截断和布里渊区采样而言的。背景设定为高等研究生水平的计算催化和化学工程领域，并要求从第一性原理出发进行推导。\n\n此问题的基本基础如下：\n- 周期性电子结构问题使用平面波表示，这些平面波在周期性边界条件下遵循布洛赫定理。平面波基组由一个能量截断 $E_{\\text{cut}}$ 进行截断，这限制了所包含平面波的最大动能。忽略高波矢分量会在可观测量中产生系统性误差，该误差取决于赝电荷密度和赝波函数的光滑度。\n- 对波矢的布里渊区（BZ）积分通过一组有限的采样 $k$ 点来近似。离散化误差取决于被积函数的光滑度以及是否存在费米面等尖锐特征。\n- 一氧化碳在金属表面上的吸附能定义为 $E_{\\text{ads}} = E_{\\text{slab+CO}} - E_{\\text{slab}} - E_{\\text{CO}}$，并以电子伏特（eV）为单位报告。本问题中所有能量量都必须以 eV 表示。\n\n您必须从这些基础出发构建一个收敛模型，不得依赖于陈述中提供的任何快捷公式。利用关于傅里叶空间截断和布里渊区数值积分的物理推理，推导出一个关于吸附能误差随 $E_{\\text{cut}}$ 和 $k$ 点数 $N_k$ 变化的模型。假设包含半芯态会使 PAW 数据集更硬，这会相对于不含半芯态的数据集改变平面波截断误差的振幅，但定性的标度指数保持不变。\n\n假设系统具有以下参考常数和特定于数据集的常数：\n- 完全收敛的参考吸附能（代表无限平面波截断和无限密集 $k$ 点网格的极限）为 $E_{\\text{ads}}^{\\text{ref}} = -1.25$ eV。\n- 不含半芯态的数据集，在无限分辨率下，相对于 $E_{\\text{ads}}^{\\text{ref}}$ 有一个系统性偏移 $ \\delta_{\\text{no-semi}} = +0.030$ eV，平面波截断误差振幅为 $A_{\\text{no-semi}} = 3.0$ eV，指数为 $p_{\\text{no-semi}} = 1.0$， $k$ 点采样误差振幅为 $B_{\\text{no-semi}} = 0.22$ eV，指数为 $q_{\\text{no-semi}} = 1.0$。\n- 包含半芯态的数据集，在无限分辨率下，相对于 $E_{\\text{ads}}^{\\text{ref}}$ 有一个系统性偏移 $ \\delta_{\\text{semi}} = +0.010$ eV，平面波截断误差振幅为 $A_{\\text{semi}} = 8.0$ eV，指数为 $p_{\\text{semi}} = 1.0$， $k$ 点采样误差振幅为 $B_{\\text{semi}} = 0.20$ eV，指数为 $q_{\\text{semi}} = 1.0$。\n\n从第一性原理出发，推导出一个模型，用于预测在有限分辨率下，对于数据集 $D \\in \\{\\text{no-semi}, \\text{semi}\\}$ 的吸附能 $E_{\\text{ads}}^{D}(E_{\\text{cut}}, N_k)$，并由此推导出吸附能误差大小 $|E_{\\text{ads}}^{D}(E_{\\text{cut}}, N_k) - E_{\\text{ads}}^{\\text{ref}}|$。使用您推导的模型实现一个程序，对每个测试用例评估以下量：\n- 不含半芯态数据集的误差大小，单位为 eV。\n- 包含半芯态数据集的误差大小，单位为 eV。\n- 改进比率，定义为不含半芯态的误差除以包含半芯态的误差（无量纲）。\n- 一个布尔值，指示不含半芯态的数据集是否满足指定的收敛容差（误差小于或等于容差）。\n- 一个布尔值，指示包含半芯态的数据集是否满足指定的收敛容差（误差小于或等于容差）。\n\n测试套件包含四组参数，用于探测 $E_{\\text{cut}}$ 和 $k$ 点采样的不同区间：\n- 情况 1：$E_{\\text{cut}} = 300$ eV, $N_k = 12$, 容差 $= 0.050$ eV。\n- 情况 2：$E_{\\text{cut}} = 450$ eV, $N_k = 24$, 容差 $= 0.020$ eV。\n- 情况 3：$E_{\\text{cut}} = 550$ eV, $N_k = 36$, 容差 $= 0.010$ eV。\n- 情况 4：$E_{\\text{cut}} = 250$ eV, $N_k = 8$, 容差 $= 0.070$ eV。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个测试用例，按确切顺序输出上面列出的五个量，其中两个误差大小以 eV 表示（作为浮点数），改进比率作为浮点数，两个布尔值作为 Python 布尔值。总输出应该是四个测试用例的四组五元组的串联。例如，形如 $[e_{1}^{\\text{no-semi}}, e_{1}^{\\text{semi}}, r_1, b_{1}^{\\text{no-semi}}, b_{1}^{\\text{semi}}, e_{2}^{\\text{no-semi}}, e_{2}^{\\text{semi}}, r_2, b_{2}^{\\text{no-semi}}, b_{2}^{\\text{semi}}, e_{3}^{\\text{no-semi}}, e_{3}^{\\text{semi}}, r_3, b_{3}^{\\text{no-semi}}, b_{3}^{\\text{semi}}, e_{4}^{\\text{no-semi}}, e_{4}^{\\text{semi}}, r_4, b_{4}^{\\text{no-semi}}, b_{4}^{\\text{semi}}]$ 的输出格式是可以接受的，其中每个 $e_i$ 的单位是 eV，每个 $r_i$ 是无量纲的。将所有浮点输出四舍五入到 $6$ 位小数。",
            "solution": "该问题要求制定并实现一个收敛模型，用于计算在使用投影缀加波（PAW）框架内的平面波基组时，一氧化碳在周期性过渡金属板上的吸附能。该模型必须根据控制周期性电子结构计算中数值误差的物理原理推导出来。\n\n使用平面波基组计算的周期性系统的总能量受到两个主要数值误差来源的影响：平面波基组的截断和布里渊区（BZ）积分的离散化。我们将通过考虑这些误差如何通过定义方程传播来模拟计算出的吸附能 $E_{\\text{ads}}$：\n$$ E_{\\text{ads}} = E_{\\text{slab+CO}} - E_{\\text{slab}} - E_{\\text{CO}} $$\n这里，$E_{\\text{slab+CO}}$、$E_{\\text{slab}}$ 和 $E_{\\text{CO}}$ 分别是带有吸附分子的板、洁净板和孤立气相分子的总能量。\n\n一个常见且物理上合理的假设是，计算量中的总误差是来自每个数值参数的独立误差贡献之和。对于给定的数据集 $D$，在有限的平面波动能截断 $E_{\\text{cut}}$ 和有限数量的 $k$ 点 $N_k$ 下计算的吸附能，记为 $E_{\\text{ads}}^{D}(E_{\\text{cut}}, N_k)$，可以表示为与该数据集固有的、完全收敛的值的偏差。这个固有值本身可能与真实的物理参考能量 $E_{\\text{ads}}^{\\text{ref}} = -1.25$ eV 不同，其差异为一个系统性偏移 $\\delta_D$。这个偏移是所选 PAW 数据集（赝势）的一个特征。因此，对于数据集 $D$，计算收敛到的值是 $E_{\\text{ads}}^{\\text{ref}} + \\delta_D$。\n\n误差的贡献模型如下：\n\n1.  **平面波基组截断误差**：基组被截断，只包含动能高达 $E_{\\text{cut}}$ 的平面波。这个有限的基组是不完备的，并在总能量中引入误差。此误差的大小与 PAW 数据集的“硬度”有关；旨在获得更高精度的数据集（例如包含半芯态的数据集）会产生振荡更快（即更不光滑）的赝波函数和赝电荷密度，这需要更高动能的分量才能准确表示。这种误差通常表现为相对于截断能量的幂律衰减。我们将这个应用于吸附能的误差项建模为 $\\Delta E_{\\text{cut}}^D = A_D E_{\\text{cut}}^{-p_D}$，其中 $A_D$ 是一个振幅常数，$p_D$ 是一个衰减指数。问题指定两个数据集的 $p_D=1.0$。\n\n2.  **布里渊区采样误差**：在 BZ 上对物理量的积分被替换为在有限 $k$ 点网格上的加权和。对于金属系统，尖锐费米面的存在使被积函数非解析，导致积分相对于采样点数 $N_k$ 的收敛呈缓慢的幂律形式。我们将此离散化误差建模为 $\\Delta E_{k}^D = B_D N_k^{-q_D}$，其中 $B_D$ 是振幅，$q_D$ 是收敛指数。问题指定两个数据集的 $q_D=1.0$。\n\n结合这些元素，我们构建了针对数据集 $D \\in \\{\\text{no-semi}, \\text{semi}\\}$ 的计算吸附能模型：\n$$ E_{\\text{ads}}^{D}(E_{\\text{cut}}, N_k) = (E_{\\text{ads}}^{\\text{ref}} + \\delta_D) + \\Delta E_{\\text{cut}}^D + \\Delta E_{k}^D $$\n代入幂律误差模型，得到：\n$$ E_{\\text{ads}}^{D}(E_{\\text{cut}}, N_k) = E_{\\text{ads}}^{\\text{ref}} + \\delta_D + A_D E_{\\text{cut}}^{-p_D} + B_D N_k^{-q_D} $$\n\n问题要求的是计算值相对于真实参考能量 $E_{\\text{ads}}^{\\text{ref}}$ 的误差大小。这个误差 $\\text{Error}_D$ 是：\n$$ \\text{Error}_D(E_{\\text{cut}}, N_k) = E_{\\text{ads}}^{D}(E_{\\text{cut}}, N_k) - E_{\\text{ads}}^{\\text{ref}} $$\n代入 $E_{\\text{ads}}^{D}(E_{\\text{cut}}, N_k)$ 的模型，我们得到误差的表达式：\n$$ \\text{Error}_D(E_{\\text{cut}}, N_k) = (\\cancel{E_{\\text{ads}}^{\\text{ref}}} + \\delta_D + A_D E_{\\text{cut}}^{-p_D} + B_D N_k^{-q_D}) - \\cancel{E_{\\text{ads}}^{\\text{ref}}} $$\n$$ \\text{Error}_D(E_{\\text{cut}}, N_k) = \\delta_D + A_D E_{\\text{cut}}^{-p_D} + B_D N_k^{-q_D} $$\n所需的量是误差大小，即此表达式的绝对值：\n$$ \\text{Error Magnitude}_D = |\\text{Error}_D(E_{\\text{cut}}, N_k)| = |\\delta_D + A_D E_{\\text{cut}}^{-p_D} + B_D N_k^{-q_D}| $$\n使用问题提供的两个数据集的指数 $p_D = 1$ 和 $q_D = 1$，最终的工作方程简化为：\n$$ \\text{Error Magnitude}_D = \\left| \\delta_D + \\frac{A_D}{E_{\\text{cut}}} + \\frac{B_D}{N_k} \\right| $$\n右侧的所有参数都已为两个数据集 $D = \\text{no-semi}$ 和 $D = \\text{semi}$ 给出。\n\n解决该问题的算法如下：\n对于每个由一组 $(E_{\\text{cut}}, N_k, \\text{tolerance})$ 指定的测试用例：\n1.  使用推导出的公式及其特定参数（$\\delta_{\\text{no-semi}} = +0.030$, $A_{\\text{no-semi}} = 3.0$, $B_{\\text{no-semi}} = 0.22$），计算“no-semi”数据集的误差大小 $e^{\\text{no-semi}}$。\n2.  使用其参数（$\\delta_{\\text{semi}} = +0.010$, $A_{\\text{semi}} = 8.0$, $B_{\\text{semi}} = 0.20$），计算“semi”数据集的误差大小 $e^{\\text{semi}}$。\n3.  计算改进比率 $r = e^{\\text{no-semi}} / e^{\\text{semi}}$。由于所有参数 $\\delta, A, B$ 均为正，误差也将为正，因此无需担心除以零的情况。\n4.  通过检查 $e^{\\text{no-semi}} \\le \\text{tolerance}$ 来确定“no-semi”数据集的收敛状态。\n5.  通过检查 $e^{\\text{semi}} \\le \\text{tolerance}$ 来确定“semi”数据集的收敛状态。\n然后将这五个量为所有测试用例汇编起来，以产生最终结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Formalizes, implements, and evaluates a convergence model for CO adsorption energy.\n    \"\"\"\n\n    # Define the constants for the two PAW datasets.\n    params = {\n        'no-semi': {\n            'delta': 0.030,  # Systematic offset in eV\n            'A': 3.0,        # Plane-wave cutoff error amplitude in eV\n            'p': 1.0,        # Plane-wave cutoff error exponent\n            'B': 0.22,       # k-point sampling error amplitude in eV\n            'q': 1.0,        # k-point sampling error exponent\n        },\n        'semi': {\n            'delta': 0.010,  # Systematic offset in eV\n            'A': 8.0,        # Plane-wave cutoff error amplitude in eV\n            'p': 1.0,        # Plane-wave cutoff error exponent\n            'B': 0.20,       # k-point sampling error amplitude in eV\n            'q': 1.0,        # k-point sampling error exponent\n        }\n    }\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (E_cut in eV, N_k, tolerance in eV)\n        (300, 12, 0.050),\n        (450, 24, 0.020),\n        (550, 36, 0.010),\n        (250, 8, 0.070),\n    ]\n\n    all_results = []\n\n    def calculate_error_magnitude(E_cut, N_k, dataset_params):\n        \"\"\"\n        Calculates the error magnitude based on the derived convergence model.\n        Error = |delta + A * E_cut**(-p) + B * N_k**(-q)|\n        \"\"\"\n        delta = dataset_params['delta']\n        A = dataset_params['A']\n        p = dataset_params['p']\n        B = dataset_params['B']\n        q = dataset_params['q']\n\n        error_val = delta + A * (E_cut ** -p) + B * (N_k ** -q)\n        return abs(error_val)\n\n    for E_cut, N_k, tolerance in test_cases:\n        # Calculate error for the dataset without semicore states\n        error_no_semi = calculate_error_magnitude(E_cut, N_k, params['no-semi'])\n\n        # Calculate error for the dataset with semicore states\n        error_semi = calculate_error_magnitude(E_cut, N_k, params['semi'])\n\n        # Calculate the improvement ratio\n        # Since all parameters are positive, errors will be non-zero.\n        improvement_ratio = error_no_semi / error_semi\n\n        # Check if each dataset meets the convergence tolerance\n        converged_no_semi = error_no_semi = tolerance\n        converged_semi = error_semi = tolerance\n\n        # Append the five results for the current test case\n        all_results.extend([\n            error_no_semi,\n            error_semi,\n            improvement_ratio,\n            converged_no_semi,\n            converged_semi\n        ])\n\n    # Format the results for the final print statement\n    formatted_results = []\n    for item in all_results:\n        if isinstance(item, float):\n            # Round floats to 6 decimal places and format to show trailing zeros\n            formatted_results.append(f\"{round(item, 6):.6f}\")\n        elif isinstance(item, bool):\n            # Convert booleans to their string representation ('True' or 'False')\n            formatted_results.append(str(item))\n        else:\n            # Fallback for any other types\n            formatted_results.append(str(item))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}