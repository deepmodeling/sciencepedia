{
    "hands_on_practices": [
        {
            "introduction": "在我们计算扩散速率之前，必须首先确定吸附原子最可能遵循的路径，即最小能量路径（Minimum Energy Path, MEP）。该路径上的最高点是鞍点，其相对于能量最低点的能量定义了活化能（$E_a$）。本练习将让你亲手实现“微动弹性带”（Nudged Elastic Band, NEB）方法，这是一种寻找 MEP 和鞍点的强大算法，为你提供计算催化中的一个基本工具。",
            "id": "3900845",
            "problem": "要求您遵循弹性链方法（Nudged Elastic Band, NEB）的概念框架，对催化剂表面上两个吸附位点之间的最低能量路径进行形式化和离散近似实现。这两个位点是 (111) 表面上的面心立方（FCC）位点和六方密堆积（HCP）位点。最终程序必须计算扩散势垒，其定义为最低能量路径上的鞍点能量，以电子伏特为单位表示。此构建必须基于第一性原理和核心定义。\n\n从以下基本原理和事实开始：\n- 最低能量路径是连接两个局域极小值的构型空间路径，在该路径上，势能在垂直于路径的方向上被最小化。在鞍点处，势能的梯度为零，且其Hessian矩阵有且仅有一个负特征值。\n- 晶体表面上吸附物的势能面是位置的光滑函数，势能的梯度通过最速下降法驱动构型弛豫。\n- 一条离散路径可由一组映像点表示，这些映像点由谐振子弹簧连接。弹簧强制实现近似均匀的参数化，但不会对垂直于路径方向的路径形状产生影响。\n\n使用以下光滑且物理上合理的二维势能面来表示单原子吸附物在FCC和HCP位点之间沿晶体学方向扩散，路径正交方向上具有约束曲率：\n$$\nV(x,y) \\;=\\; \\frac{16\\,E_b}{a^4}\\left[\\left(x - \\frac{a}{2}\\right)^2 - \\left(\\frac{a}{2}\\right)^2\\right]^2 \\;+\\; \\gamma\\,y^2,\n$$\n其中，$x$ 和 $y$ 是以埃为单位的笛卡尔坐标，$a$ 是以埃为单位的晶格常数，$E_b$ 是以电子伏特为单位的可调势垒能量，$\\gamma$ 是以电子伏特每平方埃为单位的横向曲率。前置因子的选择保证了在 $y=0$ 的直线上，$x=a/2$ 处的势垒高度为 $E_b$，并在 $x=0$ 和 $x=a$ 处有极小值点。\n\n将路径的端点定义为 FCC 位点 $(x,y)=(0,0)$ 和 HCP 位点 $(x,y)=(a,0)$，其中 $a>0$。路径被离散为包含固定端点在内的 $N$ 个映像点。这些映像点由弹性常数为 $k$（单位为电子伏特每平方埃）的谐振子弹簧连接。您必须从第一性原理出发，构建一个数学上严谨的离散NEB公式：\n- 在每个内部映像点索引 $i$ 处，根据相邻映像点定义一个离散切线 $\\,\\mathbf{t}_i\\,$，使其能够一致地近似路径方向。\n- 将映像点 $i$ 处的物理力 $-\\nabla V(\\mathbf{R}_i)$ 分解为平行于和垂直于局部切线的分量，并只保留物理力的垂直分量。\n- 沿切线方向添加弹簧力分量以维持近似均匀的参数化，不添加任何会影响路径的垂直弹簧分量。\n- 可选地，为改进鞍点识别，实现一个爬山变体，其中能量最高的内部映像点沿切线方向攀升，并沿正交方向下降，以收敛到鞍点。\n\n您的程序必须：\n- 通过在端点之间进行线性插值来初始化映像点。\n- 使用推导出的NEB力迭代地弛豫内部映像点，直到达到固定的迭代次数或满足最大力范数的合理收敛阈值。在整个过程中，端点必须保持固定。\n- 将收敛后的离散路径（不包括端点）上的最大势能确定为势垒能量；如果激活了爬山变体，则使用爬山映像点的能量作为势垒的估计值。\n- 报告下面指定的测试套件的势垒能量。\n\n单位和输出规范：\n- 位置必须以埃为单位处理。能量必须以电子伏特为单位。最终的势垒能量必须以电子伏特报告。\n- 最终的程序输出必须是单行文本，包含一个由方括号括起来的逗号分隔列表，其中每个条目是一个测试用例的势垒能量，以电子伏特为单位，表示为四舍五入到六位小数的浮点数。\n\n测试套件和参数范围：\n- 对每个案例使用上面定义的势 $V(x,y)$ 及指定的参数。映像点必须包括端点 $(0,0)$ 和 $(a,0)$。\n- 对于每个案例，参数元组为 $(a, E_b, \\gamma, N, k, \\text{climb})$，其中 $a$ 的单位是埃，$E_b$ 的单位是电子伏特，$\\gamma$ 的单位是电子伏特每平方埃，$N$ 是大于或等于3的整数，$k$ 的单位是电子伏特每平方埃，而 $\\text{climb}$ 是一个布尔值，指示是否启用爬山变体。\n\n提供并使用以下测试套件：\n- 案例1：($a=2.5$, $E_b=0.12$, $\\gamma=1.0$, $N=9$, $k=5.0$, `climb=True`)。\n- 案例2：($a=2.5$, $E_b=0.12$, $\\gamma=0.5$, $N=7$, $k=0.1$, `climb=True`)。\n- 案例3：($a=2.5$, $E_b=0.05$, $\\gamma=1.0$, $N=5$, $k=3.0$, `climb=False`)。\n- 案例4：($a=2.5$, $E_b=0.20$, $\\gamma=1.5$, $N=11$, $k=10.0$, `climb=True`)。\n- 案例5：($a=2.5$, $E_b=0.12$, $\\gamma=2.0$, $N=3$, $k=1.0$, `climb=True`)。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，以电子伏特为单位，四舍五入到六位小数，格式如下：\n\"[result1,result2,result3,result4,result5]\".",
            "solution": "问题陈述已经过验证，被认为是合理的。它提出了一个计算物理学中适定、有科学依据的问题，没有矛盾或含糊之处。任务是为一个给定的二维势能面（PES）实现弹性链方法（Nudged Elastic Band, NEB），这是一种用于寻找化学反应和扩散过程中最低能量路径（MEPs）的基石算法。\n\n我们首先对反应路径的离散表示进行形式化。该路径是一系列构型，或称“映像点”，用其坐标 $\\mathbf{R}_i = (x_i, y_i)$ 表示，其中 $i=0, 1, \\dots, N-1$。映像点总数为 $N$。端点 $\\mathbf{R}_0$ 和 $\\mathbf{R}_{N-1}$ 固定在过程的初始态和最终态——在此案例中，分别是 FCC 位点 $(0,0)$ 和 HCP 位点 $(a,0)$。$N-2$ 个中间映像点是可移动的。\n\n势能面 $V(\\mathbf{R})$ 由下式给出：\n$$\nV(x,y) = \\frac{16\\,E_b}{a^4}\\left[\\left(x - \\frac{a}{2}\\right)^2 - \\left(\\frac{a}{2}\\right)^2\\right]^2 + \\gamma\\,y^2\n$$\n由于该势能，位于位置 $\\mathbf{R}_i$ 的映像点所受的力是势能的负梯度，即 $\\mathbf{F}_{phys,i} = -\\nabla V(\\mathbf{R}_i)$。梯度的分量为：\n$$\n\\frac{\\partial V}{\\partial x} = \\frac{32\\,E_b}{a^4} (x^2 - ax)(2x - a) = \\frac{32\\,E_b}{a^4} x(x-a)(2x-a)\n$$\n$$\n\\frac{\\partial V}{\\partial y} = 2\\gamma y\n$$\nNEB方法的核心思想是在每个映像点上构建一个总力，该力驱动映像点链向最低能量路径（MEP）移动。这个力是两个分量的和：一个修正后的物理力和一个弹簧力。一个朴素的方法是简单地在物理力 $\\mathbf{F}_{phys,i}$ 和谐振子弹簧力 $\\mathbf{F}_{spring,i} = k(\\mathbf{R}_{i+1} - 2\\mathbf{R}_i + \\mathbf{R}_{i-1})$ 的作用下弛豫映像点，但这会导致路径滑入能量极小值点并表现出“切角”行为。\n\nNEB中的“微调”（nudging）修正了这个问题。我们希望物理力只在垂直于路径的方向上起作用，从而在不影响沿路径位置的情况下最小化能量。相反，我们希望弹簧力只在平行于路径的方向上起作用，以确保映像点间距均匀，而不会影响路径的形状。这需要在每个映像点 $i$ 处定义一个局部切线向量 $\\mathbf{t}_i$。对于内部映像点 $i$，一个稳健的切线选择是连接其相邻点的归一化向量：\n$$\n\\mathbf{t}_i = \\frac{\\mathbf{R}_{i+1} - \\mathbf{R}_{i-1}}{\\|\\mathbf{R}_{i+1} - \\mathbf{R}_{i-1}\\|}\n$$\n物理力垂直于路径的分量是通过投影掉平行分量得到的：\n$$\n\\mathbf{F}_{phys,i}^{\\perp} = \\mathbf{F}_{phys,i} - (\\mathbf{F}_{phys,i} \\cdot \\mathbf{t}_i)\\mathbf{t}_i\n$$\n问题为平行弹簧力分量指定了一种特定形式，旨在使相邻映像点之间的距离相等：\n$$\n\\mathbf{F}_{spring,i}^{\\parallel} = k(\\|\\mathbf{R}_{i+1} - \\mathbf{R}_i\\| - \\|\\mathbf{R}_i - \\mathbf{R}_{i-1}\\|) \\mathbf{t}_i\n$$\n在一个标准（非爬山）内部映像点 $i$ 上的总NEB力是这两个投影力的和：\n$$\n\\mathbf{F}_{NEB, i} = \\mathbf{F}_{phys,i}^{\\perp} + \\mathbf{F}_{spring,i}^{\\parallel}\n$$\n为了精确定位鞍点，采用了爬山映像点NEB（Climbing Image NEB, CI-NEB）变体。势能最高的内部映像点（设其索引为 $i_{climb}$）被指定为“爬山”映像点。该映像点不再受任何弹簧力的作用。此外，其物理力平行于路径的分量被反转。这会驱动该映像点沿MEP“上山”朝向鞍点移动，同时继续在垂直方向上最小化其能量。爬山映像点上的力为：\n$$\n\\mathbf{F}_{climb, i_{climb}} = \\mathbf{F}_{phys, i_{climb}} - 2(\\mathbf{F}_{phys, i_{climb}} \\cdot \\mathbf{t}_{i_{climb}})\\mathbf{t}_{i_{climb}} = \\mathbf{F}_{phys, i_{climb}}^{\\perp} - \\mathbf{F}_{phys, i_{climb}}^{\\parallel}\n$$\n算法流程如下：\n1. 通过在端点 $\\mathbf{R}_0=(0,0)$ 和 $\\mathbf{R}_{N-1}=(a,0)$ 之间进行线性插值来创建 $N$ 个映像点，从而初始化路径。\n2. 迭代更新 $N-2$ 个内部映像点的位置。在每次迭代中：\n    a. 计算所有映像点的势能 $V(\\mathbf{R}_i)$。\n    b. 如果爬山变体被激活，则识别具有最大能量的内部映像点 $i_{climb}$。\n    c. 对于每个内部映像点 $i \\in [1, N-2]$，计算切线 $\\mathbf{t}_i$ 和总力 $\\mathbf{F}_i$（$\\mathbf{F}_{NEB, i}$ 或 $\\mathbf{F}_{climb, i}$）。\n    d. 使用一个简单的最速下降优化步骤更新映像点位置：$\\mathbf{R}_i \\gets \\mathbf{R}_i + \\alpha \\mathbf{F}_i$，其中 $\\alpha$ 是一个小的、恒定的学习率。\n3. 当任何内部映像点上的最大力的量值低于指定的收敛阈值，或达到最大迭代次数时，循环终止。\n4. 收敛后，确定扩散势垒。如果使用了 CI-NEB，则扩散势垒是爬山映像点的势能 $V(\\mathbf{R}_{i_{climb}})$。否则，它是所有弛豫后的内部映像点中的最大势能。\n\n此过程为确定最低能量路径及其相关的活化势垒提供了一种稳健且物理上合理的方法，该方法在以下程序中实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the NEB calculations for the specified test suite\n    and print the results in the required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (a, E_b, gamma, N, k, climb)\n        (2.5, 0.12, 1.0, 9, 5.0, True),\n        (2.5, 0.12, 0.5, 7, 0.1, True),\n        (2.5, 0.05, 1.0, 5, 3.0, False),\n        (2.5, 0.20, 1.5, 11, 10.0, True),\n        (2.5, 0.12, 2.0, 3, 1.0, True),\n    ]\n\n    results = []\n    \n    # Optimization parameters\n    learning_rate = 0.01\n    num_iterations = 20000\n    force_threshold = 1e-6 # eV/Angstrom\n\n    for case in test_cases:\n        a, E_b, gamma, N, k, climb = case\n        barrier = run_neb(a, E_b, gamma, N, k, climb,\n                          learning_rate, num_iterations, force_threshold)\n        results.append(f\"{barrier:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef potential(coords, a, E_b, gamma):\n    \"\"\"\n    Calculates the potential energy V(x,y) for one or more coordinates.\n    coords is a NumPy array of shape (..., 2).\n    \"\"\"\n    x = coords[..., 0]\n    y = coords[..., 1]\n    term_x = (16.0 * E_b / a**4) * ((x - a / 2.0)**2 - (a / 2.0)**2)**2\n    term_y = gamma * y**2\n    return term_x + term_y\n\ndef gradient(coords, a, E_b, gamma):\n    \"\"\"\n    Calculates the gradient of the potential energy nabla(V) at given coordinates.\n    coords is a NumPy array of shape (..., 2).\n    \"\"\"\n    x = coords[..., 0]\n    y = coords[..., 1]\n    \n    # dV/dx = (32*E_b/a**4) * x*(x-a)*(2*x-a)\n    dv_dx = (32.0 * E_b / a**4) * x * (x - a) * (2.0 * x - a)\n    dv_dy = 2.0 * gamma * y\n    \n    if coords.ndim > 1:\n        return np.stack((dv_dx, dv_dy), axis=-1)\n    else:\n        return np.array([dv_dx, dv_dy])\n\ndef compute_neb_forces(images, a, E_b, gamma, k, climb):\n    \"\"\"\n    Computes the NEB forces for all interior images.\n    \"\"\"\n    N = images.shape[0]\n    forces = np.zeros_like(images)\n    \n    # Calculate energies for all images to identify climbing image if needed\n    energies = potential(images, a, E_b, gamma)\n    \n    i_climb = -1\n    if climb and N > 2:\n        # The climbing image is the one with the highest energy (among interior images)\n        i_climb = np.argmax(energies[1:-1]) + 1\n        \n    for i in range(1, N - 1):\n        # Local tangent at image i using centered difference\n        tangent = images[i+1] - images[i-1]\n        tangent_norm = np.linalg.norm(tangent)\n        if tangent_norm > 1e-9:\n            tangent /= tangent_norm\n        else:\n            # Fallback for colocated neighbors, though unlikely in a real run.\n            tangent = np.array([1.0, 0.0])\n\n        # True force from the potential\n        F_phys = -gradient(images[i], a, E_b, gamma)\n\n        if i == i_climb:\n            # Climbing image force: invert parallel component of true force\n            F_phys_parallel_mag = np.dot(F_phys, tangent)\n            F_total = F_phys - 2.0 * F_phys_parallel_mag * tangent\n        else:\n            # Standard NEB image force\n            # Perpendicular component of the true force\n            F_phys_parallel_mag = np.dot(F_phys, tangent)\n            F_phys_perp = F_phys - F_phys_parallel_mag * tangent\n\n            # Spring force component along the tangent\n            len_next = np.linalg.norm(images[i+1] - images[i])\n            len_prev = np.linalg.norm(images[i] - images[i-1])\n            F_spring_parallel = k * (len_next - len_prev) * tangent\n            \n            F_total = F_phys_perp + F_spring_parallel\n            \n        forces[i] = F_total\n\n    return forces\n\ndef run_neb(a, E_b, gamma, N, k, climb, learning_rate, num_iterations, force_threshold):\n    \"\"\"\n    Performs the NEB calculation for a single test case.\n    \"\"\"\n    # 1. Initialize images by linear interpolation\n    images = np.zeros((N, 2))\n    images[:, 0] = np.linspace(0.0, a, N)\n\n    # 2. Optimization loop\n    for _ in range(num_iterations):\n        forces = compute_neb_forces(images, a, E_b, gamma, k, climb)\n        \n        # Check for convergence on the maximum force norm for any movable image\n        max_force_norm = 0.0\n        if N > 2:\n            max_force_norm = np.max(np.linalg.norm(forces[1:-1], axis=1))\n        \n        if max_force_norm < force_threshold:\n            break\n        \n        # 3. Update interior image positions using steepest descent\n        images[1:-1] += learning_rate * forces[1:-1]\n\n    # 4. Calculate final barrier energy\n    if N <= 2:\n        return 0.0 # No barrier if there are no interior images\n        \n    final_energies = potential(images[1:-1], a, E_b, gamma)\n    barrier_energy = np.max(final_energies)\n\n    return barrier_energy\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "仅仅知道活化能垒是不够的。为了得到完整的扩散速率，我们还需要指前因子，它取决于初始态和过渡态的振动频率。本练习将谐振过渡态理论（Transition State Theory, TST）应用于一个模型化的各向异性势能面。它将指导你计算势能面的形状如何不仅决定了能垒，还决定了尝试频率，从而导致方向依赖的扩散速率。",
            "id": "3900854",
            "problem": "一个质量为 $m$ 的孤立吸附原子在晶体表面扩散，其势能面 (PES) 是可分离和各向异性的，由 $V(x,y)=V_{x}\\cos\\!\\left(\\frac{2\\pi x}{a}\\right)+V_{y}\\cos\\!\\left(\\frac{2\\pi y}{b}\\right)$ 给出，其中 $V_{x}>0$ 且 $V_{y}>0$，$a$ 和 $b$ 分别是沿 $x$ 和 $y$ 方向的晶格周期。假设覆盖度较低，吸附物-吸附物之间的相互作用可忽略不计，且扩散通过沿坐标轴在相邻极小值点之间的热激活跳跃进行。在温度为 $T$ 的经典极限下进行分析，并使用谐振近似下的过渡态理论 (TST)：即在极小值点和一阶鞍点附近的微小振荡是谐振的，并且反应坐标是可分离的。通过长时间均方位移定义扩散张量分量 $D_{xx}$ 和 $D_{yy}$，并将 $k_{x}$ ($k_{y}$) 定义为沿 $+x$ ($+y$) 方向到特定最近邻的微观跳跃速率。从 TST 原理出发，即速率等于势阱的平衡布居乘以通过无重返分割面的正向反应通量，并使用极小值点和鞍点处振动配分函数的谐振近似，推导 $D_{xx}/D_{yy}$ 之比关于 $V_{x}$、$V_{y}$、$a$、$b$、$m$、$T$ 和玻尔兹曼常数 $k_{B}$ 的解析表达式。将最终答案表示为闭合形式的解析表达式。无需进行数值计算或四舍五入。",
            "solution": "该问题陈述已经过验证，被认为是自洽的、有科学依据的且提法恰当。势能面和假定的扩散机制是一致的，这使得严格推导成为可能。\n\n目标是推导扩散张量对角分量之比 $D_{xx}/D_{yy}$ 的表达式。对于通过离散跳跃在晶格上的扩散，扩散系数与微观跳跃速率和跳跃长度有关。对于二维矩形晶格，这些关系由以下公式给出：\n$$D_{xx} = k_x l_x^2$$\n$$D_{yy} = k_y l_y^2$$\n这里，$k_x$ 和 $k_y$ 分别是向正 $x$ 和 $y$ 方向上特定相邻位置跳跃的速率。跳跃长度 $l_x$ 和 $l_y$ 是沿各自轴线上相邻极小值点之间的距离。\n\n从给定的势能面 (PES) $V(x,y)=V_{x}\\cos\\!\\left(\\frac{2\\pi x}{a}\\right)+V_{y}\\cos\\!\\left(\\frac{2\\pi y}{b}\\right)$（其中 $V_{x}>0$ 且 $V_{y}>0$），我们可以确定驻点的位置。势能的极小值点出现在两个余弦项都等于 $-1$ 的地方。对于任意整数 $n, m$，这发生在坐标 $(x,y) = ((n+\\frac{1}{2})a, (m+\\frac{1}{2})b)$ 处。沿 $x$ 方向相邻极小值点之间的距离（例如，从 $(-\\frac{a}{2}, \\frac{b}{2})$ 到 $(\\frac{a}{2}, \\frac{b}{2})$）是 $l_x=a$。类似地，沿 $y$ 方向相邻极小值点之间的距离是 $l_y=b$。\n因此，扩散系数之比为：\n$$\\frac{D_{xx}}{D_{yy}} = \\frac{k_x a^2}{k_y b^2}$$\n问题的核心是使用谐振过渡态理论 (TST) 来确定速率 $k_x$ 和 $k_y$。TST 速率表达式由以下公式给出：\n$$k = \\frac{\\prod_{i=1}^{N} \\nu_i^{MIN}}{\\prod_{i=1}^{N-1} \\nu_i^{SP}} \\exp\\left(-\\frac{E_a}{k_B T}\\right)$$\n其中 $\\nu_i^{MIN}$ 是能量极小值点（反应物态）处的 $N$ 个实振动频率，$\\nu_i^{SP}$ 是一阶鞍点（过渡态）处的 $N-1$ 个实振动频率，$E_a$ 是活化能 ($V_{SP} - V_{MIN}$)，$k_B$ 是玻尔兹曼常数，$T$ 是温度。对于这个二维问题，$N=2$。\n\n首先，我们分析 PES 驻点的性质。梯度为 $\\nabla V = \\left( -\\frac{2\\pi V_x}{a}\\sin(\\frac{2\\pi x}{a}), -\\frac{2\\pi V_y}{b}\\sin(\\frac{2\\pi y}{b}) \\right)$。由于势能是可分离的，Hessian 矩阵是对角的：\n$$H(x,y) = \\begin{pmatrix} \\frac{\\partial^2 V}{\\partial x^2} & 0 \\\\ 0 & \\frac{\\partial^2 V}{\\partial y^2} \\end{pmatrix} = \\begin{pmatrix} -V_x \\left(\\frac{2\\pi}{a}\\right)^2 \\cos(\\frac{2\\pi x}{a}) & 0 \\\\ 0 & -V_y \\left(\\frac{2\\pi}{b}\\right)^2 \\cos(\\frac{2\\pi y}{b}) \\end{pmatrix}$$\n\n**1. $x$ 方向跳跃分析 ($k_x$)**\n\n$x$ 方向的跳跃连接两个相邻的极小值点，例如，从 $(-\\frac{a}{2}, \\frac{b}{2})$ 到 $(\\frac{a}{2}, \\frac{b}{2})$。\n\n**极小值点（初始态）：**\n我们考虑位于 $(x_{MIN}, y_{MIN}) = (\\pm\\frac{a}{2}, \\pm\\frac{b}{2})$ 的任一极小值点。\n势能为 $V_{MIN} = V_x \\cos(\\pm\\pi) + V_y \\cos(\\pm\\pi) = -V_x - V_y$。\n在极小值点处 Hessian 矩阵的对角元素是等效劲度系数：\n$k_{x,MIN} = -V_x (\\frac{2\\pi}{a})^2 \\cos(\\pm\\pi) = V_x (\\frac{2\\pi}{a})^2$。\n$k_{y,MIN} = -V_y (\\frac{2\\pi}{b})^2 \\cos(\\pm\\pi) = V_y (\\frac{2\\pi}{b})^2$。\n在极小值点处的振动频率为 $\\nu = \\frac{1}{2\\pi}\\sqrt{k/m}$：\n$\\nu_x^{MIN} = \\frac{1}{2\\pi}\\sqrt{\\frac{V_x (2\\pi/a)^2}{m}} = \\frac{1}{a}\\sqrt{\\frac{V_x}{m}}$\n$\\nu_y^{MIN} = \\frac{1}{2\\pi}\\sqrt{\\frac{V_y (2\\pi/b)^2}{m}} = \\frac{1}{b}\\sqrt{\\frac{V_y}{m}}$\n\n**鞍点（$x$ 方向跳跃的过渡态）：**\n在 $(-\\frac{a}{2}, \\frac{b}{2})$ 和 $(\\frac{a}{2}, \\frac{b}{2})$ 之间跳跃的过渡态位于中点 $(x_{SPx}, y_{SPx}) = (0, \\frac{b}{2})$。\n势能为 $V_{SP,x} = V_x \\cos(0) + V_y \\cos(\\pi) = V_x - V_y$。\n$x$ 方向跳跃的活化能为 $E_{a,x} = V_{SP,x} - V_{MIN} = (V_x - V_y) - (-V_x - V_y) = 2V_x$。\n在此鞍点处，Hessian 分量为：\n$H_{xx} = -V_x (\\frac{2\\pi}{a})^2 \\cos(0) = -V_x (\\frac{2\\pi}{a})^2 < 0$（不稳定模式，反应坐标）。\n$H_{yy} = -V_y (\\frac{2\\pi}{b})^2 \\cos(\\pi) = V_y (\\frac{2\\pi}{b})^2 > 0$（稳定模式）。\n在此鞍点处，单一束缚振动的频率是沿 $y$ 方向的：\n$\\nu_y^{SPx} = \\frac{1}{2\\pi}\\sqrt{\\frac{V_y (2\\pi/b)^2}{m}} = \\frac{1}{b}\\sqrt{\\frac{V_y}{m}}$。注意 $\\nu_y^{SPx} = \\nu_y^{MIN}$。\n\n**跳跃速率 $k_x$：**\n使用 TST 公式：\n$$k_x = \\frac{\\nu_x^{MIN} \\nu_y^{MIN}}{\\nu_y^{SPx}} \\exp\\left(-\\frac{E_{a,x}}{k_B T}\\right) = \\nu_x^{MIN} \\exp\\left(-\\frac{2V_x}{k_B T}\\right)$$\n$$k_x = \\frac{1}{a}\\sqrt{\\frac{V_x}{m}} \\exp\\left(-\\frac{2V_x}{k_B T}\\right)$$\n\n**2. $y$ 方向跳跃分析 ($k_y$)**\n\n$y$ 方向的跳跃连接了，例如，从极小值点 $(\\frac{a}{2}, -\\frac{b}{2})$ 到 $(\\frac{a}{2}, \\frac{b}{2})$。\n\n**极小值点（初始态）：**\n极小值点的性质与之前相同。$V_{MIN} = -V_x - V_y$。\n$\\nu_x^{MIN} = \\frac{1}{a}\\sqrt{\\frac{V_x}{m}}$ 且 $\\nu_y^{MIN} = \\frac{1}{b}\\sqrt{\\frac{V_y}{m}}$。\n\n**鞍点（$y$ 方向跳跃的过渡态）：**\n过渡态位于 $(x_{SPy}, y_{SPy}) = (\\frac{a}{2}, 0)$。\n势能为 $V_{SP,y} = V_x \\cos(\\pi) + V_y \\cos(0) = -V_x + V_y$。\n活化能为 $E_{a,y} = V_{SP,y} - V_{MIN} = (-V_x + V_y) - (-V_x - V_y) = 2V_y$。\n在此鞍点处，Hessian 分量为：\n$H_{xx} = -V_x (\\frac{2\\pi}{a})^2 \\cos(\\pi) = V_x (\\frac{2\\pi}{a})^2 > 0$（稳定模式）。\n$H_{yy} = -V_y (\\frac{2\\pi}{b})^2 \\cos(0) = -V_y (\\frac{2\\pi}{b})^2 < 0$（不稳定模式）。\n单一束缚振动的频率是沿 $x$ 方向的：\n$\\nu_x^{SPy} = \\frac{1}{2\\pi}\\sqrt{\\frac{V_x (2\\pi/a)^2}{m}} = \\frac{1}{a}\\sqrt{\\frac{V_x}{m}}$。注意 $\\nu_x^{SPy} = \\nu_x^{MIN}$。\n\n**跳跃速率 $k_y$：**\n$$k_y = \\frac{\\nu_x^{MIN} \\nu_y^{MIN}}{\\nu_x^{SPy}} \\exp\\left(-\\frac{E_{a,y}}{k_B T}\\right) = \\nu_y^{MIN} \\exp\\left(-\\frac{2V_y}{k_B T}\\right)$$\n$$k_y = \\frac{1}{b}\\sqrt{\\frac{V_y}{m}} \\exp\\left(-\\frac{2V_y}{k_B T}\\right)$$\n\n**3. 扩散系数之比**\n\n现在我们可以计算比率 $D_{xx}/D_{yy}$。\n$$D_{xx} = k_x a^2 = \\left(\\frac{1}{a}\\sqrt{\\frac{V_x}{m}} \\exp\\left(-\\frac{2V_x}{k_B T}\\right)\\right) a^2 = a\\sqrt{\\frac{V_x}{m}} \\exp\\left(-\\frac{2V_x}{k_B T}\\right)$$\n$$D_{yy} = k_y b^2 = \\left(\\frac{1}{b}\\sqrt{\\frac{V_y}{m}} \\exp\\left(-\\frac{2V_y}{k_B T}\\right)\\right) b^2 = b\\sqrt{\\frac{V_y}{m}} \\exp\\left(-\\frac{2V_y}{k_B T}\\right)$$\n该比率为：\n$$\\frac{D_{xx}}{D_{yy}} = \\frac{a\\sqrt{\\frac{V_x}{m}} \\exp\\left(-\\frac{2V_x}{k_B T}\\right)}{b\\sqrt{\\frac{V_y}{m}} \\exp\\left(-\\frac{2V_y}{k_B T}\\right)}$$\n化简表达式：\n$$\\frac{D_{xx}}{D_{yy}} = \\frac{a}{b} \\sqrt{\\frac{V_x}{V_y}} \\frac{\\exp\\left(-\\frac{2V_x}{k_B T}\\right)}{\\exp\\left(-\\frac{2V_y}{k_B T}\\right)} = \\frac{a}{b} \\sqrt{\\frac{V_x}{V_y}} \\exp\\left(-\\frac{2V_x}{k_B T} + \\frac{2V_y}{k_B T}\\right)$$\n$$\\frac{D_{xx}}{D_{yy}} = \\frac{a}{b} \\sqrt{\\frac{V_x}{V_y}} \\exp\\left(\\frac{2(V_y - V_x)}{k_B T}\\right)$$\n这就是扩散系数之比的最终解析表达式。",
            "answer": "$$\\boxed{\\frac{a}{b} \\sqrt{\\frac{V_x}{V_y}} \\exp\\left(\\frac{2(V_y - V_x)}{k_B T}\\right)}$$"
        },
        {
            "introduction": "理论建模的最终目标是与实验观察建立联系。本练习通过模拟扩散系数数据的分析过程来弥合这一差距。你将使用阿伦尼乌斯方程从合成数据中提取动力学参数（$E_a$ 和 $\\nu$），并批判性地检验表面各向异性和吸附物覆盖度等真实世界的复杂性如何影响结果及其解释。",
            "id": "3900868",
            "problem": "您将编写一个完整、可运行的程序，该程序针对催化剂表面扩散系数的几个合成数据集，从基本物理关系出发，对扩散系数的自然对数与倒数温度进行线性回归，以估计活化能和尝试频率。程序必须严格按照代码实现以下物理和算法步骤，仅使用提供的数值常数和下面指定的测试套件。\n\n基本原理：\n- 对于热激活的表面跳跃，假设扩散系数 $D$ 对温度 $T$ 遵循阿伦尼乌斯依赖关系，其活化能为 $E_{a}$，指前因子 $D_{0}$ 源于随机行走理论。使用二维（2D）各向同性随机行走关系，将指前因子与尝试频率 $\\nu$ 和一个几何因子联系起来。\n- 二维几何因子取为 $g = 1/4$。跳跃长度 $a$ 是表面上平均最近邻的跳跃距离。\n- 以电子伏特每开尔文为单位的玻尔兹曼常数为 $k_{B} = 8.617333262145 \\times 10^{-5}$ $\\mathrm{eV/K}$。\n\n算法任务：\n- 对于每个测试用例，使用所述的物理生成模型和参数构建合成扩散系数数据 $D(T)$。\n- 对扩散系数的自然对数 $\\ln D$ 与倒数温度 $1/T$ 进行普通最小二乘线性回归。\n- 从回归中估计活化能 $E_{a}$（单位为 $\\mathrm{eV}$）和尝试频率 $\\nu$（单位为 $\\mathrm{s^{-1}}$）。您必须以 $\\mathrm{eV}$ 表示 $E_{a}$，以 $\\mathrm{s^{-1}}$ 表示 $\\nu$，每个值都四舍五入到六位有效数字。\n\n测试套件和生成模型：\n- 情况 A（理想路径，各向同性，覆盖度无关）：使用 $E_{a} = 0.6$ $\\mathrm{eV}$，$\\nu = 1.0 \\times 10^{12}$ $\\mathrm{s^{-1}}$，跳跃长度 $a = 2.5 \\times 10^{-10}$ $\\mathrm{m}$，二维几何因子 $g = 1/4$，以及温度 $T = [400, 450, 500, 550, 600]$ $\\mathrm{K}$。使用这些参数，根据基本的阿伦尼乌斯关系和随机行走指前因子构建 $D(T)$。\n- 情况 B（各向异性扩散，相同的活化能垒，方向依赖的指前因子聚合为一个未标记的平均值）：使用 $E_{a} = 0.6$ $\\mathrm{eV}$，两个方向分量 $(a_{x}, \\nu_{x}) = (3.0 \\times 10^{-10}$ $\\mathrm{m}$, $1.2 \\times 10^{12}$ $\\mathrm{s^{-1}})$ 和 $(a_{y}, \\nu_{y}) = (2.2 \\times 10^{-10}$ $\\mathrm{m}$, $0.8 \\times 10^{12}$ $\\mathrm{s^{-1}})$，几何因子 $g = 1/4$，以及温度 $T = [400, 450, 500, 550, 600]$ $\\mathrm{K}$。将有效扩散系数构建为由相同基本原理生成的两个方向系数的算术平均值。在回归到 $\\nu$ 的转换中，使用拟合跳跃长度 $a_{\\mathrm{fit}} = 2.5 \\times 10^{-10}$ $\\mathrm{m}$ 和几何因子 $g = 1/4$。\n- 情况 C（覆盖度效应产生一个与温度相关的表观能垒）：使用零覆盖度下的 $E_{a,0} = 0.5$ $\\mathrm{eV}$，一个附加的覆盖度贡献 $\\gamma = 0.2$ $\\mathrm{eV}$ 乘以一个覆盖度函数 $\\theta(T)$，尝试频率 $\\nu = 8.0 \\times 10^{11}$ $\\mathrm{s^{-1}}$，跳跃长度 $a = 2.6 \\times 10^{-10}$ $\\mathrm{m}$，几何因子 $g = 1/4$，以及温度 $T = [400, 450, 500, 550, 600]$ $\\mathrm{K}$。将覆盖度函数定义为 $\\theta(T) = \\left(1 + \\exp\\left(\\frac{T - 500}{30}\\right)\\right)^{-1}$。使用能垒 $E_{a}(T) = E_{a,0} + \\gamma \\,\\theta(T)$ 从基本原理构建 $D(T)$。\n- 情况 D（数据量最少的边界情况）：使用 $E_{a} = 0.3$ $\\mathrm{eV}$，$\\nu = 1.0 \\times 10^{13}$ $\\mathrm{s^{-1}}$，跳跃长度 $a = 2.8 \\times 10^{-10}$ $\\mathrm{m}$，几何因子 $g = 1/4$，以及温度 $T = [500, 510]$ $\\mathrm{K}$。从相同的基本原理构建 $D(T)$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素是针对一个测试用例的 $[E_{a}, \\nu]$ 对，使用上述单位。例如，输出必须看起来像 $[[E_{a,1},\\nu_{1}],[E_{a,2},\\nu_{2}],\\ldots]$，不含空格。每个数值必须是四舍五入到六位有效数字的浮点数。\n\n科学真实性和解释要求：\n- 上述参数的选择在物理上对于表面扩散是合理的。在计算数值估计后，附带的解决方案将讨论由各向异性和覆盖度效应引起的不确定性，具体涉及它们对推断出的 $\\nu$ 和 $\\ln D$ 对 $1/T$ 的线性度的影响。",
            "solution": "该问题要求使用阿伦尼乌斯关系式分析合成的表面扩散数据，以提取基本的动力学参数。此分析基于过渡态理论和原子输运的随机行走模型。该过程涉及在不同的物理假设下，生成扩散系数 $D$ 作为温度 $T$ 的函数的合成数据，然后执行线性回归以估计活化能 $E_a$ 和尝试频率 $\\nu$。\n\n其理论基础是扩散系数的阿伦尼乌斯方程：\n$$D(T) = D_0 \\exp\\left(-\\frac{E_a}{k_B T}\\right)$$\n其中 $D_0$ 是指前因子，$E_a$ 是跳跃的活化能，$T$ 是绝对温度，$k_B$ 是玻尔兹曼常数，给定为 $k_B = 8.617333262145 \\times 10^{-5} \\, \\mathrm{eV/K}$。\n\n对于二维（$2$D）各向同性表面扩散，指前因子 $D_0$ 通过随机行走理论与微观参数相关联：\n$$D_0 = g \\nu a^2$$\n这里，$\\nu$ 是吸附原子的振动尝试频率，$a$ 是跳跃长度（平均最近邻距离），$g$ 是几何因子，指定为 $g = 1/4$。\n\n为了从一组 $(T, D)$ 数据点中提取 $E_a$ 和 $\\nu$，我们通过取自然对数将阿伦尼乌斯方程线性化：\n$$\\ln D(T) = \\ln(D_0) - \\frac{E_a}{k_B T}$$\n此方程是线性形式 $y = c + mx$，其中变量为 $y = \\ln D$ 和 $x = 1/T$。直线的斜率 $m$ 和 y 轴截距 $c$ 与物理参数相关：\n$$m = -\\frac{E_a}{k_B}$$\n$$c = \\ln(D_0) = \\ln(g \\nu a^2)$$\n通过对数据点 $(1/T, \\ln D)$ 进行普通最小二乘（OLS）线性回归，我们获得 $m$ 和 $c$ 的估计值。由此，物理参数估计如下：\n$$E_a^{\\text{est}} = -m \\cdot k_B$$\n$$\\nu^{\\text{est}} = \\frac{\\exp(c)}{g a^2}$$\n以下各节将此过程应用于每个测试用例。\n\n**情况 A：理想各向同性扩散**\n此情况代表了扩散过程严格遵循具有恒定参数的阿伦尼乌斯关系的理想场景。\n- **数据生成**：对于每个温度 $T \\in [400, 450, 500, 550, 600] \\, \\mathrm{K}$，使用生成参数计算扩散系数 $D(T)$：$E_a = 0.6 \\, \\mathrm{eV}$，$\\nu = 1.0 \\times 10^{12} \\, \\mathrm{s^{-1}}$，$a = 2.5 \\times 10^{-10} \\, \\mathrm{m}$，以及 $g = 1/4$。\n指前因子为 $D_0 = (1/4) (1.0 \\times 10^{12} \\, \\mathrm{s^{-1}}) (2.5 \\times 10^{-10} \\, \\mathrm{m})^2 = 1.5625 \\times 10^{-8} \\, \\mathrm{m^2/s}$。\n扩散系数为 $D(T) = D_0 \\exp\\left(-\\frac{0.6}{k_B T}\\right)$。\n- **回归和参数提取**：用于回归的坐标是 $x_i = 1/T_i$ 和 $y_i = \\ln D(T_i)$。由于数据完全符合模型，OLS 回归将产生完美拟合，提取的参数 $E_a^{\\text{est}}$ 和 $\\nu^{\\text{est}}$ 将与生成参数完全相同，仅受限于浮点精度。\n\n**情况 B：各向异性扩散**\n此情况模拟了一个表面，其扩散是各向异性的，沿两个正交方向具有不同的特征跳跃长度和尝试频率。所提供的数据代表了这些方向扩散系数的算术平均值。\n- **数据生成**：方向扩散系数 $D_x(T)$ 和 $D_y(T)$ 共享相同的活化能 $E_a = 0.6 \\, \\mathrm{eV}$。它们的计算方式如下：\n$D_x(T) = g \\nu_x a_x^2 \\exp(-E_a / (k_B T))$，其中 $(a_x, \\nu_x) = (3.0 \\times 10^{-10} \\, \\mathrm{m}, 1.2 \\times 10^{12} \\, \\mathrm{s^{-1}})$。\n$D_y(T) = g \\nu_y a_y^2 \\exp(-E_a / (k_B T))$，其中 $(a_y, \\nu_y) = (2.2 \\times 10^{-10} \\, \\mathrm{m}, 0.8 \\times 10^{12} \\, \\mathrm{s^{-1}})$。\n有效扩散系数为 $D(T) = \\frac{D_x(T) + D_y(T)}{2}$。\n- **回归和参数提取**：代入 $D_x$ 和 $D_y$ 的表达式：\n$$D(T) = \\frac{1}{2} \\left( g \\nu_x a_x^2 + g \\nu_y a_y^2 \\right) \\exp\\left(-\\frac{E_a}{k_B T}\\right)$$\n取自然对数：\n$$\\ln D(T) = \\ln\\left(\\frac{g}{2}(\\nu_x a_x^2 + \\nu_y a_y^2)\\right) - \\frac{E_a}{k_B T}$$\n与一种潜在的误解相反，因为两个各向异性分量共享相同的活化能 $E_a$，所以 $\\ln D$ 对 $1/T$ 的阿伦尼乌斯图是完全线性的。斜率直接得出真实的活化能 $E_a = 0.6 \\, \\mathrm{eV}$。只有当活化能 $E_{a,x}$ 和 $E_{a,y}$ 不同时，才会出现非线性。\n截距 $c$ 对应于一个有效指前因子：$c = \\ln\\left(D_{0, \\text{eff}}\\right) = \\ln\\left(\\frac{g}{2}(\\nu_x a_x^2 + \\nu_y a_y^2)\\right)$。然后使用提供的拟合参数 $a_{\\mathrm{fit}} = 2.5 \\times 10^{-10} \\, \\mathrm{m}$ 提取估计频率 $\\nu^{\\text{est}}$：\n$$\\nu^{\\text{est}} = \\frac{\\exp(c)}{g a_{\\mathrm{fit}}^2} = \\frac{\\frac{g}{2}(\\nu_x a_x^2 + \\nu_y a_y^2)}{g a_{\\mathrm{fit}}^2} = \\frac{\\nu_x a_x^2 + \\nu_y a_y^2}{2 a_{\\mathrm{fit}}^2}$$\n这导致估计的频率是方向参数的加权平均值，其依赖于假定的 $a_{\\mathrm{fit}}$。这突显了在没有进一步信息的情况下，从平均化的各向异性数据中解释指前因子的模糊性。\n\n**情况 C：覆盖度依赖的活化能**\n此情况通过模拟因覆盖度效应而随温度变化的活化能，引入了复杂性。\n- **数据生成**：活化能与温度相关：$E_a(T) = E_{a,0} + \\gamma \\theta(T)$，其中 $E_{a,0} = 0.5 \\, \\mathrm{eV}$，$\\gamma = 0.2 \\, \\mathrm{eV}$，以及 $\\theta(T) = \\left(1 + \\exp\\left(\\frac{T - 500}{30}\\right)\\right)^{-1}$。扩散系数为：\n$$D(T) = g \\nu a^2 \\exp\\left(-\\frac{E_a(T)}{k_B T}\\right)$$\n使用 $\\nu = 8.0 \\times 10^{11} \\, \\mathrm{s^{-1}}$ 和 $a = 2.6 \\times 10^{-10} \\, \\mathrm{m}$。\n- **回归和参数提取**：阿伦尼乌斯关系变为：\n$$\\ln D(T) = \\ln(g \\nu a^2) - \\frac{E_{a,0} + \\gamma \\theta(T)}{k_B T}$$\n由于 $E_a(T)$ 不是常数，$\\ln D$ 对 $1/T$ 的图将不是一条直线。OLS 回归会找到穿过这些曲线数据的最佳拟合直线，从而得到一个“表观”活化能 $E_a^{\\text{app}}$ 和一个“表观”尝试频率 $\\nu^{\\text{app}}$。这些表观值代表了在给定温度范围内的平均值，并且不对应于任何单一温度下基础物理过程的参数。回归线的斜率 $m_{\\text{fit}}$ 给出 $E_a^{\\text{app}} = -m_{\\text{fit}} \\cdot k_B$。线性拟合的质量（例如 $R^2$ 值）将低于理想情况，表明偏离了简单的阿伦尼乌斯行为。这种情况在实验催化中很常见，其中吸附物-吸附物相互作用使得扩散的活化能依赖于表面覆盖度，而表面覆盖度本身又可能与温度有关。\n\n**情况 D：数据量最少的边界情况**\n此情况用线性拟合所需的最少数据点来测试回归算法。\n- **数据生成**：使用理想模型为两个温度 $T \\in [500, 510] \\, \\mathrm{K}$ 生成数据，参数为 $E_a = 0.3 \\, \\mathrm{eV}$，$\\nu = 1.0 \\times 10^{13} \\, \\mathrm{s^{-1}}$，以及 $a = 2.8 \\times 10^{-10} \\, \\mathrm{m}$。\n- **回归和参数提取**：仅有两个数据点时，线性回归将找到一条精确穿过这两点的直线。拟合将是完美的（$R^2=1$），并且提取的参数 $E_a^{\\text{est}}$ 和 $\\nu^{\\text{est}}$ 将精确地恢复生成参数，仅受数值精度的限制。这可作为对核心计算逻辑的验证。\n\n程序为每种情况实现这些步骤，执行所需的计算，将结果四舍五入到六位有效数字，并以指定格式呈现。有效数字的四舍五入由一个专用函数处理，该函数根据数值的大小计算适当的小数位数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import stats # Not needed, numpy.polyfit is sufficient for OLS.\n\ndef solve():\n    \"\"\"\n    Main function to solve all test cases for surface diffusion analysis.\n    \"\"\"\n    \n    # Define the physical constant\n    KB_EV_K = 8.617333262145e-5  # Boltzmann constant in eV/K\n\n    def round_to_sf(x, sf):\n        \"\"\"\n        Rounds a number x to a specified number of significant figures, sf.\n        \"\"\"\n        if x == 0:\n            return 0.0\n        # Handle formatting for scientific notation output\n        format_spec = f\"%.{sf-1}e\"\n        return float(format_spec % x)\n\n    def perform_regression(T_data, D_data, a_fit, g_factor):\n        \"\"\"\n        Performs linear regression on ln(D) vs 1/T and extracts Ea and nu.\n        \"\"\"\n        # Prepare variables for linear regression: y = m*x + c\n        x = 1.0 / T_data\n        y = np.log(D_data)\n\n        # Perform ordinary least squares linear regression (degree 1 polynomial fit)\n        m, c = np.polyfit(x, y, 1)  # m = slope, c = intercept\n\n        # Estimate physical parameters from regression results\n        # m = -Ea / kB  =>  Ea = -m * kB\n        Ea_est = -m * KB_EV_K\n        \n        # c = ln(D0) = ln(g * nu * a^2)\n        # exp(c) = g * nu * a^2  => nu = exp(c) / (g * a^2)\n        D0_est = np.exp(c)\n        nu_est = D0_est / (g_factor * a_fit**2)\n\n        return round_to_sf(Ea_est, 6), round_to_sf(nu_est, 6)\n\n    def solve_case_a():\n        \"\"\"Case A: Happy path, isotropic, coverage-independent.\"\"\"\n        Ea = 0.6  # eV\n        nu = 1.0e12  # s^-1\n        a = 2.5e-10  # m\n        g = 1.0 / 4.0\n        T = np.array([400, 450, 500, 550, 600])  # K\n\n        D0 = g * nu * a**2\n        D = D0 * np.exp(-Ea / (KB_EV_K * T))\n        \n        return perform_regression(T, D, a, g)\n\n    def solve_case_b():\n        \"\"\"Case B: Anisotropic diffusion, same activation barrier.\"\"\"\n        Ea = 0.6  # eV\n        g = 1.0 / 4.0\n        T = np.array([400, 450, 500, 550, 600])  # K\n\n        # Directional components\n        ax, nu_x = 3.0e-10, 1.2e12\n        ay, nu_y = 2.2e-10, 0.8e12\n        \n        D0_x = g * nu_x * ax**2\n        D0_y = g * nu_y * ay**2\n\n        Dx = D0_x * np.exp(-Ea / (KB_EV_K * T))\n        Dy = D0_y * np.exp(-Ea / (KB_EV_K * T))\n\n        # Effective D is the arithmetic mean\n        D_eff = (Dx + Dy) / 2.0\n\n        # Use a_fit for regression analysis as specified\n        a_fit = 2.5e-10  # m\n        return perform_regression(T, D_eff, a_fit, g)\n\n    def solve_case_c():\n        \"\"\"Case C: Coverage effect producing a temperature-dependent barrier.\"\"\"\n        Ea0 = 0.5  # eV\n        gamma = 0.2  # eV\n        nu = 8.0e11  # s^-1\n        a = 2.6e-10  # m\n        g = 1.0 / 4.0\n        T = np.array([400, 450, 500, 550, 600]) # K\n\n        def coverage_theta(T_val):\n            return 1.0 / (1.0 + np.exp((T_val - 500.0) / 30.0))\n\n        Ea_T = Ea0 + gamma * coverage_theta(T)\n        D0 = g * nu * a**2\n        D = D0 * np.exp(-Ea_T / (KB_EV_K * T))\n        \n        return perform_regression(T, D, a, g)\n\n    def solve_case_d():\n        \"\"\"Case D: Boundary case with minimal data.\"\"\"\n        Ea = 0.3  # eV\n        nu = 1.0e13  # s^-1\n        a = 2.8e-10  # m\n        g = 1.0 / 4.0\n        T = np.array([500, 510])  # K\n\n        D0 = g * nu * a**2\n        D = D0 * np.exp(-Ea / (KB_EV_K * T))\n\n        return perform_regression(T, D, a, g)\n\n    # Run all cases and collect results\n    results = [\n        list(solve_case_a()),\n        list(solve_case_b()),\n        list(solve_case_c()),\n        list(solve_case_d()),\n    ]\n    \n    # Format the final output string exactly as required\n    result_str = \",\".join([f\"[{ea},{nu}]\" for ea, nu in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        }
    ]
}