{
    "hands_on_practices": [
        {
            "introduction": "动力学蒙特卡洛（KMC）模拟通过一系列离散事件来描述系统的时间演化。本练习将从最简单的系统入手：一个仅包含吸附和脱附事件的独立催化位点。通过求解该双态系统的主方程，你将推导出表面覆盖度随时间的演化过程，这项实践旨在建立KMC中使用的微观速率常数与它们所产生的宏观动力学定律（如Langmuir吸附等温线）之间的重要联系。",
            "id": "3884607",
            "problem": "考虑一个在动力学蒙特卡洛（KMC）框架下表示为双态在格模型的单个催化位点。该位点可以为空位或被吸附物占据。该系统与固定分压 $p$ 和温度下的气相耦合，吸附物解吸回到连续（离格）气相中。假设如下：\n\n- 在空位上的吸附以与气体分压成正比的倾向发生，其速率由 $k_a p$ 建模，其中 $k_a$ 是一个包含黏附概率和分子撞击动力学的常数。\n- 从被占据位点上的解吸以恒定速率 $k_d$ 发生，该速率通过阿伦尼乌斯型关系依赖于活化能和温度，但在此被视为一个已知常数。\n- 令 $P_{\\text{occupied}}(t)$ 表示位点在时间 $t$ 被占据的概率，并假设初始条件为 $P_{\\text{occupied}}(0)=0$（初始为空位）。\n- 位点之间没有横向相互作用，气相供应维持 $p$ 随时间恒定。其底层动力学可以建模为一个双态连续时间马尔可夫链（CTMC）。\n\n从双态CTMC的主方程出发，推导 $P_{\\text{occupied}}(t)$ 关于 $k_a$、$p$、$k_d$ 和 $t$ 的随时间变化的表达式，并确定当 $t \\to \\infty$ 时覆盖度的长时间极限。将您的最终答案表示为 $P_{\\text{occupied}}(t)$ 的一个单一闭式解析表达式，所有参数均为符号。不需要进行数值计算或四舍五入。最终答案应为无量纲的。",
            "solution": "该问题提出了一个基于化学动力学和统计力学基本原理的有效且适定的场景。它描述了单个催化位点上的朗缪尔吸附-解吸过程，该过程可以严格地建模为双态连续时间马尔可夫链（CTMC）。所有必要的参数、速率和初始条件都已提供，并且没有内部矛盾或科学不准确之处。我现在将着手推导解答。\n\n设单个催化位点的状态由一个随机变量描述。该位点可以处于两种状态之一：空位（状态 $V$）或被占据（状态 $O$）。令 $P_V(t)$ 为位点在时间 $t$ 为空位的概率，令 $P_{\\text{occupied}}(t)$ 为位点在时间 $t$ 被占据的概率。由于只有两种可能的状态，在所有时间，概率之和必须为1：\n$$P_V(t) + P_{\\text{occupied}}(t) = 1$$\n问题给出了初始条件，即在 $t=0$ 时位点为空位，这可以转化为：\n$$P_{\\text{occupied}}(0) = 0$$\n这意味着 $P_V(0) = 1$。\n\n系统的动力学由两个基本过程控制：\n1. 吸附：一个来自气相的分子吸附到一个空位上。这是从状态 $V$ 到状态 $O$ 的转变。该过程的速率与分压 $p$ 成正比，具体为 $k_a p$。\n2. 解吸：一个已吸附的分子从被占据的位点解吸回气相中。这是从状态 $O$ 到状态 $V$ 的转变。该过程的速率为一个常数 $k_d$。\n\n位点被占据的概率 $P_{\\text{occupied}}(t)$ 的时间演化由这个双态CTMC的主方程描述。$P_{\\text{occupied}}(t)$ 的变化率是进入被占据状态的转变速率减去离开被占据状态的转变速率。\n$$ \\frac{dP_{\\text{occupied}}(t)}{dt} = (\\text{rate of } V \\to O) - (\\text{rate of } O \\to V) $$\n进入状态 $O$ 的转变速率是处于状态 $V$ 的概率 $P_V(t)$ 乘以从 $V$ 到 $O$ 的转变速率 $k_a p$。\n离开状态 $O$ 的转变速率是处于状态 $O$ 的概率 $P_{\\text{occupied}}(t)$ 乘以从 $O$ 到 $V$ 的转变速率 $k_d$。\n因此，主方程为：\n$$ \\frac{dP_{\\text{occupied}}(t)}{dt} = (k_a p) P_V(t) - k_d P_{\\text{occupied}}(t) $$\n为了求解该方程得到 $P_{\\text{occupied}}(t)$，我们必须消去 $P_V(t)$。利用概率守恒 $P_V(t) = 1 - P_{\\text{occupied}}(t)$，我们将其代入主方程：\n$$ \\frac{dP_{\\text{occupied}}(t)}{dt} = k_a p (1 - P_{\\text{occupied}}(t)) - k_d P_{\\text{occupied}}(t) $$\n展开各项，我们得到：\n$$ \\frac{dP_{\\text{occupied}}(t)}{dt} = k_a p - k_a p P_{\\text{occupied}}(t) - k_d P_{\\text{occupied}}(t) $$\n这是一个一阶线性常微分方程。我们可以将其整理成标准形式 $\\frac{dy}{dt} + f(t)y = g(t)$：\n$$ \\frac{dP_{\\text{occupied}}(t)}{dt} + (k_a p + k_d) P_{\\text{occupied}}(t) = k_a p $$\n这个方程可以使用积分因子的方法求解。积分因子 $I(t)$ 由下式给出：\n$$ I(t) = \\exp\\left(\\int (k_a p + k_d) dt\\right) = \\exp((k_a p + k_d)t) $$\n将整个微分方程乘以 $I(t)$：\n$$ \\exp((k_a p + k_d)t) \\frac{dP_{\\text{occupied}}(t)}{dt} + (k_a p + k_d) \\exp((k_a p + k_d)t) P_{\\text{occupied}}(t) = k_a p \\exp((k_a p + k_d)t) $$\n方程的左边现在是 $P_{\\text{occupied}}(t)$ 与积分因子 $I(t)$ 乘积的导数：\n$$ \\frac{d}{dt} \\left[ P_{\\text{occupied}}(t) \\exp((k_a p + k_d)t) \\right] = k_a p \\exp((k_a p + k_d)t) $$\n接下来，我们对两边关于时间 $t$ 积分：\n$$ \\int \\frac{d}{dt} \\left[ P_{\\text{occupied}}(t) \\exp((k_a p + k_d)t) \\right] dt = \\int k_a p \\exp((k_a p + k_d)t) dt $$\n$$ P_{\\text{occupied}}(t) \\exp((k_a p + k_d)t) = \\frac{k_a p}{k_a p + k_d} \\exp((k_a p + k_d)t) + C $$\n其中 $C$ 是积分常数。为了求出 $P_{\\text{occupied}}(t)$ 的通解，我们通过除以积分因子来分离它：\n$$ P_{\\text{occupied}}(t) = \\frac{k_a p}{k_a p + k_d} + C \\exp(-(k_a p + k_d)t) $$\n为了确定常数 $C$，我们应用初始条件 $P_{\\text{occupied}}(0) = 0$：\n$$ 0 = \\frac{k_a p}{k_a p + k_d} + C \\exp(0) $$\n$$ 0 = \\frac{k_a p}{k_a p + k_d} + C $$\n求解 $C$，我们发现：\n$$ C = -\\frac{k_a p}{k_a p + k_d} $$\n将 $C$ 的这个值代回通解，得到 $P_{\\text{occupied}}(t)$ 的特解：\n$$ P_{\\text{occupied}}(t) = \\frac{k_a p}{k_a p + k_d} - \\frac{k_a p}{k_a p + k_d} \\exp(-(k_a p + k_d)t) $$\n提取公因式，得到最终的整洁表达式：\n$$ P_{\\text{occupied}}(t) = \\frac{k_a p}{k_a p + k_d} \\left( 1 - \\exp(-(k_a p + k_d)t) \\right) $$\n这就是位点被占据的概率随时间变化的表达式。\n\n问题还要求确定覆盖度的长时间极限，这等价于当 $t \\to \\infty$ 时的 $P_{\\text{occupied}}(t)$。取极限：\n$$ \\lim_{t \\to \\infty} P_{\\text{occupied}}(t) = \\lim_{t \\to \\infty} \\left[ \\frac{k_a p}{k_a p + k_d} \\left( 1 - \\exp(-(k_a p + k_d)t) \\right) \\right] $$\n由于 $k_a$、$p$ 和 $k_d$ 都是正常数，它们的和 $k_a p + k_d$ 也是正的。因此，当 $t \\to \\infty$ 时，指数项衰减到零：\n$$ \\lim_{t \\to \\infty} \\exp(-(k_a p + k_d)t) = 0 $$\n因此，稳态占据率为：\n$$ P_{\\text{occupied}}(t \\to \\infty) = \\frac{k_a p}{k_a p + k_d} (1 - 0) = \\frac{k_a p}{k_a p + k_d} $$\n这个结果是著名的朗缪尔等温线，它给出了平衡状态下的分数表面覆盖度。这证实了我们推导的随时间变化的解的物理正确性。\n要求的最终答案是 $P_{\\text{occupied}}(t)$ 的完整随时间变化的表达式。",
            "answer": "$$\n\\boxed{\\frac{k_a p}{k_a p + k_d} \\left( 1 - \\exp(-(k_a p + k_d)t) \\right)}\n$$"
        },
        {
            "introduction": "在实际的KMC模拟中，我们通常需要模拟一个扩展的表面，并采用周期性边界条件（PBC）以消除有限尺寸效应带来的伪影。本练习聚焦于格点KMC模型的计算几何问题，你将学习如何为二维网格上的位点稳健地识别其相邻位点，并正确处理边界的环绕逻辑。掌握PBC的实现是编写格点模拟代码的一项基本功，它能确保你的模型正确地代表了一个无限延伸的表面。",
            "id": "3884595",
            "problem": "一个催化表面被建模为一个在两个方向上都具有周期性边界条件 (PBC) 的矩形、在晶格上的动力学蒙特卡洛 (KMC) 系统。该表面由一个 $L_x \\times L_y$ 的晶格位点网格组成。在 PBC 中，该晶格在拓扑上是一个环面：晶格坐标通过对晶格周期性取模来确定，因此移动一步越过边界会从相对的另一侧重新进入。位点通过线性位点索引 $s$ 按行主序进行枚举，即从坐标到线性索引的映射为 $s = i + L_x \\, j$，其中坐标索引 $i \\in \\{0,\\ldots,L_x-1\\}$ 和 $j \\in \\{0,\\ldots,L_y-1\\}$。假设对整数的取模运算符 $a \\bmod n$ 返回 $\\{0,\\ldots,n-1\\}$ 中的唯一余数，并且 $\\lfloor \\cdot \\rfloor$ 表示向下取整函数。\n\n在一个在晶格上的 KMC 步骤中，为了提出最近邻扩散或反应事件，必须为任意位点 $s$ 计算其沿 $\\pm \\hat{\\boldsymbol{x}}$ 和 $\\pm \\hat{\\boldsymbol{y}}$ 方向的四个最近邻的线性索引，使得在 PBC 下没有边界效应。\n\n哪个选项为计算每个位点 $s$ 的四个邻居索引提供了一个正确且在实现上稳健的方案，该方案与上述定义一致并避免了边界效应？\n\nA. 通过 $i = s \\bmod L_x$ 和 $j = \\left\\lfloor s / L_x \\right\\rfloor$ 从 $s$ 计算坐标。然后计算\n- 右邻居：$s_{\\mathrm{R}} = \\left(\\left(i + 1 + L_x\\right) \\bmod L_x\\right) + L_x \\, j$，\n- 左邻居：$s_{\\mathrm{L}} = \\left(\\left(i - 1 + L_x\\right) \\bmod L_x\\right) + L_x \\, j$，\n- 上邻居：$s_{\\mathrm{U}} = i + L_x \\left(\\left(j + 1 + L_y\\right) \\bmod L_y\\right)$，\n- 下邻居：$s_{\\mathrm{D}} = i + L_x \\left(\\left(j - 1 + L_y\\right) \\bmod L_y\\right)$。\n\nB. 直接使用线性索引 $s$ 并设置\n- 右邻居：$s_{\\mathrm{R}} = \\left(s + 1\\right) \\bmod \\left(L_x L_y\\right)$，\n- 左邻居：$s_{\\mathrm{L}} = \\left(s - 1 + L_x L_y\\right) \\bmod \\left(L_x L_y\\right)$，\n- 上邻居：$s_{\\mathrm{U}} = \\left(s + L_x\\right) \\bmod \\left(L_x L_y\\right)$，\n- 下邻居：$s_{\\mathrm{D}} = \\left(s - L_x + L_x L_y\\right) \\bmod \\left(L_x L_y\\right)$。\n\nC. 使用基于1的坐标，但使用相同的线性索引 $s \\in \\{0,\\ldots,L_x L_y - 1\\}$：设置 $i' = 1 + (s \\bmod L_x)$ 和 $j' = 1 + \\left\\lfloor s / L_x \\right\\rfloor$，然后定义\n- $i'_{\\mathrm{R}} = \\left(\\left(i' + 1\\right) \\bmod L_x\\right)$, $i'_{\\mathrm{L}} = \\left(\\left(i' - 1 + L_x\\right) \\bmod L_x\\right)$, $j'_{\\mathrm{U}} = \\left(\\left(j' + 1\\right) \\bmod L_y\\right)$, $j'_{\\mathrm{D}} = \\left(\\left(j' - 1 + L_y\\right) \\bmod L_y\\right)$,\n并通过 $s_{\\alpha} = i'_{\\alpha} + L_x \\, j'_{\\alpha}$ 映射回线性索引，其中 $\\alpha \\in \\{\\mathrm{R,L,U,D}\\}$。\n\nD. 通过 $i = \\left\\lfloor s / L_y \\right\\rfloor$ 和 $j = s \\bmod L_y$（列主序风格）计算坐标，然后设置\n- 右邻居：$s_{\\mathrm{R}} = \\left(\\left(i + 1 + L_y\\right) \\bmod L_y\\right) + L_y \\, j$，\n- 左邻居：$s_{\\mathrm{L}} = \\left(\\left(i - 1 + L_y\\right) \\bmod L_y\\right) + L_y \\, j$，\n- 上邻居：$s_{\\mathrm{U}} = i + L_y \\left(\\left(j + 1 + L_x\\right) \\bmod L_x\\right)$，\n- 下邻居：$s_{\\mathrm{D}} = i + L_y \\left(\\left(j - 1 + L_x\\right) \\bmod L_x\\right)$。\n\n选择一个选项。",
            "solution": "首先验证问题陈述，以确保其科学上合理、定义明确且客观。\n\n### 第1步：提取已知条件\n- **系统：** 一个矩形的、在晶格上的动力学蒙特卡洛 (KMC) 模型。\n- **晶格维度：** 一个 $L_x \\times L_y$ 的晶格位点网格。\n- **边界条件：** 在 $\\hat{\\boldsymbol{x}}$ 和 $\\hat{\\boldsymbol{y}}$ 两个方向上的周期性边界条件 (PBC)，使晶格成为一个拓扑环面。\n- **位点索引：** 位点通过线性索引 $s$ 枚举。\n- **索引方案：** 指定为行主序。\n- **坐标到索引的映射：** 从二维坐标 $(i, j)$ 到线性索引 $s$ 的映射被明确给出为 $s = i + L_x \\, j$。\n- **坐标范围：** 坐标索引为 $i \\in \\{0, \\ldots, L_x-1\\}$ 和 $j \\in \\{0, \\ldots, L_y-1\\}$。\n- **取模运算符：** 运算符 $a \\bmod n$ 返回集合 $\\{0, \\ldots, n-1\\}$ 中的唯一余数。\n- **向下取整函数：** $\\lfloor \\cdot \\rfloor$ 表示标准的向下取整函数。\n- **目标：** 为任意位点 $s$ 找到一套正确且在实现上稳健的公式，用于计算其四个最近邻（右、左、上、下）的线性索引，并与定义和 PBC 一致。\n\n### 第2步：使用提取的已知条件进行验证\n- **科学依据：** 该问题牢固地植根于计算物理学和材料科学。带有 PBC 和行主序索引的晶格模型是 KMC 和其他模拟技术中的标准构造。该问题是在周期性网格上实现邻居查找的一个实践练习。它是科学上有效的。\n- **定义明确：** 所有必要信息都已提供。晶格结构、索引方案和边界条件都已明确定义。目标是找到一套可以推导和验证的数学表达式。存在唯一的正确解。\n- **客观性：** 该问题以精确的数学语言陈述。诸如“行主序”和特定的坐标到索引映射公式等术语没有留下任何歧义的余地。术语“在实现上稳健”在此上下文中被合理地解释为避免特定编程语言实现取模运算符时的常见陷阱（例如，对于负操作数），这是计算科学中的一个标准考虑因素。\n\n### 第3步：结论与行动\n问题陈述是**有效的**。这是一个定义明确的、计算科学中的标准问题。我现在将着手推导解决方案并评估给出的选项。\n\n### 正确邻居查找方案的推导\n\n1.  **逆向映射（线性索引到坐标）：**\n    我们已知行主序映射 $s = i + L_x \\, j$，其中 $i \\in \\{0, \\ldots, L_x-1\\}$ 和 $j \\in \\{0, \\ldots, L_y-1\\}$。要找到位点 $s$ 的邻居，我们必须首先确定其坐标 $(i, j)$。\n    -   要找到列索引 $i$，我们可以对表达式取模 $L_x$：\n        $$s \\bmod L_x = (i + L_x \\, j) \\bmod L_x$$\n        由于 $L_x \\, j$ 是 $L_x$ 的倍数，其对 $L_x$ 取模的余数为 $0$。又因为 $i \\in \\{0, \\ldots, L_x-1\\}$，我们有 $i \\bmod L_x = i$。\n        因此，$i = s \\bmod L_x$。\n    -   要找到行索引 $j$，我们使用整数除法。从 $s = i + L_x \\, j$，我们可以写出 $s - i = L_x \\, j$。因此，$j = (s - i) / L_x$。由于 $i$ 和 $j$ 必须是整数，这意味着 $j = \\lfloor (s - i) / L_x \\rfloor$。代入 $i = s \\bmod L_x$，我们得到 $j = \\lfloor (s - (s \\bmod L_x)) / L_x \\rfloor$。根据整数除法的定义，$s = \\lfloor s/L_x \\rfloor L_x + (s \\bmod L_x)$。将其与 $s = j L_x + i$ 进行比较，我们直接确定 $j = \\lfloor s / L_x \\rfloor$。\n    -   所以，逆向映射为：$i = s \\bmod L_x$ 和 $j = \\lfloor s / L_x \\rfloor$。\n\n2.  **带 PBC 的邻居坐标：**\n    对于坐标为 $(i, j)$ 的位点，其最近邻的坐标通过对相应坐标加或减 $1$ 并应用 PBC 来找到。\n    -   右邻居（$\\hat{\\boldsymbol{x}}$ 方向）：$(i+1, j)$。使用 PBC，新的 x 坐标变为 $(i+1) \\bmod L_x$。坐标为 $((i+1) \\bmod L_x, j)$。\n    -   左邻居（$-\\hat{\\boldsymbol{x}}$ 方向）：$(i-1, j)$。使用 PBC，新的 x 坐标为 $(i-1) \\bmod L_x$。坐标为 $((i-1) \\bmod L_x, j)$。\n    -   上邻居（$\\hat{\\boldsymbol{y}}$ 方向）：$(i, j+1)$。使用 PBC，新的 y 坐标为 $(j+1) \\bmod L_y$。坐标为 $(i, (j+1) \\bmod L_y)$。\n    -   下邻居（$-\\hat{\\boldsymbol{y}}$ 方向）：$(i, j-1)$。使用 PBC，新的 y 坐标为 $(j-1) \\bmod L_y$。坐标为 $(i, (j-1) \\bmod L_y)$。\n\n    为确保“实现上的稳健性”，尤其是在某些编程语言中，当 `a % n` 为负数时 `a % n` 可能为负，标准做法是使用 `(a + n) % n` 的形式。这会得到：\n    -   $i_{\\mathrm{L}} = (i - 1 + L_x) \\bmod L_x$\n    -   $j_{\\mathrm{D}} = (j - 1 + L_y) \\bmod L_y$\n    右邻居和上邻居的表达式严格来说不需要这个，因为 $i+1$ 和 $j+1$ 总是非负的，但为了保持一致性，应用相同的模式是很常见的：\n    -   $i_{\\mathrm{R}} = (i + 1 + L_x) \\bmod L_x = (i + 1) \\bmod L_x$\n    -   $j_{\\mathrm{U}} = (j + 1 + L_y) \\bmod L_y = (j + 1) \\bmod L_y$\n\n3.  **正向映射（邻居坐标到线性索引）：**\n    我们现在使用原始映射 $s_{\\text{neighbor}} = i_{\\text{neighbor}} + L_x \\, j_{\\text{neighbor}}$ 来找到邻居的线性索引。\n    -   右邻居：$s_{\\mathrm{R}} = ((i + 1) \\bmod L_x) + L_x \\, j$。稳健形式：$s_{\\mathrm{R}} = ((i + 1 + L_x) \\bmod L_x) + L_x \\, j$。\n    -   左邻居：$s_{\\mathrm{L}} = ((i - 1 + L_x) \\bmod L_x) + L_x \\, j$。\n    -   上邻居：$s_{\\mathrm{U}} = i + L_x \\, ((j + 1 + L_y) \\bmod L_y)$。\n    -   下邻居：$s_{\\mathrm{D}} = i + L_x \\, ((j - 1 + L_y) \\bmod L_y)$。\n\n推导到此完成。现在我们来评估各个选项。\n\n### 逐项分析选项\n\n**A. 通过 $i = s \\bmod L_x$ 和 $j = \\left\\lfloor s / L_x \\right\\rfloor$ 从 $s$ 计算坐标。然后计算...**\n- 坐标提取公式为 $i = s \\bmod L_x$ 和 $j = \\lfloor s / L_x \\rfloor$。这与我们针对行主序的推导完全匹配。\n- 邻居索引公式为：\n  - $s_{\\mathrm{R}} = \\left(\\left(i + 1 + L_x\\right) \\bmod L_x\\right) + L_x \\, j$\n  - $s_{\\mathrm{L}} = \\left(\\left(i - 1 + L_x\\right) \\bmod L_x\\right) + L_x \\, j$\n  - $s_{\\mathrm{U}} = i + L_x \\left(\\left(j + 1 + L_y\\right) \\bmod L_y\\right)$\n  - $s_{\\mathrm{D}} = i + L_x \\left(\\left(j - 1 + L_y\\right) \\bmod L_y\\right)$\n这些公式与从第一性原理推导出的公式完全相同，包括取模运算符的稳健实现。\n**结论：正确。**\n\n**B. 直接使用线性索引 $s$ 并设置...**\n该选项避免了转换为二维坐标，而是直接使用线性索引 $s$。\n- **右邻居：** $s_{\\mathrm{R}} = (s + 1) \\bmod (L_x L_y)$。让我们在一个位于行右边缘的位点上测试一下，例如 $i = L_x-1$。其索引为 $s = (L_x-1) + L_x j$。该公式给出 $s+1 = (L_x-1) + L_x j + 1 = L_x + L_x j = L_x(j+1)$。这对应于坐标为 $(0, j+1)$ 的位点，即*下一*行的第一个位点。正确的邻居位于 $(0, j)$，索引为 $0 + L_x j = L_x j$。该公式是错误的，因为它没有在同一行内回绕。此方法仅适用于一维 PBC。\n- **左邻居：** $s_{\\mathrm{L}} = (s - 1 + L_x L_y) \\bmod (L_x L_y)$。类似地，对于一个位于左边缘（$i=0$）的位点，$s = L_x j$。该公式给出 $s-1 = L_x j - 1 = (L_x-1) + L_x(j-1)$，即*上一*行的最后一个位点。正确的邻居位于 $(L_x-1, j)$，索引为 $(L_x-1) + L_x j$。该公式是错误的。\n- **上/下邻居：** 公式 $s_{\\mathrm{U}} = (s+L_x) \\bmod (L_x L_y)$ 和 $s_{\\mathrm{D}} = (s-L_x+L_x L_y) \\bmod (L_x L_y)$ 碰巧是正确的。由于是行主序，向上或向下移动一行对应于从索引中增加或减少一整行的长度 $L_x$。对总位点数 $L_x L_y$ 取模正确处理了顶行和底行之间的回绕。然而，由于左邻居和右邻居的方案存在缺陷，整个选项是无效的。\n**结论：错误。**\n\n**C. 使用基于1的坐标，但使用相同的线性索引 $s \\in \\{0,\\ldots,L_x L_y - 1\\}$...**\n这个选项引入了一个基于1的坐标系，$i' \\in \\{1, \\ldots, L_x\\}$ 和 $j' \\in \\{1, \\ldots, L_y\\}$。\n- 映射 $i' = 1 + (s \\bmod L_x)$ 和 $j' = 1 + \\lfloor s / L_x \\rfloor$ 正确地将一个基于0的索引 $s$ 转换为基于1的坐标 $(i', j')$。\n- 邻居坐标公式，例如 $i'_{\\mathrm{R}} = ((i' + 1) \\bmod L_x)$，是有缺陷的。因为 $i'$ 是基于1的，对于最右边的列 $i' = L_x$，这给出 $(L_x+1) \\bmod L_x = 1$。这似乎正确地从列 $L_x$ 回绕到 1。然而，对于 $i' = L_x-1$，它给出 $(L_x-1+1) \\bmod L_x = L_x \\bmod L_x = 0$。得到的坐标 $i'_{R}$ 是 0，这超出了定义的基于1的范围 $\\{1, ..., L_x\\}$。该选项以不一致的方式混合了基于1和基于0的索引约定。\n- 用于重新映射到线性索引的最终公式 $s_{\\alpha} = i'_{\\alpha} + L_x \\, j'_{\\alpha}$ 也是不一致的。它取一个计算出的邻居坐标（例如，$i'_{\\mathrm{R}}$，我们发现它可能是基于0的）并将其与另一个邻居坐标（例如，$j'_{\\mathrm{R}}$）乘以 $L_x$ 相加。该表示法是模糊的，并且索引基数的混合使其在根本上是不合理的。\n**结论：错误。**\n\n**D. 通过 $i = \\left\\lfloor s / L_y \\right\\rfloor$ 和 $j = s \\bmod L_y$（列主序风格）计算坐标...**\n此选项提出了另一种坐标提取方案。\n- 问题陈述明确定义了**行主序**以及映射 $s = i + L_x \\, j$。\n- 此选项中提出的公式 $i = \\lfloor s / L_y \\rfloor$ 和 $j = s \\bmod L_y$ 对应于**列主序**，其中索引沿列增长最快。这可以通过写出其逆映射来看出：$s = j + L_y \\, i$。\n- 这个初始步骤直接与问题陈述中给出的前提相矛盾。因此，基于这个不正确前提的任何后续计算在所述问题的背景下都是无效的。\n**结论：错误。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "KMC算法的一个核心步骤是从包含海量可能性的事件目录中，选择下一个即将发生的事件，这一步的效率直接决定了模拟的整体性能。本练习将要求你分析和比较两种用于事件抽样和速率更新的数据结构：别名表（alias table）和二元索引树（Binary Indexed Tree）。理解这些算法之间的优劣权衡，对于开发可扩展的高效KMC代码至关重要，尤其是在处理具有大量可能事件的复杂系统时。",
            "id": "3884666",
            "problem": "考虑一个在格（on-lattice）模型下的非均相催化表面的动力学蒙特卡洛（KMC）模拟，该模拟包含一个由 $N$ 个离散事件组成的目录，事件索引为 $i \\in \\{1, \\dots, N\\}$，每个事件都有一个非负的倾向（速率）$r_i$。下一个事件以概率 $p_i = r_i / R$ 被选中，其中 $R = \\sum_{j=1}^{N} r_j$ 是总速率，并且停留时间从一个参数为 $R$ 的指数分布中抽取，这与连续时间马尔可夫链一致。在在格和离格（off-lattice）模型中，由于局部配位、覆盖度或反应势垒的变化，在每次事件发生后，$r_i$ 的局部更新会频繁发生，从而修改已执行事件邻域内的一小部分速率。你的任务是比较用于从离散分布 $\\{p_i\\}$ 中采样并有效更新速率的数据结构：使用别名表的别名法（alias method），以及二元索引树（BIT）（也称为Fenwick树）。\n\n从定义 $p_i = r_i / R$ 和通过累积分布函数 $F(k) = \\sum_{j=1}^{k} p_j$ 的离散分布逆变换采样法出发，在采样和更新时间复杂度（作为 $N$ 的函数）方面，对这些结构进行有理有据的比较，假设每次局部更新只涉及单个速率变化 $r_i \\leftarrow r_i + \\Delta$ 并且总速率 $R$ 保持一致地维护。通过分析每种结构如何表示或近似逆变换采样所需的累积和，以及 $r_i$ 的局部变化如何通过所维护的表示进行传播，来推导渐进复杂度。然后，根据你的推导，推荐哪种结构更适用于以频繁局部更新（每次事件影响少量速率）为特征的KMC模拟，并在 $N$ 可能很大且局部变化占主导的在格和离格两种情景下，证明你的选择是合理的。\n\n哪个选项是正确的？\n\nA. 别名表通过两次均匀抽样和一个常数时间的桶决策，在 $O(1)$ 时间内完成采样，但在最坏情况下，更改任何单个 $r_i$ 后的更新时间是 $O(N)$，因为归一化和桶的划分通常需要全局重新平衡；二元索引树（BIT），也称为Fenwick树，通过对存储在树中的累积和进行二分搜索，支持在 $O(\\log N)$ 时间内采样，并通过沿树传播 $\\Delta$ 在 $O(\\log N)$ 时间内更新。因此，对于KMC中频繁的局部更新，BIT/Fenwick树是更可取的。\n\nB. 别名表支持在 $O(1)$ 时间内进行采样和更新，因为更改单个 $r_i$ 只影响其自身的桶；二元索引树需要 $O(N)$ 时间进行采样，因为它必须遍历所有 $N$ 个条目来计算累积和，但通过调整单个节点，更新时间是 $O(1)$。因此，对于频繁的局部更新，别名表是更可取的。\n\nC. Fenwick树通过直接索引支持在 $O(1)$ 时间内采样，但更新时间是 $O(N)$，因为每次更改后都必须重新计算累积和；别名表需要 $O(\\log N)$ 时间进行采样和更新。因此，对于频繁的局部更新，Fenwick树是更可取的。\n\nD. 所有三种结构——别名表、二元索引树和Fenwick树——都提供 $O(1)$ 的采样和 $O(1)$ 的更新，因为它们存储了预计算的概率；因此，任何结构都同样适用于KMC中频繁的局部更新。",
            "solution": "问题陈述要求对用于动力学蒙特卡洛（KMC）模拟的别名法和二元索引树（BIT）进行有理有据的比较，重点关注它们在采样和更新事件方面的时间复杂度。\n\n### 第一步：提取已知条件\n- 一个KMC模拟，包含一个由 $N$ 个离散事件组成的目录，索引为 $i \\in \\{1, \\dots, N\\}$。\n- 每个事件都有一个非负速率 $r_i$。\n- 总速率为 $R = \\sum_{j=1}^{N} r_j$。\n- 选择事件 $i$ 的概率为 $p_i = r_i / R$。\n- 模拟时间的推进基于从参数为 $R$ 的指数分布中抽样。\n- KMC模拟涉及频繁的局部更新，其中一小部分速率会发生变化。\n- 分析考虑单个速率变化：$r_i \\leftarrow r_i + \\Delta$。\n- 假设总速率 $R$ 被一致地维护。\n- 比较必须基于推导采样（通过基于 $F(k) = \\sum_{j=1}^{k} p_j$ 的逆变换）和单速率更新的复杂度。\n- 待比较的数据结构：别名法（别名表）和二元索引树（BIT）/Fenwick树。\n- 目标：为具有频繁局部更新的KMC推荐一种结构并证明其合理性。\n\n### 第二步：使用提取的已知条件进行验证\n根据验证标准评估问题陈述：\n\n- **科学依据**：该问题描述了计算科学和化学工程中的一种标准、成熟的方法，即动力学蒙特卡洛。事件速率、选择概率、时间演化以及高效采样和更新大量事件的计算挑战等概念是该领域的核心。所提到的数据结构，别名法和Fenwick树，是解决此问题的已知和常用方案。描述在事实上和科学上都是合理的。\n- **问题定义良好**：问题定义良好。它要求进行特定的先验分析——为定义明确的操作（采样、更新）和定义明确的数据结构推导渐进时间复杂度。上下文被清晰地指定（频繁的局部更新），从而可以得出一个明确的结论。基于标准算法分析，存在一个唯一的、稳定的、有意义的解。\n- **客观性**：问题以精确、技术性的语言表达（例如，“倾向”、“累积分布函数”、“渐进复杂度”）。它不含主观或模棱两可的术语。\n\n### 第三步：结论与行动\n问题陈述是**有效的**。它在科学上是合理的，定义良好，客观，并为进行严谨分析提供了完整的设置。我们可以着手解决。\n\n### 复杂度的推导与比较\n\nKMC步骤的核心涉及两个操作：（1）选择一个要执行的事件；（2）根据已执行事件的后果更新可能的事件列表及其速率。我们为每种数据结构分析这两个操作的时间复杂度。\n\n**1. 别名法（别名表）**\n\n别名法是一种从离散概率分布中采样的经典技术。它将概率 $p_i$ 预处理成两个大小为 $N$ 的表：一个概率表和一个别名表。\n\n- **采样**：要抽取一个样本，首先从 $\\{1, \\dots, N\\}$ 中均匀随机选择一个桶索引 $j$。然后，生成一个均匀随机变量 $u \\in [0, 1)$。如果 $u$ 小于存储在概率表第 $j$ 项中的概率，则结果为 $j$；否则，结果为存储在别名表第 $j$ 项中的别名索引。此过程涉及两次随机数生成和一次比较，这些都是常数时间操作。因此，采样复杂度为 $O(1)$。\n\n- **更新**：更新涉及更改单个速率，$r_i \\leftarrow r_i + \\Delta$。这会将总速率更改为 $R' = R + \\Delta$。因此，由于新的归一化因子 $R'$，所有概率 $p_j = r_j / R$ 都会改变。别名表的构建依赖于将概率划分为“小”组和“大”组来填充桶。所有概率的改变通常需要完全重建概率表和别名表。构建别名表的标准算法，如Vose算法，需要处理所有 $N$ 个概率。因此，更新复杂度为 $O(N)$。虽然对于小的变化 $\\Delta$ 可能存在轻微的优化，但最坏情况和一般情况下的复杂度仍为 $O(N)$。\n\n**2. 二元索引树（BIT）/ Fenwick树**\n\nBIT是一种为高效计算数组前缀和查询和单点更新而设计的数据结构。在此背景下，BIT将构建在速率数组 $\\{r_1, r_2, \\dots, r_N\\}$ 之上。\n\n- **采样**：使用逆变换采样法进行采样。首先，从 $[0, R)$ 上的均匀分布中抽取一个随机数 $\\rho$。然后，我们需要找到事件索引 $k$，使得 $\\sum_{j=1}^{k-1} r_j \\le \\rho  \\sum_{j=1}^{k} r_j$。这等价于找到最小的索引 $k$，使得速率的累积和 $S(k) = \\sum_{j=1}^{k} r_j$ 大于 $\\rho$。BIT可以在 $O(\\log N)$ 时间内计算任何前缀和 $S(k)$。为了找到所需的索引 $k$，可以在索引 $\\{1, \\dots, N\\}$ 上进行二分搜索，其中搜索的每一步都需要一个 $O(\\log N)$ 的前缀和查询，导致总采样时间为 $O((\\log N)^2)$。然而，通过在BIT结构本身上“行走”，可以执行更高效的搜索，这允许在 $O(\\log N)$ 时间内找到索引 $k$。这是使用BIT进行采样的最优复杂度。\n\n- **更新**：当单个速率 $r_i$ 改变了 $\\Delta$ 时，我们必须更新BIT。这涉及将概念数组中索引 $i$ 处的值增加 $\\Delta$。在BIT结构中，此更改必须传播到所有在其部分和中包含索引 $i$ 的父节点。此类节点的数量与树的高度成正比，即 $O(\\log N)$。因此，更新复杂度为 $O(\\log N)$。总速率 $R$ 也可以通过简单地加上 $\\Delta$ 在 $O(1)$ 时间内更新，正如问题所假设的。\n\n**对KMC的建议**\n\n在一个以频繁局部更新为特征的KMC模拟中，每一步都会采样并执行一个事件，这会触发对少量速率的更新。一次完整KMC步骤（一次采样和一次更新）的总时间复杂度是衡量性能的相关指标。\n\n- **别名法**：总步骤时间 = $O(1)_{\\text{采样}} + O(N)_{\\text{更新}} = O(N)$。\n- **BIT/Fenwick树**：总步骤时间 = $O(\\log N)_{\\text{采样}} + O(\\log N)_{\\text{更新}} = O(\\log N)$。\n\n对于大的 $N$（这在在格和离格KMC模拟中很常见，例如，许多可能的扩散、吸附、解吸或反应事件），BIT的 $O(\\log N)$ 复杂度在渐进意义上远优于别名法的 $O(N)$ 复杂度。BIT操作成本的对数增长使其具有可扩展性，而重建别名表的线性成本使其对于具有频繁更新的大型系统来说是不可行的。因此，对于此KMC应用，二元索引树（或Fenwick树）是更可取的数据结构。\n\n### 选项评估\n\n- **A. 别名表通过两次均匀抽样和一个常数时间的桶决策，在 $O(1)$ 时间内完成采样，但在最坏情况下，更改任何单个 $r_i$ 后的更新时间是 $O(N)$，因为归一化和桶的划分通常需要全局重新平衡；二元索引树（BIT），也称为Fenwick树，通过对存储在树中的累积和进行二分搜索，支持在 $O(\\log N)$ 时间内采样，并通过沿树传播 $\\Delta$ 在 $O(\\log N)$ 时间内更新。因此，对于KMC中频繁的局部更新，BIT/Fenwick树是更可取的。**\n  - 该陈述准确地报告了复杂度：别名表采样为 $O(1)$，别名表更新为 $O(N)$；BIT采样为 $O(\\log N)$，BIT更新为 $O(\\log N)$。每种复杂度的推理都是正确的。基于此分析，BIT是频繁更新的更优选择的最终结论也是正确的。此选项**正确**。\n\n- **B. 别名表支持在 $O(1)$ 时间内进行采样和更新，因为更改单个 $r_i$ 只影响其自身的桶；二元索引树需要 $O(N)$ 时间进行采样，因为它必须遍历所有 $N$ 个条目来计算累积和，但通过调整单个节点，更新时间是 $O(1)$。因此，对于频繁的局部更新，别名表是更可取的。**\n  - 该陈述在多个方面是错误的。别名表更新不是 $O(1)$；由于归一化，所有概率都会改变。BIT采样不是 $O(N)$；它是 $O(\\log N)$。BIT更新不是 $O(1)$；它是 $O(\\log N)$。其结论基于错误的假设。此选项**错误**。\n\n- **C. Fenwick树通过直接索引支持在 $O(1)$ 时间内采样，但更新时间是 $O(N)$，因为每次更改后都必须重新计算累积和；别名表需要 $O(\\log N)$ 时间进行采样和更新。因此，对于频繁的局部更新，Fenwick树是更可取的。**\n  - 该陈述的所有复杂度都是错误的。Fenwick树采样是 $O(\\log N)$，而不是 $O(1)$。Fenwick树更新是 $O(\\log N)$，而不是 $O(N)$。别名表采样是 $O(1)$，而不是 $O(\\log N)$。别名表更新是 $O(N)$，而不是 $O(\\log N)$。此选项**错误**。\n\n- **D. 所有三种结构——别名表、二元索引树和Fenwick树——都提供 $O(1)$ 的采样和 $O(1)$ 的更新，因为它们存储了预计算的概率；因此，任何结构都同样适用于KMC中频繁的局部更新。**\n  - 该陈述有根本性缺陷。别名表和BIT都没有 $O(1)$ 的更新（成本分别为 $O(N)$ 和 $O(\\log N)$）。BIT采样也不是 $O(1)$。声称所有结构都同样适用的说法是错误的，因为它们的性能扩展性截然不同。此选项**错误**。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}