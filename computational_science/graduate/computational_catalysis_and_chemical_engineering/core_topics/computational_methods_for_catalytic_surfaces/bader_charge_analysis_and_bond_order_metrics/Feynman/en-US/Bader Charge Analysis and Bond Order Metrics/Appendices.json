{
    "hands_on_practices": [
        {
            "introduction": "The foundation of the Quantum Theory of Atoms in Molecules (QTAIM) lies in partitioning the electron density, $\\rho(\\mathbf{r})$, into distinct atomic basins. This practice  introduces the fundamental concept of the zero-flux surface, which forms the boundary between these basins. By working through a simple, analytically solvable model of a homonuclear diatomic system, you will derive the location of this surface and gain a concrete understanding of how topology dictates the definition of an atom in a molecule.",
            "id": "3869069",
            "problem": "Consider a diatomic model system used in Quantum Theory of Atoms in Molecules (QTAIM), where atomic basins are defined by zero-flux surfaces of the gradient of the electron density. Two identical atoms are placed along the $x$-axis at positions $\\mathbf{R}_1 = (0,0,0)$ and $\\mathbf{R}_2 = (L,0,0)$ with $L = 2.986$ in Å. Each atom contributes a spherically symmetric Gaussian electron density $n_i(\\mathbf{r}) = \\alpha \\exp\\!\\big(-\\beta\\,|\\mathbf{r}-\\mathbf{R}_i|^2\\big)$, with the same amplitude $\\alpha > 0$ and decay parameter $\\beta > 0$. The total density is $n(\\mathbf{r}) = n_1(\\mathbf{r}) + n_2(\\mathbf{r})$.\n\nStarting from the QTAIM definition that a zero-flux surface $\\mathcal{S}$ satisfies $\\nabla n(\\mathbf{r}) \\cdot \\hat{\\mathbf{n}}(\\mathbf{r}) = 0$ for all $\\mathbf{r} \\in \\mathcal{S}$, where $\\hat{\\mathbf{n}}(\\mathbf{r})$ is the unit normal to the surface at $\\mathbf{r}$, construct the zero-flux dividing surface that partitions space into the two atomic basins. By considering the symmetry of the system and enforcing the zero-flux condition, determine the location $x^{\\star}$ of the dividing surface along the internuclear axis (the $x$-axis), expressed as a single coordinate value along $x$.\n\nRound your final numerical value for $x^{\\star}$ to four significant figures and express it in Å.",
            "solution": "The problem requires us to find the location of the zero-flux dividing surface along the internuclear axis for a model diatomic system.\n\nFirst, we establish the mathematical representation of the total electron density, $n(\\mathbf{r})$. The system consists of two identical atoms located at $\\mathbf{R}_1 = (0,0,0)$ and $\\mathbf{R}_2 = (L,0,0)$. Each atom contributes a spherically symmetric Gaussian electron density given by $n_i(\\mathbf{r}) = \\alpha \\exp(-\\beta |\\mathbf{r}-\\mathbf{R}_i|^2)$. The total electron density is the sum of the contributions from each atom:\n$$n(\\mathbf{r}) = n_1(\\mathbf{r}) + n_2(\\mathbf{r})$$\nIn Cartesian coordinates, where $\\mathbf{r} = (x,y,z)$, the positions are $\\mathbf{R}_1 = (0,0,0)$ and $\\mathbf{R}_2 = (L,0,0)$, with $L = 2.986$ Å. The density is:\n$$n(x,y,z) = \\alpha \\exp(-\\beta(x^2+y^2+z^2)) + \\alpha \\exp(-\\beta((x-L)^2+y^2+z^2))$$\nwhere $\\alpha > 0$ and $\\beta > 0$.\n\nAccording to the Quantum Theory of Atoms in Molecules (QTAIM), the space is partitioned into atomic basins by zero-flux surfaces. A surface $\\mathcal{S}$ is a zero-flux surface if the gradient of the electron density, $\\nabla n(\\mathbf{r})$, has no component normal to the surface. This is expressed by the condition:\n$$\\nabla n(\\mathbf{r}) \\cdot \\hat{\\mathbf{n}}(\\mathbf{r}) = 0$$\nfor all points $\\mathbf{r}$ on the surface $\\mathcal{S}$, where $\\hat{\\mathbf{n}}(\\mathbf{r})$ is the unit vector normal to the surface at $\\mathbf{r}$.\n\nGiven the symmetry of the problem—two identical atoms placed symmetrically about the origin's reflection across the plane $x=L/2$—we can hypothesize that the dividing surface is the plane that perpendicularly bisects the internuclear axis. This plane is described by the equation $x = L/2$. The unit normal vector $\\hat{\\mathbf{n}}$ to this plane is constant everywhere and points along the $x$-axis, i.e., $\\hat{\\mathbf{n}} = (1, 0, 0)$.\n\nTo validate this hypothesis, we must verify if the zero-flux condition is satisfied for all points on the plane $x=L/2$. For this surface, the condition becomes:\n$$\\nabla n(\\mathbf{r}) \\cdot (1,0,0) = \\frac{\\partial n}{\\partial x}\\bigg|_{\\mathbf{r} \\in \\mathcal{S}} = 0$$\nWe need to calculate the partial derivative of the total density $n(x,y,z)$ with respect to $x$:\n$$\\frac{\\partial n}{\\partial x} = \\frac{\\partial}{\\partial x} \\left[ \\alpha \\exp(-\\beta(x^2+y^2+z^2)) + \\alpha \\exp(-\\beta((x-L)^2+y^2+z^2)) \\right]$$\nUsing the chain rule, we get:\n$$\\frac{\\partial n}{\\partial x} = \\alpha \\left[ (-2\\beta x) \\exp(-\\beta(x^2+y^2+z^2)) + (-2\\beta(x-L)) \\exp(-\\beta((x-L)^2+y^2+z^2)) \\right]$$\n$$\\frac{\\partial n}{\\partial x} = -2\\alpha\\beta \\left[ x \\exp(-\\beta(x^2+y^2+z^2)) + (x-L) \\exp(-\\beta((x-L)^2+y^2+z^2)) \\right]$$\n\nNow, we evaluate this derivative at an arbitrary point on the proposed surface, where $x = L/2$:\n$$\\frac{\\partial n}{\\partial x}\\bigg|_{x=L/2} = -2\\alpha\\beta \\left[ \\frac{L}{2} \\exp\\left(-\\beta\\left(\\left(\\frac{L}{2}\\right)^2+y^2+z^2\\right)\\right) + \\left(\\frac{L}{2}-L\\right) \\exp\\left(-\\beta\\left(\\left(\\frac{L}{2}-L\\right)^2+y^2+z^2\\right)\\right) \\right]$$\nSimplifying the terms:\n$$\\frac{\\partial n}{\\partial x}\\bigg|_{x=L/2} = -2\\alpha\\beta \\left[ \\frac{L}{2} \\exp\\left(-\\beta\\left(\\frac{L^2}{4}+y^2+z^2\\right)\\right) - \\frac{L}{2} \\exp\\left(-\\beta\\left(\\left(-\\frac{L}{2}\\right)^2+y^2+z^2\\right)\\right) \\right]$$\n$$\\frac{\\partial n}{\\partial x}\\bigg|_{x=L/2} = -2\\alpha\\beta \\left[ \\frac{L}{2} \\exp\\left(-\\beta\\left(\\frac{L^2}{4}+y^2+z^2\\right)\\right) - \\frac{L}{2} \\exp\\left(-\\beta\\left(\\frac{L^2}{4}+y^2+z^2\\right)\\right) \\right]$$\n$$\\frac{\\partial n}{\\partial x}\\bigg|_{x=L/2} = -2\\alpha\\beta [0] = 0$$\nSince this result holds for any values of $y$ and $z$, the condition $\\frac{\\partial n}{\\partial x}=0$ is satisfied for all points on the plane $x=L/2$. Therefore, the plane $x=L/2$ is indeed the zero-flux dividing surface between the two atomic basins. Note that this result is independent of the parameters $\\alpha$ and $\\beta$.\n\nThe problem asks for the location $x^{\\star}$ of the dividing surface along the internuclear axis (the $x$-axis). This is the $x$-coordinate of the point where the surface $x=L/2$ intersects the $x$-axis. This intersection occurs at $x=L/2$.\nThus, $x^{\\star} = L/2$.\n\nGiven the internuclear distance $L = 2.986$ Å, we can calculate the numerical value of $x^{\\star}$:\n$$x^{\\star} = \\frac{2.986}{2} = 1.493$$\nThe value is in units of Å. The problem requires the answer to be rounded to four significant figures. The calculated value $1.493$ already has four significant figures.\nSo, the location of the dividing surface along the internuclear axis is $x^{\\star} = 1.493$ Å.",
            "answer": "$$\\boxed{1.493}$$"
        },
        {
            "introduction": "Beyond assigning atomic charges, topological analysis can be extended to quantify the nature of chemical bonds through bond order metrics. This exercise  explores the Crystal Orbital Hamilton Population (COHP), a powerful tool for discerning bonding, non-bonding, and anti-bonding interactions in periodic systems like catalytic surfaces. You will implement a model to investigate how the integrated COHP (ICOHP) converges with respect to Brillouin Zone sampling, a critical and practical skill in computational materials science.",
            "id": "3869077",
            "problem": "You are given a model problem to assess the convergence of the Crystal Orbital Hamilton Population (COHP) and Integrated COHP (ICOHP) with respect to Brillouin Zone (BZ) sampling density for a two-dimensional surface–adsorbate system. The task is to implement a program that, for several specified parameter sets, determines the smallest number of $k$-points along each reciprocal lattice direction (i.e., the minimal mesh size) at which the ICOHP is converged according to a prescribed criterion.\n\nThe fundamental base consists of the following definitions and well-tested facts:\n- The $k$-space integral of a quantity over the Brillouin Zone (BZ) in periodic systems is defined as an average over the BZ domain. For a two-dimensional crystal, the first Brillouin Zone can be parameterized as a square domain $[-\\pi,\\pi]\\times[-\\pi,\\pi]$ with total area $A_{\\mathrm{BZ}} = (2\\pi)^2$, where angles are measured in radians.\n- The Riemann sum using a uniform grid with $N\\times N$ points and spacing $\\Delta k = \\frac{2\\pi}{N}$ at midpoints $k_x(i) = -\\pi + \\left(i + \\tfrac{1}{2}\\right)\\Delta k$, $k_y(j) = -\\pi + \\left(j + \\tfrac{1}{2}\\right)\\Delta k$ for $i,j \\in \\{0,\\dots,N-1\\}$ is a consistent approximation to the BZ integral. The discrete average equals the continuum average for uniform sampling in the limit $N\\to\\infty$.\n- The COHP at energy $E$ and wavevector $\\mathbf{k}=(k_x,k_y)$ is modeled as $ \\mathrm{COHP}(E,\\mathbf{k}) = -S\\,g(\\mathbf{k})\\,G\\!\\left(E - E_b(\\mathbf{k}); \\sigma\\right)$, where $S$ is a positive energy scale, $g(\\mathbf{k})$ is a dimensionless bond-weight factor, $E_b(\\mathbf{k})$ is a single-band dispersion, and $G(x;\\sigma)$ is a normalized Gaussian $G(x;\\sigma) = \\frac{1}{\\sqrt{2\\pi}\\,\\sigma}\\exp\\!\\left(-\\frac{x^2}{2\\sigma^2}\\right)$ representing physically motivated broadening of discrete levels. The Integrated COHP (ICOHP) up to Fermi energy $E_F$ is the energy integral of the COHP:\n$$\n\\mathrm{ICOHP}(E_F) = \\frac{1}{A_{\\mathrm{BZ}}}\\int_{\\mathrm{BZ}}\\left[\\int_{-\\infty}^{E_F} \\mathrm{COHP}(E,\\mathbf{k})\\,\\mathrm{d}E\\right]\\mathrm{d}^2\\mathbf{k}.\n$$\nAll energies must be expressed in electronvolts (eV).\n\nFor this problem, use the following specific model:\n- The band dispersion is $E_b(\\mathbf{k}) = E_0 + t\\left[\\cos(k_x) + \\cos(k_y)\\right]$.\n- The bond-weight factor is $g(\\mathbf{k}) = \\cos(k_x)\\cos(k_y) + \\alpha$.\n- The broadening $G(x;\\sigma)$ is as defined above, with width $\\sigma$.\n- The integrated energy variable is the Fermi energy $E_F$.\n\nFor a given $N$, approximate $\\mathrm{ICOHP}_N(E_F)$ using the midpoint Riemann sum over the $N\\times N$ uniform grid on $[-\\pi,\\pi]^2$:\n$$\n\\mathrm{ICOHP}_N(E_F) \\approx \\frac{1}{N^2}\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\left[-S\\,g\\!\\left(k_x(i),k_y(j)\\right)\\,\\Phi\\!\\left(\\frac{E_F - E_b\\!\\left(k_x(i),k_y(j)\\right)}{\\sigma}\\right)\\right],\n$$\nwhere $\\Phi(z) = \\tfrac{1}{2}\\left[1+\\mathrm{erf}\\!\\left(\\tfrac{z}{\\sqrt{2}}\\right)\\right]$ is the cumulative distribution function of a unit-variance Gaussian, and $\\mathrm{erf}(\\cdot)$ is the Gauss error function. Note that the Gaussian $G$ is normalized, so this energy integration yields the cumulative factor $\\Phi$.\n\nConvergence criterion:\n- Let $\\{N_\\ell\\}$ be an ascending sequence of mesh sizes. Define $I_\\ell = \\mathrm{ICOHP}_{N_\\ell}(E_F)$ in eV. For a user-specified tolerance $\\varepsilon$ (in eV), declare convergence at index $\\ell$ if $\\left|I_{\\ell} - I_{\\ell-1}\\right| \\le \\varepsilon$ for some $\\ell \\ge 1$. The minimal converged mesh size is then $N_\\ell$. If no such $\\ell$ exists within the provided sequence, report $-1$.\n\nAngles for $k_x$ and $k_y$ must be in radians. Energies and tolerances must be in electronvolts (eV).\n\nConstants to use across all test cases:\n- $S = 2.0$ eV,\n- $\\alpha = 0.15$ (dimensionless),\n- Mesh sequence $\\{N_\\ell\\} = \\{\\,4,\\,6,\\,8,\\,12,\\,16,\\,24,\\,32,\\,48,\\,64,\\,96\\,\\}$.\n\nTest suite:\n- Case $1$ (smooth band occupation): $E_0 = -5.0$ eV, $t = 1.0$ eV, $E_F = -5.0$ eV, $\\sigma = 0.30$ eV, $\\varepsilon = 1\\times 10^{-3}$ eV.\n- Case $2$ (sharp features in energy occupation): $E_0 = -5.0$ eV, $t = 1.0$ eV, $E_F = -5.0$ eV, $\\sigma = 0.020$ eV, $\\varepsilon = 1\\times 10^{-3}$ eV.\n- Case $3$ (Fermi level near band edge): $E_0 = -5.0$ eV, $t = 1.0$ eV, $E_F = -6.90$ eV, $\\sigma = 0.050$ eV, $\\varepsilon = 1\\times 10^{-3}$ eV.\n- Case $4$ (flat band edge case): $E_0 = -5.0$ eV, $t = 0.0$ eV, $E_F = -5.0$ eV, $\\sigma = 0.10$ eV, $\\varepsilon = 1\\times 10^{-6}$ eV.\n\nYour program must:\n- Implement the above model and compute $\\mathrm{ICOHP}_N(E_F)$ for each $N$ in the specified sequence and for each test case.\n- Determine the minimal $N$ satisfying the convergence criterion for each case (or $-1$ if not achieved).\n- Produce a single line of output containing the four results as a comma-separated list of integers enclosed in square brackets, e.g., $[n_1,n_2,n_3,n_4]$.\n\nAll angles must be treated in radians, and all energies and tolerances must be in electronvolts (eV). The final outputs for the test cases must be integers as described above, and the program must not read any input.",
            "solution": "The problem statement submitted for consideration is valid. It is scientifically grounded, well-posed, objective, and internally consistent, meeting all criteria for a solvable scientific problem.\n\nThe task is to determine the minimum Brillouin Zone (BZ) sampling density, represented by an $N \\times N$ grid of $k$-points, for which the Integrated Crystal Orbital Hamilton Population ($\\mathrm{ICOHP}$) converges to a specified tolerance $\\varepsilon$. This is a standard procedure in computational materials science and solid-state physics to ensure numerical results are independent of the BZ discretization.\n\nThe solution proceeds by first implementing a function to calculate the $\\mathrm{ICOHP}$ for a given mesh size $N$ and then applying a convergence test for a sequence of increasing $N$.\n\nThe fundamental quantity is the $\\mathrm{ICOHP}$, defined as the BZ-averaged, energy-integrated $\\mathrm{COHP}$:\n$$\n\\mathrm{ICOHP}(E_F) = \\frac{1}{A_{\\mathrm{BZ}}}\\int_{\\mathrm{BZ}}\\left[\\int_{-\\infty}^{E_F} \\mathrm{COHP}(E,\\mathbf{k})\\,\\mathrm{d}E\\right]\\mathrm{d}^2\\mathbf{k}\n$$\nThe problem provides a specific model for the $\\mathrm{COHP}(E, \\mathbf{k})$ and simplifies the energy integral. The integral of the Gaussian broadening function $G(x; \\sigma) = \\frac{1}{\\sqrt{2\\pi}\\,\\sigma}\\exp(-\\frac{x^2}{2\\sigma^2})$ from $-\\infty$ to a value $X$ is its cumulative distribution function (CDF), which is given by $\\Phi(X/\\sigma)$, where $\\Phi(z) = \\frac{1}{2}[1+\\mathrm{erf}(\\frac{z}{\\sqrt{2}})]$. Applying this, the inner energy integral becomes:\n$$\n\\int_{-\\infty}^{E_F} \\mathrm{COHP}(E,\\mathbf{k})\\,\\mathrm{d}E = -S\\,g(\\mathbf{k})\\,\\Phi\\!\\left(\\frac{E_F - E_b(\\mathbf{k})}{\\sigma}\\right)\n$$\nThe BZ integral is then approximated by a Riemann sum over a uniform $N \\times N$ grid of midpoints. The area of the BZ is $A_{\\mathrm{BZ}} = (2\\pi)^2$. For a uniform grid of $N \\times N$ points, the area element per point is $\\Delta k_x \\Delta k_y = (\\frac{2\\pi}{N})^2$. The BZ-averaged integral becomes a simple arithmetic mean over the grid points:\n$$\n\\mathrm{ICOHP}_N(E_F) \\approx \\frac{1}{N^2}\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\left[-S\\,g\\!\\left(k_x(i),k_y(j)\\right)\\,\\Phi\\!\\left(\\frac{E_F - E_b\\!\\left(k_x(i),k_y(j)\\right)}{\\sigma}\\right)\\right]\n$$\nThis is the expression to be implemented. The $k$-points are defined as $k_x(i) = -\\pi + (i + \\frac{1}{2})\\Delta k$ and $k_y(j) = -\\pi + (j + \\frac{1}{2})\\Delta k$, where $\\Delta k = \\frac{2\\pi}{N}$. The model functions for dispersion $E_b(\\mathbf{k}) = E_0 + t[\\cos(k_x) + \\cos(k_y)]$ and bond-weighting $g(\\mathbf{k}) = \\cos(k_x)\\cos(k_y) + \\alpha$ are substituted into this formula.\n\nThe computational algorithm is structured as follows:\n1.  Define a function, `calculate_icohp`, that takes the mesh size $N$ and the physical parameters $(E_0, t, E_F, \\sigma, S, \\alpha)$ as input. This function will perform the following steps:\n    a.  Generate the $1$D array of $k$-points for one dimension using the midpoint rule, from $-\\pi$ to $\\pi$.\n    b.  Use a grid generation function (`numpy.meshgrid`) to create the $2$D $k_x$ and $k_y$ arrays for the entire BZ.\n    c.  Calculate the band dispersion $E_b(\\mathbf{k})$ and bond-weight factor $g(\\mathbf{k})$ for every point on the grid in a vectorized manner.\n    d.  Compute the argument of the CDF, $z(\\mathbf{k}) = (E_F - E_b(\\mathbf{k}))/\\sigma$.\n    e.  Evaluate the CDF, $\\Phi(z(\\mathbf{k}))$, using the provided error function `scipy.special.erf`.\n    f.  Combine all terms to compute the summand for each $\\mathbf{k}$-point: $-S \\cdot g(\\mathbf{k}) \\cdot \\Phi(z(\\mathbf{k}))$.\n    g.  Sum the contributions from all points and divide by $N^2$ to obtain $\\mathrm{ICOHP}_N(E_F)$.\n\n2.  For each test case, iterate through the specified sequence of mesh sizes $\\{N_\\ell\\} = \\{4, 6, 8, \\dots, 96\\}$.\n    a.  Initialize the loop by calculating the $\\mathrm{ICOHP}$ for the first mesh size, $N_0 = 4$. Let this be $I_0$.\n    b.  For each subsequent mesh size $N_\\ell$ (for $\\ell = 1, 2, \\dots$), calculate the corresponding $\\mathrm{ICOHP}$ value, $I_\\ell$.\n    c.  Check the convergence criterion: $|\\,I_\\ell - I_{\\ell-1}\\,| \\le \\varepsilon$.\n    d.  If the criterion is satisfied, the minimal converged mesh size is $N_\\ell$. Record this value and terminate the search for the current test case.\n    e.  If the criterion is not met, update the previous value, $I_{\\ell-1} \\leftarrow I_\\ell$, and proceed to the next mesh size.\n    f.  If the end of the sequence is reached without convergence, a value of $-1$ is recorded for that test case, as specified.\n\n3.  A special case arises when the hopping parameter $t=0$ (Case 4). The band is flat: $E_b(\\mathbf{k}) = E_0$. Consequently, the CDF term $\\Phi(\\dots)$ becomes a constant across the BZ. The $\\mathrm{ICOHP}_N$ expression simplifies to the BZ average of $-S \\cdot g(\\mathbf{k})$ multiplied by this constant. The BZ average of $g(\\mathbf{k}) = \\cos(k_x)\\cos(k_y) + \\alpha$ over a symmetric midpoint grid for even $N$ is exactly $\\alpha$, because the average of $\\cos(k_x)$ and $\\cos(k_y)$ is zero. Thus, for Case 4, $\\mathrm{ICOHP}_N$ is independent of $N$. The difference $|I_\\ell - I_{\\ell-1}|$ is identically zero, so convergence is met at the first check (i.e., for $\\ell=1$), yielding the minimal converged mesh size $N_1 = 6$.\n\nThe results from all four test cases are collected into a list and formatted as a single-line string for output. This procedure is deterministic and directly implements the physics and numerical methods described in the problem.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import erf\n\ndef solve():\n    \"\"\"\n    Calculates the minimal converged k-point mesh size for ICOHP\n    based on a model 2D system for several test cases.\n    \"\"\"\n\n    def calculate_icohp(N, E0, t, EF, sigma, S, alpha):\n        \"\"\"\n        Calculates ICOHP_N(EF) using a Riemann sum over an N x N k-point grid.\n\n        Args:\n            N (int): The number of k-points along one dimension of the BZ.\n            E0 (float): Constant energy offset in eV.\n            t (float): Hopping parameter in eV.\n            EF (float): Fermi energy in eV.\n            sigma (float): Gaussian broadening width in eV.\n            S (float): Energy scale constant in eV.\n            alpha (float): Dimensionless bond-weight constant.\n\n        Returns:\n            float: The calculated ICOHP value in eV.\n        \"\"\"\n        # A flat band (t=0) with symmetric k-sampling results in a constant ICOHP\n        # that is independent of N. The average of cos(kx)cos(ky) over the grid is 0.\n        # The average of g(k) is then just alpha.\n        if t == 0.0:\n            z = (EF - E0) / sigma\n            phi = 0.5 * (1.0 + erf(z / np.sqrt(2)))\n            return -S * alpha * phi\n            \n        # Create k-point grid using the midpoint rule on [-pi, pi]\n        delta_k = 2.0 * np.pi / N\n        k_pts_1d = -np.pi + (np.arange(N) + 0.5) * delta_k\n        kx, ky = np.meshgrid(k_pts_1d, k_pts_1d)\n\n        # Calculate band dispersion for each k-point\n        # E_b(k) = E0 + t * [cos(kx) + cos(ky)]\n        E_b = E0 + t * (np.cos(kx) + np.cos(ky))\n\n        # Calculate bond-weight factor for each k-point\n        # g(k) = cos(kx)cos(ky) + alpha\n        g = np.cos(kx) * np.cos(ky) + alpha\n\n        # Calculate the argument for the cumulative distribution function (CDF)\n        z = (EF - E_b) / sigma\n\n        # Calculate the CDF of the standard normal distribution\n        # Phi(z) = 0.5 * [1 + erf(z / sqrt(2))]\n        phi = 0.5 * (1.0 + erf(z / np.sqrt(2.0)))\n\n        # Sum the contributions from all k-points\n        # The sum is divided by N^2 to get the average over the BZ.\n        icohp_sum = np.sum(-S * g * phi)\n        icohp_N = icohp_sum / (N * N)\n\n        return icohp_N\n\n    # Global constants defined in the problem\n    S = 2.0\n    alpha = 0.15\n    N_sequence = [4, 6, 8, 12, 16, 24, 32, 48, 64, 96]\n\n    # Test suite parameters: (E0, t, EF, sigma, epsilon)\n    test_cases = [\n        (-5.0, 1.0, -5.0, 0.30,  1e-3),   # Case 1: smooth band occupation\n        (-5.0, 1.0, -5.0, 0.020, 1e-3),   # Case 2: sharp features in energy occupation\n        (-5.0, 1.0, -6.90, 0.050, 1e-3),   # Case 3: Fermi level near band edge\n        (-5.0, 0.0, -5.0, 0.10,  1e-6),   # Case 4: flat band edge case\n    ]\n\n    final_results = []\n\n    for case_params in test_cases:\n        E0, t, EF, sigma, epsilon = case_params\n        converged_N = -1\n        \n        # Calculate ICOHP for the first mesh size N_0\n        prev_icohp = calculate_icohp(N_sequence[0], E0, t, EF, sigma, S, alpha)\n\n        # Iterate through the rest of the mesh sequence to check for convergence\n        for i in range(1, len(N_sequence)):\n            N_current = N_sequence[i]\n            current_icohp = calculate_icohp(N_current, E0, t, EF, sigma, S, alpha)\n            \n            # Convergence criterion: |I_l - I_{l-1}| = epsilon\n            if abs(current_icohp - prev_icohp) = epsilon:\n                converged_N = N_current\n                break  # Minimal converged N found, move to the next test case\n\n            prev_icohp = current_icohp\n\n        final_results.append(converged_N)\n\n    # Produce the single line of output in the required format\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Different population analysis schemes can yield quantitatively different atomic charges, and understanding these discrepancies is crucial for robust interpretation. This capstone practice  challenges you to implement and compare three widely used methods—Mulliken, Hirshfeld, and Bader analysis—for a methane molecule. By building the numerical tools for grid-based integration and gradient ascent pathfinding, you will gain deep insight into the theoretical assumptions and practical nuances that distinguish these charge partitioning schemes.",
            "id": "3869040",
            "problem": "Consider the methane molecule modeled as five atom-centered, normalized, $s$-type Gaussian basis functions located at a carbon nucleus and four hydrogen nuclei arranged in a tetrahedral geometry. Let the carbon be at the origin and the four hydrogens be located at a carbon–hydrogen bond distance of $1.09\\,\\mathrm{\\AA}$ placed at the vertices of a regular tetrahedron along directions $(1,1,1)$, $(1,-1,-1)$, $(-1,1,-1)$, $(-1,-1,1)$ normalized to the specified bond length. Each atomic orbital basis function is defined as $\\chi_{\\mu}(\\mathbf{r}) = N(\\alpha_{\\mu}) \\exp\\big(-\\alpha_{\\mu} \\lVert \\mathbf{r} - \\mathbf{R}_{\\mu} \\rVert^2\\big)$ with normalization constant $N(\\alpha) = \\left(\\dfrac{2\\alpha}{\\pi}\\right)^{3/4}$ so that $\\int \\chi_{\\mu}^2(\\mathbf{r})\\,d^3\\mathbf{r} = 1$. Assume valence-only electrons: $4$ for carbon and $1$ for each hydrogen, totaling $8$ electrons.\n\nYou are to implement a program that, for each specified parameter set, constructs:\n- The $5\\times 5$ atomic orbital overlap matrix $S$ with elements $S_{\\mu\\nu} = \\int \\chi_{\\mu}(\\mathbf{r}) \\chi_{\\nu}(\\mathbf{r})\\,d^3\\mathbf{r}$ using the analytical formula for overlaps of normalized $s$-type Gaussians:\n$$\nS_{\\mu\\nu} = \\left(\\frac{2\\sqrt{\\alpha_{\\mu}\\alpha_{\\nu}}}{\\alpha_{\\mu}+\\alpha_{\\nu}}\\right)^{3/2}\\exp\\left(-\\frac{\\alpha_{\\mu}\\alpha_{\\nu}}{\\alpha_{\\mu}+\\alpha_{\\nu}} \\lVert \\mathbf{R}_{\\mu}-\\mathbf{R}_{\\nu}\\rVert^2\\right).\n$$\n- A set of four occupied molecular orbitals in the orthonormalized atomic orbital space built from an orthonormal $5\\times 4$ coefficient matrix $M$ whose first column is the totally symmetric combination $m_0 \\propto \\big[w_C,\\,w_H/2,\\,w_H/2,\\,w_H/2,\\,w_H/2\\big]^T$, and the remaining three columns are mutually orthonormal linear combinations of hydrogen basis vectors with zero sum of hydrogen components (thus orthogonal to $m_0$). The orthonormalization must be with respect to the identity metric, not $S$. Symmetric orthogonalization is then used to return to the atomic orbital basis: if $S = U\\Lambda U^T$, define $X = U\\Lambda^{-1/2}U^T$, and the atomic orbital molecular orbital coefficient matrix is $C = X M$ satisfying $C^T S C = I_4$.\n- The closed-shell density matrix in the atomic orbital basis is $P = 2 C C^T$ with trace in the $S$-metric equal to the number of electrons in the model, i.e., $\\operatorname{Tr}(P S) = 8$.\n\nUsing these, compute three kinds of atomic charges for carbon and hydrogen:\n1. Mulliken charges: The Mulliken gross atomic population for atom $A$ is \n$$\nN_A^{\\mathrm{M}} = \\sum_{\\mu \\in A} (P S)_{\\mu\\mu},\n$$\nand the Mulliken atomic charge is $q_A^{\\mathrm{M}} = Z_A^{\\mathrm{val}} - N_A^{\\mathrm{M}}$, where $Z_C^{\\mathrm{val}} = 4$ and $Z_H^{\\mathrm{val}} = 1$.\n2. Hirshfeld charges: Define a model molecular electron density \n$$\n\\rho(\\mathbf{r}) = \\sum_{\\mu\\nu} P_{\\mu\\nu} \\chi_{\\mu}(\\mathbf{r}) \\chi_{\\nu}(\\mathbf{r}),\n$$\nand pro-atom reference densities for neutral valence shells \n$$\n\\rho_A^0(\\mathbf{r}) = Z_A^{\\mathrm{val}}\\, g_A(\\mathbf{r}),\\quad g_A(\\mathbf{r}) = \\left(\\frac{2\\beta_A}{\\pi}\\right)^{3/2} \\exp\\left(-2\\beta_A \\lVert \\mathbf{r}-\\mathbf{R}_A\\rVert^2\\right),\n$$\nwhere $g_A$ is normalized to integrate to $1$ and $\\beta_A$ is the pro-atom Gaussian exponent for atom $A$. The Hirshfeld weight is \n$$\nw_A(\\mathbf{r}) = \\frac{\\rho_A^0(\\mathbf{r})}{\\sum_B \\rho_B^0(\\mathbf{r})},\n$$\nand the Hirshfeld atom population is \n$$\nN_A^{\\mathrm{H}} = \\int \\rho(\\mathbf{r}) w_A(\\mathbf{r})\\, d^3\\mathbf{r},\n$$\nwith Hirshfeld charge $q_A^{\\mathrm{H}} = Z_A^{\\mathrm{val}} - N_A^{\\mathrm{H}}$.\n3. Bader charges via zero-flux partitioning in the gradient of $\\rho(\\mathbf{r})$: The Bader basin of atom $A$ is the set of points such that steepest-ascent trajectories of $\\rho(\\mathbf{r})$ terminate at the local maximum associated with nucleus $A$, satisfying the zero-flux condition $\\nabla \\rho(\\mathbf{r}) \\cdot \\mathbf{n}(\\mathbf{r}) = 0$ on interatomic surfaces, where $\\mathbf{n}(\\mathbf{r})$ is the surface normal. Numerically, approximate this by assigning each grid point to an atom via discrete gradient ascent updates \n$$\n\\mathbf{r}_{k+1} = \\mathbf{r}_k + s \\frac{\\nabla \\rho(\\mathbf{r}_k)}{\\lVert \\nabla \\rho(\\mathbf{r}_k) \\rVert},\n$$\nuntil convergence to within a small distance of one nucleus or until a maximum number of steps is reached; then integrate the density in each basin:\n$$\nN_A^{\\mathrm{B}} = \\int_{\\Omega_A} \\rho(\\mathbf{r})\\, d^3\\mathbf{r}, \\quad q_A^{\\mathrm{B}} = Z_A^{\\mathrm{val}} - N_A^{\\mathrm{B}}.\n$$\n\nImplement the following numerical protocol to ensure reproducibility and universality:\n- Use a uniform cubic grid of points covering the cube $[-3.0,3.0]\\,\\mathrm{\\AA}$ in each dimension with spacing $\\Delta x = \\Delta y = \\Delta z = 0.5\\,\\mathrm{\\AA}$ for all real-space integrations. Use the midpoint rule. The voxel volume is $dV = \\Delta x\\, \\Delta y\\, \\Delta z$.\n- For gradient ascent, use a fixed step size $s = 0.2\\,\\mathrm{\\AA}$, terminate if the distance to any nucleus is less than $0.3\\,\\mathrm{\\AA}$ or if the gradient norm is less than $10^{-8}$, or after $60$ steps, whichever occurs first. If the initial density at a grid point is less than $10^{-9}$, you may directly assign that point to the nearest nucleus to avoid unnecessary iterations.\n- To mitigate finite-box quadrature error, rescale the numerically integrated total electron density so that the integrated electron count matches $8$ exactly before computing Hirshfeld and Bader populations. That is, compute $N_{\\mathrm{box}} = \\sum_i \\rho(\\mathbf{r}_i) dV$ on the grid, and use $\\tilde{\\rho}(\\mathbf{r}_i) = \\rho(\\mathbf{r}_i)\\cdot \\left(8/N_{\\mathrm{box}}\\right)$ for all subsequent grid-based partitions.\n\nTest suite:\nFor each parameter set, you are provided the atomic orbital exponents $\\alpha_C$ and $\\alpha_H$, the orthonormal molecular orbital mixing weights $w_C$ and $w_H$ for the symmetric combination, and the pro-atom exponents $\\beta_C$ and $\\beta_H$. Hydrogens share the same exponents. Use the given tetrahedral geometry with carbon at the origin and hydrogens at distance $1.09\\,\\mathrm{\\AA}$ from carbon.\n\n- Case 1 (balanced): $(\\alpha_C,\\alpha_H,w_C,w_H,\\beta_C,\\beta_H) = (0.8,\\,1.2,\\,0.8,\\,0.6,\\,0.7,\\,1.0)$.\n- Case 2 (hydrogen overlocalized basis): $(\\alpha_C,\\alpha_H,w_C,w_H,\\beta_C,\\beta_H) = (0.6,\\,2.0,\\,0.7,\\,0.6,\\,0.7,\\,1.2)$.\n- Case 3 (diffuse functions): $(\\alpha_C,\\alpha_H,w_C,w_H,\\beta_C,\\beta_H) = (0.3,\\,0.4,\\,0.8,\\,0.4,\\,0.5,\\,0.7)$.\n\nFor each case, compute:\n- Carbon Mulliken charge $q_C^{\\mathrm{M}}$ and average hydrogen Mulliken charge $\\bar{q}_H^{\\mathrm{M}}$,\n- Carbon Hirshfeld charge $q_C^{\\mathrm{H}}$ and average hydrogen Hirshfeld charge $\\bar{q}_H^{\\mathrm{H}}$,\n- Carbon Bader charge $q_C^{\\mathrm{B}}$ and average hydrogen Bader charge $\\bar{q}_H^{\\mathrm{B}}$.\n\nAll charges must be expressed as decimal floats in units of the elementary charge $e$ (unitless number measured in $e$) and rounded to three digits after the decimal point. Your program should produce a single line of output containing the results for all cases as a flat, comma-separated list enclosed in square brackets in the order:\n$$\n\\big[q_C^{\\mathrm{M}}(1),\\,\\bar{q}_H^{\\mathrm{M}}(1),\\,q_C^{\\mathrm{H}}(1),\\,\\bar{q}_H^{\\mathrm{H}}(1),\\,q_C^{\\mathrm{B}}(1),\\,\\bar{q}_H^{\\mathrm{B}}(1),\\,q_C^{\\mathrm{M}}(2),\\,\\bar{q}_H^{\\mathrm{M}}(2),\\,\\ldots,\\,q_C^{\\mathrm{B}}(3),\\,\\bar{q}_H^{\\mathrm{B}}(3)\\big].\n$$\nIn parentheses, the case index is indicated. Angles are not used in this problem. Ensure numeric stability and scientific realism by adhering to the definitions and constraints above, without introducing any external data or files.",
            "solution": "The user-provided problem statement is a well-defined computational exercise in quantum chemistry. It requires the implementation of algorithms to calculate three different types of atomic charges (Mulliken, Hirshfeld, and Bader) for a simplified model of a methane molecule.\n\n### Step 1: Extract Givens\n\n- **Molecular Geometry**: A carbon atom is at the origin $\\mathbf{R}_C = (0,0,0)$. Four hydrogen atoms are at a distance $d_{CH} = 1.09\\,\\mathrm{\\AA}$ from the carbon, along the directions $(1,1,1)$, $(1,-1,-1)$, $(-1,1,-1)$, and $(-1,-1,1)$.\n- **Basis Functions**: Five atom-centered, normalized, $s$-type Gaussian basis functions, $\\chi_{\\mu}(\\mathbf{r}) = N(\\alpha_{\\mu}) \\exp\\big(-\\alpha_{\\mu} \\lVert \\mathbf{r} - \\mathbf{R}_{\\mu} \\rVert^2\\big)$, with $N(\\alpha) = \\left(\\frac{2\\alpha}{\\pi}\\right)^{3/4}$.\n- **Valence Electrons**: $Z_C^{\\mathrm{val}} = 4$, $Z_H^{\\mathrm{val}} = 1$. Total electrons = $8$.\n- **Overlap Matrix Formula**: $S_{\\mu\\nu} = \\left(\\frac{2\\sqrt{\\alpha_{\\mu}\\alpha_{\\nu}}}{\\alpha_{\\mu}+\\alpha_{\\nu}}\\right)^{3/2}\\exp\\left(-\\frac{\\alpha_{\\mu}\\alpha_{\\nu}}{\\alpha_{\\mu}+\\alpha_{\\nu}} \\lVert \\mathbf{R}_{\\mu}-\\mathbf{R}_{\\nu}\\rVert^2\\right)$.\n- **Molecular Orbitals (MOs)**:\n    - An orthonormal $5\\times 4$ coefficient matrix $M$ is constructed in an orthonormal atomic orbital (OAO) space.\n    - The first column $m_0$ is proportional to $\\big[w_C,\\,w_H/2,\\,w_H/2,\\,w_H/2,\\,w_H/2\\big]^T$.\n    - The other three columns are mutually orthonormal, composed of hydrogen basis vectors, and have a zero sum of hydrogen components.\n    - MO coefficients in the atomic orbital (AO) basis are $C = X M$, where $X = S^{-1/2}$ is from symmetric orthogonalization of the overlap matrix $S$. The relation $C^T S C = I_4$ holds.\n- **Density Matrix**: $P = 2 C C^T$. The trace $\\operatorname{Tr}(P S) = 8$.\n- **Mulliken Charges**: $N_A^{\\mathrm{M}} = \\sum_{\\mu \\in A} (P S)_{\\mu\\mu}$, $q_A^{\\mathrm{M}} = Z_A^{\\mathrm{val}} - N_A^{\\mathrm{M}}$.\n- **Hirshfeld Charges**:\n    - Molecular density: $\\rho(\\mathbf{r}) = \\sum_{\\mu\\nu} P_{\\mu\\nu} \\chi_{\\mu}(\\mathbf{r}) \\chi_{\\nu}(\\mathbf{r})$.\n    - Pro-atom density: $\\rho_A^0(\\mathbf{r}) = Z_A^{\\mathrm{val}}\\, g_A(\\mathbf{r})$, where $g_A(\\mathbf{r}) = \\left(\\frac{2\\beta_A}{\\pi}\\right)^{3/2} \\exp\\left(-2\\beta_A \\lVert \\mathbf{r}-\\mathbf{R}_A\\rVert^2\\right)$.\n    - Hirshfeld population: $N_A^{\\mathrm{H}} = \\int \\rho(\\mathbf{r}) \\frac{\\rho_A^0(\\mathbf{r})}{\\sum_B \\rho_B^0(\\mathbf{r})}\\, d^3\\mathbf{r}$.\n    - Hirshfeld charge: $q_A^{\\mathrm{H}} = Z_A^{\\mathrm{val}} - N_A^{\\mathrm{H}}$.\n- **Bader Charges**:\n    - Basins $\\Omega_A$ are determined by zero-flux surfaces of $\\nabla \\rho(\\mathbf{r})$.\n    - Numerically found by gradient ascent: $\\mathbf{r}_{k+1} = \\mathbf{r}_k + s \\frac{\\nabla \\rho(\\mathbf{r}_k)}{\\lVert \\nabla \\rho(\\mathbf{r}_k) \\rVert}$.\n    - Population: $N_A^{\\mathrm{B}} = \\int_{\\Omega_A} \\rho(\\mathbf{r})\\, d^3\\mathbf{r}$, Charge: $q_A^{\\mathrm{B}} = Z_A^{\\mathrm{val}} - N_A^{\\mathrm{B}}$.\n- **Numerical Protocol**:\n    - Grid: Cube from $[-3.0, 3.0]\\,\\mathrm{\\AA}$ in each dimension, spacing $\\Delta x = \\Delta y = \\Delta z = 0.5\\,\\mathrm{\\AA}$.\n    - Integration: Midpoint rule with voxel volume $dV = (0.5)^3\\,\\mathrm{\\AA}^3$.\n    - Density Renormalization: The numerically integrated density $\\int_{\\text{box}} \\rho(\\mathbf{r})\\,d^3\\mathbf{r}$ is rescaled to equal $8$ before computing Hirshfeld and Bader populations.\n    - Gradient Ascent: Step size $s = 0.2\\,\\mathrm{\\AA}$. Termination criteria: distance to a nucleus $ 0.3\\,\\mathrm{\\AA}$, gradient norm $ 10^{-8}$, or $60$ steps.\n    - Low-density assignment: If $\\rho(\\mathbf{r}_i)  10^{-9}$, assign grid point $\\mathbf{r}_i$ to the nearest nucleus.\n- **Test Cases**:\n    - Case 1: $(\\alpha_C,\\alpha_H,w_C,w_H,\\beta_C,\\beta_H) = (0.8,\\,1.2,\\,0.8,\\,0.6,\\,0.7,\\,1.0)$.\n    - Case 2: $(\\alpha_C,\\alpha_H,w_C,w_H,\\beta_C,\\beta_H) = (0.6,\\,2.0,\\,0.7,\\,0.6,\\,0.7,\\,1.2)$.\n    - Case 3: $(\\alpha_C,\\alpha_H,w_C,w_H,\\beta_C,\\beta_H) = (0.3,\\,0.4,\\,0.8,\\,0.4,\\,0.5,\\,0.7)$.\n- **Output Format**: A single flat list of charges `[q_C^M(1), q_H^M(1), ..., q_H^B(3)]` rounded to three decimal places.\n\n### Step 2: Validate Using Extracted Givens\n\n- **Scientifically Grounded**: The problem is firmly rooted in the principles of computational quantum chemistry. The use of Gaussian basis functions, overlap matrices, density matrices, and various population analysis schemes (Mulliken, Hirshfeld, Bader) are standard concepts. The provided formulas are correct representations of these concepts within a simplified model.\n- **Well-Posed**: The problem is unambiguous. It provides all necessary parameters, constants, and a detailed numerical protocol. The construction of the molecular orbitals is explicitly defined, including the orthonormality conditions. The sequence of calculations is logical and leads to a unique, determinable set of results.\n- **Objective**: The language is entirely quantitative and formal, with no subjective or opinion-based statements.\n- **Completeness and Consistency**: The problem is self-contained. All required data for the three test cases are provided. The theoretical framework is internally consistent; for instance, the construction of the MOs and the density matrix correctly leads to a total electron count of $8$, matching the sum of valence electrons.\n- **Feasibility**: The calculation, while computationally intensive (particularly the Bader analysis), is perfectly feasible on modern hardware within a reasonable time frame. The specified model and parameters are physically plausible for a pedagogical example.\n\n### Step 3: Verdict and Action\n\nThe problem is **valid**. It is a well-posed, scientifically grounded, and objective computational task. I will proceed with providing a complete solution.\n\n### Solution\n\nThe solution is implemented by following the sequence of operations specified in the problem statement. The architecture of the code is designed to be modular, with distinct functions handling each major step of the calculation for clarity and correctness.\n\n1.  **System Setup**: The methane geometry is first established with the carbon atom at the origin and four hydrogen atoms placed tetrahedrally at the specified bond distance of $1.09\\,\\mathrm{\\AA}$.\n\n2.  **Matrix Construction**:\n    - The $5 \\times 5$ atomic orbital **overlap matrix** $S$ is computed using the provided analytical formula for $s$-type Gaussian overlaps.\n    - The $5 \\times 4$ **orthonormal MO coefficient matrix** $M$ (in the OAO basis) is constructed. Its first column, representing the totally symmetric bonding orbital, is formed from the given weights $w_C$ and $w_H$ and then normalized. The remaining three columns are constructed to be mutually orthonormal, lie within the subspace of the hydrogen basis functions, and be orthogonal to the first MO, satisfying the \"zero-sum of hydrogen components\" rule.\n    - The **symmetric orthogonalization matrix** $X = S^{-1/2}$ is calculated by diagonalizing $S$ ($S = U\\Lambda U^T$), taking the inverse square root of the eigenvalues ($\\Lambda^{-1/2}$), and transforming back ($X = U\\Lambda^{-1/2}U^T$).\n    - The **AO-basis MO coefficient matrix** is then $C = X M$.\n    - Finally, the **density matrix** is computed as $P = 2 C C^T$, where the factor of $2$ accounts for spin pairing in the four occupied orbitals.\n\n3.  **Mulliken Population Analysis**: This is a matrix-based calculation. The Mulliken gross atomic population on atom $A$ is the sum of the diagonal elements of the product matrix $PS$ corresponding to the basis functions on atom $A$. The charge is the difference between the valence electron count $Z_A^{\\mathrm{val}}$ and this population.\n\n4.  **Grid-Based Calculations (Hirshfeld and Bader)**:\n    - A uniform 3D grid is generated within the cube $[-3.0, 3.0]^3\\,\\mathrm{\\AA}^3$.\n    - The molecular electron density $\\rho(\\mathbf{r})$ is calculated at each grid point. A helper class `DensityHandler` is designed to efficiently compute $\\rho(\\mathbf{r})$ and its gradient $\\nabla\\rho(\\mathbf{r})$ at arbitrary points by pre-calculating terms from the Gaussian product rule.\n    - The total number of electrons within the grid volume is computed via numerical integration. The density is then uniformly rescaled such that the total integrated charge equals the exact number of electrons, $8$, to correct for finite grid errors. This rescaled density $\\tilde{\\rho}(\\mathbf{r})$ is used for all subsequent population analyses.\n\n5.  **Hirshfeld Charge Calculation**:\n    - The pro-atom densities $\\rho_A^0(\\mathbf{r})$ are calculated on the grid for each atom.\n    - The Hirshfeld weighting function $w_A(\\mathbf{r}) = \\rho_A^0(\\mathbf{r}) / \\sum_B \\rho_B^0(\\mathbf{r})$ is computed at each grid point.\n    - The Hirshfeld population $N_A^{\\mathrm{H}}$ is found by numerically integrating the molecular density $\\tilde{\\rho}(\\mathbf{r})$ weighted by $w_A(\\mathbf{r})$ over the grid. The charge $q_A^{\\mathrm{H}}$ follows.\n\n6.  **Bader Charge Calculation**:\n    - This is the most computationally intensive step. For each grid point, a discrete gradient ascent algorithm is performed on the density field $\\rho(\\mathbf{r})$.\n    - The trajectory starting from a grid point $\\mathbf{r}_i$ is followed until it terminates near a nucleus (a maximum of $\\rho$), its gradient becomes negligible, or a maximum number of steps is reached. The grid point is then assigned to the basin $\\Omega_A$ of the corresponding nucleus $A$.\n    - A special case handles low-density regions by assigning points with $\\rho  10^{-9}$ to the nearest nucleus without running the ascent algorithm.\n    - The Bader population $N_A^{\\mathrm{B}}$ is the sum of the rescaled density $\\tilde{\\rho}(\\mathbf{r}_i)$ over all grid points assigned to basin $\\Omega_A$, multiplied by the voxel volume $dV$. The charge $q_A^{\\mathrm{B}}$ is then computed.\n\nFinally, the computed charges for Carbon and the average for Hydrogen are collected for each test case, rounded to three decimal places, and formatted into the required output string. Due to symmetry, the charges on all four hydrogen atoms are identical, so the average is simply the charge on any one of them.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# --- Constants and Configuration ---\nD_CH = 1.09  # Angstrom\nZ_VAL = np.array([4.0, 1.0, 1.0, 1.0, 1.0])  # C, H1, H2, H3, H4\nNUM_ELECTRONS = 8.0\nGRID_BOUNDS = 3.0\nGRID_SPACING = 0.5\nASCENT_STEP_SIZE = 0.2\nASCENT_MAX_STEPS = 60\nASCENT_DIST_THRESH = 0.3\nASCENT_GRAD_THRESH = 1e-8\nDENSITY_CUTOFF = 1e-9\n\ndef get_methane_geometry():\n    \"\"\"Returns the 5x3 array of atomic coordinates for methane.\"\"\"\n    R = np.zeros((5, 3))\n    scale = D_CH / np.sqrt(3.0)\n    R[1, :] = scale * np.array([1.0, 1.0, 1.0])\n    R[2, :] = scale * np.array([1.0, -1.0, -1.0])\n    R[3, :] = scale * np.array([-1.0, 1.0, -1.0])\n    R[4, :] = scale * np.array([-1.0, -1.0, 1.0])\n    return R\n\ndef calculate_s_matrix(R, alphas):\n    \"\"\"Calculates the 5x5 atomic orbital overlap matrix S.\"\"\"\n    num_basis = len(alphas)\n    S = np.zeros((num_basis, num_basis))\n    for mu in range(num_basis):\n        for nu in range(mu, num_basis):\n            alpha_mu, alpha_nu = alphas[mu], alphas[nu]\n            R_mu, R_nu = R[mu], R[nu]\n            \n            dist_sq = np.sum((R_mu - R_nu)**2)\n            alpha_sum = alpha_mu + alpha_nu\n            \n            term1 = (2 * np.sqrt(alpha_mu * alpha_nu) / alpha_sum)**1.5\n            term2 = np.exp(-alpha_mu * alpha_nu * dist_sq / alpha_sum)\n            \n            s_val = term1 * term2\n            S[mu, nu] = S[nu, mu] = s_val\n    return S\n\ndef calculate_m_matrix(w_C, w_H):\n    \"\"\"Constructs the 5x4 orthonormal MO coefficient matrix M.\"\"\"\n    M = np.zeros((5, 4))\n    \n    # Column 0: Totally symmetric MO\n    v0 = np.array([w_C, w_H / 2, w_H / 2, w_H / 2, w_H / 2])\n    M[:, 0] = v0 / np.linalg.norm(v0)\n    \n    # Columns 1, 2, 3: Mutually orthonormal H-based MOs\n    c1 = np.array([1., 1., -1., -1.]) / 2.0\n    c2 = np.array([1., -1., 1., -1.]) / 2.0\n    c3 = np.array([1., -1., -1., 1.]) / 2.0\n    \n    M[1:, 1] = c1\n    M[1:, 2] = c2\n    M[1:, 3] = c3\n    \n    return M\n\nclass DensityHandler:\n    \"\"\"Calculates electron density and its gradient.\"\"\"\n    def __init__(self, P, R, alphas):\n        self.P = P\n        self.R = R\n        self.alphas = alphas\n        self.num_basis = len(alphas)\n        \n        self.norm_factors = (2 * self.alphas / np.pi)**0.75\n        self.precompute_terms()\n\n    def precompute_terms(self):\n        \"\"\"Precomputes terms for the Gaussian product rule.\"\"\"\n        self.gamma = np.add.outer(self.alphas, self.alphas)\n        \n        R_mu_w = self.alphas[:, np.newaxis] * self.R\n        self.Rp = (R_mu_w[:, np.newaxis, :] + R_mu_w[np.newaxis, :, :]) / self.gamma[..., np.newaxis]\n        \n        R_dist_sq = np.sum((self.R[:, np.newaxis, :] - self.R[np.newaxis, :, :])**2, axis=-1)\n        exp_term = np.exp(-(self.alphas[:, np.newaxis] * self.alphas) / self.gamma * R_dist_sq)\n        norm_prod = np.outer(self.norm_factors, self.norm_factors)\n        self.K = norm_prod * exp_term\n\n    def _get_gauss_prod(self, r_points):\n        r_points = np.atleast_2d(r_points) # Ensure (N,3)\n        # (N,1,1,3) - (1,M,M,3) - (N,M,M,3)\n        r_minus_Rp = r_points[:, np.newaxis, np.newaxis, :] - self.Rp[np.newaxis, ...]\n        dist_sq = np.sum(r_minus_Rp**2, axis=-1) # (N,M,M)\n        \n        # (1,M,M) * exp(-(1,M,M) * (N,M,M)) - (N,M,M)\n        gauss_prod_val = self.K[np.newaxis, ...] * np.exp(-self.gamma[np.newaxis, ...] * dist_sq)\n        return gauss_prod_val, r_minus_Rp\n\n    def rho(self, r_points):\n        gauss_prod_val, _ = self._get_gauss_prod(r_points)\n        # (1,M,M) * (N,M,M) - (N,M,M)\n        density_contrib = self.P[np.newaxis, ...] * gauss_prod_val\n        return np.sum(density_contrib, axis=(1, 2))\n\n    def grad_rho(self, r_points):\n        gauss_prod_val, r_minus_Rp = self._get_gauss_prod(r_points)\n\n        # (N,M,M,1) * (1,M,M,1) * (N,M,M,3) - (N,M,M,3)\n        grad_G = gauss_prod_val[..., np.newaxis] * (\n                   -2 * self.gamma[np.newaxis, ..., np.newaxis] * r_minus_Rp)\n        \n        # (1,M,M,1) * (N,M,M,3) - (N,M,M,3)\n        grad_rho_contrib = self.P[np.newaxis, ..., np.newaxis] * grad_G\n        return np.sum(grad_rho_contrib, axis=(1, 2))\n\ndef calculate_charges_for_case(params):\n    \"\"\"Main function to compute all charges for a single parameter set.\"\"\"\n    alpha_C, alpha_H, w_C, w_H, beta_C, beta_H = params\n    R = get_methane_geometry()\n    alphas = np.array([alpha_C] + [alpha_H] * 4)\n    betas = np.array([beta_C] + [beta_H] * 4)\n\n    # --- Step 1: Matrix Calculations and Mulliken Charges ---\n    S = calculate_s_matrix(R, alphas)\n    M = calculate_m_matrix(w_C, w_H)\n    \n    eigvals, eigvecs = np.linalg.eigh(S)\n    S_inv_sqrt = eigvecs @ np.diag(1.0 / np.sqrt(eigvals)) @ eigvecs.T\n    \n    C = S_inv_sqrt @ M\n    P = 2 * C @ C.T\n    \n    PS = P @ S\n    q_C_M = Z_VAL[0] - PS[0, 0]\n    q_H_M_avg = Z_VAL[1] - np.mean(np.diag(PS)[1:])\n\n    # --- Step 2: Grid Setup and Density Calculation ---\n    grid_1d = np.arange(GRID_BOUNDS, -GRID_BOUNDS - GRID_SPACING/2, -GRID_SPACING)[::-1]\n    grid_points = np.stack(np.meshgrid(grid_1d, grid_1d, grid_1d, indexing='ij'), axis=-1).reshape(-1, 3)\n    dV = GRID_SPACING**3\n    \n    density_calc = DensityHandler(P, R, alphas)\n    rho_on_grid = density_calc.rho(grid_points)\n    \n    total_electrons_in_box = np.sum(rho_on_grid) * dV\n    rho_tilde_on_grid = rho_on_grid * (NUM_ELECTRONS / total_electrons_in_box)\n\n    # --- Step 3: Hirshfeld Charges ---\n    pro_atom_densities = np.zeros((len(R), len(grid_points)))\n    for i in range(len(R)):\n        dist_sq = np.sum((grid_points - R[i])**2, axis=1)\n        g_A = (2 * betas[i] / np.pi)**1.5 * np.exp(-2 * betas[i] * dist_sq)\n        pro_atom_densities[i, :] = Z_VAL[i] * g_A\n        \n    pro_molecule_density = np.sum(pro_atom_densities, axis=0)\n    # Avoid division by zero in empty space\n    pro_molecule_density[pro_molecule_density  1e-12] = 1.0\n    \n    hirshfeld_weights = pro_atom_densities / pro_molecule_density[np.newaxis, :]\n    \n    N_H_all = np.sum(hirshfeld_weights * rho_tilde_on_grid, axis=1) * dV\n    q_H = Z_VAL - N_H_all\n    q_C_H = q_H[0]\n    q_H_H_avg = np.mean(q_H[1:])\n\n    # --- Step 4: Bader Charges ---\n    basin_assignments = -np.ones(len(grid_points), dtype=int)\n    \n    dist_to_nuclei = np.linalg.norm(grid_points[:, np.newaxis, :] - R[np.newaxis, :, :], axis=2)\n    nearest_nucleus = np.argmin(dist_to_nuclei, axis=1)\n    \n    for i in range(len(grid_points)):\n        if rho_on_grid[i]  DENSITY_CUTOFF:\n            basin_assignments[i] = nearest_nucleus[i]\n            continue\n            \n        r_current = grid_points[i]\n        \n        for _ in range(ASCENT_MAX_STEPS):\n            grad = density_calc.grad_rho(r_current)[0]\n            grad_norm = np.linalg.norm(grad)\n\n            if grad_norm  ASCENT_GRAD_THRESH:\n                break\n            \n            r_current = r_current + ASCENT_STEP_SIZE * grad / grad_norm\n            \n            dists = np.linalg.norm(r_current - R, axis=1)\n            if np.min(dists)  ASCENT_DIST_THRESH:\n                break\n        \n        basin_assignments[i] = np.argmin(np.linalg.norm(r_current - R, axis=1))\n\n    N_B_all = np.zeros(len(R))\n    for i in range(len(R)):\n        mask = (basin_assignments == i)\n        N_B_all[i] = np.sum(rho_tilde_on_grid[mask]) * dV\n        \n    q_B = Z_VAL - N_B_all\n    q_C_B = q_B[0]\n    q_H_B_avg = np.mean(q_B[1:])\n\n    return [q_C_M, q_H_M_avg, q_C_H, q_H_H_avg, q_C_B, q_H_B_avg]\n\ndef solve():\n    \"\"\"Main solver function to run all test cases and print results.\"\"\"\n    test_cases = [\n        # (alpha_C, alpha_H, w_C, w_H, beta_C, beta_H)\n        (0.8, 1.2, 0.8, 0.6, 0.7, 1.0),\n        (0.6, 2.0, 0.7, 0.6, 0.7, 1.2),\n        (0.3, 0.4, 0.8, 0.4, 0.5, 0.7),\n    ]\n\n    all_results = []\n    for params in test_cases:\n        results = calculate_charges_for_case(params)\n        all_results.extend(results)\n\n    print(f\"[{','.join(f'{r:.3f}' for r in all_results)}]\")\n\nsolve()\n\n```"
        }
    ]
}