{
    "hands_on_practices": [
        {
            "introduction": "To truly understand Minimum Energy Path (MEP) methods, one must move beyond theory and engage in hands-on implementation. This first practice is a foundational exercise where you will build the Nudged Elastic Band (NEB) and Climbing-Image NEB (CI-NEB) algorithms from scratch for a model two-dimensional potential energy surface. The focus is on a critical algorithmic detail: the definition of the path tangent. By comparing a naive tangent formulation with the improved version, you will see firsthand why this refinement is essential for avoiding numerical instabilities like \"path kinking\" and achieving a smooth, converged MEP .",
            "id": "3888045",
            "problem": "You are given a corrugated two-dimensional potential energy surface intended to model a simplified surface diffusion barrier relevant to heterogeneous catalysis. The system consists of a coordinate vector $\\mathbf{r} = (x,y)$ and a scalar potential energy function $V(x,y)$ defined by\n$$\nV(x,y) = A\\,x^2(1-x)^2 + C_y\\,y^2 + B\\,\\cos(2\\pi y)\\,\\exp\\!\\left(-\\frac{(x-\\tfrac{1}{2})^2}{2\\sigma^2}\\right),\n$$\nwhere $A$, $B$, $C_y$, and $\\sigma$ are nonnegative constants. The minima of the unperturbed $x$-dependent part lie near $(x,y)=(0,0)$ and $(x,y)=(1,0)$, and the barrier region lies near $(x,y)\\approx(0.5,0)$, with corrugation along $y$ induced by the cosine term localized near $x\\approx 0.5$ via the Gaussian.\n\nStarting only from fundamental principles and core definitions, implement the discrete chain approximation to a Minimum Energy Path based on the Nudged Elastic Band (NEB) method and its climbing-image extension. The following fundamental base must be used:\n\n- The Minimum Energy Path (MEP) between two local minima is a curve $\\gamma(s)$ parameterized by arc length $s$ such that at each point on the curve, the force $\\mathbf{F}(\\mathbf{r})=-\\nabla V(\\mathbf{r})$ has no component perpendicular to the path, i.e., $\\mathbf{F}_{\\perp}=\\mathbf{F}-(\\mathbf{F}\\cdot \\hat{\\tau})\\hat{\\tau}=\\mathbf{0}$, where $\\hat{\\tau}$ is the unit tangent to the path.\n- In the discrete NEB method, the path is approximated by a set of $N$ images $\\{\\mathbf{r}_i\\}_{i=0}^{N-1}$ with fixed endpoints $\\mathbf{r}_0$ and $\\mathbf{r}_{N-1}$ at the two minima, connected by springs of constant $k$. The NEB force on interior image $i$ is given by $\\mathbf{F}_i=\\mathbf{F}_{\\perp,i}+\\mathbf{F}_{\\parallel,i}^{\\text{spring}}$, where $\\mathbf{F}_{\\perp,i}=-\\nabla V(\\mathbf{r}_i)+(\\nabla V(\\mathbf{r}_i)\\cdot \\hat{\\tau}_i)\\hat{\\tau}_i$ and $\\mathbf{F}_{\\parallel,i}^{\\text{spring}}=k\\left(\\|\\mathbf{r}_{i+1}-\\mathbf{r}_i\\|-\\|\\mathbf{r}_i-\\mathbf{r}_{i-1}\\|\\right)\\hat{\\tau}_i$.\n- The naive tangent uses $\\hat{\\tau}_i$ obtained by normalizing $(\\mathbf{r}_{i+1}-\\mathbf{r}_{i-1})$. The improved tangent of Henkelman and Jónsson chooses $\\hat{\\tau}_i$ using the local energy ordering to avoid kinks near maxima and minima. Let $\\Delta\\mathbf{r}^+=\\mathbf{r}_{i+1}-\\mathbf{r}_i$, $\\Delta\\mathbf{r}^-=\\mathbf{r}_i-\\mathbf{r}_{i-1}$, $\\Delta E^+=|E_{i+1}-E_i|$, and $\\Delta E^-=|E_{i-1}-E_i|$, where $E_j=V(\\mathbf{r}_j)$. Then\n$$\n\\hat{\\tau}_i \\propto \n\\begin{cases}\n\\Delta\\mathbf{r}^+ & \\text{if } E_{i+1}>E_i>E_{i-1},\\\\\n\\Delta\\mathbf{r}^- & \\text{if } E_{i+1}<E_i<E_{i-1},\\\\\n\\Delta\\mathbf{r}^+\\,\\Delta E^+ + \\Delta\\mathbf{r}^-\\,\\Delta E^- & \\text{if } E_{i+1}>E_i \\text{ and } E_{i-1}>E_i,\\\\\n\\Delta\\mathbf{r}^+\\,\\Delta E^- + \\Delta\\mathbf{r}^-\\,\\Delta E^+ & \\text{if } E_{i+1}<E_i \\text{ and } E_{i-1}<E_i,\n\\end{cases}\n$$\nand the resulting vector is normalized to unit length.\n- In the climbing-image NEB, the highest-energy interior image is made to ascend along the parallel component of the force while removing spring forces, $\\mathbf{F}_i^{\\text{CI}}=-\\nabla V(\\mathbf{r}_i)+2(\\nabla V(\\mathbf{r}_i)\\cdot \\hat{\\tau}_i)\\hat{\\tau}_i$, to converge directly to the saddle point.\n\nYour program must implement the following:\n\n1. Discretize and relax the NEB for both the naive tangent and the improved tangent using explicit time stepping with a fixed step size until a fixed number of iterations is reached. The endpoints must be fixed at the two minima located at $(x,y)=(0,0)$ and $(x,y)=(1,0)$.\n2. For the improved tangent case, also perform the climbing-image NEB by using the climbing-image force on the current highest-energy interior image at each step.\n3. Compute the true saddle point near $(x,y)=(0.5,0)$ by solving $\\nabla V(x,y)=\\mathbf{0}$ starting from $(x,y)=(0.5,0)$ and verifying that the Hessian has one positive and one negative eigenvalue at the solution. Use this as the ground truth barrier location and barrier energy.\n4. For each NEB variant, quantify barrier localization error as the Euclidean distance between the coordinates of the highest-energy image at convergence and the true saddle coordinates, and quantify barrier height error as the difference between the maximum image energy at convergence and the true saddle energy. All errors are dimensionless floats.\n5. Use the following test suite of parameter sets, designed to exercise a typical case, a strongly corrugated case, and a highly corrugated edge case:\n   - Case $\\mathrm{A}$: $(B,k,\\sigma,C_y,N,\\text{steps})=(0.5,1.0,0.08,3.0,15,800)$.\n   - Case $\\mathrm{B}$: $(B,k,\\sigma,C_y,N,\\text{steps})=(2.0,0.5,0.08,3.0,15,1000)$.\n   - Case $\\mathrm{C}$: $(B,k,\\sigma,C_y,N,\\text{steps})=(3.5,0.2,0.05,4.0,21,1200)$.\n   Use $A=1.0$ for all cases and a fixed explicit update step size of $0.02$ in dimensionless units.\n6. For each case, compute six floats in the following order: naive-tangent barrier localization error, improved-tangent barrier localization error, climbing-image barrier localization error, naive-tangent barrier height error, improved-tangent barrier height error, climbing-image barrier height error.\n\nYour program should produce a single line of output containing the results as a comma-separated list of bracketed lists in the order of the test suite, for example, \"[[a1,a2,a3,a4,a5,a6],[b1,b2,b3,b4,b5,b6],[c1,c2,c3,c4,c5,c6]]\". All numerals in the output are decimal floats. No physical units are required because all quantities are dimensionless. Angles, if any appear, must be treated in radians, but the potential uses a cosine with $2\\pi$ already specified, so no angle unit conversion is needed.",
            "solution": "The problem requires the implementation and comparison of the Nudged Elastic Band (NEB) method and its variants for determining the Minimum Energy Path (MEP) on a two-dimensional potential energy surface (PES). The solution is constructed from fundamental principles, starting with the definition of the PES and the MEP, and proceeding to the algorithmic realization of the discrete NEB approximation.\n\nThe potential energy surface, $V(\\mathbf{r})$, for a coordinate vector $\\mathbf{r} = (x,y)$ is given by:\n$$\nV(x,y) = A\\,x^2(1-x)^2 + C_y\\,y^2 + B\\,\\cos(2\\pi y)\\,\\exp\\!\\left(-\\frac{(x-\\tfrac{1}{2})^2}{2\\sigma^2}\\right)\n$$\nThe force on a particle at position $\\mathbf{r}$ is the negative gradient of the potential, $\\mathbf{F}(\\mathbf{r}) = -\\nabla V(\\mathbf{r})$. The components of the gradient are:\n$$\n\\frac{\\partial V}{\\partial x} = 2A x (1-x)(1-2x) - \\frac{B(x-\\tfrac{1}{2})}{\\sigma^2} \\cos(2\\pi y) \\exp\\!\\left(-\\frac{(x-\\tfrac{1}{2})^2}{2\\sigma^2}\\right)\n$$\n$$\n\\frac{\\partial V}{\\partial y} = 2C_y y - 2\\pi B \\sin(2\\pi y) \\exp\\!\\left(-\\frac{(x-\\tfrac{1}{2})^2}{2\\sigma^2}\\right)\n$$\n\nThe Minimum Energy Path (MEP) is a path $\\gamma(s)$ connecting two local minima (reactants and products) along which the force perpendicular to the path is zero at every point. This means the force vector is always parallel to the path's tangent vector, $\\hat{\\tau}$. A key point on the MEP is the saddle point, which corresponds to the maximum energy along the path and represents the transition state. A first-order saddle point is a critical point of the PES ($\\nabla V = \\mathbf{0}$) where the Hessian matrix of second derivatives has exactly one negative eigenvalue. To establish a ground truth for comparison, the true saddle point is located by numerically solving $\\nabla V(x,y) = \\mathbf{0}$ using a root-finding algorithm (e.g., Newton's method or a quasi-Newton method) and verifying the Hessian's eigenvalues.\n\nThe NEB method approximates the continuous MEP with a discrete chain of $N$ configurations, or \"images,\" $\\{\\mathbf{r}_i\\}_{i=0}^{N-1}$. The endpoints, $\\mathbf{r}_0$ and $\\mathbf{r}_{N-1}$, are fixed at the initial and final minima, in this case $(0,0)$ and $(1,0)$, respectively. The interior images, $\\{\\mathbf{r}_i\\}_{i=1}^{N-2}$, are relaxed to conform to the MEP. The relaxation is driven by a specially constructed \"NEB force.\" This force is a combination of the true force from the potential, $\\mathbf{F}_{\\text{true}, i} = -\\nabla V(\\mathbf{r}_i)$, and a fictitious spring force, $\\mathbf{F}_{\\text{spring}, i}$, that connects adjacent images.\n\nA crucial aspect of the NEB method is the projection of these forces. The component of the true force parallel to the path, $\\mathbf{F}_{\\parallel, i}^{\\text{true}} = (\\mathbf{F}_{\\text{true}, i} \\cdot \\hat{\\tau}_i)\\hat{\\tau}_i$, causes images to slide down the MEP, while the perpendicular component, $\\mathbf{F}_{\\perp, i}^{\\text{true}} = \\mathbf{F}_{\\text{true}, i} - \\mathbf{F}_{\\parallel, i}^{\\text{true}}$, pulls the image onto the MEP. To prevent kinking and ensure stable convergence, the NEB method uses only the perpendicular component of the true force. Conversely, the spring force is used only in its component parallel to the path, $\\mathbf{F}_{\\parallel, i}^{\\text{spring}}$, to ensure uniform spacing of images. The total NEB optimization force on image $i$ is thus:\n$$\n\\mathbf{F}_i = \\mathbf{F}_{\\perp, i}^{\\text{true}} + \\mathbf{F}_{\\parallel, i}^{\\text{spring}}\n$$\nSubstituting the definitions gives:\n$$\n\\mathbf{F}_i = \\left(-\\nabla V(\\mathbf{r}_i) + (\\nabla V(\\mathbf{r}_i) \\cdot \\hat{\\tau}_i)\\hat{\\tau}_i\\right) + k\\left(\\|\\mathbf{r}_{i+1}-\\mathbf{r}_i\\|-\\|\\mathbf{r}_i-\\mathbf{r}_{i-1}\\|\\right)\\hat{\\tau}_i\n$$\nThe tangent vector $\\hat{\\tau}_i$ is central to this projection. Its estimation is critical.\n1.  **Naive Tangent**: The simplest estimate is a central difference scheme, normalized: $\\hat{\\tau}_i \\propto \\mathbf{r}_{i+1} - \\mathbf{r}_{i-1}$. This method can suffer from \"kinks\" in the path, where the tangent estimate is poor, leading to instabilities.\n2.  **Improved Tangent**: To mitigate kinking, a more robust tangent is constructed using local energy information. As specified, the tangent $\\hat{\\tau}_i$ is defined piecewise. If the image $i$ is on a monotonic section of the path ($E_{i+1}>E_i>E_{i-1}$ or $E_{i+1}<E_i<E_{i-1}$), the tangent is taken from the uphill direction only. If image $i$ is at a local extremum relative to its neighbors, a weighted average of the forward segment, $\\Delta\\mathbf{r}^+ = \\mathbf{r}_{i+1}-\\mathbf{r}_i$, and backward segment, $\\Delta\\mathbf{r}^- = \\mathbf{r}_i-\\mathbf{r}_{i-1}$, is used. The weighting is based on the energy differences $\\Delta E^+ = |E_{i+1}-E_i|$ and $\\Delta E^- = |E_i-E_{i-1}|$, as per the rules provided. This prevents the tangent from being dominated by one segment during sharp turns or near the saddle point.\n\nThe **Climbing-Image NEB (CI-NEB)** is a modification to converge the highest-energy image precisely onto the saddle point. In this method, after an initial relaxation, the NEB force on the image with the highest potential energy is replaced. The spring force on this image is set to zero, and the parallel component of the true force is inverted to push the image \"uphill\" along the MEP. The climbing-image force is:\n$$\n\\mathbf{F}_i^{\\text{CI}} = -\\nabla V(\\mathbf{r}_i) + 2(\\nabla V(\\mathbf{r}_i) \\cdot \\hat{\\tau}_i)\\hat{\\tau}_i = \\mathbf{F}_{\\perp, i}^{\\text{true}} - \\mathbf{F}_{\\parallel, i}^{\\text{true}}\n$$\nThis modification ensures that one image converges to the saddle point, providing a more accurate barrier height and location without requiring a dense chain of images.\n\nThe algorithmic implementation for all three variants (naive, improved, and climbing-image) proceeds as follows. First, the chain of images is initialized as a linear interpolation between the fixed endpoints. Then, for a specified number of steps, the system is evolved using an explicit Euler time-stepping scheme: $\\mathbf{r}_i(t+\\Delta t) = \\mathbf{r}_i(t) + \\Delta t \\cdot \\mathbf{F}_i(t)$, where $\\mathbf{F}_i(t)$ is the appropriate NEB or CI-NEB force for image $i$ at time $t$. The forces for all images at a given step are calculated based on the positions at that step before any updates are made. For the CI-NEB, the improved tangent is used, and the highest-energy image is identified at each step to apply the climbing force.\n\nFinally, the accuracy of each method is evaluated by comparing the highest-energy image in the converged chain to the true saddle point. The barrier localization error is the Euclidean distance between their positions, and the barrier height error is the difference in their potential energies. These metrics quantify how well each algorithm approximates the true transition state under the given parameters.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import root\n\ndef solve():\n    \"\"\"\n    Main solver function to run NEB simulations and compute errors.\n    \"\"\"\n    # Test cases: (B, k, sigma, C_y, N, steps)\n    test_cases = [\n        (0.5, 1.0, 0.08, 3.0, 15, 800),\n        (2.0, 0.5, 0.08, 3.0, 15, 1000),\n        (3.5, 0.2, 0.05, 4.0, 21, 1200)\n    ]\n    A = 1.0\n    DT = 0.02\n    \n    final_results = []\n\n    for case in test_cases:\n        B, k, sigma, C_y, N, steps = case\n\n        # 1. Potential Energy Surface and its derivatives\n        def potential(r, A, B, C_y, sigma):\n            x, y = r\n            gauss_term = np.exp(-(x - 0.5)**2 / (2 * sigma**2))\n            return A * x**2 * (1 - x)**2 + C_y * y**2 + B * np.cos(2 * np.pi * y) * gauss_term\n\n        def gradient(r, A, B, C_y, sigma):\n            x, y = r\n            gauss_term = np.exp(-(x - 0.5)**2 / (2 * sigma**2))\n            \n            dV_dx = 2 * A * x * (1 - x) * (1 - 2 * x) - \\\n                    B * np.cos(2 * np.pi * y) * gauss_term * (x - 0.5) / sigma**2\n            \n            dV_dy = 2 * C_y * y - 2 * np.pi * B * np.sin(2 * np.pi * y) * gauss_term\n            \n            return np.array([dV_dx, dV_dy])\n\n        def hessian(r, A, B, C_y, sigma):\n            x, y = r\n            gauss_term = np.exp(-(x - 0.5)**2 / (2 * sigma**2))\n            \n            Vxx = 2*A*(1 - 6*x + 6*x**2) - B*np.cos(2*np.pi*y)*gauss_term * \\\n                 (1/sigma**2 - (x-0.5)**2 / sigma**4)\n            \n            Vyy = 2*C_y - 4*np.pi**2*B*np.cos(2*np.pi*y)*gauss_term\n            \n            Vxy = 2*np.pi*B*np.sin(2*np.pi*y)*gauss_term * (x-0.5)/sigma**2\n            return np.array([[Vxx, Vxy], [Vxy, Vyy]])\n\n        # 2. Find True Saddle Point\n        def find_true_saddle(A, B, C_y, sigma):\n            grad_func = lambda r: gradient(r, A, B, C_y, sigma)\n            # Initial guess near the expected saddle point off the y=0 axis.\n            initial_guess = np.array([0.5, 0.1])\n            sol = root(grad_func, initial_guess)\n            saddle_pos = sol.x\n\n            # Verify it's a saddle point\n            H = hessian(saddle_pos, A, B, C_y, sigma)\n            eigenvalues = np.linalg.eigvals(H)\n            if not(np.sum(eigenvalues < 0) == 1 and np.sum(eigenvalues > 0) == 1):\n                # Fallback to a different guess if bifurcation is not pronounced\n                initial_guess_2 = np.array([0.5, 0.0])\n                sol = root(grad_func, initial_guess_2)\n                saddle_pos = sol.x\n            \n            saddle_energy = potential(saddle_pos, A, B, C_y, sigma)\n            return saddle_pos, saddle_energy\n        \n        true_saddle_pos, true_saddle_energy = find_true_saddle(A, B, C_y, sigma)\n\n        # 3. NEB Implementation\n        def get_tangent(i, chain, energies, tangent_type):\n            r_im1, r_i, r_ip1 = chain[i-1], chain[i], chain[i+1]\n            E_im1, E_i, E_ip1 = energies[i-1], energies[i], energies[i+1]\n\n            if tangent_type == 'naive':\n                tangent_vec = r_ip1 - r_im1\n            elif tangent_type == 'improved':\n                dr_plus = r_ip1 - r_i\n                dr_minus = r_i - r_im1\n                \n                if E_ip1 > E_i > E_im1:\n                    tangent_vec = dr_plus\n                elif E_ip1 < E_i < E_im1:\n                    tangent_vec = dr_minus\n                else:\n                    dE_plus = abs(E_ip1 - E_i)\n                    dE_minus = abs(E_i - E_im1)\n                    if E_ip1 > E_i and E_im1 > E_i: # Local minimum\n                        tangent_vec = dr_plus * dE_plus + dr_minus * dE_minus\n                    elif E_ip1 < E_i and E_im1 < E_i: # Local maximum\n                        tangent_vec = dr_plus * dE_minus + dr_minus * dE_plus\n                    else: # One side up, one side down, from a plateau\n                         # Simplified from original paper for intermediate cases\n                         tangent_vec = dr_plus+dr_minus\n            else:\n                 raise ValueError(\"Invalid tangent_type\")\n\n            norm = np.linalg.norm(tangent_vec)\n            return tangent_vec / norm if norm > 1e-9 else np.zeros(2)\n\n        def run_neb_step(chain, k, tangent_type, use_climbing_image):\n            N_chain = len(chain)\n            energies = np.array([potential(r, A, B, C_y, sigma) for r in chain])\n            forces = np.zeros_like(chain)\n\n            climbing_idx = -1\n            if use_climbing_image and N_chain > 2:\n                climbing_idx = np.argmax(energies[1:-1]) + 1\n            \n            for i in range(1, N_chain - 1):\n                tangent = get_tangent(i, chain, energies, tangent_type)\n                \n                grad_V = gradient(chain[i], A, B, C_y, sigma)\n                F_true = -grad_V\n                \n                if use_climbing_image and i == climbing_idx:\n                    # Climbing-image force (project gradient, invert parallel component)\n                    F_climb = F_true + 2 * np.dot(grad_V, tangent) * tangent\n                    forces[i] = F_climb\n                else:\n                    # Standard NEB force\n                    F_perp = F_true - np.dot(F_true, tangent) * tangent\n                    \n                    d_plus = np.linalg.norm(chain[i+1] - chain[i])\n                    d_minus = np.linalg.norm(chain[i] - chain[i-1])\n                    F_spring_parallel = k * (d_plus - d_minus) * tangent\n                    \n                    forces[i] = F_perp + F_spring_parallel\n            \n            chain[1:-1] += DT * forces[1:-1]\n\n        # Initialize chains\n        initial_chain = np.linspace([0.0, 0.0], [1.0, 0.0], N, dtype=np.float64)\n        chain_naive = initial_chain.copy()\n        chain_improved = initial_chain.copy()\n        chain_ci = initial_chain.copy()\n\n        # Run simulations\n        for _ in range(steps):\n            run_neb_step(chain_naive, k=k, tangent_type='naive', use_climbing_image=False)\n            run_neb_step(chain_improved, k=k, tangent_type='improved', use_climbing_image=False)\n            run_neb_step(chain_ci, k=k, tangent_type='improved', use_climbing_image=True)\n\n        # 4. Calculate errors\n        def calculate_errors(chain, true_pos, true_energy):\n            energies = np.array([potential(r, A, B, C_y, sigma) for r in chain])\n            max_energy_idx = np.argmax(energies)\n            \n            max_energy_pos = chain[max_energy_idx]\n            max_energy_val = energies[max_energy_idx]\n            \n            loc_error = np.linalg.norm(max_energy_pos - true_pos)\n            height_error = max_energy_val - true_energy\n            return loc_error, height_error\n\n        loc_err_n, height_err_n = calculate_errors(chain_naive, true_saddle_pos, true_saddle_energy)\n        loc_err_i, height_err_i = calculate_errors(chain_improved, true_saddle_pos, true_saddle_energy)\n        loc_err_c, height_err_c = calculate_errors(chain_ci, true_saddle_pos, true_saddle_energy)\n\n        case_results = [\n            loc_err_n, loc_err_i, loc_err_c,\n            height_err_n, height_err_i, height_err_c\n        ]\n        final_results.append(case_results)\n\n    # 5. Format and print output\n    # Desired format: [[a1,...,a6],[b1,...,b6],[c1,...,c6]]\n    output_str = \"[\"\n    for i, res_list in enumerate(final_results):\n        output_str += \"[\" + \",\".join(map(str, res_list)) + \"]\"\n        if i < len(final_results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    \n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "Standard NEB and CI-NEB methods can struggle when the MEP has regions of high curvature, such as near a sharp catalytic barrier, often leading to instabilities where the climbing image overshoots the saddle point. This exercise tackles this practical challenge by having you implement an adaptive algorithm. You will design and test a variable spring constant schedule, where the stiffness of the elastic band, $k_i$, is increased in high-curvature regions of the path . This practice demonstrates how to build more robust and efficient path-finding tools for realistic and challenging potential energy surfaces.",
            "id": "3887989",
            "problem": "You are asked to design and analyze a computational procedure to determine the minimum energy path for a catalytic bond-breaking event across a sharp barrier using the Nudged Elastic Band (NEB) method and the Climbing-Image NEB (CI-NEB) variant, and to propose a variable-spring schedule that reduces overshooting of the climbing image. The minimum energy path is defined by the condition that the gradient of the potential is everywhere orthogonal to the path tangent; that is, the projection of the gradient onto the path normal vanishes along the path. Your program must implement a discrete set of images connected by springs, perform force-based iterations that project the physical force and the spring force into appropriate components relative to the path tangent, and modify the highest-energy image to climb the barrier by removing tangential spring contributions and inverting the component of the physical force parallel to the tangent.\n\nConsider a two-dimensional potential energy surface with coordinates $x$ and $y$ and real parameters $a$, $b$, $\\kappa$, $c$, $\\sigma_x$, $\\sigma_y$:\n$$\nV(x,y) = a\\,(x^2 - 1)^2 + b\\left(y - \\kappa\\,x\\,e^{-x^2}\\right)^2 + c\\,\\exp\\!\\left(-\\frac{x^2}{\\sigma_x^2} - \\frac{y^2}{\\sigma_y^2}\\right).\n$$\nThis surface contains two minima near $(-1,0)$ and $(1,0)$, and a sharp barrier region near $(0,0)$ that is made sharper by small values of $\\sigma_x$ and $\\sigma_y$. You must connect the endpoints $(-1,0)$ and $(1,0)$ using $N$ images (including endpoints), iteratively relax the images using NEB and CI-NEB, and measure overshooting of the climbing image near the barrier.\n\nYour tasks are:\n- Implement a discretized string of $N$ images with endpoints fixed at $(-1,0)$ and $(1,0)$, and intermediate images initialized by linear interpolation.\n- Implement standard NEB force projection so that the physical force contributes only perpendicular to the tangent, and the spring force contributes only along the tangent for non-climbing images. For the climbing image (the non-endpoint image of highest energy), remove the spring contribution and make the parallel component of the physical force drive ascent along the path while preserving perpendicular relaxation.\n- Propose and implement a variable spring schedule $k_i$ that increases the spring constant near high-curvature regions of the path. Use the discrete curvature indicator\n$$\n\\chi_i = \\frac{\\left\\|\\mathbf{R}_{i+1} - 2\\mathbf{R}_i + \\mathbf{R}_{i-1}\\right\\|}{\\left\\|\\mathbf{R}_{i+1} - \\mathbf{R}_{i-1}\\right\\| + \\varepsilon},\n$$\nfor interior images $i$, where $\\mathbf{R}_i$ is the position vector of image $i$ and $\\varepsilon$ is a small positive number to avoid division by zero. Define\n$$\nk_i = k_0\\,(1 + \\alpha\\,\\chi_i),\n$$\nfor interior images, and keep endpoints fixed. Here $k_0$ is a base spring constant and $\\alpha$ controls the strength of the curvature adaptation.\n- For constant spring schedule, set $\\alpha = 0$ so that $k_i = k_0$ for all interior images.\n\nDefine the overshooting metric for the climbing image as follows. Let the climbing image index at iteration $t$ be $i^\\star(t)$, and its $x$-coordinate be $x^\\star(t)$. Define a capture radius $r_c$ near the barrier on the $x$-axis. After the first iteration $t_0$ at which $\\left|x^\\star(t_0)\\right| \\le r_c$, count the number of sign changes in the sequence $\\{\\mathrm{sign}(x^\\star(t))\\}_{t \\ge t_0}$ over the subsequent iterations. This integer is the overshoot count. A lower overshoot count indicates reduced oscillation across the barrier by the climbing image.\n\nImplement the algorithm using deterministic steepest-descent updates with a fixed step size for all images. Ensure scientific realism by maintaining stable updates, a well-defined tangent from local energy ordering, and appropriate projection of forces. No external input is permitted; all parameters must be defined in your program.\n\nAngle units are not applicable, and there are no physical units required for reporting in this problem. The final outputs must be integers.\n\nTest Suite:\nUse the following test cases, each specified by $(N,k_0,\\alpha,\\sigma_x,\\sigma_y)$, with fixed potential parameters $a = 1$, $b = 5$, $\\kappa = 0.7$, $c = 1$ for all tests. The step size for image updates is fixed, and the endpoints are fixed. Use images indexed from $0$ to $N-1$, with endpoints at $i=0$ and $i=N-1$.\n\n- Case $1$ (baseline constant springs, moderately sharp barrier): $(N,k_0,\\alpha,\\sigma_x,\\sigma_y) = (15,1.0,0.0,0.15,0.09)$.\n- Case $2$ (variable springs on the same barrier): $(N,k_0,\\alpha,\\sigma_x,\\sigma_y) = (15,1.0,2.5,0.15,0.09)$.\n- Case $3$ (baseline constant springs, sharper barrier): $(N,k_0,\\alpha,\\sigma_x,\\sigma_y) = (15,0.5,0.0,0.10,0.06)$.\n- Case $4$ (variable springs on the sharper barrier): $(N,k_0,\\alpha,\\sigma_x,\\sigma_y) = (15,0.5,3.0,0.10,0.06)$.\n\nYour program must produce a single line of output containing the overshoot counts for the four test cases, in order, as a comma-separated list enclosed in square brackets, for example $[n_1,n_2,n_3,n_4]$, where each $n_j$ is an integer overshoot count computed according to the above definition.",
            "solution": "The problem requires the design and implementation of a computational method to find the minimum energy path (MEP) for a chemical transformation on a given two-dimensional potential energy surface, $V(x,y)$. The specific methods to be used are the Nudged Elastic Band (NEB) and its variant, the Climbing-Image NEB (CI-NEB). Furthermore, a variable spring-constant schedule must be implemented and compared against a constant spring-constant baseline, with the performance evaluated based on an \"overshoot\" metric for the climbing image. The problem is scientifically well-grounded, algorithmically specific, and computationally verifiable. Although certain simulation parameters such as the number of iterations, the optimization step size, and the overshooting capture radius are not specified, it is standard practice in computational science for the practitioner to select reasonable values for these parameters. We will therefore proceed by defining these parameters as part of the solution design.\n\nThe potential energy surface (PES) is given by:\n$$\nV(x,y) = a\\,(x^2 - 1)^2 + b\\left(y - \\kappa\\,x\\,e^{-x^2}\\right)^2 + c\\,\\exp\\!\\left(-\\frac{x^2}{\\sigma_x^2} - \\frac{y^2}{\\sigma_y^2}\\right)\n$$\nwith fixed parameters $a = 1$, $b = 5$, $\\kappa = 0.7$, and $c = 1$. This PES describes a double-well system with minima near $(-1, 0)$ and $(1, 0)$, separated by an energy barrier. The parameters $\\sigma_x$ and $\\sigma_y$ control the sharpness of a Gaussian feature at the origin, which modifies the barrier a reaction path must traverse.\n\nThe MEP is the path of lowest energy connecting the reactant and product states, in this case the two minima. A point $\\mathbf{R}$ is on an MEP if the gradient of the potential, $\\nabla V(\\mathbf{R})$, is parallel to the path tangent, $\\hat{\\tau}$, or in other words, if the component of the true force, $\\mathbf{F} = -\\nabla V(\\mathbf{R})$, perpendicular to the path is zero: $\\mathbf{F}_{\\perp} = \\mathbf{F} - (\\mathbf{F} \\cdot \\hat{\\tau})\\hat{\\tau} = \\mathbf{0}$.\n\nThe NEB method approximates the MEP by discretizing the path into a series of $N$ configurations, or \"images,\" $\\mathbf{R}_0, \\mathbf{R}_1, \\dots, \\mathbf{R}_{N-1}$, where the endpoints $\\mathbf{R}_0$ and $\\mathbf{R}_{N-1}$ are fixed at the reactant and product states, respectively. The intermediate images, $\\mathbf{R}_i$ for $i \\in \\{1, \\dots, N-2\\}$, are connected by springs. The system of images is then relaxed to find the MEP.\n\nThe total force on an image $i$ in the NEB formulation is the sum of two components: the perpendicular component of the true force from the potential, $\\mathbf{F}_{i,\\perp}$, and the parallel component of the spring force, $\\mathbf{F}_{i,s}^{\\parallel}$.\n$$\n\\mathbf{F}_i^{\\text{NEB}} = \\mathbf{F}_{i,\\perp} + \\mathbf{F}_{i,s}^{\\parallel}\n$$\nThe true force on image $i$ is $\\mathbf{F}_i = -\\nabla V(\\mathbf{R}_i)$. To determine its perpendicular component, we first require a definition of the local path tangent, $\\hat{\\tau}_i$. A robust definition, which we adopt, determines the tangent based on the local energy landscape. We define the forward and backward path segments as $\\mathbf{\\tau}_{i+} = \\mathbf{R}_{i+1} - \\mathbf{R}_i$ and $\\mathbf{\\tau}_{i-} = \\mathbf{R}_i - \\mathbf{R}_{i-1}$. The tangent vector $\\mathbf{\\tau}_i$ is chosen as the uphill segment if the energy is monotonic (i.e., $E_{i-1} < E_i < E_{i+1}$ or $E_{i-1} > E_i > E_{i+1}$). Otherwise, if image $i$ is an extremum, the tangent is taken along the segment connecting to the neighbor with a larger energy difference. The final tangent $\\hat{\\tau}_i$ is the normalized vector $\\mathbf{\\tau}_i / \\|\\mathbf{\\tau}_i\\|$. The perpendicular true force is then $\\mathbf{F}_{i,\\perp} = \\mathbf{F}_i - (\\mathbf{F}_i \\cdot \\hat{\\tau}_i)\\hat{\\tau}_i$.\n\nThe spring force acts to maintain equal spacing between images. The spring force on image $i$ from its neighbors is $\\mathbf{F}_{i,s} = k_{i+1}(\\mathbf{R}_{i+1} - \\mathbf{R}_i) - k_i(\\mathbf{R}_i - \\mathbf{R}_{i-1})$, where $k_i$ is the spring constant for the segment between images $i-1$ and $i$. The \"nudging\" in NEB consists of projecting this force onto the tangent: $\\mathbf{F}_{i,s}^{\\parallel}$. We use the standard approximation $\\mathbf{F}_{i,s}^{\\parallel} = (k_{i+1}\\|\\mathbf{R}_{i+1} - \\mathbf{R}_i\\| - k_i\\|\\mathbf{R}_i - \\mathbf{R}_{i-1}\\|)\\hat{\\tau}_i$.\n\nThe CI-NEB modification addresses a shortcoming of NEB, which may not precisely converge to the saddle point. In CI-NEB, the image with the highest energy (the \"climbing image,\" $i^\\star$) is treated differently. For this image, the spring force is removed entirely, and the parallel component of the true force is inverted.\n$$\n\\mathbf{F}_{i^\\star}^{\\text{CI}} = \\mathbf{F}_{i^\\star,\\perp} - \\mathbf{F}_{i^\\star,\\parallel} = \\mathbf{F}_{i^\\star} - 2(\\mathbf{F}_{i^\\star} \\cdot \\hat{\\tau}_{i^\\star})\\hat{\\tau}_{i^\\star}\n$$\nThis inverted force component drives the image \"uphill\" along the MEP to converge exactly on the saddle point, while the perpendicular component continues to relax the image onto the MEP.\n\nThe problem requires implementing a variable spring schedule. For sharp barriers or high-curvature paths, constant-stiffness springs can lead to \"corner-cutting\" and may cause instabilities in the climbing image. The proposed schedule adapts the spring constant $k_i$ based on a discrete measure of local path curvature, $\\chi_i$:\n$$\n\\chi_i = \\frac{\\left\\|\\mathbf{R}_{i+1} - 2\\mathbf{R}_i + \\mathbf{R}_{i-1}\\right\\|}{\\left\\|\\mathbf{R}_{i+1} - \\mathbf{R}_{i-1}\\right\\| + \\varepsilon}, \\quad k_i = k_0\\,(1 + \\alpha\\,\\chi_i)\n$$\nHere, $k_0$ is the base spring constant, and $\\alpha$ is a parameter controlling the strength of the adaptation. This schedule increases spring stiffness in high-curvature regions to prevent kinking and improve stability.\n\nThe simulation proceeds via iterative updates using a deterministic steepest-descent algorithm with a fixed step size, $\\delta t$. For each movable image $i \\in \\{1, \\dots, N-2\\}$, the position is updated as $\\mathbf{R}_i(t+1) = \\mathbf{R}_i(t) + \\delta t \\cdot \\mathbf{F}_i^{\\text{total}}(t)$. We select a step size of $\\delta t = 0.002$ and perform $1000$ iterations for each test case.\n\nFinally, we must compute the overshooting metric for the climbing image. This metric quantifies oscillations of the climbing image around the saddle point, which is located near $x=0$. We define a capture radius $r_c = 0.1$. Once the climbing image's $x$-coordinate, $x^\\star$, enters the interval $[-r_c, r_c]$ for the first time at iteration $t_0$, we count the number of subsequent times its sign changes. A lower count indicates a more stable convergence to the saddle point.\n\nThe overall procedure is as follows:\n1. For each test case, initialize $N=15$ images by linear interpolation between the fixed endpoints $\\mathbf{R}_0 = (-1, 0)$ and $\\mathbf{R}_{N-1} = (1, 0)$.\n2. Iterate for a fixed number of steps ($1000$). In each iteration:\n   a. Calculate the energy of all images to identify the climbing image, $i^\\star$.\n   b. For each movable image $i \\in \\{1, \\dots, N-2\\}$, calculate the path tangent $\\hat{\\tau}_i$ and the true force $\\mathbf{F}_i = -\\nabla V(\\mathbf{R}_i)$.\n   c. If using variable springs ($\\alpha>0$), calculate all curvature-dependent spring constants $k_j$ for $j \\in \\{1, \\dots, N-2\\}$.\n   d. Calculate the total force $\\mathbf{F}_i^{\\text{total}}$ using the CI-NEB rule if $i=i^\\star$, and the standard NEB rule otherwise.\n   e. Update the positions of all movable images simultaneously using the steepest-descent formula.\n   f. Track the $x$-coordinate of the climbing image and update the overshoot count according to the defined metric.\n3. Record the final overshoot count for each case. The implementation requires careful handling of vector operations, force projections, and boundary conditions (fixed endpoints).",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run NEB/CI-NEB simulations for the given test cases.\n    \"\"\"\n\n    # --- Fixed Parameters for All Tests ---\n    potential_params = {\n        'a': 1.0, 'b': 5.0, 'kappa': 0.7, 'c': 1.0\n    }\n    \n    # Simulation control parameters\n    num_iterations = 1000\n    step_size = 0.002  # Fixed step size for steepest descent\n    capture_radius = 0.1\n    epsilon = 1e-9  # For curvature calculation stability\n\n    # --- Test Cases ---\n    # (N, k0, alpha, sigma_x, sigma_y)\n    test_cases = [\n        (15, 1.0, 0.0, 0.15, 0.09),  # Case 1\n        (15, 1.0, 2.5, 0.15, 0.09),  # Case 2\n        (15, 0.5, 0.0, 0.10, 0.06),  # Case 3\n        (15, 0.5, 3.0, 0.10, 0.06),  # Case 4\n    ]\n\n    results = []\n    for params in test_cases:\n        N, k0, alpha, sigma_x, sigma_y = params\n        \n        case_potential_params = {**potential_params, 'sigma_x': sigma_x, 'sigma_y': sigma_y}\n        \n        overshoot_count = run_simulation(\n            N, k0, alpha, case_potential_params,\n            num_iterations, step_size, capture_radius, epsilon\n        )\n        results.append(overshoot_count)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef get_potential_and_gradient(R, params):\n    \"\"\"\n    Calculates the potential energy V and its gradient grad_V at a position R=(x,y).\n    \"\"\"\n    x, y = R\n    a, b, kappa, c = params['a'], params['b'], params['kappa'], params['c']\n    sx2, sy2 = params['sigma_x']**2, params['sigma_y']**2\n    \n    # Common terms\n    emx2 = np.exp(-x**2)\n    gauss_term = c * np.exp(-x**2 / sx2 - y**2 / sy2)\n    y_term_base = y - kappa * x * emx2\n    \n    # Potential V\n    V = a * (x**2 - 1)**2 + b * y_term_base**2 + gauss_term\n\n    # Gradient dV/dx\n    dv_dx_y_term_factor = -kappa * emx2 * (1 - 2*x**2)\n    grad_x = 4 * a * x * (x**2 - 1) + 2 * b * y_term_base * dv_dx_y_term_factor - gauss_term * (2 * x / sx2)\n    \n    # Gradient dV/dy\n    grad_y = 2 * b * y_term_base - gauss_term * (2 * y / sy2)\n    \n    grad_V = np.array([grad_x, grad_y])\n    \n    return V, grad_V\n\ndef run_simulation(N, k0, alpha, potential_params, num_iterations, step_size, capture_radius, epsilon):\n    \"\"\"\n    Performs a single NEB/CI-NEB simulation and returns the overshoot count.\n    \"\"\"\n    # --- Initialization ---\n    images = np.zeros((N, 2))\n    images[:, 0] = np.linspace(-1.0, 1.0, N)\n    \n    # --- Metric Tracking ---\n    overshoot_count = 0\n    capture_t0_found = False\n    prev_x_sign = 0\n\n    # --- Main Iteration Loop ---\n    for _ in range(num_iterations):\n        # Calculate energies and forces for all images\n        energies = np.zeros(N)\n        gradients = np.zeros_like(images)\n        for i in range(N):\n            energies[i], gradients[i] = get_potential_and_gradient(images[i], potential_params)\n        \n        forces = -gradients\n\n        # Identify climbing image (highest energy non-endpoint image)\n        i_climb = np.argmax(energies[1:-1]) + 1\n        \n        # Calculate tangents\n        tangents = np.zeros_like(images)\n        for i in range(1, N - 1):\n            E_prev, E_curr, E_next = energies[i-1], energies[i], energies[i+1]\n            tau_plus = images[i+1] - images[i]\n            tau_minus = images[i] - images[i-1]\n\n            if (E_prev < E_curr < E_next) or (E_prev > E_curr > E_next):\n                if E_next > E_prev:\n                    tangent_vec = tau_plus\n                else:\n                    tangent_vec = tau_minus\n            else:\n                dE_plus = abs(E_next - E_curr)\n                dE_minus = abs(E_curr - E_prev)\n                if dE_plus > dE_minus:\n                    tangent_vec = tau_plus\n                elif dE_minus > dE_plus:\n                    tangent_vec = tau_minus\n                else:\n                    tangent_vec = tau_plus + tau_minus\n\n            norm = np.linalg.norm(tangent_vec)\n            if norm > epsilon:\n                tangents[i] = tangent_vec / norm\n\n        # Calculate spring constants if needed\n        spring_constants = np.full(N, k0)\n        if alpha > 0:\n            for i in range(1, N - 1):\n                num_term = images[i+1] - 2 * images[i] + images[i-1]\n                den_term = images[i+1] - images[i-1]\n                chi_i = np.linalg.norm(num_term) / (np.linalg.norm(den_term) + epsilon)\n                spring_constants[i] = k0 * (1 + alpha * chi_i)\n\n        # Calculate total forces on movable images\n        total_forces = np.zeros((N - 2, 2))\n        for i in range(1, N - 1):\n            tangent = tangents[i]\n            \n            # Perpendicular component of true force\n            F_perp = forces[i] - np.dot(forces[i], tangent) * tangent\n\n            if i == i_climb:\n                # CI-NEB force: full force reflected through the perpendicular plane\n                F_parallel = np.dot(forces[i], tangent) * tangent\n                total_forces[i - 1] = F_perp - F_parallel\n            else:\n                # Standard NEB force\n                # Spring force parallel to tangent\n                mag_seg_plus = np.linalg.norm(images[i+1] - images[i])\n                mag_seg_minus = np.linalg.norm(images[i] - images[i-1])\n                k_plus = spring_constants[i+1]\n                k_minus = spring_constants[i]\n                \n                F_spring_parallel = (k_plus * mag_seg_plus - k_minus * mag_seg_minus) * tangent\n                total_forces[i - 1] = F_perp + F_spring_parallel\n        \n        # Update image positions\n        images[1:-1] += step_size * total_forces\n\n        # --- Overshoot Metric Logic ---\n        x_climb = images[i_climb, 0]\n        \n        if not capture_t0_found:\n            if abs(x_climb) <= capture_radius:\n                capture_t0_found = True\n                prev_x_sign = np.sign(x_climb)\n        else:\n            current_x_sign = np.sign(x_climb)\n            if current_x_sign * prev_x_sign < 0:\n                overshoot_count += 1\n            if current_x_sign != 0:\n                prev_x_sign = current_x_sign\n\n    return overshoot_count\n\nif __name__ == '__main__':\n    solve()\n\n```"
        },
        {
            "introduction": "The Minimum Energy Path is more than just a geometric line on a potential energy surface; it represents the most probable pathway for a chemical reaction at low temperatures, and its properties are intrinsically linked to atomic dynamics. This final practice bridges the gap between path geometry and physical dynamics by introducing mass-weighted coordinates $\\tilde{\\mathbf{R}} = \\mathbf{M}^{1/2}\\mathbf{R}$. You will derive how this coordinate transformation alters the NEB force projection formalism and then implement it to understand how atomic masses shape the dynamically relevant reaction pathway . This exercise is crucial for connecting MEP calculations to the calculation of reaction rates via Transition State Theory.",
            "id": "3888040",
            "problem": "You are given a discrete path of images in configuration space connecting two states of an atomistic system and asked to compute the minimum-energy-path geometrical ingredients used by the Nudged Elastic Band (NEB) method under a change of variables to mass-weighted coordinates. Work in a finite-dimensional Euclidean space with coordinates collected into a single column vector $\\,\\mathbf{R}\\in\\mathbb{R}^{n}\\,$ that stacks all Cartesian coordinates of all atoms. Let the diagonal mass matrix be $\\,\\mathbf{M}=\\mathrm{diag}(m_{1},m_{1},\\dots,m_{1},m_{2},m_{2},\\dots)\\,$ where each atomic mass $\\,m_{a}>0\\,$ is repeated for each of its Cartesian components. Define mass-weighted coordinates by $\\,\\tilde{\\mathbf{R}}=\\mathbf{M}^{1/2}\\mathbf{R}\\,$.\n\n- A discrete path is a sequence of images $\\,\\{\\mathbf{R}_{0},\\mathbf{R}_{1},\\dots,\\mathbf{R}_{K-1}\\}\\,$ with $\\,K\\ge 3\\,$. Internal images are indexed by $\\,i\\in\\{1,\\dots,K-2\\}\\,$.\n- The physical potential energy is a scalar function $\\,V(\\mathbf{R})\\,$ with gradient $\\,\\nabla_{\\mathbf{R}}V(\\mathbf{R})\\,$. The true force is $\\,\\mathbf{F}^{\\mathrm{true}}(\\mathbf{R})=-\\nabla_{\\mathbf{R}}V(\\mathbf{R})\\,$.\n- In standard NEB, one uses a unit tangent $\\,\\hat{\\boldsymbol{\\tau}}_{i}\\,$ at each internal image to define a projection of the true force orthogonal to the path. In this problem, the unit tangent is to be constructed in mass-weighted coordinates and orthogonality is to be understood with respect to the Euclidean inner product in the mass-weighted space.\n\nYour tasks:\n\n1) Starting only from multivariable calculus change-of-variables, linear algebra of diagonal scalings, and the NEB definition of tangent and projected force, derive the following in a coordinate-free but computable form:\n- The relation between the unit tangent in mass-weighted coordinates $\\,\\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}\\,$ and the discrete images. Use the symmetric finite-difference construction in mass-weighted space: differences $\\,\\Delta\\tilde{\\mathbf{R}}^{+}_{i}=\\tilde{\\mathbf{R}}_{i+1}-\\tilde{\\mathbf{R}}_{i}\\,$ and $\\,\\Delta\\tilde{\\mathbf{R}}^{-}_{i}=\\tilde{\\mathbf{R}}_{i}-\\tilde{\\mathbf{R}}_{i-1}\\,$, unit vectors $\\,\\hat{\\mathbf{u}}^{\\pm}_{i}=\\Delta\\tilde{\\mathbf{R}}^{\\pm}_{i}/\\lVert\\Delta\\tilde{\\mathbf{R}}^{\\pm}_{i}\\rVert\\,$ (whenever the denominator is nonzero), and raw tangent $\\,\\tilde{\\boldsymbol{\\tau}}^{\\mathrm{raw}}_{i}=\\hat{\\mathbf{u}}^{+}_{i}+\\hat{\\mathbf{u}}^{-}_{i}\\,$ with normalization $\\,\\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}=\\tilde{\\boldsymbol{\\tau}}^{\\mathrm{raw}}_{i}/\\lVert\\tilde{\\boldsymbol{\\tau}}^{\\mathrm{raw}}_{i}\\rVert\\,$ when $\\,\\lVert\\tilde{\\boldsymbol{\\tau}}^{\\mathrm{raw}}_{i}\\rVert>0\\,$. In degenerate cases where both neighbor differences vanish, the tangent is undefined; in this problem, define it to be the zero vector.\n- The transformation rule for the true force under the change of variables $\\,\\tilde{\\mathbf{R}}=\\mathbf{M}^{1/2}\\mathbf{R}\\,$ and the expression for the component of the true force perpendicular to the tangent when orthogonality is defined in the mass-weighted Euclidean space. Your final expression must be an explicit computable formula for the perpendicular force back in the original coordinates $\\,\\mathbf{R}\\,$ in terms of $\\,\\mathbf{M}\\,$, $\\,\\mathbf{F}^{\\mathrm{true}}(\\mathbf{R}_{i})\\,$, and $\\,\\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}\\,$.\n\n2) Implement a program that:\n- Accepts no input and constructs the four test cases below internally. All quantities are dimensionless.\n- For each case, builds $\\,\\mathbf{M}\\,$ from a list of atomic masses, constructs $\\,\\tilde{\\mathbf{R}}_{j}=\\mathbf{M}^{1/2}\\mathbf{R}_{j}\\,$, computes $\\,\\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}\\,$ at each internal image using the symmetric mass-weighted differences defined above (use the convention that if a norm is smaller than $\\,\\varepsilon=10^{-12}\\,$, treat it as zero), evaluates $\\,\\mathbf{F}^{\\mathrm{true}}(\\mathbf{R}_{i})\\,$, forms the mass-weighted perpendicular component at each internal image, maps it back to $\\,\\mathbf{R}$-space, and returns the sum over internal images of the Euclidean norms of these perpendicular components.\n- Additionally, for Case $\\,2\\,$, compute the same sum using the standard, non-mass-weighted tangent in $\\,\\mathbf{R}$-space and report the absolute difference between the mass-weighted and non-mass-weighted sums.\n\n3) Use the following test suite. In all cases the spatial dimension per atom is $\\,D=2\\,$, so that if there are $\\,A\\,$ atoms there are $\\,n=2A\\,$ coordinates per image. Each image is provided as a flat list $\\,\\mathbf{R}=[x_{1},y_{1},x_{2},y_{2},\\dots]\\,$.\n- Case $\\,1$ (happy path, unequal masses and anisotropic quadratic potential): masses $\\,\\{1,16\\}\\,$; images $\\,\\mathbf{R}_{0}=[0,0,1,-1]\\,$, $\\,\\mathbf{R}_{1}=[\\tfrac{1}{2},\\tfrac{1}{2},\\tfrac{1}{2},-\\tfrac{1}{2}]\\,$, $\\,\\mathbf{R}_{2}=[1,1,0,0]\\,$; potential $\\,V(\\mathbf{R})=\\tfrac{1}{2}\\sum_{k=1}^{4}a_{k}R_{k}^{2}\\,$ with coefficients $\\,a=[1,2,3,4]\\,$.\n- Case $\\,2$ (consistency check, equal masses): masses $\\,\\{5,5\\}\\,$; images and potential as in Case $\\,1\\,$. Return a single float equal to the absolute difference between the mass-weighted and non-mass-weighted sums of perpendicular-force norms over internal images.\n- Case $\\,3$ (boundary where the perpendicular component should vanish): masses $\\,\\{2,1\\}\\,$; images $\\,\\mathbf{R}_{0}=[0,1,0,0]\\,$, $\\,\\mathbf{R}_{1}=[1,2,1,0]\\,$, $\\,\\mathbf{R}_{2}=[2,3,2,0]\\,$; use a linear potential $\\,V(\\mathbf{R})=-\\boldsymbol{c}^{\\top}\\mathbf{R}\\,$ with constant gradient $\\,\\nabla_{\\mathbf{R}}V(\\mathbf{R})=-\\boldsymbol{c}\\,$ chosen so that the true force $\\,\\mathbf{F}^{\\mathrm{true}}(\\mathbf{R})=\\boldsymbol{c}\\,$ is exactly parallel to the mass-weighted unit tangent at the internal image. Concretely, let $\\,\\boldsymbol{c}=\\alpha\\,\\mathbf{M}^{1/2}\\hat{\\tilde{\\boldsymbol{\\tau}}}_{1}\\,$ with $\\,\\alpha=3.14\\,$ (a dimensionless constant). Report the sum of perpendicular-force norms; it should be numerically zero.\n- Case $\\,4$ (degenerate tangent, identical neighboring images): masses $\\,\\{3,7\\}\\,$; images $\\,\\mathbf{R}_{0}=\\mathbf{R}_{1}=\\mathbf{R}_{2}=[1,-1,2,-2]\\,$; potential $\\,V(\\mathbf{R})=\\tfrac{1}{2}\\,\\mathbf{R}^{\\top}\\mathbf{R}\\,$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for Cases $\\,1\\,$–$\\,4\\,$ as a comma-separated list of floats enclosed in square brackets, for example $\\,\\,[r_{1},r_{2},r_{3},r_{4}]\\,\\,$. Round each float to $\\,10\\,$ decimal places in the printed output. No units are required because all quantities are dimensionless and angles are not involved.",
            "solution": "The problem statement is evaluated to be scientifically grounded, well-posed, and an objective exercise in applying principles of multivariable calculus and linear algebra to the Nudged Elastic Band (NEB) method. The required physical and mathematical concepts, such as potential energy, force, mass-weighted coordinates, and vector projections, are standard in computational physics and chemistry. All definitions are precise, and the provided test cases are self-contained and suitable for verifying the derived formulae. The problem is therefore deemed **valid**, and a solution is provided below.\n\nThis solution is presented in two parts as requested: first, the derivation of the necessary mathematical expressions, and second, the implementation of these expressions for the given test cases.\n\n### Part 1: Derivations\n\nThe problem requires the derivation of two quantities for a discrete path of images $\\{\\mathbf{R}_{0}, \\mathbf{R}_{1}, \\dots, \\mathbf{R}_{K-1}\\}$: the unit tangent vector in mass-weighted coordinates, $\\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}$, and the component of the true force perpendicular to this tangent, mapped back to the original coordinate system.\n\nLet $\\mathbf{R} \\in \\mathbb{R}^{n}$ be the vector of Cartesian coordinates. The mass matrix $\\mathbf{M}$ is a diagonal matrix of atomic masses. The mass-weighted coordinates $\\tilde{\\mathbf{R}}$ are defined by the linear transformation:\n$$\n\\tilde{\\mathbf{R}} = \\mathbf{M}^{1/2}\\mathbf{R}\n$$\nwhere $\\mathbf{M}^{1/2}$ is the diagonal matrix whose entries are the square roots of the corresponding entries in $\\mathbf{M}$. Since $\\mathbf{M}$ is diagonal and its entries are positive, $\\mathbf{M}^{1/2}$ is real, diagonal, and symmetric, i.e., $(\\mathbf{M}^{1/2})^\\top = \\mathbf{M}^{1/2}$. The inverse transformation is $\\mathbf{R} = \\mathbf{M}^{-1/2}\\tilde{\\mathbf{R}}$.\n\n**1. Unit Tangent in Mass-Weighted Coordinates, $\\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}$**\n\nThe unit tangent $\\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}$ at an internal image $\\tilde{\\mathbf{R}}_{i}$ is constructed using a symmetric finite-difference scheme in the mass-weighted space.\n\nFirst, we define the forward and backward difference vectors in mass-weighted coordinates:\n$$\n\\Delta\\tilde{\\mathbf{R}}^{+}_{i} = \\tilde{\\mathbf{R}}_{i+1} - \\tilde{\\mathbf{R}}_{i} = \\mathbf{M}^{1/2}\\mathbf{R}_{i+1} - \\mathbf{M}^{1/2}\\mathbf{R}_{i} = \\mathbf{M}^{1/2}(\\mathbf{R}_{i+1} - \\mathbf{R}_{i})\n$$\n$$\n\\Delta\\tilde{\\mathbf{R}}^{-}_{i} = \\tilde{\\mathbf{R}}_{i} - \\tilde{\\mathbf{R}}_{i-1} = \\mathbf{M}^{1/2}\\mathbf{R}_{i} - \\mathbf{M}^{1/2}\\mathbf{R}_{i-1} = \\mathbf{M}^{1/2}(\\mathbf{R}_{i} - \\mathbf{R}_{i-1})\n$$\nNext, we normalize these vectors to obtain unit vectors $\\hat{\\mathbf{u}}^{+}_{i}$ and $\\hat{\\mathbf{u}}^{-}_{i}$, provided the corresponding norms are non-zero. The norm used is the standard Euclidean norm in the $\\tilde{\\mathbf{R}}$-space.\n$$\n\\hat{\\mathbf{u}}^{\\pm}_{i} = \\frac{\\Delta\\tilde{\\mathbf{R}}^{\\pm}_{i}}{\\lVert\\Delta\\tilde{\\mathbf{R}}^{\\pm}_{i}\\rVert}\n$$\nThe raw tangent vector, $\\tilde{\\boldsymbol{\\tau}}^{\\mathrm{raw}}_{i}$, is the sum of these unit vectors:\n$$\n\\tilde{\\boldsymbol{\\tau}}^{\\mathrm{raw}}_{i} = \\hat{\\mathbf{u}}^{+}_{i} + \\hat{\\mathbf{u}}^{-}_{i}\n$$\nFinally, the unit tangent vector $\\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}$ is obtained by normalizing the raw tangent vector, again provided its norm is non-zero:\n$$\n\\hat{\\tilde{\\boldsymbol{\\tau}}}_{i} = \\frac{\\tilde{\\boldsymbol{\\tau}}^{\\mathrm{raw}}_{i}}{\\lVert\\tilde{\\boldsymbol{\\tau}}^{\\mathrm{raw}}_{i}\\rVert}\n$$\nIn cases where any norm is zero (or below a numerical threshold $\\varepsilon$), the corresponding normalized vector is taken to be the zero vector. Specifically, if $\\lVert\\Delta\\tilde{\\mathbf{R}}^{\\pm}_{i}\\rVert < \\varepsilon$, we define $\\hat{\\mathbf{u}}^{\\pm}_{i} = \\mathbf{0}$. Consequently, if $\\tilde{\\boldsymbol{\\tau}}^{\\mathrm{raw}}_{i}$ is the zero vector (which occurs if both $\\hat{\\mathbf{u}}^{+}_{i}$ and $\\hat{\\mathbf{u}}^{-}_{i}$ are zero, as per the problem's degenerate case definition), then $\\hat{\\tilde{\\boldsymbol{\\tau}}}_{i} = \\mathbf{0}$. This set of equations constitutes a computable definition for $\\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}$ in terms of the images $\\mathbf{R}_{j}$ and the mass matrix $\\mathbf{M}$.\n\n**2. Perpendicular Force Component**\n\nThe true force on the system is the negative gradient of the potential energy $V(\\mathbf{R})$:\n$$\n\\mathbf{F}^{\\mathrm{true}}(\\mathbf{R}) = -\\nabla_{\\mathbf{R}}V(\\mathbf{R})\n$$\nTo find the force in mass-weighted coordinates, $\\tilde{\\mathbf{F}}^{\\mathrm{true}}(\\tilde{\\mathbf{R}})$, we apply the chain rule for gradients. The gradient operator transforms as $\\nabla_{\\tilde{\\mathbf{R}}} = (\\frac{\\partial\\mathbf{R}}{\\partial\\tilde{\\mathbf{R}}})^\\top \\nabla_{\\mathbf{R}}$. The Jacobian of the transformation $\\mathbf{R}(\\tilde{\\mathbf{R}})$ is $\\frac{\\partial\\mathbf{R}}{\\partial\\tilde{\\mathbf{R}}} = \\mathbf{M}^{-1/2}$. Since $\\mathbf{M}^{-1/2}$ is symmetric, we have:\n$$\n\\nabla_{\\tilde{\\mathbf{R}}} = \\mathbf{M}^{-1/2} \\nabla_{\\mathbf{R}}\n$$\nThe force in the new coordinates is thus:\n$$\n\\tilde{\\mathbf{F}}^{\\mathrm{true}}(\\tilde{\\mathbf{R}}) = -\\nabla_{\\tilde{\\mathbf{R}}}V(\\mathbf{R}(\\tilde{\\mathbf{R}})) = -\\mathbf{M}^{-1/2}\\nabla_{\\mathbf{R}}V = \\mathbf{M}^{-1/2}\\mathbf{F}^{\\mathrm{true}}(\\mathbf{R})\n$$\nSo, for the $i$-th image, we have $\\tilde{\\mathbf{F}}^{\\mathrm{true}}_{i} = \\mathbf{M}^{-1/2}\\mathbf{F}^{\\mathrm{true}}_{i}$.\n\nThe NEB force component perpendicular to the path is defined by removing the component parallel to the tangent. In the mass-weighted space, this is a standard orthogonal projection. The component of $\\tilde{\\mathbf{F}}^{\\mathrm{true}}_{i}$ parallel to $\\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}$ is:\n$$\n\\tilde{\\mathbf{F}}_{i, \\parallel} = (\\tilde{\\mathbf{F}}^{\\mathrm{true}}_{i} \\cdot \\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}) \\hat{\\tilde{\\boldsymbol{\\tau}}}_{i} = ((\\tilde{\\mathbf{F}}^{\\mathrm{true}}_{i})^\\top \\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}) \\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}\n$$\nThe perpendicular component in mass-weighted space is:\n$$\n\\tilde{\\mathbf{F}}_{i, \\perp} = \\tilde{\\mathbf{F}}^{\\mathrm{true}}_{i} - \\tilde{\\mathbf{F}}_{i, \\parallel} = \\tilde{\\mathbf{F}}^{\\mathrm{true}}_{i} - ((\\tilde{\\mathbf{F}}^{\\mathrm{true}}_{i})^\\top \\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}) \\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}\n$$\nThe problem asks for this force component expressed back in the original $\\mathbf{R}$-coordinates. We must establish the transformation rule for a force vector from $\\tilde{\\mathbf{R}}$-space to $\\mathbf{R}$-space. A force vector transforms such that the work done, $dW = \\mathbf{F}^\\top d\\mathbf{R}$, is invariant. Let $\\mathbf{F}_{i, \\perp}^{\\text{R-space}}$ be the desired force in $\\mathbf{R}$-space.\n$$\ndW = (\\mathbf{F}_{i, \\perp}^{\\text{R-space}})^\\top d\\mathbf{R} = (\\tilde{\\mathbf{F}}_{i, \\perp})^\\top d\\tilde{\\mathbf{R}}\n$$\nSubstituting $d\\tilde{\\mathbf{R}} = \\mathbf{M}^{1/2}d\\mathbf{R}$, we get:\n$$\n(\\mathbf{F}_{i, \\perp}^{\\text{R-space}})^\\top d\\mathbf{R} = (\\tilde{\\mathbf{F}}_{i, \\perp})^\\top \\mathbf{M}^{1/2} d\\mathbf{R} = (\\mathbf{M}^{1/2}\\tilde{\\mathbf{F}}_{i, \\perp})^\\top d\\mathbf{R}\n$$\nAs this must hold for any infinitesimal displacement $d\\mathbf{R}$, we find the transformation rule:\n$$\n\\mathbf{F}_{i, \\perp}^{\\text{R-space}} = \\mathbf{M}^{1/2}\\tilde{\\mathbf{F}}_{i, \\perp}\n$$\nNow we substitute the expressions for $\\tilde{\\mathbf{F}}_{i, \\perp}$ and $\\tilde{\\mathbf{F}}^{\\mathrm{true}}_{i}$:\n$$\n\\mathbf{F}_{i, \\perp}^{\\text{R-space}} = \\mathbf{M}^{1/2} \\left[ \\tilde{\\mathbf{F}}^{\\mathrm{true}}_{i} - ((\\tilde{\\mathbf{F}}^{\\mathrm{true}}_{i})^\\top \\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}) \\hat{\\tilde{\\boldsymbol{\\tau}}}_{i} \\right] \\\\\n= \\mathbf{M}^{1/2} \\left[ \\mathbf{M}^{-1/2}\\mathbf{F}^{\\mathrm{true}}_{i} - ((\\mathbf{M}^{-1/2}\\mathbf{F}^{\\mathrm{true}}_{i})^\\top \\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}) \\hat{\\tilde{\\boldsymbol{\\tau}}}_{i} \\right]\n$$\nDistributing $\\mathbf{M}^{1/2}$ yields:\n$$\n\\mathbf{F}_{i, \\perp}^{\\text{R-space}} = \\mathbf{M}^{1/2}\\mathbf{M}^{-1/2}\\mathbf{F}^{\\mathrm{true}}_{i} - ((\\mathbf{F}^{\\mathrm{true}}_{i})^\\top (\\mathbf{M}^{-1/2})^\\top \\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}) \\mathbf{M}^{1/2}\\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}\n$$\nUsing $\\mathbf{M}^{1/2}\\mathbf{M}^{-1/2}=\\mathbf{I}$ and $(\\mathbf{M}^{-1/2})^\\top = \\mathbf{M}^{-1/2}$, we arrive at the final explicit formula:\n$$\n\\mathbf{F}_{i, \\perp}^{\\text{R-space}} = \\mathbf{F}^{\\mathrm{true}}_{i} - ((\\mathbf{F}^{\\mathrm{true}}_{i})^\\top \\mathbf{M}^{-1/2} \\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}) \\mathbf{M}^{1/2}\\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}\n$$\nThis formula provides the perpendicular component of the force in the original $\\mathbf{R}$-space, using a projection defined in the mass-weighted $\\tilde{\\mathbf{R}}$-space. It is computable from the true force $\\mathbf{F}^{\\mathrm{true}}_{i}$, the mass matrix $\\mathbf{M}$, and the mass-weighted unit tangent $\\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the four test cases for computing NEB-related quantities\n    in mass-weighted coordinates.\n    \"\"\"\n    \n    # Epsilon for floating point comparisons with zero\n    EPS = 1e-12\n\n    # Define the test cases\n    test_cases = [\n        {\n            \"id\": 1,\n            \"masses\": [1.0, 16.0],\n            \"images\": [\n                [0.0, 0.0, 1.0, -1.0],\n                [0.5, 0.5, 0.5, -0.5],\n                [1.0, 1.0, 0.0, 0.0]\n            ],\n            \"potential\": {\"type\": \"quadratic\", \"coeffs\": [1.0, 2.0, 3.0, 4.0]},\n            \"dim\": 2\n        },\n        {\n            \"id\": 2,\n            \"masses\": [5.0, 5.0],\n            \"images\": [\n                [0.0, 0.0, 1.0, -1.0],\n                [0.5, 0.5, 0.5, -0.5],\n                [1.0, 1.0, 0.0, 0.0]\n            ],\n            \"potential\": {\"type\": \"quadratic\", \"coeffs\": [1.0, 2.0, 3.0, 4.0]},\n            \"dim\": 2\n        },\n        {\n            \"id\": 3,\n            \"masses\": [2.0, 1.0],\n            \"images\": [\n                [0.0, 1.0, 0.0, 0.0],\n                [1.0, 2.0, 1.0, 0.0],\n                [2.0, 3.0, 2.0, 0.0]\n            ],\n            \"potential\": {\"type\": \"linear\", \"alpha\": 3.14},\n            \"dim\": 2\n        },\n        {\n            \"id\": 4,\n            \"masses\": [3.0, 7.0],\n            \"images\": [\n                [1.0, -1.0, 2.0, -2.0],\n                [1.0, -1.0, 2.0, -2.0],\n                [1.0, -1.0, 2.0, -2.0]\n            ],\n            \"potential\": {\"type\": \"identity_quadratic\"},\n            \"dim\": 2\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        masses = np.array(case[\"masses\"])\n        images_R = [np.array(img) for img in case[\"images\"]]\n        dim = case[\"dim\"]\n        K = len(images_R)\n        num_internal_images = K - 2\n\n        # Construct mass matrix and its square roots\n        M_diag = np.repeat(masses, dim)\n        M = np.diag(M_diag)\n        M_sqrt = np.diag(np.sqrt(M_diag))\n        M_inv_sqrt = np.diag(1.0 / np.sqrt(M_diag))\n\n        def get_tangent_and_force(R_images, M_sqrt_mat, M_inv_sqrt_mat, potential_params, use_mass_weighting):\n            total_perp_force_norm = 0.0\n            \n            nonlocal M_sqrt # Need to access outer scope for case 3\n            \n            for i in range(1, num_internal_images + 1):\n                R_prev, R_curr, R_next = R_images[i-1], R_images[i], R_images[i+1]\n                \n                # --- 1. Compute unit tangent ---\n                # Use identity matrices for non-mass-weighted calculation\n                eff_M_sqrt = M_sqrt_mat if use_mass_weighting else np.eye(len(R_curr))\n                \n                delta_R_plus = R_next - R_curr\n                delta_R_minus = R_curr - R_prev\n                \n                delta_tilde_R_plus = eff_M_sqrt @ delta_R_plus\n                delta_tilde_R_minus = eff_M_sqrt @ delta_R_minus\n\n                norm_plus = np.linalg.norm(delta_tilde_R_plus)\n                norm_minus = np.linalg.norm(delta_tilde_R_minus)\n\n                u_hat_plus = delta_tilde_R_plus / norm_plus if norm_plus > EPS else np.zeros_like(delta_tilde_R_plus)\n                u_hat_minus = delta_tilde_R_minus / norm_minus if norm_minus > EPS else np.zeros_like(delta_tilde_R_minus)\n\n                tau_raw = u_hat_plus + u_hat_minus\n                norm_tau_raw = np.linalg.norm(tau_raw)\n                \n                tau_hat = tau_raw / norm_tau_raw if norm_tau_raw > EPS else np.zeros_like(tau_raw)\n\n                # --- 2. Compute true force ---\n                if potential_params[\"type\"] == \"quadratic\":\n                    coeffs = np.array(potential_params[\"coeffs\"])\n                    F_true = -coeffs * R_curr\n                elif potential_params[\"type\"] == \"identity_quadratic\":\n                    F_true = -R_curr\n                elif potential_params[\"type\"] == \"linear\":\n                    # For case 3, force depends on the mass-weighted tangent itself\n                    alpha = potential_params[\"alpha\"]\n                    # We must use the true mass-weighted tangent for the force definition\n                    F_true = alpha * M_sqrt @ tau_hat\n                \n                # --- 3. Compute perpendicular force component ---\n                if use_mass_weighting:\n                    eff_M_sqrt_force = M_sqrt_mat\n                    eff_M_inv_sqrt_force = M_inv_sqrt_mat\n                    proj_coeff = F_true.T @ eff_M_inv_sqrt_force @ tau_hat\n                    F_perp = F_true - proj_coeff * (eff_M_sqrt_force @ tau_hat)\n                else: # Standard (non-mass-weighted) projection\n                    proj_coeff = F_true.T @ tau_hat\n                    F_perp = F_true - proj_coeff * tau_hat\n\n                total_perp_force_norm += np.linalg.norm(F_perp)\n            \n            return total_perp_force_norm\n\n        # For Case 2, we need both mass-weighted and non-mass-weighted results\n        if case[\"id\"] == 2:\n            mw_sum = get_tangent_and_force(images_R, M_sqrt, M_inv_sqrt, case[\"potential\"], use_mass_weighting=True)\n            non_mw_sum = get_tangent_and_force(images_R, M_sqrt, M_inv_sqrt, case[\"potential\"], use_mass_weighting=False)\n            result = abs(mw_sum - non_mw_sum)\n        else:\n            result = get_tangent_and_force(images_R, M_sqrt, M_inv_sqrt, case[\"potential\"], use_mass_weighting=True)\n            \n        results.append(result)\n\n    # Format output as specified\n    formatted_results = [f\"{r:.10f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}