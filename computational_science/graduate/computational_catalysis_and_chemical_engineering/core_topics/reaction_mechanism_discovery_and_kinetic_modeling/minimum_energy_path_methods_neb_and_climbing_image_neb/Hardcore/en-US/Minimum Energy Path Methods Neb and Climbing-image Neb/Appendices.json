{
    "hands_on_practices": [
        {
            "introduction": "Before we can find a minimum energy path (MEP), it is valuable to understand the properties of the potential energy surface (PES) that define it. This exercise explores the local geometry of the PES near its minima, where the MEP direction is governed by the softest vibrational modes. By using the Hessian matrix , you will quantify how a simple linear interpolation deviates from the true MEP, providing crucial insight into why the \"nudging\" process of the NEB method is essential.",
            "id": "3888005",
            "problem": "A bimetallic catalyst mediates a surface reaction whose dominant collective variables can be approximated by two Cartesian coordinates. The pathway between the reactant minimum and the product minimum is sought using the Nudged Elastic Band (NEB) method and the Climbing-Image Nudged Elastic Band (CI-NEB) refinement. As an initial guess for NEB, a straight-line interpolation in Cartesian coordinates is constructed between the endpoint structures. Near a minimum on a potential energy surface, the energy can be approximated by a quadratic form determined by the Hessian matrix, and the local minimum energy path (MEP) direction corresponds to the direction of smallest curvature.\n\nConsider the following data:\n- Reactant minimum at Cartesian coordinates $\\mathbf{r}_{\\mathrm{R}} = (0, 0)$.\n- Product minimum at Cartesian coordinates $\\mathbf{r}_{\\mathrm{P}} = (1, 2)$.\n- Hessian at the reactant minimum\n$$\n\\mathbf{H}_{\\mathrm{R}} = \\begin{pmatrix}\n10 & 2 \\\\\n2 & 1\n\\end{pmatrix}.\n$$\n- Hessian at the product minimum\n$$\n\\mathbf{H}_{\\mathrm{P}} = \\begin{pmatrix}\n8 & -1 \\\\\n-1 & 3\n\\end{pmatrix}.\n$$\n\nThe initial path is the linear interpolation $\\mathbf{r}(s) = \\mathbf{r}_{\\mathrm{R}} + s\\,\\mathbf{d}$, where $\\mathbf{d} = \\mathbf{r}_{\\mathrm{P}} - \\mathbf{r}_{\\mathrm{R}}$ and $s \\in [0,1]$. Let $\\mathbf{t} = \\mathbf{d}/\\|\\mathbf{d}\\|$ denote the unit tangent of this path. Using the quadratic approximation to the potential energy near each minimum, define at each endpoint a dimensionless deviation factor as the ratio of the second-order energy curvature along $\\mathbf{t}$ to the smallest eigenvalue of the Hessian at that endpoint. Then define the overall deviation metric $D$ as the average of the two endpoint deviation factors.\n\nCompute the exact, closed-form analytic expression for $D$. Express your final answer as a single analytic expression and do not approximate or round.",
            "solution": "The Nudged Elastic Band (NEB) method constructs a series of images along a path between endpoints and relaxes them under forces that remove components along the path tangent, thereby approximating the minimum energy path (MEP). The Climbing-Image NEB (CI-NEB) further drives the highest-energy image uphill along the tangent and downhill perpendicular to locate the saddle point. To evaluate how a linear interpolation in Cartesian coordinates deviates from the local MEP near each minimum, we use the quadratic approximation of the potential energy surface and the Hessian matrices at the endpoints.\n\nNear a minimum at coordinate $\\mathbf{r}_{0}$ with Hessian $\\mathbf{H}$, the potential energy $V$ under a small displacement $\\Delta \\mathbf{r}$ can be approximated by\n$$\nV(\\mathbf{r}_{0} + \\Delta \\mathbf{r}) \\approx V(\\mathbf{r}_{0}) + \\frac{1}{2}\\,\\Delta \\mathbf{r}^{\\top}\\,\\mathbf{H}\\,\\Delta \\mathbf{r}.\n$$\nIf we consider displacements along a unit direction $\\mathbf{u}$ with scalar amplitude $s$, i.e., $\\Delta \\mathbf{r} = s\\,\\mathbf{u}$, then\n$$\nV(\\mathbf{r}_{0} + s\\,\\mathbf{u}) \\approx V(\\mathbf{r}_{0}) + \\frac{1}{2}\\,s^{2}\\,\\mathbf{u}^{\\top}\\,\\mathbf{H}\\,\\mathbf{u}.\n$$\nThe quantity $\\kappa(\\mathbf{u}) = \\mathbf{u}^{\\top}\\,\\mathbf{H}\\,\\mathbf{u}$ is the directional curvature. The local MEP departs along the eigenvector associated with the smallest eigenvalue of $\\mathbf{H}$, since this minimizes the second-order rise in energy. Therefore, a dimensionless deviation factor at an endpoint with Hessian $\\mathbf{H}$ for a chosen unit direction $\\mathbf{u}$ is\n$$\n\\delta = \\frac{\\mathbf{u}^{\\top}\\,\\mathbf{H}\\,\\mathbf{u}}{\\lambda_{\\min}},\n$$\nwhere $\\lambda_{\\min}$ is the smallest eigenvalue of $\\mathbf{H}$.\n\nWe are instructed to use the unit tangent $\\mathbf{t}$ of the linear interpolation path as the direction $\\mathbf{u}$. First, we compute the unit tangent $\\mathbf{t}$:\n$$\n\\mathbf{d} = \\mathbf{r}_{\\mathrm{P}} - \\mathbf{r}_{\\mathrm{R}} = (1, 2), \\quad \\|\\mathbf{d}\\| = \\sqrt{1^{2} + 2^{2}} = \\sqrt{5}, \\quad \\mathbf{t} = \\frac{1}{\\sqrt{5}}\\,(1, 2).\n$$\n\nNext, compute the directional curvature at the reactant endpoint:\n$$\n\\kappa_{\\mathrm{R}}(\\mathbf{t}) = \\mathbf{t}^{\\top}\\,\\mathbf{H}_{\\mathrm{R}}\\,\\mathbf{t}.\n$$\nEvaluate $\\mathbf{H}_{\\mathrm{R}}\\,\\mathbf{t}$:\n$$\n\\mathbf{H}_{\\mathrm{R}}\\,\\mathbf{t} = \n\\begin{pmatrix}\n10 & 2 \\\\\n2 & 1\n\\end{pmatrix}\n\\begin{pmatrix}\n\\frac{1}{\\sqrt{5}} \\\\\n\\frac{2}{\\sqrt{5}}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\frac{10 \\cdot 1 + 2 \\cdot 2}{\\sqrt{5}} \\\\\n\\frac{2 \\cdot 1 + 1 \\cdot 2}{\\sqrt{5}}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\frac{14}{\\sqrt{5}} \\\\\n\\frac{4}{\\sqrt{5}}\n\\end{pmatrix}.\n$$\nThen\n$$\n\\kappa_{\\mathrm{R}}(\\mathbf{t}) =\n\\begin{pmatrix}\n\\frac{1}{\\sqrt{5}} & \\frac{2}{\\sqrt{5}}\n\\end{pmatrix}\n\\begin{pmatrix}\n\\frac{14}{\\sqrt{5}} \\\\\n\\frac{4}{\\sqrt{5}}\n\\end{pmatrix}\n=\n\\frac{14}{5} + \\frac{8}{5} = \\frac{22}{5}.\n$$\n\nCompute the smallest eigenvalue of $\\mathbf{H}_{\\mathrm{R}}$. The characteristic polynomial is\n$$\n\\det\\!\\left(\\mathbf{H}_{\\mathrm{R}} - \\lambda \\mathbf{I}\\right) = \n\\begin{vmatrix}\n10 - \\lambda & 2 \\\\\n2 & 1 - \\lambda\n\\end{vmatrix}\n= (10 - \\lambda)(1 - \\lambda) - 4 = \\lambda^{2} - 11\\lambda + 6.\n$$\nThe eigenvalues are\n$$\n\\lambda_{\\mathrm{R},\\pm} = \\frac{11 \\pm \\sqrt{97}}{2}.\n$$\nThus the smallest eigenvalue is\n$$\n\\lambda_{\\mathrm{R},\\min} = \\frac{11 - \\sqrt{97}}{2}.\n$$\nTherefore, the reactant deviation factor is\n$$\n\\delta_{\\mathrm{R}} = \\frac{\\kappa_{\\mathrm{R}}(\\mathbf{t})}{\\lambda_{\\mathrm{R},\\min}} = \\frac{\\frac{22}{5}}{\\frac{11 - \\sqrt{97}}{2}} = \\frac{44}{5}\\,\\frac{1}{11 - \\sqrt{97}} = \\frac{44}{5(11 - \\sqrt{97})}.\n$$\n\nSimilarly, compute the directional curvature at the product endpoint:\n$$\n\\kappa_{\\mathrm{P}}(\\mathbf{t}) = \\mathbf{t}^{\\top}\\,\\mathbf{H}_{\\mathrm{P}}\\,\\mathbf{t}.\n$$\nEvaluate $\\mathbf{H}_{\\mathrm{P}}\\,\\mathbf{t}$:\n$$\n\\mathbf{H}_{\\mathrm{P}}\\,\\mathbf{t} = \n\\begin{pmatrix}\n8 & -1 \\\\\n-1 & 3\n\\end{pmatrix}\n\\begin{pmatrix}\n\\frac{1}{\\sqrt{5}} \\\\\n\\frac{2}{\\sqrt{5}}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\frac{8 \\cdot 1 + (-1) \\cdot 2}{\\sqrt{5}} \\\\\n\\frac{(-1) \\cdot 1 + 3 \\cdot 2}{\\sqrt{5}}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\frac{6}{\\sqrt{5}} \\\\\n\\frac{5}{\\sqrt{5}}\n\\end{pmatrix}.\n$$\nThen\n$$\n\\kappa_{\\mathrm{P}}(\\mathbf{t}) =\n\\begin{pmatrix}\n\\frac{1}{\\sqrt{5}} & \\frac{2}{\\sqrt{5}}\n\\end{pmatrix}\n\\begin{pmatrix}\n\\frac{6}{\\sqrt{5}} \\\\\n\\frac{5}{\\sqrt{5}}\n\\end{pmatrix}\n=\n\\frac{6}{5} + \\frac{10}{5} = \\frac{16}{5}.\n$$\n\nCompute the smallest eigenvalue of $\\mathbf{H}_{\\mathrm{P}}$. The characteristic polynomial is\n$$\n\\det\\!\\left(\\mathbf{H}_{\\mathrm{P}} - \\lambda \\mathbf{I}\\right) = \n\\begin{vmatrix}\n8 - \\lambda & -1 \\\\\n-1 & 3 - \\lambda\n\\end{vmatrix}\n= (8 - \\lambda)(3 - \\lambda) - 1 = \\lambda^{2} - 11\\lambda + 23.\n$$\nThe eigenvalues are\n$$\n\\lambda_{\\mathrm{P},\\pm} = \\frac{11 \\pm \\sqrt{29}}{2},\n$$\nso the smallest eigenvalue is\n$$\n\\lambda_{\\mathrm{P},\\min} = \\frac{11 - \\sqrt{29}}{2}.\n$$\nTherefore, the product deviation factor is\n$$\n\\delta_{\\mathrm{P}} = \\frac{\\kappa_{\\mathrm{P}}(\\mathbf{t})}{\\lambda_{\\mathrm{P},\\min}} = \\frac{\\frac{16}{5}}{\\frac{11 - \\sqrt{29}}{2}} = \\frac{32}{5}\\,\\frac{1}{11 - \\sqrt{29}} = \\frac{32}{5(11 - \\sqrt{29})}.\n$$\n\nThe overall deviation metric $D$ is the average of the two endpoint deviation factors:\n$$\nD = \\frac{\\delta_{\\mathrm{R}} + \\delta_{\\mathrm{P}}}{2} = \\frac{1}{2}\\left(\\frac{44}{5(11 - \\sqrt{97})} + \\frac{32}{5(11 - \\sqrt{29})}\\right) = \\frac{1}{10}\\left(\\frac{44}{11 - \\sqrt{97}} + \\frac{32}{11 - \\sqrt{29}}\\right).\n$$\nThis is the requested exact, closed-form analytic expression for $D$.",
            "answer": "$$\\boxed{\\frac{1}{10}\\left(\\frac{44}{11 - \\sqrt{97}} + \\frac{32}{11 - \\sqrt{29}}\\right)}$$"
        },
        {
            "introduction": "This practice moves from theory to algorithm construction, challenging you to implement the Nudged Elastic Band (NEB) and Climbing-Image NEB methods from first principles. Working with a model potential energy surface that mimics catalytic surface diffusion , you will discover the critical importance of the path tangent definition. This hands-on implementation will starkly illustrate why a naive tangent estimate can lead to instabilities and how an improved, energy-weighted tangent formulation ensures robust convergence to the MEP.",
            "id": "3888045",
            "problem": "You are given a corrugated two-dimensional potential energy surface intended to model a simplified surface diffusion barrier relevant to heterogeneous catalysis. The system consists of a coordinate vector $\\mathbf{r} = (x,y)$ and a scalar potential energy function $V(x,y)$ defined by\n$$\nV(x,y) = A\\,x^2(1-x)^2 + C_y\\,y^2 + B\\,\\cos(2\\pi y)\\,\\exp\\!\\left(-\\frac{(x-\\tfrac{1}{2})^2}{2\\sigma^2}\\right),\n$$\nwhere $A$, $B$, $C_y$, and $\\sigma$ are nonnegative constants. The minima of the unperturbed $x$-dependent part lie near $(x,y)=(0,0)$ and $(x,y)=(1,0)$, and the barrier region lies near $(x,y)\\approx(0.5,0)$, with corrugation along $y$ induced by the cosine term localized near $x\\approx 0.5$ via the Gaussian.\n\nStarting only from fundamental principles and core definitions, implement the discrete chain approximation to a Minimum Energy Path based on the Nudged Elastic Band (NEB) method and its climbing-image extension. The following fundamental base must be used:\n\n- The Minimum Energy Path (MEP) between two local minima is a curve $\\gamma(s)$ parameterized by arc length $s$ such that at each point on the curve, the force $\\mathbf{F}(\\mathbf{r})=-\\nabla V(\\mathbf{r})$ has no component perpendicular to the path, i.e., $\\mathbf{F}_{\\perp}=\\mathbf{F}-(\\mathbf{F}\\cdot \\hat{\\tau})\\hat{\\tau}=\\mathbf{0}$, where $\\hat{\\tau}$ is the unit tangent to the path.\n- In the discrete NEB method, the path is approximated by a set of $N$ images $\\{\\mathbf{r}_i\\}_{i=0}^{N-1}$ with fixed endpoints $\\mathbf{r}_0$ and $\\mathbf{r}_{N-1}$ at the two minima, connected by springs of constant $k$. The NEB force on interior image $i$ is given by $\\mathbf{F}_i=\\mathbf{F}_{\\perp,i}+\\mathbf{F}_{\\parallel,i}^{\\text{spring}}$, where $\\mathbf{F}_{\\perp,i}=-\\nabla V(\\mathbf{r}_i)+(\\nabla V(\\mathbf{r}_i)\\cdot \\hat{\\tau}_i)\\hat{\\tau}_i$ and $\\mathbf{F}_{\\parallel,i}^{\\text{spring}}=k\\left(\\|\\mathbf{r}_{i+1}-\\mathbf{r}_i\\|-\\|\\mathbf{r}_i-\\mathbf{r}_{i-1}\\|\\right)\\hat{\\tau}_i$.\n- The naive tangent uses $\\hat{\\tau}_i$ obtained by normalizing $(\\mathbf{r}_{i+1}-\\mathbf{r}_{i-1})$. The improved tangent of Henkelman and Jónsson chooses $\\hat{\\tau}_i$ using the local energy ordering to avoid kinks near maxima and minima. Let $\\Delta\\mathbf{r}^+=\\mathbf{r}_{i+1}-\\mathbf{r}_i$, $\\Delta\\mathbf{r}^-=\\mathbf{r}_i-\\mathbf{r}_{i-1}$, $\\Delta E^+=|E_{i+1}-E_i|$, and $\\Delta E^-=|E_{i-1}-E_i|$, where $E_j=V(\\mathbf{r}_j)$. Then\n$$\n\\hat{\\tau}_i \\propto \n\\begin{cases}\n\\Delta\\mathbf{r}^+ & \\text{if } E_{i+1}>E_i>E_{i-1},\\\\\n\\Delta\\mathbf{r}^- & \\text{if } E_{i+1}<E_i<E_{i-1},\\\\\n\\Delta\\mathbf{r}^+\\,\\Delta E^+ + \\Delta\\mathbf{r}^-\\,\\Delta E^- & \\text{if } E_{i+1}>E_i \\text{ and } E_{i-1}>E_i,\\\\\n\\Delta\\mathbf{r}^+\\,\\Delta E^- + \\Delta\\mathbf{r}^-\\,\\Delta E^+ & \\text{if } E_{i+1}<E_i \\text{ and } E_{i-1}<E_i,\n\\end{cases}\n$$\nand the resulting vector is normalized to unit length.\n- In the climbing-image NEB, the highest-energy interior image is made to ascend along the parallel component of the force while removing spring forces, $\\mathbf{F}_i^{\\text{CI}}=-\\nabla V(\\mathbf{r}_i)+2(\\nabla V(\\mathbf{r}_i)\\cdot \\hat{\\tau}_i)\\hat{\\tau}_i$, to converge directly to the saddle point.\n\nYour program must implement the following:\n\n1. Discretize and relax the NEB for both the naive tangent and the improved tangent using explicit time stepping with a fixed step size until a fixed number of iterations is reached. The endpoints must be fixed at the two minima located at $(x,y)=(0,0)$ and $(x,y)=(1,0)$.\n2. For the improved tangent case, also perform the climbing-image NEB by using the climbing-image force on the current highest-energy interior image at each step.\n3. Compute the true saddle point near $(x,y)=(0.5,0)$ by solving $\\nabla V(x,y)=\\mathbf{0}$ starting from $(x,y)=(0.5,0)$ and verifying that the Hessian has one positive and one negative eigenvalue at the solution. Use this as the ground truth barrier location and barrier energy.\n4. For each NEB variant, quantify barrier localization error as the Euclidean distance between the coordinates of the highest-energy image at convergence and the true saddle coordinates, and quantify barrier height error as the difference between the maximum image energy at convergence and the true saddle energy. All errors are dimensionless floats.\n5. Use the following test suite of parameter sets, designed to exercise a typical case, a strongly corrugated case, and a highly corrugated edge case:\n   - Case $\\mathrm{A}$: $(B,k,\\sigma,C_y,N,\\text{steps})=(0.5,1.0,0.08,3.0,15,800)$.\n   - Case $\\mathrm{B}$: $(B,k,\\sigma,C_y,N,\\text{steps})=(2.0,0.5,0.08,3.0,15,1000)$.\n   - Case $\\mathrm{C}$: $(B,k,\\sigma,C_y,N,\\text{steps})=(3.5,0.2,0.05,4.0,21,1200)$.\n   Use $A=1.0$ for all cases and a fixed explicit update step size of $0.02$ in dimensionless units.\n6. For each case, compute six floats in the following order: naive-tangent barrier localization error, improved-tangent barrier localization error, climbing-image barrier localization error, naive-tangent barrier height error, improved-tangent barrier height error, climbing-image barrier height error.\n\nYour program should produce a single line of output containing the results as a comma-separated list of bracketed lists in the order of the test suite, for example, \"[[a1,a2,a3,a4,a5,a6],[b1,b2,b3,b4,b5,b6],[c1,c2,c3,c4,c5,c6]]\". All numerals in the output are decimal floats. No physical units are required because all quantities are dimensionless. Angles, if any appear, must be treated in radians, but the potential uses a cosine with $2\\pi$ already specified, so no angle unit conversion is needed.",
            "solution": "The problem requires the implementation and comparison of the Nudged Elastic Band (NEB) method and its variants for determining the Minimum Energy Path (MEP) on a two-dimensional potential energy surface (PES). The solution is constructed from fundamental principles, starting with the definition of the PES and the MEP, and proceeding to the algorithmic realization of the discrete NEB approximation.\n\nThe potential energy surface, $V(\\mathbf{r})$, for a coordinate vector $\\mathbf{r} = (x,y)$ is given by:\n$$\nV(x,y) = A\\,x^2(1-x)^2 + C_y\\,y^2 + B\\,\\cos(2\\pi y)\\,\\exp\\!\\left(-\\frac{(x-\\tfrac{1}{2})^2}{2\\sigma^2}\\right)\n$$\nThe force on a particle at position $\\mathbf{r}$ is the negative gradient of the potential, $\\mathbf{F}(\\mathbf{r}) = -\\nabla V(\\mathbf{r})$. The components of the gradient are:\n$$\n\\frac{\\partial V}{\\partial x} = 2A x (1-x)(1-2x) - \\frac{B(x-\\tfrac{1}{2})}{\\sigma^2} \\cos(2\\pi y) \\exp\\!\\left(-\\frac{(x-\\tfrac{1}{2})^2}{2\\sigma^2}\\right)\n$$\n$$\n\\frac{\\partial V}{\\partial y} = 2C_y y - 2\\pi B \\sin(2\\pi y) \\exp\\!\\left(-\\frac{(x-\\tfrac{1}{2})^2}{2\\sigma^2}\\right)\n$$\n\nThe Minimum Energy Path (MEP) is a path $\\gamma(s)$ connecting two local minima (reactants and products) along which the force perpendicular to the path is zero at every point. This means the force vector is always parallel to the path's tangent vector, $\\hat{\\tau}$. A key point on the MEP is the saddle point, which corresponds to the maximum energy along the path and represents the transition state. A first-order saddle point is a critical point of the PES ($\\nabla V = \\mathbf{0}$) where the Hessian matrix of second derivatives has exactly one negative eigenvalue. To establish a ground truth for comparison, the true saddle point is located by numerically solving $\\nabla V(x,y) = \\mathbf{0}$ using a root-finding algorithm (e.g., Newton's method or a quasi-Newton method) and verifying the Hessian's eigenvalues.\n\nThe NEB method approximates the continuous MEP with a discrete chain of $N$ configurations, or \"images,\" $\\{\\mathbf{r}_i\\}_{i=0}^{N-1}$. The endpoints, $\\mathbf{r}_0$ and $\\mathbf{r}_{N-1}$, are fixed at the initial and final minima, in this case $(0,0)$ and $(1,0)$, respectively. The interior images, $\\{\\mathbf{r}_i\\}_{i=1}^{N-2}$, are relaxed to conform to the MEP. The relaxation is driven by a specially constructed \"NEB force.\" This force is a combination of the true force from the potential, $\\mathbf{F}_{\\text{true}, i} = -\\nabla V(\\mathbf{r}_i)$, and a fictitious spring force, $\\mathbf{F}_{\\text{spring}, i}$, that connects adjacent images.\n\nA crucial aspect of the NEB method is the projection of these forces. The component of the true force parallel to the path, $\\mathbf{F}_{\\parallel, i}^{\\text{true}} = (\\mathbf{F}_{\\text{true}, i} \\cdot \\hat{\\tau}_i)\\hat{\\tau}_i$, causes images to slide down the MEP, while the perpendicular component, $\\mathbf{F}_{\\perp, i}^{\\text{true}} = \\mathbf{F}_{\\text{true}, i} - \\mathbf{F}_{\\parallel, i}^{\\text{true}}$, pulls the image onto the MEP. To prevent kinking and ensure stable convergence, the NEB method uses only the perpendicular component of the true force. Conversely, the spring force is used only in its component parallel to the path, $\\mathbf{F}_{\\parallel, i}^{\\text{spring}}$, to ensure uniform spacing of images. The total NEB optimization force on image $i$ is thus:\n$$\n\\mathbf{F}_i = \\mathbf{F}_{\\perp, i}^{\\text{true}} + \\mathbf{F}_{\\parallel, i}^{\\text{spring}}\n$$\nSubstituting the definitions gives:\n$$\n\\mathbf{F}_i = \\left(-\\nabla V(\\mathbf{r}_i) + (\\nabla V(\\mathbf{r}_i) \\cdot \\hat{\\tau}_i)\\hat{\\tau}_i\\right) + k\\left(\\|\\mathbf{r}_{i+1}-\\mathbf{r}_i\\|-\\|\\mathbf{r}_i-\\mathbf{r}_{i-1}\\|\\right)\\hat{\\tau}_i\n$$\nThe tangent vector $\\hat{\\tau}_i$ is central to this projection. Its estimation is critical.\n1.  **Naive Tangent**: The simplest estimate is a central difference scheme, normalized: $\\hat{\\tau}_i \\propto \\mathbf{r}_{i+1} - \\mathbf{r}_{i-1}$. This method can suffer from \"kinks\" in the path, where the tangent estimate is poor, leading to instabilities.\n2.  **Improved Tangent**: To mitigate kinking, a more robust tangent is constructed using local energy information. As specified, the tangent $\\hat{\\tau}_i$ is defined piecewise. If the image $i$ is on a monotonic section of the path ($E_{i+1}>E_i>E_{i-1}$ or $E_{i+1}<E_i<E_{i-1}$), the tangent is taken from the uphill direction only. If image $i$ is at a local extremum relative to its neighbors, a weighted average of the forward segment, $\\Delta\\mathbf{r}^+ = \\mathbf{r}_{i+1}-\\mathbf{r}_i$, and backward segment, $\\Delta\\mathbf{r}^- = \\mathbf{r}_i-\\mathbf{r}_{i-1}$, is used. The weighting is based on the energy differences $\\Delta E^+ = |E_{i+1}-E_i|$ and $\\Delta E^- = |E_i-E_{i-1}|$, as per the rules provided. This prevents the tangent from being dominated by one segment during sharp turns or near the saddle point.\n\nThe **Climbing-Image NEB (CI-NEB)** is a modification to converge the highest-energy image precisely onto the saddle point. In this method, after an initial relaxation, the NEB force on the image with the highest potential energy is replaced. The spring force on this image is set to zero, and the parallel component of the true force is inverted to push the image \"uphill\" along the MEP. The climbing-image force is:\n$$\n\\mathbf{F}_i^{\\text{CI}} = -\\nabla V(\\mathbf{r}_i) + 2(\\nabla V(\\mathbf{r}_i) \\cdot \\hat{\\tau}_i)\\hat{\\tau}_i = \\mathbf{F}_{\\perp, i}^{\\text{true}} - \\mathbf{F}_{\\parallel, i}^{\\text{true}}\n$$\nThis modification ensures that one image converges to the saddle point, providing a more accurate barrier height and location without requiring a dense chain of images.\n\nThe algorithmic implementation for all three variants (naive, improved, and climbing-image) proceeds as follows. First, the chain of images is initialized as a linear interpolation between the fixed endpoints. Then, for a specified number of steps, the system is evolved using an explicit Euler time-stepping scheme: $\\mathbf{r}_i(t+\\Delta t) = \\mathbf{r}_i(t) + \\Delta t \\cdot \\mathbf{F}_i(t)$, where $\\mathbf{F}_i(t)$ is the appropriate NEB or CI-NEB force for image $i$ at time $t$. The forces for all images at a given step are calculated based on the positions at that step before any updates are made. For the CI-NEB, the improved tangent is used, and the highest-energy image is identified at each step to apply the climbing force.\n\nFinally, the accuracy of each method is evaluated by comparing the highest-energy image in the converged chain to the true saddle point. The barrier localization error is the Euclidean distance between their positions, and the barrier height error is the difference in their potential energies. These metrics quantify how well each algorithm approximates the true transition state under the given parameters.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import root\n\ndef solve():\n    \"\"\"\n    Main solver function to run NEB simulations and compute errors.\n    \"\"\"\n    # Test cases: (B, k, sigma, C_y, N, steps)\n    test_cases = [\n        (0.5, 1.0, 0.08, 3.0, 15, 800),\n        (2.0, 0.5, 0.08, 3.0, 15, 1000),\n        (3.5, 0.2, 0.05, 4.0, 21, 1200)\n    ]\n    A = 1.0\n    DT = 0.02\n    \n    final_results = []\n\n    for case in test_cases:\n        B, k, sigma, C_y, N, steps = case\n\n        # 1. Potential Energy Surface and its derivatives\n        def potential(r, A, B, C_y, sigma):\n            x, y = r\n            gauss_term = np.exp(-(x - 0.5)**2 / (2 * sigma**2))\n            return A * x**2 * (1 - x)**2 + C_y * y**2 + B * np.cos(2 * np.pi * y) * gauss_term\n\n        def gradient(r, A, B, C_y, sigma):\n            x, y = r\n            gauss_term = np.exp(-(x - 0.5)**2 / (2 * sigma**2))\n            \n            dV_dx = 2 * A * x * (1 - x) * (1 - 2 * x) - \\\n                    B * np.cos(2 * np.pi * y) * gauss_term * (x - 0.5) / sigma**2\n            \n            dV_dy = 2 * C_y * y - 2 * np.pi * B * np.sin(2 * np.pi * y) * gauss_term\n            \n            return np.array([dV_dx, dV_dy])\n\n        def hessian(r, A, B, C_y, sigma):\n            x, y = r\n            gauss_term = np.exp(-(x - 0.5)**2 / (2 * sigma**2))\n            \n            Vxx = 2*A*(1 - 6*x + 6*x**2) - B*np.cos(2*np.pi*y)*gauss_term * \\\n                 (1/sigma**2 - (x-0.5)**2 / sigma**4)\n            \n            Vyy = 2*C_y - 4*np.pi**2*B*np.cos(2*np.pi*y)*gauss_term\n            \n            Vxy = 2*np.pi*B*np.sin(2*np.pi*y)*gauss_term * (x-0.5)/sigma**2\n            return np.array([[Vxx, Vxy], [Vxy, Vyy]])\n\n        # 2. Find True Saddle Point\n        def find_true_saddle(A, B, C_y, sigma):\n            grad_func = lambda r: gradient(r, A, B, C_y, sigma)\n            # Initial guess near the expected saddle point off the y=0 axis.\n            initial_guess = np.array([0.5, 0.1])\n            sol = root(grad_func, initial_guess)\n            saddle_pos = sol.x\n\n            # Verify it's a saddle point\n            H = hessian(saddle_pos, A, B, C_y, sigma)\n            eigenvalues = np.linalg.eigvals(H)\n            if not(np.sum(eigenvalues  0) == 1 and np.sum(eigenvalues > 0) == 1):\n                # Fallback to a different guess if bifurcation is not pronounced\n                initial_guess_2 = np.array([0.5, 0.0])\n                sol = root(grad_func, initial_guess_2)\n                saddle_pos = sol.x\n            \n            saddle_energy = potential(saddle_pos, A, B, C_y, sigma)\n            return saddle_pos, saddle_energy\n        \n        true_saddle_pos, true_saddle_energy = find_true_saddle(A, B, C_y, sigma)\n\n        # 3. NEB Implementation\n        def get_tangent(i, chain, energies, tangent_type):\n            r_im1, r_i, r_ip1 = chain[i-1], chain[i], chain[i+1]\n            E_im1, E_i, E_ip1 = energies[i-1], energies[i], energies[i+1]\n\n            if tangent_type == 'naive':\n                tangent_vec = r_ip1 - r_im1\n            elif tangent_type == 'improved':\n                dr_plus = r_ip1 - r_i\n                dr_minus = r_i - r_im1\n                \n                if E_ip1 > E_i > E_im1:\n                    tangent_vec = dr_plus\n                elif E_ip1  E_i  E_im1:\n                    tangent_vec = dr_minus\n                else:\n                    dE_plus = abs(E_ip1 - E_i)\n                    dE_minus = abs(E_i - E_im1)\n                    if E_ip1 > E_i and E_im1 > E_i: # Local minimum\n                        tangent_vec = dr_plus * dE_plus + dr_minus * dE_minus\n                    elif E_ip1  E_i and E_im1  E_i: # Local maximum\n                        tangent_vec = dr_plus * dE_minus + dr_minus * dE_plus\n                    else: # One side up, one side down, from a plateau\n                         # Simplified from original paper for intermediate cases\n                         tangent_vec = dr_plus+dr_minus\n            else:\n                 raise ValueError(\"Invalid tangent_type\")\n\n            norm = np.linalg.norm(tangent_vec)\n            return tangent_vec / norm if norm > 1e-9 else np.zeros(2)\n\n        def run_neb_step(chain, k, tangent_type, use_climbing_image):\n            N_chain = len(chain)\n            energies = np.array([potential(r, A, B, C_y, sigma) for r in chain])\n            forces = np.zeros_like(chain)\n\n            climbing_idx = -1\n            if use_climbing_image and N_chain > 2:\n                climbing_idx = np.argmax(energies[1:-1]) + 1\n            \n            for i in range(1, N_chain - 1):\n                tangent = get_tangent(i, chain, energies, tangent_type)\n                \n                grad_V = gradient(chain[i], A, B, C_y, sigma)\n                F_true = -grad_V\n                \n                if use_climbing_image and i == climbing_idx:\n                    # Climbing-image force (project gradient, invert parallel component)\n                    F_climb = F_true - 2 * np.dot(F_true, tangent) * tangent\n                    forces[i] = F_climb\n                else:\n                    # Standard NEB force\n                    F_perp = F_true - np.dot(F_true, tangent) * tangent\n                    \n                    d_plus = np.linalg.norm(chain[i+1] - chain[i])\n                    d_minus = np.linalg.norm(chain[i] - chain[i-1])\n                    F_spring_parallel = k * (d_plus - d_minus) * tangent\n                    \n                    forces[i] = F_perp + F_spring_parallel\n            \n            chain[1:-1] += DT * forces[1:-1]\n\n        # Initialize chains\n        initial_chain = np.linspace([0.0, 0.0], [1.0, 0.0], N, dtype=np.float64)\n        chain_naive = initial_chain.copy()\n        chain_improved = initial_chain.copy()\n        chain_ci = initial_chain.copy()\n\n        # Run simulations\n        for _ in range(steps):\n            run_neb_step(chain_naive, k=k, tangent_type='naive', use_climbing_image=False)\n            run_neb_step(chain_improved, k=k, tangent_type='improved', use_climbing_image=False)\n            run_neb_step(chain_ci, k=k, tangent_type='improved', use_climbing_image=True)\n\n        # 4. Calculate errors\n        def calculate_errors(chain, true_pos, true_energy):\n            energies = np.array([potential(r, A, B, C_y, sigma) for r in chain])\n            max_energy_idx = np.argmax(energies)\n            \n            max_energy_pos = chain[max_energy_idx]\n            max_energy_val = energies[max_energy_idx]\n            \n            loc_error = np.linalg.norm(max_energy_pos - true_pos)\n            height_error = max_energy_val - true_energy\n            return loc_error, height_error\n\n        loc_err_n, height_err_n = calculate_errors(chain_naive, true_saddle_pos, true_saddle_energy)\n        loc_err_i, height_err_i = calculate_errors(chain_improved, true_saddle_pos, true_saddle_energy)\n        loc_err_c, height_err_c = calculate_errors(chain_ci, true_saddle_pos, true_saddle_energy)\n\n        case_results = [\n            loc_err_n, loc_err_i, loc_err_c,\n            height_err_n, height_err_i, height_err_c\n        ]\n        final_results.append(case_results)\n\n    # 5. Format and print output\n    # Desired format: [[a1,...,a6],[b1,...,b6],[c1,...,c6]]\n    output_str = \"[\"\n    for i, res_list in enumerate(final_results):\n        output_str += \"[\" + \",\".join(map(str, res_list)) + \"]\"\n        if i  len(final_results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    \n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "A purely geometric path on a potential energy surface may not represent the most probable trajectory for a real chemical system, where atomic masses play a key role. This advanced practice introduces the physically crucial concept of mass-weighted coordinates to the NEB framework . By deriving and implementing the necessary transformations for forces and tangents, you will learn how to find a path that is more relevant to true reaction dynamics, deepening your understanding of the MEP's role in theoretical kinetics.",
            "id": "3888040",
            "problem": "You are given a discrete path of images in configuration space connecting two states of an atomistic system and asked to compute the minimum-energy-path geometrical ingredients used by the Nudged Elastic Band (NEB) method under a change of variables to mass-weighted coordinates. Work in a finite-dimensional Euclidean space with coordinates collected into a single column vector $\\,\\mathbf{R}\\in\\mathbb{R}^{n}\\,$ that stacks all Cartesian coordinates of all atoms. Let the diagonal mass matrix be $\\,\\mathbf{M}=\\mathrm{diag}(m_{1},m_{1},\\dots,m_{1},m_{2},m_{2},\\dots)\\,$ where each atomic mass $\\,m_{a}0\\,$ is repeated for each of its Cartesian components. Define mass-weighted coordinates by $\\,\\tilde{\\mathbf{R}}=\\mathbf{M}^{1/2}\\mathbf{R}\\,$.\n\n- A discrete path is a sequence of images $\\,\\{\\mathbf{R}_{0},\\mathbf{R}_{1},\\dots,\\mathbf{R}_{K-1}\\}\\,$ with $\\,K\\ge 3\\,$. Internal images are indexed by $\\,i\\in\\{1,\\dots,K-2\\}\\,$.\n- The physical potential energy is a scalar function $\\,V(\\mathbf{R})\\,$ with gradient $\\,\\nabla_{\\mathbf{R}}V(\\mathbf{R})\\,$. The true force is $\\,\\mathbf{F}^{\\mathrm{true}}(\\mathbf{R})=-\\nabla_{\\mathbf{R}}V(\\mathbf{R})\\,$.\n- In standard NEB, one uses a unit tangent $\\,\\hat{\\boldsymbol{\\tau}}_{i}\\,$ at each internal image to define a projection of the true force orthogonal to the path. In this problem, the unit tangent is to be constructed in mass-weighted coordinates and orthogonality is to be understood with respect to the Euclidean inner product in the mass-weighted space.\n\nYour tasks:\n\n1) Starting only from multivariable calculus change-of-variables, linear algebra of diagonal scalings, and the NEB definition of tangent and projected force, derive the following in a coordinate-free but computable form:\n- The relation between the unit tangent in mass-weighted coordinates $\\,\\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}\\,$ and the discrete images. Use the symmetric finite-difference construction in mass-weighted space: differences $\\,\\Delta\\tilde{\\mathbf{R}}^{+}_{i}=\\tilde{\\mathbf{R}}_{i+1}-\\tilde{\\mathbf{R}}_{i}\\,$ and $\\,\\Delta\\tilde{\\mathbf{R}}^{-}_{i}=\\tilde{\\mathbf{R}}_{i}-\\tilde{\\mathbf{R}}_{i-1}\\,$, unit vectors $\\,\\hat{\\mathbf{u}}^{\\pm}_{i}=\\Delta\\tilde{\\mathbf{R}}^{\\pm}_{i}/\\lVert\\Delta\\tilde{\\mathbf{R}}^{\\pm}_{i}\\rVert\\,$ (whenever the denominator is nonzero), and raw tangent $\\,\\tilde{\\boldsymbol{\\tau}}^{\\mathrm{raw}}_{i}=\\hat{\\mathbf{u}}^{+}_{i}+\\hat{\\mathbf{u}}^{-}_{i}\\,$ with normalization $\\,\\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}=\\tilde{\\boldsymbol{\\tau}}^{\\mathrm{raw}}_{i}/\\lVert\\tilde{\\boldsymbol{\\tau}}^{\\mathrm{raw}}_{i}\\rVert\\,$ when $\\,\\lVert\\tilde{\\boldsymbol{\\tau}}^{\\mathrm{raw}}_{i}\\rVert0\\,$. In degenerate cases where both neighbor differences vanish, the tangent is undefined; in this problem, define it to be the zero vector.\n- The transformation rule for the true force under the change of variables $\\,\\tilde{\\mathbf{R}}=\\mathbf{M}^{1/2}\\mathbf{R}\\,$ and the expression for the component of the true force perpendicular to the tangent when orthogonality is defined in the mass-weighted Euclidean space. Your final expression must be an explicit computable formula for the perpendicular force back in the original coordinates $\\,\\mathbf{R}\\,$ in terms of $\\,\\mathbf{M}\\,$, $\\,\\mathbf{F}^{\\mathrm{true}}(\\mathbf{R}_{i})\\,$, and $\\,\\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}\\,$.\n\n2) Implement a program that:\n- Accepts no input and constructs the four test cases below internally. All quantities are dimensionless.\n- For each case, builds $\\,\\mathbf{M}\\,$ from a list of atomic masses, constructs $\\,\\tilde{\\mathbf{R}}_{j}=\\mathbf{M}^{1/2}\\mathbf{R}_{j}\\,$, computes $\\,\\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}\\,$ at each internal image using the symmetric mass-weighted differences defined above (use the convention that if a norm is smaller than $\\,\\varepsilon=10^{-12}\\,$, treat it as zero), evaluates $\\,\\mathbf{F}^{\\mathrm{true}}(\\mathbf{R}_{i})\\,$, forms the mass-weighted perpendicular component at each internal image, maps it back to $\\,\\mathbf{R}$-space, and returns the sum over internal images of the Euclidean norms of these perpendicular components.\n- Additionally, for Case $\\,2\\,$, compute the same sum using the standard, non-mass-weighted tangent in $\\,\\mathbf{R}$-space and report the absolute difference between the mass-weighted and non-mass-weighted sums.\n\n3) Use the following test suite. In all cases the spatial dimension per atom is $\\,D=2\\,$, so that if there are $\\,A\\,$ atoms there are $\\,n=2A\\,$ coordinates per image. Each image is provided as a flat list $\\,\\mathbf{R}=[x_{1},y_{1},x_{2},y_{2},\\dots]\\,$.\n- Case $\\,1$ (happy path, unequal masses and anisotropic quadratic potential): masses $\\,\\{1,16\\}\\,$; images $\\,\\mathbf{R}_{0}=[0,0,1,-1]\\,$, $\\,\\mathbf{R}_{1}=[\\tfrac{1}{2},\\tfrac{1}{2},\\tfrac{1}{2},-\\tfrac{1}{2}]\\,$, $\\,\\mathbf{R}_{2}=[1,1,0,0]\\,$; potential $\\,V(\\mathbf{R})=\\tfrac{1}{2}\\sum_{k=1}^{4}a_{k}R_{k}^{2}\\,$ with coefficients $\\,a=[1,2,3,4]\\,$.\n- Case $\\,2$ (consistency check, equal masses): masses $\\,\\{5,5\\}\\,$; images and potential as in Case $\\,1\\,$. Return a single float equal to the absolute difference between the mass-weighted and non-mass-weighted sums of perpendicular-force norms over internal images.\n- Case $\\,3$ (boundary where the perpendicular component should vanish): masses $\\,\\{2,1\\}\\,$; images $\\,\\mathbf{R}_{0}=[0,1,0,0]\\,$, $\\,\\mathbf{R}_{1}=[1,2,1,0]\\,$, $\\,\\mathbf{R}_{2}=[2,3,2,0]\\,$; use a linear potential $\\,V(\\mathbf{R})=-\\boldsymbol{c}^{\\top}\\mathbf{R}\\,$ with constant gradient $\\,\\nabla_{\\mathbf{R}}V(\\mathbf{R})=-\\boldsymbol{c}\\,$ chosen so that the true force $\\,\\mathbf{F}^{\\mathrm{true}}(\\mathbf{R})=\\boldsymbol{c}\\,$ is exactly parallel to the mass-weighted unit tangent at the internal image. Concretely, let $\\,\\boldsymbol{c}=\\alpha\\,\\mathbf{M}^{1/2}\\hat{\\tilde{\\boldsymbol{\\tau}}}_{1}\\,$ with $\\,\\alpha=3.14\\,$ (a dimensionless constant). Report the sum of perpendicular-force norms; it should be numerically zero.\n- Case $\\,4$ (degenerate tangent, identical neighboring images): masses $\\,\\{3,7\\}\\,$; images $\\,\\mathbf{R}_{0}=\\mathbf{R}_{1}=\\mathbf{R}_{2}=[1,-1,2,-2]\\,$; potential $\\,V(\\mathbf{R})=\\tfrac{1}{2}\\,\\mathbf{R}^{\\top}\\mathbf{R}\\,$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for Cases $\\,1\\,$–$\\,4\\,$ as a comma-separated list of floats enclosed in square brackets, for example $\\,\\,[r_{1},r_{2},r_{3},r_{4}]\\,\\,$. Round each float to $\\,10\\,$ decimal places in the printed output. No units are required because all quantities are dimensionless and angles are not involved.",
            "solution": "The problem statement is evaluated to be scientifically grounded, well-posed, and an objective exercise in applying principles of multivariable calculus and linear algebra to the Nudged Elastic Band (NEB) method. The required physical and mathematical concepts, such as potential energy, force, mass-weighted coordinates, and vector projections, are standard in computational physics and chemistry. All definitions are precise, and the provided test cases are self-contained and suitable for verifying the derived formulae. The problem is therefore deemed **valid**, and a solution is provided below.\n\nThis solution is presented in two parts as requested: first, the derivation of the necessary mathematical expressions, and second, the implementation of these expressions for the given test cases.\n\n### Part 1: Derivations\n\nThe problem requires the derivation of two quantities for a discrete path of images $\\{\\mathbf{R}_{0}, \\mathbf{R}_{1}, \\dots, \\mathbf{R}_{K-1}\\}$: the unit tangent vector in mass-weighted coordinates, $\\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}$, and the component of the true force perpendicular to this tangent, mapped back to the original coordinate system.\n\nLet $\\mathbf{R} \\in \\mathbb{R}^{n}$ be the vector of Cartesian coordinates. The mass matrix $\\mathbf{M}$ is a diagonal matrix of atomic masses. The mass-weighted coordinates $\\tilde{\\mathbf{R}}$ are defined by the linear transformation:\n$$\n\\tilde{\\mathbf{R}} = \\mathbf{M}^{1/2}\\mathbf{R}\n$$\nwhere $\\mathbf{M}^{1/2}$ is the diagonal matrix whose entries are the square roots of the corresponding entries in $\\mathbf{M}$. Since $\\mathbf{M}$ is diagonal and its entries are positive, $\\mathbf{M}^{1/2}$ is real, diagonal, and symmetric, i.e., $(\\mathbf{M}^{1/2})^\\top = \\mathbf{M}^{1/2}$. The inverse transformation is $\\mathbf{R} = \\mathbf{M}^{-1/2}\\tilde{\\mathbf{R}}$.\n\n**1. Unit Tangent in Mass-Weighted Coordinates, $\\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}$**\n\nThe unit tangent $\\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}$ at an internal image $\\tilde{\\mathbf{R}}_{i}$ is constructed using a symmetric finite-difference scheme in the mass-weighted space.\n\nFirst, we define the forward and backward difference vectors in mass-weighted coordinates:\n$$\n\\Delta\\tilde{\\mathbf{R}}^{+}_{i} = \\tilde{\\mathbf{R}}_{i+1} - \\tilde{\\mathbf{R}}_{i} = \\mathbf{M}^{1/2}\\mathbf{R}_{i+1} - \\mathbf{M}^{1/2}\\mathbf{R}_{i} = \\mathbf{M}^{1/2}(\\mathbf{R}_{i+1} - \\mathbf{R}_{i})\n$$\n$$\n\\Delta\\tilde{\\mathbf{R}}^{-}_{i} = \\tilde{\\mathbf{R}}_{i} - \\tilde{\\mathbf{R}}_{i-1} = \\mathbf{M}^{1/2}\\mathbf{R}_{i} - \\mathbf{M}^{1/2}\\mathbf{R}_{i-1} = \\mathbf{M}^{1/2}(\\mathbf{R}_{i} - \\mathbf{R}_{i-1})\n$$\nNext, we normalize these vectors to obtain unit vectors $\\hat{\\mathbf{u}}^{+}_{i}$ and $\\hat{\\mathbf{u}}^{-}_{i}$, provided the corresponding norms are non-zero. The norm used is the standard Euclidean norm in the $\\tilde{\\mathbf{R}}$-space.\n$$\n\\hat{\\mathbf{u}}^{\\pm}_{i} = \\frac{\\Delta\\tilde{\\mathbf{R}}^{\\pm}_{i}}{\\lVert\\Delta\\tilde{\\mathbf{R}}^{\\pm}_{i}\\rVert}\n$$\nThe raw tangent vector, $\\tilde{\\boldsymbol{\\tau}}^{\\mathrm{raw}}_{i}$, is the sum of these unit vectors:\n$$\n\\tilde{\\boldsymbol{\\tau}}^{\\mathrm{raw}}_{i} = \\hat{\\mathbf{u}}^{+}_{i} + \\hat{\\mathbf{u}}^{-}_{i}\n$$\nFinally, the unit tangent vector $\\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}$ is obtained by normalizing the raw tangent vector, again provided its norm is non-zero:\n$$\n\\hat{\\tilde{\\boldsymbol{\\tau}}}_{i} = \\frac{\\tilde{\\boldsymbol{\\tau}}^{\\mathrm{raw}}_{i}}{\\lVert\\tilde{\\boldsymbol{\\tau}}^{\\mathrm{raw}}_{i}\\rVert}\n$$\nIn cases where any norm is zero (or below a numerical threshold $\\varepsilon$), the corresponding normalized vector is taken to be the zero vector. Specifically, if $\\lVert\\Delta\\tilde{\\mathbf{R}}^{\\pm}_{i}\\rVert  \\varepsilon$, we define $\\hat{\\mathbf{u}}^{\\pm}_{i} = \\mathbf{0}$. Consequently, if $\\tilde{\\boldsymbol{\\tau}}^{\\mathrm{raw}}_{i}$ is the zero vector (which occurs if both $\\hat{\\mathbf{u}}^{+}_{i}$ and $\\hat{\\mathbf{u}}^{-}_{i}$ are zero, as per the problem's degenerate case definition), then $\\hat{\\tilde{\\boldsymbol{\\tau}}}_{i} = \\mathbf{0}$. This set of equations constitutes a computable definition for $\\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}$ in terms of the images $\\mathbf{R}_{j}$ and the mass matrix $\\mathbf{M}$.\n\n**2. Perpendicular Force Component**\n\nThe true force on the system is the negative gradient of the potential energy $V(\\mathbf{R})$:\n$$\n\\mathbf{F}^{\\mathrm{true}}(\\mathbf{R}) = -\\nabla_{\\mathbf{R}}V(\\mathbf{R})\n$$\nTo find the force in mass-weighted coordinates, $\\tilde{\\mathbf{F}}^{\\mathrm{true}}(\\tilde{\\mathbf{R}})$, we apply the chain rule for gradients. The gradient operator transforms as $\\nabla_{\\tilde{\\mathbf{R}}} = (\\frac{\\partial\\mathbf{R}}{\\partial\\tilde{\\mathbf{R}}})^\\top \\nabla_{\\mathbf{R}}$. The Jacobian of the transformation $\\mathbf{R}(\\tilde{\\mathbf{R}})$ is $\\frac{\\partial\\mathbf{R}}{\\partial\\tilde{\\mathbf{R}}} = \\mathbf{M}^{-1/2}$. Since $\\mathbf{M}^{-1/2}$ is symmetric, we have:\n$$\n\\nabla_{\\tilde{\\mathbf{R}}} = \\mathbf{M}^{-1/2} \\nabla_{\\mathbf{R}}\n$$\nThe force in the new coordinates is thus:\n$$\n\\tilde{\\mathbf{F}}^{\\mathrm{true}}(\\tilde{\\mathbf{R}}) = -\\nabla_{\\tilde{\\mathbf{R}}}V(\\mathbf{R}(\\tilde{\\mathbf{R}})) = -\\mathbf{M}^{-1/2}\\nabla_{\\mathbf{R}}V = \\mathbf{M}^{-1/2}\\mathbf{F}^{\\mathrm{true}}(\\mathbf{R})\n$$\nSo, for the $i$-th image, we have $\\tilde{\\mathbf{F}}^{\\mathrm{true}}_{i} = \\mathbf{M}^{-1/2}\\mathbf{F}^{\\mathrm{true}}_{i}$.\n\nThe NEB force component perpendicular to the path is defined by removing the component parallel to the tangent. In the mass-weighted space, this is a standard orthogonal projection. The component of $\\tilde{\\mathbf{F}}^{\\mathrm{true}}_{i}$ parallel to $\\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}$ is:\n$$\n\\tilde{\\mathbf{F}}_{i, \\parallel} = (\\tilde{\\mathbf{F}}^{\\mathrm{true}}_{i} \\cdot \\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}) \\hat{\\tilde{\\boldsymbol{\\tau}}}_{i} = ((\\tilde{\\mathbf{F}}^{\\mathrm{true}}_{i})^\\top \\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}) \\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}\n$$\nThe perpendicular component in mass-weighted space is:\n$$\n\\tilde{\\mathbf{F}}_{i, \\perp} = \\tilde{\\mathbf{F}}^{\\mathrm{true}}_{i} - \\tilde{\\mathbf{F}}_{i, \\parallel} = \\tilde{\\mathbf{F}}^{\\mathrm{true}}_{i} - ((\\tilde{\\mathbf{F}}^{\\mathrm{true}}_{i})^\\top \\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}) \\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}\n$$\nThe problem asks for this force component expressed back in the original $\\mathbf{R}$-coordinates. We must establish the transformation rule for a force vector from $\\tilde{\\mathbf{R}}$-space to $\\mathbf{R}$-space. A force vector transforms such that the work done, $dW = \\mathbf{F}^\\top d\\mathbf{R}$, is invariant. Let $\\mathbf{F}_{i, \\perp}^{\\text{R-space}}$ be the desired force in $\\mathbf{R}$-space.\n$$\ndW = (\\mathbf{F}_{i, \\perp}^{\\text{R-space}})^\\top d\\mathbf{R} = (\\tilde{\\mathbf{F}}_{i, \\perp})^\\top d\\tilde{\\mathbf{R}}\n$$\nSubstituting $d\\tilde{\\mathbf{R}} = \\mathbf{M}^{1/2}d\\mathbf{R}$, we get:\n$$\n(\\mathbf{F}_{i, \\perp}^{\\text{R-space}})^\\top d\\mathbf{R} = (\\tilde{\\mathbf{F}}_{i, \\perp})^\\top \\mathbf{M}^{1/2} d\\mathbf{R} = (\\mathbf{M}^{1/2}\\tilde{\\mathbf{F}}_{i, \\perp})^\\top d\\mathbf{R}\n$$\nAs this must hold for any infinitesimal displacement $d\\mathbf{R}$, we find the transformation rule:\n$$\n\\mathbf{F}_{i, \\perp}^{\\text{R-space}} = \\mathbf{M}^{1/2}\\tilde{\\mathbf{F}}_{i, \\perp}\n$$\nNow we substitute the expressions for $\\tilde{\\mathbf{F}}_{i, \\perp}$ and $\\tilde{\\mathbf{F}}^{\\mathrm{true}}_{i}$:\n$$\n\\mathbf{F}_{i, \\perp}^{\\text{R-space}} = \\mathbf{M}^{1/2} \\left[ \\tilde{\\mathbf{F}}^{\\mathrm{true}}_{i} - ((\\tilde{\\mathbf{F}}^{\\mathrm{true}}_{i})^\\top \\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}) \\hat{\\tilde{\\boldsymbol{\\tau}}}_{i} \\right] \\\\\n= \\mathbf{M}^{1/2} \\left[ \\mathbf{M}^{-1/2}\\mathbf{F}^{\\mathrm{true}}_{i} - ((\\mathbf{M}^{-1/2}\\mathbf{F}^{\\mathrm{true}}_{i})^\\top \\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}) \\hat{\\tilde{\\boldsymbol{\\tau}}}_{i} \\right]\n$$\nDistributing $\\mathbf{M}^{1/2}$ yields:\n$$\n\\mathbf{F}_{i, \\perp}^{\\text{R-space}} = \\mathbf{M}^{1/2}\\mathbf{M}^{-1/2}\\mathbf{F}^{\\mathrm{true}}_{i} - ((\\mathbf{F}^{\\mathrm{true}}_{i})^\\top (\\mathbf{M}^{-1/2})^\\top \\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}) \\mathbf{M}^{1/2}\\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}\n$$\nUsing $\\mathbf{M}^{1/2}\\mathbf{M}^{-1/2}=\\mathbf{I}$ and $(\\mathbf{M}^{-1/2})^\\top = \\mathbf{M}^{-1/2}$, we arrive at the final explicit formula:\n$$\n\\mathbf{F}_{i, \\perp}^{\\text{R-space}} = \\mathbf{F}^{\\mathrm{true}}_{i} - ((\\mathbf{F}^{\\mathrm{true}}_{i})^\\top \\mathbf{M}^{-1/2} \\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}) \\mathbf{M}^{1/2}\\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}\n$$\nThis formula provides the perpendicular component of the force in the original $\\mathbf{R}$-space, using a projection defined in the mass-weighted $\\tilde{\\mathbf{R}}$-space. It is computable from the true force $\\mathbf{F}^{\\mathrm{true}}_{i}$, the mass matrix $\\mathbf{M}$, and the mass-weighted unit tangent $\\hat{\\tilde{\\boldsymbol{\\tau}}}_{i}$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the four test cases for computing NEB-related quantities\n    in mass-weighted coordinates.\n    \"\"\"\n    \n    # Epsilon for floating point comparisons with zero\n    EPS = 1e-12\n\n    # Define the test cases\n    test_cases = [\n        {\n            \"id\": 1,\n            \"masses\": [1.0, 16.0],\n            \"images\": [\n                [0.0, 0.0, 1.0, -1.0],\n                [0.5, 0.5, 0.5, -0.5],\n                [1.0, 1.0, 0.0, 0.0]\n            ],\n            \"potential\": {\"type\": \"quadratic\", \"coeffs\": [1.0, 2.0, 3.0, 4.0]},\n            \"dim\": 2\n        },\n        {\n            \"id\": 2,\n            \"masses\": [5.0, 5.0],\n            \"images\": [\n                [0.0, 0.0, 1.0, -1.0],\n                [0.5, 0.5, 0.5, -0.5],\n                [1.0, 1.0, 0.0, 0.0]\n            ],\n            \"potential\": {\"type\": \"quadratic\", \"coeffs\": [1.0, 2.0, 3.0, 4.0]},\n            \"dim\": 2\n        },\n        {\n            \"id\": 3,\n            \"masses\": [2.0, 1.0],\n            \"images\": [\n                [0.0, 1.0, 0.0, 0.0],\n                [1.0, 2.0, 1.0, 0.0],\n                [2.0, 3.0, 2.0, 0.0]\n            ],\n            \"potential\": {\"type\": \"linear\", \"alpha\": 3.14},\n            \"dim\": 2\n        },\n        {\n            \"id\": 4,\n            \"masses\": [3.0, 7.0],\n            \"images\": [\n                [1.0, -1.0, 2.0, -2.0],\n                [1.0, -1.0, 2.0, -2.0],\n                [1.0, -1.0, 2.0, -2.0]\n            ],\n            \"potential\": {\"type\": \"identity_quadratic\"},\n            \"dim\": 2\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        masses = np.array(case[\"masses\"])\n        images_R = [np.array(img) for img in case[\"images\"]]\n        dim = case[\"dim\"]\n        K = len(images_R)\n        num_internal_images = K - 2\n\n        # Construct mass matrix and its square roots\n        M_diag = np.repeat(masses, dim)\n        M = np.diag(M_diag)\n        M_sqrt = np.diag(np.sqrt(M_diag))\n        M_inv_sqrt = np.diag(1.0 / np.sqrt(M_diag))\n\n        def get_tangent_and_force(R_images, M_sqrt_mat, M_inv_sqrt_mat, potential_params, use_mass_weighting):\n            total_perp_force_norm = 0.0\n            \n            # This is a bit of a hack to ensure case 3 can build its force correctly\n            # which depends on the true mass-weighted tangent regardless of the projection type.\n            nonlocal M_sqrt\n            \n            for i in range(1, num_internal_images + 1):\n                R_prev, R_curr, R_next = R_images[i-1], R_images[i], R_images[i+1]\n                \n                # --- 1. Compute unit tangent ---\n                eff_M_sqrt = M_sqrt_mat if use_mass_weighting else np.eye(len(R_curr))\n                \n                delta_R_plus = R_next - R_curr\n                delta_R_minus = R_curr - R_prev\n                \n                delta_tilde_R_plus = eff_M_sqrt @ delta_R_plus\n                delta_tilde_R_minus = eff_M_sqrt @ delta_R_minus\n\n                norm_plus = np.linalg.norm(delta_tilde_R_plus)\n                norm_minus = np.linalg.norm(delta_tilde_R_minus)\n\n                u_hat_plus = delta_tilde_R_plus / norm_plus if norm_plus > EPS else np.zeros_like(delta_tilde_R_plus)\n                u_hat_minus = delta_tilde_R_minus / norm_minus if norm_minus > EPS else np.zeros_like(delta_tilde_R_minus)\n\n                tau_raw = u_hat_plus + u_hat_minus\n                norm_tau_raw = np.linalg.norm(tau_raw)\n                \n                tau_hat = tau_raw / norm_tau_raw if norm_tau_raw > EPS else np.zeros_like(tau_raw)\n\n                # --- 2. Compute true force ---\n                if potential_params[\"type\"] == \"quadratic\":\n                    coeffs = np.array(potential_params[\"coeffs\"])\n                    F_true = -coeffs * R_curr\n                elif potential_params[\"type\"] == \"identity_quadratic\":\n                    F_true = -R_curr\n                elif potential_params[\"type\"] == \"linear\":\n                    alpha = potential_params[\"alpha\"]\n                    # For case 3, force depends on the mass-weighted tangent itself.\n                    # We must compute the true mass-weighted tangent first to define the force.\n                    delta_tilde_R_plus_true = M_sqrt @ delta_R_plus\n                    delta_tilde_R_minus_true = M_sqrt @ delta_R_minus\n                    norm_plus_true = np.linalg.norm(delta_tilde_R_plus_true)\n                    norm_minus_true = np.linalg.norm(delta_tilde_R_minus_true)\n                    u_hat_plus_true = delta_tilde_R_plus_true / norm_plus_true if norm_plus_true > EPS else np.zeros_like(delta_tilde_R_plus_true)\n                    u_hat_minus_true = delta_tilde_R_minus_true / norm_minus_true if norm_minus_true > EPS else np.zeros_like(delta_tilde_R_minus_true)\n                    tau_raw_true = u_hat_plus_true + u_hat_minus_true\n                    norm_tau_raw_true = np.linalg.norm(tau_raw_true)\n                    tau_hat_true = tau_raw_true / norm_tau_raw_true if norm_tau_raw_true > EPS else np.zeros_like(tau_raw_true)\n                    F_true = alpha * M_sqrt @ tau_hat_true\n                \n                # --- 3. Compute perpendicular force component ---\n                if use_mass_weighting:\n                    eff_M_inv_sqrt_force = M_inv_sqrt_mat\n                    proj_coeff = F_true.T @ eff_M_inv_sqrt_force @ tau_hat\n                    F_perp = F_true - proj_coeff * (eff_M_sqrt @ tau_hat)\n                else: # Standard (non-mass-weighted) projection\n                    proj_coeff = F_true.T @ tau_hat\n                    F_perp = F_true - proj_coeff * tau_hat\n\n                total_perp_force_norm += np.linalg.norm(F_perp)\n            \n            return total_perp_force_norm\n\n        # For Case 2, we need both mass-weighted and non-mass-weighted results\n        if case[\"id\"] == 2:\n            mw_sum = get_tangent_and_force(images_R, M_sqrt, M_inv_sqrt, case[\"potential\"], use_mass_weighting=True)\n            non_mw_sum = get_tangent_and_force(images_R, M_sqrt, M_inv_sqrt, case[\"potential\"], use_mass_weighting=False)\n            result = abs(mw_sum - non_mw_sum)\n        else:\n            result = get_tangent_and_force(images_R, M_sqrt, M_inv_sqrt, case[\"potential\"], use_mass_weighting=True)\n            \n        results.append(result)\n\n    # Format output as specified\n    formatted_results = [f\"{r:.10f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}