{
    "hands_on_practices": [
        {
            "introduction": "这个首个实践是一个基础练习 。它涉及计算球形催化剂内一级反应的有效因子，这是反应工程入门中最常见的情景。通过本练习，您将巩固应用标准公式计算塞勒模数和有效因子的能力，这对于快速评估扩散限制的影响至关重要。",
            "id": "1527055",
            "problem": "从生物质生产高附加值化学品的一个关键步骤涉及糠醛的液相加氢生成糠醇。该过程通常使用填充床反应器进行催化。考虑这样一个过程，其中加氢反应相对于糠醛是一级反应。该反应在等温条件下使用球形多孔催化剂颗粒进行。\n\n该反应的内在一级反应速率常数为 $k_1 = 0.085 \\text{ s}^{-1}$。测得糠醛在催化剂孔道内的有效扩散系数为 $D_e = 4.0 \\times 10^{-10} \\text{ m}^2/\\text{s}$。催化剂颗粒均具有 $d_p = 2.4 \\text{ mm}$ 的均一直径。\n\n计算催化剂有效因子。有效因子定义为颗粒内的实际总反应速率与假设颗粒整个内部都暴露于外表面条件下（即没有内部浓度梯度）时所观察到的速率之比。\n\n将您的答案表示为一个数值，并四舍五入到三位有效数字。",
            "solution": "对于等温、球形多孔催化剂颗粒内的一级反应，塞勒模数定义为\n$$\n\\phi = R \\sqrt{\\frac{k_{1}}{D_{e}}},\n$$\n其中 $R$ 是颗粒半径，$k_{1}$ 是内在一级反应速率常数，$D_{e}$ 是有效扩散系数。\n\n对于球形颗粒内的一级反应，内有效因子为\n$$\n\\eta = \\frac{3}{\\phi^{2}} \\left( \\phi \\coth \\phi - 1 \\right).\n$$\n\n已知 $d_{p} = 2.4 \\times 10^{-3} \\text{ m}$，半径为\n$$\nR = \\frac{d_{p}}{2} = 1.2 \\times 10^{-3} \\text{ m}.\n$$\n计算塞勒模数：\n$$\n\\frac{k_{1}}{D_{e}} = \\frac{0.085}{4.0 \\times 10^{-10}} = 2.125 \\times 10^{8},\n$$\n$$\n\\sqrt{\\frac{k_{1}}{D_{e}}} = \\sqrt{2.125} \\times 10^{4} \\approx 1.457738 \\times 10^{4},\n$$\n$$\n\\phi = R \\sqrt{\\frac{k_{1}}{D_{e}}} = 1.2 \\times 10^{-3} \\times 1.457738 \\times 10^{4} \\approx 17.492856.\n$$\n那么\n$$\n\\eta = \\frac{3}{\\phi^{2}} \\left( \\phi \\coth \\phi - 1 \\right).\n$$\n由于 $\\phi \\gg 1$，$\\coth \\phi \\approx 1$ 且误差可忽略不计，所以在数值上\n$$\n\\eta \\approx \\frac{3}{\\phi^{2}} \\left( \\phi - 1 \\right) = \\frac{3 \\times 16.492856}{(17.492856)^{2}} \\approx 0.161695.\n$$\n四舍五入到三位有效数字，\n$$\n\\eta \\approx 0.162.\n$$",
            "answer": "$$\\boxed{0.162}$$"
        },
        {
            "introduction": "在简单的一级动力学之外，本问题将探讨一个零级反应 。这种情况引入了一个有趣的概念——“死区”（dead zone），即反应物在到达催化剂中心之前就被完全消耗掉了。这项实践要求您在这些条件下从基本原理出发推导有效因子，从而加深您对反应动力学如何从根本上改变浓度分布和催化剂性能的理解。",
            "id": "1527083",
            "problem": "一个多相催化反应 $A \\rightarrow B$ 被用于去除工业废物流中的一种污染物。该反应相对于污染物 $A$ 是零级反应，具有恒定的体积反应速率 $k_0$。催化剂被制成半厚度为 $L$ 的大平板。平板外表面上反应物 $A$ 的浓度维持在恒定值 $C_{As}$，而 $A$ 在多孔催化剂内的有效扩散系数为 $D_e$。\n\n该过程在强扩散限制条件下的稳态下运行。这意味着反应物 $A$ 在其能够穿透到催化剂板中心之前就被完全消耗掉了。具体来说，在板的中心区域，$A$ 的浓度为零。这个“死区”（即反应物浓度首次降至零的区域）的边界位于距板中心（$z=0$）$z = L/2$ 的距离处。\n\n在这些特定的操作条件下，计算催化剂有效因子 $\\eta$。有效因子定义为催化剂内实际的总反应速率与假设整个催化剂体积都暴露在表面浓度 $C_{As}$ 下所能达到的反应速率之比。请以精确数值的形式给出答案。",
            "solution": "设平板的表面位于 $z=\\pm L$，中心位于 $z=0$。在 $A$ 存在的区域，稳态扩散伴随零级消耗，其一维物种衡算式为\n$$\n\\frac{d}{dz}\\left(-D_{e}\\frac{dC_{A}}{dz}\\right)=-r_{A},\\quad r_{A}=k_{0}\\ \\text{where}\\ C_{A}>0,\n$$\n在反应区域内，该式可简化为\n$$\nD_{e}\\frac{d^{2}C_{A}}{dz^{2}}=k_{0}.\n$$\n存在一个中心死区，其中 $C_{A}=0$ 且不发生反应。在死区的边界处，浓度和通量的连续性意味着在穿透边界 $z=z_{p}$ 处，\n$$\nC_{A}(z_{p})=0,\\qquad \\left.\\frac{dC_{A}}{dz}\\right|_{z_{p}}=0.\n$$\n在反应壳层 $z\\in[z_{p},L]$ 内求解带有这些条件的微分方程，得到\n$$\nC_{A}(z)=\\frac{k_{0}}{2D_{e}}(z-z_{p})^{2},\n$$\n并且表面条件 $C_{A}(L)=C_{As}$ 意味着\n$$\nC_{As}=\\frac{k_{0}}{2D_{e}}(L-z_{p})^{2}.\n$$\n单位外表面积的实际总反应速率是体积速率在两侧反应区域上的积分：\n$$\nR_{\\text{actual}}'=\\int_{-L}^{L}r_{A}(z)\\,dz=2\\,k_{0}\\,(L-z_{p}),\n$$\n因为在每个厚度为 $(L-z_{p})$ 的反应壳层内 $r_{A}=k_{0}$，而在死区内为零。如果整个催化剂体积都暴露在 $C_{As}$ 下，则各处的体积速率都将是 $k_{0}$，从而得到\n$$\nR_{\\text{ideal}}'=2L\\,k_{0}.\n$$\n因此，有效因子为\n$$\n\\eta=\\frac{R_{\\text{actual}}'}{R_{\\text{ideal}}'}=\\frac{2k_{0}(L-z_{p})}{2Lk_{0}}=\\frac{L-z_{p}}{L}.\n$$\n在所述的死区边界位于 $z_{p}=L/2$ 的条件下，该式变为\n$$\n\\eta=\\frac{L-\\frac{L}{2}}{L}=\\frac{1}{2}.\n$$",
            "answer": "$$\\boxed{\\frac{1}{2}}$$"
        },
        {
            "introduction": "这项高级实践旨在连接解析理论与现代计算方法 。您将构建一个有限差分格式，以数值方式求解球形催化剂的扩散-反应边值问题。这项动手编程练习不仅能巩固您对底层物理原理的理解，还能让您掌握解决那些无法获得解析解的难题的技能——这在真实的催化剂设计中是常见情况。",
            "id": "3902605",
            "problem": "考虑一个等温、多孔的球形催化剂颗粒，其中在稳态下发生单一的不可逆一级反应，无外部传质阻力且有效扩散系数恒定。从物种守恒和菲克定律（Fick's law）作为基本出发点，推导无量纲浓度分布的无量纲边值问题。令 $x \\in [0,1]$ 为无量纲径向坐标，$x = r/R$，令 $y(x)$ 为无量纲浓度，$y = c/c_{s}$，其中 $c_{s}$ 为表面浓度。无量纲群为塞勒模数（Thiele modulus）$\\phi$，其定义为 $\\phi^{2} = R^{2} k_{\\mathrm{eff}}/D_{\\mathrm{eff}}$，其中 $R$ 是颗粒半径，$k_{\\mathrm{eff}}$ 是有效一级反应速率常数，$D_{\\mathrm{eff}}$ 是有效扩散系数。稳态球形扩散-反应方程可以写成二阶常微分方程（ODE）的无量纲形式：\n$$(1/x^{2}) \\, \\dfrac{d}{dx} \\!\\left(x^{2} \\dfrac{dy}{dx}\\right) - \\phi^{2} y = 0 \\quad \\text{for} \\quad x \\in (0,1),$$\n服从对称性和狄利克雷（Dirichlet）边界条件\n$$\\left.\\dfrac{dy}{dx}\\right|_{x=0} = 0, \\qquad y(1) = 1.$$\n有效因子 $\\eta$（根据其基本定义）定义为无量纲的体积平均反应速率与表面浓度下的反应速率之比，即：\n$$\\eta = 3 \\int_{0}^{1} y(x)\\, x^{2}\\, dx.$$\n您的任务是设计并实现一个在均匀网格上的二阶、守恒的有限差分格式来近似 $y(x)$，然后通过对上述定义进行数值积分来计算 $\\eta$。该数值方法必须：\n- 以守恒形式离散化球形算子，以避免在 $x=0$ 处的奇点。\n- 在中心施加对称边界条件，在表面施加狄利克雷（Dirichlet）边界条件。\n- 组装并求解得到的线性系统。\n- 在同一网格上使用高精度求积法计算 $\\eta$。\n\n然后，独立地计算球体中一级反应的解析有效因子，作为塞勒模数 $\\phi$ 的函数（不要在没有推导的情况下假设或引用任何“捷径”结果；将其视为一个您需要验证的已知结果）。使用一种在 $\\phi$ 非常小和非常大时都能保持精确的数值稳定实现。\n\n测试套件：\n- 在 $x \\in [0,1]$ 上使用包含 $N = 4000$ 个节点的均匀网格。\n- 对以下塞勒模数计算数值有效因子与解析有效因子之间的绝对误差：$\\phi \\in \\{0.01, 0.10, 1.00, 5.00, 50.00\\}$。\n\n答案规格：\n- 对于测试套件中的每个 $\\phi$，计算绝对误差 $|\\eta_{\\mathrm{num}} - \\eta_{\\mathrm{ana}}|$ 并四舍五入到小数点后10位。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，`[0.0000000001,0.0000000002,0.0000000003,0.0000000004,0.0000000005]`）。\n- 此问题中的所有量都是无量纲的，因此输出中不需要物理单位。",
            "solution": "用户提供的问题是化学反应工程领域一个适定且有科学依据的边值问题，因此被认为是有效的。我们继续提供完整的解决方案。\n\n该问题要求对球形催化剂颗粒中的稳态、一维、等温扩散-反应系统进行数值和解析处理。\n\n控制浓度分布 $y(x)$ 的无量纲微分方程为：\n$$ \\frac{1}{x^2} \\frac{d}{dx} \\left(x^2 \\frac{dy}{dx}\\right) - \\phi^2 y = 0 \\quad \\text{for} \\quad x \\in (0,1) $$\n边界条件为：\n$$ \\left.\\frac{dy}{dx}\\right|_{x=0} = 0, \\qquad y(1) = 1 $$\n其中 $y$ 是无量纲浓度，$x$ 是无量纲径向位置，$\\phi$ 是塞勒模数（Thiele modulus）。\n\n**1. 数值解：守恒有限差分法**\n\n为了获得数值解，我们使用一个包含 $N$ 个节点的均匀网格对区域 $x \\in [0,1]$ 进行离散化：$x_i = i h$，其中 $i=0, 1, \\dots, N-1$，步长为 $h = 1/(N-1)$。函数在节点 $x_i$ 处的值表示为 $y_i \\approx y(x_i)$。\n\n首先将常微分方程（ODE）两边乘以 $x^2$ 写成其守恒形式：\n$$ \\frac{d}{dx} \\left(x^2 \\frac{dy}{dx}\\right) - \\phi^2 x^2 y = 0 $$\n我们使用一种内在守恒的有限体积法来离散化此方程。对于内部节点 $x_i$（$1 \\le i \\le N-2$），我们在控制体积 $[x_{i-1/2}, x_{i+1/2}]$ 上对该方程进行积分，其中 $x_{i \\pm 1/2} = x_i \\pm h/2$。\n\n$$ \\int_{x_{i-1/2}}^{x_{i+1/2}} \\frac{d}{dx} \\left(x^2 \\frac{dy}{dx}\\right) dx - \\int_{x_{i-1/2}}^{x_{i+1/2}} \\phi^2 x^2 y(x) dx = 0 $$\n根据微积分基本定理，第一项是穿过控制体积边界的净通量：\n$$ \\left[x^2 \\frac{dy}{dx}\\right]_{x_{i-1/2}}^{x_{i+1/2}} = \\left. \\left(x^2 \\frac{dy}{dx}\\right) \\right|_{x_{i+1/2}} - \\left. \\left(x^2 \\frac{dy}{dx}\\right) \\right|_{x_{i-1/2}} $$\n导数项使用二阶中心差分进行近似：\n$$ \\left. \\frac{dy}{dx} \\right|_{x_{i+1/2}} \\approx \\frac{y_{i+1} - y_i}{h}, \\qquad \\left. \\frac{dy}{dx} \\right|_{x_{i-1/2}} \\approx \\frac{y_i - y_{i-1}}{h} $$\n反应（汇）项通过假设在控制体积内 $y(x) \\approx y_i$ 来近似：\n$$ \\int_{x_{i-1/2}}^{x_{i+1/2}} \\phi^2 x^2 y(x) dx \\approx \\phi^2 y_i \\int_{x_i-h/2}^{x_i+h/2} x^2 dx = \\phi^2 y_i \\frac{1}{3} \\left[x^3\\right]_{x_i-h/2}^{x_i+h/2} $$\n对于均匀网格，这个积分很复杂。一个更简单且同样有效的二阶方法是在节点 $x_i$ 处近似微分方程：\n$$ \\frac{\\left. \\left(x^2 \\frac{dy}{dx}\\right) \\right|_{x_{i+1/2}} - \\left. \\left(x^2 \\fracdy}{dx}\\right) \\right|_{x_{i-1/2}}}{h} - \\phi^2 x_i^2 y_i = 0 $$\n代入导数的有限差分近似，得到：\n$$ \\frac{1}{h} \\left( x_{i+1/2}^2 \\frac{y_{i+1} - y_i}{h} - x_{i-1/2}^2 \\frac{y_i - y_{i-1}}{h} \\right) - \\phi^2 x_i^2 y_i = 0 $$\n重新整理后，得到内部节点 $i$（其中 $1 \\le i \\le N-2$）的线性方程：\n$$ \\left(\\frac{x_{i-1/2}^2}{h^2}\\right) y_{i-1} - \\left(\\frac{x_{i+1/2}^2 + x_{i-1/2}^2}{h^2} + \\phi^2 x_i^2\\right) y_i + \\left(\\frac{x_{i+1/2}^2}{h^2}\\right) y_{i+1} = 0 $$\n\n为了处理 $x=0$ 处的奇点，我们分析当 $x \\to 0$ 时常微分方程（ODE）的行为。对称条件 $y'(0)=0$ 意味着 $y(x)$ 在 $x=0$ 附近的泰勒级数形式为 $y(x) = y(0) + a_2 x^2 + O(x^4)$。对常微分方程的展开形式 $y'' + (2/x)y' - \\phi^2 y = 0$ 在 $x \\to 0$ 时取极限，并对 $(2/x)y'$ 项应用洛必达法则（L'Hôpital's rule），得到 $\\lim_{x\\to 0}(y'' + 2y'' - \\phi^2 y) = 3y''(0) - \\phi^2 y(0) = 0$。\n我们使用一个二阶有限差分来表示 $y''(0)$，该差分包含一个“虚点” $y_{-1}$ 和对称条件 $y_{-1}=y_1$：\n$$ y''(0) \\approx \\frac{y_1 - 2y_0 + y_{-1}}{h^2} = \\frac{2y_1 - 2y_0}{h^2} $$\n将此代入极限形式的常微分方程，得到中心节点（$i=0$）的方程：\n$$ 3 \\left(\\frac{2y_1 - 2y_0}{h^2}\\right) - \\phi^2 y_0 = 0 \\implies -(6 + h^2 \\phi^2) y_0 + 6 y_1 = 0 $$\n这提供了我们线性系统的第一个方程。\n\n表面的边界条件是 $y(1)=1$，这设定了 $y_{N-1}=1$。这是一个狄利克雷（Dirichlet）条件。因此，未知数是 $y_0, y_1, \\dots, y_{N-2}$。最后一个未知节点 $i=N-2$ 的方程是：\n$$ \\left(\\frac{x_{N-5/2}^2}{h^2}\\right) y_{N-3} - \\left(\\frac{x_{N-3/2}^2 + x_{N-5/2}^2}{h^2} + \\phi^2 x_{N-2}^2\\right) y_{N-2} + \\left(\\frac{x_{N-3/2}^2}{h^2}\\right) y_{N-1} = 0 $$\n由于 $y_{N-1}=1$ 是已知的，该项被移到线性系统 $A\\vec{y}=\\vec{b}$ 的右侧。得到的系统是三对角的，可以被高效求解。\n\n求解出浓度分布 $\\{y_i\\}$ 后，有效因子 $\\eta$ 通过对其定义进行数值积分来计算：\n$$ \\eta = 3 \\int_{0}^{1} y(x) x^2 dx $$\n为了获得高精度，我们使用辛普森法则（Simpson's rule），一种四阶求积方法，如 `scipy.integrate.simpson` 中所实现的。该函数可以处理奇数个区间，而我们的网格（$N=4000$ 个节点，$N-1=3999$ 个区间）正好具有此特性。\n\n**2. 解析解**\n\n常微分方程 $y'' + (2/x)y' - \\phi^2 y = 0$ 可以通过替换 $u(x) = x y(x)$ 来简化。这可将常微分方程转换为一个标准的二阶常系数线性方程：\n$$ u'' - \\phi^2 u = 0 $$\n$u(x)$ 的通解是 $u(x) = C_1 \\cosh(\\phi x) + C_2 \\sinh(\\phi x)$。因此，$y(x)$ 的解是：\n$$ y(x) = \\frac{u(x)}{x} = \\frac{C_1 \\cosh(\\phi x) + C_2 \\sinh(\\phi x)}{x} $$\n边界条件用于确定常数 $C_1$ 和 $C_2$。\n中心（$x=0$）浓度有限的条件要求 $\\lim_{x\\to 0} y(x)$ 是有限的。由于 $\\lim_{x\\to 0} \\cosh(\\phi x)/x \\to \\infty$ 且 $\\lim_{x\\to 0} \\sinh(\\phi x)/x = \\phi$，为了得到物理上有意义的解，我们必须有 $C_1=0$。\n当 $C_1=0$ 时，解变为 $y(x) = C_2 \\frac{\\sinh(\\phi x)}{x}$。对称条件 $y'(0)=0$ 会自动满足。\n表面边界条件 $y(1)=1$ 给出 $1 = C_2 \\frac{\\sinh(\\phi)}{1}$，所以 $C_2 = 1/\\sinh(\\phi)$。\n浓度分布的解析解为：\n$$ y(x) = \\frac{\\sinh(\\phi x)}{x \\sinh(\\phi)} $$\n为了求得解析有效因子 $\\eta_{\\mathrm{ana}}$，我们将此表达式代入 $\\eta$ 的定义中：\n$$ \\eta_{\\mathrm{ana}} = 3 \\int_{0}^{1} \\left(\\frac{\\sinh(\\phi x)}{x \\sinh(\\phi)}\\right) x^2 dx = \\frac{3}{\\sinh(\\phi)} \\int_{0}^{1} x \\sinh(\\phi x) dx $$\n使用分部积分法，我们得到 $\\int x \\sinh(\\phi x) dx = \\frac{x}{\\phi}\\cosh(\\phi x) - \\frac{1}{\\phi^2}\\sinh(\\phi x)$。\n计算从 $0$ 到 $1$ 的定积分并代回，得到众所周知的结果：\n$$ \\eta_{\\mathrm{ana}} = \\frac{3}{\\phi^2} (\\phi \\coth(\\phi) - 1) $$\n对于小的 $\\phi$，该公式由于灾难性抵消（catastrophic cancellation）而数值不稳定。我们使用 $\\phi \\coth(\\phi) = 1 + \\frac{\\phi^2}{3} - \\frac{\\phi^4}{45} + O(\\phi^6)$ 的泰勒级数展开来推导一个对小 $\\phi$ 稳定的近似：\n$$ \\eta_{\\mathrm{ana}} \\approx \\frac{3}{\\phi^2} \\left( \\left(1 + \\frac{\\phi^2}{3} - \\frac{\\phi^4}{45} + \\dots \\right) - 1 \\right) = 1 - \\frac{\\phi^2}{15} + \\frac{2\\phi^4}{315} - \\dots $$\n在实现中，对于 $\\phi  10^{-4}$，我们从标准公式切换到此级数展开，以确保在所有测试值上都具有高精度。\n\n最后，我们为每个指定的塞勒模数计算绝对误差 $|\\eta_{\\mathrm{num}} - \\eta_{\\mathrm{ana}}|$。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\nfrom scipy.integrate import simpson\n\ndef solve_bvp(phi, N):\n    \"\"\"\n    Solves the dimensionless diffusion-reaction BVP using a finite-difference scheme.\n\n    Args:\n        phi (float): The Thiele modulus.\n        N (int): The number of grid points.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: The grid points (x) and the concentration profile (y).\n    \"\"\"\n    h = 1.0 / (N - 1)\n    x_full = np.linspace(0, 1, N)\n\n    # The number of unknowns is N-1, corresponding to y_0, ..., y_{N-2}\n    M = N - 1\n\n    # `ab` is the matrix in banded form [u, d, l] for solve_banded\n    # ab[0,:] = super-diagonal (u)\n    # ab[1,:] = main diagonal (d)\n    # ab[2,:] = sub-diagonal (l)\n    # We will build it as [l, d, u] and then roll it.\n    ab = np.zeros((3, M))\n    b = np.zeros(M)\n    \n    # Equation for node i=0\n    # -(6 + h^2*phi^2)*y_0 + 6*y_1 = 0\n    ab[1, 0] = -(6.0 + phi**2 * h**2)\n    ab[0, 1] = 6.0\n    b[0] = 0.0\n\n    # Equations for interior nodes i=1 to N-3 (last unknown is y_{N-2})\n    for i in range(1, N - 2):\n        x_i = i * h\n        x_half_plus_sq = ((i + 0.5) * h)**2\n        x_half_minus_sq = ((i - 0.5) * h)**2\n        \n        ab[2, i - 1] = x_half_minus_sq / h**2  # Lower diagonal (coeff of y_{i-1})\n        ab[1, i] = -(x_half_plus_sq + x_half_minus_sq) / h**2 - phi**2 * x_i**2  # Main diagonal (coeff of y_i)\n        ab[0, i + 1] = x_half_plus_sq / h**2  # Upper diagonal (coeff of y_{i+1})\n        b[i] = 0.0\n\n    # Equation for last unknown node i=N-2\n    i = N - 2\n    x_i = i * h\n    x_half_plus_sq = ((i + 0.5) * h)**2\n    x_half_minus_sq = ((i - 0.5) * h)**2\n    \n    ab[2, i - 1] = x_half_minus_sq / h**2 # Lower diagonal\n    ab[1, i] = -(x_half_plus_sq + x_half_minus_sq) / h**2 - phi**2 * x_i**2 # Main diagonal\n    # The y_{N-1} term moves to the RHS\n    b[i] = -x_half_plus_sq / h**2  # * y_{N-1} which is 1.0\n\n    # Solve the tridiagonal system Ay=b\n    y_unknowns = solve_banded((1, 1), ab, b)\n    \n    # Reconstruct the full solution vector, including the boundary value y(1)=1\n    y_full = np.append(y_unknowns, 1.0)\n    \n    return x_full, y_full\n\ndef calculate_numerical_eta(x, y):\n    \"\"\"\n    Calculates the effectiveness factor eta using numerical quadrature.\n\n    Args:\n        x (np.ndarray): The grid points.\n        y (np.ndarray): The concentration profile.\n\n    Returns:\n        float: The numerical effectiveness factor.\n    \"\"\"\n    integrand = y * x**2\n    integral_val = simpson(integrand, x)\n    return 3.0 * integral_val\n\ndef calculate_analytical_eta(phi):\n    \"\"\"\n    Calculates the analytical effectiveness factor for a sphere.\n    This implementation is numerically stable for small and large phi.\n\n    Args:\n        phi (float): The Thiele modulus.\n\n    Returns:\n        float: The analytical effectiveness factor.\n    \"\"\"\n    if np.abs(phi)  1e-4:\n        # For very small phi, use Taylor series to avoid catastrophic cancellation\n        # eta = 1 - phi^2/15 + 2*phi^4/315 - O(phi^6)\n        phi2 = phi**2\n        return 1.0 - phi2 / 15.0 + 2.0 * phi2**2 / 315.0\n    else:\n        # Standard formula for phi > 0\n        coth_val = np.cosh(phi) / np.sinh(phi)\n        return (3.0 / phi**2) * (phi * coth_val - 1.0)\n\ndef solve():\n    \"\"\"\n    Main solver function to run the test suite and print results.\n    \"\"\"\n    test_cases = [0.01, 0.10, 1.00, 5.00, 50.00]\n    N = 4000\n    \n    errors = []\n    \n    for phi in test_cases:\n        # 1. Solve BVP numerically\n        x, y_num = solve_bvp(phi, N)\n        \n        # 2. Calculate numerical effectiveness factor\n        eta_num = calculate_numerical_eta(x, y_num)\n        \n        # 3. Calculate analytical effectiveness factor\n        eta_ana = calculate_analytical_eta(phi)\n        \n        # 4. Calculate absolute error and round\n        error = np.abs(eta_num - eta_ana)\n        errors.append(round(error, 10))\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, errors))}]\")\n\nsolve()\n```"
        }
    ]
}