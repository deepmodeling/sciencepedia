{
    "hands_on_practices": [
        {
            "introduction": "在动态催化中，催化剂的性质和反应条件可能随时间变化，导致反应速率常数也随时间波动。本练习旨在通过一个简化的解析模型，揭示这种速率常数的周期性调制如何影响总体的平均反应速率。通过精确的数学推导，您将发现一个非直观的现象：振荡可以显著提高平均反应效率，这一结论对于设计动态催化过程至关重要。",
            "id": "3888723",
            "problem": "考虑动态催化中的单中心表面反应，其中，基元步骤 $A^* \\rightarrow B^*$ 的瞬时一级速率 $r(t)$ 由 $r(t) = k(t)\\,\\theta_A$ 给出。此处，$\\theta_A$ 是 $A^*$ 的恒定覆盖度，该覆盖度通过相对于反应和结构动力学而言更快的吸附-解吸过程来维持，而 $k(t)$ 是由周期性结构重构引起的势垒调制所产生的时间依赖性速率常数。假设速率常数为 $k(t) = k_0 \\exp\\!\\big(-\\alpha \\sin(\\omega t)\\big)$，其中 $k_0 > 0$ 是基准速率常数，$\\alpha \\ge 0$ 是一个无量纲的调制幅度，它表征了势垒对结构坐标的敏感度，而 $\\omega > 0$ 是由外部刺激施加的结构调制的角频率。\n\n仅使用微观动力学建模的第一性原理和周期函数的时间平均方法，推导在长时间周期性稳态下的精确时间平均速率 $\\langle r \\rangle$。然后，确定在快速调制极限（定义为 $\\omega \\rightarrow \\infty$）和慢速调制极限（定义为 $\\omega \\rightarrow 0$）下，$\\langle r \\rangle$ 对 $\\alpha$ 和 $\\omega$ 的依赖关系。您可以假设平均是在整数个调制周期上进行的。请将您的最终答案表示为 $\\langle r \\rangle$ 的单个封闭形式解析表达式。最终表达式无需四舍五入，也无需单位。",
            "solution": "该问题陈述经评估是有效的，因为它是科学有据、定义明确且客观的。它为动态催化系统微观动力学建模中的一个标准问题提供了一个自洽且一致的框架。\n\n反应 $A^* \\rightarrow B^*$ 的瞬时速率由 $r(t) = k(t)\\,\\theta_A$ 给出。$A^*$ 物种的覆盖度，记为 $\\theta_A$，是恒定的。速率常数 $k(t)$ 是一个时间周期函数，由 $k(t) = k_0 \\exp(-\\alpha \\sin(\\omega t))$ 给出，其中 $k_0$、$\\alpha$ 和 $\\omega$ 是正常数（$\\alpha \\ge 0$）。结构调制以及速率常数 $k(t)$ 的周期是 $T = \\frac{2\\pi}{\\omega}$。\n\n主要任务是推导在长时间周期性稳态下，单个周期内的时间平均速率 $\\langle r \\rangle$。一个周期函数 $f(t)$ 在其周期 $T$ 上的时间平均定义为：\n$$\n\\langle f \\rangle = \\frac{1}{T} \\int_{0}^{T} f(t) \\, dt\n$$\n将此定义应用于速率 $r(t)$：\n$$\n\\langle r \\rangle = \\frac{1}{T} \\int_{0}^{T} r(t) \\, dt = \\frac{1}{T} \\int_{0}^{T} k(t) \\theta_A \\, dt\n$$\n由于 $\\theta_A$ 被定义为常数，可以将其从积分中提出：\n$$\n\\langle r \\rangle = \\theta_A \\left( \\frac{1}{T} \\int_{0}^{T} k(t) \\, dt \\right) = \\theta_A \\langle k(t) \\rangle\n$$\n现在，我们代入 $k(t)$ 及其周期 $T = \\frac{2\\pi}{\\omega}$ 的给定表达式：\n$$\n\\langle r \\rangle = \\theta_A \\left( \\frac{\\omega}{2\\pi} \\int_{0}^{2\\pi/\\omega} k_0 \\exp(-\\alpha \\sin(\\omega t)) \\, dt \\right)\n$$\n常数 $k_0$ 也可以被提出：\n$$\n\\langle r \\rangle = k_0 \\theta_A \\frac{\\omega}{2\\pi} \\int_{0}^{2\\pi/\\omega} \\exp(-\\alpha \\sin(\\omega t)) \\, dt\n$$\n为了求解该积分，我们进行变量替换。令 $u = \\omega t$，则 $du = \\omega \\, dt$。积分上下限分别从 $t=0$ 和 $t=2\\pi/\\omega$ 变为 $u=0$ 和 $u=2\\pi$。\n$$\n\\langle r \\rangle = k_0 \\theta_A \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\exp(-\\alpha \\sin(u)) \\, du\n$$\n这个积分是第一类修正贝塞尔函数的一个著名积分表示。阶数为 $n=0$ 的第一类修正贝塞尔函数，记为 $I_0(z)$，其定义为：\n$$\nI_0(z) = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\exp(z \\cos\\theta) \\, d\\theta\n$$\n我们可以证明，涉及 $\\sin(u)$ 的积分等价于涉及 $\\cos(\\theta)$ 的积分。由于被积函数 $\\exp(-\\alpha \\sin(u))$ 的 $2\\pi$-周期性，我们可以平移积分区间而不改变积分的值。让我们进行替换 $u = \\theta + \\frac{\\pi}{2}$：\n$$\n\\int_{0}^{2\\pi} \\exp(-\\alpha \\sin(u)) \\, du = \\int_{-\\pi/2}^{3\\pi/2} \\exp\\left(-\\alpha \\sin\\left(\\theta + \\frac{\\pi}{2}\\right)\\right) \\, d\\theta = \\int_{-\\pi/2}^{3\\pi/2} \\exp(-\\alpha \\cos\\theta) \\, d\\theta\n$$\n由于被积函数 $\\exp(-\\alpha \\cos\\theta)$ 本身是周期为 $2\\pi$ 的函数，我们可以在任何长度为 $2\\pi$ 的区间上积分，例如 $[0, 2\\pi]$：\n$$\n\\int_{-\\pi/2}^{3\\pi/2} \\exp(-\\alpha \\cos\\theta) \\, d\\theta = \\int_{0}^{2\\pi} \\exp(-\\alpha \\cos\\theta) \\, d\\theta\n$$\n因此，该积分变为：\n$$\n\\int_{0}^{2\\pi} \\exp(-\\alpha \\sin(u)) \\, du = \\int_{0}^{2\\pi} \\exp(-\\alpha \\cos\\theta) \\, d\\theta = 2\\pi I_0(-\\alpha)\n$$\n修正贝塞尔函数具有性质 $I_n(-z) = (-1)^n I_n(z)$。对于阶数 $n=0$ 的情况，这简化为 $I_0(-z) = I_0(z)$。因此：\n$$\n\\int_{0}^{2\\pi} \\exp(-\\alpha \\sin(u)) \\, du = 2\\pi I_0(\\alpha)\n$$\n将此结果代回我们关于 $\\langle r \\rangle$ 的表达式中：\n$$\n\\langle r \\rangle = k_0 \\theta_A \\frac{1}{2\\pi} \\left( 2\\pi I_0(\\alpha) \\right)\n$$\n这可以简化为时间平均速率的最终封闭形式表达式：\n$$\n\\langle r \\rangle = k_0 \\theta_A I_0(\\alpha)\n$$\n该表达式给出了在任何有效参数集下的精确时间平均速率。问题进一步要求确定在快速（$\\omega \\rightarrow \\infty$）和慢速（$\\omega \\rightarrow 0$）调制极限下，$\\langle r \\rangle$ 对 $\\alpha$ 和 $\\omega$ 的依赖关系。\n\n观察我们推导出的表达式，我们注意到时间平均速率 $\\langle r \\rangle$ 是 $k_0$、$\\theta_A$ 和 $\\alpha$ 的函数，但完全独立于调制频率 $\\omega$。这是在整数个周期上进行平均的直接结果；周期的具体持续时间不影响周期函数的平均值。因此，对于所有 $\\omega > 0$，包括 $\\omega \\rightarrow \\infty$ 和 $\\omega \\rightarrow 0$ 的极限情况，$\\langle r \\rangle$ 对参数的依赖关系是相同的。\n\n在快速和慢速调制极限下，其依赖关系均为：\n1.  时间平均速率 $\\langle r \\rangle$ 与角频率 $\\omega$ 无关。\n2.  时间平均速率 $\\langle r \\rangle$ 通过零阶第一类修正贝塞尔函数 $I_0(\\alpha)$ 依赖于调制幅度 $\\alpha$。由于对于所有实数 $\\alpha$ 都有 $I_0(\\alpha) \\ge 1$（其中 $I_0(0)=1$），振荡的存在（$\\alpha > 0$）总是导致时间平均速率大于或等于无调制时的速率 $k_0 \\theta_A$。这一现象是应用于凸函数指数函数的詹森不等式 (Jensen's inequality) 的结果。\n\n在所有指定条件下，$\\langle r \\rangle$ 的单个封闭形式解析表达式均为 $k_0 \\theta_A I_0(\\alpha)$。",
            "answer": "$$\n\\boxed{k_0 \\theta_A I_0(\\alpha)}\n$$"
        },
        {
            "introduction": "真实催化系统的复杂性往往超出了简单解析解的范畴，需要借助数值方法进行研究。本练习将引导您模拟一个更贴近实际的场景：在外部压力周期性变化的驱动下，吸附物覆盖度和催化剂表面结构相互耦合、协同演化。通过这项实践，您将掌握求解耦合常微分方程组以及分析系统在周期性稳态下动态行为的关键技能。",
            "id": "3888647",
            "problem": "考虑一个催化表面，它可以在两种结构状态之间动态重构，这两种状态表示为 $R_0$（未重构）和 $R_1$（已重构）。设 $x(t)$ 为在时间 $t$ 时处于状态 $R_1$ 的表面分数，因此处于状态 $R_0$ 的表面分数为 $1 - x(t)$。一种气相分压为 $p_A(t)$ 的吸附物种 $A$ 控制着表面上 $A$ 的覆盖度 $\\theta(t)$，而覆盖度又反过来调节 $R_0 \\rightleftharpoons R_1$ 的动力学过程。\n\n假设遵循以下具有物理基础的定律：\n- 吸附和脱附遵循 Langmuir 动力学和质量作用定律，因此覆盖度服从常微分方程 (ODE) $$\\frac{d\\theta}{dt} = k_{\\mathrm{ads}}\\,p_A(t)\\,\\left(1-\\theta(t)\\right) - k_{\\mathrm{des}}\\,\\theta(t),$$ 其中 $k_{\\mathrm{ads}}$ 的单位为 $\\mathrm{s}^{-1}\\,\\mathrm{bar}^{-1}$，$k_{\\mathrm{des}}$ 的单位为 $\\mathrm{s}^{-1}$，且 $\\theta(t)$ 是无量纲的。\n- 重构和解构遵循一级相变，其速率由覆盖度调制，$$\\frac{dx}{dt} = k_{01}\\!\\left(\\theta(t)\\right)\\,\\left(1 - x(t)\\right) - k_{10}\\!\\left(\\theta(t)\\right)\\,x(t),$$ 其中 $k_{01}\\!\\left(\\theta\\right) = k_{01}^0\\,\\exp\\!\\left(\\alpha\\,\\theta\\right)$ 且 $k_{10}\\!\\left(\\theta\\right) = k_{10}^0\\,\\exp\\!\\left(-\\beta\\,\\theta\\right)$。此处，$k_{01}^0$ 和 $k_{10}^0$ 是基础速率常数，单位为 $\\mathrm{s}^{-1}$，而 $\\alpha$ 和 $\\beta$ 是无量纲参数，反映了覆盖度如何稳定或破坏给定的结构。\n\n设进料是分压 $p_A(t)$ 的方波强迫，周期为 $T$，占空比为 $d$：在每个持续时间为 $T$ 的周期内，$p_A(t)$ 在 $d T$ 秒内等于一个高值 $p_{\\mathrm{high}}$，在 $(1-d)T$ 秒内等于一个低值 $p_{\\mathrm{low}}$。假设系统是混合良好且等温的，并且除了 $p_A(t)$ 外，所有参数都是常数。\n\n从初始条件 $\\theta(0) = 0$ 和 $x(0) = 0$ 开始，在方波强迫下模拟耦合的常微分方程，直到达到周期性稳态。周期性稳态定义为一个极限环，在该极限环中，一个周期开始时的状态在小的数值容差范围内重复。在周期性稳态下，计算周期平均的已重构分数 $$\\bar{x} = \\frac{1}{T}\\int_{t_0}^{t_0 + T} x(t)\\,dt,$$ 其中 $t_0$ 是极限环上一个周期的开始时间。每个测试最终报告的量是 $\\bar{x}$ 的无量纲十进制值，四舍五入到六位小数。最终输出值中不应包含任何物理单位。\n\n设计并实现一个程序，对以下参数集测试套件使用常微分方程数值积分执行上述计算。以下所有数字都必须以其规定单位进行解释，所有符号的定义如上。\n\n测试套件（每个案例为一组参数）：\n- 案例 1（平衡强迫，中等周期）：$k_{\\mathrm{ads}} = 5.0\\,\\mathrm{s}^{-1}\\,\\mathrm{bar}^{-1}$，$k_{\\mathrm{des}} = 0.5\\,\\mathrm{s}^{-1}$，$k_{01}^0 = 0.2\\,\\mathrm{s}^{-1}$，$k_{10}^0 = 0.05\\,\\mathrm{s}^{-1}$，$\\alpha = 4.0$，$\\beta = 2.0$，$p_{\\mathrm{low}} = 0.1\\,\\mathrm{bar}$，$p_{\\mathrm{high}} = 1.0\\,\\mathrm{bar}$，$T = 2.0\\,\\mathrm{s}$，$d = 0.5$。\n- 案例 2（高频强迫）：$k_{\\mathrm{ads}} = 5.0\\,\\mathrm{s}^{-1}\\,\\mathrm{bar}^{-1}$，$k_{\\mathrm{des}} = 0.5\\,\\mathrm{s}^{-1}$，$k_{01}^0 = 0.2\\,\\mathrm{s}^{-1}$，$k_{10}^0 = 0.05\\,\\mathrm{s}^{-1}$，$\\alpha = 4.0$，$\\beta = 2.0$，$p_{\\mathrm{low}} = 0.1\\,\\mathrm{bar}$，$p_{\\mathrm{high}} = 1.0\\,\\mathrm{bar}$，$T = 0.05\\,\\mathrm{s}$，$d = 0.5$。\n- 案例 3（低频强迫）：$k_{\\mathrm{ads}} = 5.0\\,\\mathrm{s}^{-1}\\,\\mathrm{bar}^{-1}$，$k_{\\mathrm{des}} = 0.5\\,\\mathrm{s}^{-1}$，$k_{01}^0 = 0.2\\,\\mathrm{s}^{-1}$，$k_{10}^0 = 0.05\\,\\mathrm{s}^{-1}$，$\\alpha = 4.0$，$\\beta = 2.0$，$p_{\\mathrm{low}} = 0.1\\,\\mathrm{bar}$，$p_{\\mathrm{high}} = 1.0\\,\\mathrm{bar}$，$T = 10.0\\,\\mathrm{s}$，$d = 0.5$。\n- 案例 4（有偏占空比）：$k_{\\mathrm{ads}} = 5.0\\,\\mathrm{s}^{-1}\\,\\mathrm{bar}^{-1}$，$k_{\\mathrm{des}} = 0.5\\,\\mathrm{s}^{-1}$，$k_{01}^0 = 0.2\\,\\mathrm{s}^{-1}$，$k_{10}^0 = 0.05\\,\\mathrm{s}^{-1}$，$\\alpha = 4.0$，$\\beta = 2.0$，$p_{\\mathrm{low}} = 0.1\\,\\mathrm{bar}$，$p_{\\mathrm{high}} = 1.0\\,\\mathrm{bar}$，$T = 2.0\\,\\mathrm{s}$，$d = 0.8$。\n\n算法要求：\n- 根据方波对 $p_A(t)$ 使用分段常数强迫，在长度为 $dT$ 和 $(1-d)T$ 的段上进行积分。\n- 迭代完整的周期，直到一个周期的开始和结束时状态之差的范数小于一个小的容差，从而确定周期性稳态。然后，使用对 $x(t)$ 的数值积分，计算极限环上一个完整周期的 $\\bar{x}$。\n- 程序必须为所有四个案例生成结果，并将它们聚合到单行输出中，该输出包含一个用方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 是案例 $i$ 的四舍五入后的十进制值。\n\n答案格式和单位：\n- 将最终的已重构分数值表示为四舍五入到六位小数的十进制数，不带单位。",
            "solution": "对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n- **状态变量：** $x(t)$（处于状态 $R_1$ 的表面分数）、$1 - x(t)$（处于状态 $R_0$ 的表面分数）和 $\\theta(t)$（吸附物覆盖度）。\n- **控制性常微分方程 (ODE)：**\n  - $\\frac{d\\theta}{dt} = k_{\\mathrm{ads}}\\,p_A(t)\\,\\left(1-\\theta(t)\\right) - k_{\\mathrm{des}}\\,\\theta(t)$\n  - $\\frac{dx}{dt} = k_{01}\\!\\left(\\theta(t)\\right)\\,\\left(1 - x(t)\\right) - k_{10}\\!\\left(\\theta(t)\\right)\\,x(t)$\n- **速率表达式：**\n  - $k_{01}\\!\\left(\\theta\\right) = k_{01}^0\\,\\exp\\!\\left(\\alpha\\,\\theta\\right)$\n  - $k_{10}\\!\\left(\\theta\\right) = k_{10}^0\\,\\exp\\!\\left(-\\beta\\,\\theta\\right)$\n- **强迫函数 $p_A(t)$：** 周期为 $T$、占空比为 $d$ 的方波。\n  - $p_A(t) = p_{\\mathrm{high}}$，持续时间为 $d T$。\n  - $p_A(t) = p_{\\mathrm{low}}$，持续时间为 $(1-d)T$。\n- **初始条件：** $\\theta(0) = 0$，$x(0) = 0$。\n- **目标：** 计算在周期性稳态下，周期平均的已重构分数 $\\bar{x} = \\frac{1}{T}\\int_{t_0}^{t_0 + T} x(t)\\,dt$，四舍五入到六位小数。\n- **测试案例的参数集：**\n  - 案例 1：$k_{\\mathrm{ads}} = 5.0\\,\\mathrm{s}^{-1}\\,\\mathrm{bar}^{-1}$，$k_{\\mathrm{des}} = 0.5\\,\\mathrm{s}^{-1}$，$k_{01}^0 = 0.2\\,\\mathrm{s}^{-1}$，$k_{10}^0 = 0.05\\,\\mathrm{s}^{-1}$，$\\alpha = 4.0$，$\\beta = 2.0$，$p_{\\mathrm{low}} = 0.1\\,\\mathrm{bar}$，$p_{\\mathrm{high}} = 1.0\\,\\mathrm{bar}$，$T = 2.0\\,\\mathrm{s}$，$d = 0.5$。\n  - 案例 2：与案例 1 相同，除了 $T = 0.05\\,\\mathrm{s}$。\n  - 案例 3：与案例 1 相同，除了 $T = 10.0\\,\\mathrm{s}$。\n  - 案例 4：与案例 1 相同，除了 $d = 0.8$。\n- **算法要求：** 使用常微分方程数值积分，迭代至由收敛容差定义的周期性稳态，然后使用数值积分计算周期平均值。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学基础：** 该问题描述了一个吸附物诱导的表面重构的动力学模型。吸附/脱附使用 Langmuir 动力学，结构相变使用一级速率定律，且速率由吸附物覆盖度调制，这些都是表面科学和多相催化中标准且成熟的范式。该模型在科学上是合理的，并代表了动态催化的一个简化但现实的图景。\n2.  **适定性：** 该问题提供了一个由两个耦合、非线性的一阶常微分方程组成的系统，并带有一个指定的分段常数强迫函数。给出了初始条件。速率函数是良态的，确保状态变量 $\\theta(t)$ 和 $x(t)$ 保持在其物理上有意义的界限 $[0, 1]$ 内。对于一个在周期性强迫下的耗散系统，预期会收敛到一个唯一的、稳定的极限环。寻找此极限环并计算周期平均值的过程定义明确。该问题在数学上是适定的。\n3.  **客观性：** 该问题以精确的数学和物理术语陈述。所有量都得到了明确的定义。没有主观或基于意见的内容。\n4.  **完整性和一致性：** 提供了所有参数、方程、初始条件和目标。单位在内部是一致的：例如，在 $d\\theta/dt$ 方程中，$k_{\\mathrm{ads}}\\,p_A$ 和 $k_{\\mathrm{des}}$ 两项的单位都是 $\\mathrm{s}^{-1}$，这对于一个无量纲量的变化率是正确的。设置是完整的，没有矛盾。\n\n### 步骤 3：结论与行动\n该问题具有科学基础、适定、客观且完整。它提出了一个植根于化学动力学既定原则的、不平凡的数值挑战。该问题被判定为有效。将着手开发解决方案。\n\n### 解决方案\n\n该问题要求对一个耦合常微分方程 (ODE) 系统进行数值求解，该系统模拟了周期性强迫下动态重构的催化表面。系统的状态由向量 $Y(t) = [\\theta(t), x(t)]^T$ 描述，其中 $\\theta(t)$ 是吸附物 $A$ 的表面覆盖度，$x(t)$ 是处于已重构状态 $R_1$ 的表面分数。\n\n控制性常微分方程系统为：\n$$\n\\frac{dY}{dt} = F(Y, p_A(t)) =\n\\begin{pmatrix}\n\\frac{d\\theta}{dt} \\\\\n\\frac{dx}{dt}\n\\end{pmatrix}\n$$\n其中分量函数为：\n$$\n\\frac{d\\theta}{dt} = k_{\\mathrm{ads}}\\,p_A(t)\\,\\left(1-\\theta\\right) - k_{\\mathrm{des}}\\,\\theta\n$$\n$$\n\\frac{dx}{dt} = k_{01}\\!\\left(\\theta\\right)\\,\\left(1 - x\\right) - k_{10}\\!\\left(\\theta\\right)\\,x\n$$\n重构和解构速率常数由覆盖度 $\\theta$ 调制：\n$$\nk_{01}\\!\\left(\\theta\\right) = k_{01}^0\\,\\exp\\!\\left(\\alpha\\,\\theta\\right)\n$$\n$$\nk_{10}\\!\\left(\\theta\\right) = k_{10}^0\\,\\exp\\!\\left(-\\beta\\,\\theta\\right)\n$$\n外部控制是分压 $p_A(t)$，它遵循一个方波模式，周期为 $T$，占空比为 $d$，高压为 $p_{\\mathrm{high}}$，低压为 $p_{\\mathrm{low}}$。\n\n解决方案分为两个主要阶段：\n1.  **寻找周期性稳态（极限环）：** 系统从初始条件 $Y(0) = [\\theta(0), x(0)]^T = [0, 0]^T$ 开始进行时间上的正向模拟。模拟逐个周期进行。对于每个周期，积分被分成与分段常数压力相对应的两个部分：\n    - 一个持续时间为 $d T$ 的区间，其中 $p_A = p_{\\mathrm{high}}$。\n    - 一个持续时间为 $(1-d)T$ 的区间，其中 $p_A = p_{\\mathrm{low}}$。\n    设 $Y_n$ 是系统在第 $n$ 个周期开始时的状态。我们在一个完整周期内对常微分方程进行数值积分，以获得下一个周期开始时的状态 $Y_{n+1}$。重复此迭代过程，直到系统达到周期性稳态或极限环。当一个周期开始时的状态向量不再有显著变化时，即当连续状态之间差值的欧几里得范数小于一个小的容差 $\\epsilon$ 时：$\\|Y_{n+1} - Y_n\\|  \\epsilon$，即宣告收敛。我们使用一个鲁棒的数值 ODE 求解器 `scipy.integrate.solve_ivp` 来完成此任务。\n\n2.  **计算周期平均的已重构分数 $\\bar{x}$：** 一旦达到周期性稳态，设稳定周期开始时的状态为 $Y_{ss}$。然后，我们从 $Y_{ss}$ 开始，在一个周期内执行一次最终的高精度积分。为了计算积分 $\\int_{t_0}^{t_0+T} x(t)\\,dt$，我们指示 `solve_ivp` 函数产生“密集输出”。这提供了一个连续的插值函数（多项式样条），它在求解器的内部时间步之间精确地表示解 $x(t)$。\n周期平均值由下式给出：\n$$\n\\bar{x} = \\frac{1}{T}\\int_{t_{ss}}^{t_{ss} + T} x(t)\\,dt\n$$\n这个积分通过将其分解为与压力阶段相对应的两个部分来计算，并对由 `solve_ivp` 生成的 $x(t)$ 的插值函数使用标准的数值求积程序 `scipy.integrate.quad`：\n$$\n\\bar{x} = \\frac{1}{T} \\left( \\int_{t_{ss}}^{t_{ss}+dT} x_{\\mathrm{high}}(t)\\,dt + \\int_{t_{ss}+dT}^{t_{ss}+T} x_{\\mathrm{low}}(t)\\,dt \\right)\n$$\n其中 $x_{\\mathrm{high}}(t)$ 和 $x_{\\mathrm{low}}(t)$ 分别是高压和低压段期间的解函数。\n\n最终的实现将是一个 Python 脚本，该脚本定义了 ODE 系统和参数，然后对问题陈述中指定的四个测试案例中的每一个执行这个两阶段的数值程序。得到的 $\\bar{x}$ 值被四舍五入到六位小数，并格式化为一个列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp, quad\n\ndef solve():\n    \"\"\"\n    Solves the dynamic catalysis problem for all specified test cases.\n    \"\"\"\n\n    # Test suite of parameter sets.\n    test_cases = [\n        # Case 1 (balanced forcing, moderate period)\n        {\n            \"k_ads\": 5.0, \"k_des\": 0.5, \"k01_0\": 0.2, \"k10_0\": 0.05,\n            \"alpha\": 4.0, \"beta\": 2.0, \"p_low\": 0.1, \"p_high\": 1.0,\n            \"T\": 2.0, \"d\": 0.5,\n        },\n        # Case 2 (high-frequency forcing)\n        {\n            \"k_ads\": 5.0, \"k_des\": 0.5, \"k01_0\": 0.2, \"k10_0\": 0.05,\n            \"alpha\": 4.0, \"beta\": 2.0, \"p_low\": 0.1, \"p_high\": 1.0,\n            \"T\": 0.05, \"d\": 0.5,\n        },\n        # Case 3 (low-frequency forcing)\n        {\n            \"k_ads\": 5.0, \"k_des\": 0.5, \"k01_0\": 0.2, \"k10_0\": 0.05,\n            \"alpha\": 4.0, \"beta\": 2.0, \"p_low\": 0.1, \"p_high\": 1.0,\n            \"T\": 10.0, \"d\": 0.5,\n        },\n        # Case 4 (biased duty cycle)\n        {\n            \"k_ads\": 5.0, \"k_des\": 0.5, \"k01_0\": 0.2, \"k10_0\": 0.05,\n            \"alpha\": 4.0, \"beta\": 2.0, \"p_low\": 0.1, \"p_high\": 1.0,\n            \"T\": 2.0, \"d\": 0.8,\n        },\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_simulation(params)\n        results.append(f\"{result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef ode_system(t, y, p_A, params):\n    \"\"\"\n    Defines the system of coupled ODEs.\n    - y[0]: theta (coverage)\n    - y[1]: x (reconstructed fraction)\n    \"\"\"\n    theta, x = y\n    k_ads = params[\"k_ads\"]\n    k_des = params[\"k_des\"]\n    k01_0 = params[\"k01_0\"]\n    k10_0 = params[\"k10_0\"]\n    alpha = params[\"alpha\"]\n    beta = params[\"beta\"]\n\n    # Rate of change of coverage theta\n    dtheta_dt = k_ads * p_A * (1 - theta) - k_des * theta\n\n    # Coverage-dependent reconstruction/deconstruction rates\n    k01 = k01_0 * np.exp(alpha * theta)\n    k10 = k10_0 * np.exp(-beta * theta)\n\n    # Rate of change of reconstructed fraction x\n    dx_dt = k01 * (1 - x) - k10 * x\n\n    return [dtheta_dt, dx_dt]\n\ndef run_simulation(params):\n    \"\"\"\n    Runs the simulation for a single set of parameters to find the\n    cycle-averaged reconstructed fraction at periodic steady state.\n    \"\"\"\n    p_high = params[\"p_high\"]\n    p_low = params[\"p_low\"]\n    T = params[\"T\"]\n    d = params[\"d\"]\n\n    T_high = d * T\n    T_low = (1.0 - d) * T\n\n    # Initial conditions\n    y_current = np.array([0.0, 0.0])\n\n    # --- Stage 1: Find the periodic steady state (limit cycle) ---\n    max_periods = 1000  # Safety break\n    tolerance = 1e-12    # Convergence tolerance\n\n    y_ss_start = None\n    for i in range(max_periods):\n        y_start_period = y_current.copy()\n\n        # High pressure segment\n        sol_high = solve_ivp(\n            fun=ode_system,\n            t_span=[0, T_high],\n            y0=y_start_period,\n            args=(p_high, params),\n            method='RK45',\n            rtol=1e-8,\n            atol=1e-11\n        )\n        y_mid_period = sol_high.y[:, -1]\n\n        # Low pressure segment\n        sol_low = solve_ivp(\n            fun=ode_system,\n            t_span=[0, T_low],\n            y0=y_mid_period,\n            args=(p_low, params),\n            method='RK45',\n            rtol=1e-8,\n            atol=1e-11\n        )\n        y_end_period = sol_low.y[:, -1]\n\n        # Check for convergence to the limit cycle\n        if np.linalg.norm(y_end_period - y_start_period)  tolerance:\n            y_ss_start = y_end_period\n            break\n        \n        y_current = y_end_period\n    \n    if y_ss_start is None:\n        raise RuntimeError(\"Periodic steady state not reached within max_periods.\")\n\n    # --- Stage 2: Calculate the cycle-averaged value of x ---\n    # High pressure segment with dense output for quadrature\n    sol_high_dense = solve_ivp(\n        fun=ode_system,\n        t_span=[0, T_high],\n        y0=y_ss_start,\n        args=(p_high, params),\n        method='RK45',\n        dense_output=True,\n        rtol=1e-8,\n        atol=1e-11\n    )\n    y_mid_ss = sol_high_dense.y[:, -1]\n\n    # Low pressure segment with dense output for quadrature\n    sol_low_dense = solve_ivp(\n        fun=ode_system,\n        t_span=[T_high, T],\n        y0=y_mid_ss,\n        args=(p_low, params),\n        method='RK45',\n        dense_output=True,\n        rtol=1e-8,\n        atol=1e-11\n    )\n\n    # Use quadrature to integrate the dense solution for x(t)\n    integral_high, _ = quad(lambda t: sol_high_dense.sol(t)[1], 0, T_high)\n    integral_low, _ = quad(lambda t: sol_low_dense.sol(t)[1], T_high, T)\n\n    # Calculate cycle-averaged value\n    x_bar = (integral_high + integral_low) / T\n    \n    return x_bar\n\nsolve()\n```"
        },
        {
            "introduction": "除了外部强制振荡，催化系统内部的反馈机制也可能引发自发振荡，从而产生复杂的动态行为。本练习将焦点转向这种内禀动力学，指导您通过线性稳定性分析来判断一个包含吸附物-表面重构反馈回路的系统在何种条件下会产生自发振荡。理解这种内在不稳定性对于预测和控制催化反应的复杂行为至关重要。",
            "id": "3888657",
            "problem": "一个双变量动态模型捕捉了催化表面结构重构与吸附物覆盖率之间的反馈回路。令 $\\theta \\in [0,1]$ 表示催化位点上吸附物的部分覆盖率，令 $r \\in [0,1]$ 表示表面重构的部分程度。该模型遵循吸附和解吸的质量作用动力学，以及重构/弛豫的线性动力学，其中重构会降低吸附强度。具体来说，考虑以下常微分方程（ODE）系统\n$$\n\\frac{d\\theta}{dt} \\;=\\; k_{\\mathrm{ads}}\\,s_0\\,e^{-\\alpha r}\\,p\\,(1-\\theta) \\;-\\; k_{\\mathrm{des}}\\,\\theta,\n$$\n$$\n\\frac{dr}{dt} \\;=\\; k_{\\mathrm{rec}}\\,\\theta \\;-\\; k_{\\mathrm{rel}}\\,r,\n$$\n其中 $ k_{\\mathrm{ads}} $ 是单位压力下的吸附速率常数，单位为 $ \\mathrm{s}^{-1}\\,\\mathrm{bar}^{-1} $；$ s_0 $ 是无量纲的基础黏附/吸附强度；$ \\alpha $ 是无量纲的重构-吸附耦合强度（$ \\alpha $ 越大，随着 $ r $ 增加，吸附强度降低得越显著）；$ p $ 是吸附物分压，单位为 $ \\mathrm{bar} $；$ k_{\\mathrm{des}} $ 是解吸速率常数，单位为 $ \\mathrm{s}^{-1} $；$ k_{\\mathrm{rec}} $ 是重构形成速率常数，单位为 $ \\mathrm{s}^{-1} $；$ k_{\\mathrm{rel}} $ 是重构弛豫速率常数，单位为 $ \\mathrm{s}^{-1} $。所有参数均为正数。负反馈回路由因子 $ e^{-\\alpha r} $ 表示，该因子随着重构 $ r $ 的增加而降低吸附强度，这反过来又降低了覆盖率 $ \\theta $，从而减小了重构的驱动力。\n\n稳态 $ (\\theta^\\ast, r^\\ast) $ 满足\n$$\n0 \\;=\\; k_{\\mathrm{ads}}\\,s_0\\,e^{-\\alpha r^\\ast}\\,p\\,(1-\\theta^\\ast) \\;-\\; k_{\\mathrm{des}}\\,\\theta^\\ast,\n$$\n$$\n0 \\;=\\; k_{\\mathrm{rec}}\\,\\theta^\\ast \\;-\\; k_{\\mathrm{rel}}\\,r^\\ast,\n$$\n因此 $ r^\\ast = \\left(\\frac{k_{\\mathrm{rec}}}{k_{\\mathrm{rel}}}\\right)\\,\\theta^\\ast $，并且 $ \\theta^\\ast $ 是下式在 $ (0,1) $ 区间内的唯一根：\n$$\nf(\\theta) \\;=\\; k_{\\mathrm{ads}}\\,s_0\\,e^{-\\alpha \\left(\\frac{k_{\\mathrm{rec}}}{k_{\\mathrm{rel}}}\\right)\\theta}\\,p\\,(1-\\theta) \\;-\\; k_{\\mathrm{des}}\\,\\theta.\n$$\n为了分析 $ (\\theta^\\ast, r^\\ast) $ 附近线性响应的局部稳定性以及是否存在小振幅振荡，我们考虑在 $ (\\theta^\\ast,r^\\ast) $ 处求值的常微分方程组的雅可比矩阵 $ J $：\n$$\nJ \\;=\\; \\begin{bmatrix}\n\\frac{\\partial F}{\\partial \\theta}  \\frac{\\partial F}{\\partial r} \\\\\n\\frac{\\partial G}{\\partial \\theta}  \\frac{\\partial G}{\\partial r}\n\\end{bmatrix}_{(\\theta^\\ast,r^\\ast)} \\;=\\;\n\\begin{bmatrix}\n-\\,k_{\\mathrm{ads}}\\,s_0\\,e^{-\\alpha r^\\ast}\\,p \\;-\\; k_{\\mathrm{des}}  -\\,\\alpha\\,k_{\\mathrm{ads}}\\,s_0\\,e^{-\\alpha r^\\ast}\\,p\\,(1-\\theta^\\ast) \\\\\nk_{\\mathrm{rec}}  -\\,k_{\\mathrm{rel}}\n\\end{bmatrix}.\n$$\n定义迹 $ t = \\mathrm{tr}(J) $ 和行列式 $ d = \\det(J) $。$ J $ 的特征值 $ \\lambda $ 满足 $ \\lambda^2 - t\\,\\lambda + d = 0 $。当且仅当特征值为共轭复数时，稳态附近的线性化动力学中会出现小振幅振荡，这等价于判别式为负：\n$$\nt^2  4d\n$$\n如果 $t  0$，这些振荡是阻尼的；如果 $ t > 0 $，这些振荡是增长的。\n\n您的任务是：\n- 使用一个稳健的标量求根方法求解 $ f(\\theta) $，以在区间 $ (0,1) $ 内数值计算 $ \\theta^\\ast $。\n- 计算 $ r^\\ast = \\left(\\frac{k_{\\mathrm{rec}}}{k_{\\mathrm{rel}}}\\right)\\,\\theta^\\ast $。\n- 在 $ (\\theta^\\ast, r^\\ast) $ 处计算雅可比矩阵 $ J $，然后计算 $ t $ 和 $ d $。\n- 通过检查 $t^2  4d$ 来判断线性化动力学是否表现出振荡。如果该不等式成立（振荡响应），则返回布尔值 $ \\mathrm{True} $；否则（非振荡响应），返回 $ \\mathrm{False} $。\n\n物理单位：\n- 所有动力学速率常数 $ k_{\\mathrm{ads}} $（每 $ \\mathrm{bar} $）、$ k_{\\mathrm{des}} $、$ k_{\\mathrm{rec}} $ 和 $ k_{\\mathrm{rel}} $ 的单位使用 $ \\mathrm{s}^{-1} $。\n- 分压 $ p $ 的单位使用 $ \\mathrm{bar} $。\n- $ s_0 $ 和 $ \\alpha $ 是无量纲的。\n\n不涉及角度单位。不需要百分比输出。\n\n测试组：\n提供四组参数 $ (k_{\\mathrm{ads}}, s_0, \\alpha, p, k_{\\mathrm{des}}, k_{\\mathrm{rec}}, k_{\\mathrm{rel}}) $ 以测试不同情况：\n- 情况 1（弱耦合，预期非振荡）：$ (1.0,\\,1.0,\\,0.1,\\,1.0,\\,0.5,\\,0.1,\\,1.0) $。\n- 情况 2（强耦合，预期振荡）：$ (1.0,\\,1.0,\\,3.0,\\,1.0,\\,0.2,\\,1.0,\\,0.5) $。\n- 情况 3（中等耦合，可能振荡）：$ (1.0,\\,1.0,\\,2.0,\\,1.0,\\,0.3,\\,0.8,\\,0.5) $。\n- 情况 4（高压但重构效应极弱，预期非振荡）：$ (1.0,\\,1.0,\\,0.01,\\,10.0,\\,0.2,\\,0.5,\\,1.0) $。\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含按顺序排列的四个测试用例的结果，结果为逗号分隔的列表，并用方括号括起来。例如，输出必须类似于 $[result_1,result_2,result_3,result_4]$，其中每个 $ \\mathrm{result}_i $ 是一个布尔值 $ \\mathrm{True} $ 或 $ \\mathrm{False} $，表示根据准则 $t^2  4d$ 是否发生振荡。",
            "solution": "问题陈述已经过仔细审查，并被确定为有效。它提出了一个在计算化学工程领域中科学上合理、适定且客观的问题，具体涉及催化动态模型的稳定性分析。所有参数、方程和目标都已明确定义，构成了数值方法和动力系统理论的标准应用。\n\n该问题要求确定围绕稳态的线性化动力学是否表现出振荡。这涉及一个四步过程：\n1.  数值确定稳态吸附物覆盖率 $ \\theta^\\ast $。\n2.  计算稳态表面重构 $ r^\\ast $。\n3.  在稳态 $ (\\theta^\\ast, r^\\ast) $ 处计算系统雅可比矩阵的迹 $ t $ 和行列式 $ d $。\n4.  应用振荡行为的判据，该判据对应于雅可比矩阵的复数特征值。\n\n**第一步：稳态分析**\n\n系统的稳态 $ (\\theta^\\ast, r^\\ast) $ 由条件 $ \\frac{d\\theta}{dt} = 0 $ 和 $ \\frac{dr}{dt} = 0 $ 定义。\n第二个稳态方程 $ 0 = k_{\\mathrm{rec}}\\,\\theta^\\ast - k_{\\mathrm{rel}}\\,r^\\ast $ 提供了 $ r^\\ast $ 和 $ \\theta^\\ast $ 之间的直接线性关系：\n$$\nr^\\ast = \\left(\\frac{k_{\\mathrm{rec}}}{k_{\\mathrm{rel}}}\\right)\\theta^\\ast\n$$\n将此代入第一个稳态方程 $ 0 = k_{\\mathrm{ads}}\\,s_0\\,e^{-\\alpha r^\\ast}\\,p\\,(1-\\theta^\\ast) - k_{\\mathrm{des}}\\,\\theta^\\ast $，得到一个关于 $ \\theta^\\ast $ 的超越方程：\n$$\nf(\\theta^\\ast) = k_{\\mathrm{ads}}\\,s_0\\,p\\,e^{-\\alpha \\left(\\frac{k_{\\mathrm{rec}}}{k_{\\mathrm{rel}}}\\right)\\theta^\\ast}(1-\\theta^\\ast) - k_{\\mathrm{des}}\\,\\theta^\\ast = 0\n$$\n为了求解 $ \\theta^\\ast $，我们必须在物理上有意义的区间 $ (0, 1) $ 内找到函数 $ f(\\theta) $ 的根。我们可以分析函数在区间边界处的取值：\n-   在 $ \\theta = 0 $ 处，$ f(0) = k_{\\mathrm{ads}}\\,s_0\\,p\\,e^0(1-0) - k_{\\mathrm{des}}(0) = k_{\\mathrm{ads}}\\,s_0\\,p $。由于所有参数 $ k_{\\mathrm{ads}} $、$ s_0 $ 和 $ p $ 均为正数，所以 $ f(0) > 0 $。\n-   在 $ \\theta = 1 $ 处，$ f(1) = k_{\\mathrm{ads}}\\,s_0\\,p\\,e^{-\\alpha (k_{\\mathrm{rec}}/k_{\\mathrm{rel}})}(1-1) - k_{\\mathrm{des}}(1) = -k_{\\mathrm{des}} $。由于 $ k_{\\mathrm{des}} > 0 $，所以 $ f(1)  0 $。\n\n由于 $ f(\\theta) $ 在 $ [0, 1] $ 上连续，且 $ f(0) > 0 $ 和 $ f(1)  0 $，根据介值定理，保证在 $ (0, 1) $ 区间内至少存在一个根 $ \\theta^\\ast $。问题陈述断言该根是唯一的。一个稳健的数值求根算法，例如 Brent-Dekker 方法（在 SciPy 中为 `brentq`），适合在给定区间 $ (0, 1) $ 内定位该根。\n\n**第二步：雅可比矩阵与简化**\n\n稳态的局部稳定性由在 $ (\\theta^\\ast, r^\\ast) $ 处求值的雅可比矩阵 $ J $ 的特征值决定。雅可比矩阵的一般形式如下：\n$$\nJ =\n\\begin{bmatrix}\n-\\,k_{\\mathrm{ads}}\\,s_0\\,p\\,e^{-\\alpha r} - k_{\\mathrm{des}}  -\\,\\alpha\\,k_{\\mathrm{ads}}\\,s_0\\,p\\,e^{-\\alpha r}(1-\\theta) \\\\\nk_{\\mathrm{rec}}  -\\,k_{\\mathrm{rel}}\n\\end{bmatrix}\n$$\n我们可以通过代入稳态条件 $ k_{\\mathrm{ads}}\\,s_0\\,p\\,e^{-\\alpha r^\\ast}(1-\\theta^\\ast) = k_{\\mathrm{des}}\\theta^\\ast $ 来简化雅可比矩阵的元素。\n\n对于右上角的元素 $ J_{12} $：\n$$\nJ_{12}(\\theta^\\ast, r^\\ast) = -\\alpha\\,k_{\\mathrm{ads}}\\,s_0\\,p\\,e^{-\\alpha r^\\ast}(1-\\theta^\\ast) = -\\alpha (k_{\\mathrm{des}}\\theta^\\ast)\n$$\n对于左上角的元素 $ J_{11} $：\n首先，从稳态方程中表示出 $ k_{\\mathrm{ads}}\\,s_0\\,p\\,e^{-\\alpha r^\\ast} $：\n$$\nk_{\\mathrm{ads}}\\,s_0\\,p\\,e^{-\\alpha r^\\ast} = \\frac{k_{\\mathrm{des}}\\theta^\\ast}{1-\\theta^\\ast}\n$$\n现在将此代入 $ J_{11} $ 的表达式中：\n$$\nJ_{11}(\\theta^\\ast, r^\\ast) = -\\left(\\frac{k_{\\mathrm{des}}\\theta^\\ast}{1-\\theta^\\ast}\\right) - k_{\\mathrm{des}} = -k_{\\mathrm{des}}\\left(\\frac{\\theta^\\ast}{1-\\theta^\\ast} + 1\\right) = -k_{\\mathrm{des}}\\left(\\frac{\\theta^\\ast + 1 - \\theta^\\ast}{1-\\theta^\\ast}\\right) = -\\frac{k_{\\mathrm{des}}}{1-\\theta^\\ast}\n$$\n在稳态 $ (\\theta^\\ast, r^\\ast) $ 处的简化雅可比矩阵为：\n$$\nJ^\\ast =\n\\begin{bmatrix}\n-\\frac{k_{\\mathrm{des}}}{1-\\theta^\\ast}  -\\alpha\\,k_{\\mathrm{des}}\\theta^\\ast \\\\\nk_{\\mathrm{rec}}  -k_{\\mathrm{rel}}\n\\end{bmatrix}\n$$\n这种简化形式在计算上更高效、更稳健，因为它避免了重新计算指数项，并且仅依赖于已知的速率常数和数值确定的 $ \\theta^\\ast $。\n\n**第三步：振荡判据**\n\n一个 $ 2 \\times 2 $ 矩阵的特征值 $ \\lambda $ 是特征方程 $ \\lambda^2 - t\\lambda + d = 0 $ 的根，其中 $ t = \\mathrm{tr}(J^\\ast) $ 是迹，$ d = \\det(J^\\ast) $ 是行列式。\n解为 $ \\lambda = \\frac{t \\pm \\sqrt{t^2 - 4d}}{2} $。\n\n当且仅当特征值为一对共轭复数时，系统表现出小振幅振荡。这发生在特征方程的判别式为负时：\n$$\nt^2 - 4d  0 \\quad \\implies \\quad t^2  4d\n$$\n\n简化雅可比矩阵 $ J^\\ast $ 的迹 $ t $ 和行列式 $ d $ 为：\n$$\nt = \\mathrm{tr}(J^\\ast) = -\\frac{k_{\\mathrm{des}}}{1-\\theta^\\ast} - k_{\\mathrm{rel}}\n$$\n$$\nd = \\det(J^\\ast) = \\left(-\\frac{k_{\\mathrm{des}}}{1-\\theta^\\ast}\\right)(-k_{\\mathrm{rel}}) - (-\\alpha\\,k_{\\mathrm{des}}\\theta^\\ast)(k_{\\mathrm{rec}}) = \\frac{k_{\\mathrm{des}}k_{\\mathrm{rel}}}{1-\\theta^\\ast} + \\alpha\\,k_{\\mathrm{des}}k_{\\mathrm{rec}}\\theta^\\ast\n$$\n由于所有参数均为正数且 $ \\theta^\\ast \\in (0, 1) $，很明显 $ t  0 $ 且 $ d > 0 $。条件 $ t  0 $ 确保了稳态总是稳定的（阻尼响应），意味着任何振荡都会随时间衰减。我们的任务仅仅是确定这些振荡是否存在，这由不等式 $ t^2  4d $ 控制。\n\n**第四步：算法**\n\n对于每组参数 $ (k_{\\mathrm{ads}}, s_0, \\alpha, p, k_{\\mathrm{des}}, k_{\\mathrm{rec}}, k_{\\mathrm{rel}}) $：\n1.  定义函数 $ f(\\theta) = k_{\\mathrm{ads}}\\,s_0\\,p\\,\\exp(-\\alpha (k_{\\mathrm{rec}}/k_{\\mathrm{rel}})\\theta)(1-\\theta) - k_{\\mathrm{des}}\\theta $。\n2.  使用数值求解器在区间 $ (0, 1) $ 内找到 $ f(\\theta) = 0 $ 的根 $ \\theta^\\ast $。\n3.  计算迹 $ t = -\\frac{k_{\\mathrm{des}}}{1-\\theta^\\ast} - k_{\\mathrm{rel}} $。\n4.  计算行列式 $ d = \\frac{k_{\\mathrm{des}}k_{\\mathrm{rel}}}{1-\\theta^\\ast} + \\alpha\\,k_{\\mathrm{des}}k_{\\mathrm{rec}}\\theta^\\ast $。\n5.  计算布尔表达式 $ t^2  4d $。如果存在振荡，则返回 `True`，否则返回 `False`。\n此过程将应用于提供的四个测试用例中的每一个。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves for the presence of oscillations in a catalytic surface model\n    for a given set of test cases.\n    \"\"\"\n\n    test_cases = [\n        # (k_ads, s0, alpha, p, k_des, k_rec, k_rel)\n        (1.0, 1.0, 0.1, 1.0, 0.5, 0.1, 1.0),\n        (1.0, 1.0, 3.0, 1.0, 0.2, 1.0, 0.5),\n        (1.0, 1.0, 2.0, 1.0, 0.3, 0.8, 0.5),\n        (1.0, 1.0, 0.01, 10.0, 0.2, 0.5, 1.0),\n    ]\n\n    def check_oscillations(params):\n        \"\"\"\n        For a single set of parameters, determines if the system exhibits oscillations.\n\n        Args:\n            params (tuple): A tuple containing the 7 model parameters.\n\n        Returns:\n            bool: True if oscillations occur (t^2  4d), False otherwise.\n        \"\"\"\n        k_ads, s0, alpha, p, k_des, k_rec, k_rel = params\n\n        # Define the function f(theta) whose root is the steady-state coverage theta_star.\n        # f(theta) = k_ads*s0*exp(-alpha*(k_rec/k_rel)*theta)*p*(1-theta) - k_des*theta\n        def f(theta):\n            # The exponential term can lead to overflow if args are large, though not\n            # expected for these parameters. Using np.exp for robustness.\n            kappa = k_rec / k_rel\n            adsorption_term = k_ads * s0 * p * np.exp(-alpha * kappa * theta) * (1.0 - theta)\n            desorption_term = k_des * theta\n            return adsorption_term - desorption_term\n\n        # Find the steady-state coverage theta_star in the interval (0, 1).\n        # We use a small epsilon from the boundaries to avoid potential floating point\n        # issues at exactly 0 or 1, although brentq handles it well.\n        # The function f(theta) is guaranteed to have a root in (0,1) because\n        # f(0) > 0 and f(1)  0.\n        theta_star = brentq(f, 0.0, 1.0)\n        \n        # Guard against theta_star being exactly 1 (unlikely, but defensive)\n        if theta_star >= 1.0:\n            # This case should not be reached with the given model physics.\n            # It would imply k_des is zero, which is ruled out.\n            # If it occurs due to numerical precision, it implies a non-oscillatory\n            # divergent case, but we stick to the model assumptions.\n            return False\n\n        # Calculate the trace (t) and determinant (d) of the simplified Jacobian.\n        # t = -k_des / (1 - theta_star) - k_rel\n        # d = (k_des * k_rel) / (1 - theta_star) + alpha * k_des * k_rec * theta_star\n        \n        term_1_over_1_minus_theta = 1.0 / (1.0 - theta_star)\n        \n        trace_t = -k_des * term_1_over_1_minus_theta - k_rel\n        \n        det_d = k_des * k_rel * term_1_over_1_minus_theta + alpha * k_des * k_rec * theta_star\n\n        # Check for oscillations: t^2  4d\n        return trace_t**2  4.0 * det_d\n\n    results = []\n    for case in test_cases:\n        result = check_oscillations(case)\n        results.append(result)\n\n    # Format the output as a string representation of a Python list of booleans.\n    # Note: str(True) -> \"True\", not \"true\". The problem asks for this format.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n\n```"
        }
    ]
}