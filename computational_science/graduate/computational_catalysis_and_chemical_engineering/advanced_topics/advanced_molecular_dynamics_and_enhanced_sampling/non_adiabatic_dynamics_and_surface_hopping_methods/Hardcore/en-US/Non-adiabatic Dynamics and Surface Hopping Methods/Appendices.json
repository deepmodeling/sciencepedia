{
    "hands_on_practices": [
        {
            "introduction": "A non-adiabatic dynamics simulation is only as reliable as the electronic structure data it is built upon. This practice focuses on the essential first step: calculating the potential energy surfaces and the non-adiabatic couplings (NACs) that govern transitions between them. You will use the Hellmann–Feynman theorem, a cornerstone of computational chemistry, to compute the derivative coupling $d_{ij}(R)$ from a model diabatic Hamiltonian . This exercise provides a direct look at how these crucial inputs are generated and highlights their sensitivity to the underlying model, mimicking the practical challenge of choosing an appropriate electronic structure method and basis set.",
            "id": "3892349",
            "problem": "Consider a one-dimensional nuclear coordinate $R$ representing the metal–adsorbate bond length for a small molecule on a catalytic surface. In a minimal two-state diabatic representation, the electronic Hamiltonian is modeled as a $2 \\times 2$ matrix $H_{\\mathrm{d}}(R)$ with diabatic potentials coupled by a localized interaction. Two different parameterizations mimic two different electronic structure basis-set choices (labeled \"A\" and \"B\"). For each basis-set choice, define\n$$\nH_{\\mathrm{d}}(R) = \n\\begin{bmatrix}\nA_1 + k_1 R  V_0 \\exp\\left(-\\frac{(R - R_c)^2}{2 \\sigma^2}\\right) \\\\\nV_0 \\exp\\left(-\\frac{(R - R_c)^2}{2 \\sigma^2}\\right)  A_2 - k_2 R\n\\end{bmatrix},\n$$\nwhere $A_1$ and $A_2$ are energy offsets in electronvolts (eV), $k_1$ and $k_2$ are slopes in eV/Å, $V_0$ is a coupling strength in eV, $R_c$ is the crossing coordinate in ångström (Å), and $\\sigma$ is the coupling width in Å. The adiabatic energies $E_1(R)$ and $E_2(R)$ and adiabatic electronic states $\\{ \\lvert \\phi_1(R) \\rangle, \\lvert \\phi_2(R) \\rangle \\}$ are obtained by diagonalizing $H_{\\mathrm{d}}(R)$.\n\nThe non-adiabatic derivative coupling between adiabatic states $i$ and $j$ along $R$ is defined by the fundamental relation\n$$\nd_{ij}(R) = \\langle \\phi_i(R) \\vert \\nabla_R \\phi_j(R) \\rangle,\n$$\nwhich governs electronic transitions in mixed quantum-classical dynamics such as surface hopping. Using the Hellmann–Feynman theorem (a well-tested result), for non-degenerate states $i \\neq j$,\n$$\nd_{ij}(R) = \\frac{\\langle \\phi_i(R) \\vert \\partial H_{\\mathrm{d}}(R)/\\partial R \\vert \\phi_j(R) \\rangle}{E_j(R) - E_i(R)}.\n$$\nIn this problem, you will compute the excited-state energy $E_2(R)$ and the derivative coupling $d_{12}(R)$ for two different parameter sets (\"basis-set A\" and \"basis-set B\"), and quantitatively assess how the basis-set choice influences $d_{12}(R)$ over a specified grid of $R$ values.\n\nFor each test case, perform the following steps:\n1. Construct $H_{\\mathrm{d}}(R)$ for each $R$ on the grid for both basis-set parameterizations.\n2. Diagonalize $H_{\\mathrm{d}}(R)$ to obtain $E_1(R)$, $E_2(R)$ and corresponding orthonormal adiabatic eigenvectors $\\lvert \\phi_1(R) \\rangle$, $\\lvert \\phi_2(R) \\rangle$, ordered so that $E_1(R) \\le E_2(R)$.\n3. Compute\n$$\n\\frac{\\partial H_{\\mathrm{d}}(R)}{\\partial R} =\n\\begin{bmatrix}\nk_1  \\frac{\\partial V(R)}{\\partial R} \\\\\n\\frac{\\partial V(R)}{\\partial R}  -k_2\n\\end{bmatrix},\n\\quad \\text{where} \\quad\nV(R) = V_0 \\exp\\left(-\\frac{(R - R_c)^2}{2 \\sigma^2}\\right),\n$$\nand\n$$\n\\frac{\\partial V(R)}{\\partial R} = V_0 \\exp\\left(-\\frac{(R - R_c)^2}{2 \\sigma^2}\\right)\\left(-\\frac{R - R_c}{\\sigma^2}\\right).\n$$\n4. Evaluate\n$$\nd_{12}(R) = \\frac{\\langle \\phi_1(R) \\vert \\partial H_{\\mathrm{d}}(R)/\\partial R \\vert \\phi_2(R) \\rangle}{E_2(R) - E_1(R)},\n$$\nfor each $R$ on the grid. If $E_2(R) - E_1(R)$ is numerically too small, regularize by replacing the denominator with $\\max\\left(E_2(R) - E_1(R), \\varepsilon\\right)$, where $\\varepsilon$ is a small positive constant (choose $\\varepsilon = 10^{-12}$ eV) to maintain numerical stability while reflecting the physical divergence tendency near exact crossings.\n5. Quantify the influence of basis-set choice on $d_{12}(R)$ by computing:\n   - The maximum absolute difference over the grid,\n     $$\n     \\Delta_{\\max} = \\max_{R} \\left| d^{(A)}_{12}(R) - d^{(B)}_{12}(R) \\right|,\n     $$\n   - The root-mean-square (RMS) difference over the grid,\n     $$\n     \\Delta_{\\mathrm{RMS}} = \\sqrt{\\frac{1}{N} \\sum_{n=1}^{N} \\left( d^{(A)}_{12}(R_n) - d^{(B)}_{12}(R_n) \\right)^2 },\n     $$\n     where $N$ is the number of grid points.\n   - The excited-state energies at the crossing coordinate for each basis-set parameterization,\n     $$\n     E^{(A)}_2(R_c) \\quad \\text{and} \\quad E^{(B)}_2(R_c),\n     $$\n     in electronvolts (eV).\n\nUnits:\n- Express all energies in electronvolts (eV).\n- Express all derivative couplings $d_{12}(R)$ and their differences in inverse ångström ($\\mathrm{\\AA}^{-1}$).\n- The coordinate $R$ is in ångström ($\\mathrm{\\AA}$).\n\nYour program must compute, for each test case, the list of four floating-point results\n$$\n\\left[\\Delta_{\\max}, \\Delta_{\\mathrm{RMS}}, E^{(A)}_2(R_c), E^{(B)}_2(R_c)\\right],\n$$\nand produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, where each element is the list for one test case (e.g., \"[[...],[...],...]\").\n\nTest Suite:\nUse the following four test cases, each specified by two parameter sets (\"A\" and \"B\") and a grid for $R$:\n- Case 1 (moderate coupling, avoided crossing):\n  - Basis-set A: $A_1 = 0.0$ eV, $A_2 = 0.20$ eV, $k_1 = 0.50$ eV/$\\mathrm{\\AA}$, $k_2 = 0.40$ eV/$\\mathrm{\\AA}$, $V_0 = 0.15$ eV, $R_c = 2.20$ $\\mathrm{\\AA}$, $\\sigma = 0.12$ $\\mathrm{\\AA}$.\n  - Basis-set B: $A_1 = 0.0$ eV, $A_2 = 0.22$ eV, $k_1 = 0.50$ eV/$\\mathrm{\\AA}$, $k_2 = 0.45$ eV/$\\mathrm{\\AA}$, $V_0 = 0.10$ eV, $R_c = 2.20$ $\\mathrm{\\AA}$, $\\sigma = 0.12$ $\\mathrm{\\AA}$.\n  - Grid: $R$ from $1.50$ $\\mathrm{\\AA}$ to $3.00$ $\\mathrm{\\AA}$ in steps of $0.01$ $\\mathrm{\\AA}$.\n- Case 2 (near-degeneracy, small coupling width):\n  - Basis-set A: $A_1 = -0.05$ eV, $A_2 = 0.25$ eV, $k_1 = 0.60$ eV/$\\mathrm{\\AA}$, $k_2 = 0.60$ eV/$\\mathrm{\\AA}$, $V_0 = 0.02$ eV, $R_c = 2.00$ $\\mathrm{\\AA}$, $\\sigma = 0.08$ $\\mathrm{\\AA}$.\n  - Basis-set B: $A_1 = -0.04$ eV, $A_2 = 0.23$ eV, $k_1 = 0.58$ eV/$\\mathrm{\\AA}$, $k_2 = 0.62$ eV/$\\mathrm{\\AA}$, $V_0 = 0.05$ eV, $R_c = 2.00$ $\\mathrm{\\AA}$, $\\sigma = 0.09$ $\\mathrm{\\AA}$.\n  - Grid: $R$ from $1.80$ $\\mathrm{\\AA}$ to $2.20$ $\\mathrm{\\AA}$ in steps of $0.001$ $\\mathrm{\\AA}$.\n- Case 3 (consistency check, identical basis sets):\n  - Basis-set A: $A_1 = 0.10$ eV, $A_2 = 0.30$ eV, $k_1 = 0.30$ eV/$\\mathrm{\\AA}$, $k_2 = 0.30$ eV/$\\mathrm{\\AA}$, $V_0 = 0.07$ eV, $R_c = 1.80$ $\\mathrm{\\AA}$, $\\sigma = 0.15$ $\\mathrm{\\AA}$.\n  - Basis-set B: $A_1 = 0.10$ eV, $A_2 = 0.30$ eV, $k_1 = 0.30$ eV/$\\mathrm{\\AA}$, $k_2 = 0.30$ eV/$\\mathrm{\\AA}$, $V_0 = 0.07$ eV, $R_c = 1.80$ $\\mathrm{\\AA}$, $\\sigma = 0.15$ $\\mathrm{\\AA}$.\n  - Grid: $R$ from $1.00$ $\\mathrm{\\AA}$ to $2.60$ $\\mathrm{\\AA}$ in steps of $0.02$ $\\mathrm{\\AA}$.\n- Case 4 (broad scan, different crossing locations and widths):\n  - Basis-set A: $A_1 = -0.20$ eV, $A_2 = 0.40$ eV, $k_1 = 0.80$ eV/$\\mathrm{\\AA}$, $k_2 = 0.70$ eV/$\\mathrm{\\AA}$, $V_0 = 0.12$ eV, $R_c = 3.00$ $\\mathrm{\\AA}$, $\\sigma = 0.25$ $\\mathrm{\\AA}$.\n  - Basis-set B: $A_1 = -0.18$ eV, $A_2 = 0.42$ eV, $k_1 = 0.78$ eV/$\\mathrm{\\AA}$, $k_2 = 0.72$ eV/$\\mathrm{\\AA}$, $V_0 = 0.08$ eV, $R_c = 3.10$ $\\mathrm{\\AA}$, $\\sigma = 0.30$ $\\mathrm{\\AA}$.\n  - Grid: $R$ from $0.50$ $\\mathrm{\\AA}$ to $5.00$ $\\mathrm{\\AA}$ in steps of $0.05$ $\\mathrm{\\AA}$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with one sub-list per test case and each sub-list ordered as $\\left[\\Delta_{\\max}, \\Delta_{\\mathrm{RMS}}, E^{(A)}_2(R_c), E^{(B)}_2(R_c)\\right]$. For example:\n\"[[result_case1],[result_case2],[result_case3],[result_case4]]\".",
            "solution": "The problem requires a quantitative analysis of the non-adiabatic derivative coupling, $d_{12}(R)$, between two electronic states for a model system representing a molecule-surface interaction. The core task is to assess the sensitivity of this coupling to the parameterization of the underlying diabatic electronic Hamiltonian, $H_{\\mathrm{d}}(R)$, which mimics the choice of different electronic structure basis sets.\n\nThe theoretical framework is rooted in the time-independent Schrödinger equation for the electrons at a fixed nuclear geometry $R$. In the diabatic representation, the electronic states are chosen to have smooth, slowly varying characters with respect to $R$, which results in a non-diagonal Hamiltonian matrix. The provided model is a two-state system described by the Hamiltonian:\n$$\nH_{\\mathrm{d}}(R) = \n\\begin{bmatrix}\nH_{11}(R)  H_{12}(R) \\\\\nH_{21}(R)  H_{22}(R)\n\\end{bmatrix} =\n\\begin{bmatrix}\nA_1 + k_1 R  V(R) \\\\\nV(R)  A_2 - k_2 R\n\\end{bmatrix}\n$$\nwhere $H_{11}(R)$ and $H_{22}(R)$ are the diabatic potential energies, representing two electronic configurations that cross in the absence of interaction. The off-diagonal term, $V(R) = V_0 \\exp\\left(-\\frac{(R - R_c)^2}{2 \\sigma^2}\\right)$, is a localized, Gaussian-shaped coupling that causes the diabatic states to interact.\n\nThe adiabatic electronic states, $\\{ \\lvert \\phi_i(R) \\rangle \\}$, and their corresponding potential energy surfaces, $E_i(R)$, are found by solving the eigenvalue problem for this Hamiltonian at each nuclear configuration $R$:\n$$\nH_{\\mathrm{d}}(R) \\lvert \\phi_j(R) \\rangle = E_j(R) \\lvert \\phi_j(R) \\rangle\n$$\nThis procedure, known as diagonalization, transforms the description from the diabatic basis to the adiabatic basis, where the Hamiltonian is diagonal by definition. The resulting adiabatic energies $E_1(R)$ and $E_2(R)$ (ordered such that $E_1(R) \\le E_2(R)$) form the potential energy surfaces upon which nuclear motion occurs in the Born-Oppenheimer approximation.\n\nHowever, the Born-Oppenheimer approximation breaks down where adiabatic potential energy surfaces approach each other, necessitating the inclusion of non-adiabatic couplings. The derivative coupling, $d_{ij}(R) = \\langle \\phi_i(R) \\vert \\nabla_R \\phi_j(R) \\rangle$, quantifies the strength of kinetic coupling between adiabatic states. A large coupling indicates a high probability of an electronic transition (a \"surface hop\"). Direct numerical differentiation of the eigenvectors $\\lvert \\phi_j(R) \\rangle$ is numerically unstable, especially near degeneracies. The Hellmann-Feynman theorem provides a stable and elegant alternative for non-degenerate states ($E_i \\neq E_j$):\n$$\nd_{ij}(R) = \\frac{\\langle \\phi_i(R) \\vert \\partial H_{\\mathrm{d}}(R)/\\partial R \\vert \\phi_j(R) \\rangle}{E_j(R) - E_i(R)}\n$$\nThis formula relates the derivative of an eigenvector to a matrix element of the derivative of the Hamiltonian operator, which is straightforward to compute. For our model, the derivative Hamiltonian is:\n$$\n\\frac{\\partial H_{\\mathrm{d}}(R)}{\\partial R} =\n\\begin{bmatrix}\nk_1  \\frac{\\partial V(R)}{\\partial R} \\\\\n\\frac{\\partial V(R)}{\\partial R}  -k_2\n\\end{bmatrix}\n\\quad \\text{with} \\quad\n\\frac{\\partial V(R)}{\\partial R} = -V_0 \\frac{R - R_c}{\\sigma^2} \\exp\\left(-\\frac{(R - R_c)^2}{2 \\sigma^2}\\right)\n$$\n\nThe computational procedure to solve the problem is as follows:\n\n1.  **Grid Discretization**: The continuous coordinate $R$ is sampled over a discrete grid of $N$ points, $\\{R_n\\}$, as specified for each test case.\n\n2.  **Hamiltonian Construction**: For each parameter set (\"A\" and \"B\") and for each grid point $R_n$, the matrices $H_{\\mathrm{d}}(R_n)$ and $\\partial H_{\\mathrm{d}}(R_n)/\\partial R$ are constructed. This is performed efficiently using vectorized numerical operations over the entire grid.\n\n3.  **Adiabatic Transformation**: For each $R_n$, the Hamiltonian matrix $H_{\\mathrm{d}}(R_n)$ is diagonalized. Since $H_{\\mathrm{d}}(R)$ is real and symmetric, this yields real eigenvalues $E_1(R_n), E_2(R_n)$ and a set of real, orthonormal eigenvectors $|\\phi_1(R_n)\\rangle, |\\phi_2(R_n)\\rangle$. A stack of matrices, one for each grid point, is diagonalized simultaneously for computational efficiency.\n\n4.  **Derivative Coupling Computation**: The non-adiabatic coupling $d_{12}(R_n)$ is computed using the Hellmann-Feynman expression. The numerator, $\\langle \\phi_1_n | \\partial H_{\\mathrm{d},n}/\\partial R | \\phi_2_n \\rangle$, is calculated as a matrix product. The denominator is the energy gap, $E_2(R_n) - E_1(R_n)$. To prevent numerical divergence at or near the crossing point where the gap may be very small, the denominator is regularized by taking $\\max(E_2(R_n) - E_1(R_n), \\varepsilon)$ with the specified small constant $\\varepsilon = 10^{-12}$ eV.\n\n5.  **Quantitative Comparison**: The resulting derivative coupling functions, $d^{(A)}_{12}(R)$ and $d^{(B)}_{12}(R)$, are compared. The maximum absolute difference, $\\Delta_{\\max}$, and the root-mean-square (RMS) difference, $\\Delta_{\\mathrm{RMS}}$, are calculated over the grid to quantify the overall discrepancy introduced by the change in basis-set parameterization.\n\n6.  **Energetic Analysis**: The excited adiabatic state energy at the diabatic crossing point, $E_2(R_c)$, is calculated for each basis set. This value is significant as $2V(R_c) = 2V_0$ represents the energy gap at the diabatic crossing, $E_2(R_c) - E_1(R_c)$, and is a key indicator of the coupling strength. The calculation is performed for each basis set at its own respective $R_c$.\n\nBy executing this procedure for each test case, we can systematically evaluate how variations in the underlying electronic structure model propagate to the non-adiabatic couplings that govern reaction dynamics.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _calculate_quantities(params, R_grid):\n    \"\"\"\n    Computes the derivative coupling d12(R) over a grid and the\n    excited-state energy E2(Rc) for a given parameter set.\n    \"\"\"\n    epsilon = 1e-12\n    A1 = params[\"A1\"]\n    A2 = params[\"A2\"]\n    k1 = params[\"k1\"]\n    k2 = params[\"k2\"]\n    V0 = params[\"V0\"]\n    Rc = params[\"Rc\"]\n    sigma = params[\"sigma\"]\n\n    # --- Vectorized calculation over the grid ---\n    R = R_grid\n    \n    # Calculate off-diagonal term and its derivative\n    exp_arg = -(R - Rc)**2 / (2 * sigma**2)\n    exp_term = np.exp(exp_arg)\n    V_R = V0 * exp_term\n    dV_dR = V_R * (-(R - Rc) / sigma**2)\n\n    # Construct stacks of Hamiltonian and derivative Hamiltonian matrices\n    H11 = A1 + k1 * R\n    H22 = A2 - k2 * R\n    \n    # Stack of Hamiltonians, shape (N, 2, 2)\n    Hd_stack = np.zeros((R.shape[0], 2, 2))\n    Hd_stack[:, 0, 0] = H11\n    Hd_stack[:, 1, 1] = H22\n    Hd_stack[:, 0, 1] = V_R\n    Hd_stack[:, 1, 0] = V_R\n    \n    # Stack of derivative Hamiltonians\n    dHd_dR_stack = np.zeros((R.shape[0], 2, 2))\n    dHd_dR_stack[:, 0, 0] = k1\n    dHd_dR_stack[:, 1, 1] = -k2\n    dHd_dR_stack[:, 0, 1] = dV_dR\n    dHd_dR_stack[:, 1, 0] = dV_dR\n\n    # Diagonalize all matrices in the stack at once\n    eivals_stack, eivecs_stack = np.linalg.eigh(Hd_stack)\n    \n    E1 = eivals_stack[:, 0]\n    E2 = eivals_stack[:, 1]\n    phi1 = eivecs_stack[:, :, 0]\n    phi2 = eivecs_stack[:, :, 1]\n    \n    # Calculate derivative coupling using Hellmann-Feynman theorem\n    energy_gap = E2 - E1\n    denominator = np.maximum(energy_gap, epsilon)\n    \n    # Numerator via batched matrix-vector products using einsum\n    numerator = np.einsum('ni,nij,nj-n', phi1, dHd_dR_stack, phi2)\n    \n    d12_values = numerator / denominator\n\n    # --- Scalar calculation for E2 at the specific Rc for this basis ---\n    R_c_val = Rc\n    V_at_Rc = V0  # exp term is 1 at R = Rc\n    \n    H11_rc = A1 + k1 * R_c_val\n    H22_rc = A2 - k2 * R_c_val\n    \n    Hd_rc = np.array([[H11_rc, V_at_Rc], [V_at_Rc, H22_rc]])\n    eivals_rc, _ = np.linalg.eigh(Hd_rc)\n    E2_at_Rc = eivals_rc[1]\n    \n    return d12_values, E2_at_Rc\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"A\": {\"A1\": 0.0, \"A2\": 0.20, \"k1\": 0.50, \"k2\": 0.40, \"V0\": 0.15, \"Rc\": 2.20, \"sigma\": 0.12},\n            \"B\": {\"A1\": 0.0, \"A2\": 0.22, \"k1\": 0.50, \"k2\": 0.45, \"V0\": 0.10, \"Rc\": 2.20, \"sigma\": 0.12},\n            \"grid\": {\"start\": 1.50, \"stop\": 3.00, \"step\": 0.01}\n        },\n        # Case 2\n        {\n            \"A\": {\"A1\": -0.05, \"A2\": 0.25, \"k1\": 0.60, \"k2\": 0.60, \"V0\": 0.02, \"Rc\": 2.00, \"sigma\": 0.08},\n            \"B\": {\"A1\": -0.04, \"A2\": 0.23, \"k1\": 0.58, \"k2\": 0.62, \"V0\": 0.05, \"Rc\": 2.00, \"sigma\": 0.09},\n            \"grid\": {\"start\": 1.80, \"stop\": 2.20, \"step\": 0.001}\n        },\n        # Case 3\n        {\n            \"A\": {\"A1\": 0.10, \"A2\": 0.30, \"k1\": 0.30, \"k2\": 0.30, \"V0\": 0.07, \"Rc\": 1.80, \"sigma\": 0.15},\n            \"B\": {\"A1\": 0.10, \"A2\": 0.30, \"k1\": 0.30, \"k2\": 0.30, \"V0\": 0.07, \"Rc\": 1.80, \"sigma\": 0.15},\n            \"grid\": {\"start\": 1.00, \"stop\": 2.60, \"step\": 0.02}\n        },\n        # Case 4\n        {\n            \"A\": {\"A1\": -0.20, \"A2\": 0.40, \"k1\": 0.80, \"k2\": 0.70, \"V0\": 0.12, \"Rc\": 3.00, \"sigma\": 0.25},\n            \"B\": {\"A1\": -0.18, \"A2\": 0.42, \"k1\": 0.78, \"k2\": 0.72, \"V0\": 0.08, \"Rc\": 3.10, \"sigma\": 0.30},\n            \"grid\": {\"start\": 0.50, \"stop\": 5.00, \"step\": 0.05}\n        }\n    ]\n\n    results = []\n    for case_data in test_cases:\n        params_A = case_data[\"A\"]\n        params_B = case_data[\"B\"]\n        grid_params = case_data[\"grid\"]\n\n        # Generate a robust grid using linspace\n        num_points = int(round((grid_params[\"stop\"] - grid_params[\"start\"]) / grid_params[\"step\"])) + 1\n        R_grid = np.linspace(grid_params[\"start\"], grid_params[\"stop\"], num_points)\n\n        # Calculate quantities for basis-set A\n        d12_A, E2_A_at_Rc = _calculate_quantities(params_A, R_grid)\n\n        # Calculate quantities for basis-set B\n        d12_B, E2_B_at_Rc = _calculate_quantities(params_B, R_grid)\n\n        # Compute the difference metrics\n        diff_d12 = d12_A - d12_B\n        delta_max = np.max(np.abs(diff_d12))\n        delta_rms = np.sqrt(np.mean(diff_d12**2))\n\n        # Collect the results for the current case\n        case_result = [delta_max, delta_rms, E2_A_at_Rc, E2_B_at_Rc]\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # Convert list of lists to string and remove spaces for compact representation.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "With potential energy surfaces and couplings in hand, we can tackle the core of a mixed quantum-classical simulation: the time evolution of the electronic wavefunction. This practice focuses on integrating the time-dependent Schrödinger equation (TDSE) for a two-state system moving along a prescribed classical trajectory . By numerically solving these coupled equations of motion, you will directly witness the coherent transfer of population between electronic states, gaining fundamental insights into the diabatic and adiabatic limits of a non-adiabatic event.",
            "id": "3892328",
            "problem": "Consider a one-dimensional two-state adiabatic model relevant to non-adiabatic dynamics and fewest-switches surface hopping in computational catalysis and chemical engineering. The model arises from a diabatic two-level Hamiltonian with a constant diabatic coupling, and its adiabatic representation provides prescribed adiabatic energies and non-adiabatic derivative couplings along a classical trajectory. Starting from the Time-Dependent Schrödinger Equation (TDSE), the coupled equations for the adiabatic electronic amplitudes along a prescribed classical nuclear trajectory are to be integrated to obtain evolving state populations.\n\nUse the following physically consistent setup. The diabatic Hamiltonian is defined by the parameters $\\alpha$ and $V$, with\n$$\nH_{\\text{diab}}(R) = \n\\begin{pmatrix}\n\\alpha R  V \\\\\nV  -\\alpha R\n\\end{pmatrix},\n$$\nwhere $R$ is the nuclear coordinate. The adiabatic energies $E_{\\pm}(R)$ and the mixing angle $\\theta(R)$ are defined by\n$$\nE_{\\pm}(R) = \\pm \\sqrt{(\\alpha R)^2 + V^2},\n\\quad\n\\theta(R) = \\frac{1}{2} \\arctan\\left(\\frac{V}{\\alpha R}\\right).\n$$\nThe non-adiabatic derivative coupling between adiabatic states is\n$$\nd_{+-}(R) = \\frac{\\partial\\theta}{\\partial R}\n= -\\frac{V\\,\\alpha}{2\\left((\\alpha R)^2 + V^2\\right)},\n\\quad\nd_{-+}(R) = -d_{+-}(R),\n\\quad\nd_{++}(R) = d_{--}(R) = 0.\n$$\n\nAssume a classical nuclear trajectory with constant velocity,\n$$\nR(t) = R_0 + v\\,t,\n$$\nwith $t$ being the time coordinate. The coupled electronic amplitude equations in the adiabatic basis $\\{\\lvert \\phi_+(R) \\rangle, \\lvert \\phi_-(R) \\rangle\\}$ are\n$$\ni\\hbar\\,\\frac{d c_i}{dt} = E_i(R(t))\\,c_i - i\\hbar\\sum_{j} \\dot{R}(t)\\,d_{ij}(R(t))\\,c_j,\n\\quad i,j \\in \\{+, -\\},\n$$\nwith $\\dot{R}(t) = v$. Equivalently,\n$$\n\\frac{d\\mathbf{c}}{dt} = -\\frac{i}{\\hbar}\\,\\mathrm{diag}(E_+(R(t)), E_-(R(t)))\\,\\mathbf{c}\n- v\\,\n\\begin{pmatrix}\n0  d_{+-}(R(t)) \\\\\n-d_{+-}(R(t))  0\n\\end{pmatrix}\n\\,\\mathbf{c},\n$$\nwhere $\\mathbf{c}(t) = \\begin{pmatrix} c_+(t) \\\\ c_-(t) \\end{pmatrix}$. The initial condition is the system prepared on the lower adiabatic state at the starting coordinate, namely\n$$\nc_+(0) = 0, \\quad c_-(0) = 1.\n$$\n\nLet $\\hbar$ be the reduced Planck constant expressed in electron volt femtoseconds (eV·fs), with the numerical value\n$$\n\\hbar = 0.6582119514\\,\\text{eV·fs}.\n$$\n\nUnits and reporting requirements:\n- Coordinate $R$ must be in ångström ($\\mathrm{\\AA}$), velocity $v$ in $\\mathrm{\\AA}/\\text{fs}$, time $t$ in femtoseconds (fs), and energies $E_{\\pm}$ and parameters $\\alpha$ and $V$ in electron volt (eV).\n- Populations $P_i(t) = \\lvert c_i(t) \\rvert^2$ are dimensionless and must be reported as floats.\n- Your program must compute the final adiabatic state populations $P_+(T)$ and $P_-(T)$ at the final time $T$ for each test case.\n\nTest suite:\nFor each parameter set, integrate from $t=0$ to $t=T$ along $R(t) = R_0 + v\\,t$.\n\n1. Happy path crossing:\n   - $\\alpha = 0.1$ (eV/$\\mathrm{\\AA}$), $V = 0.05$ (eV), $R_0 = -5$ ($\\mathrm{\\AA}$), $v = 0.1$ ($\\mathrm{\\AA}/\\text{fs}$), $T = 100$ (fs).\n\n2. Fast passage (more diabatic behavior expected):\n   - $\\alpha = 0.1$ (eV/$\\mathrm{\\AA}$), $V = 0.05$ (eV), $R_0 = -5$ ($\\mathrm{\\AA}$), $v = 1.0$ ($\\mathrm{\\AA}/\\text{fs}$), $T = 10$ (fs).\n\n3. Slow passage (more adiabatic behavior expected):\n   - $\\alpha = 0.1$ (eV/$\\mathrm{\\AA}$), $V = 0.05$ (eV), $R_0 = -5$ ($\\mathrm{\\AA}$), $v = 0.01$ ($\\mathrm{\\AA}/\\text{fs}$), $T = 1000$ (fs).\n\n4. Weak coupling:\n   - $\\alpha = 0.1$ (eV/$\\mathrm{\\AA}$), $V = 0.005$ (eV), $R_0 = -5$ ($\\mathrm{\\AA}$), $v = 0.1$ ($\\mathrm{\\AA}/\\text{fs}$), $T = 100$ (fs).\n\nAlgorithmic requirements:\n- Integrate the coupled amplitude equations as stated above without introducing any phenomenological switching rules; only compute the coherent evolution of the electronic amplitudes along the prescribed classical trajectory.\n- Ensure numerical stability and preserve probability normalization to within numerical tolerance by renormalizing the amplitudes at the end if necessary.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list of pairs of floats enclosed in square brackets, with each pair corresponding to $[P_+(T), P_-(T)]$ for one test case in the order listed above. For example, an output with two test cases would look like $[[0.123456,0.876544],[0.234567,0.765433]]$. The actual numeric values must be computed by your code for the four test cases here.",
            "solution": "The problem requires the solution of the time-dependent Schrödinger equation (TDSE) for a two-state model system in the adiabatic representation. The system's evolution is governed by a prescribed classical trajectory for the nuclear coordinate. This is a standard problem in the field of non-adiabatic dynamics, often used to model molecular processes near an avoided crossing of electronic potential energy surfaces. The objective is to compute the final populations of the two adiabatic electronic states after the system has traversed a region of strong non-adiabatic coupling.\n\nThe core of the problem lies in integrating the coupled first-order ordinary differential equations (ODEs) for the complex-valued electronic amplitudes, $c_+(t)$ and $c_-(t)$, which are the coefficients of the electronic wavefunction in the basis of the adiabatic states $|\\phi_+(R(t))\\rangle$ and $|\\phi_-(R(t))\\rangle$. The governing equations are derived directly from the TDSE and are given as:\n$$\n\\frac{d c_+}{dt} = -\\frac{i}{\\hbar} E_+(R(t)) c_+(t) - v d_{+-}(R(t)) c_-(t)\n$$\n$$\n\\frac{d c_-}{dt} = -\\frac{i}{\\hbar} E_-(R(t)) c_-(t) + v d_{+-}(R(t)) c_+(t)\n$$\nThis can be written in matrix form as:\n$$\n\\frac{d\\mathbf{c}}{dt} = \\mathbf{A}(t) \\mathbf{c}(t)\n$$\nwhere $\\mathbf{c}(t) = \\begin{pmatrix} c_+(t) \\\\ c_-(t) \\end{pmatrix}$ is the state vector and $\\mathbf{A}(t)$ is the time-dependent evolution matrix:\n$$\n\\mathbf{A}(t) = \n\\begin{pmatrix}\n-\\frac{i}{\\hbar} E_+(R(t))  -v d_{+-}(R(t)) \\\\\nv d_{+-}(R(t))  -\\frac{i}{\\hbar} E_-(R(t))\n\\end{pmatrix}\n$$\nThe terms in this matrix depend on the instantaneous nuclear coordinate $R(t) = R_0 + v t$. The adiabatic energies $E_{\\pm}(R)$ and the non-adiabatic derivative coupling $d_{+-}(R)$ are defined as:\n$$\nE_{\\pm}(R) = \\pm \\sqrt{(\\alpha R)^2 + V^2}\n$$\n$$\nd_{+-}(R) = -\\frac{V\\alpha}{2\\left((\\alpha R)^2 + V^2\\right)}\n$$\nThe parameters $\\alpha$, $V$, $R_0$, and $v$ are provided for each test case, along with the reduced Planck constant $\\hbar = 0.6582119514\\,\\text{eV·fs}$. The problem specifies an initial condition where the system is prepared entirely on the lower adiabatic state at time $t=0$:\n$$\nc_+(0) = 0, \\quad c_-(0) = 1\n$$\nThis setup defines an initial value problem for a system of linear, first-order, complex-valued ODEs. A solution can be obtained by numerical integration. For this task, a high-quality numerical ODE solver is employed. The `scipy.integrate.solve_ivp` function from the SciPy library is an appropriate choice, as it provides robust and adaptive algorithms for solving such problems. We will use a standard Runge-Kutta method (such as `RK45`, the default) with stringent relative and absolute error tolerances (e.g., $10^{-9}$ and $10^{-12}$, respectively) to ensure a highly accurate solution.\n\nThe algorithm for each test case is as follows:\n1. Define a function that computes the derivative vector $d\\mathbf{c}/dt$ at a given time $t$ and state $\\mathbf{c}(t)$. This function implements the matrix $\\mathbf{A}(t)$ using the provided physical parameters.\n2. Set the integration time interval from $t=0$ to the final time $t=T$.\n3. Provide the initial state vector $\\mathbf{c}(0) = \\begin{pmatrix} 0+0i \\\\ 1+0i \\end{pmatrix}$.\n4. Call the numerical integrator (`solve_ivp`) to propagate the state vector from $t=0$ to $t=T$.\n5. From the integrator's output, extract the final state vector $\\mathbf{c}(T) = \\begin{pmatrix} c_+(T) \\\\ c_-(T) \\end{pmatrix}$.\n6. The evolution described by the ODE system is unitary, meaning the norm of the state vector, $\\| \\mathbf{c}(t) \\|^2 = |c_+(t)|^2 + |c_-(t)|^2$, should be conserved and equal to $1$ for all time. To counteract any small numerical errors that may lead to a minor violation of this conservation, the final state vector $\\mathbf{c}(T)$ is renormalized by dividing it by its norm.\n7. Finally, the populations of the adiabatic states at time $T$ are calculated as the squared magnitudes of the corresponding amplitudes: $P_+(T) = |c_+(T)|^2$ and $P_-(T) = |c_-(T)|^2$.\n\nThis procedure is repeated for each of the four parameter sets specified in the problem statement to obtain the final populations $[P_+(T), P_-(T)]$ for each case. The results are then formatted into a single string as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the time-dependent Schrödinger equation for a two-level system\n    for four different test cases and prints the final populations.\n    \"\"\"\n    # Define the reduced Planck constant in eV·fs\n    HBAR = 0.6582119514\n\n    def ode_system(t, c, alpha, V, R0, v):\n        \"\"\"\n        Defines the system of coupled ODEs for the electronic amplitudes.\n\n        Args:\n            t (float): Current time.\n            c (np.ndarray): Complex array of amplitudes [c_plus, c_minus].\n            alpha (float): Diabatic coupling slope (eV/Å).\n            V (float): Diabatic coupling constant (eV).\n            R0 (float): Initial nuclear coordinate (Å).\n            v (float): Nuclear velocity (Å/fs).\n\n        Returns:\n            np.ndarray: Array of time derivatives [dc_plus/dt, dc_minus/dt].\n        \"\"\"\n        # Calculate the nuclear coordinate R at time t\n        R = R0 + v * t\n\n        # Calculate terms for energies and derivative coupling\n        common_term_sq = (alpha * R)**2 + V**2\n        \n        if common_term_sq == 0:\n            # This case is physically avoided as V > 0\n            # and should not be reached.\n            # Handle to prevent division by zero if V=0 and R=0.\n            E_plus = 0.0\n            E_minus = 0.0\n            d_plus_minus = 0.0\n        else:\n            sqrt_term = np.sqrt(common_term_sq)\n            E_plus = sqrt_term\n            E_minus = -sqrt_term\n            # Non-adiabatic derivative coupling d_{jk} = j | d/dR | k\n            d_plus_minus = -(V * alpha) / (2.0 * common_term_sq)\n\n        c_plus, c_minus = c\n\n        # Time-dependent Schrödinger equation in the adiabatic basis\n        # d(c_plus)/dt = -i/hbar * E_plus * c_plus - v * d_plus_minus * c_minus\n        # d(c_minus)/dt = -i/hbar * E_minus * c_minus + v * d_plus_minus * c_plus\n        dc_plus_dt = (-1j / HBAR) * E_plus * c_plus - v * d_plus_minus * c_minus\n        dc_minus_dt = (-1j / HBAR) * E_minus * c_minus + v * d_plus_minus * c_plus\n        \n        return np.array([dc_plus_dt, dc_minus_dt])\n\n    def run_simulation(params):\n        \"\"\"\n        Runs a single simulation for a given set of parameters.\n\n        Args:\n            params (tuple): A tuple of parameters (alpha, V, R0, v, T).\n\n        Returns:\n            list: A list containing the final populations [P_plus, P_minus].\n        \"\"\"\n        alpha, V, R0, v, T = params\n        \n        # Initial condition: system starts in the lower adiabatic state (c_- = 1)\n        c0 = np.array([0.0 + 0.0j, 1.0 + 0.0j])\n        \n        # Time span for integration\n        t_span = [0, T]\n        \n        # Solve the initial value problem\n        sol = solve_ivp(\n            fun=ode_system,\n            t_span=t_span,\n            y0=c0,\n            method='RK45', \n            args=(alpha, V, R0, v),\n            rtol=1e-9,  # Relative tolerance for accuracy\n            atol=1e-12  # Absolute tolerance for accuracy\n        )\n        \n        # Get the final state vector at time T\n        c_final = sol.y[:, -1]\n        \n        # Renormalize to ensure probability conservation\n        norm = np.linalg.norm(c_final)\n        if norm > 0:\n            c_final_normalized = c_final / norm\n        else:\n            c_final_normalized = c_final\n\n        # Calculate final populations\n        P_plus_T = np.abs(c_final_normalized[0])**2\n        P_minus_T = np.abs(c_final_normalized[1])**2\n        \n        return [P_plus_T, P_minus_T]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (alpha, V, R0, v, T)\n        (0.1, 0.05, -5.0, 0.1, 100.0),   # 1. Happy path crossing\n        (0.1, 0.05, -5.0, 1.0, 10.0),    # 2. Fast passage\n        (0.1, 0.05, -5.0, 0.01, 1000.0), # 3. Slow passage\n        (0.1, 0.005, -5.0, 0.1, 100.0)   # 4. Weak coupling\n    ]\n\n    results = []\n    for case in test_cases:\n        final_populations = run_simulation(case)\n        results.append(final_populations)\n\n    # Format the results into the specified a single-line string format\n    case_strings = [f\"[{res[0]},{res[1]}]\" for res in results]\n    final_output_str = f\"[{','.join(case_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "While simulating the detailed quantum evolution is powerful, the ultimate goal in catalysis is often to predict macroscopic reaction rates and product selectivity. This practice connects the microscopic principles of non-adiabatic transitions to these key chemical observables using the celebrated Marcus theory for electron transfer . You will derive and implement the Marcus rate equation to determine how factors like reorganization energy ($\\lambda$) and driving force ($\\Delta G$) control the competition between two reaction pathways, allowing you to calculate and analyze the all-important branching ratios.",
            "id": "3892330",
            "problem": "You will implement a program to quantify how Proton-Coupled Electron Transfer (PCET) hop probabilities and channel branching ratios depend on reorganization energy and driving force within the non-adiabatic weak-coupling regime relevant to Fewest Switches Surface Hopping (FSSH). Model the environment as a classical harmonic solvent coordinate and treat transitions in the Fermi’s golden rule limit. Start only from fundamental bases: Fermi’s golden rule, the classical high-temperature limit for the solvent coordinate, and the definition of a Poisson process for event occurrence. Do not introduce any additional phenomenological fitting factors.\n\nFundamental bases you may use:\n- Fermi’s golden rule for a non-adiabatic transition rate $k$ between diabatic states with electronic-vibronic coupling $V$ and a density of accepting states $\\rho(E)$, namely $k \\propto |V|^{2} \\rho(E)$.\n- High-temperature classical limit for a harmonic reaction coordinate with reorganization energy $\\lambda$ and free energy driving force $\\Delta G$, which yields a Gaussian distribution of energy gaps.\n- A Poisson process relation for the probability of observing a transition during a time step $\\Delta t$ from a constant rate $k$: $p(\\Delta t) = 1 - \\exp(-k \\Delta t)$.\n\nPrecisely define all symbols you use. Use only the following physical constants in SI units, and convert all energies to joule where needed:\n- Boltzmann constant $k_{\\mathrm B} = 1.380\\,649 \\times 10^{-23}\\ \\mathrm{J/K}$.\n- Reduced Planck constant $\\hbar = 1.054\\,571\\,817 \\times 10^{-34}\\ \\mathrm{J \\cdot s}$.\n- Electron-volt to joule conversion $1\\ \\mathrm{eV} = 1.602\\,176\\,634 \\times 10^{-19}\\ \\mathrm{J}$.\n\nAssumptions and scope:\n- Consider two competing PCET product channels, labeled $A$ and $B$, from the same reactant diabatic state.\n- Each channel is characterized by a reorganization energy $\\lambda$ (in $\\mathrm{eV}$) and a driving force $\\Delta G$ (in $\\mathrm{eV}$).\n- The effective vibronic coupling $V$ (in $\\mathrm{meV}$) is identical for both channels within a given test case.\n- The solvent is classical and at temperature $T$ (in $\\mathrm{K}$).\n- You will discretize dynamics with a fixed time step $\\Delta t$ (in $\\mathrm{fs}$) and map non-adiabatic rate constants to FSSH-like hop probabilities via a Poisson process approximation.\n- You must express probabilities as pure decimals, not as percentages.\n\nYour tasks for each test case:\n1. From the bases above, derive, implement, and use a non-adiabatic golden-rule PCET rate $k(\\lambda, \\Delta G, V, T)$ with the classical solvent coordinate treated harmonically. You must ensure dimensional consistency with $k$ in $\\mathrm{s}^{-1}$.\n2. Convert the rate for each channel into a per-time-step hop probability $p(\\Delta t) = 1 - \\exp(-k \\Delta t)$, with $\\Delta t$ converted to seconds.\n3. Compute the branching ratio to channel $A$, $\\mathrm{BR}_A = k_A/(k_A + k_B)$, and to channel $B$, $\\mathrm{BR}_B = 1 - \\mathrm{BR}_A$.\n4. Report, for each test case, the list $[p_A, p_B, \\mathrm{BR}_A, \\mathrm{BR}_B]$.\n\nPhysical units:\n- $\\lambda$ and $\\Delta G$ are provided in $\\mathrm{eV}$ and must be converted to $\\mathrm{J}$ internally for any calculation.\n- $V$ is provided in $\\mathrm{meV}$ and must be converted to $\\mathrm{eV}$, then to $\\mathrm{J}$.\n- $T$ is in $\\mathrm{K}$.\n- $\\Delta t$ is in $\\mathrm{fs}$ and must be converted to $\\mathrm{s}$.\n- Probabilities and branching ratios are dimensionless. Express the final numeric results rounded to eight decimal places.\n\nTest suite:\nProvide results for the following five test cases. For each line, the tuple means ($\\lambda_A$ eV, $\\Delta G_A$ eV, $\\lambda_B$ eV, $\\Delta G_B$ eV, $V$ meV, $T$ K, $\\Delta t$ fs).\n- Case $1$: $(0.6, -0.2, 0.8, -0.5, 10.0, 300.0, 0.5)$\n- Case $2$: $(0.5, -0.5, 0.5, -0.1, 10.0, 300.0, 0.5)$\n- Case $3$: $(0.6, -1.2, 0.6, -0.2, 10.0, 300.0, 0.5)$\n- Case $4$: $(0.1, -0.1, 1.0, -0.5, 5.0, 300.0, 1.0)$\n- Case $5$: $(0.4, +0.2, 0.4, -0.4, 10.0, 300.0, 0.5)$\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of lists, each inner list corresponding to one test case and ordered as above. For example, the printed line must look like\n[[$p_A^{(1)}$, $p_B^{(1)}$, $\\mathrm{BR}_A^{(1)}$, $\\mathrm{BR}_B^{(1)}$], [$p_A^{(2)}$, $p_B^{(2)}$, $\\mathrm{BR}_A^{(2)}$, $\\mathrm{BR}_B^{(2)}$],$\\ldots$]\nwith each number rounded to eight decimal places.",
            "solution": "The problem requires the implementation of a program to compute non-adiabatic transition probabilities and branching ratios for competing Proton-Coupled Electron Transfer (PCET) channels. The solution must be derived from fundamental principles as specified: Fermi's golden rule, a classical harmonic model for the solvent, and the properties of a Poisson process.\n\nFirst, I will derive the expression for the non-adiabatic rate constant, $k$, for a transition between two electronic states. The provided basis is Fermi's golden rule, which states that the rate is proportional to the square of the electronic coupling and the density of states. In the context of electron transfer in a solvent, this is expressed as:\n$$ k = \\frac{2\\pi}{\\hbar} |V|^2 (\\text{FCWD}) $$\nwhere $k$ is the rate constant in $\\mathrm{s}^{-1}$, $\\hbar$ is the reduced Planck constant in $\\mathrm{J \\cdot s}$, $V$ is the electronic coupling between the initial and final diabatic states in $\\mathrm{J}$, and $\\text{FCWD}$ is the Franck-Condon Weighted Density of States, which accounts for the nuclear part of the transition and has units of $\\mathrm{J}^{-1}$.\n\nThe problem specifies that the solvent environment should be modeled as a classical harmonic coordinate in the high-temperature limit. This is the cornerstone of Marcus theory. In this model, the potential energy surfaces of the reactant ($U_R$) and product ($U_P$) are represented as parabolas as a function of a collective solvent coordinate. The transition is driven by thermal fluctuations of this coordinate. The theory relates the $\\text{FCWD}$ to two key thermodynamic parameters: the reorganization energy, $\\lambda$, and the free energy driving force, $\\Delta G$.\n\nThe reorganization energy, $\\lambda$, is the energy cost to distort the system from the reactant's equilibrium nuclear configuration to the product's equilibrium configuration without electron transfer. The driving force, $\\Delta G$, is the change in free energy upon reaction.\n\nFor a classical system at temperature $T$, the probability of a thermal fluctuation providing an activation energy $\\Delta G^\\ddagger$ is proportional to the Boltzmann factor, $\\exp(-\\Delta G^\\ddagger / (k_{\\mathrm B} T))$, where $k_{\\mathrm B}$ is the Boltzmann constant. In Marcus theory, the activation free energy for the electron transfer process is given by:\n$$ \\Delta G^\\ddagger = \\frac{(\\lambda + \\Delta G)^2}{4\\lambda} $$\nThis expression arises from finding the energy of the crossing point between the reactant and product potential energy surfaces.\n\nThe $\\text{FCWD}$ in the classical high-temperature limit is derived by considering the Gaussian probability distribution of the vertical energy gap between the two electronic states, which is induced by the thermal fluctuations of the solvent coordinate. The final expression for the $\\text{FCWD}$ is:\n$$ \\text{FCWD} = \\frac{1}{\\sqrt{4\\pi\\lambda k_{\\mathrm B} T}} \\exp\\left(-\\frac{\\Delta G^\\ddagger}{k_{\\mathrm B} T}\\right) = \\frac{1}{\\sqrt{4\\pi\\lambda k_{\\mathrm B} T}} \\exp\\left(-\\frac{(\\lambda + \\Delta G)^2}{4\\lambda k_{\\mathrm B} T}\\right) $$\nSubstituting this into Fermi's golden rule gives the Marcus rate equation for non-adiabatic electron transfer:\n$$ k(\\lambda, \\Delta G, V, T) = \\frac{2\\pi}{\\hbar} |V|^2 \\frac{1}{\\sqrt{4\\pi\\lambda k_{\\mathrm B} T}} \\exp\\left(-\\frac{(\\lambda + \\Delta G)^2}{4\\lambda k_{\\mathrm B} T}\\right) $$\nSimplifying the prefactor, we obtain the form that will be implemented:\n$$ k = \\frac{|V|^2}{\\hbar} \\sqrt{\\frac{\\pi}{\\lambda k_{\\mathrm B} T}} \\exp\\left(-\\frac{(\\lambda + \\Delta G)^2}{4\\lambda k_{\\mathrm B} T}\\right) $$\nFor each test case, we have two competing channels, $A$ and $B$, each with its own rate constant, $k_A$ and $k_B$, calculated using the parameters $(\\lambda_A, \\Delta G_A)$ and $(\\lambda_B, \\Delta G_B)$ respectively, with the same coupling $V$ and temperature $T$. All input parameters with units of energy ($\\lambda, \\Delta G, V$) will be converted to Joules, and time ($\\Delta t$) to seconds, to ensure dimensional consistency, yielding a rate $k$ in $\\mathrm{s}^{-1}$.\n\nSecond, the problem asks to map these rates to hop probabilities within a discrete time step $\\Delta t$. This is achieved by modeling the transitions as a Poisson process. For a constant rate $k$, the probability $p$ of observing at least one event in a duration $\\Delta t$ is given by:\n$$ p(\\Delta t) = 1 - \\exp(-k \\Delta t) $$\nThis formula is applied to each channel to find the hop probabilities $p_A$ and $p_B$. For the small values of $k \\Delta t$ typical in surface hopping simulations, $p(\\Delta t) \\approx k \\Delta t$.\n\nThird, the branching ratio for each channel must be computed. The branching ratio reflects the relative probability of the reaction proceeding through a particular channel. It is given by the ratio of the rate for that channel to the total rate of all competing channels. For channels $A$ and $B$:\n$$ \\mathrm{BR}_A = \\frac{k_A}{k_A + k_B} $$\n$$ \\mathrm{BR}_B = \\frac{k_B}{k_A + k_B} = 1 - \\mathrm{BR}_A $$\n\nThe final algorithm is as follows:\n1.  Define the required physical constants ($k_{\\mathrm B}$, $\\hbar$, eV-to-J conversion).\n2.  For each test case $(\\lambda_A, \\Delta G_A, \\lambda_B, \\Delta G_B, V, T, \\Delta t)$:\n    a. Convert all input parameters to base SI units (J, K, s).\n    b. Calculate the rate $k_A$ using the Marcus equation with channel $A$'s parameters.\n    c. Calculate the rate $k_B$ using the Marcus equation with channel $B$'s parameters.\n    d. Calculate the hop probability $p_A = 1 - \\exp(-k_A \\Delta t)$.\n    e. Calculate the hop probability $p_B = 1 - \\exp(-k_B \\Delta t)$.\n    f. Calculate the branching ratios $\\mathrm{BR}_A = k_A / (k_A + k_B)$ and $\\mathrm{BR}_B = k_B / (k_A + k_B)$.\n    g. Store the four resulting values $[p_A, p_B, \\mathrm{BR}_A, \\mathrm{BR}_B]$, rounded to eight decimal places.\n3.  Format the collection of results from all test cases into the specified string representation of a list of lists.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates PCET hop probabilities and branching ratios based on Marcus theory.\n    \"\"\"\n    # Physical constants in SI units\n    K_B = 1.380649e-23  # Boltzmann constant in J/K\n    H_BAR = 1.054571817e-34  # Reduced Planck constant in J*s\n    EV_TO_J = 1.602176634e-19  # Electron-volt to Joule conversion\n\n    # Test suite parameters:\n    # (lambda_A_eV, delta_G_A_eV, lambda_B_eV, delta_G_B_eV, V_meV, T_K, dt_fs)\n    test_cases = [\n        (0.6, -0.2, 0.8, -0.5, 10.0, 300.0, 0.5),\n        (0.5, -0.5, 0.5, -0.1, 10.0, 300.0, 0.5),\n        (0.6, -1.2, 0.6, -0.2, 10.0, 300.0, 0.5),\n        (0.1, -0.1, 1.0, -0.5, 5.0, 300.0, 1.0),\n        (0.4, +0.2, 0.4, -0.4, 10.0, 300.0, 0.5),\n    ]\n\n    def calculate_rate(lambda_ev, delta_g_ev, v_mev, t_k):\n        \"\"\"\n        Calculates the non-adiabatic rate constant using Marcus theory.\n        \n        Args:\n            lambda_ev (float): Reorganization energy in eV.\n            delta_g_ev (float): Driving force in eV.\n            v_mev (float): Electronic coupling in meV.\n            t_k (float): Temperature in Kelvin.\n            \n        Returns:\n            float: Rate constant k in s^-1.\n        \"\"\"\n        # Convert inputs to SI units\n        lambda_j = lambda_ev * EV_TO_J\n        delta_g_j = delta_g_ev * EV_TO_J\n        v_j = v_mev * 1e-3 * EV_TO_J\n        \n        # Avoid division by zero if lambda is zero\n        if lambda_j = 0:\n            return 0.0\n\n        # Thermal energy\n        kbt = K_B * t_k\n        \n        # Prefactor term of the Marcus equation\n        prefactor_arg = np.pi / (lambda_j * kbt)\n        prefactor = (v_j**2 / H_BAR) * np.sqrt(prefactor_arg)\n        \n        # Exponential term (activation energy)\n        # Note: (lambda + delta_G)^2 is the same as (-lambda - delta_G)^2\n        # However, the formulation in terms of activation energy is G_act = (lambda + delta_G)^2 / (4*lambda)\n        # and the exponential is exp(-G_act / kBT)\n        activation_energy_j = (lambda_j + delta_g_j)**2 / (4 * lambda_j)\n        exponent = -activation_energy_j / kbt\n        \n        rate = prefactor * np.exp(exponent)\n        return rate\n\n    def calculate_hop_prob(k, dt_fs):\n        \"\"\"\n        Calculates the FSSH-like hop probability from a rate constant.\n        \n        Args:\n            k (float): Rate constant in s^-1.\n            dt_fs (float): Time step in femtoseconds.\n            \n        Returns:\n            float: Dimensionless hop probability.\n        \"\"\"\n        dt_s = dt_fs * 1e-15  # Convert fs to s\n        prob = 1.0 - np.exp(-k * dt_s)\n        return prob\n\n    all_results = []\n    for case in test_cases:\n        lambda_a_ev, delta_g_a_ev, lambda_b_ev, delta_g_b_ev, v_mev, t_k, dt_fs = case\n\n        # Calculate rates for both channels\n        k_a = calculate_rate(lambda_a_ev, delta_g_a_ev, v_mev, t_k)\n        k_b = calculate_rate(lambda_b_ev, delta_g_b_ev, v_mev, t_k)\n        \n        # Calculate hop probabilities\n        p_a = calculate_hop_prob(k_a, dt_fs)\n        p_b = calculate_hop_prob(k_b, dt_fs)\n        \n        # Calculate branching ratios\n        total_rate = k_a + k_b\n        br_a = k_a / total_rate if total_rate  0 else 0.0\n        br_b = k_b / total_rate if total_rate  0 else 0.0\n        \n        case_results = [p_a, p_b, br_a, br_b]\n        all_results.append(case_results)\n\n    # Format the final output string as a list of lists.\n    # Each number is formatted to 8 decimal places.\n    formatted_lists = []\n    for res_list in all_results:\n        inner_list_str = f\"[{','.join([f'{num:.8f}' for num in res_list])}]\"\n        formatted_lists.append(inner_list_str)\n    \n    final_output_str = f\"[{','.join(formatted_lists)}]\"\n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}