{
    "hands_on_practices": [
        {
            "introduction": "在催化剂的设计和操作中，理解不同失活机制对温度的响应至关重要。烧结和中毒作为两种主要的失活路径，其速率随温度变化的程度可能截然不同，这直接影响催化剂的寿命和最佳工作窗口。本练习通过应用阿伦尼乌斯方程 ，量化比较这两种机制的温度敏感性，从而揭示一个核心原理：活化能越高的过程，其速率对温度的变化越敏感。",
            "id": "3888357",
            "problem": "一种负载型金属催化剂经历两种并行的失活机制：烧结导致的颗粒粗化和中毒导致的活性位点损失。对于这两种机制，假设其内在失活速率常数都遵循与活化能为 $E_{a}$ 的阿伦尼乌斯型关系，并且两种机制的指前因子 $A$ 相同。考虑一个从 $T_{1}=600\\,\\text{K}$ 到 $T_{2}=800\\,\\text{K}$ 的线性升温过程。烧结的活化能为 $E_{a,\\text{sint}}=150\\,\\text{kJ mol}^{-1}$，中毒的活化能为 $E_{a,\\text{pois}}=50\\,\\text{kJ mol}^{-1}$。使用普适气体常数 $R=8.314\\,\\text{J mol}^{-1}\\text{K}^{-1}$。\n\n定义在升温过程中，由温度引起的机制 $i$ 的内在失活速率常数的倍数增加为比率 $k_{i}(T_{2})/k_{i}(T_{1})$。在给定假设下，计算无量纲比率\n$$\n\\mathcal{R}=\\frac{\\left[k_{\\text{sint}}(T_{2})/k_{\\text{sint}}(T_{1})\\right]}{\\left[k_{\\text{pois}}(T_{2})/k_{\\text{pois}}(T_{1})\\right]}\n$$\n请以纯数（无量纲）形式给出最终答案，并四舍五入至三位有效数字。",
            "solution": "该问题陈述被认为是有效的，因为它基于化学动力学原理（阿伦尼乌斯方程），具有科学依据，内部一致，并提供了计算唯一且有意义解所需的所有信息。\n\n每种机制（$i \\in \\{\\text{sint}, \\text{pois}\\}$）的内在失活速率常数 $k$ 由阿伦尼乌斯方程给出：\n$$\nk_i(T) = A \\exp\\left(-\\frac{E_{a,i}}{RT}\\right)\n$$\n其中 $A$ 是指前因子（假设两种机制相同），$E_{a,i}$ 是机制 $i$ 的活化能，$R$ 是普适气体常数，$T$ 是绝对温度。\n\n烧结机制由温度引起的倍数增加是其在温度 $T_2$ 和 $T_1$ 下速率常数的比值：\n$$\n\\frac{k_{\\text{sint}}(T_2)}{k_{\\text{sint}}(T_1)} = \\frac{A \\exp\\left(-\\frac{E_{a,\\text{sint}}}{RT_2}\\right)}{A \\exp\\left(-\\frac{E_{a,\\text{sint}}}{RT_1}\\right)}\n$$\n指前因子 $A$ 被消去。利用性质 $\\exp(x)/\\exp(y) = \\exp(x-y)$，我们得到：\n$$\n\\frac{k_{\\text{sint}}(T_2)}{k_{\\text{sint}}(T_1)} = \\exp\\left(-\\frac{E_{a,\\text{sint}}}{RT_2} + \\frac{E_{a,\\text{sint}}}{RT_1}\\right) = \\exp\\left[\\frac{E_{a,\\text{sint}}}{R}\\left(\\frac{1}{T_1} - \\frac{1}{T_2}\\right)\\right]\n$$\n类似地，中毒机制的倍数增加为：\n$$\n\\frac{k_{\\text{pois}}(T_2)}{k_{\\text{pois}}(T_1)} = \\frac{A \\exp\\left(-\\frac{E_{a,\\text{pois}}}{RT_2}\\right)}{A \\exp\\left(-\\frac{E_{a,\\text{pois}}}{RT_1}\\right)} = \\exp\\left[\\frac{E_{a,\\text{pois}}}{R}\\left(\\frac{1}{T_1} - \\frac{1}{T_2}\\right)\\right]\n$$\n问题要求计算无量纲比率 $\\mathcal{R}$，定义为：\n$$\n\\mathcal{R} = \\frac{\\left[k_{\\text{sint}}(T_{2})/k_{\\text{sint}}(T_{1})\\right]}{\\left[k_{\\text{pois}}(T_{2})/k_{\\text{pois}}(T_{1})\\right]}\n$$\n代入倍数增加的表达式：\n$$\n\\mathcal{R} = \\frac{\\exp\\left[\\frac{E_{a,\\text{sint}}}{R}\\left(\\frac{1}{T_1} - \\frac{1}{T_2}\\right)\\right]}{\\exp\\left[\\frac{E_{a,\\text{pois}}}{R}\\left(\\frac{1}{T_1} - \\frac{1}{T_2}\\right)\\right]}\n$$\n再次利用性质 $\\exp(x)/\\exp(y) = \\exp(x-y)$，我们可以合并这些项：\n$$\n\\mathcal{R} = \\exp\\left[\\frac{E_{a,\\text{sint}}}{R}\\left(\\frac{1}{T_1} - \\frac{1}{T_2}\\right) - \\frac{E_{a,\\text{pois}}}{R}\\left(\\frac{1}{T_1} - \\frac{1}{T_2}\\right)\\right]\n$$\n提取公因子 $\\frac{1}{R}$ 和 $\\left(\\frac{1}{T_1} - \\frac{1}{T_2}\\right)$：\n$$\n\\mathcal{R} = \\exp\\left[\\frac{E_{a,\\text{sint}} - E_{a,\\text{pois}}}{R}\\left(\\frac{1}{T_1} - \\frac{1}{T_2}\\right)\\right]\n$$\n现在，我们代入给定的数值。首先，确保单位一致。活化能的单位是 $\\text{kJ mol}^{-1}$，气体常数的单位是 $\\text{J mol}^{-1}\\text{K}^{-1}$。我们将活化能转换为 $\\text{J mol}^{-1}$。\n给定数据：\n$E_{a,\\text{sint}} = 150\\,\\text{kJ mol}^{-1} = 150000\\,\\text{J mol}^{-1}$\n$E_{a,\\text{pois}} = 50\\,\\text{kJ mol}^{-1} = 50000\\,\\text{J mol}^{-1}$\n$R = 8.314\\,\\text{J mol}^{-1}\\text{K}^{-1}$\n$T_1 = 600\\,\\text{K}$\n$T_2 = 800\\,\\text{K}$\n\n活化能之差为：\n$$\nE_{a,\\text{sint}} - E_{a,\\text{pois}} = 150000\\,\\text{J mol}^{-1} - 50000\\,\\text{J mol}^{-1} = 100000\\,\\text{J mol}^{-1}\n$$\n逆温度之差为：\n$$\n\\frac{1}{T_1} - \\frac{1}{T_2} = \\frac{1}{600\\,\\text{K}} - \\frac{1}{800\\,\\text{K}} = \\frac{4 - 3}{2400\\,\\text{K}} = \\frac{1}{2400}\\,\\text{K}^{-1}\n$$\n现在，我们计算 $\\mathcal{R}$ 表达式中的指数：\n$$\n\\text{指数} = \\frac{100000\\,\\text{J mol}^{-1}}{8.314\\,\\text{J mol}^{-1}\\text{K}^{-1}} \\times \\left(\\frac{1}{2400}\\,\\text{K}^{-1}\\right)\n$$\n$$\n\\text{指数} = \\frac{100000}{8.314 \\times 2400} \\approx 5.011624\n$$\n最后，我们计算 $\\mathcal{R}$：\n$$\n\\mathcal{R} = \\exp(5.011624) \\approx 150.1408\n$$\n问题要求答案四舍五入至三位有效数字。\n$$\n\\mathcal{R} \\approx 150\n$$\n为了明确表示三位有效数字，我们用科学记数法表示。\n$$\n\\mathcal{R} \\approx 1.50 \\times 10^2\n$$",
            "answer": "$$\n\\boxed{1.50 \\times 10^{2}}\n$$"
        },
        {
            "introduction": "催化剂中毒是导致活性下降的常见原因，通常由原料或产物中的杂质与活性位点发生强吸附引起。为了定量描述这一过程，我们可以利用表面科学的基本原理来建立数学模型。本练习  将指导您从第一性原理出发，基于Langmuir-Hinshelwood动力学框架，推导出一个描述竞争性吸附中毒的速率方程，并将理论模型应用于解决实际问题。",
            "id": "3888387",
            "problem": "考虑一个在稳态下运行的等温、等压微分催化反应器，其内外传质限制可忽略不计。单位点 Langmuir 吸附模型适用于均匀表面，反应物 $R$ 和位点阻塞毒物 $P$ 均为非解离吸附。设 $R$ 发生单分子表面反应步骤 $R^\\ast \\to \\text{products}$，速率常数为 $k$ (单位为 $\\text{s}^{-1}$)，宏观转换频率 $r$ (单位为 $\\text{s}^{-1}$) 与吸附的反应物覆盖度成正比，即 $r = k\\,\\theta_R$。$R$ 和 $P$ 的吸附遵循准平衡，其 Langmuir 吸附平衡常数分别为 $K_R$ 和 $K_P$ (单位为 $\\text{bar}^{-1}$)。平均场位点平衡成立：$\\theta_\\ast + \\theta_R + \\theta_P = 1$。\n\n从这些原理出发，且不引用任何预先推导的速率表达式，推导 $r$ 作为毒物分压 $p_P$ (单位为 $\\text{bar}$) 的函数，给定参数 $K_R = 1\\,\\text{bar}^{-1}$、$K_P = 10\\,\\text{bar}^{-1}$ 和 $p_R = 0.5\\,\\text{bar}$。然后，确定当速率 $r$ 相对于其在 $p_P = 0$ 时的值下降 $50\\%$ 时，$p_P$ 的值 (单位为 $\\text{bar}$)。\n\n将 $r$ (单位为 $\\text{s}^{-1}$) 表示为 $p_P$ 和 $k$ 的函数，并提供 $p_P$ (单位为 $\\text{bar}$)。将 $p_P$ 的数值四舍五入到 $4$ 位有效数字。",
            "solution": "首先验证问题，以确保其科学基础扎实、提法恰当且客观。\n\n**步骤 1：提取已知条件**\n- **系统：** 等温、等压、稳态运行的微分催化反应器。\n- **动力学：** 反应物 $R$ 和毒物 $P$ 的单位点 Langmuir 吸附。吸附是非解离性的且处于准平衡状态。表面反应是单分子步骤 $R^\\ast \\to \\text{products}$。\n- **速率定律：** 转换频率为 $r = k\\,\\theta_R$，其中 $k$ 是表面反应速率常数。\n- **传质：** 可忽略的内外传质限制。\n- **位点平衡：** $\\theta_\\ast + \\theta_R + \\theta_P = 1$。\n- **吸附常数：** $K_R$ 和 $K_P$ 分别是 $R$ 和 $P$ 的 Langmuir 吸附平衡常数。\n- **给定参数：**\n  - $K_R = 1\\,\\text{bar}^{-1}$\n  - $K_P = 10\\,\\text{bar}^{-1}$\n  - $p_R = 0.5\\,\\text{bar}$\n- **目标：**\n  1. 推导速率 $r$ 作为毒物分压 $p_P$ 和速率常数 $k$ 的函数。\n  2. 求出当速率 $r$ 相较于 $p_P = 0$ 时的速率降低 $50\\%$ 时 $p_P$ 的值。该值应四舍五入到 $4$ 位有效数字。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题基于经典的 Langmuir-Hinshelwood 模型，用于描述竞争吸附和催化剂中毒，这是化学反应工程中的一个基本概念。所有假设（等温、等压、无传质限制）都是用于分离本征动力学效应的标准假设。该问题是自洽的，提供了推导所需表达式和数值的所有必要参数。语言精确客观。没有科学缺陷、矛盾或含糊之处。\n\n**步骤 3：结论与行动**\n问题有效。将提供详细解答。\n\n**速率表达式的推导**\n\n问题要求从第一性原理出发进行推导。反应物 $R$ 和毒物 $P$ 在单一种类位点 $\\ast$ 上的非解离吸附的准平衡可以写为：\n$R + \\ast \\rightleftharpoons R^\\ast$\n$P + \\ast \\rightleftharpoons P^\\ast$\n\n根据 Langmuir 模型，覆盖度 $\\theta_R$ 和 $\\theta_P$ 通过吸附平衡常数 $K_R$ 和 $K_P$ 与分压 $p_R$ 和 $p_P$ 以及空位分数 $\\theta_\\ast$ 相关联：\n$\\theta_R = K_R p_R \\theta_\\ast$\n$\\theta_P = K_P p_P \\theta_\\ast$\n\n位点平衡方程指出，空位、被 $R$ 占据的位点和被 $P$ 占据的位点的分数之和必须等于 $1$：\n$\\theta_\\ast + \\theta_R + \\theta_P = 1$\n\n将 $\\theta_R$ 和 $\\theta_P$ 的表达式代入位点平衡方程：\n$\\theta_\\ast + K_R p_R \\theta_\\ast + K_P p_P \\theta_\\ast = 1$\n\n提出因子 $\\theta_\\ast$ 以求解它：\n$\\theta_\\ast(1 + K_R p_R + K_P p_P) = 1$\n$\\theta_\\ast = \\frac{1}{1 + K_R p_R + K_P p_P}$\n\n转换频率 $r$ 由 $r = k\\,\\theta_R$ 给出。为了找到 $r$ 的表达式，我们首先通过代入 $\\theta_\\ast$ 的表达式，将 $\\theta_R$ 表示为分压的函数：\n$\\theta_R = K_R p_R \\theta_\\ast = \\frac{K_R p_R}{1 + K_R p_R + K_P p_P}$\n\n现在，将这个 $\\theta_R$ 的表达式代入速率方程：\n$r = k \\frac{K_R p_R}{1 + K_R p_R + K_P p_P}$\n\n这就是通用的速率表达式。问题要求使用给定的参数值 $K_R = 1\\,\\text{bar}^{-1}$、$K_P = 10\\,\\text{bar}^{-1}$ 和 $p_R = 0.5\\,\\text{bar}$，将此表达式表示为 $p_P$ 和 $k$ 的函数。\n$r(p_P) = k \\frac{(1)(0.5)}{1 + (1)(0.5) + (10)p_P} = k \\frac{0.5}{1.5 + 10 p_P}$\n\n为简化此分数，我们可以将分子和分母同乘以 $2$：\n$r(p_P) = k \\frac{1}{3 + 20 p_P}$\n这就是所要求的转换频率 $r$ (单位为 $\\text{s}^{-1}$) 作为 $p_P$ 和 $k$ 的函数表达式。\n\n**计算速率降低50%时的毒物分压**\n\n首先，我们计算没有毒物时的初始速率 $r_0$，即在 $p_P = 0$ 时：\n$r_0 = r(p_P=0) = k \\frac{1}{3 + 20(0)} = \\frac{k}{3}$\n\n接下来，我们需要找到使速率为该初始速率 $50\\%$ 时的 $p_P$ 值。我们将此速率表示为 $r_{50\\%}$。\n$r_{50\\%} = 0.5 \\times r_0 = \\frac{1}{2} \\times \\frac{k}{3} = \\frac{k}{6}$\n\n我们将通用速率表达式 $r(p_P)$ 等于 $r_{50\\%}$，然后求解 $p_P$：\n$k \\frac{1}{3 + 20 p_P} = \\frac{k}{6}$\n\n假设 $k \\neq 0$ (反应速率不为零)，我们可以消去两边的 $k$：\n$\\frac{1}{3 + 20 p_P} = \\frac{1}{6}$\n\n将两边取倒数，我们得到：\n$3 + 20 p_P = 6$\n$20 p_P = 6 - 3$\n$20 p_P = 3$\n$p_P = \\frac{3}{20} = 0.15$\n\n将反应速率降低 $50\\%$ 所需的毒物分压值为 $0.15\\,\\text{bar}$。问题要求将此值四舍五入到 $4$ 位有效数字，即 $0.1500$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} k \\frac{1}{3 + 20 p_P}  0.1500 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "对于烧结这样涉及大量粒子相互作用的复杂过程，简单的速率方程往往不足以描述其全貌。此时，我们需要更强大的工具——群体平衡方程（PBE），来追踪整个催化剂颗粒尺寸分布的动态演化。本练习  是一项高级计算实践，您将不仅从理论上推导烧结过程中的质量守恒定律，还将亲手设计并实现一个能够精确模拟该过程的数值方案，从而深入理解复杂多相催化系统的建模精髓。",
            "id": "3888366",
            "problem": "考虑一个催化剂，其通过负载的金属颗粒的聚并发生烧结。令 $r$ 表示由参考半径缩放的无量纲颗粒半径，令 $n(r,t)$ 表示在时间 $t$ 时单位半径上的数密度。假设聚并过程不移除或增加固体质量（无蒸发，无溶解），因此单位反应器体积内的总固体体积是守恒的。单个颗粒的固体体积与 $r^{3}$ 成正比，单位反应器体积内的总固体体积由以下积分约束给出\n$$\nM(t) = \\int_{r_{\\min}}^{r_{\\max}} n(r,t)\\, r^{3}\\, dr.\n$$\n从 Smoluchowski 形式的群体平衡方程（PBE）出发，该方程指出 $n(r,t)$ 的时间变化率由产生尺寸为 $r$ 的聚并对的生成项和尺寸为 $r$ 的颗粒与任何其他颗粒聚并的消失项给出，并假设一个对称的、非负的聚并核函数 $K(r,r')$。从这个基本出发点，推导仅烧结机制所隐含的质量守恒积分约束，并解释在适当的边界条件和核函数下，为什么 $M(t)$ 随时间应保持不变。\n\n然后，设计并实现一个数值方案，该方案将半径域 $[r_{\\min}, r_{\\max}]$ 离散为 $N$ 个固定的枢轴点 $\\{r_{i}\\}_{i=1}^{N}$，其均匀间距为 $\\Delta r = (r_{\\max}-r_{\\min})/(N-1)$，并将离散颗粒数表示为 $C_{i}(t) \\approx \\int_{r_{i}-\\Delta r/2}^{r_{i}+\\Delta r/2} n(r,t)\\, dr$。使用基于固体体积线性插值的固定枢轴生成分布。该方案通过在相邻枢轴点之间分配新生成的颗粒数量来近似聚并过程，我们将评估该特定方案的质量守恒特性。$M(t)$ 的离散模拟量\n$$\nM_{\\Delta}(t) = \\sum_{i=1}^{N} C_{i}(t)\\, r_{i}^{3},\n$$\n通过离散化得以守恒。对离散的 Smoluchowski 演化过程使用时间步长为 $\\Delta t$ 的显式时间步进：\n- 损失：$D_{i}(t) = C_{i}(t) \\sum_{j=1}^{N} K(r_{i}, r_{j})\\, C_{j}(t)$。\n- 生成：对于无序对 $(i,j)$ 且 $i \\le j$，定义 $r_{\\text{new}} = \\left(r_{i}^{3} + r_{j}^{3}\\right)^{1/3}$ 和一个对形成速率\n$$\nR_{ij}(t) = \\begin{cases}\nK(r_{i}, r_{j})\\, C_{i}(t)\\, C_{j}(t),  i  j,\\\\\n\\frac{1}{2}\\, K(r_{i}, r_{i})\\, C_{i}(t)^{2},  i = j,\n\\end{cases}\n$$\n然后将生成物分配到两个相邻的枢轴点 $r_{k} \\le r_{\\text{new}} \\le r_{k+1}$，其权重由固体体积的线性插值确定：\n$$\nw_{k} = \\frac{r_{k+1}^{3} - r_{\\text{new}}^{3}}{r_{k+1}^{3} - r_{k}^{3}}, \\quad w_{k+1} = 1 - w_{k},\n$$\n从而使 $C_{k}(t)$ 和 $C_{k+1}(t)$ 分别增加 $R_{ij}(t)\\, w_{k}$ 和 $R_{ij}(t)\\, w_{k+1}$。如果 $r_{\\text{new}}$ 落在了 $[r_{\\min}, r_{\\max}]$ 之外，您可以将生成物固定到最近的边界枢轴点 $r_{1}$ 或 $r_{N}$；这通常会破坏离散质量守恒，并应进行量化检测。\n\n将 $n(r,0)$ 初始化为 $r$ 的对数正态数密度，并进行缩放，使得初始离散固体体积 $M_{\\Delta}(0)$ 等于 $M_{0} = 1$（无量纲）。具体来说，设置\n$$\nn(r,0) = \\alpha \\cdot \\frac{1}{r\\, \\sigma \\sqrt{2\\pi}} \\exp\\left(-\\frac{(\\ln r - \\mu)^{2}}{2 \\sigma^{2}}\\right),\n$$\n其中选择 $\\alpha$ 使得 $\\sum_{i=1}^{N} n(r_{i},0)\\, \\Delta r\\, r_{i}^{3} = M_{0} = 1$。将聚并核函数定义为常数 $K(r,r') = K_{0}$ 或加性形式 $K(r,r') = K_{0}\\, (r + r')$。\n\n您的任务是实现一个程序，该程序：\n1. 在注释或文档中，从 Smoluchowski PBE 在理想边界条件下推导出 $M(t)$ 的守恒性。\n2. 构建 $r$ 上的固定枢轴离散化，并采用上述基于体积的生成分布。\n3. 使用显式时间步进演化系统，并计算最终的相对质量误差\n$$\n\\varepsilon = \\frac{|M_{\\Delta}(T) - M_{\\Delta}(0)|}{M_{\\Delta}(0)},\n$$\n对每个测试用例，结果以小数形式表示。\n\n使用以下测试套件，每个套件由 $(N, r_{\\min}, r_{\\max}, \\mu, \\sigma, K_{0}, \\text{kernel\\_type}, \\Delta t, \\text{steps}, \\text{clamp\\_overflow})$ 指定，所有量均为无量纲：\n- 测试 A（理想情况，常数核函数，细网格）：$(N=64, r_{\\min}=0.5, r_{\\max}=2.0, \\mu=0, \\sigma=0.35, K_{0}=0.5, \\text{kernel\\_type}=\\text{\"constant\"}, \\Delta t=0.02, \\text{steps}=300, \\text{clamp\\_overflow}=\\text{False})$。\n- 测试 B（可变核函数，更细网格，更长域）：$(N=128, r_{\\min}=0.4, r_{\\max}=2.5, \\mu=0.2, \\sigma=0.30, K_{0}=0.3, \\text{kernel\\_type}=\\text{\"additive\"}, \\Delta t=0.01, \\text{steps}=400, \\text{clamp\\_overflow}=\\text{False})$。\n- 测试 C（粗网格，常数核函数）：$(N=12, r_{\\min}=0.5, r_{\\max}=2.0, \\mu=0, \\sigma=0.35, K_{0}=0.5, \\text{kernel\\_type}=\\text{\"constant\"}, \\Delta t=0.05, \\text{steps}=200, \\text{clamp\\_overflow}=\\text{False})$。\n- 测试 D（边界压力，常数核函数，生成物被固定以触发非守恒）：$(N=32, r_{\\min}=0.8, r_{\\max}=1.2, \\mu=0, \\sigma=0.20, K_{0}=1.0, \\text{kernel\\_type}=\\text{\"constant\"}, \\Delta t=0.03, \\text{steps}=300, \\text{clamp\\_overflow}=\\text{True})$。\n\n您的程序应生成单行输出，其中包含以方括号括起来的逗号分隔的结果列表（例如，“[resultA,resultB,resultC,resultD]”）。每个结果必须是相应测试用例的最终 $\\varepsilon$ 值，以小数形式表示（无量纲）。",
            "solution": "### 第1部分：从连续 PBE 推导质量守恒\n\n给定单位反应器体积内的总固体体积（我们称之为质量）是守恒的。该量定义为：\n$$\nM(t) = \\int_{r_{\\min}}^{r_{\\max}} n(r,t)\\, r^{3}\\, dr\n$$\n数密度 $n(r,t)$ 的时间演化由 Smoluchowski PBE 控制，可以写成生成速率和消失速率的平衡：\n$$\n\\frac{\\partial n(r,t)}{\\partial t} = \\text{Birth}(r,t) - \\text{Death}(r,t)\n$$\n消失项描述了半径为 $r$ 的颗粒因与任何其他颗粒聚并而造成的损失：\n$$\n\\text{Death}(r,t) = n(r,t) \\int_{r_{\\min}}^{r_{\\max}} K(r, r') n(r', t) dr'\n$$\n生成项描述了由两个半径分别为 $r_1$ 和 $r_2$ 的较小颗粒聚并形成半径为 $r$ 的颗粒，其体积相加，即 $r_1^3 + r_2^3 = r^3$。形式上，这可以用狄拉克δ函数表示：\n$$\n\\text{Birth}(r,t) = \\frac{1}{2} \\int_{r_{\\min}}^{r_{\\max}} \\int_{r_{\\min}}^{r_{\\max}} K(r_1, r_2) n(r_1, t) n(r_2, t) \\delta\\left(r - (r_1^3 + r_2^3)^{1/3}\\right) dr_1 dr_2\n$$\n因子 $1/2$ 是为了防止对 $(r_1, r_2)$ 对的重复计数。\n\n为了验证质量守恒，我们计算 $M(t)$ 的时间导数。假设我们可以交换微分和积分的顺序：\n$$\n\\frac{dM(t)}{dt} = \\int_{r_{\\min}}^{r_{\\max}} \\frac{\\partial n(r,t)}{\\partial t} r^3 dr\n$$\n代入 PBE：\n$$\n\\frac{dM(t)}{dt} = \\int_{r_{\\min}}^{r_{\\max}} \\text{Birth}(r,t) r^3 dr - \\int_{r_{\\min}}^{r_{\\max}} \\text{Death}(r,t) r^3 dr\n$$\n\n由消失项引起的总质量变化率 $I_{Death}$ 为：\n$$\nI_{Death} = \\int_{r_{\\min}}^{r_{\\max}} \\left( n(r,t) \\int_{r_{\\min}}^{r_{\\max}} K(r, r') n(r', t) dr' \\right) r^3 dr = \\int_{r_{\\min}}^{r_{\\max}} \\int_{r_{\\min}}^{r_{\\max}} K(r, r') n(r,t) n(r', t) r^3 dr' dr\n$$\n\n由生成项引起的总质量变化率 $I_{Birth}$ 为：\n$$\nI_{Birth} = \\int_{r_{\\min}}^{r_{\\max}} \\left( \\frac{1}{2} \\int_{r_{\\min}}^{r_{\\max}} \\int_{r_{\\min}}^{r_{\\max}} K(r_1, r_2) n(r_1, t) n(r_2, t) \\delta\\left(r - (r_1^3 + r_2^3)^{1/3}\\right) dr_1 dr_2 \\right) r^3 dr\n$$\n利用δ函数的筛选性质，并假设没有质量在域外生成（适当的边界条件）：\n$$\nI_{Birth} = \\frac{1}{2} \\int_{r_{\\min}}^{r_{\\max}} \\int_{r_{\\min}}^{r_{\\max}} K(r_1, r_2) n(r_1, t) n(r_2, t) (r_1^3 + r_2^3) dr_1 dr_2\n$$\n$$\nI_{Birth} = \\frac{1}{2} \\left( \\int \\int K(r_1, r_2) n_1 n_2 r_1^3 dr_1 dr_2 + \\int \\int K(r_1, r_2) n_1 n_2 r_2^3 dr_1 dr_2 \\right)\n$$\n由于核函数对称 $K(r_1, r_2) = K(r_2, r_1)$，通过在第二个积分中交换哑变量 $(r_1, r_2)$，我们发现两个积分相等。因此：\n$$\nI_{Birth} = \\int_{r_{\\min}}^{r_{\\max}} \\int_{r_{\\min}}^{r_{\\max}} K(r_1, r_2) n(r_1, t) n(r_2, t) r_1^3 dr_1 dr_2\n$$\n将积分变量重命名为 $r_1 \\to r$ 和 $r_2 \\to r'$，我们发现 $I_{Birth} = I_{Death}$。所以：\n$$\n\\frac{dM(t)}{dt} = I_{Birth} - I_{Death} = 0\n$$\n这证明了在对称核函数和边界无通量的假设下，总固体体积 $M(t)$ 是一个守恒量。\n\n### 第2部分：离散化方案的分析\n\n问题要求对半径域进行固定枢轴离散化。总质量的离散模拟量为 $M_{\\Delta}(t) = \\sum_{i=1}^{N} C_{i}(t)\\, r_{i}^{3}$。我们的目标是分析所提出的数值方案的质量守恒特性。\n\n离散的 Smoluchowski 方程可以写为：\n$$\n\\frac{dC_i}{dt} = \\text{BirthRate}_i - \\text{LossRate}_i\n$$\n其中，$\\text{LossRate}_i = C_i \\sum_{j=1}^N K_{ij} C_j$。\n从系统中因聚并而损失的总质量速率是：\n$$\n\\text{Total Mass Loss Rate} = \\sum_{i=1}^N (\\text{LossRate}_i) r_i^3 = \\sum_{i=1}^N \\sum_{j=1}^N K_{ij} C_i C_j r_i^3\n$$\n由于核函数 $K_{ij}$ 是对称的，通过交换求和指数 $i$ 和 $j$，我们可以将上式重写为：\n$$\n\\text{Total Mass Loss Rate} = \\frac{1}{2} \\sum_{i=1}^N \\sum_{j=1}^N K_{ij} C_i C_j (r_i^3 + r_j^3)\n$$\n这个表达式代表了所有聚并事件中消耗掉的颗粒的原始总体积。\n\n现在，我们分析新颗粒生成所引入的质量。当来自网格 $i$ 和 $j$ 的颗粒聚并时，它们形成一个体积为 $r_{\\text{new}}^3 = r_i^3 + r_j^3$ 的新颗粒。问题中描述的方案将这个新生成的颗粒**数量**（以速率 $R_{ij}$）分配到两个相邻的枢轴点 $k$ 和 $k+1$。因此，增加到离散系统中的总质量速率为：\n$$\n\\text{Total Mass Birth Rate} = \\sum_{i \\le j} R_{ij} \\left( w_k r_k^3 + w_{k+1} r_{k+1}^3 \\right)\n$$\n其中 $w_k$ 和 $w_{k+1}$ 是插值权重。将权重的定义代入，单次生成事件增加的质量为：\n$$\nR_{ij} \\left( \\frac{r_{k+1}^{3} - r_{\\text{new}}^{3}}{r_{k+1}^{3} - r_{k}^{3}} r_k^3 + \\frac{r_{\\text{new}}^{3} - r_k^3}{r_{k+1}^{3} - r_{k}^{3}} r_{k+1}^3 \\right)\n$$\n这个表达式通常**不等于**所生成的实际质量 $R_{ij} r_{\\text{new}}^3 = R_{ij}(r_i^3 + r_j^3)$。因此，这个通过对颗粒**数量**进行线性插值的方案，在离散层面上**不是**严格质量守恒的。该练习的数值部分的实际目标是实现这个特定的近似方案，并量化其内在的数值质量误差 $\\varepsilon$。一个真正守恒的方案需要直接分配质量，而不是数量。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that runs simulations for all test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test A (happy path, constant kernel, fine grid)\n        {\"N\": 64, \"r_min\": 0.5, \"r_max\": 2.0, \"mu\": 0, \"sigma\": 0.35, \"K0\": 0.5, \n         \"kernel_type\": \"constant\", \"dt\": 0.02, \"steps\": 300, \"clamp_overflow\": False},\n        # Test B (variable kernel, finer grid, longer domain)\n        {\"N\": 128, \"r_min\": 0.4, \"r_max\": 2.5, \"mu\": 0.2, \"sigma\": 0.30, \"K0\": 0.3, \n         \"kernel_type\": \"additive\", \"dt\": 0.01, \"steps\": 400, \"clamp_overflow\": False},\n        # Test C (coarse grid, constant kernel)\n        {\"N\": 12, \"r_min\": 0.5, \"r_max\": 2.0, \"mu\": 0, \"sigma\": 0.35, \"K0\": 0.5, \n         \"kernel_type\": \"constant\", \"dt\": 0.05, \"steps\": 200, \"clamp_overflow\": False},\n        # Test D (boundary stress, constant kernel, clamped births)\n        {\"N\": 32, \"r_min\": 0.8, \"r_max\": 1.2, \"mu\": 0, \"sigma\": 0.20, \"K0\": 1.0, \n         \"kernel_type\": \"constant\", \"dt\": 0.03, \"steps\": 300, \"clamp_overflow\": True},\n    ]\n\n    results = []\n    for params in test_cases:\n        error = run_simulation(**params)\n        results.append(f\"{error:.15e}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef run_simulation(N, r_min, r_max, mu, sigma, K0, kernel_type, dt, steps, clamp_overflow):\n    \"\"\"\n    Performs a single simulation of catalyst sintering based on the PBE.\n\n    This function implements the fixed-pivot method for solving the Smoluchowski\n    coagulation equation. It initializes a particle size distribution, then\n    evolves it in time using an explicit forward Euler scheme. The core of\n    the method is the careful calculation of birth and death terms, with a\n    special volume-based interpolation for birth events.\n    \"\"\"\n    # 1. Setup grid and initial conditions\n    r = np.linspace(r_min, r_max, N)\n    dr = r[1] - r[0]\n    r_cubed = r**3\n    M0 = 1.0\n\n    # Avoid log(0) or division by zero if r_min is 0.\n    n0_unscaled = (1 / (r * sigma * np.sqrt(2 * np.pi))) * \\\n                  np.exp(-(np.log(r) - mu)**2 / (2 * sigma**2))\n\n    # Normalize initial mass to M0\n    M_delta_unscaled = np.sum(n0_unscaled * dr * r_cubed)\n    alpha = M0 / M_delta_unscaled\n    n0 = alpha * n0_unscaled\n    C = n0 * dr\n    \n    M_delta_0 = np.sum(C * r_cubed)\n\n    # 2. Setup Coalescence Kernel\n    if kernel_type == \"constant\":\n        K = np.full((N, N), K0)\n    elif kernel_type == \"additive\":\n        K = K0 * np.add.outer(r, r)\n    else:\n        raise ValueError(\"Unknown kernel type\")\n\n    # 3. Time evolution loop\n    for _ in range(steps):\n        dC_dt = np.zeros(N)\n        \n        # Calculate loss terms (vectorized)\n        interaction_rates = K @ C\n        loss_rates = C * interaction_rates\n        dC_dt -= loss_rates\n        \n        # Calculate birth terms\n        # Loop over unique pairs (i, j) with i = j\n        for i in range(N):\n            for j in range(i, N + 1):\n                if j >= N: continue\n                if C[i]  1e-30 and C[j]  1e-30: continue\n\n                r_new_cubed = r_cubed[i] + r_cubed[j]\n                r_new = r_new_cubed**(1/3.0)\n                \n                if i == j:\n                    R_ij = 0.5 * K[i, i] * C[i]**2\n                else:\n                    R_ij = K[i, j] * C[i] * C[j]\n\n                if R_ij  1e-40: continue\n\n                # Find destination bins for the new particle\n                # k is the index such that r[k] = r_new = r[k+1]\n                k = np.searchsorted(r, r_new, side='right') - 1\n\n                # Check for boundary overflow\n                if k  0 or k >= N - 1:\n                    if clamp_overflow:\n                        if k  0: # Underflow\n                            dC_dt[0] += R_ij\n                        else: # Overflow (k >= N-1)\n                            dC_dt[N-1] += R_ij\n                    # If clamp_overflow is False, mass is lost from the system.\n                else: \n                    # Interior birth, use volume-based interpolation\n                    r_k_cubed = r_cubed[k]\n                    r_k1_cubed = r_cubed[k+1]\n                    \n                    denom = r_k1_cubed - r_k_cubed\n                    if denom  1e-30:\n                        if abs(r_new_cubed - r_k_cubed)  abs(r_new_cubed - r_k1_cubed):\n                           dC_dt[k] += R_ij\n                        else:\n                           dC_dt[k+1] += R_ij\n                        continue\n\n                    w_k = (r_k1_cubed - r_new_cubed) / denom\n                    w_k1 = 1.0 - w_k\n\n                    dC_dt[k] += R_ij * w_k\n                    dC_dt[k+1] += R_ij * w_k1\n        \n        # Update concentrations with Forward Euler\n        C += dC_dt * dt\n        # Enforce non-negativity\n        C[C  0] = 0\n\n    # 4. Calculate final mass and error\n    M_delta_T = np.sum(C * r_cubed)\n    \n    if abs(M_delta_0)  1e-15:\n        return np.abs(M_delta_T - M_delta_0)\n        \n    relative_error = np.abs(M_delta_T - M_delta_0) / M_delta_0\n    \n    return relative_error\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}