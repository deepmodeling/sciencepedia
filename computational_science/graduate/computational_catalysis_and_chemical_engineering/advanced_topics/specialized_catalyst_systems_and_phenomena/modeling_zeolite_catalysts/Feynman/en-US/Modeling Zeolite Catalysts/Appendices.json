{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of modeling zeolite catalysts is understanding the atomic structure of the framework itself. The substitution of silicon by aluminum atoms, which creates the catalytically active Brønsted acid sites, is not random but is governed by thermodynamic principles. This first practice connects the quantum mechanical world of Density Functional Theory (DFT) with the statistical mechanics of materials by tasking you with predicting the equilibrium distribution of aluminum atoms across different crystallographic sites . By deriving and applying the Boltzmann distribution, you will learn how to translate calculated site energies into temperature-dependent site probabilities, a foundational skill for building realistic catalyst models.",
            "id": "3890429",
            "problem": "You are modeling aluminum substitution over inequivalent tetrahedral sites in a zeolite framework using periodic Kohn-Sham Density Functional Theory (DFT). Each site type $i$ corresponds to a distinct local environment for $\\text{Al}$ substitution in the framework, with $i \\in \\{1,2,\\dots,N\\}$. A single aluminum atom replaces a silicon atom at one site type $i$ per model, producing $N$ separately optimized periodic models that share identical composition and the same compensating charge arrangement (for example, a proton or extra-framework cation). After full geometry relaxation at fixed periodic boundary conditions, you obtain total electronic energies $E_i$ for each model. Let $g_i$ denote the degeneracy, defined as the count of symmetry-equivalent positions for site type $i$ in the primitive cell. Assume all $E_i$ values are computed with the same exchange-correlation functional, basis, pseudopotentials, k-point sampling, and cell size, so that differences among $E_i$ reflect only the site-dependent environment of the aluminum substitution.\n\nStarting from first principles appropriate to equilibrium statistical mechanics and the canonical ensemble, determine how the equilibrium site-type occupancy probabilities arise when the system is in thermal contact with a reservoir at temperature $T$. Base your derivation on the principle of maximum entropy for discrete states with energy levels $E_i$, discrete degeneracy $g_i$, and constraints on normalization and average energy. You must begin from well-tested foundations such as the statistical definition of entropy $S$, constraints using Lagrange multipliers, and the thermodynamic requirement that average energy remains fixed. Do not rely on any pre-stated shortcut probability formulas in the problem statement. In the presence of degeneracy, show how site-type multiplicity enters the equilibrium probabilities. Explain how to treat the periodic DFT energies so that relative site preferences are extracted on a common reference, including any constant offsets that may be removed without altering probabilities.\n\nImplement an algorithm that, given lists of $E_i$ and $g_i$, and a temperature $T$, computes the Boltzmann-weighted site-type distribution. For numerical stability, normalize the energies to a common reference by subtracting a constant offset (for example, the minimum energy) before evaluating exponentials. Use the Boltzmann constant $k_\\mathrm{B}$ expressed in electronvolts per Kelvin, $k_\\mathrm{B} = 8.617333262145\\times 10^{-5}\\,\\mathrm{eV/K}$. All energies must be treated in electronvolts ($\\mathrm{eV}$), all temperatures must be treated in Kelvin ($\\mathrm{K}$), and the final site-type probabilities must be reported as decimals (not percentages). The computed probabilities must sum to $1$ within numerical precision for each test case.\n\nPhysical and numerical units requirement: express energies in $\\mathrm{eV}$, temperature in $\\mathrm{K}$, and report each probability as a decimal. Angles are not used in this problem. Use a canonical ensemble description appropriate for fixed number of particles, volume, and temperature.\n\nTest suite and answer specification: your program must evaluate the following test cases. Each test case consists of $([E_1,E_2,\\dots,E_N], [g_1,g_2,\\dots,g_N], T)$, where $E_i$ are periodic DFT total energies for $\\text{Al}$ at site type $i$ (same composition across $i$), $g_i$ are degeneracies, and $T$ is the temperature.\n\n- Case $1$ (general case, moderate temperature): $([0.12, 0.00, 0.08, 0.20]\\,\\mathrm{eV}, [8, 4, 12, 6], 700\\,\\mathrm{K})$.\n- Case $2$ (near-zero temperature limit): $([0.12, 0.00, 0.08, 0.20]\\,\\mathrm{eV}, [8, 4, 12, 6], 1\\,\\mathrm{K})$.\n- Case $3$ (high-temperature limit): $([0.12, 0.00, 0.08, 0.20]\\,\\mathrm{eV}, [8, 4, 12, 6], 5000\\,\\mathrm{K})$.\n- Case $4$ (equal energies, degeneracy-determined distribution): $([0.00, 0.00, 0.00, 0.00]\\,\\mathrm{eV}, [2, 2, 1, 3], 300\\,\\mathrm{K})$.\n- Case $5$ (two degenerate minima, low temperature): $([0.00, 0.00, 0.05, 0.10]\\,\\mathrm{eV}, [4, 4, 2, 2], 10\\,\\mathrm{K})$.\n\nFinal output format: your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element corresponds to one test case in order and must itself be a list of decimals giving the site-type probabilities in the same order as the input energies and degeneracies. For example, the overall output must look like $[[p_{1,1},p_{1,2},\\dots],[p_{2,1},p_{2,2},\\dots],\\dots]$, printed on a single line. Round each decimal to $6$ places in the final printed output.",
            "solution": "The problem asks for a derivation of the equilibrium site-type occupancy probabilities for aluminum substitution in a zeolite framework, starting from the principle of maximum entropy in the canonical ensemble. Subsequently, an algorithm must be implemented to compute these probabilities for given sets of site energies $E_i$, degeneracies $g_i$, and temperature $T$.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n-   Site types: $i \\in \\{1, 2, \\dots, N\\}$.\n-   Total electronic energy for a model with Al at site type $i$: $E_i$.\n-   Degeneracy (count of symmetry-equivalent positions) for site type $i$: $g_i$.\n-   System is in thermal contact with a reservoir at temperature $T$.\n-   The derivation must be based on the principle of maximum entropy for discrete states with energies $E_i$ and degeneracies $g_i$.\n-   Constraints: Normalization and fixed average energy.\n-   Method: Lagrange multipliers.\n-   Energies $E_i$ are given in electronvolts ($\\mathrm{eV}$).\n-   Temperature $T$ is given in Kelvin ($\\mathrm{K}$).\n-   Boltzmann constant: $k_\\mathrm{B} = 8.617333262145 \\times 10^{-5}\\,\\mathrm{eV/K}$.\n-   Test Cases:\n    1.  $E = [0.12, 0.00, 0.08, 0.20]\\,\\mathrm{eV}$, $g = [8, 4, 12, 6]$, $T = 700\\,\\mathrm{K}$.\n    2.  $E = [0.12, 0.00, 0.08, 0.20]\\,\\mathrm{eV}$, $g = [8, 4, 12, 6]$, $T = 1\\,\\mathrm{K}$.\n    3.  $E = [0.12, 0.00, 0.08, 0.20]\\,\\mathrm{eV}$, $g = [8, 4, 12, 6]$, $T = 5000\\,\\mathrm{K}$.\n    4.  $E = [0.00, 0.00, 0.00, 0.00]\\,\\mathrm{eV}$, $g = [2, 2, 1, 3]$, $T = 300\\,\\mathrm{K}$.\n    5.  $E = [0.00, 0.00, 0.05, 0.10]\\,\\mathrm{eV}$, $g = [4, 4, 2, 2]$, $T = 10\\,\\mathrm{K}$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, well-posed, and objective. It poses a standard, solvable problem in statistical mechanics and its application to computational materials science.\n-   **Scientific Grounding**: The use of DFT-calculated energies within a statistical mechanics framework (specifically, the canonical ensemble and Boltzmann statistics) to predict site occupancies is a well-established and valid a pproach in computational catalysis and materials science. The derivation requested is a fundamental exercise in statistical mechanics.\n-   **Well-Posedness**: The problem is clearly defined with all necessary inputs ($E_i$, $g_i$, $T$) and a well-defined output (probabilities $p_i$). A unique, stable solution exists and is derivable from the given principles.\n-   **Objectivity**: The problem is stated using precise, formal language and is free from subjective or ambiguous terminology.\n-   The problem does not violate any of the invalidity criteria. The data is consistent, the scenario is physically plausible, and the task is a formal derivation and implementation, not a subjective or trivial question.\n\n**Step 3: Verdict and Action**\nThe problem is valid. I will proceed with the solution.\n\n### Derivation from First Principles\n\nWe model the system as a single aluminum atom able to occupy any of the available tetrahedral sites in the zeolite framework. The fundamental states of the system, or microstates, correspond to the Al atom occupying one specific crystallographic position. There are $N$ distinct types of sites, with the $i$-th type having $g_i$ equivalent positions (degeneracy) and an associated energy $E_i$.\n\nLet $P_j$ be the probability of the system being in a specific microstate $j$. The statistical definition of entropy (Gibbs entropy) is:\n$$ S = -k_\\mathrm{B} \\sum_j P_j \\ln P_j $$\nwhere the sum is over all accessible microstates.\n\nThe equilibrium distribution is the one that maximizes $S$ subject to the physical constraints of the system. In the canonical ensemble (fixed particle number, volume, and temperature), these constraints are:\n1.  **Normalization**: The probabilities must sum to unity.\n    $$ \\sum_j P_j = 1 $$\n2.  **Average Energy**: The average energy of the system is fixed at a value $U$. Let $E(j)$ be the energy of microstate $j$.\n    $$ \\langle E \\rangle = \\sum_j P_j E(j) = U $$\n\nWe use the method of Lagrange multipliers to find the distribution $\\{P_j\\}$ that maximizes $S$. We construct the Lagrangian function $\\mathcal{L}$, conventionally maximizing $S/k_\\mathrm{B}$ for simplicity:\n$$ \\mathcal{L}(\\{P_j\\}, \\alpha, \\beta) = \\frac{S}{k_\\mathrm{B}} - \\alpha \\left( \\sum_j P_j - 1 \\right) - \\beta \\left( \\sum_j P_j E(j) - U \\right) $$\n$$ \\mathcal{L} = -\\sum_j P_j \\ln P_j - \\alpha \\left( \\sum_j P_j - 1 \\right) - \\beta \\left( \\sum_j P_j E(j) - U \\right) $$\nTo find the maximum, we set the partial derivative of $\\mathcal{L}$ with respect to an arbitrary probability $P_k$ to zero:\n$$ \\frac{\\partial \\mathcal{L}}{\\partial P_k} = -(\\ln P_k + P_k \\cdot \\frac{1}{P_k}) - \\alpha - \\beta E(k) = 0 $$\n$$ -\\ln P_k - 1 - \\alpha - \\beta E(k) = 0 $$\n$$ \\ln P_k = -(1+\\alpha) - \\beta E(k) $$\nThis gives the form of the probability for microstate $k$:\n$$ P_k = e^{-(1+\\alpha)} e^{-\\beta E(k)} $$\nThe term $e^{-(1+\\alpha)}$ is a normalization constant. We find its value by applying the normalization constraint:\n$$ \\sum_k P_k = \\sum_k e^{-(1+\\alpha)} e^{-\\beta E(k)} = e^{-(1+\\alpha)} \\sum_k e^{-\\beta E(k)} = 1 $$\n$$ e^{-(1+\\alpha)} = \\frac{1}{\\sum_k e^{-\\beta E(k)}} $$\nThe denominator is the canonical partition function, $Z = \\sum_k e^{-\\beta E(k)}$. Thus, the probability of finding the system in a specific microstate $k$ is:\n$$ P_k = \\frac{e^{-\\beta E(k)}}{Z} $$\nFrom the principles of thermodynamics, the Lagrange multiplier $\\beta$ is identified with the inverse temperature, $\\beta = 1/(k_\\mathrm{B} T)$.\n\nThe problem asks for the probability $p_i$ of finding the aluminum atom in any site of *type* $i$. This is obtained by summing the probabilities $P_k$ of all microstates $k$ that belong to site type $i$. There are $g_i$ such microstates, and they all share the same energy $E_i$.\n$$ p_i = \\sum_{k \\in \\text{type } i} P_k = \\sum_{k \\in \\text{type } i} \\frac{e^{-\\beta E_i}}{Z} $$\nSince the energy $E_i$ is constant for all $g_i$ sites of type $i$, the sum becomes:\n$$ p_i = g_i \\frac{e^{-\\beta E_i}}{Z} $$\nThe partition function $Z$ is the sum over all microstates. We can group the microstates by site type:\n$$ Z = \\sum_{j=1}^N \\sum_{k \\in \\text{type } j} e^{-\\beta E_j} = \\sum_{j=1}^N g_j e^{-\\beta E_j} $$\nSubstituting this expression for $Z$ gives the final formula for the site-type occupancy probability:\n$$ p_i = \\frac{g_i e^{-E_i / (k_\\mathrm{B} T)}}{\\sum_{j=1}^N g_j e^{-E_j / (k_\\mathrm{B} T)}} $$\nThis is the Boltzmann distribution for a system with discrete, degenerate energy levels.\n\n### Energy Referencing and Numerical Stability\n\nPeriodic DFT calculations yield large, negative total electronic energies. Directly computing $e^{-E_i / (k_\\mathrm{B} T)}$ can lead to numerical underflow if $E_i$ is a large positive number (relative to other sites) or overflow if it is very negative. However, the probabilities $p_i$ depend only on energy *differences*. We can prove this by shifting all energies by a constant offset $E_0$:\n$$ p_i = \\frac{g_i e^{-(E_i - E_0 + E_0) / (k_\\mathrm{B} T)}}{\\sum_{j=1}^N g_j e^{-(E_j - E_0 + E_0) / (k_\\mathrm{B} T)}} = \\frac{g_i e^{-(E_i - E_0) / (k_\\mathrm{B} T)} e^{-E_0 / (k_\\mathrm{B} T)}}{\\sum_{j=1}^N g_j e^{-(E_j - E_0) / (k_\\mathrm{B} T)} e^{-E_0 / (k_\\mathrm{B} T)}} $$\nThe term $e^{-E_0 / (k_\\mathrm{B} T)}$ is a common factor in the numerator and denominator and thus cancels:\n$$ p_i = \\frac{g_i e^{-(E_i - E_0) / (k_\\mathrm{B} T)}}{\\sum_{j=1}^N g_j e^{-(E_j - E_0) / (k_\\mathrm{B} T)}} $$\nFor numerical stability, it is conventional to choose $E_0 = E_{\\text{min}} = \\min_j(E_j)$. This sets the lowest relative energy to $0$ and all other relative energies to positive values, ensuring the largest exponential term is $e^0 = 1$ and preventing underflow for the most probable state(s).\n\n### Algorithm Design for Implementation\n\n1.  **Input**: A list of energies $E = [E_1, E_2, \\dots, E_N]$, a list of degeneracies $g = [g_1, g_2, \\dots, g_N]$, and a temperature $T$. The constant $k_\\mathrm{B}$ is also known.\n2.  **Energy Normalization**: Compute the minimum energy $E_{\\text{min}} = \\min(E)$. Calculate the relative energies $\\Delta E_i = E_i - E_{\\text{min}}$ for all $i$.\n3.  **Compute Boltzmann Weights**: For each site type $i$, calculate its statistical weight $w_i$. This is the product of the degeneracy and the Boltzmann factor. Let $\\beta = 1/(k_\\mathrm{B} T)$.\n    $$ w_i = g_i e^{-\\beta \\Delta E_i} $$\n4.  **Compute Partition Function**: Sum the weights to get the partition function $Z$.\n    $$ Z = \\sum_{i=1}^N w_i $$\n5.  **Compute Probabilities**: Normalize the individual weights by the partition function to obtain the probabilities.\n    $$ p_i = \\frac{w_i}{Z} $$\n6.  **Output**: Return the list of probabilities $[p_1, p_2, \\dots, p_N]$.\n\nThis algorithm will be applied to each test case provided in the problem statement. The use of NumPy arrays for these calculations will be efficient.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes site-type occupancy probabilities based on Boltzmann statistics\n    for a series of test cases.\n    \"\"\"\n    \n    # Constants\n    # Boltzmann constant in eV/K\n    KB = 8.617333262145e-5\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: general case, moderate temperature\n        ([0.12, 0.00, 0.08, 0.20], [8, 4, 12, 6], 700.0),\n        # Case 2: near-zero temperature limit\n        ([0.12, 0.00, 0.08, 0.20], [8, 4, 12, 6], 1.0),\n        # Case 3: high-temperature limit\n        ([0.12, 0.00, 0.08, 0.20], [8, 4, 12, 6], 5000.0),\n        # Case 4: equal energies, degeneracy-determined distribution\n        ([0.00, 0.00, 0.00, 0.00], [2, 2, 1, 3], 300.0),\n        # Case 5: two degenerate minima, low temperature\n        ([0.00, 0.00, 0.05, 0.10], [4, 4, 2, 2], 10.0),\n    ]\n\n    def calculate_probabilities(energies, degeneracies, temperature, k_b):\n        \"\"\"\n        Calculates the Boltzmann-weighted site-type distribution.\n\n        Args:\n            energies (list or np.ndarray): List of DFT total energies in eV.\n            degeneracies (list or np.ndarray): List of site degeneracies.\n            temperature (float): Temperature in K.\n            k_b (float): Boltzmann constant in eV/K.\n\n        Returns:\n            list: A list of site-type probabilities.\n        \"\"\"\n        energies_arr = np.array(energies, dtype=np.float64)\n        degeneracies_arr = np.array(degeneracies, dtype=np.float64)\n\n        # For numerical stability, normalize energies by subtracting the minimum energy.\n        # This makes all relative energies >= 0 and avoids underflow/overflow issues.\n        min_energy = np.min(energies_arr)\n        relative_energies = energies_arr - min_energy\n\n        # Calculate thermal energy\n        k_b_t = k_b * temperature\n        \n        # Handle the T -> 0 limit gracefully, though T=1K is used in test case.\n        # If k_b_t is extremely small or zero, only the ground state(s) are populated.\n        if np.isclose(k_b_t, 0.0):\n            # Find indices of minimum energy states\n            ground_state_indices = np.where(np.isclose(relative_energies, 0.0))[0]\n            \n            # Sum of degeneracies for ground states\n            total_ground_degeneracy = np.sum(degeneracies_arr[ground_state_indices])\n            \n            probabilities = np.zeros_like(energies_arr)\n            if total_ground_degeneracy > 0:\n                probabilities[ground_state_indices] = degeneracies_arr[ground_state_indices] / total_ground_degeneracy\n            \n            return probabilities.tolist()\n\n        # Calculate Boltzmann weights: g_i * exp(-E_i / k_B T)\n        # Using relative energies for numerical stability.\n        boltzmann_weights = degeneracies_arr * np.exp(-relative_energies / k_b_t)\n        \n        # The sum of weights is the partition function Z\n        partition_function = np.sum(boltzmann_weights)\n\n        # Probabilities are the individual weights divided by the partition function\n        if partition_function == 0.0:\n            # This can happen if all weights underflow to zero at extremely low T.\n            # In this case, apply the zero-temperature logic.\n            ground_state_indices = np.where(np.isclose(relative_energies, 0.0))[0]\n            total_ground_degeneracy = np.sum(degeneracies_arr[ground_state_indices])\n            probabilities = np.zeros_like(energies_arr)\n            if total_ground_degeneracy > 0:\n                probabilities[ground_state_indices] = degeneracies_arr[ground_state_indices] / total_ground_degeneracy\n        else:\n            probabilities = boltzmann_weights / partition_function\n\n        return probabilities.tolist()\n\n    all_results = []\n    for case in test_cases:\n        energies, degeneracies, temp = case\n        result_probabilities = calculate_probabilities(energies, degeneracies, temp, KB)\n        all_results.append(result_probabilities)\n    \n    # Format the final output string as specified: [[p1,p2,...],[p1,p2,...],...]\n    # Each probability is rounded to 6 decimal places.\n    inner_lists_str = []\n    for res_list in all_results:\n        formatted_nums = [f'{p:.6f}' for p in res_list]\n        inner_lists_str.append(f\"[{','.join(formatted_nums)}]\")\n    \n    final_output = f\"[{','.join(inner_lists_str)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "Once the locations of aluminum atoms are established, the next critical step is to quantify the reactivity of the resulting acid sites. A key descriptor of acid strength is the deprotonation energy (DPE), but its direct calculation can be computationally demanding. This exercise introduces a powerful and practical approach: building a structure-property relationship that connects the DPE to simple, local structural descriptors . By fitting an affine model to a dataset of known DPEs, you will gain hands-on experience in creating efficient, predictive tools that are essential for high-throughput screening and developing a deeper intuition for the factors that govern zeolite acidity.",
            "id": "3890428",
            "problem": "You are modeling how framework aluminum siting in a zeolite influences the deprotonation energy (DPE) of a Brønsted acid site. A Brønsted acid site in a zeolite corresponds to a tetrahedral site where silicon is substituted by aluminum and a charge-compensating proton is bound to a neighboring oxygen. The deprotonation energy (DPE) is the energy required to remove the proton to infinity. In this problem, you will quantify the effect of aluminum siting descriptors on DPE by fitting an affine model using ordinary least squares and then using it to predict new cases.\n\nYou must start from the following fundamental bases:\n- Charge localization and local structure control the stability of the conjugate base; therefore, the deprotonation energy depends on local structural descriptors such as ring sizes and the presence of charge-bearing aluminum in the next-nearest neighbor shell. This is a well-tested concept in computational catalysis for zeolites.\n- In linear response modeling, an observable can be approximated as an affine function of a set of descriptors. You will assume an affine dependence of DPE on structural descriptors and determine the coefficients by minimizing the sum of squared residuals (ordinary least squares).\n- The least squares estimator minimizes the sum of squared differences between observed and predicted values over the training dataset.\n\nDefinitions and variables:\n- Deprotonation energy (DPE) is denoted by $y$ and must be expressed in kilojoules per mole (kJ/mol).\n- Each tetrahedral framework site (T-site) $i$ is represented by a descriptor vector $\\mathbf{x}_i \\in \\mathbb{R}^p$ containing:\n  - $r4$: membership indicator in a $4$-member ring (value in $\\{0,1\\}$).\n  - $r5$: membership indicator in a $5$-member ring (value in $\\{0,1\\}$).\n  - $r6$: membership indicator in a $6$-member ring (value in $\\{0,1\\}$).\n  - $r10$: membership indicator in a $10$-member ring (value in $\\{0,1\\}$).\n  - $n_{\\mathrm{NNN}}$: integer count of framework aluminum atoms in the next-nearest neighbor (second shell) around the site (value in $\\{0,1,2,3\\}$ here).\n  - $d_{\\min}$: minimum T–T distance to any next-nearest aluminum, in angstroms ($\\text{\\AA}$). Distances must be entered as real numbers with units $\\text{\\AA}$, but the program should treat them numerically without units.\n- Your model must include an intercept, so the affine model is $y = \\beta_0 + \\sum_{j=1}^p \\beta_j x_j + \\varepsilon$, where $\\varepsilon$ is the residual.\n\nTraining dataset:\nYou are given $N = 12$ labeled T-sites with descriptor vectors $\\mathbf{x}_i$ and corresponding DPE values $y_i$ (in kJ/mol). The descriptors are ordered as $[r4, r5, r6, r10, n_{\\mathrm{NNN}}, d_{\\min}]$.\n\n- Site $1$: $\\mathbf{x}_1 = [1, 0, 0, 0, 0, 8.0]$, $y_1 = 1356.0$.\n- Site $2$: $\\mathbf{x}_2 = [0, 1, 0, 0, 1, 7.5]$, $y_2 = 1320.0$.\n- Site $3$: $\\mathbf{x}_3 = [0, 0, 1, 0, 0, 7.0]$, $y_3 = 1320.7$.\n- Site $4$: $\\mathbf{x}_4 = [0, 0, 0, 1, 2, 7.8]$, $y_4 = 1275.2$.\n- Site $5$: $\\mathbf{x}_5 = [1, 1, 0, 0, 1, 6.8]$, $y_5 = 1351.0$.\n- Site $6$: $\\mathbf{x}_6 = [0, 1, 1, 0, 0, 8.2]$, $y_6 = 1341.3$.\n- Site $7$: $\\mathbf{x}_7 = [1, 0, 1, 0, 2, 7.2]$, $y_7 = 1331.8$.\n- Site $8$: $\\mathbf{x}_8 = [0, 0, 1, 1, 1, 8.8]$, $y_8 = 1297.6$.\n- Site $9$: $\\mathbf{x}_9 = [0, 0, 0, 0, 0, 9.0]$, $y_9 = 1324.6$.\n- Site $10$: $\\mathbf{x}_{10} = [0, 1, 0, 1, 3, 6.6]$, $y_{10} = 1272.1$.\n- Site $11$: $\\mathbf{x}_{11} = [1, 0, 0, 1, 1, 7.6]$, $y_{11} = 1320.7$.\n- Site $12$: $\\mathbf{x}_{12} = [0, 1, 0, 0, 2, 6.9]$, $y_{12} = 1306.0$.\n\nYour tasks:\n1. Fit an affine model $y = \\beta_0 + \\sum_{j=1}^p \\beta_j x_j$ to the training data by minimizing the sum of squared residuals.\n2. Use the fitted model to predict DPE values for the following four test T-sites, each given as a descriptor vector in the same order:\n   - Test A: $\\mathbf{x}_A = [1, 0, 0, 0, 2, 7.0]$.\n   - Test B: $\\mathbf{x}_B = [0, 1, 0, 1, 0, 8.5]$.\n   - Test C: $\\mathbf{x}_C = [0, 0, 1, 0, 1, 6.7]$.\n   - Test D: $\\mathbf{x}_D = [1, 1, 0, 0, 3, 6.6]$.\n3. Evaluate the effect of aluminum siting by reporting the signs of the estimated coefficients corresponding to $n_{\\mathrm{NNN}}$ and $d_{\\min}$, and the coefficient of $r4$. Specifically, produce boolean values for:\n   - Is the coefficient of $n_{\\mathrm{NNN}}$ negative?\n   - Is the coefficient of $r4$ positive?\n   - Is the coefficient of $d_{\\min}$ positive?\n\nNumerical and unit requirements:\n- All predicted DPE values must be expressed in kilojoules per mole (kJ/mol).\n- Round each predicted DPE to three decimal places.\n- Angles are not used; distances $d_{\\min}$ are in angstroms, but you should output only energies in kJ/mol.\n\nTest suite and final output specification:\n- Your program must compute and output, in order, the four predicted DPE values for Test A, Test B, Test C, and Test D, followed by the three boolean answers for the coefficient-sign questions.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with no spaces. The first four entries must be floats with three decimal places, and the last three entries must be boolean values. For example: $[\\text{val}_A,\\text{val}_B,\\text{val}_C,\\text{val}_D,\\text{bool}_1,\\text{bool}_2,\\text{bool}_3]$.",
            "solution": "The problem as stated is valid. It is scientifically grounded in the principles of computational catalysis and heterogeneous catalysis, where structure-property relationships are commonly established using linear models. The problem is well-posed, providing a complete dataset for an ordinary least squares (OLS) regression, a standard and solvable statistical method. The definitions are objective and the data is self-consistent and sufficient to proceed.\n\nThe task is to fit an affine model to a given dataset and use it for prediction. The model describes the deprotonation energy (DPE), $y$, as a linear function of $p=6$ structural descriptors, $\\mathbf{x} = [x_1, \\dots, x_p]^T$, plus an intercept term. The model equation is:\n$$y = \\beta_0 + \\sum_{j=1}^{p} \\beta_j x_j + \\varepsilon$$\nwhere $\\beta_0$ is the intercept, $\\{\\beta_j\\}_{j=1}^p$ are the model coefficients, and $\\varepsilon$ represents the residual error. The descriptors are $x_1=r4$, $x_2=r5$, $x_3=r6$, $x_4=r10$, $x_5=n_{\\mathrm{NNN}}$, and $x_6=d_{\\min}$.\n\nFor a training set of $N=12$ observations, this relationship can be expressed in matrix form as:\n$$\\mathbf{y} = \\mathbf{X}\\boldsymbol{\\beta} + \\boldsymbol{\\varepsilon}$$\nHere, $\\mathbf{y}$ is an $N \\times 1$ vector of the observed DPE values. $\\boldsymbol{\\beta}$ is a $(p+1) \\times 1$ vector of the coefficients to be determined: $\\boldsymbol{\\beta} = [\\beta_0, \\beta_1, \\dots, \\beta_p]^T$. $\\mathbf{X}$ is the $N \\times (p+1)$ design matrix, constructed by augmenting the $N \\times p$ matrix of descriptor data with a leading column of ones to account for the intercept $\\beta_0$.\n\nThe ordinary least squares (OLS) method finds the coefficient vector $\\hat{\\boldsymbol{\\beta}}$ that minimizes the sum of squared residuals, $S(\\boldsymbol{\\beta}) = \\sum_{i=1}^N \\varepsilon_i^2 = ||\\mathbf{y} - \\mathbf{X}\\boldsymbol{\\beta}||_2^2$. The solution to this minimization problem is found by solving the normal equations:\n$$(\\mathbf{X}^T\\mathbf{X})\\hat{\\boldsymbol{\\beta}} = \\mathbf{X}^T\\mathbf{y}$$\nThe OLS estimator for the coefficients is therefore:\n$$\\hat{\\boldsymbol{\\beta}} = (\\mathbf{X}^T\\mathbf{X})^{-1}\\mathbf{X}^T\\mathbf{y}$$\nFor superior numerical stability, we will solve this system using a method based on QR decomposition, as is standard practice and implemented in libraries such as NumPy, rather than by explicitly computing the matrix inverse.\n\nThe first step is to construct the design matrix $\\mathbf{X}$ and the observation vector $\\mathbf{y}$ from the provided training data.\nThe vector of observations is:\n$$\\mathbf{y} = [1356.0, 1320.0, 1320.7, 1275.2, 1351.0, 1341.3, 1331.8, 1297.6, 1324.6, 1272.1, 1320.7, 1306.0]^T$$\nThe $12 \\times 7$ design matrix $\\mathbf{X}$ is:\n$$\n\\mathbf{X} =\n\\begin{pmatrix}\n1 & 1 & 0 & 0 & 0 & 0 & 8.0 \\\\\n1 & 0 & 1 & 0 & 0 & 1 & 7.5 \\\\\n1 & 0 & 0 & 1 & 0 & 0 & 7.0 \\\\\n1 & 0 & 0 & 0 & 1 & 2 & 7.8 \\\\\n1 & 1 & 1 & 0 & 0 & 1 & 6.8 \\\\\n1 & 0 & 1 & 1 & 0 & 0 & 8.2 \\\\\n1 & 1 & 0 & 1 & 0 & 2 & 7.2 \\\\\n1 & 0 & 0 & 1 & 1 & 1 & 8.8 \\\\\n1 & 0 & 0 & 0 & 0 & 0 & 9.0 \\\\\n1 & 0 & 1 & 0 & 1 & 3 & 6.6 \\\\\n1 & 1 & 0 & 0 & 1 & 1 & 7.6 \\\\\n1 & 0 & 1 & 0 & 0 & 2 & 6.9\n\\end{pmatrix}\n$$\nSolving the linear least squares problem for $\\hat{\\boldsymbol{\\beta}}$ yields the estimated coefficient vector:\n$$\\hat{\\boldsymbol{\\beta}} = [\\hat{\\beta}_0, \\hat{\\beta}_{r4}, \\hat{\\beta}_{r5}, \\hat{\\beta}_{r6}, \\hat{\\beta}_{r10}, \\hat{\\beta}_{n_{\\mathrm{NNN}}}, \\hat{\\beta}_{d_{\\min}}]^T$$\n\nOnce $\\hat{\\boldsymbol{\\beta}}$ is determined, we can predict the DPE for the four test sites. For each test descriptor vector $\\mathbf{x}_{\\text{test}}$, the predicted DPE, $y_{\\text{pred}}$, is calculated as:\n$$y_{\\text{pred}} = \\hat{\\beta}_0 + \\hat{\\beta}_{r4} x_{r4} + \\hat{\\beta}_{r5} x_{r5} + \\hat{\\beta}_{r6} x_{r6} + \\hat{\\beta}_{r10} x_{r10} + \\hat{\\beta}_{n_{\\mathrm{NNN}}} x_{n_{\\mathrm{NNN}}} + \\hat{\\beta}_{d_{\\min}} x_{d_{\\min}}$$\nThis is performed for each of the four test vectors, and the results are rounded to three decimal places.\n\nThe final task is to evaluate the signs of specific coefficients from the fitted model $\\hat{\\boldsymbol{\\beta}}$:\n1.  The sign of $\\hat{\\beta}_{n_{\\mathrm{NNN}}}$, the coefficient for the number of next-nearest neighbor aluminum atoms.\n2.  The sign of $\\hat{\\beta}_{r4}$, the coefficient for membership in a $4$-member ring.\n3.  The sign of $\\hat{\\beta}_{d_{\\min}}$, the coefficient for the minimum T-T distance to a next-nearest aluminum.\n\nThese checks are performed by direct inspection of the elements of the calculated $\\hat{\\boldsymbol{\\beta}}$ vector. The resulting four predicted DPE values and three boolean values are then formatted into the required output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Fits an affine model using ordinary least squares to predict deprotonation energy (DPE)\n    of Brønsted acid sites in a zeolite based on structural descriptors.\n    \"\"\"\n    # Define the training dataset from the problem statement.\n    # Descriptors are ordered as [r4, r5, r6, r10, n_NNN, d_min].\n    training_data = [\n        ([1, 0, 0, 0, 0, 8.0], 1356.0),\n        ([0, 1, 0, 0, 1, 7.5], 1320.0),\n        ([0, 0, 1, 0, 0, 7.0], 1320.7),\n        ([0, 0, 0, 1, 2, 7.8], 1275.2),\n        ([1, 1, 0, 0, 1, 6.8], 1351.0),\n        ([0, 1, 1, 0, 0, 8.2], 1341.3),\n        ([1, 0, 1, 0, 2, 7.2], 1331.8),\n        ([0, 0, 1, 1, 1, 8.8], 1297.6),\n        ([0, 0, 0, 0, 0, 9.0], 1324.6),\n        ([0, 1, 0, 1, 3, 6.6], 1272.1),\n        ([1, 0, 0, 1, 1, 7.6], 1320.7),\n        ([0, 1, 0, 0, 2, 6.9], 1306.0),\n    ]\n\n    # Unpack training data into descriptor matrix and DPE vector\n    X_train_data = np.array([item[0] for item in training_data])\n    y_train = np.array([item[1] for item in training_data])\n\n    # Construct the design matrix by adding a column of ones for the intercept\n    num_observations = X_train_data.shape[0]\n    X_train = np.hstack([np.ones((num_observations, 1)), X_train_data])\n\n    # Task 1: Fit the affine model using Ordinary Least Squares.\n    # np.linalg.lstsq provides a numerically stable solution to the normal equations.\n    # It returns the coefficient vector that minimizes the sum of squared residuals.\n    # The returned vector coeffs contains [beta_0, beta_r4, beta_r5, ...].\n    coeffs, _, _, _ = np.linalg.lstsq(X_train, y_train, rcond=None)\n\n    # Define the test cases for prediction.\n    test_cases = [\n        [1, 0, 0, 0, 2, 7.0],  # Test A\n        [0, 1, 0, 1, 0, 8.5],  # Test B\n        [0, 0, 1, 0, 1, 6.7],  # Test C\n        [1, 1, 0, 0, 3, 6.6],  # Test D\n    ]\n    \n    # Construct the design matrix for the test cases\n    X_test_data = np.array(test_cases)\n    X_test = np.hstack([np.ones((X_test_data.shape[0], 1)), X_test_data])\n\n    # Task 2: Use the fitted model to predict DPE values for test sites.\n    # y_pred = X_test @ coeffs\n    predicted_dpes = X_test.dot(coeffs)\n\n    # Round each predicted DPE to three decimal places.\n    rounded_dpes = [round(val, 3) for val in predicted_dpes]\n\n    # Task 3: Evaluate the signs of specific estimated coefficients.\n    # The descriptor order is [r4, r5, r6, r10, n_NNN, d_min].\n    # coeffs[0] is the intercept.\n    # coeffs[1] is for r4.\n    # coeffs[5] is for n_NNN.\n    # coeffs[6] is for d_min.\n    \n    # Is the coefficient of n_NNN negative?\n    is_n_nnn_coeff_negative = coeffs[5] < 0\n    # Is the coefficient of r4 positive?\n    is_r4_coeff_positive = coeffs[1] > 0\n    # Is the coefficient of d_min positive?\n    is_d_min_coeff_positive = coeffs[6] > 0\n\n    # Assemble the final results list\n    all_results = rounded_dpes + [is_n_nnn_coeff_negative, is_r4_coeff_positive, is_d_min_coeff_positive]\n\n    # Format the final output string as per the specification.\n    # Example: [val_A,val_B,val_C,val_D,bool_1,bool_2,bool_3] with no spaces.\n    # Python's bool __str__ method returns 'True' or 'False', which need to be lowercased.\n    output_str = f\"[{','.join(str(r) for r in all_results)}]\"\n    final_output = output_str.replace(\"True\", \"true\").replace(\"False\", \"false\")\n\n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "Moving from the intrinsic properties of the catalyst to its interaction with reactants, this practice explores the fundamental process of adsorption. To model any catalytic reaction, one must first understand how and to what extent reactant molecules populate the zeolite's pores from the gas or liquid phase. This exercise introduces Grand Canonical Monte Carlo (GCMC), a vital simulation technique for studying phase equilibria, and the Widom Test Particle method for calculating chemical potentials . By implementing this protocol, you will predict macroscopic adsorption isotherms from first principles, bridging the crucial gap between the molecular interaction potential and experimentally verifiable data.",
            "id": "3890457",
            "problem": "You are tasked to design and implement a Grand Canonical Monte Carlo (GCMC) simulation protocol for adsorption of water and ethanol in the Beta zeolite (BEA) framework, using Widom Test Particle (WTP) insertion to compute chemical potential contributions and predict low-pressure isotherms. The protocol must be grounded in statistical mechanics and thermodynamics, starting from the grand canonical ensemble and leading to a Henry constant that relates adsorbed loading to gas-phase pressure in the low-fugacity limit. You will validate the simulated isotherms against provided experimental data and compute a quantitative error metric.\n\nBegin from the fundamental definition of the Grand Canonical ensemble. The grand canonical partition function is defined for a single-component system by the sum over particle numbers and configurations weighted by the activity and Boltzmann factor, where the activity is related to the chemical potential. Adopt the definition of the Widom Test Particle method for excess chemical potential and connect it to the low-fugacity adsorption loading via the Henry limit. Use the Ideal Gas Law to relate pressure and number density, and explicitly implement Boltzmann sampling for the external potential in a pore.\n\nModel assumptions:\n- The BEA pore is approximated as a single cylindrical channel of radius $R$ running along the $z$-axis inside a rectangular unit cell of dimensions $L_x \\times L_y \\times L_z$. The pore axis is centered and parallel to the $z$ direction. The adsorbent mass is computed from the solid volume in the simulation cell, $m = \\rho_{\\text{solid}} \\left(L_x L_y L_z - \\pi R^2 L_z\\right)$, where $\\rho_{\\text{solid}}$ is the adsorbent solid density.\n- Treat each adsorbate (water and ethanol) as a single-site spherically symmetric coarse-grained particle interacting with the pore wall through a Lennard-Jones $12$-$6$ external potential as a function of the shortest distance to the cylindrical wall. If a test particle is at radial position $r$ from the cylinder center, define $\\delta = R - r$ as the wall distance. The external potential is $U(\\delta) = 4 \\epsilon_{\\text{sf}} \\left[ \\left(\\frac{\\sigma_{\\text{sf}}}{\\delta}\\right)^{12} - \\left(\\frac{\\sigma_{\\text{sf}}}{\\delta}\\right)^6 \\right]$, where $\\epsilon_{\\text{sf}}$ is the solid-fluid well depth and $\\sigma_{\\text{sf}}$ is the solid-fluid size parameter. Enforce an excluded region such that positions with $\\delta < \\sigma_{\\text{sf}}$ are inaccessible; define the accessible pore radius as $R_{\\text{acc}} = R - \\sigma_{\\text{sf}}$, and the accessible pore volume as $V_{\\text{acc}} = \\pi R_{\\text{acc}}^2 L_z$ if $R_{\\text{acc}} > 0$, else $V_{\\text{acc}} = 0$.\n- In the low-fugacity limit, the average adsorbate density in the pore field is $\\rho(\\mathbf{r}) = \\rho_b \\exp\\left(-\\beta U(\\mathbf{r})\\right)$, where $\\rho_b = \\frac{p}{k_B T}$ is the bulk ideal gas number density, $p$ is pressure, $T$ is absolute temperature, $k_B$ is the Boltzmann constant, and $\\beta = \\frac{1}{k_B T}$. The average number of adsorbed molecules in the accessible pore volume is then $\\langle N \\rangle = \\rho_b \\int_{V_{\\text{acc}}} \\exp\\left(-\\beta U(\\mathbf{r})\\right) \\, dV$. Converting molecules to moles by dividing by Avogadro's number and dividing by the adsorbent mass $m$ yields the loading in $\\text{mol}/\\text{kg}$. This defines the Henry constant $K_H$ (in $\\text{mol}/\\text{kg}/\\text{Pa}$) via $n = K_H \\, p$ with\n$$\nK_H = \\frac{1}{R T \\, m} \\int_{V_{\\text{acc}}} \\exp\\left(-\\beta U(\\mathbf{r})\\right) \\, dV,\n$$\nwhere $R$ is the Ideal Gas Constant. Using Widom Test Particle insertion, estimate the integral by Monte Carlo sampling as $ \\int_{V_{\\text{acc}}} \\exp\\left(-\\beta U\\right) \\, dV \\approx V_{\\text{acc}} \\left\\langle \\exp\\left(-\\beta U\\right) \\right\\rangle$, where the average is over uniformly sampled test particle positions in the accessible pore volume.\n\nProtocol requirements:\n- Implement Monte Carlo sampling of $N_{\\text{ins}}$ Widom test particle positions uniformly within the accessible cylindrical pore volume, using $r = R_{\\text{acc}} \\sqrt{u}$ with $u \\in [0,1]$, uniform azimuthal angle in $[0, 2\\pi)$, and uniform $z \\in [0, L_z]$. For each sample, compute $\\delta = R - r$, evaluate $U(\\delta)$, compute the Boltzmann factor $\\exp\\left(-\\beta U\\right)$, and average over all samples.\n- Compute $K_H$ for both water and ethanol using their species-specific $\\epsilon_{\\text{sf}}$ and $\\sigma_{\\text{sf}}$. Use $K_H$ to predict adsorption isotherms in the low-pressure regime by $n = K_H \\, p$ for single-component cases. For a binary mixture at low pressures, assume noninteracting adsorption and predict the total loading by $n_{\\text{tot}} = K_H^{\\text{water}} p_{\\text{water}} + K_H^{\\text{ethanol}} p_{\\text{ethanol}}$.\n- Validate predictions against provided experimental isotherm data by computing the root-mean-square error (RMSE). The RMSE for a set of $M$ pressures is defined as $\\mathrm{RMSE} = \\sqrt{\\frac{1}{M} \\sum_{j=1}^{M} \\left(n_j^{\\text{pred}} - n_j^{\\text{exp}}\\right)^2}$, where $n_j^{\\text{pred}}$ and $n_j^{\\text{exp}}$ are the predicted and experimental loadings at each pressure.\n\nUnits and numerical requirements:\n- All lengths must be provided in meters. All energies $\\epsilon_{\\text{sf}}$ must be provided in kilojoules per mole and internally converted to joules per molecule using Avogadro's number. Pressures must be provided in pascals. Temperature must be in kelvin. The final adsorption loadings must be computed in $\\text{mol}/\\text{kg}$. Angles are not required in this task.\n- Use $k_B$ in joules per kelvin, $R$ in joules per mole per kelvin, and Avogadro's number in per mole.\n\nTest suite:\nProvide results for the following four test cases, each defined by a parameter set specifying the geometry, thermodynamic conditions, and species-specific interaction parameters. For each case, compute and return a single float equal to the RMSE in $\\text{mol}/\\text{kg}$ between simulation-predicted loadings and the provided experimental loadings.\n\n- Case $1$ (single-component water, “happy path”):\n    - $T = 298$ K, $L_x = 2.0 \\times 10^{-9}$ m, $L_y = 2.0 \\times 10^{-9}$ m, $L_z = 5.0 \\times 10^{-9}$ m, $R = 6.0 \\times 10^{-10}$ m, $\\rho_{\\text{solid}} = 2200$ kg/m$^3$.\n    - Water parameters: $\\epsilon_{\\text{sf}} = 0.80$ kJ/mol, $\\sigma_{\\text{sf}} = 3.00 \\times 10^{-10}$ m.\n    - Pressures $p = [1000, 5000, 10000]$ Pa.\n    - Experimental loadings $n^{\\text{exp}} = [0.0010, 0.0060, 0.0120]$ mol/kg.\n\n- Case $2$ (single-component ethanol, stronger interaction):\n    - Same geometry and thermodynamic conditions as Case $1$.\n    - Ethanol parameters: $\\epsilon_{\\text{sf}} = 1.20$ kJ/mol, $\\sigma_{\\text{sf}} = 3.50 \\times 10^{-10}$ m.\n    - Pressures $p = [1000, 5000, 10000]$ Pa.\n    - Experimental loadings $n^{\\text{exp}} = [0.0020, 0.0090, 0.0180]$ mol/kg.\n\n- Case $3$ (binary mixture, low pressures):\n    - Same geometry and thermodynamic conditions as Case $1$.\n    - Water parameters: $\\epsilon_{\\text{sf}} = 0.80$ kJ/mol, $\\sigma_{\\text{sf}} = 3.00 \\times 10^{-10}$ m.\n    - Ethanol parameters: $\\epsilon_{\\text{sf}} = 1.20$ kJ/mol, $\\sigma_{\\text{sf}} = 3.50 \\times 10^{-10}$ m.\n    - Partial pressures: $p_{\\text{water}} = 500$ Pa, $p_{\\text{ethanol}} = 500$ Pa.\n    - Experimental total loading $n^{\\text{exp}} = [0.0100]$ mol/kg.\n\n- Case $4$ (boundary condition, zero pressure):\n    - Same geometry and thermodynamic conditions as Case $1$.\n    - Water parameters: $\\epsilon_{\\text{sf}} = 0.80$ kJ/mol, $\\sigma_{\\text{sf}} = 3.00 \\times 10^{-10}$ m.\n    - Pressure $p = [0]$ Pa.\n    - Experimental loading $n^{\\text{exp}} = [0.0000]$ mol/kg.\n\nAlgorithmic and output requirements:\n- Implement Widom Test Particle sampling with $N_{\\text{ins}} = 100000$ test particles per species per case for numerical stability.\n- Use a fixed random seed for reproducibility.\n- Your program should produce a single line of output containing the RMSE values for the four cases as a comma-separated list enclosed in square brackets, for example, $[r_1,r_2,r_3,r_4]$, where each $r_i$ is a float in $\\text{mol}/\\text{kg}$ computed as specified above.",
            "solution": "The user has provided a well-defined problem in computational chemical engineering that requires modeling adsorbate behavior in a simplified zeolite pore. The problem is scientifically sound, internally consistent, and possesses all necessary information for a unique solution. Therefore, the problem is deemed valid.\n\nThe solution will be developed based on the principles of statistical mechanics, specifically within the framework of the grand canonical ensemble, to model the adsorption of gas molecules into a porous solid at low pressures.\n\n### Theoretical Foundation: From the Grand Canonical Ensemble to Henry's Law\n\nIn the grand canonical ensemble, a system (the adsorbate molecules within the pore volume) is in thermal and chemical equilibrium with a large reservoir. The reservoir fixes the temperature $T$ and the chemical potential $\\mu$ of the adsorbate molecules. This is a suitable ensemble for describing adsorption, where the gas phase acts as the reservoir for the adsorbed phase.\n\nThe probability of finding the system with $N$ particles in a specific configuration $\\mathbf{r}^N$ is proportional to $\\exp(-\\beta E(\\mathbf{r}^N) + \\beta \\mu N)$, where $\\beta = (k_B T)^{-1}$, $k_B$ is the Boltzmann constant, and $E(\\mathbf{r}^N)$ is the configurational energy.\n\nFor a very dilute gas (low pressure or fugacity), particle-particle interactions are negligible. The energy of a single particle at position $\\mathbf{r}$ within the pore is given solely by the external potential exerted by the solid framework, $U(\\mathbf{r})$. In this limit, the local number density of adsorbate molecules at a position $\\mathbf{r}$ inside the pore is given by the Boltzmann distribution:\n$$\n\\rho(\\mathbf{r}) = \\rho_b \\exp(-\\beta U(\\mathbf{r}))\n$$\nHere, $\\rho_b$ is the number density of the bulk gas phase in equilibrium with the adsorbed phase. Assuming the bulk gas behaves ideally, its density is related to the pressure $p$ by the Ideal Gas Law: $\\rho_b = p / (k_B T)$.\n\nThe total average number of molecules adsorbed in the system, $\\langle N \\rangle$, is obtained by integrating the local density over the accessible volume of the pore, $V_{\\text{acc}}$:\n$$\n\\langle N \\rangle = \\int_{V_{\\text{acc}}} \\rho(\\mathbf{r}) \\, dV = \\frac{p}{k_B T} \\int_{V_{\\text{acc}}} \\exp(-\\beta U(\\mathbf{r})) \\, dV\n$$\nAdsorption loading, $n$, is typically reported in moles of adsorbate per kilogram of adsorbent mass, $m$. Converting $\\langle N \\rangle$ (molecules) to moles by dividing by Avogadro's number, $N_A$, we get:\n$$\nn = \\frac{\\langle N \\rangle}{N_A \\, m} = \\frac{p}{N_A k_B T \\, m} \\int_{V_{\\text{acc}}} \\exp(-\\beta U(\\mathbf{r})) \\, dV\n$$\nRecognizing that the Ideal Gas Constant is $R = N_A k_B$, we can write the expression as:\n$$\nn = \\left( \\frac{1}{R T \\, m} \\int_{V_{\\text{acc}}} \\exp(-\\beta U(\\mathbf{r})) \\, dV \\right) p\n$$\nThis equation is of the form $n = K_H \\, p$, which is Henry's Law for adsorption. It describes a linear relationship between loading and pressure that holds in the low-pressure limit. The proportionality constant, $K_H$, is the Henry constant, defined as:\n$$\nK_H = \\frac{1}{R T \\, m} \\int_{V_{\\text{acc}}} \\exp(-\\beta U(\\mathbf{r})) \\, dV\n$$\n\n### Numerical Implementation: Monte Carlo Integration\n\nThe core of the problem is to compute the integral $I = \\int_{V_{\\text{acc}}} \\exp(-\\beta U(\\mathbf{r})) \\, dV$. This can be efficiently estimated using Monte Carlo (MC) integration, a technique often referred to in this context as the Widom Test Particle (WTP) method. The integral can be rewritten as:\n$$\nI = V_{\\text{acc}} \\left[ \\frac{1}{V_{\\text{acc}}} \\int_{V_{\\text{acc}}} \\exp(-\\beta U(\\mathbf{r})) \\, dV \\right] = V_{\\text{acc}} \\langle \\exp(-\\beta U) \\rangle_{V_{\\text{acc}}}\n$$\nThe term $\\langle \\exp(-\\beta U) \\rangle_{V_{\\text{acc}}}$ is the average value of the Boltzmann factor, $\\exp(-\\beta U)$, where the average is taken over all positions $\\mathbf{r}$ uniformly sampled within the accessible volume $V_{\\text{acc}}$. The MC method approximates this average by sampling $N_{\\text{ins}}$ random particle positions and computing the sample mean:\n$$\n\\langle \\exp(-\\beta U) \\rangle_{V_{\\text{acc}}} \\approx \\frac{1}{N_{\\text{ins}}} \\sum_{i=1}^{N_{\\text{ins}}} \\exp(-\\beta U(\\mathbf{r}_i))\n$$\nwhere each $\\mathbf{r}_i$ is a randomly generated position within $V_{\\text{acc}}$.\n\n### Algorithmic Steps\n\nThe complete protocol involves the following sequential steps:\n\n1.  **Define Constants and System Parameters**: Initialize physical constants ($k_B$, $N_A$, $R$) and the test case parameters (geometry, temperature, interaction parameters, and experimental data).\n\n2.  **Calculate System-Specific Properties**:\n    a. For a given species with interaction size $\\sigma_{\\text{sf}}$, calculate the accessible pore radius: $R_{\\text{acc}} = R - \\sigma_{\\text{sf}}$. If $R_{\\text{acc}} \\leq 0$, the pore is inaccessible; $V_{\\text{acc}}=0$ and $K_H=0$.\n    b. Calculate the accessible pore volume: $V_{\\text{acc}} = \\pi R_{\\text{acc}}^2 L_z$.\n    c. Calculate the adsorbent mass $m$ from the solid volume and density: $m = \\rho_{\\text{solid}} (L_x L_y L_z - \\pi R^2 L_z)$. Note that $m$ depends on the total pore radius $R$, not $R_{\\text{acc}}$.\n\n3.  **Calculate the Henry Constant ($K_H$) via Monte Carlo**:\n    a. Convert the interaction energy $\\epsilon_{\\text{sf}}$ from kJ/mol to Joules per molecule: $\\epsilon_{\\text{sf}} [\\text{J}] = (\\epsilon_{\\text{sf}} [\\text{kJ/mol}] \\times 1000) / N_A$.\n    b. Calculate the inverse thermal energy $\\beta = 1 / (k_B T)$.\n    c. Initialize a sum for the Boltzmann factors to zero.\n    d. Perform a loop for $N_{\\text{ins}}$ iterations to sample test particle positions:\n        i. Generate a radial position $r$ by correctly sampling a uniform distribution over a disk's area: $r = R_{\\text{acc}} \\sqrt{u}$, where $u$ is a uniform random number in $[0, 1]$.\n        ii. Calculate the particle's distance to the pore wall: $\\delta = R - r$.\n        iii. Calculate the external potential $U(\\delta) = 4 \\epsilon_{\\text{sf}} [(\\sigma_{\\text{sf}}/\\delta)^{12} - (\\sigma_{\\text{sf}}/\\delta)^6]$.\n        iv. Compute the Boltzmann factor $\\exp(-\\beta U(\\delta))$ and add it to the sum.\n    e. Calculate the average Boltzmann factor: $\\langle \\exp(-\\beta U) \\rangle = (\\text{sum of Boltzmann factors}) / N_{\\text{ins}}$.\n    f. Compute the integral: $I = V_{\\text{acc}} \\times \\langle \\exp(-\\beta U) \\rangle$.\n    g. Compute the Henry constant: $K_H = I / (R T m)$.\n\n4.  **Predict Loadings and Compute RMSE**:\n    a. **Single-component cases**: For each given pressure $p_j$, predict the loading $n_j^{\\text{pred}} = K_H \\times p_j$.\n    b. **Binary mixture case**: Calculate $K_H$ for both species (water and ethanol). Predict the total loading as the sum of partial loadings, assuming non-interacting adsorption: $n_{\\text{tot}}^{\\text{pred}} = K_H^{\\text{water}} p_{\\text{water}} + K_H^{\\text{ethanol}} p_{\\text{ethanol}}$.\n    c. **Zero-pressure case**: Predictions are trivially zero.\n    d. Compute the Root-Mean-Square Error (RMSE) between the set of $M$ predicted loadings and the corresponding experimental loadings: $\\mathrm{RMSE} = \\sqrt{\\frac{1}{M} \\sum_{j=1}^{M} (n_j^{\\text{pred}} - n_j^{\\text{exp}})^2}$.\n\nThis structured approach translates the physical principles into a concrete, verifiable algorithm that can be implemented to solve the problem.",
            "answer": "```python\nimport numpy as np\n\n# Define physical constants\nKB = 1.380649e-23  # Boltzmann constant in J/K\nNA = 6.02214076e+23 # Avogadro's number in 1/mol\nR_GAS = KB * NA       # Ideal gas constant in J/(mol*K)\n\ndef calculate_kh(T, Lx, Ly, Lz, R_pore, rho_solid, eps_sf, sig_sf, N_ins, rng):\n    \"\"\"\n    Calculates the Henry constant (K_H) for a given species and pore geometry.\n\n    Args:\n        T (float): Temperature in Kelvin.\n        Lx, Ly, Lz (float): Unit cell dimensions in meters.\n        R_pore (float): Pore radius in meters.\n        rho_solid (float): Solid density in kg/m^3.\n        eps_sf (float): Solid-fluid interaction energy in kJ/mol.\n        sig_sf (float): Solid-fluid interaction size parameter in meters.\n        N_ins (int): Number of Monte Carlo samples.\n        rng (numpy.random.Generator): Random number generator instance.\n\n    Returns:\n        float: The calculated Henry constant in mol/(kg*Pa).\n    \"\"\"\n    # 1. System-specific geometric properties\n    V_cell = Lx * Ly * Lz\n    V_pore_total = np.pi * R_pore**2 * Lz\n    \n    # Adsorbent mass is based on the total void carved out\n    solid_volume = V_cell - V_pore_total\n    if solid_volume < 0:\n        # This physical situation is unlikely but handle it defensively\n        return 0.0\n\n    m_adsorbent = rho_solid * solid_volume\n\n    R_acc = R_pore - sig_sf\n    if R_acc <= 0:\n        return 0.0  # No accessible volume\n\n    V_acc = np.pi * R_acc**2 * Lz\n\n    # 2. Convert units and calculate beta\n    eps_sf_joules = (eps_sf * 1000.0) / NA  # Convert kJ/mol to J/molecule\n    beta = 1.0 / (KB * T)\n\n    # 3. Monte Carlo integration to find <exp(-beta*U)>\n    total_boltzmann_factor = 0.0\n    u_samples = rng.uniform(0, 1, N_ins)\n    r_samples = R_acc * np.sqrt(u_samples)\n\n    for r in r_samples:\n        delta = R_pore - r\n        # The sampling ensures delta >= sig_sf\n        if delta < sig_sf: \n            # This should not happen with correct sampling, but as a safe guard.\n            # Potential would be infinite, boltzmann factor is zero.\n            continue\n        \n        ratio = sig_sf / delta\n        ratio6 = ratio**6\n        ratio12 = ratio6**2\n        \n        # Lennard-Jones 12-6 potential\n        U = 4.0 * eps_sf_joules * (ratio12 - ratio6)\n        \n        # Accumulate Boltzmann factor\n        total_boltzmann_factor += np.exp(-beta * U)\n    \n    avg_boltzmann_factor = total_boltzmann_factor / N_ins\n\n    # 4. Calculate the integral and the Henry constant\n    integral_val = V_acc * avg_boltzmann_factor\n    K_H = integral_val / (R_GAS * T * m_adsorbent)\n\n    return K_H\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n    # Use a fixed random seed for reproducibility\n    rng = np.random.default_rng(42)\n    N_ins = 100000\n\n    # Common parameters for cases 1, 2, 3, 4\n    common_params = {\n        \"T\": 298.0,\n        \"Lx\": 2.0e-9,\n        \"Ly\": 2.0e-9,\n        \"Lz\": 5.0e-9,\n        \"R_pore\": 6.0e-10,\n        \"rho_solid\": 2200.0,\n    }\n\n    # Species-specific parameters\n    water_params = {\"eps_sf\": 0.80, \"sig_sf\": 3.00e-10}\n    ethanol_params = {\"eps_sf\": 1.20, \"sig_sf\": 3.50e-10}\n    \n    # Calculate Henry constants once\n    KH_water = calculate_kh(**common_params, **water_params, N_ins=N_ins, rng=rng)\n    KH_ethanol = calculate_kh(**common_params, **ethanol_params, N_ins=N_ins, rng=rng)\n\n    test_cases = [\n        # Case 1: Single-component water\n        {\n            \"pressures\": np.array([1000, 5000, 10000]),\n            \"exp_loadings\": np.array([0.0010, 0.0060, 0.0120]),\n            \"kh_values\": [KH_water]\n        },\n        # Case 2: Single-component ethanol\n        {\n            \"pressures\": np.array([1000, 5000, 10000]),\n            \"exp_loadings\": np.array([0.0020, 0.0090, 0.0180]),\n            \"kh_values\": [KH_ethanol]\n        },\n        # Case 3: Binary mixture (water, ethanol)\n        {\n            \"pressures\": np.array([500, 500]), # p_water, p_ethanol\n            \"exp_loadings\": np.array([0.0100]),\n            \"kh_values\": [KH_water, KH_ethanol]\n        },\n        # Case 4: Boundary condition (water at zero pressure)\n        {\n            \"pressures\": np.array([0]),\n            \"exp_loadings\": np.array([0.0000]),\n            \"kh_values\": [KH_water]\n        }\n    ]\n\n    results = []\n    \n    # Process Case 1\n    case1 = test_cases[0]\n    pred_loadings1 = case1[\"kh_values\"][0] * case1[\"pressures\"]\n    rmse1 = np.sqrt(np.mean((pred_loadings1 - case1[\"exp_loadings\"])**2))\n    results.append(rmse1)\n\n    # Process Case 2\n    case2 = test_cases[1]\n    pred_loadings2 = case2[\"kh_values\"][0] * case2[\"pressures\"]\n    rmse2 = np.sqrt(np.mean((pred_loadings2 - case2[\"exp_loadings\"])**2))\n    results.append(rmse2)\n\n    # Process Case 3\n    case3 = test_cases[2]\n    pred_total_loading3 = (case3[\"kh_values\"][0] * case3[\"pressures\"][0] +\n                           case3[\"kh_values\"][1] * case3[\"pressures\"][1])\n    rmse3 = np.sqrt(np.mean((pred_total_loading3 - case3[\"exp_loadings\"])**2))\n    results.append(rmse3)\n\n    # Process Case 4\n    case4 = test_cases[3]\n    pred_loadings4 = case4[\"kh_values\"][0] * case4[\"pressures\"]\n    rmse4 = np.sqrt(np.mean((pred_loadings4 - case4[\"exp_loadings\"])**2))\n    results.append(rmse4)\n\n    # Print final results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}