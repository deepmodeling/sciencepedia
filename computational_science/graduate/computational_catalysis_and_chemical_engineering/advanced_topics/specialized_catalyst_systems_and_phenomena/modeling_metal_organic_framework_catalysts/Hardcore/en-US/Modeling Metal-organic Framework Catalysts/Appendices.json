{
    "hands_on_practices": [
        {
            "introduction": "The vast scale of metal-organic frameworks presents a significant challenge for quantum chemical modeling. This exercise introduces the cluster model approach, a powerful strategy to make these calculations tractable by focusing on the local chemistry of the active site. By implementing a classical force field to compute the adsorption energy of carbon monoxide on a model of the HKUST-1 paddlewheel, you will gain hands-on experience in model construction and the fundamental energy terms that govern molecular interactions. ",
            "id": "3889300",
            "problem": "You are modeling adsorption at an Open Metal Site (OMS) in the Metal-Organic Framework (MOF) HKUST-1, focusing on a copper-based site. Starting from the Born–Oppenheimer approximation, the adsorption energy is defined by the ground-state potential energy difference between the adsorbate-bound system and the separated reference states. Construct a cluster representation of the site by replacing extended linkers with localized capping groups, and approximate the adsorption energy as the sum of pairwise interactions between the adsorbate and the cluster plus a deformation penalty associated with the capping group. Then compute the change in adsorption energy relative to a given periodic benchmark for a set of scenarios.\n\nYour program must implement the following model assumptions and constants, expressed in physically and numerically consistent units:\n\n- The cluster represents a copper paddlewheel with two copper atoms and four equatorial oxygen atoms. Place the first copper atom at $(0,0,0)$ and the second copper atom along the $z$-axis at $(0,0,d_{\\mathrm{Cu{-}Cu}})$, with $d_{\\mathrm{Cu{-}Cu}} = 2.64\\,\\mathrm{\\AA}$. The equatorial oxygens are at $(\\pm r_{\\mathrm{Cu{-}O}},0,z_{\\mathrm{eq}})$ and $(0,\\pm r_{\\mathrm{Cu{-}O}},z_{\\mathrm{eq}})$, where $r_{\\mathrm{Cu{-}O}} = 1.95\\,\\mathrm{\\AA}$ and $z_{\\mathrm{eq}} = 1.32\\,\\mathrm{\\AA}$. Two capping oxygen atoms are placed at $(x_{\\mathrm{cap}},0,z_{\\mathrm{eq}})$ and $(-x_{\\mathrm{cap}},0,z_{\\mathrm{eq}})$, with $x_{\\mathrm{cap}} = 5.00\\,\\mathrm{\\AA}$.\n- The adsorbate is carbon monoxide (CO) binding through carbon to the first copper atom. Place the carbon atom at $(r_{\\mathrm{Cu{-}C}},0,0)$ and the oxygen atom at $(r_{\\mathrm{Cu{-}C}} + \\ell_{\\mathrm{C{-}O}},0,0)$, with $\\ell_{\\mathrm{C{-}O}} = 1.128\\,\\mathrm{\\AA}$.\n- Atomic partial charges (in units of the elementary charge $e$) are: copper $+1.0$, equatorial oxygen $-0.5$, capping oxygen $-0.8$, adsorbate carbon $+0.2$, adsorbate oxygen $-0.2$.\n- Nonbonded interactions between the adsorbate and the cluster are modeled as the sum of electrostatic and van der Waals contributions. Use the Coulomb constant $k_{\\mathrm{e}} = 14.399645478\\,\\mathrm{eV}\\,\\mathrm{\\AA}\\,e^{-2}$ and Lennard–Jones parameters $(\\sigma,\\varepsilon)$ per atom type in the Lorentz–Berthelot mixing rule: $\\sigma_{ij} = (\\sigma_i + \\sigma_j)/2$ and $\\varepsilon_{ij} = \\sqrt{\\varepsilon_i \\varepsilon_j}$. Lennard–Jones energy is $U_{ij}^{\\mathrm{LJ}}(r) = 4\\varepsilon_{ij}\\left[(\\sigma_{ij}/r)^{12} - (\\sigma_{ij}/r)^6\\right]$. Electrostatic energy is $U_{ij}^{\\mathrm{Coul}}(r) = k_{\\mathrm{e}}\\,q_i q_j / r$.\n- Lennard–Jones base parameters (in $\\mathrm{\\AA}$ and $\\mathrm{eV}$): copper $\\sigma = 2.338$, $\\varepsilon = 0.010$; equatorial oxygen $\\sigma = 3.000$, $\\varepsilon = 0.008$; adsorbate carbon $\\sigma = 3.550$, $\\varepsilon = 0.003$; adsorbate oxygen $\\sigma = 3.120$, $\\varepsilon = 0.006$.\n- The capping oxygen Lennard–Jones $\\varepsilon$ depends on the capping group: formate $\\varepsilon = 0.010$, acetate $\\varepsilon = 0.012$, benzoate $\\varepsilon = 0.014$, with $\\sigma = 3.000\\,\\mathrm{\\AA}$ in all cases.\n- A deformation penalty $E_{\\mathrm{def}}$ accounts for the difference between cluster and periodic mechanical response: formate $E_{\\mathrm{def}} = 0.050\\,\\mathrm{eV}$, acetate $E_{\\mathrm{def}} = 0.080\\,\\mathrm{eV}$, benzoate $E_{\\mathrm{def}} = 0.120\\,\\mathrm{eV}$.\n\nStarting from the foundational definition of adsorption energy as a potential energy difference at zero temperature (neglecting zero-point and entropic terms), construct the cluster energy for the adsorbate-bound state using the above pairwise interactions between adsorbate and cluster atoms, add the appropriate deformation penalty, and define the adsorption energy of the cluster relative to the non-interacting reference. Given a periodic benchmark adsorption energy for each scenario, compute the change $\\Delta E_{\\mathrm{ads}} = E_{\\mathrm{ads}}^{\\mathrm{cluster}} - E_{\\mathrm{ads}}^{\\mathrm{periodic}}$.\n\nImplement your program to evaluate the following test suite, where each case is a tuple of capping group, copper–carbon distance, and periodic benchmark adsorption energy, all in the specified units:\n- Case $1$: capping group \"formate\", $r_{\\mathrm{Cu{-}C}} = 2.000\\,\\mathrm{\\AA}$, $E_{\\mathrm{ads}}^{\\mathrm{periodic}} = -0.450\\,\\mathrm{eV}$.\n- Case $2$: capping group \"acetate\", $r_{\\mathrm{Cu{-}C}} = 2.400\\,\\mathrm{\\AA}$, $E_{\\mathrm{ads}}^{\\mathrm{periodic}} = -0.300\\,\\mathrm{eV}$.\n- Case $3$: capping group \"benzoate\", $r_{\\mathrm{Cu{-}C}} = 3.500\\,\\mathrm{\\AA}$, $E_{\\mathrm{ads}}^{\\mathrm{periodic}} = -0.050\\,\\mathrm{eV}$.\n- Case $4$: capping group \"formate\", $r_{\\mathrm{Cu{-}C}} = 6.000\\,\\mathrm{\\AA}$, $E_{\\mathrm{ads}}^{\\mathrm{periodic}} = -0.010\\,\\mathrm{eV}$.\n\nYour program should output the list of $\\Delta E_{\\mathrm{ads}}$ values for the four cases in $\\mathrm{eV}$, rounded to $6$ decimals, as a single line: a comma-separated list enclosed in square brackets, for example, $[x_1,x_2,x_3,x_4]$, where each $x_i$ is a floating-point number in $\\mathrm{eV}$ with $6$ decimals.",
            "solution": "The problem requires the calculation of the change in adsorption energy, $\\Delta E_{\\mathrm{ads}}$, between a simplified cluster model and a periodic benchmark calculation for carbon monoxide ($CO$) adsorption on a copper site in the HKUST-$1$ metal-organic framework.\nThe adsorption energy within the specified cluster model, $E_{\\mathrm{ads}}^{\\mathrm{cluster}}$, is defined as the sum of the total interaction energy between the adsorbate ($CO$) and the cluster atoms, plus a deformation penalty, $E_{\\mathrm{def}}$, which depends on the choice of capping group.\n$$E_{\\mathrm{ads}}^{\\mathrm{cluster}} = E_{\\mathrm{interaction}} + E_{\\mathrm{def}}$$\nThe final quantity to be computed is the difference relative to a given periodic benchmark energy, $E_{\\mathrm{ads}}^{\\mathrm{periodic}}$:\n$$\\Delta E_{\\mathrm{ads}} = E_{\\mathrm{ads}}^{\\mathrm{cluster}} - E_{\\mathrm{ads}}^{\\mathrm{periodic}}$$\n\nThe interaction energy, $E_{\\mathrm{interaction}}$, is calculated as a sum of pairwise potentials over all adsorbate atoms $i$ and all cluster atoms $j$. Each pairwise interaction is the sum of a Coulombic electrostatic term and a Lennard-Jones ($LJ$) van der Waals term.\n$$E_{\\mathrm{interaction}} = \\sum_{i \\in \\text{adsorbate}} \\sum_{j \\in \\text{cluster}} \\left( U_{ij}^{\\mathrm{Coul}}(r_{ij}) + U_{ij}^{\\mathrm{LJ}}(r_{ij}) \\right)$$\nwhere $r_{ij}$ is the distance between atoms $i$ and $j$.\n\nThe Coulomb potential is given by:\n$$U_{ij}^{\\mathrm{Coul}}(r_{ij}) = \\frac{k_{\\mathrm{e}} q_i q_j}{r_{ij}}$$\nwith the Coulomb constant $k_{\\mathrm{e}} = 14.399645478\\,\\mathrm{eV}\\,\\mathrm{\\AA}\\,e^{-2}$, and $q_i, q_j$ being the partial charges in units of the elementary charge $e$.\n\nThe Lennard-Jones potential is given by:\n$$U_{ij}^{\\mathrm{LJ}}(r_{ij}) = 4\\varepsilon_{ij}\\left[\\left(\\frac{\\sigma_{ij}}{r_{ij}}\\right)^{12} - \\left(\\frac{\\sigma_{ij}}{r_{ij}}\\right)^{6}\\right]$$\nThe combined parameters $\\sigma_{ij}$ and $\\varepsilon_{ij}$ for a heteroatomic pair are determined using the Lorentz–Berthelot mixing rules from the base atomic parameters $\\sigma_i, \\varepsilon_i$ and $\\sigma_j, \\varepsilon_j$:\n$$\\sigma_{ij} = \\frac{\\sigma_i + \\sigma_j}{2}$$\n$$\\varepsilon_{ij} = \\sqrt{\\varepsilon_i \\varepsilon_j}$$\n\nThe computational procedure involves the following steps:\n$1$. Define the Cartesian coordinates for all atoms in the cluster and the adsorbate for each test case.\n$2$. Define the physical parameters (partial charges, Lennard-Jones $\\sigma$ and $\\varepsilon$) for each atom type.\n$3$. For each test case, iterate through all $2 \\times 8 = 16$ pairs of adsorbate-cluster atoms.\n$4$. For each pair, calculate the interatomic distance $r_{ij}$ and compute the corresponding $U_{ij}^{\\mathrm{Coul}}$ and $U_{ij}^{\\mathrm{LJ}}$.\n$5$. Sum these energies to obtain the total $E_{\\mathrm{interaction}}$.\n$6$. Add the appropriate deformation penalty $E_{\\mathrm{def}}$ to find $E_{\\mathrm{ads}}^{\\mathrm{cluster}}$.\n$7$. Subtract the provided $E_{\\mathrm{ads}}^{\\mathrm{periodic}}$ to obtain the final $\\Delta E_{\\mathrm{ads}}$.\n\nThe atomic coordinates are specified in Ångströms ($\\mathrm{\\AA}$). The cluster consists of $8$ atoms:\n-   Two copper atoms ($Cu$): $Cu_1$ at $(0,0,0)$ and $Cu_2$ at $(0,0,d_{\\mathrm{Cu{-}Cu}})$ with $d_{\\mathrm{Cu{-}Cu}} = 2.64\\,\\mathrm{\\AA}$.\n-   Four equatorial oxygen atoms ($O_{\\mathrm{eq}}$): at $(\\pm r_{\\mathrm{Cu{-}O}}, 0, z_{\\mathrm{eq}})$ and $(0, \\pm r_{\\mathrm{Cu{-}O}}, z_{\\mathrm{eq}})$, with $r_{\\mathrm{Cu{-}O}} = 1.95\\,\\mathrm{\\AA}$ and $z_{\\mathrm{eq}} = 1.32\\,\\mathrm{\\AA}$.\n-   Two capping oxygen atoms ($O_{\\mathrm{cap}}$): at $(\\pm x_{\\mathrm{cap}}, 0, z_{\\mathrm{eq}})$ with $x_{\\mathrm{cap}} = 5.00\\,\\mathrm{\\AA}$.\n\nThe adsorbate is a carbon monoxide molecule ($CO$), consisting of $2$ atoms:\n-   A carbon atom ($C$): at $(r_{\\mathrm{Cu{-}C}}, 0, 0)$.\n-   An oxygen atom ($O$): at $(r_{\\mathrm{Cu{-}C}} + \\ell_{\\mathrm{C{-}O}}, 0, 0)$, with $\\ell_{\\mathrm{C{-}O}} = 1.128\\,\\mathrm{\\AA}$.\nThe distance $r_{\\mathrm{Cu{-}C}}$ is a variable specified in each test case.\n\nThe parameters for the calculation are as follows:\nPartial charges (in units of $e$):\n-   $q_{\\mathrm{Cu}} = +1.0$\n-   $q_{\\mathrm{O,eq}} = -0.5$\n-   $q_{\\mathrm{O,cap}} = -0.8$\n-   $q_{\\mathrm{C,ads}} = +0.2$\n-   $q_{\\mathrm{O,ads}} = -0.2$\n\nLennard-Jones base parameters ($\\sigma$ in $\\mathrm{\\AA}$, $\\varepsilon$ in $\\mathrm{eV}$):\n-   Copper ($Cu$): $\\sigma = 2.338$, $\\varepsilon = 0.010$\n-   Equatorial Oxygen ($O_{\\mathrm{eq}}$): $\\sigma = 3.000$, $\\varepsilon = 0.008$\n-   Adsorbate Carbon ($C_{\\mathrm{ads}}$): $\\sigma = 3.550$, $\\varepsilon = 0.003$\n-   Adsorbate Oxygen ($O_{\\mathrm{ads}}$): $\\sigma = 3.120$, $\\varepsilon = 0.006$\n-   Capping Oxygen ($O_{\\mathrm{cap}}$): $\\sigma = 3.000$ for all groups. The $\\varepsilon$ parameter depends on the capping group.\n\nCapping group dependent parameters ($\\varepsilon$ in $\\mathrm{eV}$, $E_{\\mathrm{def}}$ in $\\mathrm{eV}$):\n-   Formate: $\\varepsilon_{\\mathrm{O,cap}} = 0.010$, $E_{\\mathrm{def}} = 0.050$\n-   Acetate: $\\varepsilon_{\\mathrm{O,cap}} = 0.012$, $E_{\\mathrm{def}} = 0.080$\n-   Benzoate: $\\varepsilon_{\\mathrm{O,cap}} = 0.014$, $E_{\\mathrm{def}} = 0.120$\n\nThe algorithm will be implemented to process the four test cases provided, calculating $\\Delta E_{\\mathrm{ads}}$ for each scenario and presenting the results in the specified format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\nclass AdsorptionEnergyModel:\n    \"\"\"\n    Models the adsorption energy of CO on a copper-based MOF cluster.\n    \"\"\"\n    # Physical constants\n    K_E = 14.399645478  # eV * Angstrom / e^2\n\n    # Cluster geometry constants\n    D_CU_CU = 2.64\n    R_CU_O = 1.95\n    Z_EQ = 1.32\n    X_CAP = 5.00\n\n    # Adsorbate geometry constant\n    L_C_O = 1.128\n\n    # Base atomic parameters (charge q, LJ sigma, LJ epsilon)\n    PARAMS = {\n        'Cu': {'q': 1.0, 'sigma': 2.338, 'eps': 0.010},\n        'O_eq': {'q': -0.5, 'sigma': 3.000, 'eps': 0.008},\n        'C_ads': {'q': 0.2, 'sigma': 3.550, 'eps': 0.003},\n        'O_ads': {'q': -0.2, 'sigma': 3.120, 'eps': 0.006},\n    }\n\n    # Capping group dependent parameters\n    CAPPING_PARAMS = {\n        'formate': {'eps_cap': 0.010, 'E_def': 0.050},\n        'acetate': {'eps_cap': 0.012, 'E_def': 0.080},\n        'benzoate': {'eps_cap': 0.014, 'E_def': 0.120},\n    }\n    O_CAP_BASE_PARAMS = {'q': -0.8, 'sigma': 3.000}\n\n    def __init__(self, capping_group, r_cu_c):\n        \"\"\"\n        Initializes the model for a specific scenario.\n\n        Args:\n            capping_group (str): The name of the capping group.\n            r_cu_c (float): The distance between the binding Cu and adsorbate C.\n        \"\"\"\n        if capping_group not in self.CAPPING_PARAMS:\n            raise ValueError(f\"Unknown capping group: {capping_group}\")\n        self.capping_group = capping_group\n        self.r_cu_c = r_cu_c\n        \n        self.cluster_atoms = self._build_cluster()\n        self.adsorbate_atoms = self._build_adsorbate()\n        self.e_def = self.CAPPING_PARAMS[self.capping_group]['E_def']\n\n    def _build_cluster(self):\n        \"\"\"Constructs the list of atoms in the cluster.\"\"\"\n        cap_params = self.CAPPING_PARAMS[self.capping_group]\n        o_cap_eps = cap_params['eps_cap']\n        \n        atoms = [\n            {'params': self.PARAMS['Cu'], 'pos': np.array([0.0, 0.0, 0.0])},\n            {'params': self.PARAMS['Cu'], 'pos': np.array([0.0, 0.0, self.D_CU_CU])},\n            {'params': self.PARAMS['O_eq'], 'pos': np.array([self.R_CU_O, 0.0, self.Z_EQ])},\n            {'params': self.PARAMS['O_eq'], 'pos': np.array([-self.R_CU_O, 0.0, self.Z_EQ])},\n            {'params': self.PARAMS['O_eq'], 'pos': np.array([0.0, self.R_CU_O, self.Z_EQ])},\n            {'params': self.PARAMS['O_eq'], 'pos': np.array([0.0, -self.R_CU_O, self.Z_EQ])},\n            {'params': {**self.O_CAP_BASE_PARAMS, 'eps': o_cap_eps}, 'pos': np.array([self.X_CAP, 0.0, self.Z_EQ])},\n            {'params': {**self.O_CAP_BASE_PARAMS, 'eps': o_cap_eps}, 'pos': np.array([-self.X_CAP, 0.0, self.Z_EQ])},\n        ]\n        return atoms\n\n    def _build_adsorbate(self):\n        \"\"\"Constructs the list of atoms in the adsorbate.\"\"\"\n        atoms = [\n            {'params': self.PARAMS['C_ads'], 'pos': np.array([self.r_cu_c, 0.0, 0.0])},\n            {'params': self.PARAMS['O_ads'], 'pos': np.array([self.r_cu_c + self.L_C_O, 0.0, 0.0])},\n        ]\n        return atoms\n\n    def _calculate_pair_interaction(self, atom1, atom2):\n        \"\"\"Calculates the Coulomb and LJ interaction energy for a pair of atoms.\"\"\"\n        p1 = atom1['params']\n        p2 = atom2['params']\n        \n        dist = np.linalg.norm(atom1['pos'] - atom2['pos'])\n        \n        # Coulomb interaction\n        u_coulomb = self.K_E * p1['q'] * p2['q'] / dist\n        \n        # Lennard-Jones interaction with Lorentz-Berthelot mixing rules\n        sigma_ij = (p1['sigma'] + p2['sigma']) / 2.0\n        eps_ij = math.sqrt(p1['eps'] * p2['eps'])\n        \n        sigma_over_r = sigma_ij / dist\n        sigma_over_r_6 = sigma_over_r**6\n        sigma_over_r_12 = sigma_over_r_6**2\n        \n        u_lj = 4.0 * eps_ij * (sigma_over_r_12 - sigma_over_r_6)\n        \n        return u_coulomb + u_lj\n\n    def calculate_cluster_adsorption_energy(self):\n        \"\"\"Calculates the total adsorption energy for the cluster model.\"\"\"\n        e_interaction = 0.0\n        for ads_atom in self.adsorbate_atoms:\n            for clu_atom in self.cluster_atoms:\n                e_interaction += self._calculate_pair_interaction(ads_atom, clu_atom)\n                \n        e_ads_cluster = e_interaction + self.e_def\n        return e_ads_cluster\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple of (capping_group, r_Cu-C, E_ads_periodic).\n    test_cases = [\n        (\"formate\", 2.000, -0.450),\n        (\"acetate\", 2.400, -0.300),\n        (\"benzoate\", 3.500, -0.050),\n        (\"formate\", 6.000, -0.010),\n    ]\n\n    results = []\n    for capping_group, r_cu_c, e_ads_periodic in test_cases:\n        # Instantiate the model for the current case\n        model = AdsorptionEnergyModel(capping_group=capping_group, r_cu_c=r_cu_c)\n        \n        # Calculate cluster adsorption energy\n        e_ads_cluster = model.calculate_cluster_adsorption_energy()\n        \n        # Calculate the change relative to the periodic benchmark\n        delta_e_ads = e_ads_cluster - e_ads_periodic\n        \n        results.append(delta_e_ads)\n\n    # Format the output string as required\n    output_str = f\"[{','.join([f'{val:.6f}' for val in results])}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "The accuracy of Density Functional Theory (DFT) calculations for catalysis hinges on the choice of the exchange-correlation functional. This practice moves beyond ad-hoc selections by guiding you through a quantitative and principled protocol to identify the optimal functional for a given catalytic system. By defining a risk function that weighs errors in both structure and kinetics, you will learn a robust methodology for validating computational methods, a critical skill for producing high-fidelity research. ",
            "id": "3889354",
            "problem": "You are to design and implement a program that, for a set of metal–organic framework catalyst scenarios, quantifies how predicted metal–ligand bond lengths and activation barriers depend on the choice of density functional (Generalized Gradient Approximation Perdew–Burke–Ernzerhof (PBE), Hybrid PBE0, and Strongly Constrained and Appropriately Normed (SCAN)), and selects a functional according to a principled protocol grounded in Transition State Theory and error-minimization. The program must compute function-specific errors relative to provided reference values, sensitivity metrics across functionals, and apply a selection rule that prioritizes kinetic fidelity while ensuring structural realism. All mathematics must follow from fundamental definitions and well-tested formulas.\n\nFundamental base and definitions to be used:\n- Transition State Theory: the macroscopic rate constant $k$ for a reaction step at absolute temperature $T$ is\n$$\nk \\;=\\; \\frac{k_{\\mathrm{B}} T}{h} \\,\\exp\\!\\left(-\\frac{\\Delta G^{\\ddagger}}{R T}\\right),\n$$\nwhere $k_{\\mathrm{B}}$ is the Boltzmann constant, $h$ is the Planck constant, $R$ is the ideal gas constant, and $\\Delta G^{\\ddagger}$ is the activation free energy barrier.\n- The kinetic error for a given functional is measured by the absolute deviation in the natural logarithm of the rate constant relative to a reference,\n$$\n\\varepsilon_{k} \\;=\\; \\left|\\ln\\!\\left(\\frac{k_{\\mathrm{func}}}{k_{\\mathrm{ref}}}\\right)\\right|.\n$$\n- The structural error for a predicted bond length $r_{\\mathrm{func}}$ relative to a reference $r_{\\mathrm{ref}}$ is the relative deviation,\n$$\n\\varepsilon_{r} \\;=\\; \\frac{\\left|r_{\\mathrm{func}} - r_{\\mathrm{ref}}\\right|}{r_{\\mathrm{ref}}}.\n$$\n- Sensitivity of a property across functionals is quantified by the coefficient of variation (standard deviation divided by mean) across the three functionals for that property:\n$$\nS_{r} \\;=\\; \\frac{\\mathrm{std}\\!\\left(\\{r_{i}\\}\\right)}{\\mathrm{mean}\\!\\left(\\{r_{i}\\}\\right)}, \n\\quad\nS_{E} \\;=\\; \\frac{\\mathrm{std}\\!\\left(\\{E^{\\ddagger}_{i}\\}\\right)}{\\mathrm{mean}\\!\\left(\\{E^{\\ddagger}_{i}\\}\\right)}.\n$$\n- A weighted risk functional to rank density functionals for catalysis is defined as\n$$\nJ \\;=\\; w_{r}\\,\\varepsilon_{r} \\;+\\; w_{k}\\,\\varepsilon_{k},\n$$\nwhere $w_{r}$ and $w_{k}$ are nonnegative weights satisfying $w_{r} + w_{k} = 1$. To reflect the exponential sensitivity of reaction rates to barrier height and the typically tighter experimental tolerance on activation free energies compared to bond lengths, use $w_{r} = 0.3$ and $w_{k} = 0.7$.\n\nSelection protocol to implement:\n- For each test case and each functional in $\\{ \\mathrm{PBE}, \\mathrm{PBE0}, \\mathrm{SCAN} \\}$, compute $J$ and select the functional with the smallest $J$.\n- If two or more functionals have $J$ values equal within a tolerance $\\delta = 10^{-6}$, break ties by the smallest $\\varepsilon_{k}$, then by the smallest $\\varepsilon_{r}$, and finally by the smallest functional index (mapping: $\\mathrm{PBE} \\rightarrow 0$, $\\mathrm{PBE0} \\rightarrow 1$, $\\mathrm{SCAN} \\rightarrow 2$).\n- Compute global sensitivity metrics $S_{r}$ and $S_{E}$ per test case. Define robustness tolerances $S_{r}^{\\mathrm{tol}} = 0.02$ and $S_{E}^{\\mathrm{tol}} = 0.05$. A case is flagged robust if $S_{r} \\leq S_{r}^{\\mathrm{tol}}$ and $S_{E} \\leq S_{E}^{\\mathrm{tol}}$; otherwise it is flagged non-robust.\n\nUnits and numerical requirements:\n- Activation barriers $\\Delta G^{\\ddagger}$ are provided in kilojoules per mole; convert to joules per mole by multiplying by $1000$ before use in the Transition State Theory formula.\n- Bond lengths are provided in angstroms and used directly in the structural error formula.\n- Absolute temperature $T$ is provided in kelvin and used directly.\n- The computed rate constants $k$ must be expressed in $\\mathrm{s}^{-1}$. The program will output natural logarithms $\\ln(k)$, which are dimensionless.\n- All floating-point results in the final output must be rounded to $4$ decimal places.\n\nTest suite:\nEach test case consists of the following tuple of parameters: lists of three bond lengths $(r_{\\mathrm{PBE}}, r_{\\mathrm{PBE0}}, r_{\\mathrm{SCAN}})$ in angstroms, reference bond length $r_{\\mathrm{ref}}$ in angstroms, lists of three activation barriers $(E^{\\ddagger}_{\\mathrm{PBE}}, E^{\\ddagger}_{\\mathrm{PBE0}}, E^{\\ddagger}_{\\mathrm{SCAN}})$ in kilojoules per mole, reference activation barrier $E^{\\ddagger}_{\\mathrm{ref}}$ in kilojoules per mole, and absolute temperature $T$ in kelvin.\n\nProvide the following four test cases:\n- Case $1$: $(r_{\\mathrm{PBE}}, r_{\\mathrm{PBE0}}, r_{\\mathrm{SCAN}}) = (1.95, 1.90, 1.92)$, $r_{\\mathrm{ref}} = 1.91$, $(E^{\\ddagger}_{\\mathrm{PBE}}, E^{\\ddagger}_{\\mathrm{PBE0}}, E^{\\ddagger}_{\\mathrm{SCAN}}) = (60, 75, 68)$, $E^{\\ddagger}_{\\mathrm{ref}} = 70$, $T = 298$.\n- Case $2$: $(r_{\\mathrm{PBE}}, r_{\\mathrm{PBE0}}, r_{\\mathrm{SCAN}}) = (2.02, 1.98, 2.00)$, $r_{\\mathrm{ref}} = 2.00$, $(E^{\\ddagger}_{\\mathrm{PBE}}, E^{\\ddagger}_{\\mathrm{PBE0}}, E^{\\ddagger}_{\\mathrm{SCAN}}) = (105, 100, 103)$, $E^{\\ddagger}_{\\mathrm{ref}} = 102$, $T = 298$.\n- Case $3$: $(r_{\\mathrm{PBE}}, r_{\\mathrm{PBE0}}, r_{\\mathrm{SCAN}}) = (2.10, 2.05, 2.07)$, $r_{\\mathrm{ref}} = 2.06$, $(E^{\\ddagger}_{\\mathrm{PBE}}, E^{\\ddagger}_{\\mathrm{PBE0}}, E^{\\ddagger}_{\\mathrm{SCAN}}) = (5, 8, 6)$, $E^{\\ddagger}_{\\mathrm{ref}} = 7$, $T = 298$.\n- Case $4$: $(r_{\\mathrm{PBE}}, r_{\\mathrm{PBE0}}, r_{\\mathrm{SCAN}}) = (1.80, 1.76, 1.78)$, $r_{\\mathrm{ref}} = 1.77$, $(E^{\\ddagger}_{\\mathrm{PBE}}, E^{\\ddagger}_{\\mathrm{PBE0}}, E^{\\ddagger}_{\\mathrm{SCAN}}) = (150, 145, 160)$, $E^{\\ddagger}_{\\mathrm{ref}} = 152$, $T = 450$.\n\nRequired final output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, output a list of five items:\n$[$best\\_functional\\_index$, S_{r}$, $S_{E}$, $\\ln(k_{\\mathrm{best}})$, robustness\\_flag$]$, with floating-point values rounded to $4$ decimal places and the robustness flag as a boolean. The overall output thus is a single list containing four such lists, in the order of the test cases. For example, an output line will have the form\n$[\\,[\\cdots],\\,[\\cdots],\\,[\\cdots],\\,[\\cdots]\\,]$.",
            "solution": "The problem requires the design and implementation of a computational protocol to select an optimal density functional from a given set—Perdew–Burke–Ernzerhof (PBE), a hybrid functional (PBE0), and Strongly Constrained and Appropriately Normed (SCAN)—for modeling metal-organic framework catalysts. The selection is based on a principled, quantitative evaluation of each functional's accuracy in predicting key structural (metal-ligand bond length) and kinetic (activation energy barrier) properties relative to reference values.\n\nThe solution proceeds by applying fundamental principles of chemical kinetics and statistical error analysis to each test case.\n\nFirst, we define the necessary physical and mathematical framework. The connection between the activation free energy barrier, $\\Delta G^{\\ddagger}$, and the macroscopic reaction rate constant, $k$, is given by the Eyring equation from Transition State Theory:\n$$\nk \\;=\\; \\frac{k_{\\mathrm{B}} T}{h} \\,\\exp\\!\\left(-\\frac{\\Delta G^{\\ddagger}}{R T}\\right)\n$$\nwhere $k_{\\mathrm{B}}$ is the Boltzmann constant ($1.380649 \\times 10^{-23}$ J/K), $h$ is the Planck constant ($6.62607015 \\times 10^{-34}$ J·s), $R$ is the ideal gas constant ($8.314462618$ J·mol⁻¹·K⁻¹), and $T$ is the absolute temperature. For computational convenience, we work with the natural logarithm of the rate constant:\n$$\n\\ln(k) \\;=\\; \\ln\\left(\\frac{k_{\\mathrm{B}} T}{h}\\right) - \\frac{\\Delta G^{\\ddagger}}{R T}\n$$\nThe problem provides activation barriers in units of kilojoules per mole (kJ/mol), which must be converted to joules per mole (J/mol) by multiplying by $1000$ to maintain consistency with the units of the gas constant $R$.\n\nThe performance of each functional is quantified using two error metrics. The structural error, $\\varepsilon_{r}$, measures the relative deviation of the predicted bond length, $r_{\\mathrm{func}}$, from a reference value, $r_{\\mathrm{ref}}$:\n$$\n\\varepsilon_{r} \\;=\\; \\frac{\\left|r_{\\mathrm{func}} - r_{\\mathrm{ref}}\\right|}{r_{\\mathrm{ref}}}\n$$\nThe kinetic error, $\\varepsilon_{k}$, measures the deviation in the predicted rate constant. By using the properties of logarithms, it can be expressed as the absolute difference between the logarithmic rate constants:\n$$\n\\varepsilon_{k} \\;=\\; \\left|\\ln\\!\\left(\\frac{k_{\\mathrm{func}}}{k_{\\mathrm{ref}}}\\right)\\right| = \\left|\\ln(k_{\\mathrm{func}}) - \\ln(k_{\\mathrm{ref}})\\right|\n$$\n\nTo balance the importance of structural and kinetic fidelity, a weighted risk functional, $J$, is defined as:\n$$\nJ \\;=\\; w_{r}\\,\\varepsilon_{r} \\;+\\; w_{k}\\,\\varepsilon_{k}\n$$\nThe weights are specified as $w_{r} = 0.3$ and $w_{k} = 0.7$, prioritizing accuracy in kinetics, which is appropriate as reaction rates depend exponentially on the activation barrier.\n\nThe computational procedure for each test case is as follows:\n1.  For each of the three functionals (PBE, PBE0, SCAN), calculate the structural error $\\varepsilon_{r}$ and the kinetic error $\\varepsilon_{k}$ using the provided functional-specific and reference data. This involves first computing $\\ln(k_{\\mathrm{func}})$ and $\\ln(k_{\\mathrm{ref}})$ from their respective activation barriers and the given temperature.\n2.  For each functional, evaluate the risk functional $J$.\n3.  Select the optimal functional based on the defined protocol:\n    a.  Identify the minimum value of $J$ among the three functionals, $J_{\\min}$.\n    b.  Form a candidate set of all functionals whose $J$ value is within a tolerance $\\delta = 10^{-6}$ of $J_{\\min}$ (i.e., $|J - J_{\\min}| \\le \\delta$).\n    c.  If this set contains a single functional, it is the chosen one.\n    d.  If there is a tie, the candidate set is refined by selecting the functional(s) with the minimum kinetic error, $\\varepsilon_{k}$.\n    e.  If a tie persists, it is resolved by selecting the functional(s) with the minimum structural error, $\\varepsilon_{r}$.\n    f.  As a final, definitive tie-breaker, the functional with the lowest index (PBE:$0$, PBE0:$1$, SCAN:$2$) is chosen.\n4.  Calculate the sensitivity metrics for the test case, which measure the dispersion of predictions across the three functionals. The sensitivities for bond length, $S_{r}$, and activation energy, $S_{E}$, are the coefficients of variation for the respective sets of values:\n    $$\n    S_{r} \\;=\\; \\frac{\\mathrm{std}\\!\\left(\\{r_{i}\\}\\right)}{\\mathrm{mean}\\!\\left(\\{r_{i}\\}\\right)}, \\quad S_{E} \\;=\\; \\frac{\\mathrm{std}\\!\\left(\\{E^{\\ddagger}_{i}\\}\\right)}{\\mathrm{mean}\\!\\left(\\{E^{\\ddagger}_{i}\\}\\right)}\n    $$\n    where the standard deviation is the population standard deviation.\n5.  Determine the robustness of the predictions for the test case. The case is flagged as robust if both sensitivity metrics are within their defined tolerances: $S_{r} \\leq S_{r}^{\\mathrm{tol}} = 0.02$ and $S_{E} \\leq S_{E}^{\\mathrm{tol}} = 0.05$. Otherwise, it is flagged as non-robust.\n6.  Finally, for each test case, the results are compiled into a list containing the index of the best functional, the calculated sensitivities $S_r$ and $S_E$, the natural logarithm of the rate constant for the best functional $\\ln(k_{\\mathrm{best}})$, and a boolean robustness flag. All floating-point values are rounded to four decimal places. This process is repeated for all provided test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import constants\n\ndef solve():\n    \"\"\"\n    Solves the computational catalysis problem for a set of test cases.\n    \"\"\"\n    # Define physical constants from scipy.constants\n    k_B = constants.k  # Boltzmann constant in J/K\n    h = constants.h    # Planck constant in J·s\n    R = constants.R    # Ideal gas constant in J/(mol·K)\n\n    # Define problem-specific parameters\n    FUNCTIONALS = ['PBE', 'PBE0', 'SCAN']\n    w_r = 0.3\n    w_k = 0.7\n    delta = 1e-6\n    S_r_tol = 0.02\n    S_E_tol = 0.05\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {'r_funcs': (1.95, 1.90, 1.92), 'r_ref': 1.91,\n         'E_funcs': (60, 75, 68), 'E_ref': 70, 'T': 298},\n        # Case 2\n        {'r_funcs': (2.02, 1.98, 2.00), 'r_ref': 2.00,\n         'E_funcs': (105, 100, 103), 'E_ref': 102, 'T': 298},\n        # Case 3\n        {'r_funcs': (2.10, 2.05, 2.07), 'r_ref': 2.06,\n         'E_funcs': (5, 8, 6), 'E_ref': 7, 'T': 298},\n        # Case 4\n        {'r_funcs': (1.80, 1.76, 1.78), 'r_ref': 1.77,\n         'E_funcs': (150, 145, 160), 'E_ref': 152, 'T': 450},\n    ]\n\n    def calculate_log_k(E_barrier_kj_mol, T):\n        \"\"\"\n        Calculates the natural logarithm of the TST rate constant.\n        Args:\n            E_barrier_kj_mol (float): Activation barrier in kJ/mol.\n            T (float): Absolute temperature in Kelvin.\n        Returns:\n            float: Natural logarithm of the rate constant, ln(k).\n        \"\"\"\n        E_barrier_j_mol = E_barrier_kj_mol * 1000.0  # Convert kJ/mol to J/mol\n        log_prefactor = np.log(k_B * T / h)\n        log_k = log_prefactor - E_barrier_j_mol / (R * T)\n        return log_k\n\n    all_results = []\n    for case in test_cases:\n        r_funcs = np.array(case['r_funcs'])\n        r_ref = case['r_ref']\n        E_funcs = np.array(case['E_funcs'])\n        E_ref = case['E_ref']\n        T = case['T']\n\n        # Step 4  5: Calculate sensitivity and robustness\n        S_r = np.std(r_funcs) / np.mean(r_funcs)\n        S_E = np.std(E_funcs) / np.mean(E_funcs)\n        robustness_flag = (S_r = S_r_tol) and (S_E = S_E_tol)\n\n        # Calculate reference log k\n        log_k_ref = calculate_log_k(E_ref, T)\n\n        # Calculate metrics for each functional\n        functional_metrics = []\n        log_k_values = []\n        for i in range(len(FUNCTIONALS)):\n            r_func = r_funcs[i]\n            E_func = E_funcs[i]\n\n            # Structural error\n            eps_r = abs(r_func - r_ref) / r_ref\n\n            # Kinetic error\n            log_k_func = calculate_log_k(E_func, T)\n            log_k_values.append(log_k_func)\n            eps_k = abs(log_k_func - log_k_ref)\n\n            # Risk functional\n            J = w_r * eps_r + w_k * eps_k\n            \n            functional_metrics.append({\n                'index': i,\n                'J': J,\n                'eps_k': eps_k,\n                'eps_r': eps_r\n            })\n\n        # Step 3: Select best functional using the protocol\n        # Find minimum J\n        min_J = min(m['J'] for m in functional_metrics)\n        \n        # Tie-breaking logic\n        # 3.b: Candidates based on J and delta\n        candidates = [m for m in functional_metrics if abs(m['J'] - min_J) = delta]\n\n        # 3.d: Tie-break with eps_k\n        if len(candidates)  1:\n            min_eps_k = min(m['eps_k'] for m in candidates)\n            candidates = [m for m in candidates if m['eps_k'] == min_eps_k]\n\n        # 3.e: Tie-break with eps_r\n        if len(candidates)  1:\n            min_eps_r = min(m['eps_r'] for m in candidates)\n            candidates = [m for m in candidates if m['eps_r'] == min_eps_r]\n\n        # 3.f: Final tie-break with index\n        if len(candidates)  1:\n            candidates.sort(key=lambda m: m['index'])\n\n        best_functional = candidates[0]\n        best_functional_index = best_functional['index']\n        log_k_best = log_k_values[best_functional_index]\n\n        # Step 6: Assemble results for the case\n        case_result = [\n            best_functional_index,\n            round(S_r, 4),\n            round(S_E, 4),\n            round(log_k_best, 4),\n            robustness_flag\n        ]\n        all_results.append(case_result)\n\n    # Final print statement in the exact required format\n    # Using str() for booleans to get 'True'/'False'\n    print(f\"[{','.join([str(r).replace(' ', '') for r in all_results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The ultimate goal of computational catalysis is to transform numerical data into fundamental chemical insights. This practice focuses on uncovering such insights by exploring the Brønsted–Evans–Polanyi (BEP) principle, which links activation energies to reaction energies. You will use linear regression to fit a BEP relationship for a series of reactions and then model deviations from this trend, testing the hypothesis that the unique nanoporous environment of the MOF imparts a quantifiable confinement effect on the reaction barrier. ",
            "id": "3889362",
            "problem": "You are asked to implement a program that, for a set of hydrogenation steps occurring inside a nickel-containing metal-organic framework (Nickel Metal-Organic Framework (Ni-MOF)), infers a linear mapping between the reaction energy and the activation energy and then quantifies deviations arising from pore confinement effects. The underlying physical basis starts from Transition State Theory (TST), which relates rate constants to activation free energies, and from the observation in catalysis that activation barriers for related elementary steps often vary approximately linearly with reaction energetics. Confinement in porous catalysts can modify the free energy of the activated complex, primarily by reducing accessible translational entropy. Use only the provided data and the fundamental principles described below to construct a reproducible and numerically testable analysis.\n\nFundamental base for the derivation:\n- Assume a linear relation between the activation energy and the reaction energy, parameterized by an unknown slope and intercept to be inferred from data. Let the reaction energy be denoted by $\\,\\Delta E\\,$ and the activation energy (barrier) be denoted by $\\,\\Delta E^{\\ddagger}\\,$, both expressed in $\\,\\mathrm{eV}\\,$. This linear mapping is a commonly observed empirical behavior for homologous reactions and can be motivated by a combination of Energy Landscape considerations and the Brønsted–Evans–Polanyi idea.\n- Adopt the Transition State Theory relation for rate constants $\\,k\\,$, where $\\,k = \\dfrac{k_{\\mathrm{B}} T}{h} \\exp\\!\\left(-\\dfrac{\\Delta G^{\\ddagger}}{k_{\\mathrm{B}} T}\\right)\\,$, with $\\,\\Delta G^{\\ddagger}\\,$ the activation free energy, $\\,k_{\\mathrm{B}}\\,$ the Boltzmann constant, $\\,T\\,$ the temperature, and $\\,h\\,$ Planck’s constant. While rates are not directly used here, this provides the thermodynamic framing for linking energetic barriers and free energy changes.\n- To model confinement effects on the barrier, approximate the change in free energy of the activated complex due to reduced accessible volume as $\\,\\Delta G_{\\mathrm{conf}}(T) \\approx k_{\\mathrm{B}} T \\ln\\!\\left(\\dfrac{V_{\\mathrm{ref}}}{V_{\\mathrm{pore}}}\\right)\\,$, where $\\,V_{\\mathrm{pore}}\\,$ is the accessible pore volume for the complex and $\\,V_{\\mathrm{ref}}\\,$ is a reference volume. Assuming $\\,V_{\\mathrm{pore}} \\propto r^{3}\\,$ for a characteristic pore radius $\\,r\\,$, one obtains $\\,\\Delta G_{\\mathrm{conf}}(T) \\approx 3\\,k_{\\mathrm{B}} T \\ln\\!\\left(\\dfrac{r_{\\mathrm{ref}}}{r}\\right)\\,$. Express $\\,\\Delta G_{\\mathrm{conf}}\\,$ in $\\,\\mathrm{eV}\\,$ per event using the Boltzmann constant in $\\,\\mathrm{eV}\\,\\mathrm{K}^{-1}\\,$.\n\nData and units:\n- Temperature $\\,T = 300\\,\\mathrm{K}\\,$.\n- Reference pore radius $\\,r_{\\mathrm{ref}} = 1.6\\,\\mathrm{nm}\\,$.\n- Energies are in $\\,\\mathrm{eV}\\,$, radii are in $\\,\\mathrm{nm}\\,$, and temperature is in $\\,\\mathrm{K}\\,$.\n- The dataset consists of $\\,10\\,$ hydrogenation steps, each provided as a tuple $\\,(\\Delta E,\\ \\Delta E^{\\ddagger},\\ r)\\,$:\n  1. $\\,(-0.85,\\ 0.561,\\ 1.7)\\,$\n  2. $\\,(-0.42,\\ 0.695,\\ 1.6)\\,$\n  3. $\\,(\\phantom{-}0.00,\\ 0.842,\\ 1.8)\\,$\n  4. $\\,(\\phantom{-}0.25,\\ 0.949,\\ 1.5)\\,$\n  5. $\\,(-0.60,\\ 0.670,\\ 1.2)\\,$\n  6. $\\,(\\phantom{-}0.10,\\ 0.913,\\ 1.2)\\,$\n  7. $\\,(-1.05,\\ 0.556,\\ 0.8)\\,$\n  8. $\\,(\\phantom{-}0.35,\\ 1.016,\\ 0.8)\\,$\n  9. $\\,(-0.20,\\ 0.871,\\ 0.6)\\,$\n  10. $\\,(\\phantom{-}0.00,\\ 0.921,\\ 0.6)\\,$\n\nComputational tasks:\n- Fit the linear mapping between $\\,\\Delta E\\,$ and $\\,\\Delta E^{\\ddagger}\\,$ using Ordinary Least Squares (OLS) on a training subset consisting of the low-confinement data points with $\\,r \\geq 1.5\\,\\mathrm{nm}\\,$. Infer the slope $\\,\\alpha\\,$ and intercept $\\,\\beta\\,$ of the linear model from this training subset only.\n- Compute the training Root Mean Square Error (RMSE) in $\\,\\mathrm{eV}\\,$ for the OLS fit.\n- For each data point in the full set, compute the observed deviation $\\,\\delta_{\\mathrm{obs}} = \\Delta E^{\\ddagger} - (\\alpha\\,\\Delta E + \\beta)\\,$ in $\\,\\mathrm{eV}\\,$.\n- For each data point, compute the entropic confinement penalty $\\,\\Delta G_{\\mathrm{conf}} = 3\\,k_{\\mathrm{B}} T \\ln\\!\\left(\\dfrac{r_{\\mathrm{ref}}}{r}\\right)\\,$ in $\\,\\mathrm{eV}\\,$, with $\\,k_{\\mathrm{B}} = 8.617333262\\times 10^{-5}\\,\\mathrm{eV}\\,\\mathrm{K}^{-1}\\,$.\n- Define a high-confinement subset as those with $\\,r \\leq 0.8\\,\\mathrm{nm}\\,$ and, over this subset, compute the mean absolute discrepancy $\\,\\overline{|d|}\\,$ where $\\,d = \\delta_{\\mathrm{obs}} - \\Delta G_{\\mathrm{conf}}\\,$, in $\\,\\mathrm{eV}\\,$.\n- Identify the boundary test case with $\\,\\Delta E = 0.00\\,\\mathrm{eV}\\,$ and $\\,r = 0.6\\,\\mathrm{nm}\\,$, and compute its discrepancy $\\,d\\,$ as defined above, in $\\,\\mathrm{eV}\\,$.\n- Determine whether at least half of the high-confinement cases satisfy $\\,|d| \\leq 0.03\\,\\mathrm{eV}\\,$. Report this as a boolean.\n\nTest suite and output specification:\n- Use the dataset provided above as the complete test suite.\n- Your program must produce a single line of output containing a comma-separated Python list in the following order and units:\n  - The fitted slope $\\,\\alpha\\,$ (float, unitless since it is $\\,\\mathrm{eV}/\\mathrm{eV}\\,$).\n  - The fitted intercept $\\,\\beta\\,$ (float, in $\\,\\mathrm{eV}\\,$).\n  - The training RMSE (float, in $\\,\\mathrm{eV}\\,$).\n  - The mean absolute discrepancy $\\,\\overline{|d|}\\,$ over the high-confinement subset (float, in $\\,\\mathrm{eV}\\,$).\n  - The boundary case discrepancy $\\,d\\,$ for $\\,\\Delta E = 0.00\\,\\mathrm{eV}\\,$ and $\\,r=0.6\\,\\mathrm{nm}\\,$ (float, in $\\,\\mathrm{eV}\\,$).\n  - The boolean described above.\n- Example of the required final output format: $\\,\\left[\\alpha,\\beta,\\mathrm{RMSE},\\overline{|d|},d,\\mathrm{boolean}\\right]\\,$ as a single line, such as $\\,\\left[0.35,0.85,0.01,0.02,-0.005,\\mathrm{True}\\right]\\,$. Your output must be the actual computed values from the specified dataset, not the example.",
            "solution": "The problem is assessed to be valid as it is scientifically grounded in the principles of computational catalysis, well-posed with a complete and consistent set of data and definitions, and objective in its formulation. The task requires a multi-step numerical analysis involving linear regression and the application of a physical model for confinement effects. We will proceed with a step-by-step solution.\n\nThe analysis is based on the Brønsted–Evans–Polanyi (BEP) principle, which posits a linear relationship between the activation energy, $\\Delta E^{\\ddagger}$, and the reaction energy, $\\Delta E$, for a series of homologous chemical reactions. This empirical relationship is expressed as:\n$$\n\\Delta E^{\\ddagger} = \\alpha \\Delta E + \\beta\n$$\nwhere $\\alpha$ is the slope and $\\beta$ is the intercept. These parameters represent intrinsic catalytic properties, independent of environmental factors like pore confinement.\n\nThe provided dataset consists of $10$ tuples, each representing a hydrogenation step with its reaction energy $\\Delta E$ (in $\\mathrm{eV}$), activation energy $\\Delta E^{\\ddagger}$ (in $\\mathrm{eV}$), and a characteristic pore radius $r$ (in $\\mathrm{nm}$).\n\n**Step 1: Inferring the Intrinsic Linear Scaling Relationship**\n\nFirst, we must determine the intrinsic BEP parameters, $\\alpha$ and $\\beta$. These are inferred from a subset of the data where confinement effects are minimal. The problem defines this \"training subset\" as data points with a pore radius $r \\geq 1.5\\,\\mathrm{nm}$. Examining the dataset, we identify the following $4$ points for this subset:\n1. $(\\Delta E_1, \\Delta E^{\\ddagger}_1, r_1) = (-0.85, 0.561, 1.7)$\n2. $(\\Delta E_2, \\Delta E^{\\ddagger}_2, r_2) = (-0.42, 0.695, 1.6)$\n3. $(\\Delta E_3, \\Delta E^{\\ddagger}_3, r_3) = (0.00, 0.842, 1.8)$\n4. $(\\Delta E_4, \\Delta E^{\\ddagger}_4, r_4) = (0.25, 0.949, 1.5)$\n\nWe perform an Ordinary Least Squares (OLS) regression on the $(\\Delta E, \\Delta E^{\\ddagger})$ pairs from this training set. Let $\\boldsymbol{x} = \\{\\Delta E_i\\}$ and $\\boldsymbol{y} = \\{\\Delta E^{\\ddagger}_i\\}$ for $i \\in \\{1, 2, 3, 4\\}$. The slope $\\alpha$ and intercept $\\beta$ are computed to minimize the sum of squared residuals. Using standard linear regression formulas, we find:\n$\\alpha \\approx 0.35002852$\n$\\beta \\approx 0.85100779$\n\n**Step 2: Quantifying the Fit Quality**\n\nTo assess the quality of the linear fit on the training data, we calculate the Root Mean Square Error (RMSE). The RMSE is defined as the square root of the mean of the squared differences between the observed activation energies, $\\Delta E^{\\ddagger}_i$, and the values predicted by the linear model, $\\Delta E^{\\ddagger}_{\\text{pred}, i} = \\alpha \\Delta E_i + \\beta$.\n$$\n\\text{RMSE} = \\sqrt{\\frac{1}{N_{\\text{train}}} \\sum_{i=1}^{N_{\\text{train}}} (\\Delta E^{\\ddagger}_i - (\\alpha \\Delta E_i + \\beta))^2}\n$$\nFor the $4$ training points, the calculation yields:\n$\\text{RMSE} \\approx 0.00396440\\,\\mathrm{eV}$\n\n**Step 3: Modeling Confinement Effects**\n\nConfinement within the nanopores of the Metal-Organic Framework (MOF) is hypothesized to alter the activation energy. This is primarily an entropic effect. The transition state, being a specific configuration, loses more accessible volume (and thus translational entropy) in a tighter pore compared to the reactants. This destabilizes the transition state, effectively increasing the activation barrier. The problem provides a model for this free energy penalty, $\\Delta G_{\\mathrm{conf}}$, based on a simplified particle-in-a-box argument:\n$$\n\\Delta G_{\\mathrm{conf}} = 3 k_{\\mathrm{B}} T \\ln\\left(\\frac{r_{\\mathrm{ref}}}{r}\\right)\n$$\nwhere $k_{\\mathrm{B}} = 8.617333262 \\times 10^{-5}\\,\\mathrm{eV}\\,\\mathrm{K}^{-1}$ is the Boltzmann constant, $T = 300\\,\\mathrm{K}$ is the temperature, and $r_{\\mathrm{ref}} = 1.6\\,\\mathrm{nm}$ is a reference pore radius. At the given temperature, the thermal energy is $k_{\\mathrm{B}} T \\approx 0.025852\\,\\mathrm{eV}$.\n\nThe total activation barrier in a confined environment, $\\Delta E^{\\ddagger}_{\\text{obs}}$, is the sum of the intrinsic electronic barrier and the confinement penalty:\n$$\n\\Delta E^{\\ddagger}_{\\text{obs}} \\approx (\\alpha \\Delta E + \\beta) + \\Delta G_{\\mathrm{conf}}\n$$\nThis model predicts that the observed deviation from the intrinsic BEP line, $\\delta_{\\mathrm{obs}} = \\Delta E^{\\ddagger}_{\\text{obs}} - (\\alpha \\Delta E + \\beta)$, should be approximately equal to the confinement penalty, $\\Delta G_{\\mathrm{conf}}$.\n\n**Step 4: Evaluating the Confinement Model**\n\nWe now test this hypothesis. For every point in the full dataset, we compute the observed deviation, $\\delta_{\\mathrm{obs}, j}$, and the theoretical confinement penalty, $\\Delta G_{\\mathrm{conf}, j}$. The discrepancy, $d_j = \\delta_{\\mathrm{obs}, j} - \\Delta G_{\\mathrm{conf}, j}$, measures how much our combined BEP and confinement model deviates from the observed data.\n\nWe focus on the \"high-confinement subset\", defined by $r \\leq 0.8\\,\\mathrm{nm}$. This subset includes the following $4$ data points:\n7. $(\\Delta E_7, \\Delta E^{\\ddagger}_7, r_7) = (-1.05, 0.556, 0.8)$\n8. $(\\Delta E_8, \\Delta E^{\\ddagger}_8, r_8) = (0.35, 1.016, 0.8)$\n9. $(\\Delta E_9, \\Delta E^{\\ddagger}_9, r_9) = (-0.20, 0.871, 0.6)$\n10. $(\\Delta E_{10}, \\Delta E^{\\ddagger}_{10}, r_{10}) = (0.00, 0.921, 0.6)$\n\nFor these points, we calculate the discrepancies $d_7, d_8, d_9, d_{10}$. We then compute the mean absolute discrepancy, $\\overline{|d|}$, for this subset:\n$$\n\\overline{|d|} = \\frac{1}{N_{\\text{high}}} \\sum_{j \\in \\{7,8,9,10\\}} |d_j|\n$$\nThe calculation yields $\\overline{|d|} \\approx 0.01689239\\,\\mathrm{eV}$. This small value suggests that the confinement model provides a reasonable correction to the intrinsic BEP relationship.\n\n**Step 5: Analysis of Specific Cases**\n\nThe problem asks for two specific analyses on this high-confinement subset.\n\nFirst, we identify the boundary test case with $\\Delta E = 0.00\\,\\mathrm{eV}$ and $r = 0.6\\,\\mathrm{nm}$, which corresponds to data point $10$. We compute its specific discrepancy, $d_{10}$:\nFor this point:\n$\\delta_{\\mathrm{obs}, 10} = 0.921 - (\\alpha \\cdot 0.00 + \\beta) \\approx 0.921 - 0.85100779 = 0.06999221\\,\\mathrm{eV}$\n$\\Delta G_{\\mathrm{conf}, 10} = 3 k_{\\mathrm{B}} T \\ln(1.6 / 0.6) \\approx 0.07604543\\,\\mathrm{eV}$\n$d_{10} = \\delta_{\\mathrm{obs}, 10} - \\Delta G_{\\mathrm{conf}, 10} \\approx 0.06999221 - 0.07604543 = -0.00605322\\,\\mathrm{eV}$\n\nSecond, we must determine if at least half of the cases in the high-confinement subset satisfy the condition $|d_j| \\leq 0.03\\,\\mathrm{eV}$. The high-confinement subset has $N_{\\text{high}} = 4$ points, so we must check if at least $2$ points meet the criterion. The calculated absolute discrepancies are:\n$|d_7| \\approx 0.013583\\,\\mathrm{eV}$\n$|d_8| \\approx 0.041880\\,\\mathrm{eV}$\n$|d_9| \\approx 0.006053\\,\\mathrm{eV}$\n$|d_{10}| \\approx 0.006053\\,\\mathrm{eV}$\n\nThree of these values ($|d_7|$, $|d_9|$, and $|d_{10}|$) are less than or equal to $0.03\\,\\mathrm{eV}$. Since $3 \\geq 2$, the condition is met, and the result is True.\n\n**Summary of Results**\n\nThe final computed values for the specified tasks are:\n- Slope $\\alpha \\approx 0.35002852$\n- Intercept $\\beta \\approx 0.85100779\\,\\mathrm{eV}$\n- Training RMSE $\\approx 0.00396440\\,\\mathrm{eV}$\n- Mean absolute discrepancy $\\overline{|d|} \\approx 0.01689239\\,\\mathrm{eV}$\n- Boundary case discrepancy $d_{10} \\approx -0.00605322\\,\\mathrm{eV}$\n- Boolean check: True",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational catalysis problem by performing a linear fit,\n    calculating deviations, and evaluating a confinement model.\n    \"\"\"\n    # --- Givens ---\n    # Constants\n    T = 300.0  # K\n    R_REF = 1.6  # nm\n    K_B = 8.617333262e-5  # eV/K\n\n    # Dataset: (delta_E, delta_E_ddagger, r)\n    dataset = [\n        (-0.85, 0.561, 1.7),\n        (-0.42, 0.695, 1.6),\n        (0.00, 0.842, 1.8),\n        (0.25, 0.949, 1.5),\n        (-0.60, 0.670, 1.2),\n        (0.10, 0.913, 1.2),\n        (-1.05, 0.556, 0.8),\n        (0.35, 1.016, 0.8),\n        (-0.20, 0.871, 0.6),\n        (0.00, 0.921, 0.6),\n    ]\n\n    # --- Step 1: Linear Fit on Training Subset ---\n    # Training subset is defined by r = 1.5 nm\n    training_set = [p for p in dataset if p[2] = 1.5]\n    \n    # Extract reaction energies (x) and activation energies (y)\n    train_delta_E = np.array([p[0] for p in training_set])\n    train_delta_E_ddagger = np.array([p[1] for p in training_set])\n\n    # Perform Ordinary Least Squares (OLS) regression using np.polyfit for a degree 1 polynomial\n    alpha, beta = np.polyfit(train_delta_E, train_delta_E_ddagger, 1)\n\n    # --- Step 2: Training RMSE ---\n    # Predict activation energies for the training set\n    predicted_train_delta_E_ddagger = alpha * train_delta_E + beta\n    \n    # Calculate the Root Mean Square Error (RMSE)\n    training_rmse = np.sqrt(np.mean((train_delta_E_ddagger - predicted_train_delta_E_ddagger)**2))\n\n    # --- Step 3  4: Deviations and Confinement Penalties for All Points ---\n    discrepancies = []\n    \n    for point in dataset:\n        delta_E, delta_E_ddagger, r = point\n\n        # Observed deviation from the BEP line\n        delta_obs = delta_E_ddagger - (alpha * delta_E + beta)\n\n        # Entropic confinement penalty\n        # The case r = r_ref would lead to log(1) = 0.\n        # To avoid log(negative) if r  r_ref, we check, although data prevents this.\n        if r  0:\n            delta_G_conf = 3 * K_B * T * np.log(R_REF / r)\n        else:\n            delta_G_conf = np.inf \n\n        # Discrepancy between observation and theory\n        d = delta_obs - delta_G_conf\n        discrepancies.append(d)\n\n    # --- Step 5: Mean Absolute Discrepancy for High-Confinement Subset ---\n    # High-confinement subset is defined by r = 0.8 nm\n    high_confinement_indices = [i for i, p in enumerate(dataset) if p[2] = 0.8]\n    high_confinement_discrepancies = np.array([discrepancies[i] for i in high_confinement_indices])\n    \n    mean_abs_discrepancy = np.mean(np.abs(high_confinement_discrepancies))\n\n    # --- Step 6: Boundary Case Discrepancy ---\n    # Boundary case: delta_E = 0.00 eV and r = 0.6 nm\n    boundary_case_d = 0.0\n    for i, point in enumerate(dataset):\n        if point[0] == 0.00 and point[2] == 0.6:\n            boundary_case_d = discrepancies[i]\n            break\n\n    # --- Step 7: Boolean Check ---\n    # Check if at least half of high-confinement cases satisfy |d| = 0.03 eV\n    count_satisfying_condition = np.sum(np.abs(high_confinement_discrepancies) = 0.03)\n    is_condition_met = count_satisfying_condition = (len(high_confinement_indices) / 2.0)\n\n    # --- Final Output Assembly ---\n    results = [\n        alpha,\n        beta,\n        training_rmse,\n        mean_abs_discrepancy,\n        boundary_case_d,\n        is_condition_met,\n    ]\n\n    # Print in the specified format\n    print(f\"[{results[0]},{results[1]},{results[2]},{results[3]},{results[4]},{results[5]}]\")\n\nsolve()\n```"
        }
    ]
}