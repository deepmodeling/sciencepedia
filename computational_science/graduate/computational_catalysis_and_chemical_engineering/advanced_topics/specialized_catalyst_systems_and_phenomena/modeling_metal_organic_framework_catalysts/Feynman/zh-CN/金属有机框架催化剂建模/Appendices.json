{
    "hands_on_practices": [
        {
            "introduction": "化学反应的可行性和速率最终由自由能的变化决定。本实践从统计力学的第一性原理出发，指导您将微观分子特性（如振动频率和转动惯量）与宏观热力学量（如焓 $H$、熵 $S$ 和Gibbs自由能 $G$）联系起来。通过计算金属有机框架（MOF）催化剂活化过程中脱去配位溶剂分子的自由能变化，您将掌握如何应用平动、转动和振动配分函数来量化复杂化学过程的热力学驱动力 。",
            "id": "3889328",
            "problem": "您正在通过移除配位的溶剂配体来模拟金属有机框架（MOF）催化剂节点的活化过程。从一个完全溶剂化的节点开始，通过移除指定数量的配体来构建一个活化模型，并量化去溶剂化自由能的变化。使用基于配分函数的统计力学框架，以及亥姆霍兹自由能和吉布斯自由能的热力学定义，推导并计算去溶剂化自由能（记为 $\\Delta G$）的焓和熵的贡献。从第一性原理出发：玻尔兹曼分布、独立自由度的配分函数、内能和熵的定义，以及热力学势之间的关系。将结合配体的平动和转动自由度视为受约束的（可忽略），并通过一个电子能量差参数来捕捉 MOF 节点活化时电子能量的变化。对于每种配体，使用在标准压力下理想气体的科学合理近似来模拟自由配体的平动、转动和振动贡献。除了从这些基本基础推导出的公式外，不要假设任何快捷公式。移除 $m$ 个配体使系统在指定温度和压力下，从一个溶剂化节点转变为一个活化节点加上 $m$ 个自由配体。目标量是每摩尔 MOF 节点的总 $\\Delta G$，以 $\\mathrm{kJ/mol}$ 为单位表示，并四舍五入到三位小数。\n\n物理模型假设：\n- 对在压力 $p$ 和温度 $T$ 下的自由配体的平动贡献使用理想气体近似。\n- 将配体转动处理为由主转动惯量和转动对称数指定的非线性刚性转子。\n- 使用谐振子近似处理配体振动，并使用提供的波数。\n- 将 MOF 结合配体的振动模式处理为具有不同波数的谐振子，代表在结合状态下的受约束振动。\n- 由于强约束，忽略结合配体的平动和转动贡献；明确包含结合态的振动贡献。\n- 通过提供的每摩尔 MOF 节点的电子能量差参数，捕捉 MOF 节点活化时所有剩余的电子能量变化。\n\n每个测试用例的输入为：\n- 温度 $T$ (单位 $\\mathrm{K}$)。\n- 压力 $p$ (单位 $\\mathrm{Pa}$)。\n- 移除的配体数量 $m$ (无单位整数)。\n- 配体摩尔质量 $M$ (单位 $\\mathrm{kg/mol}$)。\n- 转动对称数 $\\sigma$ (无单位整数)。\n- 主转动惯量 $I_A$, $I_B$, $I_C$ (单位 $\\mathrm{kg \\cdot m^2}$，每个分子)。\n- 自由配体振动波数 $\\{\\tilde{\\nu}_i^{\\mathrm{free}}\\}$ (单位 $\\mathrm{cm^{-1}}$)。\n- 结合配体振动波数 $\\{\\tilde{\\nu}_j^{\\mathrm{bound}}\\}$ (单位 $\\mathrm{cm^{-1}}$)。\n- 活化时的电子能量差 $\\Delta E_{\\mathrm{elect}}$，单位 $\\mathrm{kJ/mol}$，定义为 MOF 节点的电子能量变化，加上理想模式处理未能捕捉到的任何由配体脱离产生的电子贡献。\n\n您的程序必须为每个测试用例计算：\n- 总焓变 $\\Delta H$，单位 $\\mathrm{kJ/mol}$，其来自于：$m$ 个自由配体的平动、转动和振动贡献，减去结合配体的振动贡献，再加上 $\\Delta E_{\\mathrm{elect}}$。\n- 总熵变 $\\Delta S$，单位 $\\mathrm{J/(mol \\cdot K)}$，其来自于：$m$ 个自由配体的平动、转动和振动贡献，减去结合配体的振动贡献。\n- 去溶剂化自由能 $\\Delta G = \\Delta H - T \\Delta S$，单位 $\\mathrm{kJ/mol}$。\n\n单位要求：\n- 以 $\\mathrm{kJ/mol}$ 为单位表示最终的去溶剂化自由能 $\\Delta G$，并四舍五入到三位小数。\n\n不需要角度单位。\n\n测试套件：\n为以下参数集提供结果。所有数值均以上述指定的明确单位给出。\n1. 情况 A (正常路径): $T = 298.15$, $p = 1.01325 \\times 10^5$, $m = 2$, $M = 0.07309$, $\\sigma = 1$, $I_A = 1.5 \\times 10^{-46}$, $I_B = 2.8 \\times 10^{-46}$, $I_C = 4.1 \\times 10^{-46}$, $\\{\\tilde{\\nu}_i^{\\mathrm{free}}\\} = [300, 480, 990, 1500, 1650, 2950, 3000, 3100]$, $\\{\\tilde{\\nu}_j^{\\mathrm{bound}}\\} = [320, 520, 1040, 1520, 1700, 2960, 3010, 3120]$, $\\Delta E_{\\mathrm{elect}} = 40.0$.\n2. 情况 B (小而受约束的配体): $T = 298.15$, $p = 1.01325 \\times 10^5$, $m = 1$, $M = 0.01801528$, $\\sigma = 2$, $I_A = 1.93 \\times 10^{-47}$, $I_B = 1.95 \\times 10^{-47}$, $I_C = 3.85 \\times 10^{-47}$, $\\{\\tilde{\\nu}_i^{\\mathrm{free}}\\} = [1595, 3657, 3756]$, $\\{\\tilde{\\nu}_j^{\\mathrm{bound}}\\} = [1700, 3500, 3600]$, $\\Delta E_{\\mathrm{elect}} = 10.0$.\n3. 情况 C (更高温度): $T = 600.0$, $p = 1.01325 \\times 10^5$, $m = 3$, $M = 0.03204$, $\\sigma = 1$, $I_A = 3.0 \\times 10^{-47}$, $I_B = 5.5 \\times 10^{-47}$, $I_C = 8.4 \\times 10^{-47}$, $\\{\\tilde{\\nu}_i^{\\mathrm{free}}\\} = [1033, 1470, 2840, 2920, 2960, 3000, 3650]$, $\\{\\tilde{\\nu}_j^{\\mathrm{bound}}\\} = [1050, 1500, 2850, 2930, 2970, 3010, 3600]$, $\\Delta E_{\\mathrm{elect}} = 20.0$.\n4. 情况 D (边界，无移除): $T = 298.15$, $p = 1.01325 \\times 10^5$, $m = 0$, $M = 0.05000$, $\\sigma = 1$, $I_A = 2.0 \\times 10^{-46}$, $I_B = 3.0 \\times 10^{-46}$, $I_C = 4.0 \\times 10^{-46}$, $\\{\\tilde{\\nu}_i^{\\mathrm{free}}\\} = [500, 1000]$, $\\{\\tilde{\\nu}_j^{\\mathrm{bound}}\\} = [500, 1000]$, $\\Delta E_{\\mathrm{elect}} = 0.0$.\n\n最终输出格式：\n您的程序应生成一行输出，其中包含四个测试用例的去溶剂化自由能，形式为方括号括起来的逗号分隔列表，例如 $\\texttt{[x_1,x_2,x_3,x_4]}$，其中每个 $x_i$ 是一个浮点数，代表以 $\\mathrm{kJ/mol}$ 为单位并四舍五入到三位小数的 $\\Delta G$。",
            "solution": "我们从统计力学和宏观热力学开始。去溶剂化过程将在温度 $T$ 和压力 $p$ 下，将一个带有结合配体的溶剂化节点转变为一个活化节点加上 $m$ 个自由配体。每摩尔 MOF 节点的去溶剂化自由能定义为 $\\Delta G = \\Delta H - T \\Delta S$，其中 $\\Delta H$ 是焓变，$\\Delta S$ 是熵变。\n\n我们通过调用配分函数的可分离性，对来自电子、平动、转动和振动自由度的独立贡献进行建模。我们将结合配体的平动和转动模式视为受约束的（可忽略），但我们包含它们的振动贡献。活化时未被简单模式处理明确捕捉的电子能量变化，被归总为每摩尔的电子能量差 $\\Delta E_{\\mathrm{elect}}$。\n\n基本关系式：\n- 吉布斯自由能为 $G = H - T S$。\n- 焓为 $H = U + p V$。\n- 对于具有配分函数 $q$ 的可分离自由度，熵可以通过摩尔配分函数 $Q$ 计算得出：$S = R \\left( \\ln Q + T \\left( \\frac{\\partial \\ln Q}{\\partial T} \\right)_p \\right)$，而内能可通过 $U = R T^2 \\left( \\frac{\\partial \\ln Q}{\\partial T} \\right)_V$ 计算。我们使用从这些基础推导出的理想平动、转动和谐振子振动模式的标准结果。\n\n在温度 $T$ 和压力 $p$ 下，理想气体（每摩尔配体）的平动贡献：\n- 平动配分函数为 $q_{\\mathrm{trans}} = \\left( \\frac{2 \\pi m k_B T}{h^2} \\right)^{3/2} V$，其中对于在压力 $p$ 下的一摩尔气体，$V = \\frac{R T}{p}$。这里 $m$ 是每个分子的质量，$k_B$ 是玻尔兹曼常数，$h$ 是普朗克常数。\n- 摩尔平动熵为 $S_{\\mathrm{trans}} = R \\left[ \\ln \\left( \\left( \\frac{2 \\pi m k_B T}{h^2} \\right)^{3/2} \\frac{k_B T}{p} \\right) + \\frac{5}{2} \\right]$。\n- 平动内能为 $U_{\\mathrm{trans}} = \\frac{3}{2} R T$，因此平动焓为 $H_{\\mathrm{trans}} = U_{\\mathrm{trans}} + p V = \\frac{3}{2} R T + R T = \\frac{5}{2} R T$。\n\n非线性刚性转子（每摩尔配体）的转动贡献：\n- 摩尔转动配分函数为 $q_{\\mathrm{rot}} = \\frac{\\sqrt{\\pi}}{\\sigma} \\left( \\frac{8 \\pi^2 k_B T}{h^2} \\right)^{3/2} \\sqrt{ I_A I_B I_C }$，其中 $\\sigma$ 是转动对称数，$I_A$, $I_B$, $I_C$ 是每个分子的主转动惯量。\n- 摩尔转动熵为 $S_{\\mathrm{rot}} = R \\left[ \\ln \\left( q_{\\mathrm{rot}} \\right) + \\frac{3}{2} \\right]$。\n- 摩尔转动内能为 $U_{\\mathrm{rot}} = \\frac{3}{2} R T$，因此 $H_{\\mathrm{rot}} = U_{\\mathrm{rot}}$。\n\n谐振子近似下的振动贡献：\n- 对于波数为 $\\tilde{\\nu}$ 的振动模式，特征能量为 $h c \\tilde{\\nu}$，其中 $c$ 是光速，$\\tilde{\\nu}$ 的单位是长度的倒数。\n- 定义 $x = \\frac{h c \\tilde{\\nu}}{k_B T}$，其中 $\\tilde{\\nu}$ 通过乘以 $100$ 从 $\\mathrm{cm^{-1}}$ 转换为 $\\mathrm{m^{-1}}$。\n- 单个模式的摩尔振动熵为 $S_{\\mathrm{vib, mode}} = R \\left[ \\frac{x}{\\exp(x) - 1} - \\ln \\left( 1 - \\exp(-x) \\right) \\right]$。\n- 单个模式的摩尔振动焓为 $H_{\\mathrm{vib, mode}} = \\frac{1}{2} N_A h c \\tilde{\\nu} + N_A \\frac{h c \\tilde{\\nu}}{\\exp(x) - 1}$，其中 $N_A$ 是阿伏伽德罗常数。第一项是零点能，第二项是热振动能。对所有模式求和得到 $S_{\\mathrm{vib}}$ 和 $H_{\\mathrm{vib}}$。\n\n结合配体与自由配体：\n- 对于结合配体，由于约束，平动和转动贡献被忽略。振动贡献根据提供的结合态波数 $\\{\\tilde{\\nu}_j^{\\mathrm{bound}}\\}$ 计算。\n- 对于自由配体，平动、转动和振动贡献根据提供的自由态波数 $\\{\\tilde{\\nu}_i^{\\mathrm{free}}\\}$、质量 $m$（每个分子）、转动惯量 $I_A$, $I_B$, $I_C$ 和 $\\sigma$ 计算。\n\n电子能量差：\n- 参数 $\\Delta E_{\\mathrm{elect}}$ 代表 MOF 节点的摩尔电子能量变化，加上理想平动、转动和振动贡献未能描述的任何配体脱离的剩余能量效应。\n\n移除 $m$ 个配体的总变化：\n- 单个配体的差值为 $\\Delta H_{\\mathrm{lig}} = H_{\\mathrm{trans}} + H_{\\mathrm{rot}} + H_{\\mathrm{vib}}^{\\mathrm{free}} - H_{\\mathrm{vib}}^{\\mathrm{bound}}$ 和 $\\Delta S_{\\mathrm{lig}} = S_{\\mathrm{trans}} + S_{\\mathrm{rot}} + S_{\\mathrm{vib}}^{\\mathrm{free}} - S_{\\mathrm{vib}}^{\\mathrm{bound}}$。\n- 总焓变为 $\\Delta H_{\\mathrm{total}} = \\Delta E_{\\mathrm{elect}} + m \\Delta H_{\\mathrm{lig}}$。\n- 总熵变为 $\\Delta S_{\\mathrm{total}} = m \\Delta S_{\\mathrm{lig}}$。\n- 去溶剂化自由能为 $\\Delta G = \\Delta H_{\\mathrm{total}} - T \\Delta S_{\\mathrm{total}}$。\n\n算法步骤：\n1. 对每个测试用例，解析 $T$, $p$, $m$, $M$, $\\sigma$, $I_A$, $I_B$, $I_C$, $\\{\\tilde{\\nu}_i^{\\mathrm{free}}\\}$, $\\{\\tilde{\\nu}_j^{\\mathrm{bound}}\\}$ 和 $\\Delta E_{\\mathrm{elect}}$。\n2. 将配体的摩尔质量 $M$ 转换为单个分子的质量 $m_{\\mathrm{mol}} = \\frac{M}{N_A}$。\n3. 使用理想气体关系式在 $T$、$p$ 和 $m_{\\mathrm{mol}}$下计算 $S_{\\mathrm{trans}}$ 和 $H_{\\mathrm{trans}}$。\n4. 使用 $I_A$, $I_B$, $I_C$, $\\sigma$ 和 $T$ 计算 $q_{\\mathrm{rot}}$，然后计算 $S_{\\mathrm{rot}}$ 和 $H_{\\mathrm{rot}}$。\n5. 对于提供的自由振动波数，将每个 $\\tilde{\\nu}$ 从 $\\mathrm{cm^{-1}}$ 转换为 $\\mathrm{m^{-1}}$ 并计算 $x$，然后求和得到 $S_{\\mathrm{vib}}^{\\mathrm{free}}$ 和 $H_{\\mathrm{vib}}^{\\mathrm{free}}$。\n6. 对于提供的结合振动波数，重复上述步骤以计算 $S_{\\mathrm{vib}}^{\\mathrm{bound}}$ 和 $H_{\\mathrm{vib}}^{\\mathrm{bound}}$。\n7. 构建单个配体的 $\\Delta H_{\\mathrm{lig}}$ 和 $\\Delta S_{\\mathrm{lig}}$，然后针对指定的 $m$ 构建 $\\Delta H_{\\mathrm{total}}$ 和 $\\Delta S_{\\mathrm{total}}$。\n8. 计算 $\\Delta G = \\Delta H_{\\mathrm{total}} - T \\Delta S_{\\mathrm{total}}$。\n9. 将 $\\Delta G$ 转换为 $\\mathrm{kJ/mol}$ 并四舍五入到三位小数。\n10. 汇总所有测试用例的结果，并将其以方括号括起来的单个逗号分隔列表形式打印。\n\n科学真实性与边界情况：\n- 情况 A 代表移除两个具有多个高频振动模式的中等重量配体，这会产生显著的平动和转动熵增益，以及一个正的电子焓成本。\n- 情况 B 代表移除一个具有非平凡对称数 $\\sigma$、适中转动惯量和三个振动模式的小配体，突显了对称性对转动熵的作用。\n- 情况 C 探讨了温度 $T$ 升高的情况，测试了振动热激发以及增加的平动和转动焓改变自由能平衡的区域。\n- 情况 D 断言 $m = 0$，由于没有配体被移除且 $\\Delta E_{\\mathrm{elect}} = 0$，根据构造得出 $\\Delta G = 0$。\n\n该实现直接编码了推导出的公式和常数，确保了在所提供的测试套件中的单位一致性和数值稳定性。",
            "answer": "```python\n# Python 3.12 program to compute desolvation free energy for MOF activation cases\n# using statistical mechanical contributions for translational, rotational, and vibrational modes.\n# Allowed libraries: numpy 1.23.5, scipy 1.11.4 (not used)\nimport numpy as np\n\n# Physical constants (SI units)\nk_B = 1.380649e-23            # Boltzmann constant, J/K\nh = 6.62607015e-34            # Planck constant, J*s\nNA = 6.02214076e23            # Avogadro constant, 1/mol\nR = NA * k_B                  # Ideal gas constant, J/(mol*K)\nc = 299792458.0               # Speed of light, m/s\npi = np.pi\n\ndef vibrational_contributions(wavenumbers_cm, T):\n    \"\"\"\n    Compute molar vibrational entropy (J/mol/K) and enthalpy (J/mol)\n    in the harmonic oscillator approximation for a set of wavenumbers (cm^-1) at temperature T (K).\n    \"\"\"\n    S_vib = 0.0\n    H_vib = 0.0\n    if not wavenumbers_cm:\n        return S_vib, H_vib\n    for nu_cm in wavenumbers_cm:\n        # convert from cm^-1 to m^-1\n        nu_m = nu_cm * 100.0\n        # characteristic energy\n        eps = h * c * nu_m  # J per molecule\n        x = eps / (k_B * T)\n        # vibrational entropy per mole\n        # S = R * [ x/(exp(x)-1) - ln(1 - exp(-x)) ]\n        # guard against numerical issues for large x by using stable computations\n        expx = np.exp(x)\n        # Avoid overflow: when x is large, expx is large; formulas still fine with floats\n        if np.isinf(expx):\n            S_mode = 0.0\n        else:\n            S_mode = R * (x / (expx - 1.0) - np.log(1.0 - np.exp(-x)))\n        S_vib += S_mode\n        # vibrational enthalpy per mole: zero-point + thermal\n        # H = NA * [ 0.5*eps + eps/(exp(x) - 1) ]\n        if np.isinf(expx):\n            H_mode = NA * (0.5 * eps)\n        else:\n            H_mode = NA * (0.5 * eps + eps / (expx - 1.0))\n        H_vib += H_mode\n    return S_vib, H_vib\n\ndef translational_contributions(M_molar, T, p):\n    \"\"\"\n    Compute molar translational entropy (J/mol/K) and enthalpy (J/mol)\n    for an ideal gas at temperature T (K) and pressure p (Pa).\n    M_molar: ligand molar mass in kg/mol.\n    \"\"\"\n    m_per_molecule = M_molar / NA  # kg\n    # S_trans = R [ ln( (2*pi*m*k*T/h^2)^(3/2) * (k*T/p) ) + 5/2 ]\n    factor = (2.0 * pi * m_per_molecule * k_B * T) / (h ** 2)\n    S_trans = R * (np.log((factor ** 1.5) * (k_B * T / p)) + 2.5)\n    # H_trans = 5/2 R T\n    H_trans = 2.5 * R * T\n    return S_trans, H_trans\n\ndef rotational_contributions_nonlinear(Ia, Ib, Ic, sigma, T):\n    \"\"\"\n    Compute molar rotational entropy (J/mol/K) and enthalpy (J/mol)\n    for a nonlinear rigid rotor with principal moments Ia, Ib, Ic (kg*m^2 per molecule),\n    symmetry number sigma (dimensionless), at temperature T (K).\n    \"\"\"\n    # q_rot = sqrt(pi)/sigma * (8*pi^2*k*T/h^2)^(3/2) * sqrt(Ia*Ib*Ic)\n    pref = np.sqrt(pi) / sigma\n    factor = (8.0 * (pi ** 2) * k_B * T) / (h ** 2)\n    q_rot = pref * (factor ** 1.5) * np.sqrt(Ia * Ib * Ic)\n    # S_rot = R [ ln(q_rot) + 3/2 ]\n    S_rot = R * (np.log(q_rot) + 1.5)\n    # U_rot = 3/2 R T; H_rot = U_rot\n    H_rot = 1.5 * R * T\n    return S_rot, H_rot\n\ndef compute_delta_G_case(case):\n    \"\"\"\n    Compute desolvation free energy ΔG (kJ/mol) for a given case dictionary.\n    \"\"\"\n    T = case[\"T\"]\n    p = case[\"p\"]\n    m_count = case[\"m\"]\n    \n    if m_count == 0:\n        return 0.0\n\n    M_molar = case[\"M\"]\n    sigma = case[\"sigma\"]\n    Ia = case[\"I_A\"]\n    Ib = case[\"I_B\"]\n    Ic = case[\"I_C\"]\n    freqs_free = case[\"freqs_free_cm\"]\n    freqs_bound = case[\"freqs_bound_cm\"]\n    delta_elect_kJ = case[\"delta_elect_kJ\"]\n\n    # Contributions for free ligand\n    S_trans, H_trans = translational_contributions(M_molar, T, p)\n    S_rot, H_rot = rotational_contributions_nonlinear(Ia, Ib, Ic, sigma, T)\n    S_vib_free, H_vib_free = vibrational_contributions(freqs_free, T)\n\n    # Contributions for bound ligand (vibrational only)\n    S_vib_bound, H_vib_bound = vibrational_contributions(freqs_bound, T)\n\n    # Per-ligand differences\n    delta_H_lig_J = H_trans + H_rot + H_vib_free - H_vib_bound\n    delta_S_lig_J_per_K = S_trans + S_rot + S_vib_free - S_vib_bound\n\n    # Total changes\n    delta_H_total_J = (delta_elect_kJ * 1000.0) + m_count * delta_H_lig_J\n    delta_S_total_J_per_K = m_count * delta_S_lig_J_per_K\n\n    # ΔG = ΔH - T ΔS\n    delta_G_J = delta_H_total_J - T * delta_S_total_J_per_K\n    delta_G_kJ = delta_G_J / 1000.0\n\n    return delta_G_kJ\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"T\": 298.15,\n            \"p\": 1.01325e5,\n            \"m\": 2,\n            \"M\": 0.07309,\n            \"sigma\": 1,\n            \"I_A\": 1.5e-46,\n            \"I_B\": 2.8e-46,\n            \"I_C\": 4.1e-46,\n            \"freqs_free_cm\": [300, 480, 990, 1500, 1650, 2950, 3000, 3100],\n            \"freqs_bound_cm\": [320, 520, 1040, 1520, 1700, 2960, 3010, 3120],\n            \"delta_elect_kJ\": 40.0,\n        },\n        {\n            \"T\": 298.15,\n            \"p\": 1.01325e5,\n            \"m\": 1,\n            \"M\": 0.01801528,\n            \"sigma\": 2,\n            \"I_A\": 1.93e-47,\n            \"I_B\": 1.95e-47,\n            \"I_C\": 3.85e-47,\n            \"freqs_free_cm\": [1595, 3657, 3756],\n            \"freqs_bound_cm\": [1700, 3500, 3600],\n            \"delta_elect_kJ\": 10.0,\n        },\n        {\n            \"T\": 600.0,\n            \"p\": 1.01325e5,\n            \"m\": 3,\n            \"M\": 0.03204,\n            \"sigma\": 1,\n            \"I_A\": 3.0e-47,\n            \"I_B\": 5.5e-47,\n            \"I_C\": 8.4e-47,\n            \"freqs_free_cm\": [1033, 1470, 2840, 2920, 2960, 3000, 3650],\n            \"freqs_bound_cm\": [1050, 1500, 2850, 2930, 2970, 3010, 3600],\n            \"delta_elect_kJ\": 20.0,\n        },\n        {\n            \"T\": 298.15,\n            \"p\": 1.01325e5,\n            \"m\": 0,\n            \"M\": 0.05000,\n            \"sigma\": 1,\n            \"I_A\": 2.0e-46,\n            \"I_B\": 3.0e-46,\n            \"I_C\": 4.0e-46,\n            \"freqs_free_cm\": [500, 1000],\n            \"freqs_bound_cm\": [500, 1000],\n            \"delta_elect_kJ\": 0.0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        delta_G_kJ = compute_delta_G_case(case)\n        # Round to three decimal places\n        results.append(f\"{delta_G_kJ:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在理解了系统的整体热力学稳定性后，我们将焦点转向催化过程中的一个关键基元步骤：分子吸附。由于对整个周期性MOF结构进行精确的量子化学计算可能成本高昂，簇模型（cluster model）提供了一种高效且广泛应用的近似方法。本实践将引导您构建一个代表活性位点局部化学环境的有限原子簇，并使用简化的力场（包括库仑相互作用和Lennard-Jones势）来计算吸附能 。这个练习将帮助您深入理解非共价相互作用的本质，并权衡计算精度与效率。",
            "id": "3889300",
            "problem": "您正在对金属有机框架（MOF）HKUST-1中的一个开放金属位点（OMS）上的吸附进行建模，重点研究一个铜基位点。从玻恩-奥本海默近似出发，吸附能定义为吸附物结合体系与分离的参考态之间的基态势能差。通过用局域化的封端基团替换延伸的连接体，构建该位点的簇模型表示，并将吸附能近似为吸附物与簇之间的对相互作用之和，再加上与封端基团相关的形变罚项。然后，针对一系列情景，计算相对于给定周期性基准的吸附能变化。\n\n您的程序必须实现以下模型假设和常数，并以物理上和数值上一致的单位表示：\n\n- 该簇模型代表一个铜桨轮结构，包含两个铜原子和四个赤道氧原子。将第一个铜原子置于 $(0,0,0)$，第二个铜原子沿 $z$ 轴置于 $(0,0,d_{\\mathrm{Cu{-}Cu}})$，其中 $d_{\\mathrm{Cu{-}Cu}} = 2.64\\,\\mathrm{\\AA}$。赤道氧原子位于 $(\\pm r_{\\mathrm{Cu{-}O}},0,z_{\\mathrm{eq}})$ 和 $(0,\\pm r_{\\mathrm{Cu{-}O}},z_{\\mathrm{eq}})$，其中 $r_{\\mathrm{Cu{-}O}} = 1.95\\,\\mathrm{\\AA}$ 且 $z_{\\mathrm{eq}} = 1.32\\,\\mathrm{\\AA}$。两个封端氧原子位于 $(x_{\\mathrm{cap}},0,z_{\\mathrm{eq}})$ 和 $(-x_{\\mathrm{cap}},0,z_{\\mathrm{eq}})$，其中 $x_{\\mathrm{cap}} = 5.00\\,\\mathrm{\\AA}$。\n- 吸附物为一氧化碳（CO），通过碳原子与第一个铜原子结合。将碳原子置于 $(r_{\\mathrm{Cu{-}C}},0,0)$，氧原子置于 $(r_{\\mathrm{Cu{-}C}} + \\ell_{\\mathrm{C{-}O}},0,0)$，其中 $\\ell_{\\mathrm{C{-}O}} = 1.128\\,\\mathrm{\\AA}$。\n- 原子部分电荷（以元电荷 $e$ 为单位）为：铜 $+1.0$，赤道氧 $-0.5$，封端氧 $-0.8$，吸附物碳 $+0.2$，吸附物氧 $-0.2$。\n- 吸附物与簇之间的非键相互作用被建模为静电贡献和范德华贡献之和。使用库仑常数 $k_{\\mathrm{e}} = 14.399645478\\,\\mathrm{eV}\\,\\mathrm{\\AA}\\,e^{-2}$ 和每种原子类型的兰纳-琼斯参数 $(\\sigma,\\varepsilon)$，并应用洛伦兹-贝特洛混合规则：$\\sigma_{ij} = (\\sigma_i + \\sigma_j)/2$ 和 $\\varepsilon_{ij} = \\sqrt{\\varepsilon_i \\varepsilon_j}$。兰纳-琼斯能量为 $U_{ij}^{\\mathrm{LJ}}(r) = 4\\varepsilon_{ij}\\left[(\\sigma_{ij}/r)^{12} - (\\sigma_{ij}/r)^6\\right]$。静电能量为 $U_{ij}^{\\mathrm{Coul}}(r) = k_{\\mathrm{e}}\\,q_i q_j / r$。\n- 兰纳-琼斯基本参数（单位为 $\\mathrm{\\AA}$ 和 $\\mathrm{eV}$）：铜 $\\sigma = 2.338$, $\\varepsilon = 0.010$；赤道氧 $\\sigma = 3.000$, $\\varepsilon = 0.008$；吸附物碳 $\\sigma = 3.550$, $\\varepsilon = 0.003$；吸附物氧 $\\sigma = 3.120$, $\\varepsilon = 0.006$。\n- 封端氧的兰纳-琼斯参数 $\\varepsilon$ 取决于封端基团：甲酸基（formate）$\\varepsilon = 0.010$，乙酸基（acetate）$\\varepsilon = 0.012$，苯甲酸基（benzoate）$\\varepsilon = 0.014$，所有情况下 $\\sigma = 3.000\\,\\mathrm{\\AA}$。\n- 形变罚项 $E_{\\mathrm{def}}$ 用于解释簇模型和周期性体系力学响应之间的差异：甲酸基（formate）$E_{\\mathrm{def}} = 0.050\\,\\mathrm{eV}$，乙酸基（acetate）$E_{\\mathrm{def}} = 0.080\\,\\mathrm{eV}$，苯甲酸基（benzoate）$E_{\\mathrm{def}} = 0.120\\,\\mathrm{eV}$。\n\n从吸附能是零温下（忽略零点能和熵项）的势能差这一基本定义出发，使用上述吸附物和簇原子之间的对相互作用构建吸附物结合态的簇能量，加上适当的形变罚项，并定义簇相对于无相互作用参考态的吸附能。对于每种情景，给定一个周期性基准吸附能，计算其变化量 $\\Delta E_{\\mathrm{ads}} = E_{\\mathrm{ads}}^{\\mathrm{cluster}} - E_{\\mathrm{ads}}^{\\mathrm{periodic}}$。\n\n实现您的程序以评估以下测试套件，其中每个案例都是一个元组，包含封端基团、铜-碳距离和周期性基准吸附能，所有单位均已指定：\n- 案例 $1$：封端基团 \"formate\"，$r_{\\mathrm{Cu{-}C}} = 2.000\\,\\mathrm{\\AA}$，$E_{\\mathrm{ads}}^{\\mathrm{periodic}} = -0.450\\,\\mathrm{eV}$。\n- 案例 $2$：封端基团 \"acetate\"，$r_{\\mathrm{Cu{-}C}} = 2.400\\,\\mathrm{\\AA}$，$E_{\\mathrm{ads}}^{\\mathrm{periodic}} = -0.300\\,\\mathrm{eV}$。\n- 案例 $3$：封端基团 \"benzoate\"，$r_{\\mathrm{Cu{-}C}} = 3.500\\,\\mathrm{\\AA}$，$E_{\\mathrm{ads}}^{\\mathrm{periodic}} = -0.050\\,\\mathrm{eV}$。\n- 案例 $4$：封端基团 \"formate\"，$r_{\\mathrm{Cu{-}C}} = 6.000\\,\\mathrm{\\AA}$，$E_{\\mathrm{ads}}^{\\mathrm{periodic}} = -0.010\\,\\mathrm{eV}$。\n\n您的程序应输出这四个案例的 $\\Delta E_{\\mathrm{ads}}$ 值列表（单位为 $\\mathrm{eV}$），四舍五入到 $6$ 位小数，并以单行形式输出：一个用方括号括起来的逗号分隔列表，例如 $[x_1,x_2,x_3,x_4]$，其中每个 $x_i$ 是一个具有 $6$ 位小数的 $\\mathrm{eV}$ 单位浮点数。",
            "solution": "该问题要求计算在HKUST-1金属有机框架的铜位点上吸附一氧化碳（CO）时，简化簇模型与周期性基准计算之间的吸附能变化量 $\\Delta E_{\\mathrm{ads}}$。\n在指定的簇模型中，吸附能 $E_{\\mathrm{ads}}^{\\mathrm{cluster}}$ 定义为吸附物（CO）与簇原子之间的总相互作用能，加上一个取决于封端基团选择的形变罚项 $E_{\\mathrm{def}}$。\n$$E_{\\mathrm{ads}}^{\\mathrm{cluster}} = E_{\\mathrm{interaction}} + E_{\\mathrm{def}}$$\n最终要计算的量是相对于给定的周期性基准能量 $E_{\\mathrm{ads}}^{\\mathrm{periodic}}$ 的差值：\n$$\\Delta E_{\\mathrm{ads}} = E_{\\mathrm{ads}}^{\\mathrm{cluster}} - E_{\\mathrm{ads}}^{\\mathrm{periodic}}$$\n\n相互作用能 $E_{\\mathrm{interaction}}$ 的计算方法是：对所有吸附物原子 $i$ 和所有簇原子 $j$ 的对势进行求和。每个对相互作用是库仑静电项和兰纳-琼斯（LJ）范德华项的和。\n$$E_{\\mathrm{interaction}} = \\sum_{i \\in \\text{adsorbate}} \\sum_{j \\in \\text{cluster}} \\left( U_{ij}^{\\mathrm{Coul}}(r_{ij}) + U_{ij}^{\\mathrm{LJ}}(r_{ij}) \\right)$$\n其中 $r_{ij}$ 是原子 $i$ 和 $j$ 之间的距离。\n\n库仑势由以下公式给出：\n$$U_{ij}^{\\mathrm{Coul}}(r_{ij}) = \\frac{k_{\\mathrm{e}} q_i q_j}{r_{ij}}$$\n其中库仑常数 $k_{\\mathrm{e}} = 14.399645478\\,\\mathrm{eV}\\,\\mathrm{\\AA}\\,e^{-2}$，$q_i, q_j$ 是以元电荷 $e$ 为单位的部分电荷。\n\n兰纳-琼斯势由以下公式给出：\n$$U_{ij}^{\\mathrm{LJ}}(r_{ij}) = 4\\varepsilon_{ij}\\left[\\left(\\frac{\\sigma_{ij}}{r_{ij}}\\right)^{12} - \\left(\\frac{\\sigma_{ij}}{r_{ij}}\\right)^{6}\\right]$$\n对于异原子对，组合参数 $\\sigma_{ij}$ 和 $\\varepsilon_{ij}$ 由基本原子参数 $\\sigma_i, \\varepsilon_i$ 和 $\\sigma_j, \\varepsilon_j$ 通过洛伦兹-贝特洛混合规则确定：\n$$\\sigma_{ij} = \\frac{\\sigma_i + \\sigma_j}{2}$$\n$$\\varepsilon_{ij} = \\sqrt{\\varepsilon_i \\varepsilon_j}$$\n\n计算流程包括以下步骤：\n$1$. 为每个测试案例定义簇中所有原子和吸附物中所有原子的笛卡尔坐标。\n$2$. 为每种原子类型定义物理参数（部分电荷、兰纳-琼斯 $\\sigma$ 和 $\\varepsilon$）。\n$3$. 对于每个测试案例，遍历所有 $2 \\times 8 = 16$ 个吸附物-簇原子对。\n$4$. 对于每个原子对，计算原子间距离 $r_{ij}$，并计算相应的 $U_{ij}^{\\mathrm{Coul}}$ 和 $U_{ij}^{\\mathrm{LJ}}$。\n$5$. 将这些能量相加，得到总相互作用能 $E_{\\mathrm{interaction}}$。\n$6$. 加上适当的形变罚项 $E_{\\mathrm{def}}$，求得 $E_{\\mathrm{ads}}^{\\mathrm{cluster}}$。\n$7$. 减去给定的 $E_{\\mathrm{ads}}^{\\mathrm{periodic}}$，得到最终的 $\\Delta E_{\\mathrm{ads}}$。\n\n原子坐标以埃格斯特罗姆（$\\mathrm{\\AA}$）为单位指定。簇由 $8$ 个原子组成：\n- 两个铜原子（$Cu$）：$Cu_1$ 位于 $(0,0,0)$，$Cu_2$ 位于 $(0,0,d_{\\mathrm{Cu{-}Cu}})$，其中 $d_{\\mathrm{Cu{-}Cu}} = 2.64\\,\\mathrm{\\AA}$。\n- 四个赤道氧原子（$O_{\\mathrm{eq}}$）：位于 $(\\pm r_{\\mathrm{Cu{-}O}}, 0, z_{\\mathrm{eq}})$ 和 $(0, \\pm r_{\\mathrm{Cu{-}O}}, z_{\\mathrm{eq}})$，其中 $r_{\\mathrm{Cu{-}O}} = 1.95\\,\\mathrm{\\AA}$ 且 $z_{\\mathrm{eq}} = 1.32\\,\\mathrm{\\AA}$。\n- 两个封端氧原子（$O_{\\mathrm{cap}}$）：位于 $(\\pm x_{\\mathrm{cap}}, 0, z_{\\mathrm{eq}})$，其中 $x_{\\mathrm{cap}} = 5.00\\,\\mathrm{\\AA}$。\n\n吸附物为一氧化碳分子（$CO$），由 $2$ 个原子组成：\n- 一个碳原子（$C$）：位于 $(r_{\\mathrm{Cu{-}C}}, 0, 0)$。\n- 一个氧原子（$O$）：位于 $(r_{\\mathrm{Cu{-}C}} + \\ell_{\\mathrm{C{-}O}}, 0, 0)$，其中 $\\ell_{\\mathrm{C{-}O}} = 1.128\\,\\mathrm{\\AA}$。\n距离 $r_{\\mathrm{Cu{-}C}}$ 是每个测试案例中指定的一个变量。\n\n计算参数如下：\n部分电荷（单位为 $e$）：\n-   $q_{\\mathrm{Cu}} = +1.0$\n-   $q_{\\mathrm{O,eq}} = -0.5$\n-   $q_{\\mathrm{O,cap}} = -0.8$\n-   $q_{\\mathrm{C,ads}} = +0.2$\n-   $q_{\\mathrm{O,ads}} = -0.2$\n\n兰纳-琼斯基本参数（$\\sigma$ 单位为 $\\mathrm{\\AA}$，$\\varepsilon$ 单位为 $\\mathrm{eV}$）：\n-   铜（$Cu$）：$\\sigma = 2.338$，$\\varepsilon = 0.010$\n-   赤道氧（$O_{\\mathrm{eq}}$）：$\\sigma = 3.000$，$\\varepsilon = 0.008$\n-   吸附物碳（$C_{\\mathrm{ads}}$）：$\\sigma = 3.550$，$\\varepsilon = 0.003$\n-   吸附物氧（$O_{\\mathrm{ads}}$）：$\\sigma = 3.120$，$\\varepsilon = 0.006$\n-   封端氧（$O_{\\mathrm{cap}}$）：所有基团的 $\\sigma = 3.000$。$\\varepsilon$ 参数取决于封端基团。\n\n取决于封端基团的参数（$\\varepsilon$ 单位为 $\\mathrm{eV}$，$E_{\\mathrm{def}}$ 单位为 $\\mathrm{eV}$）：\n-   甲酸基（Formate）：$\\varepsilon_{\\mathrm{O,cap}} = 0.010$，$E_{\\mathrm{def}} = 0.050$\n-   乙酸基（Acetate）：$\\varepsilon_{\\mathrm{O,cap}} = 0.012$，$E_{\\mathrm{def}} = 0.080$\n-   苯甲酸基（Benzoate）：$\\varepsilon_{\\mathrm{O,cap}} = 0.014$，$E_{\\mathrm{def}} = 0.120$\n\n该算法将被实现以处理所提供的四个测试案例，计算每种情景下的 $\\Delta E_{\\mathrm{ads}}$，并按指定格式呈现结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\nclass AdsorptionEnergyModel:\n    \"\"\"\n    Models the adsorption energy of CO on a copper-based MOF cluster.\n    \"\"\"\n    # Physical constants\n    K_E = 14.399645478  # eV * Angstrom / e^2\n\n    # Cluster geometry constants\n    D_CU_CU = 2.64\n    R_CU_O = 1.95\n    Z_EQ = 1.32\n    X_CAP = 5.00\n\n    # Adsorbate geometry constant\n    L_C_O = 1.128\n\n    # Base atomic parameters (charge q, LJ sigma, LJ epsilon)\n    PARAMS = {\n        'Cu': {'q': 1.0, 'sigma': 2.338, 'eps': 0.010},\n        'O_eq': {'q': -0.5, 'sigma': 3.000, 'eps': 0.008},\n        'C_ads': {'q': 0.2, 'sigma': 3.550, 'eps': 0.003},\n        'O_ads': {'q': -0.2, 'sigma': 3.120, 'eps': 0.006},\n    }\n\n    # Capping group dependent parameters\n    CAPPING_PARAMS = {\n        'formate': {'eps_cap': 0.010, 'E_def': 0.050},\n        'acetate': {'eps_cap': 0.012, 'E_def': 0.080},\n        'benzoate': {'eps_cap': 0.014, 'E_def': 0.120},\n    }\n    O_CAP_BASE_PARAMS = {'q': -0.8, 'sigma': 3.000}\n\n    def __init__(self, capping_group, r_cu_c):\n        \"\"\"\n        Initializes the model for a specific scenario.\n\n        Args:\n            capping_group (str): The name of the capping group.\n            r_cu_c (float): The distance between the binding Cu and adsorbate C.\n        \"\"\"\n        if capping_group not in self.CAPPING_PARAMS:\n            raise ValueError(f\"Unknown capping group: {capping_group}\")\n        self.capping_group = capping_group\n        self.r_cu_c = r_cu_c\n        \n        self.cluster_atoms = self._build_cluster()\n        self.adsorbate_atoms = self._build_adsorbate()\n        self.e_def = self.CAPPING_PARAMS[self.capping_group]['E_def']\n\n    def _build_cluster(self):\n        \"\"\"Constructs the list of atoms in the cluster.\"\"\"\n        cap_params = self.CAPPING_PARAMS[self.capping_group]\n        o_cap_eps = cap_params['eps_cap']\n        \n        atoms = [\n            {'params': self.PARAMS['Cu'], 'pos': np.array([0.0, 0.0, 0.0])},\n            {'params': self.PARAMS['Cu'], 'pos': np.array([0.0, 0.0, self.D_CU_CU])},\n            {'params': self.PARAMS['O_eq'], 'pos': np.array([self.R_CU_O, 0.0, self.Z_EQ])},\n            {'params': self.PARAMS['O_eq'], 'pos': np.array([-self.R_CU_O, 0.0, self.Z_EQ])},\n            {'params': self.PARAMS['O_eq'], 'pos': np.array([0.0, self.R_CU_O, self.Z_EQ])},\n            {'params': self.PARAMS['O_eq'], 'pos': np.array([0.0, -self.R_CU_O, self.Z_EQ])},\n            {'params': {**self.O_CAP_BASE_PARAMS, 'eps': o_cap_eps}, 'pos': np.array([self.X_CAP, 0.0, self.Z_EQ])},\n            {'params': {**self.O_CAP_BASE_PARAMS, 'eps': o_cap_eps}, 'pos': np.array([-self.X_CAP, 0.0, self.Z_EQ])},\n        ]\n        return atoms\n\n    def _build_adsorbate(self):\n        \"\"\"Constructs the list of atoms in the adsorbate.\"\"\"\n        atoms = [\n            {'params': self.PARAMS['C_ads'], 'pos': np.array([self.r_cu_c, 0.0, 0.0])},\n            {'params': self.PARAMS['O_ads'], 'pos': np.array([self.r_cu_c + self.L_C_O, 0.0, 0.0])},\n        ]\n        return atoms\n\n    def _calculate_pair_interaction(self, atom1, atom2):\n        \"\"\"Calculates the Coulomb and LJ interaction energy for a pair of atoms.\"\"\"\n        p1 = atom1['params']\n        p2 = atom2['params']\n        \n        dist = np.linalg.norm(atom1['pos'] - atom2['pos'])\n        \n        # Coulomb interaction\n        u_coulomb = self.K_E * p1['q'] * p2['q'] / dist\n        \n        # Lennard-Jones interaction with Lorentz-Berthelot mixing rules\n        sigma_ij = (p1['sigma'] + p2['sigma']) / 2.0\n        eps_ij = math.sqrt(p1['eps'] * p2['eps'])\n        \n        sigma_over_r = sigma_ij / dist\n        sigma_over_r_6 = sigma_over_r**6\n        sigma_over_r_12 = sigma_over_r_6**2\n        \n        u_lj = 4.0 * eps_ij * (sigma_over_r_12 - sigma_over_r_6)\n        \n        return u_coulomb + u_lj\n\n    def calculate_cluster_adsorption_energy(self):\n        \"\"\"Calculates the total adsorption energy for the cluster model.\"\"\"\n        e_interaction = 0.0\n        for ads_atom in self.adsorbate_atoms:\n            for clu_atom in self.cluster_atoms:\n                e_interaction += self._calculate_pair_interaction(ads_atom, clu_atom)\n                \n        e_ads_cluster = e_interaction + self.e_def\n        return e_ads_cluster\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple of (capping_group, r_Cu-C, E_ads_periodic).\n    test_cases = [\n        (\"formate\", 2.000, -0.450),\n        (\"acetate\", 2.400, -0.300),\n        (\"benzoate\", 3.500, -0.050),\n        (\"formate\", 6.000, -0.010),\n    ]\n\n    results = []\n    for capping_group, r_cu_c, e_ads_periodic in test_cases:\n        # Instantiate the model for the current case\n        model = AdsorptionEnergyModel(capping_group=capping_group, r_cu_c=r_cu_c)\n        \n        # Calculate cluster adsorption energy\n        e_ads_cluster = model.calculate_cluster_adsorption_energy()\n        \n        # Calculate the change relative to the periodic benchmark\n        delta_e_ads = e_ads_cluster - e_ads_periodic\n        \n        results.append(delta_e_ads)\n\n    # Format the output string as required\n    output_str = f\"[{','.join([f'{val:.6f}' for val in results])}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "许多计算研究的最终目标是揭示一系列相关反应的构效关系，从而指导催化剂的设计。Brønsted–Evans–Polanyi（BEP）原理是一个强大的线性自由能关系，它将反应动力学（活化能 $\\Delta E^{\\ddagger}$）与热力学（反应能 $\\Delta E$）联系起来。在本实践中，您将扮演数据科学家的角色，利用一组计算数据通过线性回归发现催化趋势 。更进一步，您将学习如何通过一个物理模型来解释偏离理想线性关系的数据点，从而理解MOF孔道内的限域效应对催化活性的调控作用。",
            "id": "3889362",
            "problem": "你需要实现一个程序，针对一组在含镍金属有机框架（Nickel Metal-Organic Framework (Ni-MOF)）内发生的氢化步骤，推断出反应能和活化能之间的线性映射关系，然后量化由孔道限制效应引起的偏差。其物理基础源于过渡态理论（Transition State Theory, TST）——该理论将速率常数与活化自由能联系起来，以及催化领域的一项观察，即相关基元步骤的活化能垒通常随反应能量近似呈线性变化。多孔催化剂中的限制效应可以改变活化络合物的自由能，这主要是通过减少可及的平动熵来实现的。请仅使用所提供的数据和下述基本原理，构建一个可复现且可在数值上进行检验的分析。\n\n推导的基本原理：\n- 假设活化能与反应能之间存在线性关系，该关系由一个未知的斜率和截距参数化，这些参数需要从数据中推断。设反应能用 $\\,\\Delta E\\,$ 表示，活化能（能垒）用 $\\,\\Delta E^{\\ddagger}\\,$ 表示，两者单位均为 $\\,\\mathrm{eV}\\,$。对于同系列反应，这种线性映射是一种常见的经验行为，其动机可结合能量形貌（Energy Landscape）的考量和 Brønsted–Evans–Polanyi 思想来解释。\n- 采用过渡态理论关于速率常数 $\\,k\\,$ 的关系式：$\\,k = \\dfrac{k_{\\mathrm{B}} T}{h} \\exp\\!\\left(-\\dfrac{\\Delta G^{\\ddagger}}{k_{\\mathrm{B}} T}\\right)\\,$，其中 $\\,\\Delta G^{\\ddagger}\\,$ 是活化自由能，$\\,k_{\\mathrm{B}}\\,$ 是 Boltzmann 常数，$\\,T\\,$ 是温度，$\\,h\\,$ 是 Planck 常数。尽管此处不直接使用速率，但这为联系能垒和自由能变化提供了热力学框架。\n- 为模拟限制效应对能垒的影响，将活化络合物因可及体积减小而引起的自由能变化近似为 $\\,\\Delta G_{\\mathrm{conf}}(T) \\approx k_{\\mathrm{B}} T \\ln\\!\\left(\\dfrac{V_{\\mathrm{ref}}}{V_{\\mathrm{pore}}}\\right)\\,$，其中 $\\,V_{\\mathrm{pore}}\\,$ 是络合物的可及孔道体积，$\\,V_{\\mathrm{ref}}\\,$ 是一个参考体积。假设对于特征孔道半径 $\\,r\\,$，有 $\\,V_{\\mathrm{pore}} \\propto r^{3}\\,$，则可得到 $\\,\\Delta G_{\\mathrm{conf}}(T) \\approx 3\\,k_{\\mathrm{B}} T \\ln\\!\\left(\\dfrac{r_{\\mathrm{ref}}}{r}\\right)\\,$。使用单位为 $\\,\\mathrm{eV}\\,\\mathrm{K}^{-1}\\,$ 的 Boltzmann 常数，将 $\\,\\Delta G_{\\mathrm{conf}}\\,$ 表示为每个事件的能量，单位为 $\\,\\mathrm{eV}\\,$。\n\n数据与单位：\n- 温度 $\\,T = 300\\,\\mathrm{K}\\,$。\n- 参考孔道半径 $\\,r_{\\mathrm{ref}} = 1.6\\,\\mathrm{nm}\\,$。\n- 能量单位为 $\\,\\mathrm{eV}\\,$，半径单位为 $\\,\\mathrm{nm}\\,$，温度单位为 $\\,\\mathrm{K}\\,$。\n- 数据集包含 $\\,10\\,$ 个氢化步骤，每个步骤以元组 $\\,(\\Delta E,\\ \\Delta E^{\\ddagger},\\ r)\\,$ 的形式提供：\n  1. $\\,(-0.85,\\ 0.561,\\ 1.7)\\,$\n  2. $\\,(-0.42,\\ 0.695,\\ 1.6)\\,$\n  3. $\\,(\\phantom{-}0.00,\\ 0.842,\\ 1.8)\\,$\n  4. $\\,(\\phantom{-}0.25,\\ 0.949,\\ 1.5)\\,$\n  5. $\\,(-0.60,\\ 0.670,\\ 1.2)\\,$\n  6. $\\,(\\phantom{-}0.10,\\ 0.913,\\ 1.2)\\,$\n  7. $\\,(-1.05,\\ 0.556,\\ 0.8)\\,$\n  8. $\\,(\\phantom{-}0.35,\\ 1.016,\\ 0.8)\\,$\n  9. $\\,(-0.20,\\ 0.871,\\ 0.6)\\,$\n  10. $\\,(\\phantom{-}0.00,\\ 0.921,\\ 0.6)\\,$\n\n计算任务：\n- 使用普通最小二乘法（OLS）对由 $\\,r \\geq 1.5\\,\\mathrm{nm}\\,$ 的低限制效应数据点组成的训练子集，拟合 $\\,\\Delta E\\,$ 和 $\\,\\Delta E^{\\ddagger}\\,$ 之间的线性映射关系。仅从该训练子集推断线性模型的斜率 $\\,\\alpha\\,$ 和截距 $\\,\\beta\\,$。\n- 计算 OLS 拟合的训练集均方根误差（RMSE），单位为 $\\,\\mathrm{eV}\\,$。\n- 对于完整数据集中的每个数据点，计算观测偏差 $\\,\\delta_{\\mathrm{obs}} = \\Delta E^{\\ddagger} - (\\alpha\\,\\Delta E + \\beta)\\,$，单位为 $\\,\\mathrm{eV}\\,$。\n- 对于每个数据点，计算熵限制罚项 $\\,\\Delta G_{\\mathrm{conf}} = 3\\,k_{\\mathrm{B}} T \\ln\\!\\left(\\dfrac{r_{\\mathrm{ref}}}{r}\\right)\\,$，单位为 $\\,\\mathrm{eV}\\,$，其中 $\\,k_{\\mathrm{B}} = 8.617333262\\times 10^{-5}\\,\\mathrm{eV}\\,\\mathrm{K}^{-1}\\,$。\n- 定义一个高限制效应子集，其成员为 $\\,r \\leq 0.8\\,\\mathrm{nm}\\,$ 的数据点，并在此子集上计算平均绝对差异 $\\,\\overline{|d|}\\,$，其中 $\\,d = \\delta_{\\mathrm{obs}} - \\Delta G_{\\mathrm{conf}}\\,$，单位为 $\\,\\mathrm{eV}\\,$。\n- 识别 $\\,\\Delta E = 0.00\\,\\mathrm{eV}\\,$ 且 $\\,r = 0.6\\,\\mathrm{nm}\\,$ 的边界测试用例，并计算其如上定义的差异 $\\,d\\,$，单位为 $\\,\\mathrm{eV}\\,$。\n- 判断高限制效应案例中是否至少有一半满足 $\\,|d| \\leq 0.03\\,\\mathrm{eV}\\,$。将结果报告为一个布尔值。\n\n测试套件与输出规范：\n- 使用上述数据集作为完整的测试套件。\n- 你的程序必须生成单行输出，其中包含一个逗号分隔的 Python 列表，按以下顺序和单位排列：\n  - 拟合斜率 $\\,\\alpha\\,$（浮点数，无单位，因为是 $\\,\\mathrm{eV}/\\mathrm{eV}\\,$）。\n  - 拟合截距 $\\,\\beta\\,$（浮点数，单位为 $\\,\\mathrm{eV}\\,$）。\n  - 训练集 RMSE（浮点数，单位为 $\\,\\mathrm{eV}\\,$）。\n  - 高限制效应子集上的平均绝对差异 $\\,\\overline{|d|}\\,$（浮点数，单位为 $\\,\\mathrm{eV}\\,$）。\n  - $\\,\\Delta E = 0.00\\,\\mathrm{eV}\\,$ 且 $\\,r=0.6\\,\\mathrm{nm}\\,$ 的边界情况差异 $\\,d\\,$（浮点数，单位为 $\\,\\mathrm{eV}\\,$）。\n  - 上述的布尔值。\n- 所需最终输出格式示例：单行输出 $\\,\\left[\\alpha,\\beta,\\mathrm{RMSE},\\overline{|d|},d,\\mathrm{boolean}\\right]\\,$，例如 $\\,\\left[0.35,0.85,0.01,0.02,-0.005,\\mathrm{True}\\right]\\,$。你的输出必须是根据指定数据集计算出的实际值，而不是示例值。",
            "solution": "该问题被评估为有效，因为它在科学上基于计算催化原理，问题陈述适定，拥有完整且一致的数据和定义，并且其表述是客观的。该任务需要进行一个多步数值分析，涉及线性回归和应用一个物理模型来描述限制效应。我们将逐步进行求解。\n\n该分析基于 Brønsted–Evans–Polanyi (BEP) 原理，该原理假设对于一系列同系列化学反应，活化能 $\\Delta E^{\\ddagger}$ 与反应能 $\\Delta E$ 之间存在线性关系。这种经验关系表示为：\n$$\n\\Delta E^{\\ddagger} = \\alpha \\Delta E + \\beta\n$$\n其中 $\\alpha$ 是斜率，$\\beta$ 是截距。这些参数代表了催化剂的内禀催化性质，与孔道限制等环境因素无关。\n\n所提供的数据集包含 $10$ 个元组，每个元组代表一个氢化步骤，包含其反应能 $\\Delta E$（单位 $\\mathrm{eV}$）、活化能 $\\Delta E^{\\ddagger}$（单位 $\\mathrm{eV}$）以及一个特征孔道半径 $r$（单位 $\\mathrm{nm}$）。\n\n**步骤1：推断内在线性标度关系**\n\n首先，我们必须确定内禀的 BEP 参数 $\\alpha$ 和 $\\beta$。这些参数是通过限制效应最小的数据子集推断出来的。问题将这个“训练子集”定义为孔道半径 $r \\geq 1.5\\,\\mathrm{nm}$ 的数据点。检查数据集，我们为此子集确定了以下 $4$ 个点：\n1. $(\\Delta E_1, \\Delta E^{\\ddagger}_1, r_1) = (-0.85, 0.561, 1.7)$\n2. $(\\Delta E_2, \\Delta E^{\\ddagger}_2, r_2) = (-0.42, 0.695, 1.6)$\n3. $(\\Delta E_3, \\Delta E^{\\ddagger}_3, r_3) = (0.00, 0.842, 1.8)$\n4. $(\\Delta E_4, \\Delta E^{\\ddagger}_4, r_4) = (0.25, 0.949, 1.5)$\n\n我们对这个训练集中的 $(\\Delta E, \\Delta E^{\\ddagger})$ 对执行普通最小二乘（OLS）回归。令 $\\boldsymbol{x} = \\{\\Delta E_i\\}$ 且 $\\boldsymbol{y} = \\{\\Delta E^{\\ddagger}_i\\}$，其中 $i \\in \\{1, 2, 3, 4\\}$。计算斜率 $\\alpha$ 和截距 $\\beta$ 以最小化残差平方和。使用标准线性回归公式，我们发现：\n$\\alpha \\approx 0.35002852$\n$\\beta \\approx 0.85100779$\n\n**步骤2：量化拟合质量**\n\n为了评估训练数据上线性拟合的质量，我们计算均方根误差（RMSE）。RMSE 定义为观测活化能 $\\Delta E^{\\ddagger}_i$ 与线性模型预测值 $\\Delta E^{\\ddagger}_{\\text{pred}, i} = \\alpha \\Delta E_i + \\beta$ 之间差值平方的均值的平方根。\n$$\n\\text{RMSE} = \\sqrt{\\frac{1}{N_{\\text{train}}} \\sum_{i=1}^{N_{\\text{train}}} (\\Delta E^{\\ddagger}_i - (\\alpha \\Delta E_i + \\beta))^2}\n$$\n对于这 $4$ 个训练点，计算得出：\n$\\text{RMSE} \\approx 0.00396440\\,\\mathrm{eV}$\n\n**步骤3：模拟限制效应**\n\n据推测，金属有机框架（MOF）纳米孔内的限制会改变活化能。这主要是一种熵效应。过渡态作为一种特定构型，在更紧凑的孔道中相比于反应物会损失更多可及体积（从而损失平动熵）。这会使过渡态不稳定，从而有效地增加了活化能垒。问题为这个自由能罚项 $\\Delta G_{\\mathrm{conf}}$ 提供了一个基于简化箱中粒子模型的模型：\n$$\n\\Delta G_{\\mathrm{conf}} = 3 k_{\\mathrm{B}} T \\ln\\left(\\frac{r_{\\mathrm{ref}}}{r}\\right)\n$$\n其中 $k_{\\mathrm{B}} = 8.617333262 \\times 10^{-5}\\,\\mathrm{eV}\\,\\mathrm{K}^{-1}$ 是 Boltzmann 常数，$T = 300\\,\\mathrm{K}$ 是温度，$r_{\\mathrm{ref}} = 1.6\\,\\mathrm{nm}$ 是参考孔道半径。在给定温度下，热能为 $k_{\\mathrm{B}} T \\approx 0.025852\\,\\mathrm{eV}$。\n\n在受限环境中，总活化能垒 $\\Delta E^{\\ddagger}_{\\text{obs}}$ 是内禀电子能垒与限制罚项之和：\n$$\n\\Delta E^{\\ddagger}_{\\text{obs}} \\approx (\\alpha \\Delta E + \\beta) + \\Delta G_{\\mathrm{conf}}\n$$\n该模型预测，从内禀 BEP 直线观察到的偏差 $\\delta_{\\mathrm{obs}} = \\Delta E^{\\ddagger}_{\\text{obs}} - (\\alpha \\Delta E + \\beta)$ 应约等于限制罚项 $\\Delta G_{\\mathrm{conf}}$。\n\n**步骤4：评估限制模型**\n\n我们现在来检验这个假设。对于完整数据集中的每个点，我们计算观测偏差 $\\delta_{\\mathrm{obs}, j}$ 和理论限制罚项 $\\Delta G_{\\mathrm{conf}, j}$。差异 $d_j = \\delta_{\\mathrm{obs}, j} - \\Delta G_{\\mathrm{conf}, j}$ 衡量了我们结合了 BEP 和限制效应的模型与观测数据的偏离程度。\n\n我们关注由 $r \\leq 0.8\\,\\mathrm{nm}$ 定义的“高限制效应子集”。该子集包括以下 $4$ 个数据点：\n7. $(\\Delta E_7, \\Delta E^{\\ddagger}_7, r_7) = (-1.05, 0.556, 0.8)$\n8. $(\\Delta E_8, \\Delta E^{\\ddagger}_8, r_8) = (0.35, 1.016, 0.8)$\n9. $(\\Delta E_9, \\Delta E^{\\ddagger}_9, r_9) = (-0.20, 0.871, 0.6)$\n10. $(\\Delta E_{10}, \\Delta E^{\\ddagger}_{10}, r_{10}) = (0.00, 0.921, 0.6)$\n\n对于这些点，我们计算差异 $d_7, d_8, d_9, d_{10}$。然后，我们计算该子集的平均绝对差异 $\\overline{|d|}$：\n$$\n\\overline{|d|} = \\frac{1}{N_{\\text{high}}} \\sum_{j \\in \\{7,8,9,10\\}} |d_j|\n$$\n计算结果为 $\\overline{|d|} \\approx 0.01689239\\,\\mathrm{eV}$。这个小值表明，限制模型为内禀 BEP 关系提供了一个合理的修正。\n\n**步骤5：特定案例分析**\n\n问题要求对这个高限制效应子集进行两项特定分析。\n\n首先，我们识别 $\\Delta E = 0.00\\,\\mathrm{eV}$ 且 $r = 0.6\\,\\mathrm{nm}$ 的边界测试用例，它对应于数据点 $10$。我们计算其特定差异 $d_{10}$：\n对于此点：\n$\\delta_{\\mathrm{obs}, 10} = 0.921 - (\\alpha \\cdot 0.00 + \\beta) \\approx 0.921 - 0.85100779 = 0.06999221\\,\\mathrm{eV}$\n$\\Delta G_{\\mathrm{conf}, 10} = 3 k_{\\mathrm{B}} T \\ln(1.6 / 0.6) \\approx 0.07604543\\,\\mathrm{eV}$\n$d_{10} = \\delta_{\\mathrm{obs}, 10} - \\Delta G_{\\mathrm{conf}, 10} \\approx 0.06999221 - 0.07604543 = -0.00605322\\,\\mathrm{eV}$\n\n其次，我们必须确定高限制效应子集案例中是否至少有一半的案例满足条件 $|d_j| \\leq 0.03\\,\\mathrm{eV}$。高限制效应子集有 $N_{\\text{high}} = 4$ 个点，因此我们必须检查是否至少有 $2$ 个点满足该标准。计算出的绝对差异为：\n$|d_7| \\approx 0.013583\\,\\mathrm{eV}$\n$|d_8| \\approx 0.041880\\,\\mathrm{eV}$\n$|d_9| \\approx 0.006053\\,\\mathrm{eV}$\n$|d_{10}| \\approx 0.006053\\,\\mathrm{eV}$\n\n其中三个值（$|d_7|$、$|d_9|$ 和 $|d_{10}|$）小于或等于 $0.03\\,\\mathrm{eV}$。由于 $3 \\geq 2$，条件满足，结果为 True。\n\n**结果总结**\n\n为指定任务计算出的最终值为：\n- 斜率 $\\alpha \\approx 0.35002852$\n- 截距 $\\beta \\approx 0.85100779\\,\\mathrm{eV}$\n- 训练集 RMSE $\\approx 0.00396440\\,\\mathrm{eV}$\n- 平均绝对差异 $\\overline{|d|} \\approx 0.01689239\\,\\mathrm{eV}$\n- 边界情况差异 $d_{10} \\approx -0.00605322\\,\\mathrm{eV}$\n- 布尔值检查：True",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational catalysis problem by performing a linear fit,\n    calculating deviations, and evaluating a confinement model.\n    \"\"\"\n    # --- Givens ---\n    # Constants\n    T = 300.0  # K\n    R_REF = 1.6  # nm\n    K_B = 8.617333262e-5  # eV/K\n\n    # Dataset: (delta_E, delta_E_ddagger, r)\n    dataset = [\n        (-0.85, 0.561, 1.7),\n        (-0.42, 0.695, 1.6),\n        (0.00, 0.842, 1.8),\n        (0.25, 0.949, 1.5),\n        (-0.60, 0.670, 1.2),\n        (0.10, 0.913, 1.2),\n        (-1.05, 0.556, 0.8),\n        (0.35, 1.016, 0.8),\n        (-0.20, 0.871, 0.6),\n        (0.00, 0.921, 0.6),\n    ]\n\n    # --- Step 1: Linear Fit on Training Subset ---\n    # Training subset is defined by r >= 1.5 nm\n    training_set = [p for p in dataset if p[2] >= 1.5]\n    \n    # Extract reaction energies (x) and activation energies (y)\n    train_delta_E = np.array([p[0] for p in training_set])\n    train_delta_E_ddagger = np.array([p[1] for p in training_set])\n\n    # Perform Ordinary Least Squares (OLS) regression using np.polyfit for a degree 1 polynomial\n    alpha, beta = np.polyfit(train_delta_E, train_delta_E_ddagger, 1)\n\n    # --- Step 2: Training RMSE ---\n    # Predict activation energies for the training set\n    predicted_train_delta_E_ddagger = alpha * train_delta_E + beta\n    \n    # Calculate the Root Mean Square Error (RMSE)\n    training_rmse = np.sqrt(np.mean((train_delta_E_ddagger - predicted_train_delta_E_ddagger)**2))\n\n    # --- Step 3  4: Deviations and Confinement Penalties for All Points ---\n    discrepancies = []\n    \n    for point in dataset:\n        delta_E, delta_E_ddagger, r = point\n\n        # Observed deviation from the BEP line\n        delta_obs = delta_E_ddagger - (alpha * delta_E + beta)\n\n        # Entropic confinement penalty\n        if r > 0:\n            delta_G_conf = 3 * K_B * T * np.log(R_REF / r)\n        else:\n            delta_G_conf = np.inf \n\n        # Discrepancy between observation and theory\n        d = delta_obs - delta_G_conf\n        discrepancies.append(d)\n\n    # --- Step 5: Mean Absolute Discrepancy for High-Confinement Subset ---\n    # High-confinement subset is defined by r = 0.8 nm\n    high_confinement_indices = [i for i, p in enumerate(dataset) if p[2] = 0.8]\n    high_confinement_discrepancies = np.array([discrepancies[i] for i in high_confinement_indices])\n    \n    mean_abs_discrepancy = np.mean(np.abs(high_confinement_discrepancies))\n\n    # --- Step 6: Boundary Case Discrepancy ---\n    # Boundary case: delta_E = 0.00 eV and r = 0.6 nm\n    boundary_case_d = 0.0\n    for i, point in enumerate(dataset):\n        if point[0] == 0.00 and point[2] == 0.6:\n            boundary_case_d = discrepancies[i]\n            break\n\n    # --- Step 7: Boolean Check ---\n    # Check if at least half of high-confinement cases satisfy |d| = 0.03 eV\n    count_satisfying_condition = np.sum(np.abs(high_confinement_discrepancies) = 0.03)\n    is_condition_met = count_satisfying_condition >= (len(high_confinement_indices) / 2.0)\n\n    # --- Final Output Assembly ---\n    results = [\n        alpha,\n        beta,\n        training_rmse,\n        mean_abs_discrepancy,\n        boundary_case_d,\n        is_condition_met,\n    ]\n\n    # Print in the specified format\n    print(f\"[{results[0]},{results[1]},{results[2]},{results[3]},{results[4]},{results[5]}]\")\n\nsolve()\n```"
        }
    ]
}