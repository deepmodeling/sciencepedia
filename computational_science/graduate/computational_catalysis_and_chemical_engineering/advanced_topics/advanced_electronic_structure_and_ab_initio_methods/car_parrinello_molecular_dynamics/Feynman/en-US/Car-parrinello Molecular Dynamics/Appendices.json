{
    "hands_on_practices": [
        {
            "introduction": "The cornerstone of CPMD is the fictitious mass, $ \\mu $, which dictates the timescale of the fictitious electronic dynamics. To maintain the crucial adiabatic separation between the electronic and nuclear subsystems, $ \\mu $ must be chosen to be small enough to ensure the electrons respond almost instantaneously to nuclear motion. This first exercise guides you through a fundamental calculation to estimate the maximum safe value for $ \\mu $ based on the system's electronic band gap and characteristic ionic vibrational frequencies.",
            "id": "3741059",
            "problem": "Consider Car-Parrinello molecular dynamics (CPMD), where the electronic degrees of freedom are evolved with a fictitious kinetic term characterized by a mass-like parameter $\\mu$ to enforce adiabatic separation from the ionic motion. In CPMD, start from the standard Lagrangian structure in which the fictitious electronic kinetic energy scales as $\\mu \\sum |\\dot{\\psi}|^{2}$ and the electronic potential energy curvature near the ground state is set by the Born-Oppenheimer energy gap $\\Delta$. Using the harmonic approximation for small oscillations of the electronic variables and the separation requirement that the characteristic electronic angular frequency $\\omega_{e}$ should be at least ten times larger than the dominant ionic angular frequency $\\omega_{i}$, derive the constraint on $\\mu$ that guarantees $\\omega_{e}/\\omega_{i} \\geq 10$. Then, taking $\\Delta = 2\\ \\mathrm{eV}$ and $\\omega_{i} = 2 \\times 10^{13}\\ \\mathrm{s}^{-1}$, compute the corresponding upper bound $\\mu_{\\max}$ in $\\mathrm{J \\cdot s^{2}}$. State the numerical value of $\\mu_{\\max}$ and, based on it, interpret the safe range of $\\mu$ that meets the separation criterion. Express your final numerical answer for $\\mu_{\\max}$ in $\\mathrm{J \\cdot s^{2}}$ and round your answer to four significant figures.",
            "solution": "The problem as stated is scientifically grounded, well-posed, objective, and contains sufficient information for a unique solution. It describes a standard condition for ensuring adiabaticity in Car-Parrinello molecular dynamics (CPMD), a well-established method in computational physics. Therefore, the problem is valid, and we proceed with the solution.\n\nThe core principle of CPMD is to treat the electronic wavefunctions, $\\{\\psi_k\\}$, as classical degrees of freedom evolving in time, governed by a fictitious kinetic energy term. The Lagrangian for the fictitious electronic dynamics can be written as:\n$$L_e = \\frac{1}{2} \\mu \\sum_k \\int |\\dot{\\psi}_k(\\mathbf{r}, t)|^2 d\\mathbf{r} - E_{BO}[\\{\\psi_k\\}]$$\nwhere $\\mu$ is the fictitious mass, $\\dot{\\psi}_k$ is the time derivative of the $k$-th electronic orbital, and $E_{BO}$ is the Born-Oppenheimer energy surface, which serves as the potential energy for both the ions and the fictitious electronic system. The problem statement indicating that the kinetic energy \"scales as $\\mu \\sum |\\dot{\\psi}|^{2}$\" is interpreted in the context of this standard Lagrangian form, where the factor of $\\frac{1}{2}$ is conventional for a kinetic energy term.\n\nThe equation of motion for the electronic orbitals derived from this Lagrangian is:\n$$\\mu \\ddot{\\psi}_k = -\\frac{\\delta E_{BO}}{\\delta \\psi_k^*} + \\text{constraints}$$\nTo find the characteristic frequency of the electronic system, $\\omega_e$, we consider small oscillations around the electronic ground state. The potential energy $E_{BO}$ can be expanded quadratically around its minimum. The problem simplifies this by stating that the curvature of this potential energy is set by the energy gap, $\\Delta$, between the highest occupied and lowest unoccupied electronic states.\n\nWe can model the dynamics of the lowest-frequency electronic excitation mode as a simple harmonic oscillator. The \"mass\" of this oscillator is the fictitious mass $\\mu$. The effective \"spring constant\" $k_e$ is related to the energy gap $\\Delta$. A standard analysis of the linearized equations of motion for the electronic orbitals shows that the angular frequencies, $\\omega_{e, i \\to j}$, corresponding to an excitation from an occupied state $i$ to an unoccupied state $j$ with energy difference $\\epsilon_j - \\epsilon_i$, are given by:\n$$\\omega_{e, i \\to j}^2 = \\frac{2(\\epsilon_j - \\epsilon_i)}{\\mu}$$\nThe lowest and most critical frequency for maintaining adiabatic separation corresponds to the smallest energy gap, which is the Born-Oppenheimer gap $\\Delta$. Thus, the characteristic electronic frequency $\\omega_e$ is given by:\n$$\\omega_e^2 = \\frac{2\\Delta}{\\mu}$$\n\nThe problem requires an adiabatic separation between the electronic and ionic motion, specified by the condition that the electronic frequency must be significantly larger than the dominant ionic frequency $\\omega_i$:\n$$\\frac{\\omega_e}{\\omega_i} \\geq 10$$\nSquaring both sides of this inequality gives:\n$$\\frac{\\omega_e^2}{\\omega_i^2} \\geq 100$$\nSubstituting our expression for $\\omega_e^2$:\n$$\\frac{2\\Delta / \\mu}{\\omega_i^2} \\geq 100$$\nWe can now solve for the constraint on the fictitious mass $\\mu$:\n$$\\frac{2\\Delta}{\\omega_i^2} \\geq 100 \\mu$$\n$$\\mu \\leq \\frac{2\\Delta}{100 \\omega_i^2}$$\n$$\\mu \\leq \\frac{\\Delta}{50 \\omega_i^2}$$\nThis inequality defines the safe range for $\\mu$ that ensures adiabatic separation. The upper bound on $\\mu$ is therefore:\n$$\\mu_{\\max} = \\frac{\\Delta}{50 \\omega_i^2}$$\n\nNow, we compute the numerical value of $\\mu_{\\max}$ using the provided data. First, all values must be converted to base SI units.\nThe energy gap is given as $\\Delta = 2\\ \\mathrm{eV}$. Using the elementary charge $e \\approx 1.602176634 \\times 10^{-19}\\ \\mathrm{C}$, we convert electron-volts to Joules:\n$$\\Delta = 2 \\times (1.602176634 \\times 10^{-19}\\ \\mathrm{J}) = 3.204353268 \\times 10^{-19}\\ \\mathrm{J}$$\nThe dominant ionic frequency is given as $\\omega_i = 2 \\times 10^{13}\\ \\mathrm{s}^{-1}$.\n\nSubstitute these values into the expression for $\\mu_{\\max}$:\n$$\\mu_{\\max} = \\frac{3.204353268 \\times 10^{-19}\\ \\mathrm{J}}{50 \\times (2 \\times 10^{13}\\ \\mathrm{s}^{-1})^2}$$\n$$\\mu_{\\max} = \\frac{3.204353268 \\times 10^{-19}\\ \\mathrm{J}}{50 \\times (4 \\times 10^{26}\\ \\mathrm{s}^{-2})}$$\n$$\\mu_{\\max} = \\frac{3.204353268 \\times 10^{-19}\\ \\mathrm{J}}{200 \\times 10^{26}\\ \\mathrm{s}^{-2}}$$\n$$\\mu_{\\max} = \\frac{3.204353268 \\times 10^{-19}}{2 \\times 10^{28}}\\ \\mathrm{J \\cdot s^2}$$\n$$\\mu_{\\max} = 1.602176634 \\times 10^{-47}\\ \\mathrm{J \\cdot s^2}$$\nRounding the result to four significant figures as requested:\n$$\\mu_{\\max} \\approx 1.602 \\times 10^{-47}\\ \\mathrm{J \\cdot s^2}$$\n\nThe safe range for $\\mu$ that meets the separation criterion is $0 < \\mu \\leq \\mu_{\\max}$. A value of $\\mu$ larger than $\\mu_{\\max}$ would cause the fictitious electronic system to oscillate too slowly, leading to a breakdown of adiabatic separation and unphysical heating of the electronic system. A value of $\\mu$ that is too close to zero, while satisfying the adiabaticity condition, would require an impractically small time step for numerical integration of the equations of motion, rendering the simulation computationally infeasible. The derived constraint specifically addresses the physical requirement of adiabaticity.",
            "answer": "$$\\boxed{1.602 \\times 10^{-47}}$$"
        },
        {
            "introduction": "With the physical timescale set by the fictitious mass $ \\mu $, the next critical task is to choose a numerical integration time step, $ \\Delta t $, that guarantees a stable and energy-conserving trajectory. A $ \\Delta t $ that is too large introduces significant error, leading to an unphysical drift in the total energy and compromising the simulation's validity. This practice introduces a systematic, data-driven protocol for determining the optimal $ \\Delta t $ by modeling its effect on energy conservation, a crucial step for any production-level simulation.",
            "id": "3871873",
            "problem": "You are designing a convergence study for Car-Parrinello molecular dynamics (CPMD), which integrates ionic and electronic equations of motion derived from the extended Car-Parrinello Lagrangian using second-order time-reversible integrators. Starting from the following fundamental bases:\n\n- The Lagrangian mechanics and Newton’s equations state that the time evolution of generalized coordinates follows from extremizing the action, leading to equations of motion that, when discretized by a second-order method, exhibit a local truncation error of order $\\mathcal{O}(\\Delta t^{3})$ and a global discretization error of order $\\mathcal{O}(\\Delta t^{2})$.\n- The Störmer-Verlet (velocity-Verlet) scheme is symplectic and time-reversible, conserving a nearby “shadow” Hamiltonian such that the observed total energy drift over long times in a conservative system behaves as a smooth function of $\\Delta t^{2}$ for sufficiently small $\\Delta t$.\n\nYour task is to formalize a convergence protocol to select a time step $\\Delta t$ in femtoseconds (fs) that limits the systematic drift in the total energy over a simulation of $50$ picoseconds (ps). Assume the long-time average drift rate of total energy per picosecond, denoted $d(\\Delta t)$ in milli-electronvolts per picosecond (meV/ps), can be approximated for sufficiently small $\\Delta t$ by a linear model in $\\Delta t^{2}$:\n- $d(\\Delta t) \\approx a \\,\\Delta t^{2} + b$, where $a$ and $b$ are constants estimated from measurements.\n\nDesign a program that:\n1. Fits the linear model $d(\\Delta t) = a \\,\\Delta t^{2} + b$ by ordinary least squares to measured pairs $\\{(\\Delta t_i, d_i)\\}$.\n2. Given a maximum allowable total drift over $50$ ps, denoted $D_{\\max}$ in meV, computes the maximum permissible $\\Delta t$ such that the predicted drift over $50$ ps, $50 \\times d(\\Delta t)$, does not exceed $D_{\\max}$. If $a \\le 0$, use the rule: if $b \\le D_{\\max}/50$ then the largest allowable $\\Delta t$ is the upper bound of the admissible interval; otherwise no feasible $\\Delta t$ exists within the interval.\n3. Enforces that the chosen $\\Delta t$ must lie within a closed interval $[\\Delta t_{\\min}, \\Delta t_{\\max}]$ and must be selected on a discrete grid with spacing $\\delta$ fs. The algorithm should:\n   - Compute the continuous candidate $\\Delta t^{\\star} = \\sqrt{\\max\\{(D_{\\max}/50 - b)/a,\\,0\\}}$ for $a>0$.\n   - Clip to $\\Delta t^{\\star\\star} = \\min\\{\\Delta t^{\\star}, \\Delta t_{\\max}\\}$.\n   - Round down to the nearest grid point inside $[\\Delta t_{\\min}, \\Delta t_{\\max}]$. Explicitly, define $n = \\left\\lfloor \\dfrac{\\Delta t^{\\star\\star} - \\Delta t_{\\min}}{\\delta} \\right\\rfloor$ and propose $\\Delta t_{\\text{grid}} = \\Delta t_{\\min} + n\\,\\delta$.\n   - If $\\Delta t_{\\text{grid}} < \\Delta t_{\\min}$ or $50 \\times d(\\Delta t_{\\text{grid}}) > D_{\\max}$, decrement by $\\delta$ until feasibility is reached or report infeasible if $\\Delta t_{\\text{grid}}$ falls below $\\Delta t_{\\min}$.\n4. Returns the recommended $\\Delta t$ in fs rounded to three decimals. If no feasible $\\Delta t$ exists, return $-1.000$.\n\nAngle units are not used. All physical units must be handled as specified: $\\Delta t$ in fs, drift rate in meV/ps, total drift in meV over $50$ ps.\n\nTest Suite and Input Data:\nFor each test case, you are provided with:\n- A list of measured time steps in fs: $[\\Delta t_1,\\dots,\\Delta t_m]$.\n- A list of measured average drift rates in meV/ps: $[d_1,\\dots,d_m]$, where $d_i$ corresponds to $\\Delta t_i$.\n- A maximum allowable total drift over $50$ ps, $D_{\\max}$ in meV.\n- A lower bound $\\Delta t_{\\min}$ in fs.\n- An upper bound $\\Delta t_{\\max}$ in fs.\n- A grid spacing $\\delta$ in fs.\n\nImplement the algorithm and apply it to the following four test cases:\n\n- Case $1$:\n  - $\\Delta t$ (fs): $[0.06,\\,0.10,\\,0.14,\\,0.18]$\n  - $d$ (meV/ps): $[0.0134,\\,0.0420,\\,0.0754,\\,0.1306]$\n  - $D_{\\max}$ (meV over $50$ ps): $5.0$\n  - $\\Delta t_{\\min}$ (fs): $0.040$\n  - $\\Delta t_{\\max}$ (fs): $0.200$\n  - $\\delta$ (fs): $0.001$\n\n- Case $2$:\n  - $\\Delta t$ (fs): $[0.08,\\,0.16,\\,0.24,\\,0.30]$\n  - $d$ (meV/ps): $[0.00736,\\,0.01574,\\,0.02834,\\,0.04060]$\n  - $D_{\\max}$ (meV over $50$ ps): $2.0$\n  - $\\Delta t_{\\min}$ (fs): $0.050$\n  - $\\Delta t_{\\max}$ (fs): $0.300$\n  - $\\delta$ (fs): $0.001$\n\n- Case $3$:\n  - $\\Delta t$ (fs): $[0.05,\\,0.08,\\,0.11,\\,0.14]$\n  - $d$ (meV/ps): $[0.01195,\\,0.01750,\\,0.02645,\\,0.03720]$\n  - $D_{\\max}$ (meV over $50$ ps): $0.5$\n  - $\\Delta t_{\\min}$ (fs): $0.050$\n  - $\\Delta t_{\\max}$ (fs): $0.200$\n  - $\\delta$ (fs): $0.001$\n\n- Case $4$:\n  - $\\Delta t$ (fs): $[0.10,\\,0.20,\\,0.35,\\,0.50]$\n  - $d$ (meV/ps): $[0.00230,\\,0.00275,\\,0.00450,\\,0.00690]$\n  - $D_{\\max}$ (meV over $50$ ps): $10.0$\n  - $\\Delta t_{\\min}$ (fs): $0.050$\n  - $\\Delta t_{\\max}$ (fs): $0.500$\n  - $\\delta$ (fs): $0.001$\n\nFinal Output Format:\nYour program should produce a single line of output containing a list of four floats, each being the recommended $\\Delta t$ in fs for the corresponding test case, rounded to three decimals. If no feasible $\\Delta t$ exists for a case, output $-1.000$ for that case. The format must be exactly a comma-separated list enclosed in square brackets, for example, $[0.158,0.296,-1.000,0.500]$.",
            "solution": "The problem is valid. It presents a scientifically grounded, well-posed, and objective task based on fundamental principles of numerical integration and molecular dynamics simulations. The problem is to devise a computational protocol to determine an optimal, yet safe, integration time step, $\\Delta t$, for a Car-Parrinello molecular dynamics (CPMD) simulation.\n\nThe protocol is based on a physical model of the numerical error. For a second-order time-reversible integrator like the Störmer-Verlet scheme, the global error in a conserved quantity, such as total energy, is known to scale with the square of the time step, i.e., as $\\mathcal{O}(\\Delta t^2)$. The problem formalizes this by postulating a model for the average energy drift rate, $d(\\Delta t)$, as a function of the time step:\n$$\nd(\\Delta t) \\approx a \\Delta t^2 + b\n$$\nwhere $d(\\Delta t)$ is in units of meV/ps and $\\Delta t$ is in fs. The parameters $a$ and $b$ are empirical constants to be determined from simulation data.\n\nThe solution process for each test case involves three main stages:\n\n1.  **Model Parameterization via Least-Squares Fitting**:\n    The first step is to determine the coefficients $a$ and $b$ of the linear model. We are given a set of $m$ measured data points $(\\Delta t_i, d_i)$. We want to fit the model $d_i = a (\\Delta t_i^2) + b$. This is a linear regression problem if we define a new predictor variable $x_i = \\Delta t_i^2$. The model becomes $d_i = a x_i + b$. The coefficients $a$ and $b$ can be found by minimizing the sum of squared residuals using Ordinary Least Squares (OLS). In matrix notation, we solve the system $X\\beta = \\mathbf{d}$ for $\\beta = [a, b]^T$, where $\\mathbf{d}$ is the vector of observed drift rates and $X$ is the design matrix:\n    $$\n    X = \\begin{pmatrix} \\Delta t_1^2 & 1 \\\\ \\Delta t_2^2 & 1 \\\\ \\vdots & \\vdots \\\\ \\Delta t_m^2 & 1 \\end{pmatrix}, \\quad \\beta = \\begin{pmatrix} a \\\\ b \\end{pmatrix}, \\quad \\mathbf{d} = \\begin{pmatrix} d_1 \\\\ d_2 \\\\ \\vdots \\\\ d_m \\end{pmatrix}\n    $$\n    The OLS solution is given by $\\hat{\\beta} = (X^T X)^{-1} X^T \\mathbf{d}$. This is implemented computationally using a standard linear algebra library function.\n\n2.  **Derivation of Maximum Continuous Time Step**:\n    The core constraint is that the total energy drift over the simulation duration of $50$ ps must not exceed a specified maximum, $D_{\\max}$. The total predicted drift is $50 \\times d(\\Delta t)$. The constraint is thus:\n    $$\n    50 \\times (a \\Delta t^2 + b) \\le D_{\\max}\n    $$\n    This is equivalent to constraining the drift rate:\n    $$\n    d(\\Delta t) \\le \\frac{D_{\\max}}{50} \\equiv d_{\\text{max}}\n    $$\n    The solution to this inequality depends on the sign of $a$.\n    -   If $a > 0$, the drift rate is an increasing function of $\\Delta t$. The inequality becomes $\\Delta t^2 \\le (d_{\\text{max}} - b) / a$. If $d_{\\text{max}} - b < 0$, no positive $\\Delta t$ can satisfy the constraint, and the problem is infeasible. Otherwise, the maximum continuous time step allowed by the drift model is $\\Delta t^{\\star} = \\sqrt{(d_{\\text{max}} - b) / a}$.\n    -   If $a \\le 0$, the drift rate is a non-increasing function of $\\Delta t$. The drift is highest at $\\Delta t=0$, where it is equal to $b$. If $b > d_{\\text{max}}$, the drift is always too high, and the problem is infeasible. If $b \\le d_{\\text{max}}$, the drift constraint is satisfied for all $\\Delta t \\ge 0$.\n    In all cases, the solution must also respect the explicit bounds $[\\Delta t_{\\min}, \\Delta t_{\\max}]$. Therefore, we find a candidate upper bound, $\\Delta t^{\\star\\star}$, by taking the minimum of the model-derived bound (if it exists) and the explicit upper bound $\\Delta t_{\\max}$.\n\n3.  **Discretization and Final Selection**:\n    The final step is to find the largest permissible $\\Delta t$ that lies on a discrete grid with spacing $\\delta$ within the interval $[\\Delta t_{\\min}, \\Delta t_{\\max}]$.\n    First, we determine the highest possible grid point that is less than or equal to our candidate upper bound, $\\Delta t^{\\star\\star}$. This is calculated as:\n    $$\n    n = \\left\\lfloor \\frac{\\Delta t^{\\star\\star} - \\Delta t_{\\min}}{\\delta} \\right\\rfloor\n    $$\n    The initial candidate on the grid is $\\Delta t_{\\text{grid}} = \\Delta t_{\\min} + n\\delta$. If this calculation results in $\\Delta t_{\\text{grid}} < \\Delta t_{\\min}$ (which happens if $\\Delta t^{\\star\\star} < \\Delta t_{\\min}$), no feasible solution exists in the allowed interval.\n    Otherwise, we start a search downwards from $\\Delta t_{\\text{grid}}$. We check if the drift constraint $50 \\times d(\\Delta t_{\\text{grid}}) \\le D_{\\max}$ is satisfied. If it is, $\\Delta t_{\\text{grid}}$ is our answer, as it is the largest grid point that is guaranteed to be safe. If it is not (which could happen due to the approximate nature of the model or floating-point inaccuracies), we decrement the time step by $\\delta$ and repeat the check. This process continues until a feasible $\\Delta t$ is found or the time step falls below $\\Delta t_{\\min}$. If the search fails to find a feasible time step, the result is reported as infeasible ($-1.000$).\n\nThis structured procedure ensures that the selected $\\Delta t$ is the largest possible value that rigorously adheres to all specified physical and numerical constraints, providing a robust and optimal choice for the simulation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"dt_measured\": [0.06, 0.10, 0.14, 0.18],\n            \"d_measured\": [0.0134, 0.0420, 0.0754, 0.1306],\n            \"D_max\": 5.0,\n            \"dt_min\": 0.040,\n            \"dt_max\": 0.200,\n            \"delta\": 0.001\n        },\n        # Case 2\n        {\n            \"dt_measured\": [0.08, 0.16, 0.24, 0.30],\n            \"d_measured\": [0.00736, 0.01574, 0.02834, 0.04060],\n            \"D_max\": 2.0,\n            \"dt_min\": 0.050,\n            \"dt_max\": 0.300,\n            \"delta\": 0.001\n        },\n        # Case 3\n        {\n            \"dt_measured\": [0.05, 0.08, 0.11, 0.14],\n            \"d_measured\": [0.01195, 0.01750, 0.02645, 0.03720],\n            \"D_max\": 0.5,\n            \"dt_min\": 0.050,\n            \"dt_max\": 0.200,\n            \"delta\": 0.001\n        },\n        # Case 4\n        {\n            \"dt_measured\": [0.10, 0.20, 0.35, 0.50],\n            \"d_measured\": [0.00230, 0.00275, 0.00450, 0.00690],\n            \"D_max\": 10.0,\n            \"dt_min\": 0.050,\n            \"dt_max\": 0.500,\n            \"delta\": 0.001\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_optimal_dt(case)\n        results.append(f\"{result:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef find_optimal_dt(case_data):\n    \"\"\"\n    Solves for the optimal time step for a single test case.\n    \"\"\"\n    dt_measured = np.array(case_data[\"dt_measured\"])\n    d_measured = np.array(case_data[\"d_measured\"])\n    D_max = case_data[\"D_max\"]\n    dt_min = case_data[\"dt_min\"]\n    dt_max = case_data[\"dt_max\"]\n    delta = case_data[\"delta\"]\n\n    # 1. Fit the linear model d(dt) = a*dt^2 + b using ordinary least squares.\n    x_var = dt_measured**2\n    # Design matrix for OLS: [x, 1]\n    A = np.vstack([x_var, np.ones(len(x_var))]).T\n    a, b = np.linalg.lstsq(A, d_measured, rcond=None)[0]\n\n    # 2. Compute the maximum permissible dt based on the drift model.\n    d_max_rate = D_max / 50.0\n\n    dt_upper_bound = None\n    infeasible = False\n\n    if a <= 0:\n        # If drift is non-increasing, feasibility is determined by the baseline drift b.\n        if b > d_max_rate:\n            infeasible = True\n        else:\n            # The drift constraint is met for all dt. The limit is dt_max.\n            dt_upper_bound = dt_max\n    else:  # a > 0\n        # Drift is increasing. Solve a*dt^2 + b <= d_max_rate.\n        rhs = d_max_rate - b\n        if rhs < 0:\n            infeasible = True\n        else:\n            dt_star_continuous = np.sqrt(rhs / a)\n            # The candidate dt must also be within the allowed interval.\n            dt_upper_bound = min(dt_star_continuous, dt_max)\n\n    if infeasible:\n        return -1.0\n\n    # 3. Enforce grid constraints and find the largest feasible discrete dt.\n    \n    # If the continuous upper bound is already below the minimum allowed dt, no solution exists.\n    if dt_upper_bound < dt_min:\n        return -1.0\n\n    # Round down to the nearest grid point.\n    # n = floor((dt_upper_bound - dt_min) / delta)\n    # dt_grid = dt_min + n * delta\n    # This formula is robust. If dt_upper_bound is very close to a grid point,\n    # floating point issues might cause it to round to the point below.\n    # The subsequent search loop corrects for any such issues.\n    n = np.floor((dt_upper_bound - dt_min) / delta)\n    current_dt = dt_min + n * delta\n\n    # Iteratively check from the rounded-down candidate, decrementing by delta.\n    # This loop starts from the highest possible grid point and moves down,\n    # so the first feasible point found is the answer.\n    while current_dt >= dt_min - 1e-9: # Use small tolerance for float comparison\n        predicted_drift_rate = a * current_dt**2 + b\n        total_drift = 50.0 * predicted_drift_rate\n        \n        if total_drift <= D_max:\n            return current_dt\n\n        current_dt -= delta\n\n    # If the loop completes without finding a feasible dt.\n    return -1.0\n\nsolve()\n```"
        },
        {
            "introduction": "Even a well-parameterized simulation can be pushed to its limits by rapid physical events, such as the fast approach of a molecule during chemisorption, which can challenge the adiabatic approximation. In these scenarios, the system can be driven out of the adiabatic regime, leading to an unphysical transfer of energy to the fictitious electronic degrees of freedom. This final exercise uses a simplified but powerful model to simulate such a breakdown of adiabaticity, teaching you how to quantify this effect by monitoring the electronic kinetic energy.",
            "id": "3871910",
            "problem": "Consider the detection of adiabaticity breakdown in Car-Parrinello molecular dynamics (CPMD) for a chemisorption event such as carbon monoxide on platinum $(\\mathrm{CO}/\\mathrm{Pt}(111))$. In CPMD, the electronic degrees of freedom are assigned a fictitious mass and evolved alongside nuclei so that the electrons remain close to the instantaneous Born-Oppenheimer ground state. During rapid chemisorption, the acceleration of the nuclear coordinate can drive the electronic subsystem out of the adiabatic regime, which can be quantified by the growth of the electronic kinetic energy. Design a reduced, universal test based on a simplified CPMD-inspired Lagrangian, numerically simulate it, and report a dimensionless breakdown metric across a set of test cases.\n\nModel assumptions and definitions:\n- Use a single electronic collective coordinate $\\,\\psi(t)\\,$ representing the dominant occupied Kohn-Sham subspace response and a single nuclear reaction coordinate $\\,s(t)\\,$ representing the approach distance of the adsorbate to the surface.\n- Adopt the reduced Car-Parrinello-like Lagrangian\n$$\nL(\\psi,\\dot{\\psi},s,\\dot{s})=\\frac{\\mu}{2}\\,\\dot{\\psi}^2+\\frac{M}{2}\\,\\dot{s}^2 - U(\\psi,s),\n$$\nwhere $\\,\\mu\\,$ is the fictitious electronic mass and $\\,M\\,$ is the nuclear reduced mass for the reaction coordinate. The potential $\\,U(\\psi,s)\\,$ contains a harmonic term that penalizes deviations of $\\,\\psi\\,$ from an $\\,s$-dependent ground-state reference $\\,\\psi_{\\mathrm{eq}}(s)\\,$,\n$$\nU(\\psi,s)=\\frac{k_e}{2}\\left(\\psi-\\psi_{\\mathrm{eq}}(s)\\right)^2+V_{\\mathrm{ads}}(s),\n$$\nwith $\\,k_e\\,$ a stiffness parameter. For this test, prescribe the nuclear trajectory with a constant approach speed so that $\\,\\dot{s}(t)=-v\\,$ and $\\,s(t)=s_0-v\\,t\\,$ until $\\,s_f\\,$ is reached, and set $\\,V_{\\mathrm{ads}}(s)\\,$ to an arbitrary reference that does not enter the electronic equation of motion under the prescribed $\\,s(t)\\,$. Define\n$$\n\\psi_{\\mathrm{eq}}(s) = A\\,\\tanh\\!\\left(\\alpha\\,(s_{\\mathrm{ref}}-s)\\right),\n$$\nwith $\\,A\\,$ the amplitude, $\\,\\alpha\\,$ the steepness, and $\\,s_{\\mathrm{ref}}\\,$ a reference separation at which the electronic structure begins to change rapidly.\n\nQuantities to compute:\n- The electronic kinetic energy at time $\\,t\\,$ is\n$$\nE_{\\mathrm{elec}}(t)=\\frac{\\mu}{2}\\,\\dot{\\psi}(t)^2.\n$$\n- The ionic kinetic energy for the prescribed trajectory is constant,\n$$\nK_{\\mathrm{ion}}=\\frac{M}{2}\\,v^2.\n$$\n- Define the dimensionless breakdown metric\n$$\nR_{\\max}=\\max_{t\\in[0,T]}\\frac{E_{\\mathrm{elec}}(t)}{K_{\\mathrm{ion}}},\n$$\nwhere $\\,T=(s_0-s_f)/v\\,$ is the total approach time. Larger $\\,R_{\\max}\\,$ indicates stronger deviation from adiabatic following; values $\\,R_{\\max}\\,$ comparable to or exceeding $\\,0.1\\,$ are indicative of breakdown.\n\nTask:\n- Starting only from the Euler–Lagrange equations applied to the above $\\,L\\,$ and the prescribed $\\,s(t)\\,$, derive the time evolution equation for $\\,\\psi(t)\\,$.\n- Implement a stable, explicit time integration algorithm for $\\,\\psi(t)\\,$ on $\\,t\\in[0,T]\\,$ using a constant time step $\\,\\Delta t\\,$. Initialize with $\\,\\psi(0)=\\psi_{\\mathrm{eq}}(s_0)\\,$ and $\\,\\dot{\\psi}(0)=0\\,$.\n- Compute $\\,R_{\\max}\\,$ for each given parameter set. Report all energies in Hartree, time in atomic units, and the final metric as a dimensionless float.\n\nUnit specifications:\n- Energies must be computed and interpreted in Hartree.\n- Time must be computed in atomic units.\n- The final breakdown metric $\\,R_{\\max}\\,$ is dimensionless and must be reported as a floating-point number.\n\nTest suite:\nUse the following parameter sets, which vary the fictitious electronic mass, the time step, the approach speed, and the sharpness of the electronic response. In each case, set $\\,s_{\\mathrm{ref}}=2.5\\,$, $\\,k_e=1.0\\,$, and $\\,M=50.0\\,$.\n1. Case $\\,1\\,$ (happy path, slow approach): $\\,\\mu=400.0\\,$, $\\,\\Delta t=0.005\\,$, $\\,v=0.001\\,$, $\\,s_0=3.0\\,$, $\\,s_f=2.0\\,$, $\\,A=0.5\\,$, $\\,\\alpha=5.0\\,$.\n2. Case $\\,2\\,$ (moderate speed and stiffness): $\\,\\mu=200.0\\,$, $\\,\\Delta t=0.010\\,$, $\\,v=0.003\\,$, $\\,s_0=3.0\\,$, $\\,s_f=2.0\\,$, $\\,A=0.8\\,$, $\\,\\alpha=7.0\\,$.\n3. Case $\\,3\\,$ (fast approach, sharper electronic change): $\\,\\mu=100.0\\,$, $\\,\\Delta t=0.020\\,$, $\\,v=0.010\\,$, $\\,s_0=3.0\\,$, $\\,s_f=2.0\\,$, $\\,A=1.0\\,$, $\\,\\alpha=10.0\\,$.\n4. Case $\\,4\\,$ (aggressive parameters, potential breakdown): $\\,\\mu=50.0\\,$, $\\,\\Delta t=0.050\\,$, $\\,v=0.020\\,$, $\\,s_0=3.0\\,$, $\\,s_f=2.0\\,$, $\\,A=1.2\\,$, $\\,\\alpha=12.0\\,$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test suite (e.g., $[\\text{result1},\\text{result2},\\text{result3},\\text{result4}]$). Each result must be the floating-point value of $\\,R_{\\max}\\,$ for the corresponding case.",
            "solution": "The problem has been analyzed and is deemed valid. It is scientifically grounded in the principles of classical mechanics and the Car-Parrinello molecular dynamics (CPMD) methodology. The problem is well-posed, with all necessary parameters, initial conditions, and a clear objective provided. It is presented objectively and is free of contradictions or ambiguities.\n\nThe core of the problem is to solve the equation of motion for a single electronic collective coordinate, $\\psi(t)$, whose behavior is governed by a simplified CPMD-like Lagrangian, and to quantify the system's deviation from adiabaticity. The nuclear motion, described by a coordinate $s(t)$, is prescribed as a constant-velocity approach.\n\nFirst, we derive the equation of motion for $\\psi(t)$ using the Euler-Lagrange equation:\n$$\n\\frac{d}{dt}\\left(\\frac{\\partial L}{\\partial \\dot{\\psi}}\\right) - \\frac{\\partial L}{\\partial \\psi} = 0\n$$\nThe Lagrangian is given by:\n$$\nL(\\psi,\\dot{\\psi},s,\\dot{s})=\\frac{\\mu}{2}\\,\\dot{\\psi}^2+\\frac{M}{2}\\,\\dot{s}^2 - U(\\psi,s)\n$$\nwith the potential energy:\n$$\nU(\\psi,s)=\\frac{k_e}{2}\\left(\\psi-\\psi_{\\mathrm{eq}}(s)\\right)^2+V_{\\mathrm{ads}}(s)\n$$\nThe necessary partial derivatives of $L$ with respect to $\\psi$ and $\\dot{\\psi}$ are:\n$$\n\\frac{\\partial L}{\\partial \\dot{\\psi}} = \\mu\\dot{\\psi}\n$$\n$$\n\\frac{\\partial L}{\\partial \\psi} = -\\frac{\\partial U}{\\partial \\psi} = -\\frac{\\partial}{\\partial \\psi}\\left[\\frac{k_e}{2}(\\psi - \\psi_{\\mathrm{eq}}(s))^2\\right] = -k_e(\\psi - \\psi_{\\mathrm{eq}}(s))\n$$\nSubstituting these into the Euler-Lagrange equation yields:\n$$\n\\frac{d}{dt}(\\mu\\dot{\\psi}) - \\left[-k_e(\\psi - \\psi_{\\mathrm{eq}}(s))\\right] = 0\n$$\n$$\n\\mu\\ddot{\\psi}(t) + k_e(\\psi(t) - \\psi_{\\mathrm{eq}}(s(t))) = 0\n$$\nThis can be rewritten as a second-order ordinary differential equation (ODE) for $\\psi(t)$:\n$$\n\\ddot{\\psi}(t) = -\\frac{k_e}{\\mu}\\left(\\psi(t) - \\psi_{\\mathrm{eq}}(s(t))\\right)\n$$\nThis equation describes a harmonic oscillator with a natural frequency $\\omega_e = \\sqrt{k_e/\\mu}$. The equilibrium point, $\\psi_{\\mathrm{eq}}(s(t))$, is time-dependent due to the prescribed nuclear motion $s(t) = s_0 - v t$, which acts as a driving force on the electronic subsystem. The system is adiabatic when the electronic coordinate $\\psi(t)$ can accurately follow the moving equilibrium $\\psi_{\\mathrm{eq}}(s(t))$. This occurs when the characteristic frequency of the driving motion is much smaller than the natural frequency of the electronic oscillator, a condition which can be expressed as $\\mu(v\\alpha)^2 \\ll k_e$.\n\nTo solve this ODE numerically, we employ the Velocity Verlet algorithm, a time-reversible and symplectic integrator commonly used in molecular dynamics for its numerical stability and accuracy. Let $\\psi_n$, $\\dot{\\psi}_n$, and $a_n = \\ddot{\\psi}_n$ represent the position, velocity, and acceleration of the coordinate $\\psi$ at time $t_n = n\\Delta t$. The state at the next timestep $t_{n+1}$ is computed as follows:\n$1$. Update the position:\n$$\n\\psi_{n+1} = \\psi_n + \\dot{\\psi}_n \\Delta t + \\frac{1}{2} a_n (\\Delta t)^2\n$$\n$2$. Calculate the new acceleration $a_{n+1}$. This requires the new nuclear position $s_{n+1} = s(t_{n+1})$:\n$$\na_{n+1} = -\\frac{k_e}{\\mu}\\left(\\psi_{n+1} - \\psi_{\\mathrm{eq}}(s_{n+1})\\right)\n$$\n$3$. Update the velocity:\n$$\n\\dot{\\psi}_{n+1} = \\dot{\\psi}_n + \\frac{1}{2}(a_n + a_{n+1})\\Delta t\n$$\nThe simulation starts from the specified initial conditions: $\\psi(0) = \\psi_{\\mathrm{eq}}(s_0)$ and $\\dot{\\psi}(0) = 0$. This implies that the initial acceleration $a_0$ is zero. The simulation proceeds for a total time $T = (s_0 - s_f)/v$.\n\nThroughout the simulation, we monitor the electronic kinetic energy, $E_{\\mathrm{elec}}(t) = \\frac{\\mu}{2}\\dot{\\psi}(t)^2$. The maximum value of this energy, $\\max_{t} E_{\\mathrm{elec}}(t)$, is recorded. Finally, this maximum is normalized by the constant ionic kinetic energy, $K_{\\mathrm{ion}} = \\frac{M}{2}v^2$, to compute the dimensionless breakdown metric:\n$$\nR_{\\max} = \\frac{\\max_{t \\in [0,T]} E_{\\mathrm{elec}}(t)}{K_{\\mathrm{ion}}}\n$$\nThis procedure is repeated for each of the four parameter sets provided in the test suite.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(mu, dt, v, s0, sf, A, alpha, ke, M, s_ref):\n    \"\"\"\n    Runs a single simulation for a given set of parameters.\n\n    This function integrates the equation of motion for the electronic coordinate\n    psi(t) using the Velocity Verlet algorithm and computes the breakdown metric R_max.\n    \"\"\"\n    # Calculate total simulation time, ionic kinetic energy, and number of steps\n    if v <= 0:\n        # Avoid division by zero if v is non-positive.\n        return 0.0\n    T = (s0 - sf) / v\n    K_ion = 0.5 * M * v**2\n    if K_ion == 0:\n        # Avoid division by zero if there's no ionic motion.\n        return 0.0\n    \n    num_steps = int(T / dt)\n\n    # Initial conditions at t=0\n    s = s0\n    psi_eq_val = A * np.tanh(alpha * (s_ref - s))\n    psi = psi_eq_val\n    psi_dot = 0.0\n    \n    # The initial acceleration is zero because psi(0) = psi_eq(s_0)\n    accel = 0.0\n\n    max_E_elec = 0.0\n\n    # Main integration loop using the Velocity Verlet algorithm\n    for i in range(num_steps):\n        # Step 1: Update position-like coordinate psi\n        psi = psi + psi_dot * dt + 0.5 * accel * (dt**2)\n\n        # Step 2: Calculate new acceleration\n        # First, find the new nuclear coordinate s at time t + dt\n        t_new = (i + 1) * dt\n        s_new = s0 - v * t_new\n        \n        # Then, find the new equilibrium psi and the new acceleration\n        psi_eq_new = A * np.tanh(alpha * (s_ref - s_new))\n        accel_new = -(ke / mu) * (psi - psi_eq_new)\n\n        # Step 3: Update velocity-like coordinate psi_dot\n        psi_dot = psi_dot + 0.5 * (accel + accel_new) * dt\n        \n        # Prepare for the next iteration\n        accel = accel_new\n        \n        # Calculate instantaneous electronic kinetic energy and update the maximum\n        E_elec = 0.5 * mu * (psi_dot**2)\n        if E_elec > max_E_elec:\n            max_E_elec = E_elec\n    \n    # Calculate the final dimensionless breakdown metric\n    R_max = max_E_elec / K_ion\n    return R_max\n\ndef solve():\n    \"\"\"\n    Defines the test cases and runs the simulation for each to generate the final output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path, slow approach)\n        {'mu': 400.0, 'dt': 0.005, 'v': 0.001, 's0': 3.0, 'sf': 2.0, 'A': 0.5, 'alpha': 5.0},\n        # Case 2 (moderate speed and stiffness)\n        {'mu': 200.0, 'dt': 0.010, 'v': 0.003, 's0': 3.0, 'sf': 2.0, 'A': 0.8, 'alpha': 7.0},\n        # Case 3 (fast approach, sharper electronic change)\n        {'mu': 100.0, 'dt': 0.020, 'v': 0.010, 's0': 3.0, 'sf': 2.0, 'A': 1.0, 'alpha': 10.0},\n        # Case 4 (aggressive parameters, potential breakdown)\n        {'mu': 50.0,  'dt': 0.050, 'v': 0.020, 's0': 3.0, 'sf': 2.0, 'A': 1.2, 'alpha': 12.0},\n    ]\n\n    # Shared parameters for all test cases\n    common_params = {'ke': 1.0, 'M': 50.0, 's_ref': 2.5}\n\n    results = []\n    for case in test_cases:\n        params = {**case, **common_params}\n        result = run_simulation(**params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}