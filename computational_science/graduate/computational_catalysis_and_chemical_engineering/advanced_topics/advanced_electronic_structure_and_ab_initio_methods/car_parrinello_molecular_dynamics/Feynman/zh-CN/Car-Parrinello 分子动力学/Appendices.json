{
    "hands_on_practices": [
        {
            "introduction": "Car-Parrinello分子动力学（CPMD）的核心是绝热近似，即虚拟的电子动力学必须比离子运动快得多，以确保电子始终保持在瞬时基态附近。这个练习将指导你如何基于系统的基本物理属性——电子能隙和离子振动频率——来估算一个关键参数，即伪质量 $\\mu$，从而在模拟开始前就确保满足绝热分离的条件。通过这个计算，你将掌握设置稳定CPMD模拟的首要步骤。",
            "id": "3741059",
            "problem": "考虑Car-Parrinello分子动力学（CPMD），其中电子自由度通过一个虚构的动能项进行演化，该动能项由一个类质量参数 $\\mu$ 表征，以强制实现与离子运动的绝热分离。在CPMD中，从标准的拉格朗日结构出发，其中虚构电子动能正比于 $\\mu \\sum |\\dot{\\psi}|^{2}$，并且基态附近的电子势能曲率由Born-Oppenheimer能隙 $\\Delta$ 决定。利用电子变量微小振荡的谐振子近似，以及特征电子角频率 $\\omega_{e}$ 应至少是主导离子角频率 $\\omega_{i}$ 十倍大的分离要求，推导出保证 $\\omega_{e}/\\omega_{i} \\geq 10$ 的关于 $\\mu$ 的约束条件。然后，取 $\\Delta = 2\\ \\mathrm{eV}$ 和 $\\omega_{i} = 2 \\times 10^{13}\\ \\mathrm{s}^{-1}$，计算相应的上限 $\\mu_{\\max}$，单位为 $\\mathrm{J \\cdot s^{2}}$。陈述 $\\mu_{\\max}$ 的数值，并基于此解释满足分离判据的 $\\mu$ 的安全范围。用 $\\mathrm{J \\cdot s^{2}}$ 表示你关于 $\\mu_{\\max}$ 的最终数值答案，并将你的答案四舍五入到四位有效数字。",
            "solution": "所述问题具有科学依据、良定、客观，并包含足够的信息以得到唯一解。它描述了在Car-Parrinello分子动力学（CPMD）（一种计算物理学中成熟的方法）中确保绝热性的一个标准条件。因此，该问题是有效的，我们继续进行求解。\n\nCPMD的核心原理是将电子波函数 $\\{\\psi_k\\}$ 视为随时间演化的经典自由度，由一个虚构的动能项控制。虚构电子动力学的拉格朗日量可以写为：\n$$L_e = \\frac{1}{2} \\mu \\sum_k \\int |\\dot{\\psi}_k(\\mathbf{r}, t)|^2 d\\mathbf{r} - E_{BO}[\\{\\psi_k\\}]$$\n其中 $\\mu$ 是虚构质量，$\\dot{\\psi}_k$ 是第k个电子轨道的时间导数，$E_{BO}$ 是Born-Oppenheimer能量面，它同时作为离子和虚构电子系统的势能。问题陈述中指出动能“正比于 $\\mu \\sum |\\dot{\\psi}|^{2}$”，在这种标准拉格朗日形式的背景下，因子 $\\frac{1}{2}$ 对于动能项是常规的。\n\n从该拉格朗日量推导出的电子轨道的运动方程是：\n$$\\mu \\ddot{\\psi}_k = -\\frac{\\delta E_{BO}}{\\delta \\psi_k^*} + \\text{constraints}$$\n为了找到电子系统的特征频率 $\\omega_e$，我们考虑围绕电子基态的微小振荡。势能 $E_{BO}$ 可以在其最小值附近进行二次展开。问题通过陈述该势能的曲率由最高占据电子态和最低未占据电子态之间的能隙 $\\Delta$ 决定，从而简化了这一点。\n\n我们可以将最低频率电子激发模式的动力学建模为一个简谐振子。这个振子的“质量”是虚构质量 $\\mu$。有效“弹簧常数” $k_e$ 与能隙 $\\Delta$ 相关。对电子轨道的线性化运动方程进行标准分析表明，对应于从占据态 $i$ 到未占据态 $j$（能量差为 $\\epsilon_j - \\epsilon_i$）的激发，其角频率 $\\omega_{e, i \\to j}$ 由下式给出：\n$$\\omega_{e, i \\to j}^2 = \\frac{2(\\epsilon_j - \\epsilon_i)}{\\mu}$$\n维持绝热分离的最低且最关键的频率对应于最小的能隙，即Born-Oppenheimer能隙 $\\Delta$。因此，特征电子频率 $\\omega_e$ 由下式给出：\n$$\\omega_e^2 = \\frac{2\\Delta}{\\mu}$$\n\n问题要求电子和离子运动之间存在绝热分离，该分离由电子频率必须显著大于主导离子频率 $\\omega_i$ 的条件指定：\n$$\\frac{\\omega_e}{\\omega_i} \\geq 10$$\n将这个不等式两边平方得到：\n$$\\frac{\\omega_e^2}{\\omega_i^2} \\geq 100$$\n代入我们关于 $\\omega_e^2$ 的表达式：\n$$\\frac{2\\Delta / \\mu}{\\omega_i^2} \\geq 100$$\n现在我们可以求解关于虚构质量 $\\mu$ 的约束条件：\n$$\\frac{2\\Delta}{\\omega_i^2} \\geq 100 \\mu$$\n$$\\mu \\leq \\frac{2\\Delta}{100 \\omega_i^2}$$\n$$\\mu \\leq \\frac{\\Delta}{50 \\omega_i^2}$$\n这个不等式定义了确保绝热分离的 $\\mu$ 的安全范围。因此，$\\mu$ 的上限是：\n$$\\mu_{\\max} = \\frac{\\Delta}{50 \\omega_i^2}$$\n\n现在，我们使用所提供的数据计算 $\\mu_{\\max}$ 的数值。首先，所有值都必须转换为国际单位制（SI）基本单位。\n给定能隙为 $\\Delta = 2\\ \\mathrm{eV}$。使用元电荷 $e \\approx 1.602176634 \\times 10^{-19}\\ \\mathrm{C}$，我们将电子伏特转换为焦耳：\n$$\\Delta = 2 \\times (1.602176634 \\times 10^{-19}\\ \\mathrm{J}) = 3.204353268 \\times 10^{-19}\\ \\mathrm{J}$$\n给定主导离子频率为 $\\omega_i = 2 \\times 10^{13}\\ \\mathrm{s}^{-1}$。\n\n将这些值代入 $\\mu_{\\max}$ 的表达式中：\n$$\\mu_{\\max} = \\frac{3.204353268 \\times 10^{-19}\\ \\mathrm{J}}{50 \\times (2 \\times 10^{13}\\ \\mathrm{s}^{-1})^2}$$\n$$\\mu_{\\max} = \\frac{3.204353268 \\times 10^{-19}\\ \\mathrm{J}}{50 \\times (4 \\times 10^{26}\\ \\mathrm{s}^{-2})}$$\n$$\\mu_{\\max} = \\frac{3.204353268 \\times 10^{-19}\\ \\mathrm{J}}{200 \\times 10^{26}\\ \\mathrm{s}^{-2}}$$\n$$\\mu_{\\max} = \\frac{3.204353268 \\times 10^{-19}}{2 \\times 10^{28}}\\ \\mathrm{J \\cdot s^2}$$\n$$\\mu_{\\max} = 1.602176634 \\times 10^{-47}\\ \\mathrm{J \\cdot s^2}$$\n按要求将结果四舍五入到四位有效数字：\n$$\\mu_{\\max} \\approx 1.602 \\times 10^{-47}\\ \\mathrm{J \\cdot s^2}$$\n\n满足分离判据的 $\\mu$ 的安全范围是 $0  \\mu \\leq \\mu_{\\max}$。大于 $\\mu_{\\max}$ 的 $\\mu$ 值会导致虚构电子系统振荡过慢，从而导致绝热分离的破坏以及离子系统的非物理性加热。一个太接近于零的 $\\mu$ 值，虽然满足绝热性条件，但在对运动方程进行数值积分时，将需要一个不切实际的小时间步长，使得模拟在计算上不可行。推导出的约束条件专门针对绝热性的物理要求。",
            "answer": "$$\\boxed{1.602 \\times 10^{-47}}$$"
        },
        {
            "introduction": "在确定了物理上合理的伪质量 $\\mu$ 之后，下一步是选择一个既能保证数值积分精度，又能兼顾计算效率的积分时间步长 $\\Delta t$。本练习将引导你设计一个系统性的收敛性研究方案，通过分析总能量漂移与 $\\Delta t$ 的关系来确定最优的时间步长。这种方法是计算科学中的标准实践，对于确保长时间模拟结果的可靠性至关重要。",
            "id": "3871873",
            "problem": "您正在为Car-Parrinello分子动力学 (CPMD) 设计一项收敛性研究。CPMD使用二阶时间可逆积分器，对源自扩展Car-Parrinello拉格朗日量的离子和电子运动方程进行积分。从以下基本原理出发：\n\n- 拉格朗日力学和Newton方程指出，广义坐标的时间演化遵循作用量极值原理，从而导出运动方程。当使用二阶方法离散化时，这些方程会表现出阶数为$\\mathcal{O}(\\Delta t^{3})$的局部截断误差和阶数为$\\mathcal{O}(\\Delta t^{2})$的全局离散误差。\n- Störmer-Verlet (速度-Verlet) 格式是保辛且时间可逆的，它能保守一个邻近的“影子”哈密顿量，因此在一个保守系统中，对于足够小的$\\Delta t$，观测到的总能量在长时间内的漂移表现为$\\Delta t^{2}$的一个平滑函数。\n\n您的任务是形式化一个收敛协议，以选择一个以飞秒 (fs) 为单位的时间步长$\\Delta t$，从而限制在50皮秒 (ps) 的模拟过程中总能量的系统性漂移。假设对于足够小的$\\Delta t$，总能量每皮秒的长时间平均漂移率（记为$d(\\Delta t)$，单位为毫电子伏特/皮秒 (meV/ps)）可以用一个关于$\\Delta t^{2}$的线性模型来近似：\n- $d(\\Delta t) \\approx a \\,\\Delta t^{2} + b$，其中$a$和$b$是通过测量估计出的常数。\n\n设计一个程序，该程序：\n1. 通过普通最小二乘法，将线性模型$d(\\Delta t) = a \\,\\Delta t^{2} + b$与测量的配对$\\{ (\\Delta t_i, d_i) \\}$进行拟合。\n2. 给定在$50$ ps内允许的最大总漂移（记为$D_{\\max}$，单位为meV），计算最大允许的$\\Delta t$，使得在$50$ ps内预测的漂移$50 \\times d(\\Delta t)$不超过$D_{\\max}$。如果 $a \\le 0$，则使用以下规则：如果$b \\le D_{\\max}/50$，则最大允许的$\\Delta t$是容许区间的上界；否则，在区间内不存在可行的$\\Delta t$。\n3. 强制要求所选的$\\Delta t$必须位于闭区间$[\\Delta t_{\\min}, \\Delta t_{\\max}]$内，并且必须在间距为$\\delta$ fs的离散网格上选择。该算法应：\n   - 对于 $a > 0$ 的情况，计算连续候选值$\\Delta t^{\\star} = \\sqrt{\\max\\{(D_{\\max}/50 - b)/a,\\,0\\}}$。\n   - 将其裁剪至$\\Delta t^{\\star\\star} = \\min\\{\\Delta t^{\\star}, \\Delta t_{\\max}\\}$。\n   - 向下取整到$[\\Delta t_{\\min}, \\Delta t_{\\max}]$内的最近网格点。具体而言，定义$n = \\left\\lfloor \\dfrac{\\Delta t^{\\star\\star} - \\Delta t_{\\min}}{\\delta} \\right\\rfloor$并提出$\\Delta t_{\\text{grid}} = \\Delta t_{\\min} + n\\,\\delta$。\n   - 如果 $\\Delta t_{\\text{grid}}  \\Delta t_{\\min}$或$50 \\times d(\\Delta t_{\\text{grid}}) > D_{\\max}$，则以$\\delta$为步长递减，直到达到可行性，或者如果$\\Delta t_{\\text{grid}}$低于$\\Delta t_{\\min}$，则报告不可行。\n4. 返回推荐的$\\Delta t$（单位fs），四舍五入到三位小数。如果不存在可行的$\\Delta t$，则返回$-1.000$。\n\n不使用角度单位。所有物理单位必须按规定处理：$\\Delta t$单位为fs，漂移率单位为meV/ps，总漂移单位为meV（在$50$ ps内）。\n\n测试套件和输入数据：\n对于每个测试用例，您将获得：\n- 测量的时间步长列表（单位fs）：$[\\Delta t_1,\\dots,\\Delta t_m]$。\n- 测量的平均漂移率列表（单位meV/ps）：$[d_1,\\dots,d_m]$，其中$d_i$对应于$\\Delta t_i$。\n- 在$50$ ps内允许的最大总漂移，$D_{\\max}$（单位meV）。\n- 下界$\\Delta t_{\\min}$（单位fs）。\n- 上界$\\Delta t_{\\max}$（单位fs）。\n- 网格间距$\\delta$（单位fs）。\n\n实现该算法并将其应用于以下四个测试用例：\n\n- 案例 1：\n  - $\\Delta t$ (fs): $[0.06,\\,0.10,\\,0.14,\\,0.18]$\n  - $d$ (meV/ps): $[0.0134,\\,0.0420,\\,0.0754,\\,0.1306]$\n  - $D_{\\max}$ (meV over $50$ ps): $5.0$\n  - $\\Delta t_{\\min}$ (fs): $0.040$\n  - $\\Delta t_{\\max}$ (fs): $0.200$\n  - $\\delta$ (fs): $0.001$\n\n- 案例 2：\n  - $\\Delta t$ (fs): $[0.08,\\,0.16,\\,0.24,\\,0.30]$\n  - $d$ (meV/ps): $[0.00736,\\,0.01574,\\,0.02834,\\,0.04060]$\n  - $D_{\\max}$ (meV over $50$ ps): $2.0$\n  - $\\Delta t_{\\min}$ (fs): $0.050$\n  - $\\Delta t_{\\max}$ (fs): $0.300$\n  - $\\delta$ (fs): $0.001$\n\n- 案例 3：\n  - $\\Delta t$ (fs): $[0.05,\\,0.08,\\,0.11,\\,0.14]$\n  - $d$ (meV/ps): $[0.01195,\\,0.01750,\\,0.02645,\\,0.03720]$\n  - $D_{\\max}$ (meV over $50$ ps): $0.5$\n  - $\\Delta t_{\\min}$ (fs): $0.050$\n  - $\\Delta t_{\\max}$ (fs): $0.200$\n  - $\\delta$ (fs): $0.001$\n\n- 案例 4：\n  - $\\Delta t$ (fs): $[0.10,\\,0.20,\\,0.35,\\,0.50]$\n  - $d$ (meV/ps): $[0.00230,\\,0.00275,\\,0.00450,\\,0.00690]$\n  - $D_{\\max}$ (meV over $50$ ps): $10.0$\n  - $\\Delta t_{\\min}$ (fs): $0.050$\n  - $\\Delta t_{\\max}$ (fs): $0.500$\n  - $\\delta$ (fs): $0.001$\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个包含四个浮点数的列表，每个浮点数是对应测试用例推荐的$\\Delta t$（单位fs），四舍五入到三位小数。如果某个案例不存在可行的$\\Delta t$，则为该案例输出$-1.000$。格式必须严格为方括号内以逗号分隔的列表，例如，$[0.158,0.296,-1.000,0.500]$。",
            "solution": "此问题是有效的。它提出了一个基于数值积分和分子动力学模拟基本原理的、有科学依据、定义明确且客观的任务。该问题旨在设计一个计算协议，用于确定Car-Parrinello分子动力学 (CPMD) 模拟中一个最优且安全的积分时间步长$\\Delta t$。\n\n该协议基于数值误差的物理模型。对于像Störmer-Verlet格式这样的二阶时间可逆积分器，已知守恒量（如总能量）的全局误差与时间步长的平方成正比，即与$\\mathcal{O}(\\Delta t^2)$同阶。问题通过假设平均能量漂移率$d(\\Delta t)$作为时间步长的函数模型来形式化这一点：\n$$\nd(\\Delta t) \\approx a \\Delta t^2 + b\n$$\n其中$d(\\Delta t)$的单位是meV/ps，$\\Delta t$的单位是fs。参数$a$和$b$是待从模拟数据中确定的经验常数。\n\n每个测试用例的求解过程包括三个主要阶段：\n\n1.  **通过最小二乘拟合进行模型参数化**：\n    第一步是确定线性模型的系数$a$和$b$。给定一组$m$个测量数据点$(\\Delta t_i, d_i)$。我们希望拟合模型$d_i = a (\\Delta t_i^2) + b$。如果我们定义一个新的预测变量$x_i = \\Delta t_i^2$，这就变成一个线性回归问题。模型变为$d_i = a x_i + b$。系数$a$和$b$可以通过最小化残差平方和（使用普通最小二乘法 OLS）来找到。在矩阵表示法中，我们求解系统$X\\beta = \\mathbf{d}$以得到$\\beta = [a, b]^T$，其中$\\mathbf{d}$是观测到的漂移率向量，$X$是设计矩阵：\n    $$\n    X = \\begin{pmatrix} \\Delta t_1^2  1 \\\\ \\Delta t_2^2  1 \\\\ \\vdots  \\vdots \\\\ \\Delta t_m^2  1 \\end{pmatrix}, \\quad \\beta = \\begin{pmatrix} a \\\\ b \\end{pmatrix}, \\quad \\mathbf{d} = \\begin{pmatrix} d_1 \\\\ d_2 \\\\ \\vdots \\\\ d_m \\end{pmatrix}\n    $$\n    OLS解由$\\hat{\\beta} = (X^T X)^{-1} X^T \\mathbf{d}$给出。这在计算上通过标准的线性代数库函数实现。\n\n2.  **最大连续时间步长的推导**：\n    核心约束是在$50$ ps的模拟时长内，总能量漂移不得超过指定的最大值$D_{\\max}$。预测的总漂移为$50 \\times d(\\Delta t)$。因此约束条件是：\n    $$\n    50 \\times (a \\Delta t^2 + b) \\le D_{\\max}\n    $$\n    这等效于约束漂移率：\n    $$\n    d(\\Delta t) \\le \\frac{D_{\\max}}{50} \\equiv d_{\\text{max}}\n    $$\n    这个不等式的解取决于$a$的符号。\n    -   如果$a > 0$，漂移率是$\\Delta t$的增函数。不等式变为$\\Delta t^2 \\le (d_{\\text{max}} - b) / a$。如果 $d_{\\text{max}} - b  0$，则没有正的$\\Delta t$能满足此约束，问题不可行。否则，漂移模型允许的最大连续时间步长为$\\Delta t^{\\star} = \\sqrt{(d_{\\text{max}} - b) / a}$。\n    -   如果$a \\le 0$，漂移率是$\\Delta t$的非增函数。漂移在$\\Delta t=0$时最大，等于$b$。如果$b > d_{\\text{max}}$，漂移总是过高，问题不可行。如果$b \\le d_{\\text{max}}$，对于所有$\\Delta t \\ge 0$，漂移约束都得到满足。\n    在所有情况下，解还必须遵守显式边界$[\\Delta t_{\\min}, \\Delta t_{\\max}]$。因此，我们通过取模型推导的边界（如果存在）和显式上界$\\Delta t_{\\max}$的最小值，来找到一个候选上界$\\Delta t^{\\star\\star}$。\n\n3.  **离散化和最终选择**：\n    最后一步是找到在区间$[\\Delta t_{\\min}, \\Delta t_{\\max}]$内、位于间距为$\\delta$的离散网格上的最大允许$\\Delta t$。\n    首先，我们确定小于或等于我们候选上界$\\Delta t^{\\star\\star}$的最高可能网格点。计算方法如下：\n    $$\n    n = \\left\\lfloor \\frac{\\Delta t^{\\star\\star} - \\Delta t_{\\min}}{\\delta} \\right\\rfloor\n    $$\n    网格上的初始候选值为$\\Delta t_{\\text{grid}} = \\Delta t_{\\min} + n\\delta$。如果此计算导致$\\Delta t_{\\text{grid}}  \\Delta t_{\\min}$（当$\\Delta t^{\\star\\star}  \\Delta t_{\\min}$时发生），则在允许区间内不存在可行解。\n    否则，我们从$\\Delta t_{\\text{grid}}$开始向下搜索。我们检查漂移约束$50 \\times d(\\Delta t_{\\text{grid}}) \\le D_{\\max}$是否满足。如果满足，$\\Delta t_{\\text{grid}}$就是我们的答案，因为它是保证安全的最大的网格点。如果不满足（这可能是由于模型的近似性或浮点不精确性造成的），我们将时间步长减去$\\delta$并重复检查。此过程持续进行，直到找到一个可行的$\\Delta t$或时间步长低于$\\Delta t_{\\min}$。如果搜索未能找到可行的时间步长，则结果报告为不可行（$-1.000$）。\n\n这个结构化的过程确保所选择的$\\Delta t$是严格遵守所有指定物理和数值约束的最大可能值，为模拟提供了一个鲁棒且最优的选择。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"dt_measured\": [0.06, 0.10, 0.14, 0.18],\n            \"d_measured\": [0.0134, 0.0420, 0.0754, 0.1306],\n            \"D_max\": 5.0,\n            \"dt_min\": 0.040,\n            \"dt_max\": 0.200,\n            \"delta\": 0.001\n        },\n        # Case 2\n        {\n            \"dt_measured\": [0.08, 0.16, 0.24, 0.30],\n            \"d_measured\": [0.00736, 0.01574, 0.02834, 0.04060],\n            \"D_max\": 2.0,\n            \"dt_min\": 0.050,\n            \"dt_max\": 0.300,\n            \"delta\": 0.001\n        },\n        # Case 3\n        {\n            \"dt_measured\": [0.05, 0.08, 0.11, 0.14],\n            \"d_measured\": [0.01195, 0.01750, 0.02645, 0.03720],\n            \"D_max\": 0.5,\n            \"dt_min\": 0.050,\n            \"dt_max\": 0.200,\n            \"delta\": 0.001\n        },\n        # Case 4\n        {\n            \"dt_measured\": [0.10, 0.20, 0.35, 0.50],\n            \"d_measured\": [0.00230, 0.00275, 0.00450, 0.00690],\n            \"D_max\": 10.0,\n            \"dt_min\": 0.050,\n            \"dt_max\": 0.500,\n            \"delta\": 0.001\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_optimal_dt(case)\n        results.append(f\"{result:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef find_optimal_dt(case_data):\n    \"\"\"\n    Solves for the optimal time step for a single test case.\n    \"\"\"\n    dt_measured = np.array(case_data[\"dt_measured\"])\n    d_measured = np.array(case_data[\"d_measured\"])\n    D_max = case_data[\"D_max\"]\n    dt_min = case_data[\"dt_min\"]\n    dt_max = case_data[\"dt_max\"]\n    delta = case_data[\"delta\"]\n\n    # 1. Fit the linear model d(dt) = a*dt^2 + b using ordinary least squares.\n    x_var = dt_measured**2\n    # Design matrix for OLS: [x, 1]\n    A = np.vstack([x_var, np.ones(len(x_var))]).T\n    a, b = np.linalg.lstsq(A, d_measured, rcond=None)[0]\n\n    # 2. Compute the maximum permissible dt based on the drift model.\n    d_max_rate = D_max / 50.0\n\n    dt_upper_bound = None\n    infeasible = False\n\n    if a = 0:\n        # If drift is non-increasing, feasibility is determined by the baseline drift b.\n        if b > d_max_rate:\n            infeasible = True\n        else:\n            # The drift constraint is met for all dt. The limit is dt_max.\n            dt_upper_bound = dt_max\n    else:  # a > 0\n        # Drift is increasing. Solve a*dt^2 + b = d_max_rate.\n        rhs = d_max_rate - b\n        if rhs  0:\n            infeasible = True\n        else:\n            dt_star_continuous = np.sqrt(rhs / a)\n            # The candidate dt must also be within the allowed interval.\n            dt_upper_bound = min(dt_star_continuous, dt_max)\n\n    if infeasible:\n        return -1.0\n\n    # 3. Enforce grid constraints and find the largest feasible discrete dt.\n    \n    # If the continuous upper bound is already below the minimum allowed dt, no solution exists.\n    if dt_upper_bound  dt_min:\n        return -1.0\n\n    # Round down to the nearest grid point.\n    # n = floor((dt_upper_bound - dt_min) / delta)\n    # dt_grid = dt_min + n * delta\n    # This formula is robust. If dt_upper_bound is very close to a grid point,\n    # floating point issues might cause it to round to the point below.\n    # The subsequent search loop corrects for any such issues.\n    n = np.floor((dt_upper_bound - dt_min) / delta)\n    current_dt = dt_min + n * delta\n\n    # Iteratively check from the rounded-down candidate, decrementing by delta.\n    # This loop starts from the highest possible grid point and moves down,\n    # so the first feasible point found is the answer.\n    while current_dt >= dt_min - 1e-9: # Use small tolerance for float comparison\n        predicted_drift_rate = a * current_dt**2 + b\n        total_drift = 50.0 * predicted_drift_rate\n        \n        if total_drift = D_max:\n            return current_dt\n\n        current_dt -= delta\n\n    # If the loop completes without finding a feasible dt.\n    return -1.0\n\nsolve()\n```"
        },
        {
            "introduction": "参数的初步选择需要通过动态模拟进行验证，以防止伪质量 $\\mu$ 的选择不当导致与离子振动发生共振，从而破坏绝热条件。本练习介绍了一种强大的诊断技术：通过监测虚拟电子动能的功率谱来检查系统的动态行为。你将学习如何通过傅里叶分析来识别电子系统的特征频率，并判断其是否与离子振动模式发生共振，从而验证并优化伪质量 $\\mu$ 的选择。",
            "id": "3871803",
            "problem": "您的任务是设计并实现一个定量协议，用于在卡-帕里内洛分子动力学（CPMD）中调节虚拟电子质量参数 $ \\mu $。该协议通过监测电子动能的功率谱来避免与离子模发生共振。您的程序必须是该协议的一个完整、可运行的实现，并且必须遵循以下规范。\n\n其背景是一个简化的、与一组离子简正模相互作用的电子子系统单模模型，适用于阐释计算催化和化学工程中的绝热分离。您必须将电子子系统视为一个单一的有效谐振子自由度，并从第一性原理生成其动能的合成时间序列。核心观测量是电子动能时间序列，您将使用其主要频谱成分来估计特征电子振荡频率，并就与离子模的共振问题做出决策。\n\n从基本定律和核心定义出发，您必须推导并使用一个数学上合理的程序，该程序能够：\n- 为具有振幅 $ A $ 和由 $ \\mu $ 及有效劲度系数 $ k_e $ 决定的角频率的单个谐振电子自由度构建电子速度时间序列 $ v_e(t) $。\n- 计算电子动能时间序列 $ K_e(t) = \\tfrac{1}{2}\\,\\mu\\,v_e(t)^2 $，该序列以时间步长 $ \\Delta t $ 均匀采样，共 $ N $ 个样本，并被少量加性噪声污染以反映数值波动。\n- 使用离散傅里叶变换计算 $ K_e(t) $ 的单边功率谱，并以角频率单位识别出最强的非零谱峰。\n- 根据该峰值的位置估计特征电子角频率 $ \\omega_e $。\n- 通过将 $ \\omega_e $ 与一组给定的离子角频率 $ \\{\\omega_I\\} $ 进行比较，并使用指定的容差 $ \\tau $ 评估最小频率间隙，来量化共振风险。\n- 使用从第一性原理推导出的 $ \\omega_e $ 和 $ \\mu $ 之间的关系，计算一个推荐的调整值 $ \\mu_{\\text{rec}} $，该值在电子角频率和最大离子角频率之间强制执行一个指定的分离因子 $ s $。\n- 对每个测试用例，报告是否检测到共振、推荐的 $ \\mu_{\\text{rec}} $、估计的 $ \\omega_e $ 以及与离子频率集的最小间隙。\n\n所有频率都必须以弧度/飞秒（rad/fs）为单位进行处理和报告。时间步长必须以飞秒（fs）为单位。虚拟质量 $ \\mu $ 必须以原子单位（a.u.）进行处理和报告。任何角度（如果存在）均假定为弧度。不要使用百分号；任何分数量必须表示为小数。\n\n您的程序必须仅使用每个测试用例中提供的参数来构建电子速度和动能时间序列，不得依赖外部文件或用户输入。对于频谱分析，您必须使用快速傅里叶变换（FFT）来获得离散谱，并以角频率单位对其进行解释。您必须通过适当的预处理来处理直流偏置，以便找到有意义的峰值。\n\n定义以下测试套件，其中包含三组参数，用于探测不同的体系和边缘情况：\n\n- 测试用例 $ 1 $（近共振体系）：\n    - $ \\mu = 8.2 $ (a.u.)\n    - $ k_e = 1.0 $ (a.u.)\n    - $ \\{\\omega_I\\} = \\{0.1,\\,0.2,\\,0.35\\} $ (rad/fs)\n    - $ \\Delta t = 0.5 $ (fs)\n    - $ N = 4096 $\n    - $ A = 0.5 $ (无量纲振幅)\n    - 加性噪声标准差 $ \\sigma = 10^{-4} $ (与 $ K_e(t) $ 单位相同)\n    - 容差 $ \\tau = 0.02 $ (rad/fs)\n    - 分离因子 $ s = 2.0 $ (无量纲)\n\n- 测试用例 $ 2 $（绝热安全体系）：\n    - $ \\mu = 1.0 $ (a.u.)\n    - $ k_e = 1.0 $ (a.u.)\n    - $ \\{\\omega_I\\} = \\{0.1,\\,0.2,\\,0.35\\} $ (rad/fs)\n    - $ \\Delta t = 0.5 $ (fs)\n    - $ N = 4096 $\n    - $ A = 0.5 $\n    - $ \\sigma = 10^{-4} $\n    - $ \\tau = 0.02 $ (rad/fs)\n    - $ s = 2.0 $\n\n- 测试用例 $ 3 $（模式重合的边界情况）：\n    - $ \\mu = 25.0 $ (a.u.)\n    - $ k_e = 1.0 $ (a.u.)\n    - $ \\{\\omega_I\\} = \\{0.1,\\,0.2,\\,0.35\\} $ (rad/fs)\n    - $ \\Delta t = 0.5 $ (fs)\n    - $ N = 4096 $\n    - $ A = 0.5 $\n    - $ \\sigma = 10^{-4} $\n    - $ \\tau = 0.02 $ (rad/fs)\n    - $ s = 2.0 $\n\n您的共振判据必须是：如果最小绝对差 $ \\min_{\\omega_I} |\\omega_e - \\omega_I| $ 严格小于 $ \\tau $，则检测到共振。您推荐的 $ \\mu_{\\text{rec}} $ 的计算必须满足相对于最大离子角频率 $ \\max(\\{\\omega_I\\}) $ 的分离因子 $ s $。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是一个形如 $ [\\text{resonance\\_detected},\\,\\mu_{\\text{rec}}\\text{ (a.u.)},\\,\\omega_e\\text{ (rad/fs)},\\,\\text{min\\_gap}\\text{ (rad/fs)}] $ 的列表，所有测试用例的结果聚合为 $ [[\\cdot],[\\cdot],[\\cdot]] $ 的形式。输出中的数值必须与上述单位相对应。",
            "solution": "该问题要求设计并实现一个计算协议，用于在卡-帕里内洛分子动力学（CPMD）中调节虚拟电子质量 $ \\mu $，以避免与离子振动模式发生共振。该协议将在一个简化模型上进行演示，其中电子子系统被视为单个谐振子。\n\nCPMD的核心原理是在一个统一的拉格朗日量支配下，同时演化电子波函数（或其轨道表示）和原子核位置。这通过为电子自由度分配一个虚拟质量 $ \\mu $ 来实现，使其能够在由瞬时电子能量定义的势能面上进行经典演化。为了使动力学具有物理意义，必须在快速运动的电子子系统和缓慢运动的原子核之间保持绝热分离。这意味着电子子系统的特征频率 $ \\omega_e $ 必须显著高于任何离子振动频率 $ \\{\\omega_I\\} $。如果 $ \\omega_e $ 变得过于接近某个 $ \\omega_I $，就可能发生共振，导致能量从虚拟电子动能非物理地转移到离子系统，从而使模拟不稳定。虚拟质量 $ \\mu $ 是调节 $ \\omega_e $ 的主要参数。\n\n首先，我们建立数学模型。电子子系统被建模为一个简谐振子。有效电子坐标 $ x_e $ 的运动方程为 $ \\mu \\ddot{x}_e + k_e x_e = 0 $，其中 $ k_e $ 是一个有效劲度系数。该方程的解描述了简谐运动，其固有角频率 $ \\omega_e $ 由下式确定：\n$$ \\omega_e = \\sqrt{\\frac{k_e}{\\mu}} $$\n根据问题陈述中的测试用例及其描述（例如，“近共振体系”、“模式重合”），我们推断参数 $ \\mu $ 和 $ k_e $ 是在一组一致的单位下提供的，使得由此产生的 $ \\omega_e $ 直接以弧度/飞秒（rad/fs）为单位。提及“原子单位”是为了说明参数的来源背景，但对于所呈现的教学模型而言，无需进行单位间的转换。\n\n该协议通过监测电子动能 $ K_e(t) $ 来评估系统状态。对于一个谐振子，如果其位置为 $ x_e(t) = C \\cos(\\omega_e t) $，则其速度为 $ v_e(t) = -C\\omega_e \\sin(\\omega_e t) $。问题要求构建具有给定振幅的速度时间序列 $ v_e(t) $，在不失一般性的前提下，为了频率分析，我们可以将其建模为 $ v_e(t) = A_v \\sin(\\omega_e t) $。那么动能为：\n$$ K_e(t) = \\frac{1}{2}\\mu v_e(t)^2 = \\frac{1}{2}\\mu A_v^2 \\sin^2(\\omega_e t) $$\n使用三角恒等式 $ \\sin^2(\\theta) = \\frac{1}{2}(1 - \\cos(2\\theta)) $，我们可以将动能重写为：\n$$ K_e(t) = \\frac{1}{4}\\mu A_v^2 (1 - \\cos(2\\omega_e t)) = \\frac{1}{4}\\mu A_v^2 - \\frac{1}{4}\\mu A_v^2 \\cos(2\\omega_e t) $$\n这个表达式揭示了动能信号的两个关键特征：\n$1$. 它有一个恒定（DC）分量， $ \\langle K_e \\rangle = \\frac{1}{4}\\mu A_v^2 $。\n$2$. 它有一个时变（AC）分量，以角频率 $ 2\\omega_e $ 振荡，这是基本电子频率的两倍。\n\n因此，从 $ K_e(t) $ 的时间序列估计 $ \\omega_e $ 的协议是：在其功率谱中找到主导频率峰值 $ \\omega_{peak} $，然后计算 $ \\omega_e = \\omega_{peak} / 2 $。\n\n计算过程如下：\n$1$. **时间序列生成**：对于给定的参数集 $ \\mu, k_e, A, \\Delta t, N, \\sigma $，我们首先计算理论电子频率 $ \\omega_e = \\sqrt{k_e/\\mu} $。然后我们生成一个离散时间向量 $ t = [0, \\Delta t, 2\\Delta t, \\dots, (N-1)\\Delta t] $。利用这个向量，我们构建动能序列 $ K_e(i) = \\frac{1}{2}\\mu A^2 \\sin^2(\\omega_e t_i) $，其中我们将给定的无量纲振幅 $ A $ 解释为速度振幅 $ A_v $。然后，我们添加标准差为 $ \\sigma $ 的高斯噪声以模拟数值波动：$ K_{e, \\text{noisy}}(i) = K_e(i) + \\mathcal{N}(0, \\sigma^2) $。\n\n$2$. **频谱分析**：为了找到 $ \\omega_{peak} $，我们在频域中分析 $ K_{e, \\text{noisy}}(t) $。\n    a. **预处理**：$ K_e(t) $ 中的显著直流偏置会掩盖功率谱中的其他特征。按照规定，我们通过减去信号的均值来移除它：$ K'_e = K_{e, \\text{noisy}} - \\text{mean}(K_{e, \\text{noisy}}) $。\n    b. **傅里叶变换**：我们使用快速傅里叶变换（FFT）算法计算 $ K'_e $ 的离散傅里叶变换（DFT）。记为 $ \\hat{K'}(\\omega_k) $。\n    c. **功率谱**：功率谱与FFT系数的模平方成正比，$ P(\\omega_k) \\propto |\\hat{K'}(\\omega_k)|^2 $。我们需要分析正频率的单边谱。\n    d. **频率轴**：与FFT输出对应的离散角频率 $ \\omega_k $ 由 $ \\omega_k = \\frac{2\\pi k}{N \\Delta t} $ 给出，其中 $ k = 0, 1, \\dots, N-1 $。\n\n$3$. **峰值识别与 $ \\omega_e $ 估计**：我们寻找“最强的非零谱峰”。这对应于找到索引 $ k_{peak} $，使得 $ P(\\omega_k) $ 在 $ k > 0 $ 时最大。此峰值的角频率为 $ \\omega_{peak} = \\frac{2\\pi k_{peak}}{N \\Delta t} $。然后，估计的电子频率为 $ \\omega_{e, \\text{est}} = \\omega_{peak} / 2 $。\n\n$4$. **共振分析**：我们通过计算估计的电子频率与给定的离子频率集 $ \\{\\omega_I\\} $ 之间的最小频率间隙来量化共振风险：\n$$ \\text{min\\_gap} = \\min_{\\omega_I \\in \\{\\omega_I\\}} |\\omega_{e, \\text{est}} - \\omega_I| $$\n如果此间隙小于指定的容差 $ \\tau $，则检测到共振：\n$$ \\text{resonance\\_detected} = (\\text{min\\_gap}  \\tau) $$\n\n$5$. **虚拟质量调节**：为确保绝热分离，计算一个新的推荐虚拟质量 $ \\mu_{\\text{rec}} $。目标是设定一个新的电子频率 $ \\omega_{e, \\text{new}} $，使其比最大离子频率 $ \\omega_{I, \\text{max}} = \\max(\\{\\omega_I\\}) $ 大一个给定的分离因子 $ s $。\n$$ \\omega_{e, \\text{new}} = s \\cdot \\omega_{I, \\text{max}} $$\n从关系式 $ \\omega_e = \\sqrt{k_e/\\mu} $，我们可以写出 $ \\mu = k_e / \\omega_e^2 $。因此，推荐的质量为：\n$$ \\mu_{\\text{rec}} = \\frac{k_e}{\\omega_{e, \\text{new}}^2} = \\frac{k_e}{(s \\cdot \\omega_{I, \\text{max}})^2} $$\n将此过程应用于每个测试用例以生成最终结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import fft\n\ndef solve():\n    \"\"\"\n    Implements the CPMD fictitious mass tuning protocol.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (near-resonant regime)\n        {\n            \"mu\": 8.2, \"ke\": 1.0, \"omega_I\": [0.1, 0.2, 0.35],\n            \"dt\": 0.5, \"N\": 4096, \"A\": 0.5, \"sigma\": 1e-4,\n            \"tau\": 0.02, \"s\": 2.0\n        },\n        # Test case 2 (adiabatically safe regime)\n        {\n            \"mu\": 1.0, \"ke\": 1.0, \"omega_I\": [0.1, 0.2, 0.35],\n            \"dt\": 0.5, \"N\": 4096, \"A\": 0.5, \"sigma\": 1e-4,\n            \"tau\": 0.02, \"s\": 2.0\n        },\n        # Test case 3 (boundary case with coincident mode)\n        {\n            \"mu\": 25.0, \"ke\": 1.0, \"omega_I\": [0.1, 0.2, 0.35],\n            \"dt\": 0.5, \"N\": 4096, \"A\": 0.5, \"sigma\": 1e-4,\n            \"tau\": 0.02, \"s\": 2.0\n        }\n    ]\n\n    results = []\n    \n    # Use a seeded random number generator for reproducibility of noise\n    rng = np.random.default_rng(seed=12345)\n\n    for case in test_cases:\n        mu = case[\"mu\"]\n        ke = case[\"ke\"]\n        omega_I_set = np.array(case[\"omega_I\"])\n        dt = case[\"dt\"]\n        N = case[\"N\"]\n        A = case[\"A\"]\n        sigma = case[\"sigma\"]\n        tau = case[\"tau\"]\n        s = case[\"s\"]\n\n        # 1. Theoretical electronic frequency and time series generation\n        # omega_e = sqrt(ke / mu)\n        omega_e_theory = np.sqrt(ke / mu)\n        \n        # Time array\n        t = np.arange(N) * dt\n        \n        # Velocity and kinetic energy time series\n        # v_e(t) = A * sin(omega_e * t)\n        # K_e(t) = 0.5 * mu * v_e(t)^2\n        v_e_t = A * np.sin(omega_e_theory * t)\n        Ke_t = 0.5 * mu * v_e_t**2\n        \n        # Add additive Gaussian noise\n        noise = rng.normal(0, sigma, N)\n        Ke_t_noisy = Ke_t + noise\n\n        # 2. Spectral Analysis\n        # Preprocessing: remove DC offset (mean)\n        Ke_t_processed = Ke_t_noisy - np.mean(Ke_t_noisy)\n        \n        # Compute FFT\n        # The result of fftpack.fft is a complex array.\n        yf = fft.fft(Ke_t_processed)\n        \n        # Compute one-sided power spectrum\n        # We only need the first half of the FFT output for a real signal\n        N_half = N // 2\n        # Power is proportional to the squared magnitude\n        power = np.abs(yf[0:N_half])**2\n\n        # Frequency axis for the one-sided spectrum\n        # fft.fftfreq generates sample frequencies f = k / (N*dt)\n        # We need angular frequencies omega = 2*pi*f\n        freq_axis = fft.fftfreq(N, dt)\n        omega_axis = 2 * np.pi * freq_axis\n        \n        # We only consider positive frequencies for the one-sided spectrum\n        positive_omega_axis = omega_axis[0:N_half]\n        \n        # 3. Peak Identification and omega_e estimation\n        # Find the strongest NONZERO spectral peak.\n        # We search from index 1 to exclude the DC component.\n        peak_idx = np.argmax(power[1:]) + 1\n        omega_peak = positive_omega_axis[peak_idx]\n        \n        # The peak in the kinetic energy spectrum is at 2 * omega_e\n        omega_e_est = omega_peak / 2.0\n        \n        # 4. Resonance Analysis\n        # Calculate the minimal frequency gap to the ionic modes\n        min_gap = np.min(np.abs(omega_e_est - omega_I_set))\n        \n        # Check for resonance\n        resonance_detected = min_gap  tau\n        \n        # 5. Recommended mu calculation\n        omega_I_max = np.max(omega_I_set)\n        omega_e_new = s * omega_I_max\n        mu_rec = ke / (omega_e_new**2)\n        \n        # Aggregate results for this case\n        results.append([\n            resonance_detected,\n            mu_rec,\n            omega_e_est,\n            min_gap\n        ])\n\n    # Final print statement in the exact required format.\n    # The output format is a bit tricky, python's default string representation\n    # of list adds spaces. We need to construct the string manually.\n    outer_list_str = []\n    for R in results:\n        # Format numbers to a reasonable precision to avoid excessive digits\n        # and ensure consistent output.\n        res_str = f\"[{R[0]}, {R[1]:.7f}, {R[2]:.7f}, {R[3]:.7f}]\"\n        outer_list_str.append(res_str)\n    \n    print(f\"[{','.join(outer_list_str)}]\")\n\nsolve()\n```"
        }
    ]
}