{
    "hands_on_practices": [
        {
            "introduction": "在Car-Parrinello分子动力学（CPMD）中，伪质量（或称虚拟质量）参数 $μ$ 的选择至关重要。它必须足够小，以确保电子子系统能够绝热地跟随原子核的运动，但又必须足够大，以允许使用一个合理的积分时间步长，从而使模拟在计算上可行。这项实践将指导你通过一个基础的分析方法，根据系统的基本物理属性（如能隙和离子振动频率），来估算 $μ$ 的一个安全上限 。这个练习旨在加深你对CPMD核心绝热条件的理解。",
            "id": "3741059",
            "problem": "考虑Car-Parrinello分子动力学(CPMD)，其中电子自由度通过一个由类质量参数 $\\mu$ 表征的虚构动能项进行演化，以强制实现与离子运动的绝热分离。在CPMD中，从标准的拉格朗日结构出发，其中虚构的电子动能与 $\\mu \\sum |\\dot{\\psi}|^{2}$ 成正比，且基态附近的电子势能曲率由Born-Oppenheimer能隙 $\\Delta$ 决定。利用电子变量小振荡的谐振近似，以及特征电子角频率 $\\omega_{e}$ 应至少是主导离子角频率 $\\omega_{i}$ 十倍大的分离要求，推导保证 $\\omega_{e}/\\omega_{i} \\geq 10$ 的关于 $\\mu$ 的约束条件。然后，取 $\\Delta = 2\\ \\mathrm{eV}$ 和 $\\omega_{i} = 2 \\times 10^{13}\\ \\mathrm{s}^{-1}$，计算相应的上限 $\\mu_{\\max}$，单位为 $\\mathrm{J \\cdot s^{2}}$。给出 $\\mu_{\\max}$ 的数值，并基于此解释满足分离判据的 $\\mu$ 的安全范围。以 $\\mathrm{J \\cdot s^{2}}$ 为单位表示 $\\mu_{\\max}$ 的最终数值答案，并将答案四舍五入到四位有效数字。",
            "solution": "所述问题具有科学依据、适定、客观，并包含足够的信息以得到唯一解。它描述了在Car-Parrinello分子动力学(CPMD)中确保绝热性的一个标准条件，CPMD是计算物理学中一种成熟的方法。因此，该问题是有效的，我们继续进行求解。\n\nCPMD的核心原理是将电子波函数 $\\{\\psi_k\\}$ 视为随时间演化的经典自由度，并受一个虚构的动能项支配。虚构电子动力学的拉格朗日量可以写为：\n$$L_e = \\frac{1}{2} \\mu \\sum_k \\int |\\dot{\\psi}_k(\\mathbf{r}, t)|^2 d\\mathbf{r} - E_{BO}[\\{\\psi_k\\}]$$\n其中 $\\mu$ 是虚构质量，$\\dot{\\psi}_k$ 是第k个电子轨道的时间导数，而 $E_{BO}$ 是Born-Oppenheimer能量面，它同时作为离子和虚构电子系统的势能。问题陈述中指出动能“与 $\\mu \\sum |\\dot{\\psi}|^{2}$ 成正比”，这在标准拉格朗日形式的背景下被解释，其中因子 $\\frac{1}{2}$ 对于动能项是常规写法。\n\n从该拉格朗日量导出的电子轨道运动方程为：\n$$\\mu \\ddot{\\psi}_k = -\\frac{\\delta E_{BO}}{\\delta \\psi_k^*} + \\text{约束}$$\n为了找到电子系统的特征频率 $\\omega_e$，我们考虑围绕电子基态的小幅振荡。势能 $E_{BO}$ 可以在其最小值附近进行二次展开。问题通过陈述该势能的曲率由最高占据电子态和最低未占据电子态之间的能隙 $\\Delta$ 决定，从而简化了该问题。\n\n我们可以将最低频率电子激发模式的动力学建模为一个简谐振子。该振子的“质量”是虚构质量 $\\mu$。有效“弹簧常数” $k_e$ 与能隙 $\\Delta$ 相关。对电子轨道的线性化运动方程进行标准分析表明，对应于从能量差为 $\\epsilon_j - \\epsilon_i$ 的占据态 $i$ 激发到未占据态 $j$ 的角频率 $\\omega_{e, i \\to j}$ 由下式给出：\n$$\\omega_{e, i \\to j}^2 = \\frac{2(\\epsilon_j - \\epsilon_i)}{\\mu}$$\n维持绝热分离的最低且最关键的频率对应于最小的能隙，即Born-Oppenheimer能隙 $\\Delta$。因此，特征电子频率 $\\omega_e$ 由下式给出：\n$$\\omega_e^2 = \\frac{2\\Delta}{\\mu}$$\n\n问题要求电子和离子运动之间存在绝热分离，这由电子频率必须显著大于主导离子频率 $\\omega_i$ 的条件指定：\n$$\\frac{\\omega_e}{\\omega_i} \\geq 10$$\n将此不等式两边平方得到：\n$$\\frac{\\omega_e^2}{\\omega_i^2} \\geq 100$$\n代入我们关于 $\\omega_e^2$ 的表达式：\n$$\\frac{2\\Delta / \\mu}{\\omega_i^2} \\geq 100$$\n我们现在可以解出关于虚构质量 $\\mu$ 的约束条件：\n$$\\frac{2\\Delta}{\\omega_i^2} \\geq 100 \\mu$$\n$$\\mu \\leq \\frac{2\\Delta}{100 \\omega_i^2}$$\n$$\\mu \\leq \\frac{\\Delta}{50 \\omega_i^2}$$\n这个不等式定义了确保绝热分离的 $\\mu$ 的安全范围。因此，$\\mu$ 的上限为：\n$$\\mu_{\\max} = \\frac{\\Delta}{50 \\omega_i^2}$$\n\n现在，我们使用所提供的数据计算 $\\mu_{\\max}$ 的数值。首先，所有值都必须转换为国际单位制（SI）基本单位。\n能隙给定为 $\\Delta = 2\\ \\mathrm{eV}$。使用基本电荷 $e \\approx 1.602176634 \\times 10^{-19}\\ \\mathrm{C}$，我们将电子伏特转换为焦耳：\n$$\\Delta = 2 \\times (1.602176634 \\times 10^{-19}\\ \\mathrm{J}) = 3.204353268 \\times 10^{-19}\\ \\mathrm{J}$$\n主导离子频率给定为 $\\omega_i = 2 \\times 10^{13}\\ \\mathrm{s}^{-1}$。\n\n将这些值代入 $\\mu_{\\max}$ 的表达式中：\n$$\\mu_{\\max} = \\frac{3.204353268 \\times 10^{-19}\\ \\mathrm{J}}{50 \\times (2 \\times 10^{13}\\ \\mathrm{s}^{-1})^2}$$\n$$\\mu_{\\max} = \\frac{3.204353268 \\times 10^{-19}\\ \\mathrm{J}}{50 \\times (4 \\times 10^{26}\\ \\mathrm{s}^{-2})}$$\n$$\\mu_{\\max} = \\frac{3.204353268 \\times 10^{-19}\\ \\mathrm{J}}{200 \\times 10^{26}\\ \\mathrm{s}^{-2}}$$\n$$\\mu_{\\max} = \\frac{3.204353268 \\times 10^{-19}}{2 \\times 10^{28}}\\ \\mathrm{J \\cdot s^2}$$\n$$\\mu_{\\max} = 1.602176634 \\times 10^{-47}\\ \\mathrm{J \\cdot s^2}$$\n按要求将结果四舍五入到四位有效数字：\n$$\\mu_{\\max} \\approx 1.602 \\times 10^{-47}\\ \\mathrm{J \\cdot s^2}$$\n\n满足分离判据的 $\\mu$ 的安全范围是 $0  \\mu \\leq \\mu_{\\max}$。一个大于 $\\mu_{\\max}$ 的 $\\mu$ 值会导致虚构电子系统振荡过慢，从而导致绝热分离的破坏以及离子系统的非物理性加热。一个太接近于零的 $\\mu$ 值，虽然满足绝热性条件，但需要一个不切实际的小时间步长来对运动方程进行数值积分，使得模拟在计算上不可行。所推导出的约束条件专门针对绝热性的物理要求。",
            "answer": "$$\\boxed{1.602 \\times 10^{-47}}$$"
        },
        {
            "introduction": "在确定了合适的伪质量 $μ$ 之后，下一个关键步骤是选择积分时间步长 $Δt$。虽然较大的 $Δt$ 可以显著加快模拟速度，但过大的 $Δt$ 会破坏数值积分的稳定性，导致总能量不守恒，产生非物理的能量漂移。这项实践将引导你学习一种系统性的方法，通过分析能量漂移与 $Δt$ 的关系来确定一个最佳的时间步长 。这个过程旨在让你掌握如何在计算效率和模拟精度之间做出权衡，这是任何分子动力学模拟中的一项核心技能。",
            "id": "3871873",
            "problem": "您正在为Car-Parrinello分子动力学 (CPMD) 设计一项收敛性研究。该方法使用二阶时间可逆积分器，对源自扩展的Car-Parrinello拉格朗日量的离子和电子运动方程进行积分。请从以下基本依据出发：\n\n- 拉格朗日力学和牛顿方程指出，广义坐标的时间演化遵循作用量极值化原则，从而导出运动方程。当这些方程通过二阶方法离散化时，其局部截断误差为$\\mathcal{O}(\\Delta t^{3})$阶，全局离散化误差为$\\mathcal{O}(\\Delta t^{2})$阶。\n- Störmer-Verlet (速度-Verlet) 格式具有辛性和时间可逆性，它保守一个邻近的“影子”哈密顿量，因此在一个保守系统中，经过长时间观察到的总能量漂移表现为$\\Delta t^{2}$的光滑函数（对于足够小的$\\Delta t$）。\n\n您的任务是形式化一个收敛性协议，以选择一个以飞秒 (fs) 为单位的时间步长$\\Delta t$，从而限制在$50$皮秒 (ps) 的模拟过程中总能量的系统性漂移。假设对于足够小的$\\Delta t$，总能量的长时间平均漂移率（记为$d(\\Delta t)$，单位为毫电子伏特每皮秒 meV/ps）可以用一个关于$\\Delta t^{2}$的线性模型来近似：\n- $d(\\Delta t) \\approx a \\,\\Delta t^{2} + b$，其中$a$和$b$是通过测量估计出的常数。\n\n设计一个程序，该程序能够：\n1. 通过普通最小二乘法，将线性模型$d(\\Delta t) = a \\,\\Delta t^{2} + b$与测得的数据对$\\{(\\Delta t_i, d_i)\\}$进行拟合。\n2. 给定$50$ ps内的最大允许总漂移（记为$D_{\\max}$，单位为meV），计算出最大允许的$\\Delta t$，使得预测的$50$ ps内漂移$50 \\times d(\\Delta t)$不超过$D_{\\max}$。如果$a \\le 0$，则使用以下规则：若$b \\le D_{\\max}/50$，则最大允许的$\\Delta t$是容许区间的上界；否则，在区间内不存在可行的$\\Delta t$。\n3. 强制所选的$\\Delta t$必须位于闭区间$[\\Delta t_{\\min}, \\Delta t_{\\max}]$内，并且必须在间距为$\\delta$ fs的离散网格上选择。该算法应：\n   - 对于$a0$，计算连续候选值$\\Delta t^{\\star} = \\sqrt{\\max\\{(D_{\\max}/50 - b)/a,\\,0\\}}$。\n   - 裁剪至$\\Delta t^{\\star\\star} = \\min\\{\\Delta t^{\\star}, \\Delta t_{\\max}\\}$。\n   - 向下取整到$[\\Delta t_{\\min}, \\Delta t_{\\max}]$内的最近网格点。具体地，定义$n = \\left\\lfloor \\dfrac{\\Delta t^{\\star\\star} - \\Delta t_{\\min}}{\\delta} \\right\\rfloor$并提出$\\Delta t_{\\text{grid}} = \\Delta t_{\\min} + n\\,\\delta$。\n   - 如果$\\Delta t_{\\text{grid}}  \\Delta t_{\\min}$或$50 \\times d(\\Delta t_{\\text{grid}})  D_{\\max}$，则每次递减$\\delta$直到达到可行性，或者如果$\\Delta t_{\\text{grid}}$低于$\\Delta t_{\\min}$，则报告不可行。\n4. 返回推荐的$\\Delta t$（单位为fs），四舍五入到三位小数。如果不存在可行的$\\Delta t$，则返回$-1.000$。\n\n不使用角度单位。所有物理单位必须按规定处理：$\\Delta t$单位为fs，漂移率单位为meV/ps，总漂移为$50$ ps内的meV。\n\n测试套件和输入数据：\n对于每个测试用例，您将获得：\n- 测得的时间步长列表（单位fs）：$[\\Delta t_1,\\dots,\\Delta t_m]$。\n- 测得的平均漂移率列表（单位meV/ps）：$[d_1,\\dots,d_m]$，其中$d_i$对应于$\\Delta t_i$。\n- $50$ ps内的最大允许总漂移$D_{\\max}$（单位meV）。\n- 下界$\\Delta t_{\\min}$（单位fs）。\n- 上界$\\Delta t_{\\max}$（单位fs）。\n- 网格间距$\\delta$（单位fs）。\n\n实现该算法并将其应用于以下四个测试用例：\n\n- 用例1：\n  - $\\Delta t$ (fs): $[0.06,\\,0.10,\\,0.14,\\,0.18]$\n  - $d$ (meV/ps): $[0.0134,\\,0.0420,\\,0.0754,\\,0.1306]$\n  - $D_{\\max}$ (meV over $50$ ps): $5.0$\n  - $\\Delta t_{\\min}$ (fs): $0.040$\n  - $\\Delta t_{\\max}$ (fs): $0.200$\n  - $\\delta$ (fs): $0.001$\n\n- 用例2：\n  - $\\Delta t$ (fs): $[0.08,\\,0.16,\\,0.24,\\,0.30]$\n  - $d$ (meV/ps): $[0.00736,\\,0.01574,\\,0.02834,\\,0.04060]$\n  - $D_{\\max}$ (meV over $50$ ps): $2.0$\n  - $\\Delta t_{\\min}$ (fs): $0.050$\n  - $\\Delta t_{\\max}$ (fs): $0.300$\n  - $\\delta$ (fs): $0.001$\n\n- 用例3：\n  - $\\Delta t$ (fs): $[0.05,\\,0.08,\\,0.11,\\,0.14]$\n  - $d$ (meV/ps): $[0.01195,\\,0.01750,\\,0.02645,\\,0.03720]$\n  - $D_{\\max}$ (meV over $50$ ps): $0.5$\n  - $\\Delta t_{\\min}$ (fs): $0.050$\n  - $\\Delta t_{\\max}$ (fs): $0.200$\n  - $\\delta$ (fs): $0.001$\n\n- 用例4：\n  - $\\Delta t$ (fs): $[0.10,\\,0.20,\\,0.35,\\,0.50]$\n  - $d$ (meV/ps): $[0.00230,\\,0.00275,\\,0.00450,\\,0.00690]$\n  - $D_{\\max}$ (meV over $50$ ps): $10.0$\n  - $\\Delta t_{\\min}$ (fs): $0.050$\n  - $\\Delta t_{\\max}$ (fs): $0.500$\n  - $\\delta$ (fs): $0.001$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个包含四个浮点数的列表，每个浮点数是对应测试用例的推荐$\\Delta t$（单位为fs），四舍五入到三位小数。如果某个用例不存在可行的$\\Delta t$，则该用例输出$-1.000$。格式必须严格为由方括号括起来的逗号分隔列表，例如$[0.158,0.296,-1.000,0.500]$。",
            "solution": "该问题是有效的。它基于数值积分和分子动力学模拟的基本原理，提出了一个科学根据充分、问题定义明确且客观的任务。问题在于设计一个计算协议，用于确定Car-Parrinello分子动力学 (CPMD) 模拟的最优且安全的积分时间步长$\\Delta t$。\n\n该协议基于一个数值误差的物理模型。对于像Störmer-Verlet格式这样的二阶时间可逆积分器，诸如总能量等守恒量的全局误差已知与时间步长的平方成正比，即$\\mathcal{O}(\\Delta t^2)$。该问题通过假设平均能量漂移率$d(\\Delta t)$作为时间步长的函数来将其形式化：\n$$\nd(\\Delta t) \\approx a \\Delta t^2 + b\n$$\n其中$d(\\Delta t)$的单位是meV/ps，$\\Delta t$的单位是fs。参数$a$和$b$是待从模拟数据中确定的经验常数。\n\n每个测试用例的求解过程包括三个主要阶段：\n\n1.  **通过最小二乘拟合进行模型参数化**：\n    第一步是确定线性模型的系数$a$和$b$。给定一组$m$个测量数据点$(\\Delta t_i, d_i)$。我们希望拟合模型$d_i = a (\\Delta t_i^2) + b$。如果我们定义一个新的预测变量$x_i = \\Delta t_i^2$，这就变成一个线性回归问题。模型变为$d_i = a x_i + b$。系数$a$和$b$可以通过使用普通最小二乘法 (OLS) 最小化残差平方和来找到。在矩阵表示法中，我们求解系统$X\\beta = \\mathbf{d}$以得到$\\beta = [a, b]^T$，其中$\\mathbf{d}$是观测到的漂移率向量，$X$是设计矩阵：\n    $$\n    X = \\begin{pmatrix} \\Delta t_1^2  1 \\\\ \\Delta t_2^2  1 \\\\ \\vdots  \\vdots \\\\ \\Delta t_m^2  1 \\end{pmatrix}, \\quad \\beta = \\begin{pmatrix} a \\\\ b \\end{pmatrix}, \\quad \\mathbf{d} = \\begin{pmatrix} d_1 \\\\ d_2 \\\\ \\vdots \\\\ d_m \\end{pmatrix}\n    $$\n    OLS解由$\\hat{\\beta} = (X^T X)^{-1} X^T \\mathbf{d}$给出。这在计算上通过使用标准的线性代数库函数来实现。\n\n2.  **最大连续时间步长的推导**：\n    核心约束是在$50$ ps的模拟时长内，总能量漂移不得超过指定的最大值$D_{\\max}$。预测的总漂移为$50 \\times d(\\Delta t)$。因此，约束条件是：\n    $$\n    50 \\times (a \\Delta t^2 + b) \\le D_{\\max}\n    $$\n    这等效于约束漂移率：\n    $$\n    d(\\Delta t) \\le \\frac{D_{\\max}}{50} \\equiv d_{\\text{max}}\n    $$\n    此不等式的解取决于$a$的符号。\n    -   如果$a  0$，漂移率是$\\Delta t$的增函数。不等式变为$\\Delta t^2 \\le (d_{\\text{max}} - b) / a$。如果$d_{\\text{max}} - b  0$，则没有正的$\\Delta t$可以满足此约束，问题不可行。否则，漂移模型允许的最大连续时间步长为$\\Delta t^{\\star} = \\sqrt{(d_{\\text{max}} - b) / a}$。\n    -   如果$a \\le 0$，漂移率是$\\Delta t$的非增函数。漂移在$\\Delta t=0$时最大，等于$b$。如果$b  d_{\\text{max}}$，则漂移总是过高，问题不可行。如果$b \\le d_{\\text{max}}$，则对于所有$\\Delta t \\ge 0$，漂移约束都得到满足。\n    在所有情况下，解还必须遵守显式边界$[\\Delta t_{\\min}, \\Delta t_{\\max}]$。因此，我们通过取模型推导出的边界（如果存在）和显式上界$\\Delta t_{\\max}$的最小值，来找到一个候选上界$\\Delta t^{\\star\\star}$。\n\n3.  **离散化与最终选择**：\n    最后一步是找到位于区间$[\\Delta t_{\\min}, \\Delta t_{\\max}]$内、间距为$\\delta$的离散网格上最大的允许$\\Delta t$。\n    首先，我们确定小于或等于我们候选上界$\\Delta t^{\\star\\star}$的最高可能网格点。计算如下：\n    $$\n    n = \\left\\lfloor \\frac{\\Delta t^{\\star\\star} - \\Delta t_{\\min}}{\\delta} \\right\\rfloor\n    $$\n    网格上的初始候选值为$\\Delta t_{\\text{grid}} = \\Delta t_{\\min} + n\\delta$。如果此计算导致$\\Delta t_{\\text{grid}}  \\Delta t_{\\min}$（当$\\Delta t^{\\star\\star}  \\Delta t_{\\min}$时发生），则在允许的区间内不存在可行解。\n    否则，我们从$\\Delta t_{\\text{grid}}$开始向下搜索。我们检查漂移约束$50 \\times d(\\Delta t_{\\text{grid}}) \\le D_{\\max}$是否满足。如果满足，$\\Delta t_{\\text{grid}}$就是我们的答案，因为它是保证安全的最大的网格点。如果不满足（这可能是由于模型的近似性或浮点不精确性造成的），我们将时间步长递减$\\delta$并重复检查。此过程一直持续到找到一个可行的$\\Delta t$或时间步长降到$\\Delta t_{\\min}$以下。如果搜索未能找到可行的时间步长，则结果报告为不可行（$-1.000$）。\n\n这个结构化的过程确保所选择的$\\Delta t$是严格遵守所有指定的物理和数值约束的最大可能值，为模拟提供了一个鲁棒且最优的选择。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"dt_measured\": [0.06, 0.10, 0.14, 0.18],\n            \"d_measured\": [0.0134, 0.0420, 0.0754, 0.1306],\n            \"D_max\": 5.0,\n            \"dt_min\": 0.040,\n            \"dt_max\": 0.200,\n            \"delta\": 0.001\n        },\n        # Case 2\n        {\n            \"dt_measured\": [0.08, 0.16, 0.24, 0.30],\n            \"d_measured\": [0.00736, 0.01574, 0.02834, 0.04060],\n            \"D_max\": 2.0,\n            \"dt_min\": 0.050,\n            \"dt_max\": 0.300,\n            \"delta\": 0.001\n        },\n        # Case 3\n        {\n            \"dt_measured\": [0.05, 0.08, 0.11, 0.14],\n            \"d_measured\": [0.01195, 0.01750, 0.02645, 0.03720],\n            \"D_max\": 0.5,\n            \"dt_min\": 0.050,\n            \"dt_max\": 0.200,\n            \"delta\": 0.001\n        },\n        # Case 4\n        {\n            \"dt_measured\": [0.10, 0.20, 0.35, 0.50],\n            \"d_measured\": [0.00230, 0.00275, 0.00450, 0.00690],\n            \"D_max\": 10.0,\n            \"dt_min\": 0.050,\n            \"dt_max\": 0.500,\n            \"delta\": 0.001\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_optimal_dt(case)\n        results.append(f\"{result:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef find_optimal_dt(case_data):\n    \"\"\"\n    Solves for the optimal time step for a single test case.\n    \"\"\"\n    dt_measured = np.array(case_data[\"dt_measured\"])\n    d_measured = np.array(case_data[\"d_measured\"])\n    D_max = case_data[\"D_max\"]\n    dt_min = case_data[\"dt_min\"]\n    dt_max = case_data[\"dt_max\"]\n    delta = case_data[\"delta\"]\n\n    # 1. Fit the linear model d(dt) = a*dt^2 + b using ordinary least squares.\n    x_var = dt_measured**2\n    # Design matrix for OLS: [x, 1]\n    A = np.vstack([x_var, np.ones(len(x_var))]).T\n    a, b = np.linalg.lstsq(A, d_measured, rcond=None)[0]\n\n    # 2. Compute the maximum permissible dt based on the drift model.\n    d_max_rate = D_max / 50.0\n\n    dt_upper_bound = None\n    infeasible = False\n\n    if a = 0:\n        # If drift is non-increasing, feasibility is determined by the baseline drift b.\n        if b > d_max_rate:\n            infeasible = True\n        else:\n            # The drift constraint is met for all dt. The limit is dt_max.\n            dt_upper_bound = dt_max\n    else:  # a > 0\n        # Drift is increasing. Solve a*dt^2 + b = d_max_rate.\n        rhs = d_max_rate - b\n        if rhs  0:\n            infeasible = True\n        else:\n            dt_star_continuous = np.sqrt(rhs / a)\n            # The candidate dt must also be within the allowed interval.\n            dt_upper_bound = min(dt_star_continuous, dt_max)\n\n    if infeasible:\n        return -1.0\n\n    # 3. Enforce grid constraints and find the largest feasible discrete dt.\n    \n    # If the continuous upper bound is already below the minimum allowed dt, no solution exists.\n    if dt_upper_bound  dt_min:\n        return -1.0\n\n    # Round down to the nearest grid point.\n    n = np.floor((dt_upper_bound - dt_min) / delta)\n    current_dt = dt_min + n * delta\n\n    # Iteratively check from the rounded-down candidate, decrementing by delta.\n    # This loop starts from the highest possible grid point and moves down,\n    # so the first feasible point found is the answer.\n    while current_dt >= dt_min - 1e-9: # Use small tolerance for float comparison\n        predicted_drift_rate = a * current_dt**2 + b\n        total_drift = 50.0 * predicted_drift_rate\n        \n        if total_drift = D_max:\n            return current_dt\n\n        current_dt -= delta\n\n    # If the loop completes without finding a feasible dt.\n    return -1.0\n\nsolve()\n```"
        },
        {
            "introduction": "即使参数已经过精心选择，系统中原子几何构型的快速变化（例如在化学反应过程中）仍然可能对绝热近似构成挑战。这项高级实践通过一个简化的模型模拟了这样一个动态过程——化学吸附事件。你将学习如何通过监测虚拟电子动能的变化，来量化绝热近似被破坏的程度，并计算一个无量纲的“失效度量” 。这项练习有助于我们理解CPMD方法的适用边界，并学会在模拟动态过程时诊断潜在的物理问题。",
            "id": "3871910",
            "problem": "考虑在Car-Parrinello分子动力学(CPMD)中检测绝热性破缺，例如在一氧化碳在铂$(\\mathrm{CO}/\\mathrm{Pt}(111))$上的化学吸附事件中。在CPMD中，电子自由度被赋予一个虚拟质量并与原子核一起演化，以使电子保持在瞬时Born-Oppenheimer基态附近。在快速化学吸附过程中，核坐标的加速可能将电子子系统推离绝热机制，这可以通过电子动能的增长来量化。请基于一个简化的、受CPMD启发的拉格朗日量设计一个简化的通用测试，对其进行数值模拟，并报告一组测试案例中的无量纲破缺度量。\n\n模型假设和定义：\n- 使用单个电子集体坐标$\\psi(t)$表示主要的占据Kohn-Sham子空间响应，以及单个核反应坐标$s(t)$表示吸附物到表面的接近距离。\n- 采用简化的类Car-Parrinello拉格朗日量\n$$\nL(\\psi,\\dot{\\psi},s,\\dot{s})=\\frac{\\mu}{2}\\,\\dot{\\psi}^2+\\frac{M}{2}\\,\\dot{s}^2 - U(\\psi,s)\n$$\n其中$\\mu$是虚拟电子质量，$\\,M\\,$是反应坐标的核折合质量。势能$U(\\psi,s)$包含一个谐波项，该项惩罚$\\psi$对一个依赖于$s$的基态参考$\\psi_{\\mathrm{eq}}(s)$的偏离，\n$$\nU(\\psi,s)=\\frac{k_e}{2}\\left(\\psi-\\psi_{\\mathrm{eq}}(s)\\right)^2+V_{\\mathrm{ads}}(s)\n$$\n其中$k_e$是刚度参数。对于此测试，以恒定的接近速度指定核轨迹，使得$\\dot{s}(t)=-v$且$s(t)=s_0-v t$，直到达到$s_f$，并将$V_{\\mathrm{ads}}(s)$设置为一个在指定的$s(t)$下不进入电子运动方程的任意参考。定义\n$$\n\\psi_{\\mathrm{eq}}(s) = A\\,\\tanh\\!\\left(\\alpha\\,(s_{\\mathrm{ref}}-s)\\right)\n$$\n其中$A$是振幅，$\\alpha$是陡峭度，$s_{\\mathrm{ref}}$是电子结构开始快速变化的参考分离距离。\n\n待计算量：\n- 时间$t$时的电子动能为\n$$\nE_{\\mathrm{elec}}(t)=\\frac{\\mu}{2}\\,\\dot{\\psi}(t)^2\n$$\n- 对于指定的轨迹，离子动能是恒定的，\n$$\nK_{\\mathrm{ion}}=\\frac{M}{2}\\,v^2\n$$\n- 定义无量纲破缺度量\n$$\nR_{\\max}=\\max_{t\\in[0,T]}\\frac{E_{\\mathrm{elec}}(t)}{K_{\\mathrm{ion}}}\n$$\n其中$T=(s_0-s_f)/v$是总接近时间。较大的$R_{\\max}$表示与绝热跟随的偏离更强；$R_{\\max}$值接近或超过$0.1$表明发生破缺。\n\n任务：\n- 仅从应用于上述$L$和指定的$s(t)$的欧拉-拉格朗日方程出发，推导$\\psi(t)$的时间演化方程。\n- 使用恒定时间步长$\\Delta t$，在$t\\in[0,T]$上实现一个稳定、显式的时间积分算法来求解$\\psi(t)$。用$\\psi(0)=\\psi_{\\mathrm{eq}}(s_0)$和$\\dot{\\psi}(0)=0$进行初始化。\n- 计算每个给定参数集的$R_{\\max}$。所有能量以Hartree报告，时间以原子单位报告，最终度量为无量纲浮点数。\n\n单位规范：\n- 能量必须以Hartree计算和解释。\n- 时间必须以原子单位计算。\n- 最终的破缺度量$R_{\\max}$是无量纲的，必须报告为浮点数。\n\n测试套件：\n使用以下参数集，这些参数集改变了虚拟电子质量、时间步长、接近速度和电子响应的锐度。在每种情况下，设置$s_{\\mathrm{ref}}=2.5$、$k_e=1.0$和$M=50.0$。\n1. 案例$1$（理想情况，慢速接近）：$\\mu=400.0$, $\\Delta t=0.005$, $v=0.001$, $s_0=3.0$, $s_f=2.0$, $A=0.5$, $\\alpha=5.0$.\n2. 案例$2$（中等速度和刚度）：$\\mu=200.0$, $\\Delta t=0.010$, $v=0.003$, $s_0=3.0$, $s_f=2.0$, $A=0.8$, $\\alpha=7.0$.\n3. 案例$3$（快速接近，更锐的电子变化）：$\\mu=100.0$, $\\Delta t=0.020$, $v=0.010$, $s_0=3.0$, $s_f=2.0$, $A=1.0$, $\\alpha=10.0$.\n4. 案例$4$（激进的参数，可能的破缺）：$\\mu=50.0$, $\\Delta t=0.050$, $v=0.020$, $s_0=3.0$, $s_f=2.0$, $A=1.2$, $\\alpha=12.0$.\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序与测试套件相同（例如，$[\\text{result1},\\text{result2},\\text{result3},\\text{result4}]$）。每个结果必须是相应案例的$R_{\\max}$的浮点值。",
            "solution": "该问题已被分析并被认为是有效的。它在科学上基于经典力学原理和Car-Parrinello分子动力学(CPMD)方法。该问题定义明确，提供了所有必要的参数、初始条件和明确的目标。它被客观地呈现，没有矛盾或含糊之处。\n\n问题的核心是求解单个电子集体坐标$\\psi(t)$的运动方程，其行为由一个简化的类CPMD拉格朗日量控制，并量化系统与绝热性的偏离程度。由坐标$s(t)$描述的核运动被指定为恒速接近。\n\n首先，我们使用欧拉-拉格朗日方程推导$\\psi(t)$的运动方程：\n$$\n\\frac{d}{dt}\\left(\\frac{\\partial L}{\\partial \\dot{\\psi}}\\right) - \\frac{\\partial L}{\\partial \\psi} = 0\n$$\n拉格朗日量由以下公式给出：\n$$\nL(\\psi,\\dot{\\psi},s,\\dot{s})=\\frac{\\mu}{2}\\,\\dot{\\psi}^2+\\frac{M}{2}\\,\\dot{s}^2 - U(\\psi,s)\n$$\n势能为：\n$$\nU(\\psi,s)=\\frac{k_e}{2}\\left(\\psi-\\psi_{\\mathrm{eq}}(s)\\right)^2+V_{\\mathrm{ads}}(s)\n$$\n$L$关于$\\psi$和$\\dot{\\psi}$的必要偏导数为：\n$$\n\\frac{\\partial L}{\\partial \\dot{\\psi}} = \\mu\\dot{\\psi}\n$$\n$$\n\\frac{\\partial L}{\\partial \\psi} = -\\frac{\\partial U}{\\partial \\psi} = -\\frac{\\partial}{\\partial \\psi}\\left[\\frac{k_e}{2}(\\psi - \\psi_{\\mathrm{eq}}(s))^2\\right] = -k_e(\\psi - \\psi_{\\mathrm{eq}}(s))\n$$\n将这些代入欧拉-拉格朗日方程，得到：\n$$\n\\frac{d}{dt}(\\mu\\dot{\\psi}) - \\left[-k_e(\\psi - \\psi_{\\mathrm{eq}}(s))\\right] = 0\n$$\n$$\n\\mu\\ddot{\\psi}(t) + k_e(\\psi(t) - \\psi_{\\mathrm{eq}}(s(t))) = 0\n$$\n这可以重写为关于$\\psi(t)$的二阶常微分方程(ODE)：\n$$\n\\ddot{\\psi}(t) = -\\frac{k_e}{\\mu}\\left(\\psi(t) - \\psi_{\\mathrm{eq}}(s(t))\\right)\n$$\n这个方程描述了一个固有频率为$\\omega_e = \\sqrt{k_e/\\mu}$的谐振子。由于指定的核运动$s(t) = s_0 - v t$，平衡点$\\psi_{\\mathrm{eq}}(s(t))$是随时间变化的，这对电子子系统起到了驱动力的作用。当电子坐标$\\psi(t)$能够精确地跟随移动的平衡点$\\psi_{\\mathrm{eq}}(s(t))$时，系统是绝热的。这种情况发生在驱动运动的特征频率远小于电子振子的固有频率时，该条件可以表示为$\\mu(v\\alpha)^2 \\ll k_e$。\n\n为了数值求解此常微分方程，我们采用Velocity Verlet算法，这是一种在分子动力学中因其数值稳定性和准确性而常用的时间可逆和辛积分器。令$\\psi_n$、$\\dot{\\psi}_n$和$a_n = \\ddot{\\psi}_n$分别表示坐标$\\psi$在时间$t_n = n\\Delta t$时的位置、速度和加速度。下一个时间步$t_{n+1}$的状态计算如下：\n1. 更新位置：\n$$\n\\psi_{n+1} = \\psi_n + \\dot{\\psi}_n \\Delta t + \\frac{1}{2} a_n (\\Delta t)^2\n$$\n2. 计算新的加速度$a_{n+1}$。这需要新的核坐标$s_{n+1} = s(t_{n+1})$：\n$$\na_{n+1} = -\\frac{k_e}{\\mu}\\left(\\psi_{n+1} - \\psi_{\\mathrm{eq}}(s_{n+1})\\right)\n$$\n3. 更新速度：\n$$\n\\dot{\\psi}_{n+1} = \\dot{\\psi}_n + \\frac{1}{2}(a_n + a_{n+1})\\Delta t\n$$\n模拟从指定的初始条件开始：$\\psi(0) = \\psi_{\\mathrm{eq}}(s_0)$和$\\dot{\\psi}(0) = 0$。这意味着初始加速度$a_0$为零。模拟进行总时间$T = (s_0 - s_f)/v$。\n\n在整个模拟过程中，我们监测电子动能$E_{\\mathrm{elec}}(t) = \\frac{\\mu}{2}\\dot{\\psi}(t)^2$。记录该能量的最大值$\\max_{t} E_{\\mathrm{elec}}(t)$。最后，将此最大值用恒定的离子动能$K_{\\mathrm{ion}} = \\frac{M}{2}v^2$进行归一化，以计算无量纲破缺度量：\n$$\nR_{\\max} = \\frac{\\max_{t \\in [0,T]} E_{\\mathrm{elec}}(t)}{K_{\\mathrm{ion}}}\n$$\n对测试套件中提供的四个参数集中的每一个重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(mu, dt, v, s0, sf, A, alpha, ke, M, s_ref):\n    \"\"\"\n    Runs a single simulation for a given set of parameters.\n\n    This function integrates the equation of motion for the electronic coordinate\n    psi(t) using the Velocity Verlet algorithm and computes the breakdown metric R_max.\n    \"\"\"\n    # Calculate total simulation time, ionic kinetic energy, and number of steps\n    if v = 0:\n        # Avoid division by zero if v is non-positive.\n        return 0.0\n    T = (s0 - sf) / v\n    K_ion = 0.5 * M * v**2\n    if K_ion == 0:\n        # Avoid division by zero if there's no ionic motion.\n        return 0.0\n    \n    num_steps = int(T / dt)\n\n    # Initial conditions at t=0\n    s = s0\n    psi_eq_val = A * np.tanh(alpha * (s_ref - s))\n    psi = psi_eq_val\n    psi_dot = 0.0\n    \n    # The initial acceleration is zero because psi(0) = psi_eq(s_0)\n    accel = 0.0\n\n    max_E_elec = 0.0\n\n    # Main integration loop using the Velocity Verlet algorithm\n    for i in range(num_steps):\n        # Step 1: Update position-like coordinate psi\n        psi = psi + psi_dot * dt + 0.5 * accel * (dt**2)\n\n        # Step 2: Calculate new acceleration\n        # First, find the new nuclear coordinate s at time t + dt\n        t_new = (i + 1) * dt\n        s_new = s0 - v * t_new\n        \n        # Then, find the new equilibrium psi and the new acceleration\n        psi_eq_new = A * np.tanh(alpha * (s_ref - s_new))\n        accel_new = -(ke / mu) * (psi - psi_eq_new)\n\n        # Step 3: Update velocity-like coordinate psi_dot\n        psi_dot = psi_dot + 0.5 * (accel + accel_new) * dt\n        \n        # Prepare for the next iteration\n        accel = accel_new\n        \n        # Calculate instantaneous electronic kinetic energy and update the maximum\n        E_elec = 0.5 * mu * (psi_dot**2)\n        if E_elec > max_E_elec:\n            max_E_elec = E_elec\n    \n    # Calculate the final dimensionless breakdown metric\n    R_max = max_E_elec / K_ion\n    return R_max\n\ndef solve():\n    \"\"\"\n    Defines the test cases and runs the simulation for each to generate the final output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path, slow approach)\n        {'mu': 400.0, 'dt': 0.005, 'v': 0.001, 's0': 3.0, 'sf': 2.0, 'A': 0.5, 'alpha': 5.0},\n        # Case 2 (moderate speed and stiffness)\n        {'mu': 200.0, 'dt': 0.010, 'v': 0.003, 's0': 3.0, 'sf': 2.0, 'A': 0.8, 'alpha': 7.0},\n        # Case 3 (fast approach, sharper electronic change)\n        {'mu': 100.0, 'dt': 0.020, 'v': 0.010, 's0': 3.0, 'sf': 2.0, 'A': 1.0, 'alpha': 10.0},\n        # Case 4 (aggressive parameters, potential breakdown)\n        {'mu': 50.0,  'dt': 0.050, 'v': 0.020, 's0': 3.0, 'sf': 2.0, 'A': 1.2, 'alpha': 12.0},\n    ]\n\n    # Shared parameters for all test cases\n    common_params = {'ke': 1.0, 'M': 50.0, 's_ref': 2.5}\n\n    results = []\n    for case in test_cases:\n        params = {**case, **common_params}\n        result = run_simulation(**params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}