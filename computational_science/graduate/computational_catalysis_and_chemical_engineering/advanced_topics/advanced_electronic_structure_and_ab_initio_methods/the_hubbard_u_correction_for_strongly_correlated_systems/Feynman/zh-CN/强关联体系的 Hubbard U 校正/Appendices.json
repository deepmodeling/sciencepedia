{
    "hands_on_practices": [
        {
            "introduction": "任何DFT计算结果的可靠性都取决于数值参数的恰当选择，例如平面波截断能 $E_{\\text{cut}}$ 和k点网格密度。这些参数分别控制着基组的完备性和布里渊区积分的精度。本练习 () 提供了一个实践机会，让您能够实现一套系统的收敛性测试方案。这是一项计算研究人员必须掌握的基本技能，可确保计算出的物理性质不是数值选择所造成的人为结果。",
            "id": "3901882",
            "problem": "考虑一项对过渡金属氧化物催化剂的计算研究，其中局域化的 $d$ 电子需要 Hubbard $U$ 校正才能正确捕捉强关联效应。电子结构采用平面波和布里渊区（BZ）的离散化采样进行计算。目标是仅使用所提供的数值序列和基于原则的收敛性评估，来确定计算出的 Hubbard $U$ 参数和探针物种的吸附能是否在平面波动能截断和 $k$ 点网格密度两方面都达到了数值收敛。\n\n基础和背景：\n- 在 Kohn-Sham 密度泛函理论（DFT）中增加 Hubbard $U$ 校正后，总能量相对于电子密度被最小化，基态能量相对于基组是变分的。增加平面波截断能 $E_{\\mathrm{cut}}$ 会扩展基组，并减少波函数和电荷密度表示中的离散化误差。\n- BZ 积分通过有限的 $k$ 点网格进行近似。增加 $k$ 点数量可以提高周期性系统的求积精度，并减少依赖于电子结构的观测量所产生的采样误差。\n- 对于足够平滑的赝势和被积函数，由基组截断和 BZ 采样引起的数值误差会随着分辨率的提高而系统性地减小。一个通用且广泛使用的模型描述了属性 $P$ 作为平面波截断能 $E_{\\mathrm{cut}}$ 和均匀网格中 $k$ 点总数 $N_{k}$ 的函数的收敛行为，该模型表现为向渐近极限的加性幂律衰减：\n$$\nP\\left(E_{\\mathrm{cut}}, N_{k}\\right) \\approx P_{\\infty} + a\\,E_{\\mathrm{cut}}^{-\\alpha} + b\\,N_{k}^{-\\beta},\n$$\n其中 $P_{\\infty}$ 是收敛（无限分辨率）值，而 $a$、$b$、$\\alpha$、$\\beta$ 是根据经验确定的正模型参数。此形式体现了增加 $E_{\\mathrm{cut}}$ 和 $N_{k}$ 会以平滑、衰减的方式减少误差的原则。\n\n设计一个程序，对每个测试用例，都为 Hubbard $U$ 参数和吸附能 $E_{\\mathrm{ads}}$ 执行以下操作：\n1. 接受两个一维收敛序列：在固定的足够密的 $k$ 点网格下，随 $E_{\\mathrm{cut}}$ 增加的 $P(E_{\\mathrm{cut}})$；以及在固定的足够高的 $E_{\\mathrm{cut}}$ 下，随 $N_{k}$ 增加的 $P(N_{k})$。能量必须以电子伏特（eV）为单位处理，$E_{\\mathrm{cut}}$ 也必须以电子伏特（eV）为单位处理。$k$ 点总数 $N_{k}$ 是无量纲的。\n2. 将每个一维序列拟合到幂律模型 $P(x) = P_{\\infty} + c\\,x^{-\\gamma}$，其中 $x \\in \\{E_{\\mathrm{cut}}, N_{k}\\}$，参数为 $\\{P_{\\infty}, c, \\gamma\\}$，并强制要求 $\\gamma > 0$。\n3. 基于变分原理和平滑求积收敛这两个原则性检查，为每个序列定义一个收敛判定：\n   - 局部解析度增量检查：最后两个计算值之间的绝对变化必须低于为该属性指定的容差 $\\tau$，即 $|P_{n} - P_{n-1}| \\le \\tau$。\n   - 渐近一致性检查：最后一个计算值与拟合的渐近极限之间的绝对偏差必须低于相同的容差 $\\tau$，即 $|P_{n} - P_{\\infty}| \\le \\tau$。\n4. 当且仅当 $E_{\\mathrm{cut}}$ 序列和 $N_{k}$ 序列都通过上述两项检查时，才声明该属性收敛。\n5. 为每个测试用例报告一个布尔结果，指明在给定的容差下，两个属性（Hubbard $U$ 和吸附能 $E_{\\mathrm{ads}}$）是否都已收敛。\n\n使用以下测试套件，它为 $E_{\\mathrm{cut}}$（单位 eV）、$N_{k}$（无量纲总 $k$ 点数）和测量的属性值（单位 eV）提供了序列。Hubbard $U$ 的容差为 $\\tau_{U} = 0.05$ eV，吸附能的容差为 $\\tau_{\\mathrm{ads}} = 0.02$ eV。\n\n测试用例 A（理想情况，平滑收敛）：\n- Hubbard $U$ vs $E_{\\mathrm{cut}}$: $E_{\\mathrm{cut}} = [\\,300,\\,400,\\,500,\\,600\\,]$ eV, $U(E_{\\mathrm{cut}}) = [\\,4.35,\\,4.27,\\,4.22,\\,4.21\\,]$ eV.\n- Hubbard $U$ vs $N_{k}$: $N_{k} = [\\,27,\\,64,\\,125,\\,216\\,]$, $U(N_{k}) = [\\,4.25,\\,4.22,\\,4.21,\\,4.20\\,]$ eV.\n- 吸附能 vs $E_{\\mathrm{cut}}$: $E_{\\mathrm{cut}} = [\\,300,\\,400,\\,500,\\,600\\,]$ eV, $E_{\\mathrm{ads}}(E_{\\mathrm{cut}}) = [\\,-1.36,\\,-1.32,\\,-1.31,\\,-1.30\\,]$ eV.\n- 吸附能 vs $N_{k}$: $N_{k} = [\\,27,\\,64,\\,125,\\,216\\,]$, $E_{\\mathrm{ads}}(N_{k}) = [\\,-1.33,\\,-1.31,\\,-1.30,\\,-1.30\\,]$ eV.\n\n测试用例 B（临界收敛，伴有轻微振荡）：\n- Hubbard $U$ vs $E_{\\mathrm{cut}}$: $E_{\\mathrm{cut}} = [\\,300,\\,350,\\,400,\\,500,\\,650\\,]$ eV, $U(E_{\\mathrm{cut}}) = [\\,4.50,\\,4.45,\\,4.47,\\,4.46,\\,4.45\\,]$ eV.\n- Hubbard $U$ vs $N_{k}$: $N_{k} = [\\,27,\\,64,\\,125,\\,216,\\,343\\,]$, $U(N_{k}) = [\\,4.50,\\,4.47,\\,4.46,\\,4.45,\\,4.45\\,]$ eV.\n- 吸附能 vs $E_{\\mathrm{cut}}$: $E_{\\mathrm{cut}} = [\\,300,\\,350,\\,400,\\,500,\\,650\\,]$ eV, $E_{\\mathrm{ads}}(E_{\\mathrm{cut}}) = [\\,-0.95,\\,-0.93,\\,-0.94,\\,-0.94,\\,-0.94\\,]$ eV.\n- 吸附能 vs $N_{k}$: $N_{k} = [\\,27,\\,64,\\,125,\\,216,\\,343\\,]$, $E_{\\mathrm{ads}}(N_{k}) = [\\,-0.94,\\,-0.93,\\,-0.94,\\,-0.94,\\,-0.94\\,]$ eV.\n\n测试用例 C（在给定范围内未收敛）：\n- Hubbard $U$ vs $E_{\\mathrm{cut}}$: $E_{\\mathrm{cut}} = [\\,250,\\,300,\\,400,\\,500\\,]$ eV, $U(E_{\\mathrm{cut}}) = [\\,3.80,\\,3.60,\\,3.50,\\,3.45\\,]$ eV.\n- Hubbard $U$ vs $N_{k}$: $N_{k} = [\\,8,\\,27,\\,64,\\,125\\,]$, $U(N_{k}) = [\\,3.90,\\,3.70,\\,3.55,\\,3.50\\,]$ eV.\n- 吸附能 vs $E_{\\mathrm{cut}}$: $E_{\\mathrm{cut}} = [\\,250,\\,300,\\,400,\\,500\\,]$ eV, $E_{\\mathrm{ads}}(E_{\\mathrm{cut}}) = [\\,-1.10,\\,-1.00,\\,-0.90,\\,-0.85\\,]$ eV.\n- 吸附能 vs $N_{k}$: $N_{k} = [\\,8,\\,27,\\,64,\\,125\\,]$, $E_{\\mathrm{ads}}(N_{k}) = [\\,-1.00,\\,-0.95,\\,-0.90,\\,-0.88\\,]$ eV.\n\n最终输出规范：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个布尔值对应一个测试用例，表示两个属性（Hubbard $U$ 和吸附能 $E_{\\mathrm{ads}}$）是否在其各自的容差下都已收敛。例如，输出应具有 $[\\,\\mathrm{True},\\mathrm{False},\\mathrm{True}\\,]$ 的形式，且大小写需完全一致。",
            "solution": "目标是为 Hubbard $U$ 参数和吸附能 $E_{\\mathrm{ads}}$ 设计一个基于原则的收敛性评估方法，该评估需针对平面波动能截断 $E_{\\mathrm{cut}}$ 和布里渊区（BZ）的 $k$ 点网格密度 $N_{k}$。此方法必须与基本原理相联系，并提供明确的判定规则。\n\n原则基础：\n1. Kohn-Sham 密度泛函理论（DFT）的能量，在增加了 Hubbard $U$ 校正后，是相对于电子密度最小化的。Hubbard 项可以写成旋转不变形式：\n$$\nE_{U} = \\frac{U}{2}\\sum_{I,m,\\sigma}\\left(n_{Im\\sigma} - n_{Im\\sigma}^{2}\\right),\n$$\n其中 $I$ 标记原子， $m$ 标记局域化轨道，$\\sigma$ 标记自旋。该项惩罚局域态的非整数占据，并校正自相互作用误差。总能量仍然是一个相对于密度和占据数进行变分最小化的泛函。因此，根据变分原理，通过提高 $E_{\\mathrm{cut}}$ 来增加基组完备性必不会增加能量，并且它会系统地减少基态密度及衍生可观测量（包括线性响应计算的 $U$ 和 $E_{\\mathrm{ads}}$）的离散化误差。\n2. 周期性系统的 BZ 积分通过使用一个包含 $N_{k}$ 个点的离散网格来近似。对于足够平滑的被积函数和均匀网格，随着 $N_{k}$ 的增加，求积误差会因电子态采样的改善而减小，从而减少了从电子结构计算出的可观测量的数值积分误差。\n\n误差建模：\n为捕捉属性 $P$（Hubbard $U$ 或 $E_{\\mathrm{ads}}$）渐近趋近收敛极限的过程，我们采用一个通用的加性衰减模型：\n$$\nP\\left(E_{\\mathrm{cut}}, N_{k}\\right) \\approx P_{\\infty} + a\\,E_{\\mathrm{cut}}^{-\\alpha} + b\\,N_{k}^{-\\beta},\n$$\n其中 $P_{\\infty}$ 是无限分辨率极限，而正参数 $a$、$b$、$\\alpha$、$\\beta$ 用于拟合收敛行为。该模型与以下两点一致：\n- 基组截断误差：对于动能截断为 $E_{\\mathrm{cut}} = \\hbar^{2} k_{c}^{2}/(2m_{e})$ 的平面波，忽略 $k > k_{c}$ 的傅里叶分量所产生的误差会随着 $k_{c}$ 的增加而平滑减小，这通常可以用 $E_{\\mathrm{cut}}$ 的幂律衰减来描述。\n- BZ 采样误差：在 BZ 上对平滑被积函数进行均匀求积，其误差会随着点数 $N_{k}$ 的增加而减小，这在经验上也常通过幂律来描述。\n\n算法设计：\n我们为每个序列构建一维拟合：\n- 对于固定的密集 $k$ 点网格，将 $P(E_{\\mathrm{cut}})$ 拟合到 $P(E) = P_{\\infty}^{(E)} + c_{E}\\,E^{-\\gamma_{E}}$，且 $\\gamma_{E} > 0$。\n- 对于固定的高 $E_{\\mathrm{cut}}$，将 $P(N_{k})$ 拟合到 $P(N) = P_{\\infty}^{(N)} + c_{N}\\,N^{-\\gamma_{N}}$，且 $\\gamma_{N} > 0$。\n\n我们通过非线性最小二乘法来估计参数 $\\{P_{\\infty}, c, \\gamma\\}$，并约束 $\\gamma > 0$。拟合得到的 $P_{\\infty}$ 提供了一个与观测到的衰减趋势一致的渐近极限，而无需假设具体的指数。\n\n收敛性判定：\n对于每个序列，我们定义两个检查：\n1. 局部增量检查：\n$$\n\\Delta_{\\mathrm{last}} \\equiv \\left|P_{n} - P_{n-1}\\right| \\le \\tau,\n$$\n确保最后一次分辨率的提升所引起的变化小于容差 $\\tau$。\n2. 渐近一致性检查：\n$$\n\\delta_{\\infty} \\equiv \\left|P_{n} - P_{\\infty}\\right| \\le \\tau,\n$$\n确保最后一个计算值与拟合的收敛极限之间的差距在容差 $\\tau$ 之内。\n\n如果属性 $P$ 的 $E_{\\mathrm{cut}}$ 序列和 $N_{k}$ 序列都通过了这两项检查，则声明该属性收敛。对于 Hubbard $U$，容差为 $\\tau_{U} = 0.05$ eV；对于吸附能，容差为 $\\tau_{\\mathrm{ads}} = 0.02$ eV。\n\n实现细节：\n- 使用非线性最小二乘法拟合 $P(x) = P_{\\infty} + c\\,x^{-\\gamma}$，其中 $x \\in \\{E_{\\mathrm{cut}}, N_{k}\\}$，边界为 $\\gamma \\in (0, \\Gamma_{\\max})$，对于某个合理的 $\\Gamma_{\\max}$（例如，$\\Gamma_{\\max} = 5$），而 $P_{\\infty}$ 和 $c$ 无约束。\n- 初始化 $P_{\\infty}$ 为最后一个观测值，$c$ 为第一个和最后一个值的差，$\\gamma$ 为 1，以帮助提高数值稳定性。\n- 为两个序列计算 $\\Delta_{\\mathrm{last}}$ 和 $\\delta_{\\infty}$，并与相应的 $\\tau$ 进行比较。\n- 每个测试用例的总体布尔值为真，当且仅当两个属性在其各自的容差下都收敛时。\n\n测试集的解释：\n- 测试用例 A 显示，$U$ 和 $E_{\\mathrm{ads}}$ 对于 $E_{\\mathrm{cut}}$ 和 $N_{k}$ 都呈现平滑的单调收敛。最后的增量很小（例如，对于 $U$ 关于 $E_{\\mathrm{cut}}$， $|4.21 - 4.22| = 0.01$ eV $\\le 0.05$ eV），并且拟合的渐近极限应接近最后的值，因此预期会收敛。\n- 测试用例 B 包含轻微的振荡，这通常是数值噪声或与 Pulay 相关的微小假象的典型表现；然而，振荡在最后增量和拟合极限上都在容差范围内，因此仍应确认收敛。\n- 测试用例 C 显示，对于 $U$ 和 $E_{\\mathrm{ads}}$，在最后一次精度提升中都存在显著变化，并且拟合的渐近值相对于最后一个值仍在容差之外，因此应判定为不收敛。\n\n程序将三个测试用例的结果汇总为一行布尔值输出，并采用指定的格式。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef power_decay_model(x, pinf, c, gamma):\n    # Model: P(x) = P_inf + c * x^{-gamma}, with gamma > 0\n    return pinf + c * np.power(x, -gamma)\n\ndef fit_power_decay(x, y):\n    # Ensure inputs are numpy arrays of float\n    x = np.asarray(x, dtype=float)\n    y = np.asarray(y, dtype=float)\n    # Initial guesses: P_inf ~ last value, c ~ (first - last), gamma ~ 1.0\n    p0 = [y[-1], (y[0] - y[-1]), 1.0]\n    # Bounds: pinf free, c free, gamma in (0, 5]\n    bounds = ([-np.inf, -np.inf, 1e-8], [np.inf, np.inf, 5.0])\n    try:\n        popt, _ = curve_fit(power_decay_model, x, y, p0=p0, bounds=bounds, maxfev=10000)\n    except RuntimeError:\n        # In case fitting fails, fall back to a simple estimate: pinf ~ last, c ~ 0, gamma ~ 1\n        popt = np.array([y[-1], 0.0, 1.0])\n    pinf, c, gamma = popt\n    return pinf, c, gamma\n\ndef sequence_converged(x, y, tol):\n    # Check last increment\n    if len(y)  2:\n        return False\n    last_inc = abs(y[-1] - y[-2])\n    # Fit asymptotic limit\n    pinf, _, _ = fit_power_decay(x, y)\n    last_to_inf = abs(y[-1] - pinf)\n    return (last_inc = tol) and (last_to_inf = tol)\n\ndef property_converged(ecuts, p_vs_ecuts, nks, p_vs_nks, tol):\n    # Convergence must hold for both sequences\n    conv_ecuts = sequence_converged(ecuts, p_vs_ecuts, tol)\n    conv_nks = sequence_converged(nks, p_vs_nks, tol)\n    return conv_ecuts and conv_nks\n\ndef solve():\n    # Tolerances\n    tau_U = 0.05   # eV\n    tau_ads = 0.02 # eV\n\n    # Test case A\n    ecuts_A = [300, 400, 500, 600]\n    nk_A = [27, 64, 125, 216]\n    U_vs_ecuts_A = [4.35, 4.27, 4.22, 4.21]\n    U_vs_nk_A = [4.25, 4.22, 4.21, 4.20]\n    Eads_vs_ecuts_A = [-1.36, -1.32, -1.31, -1.30]\n    Eads_vs_nk_A = [-1.33, -1.31, -1.30, -1.30]\n\n    # Test case B (borderline oscillations)\n    ecuts_B = [300, 350, 400, 500, 650]\n    nk_B = [27, 64, 125, 216, 343]\n    U_vs_ecuts_B = [4.50, 4.45, 4.47, 4.46, 4.45]\n    U_vs_nk_B = [4.50, 4.47, 4.46, 4.45, 4.45]\n    Eads_vs_ecuts_B = [-0.95, -0.93, -0.94, -0.94, -0.94]\n    Eads_vs_nk_B = [-0.94, -0.93, -0.94, -0.94, -0.94]\n\n    # Test case C (non-converged)\n    ecuts_C = [250, 300, 400, 500]\n    nk_C = [8, 27, 64, 125]\n    U_vs_ecuts_C = [3.80, 3.60, 3.50, 3.45]\n    U_vs_nk_C = [3.90, 3.70, 3.55, 3.50]\n    Eads_vs_ecuts_C = [-1.10, -1.00, -0.90, -0.85]\n    Eads_vs_nk_C = [-1.00, -0.95, -0.90, -0.88]\n\n    test_cases = [\n        (ecuts_A, U_vs_ecuts_A, nk_A, U_vs_nk_A, Eads_vs_ecuts_A, Eads_vs_nk_A),\n        (ecuts_B, U_vs_ecuts_B, nk_B, U_vs_nk_B, Eads_vs_ecuts_B, Eads_vs_nk_B),\n        (ecuts_C, U_vs_ecuts_C, nk_C, U_vs_nk_C, Eads_vs_ecuts_C, Eads_vs_nk_C),\n    ]\n\n    results = []\n    for (ecuts, U_e, nks, U_k, Eads_e, Eads_k) in test_cases:\n        conv_U = property_converged(ecuts, U_e, nks, U_k, tau_U)\n        conv_Eads = property_converged(ecuts, Eads_e, nks, Eads_k, tau_ads)\n        results.append(conv_U and conv_Eads)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Hubbard $U$ 参数是准确描述强关联体系的关键，但它并非一个普适常数，通常需要根据具体材料和性质凭经验确定。本实践 () 将引导您完成一个常见且物理直观的过程：通过将计算性质与实验值进行匹配来校准 $U$ 值。通过计算二氧化铈 ($\\text{CeO}_2$)——一个经典的基准体系——中氧空位形成能随 $U$ 值的变化，您将学习如何搭建理论计算与实验现实之间的桥梁。",
            "id": "3901897",
            "problem": "考虑二氧化铈($\\mathrm{CeO_2}$)，其在富氧条件下的氧空位形成能，从第一性原理出发，定义为包含一个中性氧空位的还原超胞、化学计量超胞与半个氧气分子参考态之间的总电子能量差。在电子结构理论中，使用标准的总能量计算方法，氧空位形成能 $E_{\\mathrm{v}}(U)$ 由以下核心热力学恒等式定义：\n$$\nE_{\\mathrm{v}}(U) \\equiv E_{\\mathrm{tot}}^{\\mathrm{defect}}(U) + \\tfrac{1}{2} E_{\\mathrm{tot}}^{\\mathrm{O_2}} - E_{\\mathrm{tot}}^{\\mathrm{pristine}}(U),\n$$\n其中，$E_{\\mathrm{tot}}^{\\mathrm{defect}}(U)$ 和 $E_{\\mathrm{tot}}^{\\mathrm{pristine}}(U)$ 分别是还原和化学计量的 $\\mathrm{CeO_2}$ 超胞的总电子能量，$E_{\\mathrm{tot}}^{\\mathrm{O_2}}$ 是气相氧分子的总电子能量。被称为带有 Hubbard $U$ 校正的密度泛函理论 (DFT$+U$) 的方法，引入了一种修正性的在位相互作用来处理局域化的铈 $4f$ 电子。为了这个在计算催化和化学工程校准中的计算练习，我们用一阶线性模型来近似每个超胞的总能量对 Hubbard 参数 $U$ 的依赖关系：\n$$\nE_{\\mathrm{tot}}^{\\mathrm{pristine}}(U) = A_{\\mathrm{p}} + B_{\\mathrm{p}}\\,U,\\quad\nE_{\\mathrm{tot}}^{\\mathrm{defect}}(U) = A_{\\mathrm{d}} + B_{\\mathrm{d}}\\,U,\\quad\nE_{\\mathrm{tot}}^{\\mathrm{O_2}} = A_{\\mathrm{O_2}},\n$$\n其中包含以下物理上合理的常数（单位为电子伏特）：$A_{\\mathrm{p}} = -1760.0$，$B_{\\mathrm{p}} = -0.05$，$A_{\\mathrm{d}} = -1751.27$，$B_{\\mathrm{d}} = -0.20$，以及 $A_{\\mathrm{O_2}} = -9.86$。在富氧条件下，氧的参考化学势为 $\\tfrac{1}{2} E_{\\mathrm{tot}}^{\\mathrm{O_2}}$。假设在中性缺陷超胞中，有限尺寸和电荷校正是可以忽略的（即，将任何额外的校正项设置为零）。\n\n你需要编写一个完整、可运行的程序，完成以下任务：\n- 使用上述定义和且仅使用这些常数，为指定集合中的每个 $U$ 计算 $E_{\\mathrm{v}}(U)$。\n- 将 $E_{\\mathrm{v}}(U)$ 与 $\\mathrm{CeO_2}$ 在近零温度下（参考于 $\\tfrac{1}{2}\\mathrm{O_2}$）的氧空位形成焓的实验热化学包络进行比较，此处该包络被建模为可接受区间 $[E_{\\min},E_{\\max}] = [3.0, 3.3]$ 电子伏特。使用此区间作为判断 $U$ 是否物理上合理的标准。\n- 根据以下确定性规则选择一个“物理上合理”的 $U$：\n  1. 如果一个或多个 $U$ 值产生的 $E_{\\mathrm{v}}(U)$ 位于 $[E_{\\min},E_{\\max}]$ 区间内，则选择其中最小的 $U$。\n  2. 如果没有 $U$ 值产生的 $E_{\\mathrm{v}}(U)$ 位于 $[E_{\\min},E_{\\max}]$ 区间内，则选择使 $E_{\\mathrm{v}}(U)$ 与中点 $\\tfrac{1}{2}(E_{\\min}+E_{\\max})$ 的绝对偏差最小化的 $U$。如果存在多个这样的 $U$，则选择其中较小者。\n\n你的程序必须使用以下 Hubbard $U$ 值的测试套件（单位为电子伏特）：$[0.0, 2.0, 3.5, 4.0, 6.0, 8.0]$。\n\n输出和单位要求：\n- 以电子伏特为单位计算每个氧空位形成能，并将每个值以电子伏特表示，四舍五入到三位小数。\n- 最终输出必须为单行，包含一个 Python 风格的列表。列表中包含按测试套件顺序排列的氧空位形成能，最后是所选的 $U$ 值。所有数值均需四舍五入到三位小数，例如 $[x_1,x_2,\\dots,x_n,u_{\\star}]$，其中每个 $x_i$ 是 $E_{\\mathrm{v}}(U_i)$（单位为电子伏特），$u_{\\star}$ 是所选的 $U$ 值（单位为电子伏特）。\n\n测试套件和覆盖范围：\n- 包括标准情况 $U = 4.0$，以测试与实验区间上界附近的一致性。\n- 包括边界情况 $U = 0.0$，以测试无相关性基线。\n- 包括较大的 $U$ 值 $U = 6.0$ 和 $U = 8.0$，以探究强在位相互作用，并确保能处理单调趋势。\n- 包括一个非整数 $U = 3.5$，以测试非整数值。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,...,resultN]”）。所有结果必须以电子伏特为单位，并按规定四舍五入到三位小数。",
            "solution": "问题陈述已经过验证，被认为是具有科学依据、适定且客观的。它为获得唯一解提供了完整且一致的定义、数据和确定性规则。其背景是计算材料科学中校准 DFT+$U$ 计算参数的标准流程，具体是针对二氧化铈($\\mathrm{CeO_2}$)中铈 $4f$ 电子的在位 Hubbard 参数 $U$。所给出的物理常数和实验参考值是合理的。因此，我将继续进行完整解答。\n\n主要目标是计算作为 Hubbard 参数 $U$ 函数的氧空位形成能 $E_{\\mathrm{v}}(U)$，然后基于与实验数据的比较，选择一个物理上合理的 $U$ 值。\n\n氧空位形成能由以下热力学恒等式定义：\n$$\nE_{\\mathrm{v}}(U) = E_{\\mathrm{tot}}^{\\mathrm{defect}}(U) + \\tfrac{1}{2} E_{\\mathrm{tot}}^{\\mathrm{O_2}} - E_{\\mathrm{tot}}^{\\mathrm{pristine}}(U)\n$$\n问题为原始超胞和缺陷超胞的总能量提供了线性近似模型，并为氧分子能量提供了一个常数值：\n$$\nE_{\\mathrm{tot}}^{\\mathrm{pristine}}(U) = A_{\\mathrm{p}} + B_{\\mathrm{p}}\\,U\n$$\n$$\nE_{\\mathrm{tot}}^{\\mathrm{defect}}(U) = A_{\\mathrm{d}} + B_{\\mathrm{d}}\\,U\n$$\n$$\nE_{\\mathrm{tot}}^{\\mathrm{O_2}} = A_{\\mathrm{O_2}}\n$$\n将这些模型代入 $E_{\\mathrm{v}}(U)$ 的定义中：\n$$\nE_{\\mathrm{v}}(U) = (A_{\\mathrm{d}} + B_{\\mathrm{d}}\\,U) + \\tfrac{1}{2} A_{\\mathrm{O_2}} - (A_{\\mathrm{p}} + B_{\\mathrm{p}}\\,U)\n$$\n通过对常数项和与 $U$ 相关的项进行分组，该表达式可以重排为一个关于 $U$ 的线性函数：\n$$\nE_{\\mathrm{v}}(U) = (A_{\\mathrm{d}} + \\tfrac{1}{2} A_{\\mathrm{O_2}} - A_{\\mathrm{p}}) + (B_{\\mathrm{d}} - B_{\\mathrm{p}})U\n$$\n我们定义两个常数，截距 $C$ 和斜率 $D$，使得 $E_{\\mathrm{v}}(U) = C + DU$。使用题目中给定的值（单位为电子伏特）：$A_{\\mathrm{p}} = -1760.0$，$B_{\\mathrm{p}} = -0.05$，$A_{\\mathrm{d}} = -1751.27$，$B_{\\mathrm{d}} = -0.20$，以及 $A_{\\mathrm{O_2}} = -9.86$。\n\n截距 $C$ 为：\n$$\nC = A_{\\mathrm{d}} + \\tfrac{1}{2} A_{\\mathrm{O_2}} - A_{\\mathrm{p}} = -1751.27 + \\tfrac{1}{2}(-9.86) - (-1760.0) = -1751.27 - 4.93 + 1760.0 = 3.80\n$$\n斜率 $D$ 为：\n$$\nD = B_{\\mathrm{d}} - B_{\\mathrm{p}} = -0.20 - (-0.05) = -0.15\n$$\n因此，氧空位形成能的具体线性模型为：\n$$\nE_{\\mathrm{v}}(U) = 3.80 - 0.15U\n$$\n现在我们为测试套件 $U \\in \\{0.0, 2.0, 3.5, 4.0, 6.0, 8.0\\}$ 中的每个值计算 $E_{\\mathrm{v}}(U)$，所有能量单位均为电子伏特。\n\n对于 $U=0.0$：$E_{\\mathrm{v}}(0.0) = 3.80 - 0.15 \\times 0.0 = 3.800$\n对于 $U=2.0$：$E_{\\mathrm{v}}(2.0) = 3.80 - 0.15 \\times 2.0 = 3.80 - 0.30 = 3.500$\n对于 $U=3.5$：$E_{\\mathrm{v}}(3.5) = 3.80 - 0.15 \\times 3.5 = 3.80 - 0.525 = 3.275$\n对于 $U=4.0$：$E_{\\mathrm{v}}(4.0) = 3.80 - 0.15 \\times 4.0 = 3.80 - 0.60 = 3.200$\n对于 $U=6.0$：$E_{\\mathrm{v}}(6.0) = 3.80 - 0.15 \\times 6.0 = 3.80 - 0.90 = 2.900$\n对于 $U=8.0$：$E_{\\mathrm{v}}(8.0) = 3.80 - 0.15 \\times 8.0 = 3.80 - 1.20 = 2.600$\n\n下一步是通过将这些计算出的能量与实验区间 $[E_{\\min}, E_{\\max}] = [3.0, 3.3]$ 进行比较，来选择“物理上合理”的 $U$。选择过程遵循一个分为两部分的规则。\n\n规则 1：如果一个或多个 $U$ 值产生的 $E_{\\mathrm{v}}(U)$ 位于 $[3.0, 3.3]$ 区间内，则选择其中最小的 $U$。\n我们来检查哪些计算出的能量落入此区间：\n- $E_{\\mathrm{v}}(0.0) = 3.800$ (区间外)\n- $E_{\\mathrm{v}}(2.0) = 3.500$ (区间外)\n- $E_{\\mathrm{v}}(3.5) = 3.275$ (区间内, 因为 $3.0 \\le 3.275 \\le 3.3$)\n- $E_{\\mathrm{v}}(4.0) = 3.200$ (区间内, 因为 $3.0 \\le 3.200 \\le 3.3$)\n- $E_{\\mathrm{v}}(6.0) = 2.900$ (区间外)\n- $E_{\\mathrm{v}}(8.0) = 2.600$ (区间外)\n\n$U$ 的两个值，即 $U=3.5$ 和 $U=4.0$，产生的氧空位形成能在目标实验范围内。根据规则，我们必须选择其中较小的一个。因此，所选值为 $u_{\\star} = 3.5$。\n\n由于在规则 1 下找到了候选值，因此不启用规则 2。\n\n用于输出的最终列表由按顺序排列的计算出的 $E_{\\mathrm{v}}(U)$ 值和其后所选的 $u_{\\star}$ 组成，所有数值都四舍五入到三位小数。\n计算出的能量为：$3.800, 3.500, 3.275, 3.200, 2.900, 2.600$。\n所选的 Hubbard 参数为 $3.5$。\n最终输出将是列表：$[3.800, 3.500, 3.275, 3.200, 2.900, 2.600, 3.500]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes oxygen vacancy formation energies E_v(U) for a set of Hubbard U parameters,\n    and selects a physically justified U based on comparison with an experimental range.\n    \"\"\"\n    # Define the constants from the problem statement (all in electronvolts).\n    A_p = -1760.0\n    B_p = -0.05\n    A_d = -1751.27\n    B_d = -0.20\n    A_O2 = -9.86\n\n    # Define the experimental interval for E_v and the test suite for U.\n    E_min = 3.0\n    E_max = 3.3\n    U_values = [0.0, 2.0, 3.5, 4.0, 6.0, 8.0]\n\n    # --- Step 1: Calculate E_v(U) for each U in the test suite ---\n    E_v_results = []\n    for u in U_values:\n        # The vacancy formation energy E_v(U) is derived from:\n        # E_v(U) = E_tot_defect(U) + 0.5 * E_tot_O2 - E_tot_pristine(U)\n        # Substituting the linear models:\n        # E_v(U) = (A_d + B_d*U) + 0.5 * A_O2 - (A_p + B_p*U)\n        # E_v(U) = (A_d + 0.5*A_O2 - A_p) + (B_d - B_p)*U\n        e_v = (A_d + 0.5 * A_O2 - A_p) + (B_d - B_p) * u\n        E_v_results.append(e_v)\n\n    # --- Step 2: Select the physically justified U based on the specified rules ---\n    selected_U = 0.0\n\n    # Rule 1: Check for U values yielding E_v within the experimental interval.\n    valid_U_candidates = []\n    for i, u in enumerate(U_values):\n        if E_min = E_v_results[i] = E_max:\n            valid_U_candidates.append(u)\n\n    if valid_U_candidates:\n        # If one or more U values are valid, select the smallest one.\n        selected_U = min(valid_U_candidates)\n    else:\n        # Rule 2: If no U is valid, find the U that minimizes the absolute deviation\n        # from the interval's midpoint.\n        midpoint = (E_min + E_max) / 2.0\n        \n        # Calculate deviations for all U values.\n        deviations = [abs(e_v - midpoint) for e_v in E_v_results]\n        min_deviation = min(deviations)\n        \n        # Find all U values that achieve this minimum deviation.\n        # This handles potential ties in deviation values.\n        best_U_candidates = []\n        for i, u in enumerate(U_values):\n            if np.isclose(deviations[i], min_deviation):\n                best_U_candidates.append(u)\n        \n        # Break ties by choosing the smallest U among the best candidates.\n        selected_U = min(best_U_candidates)\n\n    # --- Step 3: Format the final output ---\n    # Create the list of E_v results, rounded to three decimals.\n    formatted_E_v = [f\"{val:.3f}\" for val in E_v_results]\n    \n    # Format the selected U, rounded to three decimals.\n    formatted_selected_U = f\"{selected_U:.3f}\"\n    \n    # Combine into the final string format \"[val1,val2,...,valN,selected_u]\".\n    final_output_string = f\"[{','.join(formatted_E_v)},{formatted_selected_U}]\"\n\n    # Print the final result to standard output.\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "在确定了一个合适的Hubbard $U$ 值之后，一个进阶的研究者可能会问：我的结论对这个特定选择的敏感度有多高？在计算催化领域，这个问题至关重要，因为吸附能的微小误差可能会改变对反应机理的预测。本练习 () 向您介绍了局部敏感性分析，您将计算吸附能相对于 $U$ 的导数 $\\partial E_{\\text{ads}}/\\partial U$。这项强大的技术使您能够量化结果的稳健性，并识别出哪些化学体系最需要高度精确地确定 $U$ 值。",
            "id": "3901943",
            "problem": "要求您使用密度泛函理论加哈伯德$U$ (DFT+$U$)的一种简化但被广泛接受的形式，实现吸附能对哈伯德参数的局部敏感性分析。目标是计算几种吸附物在基准$U_0$下的局部敏感度$\\partial E_{\\mathrm{ads}}/\\partial U$，并通过将敏感度的大小与一个阈值进行比较，来优先确定哪些相互作用需要精确的$U$值。\n\n基本原理：\n- 在DFT+$U$的Dudarev简化形式中，由在位库仑相互作用引起的总能量校正由下式给出\n$$\nE_U(U) = \\frac{U}{2}\\sum_{k} n_k(U)\\bigl(1 - n_k(U)\\bigr),\n$$\n其中$U$是有效在位相互作用（单位为电子伏特），$n_k(U)$是局域子空间轨道（例如，金属$d$态）的占据数（无量纲）。这是一个经过充分检验的能量校正，它在许多实际计算中捕捉了强关联的主要效应。\n- 吸附能定义为\n$$\nE_{\\mathrm{ads}}(U) = E_{\\mathrm{sub+ads}}(U) - E_{\\mathrm{sub}}(U) - E_{\\mathrm{ads}}^{\\mathrm{gas}},\n$$\n在此模型中，$E_{\\mathrm{ads}}^{\\mathrm{gas}}$不依赖于$U$。假设只有DFT+$U$校正依赖于$U$，则敏感度$\\partial E_{\\mathrm{ads}}/\\partial U$简化为吸附（SA）态和洁净基底（S）态之间DFT+$U$校正敏感度的差值。\n\n在基准$U_0$附近，基于局域响应（这是线性响应和计算催化中的一个常见近似），假定占据数随$U$线性变化：\n$$\nn_k^{\\mathrm{SA}}(U) \\approx n_k^{\\mathrm{SA}}(U_0) + s_k^{\\mathrm{SA}}(U-U_0), \\quad\nn_k^{\\mathrm{S}}(U) \\approx n_k^{\\mathrm{S}}(U_0) + s_k^{\\mathrm{S}}(U-U_0),\n$$\n其中$s_k^{\\mathrm{SA}}=\\left.\\frac{\\partial n_k^{\\mathrm{SA}}}{\\partial U}\\right|_{U_0}$和$s_k^{\\mathrm{S}}=\\left.\\frac{\\partial n_k^{\\mathrm{S}}}{\\partial U}\\right|_{U_0}$是无量纲的局域斜率。\n\n您的任务：\n- 对于每个测试用例，应用链式法则于上述定义，计算局部敏感度\n$$\n\\left.\\frac{\\partial E_{\\mathrm{ads}}}{\\partial U}\\right|_{U_0}\n$$\n此外，使用一个小的增量$\\Delta U$，通过中心有限差分近似来验证结果：\n$$\n\\left.\\frac{\\partial E_{\\mathrm{ads}}}{\\partial U}\\right|_{U_0} \\approx \\frac{E_{\\mathrm{ads}}(U_0+\\Delta U)-E_{\\mathrm{ads}}(U_0-\\Delta U)}{2\\,\\Delta U}.\n$$\n- 使用单位为$\\mathrm{eV}$的$U$、单位为$\\mathrm{eV}$的$E_U$和$E_{\\mathrm{ads}}$，并以无单位数的形式报告$\\partial E_{\\mathrm{ads}}/\\partial U$。将所有报告的浮点数结果四舍五入到六位小数。\n- 优先排序规则：如果$\\left|\\partial E_{\\mathrm{ads}}/\\partial U\\right|\\ge \\tau$，其中阈值$\\tau=0.05$（无单位），则该相互作用需要精确的$U$值；否则不需要。\n\n测试套件：\n对于每个案例，给定$U_0$、列表$\\{n_k^{\\mathrm{SA}}(U_0)\\}$、$\\{s_k^{\\mathrm{SA}}\\}$、$\\{n_k^{\\mathrm{S}}(U_0)\\}$、$\\{s_k^{\\mathrm{S}}\\}$以及一个公共的$\\Delta U = 0.01\\,\\mathrm{eV}$。\n- 案例1（一般情况）：$U_0=4.0\\,\\mathrm{eV}$；$n_k^{\\mathrm{SA}}(U_0)=[0.6,\\,0.4,\\,0.2]$，$s_k^{\\mathrm{SA}}=[-0.02,\\,0.01,\\,0.0]$；$n_k^{\\mathrm{S}}(U_0)=[0.5,\\,0.3,\\,0.25]$，$s_k^{\\mathrm{S}}=[-0.01,\\,0.005,\\,0.0]$。\n- 案例2（边界-高占据数）：$U_0=5.0\\,\\mathrm{eV}$；$n_k^{\\mathrm{SA}}(U_0)=[0.99]$，$s_k^{\\mathrm{SA}}=[-0.001]$；$n_k^{\\mathrm{S}}(U_0)=[0.95]$，$s_k^{\\mathrm{S}}=[-0.002]$。\n- 案例3（零斜率，仅占据数差异）：$U_0=3.0\\,\\mathrm{eV}$；$n_k^{\\mathrm{SA}}(U_0)=[0.7,\\,0.3]$，$s_k^{\\mathrm{SA}}=[0.0,\\,0.0]$；$n_k^{\\mathrm{S}}(U_0)=[0.5,\\,0.5]$，$s_k^{\\mathrm{S}}=[0.0,\\,0.0]$。\n- 案例4（强响应）：$U_0=4.5\\,\\mathrm{eV}$；$n_k^{\\mathrm{SA}}(U_0)=[0.2,\\,0.8,\\,0.5]$，$s_k^{\\mathrm{SA}}=[0.03,\\,-0.03,\\,0.02]$；$n_k^{\\mathrm{S}}(U_0)=[0.1,\\,0.9,\\,0.45]$，$s_k^{\\mathrm{S}}=[0.005,\\,-0.01,\\,0.0]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，格式完全如下\n$$\n\\big[ [d_1,d_2,\\dots],[\\tilde d_1,\\tilde d_2,\\dots],[b_1,b_2,\\dots] \\big],\n$$\n其中$d_i$是解析敏感度（无单位），$\\tilde d_i$是中心有限差分敏感度（无单位），$b_i$是布尔值，表示$\\left|d_i\\right|\\ge \\tau$是否成立。所有浮点值必须四舍五入到六位小数。输出中不允许有空格。",
            "solution": "任务是使用解析和数值两种方法，计算吸附能相对于哈伯德$U$参数的敏感度$\\partial E_{\\mathrm{ads}}/\\partial U$。\n\n吸附能$E_{\\mathrm{ads}}(U)$定义为：\n$$\nE_{\\mathrm{ads}}(U) = E_{\\mathrm{sub+ads}}(U) - E_{\\mathrm{sub}}(U) - E_{\\mathrm{ads}}^{\\mathrm{gas}}\n$$\n鉴于只有哈伯德能量校正$E_U(U)$依赖于参数$U$，吸附能的敏感度简化为吸附物-基底（SA）系统和洁净基底（S）系统的哈伯德校正敏感度之差：\n$$\n\\frac{\\partial E_{\\mathrm{ads}}}{\\partial U} = \\frac{\\partial E_U^{\\mathrm{SA}}}{\\partial U} - \\frac{\\partial E_U^{\\mathrm{S}}}{\\partial U}\n$$\n我们必须首先推导导数$\\partial E_U / \\partial U$的一般表达式。哈伯德能量校正由下式给出：\n$$\nE_U(U) = \\frac{U}{2}\\sum_{k} n_k(U)\\bigl(1 - n_k(U)\\bigr)\n$$\n为了求出关于$U$的导数，我们应用乘积法则和链式法则：\n$$\n\\frac{\\partial E_U}{\\partial U} = \\frac{\\partial}{\\partial U}\\left( \\frac{U}{2} \\right) \\left( \\sum_k [n_k(U) - n_k(U)^2] \\right) + \\frac{U}{2} \\frac{\\partial}{\\partial U}\\left( \\sum_k [n_k(U) - n_k(U)^2] \\right)\n$$\n$$\n\\frac{\\partial E_U}{\\partial U} = \\frac{1}{2} \\sum_k n_k(U)(1 - n_k(U)) + \\frac{U}{2} \\sum_k \\left( \\frac{\\partial n_k}{\\partial U} - 2n_k(U)\\frac{\\partial n_k}{\\partial U} \\right)\n$$\n$$\n\\frac{\\partial E_U}{\\partial U} = \\frac{1}{2} \\sum_k n_k(U)(1 - n_k(U)) + \\frac{U}{2} \\sum_k (1 - 2n_k(U)) \\frac{\\partial n_k}{\\partial U}\n$$\n为了求出在$U=U_0$处的局部敏感度，我们代入$U=U_0$，$n_k(U)=n_k(U_0)$和$\\frac{\\partial n_k}{\\partial U} = s_k$：\n$$\n\\left.\\frac{\\partial E_U}{\\partial U}\\right|_{U_0} = \\frac{1}{2} \\sum_k n_k(U_0)(1 - n_k(U_0)) + \\frac{U_0}{2} \\sum_k (1 - 2n_k(U_0))s_k\n$$\n此表达式使我们能够计算SA和S两个系统的解析敏感度，它们的差值即为所需的吸附能解析敏感度$d_i$：\n$$\nd_i = \\left.\\frac{\\partial E_{\\mathrm{ads}}}{\\partial U}\\right|_{U_0} = \\left( \\left.\\frac{\\partial E_U^{\\mathrm{SA}}}{\\partial U}\\right|_{U_0} \\right) - \\left( \\left.\\frac{\\partial E_U^{\\mathrm{S}}}{\\partial U}\\right|_{U_0} \\right)\n$$\n\n对于数值验证，我们使用中心有限差分公式，步长为一个很小的$\\Delta U$：\n$$\n\\tilde{d_i} = \\left.\\frac{\\partial E_{\\mathrm{ads}}}{\\partial U}\\right|_{U_0} \\approx \\frac{E_{\\mathrm{ads}}(U_0+\\Delta U) - E_{\\mathrm{ads}}(U_0-\\Delta U)}{2\\Delta U}\n$$\n要使用此公式，我们必须首先计算在$U_+ = U_0+\\Delta U$和$U_- = U_0-\\Delta U$处的吸附能。吸附能的差值为$E_{\\mathrm{ads}}(U) = E_U^{\\mathrm{SA}}(U) - E_U^{\\mathrm{S}}(U)$。\n在$U_+$和$U_-$处的轨道占据数值由给定的线性近似确定：\n对于SA系统：\n$$\nn_k^{\\mathrm{SA}}(U_+) = n_k^{\\mathrm{SA}}(U_0) + s_k^{\\mathrm{SA}}\\Delta U\n$$\n$$\nn_k^{\\mathrm{SA}}(U_-) = n_k^{\\mathrm{SA}}(U_0) - s_k^{\\mathrm{SA}}\\Delta U\n$$\n对于S系统：\n$$\nn_k^{\\mathrm{S}}(U_+) = n_k^{\\mathrm{S}}(U_0) + s_k^{\\mathrm{S}}\\Delta U\n$$\n$$\nn_k^{\\mathrm{S}}(U_-) = n_k^{\\mathrm{S}}(U_0) - s_k^{\\mathrm{S}}\\Delta U\n$$\n利用这些估算的占据数，我们计算每个系统在$U_+$和$U_-$处的哈伯德能量$E_U(U)$：\n$$\nE_U^{\\mathrm{sys}}(U) = \\frac{U}{2}\\sum_{k} n_k^{\\mathrm{sys}}(U)(1 - n_k^{\\mathrm{sys}}(U))\n$$\n最后，我们计算$E_{\\mathrm{ads}}(U_+) = E_U^{\\mathrm{SA}}(U_+) - E_U^{\\mathrm{S}}(U_+)$和$E_{\\mathrm{ads}}(U_-) = E_U^{\\mathrm{SA}}(U_-) - E_U^{\\mathrm{S}}(U_-)$，并将它们代入有限差分公式以获得数值敏感度$\\tilde{d_i}$。\n\n优先排序标准是一个布尔检查：如果$|d_i| \\ge \\tau$，其中$\\tau = 0.05$，则该相互作用需要精确的$U$值。每个案例$i$的结果是一个布尔值$b_i$。\n\n实现过程将通过应用这些公式来处理每个测试用例，将最终的浮点敏感度四舍五入到六位小数，并生成布尔标志。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating Hubbard U sensitivity for adsorption energy.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"U0\": 4.0,\n            \"n_sa\": [0.6, 0.4, 0.2],\n            \"s_sa\": [-0.02, 0.01, 0.0],\n            \"n_s\": [0.5, 0.3, 0.25],\n            \"s_s\": [-0.01, 0.005, 0.0],\n        },\n        {\n            \"U0\": 5.0,\n            \"n_sa\": [0.99],\n            \"s_sa\": [-0.001],\n            \"n_s\": [0.95],\n            \"s_s\": [-0.002],\n        },\n        {\n            \"U0\": 3.0,\n            \"n_sa\": [0.7, 0.3],\n            \"s_sa\": [0.0, 0.0],\n            \"n_s\": [0.5, 0.5],\n            \"s_s\": [0.0, 0.0],\n        },\n        {\n            \"U0\": 4.5,\n            \"n_sa\": [0.2, 0.8, 0.5],\n            \"s_sa\": [0.03, -0.03, 0.02],\n            \"n_s\": [0.1, 0.9, 0.45],\n            \"s_s\": [0.005, -0.01, 0.0],\n        },\n    ]\n\n    dU = 0.01\n    tau = 0.05\n\n    analytic_results = []\n    fd_results = []\n    prio_results = []\n\n    def get_analytic_deriv(U0, n_U0, s):\n        \"\"\"Calculates the analytical derivative dE_U/dU for a single system.\"\"\"\n        term1 = 0.5 * np.sum(n_U0 * (1 - n_U0))\n        term2 = (U0 / 2.0) * np.sum((1 - 2 * n_U0) * s)\n        return term1 + term2\n\n    def calculate_EU(U, U0, n_U0, s):\n        \"\"\"Calculates the Hubbard energy E_U for a single system at a given U.\"\"\"\n        n_at_U = n_U0 + s * (U - U0)\n        E_U = (U / 2.0) * np.sum(n_at_U * (1 - n_at_U))\n        return E_U\n\n    for case in test_cases:\n        U0 = case[\"U0\"]\n        n_sa_U0 = np.array(case[\"n_sa\"])\n        s_sa = np.array(case[\"s_sa\"])\n        n_s_U0 = np.array(case[\"n_s\"])\n        s_s = np.array(case[\"s_s\"])\n\n        # 1. Analytical sensitivity\n        d_sa_analytic = get_analytic_deriv(U0, n_sa_U0, s_sa)\n        d_s_analytic = get_analytic_deriv(U0, n_s_U0, s_s)\n        d_analytic = d_sa_analytic - d_s_analytic\n        analytic_results.append(d_analytic)\n\n        # 2. Finite difference sensitivity\n        U_plus = U0 + dU\n        U_minus = U0 - dU\n\n        E_U_sa_plus = calculate_EU(U_plus, U0, n_sa_U0, s_sa)\n        E_U_sa_minus = calculate_EU(U_minus, U0, n_sa_U0, s_sa)\n\n        E_U_s_plus = calculate_EU(U_plus, U0, n_s_U0, s_s)\n        E_U_s_minus = calculate_EU(U_minus, U0, n_s_U0, s_s)\n\n        E_ads_plus = E_U_sa_plus - E_U_s_plus\n        E_ads_minus = E_U_sa_minus - E_U_s_minus\n        \n        d_fd = (E_ads_plus - E_ads_minus) / (2 * dU)\n        fd_results.append(d_fd)\n\n        # 3. Prioritization\n        prio_results.append(abs(d_analytic) >= tau)\n\n    # Format the results for the final output string\n    # All floats must be rounded to six decimal places\n    d_str = \",\".join([f\"{x:.6f}\" for x in analytic_results])\n    fd_str = \",\".join([f\"{x:.6f}\" for x in fd_results])\n    # The default str() for booleans is 'True'/'False', which is acceptable\n    prio_str = \",\".join(map(str, prio_results))\n\n    # Final print statement in the exact required format.\n    print(f\"[[{d_str}],[{fd_str}],[{prio_str}]]\")\n\nsolve()\n```"
        }
    ]
}