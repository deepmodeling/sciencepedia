{
    "hands_on_practices": [
        {
            "introduction": "任何分子动力学模拟，包括从头算分子动力学（AIMD），都依赖于统计力学原理来描述系统的温度。这个练习将指导你推导和计算一个基本量——每个原子的平均动能，从而将宏观温度与原子的微观运动直接联系起来。理解这种联系是正确设置和解读AIMD模拟的第一步。",
            "id": "4236153",
            "problem": "给定一个涉及从头算分子动力学（Ab Initio Molecular Dynamics, AIMD）的计算电化学中的科学真实情景。在 Born–Oppenheimer 从头算分子动力学（AIMD）中，假定电子在当前的原子核位置下保持在瞬时基态，而原子核根据经典牛顿动力学演化，其作用力由电子基态能量面计算得出。考虑一个靠近铂 $(111)$ 晶面的小型氯化钠水溶液体系。任务是使用第一性原理来确定在指定温度下，正则系综轨迹中每个原子的平均动能，并论述该轨迹应如何设置。\n\n仅从基本定律和定义出发，推导在温度 $T$ 下，无完整约束的情况下，原子核在 Born-Oppenheimer 近似下演化时，经典正则系综中每个原子的平均动能。该推导必须从动能和正则系综的定义开始，并应关联到平衡态下经典原子核的速度分布方式。然后，实现一个程序，根据一组给定的温度计算每个原子的平均动能，假设系统为三维，每个原子具有三个平移自由度且无约束。\n\n作为背景参考，在 $T=300\\ \\mathrm{K}$ 下，一个典型的 $10\\ \\mathrm{ps}$ Born–Oppenheimer 轨迹会使用 $0.5$ 到 $1.0\\ \\mathrm{fs}$ 量级的时间步长，产生 $10000$ 到 $20000$ 个步数，每一步的力都通过在固定原子核位置下进行的电子结构计算获得，并使用恒温器来维持正则系综。然而，在本问题中，你的程序只需计算作为温度函数的每个原子的平均动能，该结果需与经典原子核的正则系综一致。\n\n物理单位要求：以电子伏特表示每个原子的平均动能。程序必须以 $\\mathrm{eV}$ 为单位输出数值，并四舍五入到六位小数。\n\n角度单位要求：不适用，因为不涉及角度。\n\n百分比要求：不适用。\n\n测试套件：\n- 案例1（正常路径）：$T=300\\ \\mathrm{K}$\n- 案例2（绝对零度下的边界条件）：$T=0\\ \\mathrm{K}$\n- 案例3（高温边界情况）：$T=1000\\ \\mathrm{K}$\n- 案例4（接近环境温度，精度更高）：$T=298.15\\ \\mathrm{K}$\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如：$[result1,result2,result3,result4]$），其中每个 $result$ 是以 $\\mathrm{eV}$ 为单位的每个原子的平均动能，四舍五入到六位小数，并分别对应上述四个测试温度。",
            "solution": "问题要求对温度 $T$ 下正则系综中的经典原子核体系，进行每个原子平均动能的第一性原理推导，然后对特定温度进行程序化计算。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n- **理论框架**：Born-Oppenheimer 从头算分子动力学（AIMD）。\n- **物理模型**：原子核根据经典牛顿动力学演化。电子在固定的原子核位置下处于基态。\n- **系综**：正则系综（NVT）。\n- **系统属性**：每个原子具有三个平移自由度。无完整约束。\n- **任务1（推导）**：从动能和正则系综的定义出发，推导每个原子的平均动能。\n- **任务2（计算）**：实现一个程序，根据一组给定的温度计算每个原子的平均动能。\n- **单位**：最终结果必须以电子伏特（$\\mathrm{eV}$）为单位。\n- **四舍五入**：数值输出必须四舍五入到六位小数。\n- **测试案例**：\n    - 案例1：$T = 300\\ \\mathrm{K}$\n    - 案例2：$T = 0\\ \\mathrm{K}$\n    - 案例3：$T = 1000\\ \\mathrm{K}$\n    - 案例4：$T = 298.15\\ \\mathrm{K}$\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据、是良定的且客观的。\n1.  **科学合理性**：该问题建立在经典统计力学（正则系综，能量均分定理）的基本原理及其在计算化学（Born-Oppenheimer 近似）中的应用之上。这些是解决此类问题的标准且正确的假设。\n2.  **良定性**：目标定义明确：推导一个已知的物理量，然后在指定条件下计算其值。这些假设（经典原子核、3个自由度、无约束）足以产生一个唯一、稳定且有意义的解。\n3.  **客观性**：问题以精确、定量的术语陈述，没有歧义或主观内容。AIMD 的背景被用来构建一个关于基本统计力学的问题，这是一种有效的教学方法。\n\n**步骤3：结论与行动**\n该问题被视为**有效**。将提供解决方案。\n\n### 推导与求解\n\n推导从经典统计力学的基本定义出发，针对一个在温度 $T$ 下，由 $N$ 个原子组成的正则系综系统。\n\n1.  **哈密顿量与动能**：在 Born-Oppenheimer 近似中，原子核的势能 $U(\\mathbf{r}_1, ..., \\mathbf{r}_N)$ 仅依赖于其位置 $\\mathbf{r}_i$。原子核子系统的总经典哈密顿量 $H$ 是动能 $K$ 和势能 $U$ 的和：\n    $$H(\\mathbf{r}^N, \\mathbf{p}^N) = K(\\mathbf{p}^N) + U(\\mathbf{r}^N)$$\n    其中 $\\mathbf{r}^N = (\\mathbf{r}_1, ..., \\mathbf{r}_N)$ 和 $\\mathbf{p}^N = (\\mathbf{p}_1, ..., \\mathbf{p}_N)$ 代表所有位置和动量矢量的集合。总动能 $K$ 是 $N$ 个原子各自的动能之和：\n    $$K = \\sum_{i=1}^{N} \\frac{\\mathbf{p}_i^2}{2m_i} = \\sum_{i=1}^{N} \\left( \\frac{p_{ix}^2}{2m_i} + \\frac{p_{iy}^2}{2m_i} + \\frac{p_{iz}^2}{2m_i} \\right)$$\n    此处，$m_i$ 是第 $i$ 个原子的质量，$\\mathbf{p}_i = (p_{ix}, p_{iy}, p_{iz})$ 是其动量矢量。\n\n2.  **正则系综与期望值**：在正则系综中，系统处于坐标为 $(\\mathbf{r}^N, \\mathbf{p}^N)$ 的微观状态的概率密度由下式给出：\n    $$\\rho(\\mathbf{r}^N, \\mathbf{p}^N) = \\frac{e^{-\\beta H(\\mathbf{r}^N, \\mathbf{p}^N)}}{Z}$$\n    其中 $\\beta = 1/(k_B T)$，$k_B$ 是玻尔兹曼常数，$Z$ 是配分函数，它对概率分布进行归一化：\n    $$Z = \\int d\\mathbf{r}^N d\\mathbf{p}^N \\, e^{-\\beta H(\\mathbf{r}^N, \\mathbf{p}^N)}$$\n    任何可观测物理量 $A$ 的平均值或期望值由下式给出：\n    $$\\langle A \\rangle = \\int d\\mathbf{r}^N d\\mathbf{p}^N \\, A(\\mathbf{r}^N, \\mathbf{p}^N) \\rho(\\mathbf{r}^N, \\mathbf{p}^N)$$\n\n3.  **平均动能**：我们要求的是平均总动能 $\\langle K \\rangle$。\n    $$\\langle K \\rangle = \\frac{1}{Z} \\int d\\mathbf{r}^N d\\mathbf{p}^N \\, K(\\mathbf{p}^N) e^{-\\beta (K(\\mathbf{p}^N) + U(\\mathbf{r}^N))}$$\n    由于哈密顿量可以分离成一个依赖动量的部分 $K(\\mathbf{p}^N)$ 和一个依赖位置的部分 $U(\\mathbf{r}^N)$，配分函数 $Z$ 可以被因式分解：\n    $$Z = \\left( \\int d\\mathbf{p}^N \\, e^{-\\beta K(\\mathbf{p}^N)} \\right) \\left( \\int d\\mathbf{r}^N \\, e^{-\\beta U(\\mathbf{r}^N)} \\right) = Z_p Z_r$$\n    类似地，$\\langle K \\rangle$ 的积分也分离为：\n    $$\\langle K \\rangle = \\frac{1}{Z_p Z_r} \\left( \\int d\\mathbf{p}^N \\, K(\\mathbf{p}^N) e^{-\\beta K(\\mathbf{p}^N)} \\right) \\left( \\int d\\mathbf{r}^N \\, e^{-\\beta U(\\mathbf{r}^N)} \\right)$$\n    位置积分 $\\int d\\mathbf{r}^N \\, e^{-\\beta U(\\mathbf{r}^N)}$ 等于 $Z_r$，它被消去，剩下：\n    $$\\langle K \\rangle = \\frac{\\int d\\mathbf{p}^N \\, K(\\mathbf{p}^N) e^{-\\beta K(\\mathbf{p}^N)}}{\\int d\\mathbf{p}^N \\, e^{-\\beta K(\\mathbf{p}^N)}}$$\n    这表明平均动能与势能函数 $U(\\mathbf{r}^N)$ 无关。\n\n4.  **能量均分定理**：总动能是 $3N$ 个独立二次项的和（对应于 $N$ 个原子中每一个的动量分量 $p_{ix}, p_{iy}, p_{iz}$）。我们可以评估单个此类项的平均能量贡献，例如 $\\frac{p_{ix}^2}{2m_i}$。\n    $$\\left\\langle \\frac{p_{ix}^2}{2m_i} \\right\\rangle = \\frac{\\int_{-\\infty}^{\\infty} dp_{ix} \\, \\frac{p_{ix}^2}{2m_i} e^{-\\beta \\frac{p_{ix}^2}{2m_i}}}{\\int_{-\\infty}^{\\infty} dp_{ix} \\, e^{-\\beta \\frac{p_{ix}^2}{2m_i}}}$$\n    所有对其他动量分量的积分在分子和分母之间相互抵消。我们使用标准高斯积分：\n    $$\\int_{-\\infty}^{\\infty} e^{-ax^2} dx = \\sqrt{\\frac{\\pi}{a}}$$\n    $$\\int_{-\\infty}^{\\infty} x^2 e^{-ax^2} dx = -\\frac{d}{da} \\int_{-\\infty}^{\\infty} e^{-ax^2} dx = -\\frac{d}{da} \\sqrt{\\frac{\\pi}{a}} = \\frac{1}{2a}\\sqrt{\\frac{\\pi}{a}}$$\n    令 $x = p_{ix}$ 且 $a = \\frac{\\beta}{2m_i}$：\n    - 分母： $\\int_{-\\infty}^{\\infty} e^{-\\frac{\\beta}{2m_i} p_{ix}^2} dp_{ix} = \\sqrt{\\frac{2 \\pi m_i}{\\beta}}$\n    - 分子： $\\int_{-\\infty}^{\\infty} \\frac{p_{ix}^2}{2m_i} e^{-\\frac{\\beta}{2m_i} p_{ix}^2} dp_{ix} = \\frac{1}{2m_i} \\left( \\frac{1}{2 \\frac{\\beta}{2m_i}}\\sqrt{\\frac{2 \\pi m_i}{\\beta}} \\right) = \\frac{1}{2\\beta} \\sqrt{\\frac{2 \\pi m_i}{\\beta}}$\n    求二者之比可得：\n    $$\\left\\langle \\frac{p_{ix}^2}{2m_i} \\right\\rangle = \\frac{\\frac{1}{2\\beta} \\sqrt{\\frac{2 \\pi m_i}{\\beta}}}{\\sqrt{\\frac{2 \\pi m_i}{\\beta}}} = \\frac{1}{2\\beta} = \\frac{1}{2} k_B T$$\n    这就是能量均分定理：哈密顿量中的每个二次自由度对系统的平均能量贡献为 $\\frac{1}{2}k_B T$。\n\n5.  **每个原子的平均动能**：问题指明每个原子有三个平移自由度，且无约束。哈密顿量的动能部分包含 $3N$ 个这样的二次项。因此，包含 $N$ 个原子的系统的总平均动能为：\n    $$\\langle K_{total} \\rangle = \\sum_{i=1}^{N} \\left( \\left\\langle \\frac{p_{ix}^2}{2m_i} \\right\\rangle + \\left\\langle \\frac{p_{iy}^2}{2m_i} \\right\\rangle + \\left\\langle \\frac{p_{iz}^2}{2m_i} \\right\\rangle \\right) = 3N \\times \\left(\\frac{1}{2} k_B T\\right) = \\frac{3}{2} N k_B T$$\n    为了求得每个原子的平均动能 $\\langle E_{kin, atom} \\rangle$，我们将总平均动能除以原子数 $N$：\n    $$\\langle E_{kin, atom} \\rangle = \\frac{\\langle K_{total} \\rangle}{N} = \\frac{\\frac{3}{2} N k_B T}{N} = \\frac{3}{2} k_B T$$\n    这是最终推导出的表达式。对于任何动能是动量的二次方并且每个粒子具有三个无约束自由度的热平衡经典系统，这是一个普适的结果。\n\n6.  **数值计算**：为了实现计算，我们使用以电子伏特每开尔文（$\\mathrm{eV}/\\mathrm{K}$）为单位的玻尔兹曼常数值。\n    - $k_B \\approx 8.617333262 \\times 10^{-5}\\ \\mathrm{eV}/\\mathrm{K}$\n    - 公式为：$\\langle E_{kin, atom} \\rangle [\\mathrm{eV}] = \\frac{3}{2} \\times (8.617333262 \\times 10^{-5}\\ \\mathrm{eV}/\\mathrm{K}) \\times T[\\mathrm{K}]$\n\n现在，针对给定的测试案例实现此公式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the mean kinetic energy per atom for a classical system\n    in a canonical ensemble at various temperatures.\n    \"\"\"\n    \n    # The Boltzmann constant in electronvolts per Kelvin (eV/K).\n    # Source: CODATA 2018 value.\n    K_B_EV_PER_K = 8.617333262145e-5\n\n    # Define the test cases from the problem statement.\n    # Temperatures are in Kelvin (K).\n    test_cases = [\n        300.0,      # Case 1 (happy path)\n        0.0,        # Case 2 (boundary condition at absolute zero)\n        1000.0,     # Case 3 (high temperature edge case)\n        298.15      # Case 4 (near-ambient temperature with higher precision)\n    ]\n\n    results = []\n    for T in test_cases:\n        # According to the equipartition theorem for a classical system with\n        # 3 translational degrees of freedom per atom and no constraints,\n        # the mean kinetic energy per atom is (3/2) * k_B * T.\n        #\n        # Degrees of freedom (dof) = 3 (for x, y, z translation)\n        # Mean energy per dof = (1/2) * k_B * T\n        # Mean kinetic energy per atom = dof * (1/2) * k_B * T = (3/2) * k_B * T\n        \n        mean_kinetic_energy_per_atom = 1.5 * K_B_EV_PER_K * T\n        \n        # Round the result to six decimal places as required.\n        # We use a format string for robust formatting to ensure trailing zeros.\n        rounded_result = \"{:.6f}\".format(mean_kinetic_energy_per_atom)\n        results.append(rounded_result)\n\n    # Final print statement in the exact required format: [result1,result2,result3,result4]\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "AIMD模拟的准确性和稳定性在很大程度上取决于时间步长 $\\Delta t$ 的选择。本实践采用一个简化的模型来阐释一个至关重要的原则：时间步长必须足够小，以解析系统中最快的运动。通过观察违反此规则时能量守恒是如何失效的 ，你将为设置稳定可靠的积分时间步长获得实用的直觉。",
            "id": "2448283",
            "problem": "从头算分子动力学（AIMD）是在通过电子结构理论获得的电子势能面上，遵循经典核运动。考虑一个近似于分子最快振动模式的单一核自由度。将此模式建模为一维谐振子，其质量为 $m$，角频率为 $\\omega_{\\max}$，在势 $V(x) = \\tfrac{1}{2} k x^2$（其中 $k = m \\omega_{\\max}^2$）上运动。使用约化的无量纲单位，其中 $m = 1$，因此 $k = \\omega_{\\max}^2$。初始条件为 $x(0) = x_0$ 和 $v(0) = v_0$。设在第 $n$ 步的离散总能量为\n$$\nE_n = \\tfrac{1}{2} v_n^2 + \\tfrac{1}{2} \\omega_{\\max}^2 x_n^2,\n$$\n并将 $N$ 步轨迹上的最大相对能量漂移定义为\n$$\n\\delta_{\\max} = \\max_{0 \\le n \\le N} \\frac{\\lvert E_n - E_0 \\rvert}{E_0}.\n$$\n如果 $\\delta_{\\max} > \\eta$，则轨迹被标记为“不稳定”，否则为“稳定”，其中 $\\eta$ 是一个给定的正阈值。所有量均为无量纲，无需物理单位。\n\n任务：编写一个完整、可运行的程序，针对下方的每个测试用例，使用恒定的时间步长 $\\Delta t$ 对运动进行 $N$ 步的数值积分，计算 $\\delta_{\\max}$，并根据上述定义输出一个布尔值，指示轨迹是否不稳定。\n\n您必须使用以下测试集，其中每个用例是一个元组 $(\\omega_{\\max}, \\Delta t, N, x_0, v_0, \\eta)$：\n- 用例 1：$(\\omega_{\\max} = 1.0, \\Delta t = 0.5, N = 2000, x_0 = 1.0, v_0 = 0.0, \\eta = 0.02)$。\n- 用例 2：$(\\omega_{\\max} = 1.0, \\Delta t = 2.0, N = 1000, x_0 = 1.0, v_0 = 0.0, \\eta = 0.02)$。\n- 用例 3：$(\\omega_{\\max} = 1.0, \\Delta t = 2.1, N = 200, x_0 = 1.0, v_0 = 0.0, \\eta = 0.02)$。\n- 用例 4：$(\\omega_{\\max} = 3.0, \\Delta t = 0.8, N = 200, x_0 = 1.0, v_0 = 0.0, \\eta = 0.02)$。\n- 用例 5：$(\\omega_{\\max} = 3.0, \\Delta t = 0.2, N = 2000, x_0 = 1.0, v_0 = 0.0, \\eta = 0.02)$。\n\n最终输出格式：您的程序应生成一行输出，其中包含所有测试用例的布尔不稳定性结果，格式为按上述用例顺序排列、用逗号分隔并括在方括号中的列表，例如 $[\\text{真},\\text{假},\\text{真}]$。",
            "solution": "首先对问题陈述进行严格验证。\n\n已知条件如下：\n- **系统**：模拟单一核自由度的一维谐振子。\n- **势能**：$V(x) = \\tfrac{1}{2} k x^2$。\n- **质量和力常数**：在约化的无量纲单位中，质量 $m = 1$，力常数 $k = \\omega_{\\max}^2$。\n- **运动方程**：根据 Newton 第二定律，$m\\ddot{x} = F(x)$，其中 $F(x) = -\\frac{dV}{dx} = -kx$。当 $m=1$ 时，方程变为 $\\ddot{x} = -\\omega_{\\max}^2 x$。\n- **初始条件**：$x(0) = x_0$ 和 $v(0) = v_0$。\n- **离散总能量**：在每个时间步 $n$，能量为 $E_n = \\tfrac{1}{2} v_n^2 + \\tfrac{1}{2} \\omega_{\\max}^2 x_n^2$。\n- **最大相对能量漂移**：数值误差的一种度量，定义为 $\\delta_{\\max} = \\max_{0 \\le n \\le N} \\frac{\\lvert E_n - E_0 \\rvert}{E_0}$。\n- **不稳定性判据**：如果 $\\delta_{\\max} > \\eta$，则轨迹为“不稳定”，其中 $\\eta$ 是一个指定的正阈值。\n- **任务**：针对多个测试用例，使用时间步长 $\\Delta t$ 对系统进行 $N$ 步的数值积分，并确定所得轨迹是否不稳定。\n\n验证的结论是，该问题就其陈述而言，是病态的 (ill-posed)。它存在一个关键的遗漏：没有指定数值积分算法。积分器（例如 Euler、Runge-Kutta、Verlet）的选择对解至关重要，因为不同的算法会产生不同的轨迹 $(x_n, v_n)$，从而导致不同的能量漂移 $\\delta_{\\max}$。对于一个数值物理问题，不指定数值方法是一个严重的缺陷（违反了**病态或结构不良**标准）。\n\n然而，该问题是在*从头算分子动力学*（AIMD）的背景下提出的。在该领域，**速度 Verlet 算法**是一种标准且广泛使用的方法，因其具有时间可逆性、辛性质（相空间体积守恒）以及对于哈密顿系统的优异长期能量守恒性。此外，所提供的测试用例似乎是专门为探测速度 Verlet 算法应用于谐振子时的著名稳定性极限而设计的，该极限为 $\\omega_{\\max} \\Delta t \\le 2$。当 $\\omega_{\\max} \\Delta t$ 的值超过此极限时，该算法在数值上变得不稳定，能量会发散。这提供了强有力的上下文证据，表明速度 Verlet 算法是预期的解法。基于这个专业上合理的假设，问题就变得良态 (well-posed) 且可解。\n\n因此，我们继续采用速度 Verlet 算法。将系统从时间步 $n$推进到 $n+1$ 的更新方程是：\n1. 更新位置：$$x_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a_n (\\Delta t)^2$$\n2. 更新速度：$$v_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t$$\n其中 $\\Delta t$ 是时间步长，$a_n$ 是第 $n$ 步的加速度。对于我们的谐振子，加速度是位置的函数：$a(x) = -\\omega_{\\max}^2 x$。因此，$a_n = -\\omega_{\\max}^2 x_n$ 且 $a_{n+1} = -\\omega_{\\max}^2 x_{n+1}$。\n\n每个测试用例的计算过程如下：\n1. 用给定参数初始化系统状态：$(\\omega_{\\max}, \\Delta t, N, x_0, v_0, \\eta)$。设置 $x_n = x_0$ 和 $v_n = v_0$。\n2. 计算初始能量 $E_0 = \\tfrac{1}{2} v_0^2 + \\tfrac{1}{2} \\omega_{\\max}^2 x_0^2$。由于所有测试用例都具有非零的初始势能，$E_0$ 不为零，从而避免了在计算漂移时出现除以零的情况。将最大相对漂移 $\\delta_{\\max}$ 初始化为 $0$。\n3. 进入一个循环，执行 $N$ 次积分步骤。对于从 $n=0$ 到 $N-1$ 的每一步：\n    a. 计算当前位置的加速度：$a_n = -\\omega_{\\max}^2 x_n$。\n    b. 使用第一个 Verlet 方程更新位置以获得 $x_{n+1}$。\n    c. 计算更新后位置的新加速度：$a_{n+1} = -\\omega_{\\max}^2 x_{n+1}$。\n    d. 使用第二个 Verlet 方程更新速度以获得 $v_{n+1}$。\n    e. 计算新的总能量 $E_{n+1} = \\tfrac{1}{2} v_{n+1}^2 + \\tfrac{1}{2} \\omega_{\\max}^2 x_{n+1}^2$。\n    f. 计算此步的相对能量漂移 $\\frac{\\lvert E_{n+1} - E_0 \\rvert}{E_0}$。\n    g. 如果当前漂移大于已存储的最大值，则更新 $\\delta_{\\max}$。\n    h. 将当前状态 $(x_n, v_n)$ 设置为新状态 $(x_{n+1}, v_{n+1})$，以进行下一次迭代。\n4. 循环完成后，将最终的 $\\delta_{\\max}$ 与不稳定性阈值 $\\eta$ 进行比较。如果 $\\delta_{\\max} > \\eta$，则轨迹被归类为不稳定（`True`）；否则，为稳定（`False`）。\n\n将此过程系统地应用于每个测试用例，以生成所需的布尔结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(omega_max, dt, N, x0, v0, eta):\n    \"\"\"\n    Numerically integrates a 1D harmonic oscillator using the Velocity Verlet\n    algorithm and determines if the trajectory is unstable based on energy drift.\n\n    Args:\n        omega_max (float): Angular frequency of the oscillator.\n        dt (float): Time step for integration.\n        N (int): Number of integration steps.\n        x0 (float): Initial position.\n        v0 (float): Initial velocity.\n        eta (float): Relative energy drift threshold for instability.\n\n    Returns:\n        bool: True if the trajectory is unstable, False otherwise.\n    \"\"\"\n    # Current state variables\n    x = x0\n    v = v0\n\n    # Constant for the potential, k = omega_max^2\n    k = omega_max**2\n\n    # Calculate initial energy E0\n    E0 = 0.5 * v**2 + 0.5 * k * x**2\n\n    # If the system starts at rest at the equilibrium position,\n    # it will not move, and the energy drift will be zero. It is stable.\n    # This also prevents division by zero if E0 is 0.\n    if E0 == 0:\n        return False\n\n    max_rel_drift = 0.0\n\n    # Initial acceleration\n    a = -k * x\n\n    # Simulation loop for N steps\n    for _ in range(N):\n        # Velocity Verlet integration\n        # 1. Update position\n        x_new = x + v * dt + 0.5 * a * dt**2\n\n        # 2. Calculate acceleration at the new position\n        a_new = -k * x_new\n\n        # 3. Update velocity\n        v_new = v + 0.5 * (a + a_new) * dt\n\n        # Update state for the next iteration\n        x, v, a = x_new, v_new, a_new\n\n        # Calculate the energy at the new step n\n        E_n = 0.5 * v**2 + 0.5 * k * x**2\n\n        # Calculate relative energy drift\n        rel_drift = np.abs(E_n - E0) / E0\n\n        # Update the maximum observed drift\n        if rel_drift > max_rel_drift:\n            max_rel_drift = rel_drift\n    \n    # Check for instability\n    is_unstable = max_rel_drift > eta\n    return is_unstable\n\ndef solve():\n    \"\"\"\n    Runs the simulation for all specified test cases and prints the results.\n    \"\"\"\n    # Test cases: (omega_max, dt, N, x0, v0, eta)\n    test_cases = [\n        (1.0, 0.5, 2000, 1.0, 0.0, 0.02),\n        (1.0, 2.0, 1000, 1.0, 0.0, 0.02),\n        (1.0, 2.1, 200, 1.0, 0.0, 0.02),\n        (3.0, 0.8, 200, 1.0, 0.0, 0.02),\n        (3.0, 0.2, 2000, 1.0, 0.0, 0.02),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Note: Python's `str(bool)` converts True to 'True' and False to 'False',\n    # which is different from the example's 'true'/'false'. The standard Python\n    # representation is used as it is unambiguous.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在真实的AIMD模拟中，由于多种数值误差源的存在，完美的能量守恒是无法实现的。这个练习将带你进入一个更真实的情景，你将分析积分时间步长和电子自洽场（SCF）收敛容差如何共同导致能量漂移。通过为这种漂移建立一个预测模型 ，你将学到一种实用的方法，用以在计算成本与模拟所需的精度之间做出明智的权衡。",
            "id": "3728716",
            "problem": "考虑一个在微正则系综（粒子数、体积和能量恒定；NVE）中进行的Born-Oppenheimer分子动力学（BOMD）模拟，该模拟针对一个由$128$个原子组成的高熵合金。在理想的连续时间演化中，当自洽场（SCF）精确收敛且力精确时，系统的总能量应该是守恒的。在实践中，两个系统数值误差源导致了能量漂移：积分器的有限时间步长 $\\Delta t$ 和电子结构求解器的有限SCF收敛容差 $\\tau$。对于足够小的 $\\Delta t$ 和严格的SCF容差，每个原子的能量漂移率可以由一个对主要小误差项呈线性的模型来近似。假设使用速度-Verlet积分器（对于行为良好的力，其局部截断误差为 $\\mathcal{O}((\\Delta t)^3)$ 阶，全局能量误差尺度为 $\\mathcal{O}((\\Delta t)^2)$），并且残余力误差与SCF能量容差近似线性相关，采用以下线性化漂移率模型：\n$$\nr(\\Delta t,\\tau) = \\alpha\\,(\\Delta t)^2 + \\beta\\,\\tau + \\gamma,\n$$\n其中 $r$ 是以 meV/atom/ns 为单位的能量漂移率，$\\Delta t$ 是以 fs（飞秒）为单位的时间步长，$\\tau$ 是以 eV（电子伏特）为单位的SCF能量容差，而 $\\alpha$、$\\beta$、$\\gamma$ 是待定参数。\n\n您将获得一组从对该$128$原子高熵合金进行的短时 NVE BOMD 运行中得到的 $(\\Delta t,\\tau)$ 对的能量漂移率 $r$ 的校准测量值。所有列出的 $r$ 值都是每个原子的值，单位为 meV/atom/ns。请使用这些校准数据，通过最小二乘法拟合线性模型参数 $\\alpha$、$\\beta$ 和 $\\gamma$：\n- $(\\Delta t=0.5\\,\\text{fs}, \\tau=1\\times 10^{-5}\\,\\text{eV}) \\rightarrow r=0.1625$\n- $(\\Delta t=0.5\\,\\text{fs}, \\tau=5\\times 10^{-5}\\,\\text{eV}) \\rightarrow r=0.3625$\n- $(\\Delta t=0.5\\,\\text{fs}, \\tau=1\\times 10^{-4}\\,\\text{eV}) \\rightarrow r=0.6125$\n- $(\\Delta t=0.5\\,\\text{fs}, \\tau=5\\times 10^{-4}\\,\\text{eV}) \\rightarrow r=2.6125$\n- $(\\Delta t=1.0\\,\\text{fs}, \\tau=1\\times 10^{-5}\\,\\text{eV}) \\rightarrow r=0.3500$\n- $(\\Delta t=1.0\\,\\text{fs}, \\tau=5\\times 10^{-5}\\,\\text{eV}) \\rightarrow r=0.5500$\n- $(\\Delta t=1.0\\,\\text{fs}, \\tau=1\\times 10^{-4}\\,\\text{eV}) \\rightarrow r=0.8000$\n- $(\\Delta t=1.0\\,\\text{fs}, \\tau=5\\times 10^{-4}\\,\\text{eV}) \\rightarrow r=2.8000$\n- $(\\Delta t=2.0\\,\\text{fs}, \\tau=1\\times 10^{-5}\\,\\text{eV}) \\rightarrow r=1.1000$\n- $(\\Delta t=2.0\\,\\text{fs}, \\tau=5\\times 10^{-5}\\,\\text{eV}) \\rightarrow r=1.3000$\n- $(\\Delta t=2.0\\,\\text{fs}, \\tau=1\\times 10^{-4}\\,\\text{eV}) \\rightarrow r=1.5500$\n- $(\\Delta t=2.0\\,\\text{fs}, \\tau=5\\times 10^{-4}\\,\\text{eV}) \\rightarrow r=3.5500$\n\n在拟合 $\\alpha$、$\\beta$ 和 $\\gamma$ 后，通过计算 $r(\\Delta t,\\tau)$ 来量化指定测试 $(\\Delta t,\\tau)$ 对的能量漂移。此外，推导出一个关于SCF容差 $\\tau$ 的函数，即最大允许时间步长 $\\Delta t_{\\max}$ 的建议值，以确保漂移率保持在目标阈值 $r_{\\text{thr}}=1\\,\\text{meV/atom/ns}$ 以下。使用拟合后的模型，该建议必须满足：\n$$ \\Delta t_{\\max}(\\tau) = \\begin{cases} \\sqrt{\\dfrac{r_{\\text{thr}} - \\beta\\,\\tau - \\gamma}{\\alpha}}  \\text{if } r_{\\text{thr}} - \\beta\\,\\tau - \\gamma > 0 \\\\ 0  \\text{otherwise} \\end{cases} $$\n其中 $\\Delta t_{\\max}$ 以 fs 表示。\n\n您的程序必须执行以下步骤：\n1. 使用上述校准数据集拟合参数 $\\alpha$、$\\beta$ 和 $\\gamma$。\n2. 计算以下测试对的预测漂移率 $r(\\Delta t,\\tau)$：\n   - $\\Delta t=1.0\\,\\text{fs}$, $\\tau=1\\times 10^{-5}\\,\\text{eV}$,\n   - $\\Delta t=2.0\\,\\text{fs}$, $\\tau=1\\times 10^{-5}\\,\\text{eV}$,\n   - $\\Delta t=1.5\\,\\text{fs}$, $\\tau=1\\times 10^{-4}\\,\\text{eV}$。\n   报告每个 $r$，单位为 meV/atom/ns。\n3. 为以下SCF容差计算推荐的 $\\Delta t_{\\max}$，以使漂移低于 $r_{\\text{thr}}=1\\,\\text{meV/atom/ns}$：\n   - $\\tau=1\\times 10^{-5}\\,\\text{eV}$,\n   - $\\tau=5\\times 10^{-5}\\,\\text{eV}$,\n   - $\\tau=1\\times 10^{-4}\\,\\text{eV}$,\n   - $\\tau=5\\times 10^{-4}\\,\\text{eV}$。\n   报告每个 $\\Delta t_{\\max}$，单位为 fs。\n\n所有数值答案必须是浮点数，并四舍五入到六位小数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序如下：三个预测的漂移率，后跟四个推荐的最大时间步长，即 $[r_{1},r_{2},r_{3},\\Delta t_{\\max,1},\\Delta t_{\\max,2},\\Delta t_{\\max,3},\\Delta t_{\\max,4}]$。",
            "solution": "该问题要求我们确定一个用于Born-Oppenheimer分子动力学（BOMD）模拟中能量漂移的线性模型的参数，然后使用此模型进行预测并建立操作约束。分析过程主要分为两个阶段：首先，使用线性最小二乘法拟合模型参数；其次，应用拟合后的模型回答提出的具体问题。\n\n提出的每个原子的能量漂移率 $r$ 的模型为：\n$$\nr(\\Delta t, \\tau) = \\alpha (\\Delta t)^2 + \\beta \\tau + \\gamma\n$$\n其中 $\\Delta t$ 是以飞秒（fs）为单位的积分时间步长，$\\tau$ 是以电子伏特（eV）为单位的自洽场（SCF）能量收敛容差，$r$ 是以 meV/atom/ns 为单位的漂移率。待定参数为 $\\alpha$、$\\beta$ 和 $\\gamma$。该模型对参数是线性的。$(\\Delta t)^2$ 项的物理动机是速度-Verlet积分器的全局能量误差尺度，而对 $\\tau$ 的线性依赖是对不完全SCF收敛对原子力的影响的一个合理的一阶近似。\n\n我们得到了12个形式为 $((\\Delta t)_i, \\tau_i, r_i)$ 的校准数据点，其中 $i=1, \\dots, 12$。为了找到最佳拟合参数 $\\alpha$、$\\beta$ 和 $\\gamma$，我们采用线性最小二乘法。该方法最小化观测到的漂移率 $r_i$ 与模型预测的漂移率之间的平方差之和。\n\n我们为每个数据点定义一个参数向量 $\\mathbf{p}$ 和一个特征向量 $\\mathbf{x}_i$：\n$$\n\\mathbf{p} = \\begin{pmatrix} \\alpha \\\\ \\beta \\\\ \\gamma \\end{pmatrix}, \\quad \\mathbf{x}_i = \\begin{pmatrix} (\\Delta t_i)^2 \\\\ \\tau_i \\\\ 1 \\end{pmatrix}\n$$\n模型可以表示为 $r_i \\approx \\mathbf{x}_i^T \\mathbf{p}$。我们可以将所有12个方程组合成一个矩阵方程：\n$$\n\\mathbf{A} \\mathbf{p} = \\mathbf{b}\n$$\n其中 $\\mathbf{A}$ 是一个 $12 \\times 3$ 的设计矩阵，其行是特征向量 $\\mathbf{x}_i^T$，$\\mathbf{b}$ 是一个 $12 \\times 1$ 的观测漂移率 $r_i$ 向量。\n\n$$\n\\mathbf{A} = \\begin{pmatrix}\n(\\Delta t_1)^2  \\tau_1  1 \\\\\n(\\Delta t_2)^2  \\tau_2  1 \\\\\n\\vdots  \\vdots  \\vdots \\\\\n(\\Delta t_{12})^2  \\tau_{12}  1\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n(0.5)^2  1 \\times 10^{-5}  1 \\\\\n(0.5)^2  5 \\times 10^{-5}  1 \\\\\n(0.5)^2  1 \\times 10^{-4}  1 \\\\\n(0.5)^2  5 \\times 10^{-4}  1 \\\\\n(1.0)^2  1 \\times 10^{-5}  1 \\\\\n(1.0)^2  5 \\times 10^{-5}  1 \\\\\n(1.0)^2  1 \\times 10^{-4}  1 \\\\\n(1.0)^2  5 \\times 10^{-4}  1 \\\\\n(2.0)^2  1 \\times 10^{-5}  1 \\\\\n(2.0)^2  5 \\times 10^{-5}  1 \\\\\n(2.0)^2  1 \\times 10^{-4}  1 \\\\\n(2.0)^2  5 \\times 10^{-4}  1\n\\end{pmatrix},\n\\quad\n\\mathbf{b} = \\begin{pmatrix}\n0.1625 \\\\ 0.3625 \\\\ 0.6125 \\\\ 2.6125 \\\\\n0.3500 \\\\ 0.5500 \\\\ 0.8000 \\\\ 2.8000 \\\\\n1.1000 \\\\ 1.3000 \\\\ 1.5500 \\\\ 3.5500\n\\end{pmatrix}\n$$\n\n最小二乘解 $\\mathbf{p}$ 最小化残差向量的欧几里得范数 $||\\mathbf{A} \\mathbf{p} - \\mathbf{b}||_2$。该解通过求解正规方程得到：\n$$\n(\\mathbf{A}^T \\mathbf{A}) \\mathbf{p} = \\mathbf{A}^T \\mathbf{b}\n$$\n求解这个线性方程组以得到 $\\mathbf{p}$，即可得出 $\\alpha$、$\\beta$ 和 $\\gamma$ 的值。用给定数据进行此计算，结果为：\n$$\n\\alpha = 0.25 \\, \\frac{\\text{meV/atom/ns}}{\\text{fs}^2}\n$$\n$$\n\\beta = 5000 \\, \\frac{\\text{meV/atom/ns}}{\\text{eV}}\n$$\n$$\n\\gamma = 0.05 \\, \\text{meV/atom/ns}\n$$\n所提供的数据可以被这些参数完美描述，表明校准集中没有随机噪声。因此，拟合后的模型为：\n$$\nr(\\Delta t, \\tau) = 0.25 (\\Delta t)^2 + 5000 \\tau + 0.05\n$$\n\n在模型参数化后，我们可以进行所需的计算。\n\n**1. 预测的漂移率**\n\n我们为三个测试对 $(\\Delta t, \\tau)$ 计算漂移率 $r$：\n- 对于 $(\\Delta t=1.0\\,\\text{fs}, \\tau=1 \\times 10^{-5}\\,\\text{eV})$：\n$$\nr_1 = 0.25 (1.0)^2 + 5000 (1 \\times 10^{-5}) + 0.05 = 0.25 + 0.05 + 0.05 = 0.35 \\, \\text{meV/atom/ns}\n$$\n- 对于 $(\\Delta t=2.0\\,\\text{fs}, \\tau=1 \\times 10^{-5}\\,\\text{eV})$：\n$$\nr_2 = 0.25 (2.0)^2 + 5000 (1 \\times 10^{-5}) + 0.05 = 0.25(4) + 0.05 + 0.05 = 1.0 + 0.05 + 0.05 = 1.10 \\, \\text{meV/atom/ns}\n$$\n- 对于 $(\\Delta t=1.5\\,\\text{fs}, \\tau=1 \\times 10^{-4}\\,\\text{eV})$：\n$$\nr_3 = 0.25 (1.5)^2 + 5000 (1 \\times 10^{-4}) + 0.05 = 0.25(2.25) + 0.5 + 0.05 = 0.5625 + 0.5 + 0.05 = 1.1125 \\, \\text{meV/atom/ns}\n$$\n\n**2. 推荐的最大时间步长**\n\n我们需要找到在给定容差 $\\tau$ 下的最大时间步长 $\\Delta t_{\\max}$，使得漂移率不超过阈值 $r_{\\text{thr}} = 1.0\\,\\text{meV/atom/ns}$。我们从模型出发，求解 $\\Delta t$：\n$$\nr_{\\text{thr}} \\ge 0.25 (\\Delta t)^2 + 5000 \\tau + 0.05\n$$\n$$\n(\\Delta t)^2 \\le \\frac{r_{\\text{thr}} - 5000 \\tau - 0.05}{0.25}\n$$\n为了使 $\\Delta t$ 为实数，分子必须为非负数。这给出了 $\\Delta t_{\\max}$ 的表达式：\n$$\n\\Delta t_{\\max}(\\tau) = \\begin{cases}\n\\sqrt{\\dfrac{1.0 - 5000 \\tau - 0.05}{0.25}} = \\sqrt{4 (0.95 - 5000 \\tau)} = 2\\sqrt{0.95 - 5000 \\tau},  \\text{if } 0.95 - 5000 \\tau > 0 \\\\\n0,  \\text{otherwise}\n\\end{cases}\n$$\n条件 $0.95 - 5000 \\tau > 0$ 意味着 $\\tau  \\frac{0.95}{5000} = 1.9 \\times 10^{-4}$ eV。\n\n我们现在为给定的四个 $\\tau$ 值计算 $\\Delta t_{\\max}$：\n\n- 对于 $\\tau = 1 \\times 10^{-5}\\,\\text{eV}$：条件满足。\n$$\n\\Delta t_{\\max,1} = 2\\sqrt{0.95 - 5000(1 \\times 10^{-5})} = 2\\sqrt{0.95 - 0.05} = 2\\sqrt{0.90} \\approx 1.897367 \\, \\text{fs}\n$$\n- 对于 $\\tau = 5 \\times 10^{-5}\\,\\text{eV}$：条件满足。\n$$\n\\Delta t_{\\max,2} = 2\\sqrt{0.95 - 5000(5 \\times 10^{-5})} = 2\\sqrt{0.95 - 0.25} = 2\\sqrt{0.70} \\approx 1.673320 \\, \\text{fs}\n$$\n- 对于 $\\tau = 1 \\times 10^{-4}\\,\\text{eV}$：条件满足。\n$$\n\\Delta t_{\\max,3} = 2\\sqrt{0.95 - 5000(1 \\times 10^{-4})} = 2\\sqrt{0.95 - 0.50} = 2\\sqrt{0.45} \\approx 1.341641 \\, \\text{fs}\n$$\n- 对于 $\\tau = 5 \\times 10^{-4}\\,\\text{eV}$：$5000 \\tau = 2.5$，大于 $0.95$。分子为负。\n$$\n\\Delta t_{\\max,4} = 0 \\, \\text{fs}\n$$\n\n最终的结果集合，四舍五入到六位小数后为：$r_1=0.350000$，$r_2=1.100000$，$r_3=1.112500$，$\\Delta t_{\\max,1}=1.897367$，$\\Delta t_{\\max,2}=1.673320$，$\\Delta t_{\\max,3}=1.341641$，以及 $\\Delta t_{\\max,4}=0.000000$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of fitting an energy drift model for BOMD simulations\n    and using it for prediction and constraint derivation.\n    \"\"\"\n    \n    # --- Step 1: Fit the model parameters using least squares ---\n    \n    # Calibration data: (delta_t, tau, r)\n    # delta_t is in fs, tau in eV, r in meV/atom/ns.\n    calibration_data = [\n        (0.5, 1e-5, 0.1625),\n        (0.5, 5e-5, 0.3625),\n        (0.5, 1e-4, 0.6125),\n        (0.5, 5e-4, 2.6125),\n        (1.0, 1e-5, 0.3500),\n        (1.0, 5e-5, 0.5500),\n        (1.0, 1e-4, 0.8000),\n        (1.0, 5e-4, 2.8000),\n        (2.0, 1e-5, 1.1000),\n        (2.0, 5e-5, 1.3000),\n        (2.0, 1e-4, 1.5500),\n        (2.0, 5e-4, 3.5500),\n    ]\n\n    # The model is r = alpha * (delta_t)^2 + beta * tau + gamma\n    # This is a linear model in the parameters (alpha, beta, gamma).\n    # We set up the linear system A * p = b, where p = [alpha, beta, gamma].\n    \n    num_points = len(calibration_data)\n    A = np.zeros((num_points, 3))\n    b = np.zeros(num_points)\n    \n    for i, (dt, tau, r) in enumerate(calibration_data):\n        A[i, 0] = dt**2\n        A[i, 1] = tau\n        A[i, 2] = 1\n        b[i] = r\n        \n    # Solve the least squares problem A*p = b for p\n    params, _, _, _ = np.linalg.lstsq(A, b, rcond=None)\n    alpha, beta, gamma = params\n\n    # --- Step 2: Compute predicted drift rates for test cases ---\n    \n    test_rates_inputs = [\n        (1.0, 1e-5),  # (delta_t, tau)\n        (2.0, 1e-5),\n        (1.5, 1e-4),\n    ]\n    \n    predicted_rates = []\n    for dt, tau in test_rates_inputs:\n        rate = alpha * dt**2 + beta * tau + gamma\n        predicted_rates.append(rate)\n\n    # --- Step 3: Compute recommended max time step ---\n\n    r_thr = 1.0  # meV/atom/ns\n    \n    test_dtmax_inputs = [\n        1e-5,  # tau in eV\n        5e-5,\n        1e-4,\n        5e-4,\n    ]\n    \n    recommended_dtmax = []\n    for tau in test_dtmax_inputs:\n        # dt_max = sqrt((r_thr - beta*tau - gamma) / alpha)\n        numerator = r_thr - beta * tau - gamma\n        if numerator > 0:\n            dt_max = np.sqrt(numerator / alpha)\n        else:\n            dt_max = 0.0\n        recommended_dtmax.append(dt_max)\n        \n    # Combine all results\n    all_results = predicted_rates + recommended_dtmax\n    \n    # Format the output as specified\n    formatted_results = [f\"{res:.6f}\" for res in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}