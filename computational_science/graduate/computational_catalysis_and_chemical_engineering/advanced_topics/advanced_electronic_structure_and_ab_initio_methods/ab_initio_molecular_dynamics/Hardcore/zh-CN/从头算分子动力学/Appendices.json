{
    "hands_on_practices": [
        {
            "introduction": "在进行任何分子动力学模拟时，选择合适的时间步长 $\\Delta t$ 是一个至关重要的初始步骤。如果时间步长相对于系统中最快的原子振动过大，数值积分算法可能会变得不稳定，导致能量不守恒甚至模拟崩溃。本练习  通过一个简化的谐振子模型，直观地展示了这一基本原理，并让您亲手探索广泛使用的速度Verlet算法的稳定性边界。理解这个边界对于设置可靠的从头算分子动力学模拟至关重要。",
            "id": "2448283",
            "problem": "从头算分子动力学 (AIMD) 遵循在从电子结构理论获得的电子势能面上的经典核运动。考虑一个近似于分子最快振动模式的单个核自由度。将此模式建模为一个质量为 $m$、角频率为 $\\omega_{\\max}$ 的一维谐振子，在势 $V(x) = \\tfrac{1}{2} k x^2$（其中 $k = m \\omega_{\\max}^2$）上运动。使用约化的无量纲单位，其中 $m = 1$，因此 $k = \\omega_{\\max}^2$。初始条件为 $x(0) = x_0$ 和 $v(0) = v_0$。设在第 $n$ 步的离散总能量为\n$$\nE_n = \\tfrac{1}{2} v_n^2 + \\tfrac{1}{2} \\omega_{\\max}^2 x_n^2,\n$$\n并将在 $N$ 步的轨迹上的最大相对能量漂移定义为\n$$\n\\delta_{\\max} = \\max_{0 \\le n \\le N} \\frac{\\lvert E_n - E_0 \\rvert}{E_0}.\n$$\n如果 $\\delta_{\\max} > \\eta$，则轨迹被标记为“不稳定”，否则为“稳定”，其中 $\\eta$ 是一个给定的正阈值。所有量都是无量纲的，不需要物理单位。\n\n任务：编写一个完整、可运行的程序，该程序针对下方的每个测试用例，使用恒定的时间步长 $\\Delta t$ 对运动进行 $N$ 步的数值积分，计算 $\\delta_{\\max}$，并根据上述定义输出一个布尔值，以指示轨迹是否不稳定。\n\n您必须使用以下测试套件，其中每个用例是一个元组 $(\\omega_{\\max}, \\Delta t, N, x_0, v_0, \\eta)$：\n- 用例 1：$(\\omega_{\\max} = 1.0, \\Delta t = 0.5, N = 2000, x_0 = 1.0, v_0 = 0.0, \\eta = 0.02)$。\n- 用例 2：$(\\omega_{\\max} = 1.0, \\Delta t = 2.0, N = 1000, x_0 = 1.0, v_0 = 0.0, \\eta = 0.02)$。\n- 用例 3：$(\\omega_{\\max} = 1.0, \\Delta t = 2.1, N = 200, x_0 = 1.0, v_0 = 0.0, \\eta = 0.02)$。\n- 用例 4：$(\\omega_{\\max} = 3.0, \\Delta t = 0.8, N = 200, x_0 = 1.0, v_0 = 0.0, \\eta = 0.02)$。\n- 用例 5：$(\\omega_{\\max} = 3.0, \\Delta t = 0.2, N = 2000, x_0 = 1.0, v_0 = 0.0, \\eta = 0.02)$。\n\n最终输出格式：您的程序应生成单行输出，其中包含所有测试用例的布尔不稳定性结果，格式为按上述用例顺序排列、方括号内用逗号分隔的列表，例如 $[\\text{True},\\text{False},\\text{True}]$。",
            "solution": "首先对问题陈述进行严格验证。\n\n已知条件如下：\n- **系统**：一个模拟单个核自由度的一维谐振子。\n- **势能**：$V(x) = \\tfrac{1}{2} k x^2$。\n- **质量和力常数**：在约化的无量纲单位中，质量 $m = 1$，力常数 $k = \\omega_{\\max}^2$。\n- **运动方程**：根据 Newton 第二定律，$m\\ddot{x} = F(x)$，其中 $F(x) = -\\frac{dV}{dx} = -kx$。当 $m=1$ 时，方程变为 $\\ddot{x} = -\\omega_{\\max}^2 x$。\n- **初始条件**：$x(0) = x_0$ 和 $v(0) = v_0$。\n- **离散总能量**：在每个时间步 $n$，能量为 $E_n = \\tfrac{1}{2} v_n^2 + \\tfrac{1}{2} \\omega_{\\max}^2 x_n^2$。\n- **最大相对能量漂移**：一个衡量数值误差的指标，定义为 $\\delta_{\\max} = \\max_{0 \\le n \\le N} \\frac{\\lvert E_n - E_0 \\rvert}{E_0}$。\n- **不稳定性判据**：如果 $\\delta_{\\max} > \\eta$，则轨迹为“不稳定”，其中 $\\eta$ 是一个指定的正阈值。\n- **任务**：对于几个测试用例，使用时间步长 $\\Delta t$ 对系统进行 $N$ 步的数值积分，并确定所得轨迹是否不稳定。\n\n验证的结论是，所陈述的问题是不适定的。它存在一个关键的疏漏：未指定数值积分算法。积分器（例如 Euler、Runge-Kutta、Verlet）的选择对解决方案至关重要，因为不同的算法会产生不同的轨迹 $(x_n, v_n)$，并因此产生不同的能量漂移 $\\delta_{\\max}$。对于一个计算物理问题，未能指定数值方法是一个严重的缺陷（违反了**不适定或结构不良**准则）。\n\n然而，该问题置于*从头算分子动力学* (AIMD) 的背景下。在该领域，**速度Verlet算法**因其时间可逆性、辛性质（相空间体积守恒）以及对于哈密顿系统出色的长期能量守恒性，而成为一种标准且广泛使用的方法。此外，所提供的测试用例似乎是专门为探究速度Verlet算法应用于谐振子时的著名稳定性极限 $\\omega_{\\max} \\Delta t \\le 2$ 而设计的。当 $\\omega_{\\max} \\Delta t$ 的值超过这个极限时，算法会变得数值不稳定，能量会发散。这提供了强有力的上下文证据，表明速度Verlet算法是预期的解题方法。通过做出这个专业上合理的假设，问题就变得适定且可解。\n\n因此，我们采用速度Verlet算法进行求解。将系统从时间步 $n$ 推进到 $n+1$ 的更新方程如下：\n1. 更新位置：$$x_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a_n (\\Delta t)^2$$\n2. 更新速度：$$v_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t$$\n其中 $\\Delta t$ 是时间步长，而 $a_n$ 是在第 $n$ 步的加速度。对于我们的谐振子，加速度是位置的函数：$a(x) = -\\omega_{\\max}^2 x$。因此，$a_n = -\\omega_{\\max}^2 x_n$ 且 $a_{n+1} = -\\omega_{\\max}^2 x_{n+1}$。\n\n每个测试用例的计算步骤如下：\n1. 使用给定参数初始化系统状态：$(\\omega_{\\max}, \\Delta t, N, x_0, v_0, \\eta)$。设置 $x_n = x_0$ 和 $v_n = v_0$。\n2. 计算初始能量 $E_0 = \\tfrac{1}{2} v_0^2 + \\tfrac{1}{2} \\omega_{\\max}^2 x_0^2$。由于所有测试用例的初始势能都非零，因此 $E_0$ 非零，避免了在计算漂移时出现除以零的情况。将最大相对漂移 $\\delta_{\\max}$ 初始化为 $0$。\n3. 进入一个循环以执行 $N$ 个积分步骤。对于从 $n=0$ 到 $N-1$ 的每一步：\n    a. 计算当前位置的加速度：$a_n = -\\omega_{\\max}^2 x_n$。\n    b. 使用第一个 Verlet 方程更新位置以获得 $x_{n+1}$。\n    c. 计算更新后位置的新加速度：$a_{n+1} = -\\omega_{\\max}^2 x_{n+1}$。\n    d. 使用第二个 Verlet 方程更新速度以获得 $v_{n+1}$。\n    e. 计算新的总能量 $E_{n+1} = \\tfrac{1}{2} v_{n+1}^2 + \\tfrac{1}{2} \\omega_{\\max}^2 x_{n+1}^2$。\n    f. 计算此步的相对能量漂移 $\\frac{\\lvert E_{n+1} - E_0 \\rvert}{E_0}$。\n    g. 如果当前漂移大于已存储的最大值，则更新 $\\delta_{\\max}$。\n    h. 为下一次迭代将当前状态 $(x_n, v_n)$ 设置为新状态 $(x_{n+1}, v_{n+1})$。\n4. 循环完成后，将最终的 $\\delta_{\\max}$ 与不稳定性阈值 $\\eta$ 进行比较。如果 $\\delta_{\\max} > \\eta$，则轨迹分类为不稳定 (`True`)；否则，分类为稳定 (`False`)。\n\n将此过程系统地应用于每个测试用例，以生成所需的布尔结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(omega_max, dt, N, x0, v0, eta):\n    \"\"\"\n    Numerically integrates a 1D harmonic oscillator using the Velocity Verlet\n    algorithm and determines if the trajectory is unstable based on energy drift.\n\n    Args:\n        omega_max (float): Angular frequency of the oscillator.\n        dt (float): Time step for integration.\n        N (int): Number of integration steps.\n        x0 (float): Initial position.\n        v0 (float): Initial velocity.\n        eta (float): Relative energy drift threshold for instability.\n\n    Returns:\n        bool: True if the trajectory is unstable, False otherwise.\n    \"\"\"\n    # Current state variables\n    x = x0\n    v = v0\n\n    # Constant for the potential, k = omega_max^2\n    k = omega_max**2\n\n    # Calculate initial energy E0\n    E0 = 0.5 * v**2 + 0.5 * k * x**2\n\n    # If the system starts at rest at the equilibrium position,\n    # it will not move, and the energy drift will be zero. It is stable.\n    # This also prevents division by zero if E0 is 0.\n    if E0 == 0:\n        return False\n\n    max_rel_drift = 0.0\n\n    # Initial acceleration\n    a = -k * x\n\n    # Simulation loop for N steps\n    for _ in range(N):\n        # Velocity Verlet integration\n        # 1. Update position\n        x_new = x + v * dt + 0.5 * a * dt**2\n\n        # 2. Calculate acceleration at the new position\n        a_new = -k * x_new\n\n        # 3. Update velocity\n        v_new = v + 0.5 * (a + a_new) * dt\n\n        # Update state for the next iteration\n        x, v, a = x_new, v_new, a_new\n\n        # Calculate the energy at the new step n\n        E_n = 0.5 * v**2 + 0.5 * k * x**2\n\n        # Calculate relative energy drift\n        rel_drift = np.abs(E_n - E0) / E0\n\n        # Update the maximum observed drift\n        if rel_drift > max_rel_drift:\n            max_rel_drift = rel_drift\n    \n    # Check for instability\n    is_unstable = max_rel_drift > eta\n    return is_unstable\n\ndef solve():\n    \"\"\"\n    Runs the simulation for all specified test cases and prints the results.\n    \"\"\"\n    # Test cases: (omega_max, dt, N, x0, v0, eta)\n    test_cases = [\n        (1.0, 0.5, 2000, 1.0, 0.0, 0.02),\n        (1.0, 2.0, 1000, 1.0, 0.0, 0.02),\n        (1.0, 2.1, 200, 1.0, 0.0, 0.02),\n        (3.0, 0.8, 200, 1.0, 0.0, 0.02),\n        (3.0, 0.2, 2000, 1.0, 0.0, 0.02),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Note: Python's `str(bool)` converts True to 'True' and False to 'False',\n    # which is different from the example's 'true'/'false'. The standard Python\n    # representation is used as it is unambiguous.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在微正则系综 (NVE) 模拟中，总能量是一个应当守恒的量。然而，在实际的从头算分子动力学模拟中，由于数值误差的累积，总能量常常会出现系统性的漂移。对于波恩-奥本海默分子动力学 (BOMD) 而言，能量漂移主要有两个来源：数值积分器使用的有限时间步长 $\\Delta t$，以及电子结构自洽场 (SCF) 计算的不完全收敛。本练习  提出了一个量化模型，将能量漂移率与时间步长和SCF收敛阈值 $\\tau$ 联系起来，从而为您提供一个在计算成本和模拟精度之间进行权衡的实用框架。",
            "id": "3728716",
            "problem": "考虑一个由 $128$ 个原子组成的高熵合金的玻恩-奥本海默分子动力学（Born-Oppenheimer Molecular Dynamics, BOMD）模拟，该模拟在微正则系综（粒子数、体积和能量恒定；NVE）中进行。在理想的连续时间演化中，当自洽场（Self-Consistent Field, SCF）计算精确收敛且力精确时，系统总能量应当是守恒的。实际上，有两个系统数值误差源会导致能量漂移：积分器的有限时间步长 $\\Delta t$ 和电子结构求解器的有限SCF收敛容差 $\\tau$。对于足够小的 $\\Delta t$ 和严格的SCF收敛容差，每个原子的能量漂移率可以由一个对主要小误差项呈线性的模型来近似。假设使用速度Verlet积分器（对于行为良好的力，其局部截断误差为 $\\mathcal{O}((\\Delta t)^3)$ 阶，全局能量误差为 $\\mathcal{O}((\\Delta t)^2)$ 阶），并且残余力误差与SCF能量容差大致呈线性关系，我们采用以下线性化漂移率模型：\n$$\nr(\\Delta t,\\tau) = \\alpha\\,(\\Delta t)^2 + \\beta\\,\\tau + \\gamma,\n$$\n其中，$r$ 是能量漂移率，单位为 meV/原子/纳秒；$\\Delta t$ 是时间步长，单位为 fs（飞秒）；$\\tau$ 是SCF能量容差，单位为 eV（电子伏特）；$\\alpha$、$\\beta$、$\\gamma$ 是待定参数。\n\n现为您提供一组从该 $128$ 原子高熵合金的短时NVE BOMD运行中获得的 $(\\Delta t,\\tau)$ 对的能量漂移率 $r$ 的校准测量数据。所有列出的 $r$ 值均是每个原子的漂移率，单位为 meV/原子/纳秒。请使用这些校准数据，通过最小二乘法拟合线性模型参数 $\\alpha$、$\\beta$ 和 $\\gamma$：\n- $(\\Delta t=0.5\\,\\text{fs}, \\tau=1\\times 10^{-5}\\,\\text{eV}) \\rightarrow r=0.1625$\n- $(\\Delta t=0.5\\,\\text{fs}, \\tau=5\\times 10^{-5}\\,\\text{eV}) \\rightarrow r=0.3625$\n- $(\\Delta t=0.5\\,\\text{fs}, \\tau=1\\times 10^{-4}\\,\\text{eV}) \\rightarrow r=0.6125$\n- $(\\Delta t=0.5\\,\\text{fs}, \\tau=5\\times 10^{-4}\\,\\text{eV}) \\rightarrow r=2.6125$\n- $(\\Delta t=1.0\\,\\text{fs}, \\tau=1\\times 10^{-5}\\,\\text{eV}) \\rightarrow r=0.3500$\n- $(\\Delta t=1.0\\,\\text{fs}, \\tau=5\\times 10^{-5}\\,\\text{eV}) \\rightarrow r=0.5500$\n- $(\\Delta t=1.0\\,\\text{fs}, \\tau=1\\times 10^{-4}\\,\\text{eV}) \\rightarrow r=0.8000$\n- $(\\Delta t=1.0\\,\\text{fs}, \\tau=5\\times 10^{-4}\\,\\text{eV}) \\rightarrow r=2.8000$\n- $(\\Delta t=2.0\\,\\text{fs}, \\tau=1\\times 10^{-5}\\,\\text{eV}) \\rightarrow r=1.1000$\n- $(\\Delta t=2.0\\,\\text{fs}, \\tau=5\\times 10^{-5}\\,\\text{eV}) \\rightarrow r=1.3000$\n- $(\\Delta t=2.0\\,\\text{fs}, \\tau=1\\times 10^{-4}\\,\\text{eV}) \\rightarrow r=1.5500$\n- $(\\Delta t=2.0\\,\\text{fs}, \\tau=5\\times 10^{-4}\\,\\text{eV}) \\rightarrow r=3.5500$\n\n在拟合出 $\\alpha$、$\\beta$ 和 $\\gamma$ 之后，通过计算 $r(\\Delta t,\\tau)$ 来量化指定测试 $(\\Delta t,\\tau)$ 对的能量漂移。此外，请推导出一个关于SCF容差 $\\tau$ 的函数，即最大允许时间步长 $\\Delta t_{\\max}$ 的建议值，以确保漂移率保持在目标阈值 $r_{\\text{thr}}=1\\,\\text{meV/atom/ns}$ 以下。使用拟合后的模型，该建议值必须满足：\n$$\n\\Delta t_{\\max}(\\tau) = \n\\begin{cases}\n\\sqrt{\\dfrac{r_{\\text{thr}} - \\beta\\,\\tau - \\gamma}{\\alpha}},  \\text{如果 } r_{\\text{thr}} - \\beta\\,\\tau - \\gamma > 0,\\\\[8pt]\n0,  \\text{否则,}\n\\end{cases}\n$$\n其中 $\\Delta t_{\\max}$ 以 fs 为单位表示。\n\n您的程序必须执行以下步骤：\n1. 使用上述校准数据集拟合参数 $\\alpha$、$\\beta$ 和 $\\gamma$。\n2. 计算以下测试对的预测漂移率 $r(\\Delta t,\\tau)$：\n   - $\\Delta t=1.0\\,\\text{fs}$，$\\tau=1\\times 10^{-5}\\,\\text{eV}$，\n   - $\\Delta t=2.0\\,\\text{fs}$，$\\tau=1\\times 10^{-5}\\,\\text{eV}$，\n   - $\\Delta t=1.5\\,\\text{fs}$，$\\tau=1\\times 10^{-4}\\,\\text{eV}$。\n   以 meV/原子/纳秒为单位报告每个 $r$ 值。\n3. 计算以下SCF容差对应的建议最大时间步长 $\\Delta t_{\\max}$，以使漂移低于 $r_{\\text{thr}}=1\\,\\text{meV/atom/ns}$：\n   - $\\tau=1\\times 10^{-5}\\,\\text{eV}$，\n   - $\\tau=5\\times 10^{-5}\\,\\text{eV}$，\n   - $\\tau=1\\times 10^{-4}\\,\\text{eV}$，\n   - $\\tau=5\\times 10^{-4}\\,\\text{eV}$。\n   以 fs 为单位报告每个 $\\Delta t_{\\max}$ 值。\n\n所有数值答案必须是浮点数，并四舍五入到六位小数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按以下顺序排列结果：三个预测漂移率，后跟四个建议的最大时间步长，即 $[r_{1},r_{2},r_{3},\\Delta t_{\\max,1},\\Delta t_{\\max,2},\\Delta t_{\\max,3},\\Delta t_{\\max,4}]$。",
            "solution": "该问题要求我们确定一个用于描述玻恩-奥本海默分子动力学（BOMD）模拟中能量漂移的线性模型的参数，然后使用该模型进行预测并建立操作约束。分析过程主要分为两个阶段：首先，使用线性最小二乘法拟合模型参数；其次，应用拟合后的模型回答提出的具体问题。\n\n提出的每个原子的能量漂移率 $r$ 的模型为：\n$$\nr(\\Delta t, \\tau) = \\alpha (\\Delta t)^2 + \\beta \\tau + \\gamma\n$$\n其中 $\\Delta t$ 是积分时间步长，单位为飞秒（fs）；$\\tau$ 是自洽场（SCF）能量收敛容差，单位为电子伏特（eV）；$r$ 是漂移率，单位为 meV/原子/纳秒。待定参数是 $\\alpha$、$\\beta$ 和 $\\gamma$。该模型是关于参数的线性模型。$(\\Delta t)^2$ 项的物理动机是速度-Verlet积分器的全局能量误差缩放特性，而对 $\\tau$ 的线性依赖性是对于不完全SCF收敛对原子力的影响的一个合理的一阶近似。\n\n我们有12个形式为 $((\\Delta t)_i, \\tau_i, r_i)$ 的校准数据点，$i=1, \\dots, 12$。为了找到最佳拟合参数 $\\alpha$、$\\beta$ 和 $\\gamma$，我们采用线性最小二乘法。该方法最小化观测漂移率 $r_i$ 与模型预测值之间的平方差之和。\n\n我们为每个数据点定义一个参数向量 $\\mathbf{p}$ 和一个特征向量 $\\mathbf{x}_i$：\n$$\n\\mathbf{p} = \\begin{pmatrix} \\alpha \\\\ \\beta \\\\ \\gamma \\end{pmatrix}, \\quad \\mathbf{x}_i = \\begin{pmatrix} (\\Delta t_i)^2 \\\\ \\tau_i \\\\ 1 \\end{pmatrix}\n$$\n模型可以表示为 $r_i \\approx \\mathbf{x}_i^T \\mathbf{p}$。我们可以将所有12个方程组合成一个矩阵方程：\n$$\n\\mathbf{A} \\mathbf{p} = \\mathbf{b}\n$$\n其中 $\\mathbf{A}$ 是一个 $12 \\times 3$ 的设计矩阵，其行是特征向量 $\\mathbf{x}_i^T$，$\\mathbf{b}$ 是一个 $12 \\times 1$ 的观测漂移率 $r_i$ 的向量。\n\n$$\n\\mathbf{A} = \\begin{pmatrix}\n(\\Delta t_1)^2 & \\tau_1 & 1 \\\\\n(\\Delta t_2)^2 & \\tau_2 & 1 \\\\\n\\vdots & \\vdots & \\vdots \\\\\n(\\Delta t_{12})^2 & \\tau_{12} & 1\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n(0.5)^2 & 1 \\times 10^{-5} & 1 \\\\\n(0.5)^2 & 5 \\times 10^{-5} & 1 \\\\\n(0.5)^2 & 1 \\times 10^{-4} & 1 \\\\\n(0.5)^2 & 5 \\times 10^{-4} & 1 \\\\\n(1.0)^2 & 1 \\times 10^{-5} & 1 \\\\\n(1.0)^2 & 5 \\times 10^{-5} & 1 \\\\\n(1.0)^2 & 1 \\times 10^{-4} & 1 \\\\\n(1.0)^2 & 5 \\times 10^{-4} & 1 \\\\\n(2.0)^2 & 1 \\times 10^{-5} & 1 \\\\\n(2.0)^2 & 5 \\times 10^{-5} & 1 \\\\\n(2.0)^2 & 1 \\times 10^{-4} & 1 \\\\\n(2.0)^2 & 5 \\times 10^{-4} & 1\n\\end{pmatrix},\n\\quad\n\\mathbf{b} = \\begin{pmatrix}\n0.1625 \\\\ 0.3625 \\\\ 0.6125 \\\\ 2.6125 \\\\\n0.3500 \\\\ 0.5500 \\\\ 0.8000 \\\\ 2.8000 \\\\\n1.1000 \\\\ 1.3000 \\\\ 1.5500 \\\\ 3.5500\n\\end{pmatrix}\n$$\n\n最小二乘解 $\\mathbf{p}$ 最小化残差向量的欧几里得范数 $||\\mathbf{A} \\mathbf{p} - \\mathbf{b}||_2$。解可以通过求解正规方程组得到：\n$$\n(\\mathbf{A}^T \\mathbf{A}) \\mathbf{p} = \\mathbf{A}^T \\mathbf{b}\n$$\n求解这个线性方程组以得到 $\\mathbf{p}$，即可得出 $\\alpha$、$\\beta$ 和 $\\gamma$ 的值。使用给定数据进行计算，结果如下：\n$$\n\\alpha = 0.25 \\, \\frac{\\text{meV/atom/ns}}{\\text{fs}^2}\n$$\n$$\n\\beta = 5000 \\, \\frac{\\text{meV/atom/ns}}{\\text{eV}}\n$$\n$$\n\\gamma = 0.05 \\, \\text{meV/atom/ns}\n$$\n所提供的数据可以被这些参数完美描述，表明校准集中没有随机噪声。因此，拟合后的模型为：\n$$\nr(\\Delta t, \\tau) = 0.25 (\\Delta t)^2 + 5000 \\tau + 0.05\n$$\n\n在模型参数确定后，我们可以进行所需的计算。\n\n**1. 预测漂移率**\n\n我们计算三个测试对 $(\\Delta t, \\tau)$ 的漂移率 $r$：\n- 对于 $(\\Delta t=1.0\\,\\text{fs}, \\tau=1 \\times 10^{-5}\\,\\text{eV})$：\n$$\nr_1 = 0.25 (1.0)^2 + 5000 (1 \\times 10^{-5}) + 0.05 = 0.25 + 0.05 + 0.05 = 0.35 \\, \\text{meV/atom/ns}\n$$\n- 对于 $(\\Delta t=2.0\\,\\text{fs}, \\tau=1 \\times 10^{-5}\\,\\text{eV})$：\n$$\nr_2 = 0.25 (2.0)^2 + 5000 (1 \\times 10^{-5}) + 0.05 = 0.25(4) + 0.05 + 0.05 = 1.0 + 0.05 + 0.05 = 1.10 \\, \\text{meV/atom/ns}\n$$\n- 对于 $(\\Delta t=1.5\\,\\text{fs}, \\tau=1 \\times 10^{-4}\\,\\text{eV})$：\n$$\nr_3 = 0.25 (1.5)^2 + 5000 (1 \\times 10^{-4}) + 0.05 = 0.25(2.25) + 0.5 + 0.05 = 0.5625 + 0.5 + 0.05 = 1.1125 \\, \\text{meV/atom/ns}\n$$\n\n**2. 建议的最大时间步长**\n\n我们需要找到在给定容差 $\\tau$ 下，使漂移率不超过阈值 $r_{\\text{thr}} = 1.0\\,\\text{meV/atom/ns}$ 的最大时间步长 $\\Delta t_{\\max}$。我们从模型出发，求解 $\\Delta t$：\n$$\nr_{\\text{thr}} \\ge 0.25 (\\Delta t)^2 + 5000 \\tau + 0.05\n$$\n$$\n(\\Delta t)^2 \\le \\frac{r_{\\text{thr}} - 5000 \\tau - 0.05}{0.25}\n$$\n为了使 $\\Delta t$ 为实数，分子必须为非负。这给出了 $\\Delta t_{\\max}$ 的表达式：\n$$\n\\Delta t_{\\max}(\\tau) = \\begin{cases}\n\\sqrt{\\dfrac{1.0 - 5000 \\tau - 0.05}{0.25}} = \\sqrt{4 (0.95 - 5000 \\tau)} = 2\\sqrt{0.95 - 5000 \\tau}, & \\text{如果 } 0.95 - 5000 \\tau > 0 \\\\\n0, & \\text{否则}\n\\end{cases}\n$$\n条件 $0.95 - 5000 \\tau > 0$ 意味着 $\\tau  \\frac{0.95}{5000} = 1.9 \\times 10^{-4}$ eV。\n\n我们现在为给定的四个 $\\tau$ 值计算 $\\Delta t_{\\max}$：\n\n- 对于 $\\tau = 1 \\times 10^{-5}\\,\\text{eV}$：满足条件。\n$$\n\\Delta t_{\\max,1} = 2\\sqrt{0.95 - 5000(1 \\times 10^{-5})} = 2\\sqrt{0.95 - 0.05} = 2\\sqrt{0.90} \\approx 1.897367 \\, \\text{fs}\n$$\n- 对于 $\\tau = 5 \\times 10^{-5}\\,\\text{eV}$：满足条件。\n$$\n\\Delta t_{\\max,2} = 2\\sqrt{0.95 - 5000(5 \\times 10^{-5})} = 2\\sqrt{0.95 - 0.25} = 2\\sqrt{0.70} \\approx 1.673320 \\, \\text{fs}\n$$\n- 对于 $\\tau = 1 \\times 10^{-4}\\,\\text{eV}$：满足条件。\n$$\n\\Delta t_{\\max,3} = 2\\sqrt{0.95 - 5000(1 \\times 10^{-4})} = 2\\sqrt{0.95 - 0.50} = 2\\sqrt{0.45} \\approx 1.341641 \\, \\text{fs}\n$$\n- 对于 $\\tau = 5 \\times 10^{-4}\\,\\text{eV}$：$5000 \\tau = 2.5$，大于 $0.95$。分子为负。\n$$\n\\Delta t_{\\max,4} = 0 \\, \\text{fs}\n$$\n\n最终的结果集合，四舍五入到六位小数，是：$r_1=0.350000$，$r_2=1.100000$，$r_3=1.112500$，$\\Delta t_{\\max,1}=1.897367$，$\\Delta t_{\\max,2}=1.673320$，$\\Delta t_{\\max,3}=1.341641$，以及 $\\Delta t_{\\max,4}=0.000000$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of fitting an energy drift model for BOMD simulations\n    and using it for prediction and constraint derivation.\n    \"\"\"\n    \n    # --- Step 1: Fit the model parameters using least squares ---\n    \n    # Calibration data: (delta_t, tau, r)\n    # delta_t is in fs, tau in eV, r in meV/atom/ns.\n    calibration_data = [\n        (0.5, 1e-5, 0.1625),\n        (0.5, 5e-5, 0.3625),\n        (0.5, 1e-4, 0.6125),\n        (0.5, 5e-4, 2.6125),\n        (1.0, 1e-5, 0.3500),\n        (1.0, 5e-5, 0.5500),\n        (1.0, 1e-4, 0.8000),\n        (1.0, 5e-4, 2.8000),\n        (2.0, 1e-5, 1.1000),\n        (2.0, 5e-5, 1.3000),\n        (2.0, 1e-4, 1.5500),\n        (2.0, 5e-4, 3.5500),\n    ]\n\n    # The model is r = alpha * (delta_t)^2 + beta * tau + gamma\n    # This is a linear model in the parameters (alpha, beta, gamma).\n    # We set up the linear system A * p = b, where p = [alpha, beta, gamma].\n    \n    num_points = len(calibration_data)\n    A = np.zeros((num_points, 3))\n    b = np.zeros(num_points)\n    \n    for i, (dt, tau, r) in enumerate(calibration_data):\n        A[i, 0] = dt**2\n        A[i, 1] = tau\n        A[i, 2] = 1\n        b[i] = r\n        \n    # Solve the least squares problem A*p = b for p\n    params, _, _, _ = np.linalg.lstsq(A, b, rcond=None)\n    alpha, beta, gamma = params\n\n    # --- Step 2: Compute predicted drift rates for test cases ---\n    \n    test_rates_inputs = [\n        (1.0, 1e-5),  # (delta_t, tau)\n        (2.0, 1e-5),\n        (1.5, 1e-4),\n    ]\n    \n    predicted_rates = []\n    for dt, tau in test_rates_inputs:\n        rate = alpha * dt**2 + beta * tau + gamma\n        predicted_rates.append(rate)\n\n    # --- Step 3: Compute recommended max time step ---\n\n    r_thr = 1.0  # meV/atom/ns\n    \n    test_dtmax_inputs = [\n        1e-5,  # tau in eV\n        5e-5,\n        1e-4,\n        5e-4,\n    ]\n    \n    recommended_dtmax = []\n    for tau in test_dtmax_inputs:\n        # dt_max = sqrt((r_thr - beta*tau - gamma) / alpha)\n        numerator = r_thr - beta * tau - gamma\n        if numerator  0:\n            dt_max = np.sqrt(numerator / alpha)\n        else:\n            dt_max = 0.0\n        recommended_dtmax.append(dt_max)\n        \n    # Combine all results\n    all_results = predicted_rates + recommended_dtmax\n    \n    # Format the output as specified\n    formatted_results = [f\"{res:.6f}\" for res in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从头算分子动力学的一个核心目标是从原子尺度的轨迹中计算出宏观物理性质。扩散系数 $D$ 是一个关键的输运性质，它描述了粒子在流体中的迁移能力。本练习  将指导您如何应用爱因斯坦关系式，从均方位移 (MSD) 数据中计算扩散系数。更重要的是，本练习引入了现代模拟实践中的一个关键概念：由于周期性边界条件导致的有限尺寸效应，并演示了如何使用 Yeh-Hummer 校正来获得与真实无限大体系更具可比性的结果。",
            "id": "2448227",
            "problem": "给定一组人工合成但具有物理基础的轨迹摘要数据，这些数据代表单个锂离子 $\\mathrm{Li}^+$ 在液态水中的运动，其获取方式与从头算分子动力学（Ab Initio Molecular Dynamics, AIMD）模拟所得一致。该运动是在边长为 $L$ 的立方模拟晶胞中，在周期性边界条件下的三维空间运动。目标是基于第一性原理，根据均方位移的长时间行为来估计热力学（无限系统）极限下的扩散系数，并量化周期性边界条件下由流体动力学相互作用引起的有限尺寸效应。\n\n定义和常数：\n- 三维扩散系数 $D$ 通过爱因斯坦关系式定义：$D = \\lim_{t \\to \\infty} \\frac{1}{6}\\frac{\\mathrm{d}}{\\mathrm{d}t}\\langle \\Delta r(t)^2 \\rangle$，其中 $\\langle \\Delta r(t)^2 \\rangle$ 是均方位移（mean squared displacement, MSD）。\n- 对于边长为 $L$ 的有限周期性立方晶胞，Yeh–Hummer 流体动力学有限尺寸校正将有限系统扩散系数 $D_L$ 与无限系统扩散系数 $D_{\\infty}$ 关联起来，其关系式为 $D_{\\infty} = D_L + \\frac{k_{\\mathrm{B}} T \\,\\xi}{6\\pi \\eta L}$，其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是绝对温度，$\\eta$ 是剪切粘度，对于立方晶格 $\\xi \\approx 2.837297$。\n- 使用 $k_{\\mathrm{B}} = 1.380649\\times 10^{-23}\\ \\mathrm{J\\,K^{-1}}$ 和 $\\xi = 2.837297$。\n- 单位：时间数组 $t$ 以皮秒（ps）为单位，均方位移值 $\\langle \\Delta r^2 \\rangle$ 以平方纳米（$\\mathrm{nm}^2$）为单位，盒子长度 $L$ 以纳米（nm）为单位，粘度 $\\eta$ 以帕斯卡-秒（$\\mathrm{Pa\\,s}$）为单位，温度 $T$ 以开尔文（K）为单位。您的程序必须以平方米/秒（$\\mathrm{m}^2\\,\\mathrm{s}^{-1}$）为单位输出 $D_{\\infty}$。不涉及角度。不涉及百分比。\n- 对于每种情况，必须根据爱因斯坦关系式的推论，通过在指定的拟合区间 $[t_{\\min}, t_{\\max}]$ 内对 $\\langle \\Delta r^2 \\rangle$ 与 $t$ 的线性函数进行最佳拟合，从其斜率中获得 $D_L$。单位换算必须精确执行：$1\\ \\mathrm{nm}^2 / \\mathrm{ps} = 10^{-6}\\ \\mathrm{m}^2 / \\mathrm{s}$。\n\n编写一个程序，对于下述每个测试用例，通过线性拟合计算 $D_L$，然后使用 Yeh–Hummer 校正计算 $D_{\\infty}$。报告最终的 $D_{\\infty}$ 值，单位为 $\\mathrm{m}^2\\,\\mathrm{s}^{-1}$，并四舍五入至六位有效数字。\n\n测试套件（每个用例相互独立）：\n\n案例 1：\n- $T = 300\\ \\mathrm{K}$，$\\eta = 0.00089\\ \\mathrm{Pa\\,s}$，$L = 1.5\\ \\mathrm{nm}$。\n- $t\\ \\mathrm{(ps)} = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]$。\n- $\\langle \\Delta r^2 \\rangle\\ \\mathrm{(nm^2)} = [0.0, 0.0072, 0.0144, 0.0216, 0.0288, 0.0360, 0.0432, 0.0504, 0.0576, 0.0648, 0.0720]$。\n- 拟合区间：$t_{\\min} = 0\\ \\mathrm{ps}$，$t_{\\max} = 10\\ \\mathrm{ps}$。\n\n案例 2：\n- $T = 300\\ \\mathrm{K}$，$\\eta = 0.00089\\ \\mathrm{Pa\\,s}$，$L = 1.0\\ \\mathrm{nm}$。\n- $t\\ \\mathrm{(ps)} = [0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0]$。\n- $\\langle \\Delta r^2 \\rangle\\ \\mathrm{(nm^2)} = [0.0, 0.0036, 0.0072, 0.0108, 0.0144, 0.0180, 0.0216]$。\n- 拟合区间：$t_{\\min} = 0.0\\ \\mathrm{ps}$，$t_{\\max} = 3.0\\ \\mathrm{ps}$。\n\n案例 3：\n- $T = 300\\ \\mathrm{K}$，$\\eta = 0.00089\\ \\mathrm{Pa\\,s}$，$L = 6.0\\ \\mathrm{nm}$。\n- $t\\ \\mathrm{(ps)} = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]$。\n- $\\langle \\Delta r^2 \\rangle\\ \\mathrm{(nm^2)} = [0.0, 0.0072, 0.0144, 0.0216, 0.0288, 0.0360, 0.0432, 0.0504, 0.0576, 0.0648, 0.0720]$。\n- 拟合区间：$t_{\\min} = 0\\ \\mathrm{ps}$，$t_{\\max} = 10\\ \\mathrm{ps}$。\n\n案例 4：\n- $T = 320\\ \\mathrm{K}$，$\\eta = 0.00065\\ \\mathrm{Pa\\,s}$，$L = 2.0\\ \\mathrm{nm}$。\n- $t\\ \\mathrm{(ps)} = [0.0, 2.0, 4.0, 6.0, 8.0]$。\n- $\\langle \\Delta r^2 \\rangle\\ \\mathrm{(nm^2)} = [0.0, 0.0096, 0.0192, 0.0288, 0.0384]$。\n- 拟合区间：$t_{\\min} = 0.0\\ \\mathrm{ps}$，$t_{\\max} = 8.0\\ \\mathrm{ps}$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含案例 1 到 4 的 $D_{\\infty}$ 值的逗号分隔列表，按顺序排列，用方括号括起来，每个数字四舍五入到六位有效数字，例如 $[a,b,c,d]$，其中 $a$、$b$、$c$ 和 $d$ 是以 $\\mathrm{m}^2\\,\\mathrm{s}^{-1}$ 为单位的浮点数。",
            "solution": "我们从第一性原理开始。对于三维空间中的布朗运动，扩散系数 $D$ 由爱因斯坦关系式定义，\n$$\nD \\equiv \\lim_{t \\to \\infty} \\frac{1}{6}\\frac{\\mathrm{d}}{\\mathrm{d}t}\\langle \\Delta r(t)^2 \\rangle,\n$$\n其中 $\\langle \\Delta r(t)^2 \\rangle$ 是粒子的均方位移 (MSD)。在实践中，在一个时间区间内，如果 MSD 与 $t$呈线性关系（扩散区），则 MSD 可以建模为线性函数，\n$$\n\\langle \\Delta r(t)^2 \\rangle \\approx s\\, t + b,\n$$\n其中斜率为 $s$，截距为 $b$。那么有限系统扩散系数 $D_L$ 为\n$$\nD_L = \\frac{s}{6}.\n$$\n由于给定的时间 $t$ 以皮秒为单位，MSD 值以平方纳米为单位，因此计算出的 $s/6$ 的 $D_L$ 将具有 $\\mathrm{nm}^2/\\mathrm{ps}$ 的单位。将 $D_L$ 转换为 $\\mathrm{m}^2\\,\\mathrm{s}^{-1}$ 的精确单位换算为\n$$\n1\\ \\frac{\\mathrm{nm}^2}{\\mathrm{ps}} = 10^{-6}\\ \\frac{\\mathrm{m}^2}{\\mathrm{s}},\n$$\n因此\n$$\nD_L\\ \\big[\\mathrm{m}^2\\,\\mathrm{s}^{-1}\\big] = \\frac{s}{6} \\times 10^{-6}.\n$$\n\n在边长为 $L$ 的立方晶胞的周期性边界条件下，流体动力学相互作用会导致有限尺寸偏差。Yeh–Hummer 校正给出了有限系统扩散系数 $D_L$ 和无限系统系数 $D_{\\infty}$ 之间的一阶关系，\n$$\nD_{\\infty} = D_L + \\frac{k_{\\mathrm{B}} T \\,\\xi}{6\\pi \\eta L},\n$$\n其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是温度，$\\eta$ 是剪切粘度，对于立方周期性边界条件，$\\xi \\approx 2.837297$。在此公式中，$L$ 必须以米为单位，$\\eta$ 以 $\\mathrm{Pa\\,s}$ 为单位，$T$ 以 $\\mathrm{K}$ 为单位，$k_{\\mathrm{B}}$ 以 $\\mathrm{J\\,K^{-1}}$ 为单位，从而得到以 $\\mathrm{m}^2\\,\\mathrm{s}^{-1}$ 为单位的校正项。\n\n根据这些原理为每个案例推导的算法步骤：\n1. 选择指定拟合区间 $[t_{\\min}, t_{\\max}]$ 内时间 $t$ 对应的数据点。\n2. 对 $\\langle \\Delta r^2 \\rangle$ 与 $t$ 进行最小二乘线性拟合，以获得单位为 $\\mathrm{nm}^2/\\mathrm{ps}$ 的斜率 $s$。\n3. 使用 $D_L = (s/6)\\times 10^{-6}$ 计算以 $\\mathrm{m}^2\\,\\mathrm{s}^{-1}$ 为单位的 $D_L$。\n4. 使用 $L_{\\mathrm{m}} = L \\times 10^{-9}$ 将盒子长度 $L$ 从 $\\mathrm{nm}$ 转换为 $\\mathrm{m}$。\n5. 计算 Yeh–Hummer 校正项，\n$$\n\\Delta D = \\frac{k_{\\mathrm{B}} T \\,\\xi}{6\\pi \\eta L_{\\mathrm{m}}}.\n$$\n6. 计算 $D_{\\infty} = D_L + \\Delta D$。\n7. 将 $D_{\\infty}$ 四舍五入到六位有效数字，并以 $\\mathrm{m}^2\\,\\mathrm{s}^{-1}$ 为单位报告。\n\n将此应用于测试套件：\n- 在案例 1、2 和 3 中，MSD 序列是完全线性的，斜率 $s = 0.0072\\ \\mathrm{nm}^2/\\mathrm{ps}$，对应 $D_L = (0.0072/6)\\times 10^{-6} = 1.2\\times 10^{-9}\\ \\mathrm{m}^2\\,\\mathrm{s}^{-1}$。由于 $L$ 值不同，有限尺寸校正也不同：较小的 $L$ 会增加校正值，较大的 $L$ 会减小校正值。具体来说，在固定的 $T$ 和 $\\eta$ 下，校正值与 $1/L$ 成比例。\n- 在案例 4 中，MSD 是线性的，斜率 $s = 0.0048\\ \\mathrm{nm}^2/\\mathrm{ps}$，校正前得到 $D_L = 0.8\\times 10^{-9}\\ \\mathrm{m}^2\\,\\mathrm{s}^{-1}$。根据公式，校正值随 $T$ 的增加而增加，随 $\\eta$ 和 $L$ 的增加而减小。\n\n程序将使用最小二乘法实现线性回归，应用精确的单位换算和常数 $k_{\\mathrm{B}} = 1.380649\\times 10^{-23}\\ \\mathrm{J\\,K^{-1}}$ 和 $\\xi = 2.837297$，并按照要求的格式，将四个校正后的扩散系数 $D_{\\infty}$ 作为单个列表打印在同一行。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_d_infinity(t_ps, msd_nm2, tmin_ps, tmax_ps, T_K, eta_Pa_s, L_nm):\n    # Select data within the fit interval [tmin_ps, tmax_ps]\n    t = np.array(t_ps, dtype=float)\n    msd = np.array(msd_nm2, dtype=float)\n    mask = (t = tmin_ps)  (t = tmax_ps)\n    t_fit = t[mask]\n    msd_fit = msd[mask]\n\n    # Linear least squares fit: msd = slope * t + intercept\n    # slope has units of nm^2/ps\n    slope, intercept = np.polyfit(t_fit, msd_fit, 1)\n\n    # Convert slope to D_L: D_L = (slope / 6) * 1e-6  [m^2/s]\n    D_L = (slope / 6.0) * 1e-6  # m^2/s\n\n    # Yeh–Hummer correction: D_inf = D_L + kB * T * xi / (6 * pi * eta * L)\n    kB = 1.380649e-23  # J/K\n    xi = 2.837297\n    pi = np.pi\n    L_m = L_nm * 1e-9  # convert nm to m\n\n    correction = kB * T_K * xi / (6.0 * pi * eta_Pa_s * L_m)  # m^2/s\n\n    D_inf = D_L + correction\n    return D_inf\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"T_K\": 300.0,\n            \"eta_Pa_s\": 0.00089,\n            \"L_nm\": 1.5,\n            \"t_ps\": [0,1,2,3,4,5,6,7,8,9,10],\n            \"msd_nm2\": [0.0,0.0072,0.0144,0.0216,0.0288,0.0360,0.0432,0.0504,0.0576,0.0648,0.0720],\n            \"tmin_ps\": 0.0,\n            \"tmax_ps\": 10.0\n        },\n        # Case 2\n        {\n            \"T_K\": 300.0,\n            \"eta_Pa_s\": 0.00089,\n            \"L_nm\": 1.0,\n            \"t_ps\": [0.0,0.5,1.0,1.5,2.0,2.5,3.0],\n            \"msd_nm2\": [0.0,0.0036,0.0072,0.0108,0.0144,0.0180,0.0216],\n            \"tmin_ps\": 0.0,\n            \"tmax_ps\": 3.0\n        },\n        # Case 3\n        {\n            \"T_K\": 300.0,\n            \"eta_Pa_s\": 0.00089,\n            \"L_nm\": 6.0,\n            \"t_ps\": [0,1,2,3,4,5,6,7,8,9,10],\n            \"msd_nm2\": [0.0,0.0072,0.0144,0.0216,0.0288,0.0360,0.0432,0.0504,0.0576,0.0648,0.0720],\n            \"tmin_ps\": 0.0,\n            \"tmax_ps\": 10.0\n        },\n        # Case 4\n        {\n            \"T_K\": 320.0,\n            \"eta_Pa_s\": 0.00065,\n            \"L_nm\": 2.0,\n            \"t_ps\": [0.0,2.0,4.0,6.0,8.0],\n            \"msd_nm2\": [0.0,0.0096,0.0192,0.0288,0.0384],\n            \"tmin_ps\": 0.0,\n            \"tmax_ps\": 8.0\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        D_inf = compute_d_infinity(\n            t_ps=case[\"t_ps\"],\n            msd_nm2=case[\"msd_nm2\"],\n            tmin_ps=case[\"tmin_ps\"],\n            tmax_ps=case[\"tmax_ps\"],\n            T_K=case[\"T_K\"],\n            eta_Pa_s=case[\"eta_Pa_s\"],\n            L_nm=case[\"L_nm\"]\n        )\n        results.append(D_inf)\n\n    # Round to six significant figures for output formatting\n    formatted = [f\"{val:.6g}\" for val in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted)}]\")\n\nsolve()\n```"
        }
    ]
}