{
    "hands_on_practices": [
        {
            "introduction": "In ab initio molecular dynamics, we often simulate systems at a constant temperature $T$ using a thermostat. This exercise connects this macroscopic control parameter to the microscopic world by exploring the fundamental relationship between temperature and atomic motion. By applying the equipartition theorem of classical statistical mechanics, you will derive and calculate the mean kinetic energy per atom, providing a crucial check on the thermal properties of any simulated system and reinforcing the physical meaning of temperature in the context of MD .",
            "id": "4236153",
            "problem": "You are given a scientifically realistic scenario in computational electrochemistry involving Ab Initio Molecular Dynamics (AIMD). In Born–Oppenheimer Ab Initio Molecular Dynamics (AIMD), the electrons are assumed to remain in the instantaneous ground state for the current nuclear positions, and the nuclei evolve according to classical Newtonian dynamics with forces obtained from the electronic ground-state energy surface. Consider a small aqueous sodium chloride system near a platinum $(111)$ slab. The task is to use first principles to determine the mean kinetic energy per atom during a canonical ensemble trajectory at a specified temperature and to reason about how the trajectory would be set up.\n\nStarting from fundamental laws and definitions only, derive the mean kinetic energy per atom in a classical canonical ensemble for nuclei evolving under the Born–Oppenheimer approximation at temperature $T$ with no holonomic constraints. The derivation must begin from the definitions of kinetic energy and the canonical ensemble and should connect to how velocities are distributed for classical nuclei at equilibrium. Then, implement a program that computes the mean kinetic energy per atom from a given set of temperatures, assuming a three-dimensional system in which each atom has three translational degrees of freedom and there are no constraints.\n\nFor context, a typical $10\\ \\mathrm{ps}$ Born–Oppenheimer trajectory at $T=300\\ \\mathrm{K}$ would use a time step of order $0.5$ to $1.0\\ \\mathrm{fs}$, yielding $10000$ to $20000$ steps, with forces obtained at each step from electronic structure calculations at fixed nuclear positions, and a thermostat to maintain the canonical ensemble. However, in this problem your program must only compute the mean kinetic energy per atom as a function of temperature, consistent with the canonical ensemble for classical nuclei.\n\nPhysical units requirement: Express the mean kinetic energy per atom in electronvolts. The program must output values in $\\mathrm{eV}$, rounded to six decimal places.\n\nAngle unit requirement: Not applicable, as no angles are involved.\n\nPercentages requirement: Not applicable.\n\nTest Suite:\n- Case 1 (happy path): $T=300\\ \\mathrm{K}$\n- Case 2 (boundary condition at absolute zero): $T=0\\ \\mathrm{K}$\n- Case 3 (high temperature edge case): $T=1000\\ \\mathrm{K}$\n- Case 4 (near-ambient temperature with higher precision): $T=298.15\\ \\mathrm{K}$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result1,result2,result3,result4]$), where each $result$ is the mean kinetic energy per atom in $\\mathrm{eV}$, rounded to six decimal places, corresponding respectively to the four test temperatures above.",
            "solution": "The problem asks for a first-principles derivation of the mean kinetic energy per atom for a system of classical nuclei in a canonical ensemble at temperature $T$, followed by a programmatic calculation for specific temperatures.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- **Theoretical Framework**: Born-Oppenheimer Ab Initio Molecular Dynamics (AIMD).\n- **Physical Model**: Nuclei evolve according to classical Newtonian dynamics. Electrons are in the ground state for fixed nuclear positions.\n- **Ensemble**: Canonical ensemble (NVT).\n- **System Properties**: Each atom has three translational degrees of freedom. There are no holonomic constraints.\n- **Task 1 (Derivation)**: Derive the mean kinetic energy per atom starting from the definitions of kinetic energy and the canonical ensemble.\n- **Task 2 (Calculation)**: Implement a program to compute the mean kinetic energy per atom for a given set of temperatures.\n- **Units**: The final result must be in electronvolts ($\\mathrm{eV}$).\n- **Rounding**: Numerical outputs must be rounded to six decimal places.\n- **Test Cases**:\n    - Case 1: $T = 300\\ \\mathrm{K}$\n    - Case 2: $T = 0\\ \\mathrm{K}$\n    - Case 3: $T = 1000\\ \\mathrm{K}$\n    - Case 4: $T = 298.15\\ \\mathrm{K}$\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, well-posed, and objective.\n1.  **Scientific Soundness**: The problem is built upon fundamental principles of classical statistical mechanics (canonical ensemble, equipartition theorem) and their application in computational chemistry (Born-Oppenheimer approximation). These are standard and correct assumptions for this type of problem.\n2.  **Well-Posedness**: The objective is clearly defined: derive a known physical quantity and then compute its value under specified conditions. The assumptions (classical nuclei, 3 degrees of freedom, no constraints) are sufficient to yield a unique, stable, and meaningful solution.\n3.  **Objectivity**: The problem is stated in precise, quantitative terms, free from ambiguity or subjective content. The context of AIMD is used to frame a question about fundamental statistical mechanics, which is a valid pedagogical approach.\n\n**Step 3: Verdict and Action**\nThe problem is deemed **valid**. A solution will be provided.\n\n### Derivation and Solution\n\nThe derivation proceeds from the fundamental definitions of classical statistical mechanics for a system of $N$ atoms in a canonical ensemble at temperature $T$.\n\n1.  **Hamiltonian and Kinetic Energy**: In the Born-Oppenheimer approximation, the potential energy of the nuclei, $U(\\mathbf{r}_1, ..., \\mathbf{r}_N)$, depends only on their positions $\\mathbf{r}_i$. The total classical Hamiltonian $H$ for the nuclear subsystem is the sum of the kinetic energy $K$ and the potential energy $U$:\n    $$H(\\mathbf{r}^N, \\mathbf{p}^N) = K(\\mathbf{p}^N) + U(\\mathbf{r}^N)$$\n    where $\\mathbf{r}^N = (\\mathbf{r}_1, ..., \\mathbf{r}_N)$ and $\\mathbf{p}^N = (\\mathbf{p}_1, ..., \\mathbf{p}_N)$ represent the set of all position and momentum vectors. The total kinetic energy $K$ is the sum of the kinetic energies of each of the $N$ atoms:\n    $$K = \\sum_{i=1}^{N} \\frac{\\mathbf{p}_i^2}{2m_i} = \\sum_{i=1}^{N} \\left( \\frac{p_{ix}^2}{2m_i} + \\frac{p_{iy}^2}{2m_i} + \\frac{p_{iz}^2}{2m_i} \\right)$$\n    Here, $m_i$ is the mass of the $i$-th atom, and $\\mathbf{p}_i = (p_{ix}, p_{iy}, p_{iz})$ is its momentum vector.\n\n2.  **Canonical Ensemble and Expectation Values**: In the canonical ensemble, the probability density of finding the system in a microstate with coordinates $(\\mathbf{r}^N, \\mathbf{p}^N)$ is given by:\n    $$\\rho(\\mathbf{r}^N, \\mathbf{p}^N) = \\frac{e^{-\\beta H(\\mathbf{r}^N, \\mathbf{p}^N)}}{Z}$$\n    where $\\beta = 1/(k_B T)$, $k_B$ is the Boltzmann constant, and $Z$ is the partition function, which normalizes the probability distribution:\n    $$Z = \\int d\\mathbf{r}^N d\\mathbf{p}^N \\, e^{-\\beta H(\\mathbf{r}^N, \\mathbf{p}^N)}$$\n    The average or expectation value of any observable quantity $A$ is given by:\n    $$\\langle A \\rangle = \\int d\\mathbf{r}^N d\\mathbf{p}^N \\, A(\\mathbf{r}^N, \\mathbf{p}^N) \\rho(\\mathbf{r}^N, \\mathbf{p}^N)$$\n\n3.  **Mean Kinetic Energy**: We seek the mean total kinetic energy, $\\langle K \\rangle$.\n    $$\\langle K \\rangle = \\frac{1}{Z} \\int d\\mathbf{r}^N d\\mathbf{p}^N \\, K(\\mathbf{p}^N) e^{-\\beta (K(\\mathbf{p}^N) + U(\\mathbf{r}^N))}$$\n    Since the Hamiltonian is separable into a momentum-dependent part $K(\\mathbf{p}^N)$ and a position-dependent part $U(\\mathbf{r}^N)$, the partition function $Z$ can be factored:\n    $$Z = \\left( \\int d\\mathbf{p}^N \\, e^{-\\beta K(\\mathbf{p}^N)} \\right) \\left( \\int d\\mathbf{r}^N \\, e^{-\\beta U(\\mathbf{r}^N)} \\right) = Z_p Z_r$$\n    Similarly, the integral for $\\langle K \\rangle$ separates:\n    $$\\langle K \\rangle = \\frac{1}{Z_p Z_r} \\left( \\int d\\mathbf{p}^N \\, K(\\mathbf{p}^N) e^{-\\beta K(\\mathbf{p}^N)} \\right) \\left( \\int d\\mathbf{r}^N \\, e^{-\\beta U(\\mathbf{r}^N)} \\right)$$\n    The positional integral $\\int d\\mathbf{r}^N \\, e^{-\\beta U(\\mathbf{r}^N)}$ is equal to $Z_r$, which cancels, leaving:\n    $$\\langle K \\rangle = \\frac{\\int d\\mathbf{p}^N \\, K(\\mathbf{p}^N) e^{-\\beta K(\\mathbf{p}^N)}}{\\int d\\mathbf{p}^N \\, e^{-\\beta K(\\mathbf{p}^N)}}$$\n    This shows that the mean kinetic energy is independent of the potential energy function $U(\\mathbf{r}^N)$.\n\n4.  **Equipartition Theorem**: The total kinetic energy is a sum of $3N$ independent quadratic terms (one for each momentum component $p_{ix}, p_{iy}, p_{iz}$ for each of the $N$ atoms). We can evaluate the average energy contribution from a single such term, for instance, $\\frac{p_{ix}^2}{2m_i}$.\n    $$\\left\\langle \\frac{p_{ix}^2}{2m_i} \\right\\rangle = \\frac{\\int_{-\\infty}^{\\infty} dp_{ix} \\, \\frac{p_{ix}^2}{2m_i} e^{-\\beta \\frac{p_{ix}^2}{2m_i}}}{\\int_{-\\infty}^{\\infty} dp_{ix} \\, e^{-\\beta \\frac{p_{ix}^2}{2m_i}}}$$\n    All other integrals over other momentum components cancel out between the numerator and the denominator. We use the standard Gaussian integrals:\n    $$\\int_{-\\infty}^{\\infty} e^{-ax^2} dx = \\sqrt{\\frac{\\pi}{a}}$$\n    $$\\int_{-\\infty}^{\\infty} x^2 e^{-ax^2} dx = -\\frac{d}{da} \\int_{-\\infty}^{\\infty} e^{-ax^2} dx = -\\frac{d}{da} \\sqrt{\\frac{\\pi}{a}} = \\frac{1}{2a}\\sqrt{\\frac{\\pi}{a}}$$\n    Letting $x = p_{ix}$ and $a = \\frac{\\beta}{2m_i}$:\n    - Denominator: $\\int_{-\\infty}^{\\infty} e^{-\\frac{\\beta}{2m_i} p_{ix}^2} dp_{ix} = \\sqrt{\\frac{2 \\pi m_i}{\\beta}}$\n    - Numerator: $\\int_{-\\infty}^{\\infty} \\frac{p_{ix}^2}{2m_i} e^{-\\frac{\\beta}{2m_i} p_{ix}^2} dp_{ix} = \\frac{1}{2m_i} \\left( \\frac{1}{2 \\frac{\\beta}{2m_i}}\\sqrt{\\frac{2 \\pi m_i}{\\beta}} \\right) = \\frac{1}{2\\beta} \\sqrt{\\frac{2 \\pi m_i}{\\beta}}$\n    Taking the ratio gives:\n    $$\\left\\langle \\frac{p_{ix}^2}{2m_i} \\right\\rangle = \\frac{\\frac{1}{2\\beta} \\sqrt{\\frac{2 \\pi m_i}{\\beta}}}{\\sqrt{\\frac{2 \\pi m_i}{\\beta}}} = \\frac{1}{2\\beta} = \\frac{1}{2} k_B T$$\n    This is the equipartition theorem: each quadratic degree of freedom in the Hamiltonian contributes an average energy of $\\frac{1}{2}k_B T$ to the system.\n\n5.  **Mean Kinetic Energy Per Atom**: The problem specifies that each atom has three translational degrees of freedom, and there are no constraints. The kinetic energy part of the Hamiltonian contains $3N$ such quadratic terms. Therefore, the total mean kinetic energy for the system of $N$ atoms is:\n    $$\\langle K_{total} \\rangle = \\sum_{i=1}^{N} \\left( \\left\\langle \\frac{p_{ix}^2}{2m_i} \\right\\rangle + \\left\\langle \\frac{p_{iy}^2}{2m_i} \\right\\rangle + \\left\\langle \\frac{p_{iz}^2}{2m_i} \\right\\rangle \\right) = 3N \\times \\left(\\frac{1}{2} k_B T\\right) = \\frac{3}{2} N k_B T$$\n    To find the mean kinetic energy per atom, $\\langle E_{kin, atom} \\rangle$, we divide the total mean kinetic energy by the number of atoms, $N$:\n    $$\\langle E_{kin, atom} \\rangle = \\frac{\\langle K_{total} \\rangle}{N} = \\frac{\\frac{3}{2} N k_B T}{N} = \\frac{3}{2} k_B T$$\n    This is the final derived expression. It is a universal result for any classical system in thermal equilibrium where the kinetic energy is quadratic in momenta and there are three unconstrained degrees of freedom per particle.\n\n6.  **Numerical Calculation**: To implement the calculation, we use the value of the Boltzmann constant in the required units of electronvolts per Kelvin ($\\mathrm{eV}/\\mathrm{K}$).\n    - $k_B \\approx 8.617333262 \\times 10^{-5}\\ \\mathrm{eV}/\\mathrm{K}$\n    - The formula is: $\\langle E_{kin, atom} \\rangle [\\mathrm{eV}] = \\frac{3}{2} \\times (8.617333262 \\times 10^{-5}\\ \\mathrm{eV}/\\mathrm{K}) \\times T[\\mathrm{K}]$\n\nThis formula is now implemented for the given test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the mean kinetic energy per atom for a classical system\n    in a canonical ensemble at various temperatures.\n    \"\"\"\n    \n    # The Boltzmann constant in electronvolts per Kelvin (eV/K).\n    # Source: CODATA 2018 value.\n    K_B_EV_PER_K = 8.617333262145e-5\n\n    # Define the test cases from the problem statement.\n    # Temperatures are in Kelvin (K).\n    test_cases = [\n        300.0,      # Case 1 (happy path)\n        0.0,        # Case 2 (boundary condition at absolute zero)\n        1000.0,     # Case 3 (high temperature edge case)\n        298.15      # Case 4 (near-ambient temperature with higher precision)\n    ]\n\n    results = []\n    for T in test_cases:\n        # According to the equipartition theorem for a classical system with\n        # 3 translational degrees of freedom per atom and no constraints,\n        # the mean kinetic energy per atom is (3/2) * k_B * T.\n        #\n        # Degrees of freedom (dof) = 3 (for x, y, z translation)\n        # Mean energy per dof = (1/2) * k_B * T\n        # Mean kinetic energy per atom = dof * (1/2) * k_B * T = (3/2) * k_B * T\n        \n        mean_kinetic_energy_per_atom = 1.5 * K_B_EV_PER_K * T\n        \n        # Round the result to six decimal places as required.\n        # We use a format string for robust formatting to ensure trailing zeros.\n        rounded_result = \"{:.6f}\".format(mean_kinetic_energy_per_atom)\n        results.append(rounded_result)\n\n    # Final print statement in the exact required format: [result1,result2,result3,result4]\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A critical decision in any molecular dynamics simulation is the choice of the integration time step, $\\Delta t$. This parameter must be small enough to resolve the fastest atomic motions, typically high-frequency vibrations, to ensure the numerical integration remains stable. This practice provides a tangible demonstration of this principle by modeling a fast vibration as a simple harmonic oscillator, allowing you to see firsthand how energy conservation fails and a simulation becomes unstable when $\\Delta t$ is too large relative to the vibrational period .",
            "id": "2448283",
            "problem": "Ab initio molecular dynamics (AIMD) follows classical nuclear motion on an electronic potential energy surface obtained from electronic structure theory. Consider a single nuclear degree of freedom that approximates the fastest vibrational mode of a molecule. Model this mode as a one-dimensional harmonic oscillator with mass $m$ and angular frequency $\\omega_{\\max}$ moving on the potential $V(x) = \\tfrac{1}{2} k x^2$ with $k = m \\omega_{\\max}^2$. Use reduced, dimensionless units in which $m = 1$, so that $k = \\omega_{\\max}^2$. The initial conditions are $x(0) = x_0$ and $v(0) = v_0$. Let the discrete total energy at step $n$ be\n$$\nE_n = \\tfrac{1}{2} v_n^2 + \\tfrac{1}{2} \\omega_{\\max}^2 x_n^2,\n$$\nand define the maximum relative energy drift over a trajectory of $N$ steps as\n$$\n\\delta_{\\max} = \\max_{0 \\le n \\le N} \\frac{\\lvert E_n - E_0 \\rvert}{E_0}.\n$$\nA trajectory is to be labeled “unstable” if $\\delta_{\\max} > \\eta$, and “stable” otherwise, where $\\eta$ is a given positive threshold. All quantities are dimensionless and require no physical units.\n\nTask: Write a complete, runnable program that, for each test case below, numerically integrates the motion for $N$ steps using a constant time step $\\Delta t$, computes $\\delta_{\\max}$, and outputs a boolean indicating whether the trajectory is unstable according to the definition above.\n\nYou must use the following test suite, where each case is a tuple $(\\omega_{\\max}, \\Delta t, N, x_0, v_0, \\eta)$:\n- Case $1$: $(\\omega_{\\max} = 1.0, \\Delta t = 0.5, N = 2000, x_0 = 1.0, v_0 = 0.0, \\eta = 0.02)$.\n- Case $2$: $(\\omega_{\\max} = 1.0, \\Delta t = 2.0, N = 1000, x_0 = 1.0, v_0 = 0.0, \\eta = 0.02)$.\n- Case $3$: $(\\omega_{\\max} = 1.0, \\Delta t = 2.1, N = 200, x_0 = 1.0, v_0 = 0.0, \\eta = 0.02)$.\n- Case $4$: $(\\omega_{\\max} = 3.0, \\Delta t = 0.8, N = 200, x_0 = 1.0, v_0 = 0.0, \\eta = 0.02)$.\n- Case $5$: $(\\omega_{\\max} = 3.0, \\Delta t = 0.2, N = 2000, x_0 = 1.0, v_0 = 0.0, \\eta = 0.02)$.\n\nFinal output format: Your program should produce a single line of output containing the boolean instability results for all test cases, as a comma-separated list enclosed in square brackets in the order of the cases above, for example, $[\\text{True},\\text{False},\\text{True}]$.",
            "solution": "The problem statement is first subjected to a critical validation.\n\nThe givens are as follows:\n- **System**: A one-dimensional harmonic oscillator modeling a single nuclear degree of freedom.\n- **Potential Energy**: $V(x) = \\tfrac{1}{2} k x^2$.\n- **Mass and Force Constant**: In reduced, dimensionless units, mass $m = 1$ and force constant $k = \\omega_{\\max}^2$.\n- **Equation of Motion**: From Newton's second law, $m\\ddot{x} = F(x)$, with $F(x) = -\\frac{dV}{dx} = -kx$. With $m=1$, this becomes $\\ddot{x} = -\\omega_{\\max}^2 x$.\n- **Initial Conditions**: $x(0) = x_0$ and $v(0) = v_0$.\n- **Discrete Total Energy**: At each time step $n$, the energy is $E_n = \\tfrac{1}{2} v_n^2 + \\tfrac{1}{2} \\omega_{\\max}^2 x_n^2$.\n- **Maximum Relative Energy Drift**: A measure of numerical error, defined as $\\delta_{\\max} = \\max_{0 \\le n \\le N} \\frac{\\lvert E_n - E_0 \\rvert}{E_0}$.\n- **Instability Criterion**: A trajectory is \"unstable\" if $\\delta_{\\max} > \\eta$, where $\\eta$ is a specified positive threshold.\n- **Task**: For several test cases, numerically integrate the system for $N$ steps using a time step $\\Delta t$ and determine if the resulting trajectory is unstable.\n\nThe validation verdict is that the problem, as stated, is ill-posed. It suffers from a critical omission: the numerical integration algorithm is not specified. The choice of integrator (e.g., Euler, Runge-Kutta, Verlet) is fundamental to the solution, as different algorithms produce different trajectories $(x_n, v_n)$ and, consequently, different energy drifts $\\delta_{\\max}$. For a problem in numerical physics, failing to specify the numerical method is a serious flaw (Violation of **Ill-Posed or Poorly Structured** criterion).\n\nHowever, the problem is situated within the context of *ab initio molecular dynamics* (AIMD). In this field, the **Velocity Verlet algorithm** is a standard and widely used method due to its time-reversibility, symplectic properties (conservation of phase space volume), and excellent long-term energy conservation for Hamiltonian systems. Furthermore, the provided test cases appear specifically designed to probe the well-known stability limit of the Velocity Verlet algorithm when applied to a harmonic oscillator, which is $\\omega_{\\max} \\Delta t \\le 2$. For values of $\\omega_{\\max} \\Delta t$ exceeding this limit, the algorithm becomes numerically unstable, and the energy diverges. This provides strong contextual evidence that the Velocity Verlet algorithm is the intended method. By making this professionally justified assumption, the problem becomes well-posed and solvable.\n\nWe thus proceed by employing the Velocity Verlet algorithm. The update equations for advancing the system from time step $n$ to $n+1$ are:\n1. Update position: $$x_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a_n (\\Delta t)^2$$\n2. Update velocity: $$v_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t$$\nwhere $\\Delta t$ is the time step, and $a_n$ is the acceleration at step $n$. For our harmonic oscillator, the acceleration is a function of position: $a(x) = -\\omega_{\\max}^2 x$. Therefore, $a_n = -\\omega_{\\max}^2 x_n$ and $a_{n+1} = -\\omega_{\\max}^2 x_{n+1}$.\n\nThe computational procedure for each test case is as follows:\n1. Initialize the system state with the given parameters: $(\\omega_{\\max}, \\Delta t, N, x_0, v_0, \\eta)$. Set $x_n = x_0$ and $v_n = v_0$.\n2. Calculate the initial energy, $E_0 = \\tfrac{1}{2} v_0^2 + \\tfrac{1}{2} \\omega_{\\max}^2 x_0^2$. As all test cases have non-zero initial potential energy, $E_0$ is non-zero, preventing division by zero in the drift calculation. Initialize the maximum relative drift, $\\delta_{\\max}$, to $0$.\n3. Enter a loop to perform $N$ integration steps. For each step from $n=0$ to $N-1$:\n    a. Calculate the acceleration at the current position: $a_n = -\\omega_{\\max}^2 x_n$.\n    b. Update the position to obtain $x_{n+1}$ using the first Verlet equation.\n    c. Calculate the new acceleration at the updated position: $a_{n+1} = -\\omega_{\\max}^2 x_{n+1}$.\n    d. Update the velocity to obtain $v_{n+1}$ using the second Verlet equation.\n    e. Compute the new total energy $E_{n+1} = \\tfrac{1}{2} v_{n+1}^2 + \\tfrac{1}{2} \\omega_{\\max}^2 x_{n+1}^2$.\n    f. Calculate the relative energy drift for this step, $\\frac{\\lvert E_{n+1} - E_0 \\rvert}{E_0}$.\n    g. Update $\\delta_{\\max}$ if the current drift is greater than the stored maximum.\n    h. Set the current state $(x_n, v_n)$ to the new state $(x_{n+1}, v_{n+1})$ for the next iteration.\n4. After the loop completes, compare the final $\\delta_{\\max}$ with the instability threshold $\\eta$. If $\\delta_{\\max} > \\eta$, the trajectory is classified as unstable (`True`); otherwise, it is stable (`False`).\n\nThis procedure is systematically applied to each test case to generate the required boolean results.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(omega_max, dt, N, x0, v0, eta):\n    \"\"\"\n    Numerically integrates a 1D harmonic oscillator using the Velocity Verlet\n    algorithm and determines if the trajectory is unstable based on energy drift.\n\n    Args:\n        omega_max (float): Angular frequency of the oscillator.\n        dt (float): Time step for integration.\n        N (int): Number of integration steps.\n        x0 (float): Initial position.\n        v0 (float): Initial velocity.\n        eta (float): Relative energy drift threshold for instability.\n\n    Returns:\n        bool: True if the trajectory is unstable, False otherwise.\n    \"\"\"\n    # Current state variables\n    x = x0\n    v = v0\n\n    # Constant for the potential, k = omega_max^2\n    k = omega_max**2\n\n    # Calculate initial energy E0\n    E0 = 0.5 * v**2 + 0.5 * k * x**2\n\n    # If the system starts at rest at the equilibrium position,\n    # it will not move, and the energy drift will be zero. It is stable.\n    # This also prevents division by zero if E0 is 0.\n    if E0 == 0:\n        return False\n\n    max_rel_drift = 0.0\n\n    # Initial acceleration\n    a = -k * x\n\n    # Simulation loop for N steps\n    for _ in range(N):\n        # Velocity Verlet integration\n        # 1. Update position\n        x_new = x + v * dt + 0.5 * a * dt**2\n\n        # 2. Calculate acceleration at the new position\n        a_new = -k * x_new\n\n        # 3. Update velocity\n        v_new = v + 0.5 * (a + a_new) * dt\n\n        # Update state for the next iteration\n        x, v, a = x_new, v_new, a_new\n\n        # Calculate the energy at the new step n\n        E_n = 0.5 * v**2 + 0.5 * k * x**2\n\n        # Calculate relative energy drift\n        rel_drift = np.abs(E_n - E0) / E0\n\n        # Update the maximum observed drift\n        if rel_drift > max_rel_drift:\n            max_rel_drift = rel_drift\n    \n    # Check for instability\n    is_unstable = max_rel_drift > eta\n    return is_unstable\n\ndef solve():\n    \"\"\"\n    Runs the simulation for all specified test cases and prints the results.\n    \"\"\"\n    # Test cases: (omega_max, dt, N, x0, v0, eta)\n    test_cases = [\n        (1.0, 0.5, 2000, 1.0, 0.0, 0.02),\n        (1.0, 2.0, 1000, 1.0, 0.0, 0.02),\n        (1.0, 2.1, 200, 1.0, 0.0, 0.02),\n        (3.0, 0.8, 200, 1.0, 0.0, 0.02),\n        (3.0, 0.2, 2000, 1.0, 0.0, 0.02),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Note: Python's `str(bool)` converts True to 'True' and False to 'False',\n    # which is different from the example's 'true'/'false'. The standard Python\n    # representation is used as it is unambiguous.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "For a reliable microcanonical (NVE) simulation, ensuring the conservation of total energy is paramount. In Born-Oppenheimer MD, systematic energy drift arises from two main numerical sources: the finite integration time step, $\\Delta t$, and the incomplete convergence of the electronic self-consistent field (SCF) calculation, controlled by tolerance $\\tau$. This advanced practice guides you through building a quantitative error model from simulated data, teaching you a powerful method for performing a convergence study to select parameters that minimize computational cost while achieving a target level of accuracy .",
            "id": "3728716",
            "problem": "Consider a Born-Oppenheimer Molecular Dynamics (BOMD) simulation in the microcanonical ensemble (constant number of particles, volume, and energy; NVE) for a high-entropy alloy composed of $128$ atoms. The total energy of the system should be conserved in an ideal continuous-time evolution under exact Self-Consistent Field (SCF) convergence and exact forces. In practice, two sources of systematic numerical error contribute to energy drift: the finite time step $\\Delta t$ of the integrator and the finite SCF convergence tolerance $\\tau$ of the electronic structure solver. For sufficiently small $\\Delta t$ and tight SCF tolerance, the energy drift rate per atom can be approximated by a model that is linear in the dominant small-error contributions. Assuming a velocity-Verlet integrator (which has a local truncation error of order $\\mathcal{O}((\\Delta t)^3)$ and a global energy error scaling as $\\mathcal{O}((\\Delta t)^2)$ for well-behaved forces) and a residual force error that scales approximately linearly with the SCF energy tolerance, adopt the following linearized drift-rate model:\n$$\nr(\\Delta t,\\tau) = \\alpha\\,(\\Delta t)^2 + \\beta\\,\\tau + \\gamma,\n$$\nwhere $r$ is the energy drift rate in meV/atom/ns, $\\Delta t$ is the time step in fs (femtoseconds), $\\tau$ is the SCF energy tolerance in eV (electronvolts), and $\\alpha$, $\\beta$, $\\gamma$ are parameters to be determined.\n\nYou are provided with calibration measurements of the energy drift rate $r$ for a set of $(\\Delta t,\\tau)$ pairs obtained from short NVE BOMD runs on the $128$-atom high-entropy alloy. All listed $r$ values are per atom in meV/atom/ns. Use these calibration data to fit the linear model parameters $\\alpha$, $\\beta$, and $\\gamma$ via least squares:\n- $(\\Delta t=0.5\\,\\text{fs}, \\tau=1\\times 10^{-5}\\,\\text{eV}) \\rightarrow r=0.1625$\n- $(\\Delta t=0.5\\,\\text{fs}, \\tau=5\\times 10^{-5}\\,\\text{eV}) \\rightarrow r=0.3625$\n- $(\\Delta t=0.5\\,\\text{fs}, \\tau=1\\times 10^{-4}\\,\\text{eV}) \\rightarrow r=0.6125$\n- $(\\Delta t=0.5\\,\\text{fs}, \\tau=5\\times 10^{-4}\\,\\text{eV}) \\rightarrow r=2.6125$\n- $(\\Delta t=1.0\\,\\text{fs}, \\tau=1\\times 10^{-5}\\,\\text{eV}) \\rightarrow r=0.3500$\n- $(\\Delta t=1.0\\,\\text{fs}, \\tau=5\\times 10^{-5}\\,\\text{eV}) \\rightarrow r=0.5500$\n- $(\\Delta t=1.0\\,\\text{fs}, \\tau=1\\times 10^{-4}\\,\\text{eV}) \\rightarrow r=0.8000$\n- $(\\Delta t=1.0\\,\\text{fs}, \\tau=5\\times 10^{-4}\\,\\text{eV}) \\rightarrow r=2.8000$\n- $(\\Delta t=2.0\\,\\text{fs}, \\tau=1\\times 10^{-5}\\,\\text{eV}) \\rightarrow r=1.1000$\n- $(\\Delta t=2.0\\,\\text{fs}, \\tau=5\\times 10^{-5}\\,\\text{eV}) \\rightarrow r=1.3000$\n- $(\\Delta t=2.0\\,\\text{fs}, \\tau=1\\times 10^{-4}\\,\\text{eV}) \\rightarrow r=1.5500$\n- $(\\Delta t=2.0\\,\\text{fs}, \\tau=5\\times 10^{-4}\\,\\text{eV}) \\rightarrow r=3.5500$\n\nAfter fitting $\\alpha$, $\\beta$, and $\\gamma$, quantify the energy drift for specified test $(\\Delta t,\\tau)$ pairs by evaluating $r(\\Delta t,\\tau)$. Furthermore, derive a recommendation for the maximum allowable time step $\\Delta t_{\\max}$ as a function of SCF tolerance $\\tau$ such that the drift rate remains below a target threshold $r_{\\text{thr}}=1\\,\\text{meV/atom/ns}$. Using the fitted model, this recommendation must satisfy:\n$$\n\\Delta t_{\\max}(\\tau) = \n\\begin{cases}\n\\sqrt{\\frac{r_{\\text{thr}} - \\beta\\,\\tau - \\gamma}{\\alpha}}  \\text{if } r_{\\text{thr}} - \\beta\\,\\tau - \\gamma > 0 \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\nwith $\\Delta t_{\\max}$ expressed in fs.\n\nYour program must perform the following steps:\n1. Fit the parameters $\\alpha$, $\\beta$, and $\\gamma$ using the calibration dataset above.\n2. Compute the predicted drift rates $r(\\Delta t,\\tau)$ for the following test pairs:\n   - $\\Delta t=1.0\\,\\text{fs}$, $\\tau=1\\times 10^{-5}\\,\\text{eV}$,\n   - $\\Delta t=2.0\\,\\text{fs}$, $\\tau=1\\times 10^{-5}\\,\\text{eV}$,\n   - $\\Delta t=1.5\\,\\text{fs}$, $\\tau=1\\times 10^{-4}\\,\\text{eV}$.\n   Report each $r$ in meV/atom/ns.\n3. Compute the recommended $\\Delta t_{\\max}$ for the following SCF tolerances to keep the drift below $r_{\\text{thr}}=1\\,\\text{meV/atom/ns}$:\n   - $\\tau=1\\times 10^{-5}\\,\\text{eV}$,\n   - $\\tau=5\\times 10^{-5}\\,\\text{eV}$,\n   - $\\tau=1\\times 10^{-4}\\,\\text{eV}$,\n   - $\\tau=5\\times 10^{-4}\\,\\text{eV}$.\n   Report each $\\Delta t_{\\max}$ in fs.\n\nAll numerical answers must be floats rounded to six decimal places. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order: the three predicted drift rates followed by the four recommended maximum time steps, i.e., $[r_{1},r_{2},r_{3},\\Delta t_{\\max,1},\\Delta t_{\\max,2},\\Delta t_{\\max,3},\\Delta t_{\\max,4}]$.",
            "solution": "The problem requires us to determine the parameters of a linear model for energy drift in a Born-Oppenheimer Molecular Dynamics (BOMD) simulation and then use this model for prediction and to establish operational constraints. The analysis proceeds in two main stages: first, fitting the model parameters using the method of linear least squares, and second, applying the fitted model to answer the specific questions posed.\n\nThe proposed model for the energy drift rate per atom, $r$, is given by:\n$$\nr(\\Delta t, \\tau) = \\alpha (\\Delta t)^2 + \\beta \\tau + \\gamma\n$$\nwhere $\\Delta t$ is the integration time step in femtoseconds (fs), $\\tau$ is the Self-Consistent Field (SCF) energy convergence tolerance in electronvolts (eV), and $r$ is the drift rate in meV/atom/ns. The parameters to be determined are $\\alpha$, $\\beta$, and $\\gamma$. This model is linear with respect to the parameters. The term $(\\Delta t)^2$ is physically motivated by the global energy error scaling of the velocity-Verlet integrator, and the linear dependence on $\\tau$ is a reasonable first-order approximation for the influence of incomplete SCF convergence on atomic forces.\n\nWe are given $12$ calibration data points of the form $((\\Delta t)_i, \\tau_i, r_i)$, for $i=1, \\dots, 12$. To find the best-fit parameters $\\alpha$, $\\beta$, and $\\gamma$, we employ the method of linear least squares. This method minimizes the sum of the squared differences between the observed drift rates $r_i$ and the rates predicted by the model.\n\nLet us define a parameter vector $\\mathbf{p}$ and a feature vector $\\mathbf{x}_i$ for each data point:\n$$\n\\mathbf{p} = \\begin{pmatrix} \\alpha \\\\ \\beta \\\\ \\gamma \\end{pmatrix}, \\quad \\mathbf{x}_i = \\begin{pmatrix} (\\Delta t_i)^2 \\\\ \\tau_i \\\\ 1 \\end{pmatrix}\n$$\nThe model can then be expressed as $r_i \\approx \\mathbf{x}_i^T \\mathbf{p}$. We can assemble all $12$ equations into a single matrix equation:\n$$\n\\mathbf{A} \\mathbf{p} = \\mathbf{b}\n$$\nwhere $\\mathbf{A}$ is the $12 \\times 3$ design matrix whose rows are the feature vectors $\\mathbf{x}_i^T$, and $\\mathbf{b}$ is the $12 \\times 1$ vector of observed drift rates $r_i$.\n\n$$\n\\mathbf{A} = \\begin{pmatrix}\n(\\Delta t_1)^2  \\tau_1  1 \\\\\n(\\Delta t_2)^2  \\tau_2  1 \\\\\n\\vdots  \\vdots  \\vdots \\\\\n(\\Delta t_{12})^2  \\tau_{12}  1\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n(0.5)^2  1 \\times 10^{-5}  1 \\\\\n(0.5)^2  5 \\times 10^{-5}  1 \\\\\n(0.5)^2  1 \\times 10^{-4}  1 \\\\\n(0.5)^2  5 \\times 10^{-4}  1 \\\\\n(1.0)^2  1 \\times 10^{-5}  1 \\\\\n(1.0)^2  5 \\times 10^{-5}  1 \\\\\n(1.0)^2  1 \\times 10^{-4}  1 \\\\\n(1.0)^2  5 \\times 10^{-4}  1 \\\\\n(2.0)^2  1 \\times 10^{-5}  1 \\\\\n(2.0)^2  5 \\times 10^{-5}  1 \\\\\n(2.0)^2  1 \\times 10^{-4}  1 \\\\\n(2.0)^2  5 \\times 10^{-4}  1\n\\end{pmatrix},\n\\quad\n\\mathbf{b} = \\begin{pmatrix}\n0.1625 \\\\ 0.3625 \\\\ 0.6125 \\\\ 2.6125 \\\\\n0.3500 \\\\ 0.5500 \\\\ 0.8000 \\\\ 2.8000 \\\\\n1.1000 \\\\ 1.3000 \\\\ 1.5500 \\\\ 3.5500\n\\end{pmatrix}\n$$\n\nThe least squares solution $\\mathbf{p}$ minimizes the Euclidean norm of the residual vector, $||\\mathbf{A} \\mathbf{p} - \\mathbf{b}||_2$. The solution is found by solving the normal equations:\n$$\n(\\mathbf{A}^T \\mathbf{A}) \\mathbf{p} = \\mathbf{A}^T \\mathbf{b}\n$$\nSolving this system of linear equations for $\\mathbf{p}$ yields the values for $\\alpha$, $\\beta$, and $\\gamma$. Performing this calculation with the given data results in:\n$$\n\\alpha = 0.25 \\, \\frac{\\text{meV/atom/ns}}{\\text{fs}^2}\n$$\n$$\n\\beta = 5000 \\, \\frac{\\text{meV/atom/ns}}{\\text{eV}}\n$$\n$$\n\\gamma = 0.05 \\, \\text{meV/atom/ns}\n$$\nThe data provided are perfectly described by these parameters, indicating no random noise in the calibration set. The fitted model is thus:\n$$\nr(\\Delta t, \\tau) = 0.25 (\\Delta t)^2 + 5000 \\tau + 0.05\n$$\n\nWith the model parameterized, we can proceed to the required calculations.\n\n**1. Predicted Drift Rates**\n\nWe compute the drift rate $r$ for three test pairs $(\\Delta t, \\tau)$:\n- For $(\\Delta t=1.0\\,\\text{fs}, \\tau=1 \\times 10^{-5}\\,\\text{eV})$:\n$$\nr_1 = 0.25 (1.0)^2 + 5000 (1 \\times 10^{-5}) + 0.05 = 0.25 + 0.05 + 0.05 = 0.35 \\, \\text{meV/atom/ns}\n$$\n- For $(\\Delta t=2.0\\,\\text{fs}, \\tau=1 \\times 10^{-5}\\,\\text{eV})$:\n$$\nr_2 = 0.25 (2.0)^2 + 5000 (1 \\times 10^{-5}) + 0.05 = 0.25(4) + 0.05 + 0.05 = 1.0 + 0.05 + 0.05 = 1.10 \\, \\text{meV/atom/ns}\n$$\n- For $(\\Delta t=1.5\\,\\text{fs}, \\tau=1 \\times 10^{-4}\\,\\text{eV})$:\n$$\nr_3 = 0.25 (1.5)^2 + 5000 (1 \\times 10^{-4}) + 0.05 = 0.25(2.25) + 0.5 + 0.05 = 0.5625 + 0.5 + 0.05 = 1.1125 \\, \\text{meV/atom/ns}\n$$\n\n**2. Recommended Maximum Time Step**\n\nWe need to find the maximum time step $\\Delta t_{\\max}$ for a given tolerance $\\tau$ such that the drift rate does not exceed a threshold $r_{\\text{thr}} = 1.0\\,\\text{meV/atom/ns}$. We start from the model and solve for $\\Delta t$:\n$$\nr_{\\text{thr}} \\ge 0.25 (\\Delta t)^2 + 5000 \\tau + 0.05\n$$\n$$\n(\\Delta t)^2 \\le \\frac{r_{\\text{thr}} - 5000 \\tau - 0.05}{0.25}\n$$\nFor $\\Delta t$ to be real, the numerator must be non-negative. This gives the expression for $\\Delta t_{\\max}$:\n$$\n\\Delta t_{\\max}(\\tau) = \\begin{cases}\n\\sqrt{\\frac{1.0 - 5000 \\tau - 0.05}{0.25}} = \\sqrt{4 (0.95 - 5000 \\tau)} = 2\\sqrt{0.95 - 5000 \\tau}  \\text{if } 0.95 - 5000 \\tau > 0 \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\nThe condition $0.95 - 5000 \\tau > 0$ implies $\\tau  \\frac{0.95}{5000} = 1.9 \\times 10^{-4}$ eV.\n\nWe now compute $\\Delta t_{\\max}$ for the four given values of $\\tau$:\n\n- For $\\tau = 1 \\times 10^{-5}\\,\\text{eV}$: The condition is met.\n$$\n\\Delta t_{\\max,1} = 2\\sqrt{0.95 - 5000(1 \\times 10^{-5})} = 2\\sqrt{0.95 - 0.05} = 2\\sqrt{0.90} \\approx 1.897367 \\, \\text{fs}\n$$\n- For $\\tau = 5 \\times 10^{-5}\\,\\text{eV}$: The condition is met.\n$$\n\\Delta t_{\\max,2} = 2\\sqrt{0.95 - 5000(5 \\times 10^{-5})} = 2\\sqrt{0.95 - 0.25} = 2\\sqrt{0.70} \\approx 1.673320 \\, \\text{fs}\n$$\n- For $\\tau = 1 \\times 10^{-4}\\,\\text{eV}$: The condition is met.\n$$\n\\Delta t_{\\max,3} = 2\\sqrt{0.95 - 5000(1 \\times 10^{-4})} = 2\\sqrt{0.95 - 0.50} = 2\\sqrt{0.45} \\approx 1.341641 \\, \\text{fs}\n$$\n- For $\\tau = 5 \\times 10^{-4}\\,\\text{eV}$: $5000 \\tau = 2.5$, which is greater than $0.95$. The numerator is negative.\n$$\n\\Delta t_{\\max,4} = 0 \\, \\text{fs}\n$$\n\nThe final collection of results, rounded to six decimal places, is: $r_1=0.350000$, $r_2=1.100000$, $r_3=1.112500$, $\\Delta t_{\\max,1}=1.897367$, $\\Delta t_{\\max,2}=1.673320$, $\\Delta t_{\\max,3}=1.341641$, and $\\Delta t_{\\max,4}=0.000000$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of fitting an energy drift model for BOMD simulations\n    and using it for prediction and constraint derivation.\n    \"\"\"\n    \n    # --- Step 1: Fit the model parameters using least squares ---\n    \n    # Calibration data: (delta_t, tau, r)\n    # delta_t is in fs, tau in eV, r in meV/atom/ns.\n    calibration_data = [\n        (0.5, 1e-5, 0.1625),\n        (0.5, 5e-5, 0.3625),\n        (0.5, 1e-4, 0.6125),\n        (0.5, 5e-4, 2.6125),\n        (1.0, 1e-5, 0.3500),\n        (1.0, 5e-5, 0.5500),\n        (1.0, 1e-4, 0.8000),\n        (1.0, 5e-4, 2.8000),\n        (2.0, 1e-5, 1.1000),\n        (2.0, 5e-5, 1.3000),\n        (2.0, 1e-4, 1.5500),\n        (2.0, 5e-4, 3.5500),\n    ]\n\n    # The model is r = alpha * (delta_t)^2 + beta * tau + gamma\n    # This is a linear model in the parameters (alpha, beta, gamma).\n    # We set up the linear system A * p = b, where p = [alpha, beta, gamma].\n    \n    num_points = len(calibration_data)\n    A = np.zeros((num_points, 3))\n    b = np.zeros(num_points)\n    \n    for i, (dt, tau, r) in enumerate(calibration_data):\n        A[i, 0] = dt**2\n        A[i, 1] = tau\n        A[i, 2] = 1\n        b[i] = r\n        \n    # Solve the least squares problem A*p = b for p\n    params, _, _, _ = np.linalg.lstsq(A, b, rcond=None)\n    alpha, beta, gamma = params\n\n    # --- Step 2: Compute predicted drift rates for test cases ---\n    \n    test_rates_inputs = [\n        (1.0, 1e-5),  # (delta_t, tau)\n        (2.0, 1e-5),\n        (1.5, 1e-4),\n    ]\n    \n    predicted_rates = []\n    for dt, tau in test_rates_inputs:\n        rate = alpha * dt**2 + beta * tau + gamma\n        predicted_rates.append(rate)\n\n    # --- Step 3: Compute recommended max time step ---\n\n    r_thr = 1.0  # meV/atom/ns\n    \n    test_dtmax_inputs = [\n        1e-5,  # tau in eV\n        5e-5,\n        1e-4,\n        5e-4,\n    ]\n    \n    recommended_dtmax = []\n    for tau in test_dtmax_inputs:\n        # dt_max = sqrt((r_thr - beta*tau - gamma) / alpha)\n        numerator = r_thr - beta * tau - gamma\n        if numerator > 0:\n            dt_max = np.sqrt(numerator / alpha)\n        else:\n            dt_max = 0.0\n        recommended_dtmax.append(dt_max)\n        \n    # Combine all results\n    all_results = predicted_rates + recommended_dtmax\n    \n    # Format the output as specified\n    formatted_results = [f\"{res:.6f}\" for res in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}