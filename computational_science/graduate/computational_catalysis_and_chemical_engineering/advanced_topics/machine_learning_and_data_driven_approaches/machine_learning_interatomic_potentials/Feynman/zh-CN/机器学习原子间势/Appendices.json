{
    "hands_on_practices": [
        {
            "introduction": "机器学习原子间势（MLIPs）的核心在于如何将原子的局部化学环境转化为一组固定的数学描述符，即特征。这些特征必须满足物理对称性要求：即在原子坐标进行旋转、平移或对相同种类的原子进行置换（排列组合）时，其值保持不变。Behler-Parrinello对称函数正是实现这一目标的一种经典而强大的方法，它通过径向和角度函数组合，为每个原子创建了独特的“指纹”。这个练习将指导你为一个理想化的晶体结构手动计算一个径向对称函数，从而深入理解原子几何构型是如何被编码成MLIPs可以学习的数学语言。",
            "id": "90953",
            "problem": "在机器学习原子间势领域，Behler-Parrinello对称函数是构建稳健且精确的原子相互作用模型的基石。这些函数以一种在旋转、平移和同类原子置换下保持不变的方式描述了原子的局部化学环境。\n\n一种常见的径向对称函数，记为 $G^i(\\eta, R_s)$，它量化了中心原子 $i$ 周围邻近原子 $j$ 的径向分布。其定义如下：\n$$\nG^i(\\eta, R_s) = \\sum_{j \\neq i} e^{-\\eta (R_{ij} - R_s)^2} f_c(R_{ij})\n$$\n这里，$R_{ij}$ 是原子 $i$ 和 $j$ 之间的距离。参数 $\\eta$ 控制高斯函数的宽度，而 $R_s$ 定义了高斯函数中心的径向距离。求和项遍历了截断半径 $R_c$ 内的所有邻近原子 $j$。该截断由截断函数 $f_c(R_{ij})$ 实现，它使每个邻近原子的贡献随着其距离接近 $R_c$ 而平滑地趋于零。$f_c(R_{ij})$ 的一个常用形式是余弦截断函数：\n$$\nf_c(R_{ij}) = \\begin{cases}\n\\frac{1}{2} \\left( \\cos\\left(\\frac{\\pi R_{ij}}{R_c}\\right) + 1 \\right)  \\text{if } R_{ij} \\le R_c \\\\\n0  \\text{if } R_{ij} > R_c\n\\end{cases}\n$$\n\n考虑一个排列在理想简单立方（SC）晶格中的单个元素原子，其晶格常数为 $a$。对于位于该晶格原点的原子，推导径向对称函数 $G^i(\\eta, R_s)$ 值的解析表达式。使用截断半径 $R_c = \\frac{7}{4}a$。你的最终表达式应以晶格常数 $a$ 和对称函数参数 $\\eta$、$R_s$ 表示。",
            "solution": "1. 径向对称函数的定义为\n$$\nG^i(\\eta,R_s)=\\sum_{j\\neq i}e^{-\\eta\\bigl(R_{ij}-R_s\\bigr)^2}f_c(R_{ij})\\,,\n$$\n其中余弦截断函数为\n$$\nf_c(R)=\\begin{cases}\n\\frac{1}{2}\\bigl(\\cos(\\pi R/R_c)+1\\bigr)  \\text{if } R \\le R_c \\\\\n0  \\text{if } R > R_c\n\\end{cases}\n$$\n\n2. 在一个晶格常数为 $a$ 的简单立方晶格中，位于原点的原子 $i$ 的邻近原子位于 $(n_x,n_y,n_z)a$ 位置，其中 $n_x, n_y, n_z$ 是不全为零的整数。它们的距离为\n$$\nR_{n_x,n_y,n_z}=a\\sqrt{n_x^2+n_y^2+n_z^2}\\,.\n$$\n\n3. 截断半径为 $R_c=\\tfrac74a = 1.75a$。我们需要考虑所有距离 $R_{ij} \\le R_c$ 的邻居，这对应于整数坐标 $(n_x, n_y, n_z)$ 满足 $n_x^2+n_y^2+n_z^2 \\le (1.75)^2 \\approx 3.06$ 的壳层。因此，只有以下壳层有贡献：\n- $n_x^2+n_y^2+n_z^2=1$：6个原子，距离 $R=a$。\n- $n_x^2+n_y^2+n_z^2=2$：12个原子，距离 $R=a\\sqrt2$。\n- $n_x^2+n_y^2+n_z^2=3$：8个原子，距离 $R=a\\sqrt3$。\n\n4. 因此，对称函数是这三个壳层贡献的总和：\n$$\nG^i=\\;6\\,e^{-\\eta(a-R_s)^2}f_c(a)\n\\;+\\;12\\,e^{-\\eta(a\\sqrt2-R_s)^2}f_c(a\\sqrt2)\n\\;+\\;8\\,e^{-\\eta(a\\sqrt3-R_s)^2}f_c(a\\sqrt3).\n$$\n\n5. 计算每个壳层的截断因子 $f_c(R)$，其中 $R_c = \\frac{7}{4}a$：\n$$\nf_c(a)=\\frac{1}{2}\\left(\\cos\\left(\\frac{\\pi a}{\\frac{7}{4}a}\\right)+1\\right)\n=\\frac{1}{2}\\left(\\cos\\left(\\frac{4\\pi}{7}\\right)+1\\right),\n$$\n类似地\n$$\nf_c(a\\sqrt2)=\\frac{1}{2}\\left(\\cos\\left(\\frac{4\\pi\\sqrt2}{7}\\right)+1\\right),\\quad\nf_c(a\\sqrt3)=\\frac{1}{2}\\left(\\cos\\left(\\frac{4\\pi\\sqrt3}{7}\\right)+1\\right).\n$$\n\n6. 将所有项代入并合并常数因子 $\\frac{1}{2}$ 得到最终表达式：\n$$\nG^i\n=3\\,e^{-\\eta(a-R_s)^2}\\left(\\cos\\left(\\frac{4\\pi}{7}\\right)+1\\right)\n+6\\,e^{-\\eta(a\\sqrt2-R_s)^2}\\left(\\cos\\left(\\frac{4\\pi\\sqrt2}{7}\\right)+1\\right)\n+4\\,e^{-\\eta(a\\sqrt3-R_s)^2}\\left(\\cos\\left(\\frac{4\\pi\\sqrt3}{7}\\right)+1\\right).\n$$",
            "answer": "$$\\boxed{3\\,e^{-\\eta(a-R_s)^2}\\left(\\cos\\frac{4\\pi}{7}+1\\right)\n+6\\,e^{-\\eta(a\\sqrt2-R_s)^2}\\left(\\cos\\frac{4\\pi\\sqrt2}{7}+1\\right)\n+4\\,e^{-\\eta(a\\sqrt3-R_s)^2}\\left(\\cos\\frac{4\\pi\\sqrt3}{7}+1\\right)}$$"
        },
        {
            "introduction": "机器学习势函数的主要任务是预测给定原子构型的总势能。然而，在分子动力学等模拟中，我们更关心驱动原子运动的力。物理学基本原理告诉我们，作用在每个原子上的力是总势能相对于该原子位置坐标的负梯度（$ \\mathbf{F}_k = -\\nabla_{\\mathbf{R}_k} E_{\\mathrm{tot}} $）。这个练习通过一个简化的成对势能模型，让你亲手计算一个简单三原子体系的总能量和各个原子所受的力，从而加深对势能（标量场）和力（矢量场）之间微分关系的理解，这是所有原子尺度模拟的核心。",
            "id": "3822117",
            "problem": "考虑一个用于阐明简单的机器学习原子间势 (MLIP) 的一维三原子构型。单原子能量定义为\n$$\\varepsilon(\\mathcal{N}_i)=\\sum_{j\\in \\mathcal{N}_i} a \\exp(-b r_{ij}),$$\n其中 $r_{ij}$ 是原子 $i$ 和 $j$ 之间的欧几里得距离，$a$ 和 $b$ 是正常数，$\\mathcal{N}_i$ 是原子 $i$ 的邻居集，包含所有其他原子。系统的总能量是所有原子的单原子能量之和。原子 $k$ 上的经典力定义为 $\\mathbf{F}_k=-\\nabla_{\\mathbf{R}_k} E_{\\mathrm{tot}}$，其中 $\\mathbf{R}_k$ 是原子 $k$ 的位置，$E_{\\mathrm{tot}}$ 是总能量。\n\n取三个沿 $x$ 轴共线放置的原子，其位置分别为 $x_1=0\\,\\mathrm{\\AA}$、$x_2=2.0\\,\\mathrm{\\AA}$ 和 $x_3=3.5\\,\\mathrm{\\AA}$。使用参数 $a=0.25\\,\\mathrm{eV}$ 和 $b=1.0\\,\\mathrm{\\AA}^{-1}$。假设 $\\mathcal{N}_i=\\{j\\neq i\\}$（即所有其他原子都是邻居），并忽略任何边界条件。\n\n计算总能量 $E_{\\mathrm{tot}}$ 和每个原子沿 $x$ 方向的力 $F_{1x}$、$F_{2x}$ 和 $F_{3x}$。最终能量以电子伏特 (eV) 表示，力以电子伏特每埃 ($\\mathrm{eV}/\\mathrm{\\AA}$) 表示。将最终数值四舍五入到四位有效数字。",
            "solution": "该问题的目标是根据一个简化的成对势能模型，计算一个三原子体系的总能量和各个原子所受的力。\n\n1.  **计算总能量 $E_{\\mathrm{tot}}$**\n\n    根据题意，总能量是所有单原子能量之和：$E_{\\mathrm{tot}} = \\sum_i \\varepsilon_i$。\n    单原子能量定义为 $\\varepsilon_i = \\sum_{j \\neq i} a \\exp(-b r_{ij})$。\n    因此，总能量为：\n    $$E_{\\mathrm{tot}} = \\varepsilon_1 + \\varepsilon_2 + \\varepsilon_3 = (a e^{-b r_{12}} + a e^{-b r_{13}}) + (a e^{-b r_{21}} + a e^{-b r_{23}}) + (a e^{-b r_{31}} + a e^{-b r_{32}})$$\n    由于 $r_{ij} = r_{ji}$，上式可以简化为：\n    $$E_{\\mathrm{tot}} = 2a (\\exp(-b r_{12}) + \\exp(-b r_{13}) + \\exp(-b r_{23}))$$\n\n    首先，根据原子位置 $x_1=0\\,\\mathrm{\\AA}$、$x_2=2.0\\,\\mathrm{\\AA}$ 和 $x_3=3.5\\,\\mathrm{\\AA}$ 计算原子间距离：\n    $$r_{12} = |x_1 - x_2| = |0 - 2.0| = 2.0\\,\\mathrm{\\AA}$$\n    $$r_{13} = |x_1 - x_3| = |0 - 3.5| = 3.5\\,\\mathrm{\\AA}$$\n    $$r_{23} = |x_2 - x_3| = |2.0 - 3.5| = 1.5\\,\\mathrm{\\AA}$$\n\n    然后，代入参数 $a=0.25\\,\\mathrm{eV}$ 和 $b=1.0\\,\\mathrm{\\AA}^{-1}$：\n    $$E_{\\mathrm{tot}} = 2(0.25) (\\exp(-1.0 \\times 2.0) + \\exp(-1.0 \\times 3.5) + \\exp(-1.0 \\times 1.5))$$\n    $$E_{\\mathrm{tot}} = 0.5 (\\exp(-2.0) + \\exp(-3.5) + \\exp(-1.5))$$\n    $$E_{\\mathrm{tot}} \\approx 0.5 (0.135335 + 0.030197 + 0.223130) = 0.5 (0.388662) \\approx 0.194331\\,\\mathrm{eV}$$\n    四舍五入到四位有效数字，得到 $E_{\\mathrm{tot}} \\approx 0.1943\\,\\mathrm{eV}$。\n\n2.  **计算各原子所受的力 $F_{kx}$**\n\n    力是总势能对原子坐标的负梯度：$F_{kx} = -\\frac{\\partial E_{\\mathrm{tot}}}{\\partial x_k}$。\n    \n    对原子1的力 $F_{1x}$：\n    $$F_{1x} = -\\frac{\\partial}{\\partial x_1} \\left[ 2a (e^{-b|x_1-x_2|} + e^{-b|x_1-x_3|} + e^{-b|x_2-x_3|}) \\right]$$\n    $$F_{1x} = -2a \\left[ -b e^{-b r_{12}} \\mathrm{sgn}(x_1-x_2) - b e^{-b r_{13}} \\mathrm{sgn}(x_1-x_3) \\right]$$\n    $$F_{1x} = 2ab \\left[ \\mathrm{sgn}(x_1-x_2) e^{-b r_{12}} + \\mathrm{sgn}(x_1-x_3) e^{-b r_{13}} \\right]$$\n    由于 $x_1  x_2$ 且 $x_1  x_3$，$\\mathrm{sgn}(x_1-x_2)=-1$ 且 $\\mathrm{sgn}(x_1-x_3)=-1$。\n    $$F_{1x} = 2(0.25)(1.0) [-e^{-2.0} - e^{-3.5}] \\approx -0.5 (0.135335 + 0.030197) \\approx -0.082766\\,\\mathrm{eV}/\\mathrm{\\AA}$$\n    四舍五入到四位有效数字，得到 $F_{1x} \\approx -0.08277\\,\\mathrm{eV}/\\mathrm{\\AA}$。\n\n    对原子2的力 $F_{2x}$：\n    $$F_{2x} = 2ab \\left[ \\mathrm{sgn}(x_2-x_1) e^{-b r_{12}} + \\mathrm{sgn}(x_2-x_3) e^{-b r_{23}} \\right]$$\n    由于 $x_2 > x_1$ 且 $x_2  x_3$，$\\mathrm{sgn}(x_2-x_1)=1$ 且 $\\mathrm{sgn}(x_2-x_3)=-1$。\n    $$F_{2x} = 0.5 [e^{-2.0} - e^{-1.5}] \\approx 0.5 (0.135335 - 0.223130) \\approx -0.043898\\,\\mathrm{eV}/\\mathrm{\\AA}$$\n    四舍五入到四位有效数字，得到 $F_{2x} \\approx -0.04390\\,\\mathrm{eV}/\\mathrm{\\AA}$。\n\n    对原子3的力 $F_{3x}$：\n    $$F_{3x} = 2ab \\left[ \\mathrm{sgn}(x_3-x_1) e^{-b r_{13}} + \\mathrm{sgn}(x_3-x_2) e^{-b r_{23}} \\right]$$\n    由于 $x_3 > x_1$ 且 $x_3 > x_2$，$\\mathrm{sgn}(x_3-x_1)=1$ 且 $\\mathrm{sgn}(x_3-x_2)=1$。\n    $$F_{3x} = 0.5 [e^{-3.5} + e^{-1.5}] \\approx 0.5 (0.030197 + 0.223130) \\approx 0.126664\\,\\mathrm{eV}/\\mathrm{\\AA}$$\n    四舍五入到四位有效数字，得到 $F_{3x} \\approx 0.1267\\,\\mathrm{eV}/\\mathrm{\\AA}$。\n\n    **验证**：孤立体系的总力应为零。$F_{1x} + F_{2x} + F_{3x} \\approx -0.08277 - 0.04390 + 0.1267 = 0.00003 \\approx 0$。计算结果在舍入误差范围内满足总力为零的条件。\n\n    最终结果为：$E_{\\mathrm{tot}} \\approx 0.1943\\,\\mathrm{eV}$，$F_{1x} \\approx -0.08277\\,\\mathrm{eV}/\\mathrm{\\AA}$，$F_{2x} \\approx -0.04390\\,\\mathrm{eV}/\\mathrm{\\AA}$，$F_{3x} \\approx 0.1267\\,\\mathrm{eV}/\\mathrm{\\AA}$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.1943  -0.08277  -0.04390  0.1267\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "一个有效的机器学习原子间势不仅要能准确预测能量和力，还必须严格遵守基本的物理对称性原理，其中最核心的一条是置换不变性。该原理指出，系统中的全同粒子（例如，两个氢原子）是不可区分的，交换它们的标签不应改变系统的总能量。这个编程练习让你通过构建一个违反置换不变性的“坏”模型，并将其与物理上正确的模型进行对比，来亲身体验并量化这一原理被破坏时的严重后果。通过计算由于标签置换而产生的非物理“能量分裂”，你将深刻理解为何在构建MLIPs时，采用能够内禀保证对称性的模型架构是至关重要的。",
            "id": "3886545",
            "problem": "要求您在计算催化和化学工程领域，形式化并量化机器学习（ML）原子间势中违反相同原子置换不变性的后果。目标是构建一个场景，其中依赖于索引的特征导致人为的能量分裂，并根据有物理基础的参考来量化由此产生的预测误差。从一个具有物理动机的、置换不变的参考能量出发，并用它来分析一个特意设计的置换可变的代理模型。您的程序必须生成一行输出，其中包含一组测试构型的聚合数值结果，这些结果以无量纲的约化单位表示，并四舍五入到八位小数。\n\n基本原理：\n- 在经典力学和量子力学中，相同原子是不可区分的；总能量必须在原子标签的任何置换下保持不变。形式上，如果有 $N$ 个相同原子，且一个构型由成对距离集合 $\\{r_{ij}\\}$ 描述，那么对于对称群 $S_N$ 中的任何索引置换 $\\pi$，都必须满足 $E(\\{r_{ij}\\}) = E(\\{r_{\\pi(i)\\pi(j)}\\})$。\n- 一个用于非键相互作用的标准、经过充分检验的成对能量函数是 Lennard-Jones (LJ) 势。在约化单位制中，特征能量和长度尺度均设为1，一个构型的总能量计算如下\n$$\nE_{\\text{LJ}}(\\mathbf{R}) = \\sum_{1 \\leq i  j \\leq N} 4 \\varepsilon \\left[\\left(\\frac{\\sigma}{r_{ij}}\\right)^{12} - \\left(\\frac{\\sigma}{r_{ij}}\\right)^6\\right],\n$$\n其中 $r_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|$，$\\varepsilon$ 和 $\\sigma$ 分别是能量和长度尺度，并且对无序对求和确保了置换不变性。使用 $\\varepsilon = 1$ 和 $\\sigma = 1$ 的约化单位，从而使得能量和距离都是无量纲的。\n\n依赖索引的代理模型：\n- 定义依赖于局部距离的单原子描述符，\n$$\nd_i = \\sum_{\\substack{j=1 \\\\ j \\neq i}}^{N} \\exp\\left(-\\frac{r_{ij}}{\\sigma}\\right), \\quad e_i = \\sum_{\\substack{j=1 \\\\ j \\neq i}}^{N} \\frac{r_{ij}}{\\sigma}.\n$$\n- 通过使用依赖索引的权重，构建一个特意设计的置换可变的代理能量，\n$$\nE_{\\text{bad}}(\\mathbf{R}; \\mathbf{a}, \\mathbf{b}) = \\sum_{i=1}^{N} \\left[a_i \\, d_i + b_i \\, e_i\\right],\n$$\n其中 $\\mathbf{a} = (a_1, \\dots, a_N)$ 和 $\\mathbf{b} = (b_1, \\dots, b_N)$ 依赖于原子索引。在标签的置换 $\\pi \\in S_N$ 下，预测的能量变为：\n$$\nE_{\\text{bad}}^{(\\pi)}(\\mathbf{R}; \\mathbf{a}, \\mathbf{b}) = \\sum_{i=1}^{N} \\left[a_{\\pi(i)} \\, d_i + b_{\\pi(i)} \\, e_i\\right],\n$$\n如果 $d_i$ 和 $e_i$ 不全相等，那么对于相同的原子，这个能量可能会不同。\n- 作为对比，构建一个具有共享权重的置换不变的代理模型，\n$$\nE_{\\text{good}}(\\mathbf{R}; a, b) = \\sum_{i=1}^{N} \\left[a \\, d_i + b \\, e_i\\right].\n$$\n\n每个测试案例需要计算的量：\n- 在一组标签置换 $\\mathcal{P}$ 上的人为能量分裂幅度，\n$$\n\\Delta_{\\text{split}} = \\max_{\\pi \\in \\mathcal{P}} E_{\\text{bad}}^{(\\pi)}(\\mathbf{R}; \\mathbf{a}, \\mathbf{b}) - \\min_{\\pi \\in \\mathcal{P}} E_{\\text{bad}}^{(\\pi)}(\\mathbf{R}; \\mathbf{a}, \\mathbf{b}).\n$$\n- 相对于 LJ 能量，依赖索引的模型在 $\\mathcal{P}$ 上的最大绝对预测误差，\n$$\n\\text{Err}_{\\text{bad,max}} = \\max_{\\pi \\in \\mathcal{P}} \\left|E_{\\text{bad}}^{(\\pi)}(\\mathbf{R}; \\mathbf{a}, \\mathbf{b}) - E_{\\text{LJ}}(\\mathbf{R})\\right|.\n$$\n- 置换不变代理模型（共享权重）的绝对预测误差，\n$$\n\\text{Err}_{\\text{good}} = \\left|E_{\\text{good}}(\\mathbf{R}; a, b) - E_{\\text{LJ}}(\\mathbf{R})\\right|.\n$$\n\n角度单位无关紧要，因为只使用了距离。所有能量和距离都必须以 $\\varepsilon = 1$ 和 $\\sigma = 1$ 的无量纲约化单位表示。将所有输出四舍五入到八位小数。\n\n测试套件：\n- 使用以下四个构型案例。坐标以三维空间中的笛卡尔位置给出，单位为约化单位。使用 $\\varepsilon = 1$ 和 $\\sigma = 1$。对于每个案例，应用由恒等置换和逆序索引置换组成的置换集合 $\\mathcal{P}$。共享权重为 $a = 0.9$，$b = -0.15$。\n\n案例 1（非对称线性三原子，理想路径）：\n- $N = 3$,\n- 位置：$\\left(0.0, 0.0, 0.0\\right)$, $\\left(1.2, 0.0, 0.0\\right)$, $\\left(2.5, 0.0, 0.0\\right)$,\n- 依赖索引的权重：$\\mathbf{a} = (0.8, 1.4, 0.5)$, $\\mathbf{b} = (-0.3, 0.2, 0.1)$.\n\n案例 2（等边三角形，对称性边界条件）：\n- $N = 3$,\n- 边长：$L = 1.6$,\n- 位置：$\\left(0.0, 0.0, 0.0\\right)$, $\\left(L, 0.0, 0.0\\right)$, $\\left(\\frac{L}{2}, \\frac{\\sqrt{3}}{2} L, 0.0\\right)$,\n- 依赖索引的权重：$\\mathbf{a} = (0.8, 1.4, 0.5)$, $\\mathbf{b} = (-0.3, 0.2, 0.1)$.\n\n案例 3（双原子对，边界情况）：\n- $N = 2$,\n- 位置：$\\left(0.0, 0.0, 0.0\\right)$, $\\left(1.1, 0.0, 0.0\\right)$,\n- 依赖索引的权重：$\\mathbf{a} = (1.2, 0.7)$, $\\mathbf{b} = (-0.25, 0.05)$.\n\n案例 4（四个原子处于非对称矩形布局）：\n- $N = 4$,\n- 位置：$\\left(0.0, 0.0, 0.0\\right)$, $\\left(1.4, 0.0, 0.0\\right)$, $\\left(0.0, 2.2, 0.0\\right)$, $\\left(2.1, 2.3, 0.0\\right)$,\n- 依赖索引的权重：$\\mathbf{a} = (0.7, 1.1, 0.6, 1.5)$, $\\mathbf{b} = (-0.2, 0.25, -0.05, 0.3)$.\n\n要求的最终输出格式：\n- 对于每个案例，计算三元组 $[\\Delta_{\\text{split}}, \\text{Err}_{\\text{bad,max}}, \\text{Err}_{\\text{good}}]$ 作为浮点数。您的程序应生成单行输出，其中包含这些按案例排列的三元组列表，四舍五入到八位小数，格式为由方括号括起的、逗号分隔的 Python 风格列表，例如 $[[x_1,y_1,z_1],[x_2,y_2,z_2],\\dots]$。",
            "solution": "该问题的核心是量化一个未能遵循相同原子物理不可区分性的机器学习模型所引入的误差。这个原理，即置换不变性，规定了由 $N$ 个相同原子组成的系统的总能量必须保持不变，无论我们如何标记它们。\n\n本题的求解思路如下：\n\n1.  **计算参考能量 $E_{\\text{LJ}}$**\n    我们首先使用标准的、物理上正确的Lennard-Jones (LJ)势函数计算每个原子构型的“基准真相”能量。在指定的约化单位制（$\\varepsilon=1, \\sigma=1$）中，该能量由以下公式给出：\n    $$E_{\\text{LJ}}(\\mathbf{R}) = \\sum_{1 \\leq i  j \\leq N} 4 \\left(r_{ij}^{-12} - r_{ij}^{-6}\\right)$$\n    其中 $r_{ij}$ 是原子 $i$ 和 $j$ 之间的距离。该公式对所有唯一的原子对进行求和，其形式本身保证了置换不变性。\n\n2.  **构建原子描述符**\n    对于每个原子 $i$，我们计算两个描述符 $d_i$ 和 $e_i$ 来概括其局部原子环境：\n    $$d_i = \\sum_{j \\neq i} \\exp(-r_{ij}/\\sigma)$$\n    $$e_i = \\sum_{j \\neq i} r_{ij}/\\sigma$$\n    这些描述符是原子 $i$ 所在位置周围几何环境的属性，因此它们的值与分配给该原子的标签无关。\n\n3.  **评估两个代理模型**\n    - **“好”模型 $E_{\\text{good}}$**：该模型通过为所有原子的描述符分配相同的共享权重 $a$ 和 $b$ 来构建，确保了置换不变性。\n      $$E_{\\text{good}} = \\sum_{i=1}^{N} \\left(a \\, d_i + b \\, e_i\\right)$$\n      交换原子标签只会重新排列描述符向量 $\\{d_i\\}$ 和 $\\{e_i\\}$，但它们的总和不变，因此 $E_{\\text{good}}$ 也是不变的。\n    - **“坏”模型 $E_{\\text{bad}}$**：该模型被特意设计为违反置换不变性，它为每个原子分配了依赖其索引（标签）的权重 $a_i$ 和 $b_i$。\n      $$E_{\\text{bad}}^{(\\pi)} = \\sum_{i=1}^{N} \\left(a_{\\pi(i)} \\, d_i + b_{\\pi(i)} \\, e_i\\right)$$\n      这里，描述符 $d_i, e_i$ 依然与固定的几何位置相关，但施加于其上的权重则根据置换 $\\pi$ 发生改变。如果原子所处的几何环境不同（导致 $d_i, e_i$ 值不同），那么总能量就会随标签置换而改变，这不符合物理规律。\n\n4.  **计算度量指标**\n    对于每个测试案例，我们考虑两种置换：恒等置换（$\\pi_{\\text{id}}(i)=i$）和逆序置换（$\\pi_{\\text{rev}}(i)=N-1-i$）。我们计算这两个置换下的 $E_{\\text{bad}}$ 能量，并与 $E_{\\text{LJ}}$ 和 $E_{\\text{good}}$ 进行比较，从而得到三个核心度量指标：\n    -   **人为能量分裂 $\\Delta_{\\text{split}}$**：由标签置换引起的能量最大差异，直接量化了对称性破坏的程度。\n    -   **坏模型的最大误差 $\\text{Err}_{\\text{bad,max}}$**：有缺陷的模型在不同标签下的最坏预测误差。\n    -   **好模型的误差 $\\text{Err}_{\\text{good}}$**：置换不变模型的固有表示误差，它与对称性破坏无关。\n\n通过为每个案例计算三元组 $[\\Delta_{\\text{split}}, \\text{Err}_{\\text{bad,max}}, \\text{Err}_{\\text{good}}]$，我们系统地分析并量化了在计算模型中违反核心物理原理的后果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes metrics for permutation variance in ML interatomic potentials.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {   # Case 1\n            \"N\": 3,\n            \"positions\": np.array([\n                [0.0, 0.0, 0.0], \n                [1.2, 0.0, 0.0], \n                [2.5, 0.0, 0.0]\n            ]),\n            \"a_bad\": np.array([0.8, 1.4, 0.5]),\n            \"b_bad\": np.array([-0.3, 0.2, 0.1]),\n        },\n        {   # Case 2\n            \"N\": 3,\n            \"positions\": np.array([\n                [0.0, 0.0, 0.0], \n                [1.6, 0.0, 0.0], \n                [1.6/2, np.sqrt(3)/2 * 1.6, 0.0]\n            ]),\n            \"a_bad\": np.array([0.8, 1.4, 0.5]),\n            \"b_bad\": np.array([-0.3, 0.2, 0.1]),\n        },\n        {   # Case 3\n            \"N\": 2,\n            \"positions\": np.array([\n                [0.0, 0.0, 0.0], \n                [1.1, 0.0, 0.0]\n            ]),\n            \"a_bad\": np.array([1.2, 0.7]),\n            \"b_bad\": np.array([-0.25, 0.05]),\n        },\n        {   # Case 4\n            \"N\": 4,\n            \"positions\": np.array([\n                [0.0, 0.0, 0.0], \n                [1.4, 0.0, 0.0], \n                [0.0, 2.2, 0.0], \n                [2.1, 2.3, 0.0]\n            ]),\n            \"a_bad\": np.array([0.7, 1.1, 0.6, 1.5]),\n            \"b_bad\": np.array([-0.2, 0.25, -0.05, 0.3]),\n        },\n    ]\n\n    # Shared parameters\n    a_good = 0.9\n    b_good = -0.15\n    epsilon = 1.0\n    sigma = 1.0\n    \n    final_results = []\n\n    for case in test_cases:\n        N = case[\"N\"]\n        positions = case[\"positions\"]\n        a_bad = case[\"a_bad\"]\n        b_bad = case[\"b_bad\"]\n\n        # 1. Calculate the-distance matrix\n        dist_matrix = np.zeros((N, N))\n        if N > 1:\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dist = np.linalg.norm(positions[i] - positions[j])\n                    dist_matrix[i, j] = dist\n                    dist_matrix[j, i] = dist\n\n        # 2. Calculate Lennard-Jones reference energy (E_LJ)\n        e_lj = 0.0\n        if N > 1:\n            # np.triu_indices gives upper triangle indices to sum over pairs once\n            i_upper, j_upper = np.triu_indices(N, k=1)\n            r_ij = dist_matrix[i_upper, j_upper]\n            \n            # Filter out zero distances to prevent division by zero\n            r_ij_nonzero = r_ij[r_ij > 0]\n            if r_ij_nonzero.size > 0:\n                inv_r6 = (sigma / r_ij_nonzero)**6\n                inv_r12 = inv_r6**2\n                e_lj = np.sum(4 * epsilon * (inv_r12 - inv_r6))\n\n        # 3. Calculate per-atom descriptors\n        d = np.zeros(N)\n        e = np.zeros(N)\n        if N > 1:\n            for i in range(N):\n                # Distances from atom i to all other atoms j\n                r_i_others = dist_matrix[i, np.arange(N) != i]\n                d[i] = np.sum(np.exp(-r_i_others / sigma))\n                e[i] = np.sum(r_i_others / sigma)\n\n        # 4. Calculate E_bad for identity and reverse permutations\n        # Identity permutation\n        e_bad_id = np.sum(a_bad * d + b_bad * e)\n\n        # Reverse-index permutation\n        pi_rev_indices = np.arange(N - 1, -1, -1)\n        a_bad_rev = a_bad[pi_rev_indices]\n        b_bad_rev = b_bad[pi_rev_indices]\n        e_bad_rev = np.sum(a_bad_rev * d + b_bad_rev * e)\n        \n        e_bad_energies = np.array([e_bad_id, e_bad_rev])\n\n        # 5. Calculate artificial energy splitting (Delta_split)\n        delta_split = np.max(e_bad_energies) - np.min(e_bad_energies)\n\n        # 6. Calculate maximum absolute prediction error for E_bad\n        err_bad_max = np.max(np.abs(e_bad_energies - e_lj))\n\n        # 7. Calculate error for the permutation-invariant model (E_good)\n        e_good = a_good * np.sum(d) + b_good * np.sum(e)\n        err_good = np.abs(e_good - e_lj)\n\n        final_results.append([delta_split, err_bad_max, err_good])\n\n    # Format the final output string as specified\n    result_strings = []\n    for res in final_results:\n        # Create string for each sublist, e.g., \"[val1,val2,val3]\"\n        sublist_str = f\"[{res[0]:.8f},{res[1]:.8f},{res[2]:.8f}]\"\n        result_strings.append(sublist_str)\n    \n    # Join sublist strings and wrap in the final brackets\n    final_output_str = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}