{
    "hands_on_practices": [
        {
            "introduction": "在开始一项复杂的直接数值模拟 (DNS) 之前，至关重要的是要理解将主导流动的基本物理平衡。这项实践将引导您完成布辛涅斯克方程 (Boussinesq equations) 的无量纲化过程，这是一项将控制物理原理转化为一组关键无量纲数的基础技能。通过为一个假设的海洋斑块计算雷诺数 ($Re$)、普朗特数 ($Pr$)、弗劳德数 ($Fr$) 和罗斯贝数 ($Ro$)，您将学会预测和解释主导的动力学机制——这是设计一个有意义的数值实验的关键第一步 。",
            "id": "3789999",
            "problem": "在旋转、分层、不可压缩 Boussinesq 近似下，对海洋湍流进行直接数值模拟 (DNS)，其控制方程为\n$$\n\\frac{\\partial \\boldsymbol{u}}{\\partial t} + \\boldsymbol{u}\\cdot\\nabla \\boldsymbol{u} + f\\,\\hat{\\boldsymbol{z}}\\times \\boldsymbol{u} = -\\frac{1}{\\rho_{0}}\\nabla p' + b\\,\\hat{\\boldsymbol{z}} + \\nu \\nabla^{2}\\boldsymbol{u}, \\quad \\nabla\\cdot \\boldsymbol{u} = 0,\n$$\n$$\n\\frac{\\partial b}{\\partial t} + \\boldsymbol{u}\\cdot\\nabla b + N^{2} w = \\kappa_{T} \\nabla^{2} b,\n$$\n其中 $\\boldsymbol{u} = (u,v,w)$ 是速度，$p'$ 是运动学压力扰动，$b$ 是浮力，$\\rho_{0}$ 是恒定参考密度，$\\nu$ 是运动粘度，$\\kappa_{T}$ 是热扩散率，$f$ 是科里奥利参数，$N$ 是与稳定、均匀的背景分层相关的浮力频率。考虑一个均匀的湍流斑块，其特征为小尺度海洋内部运动，具有以下适用于 DNS 的代表性尺度和参数：\n- 速度尺度 $U = 0.05\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$，\n- 长度尺度 $L = 0.5\\,\\mathrm{m}$，\n- 运动粘度 $\\nu = 10^{-6}\\,\\mathrm{m}^{2}\\,\\mathrm{s}^{-1}$，\n- 热扩散率 $\\kappa_{T} = 1.4\\times 10^{-7}\\,\\mathrm{m}^{2}\\,\\mathrm{s}^{-1}$，\n- 浮力频率 $N = 10^{-2}\\,\\mathrm{s}^{-1}$，\n- 科里奥利参数 $f = 10^{-4}\\,\\mathrm{s}^{-1}$。\n\n从上述方程出发，使用特征尺度 $L$ 和 $U$ 对空间和时间进行无量纲化，并使用与背景分层一致的浮力尺度，推导出能够揭示雷诺数 $Re$、普朗特数 $Pr$、弗劳德数 $Fr$ 和罗斯贝数 $Ro$ 的无量纲形式，这些无量纲数控制着惯性、扩散、分层和旋转之间的平衡。然后，使用给定值计算 $Re$、$Pr$、$Fr$ 和 $Ro$。\n\n最后，根据这些无量纲数的量级，简要解读 DNS 在此配置下将解析的主导动力学机制，评论湍流、分层、旋转以及标量与动量扩散率对比的相对重要性。\n\n将您计算出的四个无量纲数按 $(Re, Pr, Fr, Ro)$ 的顺序表示为纯数（无量纲），并将每个数四舍五入至三位有效数字。在最终数值结果中，无需报告单位。",
            "solution": "在尝试解答之前，对问题进行验证。\n\n### 步骤1：提取已知条件\n给出了旋转、分层、不可压缩 Boussinesq 流体的控制方程：\n动量和连续性方程：\n$$\n\\frac{\\partial \\boldsymbol{u}}{\\partial t} + \\boldsymbol{u}\\cdot\\nabla \\boldsymbol{u} + f\\,\\hat{\\boldsymbol{z}}\\times \\boldsymbol{u} = -\\frac{1}{\\rho_{0}}\\nabla p' + b\\,\\hat{\\boldsymbol{z}} + \\nu \\nabla^{2}\\boldsymbol{u}, \\quad \\nabla\\cdot \\boldsymbol{u} = 0\n$$\n浮力输运方程：\n$$\n\\frac{\\partial b}{\\partial t} + \\boldsymbol{u}\\cdot\\nabla b + N^{2} w = \\kappa_{T} \\nabla^{2} b\n$$\n变量定义如下：$\\boldsymbol{u} = (u,v,w)$ (速度)，$p'$ (运动学压力扰动)，$b$ (浮力)，$\\rho_{0}$ (恒定参考密度)，$\\nu$ (运动粘度)，$\\kappa_{T}$ (热扩散率)，$f$ (科里奥利参数)，以及 $N$ (浮力频率)。\n\n给出了特征尺度和参数：\n- 速度尺度: $U = 0.05\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$\n- 长度尺度: $L = 0.5\\,\\mathrm{m}$\n- 运动粘度: $\\nu = 10^{-6}\\,\\mathrm{m}^{2}\\,\\mathrm{s}^{-1}$\n- 热扩散率: $\\kappa_{T} = 1.4\\times 10^{-7}\\,\\mathrm{m}^{2}\\,\\mathrm{s}^{-1}$\n- 浮力频率: $N = 10^{-2}\\,\\mathrm{s}^{-1}$\n- 科里奥利参数: $f = 10^{-4}\\,\\mathrm{s}^{-1}$\n\n### 步骤2：使用提取的已知条件进行验证\n这是一个地球物理流体动力学中的标准练习，具体涉及 Boussinesq 方程的无量纲化。\n- **科学依据：** 控制方程是标准的 Boussinesq 近似，这是海洋学和大气科学的基石。给定的参数值对于小尺度海洋过程是物理上现实的。\n- **适定性：** 问题陈述清晰，并提供了执行无量纲化和计算所需无量纲数的所有必要信息。任务定义明确。\n- **客观性：** 问题以精确的数学和物理语言表述，没有主观性或歧义。\n\n### 步骤3：结论和行动\n问题有效。将提供完整解答。\n\n### 无量纲方程的推导\n我们使用给定的特征尺度，引入用撇号（例如 $\\boldsymbol{x}'$）表示的无量纲变量。\n- 空间: $\\boldsymbol{x} = L\\boldsymbol{x}'$\n- 速度: $\\boldsymbol{u} = U\\boldsymbol{u}'$\n- 时间: 平流时间尺度为 $T = L/U$。因此，$t = (L/U)t'$。\n- 浮力: 选择浮力尺度 $B$ 以平衡浮力的平流项 $\\boldsymbol{u}\\cdot\\nabla b \\sim (U/L)B$ 与背景分层下由垂直速度产生的浮力项 $N^2 w \\sim N^2 U$。该平衡得出 $(U/L)B \\sim N^2 U$，因此我们设 $B = N^2 L$。于是，$b = (N^2 L)b'$。\n- 压力: 选择压力尺度以平衡压力梯度项和惯性项。$-\\frac{1}{\\rho_0}\\nabla p' \\sim \\boldsymbol{u}\\cdot\\nabla\\boldsymbol{u} \\Rightarrow \\frac{P'}{\\rho_0 L} \\sim \\frac{U^2}{L}$。我们定义一个运动学压力尺度 $P_k = U^2$。令无量纲压力扰动 $p'_{nd}$ 由 $p' = (\\rho_0 U^2)p'_{nd}$ 定义。\n\n微分算子变换如下：\n$$\n\\nabla = \\frac{1}{L}\\nabla', \\quad \\nabla^2 = \\frac{1}{L^2}\\nabla'^2, \\quad \\frac{\\partial}{\\partial t} = \\frac{U}{L}\\frac{\\partial}{\\partial t'}\n$$\n\n将这些代入动量方程：\n$$\n\\frac{U}{L}\\frac{\\partial (U\\boldsymbol{u}')}{\\partial t'} + (U\\boldsymbol{u}')\\cdot(\\frac{1}{L}\\nabla') (U\\boldsymbol{u}') + f\\,\\hat{\\boldsymbol{z}}\\times (U\\boldsymbol{u}') = -\\frac{1}{\\rho_{0}}\\frac{1}{L}\\nabla' (\\rho_0 U^2 p'_{nd}) + (N^2 L b')\\,\\hat{\\boldsymbol{z}} + \\nu \\frac{1}{L^2}\\nabla'^2 (U\\boldsymbol{u}')\n$$\n提出有量纲的尺度因子：\n$$\n\\left(\\frac{U^2}{L}\\right) \\frac{\\partial \\boldsymbol{u}'}{\\partial t'} + \\left(\\frac{U^2}{L}\\right) \\boldsymbol{u}'\\cdot\\nabla' \\boldsymbol{u}' + (fU)\\,\\hat{\\boldsymbol{z}}\\times \\boldsymbol{u}' = -\\left(\\frac{U^2}{L}\\right)\\nabla' p'_{nd} + (N^2 L)b'\\,\\hat{\\boldsymbol{z}} + \\left(\\frac{\\nu U}{L^2}\\right)\\nabla'^2 \\boldsymbol{u}'\n$$\n整个方程除以惯性加速度尺度 $U^2/L$：\n$$\n\\frac{\\partial \\boldsymbol{u}'}{\\partial t'} + \\boldsymbol{u}'\\cdot\\nabla' \\boldsymbol{u}' + \\frac{fU L}{U^2}\\,\\hat{\\boldsymbol{z}}\\times \\boldsymbol{u}' = -\\nabla' p'_{nd} + \\frac{N^2 L^2}{U^2} b'\\,\\hat{\\boldsymbol{z}} + \\frac{\\nu U L^2}{L^2 U^2} \\nabla'^2 \\boldsymbol{u}'\n$$\n为符号简洁，简化系数并去掉撇号，得到无量纲动量方程：\n$$\n\\frac{\\partial \\boldsymbol{u}}{\\partial t} + \\boldsymbol{u}\\cdot\\nabla \\boldsymbol{u} + \\left(\\frac{fL}{U}\\right)\\hat{\\boldsymbol{z}}\\times \\boldsymbol{u} = -\\nabla p' + \\left(\\frac{N^2 L^2}{U^2}\\right) b\\,\\hat{\\boldsymbol{z}} + \\left(\\frac{\\nu}{UL}\\right) \\nabla^{2}\\boldsymbol{u}\n$$\n由此，我们确定以下无量纲数：\n- 罗斯贝数: $Ro = \\frac{U}{fL}$。系数为 $1/Ro$。\n- 弗劳德数: $Fr = \\frac{U}{NL}$。系数为 $1/Fr^2$。\n- 雷诺数: $Re = \\frac{UL}{\\nu}$。系数为 $1/Re$。\n\n连续性方程 $\\nabla\\cdot\\boldsymbol{u}=0$ 变为 $(\\frac{1}{L}\\nabla')\\cdot(U\\boldsymbol{u}') = 0$，简化为 $\\nabla'\\cdot\\boldsymbol{u}'=0$。其形式不变。\n\n接下来，将无量纲变量代入浮力方程，其中 $w = Uw'$：\n$$\n\\frac{U}{L}\\frac{\\partial (N^2 L b')}{\\partial t'} + (U\\boldsymbol{u}')\\cdot(\\frac{1}{L}\\nabla')(N^2 L b') + N^2 (Uw') = \\kappa_{T} \\frac{1}{L^2}\\nabla'^2(N^2 L b')\n$$\n提出尺度因子：\n$$\n(U N^2) \\frac{\\partial b'}{\\partial t'} + (U N^2) \\boldsymbol{u}'\\cdot\\nabla'b' + (N^2 U)w' = \\left(\\frac{\\kappa_T N^2}{L}\\right) \\nabla'^2 b'\n$$\n除以平流/源项尺度 $N^2 U$：\n$$\n\\frac{\\partial b'}{\\partial t'} + \\boldsymbol{u}'\\cdot\\nabla'b' + w' = \\frac{\\kappa_T}{UL} \\nabla'^2 b'\n$$\n扩散项的系数是 $\\frac{\\kappa_T}{UL}$。我们可以用一个新的无量纲数来表示它。按照惯例，这与雷诺数和普朗特数有关。普朗特数定义为动量扩散率与热扩散率之比：\n- 普朗特数: $Pr = \\frac{\\nu}{\\kappa_T}$\n因此，该系数可以改写为：\n$$\n\\frac{\\kappa_T}{UL} = \\frac{\\nu}{UL} \\frac{\\kappa_T}{\\nu} = \\frac{1}{Re} \\frac{1}{Pr} = \\frac{1}{Re \\cdot Pr}\n$$\n去掉撇号，无量纲浮力方程为：\n$$\n\\frac{\\partial b}{\\partial t} + \\boldsymbol{u}\\cdot\\nabla b + w = \\frac{1}{Re \\cdot Pr} \\nabla^{2} b\n$$\n\n### 无量纲数的计算\n使用给定值：\n$U = 0.05\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$，$L = 0.5\\,\\mathrm{m}$，$\\nu = 10^{-6}\\,\\mathrm{m}^{2}\\,\\mathrm{s}^{-1}$，$\\kappa_{T} = 1.4\\times 10^{-7}\\,\\mathrm{m}^{2}\\,\\mathrm{s}^{-1}$，$N = 10^{-2}\\,\\mathrm{s}^{-1}$，$f = 10^{-4}\\,\\mathrm{s}^{-1}$。\n\n1.  **雷诺数 ($Re$)：** 惯性力与粘性力之比。\n    $$\n    Re = \\frac{UL}{\\nu} = \\frac{(0.05\\,\\mathrm{m}\\,\\mathrm{s}^{-1})(0.5\\,\\mathrm{m})}{10^{-6}\\,\\mathrm{m}^{2}\\,\\mathrm{s}^{-1}} = \\frac{0.025}{10^{-6}} = 25000\n    $$\n2.  **普朗特数 ($Pr$)：** 动量扩散率与热扩散率之比。\n    $$\n    Pr = \\frac{\\nu}{\\kappa_{T}} = \\frac{10^{-6}\\,\\mathrm{m}^{2}\\,\\mathrm{s}^{-1}}{1.4\\times 10^{-7}\\,\\mathrm{m}^{2}\\,\\mathrm{s}^{-1}} = \\frac{10}{1.4} \\approx 7.142857...\n    $$\n3.  **弗劳德数 ($Fr$)：** 惯性力与浮力之比。\n    $$\n    Fr = \\frac{U}{NL} = \\frac{0.05\\,\\mathrm{m}\\,\\mathrm{s}^{-1}}{(10^{-2}\\,\\mathrm{s}^{-1})(0.5\\,\\mathrm{m})} = \\frac{0.05}{0.005} = 10\n    $$\n4.  **罗斯贝数 ($Ro$)：** 惯性力与科里奥利力之比。\n    $$\n    Ro = \\frac{U}{fL} = \\frac{0.05\\,\\mathrm{m}\\,\\mathrm{s}^{-1}}{(10^{-4}\\,\\mathrm{s}^{-1})(0.5\\,\\mathrm{m})} = \\frac{0.05}{5\\times 10^{-5}} = 1000\n    $$\n\n四舍五入到三位有效数字，我们得到：\n- $Re = 2.50 \\times 10^4$\n- $Pr \\approx 7.14$\n- $Fr = 10.0$\n- $Ro = 1.00 \\times 10^3$\n\n### 动力学机制的解读\n- $Re = 2.50 \\times 10^4 \\gg 1$: 雷诺数非常大，表明惯性力远大于粘性力。这是湍流的决定性特征。DNS将解析一个混沌的、多尺度的湍流场。\n- $Fr = 10.0 \\gg 1$: 弗劳德数远大于1。由于动量方程中的浮力项与 $1/Fr^2$ 成比例，这意味着惯性力远强于浮力（分层）力。其动力学特征是弱分层湍流。虽然分层不是主导因素，但它仍然会影响流动，例如通过影响垂直运动并可能支持内重力波。\n- $Ro = 1.00 \\times 10^3 \\gg 1$: 罗斯贝数非常大。由于科里奥利项与 $1/Ro$ 成比例，这表明惯性力远强于科里奥利力。地球自转在这些尺度上对动力学的影响可以忽略不计。流动是强非地转的。\n- $Pr \\approx 7.14  1$: 普朗特数是水的典型值。由于 $Pr1$，动量比浮力（温度/盐度）扩散得更有效。这意味着浮力场中的最小变化尺度（Batchelor 尺度，$\\eta_B=\\eta_K / \\sqrt{Pr}$）将小于速度场中的最小尺度（Kolmogorov 尺度，$\\eta_K$）。这对 DNS 提出了显著的分辨率要求，因为网格必须足够精细，以解析标量场中的小尺度结构。\n\n总而言之，DNS 将模拟一个**弱分层、无旋转、高雷诺数**的湍流斑块。主导的动力学平衡是惯性力和压力梯度之间的平衡，这是经典湍流理论的特征。分层和旋转的影响是次要的，作为对湍流级串的弱扰动。模拟的主要挑战是解析从积分尺度 $L$ 到耗散尺度（特别是浮力场中的精细结构）的宽范围尺度。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 2.50 \\times 10^4  7.14  10.0  1.00 \\times 10^3 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "DNS 结果的有效性取决于底层数值代码的正确性。本练习介绍了制造解方法 (Method of Manufactured Solutions, MMS)，这是一种严格的代码验证技术。您将为拉普拉斯算子实现一个有限差分格式，并将其输出与一个已知的“制造”解析解进行比较，以精确量化数值误差并验证代码是否达到了其理论精度阶数，这是构建可靠模拟工具中不可或缺的一步 。",
            "id": "3790016",
            "problem": "您的任务是为 Boussinesq 近似下的海洋湍流直接数值模拟 (DNS) 执行验证、确认和误差量化。直接数值模拟 (DNS) 解析所有动力学相关的运动尺度，无需亚格子建模。本问题的目标是推导速度场和浮力场的误差范数，并在一个科学上连贯、自洽的数值实验中，提出并实现在空间网格从 $N=128$ 加密到 $N=256$ 及 $N=512$ 时的收敛性测试。\n\n考虑一个代表海洋垂直切片的二维周期性区域，坐标为 $(x,z)$，区域大小为 $L_x = 2\\pi$ 和 $L_z = 2\\pi$。所有量均为无量纲。在 Boussinesq 近似下，流动是不可压缩的。设一个人工构造的流函数 $\\psi(x,z)$ 通过矢量势公式定义一个不可压缩速度场：\n- 速度分量由 $u_x(x,z) = \\partial \\psi / \\partial z$ 和 $u_z(x,z) = -\\partial \\psi / \\partial x$ 给出。\n- 浮力场 $b(x,z)$ 是一个给定的光滑函数。\n\n人工构造的场定义如下：\n- $\\psi(x,z) = \\sin(k_x x)\\sin(k_z z)$，\n- $b(x,z) = \\cos(k_x x)\\cos(k_z z)$，\n其中 $k_x$ 和 $k_z$ 分别是 $x$ 和 $z$ 方向的波数。由于流函数的构造，所得到的速度分量自动满足不可压缩性。这些场在两个空间方向上都是周期性的。\n\n为了验证与 DNS 相关的空间离散化精度，请关注出现在 Boussinesq 动量和浮力方程中的扩散算子。连续拉普拉斯算子表示为 $\\nabla^2$。您的任务是：\n1. 在连续情况下，推导人工构造的速度分量 $u_x(x,z)$、$u_z(x,z)$ 和浮力场 $b(x,z)$ 的精确拉普拉斯算子。\n2. 在均匀周期性网格上，为 $u_x$、$u_z$ 和 $b$ 实现拉普拉斯算子的二阶中心有限差分近似，不使用任何谱方法。网格在每个方向上都是均匀的，有 $N$ 个点，网格间距为 $h_x = L_x/N$ 和 $h_z = L_z/N$，并且在两个方向上都有周期性边界条件。您必须使用一个具有空间二阶精度的纯局部模板，并通过环绕索引来强制周期性。\n3. 通过从离散拉普拉斯算子中减去精确拉普拉斯算子，计算 $u_x$、$u_z$ 和 $b$ 各自的逐点误差场。对于矢量速度误差，定义组合误差大小场 $e_u(x,z) = \\sqrt{e_{u_x}(x,z)^2 + e_{u_z}(x,z)^2}$，其中 $e_{u_x}$ 和 $e_{u_z}$ 是分量上的拉普拉斯误差。对于浮力，标量误差大小为 $e_b(x,z) = |e_b(x,z)|$。\n4. 在离散网格上为每个 $N$ 定义并计算速度场和浮力场的 $L_2$ 和 $L_\\infty$ 误差范数。在离散网格上使用以下范数定义：\n   - 速度的 $L_2$ 范数： $\\|e_u\\|_{2} = \\sqrt{\\frac{1}{N^2}\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} e_u(x_i,z_j)^2}$，\n   - 速度的 $L_\\infty$ 范数： $\\|e_u\\|_{\\infty} = \\max_{i,j} e_u(x_i,z_j)$，\n   - 浮力的 $L_2$ 范数： $\\|e_b\\|_{2} = \\sqrt{\\frac{1}{N^2}\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} e_b(x_i,z_j)^2}$，\n   - 浮力的 $L_\\infty$ 范数： $\\|e_b\\|_{\\infty} = \\max_{i,j} e_b(x_i,z_j)$。\n   所有量均为无量纲。角度以弧度为单位。不要使用百分号；任何分数报告都必须以小数或分数形式。\n5. 使用观测阶数 $p$ 的公式，量化并报告在网格从 $N=128$ 加密到 $N=256$ 以及从 $N=256$ 加密到 $N=512$ 时的观测收敛率：\n   - $p = \\frac{\\log(\\|e\\|_{N} / \\|e\\|_{2N})}{\\log(h_{N}/h_{2N})}$。\n   由于 $h_{N} = L_x/N$ 且 $h_{2N} = L_x/(2N)$，分母简化为 $\\log(2)$，但您必须显式计算它。为速度和浮力的 $L_2$ 和 $L_\\infty$ 范数分别报告观测阶数。\n6. 提出并实现一个测试套件，用于评估不同波数配置下的数值行为，以涵盖一般情况、各向异性和近奈奎斯特边界情况。使用以下波数对 $(k_x,k_z)$ 集合：\n   - 测试用例 1：$(k_x,k_z) = (4,4)$，\n   - 测试用例 2：$(k_x,k_z) = (16,8)$，\n   - 测试用例 3：$(k_x,k_z) = (32,1)$。\n   这些波数以弧度/单位长度表示，并且是无量纲的。要使用的网格尺寸为 $N \\in \\{128,256,512\\}$。\n\n您的程序必须为每个测试用例和每个 $N$ 计算速度场和浮力场的 $L_2$ 和 $L_\\infty$ 误差范数，以及在 $N=128\\to 256$ 和 $N=256\\to 512$ 转换中的观测收敛阶数 $p$。所有输出均表示为无量纲数。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。对于每个测试用例，按以下确切顺序附加值：\n- $N=128$ 时的 $\\|e_u\\|_{2}$，$N=256$ 时的 $\\|e_u\\|_{2}$，$N=512$ 时的 $\\|e_u\\|_{2}$，从 $128\\to 256$ 的 $\\|e_u\\|_{2}$ 的 $p$ 值，从 $256\\to 512$ 的 $\\|e_u\\|_{2}$ 的 $p$ 值，\n- $N=128$ 时的 $\\|e_u\\|_{\\infty}$，$N=256$ 时的 $\\|e_u\\|_{\\infty}$，$N=512$ 时的 $\\|e_u\\|_{\\infty}$，从 $128\\to 256$ 的 $\\|e_u\\|_{\\infty}$ 的 $p$ 值，从 $256\\to 512$ 的 $\\|e_u\\|_{\\infty}$ 的 $p$ 值，\n- $N=128$ 时的 $\\|e_b\\|_{2}$，$N=256$ 时的 $\\|e_b\\|_{2}$，$N=512$ 时的 $\\|e_b\\|_{2}$，从 $128\\to 256$ 的 $\\|e_b\\|_{2}$ 的 $p$ 值，从 $256\\to 512$ 的 $\\|e_b\\|_{2}$ 的 $p$ 值，\n- $N=128$ 时的 $\\|e_b\\|_{\\infty}$，$N=256$ 时的 $\\|e_b\\|_{\\infty}$，$N=512$ 时的 $\\|e_b\\|_{\\infty}$，从 $128\\to 256$ 的 $\\|e_b\\|_{\\infty}$ 的 $p$ 值，从 $256\\to 512$ 的 $\\|e_b\\|_{\\infty}$ 的 $p$ 值。\n\n最终输出必须按顺序汇总测试用例 1、测试用例 2 和测试用例 3 的结果，生成一个包含 60 个数字的单个扁平列表。程序必须是自包含的，不需要任何输入，并以指定格式精确生成一行输出。",
            "solution": "其基础是不可压缩分层流的 Boussinesq 近似，在此近似下，控制方程的有量纲形式为：\n$$\n\\frac{\\partial \\mathbf{u}}{\\partial t} + \\mathbf{u}\\cdot\\nabla\\mathbf{u} = -\\nabla p + \\nu \\nabla^2 \\mathbf{u} + b\\,\\hat{\\mathbf{z}},\\quad\n\\frac{\\partial b}{\\partial t} + \\mathbf{u}\\cdot\\nabla b = \\kappa \\nabla^2 b,\\quad\n\\nabla\\cdot\\mathbf{u} = 0,\n$$\n其中 $\\mathbf{u}$ 是速度矢量场，$p$ 是运动学压力，$\\nu$ 是运动粘度，$b$ 是浮力，$\\kappa$ 是浮力扩散率，$\\hat{\\mathbf{z}}$ 是垂直方向的单位矢量。在直接数值模拟 (DNS) 中，所有项都在计算网格上进行解析。DNS 验证的一个核心组成部分是微分算子（特别是 $\\nabla^2$）的空间离散化精度。\n\n为了验证离散拉普拉斯算子，我们采用人工解法 (MMS)。我们在一个二维周期性区域 $(x,z)\\in [0,2\\pi]\\times[0,2\\pi]$ 上构造光滑的周期场，单位为无量纲：\n- 定义流函数 $\\psi(x,z) = \\sin(k_x x)\\sin(k_z z)$。\n- 不可压缩速度分量为 $u_x = \\partial \\psi / \\partial z$ 和 $u_z = -\\partial \\psi / \\partial x$，这在二维情况下通过构造保证了 $\\partial u_x/\\partial x + \\partial u_z/\\partial z = 0$。\n- 定义浮力 $b(x,z) = \\cos(k_x x)\\cos(k_z z)$。\n\n对于这些三角函数场，我们通过解析方法推导其精确的拉普拉斯算子。首先观察到，对于正弦和余弦的乘积，拉普拉斯算子满足\n$$\n\\nabla^2 \\left[\\sin(k_x x)\\sin(k_z z)\\right] = -\\left(k_x^2 + k_z^2\\right)\\sin(k_x x)\\sin(k_z z),\n$$\n对于余弦乘积也类似。速度分量是 $\\psi$ 的空间导数，而对于光滑场，拉普拉斯算子与微分运算是可交换的。因此，\n$$\n\\nabla^2 u_x = \\nabla^2\\left(\\frac{\\partial \\psi}{\\partial z}\\right) = \\frac{\\partial}{\\partial z}\\left(\\nabla^2 \\psi\\right) = -\\left(k_x^2 + k_z^2\\right)\\frac{\\partial \\psi}{\\partial z} = -\\left(k_x^2 + k_z^2\\right)u_x,\n$$\n$$\n\\nabla^2 u_z = \\nabla^2\\left(-\\frac{\\partial \\psi}{\\partial x}\\right) = -\\frac{\\partial}{\\partial x}\\left(\\nabla^2 \\psi\\right) = -\\left(k_x^2 + k_z^2\\right)\\left(-\\frac{\\partial \\psi}{\\partial x}\\right) = -\\left(k_x^2 + k_z^2\\right)u_z,\n$$\n以及\n$$\n\\nabla^2 b = -\\left(k_x^2 + k_z^2\\right)b.\n$$\n因此，每个场的精确拉普拉斯算子就是 $-\\left(k_x^2 + k_z^2\\right)$ 乘以原始场。\n\n现在我们定义在一个均匀网格上的离散拉普拉斯算子，该网格在每个方向上有 $N$ 个点，网格间距为 $h_x = L_x/N$ 和 $h_z = L_z/N$，并具有周期性边界条件。标量场 $f(x,z)$ 在网格点 $(i,j)$ 处的拉普拉斯算子的二阶中心有限差分近似为\n$$\n\\left(\\nabla^2 f\\right)_{i,j} \\approx \\frac{f_{i+1,j} - 2 f_{i,j} + f_{i-1,j}}{h_x^2} + \\frac{f_{i,j+1} - 2 f_{i,j} + f_{i,j-1}}{h_z^2},\n$$\n其中索引使用周期性环绕，因此 $f_{-1,j} \\equiv f_{N-1,j}$，$f_{N,j} \\equiv f_{0,j}$，在 $z$ 方向上类似。对于光滑的 $f$，该格式在空间上具有二阶精度，意味着其截断误差的尺度为 $\\mathcal{O}(h_x^2 + h_z^2)$。\n\n通过比较数值和精确的拉普拉斯算子来定义离散误差场：\n- 对于速度分量，$e_{u_x} = \\left(\\nabla^2 u_x\\right)_{\\text{num}} - \\left(\\nabla^2 u_x\\right)_{\\text{exact}}$ 和 $e_{u_z} = \\left(\\nabla^2 u_z\\right)_{\\text{num}} - \\left(\\nabla^2 u_z\\right)_{\\text{exact}}$。将它们组合成一个矢量大小误差场 $e_u(x,z) = \\sqrt{e_{u_x}(x,z)^2 + e_{u_z}(x,z)^2}$。\n- 对于浮力，$e_b = \\left(\\nabla^2 b\\right)_{\\text{num}} - \\left(\\nabla^2 b\\right)_{\\text{exact}}$，其大小为 $|e_b|$。\n\n在网格上定义离散的 $L_2$ 和 $L_\\infty$ 范数：\n$$\n\\|e_u\\|_{2} = \\sqrt{\\frac{1}{N^2}\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} e_u(x_i,z_j)^2},\\quad\n\\|e_u\\|_{\\infty} = \\max_{i,j} e_u(x_i,z_j),\n$$\n以及\n$$\n\\|e_b\\|_{2} = \\sqrt{\\frac{1}{N^2}\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} e_b(x_i,z_j)^2},\\quad\n\\|e_b\\|_{\\infty} = \\max_{i,j} e_b(x_i,z_j).\n$$\n\n对于网格加密下的收敛性测试，使用观测精度阶数的公式：\n$$\np = \\frac{\\log\\left(\\|e\\|_{N} / \\|e\\|_{2N}\\right)}{\\log\\left(h_{N} / h_{2N}\\right)} = \\frac{\\log\\left(\\|e\\|_{N} / \\|e\\|_{2N}\\right)}{\\log(2)},\n$$\n因为 $h_{N} = L_x/N$ 且 $h_{2N} = L_x/(2N)$，在 $z$ 方向上也类似。对于光滑场上的二阶有限差分模板，我们预期对于 $L_2$ 和 $L_\\infty$ 范数，$p \\approx 2$。\n\n算法设计：\n1. 对于每个测试用例 $(k_x,k_z)$ 和每个 $N\\in\\{128,256,512\\}$，生成均匀网格 $x_i = i h_x$ 和 $z_j = j h_z$，其中 $i,j\\in\\{0,\\dots,N-1\\}$ 且 $h_x = 2\\pi/N$，$h_z = 2\\pi/N$。\n2. 构造 $\\psi(x,z)$，然后计算 $u_x = \\partial \\psi/\\partial z = k_z \\cos(k_z z)\\sin(k_x x)$ 和 $u_z = -\\partial \\psi/\\partial x = -k_x \\cos(k_x x)\\sin(k_z z)$，并计算 $b(x,z) = \\cos(k_x x)\\cos(k_z z)$。\n3. 使用带周期性环绕的二阶中心差分计算数值拉普拉斯算子。将其实现为一个在两个方向上使用数组移位（循环滚动）的函数。\n4. 计算每个场的精确拉普拉斯算子，即 $-\\left(k_x^2 + k_z^2\\right)$ 乘以该场。\n5. 形成误差场 $e_{u_x}$、$e_{u_z}$ 和 $e_b$，以及矢量大小 $e_u$。\n6. 为每个 $N$ 计算 $\\|e_u\\|_2$、$\\|e_u\\|_\\infty$、$\\|e_b\\|_2$ 和 $\\|e_b\\|_\\infty$。\n7. 使用关于 $h$ 比率的对数公式，为 $128\\to 256$ 和 $256\\to 512$ 的转换计算两种范数和两种场的观测阶数 $p$。\n8. 按照指定输出顺序为每个测试用例汇总结果，并打印一行包含所有值的逗号分隔列表，并用方括号括起来。\n\n选择测试套件是为了评估：\n- 一个具有中等各向同性的通用“理想情况”，$(k_x,k_z)=(4,4)$。\n- 一个各向异性情况，$(k_x,k_z)=(16,8)$，在每个方向上有不同的尺度。\n- 一个在一个方向上的近奈奎斯特边界情况，$(k_x,k_z)=(32,1)$，接近 $N=128$ 的奈奎斯特极限（在 $[0,2\\pi]$ 上的奈奎斯特波数为 $k_{\\text{Ny}} = N/2 = 64$，单位为弧度/单位长度），以探究对高波数的敏感性。\n\n在正确实现下，观测阶数 $p$ 应接近 2，这与二阶精度一致，尽管有限精度和各向异性可能会引起小的偏差。输出是无量纲的，角度以弧度为单位。最终程序必须只生成一行符合指定格式的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef laplacian_periodic_2d(f, hx, hz):\n    \"\"\"\n    Compute the 2D periodic Laplacian of array f using second-order centered differences.\n    Periodic wrapping is enforced via np.roll. Grid spacings are hx and hz.\n    \"\"\"\n    # second derivative in x with periodic wrap\n    d2x = (np.roll(f, -1, axis=0) - 2.0 * f + np.roll(f, 1, axis=0)) / (hx * hx)\n    # second derivative in z with periodic wrap\n    d2z = (np.roll(f, -1, axis=1) - 2.0 * f + np.roll(f, 1, axis=1)) / (hz * hz)\n    return d2x + d2z\n\ndef manufactured_fields(kx, kz, N):\n    \"\"\"\n    Generate manufactured streamfunction psi, velocity components ux, uz,\n    and buoyancy b on an NxN periodic grid over [0, 2pi] x [0, 2pi].\n    \"\"\"\n    Lx = 2.0 * np.pi\n    Lz = 2.0 * np.pi\n    hx = Lx / N\n    hz = Lz / N\n\n    # Grid coordinates\n    x = np.arange(N) * hx\n    z = np.arange(N) * hz\n    X, Z = np.meshgrid(x, z, indexing='ij')\n\n    # Manufactured streamfunction and derived fields\n    psi = np.sin(kx * X) * np.sin(kz * Z)\n    ux = kz * np.cos(kz * Z) * np.sin(kx * X)\n    uz = -kx * np.cos(kx * X) * np.sin(kz * Z)\n    b = np.cos(kx * X) * np.cos(kz * Z)\n\n    return X, Z, hx, hz, psi, ux, uz, b\n\ndef norms_and_orders_for_case(kx, kz):\n    \"\"\"\n    For a given (kx, kz) test case, compute error norms at N=128,256,512\n    and observed orders for velocity and buoyancy.\n    Returns a list of 20 floats (see specified output format).\n    \"\"\"\n    Ns = [128, 256, 512]\n    Lx = 2.0 * np.pi\n    # Store norms for each N\n    vel_L2 = []\n    vel_Linf = []\n    b_L2 = []\n    b_Linf = []\n\n    k2 = (kx ** 2) + (kz ** 2)\n\n    for N in Ns:\n        # Build fields\n        X, Z, hx, hz, psi, ux, uz, b = manufactured_fields(kx, kz, N)\n\n        # Numerical laplacians\n        lap_ux_num = laplacian_periodic_2d(ux, hx, hz)\n        lap_uz_num = laplacian_periodic_2d(uz, hx, hz)\n        lap_b_num = laplacian_periodic_2d(b, hx, hz)\n\n        # Exact laplacians\n        lap_ux_exact = -k2 * ux\n        lap_uz_exact = -k2 * uz\n        lap_b_exact = -k2 * b\n\n        # Errors\n        e_ux = lap_ux_num - lap_ux_exact\n        e_uz = lap_uz_num - lap_uz_exact\n        e_b = lap_b_num - lap_b_exact\n\n        # Velocity magnitude error\n        e_u_mag = np.sqrt(e_ux * e_ux + e_uz * e_uz)\n\n        # Norms: L2 as sqrt(mean of squared), Linf as max abs\n        vel_L2.append(float(np.sqrt(np.mean(e_u_mag * e_u_mag))))\n        vel_Linf.append(float(np.max(e_u_mag)))\n        b_L2.append(float(np.sqrt(np.mean(e_b * e_b))))\n        b_Linf.append(float(np.max(np.abs(e_b))))\n\n    # Observed orders p between successive Ns using h ratios\n    # h_N / h_{2N} = 2\n    log2 = np.log(2.0)\n\n    def observed_orders(errs):\n        p12 = np.log(errs[0] / errs[1]) / log2\n        p23 = np.log(errs[1] / errs[2]) / log2\n        return float(p12), float(p23)\n\n    p_vel_L2_128_256, p_vel_L2_256_512 = observed_orders(vel_L2)\n    p_vel_Linf_128_256, p_vel_Linf_256_512 = observed_orders(vel_Linf)\n    p_b_L2_128_256, p_b_L2_256_512 = observed_orders(b_L2)\n    p_b_Linf_128_256, p_b_Linf_256_512 = observed_orders(b_Linf)\n\n    # Assemble results in specified order for this test case\n    result = [\n        vel_L2[0], vel_L2[1], vel_L2[2], p_vel_L2_128_256, p_vel_L2_256_512,\n        vel_Linf[0], vel_Linf[1], vel_Linf[2], p_vel_Linf_128_256, p_vel_Linf_256_512,\n        b_L2[0], b_L2[1], b_L2[2], p_b_L2_128_256, p_b_L2_256_512,\n        b_Linf[0], b_Linf[1], b_Linf[2], p_b_Linf_128_256, p_b_Linf_256_512\n    ]\n    return result\n\ndef solve():\n    # Define the test cases from the problem statement: (kx, kz)\n    test_cases = [\n        (4, 4),    # Test Case 1: happy path\n        (16, 8),   # Test Case 2: anisotropic\n        (32, 1)    # Test Case 3: near-Nyquist in x, low kz\n    ]\n\n    results = []\n    for kx, kz in test_cases:\n        case_results = norms_and_orders_for_case(kx, kz)\n        results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "对于受迫湍流的 DNS 而言，一个关键目标是计算稳定、长时间的统计量。这要求模拟达到统计定常态，即宏观属性不再随时间漂移。本练习通过为湍流关键统计量（如动能、耗散率和能谱）开发诊断程序，提供了一个评估定常态的框架，教您如何自信地确定模拟运行时间是否足够长，以产生可靠的科学数据 。",
            "id": "3790053",
            "problem": "考虑一个在周期性域中对三维不可压缩海洋湍流进行的受力直接数值模拟（DNS）。令 $E(t)$ 表示单位质量动能，单位为 $\\mathrm{m^2/s^2}$；令 $\\epsilon(t)$ 表示湍动能耗散率，单位为 $\\mathrm{m^2/s^3}$；令 $E_1(k,t)$ 表示一维能谱，单位为 $\\mathrm{m^3/s^2}$，使得离散谱积分近似于 $E(t)$，即对于均匀波数间隔 $\\Delta k$，有 $\\sum_k E_1(k,t)\\Delta k \\approx E(t)$。涡周转时间 $T_{\\mathrm{ed}}$ 定义为 $T_{\\mathrm{ed}} = L_{\\mathrm{int}}/U_{\\mathrm{rms}}$，其中 $L_{\\mathrm{int}}$ 是积分长度尺度，单位为 $\\mathrm{m}$，$U_{\\mathrm{rms}}$ 是均方根速度，单位为 $\\mathrm{m/s}$。\n\n您需要设计诊断方法，通过评估 $E(t)$ 和 $\\epsilon(t)$ 的运行平均值以及评估谱的平稳性，来验证在多个涡周转时间内的统计平稳性。该诊断方法必须基于以下基本原理构建：\n\n- 对于不可压缩牛顿流体，动量守恒意味着速度 $u_i(\\mathbf{x},t)$ 的演化遵循纳维-斯托克斯方程，单位质量湍动能为 $E(t) = \\frac{1}{2}\\langle u_i u_i \\rangle$，其中 $\\langle \\cdot \\rangle$ 表示空间平均。\n- 湍动能耗散率为 $\\epsilon(t) = 2\\nu \\langle s_{ij} s_{ij} \\rangle$，其中 $\\nu$ 是运动粘度，单位为 $\\mathrm{m^2/s}$，$s_{ij} = \\frac{1}{2}\\left(\\partial_j u_i + \\partial_i u_j\\right)$ 是应变率张量。\n- 在连续极限下，一维能谱 $E_1(k,t)$ 满足 $\\int_0^\\infty E_1(k,t)\\,\\mathrm{d}k = E(t)$。\n\n定义持续时间为 $T_w = N_{\\mathrm{ed}} T_{\\mathrm{ed}}$ 的不重叠时间窗口，其中 $N_{\\mathrm{ed}}$ 是一个正实数，并计算每个窗口的时间平均值 $\\overline{E}_i$ 和 $\\overline{\\epsilon}_i$ 以及每个窗口的时间平均谱 $\\overline{E}_{1,i}(k)$，按窗口 $i$ 索引。使用这些值，实施以下平稳性接受准则：\n\n1. $E(t)$ 和 $\\epsilon(t)$ 的运行平均平稳性：\n   - 范围准则：对于 $x \\in \\{E,\\epsilon\\}$，计算 $R_x = \\left(\\max_i \\overline{x}_i - \\min_i \\overline{x}_i\\right)/\\overline{x}$，其中 $\\overline{x}$ 是所有 $\\overline{x}_i$ 的均值。要求 $R_E \\le \\tau_{\\mathrm{rng},E}$ 且 $R_\\epsilon \\le \\tau_{\\mathrm{rng},\\epsilon}$。\n   - 趋势准则：将最小二乘直线 $\\overline{x}_i \\approx m_x t_i + b_x$ 拟合到窗口均值与窗口中心时间 $t_i$（单位为 $\\mathrm{s}$）的关系上。定义一个无量纲斜率度量 $S_x = |m_x|T_{\\mathrm{ed}}/\\overline{x}$。要求 $S_E \\le \\tau_{\\mathrm{slp},E}$ 且 $S_\\epsilon \\le \\tau_{\\mathrm{slp},\\epsilon}$。\n\n2. 谱平稳性：\n   - 窗口间变化：对于连续的窗口，计算归一化均方根差 $D_i = \\sqrt{\\sum_{k\\in\\mathcal{K}} \\left(\\overline{E}_{1,i}(k) - \\overline{E}_{1,i-1}(k)\\right)^2 \\big/ \\sum_{k\\in\\mathcal{K}} \\overline{E}_{1,i-1}(k)^2}$，其中波数集合 $\\mathcal{K}$ 属于惯性区。要求 $\\max_i D_i \\le \\tau_{\\mathrm{spec}}$。\n   - 补偿谱平坦度：对于每个窗口，在 $k\\in\\mathcal{K}$ 上形成补偿谱 $C_i(k) = k^{5/3}\\,\\overline{E}_{1,i}(k)$，并计算变异系数 $\\mathrm{CV}_i = \\mathrm{std}(C_i(k))/\\mathrm{mean}(C_i(k))$。要求 $\\max_i \\mathrm{CV}_i \\le \\tau_{\\mathrm{comp}}$。\n\n接受要求所有准则都得到满足，并且窗口数量至少为3；否则，拒绝平稳性。\n\n在没有完整的DNS场的情况下，实现一个物理上一致的合成生成器来产生测试数据：\n\n- 将 $E(t)$ 和 $\\epsilon(t)$ 生成为独立的均值回归Ornstein–Uhlenbeck过程，并可选择带有缓慢的线性漂移。对于一个均值为 $\\mu_x$、弛豫率为 $\\theta_x$（单位为 $\\mathrm{s^{-1}}$）、波动率参数为 $\\sigma_x$（单位与 $x$ 相同）以及在整个持续时间 $T_{\\mathrm{tot}}$ 内的分数漂移为 $d_x$ 的过程 $x(t)$，使用离散时间更新公式 $x_{n+1} = x_n + \\theta_x\\left(\\mu_x - x_n\\right)\\Delta t + \\sigma_x\\sqrt{\\Delta t}\\,\\xi_n + \\left(d_x\\,\\mu_x/T_{\\mathrm{tot}}\\right)\\Delta t$，其中 $\\xi_n$ 是独立的标准正态变量，$\\Delta t$ 是采样间隔（单位为 $\\mathrm{s}$）。强制 $x_n$ 为正值。\n- 在离散波数网格 $k = 1,2,\\dots,k_{\\max}$ 上，以 $\\Delta k = 1\\,\\mathrm{m^{-1}}$ 生成 $E_1(k,t)$。该谱由一个形状函数 $F(k) = k^{-5/3}\\exp\\left[-(k/k_d)^2\\right]$、一个局部调制函数 $g(k) = \\exp\\left[-(k-k_0)^2/(2\\sigma_g^2)\\right]$、一个随时间变化的形状振幅 $a(t) = A_{\\mathrm{shp}}\\sin\\left(2\\pi t/T_{\\mathrm{osc}}\\right)$ 以及振幅为 $A_{\\mathrm{wn}}$ 的小的附加谱噪声构成。定义一个未归一化的形状 $M(k,t) = F(k)\\left(1 + a(t) g(k) + \\eta_k(t)\\right)$，其中 $\\eta_k(t)$ 是独立的零均值噪声，然后设置 $E_1(k,t) = E(t)\\,M(k,t)/\\sum_{j} M(j,t)\\Delta k$ 以强制满足 $\\sum_k E_1(k,t)\\Delta k = E(t)$；对 $M(k,t)$ 进行裁剪以保持其为正值。\n\n使用惯性区集合 $\\mathcal{K} = \\{k\\in\\mathbb{N}: k_{\\min}\\le k \\le k_{\\max,\\mathrm{IR}}\\}$。\n\n测试套件。实现程序以评估以下参数集的接受准则。所有时间单位必须是 $\\mathrm{s}$，长度单位是 $\\mathrm{m}$，速度单位是 $\\mathrm{m/s}$，能量单位是 $\\mathrm{m^2/s^2}$，耗散率单位是 $\\mathrm{m^2/s^3}$，波数单位是 $\\mathrm{m^{-1}}$。\n\n- 案例1（理想路径，平稳）：\n  - $T_{\\mathrm{tot}} = 300$, $\\Delta t = 0.5$, $L_{\\mathrm{int}} = 1.5$, $U_{\\mathrm{rms}} = 0.1$，因此 $T_{\\mathrm{ed}} = 15$。\n  - $N_{\\mathrm{ed}} = 2$，因此 $T_w = 30$。$k_{\\max} = 64$, $k_d = 32$, $k_{\\min} = 6$, $k_{\\max,\\mathrm{IR}} = 20$, $k_0 = 14$, $\\sigma_g = 4$。\n  - $\\mu_E = 0.005$, $\\mu_\\epsilon = 5\\times 10^{-8}$, $\\theta_E = 1/T_{\\mathrm{ed}}$, $\\theta_\\epsilon = 1/T_{\\mathrm{ed}}$, $\\sigma_E = 0.05\\,\\mu_E$, $\\sigma_\\epsilon = 0.1\\,\\mu_\\epsilon$, $d_E = 0$, $d_\\epsilon = 0$。\n  - $A_{\\mathrm{shp}} = 0.05$, $A_{\\mathrm{wn}} = 0.02$, $T_{\\mathrm{osc}} = 120$。\n  - 容差：$\\tau_{\\mathrm{rng},E} = 0.2$, $\\tau_{\\mathrm{rng},\\epsilon} = 0.2$, $\\tau_{\\mathrm{slp},E} = 0.05$, $\\tau_{\\mathrm{slp},\\epsilon} = 0.05$, $\\tau_{\\mathrm{spec}} = 0.25$, $\\tau_{\\mathrm{comp}} = 0.25$。\n- 案例2（非平稳漂移）：\n  - 与案例1相同，除了 $d_E = 0.3$, $d_\\epsilon = -0.3$。\n- 案例3（谱振荡）：\n  - 与案例1相同，除了 $A_{\\mathrm{shp}} = 0.6$, $A_{\\mathrm{wn}} = 0.1$, $T_{\\mathrm{osc}} = 60$。\n- 案例4（运行时间短，窗口不足）：\n  - $T_{\\mathrm{tot}} = 40$, $\\Delta t = 0.5$, $L_{\\mathrm{int}} = 1.5$, $U_{\\mathrm{rms}} = 0.1$, $T_{\\mathrm{ed}} = 15$, $N_{\\mathrm{ed}} = 2$，谱参数与案例1相同；容差与案例1相同。\n\n您的程序应针对每个案例，根据指定参数合成 $E(t)$、$\\epsilon(t)$ 和 $E_1(k,t)$，计算诊断结果，然后返回是否根据准则接受统计平稳性。最终输出格式必须是单行，包含一个用方括号括起来的布尔值逗号分隔列表，采用Python语法（例如，$\\left[\\mathrm{True},\\mathrm{False},\\mathrm{True},\\mathrm{False}\\right]$）。不得打印任何额外文本。",
            "solution": "该问题要求设计并实现一套诊断方法，用以验证来自海洋湍流直接数值模拟（DNS）数据的统计平稳性。对于任何旨在产生时间平均统计量的长时间模拟，这都是后处理中的关键一步。统计平稳性意味着统计属性（如均值、方差和谱）在时间平移下是不变的。所提供的方法通过对标量时间序列和谱数据进行一系列定量检查来评估此属性。\n\n任务的核心是基于用户定义的准则实现一个验证算法，并在模拟真实湍流数据行为的合成数据上进行测试。合成数据生成是一种手段，其目的是为诊断工具本身生成测试数据。\n\n支撑这些诊断准则的科学原理源于均匀湍流的统计理论。关键量是单位质量总动能 $E(t)$、其耗散率 $\\epsilon(t)$ 以及一维能谱 $E_1(k,t)$。对于统计平稳的湍流，$E(t)$ 和 $\\epsilon(t)$ 的长时间平均值应收敛到常数值。此外，能谱 $E_1(k,t)$ 的形状，特别是在惯性子区，也应是统计上稳定的。\n\n算法设计分两个主要阶段进行：数据生成和平稳性分析。\n\n**1. 合成数据生成**\n\n为了在无法获得完整DNS结果的情况下测试诊断程序，我们首先生成物理上合理的合成数据。\n\n-   **标量时间序列（$E(t)$ 和 $\\epsilon(t)$）：** 在受力湍流中，动能 $E(t)$ 和耗散率 $\\epsilon(t)$ 会围绕一个平均值波动。Ornstein-Uhlenbeck (OU) 过程是对此类均值回归行为的恰当随机模型。提供的离散时间更新方程使用欧拉-丸山格式对此过程进行建模：\n    $$x_{n+1} = x_n + \\theta_x\\left(\\mu_x - x_n\\right)\\Delta t + \\sigma_x\\sqrt{\\Delta t}\\,\\xi_n + \\left(d_x\\,\\mu_x/T_{\\mathrm{tot}}\\right)\\Delta t$$\n    此处，$x_n$ 代表时间步 $n$ 处的 $E$ 或 $\\epsilon$。项 $\\theta_x(\\mu_x - x_n)\\Delta t$ 以 $1/\\theta_x$ 的弛豫时间尺度将过程驱动回其均值 $\\mu_x$。项 $\\sigma_x\\sqrt{\\Delta t}\\,\\xi_n$ 引入随机波动，其中 $\\xi_n$ 是一个标准正态随机变量。最后一项引入了一个缓慢的线性漂移，与分数漂移参数 $d_x$ 成正比，用于模拟非平稳行为。由于 $E(t)$ 和 $\\epsilon(t)$ 在物理上都是非负的，任何生成的低于零的 $x_{n+1}$ 值都必须被裁剪为小的正值或零。\n\n-   **能谱时间序列（$E_1(k,t)$）：** 一维能谱 $E_1(k,t)$ 的生成旨在符合已建立的湍流理论，并满足守恒约束 $\\sum_k E_1(k,t)\\Delta k = E(t)$。\n    -   谱形状基于 $F(k) = k^{-5/3}\\exp\\left[-(k/k_d)^2\\right]$ 的形式。$k^{-5/3}$ 项反映了湍流惯性子区的柯尔莫哥洛夫标度，而指数项则模拟了高波数（耗散区）的粘性滚降，其特征是耗散波数 $k_d$。\n    -   通过一个随时间变化的调制引入非平稳性和波动，$M(k,t) = F(k)(1 + a(t) g(k) + \\eta_k(t))$，其中 $a(t)$ 是一个正弦函数，用于模拟周期性的谱调整，$g(k)$ 将此效应定位在波数空间中，而 $\\eta_k(t)$ 是一个低振幅的随机噪声场。通过裁剪强制 $M(k,t)$ 的正性。\n    -   最后，对每个时间步的谱进行归一化，以确保其积分等于由OU过程生成的总动能 $E(t)$：\n        $$E_1(k,t) = E(t)\\frac{M(k,t)}{\\sum_{j} M(j,t)\\Delta k}$$\n    此步骤确保了标量能量时间序列和谱数据之间的一致性。\n\n**2. 平稳性分析**\n\n算法的核心在于分析在一组不重叠窗口上生成的时间序列。设总模拟时间为 $T_{\\mathrm{tot}}$，采样间隔为 $\\Delta t$。数据被划分为 $N_w = \\lfloor T_{\\mathrm{tot}} / T_w \\rfloor$ 个窗口，每个窗口的持续时间为 $T_w = N_{\\mathrm{ed}} T_{\\mathrm{ed}}$，其中 $T_{\\mathrm{ed}}$ 是涡周转时间。一个必要的初步检查是 $N_w \\ge 3$，因为少于三个数据点（窗口平均值）无法进行稳健的统计分析。\n\n对于每个窗口 $i$，我们计算时间平均量 $\\overline{E}_i$、$\\overline{\\epsilon}_i$ 和时间平均谱 $\\overline{E}_{1,i}(k)$。这些窗口化平均值构成了平稳性测试的基础。\n\n-   **准则1：运行平均平稳性：** 此准则评估平均能量和耗散率随时间的稳定性。\n    -   **范围准则：** 它测量窗口平均值的总变异。度量 $R_x = (\\max_i \\overline{x}_i - \\min_i \\overline{x}_i)/\\overline{x}$ 是窗口均值的范围，由全局均值 $\\overline{x} = \\mathrm{mean}_i(\\overline{x}_i)$ 归一化。$R_x$ 的小值表示窗口平均值没有剧烈变化。测试要求 $R_E \\le \\tau_{\\mathrm{rng},E}$ 和 $R_\\epsilon \\le \\tau_{\\mathrm{rng},\\epsilon}$。\n    -   **趋势准则：** 它检查随时间是否有系统性漂移。使用最小二乘回归将线性模型 $\\overline{x}_i \\approx m_x t_i + b_x$ 拟合到窗口均值与其中心时间 $t_i$ 的关系上。斜率 $m_x$ 表示变化率。无量纲斜率度量 $S_x = |m_x|T_{\\mathrm{ed}}/\\overline{x}$ 通过系统的特征时间尺度（$T_{\\mathrm{ed}}$）和值（$\\overline{x}$）对此斜率进行归一化。小的 $S_x$ 表明不存在显著的线性趋势。测试要求 $S_E \\le \\tau_{\\mathrm{slp},E}$ 和 $S_\\epsilon \\le \\tau_{\\mathrm{slp},\\epsilon}$。\n\n-   **准则2：谱平稳性：** 此准则评估能量在不同波数间的分布稳定性。分析集中在指定的惯性区波数集合 $\\mathcal{K} = \\{k\\in\\mathbb{N}: k_{\\min}\\le k \\le k_{\\max,\\mathrm{IR}}\\}$ 上。\n    -   **窗口间变化：** 此测试量化了连续窗口之间平均谱形状的变化程度。对于所有相邻窗口对，计算归一化均方根差：\n        $$D_i = \\sqrt{\\frac{\\sum_{k\\in\\mathcal{K}} \\left(\\overline{E}_{1,i}(k) - \\overline{E}_{1,i-1}(k)\\right)^2}{\\sum_{k\\in\\mathcal{K}} \\overline{E}_{1,i-1}(k)^2}}$$\n        $D_i$ 的小值表示窗口 $i$ 中的谱与窗口 $i-1$ 中的谱非常相似。该准则要求观察到的最大变化 $\\max_i D_i$ 低于阈值 $\\tau_{\\mathrm{spec}}$。\n    -   **补偿谱平坦度：** 这是对柯尔莫哥洛夫 $k^{-5/3}$ 标度律的直接测试。对于遵循此定律的谱，补偿谱 $C_i(k) = k^{5/3}\\,\\overline{E}_{1,i}(k)$ 在惯性区 $\\mathcal{K}$ 上应是平坦的（常数）。我们通过计算变异系数 $\\mathrm{CV}_i = \\mathrm{std}_{k\\in\\mathcal{K}}(C_i(k))/\\mathrm{mean}_{k\\in\\mathcal{K}}(C_i(k))$ 来量化平坦度。小的 $\\mathrm{CV}_i$ 表示补偿谱平坦，与稳定的惯性区一致。该准则要求 $\\max_i \\mathrm{CV}_i \\le \\tau_{\\mathrm{comp}}$。\n\n一个案例只有在通过所有适用准则（包括对窗口数量的初步检查）后，才被视为“平稳”。实现将系统地将这些检查应用于问题陈述中定义的四个测试案例中的每一个。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_ou_process(t, mu, theta, sigma, d, T_tot):\n    \"\"\"\n    Generates a time series using a mean-reverting Ornstein-Uhlenbeck process\n    with optional linear drift.\n    \"\"\"\n    num_steps = len(t)\n    dt = t[1] - t[0]\n    x = np.zeros(num_steps)\n    x[0] = mu\n    sqrt_dt = np.sqrt(dt)\n    \n    # Pre-calculate drift term per step\n    drift_term_per_step = (d * mu / T_tot) * dt if T_tot > 0 else 0\n\n    for n in range(num_steps - 1):\n        ou_term = theta * (mu - x[n]) * dt\n        random_term = sigma * sqrt_dt * np.random.randn()\n        x[n + 1] = x[n] + ou_term + random_term + drift_term_per_step\n        # Enforce positivity\n        x[n + 1] = max(1e-12, x[n + 1])\n    return x\n\ndef generate_spectrum(t, k_grid, E_t, params):\n    \"\"\"\n    Generates a time-evolving energy spectrum E_1(k,t).\n    \"\"\"\n    k_d = params['k_d']\n    k_0 = params['k_0']\n    sigma_g = params['sigma_g']\n    A_shp = params['A_shp']\n    A_wn = params['A_wn']\n    T_osc = params['T_osc']\n    dk = 1.0 # as specified, delta k = 1\n\n    num_k = len(k_grid)\n    num_t = len(t)\n    E1_k_t = np.zeros((num_k, num_t))\n\n    F_k = k_grid**(-5.0/3.0) * np.exp(-(k_grid / k_d)**2)\n    g_k = np.exp(-(k_grid - k_0)**2 / (2 * sigma_g**2))\n\n    for n in range(num_t):\n        tn = t[n]\n        a_t = A_shp * np.sin(2 * np.pi * tn / T_osc)\n        eta_k_t = np.random.uniform(-A_wn, A_wn, size=k_grid.shape)\n        \n        M_k_t = F_k * (1 + a_t * g_k + eta_k_t)\n        # Enforce positivity\n        M_k_t = np.maximum(1e-12, M_k_t)\n        \n        normalization = np.sum(M_k_t * dk)\n        if normalization > 0:\n            E1_k_t[:, n] = E_t[n] * M_k_t / normalization\n        else:\n            E1_k_t[:, n] = 0\n\n    return E1_k_t\n\ndef check_stationarity(t, E_t, eps_t, E1_k_t, k_grid, params):\n    \"\"\"\n    Performs the full stationarity analysis based on the provided criteria.\n    \"\"\"\n    T_tot = params['T_tot']\n    dt = params['dt']\n    T_ed = params['T_ed']\n    T_w = params['T_w']\n    \n    num_steps = len(t)\n    steps_per_window = int(round(T_w / dt))\n    num_windows = num_steps // steps_per_window\n\n    if num_windows  3:\n        return False\n\n    # Windowed averages\n    E_bar_i = np.zeros(num_windows)\n    eps_bar_i = np.zeros(num_windows)\n    E1_bar_i_k = np.zeros((len(k_grid), num_windows))\n    window_center_times = np.zeros(num_windows)\n\n    for i in range(num_windows):\n        start_idx = i * steps_per_window\n        end_idx = start_idx + steps_per_window\n        \n        E_bar_i[i] = np.mean(E_t[start_idx:end_idx])\n        eps_bar_i[i] = np.mean(eps_t[start_idx:end_idx])\n        E1_bar_i_k[:, i] = np.mean(E1_k_t[:, start_idx:end_idx], axis=1)\n        window_center_times[i] = np.mean(t[start_idx:end_idx])\n        \n    # --- Criterion 1: Running-average stationarity ---\n    tau_rng_E = params['tau_rng_E']\n    tau_rng_eps = params['tau_rng_eps']\n    tau_slp_E = params['tau_slp_E']\n    tau_slp_eps = params['tau_slp_eps']\n\n    # Range criterion\n    E_bar = np.mean(E_bar_i)\n    R_E = (np.max(E_bar_i) - np.min(E_bar_i)) / E_bar if E_bar > 0 else 0\n    if R_E > tau_rng_E: return False\n    \n    eps_bar = np.mean(eps_bar_i)\n    R_eps = (np.max(eps_bar_i) - np.min(eps_bar_i)) / eps_bar if eps_bar > 0 else 0\n    if R_eps > tau_rng_eps: return False\n\n    # Trend criterion\n    m_E, _ = np.polyfit(window_center_times, E_bar_i, 1)\n    S_E = abs(m_E) * T_ed / E_bar if E_bar > 0 else 0\n    if S_E > tau_slp_E: return False\n\n    m_eps, _ = np.polyfit(window_center_times, eps_bar_i, 1)\n    S_eps = abs(m_eps) * T_ed / eps_bar if eps_bar > 0 else 0\n    if S_eps > tau_slp_eps: return False\n\n    # --- Criterion 2: Spectral stationarity ---\n    tau_spec = params['tau_spec']\n    tau_comp = params['tau_comp']\n    k_min = params['k_min']\n    k_max_IR = params['k_max_IR']\n    \n    k_inertial_mask = (k_grid >= k_min)  (k_grid = k_max_IR)\n    k_inertial = k_grid[k_inertial_mask]\n\n    # Inter-window change\n    max_D = 0.0\n    for i in range(1, num_windows):\n        E1_curr = E1_bar_i_k[k_inertial_mask, i]\n        E1_prev = E1_bar_i_k[k_inertial_mask, i - 1]\n        \n        numerator = np.sum((E1_curr - E1_prev)**2)\n        denominator = np.sum(E1_prev**2)\n        \n        D_i = np.sqrt(numerator / denominator) if denominator > 0 else 0\n        if D_i > max_D:\n            max_D = D_i\n    if max_D > tau_spec: return False\n\n    # Compensated flatness\n    max_CV = 0.0\n    for i in range(num_windows):\n        E1_win = E1_bar_i_k[k_inertial_mask, i]\n        C_i_k = k_inertial**(5.0/3.0) * E1_win\n        \n        mean_C = np.mean(C_i_k)\n        std_C = np.std(C_i_k)\n        \n        CV_i = std_C / mean_C if mean_C > 0 else 0\n        if CV_i > max_CV:\n            max_CV = CV_i\n    if max_CV > tau_comp: return False\n    \n    return True\n\ndef analyze_case(params):\n    T_tot = params['T_tot']\n    dt = params['dt']\n    L_int = params['L_int']\n    U_rms = params['U_rms']\n    N_ed = params['N_ed']\n    \n    T_ed = L_int / U_rms\n    T_w = N_ed * T_ed\n\n    params['T_ed'] = T_ed\n    params['T_w'] = T_w\n    \n    num_steps = int(T_tot / dt)\n    t = np.linspace(0, T_tot - dt, num_steps)\n\n    # Generate data\n    E_t = generate_ou_process(t, params['mu_E'], params['theta_E'], params['sigma_E'], params['d_E'], T_tot)\n    eps_t = generate_ou_process(t, params['mu_eps'], params['theta_eps'], params['sigma_eps'], params['d_eps'], T_tot)\n\n    k_grid = np.arange(1, params['k_max'] + 1)\n    E1_k_t = generate_spectrum(t, k_grid, E_t, params)\n    \n    # Check for stationarity\n    return check_stationarity(t, E_t, eps_t, E1_k_t, k_grid, params)\n\n\ndef solve():\n    np.random.seed(0)\n\n    base_params = {\n        'T_tot': 300.0, 'dt': 0.5, 'L_int': 1.5, 'U_rms': 0.1,\n        'N_ed': 2.0, 'k_max': 64, 'k_d': 32, 'k_min': 6, 'k_max_IR': 20,\n        'k_0': 14, 'sigma_g': 4,\n        'mu_E': 0.005, 'mu_eps': 5e-8,\n        'theta_E': 1.0 / (1.5 / 0.1), 'theta_eps': 1.0 / (1.5 / 0.1),\n        'sigma_E': 0.05 * 0.005, 'sigma_eps': 0.1 * 5e-8,\n        'd_E': 0.0, 'd_eps': 0.0,\n        'A_shp': 0.05, 'A_wn': 0.02, 'T_osc': 120.0,\n        'tau_rng_E': 0.2, 'tau_rng_eps': 0.2, 'tau_slp_E': 0.05,\n        'tau_slp_eps': 0.05, 'tau_spec': 0.25, 'tau_comp': 0.25\n    }\n\n    # Case 1: happy path, stationary\n    case1_params = base_params.copy()\n\n    # Case 2: non-stationary drift\n    case2_params = base_params.copy()\n    case2_params.update({'d_E': 0.3, 'd_eps': -0.3})\n\n    # Case 3: spectral oscillations\n    case3_params = base_params.copy()\n    case3_params.update({'A_shp': 0.6, 'A_wn': 0.1, 'T_osc': 60.0})\n    \n    # Case 4: short run, insufficient windows\n    case4_params = base_params.copy()\n    case4_params.update({'T_tot': 40.0})\n\n    test_cases = [case1_params, case2_params, case3_params, case4_params]\n    \n    results = []\n    for case_params in test_cases:\n        result = analyze_case(case_params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}