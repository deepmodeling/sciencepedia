{
    "hands_on_practices": [
        {
            "introduction": "Before a high-quality computational mesh can be generated, the domain boundaries themselves must be rigorously validated. In coastal ocean modeling, these boundaries are typically polygons representing coastlines and islands. This exercise  delves into the fundamental geometric checks required to ensure these polygons are suitable for meshing algorithms. You will practice computing a polygon's signed area to verify its orientation—a critical convention that distinguishes the ocean domain from land—and checking for self-intersections that would render the boundary invalid.",
            "id": "3817799",
            "problem": "In computational oceanography, unstructured grid generation for coastal domains requires that polygonal boundaries representing coastlines (outer boundaries) and internal obstacles such as islands or lakes (holes) adhere to a consistent orientation convention. Under the standard Cartesian coordinate convention used by Geographic Information System (GIS) toolchains for meshing, an outer boundary must be counterclockwise and a hole must be clockwise. This convention makes use of the sign of the polygon's signed area, where the signed area is positive when traversed counterclockwise and negative when traversed clockwise. The objective is to precisely compute signed areas from first principles and use them to verify orientation, while also checking for geometric validity (non-self-intersection) to ensure that these boundaries can be safely used by triangulation routines.\n\nStarting from the fundamental base of planar area as a line integral and the definition of a simple polygon as a closed piecewise-linear curve with non-intersecting edges, derive and implement a program that:\n\n- Computes the signed area of a polygon defined by ordered vertices $\\{(x_i,y_i)\\}_{i=0}^{n-1}$, where all coordinates are in meters, based on a discrete evaluation of a line integral over the polygon boundary. The sign of the area must encode the traversal orientation.\n- Determines orientation using the sign of the computed area, enforcing that an outer boundary has positive signed area (counterclockwise) and each hole has negative signed area (clockwise).\n- Verifies that each polygon is simple (no self-intersections) by testing all non-adjacent edge pairs for intersection.\n- Applies an area magnitude threshold $\\varepsilon$ to reject degenerate polygons with $|A| \\le \\varepsilon$ where $A$ is the signed area. Use $\\varepsilon = 10^{-6}$ square meters.\n- Expresses areas in square meters, rounded to three decimal places.\n\nYour program must evaluate the following test suite, where each test case contains one outer boundary polygon and zero or more hole polygons. All coordinates are in meters, and vertices are provided in the order they are traversed.\n\nTest Case $1$ (happy path: valid simple polygons and correct orientations):\n- Outer boundary (counterclockwise): `[(0,0),(1000,0),(1000,500),(0,500)]`\n- Holes (clockwise): one hole `[(200,100),(250,200),(300,100)]`\n\nTest Case $2$ (orientation errors: valid simple polygons but wrong orientations):\n- Outer boundary (clockwise): `[(0,500),(1000,500),(1000,0),(0,0)]`\n- Holes (counterclockwise): one hole `[(300,100),(250,200),(200,100)]`\n\nTest Case $3$ (degenerate outer boundary: collinear vertices yield zero area):\n- Outer boundary: `[(0,0),(500,0),(1000,0),(0,0)]`\n- Holes: none\n\nTest Case $4$ (self-intersecting outer boundary: bow-tie shape):\n- Outer boundary: `[(0,0),(1000,0),(200,500),(800,500)]`\n- Holes: none\n\nFor each test case, the program must produce a result consisting of:\n- The outer boundary signed area in square meters, rounded to three decimal places.\n- A list of signed areas for the holes in square meters, each rounded to three decimal places (empty list if no holes).\n- A boolean indicating whether the entire case is valid for meshing, which requires: the outer boundary to be simple with positive signed area greater than $\\varepsilon$, and every hole to be simple with negative signed area less than $-\\varepsilon$.\n\nFinal Output Format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element corresponds to one test case and must itself be a list of the form `[A_outer, [A_holes], valid]`, where `A_outer` is a float, `[A_holes]` is a list of floats, and `valid` is a boolean. For example, the output must look like `[[...],[...],[...],[...]]` with four elements, one per test case.",
            "solution": "The problem as stated is valid. It is scientifically grounded in the principles of vector calculus and computational geometry, well-posed with a complete and consistent set of definitions and constraints, and entirely objective. The required tasks—calculating polygon signed area and detecting self-intersections—are standard, formalizable problems within the domain of computational grid generation for ocean models. All data and criteria for validation are explicitly provided.\n\nThe solution will be developed in three principal stages: first, the derivation of the formula for the signed area of a polygon from the principles of line integrals; second, the formulation of an algorithm to detect self-intersections in a polygon; and third, the synthesis of these components into a comprehensive validation procedure for each test case.\n\n### 1. Computation of Signed Area\n\nThe signed area $A$ of a simple, closed planar region $D$ bounded by a curve $C$ can be computed using Green's Theorem, which relates a line integral around $C$ to a double integral over $D$:\n$$\n\\oint_C (L \\, dx + M \\, dy) = \\iint_D \\left(\\frac{\\partial M}{\\partial x} - \\frac{\\partial L}{\\partial y}\\right) \\, dA\n$$\nTo compute the area $A = \\iint_D dA$, we must select functions $L(x, y)$ and $M(x, y)$ such that $\\frac{\\partial M}{\\partial x} - \\frac{\\partial L}{\\partial y} = 1$. A standard choice that symmetrizes the integrand is $L = -y/2$ and $M = x/2$. Substituting these into Green's theorem yields the line integral for area:\n$$\nA = \\frac{1}{2} \\oint_C (x \\, dy - y \\, dx)\n$$\nThe problem defines a polygon by an ordered sequence of $n$ vertices $\\{(x_i, y_i)\\}_{i=0}^{n-1}$. The closed boundary $C$ is the union of line segments connecting adjacent vertices, i.e., from $(x_i, y_i)$ to $(x_{i+1}, y_{i+1})$ for $i = 0, \\dots, n-1$, where the indices are taken modulo $n$ such that $(x_n, y_n) = (x_0, y_0)$. The line integral is thus a sum of integrals over these $n$ segments:\n$$\nA = \\frac{1}{2} \\sum_{i=0}^{n-1} \\int_{(x_i, y_i)}^{(x_{i+1}, y_{i+1})} (x \\, dy - y \\, dx)\n$$\nFor a single segment from $(x_i, y_i)$ to $(x_{i+1}, y_{i+1})$, we can parameterize the path using a parameter $t \\in [0, 1]$:\n$$\n\\begin{align*}\nx(t) &= x_i + t(x_{i+1} - x_i) &\\implies dx = (x_{i+1} - x_i) \\, dt \\\\\ny(t) &= y_i + t(y_{i+1} - y_i) &\\implies dy = (y_{i+1} - y_i) \\, dt\n\\end{align*}\n$$\nSubstituting this into the integral for one segment and integrating from $t=0$ to $t=1$:\n$$\n\\int_0^1 \\left[ (x_i + t\\Delta x_i)( \\Delta y_i ) - (y_i + t\\Delta y_i)( \\Delta x_i ) \\right] \\, dt\n$$\nwhere $\\Delta x_i = x_{i+1} - x_i$ and $\\Delta y_i = y_{i+1} - y_i$. The integrand simplifies to:\n$$\n(x_i \\Delta y_i + t\\Delta x_i \\Delta y_i) - (y_i \\Delta x_i + t\\Delta y_i \\Delta x_i) = x_i \\Delta y_i - y_i \\Delta x_i = x_i(y_{i+1}-y_i) - y_i(x_{i+1}-x_i) = x_i y_{i+1} - y_i x_{i+1}\n$$\nThis expression is constant with respect to $t$. The integral is simply the constant value multiplied by the interval length, which is $1$.\n$$\n\\int_{(x_i, y_i)}^{(x_{i+1}, y_{i+1})} (x \\, dy - y \\, dx) = x_i y_{i+1} - y_i x_{i+1}\n$$\nSumming over all segments gives the final discrete formula, known as the shoelace formula or surveyor's formula:\n$$\nA = \\frac{1}{2} \\sum_{i=0}^{n-1} (x_i y_{i+1} - x_{i+1} y_i)\n$$\nThe sign of $A$ depends on the order of the vertices. By the right-hand rule convention associated with Green's Theorem, a counterclockwise (CCW) traversal yields a positive area, while a clockwise (CW) traversal yields a negative area.\n\n### 2. Detection of Self-Intersection (Simple Polygon Test)\n\nA polygon is simple if its edges do not intersect, except for adjacent edges which intersect only at their shared vertex. To verify that a polygon is simple, we must test every pair of non-adjacent edges for intersection.\n\nLet an edge be defined by two vertices. For a polygon with $n$ vertices, we have $n$ edges $e_0, e_1, \\dots, e_{n-1}$, where $e_i$ connects vertex $v_i$ to $v_{i+1}$ (indices modulo $n$). We must check each pair $(e_i, e_j)$ where $i < j$ and $e_i$ and $e_j$ are not adjacent. Two edges $e_i$ and $e_j$ are adjacent if they share a vertex, which occurs if $j = i+1$ or if $i=0$ and $j=n-1$.\n\nThe geometric test for the intersection of two line segments, say $P_1P_2$ and $P_3P_4$, is based on a series of orientation tests. The orientation of an ordered triplet of points $(P_a, P_b, P_c)$ is determined by the sign of the cross-product of the vectors $\\vec{P_aP_b}$ and $\\vec{P_bP_c}$:\n$$\n\\text{orientation}(P_a, P_b, P_c) = \\text{sign}((y_b - y_a)(x_c - x_b) - (x_b - x_a)(y_c - y_b))\n$$\nA positive sign indicates a CCW turn (left), a negative sign a CW turn (right), and a value of $0$ indicates the points are collinear.\n\nTwo non-collinear segments $P_1P_2$ and $P_3P_4$ intersect if and only if the orientations $(P_1, P_2, P_3)$ and $(P_1, P_2, P_4)$ are different, AND the orientations $(P_3, P_4, P_1)$ and $(P_3, P_4, P_2)$ are different.\n\nSpecial handling is required for collinear cases. If the orientation test reveals that three points are collinear (e.g., $(P_1, P_2, P_3)$ are collinear), we must then check if the point $P_3$ lies on the line segment $P_1P_2$. This is true if its coordinates fall within the bounding box of the segment:\n$$\nx_3 \\in [\\min(x_1, x_2), \\max(x_1, x_2)] \\quad \\text{and} \\quad y_3 \\in [\\min(y_1, y_2), \\max(y_1, y_2)]\n$$\nIf any pair of non-adjacent edges passes this intersection test, the polygon is not simple.\n\n### 3. Comprehensive Validation Logic\n\nFor each test case, we apply the derived methods to determine overall validity for meshing. The area magnitude threshold is $\\varepsilon = 10^{-6} \\text{m}^2$.\n\n1.  **Outer Boundary Polygon:**\n    a. Calculate its signed area, $A_{\\text{outer}}$, using the shoelace formula.\n    b. Check if the polygon is simple by testing all non-adjacent edge pairs for intersection.\n    c. The outer boundary is valid if and only if it is simple AND its area $A_{\\text{outer}} > \\varepsilon$.\n\n2.  **Hole Polygons (for each hole):**\n    a. Calculate its signed area, $A_{\\text{hole}}$, using the shoelace formula.\n    b. Check if the polygon is simple.\n    c. Each hole is valid if and only if it is simple AND its area $A_{\\text{hole}} < -\\varepsilon$.\n\n3.  **Overall Case Validity:**\n    A test case is valid as a whole if its outer boundary is valid AND all of its hole polygons are valid. If any single component fails its check, the entire case is deemed invalid for meshing.\n\nThe final output for each test case will be a list containing the rounded signed area of the outer boundary, a list of the rounded signed areas of all holes, and a Boolean flag indicating the overall validity of the case.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates and solves the computational geometry problem for unstructured grid generation.\n    \"\"\"\n    \n    # Area magnitude threshold for rejecting degenerate polygons.\n    EPSILON = 1e-6\n\n    def calculate_signed_area(polygon):\n        \"\"\"\n        Calculates the signed area of a polygon using the shoelace formula.\n        A counter-clockwise polygon has positive area, clockwise has negative area.\n        \n        Args:\n            polygon (list of tuples): A list of (x, y) vertex coordinates.\n        \n        Returns:\n            float: The signed area of the polygon.\n        \"\"\"\n        n = len(polygon)\n        if n < 3:\n            return 0.0\n        \n        area = 0.0\n        for i in range(n):\n            x1, y1 = polygon[i]\n            x2, y2 = polygon[(i + 1) % n]\n            area += (x1 * y2 - x2 * y1)\n        \n        return area / 2.0\n\n    def orientation(p, q, r):\n        \"\"\"\n        Finds the orientation of the ordered triplet (p, q, r).\n        \n        Returns:\n            0: Collinear points\n            1: Clockwise (right turn)\n            2: Counter-Clockwise (left turn)\n        \"\"\"\n        val = (q[1] - p[1]) * (r[0] - q[0]) - \\\n              (q[0] - p[0]) * (r[1] - q[1])\n        if abs(val) < 1e-9: # Use tolerance for floating point\n            return 0  # Collinear\n        return 1 if val > 0 else 2  # Clockwise or Counter-Clockwise\n\n    def on_segment(p, q, r):\n        \"\"\"\n        Given three collinear points p, q, r, the function checks if point q \n        lies on line segment 'pr'.\n        \"\"\"\n        return (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and\n                q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1]))\n\n    def segments_intersect(p1, q1, p2, q2):\n        \"\"\"\n        Checks if line segment 'p1q1' and 'p2q2' intersect.\n        \"\"\"\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n\n        # General case: Segments cross each other.\n        if o1 != 0 and o2 != 0 and o3 != 0 and o4 != 0:\n            if o1 != o2 and o3 != o4:\n                return True\n        \n        # Special Cases for collinear intersections.\n        if o1 == 0 and on_segment(p1, p2, q1): return True\n        if o2 == 0 and on_segment(p1, q2, q1): return True\n        if o3 == 0 and on_segment(p2, p1, q2): return True\n        if o4 == 0 and on_segment(p2, q1, q2): return True\n\n        return False\n\n    def is_simple_polygon(polygon):\n        \"\"\"\n        Checks if a polygon is simple (does not self-intersect).\n        Tests all non-adjacent edge pairs for intersection.\n        \"\"\"\n        n = len(polygon)\n        if n < 4:\n            return True # Triangles cannot self-intersect\n\n        for i in range(n):\n            p1 = polygon[i]\n            q1 = polygon[(i + 1) % n]\n            \n            # j starts from i+2 to avoid checking adjacent segments\n            for j in range(i + 2, n):\n                # The last edge (n-1, 0) is adjacent to the first edge (0,1).\n                # This case needs to be skipped. i=0, j=n-1\n                if i == 0 and j == n - 1:\n                    continue\n                \n                p2 = polygon[j]\n                q2 = polygon[(j + 1) % n]\n                \n                if segments_intersect(p1, q1, p2, q2):\n                    return False\n        return True\n\n    test_cases = [\n        {\n            \"outer\": [(0,0),(1000,0),(1000,500),(0,500)],\n            \"holes\": [[(200,100),(250,200),(300,100)]]\n        },\n        {\n            \"outer\": [(0,500),(1000,500),(1000,0),(0,0)],\n            \"holes\": [[(300,100),(250,200),(200,100)]]\n        },\n        {\n            \"outer\": [(0,0),(500,0),(1000,0),(0,0)],\n            \"holes\": []\n        },\n        {\n            \"outer\": [(0,0),(1000,0),(200,500),(800,500)],\n            \"holes\": []\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        case_is_valid = True\n        \n        # Process outer boundary\n        outer_poly = case[\"outer\"]\n        outer_area = calculate_signed_area(outer_poly)\n        outer_is_simple = is_simple_polygon(outer_poly)\n        \n        if not (outer_is_simple and outer_area > EPSILON):\n            case_is_valid = False\n            \n        # Process holes\n        hole_areas = []\n        for hole_poly in case[\"holes\"]:\n            hole_area = calculate_signed_area(hole_poly)\n            hole_areas.append(hole_area)\n            hole_is_simple = is_simple_polygon(hole_poly)\n            if not (hole_is_simple and hole_area < -EPSILON):\n                case_is_valid = False\n\n        # Format results for output\n        rounded_outer_area = round(outer_area, 3)\n        rounded_hole_areas = [round(a, 3) for a in hole_areas]\n        \n        # Construct the string representation for the current result manually\n        hole_areas_str = '[' + ','.join(map(str, rounded_hole_areas)) + ']'\n        result_str = f\"[{rounded_outer_area},{hole_areas_str},{case_is_valid}]\"\n        results.append(result_str)\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Mesh quality can be significantly improved through iterative smoothing techniques, where vertex locations are adjusted to optimize element shapes. Lloyd's algorithm, which generates Centroidal Voronoi Tessellations (CVTs), is a cornerstone of such methods. This practice  provides a focused look at the core mechanic of this algorithm: performing a single update step. By calculating the weighted centroid of a cell and moving its generator site, you will gain hands-on insight into how this powerful optimization process iteratively minimizes a geometric energy functional to produce well-spaced vertices and high-quality elements.",
            "id": "3817790",
            "problem": "Consider an unstructured coastal ocean mesh where a single Voronoi cell is represented by the rectangle with vertices $(0,0)$, $(4,0)$, $(4,2)$, $(0,2)$ in the $(x,y)$-plane, with $x$ and $y$ in kilometers. The resolution monitor field $\\rho(x,y)$ is piecewise constant to reflect nearshore refinement: $\\rho(x,y) = 3$ for $0 \\le x \\le 2$ and $\\rho(x,y) = 1$ for $2  x \\le 4$, for all $0 \\le y \\le 2$. The current generator (site) location is $s^{(0)} = \\left(\\frac{5}{2}, \\frac{1}{2}\\right)$.\n\nStarting from foundational definitions of centroidal Voronoi tessellation (CVT) energy in terms of the $\\rho$-weighted squared distance over the cell, perform one Lloyd update by evaluating the $\\rho$-area-weighted centroid of the cell (i.e., the mass centroid under $\\rho$). Then assess the convergence criterion based on energy decrease, where the energy functional is $E(s) = \\int_{\\text{cell}} \\rho(x,y)\\, \\left|(x,y) - s\\right|^{2} \\, dx\\,dy$, and the energy decrease for this step is defined as $\\Delta E = E\\!\\left(s^{(0)}\\right) - E\\!\\left(s^{(1)}\\right)$ with $s^{(1)}$ the updated site. Use the absolute convergence test “converged if $\\Delta E  \\tau$” with tolerance $\\tau = 5$.\n\nCompute:\n- The updated site $s^{(1)}$ by evaluating the $\\rho$-area-weighted centroid of the given polygonal cell.\n- The energy decrease $\\Delta E$ for the update.\n- Whether the step is converged under the given criterion, reported as $1$ if converged and $0$ otherwise.\n\nExpress the updated site coordinates in kilometers and the energy decrease in $\\mathrm{km}^{4}$. No rounding is required. Your final answer must be a single row vector containing $s^{(1)}_x$, $s^{(1)}_y$, $\\Delta E$, and the convergence indicator in that order.",
            "solution": "The user wants to solve a problem based on the principles of Centroidal Voronoi Tessellation (CVT), specifically involving a single Lloyd update step for a generator site within a defined cell. The problem requires the calculation of the updated site position, the corresponding energy decrease, and an assessment of convergence.\n\n### Step 1: Problem Validation\n\nFirst, the validity of the problem statement is assessed.\n\n**Givens:**\n- A Voronoi cell, denoted as $V$, is a rectangle with vertices $(0,0)$, $(4,0)$, $(4,2)$, and $(0,2)$. All coordinates are in kilometers. Thus, $V = [0,4] \\times [0,2]$.\n- A piecewise constant resolution monitor field $\\rho(x,y)$ is defined over $V$:\n$$ \\rho(x,y) = \\begin{cases} 3  \\text{for } 0 \\leq x \\leq 2, 0 \\leq y \\leq 2 \\\\ 1  \\text{for } 2  x \\leq 4, 0 \\leq y \\leq 2 \\end{cases} $$\n- The initial generator site is $s^{(0)} = \\left(\\frac{5}{2}, \\frac{1}{2}\\right)$.\n- The CVT energy functional is $E(s) = \\int_{V} \\rho(x,y)\\, \\left|(x,y) - s\\right|^{2} \\, dx\\,dy$.\n- The updated site $s^{(1)}$ is the $\\rho$-area-weighted centroid of the cell $V$.\n- The energy decrease is $\\Delta E = E(s^{(0)}) - E(s^{(1)})$.\n- The convergence criterion is $\\Delta E  \\tau$ with a tolerance of $\\tau = 5$.\n- The required outputs are the coordinates of the updated site $s^{(1)}$, the energy decrease $\\Delta E$, and a binary convergence indicator.\n\n**Validation Verdict:**\nThe problem is scientifically and mathematically sound. It describes a standard step in Lloyd's algorithm for computing a CVT, a fundamental method in mesh generation and computational geometry. All terms are well-defined, the data provided are complete and consistent, and the required computations are unambiguous. The setup is a valid, well-posed problem in computational science.\n\n### Step 2: Calculation of the Updated Site $s^{(1)}$\n\nThe updated site $s^{(1)} = (s^{(1)}_x, s^{(1)}_y)$ is the $\\rho$-area-weighted centroid of the cell $V$. The coordinates are given by:\n$$ s^{(1)}_x = \\frac{\\int_V x \\rho(x,y) \\, dA}{\\int_V \\rho(x,y) \\, dA} \\quad \\text{and} \\quad s^{(1)}_y = \\frac{\\int_V y \\rho(x,y) \\, dA}{\\int_V \\rho(x,y) \\, dA} $$\nwhere $dA = dx\\,dy$.\n\nLet's first compute the denominator, which is the total weighted area (or \"mass\") $M$ of the cell:\n$$ M = \\int_V \\rho(x,y) \\, dA $$\nDue to the piecewise nature of $\\rho(x,y)$, we split the integral over two subdomains:\n$V_1 = [0,2] \\times [0,2]$, where $\\rho=3$.\n$V_2 = (2,4] \\times [0,2]$, where $\\rho=1$.\n\nThe area of $V_1$ is $2 \\times 2 = 4 \\, \\mathrm{km}^2$.\nThe area of $V_2$ is $(4-2) \\times 2 = 4 \\, \\mathrm{km}^2$.\n\n$$ M = \\int_{V_1} 3 \\, dA + \\int_{V_2} 1 \\, dA = 3 \\cdot \\text{Area}(V_1) + 1 \\cdot \\text{Area}(V_2) = 3(4) + 1(4) = 16 $$\nThe units of $M$ are $\\mathrm{km}^2$, as $\\rho$ is a dimensionless weighting factor.\n\nNext, we compute the numerators, which are the first moments of the cell.\nThe first moment with respect to the $y$-axis is:\n$$ M_y = \\int_V x \\rho(x,y) \\, dA = \\int_{V_1} x(3) \\, dA + \\int_{V_2} x(1) \\, dA $$\n$$ M_y = 3 \\int_0^2 \\int_0^2 x \\, dy \\, dx + 1 \\int_2^4 \\int_0^2 x \\, dy \\, dx $$\n$$ M_y = 3 \\int_0^2 [xy]_0^2 \\, dx + \\int_2^4 [xy]_0^2 \\, dx = 3 \\int_0^2 2x \\, dx + \\int_2^4 2x \\, dx $$\n$$ M_y = 3 [x^2]_0^2 + [x^2]_2^4 = 3(4-0) + (16-4) = 12 + 12 = 24 $$\n\nThe first moment with respect to the $x$-axis is:\n$$ M_x = \\int_V y \\rho(x,y) \\, dA = \\int_{V_1} y(3) \\, dA + \\int_{V_2} y(1) \\, dA $$\n$$ M_x = 3 \\int_0^2 \\int_0^2 y \\, dy \\, dx + 1 \\int_2^4 \\int_0^2 y \\, dy \\, dx $$\n$$ M_x = 3 \\int_0^2 \\left[\\frac{y^2}{2}\\right]_0^2 dx + \\int_2^4 \\left[\\frac{y^2}{2}\\right]_0^2 dx = 3 \\int_0^2 2 \\, dx + \\int_2^4 2 \\, dx $$\n$$ M_x = 3 [2x]_0^2 + [2x]_2^4 = 3(4-0) + (8-4) = 12 + 4 = 16 $$\n\nNow we can calculate the coordinates of the updated site $s^{(1)}$:\n$$ s^{(1)}_x = \\frac{M_y}{M} = \\frac{24}{16} = \\frac{3}{2} $$\n$$ s^{(1)}_y = \\frac{M_x}{M} = \\frac{16}{16} = 1 $$\nTherefore, the updated site is $s^{(1)} = \\left(\\frac{3}{2}, 1\\right)$.\n\n### Step 3: Calculation of the Energy Decrease $\\Delta E$\n\nThe energy decrease is $\\Delta E = E(s^{(0)}) - E(s^{(1)})$. The energy functional $E(s)$ represents the weighted moment of inertia of the cell about the point $s$. A fundamental property related to the centroid (the parallel axis theorem) states that the energy at an arbitrary point $s$ can be expressed in terms of the energy at the centroid $s^{(1)}$ and the distance between $s$ and $s^{(1)}$:\n$$ E(s) = E(s^{(1)}) + M \\left|s - s^{(1)}\\right|^2 $$\nThis holds because $s^{(1)}$ is the point that minimizes the energy functional $E(s)$.\nSetting $s = s^{(0)}$, we get:\n$$ E(s^{(0)}) = E(s^{(1)}) + M \\left|s^{(0)} - s^{(1)}\\right|^2 $$\nRearranging gives a direct formula for the energy decrease:\n$$ \\Delta E = E(s^{(0)}) - E(s^{(1)}) = M \\left|s^{(0)} - s^{(1)}\\right|^2 $$\nWe have $M=16$, $s^{(0)} = \\left(\\frac{5}{2}, \\frac{1}{2}\\right)$, and $s^{(1)} = \\left(\\frac{3}{2}, 1\\right)$.\n\nFirst, we find the squared distance between the initial and updated sites:\n$$ \\left|s^{(0)} - s^{(1)}\\right|^2 = \\left(\\frac{5}{2} - \\frac{3}{2}\\right)^2 + \\left(\\frac{1}{2} - 1\\right)^2 = \\left(\\frac{2}{2}\\right)^2 + \\left(-\\frac{1}{2}\\right)^2 = 1^2 + \\frac{1}{4} = \\frac{5}{4} $$\nThe units of this squared distance are $\\mathrm{km}^2$.\n\nNow, we calculate the energy decrease:\n$$ \\Delta E = M \\left|s^{(0)} - s^{(1)}\\right|^2 = 16 \\cdot \\frac{5}{4} = 20 $$\nSince $M$ is in $\\mathrm{km}^2$ (as $\\rho$ is dimensionless) and the squared distance is in $\\mathrm{km}^2$, the energy decrease $\\Delta E$ is in units of $\\mathrm{km}^4$, as required.\n\n### Step 4: Convergence Assessment\n\nThe convergence criterion is given by $\\Delta E  \\tau$, with the tolerance $\\tau = 5$.\nWe calculated $\\Delta E = 20$.\nWe compare these values: $20  5$. This inequality is false.\nTherefore, the update step has not met the convergence criterion. The corresponding indicator is $0$.\n\n### Summary of Results\n- The updated site is $s^{(1)} = \\left(\\frac{3}{2}, 1\\right)$.\n- The energy decrease is $\\Delta E = 20$.\n- The convergence indicator is $0$.\n\nThe final answer is a row vector containing these four values in the specified order: $(s^{(1)}_x, s^{(1)}_y, \\Delta E, \\text{indicator})$.",
            "answer": "$$ \\boxed{ \\begin{pmatrix} \\frac{3}{2}  1  20  0 \\end{pmatrix} } $$"
        },
        {
            "introduction": "The final step in the grid generation workflow is to assess the quality of the resulting mesh and determine if it meets the stringent requirements of numerical solvers. Poorly shaped triangles can compromise simulation accuracy and stability. This practice  guides you through a systematic mesh quality evaluation. You will learn to compute key quality metrics like minimum angle, analyze their statistical distribution via histograms, and apply a formal decision logic to recommend whether the mesh is ready for use or requires further intervention, such as smoothing or refinement.",
            "id": "3817836",
            "problem": "You are given planar meshes composed of triangles defined by vertex coordinates and triangle connectivity. For each mesh, you must compute angle-based quality histograms and decide whether additional refinement or smoothing is required to satisfy a minimum interior angle threshold $\\theta_{\\min}$ expressed in degrees. Work from first principles of Euclidean geometry and graph connectivity, and formalize the decision using only definitions and well-tested facts.\n\nFundamental base and definitions:\n- A mesh consists of a set of vertices with coordinates $\\{\\mathbf{x}_i \\in \\mathbb{R}^2\\}_{i=0}^{N_v-1}$ and a set of triangles $\\{(i,j,k)\\}_{m=0}^{N_t-1}$, where each triangle indexes three distinct vertices. For triangle $(i,j,k)$ with points $\\mathbf{a} = \\mathbf{x}_i$, $\\mathbf{b} = \\mathbf{x}_j$, $\\mathbf{c} = \\mathbf{x}_k$, define the edge vectors at a vertex by differences of position vectors. The interior angle at vertex $\\mathbf{a}$ is computed from the dot product as\n$$\n\\theta_a = \\arccos \\left( \\frac{ (\\mathbf{b}-\\mathbf{a}) \\cdot (\\mathbf{c}-\\mathbf{a}) }{ \\| \\mathbf{b}-\\mathbf{a} \\| \\, \\| \\mathbf{c}-\\mathbf{a} \\| } \\right ),\n$$\nwith analogous formulas for $\\theta_b$ and $\\theta_c$. The three interior angles of a non-degenerate triangle satisfy $\\theta_a + \\theta_b + \\theta_c = 180^\\circ$. All angles must be reported in degrees.\n- The minimum interior angle quality for triangle $m$ is\n$$\nq_m = \\min\\{ \\theta_a, \\theta_b, \\theta_c \\} \\quad \\text{(degrees)}.\n$$\n- The edge lengths are $\\ell_1 = \\| \\mathbf{b}-\\mathbf{a} \\|$, $\\ell_2 = \\| \\mathbf{c}-\\mathbf{b} \\|$, $\\ell_3 = \\| \\mathbf{a}-\\mathbf{c} \\|$. The anisotropy ratio for a triangle is\n$$\nr_m = \\frac{ \\max\\{ \\ell_1, \\ell_2, \\ell_3 \\} }{ \\min\\{ \\ell_1, \\ell_2, \\ell_3 \\} }.\n$$\n- A triangle is numerically degenerate if its unsigned area\n$$\nA_m = \\frac{1}{2} \\left| (\\mathbf{b}-\\mathbf{a}) \\times (\\mathbf{c}-\\mathbf{a}) \\right|\n$$\nis less than a tolerance $\\varepsilon > 0$. For degenerate triangles, set $q_m = 0$ and treat the anisotropy ratio as $+\\infty$.\n- The mesh has a set of histogram bin edges $\\mathcal{B} = [b_0, b_1, \\dots, b_K]$ with $b_0 = 0$ and $b_K \\ge 60$. Place each $q_m$ into a bin interval $[b_j, b_{j+1})$ except the last interval $[b_{K-1}, b_K]$ which is closed on both ends, and report integer counts per bin.\n- Let $\\mathcal{V} = \\{m : q_m  \\theta_{\\min}\\}$ denote the index set of violating triangles. Define the violation fraction\n$$\nf = \\frac{|\\mathcal{V}|}{N_t}.\n$$\n- Define an extremeness threshold relative to the minimum angle as $\\delta = c \\, \\theta_{\\min}$ with a constant $c \\in (0,1)$.\n- Define triangle adjacency on the vertex-sharing graph: two triangles $m$ and $n$ are adjacent if they share at least one vertex index. Consider the induced subgraph on $\\mathcal{V}$ and let $c_{\\max}$ be the size of the largest connected component.\n\nDecision logic to recommend smoothing or refinement:\n- If there are no violations, i.e., $|\\mathcal{V}| = 0$, then no smoothing and no refinement are required.\n- Otherwise, compute $f$, $r_{\\max} = \\max_{m \\in \\mathcal{V}} r_m$, $q_{\\min} = \\min_{m \\in \\mathcal{V}} q_m$, and $c_{\\max}$. Recommend smoothing if and only if all the following hold simultaneously:\n  1. $f \\le \\alpha$ (violations are limited in fraction),\n  2. $r_{\\max} \\le R_{\\text{lim}}$ (violating elements are not excessively anisotropic),\n  3. $q_{\\min} \\ge \\delta$ (no extremely small violating angles),\n  4. $c_{\\max}  \\kappa$ (no large clusters of violations).\n  If any of these conditions fails, recommend refinement instead. Output booleans for smoothing and refinement so that exactly one of them is true when violations exist.\n\nAngle units and numerical handling:\n- All angles must be computed and reported in degrees. Use radians internally only if converted back to degrees for outputs and comparisons.\n- Use a robust computation by clamping the argument of $\\arccos$ to the interval $[-1,1]$ to avoid floating-point errors.\n\nTest suite:\nFor each test case, you are given $(\\text{vertices}, \\text{triangles}, \\theta_{\\min}, \\mathcal{B}, R_{\\text{lim}}, \\alpha, \\kappa, \\varepsilon, c)$ with the following parameter values:\n\n- Test case $1$ (happy path, no violations):\n  - $\\text{vertices} = [(0,0),(1,0),(1,1),(0,1)]$\n  - $\\text{triangles} = [(0,1,2),(0,2,3)]$\n  - $\\theta_{\\min} = 30$ (degrees)\n  - $\\mathcal{B} = [0,10,20,30,40,50,60]$ (degrees)\n  - $R_{\\text{lim}} = 3$\n  - $\\alpha = 0.2$\n  - $\\kappa = 2$\n  - $\\varepsilon = 10^{-12}$\n  - $c=0.5$\n\n- Test case $2$ (isolated moderate violation, smoothing expected):\n  - $\\text{vertices} = [(0,0),(1,0),(1,1),(0,1),(0.5,0.2)]$\n  - $\\text{triangles} = [(0,1,4),(1,2,4),(2,3,4),(3,0,4)]$\n  - $\\theta_{\\min} = 25$ (degrees)\n  - $\\mathcal{B} = [0,10,20,30,40,50,60]$ (degrees)\n  - $R_{\\text{lim}} = 3$\n  - $\\alpha = 0.3$\n  - $\\kappa = 2$\n  - $\\varepsilon = 10^{-12}$\n  - $c=0.5$\n\n- Test case $3$ (clustered violations along a line, refinement expected):\n  - $\\text{vertices} = [(0,0),(1,0),(2,0),(3,0),(0.5,0.1),(1.5,0.1),(2.5,0.1)]$\n  - $\\text{triangles} = [(0,1,4),(1,2,5),(2,3,6)]$\n  - $\\theta_{\\min} = 20$ (degrees)\n  - $\\mathcal{B} = [0,10,20,30,40,50,60]$ (degrees)\n  - $R_{\\text{lim}} = 3$\n  - $\\alpha = 0.3$\n  - $\\kappa = 2$\n  - $\\varepsilon = 10^{-12}$\n  - $c=0.5$\n\n- Test case $4$ (boundary condition at equilateral threshold, no action):\n  - $\\text{vertices} = [(0,0),(1,0),(0.5,0.8660254037844386)]$\n  - $\\text{triangles} = [(0,1,2)]$\n  - $\\theta_{\\min} = 60$ (degrees)\n  - $\\mathcal{B} = [0,10,20,30,40,50,60]$ (degrees)\n  - $R_{\\text{lim}} = 3$\n  - $\\alpha = 0.2$\n  - $\\kappa = 2$\n  - $\\varepsilon = 10^{-12}$\n  - $c=0.5$\n\n- Test case $5$ (degenerate triangle, refinement required):\n  - $\\text{vertices} = [(0,0),(1,0),(2,0)]$\n  - $\\text{triangles} = [(0,1,2)]$\n  - $\\theta_{\\min} = 10$ (degrees)\n  - $\\mathcal{B} = [0,10,20,30,40,50,60]$ (degrees)\n  - $R_{\\text{lim}} = 3$\n  - $\\alpha = 0.2$\n  - $\\kappa = 2$\n  - $\\varepsilon = 10^{-12}$\n  - $c=0.5$\n\nRequired outputs per test case:\n- A list of histogram bin counts for the distribution of $\\{q_m\\}_{m=0}^{N_t-1}$ over $\\mathcal{B}$.\n- A boolean indicating whether smoothing is recommended.\n- A boolean indicating whether refinement is recommended.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list with no spaces, enclosed in square brackets. Each test case result must be a list in the form `[hist,smoothing,refinement]`, where `hist` is itself a list of integers. For example:\n`[[[h_11,h_12,...],True,False],[[h_21,...],False,True],...]`,\nbut printed without spaces, such as `[[[3,2,0,0,0,0],[...]],...]`.",
            "solution": "The problem is valid. It is a well-defined computational geometry task grounded in the principles of Euclidean geometry and graph theory, which are standard in the analysis of computational meshes. All required data, definitions, and decision logic are provided, making the problem self-contained, objective, and well-posed. A unique solution can be algorithmically determined for each test case.\n\nThe solution is implemented by following a systematic procedure for each test case. The procedure is divided into four main stages: (1) per-triangle geometric property calculation, (2) aggregation of quality metrics into a histogram, (3) identification of violating triangles and analysis of their collective properties, and (4) application of a formal decision logic to recommend a subsequent mesh adaptation action.\n\n**1. Per-Triangle Geometric Analysis**\n\nFor each triangle $m$ in the mesh, defined by vertices $\\mathbf{a} = \\mathbf{x}_i$, $\\mathbf{b} = \\mathbf{x}_j$, and $\\mathbf{c} = \\mathbf{x}_k$, we compute its fundamental geometric properties.\n\nFirst, we determine if the triangle is numerically degenerate. The area $A_m$ is computed using the 2D cross-product of the edge vectors originating from a common vertex:\n$$\nA_m = \\frac{1}{2} \\left| (\\mathbf{b}-\\mathbf{a}) \\times (\\mathbf{c}-\\mathbf{a}) \\right| = \\frac{1}{2} \\left| (x_b-x_a)(y_c-y_a) - (x_c-x_a)(y_b-y_a) \\right|\n$$\nIf $A_m$ is less than a small tolerance $\\varepsilon > 0$, the triangle is considered degenerate. For such triangles, the quality metric $q_m$ is set to $0$ and the anisotropy ratio $r_m$ is set to $+\\infty$.\n\nFor non-degenerate triangles, we compute the three interior angles. The angle $\\theta_a$ at vertex $\\mathbf{a}$ is given by the formula:\n$$\n\\theta_a = \\arccos \\left( \\frac{ (\\mathbf{b}-\\mathbf{a}) \\cdot (\\mathbf{c}-\\mathbf{a}) }{ \\| \\mathbf{b}-\\mathbf{a} \\| \\| \\mathbf{c}-\\mathbf{a} \\| } \\right )\n$$\nThe angles $\\theta_b$ and $\\theta_c$ are computed analogously. To ensure numerical stability, the argument of the $\\arccos$ function is clamped to the valid range $[-1, 1]$. The angles, computed in radians, are converted to degrees. The quality of the triangle, $q_m$, is then defined as the minimum of its three interior angles:\n$$\nq_m = \\min \\{ \\theta_a, \\theta_b, \\theta_c \\}\n$$\nWe also compute the edge lengths $\\ell_1 = \\| \\mathbf{b}-\\mathbf{a} \\|$, $\\ell_2 = \\| \\mathbf{c}-\\mathbf{b} \\|$, and $\\ell_3 = \\| \\mathbf{a}-\\mathbf{c} \\|$. The anisotropy ratio $r_m$ is the ratio of the longest edge to the shortest edge:\n$$\nr_m = \\frac{ \\max\\{ \\ell_1, \\ell_2, \\ell_3 \\} }{ \\min\\{ \\ell_1, \\ell_2, \\ell_3 \\} }\n$$\n\n**2. Mesh Quality Histogram**\n\nAfter computing the quality $q_m$ for all $N_t$ triangles in the mesh, we generate a histogram of these values. The bin edges are provided by the set $\\mathcal{B} = [b_0, b_1, \\dots, b_K]$. Each quality value $q_m$ is placed into one of the bins. The bins are defined as half-open intervals $[b_j, b_{j+1})$ for $j=0, \\dots, K-2$, and a closed interval $[b_{K-1}, b_K]$ for the last bin. The output for this stage is a list of integer counts for each bin.\n\n**3. Violation Analysis**\n\nA triangle $m$ is considered to be in violation of the quality criterion if its quality $q_m$ is less than a specified minimum angle threshold, $\\theta_{\\min}$. We define the set of violating triangles as $\\mathcal{V} = \\{ m : q_m  \\theta_{\\min} \\}$.\n\nIf $\\mathcal{V}$ is empty (i.e., $|\\mathcal{V}| = 0$), no further analysis is needed, and no mesh adaption is required.\n\nIf $\\mathcal{V}$ is non-empty, we compute four metrics that characterize the nature of the violations:\n1.  **Violation Fraction ($f$):** The fraction of triangles that are in violation, $f = \\frac{|\\mathcal{V}|}{N_t}$.\n2.  **Maximum Anisotropy ($r_{\\max}$):** The maximum anisotropy ratio among all violating triangles, $r_{\\max} = \\max_{m \\in \\mathcal{V}} r_m$.\n3.  **Minimum Quality ($q_{\\min}$):** The minimum quality value among all violating triangles, $q_{\\min} = \\min_{m \\in \\mathcal{V}} q_m$.\n4.  **Maximum Cluster Size ($c_{\\max}$):** This metric quantifies the spatial clustering of violating triangles. An adjacency graph is constructed where the nodes represent the triangles in $\\mathcal{V}$. An edge exists between two nodes if the corresponding triangles share at least one vertex. We then find the size of the largest connected component in this graph, denoted $c_{\\max}$. This is achieved by performing a graph traversal algorithm, like Breadth-First Search (BFS) or Depth-First Search (DFS), starting from each unvisited node to count the members of its component.\n\n**4. Decision Logic**\n\nThe final step is to recommend an action based on the computed metrics. The choice is between 'smoothing' (relocating vertices to improve quality) and 'refinement' (adding new vertices and triangles).\n\n- If $|\\mathcal{V}| = 0$, both smoothing and refinement are not recommended (booleans are `False`).\n- If $|\\mathcal{V}|  0$, smoothing is recommended if and only if all of the following conditions are met simultaneously:\n    1.  The violation fraction is small: $f \\le \\alpha$.\n    2.  The violating triangles are not excessively elongated: $r_{\\max} \\le R_{\\text{lim}}$.\n    3.  The violations are not extreme: $q_{\\min} \\ge \\delta$, where $\\delta = c \\cdot \\theta_{\\min}$.\n    4.  The violating triangles do not form large clusters: $c_{\\max}  \\kappa$.\n\nIf these four conditions hold, the recommendation is smoothing (`True`) and not refinement (`False`). If any condition fails, the recommendation is refinement (`True`) and not smoothing (`False`), ensuring that exactly one action is recommended when violations exist. This logic is based on the heuristic that localized, non-severe quality issues can often be fixed by smoothing, while widespread, severe, or highly clustered issues typically require the more expensive operation of refinement.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    # Test cases as defined in the problem statement.\n    test_cases = [\n        # Case 1: Happy path, no violations\n        (\n            [(0,0),(1,0),(1,1),(0,1)], \n            [(0,1,2),(0,2,3)], \n            30, [0,10,20,30,40,50,60], 3, 0.2, 2, 1e-12, 0.5\n        ),\n        # Case 2: Isolated moderate violation, smoothing expected\n        (\n            [(0,0),(1,0),(1,1),(0,1),(0.5,0.2)], \n            [(0,1,4),(1,2,4),(2,3,4),(3,0,4)], \n            25, [0,10,20,30,40,50,60], 3, 0.3, 2, 1e-12, 0.5\n        ),\n        # Case 3: Clustered violations, refinement expected\n        (\n            [(0,0),(1,0),(2,0),(3,0),(0.5,0.1),(1.5,0.1),(2.5,0.1)], \n            [(0,1,4),(1,2,5),(2,3,6)], \n            20, [0,10,20,30,40,50,60], 3, 0.3, 2, 1e-12, 0.5\n        ),\n        # Case 4: Boundary condition at equilateral, no action\n        (\n            [(0,0),(1,0),(0.5,0.8660254037844386)], \n            [(0,1,2)], \n            60, [0,10,20,30,40,50,60], 3, 0.2, 2, 1e-12, 0.5\n        ),\n        # Case 5: Degenerate triangle, refinement required\n        (\n            [(0,0),(1,0),(2,0)], \n            [(0,1,2)], \n            10, [0,10,20,30,40,50,60], 3, 0.2, 2, 1e-12, 0.5\n        ),\n    ]\n\n    all_results = [process_case(case) for case in test_cases]\n\n    # Final print statement in the exact required format.\n    # Convert the list of results to a string and remove all spaces.\n    final_output_string = str(all_results).replace(' ', '')\n    print(final_output_string)\n\ndef process_case(case_data):\n    \"\"\"\n    Processes a single test case to determine mesh quality and recommendations.\n    \"\"\"\n    vertices_list, triangles_list, theta_min, B, R_lim, alpha, kappa, epsilon, c = case_data\n    vertices = np.array(vertices_list, dtype=float)\n    triangles = np.array(triangles_list, dtype=int)\n    \n    Nt = len(triangles)\n    qualities_q = np.zeros(Nt)\n    anisotropy_r = np.zeros(Nt)\n    \n    for m, tri_indices in enumerate(triangles):\n        p1, p2, p3 = vertices[tri_indices]\n        \n        # Check for degeneracy using area calculation\n        area = 0.5 * abs((p2[0] - p1[0]) * (p3[1] - p1[1]) - (p3[0] - p1[0]) * (p2[1] - p1[1]))\n        \n        if area  epsilon:\n            qualities_q[m] = 0.0\n            anisotropy_r[m] = np.inf\n            continue\n            \n        # Edge lengths and anisotropy\n        l1 = np.linalg.norm(p2 - p1)\n        l2 = np.linalg.norm(p3 - p2)\n        l3 = np.linalg.norm(p1 - p3)\n        lengths = [l1, l2, l3]\n        if min(lengths)  epsilon: # Avoid division by zero for near-degenerate cases\n             anisotropy_r[m] = np.inf\n        else:\n             anisotropy_r[m] = max(lengths) / min(lengths)\n\n        # Interior angles\n        angles_deg = []\n        vecs = [(p2 - p1, p3 - p1, l1, l3), \n                (p1 - p2, p3 - p2, l1, l2),\n                (p1 - p3, p2 - p3, l3, l2)]\n\n        for v1, v2, len1, len2 in vecs:\n            cos_theta = np.dot(v1, v2) / (len1 * len2)\n            cos_theta = np.clip(cos_theta, -1.0, 1.0)\n            angle_rad = np.arccos(cos_theta)\n            angles_deg.append(np.degrees(angle_rad))\n        \n        qualities_q[m] = np.min(angles_deg)\n\n    # Histogram of quality metrics\n    hist, _ = np.histogram(qualities_q, bins=B)\n    \n    # Decision logic\n    violating_indices = np.where(qualities_q  theta_min)[0]\n    num_violations = len(violating_indices)\n    \n    if num_violations == 0:\n        return [hist.tolist(), False, False]\n        \n    f = num_violations / Nt\n    \n    q_violating = qualities_q[violating_indices]\n    r_violating = anisotropy_r[violating_indices]\n    \n    q_min_viol = np.min(q_violating)\n    r_max_viol = np.max(r_violating)\n    \n    delta = c * theta_min\n    \n    # Adjacency graph and connected components\n    c_max = 0\n    if num_violations  0:\n        violating_tri_verts = [set(triangles[i]) for i in violating_indices]\n        adj = {i: [] for i in range(num_violations)}\n        for i in range(num_violations):\n            for j in range(i + 1, num_violations):\n                if violating_tri_verts[i].intersection(violating_tri_verts[j]):\n                    adj[i].append(j)\n                    adj[j].append(i)\n        \n        visited = set()\n        for i in range(num_violations):\n            if i not in visited:\n                component_size = 0\n                q = [i]\n                visited.add(i)\n                head = 0\n                while head  len(q):\n                    u = q[head]\n                    head += 1\n                    component_size += 1\n                    for v in adj[u]:\n                        if v not in visited:\n                            visited.add(v)\n                            q.append(v)\n                c_max = max(c_max, component_size)\n\n    # Apply decision rules\n    smoothing_recommended = (f = alpha and \n                             r_max_viol = R_lim and \n                             q_min_viol = delta and \n                             c_max  kappa)\n                             \n    refinement_recommended = not smoothing_recommended\n    \n    return [hist.tolist(), smoothing_recommended, refinement_recommended]\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}