{
    "hands_on_practices": [
        {
            "introduction": "在为复杂的海岸线和岛屿生成非结构化网格之前，确保输入几何数据的有效性是至关重要的第一步。本练习将引导您从基本原理出发，验证定义计算域的多边形边界。您将学习如何使用鞋带公式（shoelace formula）计算多边形的有向面积，以确保外部边界（如海岸线）为逆时针方向，而内部边界（如岛屿）为顺时针方向，这是大多数网格生成器所要求的标准约定 。通过实践，您将掌握保证网格生成过程稳健性的基础计算几何技能。",
            "id": "3817799",
            "problem": "在计算海洋学中，为海岸区域生成非结构化网格时，要求代表海岸线（外边界）和内部障碍物（如岛屿或湖泊，即孔洞）的多边形边界遵循一致的方向约定。根据地理信息系统（GIS）网格划分工具链使用的标准笛卡尔坐标约定，外边界必须是逆时针方向，而孔洞必须是顺时针方向。该约定利用了多边形有符号面积的正负号，其中沿逆时针方向遍历时有符号面积为正，沿顺时针方向遍历时为负。目标是根据第一性原理精确计算有符号面积，并用其验证方向，同时检查几何有效性（非自相交），以确保这些边界可以被三角剖分程序安全使用。\n\n从作为线积分的平面面积的基本原理以及简单多边形作为一条边不相交的闭合分段线性曲线的定义出发，推导并实现一个程序，该程序能够：\n\n- 基于多边形边界上的线积分的离散求值，计算由有序顶点 $\\{(x_i,y_i)\\}_{i=0}^{n-1}$定义的多边形的有符号面积，其中所有坐标单位均为米。面积的符号必须编码遍历方向。\n- 使用计算出的面积的符号来确定方向，强制要求外边界具有正的有符号面积（逆时针），每个孔洞具有负的有符号面积（顺时针）。\n- 通过测试所有非相邻边对是否相交，来验证每个多边形都是简单多边形（无自相交）。\n- 应用面积量级阈值 $\\varepsilon$ 来拒绝退化多边形，即 $|A| \\le \\varepsilon$ 的多边形，其中 $A$ 是有符号面积。使用 $\\varepsilon = 10^{-6}$ 平方米。\n- 以平方米表示面积，并四舍五入到三位小数。\n\n您的程序必须评估以下测试套件，其中每个测试用例包含一个外边界多边形和零个或多个孔洞多边形。所有坐标单位均为米，顶点按其遍历顺序列出。\n\n测试用例 $1$（理想情况：有效的简单多边形和正确的方向）：\n- 外边界（逆时针）：$\\big[(0,0),(1000,0),(1000,500),(0,500)\\big]$\n- 孔洞（顺时针）：一个孔洞 $\\big[(200,100),(250,200),(300,100)\\big]$\n\n测试用例 $2$（方向错误：有效的简单多边形但方向错误）：\n- 外边界（顺时针）：$\\big[(0,500),(1000,500),(1000,0),(0,0)\\big]$\n- 孔洞（逆时针）：一个孔洞 $\\big[(300,100),(250,200),(200,100)\\big]$\n\n测试用例 $3$（退化的外边界：共线顶点导致零面积）：\n- 外边界：$\\big[(0,0),(500,0),(1000,0),(0,0)\\big]$\n- 孔洞：无\n\n测试用例 $4$（自相交的外边界：领结形状）：\n- 外边界：$\\big[(0,0),(1000,0),(200,500),(800,500)\\big]$\n- 孔洞：无\n\n对于每个测试用例，程序必须生成一个结果，包含：\n- 外边界的有符号面积（平方米），四舍五入到三位小数。\n- 孔洞的有符号面积列表（平方米），每个均四舍五入到三位小数（若无孔洞则为空列表）。\n- 一个布尔值，指示整个用例是否对网格划分有效。有效性要求：外边界是简单多边形且其正有符号面积大于 $\\varepsilon$，并且每个孔洞都是简单多边形且其负有符号面积小于 $-\\varepsilon$。\n\n最终输出格式：您的程序应生成一行输出，其中包含一个由方括号括起来的逗号分隔列表。每个元素对应一个测试用例，并且其本身必须是 $\\big[ A_{\\text{outer}}, [A_{\\text{holes}}], \\text{valid} \\big]$ 形式的列表，其中 $A_{\\text{outer}}$ 是一个浮点数，$[A_{\\text{holes}}]$ 是一个浮点数列表，$\\text{valid}$ 是一个布尔值。例如，输出必须类似于 $\\big[[\\dots],[\\dots],[\\dots],[\\dots]\\big]$，包含四个元素，每个元素对应一个测试用例。",
            "solution": "所述问题是有效的。它在科学上基于矢量微积分和计算几何的原理，定义和约束条件完整且一致，是一个适定的问题，并且完全客观。所要求的任务——计算多边形有符号面积和检测自相交——是海洋模型计算网格生成领域内的标准、可形式化的问题。所有用于验证的数据和标准都已明确提供。\n\n解决方案将分三个主要阶段进行：首先，根据线积分原理推导多边形有符号面积的公式；其次，构建一个用于检测多边形自相交的算法；第三，将这些组件综合成一个适用于每个测试用例的全面验证程序。\n\n### 1. 有符号面积的计算\n\n一个由曲线 $C$ 界定的简单闭合平面区域 $D$ 的有符号面积 $A$ 可以使用格林公式计算，该公式将环绕 $C$ 的线积分与在 $D$ 上的二重积分联系起来：\n$$\n\\oint_C (L \\, dx + M \\, dy) = \\iint_D \\left(\\frac{\\partial M}{\\partial x} - \\frac{\\partial L}{\\partial y}\\right) \\, dA\n$$\n为了计算面积 $A = \\iint_D dA$，我们必须选择函数 $L(x, y)$ 和 $M(x, y)$ 使得 $\\frac{\\partial M}{\\partial x} - \\frac{\\partial L}{\\partial y} = 1$。一个使被积函数对称的标准选择是 $L = -y/2$ 和 $M = x/2$。将它们代入格林公式，得到计算面积的线积分：\n$$\nA = \\frac{1}{2} \\oint_C (x \\, dy - y \\, dx)\n$$\n问题通过一个包含 $n$ 个顶点的有序序列 $\\{(x_i, y_i)\\}_{i=0}^{n-1}$ 来定义一个多边形。闭合边界 $C$ 是连接相邻顶点的线段的并集，即从 $(x_i, y_i)$ 到 $(x_{i+1}, y_{i+1})$，其中 $i = 0, \\dots, n-1$，索引对 $n$ 取模，使得 $(x_n, y_n) = (x_0, y_0)$。因此，线积分是这 $n$ 条线段上积分的总和：\n$$\nA = \\frac{1}{2} \\sum_{i=0}^{n-1} \\int_{(x_i, y_i)}^{(x_{i+1}, y_{i+1})} (x \\, dy - y \\, dx)\n$$\n对于从 $(x_i, y_i)$ 到 $(x_{i+1}, y_{i+1})$ 的单条线段，我们可以使用参数 $t \\in [0, 1]$ 对路径进行参数化：\n$$\n\\begin{align*}\nx(t) = x_i + t(x_{i+1} - x_i) \\implies dx = (x_{i+1} - x_i) \\, dt \\\\\ny(t) = y_i + t(y_{i+1} - y_i) \\implies dy = (y_{i+1} - y_i) \\, dt\n\\end{align*}\n$$\n将此代入单条线段的积分，并从 $t=0$ 积分到 $t=1$：\n$$\n\\int_0^1 \\left[ (x_i + t\\Delta x_i)( \\Delta y_i ) - (y_i + t\\Delta y_i)( \\Delta x_i ) \\right] \\, dt\n$$\n其中 $\\Delta x_i = x_{i+1} - x_i$ 且 $\\Delta y_i = y_{i+1} - y_i$。被积函数简化为：\n$$\n(x_i \\Delta y_i + t\\Delta x_i \\Delta y_i) - (y_i \\Delta x_i + t\\Delta y_i \\Delta x_i) = x_i \\Delta y_i - y_i \\Delta x_i = x_i(y_{i+1}-y_i) - y_i(x_{i+1}-x_i) = x_i y_{i+1} - y_i x_{i+1}\n$$\n此表达式相对于 $t$ 是一个常数。积分值就是该常数值乘以区间长度（即 $1$）。\n$$\n\\int_{(x_i, y_i)}^{(x_{i+1}, y_{i+1})} (x \\, dy - y \\, dx) = x_i y_{i+1} - y_i x_{i+1}\n$$\n将所有线段的积分求和，得到最终的离散化公式，即鞋带公式或测量师公式：\n$$\nA = \\frac{1}{2} \\sum_{i=0}^{n-1} (x_i y_{i+1} - x_{i+1} y_i)\n$$\n$A$ 的符号取决于顶点的顺序。根据与格林公式相关的右手法则约定，逆时针（CCW）遍历产生正面积，而顺时针（CW）遍历产生负面积。\n\n### 2. 自相交检测（简单多边形测试）\n\n如果一个多边形的边除了相邻边仅在其共享顶点处相交外，不与任何其他边相交，则该多边形是简单的。为验证一个多边形是否为简单多边形，我们必须测试每对非相邻边是否相交。\n\n设一条边由两个顶点定义。对于一个有 $n$ 个顶点的多边形，我们有 $n$ 条边 $e_0, e_1, \\dots, e_{n-1}$，其中 $e_i$ 连接顶点 $v_i$ 和 $v_{i+1}$（索引对 $n$ 取模）。我们必须检查每一对 $(e_i, e_j)$，其中 $i  j$ 且 $e_i$ 和 $e_j$ 不相邻。如果两条边 $e_i$ 和 $e_j$ 共享一个顶点，则它们是相邻的，这发生在 $j = i+1$ 或 $i=0$ 且 $j=n-1$ 的情况下。\n\n两条线段（比如 $P_1P_2$ 和 $P_3P_4$）相交的几何测试基于一系列方向测试。一个有序三点组 $(P_a, P_b, P_c)$ 的方向由向量 $\\vec{P_aP_b}$ 和 $\\vec{P_bP_c}$ 的叉积的符号决定：\n$$\n\\text{orientation}(P_a, P_b, P_c) = \\text{sign}((y_b - y_a)(x_c - x_b) - (x_b - x_a)(y_c - y_b))\n$$\n正号表示逆时针转向（左转），负号表示顺时针转向（右转），值为 $0$ 表示三点共线。\n\n两条非共线线段 $P_1P_2$ 和 $P_3P_4$ 相交，当且仅当方向 $(P_1, P_2, P_3)$ 和 $(P_1, P_2, P_4)$ 不同，并且方向 $(P_3, P_4, P_1)$ 和 $(P_3, P_4, P_2)$ 也不同。\n\n共线情况需要特殊处理。如果方向测试显示三点共线（例如 $(P_1, P_2, P_3)$ 共线），我们必须接着检查点 $P_3$ 是否位于线段 $P_1P_2$ 上。如果它的坐标落在该线段的包围盒内，则成立：\n$$\nx_3 \\in [\\min(x_1, x_2), \\max(x_1, x_2)] \\quad \\text{and} \\quad y_3 \\in [\\min(y_1, y_2), \\max(y_1, y_2)]\n$$\n如果有任何一对非相邻边通过了这个相交测试，那么多边形就不是简单的。\n\n### 3. 综合验证逻辑\n\n对于每个测试用例，我们应用推导出的方法来确定其对网格划分的整体有效性。面积量级阈值为 $\\varepsilon = 10^{-6} \\text{m}^2$。\n\n1.  **外边界多边形：**\n    a. 使用鞋带公式计算其有符号面积 $A_{\\text{outer}}$。\n    b. 通过测试所有非相邻边对是否相交，检查多边形是否为简单多边形。\n    c. 外边界有效的条件是：它是一个简单多边形，并且其面积 $A_{\\text{outer}} > \\varepsilon$。\n\n2.  **孔洞多边形（对每个孔洞）：**\n    a. 使用鞋带公式计算其有符号面积 $A_{\\text{hole}}$。\n    b. 检查多边形是否为简单多边形。\n    c. 每个孔洞有效的条件是：它是一个简单多边形，并且其面积 $A_{\\text{hole}}  -\\varepsilon$。\n\n3.  **整体用例有效性：**\n    一个测试用例整体有效，当且仅当其外边界有效，并且其所有孔洞多边形都有效。如果任何一个组成部分未能通过其检查，则整个用例被视为对网格划分无效。\n\n每个测试用例的最终输出将是一个列表，包含四舍五入后的外边界有符号面积、一个包含所有孔洞四舍五入后有符号面积的列表，以及一个指示该用例整体有效性的布尔标志。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates and solves the computational geometry problem for unstructured grid generation.\n    \"\"\"\n    \n    # Area magnitude threshold for rejecting degenerate polygons.\n    EPSILON = 1e-6\n\n    def calculate_signed_area(polygon):\n        \"\"\"\n        Calculates the signed area of a polygon using the shoelace formula.\n        A counter-clockwise polygon has positive area, clockwise has negative area.\n        \n        Args:\n            polygon (list of tuples): A list of (x, y) vertex coordinates.\n        \n        Returns:\n            float: The signed area of the polygon.\n        \"\"\"\n        n = len(polygon)\n        if n  3:\n            return 0.0\n        \n        area = 0.0\n        for i in range(n):\n            x1, y1 = polygon[i]\n            x2, y2 = polygon[(i + 1) % n]\n            area += (x1 * y2 - x2 * y1)\n        \n        return area / 2.0\n\n    def orientation(p, q, r):\n        \"\"\"\n        Finds the orientation of the ordered triplet (p, q, r).\n        \n        Returns:\n            0: Collinear points\n            1: Clockwise (right turn)\n            2: Counter-Clockwise (left turn)\n        \"\"\"\n        val = (q[1] - p[1]) * (r[0] - q[0]) - \\\n              (q[0] - p[0]) * (r[1] - q[1])\n        if abs(val)  1e-9: # Use tolerance for floating point\n            return 0  # Collinear\n        return 1 if val  0 else 2  # Clockwise or Counter-Clockwise\n\n    def on_segment(p, q, r):\n        \"\"\"\n        Given three collinear points p, q, r, the function checks if point q \n        lies on line segment 'pr'.\n        \"\"\"\n        return (q[0] = max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and\n                q[1] = max(p[1], r[1]) and q[1] >= min(p[1], r[1]))\n\n    def segments_intersect(p1, q1, p2, q2):\n        \"\"\"\n        Checks if line segment 'p1q1' and 'p2q2' intersect.\n        \"\"\"\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n\n        # General case: Segments cross each other.\n        if o1 != 0 and o2 != 0 and o3 != 0 and o4 != 0:\n            if o1 != o2 and o3 != o4:\n                return True\n        \n        # Special Cases for collinear intersections.\n        if o1 == 0 and on_segment(p1, p2, q1): return True\n        if o2 == 0 and on_segment(p1, q2, q1): return True\n        if o3 == 0 and on_segment(p2, p1, q2): return True\n        if o4 == 0 and on_segment(p2, q1, q2): return True\n\n        return False\n\n    def is_simple_polygon(polygon):\n        \"\"\"\n        Checks if a polygon is simple (does not self-intersect).\n        Tests all non-adjacent edge pairs for intersection.\n        \"\"\"\n        n = len(polygon)\n        if n  4:\n            return True # Triangles cannot self-intersect\n\n        for i in range(n):\n            p1 = polygon[i]\n            q1 = polygon[(i + 1) % n]\n            \n            # j starts from i+2 to avoid checking adjacent segments\n            for j in range(i + 2, n):\n                # The last edge (n-1, 0) is adjacent to the first edge (0,1).\n                # This case needs to be skipped. i=0, j=n-1\n                if i == 0 and j == n - 1:\n                    continue\n                \n                p2 = polygon[j]\n                q2 = polygon[(j + 1) % n]\n                \n                if segments_intersect(p1, q1, p2, q2):\n                    return False\n        return True\n\n    test_cases = [\n        {\n            \"outer\": [(0,0),(1000,0),(1000,500),(0,500)],\n            \"holes\": [[(200,100),(250,200),(300,100)]]\n        },\n        {\n            \"outer\": [(0,500),(1000,500),(1000,0),(0,0)],\n            \"holes\": [[(300,100),(250,200),(200,100)]]\n        },\n        {\n            \"outer\": [(0,0),(500,0),(1000,0),(0,0)],\n            \"holes\": []\n        },\n        {\n            \"outer\": [(0,0),(1000,0),(200,500),(800,500)],\n            \"holes\": []\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        case_is_valid = True\n        \n        # Process outer boundary\n        outer_poly = case[\"outer\"]\n        outer_area = calculate_signed_area(outer_poly)\n        outer_is_simple = is_simple_polygon(outer_poly)\n        \n        if not (outer_is_simple and outer_area  EPSILON):\n            case_is_valid = False\n            \n        # Process holes\n        hole_areas = []\n        for hole_poly in case[\"holes\"]:\n            hole_area = calculate_signed_area(hole_poly)\n            hole_areas.append(hole_area)\n            hole_is_simple = is_simple_polygon(hole_poly)\n            if not (hole_is_simple and hole_area  -EPSILON):\n                case_is_valid = False\n\n        # Format results for output\n        rounded_outer_area = round(outer_area, 3)\n        rounded_hole_areas = [round(a, 3) for a in hole_areas]\n        \n        # Construct the string representation for the current result manually\n        hole_areas_str = '[' + ','.join(map(str, rounded_hole_areas)) + ']'\n        result_str = f\"[{rounded_outer_area},{hole_areas_str},{case_is_valid}]\"\n        results.append(result_str)\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "生成初始网格后，通常需要通过“平滑”处理来提高其单元质量。本练习介绍了一种先进的、基于优化的网格平滑方法，它超越了简单的启发式算法。您将构建一个全局目标函数 $J(\\mathbf{x})$，该函数巧妙地结合了多个相互竞争的目标：最大化单元的形状质量、使边长适应物理场（如水深）的梯度，并防止单元反转 。通过使用数值优化技术最小化该函数来调整内部顶点的位置，您可以生成不仅几何形状良好，而且能有效解析关键海洋学特征的高质量网格。",
            "id": "3817793",
            "problem": "您的任务是为计算海洋学中使用的二维非结构化三角网格设计一种基于优化的顶点平滑方法。该平滑方法必须仅移动内部顶点，以最小化一个结合了质量度量倒数的全局目标函数，同时强制边界顶点固定。该方法应从第一性原理出发进行构建，并按照最终输出格式的要求，实现为一个完整的、可运行的程序。\n\n考虑一个多边形域 $\\Omega \\subset \\mathbb{R}^2$，其由一组顶点 $\\{\\mathbf{v}_i\\}_{i=0}^{N-1}$（其中 $\\mathbf{v}_i = (x_i,y_i)$）和一组以引用顶点的索引三元组 $(i,j,k)$ 表示的三角形 $\\mathcal{T}$ 离散化。令 $\\mathcal{B} \\subset \\{0,1,\\dots,N-1\\}$ 表示边界顶点集。内部顶点位于 $\\mathcal{I} = \\{0,1,\\dots,N-1\\} \\setminus \\mathcal{B}$ 中。令无向边集为由 $\\mathcal{T}$ 导出的 $\\mathcal{E}$。\n\n基本原理如下：\n- 顶点为 $\\mathbf{v}_i$、$\\mathbf{v}_j$、$\\mathbf{v}_k$ 的三角形的有向面积由下式给出\n$$\nA(i,j,k) = \\frac{1}{2} \\left[(x_j - x_i)(y_k - y_i) - (y_j - y_i)(x_k - x_i)\\right].\n$$\n- 边 $(i,j)$ 的欧几里得长度为\n$$\n\\ell(i,j) = \\|\\mathbf{v}_j - \\mathbf{v}_i\\|_2 = \\sqrt{(x_j - x_i)^2 + (y_j - y_i)^2}.\n$$\n- 三角形 $(i,j,k)$ 的平均比质量定义为\n$$\nq_{\\mathrm{mr}}(i,j,k) = \\frac{4\\sqrt{3}\\,|A(i,j,k)|}{\\ell(i,j)^2 + \\ell(j,k)^2 + \\ell(k,i)^2},\n$$\n对于非退化三角形，该值满足 $0  q_{\\mathrm{mr}} \\leq 1$，等边三角形可达到 $q_{\\mathrm{mr}} = 1$。\n\n在计算海洋学中，网格分辨率应适应诸如水深等场的空间变异性。定义一个平滑的水深代理\n$$\nH(x,y) = \\sin(2\\pi x)\\sin(2\\pi y),\n$$\n其梯度大小为\n$$\n\\|\\nabla H(x,y)\\| = \\sqrt{\\left(2\\pi\\cos(2\\pi x)\\sin(2\\pi y)\\right)^2 + \\left(2\\pi\\sin(2\\pi x)\\cos(2\\pi y)\\right)^2}.\n$$\n对于每个中点为 $\\mathbf{m}_{ij} = \\frac{1}{2}(\\mathbf{v}_i + \\mathbf{v}_j)$ 的边 $(i,j)\\in\\mathcal{E}$，定义一个目标长度\n$$\ns(i,j) = \\frac{s_0}{1 + \\beta \\|\\nabla H(\\mathbf{m}_{ij})\\|},\n$$\n其中 $s_0  0$ 是基础长度，$\\beta \\geq 0$ 控制自适应强度。\n\n为顶点位置 $\\mathbf{x} = [x_i,y_i]_{i\\in\\mathcal{I}}$ 构建全局目标函数，同时保持 $b\\in\\mathcal{B}$ 的 $\\mathbf{v}_b$ 固定：\n$$\nJ(\\mathbf{x}) = \\sum_{(i,j,k)\\in\\mathcal{T}} w_{ijk} \\,\\frac{1}{\\epsilon + q_{\\mathrm{mr}}(i,j,k)} \\;+\\; \\gamma \\sum_{(i,j)\\in\\mathcal{E}} \\left(\\frac{\\ell(i,j) - s(i,j)}{s(i,j)}\\right)^2 \\;+\\; \\mu \\sum_{(i,j,k)\\in\\mathcal{T}} \\Phi\\big(A(i,j,k)\\big),\n$$\n其中 $w_{ijk}  0$ 是每个三角形的权重，$\\epsilon  0$ 是一个小的正则化常数，$\\gamma \\geq 0$ 控制边长一致性惩罚，$\\mu  0$ 是一个障碍项的权重，该障碍项强制正向定向并防止单元反转。使用\n$$\n\\Phi(A) =\n\\begin{cases}\n-\\log(A),  A  \\delta,\\\\\n+\\infty,  A \\leq \\delta,\n\\end{cases}\n$$\n其中 $\\delta  0$ 是一个小阈值。在实践中，为确保有限精度算术中的数值鲁棒性，将 $A \\leq \\delta$ 的情况视为一个巨大的惩罚值。\n\n设计一种基于优化的平滑方法，在满足以下约束的情况下，最小化关于内部顶点位置的 $J(\\mathbf{x})$：\n- 边界顶点保持固定：对于所有 $b\\in\\mathcal{B}$，$\\mathbf{v}_b$ 是常数。\n- 内部顶点被约束在边界顶点的轴对齐包围盒内，即对于每个 $i\\in\\mathcal{I}$ 的 $(x_i,y_i)$，强制执行\n$$\nx_{\\min} \\leq x_i \\leq x_{\\max}, \\quad y_{\\min} \\leq y_i \\leq y_{\\max},\n$$\n其中 $x_{\\min} = \\min_{b\\in\\mathcal{B}} x_b$, $x_{\\max} = \\max_{b\\in\\mathcal{B}} x_b$, $y_{\\min} = \\min_{b\\in\\mathcal{B}} y_b$, $y_{\\max} = \\max_{b\\in\\mathcal{B}} y_b$。\n\n您的程序必须：\n- 按照规定实现目标函数 $J(\\mathbf{x})$，并使用合适的数值优化方法将其最小化。\n- 对于下述每个测试用例，输出优化后所有三角形的 $q_{\\mathrm{mr}}$ 的最终平均值，\n$$\n\\bar{q}_{\\mathrm{mr}} = \\frac{1}{|\\mathcal{T}|}\\sum_{(i,j,k)\\in\\mathcal{T}} q_{\\mathrm{mr}}(i,j,k),\n$$\n作为一个浮点数。\n\n测试套件：\n- 案例 1 (理想路径)：具有一个内部顶点的正方形域，均匀尺寸目标。\n  - 顶点：$\\mathbf{v}_0=(0,0)$, $\\mathbf{v}_1=(1,0)$, $\\mathbf{v}_2=(1,1)$, $\\mathbf{v}_3=(0,1)$, $\\mathbf{v}_4=(0.5,0.5)$。\n  - 三角形：$(0,1,4)$, $(1,2,4)$, $(2,3,4)$, $(3,0,4)$。\n  - 边界集：$\\mathcal{B}=\\{0,1,2,3\\}$。\n  - 参数：对所有三角形，$w_{ijk}=1$， $s_0=0.5$, $\\beta=0$, $\\gamma=0$, $\\mu=0.01$, $\\epsilon=10^{-8}$, $\\delta=10^{-12}$。\n- 案例 2 (近退化的内部顶点放置)：与案例 1 相同，但初始内部顶点为 $\\mathbf{v}_4=(0.9,0.1)$ 以产生质量差的三角形；参数与案例 1 相同。\n- 案例 3 (各向异性自适应)：具有两个内部顶点的正方形域，并对水深梯度进行自适应。\n  - 顶点：$\\mathbf{v}_0=(0,0)$, $\\mathbf{v}_1=(1,0)$, $\\mathbf{v}_2=(1,1)$, $\\mathbf{v}_3=(0,1)$, $\\mathbf{v}_4=(0.3,0.5)$, $\\mathbf{v}_5=(0.7,0.5)$。\n  - 三角形：$(0,1,4)$, $(0,4,3)$, $(1,2,5)$, $(2,3,5)$, $(1,5,4)$, $(3,4,5)$。\n  - 边界集：$\\mathcal{B}=\\{0,1,2,3\\}$。\n  - 参数：对所有三角形，$w_{ijk}=1$， $s_0=0.35$, $\\beta=1.0$, $\\gamma=1.0$, $\\mu=0.01$, $\\epsilon=10^{-8}$, $\\delta=10^{-12}$。\n- 案例 4 (无内部顶点)：用一条对角线进行三角剖分的正方形域，不执行优化。\n  - 顶点：$\\mathbf{v}_0=(0,0)$, $\\mathbf{v}_1=(1,0)$, $\\mathbf{v}_2=(1,1)$, $\\mathbf{v}_3=(0,1)$。\n  - 三角形：$(0,1,2)$, $(0,2,3)$。\n  - 边界集：$\\mathcal{B}=\\{0,1,2,3\\}$。\n  - 参数：对所有三角形，$w_{ijk}=1$， $s_0=0.5$, $\\beta=0$, $\\gamma=0$, $\\mu=0.01$, $\\epsilon=10^{-8}$, $\\delta=10^{-12}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个测试用例的结果，形式为方括号括起来的逗号分隔列表，例如 $[\\bar{q}_1,\\bar{q}_2,\\bar{q}_3,\\bar{q}_4]$。每个 $\\bar{q}_i$ 必须是浮点数。不得打印任何其他文本。",
            "solution": "目标是平滑非结构化三角网格的内部顶点，以提高与计算海洋学相关的全局网格质量，同时保留边界顶点以遵循海岸边界。我们从基本几何定义出发，构建一个对内部顶点坐标进行最小化的目标函数。\n\n我们从几何基元开始。对于每个三角形 $(i,j,k)$，其有向面积 $A(i,j,k)$ 由其边向量的叉积定义，得到\n$$\nA(i,j,k) = \\frac{1}{2}\\left[(x_j - x_i)(y_k - y_i) - (y_j - y_i)(x_k - x_i)\\right],\n$$\n对于逆时针方向，其为正；对于顺时针方向，其为负。边 $(i,j)$ 的欧几里得长度为\n$$\n\\ell(i,j) = \\sqrt{(x_j - x_i)^2 + (y_j - y_i)^2}.\n$$\n我们通过平均比质量来衡量三角形质量\n$$\nq_{\\mathrm{mr}}(i,j,k) = \\frac{4\\sqrt{3}\\,|A(i,j,k)|}{\\ell(i,j)^2 + \\ell(j,k)^2 + \\ell(k,i)^2}.\n$$\n该度量值界于 $0  q_{\\mathrm{mr}} \\leq 1$ 之间，等边三角形达到 1，退化构型趋近于 0。在海洋模型离散化中，质量差的单元会引入数值误差和伪扩散。因此，最小化质量度量倒数之和可以有效地惩罚形状不佳的三角形：\n$$\n\\sum_{(i,j,k)\\in\\mathcal{T}} w_{ijk}\\frac{1}{\\epsilon + q_{\\mathrm{mr}}(i,j,k)}.\n$$\n小常数 $\\epsilon  0$ 通过避免除以零来确保数值稳定性，而 $w_{ijk}  0$ 允许选择性加权（此处为均匀加权）。\n\n海洋学网格的分辨率通常需要适应水深地貌特征的空间梯度。我们引入一个平滑的代理场\n$$\nH(x,y) = \\sin(2\\pi x)\\sin(2\\pi y),\n$$\n其梯度大小为\n$$\n\\|\\nabla H(x,y)\\| = \\sqrt{\\left(2\\pi\\cos(2\\pi x)\\sin(2\\pi y)\\right)^2 + \\left(2\\pi\\sin(2\\pi x)\\cos(2\\pi y)\\right)^2}.\n$$\n对于每个中点为 $\\mathbf{m}_{ij} = \\frac{1}{2}(\\mathbf{v}_i + \\mathbf{v}_j)$ 的边 $(i,j)$，我们定义目标长度\n$$\ns(i,j) = \\frac{s_0}{1 + \\beta \\|\\nabla H(\\mathbf{m}_{ij})\\|},\n$$\n该长度随梯度大小的增加而减小，反映了在陡峭的水深梯度附近需要更精细的目标分辨率。我们包含一个边长一致性惩罚项：\n$$\n\\gamma \\sum_{(i,j)\\in\\mathcal{E}} \\left(\\frac{\\ell(i,j) - s(i,j)}{s(i,j)}\\right)^2,\n$$\n其中 $\\gamma \\geq 0$ 控制其贡献。\n\n为防止优化过程中的三角形反转，我们引入一个强制正向定向的障碍。理想情况下，我们使用\n$$\n\\Phi(A) = -\\log(A), \\quad A  0,\n$$\n当 $A \\to 0^+$ 时，其趋向于 $+\\infty$。在数值上，我们采用一个阈值 $\\delta  0$，并将 $A \\leq \\delta$ 的情况视为一个固定的巨大惩罚，因此：\n$$\n\\Phi(A) =\n\\begin{cases}\n-\\log(A),  A  \\delta,\\\\\n+\\infty\\ (\\text{实现为一个大常数}),  A \\leq \\delta.\n\\end{cases}\n$$\n障碍项由 $\\mu  0$ 加权，并对所有三角形求和。\n\n结合这些部分，内部顶点位置 $\\mathbf{x}$ 的全局目标函数为\n$$\nJ(\\mathbf{x}) = \\sum_{(i,j,k)\\in\\mathcal{T}} w_{ijk}\\frac{1}{\\epsilon + q_{\\mathrm{mr}}(i,j,k)} \\;+\\; \\gamma \\sum_{(i,j)\\in\\mathcal{E}} \\left(\\frac{\\ell(i,j) - s(i,j)}{s(i,j)}\\right)^2 \\;+\\; \\mu \\sum_{(i,j,k)\\in\\mathcal{T}} \\Phi\\big(A(i,j,k)\\big).\n$$\n我们在保持边界顶点固定的同时，对内部顶点坐标最小化 $J(\\mathbf{x})$：\n$$\n\\mathbf{v}_b = \\text{constant}, \\quad \\forall b \\in \\mathcal{B}.\n$$\n我们将内部顶点约束在边界的轴对齐包围盒内，其边界为\n$$\nx_{\\min} \\leq x_i \\leq x_{\\max}, \\quad y_{\\min} \\leq y_i \\leq y_{\\max}, \\quad \\forall i \\in \\mathcal{I},\n$$\n其中 $x_{\\min} = \\min_{b\\in\\mathcal{B}} x_b$, $x_{\\max} = \\max_{b\\in\\mathcal{B}} x_b$, $y_{\\min} = \\min_{b\\in\\mathcal{B}} y_b$, $y_{\\max} = \\max_{b\\in\\mathcal{B}} y_b$。这可以防止顶点漂移出域外，并与海岸边界约束保持一致。\n\n算法设计：\n- 从所有三角形的边中收集唯一的无向对 $(\\min(i,j),\\max(i,j))$，从而从 $\\mathcal{T}$ 构建边集 $\\mathcal{E}$。\n- 实现计算 $A(i,j,k)$、$\\ell(i,j)$、$q_{\\mathrm{mr}}(i,j,k)$ 和 $s(i,j)$ 的函数。\n- 将 $\\mathbf{x}$ 表示为 $i\\in\\mathcal{I}$ 的 $(x_i,y_i)$ 的扁平化向量，并通过插入未改变的边界顶点来重构完整的顶点数组 $\\{\\mathbf{v}_i\\}$。\n- 实现 $J(\\mathbf{x})$，如果任何 $A(i,j,k) \\leq \\delta$，则返回一个大值，以避免出现反转或近退化的单元。\n- 使用带边界约束的优化器，例如带盒约束的有限内存 Broyden-Fletcher-Goldfarb-Shanno (L-BFGS-B) 算法，对内部顶点位置最小化 $J(\\mathbf{x})$。该方法能处理大规模问题，并遵守变量边界，无需显式约束，因此在这里非常适用，因为边界顶点被排除在变量向量之外，且内部边界定义了一个简单的可行集。\n- 优化后，计算\n$$\n\\bar{q}_{\\mathrm{mr}} = \\frac{1}{|\\mathcal{T}|}\\sum_{(i,j,k)\\in\\mathcal{T}} q_{\\mathrm{mr}}(i,j,k),\n$$\n以总结最终的网格质量。\n\n测试套件原理：\n- 案例 1 提供了一个典型的场景，包含一个内部顶点和均匀尺寸度量（$\\beta=0, \\gamma=0$），用于隔离通过质量倒数进行形状优化的效果。\n- 案例 2 将内部顶点放置在角落附近，导致产生狭长三角形，用于测试优化器在边界内寻找更优构型的能力。\n- 案例 3 包括两个内部顶点和一个由水深梯度驱动的各向异性尺寸目标（$\\beta0, \\gamma0$），用于测试形状和尺寸自适应的组合效应。\n- 案例 4 没有内部顶点，以确保实现能处理退化的优化情况并正确报告基线质量。\n\n程序计算每个案例的最终平均质量，并按要求输出一行包含四个浮点数结果的、用方括号括起来的逗号分隔列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef triangle_oriented_area(V, tri):\n    i, j, k = tri\n    xi, yi = V[i]\n    xj, yj = V[j]\n    xk, yk = V[k]\n    return 0.5 * ((xj - xi) * (yk - yi) - (yj - yi) * (xk - xi))\n\ndef edge_length(V, i, j):\n    diff = V[j] - V[i]\n    return np.sqrt(np.dot(diff, diff))\n\ndef mean_ratio_quality(V, T):\n    qualities = []\n    for tri in T:\n        i, j, k = tri\n        lij2 = np.sum((V[j] - V[i])**2)\n        ljk2 = np.sum((V[k] - V[j])**2)\n        lki2 = np.sum((V[i] - V[k])**2)\n        A = abs(triangle_oriented_area(V, tri))\n        denom = lij2 + ljk2 + lki2\n        if denom  1e-16:\n            q = 0.0\n        else:\n            q = (4.0 * np.sqrt(3.0) * A) / denom\n        qualities.append(q)\n    return np.array(qualities)\n\ndef build_edges(T):\n    edges = set()\n    for i, j, k in T:\n        for a, b in [(i, j), (j, k), (k, i)]:\n            e = (min(a, b), max(a, b))\n            edges.add(e)\n    return sorted(list(edges))\n\ndef bathymetry_grad_mag(x, y):\n    # H(x,y) = sin(2*pi*x)*sin(2*pi*y)\n    # dH/dx = 2*pi*cos(2*pi*x)*sin(2*pi*y)\n    # dH/dy = 2*pi*sin(2*pi*x)*cos(2*pi*y)\n    two_pi = 2.0 * np.pi\n    dHx = two_pi * np.cos(two_pi * x) * np.sin(two_pi * y)\n    dHy = two_pi * np.sin(two_pi * x) * np.cos(two_pi * y)\n    return np.sqrt(dHx * dHx + dHy * dHy)\n\ndef target_edge_length(V, edge, s0, beta):\n    i, j = edge\n    mid = 0.5 * (V[i] + V[j])\n    g = bathymetry_grad_mag(mid[0], mid[1])\n    return s0 / (1.0 + beta * g)\n\ndef objective_factory(V_init, T, edges, boundary_mask, params):\n    # params: dict with keys 'w_tri', 's0', 'beta', 'gamma', 'mu', 'eps', 'delta'\n    w_tri = params['w_tri']\n    s0 = params['s0']\n    beta = params['beta']\n    gamma = params['gamma']\n    mu = params['mu']\n    eps = params['eps']\n    delta = params['delta']\n\n    N = V_init.shape[0]\n    interior_idx = np.where(~boundary_mask)[0]\n    bound_idx = np.where(boundary_mask)[0]\n\n    # Bounds: box constraints within boundary bbox\n    xb = V_init[boundary_mask, 0]\n    yb = V_init[boundary_mask, 1]\n    xmin, xmax = float(np.min(xb)), float(np.max(xb))\n    ymin, ymax = float(np.min(yb)), float(np.max(yb))\n    bounds = []\n    for _ in interior_idx:\n        bounds.append((xmin, xmax))  # bound for x\n        bounds.append((ymin, ymax))  # bound for y\n\n    def pack(V_full):\n        return np.hstack([V_full[interior_idx, 0], V_full[interior_idx, 1]])\n\n    def unpack(xvec):\n        V = V_init.copy()\n        # xvec has length 2*len(interior_idx)\n        V[interior_idx, 0] = xvec[:len(interior_idx)]\n        V[interior_idx, 1] = xvec[len(interior_idx):]\n        return V\n\n    def objective(xvec):\n        V = unpack(xvec)\n\n        # Barrier: penalize non-positive areas\n        areas = np.array([triangle_oriented_area(V, tri) for tri in T])\n        if np.any(areas = delta):\n            # Large penalty to discourage invalid configurations\n            return 1e12 + np.sum((delta - np.minimum(areas, delta))**2)\n\n        # Mean ratio inverse sum\n        q_mr = mean_ratio_quality(V, T)\n        inv_quality = np.sum(w_tri * (1.0 / (eps + q_mr)))\n\n        # Edge size conformity penalty\n        size_pen = 0.0\n        if gamma  0.0:\n            for e in edges:\n                l = edge_length(V, e[0], e[1])\n                s = target_edge_length(V, e, s0, beta)\n                size_pen += ((l - s) / s) ** 2\n            size_pen *= gamma\n\n        # Barrier term\n        barrier = -np.sum(np.log(areas)) * mu\n\n        return inv_quality + size_pen + barrier\n\n    x0 = pack(V_init)\n    return objective, x0, bounds, interior_idx\n\ndef optimize_mesh(V_init, T, boundary_mask, params):\n    edges = build_edges(T)\n    obj, x0, bounds, interior_idx = objective_factory(V_init, T, edges, boundary_mask, params)\n    # If there are no interior vertices, skip optimization\n    if len(interior_idx) == 0:\n        V_opt = V_init.copy()\n    else:\n        res = minimize(obj, x0, method='L-BFGS-B', bounds=bounds,\n                       options={'maxiter': 300, 'ftol': 1e-12})\n        # Reconstruct optimized vertices\n        V_opt = V_init.copy()\n        V_opt[interior_idx, 0] = res.x[:len(interior_idx)]\n        V_opt[interior_idx, 1] = res.x[len(interior_idx):]\n    # Compute mean mean-ratio quality\n    q_mr = mean_ratio_quality(V_opt, T)\n    mean_q = float(np.mean(q_mr))\n    return mean_q\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = []\n\n    # Case 1\n    V1 = np.array([\n        [0.0, 0.0],\n        [1.0, 0.0],\n        [1.0, 1.0],\n        [0.0, 1.0],\n        [0.5, 0.5]\n    ], dtype=float)\n    T1 = np.array([\n        [0, 1, 4],\n        [1, 2, 4],\n        [2, 3, 4],\n        [3, 0, 4]\n    ], dtype=int)\n    B1 = np.array([True, True, True, True, False])\n    params1 = {'w_tri': np.ones(len(T1)), 's0': 0.5, 'beta': 0.0, 'gamma': 0.0, 'mu': 0.01, 'eps': 1e-8, 'delta': 1e-12}\n    test_cases.append((V1, T1, B1, params1))\n\n    # Case 2: interior near corner\n    V2 = np.array([\n        [0.0, 0.0],\n        [1.0, 0.0],\n        [1.0, 1.0],\n        [0.0, 1.0],\n        [0.9, 0.1]\n    ], dtype=float)\n    T2 = np.array([\n        [0, 1, 4],\n        [1, 2, 4],\n        [2, 3, 4],\n        [3, 0, 4]\n    ], dtype=int)\n    B2 = np.array([True, True, True, True, False])\n    params2 = {'w_tri': np.ones(len(T2)), 's0': 0.5, 'beta': 0.0, 'gamma': 0.0, 'mu': 0.01, 'eps': 1e-8, 'delta': 1e-12}\n    test_cases.append((V2, T2, B2, params2))\n\n    # Case 3: anisotropic adaptation with two interior vertices\n    V3 = np.array([\n        [0.0, 0.0],\n        [1.0, 0.0],\n        [1.0, 1.0],\n        [0.0, 1.0],\n        [0.3, 0.5],\n        [0.7, 0.5]\n    ], dtype=float)\n    T3 = np.array([\n        [0, 1, 4],\n        [0, 4, 3],\n        [1, 2, 5],\n        [2, 3, 5],\n        [1, 5, 4],\n        [3, 4, 5]\n    ], dtype=int)\n    B3 = np.array([True, True, True, True, False, False])\n    params3 = {'w_tri': np.ones(len(T3)), 's0': 0.35, 'beta': 1.0, 'gamma': 1.0, 'mu': 0.01, 'eps': 1e-8, 'delta': 1e-12}\n    test_cases.append((V3, T3, B3, params3))\n\n    # Case 4: no interior vertices\n    V4 = np.array([\n        [0.0, 0.0],\n        [1.0, 0.0],\n        [1.0, 1.0],\n        [0.0, 1.0]\n    ], dtype=float)\n    T4 = np.array([\n        [0, 1, 2],\n        [0, 2, 3]\n    ], dtype=int)\n    B4 = np.array([True, True, True, True])\n    params4 = {'w_tri': np.ones(len(T4)), 's0': 0.5, 'beta': 0.0, 'gamma': 0.0, 'mu': 0.01, 'eps': 1e-8, 'delta': 1e-12}\n    test_cases.append((V4, T4, B4, params4))\n\n    results = []\n    for V, T, B, params in test_cases:\n        result = optimize_mesh(V, T, B, params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "网格生成是一个迭代过程，其中质量评估是指导下一步操作的关键环节。本练习将教您如何对现有网格进行“质量控制”，这是一个在实际工作中至关重要的步骤。您将计算每个三角形单元的关键质量指标，例如最小内角，并使用直方图来分析其整体分布 。更重要的是，您将实施一套形式化的决策逻辑，根据违规单元的比例、严重程度和空间聚集性，来决定网格是已经足够好，还是需要进一步的平滑或加密处理。",
            "id": "3817836",
            "problem": "给定由顶点坐标和三角形连接关系定义的平面三角形网格。对于每个网格，您必须计算基于角度的质量直方图，并决定是否需要进行额外的加密或平滑操作，以满足以度为单位表示的最小内角阈值 $ \\theta_{\\min} $。请从欧几里得几何 (Euclidean geometry) 和图连通性的第一性原理出发，并仅使用定义和经过验证的事实来形式化决策过程。\n\n基本原理和定义：\n- 网格由一组顶点坐标 $ \\{ \\mathbf{x}_i \\in \\mathbb{R}^2 \\}_{i=0}^{N_v-1} $ 和一组三角形 $ \\{ (i,j,k) \\}_{m=0}^{N_t-1} $ 组成，其中每个三角形索引三个不同的顶点。对于由点 $ \\mathbf{a} = \\mathbf{x}_i $、$ \\mathbf{b} = \\mathbf{x}_j $、$ \\mathbf{c} = \\mathbf{x}_k $ 构成的三角形 $ (i,j,k) $，通过位置向量的差来定义顶点处的边向量。顶点 $ \\mathbf{a} $ 处的内角通过点积计算得出：\n$$\n\\theta_a = \\arccos \\left( \\frac{ (\\mathbf{b}-\\mathbf{a}) \\cdot (\\mathbf{c}-\\mathbf{a}) }{ \\| \\mathbf{b}-\\mathbf{a} \\| \\, \\| \\mathbf{c}-\\mathbf{a} \\| } \\right ),\n$$\n$ \\theta_b $ 和 $ \\theta_c $ 的计算公式与此类似。一个非退化三角形的三个内角满足 $ \\theta_a + \\theta_b + \\theta_c = 180^\\circ $。所有角度必须以度为单位报告。\n- 三角形 $ m $ 的最小内角质量为\n$$\nq_m = \\min\\{ \\theta_a, \\theta_b, \\theta_c \\} \\quad \\text{(度)}.\n$$\n- 边长为 $ \\ell_1 = \\| \\mathbf{b}-\\mathbf{a} \\| $，$ \\ell_2 = \\| \\mathbf{c}-\\mathbf{b} \\| $，$ \\ell_3 = \\| \\mathbf{a}-\\mathbf{c} \\| $。三角形的各向异性比为\n$$\nr_m = \\frac{ \\max\\{ \\ell_1, \\ell_2, \\ell_3 \\} }{ \\min\\{ \\ell_1, \\ell_2, \\ell_3 \\} }.\n$$\n- 如果一个三角形的无符号面积\n$$\nA_m = \\frac{1}{2} \\left| (\\mathbf{b}-\\mathbf{a}) \\times (\\mathbf{c}-\\mathbf{a}) \\right|\n$$\n小于一个容差 $ \\varepsilon  0 $，则该三角形在数值上是退化的。对于退化三角形，设置 $ q_m = 0 $ 并将各向异性比视为 $ +\\infty $。\n- 网格有一组直方图区间边界 $ \\mathcal{B} = [b_0, b_1, \\dots, b_K] $，其中 $ b_0 = 0 $ 且 $ b_K \\ge 60 $。将每个 $ q_m $ 放入一个区间 $ [b_j, b_{j+1}) $ 中，但最后一个区间 $ [b_{K-1}, b_K] $ 是两端闭合的。报告每个区间的整数计数。\n- 令 $ \\mathcal{V} = \\{ m : q_m  \\theta_{\\min} \\} $ 表示不满足条件的三角形的索引集。定义不满足条件的比例为\n$$\nf = \\frac{|\\mathcal{V}|}{N_t}.\n$$\n- 定义一个相对于最小角度的极端性阈值 $ \\delta = c \\, \\theta_{\\min} $，其中 $ c \\in (0,1) $ 是一个常数。\n- 在顶点共享图上定义三角形邻接关系：如果两个三角形 $ m $ 和 $ n $ 共享至少一个顶点索引，则它们是邻接的。考虑在 $ \\mathcal{V} $ 上的导出子图，并令 $ c_{\\max} $ 为最大连通分量的大小。\n\n推荐平滑或加密的决策逻辑：\n- 如果没有不满足条件的三角形，即 $ |\\mathcal{V}| = 0 $，则不需要平滑和加密。\n- 否则，计算 $ f $、$ r_{\\max} = \\max_{m \\in \\mathcal{V}} r_m $、$ q_{\\min} = \\min_{m \\in \\mathcal{V}} q_m $ 和 $ c_{\\max} $。当且仅当以下所有条件同时成立时，推荐进行平滑：\n  1. $ f \\le \\alpha $ (不满足条件的三角形比例有限)，\n  2. $ r_{\\max} \\le R_{\\text{lim}} $ (不满足条件的单元没有过度各向异性)，\n  3. $ q_{\\min} \\ge \\delta $ (没有角度极小的不满足条件的三角形)，\n  4. $ c_{\\max}  \\kappa $ (不存在大的不满足条件的三角形簇)。\n  如果这些条件中任何一个不成立，则推荐进行加密。输出用于平滑和加密的布尔值，使得当存在不满足条件的三角形时，它们中恰好有一个为真。\n\n角度单位与数值处理：\n- 所有角度必须以度为单位进行计算和报告。仅当在输出和比较时转换回度，才可在内部使用弧度。\n- 通过将 $ \\arccos $ 的参数限制在区间 $ [-1,1] $ 内来进行稳健的计算，以避免浮点错误。\n\n测试套件：\n对于每个测试用例，您将获得 $ (\\text{vertices}, \\text{triangles}, \\theta_{\\min}, \\mathcal{B}, R_{\\text{lim}}, \\alpha, \\kappa, \\varepsilon, c) $，其参数值如下：\n\n- 测试用例 1 (理想情况，无不满足条件的三角形)：\n  - $ \\text{vertices} = [(0,0),(1,0),(1,1),(0,1)] $\n  - $ \\text{triangles} = [(0,1,2),(0,2,3)] $\n  - $ \\theta_{\\min} = 30 $ (度)\n  - $ \\mathcal{B} = [0,10,20,30,40,50,60] $ (度)\n  - $ R_{\\text{lim}} = 3 $\n  - $ \\alpha = 0.2 $\n  - $ \\kappa = 2 $\n  - $ \\varepsilon = 10^{-12} $\n  - $ c = 0.5 $\n\n- 测试用例 2 (孤立的中等程度违规，预期进行平滑)：\n  - $ \\text{vertices} = [(0,0),(1,0),(1,1),(0,1),(0.5,0.2)] $\n  - $ \\text{triangles} = [(0,1,4),(1,2,4),(2,3,4),(3,0,4)] $\n  - $ \\theta_{\\min} = 25 $ (度)\n  - $ \\mathcal{B} = [0,10,20,30,40,50,60] $ (度)\n  - $ R_{\\text{lim}} = 3 $\n  - $ \\alpha = 0.3 $\n  - $ \\kappa = 2 $\n  - $ \\varepsilon = 10^{-12} $\n  - $ c = 0.5 $\n\n- 测试用例 3 (沿直线的聚集违规，预期进行加密)：\n  - $ \\text{vertices} = [(0,0),(1,0),(2,0),(3,0),(0.5,0.1),(1.5,0.1),(2.5,0.1)] $\n  - $ \\text{triangles} = [(0,1,4),(1,2,5),(2,3,6)] $\n  - $ \\theta_{\\min} = 20 $ (度)\n  - $ \\mathcal{B} = [0,10,20,30,40,50,60] $ (度)\n  - $ R_{\\text{lim}} = 3 $\n  - $ \\alpha = 0.3 $\n  - $ \\kappa = 2 $\n  - $ \\varepsilon = 10^{-12} $\n  - $ c = 0.5 $\n\n- 测试用例 4 (等边三角形阈值的边界条件，无操作)：\n  - $ \\text{vertices} = [(0,0),(1,0),(0.5,0.8660254037844386)] $\n  - $ \\text{triangles} = [(0,1,2)] $\n  - $ \\theta_{\\min} = 60 $ (度)\n  - $ \\mathcal{B} = [0,10,20,30,40,50,60] $ (度)\n  - $ R_{\\text{lim}} = 3 $\n  - $ \\alpha = 0.2 $\n  - $ \\kappa = 2 $\n  - $ \\varepsilon = 10^{-12} $\n  - $ c = 0.5 $\n\n- 测试用例 5 (退化三角形，需要加密)：\n  - $ \\text{vertices} = [(0,0),(1,0),(2,0)] $\n  - $ \\text{triangles} = [(0,1,2)] $\n  - $ \\theta_{\\min} = 10 $ (度)\n  - $ \\mathcal{B} = [0,10,20,30,40,50,60] $ (度)\n  - $ R_{\\text{lim}} = 3 $\n  - $ \\alpha = 0.2 $\n  - $ \\kappa = 2 $\n  - $ \\varepsilon = 10^{-12} $\n  - $ c = 0.5 $\n\n每个测试用例的必需输出：\n- $ \\{ q_m \\}_{m=0}^{N_t-1} $ 在 $ \\mathcal{B} $ 上分布的直方图区间计数列表。\n- 一个布尔值，指示是否推荐平滑。\n- 一个布尔值，指示是否推荐加密。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为无空格、由方括号括起的逗号分隔列表。每个测试用例的结果必须是 $ [\\text{hist},\\text{smoothing},\\text{refinement}] $ 形式的列表，其中 $ \\text{hist} $ 本身是一个整数列表。例如：\n$ [[ [h_{11},h_{12},\\dots],\\text{True},\\text{False} ],[ [h_{21},\\dots],\\text{False},\\text{True} ],\\dots] $，\n但打印时无空格，例如 $ [[[3,2,0,0,0,0],[...]],...] $。",
            "solution": "该问题是有效的。这是一个定义明确的计算几何任务，其基础是欧几里得几何 (Euclidean geometry) 和图论的原理，这些都是计算网格分析中的标准方法。所有必需的数据、定义和决策逻辑都已提供，使得问题是自洽、客观且适定的。可以通过算法为每个测试用例确定唯一的解。\n\n该解决方案通过为每个测试用例遵循一个系统性步骤来实现。该过程分为四个主要阶段：(1) 逐个三角形的几何属性计算，(2) 将质量度量聚合到直方图中，(3) 识别不满足条件的三角形并分析其集体属性，以及 (4) 应用形式化决策逻辑以推荐后续的网格自适应操作。\n\n**1. 逐个三角形的几何分析**\n\n对于网格中的每个三角形 $m$，其由顶点 $\\mathbf{a} = \\mathbf{x}_i$、$\\mathbf{b} = \\mathbf{x}_j$ 和 $\\mathbf{c} = \\mathbf{x}_k$ 定义，我们计算其基本几何属性。\n\n首先，我们确定该三角形是否在数值上退化。面积 $A_m$ 使用源自同一顶点的边向量的二维叉积计算：\n$$\nA_m = \\frac{1}{2} \\left| (\\mathbf{b}-\\mathbf{a}) \\times (\\mathbf{c}-\\mathbf{a}) \\right| = \\frac{1}{2} \\left| (x_b-x_a)(y_c-y_a) - (x_c-x_a)(y_b-y_a) \\right|\n$$\n如果 $A_m$ 小于一个小的容差 $\\varepsilon  0$，则该三角形被认为是退化的。对于此类三角形，质量度量 $q_m$ 设置为 $0$，各向异性比 $r_m$ 设置为 $+\\infty$。\n\n对于非退化三角形，我们计算三个内角。顶点 $\\mathbf{a}$ 处的角度 $\\theta_a$ 由以下公式给出：\n$$\n\\theta_a = \\arccos \\left( \\frac{ (\\mathbf{b}-\\mathbf{a}) \\cdot (\\mathbf{c}-\\mathbf{a}) }{ \\| \\mathbf{b}-\\mathbf{a} \\| \\| \\mathbf{c}-\\mathbf{a} \\| } \\right )\n$$\n角度 $\\theta_b$ 和 $\\theta_c$ 的计算方法类似。为确保数值稳定性，$\\arccos$ 函数的参数被限制在有效范围 $[-1, 1]$ 内。以弧度计算的角度会转换为度。三角形的质量 $q_m$ 定义为其三个内角的最小值：\n$$\nq_m = \\min \\{ \\theta_a, \\theta_b, \\theta_c \\}\n$$\n我们还计算边长 $\\ell_1 = \\| \\mathbf{b}-\\mathbf{a} \\|$、$\\ell_2 = \\| \\mathbf{c}-\\mathbf{b} \\|$ 和 $\\ell_3 = \\| \\mathbf{a}-\\mathbf{c} \\|$。各向异性比 $r_m$ 是最长边与最短边的比值：\n$$\nr_m = \\frac{ \\max\\{ \\ell_1, \\ell_2, \\ell_3 \\} }{ \\min\\{ \\ell_1, \\ell_2, \\ell_3 \\} }\n$$\n\n**2. 网格质量直方图**\n\n在计算完网格中所有 $N_t$ 个三角形的质量 $q_m$ 后，我们生成这些值的直方图。区间边界由集合 $\\mathcal{B} = [b_0, b_1, \\dots, b_K]$ 提供。每个质量值 $q_m$ 被放入其中一个区间。对于 $j=0, \\dots, K-2$，区间定义为半开区间 $[b_j, b_{j+1})$，最后一个区间为闭区间 $[b_{K-1}, b_K]$。此阶段的输出是每个区间的整数计数列表。\n\n**3. 不满足条件的分析**\n\n如果三角形 $m$ 的质量 $q_m$ 小于指定的最小角度阈值 $\\theta_{\\min}$，则认为该三角形不满足质量标准。我们将不满足条件的三角形集合定义为 $\\mathcal{V} = \\{ m : q_m  \\theta_{\\min} \\}$。\n\n如果 $\\mathcal{V}$ 为空（即 $|\\mathcal{V}| = 0$），则无需进一步分析，也不需要进行网格自适应。\n\n如果 $\\mathcal{V}$ 非空，我们计算四个刻画不满足条件性质的度量：\n1.  **不满足条件比例 ($f$)**: 不满足条件的三角形所占的比例，$f = \\frac{|\\mathcal{V}|}{N_t}$。\n2.  **最大各向异性比 ($r_{\\max}$)**: 所有不满足条件的三角形中的最大各向异性比，$r_{\\max} = \\max_{m \\in \\mathcal{V}} r_m$。\n3.  **最低质量 ($q_{\\min}$)**: 所有不满足条件的三角形中的最低质量值，$q_{\\min} = \\min_{m \\in \\mathcal{V}} q_m$。\n4.  **最大簇大小 ($c_{\\max}$)**: 此度量用于量化不满足条件的三角形的空间聚集程度。构建一个邻接图，其中节点代表 $\\mathcal{V}$ 中的三角形。如果对应的三角形共享至少一个顶点，则两个节点之间存在一条边。然后我们找到该图中的最大连通分量的大小，记为 $c_{\\max}$。这是通过执行图遍历算法（如广度优先搜索 (BFS) 或深度优先搜索 (DFS)），从每个未访问的节点开始，以计算其分量中的成员数量来实现的。\n\n**4. 决策逻辑**\n\n最后一步是根据计算出的度量推荐一个操作。选择范围在“平滑”（重新定位顶点以提高质量）和“加密”（添加新的顶点和三角形）之间。\n\n- 如果 $|\\mathcal{V}| = 0$，则平滑和加密都不被推荐（布尔值为 `False`）。\n- 如果 $|\\mathcal{V}|  0$，当且仅当以下所有条件同时满足时，推荐进行平滑：\n    1.  不满足条件的比例很小：$f \\le \\alpha$。\n    2.  不满足条件的三角形没有过度拉长：$r_{\\max} \\le R_{\\text{lim}}$。\n    3.  不满足条件的情况不极端：$q_{\\min} \\ge \\delta$，其中 $\\delta = c \\cdot \\theta_{\\min}$。\n    4.  不满足条件的三角形没有形成大簇：$c_{\\max}  \\kappa$。\n\n如果这四个条件都成立，则推荐进行平滑（`True`）而非加密（`False`）。如果任何一个条件不成立，则推荐进行加密（`True`）而非平滑（`False`），以确保在存在不满足条件的三角形时，恰好推荐一个操作。此逻辑基于一种启发式方法，即局部、不严重的质量问题通常可以通过平滑来解决，而广泛、严重或高度聚集的问题通常需要成本更高的加密操作。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    # Test cases as defined in the problem statement.\n    test_cases = [\n        # Case 1: Happy path, no violations\n        (\n            [(0,0),(1,0),(1,1),(0,1)], \n            [(0,1,2),(0,2,3)], \n            30, [0,10,20,30,40,50,60], 3, 0.2, 2, 1e-12, 0.5\n        ),\n        # Case 2: Isolated moderate violation, smoothing expected\n        (\n            [(0,0),(1,0),(1,1),(0,1),(0.5,0.2)], \n            [(0,1,4),(1,2,4),(2,3,4),(3,0,4)], \n            25, [0,10,20,30,40,50,60], 3, 0.3, 2, 1e-12, 0.5\n        ),\n        # Case 3: Clustered violations, refinement expected\n        (\n            [(0,0),(1,0),(2,0),(3,0),(0.5,0.1),(1.5,0.1),(2.5,0.1)], \n            [(0,1,4),(1,2,5),(2,3,6)], \n            20, [0,10,20,30,40,50,60], 3, 0.3, 2, 1e-12, 0.5\n        ),\n        # Case 4: Boundary condition at equilateral, no action\n        (\n            [(0,0),(1,0),(0.5,0.8660254037844386)], \n            [(0,1,2)], \n            60, [0,10,20,30,40,50,60], 3, 0.2, 2, 1e-12, 0.5\n        ),\n        # Case 5: Degenerate triangle, refinement required\n        (\n            [(0,0),(1,0),(2,0)], \n            [(0,1,2)], \n            10, [0,10,20,30,40,50,60], 3, 0.2, 2, 1e-12, 0.5\n        ),\n    ]\n\n    all_results = [process_case(case) for case in test_cases]\n\n    # Final print statement in the exact required format.\n    # Convert the list of results to a string and remove all spaces.\n    final_output_string = str(all_results).replace(' ', '')\n    print(final_output_string)\n\ndef process_case(case_data):\n    \"\"\"\n    Processes a single test case to determine mesh quality and recommendations.\n    \"\"\"\n    vertices_list, triangles_list, theta_min, B, R_lim, alpha, kappa, epsilon, c = case_data\n    vertices = np.array(vertices_list, dtype=float)\n    triangles = np.array(triangles_list, dtype=int)\n    \n    Nt = len(triangles)\n    qualities_q = np.zeros(Nt)\n    anisotropy_r = np.zeros(Nt)\n    \n    for m, tri_indices in enumerate(triangles):\n        p1, p2, p3 = vertices[tri_indices]\n        \n        # Check for degeneracy using area calculation\n        area = 0.5 * abs((p2[0] - p1[0]) * (p3[1] - p1[1]) - (p3[0] - p1[0]) * (p2[1] - p1[1]))\n        \n        if area  epsilon:\n            qualities_q[m] = 0.0\n            anisotropy_r[m] = np.inf\n            continue\n            \n        # Edge lengths and anisotropy\n        l1 = np.linalg.norm(p2 - p1)\n        l2 = np.linalg.norm(p3 - p2)\n        l3 = np.linalg.norm(p1 - p3)\n        lengths = [l1, l2, l3]\n        if min(lengths)  epsilon: # Avoid division by zero for near-degenerate cases\n             anisotropy_r[m] = np.inf\n        else:\n             anisotropy_r[m] = max(lengths) / min(lengths)\n\n        # Interior angles\n        angles_deg = []\n        vecs = [(p2 - p1, p3 - p1, l1, l3), \n                (p1 - p2, p3 - p2, l1, l2),\n                (p1 - p3, p2 - p3, l3, l2)]\n\n        for v1, v2, len1, len2 in vecs:\n            cos_theta = np.dot(v1, v2) / (len1 * len2)\n            cos_theta = np.clip(cos_theta, -1.0, 1.0)\n            angle_rad = np.arccos(cos_theta)\n            angles_deg.append(np.degrees(angle_rad))\n        \n        qualities_q[m] = np.min(angles_deg)\n\n    # Histogram of quality metrics\n    hist, _ = np.histogram(qualities_q, bins=B)\n    \n    # Decision logic\n    violating_indices = np.where(qualities_q  theta_min)[0]\n    num_violations = len(violating_indices)\n    \n    if num_violations == 0:\n        return [hist.tolist(), False, False]\n        \n    f = num_violations / Nt\n    \n    q_violating = qualities_q[violating_indices]\n    r_violating = anisotropy_r[violating_indices]\n    \n    q_min_viol = np.min(q_violating)\n    r_max_viol = np.max(r_violating)\n    \n    delta = c * theta_min\n    \n    # Adjacency graph and connected components\n    c_max = 0\n    if num_violations > 0:\n        violating_tri_verts = [set(triangles[i]) for i in violating_indices]\n        adj = {i: [] for i in range(num_violations)}\n        for i in range(num_violations):\n            for j in range(i + 1, num_violations):\n                if violating_tri_verts[i].intersection(violating_tri_verts[j]):\n                    adj[i].append(j)\n                    adj[j].append(i)\n        \n        visited = set()\n        for i in range(num_violations):\n            if i not in visited:\n                component_size = 0\n                q = [i]\n                visited.add(i)\n                head = 0\n                while head  len(q):\n                    u = q[head]\n                    head += 1\n                    component_size += 1\n                    for v in adj[u]:\n                        if v not in visited:\n                            visited.add(v)\n                            q.append(v)\n                c_max = max(c_max, component_size)\n\n    # Apply decision rules\n    smoothing_recommended = (f = alpha and \n                             r_max_viol = R_lim and \n                             q_min_viol >= delta and \n                             c_max  kappa)\n                             \n    refinement_recommended = not smoothing_recommended\n    \n    return [hist.tolist(), smoothing_recommended, refinement_recommended]\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}