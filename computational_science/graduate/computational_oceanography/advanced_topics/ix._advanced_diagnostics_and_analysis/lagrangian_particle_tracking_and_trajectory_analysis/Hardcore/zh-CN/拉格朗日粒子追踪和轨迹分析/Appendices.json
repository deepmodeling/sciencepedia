{
    "hands_on_practices": [
        {
            "introduction": "在拉格朗日粒子追踪中，一个核心问题是理解流体包裹的物理属性（如温度或盐度）如何随时间变化。本练习旨在通过一个理想化的应变流场，建立拉格朗日（随流）视角和欧拉（定点）视角之间的桥梁。通过从两个不同角度推导物质导数 $D\\phi/Dt$，你将深入理解物质导数如何将局部变化与平流效应结合起来，这是流体动力学中的一个基石概念。",
            "id": "3797356",
            "problem": "考虑一个代表海洋中理想化锋区的二维定常张弛流。其速度场由 $\\mathbf{u}(x,y)=\\left(a x,\\,-a y\\right)$ 给出，其中 $a>0$ 是一个常数，单位为时间的倒数。设标量场 $\\phi(x,y)=x^{2}+y^{2}$ 表示到原点距离的平方。使用拉格朗日粒子追踪框架且仅根据第一性原理，即流体质点的运动学关系 $\\mathrm{d}x/\\mathrm{d}t=u_{x}$ 和 $\\mathrm{d}y/\\mathrm{d}t=u_{y}$，以及物质导数 $D\\phi/Dt$ 是 $\\phi$ 跟随流体质点时的变化率的定义，推导出一个对任意 $(x,y)$ 均有效的 $D\\phi/Dt$ 的显式表达式。然后，通过基于空间梯度和时间无关性的欧拉计算来验证相同的表达式，并从欧拉和拉格朗日两种框架下的张弛角度对结果进行物理解释。将 $D\\phi/Dt$ 的最终结果表示为关于 $a$、$x$ 和 $y$ 的封闭形式代数表达式。无需进行数值计算，也无需进行四舍五入。",
            "solution": "该问题已经过验证，被认为是合理、良定且有科学依据的。所有必需信息均已提供，该物理情景是流体动力学中的一个标准理想化模型，且任务定义清晰。\n\n该问题要求在速度场 $\\mathbf{u}(x,y)=(ax, -ay)$ 中，使用拉格朗日和欧拉两种不同的形式体系，推导标量场 $\\phi(x,y)=x^{2}+y^{2}$ 的物质导数 $\\frac{D\\phi}{Dt}$。常数 $a$ 为正。\n\n首先，我们将从拉格朗日视角进行推导。在此框架下，我们跟随单个流体质点，并观察该特定质点的属性 $\\phi$ 如何随时间变化。设一个流体质点在时间 $t$ 的位置由向量 $\\mathbf{r}(t) = (x(t), y(t))$ 给出。根据定义，质点的速度即为其当前位置处的流体速度。这由问题陈述中给出的常微分方程组描述：\n$$\n\\frac{\\mathrm{d}x}{\\mathrm{d}t} = u_x = ax(t)\n$$\n$$\n\\frac{\\mathrm{d}y}{\\mathrm{d}t} = u_y = -ay(t)\n$$\n沿着质点轨迹计算的标量 $\\phi$ 仅成为时间的函数，我们可以将其表示为 $\\Phi(t) = \\phi(x(t), y(t)) = (x(t))^{2} + (y(t))^{2}$。物质导数 $\\frac{D\\phi}{Dt}$ 定义为该函数的全时间导数 $\\frac{\\mathrm{d}\\Phi}{\\mathrm{d}t}$。我们使用多变量函数的链式法则计算该导数：\n$$\n\\frac{D\\phi}{Dt} = \\frac{\\mathrm{d}\\Phi}{\\mathrm{d}t} = \\frac{\\mathrm{d}}{\\mathrm{d}t} \\left[ (x(t))^{2} + (y(t))^{2} \\right] = 2x(t) \\frac{\\mathrm{d}x}{\\mathrm{d}t} + 2y(t) \\frac{\\mathrm{d}y}{\\mathrm{d}t}\n$$\n现在，我们将速度分量 $\\frac{\\mathrm{d}x}{\\mathrm{d}t}$ 和 $\\frac{\\mathrm{d}y}{\\mathrm{d}t}$ 的表达式代入此方程。在轨迹上的任意点 $(x,y)$，我们有：\n$$\n\\frac{D\\phi}{Dt} = 2x(ax) + 2y(-ay)\n$$\n化简该代数表达式可得结果：\n$$\n\\frac{D\\phi}{Dt} = 2ax^{2} - 2ay^{2} = 2a(x^{2} - y^{2})\n$$\n这是在拉格朗日框架下从第一性原理推导出的物质导数表达式。它对流场中的任意点 $(x,y)$ 均有效。\n\n其次，我们使用欧拉计算来验证此结果。在欧拉框架中，我们考虑空间中固定点的变化。在速度场 $\\mathbf{u}(\\mathbf{r}, t)$ 中，标量场 $\\phi(\\mathbf{r}, t)$ 的物质导数由以下通用公式给出：\n$$\n\\frac{D\\phi}{Dt} = \\frac{\\partial \\phi}{\\partial t} + (\\mathbf{u} \\cdot \\nabla)\\phi = \\frac{\\partial \\phi}{\\partial t} + \\mathbf{u} \\cdot \\nabla\\phi\n$$\n项 $\\frac{\\partial \\phi}{\\partial t}$ 是固定点的局部变化率，项 $\\mathbf{u} \\cdot \\nabla\\phi$ 是平流变化率，表示由于携带不同 $\\phi$ 值的流体流过该点而引起的变化。\n在本问题中，标量场由 $\\phi(x,y) = x^{2} + y^{2}$ 给出，它不显式依赖于时间 $t$。因此，局地时间导数为零：\n$$\n\\frac{\\partial \\phi}{\\partial t} = 0\n$$\n速度向量为 $\\mathbf{u} = (u_x, u_y) = (ax, -ay)$。\n标量场 $\\phi$ 的梯度为：\n$$\n\\nabla\\phi = \\left( \\frac{\\partial \\phi}{\\partial x}, \\frac{\\partial \\phi}{\\partial y} \\right) = \\left( \\frac{\\partial}{\\partial x}(x^{2}+y^{2}), \\frac{\\partial}{\\partial y}(x^{2}+y^{2}) \\right) = (2x, 2y)\n$$\n现在我们计算平流项，即速度向量与 $\\phi$ 的梯度的点积：\n$$\n\\mathbf{u} \\cdot \\nabla\\phi = (ax, -ay) \\cdot (2x, 2y) = (ax)(2x) + (-ay)(2y)\n$$\n$$\n\\mathbf{u} \\cdot \\nabla\\phi = 2ax^{2} - 2ay^{2}\n$$\n将这些分量代回物质导数公式：\n$$\n\\frac{D\\phi}{Dt} = 0 + 2ax^{2} - 2ay^{2} = 2a(x^{2} - y^{2})\n$$\n此结果与通过拉格朗日方法获得的结果完全相同，从而验证了计算。\n\n最后，我们对结果进行物理解释。速度场 $\\mathbf{u}=(ax, -ay)$ 描述了一个纯张弛流，其伸展轴沿 $x$ 轴，压缩轴沿 $y$ 轴。原点 $(0,0)$ 是一个双曲不动点（一个鞍点）。流体质点被拉伸远离 $y$ 轴并被压缩向 $x$ 轴。\n标量场 $\\phi=x^{2}+y^{2}$ 表示一个点到原点距离的平方。因此，物质导数 $\\frac{D\\phi}{Dt} = 2a(x^{2} - y^{2})$ 衡量了流体质点在流场中移动时其与原点距离的平方的变化速率。\n$\\frac{D\\phi}{Dt}$ 的符号取决于质点的位置：\n- 如果 $|x| > |y|$，则 $x^2 > y^2$ 且 $\\frac{D\\phi}{Dt} > 0$。这对应于包含 $x$ 轴（伸展轴）的两个平面扇区。在这些区域，流场的拉伸效应占主导，流体质点远离原点。\n- 如果 $|x|  |y|$，则 $x^2  y^2$ 且 $\\frac{D\\phi}{Dt}  0$。这对应于包含 $y$ 轴（压缩轴）的两个平面扇区。在这里，流场的压缩效应占主导，流体质点向原点移动。\n- 如果 $|x| = |y|$，即在直线 $y = x$ 和 $y = -x$ 上，则 $\\frac{D\\phi}{Dt} = 0$。在这些线上的任意一点，质点的瞬时运动使其到原点的距离保持不变。伸展的向外推效应与压缩的向内拉效应完全平衡。这些线分隔了质点远离原点的区域和朝向原点移动的区域。\n\n从拉格朗日视角看，$\\frac{D\\phi}{Dt}$ 是运动粒子所经历的 $\\phi$ 的实际变化率。从欧拉视角看，这种变化完全是由平流引起的（$\\frac{\\partial\\phi}{\\partial t}=0$），这意味着在任何点 $(x,y)$，$\\phi$ 值的变化仅仅是因为到达该点的流体质点来自一个 $\\phi$ 值不同的位置。这两种视角对同一物理过程提供了一致的描述。",
            "answer": "$$\n\\boxed{2a(x^2 - y^2)}\n$$"
        },
        {
            "introduction": "将粒子运动的连续微分方程转化为计算机上的离散时间步长算法，是计算海洋学中的一项核心任务，但这过程中会遇到数值挑战。本练习关注一个关键问题：如何在数值积分过程中确保粒子保持在约束表面上，例如地球球面。你将设计并实现一个投影步骤，以修正由龙格-库塔（RK4）等数值方法引起的约束漂移，这是开发精确的全球或区域粒子追踪模型的必备技能。",
            "id": "3797380",
            "problem": "考虑一个拉格朗日粒子在给定速度场的作用下，在一个球面上运动。粒子的位置在笛卡尔坐标系中表示为一个向量 $\\mathbf{r}(t) \\in \\mathbb{R}^3$，并受约束 $\\|\\mathbf{r}(t)\\| = R$，其中 $R$ 是恒定的球体半径。其运动学由常微分方程 (ODE) $\\dfrac{d\\mathbf{r}}{dt} = \\mathbf{u}(\\mathbf{r}, t)$ 给出，其中 $\\mathbf{u}(\\mathbf{r}, t)$ 是以物理单位指定的速度场。任务是设计一种数值时间步进方法，该方法在积分该 ODE 的同时包含一个投影步骤，以确保每次时间更新后，位置能精确满足 $\\|\\mathbf{r}\\| = R$。\n\n从基本定义出发：\n- 轨迹满足 $\\dfrac{d\\mathbf{r}}{dt} = \\mathbf{u}(\\mathbf{r}, t)$ 和球面约束 $\\mathbf{r}(t) \\cdot \\mathbf{r}(t) = R^2$。\n- 对约束关于时间求导可得 $2\\,\\mathbf{r}(t) \\cdot \\dfrac{d\\mathbf{r}}{dt} = 0$，这意味着物理上一致的球面上速度必须满足 $\\mathbf{r}(t) \\cdot \\mathbf{u}(\\mathbf{r}(t), t) = 0$。\n\n在数值实践中，诸如四阶龙格-库塔（Runge–Kutta 4 (RK4)）等显式时间步进方法无法精确保持完整约束，导致 $\\|\\mathbf{r}\\|$ 出现漂移。您的目标是：\n1. 从第一性原理出发，推导一个投影步骤。当该步骤应用于一个时间步更新后的位置时，能确保 $\\|\\mathbf{r}\\| = R$ 被精确满足。\n2. 实现一个完整的算法，使用显式方法对 ODE 进行积分，并在每次更新后应用投影步骤。\n3. 通过比较有无投影步骤时方法的约束漂移，以及在有解析参考解的情况下测量轨迹精度，来量化投影的有效性。\n\n使用以下速度场、参数和初始条件作为测试套件。所有角度单位为弧度，角速度单位为弧度/秒，所有距离单位为米。时间单位为秒。\n\n速度场定义：\n- 绕 $\\hat{\\mathbf{z}}$ 轴的刚体旋转：$\\mathbf{u}(\\mathbf{r}, t) = \\boldsymbol{\\Omega}(t) \\times \\mathbf{r}$，其中 $\\boldsymbol{\\Omega}(t) = \\Omega(t)\\,\\hat{\\mathbf{z}}$，$\\hat{\\mathbf{z}} = (0, 0, 1)$ 且 $\\times$ 表示叉积。\n- 对于恒定旋转，$\\Omega(t) = \\Omega_0$。\n- 对于时变旋转，$\\Omega(t) = \\Omega_0 \\cos(\\sigma t)$，其中角频率为 $\\sigma$。\n\n用于验证的解析参考解：\n- 对于恒定 $\\Omega(t) = \\Omega_0$，精确解是绕 $\\hat{\\mathbf{z}}$ 轴旋转角度 $\\theta(t) = \\Omega_0 t$。\n- 对于 $\\Omega(t) = \\Omega_0 \\cos(\\sigma t)$，旋转角度为 $\\theta(t) = \\int_0^t \\Omega(\\tau)\\,d\\tau = \\dfrac{\\Omega_0}{\\sigma} \\sin(\\sigma t)$。\n\n测试套件：\n- 情况 A (基准，“理想路径”)：$R = 6{,}371{,}000$，$\\Omega_0 = 7.2921159 \\times 10^{-5}$，时间步长 $\\Delta t = 600$，总时间 $T = 172{,}800$，初始位置 $\\mathbf{r}_0 = (R, 0, 0)$，恒定旋转。\n- 情况 B (粗时间步，稳定边界)：$R = 6{,}371{,}000$，$\\Omega_0 = 7.2921159 \\times 10^{-5}$，时间步长 $\\Delta t = 7{,}200$，总时间 $T = 86{,}400$，初始位置 $\\mathbf{r}_0 = (0, R, 0)$，恒定旋转。\n- 情况 C (时变旋转速率)：$R = 6{,}371{,}000$，$\\Omega_0 = 7.2921159 \\times 10^{-5}$，$\\sigma = \\dfrac{2\\pi}{86{,}400}$，时间步长 $\\Delta t = 600$，总时间 $T = 86{,}400$，初始位置 $\\mathbf{r}_0 = (R, 0, 0)$，时变旋转。\n\n实现要求：\n- 使用显式 RK4 方法对“无投影”和“有投影”两个版本进行时间推进 $\\mathbf{r}$。\n- 在“有投影”版本中，根据您的推导设计并使用一个投影步骤，在每次完整的 RK4 更新后强制执行 $\\|\\mathbf{r}\\| = R$。\n- 对于每个测试情况，计算以下三个以米为单位的量化指标：\n  1. 无投影时与球面约束的最大偏差：在所有时间步 $n$ 上的 $\\max_{n} \\left|\\|\\mathbf{r}_n\\| - R\\right|$。\n  2. 有投影时与球面约束的最大偏差：在所有时间步 $n$ 上的 $\\max_{n} \\left|\\|\\mathbf{r}_n\\| - R\\right|$。\n  3. 在时间 $T$ 时，数值投影解与解析参考轨迹之间的最终大圆弧长误差：$s = R \\,\\arccos\\!\\left(\\dfrac{\\mathbf{r}_{\\text{num}}(T) \\cdot \\mathbf{r}_{\\text{ref}}(T)}{R^2}\\right)$，其中 arccosine 的参数必须被限制在区间 $[-1, 1]$ 内，以避免数值问题。\n\n您的程序应生成单行输出，其中包含九个结果（每个测试情况三个，按情况 A、B、C 的上述顺序列出），形式为用方括号括起来的逗号分隔列表，单位为米。例如，您的输出必须是 $[\\text{a}_1,\\text{a}_2,\\text{a}_3,\\text{b}_1,\\text{b}_2,\\text{b}_3,\\text{c}_1,\\text{c}_2,\\text{c}_3]$ 的形式，其中每个条目都是一个以米为单位的浮点数。",
            "solution": "该问题要求设计、实现并验证一种用于积分球面上拉格朗日粒子轨迹的数值方法。问题的核心在于解决由显式时间步进方案引起的、偏离球面约束的数值漂移问题。解决方案将分三部分呈现：首先，推导用于强制执行约束的投影算子；其次，描述完整的数值算法；第三，阐述量化投影有效性的方法。\n\n粒子的位置由向量 $\\mathbf{r}(t) \\in \\mathbb{R}^3$ 给出，它根据常微分方程 (ODE) $\\dfrac{d\\mathbf{r}}{dt} = \\mathbf{u}(\\mathbf{r}, t)$ 演化。粒子被约束在半径为 $R$ 的球面上，这施加了完整约束 $\\|\\mathbf{r}(t)\\| = R$，或等效地，$\\mathbf{r}(t) \\cdot \\mathbf{r}(t) = R^2$。球面上物理一致的速度场 $\\mathbf{u}$ 必须在所有点上都与球面相切，满足条件 $\\mathbf{r} \\cdot \\mathbf{u}(\\mathbf{r}, t) = 0$。虽然所提供的解析速度场 $\\mathbf{u}(\\mathbf{r}, t) = \\boldsymbol{\\Omega}(t) \\times \\mathbf{r}$ 遵守此性质，但像四阶龙格-库塔 (RK4) 方案这样的数值积分方法会引入离散化误差，导致数值解偏离球面，从而违反约束。\n\n第一步是推导一种校正这种漂移的方法。设 $\\mathbf{r}_n$ 为粒子在时间 $t_n$ 的位置，假定它精确地位于球面上，即 $\\|\\mathbf{r}_n\\| = R$。经过数值积分器（如 RK4）在时间间隔 $\\Delta t$ 内的一个步长后，我们得到一个中间位置 $\\mathbf{r}_{n+1}^*$。由于截断误差，这个新位置通常不会在球面上，因此 $\\|\\mathbf{r}_{n+1}^*\\| \\neq R$。我们寻求一个投影后的位置 $\\mathbf{r}_{n+1}$，它既满足约束 $\\|\\mathbf{r}_{n+1}\\| = R$，又是对 $\\mathbf{r}_{n+1}^*$ 的最小修正。最直接且几何上最直观的修正是径向投影。该投影通过缩放其模长而不改变其方向，将 $\\mathbf{r}_{n+1}^*$ 映射到球面上的一个点。这相当于在穿过原点和 $\\mathbf{r}_{n+1}^*$ 的直线上找到球面上的点。\n\n这可以表述为：断言投影后的向量 $\\mathbf{r}_{n+1}$ 与中间向量 $\\mathbf{r}_{n+1}^*$ 共线。因此，我们可以写出 $\\mathbf{r}_{n+1} = \\alpha \\mathbf{r}_{n+1}^*$，其中 $\\alpha$ 是某个正的缩放因子。为了确定 $\\alpha$，我们在 $\\mathbf{r}_{n+1}$ 上强制施加球面约束：\n$$\n\\|\\mathbf{r}_{n+1}\\| = R\n$$\n代入 $\\mathbf{r}_{n+1} = \\alpha \\mathbf{r}_{n+1}^*$ 得到：\n$$\n\\|\\alpha \\mathbf{r}_{n+1}^*\\| = |\\alpha| \\|\\mathbf{r}_{n+1}^*\\| = R\n$$\n由于我们需要一个同向投影（最小修正），我们取 $\\alpha  0$。求解 $\\alpha$ 可得：\n$$\n\\alpha = \\frac{R}{\\|\\mathbf{r}_{n+1}^*\\|}\n$$\n因此，在每次时间更新后对位置向量进行重新归一化的投影步骤是：\n$$\n\\mathbf{r}_{n+1} = \\mathbf{r}_{n+1}^* \\left( \\frac{R}{\\|\\mathbf{r}_{n+1}^*\\|} \\right)\n$$\n此操作确保位置向量在每个时间步后都能在机器精度内满足约束。\n\n任务的第二部分是实现完整的算法。积分是使用显式四阶龙格-库塔 (RK4) 方法执行的。给定时间 $t_n$ 的位置 $\\mathbf{r}_n$，在时间 $t_{n+1} = t_n + \\Delta t$ 的中间位置 $\\mathbf{r}_{n+1}^*$ 计算如下：\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = \\Delta t \\cdot \\mathbf{u}(\\mathbf{r}_n, t_n) \\\\\n\\mathbf{k}_2 = \\Delta t \\cdot \\mathbf{u}\\left(\\mathbf{r}_n + \\frac{1}{2}\\mathbf{k}_1, t_n + \\frac{1}{2}\\Delta t\\right) \\\\\n\\mathbf{k}_3 = \\Delta t \\cdot \\mathbf{u}\\left(\\mathbf{r}_n + \\frac{1}{2}\\mathbf{k}_2, t_n + \\frac{1}{2}\\Delta t\\right) \\\\\n\\mathbf{k}_4 = \\Delta t \\cdot \\mathbf{u}(\\mathbf{r}_n + \\mathbf{k}_3, t_n + \\Delta t) \\\\\n\\mathbf{r}_{n+1}^* = \\mathbf{r}_n + \\frac{1}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n\\end{aligned}\n$$\n速度函数 $\\mathbf{u}(\\mathbf{r}, t)$ 被指定为刚体旋转，$\\mathbf{u}(\\mathbf{r}, t) = \\boldsymbol{\\Omega}(t) \\times \\mathbf{r}$，其中 $\\boldsymbol{\\Omega}(t) = \\Omega(t)\\,\\hat{\\mathbf{z}}$，$\\hat{\\mathbf{z}} = (0, 0, 1)^T$。函数 $\\Omega(t)$ 或者是一个常数 $\\Omega_0$，或者是时变的 $\\Omega(t) = \\Omega_0 \\cos(\\sigma t)$。算法将从初始位置 $\\mathbf{r}_0$ 开始，执行总时间 $T$。对每个测试情况运行两次模拟：一次不带投影步骤，其中 $\\mathbf{r}_{n+1} = \\mathbf{r}_{n+1}^*$；另一次在每次 RK4 更新后应用投影步骤。\n\n第三部分是使用三个指定的指标来评估该方法的性能。\n1.  **无投影时的最大约束偏差**：$\\max_{n} \\left|\\|\\mathbf{r}_n\\| - R\\right|$。该指标量化了使用标准 RK4 方法时与球面表面的累积漂移。预期该值不为零，并随时间步长的增大而增大。\n2.  **有投影时的最大约束偏差**：$\\max_{n} \\left|\\|\\mathbf{r}_n\\| - R\\right|$。通过投影步骤，该值应接近于零，仅受限于机器的浮点精度，从而证明了约束强制执行的有效性。\n3.  **最终大圆弧长误差**：该指标衡量投影轨迹相对于已知解析解的准确性。在最终时间 $T$ 的误差计算为 $s = R \\,\\arccos\\!\\left(\\frac{\\mathbf{r}_{\\text{num}}(T) \\cdot \\mathbf{r}_{\\text{ref}}(T)}{R^2}\\right)$。解析解 $\\mathbf{r}_{\\text{ref}}(T)$ 是通过将初始位置 $\\mathbf{r}_0$ 绕 $\\hat{\\mathbf{z}}$ 轴旋转角度 $\\theta(T) = \\int_0^T \\Omega(\\tau)\\,d\\tau$ 得到的。\n    - 对于恒定旋转 $\\Omega(t) = \\Omega_0$，角度为 $\\theta(T) = \\Omega_0 T$。\n    - 对于时变旋转 $\\Omega(t) = \\Omega_0 \\cos(\\sigma t)$，角度为 $\\theta(T) = \\frac{\\Omega_0}{\\sigma} \\sin(\\sigma T)$。\n    $\\arccos$ 函数的参数必须被限制在区间 $[-1, 1]$ 内，以处理可能将值推到此范围之外的潜在浮点不精确性。此误差指标评估了数值方案（RK4 结合投影）在多大程度上近似了球上的真实动力学。\n\n该实现将模拟所提供的三个测试情况下的粒子运动，总共计算这九个指标。",
            "answer": "```python\nimport numpy as np\nfrom scipy.constants import pi\n\ndef solve():\n    \"\"\"\n    Solves the Lagrangian particle tracking problem for three test cases.\n    \"\"\"\n\n    def u_vel(r, omega_val):\n        \"\"\"Calculates the velocity u = Omega x r, with Omega = (0, 0, omega_val).\"\"\"\n        omega_vec = np.array([0.0, 0.0, omega_val])\n        return np.cross(omega_vec, r)\n\n    def rk4_step(r_n, t_n, dt, u_func):\n        \"\"\"Performs a single RK4 step.\"\"\"\n        k1 = dt * u_func(r_n, t_n)\n        k2 = dt * u_func(r_n + 0.5 * k1, t_n + 0.5 * dt)\n        k3 = dt * u_func(r_n + 0.5 * k2, t_n + 0.5 * dt)\n        k4 = dt * u_func(r_n + k3, t_n + dt)\n        r_star = r_n + (k1 + 2 * k2 + 2 * k3 + k4) / 6.0\n        return r_star\n\n    def run_simulation(r0, R, dt, T, omega_func, do_projection):\n        \"\"\"Runs the simulation with or without projection.\"\"\"\n        num_steps = int(round(T / dt))\n        r = np.copy(r0)\n        max_radius_dev = 0.0\n\n        u_field_func = lambda r, t: u_vel(r, omega_func(t))\n\n        for i in range(num_steps):\n            t = i * dt\n            r_star = rk4_step(r, t, dt, u_field_func)\n\n            if do_projection:\n                norm_r_star = np.linalg.norm(r_star)\n                # Avoid division by zero, though unlikely here\n                if norm_r_star  0:\n                    r = r_star * (R / norm_r_star)\n                else:\n                    r = r_star\n            else:\n                r = r_star\n\n            radius_dev = abs(np.linalg.norm(r) - R)\n            if radius_dev  max_radius_dev:\n                max_radius_dev = radius_dev\n        \n        return r, max_radius_dev\n\n    def get_analytical_solution(r0, T, omega_0, sigma=None):\n        \"\"\"Calculates the analytical solution at time T.\"\"\"\n        if sigma is None:  # Constant rotation\n            theta = omega_0 * T\n        else:  # Time-varying rotation\n            theta = (omega_0 / sigma) * np.sin(sigma * T)\n        \n        cos_theta = np.cos(theta)\n        sin_theta = np.sin(theta)\n        \n        # Rotation matrix around z-axis\n        rot_matrix = np.array([\n            [cos_theta, -sin_theta, 0.0],\n            [sin_theta,  cos_theta, 0.0],\n            [0.0,       0.0,        1.0]\n        ])\n        \n        return rot_matrix @ r0\n\n    # Define test cases from the problem statement\n    R_val = 6371000.0\n    Omega0_val = 7.2921159e-5\n    \n    test_cases = [\n        # Case A\n        {'name': 'A', 'R': R_val, 'Omega0': Omega0_val, 'sigma': None, 'dt': 600.0, 'T': 172800.0, 'r0': np.array([R_val, 0.0, 0.0])},\n        # Case B\n        {'name': 'B', 'R': R_val, 'Omega0': Omega0_val, 'sigma': None, 'dt': 7200.0, 'T': 86400.0, 'r0': np.array([0.0, R_val, 0.0])},\n        # Case C\n        {'name': 'C', 'R': R_val, 'Omega0': Omega0_val, 'sigma': (2.0 * pi) / 86400.0, 'dt': 600.0, 'T': 86400.0, 'r0': np.array([R_val, 0.0, 0.0])},\n    ]\n\n    results = []\n    for case in test_cases:\n        R = case['R']\n        Omega0 = case['Omega0']\n        sigma = case['sigma']\n        dt = case['dt']\n        T = case['T']\n        r0 = case['r0']\n\n        if sigma is None:\n            omega_function = lambda t: Omega0\n        else:\n            omega_function = lambda t: Omega0 * np.cos(sigma * t)\n\n        # 1. Run without projection\n        _, max_dev_no_proj = run_simulation(r0, R, dt, T, omega_function, do_projection=False)\n        \n        # 2. Run with projection\n        r_final_proj, max_dev_proj = run_simulation(r0, R, dt, T, omega_function, do_projection=True)\n\n        # 3. Calculate final great-circle arc-length error\n        r_ref = get_analytical_solution(r0, T, Omega0, sigma)\n        \n        # Clamp argument of arccos to avoid domain errors from floating point issues\n        dot_product_normalized = (r_final_proj @ r_ref) / (R * R)\n        clamped_arg = np.clip(dot_product_normalized, -1.0, 1.0)\n        \n        arc_error = R * np.arccos(clamped_arg)\n\n        results.extend([max_dev_no_proj, max_dev_proj, arc_error])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "拉格朗日轨迹分析的强大之处在于它能揭示复杂流场中隐藏的输运结构。本练习将引导你完成一个高级应用：在一个典型的双涡流模型中计算前向有限时间李雅普诺夫指数（FTLE）场 $\\sigma_T(x_0, y_0)$。通过识别 FTLE 场中的脊线，即拉格朗日相干结构（LCS），我们可以可视化作为物质输运屏障的动态边界，这对于理解海洋中的混合、弥散和生态连通性至关重要。",
            "id": "3797379",
            "problem": "考虑一种被称为双涡流的二维、瞬态、无量纲流动。该速度场定义在矩形域上，其中水平坐标 $x \\in [0,2]$，垂直坐标 $y \\in [0,1]$，时间 $t \\ge 0$。速度场 $\\mathbf{v}(x,y,t) = (u(x,y,t), v(x,y,t))$ 由标量函数 $f(x,t)$ 及其空间导数 $\\partial f/\\partial x$ 按如下方式构造。定义瞬态系数 $a(t)$ 和 $b(t)$ 为\n$$\na(t) = \\varepsilon \\sin(\\omega t), \\qquad b(t) = 1 - 2 \\varepsilon \\sin(\\omega t),\n$$\n以及函数\n$$\nf(x,t) = a(t) x^2 + b(t) x, \\qquad \\frac{\\partial f}{\\partial x}(x,t) = 2 a(t) x + b(t).\n$$\n速度分量为\n$$\nu(x,y,t) = -\\pi A \\sin(\\pi f(x,t)) \\cos(\\pi y), \\qquad v(x,y,t) = \\pi A \\cos(\\pi f(x,t)) \\sin(\\pi y) \\frac{\\partial f}{\\partial x}(x,t),\n$$\n其中 $A0$ 是一个无量纲振幅，$\\varepsilon \\ge 0$ 控制涡流的水平振荡，$\\omega  0$ 是振荡频率。该流动在计算海洋学中被广泛用作瞬态涡流和输运的最小模型。\n\n从拉格朗日视角看，流体粒子的位置 $(x(t), y(t))$ 遵循常微分方程演化\n$$\n\\frac{dx}{dt} = u(x(t), y(t), t), \\qquad \\frac{dy}{dt} = v(x(t), y(t), t),\n$$\n初始条件为 $(x(0), y(0)) = (x_0, y_0)$。流映射 $\\Phi_{0}^{T}$ 将每个初始位置 $(x_0, y_0)$ 在有限积分时间 $T0$ 后映射到最终位置 $(x(T), y(T))$。前向时间有限时间李雅普诺夫指数 (FTLE) 场 $\\sigma_T(x_0, y_0)$ 由流映射梯度的最大奇异值定义。将雅可比矩阵（流映射相对于初始条件的梯度）表示为\n$$\n\\mathbf{J}(x_0, y_0) = \\nabla \\Phi_{0}^{T}(x_0, y_0) = \n\\begin{bmatrix}\n\\frac{\\partial x(T)}{\\partial x_0}  \\frac{\\partial x(T)}{\\partial y_0} \\\\\n\\frac{\\partial y(T)}{\\partial x_0}  \\frac{\\partial y(T)}{\\partial y_0}\n\\end{bmatrix}.\n$$\n右柯西-格林应变张量为\n$$\n\\mathbf{C}(x_0, y_0) = \\mathbf{J}(x_0, y_0)^\\top \\mathbf{J}(x_0, y_0),\n$$\n该张量是对称半正定的。令 $\\lambda_{\\max}(x_0, y_0)$ 表示 $\\mathbf{C}(x_0, y_0)$ 的最大特征值。前向时间 FTLE 为\n$$\n\\sigma_T(x_0, y_0) = \\frac{1}{|T|} \\ln\\left(\\sqrt{\\lambda_{\\max}(x_0, y_0)}\\right).\n$$\n排斥性拉格朗日相干结构 (LCS) 与前向时间 FTLE 场的脊线相关，这些脊线通过最大化前向时间内相邻轨迹的有限时间分离充当输运屏障。\n\n您的任务是在一个独立完整的程序中实现以下内容：\n1. 在域 $[0,2] \\times [0,1]$ 内的初始条件 $(x_0, y_0)$ 均匀网格上，计算前向时间 FTLE 场 $\\sigma_T(x_0, y_0)$，使用粒子运动方程的数值积分和对雅可比矩阵 $\\mathbf{J}(x_0, y_0)$ 的有限差分近似。使用四阶龙格-库塔时间步进法对轨迹进行积分。雅可比矩阵的列应通过流映射相对于初始条件的有限差分来近似，即通过平流 $(x_0, y_0)$、$(x_0+\\delta_0, y_0)$ 和 $(x_0, y_0+\\delta_0)$ 并形成差分，其中 $\\delta_00$ 是一个以无量纲单位表示的小扰动幅度。\n2. 将 FTLE 场中的排斥性 LCS 脊线识别为这样的网格点：相对于其四个轴对齐的邻居（上、下、左、右）是严格的局部最大值，并且其 FTLE 值超过 FTLE 场的预定分位数阈值。令分位数阈值为 $q \\in (0,1)$，并将截断值 $\\tau$ 定义为 FTLE 值集合的 $q$-分位数；只有满足 $\\sigma_T(x_0, y_0) \\ge \\tau$ 且严格大于其四个轴对齐邻居的点才应被标记为脊线。\n3. 对于下面测试套件中每个指定的参数集，计算 FTLE 场及其脊线的以下汇总指标：\n   (i) 网格上的空间平均值 $\\overline{\\sigma}_T$， \n   (ii) 网格上的最大值 $\\sigma_T^{\\max}$，\n   (iii) 根据步骤2中标准检测到的脊线点的整数计数 $N_{\\text{ridge}}$。\n4. 所有量都是无量纲的，因此报告时不应包含物理单位。为保证可复现性，将每个浮点输出四舍五入到六位小数。\n\n使用以下参数值测试套件来检验双涡流和 FTLE 计算的不同行为：\n- 案例1（一般瞬态情况，中等积分时间）：\n  $A = 0.1$, $\\varepsilon = 0.25$, $\\omega = \\frac{2\\pi}{10}$, $T = 5.0$, 时间步长 $\\Delta t = 0.02$, 扰动 $\\delta_0 = 10^{-4}$, 网格分辨率 $N_x = 31$, $N_y = 16$, 分位数阈值 $q = 0.90$。\n- 案例2（更强的平流振幅和更长的积分时间）：\n  $A = 0.2$, $\\varepsilon = 0.25$, $\\omega = \\frac{2\\pi}{10}$, $T = 10.0$, 时间步长 $\\Delta t = 0.02$, 扰动 $\\delta_0 = 10^{-4}$, 网格分辨率 $N_x = 25$, $N_y = 13$, 分位数阈值 $q = 0.90$。\n- 案例3（振荡振幅为零的稳流边界情况）：\n  $A = 0.1$, $\\varepsilon = 0.0$, $\\omega = \\frac{2\\pi}{10}$, $T = 5.0$, 时间步长 $\\Delta t = 0.02$, 扰动 $\\delta_0 = 10^{-4}$, 网格分辨率 $N_x = 31$, $N_y = 16$, 分位数阈值 $q = 0.90$。\n\n您的程序应输出单行，其中包含一个逗号分隔的列表，列表由每个案例的三元组构成，每个三元组及整个列表都用方括号括起来，并且不含空格。格式必须为\n$$\n[[\\overline{\\sigma}_T^{(1)},\\sigma_T^{\\max,(1)},N_{\\text{ridge}}^{(1)}],[\\overline{\\sigma}_T^{(2)},\\sigma_T^{\\max,(2)},N_{\\text{ridge}}^{(2)}],[\\overline{\\sigma}_T^{(3)},\\sigma_T^{\\max,(3)},N_{\\text{ridge}}^{(3)}]],\n$$\n其中上标 $(1)$、$(2)$ 和 $(3)$ 表示案例索引，每个浮点值四舍五入到六位小数，而每个计数是整数。例如，输出应如下所示\n$$\n[[0.123456,0.234567,42],[0.345678,0.456789,37],[0.567890,0.678901,15]].\n$$",
            "solution": "该问题是有效的，因为它在地球物理流体动力学这一成熟领域有科学依据，特别是使用了标准的双涡流模型来研究拉格朗日输运。该问题是适定的，它提供了所有必要的参数、定义以及一组清晰、客观的任务，从而能够得到唯一、可验证的计算结果。这是一个计算科学领域的实质性问题，需要实现用于常微分方程和矩阵分析的数值方法。\n\n任务是为一个二维、瞬态的双涡流计算前向时间有限时间李雅普诺夫指数 (FTLE) 场，将该场中的脊线识别为排斥性拉格朗日相干结构 (LCS)，并报告指定参数集的若干汇总统计量。\n\n速度场 $\\mathbf{v}(x,y,t) = (u(x,y,t), v(x,y,t))$ 定义在域 $x \\in [0,2]$ 和 $y \\in [0,1]$ 上。这些分量由一个标量函数 $f(x,t)$ 及其导数确定。瞬态系数为\n$$\na(t) = \\varepsilon \\sin(\\omega t), \\qquad b(t) = 1 - 2 \\varepsilon \\sin(\\omega t),\n$$\n其中 $\\varepsilon$ 是涡流振荡振幅，$\\omega$ 是振荡频率。它们被用来定义函数 $f(x,t)$ 及其空间导数 $\\frac{\\partial f}{\\partial x}(x,t)$：\n$$\nf(x,t) = a(t) x^2 + b(t) x,\n$$\n$$\n\\frac{\\partial f}{\\partial x}(x,t) = 2 a(t) x + b(t).\n$$\n然后，速度分量由以下公式给出：\n$$\nu(x,y,t) = -\\pi A \\sin(\\pi f(x,t)) \\cos(\\pi y),\n$$\n$$\nv(x,y,t) = \\pi A \\cos(\\pi f(x,t)) \\sin(\\pi y) \\frac{\\partial f}{\\partial x}(x,t),\n$$\n其中 $A$ 是无量纲速度振幅。\n\n一个流体粒子的轨迹，表示为 $\\mathbf{x}(t) = (x(t), y(t))$，由常微分方程(ODEs)组控制：\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{v}(\\mathbf{x}(t), t), \\quad \\text{with initial condition} \\quad \\mathbf{x}(0) = \\mathbf{x}_0 = (x_0, y_0).\n$$\n该常微分方程组的解定义了流映射 $\\Phi_{0}^{T}$，它将一个初始位置 $\\mathbf{x}_0$ 在时间间隔 $[0, T]$ 内平流到其最终位置 $\\mathbf{x}(T)$。我们使用四阶龙格-库塔(RK4)方法对解进行数值近似。对于一个时间步长 $\\Delta t$，将解从时间 $t_n$ 推进到 $t_n + \\Delta t$ 的单个 RK4 步骤为：\n$$\n\\mathbf{x}_{n+1} = \\mathbf{x}_n + \\frac{\\Delta t}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4),\n$$\n其中\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = \\mathbf{v}(\\mathbf{x}_n, t_n), \\\\\n\\mathbf{k}_2 = \\mathbf{v}(\\mathbf{x}_n + \\frac{\\Delta t}{2}\\mathbf{k}_1, t_n + \\frac{\\Delta t}{2}), \\\\\n\\mathbf{k}_3 = \\mathbf{v}(\\mathbf{x}_n + \\frac{\\Delta t}{2}\\mathbf{k}_2, t_n + \\frac{\\Delta t}{2}), \\\\\n\\mathbf{k}_4 = \\mathbf{v}(\\mathbf{x}_n + \\Delta t\\mathbf{k}_3, t_n + \\Delta t).\n\\end{aligned}\n$$\nFTLE 场 $\\sigma_T(\\mathbf{x}_0)$ 量化了在时间间隔 $T$ 内初始相邻粒子分离的最大速率。它源自于流映射的雅可比矩阵，$\\mathbf{J}(\\mathbf{x}_0) = \\nabla \\Phi_{0}^{T}(\\mathbf{x}_0)$。雅可比矩阵的列使用前向有限差分格式进行近似。这需要为三个间距很近的初始位置计算流映射：中心点 $\\mathbf{x}_0 = (x_0, y_0)$、一个x方向扰动点 $(x_0+\\delta_0, y_0)$ 和一个y方向扰动点 $(x_0, y_0+\\delta_0)$，其中 $\\delta_0$ 是一个小扰动。那么 $\\mathbf{J}$ 的列为：\n$$\n\\frac{\\partial \\Phi_{0}^{T}}{\\partial x_0} \\approx \\frac{\\Phi_{0}^{T}(x_0+\\delta_0, y_0) - \\Phi_{0}^{T}(x_0, y_0)}{\\delta_0}, \\qquad\n\\frac{\\partial \\Phi_{0}^{T}}{\\partial y_0} \\approx \\frac{\\Phi_{0}^{T}(x_0, y_0+\\delta_0) - \\Phi_{0}^{T}(x_0, y_0)}{\\delta_0}.\n$$\n根据雅可比矩阵 $\\mathbf{J}$，我们计算右柯西-格林应变张量 $\\mathbf{C}(\\mathbf{x}_0) = \\mathbf{J}(\\mathbf{x}_0)^\\top \\mathbf{J}(\\mathbf{x}_0)$。该张量是对称半正定的，其特征值代表主拉伸的平方。令 $\\lambda_{\\max}(\\mathbf{x}_0)$ 为 $\\mathbf{C}(\\mathbf{x}_0)$ 的最大特征值。FTLE 定义为：\n$$\n\\sigma_T(\\mathbf{x}_0) = \\frac{1}{|T|} \\ln\\left(\\sqrt{\\lambda_{\\max}(\\mathbf{x}_0)}\\right) = \\frac{1}{2|T|} \\ln\\left(\\lambda_{\\max}(\\mathbf{x}_0)\\right).\n$$\n对覆盖域 $[0,2] \\times [0,1]$ 的初始条件 $(x_0, y_0)$ 均匀网格上的每个点执行此计算，以生成 FTLE 场。\n\n在计算出的 FTLE 场中，使用一个两部分标准来识别排斥性 LCS 脊线。一个网格点 $(i, j)$ 被分类为脊线点，如果：\n1.  其 FTLE 值 $\\sigma_T(i, j)$ 大于或等于阈值 $\\tau$，其中 $\\tau$ 是 FTLE 场中所有值的 $q$-分位数。\n2.  $\\sigma_T(i, j)$ 相对于其四个轴对齐的邻居（上、下、左、右）是一个严格的局部最大值。\n\n最后，对于每个参数案例，我们从 FTLE 场计算三个汇总指标：\n1.  空间平均值 $\\overline{\\sigma}_T$：FTLE 网格中所有值的平均值。\n2.  最大值 $\\sigma_T^{\\max}$：FTLE 网格中的最大值。\n3.  脊线计数 $N_{\\text{ridge}}$：满足脊线标准的网格点总数。\n\n整体算法通过迭代每个测试案例来执行。对于一个给定的案例，建立一个初始条件网格。对于每个网格点，使用 RK4 方法对三个轨迹进行积分，以计算雅可比矩阵有限差分近似所需的最终位置。然后计算 FTLE 值。在计算完整个 FTLE 场后，对其进行后处理，以计数脊线点并确定汇总统计量。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It computes FTLE fields, identifies ridges, calculates summary statistics,\n    and prints the results in the required format.\n    \"\"\"\n    test_cases = [\n        {\n            \"A\": 0.1, \"eps\": 0.25, \"omega\": 2 * np.pi / 10, \"T\": 5.0,\n            \"dt\": 0.02, \"delta0\": 1e-4, \"Nx\": 31, \"Ny\": 16, \"q\": 0.90\n        },\n        {\n            \"A\": 0.2, \"eps\": 0.25, \"omega\": 2 * np.pi / 10, \"T\": 10.0,\n            \"dt\": 0.02, \"delta0\": 1e-4, \"Nx\": 25, \"Ny\": 13, \"q\": 0.90\n        },\n        {\n            \"A\": 0.1, \"eps\": 0.0, \"omega\": 2 * np.pi / 10, \"T\": 5.0,\n            \"dt\": 0.02, \"delta0\": 1e-4, \"Nx\": 31, \"Ny\": 16, \"q\": 0.90\n        },\n    ]\n\n    all_results = []\n    for params in test_cases:\n        ftle_field = compute_ftle_field(**params)\n        \n        avg_sigma = np.mean(ftle_field)\n        max_sigma = np.max(ftle_field)\n        \n        tau = np.quantile(ftle_field, params['q'])\n        \n        ridge_count = 0\n        Ny, Nx = ftle_field.shape\n        # Iterate over interior points to check for local maxima\n        for j in range(1, Ny - 1):\n            for i in range(1, Nx - 1):\n                val = ftle_field[j, i]\n                if val = tau:\n                    up = ftle_field[j + 1, i]\n                    down = ftle_field[j - 1, i]\n                    left = ftle_field[j, i - 1]\n                    right = ftle_field[j, i + 1]\n                    if val  up and val  down and val  left and val  right:\n                        ridge_count += 1\n                        \n        all_results.append(\n            f\"[{round(avg_sigma, 6):.6f},{round(max_sigma, 6):.6f},{ridge_count}]\"\n        )\n\n    print(f\"[{','.join(all_results)}]\")\n\ndef velocity(t, pos, A, eps, omega):\n    \"\"\"\n    Computes the velocity vector (u, v) for the double-gyre flow.\n    \n    Args:\n        t (float): Current time.\n        pos (np.ndarray): 2D position [x, y].\n        A (float): Advection amplitude.\n        eps (float): Gyre oscillation amplitude.\n        omega (float): Gyre oscillation frequency.\n\n    Returns:\n        np.ndarray: Velocity vector [u, v].\n    \"\"\"\n    x, y = pos[0], pos[1]\n    \n    a_t = eps * np.sin(omega * t)\n    b_t = 1 - 2 * a_t\n    \n    f_xt = a_t * x**2 + b_t * x\n    dfdx = 2 * a_t * x + b_t\n    \n    sin_pi_f = np.sin(np.pi * f_xt)\n    cos_pi_f = np.cos(np.pi * f_xt)\n    sin_pi_y = np.sin(np.pi * y)\n    cos_pi_y = np.cos(np.pi * y)\n    \n    u = -np.pi * A * sin_pi_f * cos_pi_y\n    v = np.pi * A * cos_pi_f * sin_pi_y * dfdx\n    \n    return np.array([u, v])\n\ndef rk4_step(func, t, y, dt, **kwargs):\n    \"\"\"\n    Performs a single step of the fourth-order Runge-Kutta method.\n    \"\"\"\n    k1 = func(t, y, **kwargs)\n    k2 = func(t + 0.5 * dt, y + 0.5 * dt * k1, **kwargs)\n    k3 = func(t + 0.5 * dt, y + 0.5 * dt * k2, **kwargs)\n    k4 = func(t + dt, y + dt * k3, **kwargs)\n    return y + (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n\ndef compute_flow_map(x0, y0, T, dt, **kwargs):\n    \"\"\"\n    Computes the flow map Phi_0^T by integrating a trajectory.\n    \"\"\"\n    pos = np.array([x0, y0])\n    num_steps = int(round(T / dt))\n    \n    for i in range(num_steps):\n        t = i * dt\n        pos = rk4_step(velocity, t, pos, dt, **kwargs)\n        \n    return pos\n\ndef compute_ftle_field(A, eps, omega, T, dt, delta0, Nx, Ny, q):\n    \"\"\"\n    Computes the FTLE field for a given set of parameters.\n    \"\"\"\n    x_grid = np.linspace(0.0, 2.0, Nx)\n    y_grid = np.linspace(0.0, 1.0, Ny)\n    \n    ftle_field = np.zeros((Ny, Nx))\n    \n    flow_map_args = {\"T\": T, \"dt\": dt, \"A\": A, \"eps\": eps, \"omega\": omega}\n\n    for j in range(Ny):\n        for i in range(Nx):\n            x0, y0 = x_grid[i], y_grid[j]\n            \n            # Advect central and perturbed points\n            pos_T = compute_flow_map(x0, y0, **flow_map_args)\n            pos_T_dx = compute_flow_map(x0 + delta0, y0, **flow_map_args)\n            pos_T_dy = compute_flow_map(x0, y0 + delta0, **flow_map_args)\n            \n            # Approximate Jacobian using finite differences\n            J = np.zeros((2, 2))\n            J[:, 0] = (pos_T_dx - pos_T) / delta0\n            J[:, 1] = (pos_T_dy - pos_T) / delta0\n            \n            # Compute Cauchy-Green tensor C = J^T * J\n            C = J.T @ J\n            \n            # Eigenvalues of the symmetric matrix C\n            lambda_max = np.max(np.linalg.eigvalsh(C))\n            \n            # FTLE calculation, handling lambda_max = 0\n            if lambda_max  0:\n                ftle = (1 / (2 * T)) * np.log(lambda_max)\n            else:\n                ftle = 0.0\n\n            ftle_field[j, i] = ftle\n            \n    return ftle_field\n\nsolve()\n```"
        }
    ]
}