{
    "hands_on_practices": [
        {
            "introduction": "计算有限时间李雅普诺夫指数（FTLE）的核心是右柯西-格林应变张量 $C_{t_0}^t$，而该张量又源于流映射的梯度。在处理复杂流场之前，掌握这种梯度的数值近似方法并理解其精度至关重要。本练习  提供了一个可控的环境来实现这一目标，通过使用一个具有已知解析解的流场，您可以直接实现一个有限差分格式并量化其截断误差，从而为稳健的数值工作奠定核心技能。",
            "id": "3796963",
            "problem": "考虑一个由速度场 $\\mathbf{u}(x,y,t) = \\left(0, \\sin(x)\\right)$ 描述的水平面上的二维不可压缩流，其中角度变量 $x$ 的单位为弧度。设 $\\phi_{t_0}^{t}:\\mathbb{R}^2 \\to \\mathbb{R}^2$ 表示流映射，它将初始时刻 $t_0$ 的粒子位置 $\\mathbf{X}_0 = (x_0,y_0)$ 映射到时刻 $t$ 的位置 $\\mathbf{X}(t) = (x(t),y(t))$。右柯西-格林（Cauchy–Green）应变张量 $C_{t_0}^{t}(\\mathbf{X}_0)$ 定义为 $C_{t_0}^{t}(\\mathbf{X}_0) = \\left(\\nabla \\phi_{t_0}^{t}(\\mathbf{X}_0)\\right)^{\\top}\\nabla \\phi_{t_0}^{t}(\\mathbf{X}_0)$，其中 $\\nabla \\phi_{t_0}^{t}$ 是流映射相对于初始条件的形变梯度。$C_{t_0}^{t}$ 的计算是用于检测拉格朗日相干结构的有限时间李雅普诺夫指数 (FTLE) 诊断方法的核心。\n\n从常微分方程 $\\frac{d\\mathbf{X}}{dt} = \\mathbf{u}(\\mathbf{X},t)$ 出发，使用上述给定的 $\\mathbf{u}$ 和固定的时间间隔 $\\Delta t = t - t_0$，推导解析流映射 $\\phi_{t_0}^{t}$ 及其形变梯度。然后，设计一个数值算法，在初始条件空间中的矩形均匀网格域上，使用二阶中心有限差分来近似 $\\nabla \\phi_{t_0}^{t}$，并由此计算 $C_{t_0}^{t}$。通过与解析 $C_{t_0}^{t}$ 进行比较，分析数值 $C_{t_0}^{t}$ 近似的截断误差与粒子间距（网格间距）的函数关系。\n\n使用以下科学合理且自洽的设置：\n\n- 设初始条件的域为 $\\Omega = [0,2\\pi]\\times[0,1]$，其中 $x_0 \\in [0,2\\pi]$ 单位为弧度，$y_0 \\in [0,1]$ 单位为米。\n- 在 $x_0$ 方向使用 $N_x$ 个点，在 $y_0$ 方向使用 $N_y$ 个点构成均匀网格，因此粒子间距为 $h_x = \\frac{2\\pi}{N_x - 1}$ 和 $h_y = \\frac{1}{N_y - 1}$。\n- 使用固定的时间间隔 $\\Delta t = 1$ 秒。\n- 在内部网格点上，使用关于 $x_0$ 和 $y_0$ 的二阶中心差分计算数值形变梯度 $\\nabla \\phi_{t_0}^{t}$：\n  $\\frac{\\partial \\phi_i}{\\partial x_0}(x_0,y_0) \\approx \\frac{\\phi_i(x_0+h_x,y_0) - \\phi_i(x_0-h_x,y_0)}{2h_x}$ 和\n  $\\frac{\\partial \\phi_i}{\\partial y_0}(x_0,y_0) \\approx \\frac{\\phi_i(x_0,y_0+h_y) - \\phi_i(x_0,y_0-h_y)}{2h_y}$，其中 $i\\in\\{1,2\\}$，$\\phi_1$ 和 $\\phi_2$ 是流映射的分量。\n- 在每个内部网格点，构建数值 $C_{t_0}^{t}$，并使用其与解析 $C_{t_0}^{t}$ 之差的弗罗贝尼乌斯范数进行比较。报告所有内部点上的最大弗罗贝尼乌斯范数误差，该值为无量纲。\n\n仅关注由 $\\nabla \\phi_{t_0}^{t}$ 的有限差分近似引入的截断误差；使用精确的解析流映射来评估网格点上的 $\\phi_{t_0}^{t}$，以避免轨迹积分误差对分析造成污染。\n\n测试套件：\n评估以下情况的最大弗罗贝尼乌斯范数误差，这些情况覆盖了一系列粒子间距，并包括边界受限的配置：\n1. $N_x = 3$, $N_y = 65$。\n2. $N_x = 5$, $N_y = 65$。\n3. $N_x = 9$, $N_y = 65$。\n4. $N_x = 17$, $N_y = 65$。\n\n答案规范：\n- 对每个测试用例，计算一个浮点数，表示内部网格点上的最大弗罗贝尼乌斯范数误差；该值为无量纲。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如 $\\left[ \\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4 \\right]$），顺序与上述测试套件一致。",
            "solution": "基本原理是粒子平流运动学，由 $\\frac{d\\mathbf{X}}{dt} = \\mathbf{u}(\\mathbf{X},t)$ 给出，以及流映射 $\\phi_{t_0}^{t}$ 的定义，即该映射将初始时刻 $t_0$ 的初始条件 $\\mathbf{X}_0$ 映射到时刻 $t$ 的位置 $\\mathbf{X}(t)$。形变梯度为 $\\nabla \\phi_{t_0}^{t}(\\mathbf{X}_0) = \\frac{\\partial \\phi_{t_0}^{t}}{\\partial \\mathbf{X}_0}$，右柯西-格林应变张量为 $C_{t_0}^{t}(\\mathbf{X}_0) = \\left(\\nabla \\phi_{t_0}^{t}(\\mathbf{X}_0)\\right)^{\\top}\\nabla \\phi_{t_0}^{t}(\\mathbf{X}_0)$。\n\n步骤1：针对给定速度场的解析流映射。\n给定速度场 $\\mathbf{u}(x,y,t) = \\left(0, \\sin(x)\\right)$。由于速度场是定常的且仅依赖于 $x$，我们可以将分量形式的常微分方程写为\n$\\frac{dx}{dt} = 0$ 和 $\\frac{dy}{dt} = \\sin(x)$。\n由 $\\frac{dx}{dt} = 0$ 可得，对于所有 $t$，$x(t) = x_0$。当 $x(t) = x_0$ 时，$y$ 方向的方程变为 $\\frac{dy}{dt} = \\sin(x_0)$，在时间间隔 $\\Delta t = t - t_0$ 上积分得到 $y(t) = y_0 + \\Delta t \\sin(x_0)$。因此，流映射为\n$\\phi_{t_0}^{t}(x_0,y_0) = \\left(x_0,\\; y_0 + \\Delta t \\sin(x_0)\\right)$。\n当 $\\Delta t = 1$ 秒时，这简化为 $\\phi_{t_0}^{t}(x_0,y_0) = \\left(x_0,\\; y_0 + \\sin(x_0)\\right)$，但为了推导的普适性，我们保留符号 $\\Delta t$。\n\n步骤2：形变梯度与解析右柯西-格林张量。\n形变梯度是流映射关于初始条件的雅可比矩阵：\n$\\nabla \\phi_{t_0}^{t}(x_0,y_0) = \\begin{pmatrix}\n\\frac{\\partial \\phi_1}{\\partial x_0}  \\frac{\\partial \\phi_1}{\\partial y_0} \\\\\n\\frac{\\partial \\phi_2}{\\partial x_0}  \\frac{\\partial \\phi_2}{\\partial y_0}\n\\end{pmatrix} = \\begin{pmatrix}\n1  0 \\\\\n\\Delta t \\cos(x_0)  1\n\\end{pmatrix}$，\n其中 $\\phi_1(x_0,y_0) = x_0$ 且 $\\phi_2(x_0,y_0) = y_0 + \\Delta t \\sin(x_0)$。于是，解析右柯西-格林张量为\n$C_{t_0}^{t}(x_0,y_0) = \\left(\\nabla \\phi_{t_0}^{t}\\right)^{\\top}\\nabla \\phi_{t_0}^{t} = \\begin{pmatrix}\n1 + \\left(\\Delta t \\cos(x_0)\\right)^2  \\Delta t \\cos(x_0) \\\\\n\\Delta t \\cos(x_0)  1\n\\end{pmatrix}$。\n\n步骤3：网格上形变梯度的数值近似。\n我们考虑一个矩形网格，覆盖域 $\\Omega = [0,2\\pi]\\times[0,1]$，在 $x_0$ 方向有 $N_x$ 个点，在 $y_0$ 方向有 $N_y$ 个点。间距为 $h_x = \\frac{2\\pi}{N_x - 1}$ 和 $h_y = \\frac{1}{N_y - 1}$。我们使用解析表达式计算所有网格点上的流映射。然后，在内部网格点上，我们通过二阶中心有限差分来近似偏导数：\n$\\frac{\\partial \\phi_i}{\\partial x_0}(x_0,y_0) \\approx \\frac{\\phi_i(x_0+h_x,y_0) - \\phi_i(x_0-h_x,y_0)}{2h_x}$ 和\n$\\frac{\\partial \\phi_i}{\\partial y_0}(x_0,y_0) \\approx \\frac{\\phi_i(x_0,y_0+h_y) - \\phi_i(x_0,y_0-h_y)}{2h_y}$，\n其中 $i\\in\\{1,2\\}$。在 $\\phi_i$ 满足光滑性假设的条件下，这些近似具有二阶精度，而这里该条件是成立的，因为 $\\phi_i$ 是 $x_0$ 和 $y_0$ 的光滑函数。\n\n步骤4：通过泰勒展开进行误差分析。\n根据泰勒定理，对于一个光滑标量函数 $f(x)$，中心差分近似 $f'(x) \\approx \\frac{f(x+h) - f(x-h)}{2h}$ 的截断误差为 $E(x;h) = \\frac{h^2}{6}f^{(3)}(\\xi)$，其中某个 $\\xi$ 位于 $(x-h,x+h)$ 区间内。将此应用于 $\\phi_2$ 的 $x_0$ 方向，我们有 $f(x_0) = \\phi_2(x_0,y_0) = y_0 + \\Delta t \\sin(x_0)$，因此 $f'(x_0) = \\Delta t \\cos(x_0)$ 且 $f^{(3)}(x_0) = -\\Delta t \\sin(x_0)$。因此，$\\frac{\\partial \\phi_2}{\\partial x_0}$ 的截断误差为\n$E_{x} = \\frac{h_x^2}{6}\\left(-\\Delta t \\sin(\\xi)\\right)$，\n由于 $\\sin(\\xi)$ 有界，该误差是一致 $\\mathcal{O}(h_x^2)$ 的。对于 $\\phi_1$ 在 $x_0$ 方向， $f(x_0) = x_0$ 是线性的，因此中心差分得到精确导数；类似地，关于 $y_0$ 的导数是常数（$\\frac{\\partial \\phi_1}{\\partial y_0} = 0$，$\\frac{\\partial \\phi_2}{\\partial y_0} = 1$），中心差分能精确地求出它们。因此，唯一非零的截断误差出现在 $\\frac{\\partial \\phi_2}{\\partial x_0}$ 项中，其量级为 $\\mathcal{O}(h_x^2)$。\n\n步骤5：导数误差向 $C_{t_0}^{t}$ 的传播。\n设 $\\nabla \\phi = \\begin{pmatrix} 1  0 \\\\ \\Delta t \\cos(x_0)  1 \\end{pmatrix}$ 为真实形变梯度，其数值近似为 $\\nabla \\phi^{h} = \\begin{pmatrix} 1  0 \\\\ \\Delta t \\cos(x_0) + \\delta  1 \\end{pmatrix}$，其中 $\\delta = \\mathcal{O}(h_x^2)$ 表示 $\\frac{\\partial \\phi_2}{\\partial x_0}$ 的中心差分截断误差。那么\n$C^{h} = \\left(\\nabla \\phi^{h}\\right)^{\\top}\\nabla \\phi^{h} = \\begin{pmatrix}\n1 + \\left(\\Delta t \\cos(x_0) + \\delta\\right)^2  \\Delta t \\cos(x_0) + \\delta \\\\\n\\Delta t \\cos(x_0) + \\delta  1\n\\end{pmatrix}$，\n而\n$C = \\begin{pmatrix}\n1 + \\left(\\Delta t \\cos(x_0)\\right)^2  \\Delta t \\cos(x_0) \\\\\n\\Delta t \\cos(x_0)  1\n\\end{pmatrix}$。\n其差值为\n$C^{h} - C = \\begin{pmatrix}\n2\\Delta t \\cos(x_0)\\,\\delta + \\delta^2  \\delta \\\\\n\\delta  0\n\\end{pmatrix}$。\n该差异在某一点的弗罗贝尼乌斯范数为\n$\\|C^{h} - C\\|_{F} = \\sqrt{\\left(2\\Delta t \\cos(x_0)\\,\\delta + \\delta^2\\right)^2 + 2\\delta^2 + 0^2}$。\n对于小的 $\\delta$（其量级为 $\\mathcal{O}(h_x^2)$），主导项是 $\\delta$ 的线性项，因此 $\\|C^{h} - C\\|_{F} = \\mathcal{O}(h_x^2)$。所以，随着粒子间距的细化，域上的最大弗罗贝尼乌斯范数误差应按 $h_x^2$ 的比例缩放。\n\n步骤6：算法实现细节。\n我们实现网格，在网格点上评估解析流映射 $\\phi_{t_0}^{t}$，在内部网格点上计算中心差分以形成 $\\nabla \\phi^{h}$，构造 $C^{h}$，计算解析 $C$，并评估每个内部点的弗罗贝尼乌斯范数误差。对于由 $(N_x,N_y)$ 指定的每个测试用例，我们报告内部点上的最大弗罗贝尼乌斯范数误差。由于使用解析流映射计算 $\\phi$，不存在轨迹积分误差；唯一的误差源是有限差分截断。随着 $N_x$ 增加（$h_x$ 减小），每当 $h_x$ 减半，误差应大约减少为原来的四分之一，这与二阶精度相符。\n\n最终程序打印一行，其中包含按指定顺序排列的四个测试用例的最大误差列表。",
            "answer": "```python\nimport numpy as np\n\ndef compute_flow_map(X, Y, dt):\n    \"\"\"\n    Analytical flow map for u = (0, sin(x)):\n    phi(x0, y0) = (x0, y0 + dt * sin(x0))\n    \"\"\"\n    phi1 = X.copy()\n    phi2 = Y + dt * np.sin(X)\n    return phi1, phi2\n\ndef compute_numerical_C(phi1, phi2, hx, hy):\n    \"\"\"\n    Compute numerical deformation gradient via central differences at interior points,\n    then construct the right Cauchy-Green tensor C = (Dphi)^T Dphi.\n    Returns C components on interior: C11, C12, C22.\n    \"\"\"\n    # Central differences for interior points\n    # Slices for interior region\n    sl_i = slice(1, -1)\n    sl_j = slice(1, -1)\n\n    dphi1_dx = (phi1[2:, sl_j] - phi1[:-2, sl_j]) / (2.0 * hx)\n    dphi1_dy = (phi1[sl_i, 2:] - phi1[sl_i, :-2]) / (2.0 * hy)\n\n    dphi2_dx = (phi2[2:, sl_j] - phi2[:-2, sl_j]) / (2.0 * hx)\n    dphi2_dy = (phi2[sl_i, 2:] - phi2[sl_i, :-2]) / (2.0 * hy)\n\n    # Construct C = (Dphi)^T Dphi\n    # Dphi = [[a, b],[c, d]] with a=dphi1_dx, b=dphi1_dy, c=dphi2_dx, d=dphi2_dy\n    C11 = dphi1_dx**2 + dphi2_dx**2\n    C12 = dphi1_dx * dphi1_dy + dphi2_dx * dphi2_dy\n    C22 = dphi1_dy**2 + dphi2_dy**2\n    return C11, C12, C22\n\ndef compute_analytical_C(Xi, dt):\n    \"\"\"\n    Analytical C components for the given flow:\n    Dphi = [[1, 0],[dt*cos(x0), 1]]\n    C = [[1 + (dt*cos(x0))**2, dt*cos(x0)],\n         [dt*cos(x0), 1]]\n    \"\"\"\n    cosx = np.cos(Xi)\n    C11 = 1.0 + (dt * cosx)**2\n    C12 = dt * cosx\n    C22 = 1.0\n    return C11, C12, C22\n\ndef max_error_for_case(Nx, Ny, dt):\n    # Grid spacings\n    hx = 2.0 * np.pi / (Nx - 1)\n    hy = 1.0 / (Ny - 1)\n\n    # Create grid of initial conditions\n    x = np.linspace(0.0, 2.0 * np.pi, Nx)\n    y = np.linspace(0.0, 1.0, Ny)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # Analytical flow map\n    phi1, phi2 = compute_flow_map(X, Y, dt)\n\n    # Numerical C at interior points\n    C11_num, C12_num, C22_num = compute_numerical_C(phi1, phi2, hx, hy)\n\n    # Extract interior X for analytical comparison\n    Xi = X[1:-1, 1:-1]\n\n    # Analytical C at interior points\n    C11_true, C12_true, C22_true = compute_analytical_C(Xi, dt)\n\n    # Frobenius norm of difference for symmetric 2x2 matrix:\n    # ||DeltaC||_F = sqrt((d11)^2 + 2*(d12)^2 + (d22)^2)\n    d11 = C11_num - C11_true\n    d12 = C12_num - C12_true\n    d22 = C22_num - C22_true\n    err = np.sqrt(d11**2 + 2.0 * d12**2 + d22**2)\n\n    # Maximum over interior points\n    max_err = float(np.max(err))\n    return max_err\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is (Nx, Ny)\n    test_cases = [\n        (3, 65),\n        (5, 65),\n        (9, 65),\n        (17, 65),\n    ]\n    dt = 1.0  # seconds\n\n    results = []\n    for Nx, Ny in test_cases:\n        result = max_error_for_case(Nx, Ny, dt)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "掌握了流映射梯度的基本近似方法后，我们现在可以构建一个完整的FTLE计算流程。我们将使用经典的双涡流模型，这是一个研究时变流中混沌混合的基准系统。本练习  将指导您完成粒子轨迹的积分，并计算前向和后向FTLE场，从而揭示组织流动的排斥性和吸引性相干结构的动态骨架。",
            "id": "3796942",
            "problem": "给定一个在矩形域 $\\left[x_{\\min},x_{\\max}\\right] \\times \\left[y_{\\min},y_{\\max}\\right] = \\left[0,2\\right] \\times \\left[0,1\\right]$ 上的周期性强迫双涡流速度场，这是计算海洋学中用于研究时间周期性强迫下搅动与混合的经典模型。任务是计算指定参数集下的前向时间和后向时间有限时间李雅普诺夫指数 (FTLE) 场，并量化时间周期性对拉格朗日相干结构 (LCS) 的影响。\n\n从以下基本原理开始：\n- 拉格朗日轨迹满足 $\\dfrac{d\\mathbf{x}}{dt} = \\mathbf{v}(\\mathbf{x},t)$，其中 $\\mathbf{x}(t) = \\left[x(t), y(t)\\right]^T$ 是粒子位置，$\\mathbf{v}(\\mathbf{x},t)$ 是速度场。\n- 拉格朗日流映射 $\\boldsymbol{\\phi}_{t_0}^{t_0+T}$ 将时间 $t_0$ 时的每个初始条件 $\\mathbf{x}_0$ 映射到其在速度场作用下于时间 $t_0+T$ 的位置。\n- 右柯西-格林应变张量为 $\\mathbf{C} = \\left(\\nabla \\boldsymbol{\\phi}_{t_0}^{t_0+T}\\right)^T \\nabla \\boldsymbol{\\phi}_{t_0}^{t_0+T}$，其中 $\\nabla \\boldsymbol{\\phi}_{t_0}^{t_0+T}$ 是流映射相对于初始条件的梯度。\n- 在时间范围 $T$ 和初始时间 $t_0$ 下的有限时间李雅普诺夫指数 (FTLE) 定义为与 $\\mathbf{C}$ 相关的主拉伸的时间归一化对数。\n\n考虑双涡流速度场：\n- 令 $a(t) = \\varepsilon \\sin\\left(\\omega t\\right)$，$b(t) = 1 - 2 \\varepsilon \\sin\\left(\\omega t\\right)$，以及 $f\\left(x,t\\right) = a(t) x^2 + b(t) x$。\n- 速度分量为 $u(x,y,t) = - \\pi A \\sin\\left(\\pi f(x,t)\\right) \\cos\\left(\\pi y\\right)$ 和 $v(x,y,t) = \\pi A \\cos\\left(\\pi f(x,t)\\right) \\sin\\left(\\pi y\\right) \\dfrac{\\partial f}{\\partial x}$，其中 $\\dfrac{\\partial f}{\\partial x} = 2 a(t) x + b(t)$。\n\n您的程序必须：\n- 使用一个 $N_x \\times N_y$ 点的均匀张量网格对域进行离散化，网格间距为 $h_x = \\dfrac{x_{\\max}-x_{\\min}}{N_x-1}$ 和 $h_y = \\dfrac{y_{\\max}-y_{\\min}}{N_y-1}$。\n- 使用固定的时间步长 $\\,\\Delta t\\,$ 和四阶龙格-库塔格式，对所有网格点在指定的时间范围 $T$ 和初始时间 $t_0$ 内进行轨迹的数值积分。对于前向时间 FTLE，进行时间上的前向积分。对于后向时间 FTLE，进行时间上的后向积分。\n- 在每个网格节点处，通过对流映射的有限差分来近似 $\\nabla \\boldsymbol{\\phi}_{t_0}^{t_0+T}$，其中在内部使用中心差分，在边界使用单边差分，并分量式地应用于平流网格的最终位置。\n- 由 $\\nabla \\boldsymbol{\\phi}_{t_0}^{t_0+T}$ 构建 $\\mathbf{C}$，并从 $\\mathbf{C}$ 计算网格上的 FTLE 场。\n- 对于指定的测试案例，计算场的 FTLE 空间平均值和 FTLE 空间最大值。此外，通过比较在 $t_0$ 和 $t_0 + \\dfrac{2\\pi}{\\omega}$ 开始、时间范围 $T$ 相同的两个前向时间 FTLE 场，来量化时间周期性，并报告其相对 $\\ell_2$ 差异，定义为 $\\dfrac{\\left\\|\\sigma_{t_0} - \\sigma_{t_0 + 2\\pi/\\omega}\\right\\|_2}{\\left\\|\\sigma_{t_0}\\right\\|_2}$，其中 $\\sigma_{t}$ 表示在时间 $t$ 开始的 FTLE 场，$\\|\\cdot\\|_2$ 是网格上的欧几里得范数。\n\n所有量均为无量纲。时间以无量纲单位计量；以时间单位的倒数报告 FTLE 值。将所有数值输出表示为小数点后保留 $6$ 位的小数浮点数，不附加任何单位符号。\n\n需要实现和评估的测试套件：\n- 案例 1 (理想情况)：前向时间 FTLE，参数为 $A = 0.1$, $\\varepsilon = 0.25$, $\\omega = \\dfrac{2\\pi}{10}$, $t_0 = 0$, $T = 5$, $\\Delta t = 0.02$, $N_x = 31$, $N_y = 21$。输出两个浮点数：FTLE 空间平均值和 FTLE 空间最大值。\n- 案例 2 (互补的后向时间)：后向时间 FTLE，参数与案例 1 相同，但在 $T=5$ 的时间范围内进行后向积分。输出两个浮点数：FTLE 空间平均值和 FTLE 空间最大值。\n- 案例 3 (短时间范围边界情况)：前向时间 FTLE，参数与案例 1 相同，但 $T=1$。输出两个浮点数：FTLE 空间平均值和 FTLE 空间最大值。\n- 案例 4 (时间周期性检验)：计算在 $t_0 = 0$ 和 $t_0 + \\dfrac{2\\pi}{\\omega}$ 开始的前向时间 FTLE 场之间的相对 $\\ell_2$ 差异，使用相同的 $A, \\varepsilon, \\omega, T = 5, \\Delta t = 0.02, N_x = 31, N_y = 21$。输出一个浮点数：相对差异。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含案例 1-4 的结果，以逗号分隔列表的形式用方括号括起来，顺序完全如下：$\\left[\\text{mean}_{1},\\text{max}_{1},\\text{mean}_{2},\\text{max}_{2},\\text{mean}_{3},\\text{max}_{3},\\text{relL2}_{4}\\right]$，每个浮点数四舍五入到小数点后 $6$ 位。",
            "solution": "该问题要求计算一个周期性强迫双涡流速度场的有限时间李雅普诺夫指数 (FTLE) 场。这涉及理解拉格朗日动力学的基本原理，定义计算方法，并为一组指定的测试案例实施该方法。\n\n### 问题验证\n\n所提供的问题是计算流体动力学和混沌平流研究中的一个标准练习。\n\n**1. 已知条件提取：**\n- **域：** $\\left[x_{\\min},x_{\\max}\\right] \\times \\left[y_{\\min},y_{\\max}\\right] = \\left[0,2\\right] \\times \\left[0,1\\right]$。\n- **速度场：** $u(x,y,t) = - \\pi A \\sin\\left(\\pi f(x,t)\\right) \\cos\\left(\\pi y\\right)$ 和 $v(x,y,t) = \\pi A \\cos\\left(\\pi f(x,t)\\right) \\sin\\left(\\pi y\\right) \\frac{\\partial f}{\\partial x}$，其中 $f\\left(x,t\\right) = a(t) x^2 + b(t) x$，$a(t) = \\varepsilon \\sin\\left(\\omega t\\right)$，$b(t) = 1 - 2 \\varepsilon \\sin\\left(\\omega t\\right)$，以及 $\\frac{\\partial f}{\\partial x} = 2 a(t) x + b(t)$。\n- **拉格朗日动力学：** $\\frac{d\\mathbf{x}}{dt} = \\mathbf{v}(\\mathbf{x},t)$。\n- **流映射：** $\\boldsymbol{\\phi}_{t_0}^{t_0+T}$ 将 $t_0$ 时的初始位置映射到 $t_0+T$ 时的最终位置。\n- **柯西-格林应变张量：** $\\mathbf{C} = \\left(\\nabla \\boldsymbol{\\phi}_{t_0}^{t_0+T}\\right)^T \\nabla \\boldsymbol{\\phi}_{t_0}^{t_0+T}$。\n- **FTLE 定义：** 从 $\\mathbf{C}$ 得到的主拉伸的时间归一化对数。\n- **数值方法：** 均匀网格 ($N_x \\times N_y$)，使用时间步长 $\\Delta t$ 的四阶龙格-库塔积分法，以及用于流映射梯度的有限差分法。\n- **测试案例：** 指定了四个案例，包含参数 $A, \\varepsilon, \\omega, t_0, T, \\Delta t, N_x, N_y$，要求计算前向时间 FTLE、后向时间 FTLE，并进行时间周期性检验。\n\n**2. 验证结论：**\n该问题是**有效**的。它具有科学依据，是适定的、客观且自洽的。双涡流模型是研究拉格朗日相干结构的经典系统。定义和所需计算都是该领域的标准做法。所有必要的参数和数值方法都已指定，从而能够得到一个唯一且可验证的解。\n\n### 基于原理的解决方案设计\n\n该解决方案遵循拉格朗日分析的原理，从控制方程到数值实现，逐步构建。\n\n**1. 控制方程与性质**\n流体粒子 $\\mathbf{x}(t) = [x(t), y(t)]^T$ 的轨迹由常微分方程 (ODE) 控制：\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{v}(\\mathbf{x},t)\n$$\n给定速度场 $\\mathbf{v} = [u, v]^T$ 的一个关键性质是其无散度，这意味着它代表了不可压缩流。我们可以通过计算散度 $\\nabla \\cdot \\mathbf{v} = \\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial y}$ 来验证这一点：\n$$\n\\frac{\\partial u}{\\partial x} = \\frac{\\partial}{\\partial x} \\left[ - \\pi A \\sin\\left(\\pi f(x,t)\\right) \\cos\\left(\\pi y\\right) \\right] = - \\pi^2 A \\cos(\\pi f) \\frac{\\partial f}{\\partial x} \\cos(\\pi y)\n$$\n$$\n\\frac{\\partial v}{\\partial y} = \\frac{\\partial}{\\partial y} \\left[ \\pi A \\cos\\left(\\pi f(x,t)\\right) \\sin\\left(\\pi y\\right) \\frac{\\partial f}{\\partial x} \\right] = \\pi^2 A \\cos(\\pi f) \\cos(\\pi y) \\frac{\\partial f}{\\partial x}\n$$\n将这两项相加得到：\n$$\n\\nabla \\cdot \\mathbf{v} = 0\n$$\n根据刘维尔定理，这种不可压缩性意味着流映射是保面积的，即其梯度的行列式为 1。\n\n**2. 拉格朗日相干结构与 FTLE**\n有限时间李雅普诺夫指数 (FTLE) 场是一个标量场，用于量化在有限时间间隔内初始邻近粒子分离的最大速率。高 FTLE 值的脊线可作为拉格朗日相干结构 (LCS) 的代理，这些结构是组织流动的物质线。\n\n计算过程如下：\n- **流映射 $\\boldsymbol{\\phi}$**：对于时间 $t_0$ 的一组初始条件 $\\mathbf{x}_0$，流映射 $\\boldsymbol{\\phi}_{t_0}^{t_0+T}(\\mathbf{x}_0)$ 给出了在时间范围 $T$ 内积分 ODE 后的最终位置 $\\mathbf{x}(t_0+T)$。\n- **形变梯度 $\\mathbf{F}$**：流映射相对于初始位置的梯度 $\\mathbf{F}(\\mathbf{x}_0) = \\nabla_{\\mathbf{x}_0} \\boldsymbol{\\phi}_{t_0}^{t_0+T}(\\mathbf{x}_0)$，衡量了 $\\mathbf{x}_0$ 周围一个无穷小邻域如何被流所变形。\n- **右柯西-格林应变张量 $\\mathbf{C}$**：这个对称半正定张量定义为 $\\mathbf{C} = \\mathbf{F}^T \\mathbf{F}$。其特征值 $\\lambda_i$ 是主拉伸（$\\mathbf{F}$ 的奇异值）的平方。\n- **FTLE $\\sigma$**：前向时间 FTLE 定义为：\n$$\n\\sigma_{t_0}^{T}(\\mathbf{x}_0) = \\frac{1}{|T|} \\ln\\sqrt{\\lambda_{\\max}(\\mathbf{C})} = \\frac{1}{2|T|} \\ln(\\lambda_{\\max}(\\mathbf{C}))\n$$\n其中 $\\lambda_{\\max}(\\mathbf{C})$ 是 $\\mathbf{C}$ 的最大特征值。因为流是不可压缩的，$\\det(\\mathbf{C}) = \\lambda_{\\min}\\lambda_{\\max} = 1$，这确保了 $\\lambda_{\\max} \\ge 1$，因此 $\\sigma \\ge 0$。\n\n后向时间 FTLE 的计算方法类似，但通过分析从 $t_0$ 到 $t_0 - T$ 的后向时间流动。这能揭示吸引型 LCS（稳定流形），与前向时间 FTLE 所揭示的排斥型 LCS（不稳定流形）互为补充。\n\n**3. 数值算法**\n为进行数值求解，需对连续问题进行离散化。\n\n- **步骤 1：网格生成**。将域 $[0, 2] \\times [0, 1]$ 离散化为一个 $N_x \\times N_y$ 个初始位置 $\\mathbf{x}_{i,j}$ 的均匀网格。\n\n- **步骤 2：轨迹积分**。对于网格上的每个点 $\\mathbf{x}_{i,j}$，我们使用四阶龙格-库塔 (RK4) 格式和固定的时间步长 $\\Delta t$ 求解 ODE $\\dot{\\mathbf{x}} = \\mathbf{v}(\\mathbf{x},t)$，从 $t_0$ 到 $t_0+T$，以找到最终位置 $\\mathbf{x}_{i,j}(t_0+T)$：\n$$\n\\mathbf{x}_{n+1} = \\mathbf{x}_n + \\frac{\\Delta t}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\n其中\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = \\mathbf{v}(t_n, \\mathbf{x}_n) \\\\\n\\mathbf{k}_2 = \\mathbf{v}(t_n + \\frac{\\Delta t}{2}, \\mathbf{x}_n + \\frac{\\Delta t}{2}\\mathbf{k}_1) \\\\\n\\mathbf{k}_3 = \\mathbf{v}(t_n + \\frac{\\Delta t}{2}, \\mathbf{x}_n + \\frac{\\Delta t}{2}\\mathbf{k}_2) \\\\\n\\mathbf{k}_4 = \\mathbf{v}(t_n + \\Delta t, \\mathbf{x}_n + \\Delta t\\mathbf{k}_3)\n\\end{aligned}\n$$\n对于后向时间积分，使用负的积分范围 $T  0$（例如，从 $t_0=0$ 积分到 $t_f = -5$）。\n\n- **步骤 3：流映射梯度估计**。最终位置的集合构成了流映射的离散表示。其梯度的分量 $\\frac{\\partial \\phi_x}{\\partial x}, \\frac{\\partial \\phi_x}{\\partial y}, \\frac{\\partial \\phi_y}{\\partial x}, \\frac{\\partial \\phi_y}{\\partial y}$ 在网格上使用内部的中心差分和边界的单边差分计算。\n\n- **步骤 4：FTLE 场计算**。在每个网格点上：\n    1. 构造形变梯度张量 $\\mathbf{F} = \\begin{pmatrix} \\frac{\\partial \\phi_x}{\\partial x}  \\frac{\\partial \\phi_x}{\\partial y} \\\\ \\frac{\\partial \\phi_y}{\\partial x}  \\frac{\\partial \\phi_y}{\\partial y} \\end{pmatrix}$。\n    2. 计算柯西-格林张量 $\\mathbf{C} = \\mathbf{F}^T \\mathbf{F}$。\n    3. 找到 $2 \\times 2$ 矩阵 $\\mathbf{C}$ 的最大特征值 $\\lambda_{\\max}$。对于 $\\mathbf{C} = \\begin{pmatrix} c_{11}  c_{12} \\\\ c_{12}  c_{22} \\end{pmatrix}$，$\\lambda_{\\max} = \\frac{1}{2}\\left(c_{11} + c_{22} + \\sqrt{(c_{11} - c_{22})^2 + 4c_{12}^2}\\right)$。\n    4. 使用公式 $\\sigma = \\frac{1}{2|T|} \\ln(\\lambda_{\\max})$ 计算 FTLE 值。\n\n**4. 测试案例分析**\n- **案例 1-3：** 这些案例涉及对不同的积分范围 $T$ 直接应用上述算法。计算所得 FTLE 场 $\\sigma_{i,j}$ 的空间平均值和最大值。\n- **案例 4 (时间周期性)：** 速度场 $\\mathbf{v}(\\mathbf{x}, t)$ 在时间上是周期的，周期为 $P = 2\\pi/\\omega$。该性质意味着流映射本身相对于其起始时间也是周期的，即 $\\boldsymbol{\\phi}_{t_0+P}^{t_0+P+T} = \\boldsymbol{\\phi}_{t_0}^{t_0+T}$。因此，FTLE 场也必须是周期的：$\\sigma_{t_0+P}^T = \\sigma_{t_0}^T$。此案例通过计算在 $t_0 = 0$ 开始的 FTLE 场与在 $t_0' = 0 + P$ 开始的场之间的相对 $\\ell_2$ 差异，来数值验证此性质。理论结果为 0；任何非零值都是由数值浮点误差引起的。相对差异计算为 $\\frac{\\left\\|\\sigma_{t_0} - \\sigma_{t_0'}\\right\\|_2}{\\left\\|\\sigma_{t_0}\\right\\|_2}$，其中 $\\|\\cdot\\|_2$ 是网格上值的标准欧几里得范数。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to compute results for all test cases.\n    \"\"\"\n\n    def get_velocity(t, pos, A, eps, omega):\n        \"\"\"\n        Calculates the double-gyre velocity field for an array of particles.\n        \n        Args:\n            t (float): Current time.\n            pos (np.ndarray): Particle positions, shape (N, 2).\n            A (float): Gyre amplitude.\n            eps (float): Forcing amplitude.\n            omega (float): Forcing frequency.\n\n        Returns:\n            np.ndarray: Velocity vectors, shape (N, 2).\n        \"\"\"\n        x = pos[:, 0]\n        y = pos[:, 1]\n        \n        sin_omega_t = np.sin(omega * t)\n        a_t = eps * sin_omega_t\n        b_t = 1.0 - 2.0 * eps * sin_omega_t\n        \n        f_xt = a_t * x**2 + b_t * x\n        dfdx_t = 2.0 * a_t * x + b_t\n        \n        sin_pi_f = np.sin(np.pi * f_xt)\n        cos_pi_f = np.cos(np.pi * f_xt)\n        sin_pi_y = np.sin(np.pi * y)\n        cos_pi_y = np.cos(np.pi * y)\n        \n        u = -np.pi * A * sin_pi_f * cos_pi_y\n        v = np.pi * A * cos_pi_f * sin_pi_y * dfdx_t\n        \n        return np.stack((u, v), axis=-1)\n\n    def compute_ftle_field(A, eps, omega, t0, T, dt, Nx, Ny):\n        \"\"\"\n        Computes the FTLE field for the given parameters.\n        \n        Args:\n            A, eps, omega: Velocity field parameters.\n            t0 (float): Initial time.\n            T (float): Integration horizon (can be negative for backward FTLE).\n            dt (float): Time step for RK4 integrator.\n            Nx, Ny (int): Grid dimensions.\n            \n        Returns:\n            np.ndarray: The computed FTLE field, shape (Ny, Nx).\n        \"\"\"\n        # 1. Grid Generation\n        xmin, xmax = 0.0, 2.0\n        ymin, ymax = 0.0, 1.0\n        hx = (xmax - xmin) / (Nx - 1)\n        hy = (ymax - ymin) / (Ny - 1)\n        x_grid = np.linspace(xmin, xmax, Nx)\n        y_grid = np.linspace(ymin, ymax, Ny)\n        x0_mesh, y0_mesh = np.meshgrid(x_grid, y_grid)\n        initial_pos = np.stack((x0_mesh.ravel(), y0_mesh.ravel()), axis=-1)\n\n        # 2. Trajectory Integration (RK4)\n        current_pos = initial_pos.copy()\n        current_time = t0\n        \n        # Use negative dt for backward integration\n        time_step = dt if T > 0 else -dt\n        num_steps = int(round(abs(T / time_step)))\n\n        for _ in range(num_steps):\n            k1 = get_velocity(current_time, current_pos, A, eps, omega)\n            k2 = get_velocity(current_time + 0.5 * time_step, current_pos + 0.5 * time_step * k1, A, eps, omega)\n            k3 = get_velocity(current_time + 0.5 * time_step, current_pos + 0.5 * time_step * k2, A, eps, omega)\n            k4 = get_velocity(current_time + time_step, current_pos + time_step * k3, A, eps, omega)\n            current_pos += (time_step / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n            current_time += time_step\n            \n        final_pos_grid = current_pos.reshape(Ny, Nx, 2)\n\n        # 3. Flow Map Gradient\n        phi_x = final_pos_grid[:, :, 0]\n        phi_y = final_pos_grid[:, :, 1]\n        \n        dphix_dy, dphix_dx = np.gradient(phi_x, hy, hx)\n        dphiy_dy, dphiy_dx = np.gradient(phi_y, hy, hx)\n\n        # 4. FTLE Computation\n        # Deformation Gradient Tensor F (shape: Ny, Nx, 2, 2)\n        F = np.zeros((Ny, Nx, 2, 2))\n        F[:, :, 0, 0] = dphix_dx\n        F[:, :, 0, 1] = dphix_dy\n        F[:, :, 1, 0] = dphiy_dx\n        F[:, :, 1, 1] = dphiy_dy\n\n        # Right Cauchy-Green Strain Tensor C = F^T F\n        # Using einsum for batched matrix multiplication: F.T @ F\n        C = np.einsum('...ji,...ik->...jk', F, F)\n        \n        # Max eigenvalue of C\n        c11, c12, c22 = C[:, :, 0, 0], C[:, :, 0, 1], C[:, :, 1, 1]\n        trace = c11 + c22\n        # Use numerically stable formula\n        sqrt_term = np.sqrt(np.maximum(0, (c11 - c22)**2 + 4 * c12**2))\n        lambda_max = 0.5 * (trace + sqrt_term)\n\n        # FTLE formula (sigma = 1/(2*|T|) * ln(lambda_max))\n        # The flow is incompressible, so lambda_max >= 1, no need for log(0) check.\n        with np.errstate(divide='ignore', invalid='ignore'):\n            ftle_field = (1.0 / (2.0 * abs(T))) * np.log(lambda_max)\n        \n        # Replace NaNs or Infs that might arise from edge cases, though unlikely\n        ftle_field[~np.isfinite(ftle_field)] = 0.0\n\n        return ftle_field\n\n    # Common parameters for all cases\n    params = {\n        'A': 0.1,\n        'eps': 0.25,\n        'omega': (2 * np.pi) / 10,\n        't0': 0.0,\n        'T': 5.0,\n        'dt': 0.02,\n        'Nx': 31,\n        'Ny': 21\n    }\n    \n    results = []\n\n    # Case 1: Forward-time FTLE, T=5\n    p1 = params.copy()\n    ftle1 = compute_ftle_field(**p1)\n    results.append(f\"{np.mean(ftle1):.6f}\")\n    results.append(f\"{np.max(ftle1):.6f}\")\n\n    # Case 2: Backward-time FTLE, T=5\n    p2 = params.copy()\n    # To integrate backward, we use a negative integration horizon T\n    p2['T'] = -5.0\n    ftle2 = compute_ftle_field(**p2)\n    results.append(f\"{np.mean(ftle2):.6f}\")\n    results.append(f\"{np.max(ftle2):.6f}\")\n\n    # Case 3: Forward-time FTLE, T=1\n    p3 = params.copy()\n    p3['T'] = 1.0\n    ftle3 = compute_ftle_field(**p3)\n    results.append(f\"{np.mean(ftle3):.6f}\")\n    results.append(f\"{np.max(ftle3):.6f}\")\n\n    # Case 4: Time-periodicity check\n    p4 = params.copy()\n    period = (2 * np.pi) / p4['omega']\n    \n    # FTLE field starting at t0=0\n    sigma_t0 = compute_ftle_field(**p4)\n    \n    # FTLE field starting at t0=period\n    p4['t0'] = period\n    sigma_t0_plus_period = compute_ftle_field(**p4)\n    \n    norm_diff = np.linalg.norm(sigma_t0 - sigma_t0_plus_period)\n    norm_orig = np.linalg.norm(sigma_t0)\n    \n    relative_l2_diff = norm_diff / norm_orig if norm_orig > 0 else 0.0\n    results.append(f\"{relative_l2_diff:.6f}\")\n\n    # Final output formatting\n    print(f\"[{','.join(results)}]\")\n\n\nsolve()\n```"
        },
        {
            "introduction": "真实的海洋模型通常使用曲线网格，以更好地表示复杂的海岸线和海底地形。在这种情况下计算FTLE需要比在简单笛卡尔网格上更复杂的方法。这项高级练习  挑战您将FTLE计算流程应用于曲线坐标系。您将学习如何使用网格的雅可比矩阵变换速度并正确计算形变梯度，这是将LCS诊断应用于先进海洋模型输出的关键技能。",
            "id": "3796951",
            "problem": "给定一个定义在矩形逻辑域 $(\\xi,\\eta)\\in[0,1]\\times[0,1]$ 上的曲线二维海洋模型网格，该网格被映射到物理空间 $(x,y)$ 中，长度单位为米，时间单位为秒。该映射是平滑且可逆的，三角函数内的角度以弧度为单位。粒子遵循由常微分方程 $d\\mathbf{X}/dt=\\mathbf{u}(\\mathbf{X},t)$ 控制的轨迹，其中 $\\mathbf{X}=(x,y)$ 是粒子位置，$\\mathbf{u}=(u,v)$ 是以米/秒为单位的欧拉速度场。您的任务是实现一个完整的流程，用于计算该曲线网格上指定种子点位置的有限时间李雅普诺夫指数 $\\sigma_{t_0}^{t}$。\n\n从第一性原理开始：\n- 使用轨迹定义 $d\\mathbf{X}/dt=\\mathbf{u}(\\mathbf{X},t)$ 和流映射 $\\boldsymbol{\\phi}_{t_0}^{t}$，该流映射通过对轨迹进行积分，将时间 $t_0$ 的初始位置映射到时间 $t$ 的最终位置。\n- 使用通过物理坐标中流映射的梯度定义的右 Cauchy–Green 应变张量来量化有限时间拉伸。\n- 将有限时间李雅普诺夫指数计算为由右 Cauchy–Green 应变张量所隐含的最大物质拉伸的单位时间自然对数率。\n\n您必须在代码中实现以下流程步骤：\n1. 在时间 $t_0$ 于逻辑坐标 $(\\xi_0,\\eta_0)$ 中进行粒子播种，并通过网格映射将种子点转换为初始物理坐标。\n2. 使用四阶 Runge–Kutta 方法在逻辑坐标中进行轨迹积分，通过雅可比矩阵来解释曲线映射。具体来说，速度在物理坐标中定义，但积分在逻辑坐标中执行；因此，您必须使用沿轨迹评估的映射的逆雅可比矩阵将 $d\\mathbf{X}/dt$ 转换为 $d(\\xi,\\eta)/dt$。\n3. 将定义在曲线网格节点上的速度场值插值到任意粒子位置。在每个 Runge–Kutta 子步中，使用逻辑坐标中的双线性插值来评估粒子位置处的欧拉速度。\n4. 通过相对于初始逻辑坐标的中心有限差分进行流映射差分，并通过种子点处的雅可比矩阵将其一致地映射到初始物理微分。此过程构建了流映射的物理坐标梯度。\n5. 对右 Cauchy–Green 应变张量进行特征分析，以获得主有限时间拉伸，从而得到有限时间李雅普诺夫指数 $\\sigma_{t_0}^{t}$。\n\n使用以下科学上合理且自洽的设置：\n- 曲线映射 $(\\xi,\\eta)\\mapsto(x,y)$：\n  $$x(\\xi,\\eta)=L_x\\left[\\xi+\\alpha\\,c\\,\\sin(2\\pi\\xi)\\sin(2\\pi\\eta)\\right],\\quad y(\\xi,\\eta)=L_y\\left[\\eta+\\alpha\\,c\\,\\sin(2\\pi\\xi)\\sin(2\\pi\\eta)\\right],$$\n  其中 $L_x$ 和 $L_y$ 是以米为单位的域大小，$\\alpha$ 是无量纲的网格曲率振幅，$c=0.05$ 是一个固定的无量纲常数，角度以弧度为单位。雅可比矩阵 $\\mathbf{J}=\\partial(x,y)/\\partial(\\xi,\\eta)$ 必须从这些表达式中导出，并用于映射初始物理微分以及通过 $\\mathbf{J}^{-1}$ 将物理速度转换为逻辑时间导数。\n- 在物理坐标中定义在网格节点上的欧拉速度场：\n  $$u(x,y)=S\\,y,\\quad v(x,y)=0,$$\n  其中 $S$ 是一个以秒的倒数为单位的恒定剪切率。通过在映射的物理位置 $(x(\\xi_i,\\eta_j),y(\\xi_i,\\eta_j))$ 处对此速度进行采样来填充曲线网格节点。\n- 有限时间李雅普诺夫指数定义：在种子点处构建流映射的物理坐标梯度，形成相关的右 Cauchy–Green 应变张量，并计算最大物质拉伸的单位时间自然对数率。最终值以秒的倒数表示。\n\n数值要求：\n- 在逻辑坐标中执行 Runge–Kutta 积分，每个测试指定一个固定的时间步长 $\\Delta t$。如果需要，通过裁剪确保逻辑坐标保持在 $[0,1]$ 范围内。\n- 对于 $u$ 和 $v$，使用逻辑坐标中的双线性插值，从网格化值中获取。\n- 在初始逻辑坐标中使用中心差分，并指定一个小的逻辑增量 $\\delta_\\xi=\\delta_\\eta$，以近似最终物理位置相对于初始逻辑坐标的导数。通过种子点处的雅可比矩阵将这些逻辑微分映射到初始物理微分，以获得流映射的物理坐标梯度。\n- 使用对称特征分析来获得右 Cauchy–Green 应变张量的最大特征值。\n\n单位和输出：\n- 长度必须以米为单位，时间以秒为单位，角度以弧度为单位，速度以米/秒为单位，有限时间李雅普诺夫指数必须以秒的倒数为单位报告。\n- 您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3]”）。每个结果必须是格式化为六位小数的浮点数，并表示相应测试用例的有限时间李雅普诺夫指数 $\\sigma_{t_0}^{t}$，单位为 $\\mathrm{s}^{-1}$。\n\n实现程序以评估以下测试套件，涵盖一般情况、边界邻近性、反向时间积分和增加的网格曲率：\n- 测试 1 (一般情况): $N_x=50$, $N_y=40$, $L_x=100000\\,\\mathrm{m}$, $L_y=100000\\,\\mathrm{m}$, $\\alpha=0.10$, $S=10^{-5}\\,\\mathrm{s}^{-1}$, 种子点 $(\\xi_0,\\eta_0)=(0.35,0.65)$, $t_0=0\\,\\mathrm{s}$, $t=200000\\,\\mathrm{s}$, $\\Delta t=200\\,\\mathrm{s}$, $\\delta_\\xi=\\delta_\\eta=10^{-3}$。\n- 测试 2 (边界邻近性): $N_x=50$, $N_y=40$, $L_x=100000\\,\\mathrm{m}$, $L_y=100000\\,\\mathrm{m}$, $\\alpha=0.10$, $S=10^{-5}\\,\\mathrm{s}^{-1}$, 种子点 $(\\xi_0,\\eta_0)=(0.05,0.10)$, $t_0=0\\,\\mathrm{s}$, $t=50000\\,\\mathrm{s}$, $\\Delta t=200\\,\\mathrm{s}$, $\\delta_\\xi=\\delta_\\eta=10^{-3}$。\n- 测试 3 (反向时间): $N_x=50$, $N_y=40$, $L_x=100000\\,\\mathrm{m}$, $L_y=100000\\,\\mathrm{m}$, $\\alpha=0.10$, $S=10^{-5}\\,\\mathrm{s}^{-1}$, 种子点 $(\\xi_0,\\eta_0)=(0.50,0.50)$, $t_0=0\\,\\mathrm{s}$, $t=-200000\\,\\mathrm{s}$, $\\Delta t=200\\,\\mathrm{s}$, $\\delta_\\xi=\\delta_\\eta=10^{-3}$。\n- 测试 4 (增加的曲率): $N_x=50$, $N_y=40$, $L_x=100000\\,\\mathrm{m}$, $L_y=100000\\,\\mathrm{m}$, $\\alpha=0.20$, $S=10^{-5}\\,\\mathrm{s}^{-1}$, 种子点 $(\\xi_0,\\eta_0)=(0.80,0.20)$, $t_0=0\\,\\mathrm{s}$, $t=200000\\,\\mathrm{s}$, $\\Delta t=200\\,\\mathrm{s}$, $\\delta_\\xi=\\delta_\\eta=10^{-3}$。\n\n您的程序应生成单行输出，其中包含四个测试的有限时间李雅普诺夫指数值，格式为浮点数，保留六位小数，单位为秒的倒数，并按测试顺序排列：“[result_test1,result_test2,result_test3,result_test4]”。",
            "solution": "用户提供的问题陈述已经过严格验证，被认为是具有科学依据、适定且客观的。它为在曲线网格上计算有限时间李雅普诺夫指数（FTLE）提供了一套完整且一致的定义、物理参数和数值要求。该问题是动力系统理论应用于流体动力学领域的一个标准任务，尽管计算量较大。指定的方法，包括 Runge-Kutta 积分、双线性插值以及 Cauchy-Green 应变张量的使用，都是适当且成熟的。所提供的物理和数值常数是合理的。关于反向积分的时间步长 $\\Delta t$ 符号的已识别歧义，通过遵循标准惯例得以解决，即从 $t_0$ 到最终时间 $t  t_0$ 的反向积分使用负时间步长执行。我们接下来将提供一个完整的解决方案。\n\n问题的核心是计算有限时间李雅普诺夫指数 $\\sigma_{t_0}^{t}$，它量化了在时间间隔 $[t_0, t]$ 内无限接近的粒子之间的最大分离率。该解决方案方法论涉及基于连续介质力学和数值分析基本原理的几个相互关联的步骤。\n\n首先，我们定义数学框架。\n\n**1. 坐标系与映射**\n粒子存在于具有笛卡尔坐标 $\\mathbf{X} = (x, y)^T$ 的物理空间中。它们的运动在一个具有坐标 $\\boldsymbol{\\xi} = (\\xi, \\eta)^T \\in [0,1] \\times [0,1]$ 的逻辑网格上进行分析。从逻辑空间到物理空间的映射由以下公式给出：\n$$x(\\xi,\\eta)=L_x\\left[\\xi+\\alpha\\,c\\,\\sin(2\\pi\\xi)\\sin(2\\pi\\eta)\\right]$$\n$$y(\\xi,\\eta)=L_y\\left[\\eta+\\alpha\\,c\\,\\sin(2\\pi\\xi)\\sin(2\\pi\\eta)\\right]$$\n其中 $L_x, L_y, \\alpha$ 和 $c$ 是问题中定义的常数。此映射的局部变形由雅可比矩阵 $\\mathbf{J}$ 描述，其分量是映射函数的偏导数：\n$$\n\\mathbf{J}(\\boldsymbol{\\xi}) = \\frac{\\partial(x,y)}{\\partial(\\xi,\\eta)} = \n\\begin{pmatrix} \n\\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial x}{\\partial \\eta} \\\\\n\\frac{\\partial y}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\eta} \n\\end{pmatrix}\n$$\n这些导数的解析表达式为：\n$$\\frac{\\partial x}{\\partial \\xi} = L_x [1 + 2\\pi\\alpha c \\cos(2\\pi\\xi)\\sin(2\\pi\\eta)]$$\n$$\\frac{\\partial x}{\\partial \\eta} = L_x [2\\pi\\alpha c \\sin(2\\pi\\xi)\\cos(2\\pi\\eta)]$$\n$$\\frac{\\partial y}{\\partial \\xi} = L_y [2\\pi\\alpha c \\cos(2\\pi\\xi)\\sin(2\\pi\\eta)]$$\n$$\\frac{\\partial y}{\\partial \\eta} = L_y [1 + 2\\pi\\alpha c \\sin(2\\pi\\xi)\\cos(2\\pi\\eta)]$$\n\n**2. 逻辑坐标中的轨迹积分**\n粒子轨迹由物理坐标中的常微分方程（ODE）控制：\n$$\\frac{d\\mathbf{X}}{dt} = \\mathbf{u}(\\mathbf{X}, t)$$\n为了在结构化的逻辑域中执行积分，我们使用链式法则关联物理速度和逻辑速度：$\\frac{d\\mathbf{X}}{dt} = \\mathbf{J}(\\boldsymbol{\\xi}(t)) \\frac{d\\boldsymbol{\\xi}}{dt}$。这得到了逻辑坐标中的 ODE：\n$$\\frac{d\\boldsymbol{\\xi}}{dt} = \\mathbf{J}^{-1}(\\boldsymbol{\\xi}(t)) \\, \\mathbf{u}(\\mathbf{X}(\\boldsymbol{\\xi}(t)), t)$$\n该 ODE 使用四阶 Runge-Kutta (RK4) 方法进行数值积分。对于一个时间步长 $\\Delta t$，从时间 $t_n$ 的 $\\boldsymbol{\\xi}_n$ 到时间 $t_{n+1}$ 的 $\\boldsymbol{\\xi}_{n+1}$ 的更新为：\n$$\\boldsymbol{\\xi}_{n+1} = \\boldsymbol{\\xi}_n + \\frac{\\Delta t}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)$$\n其中各阶段计算如下：\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = \\mathbf{J}^{-1}(\\boldsymbol{\\xi}_n) \\, \\mathbf{u}(\\mathbf{X}(\\boldsymbol{\\xi}_n), t_n) \\\\\n\\mathbf{k}_2 = \\mathbf{J}^{-1}(\\boldsymbol{\\xi}_n + \\frac{\\Delta t}{2}\\mathbf{k}_1) \\, \\mathbf{u}(\\mathbf{X}(\\boldsymbol{\\xi}_n + \\frac{\\Delta t}{2}\\mathbf{k}_1), t_n + \\frac{\\Delta t}{2}) \\\\\n\\mathbf{k}_3 = \\mathbf{J}^{-1}(\\boldsymbol{\\xi}_n + \\frac{\\Delta t}{2}\\mathbf{k}_2) \\, \\mathbf{u}(\\mathbf{X}(\\boldsymbol{\\xi}_n + \\frac{\\Delta t}{2}\\mathbf{k}_2), t_n + \\frac{\\Delta t}{2}) \\\\\n\\mathbf{k}_4 = \\mathbf{J}^{-1}(\\boldsymbol{\\xi}_n + \\Delta t\\mathbf{k}_3) \\, \\mathbf{u}(\\mathbf{X}(\\boldsymbol{\\xi}_n + \\Delta t\\mathbf{k}_3), t_n + \\Delta t)\n\\end{aligned}\n$$\n速度场 $\\mathbf{u}(\\mathbf{X}(\\boldsymbol{\\xi}))$ 在每个阶段通过对逻辑网格节点上预先计算的值进行双线性插值来评估。对于积分时长 $T = t-t_0$，步数为 $N_{steps} = \\lceil |T|/\\Delta t \\rceil$，在 RK4 算法中使用的带符号时间步长为 $dt_{signed} = T/N_{steps}$。\n\n**3. 速度场插值**\n欧拉速度场 $\\mathbf{u} = (u,v)^T$ 由 $u(x,y)=S\\,y$ 和 $v(x,y)=0$ 给出。为了便于高效插值，首先在逻辑网格的每个节点上计算速度分量。对于每个节点 $(\\xi_i, \\eta_j)$，其中 $\\xi_i = i/(N_x-1)$ 和 $\\eta_j = j/(N_y-1)$，我们找到对应的物理坐标 $(x_{ij}, y_{ij})$ 并评估速度分量 $u_{ij} = S\\,y_{ij}$ 和 $v_{ij}=0$。对于在 RK4 积分过程中遇到的任何任意逻辑坐标 $\\boldsymbol{\\xi}$，速度 $\\mathbf{u}(\\mathbf{X}(\\boldsymbol{\\xi}))$ 通过对预先计算的速度网格 $(u_{ij}, v_{ij})$ 进行双线性插值来近似。\n\n**4. 流映射梯度与 Cauchy-Green 应变张量**\n流映射 $\\boldsymbol{\\phi}_{t_0}^t$ 将时间 $t_0$ 的初始位置 $\\mathbf{X}_0 = \\mathbf{X}(\\boldsymbol{\\xi}_0)$ 映射到时间 $t$ 的最终位置 $\\mathbf{X}(t)$。FTLE 的计算需要该映射的梯度，$\\mathbf{F} = \\frac{\\partial \\mathbf{X}(t)}{\\partial \\mathbf{X}_0}$。使用链式法则，可以将其表示为：\n$$\\mathbf{F} = \\frac{\\partial \\mathbf{X}(t)}{\\partial \\boldsymbol{\\xi}_0} \\left( \\frac{\\partial \\mathbf{X}_0}{\\partial \\boldsymbol{\\xi}_0} \\right)^{-1} = \\frac{\\partial \\mathbf{X}(t)}{\\partial \\boldsymbol{\\xi}_0} \\mathbf{J}^{-1}(\\boldsymbol{\\xi}_0)$$\n项 $\\frac{\\partial \\mathbf{X}(t)}{\\partial \\boldsymbol{\\xi}_0}$ 使用中心有限差分计算。我们积分四条从受扰动的初始逻辑位置开始的辅助轨迹：$(\\xi_0 \\pm \\delta_\\xi, \\eta_0)$ 和 $(\\xi_0, \\eta_0 \\pm \\delta_\\eta)$。令最终物理位置分别为 $\\mathbf{X}_{\\xi\\pm}(t)$ 和 $\\mathbf{X}_{\\eta\\pm}(t)$。然后导数矩阵近似为：\n$$\n\\frac{\\partial \\mathbf{X}(t)}{\\partial \\boldsymbol{\\xi}_0} \\approx \\begin{pmatrix} \n\\frac{x_{\\xi+}(t) - x_{\\xi-}(t)}{2 \\delta_\\xi}  \\frac{x_{\\eta+}(t) - x_{\\eta-}(t)}{2 \\delta_\\eta} \\\\\n\\frac{y_{\\xi+}(t) - y_{\\xi-}(t)}{2 \\delta_\\xi}  \\frac{y_{\\eta+}(t) - y_{\\eta-}(t)}{2 \\delta_\\eta}\n\\end{pmatrix}\n$$\n计算出 $\\mathbf{F}$ 后，通过 $\\mathbf{C} = \\mathbf{F}^T \\mathbf{F}$ 得到右 Cauchy-Green 应变张量 $\\mathbf{C}$。这个 $2 \\times 2$ 矩阵是对称且半正定的。\n\n**5. 有限时间李雅普诺夫指数 (FTLE)**\n$\\mathbf{C}$ 的特征值，记为 $\\lambda_1, \\lambda_2$，量化了物质元的主拉伸平方。最大拉伸为 $\\sqrt{\\lambda_{max}}$，其中 $\\lambda_{max} = \\max(\\lambda_1, \\lambda_2)$。FTLE 场 $\\sigma_{t_0}^{t}$ 定义为该最大拉伸的自然对数，并按积分时间 $|t-t_0|$ 进行归一化：\n$$\\sigma_{t_0}^{t}(\\mathbf{X}_0) = \\frac{1}{|t-t_0|} \\ln\\sqrt{\\lambda_{max}} = \\frac{1}{2|t-t_0|} \\ln(\\lambda_{max})$$\n对称矩阵 $\\mathbf{C}$ 的特征值是使用标准数值特征求解器找到的。\n\n对于提供的每个测试用例，实现将精确地遵循这些步骤。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the FTLE computation problem for the given test cases.\n    \"\"\"\n    \n    test_cases = [\n        {'Nx': 50, 'Ny': 40, 'Lx': 100000.0, 'Ly': 100000.0, 'alpha': 0.10, 'S': 1e-5, 'seed_xi': 0.35, 'seed_eta': 0.65, 't0': 0.0, 't_final': 200000.0, 'dt_mag': 200.0, 'delta': 1e-3},\n        {'Nx': 50, 'Ny': 40, 'Lx': 100000.0, 'Ly': 100000.0, 'alpha': 0.10, 'S': 1e-5, 'seed_xi': 0.05, 'seed_eta': 0.10, 't0': 0.0, 't_final': 50000.0, 'dt_mag': 200.0, 'delta': 1e-3},\n        {'Nx': 50, 'Ny': 40, 'Lx': 100000.0, 'Ly': 100000.0, 'alpha': 0.10, 'S': 1e-5, 'seed_xi': 0.50, 'seed_eta': 0.50, 't0': 0.0, 't_final': -200000.0, 'dt_mag': 200.0, 'delta': 1e-3},\n        {'Nx': 50, 'Ny': 40, 'Lx': 100000.0, 'Ly': 100000.0, 'alpha': 0.20, 'S': 1e-5, 'seed_xi': 0.80, 'seed_eta': 0.20, 't0': 0.0, 't_final': 200000.0, 'dt_mag': 200.0, 'delta': 1e-3},\n    ]\n\n    c = 0.05  # Fixed nondimensional constant\n    \n    results = []\n    for params in test_cases:\n        ftle = compute_ftle_for_case(c=c, **params)\n        results.append(f\"{ftle:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef get_mapping_functions(Lx, Ly, alpha, c):\n    \"\"\"Returns functions for the grid mapping and its Jacobian.\"\"\"\n    def map_to_physical(xi, eta):\n        term = alpha * c * np.sin(2 * np.pi * xi) * np.sin(2 * np.pi * eta)\n        x = Lx * (xi + term)\n        y = Ly * (eta + term)\n        return np.array([x, y])\n\n    def jacobian(xi, eta):\n        J = np.zeros((2, 2))\n        sin_2pi_xi, cos_2pi_xi = np.sin(2 * np.pi * xi), np.cos(2 * np.pi * xi)\n        sin_2pi_eta, cos_2pi_eta = np.sin(2 * np.pi * eta), np.cos(2 * np.pi * eta)\n        \n        factor = 2 * np.pi * alpha * c\n        \n        J[0, 0] = Lx * (1 + factor * cos_2pi_xi * sin_2pi_eta)\n        J[0, 1] = Lx * (factor * sin_2pi_xi * cos_2pi_eta)\n        J[1, 0] = Ly * (factor * cos_2pi_xi * sin_2pi_eta)\n        J[1, 1] = Ly * (1 + factor * sin_2pi_xi * cos_2pi_eta)\n        return J\n        \n    return map_to_physical, jacobian\n\ndef get_velocity_interpolator(Nx, Ny, S, map_func):\n    \"\"\"Returns a bilinear interpolator for the velocity field.\"\"\"\n    xi_grid = np.linspace(0, 1, Nx)\n    eta_grid = np.linspace(0, 1, Ny)\n    \n    u_grid = np.zeros((Ny, Nx))\n    v_grid = np.zeros((Ny, Nx)) # v is always 0 for this problem\n    \n    for j in range(Ny):\n        for i in range(Nx):\n            _, y_phys = map_func(xi_grid[i], eta_grid[j])\n            u_grid[j, i] = S * y_phys\n    \n    def interpolate(xi, eta):\n        # Normalize coordinates\n        px = xi * (Nx - 1)\n        py = eta * (Ny - 1)\n        \n        # Get indices of bottom-left corner of the cell\n        i = int(px)\n        j = int(py)\n\n        # Clip indices to stay within bounds\n        i = min(i, Nx - 2)\n        j = min(j, Ny - 2)\n        i = max(i, 0)\n        j = max(j, 0)\n        \n        # Local coordinates within the cell\n        wx = px - i\n        wy = py - j\n        \n        # Bilinear interpolation for u\n        u_interp = (u_grid[j, i] * (1 - wx) * (1 - wy) +\n                    u_grid[j, i + 1] * wx * (1 - wy) +\n                    u_grid[j + 1, i] * (1 - wx) * wy +\n                    u_grid[j + 1, i + 1] * wx * wy)\n\n        # v is zero everywhere, so interpolated v is also zero\n        v_interp = 0.0\n\n        return np.array([u_interp, v_interp])\n\n    return interpolate\n\ndef integrate_trajectory(xi0_eta0, t0, t_final, dt_mag, vel_interpolator, jacobian_func):\n    \"\"\"\n    Integrates a particle trajectory using RK4 from t0 to t_final.\n    \"\"\"\n    xi_eta = np.array(xi0_eta0, dtype=float)\n    \n    integration_time = t_final - t0\n    if integration_time == 0:\n        return xi_eta\n    \n    num_steps = int(np.ceil(np.abs(integration_time) / dt_mag))\n    dt = integration_time / num_steps\n\n    def d_xi_eta_dt(pos_xi_eta):\n        # Clip logical coordinates to [0,1] for Jacobian and velocity evaluation\n        pos_xi_eta_clipped = np.clip(pos_xi_eta, 0.0, 1.0)\n        u_v = vel_interpolator(pos_xi_eta_clipped[0], pos_xi_eta_clipped[1])\n        J = jacobian_func(pos_xi_eta_clipped[0], pos_xi_eta_clipped[1])\n        try:\n            J_inv = np.linalg.inv(J)\n        except np.linalg.LinAlgError:\n            # If Jacobian is singular, velocity is zero. Not expected in this problem.\n            return np.zeros(2)\n        return J_inv @ u_v\n\n    for _ in range(num_steps):\n        k1 = d_xi_eta_dt(xi_eta)\n        k2 = d_xi_eta_dt(xi_eta + 0.5 * dt * k1)\n        k3 = d_xi_eta_dt(xi_eta + 0.5 * dt * k2)\n        k4 = d_xi_eta_dt(xi_eta + dt * k3)\n        xi_eta += (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n        xi_eta = np.clip(xi_eta, 0.0, 1.0) # Clip after each step as per requirement\n\n    return xi_eta\n\ndef compute_ftle_for_case(Nx, Ny, Lx, Ly, alpha, S, c, seed_xi, seed_eta, t0, t_final, dt_mag, delta):\n    \"\"\"\n    Computes the FTLE for a single test case.\n    \"\"\"\n    map_to_physical, jacobian_func = get_mapping_functions(Lx, Ly, alpha, c)\n    vel_interpolator = get_velocity_interpolator(Nx, Ny, S, map_to_physical)\n\n    # Initial seed positions for central differencing\n    xi0 = np.array([seed_xi, seed_eta])\n    xi0_xp = np.array([seed_xi + delta, seed_eta])\n    xi0_xm = np.array([seed_xi - delta, seed_eta])\n    xi0_yp = np.array([seed_xi, seed_eta + delta])\n    xi0_ym = np.array([seed_xi, seed_eta - delta])\n    \n    # Integrate trajectories for each perturbed initial condition\n    final_xi_xp = integrate_trajectory(xi0_xp, t0, t_final, dt_mag, vel_interpolator, jacobian_func)\n    final_xi_xm = integrate_trajectory(xi0_xm, t0, t_final, dt_mag, vel_interpolator, jacobian_func)\n    final_xi_yp = integrate_trajectory(xi0_yp, t0, t_final, dt_mag, vel_interpolator, jacobian_func)\n    final_xi_ym = integrate_trajectory(xi0_ym, t0, t_final, dt_mag, vel_interpolator, jacobian_func)\n\n    # Map final logical positions to physical positions\n    X_final_xp = map_to_physical(final_xi_xp[0], final_xi_xp[1])\n    X_final_xm = map_to_physical(final_xi_xm[0], final_xi_xm[1])\n    X_final_yp = map_to_physical(final_xi_yp[0], final_xi_yp[1])\n    X_final_ym = map_to_physical(final_xi_ym[0], final_xi_ym[1])\n\n    # Compute derivative of final physical position w.r.t. initial logical position\n    dXdxi0 = np.zeros((2, 2))\n    dXdxi0[:, 0] = (X_final_xp - X_final_xm) / (2 * delta)\n    dXdxi0[:, 1] = (X_final_yp - X_final_ym) / (2 * delta)\n\n    # Compute Jacobian at the initial seed position\n    J0 = jacobian_func(xi0[0], xi0[1])\n    J0_inv = np.linalg.inv(J0)\n\n    # Compute the flow map gradient tensor F\n    F = dXdxi0 @ J0_inv\n    \n    # Compute the right Cauchy-Green strain tensor C\n    C = F.T @ F\n    \n    # Find the maximum eigenvalue of C\n    # eigvalsh is for Hermitian (or real symmetric) matrices\n    eigenvalues = np.linalg.eigvalsh(C)\n    lambda_max = np.max(eigenvalues)\n    \n    integration_time = np.abs(t_final - t0)\n    \n    if integration_time == 0 or lambda_max = 0:\n        return 0.0\n\n    # Compute the FTLE\n    ftle = (1.0 / (2.0 * integration_time)) * np.log(lambda_max)\n    \n    return ftle\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}