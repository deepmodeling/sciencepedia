{
    "hands_on_practices": [
        {
            "introduction": "经验正交函数（EOF）分析旨在分离时空数据中的主要变异模式。此分析的第一步，也是最基础的一步，是将原始数据转换为距平（anomaly）数据。本练习将指导您完成这一至关重要的数据预处理步骤，通过从一个假设的海表温度（SST）场中移除时间平均值来构建距平矩阵，并以数值方式验证其基本属性()。",
            "id": "3792009",
            "problem": "考虑经验正交函数（EOF）分析，该分析需要在每个空间位置上构建一个时间均值为零的距平矩阵。设一个海表温度（SST）场由矩阵 $S \\in \\mathbb{R}^{N \\times T}$ 表示，其中 $N$ 是空间格点的数量，$T$ 是时间步长的数量，矩阵项 $S_{i t}$ 表示在格点 $i$ 和时间索引 $t$ 处的SST（单位：摄氏度）。距平矩阵 $X \\in \\mathbb{R}^{N \\times T}$ 的定义是在每个格点上减去其时间平均值。形式上，格点 $i$ 处的时间平均值定义为 $\\mu_i = \\frac{1}{T}\\sum_{t=0}^{T-1} S_{i t}$，距平矩阵的元素定义为 $X_{i t} = S_{i t} - \\mu_i$。为进行数值验证，定义一个容差 $\\tau = 10^{-12}$。如果 $\\left|\\frac{1}{T}\\sum_{t=0}^{T-1} X_{i t}\\right| \\le \\tau$ 成立，则称第 $i$ 行为零均值。任务是为每个测试用例计算 $X$，并验证 $X$ 的每一行在数值精度上是否为零均值。\n\n你必须使用给定的确定性公式为以下每个测试用例构建 $S$。所有公式中的索引都是从零开始的：$i \\in \\{0,1,\\dots,N-1\\}$ 和 $t \\in \\{0,1,\\dots,T-1\\}$。所有SST值均以摄氏度为单位。\n\n测试套件：\n- 用例 $1$：$N=4$，$T=5$，$S_{i t} = 20 + 0.5\\,i - 0.3\\,t + 0.5\\,(-1)^t$。\n- 用例 $2$：$N=3$，$T=1$，$S_{i 0} = 14 + 6\\,i$。\n- 用例 $3$：$N=2$，$T=8$，$S_{i t} = 10^{7} + 10^{5}\\,i + 1000\\,t + 100\\,(-1)^t$。\n- 用例 $4$：$N=1$，$T=6$，$S_{0 t} = 18$ 对所有 $t$。\n- 用例 $5$：$N=5$，$T=7$，$S_{i t} = 10 + 0.2\\,i + 0.01\\,t^2 - 0.5\\,t$。\n\n对于每个用例：\n1. 计算每一行 $i$ 的时间平均值 $\\mu_i$。\n2. 通过 $X_{i t} = S_{i t} - \\mu_i$ 计算距平矩阵 $X$。\n3. 验证 $X$ 的每一行的平均值是否在容差范围内，即对于所有行 $i$ 都有 $\\left|\\frac{1}{T}\\sum_{t=0}^{T-1} X_{i t}\\right| \\le \\tau$，使用 $\\tau = 10^{-12}$。\n4. 返回一个布尔值，指示是否所有行都满足零均值条件。\n\n你的程序应生成单行输出，其中包含五个用例的结果，形式为方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4,result5]”），其中每个条目都是一个布尔值（“True”或“False”）。",
            "solution": "已对用户提供的问题进行分析，并认定其有效。\n\n该问题要求实现和验证经验正交函数（EOF）分析中的一个基本步骤：创建距平矩阵。这个任务具有科学依据、是适定的且客观的。它提出了一个植根于计算海洋学领域的明确计算挑战。所有必要的参数、定义和公式都已提供，构成一个自洽且可解的问题。\n\n该任务的核心是将数据矩阵 $S \\in \\mathbb{R}^{N \\times T}$ 转换为距平矩阵 $X \\in \\mathbb{R}^{N \\times T}$。这里，$N$ 代表空间位置的数量，$T$ 代表时间步长的数量。元素 $S_{i t}$ 是空间点 $i$ 和时间 $t$ 上的数据值（海表温度）。\n\n该转换定义为从每个空间点减去其时间平均值。给定空间点 $i$（$S$ 的第 $i$ 行）的时间平均值由下式给出：\n$$\n\\mu_i = \\frac{1}{T}\\sum_{t=0}^{T-1} S_{i t}\n$$\n相应的距平矩阵 $X$ 则通过从该行中的每个元素减去这个平均值来构建：\n$$\nX_{i t} = S_{i t} - \\mu_i\n$$\n距平矩阵 $X$ 的一个关键数学性质是，根据定义，其每一行的时间平均值为零。我们可以解析地证明这一点：\n$$\n\\text{Mean of row } i \\text{ of } X = \\frac{1}{T}\\sum_{t=0}^{T-1} X_{i t} = \\frac{1}{T}\\sum_{t=0}^{T-1} (S_{i t} - \\mu_i)\n$$\n将求和运算进行分配：\n$$\n= \\left(\\frac{1}{T}\\sum_{t=0}^{T-1} S_{i t}\\right) - \\left(\\frac{1}{T}\\sum_{t=0}^{T-1} \\mu_i\\right)\n$$\n第一项是 $\\mu_i$ 的定义。由于 $\\mu_i$ 相对于求和索引 $t$ 是一个常数，第二项简化为 $\\frac{1}{T}(T \\cdot \\mu_i) = \\mu_i$。因此：\n$$\n= \\mu_i - \\mu_i = 0\n$$\n该问题要求对这一性质进行数值验证。在数字计算机中，浮点运算可能会引入微小的精度误差。因此，与 $0$ 的直接比较可能会失败。问题指定了一个容差 $\\tau = 10^{-12}$，如果计算出的某行平均值的绝对值在此容差范围内，则认为该行 $i$ 具有零均值：\n$$\n\\left|\\frac{1}{T}\\sum_{t=0}^{T-1} X_{i t}\\right| \\le \\tau\n$$\n每个测试用例的最终结果是一个布尔值（`True`），前提是其距平矩阵 $X$ 的所有 $N$ 行都满足此条件，否则为 `False`。\n\n解决每个测试用例问题的算法如下：\n1.  初始化一个 $N \\times T$ 的浮点数矩阵 $S$。\n2.  根据给定用例的指定公式 $S_{i t}$ 填充矩阵 $S$，遍历每个空间索引 $i \\in \\{0, \\dots, N-1\\}$ 和时间索引 $t \\in \\{0, \\dots, T-1\\}$。\n3.  计算 $S$ 每一行的时间平均值。这可以通过沿时间对应的轴（在行主序实现中为轴1）计算平均值来高效实现。这将产生一个均值向量 $\\boldsymbol{\\mu} \\in \\mathbb{R}^{N}$。\n4.  通过从数据矩阵 $S$ 中减去均值向量来构建距平矩阵 $X$。此操作需要将每行的均值广播到该行的所有元素上。对于一个 $N \\times T$ 矩阵 $S$ 和一个 $N \\times 1$ 的均值列向量，减法 $X = S - \\boldsymbol{\\mu}$ 会逐元素执行此操作。\n5.  计算所得距平矩阵 $X$ 每一行的时间平均值。\n6.  对于每个新计算出的行均值，检查其绝对值是否小于或等于容差 $\\tau=10^{-12}$。\n7.  如果第6步的条件对所有行都成立，则该测试用例的总体结果为 `True`，否则为 `False`。\n此过程将应用于所提供的所有五个测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes anomaly matrices for several SST test cases and verifies\n    if each row has a zero temporal mean to numerical precision.\n    \"\"\"\n\n    # Define the tolerance for numerical verification.\n    tau = 1e-12\n\n    # Define the test cases from the problem statement.\n    # Each case is a dictionary with N, T, and a lambda function for S_it.\n    test_cases = [\n        {\n            \"N\": 4, \"T\": 5,\n            \"formula\": lambda i, t: 20 + 0.5 * i - 0.3 * t + 0.5 * (-1)**t,\n        },\n        {\n            \"N\": 3, \"T\": 1,\n            \"formula\": lambda i, t: 14 + 6 * i,\n        },\n        {\n            \"N\": 2, \"T\": 8,\n            \"formula\": lambda i, t: 10**7 + 10**5 * i + 1000 * t + 100 * (-1)**t,\n        },\n        {\n            \"N\": 1, \"T\": 6,\n            \"formula\": lambda i, t: 18.0,\n        },\n        {\n            \"N\": 5, \"T\": 7,\n            \"formula\": lambda i, t: 10 + 0.2 * i + 0.01 * t**2 - 0.5 * t,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        T = case[\"T\"]\n        formula = case[\"formula\"]\n\n        # 1. Construct the SST matrix S\n        S = np.zeros((N, T), dtype=np.float64)\n        for i in range(N):\n            for t in range(T):\n                S[i, t] = formula(i, t)\n\n        # 2. Compute the temporal mean mu_i for each row i.\n        #    The shape of mu will be (N, 1) for broadcasting.\n        mu = S.mean(axis=1, keepdims=True)\n\n        # 3. Compute the anomaly matrix X.\n        #    Broadcasting subtracts mu[i, 0] from every element in row i of S.\n        X = S - mu\n\n        # 4. Verify that the mean of each row of X is within the tolerance.\n        #    Compute the mean of each row of the anomaly matrix.\n        X_row_means = X.mean(axis=1)\n\n        # 5. Check if the absolute value of all row means are = tau.\n        #    np.all returns True if all elements in the iterable are True.\n        all_rows_verified = np.all(np.abs(X_row_means) = tau)\n        \n        results.append(all_rows_verified)\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) converts boolean True/False to strings \"True\"/\"False\".\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在构建了距平矩阵后，EOF分析的核心便是对其进行分解，以提取空间模式（EOFs）和时间演变（主成分，PCs）。奇异值分解（SVD）为此提供了强大的数学框架。本练习旨在通过对一个小型综合数据集进行SVD分解，并数值验证EOF、PC与协方差矩阵特征值之间的基本关系，从而加深您对EOF分析理论基础的理解()。",
            "id": "3791994",
            "problem": "给定一组小型的合成数据矩阵，这些矩阵代表了计算海洋学中的标准化异常场。令 $\\tilde{X} \\in \\mathbb{R}^{m \\times n}$ 表示一个异常矩阵，其行索引空间位置，列索引时间。在经验正交函数（EOF）分析中，通过将 $\\tilde{X}$ 分解为正交归一的空间基、时间基和一组非负振幅，可以获得空间模态（EOF）和时间系数（主成分，PC）。您必须从第一性原理出发，证明振幅的平方与空间协方差算子 $\\tilde{X}\\tilde{X}^{\\top}$ 的特征值之间的关系。您的任务是构建一个程序，对于每个测试矩阵，计算奇异值分解，显式构造经验正交函数（EOF）和主成分（PC），并验证三个属性：(i) 振幅的平方与 $\\tilde{X}\\tilde{X}^{\\top}$ 的特征值相匹配，(ii) 分解能够重构数据，以及 (iii) 空间基和时间基是正交归一的。\n\n首次使用时的定义：\n- 经验正交函数（Empirical Orthogonal Function, EOF）：对应于时空异常场最优正交归一分解的空间基向量。\n- 主成分（Principal Component, PC）：与空间EOF相关联的时间系数。\n- 奇异值分解（Singular Value Decomposition, SVD）：一种数值分解方法，能为任何实矩阵产出正交归一的基和非负振幅。\n\n对于下面测试套件中的每个矩阵 $\\tilde{X}$，请执行以下操作：\n1. 计算一个数值分解，得到一组正交归一的空间向量（EOF）、一组正交归一的时间向量（PC方向）和非负的标量振幅。将空间EOF表示为 $U$ 的列，PC表示为 $V^{\\top}$ 的行，振幅表示为非负向量 $S$ 的元素。\n2. 验证在将两组数据按降序排序后，振幅的平方 $S^2$ 与 $\\tilde{X}\\tilde{X}^{\\top}$ 的特征值在 $10^{-10}$ 的容差范围内相匹配。\n3. 验证分解在 $10^{-12}$ 的相对误差容差内重构了 $\\tilde{X}$（如果 $\\|\\tilde{X}\\|_F=0$，则使用 $10^{-12}$ 的绝对误差容差）。\n4. 通过检查 $U^{\\top}U=I$ 和 $V^{\\top}V=I$ 在 $10^{-12}$ 的容差范围内是否成立，来验证空间基和时间基是正交归一的。\n\n矩阵测试套件：\n- 情况 $1$ (正常路径, $3 \\times 4$): $\\tilde{X}_1 = \\begin{bmatrix} 1.2  -0.3  0.5  -1.4 \\\\ 0.8  -0.2  -0.1  -0.5 \\\\ -0.6  0.7  -0.9  0.8 \\end{bmatrix}$。\n- 情况 $2$ (秩亏, $3 \\times 3$): $\\tilde{X}_2 = \\begin{bmatrix} 1  -1  0 \\\\ 2  -2  0 \\\\ -1  1  0 \\end{bmatrix}$。\n- 情况 $3$ (边界情况, 全零, $3 \\times 3$): $\\tilde{X}_3 = \\begin{bmatrix} 0  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{bmatrix}$。\n- 情况 $4$ (重复的振幅, $2 \\times 2$): $\\tilde{X}_4 = \\begin{bmatrix} 2  0 \\\\ 0  2 \\end{bmatrix}$。\n- 情况 $5$ (宽矩形, $2 \\times 5$): $\\tilde{X}_5 = \\begin{bmatrix} 3  -1  -2  0  0 \\\\ -2  2  1  -1  0 \\end{bmatrix}$。\n\n对于每种情况，您的程序必须计算：\n- 一个布尔值，指示在按降序排序后，$S^2$ 是否在 $10^{-10}$ 的容差内等于 $\\tilde{X}\\tilde{X}^{\\top}$ 的特征值。\n- 一个布尔值，指示重构误差准则是否在 $10^{-12}$ 的容差内得到满足（相对误差，如果 $\\|\\tilde{X}\\|_F=0$ 则为绝对误差）。\n- 一个布尔值，指示正交归一性条件 $U^{\\top}U=I$ 和 $V^{\\top}V=I$ 是否都在 $10^{-12}$ 的容差内得到满足。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含五个测试用例的结果，格式为一个由布尔值列表组成的逗号分隔列表，无空格，例如：\"[[True,True,True],[True,True,True],[True,True,True],[True,True,True],[True,True,True]]\"。",
            "solution": "该问题陈述是有效的。它提出了一个定义明确的计算任务，该任务基于线性代数中已确立的数学原理，特别是奇异值分解（SVD）及其与协方差矩阵特征分解的关系。这种关系是经验正交函数（EOF）分析的理论基础，而EOF分析是海洋学和气候科学中的一种标准方法。该问题提供了所有必要的数据、定义和精确、客观的验证标准，使其成为一个完整且可解的问题。\n\nEOF分析的核心是将一个时空数据矩阵 $\\tilde{X} \\in \\mathbb{R}^{m \\times n}$（其中 $m$ 代表空间位置，$n$ 代表时间点）分解为一组正交的空间模态及其对应的时间振幅。奇异值分解（SVD）为此任务提供了一个自然且数值稳健的框架。\n\n矩阵 $\\tilde{X}$ 的SVD分解由下式给出：\n$$\n\\tilde{X} = U \\Sigma V^{\\top}\n$$\n其中：\n- $U \\in \\mathbb{R}^{m \\times m}$ 是一个正交矩阵，其列是左奇异向量。在EOF分析的背景下，这些是空间基向量，称为经验正交函数（EOF）。\n- $V \\in \\mathbb{R}^{n \\times n}$ 是一个正交矩阵，其列是右奇异向量。这些代表了时间域的一组正交归一基，通常称为PC方向。\n- $\\Sigma \\in \\mathbb{R}^{m \\times n}$ 是一个矩形对角矩阵，按降序包含非负的奇异值 $s_i$。这些值是相应模态的振幅。\n\n主成分（PC）代表空间模态的时间序列，由矩阵乘积 $\\Sigma V^{\\top}$ 的行给出。\n\n验证任务包括三个部分，每个部分都确认了SVD在此背景下的一个基本属性。\n\n**第1部分：验证平方振幅与特征值**\n\n此验证基于 $\\tilde{X}$ 的SVD与空间协方差矩阵 $C_{space} = \\tilde{X}\\tilde{X}^{\\top}$ 的特征分解之间的联系。空间协方差矩阵衡量不同空间点之间随时间变化的协方差。其特征向量代表了空间变率的主要模态，这正是EOF。\n\n让我们将 $\\tilde{X}$ 的SVD代入 $C_{space}$ 的定义中：\n$$\nC_{space} = \\tilde{X}\\tilde{X}^{\\top} = (U \\Sigma V^{\\top})(U \\Sigma V^{\\top})^{\\top}\n$$\n使用属性 $(AB)^{\\top} = B^{\\top}A^{\\top}$，我们得到：\n$$\nC_{space} = (U \\Sigma V^{\\top})(V \\Sigma^{\\top} U^{\\top})\n$$\n由于 $V$ 是一个正交矩阵，所以 $V^{\\top}V = I$，其中 $I$ 是单位矩阵。表达式简化为：\n$$\nC_{space} = U (\\Sigma \\Sigma^{\\top}) U^{\\top}\n$$\n这个方程是对称矩阵 $C_{space}$ 的特征值分解。$U$ 的列是特征向量（即EOF），而对角矩阵 $\\Lambda = \\Sigma \\Sigma^{\\top}$ 包含特征值。$\\Lambda$ 的对角元素是 $\\tilde{X}$ 的SVD得到的奇异值 $s_i$ 的平方。具体来说，如果 $\\tilde{X}$ 是一个 $m \\times n$ 矩阵，那么 $\\Sigma \\Sigma^{\\top}$ 是一个 $m \\times m$ 的对角矩阵，其前 $k = \\min(m, n)$ 个对角元素是 $s_1^2, s_2^2, \\ldots, s_k^2$，剩下的 $m-k$ 个元素为零（如果 $m  n$）。\n因此，$\\tilde{X}\\tilde{X}^{\\top}$ 的特征值必须等于 $\\tilde{X}$ 的奇异值的平方（必要时用零填充）。数值验证包括计算这两组数，将它们按降序排序，并在指定的数值容差（此处为 $10^{-10}$）内检查是否相等。\n\n**第2部分：验证数据重构**\n\n方程 $\\tilde{X} = U \\Sigma V^{\\top}$ 本身就说明了原始数据矩阵可以从其SVD分量中完美重构。在有限精度算术的计算环境中，我们期望这种重构能精确到微小的浮点误差。验证步骤通过计算重构矩阵 $\\tilde{X}_{rec} = U \\Sigma V^{\\top}$ 并测量其相对于原始矩阵 $\\tilde{X}$ 的误差来证实这一点。为此使用了弗罗贝尼乌斯范数 $\\|\\cdot\\|_F$。相对误差计算如下：\n$$\n\\text{Error}_{rel} = \\frac{\\|\\tilde{X} - \\tilde{X}_{rec}\\|_F}{\\|\\tilde{X}\\|_F}\n$$\n将此误差与 $10^{-12}$ 的容差进行比较。对于 $\\tilde{X}$ 是零矩阵的特殊情况，$\\|\\tilde{X}\\|_F=0$，检查将转为绝对误差 $\\|\\tilde{X} - \\tilde{X}_{rec}\\|_F \\le 10^{-12}$。\n\n**第3部分：验证正交归一性**\n\nSVD的一个决定性属性是矩阵 $U$ 和 $V$ 是正交的。正交性意味着任何两个不同列的点积为零，任何列与自身的点积为一。这可以用矩阵形式简洁地表示：\n$$\nU^{\\top}U = I_m \\quad \\text{和} \\quad V^{\\top}V = I_n\n$$\n其中 $I_m$ 和 $I_n$ 分别是大小为 $m$ 和 $n$ 的单位矩阵。从实践角度看，当使用“经济”SVD（其中 $U$ 是 $m \\times k$，$V$ 是 $n \\times k$，$k=\\min(m,n)$）时，相应的属性是 $U^\\top U = I_k$ 和 $V^\\top V = I_k$。验证步骤检查数值计算出的矩阵是否满足这些恒等式，从而确认空间基（$U$ 中的EOF）和时间基（$V$ 中的PC方向）确实是正交归一的向量集，数值容差在 $10^{-12}$ 以内。在实现中，SVD例程返回 $V^{\\top}$（表示为 `Vh`），对 $V$ 的检查就变成了对 `Vh` 的检查，因为 $(Vh^\\top)^\\top(Vh^\\top) = Vh Vh^\\top = I_k$。\n\n程序将为每个提供的测试矩阵实现这三个验证步骤，展示SVD的理论属性与其数值实现之间的一致性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run EOF analysis verification on the test suite of matrices.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: happy path, 3x4\n        np.array([\n            [1.2, -0.3, 0.5, -1.4],\n            [0.8, -0.2, -0.1, -0.5],\n            [-0.6, 0.7, -0.9, 0.8]\n        ]),\n        # Case 2: rank-deficient, 3x3\n        np.array([\n            [1., -1., 0.],\n            [2., -2., 0.],\n            [-1., 1., 0.]\n        ]),\n        # Case 3: boundary, all zeros, 3x3\n        np.array([\n            [0., 0., 0.],\n            [0., 0., 0.],\n            [0., 0., 0.]\n        ]),\n        # Case 4: repeated amplitudes, 2x2\n        np.array([\n            [2., 0.],\n            [0., 2.]\n        ]),\n        # Case 5: rectangular wide, 2x5\n        np.array([\n            [3., -1., -2., 0., 0.],\n            [-2., 2., 1., -1., 0.]\n        ])\n    ]\n\n    results = []\n    for x_tilde in test_cases:\n        results.append(verify_eof_properties(x_tilde))\n\n    # Format the final output string to match the problem specification\n    # e.g., [[True,True,True],[True,True,True],...]\n    formatted_results = []\n    for res in results:\n        # Convert each boolean in the inner list to a string\n        inner_list_str = ','.join(map(str, res))\n        # Enclose in brackets\n        formatted_results.append(f\"[{inner_list_str}]\")\n    \n    # Join the formatted inner lists and enclose in outer brackets\n    final_output = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output)\n\ndef verify_eof_properties(x_tilde):\n    \"\"\"\n    Performs SVD and verifies the three specified properties for a given matrix.\n\n    Args:\n        x_tilde (np.ndarray): The input anomaly matrix.\n\n    Returns:\n        list: A list of three booleans corresponding to the three verified properties.\n    \"\"\"\n    m, n = x_tilde.shape\n    k = min(m, n)\n\n    # 1. Compute the Singular Value Decomposition.\n    # U: EOFs, s: singular values (amplitudes), Vh: transpose of PC directions\n    # Using full_matrices=False is the standard for economy SVD\n    # and sufficient for these checks.\n    try:\n        U, s, Vh = np.linalg.svd(x_tilde, full_matrices=False)\n    except np.linalg.LinAlgError:\n        # SVD might fail in extreme cases, though unlikely with numpy's robust implementation.\n        # If it fails, all checks are considered False.\n        return [False, False, False]\n    \n    # Property (i): Squared amplitudes match eigenvalues of X*X^T\n    # Calculate spatial covariance matrix and its eigenvalues\n    cov_spatial = x_tilde @ x_tilde.T\n    # eigvalsh is preferred for hermitian (or real symmetric) matrices\n    # and returns eigenvalues in ascending order.\n    eigvals = np.linalg.eigvalsh(cov_spatial)\n    # Sort eigenvalues in descending order to match singular value ordering\n    eigvals_sorted_desc = eigvals[::-1]\n    \n    s_squared = s**2\n    # The number of singular values is k=min(m,n).\n    # The number of eigenvalues is m. If m > n, there are m-n zero eigenvalues.\n    # We must compare the k squared singular values with the k largest eigenvalues.\n    # The remaining m-k eigenvalues should be zero. A robust way is to pad s^2 with zeros.\n    s_squared_padded = np.zeros(m)\n    s_squared_padded[:len(s_squared)] = s_squared\n    \n    is_eig_match = np.allclose(s_squared_padded, eigvals_sorted_desc, atol=1e-10, rtol=0)\n\n    # Property (ii): Decomposition reconstructs the data matrix\n    # Reconstruct the matrix using the SVD components\n    # s is a 1D array, so it needs to be formed into a diagonal matrix.\n    s_diag = np.diag(s)\n    x_reconstructed = U @ s_diag @ Vh\n    \n    norm_x = np.linalg.norm(x_tilde, 'fro')\n    norm_error = np.linalg.norm(x_tilde - x_reconstructed, 'fro')\n    \n    if norm_x == 0:\n        is_reconstructed = norm_error = 1e-12\n    else:\n        is_reconstructed = (norm_error / norm_x) = 1e-12\n\n    # Property (iii): Spatial and temporal bases are orthonormal\n    # Check U^T * U = I\n    identity_U = np.identity(U.shape[1])\n    is_U_orthonormal = np.allclose(U.T @ U, identity_U, atol=1e-12, rtol=0)\n    \n    # Check V^T * V = I. Since we have Vh = V^T, this is Vh * Vh^T = I\n    identity_V = np.identity(Vh.shape[0])\n    is_V_orthonormal = np.allclose(Vh @ Vh.T, identity_V, atol=1e-12, rtol=0)\n    \n    is_orthonormal = is_U_orthonormal and is_V_orthonormal\n    \n    return [is_eig_match, is_reconstructed, is_orthonormal]\n\nsolve()\n```"
        },
        {
            "introduction": "在处理真实的海洋学数据集时，空间点数（$N$）往往远大于时间步数（$T$），这使得直接计算一个巨大的 $N \\times N$ 协方差矩阵变得不切实际。快照法（method of snapshots）提供了一种高效的替代方案，它通过求解一个较小的 $T \\times T$ 时间协方差矩阵的特征问题来解决。本练习将引导您实现这一关键算法，使其能够处理大规模数据集，这是计算海洋学家的一项核心技能()。",
            "id": "3791937",
            "problem": "您的任务是在计算海洋学中，实现用于经验正交函数 (EOF) 分析的快照法。其目标是从一个距平数据矩阵中计算空间模态、时间模态及相关方差，而无需构建规模为 $N \\times N$ 的大型协方差矩阵。考虑一个假设的数据集，包含 $N = 10^5$ 个空间点和 $T = 500$ 个时间步。所要实现的方法必须避免构建任何 $N \\times N$ 的矩阵，且必须通过利用大小最多为 $T \\times T$ 的对象来进行。所有计算都涉及通过从每个空间位置减去时间平均值得到的距平值，并且本问题不涉及任何物理单位。\n\n从基本定义出发，将距平矩阵 $X \\in \\mathbb{R}^{N \\times T}$ 视为数据容器，其列为时间样本。经验正交函数 (EOF) 分解是根据 $X$ 的奇异值分解 (SVD) 定义的，该分解将矩阵分解为空间模态、奇异值和时间模态。快照法通过关注 $T \\times T$ 的时间协方差矩阵，避免了对 $N \\times N$ 矩阵的直接计算。该方法的目标输出是时间模态 $V$、协方差特征值的对角矩阵 $\\Lambda$ 和空间模态 $U$，其方式需与对距平矩阵进行 EOF 分析的 SVD 约定保持一致。\n\n您的程序必须实现一个数值稳定的算法，该算法能够：\n- 从每个空间位置减去时间平均值以形成距平。\n- 仅根据距平构建一个 $T \\times T$ 的时间协方差矩阵。\n- 计算时间模态 $V$、收集在对角矩阵 $\\Lambda$ 中的非负特征值，以及空间模态 $U$，而始终不构建任何 $N \\times N$ 矩阵。\n- 使用相对容差处理秩亏情况以及精确为零或数值上可忽略的特征值。\n- 根据计算出的三元组生成距平矩阵的重构，并使用严格的量化标准验证内部一致性。\n\n您的实现将使用以下测试套件进行评分。对于每种情况，请按照指示构建 $X$，然后使用快照法计算三元组 $(V, \\Lambda, U)$，最后计算指定的标量结果。所有随机变量必须使用提供的种子从标准正态分布中抽取。所有算术运算必须使用双精度。\n\n适用于所有情况的定义和约束：\n- 距平矩阵必须通过从 $X$ 的每一行减去时间平均值来形成。\n- 时间协方差矩阵是根据距平构建的 $T \\times T$ 对称矩阵。\n- 特征值必须按降序排序，且 $V$ 的列必须相应排序。\n- 估计的数值秩是严格大于 $\\tau \\cdot \\lambda_{\\max}$ 的特征值的数量，其中 $\\lambda_{\\max}$ 是最大特征值，且 $\\tau = 10^{-10}$。\n- 重构必须仅使用与高于容差的特征值相关的模态进行。\n\n测试套件（五种情况）：\n- 情况 $1$（理想路径，$N  T$）：$N = 120$，$T = 50$，种子 $= 0$。用独立的标准正态分布条目构建 $X$ 并形成距平。使用三元组 $(V, \\Lambda, U)$ 计算距平矩阵的相对 Frobenius 重构误差。所需的标量结果是\n  $$e_1 = \\frac{\\lVert X_{\\mathrm{anom}} - \\widehat{X} \\rVert_F}{\\lVert X_{\\mathrm{anom}} \\rVert_F},$$\n  其中 $\\widehat{X}$ 是从保留的模态重构的。\n- 情况 $2$（$T  N$）：$N = 40$，$T = 80$，种子 $= 1$。用独立的标准正态分布条目构建 $X$ 并形成距平。计算距平矩阵的完整矩阵 SVD 奇异值，并将其与快照法所蕴含的奇异值进行比较。所需的标量结果是两个奇异值向量（两者都截断至保留的模态）之间的相对 $\\ell_2$ 误差，\n  $$e_2 = \\frac{\\lVert s_{\\mathrm{snap}} - s_{\\mathrm{svd}} \\rVert_2}{\\lVert s_{\\mathrm{svd}} \\rVert_2}.$$\n- 情况 $3$（秩亏）：$N = 90$，$T = 70$，秩参数 $r = 15$，种子 $= 2$。使用给定种子构建具有独立标准正态条目的 $A \\in \\mathbb{R}^{N \\times r}$ 和 $B \\in \\mathbb{R}^{r \\times T}$，然后通过将 $B$ 替换为 $B - \\mathrm{mean}(B, \\text{axis}=1)$ 来强制使其时间平均值为零。设置 $X = A B$。形成距平（根据构造，距平应为零）。计算估计的数值秩并返回整数差\n  $$d_3 = \\left| \\mathrm{rank}_{\\mathrm{est}} - \\min(r, T - 1) \\right|.$$\n- 情况 $4$（正交性检查）：$N = 60$，$T = 60$，种子 $= 3$。用独立的标准正态分布条目构建 $X$ 并形成距平。计算由容差规则保留的 $U$ 的列偏离正交性的 Frobenius 范数：\n  $$e_4 = \\lVert U^\\top U - I \\rVert_F,$$\n  其中 $I$ 是相容大小的单位矩阵。\n- 情况 $5$（小 $T$ 边缘情况）：$N = 50$，$T = 5$，种子 $= 4$。用独立的标准正态分布条目构建 $X$ 并形成距平。使用保留的模态计算相对 Frobenius 重构误差：\n  $$e_5 = \\frac{\\lVert X_{\\mathrm{anom}} - \\widehat{X} \\rVert_F}{\\lVert X_{\\mathrm{anom}} \\rVert_F}.$$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按顺序 $[e_1, e_2, d_3, e_4, e_5]$ 排列、用逗号分隔并用方括号括起来的结果。例如，一个语法正确的输出示例是\n\"[0.0,0.0,0,0.0,0.0]\"。",
            "solution": "用户提供的问题经评估有效。这是一个适定的、有科学依据且客观的计算任务，其根植于线性代数原理及其在计算海洋学中的应用。该问题要求实现用于经验正交函数 (EOF) 分析的“快照法”，这是一种当空间点数 ($N$) 远大于时间快照数 ($T$) 时用于降维的标准高效算法。\n\n解决方案首先详细阐述该方法的理论基础，然后概述算法的设计及其在具体测试用例中的应用。\n\n### 基于原理的设计\n\n**1. 理论基础：EOF 分析与奇异值分解 (SVD)**\n\nEOF 分析旨在将一个时空数据集（表示为距平矩阵 $X_{\\mathrm{anom}} \\in \\mathbb{R}^{N \\times T}$）分解为一组正交的空间模态 (EOF) 和相应的时间模态 (主成分)。在数学上，这等价于对距平矩阵进行奇异值分解 (SVD)：\n$$\nX_{\\mathrm{anom}} = U S V^\\top\n$$\n其中：\n- $X_{\\mathrm{anom}}$ 是维度为 $N$ (空间) $\\times$ $T$ (时间) 的数据矩阵，其每一行都减去了时间平均值。\n- $U \\in \\mathbb{R}^{N \\times k}$ 是一个矩阵，其列是标准正交的空间模态 (EOF)。\n- $S \\in \\mathbb{R}^{k \\times k}$ 是一个对角矩阵，包含奇异值 $\\sigma_i  0$，这些值代表了每个模态的重要性。\n- $V \\in \\mathbb{R}^{T \\times k}$ 是一个矩阵，其列是标准正交的时间模态。\n- $k = \\mathrm{rank}(X_{\\mathrm{anom}})$ 是非零模态的数量。\n\n当 $N$ 非常大时（例如，如建议的 $N=10^5$），直接计算 SVD，或等效地对 $N \\times N$ 的空间协方差矩阵 $C_N = X_{\\mathrm{anom}} X_{\\mathrm{anom}}^\\top$ 进行特征分解，在计算上会变得不可行。\n\n**2. 快照法**\n\n快照法通过对小得多的 $T \\times T$ 时间散布矩阵（也称为时间协方差矩阵，两者相差一个缩放因子）进行操作来规避此问题：\n$$\nC_T = X_{\\mathrm{anom}}^\\top X_{\\mathrm{anom}}\n$$\n其核心思想是将 $C_T$ 的特征分解与 $X_{\\mathrm{anom}}$ 的 SVD 联系起来。将 $X_{\\mathrm{anom}} = U S V^\\top$ 代入 $C_T$ 的定义，我们发现：\n$$\nC_T = (U S V^\\top)^\\top (U S V^\\top) = V S^\\top U^\\top U S V^\\top = V (S^2) V^\\top\n$$\n由于 $U^\\top U = I$ 且 $V^\\top V = I$，上式最后一个表达式即为 $C_T$ 的特征分解。将其与特征分解的标准形式 $C_T V = V \\Lambda$ 进行比较，可以得出两个关键关系：\n\n- $C_T$ 的特征向量（$V$ 的列）是 $X_{\\mathrm{anom}}$ 的时间模态。\n- $C_T$ 的特征值（$\\Lambda$ 的对角元素）是 $X_{\\mathrm{anom}}$ 奇异值的平方，即 $\\lambda_i = \\sigma_i^2$。\n\n在已知 $V$ 和 $S$（从 $\\Lambda$ 导出）的情况下，空间模态 $U$ 可以从 SVD 方程中恢复，而无需构建任何 $N \\times N$ 矩阵：\n$$\nX_{\\mathrm{anom}} V = U S \\implies U = X_{\\mathrm{anom}} V S^{-1}\n$$\n对于每个模态 $i$，这对应于：\n$$\n\\mathbf{u}_i = \\frac{1}{\\sigma_i} X_{\\mathrm{anom}} \\mathbf{v}_i\n$$\n此公式表明，空间模态 $U$ 是数据快照（$X_{\\mathrm{anom}}$ 的列）的线性组合，其权重系数由 $V S^{-1}$ 的元素给出。以此方式计算出的列 $\\mathbf{u}_i$ 保证是标准正交的。\n\n**3. 算法实现**\n\n该算法实现为一个函数，该函数接受原始数据矩阵 $X$ 和一个容差 $\\tau$ 作为输入。\n\n- **步骤 1：距平计算**：从 $X$ 的每一行减去时间平均值，以形成距平矩阵 $X_{\\mathrm{anom}}$。对于一个矩阵 $X \\in \\mathbb{R}^{N \\times T}$，其时间平均值是一个向量 $\\boldsymbol{\\mu} \\in \\mathbb{R}^{N \\times 1}$，其中 $\\mu_i = \\frac{1}{T}\\sum_{j=1}^T X_{ij}$。然后，$(X_{\\mathrm{anom}})_{ij} = X_{ij} - \\mu_i$。\n- **步骤 2：时间矩阵的特征分解**：构建 $T \\times T$ 矩阵 $C_T = X_{\\mathrm{anom}}^\\top X_{\\mathrm{anom}}$。由于 $C_T$ 是对称半正定的，它的特征值 $\\lambda_i$ 和特征向量 $\\mathbf{v}_i$ 使用专门的求解器（如 `scipy.linalg.eigh`）进行计算。特征值按降序排序，相应的特征向量也重新排序以形成 $V$ 的列。\n- **步骤 3：数值秩截断**：由于浮点数限制，需要确定一个数值秩 $k$。如果特征值严格大于相对于最大特征值的阈值，即 $\\lambda_i  \\tau \\cdot \\lambda_{\\max}$（其中 $\\tau = 10^{-10}$），则认为它们是显著的。所有结果（$V$、$\\Lambda$、$U$）都被截断到这个秩 $k$。\n- **步骤 4：计算空间模态和奇异值**：使用前 $k$ 个显著特征值计算相应的奇异值，$\\sigma_i = \\sqrt{\\lambda_i}$。然后使用公式 $U_k = X_{\\mathrm{anom}} V_k S_k^{-1}$ 计算截断后的空间模态 $U_k$，这可以通过一次矩阵-矩阵乘积后接列向缩放来高效实现。\n- **步骤 5：测试用例执行**：对于问题中定义的每个测试用例，按规定构建数据矩阵 $X$。使用已实现的快照法计算 EOF 三元组。然后计算所需的标量结果。对于基于重构的测试（情况 1 和 5），距平矩阵被重构为 $\\widehat{X} = U_k S_k V_k^\\top$。对于正交性检查（情况 4），将乘积 $U_k^\\top U_k$ 与单位矩阵进行比较。对于秩检查（情况 3），将计算出的秩 $k$ 与理论秩进行比较。对于 SVD 比较（情况 2），将从快照法获得的奇异值（$\\sqrt{\\lambda_i}$）与直接调用 SVD 得到的值进行比较。所有计算都使用双精度浮点算术。",
            "answer": "```python\nimport numpy as np\nimport scipy.linalg\n\ndef compute_eofs_snapshots(X, tau):\n    \"\"\"\n    Computes EOFs using the method of snapshots.\n    \n    Args:\n        X (np.ndarray): Data matrix of shape (N, T), where N is space and T is time.\n        tau (float): Relative tolerance for rank determination.\n\n    Returns:\n        tuple: A tuple containing:\n            - U (np.ndarray): Spatial patterns (EOFs), shape (N, k).\n            - lambda_trunc (np.ndarray): Truncated eigenvalues, shape (k,).\n            - V_trunc (np.ndarray): Temporal patterns (PCs), shape (T, k).\n            - s_trunc (np.ndarray): Truncated singular values, shape (k,).\n            - k (int): Estimated numerical rank.\n    \"\"\"\n    N, T = X.shape\n\n    # Step 1: Form the anomaly matrix by subtracting the temporal mean.\n    mean = X.mean(axis=1, keepdims=True)\n    X_anom = X - mean\n\n    # Step 2: Form the temporal scatter matrix.\n    C_T = X_anom.T @ X_anom\n\n    # Step 3: Eigendecomposition of the symmetric matrix C_T.\n    # eigh returns eigenvalues in ascending order.\n    eigvals, V = scipy.linalg.eigh(C_T)\n\n    # Sort eigenvalues and eigenvectors in descending order.\n    idx = np.argsort(eigvals)[::-1]\n    eigvals = eigvals[idx]\n    V = V[:, idx]\n\n    # Clean up potential small negative eigenvalues from numerical error.\n    eigvals[eigvals  0] = 0\n\n    # Step 4: Determine numerical rank based on the tolerance.\n    # The rank is the number of eigenvalues greater than tau * max_eigenvalue.\n    max_eigval = eigvals[0] if len(eigvals) > 0 else 0.0\n    if max_eigval > 0:\n        k = np.sum(eigvals > tau * max_eigval)\n    else:\n        k = 0\n\n    # If the effective rank is 0, the anomaly matrix was all zeros.\n    if k == 0:\n        return np.zeros((N, 0)), np.array([]), np.zeros((T, 0)), np.array([]), 0\n\n    # Truncate to the estimated rank k.\n    lambda_trunc = eigvals[:k]\n    V_trunc = V[:, :k]\n\n    # Step 5: Compute singular values and spatial patterns U.\n    s_trunc = np.sqrt(lambda_trunc)\n    \n    # U = X_anom @ V_trunc @ inv(diag(s_trunc))\n    # This is numerically better and more efficient:\n    U = (X_anom @ V_trunc) / s_trunc\n    \n    return U, lambda_trunc, V_trunc, s_trunc, k\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {'case': 1, 'N': 120, 'T': 50, 'seed': 0, 'tau': 1e-10},\n        {'case': 2, 'N': 40, 'T': 80, 'seed': 1, 'tau': 1e-10},\n        {'case': 3, 'N': 90, 'T': 70, 'r': 15, 'seed': 2, 'tau': 1e-10},\n        {'case': 4, 'N': 60, 'T': 60, 'seed': 3, 'tau': 1e-10},\n        {'case': 5, 'N': 50, 'T': 5, 'seed': 4, 'tau': 1e-10},\n    ]\n    \n    results = []\n\n    for params in test_cases:\n        case_id = params['case']\n        np.random.seed(params['seed'])\n        \n        if case_id == 1:\n            N, T, tau = params['N'], params['T'], params['tau']\n            X = np.random.standard_normal(size=(N, T))\n            X_anom = X - X.mean(axis=1, keepdims=True)\n            \n            U, _, V, S, _ = compute_eofs_snapshots(X, tau)\n            \n            X_hat = U @ np.diag(S) @ V.T\n            \n            norm_X_anom = np.linalg.norm(X_anom, 'fro')\n            error = np.linalg.norm(X_anom - X_hat, 'fro') / norm_X_anom if norm_X_anom > 0 else 0.0\n            results.append(error)\n\n        elif case_id == 2:\n            N, T, tau = params['N'], params['T'], params['tau']\n            X = np.random.standard_normal(size=(N, T))\n            X_anom = X - X.mean(axis=1, keepdims=True)\n            \n            _, _, _, s_snap, k = compute_eofs_snapshots(X, tau)\n            \n            _, s_svd, _ = scipy.linalg.svd(X_anom, full_matrices=False)\n            \n            s_svd_trunc = s_svd[:k]\n            \n            norm_s_svd = np.linalg.norm(s_svd_trunc)\n            error = np.linalg.norm(s_snap - s_svd_trunc) / norm_s_svd if norm_s_svd > 0 else 0.0\n            results.append(error)\n\n        elif case_id == 3:\n            N, T, r, tau = params['N'], params['T'], params['r'], params['tau']\n            A = np.random.standard_normal(size=(N, r))\n            B = np.random.standard_normal(size=(r, T))\n            # Construct X to have zero temporal mean\n            B_centered = B - B.mean(axis=1, keepdims=True)\n            X = A @ B_centered\n            \n            _, _, _, _, rank_est = compute_eofs_snapshots(X, tau)\n            \n            # Theoretical rank is min(r, T-1) since rank(X_anom=X) = min(rank(A@B_centered), T-1)\n            # and rank(A@B_centered) = min(rank(A), rank(B_centered)) = r\n            theoretical_rank = min(r, T - 1)\n            diff = abs(rank_est - theoretical_rank)\n            results.append(diff)\n            \n        elif case_id == 4:\n            N, T, tau = params['N'], params['T'], params['tau']\n            X = np.random.standard_normal(size=(N, T))\n            \n            U, _, _, _, k = compute_eofs_snapshots(X, tau)\n            \n            if k == 0:\n                error = 0.0\n            else:\n                I_k = np.identity(k)\n                error = np.linalg.norm(U.T @ U - I_k, 'fro')\n            results.append(error)\n\n        elif case_id == 5:\n            N, T, tau = params['N'], params['T'], params['tau']\n            X = np.random.standard_normal(size=(N, T))\n            X_anom = X - X.mean(axis=1, keepdims=True)\n\n            U, _, V, S, k = compute_eofs_snapshots(X, tau)\n            \n            if k == 0:\n                X_hat = np.zeros_like(X_anom)\n            else:\n                X_hat = U @ np.diag(S) @ V.T\n            \n            norm_X_anom = np.linalg.norm(X_anom, 'fro')\n            error = np.linalg.norm(X_anom - X_hat, 'fro') / norm_X_anom if norm_X_anom > 0 else 0.0\n            results.append(error)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}