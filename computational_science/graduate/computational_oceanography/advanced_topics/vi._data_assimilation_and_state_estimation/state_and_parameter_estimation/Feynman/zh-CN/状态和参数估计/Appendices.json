{
    "hands_on_practices": [
        {
            "introduction": "掌握状态和参数估计需要从理论走向实践。本章的第一项实践探讨了估计问题中最基本的一个挑战：参数的可识别性。在投入大量计算资源进行参数估计之前，我们必须首先确定，可用的观测数据是否包含足够的信息来唯一地确定我们感兴趣的参数。本练习使用一个简化的稳态海洋模型，来解析地展示风应力和海底拖曳之间的参数混淆问题。通过完成这个例子 ，你将学会如何使用模型的雅可比矩阵来诊断不可识别性，并批判性地思考如何通过改进实验设计来解决这一问题。",
            "id": "3811287",
            "problem": "考虑一个长度为 $L$、具有周期性边界条件、均匀深度为 $H$、恒定参考密度为 $\\rho_{0}$ 的矩形渠道中的深度平均、正压、一维沿渠道水流。对于空间均匀模态，沿渠道动量方程由正压梯度力、风应力和线性底拖曳之间的基本平衡所控制，\n$$\n\\rho_{0} H \\frac{dU}{dt} \\;=\\; - \\rho_{0} g H \\frac{\\partial \\eta}{\\partial x} \\;+\\; \\tau_{x} \\;-\\; \\rho_{0} H r U,\n$$\n其中 $U$ 是深度平均的沿渠道流速，$g$ 是重力加速度，$\\eta$ 是自由面高程，$\\tau_{x}$ 是空间均匀的风应力（在稳态分析中假设其不随时间变化），$r$ 是线性底拖曳系数。假设水流达到一个稳定且空间均匀的状态，并且对于周期性边界条件下的均匀模态，可以认为平均正压梯度力对于此特定模态是可忽略的（即，解的空间均匀分支对于稳态均匀模态而言，其平均 $\\partial \\eta/\\partial x$ 实际上为零）。\n\n您正在仅使用某个时刻对 $U$ 的单个稳态观测值进行状态和参数估计。将参数矢量表示为 $\\boldsymbol{\\theta} = (\\tau_{x}, r)$，观测算子表示为在上述假设下于稳态时求值的 $h(\\boldsymbol{\\theta}) = U(\\tau_{x}, r)$。将 $U$ 视为数据同化系统观测到的标量状态变量。\n\n任务：\n- 从动量方程和所述假设出发，推导连接均匀模态下 $U$、$\\tau_{x}$ 和 $r$ 的稳态关系。利用此关系证明存在一个一维参数对族 $(\\tau_{x}, r)$，它们能产生相同的稳态 $U$，从而证明当仅观测 $U$ 时，风应力振幅和底拖曳之间存在混淆（不可辨识性）。\n- 形式上计算 $h(\\boldsymbol{\\theta})$ 关于 $\\boldsymbol{\\theta}$ 的敏感度（雅可比矩阵），并确定参数空间中的一维零空间方向，即在一阶上导致 $U$ 变化为零的非零参数增量方向 $\\delta \\boldsymbol{\\theta}$。报告这个归一化为单位欧几里得范数的方向。\n- 提出一种能够打破这种简并性的额外观测类型或实验设计，并在物理上合理的海洋学条件下，从数学上证明它引入了何种额外的参数依赖性，从而实现了 $\\tau_{x}$ 和 $r$ 的局部可辨识性（即，关于 $\\boldsymbol{\\theta}$ 的敏感度矩阵为满秩）。\n\n答案规范：\n- 最终答案必须是给出参数空间中单位范数零空间方向矢量的单一闭合形式解析表达式（以行矢量形式表示）。最终答案中不要包含任何单位。无需进行四舍五入。",
            "solution": "首先根据指定标准对问题进行验证。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n- **控制方程**：$\\rho_{0} H \\frac{dU}{dt} \\;=\\; - \\rho_{0} g H \\frac{\\partial \\eta}{\\partial x} \\;+\\; \\tau_{x} \\;-\\; \\rho_{0} H r U$\n- **系统**：深度平均、正压、一维沿渠道水流。\n- **几何与边界**：长度为 $L$ 的矩形渠道，均匀深度 $H$，周期性边界条件。\n- **变量**：$U$ (深度平均的沿渠道流速)，$\\eta$ (自由面高程)。\n- **参数**：$\\tau_{x}$ (空间均匀、恒定的风应力)，$r$ (线性底拖曳系数)。参数矢量为 $\\boldsymbol{\\theta} = (\\tau_{x}, r)$。\n- **常数**：$\\rho_{0}$ (恒定参考密度)，$g$ (重力加速度)。\n- **假设**：\n    1. 水流达到稳态。\n    2. 水流是空间均匀的（考虑空间均匀模态）。\n    3. 对于均匀模态，平均正压梯度力可以忽略不计，即 $\\frac{\\partial \\eta}{\\partial x}$ 实际上为零。\n- **观测方案**：单个稳态 $U$ 的观测。\n- **观测算子**：在稳态时求值的 $h(\\boldsymbol{\\theta}) = U(\\tau_{x}, r)$。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据**：该问题基于浅水动量方程的简化形式，这是地球物理流体动力学的基石。力的平衡（风应力与底拖曳）是模拟风生环流的基本概念。该模型是海洋学中一个常用且有效的理想化模型。\n- **适定性**：该问题是适定的。它提供了一个清晰的控制方程和一组简化假设，由此可以推导出唯一的稳态关系。推导此关系、分析参数敏感度以及提出解决不可辨识性问题的方法等任务，是反演模拟和数据同化中的标准程序。\n- **客观性**：该问题以精确、客观和标准的科学语言陈述。所有术语都在物理海洋学的背景下有明确定义。\n\n**步骤3：结论与行动**\n该问题在科学上合理、适定且客观。这是一个有效的问题，可以按陈述求解。\n\n### 解答\n\n**第1部分：稳态关系与混淆**\n\n我们从所提供的一维沿渠道动量方程开始：\n$$\n\\rho_{0} H \\frac{dU}{dt} \\;=\\; - \\rho_{0} g H \\frac{\\partial \\eta}{\\partial x} \\;+\\; \\tau_{x} \\;-\\; \\rho_{0} H r U\n$$\n为了找到稳态关系，我们应用指定的假设。\n首先，我们假设水流达到稳态，这意味着所有时间导数均为零。因此，$\\frac{dU}{dt} = 0$。\n其次，对于周期性边界条件下的空间均匀模态，假设平均正压梯度项可以忽略不计，因此 $\\frac{\\partial \\eta}{\\partial x} = 0$。\n\n将这些条件代入动量方程，我们得到：\n$$\n\\rho_{0} H (0) \\;=\\; - \\rho_{0} g H (0) \\;+\\; \\tau_{x} \\;-\\; \\rho_{0} H r U\n$$\n这简化为风应力强迫和底拖曳之间的平衡：\n$$\n0 \\;=\\; \\tau_{x} \\;-\\; \\rho_{0} H r U\n$$\n求解稳态流速 $U$ 得到观测算子 $h(\\boldsymbol{\\theta})$ 的显式形式：\n$$\nU(\\tau_{x}, r) = \\frac{\\tau_{x}}{\\rho_{0} H r}\n$$\n该关系表明，稳态流速 $U$ 不是由 $\\tau_{x}$ 或 $r$ 单独决定的，而是由它们的比值 $\\frac{\\tau_{x}}{r}$ 决定的。如果观测到一个特定的稳态流速 $U_{obs}$，任何满足方程\n$$\nU_{obs} = \\frac{\\tau_{x}}{\\rho_{0} H r} \\quad \\implies \\quad \\tau_{x} = (\\rho_{0} H U_{obs}) r\n$$\n的参数对 $(\\tau_{x}, r)$ 都是一个有效解。由于 $\\rho_{0}$、 $H$ 和 $U_{obs}$ 是常数，这个方程描述了在 $(\\tau_{x}, r)$ 参数空间中一条通过原点的直线。这构成了一个一维解族，意味着从单个稳态 $U$ 的观测值中，我们无法唯一确定 $\\tau_{x}$ 和 $r$ 这两个参数。这是一个典型的参数混淆（或不可辨识性）案例。\n\n**第2部分：敏感度（雅可比矩阵）和零空间方向**\n\n观测值 $U$ 对参数 $\\boldsymbol{\\theta} = (\\tau_x, r)$ 的敏感度由观测算子 $h(\\boldsymbol{\\theta}) = U(\\tau_{x}, r)$ 的雅可比矩阵给出。在这种情况下，雅可比矩阵是一个行矢量：\n$$\n\\mathbf{J} = \\nabla_{\\boldsymbol{\\theta}} h = \\begin{pmatrix} \\frac{\\partial U}{\\partial \\tau_{x}} & \\frac{\\partial U}{\\partial r} \\end{pmatrix}\n$$\n我们计算 $U(\\tau_{x}, r) = \\frac{\\tau_{x}}{\\rho_{0} H r}$ 的偏导数：\n$$\n\\frac{\\partial U}{\\partial \\tau_{x}} = \\frac{\\partial}{\\partial \\tau_{x}} \\left( \\frac{\\tau_{x}}{\\rho_{0} H r} \\right) = \\frac{1}{\\rho_{0} H r}\n$$\n$$\n\\frac{\\partial U}{\\partial r} = \\frac{\\partial}{\\partial r} \\left( \\frac{\\tau_{x}}{\\rho_{0} H} r^{-1} \\right) = \\frac{\\tau_{x}}{\\rho_{0} H} (-1) r^{-2} = -\\frac{\\tau_{x}}{\\rho_{0} H r^{2}}\n$$\n因此，雅可比矩阵为：\n$$\n\\mathbf{J} = \\begin{pmatrix} \\frac{1}{\\rho_{0} H r} & -\\frac{\\tau_{x}}{\\rho_{0} H r^{2}} \\end{pmatrix}\n$$\n如果一个参数增量方向 $\\delta\\boldsymbol{\\theta} = (\\delta\\tau_x, \\delta r)$ 的应用在一阶上导致观测值变化为零，则该方向位于雅可比矩阵的零空间中。在数学上，这表示为 $\\mathbf{J} \\cdot \\delta\\boldsymbol{\\theta}^{T} = 0$：\n$$\n\\begin{pmatrix} \\frac{1}{\\rho_{0} H r} & -\\frac{\\tau_{x}}{\\rho_{0} H r^{2}} \\end{pmatrix} \\begin{pmatrix} \\delta\\tau_x \\\\ \\delta r \\end{pmatrix} = 0\n$$\n$$\n\\frac{1}{\\rho_{0} H r} \\delta\\tau_x - \\frac{\\tau_{x}}{\\rho_{0} H r^{2}} \\delta r = 0\n$$\n将整个方程乘以 $\\rho_{0} H r^{2}$（假设 $r \\neq 0$）可以简化该关系：\n$$\nr \\, \\delta\\tau_x - \\tau_{x} \\, \\delta r = 0 \\quad \\implies \\quad r \\, \\delta\\tau_x = \\tau_{x} \\, \\delta r\n$$\n一个满足此关系的简单非零矢量是 $\\delta\\boldsymbol{\\theta} = (\\tau_{x}, r)$，因为 $r(\\tau_{x}) - \\tau_{x}(r) = 0$。这个矢量，我们称之为 $\\mathbf{v} = (\\tau_{x}, r)$，张成了一维零空间。\n\n为了找到单位范数的零空间方向，我们用其欧几里得范数 $\\|\\mathbf{v}\\| = \\sqrt{\\tau_{x}^{2} + r^{2}}$ 对这个矢量进行归一化。归一化后的方向 $\\hat{\\mathbf{v}}$ 是：\n$$\n\\hat{\\mathbf{v}} = \\frac{\\mathbf{v}}{\\|\\mathbf{v}\\|} = \\left( \\frac{\\tau_{x}}{\\sqrt{\\tau_{x}^{2} + r^{2}}}, \\frac{r}{\\sqrt{\\tau_{x}^{2} + r^{2}}} \\right)\n$$\n这就是所求的单位范数零空间方向矢量。\n\n**第3部分：打破简并性**\n\n为了打破简并性并实现对 $\\tau_{x}$ 和 $r$ 的唯一辨识，我们需要一个以不同方式依赖于这些参数的额外的、独立的观测。当前问题之所以出现，是因为我们只观测了稳态。观测系统的瞬态（随时间变化的）演变可以提供必要的独立信息。\n\n我们来提议一个实验，观测渠道从静止状态（即 $U(t=0)=0$）开始的加速过程。均匀模态的控制方程是一个一阶常微分方程：\n$$\n\\rho_{0} H \\frac{dU}{dt} = \\tau_{x} - \\rho_{0} H r U \\quad \\implies \\quad \\frac{dU}{dt} + rU = \\frac{\\tau_{x}}{\\rho_{0} H}\n$$\n这个常微分方程在初始条件 $U(0)=0$ 下的解是：\n$$\nU(t) = \\frac{\\tau_{x}}{\\rho_{0} H r} \\left( 1 - \\exp(-rt) \\right)\n$$\n该解表明，系统以 e折时间尺度 $T_{efold} = \\frac{1}{r}$ 向其稳态演变。这个时间尺度仅依赖于 $r$，而不依赖于 $\\tau_{x}$。\n\n一个可以打破简并性的实验设计是，在测量稳态流速 $U_{ss} = \\lim_{t\\to\\infty} U(t)$ 的同时，在瞬态阶段的某个时间 $t>0$ 测量流速 $U(t)$。例如，我们可以构建一个增广观测矢量 $\\mathbf{y}$，它包含两条独立的信息：稳态流速 $U_{ss}$ 和调整时间尺度 $T_{efold}$。\n\n新的观测算子 $\\mathbf{h}(\\boldsymbol{\\theta})$ 将是：\n$$\n\\mathbf{h}(\\boldsymbol{\\theta}) = \\begin{pmatrix} h_{1}(\\tau_x, r) \\\\ h_{2}(\\tau_x, r) \\end{pmatrix} = \\begin{pmatrix} U_{ss} \\\\ T_{efold} \\end{pmatrix} = \\begin{pmatrix} \\frac{\\tau_{x}}{\\rho_{0} H r} \\\\ \\frac{1}{r} \\end{pmatrix}\n$$\n新的敏感度矩阵（雅可比矩阵）是一个 $2 \\times 2$ 矩阵：\n$$\n\\mathbf{J}_{\\text{new}} = \\begin{pmatrix} \\frac{\\partial h_{1}}{\\partial \\tau_{x}} & \\frac{\\partial h_{1}}{\\partial r} \\\\ \\frac{\\partial h_{2}}{\\partial \\tau_{x}} & \\frac{\\partial h_{2}}{\\partial r} \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{\\rho_{0} H r} & -\\frac{\\tau_{x}}{\\rho_{0} H r^{2}} \\\\ 0 & -\\frac{1}{r^{2}} \\end{pmatrix}\n$$\n为了使参数局部可辨识，这个雅可比矩阵必须是满秩的（即秩为2），这可以通过检查其行列式是否非零来验证。\n$$\n\\det(\\mathbf{J}_{\\text{new}}) = \\left( \\frac{1}{\\rho_{0} H r} \\right) \\left( -\\frac{1}{r^{2}} \\right) - \\left( -\\frac{\\tau_{x}}{\\rho_{0} H r^{2}} \\right) (0) = -\\frac{1}{\\rho_{0} H r^{3}}\n$$\n在物理上合理的海洋学条件下，$\\rho_{0} > 0$，$H > 0$，并且拖曳系数 $r > 0$。因此，$\\det(\\mathbf{J}_{\\text{new}})$ 非零。非零的行列式意味着该矩阵是可逆的并且是满秩的。这证明了通过增加一个与瞬态动力学相关的观测（例如调整时间尺度），参数 $\\tau_{x}$ 和 $r$ 变得局部可辨识。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{\\tau_x}{\\sqrt{\\tau_x^2 + r^2}} & \\frac{r}{\\sqrt{\\tau_x^2 + r^2}}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在确认参数原则上可识别后，下一个关键步骤是建立一个能够实际执行估计的数值引擎。变分资料同化（如 4D-Var）是一个强大的框架，它通过最小化一个代价函数来寻找最优解。此过程中最关键且最容易出错的部分，是使用伴随模型计算代价函数的梯度。本实践将指导你为一个同时估计海洋状态和模型参数的 4D-Var 系统实现一个梯度检验，通过将伴随模型的计算结果与有限差分近似进行比较，来验证其正确性 。这是开发和调试任何变分资料同化系统的一项基本技能。",
            "id": "3811253",
            "problem": "考虑一个简化的二维线性模型，用于描述受线性阻尼和科里奥利力影响的水平洋流。设状态为 $x_k \\in \\mathbb{R}^2$，其分量 $x_k = [u_k, v_k]^\\top$ 分别表示在离散时间点 $k \\in \\{0,1,\\dots,K\\}$ 的纬向速度和经向速度。其离散时间动力学通过对一个线性系统进行前向欧拉离散得到，时间步长为 $\\Delta t$，参数为 $\\theta = [\\alpha, f]^\\top$，其中 $\\alpha$ 是线性阻尼率，$f$ 是科里奥利参数。动力学方程为\n$$\nx_{k+1} = M(\\theta)\\, x_k, \\quad M(\\theta) = I + \\Delta t\\, F(\\theta), \\quad F(\\theta) = \\begin{bmatrix} -\\alpha & f \\\\ -f & -\\alpha \\end{bmatrix},\n$$\n对于所有 $k \\in \\{0,1,\\dots,K-1\\}$，其中 $I$ 是2阶单位矩阵。\n\n观测是在每个时间点 $k$ 对纬向速度 $u_k$ 的标量测量，测量算子为 $H = [1,0]$。设 $y_k \\in \\mathbb{R}$ 表示在时间 $k$ 的观测值。考虑如下定义的四维变分 (4D-Var) 数据同化代价函数\n$$\nJ(x_0,\\theta) = \\tfrac{1}{2}(x_0 - x_b)^\\top B^{-1} (x_0 - x_b) + \\tfrac{1}{2}\\sum_{k=0}^K \\left(H x_k - y_k\\right)^\\top R^{-1} \\left(H x_k - y_k\\right) + \\tfrac{1}{2}(\\theta - \\theta_b)^\\top P^{-1} (\\theta - \\theta_b),\n$$\n其中 $x_b \\in \\mathbb{R}^2$ 和 $\\theta_b \\in \\mathbb{R}^2$ 是先验均值，$B \\in \\mathbb{R}^{2\\times 2}$ 和 $P \\in \\mathbb{R}^{2\\times 2}$ 是先验协方差，$R \\in \\mathbb{R}$ 是观测误差方差（因此 $R^{-1}$ 是一个标量）。状态轨迹 $\\{x_k\\}_{k=0}^K$ 受上述动力学方程的约束。\n\n您的任务是构建并实现一个梯度检验，该检验将比较 $J$ 的有限差分方向导数与伴随推导的方向导数。梯度检验必须使用中心有限差分近似，其方向为 $(p_{x_0}, p_{\\theta})$，步长为 $h>0$，\n$$\nD_{\\mathrm{FD}} J(x_0,\\theta; p_{x_0}, p_{\\theta}, h) = \\frac{J(x_0 + h\\, p_{x_0},\\ \\theta + h\\, p_{\\theta}) - J(x_0 - h\\, p_{x_0},\\ \\theta - h\\, p_{\\theta})}{2h},\n$$\n并且必须将其与伴随推导的方向导数进行比较\n$$\nD_{\\mathrm{ADJ}} J(x_0,\\theta; p_{x_0}, p_{\\theta}) = \\nabla_{x_0} J(x_0,\\theta)^\\top p_{x_0} + \\nabla_{\\theta} J(x_0,\\theta)^\\top p_{\\theta},\n$$\n其中 $\\nabla_{x_0} J$ 和 $\\nabla_{\\theta} J$ 分别是 $J$ 关于 $x_0$ 和 $\\theta$ 的梯度，通过线性模型的离散伴随和链式法则获得。您必须计算相对误差\n$$\n\\mathrm{relerr}(h, p_{x_0}, p_{\\theta}) = \\frac{\\left| D_{\\mathrm{FD}} J(x_0,\\theta; p_{x_0}, p_{\\theta}, h) - D_{\\mathrm{ADJ}} J(x_0,\\theta; p_{x_0}, p_{\\theta}) \\right|}{\\max\\left(1,\\ \\left| D_{\\mathrm{FD}} J(x_0,\\theta; p_{x_0}, p_{\\theta}, h) \\right|\\right)},\n$$\n并在 $\\mathrm{relerr} \\leq \\tau$ 时宣布测试通过，其中 $\\tau$ 为预设的容差。容差 $\\tau$ 将在下面精确指定，并统一用于所有测试。\n\n您必须实现一个完整的、可运行的程序，对以下科学上一致的测试套件执行梯度检验。以下所有数学量都必须用使其方程量纲一致的单位来解释；然而，最终所需的输出是无量纲的布尔值，因此不需要单位。\n\n模型设置和数据生成：\n- 时间步长参数：$K = 10$，$\\Delta t = 900\\ \\mathrm{s}$。\n- 用于生成观测的真实参数：$\\alpha^\\star = 2\\times 10^{-6}\\ \\mathrm{s}^{-1}$，$f^\\star = 1\\times 10^{-4}\\ \\mathrm{s}^{-1}$。\n- 用于生成观测的真实初始状态：$x_0^\\star = [0.1,\\ 0.05]^\\top$。\n- 观测：$y_k = H x_k^\\star$，其中 $\\{x_k^\\star\\}$ 是通过使用 $(x_0^\\star,\\ \\theta^\\star)$ 积分动力学方程得到的轨迹。\n- 先验均值：$x_b = [0,\\ 0]^\\top$，$\\theta_b = [1\\times 10^{-6},\\ 0.8\\times 10^{-4}]^\\top$。\n- 先验协方差和观测误差方差：\n  - $B = \\mathrm{diag}([\\sigma_{b,u}^2,\\ \\sigma_{b,v}^2])$，其中 $\\sigma_{b,u} = 0.2$，$\\sigma_{b,v} = 0.2$。\n  - $R = \\sigma_R^2$，其中 $\\sigma_R = 0.01$。\n  - $P = \\mathrm{diag}([\\sigma_{\\alpha}^2,\\ \\sigma_{f}^2])$，其中 $\\sigma_{\\alpha} = 1\\times 10^{-6}$，$\\sigma_{f} = 0.2\\times 10^{-4}$。\n- 梯度检验的评估点（非真实值）：$x_0 = [0.05,\\ 0.01]^\\top$，$\\theta = [1.5\\times 10^{-6},\\ 0.9\\times 10^{-4}]^\\top$。\n\n所需梯度构建：\n- 推导并实现离散伴随，以在评估点 $(x_0,\\ \\theta)$ 获得 $\\nabla_{x_0} J$ 和 $\\nabla_{\\theta} J$。\n\n方向导数比较和容差：\n- 使用上面定义的中心有限差分近似，并与伴随推导的方向导数进行比较。\n- 对每个测试用例使用统一的容差 $\\tau = 1\\times 10^{-6}$ 来判定通过或失败。\n\n测试套件：\n- 仅状态方向的测试，其中 $p_{x_0} = [1.0,\\ -0.5]^\\top$，$p_{\\theta} = [0,\\ 0]^\\top$，步长 $h \\in \\{1\\times 10^{-16},\\ 1\\times 10^{-5},\\ 1\\times 10^{-1}\\}$。\n- 仅参数方向的测试，其中 $p_{x_0} = [0,\\ 0]^\\top$，$p_{\\theta} = [1.0,\\ -1.0]^\\top$，步长 $h \\in \\{1\\times 10^{-16},\\ 1\\times 10^{-5},\\ 1\\times 10^{-1}\\}$。\n- 混合方向的测试，其中 $p_{x_0} = [0.3,\\ 0.7]^\\top$，$p_{\\theta} = [0.5,\\ 0.2]^\\top$，步长 $h \\in \\{1\\times 10^{-5},\\ 1\\times 10^{-1}\\}$。\n\n对于上述八个测试中的每一个，计算 $\\mathrm{relerr}$ 并返回一个布尔值，指示测试是否通过 ($\\mathrm{relerr} \\leq \\tau$)。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，`[True,False,...]`），并严格按照上面列出的测试顺序排列。",
            "solution": "用户提供的问题已经过验证，被认为是一个定义明确、具有科学依据的计算数据同化练习。本解答将介绍针对所提供的四维变分 (4D-Var) 代价函数的梯度检验的推导和实现。\n\n任务的核心是计算代价函数 $J(x_0, \\theta)$ 关于控制变量（即初始状态 $x_0$ 和模型参数 $\\theta$）的梯度。伴随推导的方向导数需要这个梯度。代价函数为\n$$\nJ(x_0,\\theta) = \\underbrace{\\tfrac{1}{2}(x_0 - x_b)^\\top B^{-1} (x_0 - x_b)}_{J_b(x_0)} + \\underbrace{\\tfrac{1}{2}\\sum_{k=0}^K \\left(H x_k - y_k\\right)^\\top R^{-1} \\left(H x_k - y_k\\right)}_{J_o(x_0, \\theta)} + \\underbrace{\\tfrac{1}{2}(\\theta - \\theta_b)^\\top P^{-1} (\\theta - \\theta_b)}_{J_p(\\theta)}.\n$$\n当 $k>0$ 时，状态 $x_k$ 是控制变量的函数，由模型动力学方程 $x_{k+1} = M(\\theta) x_k$ 隐式定义。$J$ 的梯度是其各分量梯度的和：$\\nabla J = \\nabla J_b + \\nabla J_o + \\nabla J_p$。\n\n背景项 $J_b$ 和 $J_p$ 的梯度是直接的：\n$$\n\\nabla_{x_0} J_b = B^{-1}(x_0 - x_b)\n$$\n$$\n\\nabla_{\\theta} J_p = P^{-1}(\\theta - \\theta_b)\n$$\n由于状态 $\\{x_k\\}$ 对控制变量的递归依赖性，观测项 $J_o$ 的梯度更为复杂。我们采用离散伴随方法（拉格朗日乘子技术的一种专门应用）来高效地计算这个梯度。\n\n我们定义一个伴随变量序列 $\\{\\lambda_k\\}_{k=0}^K$，它们是 $\\mathbb{R}^2$ 中的向量。伴随模型是通过确保拉格朗日函数（即代价函数加上模型约束）关于状态变量 $x_k$ (对于 $k>0$) 的梯度为零来推导的。这会导出一个方程组，可以通过时间上的反向积分来求解伴随变量。\n\n计算梯度分量 $\\nabla_{x_0} J_o$ 和 $\\nabla_{\\theta} J_o$ 的过程如下：\n\n1.  **正向积分**：给定控制空间中的一点 $(x_0, \\theta)$，从 $k=0$到 $K-1$ 积分正向模型 $x_{k+1} = M(\\theta) x_k$，并存储整个状态轨迹 $\\{x_k\\}_{k=0}^K$。矩阵 $M(\\theta)$ 由 $M(\\theta) = I + \\Delta t\\, F(\\theta)$ 给出，其中 $F(\\theta) = \\begin{bmatrix} -\\alpha & f \\\\ -f & -\\alpha \\end{bmatrix}$。\n\n2.  **反向（伴随）积分**：\n    a. 初始化最终的伴随变量 $\\lambda_K$。这对应于代价函数关于最终状态 $x_K$ 的梯度：\n    $$\n    \\lambda_K = \\frac{\\partial J_o}{\\partial x_K} = H^\\top R^{-1} (H x_K - y_K)\n    $$\n    b. 从 $k=K-1$ 向下积分到 $k=0$。在步骤 $k$ 的伴随变量由步骤 $k+1$ 的伴随变量、正向模型传播矩阵的转置 $M(\\theta)^\\top$ 以及来自时间 $k$ 的观测的附加强迫项计算得出：\n    $$\n    \\lambda_k = M(\\theta)^\\top \\lambda_{k+1} + H^\\top R^{-1} (H x_k - y_k)\n    $$\n    计算出的最终伴随变量 $\\lambda_0$ 正是观测代价函数关于初始状态的梯度：$\\nabla_{x_0} J_o = \\lambda_0$。\n\n3.  **参数梯度累积**：关于参数 $\\theta$ 的梯度可以在反向积分过程中计算。代价函数对参数 $\\theta_j$ 的敏感度由下式给出\n    $$\n    \\nabla_{\\theta_j} J_o = \\sum_{k=0}^{K-1} \\left( \\frac{\\partial x_{k+1}}{\\partial \\theta_j} \\right)^\\top \\lambda_{k+1}\n    $$\n    其中括号中的量是沿着正向轨迹计算的。由于 $x_{k+1} = M(\\theta) x_k$，我们有 $\\frac{\\partial x_{k+1}}{\\partial \\theta_j} = \\left(\\frac{\\partial M(\\theta)}{\\partial \\theta_j}\\right) x_k$。所需的矩阵导数为：\n    $$\n    \\frac{\\partial M}{\\partial \\alpha} = \\Delta t \\begin{bmatrix} -1 & 0 \\\\ 0 & -1 \\end{bmatrix} = -\\Delta t I\n    $$\n    $$\n    \\frac{\\partial M}{\\partial f} = \\Delta t \\begin{bmatrix} 0 & 1 \\\\ -1 & 0 \\end{bmatrix}\n    $$\n    在从 $k=K-1, \\dots, 0$ 的反向扫描过程中，我们累积对参数梯度的贡献：\n    $$\n    \\nabla_{\\alpha} J_o \\leftarrow \\nabla_{\\alpha} J_o + \\left( (-\\Delta t I) x_k \\right)^\\top \\lambda_{k+1} = \\nabla_{\\alpha} J_o - \\Delta t \\, x_k^\\top \\lambda_{k+1}\n    $$\n    $$\n    \\nabla_{f} J_o \\leftarrow \\nabla_{f} J_o + \\left( \\left(\\Delta t \\begin{bmatrix} 0 & 1 \\\\ -1 & 0 \\end{bmatrix}\\right) x_k \\right)^\\top \\lambda_{k+1} = \\nabla_{f} J_o + \\Delta t \\, x_k^\\top \\begin{bmatrix} 0 & -1 \\\\ 1 & 0 \\end{bmatrix} \\lambda_{k+1}\n    $$\n\n最后，通过加上背景项的贡献来组合得到总梯度：\n$$\n\\nabla_{x_0} J = B^{-1}(x_0 - x_b) + \\lambda_0\n$$\n$$\n\\nabla_{\\theta} J = P^{-1}(\\theta - \\theta_b) + \\nabla_{\\theta} J_o\n$$\n利用这些梯度，可以计算出伴随推导的方向导数 $D_{\\mathrm{ADJ}} J$。然后将其与中心有限差分近似 $D_{\\mathrm{FD}} J$ 进行比较，以计算每个测试用例的相对误差。如果此误差低于容差 $\\tau = 1 \\times 10^{-6}$，则测试通过。\n\n该测试套件旨在探测实现的正确性和数值稳定性。步长非常小（$h=1 \\times 10^{-16}$）的测试预计会因为浮点数运算中的灾难性抵消而失败。步长较大（$h=1 \\times 10^{-1}$）的测试预计会因为有限差分近似中的巨大截断误差而失败。步长适中（$h=1 \\times 10^{-5}$）的测试预计会通过，从而证明伴随推导梯度的准确性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and implements a gradient test for a 4D-Var data assimilation problem.\n    \"\"\"\n\n    # --- Model setup and data generation ---\n\n    # Time-stepping parameters\n    K = 10\n    dt = 900.0\n\n    # True parameters and initial state for generating observations\n    alpha_star = 2e-6\n    f_star = 1e-4\n    theta_star = np.array([alpha_star, f_star])\n    x0_star = np.array([0.1, 0.05])\n\n    # Prior means\n    x_b = np.array([0.0, 0.0])\n    theta_b = np.array([1e-6, 0.8e-4])\n\n    # Standard deviations for covariances\n    sigma_b_u = 0.2\n    sigma_b_v = 0.2\n    sigma_R = 0.01\n    sigma_alpha = 1e-6\n    sigma_f = 0.2e-4\n\n    # Inverse covariance matrices and observation error variance\n    B_inv = np.diag([1/sigma_b_u**2, 1/sigma_b_v**2])\n    R_inv = 1/sigma_R**2\n    P_inv = np.diag([1/sigma_alpha**2, 1/sigma_f**2])\n    \n    # Observation operator\n    H = np.array([1.0, 0.0])\n\n    # Generate synthetic observations\n    def get_M(theta):\n        alpha, f = theta\n        F = np.array([[-alpha, f], [-f, -alpha]])\n        return np.identity(2) + dt * F\n\n    M_star = get_M(theta_star)\n    x_star_traj = np.zeros((K + 1, 2))\n    x_star_traj[0] = x0_star\n    for k in range(K):\n        x_star_traj[k + 1] = M_star @ x_star_traj[k]\n\n    ys = np.array([H @ xk for xk in x_star_traj])\n\n    # --- Core Functions ---\n    def cost_function_J(x0, theta):\n        \"\"\"Computes the 4D-Var cost function J(x0, theta).\"\"\"\n        # Trajectory calculation\n        M = get_M(theta)\n        x_traj = np.zeros((K + 1, 2))\n        x_traj[0] = x0\n        for k in range(K):\n            x_traj[k + 1] = M @ x_traj[k]\n\n        # Background term for x0\n        j_b = 0.5 * (x0 - x_b).T @ B_inv @ (x0 - x_b)\n\n        # Observation term\n        j_o = 0.0\n        for k in range(K + 1):\n            mismatch = H @ x_traj[k] - ys[k]\n            j_o += 0.5 * mismatch * R_inv * mismatch\n        \n        # Background term for theta\n        j_p = 0.5 * (theta - theta_b).T @ P_inv @ (theta - theta_b)\n\n        return j_b + j_o + j_p\n\n    def adjoint_gradient(x0, theta):\n        \"\"\"Computes gradients of J w.r.t. x0 and theta using the adjoint method.\"\"\"\n        # 1. Forward model run to get trajectory\n        M = get_M(theta)\n        x_traj = np.zeros((K + 1, 2))\n        x_traj[0] = x0\n        for k in range(K):\n            x_traj[k + 1] = M @ x_traj[k]\n\n        # 2. Backward (adjoint) integration\n        grad_theta_o = np.zeros(2)\n        \n        # Initialize adjoint variable at final time K\n        forcing_K = H.T * R_inv * (H @ x_traj[K] - ys[K])\n        lambda_next = forcing_K # This is lambda_{k+1}, starting with lambda_K\n\n        # Loop from k = K-1 down to 0\n        for k in range(K - 1, -1, -1):\n            # Accumulate parameter gradient contribution using x_k and lambda_{k+1}\n            # Contribution to dJ_o/d_alpha\n            grad_theta_o[0] += (-dt * x_traj[k]) @ lambda_next\n            # Contribution to dJ_o/d_f\n            dMdf_x_k_T = dt * np.array([x_traj[k, 1], -x_traj[k, 0]]) # (dM/df * x_k)^T\n            grad_theta_o[1] += dMdf_x_k_T @ lambda_next\n\n            # Forcing term at time k\n            forcing_k = H.T * R_inv * (H @ x_traj[k] - ys[k])\n            \n            # Update adjoint state: lambda_k = M^T @ lambda_{k+1} + forcing_k\n            lambda_k = M.T @ lambda_next + forcing_k\n            \n            # Update for next iteration\n            lambda_next = lambda_k\n\n        lambda_0 = lambda_next\n\n        # 3. Assemble full gradients\n        grad_x0 = B_inv @ (x0 - x_b) + lambda_0\n        grad_theta = P_inv @ (theta - theta_b) + grad_theta_o\n\n        return grad_x0, grad_theta\n\n    # --- Gradient Test ---\n    # Evaluation point for the gradient test\n    x0_eval = np.array([0.05, 0.01])\n    theta_eval = np.array([1.5e-6, 0.9e-4])\n\n    # Test suite\n    test_cases = [\n        # State-only direction tests\n        {'p_x0': np.array([1.0, -0.5]), 'p_theta': np.array([0.0, 0.0]), 'h': 1e-16},\n        {'p_x0': np.array([1.0, -0.5]), 'p_theta': np.array([0.0, 0.0]), 'h': 1e-5},\n        {'p_x0': np.array([1.0, -0.5]), 'p_theta': np.array([0.0, 0.0]), 'h': 1e-1},\n        # Parameter-only direction tests\n        {'p_x0': np.array([0.0, 0.0]), 'p_theta': np.array([1.0, -1.0]), 'h': 1e-16},\n        {'p_x0': np.array([0.0, 0.0]), 'p_theta': np.array([1.0, -1.0]), 'h': 1e-5},\n        {'p_x0': np.array([0.0, 0.0]), 'p_theta': np.array([1.0, -1.0]), 'h': 1e-1},\n        # Mixed direction tests\n        {'p_x0': np.array([0.3, 0.7]), 'p_theta': np.array([0.5, 0.2]), 'h': 1e-5},\n        {'p_x0': np.array([0.3, 0.7]), 'p_theta': np.array([0.5, 0.2]), 'h': 1e-1},\n    ]\n\n    tau = 1e-6\n    results = []\n    \n    # Pre-compute adjoint gradient at the evaluation point\n    grad_x0_adj, grad_theta_adj = adjoint_gradient(x0_eval, theta_eval)\n\n    for case in test_cases:\n        p_x0, p_theta, h = case['p_x0'], case['p_theta'], case['h']\n\n        # Adjoint-derived directional derivative\n        D_adj = grad_x0_adj.T @ p_x0 + grad_theta_adj.T @ p_theta\n\n        # Finite-difference directional derivative (central difference)\n        J_plus = cost_function_J(x0_eval + h * p_x0, theta_eval + h * p_theta)\n        J_minus = cost_function_J(x0_eval - h * p_x0, theta_eval - h * p_theta)\n        \n        # Avoid division by zero if h is extremely small\n        if 2*h == 0:\n            D_fd = 0.0\n        else:\n            D_fd = (J_plus - J_minus) / (2 * h)\n\n        # Relative error calculation\n        abs_diff = np.abs(D_fd - D_adj)\n        denominator = np.max([1.0, np.abs(D_fd)])\n        rel_err = abs_diff / denominator\n        \n        # Test pass/fail\n        results.append(rel_err = tau)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "拥有一个经过验证的估计器后，最后一步是评估其在实际运行中的性能。对于像集合卡尔曼滤波器（EnKF）这样的序贯同化方法，其产生的“新息”（观测减去预报）的统计特性为我们提供了有力的诊断工具。通过分析这些新息，我们可以判断滤波器的统计假设是否与实际情况相符，并据此调整滤波器参数以优化其性能。本问题深入探讨了“归一化新息平方”（NIS）统计量的理论与应用，你将首先推导其理论分布，然后利用该结果发展出一种调整协方差膨胀的实用方法 ，从而将基础统计理论与实际的滤波器调优挑战联系起来。",
            "id": "3811231",
            "problem": "考虑一个海洋数据同化循环，其中海面温度由位于 $m$ 个位置的浮标阵列观测，并使用集合卡尔曼滤波器（EnKF）同化到一个原始方程海洋模型中。设观测算子是线性的，并且在观测分量上等于单位算子，因此 $H = I_{m}$。假设观测分量的预报误差是无偏的，服从协方差为 $P^{f} \\in \\mathbb{R}^{m \\times m}$ 的高斯分布，并且观测误差是无偏的，服从协方差为 $R \\in \\mathbb{R}^{m \\times m}$ 的高斯分布，且与预报误差统计独立。将在分析时刻的新息定义为 $d = y - H x^{f} \\in \\mathbb{R}^{m}$，其中 $y$ 是观测向量，$x^{f}$ 是预报状态向量。EnKF 使用的预报观测误差协方差为 $S = H P^{f} H^{\\top} + R \\in \\mathbb{R}^{m \\times m}$。归一化新息平方统计量定义为 $\\text{NIS} = d^{\\top} S^{-1} d$。\n\n任务 A（分布推导）：从上述高斯假设出发，推导归一化新息平方统计量的分布，并确定观测维度 $m$ 在此分布中的作用。证明在哪种一致性条件下，该统计量为 $S$ 的准确性提供了一个原则性检验。\n\n任务 B（各向同性设置下的实际调优）：将问题具体化到计算海洋学中一个科学上现实的各向同性设置，其中 $H = I_{m}$，$P^{f} = \\hat{\\sigma}_{f}^{2} I_{m}$（其中 $\\hat{\\sigma}_{f}^{2}  0$ 是某个集合估计的预报方差），以及 $R = \\sigma_{r}^{2} I_{m}$（其中 $\\sigma_{r}^{2}  0$ 是已知的传感器噪声方差）。假设一个乘性膨胀因子 $\\lambda  0$ 被应用于集合预报协方差，使得滤波器中使用的预报协方差为 $S(\\lambda) = \\lambda \\hat{\\sigma}_{f}^{2} I_{m} + \\sigma_{r}^{2} I_{m}$。在统计平稳状态下的 $K$ 个连续循环中，定义新息范数平方的样本均值为\n$$\n\\bar{q} = \\frac{1}{K} \\sum_{k=1}^{K} \\| d_{k} \\|^{2},\n$$\n其中 $d_{k}$ 表示第 $k$ 个循环的新息。在所述假设下，通过用可观测的估计量 $\\bar{q}$ 替换真实预报协方差的未知迹，推导膨胀因子 $\\lambda$ 的一个闭式表达式，该表达式在期望意义上强制执行一致性条件 $\\mathbb{E}[\\text{NIS}] = m$。您的最终答案必须是一个关于 $\\lambda$ 的单一解析表达式，用 $\\bar{q}$、$m$、$\\hat{\\sigma}_{f}^{2}$ 和 $\\sigma_{r}^{2}$ 表示。无需进行数值计算。",
            "solution": "该问题分为两个任务。任务 A 要求推导归一化新息平方（NIS）统计量的分布，并解释其作为一致性检验的用途。任务 B 要求在特定的各向同性设置下，推导膨胀因子 $\\lambda$ 的闭式表达式。\n\n任务 A：归一化新息平方统计量的分布\n\n设观测空间中的真实状态向量为 $H x^t$，其中 $x^t$ 是真实状态。观测向量 $y \\in \\mathbb{R}^m$ 由 $y = H x^t + v$ 给出，其中 $v \\sim \\mathcal{N}(0, R)$ 是观测误差向量，假设为零均值、协方差矩阵为 $R \\in \\mathbb{R}^{m \\times m}$ 的高斯分布。预报状态向量 $x^f$ 通过 $x^f = x^t + e^f$ 与真实状态相关，其中 $e^f$ 是预报误差。观测空间中的预报误差是 $H e^f$。问题陈述此误差是无偏的，服从协方差为 $P^f \\in \\mathbb{R}^{m \\times m}$ 的高斯分布。这是一种非常规的记法，因为 $P^f$ 通常表示 $x^f$ 的协方差，而不是 $H x^f$。然而，随后的 $H = I_m$ 的假设阐明了我们考虑的是整个状态都被观测的情况，因此状态空间和观测空间的维度都是 $m$。当 $H = I_m$ 时，我们有 $P^f$ 作为预报误差 $e^f$ 的协方差。\n\n新息向量 $d \\in \\mathbb{R}^m$ 定义为 $d = y - H x^f$。代入 $y$ 和 $x^f$ 的表达式：\n$$\nd = (H x^t + v) - H(x^t + e^f) = v - H e^f\n$$\n由于 $v$ 和 $e^f$ 都是零均值高斯随机向量，并且假设它们统计独立，所以它们的线性组合 $d$ 也是一个零均值高斯随机向量。\n$d$ 的均值为：\n$$\n\\mathbb{E}[d] = \\mathbb{E}[v - H e^f] = \\mathbb{E}[v] - H \\mathbb{E}[e^f] = 0 - H(0) = 0\n$$\n$d$ 的协方差为：\n$$\n\\text{Cov}(d) = \\mathbb{E}[d d^\\top] = \\mathbb{E}[(v - H e^f)(v - H e^f)^\\top] = \\mathbb{E}[v v^\\top - v (H e^f)^\\top - H e^f v^\\top + H e^f (H e^f)^\\top]\n$$\n由于 $v$ 和 $e^f$ 的独立性，交叉项的期望为零：$\\mathbb{E}[v (H e^f)^\\top] = \\mathbb{E}[v] \\mathbb{E}[(H e^f)^\\top] = 0$。\n因此，$d$ 的协方差是各自协方差之和：\n$$\n\\text{Cov}(d) = \\mathbb{E}[v v^\\top] + \\mathbb{E}[H e^f (e^f)^\\top H^\\top] = R + H \\mathbb{E}[e^f (e^f)^\\top] H^\\top = R + H P^f H^\\top\n$$\n问题将预报的观测误差协方差（或新息协方差）定义为 $S = H P^f H^\\top + R$。因此，如果滤波器使用的协方差 $P^f$ 和 $R$ 是真实的协方差，那么新息向量 $d$ 服从均值为 $0$、协方差为 $S$ 的多元正态分布：\n$$\nd \\sim \\mathcal{N}(0, S)\n$$\n归一化新息平方（NIS）统计量定义为 $\\text{NIS} = d^\\top S^{-1} d$。为了求出其分布，我们定义一个变换后的随机向量 $z \\in \\mathbb{R}^m$ 如下：\n$$\nz = S^{-1/2} d\n$$\n其中 $S^{1/2}$ 是正定矩阵 $S$ 的一个矩阵平方根，使得 $S = S^{1/2} (S^{1/2})^\\top$。因此，$S^{-1} = (S^{-1/2})^\\top S^{-1/2}$。\n$z$ 的均值为 $\\mathbb{E}[z] = S^{-1/2} \\mathbb{E}[d] = 0$。\n$z$ 的协方差为：\n$$\n\\text{Cov}(z) = \\mathbb{E}[z z^\\top] = \\mathbb{E}[S^{-1/2} d d^\\top (S^{-1/2})^\\top] = S^{-1/2} \\mathbb{E}[d d^\\top] (S^{-1/2})^\\top = S^{-1/2} S (S^{-1/2})^\\top\n$$\n代入 $S = S^{1/2} (S^{1/2})^\\top$：\n$$\n\\text{Cov}(z) = S^{-1/2} S^{1/2} (S^{1/2})^\\top (S^{-1/2})^\\top = I_m I_m^\\top = I_m\n$$\n其中 $I_m$ 是 $m \\times m$ 的单位矩阵。因此，向量 $z$ 服从标准多元正态分布，$z \\sim \\mathcal{N}(0, I_m)$。这意味着 $z$ 的分量（记为 $z_i$，$i=1, \\dots, m$）是独立同分布的标准正态随机变量，$z_i \\sim \\mathcal{N}(0,1)$。\n\n现在我们可以用 $z$ 来表示 NIS 统计量：\n$$\n\\text{NIS} = d^\\top S^{-1} d = d^\\top (S^{-1/2})^\\top S^{-1/2} d = (S^{-1/2}d)^\\top(S^{-1/2}d) = z^\\top z = \\sum_{i=1}^m z_i^2\n$$\n根据定义，$m$ 个独立标准正态随机变量的平方和服从自由度为 $m$ 的卡方分布。因此，NIS 统计量的分布是：\n$$\n\\text{NIS} \\sim \\chi^2_m\n$$\n观测维度 $m$ 的作用至关重要：它决定了这个卡方分布的自由度。\n\n这个推导成立的条件是，用于归一化新息的新息协方差 $S = H P^f H^\\top + R$ 确实是新息向量 $d$ 的真实协方差。这就是一致性条件。如果滤波器关于预报误差协方差 $P^f$ 和观测误差协方差 $R$ 的假设是正确的，那么新息将与一个 $\\mathcal{N}(0, S)$ 过程统计一致。NIS 统计量为这种一致性提供了一个原则性检验。卡方分布的一个关键性质是其期望值等于其自由度，即 $\\mathbb{E}[\\chi^2_m] = m$。因此，通过监测 NIS 值的长期平均值，可以检验 $S$ 的准确性。如果 NIS 的样本均值显著偏离 $m$，则意味着滤波器的误差协方差假设不正确，$S$ 要么过大（$\\mathbb{E}[\\text{NIS}]  m$），要么过小（$\\mathbb{E}[\\text{NIS}]  m$）。\n\n任务 B：膨胀因子 $\\lambda$ 的推导\n\n我们现在将问题具体化到各向同性设置，其中 $H = I_m$，集合估计的预报误差协方差为 $\\hat{P}^f = \\hat{\\sigma}_f^2 I_m$，观测误差协方差为 $R = \\sigma_r^2 I_m$。将一个乘性膨胀因子 $\\lambda  0$ 应用于预报误差协方差。滤波器中使用的由此产生的预报观测误差协方差为：\n$$\nS(\\lambda) = \\lambda \\hat{P}^f + R = \\lambda \\hat{\\sigma}_f^2 I_m + \\sigma_r^2 I_m = (\\lambda \\hat{\\sigma}_f^2 + \\sigma_r^2) I_m\n$$\n该协方差矩阵的逆为：\n$$\nS(\\lambda)^{-1} = \\frac{1}{\\lambda \\hat{\\sigma}_f^2 + \\sigma_r^2} I_m\n$$\n对于给定的分析循环 $k$，NIS 统计量为 $\\text{NIS}_k = d_k^\\top S(\\lambda)^{-1} d_k$。代入 $S(\\lambda)^{-1}$ 的表达式：\n$$\n\\text{NIS}_k = d_k^\\top \\left( \\frac{1}{\\lambda \\hat{\\sigma}_f^2 + \\sigma_r^2} I_m \\right) d_k = \\frac{d_k^\\top d_k}{\\lambda \\hat{\\sigma}_f^2 + \\sigma_r^2} = \\frac{\\|d_k\\|^2}{\\lambda \\hat{\\sigma}_f^2 + \\sigma_r^2}\n$$\n任务是找到一个 $\\lambda$ 值，以强制执行一致性条件 $\\mathbb{E}[\\text{NIS}] = m$。在统计平稳状态下，对于任何循环 $k$，期望都是相同的。\n$$\n\\mathbb{E}[\\text{NIS}_k] = \\mathbb{E}\\left[ \\frac{\\|d_k\\|^2}{\\lambda \\hat{\\sigma}_f^2 + \\sigma_r^2} \\right] = \\frac{\\mathbb{E}[\\|d_k\\|^2]}{\\lambda \\hat{\\sigma}_f^2 + \\sigma_r^2}\n$$\n令此期望等于 $m$：\n$$\nm = \\frac{\\mathbb{E}[\\|d_k\\|^2]}{\\lambda \\hat{\\sigma}_f^2 + \\sigma_r^2}\n$$\n这个方程将未知参数 $\\lambda$ 与新息的期望平方范数 $\\mathbb{E}[\\|d_k\\|^2]$ 联系起来。这个期望代表了真实新息协方差矩阵的迹，$\\mathbb{E}[\\|d_k\\|^2] = \\text{tr}(\\text{Cov}(d_k))$。这个真值是未知的。然而，问题为它提供了一个可观测的估计量，即在 $K$ 个循环中新息范数平方的样本均值：\n$$\n\\bar{q} = \\frac{1}{K} \\sum_{k=1}^{K} \\|d_k\\|^2\n$$\n对于大的 $K$，$\\bar{q}$ 是 $\\mathbb{E}[\\|d_k\\|^2]$ 的一个估计量。按照问题的指示，我们在一致性方程中用其可观测的估计量 $\\bar{q}$ 替换 $\\mathbb{E}[\\|d_k\\|^2]$：\n$$\nm = \\frac{\\bar{q}}{\\lambda \\hat{\\sigma}_f^2 + \\sigma_r^2}\n$$\n我们现在求解这个方程以得到膨胀因子 $\\lambda$：\n$$\n\\lambda \\hat{\\sigma}_f^2 + \\sigma_r^2 = \\frac{\\bar{q}}{m}\n$$\n$$\n\\lambda \\hat{\\sigma}_f^2 = \\frac{\\bar{q}}{m} - \\sigma_r^2\n$$\n$$\n\\lambda = \\frac{1}{\\hat{\\sigma}_f^2} \\left( \\frac{\\bar{q}}{m} - \\sigma_r^2 \\right)\n$$\n这就是膨胀因子 $\\lambda$ 的闭式表达式，它基于由 $\\bar{q}$ 总结的观测新息统计量，调整滤波器的内部协方差模型，以平均满足一致性准则 $\\mathbb{E}[\\text{NIS}]=m$。",
            "answer": "$$\n\\boxed{\\frac{1}{\\hat{\\sigma}_{f}^{2}} \\left( \\frac{\\bar{q}}{m} - \\sigma_{r}^{2} \\right)}\n$$"
        }
    ]
}