{
    "hands_on_practices": [
        {
            "introduction": "This first exercise lays the groundwork by applying Von Neumann analysis to a foundational problem in computational fluid dynamics: the two-dimensional diffusion equation. By analyzing the Forward-Time, Centered-Space (FTCS) scheme, you will derive the classic stability criterion that relates the maximum allowable timestep, $\\Delta t$, to the physical diffusivity and grid spacing . Mastering this analytical derivation is the essential first step toward understanding and predicting the behavior of more complex numerical models.",
            "id": "3804352",
            "problem": "An ocean interior passive tracer with concentration field $C(x,y,t)$ evolves according to horizontal anisotropic diffusion with constant eddy diffusivities $K_{x}$ and $K_{y}$:\n$$\n\\frac{\\partial C}{\\partial t} \\;=\\; K_{x}\\,\\frac{\\partial^{2} C}{\\partial x^{2}} \\;+\\; K_{y}\\,\\frac{\\partial^{2} C}{\\partial y^{2}}\\,,\n$$\non a rectangular, horizontally periodic domain. Consider a uniform grid with spacings $\\Delta x$ and $\\Delta y$ and an explicit forward Euler time step of size $\\Delta t$, with second-order centered finite differences for the spatial second derivatives. The discrete update at grid point $(i,j)$ is\n$$\nC_{i,j}^{n+1} \\;=\\; C_{i,j}^{n} \\;+\\; \\Delta t \\left[ K_{x}\\,\\frac{C_{i+1,j}^{n} - 2\\,C_{i,j}^{n} + C_{i-1,j}^{n}}{\\Delta x^{2}} \\;+\\; K_{y}\\,\\frac{C_{i,j+1}^{n} - 2\\,C_{i,j}^{n} + C_{i,j-1}^{n}}{\\Delta y^{2}} \\right].\n$$\nUsing von Neumann analysis (VNA), which states that linear constant-coefficient schemes on periodic domains are stable only if the magnitude of the amplification factor does not exceed unity for all admissible discrete Fourier modes, derive the largest stable time step $\\Delta t_{\\max}$ that guarantees stability for all horizontal wavenumbers representable on the grid.\n\nYour derivation must start from the definition of the amplification factor for a discrete Fourier mode and the discrete symbol of the second-order centered second derivative. Conclude with a single closed-form symbolic expression for $\\Delta t_{\\max}$ in terms of $K_{x}$, $K_{y}$, $\\Delta x$, and $\\Delta y$. Express your final answer in seconds. Do not substitute numerical values and do not present an inequality; provide only the closed-form expression for the largest stable time step.",
            "solution": "The problem as stated is valid. It is a scientifically grounded, well-posed, and objective problem in the field of computational science, specifically concerning the numerical stability of a finite difference scheme for the two-dimensional anisotropic diffusion equation. All necessary information is provided, and the objective is to derive a standard result using a specified method, the von Neumann analysis.\n\nThe analysis begins by considering the evolution of a single, generic Fourier mode of the discrete solution $C_{i,j}^n$. A two-dimensional discrete Fourier mode is represented by the ansatz:\n$$\nC_{i,j}^{n} = \\hat{C}^{n}(k_x, k_y) \\exp[I (k_x x_i + k_y y_j)]\n$$\nwhere $x_i = i \\Delta x$ and $y_j = j \\Delta y$ are the grid point coordinates, $i$ and $j$ are the integer grid indices, $k_x$ and $k_y$ are the real-valued wavenumbers in the $x$ and $y$ directions, respectively, $n$ is the time-step index, and $I \\equiv \\sqrt{-1}$ is the imaginary unit. The term $\\hat{C}^{n}(k_x, k_y)$ represents the complex amplitude of the mode $(k_x, k_y)$ at time level $n$.\n\nThe von Neumann analysis postulates that for a linear scheme, the amplitude of each mode evolves independently according to a multiplicative factor, the amplification factor $G(k_x, k_y, \\Delta t)$, such that:\n$$\n\\hat{C}^{n+1} = G \\, \\hat{C}^{n}\n$$\nSubstituting the Fourier mode ansatz into this relationship gives:\n$$\nC_{i,j}^{n+1} = G \\, C_{i,j}^{n}\n$$\nWe now substitute the Fourier mode expression for $C_{i,j}^n$ into the given finite difference equation:\n$$\nC_{i,j}^{n+1} = C_{i,j}^{n} + \\frac{K_x \\Delta t}{\\Delta x^2} \\left(C_{i+1,j}^{n} - 2C_{i,j}^{n} + C_{i-1,j}^{n}\\right) + \\frac{K_y \\Delta t}{\\Delta y^2} \\left(C_{i,j+1}^{n} - 2C_{i,j}^{n} + C_{i,j-1}^{n}\\right)\n$$\nTo evaluate the terms at neighboring grid points, we note their relationship to $C_{i,j}^n$:\n$$\nC_{i \\pm 1, j}^{n} = \\hat{C}^n \\exp[I(k_x (i \\pm 1)\\Delta x + k_y j \\Delta y)] = C_{i,j}^n \\exp[\\pm I k_x \\Delta x]\n$$\n$$\nC_{i, j \\pm 1}^{n} = \\hat{C}^n \\exp[I(k_x i \\Delta x + k_y (j \\pm 1) \\Delta y)] = C_{i,j}^n \\exp[\\pm I k_y \\Delta y]\n$$\nSubstituting these expressions into the finite difference equation yields:\n$$\nG C_{i,j}^n = C_{i,j}^n + \\frac{K_x \\Delta t}{\\Delta x^2} \\left(C_{i,j}^n e^{I k_x \\Delta x} - 2C_{i,j}^n + C_{i,j}^n e^{-I k_x \\Delta x}\\right) + \\frac{K_y \\Delta t}{\\Delta y^2} \\left(C_{i,j}^n e^{I k_y \\Delta y} - 2C_{i,j}^n + C_{i,j}^n e^{-I k_y \\Delta y}\\right)\n$$\nDividing through by the non-zero common factor $C_{i,j}^n$, we obtain the expression for the amplification factor $G$:\n$$\nG = 1 + \\frac{K_x \\Delta t}{\\Delta x^2} \\left(e^{I k_x \\Delta x} - 2 + e^{-I k_x \\Delta x}\\right) + \\frac{K_y \\Delta t}{\\Delta y^2} \\left(e^{I k_y \\Delta y} - 2 + e^{-I k_y \\Delta y}\\right)\n$$\nThe expressions in parentheses represent the discrete symbols of the second-order centered second derivative operator. Using Euler's identity, $e^{I\\theta} + e^{-I\\theta} = 2\\cos(\\theta)$, we simplify these expressions:\n$$\ne^{I\\theta} - 2 + e^{-I\\theta} = 2\\cos(\\theta) - 2\n$$\nUsing the half-angle identity $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$, we find:\n$$\n2\\cos(\\theta) - 2 = -2(1-\\cos(\\theta)) = -4\\sin^2(\\theta/2)\n$$\nApplying this result with $\\theta_x = k_x \\Delta x$ and $\\theta_y = k_y \\Delta y$, the amplification factor becomes:\n$$\nG = 1 + \\frac{K_x \\Delta t}{\\Delta x^2} \\left[-4\\sin^2\\left(\\frac{k_x \\Delta x}{2}\\right)\\right] + \\frac{K_y \\Delta t}{\\Delta y^2} \\left[-4\\sin^2\\left(\\frac{k_y \\Delta y}{2}\\right)\\right]\n$$\n$$\nG = 1 - 4 \\Delta t \\left[ \\frac{K_x}{\\Delta x^2}\\sin^2\\left(\\frac{k_x \\Delta x}{2}\\right) + \\frac{K_y}{\\Delta y^2}\\sin^2\\left(\\frac{k_y \\Delta y}{2}\\right) \\right]\n$$\nFor the numerical scheme to be stable, the magnitude of the amplification factor must not exceed unity for all possible wavenumbers, i.e., $|G| \\leq 1$. Since $K_x$, $K_y$, $\\Delta t$, $\\Delta x^2$, and $\\Delta y^2$ are positive, and the sine-squared terms are non-negative, the term being subtracted from $1$ is always non-negative. This means $G \\leq 1$ is always satisfied. The critical condition for stability is the lower bound:\n$$\nG \\geq -1\n$$\nSubstituting the expression for $G$:\n$$\n1 - 4 \\Delta t \\left[ \\frac{K_x}{\\Delta x^2}\\sin^2\\left(\\frac{k_x \\Delta x}{2}\\right) + \\frac{K_y}{\\Delta y^2}\\sin^2\\left(\\frac{k_y \\Delta y}{2}\\right) \\right] \\geq -1\n$$\nRearranging the inequality to solve for $\\Delta t$:\n$$\n2 \\geq 4 \\Delta t \\left[ \\frac{K_x}{\\Delta x^2}\\sin^2\\left(\\frac{k_x \\Delta x}{2}\\right) + \\frac{K_y}{\\Delta y^2}\\sin^2\\left(\\frac{k_y \\Delta y}{2}\\right) \\right]\n$$\n$$\n\\Delta t \\leq \\frac{2}{4 \\left[ \\frac{K_x}{\\Delta x^2}\\sin^2\\left(\\frac{k_x \\Delta x}{2}\\right) + \\frac{K_y}{\\Delta y^2}\\sin^2\\left(\\frac{k_y \\Delta y}{2}\\right) \\right]} = \\frac{1}{2 \\left[ \\frac{K_x}{\\Delta x^2}\\sin^2\\left(\\frac{k_x \\Delta x}{2}\\right) + \\frac{K_y}{\\Delta y^2}\\sin^2\\left(\\frac{k_y \\Delta y}{2}\\right) \\right]}\n$$\nThis inequality must hold for all wavenumbers $(k_x, k_y)$ that are representable on the grid. To find the most restrictive condition on $\\Delta t$, we must maximize the denominator. The maximum value of $\\sin^2(\\theta/2)$ is $1$. This occurs for the highest frequency (shortest wavelength) modes, known as the Nyquist frequencies. The shortest resolvable wavelength in the $x$-direction is $\\lambda_x = 2 \\Delta x$, which corresponds to a wavenumber $k_x = \\pi/\\Delta x$. For this mode, the argument of the sine function is $(k_x \\Delta x)/2 = \\pi/2$, and thus $\\sin^2(\\pi/2) = 1$. Similarly, the maximum value for the $y$-direction term is also $1$, occurring at $k_y = \\pi/\\Delta y$.\nThe most stringent constraint arises when both sinusoidal terms are simultaneously maximized:\n$$\n\\sin^2\\left(\\frac{k_x \\Delta x}{2}\\right) \\rightarrow 1 \\quad \\text{and} \\quad \\sin^2\\left(\\frac{k_y \\Delta y}{2}\\right) \\rightarrow 1\n$$\nSubstituting these maximum values into the inequality for $\\Delta t$ gives the stability limit:\n$$\n\\Delta t \\leq \\frac{1}{2 \\left( \\frac{K_x}{\\Delta x^2} \\cdot 1 + \\frac{K_y}{\\Delta y^2} \\cdot 1 \\right)}\n$$\nThe largest stable time step, $\\Delta t_{\\max}$, is the value that satisfies this condition as an equality.\n$$\n\\Delta t_{\\max} = \\frac{1}{2 \\left( \\frac{K_x}{\\Delta x^2} + \\frac{K_y}{\\Delta y^2} \\right)}\n$$\nThis expression provides the maximum permissible time step size that ensures numerical stability for all wavenumbers.",
            "answer": "$$\n\\boxed{\\frac{1}{2\\left(\\frac{K_x}{\\Delta x^2} + \\frac{K_y}{\\Delta y^2}\\right)}}\n$$"
        },
        {
            "introduction": "While analytical derivations provide deep insight, real-world schemes can be too complex for a purely paper-and-pencil approach. This practice transitions from theory to computation, guiding you to build a numerical tool to evaluate the stability and dispersion of various schemes . Implementing this numerical Von Neumann analyzer will empower you to assess any linear, constant-coefficient scheme, a vital skill for both model development and critical use of existing codes.",
            "id": "3804367",
            "problem": "Consider the one-dimensional linear advection of a passive tracer, described by the partial differential equation $u_t + c\\,u_x = 0$, where $c$ is a constant advection speed. For a uniform grid with spacing $\\Delta x$, a translation-invariant spatial discretization of $u_x$ can be represented as a finite stencil with coefficients $\\{a_m\\}_{m=-M}^{M}$, yielding the semi-discrete form $u_t = -\\frac{c}{\\Delta x}\\sum_{m=-M}^{M} a_m\\,u_{i+m}$. Under the Von Neumann analysis framework, the discrete Fourier mode $u_i^n = A^n e^{\\mathrm{i} i \\theta}$, for mode angle $\\theta \\in [-\\pi,\\pi]$ in radians, is an eigenfunction of any such linear translation-invariant scheme. The corresponding spatial symbol is $S(\\theta) = \\sum_{m=-M}^{M} a_m\\,\\mathrm{e}^{\\mathrm{i} m \\theta}$ and the semi-discrete eigenvalue is $\\lambda(\\theta) = -\\frac{c}{\\Delta x} S(\\theta)$. For a time step $\\Delta t$, the Courant number is defined as $\\mu = \\frac{c\\,\\Delta t}{\\Delta x}$, and the nondimensional eigenvalue is $z(\\theta) = \\lambda(\\theta)\\,\\Delta t = -\\mu\\,S(\\theta)$.\n\nA one-step time integrator applied to the scalar linear ordinary differential equation $A'(t) = \\lambda(\\theta)\\,A(t)$ produces an amplification factor $G(\\theta)$ such that $A^{n+1} = G(\\theta)\\,A^n$. For explicit Runge–Kutta methods defined by a Butcher tableau $(A,b)$, the stages can be computed recursively for the scalar problem to obtain $G(\\theta)$ without closed-form shortcuts. For the trapezoidal (Crank–Nicolson) method, the update is defined implicitly for the scalar linear equation and can be evaluated directly for $G(\\theta)$. Using these principles:\n\n1. Implement a general numerical procedure that, given a stencil $\\{a_m\\}$ and a time integrator specification, computes the amplification factor $G(\\theta)$ for any $\\theta \\in [-\\pi,\\pi]$ (radians).\n2. Implement a sampling strategy for $\\theta$ over the interval $[-\\pi,\\pi]$ (radians) to assess both stability and dispersion. Your sampling must:\n   - Use a uniform grid of $N$ angles including the endpoints $-\\pi$ and $\\pi$.\n   - Avoid division by zero in dispersion calculations by excluding angles with $|\\theta|$ below a small threshold.\n3. Assess stability by computing $\\max_{\\theta} |G(\\theta)|$ over the sampled angles and declaring the scheme stable if and only if $\\max_{\\theta} |G(\\theta)| \\leq 1$.\n4. Assess dispersion by computing the root-mean-square (RMS) phase speed error with respect to the exact advection speed $c$. For each sampled angle with $|\\theta|$ above threshold, define the numerical phase speed $v_{p,\\mathrm{num}}(\\theta) = -\\frac{\\operatorname{arg}(G(\\theta))\\,\\Delta x}{\\theta\\,\\Delta t}$, where $\\operatorname{arg}(\\cdot)$ is the principal value of the complex argument in radians. Compute the RMS of $v_{p,\\mathrm{num}}(\\theta) - c$ over the sampled angles that satisfy the threshold. All angles must be in radians; speeds are dimensionless in this problem.\n\nYour program must support the following stencils and time integrators:\n\n- Stencils for $u_x$:\n  - Upwind first-order: $a_{-1} = -1$, $a_{0} = 1$.\n  - Centered second-order: $a_{-1} = -\\frac{1}{2}$, $a_{1} = \\frac{1}{2}$.\n\n- Time integrators:\n  - Forward Euler (one-stage explicit Runge–Kutta).\n  - Explicit midpoint (two-stage, second-order Runge–Kutta).\n  - Classical three-stage, third-order Runge–Kutta.\n  - Trapezoidal rule (Crank–Nicolson).\n\nYou must implement the explicit Runge–Kutta amplification numerically via the Butcher tableau recursion for the scalar linear problem. You must implement the trapezoidal rule amplification for the scalar linear problem by directly evaluating the scalar implicit update.\n\nSampling requirement: Use $N=257$ uniformly spaced angles over $[-\\pi,\\pi]$ (radians). For dispersion, exclude angles with $|\\theta|  10^{-6}$.\n\nTest suite:\n- Case 1: Upwind first-order, Forward Euler, Courant number $\\mu = 0.8$.\n- Case 2: Upwind first-order, Forward Euler, Courant number $\\mu = 1.2$.\n- Case 3: Centered second-order, Classical three-stage third-order Runge–Kutta, Courant number $\\mu = 0.5$.\n- Case 4: Centered second-order, Forward Euler, Courant number $\\mu = 0.1$.\n- Case 5: Centered second-order, Trapezoidal rule (Crank–Nicolson), Courant number $\\mu = 2.0$.\n\nIn all test cases, take $c = 1$ and $\\Delta x = 1$, so that $\\Delta t = \\mu$; angles are in radians.\n\nProgram output specification: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must be a list of the form $[\\text{stable\\_flag}, \\max|G|, \\text{RMS\\_phase\\_speed\\_error}]$, where $\\text{stable\\_flag}$ is a boolean, and the remaining entries are floating-point numbers. For example, the output should look like $[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]$ with no additional text.",
            "solution": "The supplied problem is a well-posed and scientifically sound exercise in the numerical analysis of partial differential equations, specifically using Von Neumann analysis to assess the stability and dispersion properties of several common finite difference schemes for the linear advection equation. The given definitions, parameters, and required computations are standard in the field of computational science and engineering. The problem statement is complete, consistent, and unambiguous. We therefore proceed with the solution.\n\nThe governing equation is the one-dimensional linear advection equation for a passive tracer concentration $u(x,t)$:\n$$\n\\frac{\\partial u}{\\partial t} + c \\frac{\\partial u}{\\partial x} = 0\n$$\nwhere $c$ is the constant advection speed.\n\nWe discretize this equation on a uniform spatial grid $x_j = j\\Delta x$ and for discrete time levels $t^n = n\\Delta t$. The problem specifies a semi-discretization in space of the form:\n$$\n\\frac{du_j(t)}{dt} = -\\frac{c}{\\Delta x} \\sum_{m=-M}^{M} a_m u_{j+m}(t)\n$$\nwhere $\\{a_m\\}$ are the coefficients of the finite difference stencil approximating the spatial derivative $\\partial u / \\partial x$.\n\nTo perform Von Neumann stability analysis, we consider the evolution of a single Fourier mode, $u_j(t) = A(t) e^{\\mathrm{i} j \\theta}$, where $\\theta = k \\Delta x$ is the non-dimensional wavenumber (or mode angle) and $k$ is the wavenumber. Substituting this into the semi-discrete equation yields an ordinary differential equation (ODE) for the modal amplitude $A(t)$:\n$$\n\\frac{dA(t)}{dt} e^{\\mathrm{i} j \\theta} = -\\frac{c}{\\Delta x} \\sum_{m=-M}^{M} a_m A(t) e^{\\mathrm{i} (j+m) \\theta}\n$$\nDividing by $e^{\\mathrm{i} j \\theta}$ and factoring out $A(t)$, we get:\n$$\n\\frac{dA(t)}{dt} = \\left( -\\frac{c}{\\Delta x} \\sum_{m=-M}^{M} a_m e^{\\mathrm{i} m \\theta} \\right) A(t)\n$$\nThis is an ODE of the form $A'(t) = \\lambda(\\theta) A(t)$, where the complex number $\\lambda(\\theta)$ is the eigenvalue of the semi-discrete operator for the mode $\\theta$:\n$$\n\\lambda(\\theta) = -\\frac{c}{\\Delta x} S(\\theta), \\quad \\text{with} \\quad S(\\theta) = \\sum_{m=-M}^{M} a_m e^{\\mathrm{i} m \\theta}\n$$\nHere, $S(\\theta)$ is the spatial symbol of the discretization. The spatial stencils provided are:\n1.  **First-order upwind:** For $c0$, this uses a backward difference, $\\{a_{-1}=-1, a_0=1\\}$. The symbol is $S(\\theta) = -1 \\cdot e^{\\mathrm{i}(-1)\\theta} + 1 \\cdot e^{\\mathrm{i}(0)\\theta} = 1 - e^{-\\mathrm{i}\\theta}$.\n2.  **Second-order centered:** $\\{a_{-1}=-1/2, a_1=1/2\\}$. The symbol is $S(\\theta) = -\\frac{1}{2} e^{-\\mathrm{i}\\theta} + \\frac{1}{2} e^{\\mathrm{i}\\theta} = \\mathrm{i}\\sin(\\theta)$.\n\nNext, we apply a one-step time integration scheme. The update from time $t^n$ to $t^{n+1} = t^n + \\Delta t$ can be written as $A^{n+1} = G(\\theta) A^n$, where $G(\\theta)$ is the amplification factor. The stability of the fully discrete scheme requires that $|G(\\theta)| \\le 1$ for all $\\theta \\in [-\\pi, \\pi]$.\n\nThe amplification factor $G(\\theta)$ is a function of the non-dimensional eigenvalue $z(\\theta) = \\lambda(\\theta) \\Delta t$. Using the Courant number $\\mu = \\frac{c \\Delta t}{\\Delta x}$, we have:\n$$\nz(\\theta) = -\\frac{c \\Delta t}{\\Delta x} S(\\theta) = -\\mu S(\\theta)\n$$\n\nThe amplification factors for the specified time integrators are as follows:\n\n**Explicit Runge-Kutta (RK) Methods:**\nFor a scalar ODE $A' = \\lambda A$, a general $s$-stage explicit RK method defined by a Butcher tableau with coefficients $A_{ij}$ and weights $b_i$ computes the next state as $A^{n+1} = A^n + \\Delta t \\sum_{i=1}^s b_i k_i$, where the stages $k_i$ are given by $k_i = \\lambda(A^n + \\Delta t \\sum_{j=1}^{i-1} A_{ij} k_j)$.\nTo compute $G(z)$, we define normalized stage derivatives $K_i = k_i / (\\lambda A^n)$, which obey the recurrence relation:\n$$\nK_1 = 1, \\quad K_i = 1 + z \\sum_{j=1}^{i-1} A_{ij} K_j \\quad \\text{for } i=2, \\dots, s\n$$\nThe amplification factor is then $G(z) = A^{n+1}/A^n = 1 + z \\sum_{i=1}^s b_i K_i$.\nThe specific RK methods are defined by their Butcher tableaux $(A,b)$:\n-   Forward Euler (1-stage): $A=[0], b=[1]$.\n-   Explicit Midpoint (2-stage): $A=\\begin{pmatrix} 0  0 \\\\ 1/2  0 \\end{pmatrix}, b=\\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}$.\n-   Classical RK3 (3-stage): $A=\\begin{pmatrix} 0  0  0 \\\\ 1/2  0  0 \\\\ -1  2  0 \\end{pmatrix}, b=\\begin{pmatrix} 1/6 \\\\ 2/3 \\\\ 1/6 \\end{pmatrix}$.\n\n**Trapezoidal Rule (Crank-Nicolson):**\nThis is an implicit method defined for $A'=\\lambda A$ by $A^{n+1} = A^n + \\frac{\\Delta t}{2}(\\lambda A^n + \\lambda A^{n+1})$.\nSolving for the ratio $G(z) = A^{n+1}/A^n$ with $z=\\lambda \\Delta t$:\n$$\nG = 1 + \\frac{z}{2}(1+G) \\implies G(1 - z/2) = 1 + z/2 \\implies G(z) = \\frac{1 + z/2}{1 - z/2}\n$$\n\n**Analysis Procedure:**\nThe analysis for each test case follows these steps:\n1.  Define the angle grid: a set of $N=257$ uniformly spaced points $\\theta_j$ in $[-\\pi, \\pi]$.\n2.  Compute the spatial symbol $S(\\theta_j)$ for all angles on the grid based on the chosen stencil.\n3.  Compute the non-dimensional eigenvalue $z(\\theta_j) = -\\mu S(\\theta_j)$ for the given Courant number $\\mu$.\n4.  Compute the amplification factor $G(\\theta_j)$ for all $z(\\theta_j)$ using the function corresponding to the chosen time integrator.\n5.  **Stability assessment:** Calculate $\\max_j |G(\\theta_j)|$. The scheme is declared stable if and only if this maximum is less than or equal to $1$.\n6.  **Dispersion assessment:** The numerical phase speed is $v_{p,\\text{num}}(\\theta) = -\\frac{\\arg(G(\\theta))\\Delta x}{\\theta\\Delta t}$. We are given $c=1$ and $\\Delta x=1$, so $\\Delta t = \\mu$. The formula becomes $v_{p,\\text{num}}(\\theta) = -\\frac{\\arg(G(\\theta))}{\\theta \\mu}$. The Root-Mean-Square (RMS) phase speed error is calculated over all angles where $|\\theta| \\geq 10^{-6}$:\n$$\n\\text{RMS Error} = \\sqrt{\\text{mean}[(v_{p,\\text{num}}(\\theta) - c)^2]}\n$$\nThe results for each test case are compiled into the required output format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Performs Von Neumann stability and dispersion analysis for several numerical\n    schemes applied to the 1D linear advection equation.\n    \"\"\"\n\n    # --- Stencil Definitions ---\n    # Stencils are defined as dictionaries mapping index m to coefficient a_m\n    stencils = {\n        'upwind1': {-1: -1.0, 0: 1.0},\n        'centered2': {-1: -0.5, 1: 0.5}\n    }\n\n    # --- Butcher Tableaux for Explicit Runge-Kutta Methods ---\n    # Tableaux are stored as tuples of numpy arrays (A, b)\n    butcher_tableaux = {\n        'FE': (np.array([[0.0]]), np.array([1.0])),\n        'Midpoint': (np.array([[0.0, 0.0], [0.5, 0.0]]), np.array([0.0, 1.0])),\n        'RK3': (np.array([[0.0, 0.0, 0.0], [0.5, 0.0, 0.0], [-1.0, 2.0, 0.0]]), \n                np.array([1/6, 2/3, 1/6]))\n    }\n\n    # --- Test Case Definitions ---\n    # Format: (stencil_key, integrator_key, courant_number_mu)\n    test_cases = [\n        ('upwind1', 'FE', 0.8),\n        ('upwind1', 'FE', 1.2),\n        ('centered2', 'RK3', 0.5),\n        ('centered2', 'FE', 0.1),\n        ('centered2', 'Trapezoidal', 2.0),\n    ]\n\n    # --- Analysis Parameters ---\n    N_angles = 257\n    theta_grid = np.linspace(-np.pi, np.pi, N_angles)\n    dispersion_theta_threshold = 1.0e-6\n    c = 1.0  # Advection speed\n    dx = 1.0 # Grid spacing\n\n    def compute_spatial_symbol(stencil, theta_grid):\n        \"\"\"Computes the spatial symbol S(theta) for a given stencil.\"\"\"\n        s_theta = np.zeros_like(theta_grid, dtype=np.complex128)\n        for m, a_m in stencil.items():\n            s_theta += a_m * np.exp(1j * m * theta_grid)\n        return s_theta\n\n    def compute_G_rk(z_grid, A, b):\n        \"\"\"Computes amplification factor G(z) for an explicit RK method.\"\"\"\n        num_stages = len(b)\n        K = np.zeros((num_stages, len(z_grid)), dtype=np.complex128)\n        \n        for i in range(num_stages):\n            stage_sum = np.zeros_like(z_grid, dtype=np.complex128)\n            if i > 0:\n                for j in range(i):\n                    stage_sum += A[i, j] * K[j, :]\n            K[i, :] = 1.0 + z_grid * stage_sum\n            \n        g_grid = 1.0 + z_grid * np.sum(b[:, np.newaxis] * K, axis=0)\n        return g_grid\n\n    def compute_G_trapezoidal(z_grid):\n        \"\"\"Computes amplification factor G(z) for the Trapezoidal (Crank-Nicolson) method.\"\"\"\n        # To avoid division by zero, although z=2 is not expected for stable schemes\n        # with purely imaginary z, we handle it generally.\n        with np.errstate(divide='ignore', invalid='ignore'):\n            g_grid = (1.0 + 0.5 * z_grid) / (1.0 - 0.5 * z_grid)\n        g_grid[np.isinf(g_grid)] = np.nan # Handle cases where denominator is zero\n        return g_grid\n\n    results = []\n    for stencil_key, integrator_key, mu in test_cases:\n        # --- 1. Compute Spatial Symbol S(theta) ---\n        stencil = stencils[stencil_key]\n        s_theta = compute_spatial_symbol(stencil, theta_grid)\n\n        # --- 2. Compute Nondimensional Eigenvalue z(theta) ---\n        z_theta = -mu * s_theta\n        \n        # --- 3. Compute Amplification Factor G(theta) ---\n        if integrator_key in butcher_tableaux:\n            A, b = butcher_tableaux[integrator_key]\n            g_theta = compute_G_rk(z_theta, A, b)\n        elif integrator_key == 'Trapezoidal':\n            g_theta = compute_G_trapezoidal(z_theta)\n        else:\n            raise ValueError(f\"Unknown integrator: {integrator_key}\")\n\n        # --- 4. Stability Assessment ---\n        max_g_abs = np.max(np.abs(g_theta))\n        is_stable = max_g_abs = 1.0 + 1e-9 # Use a small tolerance for floating point comparisons\n        \n        # --- 5. Dispersion Assessment ---\n        dt = mu * dx / c\n        valid_mask = np.abs(theta_grid) >= dispersion_theta_threshold\n        \n        theta_valid = theta_grid[valid_mask]\n        g_valid = g_theta[valid_mask]\n        \n        phase_g = np.angle(g_valid)\n        v_p_num = -phase_g * dx / (theta_valid * dt)\n        \n        phase_speed_error = v_p_num - c\n        rms_phase_speed_error = np.sqrt(np.mean(phase_speed_error**2))\n        \n        results.append([is_stable, max_g_abs, rms_phase_speed_error])\n    \n    # --- Final Output Formatting ---\n    # Format each inner list of results\n    formatted_results = []\n    for res in results:\n        stable_flag_str = str(res[0]).lower() # Convert boolean to \"true\" or \"false\"\n        max_g_str = f\"{res[1]:.6f}\"\n        rms_err_str = f\"{res[2]:.6f}\"\n        formatted_results.append(f\"[{stable_flag_str},{max_g_str},{rms_err_str}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The principles of stability analysis find their ultimate utility in the practical design of robust numerical models. This final exercise challenges you to apply the Courant-Friedrichs-Lewy (CFL) condition, derived from local Von Neumann analysis, to create an adaptive timestep controller for a shallow water model . Developing this algorithm demonstrates how to ensure global stability in a complex simulation with spatially varying grid properties and physics, a cornerstone of modern computational oceanography.",
            "id": "3804289",
            "problem": "Consider the two-dimensional linearized barotropic shallow water equations on an orthogonal, rectilinear grid with spatially varying mean depth $H(x,y)$ and mean flow $(u(x,y),v(x,y))$. Denote gravitational acceleration by $g$. Assume an explicit, first-order donor-cell (upwind) spatial discretization and forward Euler time stepping, applied in a dimensionally split fashion to the free-surface height $ \\eta(x,y,t) $ and its characteristic wave propagation. For purposes of stability assessment at a given grid point, use the frozen-coefficient approximation, replacing all spatially varying quantities by their local values and treating them as constant.\n\nYour task is to propose a timestep adaptation strategy that computes a single global time step $ \\Delta t $ using local wave speeds and local grid spacing, and to justify its stability using the most restrictive local von Neumann estimate. Specifically:\n\n- Begin from the fundamental characterization of wave propagation for the linearized barotropic shallow water system: local barotropic gravity waves propagate with characteristic speeds that combine mean flow advection and gravity wave speed. Use this fundamental understanding together with a frozen-coefficient linear surrogate to derive a sufficient stability condition based on the local von Neumann analysis of the donor-cell update in two spatial dimensions.\n- Propose an algorithm that, given one-dimensional arrays of grid spacings $ \\Delta x_i $ for $ i = 1,\\dots,N_x $ and $ \\Delta y_j $ for $ j = 1,\\dots,N_y $, and two-dimensional arrays $ u_{j,i} $, $ v_{j,i} $, and $ H_{j,i} $ defined on cell centers, computes a single global time step $ \\Delta t $ by aggregating the most restrictive local estimate across all cells. The algorithm should include a user-specified safety factor $ \\sigma $ in decimal form (not a percentage), with $ 0  \\sigma \\le 1 $, to provide a margin relative to the strict stability limit.\n- Express the final time step $ \\Delta t $ in seconds, rounded to six decimal places.\n\nYou will implement your algorithm and apply it to the following test suite of scenarios. In all scenarios, the program must treat the local gravity wave speed as $ c_{j,i} = \\sqrt{g\\,H_{j,i}} $ and evaluate stability using the most restrictive local von Neumann estimate derived from the frozen-coefficient two-dimensional linear advection surrogate associated with the shallow water characteristics. Use $ g = 9.81 \\ \\mathrm{m}\\,\\mathrm{s}^{-2} $ in all cases.\n\nTest Suite:\n\n1. Happy path (uniform grid and deep ocean):\n   - $ N_x = 4 $, $ N_y = 3 $.\n   - $ \\Delta x_i = 10000 \\ \\mathrm{m} $ for all $ i $.\n   - $ \\Delta y_j = 10000 \\ \\mathrm{m} $ for all $ j $.\n   - $ u_{j,i} = 0.5 \\ \\mathrm{m}\\,\\mathrm{s}^{-1} $ and $ v_{j,i} = 0.2 \\ \\mathrm{m}\\,\\mathrm{s}^{-1} $ for all $ j,i $.\n   - $ H_{j,i} = 4000 \\ \\mathrm{m} $ for all $ j,i $.\n   - Safety factor $ \\sigma = 0.8 $.\n\n2. Boundary-limited by smallest cells (no mean flow, varying $ \\Delta x $):\n   - $ N_x = 3 $, $ N_y = 2 $.\n   - $ \\Delta x_1 = 2000 \\ \\mathrm{m} $, $ \\Delta x_2 = 5000 \\ \\mathrm{m} $, $ \\Delta x_3 = 10000 \\ \\mathrm{m} $.\n   - $ \\Delta y_j = 10000 \\ \\mathrm{m} $ for $ j = 1,2 $.\n   - $ u_{j,i} = 0 \\ \\mathrm{m}\\,\\mathrm{s}^{-1} $ and $ v_{j,i} = 0 \\ \\mathrm{m}\\,\\mathrm{s}^{-1} $ for all $ j,i $.\n   - $ H_{j,i} = 4000 \\ \\mathrm{m} $ for all $ j,i $.\n   - Safety factor $ \\sigma = 0.9 $.\n\n3. Edge case (anisotropic grid, strong currents, steep depth gradients):\n   - $ N_x = 2 $, $ N_y = 2 $.\n   - $ \\Delta x_1 = 1500 \\ \\mathrm{m} $, $ \\Delta x_2 = 3000 \\ \\mathrm{m} $.\n   - $ \\Delta y_1 = 3000 \\ \\mathrm{m} $, $ \\Delta y_2 = 1500 \\ \\mathrm{m} $.\n   - $ u_{j,i} $ given by the matrix\n     $ \\begin{bmatrix}\n     1.2  0.4 \\\\\n     0.8  -0.6\n     \\end{bmatrix} \\ \\mathrm{m}\\,\\mathrm{s}^{-1} $.\n   - $ v_{j,i} $ given by the matrix\n     $ \\begin{bmatrix}\n     -0.2  1.0 \\\\\n     0.5  -1.5\n     \\end{bmatrix} \\ \\mathrm{m}\\,\\mathrm{s}^{-1} $.\n   - $ H_{j,i} $ given by the matrix\n     $ \\begin{bmatrix}\n     100  50 \\\\\n     200  4000\n     \\end{bmatrix} \\ \\mathrm{m} $.\n   - Safety factor $ \\sigma = 0.7 $.\n\nYour program should produce a single line of output containing the three results as a comma-separated list enclosed in square brackets, for example $ [\\Delta t_1,\\Delta t_2,\\Delta t_3] $, each $ \\Delta t_k $ in seconds rounded to six decimal places. No additional text should be printed.",
            "solution": "The task is to devise a robust timestep adaptation strategy for the two-dimensional linearized barotropic shallow water equations, discretized using a forward Euler time-stepping scheme and a first-order donor-cell (upwind) spatial discretization. The strategy must yield a single global time step $ \\Delta t $ that ensures numerical stability across a variable grid with spatially varying mean depth and flow. The justification for this strategy must be grounded in a local von Neumann stability analysis using a frozen-coefficient approximation.\n\nThe fundamental principle governing the system is that information, including changes in the free-surface height $ \\eta $, propagates as waves. In the linearized shallow water system, these are barotropic gravity waves. The problem specifies that we should use a linear advection surrogate model for the stability analysis, which is standard practice. The local, one-dimensional wave propagation speed is the sum of the mean flow advection speed and the gravity wave celerity, $ c = \\sqrt{gH} $.\n\nFor a two-dimensional system on a rectilinear grid, we must consider propagation in both the $ x $ and $ y $ directions. The total effective propagation speed along each axis is the sum of the magnitude of the mean flow component along that axis and the gravity wave celerity. The gravity wave propagates isotropically, so its contribution to the characteristic speed is added in both directions. Therefore, using the frozen-coefficient approximation at a given grid cell $ (j,i) $, the maximum characteristic speeds along the grid axes are:\n$$ C_{x,j,i} = |u_{j,i}| + \\sqrt{gH_{j,i}} $$\n$$ C_{y,j,i} = |v_{j,i}| + \\sqrt{gH_{j,i}} $$\nwhere $ u_{j,i} $, $ v_{j,i} $, and $ H_{j,i} $ are the local mean velocity components and mean water depth, and $ g $ is the acceleration due to gravity.\n\nThe stability of the numerical scheme is assessed by applying von Neumann analysis to the two-dimensional linear advection equation, which serves as our surrogate:\n$$ \\frac{\\partial \\eta}{\\partial t} + C_x \\frac{\\partial \\eta}{\\partial x} + C_y \\frac{\\partial \\eta}{\\partial y} = 0 $$\nThe specified numerical scheme is forward Euler in time and first-order upwind in space. For a given cell $ (j,i) $ with grid spacings $ \\Delta x_i $ and $ \\Delta y_j $, and assuming for analytical simplicity that $ C_x  0 $ and $ C_y  0 $, the discretized equation is:\n$$ \\frac{\\eta_{j,i}^{n+1} - \\eta_{j,i}^n}{\\Delta t} + C_x \\frac{\\eta_{j,i}^n - \\eta_{j,i-1}^n}{\\Delta x_i} + C_y \\frac{\\eta_{j,i}^n - \\eta_{j-1,i}^n}{\\Delta y_j} = 0 $$\nwhere the superscript $ n $ denotes the time level. Rearranging for the future time step $ \\eta_{j,i}^{n+1} $:\n$$ \\eta_{j,i}^{n+1} = \\eta_{j,i}^n - \\frac{C_x \\Delta t}{\\Delta x_i}(\\eta_{j,i}^n - \\eta_{j,i-1}^n) - \\frac{C_y \\Delta t}{\\Delta y_j}(\\eta_{j,i}^n - \\eta_{j-1,i}^n) $$\nLet's define the local Courant numbers for the $ x $ and $ y $ directions as $ \\nu_x = \\frac{C_x \\Delta t}{\\Delta x_i} $ and $ \\nu_y = \\frac{C_y \\Delta t}{\\Delta y_j} $. The equation becomes:\n$$ \\eta_{j,i}^{n+1} = (1 - \\nu_x - \\nu_y)\\eta_{j,i}^n + \\nu_x \\eta_{j,i-1}^n + \\nu_y \\eta_{j-1,i}^n $$\nThis is a weighted average of values at the current time step. A sufficient condition for stability ($ |\\text{amplification factor}| \\le 1 $) for this type of scheme is that all weighting coefficients are non-negative. Since $ \\nu_x $ and $ \\nu_y $ are non-negative (by definition of the upwind scheme which chooses the stencil based on flow direction), the only non-trivial constraint is on the first coefficient:\n$$ 1 - \\nu_x - \\nu_y \\ge 0 $$\nGeneralizing for arbitrary signs of the velocity components by using their absolute values (as the upwind scheme implicitly does), and substituting back the expressions for Courant numbers and characteristic speeds, we arrive at the local Courant-Friedrichs-Lewy (CFL) stability condition:\n$$ \\frac{(|u_{j,i}| + \\sqrt{gH_{j,i}})}{\\Delta x_i}\\Delta t + \\frac{(|v_{j,i}| + \\sqrt{gH_{j,i}})}{\\Delta y_j}\\Delta t \\le 1 $$\nThis is the most restrictive local stability estimate for a first-order, explicit, unsplit advection scheme, and is therefore appropriate despite the mention of dimensional splitting, as it guarantees a robust stability margin.\n\nTo find a single global time step $ \\Delta t $ that is stable for all cells in the computational domain, we must satisfy this condition everywhere. This requires finding the most restrictive constraint across all cells. Rearranging the condition to solve for the maximum allowable local time step, $ \\Delta t_{j,i} $:\n$$ \\Delta t_{j,i} \\le \\left( \\frac{|u_{j,i}| + \\sqrt{gH_{j,i}}}{\\Delta x_i} + \\frac{|v_{j,i}| + \\sqrt{gH_{j,i}}}{\\Delta y_j} \\right)^{-1} $$\nA stable global time step must be less than or equal to the minimum of all these local maximums. Thus, the stability limit, $ \\Delta t_{\\text{limit}} $, is:\n$$ \\Delta t_{\\text{limit}} = \\min_{j,i} \\left\\{ \\left( \\frac{|u_{j,i}| + c_{j,i}}{\\Delta x_i} + \\frac{|v_{j,i}| + c_{j,i}}{\\Delta y_j} \\right)^{-1} \\right\\} $$\nwhere $ c_{j,i} = \\sqrt{gH_{j,i}} $.\n\nThe final proposed algorithm incorporates a user-specified safety factor $ \\sigma \\in (0, 1] $ to keep the time step strictly below the limit, providing a margin for nonlinear effects or other phenomena not captured by the linear analysis. The final time step $ \\Delta t $ is:\n$$ \\Delta t = \\sigma \\cdot \\Delta t_{\\text{limit}} $$\nThis algorithm computes a single, globally valid time step by identifying the cell that most severely constrains $ \\Delta t $—typically a cell with a combination of small grid spacing, high flow velocity, and large water depth (and thus high gravity wave speed)—and then applying a safety factor. The result is rounded to six decimal places as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_dt(sigma, dx, dy, u, v, H):\n    \"\"\"\n    Computes the stable global time step based on the CFL condition for the\n    2D linearized shallow water equations.\n\n    Args:\n        sigma (float): Safety factor (0  sigma = 1).\n        dx (np.ndarray): 1D array of grid spacings in the x-direction.\n        dy (np.ndarray): 1D array of grid spacings in the y-direction.\n        u (np.ndarray): 2D array of mean velocity in the x-direction.\n        v (np.ndarray): 2D array of mean velocity in the y-direction.\n        H (np.ndarray): 2D array of mean water depth.\n\n    Returns:\n        float: The calculated stable global time step, rounded to 6 decimal places.\n    \"\"\"\n    g = 9.81\n    \n    # Ensure inputs are numpy arrays\n    dx = np.asarray(dx, dtype=np.float64)\n    dy = np.asarray(dy, dtype=np.float64)\n    u = np.asarray(u, dtype=np.float64)\n    v = np.asarray(v, dtype=np.float64)\n    H = np.asarray(H, dtype=np.float64)\n\n    # Calculate local gravity wave speed c = sqrt(g*H)\n    # Add a small epsilon to H to avoid sqrt(0) if H could be zero, though not in test cases.\n    c = np.sqrt(g * H + 1e-12)\n\n    # Reshape 1D grid spacing arrays to be broadcastable with 2D field arrays.\n    # dx shape: (Nx,) - (1, Nx)\n    # dy shape: (Ny,) - (Ny, 1)\n    # u, v, H, c shapes: (Ny, Nx)\n    dx_broadcast = dx.reshape(1, -1)\n    dy_broadcast = dy.reshape(-1, 1)\n\n    # Calculate the terms in the CFL condition denominator for each cell\n    # term_x = (|u| + c) / dx\n    term_x = (np.abs(u) + c) / dx_broadcast\n    \n    # term_y = (|v| + c) / dy\n    term_y = (np.abs(v) + c) / dy_broadcast\n\n    # The local inverse time step limit is the sum of the terms.\n    local_dt_limit_inv = term_x + term_y\n\n    # The global time step limit is the inverse of the maximum of the local inverse limits.\n    # This is equivalent to finding the minimum of all local dt limits.\n    # Handle the case where the denominator might be zero (no motion, infinite grid spacing),\n    -    # although this is physically unlikely in this problem's context.\n    max_inv_dt = np.max(local_dt_limit_inv)\n    if max_inv_dt = 1e-12:\n        # Effectively infinite time step limit, return a large number or handle as error.\n        # For this problem, we can assume this won't happen.\n         dt_limit = np.inf\n    else:\n         dt_limit = 1.0 / max_inv_dt\n\n    # Apply the safety factor\n    dt = sigma * dt_limit\n    \n    return round(dt, 6)\n\ndef solve():\n    \"\"\"\n    Defines the test cases and computes the results.\n    \"\"\"\n    test_cases = [\n        {\n            # Case 1: Happy path (uniform grid and deep ocean)\n            \"sigma\": 0.8,\n            \"dx\": [10000.0, 10000.0, 10000.0, 10000.0],\n            \"dy\": [10000.0, 10000.0, 10000.0],\n            \"u\": [[0.5, 0.5, 0.5, 0.5], [0.5, 0.5, 0.5, 0.5], [0.5, 0.5, 0.5, 0.5]],\n            \"v\": [[0.2, 0.2, 0.2, 0.2], [0.2, 0.2, 0.2, 0.2], [0.2, 0.2, 0.2, 0.2]],\n            \"H\": [[4000.0, 4000.0, 4000.0, 4000.0], [4000.0, 4000.0, 4000.0, 4000.0], [4000.0, 4000.0, 4000.0, 4000.0]],\n        },\n        {\n            # Case 2: Boundary-limited by smallest cells\n            \"sigma\": 0.9,\n            \"dx\": [2000.0, 5000.0, 10000.0],\n            \"dy\": [10000.0, 10000.0],\n            \"u\": [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0]],\n            \"v\": [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0]],\n            \"H\": [[4000.0, 4000.0, 4000.0], [4000.0, 4000.0, 4000.0]],\n        },\n        {\n            # Case 3: Edge case (anisotropic, strong currents, steep depth)\n            \"sigma\": 0.7,\n            \"dx\": [1500.0, 3000.0],\n            \"dy\": [3000.0, 1500.0],\n            \"u\": [[1.2, 0.4], [0.8, -0.6]],\n            \"v\": [[-0.2, 1.0], [0.5, -1.5]],\n            \"H\": [[100.0, 50.0], [200.0, 4000.0]],\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        dt = compute_dt(case[\"sigma\"], case[\"dx\"], case[\"dy\"], case[\"u\"], case[\"v\"], case[\"H\"])\n        results.append(dt)\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}