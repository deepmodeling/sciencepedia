{
    "hands_on_practices": [
        {
            "introduction": "我们实践之旅的第一步是回到基础。在选择数值方案时，理解其固有的准确性至关重要。这个练习通过对一个简单的二次函数应用三种典型的有限差分格式——前向、后向和中心差分——来直接计算它们的截断误差。通过这个基础分析，你将亲手揭示为什么中心差分格式在许多情况下更受青睐，并理解“阶”精度在实践中的具体含义。",
            "id": "3793438",
            "problem": "在计算海洋学中用于基准测试数值微分算法的一维理想化横断面上，考虑一个在均匀网格 $x_{i} = x_{0} + i\\,h$ （其中网格间距 $h > 0$ 为常数）上采样的解析、无量纲速度剖面 $u(x) = x^{2}$。你感兴趣的是使用三种典型的有限差分格式在内部网格点 $x_{i}$ 处近似空间导数 $u^{\\prime}(x)$：在 $x_{i}$ 处的单边前向差分、在 $x_{i}$ 处的单边后向差分以及在 $x_{i}$ 处的中心差分。\n\n从第一性原理出发，即导数的定义 $u^{\\prime}(x) = \\lim_{h \\to 0} \\frac{u(x+h) - u(x)}{h}$ 和 $u(x)$ 在 $x_{i}$ 附近的泰勒级数展开，推导这三种格式应用于 $u(x) = x^{2}$ 时在 $x_{i}$ 处的截断误差。将近似值 $\\mathcal{D}u(x_{i})$ 的截断误差定义为 $\\mathcal{T}(x_{i};h) = \\mathcal{D}u(x_{i}) - u^{\\prime}(x_{i})$。将每个截断误差表达式完全简化为 $h$ 和常数的项，并确定哪种格式对于此剖面是精确的，以及对于非零的 $h$ 哪种格式最接近精确值。\n\n将你的最终答案以一个行矩阵的形式报告，该矩阵按顺序包含在 $x_{i}$ 处计算的前向、后向和中心差分格式的截断误差，并以 $h$ 的函数闭式形式表示。不需要四舍五入，也不需要单位。",
            "solution": "该问题是有效的，因为它具有科学依据、问题明确且客观。它提出了一个数值分析中的标准练习，特别是关于将有限差分格式应用于简单多项式函数的截断误差的推导。所有必要信息均已提供，问题没有矛盾或含糊之处。\n\n我们首先定义给定的函数及其导数，这是分析所必需的。速度剖面由函数 $u(x) = x^{2}$ 给出。\n前几阶导数是：\n- 一阶导数：$u^{\\prime}(x) = \\frac{d}{dx}(x^{2}) = 2x$\n- 二阶导数：$u^{\\prime\\prime}(x) = \\frac{d}{dx}(2x) = 2$\n- 三阶导数：$u^{\\prime\\prime\\prime}(x) = \\frac{d}{dx}(2) = 0$\n对于此函数，三阶及更高阶的导数均为零。因此，在网格点 $x_{i}$ 处导数的精确值为 $u^{\\prime}(x_{i}) = 2x_{i}$。\n\n截断误差定义为 $\\mathcal{T}(x_{i};h) = \\mathcal{D}u(x_{i}) - u^{\\prime}(x_{i})$，其中 $\\mathcal{D}u(x_{i})$ 表示导数的有限差分近似。我们现在将为三种指定的格式分别推导这个误差。\n\n**1. 前向差分格式**\n\n$u^{\\prime}(x_{i})$ 的单边前向差分近似由下式给出：\n$$\n\\mathcal{D}_{f}u(x_{i}) = \\frac{u(x_{i}+h) - u(x_{i})}{h}\n$$\n网格点的定义使得 $x_{i+1} = x_i + h$，因此 $u(x_i+h)$ 是函数在下一个网格点的值。将此公式应用于函数 $u(x) = x^{2}$：\n$$\n\\mathcal{D}_{f}u(x_{i}) = \\frac{(x_{i}+h)^{2} - x_{i}^{2}}{h}\n$$\n展开分子：\n$$\n\\mathcal{D}_{f}u(x_{i}) = \\frac{(x_{i}^{2} + 2x_{i}h + h^{2}) - x_{i}^{2}}{h} = \\frac{2x_{i}h + h^{2}}{h}\n$$\n通过提出因子 $h$ 进行简化（因为 $h > 0$）：\n$$\n\\mathcal{D}_{f}u(x_{i}) = 2x_{i} + h\n$$\n前向差分格式的截断误差 $\\mathcal{T}_{f}$ 是此近似值与精确导数 $u^{\\prime}(x_{i}) = 2x_{i}$ 之间的差：\n$$\n\\mathcal{T}_{f}(x_{i};h) = \\mathcal{D}_{f}u(x_{i}) - u^{\\prime}(x_{i}) = (2x_{i} + h) - 2x_{i} = h\n$$\n因此，前向差分格式的截断误差恰好是 $h$。\n\n**2. 后向差分格式**\n\n$u^{\\prime}(x_{i})$ 的单边后向差分近似由下式给出：\n$$\n\\mathcal{D}_{b}u(x_{i}) = \\frac{u(x_{i}) - u(x_{i}-h)}{h}\n$$\n网格点 $x_{i-1} = x_i - h$。将此公式应用于 $u(x) = x^{2}$：\n$$\n\\mathcal{D}_{b}u(x_{i}) = \\frac{x_{i}^{2} - (x_{i}-h)^{2}}{h}\n$$\n展开分子：\n$$\n\\mathcal{D}_{b}u(x_{i}) = \\frac{x_{i}^{2} - (x_{i}^{2} - 2x_{i}h + h^{2})}{h} = \\frac{2x_{i}h - h^{2}}{h}\n$$\n通过提出因子 $h$ 进行简化：\n$$\n\\mathcal{D}_{b}u(x_{i}) = 2x_{i} - h\n$$\n后向差分格式的截断误差 $\\mathcal{T}_{b}$ 是：\n$$\n\\mathcal{T}_{b}(x_{i};h) = \\mathcal{D}_{b}u(x_{i}) - u^{\\prime}(x_{i}) = (2x_{i} - h) - 2x_{i} = -h\n$$\n因此，后向差分格式的截断误差恰好是 $-h$。\n\n**3. 中心差分格式**\n\n$u^{\\prime}(x_{i})$ 的中心差分近似由下式给出：\n$$\n\\mathcal{D}_{c}u(x_{i}) = \\frac{u(x_{i}+h) - u(x_{i}-h)}{2h}\n$$\n将此公式应用于 $u(x) = x^{2}$：\n$$\n\\mathcal{D}_{c}u(x_{i}) = \\frac{(x_{i}+h)^{2} - (x_{i}-h)^{2}}{2h}\n$$\n展开分子中的各项：\n$$\n\\mathcal{D}_{c}u(x_{i}) = \\frac{(x_{i}^{2} + 2x_{i}h + h^{2}) - (x_{i}^{2} - 2x_{i}h + h^{2})}{2h} = \\frac{4x_{i}h}{2h}\n$$\n简化表达式：\n$$\n\\mathcal{D}_{c}u(x_{i}) = 2x_{i}\n$$\n中心差分格式的截断误差 $\\mathcal{T}_{c}$ 是：\n$$\n\\mathcal{T}_{c}(x_{i};h) = \\mathcal{D}_{c}u(x_{i}) - u^{\\prime}(x_{i}) = 2x_{i} - 2x_{i} = 0\n$$\n因此，中心差分格式的截断误差恰好是 $0$。\n\n这个结果也可以从中心差分误差的一般泰勒级数推导中理解。对于一般函数 $u(x)$，主导误差项与 $u^{\\prime\\prime\\prime}(x_{i})$ 成正比：\n$$\n\\mathcal{T}_{c}(x_{i};h) = \\frac{h^{2}}{6}u^{\\prime\\prime\\prime}(x_{i}) + \\mathcal{O}(h^{4})\n$$\n由于我们的函数是 $u(x) = x^{2}$，我们有对于所有 $x$ 都有 $u^{\\prime\\prime\\prime}(x) = 0$，因此主导误差项消失了，误差展开中的所有更高阶项也同样消失。这证实了该格式对于任何二次多项式都是精确的这一结果。\n\n**关于格式准确性的结论**\n\n基于推导出的截断误差：\n- 前向差分误差：$\\mathcal{T}_{f} = h$\n- 后向差分误差：$\\mathcal{T}_{b} = -h$\n- 中心差分误差：$\\mathcal{T}_{c} = 0$\n\n对于剖面 $u(x)=x^2$ 而言，精确的格式是**中心差分格式**，因为其截断误差恒等于零。因此，对于任何非零网格间距 $h$，中心差分格式也是**最接近精确**的；其近似值等于真实导数，而前向和后向格式的误差大小为 $|h|$。\n\n最终答案是前向、后向和中心差分格式的截断误差集合，分别以行矩阵的形式呈现。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\nh  -h  0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "真实的海洋模型很少依赖完全均匀的网格。为了有效解析如沿岸边界层等小尺度特征，我们常常使用非均匀网格。这个练习将我们从均匀网格的理想情况带入更现实的场景，要求你在非均匀网格上推导一个高阶的单边差分格式。掌握这项技能对于开发和理解能够精确模拟近岸动力学的数值模型至关重要。",
            "id": "3793418",
            "problem": "在一个海岸上升流模拟中，横岸坐标 $x$ 在靠近西部边界（海岸）处的一个非均匀、单侧网格上进行离散化，以解析一个薄边界层。设前三个网格点为 $x_0$、$x_1 = x_0 + h_0$ 和 $x_2 = x_0 + h_0 + h_1$，其中 $h_0 > 0$ 和 $h_1 > 0$ 是局部间距且 $h_1 \\neq h_0$。一个标量示踪剂 $u(x)$ 足够光滑，可以在 $x_0$ 附近进行泰勒展开。由于在 $x_0$ 处无法使用中心差分格式，因此必须使用单侧公式。\n\n仅使用基本定义和泰勒级数，完成以下任务：\n- 使用 $u(x_0)$ 和 $u(x_1)$ 的值，推导一个关于 $u^{\\prime}(x_0)$ 的一阶精确单侧近似，并确定其以 $h_0$ 和在 $x_0$ 处求值的 $u$ 的导数表示的主截断误差项。\n- 在这个非均匀网格上，使用 $u(x_0)$、$u(x_1)$ 和 $u(x_2)$ 的值，推导一个关于 $u^{\\prime}(x_0)$ 的二阶精确单侧近似，并确定其以 $h_0$、$h_1$ 和在 $x_0$ 处求值的 $u$ 的导数表示的主截断误差项。\n\n最后，报告你的二阶单侧近似的主截断误差中乘以 $u^{(3)}(x_0)$ 的系数的单一闭式表达式。无需进行数值计算或四舍五入。最终报告的表达式必须仅用 $h_0$ 和 $h_1$ 来简化表示。",
            "solution": "对用户提供的问题陈述进行验证。\n\n### 第 1 步：提取已知条件\n- **离散化**：靠近边界的横岸坐标 $x$ 的非均匀、单侧网格。\n- **网格点**：$x_0$、$x_1 = x_0 + h_0$ 和 $x_2 = x_0 + h_0 + h_1$。\n- **网格间距**：$h_0 > 0$ 和 $h_1 > 0$，且 $h_1 \\neq h_0$。\n- **函数**：假设标量示踪剂 $u(x)$ 足够光滑，可在 $x_0$ 附近进行泰勒级数展开。\n- **任务 1**：使用 $u(x_0)$ 和 $u(x_1)$ 推导 $u^{\\prime}(x_0)$ 的一阶精确单侧近似，并求其主截断误差。\n- **任务 2**：使用 $u(x_0)$、$u(x_1)$ 和 $u(x_2)$ 推导 $u^{\\prime}(x_0)$ 的二阶精确单侧近似，并求其主截断误差。\n- **最终交付**：二阶近似的主截断误差中 $u^{(3)}(x_0)$ 系数的单一闭式表达式。\n\n### 第 2 步：使用提取的已知条件进行验证\n- **科学基础**：该问题在根本上是合理的。它是数值分析和计算科学中的一个标准课题，涉及使用泰勒级数推导有限差分格式。这是离散化微分方程的核心技术，计算海洋学的背景是一个有效的应用领域。\n- **适定性**：该问题是适定的。它提供了足够的信息（要使用的网格点和所需的精度阶数），以唯一确定有限差分系数和相应的截断误差。\n- **客观性**：该问题以精确、客观的数学语言陈述。\n- **结论**：该问题没有科学缺陷、歧义或矛盾。它是应用数学中一个有效、可解的问题。\n\n### 第 3 步：结论与行动\n问题有效。现在开始求解过程。\n\n解答按要求分为两部分：推导一阶格式和推导二阶格式，然后确定所要求的特定系数。为清晰起见，我们使用记号 $u_i = u(x_i)$ 和 $u_0^{(k)} = u^{(k)}(x_0)$。\n\n**第 1 部分：一阶精确近似**\n\n为了使用 $u_0$ 和 $u_1$ 推导 $u'(x_0)$ 的近似，我们从 $u(x)$ 在 $x_1$ 处围绕 $x_0$ 的泰勒级数展开开始：\n$$u(x_1) = u(x_0 + h_0) = u(x_0) + h_0 u'(x_0) + \\frac{h_0^2}{2!} u''(x_0) + O(h_0^3)$$\n重新整理此方程以求解 $u'(x_0)$，得到：\n$$h_0 u'(x_0) = u(x_1) - u(x_0) - \\frac{h_0^2}{2} u''(x_0) - O(h_0^3)$$\n$$u'(x_0) = \\frac{u(x_1) - u(x_0)}{h_0} - \\frac{h_0}{2} u''(x_0) - O(h_0^2)$$\n$u'(x_0)$ 的一阶单侧近似（我们记为 $D_1(u)$）是右侧的第一项：\n$$D_1(u) = \\frac{u_1 - u_0}{h_0}$$\n这是标准的前向差分公式。截断误差 $T_1$ 定义为近似值减去精确值，即 $T_1 = D_1(u) - u'(x_0)$。从重新整理的泰勒展开式中，我们发现：\n$$T_1 = \\frac{h_0}{2} u''(x_0) + O(h_0^2)$$\n因此，主截断误差项为 $\\frac{h_0}{2} u''(x_0)$，并且该近似是一阶精确的，因为误差与 $h_0^1$ 成正比。\n\n**第 2 部分：二阶精确近似**\n\n我们寻求 $u_0$、$u_1$ 和 $u_2$ 的线性组合来近似 $u'(x_0)$：\n$$u'(x_0) \\approx D_2(u) = A u_0 + B u_1 + C u_2$$\n为了确定系数 $A$、$B$ 和 $C$，我们将 $u_1$ 和 $u_2$ 在 $x_0$ 附近展开为泰勒级数：\n$$u_1 = u(x_0 + h_0) = u_0 + h_0 u'_0 + \\frac{h_0^2}{2} u''_0 + \\frac{h_0^3}{6} u'''_0 + O(h_0^4)$$\n$$u_2 = u(x_0 + h_0 + h_1) = u_0 + (h_0 + h_1)u'_0 + \\frac{(h_0 + h_1)^2}{2} u''_0 + \\frac{(h_0 + h_1)^3}{6} u'''_0 + O((h_0+h_1)^4)$$\n将这些展开式代入 $D_2(u)$ 的表达式中，得到：\n$$D_2(u) = A u_0 + B\\left(u_0 + h_0 u'_0 + \\frac{h_0^2}{2} u''_0 + \\dots\\right) + C\\left(u_0 + (h_0 + h_1)u'_0 + \\frac{(h_0 + h_1)^2}{2} u''_0 + \\dots\\right)$$\n按 $u$ 在 $x_0$ 处的导数整理各项：\n$$D_2(u) = (A+B+C)u_0 + (B h_0 + C(h_0+h_1))u'_0 + \\left(B \\frac{h_0^2}{2} + C \\frac{(h_0+h_1)^2}{2}\\right)u''_0 + \\left(B \\frac{h_0^3}{6} + C \\frac{(h_0+h_1)^3}{6}\\right)u'''_0 + \\dots$$\n为使 $D_2(u)$ 成为 $u'_0$ 的二阶精确近似，系数必须满足以下方程组：\n1. $u_0$ 的系数：$A+B+C = 0$\n2. $u'_0$ 的系数：$B h_0 + C(h_0+h_1) = 1$\n3. $u''_0$ 的系数：$B h_0^2 + C(h_0+h_1)^2 = 0$\n\n从方程（3）中，我们将 $B$ 用 $C$ 表示：\n$$B = -C \\frac{(h_0+h_1)^2}{h_0^2}$$\n将此代入方程（2）：\n$$\\left(-C \\frac{(h_0+h_1)^2}{h_0^2}\\right) h_0 + C(h_0+h_1) = 1$$\n$$-C \\frac{(h_0+h_1)^2}{h_0} + C(h_0+h_1) = 1$$\n$$C(h_0+h_1) \\left(1 - \\frac{h_0+h_1}{h_0}\\right) = 1$$\n$$C(h_0+h_1) \\left(\\frac{h_0 - h_0 - h_1}{h_0}\\right) = 1$$\n$$C(h_0+h_1) \\left(\\frac{-h_1}{h_0}\\right) = 1 \\implies C = -\\frac{h_0}{h_1(h_0+h_1)}$$\n现在，我们求 $B$：\n$$B = -\\left(-\\frac{h_0}{h_1(h_0+h_1)}\\right) \\frac{(h_0+h_1)^2}{h_0^2} = \\frac{h_0+h_1}{h_0 h_1}$$\n最后，从方程（1）中，我们求 $A$：\n$$A = -B - C = -\\frac{h_0+h_1}{h_0 h_1} + \\frac{h_0}{h_1(h_0+h_1)}$$\n$$A = \\frac{-(h_0+h_1)^2 + h_0^2}{h_0 h_1 (h_0+h_1)} = \\frac{-(h_0^2 + 2h_0 h_1 + h_1^2) + h_0^2}{h_0 h_1 (h_0+h_1)} = \\frac{-2h_0 h_1 - h_1^2}{h_0 h_1 (h_0+h_1)}$$\n$$A = \\frac{-h_1(2h_0 + h_1)}{h_0 h_1 (h_0+h_1)} = -\\frac{2h_0 + h_1}{h_0(h_0+h_1)}$$\n二阶近似为：\n$$D_2(u) = -\\frac{2h_0 + h_1}{h_0(h_0+h_1)} u_0 + \\frac{h_0+h_1}{h_0 h_1} u_1 - \\frac{h_0}{h_1(h_0+h_1)} u_2$$\n截断误差为 $T_2 = D_2(u) - u'_0$。根据我们的设定，含有 $u_0$、$u'_0$ 和 $u''_0$ 的项按要求为零或一，所以误差的主项来自 $u'''_0$ 项：\n$$T_2 = \\left(B \\frac{h_0^3}{6} + C \\frac{(h_0+h_1)^3}{6}\\right)u'''_0 + O(h^3)$$\n其中 $h$ 代表网格间距 $h_0$ 和 $h_1$ 的尺度。问题要求这个主误差项中 $u^{(3)}(x_0)$ 的系数。设该系数为 $K_{err}$：\n$$K_{err} = B \\frac{h_0^3}{6} + C \\frac{(h_0+h_1)^3}{6}$$\n代入 $B$ 和 $C$ 的表达式：\n$$K_{err} = \\frac{1}{6} \\left[ \\left(\\frac{h_0+h_1}{h_0 h_1}\\right) h_0^3 + \\left(-\\frac{h_0}{h_1(h_0+h_1)}\\right) (h_0+h_1)^3 \\right]$$\n$$K_{err} = \\frac{1}{6} \\left[ \\frac{(h_0+h_1)h_0^2}{h_1} - \\frac{h_0(h_0+h_1)^2}{h_1} \\right]$$\n提取公因式：\n$$K_{err} = \\frac{h_0(h_0+h_1)}{6h_1} \\left[ h_0 - (h_0+h_1) \\right]$$\n$$K_{err} = \\frac{h_0(h_0+h_1)}{6h_1} [-h_1]$$\n$$K_{err} = -\\frac{h_0(h_0+h_1)}{6}$$\n这就是所求的系数。",
            "answer": "$$\\boxed{-\\frac{h_0(h_0+h_1)}{6}}$$"
        },
        {
            "introduction": "理论分析最终必须转化为能够解决实际问题的代码。这个综合性练习旨在连接理论与实践，指导你将一个完整的偏微分方程——扩散方程——进行离散化并编程实现。你不仅需要应用二阶中心差分来处理空间导数，还要学习如何结合隐式时间步进并正确地施加狄利克雷边界条件，这是构建任何稳健的计算海洋学模型的核心环节。",
            "id": "3793439",
            "problem": "考虑海洋学中由菲克扩散控制的守恒示踪剂的一维垂直扩散。示踪剂浓度场表示为 $C(x,t)$，其中 $x \\in [0,L]$ 且 $t \\ge 0$。控制定律结合了菲克定律和质量守恒：扩散通量 $J$ 满足 $J = -\\kappa \\, \\partial C / \\partial x$，局部守恒得到 $\\partial C / \\partial t = -\\partial J / \\partial x$。结果为扩散方程\n$$\n\\frac{\\partial C}{\\partial t} = \\kappa \\frac{\\partial^2 C}{\\partial x^2},\n$$\n其中 $\\kappa$ 是分子或湍流扩散率，单位为 $\\mathrm{m}^2/\\mathrm{s}$，$x$ 的单位为 $\\mathrm{m}$。\n\n你需要使用均匀网格上的中心二阶差分在空间上离散化该方程，并使用隐式后向欧拉格式在时间上进行离散化。设空间网格有 $N$ 个点，均匀间距为 $\\Delta x = L/(N-1)$，位置在 $x_i = i \\, \\Delta x$，其中 $i \\in \\{0,1,\\dots,N-1\\}$。设时间步长为 $\\Delta t$，单位为 $\\mathrm{s}$。两端的狄利克雷边界条件为给定值 $C(0,t) = C_L(t)$ 和 $C(L,t) = C_R(t)$，这些条件将通过修改近边界模板和右端项，在新的时间层直接施加于离散系统中，而不引入虚拟点。\n\n从上述基本定义出发，推导内部网格点 $\\{x_i\\}_{i=1}^{N-2}$ 处的离散隐式格式，该格式对在新的时间层上计算的二阶导数使用中心二阶差分近似，对时间导数使用后向欧拉近似：\n$$\n\\frac{C_i^{n+1} - C_i^n}{\\Delta t} = \\kappa \\frac{C_{i-1}^{n+1} - 2 C_i^{n+1} + C_{i+1}^{n+1}}{\\Delta x^2},\n$$\n其中 $C_i^n$ 表示对 $C(x_i, t^n)$ 的近似，且 $t^{n+1} = t^n + \\Delta t$。展示如何通过在第一个和最后一个内部方程的右端项中添加项，来为内部未知量 $\\{C_i^{n+1}\\}_{i=1}^{N-2}$ 修改代数系统，从而施加狄利克雷条件 $C_0^{n+1} = C_L^{n+1}$ 和 $C_{N-1}^{n+1} = C_R^{n+1}$。清楚地解释哪些模板系数和右端项条目受到了影响以及如何影响。\n\n在一个程序中实现所推导的格式，该程序：\n- 为内部未知量构建三对角系统，使用中心二阶差分和后向欧拉时间格式。\n- 如推导所示，通过修改近边界模板和右端项，在新的时间层 $t^{n+1}$ 施加狄利克雷边界条件。\n- 在给定 $C^n$ 的情况下求解 $C^{n+1}$，返回包括边界值的完整向量。\n\n所有物理量必须使用国际单位制：$L$ 单位为 $\\mathrm{m}$，$\\Delta x$ 单位为 $\\mathrm{m}$，$\\Delta t$ 单位为 $\\mathrm{s}$，$\\kappa$ 单位为 $\\mathrm{m}^2/\\mathrm{s}$，$C$ 单位为 $\\mathrm{kg}/\\mathrm{m}^3$。此问题不涉及角度。\n\n使用以下测试套件来验证你的实现，并为每个测试计算所要求的标量。你的程序必须将结果组合成指定格式的单行。网格间距 $\\Delta x$ 应根据给定的 $L$ 和 $N$ 计算，比率 $r = \\kappa \\Delta t / \\Delta x^2$ 应用于构建三对角系数。\n\n测试套件：\n- 案例 A（稳态一致性，理想情况）：$L = 10{,}000\\,\\mathrm{m}$，$N = 51$，$\\kappa = 10^{-4}\\,\\mathrm{m}^2/\\mathrm{s}$，$\\Delta t = 3{,}600\\,\\mathrm{s}$，$C_L^n = 35\\,\\mathrm{kg}/\\mathrm{m}^3$，$C_R^n = 35\\,\\mathrm{kg}/\\mathrm{m}^3$，$C_L^{n+1} = 35\\,\\mathrm{kg}/\\mathrm{m}^3$，$C_R^{n+1} = 35\\,\\mathrm{kg}/\\mathrm{m}^3$，且对于所有内部索引 $i$，$C_i^n = 35\\,\\mathrm{kg}/\\mathrm{m}^3$。计算 $C^{n+1}$ 内部值与常数 $35\\,\\mathrm{kg}/\\mathrm{m}^3$ 的最大绝对偏差，并以 $\\mathrm{kg}/\\mathrm{m}^3$ 为单位返回一个浮点数。\n- 案例 B（梯度形成）：$L = 10{,}000\\,\\mathrm{m}$，$N = 51$，$\\kappa = 10^{-4}\\,\\mathrm{m}^2/\\mathrm{s}$，$\\Delta t = 3{,}600\\,\\mathrm{s}$，$C_L^n = 10\\,\\mathrm{kg}/\\mathrm{m}^3$，$C_R^n = 0\\,\\mathrm{kg}/\\mathrm{m}^3$，$C_L^{n+1} = 10\\,\\mathrm{kg}/\\mathrm{m}^3$，$C_R^{n+1} = 0\\,\\mathrm{kg}/\\mathrm{m}^3$，且对于所有内部索引 $i$，$C_i^n = 0\\,\\mathrm{kg}/\\mathrm{m}^3$。计算并返回中点网格索引 $i = \\lfloor N/2 \\rfloor$ 处的 $C^{n+1}$ 值，以 $\\mathrm{kg}/\\mathrm{m}^3$ 为单位返回一个浮点数。\n- 案例 C（最小内部，边界影响）：$L = 100\\,\\mathrm{m}$，$N = 3$，$\\kappa = 10^{-4}\\,\\mathrm{m}^2/\\mathrm{s}$，$\\Delta t = 1{,}000\\,\\mathrm{s}$，$C_L^n = 5\\,\\mathrm{kg}/\\mathrm{m}^3$，$C_R^n = 0\\,\\mathrm{kg}/\\mathrm{m}^3$，$C_L^{n+1} = 5\\,\\mathrm{kg}/\\mathrm{m}^3$，$C_R^{n+1} = 0\\,\\mathrm{kg}/\\mathrm{m}^3$，以及单个内部值 $C_1^n = 1\\,\\mathrm{kg}/\\mathrm{m}^3$。计算并返回单个内部值 $C_1^{n+1}$，以 $\\mathrm{kg}/\\mathrm{m}^3$ 为单位返回一个浮点数。\n- 案例 D（新时间层的时变边界）：$L = 10{,}000\\,\\mathrm{m}$，$N = 51$，$\\kappa = 10^{-4}\\,\\mathrm{m}^2/\\mathrm{s}$，$\\Delta t = 3{,}600\\,\\mathrm{s}$，$C_L^n = 0\\,\\mathrm{kg}/\\mathrm{m}^3$，$C_R^n = 0\\,\\mathrm{kg}/\\mathrm{m}^3$，$C_L^{n+1} = 2\\,\\mathrm{kg}/\\mathrm{m}^3$，$C_R^{n+1} = 0\\,\\mathrm{kg}/\\mathrm{m}^3$，且对于所有内部索引 $i$，$C_i^n = 0\\,\\mathrm{kg}/\\mathrm{m}^3$。计算并返回第一个内部值 $C_1^{n+1}$（与左边界相邻），以 $\\mathrm{kg}/\\mathrm{m}^3$ 为单位返回一个浮点数。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序与上述案例相同。例如，输出格式必须为 $[\\text{result}_A,\\text{result}_B,\\text{result}_C,\\text{result}_D]$，每个条目都是一个以 $\\mathrm{kg}/\\mathrm{m}^3$ 为单位的浮点数。",
            "solution": "目标是推导并实现一个在空间上使用中心二阶差分、在时间上使用后向欧拉的离散隐式扩散格式，并通过修改近边界模板和右端项来施加新时间层上的狄利克雷边界条件。\n\n我们从基本定律开始。菲克定律给出通量 $J = -\\kappa \\, \\partial C / \\partial x$。一维质量守恒是 $\\partial C / \\partial t + \\partial J / \\partial x = 0$。代入菲克定律得到\n$$\n\\frac{\\partial C}{\\partial t} = \\kappa \\frac{\\partial^2 C}{\\partial x^2},\n$$\n其中 $C$ 的单位是 $\\mathrm{kg}/\\mathrm{m}^3$，$x$ 的单位是 $\\mathrm{m}$，$t$ 的单位是 $\\mathrm{s}$，$\\kappa$ 的单位是 $\\mathrm{m}^2/\\mathrm{s}$。\n\n我们设定一个均匀网格 $x_i = i \\Delta x$，其中 $i \\in \\{0,1,\\dots,N-1\\}$，$\\Delta x = L / (N - 1)$。在离散时间 $t^n$ 上，定义 $C_i^n \\approx C(x_i, t^n)$，且 $t^{n+1} = t^n + \\Delta t$。\n\n在内部点 $i \\in \\{1,2,\\dots,N-2\\}$，用后向欧拉近似时间导数，用在新的时间层上计算的中心二阶差分近似空间二阶导数：\n$$\n\\frac{C_i^{n+1} - C_i^n}{\\Delta t} = \\kappa \\frac{C_{i-1}^{n+1} - 2 C_i^{n+1} + C_{i+1}^{n+1}}{\\Delta x^2}.\n$$\n引入无量纲比率 $r = \\kappa \\Delta t / \\Delta x^2$，两边同乘以 $\\Delta t$ 并重新整理，得到关于内部未知量的三对角线性系统，\n$$\n(1 + 2 r) \\, C_i^{n+1} - r \\, C_{i-1}^{n+1} - r \\, C_{i+1}^{n+1} = C_i^n, \\quad i = 1,2,\\dots,N-2.\n$$\n\n施加狄利克雷边界条件是通过将新时间层上的边界值直接代入离散方程中任何出现边界节点的地方来处理的。边界条件是\n$$\nC_0^{n+1} = C_L^{n+1}, \\qquad C_{N-1}^{n+1} = C_R^{n+1}.\n$$\n对于 $i=1$ 处的第一个内部方程，模板引用了 $C_0^{n+1}$，这不是一个未知数，而是由狄利克雷条件给定的。将其贡献移到右端项：\n$$\n(1 + 2 r) \\, C_1^{n+1} - r \\, C_{2}^{n+1} = C_1^n + r \\, C_0^{n+1} = C_1^n + r \\, C_L^{n+1}.\n$$\n对于 $i=N-2$ 处的最后一个内部方程，模板引用了 $C_{N-1}^{n+1}$，这是给定的。将其贡献移到右端项：\n$$\n(1 + 2 r) \\, C_{N-2}^{n+1} - r \\, C_{N-3}^{n+1} = C_{N-2}^n + r \\, C_{N-1}^{n+1} = C_{N-2}^n + r \\, C_R^{n+1}.\n$$\n对于严格内部的方程 $i \\in \\{2,3,\\dots,N-3\\}$，标准的中心二阶差分模板保持不变：\n$$\n(1 + 2 r) \\, C_i^{n+1} - r \\, C_{i-1}^{n+1} - r \\, C_{i+1}^{n+1} = C_i^n.\n$$\n\n因此，关于内部未知向量 $\\mathbf{u}^{n+1} = [C_1^{n+1}, C_2^{n+1}, \\dots, C_{N-2}^{n+1}]^\\top$ 的代数系统是具有常系数的三对角系统：\n- 主对角线元素等于 $1 + 2 r$。\n- 次对角线和超对角线元素等于 $-r$。\n\n右端向量 $\\mathbf{b}$ 的构造如下：\n- 对于条目 $i \\in \\{2,3,\\dots,N-3\\}$（对应内部节点），$\\mathbf{b}_i = C_i^n$。\n- 对于第一个条目（对应 $i=1$），$\\mathbf{b}_1 = C_1^n + r \\, C_L^{n+1}$。\n- 对于最后一个条目（对应 $i=N-2$），$\\mathbf{b}_{N-2} = C_{N-2}^n + r \\, C_R^{n+1}$。\n\n在求解 $\\mathbf{A} \\, \\mathbf{u}^{n+1} = \\mathbf{b}$ 之后，通过将已知的边界值 $C_0^{n+1} = C_L^{n+1}$ 和 $C_{N-1}^{n+1} = C_R^{n+1}$ 与已解出的内部项组合，来组装完整的向量 $[C_0^{n+1}, C_1^{n+1}, \\dots, C_{N-2}^{n+1}, C_{N-1}^{n+1}]^\\top$。\n\n算法设计：\n- 计算 $\\Delta x = L / (N - 1)$ 和 $r = \\kappa \\Delta t / \\Delta x^2$。\n- 构建三对角矩阵 $\\mathbf{A} \\in \\mathbb{R}^{(N-2) \\times (N-2)}$，主对角线为 $1 + 2 r$，次对角线为 $-r$。\n- 使用旧时间层的内部值以及在 $i=1$ 和 $i=N-2$ 处的边界贡献构建右端项 $\\mathbf{b} \\in \\mathbb{R}^{N-2}$。\n- 使用直接求解器求解 $\\mathbf{u}^{n+1} = \\mathbf{A}^{-1} \\mathbf{b}$。\n- 组装包括边界在内的完整 $C^{n+1}$。\n\n测试套件原理：\n- 案例 A 使用恒定的初始值和边界值。作用于常数场的扩散算子为零，而后向欧拉与齐次二阶差分项会保持常数。精确离散解为对所有 $i$ 都有 $C_i^{n+1} = 35$，因此最大绝对偏差应为 $0$（在浮点舍入误差范围内）。\n- 案例 B 从零内部值和非零左边界开始。由于在第一个内部方程中添加了源项 $r \\, C_L^{n+1}$，隐式步长会产生一个朝向左边界的非零内部剖面；中点值是该剖面的一个有意义的标量诊断量。\n- 案例 C 中 $N=3$，因此只有一个由 $i=1$ 索引的内部节点。其方程简化为\n$$\n(1 + 2 r) \\, C_1^{n+1} = C_1^n + r \\, C_L^{n+1} + r \\, C_R^{n+1},\n$$\n因此\n$$\nC_1^{n+1} = \\frac{C_1^n + r \\, C_L^{n+1} + r \\, C_R^{n+1}}{1 + 2 r}.\n$$\n这测试了在最小内部系统中近边界模板的修改。\n- 案例 D 使用一个时变左边界，其中 $C_L^{n+1}$ 非零而 $C_L^n$ 为零，这表明隐式格式通过向第一个内部方程添加 $r \\, C_L^{n+1}$ 来施加新时间层的边界条件，从而产生一个非零的第一个内部值 $C_1^{n+1}$。\n\n程序实现了针对指定案例的该格式，并以方括号括起、逗号分隔的四个以 $\\mathrm{kg}/\\mathrm{m}^3$ 为单位的浮点数标量结果输出单行。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef implicit_diffusion_step(L, N, kappa, dt, CL_np1, CR_np1, C_n):\n    \"\"\"\n    Perform one backward Euler time step for 1D diffusion with centered second differences.\n    Dirichlet boundary conditions at the new time level are imposed via RHS modification.\n\n    Parameters:\n        L (float): Domain length in meters.\n        N (int): Number of grid points (including boundaries).\n        kappa (float): Diffusivity in m^2/s.\n        dt (float): Time step in seconds.\n        CL_np1 (float): Left boundary value at new time level (kg/m^3).\n        CR_np1 (float): Right boundary value at new time level (kg/m^3).\n        C_n (np.ndarray): Concentration at old time level, length N (kg/m^3).\n\n    Returns:\n        C_np1 (np.ndarray): Concentration at new time level, length N (kg/m^3).\n    \"\"\"\n    # Grid spacing\n    dx = L / (N - 1)\n    # Non-dimensional ratio r\n    r = kappa * dt / (dx * dx)\n\n    if N  2:\n        raise ValueError(\"N must be at least 2.\")\n    # Handle trivial case N == 2 (no interior points)\n    if N == 2:\n        C_np1 = np.array([CL_np1, CR_np1], dtype=float)\n        return C_np1\n\n    # Number of interior points\n    M = N - 2\n\n    # Assemble tridiagonal matrix A of size MxM\n    main_diag = (1.0 + 2.0 * r) * np.ones(M, dtype=float)\n    off_diag = (-r) * np.ones(M - 1, dtype=float)\n    A = np.diag(main_diag)\n    if M > 1:\n        A += np.diag(off_diag, k=1)\n        A += np.diag(off_diag, k=-1)\n\n    # Right-hand side vector b\n    b = C_n[1:-1].astype(float).copy()\n    # Modify near-boundary RHS entries to impose Dirichlet BCs at new time level\n    b[0] += r * CL_np1\n    b[-1] += r * CR_np1\n\n    # Solve for interior unknowns at new time level\n    u_np1 = np.linalg.solve(A, b)\n\n    # Assemble full solution including boundaries\n    C_np1 = np.zeros(N, dtype=float)\n    C_np1[0] = CL_np1\n    C_np1[-1] = CR_np1\n    C_np1[1:-1] = u_np1\n    return C_np1\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Case A: Steady consistency, happy path\n    L_A = 10000.0  # m\n    N_A = 51\n    kappa_A = 1e-4  # m^2/s\n    dt_A = 3600.0  # s\n    CLn_A = 35.0  # kg/m^3\n    CRn_A = 35.0  # kg/m^3\n    CLnp1_A = 35.0  # kg/m^3\n    CRnp1_A = 35.0  # kg/m^3\n    Cn_A = np.full(N_A, 35.0, dtype=float)  # constant interior equals boundary\n    Cnp1_A = implicit_diffusion_step(L_A, N_A, kappa_A, dt_A, CLnp1_A, CRnp1_A, Cn_A)\n    max_dev_A = float(np.max(np.abs(Cnp1_A[1:-1] - 35.0)))  # kg/m^3\n\n    # Case B: Gradient formation\n    L_B = 10000.0  # m\n    N_B = 51\n    kappa_B = 1e-4  # m^2/s\n    dt_B = 3600.0  # s\n    CLn_B = 10.0  # kg/m^3\n    CRn_B = 0.0  # kg/m^3\n    CLnp1_B = 10.0  # kg/m^3\n    CRnp1_B = 0.0  # kg/m^3\n    Cn_B = np.zeros(N_B, dtype=float)  # zero interior initially\n    # Boundaries are enforced at new time level; old boundary values do not enter directly\n    Cnp1_B = implicit_diffusion_step(L_B, N_B, kappa_B, dt_B, CLnp1_B, CRnp1_B, Cn_B)\n    mid_index_B = N_B // 2\n    mid_value_B = float(Cnp1_B[mid_index_B])  # kg/m^3\n\n    # Case C: Minimal interior, boundary influence (N=3)\n    L_C = 100.0  # m\n    N_C = 3\n    kappa_C = 1e-4  # m^2/s\n    dt_C = 1000.0  # s\n    CLn_C = 5.0  # kg/m^3\n    CRn_C = 0.0  # kg/m^3\n    CLnp1_C = 5.0  # kg/m^3\n    CRnp1_C = 0.0  # kg/m^3\n    Cn_C = np.zeros(N_C, dtype=float)\n    Cn_C[1] = 1.0  # single interior value\n    Cnp1_C = implicit_diffusion_step(L_C, N_C, kappa_C, dt_C, CLnp1_C, CRnp1_C, Cn_C)\n    interior_value_C = float(Cnp1_C[1])  # kg/m^3\n\n    # Case D: Time-varying boundary at the new time\n    L_D = 10000.0  # m\n    N_D = 51\n    kappa_D = 1e-4  # m^2/s\n    dt_D = 3600.0  # s\n    CLn_D = 0.0  # kg/m^3\n    CRn_D = 0.0  # kg/m^3\n    CLnp1_D = 2.0  # kg/m^3\n    CRnp1_D = 0.0  # kg/m^3\n    Cn_D = np.zeros(N_D, dtype=float)  # zero interior initially\n    Cnp1_D = implicit_diffusion_step(L_D, N_D, kappa_D, dt_D, CLnp1_D, CRnp1_D, Cn_D)\n    first_interior_D = float(Cnp1_D[1])  # kg/m^3\n\n    results = [max_dev_A, mid_value_B, interior_value_C, first_interior_D]\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}