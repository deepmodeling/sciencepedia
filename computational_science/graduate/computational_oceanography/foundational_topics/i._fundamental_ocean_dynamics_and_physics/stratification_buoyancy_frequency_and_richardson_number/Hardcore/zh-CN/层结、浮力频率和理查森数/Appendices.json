{
    "hands_on_practices": [
        {
            "introduction": "分析海洋稳定性的第一步，是将原始仪器数据转化为有意义的物理量。这项练习将指导您完成从典型的CTD（温盐深仪）和ADCP（声学多普勒流速剖面仪）剖面数据计算平方浮力频率 $N^2$ 和梯度理查森数 $Ri_g$ 的全过程。通过从静力平衡和线性化状态方程等第一性原理出发进行推导，您将巩固对这些关键参数物理基础的理解，并掌握海洋学中的一项核心计算技能 。",
            "id": "3812274",
            "problem": "给定来自电导率-温度-深度（CTD）仪的剖面数据：温度 $T$（单位为摄氏度），实用盐度 $S$（单位为实用盐度单位 PSU），以及压力 $p$（单位为分巴 dbar）。在$z$轴向上为正的约定下，从第一性原理出发，推导一个计算程序，将这些剖面数据转换为浮力频率的平方 $N^2$，然后利用水平速度分量 $u$（单位为米/秒）的垂直切变计算梯度理查森数。你的推导和算法应基于静水力平衡、Boussinesq近似和线性化状态方程。请勿直接使用 $N^2$ 的快捷公式；相反，应在解题过程中将计算与底层的物理关系和定义联系起来。假设重力加速度和参考密度为常数。\n\n该程序必须按顺序为每个测试用例实现以下内容：\n- 使用静水力平衡将压力剖面 $p$ 转换为以海面为 $z=0$ 的向上为正的几何高度剖面 $z$（单位为米）。将参考密度和重力加速度视为常数，并使用标准的分巴到帕斯卡的转换。\n- 使用线性化状态方程，将密度变化表示为 $T$ 和 $S$ 的函数，然后根据 $T$ 和 $S$ 剖面计算相对于 $z$ 的垂直密度梯度。\n- 根据密度梯度和$z$轴向上为正的约定，得到每个采样点的 $N^2$（单位为 $\\mathrm{s^{-2}}$）。\n- 使用 $u$ 剖面计算垂直切变 $\\partial u/\\partial z$，然后计算每个采样点的梯度理查森数 $Ri_g$。\n- 在内部点使用二阶中心差分，在边界点使用一阶单边差分来近似所有剖面的垂直导数。\n\n使用的常数：\n- 参考密度 $ \\rho_0 = 1027 $ 千克/立方米。\n- 重力加速度 $ g = 9.81 $ 米/秒^2。\n- 线性热膨胀系数 $ \\alpha = 2.0 \\times 10^{-4} $ /开尔文。\n- 线性盐致收缩系数 $ \\beta = 7.6 \\times 10^{-4} $ /PSU。\n- 压力转换 $ 1 $ 分巴 $ = 10^4 $ 帕斯卡。\n\n对于每个测试用例，程序必须计算两个汇总指标：\n- 内部（不包括第一个和最后一个样本）$N^2$ 值的算术平均值，以 $\\mathrm{s^{-2}}$ 为单位，四舍五入到 $6$ 位小数。\n- 内部梯度理查森数的最小值，四舍五入到 $6$ 位小数。\n\n你的程序应该生成单行输出，其中包含所有测试用例的聚合结果，形式为方括号括起来的逗号分隔列表。对于每个测试用例，列表必须按顺序首先包含内部 $N^2$ 的平均值，然后是内部 $Ri_g$ 的最小值。\n\n提供并使用以下测试套件：\n\n- 测试用例 $1$（典型的稳定分层，不规则的压力间距）：\n  - $p$（分巴）：$[0, 5, 10, 20, 50, 100, 200, 300]$。\n  - $T$（摄氏度）：$[20.0, 19.0, 18.2, 16.0, 12.0, 8.0, 5.0, 3.0]$。\n  - $S$（PSU）：$[34.0, 34.1, 34.2, 34.4, 34.6, 34.8, 35.0, 35.1]$。\n  - $u$（米/秒）：$[0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50, 0.60]$。\n\n- 测试用例 $2$（近乎均质的水体）：\n  - $p$（分巴）：$[0, 10, 50, 100, 200]$。\n  - $T$（摄氏度）：$[10.0, 10.0, 10.0, 10.0, 10.0]$。\n  - $S$（PSU）：$[35.0, 35.0, 35.0, 35.0, 35.0]$。\n  - $u$（米/秒）：$[0.10, 0.12, 0.14, 0.16, 0.18]$。\n\n- 测试用例 $3$（上层海洋的不稳定分层）：\n  - $p$（分巴）：$[0, 5, 10, 20, 40]$。\n  - $T$（摄氏度）：$[10.0, 10.5, 10.8, 11.0, 11.2]$。\n  - $S$（PSU）：$[35.0, 34.9, 34.8, 34.7, 34.6]$。\n  - $u$（米/秒）：$[0.30, 0.28, 0.26, 0.25, 0.24]$。\n\n以指定单位作答。不使用角度。所有打印结果必须为小数。你的程序应生成单行输出，其中包含结果，形式为方括号括起来的逗号分隔列表，顺序为 $[N2\\_mean\\_1, Ri\\_min\\_1, N2\\_mean\\_2, Ri\\_min\\_2, N2\\_mean\\_3, Ri\\_min\\_3]$。",
            "solution": "用户要求从第一性原理推导一个计算流程，用于从压力（$p$）、温度（$T$）、盐度（$S$）和水平速度（$u$）的海洋学剖面数据计算浮力频率的平方（$N^2$）和梯度理查森数（$Ri_g$）。此推导及后续算法将基于静水力平衡、Boussinesq近似和线性化状态方程的原理。\n\n**1. 从第一性原理推导**\n\n**1.1. 坐标系：从压力到几何高度**\n题目指定了一个向上为正的垂直坐标$z$，且海面处$z=0$。CTD测量的主要垂直坐标是压力$p$。我们必须将压力剖面转换为几何高度剖面。基本关系是静水力平衡方程：\n$$ dP = -\\rho g dz $$\n其中$P$是帕斯卡（Pa）为单位的压力，$\\rho$是水密度，g是重力加速度。Boussinesq近似允许我们假设密度为常数 $\\rho \\approx \\rho_0$（一个参考密度），除非在浮力项中。将此近似应用于静水力方程，可简化为：\n$$ dP \\approx -\\rho_0 g dz $$\n我们从海面对该方程进行积分，海面处的$z_s=0$且表压$P_s=0$，积分到一个任意点$(z, P)$：\n$$ \\int_{0}^{P} dP' = \\int_{0}^{z} -\\rho_0 g dz' \\implies P = -\\rho_0 g z $$\n解出$z$，得到以米为单位的高度：\n$$ z = -\\frac{P}{\\rho_0 g} $$\n输入的压力$p$以分巴（dbar）为单位。我们使用标准转换 $1 \\ \\text{dbar} = 10^4 \\ \\text{Pa}$。因此，对于每个压力测量值$p_i$，相应的几何高度$z_i$计算如下：\n$$ z_i = -\\frac{p_i \\times 10^4}{\\rho_0 g} $$\n给定的常数是 $\\rho_0 = 1027 \\ \\mathrm{kg/m^3}$ 和 $g = 9.81 \\ \\mathrm{m/s^2}$。得到的$z$值将是非正值，这在我们的坐标系中正确地表示了海面以下的深度。\n\n**1.2. 浮力频率的平方 ($N^2$)**\n浮力（或布伦特-维萨拉）频率$N$表征了在稳定密度分层中流体质点垂直振荡的固有频率。其平方$N^2$定义为：\n$$ N^2 = -\\frac{g}{\\rho_0} \\frac{d\\rho}{dz} $$\n$N^2$为正表示稳定分层，$N^2$为负表示不稳定（对流）分层，$N^2=0$表示中性分层。要计算$N^2$，我们需要密度的垂直梯度$d\\rho/dz$。\n\n题目指定了一个线性化的海水状态方程，其中密度$\\rho$是温度$T$和盐度$S$的函数。密度变化$d\\rho$可以表示为：\n$$ d\\rho = \\frac{\\partial\\rho}{\\partial T} dT + \\frac{\\partial\\rho}{\\partial S} dS $$\n热膨胀系数$\\alpha$和盐致收缩系数$\\beta$定义为：\n$$ \\alpha = -\\frac{1}{\\rho_0} \\frac{\\partial\\rho}{\\partial T}, \\quad \\beta = \\frac{1}{\\rho_0} \\frac{\\partial\\rho}{\\partial S} $$\n根据这些定义，我们有 $\\partial\\rho/\\partial T = -\\rho_0 \\alpha$ 和 $\\partial\\rho/\\partial S = \\rho_0 \\beta$。\n使用链式法则，我们将垂直密度梯度$d\\rho/dz$表示为温度和盐度垂直梯度的函数：\n$$ \\frac{d\\rho}{dz} = \\frac{\\partial\\rho}{\\partial T}\\frac{dT}{dz} + \\frac{\\partial\\rho}{\\partial S}\\frac{dS}{dz} = -\\rho_0\\alpha\\frac{dT}{dz} + \\rho_0\\beta\\frac{dS}{dz} $$\n将$d\\rho/dz$的这个表达式代入$N^2$的定义中：\n$$ N^2 = -\\frac{g}{\\rho_0} \\left( -\\rho_0\\alpha\\frac{dT}{dz} + \\rho_0\\beta\\frac{dS}{dz} \\right) $$\n$$ N^2 = g \\left( \\alpha\\frac{dT}{dz} - \\beta\\frac{dS}{dz} \\right) $$\n这个最终表达式使我们能够使用给定的系数（$\\alpha = 2.0 \\times 10^{-4} \\ \\mathrm{K^{-1}}$, $\\beta = 7.6 \\times 10^{-4} \\ \\mathrm{PSU^{-1}}$）和数值近似的$T$和$S$的垂直梯度来计算$N^2$。\n\n**1.3. 梯度理查森数 ($Ri_g$)**\n梯度理查森数$Ri_g$是一个无量纲参数，表示浮力的稳定作用与速度切变的不稳定作用之比。它是动力稳定性和湍流生成可能性的关键指标。其定义为：\n$$ Ri_g = \\frac{N^2}{\\left(\\frac{\\partial u}{\\partial z}\\right)^2} $$\n其中 $\\partial u/\\partial z$ 是水平速度的垂直切变。切变不稳定发生的一个常用判据是$Ri_g  0.25$。为了计算$Ri_g$，我们将使用已计算的$N^2$剖面和数值近似的速度剖面$u(z)$的垂直梯度。\n\n**2. 计算算法**\n\n整体计算流程如下：\n\n**2.1. 数值微分**\n为了从离散的剖面数据计算垂直梯度 $\\frac{dT}{dz}$、$\\frac{dS}{dz}$ 和 $\\frac{\\partial u}{\\partial z}$，我们使用一种能适应$z$坐标非均匀垂直间距的有限差分格式。对于一个具有$n$个数据点$F_0, F_1, ..., F_{n-1}$（位于高度$z_0, z_1, ..., z_{n-1}$）的通用剖面$F(z)$：\n- **边界（第一个点，$i=0$）：** 使用一阶向前差分。\n$$ \\left(\\frac{dF}{dz}\\right)_0 = \\frac{F_1 - F_0}{z_1 - z_0} $$\n- **内部点（$1 \\le i \\le n-2$）：** 使用二阶中心差分。这种方法更精确，且适用于非均匀网格。\n$$ \\left(\\frac{dF}{dz}\\right)_i = \\frac{F_{i+1} - F_{i-1}}{z_{i+1} - z_{i-1}} $$\n- **边界（最后一个点，$i=n-1$）：** 使用一阶向后差分。\n$$ \\left(\\frac{dF}{dz}\\right)_{n-1} = \\frac{F_{n-1} - F_{n-2}}{z_{n-1} - z_{n-2}} $$\n\n**2.2. 分步实现**\n对于每个测试用例：\n1.  将输入的压力剖面$p$（dbar）转换为几何高度剖面$z$（m），使用公式 $z_i = -(p_i \\times 10^4) / (\\rho_0 g)$。\n2.  应用上述有限差分格式，根据输入的$T$、$S$、$u$剖面和计算出的$z$剖面，计算梯度剖面 $\\frac{dT}{dz}$、$\\frac{dS}{dz}$ 和 $\\frac{\\partial u}{\\partial z}$。\n3.  使用公式 $N^2 = g(\\alpha \\frac{dT}{dz} - \\beta \\frac{dS}{dz})$ 计算浮力频率平方剖面$N^2(z)$。\n4.  计算切变平方剖面 $(\\frac{\\partial u}{\\partial z})^2$。\n5.  通过将$N^2$剖面除以切变平方剖面，计算梯度理查森数剖面$Ri_g(z)$。\n6.  分离出结果剖面的内部点（即排除第一个和最后一个计算值）。\n7.  计算内部$N^2$值的算术平均值。\n8.  计算内部$Ri_g$值的最小值。\n9.  将两个指标都四舍五入到6位小数并存储。\n10. 处理完所有测试用例后，将收集到的结果格式化为指定的输出字符串。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and computes buoyancy frequency and Richardson number from CTD profiles.\n    \"\"\"\n\n    # --- Constants ---\n    RHO_0 = 1027.0  # Reference density in kg/m^3\n    G = 9.81        # Gravitational acceleration in m/s^2\n    ALPHA = 2.0e-4  # Thermal expansion coefficient in 1/K\n    BETA = 7.6e-4   # Haline contraction coefficient in 1/PSU\n    P_CONV = 1.0e4  # Pressure conversion from dbar to Pascal\n\n    # --- Test Cases ---\n    test_cases = [\n        {\n            \"p\": np.array([0, 5, 10, 20, 50, 100, 200, 300], dtype=float),\n            \"T\": np.array([20.0, 19.0, 18.2, 16.0, 12.0, 8.0, 5.0, 3.0], dtype=float),\n            \"S\": np.array([34.0, 34.1, 34.2, 34.4, 34.6, 34.8, 35.0, 35.1], dtype=float),\n            \"u\": np.array([0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50, 0.60], dtype=float),\n        },\n        {\n            \"p\": np.array([0, 10, 50, 100, 200], dtype=float),\n            \"T\": np.array([10.0, 10.0, 10.0, 10.0, 10.0], dtype=float),\n            \"S\": np.array([35.0, 35.0, 35.0, 35.0, 35.0], dtype=float),\n            \"u\": np.array([0.10, 0.12, 0.14, 0.16, 0.18], dtype=float),\n        },\n        {\n            \"p\": np.array([0, 5, 10, 20, 40], dtype=float),\n            \"T\": np.array([10.0, 10.5, 10.8, 11.0, 11.2], dtype=float),\n            \"S\": np.array([35.0, 34.9, 34.8, 34.7, 34.6], dtype=float),\n            \"u\": np.array([0.30, 0.28, 0.26, 0.25, 0.24], dtype=float),\n        },\n    ]\n\n    def compute_gradient(F, z):\n        \"\"\"\n        Computes the gradient of a profile F with respect to z using\n        a mixed finite difference scheme for a non-uniform grid.\n        \"\"\"\n        n = len(F)\n        if n  2:\n            return np.zeros(n)\n        \n        dFdz = np.zeros(n)\n        \n        # First-order forward difference at the start\n        if z[1] - z[0] != 0:\n            dFdz[0] = (F[1] - F[0]) / (z[1] - z[0])\n        \n        # First-order backward difference at the end\n        if z[n - 1] - z[n - 2] != 0:\n            dFdz[n - 1] = (F[n - 1] - F[n - 2]) / (z[n - 1] - z[n - 2])\n        \n        # Second-order central difference for interior points\n        for i in range(1, n - 1):\n            if z[i + 1] - z[i - 1] != 0:\n                dFdz[i] = (F[i + 1] - F[i - 1]) / (z[i + 1] - z[i - 1])\n            \n        return dFdz\n\n    results = []\n    for case in test_cases:\n        p, T, S, u = case[\"p\"], case[\"T\"], case[\"S\"], case[\"u\"]\n\n        # Step 1: Convert pressure (dbar) to geometric height z (m)\n        z = - (p * P_CONV) / (RHO_0 * G)\n\n        # Step 2: Compute vertical gradients\n        dT_dz = compute_gradient(T, z)\n        dS_dz = compute_gradient(S, z)\n        du_dz = compute_gradient(u, z)\n\n        # Step 3: Compute buoyancy frequency squared (N^2)\n        # N^2 = g * (alpha * dT/dz - beta * dS/dz)\n        N2 = G * (ALPHA * dT_dz - BETA * dS_dz)\n\n        # Step 4: Compute gradient Richardson number (Ri_g)\n        shear_sq = du_dz**2\n        # Use np.divide to handle division by zero safely, resulting in np.inf\n        # which is physically meaningful for Ri_g when shear is zero.\n        Rig = np.divide(N2, shear_sq, out=np.full_like(N2, np.inf), where=shear_sq != 0)\n\n        # Step 5: Extract interior points and compute metrics\n        if len(p) > 2:\n            interior_N2 = N2[1:-1]\n            interior_Rig = Rig[1:-1]\n            \n            mean_interior_N2 = np.mean(interior_N2)\n            min_interior_Rig = np.min(interior_Rig)\n        else: # Case with 2 or fewer points has no interior\n            mean_interior_N2 = np.nan\n            min_interior_Rig = np.nan\n\n        results.append(round(mean_interior_N2, 6))\n        results.append(round(min_interior_Rig, 6))\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然详细的垂直剖面数据很有价值，但有时一个简化的、层平均的稳定性视角会更为实用，尤其是在混合层动力学或大尺度模型中。本练习介绍了“整体理查森数”（Bulk Richardson Number）的概念，它在一个有限厚度的层上近似计算分层与切变的比例，而不是在某个特定点上。通过推导和应用这一整体参数，您将学会如何用一个单一的、具有物理意义的数值来表征整层水的稳定性 。",
            "id": "3812313",
            "problem": "给定一个海洋水柱中客观检测到的混合层深度（MLD）值，以及跨混合层的密度和水平速度的层平均差异。利用分层和切变的基本定义，推导理查森数在混合层上的整体表示，并实现一个程序来为一组测试用例计算该数值。假设标准符号约定，即垂直坐标向上增加，并且层平均密度差定义为底部密度减去顶部密度，因此正差值表示稳定分层。程序必须使用以下基本依据，并从第一性原理出发：\n1. Brunt–Väisälä 频率，也称为浮力频率（BF），在稳定分层条件下对于小的垂直位移定义为 $$N^2 = -\\frac{g}{\\rho_0}\\frac{\\partial \\rho}{\\partial z},$$ 其中 $g$ 是重力加速度，$\\rho_0$ 是一个恒定的参考密度，$\\rho$ 是现场密度，$z$ 是垂直坐标。\n2. 梯度理查森数定义为 $$Ri_g = \\frac{N^2}{S^2},$$ 其中 $S^2$ 是水平流垂直切变大小的平方，由速度分量得到 $$S^2 = \\left(\\frac{\\partial U}{\\partial z}\\right)^2 + \\left(\\frac{\\partial V}{\\partial z}\\right)^2,$$ 并且切变的大小可以从跨越层的矢量速度差来近似。\n3. 在厚度为 $h$ 的整体层中，用 $h$ 上的层平均差异替换垂直梯度，以获得跨混合层的 $Ri_g$ 的整体层估计，此处称为混合层的整体理查森数（BRN）。\n\n你的任务：\n- 根据上述定义，使用给定的层平均差异 $\\Delta \\rho$（底部减去顶部，单位为千克/立方米）和水平速度差的大小 $\\Delta U$（单位为米/秒），为厚度为 $h$ 的层推导一个合适的整体表达式。\n- 实现一个程序，使用常量 $g = 9.81$ m/s$^2$ 和 $\\rho_0 = 1025$ kg/m$^3$，为下面的每个测试用例计算混合层的整体理查森数。\n- 明确处理极限行为：\n  - 如果由 $\\Delta U$ 计算出的分母中的切变平方项为零且分子为正，则返回 $+\\infty$。\n  - 如果分子和分母都为零，则返回 $\\mathrm{NaN}$。\n  - 如果切变平方项为零且分子为负，则返回 $-\\infty$。\n- 将所有结果表示为无量纲实数（浮点数）。你必须生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。\n\n物理单位和约定：\n- 混合层深度 $h$，单位为米。\n- 层平均密度差 $\\Delta \\rho$，单位为千克/立方米。\n- 层平均水平速度差大小 $\\Delta U$，单位为米/秒。\n- 重力加速度 $g = 9.81$ m/s$^2$。\n- 参考密度 $\\rho_0 = 1025$ kg/m$^3$。\n- 整体理查森数是无量纲的。\n\n测试套件（每个用例是一个元组 $(h,\\Delta \\rho,\\Delta U)$）：\n- 用例 1：$(50.0, 0.5, 0.2)$，典型的稳定分层和中等切变。\n- 用例 2：$(20.0, 0.01, 0.1)$，近中性分层和弱切变。\n- 用例 3：$(30.0, 0.3, 1.5)$，中等分层和强切变。\n- 用例 4：$(40.0, 0.4, 0.0)$，稳定分层和零切变。\n- 用例 5：$(0.0, 0.2, 0.0)$，零厚度和零切变。\n- 用例 6：$(60.0, -0.1, 0.3)$，不稳定分层和有限切变。\n\n你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，$\\left[\\mathrm{result}_1,\\mathrm{result}_2,\\mathrm{result}_3\\right]$）。",
            "solution": "目标是推导梯度理查森数的一种整体层表示（此后称为整体理查森数，BRN），并实现一个程序，根据提供的层平均属性来计算它。推导将从提供的基本定义出发。\n\n梯度理查森数 $Ri_g$ 定义为浮力频率的平方 $N^2$ 与垂直切变的平方 $S^2$ 之比：\n$$\nRi_g = \\frac{N^2}{S^2}\n$$\n我们现在将分别推导分子和分母的整体表达式。\n\n**1. 整体浮力频率项（$N^2$）的推导**\n\n浮力频率（或 Brunt–Väisälä 频率）的平方由下式给出：\n$$\nN^2 = -\\frac{g}{\\rho_0} \\frac{\\partial \\rho}{\\partial z}\n$$\n其中 $g$ 是重力加速度，$\\rho_0$ 是参考密度，$\\rho$ 是现场密度，$z$ 是垂直坐标，定义为向上为正。\n\n为了获得厚度为 $h$ 的层的整体估计，我们使用层上的有限差分来近似垂直梯度 $\\frac{\\partial \\rho}{\\partial z}$。设层的顶部和底部位置分别为 $z_{top}$ 和 $z_{bottom}$，使得层厚度为 $h = z_{top} - z_{bottom}$。梯度的有限差分近似为：\n$$\n\\frac{\\partial \\rho}{\\partial z} \\approx \\frac{\\rho(z_{top}) - \\rho(z_{bottom})}{z_{top} - z_{bottom}} = \\frac{\\rho_{top} - \\rho_{bottom}}{h}\n$$\n问题将层平均密度差定义为 $\\Delta \\rho = \\rho_{bottom} - \\rho_{top}$。将其代入梯度近似中，我们得到：\n$$\n\\rho_{top} - \\rho_{bottom} = -(\\rho_{bottom} - \\rho_{top}) = -\\Delta \\rho\n$$\n因此，密度梯度的近似变为：\n$$\n\\frac{\\partial \\rho}{\\partial z} \\approx -\\frac{\\Delta \\rho}{h}\n$$\n将此整体近似代入 $N^2$ 的方程中，我们得到整体浮力频率的平方：\n$$\nN^2_{bulk} \\approx -\\frac{g}{\\rho_0} \\left( -\\frac{\\Delta \\rho}{h} \\right) = \\frac{g \\Delta \\rho}{\\rho_0 h}\n$$\n对于稳定分层，密度随深度增加，因此 $\\rho_{bottom}  \\rho_{top}$，这意味着 $\\Delta \\rho  0$。这正确地导致 $N^2  0$，与浮力振荡的物理原理一致。\n\n**2. 整体垂直切变项（$S^2$）的推导**\n\n水平流垂直切变大小的平方由下式给出：\n$$\nS^2 = \\left(\\frac{\\partial U}{\\partial z}\\right)^2 + \\left(\\frac{\\partial V}{\\partial z}\\right)^2\n$$\n其中 $U$ 和 $V$ 是水平速度矢量 $\\mathbf{u} = (U, V)$ 的分量。\n\n在厚度为 $h$ 的层上近似速度分量的垂直梯度：\n$$\n\\frac{\\partial U}{\\partial z} \\approx \\frac{\\Delta U_{comp}}{h} \\quad \\text{和} \\quad \\frac{\\partial V}{\\partial z} \\approx \\frac{\\Delta V_{comp}}{h}\n$$\n其中 $\\Delta U_{comp}$ 和 $\\Delta V_{comp}$ 是跨层的速度分量之差。将这些代入 $S^2$ 的表达式中，得到整体切变的平方：\n$$\nS^2_{bulk} \\approx \\left(\\frac{\\Delta U_{comp}}{h}\\right)^2 + \\left(\\frac{\\Delta V_{comp}}{h}\\right)^2 = \\frac{(\\Delta U_{comp})^2 + (\\Delta V_{comp})^2}{h^2}\n$$\n项 $(\\Delta U_{comp})^2 + (\\Delta V_{comp})^2$ 表示跨层矢量速度差的大小平方，即 $|\\Delta \\mathbf{u}|^2$。问题直接将此量作为 $\\Delta U$ 提供，其定义为“水平速度差的大小”。因此，我们可以写成：\n$$\nS^2_{bulk} \\approx \\frac{(\\Delta U)^2}{h^2}\n$$\n\n**3. 整体理查森数（BRN）的公式化**\n\n通过将 $N^2$ 和 $S^2$ 的整体表达式代入理查森数的定义，我们推导出 BRN 的表达式：\n$$\nBRN = \\frac{N^2_{bulk}}{S^2_{bulk}} \\approx \\frac{\\frac{g \\Delta \\rho}{\\rho_0 h}}{\\frac{(\\Delta U)^2}{h^2}}\n$$\n简化此表达式，我们得到整体理查森数的最终公式：\n$$\nBRN = \\frac{g \\Delta \\rho}{\\rho_0 h} \\cdot \\frac{h^2}{(\\Delta U)^2} = \\frac{g h \\Delta \\rho}{\\rho_0 (\\Delta U)^2}\n$$\n这个无量纲数表征了整个层中由分层引起的稳定性与由切变引起的不稳定性之比。\n\n**4. 计算实现与极限情况处理**\n\n为实现计算，我们将最终表达式的分子定义为 $N_{final} = g h \\Delta \\rho$，分母定义为 $D_{final} = \\rho_0 (\\Delta U)^2$。BRN 是它们的比值。问题规定了处理奇异情况的规则，我们在这个最终推导出的表达式的背景下对其进行解释。\n\n- 如果 $D_{final} = 0$（当 $\\Delta U = 0$ 时发生）且 $N_{final} > 0$（稳定分层，$h>0$，$\\Delta\\rho>0$），则表达式变为 $\\frac{>0}{0}$，对应于一个无限稳定的层。程序应返回正无穷大（$+\\infty$）。\n- 如果 $D_{final} = 0$ 且 $N_{final}  0$（不稳定分层，$h>0$，$\\Delta\\rho0$），则表达式变为 $\\frac{0}{0}$，对应于一个无限不稳定的层。程序应返回负无穷大（$-\\infty$）。\n- 如果 $D_{final} = 0$（$\\Delta U = 0$）和 $N_{final} = 0$（如果 $h=0$ 或 $\\Delta \\rho = 0$ 则发生）都成立，则表达式是不确定的（$0/0$）。程序应返回非数字（$\\mathrm{NaN}$）。这正确地处理了零厚度层的物理奇异情况。\n\n程序将应用此逻辑和推导出的公式到每个测试用例，使用提供的常量 $g = 9.81 \\, \\text{m/s}^2$ 和 $\\rho_0 = 1025 \\, \\text{kg/m}^3$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and computes the Bulk Richardson Number (BRN) for a set of oceanic test cases.\n    The validation of the problem statement has been completed, and the problem is deemed valid.\n    This function proceeds with the solution as per the problem's requirements.\n    \"\"\"\n\n    # Constants provided in the problem statement.\n    G = 9.81  # Gravitational acceleration in m/s^2\n    RHO_0 = 1025.0  # Reference density in kg/m^3\n\n    # Test suite: each tuple is (h, delta_rho, delta_U)\n    # h: Mixed Layer Depth in meters\n    # delta_rho: Layer-mean density difference (bottom - top) in kg/m^3\n    # delta_U: Magnitude of the horizontal velocity difference in m/s\n    test_cases = [\n        (50.0, 0.5, 0.2),   # Case 1: typical stable stratification and moderate shear.\n        (20.0, 0.01, 0.1),  # Case 2: near-neutral stratification and weak shear.\n        (30.0, 0.3, 1.5),   # Case 3: moderate stratification and strong shear.\n        (40.0, 0.4, 0.0),   # Case 4: stable stratification and vanishing shear.\n        (0.0, 0.2, 0.0),    # Case 5: zero thickness and vanishing shear.\n        (60.0, -0.1, 0.3),  # Case 6: unstable stratification and finite shear.\n    ]\n\n    def compute_brn(h, delta_rho, delta_u):\n        \"\"\"\n        Computes the Bulk Richardson number based on the derived formula.\n        \n        BRN = (g * h * delta_rho) / (rho_0 * delta_u^2)\n\n        Args:\n            h (float): Mixed Layer Depth (m).\n            delta_rho (float): Density difference across the layer (kg/m^3).\n            delta_u (float): Velocity difference magnitude across the layer (m/s).\n\n        Returns:\n            float: The dimensionless Bulk Richardson number, or inf, -inf, nan for special cases.\n        \"\"\"\n        # Numerator of the final derived BRN expression\n        brn_numerator = G * h * delta_rho\n        \n        # Denominator of the final derived BRN expression\n        # This corresponds to rho_0 * (shear_velocity_magnitude)^2\n        brn_denominator = RHO_0 * (delta_u ** 2)\n\n        # Handle limiting behaviors as specified in the problem statement\n        if brn_denominator == 0.0:\n            if brn_numerator > 0.0:\n                return np.inf\n            elif brn_numerator  0.0:\n                return -np.inf\n            else:  # brn_numerator is also 0.0\n                return np.nan\n        else:\n            return brn_numerator / brn_denominator\n\n    results = []\n    for h_case, drho_case, dU_case in test_cases:\n        result = compute_brn(h_case, drho_case, dU_case)\n        results.append(result)\n\n    # Format the output as a comma-separated list enclosed in square brackets.\n    # The str() function for numpy values (inf, -inf, nan) produces the required string representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在活跃的湍流区域，原始密度剖面常常包含密度倒置，这会导致计算出非物理的负 $N^2$ 值，从而使背景层化的评估变得复杂。这项高级练习介绍了一种处理此类数据的强大技术：通过重排密度剖面来创建一个引力稳定的参考状态。通过实施此方法，您将学会量化由湍流翻转引入的偏差，并估算驱动湍流的背景层化强度，这是高级湍流和混合研究的一项关键技能 。",
            "id": "3812291",
            "problem": "给定您的是深度和原位密度的垂直剖面，其中显示出与湍流翻转一致的密度倒置斑块。计算任务是通过将密度随深度增加进行单调重排来重构一个静力稳定的参考剖面，然后量化翻转在浮力频率平方的原始估计中引入的偏差。推导和算法必须从一个基本基础出发：静水平衡 $\\,\\partial p/\\partial z=-\\rho g\\,$、带有浮力 $\\,b(z)=-g\\left(\\rho(z)-\\rho_0\\right)/\\rho_0\\,$ 的 Boussinesq 近似，以及与所选垂直坐标一致表达的 Brunt–Väisälä（浮力）频率 $\\,N^2=\\partial b/\\partial z\\,$ 的定义。使用深度 $\\,d\\,$（单位为米）作为垂直坐标，其向下为正。在 Boussinesq 极限下进行计算，使用恒定的参考密度 $\\,\\rho_0\\,\\,$（单位为千克/立方米）、重力加速度 $\\,g\\,\\,$（单位为米/秒平方）和密度 $\\,\\rho(d)\\,$（单位为千克/立方米）。您的算法必须使用在内部为二阶中心、在边界为一阶单侧的数值一致的有限差分格式，为原始（翻转）和重排（静力稳定）剖面计算 $\\,N^2(d)\\,$，单位为 $\\,\\mathrm{s}^{-2}\\,$。然后，为每个测试案例计算一个翻转引起的偏差的单一标量度量，该度量定义为在重排后的 $\\,N^2\\,$ 超过一个小阈值 $\\,\\epsilon\\,$ 的深度范围内，$\\,N^2\\,$ 的平均分数偏差，即\n$$\n\\text{bias}=\\frac{1}{M}\\sum_{i\\in\\mathcal{I}}\\frac{N^2_{\\text{raw}}(d_i)-N^2_{\\text{reordered}}(d_i)}{\\max\\!\\left(N^2_{\\text{reordered}}(d_i),\\,\\epsilon\\right)},\n$$\n其中 $\\,\\mathcal{I}=\\{i:\\,N^2_{\\text{reordered}}(d_i)\\epsilon\\}\\,$ 且 $\\,M=|\\mathcal{I}|\\,$。如果 $\\,M=0\\,$，则将偏差设为 $\\,0.0\\,$。使用 $\\,g=9.81\\,$、$\\,\\rho_0=1025.0\\,$ 和 $\\,\\epsilon=10^{-7}\\,$。在内部以 $\\,\\mathrm{s}^{-2}\\,$ 为单位表示 $\\,N^2\\,$；最终报告的偏差是无量纲的，并且必须是一个小数。\n\n实现该算法，并在以下测试套件上进行评估。在每个案例中，使用三角函数扰动确定性地构建 $\\,\\rho(d)\\,$ 以避免随机性，并通过反转剖面的一个连续段来创建一个局部翻转，以引入密度倒置。所有密度单位均为千克/立方米，深度单位为米，三角函数参数单位为弧度。\n\n- 测试案例 $\\,1\\,$（具有小翻转斑块的通用稳定剖面）：$\\,d=\\{0,1,2,\\dots,100\\}\\,$；基线 $\\,\\rho_{\\mathrm{base}}(d)=1025.0+0.2\\,(d/100)\\,$；扰动 $\\,\\delta\\rho(d)=0.005\\sin\\!\\left(2\\pi d/20\\right)\\,$；原始剖面 $\\,\\rho(d)=\\rho_{\\mathrm{base}}(d)+\\delta\\rho(d)\\,$；通过反转段 $\\,d\\in[42,49]\\,$（即索引 $\\,42:50\\,$）引入一个翻转。\n- 测试案例 $\\,2\\,$（近中性层结）：$\\,d=\\{0,1,2,\\dots,50\\}\\,$；基线 $\\,\\rho_{\\mathrm{base}}(d)=1025.0\\,$；扰动 $\\,\\delta\\rho(d)=0.0005\\sin\\!\\left(2\\pi d/10\\right)\\,$；原始剖面 $\\,\\rho(d)=\\rho_{\\mathrm{base}}(d)+\\delta\\rho(d)\\,$；不反转任何段。\n- 测试案例 $\\,3\\,$（较厚层内的强翻转）：$\\,d=\\{0,1,2,\\dots,200\\}\\,$；基线 $\\,\\rho_{\\mathrm{base}}(d)=1025.0+0.5\\,(d/200)\\,$；扰动 $\\,\\delta\\rho(d)=0.01\\sin\\!\\left(2\\pi d/30\\right)\\,$；原始剖面 $\\,\\rho(d)=\\rho_{\\mathrm{base}}(d)+\\delta\\rho(d)\\,$；通过反转段 $\\,d\\in[80,119]\\,$（即索引 $\\,80:120\\,$）引入一个翻转。\n- 测试案例 $\\,4\\,$（具有分层结构和翻转的粗垂直分辨率）：$\\,d=\\{0,10,20,\\dots,300\\}\\,$；分段基线\n$$\n\\rho_{\\mathrm{base}}(d) =\n\\begin{cases}\n1026.0  \\text{if } 0 \\le d \\le 100 \\\\\n1026.0 + 0.8 \\frac{d-100}{100}  \\text{if } 100  d \\le 200 \\\\\n1026.8 + 0.1 \\frac{d-200}{100}  \\text{if } 200  d \\le 300\n\\end{cases}\n$$\n扰动 $\\,\\delta\\rho(d)=0.02\\sin\\!\\left(2\\pi d/50\\right)\\,$；原始剖面 $\\,\\rho(d)=\\rho_{\\mathrm{base}}(d)+\\delta\\rho(d)\\,$；通过反转段 $\\,d\\in[120,160]\\,$（即索引 $\\,12:17\\,$）引入一个翻转。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，形式为 `[result_1, result_2, result_3, result_4]`。",
            "solution": "问题陈述经评估是有效的。它在科学上植根于物理海洋学原理，在数学和计算上是适定的，并且所有参数和程序都得到了明确的规定。\n\n核心任务是量化垂直剖面中由密度倒置引起的浮力频率平方（$N^2$）估计的偏差。该分析的关键在于将从原始数据计算出的 $N^2$ 剖面与从重构的静力稳定参考剖面计算出的剖面进行比较。\n\n**1. 理论框架**\n\n该问题的基础在于流体中的静力稳定性概念。如果流体柱的密度随深度增加而增加，则它是静力稳定的。任何偏差，即较轻的流体位于较重的流体之下，都代表一种重力不稳定性，通常由湍流混合或其他动力过程引起。\n\n垂直坐标是深度 $d$，定义为向下为正。标准的海洋学垂直坐标 $z$ 向上为正，因此我们有关系式 $z = -d$。微分算子相应地变换为：$\\partial/\\partial z = -\\partial/\\partial d$。\n\nBoussinesq 近似通过假设密度变化很小来简化运动方程，除非密度变化与重力相乘（浮力项）。浮力 $b$ 定义为：\n$$\nb(z) = -g\\frac{\\rho(z) - \\rho_0}{\\rho_0}\n$$\n其中 $g$ 是重力加速度，$\\rho(z)$ 是原位密度，$\\rho_0$ 是一个恒定的参考密度。用深度 $d$ 表示，则为 $b(d) = -g(\\rho(d) - \\rho_0)/\\rho_0$。\n\nBrunt–Väisälä 频率的平方，或称浮力频率，$N^2$，量化了静力稳定性的强度。它被定义为浮力的垂直梯度：\n$$\nN^2 = \\frac{\\partial b}{\\partial z}\n$$\n代入 $b$ 的表达式并将变量更改为深度 $d$：\n$$\nN^2 = -\\frac{\\partial b}{\\partial d} = -\\frac{\\partial}{\\partial d} \\left( -g\\frac{\\rho(d) - \\rho_0}{\\rho_0} \\right) = \\frac{g}{\\rho_0} \\frac{\\partial \\rho}{\\partial d}\n$$\n对于一个稳定的流体柱，密度必须随深度增加，因此 $\\partial \\rho / \\partial d  0$，这意味着 $N^2  0$。具有密度倒置（$\\partial \\rho / \\partial d  0$）的区域其特征为 $N^2  0$ 并且是静力不稳定的。问题提供了 $g=9.81\\,\\mathrm{m/s^2}$ 和 $\\rho_0=1025.0\\,\\mathrm{kg/m^3}$。\n\n**2. 算法步骤**\n\n解决该问题的算法包括四个主要步骤，对每个测试案例都会执行这些步骤。\n\n**步骤 1：剖面生成**\n对于每个测试案例，在一系列深度 $d_i$ 上构建一个离散的`原始`密度垂直剖面 $\\rho_{\\text{raw}}(d_i)$。这包括：\n-   生成深度网格 $d$。\n-   计算基线密度剖面 $\\rho_{\\text{base}}(d)$。\n-   计算扰动 $\\delta\\rho(d)$。\n-   将它们相加以获得初始剖面：$\\rho(d) = \\rho_{\\text{base}}(d) + \\delta\\rho(d)$。\n-   对于有湍流翻转的案例，$\\rho(d)$ 数组的一个指定连续段被反转以创建 $\\rho_{\\text{raw}}(d_i)$。这会引入一个显著的密度倒置。\n\n**步骤 2：稳定剖面重构**\n从原始剖面创建一个静力稳定的参考剖面 $\\rho_{\\text{reordered}}(d_i)$。这是通过将 $\\rho_{\\text{raw}}(d_i)$ 的密度值按升序排序来实现的。\n$$\n\\rho_{\\text{reordered}} = \\text{sort}(\\rho_{\\text{raw}})\n$$\n此过程，类似于海洋学中的 Thorpe 排序法，将水块重新排序到其稳定位置，而不改变水团的总体分布。得到的剖面 $\\rho_{\\text{reordered}}(d_i)$ 随深度 $d_i$ 单调非递减。\n\n**步骤 3：浮力频率 ($N^2$) 计算**\n有了`原始`和`重排`的密度剖面，我们计算它们各自的浮力频率平方，$N^2_{\\text{raw}}$ 和 $N^2_{\\text{reordered}}$。这需要计算密度的垂直导数 $\\partial \\rho / \\partial d$。问题指定了一种有限差分格式：\n-   在内部网格点 $i \\in [1, N-2]$，使用二阶中心差分：\n    $$\n    \\left(\\frac{\\partial \\rho}{\\partial d}\\right)_i \\approx \\frac{\\rho_{i+1} - \\rho_{i-1}}{d_{i+1} - d_{i-1}}\n    $$\n-   在边界处，使用一阶单侧差分：\n    -   上边界 ($i=0$)：$\\left(\\frac{\\partial \\rho}{\\partial d}\\right)_0 \\approx \\frac{\\rho_1 - \\rho_0}{d_1 - d_0}$ (向前差分)。\n    -   下边界 ($i=N-1$)：$\\left(\\frac{\\partial \\rho}{\\partial d}\\right)_{N-1} \\approx \\frac{\\rho_{N-1} - \\rho_{N-2}}{d_{N-1} - d_{N-2}}$ (向后差分)。\n\n对 $\\rho_{\\text{raw}}$ 和 $\\rho_{\\text{reordered}}$ 都计算此数值导数。然后使用结果计算每个剖面的 $N^2$：\n$$\nN^2_{\\text{raw}}(d_i) = \\frac{g}{\\rho_0} \\left(\\frac{\\partial \\rho_{\\text{raw}}}{\\partial d}\\right)_i \\quad \\text{and} \\quad N^2_{\\text{reordered}}(d_i) = \\frac{g}{\\rho_0} \\left(\\frac{\\partial \\rho_{\\text{reordered}}}{\\partial d}\\right)_i\n$$\n所有 $N^2$ 值的单位都是 $\\mathrm{s}^{-2}$。\n\n**步骤 4：翻转引起的偏差计算**\n最后一步是计算平均分数偏差，这是一个标量度量，用于量化`原始`和`重排`的 $N^2$ 估计值之间的不一致性。公式为：\n$$\n\\text{bias}=\\frac{1}{M}\\sum_{i\\in\\mathcal{I}}\\frac{N^2_{\\text{raw}}(d_i)-N^2_{\\text{reordered}}(d_i)}{\\max\\!\\left(N^2_{\\text{reordered}}(d_i),\\,\\epsilon\\right)}\n$$\n求和是在一组特定的索引 $\\mathcal{I} = \\{i: N^2_{\\text{reordered}}(d_i) > \\epsilon\\}$ 上进行的，其中 $\\epsilon = 10^{-7}\\,\\mathrm{s}^{-2}$ 是一个小的正阈值。该阈值确保了归一化仅在背景层结具有物理意义的地方进行，从而避免了除以零或小数。$M$ 是这类索引的数量，$M=|\\mathcal{I}|$。如果 $M=0$（即重排后的剖面基本未分层），则偏差定义为 $0.0$。负偏差表示原始剖面平均而言低估了真实的背景层结，这是湍流翻转的预期效应。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It generates density profiles, computes buoyancy frequencies,\n    and calculates the overturn-induced bias.\n    \"\"\"\n    g = 9.81\n    rho_0 = 1025.0\n    epsilon = 1e-7\n\n    def calculate_bias(d, rho_raw, g_const, rho_0_const, eps_const):\n        \"\"\"\n        Calculates the overturn-induced bias for a given profile.\n\n        Args:\n            d (np.ndarray): Array of depths (m).\n            rho_raw (np.ndarray): Array of raw in situ densities (kg/m^3).\n            g_const (float): Gravitational acceleration (m/s^2).\n            rho_0_const (float): Reference density (kg/m^3).\n            eps_const (float): Threshold for N^2 (s^-2).\n\n        Returns:\n            float: The calculated bias metric.\n        \"\"\"\n        # Step 2: Reconstruct stable profile\n        rho_reordered = np.sort(rho_raw)\n\n        # Step 3: Compute N^2 for both profiles\n        # np.gradient uses second-order centered difference for interior\n        # and first-order one-sided difference for boundaries by default.\n        d_rho_raw_dd = np.gradient(rho_raw, d)\n        d_rho_reordered_dd = np.gradient(rho_reordered, d)\n\n        factor = g_const / rho_0_const\n        N2_raw = factor * d_rho_raw_dd\n        N2_reordered = factor * d_rho_reordered_dd\n\n        # Step 4: Calculate the bias metric\n        indices_I = np.where(N2_reordered > eps_const)[0]\n        M = len(indices_I)\n\n        if M == 0:\n            return 0.0\n\n        N2_raw_I = N2_raw[indices_I]\n        N2_reordered_I = N2_reordered[indices_I]\n\n        numerator = N2_raw_I - N2_reordered_I\n        denominator = np.maximum(N2_reordered_I, eps_const)\n        \n        terms = numerator / denominator\n        bias = np.mean(terms)\n\n        return bias\n\n    results = []\n\n    # Test Case 1\n    d1 = np.arange(101, dtype=float)\n    rho_base1 = 1025.0 + 0.2 * (d1 / 100.0)\n    delta_rho1 = 0.005 * np.sin(2 * np.pi * d1 / 20.0)\n    rho_raw1 = rho_base1 + delta_rho1\n    rho_raw1[42:50] = rho_raw1[42:50][::-1]\n    bias1 = calculate_bias(d1, rho_raw1, g, rho_0, epsilon)\n    results.append(bias1)\n\n    # Test Case 2\n    d2 = np.arange(51, dtype=float)\n    rho_base2 = 1025.0 * np.ones_like(d2)\n    delta_rho2 = 0.0005 * np.sin(2 * np.pi * d2 / 10.0)\n    rho_raw2 = rho_base2 + delta_rho2\n    # No reversal for this case\n    bias2 = calculate_bias(d2, rho_raw2, g, rho_0, epsilon)\n    results.append(bias2)\n\n    # Test Case 3\n    d3 = np.arange(201, dtype=float)\n    rho_base3 = 1025.0 + 0.5 * (d3 / 200.0)\n    delta_rho3 = 0.01 * np.sin(2 * np.pi * d3 / 30.0)\n    rho_raw3 = rho_base3 + delta_rho3\n    rho_raw3[80:120] = rho_raw3[80:120][::-1]\n    bias3 = calculate_bias(d3, rho_raw3, g, rho_0, epsilon)\n    results.append(bias3)\n    \n    # Test Case 4\n    d4 = np.arange(0, 301, 10, dtype=float)\n    rho_base4 = np.zeros_like(d4)\n    # Piecewise definition of baseline density\n    cond1 = (d4 >= 0)  (d4 = 100)\n    cond2 = (d4 > 100)  (d4 = 200)\n    cond3 = (d4 > 200)  (d4 = 300)\n    rho_base4[cond1] = 1026.0\n    rho_base4[cond2] = 1026.0 + 0.8 * (d4[cond2] - 100.0) / 100.0\n    rho_base4[cond3] = 1026.8 + 0.1 * (d4[cond3] - 200.0) / 100.0\n    delta_rho4 = 0.02 * np.sin(2 * np.pi * d4 / 50.0)\n    rho_raw4 = rho_base4 + delta_rho4\n    # Overturn for depths 120 to 160 inclusive (indices 12 to 16)\n    rho_raw4[12:17] = rho_raw4[12:17][::-1]\n    bias4 = calculate_bias(d4, rho_raw4, g, rho_0, epsilon)\n    results.append(bias4)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}