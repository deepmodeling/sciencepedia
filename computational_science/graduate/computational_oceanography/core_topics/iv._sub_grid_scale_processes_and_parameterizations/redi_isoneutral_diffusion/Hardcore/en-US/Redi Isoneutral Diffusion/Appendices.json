{
    "hands_on_practices": [
        {
            "introduction": "The cornerstone of parameterizing isoneutral diffusion is quantifying the local orientation of neutral surfaces. This exercise grounds the abstract concept of a neutral surface in a concrete calculation, starting from first principles. By deriving the isoneutral slope from a linearized equation of state and then applying it to a hypothetical ocean scenario, you will develop a foundational understanding of how thermodynamic properties determine the geometry of mixing pathways .",
            "id": "3809728",
            "problem": "Consider a local patch of the ocean interior where small-scale tracer mixing is parameterized following the Redi isoneutral diffusion framework. Assume the seawater equation of state is linearized such that infinitesimal density changes obey $d\\rho/\\rho_{0}=-\\alpha_{T}\\,d\\theta+\\beta_{S}\\,dS$, where $\\rho_{0}$ is a constant reference density, $\\theta$ is potential temperature, $S$ is practical salinity, $\\alpha_{T}$ is the thermal expansion coefficient, and $\\beta_{S}$ is the haline contraction coefficient. A neutral displacement is defined by the condition that $d\\rho=0$ along it. Treat the neutral surface locally as a smooth surface given implicitly by a scalar function of state, and define the local isoneutral slope in the $x$-direction $s_{x}$ as the geometric slope $\\partial z/\\partial x$ of that surface.\n\nStarting from the neutral condition and the linearized thermodynamic relation above, derive the expression for $s_{x}$ in terms of the local spatial gradients of $\\theta$ and $S$ and the coefficients $\\alpha_{T}$ and $\\beta_{S}$. Then, using the following locally measured coefficients and gradients,\n$\\alpha_{T}=2\\times 10^{-4}\\,\\text{K}^{-1}$, $\\beta_{S}=8\\times 10^{-4}\\,\\text{(g/kg)}^{-1}$, $\\partial_{z}\\theta=-0.01\\,\\text{K/m}$, $\\partial_{z}S=2\\times 10^{-5}\\,\\text{(g/kg)/m}$, $\\partial_{x}\\theta=1\\times 10^{-5}\\,\\text{K/m}$, and $\\partial_{x}S=-5\\times 10^{-6}\\,\\text{(g/kg)/m}$, compute the numerical value of $s_{x}$. Express the final value of $s_{x}$ as an exact fraction. In your reasoning, comment on the magnitude of the computed slope in relation to typical isoneutral slopes encountered in Ocean General Circulation Models (OGCMs). The final answer must be a single number; $s_{x}$ is dimensionless.",
            "solution": "The problem requires the derivation of the isoneutral slope, $s_x$, followed by its numerical computation based on provided oceanographic data.\n\nFirst, we validate the problem statement.\nThe givens are:\n1.  Linearized equation of state: $d\\rho/\\rho_{0}=-\\alpha_{T}\\,d\\theta+\\beta_{S}\\,dS$.\n2.  Definition of a neutral displacement: $d\\rho=0$.\n3.  Definition of isoneutral slope: $s_{x} = \\frac{\\partial z}{\\partial x}$ along a neutral surface.\n4.  Coefficients: $\\alpha_{T}=2\\times 10^{-4}\\,\\text{K}^{-1}$, $\\beta_{S}=8\\times 10^{-4}\\,\\text{(g/kg)}^{-1}$.\n5.  Local gradients: $\\partial_{z}\\theta=-0.01\\,\\text{K/m}$, $\\partial_{z}S=2\\times 10^{-5}\\,\\text{(g/kg)/m}$, $\\partial_{x}\\theta=1\\times 10^{-5}\\,\\text{K/m}$, $\\partial_{x}S=-5\\times 10^{-6}\\,\\text{(g/kg)/m}$.\n\nThe problem is scientifically grounded in the well-established principles of physical oceanography, specifically the parameterization of sub-grid scale mixing. The framework of Redi isoneutral diffusion and the use of a linearized equation of state are standard practices in computational oceanography. All necessary information is provided, and the given values are physically plausible for the ocean interior, assuming the common oceanographic convention that the vertical coordinate $z$ is positive downwards (depth). Under this convention, a positive vertical density gradient, $\\partial_z\\rho  0$, signifies a statically stable water column. The given gradients result in a stable stratification, confirming the physical consistency of the problem setup. The problem is well-posed, objective, and requires a non-trivial derivation and calculation. Therefore, the problem is deemed valid.\n\nWe now proceed with the solution.\n\nThe derivation begins with the condition for a neutral displacement, $d\\rho = 0$. Using the provided linearized equation of state, this implies:\n$$-\\alpha_{T}\\,d\\theta+\\beta_{S}\\,dS = 0$$\nThe potential temperature $\\theta$ and salinity $S$ are functions of the spatial coordinates, $\\theta(x,z)$ and $S(x,z)$, neglecting any variation in the $y$-direction as we are interested in the slope $s_x$. The total differentials $d\\theta$ and $dS$ for a displacement $(dx, dz)$ are given by:\n$$d\\theta = \\frac{\\partial \\theta}{\\partial x}dx + \\frac{\\partial \\theta}{\\partial z}dz$$\n$$dS = \\frac{\\partial S}{\\partial x}dx + \\frac{\\partial S}{\\partial z}dz$$\nSubstituting these expressions into the neutral displacement condition yields:\n$$-\\alpha_{T}\\left(\\frac{\\partial \\theta}{\\partial x}dx + \\frac{\\partial \\theta}{\\partial z}dz\\right) + \\beta_{S}\\left(\\frac{\\partial S}{\\partial x}dx + \\frac{\\partial S}{\\partial z}dz\\right) = 0$$\nThis equation must hold for any displacement $(dx, dz)$ that lies within the local neutral surface. To find the slope of this surface, $s_x = \\frac{\\partial z}{\\partial x}$, we rearrange the equation to solve for the ratio $\\frac{dz}{dx}$. First, group terms containing $dx$ and $dz$:\n$$\\left(-\\alpha_{T}\\frac{\\partial \\theta}{\\partial x} + \\beta_{S}\\frac{\\partial S}{\\partial x}\\right)dx + \\left(-\\alpha_{T}\\frac{\\partial \\theta}{\\partial z} + \\beta_{S}\\frac{\\partial S}{\\partial z}\\right)dz = 0$$\nRearranging to solve for $\\frac{dz}{dx}$:\n$$\\left(-\\alpha_{T}\\frac{\\partial \\theta}{\\partial z} + \\beta_{S}\\frac{\\partial S}{\\partial z}\\right)dz = -\\left(-\\alpha_{T}\\frac{\\partial \\theta}{\\partial x} + \\beta_{S}\\frac{\\partial S}{\\partial x}\\right)dx$$\n$$\\left(-\\alpha_{T}\\frac{\\partial \\theta}{\\partial z} + \\beta_{S}\\frac{\\partial S}{\\partial z}\\right)dz = \\left(\\alpha_{T}\\frac{\\partial \\theta}{\\partial x} - \\beta_{S}\\frac{\\partial S}{\\partial x}\\right)dx$$\nThe isoneutral slope $s_x$ is therefore:\n$$s_x = \\frac{dz}{dx} = \\frac{\\alpha_{T}\\frac{\\partial \\theta}{\\partial x} - \\beta_{S}\\frac{\\partial S}{\\partial x}}{-\\alpha_{T}\\frac{\\partial \\theta}{\\partial z} + \\beta_{S}\\frac{\\partial S}{\\partial z}}$$\nThis is the desired expression for the isoneutral slope in terms of the thermodynamic coefficients and the spatial gradients of potential temperature and salinity. The numerator is proportional to the horizontal density gradient, while the denominator is proportional to the vertical density gradient.\n\nNext, we compute the numerical value of $s_x$ using the provided data.\nLet's denote the partial derivatives compactly, e.g., $\\partial_x \\theta = \\frac{\\partial \\theta}{\\partial x}$.\nNumerator: $\\mathcal{N} = \\alpha_{T}\\partial_{x}\\theta - \\beta_{S}\\partial_{x}S$\nDenominator: $\\mathcal{D} = -\\alpha_{T}\\partial_{z}\\theta + \\beta_{S}\\partial_{z}S$\n\nSubstitute the given values:\n$\\alpha_{T} = 2 \\times 10^{-4}\\,\\text{K}^{-1}$\n$\\beta_{S} = 8 \\times 10^{-4}\\,\\text{(g/kg)}^{-1}$\n$\\partial_{x}\\theta = 1 \\times 10^{-5}\\,\\text{K/m}$\n$\\partial_{x}S = -5 \\times 10^{-6}\\,\\text{(g/kg)/m}$\n$\\partial_{z}\\theta = -0.01\\,\\text{K/m} = -1 \\times 10^{-2}\\,\\text{K/m}$\n$\\partial_{z}S = 2 \\times 10^{-5}\\,\\text{(g/kg)/m}$\n\nCalculate the numerator $\\mathcal{N}$:\n$$\\mathcal{N} = (2 \\times 10^{-4}) \\times (1 \\times 10^{-5}) - (8 \\times 10^{-4}) \\times (-5 \\times 10^{-6})$$\n$$\\mathcal{N} = (2 \\times 10^{-9}) - (-40 \\times 10^{-10})$$\n$$\\mathcal{N} = (2 \\times 10^{-9}) + (4 \\times 10^{-9})$$\n$$\\mathcal{N} = 6 \\times 10^{-9}\\,\\text{m}^{-1}$$\n\nCalculate the denominator $\\mathcal{D}$:\n$$\\mathcal{D} = -(2 \\times 10^{-4}) \\times (-1 \\times 10^{-2}) + (8 \\times 10^{-4}) \\times (2 \\times 10^{-5})$$\n$$\\mathcal{D} = (2 \\times 10^{-6}) + (16 \\times 10^{-9})$$\n$$\\mathcal{D} = (2 \\times 10^{-6}) + (0.016 \\times 10^{-6})$$\n$$\\mathcal{D} = 2.016 \\times 10^{-6}\\,\\text{m}^{-1}$$\nThe positive sign of $\\mathcal{D}$ confirms that the density stratification is stable for a coordinate system where $z$ is positive downwards, as $\\partial_z\\rho / \\rho_0 = \\mathcal{D}  0$.\n\nNow, compute the slope $s_x = \\frac{\\mathcal{N}}{\\mathcal{D}}$:\n$$s_x = \\frac{6 \\times 10^{-9}\\,\\text{m}^{-1}}{2.016 \\times 10^{-6}\\,\\text{m}^{-1}}$$\nTo express this as an exact fraction, we can write $2.016$ as $\\frac{2016}{1000}$.\n$$s_x = \\frac{6 \\times 10^{-9}}{2016 \\times 10^{-3} \\times 10^{-6}} = \\frac{6 \\times 10^{-9}}{2016 \\times 10^{-9}}$$\n$$s_x = \\frac{6}{2016}$$\nTo simplify the fraction, we find the greatest common divisor of $6$ and $2016$. Since $2+0+1+6=9$, $2016$ is divisible by $3$ and also by $2$. Thus it is divisible by $6$.\n$$2016 \\div 6 = 336$$\nSo, the simplified fraction is:\n$$s_x = \\frac{1}{336}$$\n\nFinally, we comment on the magnitude of this slope. The value $s_x = \\frac{1}{336} \\approx 0.002976$, or roughly $3 \\times 10^{-3}$. This is a dimensionless quantity representing the slope of the neutral surface. A slope of this magnitude implies that the surface changes depth by approximately $3$ meters over a horizontal distance of $1$ kilometer. In the context of Ocean General Circulation Models (OGCMs), isoneutral slopes vary widely. In the vast, quiescent interior of ocean basins, slopes are typically very small, on the order of $10^{-5}$ to $10^{-4}$. However, in dynamically active regions such as western boundary currents, strong frontal zones, or within mesoscale eddies, slopes can be significantly steeper, reaching magnitudes of $10^{-3}$ to $10^{-2}$. The calculated value of $s_x \\approx 3 \\times 10^{-3}$ is therefore on the larger end of the typical spectrum, suggesting that the \"local patch\" described in the problem is not dynamically quiescent but rather is located within or near a feature like a mesoscale eddy or a front, which acts to tilt the isoneutral surfaces. This is a realistic value for such a region.",
            "answer": "$$\n\\boxed{\\frac{1}{336}}\n$$"
        },
        {
            "introduction": "With the ability to calculate isoneutral slopes, we can now explore their profound consequences for tracer transport in models that use vertical coordinates. This practice reveals how diffusion that occurs strictly along tilted surfaces is perceived as a combination of horizontal and vertical mixing from the perspective of a fixed Cartesian grid. You will derive the effective vertical diffusivity, $K_{zz}^{\\mathrm{eff}}$, that arises purely from this geometric effect, a critical insight for understanding how isoneutral mixing drives vertical transport in ocean models .",
            "id": "3809721",
            "problem": "You are asked to derive and implement a computational method to diagnose the effective vertical diffusivity arising from Redi isoneutral diffusion in a Cartesian $x$-$y$-$z$ ocean model with sloping isoneutral surfaces. The objective is to start from first principles and core definitions, then arrive at a closed-form expression that can be used algorithmically. You must also demonstrate the method on a simple analytical tracer field.\n\nStart from the following fundamental base:\n- Fickâ€™s law in tensor form for a scalar tracer $C$ states that the diffusive flux vector $\\boldsymbol{F}$ is $\\boldsymbol{F} = - \\boldsymbol{K} \\nabla C$, where $\\boldsymbol{K}$ is a symmetric, positive semi-definite diffusivity tensor.\n- Redi isoneutral diffusion can be modeled as diffusion along isoneutral surfaces, represented by a diffusion tensor $\\boldsymbol{K} = K_{\\mathrm{i}} \\boldsymbol{P}$, where $K_{\\mathrm{i}}$ is a prescribed isoneutral diffusivity (constant and isotropic along isoneutral directions) with unit $\\mathrm{m^2\\,s^{-1}}$, and $\\boldsymbol{P}$ is the orthogonal projector onto the local tangent plane of the isoneutral surface. If $\\boldsymbol{b}$ denotes the unit normal to the isoneutral surface, then $\\boldsymbol{P} = \\boldsymbol{I} - \\boldsymbol{b}\\boldsymbol{b}^{\\top}$, where $\\boldsymbol{I}$ is the identity tensor.\n- Assume small-angle slopes of the isoneutral surface in a $z$-coordinate model are described by the slope vector $\\boldsymbol{s} = (s_x, s_y)$, defined as the horizontal slope of isoneutral surfaces, so that the unit normal to the surface is $\\boldsymbol{b} = \\dfrac{(-s_x, -s_y, 1)}{\\sqrt{1 + s_x^2 + s_y^2}}$. This definition is consistent with the standard neutral vector geometry in z-coordinate ocean models.\n\nUsing only these definitions, perform the following tasks:\n1. Derive an explicit expression for the vertical component of the flux, $F_z$, in terms of $K_{\\mathrm{i}}$, $s_x$, $s_y$, and the components of $\\nabla C$. Then, from the tensor definition alone, derive the effective vertical diffusivity component $K_{zz}^{\\mathrm{eff}}$ (the $z$-$z$ component of $\\boldsymbol{K}$ in the standard basis), which quantifies the apparent vertical diffusion generated purely by the along-isoneutral diffusion when isoneutral surfaces are tilted.\n2. Implement a program that, given constant parameters $K_{\\mathrm{i}}$, $s_x$, $s_y$, and a linear tracer field $C(x,y,z) = a_x x + a_y y + a_z z$ (with $C$ non-dimensional), computes for each parameter set:\n   - The effective vertical diffusivity $K_{zz}^{\\mathrm{eff}}$ in $\\mathrm{m^2\\,s^{-1}}$.\n   - The vertical diffusive flux $F_z$ in $\\mathrm{m\\,s^{-1}}$ for the given linear $C$, evaluated from your derived expression.\n   You must not assume any special-case formula beyond what is derivable from the definitions above.\n3. Use the following test suite of parameter sets. Each test case is a tuple $\\left(K_{\\mathrm{i}}, s_x, s_y, a_x, a_y, a_z\\right)$ with $K_{\\mathrm{i}}$ in $\\mathrm{m^2\\,s^{-1}}$, slopes dimensionless, and $a_x$, $a_y$, $a_z$ in $\\mathrm{m^{-1}}$:\n   - Case $1$: $\\left(1000, 0.01, 0.02, 0, 0, 0.001\\right)$\n   - Case $2$: $\\left(1200, 0, 0, 0.00005, -0.00003, 0.002\\right)$\n   - Case $3$: $\\left(800, 1.0, 0.5, 0.0001, -0.0002, 0.0005\\right)$\n   - Case $4$: $\\left(500, -0.05, 0.02, 0.0002, 0.0001, 0\\right)$\n4. Your program must output a single line that is a valid Python list literal, containing one sub-list per test case. Each sub-list must have the two floats $\\left[K_{zz}^{\\mathrm{eff}}, F_z\\right]$ in that order, both in the specified units, each rounded to $6$ decimal places. For example, a valid output format is $\\left[\\left[1.234000, -0.056700\\right],\\left[\\dots\\right],\\dots\\right]$.\n\nClarifications and constraints:\n- The method must be universally applicable to any modern programming language; however, you must provide the final runnable program as specified in the final answer.\n- Treat the tracer $C$ as non-dimensional. Therefore, the vertical flux $F_z$ must be reported in $\\mathrm{m\\,s^{-1}}$, and the effective vertical diffusivity $K_{zz}^{\\mathrm{eff}}$ in $\\mathrm{m^2\\,s^{-1}}$.\n- All computations are in Cartesian coordinates, and there are no Coriolis or advection effects.\n- Your implementation must use only the provided test suite and produce the exact output format described: a single line containing a comma-separated list of the per-case results, each result being a two-element list. No other text should be printed.",
            "solution": "The problem is valid as it is scientifically grounded in the principles of computational oceanography, specifically Redi isoneutral diffusion theory, is well-posed with all necessary information provided, and is formulated objectively. We will proceed with a full derivation and solution.\n\nThe objective is to derive expressions for the effective vertical diffusivity $K_{zz}^{\\mathrm{eff}}$ and the vertical diffusive flux $F_z$ from first principles and then implement these in a computational model.\n\nWe begin with the provided fundamental definitions:\nThe diffusive flux of a scalar tracer $C$ is given by Fick's law:\n$$ \\boldsymbol{F} = - \\boldsymbol{K} \\nabla C $$\nThe Redi isoneutral diffusion tensor $\\boldsymbol{K}$ is defined as:\n$$ \\boldsymbol{K} = K_{\\mathrm{i}} \\boldsymbol{P} = K_{\\mathrm{i}} (\\boldsymbol{I} - \\boldsymbol{b}\\boldsymbol{b}^{\\top}) $$\nwhere $K_{\\mathrm{i}}$ is the constant isoneutral diffusivity, $\\boldsymbol{I}$ is the identity tensor, and $\\boldsymbol{b}$ is the unit vector normal to the local isoneutral surface. In a Cartesian coordinate system $(x, y, z)$, the unit normal vector $\\boldsymbol{b}$ is defined in terms of the horizontal isoneutral slope vector $\\boldsymbol{s} = (s_x, s_y)$ as:\n$$ \\boldsymbol{b} = \\frac{1}{\\sqrt{1 + s_x^2 + s_y^2}} \\begin{pmatrix} -s_x \\\\ -s_y \\\\ 1 \\end{pmatrix} $$\n\n**1. Derivation of the Effective Vertical Diffusivity, $K_{zz}^{\\mathrm{eff}}$**\n\nThe effective vertical diffusivity $K_{zz}^{\\mathrm{eff}}$ is the $z$-$z$ component of the full diffusivity tensor $\\boldsymbol{K}$, which we denote as $K_{33}$ in matrix notation. To find this, we first construct the matrix representation of $\\boldsymbol{K}$.\n\nLet the normalization factor be $N^2 = 1 + s_x^2 + s_y^2$. The outer product of the normal vector, $\\boldsymbol{b}\\boldsymbol{b}^{\\top}$, is:\n$$ \\boldsymbol{b}\\boldsymbol{b}^{\\top} = \\frac{1}{N^2} \\begin{pmatrix} -s_x \\\\ -s_y \\\\ 1 \\end{pmatrix} \\begin{pmatrix} -s_x  -s_y  1 \\end{pmatrix} = \\frac{1}{1 + s_x^2 + s_y^2} \\begin{pmatrix} s_x^2  s_x s_y  -s_x \\\\ s_x s_y  s_y^2  -s_y \\\\ -s_x  -s_y  1 \\end{pmatrix} $$\nThe identity tensor $\\boldsymbol{I}$ is:\n$$ \\boldsymbol{I} = \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix} $$\nNow we construct the projector $\\boldsymbol{P} = \\boldsymbol{I} - \\boldsymbol{b}\\boldsymbol{b}^{\\top}$:\n$$ \\boldsymbol{P} = \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix} - \\frac{1}{1 + s_x^2 + s_y^2} \\begin{pmatrix} s_x^2  s_x s_y  -s_x \\\\ s_x s_y  s_y^2  -s_y \\\\ -s_x  -s_y  1 \\end{pmatrix} $$\n$$ \\boldsymbol{P} = \\frac{1}{1 + s_x^2 + s_y^2} \\left[ \\begin{pmatrix} 1 + s_x^2 + s_y^2  0  0 \\\\ 0  1 + s_x^2 + s_y^2  0 \\\\ 0  0  1 + s_x^2 + s_y^2 \\end{pmatrix} - \\begin{pmatrix} s_x^2  s_x s_y  -s_x \\\\ s_x s_y  s_y^2  -s_y \\\\ -s_x  -s_y  1 \\end{pmatrix} \\right] $$\n$$ \\boldsymbol{P} = \\frac{1}{1 + s_x^2 + s_y^2} \\begin{pmatrix} 1 + s_y^2  -s_x s_y  s_x \\\\ -s_x s_y  1 + s_x^2  s_y \\\\ s_x  s_y  s_x^2 + s_y^2 \\end{pmatrix} $$\nThe full diffusivity tensor $\\boldsymbol{K}$ is $K_{\\mathrm{i}}\\boldsymbol{P}$:\n$$ \\boldsymbol{K} = \\frac{K_{\\mathrm{i}}}{1 + s_x^2 + s_y^2} \\begin{pmatrix} 1 + s_y^2  -s_x s_y  s_x \\\\ -s_x s_y  1 + s_x^2  s_y \\\\ s_x  s_y  s_x^2 + s_y^2 \\end{pmatrix} $$\nThe effective vertical diffusivity, $K_{zz}^{\\mathrm{eff}}$, is the component of the flux that is proportional to the vertical gradient of the tracer, $-\\frac{\\partial C}{\\partial z}$. By inspection of the Fickian relation $F_z = -K_{zx} \\frac{\\partial C}{\\partial x} - K_{zy} \\frac{\\partial C}{\\partial y} - K_{zz} \\frac{\\partial C}{\\partial z}$, $K_{zz}^{\\mathrm{eff}}$ is the $(3, 3)$ element of the tensor $\\boldsymbol{K}$, which we denote $K_{33}$.\n$$\nK_{zz}^{\\mathrm{eff}} = K_{33} = K_{\\mathrm{i}} \\frac{s_x^2 + s_y^2}{1 + s_x^2 + s_y^2}\n$$\nThis expression demonstrates that vertical diffusion arises from isoneutral diffusion only when isoneutral surfaces are sloped (i.e., $s_x \\neq 0$ or $s_y \\neq 0$). The term $s_x^2 + s_y^2$ represents the squared magnitude of the total slope.\n\n**2. Derivation of the Vertical Flux, $F_z$**\n\nThe vertical component of the diffusive flux, $F_z$, is the third component of the vector $\\boldsymbol{F} = -\\boldsymbol{K} \\nabla C$. The problem specifies a linear tracer field $C(x,y,z) = a_x x + a_y y + a_z z$. The gradient of $C$ is therefore a constant vector:\n$$ \\nabla C = \\begin{pmatrix} \\frac{\\partial C}{\\partial x} \\\\ \\frac{\\partial C}{\\partial y} \\\\ \\frac{\\partial C}{\\partial z} \\end{pmatrix} = \\begin{pmatrix} a_x \\\\ a_y \\\\ a_z \\end{pmatrix} $$\nWe compute the flux vector $\\boldsymbol{F}$ by multiplying $-\\boldsymbol{K}$ with $\\nabla C$:\n$$ \\boldsymbol{F} = - \\boldsymbol{K} \\nabla C = - \\frac{K_{\\mathrm{i}}}{1 + s_x^2 + s_y^2} \\begin{pmatrix} 1 + s_y^2  -s_x s_y  s_x \\\\ -s_x s_y  1 + s_x^2  s_y \\\\ s_x  s_y  s_x^2 + s_y^2 \\end{pmatrix} \\begin{pmatrix} a_x \\\\ a_y \\\\ a_z \\end{pmatrix} $$\nWe are interested in the vertical component, $F_z$, which corresponds to the third row of the matrix-vector product:\n$$\nF_z = - \\frac{K_{\\mathrm{i}}}{1 + s_x^2 + s_y^2} \\left[ (s_x)(a_x) + (s_y)(a_y) + (s_x^2 + s_y^2)(a_z) \\right]\n$$\nThis can be written more concisely as:\n$$\nF_z = - \\frac{K_{\\mathrm{i}}}{1 + |\\boldsymbol{s}|^2} \\left( \\boldsymbol{s} \\cdot \\nabla_{h} C + |\\boldsymbol{s}|^2 \\frac{\\partial C}{\\partial z} \\right)\n$$\nwhere $\\boldsymbol{s}=(s_x, s_y)$, $\\nabla_h C = (a_x, a_y)$, and $|\\boldsymbol{s}|^2 = s_x^2 + s_y^2$. This final expression shows that the vertical flux is generated by two mechanisms: the projection of the horizontal tracer gradient onto the slope vector (first term) and the vertical tracer gradient acting over the sloped surface (second term).\n\n**3. Algorithmic Implementation**\n\nThe derived formulae are direct and can be implemented in a straightforward manner. For each test case, specified by the tuple $(K_{\\mathrm{i}}, s_x, s_y, a_x, a_y, a_z)$:\n- The effective vertical diffusivity is computed as:\n  $$ K_{zz}^{\\mathrm{eff}} = K_{\\mathrm{i}} \\frac{s_x^2 + s_y^2}{1 + s_x^2 + s_y^2} $$\n- The vertical diffusive flux is computed as:\n  $$ F_z = - K_{\\mathrm{i}} \\frac{s_x a_x + s_y a_y + (s_x^2 + s_y^2) a_z}{1 + s_x^2 + s_y^2} $$\nThe program will iterate through the provided test suite, compute these two values for each case, format them as floating-point numbers rounded to $6$ decimal places, and print the final result as a list of lists.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and computes the effective vertical diffusivity and vertical flux\n    arising from Redi isoneutral diffusion on sloping surfaces.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (K_i, s_x, s_y, a_x, a_y, a_z)\n    test_cases = [\n        (1000, 0.01, 0.02, 0, 0, 0.001),         # Case 1\n        (1200, 0, 0, 0.00005, -0.00003, 0.002), # Case 2\n        (800, 1.0, 0.5, 0.0001, -0.0002, 0.0005),# Case 3\n        (500, -0.05, 0.02, 0.0002, 0.0001, 0)     # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        K_i, s_x, s_y, a_x, a_y, a_z = case\n\n        # Calculate the squared magnitude of the slope and the normalization denominator\n        s_sq = s_x**2 + s_y**2\n        denominator = 1 + s_sq\n\n        # 1. Calculate the effective vertical diffusivity, K_zz_eff\n        # Formula: K_zz_eff = K_i * (s_x^2 + s_y^2) / (1 + s_x^2 + s_y^2)\n        K_zz_eff = K_i * s_sq / denominator\n\n        # 2. Calculate the vertical diffusive flux, F_z\n        # Formula: F_z = -K_i * (s_x*a_x + s_y*a_y + (s_x^2+s_y^2)*a_z) / (1 + s_x^2 + s_y^2)\n        flux_numerator = s_x * a_x + s_y * a_y + s_sq * a_z\n        F_z = -K_i * flux_numerator / denominator\n        \n        results.append([K_zz_eff, F_z])\n\n    # Format the final output string exactly as required by the problem.\n    # Each value is formatted to 6 decimal places.\n    formatted_results = []\n    for res_pair in results:\n        k_eff_str = f\"{res_pair[0]:.6f}\"\n        fz_str = f\"{res_pair[1]:.6f}\"\n        formatted_results.append(f\"[{k_eff_str}, {fz_str}]\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[[{formatted_results[0][1:-1]}],[{formatted_results[1][1:-1]}],[{formatted_results[2][1:-1]}],[{formatted_results[3][1:-1]}]]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This final practice bridges the gap between continuous mathematical theory and its discrete implementation within a computational model. Real-world ocean models use staggered grids, and translating theoretical formulas into robust code requires careful attention to discretization and numerical stability. You will develop an algorithm to compute isoneutral slopes on an Arakawa C-grid, incorporating essential techniques like face-centered averaging, slope capping, and handling regions of weak stratification, which are vital for a stable and physically realistic parameterization .",
            "id": "3809736",
            "problem": "You are to implement a complete, runnable program that computes isoneutral slopes in the Redi parameterization on an Arakawa C-grid for ocean tracers. The target quantities are the horizontal components of the slope vector, namely $s_x$ at $u$-faces and $s_y$ at $v$-faces, derived from cell-centered temperature $T$ and salinity $S$. Your algorithm must be robust and preserve consistency with vertical gradients and the model staggering.\n\nFundamental base and definitions:\n- Redi isoneutral diffusion parameterizes small-scale mixing along locally neutral directions defined by the linearized equation of state. Under a linear approximation, the local neutral gradient vector is $N = \\alpha \\nabla T - \\beta \\nabla S$, where $\\alpha$ is the thermal expansion coefficient and $\\beta$ is the haline contraction coefficient. The isoneutral slope components are obtained as ratios of horizontal to vertical components of $N$, specifically\n$$\ns_x = \\frac{\\alpha \\, \\partial_x T - \\beta \\, \\partial_x S}{\\alpha \\, \\partial_z T - \\beta \\, \\partial_z S}, \\quad\ns_y = \\frac{\\alpha \\, \\partial_y T - \\beta \\, \\partial_y S}{\\alpha \\, \\partial_z T - \\beta \\, \\partial_z S}.\n$$\n- The Arakawa C-grid staggering places scalars at cell centers. Horizontal slopes $s_x$ and $s_y$ must be computed at face centers with vertical consistency: the numerator is evaluated at the face, and the denominator is the vertical neutral component evaluated at the same face location by a horizontal average of adjacent cell-centered vertical gradients.\n\nGrid, discretization, and algorithm requirements:\n- Consider a uniform Cartesian grid with spacings $\\Delta x$, $\\Delta y$, and $\\Delta z$, measured in meters. The variables $T$ and $S$ are defined at cell centers with indices $(i,j,k)$ for $i = 0,\\dots,N_x-1$, $j = 0,\\dots,N_y-1$, and $k = 0,\\dots,N_z-1$.\n- Compute face-centered horizontal gradients using second-order centered differences consistent with the face location:\n    - At $u$-faces located at $(i+\\tfrac{1}{2}, j, k)$, use\n    $$\n    \\partial_x T\\big|_{i+\\frac{1}{2},j,k} \\approx \\frac{T_{i+1,j,k} - T_{i,j,k}}{\\Delta x}, \\quad\n    \\partial_x S\\big|_{i+\\frac{1}{2},j,k} \\approx \\frac{S_{i+1,j,k} - S_{i,j,k}}{\\Delta x}.\n    $$\n    - At $v$-faces located at $(i, j+\\tfrac{1}{2}, k)$, use\n    $$\n    \\partial_y T\\big|_{i,j+\\frac{1}{2},k} \\approx \\frac{T_{i,j+1,k} - T_{i,j,k}}{\\Delta y}, \\quad\n    \\partial_y S\\big|_{i,j+\\frac{1}{2},k} \\approx \\frac{S_{i,j+1,k} - S_{i,j,k}}{\\Delta y}.\n    $$\n- Compute cell-centered vertical gradients using centered differences in the interior and one-sided differences at the boundaries:\n    $$\n    \\partial_z T\\big|_{i,j,k} \\approx\n    \\begin{cases}\n    \\dfrac{T_{i,j,k+1} - T_{i,j,k-1}}{2 \\Delta z},  \\text{for } 1 \\le k \\le N_z-2, \\\\\n    \\dfrac{T_{i,j,1} - T_{i,j,0}}{\\Delta z},  \\text{for } k=0, \\\\\n    \\dfrac{T_{i,j,N_z-1} - T_{i,j,N_z-2}}{\\Delta z},  \\text{for } k=N_z-1,\n    \\end{cases}\n    $$\n    and the same for $\\partial_z S\\big|_{i,j,k}$.\n- To place the vertical neutral denominator at faces consistently with the horizontal staggering, use a simple horizontal average:\n    - At $u$-faces,\n    $$\n    D_{x}\\big|_{i+\\frac{1}{2},j,k} = \\frac{1}{2} \\left[ \\alpha \\, \\partial_z T\\big|_{i,j,k} - \\beta \\, \\partial_z S\\big|_{i,j,k} \\;+\\; \\alpha \\, \\partial_z T\\big|_{i+1,j,k} - \\beta \\, \\partial_z S\\big|_{i+1,j,k} \\right].\n    $$\n    - At $v$-faces,\n    $$\n    D_{y}\\big|_{i,j+\\frac{1}{2},k} = \\frac{1}{2} \\left[ \\alpha \\, \\partial_z T\\big|_{i,j,k} - \\beta \\, \\partial_z S\\big|_{i,j,k} \\;+\\; \\alpha \\, \\partial_z T\\big|_{i,j+1,k} - \\beta \\, \\partial_z S\\big|_{i,j+1,k} \\right].\n    $$\n- Form the raw slopes by dividing the face-centered numerators by the corresponding face-centered denominators. For robustness:\n    - If the magnitude of the denominator is below a small threshold $\\varepsilon$, set the slope to zero at that face to avoid numerical blow-up.\n    - Apply a slope cap $s_{\\max}$ to enforce the small-slope assumption used in Redi diffusion: after forming the raw slope, set $s \\leftarrow \\operatorname{sign}(s) \\cdot \\min(|s|, s_{\\max})$.\n- Use constant coefficients $\\alpha$ and $\\beta$ in units of inverse degrees Celsius and inverse practical salinity units: $\\alpha = 0.0002$ and $\\beta = 0.0008$. These values are representative for the mixed-layer range and are adequate for algorithmic testing.\n\nUnits and outputs:\n- The inputs $T$ and $S$ must be in degrees Celsius and practical salinity units (dimensionless), respectively. The grid spacings $\\Delta x$, $\\Delta y$, and $\\Delta z$ must be in meters. The slopes $s_x$ and $s_y$ are dimensionless.\n- Your program must compute $s_x$ and $s_y$ for each test case and then provide aggregate metrics as specified below. All reported values must be numeric floats or integers without units.\n\nTest suite:\nImplement your program to run the following three cases. In each case, use the specified constants $\\alpha = 0.0002$, $\\beta = 0.0008$, slope cap $s_{\\max} = 0.01$, and denominator threshold $\\varepsilon = 1.0 \\times 10^{-12}$.\n- Case $1$ (general well-behaved field):\n    - Grid: $N_x = 3$, $N_y = 3$, $N_z = 4$, $\\Delta x = 10000$, $\\Delta y = 10000$, $\\Delta z = 10$.\n    - Fields: $T_{i,j,k} = 10 + 0.01 \\, i + 0.02 \\, j - 0.05 \\, k$, $S_{i,j,k} = 35 + 0.005 \\, i + 0.000 \\, j + 0.01 \\, k$.\n    - Outputs to report: the maximum absolute slope over all $u$-faces, and the maximum absolute slope over all $v$-faces, both after thresholding and capping.\n- Case $2$ (near-neutral vertical denominator):\n    - Grid: $N_x = 2$, $N_y = 2$, $N_z = 3$, $\\Delta x = 1000$, $\\Delta y = 1000$, $\\Delta z = 20$.\n    - Fields: $T_{i,j,k} = 5 + 1.0 \\, i + 0.0 \\, j - 0.02 \\, k$, $S_{i,j,k} = 34 + 0.0 \\, i + 0.0 \\, j - 0.005 \\, k$.\n    - Outputs to report: the total count of faces (sum over $u$-faces and $v$-faces) where $|D|  \\varepsilon$ and the slope is set to zero due to near-zero denominator; the maximum absolute $u$-face slope; and the maximum absolute $v$-face slope, both after thresholding and capping.\n- Case $3$ (strong horizontal gradients causing capping):\n    - Grid: $N_x = 3$, $N_y = 2$, $N_z = 3$, $\\Delta x = 500$, $\\Delta y = 500$, $\\Delta z = 20$.\n    - Fields: $T_{i,j,k} = 8 + 5.0 \\, i + 0.0 \\, j - 0.02 \\, k$, $S_{i,j,k} = 35 + 0.0 \\, i + 0.0 \\, j + 0.0 \\, k$.\n    - Outputs to report: the total count of faces (sum over $u$-faces and $v$-faces) where capping is active, i.e., where $|s_{\\text{raw}}|  s_{\\max}$ and the denominator satisfies $|D| \\ge \\varepsilon$; the maximum absolute $u$-face slope; and the maximum absolute $v$-face slope, both after thresholding and capping.\n\nFinal output format:\nYour program should produce a single line of output containing the results for all three cases as a comma-separated list enclosed in square brackets. The order must be:\n$[$case $1$ $u$-face maximum absolute slope, case $1$ $v$-face maximum absolute slope, case $2$ near-zero-denominator face count, case $2$ $u$-face maximum absolute slope, case $2$ $v$-face maximum absolute slope, case $3$ capped-face count, case $3$ $u$-face maximum absolute slope, case $3$ $v$-face maximum absolute slope$]$. All values must be reported as plain numbers (no units).",
            "solution": "The problem requires the implementation of an algorithm to compute isoneutral slopes, $s_x$ and $s_y$, on an Arakawa C-grid, which is a fundamental task in the Redi parameterization of mesoscale eddy-induced tracer transport in ocean models. The provided problem statement is scientifically sound, mathematically well-posed, and contains all necessary information for a unique and verifiable solution.\n\nThe core principle is the parameterization of sub-grid scale mixing along isoneutral surfaces, which are surfaces of constant potential density. For computational purposes, this is approximated by a local neutral direction. Using a linearized equation of state, the local neutral gradient vector, $N$, is defined as:\n$$\nN = \\alpha \\nabla T - \\beta \\nabla S\n$$\nwhere $T$ is temperature, $S$ is salinity, $\\alpha$ is the thermal expansion coefficient, and $\\beta$ is the haline contraction coefficient. The isoneutral slopes, $s_x$ and $s_y$, represent the tilt of this neutral surface in the $x$-$z$ and $y$-$z$ planes, respectively. They are defined as the ratio of the horizontal components of $N$ to its vertical component:\n$$\ns_x = \\frac{\\alpha \\, \\partial_x T - \\beta \\, \\partial_x S}{\\alpha \\, \\partial_z T - \\beta \\, \\partial_z S}, \\quad\ns_y = \\frac{\\alpha \\, \\partial_y T - \\beta \\, \\partial_y S}{\\alpha \\, \\partial_z T - \\beta \\, \\partial_z S}\n$$\n\nThe provided algorithmic design adheres to the staggering of variables on an Arakawa C-grid, where scalar quantities like $T$ and $S$ reside at cell centers, while velocity components (and associated fluxes or slopes) are located at cell faces. This requires careful discretization and averaging.\n\nThe algorithm proceeds as follows:\n\n$1$. **Compute Vertical Gradients**: The vertical gradients, $\\partial_z T$ and $\\partial_z S$, are computed first at the cell centers $(i,j,k)$. Following the specification, a second-order centered difference is used for interior grid points ($1 \\le k \\le N_z-2$), while first-order one-sided differences are used at the top ($k=0$) and bottom ($k=N_z-1$) boundaries. This provides a robust estimate of the vertical structure across the entire water column.\n$$\n\\partial_z T\\big|_{i,j,k} \\approx\n\\begin{cases}\n\\dfrac{T_{i,j,k+1} - T_{i,j,k-1}}{2 \\Delta z},  \\text{for } 1 \\leq k \\leq N_z-2 \\\\\n\\dfrac{T_{i,j,1} - T_{i,j,0}}{\\Delta z},  \\text{for } k=0 \\\\\n\\dfrac{T_{i,j,N_z-1} - T_{i,j,N_z-2}}{\\Delta z},  \\text{for } k=N_z-1\n\\end{cases}\n$$\nThe procedure for $\\partial_z S$ is identical.\n\n$2$. **Compute Horizontal Gradients and Face-Centered Numerators**: The horizontal gradients required for the slope numerators are computed at the cell faces, consistent with the C-grid staggering.\n- For the slope $s_x$ at the $u$-face $(i+\\frac{1}{2}, j, k)$, the horizontal gradients are approximated by a centered difference across the face:\n$$\n\\partial_x T\\big|_{i+\\frac{1}{2},j,k} \\approx \\frac{T_{i+1,j,k} - T_{i,j,k}}{\\Delta x}\n$$\nThe numerator of $s_x$, denoted $N_{x}|_{i+\\frac{1}{2},j,k}$, is then assembled using these face-centered gradients.\n- An analogous computation is performed for $s_y$ at the $v$-face $(i, j+\\frac{1}{2}, k)$ using gradients in the $y$-direction.\n\n$3$. **Compute Face-Centered Denominators**: The denominator, $N_z = \\alpha \\, \\partial_z T - \\beta \\, \\partial_z S$, is first evaluated at cell centers using the vertical gradients from Step $1$. To co-locate the denominator with the numerator at the cell faces, a simple horizontal average is performed.\n- For the $u$-face at $(i+\\frac{1}{2}, j, k)$, the denominator $D_x$ is:\n$$\nD_{x}\\big|_{i+\\frac{1}{2},j,k} = \\frac{1}{2} \\left[ (\\alpha \\partial_z T - \\beta \\partial_z S)\\big|_{i,j,k} + (\\alpha \\partial_z T - \\beta \\partial_z S)\\big|_{i+1,j,k} \\right]\n$$\n- A similar average is used to find the denominator $D_y$ at the $v$-face at $(i, j+\\frac{1}{2}, k)$. This averaging conserves properties and maintains numerical stability.\n\n$4$. **Apply Robustness Constraints**: Two critical numerical constraints are applied to ensure the stability and physical realism of the computed slopes.\n- **Denominator Thresholding**: In regions where the water column is weakly stratified or isoneutral, the denominator $N_z$ can approach zero, leading to a numerical singularity. To prevent this, if the magnitude of the face-centered denominator ($|D_x|$ or $|D_y|$) is smaller than a prescribed threshold $\\varepsilon = 10^{-12}$, the slope at that face is set to zero. This condition physically corresponds to a vertical isoneutral surface, where horizontal mixing is not well-defined by this parameterization.\n- **Slope Capping**: The Redi parameterization assumes that isoneutral slopes are small. To enforce this \"small-slope\" approximation, the magnitude of the computed raw slopes is capped at a maximum value, $s_{\\max} = 0.01$. If the raw slope $|s_{raw}|  s_{\\max}$, the final slope is set to $s = \\operatorname{sign}(s_{raw}) \\cdot s_{\\max}$. This prevents unphysically large slopes which can cause numerical instability in the parent ocean model.\n\nBy systematically applying these well-established principles of computational oceanography, we can construct a robust and accurate implementation. The provided test cases are designed to verify the correct handling of a general case, a near-zero denominator scenario, and a strong-gradient scenario that triggers slope capping.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_slopes(Nx, Ny, Nz, dx, dy, dz, T_func, S_func, alpha, beta, s_max, epsilon):\n    \"\"\"\n    Computes isoneutral slopes and related metrics for a given case.\n\n    Args:\n        Nx, Ny, Nz (int): Grid dimensions.\n        dx, dy, dz (float): Grid spacings.\n        T_func, S_func (callable): Functions to generate T and S fields.\n        alpha, beta (float): Thermal/haline coefficients.\n        s_max (float): Slope cap.\n        epsilon (float): Denominator threshold.\n\n    Returns:\n        A tuple containing:\n        (max_abs_sx, max_abs_sy, zero_denom_count, capped_count)\n    \"\"\"\n    # 1. Create grid and scalar fields using numpy broadcasting\n    i, j, k = np.ogrid[0:Nx, 0:Ny, 0:Nz]\n    T = T_func(i, j, k)\n    S = S_func(i, j, k)\n\n    # 2. Compute vertical gradients at cell centers\n    # The problem's specification for vertical gradients (centered interior, \n    # one-sided boundaries) exactly matches the behavior of np.gradient with edge_order=1.\n    d_T_dz = np.gradient(T, dz, axis=2, edge_order=1)\n    d_S_dz = np.gradient(S, dz, axis=2, edge_order=1)\n\n    # 3. Compute cell-centered vertical neutral component (denominator base)\n    Den_cell = alpha * d_T_dz - beta * d_S_dz\n\n    # --- 4. Compute slopes sx at u-faces (i+1/2, j, k) ---\n    max_abs_sx = 0.0\n    zero_denom_count_x = 0\n    capped_count_x = 0\n\n    if Nx  1:\n        # Numerator at u-faces\n        dT_dx = (T[1:, :, :] - T[:-1, :, :]) / dx\n        dS_dx = (S[1:, :, :] - S[:-1, :, :]) / dx\n        Num_x = alpha * dT_dx - beta * dS_dx\n\n        # Denominator at u-faces (average from adjacent cells)\n        Den_x = 0.5 * (Den_cell[:-1, :, :] + Den_cell[1:, :, :])\n\n        # Apply denominator threshold\n        s_x_raw = np.zeros_like(Den_x)\n        mask_x_denom_ok = np.abs(Den_x) = epsilon\n        np.divide(Num_x, Den_x, out=s_x_raw, where=mask_x_denom_ok)\n\n        # Apply slope capping\n        s_x = np.sign(s_x_raw) * np.minimum(np.abs(s_x_raw), s_max)\n        \n        # Collect metrics for sx\n        max_abs_sx = np.max(np.abs(s_x))\n        zero_denom_count_x = np.sum(~mask_x_denom_ok)\n        capped_count_x = np.sum((np.abs(s_x_raw)  s_max)  mask_x_denom_ok)\n\n    # --- 5. Compute slopes sy at v-faces (i, j+1/2, k) ---\n    max_abs_sy = 0.0\n    zero_denom_count_y = 0\n    capped_count_y = 0\n\n    if Ny  1:\n        # Numerator at v-faces\n        dT_dy = (T[:, 1:, :] - T[:, :-1, :]) / dy\n        dS_dy = (S[:, 1:, :] - S[:, :-1, :]) / dy\n        Num_y = alpha * dT_dy - beta * dS_dy\n\n        # Denominator at v-faces (average from adjacent cells)\n        Den_y = 0.5 * (Den_cell[:, :-1, :] + Den_cell[:, 1:, :])\n\n        # Apply denominator threshold\n        s_y_raw = np.zeros_like(Den_y)\n        mask_y_denom_ok = np.abs(Den_y) = epsilon\n        np.divide(Num_y, Den_y, out=s_y_raw, where=mask_y_denom_ok)\n\n        # Apply slope capping\n        s_y = np.sign(s_y_raw) * np.minimum(np.abs(s_y_raw), s_max)\n        \n        # Collect metrics for sy\n        max_abs_sy = np.max(np.abs(s_y))\n        zero_denom_count_y = np.sum(~mask_y_denom_ok)\n        capped_count_y = np.sum((np.abs(s_y_raw)  s_max)  mask_y_denom_ok)\n\n    # --- 6. Aggregate metrics ---\n    zero_denom_count = zero_denom_count_x + zero_denom_count_y\n    capped_count = capped_count_x + capped_count_y\n\n    return (max_abs_sx, max_abs_sy, zero_denom_count, capped_count)\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Define constants for all cases\n    alpha = 0.0002\n    beta = 0.0008\n    s_max = 0.01\n    epsilon = 1.0e-12\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Case 1\",\n            \"grid\": {\"Nx\": 3, \"Ny\": 3, \"Nz\": 4, \"dx\": 10000, \"dy\": 10000, \"dz\": 10},\n            \"fields\": {\n                \"T_func\": lambda i, j, k: 10 + 0.01 * i + 0.02 * j - 0.05 * k,\n                \"S_func\": lambda i, j, k: 35 + 0.005 * i + 0.000 * j + 0.01 * k,\n            },\n        },\n        {\n            \"name\": \"Case 2\",\n            \"grid\": {\"Nx\": 2, \"Ny\": 2, \"Nz\": 3, \"dx\": 1000, \"dy\": 1000, \"dz\": 20},\n            \"fields\": {\n                \"T_func\": lambda i, j, k: 5 + 1.0 * i + 0.0 * j - 0.02 * k,\n                \"S_func\": lambda i, j, k: 34 + 0.0 * i + 0.0 * j - 0.005 * k,\n            },\n        },\n        {\n            \"name\": \"Case 3\",\n            \"grid\": {\"Nx\": 3, \"Ny\": 2, \"Nz\": 3, \"dx\": 500, \"dy\": 500, \"dz\": 20},\n            \"fields\": {\n                \"T_func\": lambda i, j, k: 8 + 5.0 * i + 0.0 * j - 0.02 * k,\n                \"S_func\": lambda i, j, k: 35 + 0.0 * i + 0.0 * j + 0.0 * k,\n            },\n        },\n    ]\n\n    results = []\n    for i, case in enumerate(test_cases):\n        max_sx, max_sy, zero_denom, capped = calculate_slopes(\n            **case[\"grid\"], \n            **case[\"fields\"], \n            alpha=alpha, beta=beta, s_max=s_max, epsilon=epsilon\n        )\n        if i == 0:  # Case 1\n            results.extend([max_sx, max_sy])\n        elif i == 1:  # Case 2\n            results.extend([zero_denom, max_sx, max_sy])\n        elif i == 2:  # Case 3\n            results.extend([capped, max_sx, max_sy])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}