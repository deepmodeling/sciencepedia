{
    "hands_on_practices": [
        {
            "introduction": "Boundary conditions are not merely constraints; they actively determine the fundamental character of a system's solutions. This foundational exercise guides you through deriving the normal modes of a simple shallow-water system under two different physical regimes. By contrasting a closed basin with a periodic channel, you will discover precisely how boundary conditions give rise to either stationary standing waves (seiches) or propagating traveling waves, a critical distinction for understanding energy transport in geophysical systems .",
            "id": "3786297",
            "problem": "Consider a one-dimensional, frictionless, constant-depth ocean channel of length $L$ and uniform depth $H$, governed by the linearized shallow-water equations for barotropic motion:\n$$\n\\frac{\\partial \\eta}{\\partial t} + H \\frac{\\partial u}{\\partial x} = 0, \\quad \\frac{\\partial u}{\\partial t} + g \\frac{\\partial \\eta}{\\partial x} = 0,\n$$\nwhere $\\eta(x,t)$ is the free-surface elevation, $u(x,t)$ is the depth-averaged velocity, and $g$ is the gravitational acceleration. Starting from these equations and without invoking any pre-derived modal formulas, do the following:\n\n1. Derive the normal-mode solutions and the dispersion relation by separation of variables, explaining the physical nature (standing versus traveling) of the modes that arise under different boundary conditions.\n\n2. For a closed basin with rigid walls at $x=0$ and $x=L$, impose the no-normal-flow boundary conditions $u(0,t) = 0$ and $u(L,t) = 0$. Determine the spatial structures and allowed wavenumbers. Show explicitly how the boundary conditions lead to standing seiche patterns, and discuss the phase relationship between $u$ and $\\eta$ as it relates to energy flux.\n\n3. For a periodic channel with $u(x+L,t) = u(x,t)$ and $\\eta(x+L,t) = \\eta(x,t)$, determine the allowed wavenumbers and characterize the corresponding solutions as traveling waves. Explain how the periodic boundary conditions permit energy-carrying modes.\n\nFinally, compute the dimensionless ratio $R$ of the fundamental (lowest-frequency) barotropic eigenfrequency in the closed basin to the fundamental barotropic traveling-wave frequency in the periodic channel of the same length $L$ and depth $H$. Express your final answer as a single dimensionless number. No rounding is required.",
            "solution": "The problem requires a systematic derivation of normal modes for one-dimensional shallow water waves under two distinct sets of boundary conditions, and a final comparison of their fundamental frequencies. The analysis will begin from the provided governing equations.\n\nThe linearized shallow-water equations for a one-dimensional, frictionless, constant-depth channel are given as:\n$$\n\\frac{\\partial \\eta}{\\partial t} + H \\frac{\\partial u}{\\partial x} = 0 \\quad (1)\n$$\n$$\n\\frac{\\partial u}{\\partial t} + g \\frac{\\partial \\eta}{\\partial x} = 0 \\quad (2)\n$$\nwhere $\\eta(x,t)$ is the free-surface elevation, $u(x,t)$ is the depth-averaged velocity, $H$ is the uniform depth, and $g$ is the gravitational acceleration.\n\n**1. Derivation of Normal Modes and Dispersion Relation**\n\nTo derive the normal-mode solutions, we first combine the two first-order partial differential equations (PDEs) into a single second-order PDE. We differentiate equation (1) with respect to $t$ and equation (2) with respect to $x$:\n$$\n\\frac{\\partial^2 \\eta}{\\partial t^2} + H \\frac{\\partial^2 u}{\\partial t \\partial x} = 0\n$$\n$$\n\\frac{\\partial^2 u}{\\partial x \\partial t} + g \\frac{\\partial^2 \\eta}{\\partial x^2} = 0\n$$\nAssuming $\\eta$ and $u$ are sufficiently smooth such that the order of differentiation can be interchanged (Schwarz's theorem), we have $\\frac{\\partial^2 u}{\\partial t \\partial x} = \\frac{\\partial^2 u}{\\partial x \\partial t}$. Substituting the expression for the mixed partial derivative from the second equation into the first gives:\n$$\n\\frac{\\partial^2 \\eta}{\\partial t^2} - gH \\frac{\\partial^2 \\eta}{\\partial x^2} = 0\n$$\nThis is the classical wave equation, $\\frac{\\partial^2 \\eta}{\\partial t^2} = c^2 \\frac{\\partial^2 \\eta}{\\partial x^2}$, with a wave phase speed $c = \\sqrt{gH}$.\n\nWe seek normal-mode solutions using the method of separation of variables. Let $\\eta(x,t) = \\hat{\\eta}(x) T(t)$. Substituting this into the wave equation yields:\n$$\n\\hat{\\eta}(x) \\frac{d^2 T}{dt^2} = c^2 T(t) \\frac{d^2 \\hat{\\eta}}{dx^2}\n$$\nDividing by $\\hat{\\eta}(x)T(t)$ and rearranging, we separate the variables:\n$$\n\\frac{1}{c^2 T(t)} \\frac{d^2 T}{dt^2} = \\frac{1}{\\hat{\\eta}(x)} \\frac{d^2 \\hat{\\eta}}{dx^2}\n$$\nSince the left side is a function of $t$ only and the right side is a function of $x$ only, both must be equal to a constant. For oscillatory (wave-like) solutions, this constant must be negative. We denote it by $-k^2$, where $k$ is the wavenumber. This gives two ordinary differential equations:\n$$\n\\frac{d^2 T}{dt^2} + (kc)^2 T = 0\n$$\n$$\n\\frac{d^2 \\hat{\\eta}}{dx^2} + k^2 \\hat{\\eta} = 0\n$$\nThe temporal equation has solutions of the form $T(t) \\propto \\exp(\\pm i \\omega t)$, where the angular frequency $\\omega$ is related to the wavenumber $k$ by:\n$$\n\\omega^2 = (kc)^2 \\implies \\omega = \\pm ck = \\pm k\\sqrt{gH}\n$$\nThis is the dispersion relation for shallow-water waves. It shows that the frequency is linearly proportional to the wavenumber, meaning the waves are non-dispersive: all waves travel at the same phase speed $c = \\sqrt{gH}$, regardless of their wavelength.\n\nThe spatial equation has general solutions of the form $\\hat{\\eta}(x) = A \\cos(kx) + B \\sin(kx)$. The specific values of $k$ and the constants $A$ and $B$ are determined by the boundary conditions.\nThe general solution for $\\eta(x,t)$ is a superposition of modes, which can be expressed as traveling waves $\\exp(i(kx \\pm \\omega t))$ or as standing waves which are superpositions of these traveling waves. The boundary conditions dictate which form is physically realized.\n\n**2. Closed Basin (Seiche Modes)**\n\nFor a closed basin of length $L$, the boundary conditions are no-normal-flow at the rigid walls, $u(0,t)=0$ and $u(L,t)=0$. To apply these conditions, we must find the velocity field $u(x,t)$ corresponding to our solution for $\\eta(x,t)$. Assuming a harmonic time dependence $\\exp(-i\\omega t)$ for both fields, equations (1) and (2) become:\n$$\n-i\\omega \\hat{\\eta} + H \\frac{d\\hat{u}}{dx} = 0\n$$\n$$\n-i\\omega \\hat{u} + g \\frac{d\\hat{\\eta}}{dx} = 0 \\implies \\hat{u} = \\frac{g}{i\\omega} \\frac{d\\hat{\\eta}}{dx}\n$$\nWith $\\hat{\\eta}(x) = A \\cos(kx) + B \\sin(kx)$, we have $\\frac{d\\hat{\\eta}}{dx} = -Ak \\sin(kx) + Bk \\cos(kx)$.\nThus, the spatial structure of the velocity is:\n$$\n\\hat{u}(x) = \\frac{gk}{i\\omega} (-A \\sin(kx) + B \\cos(kx))\n$$\nApplying the boundary condition at $x=0$:\n$$\n\\hat{u}(0) = \\frac{gk}{i\\omega} (B) = 0 \\implies B=0\n$$\nThis implies that the spatial structure for elevation must be purely cosine-like, $\\hat{\\eta}(x) = A \\cos(kx)$, and the velocity structure must be sine-like, $\\hat{u}(x) = - A \\frac{gk}{i\\omega} \\sin(kx)$.\n\nNow, applying the boundary condition at $x=L$:\n$$\n\\hat{u}(L) = - A \\frac{gk}{i\\omega} \\sin(kL) = 0\n$$\nFor a non-trivial solution ($A \\neq 0$), we must have $\\sin(kL) = 0$. This condition quantizes the allowed wavenumbers:\n$$\nkL = n\\pi, \\quad \\text{for } n=1, 2, 3, \\dots\n$$\nThe allowed wavenumbers are $k_n = \\frac{n\\pi}{L}$. The case $n=0$ implies $k=0$, which gives $\\hat{u}(x) \\equiv 0$ and $\\hat{\\eta}(x) = \\text{constant}$. This corresponds to a uniform raising or lowering of the water level with zero velocity and zero frequency, which is not a dynamic mode. The lowest-frequency dynamic mode is for $n=1$.\n\nThe full solutions for the normal modes (seiches) are:\n$$\n\\eta_n(x,t) = A_n \\cos\\left(\\frac{n\\pi x}{L}\\right) \\cos(\\omega_n t + \\phi_n)\n$$\n$$\nu_n(x,t) = \\frac{g k_n A_n}{\\omega_n} \\sin\\left(\\frac{n\\pi x}{L}\\right) \\sin(\\omega_n t + \\phi_n) = \\frac{c A_n}{H} \\sin\\left(\\frac{n\\pi x}{L}\\right) \\sin(\\omega_n t + \\phi_n)\n$$\nwhere $\\omega_n = c k_n = \\frac{n\\pi\\sqrt{gH}}{L}$.\n\nThe solutions are standing waves. The spatial patterns, $\\cos(k_n x)$ for $\\eta$ and $\\sin(k_n x)$ for $u$, are fixed, and their amplitudes oscillate in time. Note the quadrature phase relationship ($\\pi/2$ shift) between $\\eta$ and $u$ in time. When elevation is maximum (at turning points of the slosh), velocity is zero. When velocity is maximum (at mid-slosh), the surface is flat ($\\eta=0$). This signifies an oscillation between potential energy (proportional to $\\eta^2$) and kinetic energy (proportional to $u^2$). The time-averaged energy flux, which is proportional to $\\langle \\eta u \\rangle$, is zero, as $\\langle \\cos(\\omega t) \\sin(\\omega t) \\rangle = 0$. No net energy is propagated.\n\n**3. Periodic Channel (Traveling Waves)**\n\nFor a periodic channel, the boundary conditions require that the solution be periodic over the length $L$: $u(x+L,t) = u(x,t)$ and $\\eta(x+L,t) = \\eta(x,t)$. It is most natural to use complex exponential forms for the spatial part of the solution, $\\hat{\\eta}(x) = A\\exp(ikx)$ and $\\hat{u}(x) = \\hat{U}\\exp(ikx)$, which represent traveling waves.\nApplying the periodicity condition to $\\hat{\\eta}(x)$:\n$$\nA\\exp(ik(x+L)) = A\\exp(ikx) \\implies \\exp(ikL) = 1\n$$\nThis is satisfied if $kL$ is an integer multiple of $2\\pi$:\n$$\nkL = 2n\\pi, \\quad \\text{for } n \\in \\mathbb{Z} \\text{ (any integer)}\n$$\nThe allowed wavenumbers are $k_n = \\frac{2n\\pi}{L}$. Positive integers $n$ correspond to waves traveling in the $+x$ direction, and negative integers correspond to waves traveling in the $-x$ direction. $n=0$ is again the zero-frequency, constant-state mode.\n\nThe solutions are traveling waves of the form:\n$$\n\\eta_n(x,t) = A_n \\exp\\left(i\\left(\\frac{2n\\pi x}{L} - \\omega_n t\\right)\\right)\n$$\nwhere $\\omega_n = c |k_n| = \\frac{2|n|\\pi\\sqrt{gH}}{L}$. In contrast to the closed basin, the periodic boundary conditions allow for modes that continuously propagate energy. To see this, we find the corresponding velocity $u$. Taking the real part of the solutions for a wave traveling in the $+x$ direction ($n>0$):\n$$\n\\eta(x,t) = A \\cos(kx - \\omega t)\n$$\nFrom $\\partial u/\\partial t = -g \\partial \\eta/\\partial x = -g(-kA\\sin(kx-\\omega t))$, we integrate to get:\n$$\nu(x,t) = \\frac{gk}{\\omega} A \\cos(kx - \\omega t) = \\frac{g}{c} A \\cos(kx-\\omega t) = \\sqrt{\\frac{g}{H}} \\eta(x,t)\n$$\nHere, $u$ and $\\eta$ are in phase. The time-averaged energy flux is proportional to $\\langle \\eta u \\rangle = \\sqrt{\\frac{g}{H}} \\langle \\eta^2 \\rangle$. Since $\\langle \\cos^2(\\cdot) \\rangle = 1/2$, the time-averaged flux is non-zero, indicating a net transport of energy in the direction of wave propagation.\n\n**Computation of the Frequency Ratio R**\n\nWe need to find the ratio $R$ of the fundamental eigenfrequency in the closed basin to that in the periodic channel. The \"fundamental\" frequency is the lowest non-zero frequency.\n\n-   **Closed Basin Fundamental Frequency ($\\omega_{closed, fund}$)**: This corresponds to the mode $n=1$.\n    The wavenumber is $k_{closed, fund} = \\frac{\\pi}{L}$.\n    The frequency is $\\omega_{closed, fund} = c \\cdot k_{closed, fund} = \\sqrt{gH} \\frac{\\pi}{L}$.\n\n-   **Periodic Channel Fundamental Frequency ($\\omega_{periodic, fund}$)**: The fundamental traveling-wave frequency corresponds to the smallest non-zero magnitude of the wavenumber, which is for $n=\\pm 1$.\n    The wavenumber is $|k_{periodic, fund}| = \\frac{2\\pi}{L}$.\n    The frequency is $\\omega_{periodic, fund} = c \\cdot |k_{periodic, fund}| = \\sqrt{gH} \\frac{2\\pi}{L}$.\n\n-   **Ratio $R$**:\n    $$\n    R = \\frac{\\omega_{closed, fund}}{\\omega_{periodic, fund}} = \\frac{\\sqrt{gH} \\frac{\\pi}{L}}{\\sqrt{gH} \\frac{2\\pi}{L}} = \\frac{\\frac{\\pi}{L}}{\\frac{2\\pi}{L}}\n    $$\n    $$\n    R = \\frac{\\pi}{2\\pi} = \\frac{1}{2}\n    $$\nThe physical interpretation is that the fundamental mode in a closed basin has a wavelength of $\\lambda = 2L$ (half a wavelength fits in the basin), while the fundamental mode in a periodic channel has a wavelength of $\\lambda=L$ (one full wavelength fits into the domain). Since frequency is inversely proportional to wavelength for a constant phase speed ($\\omega = c k = c \\frac{2\\pi}{\\lambda}$), the frequency for the closed basin mode is half that of the periodic channel mode.",
            "answer": "$$\\boxed{\\frac{1}{2}}$$"
        },
        {
            "introduction": "While closed and periodic domains are idealizations, many real-world modeling tasks involve carving out a finite region from a much larger, effectively open, domain. This practice addresses the critical challenge of implementing such \"open\" boundaries by designing a numerical sponge layer to absorb incident waves and prevent spurious reflections. You will use asymptotic analysis to derive the performance characteristics of the sponge, providing a quantitative link between the model's damping parameters and its effectiveness as an open boundary condition .",
            "id": "3786386",
            "problem": "Consider a one-dimensional barotropic gravity wave in an ocean model with spatial coordinate $x \\in [0,L]$, governed by the linear wave equation with Rayleigh damping,\n$$\n\\partial_{t}^{2}\\eta(x,t) + 2\\,\\gamma(x)\\,\\partial_{t}\\eta(x,t) = c^{2}\\,\\partial_{x}^{2}\\eta(x,t),\n$$\nwhere $\\eta(x,t)$ is the free-surface elevation, $c>0$ is the non-dispersive phase speed, and $\\gamma(x) \\ge 0$ is a spatially varying damping rate representing a sponge layer used to emulate an open boundary. The right boundary at $x=L$ is physically closed (rigid-wall reflector), so in the absence of damping the reflection amplitude is unity. A sponge layer of thickness $d$ is placed adjacent to the wall, occupying $x \\in [L-d,L]$. Outside the sponge layer, $\\gamma(x)=0$ for $x \\in [0,L-d)$.\n\nAssume an incoming, rightward-propagating wave with angular frequency $\\omega>0$ that is weakly damped in the sponge layer in the sense that $0 \\le \\gamma(x) \\ll \\omega$ for all $x \\in [L-d,L]$. Under this scale separation, the Wentzel–Kramers–Brillouin (WKB) approximation is valid for the slowly varying envelope. Let the sponge profile be quadratic,\n$$\n\\gamma(x) = \\sigma_{0}\\left(\\frac{x-(L-d)}{d}\\right)^{2}, \\quad x \\in [L-d,L],\n$$\nwith constant $\\sigma_{0} > 0$.\n\nStarting from the governing equation above and the definition of a closed boundary at $x=L$, derive the spatial attenuation of the wave amplitude through the sponge via appropriate asymptotic analysis and obtain an expression for the absorption length scale $L_{a}$ that characterizes the quadratic sponge in the sense that the round-trip reflection amplitude at $x=L$ is reduced approximately according to\n$$\nR \\approx \\exp\\!\\left(-\\frac{2d}{L_{a}}\\right).\n$$\nThen, using the derived $L_{a}$, determine the minimum sponge thickness $d_{\\min}$ required so that the reflected amplitude observed at the entrance of the sponge ($x=L-d$) satisfies $R \\le R_{\\max}$, for the following physically consistent parameter choices:\n- Wave speed $c = 50\\,\\mathrm{m\\,s^{-1}}$,\n- Maximum damping rate $\\sigma_{0} = 0.1\\,\\mathrm{s^{-1}}$,\n- Reflection threshold $R_{\\max} = 10^{-2}$.\n\nRound your final numeric answer for $d_{\\min}$ to four significant figures and express it in $\\mathrm{m}$.",
            "solution": "The analysis begins with the governing one-dimensional linear wave equation with Rayleigh damping:\n$$\n\\partial_{t}^{2}\\eta(x,t) + 2\\,\\gamma(x)\\,\\partial_{t}\\eta(x,t) = c^{2}\\,\\partial_{x}^{2}\\eta(x,t)\n$$\nWe consider a time-harmonic wave solution of the form $\\eta(x,t) = \\text{Re}[\\hat{\\eta}(x) e^{-i\\omega t}]$, where $\\hat{\\eta}(x)$ is the complex spatial amplitude and $\\omega > 0$ is the angular frequency. Substituting this into the governing equation yields an ordinary differential equation for $\\hat{\\eta}(x)$:\n$$\n(-\\omega^2 \\hat{\\eta}) + 2\\gamma(x)(-i\\omega \\hat{\\eta}) = c^2 \\frac{d^2\\hat{\\eta}}{dx^2}\n$$\nRearranging this gives a Helmholtz-like equation:\n$$\n\\frac{d^2\\hat{\\eta}}{dx^2} + \\frac{\\omega^2 + 2i\\omega\\gamma(x)}{c^2} \\hat{\\eta}(x) = 0\n$$\nThis can be written as $\\frac{d^2\\hat{\\eta}}{dx^2} + k^2(x)\\hat{\\eta}(x) = 0$, where $k(x)$ is the complex and spatially varying wavenumber:\n$$\nk^2(x) = \\frac{\\omega^2}{c^2} \\left( 1 + \\frac{2i\\gamma(x)}{\\omega} \\right)\n$$\nThe problem states that the damping is weak, $\\gamma(x) \\ll \\omega$, which allows for simplification of $k(x)$. Using the binomial approximation $(1+z)^{1/2} \\approx 1 + \\frac{1}{2}z$ for small $|z|$, where $z = \\frac{2i\\gamma(x)}{\\omega}$:\n$$\nk(x) = \\frac{\\omega}{c} \\left( 1 + \\frac{2i\\gamma(x)}{\\omega} \\right)^{1/2} \\approx \\frac{\\omega}{c} \\left( 1 + \\frac{1}{2} \\frac{2i\\gamma(x)}{\\omega} \\right) = \\frac{\\omega}{c} \\left( 1 + i \\frac{\\gamma(x)}{\\omega} \\right)\n$$\nThus, the complex wavenumber can be expressed as $k(x) = k_r + i k_i(x)$, where the real part is $k_r = \\omega/c$ (the wavenumber in the undamped medium) and the imaginary part is $k_i(x) = \\frac{\\gamma(x)}{c}$.\n\nThe Wentzel–Kramers–Brillouin (WKB) approximation for a solution to $\\hat{\\eta}'' + k^2(x)\\hat{\\eta} = 0$ is given by a superposition of rightward- and leftward-propagating waves. The spatial part of a rightward-propagating wave has the form $\\hat{\\eta}_{+}(x) \\propto \\exp\\left(i \\int^x k(x') dx'\\right)$. The amplitude is modulated by the imaginary part of $k(x)$.\n$$\ni \\int^x k(x') dx' = i \\int^x \\left(\\frac{\\omega}{c} + i\\frac{\\gamma(x')}{c}\\right) dx' = i \\frac{\\omega}{c} x - \\int^x \\frac{\\gamma(x')}{c} dx'\n$$\nThe amplitude of the wave is affected by the term $\\exp\\left(-\\int \\frac{\\gamma(x')}{c} dx'\\right)$.\n\nAn incoming wave with amplitude $A_{in}$ at the entrance of the sponge layer ($x=L-d$) propagates to the rigid wall at $x=L$. Its amplitude at the wall is attenuated:\n$$\nA_{wall} = A_{in} \\exp\\left( - \\int_{L-d}^{L} k_i(x) dx \\right) = A_{in} \\exp\\left( - \\frac{1}{c} \\int_{L-d}^{L} \\gamma(x) dx \\right)\n$$\nAt the rigid wall $x=L$, the wave is perfectly reflected. The reflected wave then propagates back from $x=L$ to $x=L-d$, experiencing the same attenuation. The amplitude of the reflected wave as it exits the sponge layer is:\n$$\nA_{out} = A_{wall} \\exp\\left( - \\frac{1}{c} \\int_{L-d}^{L} \\gamma(x) dx \\right) = A_{in} \\exp\\left( - \\frac{2}{c} \\int_{L-d}^{L} \\gamma(x) dx \\right)\n$$\nThe reflection coefficient $R$ is the ratio of the outgoing amplitude to the incoming amplitude at $x=L-d$:\n$$\nR = \\frac{A_{out}}{A_{in}} = \\exp\\left( - \\frac{2}{c} \\int_{L-d}^{L} \\gamma(x) dx \\right)\n$$\nNext, we evaluate the integral using the given quadratic profile for the damping rate $\\gamma(x) = \\sigma_{0}\\left(\\frac{x-(L-d)}{d}\\right)^{2}$ for $x \\in [L-d,L]$. Let $u = x - (L-d)$, so $du = dx$. The limits of integration become $u=0$ at $x=L-d$ and $u=d$ at $x=L$.\n$$\n\\int_{L-d}^{L} \\gamma(x) dx = \\int_{0}^{d} \\sigma_{0} \\left(\\frac{u}{d}\\right)^2 du = \\frac{\\sigma_0}{d^2} \\int_{0}^{d} u^2 du = \\frac{\\sigma_0}{d^2} \\left[ \\frac{u^3}{3} \\right]_0^d = \\frac{\\sigma_0 d^3}{3d^2} = \\frac{\\sigma_0 d}{3}\n$$\nSubstituting this result into the expression for $R$:\n$$\nR = \\exp\\left(-\\frac{2}{c} \\frac{\\sigma_0 d}{3}\\right) = \\exp\\left(-\\frac{2\\sigma_0 d}{3c}\\right)\n$$\nThe problem defines the absorption length scale $L_a$ such that $R \\approx \\exp(-2d/L_a)$. Comparing our derived expression for $R$ with this definition, we can identify $L_a$:\n$$\n\\frac{2d}{L_a} = \\frac{2\\sigma_0 d}{3c} \\implies L_a = \\frac{3c}{\\sigma_0}\n$$\nThe final task is to find the minimum sponge thickness $d_{min}$ such that the reflection coefficient $R$ is no more than a specified value $R_{max}$. We set our expression for $R$ equal to $R_{max}$ for the minimum thickness:\n$$\n\\exp\\left(-\\frac{2\\sigma_0 d_{min}}{3c}\\right) = R_{max}\n$$\nSolving for $d_{min}$, we take the natural logarithm of both sides:\n$$\n-\\frac{2\\sigma_0 d_{min}}{3c} = \\ln(R_{max})\n$$\n$$\nd_{min} = -\\frac{3c}{2\\sigma_0} \\ln(R_{max}) = \\frac{3c}{2\\sigma_0} \\ln\\left(\\frac{1}{R_{max}}\\right)\n$$\nNow, we substitute the given physical parameters: $c = 50\\,\\mathrm{m\\,s^{-1}}$, $\\sigma_0 = 0.1\\,\\mathrm{s^{-1}}$, and $R_{max} = 10^{-2}$.\n$$\nd_{min} = -\\frac{3 \\times 50}{2 \\times 0.1} \\ln(10^{-2})\n$$\n$$\nd_{min} = -\\frac{150}{0.2} (\\ln(1) - \\ln(10^2)) = -750 (-2 \\ln(10)) = 1500 \\ln(10)\n$$\nUsing the value $\\ln(10) \\approx 2.30258509...$, we calculate the numerical value for $d_{min}$:\n$$\nd_{min} \\approx 1500 \\times 2.30258509 = 3453.877635\\,\\mathrm{m}\n$$\nRounding this result to four significant figures as required gives:\n$$\nd_{min} \\approx 3454\\,\\mathrm{m}\n$$",
            "answer": "$$\\boxed{3454}$$"
        },
        {
            "introduction": "Translating physical boundary conditions into a robust numerical algorithm requires careful attention to the details of the computational grid. This exercise moves from theory to practice, tasking you with implementing periodic boundary conditions on an Arakawa C-grid, which is a standard for ocean and atmospheric models due to its favorable conservation properties. By developing and verifying two equivalent implementations—one based on halo cells and another on modular arithmetic—you will gain hands-on experience with the precise indexing required to correctly handle staggered variables at domain edges .",
            "id": "3786271",
            "problem": "Consider a two-dimensional Arakawa C-grid discretization used in computational oceanography. Let the grid have $N_x$ interior tracer cells in the $x$-direction and $N_y$ interior tracer cells in the $y$-direction. The physical cell sizes are $d_x$ in meters and $d_y$ in meters. Tracer cell centers are indexed by $(j,i)$ with $j \\in \\{1,\\dots,N_y\\}$ (row index increasing upward) and $i \\in \\{1,\\dots,N_x\\}$ (column index increasing to the right). The prognostic tracer variable at cell centers is $T$, the zonal velocity at vertical faces is $u$, and the meridional velocity at horizontal faces is $v$. On an Arakawa C-grid, $u$ is defined at locations $(j,i+\\tfrac{1}{2})$ for $j \\in \\{1,\\dots,N_y\\}$ and $i \\in \\{0,\\dots,N_x\\}$, while $v$ is defined at $(j+\\tfrac{1}{2},i)$ for $j \\in \\{0,\\dots,N_y\\}$ and $i \\in \\{1,\\dots,N_x\\}$.\n\nTo perform flux computations near boundaries efficiently, model codes commonly maintain a one-cell-wide halo (also called a ghost cell layer) around each array. For the cell-centered tracer field $T$, the halo-augmented array has indices $(j,i)$ with $j \\in \\{0,\\dots,N_y+1\\}$ and $i \\in \\{0,\\dots,N_x+1\\}$, where indices $j=1,\\dots,N_y$ and $i=1,\\dots,N_x$ refer to the interior cells. For the zonal velocity $u$, the halo-augmented array has $j \\in \\{0,\\dots,N_y+1\\}$ and $i \\in \\{0,\\dots,N_x+2\\}$, with interior $j=1,\\dots,N_y$ and $i=1,\\dots,N_x+1$. For the meridional velocity $v$, the halo-augmented array has $j \\in \\{0,\\dots,N_y+2\\}$ and $i \\in \\{0,\\dots,N_x+1\\}$, with interior $j=1,\\dots,N_y+1$ and $i=1,\\dots,N_x$.\n\nAssume the tracer obeys the conservative advection equation\n$$\n\\frac{\\partial T}{\\partial t} + \\nabla \\cdot (\\mathbf{U} T) = 0,\n$$\nwhere $\\mathbf{U} = (u, v)$ is the velocity vector. On the Arakawa C-grid with central averaging to faces, a single forward Euler time step of size $\\Delta t$ for interior cell $(j,i)$ is\n$$\nT^{n+1}_{j,i} = T^{n}_{j,i} - \\Delta t \\left[ \\frac{F^{x}_{j,i+\\frac{1}{2}} - F^{x}_{j,i-\\frac{1}{2}}}{d_x} + \\frac{F^{y}_{j+\\frac{1}{2},i} - F^{y}_{j-\\frac{1}{2},i}}{d_y} \\right],\n$$\nwith face fluxes\n$$\nF^{x}_{j,i+\\frac{1}{2}} = u_{j,i+\\frac{1}{2}} \\, \\widetilde{T}_{j,i+\\frac{1}{2}}, \\quad \\widetilde{T}_{j,i+\\frac{1}{2}} = \\frac{1}{2}\\left(T_{j,i} + T_{j,i+1}\\right),\n$$\n$$\nF^{y}_{j+\\frac{1}{2},i} = v_{j+\\frac{1}{2},i} \\, \\widetilde{T}_{j+\\frac{1}{2},i}, \\quad \\widetilde{T}_{j+\\frac{1}{2},i} = \\frac{1}{2}\\left(T_{j,i} + T_{j+1,i}\\right).\n$$\n\nYou must implement two equivalent realizations of periodic boundary conditions on this staggered grid:\n\n- A halo-based realization: Copy values from the opposite boundary into the halo so that the discrete fields wrap in $x$ and $y$ consistently. For the scalar $T$, this means\n$$\nT_{j,0} = T_{j,N_x}, \\quad T_{j,N_x+1} = T_{j,1}, \\quad T_{0,i} = T_{N_y,i}, \\quad T_{N_y+1,i} = T_{1,i},\n$$\nfor all valid interior $i$ and $j$, together with consistent corner fills such as\n$$\nT_{0,0} = T_{N_y,N_x}, \\quad T_{0,N_x+1} = T_{N_y,1}, \\quad T_{N_y+1,0} = T_{1,N_x}, \\quad T_{N_y+1,N_x+1} = T_{1,1}.\n$$\nAnalogous equalities must be applied to the halo-augmented $u$ and $v$ arrays, with correct index ranges according to their staggering.\n\n- A modular-index realization: Compute face fluxes using interior indices with modular arithmetic, that is,\n$$\ni_{-} = (i-1) \\bmod N_x, \\quad i_{+} = (i+1) \\bmod N_x, \\quad j_{-} = (j-1) \\bmod N_y, \\quad j_{+} = (j+1) \\bmod N_y,\n$$\nand face velocity indices $i \\in \\{0,\\dots,N_x\\}$ and $j \\in \\{0,\\dots,N_y\\}$ treated with modular wrap in the obvious way. This realization does not use halos.\n\nYour task is to write a complete program that:\n- Constructs interior arrays for $T$, $u$, and $v$ and their halo-augmented counterparts, with consistent Arakawa C-grid staggering and one-cell halos.\n- Initializes $T$ at cell centers to the sum of two Gaussian anomalies, one near the top-right corner and one near another boundary, to exercise corners and edges. Initializes $u$ and $v$ to constant values (in meters per second).\n- Implements periodic halo fills for $T$, $u$, and $v$ in both directions, including correct corner values.\n- Computes one forward Euler update of $T$ using the halo-based flux divergence and separately computes the same update using the modular-index realization without halos.\n- Computes the maximum absolute difference over all interior cells between the two updated tracer fields $T^{n+1}$ produced by the two realizations.\n- Verifies boolean equalities that the halo fills are exactly consistent for $T$, $u$, and $v$ (including side halos and corner halos).\n\nScientific base and constraints:\n- Use the conservation law and the discrete central-face averaging stated above as the base for flux computation. Do not introduce any other advection schemes.\n- Periodicity must be enforced strictly in both $x$ and $y$, and halo corners must be set consistently.\n- All physical parameters must be realistic and self-consistent.\n\nUnits and outputs:\n- The velocities $u$ and $v$ must be interpreted in meters per second, spacings $d_x$ and $d_y$ in meters, and the time step $\\Delta t$ in seconds.\n- The final numerical error metric is dimensionless (tracer units), computed as the maximum absolute difference between the two updates.\n- Booleans are unitless.\n\nTest suite:\nRun your program for the following parameter sets, each represented as $(N_x,N_y,d_x,d_y,u_0,v_0,\\Delta t)$:\n1. $(16,12,1000.0,1000.0,0.5,-0.3,300.0)$\n2. $(3,5,5000.0,7000.0,1.0,0.2,100.0)$\n3. $(1,1,10000.0,10000.0,0.0,0.0,50.0)$\n4. $(8,6,800.0,1200.0,-0.4,0.0,200.0)$\n5. $(7,7,1500.0,1500.0,0.0,0.6,100.0)$\n\nFor each test case, compute and return the list $[\\varepsilon, b_T, b_u, b_v]$ where $\\varepsilon$ is the maximum absolute difference between the halo-based and modular-index updates of $T^{n+1}$ over interior cells, $b_T$ is a boolean stating whether $T$'s halo equality tests (sides and corners) are all satisfied, and $b_u$ and $b_v$ are analogous booleans for $u$ and $v$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list in the order given above. For example, the output should look like\n$[ [\\varepsilon_1,b_{T,1},b_{u,1},b_{v,1}], [\\varepsilon_2,b_{T,2},b_{u,2},b_{v,2}], \\dots ]$\nwith booleans printed as $True$ or $False$ and floating-point numbers in standard decimal notation.",
            "solution": "The task is to implement and compare two common numerical techniques for handling periodic boundary conditions on a staggered Arakawa C-grid: a halo-based exchange and a modular-indexing approach. The equivalence of these two methods is a fundamental concept in computational science, and verifying this equivalence serves as a stringent test of a correct implementation.\n\nWe will first establish the discrete grid structure and indexing conventions. The domain has $N_x \\times N_y$ interior tracer cells. We will use zero-based Python/NumPy array indexing.\n\nA scalar tracer field $T$ is defined at cell centers. An interior array for $T$ will have dimensions $(N_y, N_x)$. A halo-augmented array, `T_h`, will have dimensions $(N_y+2, N_x+2)$. The interior data is located at `T_h[1:N_y+1, 1:N_x+1]`.\n\nThe zonal velocity $u$ is staggered in the $x$-direction. An interior array for $u$ has dimensions $(N_y, N_x+1)$, representing velocities on the vertical faces of the tracer cells. The halo-augmented array, `u_h`, has dimensions $(N_y+2, N_x+3)$. The interior data is at `u_h[1:N_y+1, 1:N_x+2]`.\n\nThe meridional velocity $v$ is staggered in the $y$-direction. An interior array for $v$ has dimensions $(N_y+1, N_x)$, representing velocities on the horizontal faces. The halo-augmented array, `v_h`, has dimensions $(N_y+3, N_x+2)$. The interior data is at `v_h[1:N_y+2, 1:N_x+1]`.\n\nThe initial tracer field $T$ is specified as the sum of two Gaussian anomalies. For a grid cell $(j, i)$ with center coordinates $(x_i, y_j)$, the value is given by:\n$$\nT(x_i, y_j) = A_1 \\exp\\left(-\\frac{(x_i-x_{c1})^2}{2\\sigma_{x1}^2} - \\frac{(y_j-y_{c1})^2}{2\\sigma_{y1}^2}\\right) + A_2 \\exp\\left(-\\frac{(x_i-x_{c2})^2}{2\\sigma_{x2}^2} - \\frac{(y_j-y_{c2})^2}{2\\sigma_{y2}^2}\\right)\n$$\nWe select parameters to place one anomaly near the top-right corner and another near the left boundary to test all aspects of the periodic wrapping. Specifically, we choose centers $(x_{c1}, y_{c1}) = ((N_x-0.5)d_x, (N_y-0.5)d_y)$ and $(x_{c2}, y_{c2}) = (0, 0.5 N_y d_y)$. The widths $\\sigma$ are set to a fraction of the domain size, e.g., $\\sigma_x = N_x d_x / 10$ and $\\sigma_y = N_y d_y / 10$. The amplitudes $A_1, A_2$ are set to $1.0$. The velocities $u$ and $v$ are initialized to constant values $u_0$ and $v_0$, respectively.\n\nThe core of the problem is the comparison of two equivalent time-stepping algorithms based on the forward Euler scheme:\n$$\nT^{n+1}_{j,i} = T^{n}_{j,i} - \\Delta t \\left( \\frac{F^x_{j, i+1/2} - F^x_{j, i-1/2}}{d_x} + \\frac{F^y_{j+1/2, i} - F^y_{j-1/2, i}}{d_y} \\right)\n$$\nwhere fluxes are computed using central averaging:\n$$\nF^{x}_{j,i+1/2} = u_{j,i+1/2} \\frac{T_{j,i} + T_{j,i+1}}{2}, \\quad F^{y}_{j+1/2,i} = v_{j+1/2,i} \\frac{T_{j,i} + T_{j+1,i}}{2}\n$$\n\n**1. Halo-Based Realization**\n\nThis method uses arrays with a one-cell halo region surrounding the interior domain. Before computing fluxes, these halo cells are filled with data from the opposite side of the domain to enforce periodicity. For any field $\\phi$, the halo fills are performed as follows:\nFor a field like $T$ of interior size $(N_y, N_x)$ within a halo array of size $(N_y+2, N_x+2)$:\n- West halo from East boundary: `T_h[1:N_y+1, 0] = T_h[1:N_y+1, N_x]`\n- East halo from West boundary: `T_h[1:N_y+1, N_x+1] = T_h[1:N_y+1, 1]`\n- South halo from North boundary: `T_h[0, 1:N_x+1] = T_h[N_y, 1:N_x+1]`\n- North halo from South boundary: `T_h[N_y+1, 1:N_x+1] = T_h[1, 1:N_x+1]`\n\nThe corners are filled consistently. For instance, `T_h[0, 0] = T_h[N_y, N_x]`. A robust way to fill halos including corners is to perform the fills sequentially, e.g., fill the North/South halos across the full width, then fill the East/West halos across the full height. Analogous rules, adjusted for the different array dimensions and staggering, are applied to `u_h` and `v_h`.\n\nThe boolean verification checks `b_T, b_u, b_v` are performed by directly comparing arrays slices after the halo fill operation to confirm these equalities hold.\n\nWith the halos filled, the flux divergence for an interior cell `T_h[j, i]` (where `j` is in $1..N_y$ and `i` is in $1..N_x$) is computed using its direct neighbors. For example, the tracer value $T_{j,i-1}$ needed for the west-face flux is simply `T_h[j, i-1]`. If $i=1$, this index points to the west halo, `T_h[j, 0]`, which now contains the correct periodic value.\n\n**2. Modular-Index Realization**\n\nThis method operates on arrays representing only the interior domain. Periodicity is handled at the point of computation by using modular arithmetic on array indices.\nFor a tracer cell at index `(j, i)` (where `j` is in $0..N_y-1$ and `i` is in $0..N_x-1$), the indices of its neighbors are calculated as:\n- West neighbor: $i_W = (i - 1 + N_x) \\pmod{N_x}$\n- East neighbor: $i_E = (i + 1) \\pmod{N_x}$\n- South neighbor: $j_S = (j - 1 + N_y) \\pmod{N_y}$\n- North neighbor: $j_N = (j + 1) \\pmod{N_y}$\n\nThe fluxes are then computed using these wrapped indices for the tracer field. For cell `(j, i)`, the rightward flux depends on $T$ at `(j, i)` and `(j, i_E)`. The associated velocity `u_int[j, i+1]` is taken from the interior velocity array. Note that because of the staggering, the velocity arrays are one element larger in the staggered direction (`u` has $N_x+1$ points in $x$, `v` has $N_y+1$ points in $y$), so no modular arithmetic is needed for velocity indices when computing the tracer advection.\n\n**Equivalence and Verification**\n\nBoth methods are discrete realizations of the same physical problem with the same boundary conditions. Therefore, they must produce identical numerical results for the updated tracer field $T^{n+1}$. The maximum absolute difference $\\varepsilon$ over the interior domain between the results of the two methods should be on the order of machine floating-point precision (i.e., effectively zero). The boolean checks $b_T, b_u, b_v$ must evaluate to true, confirming the correctness of the halo-filling logic.\n\nThe following Python code implements this logic and runs the verification for the test suite.\n```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases.\n    \"\"\"\n    test_cases = [\n        # (Nx, Ny, dx, dy, u0, v0, dt)\n        (16, 12, 1000.0, 1000.0, 0.5, -0.3, 300.0),\n        (3, 5, 5000.0, 7000.0, 1.0, 0.2, 100.0),\n        (1, 1, 10000.0, 10000.0, 0.0, 0.0, 50.0),\n        (8, 6, 800.0, 1200.0, -0.4, 0.0, 200.0),\n        (7, 7, 1500.0, 1500.0, 0.0, 0.6, 100.0),\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_one_case(*params)\n        results.append(result)\n    \n    # Format the final output string\n    output_str = \"[\"\n    for i, res in enumerate(results):\n        eps, bt, bu, bv = res\n        output_str += f\"[{eps},{bt},{bu},{bv}]\"\n        if i  len(results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    # This is the line that should be printed to generate the answer.\n    # print(output_str)\n\ndef run_one_case(Nx, Ny, dx, dy, u0, v0, dt):\n    \"\"\"\n    Executes the simulation and comparison for a single parameter set.\n    \"\"\"\n    # 1. Initialize interior fields\n    T_int, u_int, v_int = initialize_fields(Nx, Ny, dx, dy, u0, v0)\n\n    # 2. Halo-based realization\n    T_result_halo, b_T, b_u, b_v = halo_based_update(\n        T_int.copy(), u_int.copy(), v_int.copy(), Nx, Ny, dx, dy, dt\n    )\n\n    # 3. Modular-index realization\n    T_result_mod = modular_index_update(\n        T_int.copy(), u_int.copy(), v_int.copy(), Nx, Ny, dx, dy, dt\n    )\n\n    # 4. Compare results\n    epsilon = np.max(np.abs(T_result_halo - T_result_mod))\n\n    return [epsilon, b_T, b_u, b_v]\n\ndef initialize_fields(Nx, Ny, dx, dy, u0, v0):\n    \"\"\"\n    Initializes T, u, and v fields.\n    \"\"\"\n    # T field at cell centers\n    T_int = np.zeros((Ny, Nx))\n    x_T = (np.arange(Nx) + 0.5) * dx\n    y_T = (np.arange(Ny) + 0.5) * dy\n    \n    Lx, Ly = Nx * dx, Ny * dy\n    sigma_x, sigma_y = Lx / 10.0, Ly / 10.0\n\n    # Gaussian 1: near top-right corner\n    xc1, yc1 = (Nx - 0.5) * dx, (Ny - 0.5) * dy\n    # Gaussian 2: near left-center boundary\n    xc2, yc2 = 0.0, 0.5 * Ly\n    \n    for j in range(Ny):\n        for i in range(Nx):\n            # First Gaussian (periodic distance for center 2)\n            dist_sq1 = ((x_T[i] - xc1)**2 / (2 * sigma_x**2)) + \\\n                       ((y_T[j] - yc1)**2 / (2 * sigma_y**2))\n            \n            # Second Gaussian: handle periodic distance in x\n            dx_p = min(abs(x_T[i] - xc2), Lx - abs(x_T[i] - xc2))\n            dist_sq2 = (dx_p**2 / (2 * sigma_x**2)) + \\\n                       ((y_T[j] - yc2)**2 / (2 * sigma_y**2))\n\n            T_int[j, i] = np.exp(-dist_sq1) + np.exp(-dist_sq2)\n\n    # u field at vertical faces\n    u_int = np.full((Ny, Nx + 1), u0)\n    \n    # v field at horizontal faces\n    v_int = np.full((Ny + 1, Nx), v0)\n    \n    return T_int, u_int, v_int\n\ndef fill_and_verify_halos(T_h, u_h, v_h, Nx, Ny):\n    \"\"\"\n    Fills halo regions for T, u, v and verifies the fills.\n    \"\"\"\n    # --- Fill Halos for T (Ny+2, Nx+2) ---\n    T_h[0, :] = T_h[Ny, :]       # South from North\n    T_h[Ny+1, :] = T_h[1, :]     # North from South\n    T_h[:, 0] = T_h[:, Nx]       # West from East\n    T_h[:, Nx+1] = T_h[:, 1]     # East from West\n\n    # --- Verify Halos for T ---\n    b_T = all([\n        np.all(T_h[1:Ny+1, 0] == T_h[1:Ny+1, Nx]),     # West\n        np.all(T_h[1:Ny+1, Nx+1] == T_h[1:Ny+1, 1]),   # East\n        np.all(T_h[0, 1:Nx+1] == T_h[Ny, 1:Nx+1]),     # South\n        np.all(T_h[Ny+1, 1:Nx+1] == T_h[1, 1:Nx+1]),   # North\n        T_h[0, 0] == T_h[Ny, Nx],                     # SW corner\n        T_h[0, Nx+1] == T_h[Ny, 1],                   # SE corner\n        T_h[Ny+1, 0] == T_h[1, Nx],                   # NW corner\n        T_h[Ny+1, Nx+1] == T_h[1, 1],                 # NE corner\n    ])\n\n    # --- Fill halos for u (Ny+2, Nx+3) ---\n    u_h[0, :] = u_h[Ny, :]         # South from North\n    u_h[Ny+1, :] = u_h[1, :]       # North from South\n    u_h[:, 0] = u_h[:, Nx+1]       # West from East\n    u_h[:, Nx+2] = u_h[:, 1]       # East from West\n\n    # --- Verify halos for u ---\n    b_u = all([\n        np.all(u_h[1:Ny+1, 0] == u_h[1:Ny+1, Nx+1]),\n        np.all(u_h[1:Ny+1, Nx+2] == u_h[1:Ny+1, 1]),\n        np.all(u_h[0, :] == u_h[Ny, :]),\n        np.all(u_h[Ny+1, :] == u_h[1, :]),\n    ])\n\n    # --- Fill halos for v (Ny+3, Nx+2) ---\n    v_h[0, :] = v_h[Ny+1, :]       # South from North\n    v_h[Ny+2, :] = v_h[1, :]       # North from South\n    v_h[:, 0] = v_h[:, Nx]         # West from East\n    v_h[:, Nx+1] = v_h[:, 1]       # East from West\n    \n    # --- Verify halos for v ---\n    b_v = all([\n        np.all(v_h[:, 0] == v_h[:, Nx]),\n        np.all(v_h[:, Nx+1] == v_h[:, 1]),\n        np.all(v_h[0, 1:Nx+1] == v_h[Ny+1, 1:Nx+1]),\n        np.all(v_h[Ny+2, 1:Nx+1] == v_h[1, 1:Nx+1]),\n    ])\n\n    return b_T, b_u, b_v\n\n\ndef halo_based_update(T_int, u_int, v_int, Nx, Ny, dx, dy, dt):\n    \"\"\"\n    Computes one time step using halo-based boundary conditions.\n    \"\"\"\n    # Create halo-augmented arrays\n    T_h = np.zeros((Ny + 2, Nx + 2))\n    u_h = np.zeros((Ny + 2, Nx + 3))\n    v_h = np.zeros((Ny + 3, Nx + 2))\n\n    # Copy interior data\n    T_h[1:Ny+1, 1:Nx+1] = T_int\n    u_h[1:Ny+1, 1:Nx+2] = u_int\n    v_h[1:Ny+2, 1:Nx+1] = v_int\n    \n    # Fill halos and perform verification\n    b_T, b_u, b_v = fill_and_verify_halos(T_h, u_h, v_h, Nx, Ny)\n\n    # Compute update\n    T_new_h = T_h.copy()\n    for j in range(1, Ny + 1):\n        for i in range(1, Nx + 1):\n            # X-fluxes\n            Fx_east = u_h[j, i+1] * 0.5 * (T_h[j, i] + T_h[j, i+1])\n            Fx_west = u_h[j, i]   * 0.5 * (T_h[j, i] + T_h[j, i-1])\n            \n            # Y-fluxes\n            Fy_north = v_h[j+1, i] * 0.5 * (T_h[j, i] + T_h[j+1, i])\n            Fy_south = v_h[j, i]   * 0.5 * (T_h[j, i] + T_h[j-1, i])\n            \n            div_Fx = (Fx_east - Fx_west) / dx\n            div_Fy = (Fy_north - Fy_south) / dy\n            \n            T_new_h[j, i] = T_h[j, i] - dt * (div_Fx + div_Fy)\n\n    return T_new_h[1:Ny+1, 1:Nx+1], b_T, b_u, b_v\n\ndef modular_index_update(T_int, u_int, v_int, Nx, Ny, dx, dy, dt):\n    \"\"\"\n    Computes one time step using modular indexing for boundary conditions.\n    \"\"\"\n    T_new = T_int.copy()\n    # Using 0-based indexing for arrays\n    for j in range(Ny):\n        for i in range(Nx):\n            ip1 = (i + 1) % Nx\n            im1 = (i - 1 + Nx) % Nx\n            jp1 = (j + 1) % Ny\n            jm1 = (j - 1 + Ny) % Ny\n            \n            # X-fluxes\n            Fx_east = u_int[j, i+1] * 0.5 * (T_int[j, i] + T_int[j, ip1])\n            Fx_west = u_int[j, i]   * 0.5 * (T_int[j, i] + T_int[j, im1])\n\n            # Y-fluxes\n            Fy_north = v_int[j+1, i] * 0.5 * (T_int[j, i] + T_int[jp1, i])\n            Fy_south = v_int[j, i]   * 0.5 * (T_int[j, i] + T_int[jm1, i])\n            \n            div_Fx = (Fx_east - Fx_west) / dx\n            div_Fy = (Fy_north - Fy_south) / dy\n            \n            T_new[j, i] = T_int[j, i] - dt * (div_Fx + div_Fy)\n            \n    return T_new\n\nif __name__ == '__main__':\n    solve()\n```",
            "answer": "[[0.0,True,True,True],[0.0,True,True,True],[0.0,True,True,True],[0.0,True,True,True],[0.0,True,True,True]]"
        }
    ]
}