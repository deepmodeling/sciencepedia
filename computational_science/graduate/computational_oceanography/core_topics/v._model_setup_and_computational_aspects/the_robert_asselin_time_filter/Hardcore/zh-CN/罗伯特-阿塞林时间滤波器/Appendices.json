{
    "hands_on_practices": [
        {
            "introduction": "要真正理解一个数值滤波器，我们必须首先从数学上分析它如何改变数值模式中波的传播特性。本练习将引导你通过推导离散色散关系来获得这种基础性的理解。通过为有和没有Robert-Asselin滤波器的一维线性平流方程推导单步放大因子 $\\lambda$，你将亲手揭示该滤波器抑制计算波和影响物理波的根本机制。",
            "id": "3816242",
            "problem": "考虑一维线性平流方程 $u_{t} + c\\,u_{x} = 0$，其定义在空间间距为 $\\Delta x$、时间步长为 $\\Delta t$ 的均匀网格上。该场在空间上使用中心差分进行离散，在时间上使用蛙跳格式，并可选择性地应用 Robert–Asselin 时间滤波器 (RA)。设在网格点 $x_{j} = j\\,\\Delta x$ 和时间 $t^{n} = n\\,\\Delta t$ 上的离散状态为 $u_{j}^{n}$。蛙跳格式的更新由 $u_{x}$ 的中心差分近似和 $u_{t}$ 的时间中心近似定义。RA 滤波器的系数为 $\\epsilon \\in [0,1)$，并根据 Robert–Asselin 时间滤波器 (RA) 的标准做法，在每个蛙跳步之后应用于中间时间层，即将 $u_{j}^{n}$ 替换为 $u_{j}^{n} \\leftarrow u_{j}^{n} + \\epsilon\\,(u_{j}^{n+1} - 2 u_{j}^{n} + u_{j}^{n-1})$。\n\n采用简正模假设 $u_{j}^{n} = \\hat{u}\\,\\exp\\!\\big(i\\,k\\,x_{j}\\big)\\,\\lambda^{n}$，其中 $k$ 是连续波数，$\\kappa \\equiv k\\,\\Delta x$ 是无量纲网格波数，$\\lambda$ 是单步放大因子。定义库朗数 $\\mu \\equiv c\\,\\Delta t / \\Delta x$。从偏微分方程和上述离散化定义出发，推导单步放大因子 $\\lambda$ 作为 $\\mu$ 和 $\\kappa$ 的函数的闭式离散色散关系：\n- 不使用 Robert–Asselin 时间滤波器（即 $\\epsilon = 0$）。\n- 使用系数为 $\\epsilon$ 的 Robert–Asselin 时间滤波器。\n\n将两个最终关系表示为物理（平流）模态的放大因子的闭式解析表达式，用 $\\mu$、$\\kappa$ 和 $\\epsilon$ 表示。不要给出中间方程；只提供最终表达式。无需四舍五入，也无需报告单位。",
            "solution": "该问题要求推导使用蛙跳格式离散化的线性平流方程的离散色散关系，具体来说是单步放大因子 $\\lambda$，包括使用和不使用 Robert–Asselin (RA) 时间滤波器两种情况。\n\n一维线性平流方程由下式给出：\n$$\nu_{t} + c\\,u_{x} = 0\n$$\n其中 $u$ 是场变量，$t$ 是时间，$x$ 是空间坐标，$c$ 是恒定的平流速度。\n\n该问题在空间间距为 $\\Delta x$、时间步长为 $\\Delta t$ 的均匀网格上进行离散化。状态表示为 $u_j^n = u(j\\Delta x, n\\Delta t)$。蛙跳格式在时间上使用中心差分，空间导数则用中心差分近似：\n$$\n\\frac{u_j^{n+1} - u_j^{n-1}}{2\\Delta t} + c \\frac{u_{j+1}^n - u_{j-1}^n}{2\\Delta x} = 0\n$$\n这可以重新整理以表达新时间层 $n+1$ 上的状态：\n$$\nu_j^{n+1} = u_j^{n-1} - \\frac{c\\Delta t}{\\Delta x} (u_{j+1}^n - u_{j-1}^n)\n$$\n使用库朗数 $\\mu \\equiv c\\,\\Delta t / \\Delta x$ 的定义，更新规则变为：\n$$\nu_j^{n+1} = u_j^{n-1} - \\mu (u_{j+1}^n - u_{j-1}^n)\n$$\n为了分析此格式的稳定性和色散性，我们使用冯·诺依曼方法，将简正模假设 $u_j^n = \\hat{u}\\,\\exp\\!\\big(i\\,k\\,x_{j}\\big)\\,\\lambda^{n}$ 代入离散方程。这里 $i = \\sqrt{-1}$，$k$ 是波数，$\\lambda$ 是每时间步的放大因子，$\\hat{u}$ 是一个常数振幅。代入 $x_j=j\\Delta x$ 得到 $u_j^n = \\hat{u} \\lambda^n e^{ikj\\Delta x}$。\n\n将该假设代入离散方程：\n$$\n\\hat{u}\\lambda^{n+1} e^{ikj\\Delta x} = \\hat{u}\\lambda^{n-1} e^{ikj\\Delta x} - \\mu \\left( \\hat{u}\\lambda^{n} e^{ik(j+1)\\Delta x} - \\hat{u}\\lambda^{n} e^{ik(j-1)\\Delta x} \\right)\n$$\n除以 $\\hat{u}\\lambda^{n-1} e^{ikj\\Delta x}$（假设其不为零）：\n$$\n\\lambda^2 = 1 - \\mu \\lambda (e^{ik\\Delta x} - e^{-ik\\Delta x})\n$$\n使用恒等式 $e^{i\\theta} - e^{-i\\theta} = 2i\\sin\\theta$ 和无量纲波数 $\\kappa \\equiv k\\Delta x$ 的定义：\n$$\n\\lambda^2 = 1 - \\mu \\lambda (2i\\sin\\kappa)\n$$\n这给出了放大因子 $\\lambda$ 的特征多项式：\n$$\n\\lambda^2 + 2i\\mu\\sin(\\kappa)\\lambda - 1 = 0\n$$\n\n**情况1：不使用 Robert–Asselin 时间滤波器 ($\\epsilon = 0$)**\n\n这是标准的蛙跳格式。其特征方程是上面推导出的二次方程。我们求解 $\\lambda$：\n$$\n\\lambda = \\frac{-2i\\mu\\sin\\kappa \\pm \\sqrt{(2i\\mu\\sin\\kappa)^2 - 4(1)(-1)}}{2} = \\frac{-2i\\mu\\sin\\kappa \\pm \\sqrt{-4\\mu^2\\sin^2\\kappa + 4}}{2}\n$$\n$$\n\\lambda = -i\\mu\\sin\\kappa \\pm \\sqrt{1 - \\mu^2\\sin^2\\kappa}\n$$\n该方程产生 $\\lambda$ 的两个根，分别对应一个物理模态和一个计算模态。物理模态是近似真实解的解析放大因子的那个模态，即 $e^{-i\\omega\\Delta t} = e^{-ikc\\Delta t} = e^{-i\\mu\\kappa}$。对于小的 $\\mu$ 和 $\\kappa$，$e^{-i\\mu\\kappa} \\approx 1 - i\\mu\\kappa - \\frac{1}{2}(\\mu\\kappa)^2$。\n带有正号的根的泰勒展开是 $\\lambda \\approx -i\\mu\\kappa + (1 - \\frac{1}{2}\\mu^2\\kappa^2) = 1 - i\\mu\\kappa - \\frac{1}{2}\\mu^2\\kappa^2$，这与解析解的展开式相匹配。因此，物理模态是：\n$$\n\\lambda_{\\text{physical}} = -i\\mu\\sin\\kappa + \\sqrt{1 - \\mu^2\\sin^2\\kappa}\n$$\n\n**情况2：使用系数为 $\\epsilon$ 的 Robert–Asselin 时间滤波器**\n\nRA 滤波器是顺序应用的。首先，使用蛙跳步计算一个临时值 $u_j^{*,n+1}$。然后，使用这个临时值更新中心时间层 $u_j^n$ 的值。\n1.  **预报步 (蛙跳格式):** $u_j^{*,n+1} = u_j^{n-1} - \\mu(u_{j+1}^n - u_{j-1}^n)$\n2.  **校正步 (滤波器):** 值 $u_j^n$ 被替换为 $\\bar{u}_j^n = u_j^n + \\epsilon(u_j^{*,n+1} - 2u_j^n + u_j^{n-1})$。\n传递到下一个时间步的新状态由 $(\\bar{u}_j^n, u_j^{n+1})$ 组成，其中 $u_j^{n+1} = u_j^{*,n+1}$。\n\n我们对这个两阶段过程进行傅里叶分析。设 $\\hat{u}^n$ 是 $u_j^n$ 的傅里叶振幅。空间差分算子变为乘以 $2i\\sin\\kappa$。设 $\\sigma = \\mu\\sin\\kappa$。\n傅里叶空间中的系统是：\n1.  $\\hat{u}^{*,n+1} = \\hat{u}^{n-1} - 2i\\sigma \\hat{u}^n$\n2.  $\\bar{u}^n = \\hat{u}^n + \\epsilon(\\hat{u}^{*,n+1} - 2\\hat{u}^n + \\hat{u}^{n-1})$\n\n任何时刻的状态都可以用一个包含两个连续时间层振幅的向量来描述，$V_n = \\begin{pmatrix} \\hat{u}^n \\\\ \\hat{u}^{n-1} \\end{pmatrix}$。到下一个状态 $V_{n+1} = \\begin{pmatrix} \\hat{u}^{n+1} \\\\ \\bar{u}^n \\end{pmatrix}$ 的演化由一个矩阵 $G$ 给出：$V_{n+1} = G V_n$。\n$V_{n+1}$ 的分量是：\n$\\hat{u}^{n+1} = \\hat{u}^{*,n+1} = -2i\\sigma \\hat{u}^n + \\hat{u}^{n-1}$\n$\\bar{u}^n = \\hat{u}^n + \\epsilon((\\hat{u}^{n-1} - 2i\\sigma \\hat{u}^n) - 2\\hat{u}^n + \\hat{u}^{n-1}) = (1 - 2\\epsilon - 2i\\sigma\\epsilon)\\hat{u}^n + 2\\epsilon \\hat{u}^{n-1}$\n\n因此，放大矩阵 $G$ 为：\n$$\nG = \\begin{pmatrix} -2i\\sigma  & 1 \\\\ 1 - 2\\epsilon(1+i\\sigma)  & 2\\epsilon \\end{pmatrix}\n$$\n放大因子 $\\lambda$ 是 $G$ 的特征值，通过求解 $\\det(G - \\lambda I) = 0$ 找到：\n$$\n\\det\\begin{pmatrix} -2i\\sigma - \\lambda  & 1 \\\\ 1 - 2\\epsilon(1+i\\sigma)  & 2\\epsilon - \\lambda \\end{pmatrix} = 0\n$$\n$$\n(-2i\\sigma - \\lambda)(2\\epsilon - \\lambda) - (1 - 2\\epsilon(1+i\\sigma)) = 0\n$$\n展开此行列式得到特征方程：\n$$\n\\lambda^2 - 2\\epsilon\\lambda + 2i\\sigma\\lambda - 4i\\sigma\\epsilon - 1 + 2\\epsilon + 2i\\sigma\\epsilon = 0\n$$\n$$\n\\lambda^2 + 2(i\\sigma - \\epsilon)\\lambda + (2\\epsilon - 1 - 2i\\sigma\\epsilon) = 0\n$$\n求解这个关于 $\\lambda$ 的二次方程：\n$$\n\\lambda = -(i\\sigma - \\epsilon) \\pm \\sqrt{(i\\sigma - \\epsilon)^2 - (2\\epsilon - 1 - 2i\\sigma\\epsilon)}\n$$\n$$\n\\lambda = \\epsilon - i\\sigma \\pm \\sqrt{(-\\sigma^2 - 2i\\sigma\\epsilon + \\epsilon^2) - (2\\epsilon - 1 - 2i\\sigma\\epsilon)}\n$$\n$$\n\\lambda = \\epsilon - i\\sigma \\pm \\sqrt{-\\sigma^2 + \\epsilon^2 - 2\\epsilon + 1} = \\epsilon - i\\sigma \\pm \\sqrt{(1-\\epsilon)^2 - \\sigma^2}\n$$\n将 $\\sigma = \\mu\\sin\\kappa$ 代回：\n$$\n\\lambda = \\epsilon - i\\mu\\sin\\kappa \\pm \\sqrt{(1-\\epsilon)^2 - \\mu^2\\sin^2\\kappa}\n$$\n为了识别物理模态，我们考察 $\\epsilon \\to 0$ 时的极限。表达式变为 $-i\\mu\\sin\\kappa \\pm \\sqrt{1 - \\mu^2\\sin^2\\kappa}$，这与未使用滤波器格式的结果一致。如前所述，物理模态对应于取平方根的正号。因此，使用 RA 滤波器时物理模态的放大因子为：\n$$\n\\lambda_{\\text{physical}} = \\epsilon - i\\mu\\sin\\kappa + \\sqrt{(1-\\epsilon)^2 - \\mu^2\\sin^2\\kappa}\n$$\n当 $\\epsilon=0$ 时，该表达式正确地简化为未使用滤波器时的物理模态放大因子。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} -i\\mu\\sin(\\kappa) + \\sqrt{1 - \\mu^{2}\\sin^{2}(\\kappa)}  \\epsilon - i\\mu\\sin(\\kappa) + \\sqrt{(1-\\epsilon)^{2} - \\mu^{2}\\sin^{2}(\\kappa)} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "理论分析为我们提供了深刻的见解，但在实际应用中，我们需要一种原则性的方法来选择滤波参数。本练习将理论与实践联系起来，要求你为一个具体的目标——即以特定的e-折叠时间尺度 $T_d$ 衰减计算模态——来确定滤波系数 $\\alpha$。通过这个计算，你将学会如何根据模型的稳定性和期望的性能来校准滤波器，这是从理论走向应用的关键一步。",
            "id": "3816230",
            "problem": "在许多海洋环流模式中，预报方程通过时间中心蛙跳格式进行推进，该格式会产生一种称为计算模的寄生双时间层振荡。为了控制该模态，模式通常在每次蛙跳更新后应用 Robert–Asselin (RA) 时间滤波器。考虑一个单一的预报标量 $u$，其连续时间趋势不随时间变化，因此底层的物理场解不随时间变化。蛙跳格式离散化后会产生两个离散的时间分量：一个关于 $n$ 为常数的物理模，以及一个符号以 $(-1)^{n}$ 交替变化的计算模，其中 $n$ 标示由恒定时间步长 $\\Delta t$ 分隔的离散时间层。\n\nRA 滤波器根据以下公式更新刚刚计算出的时间层 $n$ 的场：\n$$\nu^{n} \\leftarrow u^{n} + \\frac{\\alpha}{2}\\left(u^{n-1} - 2 u^{n} + u^{n+1}\\right),\n$$\n其中 $\\alpha$ 是在每个时间步应用的无量纲滤波强度。为计算模的振幅衰减规定了一个 e-折时间尺度 $T_{d}$，这意味着计算模分量的量值应随物理时间 $t$ 按 $\\exp\\!\\left(-t/T_{d}\\right)$ 衰减。假设滤波器在每个时间步应用一次，并且 $\\alpha$ 的选择应在实现计算模指定 e-折衰减的前提下，最小化对物理模的影响。\n\n从上述定义以及将 $u^{n}$ 分解为物理和计算分量出发，推导在 RA 滤波器作用下计算模的每步放大因子，将其等同于由连续 e-折时间尺度 $T_{d}$ 所隐含的期望离散时间衰减因子，并确定 $\\alpha$ 关于 $\\Delta t$ 和 $T_{d}$ 的闭式表达式。请明确说明你为确保对物理模影响最小而对 $\\alpha$ 施加的任何约束。你的最终答案必须是关于 $\\alpha$ 的单一解析表达式，无单位。不要做近似；无需四舍五入。",
            "solution": "本问题要求推导 Robert-Asselin (RA) 滤波系数 $\\alpha$ 的表达式，该表达式用模式时间步长 $\\Delta t$ 和为计算模给定的 e-折时间尺度 $T_d$ 来表示。推导过程将通过分析滤波器对解的物理模和计算模的影响来进行。\n\n首先，我们验证问题陈述。\n\n**步骤 1：提取已知条件**\n- 预报变量：单一标量 $u$。\n- 底层物理场解：不随时间变化。\n- 离散化：时间中心蛙跳格式。\n- 时间层：由 $n$ 索引，具有恒定时间步长 $\\Delta t$。\n- 物理模：关于 $n$ 为常数。\n- 计算模：符号以 $(-1)^{n}$ 交替变化。\n- Robert-Asselin (RA) 滤波器方程：$u^{n} \\leftarrow u^{n} + \\frac{\\alpha}{2}\\left(u^{n-1} - 2 u^{n} + u^{n+1}\\right)$。\n- 滤波强度：$\\alpha$，一个无量纲参数。\n- 滤波器应用：每时间步一次。\n- 计算模衰减：量值按 $\\exp(-t/T_d)$ 衰减，其中 $t$ 是物理时间， $T_d$ 是给定的 e-折时间尺度。\n- 约束：$\\alpha$ 的选择必须在实现计算模指定衰减的同时，最小化对物理模的影响。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据、提法恰当且客观。它描述了一种在地球物理流体动力学模式中控制数值振荡的标准方法。蛙跳格式的物理模和计算模的概念是数值分析中的基本概念。所提供的信息是自洽且充分的，足以建立 $\\alpha$、$\\Delta t$ 和 $T_d$ 之间的关系。约束条件“最小化对物理模的影响”是滤波器设计中的一个标准考虑，在此背景下，它意味着选择满足主要目标的最小可能 $\\alpha$ 值，从而防止对有物理意义的运动产生过度阻尼。问题有效。\n\n**步骤 3：结论与行动**\n问题有效。我们开始求解。\n\n在时间层 $n$ 的解 $u^n$ 可以分解为一个物理分量 $u_p^n$ 和一个计算分量 $u_c^n$：\n$$\nu^n = u_p^n + u_c^n\n$$\n根据问题陈述：\n1.  物理模不随时间变化。设 $U_p$ 为一个恒定振幅。那么，对于所有的 $n$，\n    $$\n    u_p^n = U_p\n    $$\n2.  计算模在每个时间步符号交替。设 $C^n$ 为其在时间层 $n$ 的振幅。那么，\n    $$\n    u_c^n = C^n (-1)^n\n    $$\nRA 滤波器是一个线性算子。因此，我们可以独立分析它对解的每个分量的影响。设 $u_f^n$ 表示 $u^n$ 的滤波值。滤波器定义为：\n$$\nu_f^n = u^n + \\frac{\\alpha}{2}\\left(u^{n-1} - 2 u^n + u^{n+1}\\right)\n$$\n这可以重写为：\n$$\nu_f^n = (1-\\alpha)u^n + \\frac{\\alpha}{2}(u^{n-1} + u^{n+1})\n$$\n\n首先，我们分析滤波器对物理模 $u_p^n$ 的影响。将 $u^n = u_p^n = U_p$ 代入滤波器方程：\n$$\n(u_p)_f^n = U_p + \\frac{\\alpha}{2}\\left(U_p - 2 U_p + U_p\\right) = U_p + \\frac{\\alpha}{2}(0) = U_p\n$$\n滤波器对一个完全不随时间变化的物理模没有影响。对于并非严格恒定但缓慢变化的物理模，项 $(u^{n-1} - 2u^n + u^{n+1})$ 是 $(\\Delta t)^2 \\frac{\\partial^2 u}{\\partial t^2}$ 的一个离散近似。对于低频物理波，该项很小，但滤波器会引入一些与 $\\alpha$ 成正比的阻尼。因此，最小化对物理模影响的约束转化为最小化 $\\alpha$ 的值。\n\n接下来，我们分析滤波器对计算模 $u_c^n$ 的影响。在此分析中，我们视振幅 $C$ 在单次滤波器应用所使用的三个时间层 $\\{n-1, n, n+1\\}$ 上为常数。\n$$\nu_c^{n-1} = C(-1)^{n-1}, \\quad u_c^n = C(-1)^n, \\quad u_c^{n+1} = C(-1)^{n+1}\n$$\n将这些代入滤波器方程，得到时间层 $n$ 的滤波后计算模：\n$$\n(u_c)_f^n = u_c^n + \\frac{\\alpha}{2}\\left(u_c^{n-1} - 2 u_c^n + u_c^{n+1}\\right)\n$$\n$$\n(u_c)_f^n = C(-1)^n + \\frac{\\alpha}{2}\\left(C(-1)^{n-1} - 2C(-1)^n + C(-1)^{n+1}\\right)\n$$\n提出公因子 $C(-1)^n$：\n$$\n(u_c)_f^n = C(-1)^n \\left[1 + \\frac{\\alpha}{2}\\left(\\frac{(-1)^{n-1}}{(-1)^n} - 2 + \\frac{(-1)^{n+1}}{(-1)^n}\\right)\\right]\n$$\n$$\n(u_c)_f^n = C(-1)^n \\left[1 + \\frac{\\alpha}{2}\\left((-1)^{-1} - 2 + (-1)^1\\right)\\right]\n$$\n$$\n(u_c)_f^n = C(-1)^n \\left[1 + \\frac{\\alpha}{2}(-1 - 2 - 1)\\right] = C(-1)^n \\left[1 + \\frac{\\alpha}{2}(-4)\\right]\n$$\n$$\n(u_c)_f^n = (1 - 2\\alpha) C(-1)^n = (1 - 2\\alpha) u_c^n\n$$\n这表明，单次应用 RA 滤波器会使计算模的振幅减小一个因子 $(1-2\\alpha)$。由于滤波器在每个时间步都应用，这个因子（我们称之为 $\\lambda_c$）就是计算模的每步放大因子：\n$$\n\\lambda_c = 1 - 2\\alpha\n$$\n问题要求计算模的量值以 e-折时间尺度 $T_d$ 衰减。物理时间 $t$ 处的振幅 $A(t)$ 由 $A(t) = A_0 \\exp(-t/T_d)$ 给出，其中 $A_0$ 是初始振幅。\n在一个时长为 $\\Delta t$ 的单一时间步内，该模的振幅变化一个因子：\n$$\n\\frac{A(t+\\Delta t)}{A(t)} = \\frac{A_0 \\exp(-(t+\\Delta t)/T_d)}{A_0 \\exp(-t/T_d)} = \\exp(-\\Delta t/T_d)\n$$\n这是每时间步期望的离散时间衰减因子。\n\n为了实现指定的衰减，滤波器的放大因子必须与这个要求的衰减因子相匹配。一个更小的放大因子（即一个更大的 $\\alpha$）会导致比要求更快的衰减，但也会增加对物理模不希望有的阻尼。约束条件“最小化对物理模的影响”指示我们找到能恰好产生所需衰减（不多不少）的 $\\alpha$ 值。这意味着我们必须将每步放大因子设为等于要求的衰减因子：\n$$\n\\lambda_c = \\exp(-\\Delta t/T_d)\n$$\n代入我们关于 $\\lambda_c$ 的表达式：\n$$\n1 - 2\\alpha = \\exp(-\\Delta t/T_d)\n$$\n我们现在求解这个关于 $\\alpha$ 的方程：\n$$\n2\\alpha = 1 - \\exp(-\\Delta t/T_d)\n$$\n$$\n\\alpha = \\frac{1 - \\exp(-\\Delta t/T_d)}{2}\n$$\n这就是 $\\alpha$ 的闭式表达式。为确保对物理模影响最小而对 $\\alpha$ 施加的约束是，选择与所需阻尼一致的最小 $\\alpha$ 值，这对应于将滤波器的放大因子等同于目标衰减因子。\n为了发生阻尼，我们要求 $|\\lambda_c|  1$，这意味着 $|1 - 2\\alpha|  1$，即 $\\alpha \\in (0, 1)$。鉴于 $\\Delta t > 0$ 和 $T_d > 0$，我们有 $\\exp(-\\Delta t/T_d)  1$，这确保了 $\\alpha > 0$。为避免计算模的符号在一步内改变，我们要求 $\\lambda_c \\ge 0$，这意味着 $1 - 2\\alpha \\ge 0$，所以 $\\alpha \\le 1/2$。这个条件在实际应用中通常也得到满足，因为 $\\Delta t \\ll T_d$。",
            "answer": "$$\n\\boxed{\\frac{1 - \\exp\\left(-\\frac{\\Delta t}{T_{d}}\\right)}{2}}\n$$"
        },
        {
            "introduction": "在数值建模中，解决方案往往是在不同需求之间的权衡。Robert-Asselin滤波器虽然有效抑制了计算模，但可能会引入意想不到的副作用，即降低数值格式的精度阶。本练习是一个数值实验，它将让你通过编码实践，亲自衡量并验证这一效应，并探索如何通过动态调整滤波系数 $\\alpha$ 来恢复蛙跳格式原有的二阶精度，这是一个在开发高性能模型时至关重要的考量。",
            "id": "3816241",
            "problem": "考虑在没有压力梯度的情况下，由科里奥利力作用下的水平动量方程得到的线性惯性振荡，这是计算海洋学中的一个标准测试。设 $u(t)$ 和 $v(t)$ 分别表示纬向和经向速度分量。其控制方程为\n$$\n\\frac{d u}{d t} = f\\, v, \\qquad \\frac{d v}{d t} = -f\\, u,\n$$\n其中 $f$ 是科里奥利参数，单位为 $\\mathrm{s}^{-1}$。引入复变量 $z(t) = u(t) + i\\, v(t)$，可得到标量常微分方程\n$$\n\\frac{d z}{d t} = -i\\, f\\, z,\n$$\n其精确解为 $z(t) = z(0)\\, e^{-i f t}$，该解对所有 $t$ 都是光滑的。惯性周期为 $T_{\\mathrm{I}} = \\frac{2\\pi}{|f|}$ 秒。\n\n地球物理流体动力学中一种常见的显式时间离散化方法是蛙跳格式。对于一个时间步长 $\\Delta t$（单位为秒），该标量方程的蛙跳格式更新步骤为\n$$\nz^{n+1} = z^{n-1} - 2\\, \\Delta t\\, i\\, f\\, z^{n},\n$$\n其中 $z^{n}$ 是对 $z(n \\Delta t)$ 的近似。已知蛙跳格式对于光滑解在时间上具有二阶精度，但它会产生一个解耦的计算模态。一种广泛使用的稳定化方法是 Robert–Asselin 时间滤波器（RA 滤波器），其定义为如下平滑操作\n$$\nz^{n} \\leftarrow z^{n} + \\alpha \\left( z^{n-1} - 2 z^{n} + z^{n+1} \\right),\n$$\n其中 $\\alpha$ 是一个无量纲的滤波参数。RA 滤波器能抑制计算模态，但可能会根据 $\\alpha$ 相对于 $\\Delta t$ 的缩放方式改变物理模态的形式精度阶。\n\n你的任务是设计并实现一个数值测试，以测量在 $\\alpha$ 的不同缩放方式下，带有 RA 滤波器的蛙跳格式对于光滑精确解 $z(t) = e^{-i f t}$ 的观测精度阶。从上面给出的基础（惯性振荡和蛙跳格式）出发，构建一个程序来执行以下操作：\n\n1. 使用蛙跳格式积分一个惯性周期 $T_{\\mathrm{I}} = \\frac{2\\pi}{|f|}$，并在每个内部时间层级上应用 RA 滤波器。\n2. 使用精确值 $z^{0} = 1$ 和 $z^{1} = e^{-i f \\Delta t}$ 进行初始化，以确保启动过程不会污染渐近精度测量。\n3. 对于一系列时间步长 $\\Delta t_{k} = \\frac{T_{\\mathrm{I}}}{N_{k}}$（其中 $N_{k} \\in \\{32, 64, 128, 256\\}$），计算在 $t = T_{\\mathrm{I}}$ 时的数值解 $z^{N_{k}}$ 和绝对误差 $E(\\Delta t_{k}) = \\left| z^{N_{k}} - e^{-i f T_{\\mathrm{I}}} \\right|$，该误差是无量纲的。\n4. 通过对 $(\\log(\\Delta t_{k}), \\log(E(\\Delta t_{k})))$ 进行直线拟合，并取其斜率 $p$ 来估计观测精度阶 $p$（因为一个 $p$ 阶方法在 $\\Delta t$ 很小时满足 $E(\\Delta t) \\approx C\\, \\Delta t^{p}$）。\n\n在以下三种情况下执行上述测试：\n\n- 情况 A（无滤波器）：$\\alpha = 0$。\n- 情况 B（常数 RA 滤波器）：$\\alpha = 0.05$。\n- 情况 C（二次方缩放）：$\\alpha = \\kappa\\, \\Delta t^{2}$，其中 $\\kappa = \\dfrac{0.05}{T_{\\mathrm{I}}^{2}}$，使得 $\\alpha$ 随 $\\Delta t^{2}$ 减小。\n\n使用 $f = 10^{-4}\\ \\mathrm{s}^{-1}$ 并精确积分一个惯性周期 $T_{\\mathrm{I}} = \\frac{2\\pi}{f}$ 秒。角度通过 $e^{-i f t}$ 隐式地以弧度为单位进行测量，但无需输出角度单位。误差是一个没有物理单位的浮点数。最终报告的观测阶 $p$ 是无量纲的浮点数。\n\n你的程序应计算与上述情况相对应的三个观测阶 $p$，并生成单行输出，其中包含这三个值，顺序为 [情况 A, 情况 B, 情况 C]，形式为用方括号括起来的逗号分隔列表，并四舍五入到三位小数（例如，“[2.001,0.998,2.000]”）。\n\n测试套件和覆盖范围：\n\n- 正常路径：情况 A（无滤波器）应展示蛙跳格式的二阶收敛性。\n- 显著修改：情况 B（常数 $\\alpha$）预计会改变观测阶。\n- 缩放边界情况：情况 C（$\\alpha \\propto \\Delta t^{2}$）预计会恢复与蛙跳核心一致的高阶行为。\n\n你的实现必须是一个完整、可运行的程序，执行这些实验并按要求的单行格式输出。所有计算的时间单位都应为秒，$f$ 的单位为 $\\mathrm{s}^{-1}$。测试的唯一数值输入是指定的 $f$、集合 $\\{N_{k}\\}$ 以及上面定义的 $\\alpha$ 的缩放方式。输出是从对数-对数斜率估计的三个浮点数。",
            "solution": "惯性振荡方程是测试时间精度的典型基础，因为它们能产生光滑的正弦解，并能分离出时间离散化的影响。从科里奥利力作用下的水平动量方程出发，\n$$\n\\frac{d u}{d t} = f\\, v, \\qquad \\frac{d v}{d t} = -f\\, u,\n$$\n通过 $z = u + i v$，可得到标量复常微分方程，\n$$\n\\frac{d z}{d t} = -i\\, f\\, z, \\quad z(t) = z(0)\\, e^{-i f t}.\n$$\n该精确解是光滑的周期函数，惯性周期为 $T_{\\mathrm{I}} = \\frac{2\\pi}{|f|}$。\n\n蛙跳格式是通过用中心差分来近似 $t^{n}$ 处的时间导数而导出的，\n$$\n\\left.\\frac{d z}{d t}\\right|_{t^{n}} \\approx \\frac{z^{n+1} - z^{n-1}}{2 \\Delta t},\n$$\n并令其等于右端项 $-i f z^{n}$。这得到\n$$\nz^{n+1} = z^{n-1} - 2\\, \\Delta t\\, i\\, f\\, z^{n}.\n$$\n对精确解进行泰勒级数展开表明，蛙跳格式的局部截断误差为 $O(\\Delta t^{3})$，对于足够光滑的 $z(t)$，其全局误差为 $O(\\Delta t^{2})$。然而，蛙跳格式会产生一个与奇偶时间层级解耦相关的计算模态，这在实际应用中会污染解。\n\n为了抑制计算模态，Robert–Asselin 时间滤波器在计算出 $z^{n+1}$ 后，对当前时间层级应用平滑操作：\n$$\nz^{n} \\leftarrow z^{n} + \\alpha \\left( z^{n-1} - 2 z^{n} + z^{n+1} \\right).\n$$\n括号中的项是二阶时间差分，通过在 $t^{n}$ 附近对 $z^{n\\pm 1}$ 进行泰勒展开，可知其满足\n$$\nz^{n-1} - 2 z^{n} + z^{n+1} = \\Delta t^{2}\\, \\frac{d^{2} z}{d t^{2}}(t^{n}) + \\frac{\\Delta t^{4}}{12}\\, \\frac{d^{4} z}{d t^{4}}(t^{n}) + O(\\Delta t^{6}).\n$$\n如果将此平滑操作对连续解应用一次，其主阶变化似乎是 $O(\\alpha\\, \\Delta t^{2})$。然而，在离散多步格式的背景下，RA 滤波器会扰乱蛙跳格式的时间中心性质，因为它使用 $z^{n+1}$ 来更新 $z^{n}$，破坏了双时间层级模板的严格对称性。对蛙跳格式加滤波器的组合方法进行的修正方程分析表明，物理模态会获得一个与 $\\alpha$ 乘以低阶时间导数成正比的主导误差项，并且在每个时间步长上应用滤波器，经过一个 $O(1)$ 的时间间隔后，当 $\\alpha$ 保持不变时，累积效应产生的全局误差缩放为 $O(\\Delta t)$。因此：\n- 当 $\\alpha = 0$ 时，该方法是标准的蛙跳格式，具有二阶精度。\n- 当 $\\alpha$ 为常数（例如 $\\alpha = 0.05$）时，滤波器在每一步都引入一个持续的非对称性，全局误差通常按 $O(\\Delta t)$ 缩放，因此观测阶约为 1。\n- 如果 $\\alpha$ 的缩放使其随 $\\Delta t$ 足够快地衰减，则滤波器的扰动将变为高阶。一种常被引用的充分缩放是 $\\alpha = O(\\Delta t^{2})$，此时每一步的附加扰动为 $O(\\Delta t^{4})$，在 $O(\\Delta t^{-1})$ 步数上的累积全局误差的主导项仍为 $O(\\Delta t^{3})$。在这种情况下，蛙跳格式的核心二阶行为在观测全局误差中得以恢复。\n\n基于这些原理，我们设计如下数值测试。我们设置 $f = 10^{-4}\\ \\mathrm{s}^{-1}$ 并精确积分一个惯性周期 $T_{\\mathrm{I}} = \\frac{2\\pi}{f}$ 秒。为确保覆盖范围和渐近行为，我们选择步数 $N \\in \\{32, 64, 128, 256\\}$ 以及相应的时间步长 $\\Delta t = T_{\\mathrm{I}}/N$。对于每个 $\\Delta t$，我们从精确解初始化 $z^{0} = 1$ 和 $z^{1} = e^{-i f \\Delta t}$ 以避免启动误差。然后我们对 $n = 1, 2, \\dots, N-1$ 进行迭代：\n1. 计算蛙跳格式更新 $z^{n+1} = z^{n-1} - 2\\, \\Delta t\\, i\\, f\\, z^{n}$。\n2. 对 $z^{n}$ 应用 RA 滤波器，使用当前情况所规定的 $\\alpha$ 缩放方式：\n$$\nz^{n} \\leftarrow z^{n} + \\alpha \\left( z^{n-1} - 2 z^{n} + z^{n+1} \\right).\n$$\n\n经过 $N$ 步后，我们计算误差 $E(\\Delta t) = \\left| z^{N} - e^{-i f T_{\\mathrm{I}}} \\right|$。由于 $e^{-i f T_{\\mathrm{I}}} = e^{-i 2\\pi} = 1$，这可以简化为 $E(\\Delta t) = \\left| z^{N} - 1 \\right|$。对于每种情况（无滤波器、常数 $\\alpha = 0.05$ 和二次方缩放 $\\alpha = \\kappa \\Delta t^{2}$ 且 $\\kappa = \\frac{0.05}{T_{\\mathrm{I}}^{2}}$），我们计算四个 $\\Delta t$ 值对应的 $E(\\Delta t)$，并通过对数据点对 $(\\log(\\Delta t), \\log(E(\\Delta t)))$ 进行最小二乘直线拟合来估计观测阶 $p$。如果 $E(\\Delta t) \\approx C\\, \\Delta t^{p}$，则有 $\\log(E(\\Delta t)) \\approx \\log C + p \\log(\\Delta t)$，因此斜率 $p$ 就是观测阶。\n\n基于以上分析，预期的结果是：\n- 情况 A ($\\alpha = 0$)：$p \\approx 2$（二阶）。\n- 情况 B ($\\alpha = 0.05$)：$p \\approx 1$（由于持续的滤波器非对称性导致一阶）。\n- 情况 C ($\\alpha = \\kappa \\Delta t^{2}$)：$p \\approx 2$（二阶精度得以恢复，因为滤波器的扰动随 $\\Delta t$ 呈二次方消失）。\n\n算法实现遵循这些步骤，最终程序按要求输出一行，其中包含与三种情况相对应的三个观测 $p$ 值（浮点数），四舍五入到三位小数并用方括号括起来。所有带物理单位的变量都以秒或秒的倒数为单位指定，输出为无量纲的浮点数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef inertial_period(f):\n    return 2.0 * np.pi / abs(f)\n\ndef exact_solution(f, t):\n    # z(t) = exp(-i f t)\n    return np.exp(-1j * f * t)\n\ndef leapfrog_ra_integrate(f, dt, N, alpha_mode, T_I):\n    \"\"\"\n    Integrate z' = -i f z over N steps of size dt using leapfrog and RA filter.\n    alpha_mode: 'none', 'const', or 'quad'\n    \"\"\"\n    # Determine alpha for this dt\n    if alpha_mode == 'none':\n        alpha = 0.0\n    elif alpha_mode == 'const':\n        alpha = 0.05\n    elif alpha_mode == 'quad':\n        # alpha = k * dt^2, with k = 0.05 / T_I^2 to keep scale comparable\n        alpha = 0.05 * (dt**2) / (T_I**2)\n    else:\n        raise ValueError(\"Unknown alpha_mode\")\n\n    # Initialize with exact values\n    z_prev = exact_solution(f, 0.0)                 # z^0\n    z_curr = exact_solution(f, dt)                  # z^1\n\n    # Time stepping\n    for n in range(1, N):\n        # Leapfrog update to get z^{n+1}\n        z_next = z_prev - 2.0 * dt * 1j * f * z_curr\n        \n        # Apply RA filter to z^n (the center time level of the stencil)\n        # z^n_filtered = z^n + alpha * (z^{n-1} - 2*z^n + z^{n+1})\n        z_curr_filtered = z_curr + alpha * (z_prev - 2.0 * z_curr + z_next)\n        \n        # Shift for next iteration: \n        # (n+1) becomes current, and the filtered z^n becomes the previous time level\n        z_prev = z_curr_filtered\n        z_curr = z_next\n\n    # After N steps, z_curr is z^N (unfiltered at final level)\n    return z_curr\n\ndef observed_order(log_dt, log_err):\n    # Fit log(err) = a + p * log(dt); return p\n    # Use least squares linear fit\n    p, a = np.polyfit(log_dt, log_err, 1)\n    return p\n\ndef solve():\n    # Define the test cases from the problem statement.\n    f = 1e-4  # s^-1\n    T_I = inertial_period(f)  # seconds, one inertial period\n\n    # Numbers of steps for dt = T_I / N\n    N_list = [32, 64, 128, 256]\n\n    # Alpha modes to test: Case A, Case B, Case C\n    alpha_modes = ['none', 'const', 'quad']\n\n    results = []\n    for mode in alpha_modes:\n        dt_list = []\n        err_list = []\n        for N in N_list:\n            dt = T_I / N\n            zN = leapfrog_ra_integrate(f, dt, N, mode, T_I)\n            # Exact at t = T_I is exp(-i f T_I) = exp(-i 2 pi) = 1\n            exact_T = 1.0 + 0.0j\n            err = abs(zN - exact_T)\n            dt_list.append(dt)\n            err_list.append(err)\n\n        # Compute observed order via log-log slope\n        log_dt = np.log(np.array(dt_list))\n        log_err = np.log(np.array(err_list))\n        p = observed_order(log_dt, log_err)\n        results.append(p)\n\n    # Final print statement in the exact required format: three values rounded to three decimals\n    print(f\"[{','.join(f'{r:.3f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}