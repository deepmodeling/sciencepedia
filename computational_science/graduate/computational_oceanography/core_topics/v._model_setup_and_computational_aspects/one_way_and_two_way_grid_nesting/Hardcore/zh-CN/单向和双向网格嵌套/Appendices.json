{
    "hands_on_practices": [
        {
            "introduction": "在单向嵌套中，子网格内部可能产生自身的精细尺度信号（如波浪），这些信号必须能够平稳地传出计算域，而不会在边界处产生虚假反射。Orlanski 辐射边界条件是一种经典的解决方案，它通过在边界上动态估算局部波速来实现这一目标。本练习将指导你推导该条件的一种特定离散化形式，这是构建稳定有效的单向嵌套模型的一项基本技能。",
            "id": "3805886",
            "problem": "考虑一个采用网格嵌套的二维近岸海洋模型，该模型包含一个粗糙的父网格和一个精细的子网格。沿着子网格的一个开放边界段，向外的法线方向与 $x$ 轴对齐。令一个标量预报场 $\\phi(x,t)$ 表示子网格上的正压模海面高度异常。在单向嵌套中，子网格的边界应允许在子网格内部生成的向外传播的信号无虚假反射地离开，而流入则由父网格提供。一种常用的方法是 Orlanski 辐射边界条件，它遵循运动学假设，即在局部，沿着边界法线方向，向外传播的扰动满足线性平流方程。\n\n从沿边界法线方向的线性平流方程出发，\n$$\n\\frac{\\partial \\phi}{\\partial t} + c \\,\\frac{\\partial \\phi}{\\partial x} = 0,\n$$\n其中 $c$ 是一个未知的局地相速度，将根据模型解析的梯度进行估计。请使用时间上的一阶前向欧拉格式和空间上在边界点处的一阶单侧（内部）差分格式，为下一个时间层 $t^{n+1}$ 的边界值 $\\phi_b^{n+1}$ 推导出一个离散的辐射更新公式。令 $\\Delta t$ 表示子网格的时间步长，$\\Delta x$ 表示子网格的边界法线方向上的网格间距。将边界值记为 $\\phi_b^n = \\phi(x_b,t^n)$，其紧邻的内部点记为 $\\phi_{b-1}^n = \\phi(x_b-\\Delta x,t^n)$。\n\n假设在时间层 $n$ 的局地相速度通过解析梯度估计如下：\n$$\nc^n = -\\,\\frac{\\left(\\frac{\\partial \\phi}{\\partial t}\\right)^n}{\\left(\\frac{\\partial \\phi}{\\partial x}\\right)^n},\n$$\n并使用时间上的后向差分和空间上的单侧内部差分来近似梯度，\n$$\n\\left(\\frac{\\partial \\phi}{\\partial t}\\right)^n \\approx \\frac{\\phi_b^n - \\phi_b^{n-1}}{\\Delta t}, \\qquad\n\\left(\\frac{\\partial \\phi}{\\partial x}\\right)^n \\approx \\frac{\\phi_b^n - \\phi_{b-1}^n}{\\Delta x}.\n$$\n\n在此边界段上，根据与单向嵌套一致的向外传播假设，将以上各式结合起来，生成一个用 $\\phi_b^n$、$\\phi_b^{n-1}$、$\\Delta t$ 和 $\\Delta x$ 表示的边界更新 $\\phi_b^{n+1}$ 的单一闭合形式表达式。将最终答案表示为单个符号表达式；不要包含单位。不需要进行数值计算。",
            "solution": "目标是为时间层 $t^{n+1}$ 的边界值 $\\phi_b^{n+1}$ 推导出一个单一的闭合形式表达式。推导从线性平流方程开始，该方程控制着标量场 $\\phi(x,t)$ 沿边界法线方向 $x$ 的动力学：\n$$\n\\frac{\\partial \\phi}{\\partial t} + c \\,\\frac{\\partial \\phi}{\\partial x} = 0\n$$\n其中 $c$ 是局地相速度。\n\n问题指定应通过使用时间上的一阶前向欧拉格式和空间上的一阶单侧（内部）差分格式对此方程进行离散化，从而推导出 $\\phi_b^{n+1}$ 的更新公式。在边界点 $x_b$ 和时间层 $t^n$，该离散化可写为：\n$$\n\\frac{\\phi_b^{n+1} - \\phi_b^n}{\\Delta t} + c^n \\left( \\frac{\\phi_b^n - \\phi_{b-1}^n}{\\Delta x} \\right) = 0\n$$\n此处，$\\phi_b^n$ 是在时间 $t^n$ 位于边界点 $x_b$ 的值，$\\phi_{b-1}^n$ 是在时间 $t^n$ 位于相邻内部点 $x_b - \\Delta x$ 的值，$\\Delta t$ 是时间步长，$\\Delta x$ 是网格间距。相速度 $c^n$ 在时间层 $n$ 进行评估。\n\n我们可以重新整理这个方程以求解 $\\phi_b^{n+1}$：\n$$\n\\phi_b^{n+1} = \\phi_b^n - c^n \\frac{\\Delta t}{\\Delta x} (\\phi_b^n - \\phi_{b-1}^n)\n$$\n该表达式用当前时间层的值和相速度 $c^n$ 给出了更新后的边界值。\n\n接下来，我们使用所提供的方法来估计相速度 $c^n$。公式为：\n$$\nc^n = -\\,\\frac{\\left(\\frac{\\partial \\phi}{\\partial t}\\right)^n}{\\left(\\frac{\\partial \\phi}{\\partial x}\\right)^n}\n$$\n问题指定了在边界点 $x_b$ 和时间层 $t^n$ 处偏导数的近似方法：\n1. 时间上的后向差分：\n$$\n\\left(\\frac{\\partial \\phi}{\\partial t}\\right)^n \\approx \\frac{\\phi_b^n - \\phi_b^{n-1}}{\\Delta t}\n$$\n2. 空间上的单侧内部差分（这是一个后向差分格式）：\n$$\n\\left(\\frac{\\partial \\phi}{\\partial x}\\right)^n \\approx \\frac{\\phi_b^n - \\phi_{b-1}^n}{\\Delta x}\n$$\n将这些离散近似代入 $c^n$ 的公式中，得到：\n$$\nc^n = - \\frac{ \\left( \\frac{\\phi_b^n - \\phi_b^{n-1}}{\\Delta t} \\right) }{ \\left( \\frac{\\phi_b^n - \\phi_{b-1}^n}{\\Delta x} \\right) }\n$$\n简化这个关于 $c^n$ 的表达式，得到：\n$$\nc^n = - \\frac{\\Delta x}{\\Delta t} \\frac{\\phi_b^n - \\phi_b^{n-1}}{\\phi_b^n - \\phi_{b-1}^n}\n$$\n现在将这个 $c^n$ 的表达式代回到 $\\phi_b^{n+1}$ 的更新方程中：\n$$\n\\phi_b^{n+1} = \\phi_b^n - \\left( - \\frac{\\Delta x}{\\Delta t} \\frac{\\phi_b^n - \\phi_b^{n-1}}{\\phi_b^n - \\phi_{b-1}^n} \\right) \\frac{\\Delta t}{\\Delta x} (\\phi_b^n - \\phi_{b-1}^n)\n$$\n两个负号相消，得到：\n$$\n\\phi_b^{n+1} = \\phi_b^n + \\left( \\frac{\\Delta x}{\\Delta t} \\frac{\\phi_b^n - \\phi_b^{n-1}}{\\phi_b^n - \\phi_{b-1}^n} \\right) \\frac{\\Delta t}{\\Delta x} (\\phi_b^n - \\phi_{b-1}^n)\n$$\n我们可以重新组合各项以便于相消：\n$$\n\\phi_b^{n+1} = \\phi_b^n + \\left( \\frac{\\Delta x}{\\Delta t} \\frac{\\Delta t}{\\Delta x} \\right) \\left( \\frac{\\phi_b^n - \\phi_b^{n-1}}{\\phi_b^n - \\phi_{b-1}^n} \\right) (\\phi_b^n - \\phi_{b-1}^n)\n$$\n假设边界处的空间梯度非零，即 $\\phi_b^n \\neq \\phi_{b-1}^n$，各项相消：\n$$\n\\phi_b^{n+1} = \\phi_b^n + (1) \\cdot (\\phi_b^n - \\phi_b^{n-1})\n$$\n这简化为边界更新的最终闭合形式表达式：\n$$\n\\phi_b^{n+1} = 2\\phi_b^n - \\phi_b^{n-1}\n$$\n该结果表明，由于为更新规则和相速度估计选择了特定的离散化方案组合，边界值的更新简化为在边界点处根据前两个时间层进行简单的时间线性外推。",
            "answer": "$$\n\\boxed{2\\phi_b^n - \\phi_b^{n-1}}\n$$"
        },
        {
            "introduction": "双向嵌套的核心在于将子网格的高分辨率信息反馈给父网格，但简单地用子网格解“替换”父网格解可能会引入数值冲击和噪声，影响模型的稳定性。本练习探讨了一种更为平缓的“增量更新”反馈方法，并要求你在一个简化的理论模型中量化其相对于替换法所产生的扰动大小。这个练习的结果揭示了设计稳定双向耦合方案的一个关键原则，即平滑地引入反馈以减小虚假噪声。",
            "id": "3805941",
            "problem": "考虑一个被动示踪剂场 $u(x,t)$ 的一维线性平流-扩散方程，\n$$\n\\frac{\\partial u}{\\partial t} + c\\,\\frac{\\partial u}{\\partial x} = \\kappa\\,\\frac{\\partial^{2} u}{\\partial x^{2}},\n$$\n在一个周期性域 $x \\in [0, L]$上，其中 $c$ 是一个恒定的平流速度，$\\kappa$ 是一个恒定的扩散系数。一个均匀间距为 $\\Delta x_{p}$ 的父网格覆盖整个域，一个均匀间距为 $\\Delta x_{c} = \\Delta x_{p}/r$（其中整数加密因子 $r \\geq 2$）的嵌套子网格覆盖一个连续的子域 $\\Omega_{\\mathrm{nest}} \\subset [0,L]$。两个网格都使用相同的时间步长 $\\Delta t$ 和相同的稳定有限体积法离散方案进行平流-扩散，但本问题不需要时间积分器的具体细节。\n\n假设在耦合时间 $t^{n+1}$，子网格在 $\\Omega_{\\mathrm{nest}}$ 内解析真实解 $u(x,t)$ 的误差可以忽略不计，而父网格的自由预报 $u_{p}^{n+1,\\mathrm{f}}(x)$ 在 $\\Omega_{\\mathrm{nest}}$ 内与真实解相差一个误差场 $e(x)$，使得对于 $x \\in \\Omega_{\\mathrm{nest}}$ 有 $u_{p}^{n+1,\\mathrm{f}}(x) = u(x,t^{n+1}) + e(x)$。在 $\\Omega_{\\mathrm{nest}}$ 之外，不施加反馈，父网格保持不变。\n\n考虑两种标准的双向嵌套反馈策略，在 $t^{n+1}$ 时刻使用限制在父网格上的子网格解来更新父网格。令 $\\mathcal{A}$ 表示一个线性限制算子，它将子网格解映射到 $\\Omega_{\\mathrm{nest}}$ 上父网格的单元平均值。这些策略是：\n- 替换反馈：将父网格设置为受限的子网格解，$u_{p}^{n+1,\\mathrm{rep}} = \\mathcal{A}[u_{c}^{n+1}]$ 于 $\\Omega_{\\mathrm{nest}}$ 内。\n- 增量更新反馈：将父网格设置为自由预报加上一个朝向受限子网格解的加权增量，$u_{p}^{n+1,\\mathrm{inc}} = u_{p}^{n+1,\\mathrm{f}} + \\alpha\\big(\\mathcal{A}[u_{c}^{n+1}] - u_{p}^{n+1,\\mathrm{f}}\\big)$ 于 $\\Omega_{\\mathrm{nest}}$ 内，其中权重为固定的 $0  \\alpha  1$。\n\n为了量化在 $t^{n+1}$ 时刻反馈注入父网格的虚假噪声，将父网格更新增量定义为 $\\Delta u_{p}^{n+1} = u_{p}^{n+1} - u_{p}^{n+1,\\mathrm{f}}$，并测量其在位于 $\\Omega_{\\mathrm{nest}}$ 内的父网格单元上的离散 $L^{2}$ 范数：\n$$\n\\|\\Delta u_{p}^{n+1}\\|_{2} \\equiv \\left(\\Delta x_{p} \\sum_{j \\in \\Omega_{\\mathrm{nest}}} \\big[\\Delta u_{p,j}^{n+1}\\big]^{2}\\right)^{1/2},\n$$\n其中 $u_{p,j}^{n+1}$ 和 $\\Delta u_{p,j}^{n+1}$ 分别表示父网格单元平均值及其相应的增量，求和是对 $\\Omega_{\\mathrm{nest}}$ 内父网格单元的索引进行的。\n\n对于一个线性平流-扩散测试，取 $t^{n+1}$ 时刻的真实解为单个空间傅里叶模式，$u(x,t^{n+1}) = U_{0}\\cos\\big(2\\pi k x/L\\big)$，波数为 $k \\in \\mathbb{N}$，并假设在 $\\Omega_{\\mathrm{nest}}$ 内父网格的自由预报误差为 $e(x) = E_{0}\\cos\\big(2\\pi m x/L\\big)$，其中 $m$ 为某个整数。子网格解在 $\\Omega_{\\mathrm{nest}}$ 内被认为是精确的，因此在父网格上有 $\\mathcal{A}[u_{c}^{n+1}] = \\mathcal{A}[u(\\cdot,t^{n+1})]$。设加密因子为 $r = 4$，增量更新权重为 $\\alpha = \\tfrac{1}{2}$。您可以假设 $\\mathcal{A}$ 是对每个父单元的体积平均且是线性的，并且上述离散 $L^{2}$ 范数在这种限制下与连续 $L^{2}$ 范数是一致的。\n\n计算比率\n$$\nR \\equiv \\frac{\\|\\Delta u_{p}^{n+1}\\|_{2}^{\\mathrm{inc}}}{\\|\\Delta u_{p}^{n+1}\\|_{2}^{\\mathrm{rep}}},\n$$\n其中 $\\|\\Delta u_{p}^{n+1}\\|_{2}^{\\mathrm{inc}}$ 和 $\\|\\Delta u_{p}^{n+1}\\|_{2}^{\\mathrm{rep}}$ 分别是由增量更新和替换反馈产生的父网格更新的 $L^{2}$ 范数，在 $t^{n+1}$ 耦合后立即评估。将您的最终答案表示为一个四舍五入到四位有效数字的无量纲数。",
            "solution": "该问题提出了一个偏微分方程数值方法领域的理论问题，具体涉及网格嵌套技术。核心问题可以通过仔细应用反馈策略的定义和离散 $L^{2}$ 范数的性质来解决。\n\n让我们将一个量 $f(x)$ 在第 $j$ 个单元上的父网格单元平均值表示为 $f_j$。该问题提供了在嵌套域 $\\Omega_{\\mathrm{nest}}$ 内 $t^{n+1}$ 时刻父网格值的以下关键定义和关系：\n\n1.  父网格自由预报 $u_{p,j}^{n+1,\\mathrm{f}}$ 是连续场 $u_{p}^{n+1,\\mathrm{f}}(x) = u(x,t^{n+1}) + e(x)$ 的单元平均值。设 $u_j^{n+1}$ 和 $e_j$ 分别是真实解 $u(x,t^{n+1})$ 和误差场 $e(x)$ 的单元平均值。根据平均算子的线性性质，我们有：\n    $$u_{p,j}^{n+1,\\mathrm{f}} = u_j^{n+1} + e_j$$\n2.  子网格解 $u_c^{n+1}$ 被假定为精确解。限制算子 $\\mathcal{A}$ 执行单元平均。因此，父网格上的受限子网格解对应于真实解的单元平均值：\n    $$\\big(\\mathcal{A}[u_c^{n+1}]\\big)_j = u_j^{n+1}$$\n3.  父网格的更新增量定义为：\n    $$\\Delta u_{p,j}^{n+1} = u_{p,j}^{n+1} - u_{p,j}^{n+1,\\mathrm{f}}$$\n\n我们现在为两种反馈策略分别计算这个增量。\n\n对于 **替换反馈** 策略，更新后的父网格状态 $u_{p,j}^{n+1,\\mathrm{rep}}$ 由下式给出：\n$$u_{p,j}^{n+1,\\mathrm{rep}} = \\big(\\mathcal{A}[u_c^{n+1}]\\big)_j = u_j^{n+1}$$\n相应的更新增量 $\\Delta u_{p,j}^{n+1,\\mathrm{rep}}$ 为：\n$$\\Delta u_{p,j}^{n+1,\\mathrm{rep}} = u_{p,j}^{n+1,\\mathrm{rep}} - u_{p,j}^{n+1,\\mathrm{f}} = u_j^{n+1} - (u_j^{n+1} + e_j) = -e_j$$\n\n对于 **增量更新反馈** 策略，权重为 $\\alpha$，更新后的父网格状态 $u_{p,j}^{n+1,\\mathrm{inc}}$ 为：\n$$u_{p,j}^{n+1,\\mathrm{inc}} = u_{p,j}^{n+1,\\mathrm{f}} + \\alpha\\left(\\big(\\mathcal{A}[u_c^{n+1}]\\big)_j - u_{p,j}^{n+1,\\mathrm{f}}\\right)$$\n根据定义，更新增量 $\\Delta u_{p,j}^{n+1,\\mathrm{inc}}$ 是右侧的第二项：\n$$\\Delta u_{p,j}^{n+1,\\mathrm{inc}} = \\alpha\\left(\\big(\\mathcal{A}[u_c^{n+1}]\\big)_j - u_{p,j}^{n+1,\\mathrm{f}}\\right)$$\n代入括号中各项的已知表达式：\n$$\\Delta u_{p,j}^{n+1,\\mathrm{inc}} = \\alpha\\left(u_j^{n+1} - (u_j^{n+1} + e_j)\\right) = -\\alpha e_j$$\n\n从这些推导中，我们发现对于任何父网格单元 $j$，两种策略的更新增量之间存在直接关系：\n$$\\Delta u_{p,j}^{n+1,\\mathrm{inc}} = \\alpha \\cdot \\Delta u_{p,j}^{n+1,\\mathrm{rep}}$$\n这个简单的代数关系是解决问题的关键。建立此关系并不需要真实解 $u(x,t^{n+1})$ 和误差 $e(x)$ 的详细形式。\n\n现在，我们计算这些增量的离散 $L^2$ 范数。替换反馈的范数是：\n$$\\|\\Delta u_{p}^{n+1}\\|_{2}^{\\mathrm{rep}} = \\left(\\Delta x_{p} \\sum_{j \\in \\Omega_{\\mathrm{nest}}} \\big[\\Delta u_{p,j}^{n+1,\\mathrm{rep}}\\big]^{2}\\right)^{1/2}$$\n增量更新反馈的范数是：\n$$\\|\\Delta u_{p}^{n+1}\\|_{2}^{\\mathrm{inc}} = \\left(\\Delta x_{p} \\sum_{j \\in \\Omega_{\\mathrm{nest}}} \\big[\\Delta u_{p,j}^{n+1,\\mathrm{inc}}\\big]^{2}\\right)^{1/2}$$\n将关系式 $\\Delta u_{p,j}^{n+1,\\mathrm{inc}} = \\alpha \\cdot \\Delta u_{p,j}^{n+1,\\mathrm{rep}}$ 代入增量更新范数的表达式中：\n$$\\|\\Delta u_{p}^{n+1}\\|_{2}^{\\mathrm{inc}} = \\left(\\Delta x_{p} \\sum_{j \\in \\Omega_{\\mathrm{nest}}} \\big[\\alpha \\cdot \\Delta u_{p,j}^{n+1,\\mathrm{rep}}\\big]^{2}\\right)^{1/2} = \\left(\\Delta x_{p} \\sum_{j \\in \\Omega_{\\mathrm{nest}}} \\alpha^2 \\big[\\Delta u_{p,j}^{n+1,\\mathrm{rep}}\\big]^{2}\\right)^{1/2}$$\n由于 $\\alpha$ 是一个常数，我们可以将 $\\alpha^2$ 从求和中提出来：\n$$\\|\\Delta u_{p}^{n+1}\\|_{2}^{\\mathrm{inc}} = \\left(\\alpha^2 \\left(\\Delta x_{p} \\sum_{j \\in \\Omega_{\\mathrm{nest}}} \\big[\\Delta u_{p,j}^{n+1,\\mathrm{rep}}\\big]^{2}\\right)\\right)^{1/2} = |\\alpha| \\left(\\Delta x_{p} \\sum_{j \\in \\Omega_{\\mathrm{nest}}} \\big[\\Delta u_{p,j}^{n+1,\\mathrm{rep}}\\big]^{2}\\right)^{1/2}$$\n这可以简化为：\n$$\\|\\Delta u_{p}^{n+1}\\|_{2}^{\\mathrm{inc}} = |\\alpha| \\cdot \\|\\Delta u_{p}^{n+1}\\|_{2}^{\\mathrm{rep}}$$\n问题陈述要求计算比率 $R$：\n$$R \\equiv \\frac{\\|\\Delta u_{p}^{n+1}\\|_{2}^{\\mathrm{inc}}}{\\|\\Delta u_{p}^{n+1}\\|_{2}^{\\mathrm{rep}}} = \\frac{|\\alpha| \\cdot \\|\\Delta u_{p}^{n+1}\\|_{2}^{\\mathrm{rep}}}{\\|\\Delta u_{p}^{n+1}\\|_{2}^{\\mathrm{rep}}}$$\n假设误差场 $e(x)$ 在单元平均后不恒为零（这是唯一的非平凡情况，否则增量和范数都将为零），我们可以消去范数项：\n$$R = |\\alpha|$$\n问题指定权重 $\\alpha$ 的范围是 $0  \\alpha  1$，所以 $|\\alpha| = \\alpha$。\n给定的权重值为 $\\alpha = \\frac{1}{2}$。\n因此，比率为：\n$$R = \\frac{1}{2} = 0.5$$\n问题要求结果四舍五入到四位有效数字。这得到 $0.5000$。诸如 $c$、$\\kappa$、$r=4$、$U_0$、$E_0$、$k$ 和 $m$ 等无关信息不影响最终的比率。",
            "answer": "$$\\boxed{0.5000}$$"
        },
        {
            "introduction": "这是一个综合性的编程实践，旨在解决实际海洋模型中的一个关键难题。真实的海洋模型常使用地形跟随坐标（如 $\\sigma$ 坐标），这在陡峭地形区域计算水平气压梯度时会引入显著的数值误差，即“气压梯度力误差”（PGE）。当嵌套网格的边界横跨这种地形时，问题会变得更加复杂。本练习要求你构建一个完整的测试案例，在嵌套边界处诊断并量化这种误差，从而将理论概念与海洋模型开发中一个至关重要的实际问题联系起来。",
            "id": "3805945",
            "problem": "考虑一个一维、静力、Boussinesq 海洋模型，该模型使用地形跟随垂直坐标（通常称为 sigma-坐标）进行离散化。假设适用以下基本定律和定义：静力平衡 $dp/dz = -\\rho g$，Boussinesq 近似仅在浮力和压力梯度力中考虑密度变化并使用一个恒定的参考密度，以及使用线性的状态方程来计算密度。设密度场由一个平滑的解析函数给出\n$$\n\\rho(x,z) = \\rho_0 + \\gamma_x x + \\gamma_z z,\n$$\n其中 $x$ 为水平距离（单位：米），$z$ 为垂直距离（单位：米），$z=0$ 对应自由表面且向下为负，$\\rho_0$ 的单位为千克/立方米，梯度 $\\gamma_x$ 和 $\\gamma_z$ 为常数，单位为千克/立方米/米。水深是一个平滑函数 $H(x)$，单位为米。地形跟随垂直坐标定义为\n$$\n\\sigma = -\\frac{z}{H(x)}, \\quad \\sigma \\in [0,1],\n$$\n因此，对于倾斜的海底地形，一个固定的 $\\sigma$ 值对应一个随 $x$ 变化的物理深度 $z(x,\\sigma) = -\\sigma H(x)$。\n\n根据静力平衡和给定的密度，在自由表面高程为零的情况下，点 $(x,z)$ 处的精确静力压力为\n$$\np(x,z) = g \\int_{z}^{0} \\rho(x,\\zeta)\\,d\\zeta = g\\left[-(\\rho_0 + \\gamma_x x)z - \\frac{\\gamma_z}{2}z^2\\right],\n$$\n其中 $g$ 为重力加速度，单位为米/平方秒。在恒定几何深度 $z$ 处的精确水平压力梯度为\n$$\n\\left.\\frac{\\partial p}{\\partial x}\\right|_{z} = -g \\gamma_x z.\n$$\n\n在 sigma-坐标离散化中，边界附近水平压力梯度的一个常见数值近似是沿固定 $\\sigma$ 层级的有限差分，\n$$\n\\left.\\frac{\\partial p}{\\partial x}\\right|_{\\sigma} \\approx \\frac{p(x+\\Delta x, z(x+\\Delta x,\\sigma)) - p(x-\\Delta x, z(x-\\Delta x,\\sigma))}{2\\Delta x},\n$$\n当 $H(x)$ 不为常数时，该路径的几何深度是变化的。这个沿 sigma 路径的梯度与精确的恒定 $z$ 梯度之间的差异就是压力梯度误差 (PGE)，\n$$\n\\mathrm{PGE}(x,\\sigma) = \\left.\\frac{\\partial p}{\\partial x}\\right|_{\\sigma} - \\left.\\frac{\\partial p}{\\partial x}\\right|_{z}.\n$$\n\n您将设计一个关注边界效应的嵌套网格测试。设有一个粗外层网格，包含 $N_c$ 个节点，覆盖范围为 $x\\in[0,L]$，均匀间距为 $\\Delta x_c = L/(N_c-1)$；以及一个嵌套在 $[x_s,x_e]\\subset(0,L)$ 内的细内层网格，包含 $N_f$ 个节点，间距为 $\\Delta x_f = \\Delta x_c/r$，其中 $r\\ge 2$ 为某个整数加密比。水深是线性的，\n$$\nH(x) = H_0 + \\alpha x,\n$$\n其中 $H_00$，斜率 $\\alpha$ 的单位为米/米。等密度面斜率由比率 $s = -\\gamma_x/\\gamma_z$ 隐式确定；当 $\\gamma_z0$ 且 $\\gamma_x0$ 时，该斜率为正，确保等密度面倾斜并穿过任何垂直边界。\n\n在位于 $x_b = x_s + \\Delta x_f$ 的细网格左边界处，考虑使用 $\\sigma_j = j/(M+1)$（对于 $j=1,\\dots,M$，为避免端点的中间层级）且 $M\\ge 2$ 的值，对沿 sigma 路径的水平压力梯度进行离散中心差分近似：\n- 使用来自细网格内部的 $p(x_b+\\Delta x_f, z(x_b+\\Delta x_f,\\sigma_j))$。\n- 使用两种耦合策略之一，从粗网格提供左侧的虚拟值 $p(x_b-\\Delta x_f, z(x_b-\\Delta x_f,\\sigma_j))$：\n    1. 单向嵌套：使用最近的粗网格节点之间的线性插值，将相同 $\\sigma_j$ 处的粗网格压力值插值到 $x_b-\\Delta x_f$。\n    2. 双向嵌套：计算相同的粗网格插值，然后使用一个反馈权重 $\\lambda \\in (0,1)$，将其与来自内部、相同 $\\sigma_j$ 处的细网格线性外插值进行混合，即 $p_{\\text{ghost}} = (1-\\lambda) p_{\\text{coarse-interp}} + \\lambda p_{\\text{fine-extrap}}$，其中细网格外插值为 $p_{\\text{fine-extrap}} = p(x_b,\\sigma_j) - [p(x_b+\\Delta x_f,\\sigma_j) - p(x_b,\\sigma_j)]$。\n\n对于每个 $\\sigma_j$，计算沿 sigma 路径的有限差分\n$$\nG_{\\sigma}(x_b,\\sigma_j) = \\frac{p(x_b+\\Delta x_f, z(x_b+\\Delta x_f,\\sigma_j)) - p_{\\text{ghost}}(x_b-\\Delta x_f, \\sigma_j)}{2\\Delta x_f},\n$$\n以及在代表性深度 $z_b(\\sigma_j) = -\\sigma_j H(x_b)$ 处的精确恒定 $z$ 梯度，\n$$\nG_{z}(x_b,\\sigma_j) = -g \\gamma_x z_b(\\sigma_j).\n$$\n定义边界处的均方根压力梯度误差，\n$$\nE_{\\mathrm{RMS}} = \\sqrt{\\frac{1}{M}\\sum_{j=1}^{M} \\left( G_{\\sigma}(x_b,\\sigma_j) - G_{z}(x_b,\\sigma_j) \\right)^2 }.\n$$\n\n您的任务是实现一个完整的程序，该程序能够：\n1. 根据上述解析公式精确计算 $p(x,z)$。\n2. 按所述构建粗网格和细网格。\n3. 为边界虚拟值实现单向和双向嵌套，并计算细网格左边界处的 $E_{\\mathrm{RMS}}$。\n4. 对提供的测试套件评估 $E_{\\mathrm{RMS}}$ 并打印结果。\n\n使用以下常量和测试套件。所有输出必须以帕斯卡/米 (Pa/m) 为单位，表示为十进制浮点数。\n\n常量：\n- $g = 9.81 \\ \\mathrm{m/s^2}$，$\\rho_0 = 1025 \\ \\mathrm{kg/m^3}$，加密比 $r = 2$，反馈权重 $\\lambda = 0.5$，sigma 中间层级数 $M = 20$。\n\n测试套件参数集 $(L,H_0,\\alpha,N_c,\\gamma_x,\\gamma_z,x_s,x_e,\\mathrm{mode})$：\n- 案例1（正常路径，单向）：$(10000, 100, 1.0\\times 10^{-3}, 65, 1.0\\times 10^{-5}, -1.0\\times 10^{-2}, 2500, 7500, \\text{one-way})$。\n- 案例2（正常路径，双向）：$(10000, 100, 1.0\\times 10^{-3}, 65, 1.0\\times 10^{-5}, -1.0\\times 10^{-2}, 2500, 7500, \\text{two-way})$。\n- 案例3（边界条件边缘情况，平坦水深）：$(10000, 100, 0, 65, 1.0\\times 10^{-5}, -1.0\\times 10^{-2}, 2500, 7500, \\text{one-way})$。\n- 案例4（更陡峭的水深，单向）：$(10000, 100, 1.0\\times 10^{-2}, 65, 1.0\\times 10^{-5}, -1.0\\times 10^{-2}, 2500, 7500, \\text{one-way})$。\n- 案例5（更陡峭的水深，双向）：$(10000, 100, 1.0\\times 10^{-2}, 65, 1.0\\times 10^{-5}, -1.0\\times 10^{-2}, 2500, 7500, \\text{two-way})$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，顺序与上述测试案例一致，例如，“[result1,result2,result3,result4,result5]”。每个结果应为指定案例对应的 $E_{\\mathrm{RMS}}$ 值，单位为 Pa/m。",
            "solution": "该解决方案要求在一个简化的一维海洋模型中，计算嵌套网格边界处的均方根压力梯度误差 ($E_{\\mathrm{RMS}}$)。解决方案涉及基于所提供的物理和数值框架的几个计算步骤。\n\n首先，我们根据问题陈述定义核心的物理函数。水深 $H(x)$ 是水平坐标 $x$ 的线性函数：\n$$\nH(x) = H_0 + \\alpha x\n$$\n其中 $H_0$ 是 $x=0$ 处的深度，$\\alpha$ 是恒定的海底斜率。\n\n地形跟随 sigma-坐标 $\\sigma$ 与几何垂直坐标 $z$ 的关系如下：\n$$\nz(x, \\sigma) = -\\sigma H(x) = -\\sigma(H_0 + \\alpha x)\n$$\n该变换将域 $(x, \\sigma) \\in [0,L] \\times [0,1]$ 映射到由自由表面 $z=0$ 和海底 $z=-H(x)$ 界定的物理域。\n\n静力压力 $p(x,z)$ 由对给定密度场 $\\rho(x,z) = \\rho_0 + \\gamma_x x + \\gamma_z z$ 积分得到的解析公式给出：\n$$\np(x,z) = g\\left[-(\\rho_0 + \\gamma_x x)z - \\frac{\\gamma_z}{2}z^2\\right]\n$$\n其中 $g$ 是重力加速度。\n\n该问题要求在恒定深度 ($z$) 面上的精确水平压力梯度与其在恒定 sigma ($\\sigma$) 面上的数值近似之间进行比较。在点 $(x,z)$ 处的精确梯度为：\n$$\n\\left.\\frac{\\partial p}{\\partial x}\\right|_{z} = -g \\gamma_x z\n$$\n评估将在水平位置 $x_b$ 处的离散垂直层级 $\\sigma_j = j/(M+1)$（对于 $j=1,\\dots,M$）上进行。对应的物理深度为 $z_b(\\sigma_j) = z(x_b, \\sigma_j) = -\\sigma_j H(x_b)$。因此，用于比较的精确梯度为：\n$$\nG_{z}(x_b, \\sigma_j) = \\left.\\frac{\\partial p}{\\partial x}\\right|_{z=z_b(\\sigma_j)} = -g \\gamma_x z_b(\\sigma_j) = g \\gamma_x \\sigma_j H(x_b)\n$$\n\n接下来，我们建立数值网格结构。一个粗网格覆盖域 $x \\in [0,L]$，有 $N_c$ 个节点，产生的网格间距为 $\\Delta x_c = L/(N_c-1)$。一个细网格嵌套在 $[x_s, x_e]$ 内，间距为 $\\Delta x_f = \\Delta x_c / r$，其中 $r$ 是加密比。\n\n数值压力梯度使用位于 $x_b = x_s + \\Delta x_f$（即细网格的第二个节点）的中心差分进行计算。该差分格式使用点 $x_b - \\Delta x_f = x_s$ 和 $x_b + \\Delta x_f = x_s + 2\\Delta x_f$。对于给定的 $\\sigma_j$ 层级，数值梯度为：\n$$\nG_{\\sigma}(x_b, \\sigma_j) = \\frac{p(x_R, z_R) - p_{\\text{ghost}}(x_L, \\sigma_j)}{2\\Delta x_f}\n$$\n其中：\n- 右侧点为 $x_R = x_b + \\Delta x_f$。压力在物理位置 $(x_R, z_R)$ 处计算，其中 $z_R = z(x_R, \\sigma_j)$。因此，压力项为 $p_R = p(x_R, z(x_R, \\sigma_j))$。\n- 左侧点为 $x_L = x_b - \\Delta x_f = x_s$。此边界点上的压力不是直接计算的，而是作为一个“虚拟”值 $p_{\\text{ghost}}$ 提供，其计算取决于嵌套策略。问题陈述意味着 $p_{\\text{ghost}}$ 是水平位置 $x_L$ 处 sigma 层级 $\\sigma_j$ 上的一个值，但其物理深度对应于 $x_L$ 处的水深，即 $z_L = z(x_L, \\sigma_j)$。\n\n在位置 $x_L = x_s$ 处为每个 $\\sigma_j$ 计算 $p_{\\text{ghost}}$ 的过程如下：\n\n1.  **粗网格插值**：首先，我们通过从包围 $x_L$ 的两个最近的粗网格节点进行线性插值来找到值 $p_{\\text{coarse-interp}}$。设这些节点为 $x_{c,k}$ 和 $x_{c,k+1}$，使得 $x_{c,k} \\le x_L  x_{c,k+1}$。索引 $k$ 可以通过 $k = \\lfloor x_L / \\Delta x_c \\rfloor$ 找到。插值权重由 $x_L$ 相对于这些节点的位置确定。粗网格节点上的压力值在相同的 $\\sigma_j$ 面上计算：\n    $$\n    p_{c,k} = p(x_{c,k}, z(x_{c,k}, \\sigma_j))\n    $$\n    $$\n    p_{c,k+1} = p(x_{c,k+1}, z(x_{c,k+1}, \\sigma_j))\n    $$\n    插值后的值为：\n    $$\n    p_{\\text{coarse-interp}} = p_{c,k} + \\frac{p_{c,k+1} - p_{c,k}}{x_{c,k+1} - x_{c,k}} (x_L - x_{c,k})\n    $$\n\n2.  **嵌套策略**：\n    *   **单向嵌套**：虚拟值就是粗网格插值：\n      $$\n      p_{\\text{ghost}} = p_{\\text{coarse-interp}}\n      $$\n    *   **双向嵌套**：虚拟值是粗网格插值和细网格内部外插值的混合。细网格外插值 $p_{\\text{fine-extrap}}$ 使用 $x_b$ 和 $x_b+\\Delta x_f$ 处的值来估计 $x_b - \\Delta x_f = x_L$ 处的值：\n      $$\n      p_{\\text{fine-extrap}} = p(x_b, z(x_b, \\sigma_j)) - \\left[ p(x_b+\\Delta x_f, z(x_b+\\Delta x_f, \\sigma_j)) - p(x_b, z(x_b, \\sigma_j)) \\right]\n      $$\n      最终的虚拟值是使用反馈权重 $\\lambda$ 的加权平均值：\n      $$\n      p_{\\text{ghost}} = (1-\\lambda) p_{\\text{coarse-interp}} + \\lambda p_{\\text{fine-extrap}}\n      $$\n\n最后，对于每个测试案例，通过对所有 $M$ 个 sigma 层级上数值梯度和精确梯度之间的差的平方进行平均，来计算均方根误差：\n$$\nE_{\\mathrm{RMS}} = \\sqrt{\\frac{1}{M}\\sum_{j=1}^{M} \\left( G_{\\sigma}(x_b, \\sigma_j) - G_{z}(x_b, \\sigma_j) \\right)^2 }\n$$\n\n对于 $\\alpha = 0$ 的特殊情况，水深 $H(x) = H_0$ 是恒定的。因此，对于任何固定的 $\\sigma_j$，深度 $z(x,\\sigma_j) = -\\sigma_j H_0$ 也是恒定的。对于固定的 $z$，压力函数 $p(x,z)$ 在 $x$ 方向上是线性的。因此，$x$ 方向的线性插值是精确的。粗网格插值将产生精确的压力值，因此 $p_{\\text{coarse-interp}}$ 将是精确的。这意味着对于单向嵌套，数值梯度 $G_\\sigma$ 将完全等于在 $z$ 层级上的解析有限差分，对于线性压力场，这等于真实导数。因此，对于案例3，我们预期 $E_{\\mathrm{RMS}} = 0$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the RMS pressure gradient error for a series of nested-grid test cases.\n    \"\"\"\n    # Constants\n    g = 9.81  # m/s^2\n    rho_0 = 1025.0  # kg/m^3\n    r = 2.0  # refinement ratio\n    lambda_blend = 0.5  # two-way feedback weight\n    M = 20  # number of sigma mid-levels\n\n    # Test suite parameter sets\n    # (L, H0, alpha, Nc, gamma_x, gamma_z, x_s, x_e, mode)\n    test_cases = [\n        (10000.0, 100.0, 1.0e-3, 65, 1.0e-5, -1.0e-2, 2500.0, 7500.0, 'one-way'),\n        (10000.0, 100.0, 1.0e-3, 65, 1.0e-5, -1.0e-2, 2500.0, 7500.0, 'two-way'),\n        (10000.0, 100.0, 0.0, 65, 1.0e-5, -1.0e-2, 2500.0, 7500.0, 'one-way'),\n        (10000.0, 100.0, 1.0e-2, 65, 1.0e-5, -1.0e-2, 2500.0, 7500.0, 'one-way'),\n        (10000.0, 100.0, 1.0e-2, 65, 1.0e-5, -1.0e-2, 2500.0, 7500.0, 'two-way'),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        L, H0, alpha, Nc, gamma_x, gamma_z, x_s, x_e, mode = case\n\n        # Helper functions defined within the case scope to capture parameters\n        def H(x):\n            return H0 + alpha * x\n\n        def z_coord(x, sigma):\n            return -sigma * H(x)\n\n        def pressure(x, z_val):\n            term1 = -(rho_0 + gamma_x * x) * z_val\n            term2 = - (gamma_z / 2.0) * z_val**2\n            return g * (term1 + term2)\n\n        # Grid setup\n        dx_c = L / (Nc - 1)\n        dx_f = dx_c / r\n\n        # Key x-locations for the finite difference stencil\n        x_b = x_s + dx_f  # Stencil center\n        x_L = x_b - dx_f  # Left point (ghost)\n        x_R = x_b + dx_f  # Right point\n\n        # Sigma levels\n        sigma_levels = np.array([j / (M + 1) for j in range(1, M + 1)])\n\n        squared_errors = []\n\n        for sigma_j in sigma_levels:\n            # --- Exact Gradient ---\n            z_at_xb = z_coord(x_b, sigma_j)\n            G_z = -g * gamma_x * z_at_xb\n\n            # --- Numerical Gradient Calculation ---\n            \n            # 1. Right point value (fine grid interior)\n            z_at_xR = z_coord(x_R, sigma_j)\n            p_R = pressure(x_R, z_at_xR)\n\n            # 2. Left point value (ghost point at x_L = x_s)\n            \n            # 2a. Coarse-grid interpolation to x_L\n            k = int(np.floor(x_L / dx_c))\n            x_c_k = k * dx_c\n            x_c_k1 = (k + 1) * dx_c\n            \n            z_c_k = z_coord(x_c_k, sigma_j)\n            p_c_k = pressure(x_c_k, z_c_k)\n            \n            z_c_k1 = z_coord(x_c_k1, sigma_j)\n            p_c_k1 = pressure(x_c_k1, z_c_k1)\n\n            interp_weight = (x_L - x_c_k) / dx_c\n            p_coarse_interp = p_c_k * (1.0 - interp_weight) + p_c_k1 * interp_weight\n\n            p_ghost = 0.0\n            if mode == 'one-way':\n                p_ghost = p_coarse_interp\n            elif mode == 'two-way':\n                # 2b. Fine-grid extrapolation to x_L\n                z_at_xb_fine = z_coord(x_b, sigma_j)\n                p_at_xb_fine = pressure(x_b, z_at_xb_fine)\n                \n                z_at_xR_fine = z_coord(x_R, sigma_j)\n                p_at_xR_fine = pressure(x_R, z_at_xR_fine)\n                \n                p_fine_extrap = p_at_xb_fine - (p_at_xR_fine - p_at_xb_fine)\n                \n                # 2c. Blending\n                p_ghost = (1.0 - lambda_blend) * p_coarse_interp + lambda_blend * p_fine_extrap\n\n            # 3. Compute numerical gradient G_sigma\n            G_sigma = (p_R - p_ghost) / (2.0 * dx_f)\n\n            # 4. Store squared error\n            squared_errors.append((G_sigma - G_z)**2)\n        \n        # Compute RMS error for the case\n        E_rms = np.sqrt(np.mean(squared_errors))\n        results.append(E_rms)\n\n    # Print results in the required format\n    print(f\"[{results[0]},{results[1]},{results[2]},{results[3]},{results[4]}]\")\n\nsolve()\n```"
        }
    ]
}