{
    "hands_on_practices": [
        {
            "introduction": "Before applying any numerical filter, one must first ensure the integrity of the discretely sampled data. This foundational practice delves into the Nyquist-Shannon sampling theorem, a cornerstone of digital signal processing, by applying it to a core physical oceanography problem. You will derive the minimum sampling rate required to unambiguously capture inertial oscillations, which are high-frequency motions driven by Earth's rotation, thereby preventing the corruption of your data by aliasing .",
            "id": "3803618",
            "problem": "An ocean mooring at latitude $\\phi=45^{\\circ}$ records horizontal current velocity to study inertial oscillations. In the absence of pressure gradients and friction, the horizontal momentum equations on an $f$-plane are governed by the Coriolis acceleration with parameter $f=2\\Omega\\sin\\phi$, where $\\Omega$ is the Earth's rotation rate. You are tasked with designing the sampling strategy so that subsequent numerical filtering does not suffer from aliasing of the inertial band into lower frequencies.\n\nStarting from the linearized momentum equations and the definition of angular frequency, derive the condition on the sampling rate $f_{s}$ (in Hertz, $\\mathrm{s}^{-1}$) required to avoid aliasing of inertial oscillations, and then compute the minimum $f_{s}$ at $\\phi=45^{\\circ}$ using $\\Omega=7.2921159\\times 10^{-5}\\ \\mathrm{s}^{-1}$. Justify the choice of $f_{s}$ from first principles, explicitly invoking the Nyquist-Shannon sampling theorem. Express the final sampling rate in Hertz ($\\mathrm{s}^{-1}$), and round your numerical result to four significant figures.",
            "solution": "The problem as stated is scientifically grounded, well-posed, and contains all necessary information for a unique and meaningful solution. It will be addressed by first deriving the frequency of inertial oscillations from the governing equations of motion and then applying the Nyquist-Shannon sampling theorem to determine the minimum required sampling rate.\n\nThe horizontal momentum equations on an $f$-plane, in the absence of pressure gradients and friction, describe a balance solely between the local acceleration and the Coriolis force. For a fluid parcel with velocity components $u$ (zonal, positive eastward) and $v$ (meridional, positive northward), these equations are:\n$$\n\\frac{du}{dt} - fv = 0 \\quad (1)\n$$\n$$\n\\frac{dv}{dt} + fu = 0 \\quad (2)\n$$\nHere, $f = 2\\Omega\\sin\\phi$ is the Coriolis parameter, where $\\Omega$ is the Earth's angular rotation rate and $\\phi$ is the latitude.\n\nTo find the characteristic frequency of this system, we can form a single second-order differential equation. Differentiating equation $(1)$ with respect to time $t$ gives:\n$$\n\\frac{d^2u}{dt^2} - f\\frac{dv}{dt} = 0\n$$\nWe can substitute for $\\frac{dv}{dt}$ using equation $(2)$:\n$$\n\\frac{d^2u}{dt^2} - f(-fu) = 0\n$$\n$$\n\\frac{d^2u}{dt^2} + f^2 u = 0\n$$\nThis is the canonical form of the equation for a simple harmonic oscillator, $\\frac{d^2x}{dt^2} + \\omega^2 x = 0$. By direct comparison, the angular frequency of the motion, known as the inertial angular frequency, is:\n$$\n\\omega_{\\text{inertial}} = |f|\n$$\nThe cyclical frequency, $\\nu_{\\text{inertial}}$, is related to the angular frequency by $\\nu = \\frac{\\omega}{2\\pi}$. Therefore, the frequency of inertial oscillations is:\n$$\n\\nu_{\\text{inertial}} = \\frac{|f|}{2\\pi}\n$$\nAt the specified latitude $\\phi=45^{\\circ}$, which is in the Northern Hemisphere, $\\sin\\phi > 0$ and thus $f > 0$. Consequently, $|f| = f$.\n$$\n\\nu_{\\text{inertial}} = \\frac{f}{2\\pi}\n$$\nThis represents the highest frequency component in the idealized system described.\n\nTo prevent aliasing, we must invoke the Nyquist-Shannon sampling theorem. The theorem states that for a bandlimited signal with a maximum frequency component $\\nu_{\\text{max}}$, the sampling frequency $f_s$ must be strictly greater than twice this maximum frequency. This minimum bound, $2\\nu_{\\text{max}}$, is known as the Nyquist frequency. The condition to avoid aliasing is:\n$$\nf_s > 2\\nu_{\\text{max}}\n$$\nIn our case, the maximum frequency of the physical process is the inertial frequency, so $\\nu_{\\text{max}} = \\nu_{\\text{inertial}}$. The condition on the sampling rate is therefore:\n$$\nf_s > 2\\nu_{\\text{inertial}} = 2\\left(\\frac{f}{2\\pi}\\right) = \\frac{f}{\\pi}\n$$\nThe problem asks for the minimum sampling rate required to avoid aliasing. This corresponds to the Nyquist frequency of the system:\n$$\nf_{s, \\text{min}} = 2\\nu_{\\text{inertial}} = \\frac{f}{\\pi} = \\frac{2\\Omega\\sin\\phi}{\\pi}\n$$\nWe are given the values:\n$\\Omega = 7.2921159 \\times 10^{-5}\\ \\mathrm{s}^{-1}$\n$\\phi = 45^{\\circ}$\n\nFirst, we calculate the Coriolis parameter $f$:\n$$\nf = 2 \\times (7.2921159 \\times 10^{-5}\\ \\mathrm{s}^{-1}) \\times \\sin(45^{\\circ})\n$$\nSince $\\sin(45^{\\circ}) = \\frac{\\sqrt{2}}{2}$:\n$$\nf = 2 \\times (7.2921159 \\times 10^{-5}\\ \\mathrm{s}^{-1}) \\times \\frac{\\sqrt{2}}{2} = \\sqrt{2} \\times 7.2921159 \\times 10^{-5}\\ \\mathrm{s}^{-1}\n$$\n$$\nf \\approx 1.03126402 \\times 10^{-4}\\ \\mathrm{s}^{-1}\n$$\nNow, we can compute the minimum required sampling rate $f_{s}$:\n$$\nf_{s} = \\frac{f}{\\pi} \\approx \\frac{1.03126402 \\times 10^{-4}\\ \\mathrm{s}^{-1}}{\\pi} \\approx 3.282639 \\times 10^{-5}\\ \\mathrm{s}^{-1}\n$$\nThe problem requires the result to be rounded to four significant figures.\n$$\nf_{s} \\approx 3.283 \\times 10^{-5}\\ \\mathrm{s}^{-1}\n$$\nThis sampling rate is specified in Hertz ($\\mathrm{s}^{-1}$). In practice, one would sample at a rate somewhat higher than this minimum to ensure a clear separation between the signal and the Nyquist frequency. However, the theoretical minimum is what the problem demands.",
            "answer": "$$\n\\boxed{3.283 \\times 10^{-5}}\n$$"
        },
        {
            "introduction": "With a properly sampled dataset, we can turn to the task of filtering. This exercise introduces one of the simplest and most intuitive numerical filters, the 1-2-1 or Shapiro filter, which acts as a low-pass smoother. By deriving and implementing this filter's amplitude response, you will gain hands-on experience with how a filter's discrete stencil selectively dampens high-frequency (short-wavelength) components, a fundamental technique for removing grid-scale noise in numerical models and data .",
            "id": "3803574",
            "problem": "You are given a latitude–longitude computational grid used in ocean circulation modeling. Consider constructing a one-dimensional, single-pass 1-2-1 Shapiro filter along the zonal (longitude) direction on this grid, with periodic boundary conditions in longitude. The filter is defined by a fixed, symmetric three-point stencil applied to a discrete field $f_i$ sampled at equally spaced zonal positions $x_i$, where $x_i = i\\,\\Delta x$ and $\\Delta x$ is the local zonal grid spacing expressed in $\\mathrm{km}$. The stencil is given by weights $\\{1,2,1\\}$ normalized to unit sum and acts as a convolution operator. Assume that the internal wave packet of interest is narrowband and can be approximated locally by a monochromatic signal $f(x) = A \\cos(k x)$ with horizontal wavelength $\\lambda = 50\\ \\mathrm{km}$, where $k = 2\\pi/\\lambda$ is the wavenumber. Angles in any trigonometric expressions must be handled in radians.\n\nStarting from the fundamental definitions of discrete convolution and the Discrete Fourier Transform (DFT), derive the amplitude response of the single-pass 1-2-1 Shapiro filter to a monochromatic component of the internal wave $f(x)$ sampled on the grid. Use the fact that a linear, shift-invariant discrete filter acts multiplicatively on sinusoidal components in the DFT domain and that a symmetric stencil implies zero phase shift.\n\nQuantify the filter’s effect by computing the amplitude multiplier $M(\\Delta x)$ applied to the monochromatic component after a single pass of the filter along the zonal direction, as a function of the grid spacing $\\Delta x$ and the fixed wavelength $\\lambda = 50\\ \\mathrm{km}$. Express the amplitude multiplier as a unitless float.\n\nImplement your derivation in a complete, runnable program that produces numeric results for the following test suite of grid spacings, all expressed in $\\mathrm{km}$: $\\Delta x \\in \\{2.0,\\ 5.0,\\ 12.5,\\ 25.0,\\ 50.0\\}$. These values are chosen to test multiple regimes: very fine spacing relative to the wavelength, moderate spacing, quarter-wavelength spacing, half-wavelength spacing (Nyquist limit), and spacing equal to the wavelength.\n\nYour program must:\n- Construct the 1-2-1 Shapiro filter operator along longitude with periodic boundary conditions (conceptually; you must implement a function that applies the operator to a one-dimensional array).\n- From first principles, compute the analytic amplitude multiplier $M(\\Delta x)$ for a single pass of the filter acting on a monochromatic component with $\\lambda = 50\\ \\mathrm{km}$.\n- For each $\\Delta x$ in the test suite, output the value of $M(\\Delta x)$.\n\nUnits and formatting requirements:\n- $\\Delta x$ and $\\lambda$ are in $\\mathrm{km}$.\n- All angles in trigonometric functions are in radians.\n- The final outputs are unitless floats.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test suite $\\Delta x$ values, with each float rounded to six decimal places. For example, a valid output format is $[m_1,m_2,m_3,m_4,m_5]$.",
            "solution": "The problem has been validated and is determined to be a well-posed, scientifically grounded problem in the field of numerical analysis as applied to computational oceanography.\n\nThe objective is to derive and compute the amplitude response, or multiplier $M$, of a single-pass $1$–$2$–$1$ Shapiro filter applied to a monochromatic wave. The filter is applied along a discrete grid in the zonal direction.\n\nFirst, we define the filter operation. The Shapiro filter uses a three-point stencil with weights $\\{1, 2, 1\\}$, which must be normalized to have a unit sum. The sum of weights is $1+2+1=4$. Thus, the normalized weights are $\\{1/4, 1/2, 1/4\\}$. Let $f_i$ represent the value of a discrete field at grid point $i$, where the grid points are separated by a uniform spacing $\\Delta x$. The application of the filter produces a new field $f'_i$ defined by the discrete convolution:\n$$ f'_i = \\frac{1}{4}f_{i-1} + \\frac{1}{2}f_{i} + \\frac{1}{4}f_{i+1} $$\n\nThe input signal is a monochromatic wave, given in its continuous form as $f(x) = A \\cos(k x)$, where $A$ is the amplitude, $k=2\\pi/\\lambda$ is the wavenumber, and $\\lambda = 50\\ \\mathrm{km}$ is the wavelength. On the discrete grid where $x_i = i\\,\\Delta x$, the signal is sampled as:\n$$ f_i = A \\cos(k x_i) = A \\cos(k i \\Delta x) $$\n\nWe now apply the filter to this discrete signal $f_i$:\n$$ f'_i = A \\left[ \\frac{1}{4}\\cos(k(i-1)\\Delta x) + \\frac{1}{2}\\cos(k i \\Delta x) + \\frac{1}{4}\\cos(k(i+1)\\Delta x) \\right] $$\n\nTo simplify this expression, we use the trigonometric sum and difference identities for cosine:\n$\\cos(\\alpha \\mp \\beta) = \\cos(\\alpha)\\cos(\\beta) \\pm \\sin(\\alpha)\\sin(\\beta)$.\nLet $\\alpha = k i \\Delta x$ and $\\beta = k \\Delta x$.\nThe terms $\\cos(k(i \\pm 1)\\Delta x)$ become:\n$$ \\cos(k(i-1)\\Delta x) = \\cos(k i \\Delta x)\\cos(k \\Delta x) + \\sin(k i \\Delta x)\\sin(k \\Delta x) $$\n$$ \\cos(k(i+1)\\Delta x) = \\cos(k i \\Delta x)\\cos(k \\Delta x) - \\sin(k i \\Delta x)\\sin(k \\Delta x) $$\n\nSubstituting these into the expression for $f'_i$:\n$$ f'_i = A \\left[ \\frac{1}{4}(\\cos(k i \\Delta x)\\cos(k \\Delta x) + \\sin(k i \\Delta x)\\sin(k \\Delta x)) + \\frac{1}{2}\\cos(k i \\Delta x) + \\frac{1}{4}(\\cos(k i \\Delta x)\\cos(k \\Delta x) - \\sin(k i \\Delta x)\\sin(k \\Delta x)) \\right] $$\n\nThe sine terms cancel out, yielding:\n$$ f'_i = A \\left[ \\frac{1}{4}\\cos(k i \\Delta x)\\cos(k \\Delta x) + \\frac{1}{2}\\cos(k i \\Delta x) + \\frac{1}{4}\\cos(k i \\Delta x)\\cos(k \\Delta x) \\right] $$\n$$ f'_i = A \\left[ \\frac{1}{2}\\cos(k i \\Delta x)\\cos(k \\Delta x) + \\frac{1}{2}\\cos(k i \\Delta x) \\right] $$\n\nFactoring out the common terms $\\frac{1}{2}$ and $\\cos(k i \\Delta x)$:\n$$ f'_i = A \\cos(k i \\Delta x) \\left[ \\frac{1}{2}(1 + \\cos(k \\Delta x)) \\right] $$\n\nSince the original signal at point $i$ is $f_i = A \\cos(k i \\Delta x)$, we can write the filtered signal as:\n$$ f'_i = M(\\Delta x) \\cdot f_i $$\nwhere the amplitude multiplier $M(\\Delta x)$ is:\n$$ M(\\Delta x) = \\frac{1}{2}(1 + \\cos(k \\Delta x)) $$\n\nAs suggested by the problem, this result can also be derived by analyzing the filter's frequency response. The frequency response $H(\\hat{\\omega})$ of a discrete filter with impulse response (weights) $h_n$ is its Discrete-Time Fourier Transform (DTFT):\n$$ H(\\hat{\\omega}) = \\sum_{n=-\\infty}^{\\infty} h_n e^{-j \\hat{\\omega} n} $$\nwhere $\\hat{\\omega}$ is the normalized angular frequency. For our symmetric filter with weights $h_{-1}=1/4$, $h_0=1/2$, and $h_1=1/4$:\n$$ H(\\hat{\\omega}) = h_{-1} e^{j \\hat{\\omega}} + h_0 e^{0} + h_1 e^{-j \\hat{\\omega}} = \\frac{1}{4}e^{j\\hat{\\omega}} + \\frac{1}{2} + \\frac{1}{4}e^{-j\\hat{\\omega}} $$\n\nUsing Euler's identity $e^{j\\hat{\\omega}} + e^{-j\\hat{\\omega}} = 2\\cos(\\hat{\\omega})$, we get:\n$$ H(\\hat{\\omega}) = \\frac{1}{2} + \\frac{1}{4}(2\\cos(\\hat{\\omega})) = \\frac{1}{2}(1 + \\cos(\\hat{\\omega})) $$\nThis is a real-valued function, which confirms the zero phase shift for a symmetric filter. The amplitude response is $|H(\\hat{\\omega})|$.\nFor a continuous wave $\\cos(kx)$ sampled with spacing $\\Delta x$, the discrete signal is $\\cos(k i \\Delta x) = \\cos((k\\Delta x)i)$. The normalized angular frequency corresponds to the physical wavenumber and grid spacing as $\\hat{\\omega} = k\\Delta x$.\nSubstituting this into the response function gives the amplitude multiplier for the specific wavenumber $k$:\n$$ M(k, \\Delta x) = H(k\\Delta x) = \\frac{1}{2}(1 + \\cos(k\\Delta x)) $$\nThis confirms the result from our first-principles derivation.\n\nFor elegance and improved numerical stability, we can use the half-angle trigonometric identity $\\cos^2(\\theta) = \\frac{1+\\cos(2\\theta)}{2}$. Setting $2\\theta = k\\Delta x$, we obtain a more compact expression for the amplitude multiplier:\n$$ M(\\Delta x) = \\cos^2\\left(\\frac{k \\Delta x}{2}\\right) $$\n\nTo finalize the formula for implementation, we substitute $k = 2\\pi/\\lambda$:\n$$ M(\\Delta x) = \\cos^2\\left(\\frac{(2\\pi/\\lambda) \\Delta x}{2}\\right) = \\cos^2\\left(\\frac{\\pi \\Delta x}{\\lambda}\\right) $$\n\nWe will now use this final expression to compute the amplitude multiplier for the given test suite of $\\Delta x$ values, with $\\lambda = 50\\ \\mathrm{km}$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the amplitude multiplier of a 1-2-1 Shapiro filter for a\n    monochromatic wave with a given wavelength, evaluated at several\n    grid spacings.\n    \"\"\"\n\n    # Define the test cases and physical constants from the problem statement.\n    # The wavelength of the internal wave packet.\n    lambda_wave = 50.0  # in km\n\n    # The test suite of grid spacings.\n    delta_x_values = [\n        2.0,   # Very fine spacing\n        5.0,   # Moderate spacing\n        12.5,  # Quarter-wavelength spacing (lambda/4)\n        25.0,  # Half-wavelength spacing (lambda/2, Nyquist limit)\n        50.0   # Wavelength spacing (lambda)\n    ] # in km\n\n    results = []\n    \n    # The derived amplitude multiplier M is given by the analytic formula:\n    # M(delta_x) = cos^2(pi * delta_x / lambda)\n    # This formula quantifies the damping effect of the filter as a function\n    # of the ratio of grid spacing to wavelength.\n\n    for dx in delta_x_values:\n        # The argument of the cosine function is pi * (delta_x / lambda).\n        # This is the fundamental non-dimensional parameter that governs the\n        # filter's response.\n        argument = np.pi * dx / lambda_wave\n        \n        # Calculate the amplitude multiplier. The result is unitless.\n        multiplier = np.cos(argument) ** 2\n        \n        results.append(multiplier)\n\n    # Format the results into the specified string format.\n    # Each float must be rounded to six decimal places.\n    # The f-string format specifier f\"{value:.6f}\" achieves this.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    \n    # The final print statement must produce only the single-line format\n    # specified in the problem: a comma-separated list enclosed in\n    # square brackets.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving beyond simple smoothing, this advanced practice addresses a common and more complex challenge: the targeted removal of specific, energetic signals from a time series. Here, you will design a Butterworth band-stop filter to eliminate the dominant semi-diurnal tidal constituents, which often mask lower-frequency signals of interest. This exercise demonstrates the practical design of a sophisticated filter, including the critical trade-off between filter order and the sharpness of the frequency transition, providing a powerful tool for signal isolation in oceanographic data analysis .",
            "id": "3803585",
            "problem": "You are given a uniformly sampled time series of sea surface height and asked to design digital filters that remove the dominant semi-diurnal tidal constituents by attenuating frequency content around the principal lunar semi-diurnal tide and the principal solar semi-diurnal tide. The principal lunar semi-diurnal tide has angular frequency $\\omega_{M2}$, and the principal solar semi-diurnal tide has angular frequency $\\omega_{S2}$, defined by $\\omega = 2\\pi/T$ where $T$ is the period in seconds. For this problem, use $T_{M2} = 44712\\,\\mathrm{s}$ and $T_{S2} = 43200\\,\\mathrm{s}$, so that $\\omega_{M2} = 2\\pi/44712$ and $\\omega_{S2} = 2\\pi/43200$ in radians per second.\n\nYou must construct, for each specified test case, two separate digital Butterworth band-stop filters (one centered at $\\omega_{M2}$ and one centered at $\\omega_{S2}$) with explicitly defined stopband half-widths and transition half-widths, and determine the minimal filter order needed to guarantee at least 40 dB attenuation in the stopband. Assume a passband ripple of 1 dB is allowed. Treat each band-stop filter independently and then form a cascaded filter that applies both notches in sequence.\n\nStart from the following fundamental base:\n- The sampling theorem and discrete-time frequency normalization: with sampling interval $\\Delta t$ (in seconds), sampling frequency $f_s = 1/\\Delta t$ (in cycles per second), Nyquist frequency $f_N = f_s/2$, and normalized digital frequency $W = f/f_N$ where $f = \\omega/(2\\pi)$.\n- The Butterworth magnitude response for the low-pass prototype, which yields a monotonic response characterized by order $n$ and cutoff, and standard frequency transformations to create band-stop filters.\n- The definition of attenuation and ripple in decibels: an attenuation of $A$ dB corresponds to a magnitude ratio $10^{-A/20}$, and passband ripple of $R$ dB corresponds to a magnitude deviation characterized by $10^{R/20}$.\n\nDesign requirements for each band-stop filter in a test case:\n1. Let the center angular frequency be $\\omega_0 \\in \\{\\omega_{M2}, \\omega_{S2}\\}$. Convert it to cycles per second $f_0 = \\omega_0/(2\\pi)$ and normalize by $f_N$ to obtain the normalized center $W_0 = f_0/f_N$.\n2. You are given a stopband half-width $\\delta\\omega_{\\mathrm{stop}}$ and a transition half-width $\\delta\\omega_{\\mathrm{trans}}$, both in radians per second. Convert them to cycles per second via $\\delta f_{\\mathrm{stop}} = \\delta\\omega_{\\mathrm{stop}}/(2\\pi)$ and $\\delta f_{\\mathrm{trans}} = \\delta\\omega_{\\mathrm{trans}}/(2\\pi)$.\n3. Define the stopband edges in cycles per second as $f_{s1} = f_0 - \\delta f_{\\mathrm{stop}}$ and $f_{s2} = f_0 + \\delta f_{\\mathrm{stop}}$. Define the passband edges just outside the stopband as $f_{p1} = f_0 - \\delta f_{\\mathrm{stop}} - \\delta f_{\\mathrm{trans}}$ and $f_{p2} = f_0 + \\delta f_{\\mathrm{stop}} + \\delta f_{\\mathrm{trans}}$. Normalize all edges by $f_N$ to get $W_{s1}, W_{s2}, W_{p1}, W_{p2}$ with $W_{x} = f_x/f_N$.\n4. Use a Butterworth order computation consistent with these band-stop specifications and the given passband ripple $g_{\\mathrm{pass}} = 1\\,\\mathrm{dB}$ and stopband attenuation $g_{\\mathrm{stop}} = 40\\,\\mathrm{dB}$ to determine the minimal order $n$ for each band-stop filter. Then design the corresponding digital Butterworth band-stop filter.\n5. Cascade the two band-stop filters (one for $\\omega_{M2}$ and one for $\\omega_{S2}$). For the purpose of reporting the total order, use the sum of the individual minimal orders determined for the two constituent filters.\n\nYour program must compute, for each test case, the triple `[n_{M2}, n_{S2}, n_{total}]` where $n_{M2}$ is the minimal order for the $\\omega_{M2}$ band-stop filter, $n_{S2}$ is the minimal order for the $\\omega_{S2}$ band-stop filter, and $n_{\\mathrm{total}} = n_{M2} + n_{S2}$ is the order of the cascaded design in terms of the sum of the orders of its constituent filters. The final output must be a single line containing a list of these triples for all test cases.\n\nAngle unit: radians per second for all angular frequencies and widths. No other angle units are allowed.\n\nUse the following test suite, which spans typical oceanographic sampling scenarios and transition sharpnesses:\n- Test Case 1 (happy path): $\\Delta t = 900\\,\\mathrm{s}$, $\\delta\\omega_{\\mathrm{stop}} = 2\\pi \\times 1.0\\times 10^{-6}\\,\\mathrm{rad/s}$, $\\delta\\omega_{\\mathrm{trans}} = 2\\pi \\times 4.0\\times 10^{-7}\\,\\mathrm{rad/s}$.\n- Test Case 2 (sharper transition with finer sampling): $\\Delta t = 600\\,\\mathrm{s}$, $\\delta\\omega_{\\mathrm{stop}} = 2\\pi \\times 7.0\\times 10^{-7}\\,\\mathrm{rad/s}$, $\\delta\\omega_{\\mathrm{trans}} = 2\\pi \\times 2.0\\times 10^{-7}\\,\\mathrm{rad/s}$.\n- Test Case 3 (coarser sampling with wider transition): $\\Delta t = 3600\\,\\mathrm{s}$, $\\delta\\omega_{\\mathrm{stop}} = 2\\pi \\times 1.2\\times 10^{-6}\\,\\mathrm{rad/s}$, $\\delta\\omega_{\\mathrm{trans}} = 2\\pi \\times 6.0\\times 10^{-7}\\,\\mathrm{rad/s}$.\n\nFor each test case, apply the design to both $\\omega_{M2}$ and $\\omega_{S2}$ using the provided widths. If any intermediate frequency edges would fall outside the valid normalized range $0  W  1$, clamp them to be strictly inside this interval while preserving the ordering $W_{p1}  W_{s1}  W_{s2}  W_{p2}$. If clamping prevents a valid ordering, the test case should be treated as infeasible; in this test suite all cases are feasible.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the list `[n_{M2},n_{S2},n_{total}]` for the corresponding test case, in the same order as listed above. For example, the output format should look like `[[n_{M2}^{(1)},n_{S2}^{(1)},n_{total}^{(1)}],[n_{M2}^{(2)},n_{S2}^{(2)},n_{total}^{(2)}],[n_{M2}^{(3)},n_{S2}^{(3)},n_{total}^{(3)}]`. All numbers must be integers with no units in the output.",
            "solution": "The problem as stated is scientifically and mathematically sound, well-posed, and contains all necessary information for a unique solution. It requests the design of digital filters based on canonical principles of signal processing within a realistic oceanographic context. Therefore, a solution is warranted.\n\nThe core task is to determine the minimum order for two separate Butterworth band-stop filters, designed to attenuate the principal lunar ($M2$) and solar ($S2$) semi-diurnal tidal components in a time series of sea surface height. The problem then requires summing these orders to find the order of a conceptually cascaded filter.\n\nThe fundamental tidal frequencies are given by their periods, $T_{M2} = 44712\\,\\mathrm{s}$ and $T_{S2} = 43200\\,\\mathrm{s}$. The corresponding angular frequencies are $\\omega_{M2} = 2\\pi/T_{M2}$ and $\\omega_{S2} = 2\\pi/T_{S2}$. In cycles per second (Hz), these are $f_{M2} = 1/T_{M2}$ and $f_{S2} = 1/T_{S2}$.\n\nThe design of a digital filter requires that all frequencies be normalized with respect to the Nyquist frequency. Given a sampling interval $\\Delta t$, the sampling frequency is $f_s = 1/\\Delta t$, and the Nyquist frequency is $f_N = f_s/2$. An analog frequency $f$ (in Hz) is mapped to a normalized digital frequency $W$ via the relation $W = f/f_N$. The normalized frequency range is $W \\in [0, 1]$, where $W=0$ corresponds to DC and $W=1$ corresponds to the Nyquist frequency.\n\nA band-stop filter is defined by a stopband, where frequencies are attenuated, and passbands, where frequencies are largely unaffected. The specifications for our filters are:\n1.  A passband ripple of no more than $g_{\\mathrm{pass}} = 1\\,\\mathrm{dB}$. This means the magnitude response in the passband must not drop below $10^{-g_{\\mathrm{pass}}/20} \\approx 0.891$.\n2.  A stopband attenuation of at least $g_{\\mathrm{stop}} = 40\\,\\mathrm{dB}$. This means the magnitude response in the stopband must not exceed $10^{-g_{\\mathrm{stop}}/20} = 0.01$.\n\nThe design procedure for each tidal component, centered at an angular frequency $\\omega_0$ (either $\\omega_{M2}$ or $\\omega_{S2}$), is as follows:\n\nFirst, we convert all specifications from angular frequency (rad/s) to cycles per second (Hz). The center frequency is $f_0 = \\omega_0 / (2\\pi)$. The stopband half-width is $\\delta f_{\\mathrm{stop}} = \\delta\\omega_{\\mathrm{stop}} / (2\\pi)$ and the transition half-width is $\\delta f_{\\mathrm{trans}} = \\delta\\omega_{\\mathrm{trans}} / (2\\pi)$.\n\nSecond, we define the critical frequencies that delineate the passbands and stopband:\n-   Stopband edges: $f_{s1} = f_0 - \\delta f_{\\mathrm{stop}}$ and $f_{s2} = f_0 + \\delta f_{\\mathrm{stop}}$.\n-   Passband edges: $f_{p1} = f_{s1} - \\delta f_{\\mathrm{trans}}$ and $f_{p2} = f_{s2} + \\delta f_{\\mathrm{trans}}$.\n\nThird, these frequencies are normalized by the Nyquist frequency $f_N = 1/(2\\Delta t)$:\n- Passband edges: $W_{p1} = f_{p1}/f_N$ and $W_{p2} = f_{p2}/f_N$.\n- Stopband edges: $W_{s1} = f_{s1}/f_N$ and $W_{s2} = f_{s2}/f_N$.\nThe problem requires that these normalized frequencies must lie strictly between $0$ and $1$. If any calculated edge falls outside this range, it must be clamped to be within it, for instance within a small margin $[\\epsilon, 1-\\epsilon]$ for a small $\\epsilon>0$.\n\nFourth, we determine the minimum filter order $n$ for a Butterworth filter that meets these specifications. The order of a Butterworth filter dictates the steepness of its transition from passband to stopband. For a given set of specifications ($W_p$, $W_s$, $g_{\\mathrm{pass}}$, $g_{\\mathrm{stop}}$), there is a minimum integer order $n$ that can satisfy them. This calculation involves mapping the band-stop specifications to an equivalent low-pass prototype filter, accounting for the frequency warping inherent in the standard bilinear transform used to create digital filters from analog prototypes. The order $n$ of the analog low-pass prototype is given by:\n$$ n \\ge \\frac{\\log_{10}\\left(\\frac{10^{0.1 g_{\\mathrm{stop}}} - 1}{10^{0.1 g_{\\mathrm{pass}}} - 1}\\right)}{2\\log_{10}\\left(\\frac{\\Omega_s}{\\Omega_p}\\right)} $$\nwhere $\\Omega_s$ and $\\Omega_p$ are the stopband and passband edge frequencies of the warped prototype. Standard computational libraries provide functions that encapsulate this entire procedure, taking the digital frequency specifications and returning the minimum integer order $n$.\n\nThis process is executed independently for the $M2$ and $S2$ components for each test case, yielding the minimal orders $n_{M2}$ and $n_{S2}$. The total order of the cascaded filter, which applies both filtering operations, is defined as the sum of the individual orders: $n_{\\mathrm{total}} = n_{M2} + n_{S2}$. This represents the complexity of a filter whose transfer function is the product of the two individual filter transfer functions.\n\nThe following Python program implements this design procedure for the provided test cases. It calculates the necessary frequency parameters, normalizes them, and then uses the `buttord` function from the `scipy.signal` library to find the minimum filter order for each component. The results are then aggregated and formatted as specified.",
            "answer": "```python\nimport numpy as np\nfrom scipy.signal import buttord\n\ndef solve():\n    \"\"\"\n    Designs Butterworth band-stop filters for tidal constituents and computes their minimal orders.\n    \"\"\"\n    # Define physical constants for tidal constituents\n    # Period of principal lunar semi-diurnal tide (s)\n    T_M2 = 44712.0\n    # Period of principal solar semi-diurnal tide (s)\n    T_S2 = 43200.0\n\n    # Angular frequencies in rad/s\n    omega_M2 = 2 * np.pi / T_M2\n    omega_S2 = 2 * np.pi / T_S2\n    \n    # Filter specifications\n    g_pass = 1.0  # Passband ripple (dB)\n    g_stop = 40.0 # Stopband attenuation (dB)\n\n    test_cases = [\n        # (delta_t, d_omega_stop, d_omega_trans)\n        (900.0, 2 * np.pi * 1.0e-6, 2 * np.pi * 4.0e-7),\n        (600.0, 2 * np.pi * 7.0e-7, 2 * np.pi * 2.0e-7),\n        (3600.0, 2 * np.pi * 1.2e-6, 2 * np.pi * 6.0e-7),\n    ]\n\n    results = []\n\n    def calculate_order(omega_0, delta_t, d_omega_stop, d_omega_trans):\n        \"\"\"\n        Calculates the minimum Butterworth filter order for a single band-stop filter.\n\n        Args:\n            omega_0 (float): Center angular frequency of the stopband (rad/s).\n            delta_t (float): Sampling interval (s).\n            d_omega_stop (float): Stopband half-width (rad/s).\n            d_omega_trans (float): Transition half-width (rad/s).\n\n        Returns:\n            int: The minimal filter order.\n        \"\"\"\n        # Calculate sampling and Nyquist frequencies in Hz\n        f_s = 1.0 / delta_t\n        f_N = f_s / 2.0\n\n        # Convert angular frequencies (rad/s) to standard frequencies (Hz)\n        f_0 = omega_0 / (2 * np.pi)\n        df_stop = d_omega_stop / (2 * np.pi)\n        df_trans = d_omega_trans / (2 * np.pi)\n\n        # Define band-stop and passband edges in Hz\n        f_s1 = f_0 - df_stop\n        f_s2 = f_0 + df_stop\n        f_p1 = f_s1 - df_trans\n        f_p2 = f_s2 + df_trans\n\n        # Normalize frequencies by the Nyquist frequency\n        W_p1 = f_p1 / f_N\n        W_p2 = f_p2 / f_N\n        W_s1 = f_s1 / f_N\n        W_s2 = f_s2 / f_N\n        \n        # Clamp frequencies to be strictly within (0, 1) as per problem statement\n        # A small epsilon is used to avoid boundary issues.\n        epsilon = 1e-9\n        W_p1 = np.clip(W_p1, epsilon, 1.0 - epsilon)\n        W_p2 = np.clip(W_p2, epsilon, 1.0 - epsilon)\n        W_s1 = np.clip(W_s1, epsilon, 1.0 - epsilon)\n        W_s2 = np.clip(W_s2, epsilon, 1.0 - epsilon)\n\n        # Use scipy.signal.buttord to find the minimum order\n        # wp: Passband edge frequencies (normalized)\n        # ws: Stopband edge frequencies (normalized)\n        wp = [W_p1, W_p2]\n        ws = [W_s1, W_s2]\n        \n        order, _ = buttord(wp, ws, g_pass, g_stop, analog=False)\n        return int(order)\n\n    for case in test_cases:\n        delta_t, d_omega_stop, d_omega_trans = case\n\n        # Calculate minimal order for M2 tide component\n        n_M2 = calculate_order(omega_M2, delta_t, d_omega_stop, d_omega_trans)\n\n        # Calculate minimal order for S2 tide component\n        n_S2 = calculate_order(omega_S2, delta_t, d_omega_stop, d_omega_trans)\n\n        # Total order of the cascaded filter\n        n_total = n_M2 + n_S2\n\n        results.append([n_M2, n_S2, n_total])\n\n    # Format the final output string\n    # e.g., [[1, 2, 3],[4, 5, 9]] - \"[[1, 2, 3],[4, 5, 9]]\"\n    result_str = \",\".join(map(str, results))\n    final_output = f\"[{result_str}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}