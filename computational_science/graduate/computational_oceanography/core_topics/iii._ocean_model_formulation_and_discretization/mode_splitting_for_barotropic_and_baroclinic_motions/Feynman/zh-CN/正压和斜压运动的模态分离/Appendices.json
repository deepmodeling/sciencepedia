{
    "hands_on_practices": [
        {
            "introduction": "在分裂显式方案中，快速移动的外部（正压）引力波的稳定性通常是计算效率的主要瓶颈。本练习将指导您完成一个基本但至关重要的计算：如何根据变化的测深数据确定整个模型区域内允许的最大稳定时间步长。通过计算由外部引力波速度 $c = \\sqrt{gH}$ 决定的科朗-弗里德里希斯-路维（CFL）条件，您将掌握在海洋模型中设置正压模态时间步长的核心技能。",
            "id": "3799110",
            "problem": "考虑一个分别解析正压（外部）和斜压（内部）运动的分裂-显式海洋模型。正压模态采用显式格式推进，该格式需要满足 Courant–Friedrichs–Lewy (CFL) 稳定性限制。给定一个在 Arakawa C-网格上的一维沿断面离散化：海面高度 $\\eta$ 位于网格中心，正压速度 $u$ 位于网格面上。正压模态的控制性线性化浅水方程（忽略科里奥利力和摩擦力）为\n$$\n\\eta_{t} + \\partial_{x}\\left(H u\\right) = 0, \\qquad u_{t} + g\\,\\eta_{x} = 0,\n$$\n其中 $H(x)$ 是水深， $g$ 是重力加速度。在离散通量中，网格面上的深度取相邻网格中心深度的算术平均值。\n\n沿着长度为 $L = 50\\,\\mathrm{km}$、均匀网格间距为 $\\Delta x = 10\\,\\mathrm{km}$ 的断面，六个网格中心的深度为\n$$\nH_{1} = 50\\,\\mathrm{m},\\quad H_{2} = 75\\,\\mathrm{m},\\quad H_{3} = 150\\,\\mathrm{m},\\quad H_{4} = 1000\\,\\mathrm{m},\\quad H_{5} = 3000\\,\\mathrm{m},\\quad H_{6} = 3800\\,\\mathrm{m}.\n$$\n设重力加速度为 $g = 9.81\\,\\mathrm{m}\\,\\mathrm{s}^{-2}$。正压求解器使用一个统一的快模态时间步长 $\\Delta t_{\\mathrm{b}}$ 和一个相对于稳定性极限的安全 Courant 因子 $\\nu = 0.80$。\n\n从上述给定的线性化浅水方程以及所述的网格交错和网格面深度定义出发，推导沿每个网格面的离散外重力波传播速度，确定该断面施加的最严格的稳定性约束，并计算确保沿整个断面处处稳定的单一全局 $\\Delta t_{\\mathrm{b}}$。最终答案以秒为单位表示，并四舍五入到三位有效数字。在你的推理过程中，明确地根据给定的 $H_{i}$ 构建有效网格面深度 $H_{\\mathrm{f}}$，并说明陡峭的海底地形如何改变不同区域的逐面传播速度，从而改变允许的快模态时间步长。",
            "solution": "用户希望我严格验证一个计算海洋学问题，并在其有效的情况下进行求解。\n\n### **问题验证**\n\n**第 1 步：提取已知条件**\n\n*   **模型和网格：** 一个采用一维 Arakawa C-网格离散化的分裂-显式海洋模型。海面高度 $\\eta$ 位于网格中心，正压速度 $u$ 位于网格面上。\n*   **控制方程（线性化浅水方程）：**\n    $$\n    \\eta_{t} + \\partial_{x}\\left(H u\\right) = 0, \\qquad u_{t} + g\\,\\eta_{x} = 0\n    $$\n*   **参数和定义：**\n    *   $H(x)$：水深。\n    *   $g = 9.81\\,\\mathrm{m}\\,\\mathrm{s}^{-2}$：重力加速度。\n    *   离散网格面深度：网格面上的深度是两个相邻网格中心深度的算术平均值。\n*   **域和离散化：**\n    *   断面长度：$L = 50\\,\\mathrm{km}$。\n    *   均匀网格间距：$\\Delta x = 10\\,\\mathrm{km}$。\n    *   六个网格中心（$i=1, \\dots, 6$）的深度：\n        *   $H_{1} = 50\\,\\mathrm{m}$\n        *   $H_{2} = 75\\,\\mathrm{m}$\n        *   $H_{3} = 150\\,\\mathrm{m}$\n        *   $H_{4} = 1000\\,\\mathrm{m}$\n        *   $H_{5} = 3000\\,\\mathrm{m}$\n        *   $H_{6} = 3800\\,\\mathrm{m}$\n*   **数值格式：**\n    *   正压求解器使用一个统一的快模态时间步长 $\\Delta t_{\\mathrm{b}}$。\n    *   它是一种受 Courant–Friedrichs–Lewy (CFL) 稳定性限制的显式格式。\n    *   使用了一个安全 Courant 因子 $\\nu = 0.80$。\n\n**第 2 步：使用提取的已知条件进行验证**\n\n1.  **科学依据：** 该问题牢固地植根于计算流体动力学和物理海洋学的基本原理。线性化浅水方程是正压重力波的标准模型，而 Arakawa C-网格、分裂-显式时间步进和 CFL 条件是数值海洋模拟中的经典概念。\n2.  **适定性：** 该问题是适定的。它提供了计算稳定时间步长的单一、唯一定义数值所需的所有必要信息。\n3.  **客观性：** 该问题以精确、客观和标准的科学术语陈述。\n4.  **一致性：** 存在一个潜在的歧义：6 个宽度为 $\\Delta x = 10\\,\\mathrm{km}$ 的网格将跨越 $60\\,\\mathrm{km}$ 的总长度，而不是 $50\\,\\mathrm{km}$。然而，通过将 $L = 50\\,\\mathrm{km}$ 的“断面长度”解释为计算动力学的距离，这个问题可以得到解决。在具有 $N=6$ 个标量网格的 C-网格上，有 $N-1=5$ 个计算速度的内部网格面。这个速度网格的总长度是 $(N-1)\\Delta x = 5 \\times 10\\,\\mathrm{km} = 50\\,\\mathrm{km}$。这种解释使得问题陈述完全一致。\n5.  **真实性：** 给定的深度代表了从大陆架到深海平原的真实过渡。物理常数和数值参数都是标准的。\n\n**第 3 步：结论和行动**\n\n该问题是有效的。其前提在科学上是合理的，数据在对网格设置的标准解释下是一致的，并且问题是适定的。我将继续进行求解。\n\n### **问题求解**\n\n目标是找到正压模态求解器允许的最大稳定时间步长 $\\Delta t_{\\mathrm{b}}$。这由显式数值格式的 Courant–Friedrichs–Lewy (CFL) 稳定性条件决定。\n\n控制方程描述了外重力波的传播。通过对第一个方程取时间导数，对第二个方程取空间导数，并将两者结合（并假设 $H$ 变化缓慢，这是推导波速的常见简化），可以得到波动方程：\n$$ \\eta_{tt} = \\partial_t(-\\partial_x(Hu)) = -\\partial_x(H u_t) = -\\partial_x(H(-g\\eta_x)) = g\\partial_x(H\\eta_x) \\approx gH \\eta_{xx} $$\n这是一个标准的波动方程 $\\eta_{tt} = c^2 \\eta_{xx}$，其中重力波的相速度为 $c = \\sqrt{gH}$。\n\n对于网格间距为 $\\Delta x$ 的显式数值格式，CFL 稳定性条件要求数值依赖域必须包含物理依赖域。对于以速度 $c$ 传播的波，该条件由以下公式给出：\n$$ \\Delta t \\le \\frac{\\Delta x}{c} $$\n由于正压时间步长 $\\Delta t_{\\mathrm{b}}$ 必须确保整个计算域的稳定性，它必须受到模型网格中任何地方出现的最快波速 $c_{\\max}$ 的约束：\n$$ \\Delta t_{\\mathrm{b}} \\le \\frac{\\Delta x}{c_{\\max}} $$\n问题指定了一个安全 Courant 因子 $\\nu = 0.80$。因此，选择的时间步长为：\n$$ \\Delta t_{\\mathrmb} = \\nu \\frac{\\Delta x}{c_{\\max}} $$\n波速 $c$ 取决于局部深度 $H$。在交错的 Arakawa C-网格上，速度 $u$ 在网格之间的面上计算。速度更新的稳定性取决于质量通量项 $(Hu)$ 中使用的深度。问题指出，面上的深度（我们记为 $H_{\\mathrmf}$）是两个相邻网格深度的算术平均值。因此，对于索引为 $i+1/2$ 的网格 $i$ 和网格 $i+1$ 之间的面，有效深度为：\n$$ H_{\\mathrmf, i+1/2} = \\frac{H_i + H_{i+1}}{2} $$\n因此，该面上的局部重力波速度为 $c_{i+1/2} = \\sqrt{g H_{\\mathrmf, i+1/2}}$。最严格的条件，也就是决定全局时间步长的条件，对应于最大波速，它出现在具有最大有效深度 $H_{\\mathrmf, \\max}$ 的面上。\n$$ c_{\\max} = \\sqrt{g H_{\\mathrmf, \\max}} $$\n我们有 6 个网格，因此有 5 个内部面，在这些面上定义了速度 $u$ 和相应的有效面深度 $H_{\\mathrmf}$。让我们根据给定的网格中心深度 $H_i$ 计算这些面深度：\n$H_{1} = 50\\,\\mathrm{m}$, $H_{2} = 75\\,\\mathrm{m}$, $H_{3} = 150\\,\\mathrm{m}$, $H_{4} = 1000\\,\\mathrm{m}$, $H_{5} = 3000\\,\\mathrm{m}$, $H_{6} = 3800\\,\\mathrm{m}$。\n\n五个面深度为：\n$H_{\\mathrmf, 1.5} = \\frac{H_1 + H_2}{2} = \\frac{50 + 75}{2} = 62.5\\,\\mathrm{m}$\n$H_{\\mathrmf, 2.5} = \\frac{H_2 + H_3}{2} = \\frac{75 + 150}{2} = 112.5\\,\\mathrm{m}$\n$H_{\\mathrmf, 3.5} = \\frac{H_3 + H_4}{2} = \\frac{150 + 1000}{2} = 575\\,\\mathrm{m}$\n$H_{\\mathrmf, 4.5} = \\frac{H_4 + H_5}{2} = \\frac{1000 + 3000}{2} = 2000\\,\\mathrm{m}$\n$H_{\\mathrmf, 5.5} = \\frac{H_5 + H_6}{2} = \\frac{3000 + 3800}{2} = 3400\\,\\mathrm{m}$\n\n最大面深度为 $H_{\\mathrmf, \\max} = H_{\\mathrmf, 5.5} = 3400\\,\\mathrm{m}$。这是向深海过渡最显著的区域，也是外重力波传播最快的地方。\n\n最大波速为：\n$$ c_{\\max} = \\sqrt{g H_{\\mathrmf, \\max}} = \\sqrt{(9.81\\,\\mathrm{m}\\,\\mathrm{s}^{-2})(3400\\,\\mathrm{m})} = \\sqrt{33354}\\,\\mathrm{m}\\,\\mathrm{s}^{-1} \\approx 182.631\\,\\mathrm{m}\\,\\mathrm{s}^{-1} $$\n现在我们可以计算稳定的时间步长 $\\Delta t_{\\mathrmb}$。给定的 SI 单位参数为：\n$\\nu = 0.80$\n$\\Delta x = 10\\,\\mathrm{km} = 10000\\,\\mathrm{m}$\n$g = 9.81\\,\\mathrm{m}\\,\\mathrm{s}^{-2}$\n$H_{\\mathrmf, \\max} = 3400\\,\\mathrm{m}$\n\n$$ \\Delta t_{\\mathrmb} = \\nu \\frac{\\Delta x}{\\sqrt{g H_{\\mathrmf, \\max}}} = 0.80 \\times \\frac{10000\\,\\mathrm{m}}{\\sqrt{9.81\\,\\mathrm{m}\\,\\mathrm{s}^{-2} \\times 3400\\,\\mathrm{m}}} $$\n$$ \\Delta t_{\\mathrmb} = \\frac{8000}{\\sqrt{33354}}\\,\\mathrm{s} \\approx \\frac{8000}{182.631}\\,\\mathrm{s} \\approx 43.8043\\,\\mathrm{s} $$\n问题要求最终答案四舍五入到三位有效数字。\n$$ \\Delta t_{\\mathrmb} \\approx 43.8\\,\\mathrm{s} $$\n这个单一的全局时间步长确保了正压模态的数值解在整个断面上保持稳定，即使在 Courant 数本应最大的最深区域也是如此。$H_5$ 和 $H_6$ 之间的陡峭海底坡度产生了最大的面深度，从而导致了最严格的稳定性约束。",
            "answer": "$$\n\\boxed{43.8}\n$$"
        },
        {
            "introduction": "与由深度决定的单一正压模态不同，斜压模态的结构由水体的垂直分层决定。这种分层由浮力频率（或布伦特-维萨拉频率）的平方 $N^2(z)$ 来量化，它是垂直模态分解的关键输入。本练习将指导您从温盐剖面的一阶物理原理出发，推导并计算 $N^2(z)$ 剖面，并将其处理成适用于数值求解器的平滑、非负函数。",
            "id": "3799111",
            "problem": "给定一个海洋水柱的离散垂直温度和盐度剖面，它们是深度的函数。目标是使用物理上一致的海水状态方程，在 Boussinesq 近似和静水力近似下，计算浮力频率的平方 $N^2(z)$，然后准备一个光滑的非负函数 $N^2(z)$，以用作正压和斜压运动垂直模态分解的输入。推导必须从第一性原理开始，并且程序必须相应地实现该算法。\n\n假设使用以下广泛应用的近似：\n- Boussinesq 近似，使用一个恒定的参考密度 $\\rho_0$。\n- 静水平衡和小振幅扰动，这是线性稳定性度量 $N^2$ 的理论基础。\n- 线性化的海水状态方程：$\\rho(T,S) = \\rho_0 \\left(1 - \\alpha (T - T_\\mathrm{ref}) + \\beta (S - S_\\mathrm{ref})\\right)$，其中 $\\alpha$ 是热膨胀系数，$\\beta$ 是盐收缩系数，$T$ 是位温（单位：摄氏度），$S$ 是实用盐度（单位：无量纲的实用盐度单位，PSU）。参考值 $T_\\mathrm{ref}$ 和 $S_\\mathrm{ref}$ 是常数，在垂直微分中会被消去，不影响 $N^2$。\n\n使用以下标准常数：\n- 重力加速度 $g = 9.81$，单位为 $\\mathrm{m\\,s^{-2}}$。\n- 热膨胀系数 $\\alpha = 2.0 \\times 10^{-4}$，单位为 $\\mathrm{K^{-1}}$。\n- 盐收缩系数 $\\beta = 7.6 \\times 10^{-4}$，单位为 $\\mathrm{(PSU)^{-1}}$。\n- 参考密度 $\\rho_0$ 是恒定的（其确切数值在下述 $N^2$ 的线性化公式中被消去，数值上不需要）。\n\n设深度 $d$ 以米为单位，向下为正，自由表面处 $d = 0$。设 $T(d)$ 和 $S(d)$ 是在跨越 $[0,1000]$ 米的离散网格 $\\{d_i\\}_{i=0}^{N-1}$ 上采样的给定剖面。从第一性原理出发，以指向上方的垂直坐标 $z$ 定义的浮力频率平方为\n$$\nN^2(z) = - \\frac{g}{\\rho_0} \\frac{\\partial \\rho}{\\partial z}.\n$$\n当深度坐标 $d$ 向下为正时，链式法则给出\n$$\n\\frac{\\partial}{\\partial z} = -\\frac{\\partial}{\\partial d},\n$$\n并使用线性化的海水状态方程，密度对深度的垂直导数为\n$$\n\\frac{\\partial \\rho}{\\partial d} = \\rho_0\\left(-\\alpha \\frac{\\partial T}{\\partial d} + \\beta \\frac{\\partial S}{\\partial d}\\right).\n$$\n因此，\n$$\nN^2(d) = \\frac{g}{\\rho_0} \\frac{\\partial \\rho}{\\partial d} = g\\left(\\beta \\frac{\\partial S}{\\partial d} - \\alpha \\frac{\\partial T}{\\partial d}\\right).\n$$\n\n将 $N^2(d)$ 准备成适用于垂直模态分解的函数的算法要求如下：\n1. 使用在内部为二阶精确、在边界为单侧的相容有限差分方法，在给定的深度网格上计算离散的垂直梯度 $\\frac{\\partial T}{\\partial d}$ 和 $\\frac{\\partial S}{\\partial d}$。\n2. 通过线性化公式 $N^2(d) = g\\left(\\beta \\frac{\\partial S}{\\partial d} - \\alpha \\frac{\\partial T}{\\partial d}\\right)$ 计算 $N^2(d)$，单位为 $\\mathrm{s^{-2}}$。\n3. 通过将 $N^2(d)$ 裁剪到一个最小下限值 $N^2_\\mathrm{min} = 10^{-6}$（单位为 $\\mathrm{s^{-2}}$）来强制满足 Sturm–Liouville 良定性所需的非负性，即，设 $N^2(d) \\leftarrow \\max(N^2(d), N^2_\\mathrm{min})$。\n4. 使用分段三次 Hermite 插值多项式 (PCHIP) 构建一个光滑、保形的插值函数 $\\widehat{N^2}(d)$，以便可以在垂直模态求解器所需的任意深度上评估 $\\widehat{N^2}(d)$，而不会产生过冲伪影。\n\n您的程序必须实现上述算法，并在一组指定的查询深度上为多个测试用例评估准备好的函数 $\\widehat{N^2}(d)$。所有输出都必须以 $\\mathrm{s^{-2}}$ 为单位，使用科学记数法表示，并至少保留六位小数。此问题不使用角度。最终输出必须是单行文本，包含所有测试用例的汇总结果，格式为方括号括起来的逗号分隔列表，其中每个测试用例的结果也是一个用方括号括起来的逗号分隔值列表，例如：$[[r_{1,1},r_{1,2}],[r_{2,1},r_{2,2}]]$，不含空格。\n\n测试套件（以物理上合理的形式提供所有 $T(d)$ 和 $S(d)$）：\n\n- 测试用例 1（良好分层的温跃层）：\n  - 深度网格：$d_i \\in [0,1000]$ 米，$N = 501$ 个均匀间隔的点。\n  - 温度：$T(d) = 20 - 15 \\tanh\\left(\\frac{d - 200}{150}\\right)$，单位为摄氏度。\n  - 盐度：$S(d) = 34.5 + 0.5 \\tanh\\left(\\frac{d - 300}{200}\\right)$，单位为 PSU。\n  - 查询深度（单位：米）：$[0,100,250,500,1000]$。\n\n- 测试用例 2（近乎未分层的水柱）：\n  - 深度网格：$d_i \\in [0,1000]$ 米，$N = 501$ 个均匀间隔的点。\n  - 温度：$T(d) = 10$，单位为摄氏度。\n  - 盐度：$S(d) = 35$，单位为 PSU。\n  - 查询深度（单位：米）：$[0,100,250,500,1000]$。\n\n- 测试用例 3（带有小振荡的弱不稳定层，需要裁剪）：\n  - 深度网格：$d_i \\in [0,1000]$ 米，$N = 501$ 个均匀间隔的点。\n  - 温度：$T(d) = 14 + 0.5 \\sin\\left(\\frac{2\\pi d}{120}\\right) - 11 \\frac{d}{1000}$，单位为摄氏度。\n  - 盐度：$S(d) = 34.8 + 0.2 \\cos\\left(\\frac{2\\pi d}{180}\\right) + 0.1 \\frac{d}{1000}$，单位为 PSU。\n  - 查询深度（单位：米）：$[0,100,250,500,1000]$。\n\n您的程序应生成单行输出，其中包含结果，格式为方括号括起来的逗号分隔列表，每个测试用例的结果是在指定查询深度处的 $\\widehat{N^2}(d)$ 值的逗号分隔列表（单位为 $\\mathrm{s^{-2}}$），采用科学记数法，至少保留六位小数，且不含任何空格。例如，格式必须为 $[[v_{1,1},v_{1,2},\\ldots,v_{1,5}],[v_{2,1},\\ldots,v_{2,5}],[v_{3,1},\\ldots,v_{3,5}]]$.",
            "solution": "该问题是有效的，因为它科学地基于地球物理流体动力学原理，问题定义良好，有清晰的算法路径可通向唯一解，并以客观、正式的语言表述。我们着手进行求解。\n\n**基于原理的推导**\n\n浮力频率的平方 $N^2$ 量化了在分层介质中垂直位移的流体质点所受的恢复力。在稳定分层中，一个被位移的流体质点会比其新环境的密度小（如果向上位移）或大（如果向下位移），从而导致它围绕其平衡位置振荡。$N$ 代表了这种振荡的频率。\n\n当垂直坐标 $z$ 从海底指向上方时，$N^2(z)$ 定义为：\n$$\nN^2(z) = - \\frac{g}{\\rho_0} \\frac{\\partial \\rho}{\\partial z}\n$$\n其中 $g$ 是重力加速度，$\\rho$ 是位密度，$\\rho_0$ 是一个恒定的参考密度，这与 Boussinesq 近似一致。该近似假设密度的变化与参考密度相比很小，除非乘以 $g$。\n\n该问题使用一个向下为正的深度坐标 $d$，其中海面处 $d=0$。两个坐标之间的关系意味着 $\\partial/\\partial z = -\\partial/\\partial d$。将此代入 $N^2$ 的定义中可得：\n$$\nN^2(d) = \\frac{g}{\\rho_0} \\frac{\\partial \\rho}{\\partial d}\n$$\n\n位密度 $\\rho$ 是位温 $T$ 和盐度 $S$ 的函数。提供了一个线性化的状态方程：\n$$\n\\rho(T, S) = \\rho_0 \\left(1 - \\alpha (T - T_{\\mathrm{ref}}) + \\beta (S - S_{\\mathrm{ref}})\\right)\n$$\n这里，$\\alpha$ 是热膨胀系数，$\\beta$ 是盐收缩系数，$T_{\\mathrm{ref}}$ 和 $S_{\\mathrm{ref}}$ 是恒定的参考值。为了求出垂直密度梯度，我们使用链式法则对 $\\rho$ 关于深度 $d$ 求导：\n$$\n\\frac{\\partial \\rho}{\\partial d} = \\frac{\\partial \\rho}{\\partial T} \\frac{\\partial T}{\\partial d} + \\frac{\\partial \\rho}{\\partial S} \\frac{\\partial S}{\\partial d}\n$$\n根据线性化的状态方程，偏导数分别为 $\\partial \\rho / \\partial T = -\\rho_0 \\alpha$ 和 $\\partial \\rho / \\partial S = \\rho_0 \\beta$。代入这些可得：\n$$\n\\frac{\\partial \\rho}{\\partial d} = \\rho_0 \\left(-\\alpha \\frac{\\partial T}{\\partial d} + \\beta \\frac{\\partial S}{\\partial d}\\right)\n$$\n\n最后，将此密度梯度表达式代回 $N^2(d)$ 的公式中：\n$$\nN^2(d) = \\frac{g}{\\rho_0} \\left[ \\rho_0 \\left(-\\alpha \\frac{\\partial T}{\\partial d} + \\beta \\frac{\\partial S}{\\partial d}\\right) \\right]\n$$\n参考密度 $\\rho_0$ 被消去，得到最终的计算公式：\n$$\nN^2(d) = g \\left(\\beta \\frac{\\partial S}{\\partial d} - \\alpha \\frac{\\partial T}{\\partial d}\\right)\n$$\n这个方程表明，稳定性（$N^2 > 0$）会因盐度随深度增加（$\\partial S/\\partial d > 0$，即下方是更咸、密度更大的水）和温度随深度降低（$\\partial T/\\partial d  0$，即下方是更冷、密度更大的水）而增强。\n\n**数值算法设计**\n\n该问题要求一个四步算法，将离散的 $T(d)$ 和 $S(d)$ 剖面转换为一个连续、光滑且非负的函数 $\\widehat{N^2}(d)$。\n\n1.  **离散梯度计算**：给定在深度均匀网格 $\\{d_i\\}_{i=0}^{N-1}$（间距 $h = d_{i+1} - d_i$）上的离散剖面 $T_i = T(d_i)$ 和 $S_i = S(d_i)$，必须数值近似垂直梯度 $\\partial T/\\partial d$ 和 $\\partial S/\\partial d$。为保持良好的精度，指定了二阶有限差分格式。对于内部点（$1 \\le i \\le N-2$），使用中心差分公式：\n    $$\n    f'(d_i) \\approx \\frac{f(d_{i+1}) - f(d_{i-1})}{2h}\n    $$\n    对于边界，需要使用二阶精确的单侧公式以避免降低整体精度。在表面（$i=0$）：\n    $$\n    f'(d_0) \\approx \\frac{-3f(d_0) + 4f(d_1) - f(d_2)}{2h}\n    $$\n    在底部（$i=N-1$）：\n    $$\n    f'(d_{N-1}) \\approx \\frac{3f(d_{N-1}) - 4f(d_{N-2}) + f(d_{N-3})}{2h}\n    $$\n    这些计算产生 $(\\partial T/\\partial d)_i$ 和 $(\\partial S/\\partial d)_i$ 的离散数组。\n\n2.  **$N^2(d)$ 剖面计算**：使用计算出的梯度和给定的常数 $g = 9.81\\,\\mathrm{m\\,s^{-2}}$、$\\alpha = 2.0 \\times 10^{-4}\\,\\mathrm{K^{-1}}$ 和 $\\beta = 7.6 \\times 10^{-4}\\,\\mathrm{(PSU)^{-1}}$，在每个网格点 $d_i$ 上使用推导出的公式计算离散的浮力频率平方剖面 $(N^2)_i$：\n    $$\n    (N^2)_i = g \\left(\\beta \\left(\\frac{\\partial S}{\\partial d}\\right)_i - \\alpha \\left(\\frac{\\partial T}{\\partial d}\\right)_i\\right)\n    $$\n\n3.  **强制非负性**：使用 $N^2(d)$ 作为系数的垂直模态问题通常被表述为 Sturm-Liouville 特征值问题。为了使该问题良定，系数 $N^2(d)$ 必须处处非负。在物理上，$N^2  0$ 对应于一个静态不稳定的水柱，其中会发生对流，从而使线性稳定性模型失效。为了进行线性分析，通过将计算出的 $N^2$ 值裁剪到一个小的正下限值 $N^2_{\\mathrm{min}} = 10^{-6}\\,\\mathrm{s^{-2}}$，对这些不稳定区域进行数值正则化。\n    $$\n    (N^2_{\\text{clipped}})_i = \\max\\left((N^2)_i, N^2_{\\mathrm{min}}\\right)\n    $$\n    这一步确保了模态分析具有物理上和数学上稳定的背景状态。\n\n4.  **光滑、保形插值**：必须将离散的、裁剪后的剖面 $(N^2_{\\text{clipped}})_i$ 转换为一个可在任意深度求值的连续函数 $\\widehat{N^2}(d)$。标准的立方样条插值可能会在网格点之间引入虚假的振荡（过冲），这可能违反非负性约束。此处指定使用分段三次 Hermite 插值多项式 (PCHIP)，因为它是保形的。它尊重所提供数据点的单调性，确保如果离散数据是非负的，插值函数在点之间也同样是非负的。这样可以得到一个光滑函数 $\\widehat{N^2}(d)$，它能准确反映物理分层而不会引入数值伪影。然后使用此函数在每个测试用例的指定查询深度上评估 $N^2$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import PchipInterpolator\n\ndef solve():\n    \"\"\"\n    Computes and prepares the squared buoyancy frequency profile N^2(d)\n    for several test cases, following the algorithm specified in the problem.\n    \"\"\"\n    # Define physical constants.\n    g = 9.81  # Gravitational acceleration in m/s^2\n    alpha = 2.0e-4  # Thermal expansion coefficient in K^-1\n    beta = 7.6e-4  # Haline contraction coefficient in (PSU)^-1\n    N2_min = 1.0e-6  # Minimum floor for N^2 in s^-2\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"d_range\": (0.0, 1000.0),\n            \"N_points\": 501,\n            \"T_func\": lambda d: 20.0 - 15.0 * np.tanh((d - 200.0) / 150.0),\n            \"S_func\": lambda d: 34.5 + 0.5 * np.tanh((d - 300.0) / 200.0),\n            \"query_depths\": [0.0, 100.0, 250.0, 500.0, 1000.0],\n        },\n        {\n            \"d_range\": (0.0, 1000.0),\n            \"N_points\": 501,\n            \"T_func\": lambda d: np.full_like(d, 10.0),\n            \"S_func\": lambda d: np.full_like(d, 35.0),\n            \"query_depths\": [0.0, 100.0, 250.0, 500.0, 1000.0],\n        },\n        {\n            \"d_range\": (0.0, 1000.0),\n            \"N_points\": 501,\n            \"T_func\": lambda d: 14.0 + 0.5 * np.sin(2.0 * np.pi * d / 120.0) - 11.0 * d / 1000.0,\n            \"S_func\": lambda d: 34.8 + 0.2 * np.cos(2.0 * np.pi * d / 180.0) + 0.1 * d / 1000.0,\n            \"query_depths\": [0.0, 100.0, 250.0, 500.0, 1000.0],\n        },\n    ]\n\n    all_results = []\n    for case in test_cases:\n        # Generate the depth grid and corresponding T/S profiles.\n        d_grid = np.linspace(case[\"d_range\"][0], case[\"d_range\"][1], case[\"N_points\"])\n        T_profile = case[\"T_func\"](d_grid)\n        S_profile = case[\"S_func\"](d_grid)\n        \n        # Calculate grid spacing for finite differences.\n        h = d_grid[1] - d_grid[0]\n\n        # Step 1: Compute discrete vertical gradients using second-order accurate differences.\n        # np.gradient with edge_order=2 uses second-order central differences for the interior\n        # and second-order one-sided differences for the boundaries.\n        dT_dd = np.gradient(T_profile, h, edge_order=2)\n        dS_dd = np.gradient(S_profile, h, edge_order=2)\n\n        # Step 2: Compute N^2(d) via the linearized formula.\n        N2_profile = g * (beta * dS_dd - alpha * dT_dd)\n\n        # Step 3: Enforce non-negativity by clipping to a minimum floor.\n        N2_clipped = np.maximum(N2_profile, N2_min)\n\n        # Step 4: Construct a smooth, shape-preserving interpolant (PCHIP).\n        pchip_N2 = PchipInterpolator(d_grid, N2_clipped)\n        \n        # Evaluate the prepared function at the specified query depths.\n        query_depths = np.array(case[\"query_depths\"])\n        N2_interpolated = pchip_N2(query_depths)\n        \n        # Format results for the current case into a string list.\n        # The format must use scientific notation with at least 6 decimal digits.\n        case_results_str = [f\"{val:.7e}\" for val in N2_interpolated]\n        all_results.append(f\"[{','.join(case_results_str)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在分别处理了快（正压）和慢（斜压）模态之后，模式分裂的核心挑战在于如何精确地耦合它们。简单的耦合方法可能会引入数值误差，从而破坏解的整体精度。本练习将带您深入探讨一种高级的时间积分方案，通过实现一个双向预测-校正耦合算法，您将学习如何确保在两个模态之间传递信息时维持二阶时间精度。",
            "id": "3799124",
            "problem": "您的任务是为一个在一维周期性域上的简化、无量纲、双层浅水系统，实现用于正压和斜压运动之间模态分裂的双向预报-校正耦合。目标是通过使用中间步长的场来耦合正压和斜压趋势项，从而展示时间上的二阶精度。您的实现必须是一个完整的、可运行的程序，能够为给定的测试组生成指定的输出。\n\n从以下基本原理出发：\n- 在静水近似和 Boussinesq 近似下，分层流体的质量和动量守恒，该系统在静止状态附近进行了线性化，并以一维空间和周期性边界条件表示。\n- 外部（正压）和内部（斜压）模态的浅水形式，其中正压场反映深度平均的自由表面动力学，斜压场反映内部界面位移和切变运动。\n\n在无量纲形式下，考虑关于正压表面高程 $\\,\\eta(x,t)\\,$、正压速度 $\\,u_b(x,t)\\,$、斜压界面位移 $\\,\\zeta(x,t)\\,$ 和斜压速度 $\\,u_i(x,t)\\,$ 的耦合线性系统：\n$$\n\\partial_t \\eta = -\\partial_x u_b,\n$$\n$$\n\\partial_t u_b = -c_e^2 \\,\\partial_x \\eta \\;-\\; \\gamma\\,\\partial_x \\zeta,\n$$\n$$\n\\partial_t \\zeta = -\\partial_x u_i,\n$$\n$$\n\\partial_t u_i = -c_i^2 \\,\\partial_x \\zeta \\;-\\; \\delta\\,\\partial_x \\eta,\n$$\n其中 $\\,c_e\\,$ 是无量纲外部重力波速，$\\,c_i\\,$ 是无量纲内部重力波速，$\\,\\gamma\\,$ 和 $\\,\\delta\\,$ 是代表模态间静水压力耦合的无量纲耦合系数。\n\n使用线方法，空间上采用二阶中心有限差分，时间上采用通过中间步长耦合实现二阶精度的两阶段预报-校正方案。在一个均匀网格上，对于具有周期性边界条件的区间 $\\,x\\in[0,L]\\,$ 上的 $\\,N\\,$ 个点，将时间 $\\,t^n\\,$ 和网格索引 $\\,i\\,$ 处的离散场表示为 $\\,\\eta^n_i\\,$, $\\,u^n_{b,i}\\,$, $\\,\\zeta^n_i\\,$ 和 $\\,u^n_{i,i}\\,$。空间导数 $\\,\\partial_x\\,$ 应通过以下方式近似：\n$$\n\\left(\\partial_x q\\right)_i \\approx \\frac{q_{i+1}-q_{i-1}}{2\\,\\Delta x},\n$$\n采用周期性索引。对于从 $\\,t^n\\,$ 到 $\\,t^{n+1}\\,$ 的每个时间步长 $\\,\\Delta t\\,$，实施以下耦合的预报-校正过程：\n\n带中间步长耦合的预报阶段：\n1. 计算 $\\,t^n\\,$ 时刻的正压趋势项：\n$$\n\\mathcal{T}_{\\eta}^{n} = -\\partial_x u_b^n, \\qquad\n\\mathcal{T}_{u_b}^{n} = -c_e^2\\,\\partial_x \\eta^n \\;-\\; \\gamma\\,\\partial_x \\zeta^n.\n$$\n2. 将正压场推进到中间步长：\n$$\n\\eta^{n+\\frac{1}{2}} = \\eta^n + \\frac{\\Delta t}{2}\\,\\mathcal{T}_{\\eta}^{n}, \\qquad\nu_b^{n+\\frac{1}{2}} = u_b^n + \\frac{\\Delta t}{2}\\,\\mathcal{T}_{u_b}^{n}.\n$$\n3. 使用 $\\,\\eta^{n+\\frac{1}{2}}\\,$ 进行耦合，计算 $\\,t^n\\,$ 时刻的斜压趋势项：\n$$\n\\mathcal{T}_{\\zeta}^{n} = -\\partial_x u_i^n, \\qquad\n\\mathcal{T}_{u_i}^{n} = -c_i^2\\,\\partial_x \\zeta^n \\;-\\; \\delta\\,\\partial_x \\eta^{n+\\frac{1}{2}}.\n$$\n将斜压场推进到中间步长：\n$$\n\\zeta^{n+\\frac{1}{2}} = \\zeta^n + \\frac{\\Delta t}{2}\\,\\mathcal{T}_{\\zeta}^{n}, \\qquad\nu_i^{n+\\frac{1}{2}} = u_i^n + \\frac{\\Delta t}{2}\\,\\mathcal{T}_{u_i}^{n}.\n$$\n4. 使用 $\\,\\zeta^{n+\\frac{1}{2}}\\,$ 更新正压趋势项并构建预报值：\n$$\n\\tilde{\\mathcal{T}}_{u_b}^{n} = -c_e^2\\,\\partial_x \\eta^n \\;-\\; \\gamma\\,\\partial_x \\zeta^{n+\\frac{1}{2}},\n$$\n$$\n\\eta^{*} = \\eta^n + \\Delta t\\,\\mathcal{T}_{\\eta}^{n}, \\quad\nu_b^{*} = u_b^n + \\Delta t\\,\\tilde{\\mathcal{T}}_{u_b}^{n}, \\quad\n\\zeta^{*} = \\zeta^n + \\Delta t\\,\\mathcal{T}_{\\zeta}^{n}, \\quad\nu_i^{*} = u_i^n + \\Delta t\\,\\mathcal{T}_{u_i}^{n}.\n$$\n\n带完全耦合中点评估的校正阶段：\n5. 构建中点场：\n$$\n\\eta^{\\mathrm{mid}} = \\frac{\\eta^n + \\eta^{*}}{2}, \\quad\nu_b^{\\mathrm{mid}} = \\frac{u_b^n + u_b^{*}}{2}, \\quad\n\\zeta^{\\mathrm{mid}} = \\frac{\\zeta^n + \\zeta^{*}}{2}, \\quad\nu_i^{\\mathrm{mid}} = \\frac{u_i^n + u_i^{*}}{2}.\n$$\n6. 在中点评估完全耦合的趋势项：\n$$\n\\mathcal{T}_{\\eta}^{\\mathrm{mid}} = -\\partial_x u_b^{\\mathrm{mid}}, \\quad\n\\mathcal{T}_{u_b}^{\\mathrm{mid}} = -c_e^2\\,\\partial_x \\eta^{\\mathrm{mid}} \\;-\\; \\gamma\\,\\partial_x \\zeta^{\\mathrm{mid}},\n$$\n$$\n\\mathcal{T}_{\\zeta}^{\\mathrm{mid}} = -\\partial_x u_i^{\\mathrm{mid}}, \\quad\n\\mathcal{T}_{u_i}^{\\mathrm{mid}} = -c_i^2\\,\\partial_x \\zeta^{\\mathrm{mid}} \\;-\\; \\delta\\,\\partial_x \\eta^{\\mathrm{mid}}.\n$$\n7. 校正场：\n$$\n\\eta^{n+1} = \\eta^n + \\Delta t\\,\\mathcal{T}_{\\eta}^{\\mathrm{mid}}, \\quad\nu_b^{n+1} = u_b^n + \\Delta t\\,\\mathcal{T}_{u_b}^{\\mathrm{mid}}, \\quad\n\\zeta^{n+1} = \\zeta^n + \\Delta t\\,\\mathcal{T}_{\\zeta}^{\\mathrm{mid}}, \\quad\nu_i^{n+1} = u_i^n + \\Delta t\\,\\mathcal{T}_{u_i}^{\\mathrm{mid}}.\n$$\n\n使用以下配置，均为无量纲：\n- 域长度 $\\,L=1\\,$，网格点数 $\\,N=256\\,$，网格间距 $\\,\\Delta x = L/N\\,$，周期性边界。\n- 波速 $\\,c_e=1.0\\,$ 和 $\\,c_i=0.3\\,$，耦合系数 $\\,\\gamma=0.2\\,$ 和 $\\,\\delta=0.1\\,$。\n- 初始条件：\n$$\n\\eta(x,0) = A \\sin(2\\pi x), \\quad u_b(x,0)=0, \\quad \\zeta(x,0)=B \\cos(2\\pi x), \\quad u_i(x,0)=0,\n$$\n振幅为 $\\,A=0.01\\,$ 和 $\\,B=0.01\\,$。\n-  final time $\\,T=0.05\\,$.\n\n空间导数必须通过具有周期性索引的二阶中心差分来计算。所有量都是无量綱的，因此不需要物理单位。\n\n将给定时间步长 $\\,\\Delta t\\,$ 在最终时间 $\\,T\\,$ 的相对误差定义为数值解与高精度参考解之差的均方根范数，并由参考解的范数进行归一化：\n$$\nE(\\Delta t) \\;=\\; \\frac{\\left\\| \\mathbf{q}(T;\\Delta t) - \\mathbf{q}_{\\mathrm{ref}}(T;\\Delta t_{\\mathrm{ref}}) \\right\\|_{2,\\mathrm{mean}}}{\\left\\| \\mathbf{q}_{\\mathrm{ref}}(T;\\Delta t_{\\mathrm{ref}}) \\right\\|_{2,\\mathrm{mean}}},\n$$\n其中 $\\,\\mathbf{q}=[\\eta, u_b, \\zeta, u_i]\\,$ 是在网格上拼接而成的向量，$\\,\\|\\cdot\\|_{2,\\mathrm{mean}}\\,$ 表示对各分量平方后求平均再开方，而 $\\,\\Delta t_{\\mathrm{ref}}\\,$ 是一个足够小的时间步长，用于定义参考解。\n\n实施上述方案并为以下时间步长测试组计算 $\\,E(\\Delta t)\\,$，每个测试组的最终时间 $\\,T\\,$ 相同：\n- 测试 $\\,1\\,$：$\\,\\Delta t = 0.002\\,$.\n- 测试 $\\,2\\,$：$\\,\\Delta t = 0.001\\,$.\n- 测试 $\\,3\\,$：$\\,\\Delta t = 0.0005\\,$.\n- 测试 $\\,4\\,$：$\\,\\Delta t = 0.00025\\,$.\n\n使用一个公共参考时间步长 $\\,\\Delta t_{\\mathrm{ref}} = 0.0000625\\,$。为精确达到最终时间 $\\,T\\,$，对每种情况使用整数步数 $\\,n = \\mathrm{round}\\!\\left(T/\\Delta t\\right)\\,$，并设置有效时间步长为 $\\,\\Delta t_{\\mathrm{eff}} = T/n\\,$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试用例 $\\,1\\,$ 到 $\\,4\\,$ 的顺序排列结果，例如 $[\\text{result1},\\text{result2},\\text{result3},\\text{result4}]$。每个结果必须是代表相应测试用例的 $\\,E(\\Delta t)\\,$ 的浮点数。",
            "solution": "用户提供的问题是有效的。它在科学上基于地球物理流体动力学的原理，特别是双层浅水系统，这是研究正压和斜压运动的标准模型。该问题是适定的，具有一套完整的线性偏微分方程、明確定義的初始和邊界條件以及所有必要的無量綱參數。数值方法，一个定制的双向预报-校正方案，与空间离散化和误差度量一起被明確無歧義地定义。该任务是客观且可形式化的，要求实现特定算法并计算定量结果。\n\n### 1. 基础科学原理\n\n该问题根植于分层流体的动力学，这在海洋和大气中很常见。控制方程代表了一个简化的、一维的、在静止状态附近线性化的双层浅水系统。该系统捕捉了两种不同类型的波动的基本动力学：\n\n- **正压（外部）模态**：此模态代表深度平均的运动，并与快速移动的表面重力波相关。在所提供的系统中，变量 $\\eta(x,t)$（自由表面高程）和 $u_b(x,t)$（正压或深度平均速度）描述了此模态。其动力学由外部波速 $c_e$ 驱动。\n\n- **斜压（内部）模态**：此模态描述与密度分层相关的运动，例如流体层之间界面的位移以及相关的速度切变。变量 $\\zeta(x,t)$（内部界面位移）和 $u_i(x,t)$（斜压速度分量）描述了此模態。其动力学由慢得多的内部波速 $c_i$ 控制。\n\n给出的方程是：\n$$\n\\begin{align*}\n\\partial_t \\eta = -\\partial_x u_b \\\\\n\\partial_t u_b = -c_e^2 \\,\\partial_x \\eta - \\gamma\\,\\partial_x \\zeta \\\\\n\\partial_t \\zeta = -\\partial_x u_i \\\\\n\\partial_t u_i = -c_i^2 \\,\\partial_x \\zeta - \\delta\\,\\partial_x \\eta\n\\end{align*}\n$$\n带有耦合系数 $\\gamma$ 和 $\\delta$ 的项代表了两层之间的静水压力相互作用，将正压和斜压系统联系起来。数值求解此类系统的一个关键挑战是由波速差异（$c_e \\gg c_i$）引起的刚性问题。“模态分裂”指的是为快慢模态使用不同时间步长策略以提高计算效率的技术。本问题实现了一种特定类型的耦合时间步进方案以保持精度。\n\n### 2. 数值离散化与算法设计\n\n该解法采用了**线方法**，即首先对空间维度进行离散化，将偏微分方程组（PDEs）转化为一个大型的关于时间的耦合常微分方程组（ODEs）。\n\n#### 2.1. 空间离散化\n\n一维域 $x \\in [0, L]$ 被离散化为 $N$ 个网格点，间距为 $\\Delta x = L/N$。空间导数算子 $\\partial_x$ 使用二阶中心有限差分格式近似，同时遵守周期性边界条件。对于网格点 $i$ 处的离散函数 $q_i$，其导数为：\n$$\n(\\partial_x q)_i \\approx \\frac{q_{i+1} - q_{i-1}}{2\\,\\Delta x}\n$$\n周期性索引通过模运算处理，或者在 `numpy` 中更方便地使用 `np.roll` 函数来处理。\n\n#### 2.2. 时间离散化：双向预报-校正方案\n\n为了在时间上达到二阶精度，实现了一个专门的两阶段预报-校正方案。该方案通过使用中间步长的场估计来精确处理耦合项。将解从时间 $t^n$ 推进到 $t^{n+1} = t^n + \\Delta t$ 的过程如下：\n\n**预报阶段：** 此阶段生成解在 $t^{n+1}$ 时刻的一阶估计，用上标 $*$ 表示。其关键特征是在一个假设的中间步长 $t^{n+1/2}$ 进行双向信息交换。\n\n1. **$t^n$ 时刻的正压趋势项**：使用 $t^n$ 时刻的状态计算 $\\eta$ 和 $u_b$ 的初始变化率。\n2. **正压场中间步长推进**：使用第1步的趋势项将 $\\eta$ 推进到 $t^{n+1/2}$。这提供了一个更新的自由表面场 $\\eta^{n+1/2}$。\n3. **$t^n$ 时刻的斜压趋势项**：计算 $\\zeta$ 和 $u_i$ 的变化率。关键是，$u_i$ 的趋势项使用中间步长的正压场 $\\eta^{n+1/2}$ 作为耦合项。这是双向耦合的第一部分。然后将斜压场推进到 $t^{n+1/2}$。\n4. **更新的预报趋势项**：现在重新评估用于全步长预报的正压速度趋势项 $\\tilde{\\mathcal{T}}_{u_b}^{n}$。它使用中间步长的斜压场 $\\zeta^{n+1/2}$ 作为其耦合项。这是双向耦合的第二部分。最后，对所有四个场进行全步长欧拉预报，以获得 $(\\eta^*, u_b^*, \\zeta^*, u_i^*)$。\n\n**校正阶段：** 此阶段将解 refining 到二阶精度。它遵循标准的二阶龙格-库塔（中点）方法的逻辑。\n\n5. **中点场评估**：通过平均初始状态 $(q^n)$ 和预报状态 $(q^*)$ 来近似时间步中点的状态：$q^{\\mathrm{mid}} = (\\eta^n + \\eta^*)/2$，对所有场依此类推。\n6. **中点趋势项评估**：使用这些平均的中点场重新计算所有四个变量的趋势项。这为区间 $[t^n, t^{n+1}]$ 上的平均变化率提供了一个二阶精确的估计。\n7. **最终校正**：使用上一步计算的中点趋势项，以完整时间步长 $\\Delta t$ 推进 $t^n$ 时刻的状态，从而计算出 $t^{n+1}$ 时刻的最终解。\n\n### 3. 实现与验证\n\n该算法在一个Python函数中实现，该函数模拟系统运行至最终时间 $T$，给定时间步长为 $\\Delta t$。为确保精确达到最终时间，步数计算为 $n = \\mathrm{round}(T/\\Delta t)$，并在积分循环中使用有效时间步长 $\\Delta t_{\\mathrm{eff}} = T/n$。\n\n为验证实现的二阶精度，进行了一次收敛性测试。首先通过使用一个非常小的时间步长 $\\Delta t_{\\mathrm{ref}}$ 运行模拟，生成一个高精度的**参考解**。然后，对于一系列更大的时间步长（$\\Delta t = 0.002, 0.001, 0.0005, 0.00025$），再次运行模拟。将每次运行的最终状态 $\\mathbf{q}(T; \\Delta t)$ 与参考解 $\\mathbf{q}_{\\mathrm{ref}}(T; \\Delta t_{\\mathrm{ref}})$进行比较。\n\n误差 $E(\\Delta t)$ 使用指定的范数计算：数值解与参考解之差的平方的均值的平方根，并由参考解的相应范数归一化。\n$$\nE(\\Delta t) \\;=\\; \\frac{\\left\\| \\mathbf{q}(T;\\Delta t) - \\mathbf{q}_{\\mathrm{ref}}(T;\\Delta t_{\\mathrm{ref}}) \\right\\|_{2,\\mathrm{mean}}}{\\left\\| \\mathbf{q}_{\\mathrm{ref}}(T;\\Delta t_{\\mathrm{ref}}) \\right\\|_{2,\\mathrm{mean}}}\n$$\n其中 $\\mathbf{q}$ 是在空间网格上拼接的所有场变量的向量。如果该方案确实是二阶精度的，那么将时间步长 $\\Delta t$ 减半应使误差 $E(\\Delta t)$ 减少约四倍。程序为指定的测试组计算并输出这些误差值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and tests a two-way predictor-corrector coupling scheme for a \n    simplified two-layer shallow-water system.\n    \"\"\"\n    \n    # --- Problem Configuration ---\n    # Domain and Grid\n    L = 1.0\n    N = 256\n    \n    # Physical Parameters (nondimensional)\n    c_e = 1.0\n    c_i = 0.3\n    gamma = 0.2\n    delta = 0.1\n    \n    # Initial Conditions Amplitudes\n    A = 0.01\n    B = 0.01\n\n    # Simulation Time\n    T = 0.05\n    \n    # Test Suite\n    test_dts = [0.002, 0.001, 0.0005, 0.00025]\n    dt_ref = 0.0000625\n\n    # --- Spatial Discretization ---\n    dx = L / N\n    x = np.linspace(0, L, N, endpoint=False)\n\n    def centered_diff(field, dx_val):\n        \"\"\"\n        Computes the second-order centered finite difference on a periodic grid.\n        \"\"\"\n        return (np.roll(field, -1) - np.roll(field, 1)) / (2.0 * dx_val)\n\n    def run_simulation(dt_in):\n        \"\"\"\n        Runs the simulation for a given time step dt_in until final time T.\n        \"\"\"\n        # --- Time-stepping setup ---\n        n_steps = int(round(T / dt_in))\n        dt = T / n_steps\n        \n        # --- Initialize fields ---\n        eta = A * np.sin(2.0 * np.pi * x)\n        u_b = np.zeros(N)\n        zeta = B * np.cos(2.0 * np.pi * x)\n        u_i = np.zeros(N)\n        \n        # --- Main time-stepping loop ---\n        for n in range(n_steps):\n            eta_n, u_b_n, zeta_n, u_i_n = eta, u_b, zeta, u_i\n\n            # --- PREDICTOR STAGE ---\n            \n            # Step 1: Compute barotropic tendencies at t^n\n            T_eta_n = -centered_diff(u_b_n, dx)\n            T_u_b_n = -c_e**2 * centered_diff(eta_n, dx) - gamma * centered_diff(zeta_n, dx)\n\n            # Step 2: Advance barotropic fields to mid-step\n            eta_n_half = eta_n + 0.5 * dt * T_eta_n\n            # u_b_n_half is computed but not used in subsequent steps per the problem statement\n            # u_b_n_half = u_b_n + 0.5 * dt * T_u_b_n\n            \n            # Step 3: Compute baroclinic tendencies at t^n using eta_n_half and advance\n            T_zeta_n = -centered_diff(u_i_n, dx)\n            T_u_i_n = -c_i**2 * centered_diff(zeta_n, dx) - delta * centered_diff(eta_n_half, dx)\n            \n            zeta_n_half = zeta_n + 0.5 * dt * T_zeta_n\n            # u_i_n_half is computed but not used in subsequent steps per the problem statement\n            # u_i_n_half = u_i_n + 0.5 * dt * T_u_i_n\n\n            # Step 4: Update barotropic tendency using zeta_n_half and form the predictor state\n            T_u_b_n_tilde = -c_e**2 * centered_diff(eta_n, dx) - gamma * centered_diff(zeta_n_half, dx)\n            \n            eta_star = eta_n + dt * T_eta_n\n            u_b_star = u_b_n + dt * T_u_b_n_tilde\n            zeta_star = zeta_n + dt * T_zeta_n\n            u_i_star = u_i_n + dt * T_u_i_n\n            \n            # --- CORRECTOR STAGE ---\n\n            # Step 5: Form mid-point fields\n            eta_mid = 0.5 * (eta_n + eta_star)\n            u_b_mid = 0.5 * (u_b_n + u_b_star)\n            zeta_mid = 0.5 * (zeta_n + zeta_star)\n            u_i_mid = 0.5 * (u_i_n + u_i_star)\n\n            # Step 6: Evaluate fully coupled tendencies at the mid-point\n            T_eta_mid = -centered_diff(u_b_mid, dx)\n            T_u_b_mid = -c_e**2 * centered_diff(eta_mid, dx) - gamma * centered_diff(zeta_mid, dx)\n            T_zeta_mid = -centered_diff(u_i_mid, dx)\n            T_u_i_mid = -c_i**2 * centered_diff(zeta_mid, dx) - delta * centered_diff(eta_mid, dx)\n\n            # Step 7: Correct the fields to get the state at t^(n+1)\n            eta = eta_n + dt * T_eta_mid\n            u_b = u_b_n + dt * T_u_b_mid\n            zeta = zeta_n + dt * T_zeta_mid\n            u_i = u_i_n + dt * T_u_i_mid\n\n        return eta, u_b, zeta, u_i\n\n    # --- Error Calculation ---\n    \n    # 1. Generate the high-accuracy reference solution\n    eta_ref, u_b_ref, zeta_ref, u_i_ref = run_simulation(dt_ref)\n    q_ref_vec = np.concatenate((eta_ref, u_b_ref, zeta_ref, u_i_ref))\n\n    # 2. Calculate the norm of the reference solution\n    norm_ref = np.sqrt(np.mean(q_ref_vec**2))\n    \n    if norm_ref == 0:\n        # This case is unlikely but would mean all solutions are zero.\n        # Errors would be 0 if the numerical solutions are also zero, otherwise undefined.\n        # We assume a non-trivial solution based on the initial conditions.\n        results = [0.0] * len(test_dts)\n    else:\n        results = []\n        for dt_val in test_dts:\n            # 3. Generate numerical solution for the current test case\n            eta_num, u_b_num, zeta_num, u_i_num = run_simulation(dt_val)\n            q_num_vec = np.concatenate((eta_num, u_b_num, zeta_num, u_i_num))\n            \n            # 4. Calculate the relative error\n            diff_vec = q_num_vec - q_ref_vec\n            norm_diff = np.sqrt(np.mean(diff_vec**2))\n            error = norm_diff / norm_ref\n            results.append(error)\n\n    # --- Final Output ---\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n\n```"
        }
    ]
}