{
    "hands_on_practices": [
        {
            "introduction": "Before a numerical model can be trusted for scientific discovery, it must be verified. This practice introduces the Method of Manufactured Solutions (MMS), a rigorous technique for code verification. By designing a problem with a known analytical solution, you will implement a finite-difference solver and quantify its error, confirming that your code achieves its expected theoretical accuracy .",
            "id": "3804158",
            "problem": "Consider the pressure Poisson equation that arises in incompressible ocean modeling, posed as the scalar Partial Differential Equation (PDE) $\\nabla^2 u = f$ on the unit square domain $\\Omega = (0,1)\\times(0,1)$ with Dirichlet boundary condition $u|_{\\partial\\Omega} = g$. To verify a numerical solver using the Method of Manufactured Solutions (MMS), assume a smooth manufactured solution $u^\\star(x,y)$ and define the forcing $f$ by the exact Laplacian of $u^\\star$, while prescribing the boundary data $g$ as the restriction of $u^\\star$ to $\\partial\\Omega$. All quantities are dimensionless.\n\nLet the manufactured solution be\n$$\nu^\\star(x,y) = \\sin(3\\pi x)\\cos(2\\pi y) + x^3 y - e^{x+y}.\n$$\nDefine $f(x,y)$ by $f(x,y) = \\nabla^2 u^\\star(x,y)$, and define $g$ by $g(x,y) = u^\\star(x,y)$ for $(x,y)\\in \\partial\\Omega$. The goal is to numerically solve $\\nabla^2 u = f$ with $u=g$ on $\\partial\\Omega$ using a second-order centered finite-difference discretization on a rectangular grid and to quantify the discretization error and the observed order of accuracy under mesh refinement.\n\nStarting only from the following fundamental base:\n- Conservation of mass for incompressible flow implies a pressure Poisson equation in projection-type solvers, which reduces mathematically to solving $\\nabla^2 u = f$ on a domain with appropriate boundary conditions.\n- The centered second-order finite-difference approximation of second derivatives follows from Taylor expansion about a grid point and yields a discrete Laplacian assembled from directional second differences on a uniform grid.\n\nTasks to implement in a program:\n1. Discretize $\\nabla^2 u = f$ on $\\Omega$ using a uniform rectangular grid with $N_x$ points in the $x$-direction and $N_y$ points in the $y$-direction, spacings $h_x = 1/(N_x-1)$ and $h_y = 1/(N_y-1)$, and a five-point stencil that is second order in space. Enforce the Dirichlet boundary condition strongly by inserting the boundary values from $u^\\star$ and shifting the corresponding contributions into the right-hand side for the linear system at interior nodes.\n2. Solve the resulting linear system for interior grid values and reconstruct the grid function $u_h$ on all nodes by inserting boundary values from $u^\\star$.\n3. Compute the discrete interior error $e_h = u_h - u^\\star$ on the set of interior nodes only. From $e_h$, compute two norms:\n   - The discrete $L^2$-norm defined by $\\|e_h\\|_{L^2(\\Omega)} \\approx \\left(\\sum_{i=1}^{N_x-2}\\sum_{j=1}^{N_y-2} |e_{i,j}|^2 h_x h_y\\right)^{1/2}$.\n   - The discrete $L^\\infty$-norm defined by $\\|e_h\\|_{L^\\infty(\\Omega)} = \\max_{1\\le i\\le N_x-2,\\,1\\le j\\le N_y-2} |e_{i,j}|$.\n4. For a mesh refinement by a factor of $2$ in each direction, estimate the observed order of accuracy $p$ by the standard formula $p = \\log(e_{h}/e_{h/2})/\\log(2)$, where $e_h$ denotes the error norm at resolution characterized by $(h_x,h_y)$ and $e_{h/2}$ denotes the error norm at the refined resolution characterized by $(h_x/2,h_y/2)$. In the anisotropic case where $h_x\\neq h_y$ but both are refined by a factor of $2$, use the same formula with the understanding that the refinement factor is $2$ for both directions and that the error norm $e_h$ is computed on the interior nodes of the corresponding grid.\n5. Compute the relative $\\ell^2$-norm of the discrete linear system residual $\\|r\\|_2/\\|b\\|_2$ on the finest isotropic grid, where $r = A u - b$ is the interior-node residual of the assembled linear system with $A$ the discrete Laplacian and $b$ the adjusted right-hand side. This quantity is dimensionless.\n\nTest suite specification:\n- Isotropic refinement sequence: $(N_x,N_y)\\in\\{(17,17),(33,33),(65,65)\\}$. Compute the observed orders using the last two levels only, i.e., use the errors from $(33,33)$ and $(65,65)$ to produce $p_{L^2}^{\\mathrm{iso}}$ and $p_{L^\\infty}^{\\mathrm{iso}}$.\n- Anisotropic refinement pair: coarse $(N_x,N_y)=(33,49)$ and fine $(N_x,N_y)=(65,97)$. Compute $p_{L^2}^{\\mathrm{aniso}}$ and $p_{L^\\infty}^{\\mathrm{aniso}}$ between these two levels.\n- Residual on the finest isotropic grid: compute the relative residual $\\|r\\|_2/\\|b\\|_2$ at $(N_x,N_y)=(65,65)$.\n\nAll computations are dimensionless; no physical units are involved.\n\nFinal output specification:\nYour program must produce a single line containing a Python-style list with five floating-point numbers in the following order:\n`[p_{L^2}^{\\mathrm{iso}}, p_{L^\\infty}^{\\mathrm{iso}}, p_{L^2}^{\\mathrm{aniso}}, p_{L^\\infty}^{\\mathrm{aniso}}, \\|r\\|_2/\\|b\\|_2]`.\nEach value must be rounded to exactly six digits after the decimal point. The line must contain no other text.\n\nYour implementation must be entirely self-contained and runnable. No user input is permitted. All angles and quantities are dimensionless; no units are required or accepted. The correctness criteria are the numerical values of the five outputs for the specified test suite. The expected answers are real numbers and should reflect second-order convergence in both norms for this smooth manufactured solution. The final output must aggregate the results of all provided test cases into a single line as specified.",
            "solution": "The problem presented is a standard verification exercise for a numerical solver of the two-dimensional Poisson equation, $\\nabla^2 u = f$, on a unit square domain $\\Omega = (0,1)\\times(0,1)$ with specified Dirichlet boundary conditions $u|_{\\partial\\Omega} = g$. The Method of Manufactured Solutions (MMS) is employed, which is a rigorous technique for verifying the correctness and accuracy of numerical code. The problem is scientifically sound, self-contained, and well-posed. We proceed with a complete solution.\n\n### 1. Analytical Formulation\n\nThe core of the MMS is to assume an analytical form for the solution, referred to as the manufactured solution $u^\\star(x,y)$, and then derive the corresponding problem data (forcing term $f$ and boundary conditions $g$).\n\nThe given manufactured solution is:\n$$\nu^\\star(x,y) = \\sin(3\\pi x)\\cos(2\\pi y) + x^3 y - e^{x+y}\n$$\nThe forcing term $f(x,y)$ is defined as the Laplacian of $u^\\star(x,y)$:\n$$\nf(x,y) = \\nabla^2 u^\\star(x,y) = \\frac{\\partial^2 u^\\star}{\\partial x^2} + \\frac{\\partial^2 u^\\star}{\\partial y^2}\n$$\nWe compute the second partial derivatives of $u^\\star$:\nFirst, with respect to $x$:\n$$\n\\frac{\\partial u^\\star}{\\partial x} = 3\\pi \\cos(3\\pi x)\\cos(2\\pi y) + 3x^2 y - e^{x+y}\n$$\n$$\n\\frac{\\partial^2 u^\\star}{\\partial x^2} = -(3\\pi)^2 \\sin(3\\pi x)\\cos(2\\pi y) + 6xy - e^{x+y} = -9\\pi^2 \\sin(3\\pi x)\\cos(2\\pi y) + 6xy - e^{x+y}\n$$\nNext, with respect to $y$:\n$$\n\\frac{\\partial u^\\star}{\\partial y} = -2\\pi \\sin(3\\pi x)\\sin(2\\pi y) + x^3 - e^{x+y}\n$$\n$$\n\\frac{\\partial^2 u^\\star}{\\partial y^2} = -(2\\pi)^2 \\sin(3\\pi x)\\cos(2\\pi y) - e^{x+y} = -4\\pi^2 \\sin(3\\pi x)\\cos(2\\pi y) - e^{x+y}\n$$\nSumming these derivatives gives the forcing function $f(x,y)$:\n$$\nf(x,y) = (-9\\pi^2 - 4\\pi^2)\\sin(3\\pi x)\\cos(2\\pi y) + 6xy - 2e^{x+y}\n$$\n$$\nf(x,y) = -13\\pi^2\\sin(3\\pi x)\\cos(2\\pi y) + 6xy - 2e^{x+y}\n$$\nThe Dirichlet boundary data $g(x,y)$ is simply the value of $u^\\star(x,y)$ on the boundary $\\partial\\Omega$ of the unit square.\n\n### 2. Numerical Discretization\n\nThe domain $\\Omega = (0,1)\\times(0,1)$ is discretized using a uniform rectangular grid. The grid points are denoted by $(x_i, y_j)$, where $x_i = i h_x$ for $i \\in \\{0, 1, ..., N_x-1\\}$ and $y_j = j h_y$ for $j \\in \\{0, 1, ..., N_y-1\\}$. The grid spacings are $h_x = 1/(N_x-1)$ and $h_y = 1/(N_y-1)$.\n\nThe Laplacian operator $\\nabla^2 u$ at an interior grid point $(x_i, y_j)$ is approximated using a second-order centered finite-difference formula, which results in the well-known five-point stencil:\n$$\n\\nabla^2 u \\Big|_{(x_i, y_j)} \\approx \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2}\n$$\nwhere $u_{i,j}$ denotes the numerical approximation of $u(x_i, y_j)$. Equating this to the source term $f(x_i, y_j) = f_{i,j}$ gives the discrete equation at each interior node ($1 \\le i \\le N_x-2$, $1 \\le j \\le N_y-2$):\n$$\n\\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2} = f_{i,j}\n$$\n\n### 3. Linear System Formulation\n\nThe set of linear algebraic equations for all $(N_x-2) \\times (N_y-2)$ interior nodes forms a large linear system of the form $A\\mathbf{u}_{int} = \\mathbf{b}$.\n\n$\\mathbf{u}_{int}$ is a vector of the unknown values $u_{i,j}$ at the interior grid points, flattened into a one-dimensional array. Using a row-major ordering, the index $k$ for an interior point $(i,j)$ is $k = (i-1)(N_y-2) + (j-1)$.\n\nThe matrix $A$ is a sparse matrix representing the discrete Laplacian operator. It has a block-tridiagonal structure. A highly effective method for constructing $A$ is through the Kronecker sum of the one-dimensional second-derivative matrices. Let $D_{xx}$ be the $(N_x-2) \\times (N_x-2)$ matrix for the second derivative in $x$, and $D_{yy}$ be the $(N_y-2) \\times (N_y-2)$ matrix for the second derivative in $y$. Then, for row-major ordering of unknowns, $A$ is given by:\n$$\nA = D_{xx} \\otimes I_y + I_x \\otimes D_{yy}\n$$\nwhere $I_x$ and $I_y$ are identity matrices of size $(N_x-2)$ and $(N_y-2)$ respectively, and $\\otimes$ denotes the Kronecker product.\n\nThe right-hand-side vector $\\mathbf{b}$ is constructed from the values of the forcing function $f_{i,j}$ at the interior nodes. For nodes adjacent to the boundary, boundary condition values must be incorporated. The discrete equations are rearranged to move all known boundary value terms to the right-hand side. For an interior node $(i,j)$, the RHS element $b_{i,j}$ is initialized to $f_{i,j}$. Then, adjustments are made:\n-   If $i=1$, subtract $\\frac{g(x_0, y_j)}{h_x^2}$ from $b_{1,j}$.\n-   If $i=N_x-2$, subtract $\\frac{g(x_{N_x-1}, y_j)}{h_x^2}$ from $b_{N_x-2,j}$.\n-   If $j=1$, subtract $\\frac{g(x_i, y_0)}{h_y^2}$ from $b_{i,1}$.\n-   If $j=N_y-2$, subtract $\\frac{g(x_i, y_{N_y-1})}{h_y^2}$ from $b_{i,N_y-2}$.\n\nOnce $A$ and $\\mathbf{b}$ are assembled, the system is solved for $\\mathbf{u}_{int}$. The full numerical solution $u_h$ is then constructed by combining the computed interior values with the known boundary values from $u^\\star$.\n\n### 4. Error Analysis and Convergence\n\nThe numerical error is the difference between the numerical solution $u_h$ and the exact manufactured solution $u^\\star$ at the grid points, $e_{i,j} = u_{h,i,j} - u^\\star(x_i, y_j)$. We quantify this error over the interior nodes using two standard norms:\n\n-   The discrete $L^2$-norm: $\\|e_h\\|_{L^2} = \\left(\\sum_{i=1}^{N_x-2}\\sum_{j=1}^{N_y-2} |e_{i,j}|^2 h_x h_y\\right)^{1/2}$\n-   The discrete $L^\\infty$-norm (maximum norm): $\\|e_h\\|_{L^\\infty} = \\max_{1\\le i\\le N_x-2,\\,1\\le j\\le N_y-2} |e_{i,j}|$\n\nTo verify the order of accuracy of the method, we perform a mesh refinement study. If the error norm behaves as $\\|e_h\\| \\approx C h^p$, where $h$ is a characteristic mesh size and $p$ is the order of accuracy, then by solving on a coarse grid (size $h$) and a fine grid (size $h/2$), we can estimate $p$:\n$$\np = \\frac{\\log(\\|e_h\\| / \\|e_{h/2}\\|)}{\\log(2)}\n$$\nFor a second-order method, we expect $p \\approx 2$.\n\nFinally, the relative $\\ell^2$-norm of the linear system residual, $\\|r\\|_2 / \\|b\\|_2$ where $r = A\\mathbf{u}_{int} - \\mathbf{b}$, is computed. This value assesses how well the numerical linear algebra solver has solved the system $A\\mathbf{u}_{int} = \\mathbf{b}$ and should be close to machine precision.\n\nThese steps are implemented for the specified isotropic and anisotropic grid refinement sequences to produce the five required output values.",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import diags, identity, kron\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to perform the Method of Manufactured Solutions verification\n    for a 2D Poisson solver.\n    \"\"\"\n\n    def u_star(x, y):\n        \"\"\"The manufactured solution u*(x,y).\"\"\"\n        return np.sin(3 * np.pi * x) * np.cos(2 * np.pi * y) + x**3 * y - np.exp(x + y)\n\n    def f_source(x, y):\n        \"\"\"The forcing term f(x,y) = laplacian(u*(x,y)).\"\"\"\n        term1 = -13 * np.pi**2 * np.sin(3 * np.pi * x) * np.cos(2 * np.pi * y)\n        term2 = 6 * x * y\n        term3 = -2 * np.exp(x + y)\n        return term1 + term2 + term3\n\n    def solve_poisson(Nx, Ny):\n        \"\"\"\n        Solves the Poisson equation on a grid of size (Nx, Ny) and returns error norms.\n        \"\"\"\n        hx = 1.0 / (Nx - 1)\n        hy = 1.0 / (Ny - 1)\n\n        x = np.linspace(0, 1, Nx)\n        y = np.linspace(0, 1, Ny)\n        X, Y = np.meshgrid(x, y, indexing='ij')\n\n        u_exact_grid = u_star(X, Y)\n        f_grid = f_source(X, Y)\n\n        Nix = Nx - 2\n        Niy = Ny - 2\n        N_int = Nix * Niy\n\n        if N_int == 0:\n            return 0.0, 0.0, None, None, None\n\n        # Assemble the discrete Laplacian matrix A using Kronecker products\n        # This corresponds to row-major (C-style) flattening of the unknowns.\n        hx2_inv = 1.0 / hx**2\n        hy2_inv = 1.0 / hy**2\n        \n        diag_x = np.full(Nix, -2.0 * hx2_inv)\n        offdiag_x = np.full(Nix - 1, 1.0 * hx2_inv)\n        Dxx = diags([offdiag_x, diag_x, offdiag_x], [-1, 0, 1], format='csc')\n\n        diag_y = np.full(Niy, -2.0 * hy2_inv)\n        offdiag_y = np.full(Niy - 1, 1.0 * hy2_inv)\n        Dyy = diags([offdiag_y, diag_y, offdiag_y], [-1, 0, 1], format='csc')\n\n        Ix = identity(Nix, format='csc')\n        Iy = identity(Niy, format='csc')\n\n        # The order of kron matters and must match the flattening of the RHS vector\n        # This is for row-major flattening: Dxx kron I + I kron Dyy\n        A = kron(Dxx, Iy) + kron(Ix, Dyy)\n\n        # Assemble the right-hand side vector b\n        b_matrix = f_grid[1:-1, 1:-1].copy()\n\n        # Adjust RHS for boundary conditions\n        b_matrix[0, :] -= u_exact_grid[0, 1:-1] * hx2_inv  # Left boundary i=0\n        b_matrix[-1, :] -= u_exact_grid[-1, 1:-1] * hx2_inv # Right boundary i=Nx-1\n        b_matrix[:, 0] -= u_exact_grid[1:-1, 0] * hy2_inv   # Bottom boundary j=0\n        b_matrix[:, -1] -= u_exact_grid[1:-1, -1] * hy2_inv # Top boundary j=Ny-1\n        \n        b = b_matrix.flatten('C')\n\n        # Solve the linear system for interior nodes\n        u_int_flat = spsolve(A, b)\n\n        # Reconstruct the full numerical solution grid\n        u_h = u_exact_grid.copy()\n        u_h[1:-1, 1:-1] = u_int_flat.reshape((Nix, Niy), order='C')\n\n        # Compute error on interior nodes\n        error_grid = u_h[1:-1, 1:-1] - u_exact_grid[1:-1, 1:-1]\n\n        # Compute L2 and Linf norms of the error\n        l2_norm = np.sqrt(np.sum(error_grid**2 * hx * hy))\n        linf_norm = np.max(np.abs(error_grid))\n        \n        return l2_norm, linf_norm, A, u_int_flat, b\n\n    # Isotropic refinement\n    err_l2_33, err_linf_33, _, _, _ = solve_poisson(33, 33)\n    err_l2_65, err_linf_65, A_65, u_sol_65, b_65 = solve_poisson(65, 65)\n\n    p_l2_iso = np.log(err_l2_33 / err_l2_65) / np.log(2)\n    p_linf_iso = np.log(err_linf_33 / err_linf_65) / np.log(2)\n    \n    # Anisotropic refinement\n    err_l2_c, err_linf_c, _, _, _ = solve_poisson(33, 49)\n    err_l2_f, err_linf_f, _, _, _ = solve_poisson(65, 97)\n\n    p_l2_aniso = np.log(err_l2_c / err_l2_f) / np.log(2)\n    p_linf_aniso = np.log(err_linf_c / err_linf_f) / np.log(2)\n    \n    # Residual calculation for the finest isotropic grid\n    residual_vector = A_65.dot(u_sol_65) - b_65\n    rel_residual = np.linalg.norm(residual_vector) / np.linalg.norm(b_65)\n\n    results = [p_l2_iso, p_linf_iso, p_l2_aniso, p_linf_aniso, rel_residual]\n    \n    # Format output as specified\n    formatted_results = [f\"{val:.6f}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "In computational oceanography, efficiency is paramount, and exploiting the problem's structure is key. This exercise demonstrates the power of Fast Fourier Transform (FFT)-based direct solvers for domains with periodic boundary conditions, a common feature in idealized models of oceanic and atmospheric flows. You will see how transforming the problem into Fourier space can convert a complex system of partial differential equations into a simple set of algebraic equations, leading to an exact and highly efficient solution .",
            "id": "3804162",
            "problem": "Consider the numerical solution of the pressure Poisson equation arising in the projection method for incompressible ocean flows. Starting from the incompressibility constraint $\\nabla \\cdot \\boldsymbol{u} = 0$ and the momentum equation, one arrives at a Poisson equation for the pressure, $\\nabla^2 p = f$, where $p$ is the pressure and $f$ is a known right-hand side derived from intermediate velocity fields. In computational oceanography, it is common to impose periodic boundary conditions in directions tangential to large-scale coast-free flows and nonperiodic boundary conditions in the remaining directions. Your task is to implement Fast Fourier Transform (FFT)-based direct solvers in the periodic directions and second-order central finite differences in the nonperiodic directions to solve the pressure Poisson equation and quantify the numerical error against an exact solution.\n\nYou must write a complete program that constructs uniform grids over a rectangular domain, assembles the appropriate discrete operator, and solves the Poisson equation using:\n- FFT-based diagonalization in any periodic direction(s).\n- A tridiagonal direct solve in any nonperiodic direction using second-order centered finite differences and homogeneous Dirichlet boundary conditions.\n\nThe solver must handle two configurations:\n1. A mixed configuration with periodic boundary conditions in the $x$-direction and homogeneous Dirichlet boundary conditions in the $y$-direction.\n2. A fully periodic configuration with periodic boundary conditions in both $x$ and $y$.\n\nFor each configuration, the program must define an exact solution $p^{\\mathrm{true}}(x,y)$ and derive a consistent right-hand side $f(x,y)$ from the continuous Poisson equation $\\nabla^2 p^{\\mathrm{true}} = f$. The grids and test functions are chosen to be smooth and compatible with the specified boundary conditions. Use uniform grids with the following definitions:\n- In any periodic direction of length $L$, use $N$ points with coordinates $x_i = i L / N$ for $i = 0, 1, \\dots, N-1$.\n- In any homogeneous Dirichlet direction of length $L$, use $N^{\\mathrm{int}}$ interior points with spacing $h = L / (N^{\\mathrm{int}} + 1)$ and coordinates $y_j = j h$ for $j = 1, 2, \\dots, N^{\\mathrm{int}}$.\n\nImplement the following three test cases (this is the required test suite):\n\n- Test case $1$ (mixed: periodic in $x$, Dirichlet in $y$):\n  - Domain sizes: $L_x = 1$, $L_y = 1$.\n  - Grid sizes: $N_x = 64$ periodic points in $x$, $N_y^{\\mathrm{int}} = 64$ interior points in $y$.\n  - Exact solution: $p^{\\mathrm{true}}(x,y) = \\sin\\!\\left(2\\pi x / L_x\\right) \\sin\\!\\left(\\pi y / L_y\\right)$.\n  - Right-hand side: $f(x,y) = -\\left[\\left(2\\pi/L_x\\right)^2 + \\left(\\pi/L_y\\right)^2\\right] p^{\\mathrm{true}}(x,y)$.\n\n- Test case $2$ (fully periodic in $x$ and $y$):\n  - Domain sizes: $L_x = 1$, $L_y = 1$.\n  - Grid sizes: $N_x = 64$, $N_y = 64$ periodic points.\n  - Exact solution: $p^{\\mathrm{true}}(x,y) = \\sin\\!\\left(2\\pi x / L_x\\right) \\sin\\!\\left(2\\pi y / L_y\\right)$.\n  - Right-hand side: $f(x,y) = -\\left[\\left(2\\pi/L_x\\right)^2 + \\left(2\\pi/L_y\\right)^2\\right] p^{\\mathrm{true}}(x,y)$.\n  - Enforce that the zero Fourier mode of $p$ is set to $0$ to avoid the indeterminate mean-pressure mode; this is consistent because the specified $f$ has zero mean.\n\n- Test case $3$ (mixed: periodic in $x$, Dirichlet in $y$, edge case with zero wavenumber in $x$):\n  - Domain sizes: $L_x = 1$, $L_y = 1$.\n  - Grid sizes: $N_x = 32$ periodic points in $x$, $N_y^{\\mathrm{int}} = 50$ interior points in $y$.\n  - Exact solution: $p^{\\mathrm{true}}(x,y) = \\sin\\!\\left(\\pi y / L_y\\right)$ (independent of $x$).\n  - Right-hand side: $f(x,y) = -\\left(\\pi/L_y\\right)^2 \\sin\\!\\left(\\pi y / L_y\\right)$.\n\nAlgorithmic requirements:\n- In mixed configurations, apply the one-dimensional FFT in the periodic $x$-direction to diagonalize the discrete second derivative there, resulting in decoupled linear systems along $y$ for each Fourier mode. Solve each resulting tridiagonal system along $y$ exactly using a direct method, and reconstruct $p(x,y)$ via the inverse FFT.\n- In fully periodic configurations, apply a two-dimensional FFT to the right-hand side, perform a direct spectral inversion of the Laplacian in Fourier space for all nonzero wavenumber pairs, and set the zero wavenumber of the pressure to $0$ before transforming back.\n\nFor each test case, compute the maximum absolute error between the numerical solution and the exact solution on the grid, defined as $E_{\\infty} = \\max_{i,j} \\left| p_{ij} - p^{\\mathrm{true}}_{ij} \\right|$. There are no physical units in this problem; all quantities are dimensionless. The expected answers for the test cases are real-valued floats.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of test cases $1$, $2$, and $3$ (for example, `[r_1,r_2,r_3]`). The entries must be the computed values of $E_{\\infty}$ for each test case, in that order. No input should be read from the user, and no output other than the specified single line should be printed.",
            "solution": "The problem is validated as scientifically sound, well-posed, and complete. It presents a standard numerical task in computational physics: solving the two-dimensional Poisson equation, $\\nabla^2 p = f$, on a rectangular domain using a combination of spectral and finite difference methods, tailored to different boundary conditions.\n\nThe solution is approached by developing solvers for two distinct configurations as specified: one with mixed periodic and Dirichlet boundary conditions, and another with fully periodic boundary conditions.\n\n### Methodology for Mixed Boundary Conditions (Periodic-Dirichlet)\n\nThis configuration applies to test cases $1$ and $3$, where the domain is periodic in the $x$-direction and bounded by homogeneous Dirichlet conditions in the $y$-direction, i.e., $p(x, 0) = 0$ and $p(x, L_y) = 0$. The governing equation is\n$$\n\\frac{\\partial^2 p}{\\partial x^2} + \\frac{\\partial^2 p}{\\partial y^2} = f(x, y)\n$$\nThe problem is discretized on a grid with points $(x_i, y_j)$, where $x_i = i L_x / N_x$ for $i=0, \\dots, N_x-1$ and $y_j = j h_y$ for $j=1, \\dots, N_y^{\\mathrm{int}}$, with cell height $h_y = L_y / (N_y^{\\mathrm{int}} + 1)$.\n\nThe strategy leverages the periodicity in the $x$-direction. For any fixed vertical level $y_j$, the pressure $p(x, y_j)$ and the right-hand side $f(x, y_j)$ can be represented by a discrete Fourier series:\n$$\np(x_i, y_j) = \\sum_{m=0}^{N_x-1} \\hat{p}(k_m, y_j) e^{i k_m x_i}\n$$\n$$\nf(x_i, y_j) = \\sum_{m=0}^{N_x-1} \\hat{f}(k_m, y_j) e^{i k_m x_i}\n$$\nwhere $\\hat{p}$ and $\\hat{f}$ are the Fourier coefficients (computed via Fast Fourier Transform, FFT), and $k_m = 2\\pi m' / L_x$ are the discrete wavenumbers, with $m'$ being an integer index managed by the FFT algorithm (typically from $-N_x/2$ to $N_x/2 - 1$). The differentiation property of the Fourier transform states that the transform of $\\partial^2 p / \\partial x^2$ is $-k_m^2 \\hat{p}$.\n\nSubstituting these series into the PDE effectively transforms the equation into Fourier space with respect to $x$. This decouples the spatial dimensions, yielding a separate one-dimensional boundary value problem in $y$ for each Fourier mode $k_m$:\n$$\n-k_m^2 \\hat{p}(k_m, y) + \\frac{d^2 \\hat{p}(k_m, y)}{d y^2} = \\hat{f}(k_m, y)\n$$\nThis ordinary differential equation is now discretized in $y$ using a second-order central finite difference scheme for the second derivative:\n$$\n\\frac{d^2 \\hat{p}}{dy^2} \\bigg|_{y_j} \\approx \\frac{\\hat{p}(k_m, y_{j+1}) - 2\\hat{p}(k_m, y_j) + \\hat{p}(k_m, y_{j-1})}{h_y^2}\n$$\nThe homogeneous Dirichlet boundary conditions $p(x,0)=p(x,L_y)=0$ imply that their Fourier transforms are also zero, $\\hat{p}(k_m, 0) = 0$ and $\\hat{p}(k_m, L_y) = 0$. This provides the boundary conditions for the discrete system.\n\nFor each wavenumber $k_m$, we obtain a system of linear equations for the vector of Fourier coefficients $\\mathbf{\\hat{p}}_m = [\\hat{p}(k_m, y_1), \\dots, \\hat{p}(k_m, y_{N_y^{\\mathrm{int}}})]^T$:\n$$\n\\frac{1}{h_y^2} \\left( \\hat{p}_{m,j-1} - 2\\hat{p}_{m,j} + \\hat{p}_{m,j+1} \\right) - k_m^2 \\hat{p}_{m,j} = \\hat{f}_{m,j}\n$$\nwhere $\\hat{p}_{m,j} \\equiv \\hat{p}(k_m, y_j)$ and the boundary terms $\\hat{p}_{m,0}$ and $\\hat{p}_{m,N_y^{\\mathrm{int}}+1}$ are zero. This constitutes a symmetric tridiagonal system of size $N_y^{\\mathrm{int}} \\times N_y^{\\mathrm{int}}$ for each mode $m$, which can be solved efficiently using a direct tridiagonal solver.\n\nThe complete algorithm is:\n1.  Compute the 1D FFT of the source term $f(x_i, y_j)$ along the $x$-axis for each $j$ to obtain $\\hat{f}(k_m, y_j)$.\n2.  For each Fourier mode $k_m$:\n    a.  Construct the tridiagonal matrix representing the operator $(-k_m^2 + \\frac{d^2}{dy^2})$.\n    b.  Solve the tridiagonal system for $\\hat{p}(k_m, y_j)$.\n3.  Combine the solutions for all modes into a 2D array $\\hat{p}(k_m, y_j)$.\n4.  Compute the 1D inverse FFT of $\\hat{p}(k_m, y_j)$ along the $k_m$ axis for each $j$ to recover the pressure field $p(x_i, y_j)$.\n\n### Methodology for Fully Periodic Boundary Conditions\n\nThis configuration applies to test case $2$, where the boundary conditions are periodic in both $x$ and $y$. The discretization uses $N_x$ points in $x$ and $N_y$ points in $y$.\n\nGiven periodicity in both directions, a 2D FFT is the natural tool to diagonalize the Laplacian operator. The pressure and source terms are represented by 2D discrete Fourier series:\n$$\np(x_i, y_j) = \\sum_{m=0}^{N_x-1} \\sum_{l=0}^{N_y-1} \\hat{p}(k_m, k_l) e^{i k_m x_i} e^{i k_l y_j}\n$$\nApplying the 2D FFT to the Poisson equation $\\nabla^2 p = f$ transforms it into a simple algebraic equation in the spectral domain:\n$$\n(-k_m^2 - k_l^2) \\hat{p}(k_m, k_l) = \\hat{f}(k_m, k_l)\n$$\nwhere $k_m$ and $k_l$ are the wavenumbers in the $x$ and $y$ directions, respectively. The solution for the Fourier coefficients of the pressure is then obtained by direct division:\n$$\n\\hat{p}(k_m, k_l) = \\frac{\\hat{f}(k_m, k_l)}{-k_m^2 - k_l^2}\n$$\nA singularity arises for the zero-wavenumber mode $(k_m, k_l) = (0,0)$, where the denominator is zero. This corresponds to the mean value of the fields. For a solution to exist, the source term must have a zero mean, i.e., $\\int f \\,dA = 0$, which implies its zero-wavenumber Fourier coefficient $\\hat{f}(0,0)$ must be zero. The problem statement guarantees this condition for the chosen test case. The corresponding pressure mode $\\hat{p}(0,0)$, representing the mean pressure, is undetermined. As is customary, we resolve this ambiguity by setting the mean pressure to zero: $\\hat{p}(0,0) = 0$.\n\nThe complete algorithm is:\n1.  Compute the 2D FFT of the source term $f(x_i, y_j)$ to get $\\hat{f}(k_m, k_l)$.\n2.  For all non-zero wavenumber pairs $(k_m, k_l)$, compute $\\hat{p}(k_m, k_l)$ by dividing $\\hat{f}(k_m, k_l)$ by the spectral representation of the Laplacian, $-(k_m^2 + k_l^2)$.\n3.  Set the zero-wavenumber mode $\\hat{p}(0,0) = 0$.\n4.  Compute the 2D inverse FFT of $\\hat{p}(k_m, k_l)$ to recover the pressure field $p(x_i, y_j)$.\n\n### Error Quantification\n\nFor each test case, the problem provides an exact analytical solution $p^{\\mathrm{true}}(x,y)$ that is consistent with the boundary conditions and from which the source term $f(x,y)$ is derived. Crucially, the chosen sine functions are eigenfunctions of both the continuous Laplacian and the discrete operators (FFT-based second derivative and central finite difference second derivative). Consequently, the numerical method should solve the discrete system exactly, and the resulting numerical solution $p_{ij}$ should match the exact solution evaluated at the grid points, $p^{\\mathrm{true}}_{ij}$, to within machine floating-point precision. The maximum absolute error, $E_{\\infty} = \\max_{i,j} |p_{ij} - p^{\\mathrm{true}}_{ij}|$, is calculated to verify this expectation. Any significant deviation from zero would indicate an error in the implementation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve_mixed_bc(Lx, Ly, Nx, Ny_int, p_true_func, f_func):\n    \"\"\"\n    Solves the 2D Poisson equation with periodic BC in x and Dirichlet BC in y.\n    \n    Uses FFT in the x-direction and a tridiagonal solve in the y-direction.\n    \"\"\"\n    # 1. Create grids\n    hx = Lx / Nx\n    x = hx * np.arange(Nx)\n    hy = Ly / (Ny_int + 1)\n    y = hy * np.arange(1, Ny_int + 1)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # 2. Evaluate functions on the grid\n    f_grid = f_func(X, Y)\n    p_true_grid = p_true_func(X, Y)\n\n    # 3. FFT of the source term f along the periodic x-axis\n    f_hat = np.fft.fft(f_grid, axis=0)\n    \n    # 4. Get discrete wavenumbers in x\n    kx = 2 * np.pi * np.fft.fftfreq(Nx, d=hx)\n\n    # 5. Solve tridiagonal systems for each Fourier mode\n    p_hat = np.zeros_like(f_hat, dtype=np.complex128)\n    \n    # The tridiagonal matrix is constant except for the main diagonal.\n    # It has shape (Ny_int, Ny_int).\n    # A_m @ p_hat_col = f_hat_col\n    # The matrix has (1/hy^2) on the off-diagonals.\n    \n    # For scipy.linalg.solve_banded, we prepare the banded matrix `ab`\n    # ab has shape (3, Ny_int) for l=1, u=1.\n    # ab[0, :] = super-diagonal\n    # ab[1, :] = main-diagonal\n    # ab[2, :] = sub-diagonal\n    ab = np.zeros((3, Ny_int))\n    ab[0, 1:] = 1.0 / hy**2\n    ab[2, :-1] = 1.0 / hy**2\n\n    for m in range(Nx):\n        # Construct main diagonal for this wavenumber kx[m]\n        main_diag_val = -2.0 / hy**2 - kx[m]**2\n        ab[1, :] = main_diag_val\n        \n        # Right-hand side for this mode\n        b = f_hat[m, :]\n        \n        # Solve the tridiagonal system\n        p_hat[m, :] = solve_banded((1, 1), ab, b)\n        \n    # 6. Inverse FFT to get the numerical solution\n    p_numeric = np.fft.ifft(p_hat, axis=0)\n\n    # The solution should be real\n    p_numeric_real = np.real(p_numeric)\n    \n    # 7. Calculate max absolute error\n    error = np.max(np.abs(p_numeric_real - p_true_grid))\n    return error\n\ndef solve_periodic_bc(Lx, Ly, Nx, Ny, p_true_func, f_func):\n    \"\"\"\n    Solves the 2D Poisson equation with periodic BCs in x and y.\n    \n    Uses a 2D FFT-based spectral method.\n    \"\"\"\n    # 1. Create grids\n    hx = Lx / Nx\n    x = hx * np.arange(Nx)\n    hy = Ly / Ny\n    y = hy * np.arange(Ny)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # 2. Evaluate functions on grid\n    f_grid = f_func(X, Y)\n    p_true_grid = p_true_func(X, Y)\n\n    # 3. 2D FFT of the source term\n    f_hat = np.fft.fft2(f_grid)\n\n    # 4. Get discrete wavenumbers\n    kx_vec = 2 * np.pi * np.fft.fftfreq(Nx, d=hx)\n    ky_vec = 2 * np.pi * np.fft.fftfreq(Ny, d=hy)\n    Kx, Ky = np.meshgrid(kx_vec, ky_vec, indexing='ij')\n\n    # 5. Fourier representation of the Laplacian\n    lap_hat = -(Kx**2 + Ky**2)\n\n    # 6. Solve for p_hat in Fourier space\n    # Handle the (0,0) mode singularity by dividing only where lap_hat is non-zero.\n    p_hat = np.divide(f_hat, lap_hat, out=np.zeros_like(f_hat), where=(lap_hat != 0))\n    \n    # The problem specifies setting the zero mode of p to 0. This is implicitly\n    # handled by the `out=np.zeros_like(f_hat)` argument to np.divide, since\n    # lap_hat[0,0] is zero, so the result p_hat[0,0] remains 0.\n    # An explicit set for clarity:\n    p_hat[0, 0] = 0.0\n\n    # 7. Inverse 2D FFT to get the numerical solution\n    p_numeric = np.fft.ifft2(p_hat)\n    \n    # The solution should be real\n    p_numeric_real = np.real(p_numeric)\n\n    # 8. Calculate max absolute error\n    error = np.max(np.abs(p_numeric_real - p_true_grid))\n    return error\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    \n    results = []\n\n    # Test Case 1: Mixed BC (periodic-x, dirichlet-y)\n    Lx1, Ly1 = 1.0, 1.0\n    Nx1, Ny_int1 = 64, 64\n    k_x1 = 2 * np.pi / Lx1\n    k_y1 = np.pi / Ly1\n    p_true1 = lambda x, y: np.sin(k_x1 * x) * np.sin(k_y1 * y)\n    f1 = lambda x, y: -(k_x1**2 + k_y1**2) * p_true1(x, y)\n    error1 = solve_mixed_bc(Lx1, Ly1, Nx1, Ny_int1, p_true1, f1)\n    results.append(error1)\n\n    # Test Case 2: Fully Periodic BC\n    Lx2, Ly2 = 1.0, 1.0\n    Nx2, Ny2 = 64, 64\n    k_x2 = 2 * np.pi / Lx2\n    k_y2 = 2 * np.pi / Ly2\n    p_true2 = lambda x, y: np.sin(k_x2 * x) * np.sin(k_y2 * y)\n    f2 = lambda x, y: -(k_x2**2 + k_y2**2) * p_true2(x, y)\n    error2 = solve_periodic_bc(Lx2, Ly2, Nx2, Ny2, p_true2, f2)\n    results.append(error2)\n\n    # Test Case 3: Mixed BC, edge case (zero wavenumber in x)\n    Lx3, Ly3 = 1.0, 1.0\n    Nx3, Ny_int3 = 32, 50\n    k_y3 = np.pi / Ly3\n    p_true3 = lambda x, y: np.sin(k_y3 * y)\n    f3 = lambda x, y: -(k_y3**2) * np.sin(k_y3 * y)\n    error3 = solve_mixed_bc(Lx3, Ly3, Nx3, Ny_int3, p_true3, f3)\n    results.append(error3)\n\n    # Format the results for printing\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "For the large, complex domains encountered in realistic ocean modeling, direct solvers are often computationally infeasible, making iterative methods the practical choice. This practice focuses on implementing the Conjugate Gradient (CG) method, an efficient iterative solver for the symmetric positive-definite systems arising from the discretized Poisson equation. You will explore the critical relationship between solver accuracy and computational cost by implementing and testing various stopping criteria based on the residual norm and the change between successive iterates .",
            "id": "3804172",
            "problem": "Consider a two-dimensional horizontal slice of an oceanic domain where the pressure field satisfies the Poisson pressure equation arising from the incompressible flow constraint. Begin from the mass conservation equation for an incompressible fluid, which is $ \\nabla \\cdot \\mathbf{u} = 0 $, and the linear momentum equation under the Boussinesq approximation with constant density and negligible Coriolis and viscous terms at the timescale of interest, and justify the emergence of the Poisson equation for pressure. Then, solve the resulting scalar Partial Differential Equation (PDE) numerically. Use a square-integrable manufactured solution with physically plausible amplitude to quantify the numerical error. The governing PDE is the pressure Poisson equation on a rectangular domain:\n$$ \\nabla^2 p(x,y) = f(x,y), \\quad (x,y) \\in \\Omega, $$\nwith Dirichlet boundary conditions on $ \\partial \\Omega $. The domain is $\\Omega = [0,L_x] \\times [0,L_y]$ with $ L_x = 1000 \\, \\mathrm{m} $ and $ L_y = 500 \\, \\mathrm{m} $. Use a manufactured exact solution\n$$ p_{\\mathrm{exact}}(x,y) = A \\sin\\!\\left(\\frac{2\\pi x}{L_x}\\right)\\sin\\!\\left(\\frac{2\\pi y}{L_y}\\right), $$\nwhere $A$ is the amplitude in Pascals and the arguments of the sine functions are in radians. The corresponding source term is\n$$ f(x,y) = -\\left[\\left(\\frac{2\\pi}{L_x}\\right)^2 + \\left(\\frac{2\\pi}{L_y}\\right)^2\\right] p_{\\mathrm{exact}}(x,y). $$\nImpose Dirichlet boundary conditions $p\\vert_{\\partial \\Omega} = p_{\\mathrm{exact}}\\vert_{\\partial \\Omega}$.\n\nDiscretize the PDE using a second-order accurate finite difference method on a uniform Cartesian grid with $N_x$ points in the $x$-direction and $N_y$ points in the $y$-direction, including the boundary nodes. Let the spacings be $\\Delta x = L_x/(N_x - 1)$ and $\\Delta y = L_y/(N_y - 1)$. Assemble the resulting sparse, symmetric positive definite linear system $A \\mathbf{p} = \\mathbf{b}$ for the interior degrees of freedom. Implement an iterative solver based on Conjugate Gradient (CG) for symmetric positive definite systems to compute the interior pressure vector $\\mathbf{p}$. Define and monitor the following quantities at iteration $k$:\n- The relative residual norm $\\| \\mathbf{r}_k \\|_2 / \\| \\mathbf{b} \\|_2$ where $\\mathbf{r}_k = \\mathbf{b} - A \\mathbf{p}_k$.\n- The relative iterate change $\\| \\mathbf{p}_{k+1} - \\mathbf{p}_{k} \\|_2 / \\| \\mathbf{p}_{k+1} \\|_2$, with the convention that if $\\| \\mathbf{p}_{k+1} \\|_2 = 0$ then test $\\| \\mathbf{p}_{k+1} - \\mathbf{p}_{k} \\|_2 \\le \\tau_x$ directly.\n- The true discrete $L^2$ error at convergence, computed as\n$$ \\varepsilon = \\frac{\\left(\\sum_{i=2}^{N_x-1}\\sum_{j=2}^{N_y-1} \\left[p_{i,j} - p_{\\mathrm{exact},i,j}\\right]^2 \\Delta x \\Delta y \\right)^{1/2}}{\\left(\\sum_{i=2}^{N_x-1}\\sum_{j=2}^{N_y-1} p_{\\mathrm{exact},i,j}^2 \\Delta x \\Delta y \\right)^{1/2}}, $$\nwhere $p_{i,j}$ and $p_{\\mathrm{exact},i,j}$ denote the numerical and exact pressures at interior grid nodes. The error $\\varepsilon$ is dimensionless.\n\nImplement the following stopping criteria:\n- Stop if the relative residual norm falls below a prescribed threshold $\\tau_r$.\n- Stop if the relative iterate change falls below a prescribed threshold $\\tau_x$.\n- Stop if the number of iterations reaches a prescribed maximum $k_{\\max}$.\n\nCompute and report, for each test case, the final relative residual norm, the final discrete relative $L^2$ error $\\varepsilon$, the number of iterations performed, and two booleans indicating whether stopping was triggered by the residual criterion and by the iterate-change criterion, respectively. All trigonometric function arguments must be in radians. Pressure is in Pascals. The reported relative residual norm and relative $L^2$ error are dimensionless.\n\nTest suite. Use the following parameter sets to test the solver and the criteria across a range of scenarios:\n- Case $1$ (happy path): $N_x = 65$, $N_y = 33$, $A = 1 \\, \\mathrm{Pa}$, $\\tau_r = 10^{-8}$, $\\tau_x = 10^{-10}$, $k_{\\max} = 2000$.\n- Case $2$ (looser tolerances): $N_x = 33$, $N_y = 17$, $A = 1 \\, \\mathrm{Pa}$, $\\tau_r = 10^{-4}$, $\\tau_x = 10^{-6}$, $k_{\\max} = 1000$.\n- Case $3$ (tight tolerances, small grid): $N_x = 9$, $N_y = 9$, $A = 1 \\, \\mathrm{Pa}$, $\\tau_r = 10^{-12}$, $\\tau_x = 10^{-12}$, $k_{\\max} = 10000$.\n- Case $4$ (zero-forcing edge case): $N_x = 33$, $N_y = 33$, $A = 0 \\, \\mathrm{Pa}$, $\\tau_r = 10^{-8}$, $\\tau_x = 10^{-10}$, $k_{\\max} = 2000$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with no spaces, where each element corresponds to one test case and is itself a list of the five values `[relative residual, relative L^2 error, iterations, stopped by residual, stopped by iterate change]`. For example, the structure must be `[[r_1,e_1,n_1,b^(r)_1,b^(x)_1],[r_2,e_2,n_2,b^(r)_2,b^(x)_2],...]` with each `r_i` and `e_i` a floating-point number, each `n_i` an integer, and each `b^(r)_i`, `b^(x)_i` a boolean.",
            "solution": "The validity of the problem statement is confirmed. The problem is scientifically grounded, well-posed, and provides a complete and consistent set of definitions and parameters. The physics describing the emergence of the Poisson pressure equation from the incompressible flow equations is standard in fluid dynamics, and the numerical task is a well-defined application of the method of manufactured solutions for verifying a numerical solver.\n\nFirst, we justify the emergence of the Poisson equation for pressure from the governing equations of an incompressible fluid. The derivation begins with the conservation of mass and linear momentum.\n\n1.  **Mass Conservation (Continuity Equation)**: For an incompressible fluid with constant density $\\rho_0$, the continuity equation states that the velocity field $\\mathbf{u}$ must be divergence-free:\n    $$ \\nabla \\cdot \\mathbf{u} = 0 $$\n\n2.  **Momentum Conservation (Euler Equation)**: Under the stated approximations (Boussinesq, constant density, negligible Coriolis and viscous terms), the momentum equation is:\n    $$ \\frac{\\partial \\mathbf{u}}{\\partial t} + (\\mathbf{u} \\cdot \\nabla)\\mathbf{u} = -\\frac{1}{\\rho_0} \\nabla p $$\n    where $p$ is the dynamic pressure.\n\nTo derive an equation for pressure, we take the divergence of the momentum equation:\n$$ \\nabla \\cdot \\left( \\frac{\\partial \\mathbf{u}}{\\partial t} \\right) + \\nabla \\cdot ((\\mathbf{u} \\cdot \\nabla)\\mathbf{u}) = \\nabla \\cdot \\left(-\\frac{1}{\\rho_0} \\nabla p \\right) $$\n\nWe analyze each term separately:\n-   Assuming sufficient smoothness of the velocity field, we can interchange the temporal and spatial derivatives:\n    $$ \\nabla \\cdot \\left( \\frac{\\partial \\mathbf{u}}{\\partial t} \\right) = \\frac{\\partial}{\\partial t} (\\nabla \\cdot \\mathbf{u}) $$\n    By the incompressibility constraint, $\\nabla \\cdot \\mathbf{u} = 0$, so this term vanishes.\n\n-   The pressure term becomes:\n    $$ \\nabla \\cdot \\left(-\\frac{1}{\\rho_0} \\nabla p \\right) = -\\frac{1}{\\rho_0} \\nabla^2 p $$\n    where $\\nabla^2$ is the Laplacian operator.\n\nSubstituting these results back, we obtain the Pressure Poisson Equation (PPE):\n$$ \\nabla^2 p = -\\rho_0 \\nabla \\cdot ((\\mathbf{u} \\cdot \\nabla)\\mathbf{u}) $$\n\nThis equation is a diagnostic constraint on the pressure field, ensuring the velocity field remains incompressible at all times. The right-hand side acts as a source term, which we denote as $f(x,y)$:\n$$ f(x,y) = -\\rho_0 \\nabla \\cdot ((\\mathbf{u} \\cdot \\nabla)\\mathbf{u}) $$\nIn this problem, a specific form for $f(x,y)$ is provided, corresponding to a manufactured analytical solution for $p(x,y)$, allowing for direct verification of the numerical method.\n\nThe problem is to solve $\\nabla^2 p(x,y) = f(x,y)$ on $\\Omega = [0,L_x] \\times [0,L_y]$. We discretize this equation using a second-order central finite difference scheme on a uniform grid with $(x_i, y_j) = ((i-1)\\Delta x, (j-1)\\Delta y)$ for $i=1,\\dots,N_x$ and $j=1,\\dots,N_y$. The grid spacings are $\\Delta x = L_x/(N_x - 1)$ and $\\Delta y = L_y/(N_y - 1)$. The finite difference approximation at an interior node $(i,j)$ is:\n$$ \\frac{p_{i+1,j} - 2p_{i,j} + p_{i-1,j}}{(\\Delta x)^2} + \\frac{p_{i,j+1} - 2p_{i,j} + p_{i,j-1}}{(\\Delta y)^2} = f_{i,j} $$\nfor $i=2,\\dots,N_x-1$ and $j=2,\\dots,N_y-1$.\n\nTo formulate this as a symmetric positive definite (SPD) linear system $A \\mathbf{p} = \\mathbf{b}$, we re-arrange the equation by multiplying by $-1$:\n$$ 2\\left(\\frac{1}{(\\Delta x)^2} + \\frac{1}{(\\Delta y)^2}\\right)p_{i,j} - \\frac{p_{i+1,j}}{(\\Delta x)^2} - \\frac{p_{i-1,j}}{(\\Delta x)^2} - \\frac{p_{i,j+1}}{(\\Delta y)^2} - \\frac{p_{i,j-1}}{(\\Delta y)^2} = -f_{i,j} $$\nThe left side defines the action of the matrix $A$ (the discrete negative Laplacian) on the vector of interior unknowns $\\mathbf{p}$. The terms involving known boundary values are moved to the right-hand side to form the vector $\\mathbf{b}$. For an interior node $(i,j)$, the corresponding element of $\\mathbf{b}$ is:\n$$ b_{i,j} = -f_{i,j} + (\\text{boundary contributions}) $$\nSpecifically, if $i=2$, we add $\\frac{p_{1,j}}{(\\Delta x)^2}$ to the RHS. If $i=N_x-1$, we add $\\frac{p_{N_x,j}}{(\\Delta x)^2}$. Similarly, if $j=2$, we add $\\frac{p_{i,1}}{(\\Delta y)^2}$, and if $j=N_y-1$, we add $\\frac{p_{i,N_y}}{(\\Delta y)^2}$. The boundary values $p_{i,j}$ are given by $p_{\\mathrm{exact}}(x_i, y_j)$.\n\nThe resulting linear system is solved for the vector of interior pressure values $\\mathbf{p}$ using the Conjugate Gradient (CG) algorithm. This method is suitable because the matrix $A$ is sparse, symmetric, and positive-definite. We implement a matrix-free version of CG, where the matrix-vector product $A\\mathbf{x}$ is computed by applying the 5-point stencil to the vector $\\mathbf{x}$ reshaped onto the grid of interior nodes.\n\nThe CG algorithm is initialized with a guess $\\mathbf{p}_0 = \\mathbf{0}$. The iterations proceed until one of the stopping criteria is met: the relative residual norm $\\| \\mathbf{b} - A\\mathbf{p}_k \\|_2 / \\| \\mathbf{b} \\|_2$ falls below $\\tau_r$, the relative iterate change $\\| \\mathbf{p}_{k+1} - \\mathbf{p}_k \\|_2 / \\| \\mathbf{p}_{k+1} \\|_2$ falls below $\\tau_x$, or the iteration count exceeds $k_{\\max}$.\n\nSpecial handling is required for the test case where the pressure amplitude $A=0$. Here, $p_{\\mathrm{exact}}=0$, $f(x,y)=0$, and the boundary conditions are zero. This leads to a homogeneous system $A\\mathbf{p}=\\mathbf{0}$. Since $A$ is SPD, the unique solution is $\\mathbf{p}=\\mathbf{0}$. Our initial guess $\\mathbf{p}_0=\\mathbf{0}$ is the exact solution. The initial residual is $\\mathbf{r}_0 = \\mathbf{0}$, so the absolute residual norm is $0$ and the solver converges in $0$ iterations. The relative residual $\\| \\mathbf{r}_0 \\|_2 / \\| \\mathbf{b} \\|_2$ becomes $0/0$; we define this as $0$. The relative $L^2$ error also becomes $0/0$, and since the numerical solution is exact, the error is correctly reported as $0$.\n\nUpon convergence at iteration $k_{\\text{final}}$, the final numerical solution on the full grid is constructed by combining the computed interior values with the known boundary values. The discrete relative $L^2$ error, $\\varepsilon$, is then computed using the formula provided, which compares the numerical and exact solutions at the interior nodes. The reported results for each test case include the final relative residual norm, the error $\\varepsilon$, the number of iterations, and boolean flags indicating which stopping criteria were met.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1: happy path\n        {'Nx': 65, 'Ny': 33, 'A': 1.0, 'tau_r': 1e-8, 'tau_x': 1e-10, 'k_max': 2000},\n        # Case 2: looser tolerances\n        {'Nx': 33, 'Ny': 17, 'A': 1.0, 'tau_r': 1e-4, 'tau_x': 1e-6, 'k_max': 1000},\n        # Case 3: tight tolerances, small grid\n        {'Nx': 9, 'Ny': 9, 'A': 1.0, 'tau_r': 1e-12, 'tau_x': 1e-12, 'k_max': 10000},\n        # Case 4: zero-forcing edge case\n        {'Nx': 33, 'Ny': 33, 'A': 0.0, 'tau_r': 1e-8, 'tau_x': 1e-10, 'k_max': 2000},\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result = solve_one_case(**params)\n        all_results.append(result)\n\n    # Format the final output string exactly as specified.\n    result_strings = []\n    for r in all_results:\n        # [float, float, int, bool, bool]\n        # str(True) -> 'True', which is fine.\n        inner_str = f\"[{r[0]},{r[1]},{r[2]},{str(r[3]).lower()},{str(r[4]).lower()}]\"\n        result_strings.append(inner_str)\n    \n    # Python's default json-like bool representation is lower case,\n    # but the problem implies Python's `True`/`False`.\n    # To be unambiguous, I will make them lowercase as is common in JSON.\n    final_output = f\"[{','.join(result_strings)}]\"\n    # The example has `b^(r)_1`. Booleans seem more natural.\n    # The prompt says 'boolean', which maps to True/False in Python.\n    # Let me re-format without the lowercase conversion to match Python bools.\n    result_strings_pybool = []\n    for r in all_results:\n        inner_str = f\"[{r[0]},{r[1]},{r[2]},{r[3]},{r[4]}]\"\n        result_strings_pybool.append(inner_str)\n    print(f\"[{','.join(result_strings_pybool)}]\")\n\n\ndef solve_one_case(Nx, Ny, A, tau_r, tau_x, k_max):\n    \"\"\"\n    Solves the Poisson equation for a single set of parameters.\n    \"\"\"\n    # Domain and grid setup\n    Lx, Ly = 1000.0, 500.0\n    dx, dy = Lx / (Nx - 1), Ly / (Ny - 1)\n    \n    x = np.linspace(0, Lx, Nx)\n    y = np.linspace(0, Ly, Ny)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # Manufactured solution and source term\n    kx, ky = 2 * np.pi / Lx, 2 * np.pi / Ly\n    p_exact = A * np.sin(kx * X) * np.sin(ky * Y)\n    f_source = -(kx**2 + ky**2) * p_exact\n\n    # System assembly for interior points\n    # A p = b, where A is the discrete negative Laplacian\n    # and p is the vector of interior pressure values.\n    \n    # Construct RHS vector b\n    b_2d = -f_source[1:-1, 1:-1]\n    \n    # Add boundary contributions\n    b_2d[0, :] += p_exact[0, 1:-1] / dx**2   # Boundary at i=1 (x=0)\n    b_2d[-1, :] += p_exact[-1, 1:-1] / dx**2  # Boundary at i=Nx (x=Lx)\n    b_2d[:, 0] += p_exact[1:-1, 0] / dy**2   # Boundary at j=1 (y=0)\n    b_2d[:, -1] += p_exact[1:-1, -1] / dy**2  # Boundary at j=Ny (y=Ly)\n    \n    b = b_2d.flatten()\n    \n    # Matrix-vector product function for the CG solver\n    # This function computes (discrete negative Laplacian) * p_int_vec\n    def matvec(p_int_vec):\n        p_int_2d = p_int_vec.reshape((Nx-2, Ny-2))\n        p_full = np.zeros((Nx, Ny))\n        p_full[1:-1, 1:-1] = p_int_2d\n\n        lap_p = (p_full[2:, 1:-1] - 2*p_full[1:-1, 1:-1] + p_full[:-2, 1:-1]) / dx**2 + \\\n                (p_full[1:-1, 2:] - 2*p_full[1:-1, 1:-1] + p_full[1:-1, :-2]) / dy**2\n        \n        # We solve A*p=b where A=-nabla^2\n        return -lap_p.flatten()\n\n    # CG solver implementation\n    p_int = np.zeros_like(b)\n    r = b - matvec(p_int)\n    d = r.copy()\n    \n    rs_old = np.dot(r, r)\n    b_norm = np.linalg.norm(b)\n\n    # Handle the A=0 (P_amp=0) case where b is all zeros\n    if b_norm == 0:\n        final_rel_res = 0.0\n        stopped_by_res = True\n        stopped_by_iter = False\n        k = 0\n    else:\n        # Main CG loop\n        stopped_by_res = False\n        stopped_by_iter = False\n        k = 0\n        for k_iter in range(1, k_max + 1):\n            k = k_iter\n            Ap = matvec(d)\n            alpha = rs_old / np.dot(d, Ap)\n            \n            p_new = p_int + alpha * d\n            \n            # Check for iterate change convergence\n            p_diff_norm = np.linalg.norm(p_new - p_int)\n            p_new_norm = np.linalg.norm(p_new)\n            \n            if p_new_norm == 0.0:\n                rel_iter_change = p_diff_norm\n            else:\n                rel_iter_change = p_diff_norm / p_new_norm\n            \n            p_int = p_new\n\n            stopped_by_iter = rel_iter_change  tau_x\n\n            # Update residual with a more stable formula\n            r = r - alpha * Ap\n            rs_new = np.dot(r, r)\n            \n            # Check for residual convergence\n            final_rel_res = np.sqrt(rs_new) / b_norm\n            stopped_by_res = final_rel_res  tau_r\n            \n            if stopped_by_res or stopped_by_iter:\n                break\n                \n            d = r + (rs_new / rs_old) * d\n            rs_old = rs_new\n        else: # loop completed without break (k_max reached)\n             k = k_max\n             final_rel_res = np.sqrt(rs_old) / b_norm\n\n    # Reconstruct full solution\n    p_numerical = np.copy(p_exact) # Start with boundary values\n    p_numerical[1:-1, 1:-1] = p_int.reshape((Nx - 2, Ny - 2))\n\n    # Calculate final discrete L2 error\n    p_exact_interior = p_exact[1:-1, 1:-1]\n    p_numerical_interior = p_numerical[1:-1, 1:-1]\n\n    error_field = p_numerical_interior - p_exact_interior\n    numerator_l2 = np.sqrt(np.sum(error_field**2) * dx * dy)\n    denominator_l2 = np.sqrt(np.sum(p_exact_interior**2) * dx * dy)\n    \n    if denominator_l2 == 0:\n        # Case where exact solution is zero. If numerical is also zero, error is 0.\n        rel_l2_error = 0.0 if numerator_l2 == 0.0 else np.inf\n    else:\n        rel_l2_error = numerator_l2 / denominator_l2\n\n    return [final_rel_res, rel_l2_error, k, stopped_by_res, stopped_by_iter]\n\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}