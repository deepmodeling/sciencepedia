{
    "hands_on_practices": [
        {
            "introduction": "开发可靠数值模型的第一步是确保代码的正确性。本实践将介绍“人造解方法”（Method of Manufactured Solutions, MMS），这是一种强大的代码验证技术，通过“制造”一个精确解来检验求解器的准确性。通过实现一个有限差分求解器并将其计算结果与已知解进行比较，您将通过经验验证离散方案的理论收敛阶 。",
            "id": "3804158",
            "problem": "考虑在不可压缩海洋模型中出现的压力泊松方程，它是一个在单位正方形域 $\\Omega = (0,1)\\times(0,1)$ 上定义的标量偏微分方程 (PDE) $\\nabla^2 u = f$，带有狄利克雷边界条件 $u|_{\\partial\\Omega} = g$。为使用人造解方法 (MMS) 验证数值求解器，假设一个光滑的人造解 $u^\\star(x,y)$，并通过 $u^\\star$ 的精确拉普拉斯算子来定义强迫项 $f$，同时将边界数据 $g$ 指定为 $u^\\star$ 在 $\\partial\\Omega$ 上的限制。所有量均为无量纲。\n\n设人造解为\n$$\nu^\\star(x,y) = \\sin(3\\pi x)\\cos(2\\pi y) + x^3 y - e^{x+y}.\n$$\n通过 $f(x,y) = \\nabla^2 u^\\star(x,y)$ 定义 $f(x,y)$，并通过 $g(x,y) = u^\\star(x,y)$ 定义 $g$（对于 $(x,y)\\in \\partial\\Omega$）。目标是使用矩形网格上的二阶中心有限差分格式来数值求解在 $\\partial\\Omega$ 上满足 $u=g$ 的方程 $\\nabla^2 u = f$，并在网格加密过程中量化离散误差和观测到的精度阶。\n\n仅从以下基本原理出发：\n- 不可压缩流的质量守恒在投影类求解器中会导出压力泊松方程，这在数学上可归结为在具有适当边界条件的域上求解 $\\nabla^2 u = f$。\n- 二阶导数的中心二阶有限差分近似源于围绕网格点的泰勒展开，并在均匀网格上产生一个由方向二阶差分组合而成的离散拉普拉斯算子。\n\n需要在程序中实现的任务：\n1. 在 $\\Omega$ 上使用均匀矩形网格离散化 $\\nabla^2 u = f$，该网格在 $x$ 方向有 $N_x$ 个点，在 $y$ 方向有 $N_y$ 个点，步长分别为 $h_x = 1/(N_x-1)$ 和 $h_y = 1/(N_y-1)$。使用空间二阶精度的五点格式。通过代入来自 $u^\\star$ 的边界值来强施加狄利克雷边界条件，并将相应的贡献移入内部节点线性系统的右端项。\n2. 求解得到的线性系统以获得内部网格点的值，并通过代入来自 $u^\\star$ 的边界值来重构所有节点上的网格函数 $u_h$。\n3. 仅在一组内部节点上计算离散内部误差 $e_h = u_h - u^\\star$。根据 $e_h$ 计算两个范数：\n   - 离散 $L^2$ 范数，定义为 $\\|e_h\\|_{L^2(\\Omega)} \\approx \\left(\\sum_{i=1}^{N_x-2}\\sum_{j=1}^{N_y-2} |e_{i,j}|^2 h_x h_y\\right)^{1/2}$。\n   - 离散 $L^\\infty$ 范数，定义为 $\\|e_h\\|_{L^\\infty(\\Omega)} = \\max_{1\\le i\\le N_x-2,\\,1\\le j\\le N_y-2} |e_{i,j}|$。\n4. 对于每个方向上加密因子为 2 的网格加密，使用标准公式 $p = \\log(e_{h}/e_{h/2})/\\log(2)$ 估计观测到的精度阶 $p$，其中 $e_h$ 表示在分辨率为 $(h_x,h_y)$ 时的误差范数，而 $e_{h/2}$ 表示在加密后分辨率为 $(h_x/2,h_y/2)$ 时的误差范数。在各向异性情况中，$h_x\\neq h_y$ 但两者都以因子 2 加密，使用相同的公式，并理解为两个方向的加密因子均为 2，且误差范数 $e_h$ 是在相应网格的内部节点上计算的。\n5. 在最精细的各向同性网格上，计算离散线性系统残差的相对 $\\ell^2$ 范数 $\\|r\\|_2/\\|b\\|_2$，其中 $r = A u - b$ 是组装好的线性系统的内部节点残差，$A$ 是离散拉普拉斯算子，$b$ 是调整后的右端项。此量为无量纲。\n\n测试套件规范：\n- 各向同性加密序列：$(N_x,N_y)\\in\\{(17,17),(33,33),(65,65)\\}$。仅使用最后两个层级计算观测到的精度阶，即使用来自 $(33,33)$ 和 $(65,65)$ 的误差来生成 $p_{L^2}^{\\mathrm{iso}}$ 和 $p_{L^\\infty}^{\\mathrm{iso}}$。\n- 各向异性加密对：粗网格 $(N_x,N_y)=(33,49)$ 和细网格 $(N_x,N_y)=(65,97)$。计算这两个层级之间的 $p_{L^2}^{\\mathrm{aniso}}$ 和 $p_{L^\\infty}^{\\mathrm{aniso}}$。\n- 最精细各向同性网格上的残差：计算在 $(N_x,N_y)=(65,65)$ 时的相对残差 $\\|r\\|_2/\\|b\\|_2$。\n\n所有计算均为无量纲；不涉及物理单位。\n\n最终输出规范：\n您的程序必须生成单行输出，其中包含一个 Python 风格的列表，按以下顺序包含五个浮点数：\n$[p_{L^2}^{\\mathrm{iso}}, p_{L^\\infty}^{\\mathrm{iso}}, p_{L^2}^{\\mathrm{aniso}}, p_{L^\\infty}^{\\mathrm{aniso}}, \\|r\\|_2/\\|b\\|_2]$。\n每个值必须四舍五入到小数点后恰好六位。该行不得包含任何其他文本。\n\n您的实现必须是完全独立且可运行的。不允许用户输入。所有角度和量均为无量纲；不需要也不接受单位。正确性标准是针对指定测试套件的五个输出的数值。预期答案为实数，并且对于此光滑人造解，应在两种范数下都反映出二阶收敛性。最终输出必须按规定将所有给定测试用例的结果汇总到单行中。",
            "solution": "所提出的问题是针对二维泊松方程 $\\nabla^2 u = f$（在单位正方形域 $\\Omega = (0,1)\\times(0,1)$ 上，具有指定的狄利克雷边界条件 $u|_{\\partial\\Omega} = g$）数值求解器的标准验证练习。该练习采用人造解方法 (MMS)，这是一种用于验证数值代码正确性和准确性的严谨技术。该问题在科学上是合理的、自洽的且适定的。下面我们给出一个完整的解法。\n\n### 1. 解析公式\n\nMMS 的核心是为解（称为人造解 $u^\\star(x,y)$）假设一个解析形式，然后推导出相应的问题数据（强迫项 $f$ 和边界条件 $g$）。\n\n给定的人造解为：\n$$\nu^\\star(x,y) = \\sin(3\\pi x)\\cos(2\\pi y) + x^3 y - e^{x+y}\n$$\n强迫项 $f(x,y)$ 定义为 $u^\\star(x,y)$ 的拉普拉斯算子：\n$$\nf(x,y) = \\nabla^2 u^\\star(x,y) = \\frac{\\partial^2 u^\\star}{\\partial x^2} + \\frac{\\partial^2 u^\\star}{\\partial y^2}\n$$\n我们计算 $u^\\star$ 的二阶偏导数：\n首先，对 $x$ 求导：\n$$\n\\frac{\\partial u^\\star}{\\partial x} = 3\\pi \\cos(3\\pi x)\\cos(2\\pi y) + 3x^2 y - e^{x+y}\n$$\n$$\n\\frac{\\partial^2 u^\\star}{\\partial x^2} = -(3\\pi)^2 \\sin(3\\pi x)\\cos(2\\pi y) + 6xy - e^{x+y} = -9\\pi^2 \\sin(3\\pi x)\\cos(2\\pi y) + 6xy - e^{x+y}\n$$\n接下来，对 $y$ 求导：\n$$\n\\frac{\\partial u^\\star}{\\partial y} = -2\\pi \\sin(3\\pi x)\\sin(2\\pi y) + x^3 - e^{x+y}\n$$\n$$\n\\frac{\\partial^2 u^\\star}{\\partial y^2} = -(2\\pi)^2 \\sin(3\\pi x)\\cos(2\\pi y) - e^{x+y} = -4\\pi^2 \\sin(3\\pi x)\\cos(2\\pi y) - e^{x+y}\n$$\n将这些导数相加，得到强迫函数 $f(x,y)$：\n$$\nf(x,y) = (-9\\pi^2 - 4\\pi^2)\\sin(3\\pi x)\\cos(2\\pi y) + 6xy - 2e^{x+y}\n$$\n$$\nf(x,y) = -13\\pi^2\\sin(3\\pi x)\\cos(2\\pi y) + 6xy - 2e^{x+y}\n$$\n狄利克雷边界数据 $g(x,y)$ 就是 $u^\\star(x,y)$ 在单位正方形边界 $\\partial\\Omega$ 上的值。\n\n### 2. 数值离散化\n\n域 $\\Omega = (0,1)\\times(0,1)$ 使用均匀矩形网格进行离散化。网格点表示为 $(x_i, y_j)$，其中 $x_i = i h_x$（对于 $i \\in \\{0, 1, ..., N_x-1\\}$）和 $y_j = j h_y$（对于 $j \\in \\{0, 1, ..., N_y-1\\}$）。网格间距为 $h_x = 1/(N_x-1)$ 和 $h_y = 1/(N_y-1)$。\n\n在内部网格点 $(x_i, y_j)$ 处的拉普拉斯算子 $\\nabla^2 u$ 使用二阶中心有限差分公式进行近似，这得到了著名的五点格式：\n$$\n\\nabla^2 u \\Big|_{(x_i, y_j)} \\approx \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2}\n$$\n其中 $u_{i,j}$ 表示 $u(x_i, y_j)$ 的数值近似。将其等同于源项 $f(x_i, y_j) = f_{i,j}$，得到每个内部节点（$1 \\le i \\le N_x-2$, $1 \\le j \\le N_y-2$）处的离散方程：\n$$\n\\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2} = f_{i,j}\n$$\n\n### 3. 线性系统构建\n\n所有 $(N_x-2) \\times (N_y-2)$ 个内部节点的线性代数方程组构成一个形如 $A\\mathbf{u}_{int} = \\mathbf{b}$ 的大型线性系统。\n\n$\\mathbf{u}_{int}$ 是内部网格点处未知值 $u_{i,j}$ 的向量，被展平为一维数组。使用行主序，内部点 $(i,j)$ 的索引 $k$ 为 $k = (i-1)(N_y-2) + (j-1)$。\n\n矩阵 $A$ 是表示离散拉普拉斯算子的稀疏矩阵。它具有块三对角结构。一种构建 $A$ 的高效方法是使用一维二阶导数矩阵的克罗内克和。设 $D_{xx}$ 为 $x$ 方向二阶导数的 $(N_x-2) \\times (N_x-2)$ 矩阵，$D_{yy}$ 为 $y$ 方向二阶导数的 $(N_y-2) \\times (N_y-2)$ 矩阵。那么，对于未知量的行主序，$A$ 由下式给出：\n$$\nA = D_{xx} \\otimes I_y + I_x \\otimes D_{yy}\n$$\n其中 $I_x$ 和 $I_y$ 分别是大小为 $(N_x-2)$ 和 $(N_y-2)$ 的单位矩阵，$\\otimes$ 表示克罗内克积。\n\n右端项向量 $\\mathbf{b}$ 由内部节点处的强迫函数值 $f_{i,j}$ 构成。对于邻近边界的节点，必须并入边界条件值。离散方程经过重新排列，将所有已知的边界值项移到右端。对于一个内部节点 $(i,j)$，右端项元素 $b_{i,j}$ 初始化为 $f_{i,j}$。然后进行调整：\n-   如果 $i=1$，从 $b_{1,j}$ 中减去 $\\frac{g(x_0, y_j)}{h_x^2}$。\n-   如果 $i=N_x-2$，从 $b_{N_x-2,j}$ 中减去 $\\frac{g(x_{N_x-1}, y_j)}{h_x^2}$。\n-   如果 $j=1$，从 $b_{i,1}$ 中减去 $\\frac{g(x_i, y_0)}{h_y^2}$。\n-   如果 $j=N_y-2$，从 $b_{i,N_y-2}$ 中减去 $\\frac{g(x_i, y_{N_y-1})}{h_y^2}$。\n\n一旦 $A$ 和 $\\mathbf{b}$ 组装完毕，就求解该系统以得到 $\\mathbf{u}_{int}$。然后通过将计算出的内部值与来自 $u^\\star$ 的已知边界值相结合，来构建完整的数值解 $u_h$。\n\n### 4. 误差分析与收敛性\n\n数值误差是数值解 $u_h$ 与精确人造解 $u^\\star$ 在网格点上的差值，即 $e_{i,j} = u_{h,i,j} - u^\\star(x_i, y_j)$。我们使用两个标准范数来量化内部节点上的此误差：\n\n-   离散 $L^2$ 范数：$\\|e_h\\|_{L^2} = \\left(\\sum_{i=1}^{N_x-2}\\sum_{j=1}^{N_y-2} |e_{i,j}|^2 h_x h_y\\right)^{1/2}$\n-   离散 $L^\\infty$ 范数（最大范数）：$\\|e_h\\|_{L^\\infty} = \\max_{1\\le i\\le N_x-2,\\,1\\le j\\le N_y-2} |e_{i,j}|$\n\n为验证方法的精度阶，我们进行网格加密研究。如果误差范数的行为符合 $\\|e_h\\| \\approx C h^p$，其中 $h$ 是特征网格尺寸，$p$ 是精度阶，那么通过在粗网格（尺寸 $h$）和细网格（尺寸 $h/2$）上求解，我们可以估计 $p$：\n$$\np = \\frac{\\log(\\|e_h\\| / \\|e_{h/2}\\|)}{\\log(2)}\n$$\n对于一个二阶方法，我们期望 $p \\approx 2$。\n\n最后，计算线性系统残差的相对 $\\ell^2$ 范数 $\\|r\\|_2 / \\|b\\|_2$，其中 $r = A\\mathbf{u}_{int} - \\mathbf{b}$。该值评估数值线性代数求解器求解系统 $A\\mathbf{u}_{int} = \\mathbf{b}$ 的效果如何，并且应接近机器精度。\n\n为生成五个所需的输出值，我们对指定的各向同性和各向异性网格加密序列实施了这些步骤。",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import diags, identity, kron\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to perform the Method of Manufactured Solutions verification\n    for a 2D Poisson solver.\n    \"\"\"\n\n    def u_star(x, y):\n        \"\"\"The manufactured solution u*(x,y).\"\"\"\n        return np.sin(3 * np.pi * x) * np.cos(2 * np.pi * y) + x**3 * y - np.exp(x + y)\n\n    def f_source(x, y):\n        \"\"\"The forcing term f(x,y) = laplacian(u*(x,y)).\"\"\"\n        term1 = -13 * np.pi**2 * np.sin(3 * np.pi * x) * np.cos(2 * np.pi * y)\n        term2 = 6 * x * y\n        term3 = -2 * np.exp(x + y)\n        return term1 + term2 + term3\n\n    def solve_poisson(Nx, Ny):\n        \"\"\"\n        Solves the Poisson equation on a grid of size (Nx, Ny) and returns error norms.\n        \"\"\"\n        hx = 1.0 / (Nx - 1)\n        hy = 1.0 / (Ny - 1)\n\n        x = np.linspace(0, 1, Nx)\n        y = np.linspace(0, 1, Ny)\n        X, Y = np.meshgrid(x, y, indexing='ij')\n\n        u_exact_grid = u_star(X, Y)\n        f_grid = f_source(X, Y)\n\n        Nix = Nx - 2\n        Niy = Ny - 2\n        N_int = Nix * Niy\n\n        if N_int == 0:\n            return 0.0, 0.0, None, None, None\n\n        # Assemble the discrete Laplacian matrix A using Kronecker products\n        # This corresponds to row-major (C-style) flattening of the unknowns.\n        hx2_inv = 1.0 / hx**2\n        hy2_inv = 1.0 / hy**2\n        \n        diag_x = np.full(Nix, -2.0 * hx2_inv)\n        offdiag_x = np.full(Nix - 1, 1.0 * hx2_inv)\n        Dxx = diags([offdiag_x, diag_x, offdiag_x], [-1, 0, 1], format='csc')\n\n        diag_y = np.full(Niy, -2.0 * hy2_inv)\n        offdiag_y = np.full(Niy - 1, 1.0 * hy2_inv)\n        Dyy = diags([offdiag_y, diag_y, offdiag_y], [-1, 0, 1], format='csc')\n\n        Ix = identity(Nix, format='csc')\n        Iy = identity(Niy, format='csc')\n\n        # The order of kron matters and must match the flattening of the RHS vector\n        # This is for row-major flattening: Dxx kron I + I kron Dyy\n        A = kron(Dxx, Iy) + kron(Ix, Dyy)\n\n        # Assemble the right-hand side vector b\n        b_matrix = f_grid[1:-1, 1:-1].copy()\n\n        # Adjust RHS for boundary conditions\n        b_matrix[0, :] -= u_exact_grid[0, 1:-1] * hx2_inv  # Left boundary i=0\n        b_matrix[-1, :] -= u_exact_grid[-1, 1:-1] * hx2_inv # Right boundary i=Nx-1\n        b_matrix[:, 0] -= u_exact_grid[1:-1, 0] * hy2_inv   # Bottom boundary j=0\n        b_matrix[:, -1] -= u_exact_grid[1:-1, -1] * hy2_inv # Top boundary j=Ny-1\n        \n        b = b_matrix.flatten('C')\n\n        # Solve the linear system for interior nodes\n        u_int_flat = spsolve(A, b)\n\n        # Reconstruct the full numerical solution grid\n        u_h = u_exact_grid.copy()\n        u_h[1:-1, 1:-1] = u_int_flat.reshape((Nix, Niy), order='C')\n\n        # Compute error on interior nodes\n        error_grid = u_h[1:-1, 1:-1] - u_exact_grid[1:-1, 1:-1]\n\n        # Compute L2 and Linf norms of the error\n        l2_norm = np.sqrt(np.sum(error_grid**2 * hx * hy))\n        linf_norm = np.max(np.abs(error_grid))\n        \n        return l2_norm, linf_norm, A, u_int_flat, b\n\n    # Isotropic refinement\n    err_l2_33, err_linf_33, _, _, _ = solve_poisson(33, 33)\n    err_l2_65, err_linf_65, A_65, u_sol_65, b_65 = solve_poisson(65, 65)\n\n    p_l2_iso = np.log(err_l2_33 / err_l2_65) / np.log(2)\n    p_linf_iso = np.log(err_linf_33 / err_linf_65) / np.log(2)\n    \n    # Anisotropic refinement\n    err_l2_c, err_linf_c, _, _, _ = solve_poisson(33, 49)\n    err_l2_f, err_linf_f, _, _, _ = solve_poisson(65, 97)\n\n    p_l2_aniso = np.log(err_l2_c / err_l2_f) / np.log(2)\n    p_linf_aniso = np.log(err_linf_c / err_linf_f) / np.log(2)\n    \n    # Residual calculation for the finest isotropic grid\n    residual_vector = A_65.dot(u_sol_65) - b_65\n    rel_residual = np.linalg.norm(residual_vector) / np.linalg.norm(b_65)\n\n    results = [p_l2_iso, p_linf_iso, p_l2_aniso, p_linf_aniso, rel_residual]\n    \n    # Format output as specified\n    formatted_results = [f\"{val:.6f}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "对于计算海洋学中出现的大型线性系统，迭代求解器通常是唯一可行的方法。本实践将重点从离散化转移到求解阶段，指导您实现共轭梯度（Conjugate Gradient, CG）算法——一种针对对称正定系统的高效方法。您将获得关于监控收敛过程以及如何基于残差和迭代变化设置稳健停止条件的实践经验 。",
            "id": "3804172",
            "problem": "考虑海洋域的一个二维水平切片，其中压力场满足由不可压缩流约束产生的压力泊松方程。从不可压缩流体的质量守恒方程（即 $ \\nabla \\cdot \\mathbf{u} = 0 $）和在 Boussinesq 近似下，密度恒定、在所关心的时间尺度上科里奥利项和粘性项可忽略的线性动量方程出发，推导压力泊松方程的出现。然后，对得到的标量偏微分方程 (PDE) 进行数值求解。使用一个具有物理上合理振幅的平方可积制造解来量化数值误差。控制偏微分方程是在一个矩形域上的压力泊松方程：\n$$ \\nabla^2 p(x,y) = f(x,y), \\quad (x,y) \\in \\Omega, $$\n在 $ \\partial \\Omega $ 上具有狄利克雷边界条件。域为 $ \\Omega = [0,L_x] \\times [0,L_y] $，其中 $ L_x = 1000 \\, \\mathrm{m} $ 且 $ L_y = 500 \\, \\mathrm{m} $。使用一个制造的精确解\n$$ p_{\\mathrm{exact}}(x,y) = A \\sin\\!\\left(\\frac{2\\pi x}{L_x}\\right)\\sin\\!\\left(\\frac{2\\pi y}{L_y}\\right), $$\n其中 $ A $ 是以帕斯卡为单位的振幅，正弦函数的参数以弧度为单位。对应的源项是\n$$ f(x,y) = -\\left[\\left(\\frac{2\\pi}{L_x}\\right)^2 + \\left(\\frac{2\\pi}{L_y}\\right)^2\\right] p_{\\mathrm{exact}}(x,y). $$\n施加狄利克雷边界条件 $ p\\vert_{\\partial \\Omega} = p_{\\mathrm{exact}}\\vert_{\\partial \\Omega} $。\n\n在一个均匀笛卡尔网格上，使用二阶精确的有限差分法对 PDE 进行离散化，该网格在 $ x $ 方向有 $ N_x $ 个点，在 $ y $ 方向有 $ N_y $ 个点，包括边界节点。设间距为 $ \\Delta x = L_x/(N_x - 1) $ 和 $ \\Delta y = L_y/(N_y - 1) $。为内部自由度组装得到的稀疏、对称正定线性系统 $ A \\mathbf{p} = \\mathbf{b} $。为对称正定系统实现一个基于共轭梯度 (CG) 的迭代求解器，以计算内部压力向量 $ \\mathbf{p} $。在迭代 $ k $ 时定义并监测以下量：\n- 相对残差范数 $ \\| \\mathbf{r}_k \\|_2 / \\| \\mathbf{b} \\|_2 $，其中 $ \\mathbf{r}_k = \\mathbf{b} - A \\mathbf{p}_k $。\n- 相对迭代变化 $ \\| \\mathbf{p}_{k+1} - \\mathbf{p}_{k} \\|_2 / \\| \\mathbf{p}_{k+1} \\|_2 $，约定如果 $ \\| \\mathbf{p}_{k+1} \\|_2 = 0 $，则直接检验 $ \\| \\mathbf{p}_{k+1} - \\mathbf{p}_{k} \\|_2 \\le \\tau_x $。\n- 收敛时的真实离散 $ L^2 $ 误差，计算如下\n$$ \\varepsilon = \\frac{\\left(\\sum_{i=2}^{N_x-1}\\sum_{j=2}^{N_y-1} \\left[p_{i,j} - p_{\\mathrm{exact},i,j}\\right]^2 \\Delta x \\Delta y \\right)^{1/2}}{\\left(\\sum_{i=2}^{N_x-1}\\sum_{j=2}^{N_y-1} p_{\\mathrm{exact},i,j}^2 \\Delta x \\Delta y \\right)^{1/2}}, $$\n其中 $ p_{i,j} $ 和 $ p_{\\mathrm{exact},i,j} $ 表示内部网格节点上的数值压力和精确压力。误差 $ \\varepsilon $ 是无量纲的。\n\n实现以下停止准则：\n- 如果相对残差范数低于指定的阈值 $ \\tau_r $，则停止。\n- 如果相对迭代变化低于指定的阈值 $ \\tau_x $，则停止。\n- 如果迭代次数达到指定的最大值 $ k_{\\max} $，则停止。\n\n对每个测试用例，计算并报告最终的相对残差范数、最终的离散相对 $ L^2 $ 误差 $ \\varepsilon $、执行的迭代次数，以及两个布尔值，分别指示停止是否由残差准则和迭代变化准则触发。所有三角函数的参数必须以弧度为单位。压力单位为帕斯卡。报告的相对残差范数和相对 $ L^2 $ 误差是无量纲的。\n\n测试套件。使用以下参数集在一系列情景下测试求解器和准则：\n- 用例 1（理想情况）：$ N_x = 65 $，$ N_y = 33 $，$ A = 1 \\, \\mathrm{Pa} $，$ \\tau_r = 10^{-8} $，$ \\tau_x = 10^{-10} $，$ k_{\\max} = 2000 $。\n- 用例 2（较宽松的容差）：$ N_x = 33 $，$ N_y = 17 $，$ A = 1 \\, \\mathrm{Pa} $，$ \\tau_r = 10^{-4} $，$ \\tau_x = 10^{-6} $，$ k_{\\max} = 1000 $。\n- 用例 3（严格容差，小网格）：$ N_x = 9 $，$ N_y = 9 $，$ A = 1 \\, \\mathrm{Pa} $，$ \\tau_r = 10^{-12} $，$ \\tau_x = 10^{-12} $，$ k_{\\max} = 10000 $。\n- 用例 4（零源项边缘情况）：$ N_x = 33 $，$ N_y = 33 $，$ A = 0 \\, \\mathrm{Pa} $，$ \\tau_r = 10^{-8} $，$ \\tau_x = 10^{-10} $，$ k_{\\max} = 2000 $。\n\n最终输出格式。您的程序应产生单行输出，其中包含用方括号括起来的逗号分隔的结果列表，无空格，其中每个元素对应一个测试用例，本身是一个包含五个值的列表 $ [\\text{相对残差}, \\text{相对 } L^2 \\text{ 误差}, \\text{迭代次数}, \\text{因残差停止}, \\text{因迭代变化停止}] $。例如，结构必须是 $ [[r_1,e_1,n_1,b^{(r)}_1,b^{(x)}_1],[r_2,e_2,n_2,b^{(r)}_2,b^{(x)}_2],\\ldots] $，其中每个 $ r_i $ 和 $ e_i $ 是一个浮点数，每个 $ n_i $ 是一个整数，每个 $ b^{(r)}_i $、$ b^{(x)}_i $ 是一个布尔值。",
            "solution": "问题陈述的有效性已确认。该问题有科学依据、是适定的，并提供了一套完整且一致的定义和参数。从不可压缩流方程推导压力泊松方程的物理学原理在流体动力学中是标准的，而数值任务是应用制造解方法验证数值求解器的一个明确定义的应用。\n\n首先，我们从不可压缩流体的控制方程出发，推导压力泊松方程的出现。推导始于质量守恒和线性动量守恒。\n\n1.  **质量守恒（连续性方程）**：对于密度恒为 $\\rho_0$ 的不可压缩流体，连续性方程表明速度场 $\\mathbf{u}$ 必须是无散度的：\n    $$ \\nabla \\cdot \\mathbf{u} = 0 $$\n\n2.  **动量守恒（欧拉方程）**：在所述近似（Boussinesq 近似、密度恒定、忽略科里奥利项和粘性项）下，动量方程为：\n    $$ \\frac{\\partial \\mathbf{u}}{\\partial t} + (\\mathbf{u} \\cdot \\nabla)\\mathbf{u} = -\\frac{1}{\\rho_0} \\nabla p $$\n    其中 $p$ 是动压。\n\n为了推导一个关于压力的方程，我们对动量方程取散度：\n$$ \\nabla \\cdot \\left( \\frac{\\partial \\mathbf{u}}{\\partial t} \\right) + \\nabla \\cdot ((\\mathbf{u} \\cdot \\nabla)\\mathbf{u}) = \\nabla \\cdot \\left(-\\frac{1}{\\rho_0} \\nabla p \\right) $$\n\n我们分别分析每一项：\n-   假设速度场足够光滑，我们可以交换时间和空间导数：\n    $$ \\nabla \\cdot \\left( \\frac{\\partial \\mathbf{u}}{\\partial t} \\right) = \\frac{\\partial}{\\partial t} (\\nabla \\cdot \\mathbf{u}) $$\n    根据不可压缩性约束 $\\nabla \\cdot \\mathbf{u} = 0$，此项为零。\n\n-   压力项变为：\n    $$ \\nabla \\cdot \\left(-\\frac{1}{\\rho_0} \\nabla p \\right) = -\\frac{1}{\\rho_0} \\nabla^2 p $$\n    其中 $\\nabla^2$ 是拉普拉斯算子。\n\n将这些结果代回，我们得到压力泊松方程 (PPE)：\n$$ \\nabla^2 p = -\\rho_0 \\nabla \\cdot ((\\mathbf{u} \\cdot \\nabla)\\mathbf{u}) $$\n\n该方程是对压力场的一个诊断性约束，确保速度场在任何时候都保持不可压缩。右侧项作为源项，我们记为 $f(x,y)$：\n$$ f(x,y) = -\\rho_0 \\nabla \\cdot ((\\mathbf{u} \\cdot \\nabla)\\mathbf{u}) $$\n在本问题中，给定了一个 $f(x,y)$ 的特定形式，它对应于一个 $p(x,y)$ 的制造解析解，从而可以直接验证数值方法。\n\n问题是在 $\\Omega = [0,L_x] \\times [0,L_y]$ 上求解 $\\nabla^2 p(x,y) = f(x,y)$。我们使用二阶中心有限差分格式在一个均匀网格上离散化该方程，网格点为 $(x_i, y_j) = ((i-1)\\Delta x, (j-1)\\Delta y)$，其中 $i=1,\\dots,N_x$ 且 $j=1,\\dots,N_y$。网格间距为 $\\Delta x = L_x/(N_x - 1)$ 和 $\\Delta y = L_y/(N_y - 1)$。在内部节点 $(i,j)$ 处的有限差分近似为：\n$$ \\frac{p_{i+1,j} - 2p_{i,j} + p_{i-1,j}}{(\\Delta x)^2} + \\frac{p_{i,j+1} - 2p_{i,j} + p_{i,j-1}}{(\\Delta y)^2} = f_{i,j} $$\n对于 $i=2,\\dots,N_x-1$ 和 $j=2,\\dots,N_y-1$。\n\n为了将其构造为一个对称正定 (SPD) 线性系统 $A \\mathbf{p} = \\mathbf{b}$，我们通过乘以 $-1$ 来重新整理方程：\n$$ 2\\left(\\frac{1}{(\\Delta x)^2} + \\frac{1}{(\\Delta y)^2}\\right)p_{i,j} - \\frac{p_{i+1,j}}{(\\Delta x)^2} - \\frac{p_{i-1,j}}{(\\Delta x)^2} - \\frac{p_{i,j+1}}{(\\Delta y)^2} - \\frac{p_{i,j-1}}{(\\Delta y)^2} = -f_{i,j} $$\n左侧定义了矩阵 $A$（离散负拉普拉斯算子）作用于内部未知量向量 $\\mathbf{p}$ 的方式。涉及已知边界值的项被移到右侧以形成向量 $\\mathbf{b}$。对于内部节点 $(i,j)$，$\\mathbf{b}$ 的对应元素是：\n$$ b_{i,j} = -f_{i,j} + (\\text{边界贡献}) $$\n具体来说，如果 $i=2$，我们将 $\\frac{p_{1,j}}{(\\Delta x)^2}$ 加到右侧。如果 $i=N_x-1$，我们将 $\\frac{p_{N_x,j}}{(\\Delta x)^2}$ 加到右侧。类似地，如果 $j=2$，我们将 $\\frac{p_{i,1}}{(\\Delta y)^2}$ 加到右侧，如果 $j=N_y-1$，我们将 $\\frac{p_{i,N_y}}{(\\Delta y)^2}$ 加到右侧。边界值 $p_{i,j}$ 由 $p_{\\mathrm{exact}}(x_i, y_j)$ 给出。\n\n使用共轭梯度 (CG) 算法求解得到的线性系统，以获得内部压力值向量 $\\mathbf{p}$。该方法是适用的，因为矩阵 $A$ 是稀疏、对称且正定的。我们实现了一个无矩阵版本的 CG，其中矩阵向量乘积 $A\\mathbf{x}$ 是通过将五点差分格式应用于重塑到内部节点网格上的向量 $\\mathbf{x}$ 来计算的。\n\nCG 算法以初值 $\\mathbf{p}_0 = \\mathbf{0}$ 初始化。迭代持续进行，直到满足其中一个停止准则：相对残差范数 $\\| \\mathbf{b} - A\\mathbf{p}_k \\|_2 / \\| \\mathbf{b} \\|_2$ 低于 $\\tau_r$，相对迭代变化 $\\| \\mathbf{p}_{k+1} - \\mathbf{p}_k \\|_2 / \\| \\mathbf{p}_{k+1} \\|_2$ 低于 $\\tau_x$，或迭代次数超过 $k_{\\max}$。\n\n对于压力振幅 $A=0$ 的测试用例需要特殊处理。此时，$p_{\\mathrm{exact}}=0$，$f(x,y)=0$，且边界条件为零。这导致一个齐次系统 $A\\mathbf{p}=\\mathbf{0}$。由于 $A$ 是对称正定的，唯一解是 $\\mathbf{p}=\\mathbf{0}$。我们的初始猜测 $\\mathbf{p}_0=\\mathbf{0}$ 就是精确解。初始残差为 $\\mathbf{r}_0 = \\mathbf{0}$，因此绝对残差范数为 $0$，求解器在 $0$ 次迭代内收敛。相对残差 $\\| \\mathbf{r}_0 \\|_2 / \\| \\mathbf{b} \\|_2$ 变为 $0/0$；我们将其定义为 $0$。相对 $L^2$ 误差也变为 $0/0$，并且由于数值解是精确的，误差被正确地报告为 $0$。\n\n在第 $k_{final}$ 次迭代收敛后，通过将计算出的内部值与已知的边界值相结合，构建完整网格上的最终数值解。然后，使用提供的公式计算离散相对 $L^2$ 误差 $\\varepsilon$，该公式比较了内部节点上的数值解和精确解。每个测试用例报告的结果包括最终的相对残差范数、误差 $\\varepsilon$、迭代次数以及指示满足了哪个停止准则的布尔标志。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1: happy path\n        {'Nx': 65, 'Ny': 33, 'A': 1.0, 'tau_r': 1e-8, 'tau_x': 1e-10, 'k_max': 2000},\n        # Case 2: looser tolerances\n        {'Nx': 33, 'Ny': 17, 'A': 1.0, 'tau_r': 1e-4, 'tau_x': 1e-6, 'k_max': 1000},\n        # Case 3: tight tolerances, small grid\n        {'Nx': 9, 'Ny': 9, 'A': 1.0, 'tau_r': 1e-12, 'tau_x': 1e-12, 'k_max': 10000},\n        # Case 4: zero-forcing edge case\n        {'Nx': 33, 'Ny': 33, 'A': 0.0, 'tau_r': 1e-8, 'tau_x': 1e-10, 'k_max': 2000},\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result = solve_one_case(**params)\n        all_results.append(result)\n\n    # Format the final output string exactly as specified.\n    result_strings = []\n    for r in all_results:\n        # [float, float, int, bool, bool]\n        # str(True) -> 'True', which is fine.\n        inner_str = f\"[{r[0]},{r[1]},{r[2]},{r[3]},{r[4]}]\"\n        result_strings.append(inner_str)\n    \n    print(f\"[{','.join(result_strings)}]\")\n\ndef solve_one_case(Nx, Ny, A, tau_r, tau_x, k_max):\n    \"\"\"\n    Solves the Poisson equation for a single set of parameters.\n    \"\"\"\n    # Domain and grid setup\n    Lx, Ly = 1000.0, 500.0\n    dx, dy = Lx / (Nx - 1), Ly / (Ny - 1)\n    \n    x = np.linspace(0, Lx, Nx)\n    y = np.linspace(0, Ly, Ny)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # Manufactured solution and source term\n    kx, ky = 2 * np.pi / Lx, 2 * np.pi / Ly\n    p_exact = A * np.sin(kx * X) * np.sin(ky * Y)\n    f_source = -(kx**2 + ky**2) * p_exact\n\n    # System assembly for interior points\n    # A p = b, where A is the discrete negative Laplacian\n    # and p is the vector of interior pressure values.\n    \n    # Construct RHS vector b\n    b_2d = -f_source[1:-1, 1:-1]\n    \n    # Add boundary contributions\n    b_2d[0, :] += p_exact[0, 1:-1] / dx**2   # Boundary at i=1 (x=0)\n    b_2d[-1, :] += p_exact[-1, 1:-1] / dx**2  # Boundary at i=Nx (x=Lx)\n    b_2d[:, 0] += p_exact[1:-1, 0] / dy**2   # Boundary at j=1 (y=0)\n    b_2d[:, -1] += p_exact[1:-1, -1] / dy**2  # Boundary at j=Ny (y=Ly)\n    \n    b = b_2d.flatten()\n    \n    # Matrix-vector product function for the CG solver\n    # This function computes (discrete negative Laplacian) * p_int_vec\n    def matvec(p_int_vec):\n        p_int_2d = p_int_vec.reshape((Nx-2, Ny-2))\n        p_full = np.zeros((Nx, Ny))\n        p_full[1:-1, 1:-1] = p_int_2d\n\n        lap_p = (p_full[2:, 1:-1] - 2*p_full[1:-1, 1:-1] + p_full[:-2, 1:-1]) / dx**2 + \\\n                (p_full[1:-1, 2:] - 2*p_full[1:-1, 1:-1] + p_full[1:-1, :-2]) / dy**2\n        \n        # We solve A*p=b where A=-nabla^2\n        return -lap_p.flatten()\n\n    # CG solver implementation\n    p_int = np.zeros_like(b)\n    r = b - matvec(p_int)\n    d = r.copy()\n    \n    rs_old = np.dot(r, r)\n    b_norm = np.linalg.norm(b)\n\n    # Handle the A=0 (P_amp=0) case where b is all zeros\n    if b_norm == 0:\n        final_rel_res = 0.0\n        stopped_by_res = True\n        stopped_by_iter = False\n        k = 0\n    else:\n        # Main CG loop\n        stopped_by_res = False\n        stopped_by_iter = False\n        k = 0\n        for k_iter in range(1, k_max + 1):\n            k = k_iter\n            Ap = matvec(d)\n            alpha = rs_old / np.dot(d, Ap)\n            \n            p_new = p_int + alpha * d\n            \n            # Check for iterate change convergence\n            p_diff_norm = np.linalg.norm(p_new - p_int)\n            p_new_norm = np.linalg.norm(p_new)\n            \n            if p_new_norm == 0.0:\n                rel_iter_change = p_diff_norm\n            else:\n                rel_iter_change = p_diff_norm / p_new_norm\n            \n            p_int = p_new\n\n            stopped_by_iter = rel_iter_change  tau_x\n\n            # Update residual with a more stable formula\n            r = r - alpha * Ap\n            rs_new = np.dot(r, r)\n            \n            # Check for residual convergence\n            final_rel_res = np.sqrt(rs_new) / b_norm\n            stopped_by_res = final_rel_res  tau_r\n            \n            if stopped_by_res or stopped_by_iter:\n                break\n                \n            d = r + (rs_new / rs_old) * d\n            rs_old = rs_new\n        else: # loop completed without break (k_max reached)\n             k = k_max\n             final_rel_res = np.sqrt(rs_old) / b_norm\n\n    # Reconstruct full solution\n    p_numerical = np.copy(p_exact) # Start with boundary values\n    p_numerical[1:-1, 1:-1] = p_int.reshape((Nx - 2, Ny - 2))\n\n    # Calculate final discrete L2 error\n    p_exact_interior = p_exact[1:-1, 1:-1]\n    p_numerical_interior = p_numerical[1:-1, 1:-1]\n\n    error_field = p_numerical_interior - p_exact_interior\n    numerator_l2 = np.sqrt(np.sum(error_field**2) * dx * dy)\n    denominator_l2 = np.sqrt(np.sum(p_exact_interior**2) * dx * dy)\n    \n    if denominator_l2 == 0:\n        # Case where exact solution is zero. If numerical is also zero, error is 0.\n        rel_l2_error = 0.0 if numerator_l2 == 0.0 else np.inf\n    else:\n        rel_l2_error = numerator_l2 / denominator_l2\n\n    return [final_rel_res, rel_l2_error, k, stopped_by_res, stopped_by_iter]\n\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "效率在计算科学中至关重要，而利用问题的内在结构可以带来显著的性能提升。本实践将探索一种强大的替代通用迭代方法的技术，即使用快速傅里叶变换（Fast Fourier Transform, FFT）为具有周期性边界的区域构建直接谱方法求解器。您将为全周期和混合边界两种场景实现这种高效技术，从而突显其在相关海洋学背景下的优势 。",
            "id": "3804162",
            "problem": "考虑在不可压缩海洋流的投影法中出现的压力泊松方程的数值解。从不可压缩约束 $\\nabla \\cdot \\boldsymbol{u} = 0$ 和动量方程出发，可以得到一个关于压力的泊松方程 $\\nabla^2 p = f$，其中 $p$ 是压力，$f$ 是从中间速度场导出的已知右端项。在计算海洋学中，通常在切向于大规模无岸流动的方向上施加周期性边界条件，而在其余方向上施加非周期性边界条件。您的任务是在周期性方向上实现基于快速傅里叶变换（FFT）的直接求解器，并在非周期性方向上使用二阶中心有限差分来求解压力泊松方程，并根据精确解量化数值误差。\n\n您必须编写一个完整的程序，该程序在矩形域上构建均匀网格，组装适当的离散算子，并使用以下方法求解泊松方程：\n- 在任何周期性方向上使用基于FFT的对角化。\n- 在任何非周期性方向上，使用二阶中心有限差分和齐次狄利克雷边界条件进行三对角直接求解。\n\n求解器必须处理两种配置：\n1. 一种混合配置，在 $x$ 方向上具有周期性边界条件，在 $y$ 方向上具有齐次狄利克雷边界条件。\n2. 一种全周期配置，在 $x$ 和 $y$ 方向上都具有周期性边界条件。\n\n对于每种配置，程序必须定义一个精确解 $p^{\\mathrm{true}}(x,y)$，并从连续泊松方程 $\\nabla^2 p^{\\mathrm{true}} = f$ 中导出一个一致的右端项 $f(x,y)$。选择的网格和测试函数应是光滑的，并与指定的边界条件兼容。使用具有以下定义的均匀网格：\n- 在任何长度为 $L$ 的周期性方向上，使用 $N$ 个点，坐标为 $x_i = i L / N$，其中 $i = 0, 1, \\dots, N-1$。\n- 在任何长度为 $L$ 的齐次狄利克雷方向上，使用 $N^{\\mathrm{int}}$ 个内部点，间距为 $h = L / (N^{\\mathrm{int}} + 1)$，坐标为 $y_j = j h$，其中 $j = 1, 2, \\dots, N^{\\mathrm{int}}$。\n\n实现以下三个测试用例（这是必需的测试套件）：\n\n- 测试用例 $1$（混合：$x$ 方向周期性，$y$ 方向狄利克雷）：\n  - 域尺寸：$L_x = 1$，$L_y = 1$。\n  - 网格尺寸：$x$ 方向 $N_x = 64$ 个周期点，$y$ 方向 $N_y^{\\mathrm{int}} = 64$ 个内部点。\n  - 精确解：$p^{\\mathrm{true}}(x,y) = \\sin\\!\\left(2\\pi x / L_x\\right) \\sin\\!\\left(\\pi y / L_y\\right)$。\n  - 右端项：$f(x,y) = -\\left[\\left(2\\pi/L_x\\right)^2 + \\left(\\pi/L_y\\right)^2\\right] p^{\\mathrm{true}}(x,y)$。\n\n- 测试用例 $2$（$x$ 和 $y$ 方向全周期）：\n  - 域尺寸：$L_x = 1$，$L_y = 1$。\n  - 网格尺寸：$N_x = 64$，$N_y = 64$ 个周期点。\n  - 精确解：$p^{\\mathrm{true}}(x,y) = \\sin\\!\\left(2\\pi x / L_x\\right) \\sin\\!\\left(2\\pi y / L_y\\right)$。\n  - 右端项：$f(x,y) = -\\left[\\left(2\\pi/L_x\\right)^2 + \\left(2\\pi/L_y\\right)^2\\right] p^{\\mathrm{true}}(x,y)$。\n  - 强制将 $p$ 的零傅里叶模态设置为 $0$ 以避免不确定的平均压力模态；这是合理的，因为指定的 $f$ 的平均值为零。\n\n- 测试用例 $3$（混合：$x$ 方向周期性，$y$ 方向狄利克雷，$x$ 方向零波数的边界情况）：\n  - 域尺寸：$L_x = 1$，$L_y = 1$。\n  - 网格尺寸：$x$ 方向 $N_x = 32$ 个周期点，$y$ 方向 $N_y^{\\mathrm{int}} = 50$ 个内部点。\n  - 精确解：$p^{\\mathrm{true}}(x,y) = \\sin\\!\\left(\\pi y / L_y\\right)$（与 $x$ 无关）。\n  - 右端项：$f(x,y) = -\\left(\\pi/L_y\\right)^2 \\sin\\!\\left(\\pi y / L_y\\right)$。\n\n算法要求：\n- 在混合配置中，在周期性的 $x$ 方向上应用一维FFT，以对那里的离散二阶导数进行对角化，从而为每个傅里叶模态在 $y$ 方向上产生解耦的线性系统。使用直接法精确求解每个生成的三对角系统，并通过逆FFT重构 $p(x,y)$。\n- 在全周期配置中，对右端项应用二维FFT，对所有非零波数对在傅里叶空间中执行拉普拉斯算子的直接谱反演，并在反变换前将压力的零波数设置为 $0$。\n\n对于每个测试用例，计算网格上数值解与精确解之间的最大绝对误差，定义为 $E_{\\infty} = \\max_{i,j} \\left| p_{ij} - p^{\\mathrm{true}}_{ij} \\right|$。本问题中没有物理单位；所有量均为无量纲。测试用例的预期答案是实值浮点数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试用例 $1$、$2$ 和 $3$ 的顺序排列结果（例如，$\\left[ r_1, r_2, r_3 \\right]$）。条目必须是按该顺序为每个测试用例计算的 $E_{\\infty}$ 值。不应从用户读取任何输入，并且除了指定的单行输出外，不应打印任何其他内容。",
            "solution": "该问题被验证为科学上合理、适定且完整。它提出了计算物理学中的一个标准数值任务：在矩形域上使用谱方法和有限差分方法的组合来求解二维泊松方程 $\\nabla^2 p = f$，并针对不同的边界条件进行调整。\n\n解决方案是通过为指定的两种不同配置开发求解器来处理的：一种是混合周期性和狄利克雷边界条件，另一种是全周期性边界条件。\n\n### 混合边界条件（周期性-狄利克雷）的方法\n\n此配置适用于测试用例 $1$ 和 $3$，其中域在 $x$ 方向上是周期性的，在 $y$ 方向上受齐次狄利克雷条件约束，即 $p(x, 0) = 0$ 和 $p(x, L_y) = 0$。控制方程为\n$$\n\\frac{\\partial^2 p}{\\partial x^2} + \\frac{\\partial^2 p}{\\partial y^2} = f(x, y)\n$$\n该问题在网格点 $(x_i, y_j)$ 上进行离散化，其中 $x_i = i L_x / N_x$ for $i=0, \\dots, N_x-1$，以及 $y_j = j h_y$ for $j=1, \\dots, N_y^{\\mathrm{int}}$，单元高度为 $h_y = L_y / (N_y^{\\mathrm{int}} + 1)$。\n\n该策略利用了 $x$ 方向的周期性。对于任何固定的垂直层级 $y_j$，压力 $p(x, y_j)$ 和右端项 $f(x, y_j)$ 都可以用离散傅里叶级数表示：\n$$\np(x_i, y_j) = \\sum_{m=0}^{N_x-1} \\hat{p}(k_m, y_j) e^{i k_m x_i}\n$$\n$$\nf(x_i, y_j) = \\sum_{m=0}^{N_x-1} \\hat{f}(k_m, y_j) e^{i k_m x_i}\n$$\n其中 $\\hat{p}$ 和 $\\hat{f}$ 是傅里叶系数（通过快速傅里叶变换，FFT计算），$k_m = 2\\pi m' / L_x$ 是离散波数，其中 $m'$ 是由FFT算法管理的整数索引（通常从 $-N_x/2$ 到 $N_x/2 - 1$）。傅里叶变换的微分性质指出，$\\partial^2 p / \\partial x^2$ 的变换是 $-k_m^2 \\hat{p}$。\n\n将这些级数代入偏微分方程，实际上是将方程相对于 $x$ 变换到傅里叶空间。这解耦了空间维度，为每个傅里叶模态 $k_m$ 产生了一个独立的 $y$ 方向上的一维边值问题：\n$$\n-k_m^2 \\hat{p}(k_m, y) + \\frac{d^2 \\hat{p}(k_m, y)}{d y^2} = \\hat{f}(k_m, y)\n$$\n现在使用二阶中心有限差分格式对二阶导数在 $y$ 方向上离散化这个常微分方程：\n$$\n\\frac{d^2 \\hat{p}}{dy^2} \\bigg|_{y_j} \\approx \\frac{\\hat{p}(k_m, y_{j+1}) - 2\\hat{p}(k_m, y_j) + \\hat{p}(k_m, y_{j-1})}{h_y^2}\n$$\n齐次狄利克雷边界条件 $p(x,0)=p(x,L_y)=0$ 意味着它们的傅里叶变换也为零，即 $\\hat{p}(k_m, 0) = 0$ 和 $\\hat{p}(k_m, L_y) = 0$。这为离散系统提供了边界条件。\n\n对于每个波数 $k_m$，我们得到一个关于傅里叶系数向量 $\\mathbf{\\hat{p}}_m = [\\hat{p}(k_m, y_1), \\dots, \\hat{p}(k_m, y_{N_y^{\\mathrm{int}}})]^T$ 的线性方程组：\n$$\n\\frac{1}{h_y^2} \\left( \\hat{p}_{m,j-1} - 2\\hat{p}_{m,j} + \\hat{p}_{m,j+1} \\right) - k_m^2 \\hat{p}_{m,j} = \\hat{f}_{m,j}\n$$\n其中 $\\hat{p}_{m,j} \\equiv \\hat{p}(k_m, y_j)$ 且边界项 $\\hat{p}_{m,0}$ 和 $\\hat{p}_{m,N_y^{\\mathrm{int}}+1}$ 为零。这对每个模态 $m$ 构成了一个大小为 $N_y^{\\mathrm{int}} \\times N_y^{\\mathrm{int}}$ 的对称三对角系统，可以使用直接三对角求解器高效地求解。\n\n完整的算法是：\n1.  对源项 $f(x_i, y_j)$ 沿 $x$ 轴（对每个 $j$）进行一维FFT，以获得 $\\hat{f}(k_m, y_j)$。\n2.  对每个傅里叶模态 $k_m$：\n    a.  构造代表算子 $(-k_m^2 + \\frac{d^2}{dy^2})$ 的三对角矩阵。\n    b.  求解三对角系统以得到 $\\hat{p}(k_m, y_j)$。\n3.  将所有模态的解组合成一个二维数组 $\\hat{p}(k_m, y_j)$。\n4.  对 $\\hat{p}(k_m, y_j)$ 沿 $k_m$ 轴（对每个 $j$）进行一维逆FFT，以恢复压力场 $p(x_i, y_j)$。\n\n### 全周期性边界条件的方法\n\n此配置适用于测试用例 $2$，其中边界条件在 $x$ 和 $y$ 方向上都是周期性的。离散化在 $x$ 方向使用 $N_x$ 个点，在 $y$ 方向使用 $N_y$ 个点。\n\n鉴于两个方向都是周期性的，二维FFT是使拉普拉斯算子对角化的自然工具。压力和源项由二维离散傅里叶级数表示：\n$$\np(x_i, y_j) = \\sum_{m=0}^{N_x-1} \\sum_{l=0}^{N_y-1} \\hat{p}(k_m, k_l) e^{i k_m x_i} e^{i k_l y_j}\n$$\n将二维FFT应用于泊松方程 $\\nabla^2 p = f$，会将其转换为谱域中的一个简单代数方程：\n$$\n(-k_m^2 - k_l^2) \\hat{p}(k_m, k_l) = \\hat{f}(k_m, k_l)\n$$\n其中 $k_m$ 和 $k_l$ 分别是 $x$ 和 $y$ 方向的波数。压力的傅里叶系数的解可以通过直接相除获得：\n$$\n\\hat{p}(k_m, k_l) = \\frac{\\hat{f}(k_m, k_l)}{-k_m^2 - k_l^2}\n$$\n对于零波数模态 $(k_m, k_l) = (0,0)$，分母为零，会出现奇异点。这对应于场的平均值。为了使解存在，源项必须具有零平均值，即 $\\int f \\,dA = 0$，这意味着其零波数傅里叶系数 $\\hat{f}(0,0)$ 必须为零。问题陈述保证了所选测试用例满足此条件。相应的压力模态 $\\hat{p}(0,0)$（代表平均压力）是不确定的。按照惯例，我们通过将平均压力设置为零来解决此不确定性：$\\hat{p}(0,0) = 0$。\n\n完整的算法是：\n1.  对源项 $f(x_i, y_j)$ 进行二维FFT，以得到 $\\hat{f}(k_m, k_l)$。\n2.  对于所有非零波数对 $(k_m, k_l)$，通过将 $\\hat{f}(k_m, k_l)$ 除以拉普拉斯算子的谱表示 $-(k_m^2 + k_l^2)$ 来计算 $\\hat{p}(k_m, k_l)$。\n3.  将零波数模态设置为 $\\hat{p}(0,0) = 0$。\n4.  对 $\\hat{p}(k_m, k_l)$ 进行二维逆FFT，以恢复压力场 $p(x_i, y_j)$。\n\n### 误差量化\n\n对于每个测试用例，问题提供了一个与边界条件一致的精确解析解 $p^{\\mathrm{true}}(x,y)$，并从中导出了源项 $f(x,y)$。关键在于，所选的正弦函数既是连续拉普拉斯算子的本征函数，也是离散算子（基于FFT的二阶导数和中心有限差分二阶导数）的本征函数。因此，数值方法应该能够精确求解离散系统，并且得到的数值解 $p_{ij}$ 应该在机器浮点精度范围内与在网格点上计算的精确解 $p^{\\mathrm{true}}_{ij}$ 相匹配。计算最大绝对误差 $E_{\\infty} = \\max_{i,j} |p_{ij} - p^{\\mathrm{true}}_{ij}|$ 来验证这一预期。任何与零的显著偏差都将表明实现中存在错误。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve_mixed_bc(Lx, Ly, Nx, Ny_int, p_true_func, f_func):\n    \"\"\"\n    Solves the 2D Poisson equation with periodic BC in x and Dirichlet BC in y.\n    \n    Uses FFT in the x-direction and a tridiagonal solve in the y-direction.\n    \"\"\"\n    # 1. Create grids\n    hx = Lx / Nx\n    x = hx * np.arange(Nx)\n    hy = Ly / (Ny_int + 1)\n    y = hy * np.arange(1, Ny_int + 1)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # 2. Evaluate functions on the grid\n    f_grid = f_func(X, Y)\n    p_true_grid = p_true_func(X, Y)\n\n    # 3. FFT of the source term f along the periodic x-axis\n    f_hat = np.fft.fft(f_grid, axis=0)\n    \n    # 4. Get discrete wavenumbers in x\n    kx = 2 * np.pi * np.fft.fftfreq(Nx, d=hx)\n\n    # 5. Solve tridiagonal systems for each Fourier mode\n    p_hat = np.zeros_like(f_hat, dtype=np.complex128)\n    \n    # The tridiagonal matrix is constant except for the main diagonal.\n    # It has shape (Ny_int, Ny_int).\n    # A_m @ p_hat_col = f_hat_col\n    # The matrix has (1/hy^2) on the off-diagonals.\n    \n    # For scipy.linalg.solve_banded, we prepare the banded matrix `ab`\n    # ab has shape (3, Ny_int) for l=1, u=1.\n    # ab[0, :] = super-diagonal\n    # ab[1, :] = main-diagonal\n    # ab[2, :] = sub-diagonal\n    ab = np.zeros((3, Ny_int))\n    ab[0, 1:] = 1.0 / hy**2\n    ab[2, :-1] = 1.0 / hy**2\n\n    for m in range(Nx):\n        # Construct main diagonal for this wavenumber kx[m]\n        main_diag_val = -2.0 / hy**2 - kx[m]**2\n        ab[1, :] = main_diag_val\n        \n        # Right-hand side for this mode\n        b = f_hat[m, :]\n        \n        # Solve the tridiagonal system\n        p_hat[m, :] = solve_banded((1, 1), ab, b)\n        \n    # 6. Inverse FFT to get the numerical solution\n    p_numeric = np.fft.ifft(p_hat, axis=0)\n\n    # The solution should be real\n    p_numeric_real = np.real(p_numeric)\n    \n    # 7. Calculate max absolute error\n    error = np.max(np.abs(p_numeric_real - p_true_grid))\n    return error\n\ndef solve_periodic_bc(Lx, Ly, Nx, Ny, p_true_func, f_func):\n    \"\"\"\n    Solves the 2D Poisson equation with periodic BCs in x and y.\n    \n    Uses a 2D FFT-based spectral method.\n    \"\"\"\n    # 1. Create grids\n    hx = Lx / Nx\n    x = hx * np.arange(Nx)\n    hy = Ly / Ny\n    y = hy * np.arange(Ny)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # 2. Evaluate functions on grid\n    f_grid = f_func(X, Y)\n    p_true_grid = p_true_func(X, Y)\n\n    # 3. 2D FFT of the source term\n    f_hat = np.fft.fft2(f_grid)\n\n    # 4. Get discrete wavenumbers\n    kx_vec = 2 * np.pi * np.fft.fftfreq(Nx, d=hx)\n    ky_vec = 2 * np.pi * np.fft.fftfreq(Ny, d=hy)\n    Kx, Ky = np.meshgrid(kx_vec, ky_vec, indexing='ij')\n\n    # 5. Fourier representation of the Laplacian\n    lap_hat = -(Kx**2 + Ky**2)\n\n    # 6. Solve for p_hat in Fourier space\n    # Handle the (0,0) mode singularity by dividing only where lap_hat is non-zero.\n    p_hat = np.divide(f_hat, lap_hat, out=np.zeros_like(f_hat), where=(lap_hat != 0))\n    \n    # The problem specifies setting the zero mode of p to 0. This is implicitly\n    # handled by the `out=np.zeros_like(f_hat)` argument to np.divide, since\n    # lap_hat[0,0] is zero, so the result p_hat[0,0] remains 0.\n    # An explicit set for clarity:\n    p_hat[0, 0] = 0.0\n\n    # 7. Inverse 2D FFT to get the numerical solution\n    p_numeric = np.fft.ifft2(p_hat)\n    \n    # The solution should be real\n    p_numeric_real = np.real(p_numeric)\n\n    # 8. Calculate max absolute error\n    error = np.max(np.abs(p_numeric_real - p_true_grid))\n    return error\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    \n    results = []\n\n    # Test Case 1: Mixed BC (periodic-x, dirichlet-y)\n    Lx1, Ly1 = 1.0, 1.0\n    Nx1, Ny_int1 = 64, 64\n    k_x1 = 2 * np.pi / Lx1\n    k_y1 = np.pi / Ly1\n    p_true1 = lambda x, y: np.sin(k_x1 * x) * np.sin(k_y1 * y)\n    f1 = lambda x, y: -(k_x1**2 + k_y1**2) * p_true1(x, y)\n    error1 = solve_mixed_bc(Lx1, Ly1, Nx1, Ny_int1, p_true1, f1)\n    results.append(error1)\n\n    # Test Case 2: Fully Periodic BC\n    Lx2, Ly2 = 1.0, 1.0\n    Nx2, Ny2 = 64, 64\n    k_x2 = 2 * np.pi / Lx2\n    k_y2 = 2 * np.pi / Ly2\n    p_true2 = lambda x, y: np.sin(k_x2 * x) * np.sin(k_y2 * y)\n    f2 = lambda x, y: -(k_x2**2 + k_y2**2) * p_true2(x, y)\n    error2 = solve_periodic_bc(Lx2, Ly2, Nx2, Ny2, p_true2, f2)\n    results.append(error2)\n\n    # Test Case 3: Mixed BC, edge case (zero wavenumber in x)\n    Lx3, Ly3 = 1.0, 1.0\n    Nx3, Ny_int3 = 32, 50\n    k_y3 = np.pi / Ly3\n    p_true3 = lambda x, y: np.sin(k_y3 * y)\n    f3 = lambda x, y: -(k_y3**2) * np.sin(k_y3 * y)\n    error3 = solve_mixed_bc(Lx3, Ly3, Nx3, Ny_int3, p_true3, f3)\n    results.append(error3)\n\n    # Format the results for printing\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}