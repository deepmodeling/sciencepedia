{
    "hands_on_practices": [
        {
            "introduction": "我们首先分析离散拉普拉斯算子本身的基本性质。在求解方程 $A \\mathbf{p} = \\mathbf{b}$ 之前，理解矩阵 $A$ 至关重要。这项分析练习  将引导你使用离散傅里叶分析来确定该算子的特征值，并最终找到其谱半径——这是一个控制许多迭代求解器稳定性和收敛速度的关键参数。",
            "id": "3804161",
            "problem": "考虑一个尺寸为 $L_{x} \\times L_{y}$ 的水平周期性矩形域中的正压不可压缩海洋模型。水平速度场 $\\boldsymbol{u}(x,y,t)$ 和压力 $p(x,y,t)$ 满足不可压缩条件 $\\nabla \\cdot \\boldsymbol{u} = 0$ 和一个动量方程，该方程的投影步骤通过求解一个压力泊松问题来强制执行此约束。在投影法中，压力 $p$ 是通过在每个时间步求解泊松方程得到的\n$$\n\\nabla^{2} p = g(x,y),\n$$\n其中 $g$ 源于中间速度的散度以及其他源项。为了在周期性边界条件下使问题适定，$p$ 的定义允许相差一个相加常数；因此，我们将 $p$ 限制在零均值子空间中。\n\n给定一个具有 $N_{x} \\times N_{y}$ 个点的结构化笛卡尔网格，其在 $x$ 和 $y$ 方向上的均匀间距分别为 $h_{x} = L_{x}/N_{x}$ 和 $h_{y} = L_{y}/N_{y}$，并且在这两个方向上均采用周期性边界条件。假设 $N_{x}$ 和 $N_{y}$ 是正偶数。离散负拉普拉斯算子，记为 $\\mathcal{A}_{h}$，由作用于网格中心压力值 $p_{i,j}$ 的二阶中心差分定义：\n$$\n\\mathcal{A}_{h} p_{i,j} = -\\left[\\frac{p_{i+1,j} - 2 p_{i,j} + p_{i-1,j}}{h_{x}^{2}} + \\frac{p_{i,j+1} - 2 p_{i,j} + p_{i,j-1}}{h_{y}^{2}}\\right],\n$$\n索引是周期性的。\n\n从不可压缩约束和投影法的基本原理出发，并利用周期性网格上的离散傅里叶分析，推导 $\\mathcal{A}_{h}$ 的离散傅里叶符号。然后，在限制于零均值子空间的条件下，确定 $\\mathcal{A}_{h}$ 的精确谱半径（即最大特征值），并将其表示为仅包含 $h_{x}$ 和 $h_{y}$ 的解析表达式。清楚地说明你对容许的离散傅里叶模态集合所作的任何假设。\n\n将你的最终答案表示为仅包含 $h_{x}$ 和 $h_{y}$ 的单个闭式解析表达式。单位：长度的平方的倒数。最终表达式中不要包含单位。不需要进行数值计算或四舍五入。",
            "solution": "### 步骤 1：提取已知条件\n问题提供了以下信息：\n- 一个尺寸为 $L_x \\times L_y$ 的水平周期性矩形域上的正压不可压缩海洋模型。\n- 待求解的压力泊松方程为 $\\nabla^{2} p = g(x,y)$。\n- 通过将压力 $p$ 限制在零均值子空间，问题在周期性边界条件下是适定的。\n- 一个具有 $N_{x} \\times N_{y}$ 个点的结构化笛卡尔网格，其中 $N_x$ 和 $N_y$ 是正偶数。\n- 均匀网格间距 $h_{x} = L_{x}/N_{x}$ 和 $h_{y} = L_{y}/N_{y}$。\n- $x$ 和 $y$ 方向上均采用周期性边界条件。\n- 离散负拉普拉斯算子 $\\mathcal{A}_{h}$ 定义为：\n$$\n\\mathcal{A}_{h} p_{i,j} = -\\left[\\frac{p_{i+1,j} - 2 p_{i,j} + p_{i-1,j}}{h_{x}^{2}} + \\frac{p_{i,j+1} - 2 p_{i,j} + p_{i,j-1}}{h_{y}^{2}}\\right]\n$$\n- 索引是周期性的。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据既定准则对问题陈述进行严格评估。\n- **科学基础**：该问题基于求解不可压缩Navier-Stokes方程的投影法（或其海洋模型的简化版本），这是计算流体动力学中的一个标准和基本技术。压力泊松方程是该方法的核心组成部分。在周期性笛卡尔网格上对拉普拉斯算子使用二阶中心差分格式是有限差分法的教科书式示例。通过离散傅里叶级数进行分析是处理周期域上线性常系数算子的典型方法。因此，该问题在科学上是合理的，植根于数值分析和计算物理的既定原则。\n- **适定性**：该问题要求推导一个明确定义的线性算子 $\\mathcal{A}_h$ 的离散傅里叶符号和谱半径。域、边界条件和算子都已明确指定。对零均值子空间的约束正确地处理了周期性边界条件下拉普拉斯算子的零空间，确保了问题的适定性。谱半径存在唯一的解析表达式。\n- **客观性**：问题以精确、客观的数学语言陈述。没有主观因素或观点。\n- **完整性和一致性**：提供了所有必要的信息。算子的定义、网格参数（$N_x, N_y, h_x, h_y$）和边界条件都已明确给出。$N_x$ 和 $N_y$为偶数的条件与确定奈奎斯特频率相关。已知条件是自洽的。\n\n### 步骤 3：结论与行动\n问题是有效的。这是数值分析应用于计算流体动力学领域的一个定义明确、科学合理的问题。我将继续提供完整解答。\n\n### 解答推导\n问题要求推导双周期网格上离散负拉普拉斯算子 $\\mathcal{A}_{h}$ 的离散傅里叶符号和谱半径。\n\n分析是使用离散傅里叶级数进行的。周期性网格上线性常系数算子的特征函数是离散傅里叶模态。离散网格 $x_i = i h_x$, $y_j = j h_y$ 上的一个通用傅里叶模态可以写成：\n$$\np_{i,j} = \\exp(I (k_x x_i + k_y y_j)) = \\exp(I (k_x i h_x + k_y j h_y))\n$$\n其中 $I = \\sqrt{-1}$ 是虚数单位，$(k_x, k_y)$ 是波数。由于域 ($L_x, L_y$) 和离散网格 ($N_x, N_y$) 的周期性，波数是量子化的：\n$$\nk_x = \\frac{2\\pi m}{L_x} = \\frac{2\\pi m}{N_x h_x}, \\quad k_y = \\frac{2\\pi n}{L_y} = \\frac{2\\pi n}{N_y h_y}\n$$\n这里，$m$ 和 $n$ 是整数模态指数。通过取，例如，$m \\in \\{0, 1, \\dots, N_x-1\\}$ 和 $n \\in \\{0, 1, \\dots, N_y-1\\}$，可以得到一个完备正交的模态集。\n\n$\\mathcal{A}_h$ 的离散傅里叶符号，记为 $\\hat{\\mathcal{A}}_h(k_x, k_y)$，是对应于特征函数 $\\exp(I (k_x x_i + k_y y_j))$ 的特征值。为了找到它，我们将算子 $\\mathcal{A}_h$ 应用于此模态。\n$$\n\\mathcal{A}_{h} p_{i,j} = \\hat{\\mathcal{A}}_h(k_x, k_y) p_{i,j}\n$$\n让我们分别计算算子各部分的作用。对于 $x$-导数部分：\n$$\n-\\frac{p_{i+1,j} - 2 p_{i,j} + p_{i-1,j}}{h_{x}^{2}} = -\\frac{\\exp(I(k_x(i+1)h_x + k_yjh_y)) - 2\\exp(I(k_xih_x + k_yjh_y)) + \\exp(I(k_x(i-1)h_x + k_yjh_y))}{h_{x}^{2}}\n$$\n提取公因子 $p_{i,j} = \\exp(I(k_x i h_x + k_y j h_y))$:\n$$\n= -\\frac{\\exp(I k_x h_x) - 2 + \\exp(-I k_x h_x)}{h_{x}^{2}} p_{i,j}\n$$\n使用欧拉公式 $2 \\cos(\\theta) = \\exp(I\\theta) + \\exp(-I\\theta)$:\n$$\n= -\\frac{2 \\cos(k_x h_x) - 2}{h_{x}^{2}} p_{i,j} = \\frac{2(1 - \\cos(k_x h_x))}{h_{x}^{2}} p_{i,j}\n$$\n使用半角恒等式 $1 - \\cos(\\theta) = 2 \\sin^2(\\theta/2)$:\n$$\n= \\frac{2(2 \\sin^2(k_x h_x/2))}{h_{x}^{2}} p_{i,j} = \\frac{4 \\sin^2(k_x h_x/2)}{h_{x}^{2}} p_{i,j}\n$$\n同理， $y$-导数部分的作用是：\n$$\n-\\frac{p_{i,j+1} - 2 p_{i,j} + p_{i,j-1}}{h_{y}^{2}} = \\frac{4 \\sin^2(k_y h_y/2)}{h_{y}^{2}} p_{i,j}\n$$\n结合两部分，完整算子 $\\mathcal{A}_h$ 对特征模态的作用是：\n$$\n\\mathcal{A}_{h} p_{i,j} = \\left[ \\frac{4}{h_{x}^{2}} \\sin^2\\left(\\frac{k_x h_x}{2}\\right) + \\frac{4}{h_{y}^{2}} \\sin^2\\left(\\frac{k_y h_y}{2}\\right) \\right] p_{i,j}\n$$\n因此，离散傅里叶符号（以及模态 $(k_x, k_y)$ 的特征值）为：\n$$\n\\hat{\\mathcal{A}}_h(k_x, k_y) = \\frac{4}{h_{x}^{2}} \\sin^2\\left(\\frac{k_x h_x}{2}\\right) + \\frac{4}{h_{y}^{2}} \\sin^2\\left(\\frac{k_y h_y}{2}\\right)\n$$\n代入离散波数 $k_x$ 和 $k_y$ 的表达式：\n$$\n\\frac{k_x h_x}{2} = \\frac{1}{2} \\left(\\frac{2\\pi m}{N_x h_x}\\right) h_x = \\frac{\\pi m}{N_x}\n$$\n$$\n\\frac{k_y h_y}{2} = \\frac{1}{2} \\left(\\frac{2\\pi n}{N_y h_y}\\right) h_y = \\frac{\\pi n}{N_y}\n$$\n由 $(m,n)$ 索引的离散特征值集合是：\n$$\n\\lambda_{m,n} = \\frac{4}{h_{x}^{2}} \\sin^2\\left(\\frac{\\pi m}{N_x}\\right) + \\frac{4}{h_{y}^{2}} \\sin^2\\left(\\frac{\\pi n}{N_y}\\right)\n$$\n问题陈述我们在零均值子空间上操作，这意味着我们排除了对应于 $(m,n)=(0,0)$ 的常数模态。对于此模态，$\\lambda_{0,0}=0$。对于所有其他模态，$\\lambda_{m,n} > 0$，因为 $m$ 或 $n$ 中至少有一个不为零（在定义唯一模态的主值范围内），所以至少有一个正弦项不为零。算子 $\\mathcal{A}_h$ 在该子空间上是正定的。\n\n谱半径 $\\rho(\\mathcal{A}_h)$ 是最大的特征值。我们需要在所有容许的整数对 $(m, n)$（不包括 $(0,0)$）上找到 $\\lambda_{m,n}$ 的最大值。$\\lambda_{m,n}$ 的表达式是两个非负项的和。当每一项都取最大值时，总和达到最大值。\n\n我们需要最大化 $\\sin^2(\\pi m / N_x)$ 和 $\\sin^2(\\pi n / N_y)$。函数 $\\sin^2(\\theta)$ 的最大值为 $1$，这发生在 $\\theta = \\frac{\\pi}{2} + q\\pi$（其中 $q$ 为任意整数）时。\n\n对于 $x$ 方向，我们希望 $\\frac{\\pi m}{N_x} = \\frac{\\pi}{2}$，这意味着 $m = \\frac{N_x}{2}$。由于已知 $N_x$ 是偶数，所以 $m=N_x/2$ 是一个整数。这个模态指数对应于网格在 $x$ 方向上能表示的最高频率（奈奎斯特频率）。容许的模态指数 $m$ 的集合必须包含这个值（或一个等效值，如 $m=-N_x/2$，这取决于约定，此时 $\\sin^2(-\\pi/2)=1$）。例如，如果 $m \\in \\{0, 1, \\dots, N_x-1\\}$，$m=N_x/2$ 是一个有效的索引。因此，$\\sin^2(\\pi m/N_x)$ 的最大值确实是 $1$。\n\n类似地，对于 $y$ 方向，$\\sin^2(\\pi n/N_y)$ 的最大值是 $1$，在 $n = N_y/2$ 时达到。\n\n最大特征值对应于模态 $(m, n) = (N_x/2, N_y/2)$。这代表了网格能分辨的最高频率棋盘格模式。将这些使表达式最大化的索引代入特征值表达式，得到谱半径：\n$$\n\\rho(\\mathcal{A}_h) = \\lambda_{N_x/2, N_y/2} = \\frac{4}{h_{x}^{2}} \\sin^2\\left(\\frac{\\pi (N_x/2)}{N_x}\\right) + \\frac{4}{h_{y}^{2}} \\sin^2\\left(\\frac{\\pi (N_y/2)}{N_y}\\right)\n$$\n$$\n\\rho(\\mathcal{A}_h) = \\frac{4}{h_{x}^{2}} \\sin^2\\left(\\frac{\\pi}{2}\\right) + \\frac{4}{h_{y}^{2}} \\sin^2\\left(\\frac{\\pi}{2}\\right)\n$$\n$$\n\\rho(\\mathcal{A}_h) = \\frac{4}{h_{x}^{2}} (1)^2 + \\frac{4}{h_{y}^{2}} (1)^2\n$$\n$$\n\\rho(\\mathcal{A}_h) = \\frac{4}{h_{x}^{2}} + \\frac{4}{h_{y}^{2}}\n$$\n这就是离散算子 $\\mathcal{A}_h$ 的精确谱半径，用 $h_x$ 和 $h_y$ 表示。",
            "answer": "$$\n\\boxed{\\frac{4}{h_{x}^{2}} + \\frac{4}{h_{y}^{2}}}\n$$"
        },
        {
            "introduction": "在对算子有了理论理解之后，下一步是构建一个可用的求解器。这项动手编码练习  将指导你为一个带狄利克雷边界的区域实现一个标准的二阶有限差分求解器。你将应用“制造解方法”（Method of Manufactured Solutions, MMS）——这是科学计算的基石之一——来严格验证代码的正确性，并确认其理论精度阶。",
            "id": "3804158",
            "problem": "考虑不可压缩海洋模型中出现的压力泊松方程，其形式为单位正方形域 $\\Omega = (0,1)\\times(0,1)$ 上的标量偏微分方程 (PDE) $\\nabla^2 u = f$，并带有狄利克雷边界条件 $u|_{\\partial\\Omega} = g$。为了使用制造解法 (MMS) 验证数值求解器，我们假设一个光滑的制造解 $u^\\star(x,y)$，并通过 $u^\\star$ 的精确拉普拉斯算子来定义强迫项 $f$，同时将 $u^\\star$ 在 $\\partial\\Omega$ 上的限制规定为边界数据 $g$。所有量均为无量纲。\n\n令制造解为\n$$\nu^\\star(x,y) = \\sin(3\\pi x)\\cos(2\\pi y) + x^3 y - e^{x+y}.\n$$\n将 $f(x,y)$ 定义为 $f(x,y) = \\nabla^2 u^\\star(x,y)$，并将 $g$ 定义为 $g(x,y) = u^\\star(x,y)$（对于 $(x,y)\\in \\partial\\Omega$）。目标是使用矩形网格上的二阶中心有限差分离散格式，数值求解在 $\\partial\\Omega$ 上满足 $u=g$ 的方程 $\\nabla^2 u = f$，并在网格加密的情况下量化离散误差和观测到的精度阶。\n\n仅从以下基本原理出发：\n- 不可压缩流的质量守恒在投影法求解器中导出了压力泊松方程，这在数学上可归结为在具有适当边界条件的域上求解 $\\nabla^2 u = f$。\n- 二阶导数的中心二阶有限差分近似源于网格点周围的泰勒展开，并产生一个由均匀网格上各方向二阶差分组合而成的离散拉普拉斯算子。\n\n在程序中需要实现的任务：\n1. 使用均匀矩形网格对 $\\Omega$ 上的 $\\nabla^2 u = f$ 进行离散化。该网格在 $x$ 方向有 $N_x$ 个点，在 $y$ 方向有 $N_y$ 个点，间距分别为 $h_x = 1/(N_x-1)$ 和 $h_y = 1/(N_y-1)$，并采用空间二阶的五点格式。通过代入来自 $u^\\star$ 的边界值来强加狄利克雷边界条件，并将相应的贡献项移至内部节点线性系统的右端项中。\n2. 求解得到的线性系统以获得内部网格值，并通过代入来自 $u^\\star$ 的边界值来重构所有节点上的网格函数 $u_h$。\n3. 仅在内部节点集上计算离散内部误差 $e_h = u_h - u^\\star$。根据 $e_h$ 计算两种范数：\n   - 离散 $L^2$-范数，定义为 $\\|e_h\\|_{L^2(\\Omega)} \\approx \\left(\\sum_{i=1}^{N_x-2}\\sum_{j=1}^{N_y-2} |e_{i,j}|^2 h_x h_y\\right)^{1/2}$。\n   - 离散 $L^\\infty$-范数，定义为 $\\|e_h\\|_{L^\\infty(\\Omega)} = \\max_{1\\le i\\le N_x-2,\\,1\\le j\\le N_y-2} |e_{i,j}|$。\n4. 对于每个方向上加密2倍的网格，使用标准公式 $p = \\log(e_{h}/e_{h/2})/\\log(2)$ 来估计观测到的精度阶 $p$。其中 $e_h$ 表示由 $(h_x,h_y)$ 表征的分辨率下的误差范数，$e_{h/2}$ 表示由 $(h_x/2,h_y/2)$ 表征的加密分辨率下的误差范数。在 $h_x\\neq h_y$ 的各向异性情况下，但两个方向都加密2倍时，使用相同的公式，前提是理解为两个方向的加密因子均为2，并且误差范数 $e_h$ 是在相应网格的内部节点上计算的。\n5. 在最密的各向同性网格上，计算离散线性系统残差的相对 $\\ell^2$-范数 $\\|r\\|_2/\\|b\\|_2$。其中 $r = A u - b$ 是组装的线性系统的内部节点残差，$A$ 是离散拉普拉斯算子，$b$ 是调整后的右端项。该量是无量纲的。\n\n测试套件规范：\n- 各向同性加密序列：$(N_x,N_y)\\in\\{(17,17),(33,33),(65,65)\\}$。仅使用最后两个层级计算观测阶，即使用来自 $(33,33)$ 和 $(65,65)$ 的误差来生成 $p_{L^2}^{\\mathrm{iso}}$ 和 $p_{L^\\infty}^{\\mathrm{iso}}$。\n- 各向异性加密对：粗网格 $(N_x,N_y)=(33,49)$ 和细网格 $(N_x,N_y)=(65,97)$。计算这两个层级之间的 $p_{L^2}^{\\mathrm{aniso}}$ 和 $p_{L^\\infty}^{\\mathrm{aniso}}$。\n- 最密各向同性网格上的残差：在 $(N_x,N_y)=(65,65)$ 上计算相对残差 $\\|r\\|_2/\\|b\\|_2$。\n\n所有计算都是无量纲的；不涉及物理单位。\n\n最终输出规范：\n您的程序必须生成单行输出，其中包含一个 Python 风格的列表，按以下顺序包含五个浮点数：\n$[p_{L^2}^{\\mathrm{iso}}, p_{L^\\infty}^{\\mathrm{iso}}, p_{L^2}^{\\mathrm{aniso}}, p_{L^\\infty}^{\\mathrm{aniso}}, \\|r\\|_2/\\|b\\|_2]$。\n每个值必须四舍五入到小数点后恰好六位。该行不得包含任何其他文本。\n\n您的实现必须是完全自包含且可运行的。不允许用户输入。所有角度和量都是无量纲的；不需要也不接受任何单位。正确性标准是指定测试套件的五个输出的数值。预期答案是实数，并且对于此光滑制造解，应在两种范数下都反映出二阶收敛。最终输出必须按规定将所有提供的测试用例的结果汇总到单行中。",
            "solution": "所提出的问题是一个标准的验证练习，用于验证在单位正方形域 $\\Omega = (0,1)\\times(0,1)$ 上求解带狄利克雷边界条件 $u|_{\\partial\\Omega} = g$ 的二维泊松方程 $\\nabla^2 u = f$ 的数值求解器。此问题采用了制造解法（MMS），这是一种用于验证数值代码正确性和准确性的严谨技术。该问题在科学上是合理的、自包含的且适定的。我们接下来给出一个完整的解答。\n\n### 1. 解析公式\n\nMMS 的核心是为解假设一个解析形式，称为制造解 $u^\\star(x,y)$，然后推导出相应的问题数据（强迫项 $f$ 和边界条件 $g$）。\n\n给定的制造解是：\n$$\nu^\\star(x,y) = \\sin(3\\pi x)\\cos(2\\pi y) + x^3 y - e^{x+y}\n$$\n强迫项 $f(x,y)$ 定义为 $u^\\star(x,y)$ 的拉普拉斯算子：\n$$\nf(x,y) = \\nabla^2 u^\\star(x,y) = \\frac{\\partial^2 u^\\star}{\\partial x^2} + \\frac{\\partial^2 u^\\star}{\\partial y^2}\n$$\n我们计算 $u^\\star$ 的二阶偏导数：\n首先，对 $x$ 求导：\n$$\n\\frac{\\partial u^\\star}{\\partial x} = 3\\pi \\cos(3\\pi x)\\cos(2\\pi y) + 3x^2 y - e^{x+y}\n$$\n$$\n\\frac{\\partial^2 u^\\star}{\\partial x^2} = -(3\\pi)^2 \\sin(3\\pi x)\\cos(2\\pi y) + 6xy - e^{x+y} = -9\\pi^2 \\sin(3\\pi x)\\cos(2\\pi y) + 6xy - e^{x+y}\n$$\n接下来，对 $y$ 求导：\n$$\n\\frac{\\partial u^\\star}{\\partial y} = -2\\pi \\sin(3\\pi x)\\sin(2\\pi y) + x^3 - e^{x+y}\n$$\n$$\n\\frac{\\partial^2 u^\\star}{\\partial y^2} = -(2\\pi)^2 \\sin(3\\pi x)\\cos(2\\pi y) - e^{x+y} = -4\\pi^2 \\sin(3\\pi x)\\cos(2\\pi y) - e^{x+y}\n$$\n将这些导数相加，得到强迫函数 $f(x,y)$：\n$$\nf(x,y) = (-9\\pi^2 - 4\\pi^2)\\sin(3\\pi x)\\cos(2\\pi y) + 6xy - 2e^{x+y}\n$$\n$$\nf(x,y) = -13\\pi^2\\sin(3\\pi x)\\cos(2\\pi y) + 6xy - 2e^{x+y}\n$$\n狄利克雷边界数据 $g(x,y)$ 就是 $u^\\star(x,y)$ 在单位正方形边界 $\\partial\\Omega$ 上的值。\n\n### 2. 数值离散\n\n域 $\\Omega = (0,1)\\times(0,1)$ 使用均匀矩形网格进行离散化。网格点用 $(x_i, y_j)$ 表示，其中 $x_i = i h_x$（对于 $i \\in \\{0, 1, ..., N_x-1\\}$）和 $y_j = j h_y$（对于 $j \\in \\{0, 1, ..., N_y-1\\}$）。网格间距为 $h_x = 1/(N_x-1)$ 和 $h_y = 1/(N_y-1)$。\n\n在内部网格点 $(x_i, y_j)$ 处的拉普拉斯算子 $\\nabla^2 u$ 使用二阶中心有限差分公式进行近似，这得到了著名的五点格式：\n$$\n\\nabla^2 u \\Big|_{(x_i, y_j)} \\approx \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2}\n$$\n其中 $u_{i,j}$ 表示 $u(x_i, y_j)$ 的数值近似。将此式与源项 $f(x_i, y_j) = f_{i,j}$ 相等，得到每个内部节点（$1 \\le i \\le N_x-2$, $1 \\le j \\le N_y-2$）处的离散方程：\n$$\n\\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2} = f_{i,j}\n$$\n\n### 3. 线性系统构建\n\n所有 $(N_x-2) \\times (N_y-2)$ 个内部节点的线性代数方程组构成一个形如 $A\\mathbf{u}_{int} = \\mathbf{b}$ 的大型线性系统。\n\n$\\mathbf{u}_{int}$ 是内部网格点上未知值 $u_{i,j}$ 的向量，它被展平成一个一维数组。使用行主序，内部点 $(i,j)$ 的索引 $k$ 为 $k = (i-1)(N_y-2) + (j-1)$。\n\n矩阵 $A$ 是一个表示离散拉普拉斯算子的稀疏矩阵。它具有块三对角结构。一种构建 $A$ 的高效方法是使用一维二阶导数矩阵的克罗内克和。令 $D_{xx}$ 为 $x$ 方向二阶导数的 $(N_x-2) \\times (N_x-2)$ 矩阵，$D_{yy}$ 为 $y$ 方向二阶导数的 $(N_y-2) \\times (N_y-2)$ 矩阵。那么，对于行主序的未知数，$A$ 由以下公式给出：\n$$\nA = D_{xx} \\otimes I_y + I_x \\otimes D_{yy}\n$$\n其中 $I_x$ 和 $I_y$ 分别是大小为 $(N_x-2)$ 和 $(N_y-2)$ 的单位矩阵，$\\otimes$ 表示克罗内克积。\n\n右端向量 $\\mathbf{b}$ 由内部节点上的强迫函数值 $f_{i,j}$ 构建。对于邻近边界的节点，必须将边界条件值纳入考虑。离散方程被重排，将所有已知的边界值项移到右端。对于一个内部节点 $(i,j)$，右端项元素 $b_{i,j}$ 初始化为 $f_{i,j}$。然后进行调整：\n-   如果 $i=1$，从 $b_{1,j}$ 中减去 $\\frac{g(x_0, y_j)}{h_x^2}$。\n-   如果 $i=N_x-2$，从 $b_{N_x-2,j}$ 中减去 $\\frac{g(x_{N_x-1}, y_j)}{h_x^2}$。\n-   如果 $j=1$，从 $b_{i,1}$ 中减去 $\\frac{g(x_i, y_0)}{h_y^2}$。\n-   如果 $j=N_y-2$，从 $b_{i,N_y-2}$ 中减去 $\\frac{g(x_i, y_{N_y-1})}{h_y^2}$。\n\n一旦 $A$ 和 $\\mathbf{b}$ 组装完毕，就求解该系统以获得 $\\mathbf{u}_{int}$。然后，通过将计算出的内部值与来自 $u^\\star$ 的已知边界值相结合，构建出完整的数值解 $u_h$。\n\n### 4. 误差分析与收敛性\n\n数值误差是数值解 $u_h$ 与网格点上的精确制造解 $u^\\star$ 之间的差值，$e_{i,j} = u_{h,i,j} - u^\\star(x_i, y_j)$。我们使用两种标准范数来量化内部节点上的这个误差：\n\n-   离散 $L^2$-范数：$\\|e_h\\|_{L^2} = \\left(\\sum_{i=1}^{N_x-2}\\sum_{j=1}^{N_y-2} |e_{i,j}|^2 h_x h_y\\right)^{1/2}$\n-   离散 $L^\\infty$-范数（最大范数）：$\\|e_h\\|_{L^\\infty} = \\max_{1\\le i\\le N_x-2,\\,1\\le j\\le N_y-2} |e_{i,j}|$\n\n为了验证该方法的精度阶，我们进行网格加密研究。如果误差范数的行为符合 $\\|e_h\\| \\approx C h^p$，其中 $h$ 是特征网格尺寸，$p$ 是精度阶，那么通过在粗网格（尺寸 $h$）和细网格（尺寸 $h/2$）上求解，我们可以估计 $p$：\n$$\np = \\frac{\\log(\\|e_h\\| / \\|e_{h/2}\\|)}{\\log(2)}\n$$\n对于一个二阶方法，我们期望 $p \\approx 2$。\n\n最后，计算线性系统残差的相对 $\\ell^2$-范数 $\\|r\\|_2 / \\|b\\|_2$，其中 $r = A\\mathbf{u}_{int} - \\mathbf{b}$。这个值评估了数值线性代数求解器在求解系统 $A\\mathbf{u}_{int} = \\mathbf{b}$ 方面的表现，并且应该接近机器精度。\n\n这些步骤将针对指定的各向同性和各向异性网格加密序列进行实现，以产生五个所需的输出值。",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import diags, identity, kron\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to perform the Method of Manufactured Solutions verification\n    for a 2D Poisson solver.\n    \"\"\"\n\n    def u_star(x, y):\n        \"\"\"The manufactured solution u*(x,y).\"\"\"\n        return np.sin(3 * np.pi * x) * np.cos(2 * np.pi * y) + x**3 * y - np.exp(x + y)\n\n    def f_source(x, y):\n        \"\"\"The forcing term f(x,y) = laplacian(u*(x,y)).\"\"\"\n        term1 = -13 * np.pi**2 * np.sin(3 * np.pi * x) * np.cos(2 * np.pi * y)\n        term2 = 6 * x * y\n        term3 = -2 * np.exp(x + y)\n        return term1 + term2 + term3\n\n    def solve_poisson(Nx, Ny):\n        \"\"\"\n        Solves the Poisson equation on a grid of size (Nx, Ny) and returns error norms.\n        \"\"\"\n        hx = 1.0 / (Nx - 1)\n        hy = 1.0 / (Ny - 1)\n\n        x = np.linspace(0, 1, Nx)\n        y = np.linspace(0, 1, Ny)\n        X, Y = np.meshgrid(x, y, indexing='ij')\n\n        u_exact_grid = u_star(X, Y)\n        f_grid = f_source(X, Y)\n\n        Nix = Nx - 2\n        Niy = Ny - 2\n        N_int = Nix * Niy\n\n        if N_int == 0:\n            return 0.0, 0.0, None, None, None\n\n        # Assemble the discrete Laplacian matrix A using Kronecker products\n        # This corresponds to row-major (C-style) flattening of the unknowns.\n        hx2_inv = 1.0 / hx**2\n        hy2_inv = 1.0 / hy**2\n        \n        diag_x = np.full(Nix, -2.0 * hx2_inv)\n        offdiag_x = np.full(Nix - 1, 1.0 * hx2_inv)\n        Dxx = diags([offdiag_x, diag_x, offdiag_x], [-1, 0, 1], format='csc')\n\n        diag_y = np.full(Niy, -2.0 * hy2_inv)\n        offdiag_y = np.full(Niy - 1, 1.0 * hy2_inv)\n        Dyy = diags([offdiag_y, diag_y, offdiag_y], [-1, 0, 1], format='csc')\n\n        Ix = identity(Nix, format='csc')\n        Iy = identity(Niy, format='csc')\n\n        # The order of kron matters and must match the flattening of the RHS vector\n        # This is for row-major flattening: Dxx kron I + I kron Dyy\n        A = kron(Dxx, Iy) + kron(Ix, Dyy)\n\n        # Assemble the right-hand side vector b\n        b_matrix = f_grid[1:-1, 1:-1].copy()\n\n        # Adjust RHS for boundary conditions\n        b_matrix[0, :] -= u_exact_grid[0, 1:-1] * hx2_inv  # Left boundary i=0\n        b_matrix[-1, :] -= u_exact_grid[-1, 1:-1] * hx2_inv # Right boundary i=Nx-1\n        b_matrix[:, 0] -= u_exact_grid[1:-1, 0] * hy2_inv   # Bottom boundary j=0\n        b_matrix[:, -1] -= u_exact_grid[1:-1, -1] * hy2_inv # Top boundary j=Ny-1\n        \n        b = b_matrix.flatten('C')\n\n        # Solve the linear system for interior nodes\n        u_int_flat = spsolve(A, b)\n\n        # Reconstruct the full numerical solution grid\n        u_h = u_exact_grid.copy()\n        u_h[1:-1, 1:-1] = u_int_flat.reshape((Nix, Niy), order='C')\n\n        # Compute error on interior nodes\n        error_grid = u_h[1:-1, 1:-1] - u_exact_grid[1:-1, 1:-1]\n\n        # Compute L2 and Linf norms of the error\n        l2_norm = np.sqrt(np.sum(error_grid**2 * hx * hy))\n        linf_norm = np.max(np.abs(error_grid))\n        \n        return l2_norm, linf_norm, A, u_int_flat, b\n\n    # Isotropic refinement\n    err_l2_33, err_linf_33, _, _, _ = solve_poisson(33, 33)\n    err_l2_65, err_linf_65, A_65, u_sol_65, b_65 = solve_poisson(65, 65)\n\n    p_l2_iso = np.log(err_l2_33 / err_l2_65) / np.log(2)\n    p_linf_iso = np.log(err_linf_33 / err_linf_65) / np.log(2)\n    \n    # Anisotropic refinement\n    err_l2_c, err_linf_c, _, _, _ = solve_poisson(33, 49)\n    err_l2_f, err_linf_f, _, _, _ = solve_poisson(65, 97)\n\n    p_l2_aniso = np.log(err_l2_c / err_l2_f) / np.log(2)\n    p_linf_aniso = np.log(err_linf_c / err_linf_f) / np.log(2)\n    \n    # Residual calculation for the finest isotropic grid\n    residual_vector = A_65.dot(u_sol_65) - b_65\n    rel_residual = np.linalg.norm(residual_vector) / np.linalg.norm(b_65)\n\n    results = [p_l2_iso, p_linf_iso, p_l2_aniso, p_linf_aniso, rel_residual]\n    \n    # Format output as specified\n    formatted_results = [f\"{val:.6f}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "对于某些重要情况，例如具有周期性边界的区域，通用的有限差分求解器并非最有效的方法。这项实践  介绍功能强大的基于 FFT 的直接求解器，它将问题转换到傅里叶空间，使求解过程简化为一次简单的除法。你将为全周期和混合周期-狄利克雷边界条件实现求解器，从而体会到当算法与问题结构匹配时可能带来的巨大效率提升。",
            "id": "3804162",
            "problem": "考虑在不可压缩海洋流的投影法中出现的压力泊松方程的数值解。从不可压缩性约束 $\\nabla \\cdot \\boldsymbol{u} = 0$ 和动量方程出发，可以得到关于压力的泊松方程 $\\nabla^2 p = f$，其中 $p$ 是压力，$f$ 是一个由中间速度场导出的已知右端项。在计算海洋学中，通常在与大规模无岸流相切的方向上施加周期性边界条件，而在其余方向上施加非周期性边界条件。您的任务是在周期性方向上实现基于快速傅里叶变换（FFT）的直接求解器，并在非周期性方向上使用二阶中心有限差分来求解压力泊松方程，并根据精确解量化数值误差。\n\n您必须编写一个完整的程序，该程序在矩形域上构建均匀网格，组装适当的离散算子，并使用以下方法求解泊松方程：\n- 在任何周期性方向上使用基于 FFT 的对角化。\n- 在任何非周期性方向上使用二阶中心有限差分和齐次狄利克雷边界条件进行三对角直接求解。\n\n求解器必须处理两种配置：\n1. 一种混合配置，在 $x$ 方向上具有周期性边界条件，在 $y$ 方向上具有齐次狄利克雷边界条件。\n2. 一种完全周期性配置，在 $x$ 和 $y$ 方向上均具有周期性边界条件。\n\n对于每种配置，程序必须定义一个精确解 $p^{\\mathrm{true}}(x,y)$，并从连续泊松方程 $\\nabla^2 p^{\\mathrm{true}} = f$ 中导出一个一致的右端项 $f(x,y)$。选择的网格和测试函数是光滑的，并与指定的边界条件兼容。使用具有以下定义的均匀网格：\n- 在任何长度为 $L$ 的周期性方向上，使用 $N$ 个点，坐标为 $x_i = i L / N$，其中 $i = 0, 1, \\dots, N-1$。\n- 在任何长度为 $L$ 的齐次狄利克雷方向上，使用 $N^{\\mathrm{int}}$ 个内部点，间距为 $h = L / (N^{\\mathrm{int}} + 1)$，坐标为 $y_j = j h$，其中 $j = 1, 2, \\dots, N^{\\mathrm{int}}$。\n\n实现以下三个测试用例（这是必需的测试套件）：\n\n- 测试用例 1（混合：$x$ 方向周期性，$y$ 方向狄利克雷）：\n  - 域大小：$L_x = 1$，$L_y = 1$。\n  - 网格大小：$x$ 方向 $N_x = 64$ 个周期性点，$y$ 方向 $N_y^{\\mathrm{int}} = 64$ 个内部点。\n  - 精确解：$p^{\\mathrm{true}}(x,y) = \\sin\\!\\left(2\\pi x / L_x\\right) \\sin\\!\\left(\\pi y / L_y\\right)$。\n  - 右端项：$f(x,y) = -\\left[\\left(2\\pi/L_x\\right)^2 + \\left(\\pi/L_y\\right)^2\\right] p^{\\mathrm{true}}(x,y)$。\n\n- 测试用例 2（$x$ 和 $y$ 方向完全周期性）：\n  - 域大小：$L_x = 1$，$L_y = 1$。\n  - 网格大小：$N_x = 64$，$N_y = 64$ 个周期性点。\n  - 精确解：$p^{\\mathrm{true}}(x,y) = \\sin\\!\\left(2\\pi x / L_x\\right) \\sin\\!\\left(2\\pi y / L_y\\right)$。\n  - 右端项：$f(x,y) = -\\left[\\left(2\\pi/L_x\\right)^2 + \\left(2\\pi/L_y\\right)^2\\right] p^{\\mathrm{true}}(x,y)$。\n  - 强制将 $p$ 的零傅里叶模式设置为 $0$，以避免不确定的平均压力模式；这是合理的，因为指定的 $f$ 具有零均值。\n\n- 测试用例 3（混合：$x$ 方向周期性，$y$ 方向狄利克雷，$x$ 方向零波数的边界情况）：\n  - 域大小：$L_x = 1$，$L_y = 1$。\n  - 网格大小：$x$ 方向 $N_x = 32$ 个周期性点，$y$ 方向 $N_y^{\\mathrm{int}} = 50$ 个内部点。\n  - 精确解：$p^{\\mathrm{true}}(x,y) = \\sin\\!\\left(\\pi y / L_y\\right)$（与 $x$ 无关）。\n  - 右端项：$f(x,y) = -\\left(\\pi/L_y\\right)^2 \\sin\\!\\left(\\pi y / L_y\\right)$。\n\n算法要求：\n- 在混合配置中，沿周期性 $x$ 方向应用一维 FFT 以对该方向的离散二阶导数进行对角化，从而为每个傅里叶模式生成沿 $y$ 方向的解耦线性系统。使用直接法精确求解每个生成的三对角系统，然后通过逆 FFT 重建 $p(x,y)$。\n- 在完全周期性配置中，对右端项应用二维 FFT，在傅里叶空间中对所有非零波数对的拉普拉斯算子进行直接谱反演，并在反变换回之前将压力的零波数设置为 $0$。\n\n对于每个测试用例，计算网格上数值解与精确解之间的最大绝对误差，定义为 $E_{\\infty} = \\max_{i,j} \\left| p_{ij} - p^{\\mathrm{true}}_{ij} \\right|$。此问题中没有物理单位；所有量纲均为无量纲。测试用例的预期答案是实值浮点数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，按测试用例 $1$、$2$ 和 $3$ 的顺序排列（例如，$\\left[ r_1, r_2, r_3 \\right]$）。这些条目必须是每个测试用例计算出的 $E_{\\infty}$ 值，并按该顺序排列。不应从用户读取任何输入，并且除了指定的单行输出外，不应打印任何其他内容。",
            "solution": "该问题被验证为科学上合理、适定且完整。它提出了计算物理学中的一个标准数值任务：在矩形域上使用谱方法和有限差分法相结合来求解二维泊松方程 $\\nabla^2 p = f$，并针对不同的边界条件进行调整。\n\n该解决方案的实现方法是为指定的两种不同配置开发求解器：一种是混合周期性和狄利克雷边界条件，另一种是完全周期性边界条件。\n\n### 混合边界条件（周期性-狄利克雷）的方法\n\n此配置适用于测试用例 1 和 3，其中域在 $x$ 方向上是周期性的，在 $y$ 方向上受齐次狄利克雷条件约束，即 $p(x, 0) = 0$ 和 $p(x, L_y) = 0$。控制方程为\n$$\n\\frac{\\partial^2 p}{\\partial x^2} + \\frac{\\partial^2 p}{\\partial y^2} = f(x, y)\n$$\n该问题在网格点 $(x_i, y_j)$ 上进行离散化，其中 $x_i = i L_x / N_x$（对于 $i=0, \\dots, N_x-1$）以及 $y_j = j h_y$（对于 $j=1, \\dots, N_y^{\\mathrm{int}}$），单元高度为 $h_y = L_y / (N_y^{\\mathrm{int}} + 1)$。\n\n该策略利用了 $x$ 方向的周期性。对于任何固定的垂直层 $y_j$，压力 $p(x, y_j)$ 和右端项 $f(x, y_j)$ 可以用离散傅里叶级数表示：\n$$\np(x_i, y_j) = \\sum_{m=0}^{N_x-1} \\hat{p}(k_m, y_j) e^{i k_m x_i}\n$$\n$$\nf(x_i, y_j) = \\sum_{m=0}^{N_x-1} \\hat{f}(k_m, y_j) e^{i k_m x_i}\n$$\n其中 $\\hat{p}$ 和 $\\hat{f}$ 是傅里叶系数（通过快速傅里叶变换，FFT 计算），$k_m = 2\\pi m' / L_x$ 是离散波数，其中 $m'$ 是由 FFT 算法管理的整数索引（通常从 $-N_x/2$ 到 $N_x/2 - 1$）。傅里叶变换的微分性质表明，$\\partial^2 p / \\partial x^2$ 的变换是 $-k_m^2 \\hat{p}$。\n\n将这些级数代入偏微分方程，可以有效地将方程在 $x$ 方向上变换到傅里叶空间。这将空间维度解耦，为每个傅里叶模式 $k_m$ 产生一个独立的 $y$ 方向上的一维边值问题：\n$$\n-k_m^2 \\hat{p}(k_m, y) + \\frac{d^2 \\hat{p}(k_m, y)}{d y^2} = \\hat{f}(k_m, y)\n$$\n现在，这个常微分方程在 $y$ 方向上使用二阶中心有限差分格式对二阶导数进行离散化：\n$$\n\\frac{d^2 \\hat{p}}{dy^2} \\bigg|_{y_j} \\approx \\frac{\\hat{p}(k_m, y_{j+1}) - 2\\hat{p}(k_m, y_j) + \\hat{p}(k_m, y_{j-1})}{h_y^2}\n$$\n齐次狄利克雷边界条件 $p(x,0)=p(x,L_y)=0$ 意味着它们的傅里叶变换也为零，即 $\\hat{p}(k_m, 0) = 0$ 和 $\\hat{p}(k_m, L_y) = 0$。这为离散系统提供了边界条件。\n\n对于每个波数 $k_m$，我们得到一个关于傅里叶系数向量 $\\mathbf{\\hat{p}}_m = [\\hat{p}(k_m, y_1), \\dots, \\hat{p}(k_m, y_{N_y^{\\mathrm{int}}})]^T$ 的线性方程组：\n$$\n\\frac{1}{h_y^2} \\left( \\hat{p}_{m,j-1} - 2\\hat{p}_{m,j} + \\hat{p}_{m,j+1} \\right) - k_m^2 \\hat{p}_{m,j} = \\hat{f}_{m,j}\n$$\n其中 $\\hat{p}_{m,j} \\equiv \\hat{p}(k_m, y_j)$，边界项 $\\hat{p}_{m,0}$ 和 $\\hat{p}_{m,N_y^{\\mathrm{int}}+1}$ 为零。这对每个模式 $m$ 构成一个大小为 $N_y^{\\mathrm{int}} \\times N_y^{\\mathrm{int}}$ 的对称三对角系统，可以使用直接三对角求解器高效求解。\n\n完整的算法如下：\n1.  对每个 $j$，沿 $x$ 轴计算源项 $f(x_i, y_j)$ 的一维 FFT，以获得 $\\hat{f}(k_m, y_j)$。\n2.  对每个傅里叶模式 $k_m$：\n    a.  构造代表算子 $(-k_m^2 + \\frac{d^2}{dy^2})$ 的三对角矩阵。\n    b.  求解三对角系统以得到 $\\hat{p}(k_m, y_j)$。\n3.  将所有模式的解组合成一个二维数组 $\\hat{p}(k_m, y_j)$。\n4.  对每个 $j$，沿 $k_m$ 轴计算 $\\hat{p}(k_m, y_j)$ 的一维逆 FFT，以恢复压力场 $p(x_i, y_j)$。\n\n### 完全周期性边界条件的方法\n\n此配置适用于测试用例 2，其中边界条件在 $x$ 和 $y$ 方向上都是周期性的。离散化在 $x$ 方向上使用 $N_x$ 个点，在 $y$ 方向上使用 $N_y$ 个点。\n\n鉴于两个方向上的周期性，二维 FFT 是对角化拉普拉斯算子的自然工具。压力和源项由二维离散傅里叶级数表示：\n$$\np(x_i, y_j) = \\sum_{m=0}^{N_x-1} \\sum_{l=0}^{N_y-1} \\hat{p}(k_m, k_l) e^{i k_m x_i} e^{i k_l y_j}\n$$\n对泊松方程 $\\nabla^2 p = f$ 应用二维 FFT，将其在谱域中转换为一个简单的代数方程：\n$$\n(-k_m^2 - k_l^2) \\hat{p}(k_m, k_l) = \\hat{f}(k_m, k_l)\n$$\n其中 $k_m$ 和 $k_l$ 分别是 $x$ 和 $y$ 方向的波数。然后通过直接相除得到压力的傅里叶系数的解：\n$$\n\\hat{p}(k_m, k_l) = \\frac{\\hat{f}(k_m, k_l)}{-k_m^2 - k_l^2}\n$$\n对于零波数模式 $(k_m, k_l) = (0,0)$，分母为零，会出现奇点。这对应于场的平均值。为了使解存在，源项必须具有零均值，即 $\\int f \\,dA = 0$，这意味着其零波数傅里叶系数 $\\hat{f}(0,0)$ 必须为零。问题陈述保证了所选测试用例满足此条件。相应的压力模式 $\\hat{p}(0,0)$（代表平均压力）是不确定的。按照惯例，我们通过将平均压力设置为零来解决这种模糊性：$\\hat{p}(0,0) = 0$。\n\n完整的算法如下：\n1.  计算源项 $f(x_i, y_j)$ 的二维 FFT 以得到 $\\hat{f}(k_m, k_l)$。\n2.  对于所有非零波数对 $(k_m, k_l)$，通过将 $\\hat{f}(k_m, k_l)$ 除以拉普拉斯算子的谱表示 $-(k_m^2 + k_l^2)$ 来计算 $\\hat{p}(k_m, k_l)$。\n3.  设置零波数模式 $\\hat{p}(0,0) = 0$。\n4.  计算 $\\hat{p}(k_m, k_l)$ 的二维逆 FFT 以恢复压力场 $p(x_i, y_j)$。\n\n### 误差量化\n\n对于每个测试用例，问题都提供了一个与边界条件一致的精确解析解 $p^{\\mathrm{true}}(x,y)$，并由此导出了源项 $f(x,y)$。至关重要的是，所选的正弦函数既是连续拉普拉斯算子的本征函数，也是离散算子（基于 FFT 的二阶导数和中心有限差分二阶导数）的本征函数。因此，数值方法应该能精确求解离散系统，得到的数值解 $p_{ij}$ 应该在机器浮点精度范围内与在网格点上求值的精确解 $p^{\\mathrm{true}}_{ij}$ 相匹配。计算最大绝对误差 $E_{\\infty} = \\max_{i,j} |p_{ij} - p^{\\mathrm{true}}_{ij}|$ 以验证这一预期。任何显著偏离零的值都将表明实现中存在错误。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve_mixed_bc(Lx, Ly, Nx, Ny_int, p_true_func, f_func):\n    \"\"\"\n    Solves the 2D Poisson equation with periodic BC in x and Dirichlet BC in y.\n    \n    Uses FFT in the x-direction and a tridiagonal solve in the y-direction.\n    \"\"\"\n    # 1. Create grids\n    hx = Lx / Nx\n    x = hx * np.arange(Nx)\n    hy = Ly / (Ny_int + 1)\n    y = hy * np.arange(1, Ny_int + 1)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # 2. Evaluate functions on the grid\n    f_grid = f_func(X, Y)\n    p_true_grid = p_true_func(X, Y)\n\n    # 3. FFT of the source term f along the periodic x-axis\n    f_hat = np.fft.fft(f_grid, axis=0)\n    \n    # 4. Get discrete wavenumbers in x\n    kx = 2 * np.pi * np.fft.fftfreq(Nx, d=hx)\n\n    # 5. Solve tridiagonal systems for each Fourier mode\n    p_hat = np.zeros_like(f_hat, dtype=np.complex128)\n    \n    # The tridiagonal matrix is constant except for the main diagonal.\n    # It has shape (Ny_int, Ny_int).\n    # A_m @ p_hat_col = f_hat_col\n    # The matrix has (1/hy^2) on the off-diagonals.\n    \n    # For scipy.linalg.solve_banded, we prepare the banded matrix `ab`\n    # ab has shape (3, Ny_int) for l=1, u=1.\n    # ab[0, :] = super-diagonal\n    # ab[1, :] = main-diagonal\n    # ab[2, :] = sub-diagonal\n    ab = np.zeros((3, Ny_int))\n    ab[0, 1:] = 1.0 / hy**2\n    ab[2, :-1] = 1.0 / hy**2\n\n    for m in range(Nx):\n        # Construct main diagonal for this wavenumber kx[m]\n        main_diag_val = -2.0 / hy**2 - kx[m]**2\n        ab[1, :] = main_diag_val\n        \n        # Right-hand side for this mode\n        b = f_hat[m, :]\n        \n        # Solve the tridiagonal system\n        p_hat[m, :] = solve_banded((1, 1), ab, b)\n        \n    # 6. Inverse FFT to get the numerical solution\n    p_numeric = np.fft.ifft(p_hat, axis=0)\n\n    # The solution should be real\n    p_numeric_real = np.real(p_numeric)\n    \n    # 7. Calculate max absolute error\n    error = np.max(np.abs(p_numeric_real - p_true_grid))\n    return error\n\ndef solve_periodic_bc(Lx, Ly, Nx, Ny, p_true_func, f_func):\n    \"\"\"\n    Solves the 2D Poisson equation with periodic BCs in x and y.\n    \n    Uses a 2D FFT-based spectral method.\n    \"\"\"\n    # 1. Create grids\n    hx = Lx / Nx\n    x = hx * np.arange(Nx)\n    hy = Ly / Ny\n    y = hy * np.arange(Ny)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # 2. Evaluate functions on grid\n    f_grid = f_func(X, Y)\n    p_true_grid = p_true_func(X, Y)\n\n    # 3. 2D FFT of the source term\n    f_hat = np.fft.fft2(f_grid)\n\n    # 4. Get discrete wavenumbers\n    kx_vec = 2 * np.pi * np.fft.fftfreq(Nx, d=hx)\n    ky_vec = 2 * np.pi * np.fft.fftfreq(Ny, d=hy)\n    Kx, Ky = np.meshgrid(kx_vec, ky_vec, indexing='ij')\n\n    # 5. Fourier representation of the Laplacian\n    lap_hat = -(Kx**2 + Ky**2)\n\n    # 6. Solve for p_hat in Fourier space\n    # Handle the (0,0) mode singularity by dividing only where lap_hat is non-zero.\n    p_hat = np.divide(f_hat, lap_hat, out=np.zeros_like(f_hat), where=(lap_hat != 0))\n    \n    # The problem specifies setting the zero mode of p to 0. This is implicitly\n    # handled by the `out=np.zeros_like(f_hat)` argument to np.divide, since\n    # lap_hat[0,0] is zero, so the result p_hat[0,0] remains 0.\n    # An explicit set for clarity:\n    p_hat[0, 0] = 0.0\n\n    # 7. Inverse 2D FFT to get the numerical solution\n    p_numeric = np.fft.ifft2(p_hat)\n    \n    # The solution should be real\n    p_numeric_real = np.real(p_numeric)\n\n    # 8. Calculate max absolute error\n    error = np.max(np.abs(p_numeric_real - p_true_grid))\n    return error\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    \n    results = []\n\n    # Test Case 1: Mixed BC (periodic-x, dirichlet-y)\n    Lx1, Ly1 = 1.0, 1.0\n    Nx1, Ny_int1 = 64, 64\n    k_x1 = 2 * np.pi / Lx1\n    k_y1 = np.pi / Ly1\n    p_true1 = lambda x, y: np.sin(k_x1 * x) * np.sin(k_y1 * y)\n    f1 = lambda x, y: -(k_x1**2 + k_y1**2) * p_true1(x, y)\n    error1 = solve_mixed_bc(Lx1, Ly1, Nx1, Ny_int1, p_true1, f1)\n    results.append(error1)\n\n    # Test Case 2: Fully Periodic BC\n    Lx2, Ly2 = 1.0, 1.0\n    Nx2, Ny2 = 64, 64\n    k_x2 = 2 * np.pi / Lx2\n    k_y2 = 2 * np.pi / Ly2\n    p_true2 = lambda x, y: np.sin(k_x2 * x) * np.sin(k_y2 * y)\n    f2 = lambda x, y: -(k_x2**2 + k_y2**2) * p_true2(x, y)\n    error2 = solve_periodic_bc(Lx2, Ly2, Nx2, Ny2, p_true2, f2)\n    results.append(error2)\n\n    # Test Case 3: Mixed BC, edge case (zero wavenumber in x)\n    Lx3, Ly3 = 1.0, 1.0\n    Nx3, Ny_int3 = 32, 50\n    k_y3 = np.pi / Ly3\n    p_true3 = lambda x, y: np.sin(k_y3 * y)\n    f3 = lambda x, y: -(k_y3**2) * np.sin(k_y3 * y)\n    error3 = solve_mixed_bc(Lx3, Ly3, Nx3, Ny_int3, p_true3, f3)\n    results.append(error3)\n\n    # Format the results for printing\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}