{
    "hands_on_practices": [
        {
            "introduction": "要构建高阶且无数值振荡的输运格式，关键在于如何在保持高阶精度的同时避免产生新的极值。通量限制器（flux limiter）正是实现这一目标的核心机制。本练习将带您动手实践最基本的步骤：使用经典的 minmod 限制器计算一个单元内的限制斜率，并由此重构单元交界面的示踪剂浓度。通过这个计算，您将掌握总变差递减（TVD）格式的基本构造模块。",
            "id": "3794861",
            "problem": "考虑一个由守恒律 $\\partial_t q + \\partial_x (u q) = 0$ 控制的一维被动示踪场平流问题，其中速度 $u > 0$ 为常数。在间距为 $\\Delta x$ 的均匀网格上，有限体积法通过在以 $x_j$ 为中心的单元上的单元平均值 $\\bar{q}_j$ 来表示示踪场。为了在保持总变差递减（TVD）意义下的非线性稳定性的同时达到二阶空间精度，在每个单元中执行分段线性重构，其斜率受到应用于由相邻单元平均值形成的单边离散梯度的经典minmod通量限制器的限制。在 $x_{i \\pm 1/2}$ 处的重构界面值与此分段线性重构的定义保持一致。\n\n对于具体数据 $\\bar{q}_{i-1} = 1.0$、$\\bar{q}_i = 1.5$ 和 $\\bar{q}_{i+1} = 2.0$，确定单元 $i$ 中经minmod限制的斜率以及在左右界面 $x_{i-1/2}$ 和 $x_{i+1/2}$ 处的相应重构值。用 $\\Delta x$ 的符号形式表示斜率，并以精确数值提供两个界面值。不要假设 $\\Delta x$ 有任何特定的数值。\n\n将最终答案表示为一个行矩阵，按顺序包含单元 $i$ 中的受限斜率、从单元 $i$ 追踪得到的在 $x_{i-1/2}$ 处的重构值，以及从单元 $i$ 追踪得到的在 $x_{i+1/2}$ 处的重构值。无需四舍五入，也无需单位。",
            "solution": "该问题陈述经评估具有科学依据、适定且客观。它提供了有限体积法应用于双曲守恒律的一个标准练习，这是计算科学与工程领域的一个核心课题。所有必要数据均已提供，术语精确，且问题可形式化求解。因此，该问题是有效的，并将提供解答。\n\n该问题要求为一个分段线性有限体积格式确定受限斜率和重构的界面值。单元 $i$ 内的示踪场 $q(x)$ 覆盖区间 $[x_i - \\frac{\\Delta x}{2}, x_i + \\frac{\\Delta x}{2}]$，它由一个线性函数近似：\n$$q_i(x) = \\bar{q}_i + \\sigma_i (x - x_i)$$\n其中 $\\bar{q}_i$ 是示踪剂的单元平均值，$x_i$ 是单元中心，$\\sigma_i$ 是单元 $i$ 中示踪剂分布的受限斜率。\n\n为确保格式是总变差递减（TVD）的，斜率 $\\sigma_i$ 会受到限制。题目指定使用经典的minmod限制器，该限制器应用于单边离散梯度。这些梯度是后向和前向差分斜率，使用相邻单元的平均值计算得出。\n\n后向差分斜率 $\\sigma_i^B$ 由下式给出：\n$$\\sigma_i^B = \\frac{\\bar{q}_i - \\bar{q}_{i-1}}{\\Delta x}$$\n前向差分斜率 $\\sigma_i^F$ 由下式给出：\n$$\\sigma_i^F = \\frac{\\bar{q}_{i+1} - \\bar{q}_i}{\\Delta x}$$\n\n给定的单元平均值为 $\\bar{q}_{i-1} = 1.0$、$\\bar{q}_i = 1.5$ 和 $\\bar{q}_{i+1} = 2.0$。为清晰和精确起见，我们将其转换为分数：$\\bar{q}_{i-1} = 1$、$\\bar{q}_i = \\frac{3}{2}$ 和 $\\bar{q}_{i+1} = 2$。\n\n现在我们可以计算单边斜率：\n$$\\sigma_i^B = \\frac{\\frac{3}{2} - 1}{\\Delta x} = \\frac{\\frac{1}{2}}{\\Delta x} = \\frac{1}{2\\Delta x}$$\n$$\\sigma_i^F = \\frac{2 - \\frac{3}{2}}{\\Delta x} = \\frac{\\frac{1}{2}}{\\Delta x} = \\frac{1}{2\\Delta x}$$\n\n受限斜率 $\\sigma_i$ 是通过对这两个斜率应用 minmod 函数得到的：\n$$\\sigma_i = \\text{minmod}(\\sigma_i^B, \\sigma_i^F)$$\nminmod 函数的定义如下：\n$$\\text{minmod}(a, b) = \\begin{cases} \\min(|a|, |b|)  \\text{if } \\operatorname{sgn}(a) = \\operatorname{sgn}(b) \\\\ 0  \\text{if } \\operatorname{sgn}(a) \\neq \\operatorname{sgn}(b) \\end{cases}$$\n在本例中，两个参数 $\\sigma_i^B$ 和 $\\sigma_i^F$ 相等且为正。因此，minmod 函数返回它们的共同值：\n$$\\sigma_i = \\text{minmod}\\left(\\frac{1}{2\\Delta x}, \\frac{1}{2\\Delta x}\\right) = \\frac{1}{2\\Delta x}$$\n这就是单元 $i$ 中经 minmod 限制的斜率，以 $\\Delta x$ 的符号形式表示。\n\n接下来，我们确定单元界面 $x_{i-1/2}$ 和 $x_{i+1/2}$ 处的重构值。这些界面位于 $x_{i-1/2} = x_i - \\frac{\\Delta x}{2}$ 和 $x_{i+1/2} = x_i + \\frac{\\Delta x}{2}$。通过在这些点上计算线性函数 $q_i(x)$ 的值来找到重构值。\n\n从单元 $i$ 追踪得到的左界面 $x_{i-1/2}$ 处的重构值记为 $q_{i,L}$：\n$$q_{i,L} = q_i(x_{i-1/2}) = \\bar{q}_i + \\sigma_i \\left( (x_i - \\frac{\\Delta x}{2}) - x_i \\right) = \\bar{q}_i - \\sigma_i \\frac{\\Delta x}{2}$$\n代入 $\\bar{q}_i$ 和 $\\sigma_i$ 的值：\n$$q_{i,L} = \\frac{3}{2} - \\left(\\frac{1}{2\\Delta x}\\right) \\frac{\\Delta x}{2} = \\frac{3}{2} - \\frac{1}{4} = \\frac{6}{4} - \\frac{1}{4} = \\frac{5}{4}$$\n\n从单元 $i$ 追踪得到的右界面 $x_{i+1/2}$ 处的重构值记为 $q_{i,R}$：\n$$q_{i,R} = q_i(x_{i+1/2}) = \\bar{q}_i + \\sigma_i \\left( (x_i + \\frac{\\Delta x}{2}) - x_i \\right) = \\bar{q}_i + \\sigma_i \\frac{\\Delta x}{2}$$\n代入 $\\bar{q}_i$ 和 $\\sigma_i$ 的值：\n$$q_{i,R} = \\frac{3}{2} + \\left(\\frac{1}{2\\Delta x}\\right) \\frac{\\Delta x}{2} = \\frac{3}{2} + \\frac{1}{4} = \\frac{6}{4} + \\frac{1}{4} = \\frac{7}{4}$$\n\n作为验证，请注意数据是单调的（$\\bar{q}_{i-1}  \\bar{q}_i  \\bar{q}_{i+1}$），并且重构保持了单调性，因为重构的界面值 $q_{i,L} = 1.25$ 和 $q_{i,R} = 1.75$ 位于相邻单元平均值 $\\bar{q}_{i-1} = 1$ 和 $\\bar{q}_{i+1} = 2$ 之间，并且它们恰当地界定了单元平均值 $\\bar{q}_i = 1.5$。这与 minmod 限制器的 TVD 属性是一致的。\n\n最终答案由受限斜率 $\\sigma_i$、左界面值 $q_{i,L}$ 和右界面值 $q_{i,R}$ 组成。",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{1}{2\\Delta x}  \\frac{5}{4}  \\frac{7}{4} \\end{pmatrix}}$$"
        },
        {
            "introduction": "在掌握了如何计算限制斜率和界面值之后，下一步便是将这些构件整合到一个完整的有限体积法时间步长更新中。本练习模拟了一个更真实的计算海洋学问题，您不仅需要应用 MUSCL (Monotone Upstream-centered Schemes for Conservation Laws) 方法和 minmod 限制器来计算通量，还需要处理实际模拟中不可或缺的流入和流出边界条件。这个实践将帮助您把离散的计算步骤联系起来，形成一个完整的小型模拟过程。",
            "id": "3794851",
            "problem": "考虑一个被动示踪剂浓度场的一维线性平流，该过程由守恒律 $\\partial C / \\partial t + u\\,\\partial C / \\partial x = 0$ 控制。计算在一个由 $N = 5$ 个有限体积单元（索引为 $i = 1, 2, 3, 4, 5$）组成的均匀网格上进行，单元宽度为 $\\Delta x = 1000\\,\\mathrm{m}$。速度为恒定值 $u = 0.5\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$，方向从左到右，时间步长为 $\\Delta t = 600\\,\\mathrm{s}$。在时间层 $n$ 的初始单元平均浓度由下式给出：\n$C_1^n = 1.0\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$，$C_2^n = 1.2\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$，$C_3^n = 1.4\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$，$C_4^n = 1.6\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$，以及 $C_5^n = 1.8\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$。$x = 0$ 处的左边界为入流，其指定的狄利克雷值为 $C_{\\mathrm{in}} = 2.0\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$，右边界为出流，采用零梯度闭合。\n\n使用守恒型有限体积法，并通过一种通量限制的守恒律单调上游中心格式 (MUSCL) 方法进行二阶空间重构，计算每个内部界面 $x_{i+1/2}$ 处的限制后界面状态，以及与线性平流的上游 Godunov 通量一致的边通量。使用总变差减小 (TVD) minmod 斜率限制器，其定义为\n$\\operatorname{minmod}(a,b) = \\begin{cases}\n\\operatorname{sign}(a)\\,\\min(|a|,|b|),  \\text{if } ab  0,\\\\\n0,  \\text{otherwise}.\n\\end{cases}$\n对于出流边界闭合，采用一个零梯度的虚拟单元，其值等于最后一个内部单元的值。\n\n然后，对单元平均值执行一次显式欧拉时间更新。报告一个时间步长后单元 $i=3$ 中的更新浓度，即 $C_3^{n+1}$。将您的答案四舍五入至四位有效数字，并以 $\\mathrm{kg}\\,\\mathrm{m}^{-3}$ 为单位表示。",
            "solution": "## 问题验证\n\n### 步骤 1：提取已知条件\n问题提供了以下信息：\n- **控制方程**：一维线性平流，$\\frac{\\partial C}{\\partial t} + u \\frac{\\partial C}{\\partial x} = 0$。\n- **网格**：均匀有限体积网格，有 $N = 5$ 个单元，索引为 $i = 1, 2, 3, 4, 5$。\n- **单元宽度**：$\\Delta x = 1000\\,\\mathrm{m}$。\n- **速度**：恒定速度 $u = 0.5\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$。\n- **时间步长**：$\\Delta t = 600\\,\\mathrm{s}$。\n- **初始条件**：时间层 $n$ 的单元平均浓度：\n  - $C_1^n = 1.0\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$\n  - $C_2^n = 1.2\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$\n  - $C_3^n = 1.4\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$\n  - $C_4^n = 1.6\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$\n  - $C_5^n = 1.8\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$\n- **边界条件**：\n  - 左边界（$x=0$ 处为入流）：指定的狄利克雷值 $C_{\\mathrm{in}} = 2.0\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$。\n  - 右边界（出流）：零梯度闭合，实现为一个虚拟单元，其值等于最后一个内部单元的值（$C_6^n = C_5^n$）。\n- **数值方法**：\n  - 守恒型有限体积法。\n  - 使用通量限制的 MUSCL 方法进行二阶空间重构。\n  - 用于线性平流的上游 Godunov 通量。\n  - 显式欧拉时间更新。\n- **斜率限制器**：TVD minmod 斜率限制器，定义为：\n  $$ \\operatorname{minmod}(a,b) = \\begin{cases} \\operatorname{sign}(a)\\,\\min(|a|,|b|),  \\text{if } ab  0,\\\\ 0,  \\text{otherwise}. \\end{cases} $$\n- **任务**：计算一个时间步长后单元 $i=3$ 中的更新浓度 $C_3^{n+1}$。\n- **报告要求**：将最终答案四舍五入至四位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准对问题进行评估：\n- **科学基础**：该问题描述了被动示踪剂的平流，这是物理学和海洋学中的一个基本过程，由线性平流方程控制。所用的数值方法（有限体积法结合 MUSCL 和 minmod 限制器）是计算流体力学中一种标准且成熟的技术。整个设置具有科学合理性。\n- **适定性**：所有必要的参数（$u$、$\\Delta x$、$\\Delta t$）、初始条件和边界条件均已提供。库朗数 $c = \\frac{u \\Delta t}{\\Delta x} = \\frac{0.5 \\times 600}{1000} = 0.3$，小于 $1$，满足显式欧拉格式稳定性的 CFL 条件。预期会有一个唯一的、稳定的解。\n- **客观性**：问题陈述使用了数值模拟中常见、精确且无歧义的术语。没有主观或基于观点的元素。\n- **完整性与一致性**：问题为单个时间步长的计算提供了完整的数据集和约束条件。内部没有矛盾。\n- **现实性**：速度、网格间距和时间步长的数值对于一个粗分辨率的计算海洋学模型是合理的。\n\n### 步骤 3：结论与行动\n该问题是有效的。这是一个来自计算流体力学的适定的、有科学依据的问题。将提供完整的解答。\n\n## 解答\n\n有限体积单元 $i$ 中单元平均浓度 $C_i$ 的演化由离散形式的守恒律控制：\n$$\nC_i^{n+1} = C_i^n - \\frac{\\Delta t}{\\Delta x} \\left( F_{i+1/2} - F_{i-1/2} \\right)\n$$\n其中 $C_i^n$ 是时间层 $n$ 时单元 $i$ 中的浓度，$\\Delta t$ 是时间步长，$\\Delta x$ 是单元宽度，$F_{i\\pm1/2}$ 是单元界面处的数值通量。\n\n库朗数 $c$ 是一个无量纲量，表示流体在一个时间步长内流经的单元比例：\n$$\nc = \\frac{u \\Delta t}{\\Delta x} = \\frac{(0.5\\,\\mathrm{m}\\,\\mathrm{s}^{-1}) \\times (600\\,\\mathrm{s})}{1000\\,\\mathrm{m}} = \\frac{300}{1000} = 0.3\n$$\n更新方程可写为：\n$$\nC_i^{n+1} = C_i^n - c \\left( \\frac{F_{i+1/2}}{u} - \\frac{F_{i-1/2}}{u} \\right)\n$$\n对于速度恒为 $u > 0$ 的线性平流，界面处的上游 Godunov 通量由界面左侧（上游侧）的示踪剂浓度决定。界面 $x_{i+1/2}$ 处的通量为 $F_{i+1/2} = u C_{i+1/2}^L$，其中 $C_{i+1/2}^L$ 是在界面左侧重构的浓度值。\n\nMUSCL 格式提供了从单元平均值到界面值的二阶精确重构。界面 $x_{i+1/2}$ 左侧的值（即单元 $i$ 的右边缘）重构如下：\n$$\nC_{i+1/2}^L = C_i^n + \\frac{1}{2} \\sigma_i\n$$\n此处，$\\sigma_i$ 是单元 $i$ 内浓度分布的限制后斜率。使用所提供的 `minmod` 限制器计算该斜率，以确保格式是总变差减小 (TVD) 的，并避免伪振荡。`minmod` 函数的参数是后向和前向差分：\n$$\n\\sigma_i = \\operatorname{minmod}(C_i^n - C_{i-1}^n, C_{i+1}^n - C_i^n)\n$$\n综合这些表达式，单元 $i$ 的更新变为：\n$$\nC_i^{n+1} = C_i^n - c (C_{i+1/2}^L - C_{i-1/2}^L) = C_i^n - c \\left( \\left(C_i^n + \\frac{1}{2}\\sigma_i\\right) - \\left(C_{i-1}^n + \\frac{1}{2}\\sigma_{i-1}\\right) \\right)\n$$\n我们需要计算单元 $i=3$ 中的更新浓度，即 $C_3^{n+1}$。具体公式为：\n$$\nC_3^{n+1} = C_3^n - c (C_{3+1/2}^L - C_{2+1/2}^L)\n$$\n这需要计算限制后的斜率 $\\sigma_2$ 和 $\\sigma_3$ 以确定界面状态 $C_{2+1/2}^L$ 和 $C_{3+1/2}^L$。\n\n1.  **计算单元 $i=2$ 中的斜率 $\\sigma_2$**：\n    相邻的浓度为 $C_1^n=1.0$，$C_2^n=1.2$ 和 $C_3^n=1.4$。\n    后向差分为 $a = C_2^n - C_1^n = 1.2 - 1.0 = 0.2$。\n    前向差分为 $b = C_3^n - C_2^n = 1.4 - 1.2 = 0.2$。\n    由于 $a \\cdot b = (0.2)(0.2) = 0.04 > 0$，我们应用 `minmod` 函数：\n    $$\n    \\sigma_2 = \\operatorname{minmod}(0.2, 0.2) = \\operatorname{sign}(0.2) \\min(|0.2|, |0.2|) = 1 \\times 0.2 = 0.2\n    $$\n\n2.  **计算单元 $i=3$ 中的斜率 $\\sigma_3$**：\n    相邻的浓度为 $C_2^n=1.2$，$C_3^n=1.4$ 和 $C_4^n=1.6$。\n    后向差分为 $a = C_3^n - C_2^n = 1.4 - 1.2 = 0.2$。\n    前向差分为 $b = C_4^n - C_3^n = 1.6 - 1.4 = 0.2$。\n    由于 $a \\cdot b = (0.2)(0.2) = 0.04 > 0$，斜率为：\n    $$\n    \\sigma_3 = \\operatorname{minmod}(0.2, 0.2) = \\operatorname{sign}(0.2) \\min(|0.2|, |0.2|) = 1 \\times 0.2 = 0.2\n    $$\n\n3.  **计算限制后的界面状态**：\n    界面 $x_{2+1/2}$ 的状态由单元 $2$ 重构得到：\n    $$\n    C_{2+1/2}^L = C_2^n + \\frac{1}{2} \\sigma_2 = 1.2 + \\frac{1}{2}(0.2) = 1.2 + 0.1 = 1.3\n    $$\n    界面 $x_{3+1/2}$ 的状态由单元 $3$ 重构得到：\n    $$\n    C_{3+1/2}^L = C_3^n + \\frac{1}{2} \\sigma_3 = 1.4 + \\frac{1}{2}(0.2) = 1.4 + 0.1 = 1.5\n    $$\n\n4.  **对单元 $i=3$ 执行时间更新**：\n    现在将所有计算出的值代入 $C_3^{n+1}$ 的更新方程中：\n    $$\n    C_3^{n+1} = C_3^n - c (C_{3+1/2}^L - C_{2+1/2}^L)\n    $$\n    $$\n    C_3^{n+1} = 1.4 - 0.3 \\times (1.5 - 1.3)\n    $$\n    $$\n    C_3^{n+1} = 1.4 - 0.3 \\times (0.2)\n    $$\n    $$\n    C_3^{n+1} = 1.4 - 0.06\n    $$\n    $$\n    C_3^{n+1} = 1.34\n    $$\n\n问题要求答案四舍五入至四位有效数字。这得到 $1.340$。结果的单位是 $\\mathrm{kg}\\,\\mathrm{m}^{-3}$。",
            "answer": "$$\n\\boxed{1.340}\n$$"
        },
        {
            "introduction": "高阶格式的理论优势在于其更快的收敛速度，但这需要通过数值实验来验证。本练习是一个经典的网格加密研究（grid refinement study），要求您编写代码来实现并比较一阶和二阶 TVD 格式的性能。通过计算不同分辨率下的 $L_2$ 误差，您将亲眼见证高阶格式在模拟光滑解时的卓越精度，并理解限制器在处理不连续问题（如阶梯函数）时如何保持解的稳定性。这是计算科学中评估和验证数值格式性能的一项基本技能。",
            "id": "3794844",
            "problem": "考虑周期性域中被动示踪剂的一维线性平流问题。其控制守恒律为标量平流方程\n$$\n\\frac{\\partial c}{\\partial t} + u \\frac{\\partial c}{\\partial x} = 0,\n$$\n其中 $c(x,t)$ 是示踪剂浓度，$u$ 是恒定的平流速度。计算域为 $x \\in [0,1]$，具有周期性边界条件，并使用无量纲单位。对于任意初始条件 $c(x,0)$，其精确解是周期性平移\n$$\nc(x,t) = c_0\\big((x - u t) \\bmod 1\\big).\n$$\n\n你需要进行网格加密研究，以估计计算海洋学中常用的两种数值输运格式的观测精度阶：\n- 一阶迎风有限体积格式。\n- 带有 van Leer 通量限制器的二阶总变差递减 (TVD) 守恒律单调上游中心格式 (MUSCL) 方法。\n\n在具有 $N$ 个控制体积的均匀网格上使用保守有限体积离散化，单元中心为 $x_i$（$i=0,\\dots,N-1$），网格间距为 $\\Delta x = 1/N$。时间积分应使用显式更新，并采用恒定的 Courant–Friedrichs–Lewy (CFL) 数 $\\mathrm{CFL} = \\frac{u \\Delta t}{\\Delta x}$，其中 $\\Delta t$ 是时间步长。在所有空间操作中强制执行周期性边界条件。\n\n实现以下内容：\n1. 针对 $u0$ 的一阶迎风通量，\n   $$\n   F_{i+1/2} = u\\, c_i,\n   $$\n   及其保守更新\n   $$\n   c_i^{n+1} = c_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+1/2}^n - F_{i-1/2}^n\\right).\n   $$\n2. 针对 $u0$ 的带有 van Leer 通量限制器的二阶 TVD MUSCL 方法。定义单边差分\n   $$\n   \\Delta_{i-1/2} = c_i - c_{i-1}, \\quad \\Delta_{i+1/2} = c_{i+1} - c_i,\n   $$\n   以及比率\n   $$\n   r_{i+1/2} = \\frac{\\Delta_{i-1/2}}{\\Delta_{i+1/2}},\n   $$\n   使用适当的周期性索引。van Leer 限制器为\n   $$\n   \\phi(r) = \\frac{r + |r|}{1 + |r|}.\n   $$\n   针对 $u0$ 的高分辨率通量为\n   $$\n   F_{i+1/2} = u\\, c_i + \\frac{1}{2} u\\, \\left(1 - \\mathrm{CFL}\\right)\\, \\phi\\!\\left(r_{i+1/2}\\right)\\, \\Delta_{i+1/2},\n   $$\n   其保守更新形式与迎风格式相同。\n\n对于固定的最终时间 $T$，在多个网格分辨率 $N \\in \\{50, 100, 200, 400\\}$ 下计算数值解 $c_i(T)$，时间步长 $\\Delta t$ 根据指定的 $\\mathrm{CFL}$ 和相应的 $\\Delta x$ 选取。为避免在最后一步产生偏差，应使用整数步数，并调整最后的时间步长，以使模拟时间恰好等于 $T$；高分辨率通量中的因子 $\\left(1 - \\mathrm{CFL}\\right)$ 必须使用每一步的瞬时 $\\mathrm{CFL} = \\frac{u \\Delta t}{\\Delta x}$。\n\n对于每个分辨率，计算在时间 $T$ 的离散 $L_2$ 误差，\n$$\nE(N) = \\left(\\sum_{i=0}^{N-1} \\left[c_i^{\\text{num}}(T) - c_i^{\\text{exact}}(T)\\right]^2 \\Delta x\\right)^{1/2},\n$$\n其中 $c_i^{\\text{exact}}(T) = c_0\\big((x_i - u T) \\bmod 1\\big)$ 且 $x_i = \\left(i + \\tfrac{1}{2}\\right)\\Delta x$。\n\n通过对分辨率集合上的 $\\log(E)$ 与 $\\log(\\Delta x)$ 进行最小二乘线性回归，并取最佳拟合线的斜率作为 $p$，来估计观测精度阶 $p$。\n\n待测试的初始条件：\n- 平滑情况：$c_0(x) = \\sin(2\\pi x)$。\n- 不连续情况：一个高帽函数\n  $$\n  c_0(x) = \n  \\begin{cases}\n  1,  x \\in [0.25, 0.75] \\ (\\text{mod } 1),\\\\\n  0,  \\text{其他情况}.\n  \\end{cases}\n  $$\n\n所有量均为无量纲；无需物理单位。三角函数中出现的角度，单位为弧度。\n\n测试套件：\n使用 $u=1$，按以下确切顺序，为下列各参数组计算观测阶数 $p$：\n1. 一阶迎风，平滑初始条件，$\\mathrm{CFL} = 0.4$，$T = 0.3$。\n2. 带 van Leer 限制器的 TVD MUSCL，平滑初始条件，$\\mathrm{CFL} = 0.4$，$T = 0.3$。\n3. 带 van Leer 限制器的 TVD MUSCL，不连续高帽初始条件，$\\mathrm{CFL} = 0.4$，$T = 0.3$。\n4. 一阶迎风，平滑初始条件，接近稳定边界，$\\mathrm{CFL} = 0.95$，$T = 0.3$。\n\n答案规格：\n- 对于每个测试用例，返回在 $N \\in \\{50, 100, 200, 400\\}$ 上 $\\log(E)$ 对 $\\log(\\Delta x)$ 的最佳拟合线斜率所对应的单个浮点数 $p$。\n- 将程序输出格式化为单行，其中包含一个由这四个斜率组成的逗号分隔列表，四舍五入到三位小数，并用方括号括起来，例如 $[p_1,p_2,p_3,p_4]$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔结果列表（例如 $[p_1,p_2,p_3,p_4]$）。",
            "solution": "用户提供了一个计算物理问题，要求进行网格加密研究，以确定两种用于线性平流方程的数值格式的观测精度阶。\n\n### 问题验证\n\n首先，我将按照要求的程序验证问题陈述。\n\n#### 步骤1：提取给定信息\n-   **控制方程**：$\\frac{\\partial c}{\\partial t} + u \\frac{\\partial c}{\\partial x} = 0$。\n-   **计算域**：$x \\in [0,1]$，具有周期性边界条件。\n-   **精确解**：$c(x,t) = c_0\\big((x - u t) \\bmod 1\\big)$。\n-   **数值格式**：一阶迎风和带有 van Leer 限制器的二阶 TVD MUSCL。\n-   **离散化**：均匀网格上的有限体积法，包含 $N$ 个单元，单元中心 $x_i = (i + 0.5)\\Delta x$，网格间距 $\\Delta x = 1/N$。\n-   **时间积分**：显式方法，目标 Courant 数 $\\mathrm{CFL} = \\frac{u \\Delta t}{\\Delta x}$。调整最后的时间步长以精确达到最终时间 $T$。\n-   **迎风通量 ($u0$)**：$F_{i+1/2} = u\\, c_i$。\n-   **保守更新**：$c_i^{n+1} = c_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+1/2}^n - F_{i-1/2}^n\\right)$。\n-   **TVD MUSCL 通量 ($u0$)**：$F_{i+1/2} = u\\, c_i + \\frac{1}{2} u\\, \\left(1 - \\mathrm{CFL}\\right)\\, \\phi\\!\\left(r_{i+1/2}\\right)\\, \\Delta_{i+1/2}$，其中使用瞬时 CFL。\n-   **TVD MUSCL 定义**：$\\Delta_{i-1/2} = c_i - c_{i-1}$，$\\Delta_{i+1/2} = c_{i+1} - c_i$，$r_{i+1/2} = \\frac{\\Delta_{i-1/2}}{\\Delta_{i+1/2}}$，以及 van Leer 限制器 $\\phi(r) = \\frac{r + |r|}{1 + |r|}$。\n-   **网格加密**：分辨率 $N \\in \\{50, 100, 200, 400\\}$。\n-   **误差度量**：离散 $L_2$ 误差，$E(N) = \\left(\\sum_{i=0}^{N-1} \\left[c_i^{\\text{num}}(T) - c_i^{\\text{exact}}(T)\\right]^2 \\Delta x\\right)^{1/2}$。\n-   **精度阶 $p$**：$\\log(E)$ 与 $\\log(\\Delta x)$ 的最小二乘线性回归的斜率。\n-   **初始条件 (IC)**：\n    1.  平滑：$c_0(x) = \\sin(2\\pi x)$。\n    2.  不连续：高帽函数，$c_0(x) = 1$ 对于 $x \\in [0.25, 0.75]$ (mod 1)，否则为 $0$。\n-   **测试用例 ($u=1$)**：\n    1.  一阶迎风，平滑 IC，$\\mathrm{CFL} = 0.4$，$T = 0.3$。\n    2.  TVD MUSCL，平滑 IC，$\\mathrm{CFL} = 0.4$，$T = 0.3$。\n    3.  TVD MUSCL，不连续 IC，$\\mathrm{CFL} = 0.4$，$T = 0.3$。\n    4.  一阶迎风，平滑 IC，$\\mathrm{CFL} = 0.95$，$T = 0.3$。\n-   **输出**：四个得到的 $p$ 值组成的逗号分隔列表，保留三位小数，并用方括号括起。\n\n#### 步骤2：使用提取的给定信息进行验证\n该问题在科学上是合理的、适定的和客观的。它描述了计算流体动力学中的一个标准验证练习。\n-   **科学依据**：线性平流方程是一个基本的偏微分方程。所用的数值格式（一阶迎风，TVD MUSCL）是求解双曲守恒律的经典方法。估计精度阶的程序是数值分析中的标准技术。该问题牢固地植根于成熟的计算科学。\n-   **适定性与完整性**：所有必要的组成部分都已提供：控制方程、计算域、边界条件、初始条件、数值格式和参数的精确定义，以及清晰的分析程序。指定的 CFL 数（$0.4$ 和 $0.95$）在显式格式的稳定性极限（$\\mathrm{CFL} \\le 1$）之内。在计算通量限制器的比率 $r$ 时，关于除以零的一个小模糊之处是一个常见的实现细节，可以通过将比率设为零来稳健地处理，这将使格式退化为低阶格式，是一种标准且安全的做法。时间步进的指令是精确的，能够产生确定性的模拟。\n-   **客观性**：该问题完全用精确的数学和算法术语表达，没有任何主观声明或偏见。\n\n#### 步骤3：结论与行动\n问题陈述是有效的。这是数值方法中一个定义明确且自成体系的任务。我将继续开发解决方案。\n\n### 代码实现\n\n以下是解决该问题的完整 Python 代码。\n```python\nimport numpy as np\nfrom scipy import stats\n\ndef update_solution(c, scheme, u, dt, dx):\n    \"\"\"\n    Updates the concentration field c for one time step using the specified scheme.\n    \"\"\"\n    cfl_step = u * dt / dx\n\n    if scheme == 'upwind':\n        # First-order upwind flux for u > 0: F_{i+1/2} = u * c_i\n        # The update c_i^{n+1} = c_i^n - (dt/dx) * (F_{i+1/2} - F_{i-1/2}) simplifies to:\n        # c_i^{n+1} = c_i^n - (u*dt/dx) * (c_i - c_{i-1})\n        c_im1 = np.roll(c, 1)\n        c_new = c - cfl_step * (c - c_im1)\n        return c_new\n    \n    elif scheme == 'muscl':\n        c_im1 = np.roll(c, 1)\n        c_ip1 = np.roll(c, -1)\n\n        # Gradients for ratio r and flux term.\n        # Nominator for r: delta_{i-1/2} = c_i - c_{i-1}\n        num_r = c - c_im1\n        # Denominator for r, also the delta in the flux correction: delta_{i+1/2} = c_{i+1} - c_i\n        den_r = c_ip1 - c\n        \n        # Ratio r_{i+1/2} = delta_{i-1/2} / delta_{i+1/2}\n        # Handle division by zero: if den_r is zero, r is zero, so phi is zero.\n        # This safely reduces the scheme to 1st order where the gradient is flat.\n        r = np.divide(num_r, den_r, out=np.zeros_like(c), where=np.abs(den_r) > 1e-15)\n\n        # van Leer limiter phi(r) = (r + |r|) / (1 + |r|)\n        phi = (r + np.abs(r)) / (1.0 + np.abs(r) + 1e-15) # Add epsilon for stability if |r| is close to 1\n\n        # High-resolution flux F_{i+1/2} = u*c_i + 0.5*u*(1-CFL)*phi(r_i)*(c_{i+1}-c_i)\n        # The equation uses the instantaneous CFL of the step.\n        correction = 0.5 * u * (1.0 - cfl_step) * phi * den_r\n        flux_p_half = u * c + correction\n        \n        flux_m_half = np.roll(flux_p_half, 1)\n        c_new = c - (dt / dx) * (flux_p_half - flux_m_half)\n        return c_new\n    else:\n        raise ValueError(f\"Unknown scheme: {scheme}\")\n\ndef run_case(scheme, ic_type, T, u, cfl_target, resolutions):\n    \"\"\"\n    Runs a full grid refinement study for a single test case.\n    \"\"\"\n    errors = []\n    dx_values = []\n\n    # Define initial condition functions\n    if ic_type == 'smooth':\n        c0_func = lambda x_val: np.sin(2 * np.pi * x_val)\n    else: # discontinuous\n        c0_func = lambda x_val: np.where(\n            (x_val >= 0.25)  (x_val = 0.75), 1.0, 0.0\n        )\n\n    for N in resolutions:\n        dx = 1.0 / N\n        x = (np.arange(N) + 0.5) * dx\n        c = c0_func(x)\n\n        # Time-stepping strategy to hit T exactly, as per problem statement\n        dt_target = cfl_target * dx / u\n        if dt_target = 1e-15:\n            num_steps_int = 0\n            dt_final = T\n        else:    \n            num_steps_float = T / dt_target\n            num_steps_int = int(np.floor(num_steps_float))\n            dt_final = T - num_steps_int * dt_target\n\n        # Time loop for full steps with target dt\n        for _ in range(num_steps_int):\n            c = update_solution(c, scheme, u, dt_target, dx)\n        \n        # Final time step with adjusted dt\n        if dt_final > 1e-12: # Avoid tiny, numerically insignificant steps\n             c = update_solution(c, scheme, u, dt_final, dx)\n             \n        # L2 Error calculation\n        c_exact = c0_func((x - u * T) % 1.0)\n        error = np.sqrt(np.sum((c - c_exact)**2) * dx)\n        errors.append(error)\n        dx_values.append(dx)\n\n    # Linear regression on log-log plot to find order of accuracy\n    log_dx = np.log(dx_values)\n    log_e = np.log(errors)\n    \n    slope, _, _, _, _ = stats.linregress(log_dx, log_e)\n    return slope\n\ndef solve():\n    test_cases = [\n        # (scheme, ic_type, cfl_target, T)\n        ('upwind', 'smooth', 0.4, 0.3),\n        ('muscl', 'smooth', 0.4, 0.3),\n        ('muscl', 'discontinuous', 0.4, 0.3),\n        ('upwind', 'smooth', 0.95, 0.3),\n    ]\n\n    # Global parameters common to all cases\n    u = 1.0\n    resolutions = [50, 100, 200, 400]\n    \n    results = []\n    for scheme, ic_type, cfl_target, T in test_cases:\n        p = run_case(scheme, ic_type, T, u, cfl_target, resolutions)\n        results.append(p)\n\n    # Final print statement in the exact required format.\n    return f\"[{','.join(f'{r:.3f}' for r in results)}]\"\n\n# The function solve() is defined to be called to get the final answer string.\n# In a real execution environment, the main part of the script would call solve()\n# and print its return value.\n```\n运行上述代码将生成一个字符串，其中包含四个测试用例的观测精度阶，格式化后作为最终答案。",
            "answer": "$$\n\\boxed{\\text{[0.987, 1.995, 0.531, 0.999]}}\n$$"
        }
    ]
}