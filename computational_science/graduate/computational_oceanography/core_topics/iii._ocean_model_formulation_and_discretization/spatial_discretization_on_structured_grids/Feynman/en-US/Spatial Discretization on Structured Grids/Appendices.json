{
    "hands_on_practices": [
        {
            "introduction": "Building accurate numerical models begins with the fundamental task of representing continuous operators, like derivatives, on a discrete grid. This practice delves into the theoretical heart of this process, guiding you through the derivation of coefficients for centered finite difference schemes of arbitrary order. By systematically matching terms in a Taylor series expansion, you will gain a first-principles understanding of how these essential numerical building blocks are constructed .",
            "id": "3810594",
            "problem": "Consider the one-dimensional zonal gradient of a smooth tracer field $u(x)$ sampled on a uniform, structured ocean model grid with spacing $h$. You wish to approximate $\\partial_{x} u$ at a grid point $x_{i}$ using a centered stencil of width $2m+1$ points, with $m \\in \\mathbb{N}$, via\n$$\n\\partial_{x} u(x_{i}) \\approx \\frac{1}{h} \\sum_{j=-m}^{m} c_{j} \\, u(x_{i} + j h),\n$$\nwhere the coefficients $c_{j}$ are dimensionless and independent of $h$ and $x_{i}$. Using Taylor series matching conditions about $x_{i}$, derive the coefficients $c_{j}$ that yield a truncation error of order $\\mathcal{O}(h^{2m})$ for $\\partial_{x} u(x_{i})$ on this uniform grid. Your derivation should start from the Taylor expansion of $u(x_{i} + j h)$ about $x_{i}$, impose exactness for polynomials up to degree $2m$, and enforce the necessary symmetry properties implied by a centered stencil for the first derivative. Express your final result as a single closed-form analytical expression for $c_{j}$ in terms of $m$ and $j$.\n\nNo numerical values are required. Provide the expression for general $m$ and $j$. The final answer must be a single closed-form analytical expression (no units).",
            "solution": "To find the coefficients $c_j$ for the finite difference approximation\n$$ \\partial_{x} u(x_{i}) \\approx \\frac{1}{h} \\sum_{j=-m}^{m} c_{j} u(x_{i} + j h) $$\nsuch that the approximation has a truncation error of order $\\mathcal{O}(h^{2m})$, we can require the formula to be exact for polynomials of degree up to $2m$. This is equivalent to matching terms in the Taylor series expansion of the approximation to the Taylor series of the exact derivative.\n\nExpanding $u(x_{i} + jh)$ in a Taylor series about $x_i$ and substituting into the formula gives:\n$$ \\sum_{k=0}^{\\infty} \\frac{h^{k-1}}{k!} u^{(k)}(x_i) \\left( \\sum_{j=-m}^{m} c_j j^k \\right) $$\nwhere $u^{(k)}(x_i)$ is the $k$-th derivative. To approximate $\\partial_x u(x_i) = u^{(1)}(x_i)$ with the desired accuracy, the term in the parenthesis must satisfy:\n$$ \\sum_{j=-m}^{m} c_j j^k = \\delta_{k,1}, \\quad \\text{for } k = 0, 1, 2, \\dots, 2m $$\nwhere $\\delta_{k,1}$ is the Kronecker delta.\n\nAn elegant method to solve this system is by considering the derivative of a Lagrange interpolating polynomial $P(x)$ of degree $2m$ that passes through the stencil points. The approximation to the derivative is then $u'(x_i) \\approx P'(x_i)$. In a local coordinate $s = (x-x_i)/h$, the Lagrange basis polynomial for node $j$ is $\\ell_j(s) = \\prod_{k \\neq j} \\frac{s-k}{j-k}$. The derivative approximation becomes:\n$$ P'(x_i) = \\frac{1}{h} \\sum_{j=-m}^{m} u(x_i+jh) \\ell_j'(0) $$\nComparing this to the target formula, we identify the coefficients as $c_j = \\ell_j'(0)$.\n\nFor a centered stencil approximating a first derivative, the coefficients must be anti-symmetric, $c_{-j} = -c_j$, which implies $c_0 = 0$. For $j \\neq 0$, the calculation of $\\ell_j'(0)$ yields:\n$$ c_j = \\frac{(-1)^{j+1}}{j} \\frac{(m!)^2}{(m+j)!(m-j)!} $$\nThis expression is valid for $j \\in \\{-m, \\ldots, -1, 1, \\ldots, m\\}$. This formula provides the coefficients for the $(2m+1)$-point centered difference for the first derivative, accurate to order $\\mathcal{O}(h^{2m})$.",
            "answer": "$$\n\\boxed{\\frac{(-1)^{j+1}}{j} \\frac{(m!)^2}{(m+j)!(m-j)!}}\n$$"
        },
        {
            "introduction": "After constructing a numerical scheme, it is crucial to analyze its performance and understand its inherent limitations. This exercise introduces modified wavenumber analysis, a powerful diagnostic tool that reveals how a scheme distorts the representation of waves, leading to numerical dispersion and dissipation. By applying this analysis to common advection schemes, you will learn to quantify their accuracy and predict their behavior in a practical simulation context .",
            "id": "3810592",
            "problem": "Consider linear advection of a passive tracer in one spatial dimension on a uniform, structured grid. The governing equation is the linear advection equation, a well-tested foundation for geophysical transport, given by $$\\frac{\\partial T}{\\partial t} + c \\frac{\\partial T}{\\partial x} = 0,$$ where $T(x,t)$ is the tracer concentration and $c$ is a constant background velocity. The domain is discretized by a uniform grid with spacing $\\Delta x$ and grid points $x_i = i \\Delta x$, where $i$ is an integer index.\n\nAssume a sinusoidal tracer profile with physical wavenumber $k$ given by $$T(x,0) = A \\sin(k x),$$ where $A$ is a real amplitude and $k = \\frac{2\\pi}{\\lambda}$ for physical wavelength $\\lambda$. In discrete modified wavenumber analysis, we analyze the action of a discrete spatial derivative operator on the complex Fourier mode $$T_i = \\exp(\\mathrm{i} k x_i) = \\exp(\\mathrm{i} i \\theta),$$ where $\\theta = k \\Delta x$. For any linear, translation-invariant finite difference operator approximating $\\frac{\\partial}{\\partial x}$, its action on $T_i$ is equivalent to multiplication by a complex symbol $S(\\theta)$, defined by $$D[T]_i = S(\\theta) \\, T_i.$$ The exact derivative corresponds to $S_{\\text{exact}}(\\theta) = \\mathrm{i} k$. The discrete modified wavenumber $k^\\ast$ is defined so that $$\\mathrm{i} k^\\ast = S(\\theta),$$ and therefore $$k^\\ast = -\\mathrm{i} S(\\theta).$$ The real part $\\operatorname{Re}(k^\\ast)$ characterizes numerical dispersion, and the imaginary part $\\operatorname{Im}(k^\\ast)$ characterizes numerical dissipation induced by the spatial discretization. The semi-discrete amplitude evolution under the linear advection equation is governed by the growth (or decay) rate $$\\sigma = c \\, \\operatorname{Im}(k^\\ast),$$ which has units of inverse seconds and is negative for dissipative schemes when $c > 0$.\n\nYour task is to derive and implement the symbols $S(\\theta)$ and the associated modified wavenumber $k^\\ast$ and dissipation rate $\\sigma$ for the following two upwind schemes suitable for $c > 0$:\n\n- First-order upwind scheme (one-sided, using points $\\{x_i, x_{i-1}\\}$), which is consistent and first-order accurate in space.\n- Third-order upwind-biased scheme (one-sided, using points $\\{x_i, x_{i-1}, x_{i-2}, x_{i-3}\\}$), which is consistent and third-order accurate in space.\n\nStarting from the definition of order conditions via Taylor expansion about $x_i$ on a uniform mesh, derive the finite difference coefficients for each scheme that ensure the targeted spatial accuracy and consistency. Then, using the discrete Fourier mode $T_i = \\exp(\\mathrm{i} i \\theta)$, construct the corresponding discrete symbols $S(\\theta)$, compute $$k^\\ast(\\theta) = -\\mathrm{i} S(\\theta),$$ and evaluate $$\\sigma(\\theta) = c \\, \\operatorname{Im}\\big(k^\\ast(\\theta)\\big).$$ Report $\\operatorname{Re}(k^\\ast)$ and $\\operatorname{Im}(k^\\ast)$ in radians per meter and $\\sigma$ in inverse seconds.\n\nImplement a program that evaluates these quantities for the following test suite, which probes different resolution regimes:\n\n- Case $1$: $\\Delta x = 1000$ meters, $\\lambda = 10000$ meters, $c = 0.5$ meters per second.\n- Case $2$: $\\Delta x = 1000$ meters, $\\lambda = 2000$ meters, $c = 0.5$ meters per second.\n- Case $3$: $\\Delta x = 5000$ meters, $\\lambda = 500000$ meters, $c = 0.2$ meters per second.\n- Case $4$: $\\Delta x = 1000$ meters, $\\lambda = 4000$ meters, $c = 0.5$ meters per second.\n\nFor each case, compute and return a single list containing the six floats $$\\big[\\operatorname{Re}(k^\\ast_{\\text{FOU}}), \\operatorname{Im}(k^\\ast_{\\text{FOU}}), \\sigma_{\\text{FOU}}, \\operatorname{Re}(k^\\ast_{\\text{U3}}), \\operatorname{Im}(k^\\ast_{\\text{U3}}), \\sigma_{\\text{U3}}\\big],$$ where $\\text{FOU}$ denotes the first-order upwind scheme and $\\text{U3}$ denotes the third-order upwind-biased scheme. Values must be expressed with $\\operatorname{Re}(k^\\ast)$ and $\\operatorname{Im}(k^\\ast)$ in radians per meter and $\\sigma$ in inverse seconds, each rounded to $8$ decimal places.\n\nYour program should produce a single line of output containing the results for all cases as a comma-separated list of lists enclosed in square brackets, for example $$[\\text{case1\\_list},\\text{case2\\_list},\\text{case3\\_list},\\text{case4\\_list}].$$ No other output is permitted.",
            "solution": "The problem requires the derivation and implementation of the modified wavenumber $k^\\ast$ and the numerical dissipation rate $\\sigma$ for two upwind finite difference schemes used to approximate the spatial derivative in the linear advection equation, $\\frac{\\partial T}{\\partial t} + c \\frac{\\partial T}{\\partial x} = 0$. The analysis is performed on a uniform grid with spacing $\\Delta x$ for a discrete Fourier mode $T_i = \\exp(\\mathrm{i} k x_i) = \\exp(\\mathrm{i} i \\theta)$, where $\\theta = k \\Delta x$ is the dimensionless wavenumber.\n\nThe general form of a finite difference approximation to $\\frac{\\partial T}{\\partial x}$ at grid point $x_i$ is given by\n$$\nD[T]_i = \\frac{1}{\\Delta x} \\sum_{j} a_j T_{i+j}\n$$\nThe coefficients $a_j$ are determined by expanding each $T_{i+j}$ in a Taylor series about $x_i$ and matching the coefficients of the resulting expansion to the Taylor series of the exact derivative, which is simply $T'(x_i)$. The action of this discrete operator on the Fourier mode $T_i$ is $D[T]_i = S(\\theta) T_i$, where $S(\\theta)$ is the symbol of the operator. The modified wavenumber $k^\\ast$ is then defined as $k^\\ast = -\\mathrm{i} S(\\theta)$, and the dissipation rate is $\\sigma = c \\, \\operatorname{Im}(k^\\ast)$.\n\n### First-Order Upwind (FOU) Scheme\n\nThis scheme uses the stencil $\\{x_i, x_{i-1}\\}$ for a positive velocity $c > 0$. The approximation is\n$$\n\\frac{\\partial T}{\\partial x} \\bigg|_{x_i} \\approx \\frac{T_i - T_{i-1}}{\\Delta x}\n$$\nTo find the symbol $S_{\\text{FOU}}(\\theta)$, we apply the operator to $T_i = \\exp(\\mathrm{i} i \\theta)$:\n$$\nD_{\\text{FOU}}[e^{\\mathrm{i} i \\theta}]_i = \\frac{e^{\\mathrm{i} i \\theta} - e^{\\mathrm{i} (i-1) \\theta}}{\\Delta x} = \\frac{e^{\\mathrm{i} i \\theta}(1 - e^{-\\mathrm{i}\\theta})}{\\Delta x}\n$$\nThus, the symbol is $S_{\\text{FOU}}(\\theta) = \\frac{1 - e^{-\\mathrm{i}\\theta}}{\\Delta x}$. The modified wavenumber $k^\\ast_{\\text{FOU}}$ is:\n$$\nk^\\ast_{\\text{FOU}} = -\\mathrm{i} S_{\\text{FOU}}(\\theta) = -\\mathrm{i} \\frac{1 - (\\cos\\theta - \\mathrm{i}\\sin\\theta)}{\\Delta x} = \\frac{\\sin\\theta - \\mathrm{i}(1-\\cos\\theta)}{\\Delta x}\n$$\nThe real and imaginary parts are $\\operatorname{Re}(k^\\ast_{\\text{FOU}}) = \\frac{\\sin\\theta}{\\Delta x}$ and $\\operatorname{Im}(k^\\ast_{\\text{FOU}}) = -\\frac{1-\\cos\\theta}{\\Delta x}$. The dissipation rate is $\\sigma_{\\text{FOU}} = c \\operatorname{Im}(k^\\ast_{\\text{FOU}})$.\n\n### Third-Order Upwind-biased (U3) Scheme\n\nThis scheme uses the stencil $\\{x_i, x_{i-1}, x_{i-2}, x_{i-3}\\}$ and is third-order accurate. The coefficients derived from Taylor series expansion are $a_0 = 11/6, a_{-1} = -3, a_{-2} = 3/2, a_{-3} = -1/3$. The scheme is:\n$$\nD_{\\text{U3}}[T]_i = \\frac{1}{\\Delta x} \\left( \\frac{11}{6} T_i - 3 T_{i-1} + \\frac{3}{2} T_{i-2} - \\frac{1}{3} T_{i-3} \\right)\n$$\nThe symbol is $S_{\\text{U3}}(\\theta) = \\frac{1}{\\Delta x} \\left( \\frac{11}{6} - 3 e^{-\\mathrm{i}\\theta} + \\frac{3}{2} e^{-2\\mathrm{i}\\theta} - \\frac{1}{3} e^{-3\\mathrm{i}\\theta} \\right)$.\nThe modified wavenumber $k^\\ast_{\\text{U3}}$ is $k^\\ast_{\\text{U3}} = -\\mathrm{i} S_{\\text{U3}}(\\theta)$. Separating the real and imaginary parts gives:\n$$\n\\operatorname{Re}(k^\\ast_{\\text{U3}}) = \\frac{1}{\\Delta x} \\left( 3\\sin\\theta - \\frac{3}{2}\\sin(2\\theta) + \\frac{1}{3}\\sin(3\\theta) \\right)\n$$\n$$\n\\operatorname{Im}(k^\\ast_{\\text{U3}}) = -\\frac{1}{\\Delta x} \\left( \\frac{11}{6} - 3\\cos\\theta + \\frac{3}{2}\\cos(2\\theta) - \\frac{1}{3}\\cos(3\\theta) \\right)\n$$\nThe dissipation rate is $\\sigma_{\\text{U3}} = c \\operatorname{Im}(k^\\ast_{\\text{U3}})$. The implementation evaluates these formulas for the specified test cases.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and calculates modified wavenumber and dissipation rates for FOU and U3 schemes.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (delta_x, lambda, c)\n        (1000.0, 10000.0, 0.5),\n        (1000.0, 2000.0, 0.5),\n        (5000.0, 500000.0, 0.2),\n        (1000.0, 4000.0, 0.5),\n    ]\n\n    results = []\n    for dx, lam, c in test_cases:\n        # Calculate physical and dimensionless wavenumbers\n        k = 2 * np.pi / lam\n        theta = k * dx\n\n        # --- First-Order Upwind (FOU) Scheme ---\n        # Re(k*) = (1/dx) * sin(theta)\n        # Im(k*) = -(1/dx) * (1 - cos(theta))\n        # sigma = c * Im(k*)\n        \n        re_k_star_fou = (1 / dx) * np.sin(theta)\n        im_k_star_fou = -(1 / dx) * (1 - np.cos(theta))\n        sigma_fou = c * im_k_star_fou\n        \n        # --- Third-Order Upwind-Biased (U3) Scheme ---\n        # Re(k*) = (1/dx) * (3*sin(theta) - 1.5*sin(2*theta) + (1/3)*sin(3*theta))\n        # Im(k*) = -(1/dx) * (11/6 - 3*cos(theta) + 1.5*cos(2*theta) - (1/3)*cos(3*theta))\n        # sigma = c * Im(k*)\n\n        re_k_star_u3 = (1 / dx) * (\n            3 * np.sin(theta) - 1.5 * np.sin(2 * theta) + (1 / 3) * np.sin(3 * theta)\n        )\n        \n        im_k_star_u3 = -(1 / dx) * (\n            11 / 6\n            - 3 * np.cos(theta)\n            + 1.5 * np.cos(2 * theta)\n            - (1 / 3) * np.cos(3 * theta)\n        )\n        \n        sigma_u3 = c * im_k_star_u3\n        \n        # Collect results for the current case\n        case_result = [\n            re_k_star_fou, im_k_star_fou, sigma_fou,\n            re_k_star_u3, im_k_star_u3, sigma_u3\n        ]\n        results.append(case_result)\n\n    # Format the final output string as a list of lists, with each value\n    # rounded to 8 decimal places and no spaces within the sublists.\n    case_strings = []\n    for case_result in results:\n        # Format each float to 8 decimal places and join into a comma-separated string\n        s = \",\".join(f\"{val:.8f}\" for val in case_result)\n        case_strings.append(f\"[{s}]\")\n    \n    final_output = f\"[{','.join(case_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "The long-term stability and physical realism of an ocean model depend critically on its ability to conserve fundamental quantities like energy and enstrophy. This exercise demonstrates how this can be achieved through sophisticated scheme design, focusing on the celebrated Arakawa Jacobian for the barotropic vorticity equation. You will verify computationally that this scheme, by its very structure, maintains discrete analogues of key physical invariants, a property essential for preventing non-physical drifts in climate and ocean simulations .",
            "id": "3810632",
            "problem": "You are tasked with deriving and verifying discrete conservation of energy and enstrophy for the barotropic vorticity equation on a two-dimensional periodic, structured grid using the Arakawa Jacobian scheme. The goal is to show, from first principles, that the discrete formulation conserves these invariants in the absence of external forcing and diffusion, and to implement a program that numerically verifies the conservation properties on several test cases.\n\nStart from the continuous, inviscid barotropic vorticity equation on an $f$-plane (constant Coriolis parameter):\n$$\n\\frac{\\partial \\zeta}{\\partial t} + J(\\psi, \\zeta) = 0,\n$$\nwhere $\\zeta$ is the relative vorticity, $\\psi$ is the streamfunction, and $J(\\psi, \\zeta)$ is the Jacobian operator $J(\\psi,\\zeta) = \\psi_x \\zeta_y - \\psi_y \\zeta_x$. For a two-dimensional, incompressible flow, the velocity field is defined via the streamfunction as $u = -\\partial \\psi / \\partial y$ and $v = \\partial \\psi / \\partial x$, and the relative vorticity satisfies $\\zeta = \\nabla^2 \\psi$.\n\nDefine the continuous invariants:\n- The kinetic energy per unit density:\n$$\nE = \\frac{1}{2} \\int_{\\Omega} |\\nabla \\psi|^2 \\, dA = -\\frac{1}{2}\\int_{\\Omega} \\psi \\, \\zeta \\, dA,\n$$\nunder periodic boundary conditions.\n- The enstrophy:\n$$\nZ = \\frac{1}{2} \\int_{\\Omega} \\zeta^2 \\, dA.\n$$\n\nDiscretize the domain on a uniform, periodic, structured grid with $N_x$ points in the $x$-direction, $N_y$ points in the $y$-direction, and grid spacings $d_x$ and $d_y$, respectively. Denote discrete fields at cell centers by arrays $\\psi_{j,i}$ and $\\zeta_{j,i}$, with $0 \\leq i \\leq N_x - 1$ and $0 \\leq j \\leq N_y - 1$, and impose periodicity in both directions. Use second-order central differences for spatial derivatives. The discrete Laplacian is\n$$\n\\zeta_{j,i} = \\frac{\\psi_{j,i+1} - 2\\psi_{j,i} + \\psi_{j,i-1}}{d_x^2} + \\frac{\\psi_{j+1,i} - 2\\psi_{j,i} + \\psi_{j-1,i}}{d_y^2},\n$$\nwith indices wrapped periodically. The Arakawa Jacobian $J^{A}(\\psi,\\zeta)$ at each grid point is defined as the average of three second-order discrete forms:\n$$\nJ^{A}(\\psi,\\zeta) = \\frac{1}{3}\\left(J_1 + J_2 + J_3\\right),\n$$\nwhere\n$$\nJ_1 = \\frac{(\\psi_{j,i+1}-\\psi_{j,i-1})(\\zeta_{j+1,i}-\\zeta_{j-1,i}) - (\\psi_{j+1,i}-\\psi_{j-1,i})(\\zeta_{j,i+1}-\\zeta_{j,i-1})}{4 d_x d_y},\n$$\n$$\nJ_2 = \\frac{\\psi_{j,i+1}(\\zeta_{j+1,i+1}-\\zeta_{j-1,i+1}) - \\psi_{j,i-1}(\\zeta_{j+1,i-1}-\\zeta_{j-1,i-1}) - \\psi_{j+1,i}(\\zeta_{j+1,i+1}-\\zeta_{j+1,i-1}) + \\psi_{j-1,i}(\\zeta_{j-1,i+1}-\\zeta_{j-1,i-1})}{4 d_x d_y},\n$$\n$$\nJ_3 = \\frac{\\zeta_{j,i+1}(\\psi_{j+1,i+1}-\\psi_{j-1,i+1}) - \\zeta_{j,i-1}(\\psi_{j+1,i-1}-\\psi_{j-1,i-1}) - \\zeta_{j+1,i}(\\psi_{j+1,i+1}-\\psi_{j+1,i-1}) + \\zeta_{j-1,i}(\\psi_{j-1,i+1}-\\psi_{j-1,i-1})}{4 d_x d_y},\n$$\nwith all indices interpreted periodically modulo $N_x$ and $N_y$.\n\nUnder periodic boundary conditions, the Arakawa Jacobian is designed so that the following discrete inner products vanish, which ensures conservation of discrete energy and enstrophy in the absence of forcing and diffusion:\n$$\n\\sum_{j,i} \\psi_{j,i} \\, J^{A}(\\psi,\\zeta)_{j,i} \\, d_x d_y = 0, \\quad \\sum_{j,i} \\zeta_{j,i} \\, J^{A}(\\psi,\\zeta)_{j,i} \\, d_x d_y = 0.\n$$\nThe discrete energy and enstrophy are computed as\n$$\nE_d = -\\frac{1}{2}\\sum_{j,i} \\psi_{j,i} \\, \\zeta_{j,i} \\, d_x d_y, \\quad Z_d = \\frac{1}{2}\\sum_{j,i} \\zeta_{j,i}^2 \\, d_x d_y.\n$$\n\nYour program must:\n1. Construct test streamfunctions $\\psi_{j,i}$ on periodic grids as specified below.\n2. Compute $\\zeta$ using the discrete Laplacian.\n3. Compute $J^{A}(\\psi,\\zeta)$ using the Arakawa scheme.\n4. Compute the discrete inner products $S_\\psi = \\sum \\psi \\, J^{A}(\\psi,\\zeta) \\, d_x d_y$ and $S_\\zeta = \\sum \\zeta \\, J^{A}(\\psi,\\zeta) \\, d_x d_y$.\n5. For each test case, return a boolean that is true if both $|S_\\psi|$ and $|S_\\zeta|$ are less than a fixed absolute tolerance $T$ and false otherwise. Use $T = 10^{-9}$ in dimensionless units. All quantities are treated as dimensionless for this assignment; no physical units are to be used.\n\nTest Suite:\n- Case 1 (happy path): $N_x = 32$, $N_y = 32$, $d_x = 1.0$, $d_y = 1.0$. Initialize $\\psi_{j,i} = \\sin\\left(2\\pi k_x x_i / L_x\\right) \\sin\\left(2\\pi k_y y_j / L_y\\right)$ with $k_x=4$, $k_y=5$, $x_i = i d_x$, $y_j = j d_y$, $L_x = N_x d_x$, and $L_y = N_y d_y$.\n- Case 2 (anisotropic grid): $N_x = 64$, $N_y = 48$, $d_x = 1.0$, $d_y = 2.0$. Initialize $\\psi$ with a reproducible pseudorandom field drawn from a standard normal distribution with seed $42$.\n- Case 3 (uniform field edge case): $N_x = 16$, $N_y = 16$, $d_x = 1.0$, $d_y = 1.0$. Initialize $\\psi_{j,i} = c$ with $c = 2.0$ (constant).\n- Case 4 (minimal periodic resolution): $N_x = 3$, $N_y = 3$, $d_x = 1.0$, $d_y = 1.0$. Initialize $\\psi_{j,i} = i + 2 j$ (a simple linear pattern wrapped periodically).\n- Case 5 (odd sizes, mixed modes): $N_x = 33$, $N_y = 31$, $d_x = 0.5$, $d_y = 0.7$. Initialize $\\psi_{j,i} = \\cos\\left(2\\pi m x_i / L_x\\right) + 0.5 \\sin\\left(2\\pi n y_j / L_y\\right)$ with $m=3$ and $n=7$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, such as \"[result1,result2,result3,result4,result5]\". Each result must be a boolean indicating whether both inner products are below the tolerance for the corresponding test case.",
            "solution": "The time evolution of the continuous kinetic energy $E$ and enstrophy $Z$ for the inviscid barotropic vorticity equation on a periodic domain $\\Omega$ is governed by the properties of the Jacobian operator, $J(\\psi, \\zeta)$. Differentiating the invariants with respect to time and substituting the vorticity equation $\\zeta_t = -J(\\psi, \\zeta)$ yields:\n$$ \\frac{dE}{dt} = \\int_{\\Omega} \\psi J(\\psi, \\zeta) \\, dA $$\n$$ \\frac{dZ}{dt} = -\\int_{\\Omega} \\zeta J(\\psi, \\zeta) \\, dA $$\nConservation of energy and enstrophy ($dE/dt = 0$, $dZ/dt = 0$) depends on the integral properties of the Jacobian. For the continuous operator, these integrals are zero over a periodic domain.\n\nWhen discretizing the equations, the goal is to find a discrete Jacobian operator $J^A$ that mimics these crucial conservation properties. The time derivatives of the discrete energy $E_d$ and enstrophy $Z_d$ are proportional to the sums over all grid points:\n$$ \\frac{dE_d}{dt} \\propto \\sum_{j,i} \\psi_{j,i} J^A_{j,i}, \\quad \\frac{dZ_d}{dt} \\propto \\sum_{j,i} \\zeta_{j,i} J^A_{j,i} $$\nConservation requires these sums to be zero. Arakawa's scheme is constructed as a specific average of three different second-order accurate stencils ($J_1$, $J_2$, and $J_3$) precisely to satisfy these discrete conservation laws. The underlying principle is summation by parts (the discrete analogue of integration by parts), which causes terms to cancel perfectly when summed over a periodic grid. In floating-point arithmetic, these sums should be zero to within machine precision.\n\nThe verification program implements the following steps for each test case:\n1.  **Grid and Field Generation**: Construct the two-dimensional grid and initialize the streamfunction array $\\psi_{j,i}$ as specified.\n2.  **Vorticity Calculation**: Compute the relative vorticity field $\\zeta_{j,i}$ by applying the second-order discrete Laplacian to $\\psi_{j,i}$, handling periodic boundaries using array-shifting operations.\n3.  **Arakawa Jacobian Calculation**: Evaluate the three components $J_1$, $J_2$, and $J_3$ at each grid point using stencils that access first, second, and diagonal neighbors. The final Jacobian $J^A$ is the average of the three components.\n4.  **Conservation Check**: Compute the two inner products $S_\\psi = d_x d_y \\sum_{j,i} \\psi_{j,i} J^A_{j,i}$ and $S_\\zeta = d_x d_y \\sum_{j,i} \\zeta_{j,i} J^A_{j,i}$.\n5.  **Verification**: Compare the absolute values of $S_\\psi$ and $S_\\zeta$ against the specified tolerance $T=10^{-9}$. The case passes if both sums are below the tolerance. This numerically verifies the conservation properties of the Arakawa Jacobian.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and verifies discrete conservation of energy and enstrophy for the\n    barotropic vorticity equation using the Arakawa Jacobian scheme.\n    \"\"\"\n    \n    test_cases = [\n        {'Nx': 32, 'Ny': 32, 'dx': 1.0, 'dy': 1.0, 'case_type': 'sinsin', 'params': {'kx': 4, 'ky': 5}},\n        {'Nx': 64, 'Ny': 48, 'dx': 1.0, 'dy': 2.0, 'case_type': 'random', 'params': {'seed': 42}},\n        {'Nx': 16, 'Ny': 16, 'dx': 1.0, 'dy': 1.0, 'case_type': 'constant', 'params': {'c': 2.0}},\n        {'Nx': 3, 'Ny': 3, 'dx': 1.0, 'dy': 1.0, 'case_type': 'linear', 'params': {}},\n        {'Nx': 33, 'Ny': 31, 'dx': 0.5, 'dy': 0.7, 'case_type': 'mixed_modes', 'params': {'m': 3, 'n': 7}}\n    ]\n    \n    TOLERANCE = 1e-9\n    results = []\n\n    for case in test_cases:\n        Nx, Ny, dx, dy = case['Nx'], case['Ny'], case['dx'], case['dy']\n        Lx, Ly = Nx * dx, Ny * dy\n\n        # 1. Construct test streamfunctions\n        x = np.arange(Nx) * dx\n        y = np.arange(Ny) * dy\n        xx, yy = np.meshgrid(x, y)\n        \n        psi = np.zeros((Ny, Nx))\n        \n        if case['case_type'] == 'sinsin':\n            kx, ky = case['params']['kx'], case['params']['ky']\n            psi = np.sin(2 * np.pi * kx * xx / Lx) * np.sin(2 * np.pi * ky * yy / Ly)\n        elif case['case_type'] == 'random':\n            seed = case['params']['seed']\n            rng = np.random.default_rng(seed)\n            psi = rng.standard_normal((Ny, Nx))\n        elif case['case_type'] == 'constant':\n            psi.fill(case['params']['c'])\n        elif case['case_type'] == 'linear':\n            psi = xx + 2 * yy\n        elif case['case_type'] == 'mixed_modes':\n            m, n = case['params']['m'], case['params']['n']\n            psi = np.cos(2 * np.pi * m * xx / Lx) + 0.5 * np.sin(2 * np.pi * n * yy / Ly)\n\n        # 2. Compute vorticity using discrete Laplacian\n        psi_ip1 = np.roll(psi, -1, axis=1)\n        psi_im1 = np.roll(psi, 1, axis=1)\n        psi_jp1 = np.roll(psi, -1, axis=0)\n        psi_jm1 = np.roll(psi, 1, axis=0)\n        \n        zeta = (psi_ip1 - 2*psi + psi_im1) / (dx**2) + \\\n               (psi_jp1 - 2*psi + psi_jm1) / (dy**2)\n               \n        # 3. Compute Arakawa Jacobian\n        # Pre-compute all shifted fields for clarity and efficiency\n        zeta_ip1 = np.roll(zeta, -1, axis=1)\n        zeta_im1 = np.roll(zeta, 1, axis=1)\n        zeta_jp1 = np.roll(zeta, -1, axis=0)\n        zeta_jm1 = np.roll(zeta, 1, axis=0)\n        \n        psi_jp1_ip1 = np.roll(psi, (-1, -1), axis=(0, 1))\n        psi_jm1_ip1 = np.roll(psi, (1, -1), axis=(0, 1))\n        psi_jp1_im1 = np.roll(psi, (-1, 1), axis=(0, 1))\n        psi_jm1_im1 = np.roll(psi, (1, 1), axis=(0, 1))\n\n        zeta_jp1_ip1 = np.roll(zeta, (-1, -1), axis=(0, 1))\n        zeta_jm1_ip1 = np.roll(zeta, (1, -1), axis=(0, 1))\n        zeta_jp1_im1 = np.roll(zeta, (-1, 1), axis=(0, 1))\n        zeta_jm1_im1 = np.roll(zeta, (1, 1), axis=(0, 1))\n\n        # J1\n        j1 = ((psi_ip1 - psi_im1) * (zeta_jp1 - zeta_jm1) - \n              (psi_jp1 - psi_jm1) * (zeta_ip1 - zeta_im1)) / (4 * dx * dy)\n        \n        # J2\n        j2 = (psi_ip1 * (zeta_jp1_ip1 - zeta_jm1_ip1) - \n              psi_im1 * (zeta_jp1_im1 - zeta_jm1_im1) -\n              psi_jp1 * (zeta_jp1_ip1 - zeta_jp1_im1) +\n              psi_jm1 * (zeta_jm1_ip1 - zeta_jm1_im1)) / (4 * dx * dy)\n\n        # J3\n        j3 = (zeta_ip1 * (psi_jp1_ip1 - psi_jm1_ip1) -\n              zeta_im1 * (psi_jp1_im1 - psi_jm1_im1) -\n              zeta_jp1 * (psi_jp1_ip1 - psi_jp1_im1) +\n              zeta_jm1 * (psi_jm1_ip1 - psi_jm1_im1)) / (4 * dx * dy)\n\n        j_arakawa = (j1 + j2 + j3) / 3.0\n\n        # 4. Compute discrete inner products\n        s_psi = np.sum(psi * j_arakawa) * dx * dy\n        s_zeta = np.sum(zeta * j_arakawa) * dx * dy\n        \n        # 5. Verify conservation\n        is_conserved = abs(s_psi)  TOLERANCE and abs(s_zeta)  TOLERANCE\n        results.append(is_conserved)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}