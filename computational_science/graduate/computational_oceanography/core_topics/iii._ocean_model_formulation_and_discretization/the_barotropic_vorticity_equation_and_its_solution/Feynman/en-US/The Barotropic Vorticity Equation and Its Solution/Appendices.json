{
    "hands_on_practices": [
        {
            "introduction": "This practice connects the abstract barotropic vorticity equation to a cornerstone of physical oceanography: the Sverdrup balance. By deriving this famous relation and applying it with realistic parameters, you will gain a tangible understanding of how large-scale wind patterns drive the slow, broad interior flow of ocean gyres . This exercise solidifies the physical intuition behind the vorticity dynamics that govern basin-scale circulation.",
            "id": "3813697",
            "problem": "Consider a rectangular, midlatitude ocean interior on a $\\beta$-plane with constant reference density $\\rho_{0}$ and uniform depth $H$. Assume a steady state, Boussinesq, hydrostatic ocean in which the interior vorticity balance is governed by the depth-integrated, linear, barotropic vorticity dynamics away from boundaries. The wind stress is purely zonal and varies meridionally as\n$$\n\\tau_{x}(y) \\;=\\; \\tau_{0}\\,\\sin\\!\\left(\\frac{2\\pi\\, y}{L_{y}}\\right), \n\\qquad \n\\tau_{y}(x,y)\\;=\\;0,\n$$\nfor $0 \\le y \\le L_{y}$, with $\\tau_{0} > 0$. Use parameters characteristic of the subtropical gyre interior:\n$$\n\\beta \\;=\\; 2.0 \\times 10^{-11}\\ \\mathrm{m}^{-1}\\,\\mathrm{s}^{-1},\\quad \n\\rho_{0} \\;=\\; 1025\\ \\mathrm{kg}\\,\\mathrm{m}^{-3},\\quad \nH \\;=\\; 4000\\ \\mathrm{m},\\quad \n\\tau_{0} \\;=\\; 0.10\\ \\mathrm{N}\\,\\mathrm{m}^{-2},\\quad \nL_{y} \\;=\\; 3.0 \\times 10^{6}\\ \\mathrm{m}.\n$$\n\nStarting from appropriate depth-integrated laws that are valid for this setting, derive the steady interior relation linking the depth-averaged meridional velocity $v(y)$ to the wind-stress curl. Then, using that relation, evaluate the interior depth-averaged meridional velocity at $y = L_{y}/3$. Round your final numerical answer to four significant figures and express it in $\\mathrm{m}\\,\\mathrm{s}^{-1}$. In your derivation, clearly state the assumptions that permit neglect of terms and briefly explain how the magnitude of $v$ depends on $H$ in this interior balance.",
            "solution": "The problem is evaluated to be scientifically grounded, well-posed, objective, and contains a complete and consistent setup. The parameters are physically realistic for the specified oceanographic context. Therefore, the problem is deemed valid and a full solution can be constructed.\n\nThe problem asks for the derivation of the steady, interior meridional velocity from the governing dynamics of a barotropic ocean on a $\\beta$-plane. The starting point is the set of horizontal momentum equations for a Boussinesq fluid, simplified by the assumptions of steady state ($\\frac{\\partial}{\\partial t} = 0$) and linear dynamics (neglecting advective terms).\n\nThe linearized, steady-state, horizontal momentum equations are:\n$$\n-f v = -\\frac{1}{\\rho_0}\\frac{\\partial p}{\\partial x} + \\frac{1}{\\rho_0}\\frac{\\partial \\tau_x}{\\partial z}\n$$\n$$\nf u = -\\frac{1}{\\rho_0}\\frac{\\partial p}{\\partial y} + \\frac{1}{\\rho_0}\\frac{\\partial \\tau_y}{\\partial z}\n$$\nwhere $u$ and $v$ are the zonal and meridional velocities, $f = f_0 + \\beta y$ is the Coriolis parameter on the $\\beta$-plane, $p$ is the pressure, $\\rho_0$ is the constant reference density, and $\\tau_x$ and $\\tau_y$ are the horizontal components of the viscous stress.\n\nWe integrate these equations over the full depth of the ocean, from the bottom at $z = -H$ to the surface at $z=0$. Let us define the depth-integrated transports (or volume transports) as $U = \\int_{-H}^{0} u \\,dz$ and $V = \\int_{-H}^{0} v \\,dz$. The depth-averaged velocities are then $\\bar{u} = U/H$ and $\\bar{v} = V/H$. For a barotropic flow, $u$ and $v$ are independent of depth, so $U = uH$ and $V = vH$. The problem asks for the depth-averaged velocity, which we will simply denote as $v(y)$ in the final steps, consistent with the problem statement.\n\nIntegrating the momentum equations yields:\n$$\n-f \\int_{-H}^{0} v \\,dz = -\\frac{1}{\\rho_0}\\int_{-H}^{0} \\frac{\\partial p}{\\partial x} \\,dz + \\frac{1}{\\rho_0}\\int_{-H}^{0} \\frac{\\partial \\tau_x}{\\partial z} \\,dz\n$$\n$$\nf \\int_{-H}^{0} u \\,dz = -\\frac{1}{\\rho_0}\\int_{-H}^{0} \\frac{\\partial p}{\\partial y} \\,dz + \\frac{1}{\\rho_0}\\int_{-H}^{0} \\frac{\\partial \\tau_y}{\\partial z} \\,dz\n$$\nThese become:\n$$\n-fV = -\\frac{1}{\\rho_0}\\frac{\\partial P}{\\partial x} + \\frac{1}{\\rho_0}\\left[\\tau_x(z=0) - \\tau_x(z=-H)\\right]\n$$\n$$\nfU = -\\frac{1}{\\rho_0}\\frac{\\partial P}{\\partial y} + \\frac{1}{\\rho_0}\\left[\\tau_y(z=0) - \\tau_y(z=-H)\\right]\n$$\nwhere $P = \\int_{-H}^{0} p \\,dz$ is the depth-integrated pressure. The stress at the surface is the wind stress, $\\vec{\\tau}_{\\text{wind}} = (\\tau_x(z=0), \\tau_y(z=0))$, which we are given. In the ocean interior, it is a standard assumption that bottom friction is negligible, so $\\tau_x(z=-H)=0$ and $\\tau_y(z=-H)=0$. The equations simplify to:\n$$\n-fV = -\\frac{1}{\\rho_0}\\frac{\\partial P}{\\partial x} + \\frac{\\tau_x}{\\rho_0}\n$$\n$$\nfU = -\\frac{1}{\\rho_0}\\frac{\\partial P}{\\partial y} + \\frac{\\tau_y}{\\rho_0}\n$$\nwhere $\\tau_x$ and $\\tau_y$ now represent the surface wind stress components.\n\nTo obtain the vorticity balance, we take the curl of these transport equations: $\\frac{\\partial}{\\partial x}$ of the second equation minus $\\frac{\\partial}{\\partial y}$ of the first equation.\n$$\n\\frac{\\partial}{\\partial x}(fU) - \\frac{\\partial}{\\partial y}(-fV) = -\\frac{1}{\\rho_0}\\left(\\frac{\\partial^2 P}{\\partial x \\partial y} - \\frac{\\partial^2 P}{\\partial y \\partial x}\\right) + \\frac{1}{\\rho_0}\\left(\\frac{\\partial \\tau_y}{\\partial x} - \\frac{\\partial \\tau_x}{\\partial y}\\right)\n$$\nThe pressure term vanishes because partial derivatives commute ($\\frac{\\partial^2 P}{\\partial x \\partial y} = \\frac{\\partial^2 P}{\\partial y \\partial x}$). The right side becomes $\\frac{1}{\\rho_0} \\mathrm{curl}_z(\\vec{\\tau})$. The left side is expanded as:\n$$\n\\frac{\\partial}{\\partial x}(fU) + \\frac{\\partial}{\\partial y}(fV) = f\\left(\\frac{\\partial U}{\\partial x} + \\frac{\\partial V}{\\partial y}\\right) + U\\frac{\\partial f}{\\partial x} + V\\frac{\\partial f}{\\partial y}\n$$\nFor a barotropic fluid with a flat bottom, the depth-integrated continuity equation ($\\int_{-H}^0 (\\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial y} + \\frac{\\partial w}{\\partial z}) dz = 0$) simplifies to $\\frac{\\partial U}{\\partial x} + \\frac{\\partial V}{\\partial y} = 0$. Also, on a $\\beta$-plane, $f$ varies only with latitude $y$, so $\\frac{\\partial f}{\\partial x} = 0$ and $\\frac{\\partial f}{\\partial y} = \\beta$. The vorticity balance thus reduces to:\n$$\n\\beta V = \\frac{1}{\\rho_0}\\left(\\frac{\\partial \\tau_y}{\\partial x} - \\frac{\\partial \\tau_x}{\\partial y}\\right) \\equiv \\frac{1}{\\rho_0} \\mathrm{curl}_z(\\vec{\\tau})\n$$\nThis is the Sverdrup relation, which links the interior meridional mass transport to the curl of the wind stress.\n\nThe problem asks for the depth-averaged meridional velocity, $v(y) = V(y)/H$ (since for a barotropic flow, the velocity is independent of depth). The relation is therefore:\n$$\nv(y) = \\frac{1}{\\beta \\rho_0 H} \\left( \\frac{\\partial \\tau_y}{\\partial x} - \\frac{\\partial \\tau_x}{\\partial y} \\right)\n$$\nThis is the desired interior relation. The key assumptions made in this derivation are: steady state, linear dynamics (small Rossby number), a $\\beta$-plane approximation, negligible bottom friction, and a flat bottom (constant $H$).\n\nRegarding the dependence of $v$ on $H$, the relation shows that for a given wind stress curl, the magnitude of the meridional velocity $|v|$ is inversely proportional to the ocean depth $H$. The total meridional transport per unit zonal width, $V = vH$, is determined solely by the wind stress curl and the planetary vorticity gradient $\\beta$. A deeper ocean can accommodate this transport with a slower depth-averaged velocity.\n\nNow we evaluate the velocity for the given wind stress:\n$$\n\\tau_{x}(y) = \\tau_{0}\\,\\sin\\!\\left(\\frac{2\\pi\\, y}{L_{y}}\\right), \\qquad \\tau_{y}(x,y) = 0\n$$\nThe curl of the wind stress is:\n$$\n\\mathrm{curl}_z(\\vec{\\tau}) = \\frac{\\partial \\tau_y}{\\partial x} - \\frac{\\partial \\tau_x}{\\partial y} = \\frac{\\partial}{\\partial x}(0) - \\frac{\\partial}{\\partial y}\\left[\\tau_{0}\\,\\sin\\!\\left(\\frac{2\\pi\\, y}{L_{y}}\\right)\\right]\n$$\n$$\n\\mathrm{curl}_z(\\vec{\\tau}) = - \\tau_0 \\left( \\frac{2\\pi}{L_y} \\right) \\cos\\!\\left(\\frac{2\\pi\\, y}{L_{y}}\\right)\n$$\nSubstituting this into the expression for $v(y)$:\n$$\nv(y) = \\frac{1}{\\beta \\rho_0 H} \\left[ - \\frac{2\\pi \\tau_0}{L_y} \\cos\\!\\left(\\frac{2\\pi\\, y}{L_{y}}\\right) \\right] = - \\frac{2\\pi \\tau_0}{\\beta \\rho_0 H L_y} \\cos\\!\\left(\\frac{2\\pi\\, y}{L_{y}}\\right)\n$$\nWe need to evaluate this at $y = L_y/3$:\n$$\nv\\left(\\frac{L_y}{3}\\right) = - \\frac{2\\pi \\tau_0}{\\beta \\rho_0 H L_y} \\cos\\!\\left(\\frac{2\\pi}{L_y} \\cdot \\frac{L_y}{3}\\right) = - \\frac{2\\pi \\tau_0}{\\beta \\rho_0 H L_y} \\cos\\!\\left(\\frac{2\\pi}{3}\\right)\n$$\nThe value of the cosine term is $\\cos(2\\pi/3) = -1/2$.\n$$\nv\\left(\\frac{L_y}{3}\\right) = - \\frac{2\\pi \\tau_0}{\\beta \\rho_0 H L_y} \\left(-\\frac{1}{2}\\right) = \\frac{\\pi \\tau_0}{\\beta \\rho_0 H L_y}\n$$\nNow, we substitute the given numerical values:\n$\\beta = 2.0 \\times 10^{-11}\\ \\mathrm{m}^{-1}\\,\\mathrm{s}^{-1}$\n$\\rho_0 = 1025\\ \\mathrm{kg}\\,\\mathrm{m}^{-3}$\n$H = 4000\\ \\mathrm{m}$\n$\\tau_0 = 0.10\\ \\mathrm{N}\\,\\mathrm{m}^{-2}$\n$L_y = 3.0 \\times 10^{6}\\ \\mathrm{m}$\n\n$$\nv\\left(\\frac{L_y}{3}\\right) = \\frac{\\pi (0.10)}{(2.0 \\times 10^{-11})(1025)(4000)(3.0 \\times 10^6)}\n$$\n$$\nv\\left(\\frac{L_y}{3}\\right) = \\frac{0.10 \\pi}{ (2.0 \\times 1025 \\times 4000 \\times 3.0) \\times 10^{-5} } = \\frac{0.10 \\pi}{24600000 \\times 10^{-5}}\n$$\n$$\nv\\left(\\frac{L_y}{3}\\right) = \\frac{0.10 \\pi}{246} \\approx \\frac{0.314159}{246} \\approx 0.00127707\\ \\mathrm{m}\\,\\mathrm{s}^{-1}\n$$\nRounding to four significant figures, the result is $1.277 \\times 10^{-3}\\ \\mathrm{m}\\,\\mathrm{s}^{-1}$.",
            "answer": "$$\n\\boxed{1.277 \\times 10^{-3}}\n$$"
        },
        {
            "introduction": "Moving from analytical solutions to numerical modeling is a key step in modern oceanography. This practice guides you through the process of building a finite-difference solver for the Poisson equation, which is the diagnostic heart of many barotropic models . You will learn to discretize the equation, implement boundary conditions, and validate your code, providing a foundational skill set for tackling more complex computational problems.",
            "id": "3813684",
            "problem": "Consider a two-dimensional, barotropic, incompressible ocean flow on a rectangular domain, where the horizontal velocity field is represented by a scalar streamfunction $\\psi(x,y)$ such that $\\mathbf{u} = (u,v) = \\left(-\\frac{\\partial \\psi}{\\partial y}, \\frac{\\partial \\psi}{\\partial x}\\right)$. The relative vorticity $\\zeta(x,y)$ is defined as $\\zeta = \\frac{\\partial v}{\\partial x} - \\frac{\\partial u}{\\partial y}$. For barotropic flow, these definitions imply a Poisson relation between the streamfunction and vorticity, namely $\\nabla^2 \\psi = \\zeta$.\n\nYour tasks are:\n1. Starting only from the definitions of the streamfunction and relative vorticity and the properties of incompressible flow, derive the governing Poisson equation and a second-order, uniform-grid, finite-difference discretization of the Laplacian operator $\\nabla^2 \\psi$ on the unit square domain $[0,1] \\times [0,1]$ with $N \\times N$ grid points and grid spacing $h = \\frac{1}{N-1}$ in both directions. Clearly specify how the discretized operator should be formed at interior points.\n2. Formulate boundary treatments for two types of boundary conditions:\n   - Dirichlet boundary condition: $\\psi$ is prescribed along all four boundaries.\n   - Homogeneous Neumann boundary condition: $\\frac{\\partial \\psi}{\\partial n} = 0$ along all four boundaries, where $\\frac{\\partial \\psi}{\\partial n}$ denotes the derivative normal to the boundary. Ensure that your formulation is consistent with the discrete Laplacian at points adjacent to the boundary. In the homogeneous Neumann case, address the solvability condition and the non-uniqueness up to an additive constant; define a gauge to fix the mean value of $\\psi$.\n3. Propose and implement an iterative solver suitable for large domains using a pointwise relaxation strategy that updates $\\psi$ locally based on the discretized Poisson equation. Describe the iteration in terms of a relaxation parameter and how new values depend on neighboring points. Explain the stopping criterion based on a residual norm derived from the discrete Poisson operator. Discuss how the method scales with $N$, and comment on alternative iterative methods that are more efficient for very large $N$.\n4. Validate the solver using manufactured solutions on the unit square. Let $(x_i, y_j)$ denote the grid point coordinates. Use the following test suite, which covers interior updates, boundary treatments, small-grid behavior, and moderate-grid behavior. For each case, construct $\\zeta(x_i,y_j)$ from the manufactured exact $\\psi(x_i,y_j)$, apply the appropriate boundary condition, run your solver until convergence, and then compute the maximum absolute pointwise error $\\max_{i,j} |\\psi_{\\text{num}}(x_i,y_j) - \\psi_{\\text{exact}}(x_i,y_j)|$:\n   - Case A (Dirichlet, happy path): $N = 33$. Exact streamfunction $ \\psi_{\\text{exact}}(x,y) = \\sin(2\\pi x)\\sin(3\\pi y)$. Dirichlet boundary values are prescribed from $\\psi_{\\text{exact}}$ on all boundaries. Define $\\zeta(x,y)$ by the continuous identity $\\zeta = \\nabla^2 \\psi_{\\text{exact}}$ evaluated pointwise on the grid.\n   - Case B (Homogeneous Neumann, compatibility satisfied): $N = 33$. Exact streamfunction $\\psi_{\\text{exact}}(x,y) = \\cos(2\\pi x) + \\cos(2\\pi y)$. Homogeneous Neumann boundary condition $\\frac{\\partial \\psi}{\\partial n} = 0$ along all boundaries. Define $\\zeta(x,y)$ by $\\zeta = \\nabla^2 \\psi_{\\text{exact}}$. Impose a gauge by enforcing zero mean for $\\psi$ at all iterations.\n   - Case C (Dirichlet, small-grid edge case): $N = 5$. Exact streamfunction $ \\psi_{\\text{exact}}(x,y) = \\sin(2\\pi x)\\sin(3\\pi y)$. Dirichlet boundary values from $\\psi_{\\text{exact}}$; define $\\zeta$ as before.\n   - Case D (Homogeneous Neumann, moderate-grid): $N = 49$. Exact streamfunction $\\psi_{\\text{exact}}(x,y) = \\cos(2\\pi x) + \\cos(2\\pi y)$. Homogeneous Neumann boundary condition $\\frac{\\partial \\psi}{\\partial n} = 0$, with a zero-mean gauge. Define $\\zeta$ by $\\zeta = \\nabla^2 \\psi_{\\text{exact}}$.\n\nImplementation requirements:\n- Use a pointwise relaxation method based on your discretization with a relaxation parameter. Stop the iteration when the maximum norm of the discrete residual $r_{i,j} = (\\nabla^2_h \\psi)_{i,j} - \\zeta_{i,j}$ falls below a prescribed tolerance or a maximum number of iterations is reached.\n- The program must be self-contained and must not require any input.\n- For each test case, compute and report the maximum absolute pointwise error between the numerical and exact $\\psi$ fields over all grid points.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain four numbers corresponding to Cases A, B, C, and D, respectively. Each number must be the maximum absolute pointwise error, formatted in scientific notation with six significant digits (for example, $[1.23\\text{e-}04,5.67\\text{e-}05,8.90\\text{e-}06,1.23\\text{e-}04]$). No physical units or angle units apply; results are dimensionless.",
            "solution": "The problem presented is a well-posed and standard exercise in computational fluid dynamics, specifically the numerical solution of an elliptic partial differential equation. It requires the derivation and implementation of a finite-difference solver for the Poisson equation governing the streamfunction in a barotropic, incompressible flow. The problem is scientifically grounded, self-contained, and all provided data and conditions are consistent. We may therefore proceed with a full solution.\n\nThe solution is presented in four parts, corresponding to the tasks outlined in the problem statement.\n\n### 1. Governing Equation and Finite-Difference Discretization\n\nThe relationship between the velocity field $\\mathbf{u} = (u,v)$ and the scalar streamfunction $\\psi(x,y)$ is given by:\n$$\nu = -\\frac{\\partial \\psi}{\\partial y}, \\qquad v = \\frac{\\partial \\psi}{\\partial x}\n$$\nThe incompressibility condition, $\\nabla \\cdot \\mathbf{u} = \\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial y} = 0$, is satisfied identically by this definition, provided $\\psi$ has continuous second-order partial derivatives:\n$$\n\\frac{\\partial}{\\partial x}\\left(-\\frac{\\partial \\psi}{\\partial y}\\right) + \\frac{\\partial}{\\partial y}\\left(\\frac{\\partial \\psi}{\\partial x}\\right) = -\\frac{\\partial^2 \\psi}{\\partial x \\partial y} + \\frac{\\partial^2 \\psi}{\\partial y \\partial x} = 0\n$$\nThe relative vorticity, $\\zeta$, is defined as the curl of the velocity field:\n$$\n\\zeta = \\frac{\\partial v}{\\partial x} - \\frac{\\partial u}{\\partial y}\n$$\nSubstituting the streamfunction definitions for $u$ and $v$ into the expression for $\\zeta$ yields the governing Poisson equation:\n$$\n\\zeta = \\frac{\\partial}{\\partial x}\\left(\\frac{\\partial \\psi}{\\partial x}\\right) - \\frac{\\partial}{\\partial y}\\left(-\\frac{\\partial \\psi}{\\partial y}\\right) = \\frac{\\partial^2 \\psi}{\\partial x^2} + \\frac{\\partial^2 \\psi}{\\partial y^2} = \\nabla^2 \\psi\n$$\nTo solve this equation numerically, we discretize the domain $[0,1] \\times [0,1]$ using a uniform grid with $N \\times N$ points. The grid spacing is $h = \\frac{1}{N-1}$ in both the $x$ and $y$ directions. The coordinates of a grid point are $(x_i, y_j) = (i h, j h)$ for $i, j \\in \\{0, 1, \\dots, N-1\\}$. The value of the streamfunction at this point is denoted $\\psi_{i,j}$.\n\nThe Laplacian operator, $\\nabla^2 \\psi$, is discretized at an interior grid point $(i,j)$ using second-order accurate central finite differences for the second partial derivatives:\n$$\n\\frac{\\partial^2 \\psi}{\\partial x^2}\\bigg|_{i,j} \\approx \\frac{\\psi_{i+1,j} - 2\\psi_{i,j} + \\psi_{i-1,j}}{h^2}\n$$\n$$\n\\frac{\\partial^2 \\psi}{\\partial y^2}\\bigg|_{i,j} \\approx \\frac{\\psi_{i,j+1} - 2\\psi_{i,j} + \\psi_{i,j-1}}{h^2}\n$$\nSumming these gives the five-point-stencil discrete Laplacian operator, $(\\nabla^2_h \\psi)_{i,j}$:\n$$\n(\\nabla^2_h \\psi)_{i,j} = \\frac{\\psi_{i+1,j} + \\psi_{i-1,j} + \\psi_{i,j+1} + \\psi_{i,j-1} - 4\\psi_{i,j}}{h^2}\n$$\nThus, the discretized Poisson equation at any interior point $(i,j)$ is:\n$$\n\\frac{\\psi_{i+1,j} + \\psi_{i-1,j} + \\psi_{i,j+1} + \\psi_{i,j-1} - 4\\psi_{i,j}}{h^2} = \\zeta_{i,j}\n$$\n\n### 2. Boundary Condition Treatment\n\n**Dirichlet Boundary Condition**: $\\psi$ is prescribed on all boundaries.\nIn this case, the values of $\\psi_{i,j}$ are known for $i \\in \\{0, N-1\\}$ or $j \\in \\{0, N-1\\}$. The iterative solver updates only the interior points, i.e., for $i,j \\in \\{1, \\dots, N-2\\}$. When updating a point adjacent to a boundary, such as $(1,j)$, the known boundary value $\\psi_{0,j}$ is used in the stencil.\n\n**Homogeneous Neumann Boundary Condition**: $\\frac{\\partial \\psi}{\\partial n} = 0$ on all boundaries.\nThis condition is handled by introducing \"ghost points\" outside the domain. For example, on the left boundary ($x=0$, $i=0$), the condition is $\\frac{\\partial \\psi}{\\partial x}=0$. A second-order central difference approximation at $i=0$ is $\\frac{\\psi_{1,j} - \\psi_{-1,j}}{2h} = 0$, which implies the ghost point value is $\\psi_{-1,j} = \\psi_{1,j}$. We can now write the discrete Laplacian at the boundary point $(0,j)$:\n$$\n(\\nabla^2_h \\psi)_{0,j} = \\frac{\\psi_{1,j} + \\psi_{-1,j} + \\psi_{0,j+1} + \\psi_{0,j-1} - 4\\psi_{0,j}}{h^2} = \\frac{2\\psi_{1,j} + \\psi_{0,j+1} + \\psi_{0,j-1} - 4\\psi_{0,j}}{h^2}\n$$\nThis gives us the equation to be solved at the boundary points. Similar stencils are derived for the other three boundaries and the four corners. For a corner point, e.g., $(0,0)$, we have both $\\frac{\\partial \\psi}{\\partial x}=0$ and $\\frac{\\partial \\psi}{\\partial y}=0$, leading to $\\psi_{-1,0}=\\psi_{1,0}$ and $\\psi_{0,-1}=\\psi_{0,1}$. The discretized equation becomes:\n$$\n(\\nabla^2_h \\psi)_{0,0} = \\frac{2\\psi_{1,0} + 2\\psi_{0,1} - 4\\psi_{0,0}}{h^2} = \\zeta_{0,0}\n$$\nA Neumann problem for the Poisson equation has a solution only if the source term satisfies a solvability condition. Integrating $\\nabla^2\\psi = \\zeta$ over the domain $\\Omega$ and applying the divergence theorem: $\\iint_\\Omega \\zeta \\,dA = \\iint_\\Omega \\nabla \\cdot (\\nabla \\psi) \\,dA = \\oint_{\\partial\\Omega} \\nabla\\psi \\cdot \\mathbf{n} \\,ds = \\oint_{\\partial\\Omega} \\frac{\\partial\\psi}{\\partial n} \\,ds$. For homogeneous Neumann conditions, this requires $\\iint_\\Omega \\zeta \\,dA = 0$. The manufactured solutions in the test cases satisfy this integral constraint.\nFurthermore, if $\\psi$ is a solution, so is $\\psi+C$ for any constant $C$. This non-uniqueness is resolved by enforcing a gauge. As specified, we enforce a zero-mean solution by subtracting the grid-mean of $\\psi$ at each iteration: $\\psi_{i,j} \\leftarrow \\psi_{i,j} - \\frac{1}{N^2}\\sum_{k,l} \\psi_{k,l}$.\n\n### 3. Iterative Solver: Successive Over-Relaxation (SOR)\n\nA suitable pointwise relaxation method is Successive Over-Relaxation (SOR). The method updates a point $\\psi_{i,j}$ based on its neighbors and a relaxation parameter $\\omega$. First, we rearrange the discrete Poisson equation to express $\\psi_{i,j}$ in terms of its neighbors. For an interior point:\n$$\n\\psi_{i,j} = \\frac{1}{4}(\\psi_{i+1,j} + \\psi_{i-1,j} + \\psi_{i,j+1} + \\psi_{i,j-1} - h^2 \\zeta_{i,j})\n$$\nThe right-hand side, evaluated using the most up-to-date values of $\\psi$ in a sequential sweep, defines the Gauss-Seidel update, $\\psi_{i,j}^{\\text{GS}}$. The SOR method modifies the current value $\\psi_{i,j}^{(k)}$ to the new value $\\psi_{i,j}^{(k+1)}$ by \"over-relaxing\" this update:\n$$\n\\psi_{i,j}^{(k+1)} = (1-\\omega)\\psi_{i,j}^{(k)} + \\omega \\psi_{i,j}^{\\text{GS}}\n$$\nwhere $k$ is the iteration index and $\\omega$ is the relaxation parameter. For convergence, $0 < \\omega < 2$. For $\\omega > 1$, the method is \"over-relaxed\" and convergence is accelerated. The optimal $\\omega$ for this problem on a square grid is approximately $\\omega_{\\text{opt}} \\approx \\frac{2}{1 + \\sin(\\pi h)} = \\frac{2}{1 + \\sin(\\pi/(N-1))}$.\n\nThe iteration is terminated when the discrete system is solved to a desired accuracy. This is measured by the norm of the residual, $r_{i,j} = (\\nabla^2_h \\psi)_{i,j} - \\zeta_{i,j}$. The iteration stops when the maximum norm of the residual, $\\|r\\|_\\infty = \\max_{i,j} |r_{i,j}|$, falls below a specified tolerance $\\epsilon$, or a maximum number of iterations is reached.\n\n**Scaling and Alternatives**: The number of iterations required for SOR to converge to a fixed tolerance scales as $O(N)$. Since each iteration involves $O(N^2)$ operations, the total computational cost scales as $O(N^3)$. This becomes prohibitive for very large $N$. More efficient modern methods include:\n- **Conjugate Gradient (CG) Method**: An algorithm for solving linear systems $A\\mathbf{x}=\\mathbf{b}$ where $A$ is symmetric and positive-definite. It typically converges much faster than SOR. Preconditioned CG (PCG) can further improve performance.\n- **Multigrid Methods**: These methods operate on a hierarchy of grids, using coarser grids to efficiently resolve low-frequency error components. They are among the most efficient solvers, with a computational complexity of $O(N^2)$, which is optimal.\n- **Fast Fourier Transform (FFT) Solvers**: For rectangular domains and certain boundary conditions, the discrete Poisson equation can be diagonalized in Fourier space, allowing for a very fast solution with complexity $O(N^2 \\log N)$.\n\n### 4. Validation using Manufactured Solutions\n\nThe solver is validated using the method of manufactured solutions. An exact solution $\\psi_{\\text{exact}}$ is chosen, and the corresponding forcing term $\\zeta_{\\text{exact}} = \\nabla^2 \\psi_{\\text{exact}}$ and boundary conditions are derived from it. The numerical solver is then run with this setup, and its output $\\psi_{\\text{num}}$ is compared to $\\psi_{\\text{exact}}$. The maximum absolute pointwise error, $\\max_{i,j} |\\psi_{\\text{num}}(x_i,y_j) - \\psi_{\\text{exact}}(x_i,y_j)|$, quantifies the accuracy of the implementation. The provided test suite covers Dirichlet and Neumann boundary conditions for different grid sizes, as detailed in the problem statement. The implementation follows the principles described above.",
            "answer": "```python\nimport numpy as np\n\ndef solve_poisson(N, bc_type, psi_exact_func, zeta_func, tol=1e-9, max_iter=30000):\n    \"\"\"\n    Solves the Poisson equationnabla^2 psi = zeta on a unit square.\n    \"\"\"\n    h = 1.0 / (N - 1)\n    hsq = h * h\n\n    # Grid and exact solutions\n    x = np.linspace(0, 1, N)\n    y = np.linspace(0, 1, N)\n    xx, yy = np.meshgrid(x, y, indexing='ij')\n\n    psi_exact = psi_exact_func(xx, yy)\n    zeta = zeta_func(xx, yy)\n\n    # Initial guess for psi\n    psi = np.zeros((N, N), dtype=float)\n\n    # Set Dirichlet boundary conditions on the initial guess\n    if bc_type == 'dirichlet':\n        psi[0, :] = psi_exact[0, :]\n        psi[N-1, :] = psi_exact[N-1, :]\n        psi[:, 0] = psi_exact[:, 0]\n        psi[:, N-1] = psi_exact[:, N-1]\n\n    # Optimal relaxation parameter for SOR\n    omega = 2.0 / (1.0 + np.sin(np.pi * h))\n\n    # SOR Iteration\n    for k in range(max_iter):\n        if bc_type == 'dirichlet':\n            # Update only interior points\n            for i in range(1, N - 1):\n                for j in range(1, N - 1):\n                    neighbors_sum = psi[i-1, j] + psi[i+1, j] + psi[i, j-1] + psi[i, j+1]\n                    gs_target = 0.25 * (neighbors_sum - hsq * zeta[i, j])\n                    psi[i, j] = (1 - omega) * psi[i, j] + omega * gs_target\n        \n        elif bc_type == 'neumann':\n            # Update all points with appropriate stencils\n            for i in range(N):\n                for j in range(N):\n                    # Interior\n                    if 0 < i < N - 1 and 0 < j < N - 1:\n                        neighbors_sum = psi[i-1, j] + psi[i+1, j] + psi[i, j-1] + psi[i, j+1]\n                    # Edges\n                    elif i == 0 and 0 < j < N - 1: # Left\n                        neighbors_sum = 2 * psi[i+1, j] + psi[i, j-1] + psi[i, j+1]\n                    elif i == N - 1 and 0 < j < N - 1: # Right\n                        neighbors_sum = 2 * psi[i-1, j] + psi[i, j-1] + psi[i, j+1]\n                    elif 0 < i < N - 1 and j == 0: # Bottom\n                        neighbors_sum = psi[i-1, j] + psi[i+1, j] + 2 * psi[i, j+1]\n                    elif 0 < i < N - 1 and j == N - 1: # Top\n                        neighbors_sum = psi[i-1, j] + psi[i+1, j] + 2 * psi[i, j-1]\n                    # Corners\n                    elif i == 0 and j == 0: # Bottom-left\n                        neighbors_sum = 2 * psi[i+1, j] + 2 * psi[i, j+1]\n                    elif i == N - 1 and j == 0: # Bottom-right\n                        neighbors_sum = 2 * psi[i-1, j] + 2 * psi[i, j+1]\n                    elif i == 0 and j == N - 1: # Top-left\n                        neighbors_sum = 2 * psi[i+1, j] + 2 * psi[i, j-1]\n                    elif i == N - 1 and j == N - 1: # Top-right\n                        neighbors_sum = 2 * psi[i-1, j] + 2 * psi[i, j-1]\n\n                    gs_target = 0.25 * (neighbors_sum - hsq * zeta[i, j])\n                    psi[i, j] = (1 - omega) * psi[i, j] + omega * gs_target\n            \n            # Apply zero-mean gauge\n            psi -= np.mean(psi)\n\n        # Check for convergence based on residual (every 25 iterations to save time)\n        if k % 25 == 0:\n            residual = np.zeros_like(psi)\n            # Dirichlet residual is on interior points\n            if bc_type == 'dirichlet':\n                lap_psi = (psi[:-2, 1:-1] + psi[2:, 1:-1] + psi[1:-1, :-2] + psi[1:-1, 2:] - 4*psi[1:-1, 1:-1]) / hsq\n                residual[1:-1,1:-1] = lap_psi - zeta[1:-1,1:-1]\n                max_res = np.max(np.abs(residual[1:-1,1:-1]))\n            # Neumann residual is on all points\n            else:\n                for i in range(N):\n                    for j in range(N):\n                        if 0 < i < N - 1 and 0 < j < N - 1:\n                            lap_psi_ij = (psi[i-1,j] + psi[i+1,j] + psi[i,j-1] + psi[i,j+1] - 4*psi[i,j]) / hsq\n                        elif i == 0 and 0 < j < N - 1:\n                            lap_psi_ij = (2*psi[i+1,j] + psi[i,j-1] + psi[i,j+1] - 4*psi[i,j]) / hsq\n                        elif i == N - 1 and 0 < j < N - 1:\n                            lap_psi_ij = (2*psi[i-1,j] + psi[i,j-1] + psi[i,j+1] - 4*psi[i,j]) / hsq\n                        elif 0 < i < N - 1 and j == 0:\n                            lap_psi_ij = (psi[i-1,j] + psi[i+1,j] + 2*psi[i,j+1] - 4*psi[i,j]) / hsq\n                        elif 0 < i < N - 1 and j == N - 1:\n                            lap_psi_ij = (psi[i-1,j] + psi[i+1,j] + 2*psi[i,j-1] - 4*psi[i,j]) / hsq\n                        elif i == 0 and j == 0:\n                            lap_psi_ij = (2*psi[i+1,j] + 2*psi[i,j+1] - 4*psi[i,j]) / hsq\n                        elif i == N - 1 and j == 0:\n                            lap_psi_ij = (2*psi[i-1,j] + 2*psi[i,j+1] - 4*psi[i,j]) / hsq\n                        elif i == 0 and j == N - 1:\n                            lap_psi_ij = (2*psi[i+1,j] + 2*psi[i,j-1] - 4*psi[i,j]) / hsq\n                        elif i == N - 1 and j == N - 1:\n                            lap_psi_ij = (2*psi[i-1,j] + 2*psi[i,j-1] - 4*psi[i,j]) / hsq\n                        residual[i,j] = lap_psi_ij - zeta[i,j]\n                max_res = np.max(np.abs(residual))\n            \n            if max_res < tol:\n                break\n    \n    # Final error calculation\n    error = np.max(np.abs(psi - psi_exact))\n    return error\n\n\ndef solve():\n    # Case definitions\n    psi_A_C = lambda x, y: np.sin(2 * np.pi * x) * np.sin(3 * np.pi * y)\n    zeta_A_C = lambda x, y: -( (2*np.pi)**2 + (3*np.pi)**2 ) * np.sin(2 * np.pi * x) * np.sin(3 * np.pi * y)\n    \n    psi_B_D = lambda x, y: np.cos(2 * np.pi * x) + np.cos(2 * np.pi * y)\n    zeta_B_D = lambda x, y: -(2 * np.pi)**2 * (np.cos(2 * np.pi * x) + np.cos(2 * np.pi * y))\n\n    test_cases = [\n        # (N, bc_type, psi_exact_func, zeta_func)\n        (33, 'dirichlet', psi_A_C, zeta_A_C),  # Case A\n        (33, 'neumann',   psi_B_D, zeta_B_D),  # Case B\n        (5,  'dirichlet', psi_A_C, zeta_A_C),  # Case C\n        (49, 'neumann',   psi_B_D, zeta_B_D),  # Case D\n    ]\n\n    results = []\n    for N, bc_type, psi_func, zeta_func in test_cases:\n        error = solve_poisson(N, bc_type, psi_func, zeta_func)\n        results.append(error)\n\n    # Format output\n    formatted_results = [f\"{r:.5e}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While finite-difference methods are powerful, spectral methods offer an elegant and often highly accurate alternative for certain problem geometries. This exercise introduces you to solving the Poisson equation using a spectral approach based on a double sine series expansion . By deriving the modal equations and implementing a numerical projection, you will appreciate the power of eigenfunction expansions and the concept of solving a PDE by transforming it into a set of algebraic equations in \"wavenumber space\".",
            "id": "3813669",
            "problem": "You are to implement and validate a spectral solution for the diagnostic barotropic streamfunction in a rectangular basin using a double sine series. Begin from the barotropic vorticity equation on a beta-plane with linear bottom drag and wind-stress curl forcing, then justify a reduction to a diagnostic Poisson problem for the streamfunction under a steady, linear, highly frictional, and small-beta regime. Let the nondimensionalized equation be\n$$\n\\nabla^2 \\psi(x,y) = F(x,y),\n$$\nposed on a rectangle $0 < x < L_x$, $0 < y < L_y$ with homogeneous Dirichlet boundary conditions\n$$\n\\psi(0,y)=\\psi(L_x,y)=\\psi(x,0)=\\psi(x,L_y)=0.\n$$\nAll trigonometric functions use radians. All quantities are nondimensional.\n\nYour tasks are:\n- Derive, from first principles of separation of variables and orthogonality, the double sine eigenfunction expansion that satisfies the stated boundary conditions.\n- Derive the modal equations linking the expansion coefficients of $\\psi$ and $F$, including the correct normalization constants from orthogonality over the rectangle.\n- Implement a program that, for a given forcing field $F(x,y)$ and integers $(m,n)$, computes the modal amplitude $A_{mn}$ of $\\psi$ in the double sine series. The series representation must be of the form\n$$\n\\psi(x,y) = \\sum_{m=1}^{\\infty} \\sum_{n=1}^{\\infty} A_{mn} \\sin\\!\\left(\\frac{m\\pi x}{L_x}\\right)\\sin\\!\\left(\\frac{n\\pi y}{L_y}\\right),\n$$\nwith a corresponding projection of $F(x,y)$ onto the same basis. The program should:\n  - Numerically evaluate the projection integrals for $F_{mn}$ using two-dimensional Gaussâ€“Legendre quadrature over $[0,L_x]\\times[0,L_y]$,\n  - Use the derived modal relation to compute $A_{mn}$,\n  - Return $A_{mn}$ for specified test inputs.\n\nUse the following test suite. Each test case specifies $(L_x,L_y)$, a forcing constructed as a finite sum of double sines, and a target mode $(m,n)$ for which you must compute $A_{mn}$. In each forcing definition, the notation $\\sin\\!\\left(\\frac{p\\pi x}{L_x}\\right)\\sin\\!\\left(\\frac{q\\pi y}{L_y}\\right)$ is abbreviated as the pair $(p,q)$ with unit amplitude. All trigonometric arguments are in radians.\n\n- Test 1 (happy path, matched single mode): $L_x=1$, $L_y=1$, forcing $F=\\{(1,1)\\}$, target mode $(m,n)=(1,1)$.\n- Test 2 (higher wavenumbers): $L_x=1$, $L_y=1$, forcing $F=\\{(2,3)\\}$, target mode $(2,3)$.\n- Test 3 (orthogonality zero case): $L_x=1$, $L_y=1$, forcing $F=\\{(2,3)\\}$, target mode $(1,1)$.\n- Test 4 (anisotropic domain): $L_x=2$, $L_y=1$, forcing $F=\\{(1,2)\\}$, target mode $(1,2)$.\n- Test 5 (sum of two modes, single target): $L_x=1$, $L_y=1$, forcing $F=\\{(1,2),(3,1)\\}$, target mode $(1,2)$.\n\nYour program must compute the list of results $[A_{mn}^{(1)},A_{mn}^{(2)},A_{mn}^{(3)},A_{mn}^{(4)},A_{mn}^{(5)}]$ corresponding to the five test cases above and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example\n\"[r1,r2,r3,r4,r5]\".\nEach entry must be a floating-point number rounded to $12$ decimal places.\n\nYour answer must be a complete, runnable program that performs these computations with no user input.",
            "solution": "The user-provided problem has been analyzed and is determined to be **valid**. It is a well-posed, scientifically grounded problem from the field of computational oceanography that is free from any of the invalidating flaws listed in the problem validation rules. The problem is self-contained, with all necessary data, equations, and conditions provided for a unique solution to be determined.\n\n### 1. Theoretical Framework and Derivation\n\nThe problem requires the solution of the nondimensionalized, steady-state, linear barotropic vorticity equation in a highly frictional regime, which reduces to the Poisson equation for the streamfunction $\\psi(x,y)$:\n$$\n\\nabla^2 \\psi(x,y) = F(x,y)\n$$\nThis equation is posed on a rectangular domain $D = \\{ (x,y) \\,|\\, 0 < x < L_x, \\, 0 < y < L_y \\}$ with homogeneous Dirichlet boundary conditions, corresponding to no-normal-flow at the solid walls of the basin:\n$$\n\\psi(0,y) = \\psi(L_x,y) = \\psi(x,0) = \\psi(L_y,y) = 0\n$$\n\nThe solution is constructed using an eigenfunction expansion, a standard technique for linear partial differential equations. The basis functions are the eigenfunctions of the Laplacian operator, $\\nabla^2$, that satisfy the given boundary conditions.\n\n#### 1.1. Eigenfunction Expansion via Separation of Variables\n\nWe seek solutions to the eigenvalue problem $\\nabla^2 \\phi(x,y) = -\\lambda \\phi(x,y)$ with the same homogeneous Dirichlet boundary conditions. Assuming a separable solution of the form $\\phi(x,y) = X(x)Y(y)$, the equation becomes:\n$$\n\\frac{X''(x)}{X(x)} + \\frac{Y''(y)}{Y(y)} = -\\lambda\n$$\nSince the terms on the left are functions of independent variables, they must be equal to constants. We set $\\frac{X''(x)}{X(x)} = -k_x^2$ and $\\frac{Y''(y)}{Y(y)} = -k_y^2$, leading to $\\lambda = k_x^2 + k_y^2$.\n\nThe boundary conditions on $\\psi$ translate to $X(0)=X(L_x)=0$ and $Y(0)=Y(L_y)=0$. The solution to the Sturm-Liouville problem $X''(x) + k_x^2 X(x) = 0$ with these boundary conditions yields the eigenvalues and eigenfunctions for the $x$-direction:\n$$\nk_{x,m} = \\frac{m\\pi}{L_x}, \\quad X_m(x) = \\sin\\left(\\frac{m\\pi x}{L_x}\\right), \\quad m = 1, 2, 3, \\dots\n$$\nSimilarly, for the $y$-direction:\n$$\nk_{y,n} = \\frac{n\\pi}{L_y}, \\quad Y_n(y) = \\sin\\left(\\frac{n\\pi y}{L_y}\\right), \\quad n = 1, 2, 3, \\dots\n$$\nThe eigenfunctions of the 2D Laplacian on the rectangle are the products of these 1D solutions:\n$$\n\\phi_{mn}(x,y) = \\sin\\left(\\frac{m\\pi x}{L_x}\\right)\\sin\\left(\\frac{n\\pi y}{L_y}\\right)\n$$\nThe corresponding eigenvalues $\\lambda_{mn}$ are:\n$$\n\\lambda_{mn} = k_{x,m}^2 + k_{y,n}^2 = \\pi^2 \\left( \\frac{m^2}{L_x^2} + \\frac{n^2}{L_y^2} \\right)\n$$\nApplying the Laplacian to an eigenfunction yields $\\nabla^2 \\phi_{mn} = -\\lambda_{mn} \\phi_{mn}$. These eigenfunctions form a complete orthogonal basis for functions on the domain $D$ that vanish at the boundary.\n\n#### 1.2. Modal Equations for Amplitudes\n\nWe expand both the solution $\\psi$ and the forcing $F$ in this basis:\n$$\n\\psi(x,y) = \\sum_{m=1}^{\\infty} \\sum_{n=1}^{\\infty} A_{mn} \\phi_{mn}(x,y)\n$$\n$$\nF(x,y) = \\sum_{m=1}^{\\infty} \\sum_{n=1}^{\\infty} F_{mn} \\phi_{mn}(x,y)\n$$\nSubstituting these series into the Poisson equation $\\nabla^2 \\psi = F$:\n$$\n\\nabla^2 \\left( \\sum_{m,n} A_{mn} \\phi_{mn}(x,y) \\right) = \\sum_{m,n} F_{mn} \\phi_{mn}(x,y)\n$$\nUsing linearity and the eigenvalue property $\\nabla^2 \\phi_{mn} = -\\lambda_{mn} \\phi_{mn}$:\n$$\n\\sum_{m,n} A_{mn} (-\\lambda_{mn} \\phi_{mn}(x,y)) = \\sum_{m,n} F_{mn} \\phi_{mn}(x,y)\n$$\nBy orthogonality, the coefficients of each basis function must be equal:\n$$\n-\\lambda_{mn} A_{mn} = F_{mn} \\quad \\implies \\quad A_{mn} = -\\frac{F_{mn}}{\\lambda_{mn}}\n$$\n\nTo find the forcing coefficient $F_{mn}$, we project $F(x,y)$ onto the basis function $\\phi_{mn}(x,y)$ using the inner product $\\langle f,g \\rangle = \\int_0^{L_y} \\int_0^{L_x} f(x,y)g(x,y) \\,dx\\,dy$.\n$$\n\\langle F, \\phi_{mn} \\rangle = \\left\\langle \\sum_{p,q} F_{pq} \\phi_{pq}, \\phi_{mn} \\right\\rangle = \\sum_{p,q} F_{pq} \\langle \\phi_{pq}, \\phi_{mn} \\rangle\n$$\nThe orthogonality integral is:\n$$\n\\langle \\phi_{pq}, \\phi_{mn} \\rangle = \\int_0^{L_x} \\sin\\left(\\frac{p\\pi x}{L_x}\\right)\\sin\\left(\\frac{m\\pi x}{L_x}\\right) \\,dx \\int_0^{L_y} \\sin\\left(\\frac{q\\pi y}{L_y}\\right)\\sin\\left(\\frac{n\\pi y}{L_y}\\right) \\,dy\n$$\nUsing the identity $\\int_0^L \\sin^2\\left(\\frac{k\\pi z}{L}\\right)dz = L/2$ for integer $k \\ge 1$, the integral evaluates to $(\\frac{L_x}{2}\\delta_{pm})(\\frac{L_y}{2}\\delta_{qn})$, where $\\delta_{ij}$ is the Kronecker delta. Thus:\n$$\n\\int_0^{L_y} \\int_0^{L_x} F(x,y) \\phi_{mn}(x,y) \\,dx\\,dy = F_{mn} \\frac{L_x L_y}{4}\n$$\nSolving for $F_{mn}$:\n$$\nF_{mn} = \\frac{4}{L_x L_y} \\int_0^{L_y} \\int_0^{L_x} F(x,y) \\sin\\left(\\frac{m\\pi x}{L_x}\\right)\\sin\\left(\\frac{n\\pi y}{L_y}\\right) \\,dx\\,dy\n$$\nCombining these results gives the final expression for the streamfunction modal amplitude $A_{mn}$:\n$$\nA_{mn} = -\\frac{1}{\\lambda_{mn}} F_{mn} = -\\frac{\\frac{4}{L_x L_y} \\int_0^{L_y} \\int_0^{L_x} F(x,y) \\phi_{mn}(x,y) \\,dx\\,dy}{\\pi^2 \\left( \\frac{m^2}{L_x^2} + \\frac{n^2}{L_y^2} \\right)}\n$$\n\n### 2. Numerical Implementation\n\nThe core computational task is the evaluation of the 2D projection integral for $F_{mn}$. The problem specifies the use of two-dimensional Gauss-Legendre quadrature.\n\n#### 2.1. Gauss-Legendre Quadrature\nA 1D integral on an arbitrary interval $[a, b]$ can be approximated using Gauss-Legendre quadrature by transforming to the standard interval $[-1, 1]$:\n$$\n\\int_a^b g(z) \\,dz = \\frac{b-a}{2} \\int_{-1}^1 g\\left(\\frac{b-a}{2}\\xi + \\frac{a+b}{2}\\right) \\,d\\xi \\approx \\frac{b-a}{2} \\sum_{i=1}^{N} w_i g\\left(\\frac{b-a}{2}\\xi_i + \\frac{a+b}{2}\\right)\n$$\nwhere $\\{\\xi_i, w_i\\}_{i=1}^N$ are the $N$-point quadrature nodes and weights on $[-1, 1]$.\n\nFor the 2D integral over $[0, L_x] \\times [0, L_y]$, we apply this transformation to each dimension. The double integral becomes a double summation:\n$$\nI = \\int_0^{L_y} \\int_0^{L_x} g(x,y) \\,dx\\,dy \\approx \\frac{L_x L_y}{4} \\sum_{j=1}^{N_y} \\sum_{i=1}^{N_x} w_j w_i \\, g\\left(\\frac{L_x}{2}(\\xi_i+1), \\frac{L_y}{2}(\\eta_j+1)\\right)\n$$\nThis approach will be implemented using `numpy.polynomial.legendre.leggauss` to obtain the nodes and weights. A sufficiently high quadrature order (e.g., $N_x=N_y=128$) is chosen to ensure high precision for the smooth integrands involved.\n\n#### 2.2. Algorithmic Steps\nFor each test case:\n1.  Define the forcing function $F(x,y)$ as the sum of the provided sine modes.\n2.  Define the full integrand for the projection: $\\text{integrand}(x,y) = F(x,y) \\cdot \\phi_{mn}(x,y)$, where $(m,n)$ is the target mode.\n3.  Obtain Gauss-Legendre nodes and weights for a chosen order $N_{quad}$.\n4.  Map the nodes from $[-1, 1]$ to $[0, L_x]$ and $[0, L_y]$.\n5.  Evaluate the integrand on a 2D grid of the mapped nodes.\n6.  Compute the double summation, weighted by the product of the corresponding weights, and scale by the Jacobian factor $\\frac{L_x L_y}{4}$ to find the integral value $I_{mn}$.\n7.  Calculate the forcing coefficient $F_{mn} = \\frac{4}{L_x L_y} I_{mn}$.\n8.  Calculate the eigenvalue $\\lambda_{mn} = \\pi^2 \\left( \\frac{m^2}{L_x^2} + \\frac{n^2}{L_y^2} \\right)$.\n9.  Compute the final amplitude $A_{mn} = -F_{mn} / \\lambda_{mn}$.\n\nThis numerical procedure allows for a precise calculation of the modal amplitudes as required. The test cases, where the forcing is composed of the basis eigenfunctions, provide an excellent opportunity to verify the numerical implementation against known analytical results (e.g., for orthogonal modes, the projection should be zero; for matched modes, it should be related to the normalization constant).",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the modal amplitude A_mn of the streamfunction psi for a given\n    forcing in the Poisson equation nabla^2(psi) = F on a rectangular domain\n    with homogeneous Dirichlet boundary conditions. The solution uses a\n    double sine series spectral method, with projection integrals evaluated\n    using 2D Gauss-Legendre quadrature.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is (Lx, Ly, list_of_forcing_modes, target_mode)\n    # A forcing mode (p,q) corresponds to sin(p*pi*x/Lx)*sin(q*pi*y/Ly).\n    test_cases = [\n        (1.0, 1.0, [(1, 1)], (1, 1)),\n        (1.0, 1.0, [(2, 3)], (2, 3)),\n        (1.0, 1.0, [(2, 3)], (1, 1)),\n        (2.0, 1.0, [(1, 2)], (1, 2)),\n        (1.0, 1.0, [(1, 2), (3, 1)], (1, 2)),\n    ]\n\n    results = []\n    # Use a sufficiently high order for the quadrature to ensure precision.\n    N_QUAD = 128\n\n    # Get Gauss-Legendre nodes and weights for the standard interval [-1, 1].\n    # These will be reused for all test cases.\n    nodes, weights = np.polynomial.legendre.leggauss(N_QUAD)\n\n    for Lx, Ly, forcing_modes, target_mode in test_cases:\n        m, n = target_mode\n\n        # 1. Define the forcing function F(x, y)\n        def F(x, y, lx_loc, ly_loc, f_modes):\n            res = 0.0\n            for p, q in f_modes:\n                res += np.sin(p * np.pi * x / lx_loc) * np.sin(q * np.pi * y / ly_loc)\n            return res\n\n        # 2. Define the full integrand for the projection integral\n        def integrand(x, y, lx_loc, ly_loc, f_modes, m_loc, n_loc):\n            forcing_val = F(x, y, lx_loc, ly_loc, f_modes)\n            basis_func_val = np.sin(m_loc * np.pi * x / lx_loc) * np.sin(n_loc * np.pi * y / ly_loc)\n            return forcing_val * basis_func_val\n\n        # 3. Perform 2D Gauss-Legendre Quadrature\n        # Map nodes from [-1, 1] to [0, Lx] and [0, Ly]\n        x_mapped = 0.5 * Lx * (nodes + 1.0)\n        y_mapped = 0.5 * Ly * (nodes + 1.0)\n\n        # Vectorized calculation: create a grid of points and weights\n        xx, yy = np.meshgrid(x_mapped, y_mapped)\n        wx, wy = np.meshgrid(weights, weights)\n\n        # Evaluate the integrand on the grid of quadrature points\n        integrand_values = integrand(xx, yy, Lx, Ly, forcing_modes, m, n)\n\n        # Compute the integral by summing weighted integrand values\n        # and scaling by the Jacobian of the transformation\n        integral_val = np.sum(wx * wy * integrand_values)\n        I_mn = integral_val * (Lx / 2.0) * (Ly / 2.0)\n\n        # 4. Calculate the forcing coefficient F_mn\n        # F_mn = (4 / (Lx * Ly)) * I_mn\n        # Note: A small Lx*Ly can cause floating point issues if not handled carefully.\n        # But for this problem, the domains are well-behaved.\n        if Lx * Ly > 0:\n            F_mn = (4.0 / (Lx * Ly)) * I_mn\n        else:\n            F_mn = 0.0\n\n        # 5. Calculate the eigenvalue lambda_mn\n        lambda_mn = (np.pi**2) * ((m / Lx)**2 + (n / Ly)**2)\n\n        # 6. Compute the final amplitude A_mn\n        # Handle the case where lambda_mn is zero (m=0, n=0), though m,n >= 1\n        # in this problem, so lambda_mn will always be positive.\n        if lambda_mn == 0:\n            A_mn = 0.0\n        else:\n            A_mn = -F_mn / lambda_mn\n        \n        results.append(A_mn)\n\n    # 7. Format the output to 12 decimal places as specified.\n    formatted_results = [f\"{r:.12f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}