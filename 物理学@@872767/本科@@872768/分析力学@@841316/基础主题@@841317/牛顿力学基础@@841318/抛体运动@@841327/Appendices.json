{"hands_on_practices": [{"introduction": "理解抛体运动的基本方程是第一步，但真正的掌握来自于应用这些方程来关联弹道的不同方面。这个练习 [@problem_id:2209981] 要求你推导最大高度和水平射程之间的关系，这是一个经典问题，可以加深你对发射角度如何控制飞行路径形状的理解。通过解决这个问题，你将在一个理想的、无阻力的环境中，熟练地运用核心运动学方程。", "problem": "一家体育分析公司正在为一款新的虚拟现实游戏设计一个逼真的物理引擎。游戏中的一个关键机制涉及从地面以初速度 $v_0$ 和与水平方向成 $\\theta$ 角的角度抛出一个球。在一项特定的游戏挑战中，球的轨迹必须满足一个精确的美学条件：它在落回地面之前所经过的总水平距离（其射程 $R$）必须恰好是其最大垂直高度 ($H$) 的 $n$ 倍。球的抛出点和落地点处于同一垂直高度。\n\n假设重力加速度为常数 $g$ 且空气阻力可忽略不计，请推导出发射角 $\\theta$ 关于无量纲因子 $n$ 的解析表达式。", "solution": "设初速度为 $v_{0}$，发射角为与水平方向夹角为 $\\theta$。在向下的恒定重力加速度 $g$ 作用下且无空气阻力时，抛体的运动方程为\n$$\nx(t)=v_{0}\\cos\\theta\\, t,\\qquad y(t)=v_{0}\\sin\\theta\\, t-\\frac{1}{2}gt^{2}.\n$$\n飞行时间 $T$（返回到发射高度，因此当 $T>0$ 时 $y(T)=0$）满足\n$$\n0=v_{0}\\sin\\theta\\, T-\\frac{1}{2}gT^{2}\\quad\\Rightarrow\\quad T=\\frac{2v_{0}\\sin\\theta}{g}.\n$$\n射程 $R$ 是 $t=T$ 时的水平位移：\n$$\nR=x(T)=v_{0}\\cos\\theta\\left(\\frac{2v_{0}\\sin\\theta}{g}\\right)=\\frac{v_{0}^{2}}{g}\\sin(2\\theta).\n$$\n当竖直速度为零时，达到最大高度 $H$。竖直速度为 $v_{y}(t)=v_{0}\\sin\\theta-gt$，因此令 $v_{y}(t_{h})=0$ 可得\n$$\nt_{h}=\\frac{v_{0}\\sin\\theta}{g}.\n$$\n因此，\n$$\nH=y(t_{h})=v_{0}\\sin\\theta\\left(\\frac{v_{0}\\sin\\theta}{g}\\right)-\\frac{1}{2}g\\left(\\frac{v_{0}\\sin\\theta}{g}\\right)^{2}=\\frac{v_{0}^{2}\\sin^{2}\\theta}{2g}.\n$$\n条件 $R=nH$ 导出\n$$\n\\frac{v_{0}^{2}}{g}\\sin(2\\theta)=n\\left(\\frac{v_{0}^{2}\\sin^{2}\\theta}{2g}\\right).\n$$\n消去公因式 $\\frac{v_{0}^{2}}{g}$ 并使用 $\\sin(2\\theta)=2\\sin\\theta\\cos\\theta$，\n$$\n\\sin(2\\theta)=\\frac{n}{2}\\sin^{2}\\theta\n\\quad\\Rightarrow\\quad\n2\\sin\\theta\\cos\\theta=\\frac{n}{2}\\sin^{2}\\theta\n\\quad\\Rightarrow\\quad\n4\\cos\\theta=n\\sin\\theta.\n$$\n因此，\n$$\n\\cot\\theta=\\frac{n}{4}\\quad\\Rightarrow\\quad \\tan\\theta=\\frac{4}{n}\\quad\\Rightarrow\\quad \\theta=\\arctan\\!\\left(\\frac{4}{n}\\right).\n$$\n对于 $n>0$，这给出了在区间 $(0,\\frac{\\pi}{2})$ 内唯一具有物理意义的发射角。", "answer": "$$\\boxed{\\arctan\\!\\left(\\frac{4}{n}\\right)}$$", "id": "2209981"}, {"introduction": "真实世界的场景常常涉及运动物体之间的相互作用。这个问题通过引入相对速度的概念，为理想抛体运动增加了一层复杂性。你被要求确定一个抛体的初始发射条件，该抛体在满足特定相对运动约束的情况下，被一个移动物体拦截。这个练习 [@problem_id:2210027] 旨在锻炼你将运动分解为分量，并分析不同参考系下速度如何叠加的能力。", "problem": "一位工程师正在测试一种新的抛射物发射系统。一个小球从水平地面上的一个点被发射出去。同时，一架配备了捕捉装置的研究无人机从一个很高的高度开始垂直下降。无人机以恒定的速度 $v_L$ 下降。当小球处于离地高度为 $h$ 时，无人机成功拦截并捕捉到了它。在拦截的精确时刻，无人机测得小球的速度完全是水平的。假设重力加速度为 $g$ 且空气阻力可以忽略不计，求小球发射速度的初始垂直分量。请用 $h$、$v_L$ 和 $g$ 的符号表达式表示你的答案。", "solution": "选择垂直轴向上为正方向，地面为 $y=0$。设小球的初始垂直速度为 $v_{0y}$。无人机以恒定速度 $v_{L}$ 下降，所以其垂直速度为 $-v_{L}$。\n\n忽略空气阻力，小球的垂直运动遵循运动学方程：\n$$\ny(t) = v_{0y} t - \\frac{1}{2} g t^{2}, \\quad v_{y}(t) = v_{0y} - g t.\n$$\n在拦截时，满足两个条件：\n1) 小球的高度为 $h$，所以 $y(t)=h$。\n2) 小球相对于无人机的速度完全是水平的，这要求它们的垂直速度分量相等：$v_{y}(t) = -v_{L}$。\n\n根据第二个条件，\n$$\nv_{0y} - g t = -v_{L} \\quad \\Rightarrow \\quad t = \\frac{v_{0y} + v_{L}}{g}.\n$$\n将这个 $t$ 代入 $y(t)=h$：\n$$\nh = v_{0y} \\left(\\frac{v_{0y} + v_{L}}{g}\\right) - \\frac{1}{2} g \\left(\\frac{v_{0y} + v_{L}}{g}\\right)^{2}.\n$$\n化简右侧：\n$$\nh = \\frac{v_{0y}(v_{0y} + v_{L})}{g} - \\frac{(v_{0y} + v_{L})^{2}}{2g}\n= \\frac{1}{2g}\\left[v_{0y}^{2} - v_{L}^{2}\\right].\n$$\n因此，\n$$\nv_{0y}^{2} = v_{L}^{2} + 2 g h.\n$$\n由于小球必须向上发射，我们取正根：\n$$\nv_{0y} = \\sqrt{v_{L}^{2} + 2 g h}.\n$$\n这就是用 $h$、$v_{L}$ 和 $g$ 表示的发射速度的初始垂直分量。", "answer": "$$\\boxed{\\sqrt{v_{L}^{2} + 2 g h}}$$", "id": "2210027"}, {"introduction": "虽然理想模型很有用，但大多数真实世界的抛体运动都会受到空气阻力的显著影响。这个高级实践将带你超越解析解，进入计算物理的领域。你将实现一个数值“打靶法”，在考虑二次空气阻力（一个更符合实际的模型）的情况下，找到击中目标所需的正确发射角度。这个动手编程练习 [@problem_id:2430429] 不仅展示了计算工具在解决真实物理问题时的强大能力，还提供了数值积分和求根算法的实践经验。", "problem": "一个质量为 $m$ 的二维抛体从原点以初速度 $v_0$ 发射，发射角 $\\theta$ 为与水平方向的夹角。该抛体在匀重力加速度 $\\mathbf{g} = (0,-g)$ 下运动，并受到与速度平方成正比、与瞬时速度方向相反的二次空气动力阻力。使用牛顿第二定律对阻力进行建模如下。设状态为 $\\mathbf{r}(t) = (x(t),y(t))$ 和 $\\mathbf{v}(t) = (v_x(t),v_y(t))$，其中 $v(t) = \\sqrt{v_x(t)^2 + v_y(t)^2}$。运动方程为\n$$\n\\frac{d x}{d t} = v_x, \\quad \\frac{d y}{d t} = v_y,\n$$\n$$\n\\frac{d v_x}{d t} = -k\\, v\\, v_x, \\quad \\frac{d v_y}{d t} = -g - k\\, v\\, v_y,\n$$\n初始条件为\n$$\nx(0) = 0,\\quad y(0) = 0,\\quad v_x(0) = v_0 \\cos\\theta,\\quad v_y(0) = v_0 \\sin\\theta.\n$$\n阻力参数 $k$ 定义为\n$$\nk = \\frac{\\tfrac{1}{2}\\,\\rho\\, C_d\\, A}{m},\n$$\n其中 $\\rho$ 是空气密度，$C_d$ 是阻力系数，$A$ 是横截面积。\n\n您的任务是编写一个完整、可运行的程序，对于每个目标点 $(x_T,y_T)$，使用求根算法来确定所有能使抛体在高度 $y=y_T$ 处通过垂直线 $x=x_T$ 的发射角 $\\theta \\in (0,\\tfrac{\\pi}{2})$（严格介于水平和垂直之间）。求根过程必须应用于一个根据第一性原理构造的关于发射角的标量函数，具体如下。\n\n1. 对于给定的 $\\theta$，定义标量函数\n$$\nF(\\theta) = y\\big(t^\\star(\\theta)\\big) - y_T,\n$$\n其中 $t^\\star(\\theta)$ 是以速度 $v_0$、角度 $\\theta$ 发射的飞行过程中，$x\\big(t^\\star(\\theta)\\big) = x_T$ 首次出现的时间（如果存在）。如果抛体从未到达 $x_T$（例如，在 $x$ 到达 $x_T$ 之前就以 $y=0$ 落地），则 $F(\\theta)$ 未定义，该 $\\theta$ 不应用于求根的区间括号对。\n\n2. 一个有效的解角度 $\\theta^\\star$ 满足 $F(\\theta^\\star) = 0$。您的程序必须系统地搜索区间 $\\theta \\in [\\theta_{\\min}, \\theta_{\\max}]$（其中 $\\theta_{\\min} = 0.1^\\circ$，$ \\theta_{\\max} = 89.9^\\circ$）以检测 $F(\\theta)$ 符号改变的子区间，然后对每个检测到的子区间应用一维求根算法（例如，区间法）以收敛到一个根。\n\n3. 如果存在多个不同的根，必须找到并报告所有在 $(0^\\circ,90^\\circ)$ 内的此类角度。如果不存在根，则为该情况报告一个空列表。\n\n数值要求和约定：\n\n- 使用上述微分方程和初始条件作为唯一的物理模型；不要代入任何闭式轨迹公式。\n- 实现一个数值常微分方程积分器，当 $x(t)$ 首次等于 $x_T$（如果发生）或抛体在下降过程中撞击地面 $y(t)=0$ 时停止。使用足够严格的容差以可靠地检测穿越事件。\n- 距离单位必须是米，时间单位是秒，质量单位是千克，空气密度单位是千克/立方米，面积单位是平方米，加速度单位是米/平方秒。角度必须以度为单位报告。\n- 报告每个解角度，以度为单位，四舍五入到三位小数。\n- 如果在穿越时间 $t^\\star$ 时，值 $|y(t^\\star) - y_T|$ 在 $10^{-3}$ 米以内，则该解角度是可接受的。您的求根容差应确保达到此目标精度。\n- 为了可复现性，对所有测试用例使用以下固定的物理参数：$m = 0.145$ 千克, $\\rho = 1.225$ 千克/立方米, $C_d = 0.47$, $A = 0.0042$ 平方米, 以及 $g = 9.81$ 米/平方秒。\n\n覆盖不同情况的测试套件：\n\n- 情况1（理想情况，地面目标，预计有两个解）：$v_0 = 40.0$ 米/秒, $(x_T,y_T) = (80.0, 0.0)$ 米。\n- 情况2（高处目标，通常有一或两个解）：$v_0 = 40.0$ 米/秒, $(x_T,y_T) = (60.0, 10.0)$ 米。\n- 情况3（近程，预计有两个解）：$v_0 = 30.0$ 米/秒, $(x_T,y_T) = (30.0, 0.0)$ 米。\n- 情况4（超出最大射程，预计无解）：$v_0 = 40.0$ 米/秒, $(x_T,y_T) = (200.0, 0.0)$ 米。\n\n程序输入和输出规范：\n\n- 没有外部输入。使用上述确切的常量和测试套件。\n- 您的程序应生成单行输出，其中包含四个情况的结果，格式为方括号内由逗号分隔的列表。每个情况的结果必须是一个解角度（以度为单位）的列表，按升序排序并四舍五入到三位小数。如果某个情况没有解，则为该情况输出一个空列表。\n- 例如，要求的整体输出格式类似于 $[ [\\ldots], [\\ldots], [\\ldots], [\\ldots] ]$，其中的数值条目以十进制形式显示，没有额外文本。\n\n您的程序必须是完整且可直接运行的，并且必须使用应用于如上定义的 $F(\\theta)$ 的求根算法来为每种情况定位解角度。角度必须以度为单位报告。", "solution": "所提出的问题是计算物理学中一个定义明确且标准的练习。它具有科学依据，数学上一致，并且提供了求解所需的所有必要参数。该物理模型基于牛顿第二定律和二次空气阻力，是粘性介质中抛体运动的典型表示。数值任务是找到使抛体穿过特定目标点的发射角，这构成了一个边值问题。规定的求解方法——打靶法结合标量函数的求根算法——对于这类问题是一种稳健且恰当的技术。因此，该问题是有效的，我们将着手提供一个完整的解决方案。\n\n问题的核心是求解一个耦合一阶常微分方程（ODEs）组。设系统在时间 $t$ 的状态由向量 $\\mathbf{S}(t) = [x(t), y(t), v_x(t), v_y(t)]^T$ 描述。运动方程可以写成 $\\frac{d\\mathbf{S}}{dt} = \\mathbf{f}(t, \\mathbf{S})$ 的形式，其中函数 $\\mathbf{f}$ 定义为：\n$$\n\\mathbf{f}(t, \\mathbf{S}) = \n\\begin{pmatrix}\nv_x \\\\\nv_y \\\\\n-k \\sqrt{v_x^2 + v_y^2} \\, v_x \\\\\n-g - k \\sqrt{v_x^2 + v_y^2} \\, v_y\n\\end{pmatrix}\n$$\n在 $t=0$ 时的初始状态由 $\\mathbf{S}(0) = [0, 0, v_0 \\cos\\theta, v_0 \\sin\\theta]^T$ 给出。参数 $\\theta$ 是发射角，这是我们必须确定的。\n\n对于这个系统，轨迹 $\\mathbf{r}(t)$ 不存在直接的解析解。我们必须采用数值方法。问题要求我们找到使轨迹通过目标点 $(x_T, y_T)$ 的 $\\theta$ 值。这是一个边值问题。我们将使用“打靶法”来解决它，该方法将边值问题转化为求根问题。\n\n打靶法的步骤如下：\n1.  我们选择一个试验发射角 $\\theta$。这完全确定了初始条件 $\\mathbf{S}(0)$。\n2.  我们从 $t=0$ 开始，随时间向前数值积分该ODE系统。这个过程就是“发射”抛体。\n3.  我们监控轨迹，找到抛体的水平位置 $x(t)$ 首次等于目标水平位置 $x_T$ 的时间 $t^\\star$。\n4.  在这个时间 $t^\\star$，我们计算抛体的高度 $y(t^\\star)$。\n5.  我们定义一个标量目标函数 $F(\\theta)$，作为抛体在 $x=x_T$ 处的高度与目标高度 $y_T$ 之间的差值：\n    $$\n    F(\\theta) = y\\big(t^\\star(\\theta)\\big) - y_T\n    $$\n    一个解角度 $\\theta^\\star$ 满足 $F(\\theta^\\star) = 0$。因此，问题被简化为寻找函数 $F(\\theta)$ 的根。\n\n为了实现这个方法，我们需要一个稳健的ODE积分器。SciPy库中的 `solve_ivp` 函数是完成此任务的绝佳工具。`solve_ivp` 的一个关键特性是它能够检测“事件”——即状态和时间的某个函数变为零的条件。我们将利用此特性来精确确定穿越时间 $t^\\star$，而无需积分到固定的最大时间然后进行插值。\n\n我们定义两个终端事件函数：\n1.  `event_reach_x_target(t, S)`：该函数返回 $x(t) - x_T$。当此值为零时，积分器将停止，表示抛体已到达目标的水平位置。\n2.  `event_hit_ground(t, S)`：该函数返回 $y(t)$。我们将其配置为仅当 $y(t)$ 减小时（即抛体正在下落）触发，这标志着抛体在到达 $x=x_T$ 之前已经落地。\n\n函数 $F(\\theta)$ 是通过为给定的 $\\theta$ 调用ODE求解器来构造的。如果积分因 `event_reach_x_target` 事件而终止，我们计算并返回 $y(t^\\star) - y_T$。如果积分因 `event_hit_ground` 而终止，或者在未触发任何事件的情况下达到了最大仿真时间，这意味着轨迹射程不足。在这种情况下，对于区间确定而言，$F(\\theta)$ 函数被认为是未定义的，我们可以返回一个非数值，如 `NaN`（非数字），来表示这一点。\n\n为了在指定区间 $\\theta \\in [0.1^\\circ, 89.9^\\circ]$ 内找到 $F(\\theta)=0$ 的所有根，我们采用一个两阶段过程：\n1.  **区间划分**：我们首先将搜索区间离散化为一个精细的角度网格。我们计算网格上每个点的 $F(\\theta)$。通过搜索函数符号发生变化的相邻网格点 $(\\theta_i, \\theta_{i+1})$（即 $F(\\theta_i) \\cdot F(\\theta_{i+1})  0$），我们根据介值定理确定了保证至少包含一个根的子区间。正确处理 `NaN` 情况非常重要，因为一个有效的括号区间需要在两端都有定义的数值。\n2.  **求解**：对于找到的每个括号区间 $[\\theta_a, \\theta_b]$，我们应用一个数值求根算法。在 `scipy.optimize.brentq` 中实现的 Brent 方法是一个非常有效的选择。它结合了二分法的保证收敛性和割线法的更快收敛速度，是在已知括号区间时进行一维求根的标准方法。求根器的容差将被设置以确保在角度和最终目标高度上都达到所需的精度。\n\n这个包含数值积分、事件检测、区间划分和求根的系统性程序将应用于每个测试用例，以找到所有有效的发射角。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Main function to solve the projectile motion problem for all test cases.\n    \"\"\"\n    # Fixed physical parameters\n    M = 0.145  # mass in kg\n    RHO = 1.225  # air density in kg/m^3\n    C_D = 0.47  # drag coefficient (dimensionless)\n    A = 0.0042  # cross-sectional area in m^2\n    G = 9.81  # gravitational acceleration in m/s^2\n\n    # Derived drag parameter k = (rho * C_d * A) / (2 * m)\n    K = (0.5 * RHO * C_D * A) / M\n\n    # Test suite\n    test_cases = [\n        (40.0, (80.0, 0.0)),   # Case 1\n        (40.0, (60.0, 10.0)),  # Case 2\n        (30.0, (30.0, 0.0)),   # Case 3\n        (40.0, (200.0, 0.0)),  # Case 4\n    ]\n\n    def derivatives(t, state, k, g):\n        \"\"\"\n        Computes the derivatives for the system of ODEs.\n        state = [x, y, v_x, v_y]\n        \"\"\"\n        x, y, vx, vy = state\n        v = np.sqrt(vx**2 + vy**2)\n        \n        # Avoid division by zero if velocity is zero, though unlikely in this problem.\n        if v == 0:\n            ax = 0\n            ay = -g\n        else:\n            ax = -k * v * vx\n            ay = -g - k * v * vy\n            \n        return [vx, vy, ax, ay]\n\n    def calculate_y_error_at_xT(theta_deg, v0, xT, yT, k_param, g_param):\n        \"\"\"\n        Calculates the error F(theta) = y(t*) - yT for a given launch angle.\n        Returns np.nan if the projectile does not reach xT.\n        \"\"\"\n        theta_rad = np.deg2rad(theta_deg)\n        vx0 = v0 * np.cos(theta_rad)\n        vy0 = v0 * np.sin(theta_rad)\n        \n        initial_state = [0.0, 0.0, vx0, vy0]\n        \n        # Event: projectile reaches the target's x-coordinate\n        def reach_x_target(t, state, k, g):\n            return state[0] - xT\n        reach_x_target.terminal = True\n        reach_x_target.direction = 1 # Trigger only when x is increasing\n\n        # Event: projectile hits the ground (y=0)\n        def hit_ground(t, state, k, g):\n            return state[1]\n        hit_ground.terminal = True\n        hit_ground.direction = -1 # Trigger only when y is decreasing\n\n        t_span = (0, 100) # Max integration time of 100s is sufficient\n        sol = solve_ivp(\n            fun=derivatives,\n            t_span=t_span,\n            y0=initial_state,\n            args=(k_param, g_param),\n            events=[reach_x_target, hit_ground],\n            dense_output=True,\n            rtol=1e-8,\n            atol=1e-8\n        )\n\n        # Check which event terminated the integration\n        if sol.status == 1 and sol.t_events[0].size > 0:\n            # The 'reach_x_target' event was triggered\n            y_at_t_star = sol.y_events[0][0][1]\n            return y_at_t_star - yT\n        else:\n            # Projectile hit the ground first or integration timed out\n            return np.nan\n\n    all_results = []\n    for v0, (xT, yT) in test_cases:\n        \n        # Define the function for root finding, which depends on the case parameters\n        objective_func = lambda th: calculate_y_error_at_xT(th, v0, xT, yT, K, G)\n\n        # 1. Bracketing stage: Scan the angle range to find sign changes\n        theta_min_deg = 0.1\n        theta_max_deg = 89.9\n        scan_step_deg = 0.5  # Step size for scanning\n        \n        angles_to_scan = np.arange(theta_min_deg, theta_max_deg + scan_step_deg, scan_step_deg)\n        f_values = np.array([objective_func(th) for th in angles_to_scan])\n        \n        case_roots = []\n        for i in range(len(angles_to_scan) - 1):\n            th1, f1 = angles_to_scan[i], f_values[i]\n            th2, f2 = angles_to_scan[i+1], f_values[i+1]\n\n            if not np.isnan(f1) and not np.isnan(f2):\n                if f1 * f2  0:\n                    # Found a bracket [th1, th2]\n                    try:\n                        # 2. Solving stage: Find the root within the bracket\n                        root_deg = brentq(objective_func, th1, th2, xtol=1e-5)\n                        # Check if this root is a duplicate before adding\n                        is_duplicate = False\n                        for existing_root in case_roots:\n                            if abs(root_deg - existing_root)  1e-4:\n                                is_duplicate = True\n                                break\n                        if not is_duplicate:\n                            case_roots.append(root_deg)\n                    except ValueError:\n                        # brentq can fail if signs are not opposite, though our check prevents this.\n                        pass\n        \n        case_roots.sort()\n        all_results.append([round(r, 3) for r in case_roots])\n\n    # Format the final output string as specified\n    case_strs = []\n    for res_list in all_results:\n        num_strs = [f\"{num:.3f}\" for num in res_list]\n        case_strs.append(f\"[{','.join(num_strs)}]\")\n    \n    print(f\"[{','.join(case_strs)}]\")\n\nsolve()\n```", "id": "2430429"}]}