{"hands_on_practices": [{"introduction": "真实世界的时间序列数据常常被噪声污染。本练习将介绍一种基础技术——移动平均法，它能有效滤除高频随机波动，从而更好地揭示潜在的趋势或信号。计算移动平均是任何时间序列分析的必备基础技能。[@problem_id:1723028]", "problem": "一位研究人员正在分析一种新材料的温度稳定性。一个传感器每秒记录一次材料的温度，但原始数据受到高频电子噪声的影响。为了辨别潜在的温度趋势，应用了一种称为移动平均的常用信号处理技术。\n\n考虑以下在时间索引 $i=1, 2, ..., 9$ 记录的九个连续温度测量值序列 $T_i$：\n$T = \\{35.3, 36.2, 35.1, 34.7, 35.8, 35.2, 36.1, 34.9, 35.5\\}$\n\n在给定时间索引 $i$ 处，平滑后时间序列的值是使用5点中心移动平均计算的。这被定义为索引 $i$ 处的数据点、其紧邻的前两个数据点以及紧邻的后两个数据点的算术平均值。\n\n使用此定义，计算时间索引 $i=6$ 处的平滑后温度值。答案以摄氏度表示，并四舍五入到三位有效数字。", "solution": "在索引 $i$ 处的5点中心移动平均定义为索引 $i-2$、$i-1$、$i$、$i+1$ 和 $i+2$ 处的值的算术平均值。将平滑后的值表示为 $\\overline{T}_{i}$。那么\n$$\n\\overline{T}_{i}=\\frac{1}{5}\\sum_{k=-2}^{2}T_{i+k}.\n$$\n对于 $i=6$，所需的索引是 $4,5,6,7,8$，其对应的值为 $T_{4}=34.7$、$T_{5}=35.8$、$T_{6}=35.2$、$T_{7}=36.1$ 和 $T_{8}=34.9$。它们的和是\n$$\n34.7+35.8=70.5,\\quad 70.5+35.2=105.7,\\quad 105.7+36.1=141.8,\\quad 141.8+34.9=176.7.\n$$\n因此，\n$$\n\\overline{T}_{6}=\\frac{176.7}{5}=35.34.\n$$\n四舍五入到三位有效数字得到 $35.3$。", "answer": "$$\\boxed{35.3}$$", "id": "1723028"}, {"introduction": "除了观察时间序列本身，理解其物理意义也至关重要。由于速度是位置的变化率，即 $v(t) = \\frac{dx}{dt}$，速度时间序列的形态通过积分直接决定了位置时间序列的形态。本练习旨在训练你将速度图谱所描述的动力学过程，转化为物体相应的位置轨迹。[@problem_id:1722993]", "problem": "一个自主仓库漫游车被设计用来沿着一条笔直的一维轨道移动。该漫游车从其充电站静止开始运动，我们将其充电站定义为坐标系的原点，因此其初始位置为 $x(0) = 0$。\n\n漫游车的速度 $v(t)$ 根据一个预设程序在三个不同的时间间隔内进行控制。这些时间间隔由时间标记 $T_1$ 和 $T_2$ 定义，其中 $0  T_1  T_2$。运动的总持续时间为 $t_{final}$。\n\n运动概况如下：\n1.  在时间间隔 $0 \\leq t \\leq T_1$ 内，漫游车经历恒定的正加速度。\n2.  在时间间隔 $T_1  t \\leq T_2$ 内，漫游车以恒定的正速度移动。\n3.  在时间间隔 $T_2  t \\leq t_{final}$ 内，漫游车经历恒定的负加速度，并在时间 $t_{final}$ 完全停止。\n\n在从 $t=0$ 到 $t=t_{final}$ 的整个过程中，漫游车的速度从不为负。\n\n设 $x(t)$ 表示漫游车位置随时间变化的函数。根据所提供的信息，以下哪个选项对位置-时间函数 $x(t)$ 进行了正确的定性描述？\n\nA. $x(t)$ 的图像是一条斜率递增的直线，然后是一条平坦的水平线，接着是一条斜率递减的直线。\n\nB. $x(t)$ 的图像是一条开口向上的抛物线，然后是一条正斜率的直线，接着是一条开口向下的抛物线。\n\nC. $x(t)$ 的图像是一条正斜率的直线，然后是一条开口向上的抛物线，接着是一条负斜率的直线。\n\nD. $x(t)$ 的图像是在整个运动期间内一条单一、连续的开口向上的抛物线。\n\nE. $x(t)$ 的图像是一条开口向上的抛物线，然后是一条正斜率的直线，接着是另一条开口向上的抛物线。", "solution": "使用运动学关系 $v(t)=\\frac{dx}{dt}$ 和 $a(t)=\\frac{dv}{dt}=\\frac{d^{2}x}{dt^{2}}$。$x(t)$ 的定性形状取决于每个区间内 $a(t)$ 的符号和恒定性。\n\n对于 $0 \\leq t \\leq T_{1}$，加速度是恒定且为正；记为 $a_{1}>0$。由于 $v(0)=0$，积分可得\n$$\nv(t)=a_{1}t \\quad \\text{and} \\quad x(t)=\\int_{0}^{t} v(\\tau)\\,d\\tau=\\frac{1}{2}a_{1}t^{2}.\n$$\n因此 $\\frac{d^{2}x}{dt^{2}}=a_{1}>0$，所以 $x(t)$ 是一条开口向上（凹向上）的抛物线，其斜率递增。\n\n对于 $T_{1}  t \\leq T_{2}$，速度是恒定且为正；记为 $v_{2}>0$。则 $a(t)=0$ 且\n$$\nx(t)=x(T_{1})+v_{2}(t-T_{1}),\n$$\n这是一条正斜率的直线。\n\n对于 $T_{2}  t \\leq t_{\\text{final}}$，加速度是恒定且为负；记为 $a_{3}0$。速度演变为\n$$\nv(t)=v(T_{2})+a_{3}(t-T_{2}),\n$$\n根据假设，速度线性减小到在 $t_{\\text{final}}$ 时为 $0$，同时保持非负。积分，\n$$\nx(t)=x(T_{2})+v(T_{2})(t-T_{2})+\\frac{1}{2}a_{3}(t-T_{2})^{2},\n$$\n所以 $\\frac{d^{2}x}{dt^{2}}=a_{3}0$，这是一条开口向下（凹向下）的抛物线，其斜率递减至零。\n\n因此，位置-时间图像是：开口向上的抛物线，然后是正斜率的直线，接着是开口向下的抛物线。这对应于选项 B。其他选项不一致：A 将匀速运动错误地描述为水平线，并使用了“斜率递增的直线”，这是不可能的；C 和 E 在各段中的曲率或斜率符号不正确；D 假设在整个过程中加速度恒为正，而这并未给出。", "answer": "$$\\boxed{B}$$", "id": "1722993"}, {"introduction": "动力系统的一个关键特征是分岔的可能性——即当一个参数变化时，系统行为发生突然的质变。这个高级计算练习将引导你学习一种现代方法，直接从时间序列数据中检测此类变化，而无需事先知道系统模型。你将使用时间延迟嵌入重构系统的吸引子，并应用代理数据方法对其复杂度的变化进行统计检验。[@problem_id:2376563]", "problem": "您将执行一项概念性任务，该任务基于时间延迟嵌入和代理数据方法，旨在分析标量离散时间序列，以寻找与分岔一致的动力学性质变化的证据。您必须编写一个完整且可运行的程序，为每个提供的测试用例，使用时间延迟嵌入重构状态空间，在两个时间窗口上估计一个非线性不变量，构建一个保留线性特性的代理数据零分布，并执行假设检验，以判断两个窗口之间是否存在类似分岔变化的统计显著性证据。最终输出必须是单行，内容为方括号内以逗号分隔的布尔值列表。\n\n从基本定义开始。标量时间序列是一个以均匀间隔采样的序列 $\\{x_n\\}_{n=0}^{N-1}$。根据 Takens 嵌入定理，可以通过构建延迟向量 $\\mathbf{X}_n = \\left(x_n, x_{n-\\tau}, \\dots, x_{n-(m-1)\\tau}\\right)$，从单个可观测量中重构出光滑动力系统潜在吸引子的微分同胚图像，其中嵌入维度为 $m$，延迟为 $\\tau$。您将使用关联和来估计重构吸引子的结构复杂性，其定义为对于 $M$ 个嵌入点 $\\{\\mathbf{X}_i\\}_{i=0}^{M-1}$：\n$$\nC(r) = \\frac{2}{M(M-1)} \\sum_{0 \\le i  j \\le M-1} \\Theta\\!\\left(r - \\left\\|\\mathbf{X}_i - \\mathbf{X}_j\\right\\|\\right),\n$$\n其中 $\\Theta$ 是赫维赛德阶跃函数，$\\|\\cdot\\|$ 是欧几里得范数。在合适的 $r$ 标度范围内，$\\log C(r)$ 与 $\\log r$ 的关系图的斜率可作为关联维数的代理，后者是吸引子的标准复杂度度量。\n\n为了使计算在有限数据下具有统计鲁棒性和计算效率，您必须：\n- 在计算距离时使用 Theiler 窗排除时间上相邻的点对，具体要求 $|i-j| > w$，其中 $w = m\\tau$。\n- 通过选择基于采样的成对距离分位数的标度范围内的半径 $r$ 来估计斜率。您可以在距离分布的两个分位数之间，使用固定数量的对数间隔的半径值，并通过在该范围上对 $\\log C(r)$ 和 $\\log r$ 进行线性回归来获得斜率。\n- 通过对满足 $i \\ne j$ 和 $|i-j| > w$ 的不同点对 $(i,j)$ 进行大量均匀随机抽样来近似关联和。\n\n为检验时间序列的早期窗口和晚期窗口之间是否存在类似分岔的变化，使用振幅调整傅里叶变换 (AAFT) 方法构建代理数据零模型，该方法保留了边际振幅分布并近似了功率谱（因此也近似了自相关）。对于每个窗口：\n- 生成 $S$ 个独立的 AAFT 代理数据。\n- 对于每个窗口和每个代理数据，计算上述相同的斜率统计量。\n- 令 $\\Delta_{\\mathrm{obs}}$ 为晚期和早期斜率之间的观测差异。通过跨窗口配对代理数据，构建一个差异的蒙特卡洛零分布，以获得 $\\{\\Delta_s\\}_{s=1}^S$，并计算双边蒙特卡洛 $p$ 值：\n$$\np = \\frac{1 + \\#\\{s : |\\Delta_s| \\ge |\\Delta_{\\mathrm{obs}}|\\}}{S+1}.\n$$\n如果对于选定的显著性水平 $\\alpha$，有 $p  \\alpha$，则判定存在分岔的证据。\n\n实施以下测试套件。在所有情况下，使用嵌入维度 $m = 3$，延迟 $\\tau = 1$，Theiler 窗 $w = m\\tau$，代理数据数量 $S = 20$，点对样本大小 $P = 8000$，显著性水平 $\\alpha = 0.05$，并使用固定的随机种子以保证可复现性。程序必须在内部生成每个时间序列，并在嵌入前通过减去其均值并除以其标准差来标准化每个分析窗口。\n\n- 测试用例 1（平稳非线性动力学，预期无分岔）：使用固定参数 $r = 3.70$ 的逻辑斯蒂映射。从 $x_0 = 0.2$ 开始生成 $N = 4096$ 个点，并在分析前丢弃前 $512$ 个值作为暂态。\n- 测试用例 2（慢参数漂移穿过性质变化，预期有分岔）：使用线性斜坡参数 $r_n$ 的逻辑斯蒂映射，该参数在 $N = 4096$ 个点上从 $r_{\\min} = 3.20$ 增加到 $r_{\\max} = 3.70$，从 $x_0 = 0.2$ 开始，在分析前丢弃前 $256$ 个点。\n- 测试用例 3（线性随机动力学，预期无分岔）：由 $x_{n+1} = \\phi x_n + \\epsilon_n$ 给出的 1 阶自回归过程，其中 $\\phi = 0.8$，$\\epsilon_n \\sim \\mathcal{N}(0,\\sigma^2)$ 且 $\\sigma = 0.5$，生成 $N = 4096$ 个点，并在分析前丢弃前 $512$ 个点作为暂态。\n\n您的程序必须对每个测试用例执行上述过程，并判断时间序列的早期和晚期半段之间是否存在分岔的统计显著性证据。最终输出必须是单行，按测试用例 1、2、3 的顺序列出三个布尔结果，格式为方括号内以逗号分隔的列表（例如，“[True,False,True]”）。此任务不涉及物理单位。如果中间计算出现角度，则默认为弧度。\n\n您的实现必须是完整和自包含的，并且不能需要任何用户输入。程序应以指定格式精确输出一行。", "solution": "该问题提出了一个在非线性时间序列分析领域中形式良好、定义明确的计算任务。它基于既定的科学原理，并为其实现提供了清晰、客观和完整的规范。该任务是创建一个程序，通过比较两个时间窗口内的复杂度度量，并使用基于代理数据的假设检验来确定统计显著性，从而测试标量时间序列中是否存在类似分岔的动力学变化。\n\n解决方案的结构是首先实现分析的基本组件，然后将它们集成到一个完整的假设检验过程中，并应用于指定的测试用例。核心原理是状态空间重构、作为复杂度度量的关联维数，以及用于生成零假设数据的振幅调整傅里叶变换 (AAFT) 方法。\n\n首先，我们处理状态空间重构的原理。根据 Takens 嵌入定理，系统的动力学可以从单个时间序列可观测量 $\\{x_n\\}$ 中重构出来。这是通过形成 $m$ 维延迟向量 $\\mathbf{X}_n = (x_n, x_{n-\\tau}, \\dots, x_{n-(m-1)\\tau})$ 来实现的，其中 $m$ 是嵌入维度，$\\tau$ 是时间延迟。对于此问题，我们使用指定的值 $m=3$ 和 $\\tau=1$。这些向量的集合 $\\{\\mathbf{X}_n\\}$ 在 $m$ 维状态空间中形成一条轨迹，在某些条件下，该轨迹与原始系统的吸引子是微分同胚的。\n\n其次，我们使用关联维数 $\\nu$ 的代理来量化重构吸引子的几何复杂性。关联和 $C(r)$ 测量吸引子上随机选择的两个点相距小于 $r$ 的概率。对于 $M$ 个点，其形式化定义为：\n$$\nC(r) = \\frac{2}{M(M-1)} \\sum_{0 \\le i  j \\le M-1} \\Theta(r - \\|\\mathbf{X}_i - \\mathbf{X}_j\\|)\n$$\n其中 $\\Theta$ 是赫维赛德阶跃函数。对于分形吸引子，$C(r)$ 在一定半径范围内表现出幂律标度关系，$C(r) \\propto r^\\nu$。指数 $\\nu$ 就是关联维数。我们通过线性回归计算 $\\log{C(r)}$ 对 $\\log{r}$ 的斜率来估计 $\\nu$。为了使此计算高效，我们通过对大量的、即 $P=8000$ 个不同的点对 $(\\mathbf{X}_i, \\mathbf{X}_j)$ 进行抽样来近似 $C(r)$，并计算成对距离小于或等于 $r$ 的比例。为避免时间上相邻点造成的伪相关，采用了 Theiler 窗 $w=m\\tau=3$，要求抽样的点对满足 $|i-j| > w$。用于线性拟合的标度区域是通过动态选择约 20 个半径来确定的，这些半径在采样的距离分布的第 5 和第 95 百分位数之间呈对数间隔。\n\n第三，我们构建一个基于代理数据的统计检验来检测动力学的变化。零假设 $H_0$ 是时间序列由一个平稳过程生成。如果 $H_0$ 为真，那么从序列的早期窗口估计的关联维数应与晚期窗口的关联维数在统计上是不可区分的。显著的差异 $\\Delta_{\\mathrm{obs}} = \\nu_{\\mathrm{late}} - \\nu_{\\mathrm{early}}$ 将表明潜在动力学发生了变化，这与分岔是一致的。为了评估显著性，我们使用振幅调整傅里叶变换 (AAFT) 方法为 $\\Delta$ 生成一个零分布。对于早期和晚期窗口，我们各生成 $S=20$ 个代理时间序列。AAFT 代理数据旨在保留原始数据段的精确振幅分布并近似其功率谱（以及自相关函数）。它们代表了与原始窗口具有相似线性特性的平稳数据。通过为每对代理数据计算斜率差异 $\\Delta_s$，我们构建了一个蒙特卡洛零分布。\n\n观测差异 $\\Delta_{\\mathrm{obs}}$ 的统计显著性随后通过一个双边 $p$ 值来量化，计算公式为：\n$$\np = \\frac{1 + \\#\\{s : |\\Delta_s| \\ge |\\Delta_{\\mathrm{obs}}|\\}}{S+1}\n$$\n如果这个 $p$ 值小于指定的显著性水平 $\\alpha=0.05$，我们就拒绝平稳性零假设，并断定存在类似分岔变化的证据。\n\n整个过程封装在一个 Python 程序中。该程序首先为三个不同的测试用例生成时间序列：(1) 一个平稳的混沌逻辑斯蒂映射，(2) 一个带有漂移参数的非平稳逻辑斯蒂映射，以及 (3) 一个平稳的线性随机 AR(1) 过程。每个序列被分为早期和晚期两半。在分析之前，每个窗口都被标准化为零均值和单位方差。然后对每种情况执行假设检验，并记录布尔结果（True 表示有显著变化，False 表示没有）。所有涉及随机性的计算（数据生成、点对抽样、代理数据创建）都由一个固定的单一随机种子控制，以确保完全的可复现性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Main function to execute the bifurcation detection analysis for all test cases.\n    \"\"\"\n    # Set a fixed random seed for reproducibility of the entire script.\n    SEED = 42\n    rng = np.random.default_rng(SEED)\n\n    # --- Global parameters from the problem statement ---\n    M_DIM = 3\n    TAU = 1\n    THEILER_W = M_DIM * TAU\n    N_SURROGATES = 20\n    N_PAIRS = 8000\n    ALPHA = 0.05\n\n    # --- Time series generation functions ---\n\n    def generate_logistic(r_param, N, x0, discard, rng):\n        \"\"\"Generates a time series from the logistic map.\"\"\"\n        x = np.zeros(N)\n        x[0] = x0\n        if np.isscalar(r_param):\n            for i in range(N - 1):\n                x[i + 1] = r_param * x[i] * (1 - x[i])\n        else:  # Ramped parameter\n            for i in range(N - 1):\n                x[i + 1] = r_param[i] * x[i] * (1 - x[i])\n        return x[discard:]\n\n    def generate_ar1(phi, sigma, N, x0, discard, rng):\n        \"\"\"Generates a time series from an AR(1) process.\"\"\"\n        x = np.zeros(N)\n        x[0] = x0\n        noise = rng.normal(0, sigma, N)\n        for i in range(N - 1):\n            x[i + 1] = phi * x[i] + noise[i]\n        return x[discard:]\n\n    # --- Core analysis functions ---\n\n    def embed(series, m, tau):\n        \"\"\"Performs time-delay embedding on a series.\"\"\"\n        n_points = len(series) - (m - 1) * tau\n        # This check is added for robustness with short series\n        if n_points = 0:\n            return np.empty((0, m))\n        embedded = np.lib.stride_tricks.as_strided(\n            series,\n            shape=(n_points, m),\n            strides=(series.strides[0], series.strides[0] * tau)\n        )\n        return embedded\n\n    def generate_aaft_surrogate(series, rng):\n        \"\"\"Generates one Amplitude-Adjusted Fourier Transform (AAFT) surrogate.\"\"\"\n        n = len(series)\n        \n        # FFT of the original series to get its phases\n        fft_original = np.fft.rfft(series)\n        phases_original = np.angle(fft_original)\n        \n        # Create a shuffled copy of the data, FFT it, and get magnitudes\n        shuffled_series = rng.permutation(series)\n        fft_shuffled = np.fft.rfft(shuffled_series)\n        magnitudes_shuffled = np.abs(fft_shuffled)\n        \n        # Create a new spectrum with original phases and shuffled magnitudes\n        new_fft_spec = magnitudes_shuffled * np.exp(1j * phases_original)\n        \n        # Inverse FFT to get a series with modified amplitude distribution\n        y_prime = np.fft.irfft(new_fft_spec, n=n)\n        \n        # Restore original amplitude distribution by rank-ordering\n        sorted_series = np.sort(series)\n        ranks_y_prime = np.argsort(np.argsort(y_prime))\n        \n        surrogate = sorted_series[ranks_y_prime]\n        return surrogate\n\n    def compute_slope(series, m, tau, w, n_pairs, rng):\n        \"\"\"Computes the correlation dimension slope for a given series.\"\"\"\n        embedded_series = embed(series, m, tau)\n        m_points = len(embedded_series)\n        \n        if m_points = w + 2:\n            return 0.0\n\n        # Sample pairs of points respecting the Theiler window\n        # Oversample to efficiently find n_pairs valid pairs\n        max_attempts = n_pairs * 5\n        cand_i = rng.integers(0, m_points, size=max_attempts)\n        cand_j = rng.integers(0, m_points, size=max_attempts)\n        \n        valid_mask = (cand_i != cand_j)  (np.abs(cand_i - cand_j) > w)\n        \n        pairs_i = cand_i[valid_mask][:n_pairs]\n        pairs_j = cand_j[valid_mask][:n_pairs]\n        \n        if len(pairs_i)  n_pairs: # Fallback if not enough pairs were found\n            return 0.0\n\n        # Compute distances and determine scaling range for radii\n        distances = np.linalg.norm(embedded_series[pairs_i] - embedded_series[pairs_j], axis=1)\n        \n        # Filter out zero distances to avoid issues with quantiles/log\n        pos_distances = distances[distances > 1e-12]\n        if len(pos_distances)  2:\n            return 0.0\n        \n        q_low, q_high = np.quantile(pos_distances, [0.05, 0.95])\n        \n        if q_high = q_low:\n             return 0.0\n        \n        radii = np.geomspace(q_low, q_high, num=20)\n        \n        # Approximate correlation sum C(r)\n        c_r = np.array([np.sum(distances = r) for r in radii]) / n_pairs\n        \n        # Perform linear regression on log-log plot to find the slope\n        valid_mask = (c_r > 1e-9)  (c_r  1.0)\n        log_radii = np.log(radii[valid_mask])\n        log_c_r = np.log(c_r[valid_mask])\n        \n        if len(log_radii)  2:\n            return 0.0 # Cannot perform regression\n        \n        slope, _, _, _, _ = linregress(log_radii, log_c_r)\n        \n        return slope if np.isfinite(slope) else 0.0\n\n    def run_test_case(series_generator, gen_params, m, tau, w, s_count, p_count, alpha_level, rng_instance):\n        \"\"\"Runs the entire hypothesis test for a single case.\"\"\"\n        ts_full = series_generator(**gen_params, rng=rng_instance)\n        \n        # Split into early and late windows\n        midpoint = len(ts_full) // 2\n        ts_early = ts_full[:midpoint]\n        ts_late = ts_full[midpoint:]\n\n        # Standardize each window\n        ts_early_std = (ts_early - np.mean(ts_early)) / np.std(ts_early)\n        ts_late_std = (ts_late - np.mean(ts_late)) / np.std(ts_late)\n        \n        # Compute observed difference in slopes\n        slope_early_obs = compute_slope(ts_early_std, m, tau, w, p_count, rng_instance)\n        slope_late_obs = compute_slope(ts_late_std, m, tau, w, p_count, rng_instance)\n        delta_obs = slope_late_obs - slope_early_obs\n\n        # Generate null distribution from surrogates\n        delta_surrogates = []\n        for _ in range(s_count):\n            surr_early = generate_aaft_surrogate(ts_early, rng_instance)\n            surr_late = generate_aaft_surrogate(ts_late, rng_instance)\n            \n            surr_early_std = (surr_early - np.mean(surr_early)) / np.std(surr_early)\n            surr_late_std = (surr_late - np.mean(surr_late)) / np.std(surr_late)\n            \n            slope_early_surr = compute_slope(surr_early_std, m, tau, w, p_count, rng_instance)\n            slope_late_surr = compute_slope(surr_late_std, m, tau, w, p_count, rng_instance)\n            \n            delta_surrogates.append(slope_late_surr - slope_early_surr)\n        \n        delta_surrogates = np.array(delta_surrogates)\n        \n        # Compute Monte Carlo p-value and make a decision\n        num_exceed = np.sum(np.abs(delta_surrogates) >= np.abs(delta_obs))\n        p_value = (1 + num_exceed) / (s_count + 1)\n        \n        return p_value  alpha_level\n\n    # --- Define and run test cases ---\n    \n    test_cases = [\n        # Case 1: Stationary Logistic Map (no bifurcation expected)\n        {\n            'generator': generate_logistic,\n            'params': {'r_param': 3.70, 'N': 4096, 'x0': 0.2, 'discard': 512}\n        },\n        # Case 2: Non-stationary Logistic Map (bifurcation expected)\n        {\n            'generator': generate_logistic,\n            'params': {'r_param': np.linspace(3.20, 3.70, 4096), 'N': 4096, 'x0': 0.2, 'discard': 256}\n        },\n        # Case 3: Stationary AR(1) Process (no bifurcation expected)\n        {\n            'generator': generate_ar1,\n            'params': {'phi': 0.8, 'sigma': 0.5, 'N': 4096, 'x0': 0.0, 'discard': 512}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_test_case(\n            series_generator=case['generator'],\n            gen_params=case['params'],\n            m=M_DIM,\n            tau=TAU,\n            w=THEILER_W,\n            s_count=N_SURROGATES,\n            p_count=N_PAIRS,\n            alpha_level=ALPHA,\n            rng_instance=rng\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2376563"}]}