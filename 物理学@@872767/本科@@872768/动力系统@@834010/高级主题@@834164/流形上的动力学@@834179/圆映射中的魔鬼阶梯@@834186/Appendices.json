{"hands_on_practices": [{"introduction": "这个实践练习旨在揭示圆映射的一个基本对称性。参数 $\\Omega$ 代表外部驱动频率，理解当 $\\Omega$ 增加一个整数时，旋转数 $\\rho$ 如何变化，是把握魔鬼阶梯整体结构的关键。通过这个练习 [@problem_id:1672670]，你将明白为什么所有复杂的动力学行为都可以集中在 $\\Omega$ 的一个单位区间内进行研究，这极大地简化了我们的分析。", "problem": "标准圆映射是非线性动力学研究中的一个基本模型，常用于描述周期性受迫振子的锁相等现象。系统在离散时间步 $n=0, 1, 2, \\dots$ 的状态由一个角度 $\\theta_n \\in [0, 1)$ 描述。该角度的演化由以下迭代映射给出：\n$$ \\theta_{n+1} = \\left( \\theta_n + \\Omega - \\frac{K}{2\\pi} \\sin(2\\pi \\theta_n) \\right) \\pmod 1 $$\n其中，$\\Omega$ 是与振子固有频率相关的参数，而 $K \\ge 0$ 是与周期性驱动力的非线性耦合强度。\n\n为分析其长期行为，我们引入该映射的一个“提升”(lift)，即实线上的一个变量 $X_n$，它不受取模运算的约束。该提升的演化遵循：\n$$ X_{n+1} = X_n + \\Omega - \\frac{K}{2\\pi} \\sin(2\\pi X_n) $$\n角度 $\\theta_n$ 可通过 $\\theta_n = X_n \\pmod 1$ 恢复。平均旋转速率由旋转数 $\\rho$ 捕捉，其定义为极限：\n$$ \\rho = \\lim_{n \\to \\infty} \\frac{X_n}{n} $$\n当此极限存在时，它与初始条件 $X_0$ 无关。\n\n考虑该系统的一个具体实例，其中参数设置为 $\\Omega = 5$ 和 $K = 0.8$。计算该系统的旋转数 $\\rho$ 的数值。", "solution": "我们考虑标准圆映射的提升，\n$$\nf_{\\Omega,K}(x) = x + \\Omega - \\frac{K}{2\\pi}\\sin(2\\pi x),\n$$\n使得 $X_{n+1} = f_{\\Omega,K}(X_n)$ 且旋转数为 $\\rho(\\Omega,K) = \\lim_{n\\to\\infty} \\frac{X_n}{n}$（当极限存在时）。对于 $K  1$ 的情况，该提升的导数为\n$$\nf_{\\Omega,K}'(x) = 1 - K \\cos(2\\pi x) \\ge 1 - K  0,\n$$\n因此 $f_{\\Omega,K}$ 诱导了一个保向圆微分同胚，且旋转数存在并独立于 $X_0$（Poincaré 旋转数）。\n\n关于 $\\Omega$ 的整数平移的关键可加性：对任意整数 $m$，定义 $f_{\\Omega+m,K}(x) = x + \\Omega + m - \\frac{K}{2\\pi}\\sin(2\\pi x)$。设 $X_n^{(\\Omega)}$ 和 $X_n^{(\\Omega+m)}$ 分别是在 $f_{\\Omega,K}$ 和 $f_{\\Omega+m,K}$ 下的轨道，且具有相同的初始条件 $X_0^{(\\Omega)} = X_0^{(\\Omega+m)}$。定义 $Y_n = X_n^{(\\Omega)} + m n$。然后利用周期性 $\\sin(2\\pi(Y_n)) = \\sin(2\\pi X_n^{(\\Omega)} + 2\\pi m n) = \\sin(2\\pi X_n^{(\\Omega)})$，我们计算\n$$\nY_{n+1} = X_{n+1}^{(\\Omega)} + m(n+1) = \\left(X_n^{(\\Omega)} + \\Omega - \\frac{K}{2\\pi}\\sin(2\\pi X_n^{(\\Omega)})\\right) + m + m n\n= Y_n + \\Omega + m - \\frac{K}{2\\pi}\\sin(2\\pi Y_n).\n$$\n因此 $Y_n$ 满足与 $X_n^{(\\Omega+m)}$ 相同的递归关系和初始条件，故 $X_n^{(\\Omega+m)} = Y_n = X_n^{(\\Omega)} + m n$。两边同除以 $n$ 并令 $n \\to \\infty$ 得\n$$\n\\rho(\\Omega + m, K) = \\rho(\\Omega, K) + m.\n$$\n\n因此，对于 $\\Omega = 5$，\n$$\n\\rho(5, K) = \\rho(0, K) + 5.\n$$\n\n我们现在计算当 $K=0.8$ 时 $\\rho(0, K)$ 的值。当 $\\Omega = 0$ 时，映射为\n$$\nf_{0,K}(x) = x - \\frac{K}{2\\pi}\\sin(2\\pi x).\n$$\n不动点满足 $f_{0,K}(x^{\\ast}) = x^{\\ast}$，即\n$$\n\\sin(2\\pi x^{\\ast}) = 0 \\quad \\Longrightarrow \\quad x^{\\ast} \\in \\frac{1}{2}\\mathbb{Z}.\n$$\n从任何这样的不动点出发，都会得到一个常数轨道 $X_n \\equiv x^{\\ast}$，因此\n$$\n\\lim_{n\\to\\infty} \\frac{X_n}{n} = 0.\n$$\n由于当 $K  1$ 时旋转数存在且与初始条件无关，因此可以得出\n$$\n\\rho(0, 0.8) = 0.\n$$\n\n综合以上结果，我们得到\n$$\n\\rho(5, 0.8) = \\rho(0, 0.8) + 5 = 5.\n$$", "answer": "$$\\boxed{5}$$", "id": "1672670"}, {"introduction": "魔鬼阶梯由无限多个平坦的台阶（即“阿诺德舌”）构成，但这些台阶的宽度并非均等。这个练习将使用一个简化的理论模型来探究这些台阶的尺寸规律 [@problem_id:1672710]。通过计算不同有理旋转数所对应的锁定区间的相对宽度，你将洞察阶梯的层级结构，并理解为何对应于更简单分数（分母更小）的台阶会更加显著。", "problem": "在动力系统的研究中，圆映射为驱动振子同步等现象提供了一个简单的模型。圆映射的一种标准形式由以下迭代给出：\n$$ \\theta_{n+1} = \\left( \\theta_n + \\Omega - \\frac{K}{2\\pi}\\sin(2\\pi\\theta_n) \\right) \\pmod 1 $$\n此处，$\\theta_n$ 代表系统在单位周长圆上第 $n$ 步的状态，$\\Omega$ 是一个驱动参数（“裸”环数），而 $K \\ge 0$ 是一个非线性常数。\n\n对于一组给定的参数，长期平均旋转率由环数 $\\rho = \\lim_{n \\to \\infty} \\frac{\\theta_n - \\theta_0}{n}$ 描述。当 $K  0$ 时，对于参数 $\\Omega$ 的某些范围，环数 $\\rho$ 会锁定在一个有理数值 $P/Q$ 上。这些 $\\Omega$ 的区域被称为锁模区间或阿诺德舌。对于固定的 $K0$，$\\rho$ 相对于 $\\Omega$ 的图像形成一个复杂的自相似结构，称为“魔鬼阶梯”，它由在每个有理数高度上的无限多个平坦台阶组成。\n\n考虑该系统的一个简化理论模型，其中非线性 $K$ 是一个小的正数。在此模型中，对应于环数 $\\rho = P/Q$ 的锁模区间的宽度 $\\Delta\\Omega(P/Q)$ 由以下公式给出：\n$$ \\Delta\\Omega(P/Q) = C \\frac{K^{Q-1}}{Q^4} $$\n其中 $P/Q$ 是一个最简分数，$C$ 是一个正常数，而 $K$ 是非线性参数。该公式适用于开区间 $\\rho \\in (0, 1)$ 内的环数，因此我们考虑 $0  P  Q$。\n\n使用此模型，计算所有对应于分母为 $Q=3$ 的环数的锁模台阶的总宽度与所有对应于分母为 $Q=2$ 的环数的锁模台阶的总宽度的比值。将您的答案表示为关于 $K$ 的符号表达式。", "solution": "我们已知环数为 $\\rho = P/Q$ 的锁模区间的宽度公式为\n$$\n\\Delta\\Omega\\left(\\frac{P}{Q}\\right) = C \\frac{K^{Q-1}}{Q^{4}},\n$$\n其中 $0  P  Q$ 且 $P/Q$ 为最简分数。我们需要计算所有对应于分母 $Q=3$ 的台阶的总宽度 $W_3$，以及所有对应于分母 $Q=2$ 的台阶的总宽度 $W_2$。\n\n1.  **计算 $W_2$（分母为2）**\n    对于 $Q=2$，我们需要找到满足 $0  P  2$ 的所有整数 $P$，使得 $P/2$ 是最简分数。唯一的可能值是 $P=1$。\n    因此，只有一个对应于 $Q=2$ 的环数，即 $\\rho = 1/2$。其锁模区间的宽度为：\n    $$\n    W_2 = \\Delta\\Omega\\left(\\frac{1}{2}\\right) = C \\frac{K^{2-1}}{2^4} = C \\frac{K}{16}.\n    $$\n\n2.  **计算 $W_3$（分母为3）**\n    对于 $Q=3$，我们需要找到满足 $0  P  3$ 的所有整数 $P$，使得 $P/3$ 是最简分数。可能的 $P$ 值为 $\\{1, 2\\}$。两个分数 $1/3$ 和 $2/3$ 都是最简的。\n    因此，有两个对应于 $Q=3$ 的环数。总宽度是它们各自宽度的总和：\n    $$\n    W_3 = \\Delta\\Omega\\left(\\frac{1}{3}\\right) + \\Delta\\Omega\\left(\\frac{2}{3}\\right) = C \\frac{K^{3-1}}{3^4} + C \\frac{K^{3-1}}{3^4} = 2 \\cdot C \\frac{K^2}{81}.\n    $$\n\n3.  **计算比值**\n    我们现在计算比值 $W_3 / W_2$：\n    $$\n    \\frac{W_3}{W_2} = \\frac{2 C K^2 / 81}{C K / 16} = \\frac{2 K^2}{81} \\cdot \\frac{16}{K} = \\frac{32 K^{2-1}}{81} = \\frac{32K}{81}.\n    $$\n因此，总宽度的比值为 $\\frac{32}{81}K$。", "answer": "$$\\boxed{\\frac{32}{81}K}$$", "id": "1672710"}, {"introduction": "最后的这个实践将所有概念融于一个计算任务中。你将通过编程来模拟圆映射，并亲手绘制出魔鬼阶梯，从而将抽象的映射方程与它著名的图形化表示联系起来 [@problem_id:2731669]。这个动手编程练习将加深你对旋转数计算、频率锁定以及动力学系统如何生成分形结构的理解。", "problem": "考虑由以下提升动力学定义的离散时间圆映射\n$$\nx_{k+1} \\;=\\; x_k \\;+\\; \\Omega \\;-\\; \\frac{K}{2\\pi}\\,\\sin(2\\pi x_k),\n$$\n其中 $x_k \\in \\mathbb{R}$，$K \\ge 0$ 是非线性参数，而 $\\Omega \\in [0,1]$ 是归一化驱动频率。圆上的物理相位为 $\\theta_k = x_k \\bmod 1$。旋转数由以下极限定义\n$$\n\\rho(K,\\Omega) \\;=\\; \\lim_{n\\to\\infty} \\frac{x_n - x_0}{n},\n$$\n在广泛条件下，该极限对本系统存在，并且在遍历区域内与 $x_0$ 无关。当 $K$ 固定时，作为 $\\Omega$ 的函数，映射 $\\Omega \\mapsto \\rho(K,\\Omega)$ 会形成一个非递减的阶梯函数，其平台区表示锁频（也称锁模），在这些平台区上，$\\rho$ 在长度非零的 $\\Omega$ 区间内取有理数值 $p/q$。这个分形单调函数通常被称为魔鬼阶梯。\n\n本任务要求您对几个固定的 $K$ 值，在一系列 $\\Omega$ 网格点上数值近似计算 $\\rho(K,\\Omega)$，检测其中 $\\rho$ 为小分母有理数的锁频平台区，并测量平台区的宽度。仅使用通过提升动力学和基本数值迭代得到的旋转数定义。\n\n使用以下数值程序和检测标准。\n\n- 对于指定网格上的每一对 $(K,\\Omega)$，从 $x_0=0$ 开始，通过迭代提升映射来近似计算旋转数：\n  1. 运行 $N_{\\mathrm{tr}}$ 步的暂态过程，以降低对初始条件的敏感性。\n  2. 然后运行 $N_{\\mathrm{avg}}$ 步并计算\n     $$\n     \\widehat{\\rho}(K,\\Omega) \\;=\\; \\frac{x_{N_{\\mathrm{tr}}+N_{\\mathrm{avg}}} - x_{N_{\\mathrm{tr}}}}{N_{\\mathrm{avg}}}.\n     $$\n- 为识别给定 $(K,\\Omega)$ 处的锁频现象，使用最佳有理逼近（例如，连分数法）将 $\\widehat{\\rho}$ 近似为一个满足 $1 \\le q \\le q_{\\max}$ 的有理数 $p/q$。如果满足以下条件，则宣布该点被锁定\n  $$\n  \\left| \\widehat{\\rho}(K,\\Omega) - \\frac{p}{q} \\right| \\le \\varepsilon_{\\mathrm{lock}},\n  $$\n  并记录标签 $(p,q)$。\n- 为在给定的 $K$ 值和一系列扫描的 $\\Omega$ 值中识别平台区，需找到 $\\Omega$ 的连续序列，其中所有点都锁定在相同的 $(p,q)$ 上。平台宽度是该序列中最大和最小 $\\Omega$ 值之差。如果一个平台区至少包含 $m_{\\min}$ 个网格点，并且宽度至少为 $w_{\\min}$，则接受该平台区。\n\n在本问题的所有计算中，请采用以下固定的数值设置：\n- 使用 $N_{\\mathrm{tr}} = 1500$，$N_{\\mathrm{avg}} = 3000$。\n- 使用 $\\Omega$ 在 $[0,1]$ 上的均匀网格，包含 $N_{\\Omega} = 401$ 个点（包括端点），即步长为 $1/400$。\n- 使用 $q_{\\max} = 8$，锁定容差 $\\varepsilon_{\\mathrm{lock}} = 5\\times 10^{-4}$，最小平台宽度 $w_{\\min} = 0.01$，以及最小平台点数 $m_{\\min} = 3$。\n- 所有运行均使用 $x_0 = 0$。\n\n测试套件。\n您必须评估以下四个测试用例，每个用例由 $(K,\\Omega_{\\min},\\Omega_{\\max},N_{\\Omega},q_{\\max},w_{\\min})$ 定义：\n1. $K = 0.0$, $\\Omega_{\\min} = 0.0$, $\\Omega_{\\max} = 1.0$, $N_{\\Omega} = 401$, $q_{\\max} = 8$, $w_{\\min} = 0.01$。\n2. $K = 0.5$, $\\Omega_{\\min} = 0.0$, $\\Omega_{\\max} = 1.0$, $N_{\\Omega} = 401$, $q_{\\max} = 8$, $w_{\\min} = 0.01$。\n3. $K = 1.0$, $\\Omega_{\\min} = 0.0$, $\\Omega_{\\max} = 1.0$, $N_{\\Omega} = 401$, $q_{\\max} = 8$, $w_{\\min} = 0.01$。\n4. $K = 1.2$, $\\Omega_{\\min} = 0.0$, $\\Omega_{\\max} = 1.0$, $N_{\\Omega} = 401$, $q_{\\max} = 8$, $w_{\\min} = 0.01$。\n\n对于每个测试用例，您的程序必须：\n- 计算给定 $K$ 值在 $\\Omega$ 网格上对应的已接受平台区列表。\n- 每个测试用例返回三个输出：\n  1. 已接受平台区的整数总数。\n  2. 一个布尔值，指示 $1:2$ 锁定平台区（即 $\\rho = 1/2$）是否存在于已接受的平台区中。\n  3. 最宽的已接受平台区的宽度，结果为实数，四舍五入到4位小数。\n\n最终输出格式。\n您的程序应生成单行输出，其中包含四个测试用例的结果，格式为一个由方括号括起来的、以逗号分隔的列表的列表。每个内部列表对应上述顺序中的一个测试用例，并且必须采用 $[\\text{计数},\\text{布尔值},\\text{宽度}]$ 的形式，例如：\n$[[3,True,0.1250],[\\dots],[\\dots],[\\dots]]$。\n本问题不涉及单位。根据映射的定义，正弦函数内的角度以弧度为单位。所有浮点输出在打印前必须按上述规定四舍五入到4位小数。", "solution": "该问题要求对标准圆映射进行数值研究，这是研究非线性动力系统和锁频现象的一个基本模型。其目标是，对于非线性参数 $K$ 的几个不同值，在一系列驱动频率 $\\Omega$ 组成的网格上近似计算旋转数 $\\rho(K,\\Omega)$，并识别和表征被称为阿诺德舌的锁频平台区。\n\n解决方案是通过直接实现问题陈述中指定的程序来构建的。该方法遵循基于第一性原理的层次化结构。\n\n分析的核心是旋转数，定义为 $\\rho = \\lim_{n\\to\\infty} (x_n - x_0)/n$。这个量度量了系统相位的平均渐近变化率。我们被要求通过迭代提升映射来计算其数值近似值 $\\widehat{\\rho}$：\n$$\nx_{k+1} = x_k + \\Omega - \\frac{K}{2\\pi}\\sin(2\\pi x_k)\n$$\n对每一对 $(K, \\Omega)$ 的计算都从 $x_0 = 0$ 开始。前 $N_{\\mathrm{tr}} = 1500$ 次迭代作为暂态阶段被舍弃，以确保系统已稳定到其吸引子上。随后的 $N_{\\mathrm{avg}} = 3000$ 次迭代用于计算平均频率：\n$$\n\\widehat{\\rho}(K,\\Omega) = \\frac{x_{N_{\\mathrm{tr}}+N_{\\mathrm{avg}}} - x_{N_{\\mathrm{tr}}}}{N_{\\mathrm{avg}}}\n$$\n对于每个指定的测试用例 $K$，此过程被系统地应用于区间 $[0,1]$ 内由 $N_{\\Omega} = 401$ 个 $\\Omega$ 值组成的均匀网格上的每个点。\n\n一旦计算出给定 $\\Omega$ 的 $\\widehat{\\rho}$，下一步是测试是否存在锁频。这是一个分类任务。如果一个点的数值计算旋转数足够接近一个简单有理数，则该点被视为锁定。这通过一个两步过程实现：\n1.  **最佳有理逼近**：对于每个 $\\widehat{\\rho}$，我们找到其最佳有理逼近 $p/q$，其中分母 $q$ 不超过最大值 $q_{\\max} = 8$。这可以通过算法使用连分数法来实现，该方法在标准库中有高效实现。\n2.  **锁定条件**：如果计算出的旋转数与其有理逼近之间的绝对差在指定容差范围内，则点 $(\\Omega, \\widehat{\\rho})$ 被分类为以有理数 $p/q$ 锁定：\n    $$\n    \\left| \\widehat{\\rho}(K,\\Omega) - \\frac{p}{q} \\right| \\le \\varepsilon_{\\mathrm{lock}}\n    $$\n    其中 $\\varepsilon_{\\mathrm{lock}} = 5 \\times 10^{-4}$。如果满足此条件，该状态被标记为对 $(p,q)$；否则，它被视为未锁定。\n\n在对给定 $K$ 的 $\\Omega$ 网格上所有点进行分类后，扫描生成的标签序列以识别平台区。平台区被定义为所有点都锁定到相同有理数 $(p,q)$ 的连续网格点子序列。\n\n每个识别出的潜在平台区随后都将通过验证标准进行筛选，以排除伪结果或不显著的结果。一个段落只有在同时满足以下两个条件时才被接受为有效平台区：\n- 它必须包含至少 $m_{\\min} = 3$ 个连续的网格点。\n- 该段落中 $\\Omega$ 值的跨度，即该段落的 $\\Omega_{\\max} - \\Omega_{\\min}$，必须至少为 $w_{\\min} = 0.01$。\n\n最后，对于每个 $K$ 值，分析已接受的平台区集合以提取所需的摘要指标：\n1.  已接受平台区的总数。\n2.  一个布尔标志，指示对应于 $1:2$ 锁频（$\\rho = 1/2$）的平台区是否存在于已接受的集合中。\n3.  找到的最宽平台区的宽度，四舍五入到四位小数。在没有已接受平台区的情况下，此宽度报告为 $0$。\n\n这整个计算过程被封装在一个程序中，该程序遍历四个指定的 $K$ 值，对每个值执行分析，并按要求将最终结果格式化为单行输出。情况 $K=0$ 作为基准，此时映射是线性的（$x_{k+1} = x_k + \\Omega$），因此 $\\rho=\\Omega$。在这种线性情况下，真正的平台区无法形成，并且指定的验证标准能如预期般正确地滤除由有理逼近过程产生的任何伪影。对于 $K0$ 的情况，非线性会引发真正的锁频现象，而该算法旨在检测并测量由此产生的平台区。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom fractions import Fraction\n\ndef solve():\n    \"\"\"\n    Solves the circle map problem by numerically approximating rotation numbers,\n    detecting frequency-locked plateaus, and reporting statistics for several\n    nonlinearity parameters K.\n    \"\"\"\n    # Define the fixed numerical settings from the problem statement.\n    N_TR = 1500\n    N_AVG = 3000\n    EPS_LOCK = 5e-4\n    M_MIN = 3\n    X0 = 0.0\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (K, Omega_min, Omega_max, N_Omega, q_max, w_min)\n        (0.0, 0.0, 1.0, 401, 8, 0.01),\n        (0.5, 0.0, 1.0, 401, 8, 0.01),\n        (1.0, 0.0, 1.0, 401, 8, 0.01),\n        (1.2, 0.0, 1.0, 401, 8, 0.01),\n    ]\n\n    all_case_results = []\n    for K, omega_min, omega_max, n_omega, q_max, w_min in test_cases:\n        # Create the grid of Omega values.\n        omega_grid = np.linspace(omega_min, omega_max, n_omega)\n        locked_states = []\n\n        # Pre-compute the K-dependent term for efficiency.\n        k_term = K / (2 * np.pi)\n\n        # Iterate over each Omega to compute rho_hat and determine its locked state.\n        for omega in omega_grid:\n            x = X0\n            \n            # 1. Iterate the map to compute rho_hat.\n            # Transient steps.\n            for _ in range(N_TR):\n                x = x + omega - k_term * np.sin(2 * np.pi * x)\n            \n            x_transient = x\n            \n            # Averaging steps.\n            for _ in range(N_AVG):\n                x = x + omega - k_term * np.sin(2 * np.pi * x)\n            \n            x_final = x\n            \n            rho_hat = (x_final - x_transient) / N_AVG\n            \n            # 2. Find best rational approximation p/q.\n            frac = Fraction(rho_hat).limit_denominator(q_max)\n            p, q = frac.numerator, frac.denominator\n            \n            # 3. Check for frequency locking.\n            if abs(rho_hat - p / q) = EPS_LOCK and q = 1:\n                locked_states.append((p, q))\n            else:\n                locked_states.append(None)\n        \n        # 4. Identify and validate plateaus from contiguous locked states.\n        accepted_plateaus = []\n        i = 0\n        while i  n_omega:\n            current_state = locked_states[i]\n            if current_state is None:\n                i += 1\n                continue\n            \n            # A potential plateau starts at index i.\n            start_index = i\n            j = i + 1\n            while j  n_omega and locked_states[j] == current_state:\n                j += 1\n            end_index = j - 1\n            \n            # Apply validation criteria for the identified segment.\n            num_points = end_index - start_index + 1\n            if num_points = M_MIN:\n                width = omega_grid[end_index] - omega_grid[start_index]\n                if width = w_min:\n                    p_val, q_val = current_state\n                    plateau_info = {'p': p_val, 'q': q_val, 'width': width}\n                    accepted_plateaus.append(plateau_info)\n            \n            i = j  # Continue search from the end of the current segment.\n        \n        # 5. Compute the required output metrics for the current test case.\n        count = len(accepted_plateaus)\n        has_1_2 = any(p['p'] == 1 and p['q'] == 2 for p in accepted_plateaus)\n        \n        max_width = 0.0\n        if accepted_plateaus:\n            max_width = max(p['width'] for p in accepted_plateaus)\n            \n        all_case_results.append([count, has_1_2, max_width])\n    \n    # Final print statement in the exact required format.\n    result_strings = []\n    for count, has_bool, width in all_case_results:\n        bool_str = 'True' if has_bool else 'False'\n        width_str = f\"{round(width, 4):.4f}\" # Round then format\n        result_strings.append(f\"[{count},{bool_str},{width_str}]\")\n        \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2731669"}]}