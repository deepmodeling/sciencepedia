{"hands_on_practices": [{"introduction": "平均场理论是处理多体相互作用问题的一种基本而强大的近似方法，其核心思想是用一个有效的平均场来代替单个粒子所感受到的来自其他粒子的复杂相互作用。通过求解自洽方程，我们可以对系统的宏观行为获得定性乃至半定量的理解。这项实践将指导你应用平均场近似，为铁磁性伊辛模型推导居里-韦斯定律，这是理解顺磁相磁化率行为的关键结果 [@problem_id:115532]。", "problem": "考虑一个晶体固体，可用一个由 $N$ 个排列在晶格上的磁矩组成的系统来对其建模。每个格点 $i$ 都有一个磁矩，其方向可以“向上” ($s_i = +1$) 或“向下” ($s_i = -1$)。最近邻格点之间的相互作用由 Ising 模型描述。在存在外部磁场 $B$ 的情况下，系统的总能量由哈密顿量 (Hamiltonian) 给出：\n$$\nH = -J \\sum_{\\langle i,j \\rangle} s_i s_j - \\mu B \\sum_i s_i\n$$\n其中 $J > 0$ 是铁磁交换耦合常数，$\\mu$ 是每个格点上磁矩的大小，求和 $\\sum_{\\langle i,j \\rangle}$ 遍历所有最近邻对。\n\n在平均场近似 (mean-field approximation) 中，这个复杂的多体问题被简化：我们考虑单个格点 $i$，并将其与邻居的相互作用替换为与一个平均场（或“均场”）的相互作用。这个有效场是由相邻格点的平均磁化强度产生的。单个格点 $s$ 的平均场哈密顿量可以写为：\n$$\nH_{\\text{MF}} = -s(\\mu B + zJm)\n$$\n这里，$z$ 是晶格的配位数（任何给定格点的最近邻数量），$m = \\langle s_j \\rangle$ 是每个格点的平均磁化强度，假设在整个晶格上是均匀的。$m$ 的值必须自洽地确定。\n\n在顺磁相 (paramagnetic phase) 中（该相存在于高温下），系统在没有外部磁场的情况下净磁化强度为零。一个小的外部磁场 $B$ 会感生一个小的磁化强度 $m$。\n\n推导在高温（顺磁）相中，每个格点的磁化率 $\\chi$ 的表达式。每个格点的磁化率定义为 $\\chi = \\mu \\left( \\frac{\\partial m}{\\partial B} \\right)_{B \\to 0}$。用温度 $T$、磁矩 $\\mu$、交换常数 $J$、配位数 $z$ 和 Boltzmann 常数 $k_B$ 来表示你的答案。", "solution": "我们从平均自旋的平均场方程开始\n$$m=\\langle s\\rangle=\\tanh\\bigl[\\beta(\\mu B+zJm)\\bigr],\\quad \\beta=\\frac1{k_B T}.$$  \n在高温、小 $B$ 极限下，$m$ 很小，我们展开 $\\tanh x\\simeq x$：\n$$m\\simeq\\beta(\\mu B+zJm).$$  \n整理以解出 $m$：\n$$m\\bigl(1-\\beta zJ\\bigr)=\\beta\\mu B\\quad\\Longrightarrow\\quad m=\\frac{\\beta\\mu}{1-\\beta zJ}\\,B\\,. $$  \n每个格点的磁化率为\n$$\\chi=\\mu\\frac{\\partial m}{\\partial B}\\Big|_{B\\to0}\n=\\mu\\frac{\\beta\\mu}{1-\\beta zJ}\n=\\frac{\\mu^2\\beta}{1-\\beta zJ}\\,. $$  \n代入 $\\beta=1/(k_BT)$：\n$$\\chi=\\frac{\\mu^2/(k_BT)}{1-\\frac{zJ}{k_BT}}\n=\\frac{\\mu^2}{k_BT-zJ}\\,. $$", "answer": "$$\\boxed{\\frac{\\mu^2}{k_B T - z J}}$$", "id": "115532"}, {"introduction": "虽然近似方法非常有用，但精确解能够为我们提供更深刻的物理洞见和重要的理论基准。二维伊辛模型正是这样一个可以通过精确方法求解的典范。这项实践将带你探索该模型中一个优美而深刻的概念——Kramers-Wannier对偶性，并利用自对偶点 (self-dual point) 的论证，精确地确定相变的临界点 [@problem_id:1177334]。", "problem": "方形晶格上的二维伊辛模型是统计力学中研究相变的基石模型。其配分函数由 $Z(K) = \\sum_{\\{\\sigma_i=\\pm 1\\}} \\exp(K \\sum_{\\langle i,j \\rangle} \\sigma_i \\sigma_j)$ 给出，其中 $\\sigma_i$ 是晶格格点上的自旋，求和 $\\langle i,j \\rangle$ 遍及所有最近邻对，而 $K = J/(k_B T)$ 是无量纲耦合常数。\n\n该模型的一个显著性质是 Kramers-Wannier 对偶性。这种对偶性将模型在高温（小 $K$）下的配分函数与在对偶晶格上的另一个伊辛模型在低温（大 $K^*$）下的配分函数联系起来。对于方形晶格，其对偶晶格也是方形晶格。\n\n对偶变换根据以下关系将耦合常数 $K$ 映射到对偶耦合 $K^*$：\n$$\n\\tanh(K) = e^{-2K^*}\n$$\n这个关系是通过比较原始模型的高温展开与对偶模型的低温展开而建立的。\n\n假设该模型只发生单一相变，此相变必定发生在自对偶点，在该点上模型被映射到其自身，即 $K=K^* = K_c$。\n\n**任务：**\n从给定的对偶关系 $\\tanh(K) = e^{-2K^*}$ 出发，首先证明它等价于更对称的形式 $\\sinh(2K)\\sinh(2K^*) = 1$。然后，利用这个关系，确定临界参数 $v_c = \\tanh(K_c)$ 的精确值。", "solution": "1. 从对偶关系出发\n$$\n\\tanh K \\;=\\; e^{-2K^*}\\,.\n$$\n取倒数可得\n$$\n\\coth K \\;=\\; e^{2K^*}\\,\\quad\\text{所以}\\quad\n\\frac{\\cosh K}{\\sinh K}=e^{2K^*}\\,.\n$$\n2. 对双曲恒等式 $\\cosh^2K-\\sinh^2K=1$ 进行平方，并利用 $\\cosh K=e^{2K^*}\\sinh K$，可得\n$$\n(e^{2K^*}\\sinh K)^2-\\sinh^2K=1\n\\quad\\Longrightarrow\\quad\n\\sinh^2K\\bigl(e^{4K^*}-1\\bigr)=1\n\\quad\\Longrightarrow\\quad\n\\sinh K=\\frac{1}{\\sqrt{e^{4K^*}-1}}.\n$$\n因此\n$$\n\\cosh K=\\frac{e^{2K^*}}{\\sqrt{e^{4K^*}-1}}.\n$$\n3. 计算\n$$\n\\sinh(2K)=2\\sinh K\\cosh K\n=\\frac{2e^{2K^*}}{e^{4K^*}-1}, \n\\qquad\n\\sinh(2K^*)=\\frac{e^{2K^*}-e^{-2K^*}}{2}.\n$$\n它们的乘积为\n$$\n\\sinh(2K)\\,\\sinh(2K^*)\n=\\frac{2e^{2K^*}}{e^{4K^*}-1}\\cdot\\frac{e^{2K^*}-e^{-2K^*}}{2}\n=\\frac{e^{4K^*}-1}{\\,e^{4K^*}-1\\,}=1,\n$$\n从而证得对称形式\n$$\n\\sinh(2K)\\,\\sinh(2K^*)=1.\n$$\n4. 在自对偶点 $K=K^*=K_c$，上式给出\n$$\n\\sinh^2(2K_c)=1\n\\quad\\Longrightarrow\\quad\n2K_c=\\operatorname{arsinh}(1)=\\ln(1+\\sqrt2)\n\\quad\\Longrightarrow\\quad\nK_c=\\tfrac12\\ln(1+\\sqrt2).\n$$\n因此\n$$\nv_c=\\tanh(K_c)\n=\\tanh\\!\\bigl(\\tfrac12\\ln(1+\\sqrt2)\\bigr)\n=\\frac{(1+\\sqrt2)-1}{(1+\\sqrt2)+1}\n=\\sqrt2-1.\n$$", "answer": "$$\\boxed{\\sqrt2-1}$$", "id": "1177334"}, {"introduction": "为了将理论模型与真实材料联系起来，我们通常需要考虑超出简单近邻假设的复杂相互作用，这些相互作用可以通过团簇展开 (cluster expansion) 来描述。这项动手编程实践将理论与现代计算物理方法相结合，指导你通过代码实现一个基于团簇展开的平均场分析。你将研究当逐渐包含更长程的相互作用“团簇”时，系统的基态稳定性和临界温度如何收敛，从而体验从第一性原理计算到宏观相变行为预测的完整流程 [@problem_id:2844973]。", "problem": "要求您实现并分析二维方格子上一种有序-无序相变的团簇展开的收敛性，通过系统地增加对团簇（有效对相互作用），并追踪基态的稳定性和临界温度。您的程序必须是一个完整、可运行的程序，并能产生指定的输出。目标是从第一性原理出发进行推导，从构型能量（用有效对相互作用表示）的定义和平均场线性稳定性判据开始。\n\n方格子上的二元合金通过位于格点 $\\mathbf{R} = (x,y)$ 上的类伊辛赝自旋 $s_{\\mathbf{R}} \\in \\{-1,+1\\}$ 进行建模，并采用周期性边界条件。构型哈密顿量为\n$$\n\\mathcal{H} = -\\frac{1}{2}\\sum_{\\mathbf{R}}\\sum_{\\boldsymbol{\\delta}\\neq \\mathbf{0}} J(\\boldsymbol{\\delta})\\, s_{\\mathbf{R}}\\, s_{\\mathbf{R}+\\boldsymbol{\\delta}},\n$$\n其中 $J(\\boldsymbol{\\delta})$ 是平移不变的有效对相互作用（对团簇的团簇展开系数），单位为电子伏特。每个格点的能量为\n$$\n\\varepsilon = \\frac{\\mathcal{H}}{N},\n$$\n其中 $N$ 是格点总数。\n\n平均场相变温度需从无序态在对相互作用下的线性稳定性获得。对于平移不变的对相互作用，相互作用矩阵可由布里渊区中以波矢 $\\mathbf{q}$ 标记的平面波对角化，其本征值由 $J(\\boldsymbol{\\delta})$ 的晶格傅里叶级数给出。当最大本征值首先导致无序态失稳时，平均场不稳定性条件设定了临界温度 $T_c$。您必须从第一性原理出发实现此判据，通过其晶格傅里叶级数在倒易空间中构建相互作用矩阵，并找出其最大本征值。使用玻尔兹曼常数 $k_{\\mathrm{B}} = 8.617333262145\\times 10^{-5}\\,\\mathrm{eV/K}$ 将 $T_c$ 表示为开尔文。\n\n您必须通过在一系列实空间截断半径 $R_c$ 处截断真实相互作用来分析收敛性，这定义了通过增加相互作用范围来系统性地增加团簇的过程。对于序列中的每个截断半径，您必须计算：\n- 在四个候选长程有序模式中，通过比较从截断后的哈密顿量计算出的每个格点的能量，确定固定浓度下的基态。候选模式如下：\n  - 铁磁性（索引 $0$）：对于所有格点，$s_{x,y} = +1$。\n  - 棋盘式（索引 $1$），有序化矢量 $(\\pi,\\pi)$：$s_{x,y} = (-1)^{x+y}$。\n  - x-条纹（索引 $2$），有序化矢量 $(\\pi,0)$：$s_{x,y} = (-1)^x$。\n  - y-条纹（索引 $3$），有序化矢量 $(0,\\pi)$：$s_{x,y} = (-1)^y$。\n- 根据截断后的相互作用，通过计算倒易空间中相互作用矩阵的最大本征值来计算平均场临界温度 $T_c$（单位：开尔文），如上所述。您必须使用一个 $L\\times L$ 实空间超胞的倒易矢量对布里渊区进行离散化，并在离散波矢上取最大值。使用 $L = 32$。将 $T_c$ 以开尔文表示，并四舍五入到一位小数。\n\n给定三个科学上合理的测试用例，它们定义了最大范围内的“真实”相互作用 $J(\\boldsymbol{\\delta})$，以及一组通用的截断半径。对于每个测试用例，您必须为每个截断半径构建截断后的相互作用，并返回基态索引和 $T_c$。截断半径列表为\n$$\nR_c \\in \\{1.0,\\;1.5,\\;2.0,\\;3.0,\\;4.0\\}。\n$$\n\n对于所有测试用例，将位移 $\\boldsymbol{\\delta}=(\\Delta x,\\Delta y)$ 限制为整数分量，其欧几里得范数 $r=\\sqrt{(\\Delta x)^2+(\\Delta y)^2}$ 满足 $0  r \\le 4.0$。\n\n**测试用例定义：**\n- **测试用例 A：** 相互作用强烈倾向于棋盘式反铁磁有序。\n  - $J(1,0)=-0.030$, $J(1,1)=0.004$, $J(2,0)=-0.002$。\n  - 对于所有其他对，适用长程行为：$J(\\Delta x, \\Delta y) = 0.001 \\times (-1)^{\\Delta x + \\Delta y} / r^3$。\n- **测试用例 B：** 相互作用竞争导致条纹有序。\n  - $J(1,0)=0.010$, $J(1,1)=-0.007$, $J(2,0)=-0.002$。\n  - 对于所有其他对，适用长程行为：$J(\\Delta x, \\Delta y) = 0.0008 \\times (-1)^{\\Delta x} / r^3$。\n- **测试用例 C：** 具有振荡衰减的相互作用。\n  - $J(1,0)=0.001$。\n  - 对于 $0  |\\Delta x| \\le 4, \\Delta y=0$ 的轴上对，加性项适用：在基础值上增加 $0.004 \\times (-1)^{\\Delta x} / (\\Delta x)^2$。\n  - 对于所有其他未指定的对，适用长程行为：$J(\\Delta x, \\Delta y) = 0.0005 \\times (-1)^{\\Delta x} / (1+r^2)$。\n\n**输出格式：**\n返回一个包含三个字符串的列表，每个字符串代表一个测试用例的结果。每个字符串的格式为 `[[gs_indices],[tc_values]]`，其中 `gs_indices` 是一个逗号分隔的基态索引列表，`tc_values` 是一个逗号分隔的临界温度列表（以开尔文为单位，四舍五入到一位小数）。", "solution": "所提出的问题在科学上是有效且定义明确的。它构成了合金中有序-无序相变平均场理论中的一个标准练习，这是计算材料物理学的一个基本课题。该模型是二维方格子上的一个广义伊辛模型，其构型能量由在对相互作用级别截断的团簇展开定义。所有参数、物理常数和计算步骤都已明确指定，没有歧义。该问题基于已建立的物理原理，可进行数学形式化，其解是唯一且可验证的。\n\n我们现在将开始推导所需量并概述计算算法。\n\n**1. 理论框架**\n\n构型哈密顿量为：\n$$\n\\mathcal{H} = -\\frac{1}{2}\\sum_{\\mathbf{R}}\\sum_{\\boldsymbol{\\delta}\\neq \\mathbf{0}} J(\\boldsymbol{\\delta})\\, s_{\\mathbf{R}}\\, s_{\\mathbf{R}+\\boldsymbol{\\delta}}\n$$\n其中 $s_{\\mathbf{R}} \\in \\{-1, +1\\}$ 是位于格点 $\\mathbf{R}$ 的赝自旋，$J(\\boldsymbol{\\delta})$ 是位移矢量 $\\boldsymbol{\\delta}$ 的有效对相互作用。对于总共 $N$ 个格点，每个格点的能量 $\\varepsilon = \\mathcal{H}/N$，在一个完全有序的周期性结构中，由于平移不变性而简化为：\n$$\n\\varepsilon = -\\frac{1}{2}\\sum_{\\boldsymbol{\\delta}\\neq \\mathbf{0}} J(\\boldsymbol{\\delta})\\, \\langle s_{\\mathbf{R}}s_{\\mathbf{R}+\\boldsymbol{\\delta}} \\rangle\n$$\n其中平均值 $\\langle \\dots \\rangle$ 在整个晶格上是恒定的。对于一个由单一有序化波矢 $\\mathbf{k}$ 表征的简单有序模式，使得 $s_{\\mathbf{R}} \\propto e^{i\\mathbf{k}\\cdot\\mathbf{R}}$，自旋的乘积为 $s_{\\mathbf{R}}s_{\\mathbf{R}+\\boldsymbol{\\delta}} \\propto e^{i\\mathbf{k}\\cdot\\mathbf{R}} e^{-i\\mathbf{k}\\cdot(\\mathbf{R}+\\boldsymbol{\\delta})} = e^{-i\\mathbf{k}\\cdot\\boldsymbol{\\delta}}$。通过适当的归一化，我们可以将这些模式与特定的余弦参数相关联。四个候选基态对应于在特定高对称性波矢处评估能量：\n- **铁磁性（FM，索引 $0$）**：$s_{\\mathbf{R}}=+1$。有序化矢量为 $\\mathbf{k}=(0,0)$。自旋乘积为 $s_{\\mathbf{R}}s_{\\mathbf{R}+\\boldsymbol{\\delta}} = 1$。能量为 $\\varepsilon_{\\text{FM}} = -\\frac{1}{2}\\sum_{\\boldsymbol{\\delta}} J(\\boldsymbol{\\delta})$。\n- **棋盘式（AFM，索引 $1$）**：$s_{x,y}=(-1)^{x+y}$。有序化矢量为 $\\mathbf{k}=(\\pi,\\pi)$。自旋乘积为 $s_{\\mathbf{R}}s_{\\mathbf{R}+\\boldsymbol{\\delta}} = (-1)^{\\Delta x+\\Delta y}$。能量为 $\\varepsilon_{\\text{AFM}} = -\\frac{1}{2}\\sum_{\\boldsymbol{\\delta}} J(\\boldsymbol{\\delta})(-1)^{\\Delta x+\\Delta y}$。\n- **x-条纹（索引 $2$）**：$s_{x,y}=(-1)^{x}$。有序化矢量为 $\\mathbf{k}=(\\pi,0)$。自旋乘积为 $s_{\\mathbf{R}}s_{\\mathbf{R}+\\boldsymbol{\\delta}} = (-1)^{\\Delta x}$。能量为 $\\varepsilon_{\\text{Stripe-x}} = -\\frac{1}{2}\\sum_{\\boldsymbol{\\delta}} J(\\boldsymbol{\\delta})(-1)^{\\Delta x}$。\n- **y-条纹（索引 $3$）**：$s_{x,y}=(-1)^{y}$。有序化矢量为 $\\mathbf{k}=(0,\\pi)$。自旋乘积为 $s_{\\mathbf{R}}s_{\\mathbf{R}+\\boldsymbol{\\delta}} = (-1)^{\\Delta y}$。能量为 $\\varepsilon_{\\text{Stripe-y}} = -\\frac{1}{2}\\sum_{\\boldsymbol{\\delta}} J(\\boldsymbol{\\delta})(-1)^{\\Delta y}$。\n\n这些候选态中的基态是能量最低的那个。\n\n平均场临界温度 $T_c$ 由高温无序相的稳定性决定。当相应的磁化率发散时，波矢为 $\\mathbf{q}$ 的浓度波变得不稳定。这发生在满足条件 $k_{\\mathrm{B}}T = \\tilde{J}(\\mathbf{q})$ 时，其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，$\\tilde{J}(\\mathbf{q})$ 是相互作用矩阵的晶格傅里叶变换：\n$$\n\\tilde{J}(\\mathbf{q}) = \\sum_{\\boldsymbol{\\delta}\\neq\\mathbf{0}} J(\\boldsymbol{\\delta}) e^{-i\\mathbf{q}\\cdot\\boldsymbol{\\delta}}\n$$\n考虑到强制的对称性 $J(\\boldsymbol{\\delta}) = J(-\\boldsymbol{\\delta})$，上式简化为一个余弦级数：\n$$\n\\tilde{J}(\\mathbf{q}) = \\sum_{\\boldsymbol{\\delta}\\neq\\mathbf{0}} J(\\boldsymbol{\\delta}) \\cos(\\mathbf{q}\\cdot\\boldsymbol{\\delta})\n$$\n物理相变温度 $T_c$ 对应于冷却时出现的第一个不稳定性，这由相互作用本征值谱的全局最大值决定。因此：\n$$\nk_{\\mathrm{B}}T_c = \\max_{\\mathbf{q}} \\left\\{ \\tilde{J}(\\mathbf{q}) \\right\\}\n$$\n最大化是在第一布里渊区中的所有波矢 $\\mathbf{q}$ 上进行的。\n\n**2. 计算步骤**\n\n解决该问题的算法如下：\n\n1.  **相互作用生成**：对于每个测试用例，我们首先构建完整的“真实”相互作用势 $J(\\boldsymbol{\\delta})$，作为一个将位移矢量 $\\boldsymbol{\\delta}=(\\Delta x, \\Delta y)$ 映射到其相互作用能量值的映射。这是通过迭代所有整数坐标 $(\\Delta x, \\Delta y)$ 来完成的，使其欧几里得范数 $r = \\sqrt{(\\Delta x)^2+(\\Delta y)^2}$ 满足 $0  r \\le 4.0$。顺序应用为每个测试用例指定的规则来确定 $J(\\boldsymbol{\\delta})$ 的值，同时尊重规则的优先级和处理加法或覆盖赋值。对称性 $J(\\boldsymbol{\\delta}) = J(-\\boldsymbol{\\delta})$ 在所提供的公式中是固有的。\n\n2.  **收敛性循环**：对于每个测试用例，我们遍历规定的实空间截断半径序列 $R_c \\in \\{1.0, 1.5, 2.0, 3.0, 4.0\\}$。\n    - **截断**：为每个 $R_c$ 创建一个截断后的相互作用映射 $J_{\\text{trunc}}$，方法是仅从真实势中包含那些满足 $r \\le R_c$ 的对 $(\\boldsymbol{\\delta}, J(\\boldsymbol{\\delta}))$。\n\n3.  **基态计算**：对于每个 $J_{\\text{trunc}}$：\n    - 我们使用上面推导的公式计算能量 $\\varepsilon_{\\text{FM}}$、$\\varepsilon_{\\text{AFM}}$、$\\varepsilon_{\\text{Stripe-x}}$ 和 $\\varepsilon_{\\text{Stripe-y}}$，对 $J_{\\text{trunc}}$ 中的所有对进行求和。\n    - 通过找到这四种能量中的最小值来确定基态。记录相应的索引（$0$、$1$、$2$ 或 $3$）。\n\n4.  **临界温度计算**：对于每个 $J_{\\text{trunc}}$：\n    - 波矢 $\\mathbf{q}$ 在一个对应于 $L \\times L$ 超胞（其中 $L=32$）的倒易晶格的网格上被离散化。允许的矢量为 $\\mathbf{q} = (\\frac{2\\pi n_x}{L}, \\frac{2\\pi n_y}{L})$，其中整数 $n_x, n_y \\in [0, L-1]$。\n    - 构建一个大小为 $L \\times L$ 的实空间网格 `J_grid`。对于 $J_{\\text{trunc}}$ 中的每一对 $(\\boldsymbol{\\delta}, J(\\boldsymbol{\\delta}))$，其中 $\\boldsymbol{\\delta}=(\\Delta x, \\Delta y)$，将值 $J(\\boldsymbol{\\delta})$ 放置在网格索引 `(dy % L, dx % L)` 处。原点处的相互作用 $J(\\mathbf{0})$ 为零。\n    - 对 `J_grid` 应用二维快速傅里叶变换 (FFT)，以同时计算所有离散化 $\\mathbf{q}$ 矢量的 $\\tilde{J}(\\mathbf{q})$。\n    - 所得FFT数组的最大实部给出 $J_{\\text{max}} = \\max_{\\mathbf{q}} \\tilde{J}(\\mathbf{q})$。\n    - 然后计算临界温度为 $T_c = J_{\\text{max}} / k_{\\mathrm{B}}$，其中 $k_{\\mathrm{B}} = 8.617333262145 \\times 10^{-5}\\,\\mathrm{eV/K}$。结果将转换为开尔文并四舍五入到一位小数。\n\n对所有截断半径和所有测试用例重复此过程，并将结果汇总成指定的输出格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the cluster expansion convergence problem for three test cases.\n    \"\"\"\n    k_B = 8.617333262145e-5  # Boltzmann constant in eV/K\n    L = 32\n    cutoffs = [1.0, 1.5, 2.0, 3.0, 4.0]\n    max_dist = 4.0\n\n    test_cases_params = [\n        # Test Case A\n        {\n            'base': {\n                (1, 0): -0.030, (0, 1): -0.030,\n                (1, 1): 0.004,\n                (2, 0): -0.002, (0, 2): -0.002,\n            },\n            'additive': {},\n            'tail': lambda dx, dy, r: 0.001 * ((-1)**(dx + dy)) / (r**3)\n        },\n        # Test Case B\n        {\n            'base': {\n                (1, 0): 0.010, (0, 1): 0.010,\n                (1, 1): -0.007,\n                (2, 0): -0.002, (0, 2): -0.002,\n            },\n            'additive': {},\n            'tail': lambda dx, dy, r: 0.0008 * ((-1)**dx) / (r**3)\n        },\n        # Test Case C\n        {\n            'base': {\n                (1, 0): 0.001, (0, 1): 0.001,\n            },\n            'additive': {\n                (dx, 0): (0.004 * ((-1)**dx)) / (abs(dx)**2) for dx in range(1, 5)\n            },\n            'tail': lambda dx, dy, r: 0.0005 * ((-1)**dx) / (1 + r**2)\n        }\n    ]\n\n    final_results = []\n\n    for params in test_cases_params:\n        # 1. Generate the full \"true\" interaction dictionary\n        j_true = {}\n        assigned_pairs = set()\n\n        # Apply base interactions\n        for (dx, dy), val in params['base'].items():\n            for sdx in [dx, -dx]:\n                for sdy in [dy, -dy]:\n                    if sdx != 0 or sdy != 0:\n                        j_true[(sdx, sdy)] = val\n                        assigned_pairs.add(tuple(sorted((abs(sdx), abs(sdy)))) if sdx*sdy != 0 else (abs(sdx),abs(sdy)))\n\n        # Apply additive interactions\n        for (dx, dy), add_val in params['additive'].items():\n            for sdx in [dx, -dx]:\n                if (sdx, dy) not in j_true:\n                    j_true[(sdx, dy)] = 0.0\n                j_true[(sdx, dy)] += add_val\n                assigned_pairs.add(tuple(sorted((abs(sdx),abs(dy)))) if sdx*dy != 0 else (abs(sdx),abs(dy)))\n\n\n        # Apply tail interactions\n        max_coord = int(np.ceil(max_dist))\n        for dx in range(-max_coord, max_coord + 1):\n            for dy in range(-max_coord, max_coord + 1):\n                if dx == 0 and dy == 0:\n                    continue\n                \n                r = np.sqrt(dx**2 + dy**2)\n                if r  max_dist:\n                    continue\n\n                canonical_pair = tuple(sorted((abs(dx),abs(dy)))) if dx*dy != 0 else (abs(dx),abs(dy))\n                if canonical_pair not in assigned_pairs:\n                    val = params['tail'](dx, dy, r)\n                    if (dx, dy) not in j_true:\n                       j_true[(dx, dy)] = val\n\n        # Ensure symmetry J(d) = J(-d) for all pairs\n        all_deltas = list(j_true.keys())\n        for dx, dy in all_deltas:\n            val = j_true.get((dx, dy))\n            if (-dx, -dy) not in j_true:\n                j_true[(-dx, -dy)] = val\n\n        gs_indices = []\n        tc_values = []\n\n        # 2. Loop through cutoffs\n        for r_c in cutoffs:\n            j_truncated = {\n                delta: val for delta, val in j_true.items() \n                if np.sqrt(delta[0]**2 + delta[1]**2) = r_c\n            }\n            if not j_truncated:\n                gs_indices.append(0) # Or handle as error\n                tc_values.append(0.0)\n                continue\n\n            # 3. Calculate ground state energy\n            energies = [0.0, 0.0, 0.0, 0.0]\n            for (dx, dy), val in j_truncated.items():\n                energies[0] += val  # FM\n                energies[1] += val * ((-1)**(dx + dy))  # Checkerboard\n                energies[2] += val * ((-1)**dx)  # Stripe-x\n                energies[3] += val * ((-1)**dy)  # Stripe-y\n            \n            energies = [-0.5 * e for e in energies]\n            gs_index = np.argmin(energies)\n            gs_indices.append(gs_index)\n\n            # 4. Calculate critical temperature\n            j_grid = np.zeros((L, L), dtype=float)\n            for (dx, dy), val in j_truncated.items():\n                j_grid[dy % L, dx % L] += val\n            \n            j_fourier = np.fft.fft2(j_grid)\n            j_max = np.max(np.real(j_fourier))\n            \n            tc = 0.0\n            if j_max  0:\n                tc = j_max / k_B\n            \n            tc_values.append(round(tc, 1))\n\n        final_results.append(f\"[[{','.join(map(str, gs_indices))}],[{','.join(map(str, tc_values))}]]\")\n\n    print(f\"[{','.join(final_results)}]\")\n\nsolve()\n```", "id": "2844973"}]}