{"hands_on_practices": [{"introduction": "布里渊区的构建是固体物理学中的一项基本功。本练习将引导你从第一性原理出发，为最简洁的三维晶格——简立方晶格——构建其第一布里渊区。通过这个实践，你将掌握从正空间格矢到倒格矢的转换，并运用 Wigner-Seitz 原胞的几何定义来确定布里渊区的边界和形状，从而牢固建立起这些核心概念之间的联系 [@problem_id:2974106]。", "problem": "考虑一个晶格常数为 $a$ 的简单立方正格子，其原胞基矢为 $\\mathbf{a}_{1}=a\\,\\hat{\\mathbf{x}}$，$\\mathbf{a}_{2}=a\\,\\hat{\\mathbf{y}}$ 和 $\\mathbf{a}_{3}=a\\,\\hat{\\mathbf{z}}$。倒易点阵由条件 $\\mathbf{a}_{i}\\cdot\\mathbf{b}_{j}=2\\pi\\,\\delta_{ij}$ 定义。第一布里渊区（Brillouin zone (BZ)）定义为倒易空间中的维格纳-赛兹原胞：即所有比其他任何倒格点更靠近原点的 $\\mathbf{k}$ 点的集合。\n\n从这些定义以及几何上解释为原点与倒格点 $\\mathbf{G}$ 之间中垂面（布拉格平面）的布拉格运动学条件出发，完成以下任务：\n\n$1.$ 确定倒格子原胞基矢 $\\mathbf{b}_{1}$、$\\mathbf{b}_{2}$ 和 $\\mathbf{b}_{3}$。\n\n$2.$ 仅使用布拉格平面的定义——即在倒易空间中，与原点和给定倒格点 $\\mathbf{G}$ 等距（在欧几里得度量下）的所有点 $\\mathbf{k}$ 的轨迹——推导垂直于 $\\mathbf{G}$ 且平分从原点到 $\\mathbf{G}$ 线段的布拉格平面的一般方程。\n\n$3.$ 将此方程应用于简单立方倒格子的最短非零倒格矢集合，并明确写出由这些矢量决定的所有不同布拉格平面的方程。\n\n$4.$ 证明包含原点的相应半空间的交集是一个凸多面体，并指明其几何形状。解释为什么这个交集恰好是如上定义的第一布里渊区。\n\n$5.$ 计算该第一布里渊区的 k 空间体积 $V_{\\mathrm{BZ}}$，用 $a$ 表示。\n\n最终答案仅需提供 $V_{\\mathrm{BZ}}$ 关于 $a$ 和 $\\pi$ 的解析表达式。最终的 k 空间体积以倒易立方米（$\\left(\\mathrm{m}^{-3}\\right)$）表示，但在最终的方框答案中省略单位。无需进行数值计算或四舍五入。", "solution": "该问题经评估有效。这是一个适定、有科学依据的固态物理学标准问题，旨在检验对倒易空间和布里渊区的基本知识。定义清晰，任务导向一个唯一、可验证的解。我们开始解题。\n\n解题过程分为五个部分，与问题陈述的结构保持一致。\n\n$1.$ 确定倒格子原胞基矢。\n\n倒格子原胞基矢 $\\mathbf{b}_{1}$、$\\mathbf{b}_{2}$ 和 $\\mathbf{b}_{3}$ 通过条件 $\\mathbf{a}_{i} \\cdot \\mathbf{b}_{j} = 2\\pi\\delta_{ij}$ 与正格子原胞基矢 $\\mathbf{a}_{1}$、$\\mathbf{a}_{2}$ 和 $\\mathbf{a}_{3}$ 相关联，其中 $\\delta_{ij}$ 是克罗内克符号。\n给定的简单立方晶格的原胞基矢为：\n$$ \\mathbf{a}_{1} = a\\,\\hat{\\mathbf{x}} $$\n$$ \\mathbf{a}_{2} = a\\,\\hat{\\mathbf{y}} $$\n$$ \\mathbf{a}_{3} = a\\,\\hat{\\mathbf{z}} $$\n我们来求 $\\mathbf{b}_{1}$。我们将其表示为一般形式 $\\mathbf{b}_{1} = b_{1x}\\hat{\\mathbf{x}} + b_{1y}\\hat{\\mathbf{y}} + b_{1z}\\hat{\\mathbf{z}}$。\n应用定义条件：\n对于 $j=1$：$\\mathbf{a}_{1} \\cdot \\mathbf{b}_{1} = (a\\,\\hat{\\mathbf{x}}) \\cdot (b_{1x}\\hat{\\mathbf{x}} + b_{1y}\\hat{\\mathbf{y}} + b_{1z}\\hat{\\mathbf{z}}) = a b_{1x} = 2\\pi$。这得到 $b_{1x} = \\frac{2\\pi}{a}$。\n对于 $j=2$：$\\mathbf{a}_{2} \\cdot \\mathbf{b}_{1} = (a\\,\\hat{\\mathbf{y}}) \\cdot (b_{1x}\\hat{\\mathbf{x}} + b_{1y}\\hat{\\mathbf{y}} + b_{1z}\\hat{\\mathbf{z}}) = a b_{1y} = 0$。这得到 $b_{1y} = 0$。\n对于 $j=3$：$\\mathbf{a}_{3} \\cdot \\mathbf{b}_{1} = (a\\,\\hat{\\mathbf{z}}) \\cdot (b_{1x}\\hat{\\mathbf{x}} + b_{1y}\\hat{\\mathbf{y}} + b_{1z}\\hat{\\mathbf{z}}) = a b_{1z} = 0$。这得到 $b_{1z} = 0$。\n因此，第一个倒格子原胞基矢为 $\\mathbf{b}_{1} = \\frac{2\\pi}{a}\\hat{\\mathbf{x}}$。\n\n由于正格子的立方对称性，其他倒格子原胞基矢可以通过对下标进行轮换置换或重复计算得到。\n对于 $\\mathbf{b}_{2}$：\n$\\mathbf{a}_{1} \\cdot \\mathbf{b}_{2} = 0 \\implies b_{2x} = 0$。\n$\\mathbf{a}_{2} \\cdot \\mathbf{b}_{2} = 2\\pi \\implies a b_{2y} = 2\\pi \\implies b_{2y} = \\frac{2\\pi}{a}$。\n$\\mathbf{a}_{3} \\cdot \\mathbf{b}_{2} = 0 \\implies b_{2z} = 0$。\n所以，$\\mathbf{b}_{2} = \\frac{2\\pi}{a}\\hat{\\mathbf{y}}$。\n\n对于 $\\mathbf{b}_{3}$：\n$\\mathbf{a}_{1} \\cdot \\mathbf{b}_{3} = 0 \\implies b_{3x} = 0$。\n$\\mathbf{a}_{2} \\cdot \\mathbf{b}_{3} = 0 \\implies b_{3y} = 0$。\n$\\mathbf{a}_{3} \\cdot \\mathbf{b}_{3} = 2\\pi \\implies a b_{3z} = 2\\pi \\implies b_{3z} = \\frac{2\\pi}{a}$。\n所以，$\\mathbf{b}_{3} = \\frac{2\\pi}{a}\\hat{\\mathbf{z}}$。\n\n倒易点阵也是一个简单立方晶格，晶格常数为 $\\frac{2\\pi}{a}$。\n\n$2.$ 推导布拉格平面的一般方程。\n\n布拉格平面定义为倒易空间中与原点（$O$）和特定倒格点 $\\mathbf{G}$ 等距的所有点 $\\mathbf{k}$ 的轨迹。设平面上一点的位置矢量为 $\\mathbf{k}$。\n从原点到 $\\mathbf{k}$ 的距离是 $|\\mathbf{k}|$。\n从 $\\mathbf{G}$ 到 $\\mathbf{k}$ 的距离是 $|\\mathbf{k} - \\mathbf{G}|$。\n条件为 $|\\mathbf{k}| = |\\mathbf{k} - \\mathbf{G}|$。\n为消除平方根，我们将两边平方：\n$$ |\\mathbf{k}|^2 = |\\mathbf{k} - \\mathbf{G}|^2 $$\n使用点积展开右侧， $|\\mathbf{v}|^2 = \\mathbf{v} \\cdot \\mathbf{v}$：\n$$ \\mathbf{k} \\cdot \\mathbf{k} = (\\mathbf{k} - \\mathbf{G}) \\cdot (\\mathbf{k} - \\mathbf{G}) $$\n$$ \\mathbf{k} \\cdot \\mathbf{k} = \\mathbf{k} \\cdot \\mathbf{k} - 2(\\mathbf{k} \\cdot \\mathbf{G}) + \\mathbf{G} \\cdot \\mathbf{G} $$\n令 $k^2 = \\mathbf{k} \\cdot \\mathbf{k}$ 且 $G^2 = \\mathbf{G} \\cdot \\mathbf{G}$。\n$$ k^2 = k^2 - 2(\\mathbf{k} \\cdot \\mathbf{G}) + G^2 $$\n两边减去 $k^2$ 得到：\n$$ 0 = -2(\\mathbf{k} \\cdot \\mathbf{G}) + G^2 $$\n整理后得到布拉格平面的一般方程：\n$$ 2(\\mathbf{k} \\cdot \\mathbf{G}) = G^2 $$\n该方程描述了一个垂直于矢量 $\\mathbf{G}$ 并穿过点 $\\frac{1}{2}\\mathbf{G}$ 的平面，从而平分了连接原点与 $\\mathbf{G}$ 的线段。\n\n$3.$ 最短非零倒格矢的布拉格平面方程。\n\n一个普遍的倒格矢形式为 $\\mathbf{G} = n_1\\mathbf{b}_1 + n_2\\mathbf{b}_2 + n_3\\mathbf{b}_3$，其中 $n_1, n_2, n_3$ 是整数。对于我们的简单立方倒格子，其形式为：\n$$ \\mathbf{G} = \\frac{2\\pi}{a}(n_1\\hat{\\mathbf{x}} + n_2\\hat{\\mathbf{y}} + n_3\\hat{\\mathbf{z}}) $$\n最短的非零矢量 $\\mathbf{G}$ 是那些模长最小的矢量，这对应于为非零整数三元组 $(n_1, n_2, n_3)$ 最小化 $n_1^2 + n_2^2 + n_3^2$。最小值为 $1$。这发生在以下六个矢量的情况下：\n$(\\pm 1, 0, 0) \\implies \\mathbf{G} = \\pm\\frac{2\\pi}{a}\\hat{\\mathbf{x}}$\n$(0, \\pm 1, 0) \\implies \\mathbf{G} = \\pm\\frac{2\\pi}{a}\\hat{\\mathbf{y}}$\n$(0, 0, \\pm 1) \\implies \\mathbf{G} = \\pm\\frac{2\\pi}{a}\\hat{\\mathbf{z}}$\n对于所有这些矢量，其模长的平方为 $G^2 = \\left(\\frac{2\\pi}{a}\\right)^2$。我们来求每个矢量对应的平面方程。设 $\\mathbf{k} = k_x\\hat{\\mathbf{x}} + k_y\\hat{\\mathbf{y}} + k_z\\hat{\\mathbf{z}}$。\n\n对于 $\\mathbf{G} = \\frac{2\\pi}{a}\\hat{\\mathbf{x}}$：\n$2(\\mathbf{k} \\cdot \\mathbf{G}) = G^2 \\implies 2\\left(k_x \\frac{2\\pi}{a}\\right) = \\left(\\frac{2\\pi}{a}\\right)^2 \\implies 2k_x = \\frac{2\\pi}{a} \\implies k_x = \\frac{\\pi}{a}$。\n\n对于 $\\mathbf{G} = -\\frac{2\\pi}{a}\\hat{\\mathbf{x}}$：\n$2(\\mathbf{k} \\cdot \\mathbf{G}) = G^2 \\implies 2\\left(-k_x \\frac{2\\pi}{a}\\right) = \\left(\\frac{2\\pi}{a}\\right)^2 \\implies -2k_x = \\frac{2\\pi}{a} \\implies k_x = -\\frac{\\pi}{a}$。\n\n根据对称性，对于 $\\hat{\\mathbf{y}}$ 和 $\\hat{\\mathbf{z}}$ 方向上的矢量，我们得到其余四个平面方程。由最短非零倒格矢决定的六个不同布拉格平面的完整集合是：\n$k_x = \\frac{\\pi}{a}$， $k_x = -\\frac{\\pi}{a}$\n$k_y = \\frac{\\pi}{a}$， $k_y = -\\frac{\\pi}{a}$\n$k_z = \\frac{\\pi}{a}$， $k_z = -\\frac{\\pi}{a}$\n\n$4.$ 几何形状及作为第一布里渊区的确定。\n\n第一布里渊区（BZ）定义为倒易点阵的维格纳-赛兹原胞，即所有比其他任何非零倒格点 $\\mathbf{G} \\neq 0$ 更靠近原点的点 $\\mathbf{k}$ 的集合：\n$$ |\\mathbf{k}| \\le |\\mathbf{k} - \\mathbf{G}| \\quad \\forall \\mathbf{G} \\neq 0 $$\n如第 2 部分所示，将此不等式平方并化简可得 $2(\\mathbf{k} \\cdot \\mathbf{G}) \\le G^2$。\n每个这样的不等式定义了一个包含原点的开半空间。第一布里渊区是所有这些半空间的交集，每个非零 $\\mathbf{G}$ 对应一个半空间：\n$$ \\mathrm{BZ} = \\bigcap_{\\mathbf{G} \\neq 0} \\{ \\mathbf{k} \\in \\mathbb{R}^3 \\mid 2(\\mathbf{k} \\cdot \\mathbf{G}) \\le G^2 \\} $$\n半空间是凸集。任意数量凸集的交集也是凸集。因此，第一布里渊区是一个凸多面体。\n\n该区域的边界由一组平面 $2(\\mathbf{k} \\cdot \\mathbf{G}) = G^2$ 构成，这些平面未被其他平面冗余覆盖。它们恰好是对应于最短倒格矢的布拉格平面。对于这些“内部”平面所界定区域内的任何点 $\\mathbf{k}$，对于任何对应于更大矢量 $\\mathbf{G'}$ 的“外部”平面，不等式 $2(\\mathbf{k} \\cdot \\mathbf{G'}) \\le G'^2$ 将自动满足。\n在我们的例子中，第 3 部分推导出的六个平面，$k_x = \\pm \\frac{\\pi}{a}$、$k_y = \\pm \\frac{\\pi}{a}$ 和 $k_z = \\pm \\frac{\\pi}{a}$ 构成了边界。这六个平面定义了一个以原点为中心、顶点位于 $(\\pm \\frac{\\pi}{a}, \\pm \\frac{\\pi}{a}, \\pm \\frac{\\pi}{a})$ 的立方体。它们所包围的区域是满足 $-\\frac{\\pi}{a} \\le k_x \\le \\frac{\\pi}{a}$、$-\\frac{\\pi}{a} \\le k_y \\le \\frac{\\pi}{a}$ 和 $-\\frac{\\pi}{a} \\le k_z \\le \\frac{\\pi}{a}$ 的点 $\\mathbf{k}$ 的集合。这个立方体就是简单立方晶格的第一布里渊区。\n\n$5.$ 第一布里渊区 k 空间体积的计算。\n\n第一布里渊区是 k 空间中的一个立方体。该立方体的边长 $L$ 是平行平面之间的距离，例如，$k_x = \\frac{\\pi}{a}$ 和 $k_x = -\\frac{\\pi}{a}$ 之间的距离。\n$$ L = \\frac{\\pi}{a} - \\left(-\\frac{\\pi}{a}\\right) = \\frac{2\\pi}{a} $$\n该立方体的体积 $V_{\\mathrm{BZ}}$ 为 $L^3$：\n$$ V_{\\mathrm{BZ}} = \\left(\\frac{2\\pi}{a}\\right)^3 = \\frac{8\\pi^3}{a^3} $$\n这个结果可以通过计算倒格子原胞的体积来验证，该体积必须等于第一布里渊区的体积。由 $\\mathbf{b}_1, \\mathbf{b}_2, \\mathbf{b}_3$ 张成的平行六面体的体积由标量三重积给出：\n$$ V_{\\mathrm{recip}} = |\\mathbf{b}_1 \\cdot (\\mathbf{b}_2 \\times \\mathbf{b}_3)| $$\n代入第 1 部分的矢量：\n$$ \\mathbf{b}_2 \\times \\mathbf{b}_3 = \\left(\\frac{2\\pi}{a}\\hat{\\mathbf{y}}\\right) \\times \\left(\\frac{2\\pi}{a}\\hat{\\mathbf{z}}\\right) = \\left(\\frac{2\\pi}{a}\\right)^2 (\\hat{\\mathbf{y}} \\times \\hat{\\mathbf{z}}) = \\left(\\frac{2\\pi}{a}\\right)^2 \\hat{\\mathbf{x}} $$\n$$ V_{\\mathrm{recip}} = \\left| \\left(\\frac{2\\pi}{a}\\hat{\\mathbf{x}}\\right) \\cdot \\left( \\left(\\frac{2\\pi}{a}\\right)^2 \\hat{\\mathbf{x}} \\right) \\right| = \\left(\\frac{2\\pi}{a}\\right)^3 = \\frac{8\\pi^3}{a^3} $$\n结果吻合，证实了第一布里渊区的体积。", "answer": "$$ \\boxed{\\frac{8\\pi^{3}}{a^{3}}} $$", "id": "2974106"}, {"introduction": "在理解了布里渊区的几何构造后，我们转向其物理内涵。本练习探讨了布里渊区边界为何在物理上如此重要，它直接导致了能带隙的形成。通过在近自由电子模型中运用微扰理论，你将亲手推导出晶体的周期性势垒恰好在布里渊区边界处打开一个能隙，这是理解半导体和绝缘体电子特性的关键一步 [@problem_id:2974077]。", "problem": "一个质量为 $m$ 的电子在一维空间中运动，受到一个晶格常数为 $a$ 的弱周期势 $V(x)$ 的作用，其中 $V(x)$ 可进行傅里叶展开 $V(x)=\\sum_{G} V_{G}\\exp(i G x)$，倒格矢为 $G=2\\pi n/a$（$n$ 为整数）。未微扰的哈密顿量为 $H_{0}=p^{2}/(2m)$，其本征态为 $\\exp(i k x)$，色散关系为 $E^{(0)}(k)=\\hbar^{2}k^{2}/(2m)$。仅使用不含时薛定谔方程、布洛赫定理以及在平面波基下应用的简并微扰理论，在近自由电子模型下，确定第一布里渊区边界 $k=\\pm \\pi/a$ 处的直接带隙。计算时只保留捕捉简并点主导分裂所需的最小平面波子空间。将最终的带隙表示为仅含单个傅里叶系数 $V_{2\\pi/a}$ 的闭合形式解析表达式。最终结果应为一个无单位、无数值近似的解析表达式。", "solution": "问题要求解由近自由电子模型描述的一维系统在第一布里渊区边界处的直接带隙。将按照题目要求，使用简并微扰理论推导求解。\n\n系统的总哈密顿量为 $H = H_0 + V(x)$，其中未微扰的哈密顿量为 $H_0 = \\frac{p^2}{2m} = -\\frac{\\hbar^2}{2m}\\frac{d^2}{dx^2}$，$V(x)$ 是一个晶格常数为 $a$ 的弱周期势。$H_0$ 的未微扰本征态是平面波 $\\psi_k(x) = \\frac{1}{\\sqrt{L}}\\exp(ikx)$，其中 $L$ 是系统的长度，其对应的能量为 $E^{(0)}(k) = \\frac{\\hbar^2 k^2}{2m}$。\n\n我们关心的是第一布里渊区边界处的电子态。对于晶格常数为 $a$ 的一维晶格，该边界出现在波矢 $k = \\pm \\frac{\\pi}{a}$ 处。我们考虑 $k_1 = \\frac{\\pi}{a}$ 处的态，其未微扰能量为 $E^{(0)}(k_1) = \\frac{\\hbar^2}{2m}(\\frac{\\pi}{a})^2$。\n\n根据布洛赫定理，周期势中的本征态可以表示为平面波的叠加，这些平面波的波矢之间相差一个倒格矢 $G_n = \\frac{2\\pi n}{a}$（$n$ 为整数）。近自由电子模型的一个关键思想是，势 $V(x)$ 会最强烈地混合那些未微扰能量简并或近简并的态。在布里渊区边界 $k_1 = \\frac{\\pi}{a}$ 处，我们寻找另一个与 $|k_1\\rangle$ 简并的平面波态 $|k_2\\rangle$。令 $k_2 = k_1 - G$，其中 $G$ 是某个非零倒格矢。最简单的选择是 $G = G_1 = \\frac{2\\pi}{a}$。这得到 $k_2 = \\frac{\\pi}{a} - \\frac{2\\pi}{a} = -\\frac{\\pi}{a}$。\n\n我们来验证简并性。波矢为 $k_2 = -\\frac{\\pi}{a}$ 的态的能量是 $E^{(0)}(k_2) = \\frac{\\hbar^2}{2m}(-\\frac{\\pi}{a})^2 = \\frac{\\hbar^2}{2m}(\\frac{\\pi}{a})^2$。因此，$E^{(0)}(k_1) = E^{(0)}(k_2)$，在没有势场的情况下，这两个态 $|k_1\\rangle = |\\frac{\\pi}{a}\\rangle$ 和 $|k_2\\rangle = |-\\frac{\\pi}{a}\\rangle$ 是简并的。\n\n我们应用简并微扰理论来确定微扰 $V(x)$ 如何消除这种简并。我们将分析限制在这两个简并态张成的二维子空间 $\\{|\\frac{\\pi}{a}\\rangle, |-\\frac{\\pi}{a}\\rangle\\}$ 中。我们必须在此基下构建哈密顿矩阵并将其对角化。矩阵元为 $H_{ij} = \\langle k_i | H_0 + V | k_j \\rangle$。由于这些是 $H_0$ 的本征态，这可以简化为 $H_{ij} = E^{(0)}(k_i)\\delta_{ij} + V_{ij}$，其中 $V_{ij} = \\langle k_i | V | k_j \\rangle$。\n\n令 $E_B \\equiv E^{(0)}(\\frac{\\pi}{a}) = E^{(0)}(-\\frac{\\pi}{a})$。哈密顿矩阵为：\n$$\n\\mathbf{H} =\n\\begin{pmatrix}\nE_B + V_{11} & V_{12} \\\\\nV_{21} & E_B + V_{22}\n\\end{pmatrix}\n$$\n势的矩阵元可以使用其傅里叶展开 $V(x) = \\sum_{G} V_G \\exp(iGx)$ 来计算。归一化的平面波态为 $\\psi_k(x) = \\frac{1}{\\sqrt{L}}\\exp(ikx)$。\n\n对角元为：\n$V_{11} = \\langle \\frac{\\pi}{a} | V | \\frac{\\pi}{a} \\rangle = \\frac{1}{L} \\int_0^L \\exp(-i\\frac{\\pi}{a}x) \\left( \\sum_G V_G \\exp(iGx) \\right) \\exp(i\\frac{\\pi}{a}x) dx = \\frac{1}{L} \\int_0^L \\sum_G V_G \\exp(iGx) dx$。\n该积分仅在 $G=0$ 时非零，得到 $V_{11} = V_0$。\n类似地，$V_{22} = \\langle -\\frac{\\pi}{a} | V | -\\frac{\\pi}{a} \\rangle = V_0$。$V_0$ 是平均势，它将所有能级进行统一的平移。\n\n非对角元为：\n$V_{12} = \\langle \\frac{\\pi}{a} | V | -\\frac{\\pi}{a} \\rangle = \\frac{1}{L} \\int_0^L \\exp(-i\\frac{\\pi}{a}x) \\left( \\sum_G V_G \\exp(iGx) \\right) \\exp(-i\\frac{\\pi}{a}x) dx = \\frac{1}{L} \\sum_G V_G \\int_0^L \\exp(i(G-\\frac{2\\pi}{a})x) dx$。\n该积分仅在指数为零时，即 $G = \\frac{2\\pi}{a}$ 时非零。因此，$V_{12} = V_{2\\pi/a}$。\n\n$V_{21} = \\langle -\\frac{\\pi}{a} | V | \\frac{\\pi}{a} \\rangle = \\frac{1}{L} \\int_0^L \\exp(i\\frac{\\pi}{a}x) \\left( \\sum_G V_G \\exp(iGx) \\right) \\exp(i\\frac{\\pi}{a}x) dx = \\frac{1}{L} \\sum_G V_G \\int_0^L \\exp(i(G+\\frac{2\\pi}{a})x) dx$。\n该积分仅在 $G = -\\frac{2\\pi}{a}$ 时非零。因此，$V_{21} = V_{-2\\pi/a}$。\n\n哈密顿算符必须是厄米算符，这意味着势能函数 $V(x)$ 必须是实值的，$V(x) = V(x)^*$。这个实值条件对其傅里叶系数施加了一个约束：$V_{-G} = V_G^*$。因此，$V_{21} = V_{-2\\pi/a} = V_{2\\pi/a}^*$。\n\n在基 $\\{|\\frac{\\pi}{a}\\rangle, |-\\frac{\\pi}{a}\\rangle\\}$ 下的哈密顿矩阵为：\n$$\n\\mathbf{H} =\n\\begin{pmatrix}\nE_B + V_0 & V_{2\\pi/a} \\\\\nV_{2\\pi/a}^* & E_B + V_0\n\\end{pmatrix}\n$$\n为求解新的能量本征值 $E$，我们求解久期方程 $\\det(\\mathbf{H} - E\\mathbf{I}) = 0$：\n$$\n\\det\n\\begin{pmatrix}\nE_B + V_0 - E & V_{2\\pi/a} \\\\\nV_{2\\pi/a}^* & E_B + V_0 - E\n\\end{pmatrix}\n= 0\n$$\n这得到特征方程：\n$(E_B + V_0 - E)^2 - V_{2\\pi/a} V_{2\\pi/a}^* = 0$\n$(E_B + V_0 - E)^2 - |V_{2\\pi/a}|^2 = 0$\n对两边开平方根，我们得到：\n$E_B + V_0 - E = \\pm |V_{2\\pi/a}|$\n在布里渊区边界处的两个能量本征值为：\n$E_{\\pm} = E_B + V_0 \\pm |V_{2\\pi/a}|$。\n\n势 $V(x)$ 消除了简并，将能级 $E_B$ 分裂成两个不同的能级 $E_+$ 和 $E_-$。这两个能级之间的能量差就是第一布里渊区边界处的直接带隙 $E_g$。\n$E_g = E_+ - E_- = (E_B + V_0 + |V_{2\\pi/a}|) - (E_B + V_0 - |V_{2\\pi/a}|)$\n$E_g = 2|V_{2\\pi/a}|$\n\n这个结果表示由周期势的第一个重要傅里叶分量所产生的能级分裂的大小，该分量连接了布里渊区边缘处的简并自由电子态。", "answer": "$$\n\\boxed{2|V_{2\\pi/a}|}\n$$", "id": "2974077"}, {"introduction": "最后一项实践将理论与现代计算方法联系起来，解决了在实际能带结构计算中效率的核心问题。本练习引入了不可约布里渊区的概念，要求你通过编程实现一个算法，利用晶格的点群对称性，将任意 $k$ 点映射到其在不可约楔形区内的等效点。掌握这一技能对于进行任何实际的材料电子结构计算都至关重要 [@problem_id:2804328]。", "problem": "实现一个程序，对于一个简立方Bravais晶格，使用点群操作将任意晶体波矢映射到不可约布里渊区楔形区域中的一个正则代表元，并根据每个波矢的星群大小计算其对称性权重。设定和约束如下。\n\n- 使用晶格常数 $a=1$ 的简立方实空间晶格。此时，原胞倒易点阵矢量在笛卡尔坐标轴方向上的大小为 $2\\pi$，因此所有波矢都以 $1/a$ 为单位表示。\n- 令第一布里渊区 (BZ) 为分量上由 $(-\\pi,\\pi]$ 定义的立方区域。将一个矢量 $\\mathbf{k}$ 折叠到BZ中，意味着对其各分量加上一个倒易点阵矢量 $2\\pi \\,\\mathbf{n}$（其中 $\\mathbf{n}\\in\\mathbb{Z}^3$），从而在 $(-\\pi,\\pi]$ 中获得一个唯一的代表元。\n- 使用的点群是立方体的完整八面体对称群 $O_h$，它可由所有 $3\\times 3$ 的正交整数矩阵实现，这些矩阵的每一行和每一列都只有一个非零元素，且非零元素为 $\\pm 1$。这样的带符号置换矩阵共有 $48$ 个，每个矩阵通过左乘作用于 $\\mathbf{k}$。如果存在一个群元素 $R\\in O_h$ 和一个倒易点阵矢量 $2\\pi\\,\\mathbf{n}$ 使得 $\\mathbf{k}'=R\\mathbf{k}+2\\pi\\,\\mathbf{n}$，则两个波矢 $\\mathbf{k}$ 和 $\\mathbf{k}'$ 是对称等价的。\n- 将不可约楔形区域 $\\mathcal{W}$ 定义为BZ中满足不等式 $k_x\\ge k_y\\ge k_z\\ge 0$（包括边界）的所有 $\\mathbf{k}$ 的集合。$\\mathbf{k}$ 的对称轨道（星群）的正则代表元是其星群中位于 $\\mathcal{W}$ 内的唯一元素。如果有多个像落在共享边界上，则使用三元组 $(k_x,k_y,k_z)$ 的字典序来选择最小的三元组。在测试不等式和边界等价性时，使用数值容差 $\\epsilon=10^{-9}$。\n- 对于给定的 $\\mathbf{k}$，定义其星群为 $\\mathcal{S}(\\mathbf{k})=\\{\\mathrm{fold}_{\\mathrm{BZ}}(R\\mathbf{k})\\,:\\,R\\in O_h\\}$，其中 $\\mathrm{fold}_{\\mathrm{BZ}}$ 表示分量上折叠到 $(-\\pi,\\pi]$ 区间。在容差 $\\epsilon$ 内将相等的点视为同一个点后，令 $m(\\mathbf{k})$ 为 $\\mathcal{S}(\\mathbf{k})$ 的基数。定义星群权重为 $w_{\\star}(\\mathbf{k})=1/m(\\mathbf{k})$。同时定义群归一化权重 $\\widetilde{w}(\\mathbf{k})=m(\\mathbf{k})/|O_h|$，其中 $|O_h|=48$。\n- 您的程序必须：\n  - 生成 $O_h$ 中的所有点群操作，形式为带符号的置换矩阵。\n  - 实现折叠到 $(-\\pi,\\pi]$ 区间的操作，约定任何在数值容差内等于 $-\\pi$ 的分量都映射到 $+\\pi$。\n  - 对于每个输入的 $\\mathbf{k}$，计算其完整的星群，确定 $m(\\mathbf{k})$，根据上述规则在 $\\mathcal{W}$ 中选择正则代表元 $\\mathbf{k}_{\\mathrm{rep}}$，并计算 $w_{\\star}(\\mathbf{k})$ 和 $\\widetilde{w}(\\mathbf{k})$。\n\n可依赖的基础理论：\n- 倒易点阵、第一布里渊区以及点群对称性作为保持晶格不变的正交映射的定义。\n- 等价关系 $\\mathbf{k}\\sim R\\mathbf{k}+2\\pi\\,\\mathbf{n}$，其中 $R$ 属于点群，$\\mathbf{n}$ 是整数矢量。\n- 有限群 $G$ 的轨道-稳定子关系：对于一个点的轨道 $\\mathcal{O}(\\mathbf{k})$ 及其小群 $G_{\\mathbf{k}}=\\{R\\in G\\,:\\,\\mathrm{fold}_{\\mathrm{BZ}}(R\\mathbf{k})=\\mathrm{fold}_{\\mathrm{BZ}}(\\mathbf{k})\\}$，有 $|\\mathcal{O}(\\mathbf{k})|=|G|/|G_{\\mathbf{k}}|$。\n\n输入测试集：\n- 使用以下五个输入的波矢 $\\mathbf{k}$，以 $1/a$ 为单位表示：\n  - 情况 A: $\\mathbf{k}_A=\\big(0.7\\pi,\\,0.2\\pi,\\,-0.4\\pi\\big)$。\n  - 情况 B: $\\mathbf{k}_B=\\big(\\frac{\\pi}{4},\\,\\frac{\\pi}{4},\\,\\frac{\\pi}{6}\\big)$。\n  - 情况 C: $\\mathbf{k}_C=\\big(0,\\,0,\\,0\\big)$。\n  - 情况 D: $\\mathbf{k}_D=\\big(\\pi,\\,0.1\\pi,\\,0\\big)$。\n  - 情况 E: $\\mathbf{k}_E=\\big(\\pi,\\,\\pi,\\,\\pi\\big)$。\n\n要求的输出和单位：\n- 对于每种情况，输出一个列表 $[k_{\\mathrm{rep},x},\\,k_{\\mathrm{rep},y},\\,k_{\\mathrm{rep},z},\\,m,\\,w_{\\star},\\,\\widetilde{w}]$，其中 $k_{\\mathrm{rep},x}$、$k_{\\mathrm{rep},y}$ 和 $k_{\\mathrm{rep},z}$ 是 $\\mathbf{k}_{\\mathrm{rep}}$ 在笛卡尔坐标系下的分量（以 $1/a$ 为单位），$m$ 是整数重数，$w_{\\star}$ 和 $\\widetilde{w}$ 是如上定义的浮点数。将所有浮点数输出四舍五入到 $10$ 位小数。\n- 您的程序应生成单行输出，其中包含 A, B, C, D, E 五种情况的结果，结果按顺序排列，以逗号分隔，并用方括号括起来，其中每个元素是上述描述的列表。例如，输出形状应为 $[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]$，不含任何额外文本。", "solution": "该构建过程源于倒易空间对称性和等价性的第一性原理。对于晶格常数 $a=1$ 的简立方晶格，原胞倒易矢量为 $\\mathbf{b}_1=2\\pi\\,\\hat{\\mathbf{x}}$、$\\mathbf{b}_2=2\\pi\\,\\hat{\\mathbf{y}}$ 和 $\\mathbf{b}_3=2\\pi\\,\\hat{\\mathbf{z}}$。第一布里渊区 (BZ)可以表示为分量上取 $(-\\pi,\\pi]$ 的超立方体。任何波矢 $\\mathbf{k}$ 都与 $\\mathbf{k}+2\\pi\\,\\mathbf{n}$（其中 $\\mathbf{n}\\in\\mathbb{Z}^3$）等价，因此向BZ的折叠操作定义为将每个分量模 $2\\pi$ 变换到 $(-\\pi,\\pi]$ 区间内。为确保表示唯一，任何在容差范围内等于 $-\\pi$ 的分量都会被映射到 $+\\pi$。\n\n立方体的点群 $O_h$ 通过正交变换 $R$ 作用于波矢，这些变换会置换坐标并翻转符号，同时保持长度不变，其矩阵元 $R_{ij}\\in\\{0,\\pm 1\\}$，且每行每列只有一个非零元素。这样的矩阵共有48个，它们都代表了倒易空間中立方晶格的对称操作，包括正常旋转和与反演复合的操作。如果两个波矢通过这样一个 $R$ 相关联（相差一个倒易点阵矢量 $2\\pi\\,\\mathbf{n}$），则它们是对称等价的。这定义了轨道或星群，\n$$\n\\mathcal{S}(\\mathbf{k})=\\left\\{\\,\\mathrm{fold}_{\\mathrm{BZ}}(R\\mathbf{k}) \\,:\\, R\\in O_h\\,\\right\\}.\n$$\n\n根据群论，对于作用于一个集合的有限群 $G$，通过轨道-稳定子定理可知，轨道的大小 $|\\mathcal{O}(\\mathbf{k})|$ 乘以稳定子（小群）的大小 $|G_{\\mathbf{k}}|$ 等于群的大小 $|G|$，\n$$\n\\left|\\mathcal{O}(\\mathbf{k})\\right|=\\frac{|G|}{|G_{\\mathbf{k}}|}.\n$$\n在我们的设定中，$G=O_h$ 且 $|G|=48$，轨道是星群 $\\mathcal{S}(\\mathbf{k})$，小群 $G_{\\mathbf{k}}$ 包含所有满足 $\\mathrm{fold}_{\\mathrm{BZ}}(R\\mathbf{k})=\\mathrm{fold}_{\\mathrm{BZ}}(\\mathbf{k})$ 的 $R\\in O_h$。\n\n不可约楔形区域 $\\mathcal{W}$ 被选为满足不等式 $k_x\\ge k_y\\ge k_z\\ge 0$ (包括边界) 的所有折叠后的 $\\mathbf{k}$ 的集合。因为 $O_h$ 包含了所有坐标的带符号置换，所以每个轨道都与 $\\mathcal{W}$ 相交。如果轨道在多个边界点与 $\\mathcal{W}$ 相交，则需要一种确定性的选择方法；对 $(k_x,k_y,k_z)$ 进行字典序排序提供了一种正则选择。我们使用数值容差 $\\epsilon=10^{-9}$ 来检验不等式 $k_x\\ge k_y-\\epsilon$、$k_y\\ge k_z-\\epsilon$ 和 $k_z\\ge -\\epsilon$。\n\n基于这些原理的算法步骤：\n- 通过枚举所有坐标轴的置换和所有符号组合来生成 $O_h$。对于坐标索引的每个置换 $\\pi$ 和每个符号三元组 $(s_1,s_2,s_3)\\in\\{\\pm 1\\}^3$，构造矩阵 $R$，其元素为 $R_{i,\\pi(i)}=s_i$，其余为零。这将产生 $6\\times 8=48$ 个不同的矩阵。\n- 实现分量上的折叠到 $(-\\pi,\\pi]$ 区间。对于每个标量分量 $x$，计算 $y=((x+\\pi) \\bmod 2\\pi)-\\pi$；如果 $y$ 在一个很小的容差范围内接近 $-\\pi$，则将其替换为 $+\\pi$。这保证了 $y\\in(-\\pi,\\pi]$。\n- 对于给定的 $\\mathbf{k}$，计算所有 $R\\in O_h$ 下的像 $\\mathrm{fold}_{\\mathrm{BZ}}(R\\mathbf{k})$。通过四舍五入到固定的小数位数来识别唯一的矢量（这在数值上实现了容差 $\\epsilon$），并计算不同圆整后三元组的数量。这个数量就是 $m(\\mathbf{k})$。\n- 在唯一的像中，选择那些满足楔形不等式（带容差 $\\epsilon$）的像。从这些像中，选择字典序最小的圆整后三元组作为 $\\mathbf{k}_{\\mathrm{rep}}$。楔形区域中至少存在一个这样的三元组，这是因为带符号置换能够按大小对坐标进行排序并在折叠后使其非负。如果数值舍入错误地排除了候选者，备用方案将是选择所有像中字典序最小的一个；然而，在使用所采纳的容差和带符号置换群的情况下，对于所述情况，楔形区域代表元在实践中是存在的。\n- 星群权重为 $w_{\\star}(\\mathbf{k})=1/m(\\mathbf{k})$。群归一化权重为 $\\widetilde{w}(\\mathbf{k})=m(\\mathbf{k})/48$，根据轨道-稳定子定理，这与 $\\widetilde{w}(\\mathbf{k})=1/|G_{\\mathbf{k}}|$ 一致。\n\n数值考量：\n- 使用 $\\epsilon=10^{-9}$ 进行不等式检验，并使用内部10位小数的舍入来识别唯一点和输出浮点数。这是一致的，因为所有输入坐标都是 $\\pi$ 的有理数倍，并且群作用保留了这种结构；小的浮点误差通过舍入得到控制。\n\n该程序实现了这些步骤，构造群、折疊点、计算星群和权重，在 $\\mathcal{W}$ 中选择代表元，并打印一个包含5个条目的单行列表，对应五个测试 $\\mathbf{k}$ 矢量，每个条目包含 $[k_{\\mathrm{rep},x},k_{\\mathrm{rep},y},k_{\\mathrm{rep},z},m,w_{\\star},\\widetilde{w}]$，以 $1/a$（$a=1$）为单位，并四舍五入到10位小数。", "answer": "```python\nimport numpy as np\nimport itertools\n\n# Execution environment: Python 3.12, numpy 1.23.5, scipy 1.11.4 (not used)\n\ndef generate_oh_group():\n    \"\"\"\n    Generate the full octahedral group Oh as all 3x3 signed permutation matrices.\n    Returns a list of numpy arrays (float type).\n    \"\"\"\n    mats = []\n    for perm in itertools.permutations([0, 1, 2]):\n        for signs in itertools.product([-1, 1], repeat=3):\n            M = np.zeros((3, 3), dtype=int)\n            for i, p in enumerate(perm):\n                M[i, p] = signs[i]\n            mats.append(M.astype(float))\n    # Deduplicate (though construction yields unique already)\n    unique = []\n    seen = set()\n    for M in mats:\n        key = tuple(M.flatten().tolist())\n        if key not in seen:\n            seen.add(key)\n            unique.append(M)\n    return unique  # Expect 48 matrices\n\ndef fold_to_bz(k, tol=1e-12):\n    \"\"\"\n    Fold vector k component-wise into (-pi, pi], mapping any -pi to +pi.\n    \"\"\"\n    L = 2.0 * np.pi\n    y = (k + np.pi) % L - np.pi\n    # Map components equal to -pi (within tol) to +pi to realize (-pi, pi]\n    y = np.where(np.isclose(y, -np.pi, atol=tol), np.pi, y)\n    return y\n\ndef in_wedge(k, eps=1e-9):\n    \"\"\"\n    Test if k lies in the irreducible wedge: kx >= ky >= kz >= 0 with tolerance eps.\n    \"\"\"\n    return (k[0] >= k[1] - eps) and (k[1] >= k[2] - eps) and (k[2] >= -eps)\n\ndef compute_star_and_rep(k, group, round_dec=10, eps=1e-9):\n    \"\"\"\n    For a given k and group (list of 3x3 matrices), compute:\n    - unique folded images (the star) with uniqueness via rounding to round_dec decimals\n    - multiplicity m = size of unique set\n    - representative in the irreducible wedge (lexicographically smallest among candidates)\n    Returns (k_rep, m, w_star, w_group_norm)\n    \"\"\"\n    # Generate all images under group and fold to BZ\n    images = []\n    for R in group:\n        k_img = fold_to_bz(R @ k)\n        images.append(k_img)\n    # Unique images via rounding\n    rounded_to_image = {}\n    for img in images:\n        key = tuple(np.round(img, round_dec))\n        rounded_to_image[key] = img  # last one kept; all approximately same\n    unique_keys = list(rounded_to_image.keys())\n    m = len(unique_keys)\n\n    # Candidates in the wedge\n    wedge_candidates = [key for key in unique_keys if in_wedge(np.array(key), eps=eps)]\n    if not wedge_candidates:\n        # Fallback: should not happen for Oh with defined wedge; pick lexicographically smallest overall\n        chosen_key = min(unique_keys)\n    else:\n        chosen_key = min(wedge_candidates)\n    # Use the rounded key as representative to ensure consistency with rounding\n    k_rep = np.array(chosen_key, dtype=float)\n\n    # Weights\n    w_star = 1.0 / float(m)\n    w_group_norm = float(m) / float(len(group))\n    return k_rep, m, w_star, w_group_norm\n\ndef solve():\n    # Define test cases (in units of 1/a with a=1)\n    test_cases = [\n        np.array([0.7*np.pi, 0.2*np.pi, -0.4*np.pi], dtype=float),              # Case A\n        np.array([0.25*np.pi, 0.25*np.pi, (1.0/6.0)*np.pi], dtype=float),       # Case B\n        np.array([0.0, 0.0, 0.0], dtype=float),                                 # Case C\n        np.array([np.pi, 0.1*np.pi, 0.0], dtype=float),                         # Case D\n        np.array([np.pi, np.pi, np.pi], dtype=float),                           # Case E\n    ]\n\n    # Generate Oh group\n    group = generate_oh_group()\n\n    results = []\n    for k in test_cases:\n        k_rep, m, w_star, w_group_norm = compute_star_and_rep(k, group, round_dec=10, eps=1e-9)\n        # Round outputs to 10 decimals as required\n        k_rep_rounded = np.round(k_rep, 10).tolist()\n        w_star_rounded = round(w_star, 10)\n        w_group_norm_rounded = round(w_group_norm, 10)\n        results.append([k_rep_rounded[0], k_rep_rounded[1], k_rep_rounded[2], int(m), w_star_rounded, w_group_norm_rounded])\n\n    # Print single-line output in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2804328"}]}