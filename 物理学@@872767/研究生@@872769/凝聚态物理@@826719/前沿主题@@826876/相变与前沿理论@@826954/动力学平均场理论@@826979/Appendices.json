{"hands_on_practices": [{"introduction": "掌握原子极限是深入理解和解决杂质问题的第一步。本练习旨在为一个完全孤立的原子（即杂化函数 $\\Delta(i\\omega_n)=0$）提供格林函数的一个精确解，这不仅是理论分析的基石，也为更复杂的计算提供了重要的基准 [@problem_id:2983234]。", "problem": "考虑在动力学平均场理论 (DMFT) 中出现的单点杂质问题，在原子极限下，杂化函数满足 $\\Delta(i\\omega_{n}) = 0$。该杂质由单轨道哈伯德原子描述，其哈密顿量为\n$$\nH_{\\text{imp}} = U\\, n_{\\uparrow} n_{\\downarrow} - \\mu \\left(n_{\\uparrow} + n_{\\downarrow}\\right),\n$$\n其中 $U$ 是在位相互作用，$\\mu$ 是化学势，$n_{\\sigma} = c^{\\dagger}_{\\sigma} c_{\\sigma}$ 是自旋为 $\\sigma \\in \\{\\uparrow,\\downarrow\\}$ 的粒子数算符。设温度为 $T$，逆温为 $\\beta = 1/(k_{B} T)$，并使用费米子松原频率 $i\\omega_{n}$，其中 $\\omega_{n} = (2n+1)\\pi/\\beta$。\n\n从巨正则配分函数和松原格林函数的基本定义出发，\n$$\nZ_{\\text{imp}} = \\mathrm{Tr}\\left[\\exp\\left(-\\beta H_{\\text{imp}}\\right)\\right], \\qquad G_{\\text{imp},\\sigma}(\\tau) = -\\left\\langle \\mathcal{T}_{\\tau}\\, c_{\\sigma}(\\tau)\\, c_{\\sigma}^{\\dagger}(0)\\right\\rangle,\n$$\n并利用 $G_{\\text{imp},\\sigma}(i\\omega_{n})$ 的 Lehmann 表示，计算杂质配分函数 $Z_{\\text{imp}}$，并获得顺磁情况下杂质格林函数 $G_{\\text{imp}}(i\\omega_{n})$ 的显式闭合表达式。请将 $G_{\\text{imp}}(i\\omega_{n})$ 的最终答案仅用 $U$、$\\mu$、$\\beta$ 和 $\\omega_{n}$ 表示。无需取整，也不需要单位。最终答案必须是单个解析表达式。", "solution": "问题是计算单轨道哈伯德原子在原子极限下的巨正则配分函数 $Z_{\\text{imp}}$ 和松原格林函数 $G_{\\text{imp}}(i\\omega_{n})$，即与热库没有杂化（$\\Delta(i\\omega_{n}) = 0$）。哈密顿量由 $H_{\\text{imp}} = U\\, n_{\\uparrow} n_{\\downarrow} - \\mu \\left(n_{\\uparrow} + n_{\\downarrow}\\right)$ 给出。\n\n首先，我们确定哈密顿量的希尔伯特空间和能谱。该单点可以处于以下四种状态之一：\n1.  空态，记为 $\\left|0\\right\\rangle$，没有电子 ($n_{\\uparrow}=0, n_{\\downarrow}=0$)。\n2.  自旋向上的单占据态，$\\left|\\uparrow\\right\\rangle = c_{\\uparrow}^{\\dagger}\\left|0\\right\\rangle$，有一个电子 ($n_{\\uparrow}=1, n_{\\downarrow}=0$)。\n3.  自旋向下的单占据态，$\\left|\\downarrow\\right\\rangle = c_{\\downarrow}^{\\dagger}\\left|0\\right\\rangle$，有一个电子 ($n_{\\uparrow}=0, n_{\\downarrow}=1$)。\n4.  双占据态，$\\left|\\uparrow\\downarrow\\right\\rangle = c_{\\uparrow}^{\\dagger}c_{\\downarrow}^{\\dagger}\\left|0\\right\\rangle$，有两个电子 ($n_{\\uparrow}=1, n_{\\downarrow}=1$)。\n\n哈密顿量 $H_{\\text{imp}}$ 在这个占据数表象中是对角的。我们可以计算每个状态的能量本征值：\n-   对于 $\\left|0\\right\\rangle$：$H_{\\text{imp}}\\left|0\\right\\rangle = \\left[U(0)(0) - \\mu(0+0)\\right]\\left|0\\right\\rangle = 0$。能量为 $E_{0} = 0$。\n-   对于 $\\left|\\uparrow\\right\\rangle$：$H_{\\text{imp}}\\left|\\uparrow\\right\\rangle = \\left[U(1)(0) - \\mu(1+0)\\right]\\left|\\uparrow\\right\\rangle = -\\mu\\left|\\uparrow\\right\\rangle$。能量为 $E_{\\uparrow} = -\\mu$。\n-   对于 $\\left|\\downarrow\\right\\rangle$：$H_{\\text{imp}}\\left|\\downarrow\\right\\rangle = \\left[U(0)(1) - \\mu(0+1)\\right]\\left|\\downarrow\\right\\rangle = -\\mu\\left|\\downarrow\\right\\rangle$。能量为 $E_{\\downarrow} = -\\mu$。\n-   对于 $\\left|\\uparrow\\downarrow\\right\\rangle$：$H_{\\text{imp}}\\left|\\uparrow\\downarrow\\right\\rangle = \\left[U(1)(1) - \\mu(1+1)\\right]\\left|\\uparrow\\downarrow\\right\\rangle = (U-2\\mu)\\left|\\uparrow\\downarrow\\right\\rangle$。能量为 $E_{\\uparrow\\downarrow} = U-2\\mu$。\n\n接下来，我们计算巨正则配分函数 $Z_{\\text{imp}} = \\mathrm{Tr}\\left[\\exp\\left(-\\beta H_{\\text{imp}}\\right)\\right]$。迹是对希尔伯特空间中所有状态的玻尔兹曼因子求和。\n$$\nZ_{\\text{imp}} = \\exp(-\\beta E_{0}) + \\exp(-\\beta E_{\\uparrow}) + \\exp(-\\beta E_{\\downarrow}) + \\exp(-\\beta E_{\\uparrow\\downarrow})\n$$\n代入能量本征值：\n$$\nZ_{\\text{imp}} = \\exp(-\\beta \\cdot 0) + \\exp(-\\beta (-\\mu)) + \\exp(-\\beta (-\\mu)) + \\exp(-\\beta (U-2\\mu))\n$$\n$$\nZ_{\\text{imp}} = 1 + 2\\exp(\\beta\\mu) + \\exp(-\\beta(U-2\\mu))\n$$\n\n现在我们开始计算杂质格林函数。问题要求计算顺磁情况下的格林函数。由于哈密顿量是自旋对称的，解自然是顺磁的，即 $G_{\\text{imp},\\uparrow} = G_{\\text{imp},\\downarrow}$。我们将计算一个通用自旋 $\\sigma$ 的 $G_{\\text{imp},\\sigma}(i\\omega_{n})$，然后省略下标。费米子松原格林函数的 Lehmann 表示为：\n$$\nG_{\\text{imp},\\sigma}(i\\omega_{n}) = \\frac{1}{Z_{\\text{imp}}} \\sum_{m,n} \\frac{\\langle m | c_{\\sigma} | n \\rangle \\langle n | c_{\\sigma}^{\\dagger} | m \\rangle}{i\\omega_{n} - (E_{n} - E_{m})}\\left(\\exp(-\\beta E_{m}) + \\exp(-\\beta E_{n})\\right)\n$$\n其中 $|m\\rangle$ 和 $|n\\rangle$ 是 $H_{\\text{imp}}$ 的本征态。矩阵元 $\\langle n | c_{\\sigma}^{\\dagger} | m \\rangle$ 仅当状态 $|n\\rangle$ 可以通过在状态 $|m\\rangle$ 中产生一个自旋为 $\\sigma$ 的电子得到时才非零。我们必须找出所有这样的态对 $(m, n)$。对于特定自旋，比如 $\\sigma=\\uparrow$，算符 $c_{\\uparrow}^{\\dagger}$ 可以作用于没有自旋向上电子的状态，即 $\\left|0\\right\\rangle$ 和 $\\left|\\downarrow\\right\\rangle$。\n\n1.  从 $|m\\rangle = \\left|0\\right\\rangle$ 到 $|n\\rangle = \\left|\\uparrow\\right\\rangle$ 的跃迁：\n    -   矩阵元的平方为 $|\\langle \\uparrow | c_{\\uparrow}^{\\dagger} | 0 \\rangle|^{2} = 1$。\n    -   能量差为 $E_{n} - E_{m} = E_{\\uparrow} - E_{0} = -\\mu - 0 = -\\mu$。\n    -   玻尔兹曼因子为 $\\exp(-\\beta E_{m}) = \\exp(-\\beta E_{0}) = 1$ 和 $\\exp(-\\beta E_{n}) = \\exp(-\\beta E_{\\uparrow}) = \\exp(\\beta\\mu)$。\n    -   对求和的贡献是：\n    $$\n    \\frac{1}{Z_{\\text{imp}}} \\frac{1}{i\\omega_{n} - (-\\mu)} \\left(1 + \\exp(\\beta\\mu)\\right) = \\frac{1}{Z_{\\text{imp}}} \\frac{1 + \\exp(\\beta\\mu)}{i\\omega_{n} + \\mu}\n    $$\n\n2.  从 $|m\\rangle = \\left|\\downarrow\\right\\rangle$ 到 $|n\\rangle = \\left|\\uparrow\\downarrow\\right\\rangle$ 的跃迁：\n    -   矩阵元的平方为 $|\\langle \\uparrow\\downarrow | c_{\\uparrow}^{\\dagger} | \\downarrow \\rangle|^{2} = 1$。费米子算符的相位约定在此处产生一个正号。\n    -   能量差为 $E_{n} - E_{m} = E_{\\uparrow\\downarrow} - E_{\\downarrow} = (U-2\\mu) - (-\\mu) = U-\\mu$。\n    -   玻尔兹曼因子为 $\\exp(-\\beta E_{m}) = \\exp(-\\beta E_{\\downarrow}) = \\exp(\\beta\\mu)$ 和 $\\exp(-\\beta E_{n}) = \\exp(-\\beta E_{\\uparrow\\downarrow}) = \\exp(-\\beta(U-2\\mu))$。\n    -   对求和的贡献是：\n    $$\n    \\frac{1}{Z_{\\text{imp}}} \\frac{1}{i\\omega_{n} - (U-\\mu)} \\left(\\exp(\\beta\\mu) + \\exp(-\\beta(U-2\\mu))\\right) = \\frac{1}{Z_{\\text{imp}}} \\frac{\\exp(\\beta\\mu) + \\exp(-\\beta(U-2\\mu))}{i\\omega_{n} - U + \\mu}\n    $$\n\n没有其他可能产生自旋向上电子的跃迁。将这两项贡献相加，得到自旋为 $\\sigma=\\uparrow$ 的格林函数。由于自旋对称性，这与 $\\sigma=\\downarrow$ 的情况相同。因此，我们可以省略自旋下标，将结果记为 $G_{\\text{imp}}(i\\omega_n)$。\n$$\nG_{\\text{imp}}(i\\omega_{n}) = \\frac{1}{Z_{\\text{imp}}} \\left( \\frac{1 + \\exp(\\beta\\mu)}{i\\omega_{n} + \\mu} + \\frac{\\exp(\\beta\\mu) + \\exp(-\\beta(U-2\\mu))}{i\\omega_{n} - U + \\mu} \\right)\n$$\n代入 $Z_{\\text{imp}}$ 的表达式，我们得到杂质格林函数的最终闭合形式表达式。\n$$\nG_{\\text{imp}}(i\\omega_{n}) = \\frac{1}{1 + 2\\exp(\\beta\\mu) + \\exp(-\\beta(U-2\\mu))} \\left( \\frac{1 + \\exp(\\beta\\mu)}{i\\omega_{n} + \\mu} + \\frac{\\exp(\\beta\\mu) + \\exp(-\\beta(U-2\\mu))}{i\\omega_{n} - U + \\mu} \\right)\n$$\n该表达式仅依赖于 $U$、$\\mu$、$\\beta$ 和 $\\omega_{n}$，符合要求。这两项对应于涉及增加一个电子的两种可能的原子跃迁：第一项对应于从空位到单占据位的跃迁，激发能为 $-\\mu$；第二项对应于从单占据位到双占据位的跃迁，激发能为 $U-\\mu$。", "answer": "$$\n\\boxed{\\frac{1}{1 + 2\\exp(\\beta\\mu) + \\exp(-\\beta(U-2\\mu))} \\left( \\frac{1 + \\exp(\\beta\\mu)}{i\\omega_{n} + \\mu} + \\frac{\\exp(\\beta\\mu) + \\exp(-\\beta(U-2\\mu))}{i\\omega_{n} - U + \\mu} \\right)}\n$$", "id": "2983234"}, {"introduction": "动力学平均场理论的计算通常在虚构的松原频率轴上进行，但像态密度这样的物理可观测量存在于实频率轴上。这项动手编程练习将引导你解决一个关键且极具挑战性的任务——解析延拓，它能让你将原始的数值数据转化为有物理意义的谱函数 [@problem_id:2983197]。", "problem": "考虑动力学平均场理论 (DMFT) 中的费米子局域格林函数，它在松原频率上由谱表示定义\n$$\nG(i\\omega_n) \\equiv \\int_{-\\infty}^{\\infty} \\frac{A(\\omega)}{i\\omega_n - \\omega}\\, d\\omega,\n$$\n其中 $A(\\omega)$ 是谱函数，满足物理约束条件：对所有 $\\omega$ 都有 $A(\\omega) \\ge 0$，以及零阶矩求和规则\n$$\n\\int_{-\\infty}^{\\infty} A(\\omega)\\, d\\omega = 1.\n$$\n对于逆温度为 $\\beta$ (单位为 $1/\\mathrm{eV}$) 的费米子，松原频率为 $i\\omega_n = i(2n+1)\\pi/\\beta$，其中 $n=0,1,2,\\dots$。\n\n你的任务是实现一个解析延拓程序，该程序在给定离散数据 $G(i\\omega_n)$ 的情况下，构造推迟格林函数 $G^R(\\omega) = G(z)\\big|_{z=\\omega + i0^+}$ 的近似，然后构造谱函数\n$$\nA(\\omega) = -\\frac{1}{\\pi}\\,\\mathrm{Im}\\,G^R(\\omega).\n$$\n你必须使用根据给定的松原数据在复平面上构造的有理插值来建立此近似（例如，基于倒数差分的 Padé 型近似的连分式实现），在具有很小正虚部 $0^+$ 的实频轴上对其求值（使用有限展宽 $0^+ = \\delta$，单位为 $\\mathrm{eV}$），然后提取 $A(\\omega)$。\n\n为了使任务在数值上适定并能够进行验证，你必须完全在程序内部完成以下操作：\n- 对于每个测试用例，通过首先定义一个物理上合理的 $A_{\\text{true}}(\\omega)$，构建一个频率网格，并为每个松原频率数值计算谱表示积分来合成 $G(i\\omega_n)$。\n- 使用你的有理插值方法，从合成的 $G(i\\omega_n)$ 进行解析延拓，以在指定的实频网格上获得近似 $A_{\\text{rec}}(\\omega)$。\n- 通过计算以下量化检查来验证重构：\n  1. 零阶矩求和规则偏差\n     $$\n     \\Delta_0 \\equiv \\left| \\int A_{\\text{rec}}(\\omega)\\, d\\omega - 1 \\right|.\n     $$\n  2. 非负性：$A_{\\text{rec}}(\\omega)  0$ 的网格点所占的比例。\n  3. 松原一致性：通过谱表示从 $A_{\\text{rec}}(\\omega)$ 反向重构 $G(i\\omega_n)$，并计算相对均方根误差\n     $$\n     \\epsilon_{\\text{M}} \\equiv \\frac{\\sqrt{\\frac{1}{N}\\sum_{n=0}^{N-1}\\left|G_{\\text{rec}}(i\\omega_n) - G(i\\omega_n)\\right|^2}}{\\sqrt{\\frac{1}{N}\\sum_{n=0}^{N-1}\\left|G(i\\omega_n)\\right|^2}}.\n     $$\n\n对于每个测试用例，你必须返回一个布尔值，指示所有三个验证检查是否在该用例的指定容差内通过。这三个检查必须使用以下方式评估：\n- 绝对求和规则偏差 $\\Delta_0$ 与容差 $\\tau_0$ 进行比较。\n- 非负性违规比例与容差 $\\tau_{\\text{neg}}$ 进行比较。\n- 松原相对误差 $\\epsilon_{\\text{M}}$ 与容差 $\\tau_{\\text{M}}$ 进行比较。\n\n实现要求：\n- 能量（包括 $\\omega$、$D$、$\\Omega$、$\\gamma$ 和 $\\delta$）必须以电子伏特 (eV) 为单位处理。\n- 你的解析延拓应通过将 $G(z)$ 从点 $z_n = i\\omega_n$ 有理插值到线 $z=\\omega + i\\delta$（其中 $\\delta>0$，单位为 $\\mathrm{eV}$）来评估 $G^R(\\omega)$。\n- 在指定的实频网格上使用数值求积（例如梯形法则）来合成 $G(i\\omega_n)$ 并执行反投影检查。\n- 最终输出必须是单行，包含一个 Python 的布尔值列表，按顺序表示各测试用例的结果，不含额外文本（例如，“[True,False,True]”）。\n\n测试套件：\n对于每个测试用例，模型、参数、网格和验证容差定义如下。对于所有情况，取化学势 $\\mu=0$。\n- 情况 1（半圆能带）：\n  - 谱函数：对于 $|\\omega| \\le D$，为 $A_{\\text{true}}(\\omega) = \\frac{2}{\\pi D^2}\\sqrt{D^2 - \\omega^2}$，其他情况为 $A_{\\text{true}}(\\omega)=0$。\n  - 参数：$D = 1.0\\,\\mathrm{eV}$，$\\beta = 50\\,\\mathrm{eV}^{-1}$，松原频率数 $N=200$，展宽 $\\delta = 10^{-3}\\,\\mathrm{eV}$。\n  - 用于延拓和验证的实频网格：$\\omega \\in [-2.0, 2.0]\\,\\mathrm{eV}$，有 $2001$ 个均匀间隔点。\n  - 容差：$\\tau_0 = 2\\times 10^{-2}$，$\\tau_{\\text{neg}} = 2\\times 10^{-2}$，$\\tau_{\\text{M}} = 5\\times 10^{-2}$。\n- 情况 2（半圆能带，更高温度）：\n  - 谱函数：与情况 1 的函数形式相同。\n  - 参数：$D = 1.0\\,\\mathrm{eV}$，$\\beta = 10\\,\\mathrm{eV}^{-1}$，$N=80$，$\\delta = 10^{-3}\\,\\mathrm{eV}$。\n  - 实频网格：$\\omega \\in [-2.0, 2.0]\\,\\mathrm{eV}$，有 $2001$ 个点。\n  - 容差：$\\tau_0 = 3\\times 10^{-2}$，$\\tau_{\\text{neg}} = 5\\times 10^{-2}$，$\\tau_{\\text{M}} = 8\\times 10^{-2}$。\n- 情况 3（半圆能带，少量松原点）：\n  - 谱函数：与情况 1 的函数形式相同。\n  - 参数：$D = 1.0\\,\\mathrm{eV}$，$\\beta = 50\\,\\mathrm{eV}^{-1}$，$N=30$，$\\delta = 10^{-3}\\,\\mathrm{eV}$。\n  - 实频网格：$\\omega \\in [-2.0, 2.0]\\,\\mathrm{eV}$，有 $2001$ 个点。\n  - 容差：$\\tau_0 = 5\\times 10^{-2}$，$\\tau_{\\text{neg}} = 1\\times 10^{-1}$，$\\tau_{\\text{M}} = 1.5\\times 10^{-1}$。\n- 情况 4（双洛伦兹谱函数，对称峰）：\n  - 谱函数：$A_{\\text{true}}(\\omega) = \\tfrac{1}{2}L(\\omega;\\Omega,\\gamma) + \\tfrac{1}{2}L(\\omega;-\\Omega,\\gamma)$，其中 $L(\\omega;\\omega_0,\\gamma) = \\frac{1}{\\pi}\\frac{\\gamma}{(\\omega - \\omega_0)^2 + \\gamma^2}$。\n  - 参数：$\\Omega = 0.5\\,\\mathrm{eV}$，$\\gamma = 0.05\\,\\mathrm{eV}$，$\\beta = 50\\,\\mathrm{eV}^{-1}$，$N=120$，$\\delta = 10^{-3}\\,\\mathrm{eV}$。\n  - 实频网格：$\\omega \\in [-5.0, 5.0]\\,\\mathrm{eV}$，有 $4001$ 个点。\n  - 容差：$\\tau_0 = 2\\times 10^{-2}$，$\\tau_{\\text{neg}} = 5\\times 10^{-2}$，$\\tau_{\\text{M}} = 7\\times 10^{-2}$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”），其中每个结果是相应情况根据其容差评估的布尔值结果。", "solution": "我们从费米子格林函数的谱表示开始，\n$$\nG(i\\omega_n) = \\int_{-\\infty}^{\\infty} \\frac{A(\\omega)}{i\\omega_n - \\omega}\\, d\\omega,\n$$\n这个关系是在多体物理学的标准假设下从 Lehmann 表示推导出来的，并在动力学平均场理论 (DMFT) 中用作基本关系。推迟格林函数通过解析延拓到实频获得，\n$$\nG^R(\\omega) = \\lim_{\\eta\\to 0^+} G(\\omega + i\\eta),\n$$\n谱函数为\n$$\nA(\\omega) = -\\frac{1}{\\pi}\\,\\mathrm{Im}\\, G^R(\\omega).\n$$\n物理上验证 $A(\\omega)$ 的约束条件包括非负性 $A(\\omega) \\ge 0$、零阶矩求和规则 $\\int A(\\omega)\\, d\\omega = 1$，以及通过谱表示的松原变换的一致性。\n\n从离散值 $G(i\\omega_n)$ 进行解析延拓是不适定的。一种广泛使用的方法是在复平面上构造一个 $G(z)$ 的有理近似，使其在点 $z_n = i\\omega_n$ 处与给定数据匹配，然后评估该有理函数在实轴附近的值。一种构造性方法是通过 Thiele 的倒数差分，这会产生一个有理插值的连分式表示，在无噪声的情况下，它能精确地插值输入数据。\n\n给定 $N$ 个数据点 $(x_k, y_k)$，其中 $x_k \\in \\mathbb{C}$ 且 $y_k \\in \\mathbb{C}$，递归定义倒数差分 $r_{i,k}$：\n$$\nr_{i,0} = y_i,\\quad\nr_{i,k} = \\frac{x_{i+k} - x_i}{\\,r_{i+1,k-1} - r_{i,k-1}\\,},\\quad \\text{对于 } k = 1,\\dots,N-1,\\; i = 0,\\dots,N-1-k.\n$$\n连分式的系数为 $a_k = r_{0,k}$，其中 $k=1,\\dots,N-1$。得到的有理插值 $R(x)$ 可以对任何 $x \\in \\mathbb{C}$ 进行评估：\n$$\nR(x) = r_{0,0} + \\frac{x - x_0}{a_1 + \\frac{x - x_1}{a_2 + \\frac{x - x_2}{\\ddots + \\frac{x - x_{N-1}}{a_{N}}}}}.\n$$\n这种表示形式是从不规则样本构造的 Padé 型近似的一种形式，当函数在感兴趣的域内是亚纯的或能被有理函数很好地近似时，特别适用于解析延拓。在实践中，可以在分母中引入小的正则化，以避免在有限精度算术中出现除以零的情况。\n\n算法计划：\n1. 对于每个测试用例，在指定的实频网格上定义一个物理上有效的谱函数 $A_{\\text{true}}(\\omega)$。对于半圆能带，我们使用\n   $$\n   A_{\\text{true}}(\\omega) = \\frac{2}{\\pi D^2}\\sqrt{D^2 - \\omega^2}\\,\\Theta(D - |\\omega|),\n   $$\n   其中 $\\Theta$ 是单位阶跃函数。对于双洛伦兹情况，我们使用\n   $$\n   A_{\\text{true}}(\\omega) = \\tfrac{1}{2}\\frac{\\gamma}{\\pi[(\\omega - \\Omega)^2 + \\gamma^2]} + \\tfrac{1}{2}\\frac{\\gamma}{\\pi[(\\omega + \\Omega)^2 + \\gamma^2]}.\n   $$\n   这些函数是非负的，并且在 $\\mathbb{R}$ 上的积分为一；在有限网格上的数值实现可能会引入小的归一化误差，因此我们在重构后监控求和规则。\n2. 构造 $N$ 个费米子松原频率 $i\\omega_n = i(2n+1)\\pi/\\beta$，其中 $n=0,\\dots,N-1$。对于每个 $n$，使用网格上的梯形法则数值合成 $G(i\\omega_n)$：\n   $$\n   G(i\\omega_n) \\approx \\sum_j \\frac{A_{\\text{true}}(\\omega_j)}{i\\omega_n - \\omega_j}\\,\\Delta\\omega,\n   $$\n   其中 $\\Delta\\omega$ 是网格间距。\n3. 使用 Thiele 的倒数差分从点对 $(z_n, G(z_n))$（其中 $z_n=i\\omega_n$）构建有理插值 $R(z)$。在具有小 $\\delta>0$ 的实频网格上评估 $R(\\omega + i\\delta)$ 以近似 $G^R(\\omega)$，并计算\n   $$\n   A_{\\text{rec}}(\\omega) = -\\frac{1}{\\pi}\\,\\mathrm{Im}\\, R(\\omega + i\\delta).\n   $$\n4. 计算验证指标：\n   - 零阶矩偏差 $\\Delta_0 = \\left|\\int A_{\\text{rec}}(\\omega)\\, d\\omega - 1\\right|$，通过梯形法则计算。\n   - 非负性违规比例，即 $A_{\\text{rec}}(\\omega)  0$ 的网格点所占的比例（使用一个小的数值容差来忽略无穷小的负噪声）。\n   - 松原一致性误差 $\\epsilon_{\\text{M}}$，通过使用谱表示从 $A_{\\text{rec}}(\\omega)$ 重构 $G_{\\text{rec}}(i\\omega_n)$ 并形成相对均方根偏差。\n5. 将每个指标与该情况指定的容差进行比较，并输出一个布尔值，指示所有检查是否通过。\n\n数值考虑：\n- 梯形法则是合适的，因为被积函数是平滑的，且网格是密集的。对于洛伦兹情况，我们使用更宽的网格来捕捉尾部。\n- 展宽 $\\delta$ 模拟了 $0^+$，并稳定了有理近似在实轴上的评估。\n- Thiele 的方法需要防止倒数差分中的精确相消。必要时，我们在分母中添加一个微小的复数正则项。\n\n通过这些步骤，程序从已知的物理 $A_{\\text{true}}(\\omega)$ 生成合成的松原数据，通过有理插值进行解析延拓，重构 $A(\\omega)$，并使用 DMFT 中谱表示固有的求和规则和一致性约束来验证结果。\n\n最终输出是单行的 Python 布尔值列表，对应于情况 1-4，指示每种情况是否满足所有验证标准。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef thiele_coeffs(xs, ys, eps=1e-14):\n    \"\"\"\n    Compute Thiele's reciprocal differences coefficients for rational interpolation.\n    xs: array of complex x_k (distinct points)\n    ys: array of complex y_k (function values)\n    Returns (y0, a_coeffs) where y0 = ys[0], and a_coeffs are the continued fraction coefficients a1..aN.\n    \"\"\"\n    N = len(xs)\n    r = np.zeros((N, N), dtype=complex)\n    r[:, 0] = ys\n    # Build reciprocal differences\n    for k in range(1, N):\n        for i in range(0, N - k):\n            denom = r[i + 1, k - 1] - r[i, k - 1]\n            # Regularize if nearly zero to avoid division overflow\n            if abs(denom)  eps:\n                denom += eps * (1.0 + 1j)\n            r[i, k] = (xs[i + k] - xs[i]) / denom\n    a_coeffs = [r[0, k] for k in range(1, N)]\n    y0 = r[0, 0]\n    return y0, a_coeffs\n\ndef thiele_eval(x, xs, y0, a_coeffs, eps=1e-14):\n    \"\"\"\n    Evaluate the Thiele continued fraction at point x.\n    xs: array of nodes x0..x_{N-1}\n    y0: r[0,0]\n    a_coeffs: list [a1, a2, ..., aN]\n    \"\"\"\n    N = len(a_coeffs)\n    if N == 0:\n        return y0\n    denom = a_coeffs[-1]\n    # Regularize if nearly zero\n    if abs(denom)  eps:\n        denom += eps * (1.0 + 1j)\n    # Build from bottom\n    for k in range(N - 2, -1, -1):\n        denom = a_coeffs[k] + (x - xs[k + 1]) / denom\n        if abs(denom)  eps:\n            denom += eps * (1.0 + 1j)\n    return y0 + (x - xs[0]) / denom\n\ndef semicircular_A(omega, D):\n    \"\"\"Semicircular spectral function normalized to 1 over [-D, D].\"\"\"\n    A = np.zeros_like(omega, dtype=float)\n    mask = np.abs(omega) = D\n    A[mask] = (2.0 / (np.pi * D**2)) * np.sqrt(D**2 - omega[mask]**2)\n    return A\n\ndef lorentzian(omega, omega0, gamma):\n    \"\"\"Normalized Lorentzian: integrates to 1 over R.\"\"\"\n    return (gamma / np.pi) / ((omega - omega0)**2 + gamma**2)\n\ndef synthesize_G_matsubara(A_vals, omega_grid, beta, N_mats):\n    \"\"\"Compute G(iw_n) from A(omega) via trapezoidal rule on omega_grid.\"\"\"\n    domega = omega_grid[1] - omega_grid[0]\n    # Fermionic Matsubara frequencies\n    n = np.arange(N_mats)\n    iw = 1j * (2 * n + 1) * np.pi / beta\n    G = np.zeros(N_mats, dtype=complex)\n    # Vectorized integration over omega grid\n    # G(iw) = sum A(omega)/(iw - omega) d omega\n    denom = iw[:, None] - omega_grid[None, :]\n    G = np.trapz(A_vals[None, :] / denom, omega_grid, axis=1)\n    return iw, G\n\ndef reconstruct_A_from_G(iw, G_iw, omega_grid, delta):\n    \"\"\"Construct rational interpolant from (iw, G_iw) and evaluate A(omega).\"\"\"\n    y0, a_coeffs = thiele_coeffs(iw, G_iw)\n    # Evaluate on real axis with small imaginary part delta\n    G_ret = np.array([thiele_eval(om + 1j * delta, iw, y0, a_coeffs) for om in omega_grid], dtype=complex)\n    A_rec = -np.imag(G_ret) / np.pi\n    return A_rec, G_ret\n\ndef backproject_G_from_A(A_vals, omega_grid, iw_points):\n    \"\"\"Compute G(iw_n) by integrating A(omega)/(iw_n - omega) over omega_grid.\"\"\"\n    G_back = np.trapz(A_vals[None, :] / (iw_points[:, None] - omega_grid[None, :]), omega_grid, axis=1)\n    return G_back\n\ndef validate_case(A_true_func, A_params, beta, N_mats, delta, wmin, wmax, Nw, tol_sum, tol_neg_frac, tol_mats_err):\n    \"\"\"\n    Build A_true on grid, synthesize G(iw), perform analytic continuation via rational interpolation,\n    compute A_rec, and validate against tolerances.\n    \"\"\"\n    omega_grid = np.linspace(wmin, wmax, Nw)\n    # Construct A_true\n    if A_true_func == \"semicircle\":\n        D = A_params[\"D\"]\n        A_true = semicircular_A(omega_grid, D)\n    elif A_true_func == \"lorentzian_pair\":\n        Omega = A_params[\"Omega\"]\n        gamma = A_params[\"gamma\"]\n        A_true = 0.5 * lorentzian(omega_grid, Omega, gamma) + 0.5 * lorentzian(omega_grid, -Omega, gamma)\n    else:\n        raise ValueError(\"Unknown spectral function type.\")\n\n    # Synthesize Matsubara data\n    iw, G_iw = synthesize_G_matsubara(A_true, omega_grid, beta, N_mats)\n\n    # Analytic continuation (rational interpolation) to real axis\n    A_rec, G_ret = reconstruct_A_from_G(iw, G_iw, omega_grid, delta)\n\n    # Validation 1: sum rule deviation\n    integral_rec = np.trapz(A_rec, omega_grid)\n    sum_dev = abs(integral_rec - 1.0)\n\n    # Validation 2: non-negativity fraction\n    neg_eps = 1e-9\n    neg_frac = np.mean(A_rec  -neg_eps)\n\n    # Validation 3: Matsubara consistency via back-projection\n    G_back = backproject_G_from_A(A_rec, omega_grid, iw)\n    # Relative RMS error\n    num = np.sqrt(np.mean(np.abs(G_back - G_iw)**2))\n    denom = np.sqrt(np.mean(np.abs(G_iw)**2))\n    mats_rel_err = num / (denom + 1e-16)\n\n    # Decide pass/fail\n    ok = (sum_dev = tol_sum) and (neg_frac = tol_neg_frac) and (mats_rel_err = tol_mats_err)\n    return ok, sum_dev, neg_frac, mats_rel_err\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"A_true_func\": \"semicircle\",\n            \"A_params\": {\"D\": 1.0},\n            \"beta\": 50.0,\n            \"N_mats\": 200,\n            \"delta\": 1e-3,\n            \"wmin\": -2.0,\n            \"wmax\": 2.0,\n            \"Nw\": 2001,\n            \"tol_sum\": 2e-2,\n            \"tol_neg_frac\": 2e-2,\n            \"tol_mats_err\": 5e-2,\n        },\n        {\n            \"A_true_func\": \"semicircle\",\n            \"A_params\": {\"D\": 1.0},\n            \"beta\": 10.0,\n            \"N_mats\": 80,\n            \"delta\": 1e-3,\n            \"wmin\": -2.0,\n            \"wmax\": 2.0,\n            \"Nw\": 2001,\n            \"tol_sum\": 3e-2,\n            \"tol_neg_frac\": 5e-2,\n            \"tol_mats_err\": 8e-2,\n        },\n        {\n            \"A_true_func\": \"semicircle\",\n            \"A_params\": {\"D\": 1.0},\n            \"beta\": 50.0,\n            \"N_mats\": 30,\n            \"delta\": 1e-3,\n            \"wmin\": -2.0,\n            \"wmax\": 2.0,\n            \"Nw\": 2001,\n            \"tol_sum\": 5e-2,\n            \"tol_neg_frac\": 1e-1,\n            \"tol_mats_err\": 1.5e-1,\n        },\n        {\n            \"A_true_func\": \"lorentzian_pair\",\n            \"A_params\": {\"Omega\": 0.5, \"gamma\": 0.05},\n            \"beta\": 50.0,\n            \"N_mats\": 120,\n            \"delta\": 1e-3,\n            \"wmin\": -5.0,\n            \"wmax\": 5.0,\n            \"Nw\": 4001,\n            \"tol_sum\": 2e-2,\n            \"tol_neg_frac\": 5e-2,\n            \"tol_mats_err\": 7e-2,\n        },\n    ]\n\n    results = []\n    # Optionally collect metrics for internal debugging (not printed)\n    for case in test_cases:\n        ok, sum_dev, neg_frac, mats_err = validate_case(\n            case[\"A_true_func\"],\n            case[\"A_params\"],\n            case[\"beta\"],\n            case[\"N_mats\"],\n            case[\"delta\"],\n            case[\"wmin\"],\n            case[\"wmax\"],\n            case[\"Nw\"],\n            case[\"tol_sum\"],\n            case[\"tol_neg_frac\"],\n            case[\"tol_mats_err\"],\n        )\n        results.append(ok)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2983197"}]}