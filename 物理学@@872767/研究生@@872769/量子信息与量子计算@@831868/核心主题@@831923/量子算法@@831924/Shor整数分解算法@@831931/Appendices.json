{"hands_on_practices": [{"introduction": "Shor 算法的精妙之处在于将量子计算的强大能力与经典的数论原理相结合。虽然量子计算机负责寻找周期，但这一结果之所以能够用于因子分解，其根本原因在于经典的数论，特别是中国剩余定理。该定理揭示了整数 $a$ 模 $N$ 的周期 $r$ 与其模 $N$ 的素因子 $p_1$ 和 $p_2$ 的周期 $r_1$ 和 $r_2$ 之间的深刻联系。通过解决这个练习 [@problem_id:132634]，你将亲手计算这个联系，从而理解为何找到周期是破解大数分解难题的关键一步。", "problem": "在用于分解合数 $N = p_1 p_2$（其中 $p_1$ 和 $p_2$ 是不同的素因数）的Shor算法中，一个关键步骤是周期查找子程序。该子程序使用量子计算机来寻找函数 $f(x) = a^x \\pmod{N}$ 的周期 $r$，其中 $a$ 是一个随机选择的与 $N$ 互质的底数。周期 $r$ 定义为满足 $a^r \\equiv 1 \\pmod{N}$ 的最小正整数。\n\n根据中国剩余定理，模 $N$ 的整数乘法群 $(\\mathbb{Z}/N\\mathbb{Z})^*$ 同构于其素因数模群的直积 $(\\mathbb{Z}/p_1\\mathbb{Z})^* \\times (\\mathbb{Z}/p_2\\mathbb{Z})^*$。这意味着元素 $a$ 模 $N$ 的阶（或周期）$r$ 由其模 $p_1$ 和 $p_2$ 的阶决定。设 $r_1$ 为 $a$ 模 $p_1$ 的阶，$r_2$ 为 $a$ 模 $p_2$ 的阶。\n\n考虑分解数 $N$ 的任务。我们已知其素因数为 $p_1$ 和 $p_2$。对于一个特定的底数 $a$，我们发现其模 $p_1$ 的阶为 $r_1 = 6$，模 $p_2$ 的阶为 $r_2 = 5$。\n\n求函数 $f(x) = a^x \\pmod{N}$ 的周期 $r$。", "solution": "函数 $f(x) = a^x \\pmod{N}$ 的周期 $r$ 是满足 $a^r \\equiv 1 \\pmod{N}$ 的最小正整数。已知 $N = p_1 p_2$，$p_1$ 和 $p_2$ 为不同的素数，且 $a$ 与 $N$ 互质，根据中国剩余定理可得：\n\n$$\na^r \\equiv 1 \\pmod{N} \\quad \\text{当且仅当} \\quad \n\\begin{cases}\na^r \\equiv 1 \\pmod{p_1} \\\\\na^r \\equiv 1 \\pmod{p_2}\n\\end{cases}\n$$\n\n条件 $a^r \\equiv 1 \\pmod{p_1}$ 和 $a^r \\equiv 1 \\pmod{p_2}$ 要求 $r$ 分别是 $a$ 模 $p_1$ 的阶 $r_1$ 和模 $p_2$ 的阶 $r_2$ 的倍数。已知 $r_1 = 6$ 且 $r_2 = 5$，所以：\n\n$$\nr \\text{ 必须是 } 6 \\text{ 的倍数} \\quad \\text{且} \\quad r \\text{ 必须是 } 5 \\text{ 的倍数}。\n$$\n\n因此，$r$ 是 5 和 6 的公倍数。最小公倍数 (LCM) 是满足条件的最小正整数。因为 5 和 6 互质（$\\gcd(5,6) = 1$）：\n\n$$\n\\operatorname{lcm}(5, 6) = 5 \\times 6 = 30.\n$$\n\n验证 $r=30$ 满足 $a^r \\equiv 1 \\pmod{N}$：\n- 模 $p_1$：$a^{30} = (a^6)^5 \\equiv 1^5 \\equiv 1 \\pmod{p_1}$，因为 $r_1 = 6$ 整除 $30$。\n- 模 $p_2$：$a^{30} = (a^5)^6 \\equiv 1^6 \\equiv 1 \\pmod{p_2}$，因为 $r_2 = 5$ 整除 $30$。\n根据中国剩余定理，$a^{30} \\equiv 1 \\pmod{N}$。因为 30 是最小公倍数，所以不存在比 30 更小的 5 和 6 的正公倍数。因此，周期 $r = 30$。", "answer": "$$ \\boxed{30} $$", "id": "132634"}, {"introduction": "在量子计算机完成其核心任务并返回一个测量结果 $y$ 之后，魔法便告一段落，接力棒交还给了经典算法。这个实践练习 [@problem_id:132720] 聚焦于这关键的后处理步骤：如何从原始的测量值中提取出我们真正关心的周期 $r$。我们将运用连分数算法这一强大的数学工具，它能够为我们找到给定分数的最佳有理数近似，从而揭示隐藏在测量数据背后的周期信息。", "problem": "在用于分解整数 $N$ 的 Shor 算法中，一个关键的子程序是使用量子相位估计算法 (QPE) 来寻找函数 $f(x) = a^x \\pmod{N}$ 的周期 $r$，其中 $a$ 是一个随机选择的基数。QPE 电路使用一个 $t$ 比特的寄存器，产生一个测量结果，即一个整数 $y$，其中 $0 \\le y  Q = 2^t$。这个测量结果为某个整数 $s$ ($0 \\le s  r$) 对应的相位 $\\phi = s/r$ 提供了一个估计，由近似式 $\\phi \\approx y/Q$ 给出。\n\n为了从这个近似值中恢复周期 $r$，我们经典地计算 $y/Q$ 的连分数展开。该展开的有理渐近分数是 $y/Q$ 逐次更优的有理数近似。这些渐近分数之一的分母是周期 $r$ 或 $r$ 的一个因子的良好候选。\n\n一个实数 $x$ 的连分数展开是形如 $[a_0; a_1, a_2, \\dots]$ 的表达式，其中整数 $a_i$ 的计算方式如下：\n$x_0 = x, a_0 = \\lfloor x_0 \\rfloor$\n$x_1 = 1/(x_0 - a_0), a_1 = \\lfloor x_1 \\rfloor$\n$x_2 = 1/(x_1 - a_1), a_2 = \\lfloor x_2 \\rfloor$\n... 依此类推，直到过程终止（对于有理数 $x$）或无限进行（对于无理数 $x$）。\n\n第 $k$ 个有理渐近分数 $C_k = p_k/q_k$ 由该展开的前 $k+1$ 项给出：$C_k = [a_0; a_1, \\dots, a_k]$。分子 $p_k$ 和分母 $q_k$ 可以使用以下递推关系高效地计算：\n$p_k = a_k p_{k-1} + p_{k-2}$，其中 $p_{-2} = 0, p_{-1} = 1$\n$q_k = a_k q_{k-1} + q_{k-2}$，其中 $q_{-2} = 1, q_{-1} = 0$\n\n考虑一个 Shor 算法实例，该实例试图找到 $a=2$ 模 $N=33$ 的周期。QPE 电路使用一个 $t=8$ 比特的寄存器（因此 $Q=2^8=256$）并返回测量结果 $y=102$。你的任务是从测量得到的相位估计 $y/Q$ 的连分数展开中计算出有理渐近分数 $C_2 = p_2/q_2$。", "solution": "问题要求计算分数 $y/Q = 102/256$ 的有理渐近分数 $C_2 = p_2/q_2$。\n\n首先，我们简化该分数：\n$$ x = \\frac{102}{256} = \\frac{51}{128} $$\n\n接下来，我们应用连分数算法来找到系数 $a_0, a_1, a_2$。\n\n**第0步：**\n$x_0 = \\frac{51}{128}$\n$a_0 = \\lfloor x_0 \\rfloor = \\lfloor \\frac{51}{128} \\rfloor = 0$\n\n**第1步：**\n$x_1 = \\frac{1}{x_0 - a_0} = \\frac{1}{\\frac{51}{128} - 0} = \\frac{128}{51}$\n$a_1 = \\lfloor x_1 \\rfloor = \\lfloor \\frac{128}{51} \\rfloor = \\lfloor 2.509... \\rfloor = 2$\n\n**第2步：**\n$x_2 = \\frac{1}{x_1 - a_1} = \\frac{1}{\\frac{128}{51} - 2} = \\frac{1}{\\frac{128 - 102}{51}} = \\frac{1}{\\frac{26}{51}} = \\frac{51}{26}$\n$a_2 = \\lfloor x_2 \\rfloor = \\lfloor \\frac{51}{26} \\rfloor = \\lfloor 1.961... \\rfloor = 1$\n\n我们现在已经找到了连分数展开的前三个系数：$a_0=0$，$a_1=2$ 和 $a_2=1$。展开式以 $[0; 2, 1, \\dots]$ 开始。这足以计算渐近分数 $C_2$。\n\n现在，我们使用递推关系来找到 $k=0, 1, 2$ 时的分子 $p_k$ 和分母 $q_k$。\n初始条件为 $p_{-2} = 0, p_{-1} = 1$ 和 $q_{-2} = 1, q_{-1} = 0$。\n\n**对于 k = 0：** ($a_0 = 0$)\n$p_0 = a_0 p_{-1} + p_{-2} = 0 \\cdot 1 + 0 = 0$\n$q_0 = a_0 q_{-1} + q_{-2} = 0 \\cdot 0 + 1 = 1$\n所以，第零个渐近分数是 $C_0 = p_0/q_0 = 0/1$。\n\n**对于 k = 1：** ($a_1 = 2$)\n$p_1 = a_1 p_0 + p_{-1} = 2 \\cdot 0 + 1 = 1$\n$q_1 = a_1 q_0 + q_{-1} = 2 \\cdot 1 + 0 = 2$\n第一个渐近分数是 $C_1 = p_1/q_1 = 1/2$。\n\n**对于 k = 2：** ($a_2 = 1$)\n$p_2 = a_2 p_1 + p_0 = 1 \\cdot 1 + 0 = 1$\n$q_2 = a_2 q_1 + q_0 = 1 \\cdot 2 + 1 = 3$\n第二个渐近分数是 $C_2 = p_2/q_2 = 1/3$。\n\n所求的渐近分数是 $C_2$。", "answer": "$$ \\boxed{\\frac{1}{3}} $$", "id": "132720"}, {"introduction": "Shor 算法核心的量子相位估计算法 (QPE) 的成功并非必然，它在很大程度上依赖于在相位寄存器中使用足够数量的量子比特以达到必要的精度。这个练习 [@problem_id:132696] 探讨了一个非常实际的工程设计问题：到底需要多少量子比特才足够？通过这个计算，你将把对精度的抽象要求与量子资源的具体配置联系起来，从而更深入地理解算法成功率与物理实现之间的权衡。", "problem": "在用于分解整数 $N$ 的 Shor 算法中，一个关键的子程序是量子相位估计算法（QPE）。此子程序用于寻找函数 $f(x) = a^x \\pmod N$ 的周期 $r$，其中 $a$ 是一个与 $N$ 互质的随机选择的底数。QPE 算法应用于酉算符 $U$，其对计算基态 $|y\\rangle$ 的作用定义为 $U|y\\rangle = |ay \\pmod N\\rangle$。该算符的本征值形式为 $e^{i\\phi_s}$，其中相位为 $\\phi_s = 2\\pi s/r$，对于整数 $s \\in \\{0, 1, \\dots, r-1\\}$。\n\nQPE 算法使用一个 $t$ 量子比特的寄存器（“相位寄存器”），并输出一个整数 $j \\in \\{0, 1, \\dots, 2^t-1\\}$。这个测量被用来为其中一个相位 $\\phi = s/r$（这里我们省略了因子 $2\\pi$）生成一个有理近似值 $\\tilde{\\phi} = j/2^t$。\n\n对于 Shor 算法的后续经典部分，即使用连分数算法从估计值 $j/2^t$ 中找到周期 $r$ 的部分，相位估计必须非常精确。具体来说，误差必须满足以下不等式：\n$$ \\left| \\frac{s}{r} - \\frac{j}{2^t} \\right|  \\frac{1}{2N^2} $$\n为了获得高的成功概率，必须仔细选择相位寄存器中的量子比特数 $t$。QPE 算法保证能够以至少 $1 - \\epsilon$ 的成功概率将相位 $\\phi$ 估计到 $n$ 比特的精度（即误差 $|\\phi - \\tilde{\\phi}|$ 以 $2^{-n}$ 为界）。如果量子比特数 $t$ 选择为以下值，这个保证就成立：\n$$ t = n + \\left\\lceil \\log_2\\left(2 + \\frac{1}{2\\epsilon}\\right) \\right\\rceil $$\n你的任务是计算分解整数 $N=511$ 时，相位估计寄存器所需的最小整数量子比特数 $t$，要确保测量的相位足够精确，以使连分数算法能以至少 $1 - \\epsilon$ 的概率成功，其中失败容忍度为 $\\epsilon = 1/4$。", "solution": "为了保证连分数算法的成功，我们需要相位估计的误差满足：\n$$ \\left| \\frac{s}{r} - \\frac{j}{2^t} \\right|  \\frac{1}{2N^2} $$\n为了满足此条件，QPE的精度比特数 $n$ 必须满足 $2^n \\ge 2N^2$。因此，所需的最小整数 $n$ 为：\n$$n = \\lceil \\log_2(2N^2) \\rceil$$\n对于 $N=511$，我们计算：\n$$ 2N^2 = 2 \\cdot 511^2 = 2 \\cdot 261,121 = 522,242 $$\n由于 $2^{18} = 262,144$ 且 $2^{19} = 524,288$，我们有 $18  \\log_2(522,242)  19$。因此：\n$$ n = \\lceil \\log_2(522,242) \\rceil = 19 $$\n接下来，为了在失败容忍度为 $\\epsilon=1/4$ 的情况下成功获得此精度，我们使用给定的公式计算总量子比特数 $t$：\n$$ t = n + \\left\\lceil \\log_2\\left(2 + \\frac{1}{2\\epsilon}\\right) \\right\\rceil = 19 + \\left\\lceil \\log_2\\left(2 + \\frac{1}{2 \\cdot (1/4)}\\right) \\right\\rceil = 19 + \\lceil \\log_2(2 + 2) \\rceil = 19 + \\lceil \\log_2(4) \\rceil = 19 + 2 = 21 $$\n因此，所需的最小量子比特数是21。", "answer": "$$\\boxed{21}$$", "id": "132696"}]}