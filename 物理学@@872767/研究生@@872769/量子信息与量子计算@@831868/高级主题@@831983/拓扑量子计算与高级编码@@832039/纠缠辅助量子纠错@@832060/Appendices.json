{"hands_on_practices": [{"introduction": "纠缠辅助量子纠错码的核心思想是利用预共享的纠缠来放宽对经典码的要求。一个关键的参数是所需消耗的纠缠比特（ebit）数量 $c$。这个练习将引导你通过一个具体的例子，学习如何从两个经典线性码的校验矩阵出发，计算构建一个纠缠辅助CSS（EA-CSS）码所需的 $c$ 值，这是理解纠缠辅助方案成本与收益的第一步。", "problem": "一个纠缠辅助量子纠错码 (Entanglement-Assisted Quantum Error-Correcting, EA-QEC) 可以由两个定义在 $\\mathbb{F}_2$ 上的经典线性码构造而成。这种构造方法被称为纠缠辅助Calderbank-Shor-Steane (EA-CSS)，它为标准CSS框架提供了一个强大的推广。\n\n给定两个经典线性码，$C_X$ 的参数为 $[n, k_X]$，$C_Z$ 的参数为 $[n, k_Z]$，就可以构建一个EA-CSS码。该量子码的X型稳定子生成元来自于经典码 $C_X$ 的校验矩阵 $H_X$ 的行向量。类似地，Z型稳定子生成元来自于经典码 $C_Z$ 的校验矩阵 $H_Z$ 的行向量。\n\n该构造所需的预共享纠缠贝尔对（ebit）的数量，记为 $c$，由稳定子生成元的对易关系中的重叠部分决定。它由以下公式给出：\n$$\nc = \\text{rank}(H_X H_Z^T)\n$$\n其中矩阵乘法和秩的计算都在二元域 $\\mathbb{F}_2$ 上进行。\n\n考虑两个经典线性码 $C_X$ 和 $C_Z$，它们的码长均为 $n=5$。\n码 $C_X$ 由以下生成矩阵定义：\n$$\nG_X = \\begin{pmatrix} 1  0  1  1  0 \\\\ 0  1  0  1  1 \\end{pmatrix}\n$$\n码 $C_Z$ 由以下生成矩阵定义：\n$$\nG_Z = \\begin{pmatrix} 1  0  0  1  1 \\\\ 0  1  0  0  1 \\\\ 0  0  1  1  0 \\end{pmatrix}\n$$\n两个矩阵都处于系统形式 $G = [I_k | P]$，其中 $I_k$ 是 $k \\times k$ 的单位矩阵，$P$ 是一个 $k \\times (n-k)$ 的矩阵。相应的校验矩阵由 $H = [P^T | I_{n-k}]$ 给出。\n\n计算由经典码 $C_X$ 和 $C_Z$ 构造的EA-CSS码所需的ebit数量 $c$。", "solution": "为了确定EA-CSS码的ebit数量 $c$，我们使用公式 $c = \\text{rank}(H_X H_Z^T)$，该计算在 $\\mathbb{F}_2$ 上进行，其中 $H_X$ 和 $H_Z$ 分别是经典码 $C_X$ 和 $C_Z$ 的校验矩阵。\n\n给定系统形式的生成矩阵：\n- $G_X = \\begin{pmatrix} 1  0  1  1  0 \\\\ 0  1  0  1  1 \\end{pmatrix} = [I_2 \\mid P_X]$，因此 $P_X = \\begin{pmatrix} 1  1  0 \\\\ 0  1  1 \\end{pmatrix}$。\n- $G_Z = \\begin{pmatrix} 1  0  0  1  1 \\\\ 0  1  0  0  1 \\\\ 0  0  1  1  0 \\end{pmatrix} = [I_3 \\mid P_Z]$，因此 $P_Z = \\begin{pmatrix} 1  1 \\\\ 0  1 \\\\ 1  0 \\end{pmatrix}$。\n\n校验矩阵由 $H = [P^T \\mid I_{n-k}]$ 给出：\n- 对于 $C_X$，$k_X = 2$，$n - k_X = 3$：\n  $$\n  H_X = [P_X^T \\mid I_3] = \\begin{pmatrix} 1  0  1  0  0 \\\\ 1  1  0  1  0 \\\\ 0  1  0  0  1 \\end{pmatrix}.\n  $$\n- 对于 $C_Z$，$k_Z = 3$，$n - k_Z = 2$：\n  $$\n  H_Z = [P_Z^T \\mid I_2] = \\begin{pmatrix} 1  0  1  1  0 \\\\ 1  1  0  0  1 \\end{pmatrix}.\n  $$\n\n现在计算 $H_Z^T$：\n$$\nH_Z^T = \\begin{pmatrix} 1  1 \\\\ 0  1 \\\\ 1  0 \\\\ 1  0 \\\\ 0  1 \\end{pmatrix}.\n$$\n\n接下来，在 $\\mathbb{F}_2$ 上计算乘积 $H_X H_Z^T$：\n- $H_X$ 是 $3 \\times 5$ 矩阵，$H_Z^T$ 是 $5 \\times 2$ 矩阵，所以乘积是 $3 \\times 2$ 矩阵。\n- 元素 $(1,1)$: $(1,0,1,0,0) \\cdot (1,0,1,1,0)^T = 1\\cdot1 + 0\\cdot0 + 1\\cdot1 + 0\\cdot1 + 0\\cdot0 = 1 + 0 + 1 + 0 + 0 = 0$。\n- 元素 $(1,2)$: $(1,0,1,0,0) \\cdot (1,1,0,0,1)^T = 1\\cdot1 + 0\\cdot1 + 1\\cdot0 + 0\\cdot0 + 0\\cdot1 = 1 + 0 + 0 + 0 + 0 = 1$。\n- 元素 $(2,1)$: $(1,1,0,1,0) \\cdot (1,0,1,1,0)^T = 1\\cdot1 + 1\\cdot0 + 0\\cdot1 + 1\\cdot1 + 0\\cdot0 = 1 + 0 + 0 + 1 + 0 = 0$。\n- 元素 $(2,2)$: $(1,1,0,1,0) \\cdot (1,1,0,0,1)^T = 1\\cdot1 + 1\\cdot1 + 0\\cdot0 + 1\\cdot0 + 0\\cdot1 = 1 + 1 + 0 + 0 + 0 = 0$。\n- 元素 $(3,1)$: $(0,1,0,0,1) \\cdot (1,0,1,1,0)^T = 0\\cdot1 + 1\\cdot0 + 0\\cdot1 + 0\\cdot1 + 1\\cdot0 = 0$。\n- 元素 $(3,2)$: $(0,1,0,0,1) \\cdot (1,1,0,0,1)^T = 0\\cdot1 + 1\\cdot1 + 0\\cdot0 + 0\\cdot0 + 1\\cdot1 = 0 + 1 + 0 + 0 + 1 = 0$。\n\n因此，\n$$\nH_X H_Z^T = \\begin{pmatrix} 0  1 \\\\ 0  0 \\\\ 0  0 \\end{pmatrix}.\n$$\n\n现在在 $\\mathbb{F}_2$ 上求秩：\n- 该矩阵的行向量为：$(0,1)$, $(0,0)$, $(0,0)$。\n- 第一行是非零行，其他行是零行。行空间由 $(0,1)$ 张成，其维度为1。\n- 因此，$\\text{rank}(H_X H_Z^T) = 1$。\n\n所以，所需的ebit数量 $c = 1$。", "answer": "$$\\boxed{1}$$", "id": "80241"}, {"introduction": "在掌握了如何计算纠缠消耗之后，一个更具挑战性的任务是进行反向设计：给定我们期望的量子码参数（如编码的逻辑比特数 $k$ 和消耗的纠缠比特数 $c$），我们应该如何选择合适的经典码？这个练习将引导你运用EA-CSS码的参数平衡方程和秩约束条件，来推导底层经典码的维度所需满足的限制。这有助于我们理解在设计纠缠辅助码时，不同参数之间的权衡关系。", "problem": "纠缠辅助量子纠错码（EAQECC）是一种量子码，它利用发送方和接收方之间预先共享的纠缠态来提高其性能或简化其构造。这些码由参数 $[[n, k, d; c]]$ 表示，其中 $n$ 是物理量子比特的数量，$k$ 是编码的逻辑量子比特的数量，$d$ 是码的最小距离，$c$ 是编码和解码过程消耗的预共享贝尔对（ebits）的数量。\n\nEAQECC 的一种常见构造是纠缠辅助 Calderbank-Shor-Steane (EA-CSS) 框架。一个 EA-CSS 码由域 $\\mathbb{F}_2$ 上的两个经典线性码构建而成：$C_X = [n, k_X]$ 和 $C_Z = [n, k_Z]$。这里，$n$ 是经典码的长度，与物理量子比特的数量相匹配，而 $k_X, k_Z$ 分别是这两个码的维度。\n\n得到的 EA-CSS 码的参数通过以下方程关联：\n$$k = k_X + k_Z - n + c$$\n\n一个 EA-CSS 码所需的 ebits 数量 $c$ 由其底层经典码的校验矩阵决定。设 $H_X$ 为 $C_X$ 的校验矩阵，$H_Z$ 为 $C_Z$ 的校验矩阵。对于一个类型为 $[n_{cl}, k_{cl}]$ 的经典码，其校验矩阵是一个大小为 $(n_{cl}-k_{cl}) \\times n_{cl}$ 且秩为 $n_{cl}-k_{cl}$ 的矩阵。ebits 的数量由这些矩阵在 $\\mathbb{F}_2$ 上乘积的秩给出：\n$$c = \\text{rank}(H_X H_Z^T)$$\n\n考虑一个参数为 $[[16, 4, d; c=2]]$ 的 EA-CSS 码。该码由两个经典线性码构建，$C_X$ 的参数为 $[16, k_X]$，$C_Z$ 的参数为 $[16, k_Z]$。根据这些参数之间的关系，确定经典码 $C_X$ 的维度 $k_X$ 的最小可能整数值。", "solution": "EAQECC 的参数给定为 $[[16, 4, d; c=2]]$，因此：\n- $n = 16$ (物理量子比特数)，\n- $k = 4$ (逻辑量子比特数)，\n- $c = 2$ (ebits 数)。\n\n该 EA-CSS 码由经典线性码 $C_X = [16, k_X]$ 和 $C_Z = [16, k_Z]$ 构建。参数之间的关系是：\n$$\nk = k_X + k_Z - n + c\n$$\n代入已知值：\n$$\n4 = k_X + k_Z - 16 + 2\n$$\n求解 $k_X + k_Z$：\n$$\nk_X + k_Z = 18 \\quad (1)\n$$\n\nebits 的数量 $c$ 由以下公式给出：\n$$\nc = \\text{rank}(H_X H_Z^T) = 2\n$$\n其中 $H_X$ 是 $C_X$ 的校验矩阵，维度为 $(16 - k_X) \\times 16$，$H_Z$ 是 $C_Z$ 的校验矩阵，维度为 $(16 - k_Z) \\times 16$。乘积 $H_X H_Z^T$ 的维度为 $(16 - k_X) \\times (16 - k_Z)$。\n\n秩的基本性质是，一个矩阵乘积的秩不能超过任何一个因子矩阵的秩。因此：\n$$\n\\text{rank}(H_X H_Z^T) \\leq \\min(\\text{rank}(H_X), \\text{rank}(H_Z^T))\n$$\n由于校验矩阵是满秩的，我们有 $\\text{rank}(H_X) = 16-k_X$ 和 $\\text{rank}(H_Z) = 16-k_Z$（因此 $\\text{rank}(H_Z^T) = 16-k_Z$）。\n所以，\n$$\n2 \\leq \\min(16 - k_X, 16 - k_Z)\n$$\n这给了我们两个不等式：\n$$\n16 - k_X \\geq 2 \\quad \\Rightarrow \\quad k_X \\leq 14 \\quad (2)\n$$\n$$\n16 - k_Z \\geq 2 \\quad \\Rightarrow \\quad k_Z \\leq 14 \\quad (3)\n$$\n\n现在我们使用方程 (1) $k_Z = 18 - k_X$，并将其代入不等式 (3) 中：\n$$\n16 - (18 - k_X) \\geq 2\n$$\n$$\n-2 + k_X \\geq 2\n$$\n$$\nk_X \\geq 4 \\quad (4)\n$$\n\n结合 (2) 和 (4)，我们得到 $k_X$ 的取值范围：$4 \\leq k_X \\leq 14$。\n我们要求的是 $k_X$ 的最小可能整数值，即 4。\n\n我们可以验证这个值是可行的。如果 $k_X=4$，则 $k_Z = 18 - 4 = 14$。\n$H_X$ 的维度是 $(16 - 4) \\times 16 = 12 \\times 16$。\n$H_Z$ 的维度是 $(16 - 14) \\times 16 = 2 \\times 16$。\n乘积 $H_X H_Z^T$ 的维度是 $12 \\times 2$。\n一个 $12 \\times 2$ 矩阵的最大秩是 2，因此选择合适的经典码使得 $\\text{rank}(H_X H_Z^T) = 2$ 是可能的。\n\n因此，$k_X$ 的最小可能整数值为 4。", "answer": "$$\\boxed{4}$$", "id": "80222"}, {"introduction": "纠错码的设计不仅在于其参数，还在于其在实际纠错过程中的表现。一个重要的现象是“错误简并”（error degeneracy），即不同的物理错误可能产生完全相同的错误症状（syndrome），这会导致纠错失败并引入逻辑错误。这个练习将带你分析一个具体的纠缠辅助码，当一个物理错误被错误地识别为另一个简并错误时，最终会对编码的逻辑量子比特造成什么样的影响。", "problem": "在纠缠辅助量子纠错 (EAQEC) 码中，发送方和接收方之间预共享的纠缠用于放宽对稳定子生成元的约束。具体来说，作用于物理数据量子比特的码生成元不需要彼此对易。\n\n考虑一个 $[[n=3, k=1, c=1]]$ EAQEC 码，它借助一个贝尔对 ($c=1$) 的辅助，将一个逻辑量子比特 ($k=1$) 编码到三个物理量子比特 ($n=3$) 中。该码由两个物理生成元 $g_1$ 和 $g_2$ 定义，它们是3量子比特泡利群 $G_3$ 的元素：\n$$ g_1 = Z_1 \\otimes Z_2 \\otimes I_3 $$\n$$ g_2 = I_1 \\otimes X_2 \\otimes X_3 $$\n此处，$X_i, Y_i, Z_i$ 是量子比特 $i$ 上的标准泡利算符，$I_i$ 是量子比特 $i$ 上的单位算符。这些生成元的不对易性 $[g_1, g_2] \\neq 0$，使得贝尔对的使用成为必要。\n\n编码后量子比特的逻辑泡利算符由下式给出：\n$$ \\bar{X} = X_1 \\otimes X_2 \\otimes I_3 $$\n$$ \\bar{Z} = I_1 \\otimes Z_2 \\otimes Z_3 $$\n逻辑单位算符为 $\\bar{I} = I_1 \\otimes I_2 \\otimes I_3$，逻辑Y算符为 $\\bar{Y} = i\\bar{X}\\bar{Z}$。\n\n一个错误是一个作用在物理量子比特上的泡利算符 $E \\in G_3$。错误诊断子是一个二元向量，其分量由错误 $E$ 与生成元 $\\{g_j\\}$ 的对易关系确定。错误 $E$ 是通过测量生成元的本征值来检测的。如果 $E$ 与 $g_j$ 反对易，它会翻转相应的诊断子比特。如果两个不同的错误 $E_1$ 和 $E_2$ 产生相同的错误诊断子，则称它们是简并的。\n\n假设系统遭受了一个单量子比特泡利错误 $E_1 = Z_3$。然而，由于错误简并，恢复过程错误地假设发生了另一个不同的单量子比特错误 $E_2 = Z_2$。因此，恢复操作 $R$ 被选为所假设错误的逆，$R=E_2^\\dagger$。此恢复操作被应用于被错误损坏的状态。\n\n确定最终作用于编码量子比特上的等效逻辑泡利算符。将你的答案表示为 $\\bar{I}$、$\\bar{X}$、$\\bar{Y}$ 或 $\\bar{Z}$ 之一。", "solution": "问题要求我们找出由一个特定的错误和一个错误的恢复操作导致的等效逻辑算符。作用在逻辑态 $|\\psi_L\\rangle$ 上的总变换是 $R E_1$，其中 $E_1$ 是实际发生的错误，$R$ 是恢复操作。\n\n**步骤 1：验证错误 $E_1$ 和 $E_2$ 是简并的。**\n如果两个错误具有相同的诊断子，则它们是简并的。一个错误 $E$ 的诊断子由其与生成元 $g_1$ 和 $g_2$ 的对易关系确定。我们利用泡利算符的一个性质：两个泡利串（由泡利矩阵和单位矩阵通过张量积构成）对易，当且仅当它们在偶数个量子比特位置上的算符反对易。\n\n我们计算实际错误 $E_1 = Z_3 = I_1 \\otimes I_2 \\otimes Z_3$ 的诊断子。\n- 与 $g_1 = Z_1 \\otimes Z_2 \\otimes I_3$ 的对易关系：$E_1$ 和 $g_1$ 作用在不相交的量子比特集合上（位置3 vs 位置1,2）。它们在0个位置上反对易（偶数），所以它们对易。第一个诊断子比特是 0。\n- 与 $g_2 = I_1 \\otimes X_2 \\otimes X_3$ 的对易关系：$E_1$ 和 $g_2$ 在量子比特3上有非单位算符重叠 ($Z_3$ 和 $X_3$)。由于 $X_3$ 和 $Z_3$ 反对易，它们在1个位置上反对易（奇数），所以它们反对易。第二个诊断子比特是 1。\n因此，$E_1 = Z_3$ 的诊断子是 $(0, 1)$。\n\n现在，我们计算假设的错误 $E_2 = Z_2 = I_1 \\otimes Z_2 \\otimes I_3$ 的诊断子。\n- 与 $g_1 = Z_1 \\otimes Z_2 \\otimes I_3$ 的对易关系：$E_2$ 和 $g_1$ 在量子比特2上有重叠 ($Z_2$ 和 $Z_2$) 。由于 $Z_2$ 和 $Z_2$ 对易，它们在0个位置上反对易（偶数），所以它们对易。第一个诊断子比特是 0。\n- 与 $g_2 = I_1 \\otimes X_2 \\otimes X_3$ 的对易关系：$E_2$ 和 $g_2$ 在量子比特2上有重叠 ($Z_2$ 和 $X_2$)。由于 $X_2$ 和 $Z_2$ 反对易，它们在1个位置上反对易（奇数），所以它们反对易。第二个诊断子比特是 1。\n因此，$E_2 = Z_2$ 的诊断子是 $(0, 1)$。\n由于两个错误具有相同的诊断子，它们确实是简并的。\n\n**步骤 2：确定等效逻辑算符。**\n初始状态是一个编码后的逻辑态 $|\\psi_L\\rangle$。错误 $E_1 = Z_3$ 发生，将状态转换为 $E_1 |\\psi_L\\rangle = Z_3 |\\psi_L\\rangle$。\n\n恢复过程假设错误是 $E_2=Z_2$。相应的恢复操作是 $R = E_2^\\dagger$。由于 $Z_2$ 是厄米算符和幺正算符，所以 $Z_2^\\dagger = Z_2$。因此，$R = Z_2$。\n\n恢复操作被应用于被损坏的状态：\n$$ |\\psi_{final}\\rangle = R (E_1 |\\psi_L\\rangle) = Z_2 (Z_3 |\\psi_L\\rangle) $$\n作用在逻辑态上的等效算符是恢复算符与错误算符的乘积：\n$$ L_{eff} = R E_1 = Z_2 Z_3 = I_1 \\otimes Z_2 \\otimes Z_3 $$\n\n**步骤 3：用码的逻辑算符表示该等效算符。**\n问题提供了逻辑算符的定义：\n$$ \\bar{X} = X_1 \\otimes X_2 \\otimes I_3 $$\n$$ \\bar{Z} = I_1 \\otimes Z_2 \\otimes Z_3 $$\n通过将我们得到的等效算符结果与这些定义进行比较，我们可以看到：\n$$ L_{eff} = I_1 \\otimes Z_2 \\otimes Z_3 = \\bar{Z} $$\n因此，对错误的错误识别导致在编码量子比特上施加了一个逻辑 $\\bar{Z}$ 门。", "answer": "$$ \\boxed{\\bar{Z}} $$", "id": "80330"}]}