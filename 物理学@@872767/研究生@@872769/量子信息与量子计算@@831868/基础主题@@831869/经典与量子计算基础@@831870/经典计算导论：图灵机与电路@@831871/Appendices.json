{"hands_on_practices": [{"introduction": "理解图灵机（一种尽管简单却能执行任何经典计算的模型）的强大功能和工作机制的最佳方式，是逐步追踪其操作过程。这个练习 [@problem_id:93270] 要求我们分析一个为执行一元乘法而设计的特定图灵机，并计算其所需的总步数。这项实践旨在培养我们理解状态转换、读写头移动以及分析简单图灵机算法时间复杂度的能力。", "problem": "一个特定的图灵机由状态集 $Q = \\{q_0, q_1, q_2, q_h\\}$ 定义，其中 $q_0$ 是起始状态，$q_h$ 是停机状态。带字母表为 $\\Gamma = \\{0, 1, X, \\blank\\}$，其中 $\\blank$ 是空白符号。该图灵机的行为由以下转移函数 $\\delta(q, s) = (q', s', d)$ 描述，其中 $q$ 是当前状态，$s$ 是读写头下的符号，$q'$ 是下一个状态，$s'$ 是要写入带上的符号，$d \\in \\{L, R\\}$ 是读写头移动的方向。\n\n转移规则如下：\n1.  $\\delta(q_0, 1) = (q_1, X, R)$\n2.  $\\delta(q_0, X) = (q_0, X, R)$\n3.  $\\delta(q_0, 0) = (q_h, 0, R)$\n4.  $\\delta(q_1, 1) = (q_1, 1, R)$\n5.  $\\delta(q_1, 0) = (q_1, 0, R)$\n6.  $\\delta(q_1, \\blank) = (q_2, \\blank, L)$\n7.  $\\delta(q_2, 1) = (q_2, 1, L)$\n8.  $\\delta(q_2, 0) = (q_2, 0, L)$\n9.  $\\delta(q_2, X) = (q_2, X, L)$\n10. $\\delta(q_2, \\blank) = (q_0, \\blank, R)$\n\n该图灵机从一条包含字符串 `1^n01^m` 的带上开始运行，其中 $n$ 和 $m$ 为非负整数，字符串两侧被空白符号包围。带的配置为 `... \\blank \\blank 1...1 0 1...1 \\blank \\blank ...`，其中第一个 `1...1` 的长度为 $n$，第二个 `1...1` 的长度为 $m$。读写头初始位置在输入字符串的最左侧符号上。如果 $n>0$，则为第一个‘1’。如果 $n=0$，字符串为 `01^m`，读写头从‘0’开始。\n\n计算该图灵机进入停机状态 $q_h$ 所需的总步数，将其表示为参数 $n$ 和 $m$ 的函数。", "solution": "我们分析一个“标记并返回”周期，对于 $n$ 个初始的1，每个1重复一次该周期，然后进行最后一次扫描以停机。\n\n1.  一个完整的循环从状态 $q_0$ 开始，位于第 $i$ 个（从左数）未标记的 `1` 之前。图灵机首先扫描过 $i-1$ 个 `X`，然后读取第 $i$ 个 `1`。这需要 $i$ 步。在第 $i$ 步，它读取 `1`，写入 `X`，进入 $q_1$，并向右移动。\n\n2.  在状态 $q_1$ 中，读写头向右移动，经过剩下的 $n-i$ 个 `1`、一个 `0` 和 $m$ 个 `1`，直到找到第一个空白符号 $\\blank$。这需要 $(n-i) + 1 + m + 1 = n+m-i+2$ 步。在第 $n+m-i+2$ 步，它读取 $\\blank$，写入 $\\blank$，进入 $q_2$，并向左移动。\n\n3.  在状态 $q_2$ 中，读写头向左移动，经过 $m$ 个 `1`、一个 `0` 和 $n$ 个 `X` 或 `1`，直到找到最左边的空白符号 $\\blank$。这需要 $m+1+n+1 = n+m+2$ 步。在第 $n+m+2$ 步，它读取 $\\blank$，写入 $\\blank$，进入 $q_0$，并向右移动。\n\n4.  因此，处理第 $i$ 个 `1` 的一个完整循环的总步数为：\n    $$i + (n+m-i+2) + (n+m+2) = 2n + 2m + 4$$\n    这个步数与 $i$ 无关。\n\n5.  这个循环对 $i=1, \\dots, n$ 重复 $n$ 次。所以这部分的步数总计为：\n    $$n \\times (2n + 2m + 4) = 2n^2 + 2nm + 4n$$\n\n6.  在 $n$ 个循环之后，带上的内容是 `X^n01^m`，图灵机回到状态 $q_0$，读写头位于第一个 `X` 上。机器随后扫描过 $n$ 个 `X`，需要 $n$ 步。在第 $n+1$ 步，它读取 `0`，进入停机状态 $q_h$。这总共增加了 $n+1$ 步。\n\n7.  总步数是循环步数和最后扫描步数的总和：\n    $$(2n^2 + 2nm + 4n) + (n+1) = 2n^2 + 2nm + 5n + 1$$\n    我们可以检验，当 $n=0$ 时，该公式结果为1，这与从 $q_0$ 读到 `0` 并一步停机的情况相符。\n\n因此，图灵机在\n$$2n^2 +2nm+5n +1$$\n步后停机。", "answer": "$$\\boxed{2n^2 + 2nm + 5n + 1}$$", "id": "93270"}, {"introduction": "从图灵机的顺序模型转向布尔电路的并行模型，我们关注的重点也随之改变。对于电路而言，一个关键的性能指标是“深度”，它直接对应于并行计算环境下的计算时间。这项实践 [@problem_id:93272] 要求我们计算一个实现奇偶校验函数（计算中的一个基本操作）的电路深度。通过分析这种树状电路结构，我们可以直观地看到在并行模型中，计算时间如何随输入规模扩展。", "problem": "在经典计算理论中，布尔电路是一个有向无环图，用于表示一个布尔函数。图的顶点称为门，边代表导线。入度为0的顶点是电路的输入，一些指定的顶点是输出。每个非输入门代表一个布尔运算，例如与（AND）、或（OR）、非（NOT）或异或（XOR）。\n\n电路的深度定义为从任何输入顶点到任何输出顶点的最长路径的长度。这个度量对于理解一个函数的并行计算时间至关重要。\n\n考虑计算一个二进制字符串的奇偶性问题。一个字符串 $x = x_1x_2...x_n$ 的奇偶性定义为 $P(x) = x_1 \\oplus x_2 \\oplus \\dots \\oplus x_n$，其中 $\\oplus$ 表示异或（XOR）运算，等价于模2加法。\n\n我们的任务是设计一个电路来计算长度为 $n = 2^k$ 的输入字符串的奇偶性，其中 $k$ 是一个正整数。该电路只能使用双输入异或门。设计遵循一个特定的级联结构：\n1.  第一层门接收初始的 $n$ 个输入比特对，并计算它们的异或。\n2.  随后的每一层接收前一层输出的比特对，并计算它们的异或。\n3.  这个过程持续进行，直到产生一个代表最终奇偶性的比特位。\n\n求该奇偶电路的深度，作为 $k$ 的函数。", "solution": "计算长度为 $n = 2^k$ 的输入字符串的奇偶性的电路是通过分层重复应用双输入异或门来构建的。深度是将输入减少到单个输出比特所需的层数。\n\n- 最初，有 $n = 2^k$ 个输入比特。\n- 经过第一层后，比特数减半为 $n/2 = 2^{k-1}$，因为每个异或门组合了两个比特。\n- 经过第二层后，比特数再次减半为 $2^{k-2}$。\n- 这种减半过程持续进行，直到只剩下一个比特。\n\n设深度为 $d$。经过 $d$ 层后，比特数为 $2^{k-d}$。令其等于1，得到：\n\n$$\n2^{k-d} = 1\n$$\n\n因为 $2^0 = 1$，所以有：\n\n$$\nk - d = 0\n$$\n\n解出 $d$：\n\n$$\nd = k\n$$\n\n因此，电路的深度为 $k$。", "answer": "$$ \\boxed{k} $$", "id": "93272"}, {"introduction": "现在，我们将前两个概念联系起来。图灵机的“有限控制器”通常被抽象地描述，但它终究是一个可以用逻辑门构建的物理设备。这最后一个实践 [@problem_id:93292] 将这种联系具体化。我们将一个简单图灵机的转换规则，将其状态和符号编码为二进制信号，并设计出实现其决策过程的最小逻辑电路（以析取范式 DNF 表示）。这个练习揭示了图灵机控制单元的神秘面纱，并展示了逻辑电路在实现计算规则方面的普适性。", "problem": "一台图灵机（Turing Machine, TM）被设计用于判定语言 $L$，该语言由含有偶数个1的二进制字符串组成。该语言定义在字母表 $\\Sigma = \\{0, 1\\}$ 上。该图灵机的具体设计如下：\n\n1.  **状态：** 非停机状态的集合为 $Q = \\{q_{\\text{even}}, q_{\\text{odd}}\\}$，其中 $q_{\\text{even}}$ 是起始状态。\n2.  **带字母表：** 带字母表为 $\\Gamma = \\{0, 1, B\\}$，其中 $B$ 是空白符号。\n3.  **操作：** 图灵机从状态 $q_{\\text{even}}$ 开始，其读写头位于输入字符串的最左侧符号上。它从左到右读取字符串。\n    *   如果读到 `0`，其状态不改变。\n    *   如果读到 `1`，其状态翻转（从 $q_{\\text{even}}$ 变为 $q_{\\text{odd}}$ 或反之）。\n    *   当读取 `0` 或 `1` 时，它将相同的符号写回带上，并将读写头向右（R）移动。\n    *   当读到第一个空白符号 `B`（表示输入结束）时，它停机。如果从状态 $q_{\\text{even}}$ 停机，则接受输入字符串。如果从状态 $q_{\\text{odd}}$ 停机，则拒绝输入。停机时，它将 `B` 写回带上并向右移动。\n\n此图灵机的转移函数将通过一个组合逻辑电路来实现。该电路的输入和输出由布尔变量表示，基于一个特定的编码方案：\n\n*   **输入：**\n    *   当前非停机状态由单个比特 $s_c$ 编码，其中 $q_{\\text{even}} \\leftrightarrow 0$ 且 $q_{\\text{odd}} \\leftrightarrow 1$。\n    *   从带上读取的符号由两个比特 $t_1t_0$ 编码，其中 $0 \\leftrightarrow 00$，$1 \\leftrightarrow 01$，$B \\leftrightarrow 10$。假设输入比特组合 $t_1t_0 = 11$ 永远不会出现。\n\n*   **输出：** 该电路有五个输出比特：\n    *   $H$：停机信号。如果机器停机，则 $H=1$，否则 $H=0$。\n    *   $s_n$：下一状态比特，编码方式与 $s_c$ 相同。该输出仅在 $H=0$ 时有意义；如果 $H=1$，其值为“无关项”（don't care）。\n    *   $t'_1t'_0$：要写回带上的符号的两个比特，使用与输入符号相同的编码方式。\n    *   $d$：读写头移动方向。$d=1$ 表示向右（R），$d=0$ 表示向左（L）。\n\n您的任务是确定此转移函数的逻辑总规模。规模定义为所有五个输出函数（$H, s_n, t'_1, t'_0, d$）的最小析取范式（Disjunctive Normal Form, DNF）表达式中文字（literal）的总数。一个文字是一个变量或其否定（例如，表达式 $a\\bar{b} \\lor c$ 有3个文字）。", "solution": "我们将输入变量表示为 $s_c, t_1, t_0$。我们根据图灵机规则为每个输出函数构建一个真值表，其中 $s_c=0$ 代表 $q_{\\text{even}}$，$s_c=1$ 代表 $q_{\\text{odd}}$，并且 $t_1t_0=11$ 是一个无关项（don't care）条件。\n\n| $s_c$ | $t_1t_0$ (符号) | 规则                                    | $H$ | $s_n$    | $t'_1t'_0$ | $d$ |\n| :---- | :-------------- | :-------------------------------------- | :-- | :------- | :--------- | :-- |\n| 0     | 00 ('0')         | 保持 $q_{\\text{even}}$, 写'0', 右移       | 0   | 0        | 00         | 1   |\n| 1     | 00 ('0')         | 保持 $q_{\\text{odd}}$, 写'0', 右移        | 0   | 1        | 00         | 1   |\n| 0     | 01 ('1')         | 变为 $q_{\\text{odd}}$, 写'1', 右移         | 0   | 1        | 01         | 1   |\n| 1     | 01 ('1')         | 变为 $q_{\\text{even}}$, 写'1', 右移        | 0   | 0        | 01         | 1   |\n| 0     | 10 ('B')         | 停机, 写'B', 右移                      | 1   | dc       | 10         | 1   |\n| 1     | 10 ('B')         | 停机, 写'B', 右移                      | 1   | dc       | 10         | 1   |\n| X     | 11 (未使用)      | 无关                                    | dc  | dc       | dc dc      | dc  |\n\n现在为每个输出推导最小DNF表达式：\n\n1.  **$H$ (停机):** $H=1$ 仅当 $t_1t_0=10$。\n   $$H = t_1 \\land \\neg t_0$$\n   这有2个文字。\n\n2.  **$d$ (方向):** $d=1$ 对所有有效输入都成立。因此，$d=1$。一个空的DNF（真值）有0个文字。\n\n3.  **$t'_1$ (写符号 bit 1):** $t'_1=1$ 仅当 $t_1t_0=10$。利用 $t_1t_0=11$ 是无关项，我们可以将 $t_1t_0=10$ 和 $t_1t_0=11$ 分组，得到：\n   $$t'_1 = t_1$$\n   这有1个文字。\n\n4.  **$t'_0$ (写符号 bit 0):** $t'_0=1$ 仅当 $t_1t_0=01$。利用 $t_1t_0=11$ 是无关项，我们可以将 $t_1t_0=01$ 和 $t_1t_0=11$ 分组，得到：\n   $$t'_0 = t_0$$\n   这有1个文字。\n\n5.  **$s_n$ (下一状态):** 我们只关心 $H=0$ 的情况，即 $t_1t_0$ 为 $00$ 或 $01$。当 $t_1t_0=10$ 或 $t_1t_0=11$ 时，$s_n$ 是无关项。\n    - 当 $t_1t_0=00$ (读'0') 时，$s_n = s_c$。\n    - 当 $t_1t_0=01$ (读'1') 时，$s_n = \\neg s_c$。\n    这等价于 $s_n = s_c \\oplus t_0$ （在 $H=0$ 的条件下）。\n    其DNF表达式为：\n   $$s_n = (s_c \\land \\neg t_1 \\land \\neg t_0) \\lor (\\neg s_c \\land \\neg t_1 \\land t_0)$$\n    这个表达式包含两个乘积项，每个有3个文字，总共6个文字。\n\n将所有文字计数相加：\n总规模 = (H的文字) + (d的文字) + ($t'_1$的文字) + ($t'_0$的文字) + ($s_n$的文字)\n总规模 = $2 + 0 + 1 + 1 + 6 = 10$。", "answer": "$$\\boxed{10}$$", "id": "93292"}]}