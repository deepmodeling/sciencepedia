{"hands_on_practices": [{"introduction": "将基因从一个物种（例如，富含AT的寄生虫）转移到另一个具有不同碱基组成的物种（例如，富含GC的细菌）中进行异源表达时，一个核心的挑战是密码子使用的不匹配。密码子优化旨在通过替换为宿主偏好的同义密码子来解决此问题，但这会直接改变基因的核苷酸组成。这项练习旨在通过计算密码子优化对第三位密码子GC含量（$GC3$）和mRNA结构稳定性的一个简单代理指标的影响，为理解序列重设计的后果提供一个定量的基础[@problem_id:2721544]。", "problem": "您的任务是形式化、实现并计算一个简单的组成模型，该模型用于量化将富含腺嘌呤-胸腺嘧啶（AT）的寄生虫基因进行密码子优化以便在富含鸟嘌呤-胞嘧啶（GC）的细菌宿主中表达时，如何改变密码子第三位的鸟嘌呤-胞嘧啶含量（GC3）和一个代表信使核糖核酸（mRNA）二级结构稳定性的指标。推导和计算必须基于以下基本原理：分子生物学的中心法则（脱氧核糖核酸（DNA）转录为mRNA，mRNA再翻译为蛋白质）、遗传密码的简并性（同义密码子编码相同的氨基酸）、摆动位置概念（许多密码子的第三位通常是简并的），以及一个经过充分验证的经验观察：较高的GC含量倾向于通过更强的碱基配对和堆积相互作用来增加RNA双链的稳定性。对于结构稳定性指标，使用一个针对与反向互补序列完美碱基配对双链的加性最近邻堆积模型，该模型在此作为一个组分敏感的稳定性指数，而非完整的二级结构预测。\n\n请精确定义以下量和计算规则：\n\n- 设一个编码DNA序列的长度为 $L_{\\mathrm{nt}}$ 个核苷酸，且 $L_{\\mathrm{nt}} \\bmod 3 = 0$，因此有 $n = L_{\\mathrm{cod}} = L_{\\mathrm{nt}}/3$ 个密码子。GC3含量定义为\n  $$ GC3(\\text{DNA}) = \\frac{1}{n} \\sum_{i=1}^{n} \\mathbf{1}\\left\\{ b_{3i} \\in \\{\\mathrm{G},\\mathrm{C}\\} \\right\\}, $$\n  其中 $b_{3i}$ 是第 $i$ 个密码子第三位的核苷酸，$\\mathbf{1}\\{\\cdot\\}$ 是指示函数。\n\n- 为模拟mRNA的结构稳定性，首先通过将 $\\mathrm{T} \\rightarrow \\mathrm{U}$ 把DNA转录为RNA。对于一个长度为 $L$ 的RNA序列，将预期双链堆积能（EDSE）指标定义为在与反向互补序列完美Watson–Crick配对情况下，二核苷酸堆积贡献的平均值：\n  $$ \\mathrm{EDSE}(\\text{RNA}) = \\frac{1}{L-1} \\sum_{i=1}^{L-1} e\\left( s_i s_{i+1} \\right), $$\n  其中 $s_i \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$ 且 $e(\\cdot)$ 是一个简化的类似Turner的最近邻能量（单位：$\\mathrm{kcal/mol}$），用于由顶部链相邻碱基 $s_i s_{i+1}$ 指示的二核苷酸步长，假设其与反向互补序列完美Watson–Crick配对。使用以下在 $37^\\circ \\mathrm{C}$ 下为所有 $16$ 种二核苷酸定义的固定能量表 $e(\\cdot)$（单位：$\\mathrm{kcal/mol}$）：\n\n  - $e(\\mathrm{AA}) = -0.93$, $e(\\mathrm{AC}) = -1.10$, $e(\\mathrm{AG}) = -1.30$, $e(\\mathrm{AU}) = -1.10$.\n  - $e(\\mathrm{CA}) = -1.10$, $e(\\mathrm{CC}) = -2.08$, $e(\\mathrm{CG}) = -2.17$, $e(\\mathrm{CU}) = -1.30$.\n  - $e(\\mathrm{GA}) = -1.30$, $e(\\mathrm{GC}) = -2.24$, $e(\\mathrm{GG}) = -2.08$, $e(\\mathrm{GU}) = -1.10$.\n  - $e(\\mathrm{UA}) = -0.90$, $e(\\mathrm{UC}) = -1.30$, $e(\\mathrm{UG}) = -1.10$, $e(\\mathrm{UU}) = -0.93$.\n\n- 密码子优化规则：给定一个根据标准遗传密码从输入编码DNA翻译出的氨基酸序列，通过为每个氨基酸独立选择宿主最常用的同义密码子（如下所提供）来重新编码该蛋白质。对于只有一个密码子的氨基酸，保留该密码子。这将产生一个宿主优化的DNA序列，其氨基酸序列相同，但GC3和EDSE可能不同。\n\n- 对于每个测试用例，计算变化量：\n  $$ \\Delta GC3 = GC3(\\text{optimized DNA}) - GC3(\\text{original DNA}), $$\n  $$ \\Delta \\mathrm{EDSE} = \\mathrm{EDSE}(\\text{optimized RNA}) - \\mathrm{EDSE}(\\text{original RNA}). $$\n  以 $\\mathrm{kcal/mol}$ 每步为单位报告 $\\Delta \\mathrm{EDSE}$。注意，更负的 $\\Delta \\mathrm{EDSE}$ 值表示基于堆积的平均稳定性预测增加。\n\n针对富含GC的细菌密码子偏好模型的宿主规范，给出标准遗传密码下每个氨基酸对应的宿主最常用密码子：\n\n- 丙氨酸 $\\mathrm{A}$: $\\mathrm{GCC}$\n- 精氨酸 $\\mathrm{R}$: $\\mathrm{CGC}$\n- 天冬酰胺 $\\mathrm{N}$: $\\mathrm{AAC}$\n- 天冬氨酸 $\\mathrm{D}$: $\\mathrm{GAC}$\n- 半胱氨酸 $\\mathrm{C}$: $\\mathrm{TGC}$\n- 谷氨酰胺 $\\mathrm{Q}$: $\\mathrm{CAG}$\n- 谷氨酸 $\\mathrm{E}$: $\\mathrm{GAG}$\n- 甘氨酸 $\\mathrm{G}$: $\\mathrm{GGC}$\n- 组氨酸 $\\mathrm{H}$: $\\mathrm{CAC}$\n- 异亮氨酸 $\\mathrm{I}$: $\\mathrm{ATC}$\n- 亮氨酸 $\\mathrm{L}$: $\\mathrm{CTG}$\n- 赖氨酸 $\\mathrm{K}$: $\\mathrm{AAG}$\n- 甲硫氨酸 $\\mathrm{M}$: $\\mathrm{ATG}$ (单一密码子)\n- 苯丙氨酸 $\\mathrm{F}$: $\\mathrm{TTC}$\n- 脯氨酸 $\\mathrm{P}$: $\\mathrm{CCG}$\n- 丝氨酸 $\\mathrm{S}$: $\\mathrm{TCG}$\n- 苏氨酸 $\\mathrm{T}$: $\\mathrm{ACC}$\n- 色氨酸 $\\mathrm{W}$: $\\mathrm{TGG}$ (单一密码子)\n- 酪氨酸 $\\mathrm{Y}$: $\\mathrm{TAC}$\n- 缬氨酸 $\\mathrm{V}$: $\\mathrm{GTC}$\n\n测试套件。使用以下三个编码DNA序列，均为大写，长度是 $3$ 的倍数，且不含内部终止密码子：\n\n- 用例 A（富含AT，类似寄生虫，包含一个色氨酸）： \n  $$ \\text{ATGAAA AAT TTT ATT GAA GAT CAA AGA TAT CAT TGT ATA AAA AAT TTT ATT GAA GAT CAA AGA TAT CAT TGT ATA AAA AAT TTT ATT TGG} $$\n  连接时不带空格以获得序列。\n\n- 用例 B（短序列，包含脯氨酸和甘氨酸以测试GC驱动的密码子）： \n  $$ \\text{ATG CCT GGT TTT AAT ATT AAA TAT TGG} $$\n\n- 用例 C（使用富含AT的源密码子，偏向于六重简并的氨基酸）： \n  $$ \\text{ATG TTA TCT AGA TTA TCT AGA TTA TCT AGA GAA GAT CAA AAA AAT TTT ATT TAT CAT TGT} $$\n\n您的程序必须：\n\n- 实现标准遗传密码，将密码子翻译为氨基酸，并使用宿主偏好的密码子进行重新编码。\n- 计算原始和优化后DNA的 $GC3$ 含量，以及它们的差值 $\\Delta GC3$，作为一个无单位的十进制小数。\n- 通过上述指定的二核苷酸平均值计算原始和优化后RNA的 $\\mathrm{EDSE}$，以及它们的差值 $\\Delta \\mathrm{EDSE}$，单位为 $\\mathrm{kcal/mol}$ 每步。\n- 将 $\\Delta GC3$ 和 $\\Delta \\mathrm{EDSE}$ 均四舍五入到 $6$ 位小数。\n\n最终输出格式要求：\n\n- 您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例（按 A、B、C 的顺序），并且本身是一个形式为 $[\\Delta GC3, \\Delta \\mathrm{EDSE}]$ 的双元素列表。例如：$[[x_1,y_1],[x_2,y_2],[x_3,y_3]]$。", "solution": "目标是量化密码子优化对两个关键分子特性的影响：密码子第三位的鸟嘌呤-胞嘧啶含量（$GC3$）和信使RNA（mRNA）结构稳定性的一个替代指标——预期双链堆积能（$\\mathrm{EDSE}$）。这是针对一个富含AT的基因序列在富含GC的宿主中进行表达优化而执行的。我们将计算这两个指标的变化量 $\\Delta GC3$ 和 $\\Delta \\mathrm{EDSE}$。\n\n整体计算流程如下：\n$1$. 对于给定的原始DNA序列，计算其初始 $GC3$ 值，记为 $GC3(\\text{original DNA})$，以及初始稳定性指标 $\\mathrm{EDSE}(\\text{original RNA})$。\n$2$. 使用标准遗传密码将原始DNA序列翻译成其对应的氨基酸序列。\n$3$. 根据提供的密码子使用表，为每个氨基酸选择宿主偏好的密码子，将此氨基酸序列重新编码成一个新的、优化后的DNA序列。\n$4$. 对于这个新的优化DNA序列，计算其最终 $GC3$ 值 $GC3(\\text{optimized DNA})$ 和最终稳定性指标 $\\mathrm{EDSE}(\\text{optimized RNA})$。\n$5$. 计算差值：$\\Delta GC3 = GC3(\\text{optimized DNA}) - GC3(\\text{original DNA})$ 和 $\\Delta \\mathrm{EDSE} = \\mathrm{EDSE}(\\text{optimized RNA}) - \\mathrm{EDSE}(\\text{original RNA})$。\n\n为了实现这一流程，我们首先需要建立必要的数据结构。\n\n标准遗传密码将DNA密码子映射到氨基酸。需要一个从64个可能的密码子到20种标准氨基酸和终止信号的映射。对于本问题，我们只需要正向翻译。\n映射示例包括：`TTT` $\\rightarrow$ 苯丙氨酸 (F)，`ATG` $\\rightarrow$ 甲硫氨酸 (M)，`GGC` $\\rightarrow$ 甘氨酸 (G)。\n\n宿主偏好密码子表为重新编码提供了确定性规则。它将每个氨基酸映射到一个单一、特定的DNA密码子。例如：\n- 丙氨酸 (A): $\\mathrm{GCC}$\n- 精氨酸 (R): $\\mathrm{CGC}$\n- ...以此类推，涵盖所有20种氨基酸。\n\n最近邻能量表给出了16种可能的RNA二核苷酸中每一种的堆积能量贡献 $e(s_i s_{i+1})$。例如：\n- $e(\\mathrm{GC}) = -2.24 \\, \\mathrm{kcal/mol}$\n- $e(\\mathrm{AU}) = -1.10 \\, \\mathrm{kcal/mol}$\n- $e(\\mathrm{AA}) = -0.93 \\, \\mathrm{kcal/mol}$\n\n有了这些数据结构，我们就可以定义计算函数了。\n\n首先，计算 $GC3$ 含量。对于一个长度为 $L_{\\mathrm{nt}}$、包含 $n = L_{\\mathrm{nt}}/3$ 个密码子的DNA序列，该函数遍历序列，检查每个密码子第三位（即，以1为基准索引的位置 $3, 6, 9, \\ldots, L_{\\mathrm{nt}}$）的核苷酸。将这些位置上鸟嘌呤（'G'）或胞嘧啶（'C'）的计数除以密码子总数 $n$。\n$$\nGC3(\\text{DNA}) = \\frac{\\text{第三位是G或C的数量}}{\\text{密码子总数}}\n$$\n\n其次，计算 $\\mathrm{EDSE}$。给定的DNA序列首先通过将每个胸腺嘧啶（'T'）替换为尿嘧啶（'U'）来转录成其对应的mRNA序列。对于得到的长度为 $L$ 的RNA序列，我们计算所有 $L-1$ 个相邻二核苷酸对的最近邻堆积能量之和。然后将该总和除以对的数量 $L-1$ 进行归一化。\n$$\n\\mathrm{EDSE}(\\text{RNA}) = \\frac{1}{L-1} \\sum_{i=1}^{L-1} e\\left( s_i s_{i+1} \\right)\n$$\n这里，$s_i$ 是RNA序列中位置 $i$ 的碱基，$e(\\cdot)$ 是由所提供表格定义的能量函数。更负的 $\\mathrm{EDSE}$ 值意味着在模型完美双链的假设下，平均稳定性更高。\n\n第三，序列优化函数执行一个两步过程。\n第1步，翻译：将输入的DNA序列解析为一个由3个碱基组成的密码子列表。使用标准遗传密码图谱将每个密码子翻译成一个氨基酸。结果是一个代表编码蛋白质的氨基酸字符串。\n第2步，重新编码：然后将此氨基酸字符串翻译回DNA序列。对于字符串中的每个氨基酸，从宿主的密码子使用表中选择相应的偏好密码子。将这些密码子连接起来，形成最终的优化DNA序列。\n\n最后，对每个测试用例执行主算法。计算原始序列和优化序列的 $GC3$ 和 $\\mathrm{EDSE}$ 值。计算差值 $\\Delta GC3$ 和 $\\Delta \\mathrm{EDSE}$，并按要求四舍五入到6位小数。将结果汇总并格式化为指定的输出结构。这种对所提供数据系统地应用已定义规则的方法，确保了结果的可复现性和正确性。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the codon optimization problem by calculating changes in GC3 and EDSE.\n    \"\"\"\n    \n    # --- Data Structures ---\n    \n    # Standard Genetic Code: DNA Codon -> Amino Acid (1-letter code)\n    STANDARD_GENETIC_CODE = {\n        'TTT': 'F', 'TTC': 'F', 'TTA': 'L', 'TTG': 'L',\n        'CTT': 'L', 'CTC': 'L', 'CTA': 'L', 'CTG': 'L',\n        'ATT': 'I', 'ATC': 'I', 'ATA': 'I', 'ATG': 'M',\n        'GTT': 'V', 'GTC': 'V', 'GTA': 'V', 'GTG': 'V',\n        'TCT': 'S', 'TCC': 'S', 'TCA': 'S', 'TCG': 'S',\n        'CCT': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',\n        'ACT': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T',\n        'GCT': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',\n        'TAT': 'Y', 'TAC': 'Y', 'TAA': '*', 'TAG': '*',\n        'CAT': 'H', 'CAC': 'H', 'CAA': 'Q', 'CAG': 'Q',\n        'AAT': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K',\n        'GAT': 'D', 'GAC': 'D', 'GAA': 'E', 'GAG': 'E',\n        'TGT': 'C', 'TGC': 'C', 'TGA': '*', 'TGG': 'W',\n        'CGT': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R',\n        'AGT': 'S', 'AGC': 'S', 'AGA': 'R', 'AGG': 'R',\n        'GGT': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G',\n    }\n    \n    # Host's Preferred Codon Table: Amino Acid -> DNA Codon\n    HOST_CODON_USAGE = {\n        'A': 'GCC', 'R': 'CGC', 'N': 'AAC', 'D': 'GAC', 'C': 'TGC',\n        'Q': 'CAG', 'E': 'GAG', 'G': 'GGC', 'H': 'CAC', 'I': 'ATC',\n        'L': 'CTG', 'K': 'AAG', 'M': 'ATG', 'F': 'TTC', 'P': 'CCG',\n        'S': 'TCG', 'T': 'ACC', 'W': 'TGG', 'Y': 'TAC', 'V': 'GTC',\n    }\n    \n    # Nearest-Neighbor Stacking Energy Table (kcal/mol) for RNA\n    ENERGY_TABLE = {\n        'AA': -0.93, 'AC': -1.10, 'AG': -1.30, 'AU': -1.10,\n        'CA': -1.10, 'CC': -2.08, 'CG': -2.17, 'CU': -1.30,\n        'GA': -1.30, 'GC': -2.24, 'GG': -2.08, 'GU': -1.10,\n        'UA': -0.90, 'UC': -1.30, 'UG': -1.10, 'UU': -0.93,\n    }\n\n    # --- Core Functions ---\n\n    def calculate_gc3(dna_sequence):\n        \"\"\"Calculates the GC3 fraction of a DNA sequence.\"\"\"\n        num_codons = len(dna_sequence) // 3\n        if num_codons == 0:\n            return 0.0\n        \n        gc3_count = 0\n        for i in range(num_codons):\n            third_base = dna_sequence[i * 3 + 2]\n            if third_base in ('G', 'C'):\n                gc3_count += 1\n        return gc3_count / num_codons\n\n    def calculate_edse(dna_sequence):\n        \"\"\"Calculates the Expected Duplex Stacking Energy (EDSE) of an RNA sequence.\"\"\"\n        rna_sequence = dna_sequence.replace('T', 'U')\n        seq_len = len(rna_sequence)\n        if seq_len  2:\n            return 0.0\n\n        total_energy = 0.0\n        for i in range(seq_len - 1):\n            dinucleotide = rna_sequence[i:i+2]\n            total_energy += ENERGY_TABLE[dinucleotide]\n        \n        return total_energy / (seq_len - 1)\n\n    def optimize_sequence(dna_sequence):\n        \"\"\"Optimizes a DNA sequence based on host codon preference.\"\"\"\n        # 1. Translate original DNA to amino acid sequence\n        num_codons = len(dna_sequence) // 3\n        amino_acid_seq = []\n        for i in range(num_codons):\n            codon = dna_sequence[i * 3 : i * 3 + 3]\n            amino_acid = STANDARD_GENETIC_CODE[codon]\n            amino_acid_seq.append(amino_acid)\n        \n        # 2. Re-encode amino acid sequence using host preferences\n        optimized_codons = []\n        for aa in amino_acid_seq:\n            optimized_codons.append(HOST_CODON_USAGE[aa])\n        \n        return \"\".join(optimized_codons)\n\n    # --- Test Cases ---\n    \n    test_cases_raw = {\n        \"A\": \"ATGAAA AAT TTT ATT GAA GAT CAA AGA TAT CAT TGT ATA AAA AAT TTT ATT GAA GAT CAA AGA TAT CAT TGT ATA AAA AAT TTT ATT TGG\",\n        \"B\": \"ATG CCT GGT TTT AAT ATT AAA TAT TGG\",\n        \"C\": \"ATG TTA TCT AGA TTA TCT AGA TTA TCT AGA GAA GAT CAA AAA AAT TTT ATT TAT CAT TGT\"\n    }\n\n    # Concatenate sequences by removing spaces\n    test_cases = [seq.replace(\" \", \"\") for seq in test_cases_raw.values()]\n\n    # --- Main Logic ---\n\n    results = []\n    for original_dna in test_cases:\n        # Calculate metrics for original sequence\n        gc3_orig = calculate_gc3(original_dna)\n        edse_orig = calculate_edse(original_dna)\n        \n        # Generate optimized sequence\n        optimized_dna = optimize_sequence(original_dna)\n        \n        # Calculate metrics for optimized sequence\n        gc3_opt = calculate_gc3(optimized_dna)\n        edse_opt = calculate_edse(optimized_dna)\n        \n        # Compute differences and round\n        delta_gc3 = np.round(gc3_opt - gc3_orig, 6)\n        delta_edse = np.round(edse_opt - edse_orig, 6)\n        \n        results.append([delta_gc3, delta_edse])\n\n    # Format and print the final output\n    # Convert floats to strings for custom list representation asked by the problem\n    # e.g., [[x1, y1], [x2, y2]] --> \"[[x1,y1],[x2,y2]]\"\n    result_str = \",\".join([f\"[{d_gc3},{d_edse}]\" for d_gc3, d_edse in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```", "id": "2721544"}, {"introduction": "同义密码子的选择不仅改变序列的碱基组成，还显著影响信使RNA（mRNA）分子的折叠稳定性。mRNA的二级结构可以调控翻译起始、延伸速率和降解速率，因此是基因表达调控中的一个重要层面。这项练习在前一个练习的基础上，引入了一个更复杂的生物物理模型，要求您通过动态规划算法来计算RNA二级结构的最小自由能（MFE），从而定量评估密码子优化对mRNA结构稳定性的具体影响[@problem_id:2721468]。", "problem": "给定一个计算任务，其基础是分子生物学的中心法则以及异源基因表达中的密码子偏好性。蛋白质编码序列（coding DNA sequences, CDS）由密码子组成，每个密码子对应一个氨基酸。由于遗传密码的简并性，多个同义密码子可以对应同一个氨基酸，但生物体通常表现出密码子使用偏好。信使核糖核酸（mRNA）的二级结构稳定性可以通过碱基配对能量学来近似，而改变密码子的选择（同时保持氨基酸序列不变）可以改变编码区RNA的最小自由能（MFE）。您的目标是实现一个有原则的估计方法，用于计算当用宿主偏好的密码子对替换中性密码子对时编码区MFE的变化，同时保持氨基酸序列不变。\n\n使用以下基本依据：\n- 中心法则：DNA转录为RNA，RNA翻译成蛋白质。\n- 密码子简并性：多个密码子可以编码同一个氨基酸。\n- 宿主密码子使用偏好：每种氨基酸都有一组同义密码子频率分布，对于密码子 $c$，其频率记为 $f(c)$，且对于同一氨基酸的所有同义密码子，有 $\\sum f(c)=1$。\n- RNA碱基配对：Watson-Crick碱基对（$\\mathrm{AU}$、$\\mathrm{UA}$、$\\mathrm{GC}$、$\\mathrm{CG}$）和摆动配对（$\\mathrm{GU}$、$\\mathrm{UG}$）为RNA二级结构贡献稳定（负）能量。作为热力学最小自由能的一个简化且具有物理动机的代理模型，我们采用一种加权的Nussinov式动态规划模型，该模型在满足最小发夹环长度的约束下，寻找能量最低的非交叉碱基对集合。\n\n定义和要求：\n1. 对于一个氨基酸 $a$ 及其同义密码子集合 $\\mathcal{C}(a)$，定义每个 $c \\in \\mathcal{C}(a)$ 的宿主使用频率为 $f(c)$，且满足 $\\sum_{c \\in \\mathcal{C}(a)} f(c) = 1$。相对适应度 $w(c)$ 定义为\n$$\nw(c) = \\frac{f(c)}{\\max_{c' \\in \\mathcal{C}(a)} f(c')}.\n$$\n2. 如果一个密码子 $c$ 满足 $w(c) \\ge \\theta$，则称其为中性密码子，其中 $\\theta \\in (0,1]$ 是给定的阈值。如果一个密码子对 $(c_i,c_{i+1})$ 中的 $c_i$ 和 $c_{i+1}$ 均为中性密码子，则称该密码子对为中性密码子对。您必须以不相交、非重叠的相邻对形式扫描密码子：$(c_1,c_2)$、$(c_3,c_4)$、$(c_5,c_6)$ 等。如果密码子数量 $N$ 为奇数，则最后一个密码子保持不变，不参与配对替换决策。\n3. 对于每个中性密码子对 $(c_i,c_{i+1})$，将其替换为宿主偏好的密码子对 $(c_i^\\star,c_{i+1}^\\star)$，其中 $c_i^\\star$ 是氨基酸 $a_i$ 达到 $\\max_{c \\in \\mathcal{C}(a_i)} f(c)$ 的任意一个密码子，类似地，$c_{i+1}^\\star$ 是氨基酸 $a_{i+1}$ 的偏好密码子。这将产生一个优化后的DNA序列，并保持氨基酸序列不变。\n4. 通过将 $\\mathrm{T}$ 替换为 $\\mathrm{U}$，将DNA转录为RNA。\n5. 使用以下加权Nussinov式动态规划，为RNA序列 $S$ 计算MFE代理值 $G(S)$：\n   - 允许的碱基对为 $\\mathrm{AU}$、$\\mathrm{UA}$、$\\mathrm{GC}$、$\\mathrm{CG}$、$\\mathrm{GU}$ 和 $\\mathrm{UG}$，其配对能量（单位：千卡/摩尔）如下：\n     - $E(\\mathrm{AU})=E(\\mathrm{UA})=-2.1$，\n     - $E(\\mathrm{GC})=E(\\mathrm{CG})=-3.4$，\n     - $E(\\mathrm{GU})=E(\\mathrm{UG})=-0.9$。\n   - 强制最小发夹环长度为 $L_0 = 3$，意味着位置 $i$ 和 $j$ 只有在 $j - i - 1 \\ge L_0$ 时才能配对。\n   - 设 $S$ 的长度为 $L$。定义一个动态规划矩阵 $D \\in \\mathbb{R}^{L \\times L}$，其中 $D[i,j]$ 是子序列 $S[i..j]$ 在非交叉碱基配对下可达到的最小能量。递推关系为：\n     $$\n     D[i,j] = \\min \\Big\\{\n       D[i+1,j],\\;\n       D[i,j-1],\\;\n       D[i+1,j-1] + E(S[i],S[j]) \\;\\text{若允许配对},\\;\n       \\min_{k=i}^{j-1} \\big( D[i,k] + D[k+1,j] \\big)\n     \\Big\\}\n     $$\n     基础条件为 $D[i,i]=0$ 和对于 $i \\ge j$ 的 $D[i,j]=0$。如果配对不被允许，则将该分支视为 $+\\infty$。最终的MFE代理值为 $G(S) = D[0,L-1]$，单位为千卡/摩尔。\n6. MFE的变化量 $\\Delta G$ 定义为\n$$\n\\Delta G = G(S_{\\text{opt}}) - G(S_{\\text{orig}}),\n$$\n单位为千卡/摩尔，其中 $S_{\\text{orig}}$ 是原始转录的RNA，$S_{\\text{opt}}$ 是优化后转录的RNA。所有报告的能量均以千卡/摩尔为单位，并四舍五入到 $3$ 位小数。\n\n宿主使用频率表和遗传密码子集：\n- 只考虑测试序列中出现的氨基酸及其同义密码子。对于每种氨基酸 $a$，宿主使用频率 $f(c)$（每个密码子 $c$）如下：\n  - 丙氨酸（$\\mathrm{Ala}$，单字母 $\\mathrm{A}$）：$\\{\\mathrm{GCT}:0.2,\\ \\mathrm{GCC}:0.5,\\ \\mathrm{GCA}:0.1,\\ \\mathrm{GCG}:0.2\\}$。\n  - 甘氨酸（$\\mathrm{Gly}$，$\\mathrm{G}$）：$\\{\\mathrm{GGT}:0.25,\\ \\mathrm{GGC}:0.45,\\ \\mathrm{GGA}:0.1,\\ \\mathrm{GGG}:0.2\\}$。\n  - 缬氨酸（$\\mathrm{Val}$，$\\mathrm{V}$）：$\\{\\mathrm{GTT}:0.2,\\ \\mathrm{GTC}:0.2,\\ \\mathrm{GTA}:0.1,\\ \\mathrm{GTG}:0.5\\}$。\n  - 赖氨酸（$\\mathrm{Lys}$，$\\mathrm{K}$）：$\\{\\mathrm{AAA}:0.3,\\ \\mathrm{AAG}:0.7\\}$。\n  - 谷氨酸（$\\mathrm{Glu}$，$\\mathrm{E}$）：$\\{\\mathrm{GAA}:0.35,\\ \\mathrm{GAG}:0.65\\}$。\n  - 甲硫氨酸（$\\mathrm{Met}$，$\\mathrm{M}$）：$\\{\\mathrm{ATG}:1.0\\}$。\n- 对这些氨基酸及其列出的密码子使用标准遗传密码。所有测试序列都完全由这些密码子组成。\n\n测试套件：\n每个测试用例是一个序对 $(\\text{DNA}, \\theta)$，其中 $\\text{DNA}$ 是编码DNA序列（一个长度为 $3$ 的倍数的字符串），$\\theta$ 是中性阈值。对于每个测试，计算上文定义的 $\\Delta G$。所有测试均使用 $L_0 = 3$。将每个结果报告为浮点数，单位为千卡/摩尔，并四舍五入到 $3$ 位小数。\n\n- 测试 $1$ (正常路径): $(\\text{\"GCTGGTAAAGAA\"},\\ \\theta=0.4)$。\n- 测试 $2$ (已是偏好密码子，预计无变化): $(\\text{\"GCCGGCAAGGAG\"},\\ \\theta=0.4)$。\n- 测试 $3$ (密码子数量为奇数，最后一个密码子不参与配对替换): $(\\text{\"GCTGTGAAA\"},\\ \\theta=0.4)$。\n- 测试 $4$ (包含单密码子氨基酸甲硫氨酸): $(\\text{\"ATGGAA\"},\\ \\theta=0.4)$。\n- 测试 $5$ (严格的中性阈值，仅当两个密码子都已是首选时才进行替换): $(\\text{\"GCTGGTAAAGAA\"},\\ \\theta=1.0)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的浮点数列表，结果顺序与测试顺序相同，每个浮点数四舍五入到 $3$ 位小数（例如 $[\\!-3.200,0.000,\\dots]$）。", "solution": "任务是计算编码序列转录的RNA，在经过密码子优化程序后，其最小自由能（$\\Delta G$）的变化。该程序旨在用宿主生物体中最频繁（“偏好”）的同义密码子替换中高频率（“中性”）的密码子对。该解决方案包括两个主要部分：首先，实现密码子优化逻辑；其次，使用指定的动态规划算法为原始和优化后的RNA序列计算MFE代理值。\n\n首先，我们必须建立问题所需的数据结构。这包括将密码子映射到氨基酸的遗传密码、每个密码子 $c$ 的宿主密码子使用频率 $f(c)$，以及碱基配对能量 $E$。根据给定的频率，我们为每种氨基酸 $a$ 预先计算两个关键指标：最大同义密码子频率 $\\max_{c' \\in \\mathcal{C}(a)} f(c')$，以及相应的最优选密码子 $c^\\star$。然后按要求计算任何密码子 $c$ 的相对适应度 $w(c)$：\n$$\nw(c) = \\frac{f(c)}{\\max_{c' \\in \\mathcal{C}(a)} f(c')}\n$$\n其中 $a$ 是由 $c$ 编码的氨基酸。\n\n密码子优化算法流程如下。输入的DNA序列被解析为包含 $N$ 个密码子的序列 $(c_1, c_2, \\dots, c_N)$。这些密码子以不相交、非重叠的配对形式进行处理：$(c_1, c_2)$、$(c_3, c_4)$ 等。如果 $N$ 是奇数，最后一个密码子 $c_N$ 不属于任何配对，并保持不变。对于每个配对 $(c_i, c_{i+1})$，其中 $i$ 是从1开始的奇数索引，我们判断该配对是否为“中性”。如果两个密码子都是中性的，即它们的相对适应度值达到或超过给定的阈值 $\\theta$，则该配对被定义为中性：\n$$\nw(c_i) \\ge \\theta \\quad \\text{and} \\quad w(c_{i+1}) \\ge \\theta\n$$\n如果一个配对被确定为中性，它将被替换为宿主偏好的配对 $(c_i^\\star, c_{i+1}^\\star)$，其中 $c_i^\\star$ 是氨基酸 $a_i$（由 $c_i$ 编码）最频繁的密码子，而 $c_{i+1}^\\star$ 是氨基酸 $a_{i+1}$ 最频繁的密码子。如果配对不是中性的，则保持不变。此过程产生一个优化后的DNA序列，根据设计，该序列编码的氨基酸序列与原始序列完全相同。\n\n问题的第二部分是通过为RNA序列 $S$ 计算最小自由能（MFE）代理值 $G(S)$ 来量化此优化的结构影响。首先将DNA序列中所有出现的碱基 $\\mathrm{T}$ 替换为 $\\mathrm{U}$，从而转录为RNA。MFE代理值使用一种类似于用于RNA二级结构预测的Nussinov算法的动态规划方法计算。对于长度为 $L$ 的RNA序列 $S$，我们计算一个 $L \\times L$ 的矩阵 $D$，其中 $D[i,j]$ 存储子序列 $S[i..j]$ 的最小自由能。如规定的递推关系考虑了非交叉结构的所有可能性：一个碱基可以不配对，可以与另一个碱基形成配对，或者结构可以分叉成两个独立的子结构。形式上，对于 $0 \\le i  j  L$， $D[i,j]$ 的值由以下公式给出：\n$$\nD[i,j] = \\min \\Big\\{\n    D[i+1,j],\\;\n    D[i,j-1],\\;\n    D[i+1,j-1] + E(S[i],S[j]),\\;\n    \\min_{k=i}^{j-1} \\big( D[i,k] + D[k+1,j] \\big)\n\\Big\\}\n$$\n仅当碱基 $S[i]$ 和 $S[j]$ 之间的配对被允许时，才包含 $D[i+1,j-1] + E(S[i],S[j])$ 这一项。如果配对是Watson-Crick（$\\mathrm{AU}$, $\\mathrm{GC}$）或摆动（$\\mathrm{GU}$）对之一，并且满足最小发夹环长度约束 $j - i - 1 \\ge L_0$（其中 $L_0 = 3$），则允许配对。碱基配对能量 $E$ 如下：$E(\\mathrm{AU})=E(\\mathrm{UA})=-2.1$，$E(\\mathrm{GC})=E(\\mathrm{CG})=-3.4$，以及 $E(\\mathrm{GU})=E(\\mathrm{UG})=-0.9$，单位均为千卡/摩尔。递推的基础情况是对于所有 $i$，$D[i,i] = 0$，以及对于 $i > j$，$D[i,j] = 0$。整个序列 $S$ 的MFE代理值为 $G(S) = D[0,L-1]$。\n\n为解决每个测试用例，我们将此MFE计算应用于原始RNA序列 $S_{\\text{orig}}$ 和优化后的RNA序列 $S_{\\text{opt}}$，分别获得 $G(S_{\\text{orig}})$ 和 $G(S_{\\text{opt}})$。最终关注的量是MFE的变化量 $\\Delta G$，定义为：\n$$\n\\Delta G = G(S_{\\text{opt}}) - G(S_{\\text{orig}})\n$$\n结果以千卡/摩尔为单位报告，并四舍五入到3位小数。整个过程被封装在一个程序中，该程序迭代遍历所提供的测试套件。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the codon optimization and MFE calculation problem.\n    \"\"\"\n    # Define constants and data structures based on the problem statement.\n    genetic_code = {\n        'GCT': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',  # Alanine\n        'GGT': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G',  # Glycine\n        'GTT': 'V', 'GTC': 'V', 'GTA': 'V', 'GTG': 'V',  # Valine\n        'AAA': 'K', 'AAG': 'K',                          # Lysine\n        'GAA': 'E', 'GAG': 'E',                          # Glutamate\n        'ATG': 'M',                                      # Methionine\n    }\n\n    codon_usage = {\n        'A': {'GCT': 0.2, 'GCC': 0.5, 'GCA': 0.1, 'GCG': 0.2},\n        'G': {'GGT': 0.25, 'GGC': 0.45, 'GGA': 0.1, 'GGG': 0.2},\n        'V': {'GTT': 0.2, 'GTC': 0.2, 'GTA': 0.1, 'GTG': 0.5},\n        'K': {'AAA': 0.3, 'AAG': 0.7},\n        'E': {'GAA': 0.35, 'GAG': 0.65},\n        'M': {'ATG': 1.0},\n    }\n\n    pair_energies = {\n        'AU': -2.1, 'UA': -2.1,\n        'GC': -3.4, 'CG': -3.4,\n        'GU': -0.9, 'UG': -0.9,\n    }\n\n    L0 = 3\n\n    # Pre-calculate max frequencies and preferred codons for efficiency.\n    max_freqs = {aa: max(freqs.values()) for aa, freqs in codon_usage.items()}\n    preferred_codons = {\n        aa: max(freqs, key=freqs.get) for aa, freqs in codon_usage.items()\n    }\n\n    def calculate_mfe(dna_sequence: str) -> float:\n        \"\"\"\n        Calculates the MFE proxy for a given DNA sequence using the specified DP.\n        \"\"\"\n        rna = dna_sequence.replace('T', 'U')\n        L = len(rna)\n        if L == 0:\n            return 0.0\n\n        # Initialize DP table. Zeros handle base cases D[i,i] and D[i,j] for i>j.\n        dp = np.zeros((L, L))\n\n        # Iterate over subsequence length, l.\n        for l in range(2, L + 1):\n            # Iterate over start position, i.\n            for i in range(L - l + 1):\n                j = i + l - 1\n\n                # Term 1: i is unpaired.\n                term1 = dp[i + 1, j]\n\n                # Term 2: j is unpaired.\n                term2 = dp[i, j - 1]\n\n                # Term 3: i and j form a base pair.\n                term3 = float('inf')\n                pair = rna[i] + rna[j]\n                if j - i - 1 >= L0 and pair in pair_energies:\n                    energy = pair_energies[pair]\n                    # Interior loop energy. If i+1 > j-1, subproblem is empty, energy 0.\n                    sub_energy = dp[i + 1, j - 1] if i + 1 = j - 1 else 0.0\n                    term3 = energy + sub_energy\n\n                # Term 4: Bifurcation.\n                # Loop for k from i to j-1 to find the minimum energy split.\n                bifurcation_min = min(dp[i, k] + dp[k + 1, j] for k in range(i, j))\n                term4 = bifurcation_min\n\n                dp[i, j] = min(term1, term2, term3, term4)\n\n        return dp[0, L - 1]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"GCTGGTAAAGAA\", 0.4),\n        (\"GCCGGCAAGGAG\", 0.4),\n        (\"GCTGTGAAA\", 0.4),\n        (\"ATGGAA\", 0.4),\n        (\"GCTGGTAAAGAA\", 1.0),\n    ]\n\n    results = []\n    for dna, theta in test_cases:\n        # 1. Calculate MFE for the original sequence.\n        mfe_orig = calculate_mfe(dna)\n\n        # 2. Generate the optimized sequence.\n        codons = [dna[i:i+3] for i in range(0, len(dna), 3)]\n        num_codons = len(codons)\n        optimized_codons = list(codons)\n\n        # Iterate over non-overlapping pairs of codons.\n        for i in range(num_codons // 2):\n            idx1 = 2 * i\n            idx2 = 2 * i + 1\n            \n            c1 = codons[idx1]\n            c2 = codons[idx2]\n\n            aa1 = genetic_code[c1]\n            aa2 = genetic_code[c2]\n\n            w1 = codon_usage[aa1][c1] / max_freqs[aa1]\n            w2 = codon_usage[aa2][c2] / max_freqs[aa2]\n\n            # Check if the pair is neutral.\n            if w1 >= theta and w2 >= theta:\n                optimized_codons[idx1] = preferred_codons[aa1]\n                optimized_codons[idx2] = preferred_codons[aa2]\n\n        optimized_dna = \"\".join(optimized_codons)\n\n        # 3. Calculate MFE for the optimized sequence.\n        mfe_opt = calculate_mfe(optimized_dna)\n        \n        # 4. Compute the change in MFE, round, and store the result.\n        delta_g = mfe_opt - mfe_orig\n        results.append(delta_g)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.3f}' for r in results)}]\")\n\nsolve()\n```", "id": "2721468"}, {"introduction": "密码子使用对基因表达的影响并非一成不变，它会受到细胞生理状态（如生长条件）的显著影响，因为这些条件可以改变tRNA库的丰度和组成。这项最终练习将带您从计算机内的设计和预测转向数据分析，您将使用统计模型来分析假设的实验数据。通过这项练习，您将学习如何检验密码子优化效果的条件依赖性，这对于解释真实的实验结果和完善基因表达的预测模型至关重要[@problem_id:2721531]。", "problem": "给定两种细胞生长条件（条件A和条件B）下多个编码序列的成对观测数据：一个是密码子优适性得分（无量纲；例如，转运RNA适应指数（tAI）或密码子适应指数（CAI）等代理指标），另一个是测得的信使核糖核酸（mRNA）半衰期（单位为分钟）。从中心法则以及一个经过充分检验的观察（即受密码子优适性影响的翻译延伸动力学可以与mRNA降解途径耦合）出发，假设一个带有交互项的线性响应模型可以捕捉密码子优适性对稳定性影响的条件依赖性。您的任务是，对每个数据集，检验密码子优适性对mRNA半衰期的影响是否依赖于生长条件，并量化该交互项。\n\n使用的基本原理：\n- 中心法则（DNA → RNA → 蛋白质）以及翻译延伸与mRNA降解之间的耦合是经过充分检验的生物学观察。\n- 普通最小二乘法是通过最小化残差平方和来估计线性模型中未知系数的标准方法。\n\n您的程序必须：\n- 对于每个数据集，将两种条件合并到单一分析中，使用一个二元指示变量 $c \\in \\{0,1\\}$ 来表示条件（条件A使用 $c=0$，条件B使用 $c=1$），模型中包括一个截距、密码子优适性得分 $s$ 的主效应，以及一个乘积项 $s \\cdot c$ 以捕捉潜在的条件依赖斜率。\n- 使用普通最小二乘法估计交互作用系数（即与 $s \\cdot c$ 相乘的系数），并在交互作用系数等于 $0$ 的原假设下，计算其双侧 $t$ 检验的 $p$ 值。自由度使用 $n-p$，其中 $n$ 是观测数量， $p$ 是拟合系数的数量。\n- 使用显著性水平 $\\alpha = 0.05$（小数形式），如果 $p$ 值小于 $\\alpha$，则做出拒绝原假设的布尔决策。\n- 对于每个数据集，报告估计的交互作用系数（浮点数）、双侧 $p$ 值（浮点数）和布尔决策（布尔值）。\n\n物理和数值单位：\n- mRNA半衰期必须以分钟为单位处理。密码子优适性得分是无量纲的。估计的交互作用系数的单位是“分钟/单位密码子优适性得分”。$p$ 值和决策是无单位的。您必须仅输出原始数字和布尔值，不带任何单位标签。\n\n测试套件（三个数据集）：\n- 数据集 $1$（预期存在条件依赖效应）：\n  - 条件A：密码子得分 $s_A = [\\,0.2,\\,0.3,\\,0.5,\\,0.7,\\,0.9\\,]$，半衰期 $h_A$（分钟）$= [\\,3 + 2\\cdot 0.2 + 0.05,\\; 3 + 2\\cdot 0.3 - 0.03,\\; 3 + 2\\cdot 0.5 + 0.02,\\; 3 + 2\\cdot 0.7 - 0.04,\\; 3 + 2\\cdot 0.9 + 0.01\\,]$。\n  - 条件B：密码子得分 $s_B = [\\,0.2,\\,0.3,\\,0.5,\\,0.7,\\,0.9\\,]$，半衰期 $h_B$（分钟）$= [\\,4 + 3.5\\cdot 0.2 - 0.02,\\; 4 + 3.5\\cdot 0.3 + 0.01,\\; 4 + 3.5\\cdot 0.5 - 0.03,\\; 4 + 3.5\\cdot 0.7 + 0.04,\\; 4 + 3.5\\cdot 0.9 - 0.01\\,]$。\n- 数据集 $2$（预期无交互作用）：\n  - 条件A：密码子得分 $s_A = [\\,0.1,\\,0.25,\\,0.5,\\,0.75,\\,0.9,\\,0.95\\,]$，半衰期 $h_A$（分钟）$= [\\,4 + 1.5\\cdot 0.1 + 0.02,\\; 4 + 1.5\\cdot 0.25 - 0.01,\\; 4 + 1.5\\cdot 0.5 + 0.0,\\; 4 + 1.5\\cdot 0.75 - 0.02,\\; 4 + 1.5\\cdot 0.9 + 0.01,\\; 4 + 1.5\\cdot 0.95 - 0.03\\,]$。\n  - 条件B：密码子得分 $s_B = [\\,0.1,\\,0.25,\\,0.5,\\,0.75,\\,0.9,\\,0.95\\,]$，半衰期 $h_B$（分钟）$= [\\,4.5 + 1.5\\cdot 0.1 - 0.01,\\; 4.5 + 1.5\\cdot 0.25 + 0.02,\\; 4.5 + 1.5\\cdot 0.5 - 0.02,\\; 4.5 + 1.5\\cdot 0.75 + 0.01,\\; 4.5 + 1.5\\cdot 0.9 + 0.0,\\; 4.5 + 1.5\\cdot 0.95 + 0.01\\,]$。\n- 数据集 $3$（样本量小且条件B中斜率减小的边缘案例）：\n  - 条件A：密码子得分 $s_A = [\\,0.2,\\,0.8,\\,0.9\\,]$，半衰期 $h_A$（分钟）$= [\\,2 + 1\\cdot 0.2 + 0.01,\\; 2 + 1\\cdot 0.8 - 0.02,\\; 2 + 1\\cdot 0.9 + 0.03\\,]$。\n  - 条件B：密码子得分 $s_B = [\\,0.1,\\,0.4,\\,0.95\\,]$，半衰期 $h_B$（分钟）$= [\\,2 + 0\\cdot 0.1 - 0.01,\\; 2 + 0\\cdot 0.4 + 0.0,\\; 2 + 0\\cdot 0.95 + 0.02\\,]$。\n\n每个数据集所需的统计流程：\n- 构建包含截距、密码子得分 $s$、条件指示变量 $c$ 和交互项 $s\\cdot c$ 的组合设计。\n- 通过最小化残差平方和来估计系数。\n- 计算残差方差估计值、交互作用系数的标准误、$t$ 统计量，以及使用自由度为 $n-p$ 的学生t分布计算双侧 $p$ 值。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有数据集的结果，形式为用方括号括起来的逗号分隔列表。每个数据集的结果必须是 $[\\hat{\\beta}_{\\text{int}}, p, \\text{decision}]$ 的形式，其中 $\\hat{\\beta}_{\\text{int}}$ 是估计的交互作用系数，$p$ 是双侧 $p$ 值，$\\text{decision}$ 是一个布尔值，如果 $p  \\alpha$ 则为 $\\text{True}$，否则为 $\\text{False}$。将所有浮点数四舍五入到6位小数。例如，整体输出必须类似于 $[[x\\_1,y\\_1,z\\_1],[x\\_2,y\\_2,z\\_2],[x\\_3,y\\_3,z\\_3]]$。", "solution": "我们从中心法则（DNA转录为RNA，翻译为蛋白质）和经过充分检验的观察出发，即由密码子优适性调节的翻译延伸动力学，可以通过核糖体与降解机制之间的耦合影响信使核糖核酸（mRNA）的降解速率。因此，密码子优适性得分 $s$ 的增加可以提高翻译延伸速度，并在许多系统中稳定转录本，这意味着mRNA半衰期 $h$ 依赖于 $s$。环境或生长条件可以改变转运核糖核酸（tRNA）池或降解因子，从而可能改变 $s$ 到 $h$ 的映射关系。为了捕捉这种条件依赖性，我们假设一个带有密码子优适性得分和条件指示变量之间交互作用的线性响应。\n\n算法建模框架：\n- 对每个观测值 $i$，定义 $s_i$ 为密码子优适性得分，$c_i \\in \\{0,1\\}$ 为条件B的二元指示变量（条件A编码为 $c_i=0$）。令 $h_i$ 为测得的mRNA半衰期（单位：分钟）。\n- 考虑一个包含截距、主效应和交互项的线性模型：\n  $$ h_i = \\beta_0 + \\beta_s s_i + \\beta_c c_i + \\beta_{sc}\\, s_i c_i + \\varepsilon_i, $$\n  其中 $\\varepsilon_i$ 是均值为零、方差有限的独立噪声项，而 $\\beta_{sc}$ 量化了将 $s$ 与 $h$ 关联的斜率的条件依赖性。\n- 将所有 $n$ 个观测值堆叠成矩阵形式：\n  $$ \\mathbf{h} = \\mathbf{X}\\boldsymbol{\\beta} + \\boldsymbol{\\varepsilon}, $$\n  其中 $\\mathbf{h}\\in\\mathbb{R}^{n}$，$\\boldsymbol{\\beta} = [\\beta_0,\\beta_s,\\beta_c,\\beta_{sc}]^\\top \\in \\mathbb{R}^{4}$，以及\n  $$ \\mathbf{X} = \\begin{bmatrix}\n  1  s_1  c_1  s_1 c_1\\\\\n  \\vdots  \\vdots  \\vdots  \\vdots\\\\\n  1  s_n  c_n  s_n c_n\n  \\end{bmatrix}. $$\n- 通过普通最小二乘法（OLS）估计系数，该方法最小化残差平方和 $S(\\boldsymbol{\\beta}) = \\|\\mathbf{h} - \\mathbf{X}\\boldsymbol{\\beta}\\|_2^2$。OLS估计值为\n  $$ \\hat{\\boldsymbol{\\beta}} = (\\mathbf{X}^\\top \\mathbf{X})^{-1}\\mathbf{X}^\\top \\mathbf{h}, $$\n  假设 $\\mathbf{X}$ 具有满列秩。\n- 计算拟合值 $\\hat{\\mathbf{h}} = \\mathbf{X}\\hat{\\boldsymbol{\\beta}}$ 和残差 $\\hat{\\boldsymbol{\\varepsilon}} = \\mathbf{h} - \\hat{\\mathbf{h}}$。令 $p=4$ 为参数数量。无偏残差方差估计量为\n  $$ \\hat{\\sigma}^2 = \\frac{\\hat{\\boldsymbol{\\varepsilon}}^\\top \\hat{\\boldsymbol{\\varepsilon}}}{n-p}. $$\n- 在常规OLS假设下，$\\hat{\\boldsymbol{\\beta}}$ 的协方差矩阵为\n  $$ \\widehat{\\mathrm{Cov}}(\\hat{\\boldsymbol{\\beta}}) = \\hat{\\sigma}^2 (\\mathbf{X}^\\top \\mathbf{X})^{-1}. $$\n  交互作用系数的标准误是\n  $$ \\mathrm{SE}(\\hat{\\beta}_{sc}) = \\sqrt{\\left[\\widehat{\\mathrm{Cov}}(\\hat{\\boldsymbol{\\beta}})\\right]_{4,4}}. $$\n- 为检验原假设 $H_0:\\ \\beta_{sc}=0$ 对双侧备择假设 $H_1:\\ \\beta_{sc}\\neq 0$，使用 $t$ 统计量\n  $$ t = \\frac{\\hat{\\beta}_{sc}}{\\mathrm{SE}(\\hat{\\beta}_{sc})}, $$\n  在 $H_0$ 和标准OLS假设下，该统计量服从自由度为 $n-p$ 的学生t分布。双侧 $p$ 值为\n  $$ p = 2\\left(1 - F_{t,n-p}(|t|)\\right), $$\n  其中 $F_{t,\\nu}$ 是自由度为 $\\nu$ 的 $t$ 分布的累积分布函数。\n- 设定显著性水平 $\\alpha = 0.05$，如果 $p  \\alpha$，则拒绝 $H_0$。该决策以布尔值形式返回。\n\n应用于测试套件的实现细节：\n- 对于每个数据集，通过串联条件A和条件B的观测数据来构建组合设计矩阵。将所有条件A行的 $c$ 设为0，所有条件B行的 $c$ 设为1。构建列 $[1, s, c, s\\cdot c]$，估计 $\\hat{\\boldsymbol{\\beta}}$，计算 $\\hat{\\sigma}^2$，提取 $\\hat{\\beta}_{sc}$ 及其标准误，形成 $t$ 统计量，用 $n-p$ 的自由度计算双侧 $p$ 值，并与 $\\alpha=0.05$ 进行比较。\n- 对每个数据集，返回三元组 $[\\hat{\\beta}_{\\text{int}}, p, \\text{decision}]$，其中 $\\hat{\\beta}_{\\text{int}} \\equiv \\hat{\\beta}_{sc}$，并将 $\\hat{\\beta}_{\\text{int}}$ 和 $p$ 四舍五入到6位小数。\n\n此流程量化了密码子优适性对mRNA稳定性的影响是否具有条件依赖性（非零的 $\\hat{\\beta}_{sc}$），并提供了一个基于最小二乘估计和 $t$ 分布推断的严格统计检验。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import t as student_t\n\ndef ols_interaction_test(s_A, h_A, s_B, h_B, alpha=0.05):\n    \"\"\"\n    Fit OLS with intercept, s, c, s*c and test interaction coefficient.\n    Returns (beta_interaction, p_value, decision_bool).\n    \"\"\"\n    # Prepare data\n    s_A = np.asarray(s_A, dtype=float)\n    h_A = np.asarray(h_A, dtype=float)\n    s_B = np.asarray(s_B, dtype=float)\n    h_B = np.asarray(h_B, dtype=float)\n\n    # Concatenate\n    s = np.concatenate([s_A, s_B])\n    h = np.concatenate([h_A, h_B])\n    c = np.concatenate([np.zeros_like(s_A), np.ones_like(s_B)])\n\n    # Design matrix: [1, s, c, s*c]\n    X = np.column_stack([np.ones_like(s), s, c, s * c])\n    n, p = X.shape\n\n    # OLS estimates\n    # Compute (X^T X)^{-1} X^T h robustly\n    XtX = X.T @ X\n    XtX_inv = np.linalg.inv(XtX)\n    beta_hat = XtX_inv @ (X.T @ h)\n\n    # Residuals and variance estimate\n    h_hat = X @ beta_hat\n    resid = h - h_hat\n    dof = n - p\n    # Guard against division by zero if dof = 0 (should not occur with provided tests)\n    sigma2_hat = (resid @ resid) / dof\n\n    # Standard errors\n    cov_beta = sigma2_hat * XtX_inv\n    se_beta = np.sqrt(np.diag(cov_beta))\n\n    # Interaction coefficient is the 4th parameter\n    beta_int = beta_hat[3]\n    se_int = se_beta[3]\n\n    # t-statistic and two-sided p-value\n    t_stat = beta_int / se_int\n    p_value = 2.0 * (1.0 - student_t.cdf(np.abs(t_stat), df=dof))\n\n    decision = bool(p_value  alpha)\n    # Round floats to 6 decimals\n    beta_int_r = round(float(beta_int), 6)\n    p_value_r = round(float(p_value), 6)\n    return [beta_int_r, p_value_r, decision]\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Dataset 1\n    sA1 = [0.2, 0.3, 0.5, 0.7, 0.9]\n    hA1 = [3 + 2*0.2 + 0.05,\n           3 + 2*0.3 - 0.03,\n           3 + 2*0.5 + 0.02,\n           3 + 2*0.7 - 0.04,\n           3 + 2*0.9 + 0.01]\n    sB1 = [0.2, 0.3, 0.5, 0.7, 0.9]\n    hB1 = [4 + 3.5*0.2 - 0.02,\n           4 + 3.5*0.3 + 0.01,\n           4 + 3.5*0.5 - 0.03,\n           4 + 3.5*0.7 + 0.04,\n           4 + 3.5*0.9 - 0.01]\n\n    # Dataset 2\n    sA2 = [0.1, 0.25, 0.5, 0.75, 0.9, 0.95]\n    hA2 = [4 + 1.5*0.1 + 0.02,\n           4 + 1.5*0.25 - 0.01,\n           4 + 1.5*0.5 + 0.0,\n           4 + 1.5*0.75 - 0.02,\n           4 + 1.5*0.9 + 0.01,\n           4 + 1.5*0.95 - 0.03]\n    sB2 = [0.1, 0.25, 0.5, 0.75, 0.9, 0.95]\n    hB2 = [4.5 + 1.5*0.1 - 0.01,\n           4.5 + 1.5*0.25 + 0.02,\n           4.5 + 1.5*0.5 - 0.02,\n           4.5 + 1.5*0.75 + 0.01,\n           4.5 + 1.5*0.9 + 0.0,\n           4.5 + 1.5*0.95 + 0.01]\n\n    # Dataset 3\n    sA3 = [0.2, 0.8, 0.9]\n    hA3 = [2 + 1*0.2 + 0.01,\n           2 + 1*0.8 - 0.02,\n           2 + 1*0.9 + 0.03]\n    sB3 = [0.1, 0.4, 0.95]\n    hB3 = [2 + 0*0.1 - 0.01,\n           2 + 0*0.4 + 0.0,\n           2 + 0*0.95 + 0.02]\n\n    alpha = 0.05\n\n    test_cases = [\n        (sA1, hA1, sB1, hB1, alpha),\n        (sA2, hA2, sB2, hB2, alpha),\n        (sA3, hA3, sB3, hB3, alpha),\n    ]\n\n    results = []\n    for sA, hA, sB, hB, a in test_cases:\n        result = ols_interaction_test(sA, hA, sB, hB, alpha=a)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # It should be a single line: [[b1,p1,dec1],[b2,p2,dec2],[b3,p3,dec3]]\n    def format_item(x):\n        if isinstance(x, bool):\n            return \"True\" if x else \"False\"\n        else:\n            return str(x)\n\n    formatted = \"[\" + \",\".join(\n        \"[\" + \",\".join(format_item(x) for x in res) + \"]\" for res in results\n    ) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2721531"}]}