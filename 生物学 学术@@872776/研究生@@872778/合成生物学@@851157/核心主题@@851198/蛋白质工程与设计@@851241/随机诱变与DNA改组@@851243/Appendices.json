{"hands_on_practices": [{"introduction": "在深入研究具体的实验室技术之前，合成生物学家必须做出一个战略性选择：是采用理性设计还是定向进化。这个选择取决于我们对目标蛋白质的结构和功能的现有知识。本练习 [@problem_id:2108796] 阐明了指导这一关键决策的基本原则，帮助您理解何时以及为何应采用像定向进化这样的“黑箱”搜索策略。", "problem": "一组生物化学家在一种南极细菌中发现了一种新蛋白质，他们将其命名为“Cryopro”。该蛋白质的氨基酸序列已被确定，但它与现有数据库中任何具有已知三维结构或生物功能的蛋白质都没有显著的相似性。该团队的目标是改造Cryopro，使其能高特异性地结合一种与冰晶造成的细胞损伤相关的小分子生物标志物。他们必须在两种主要的蛋白质工程策略之间做出选择：理性设计或定向进化（例如，使用酵母展示或噬菌体展示等方法）。\n\n以下哪个陈述提出了在这种特定情况下，定向进化方法比理性设计方法更合适的根本原因？\n\nA. 理性设计基于计算算法，而这些算法对于源自南极细菌等嗜极生物的蛋白质来说是众所周知不准确的。\n\nB. 定向进化在本质上更优越，因为它模仿了自然选择的过程，而自然选择总是能产生比人类设计的蛋白质更稳定、活性更高的蛋白质。\n\nC. 理性设计需要预先了解蛋白质的三维结构和/或一个被充分理解的作用机制，以便进行有针对性的、有目的的突变，而对于Cryopro来说，这些信息完全缺乏。\n\nD. 像酵母展示这样的定向进化方法是必要的，因为它们是唯一能够将突变引入蛋白质遗传密码的技术；而理性设计是通过化学修饰蛋白质本身来工作的。\n\nE. 理性设计中计算模拟所需的高昂成本和专业设备使其对于学术研究实验室来说不切实际，这些实验室通常更青睐成本较低的定向进化。", "solution": "我们通过分析每种方法的信息需求和方法论原则，来评估在给定约束条件下理性设计与定向进化的适用性。\n\n理性设计依赖于基于结构-功能关系的明确假设来进行有针对性的序列改变。其核心先决条件是先验知识，例如高分辨率的三维结构、经过验证的结合口袋，或者至少是一个将特定残基或基序与所需功能联系起来的、被充分理解的机理模型。在缺乏结构同源性且Cryopro作用机制未知的情况下，没有可靠的基础来假设哪些突变会增强与该生物标志物的结合。如果没有这些信息，理性设计就变成了猜测，而不是有原则的工程。\n\n相比之下，定向进化不需要先验的结构或机理知识。它利用基因型-表型连锁和选择，在序列空间中凭经验搜索具有所需功能（例如，结合特异性）的变体，从而通过迭代的多样化和选择来发现有益的突变。当起始信息极少时（如此处的情况），这一点尤其有利。\n\n选项A不是一个根本原因：理性设计并非完全是计算性的，并且嗜极生物的来源不会绝对地使计算模型失效。选项B是错误的：定向进化并非天生优越，也并非总能产生更稳定或活性更高的蛋白质。选项D是错误的：理性设计和定向进化都是引入基因突变；理性设计并不局限于对蛋白质进行化学修饰。选项E诉诸于成本而非核心的方法论局限性，并且不是最根本的原因。\n\n因此，最根本的原因是理性设计需要Cryopro所缺乏的结构和/或机理知识，这使得定向进化在这种情况下更为合适。", "answer": "$$\\boxed{C}$$", "id": "2108796"}, {"introduction": "一旦确定采用定向进化策略，下一步便是有效地产生遗传多样性。本问题聚焦于饱和突变，这是一种旨在详尽探索单个关键氨基酸位置功能潜力的强大技术。通过解决这个场景 [@problem_id:2108788]，您将学会如何根据具体的工程目标，选择最合适的分子工具来构建一个高度集中的突变体文库。", "problem": "一位蛋白质工程师正在研究一种新型酶的催化机制。通过结构分析，他们假设位于第88位的特定色氨酸残基（Trp88）在底物结合中起着关键作用。为了通过实验检验这一假设，该工程师旨在创建一个全面的突变文库，其中Trp88残基被系统地替换为所有其他19种标准的蛋白质氨基酸。然后，这个基因变体文库将被表达，并筛选所得蛋白质的结合亲和力。\n\n以下哪种分子生物学技术是构建所述基因文库最直接、最有效的方法？\n\nA. 对整个基因进行易错聚合酶链式反应（PCR）。\n\nB. 使用单一、特异性的非简并引物对进行定点突变，将Trp88的密码子更改为丙氨酸的密码子。\n\nC. 使用野生型基因和一组来自相关物种的同源基因进行DNA改组。\n\nD. 使用在对应于88位残基的位置包含“NNK”密码子的简并引物进行定点突变。\n\nE. 使用基于转座子的系统进行随机插入突变。", "solution": "目标：构建一个集中的文库，其中一个单一密码子（Trp88的密码子）被多样化，以编码所有$19$种其他标准氨基酸，并且这种多样化是高效、直接地在该位点上实现的。\n\n根据目标评估每个选项：\n- 选项A（易错PCR）：易错PCR在整个基因中引入随机点突变，其突变率可调但分布不均。它并非针对单个密码子，并且会引入许多脱靶突变，产生一个异质文库，对于分离88位残基上特定的$19$种单点替换组合来说效率低下。因此，对于这个特定的文库，它不是最直接或最有效的方法。\n\n- 选项B（使用非简并引物定点突变为丙氨酸）：这会产生一个单一的特异性替换（Trp88到Ala88）。它无法一步生成全部$19$种替换，因此不适合创建全面的文库。\n\n- 选项C（DNA改组）：DNA改组重组同源序列，以在相关序列中重新分配现有的突变。它并非设计用于在野生型基因的特定密码子上引入所有$19$种替换，因此不会直接产生集中的单点变体集合。\n\n- 选项D（使用含有NNK密码子的简并引物在88位残基进行定点突变）：在寡核苷酸表示法中，$N$ 代表任何核苷酸，$K$ 代表 $G$ 或 $T$。一个NNK密码子（$4 \\times 4 \\times 2 = 32$ 个密码子）可以覆盖所有$20$种标准氨基酸，并且包含的终止密码子最少。具体来说，在终止密码子（TAA、TAG、TGA）中，只有TAG符合NNK（第三个碱基为$G$），因此终止密码子的比例被最小化。使用在Trp88密码子位置精确带有NNK的简并引物，可以生成一个集中的文库，该文库包含该位置的所有单密码子变体，高效地覆盖所有$19$种非色氨酸氨基酸（通常也包括原始的色氨酸），同时在其他位置的不必要多样化最小。这是在单个位点进行饱和突变的标准、最直接的方法。\n\n- 选项E（使用转座子进行随机插入突变）：这会在随机位置产生插入，通常会导致移码或破坏性插入，而不是单密码子替换。它无法生成所需的单点替换文库。\n\n结论：在88位残基构建全面的单点饱和文库最直接、最有效的方法是使用在目标位置带有简并NNK密码子的定点突变。\n\n因此，正确选项是D。", "answer": "$$\\boxed{D}$$", "id": "2108788"}, {"introduction": "除了引入点突变，DNA shuffling 技术通过重组多个亲本基因的片段，能够创造出结构新颖的嵌合蛋白库。然而，预测哪些嵌合体能够正确折叠并保持功能是一个核心挑战，SCHEMA 算法为此提供了一个强大的计算启发式框架，用以评估重组带来的结构“破坏”程度。这项高级计算练习 [@problem_id:2767666] 要求您将生物学理论转化为定量模拟，从而深入理解如何利用计算工具来指导和优化复杂的文库设计。", "problem": "给定对齐的亲本氨基酸序列和残基-残基接触图，该接触图定义了蛋白质结构中哪些位置存在物理相互作用。目标是将脱氧核糖核酸（DNA）改组建模为随机交叉重组，并通过模拟凭经验表征SCHEMA破坏能量在随机交叉点放置下的分布。然后，您必须报告该破坏能量分布的指定百分位数阈值，以用于选择决策。\n\n背景和定义：\n- 中心法则确立了序列决定结构，结构制约功能。在同源蛋白质的重组中，嵌合体是通过在亲本序列之间交换连续的序列片段而形成的。\n- 接触图是在天然蛋白质折叠中空间上邻近的残基索引的无向对集合。设对齐的序列长度为 $L$，接触集为 $C \\subset \\{1,\\dots,L\\} \\times \\{1,\\dots,L\\}$，其中 $(i,j) \\in C$ 表示位置 $i$ 和 $j$ 之间存在接触，且 $i \\neq j$。\n- SCHEMA破坏能量（通常写作 $E$）在此定义为嵌合体中相互作用的残基源自不同亲本的接触数量。形式上，令 $p_\\ell \\in \\{1,\\dots,K\\}$ 表示在嵌合体中提供位置 $\\ell$ 处残基的亲本索引，其中 $K$ 是亲本数量。那么\n$$\nE \\;=\\; \\sum_{(i,j)\\in C} \\mathbf{1}\\{p_i \\neq p_j\\},\n$$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。这个定义反映了一个启发式思想：当两个残基都共同遗传自同一个亲本时，共同适应的接触对得以保留，否则就被破坏。\n\n随机重组模型：\n- 给定 $K$ 个长度均为 $L$ 的对齐亲本序列。\n- 通过在 $L-1$ 个可能的残基间边界 $\\{1,2,\\dots,L-1\\}$ 中无放回地随机均匀放置 $c$ 个交叉点来构建嵌合体，然后对这些交叉点进行排序，将序列划分为 $c+1$ 个连续的区块。\n- 第一个区块的亲本从 $\\{1,\\dots,K\\}$ 中均匀选择。在每个交叉点处，下一个区块的亲本从与当前区块亲本不同的 $K-1$ 个亲本中均匀选择（不允许立即重复）。\n- 对于给定的嵌合体，使用上述方程从亲本来源谱 $(p_1,\\dots,p_L)$ 和接触集 $C$ 精确计算 $E$。\n- 为表征给定参数集下 $E$ 的分布，使用上述模型和固定的伪随机数种子模拟 $n$ 个独立的嵌合体以确保可复现性。通过应用与NumPy的“linear”方法一致的线性插值经验分位数函数来估计所请求的分位数阈值。\n\n百分位数定义和四舍五入：\n- 对于给定的分位数水平列表 $\\{q_1,\\dots,q_m\\}$，其中每个 $q_r \\in [0,1]$ 以小数形式给出，使用线性插值计算采样得到的 $E$ 值的经验分位数。报告每个阈值，四舍五入到三位小数。\n\n不涉及角度或物理单位；所有报告的量都是无量纲的计数。最终输出必须是四舍五入到三位小数的浮点数。\n\n测试套件：\n实现一个程序来解决以下三个测试用例。对于所有用例，下面的接触索引是基于1的；您的实现可以在内部将其转换为基于0的索引。\n\n- 测试用例1（通用多亲本，中等交叉数）：\n  - 亲本（$K=3$, $L=14$）：\n    - 亲本1：\"MKTLYDNNRVAIQL\"\n    - 亲本2：\"MKTLYENNKIAVQL\"\n    - 亲本3：\"MRTLYDGNKIAVAL\"\n  - 接触 $C$（对）：$(1,4)$, $(2,5)$, $(3,6)$, $(4,7)$, $(5,8)$, $(6,9)$, $(7,10)$, $(8,11)$, $(9,12)$, $(10,13)$, $(11,14)$, $(2,10)$, $(3,11)$, $(5,12)$, $(6,14)$。\n  - 交叉数 $c=4$。\n  - 模拟的嵌合体数量 $n=8000$。\n  - 要报告的分位数 $\\{0.1,0.5,0.9\\}$。\n  - 随机种子 $=123456$。\n\n- 测试用例2（边界情况：零交叉）：\n  - 亲本和接触：与测试用例1相同。\n  - 交叉数 $c=0$。\n  - 模拟的嵌合体数量 $n=4000$。\n  - 要报告的分位数 $\\{0.25,0.5,0.75\\}$。\n  - 随机种子 $=2024$。\n\n- 测试用例3（两个亲本，多次交叉）：\n  - 亲本（$K=2$, $L=20$）：\n    - 亲本1：\"MKKTAIAALAGLVAGFAQDN\"\n    - 亲本2：\"MKETAIAALVGIVAGFAQEN\"\n  - 接触 $C$（对）：$(1,4)$, $(2,5)$, $(3,6)$, $(4,7)$, $(5,8)$, $(6,9)$, $(7,10)$, $(8,11)$, $(9,12)$, $(10,13)$, $(11,14)$, $(12,15)$, $(13,16)$, $(14,17)$, $(15,18)$, $(16,19)$, $(17,20)$, $(5,15)$, $(6,16)$, $(7,17)$, $(8,18)$, $(9,19)$, $(10,20)$。\n  - 交叉数 $c=9$。\n  - 模拟的嵌合体数量 $n=6000$。\n  - 要报告的分位数 $\\{0.05,0.5,0.95\\}$。\n  - 随机种子 $=777$。\n\n程序要求：\n- 您的程序必须完全按照规定实现随机过程，并使用提供的种子以确保可复现性。\n- 按顺序为每个测试用例计算 $n$ 个模拟嵌合体上 $E$ 分布的所请求分位数阈值，并将每个值四舍五入到三位小数。\n- 最终输出格式：一行包含一个逗号分隔的扁平列表，其中包含三个测试用例的所有分位数阈值，顺序与上面列出的测试用例及其分位数一致，并用方括号括起来。例如，如果测试用例1产生三个阈值 $t_{1,1},t_{1,2},t_{1,3}$，测试用例2产生 $t_{2,1},t_{2,2},t_{2,3}$，测试用例3产生 $t_{3,1},t_{3,2},t_{3,3}$，您的程序必须打印“[t_{1,1},t_{1,2},t_{1,3},t_{2,1},t_{2,2},t_{2,3},t_{3,1},t_{3,2},t_{3,3}]”，每个值都四舍五入到三位小数，且没有额外的空白字符。", "solution": "问题陈述是一个有效且定义明确的计算生物学问题。它要求对蛋白质重组的随机模型进行模拟，并随后对一个启发式能量函数进行统计分析。所有参数和定义都以足够的精度提供，以构建一个唯一且可复现的解决方案。\n\n该问题要求表征由DNA改组模型产生的SCHEMA破坏能量（表示为 $E$）的分布。这是通过模拟 $n$ 个嵌合序列的创建并为每个序列计算 $E$ 来实现的。最终目标是报告所得 $E$ 的经验分布的特定分位数。整个过程将针对三个不同的测试用例进行实现。\n\n解决方案的核心是随机模拟。对于每个测试用例，由亲本数 $K$、序列长度 $L$、接触集 $C$、交叉数 $c$、模拟次数 $n$ 和一个随机种子指定，执行以下步骤：\n\n1.  **初始化**：使用指定的种子初始化伪随机数生成器以确保可复现性。将以基于1的索引给出的接触图 $C$ 转换为基于0的索引以便于计算。准备一个数组来存储 $n$ 个计算出的能量值。\n\n2.  **嵌合体模拟与能量计算**：执行一个循环 $n$ 次。在每次迭代中，对一个嵌合序列进行建模，并计算其破坏能量 $E$。\n\n    a.  **亲本来源谱生成**：嵌合体由一个亲本来源向量 $\\mathbf{p} = (p_0, p_1, \\dots, p_{L-1})$ 表示，其中每个元素 $p_i \\in \\{1, \\dots, K\\}$ 指示位置 $i$ 处的残基遗传自哪个亲本。该向量的构建方法如下：\n        -   首先，从 $L-1$ 个可能的残基间边界中无放回地随机均匀选择 $c$ 个唯一的交叉位置。对这些位置进行排序，将序列划分为 $c+1$ 个连续的区块。\n        -   第一个区块（从索引 $0$ 到第一个交叉点）的亲本从 $K$ 个亲本的集合中随机均匀选择。\n        -   对于每个后续区块，从与紧邻前一个区块的亲本不同的 $K-1$ 个亲本集合中随机均匀选择一个亲本。此过程定义了完整的亲本来源向量 $\\mathbf{p}$。\n        -   当 $c=0$ 时存在一个特殊情况。在这种情况下，不发生交叉，整个序列都遗传自一个随机选择的单一亲本。\n\n    b.  **SCHEMA破坏能量（$E$）计算**：一旦确定了亲本来源谱 $\\mathbf{p}$，就使用提供的公式计算SCHEMA破坏能量 $E$：\n        $$ E \\;=\\; \\sum_{(i,j)\\in C} \\mathbf{1}\\{p_i \\neq p_j\\} $$\n        其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数，如果条件为真则为 $1$，否则为 $0$。这个总和计算了蛋白质结构中两个相互作用的残基源自不同亲本的接触数量。为提高计算效率，此计算被向量化。通过比较所有接触对 $(i,j)$ 的亲本索引创建一个布尔掩码，能量 $E$ 就是这个掩码的总和。\n\n3.  **统计分析**：完成所有 $n$ 次模拟后，收集到的 $n$ 个能量值列表构成了 $E$ 的一个经验分布。问题要求从这个分布中估计特定的分位数 $\\{q_1, \\dots, q_m\\}$。这是通过使用 `numpy.quantile` 函数完成的，该函数实现了指定的线性插值方法（`interpolation='linear'`）。该方法精确计算给定分位数处的值，如果分位数落在两个最近的数据点之间，则在这两点之间进行插值。\n\n4.  **最终输出**：将每个测试用例计算出的分位数四舍五入到三位小数。然后将这三个测试用例的所有值汇总成一个单一的扁平列表。最终输出是此列表的字符串表示，格式完全按照规定：用方括号括起来，元素之间用逗号分隔。\n\n$c=0$ 的特殊情况（测试用例2）作为一个重要的合理性检查。在零交叉的情况下，任何嵌合体的亲本来源谱 $\\mathbf{p}$ 都将由一个重复 $L$ 次的单一亲本索引组成。因此，对于任何接触 $(i,j)$，$p_i$ 将始终等于 $p_j$，使得破坏能量 $E = \\sum \\mathbf{1}\\{p_i \\neq p_j\\} = \\sum 0 = 0$。这对所有 $n$ 次模拟都成立。因此，$E$ 的经验分布是在 $0$ 处的狄拉克δ函数，该分布的任何分位数也必须是 $0$。实现必须正确地复现这个确定性结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DNA shuffling simulation problem for the three specified test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"K\": 3, \"L\": 14,\n            \"contacts\": [(1,4), (2,5), (3,6), (4,7), (5,8), (6,9), (7,10), (8,11), (9,12), (10,13), (11,14), (2,10), (3,11), (5,12), (6,14)],\n            \"c\": 4, \"n\": 8000,\n            \"quantiles\": [0.1, 0.5, 0.9],\n            \"seed\": 123456\n        },\n        {\n            \"K\": 3, \"L\": 14,\n            \"contacts\": [(1,4), (2,5), (3,6), (4,7), (5,8), (6,9), (7,10), (8,11), (9,12), (10,13), (11,14), (2,10), (3,11), (5,12), (6,14)],\n            \"c\": 0, \"n\": 4000,\n            \"quantiles\": [0.25, 0.5, 0.75],\n            \"seed\": 2024\n        },\n        {\n            \"K\": 2, \"L\": 20,\n            \"contacts\": [(1,4), (2,5), (3,6), (4,7), (5,8), (6,9), (7,10), (8,11), (9,12), (10,13), (11,14), (12,15), (13,16), (14,17), (15,18), (16,19), (17,20), (5,15), (6,16), (7,17), (8,18), (9,19), (10,20)],\n            \"c\": 9, \"n\": 6000,\n            \"quantiles\": [0.05, 0.5, 0.95],\n            \"seed\": 777\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        K, L, contacts_1based, c, n, quantiles, seed = case.values()\n        \n        # Initialize the random number generator for reproducibility\n        rng = np.random.default_rng(seed)\n\n        # Convert 1-based contact indices to 0-based for array access\n        # and pre-calculate vectors of i and j indices for contacts\n        contacts_0based = np.array(contacts_1based) - 1\n        contacts_i = contacts_0based[:, 0]\n        contacts_j = contacts_0based[:, 1]\n        \n        # Array to store the SCHEMA disruption energies for n simulations\n        E_samples = np.empty(n, dtype=np.int16)\n\n        # Pre-generate parent choice sets\n        all_possible_parents = np.arange(1, K + 1)\n\n        for i in range(n):\n            # Generate one chimera and calculate its disruption energy\n            parent_profile = np.empty(L, dtype=np.int8)\n\n            if c == 0:\n                # With zero crossovers, the whole sequence has one parent\n                parent = rng.integers(1, K + 1)\n                parent_profile.fill(parent)\n            else:\n                # Choose c unique crossover locations from L-1 possibilities\n                crossover_locs = rng.choice(L - 1, size=c, replace=False)\n                crossover_locs.sort()\n                \n                # Define block boundaries (start inclusive, end exclusive)\n                boundaries = np.concatenate(([0], crossover_locs + 1, [L]))\n\n                # Assign parents to blocks sequentially\n                current_parent = rng.choice(all_possible_parents)\n                \n                for j in range(c + 1):\n                    start, end = boundaries[j], boundaries[j+1]\n                    parent_profile[start:end] = current_parent\n                    \n                    # For the next block, choose a different parent\n                    if j  c: # No need to choose a next parent after the last block\n                        if K > 1:\n                            # Choose from parents that are not the current one\n                            parent_choices = all_possible_parents[all_possible_parents != current_parent]\n                            current_parent = rng.choice(parent_choices)\n                        # If K=1, parent remains the same (though c>0, K=1 is ill-defined)\n            \n            # Vectorized calculation of SCHEMA disruption energy\n            parents_at_i = parent_profile[contacts_i]\n            parents_at_j = parent_profile[contacts_j]\n            energy = np.sum(parents_at_i != parents_at_j)\n            E_samples[i] = energy\n\n        # Calculate empirical quantiles using linear interpolation\n        calculated_quantiles = np.quantile(E_samples, quantiles, interpolation='linear')\n        \n        # Round results to three decimal places and add to the final list\n        all_results.extend(np.round(calculated_quantiles, 3))\n\n    # Format and print the final output string\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "2767666"}]}