{"hands_on_practices": [{"introduction": "在生物物理学中，一项基本技能是从实验数据中量化蛋白质的稳定性。本练习 [@problem_id:2765810] 提供了一个实践指南，指导您如何获取化学变性实验（一种常用技术）的数据，并将其拟合到双态折叠模型中。这个过程将理论与实践联系起来，培养了非线性最小二乘法拟合和误差分析的技能，以提取关键的热力学参数，如水中的折叠自由能 $\\Delta G_{\\mathrm{H_2O}}$ 和 $m$ 值。", "problem": "一个处于恒温状态的双态蛋白质折叠系统，被浓度为 $[D]$ (单位为 $\\mathrm{M}$) 的变性剂化学变性。观测到的量是在每个 $[D]$ 处独立测量的天然构象系综的分数 $f_N([D])$。从以下基本原理出发：(i) 平衡常数 $K = \\exp(-\\Delta G / (R T))$ 的热力学定义，它通过玻尔兹曼因子将去折叠与天然构象系综之间的吉布斯自由能差 $\\Delta G$ 与平衡常数联系起来；(ii) 从配分函数出发的双态系统中状态分数的定义；以及 (iii) 在低至中等浓度变性剂条件下，经验性的线性变性剂依赖关系 $\\Delta G([D]) = \\Delta G_{\\mathrm{H_2O}} - m [D]$。基于这些原理，推导出用 $\\Delta G_{\\mathrm{H_2O}}$ (单位 $\\mathrm{kJ/mol}$)、$m$ (单位 $\\mathrm{kJ/mol/M}$)、气体常数 $R$ (单位 $\\mathrm{kJ/(mol\\cdot K)}$) 和绝对温度 $T$ (单位 $\\mathrm{K}$) 来预测 $f_N([D])$ 的正向模型。构建一个非线性最小二乘目标函数，通过最小化测量的 $f_N([D])$ 与模型预测值之间的残差平方和来估计 $\\Delta G_{\\mathrm{H_2O}}$ 和 $m$。对所有数据点使用相等权重。通过在最优点附近的线性误差传播，从残差中估计拟合参数的不确定度（标准误差）：计算残差相对于参数在最优点处的雅可比矩阵，使用残差方差估计量 $\\hat{\\sigma}^2 = \\mathrm{RSS}/(n - p)$，其中 $n$ 是数据点数量，$p$ 是拟合参数数量，并构建参数协方差矩阵 $\\hat{\\sigma}^2 (J^\\top J)^{-1}$；如果 $J^\\top J$ 是病态的，则使用 Moore–Penrose 伪逆。将参数标准误差报告为该协方差矩阵对角线元素的平方根。约束 $m \\ge 0$。\n\n假设温度 $T = 298.15$ $\\mathrm{K}$，气体常数 $R = 0.008314462618$ $\\mathrm{kJ/(mol\\cdot K)}$。对于以下三个测试用例，提供了变性剂浓度 $[D]$ (单位 $\\mathrm{M}$) 和测量的分数 $f_N$ (无量纲)。所有 $f_N$ 值均为独立测量值。\n\n- 用例 A (宽转变):\n  $[D] = [0.0, 1.0, 2.0, 3.0, 4.0, 4.5, 5.0, 6.0, 7.0]$,\n  $f_N = [0.999, 0.999, 0.995, 0.946, 0.600, 0.310, 0.118, 0.012, 0.001]$.\n\n- 用例 B (转变中区):\n  $[D] = [0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0]$,\n  $f_N = [0.885, 0.835, 0.770, 0.690, 0.600, 0.500, 0.400]$.\n\n- 用例 C (低变性剂浓度下部分信息缺失，中点附近急剧下降):\n  $[D] = [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0]$,\n  $f_N = [1.000, 1.000, 1.000, 0.983, 0.500, 0.017, 0.000]$.\n\n您的程序必须对每个用例，使用从上述基本原理推导出的双态模型，通过非线性最小二乘法拟合 $\\Delta G_{\\mathrm{H_2O}}$ (单位 $\\mathrm{kJ/mol}$) 和 $m$ (单位 $\\mathrm{kJ/mol/M}$)，并使用上述基于残差的协方差近似法计算它们的标准误差。生成的结果需四舍五入到三位小数。以 $\\mathrm{kJ/mol}$ 为单位表示 $\\Delta G_{\\mathrm{H_2O}}$，以 $\\mathrm{kJ/mol/M}$ 为单位表示 $m$，它们的标准误差使用与其对应参数相同的单位。\n\n最终输出格式：您的程序应生成单行输出，包含一个以逗号分隔的列表的列表，每个内部列表对应一个测试用例，且每个内部列表按 $[\\Delta G_{\\mathrm{H_2O}}, m, s_{\\Delta G_{\\mathrm{H_2O}}}, s_m]$ 的顺序列出结果，例如 $[[x_{A1},x_{A2},x_{A3},x_{A4}],[x_{B1},x_{B2},x_{B3},x_{B4}],[x_{C1},x_{C2},x_{C3},x_{C4}]]$，其中每个 $x$ 是一个四舍五入到三位小数的浮点数。", "solution": "问题陈述在生物物理化学和数据分析领域提出了一个有效且定义明确的任务。它在科学上基于经典的蛋白质折叠双态模型和线性外推法。该问题是自洽的，提供了所有必要的数据、常数以及对所需数学和统计程序的清晰描述。它没有矛盾、歧义或事实错误。因此，将提供一个合理的解决方案。\n\n任务是通过使用非线性最小二乘法拟合双态折叠模型，从蛋白质变性数据中估计热力学参数 $\\Delta G_{\\mathrm{H_2O}}$ 和 $m$，并计算这些估计值的不确定度。\n\n首先，我们推导天然蛋白质分数 $f_N$ 作为变性剂浓度 $[D]$ 的函数的正向模型。该系统被描述为天然态 ($N$) 和去折叠态 ($U$) 之间的双态平衡：\n$$ N \\rightleftharpoons U $$\n该反应（代表去折叠过程）的平衡常数由各状态浓度的比值给出：\n$$ K = \\frac{[U]}{[N]} $$\n问题将 $\\Delta G$ 定义为去折叠与天然构象系综之间的吉布斯自由能差，因此 $\\Delta G = G_U - G_N$。对于在没有变性剂时稳定折叠的蛋白质，$G_N  G_U$，这意味着 $\\Delta G  0$。平衡常数与 $\\Delta G$ 之间的关系由基本热力学方程给出：\n$$ K = \\exp\\left(-\\frac{\\Delta G}{RT}\\right) $$\n其中 $R$ 是气体常数，$T$ 是绝对温度。\n\n观测到的量 $f_N$ 是处于天然态的蛋白质分子的分数。用浓度表示为：\n$$ f_N = \\frac{[N]}{[N] + [U]} $$\n通过将分子和分母同除以 $[N]$，我们可以用平衡常数 $K$ 来表示 $f_N$：\n$$ f_N = \\frac{1}{1 + \\frac{[U]}{[N]}} = \\frac{1}{1 + K} $$\n代入 $K$ 的表达式，得到 $f_N$ 和 $\\Delta G$ 之间的关系：\n$$ f_N = \\frac{1}{1 + \\exp\\left(-\\frac{\\Delta G}{RT}\\right)} $$\n该方程在形式上类似于费米-狄拉克分布。\n\n问题指出，$\\Delta G$ 与变性剂浓度 $[D]$ 存在经验性的线性依赖关系：\n$$ \\Delta G([D]) = \\Delta G_{\\mathrm{H_2O}} - m[D] $$\n这里，$\\Delta G_{\\mathrm{H_2O}}$ 是在纯水中（$[D]=0$）的去折叠吉布斯自由能，$m$ 值量化了 $\\Delta G$ 对变性剂浓度的敏感性。将此线性关系代入我们关于 $f_N$ 的表达式中，得到最终的正向模型：\n$$ f_N([D]; \\Delta G_{\\mathrm{H_2O}}, m) = \\frac{1}{1 + \\exp\\left(-\\frac{\\Delta G_{\\mathrm{H_2O}} - m[D]}{RT}\\right)} $$\n该模型在给定参数 $\\theta = (\\Delta G_{\\mathrm{H_2O}}, m)$ 的情况下，预测在任何给定变性剂浓度下的天然蛋白质分数。\n\n接下来，我们构建非线性最小二乘 (NLLS) 问题，以从一组 $n$ 个实验数据点 $([D_i], f_{N,i}^{\\text{obs}})$ 中估计参数 $\\theta$。目标是找到使观测数据与模型预测值之间的残差平方和 (RSS) 最小化的参数值。第 $i$ 个数据点的残差为：\n$$ r_i(\\theta) = f_{N,i}^{\\text{obs}} - f_N([D_i]; \\theta) $$\n需要最小化的目标函数是 RSS：\n$$ \\text{RSS}(\\theta) = \\sum_{i=1}^n r_i(\\theta)^2 $$\n优化的执行受限于物理上有意义的约束条件 $m \\ge 0$，因为变性剂预计会使天然态不稳定，从而降低 $\\Delta G$。\n\n最后，我们讨论参数不确定度的估计。对于非线性模型，不确定度可以通过在最优参数集 $\\hat{\\theta}$ 周围进行线性误差传播来近似。该方法依赖于在最优点处评估的残差的雅可比矩阵 $J$。雅可比矩阵的元素由下式给出：\n$$ J_{ij} = \\frac{\\partial r_i}{\\partial \\theta_j} \\bigg|_{\\theta=\\hat{\\theta}} $$\n模型参数的数量为 $p=2$。测量误差的方差由最小化的 RSS 估计：\n$$ \\hat{\\sigma}^2 = \\frac{\\text{RSS}(\\hat{\\theta})}{n - p} $$\n其中 $n-p$ 是自由度。参数协方差矩阵 $C$ 随之近似为：\n$$ C = \\hat{\\sigma}^2 (J^\\top J)^{-1} $$\n为了增强对数值不稳定性的鲁棒性，特别是在 $J^\\top J$ 是病态的情况下（当数据不足以充分约束所有参数时可能发生），使用 Moore-Penrose 伪逆 $(J^\\top J)^+$ 代替标准逆。\n$$ C = \\hat{\\sigma}^2 (J^\\top J)^+ $$\n估计参数的标准误差（不确定度）是协方差矩阵对角线元素的平方根：\n$$ s_{\\theta_j} = \\sqrt{C_{jj}} $$\n具体来说，$s_{\\Delta G_{\\mathrm{H_2O}}} = \\sqrt{C_{11}}$ 且 $s_m = \\sqrt{C_{22}}$。\n\n实现将利用 `scipy.optimize.least_squares` 函数来执行 NLLS 拟合。该函数方便地提供了最优参数和解处的雅可比矩阵，然后用它们来计算协方差矩阵和标准误差，如前所述。在整个计算过程中使用常数 $T = 298.15 \\, \\mathrm{K}$ 和 $R = 0.008314462618 \\, \\mathrm{kJ/(mol\\cdot K)}$。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import least_squares\nfrom scipy.linalg import pinv\n\ndef solve():\n    \"\"\"\n    Fits a two-state protein folding model to denaturation data and calculates parameter uncertainties.\n    \"\"\"\n    # Define constants as specified in the problem\n    T_K = 298.15  # Temperature in Kelvin\n    R_KJ_MOL_K = 0.008314462618  # Gas constant in kJ/(mol*K)\n    RT = R_KJ_MOL_K * T_K\n\n    # Test cases from the problem statement\n    test_cases = [\n        # Case A (broad transition)\n        (np.array([0.0, 1.0, 2.0, 3.0, 4.0, 4.5, 5.0, 6.0, 7.0]),\n         np.array([0.999, 0.999, 0.995, 0.946, 0.600, 0.310, 0.118, 0.012, 0.001])),\n\n        # Case B (mid-transition region)\n        (np.array([0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0]),\n         np.array([0.885, 0.835, 0.770, 0.690, 0.600, 0.500, 0.400])),\n        \n        # Case C (partially uninformative, sharp drop)\n        (np.array([0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0]),\n         np.array([1.000, 1.000, 1.000, 0.983, 0.500, 0.017, 0.000]))\n    ]\n    \n    all_results = []\n\n    for D_M, fN_obs in test_cases:\n        \n        def two_state_model(params, D):\n            \"\"\"\n            Calculates the fraction of native protein based on the two-state model.\n            params[0]: dG_H2O (in kJ/mol)\n            params[1]: m (in kJ/mol/M)\n            \"\"\"\n            dG_H2O, m_val = params\n            delta_G = dG_H2O - m_val * D\n            arg_exp = -delta_G / RT\n            # Use np.exp for vectorized operations\n            return 1.0 / (1.0 + np.exp(arg_exp))\n\n        def residuals(params, D, fN_obs):\n            \"\"\"\n            Calculates the residuals between observed and predicted fN.\n            \"\"\"\n            fN_pred = two_state_model(params, D)\n            return fN_obs - fN_pred\n\n        # Initial guess for parameters [dG_H2O, m].\n        # A positive dG_H2O indicates a stable native state at [D]=0.\n        # An m-value represents the slope of the transition.\n        x0 = np.array([10.0, 5.0]) \n\n        # Bounds for parameters: m must be non-negative.\n        bounds = ([-np.inf, 0], [np.inf, np.inf])\n\n        # Perform the non-linear least squares fit. 'trf' is a good choice for bounds.\n        fit_result = least_squares(residuals, x0, args=(D_M, fN_obs), bounds=bounds, method='trf')\n        \n        # Optimal parameters\n        dG_H2O_fit, m_fit = fit_result.x\n        \n        # Number of data points and parameters\n        n_points = len(D_M)\n        p_params = 2\n        \n        # Degrees of freedom must be positive to estimate variance\n        if n_points = p_params:\n            s_dG, s_m = np.nan, np.nan\n        else:\n            # Calculate residual sum of squares (RSS)\n            # fit_result.cost is 0.5 * sum(residuals**2)\n            rss = 2 * fit_result.cost\n            \n            # Estimate variance of the error\n            sigma_sq = rss / (n_points - p_params)\n            \n            # Jacobian matrix at the solution\n            J = fit_result.jac\n            \n            # Calculate parameter covariance matrix\n            try:\n                # Use Moore-Penrose pseudoinverse for numerical stability\n                jtj_inv = pinv(J.T @ J)\n                cov_matrix = sigma_sq * jtj_inv\n                \n                # Standard errors are the sqrt of the diagonal elements\n                # Ensure diagonal elements are non-negative before taking sqrt\n                diag_cov = np.diag(cov_matrix)\n                if np.any(diag_cov  0):\n                    # Should not happen with real data and a decent fit.\n                    # This indicates a severe numerical issue or a very poor model.\n                    std_errors = np.array([np.nan, np.nan])\n                else:\n                    std_errors = np.sqrt(diag_cov)\n                \n                s_dG, s_m = std_errors\n            except np.linalg.LinAlgError:\n                # Fallback in case of a singular matrix that pinv can't handle\n                s_dG, s_m = np.nan, np.nan\n\n        case_results = [\n            round(dG_H2O_fit, 3),\n            round(m_fit, 3),\n            round(s_dG, 3),\n            round(s_m, 3)\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string as specified\n    # map(str, all_results) will convert each inner list to its string representation\n    # e.g., '[1.234, 5.678, ...]'\n    output_str = f\"[{','.join(map(str, all_results))}]\"\n    print(output_str)\n\nsolve()\n\n```", "id": "2765810"}, {"introduction": "在理解了蛋白质的静态稳定性后，我们将转向动态过程，特别是分子伴侣在维持蛋白质稳态中的作用。Hsp70 伴侣是细胞蛋白质质量控制的关键参与者。本练习 [@problem_id:2765789] 挑战您从第一性原理出发，建立一个动力学模型，将伴侣的核苷酸循环与客户蛋白的结合和释放整合起来。通过计算有效的聚集速率，您将对这些分子机器如何保护蛋白质组获得定量的理解。", "problem": "一个客户多肽在其折叠周期中会瞬时结合到热休克蛋白70 (Hsp70)上。在每个结合周期中，客户多肽在释放前会经历伴侣蛋白的两种连续核苷酸状态：先是结合三磷酸腺苷 (ATP) 的状态，然后是结合二磷酸腺苷 (ADP) 的状态。您测得客户多肽与Hsp70结合时在每种状态下的平均停留时间分别为 $ \\tau_{\\mathrm{ATP}} = 0.60\\,\\text{s}$ 和 $ \\tau_{\\mathrm{ADP}} = 9.0\\,\\text{s}$。游离Hsp70的核苷酸循环是一个两状态过程，ATP到ADP的转化（水解）速率为 $k_{\\mathrm{hyd}} = 1.20\\,\\text{s}^{-1}$，ADP到ATP的核苷酸交换速率为 $k_{\\mathrm{exch}} = 0.30\\,\\text{s}^{-1}$。游离Hsp70的总浓度为 $C_{\\mathrm{tot}} = 5.0\\,\\mu\\text{M}$，客户多肽与ATP结合的Hsp70结合的（二级）速率常数为 $k_{\\mathrm{on}} = 1.0 \\times 10^{6}\\,\\text{M}^{-1}\\text{s}^{-1}$。未受保护的客户多肽以泊松过程的方式形成聚集核心，其基准速率为 $k_{\\mathrm{agg}}^{0} = 1.00 \\times 10^{-2}\\,\\text{s}^{-1}$。\n\n假设：\n- 游离Hsp70的核苷酸状态构成一个两状态连续时间马尔可夫链，其稳态流由给定的相互转化速率决定。\n- 客户多肽的捕获仅通过与ATP结合的Hsp70发生；因此，每个未结合的客户多肽的瞬时结合速率是 $k_{\\mathrm{on}}$ 乘以稳态下ATP-Hsp70的浓度。\n- 客户多肽被捕获的未结合等待时间呈指数分布，其平均值等于捕获速率的倒数（泊松到达）。\n- 在一次结合事件中，ATP和ADP阶段按顺序发生，因此每次事件的平均结合持续时间是平均ATP和ADP停留时间之和。\n- 当客户多肽与Hsp70结合时，聚集核心的形成被阻断；因此，有效聚集速率等于基准速率乘以客户多肽处于未结合状态的长时间分数。\n\n从这些原理出发，并仅使用第一性原理推理（例如，两状态马尔可夫链中的稳态平衡、结合的质量作用定律、泊松/指数等待时间特性以及更新过程的时间分数论证），计算在稳态下单个客户多肽分子在分子伴侣作用下的有效聚集速率 $k_{\\mathrm{agg,eff}}$。将 $k_{\\mathrm{agg,eff}}$ 以 $\\text{s}^{-1}$ 为单位表示，并将最终答案四舍五入到三位有效数字。最终答案必须是一个数字。", "solution": "该问题是有效的，因为它具有科学依据，问题明确且客观。它提出了一个简化但标准的分子伴侣-客户多肽相互作用的生物物理模型，提供了所有必要的参数和一致的假设，并要求计算一个可量化的值。我现在开始解答。\n\n目标是计算在Hsp70分子伴侣系统作用下，客户多肽的有效聚集速率 $k_{\\mathrm{agg,eff}}$。根据问题的第五个假设，当客户多肽与Hsp70结合时，聚集被阻断。因此，有效聚集速率是基准聚集速率 $k_{\\mathrm{agg}}^{0}$ 乘以客户多肽处于未结合状态的时间分数 $P_{\\mathrm{unbound}}$。\n$$k_{\\mathrm{agg,eff}} = k_{\\mathrm{agg}}^{0} \\times P_{\\mathrm{unbound}}$$\n客户多肽的状态在未结合和与Hsp70结合之间交替。这构成了一个更新过程。对于此类过程，在特定状态下花费的长时间分数是该状态的平均持续时间与平均总周期时间之比。\n$$P_{\\mathrm{unbound}} = \\frac{\\langle T_{\\mathrm{unbound}} \\rangle}{\\langle T_{\\mathrm{unbound}} \\rangle + \\langle T_{\\mathrm{bound}} \\rangle}$$\n此处，$\\langle T_{\\mathrm{unbound}} \\rangle$ 是客户多肽未结合的平均时间，$\\langle T_{\\mathrm{bound}} \\rangle$ 是在单个周期内客户多肽与Hsp70结合的平均时间。\n\n首先，我们计算平均结合时间 $\\langle T_{\\mathrm{bound}} \\rangle$。问题陈述，一次结合事件包括两个连续的阶段：ATP结合阶段和ADP结合阶段。一次完整结合事件的平均持续时间是每个状态中平均停留时间之和。\n$$\\langle T_{\\mathrm{bound}} \\rangle = \\tau_{\\mathrm{ATP}} + \\tau_{\\mathrm{ADP}}$$\n使用所给值 $\\tau_{\\mathrm{ATP}} = 0.60\\,\\text{s}$ 和 $\\tau_{\\mathrm{ADP}} = 9.0\\,\\text{s}$：\n$$\\langle T_{\\mathrm{bound}} \\rangle = 0.60\\,\\text{s} + 9.0\\,\\text{s} = 9.6\\,\\text{s}$$\n\n接下来，我们计算平均未结合时间 $\\langle T_{\\mathrm{unbound}} \\rangle$。根据假设，捕获一个未结合的客户多肽是一个泊松过程。泊松过程中事件的平均等待时间是其速率的倒数。捕获速率 $\\lambda_{\\text{capture}}$ 由质量作用定律给出：它是二级结合速率常数 $k_{\\mathrm{on}}$ 与可用于结合的物种浓度（即ATP结合的Hsp70，记为 $[H_{ATP}]$）的乘积。\n$$\\langle T_{\\mathrm{unbound}} \\rangle = \\frac{1}{\\lambda_{\\text{capture}}} = \\frac{1}{k_{\\mathrm{on}} [H_{ATP}]}$$\n\n为了求得 $[H_{ATP}]$，我们必须确定游离Hsp70核苷酸状态的稳态浓度。问题将游离Hsp70核苷酸循环描述为一个涉及ATP结合的Hsp70 ($H_{ATP}$) 和ADP结合的Hsp70 ($H_{ADP}$) 的两状态连续时间马尔可夫过程。\n$$H_{ATP} \\underset{k_{\\mathrm{exch}}}{\\stackrel{k_{\\mathrm{hyd}}}{\\rightleftharpoons}} H_{ADP}$$\n在稳态下，从ATP状态到ADP状态的通量必须与从ADP状态到ATP状态的通量相平衡。\n$$k_{\\mathrm{hyd}} [H_{ATP}] = k_{\\mathrm{exch}} [H_{ADP}]$$\n此外，两种状态的浓度之和等于游离Hsp70的总浓度 $C_{\\mathrm{tot}}$。\n$$[H_{ATP}] + [H_{ADP}] = C_{\\mathrm{tot}}$$\n我们可以解这个二元线性方程组。从第二个方程，我们得到 $[H_{ADP}] = C_{\\mathrm{tot}} - [H_{ATP}]$，并将其代入第一个方程：\n$$k_{\\mathrm{hyd}} [H_{ATP}] = k_{\\mathrm{exch}} (C_{\\mathrm{tot}} - [H_{ATP}])$$\n求解 $[H_{ATP}]$：\n$$k_{\\mathrm{hyd}} [H_{ATP}] + k_{\\mathrm{exch}} [H_{ATP}] = k_{\\mathrm{exch}} C_{\\mathrm{tot}}$$\n$$[H_{ATP}] (k_{\\mathrm{hyd}} + k_{\\mathrm{exch}}) = k_{\\mathrm{exch}} C_{\\mathrm{tot}}$$\n$$[H_{ATP}] = C_{\\mathrm{tot}} \\frac{k_{\\mathrm{exch}}}{k_{\\mathrm{hyd}} + k_{\\mathrm{exch}}}$$\n现在，我们代入给定的数值：$C_{\\mathrm{tot}} = 5.0\\,\\mu\\text{M} = 5.0 \\times 10^{-6}\\,\\text{M}$，$k_{\\mathrm{exch}} = 0.30\\,\\text{s}^{-1}$ 和 $k_{\\mathrm{hyd}} = 1.20\\,\\text{s}^{-1}$。\n$$[H_{ATP}] = (5.0 \\times 10^{-6}\\,\\text{M}) \\frac{0.30\\,\\text{s}^{-1}}{1.20\\,\\text{s}^{-1} + 0.30\\,\\text{s}^{-1}} = (5.0 \\times 10^{-6}\\,\\text{M}) \\frac{0.30}{1.50} = (5.0 \\times 10^{-6}\\,\\text{M}) \\times 0.2 = 1.0 \\times 10^{-6}\\,\\text{M}$$\n\n有了ATP结合的Hsp70的浓度，我们可以使用 $k_{\\mathrm{on}} = 1.0 \\times 10^{6}\\,\\text{M}^{-1}\\text{s}^{-1}$ 计算捕获速率 $\\lambda_{\\text{capture}}$。\n$$\\lambda_{\\text{capture}} = k_{\\mathrm{on}} [H_{ATP}] = (1.0 \\times 10^{6}\\,\\text{M}^{-1}\\text{s}^{-1}) \\times (1.0 \\times 10^{-6}\\,\\text{M}) = 1.0\\,\\text{s}^{-1}$$\n平均未结合时间是该速率的倒数：\n$$\\langle T_{\\mathrm{unbound}} \\rangle = \\frac{1}{\\lambda_{\\text{capture}}} = \\frac{1}{1.0\\,\\text{s}^{-1}} = 1.0\\,\\text{s}$$\n\n现在我们有了两个平均时间：$\\langle T_{\\mathrm{unbound}} \\rangle = 1.0\\,\\text{s}$ 和 $\\langle T_{\\mathrm{bound}} \\rangle = 9.6\\,\\text{s}$。我们可以计算客户多肽处于未结合状态的时间分数：\n$$P_{\\mathrm{unbound}} = \\frac{\\langle T_{\\mathrm{unbound}} \\rangle}{\\langle T_{\\mathrm{unbound}} \\rangle + \\langle T_{\\mathrm{bound}} \\rangle} = \\frac{1.0\\,\\text{s}}{1.0\\,\\text{s} + 9.6\\,\\text{s}} = \\frac{1.0}{10.6}$$\n\n最后，我们使用基准速率 $k_{\\mathrm{agg}}^{0} = 1.00 \\times 10^{-2}\\,\\text{s}^{-1}$ 计算有效聚集速率 $k_{\\mathrm{agg,eff}}$。\n$$k_{\\mathrm{agg,eff}} = k_{\\mathrm{agg}}^{0} \\times P_{\\mathrm{unbound}} = (1.00 \\times 10^{-2}\\,\\text{s}^{-1}) \\times \\frac{1.0}{10.6} \\approx 9.43396 \\times 10^{-4}\\,\\text{s}^{-1}$$\n将结果四舍五入到三位有效数字，我们得到 $9.43 \\times 10^{-4}\\,\\text{s}^{-1}$。", "answer": "$$\\boxed{9.43 \\times 10^{-4}}$$", "id": "2765789"}, {"introduction": "最后，我们探讨最复杂且最接近生物学现实的场景：共翻译折叠。蛋白质在核糖体上合成时就开始折叠，而翻译速度可以影响这一过程。这个高级计算练习 [@problem_id:2765779] 将指导您使用连续时间马尔可夫链来模拟这一复杂的相互作用。通过实施这个模型，您将探索一个前沿问题：同义密码子的使用如何通过制造翻译暂停来决定蛋白质的最终命运——是正确折叠还是错误折叠。", "problem": "您的任务是，从第一性原理出发，定量分析引入翻译暂停的同义密码子变化如何改变单个蛋白质结构域在其共翻译出现过程中发生错误折叠的概率。将共翻译折叠形式化为一个在一维反应坐标上的连续时间生灭过程，该坐标代表新生链朝向一个有效的天然构象盆或一个无效的错误折叠盆的演进。您必须实现一个程序，该程序能为给定的延伸速率剖面计算错误折叠概率，然后报告在指定密码子处引入暂停所引起的错误折叠概率的变化。\n\n假设和基础：\n- 核糖体的翻译延伸被建模为一系列密码子添加过程。在密码子索引 $i$ 处，延伸任何特定密码子的等待时间服从速率参数为 $r_i$ (单位: $\\mathrm{s}^{-1}$) 的指数分布。这与一个泊松 (Poissonian) 延伸机制相符，其中每一步都是一个无记忆事件。\n- 在固定的密码子索引 $i$ 处，出现的结构域的共翻译折叠动力学被建模为一个在离散状态 $\\{0,1,\\dots,K\\}$ 上的连续时间马尔可夫链 (CTMC)，其生成元为一个三对角的生灭生成元 $Q_i$。其中，$0$ 是一个吸收的天然状态，$K$ 是一个吸收的错误折叠状态。非吸收状态为 $k \\in \\{1,\\dots,K-1\\}$。\n- 对于在密码子索引 $i$ 处的 $k \\in \\{1,\\dots,K-1\\}$，生成（朝向错误折叠）和消亡（朝向天然状态）的转移速率分别表示为 $\\lambda_i(k)$ 和 $\\mu_i(k)$，单位均为 $\\mathrm{s}^{-1}$。生成元 $Q_i$ 的元素为 $[Q_i]_{k,k+1}=\\lambda_i(k)$、$[Q_i]_{k,k-1}=\\mu_i(k)$、$[Q_i]_{k,k}=-(\\lambda_i(k)+\\mu_i(k))$，并且 $[Q_i]_{0,\\cdot}=\\mathbf{0}$ 和 $[Q_i]_{K,\\cdot}=\\mathbf{0}$（吸收边界）。\n- 局部能量景观中密码子依赖的偏倚由一个标量权重 $w_i0$ 表示，该权重调节正向和反向速率。胞质分子伴侣的作用由浓度 $C$ (单位: $\\mu\\mathrm{M}$) 表示，它根据一个线性拯救项来增加反向速率 $\\mu_i(k)$。\n\n用于所有计算的速率参数化：\n- 对于 $k \\in \\{1,\\dots,K-1\\}$ 和密码子 $i$，通过以下公式定义基础系数 $a_k$ 和 $b_k$：\n  $$\n  a_k \\equiv a_0 \\left(1 + s\\,(k-1)\\right), \\quad b_k \\equiv b_0 \\left(1 + t\\,(K-1-k)\\right),\n  $$\n  其中常数 $a_0=0.5\\,\\mathrm{s}^{-1}$，$s=0.3$，$b_0=0.8\\,\\mathrm{s}^{-1}$，$t=0.2$。\n- 定义分子伴侣拯救标度为 $(1+\\gamma C)$，其中 $\\gamma=0.06\\,\\mu\\mathrm{M}^{-1}$ 且 $C$ 的单位为 $\\mu\\mathrm{M}$。\n- 密码子依赖的权重 $w_i$ 是分段的：\n  - 对于 $i \\in \\{1,\\dots,24\\}$，设 $w_i=0.7$。\n  - 对于 $i \\in \\{25,\\dots,45\\}$，设 $w_i=1.8$。\n  - 对于 $i \\in \\{46,\\dots,60\\}$，设 $w_i=1.2$。\n- 按如下方式构建位置特异性速率：\n  $$\n  \\lambda_i(k) = w_i \\, a_k, \\qquad \\mu_i(k) = \\frac{(1+\\gamma C)\\, b_k}{w_i}.\n  $$\n\n延伸速率剖面：\n- 设结构域长度为 $L=60$ 个密码子。对于每个密码子 $i \\in \\{1,\\dots,L\\}$，延伸等待时间服从速率为 $r_i$ (单位: $\\mathrm{s}^{-1}$) 的指数分布。对于给定的测试用例，基线剖面是恒定的，而暂停剖面除了在指定窗口内 $r_i$ 被降低以表示同义密码子暂停外，其余与基线剖面相等。\n\n折叠轨迹的构成：\n- 在所有测试用例中，新生链在 $i=1$ 时从状态 $k_0=3$ 开始。\n- 当核糖体在密码子 $i$ 处停留一个服从速率为 $r_i$ 的指数分布的随机时间时，具有生成元 $Q_i$ 的CTMC进行演化。当延伸进行到密码子 $i+1$ 后，生成元变为 $Q_{i+1}$。此过程持续到 $i=L$。天然和错误折叠状态（$0$ 和 $K$）在整个过程中都是吸收状态。\n\n目标：\n- 对于给定的延伸速率剖面 $\\{r_i\\}_{i=1}^L$ 和分子伴侣浓度 $C$，计算翻译结束时的精确错误折叠概率，该概率定义为在密码子 $L$ 之后，处于吸收的错误折叠状态 $K$ 的概率质量。\n- 对于每个测试用例，计算两个错误折叠概率：一个使用基线延伸速率剖面，另一个使用暂停剖面；将差值（暂停剖面概率 - 基线剖面概率）报告为一个等于 $\\text{paused} - \\text{baseline}$ 的浮点数。\n\n推导的基本出发点：\n- 仅使用以下内容作为出发点：分子生物学的中心法则（DNA到RNA到蛋白质）、带有生成元矩阵的连续时间马尔可夫链的定义，以及当环境在随机的指数时间点发生变化时，指数等待时间会产生生成元的无记忆切换这一性质。您不得在这些基础之外假设任何预先推导出的简化公式。\n\n测试套件（所有用例均使用 $K=5$，$k_0=3$，$L=60$ 个密码子，以及如上所述的 $w_i$）：\n- 用例 1：$C=1.0$。基线剖面：对于所有 $i$，$r_i=10.0$。暂停剖面：对于 $i \\in \\{30,31,32,33,34,35\\}$，$r_i=2.0$，其他情况下 $r_i=10.0$。\n- 用例 2：$C=5.0$。基线剖面：对于所有 $i$，$r_i=10.0$。暂停剖面：对于 $i \\in \\{30,\\dots,45\\}$，$r_i=2.0$，其他情况下 $r_i=10.0$。\n- 用例 3：$C=10.0$。基线剖面：对于所有 $i$，$r_i=10.0$。暂停剖面：对于 $i \\in \\{30,\\dots,45\\}$，$r_i=2.0$，其他情况下 $r_i=10.0$。\n- 用例 4：$C=0.0$。基线剖面：对于所有 $i$，$r_i=20.0$。暂停剖面：对于 $i \\in \\{25,\\dots,45\\}$，$r_i=0.5$，其他情况下 $r_i=20.0$。\n\n您的程序必须做到：\n- 按照规定实现具有吸收端点的生灭CTMC。\n- 通过正确组合指数停留时间下的密码子内动力学和密码子间的生成元切换，来构成跨越所有密码子的完整共翻译演化过程。\n- 对于每个用例，计算基线和暂停剖面的错误折叠概率，并输出差值（暂停概率减去基线概率）作为浮点数。\n\n答案规格和输出格式：\n- 所有输出都是无量纲的概率。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[x_1,x_2,x_3,x_4]$），其中每个 $x_j$ 是用例 $j$ 的错误折叠概率差，四舍五入到恰好6位小数。", "solution": "该问题要求在一个共翻译折叠模型下计算蛋白质错误折叠的概率。该模型是一个用于描述折叠状态的连续时间马尔可夫链 (CTMC)，其控制参数在与核糖体延伸步骤相对应的随机、指数分布的时间点上发生切换。解决方案必须从第一性原理推导得出。\n\n设系统的状态由一个概率向量 $\\mathbf{p}(t) \\in \\mathbb{R}^{K+1}$ 描述，其中 $p_k(t)$ 是新生链在时间 $t$ 处于折叠状态 $k \\in \\{0, 1, \\dots, K\\}$ 的概率。状态 $k=0$（天然）和 $k=K$（错误折叠）是吸收态。\n\n系统的演化被划分为与核糖体停留在每个密码子 $i \\in \\{1, \\dots, L\\}$ 相对应的多个时间区间。在密码子 $i$ 的停留时间（表示为 $T_i$）内，折叠动力学由一个恒定的生成元矩阵 $Q_i$ 控制。概率向量 $\\mathbf{p}(t)$ 根据正向主方程演化：\n$$\n\\frac{d\\mathbf{p}(t)}{dt} = Q_i^T \\mathbf{p}(t)\n$$\n其中 $Q_i^T$ 是生成元矩阵 $Q_i$ 的转置。给定区间开始时的分布 $\\mathbf{p}_{\\text{start}}$，其形式解为\n$$\n\\mathbf{p}(t) = e^{Q_i^T t} \\mathbf{p}_{\\text{start}}\n$$\n\n停留时间 $T_i$ 不是一个固定值，而是一个服从速率参数为 $r_i$ 的指数分布的随机变量，即 $T_i \\sim \\text{Exp}(r_i)$。其概率密度函数为 $f_{T_i}(t) = r_i e^{-r_i t}$ (当 $t \\ge 0$)。为了找到这个随机区间结束时的概率分布，必须对所有可能的 $t$ 值，按此密度加权平均求解。\n\n设 $\\mathbf{p}_i$ 为核糖体开始处理密码子 $i$ 那一刻的概率分布向量。下一个密码子开始时的分布 $\\mathbf{p}_{i+1}$ 是在随机停留时间 $T_i$ 上对演化后状态的期望：\n$$\n\\mathbf{p}_{i+1} = \\mathbb{E}_{T_i \\sim \\text{Exp}(r_i)} \\left[ e^{Q_i^T T_i} \\mathbf{p}_i \\right]\n$$\n根据无意识统计师法则，该期望通过以下积分计算：\n$$\n\\mathbf{p}_{i+1} = \\int_{0}^{\\infty} \\left( e^{Q_i^T t} \\mathbf{p}_i \\right) (r_i e^{-r_i t}) dt\n$$\n由于 $\\mathbf{p}_i$ 相对于积分变量 $t$ 是一个常数，可以将其提出：\n$$\n\\mathbf{p}_{i+1} = \\left( r_i \\int_{0}^{\\infty} e^{-r_i t} e^{Q_i^T t} dt \\right) \\mathbf{p}_i\n$$\n该积分表达式是矩阵指数 $e^{Q_i^T t}$ 的拉普拉斯变换的定义，在 $s=r_i$ 处求值。$e^{At}$ 的拉普拉斯变换是 $(sI - A)^{-1}$。应用这一基本性质，我们得到：\n$$\n\\int_{0}^{\\infty} e^{-s t} e^{Q_i^T t} dt = (sI - Q_i^T)^{-1}\n$$\n将 $s = r_i$ 代入，概率向量的更新规则变为：\n$$\n\\mathbf{p}_{i+1} = M_i \\mathbf{p}_i, \\quad \\text{其中} \\quad M_i = r_i (r_i I - Q_i^T)^{-1}\n$$\n矩阵 $M_i$ 充当传播子，将概率分布从密码子 $i$ 的开始时刻映射到密码子 $i+1$ 的开始时刻。\n\n从密码子 $i=1$ 到 $i=L$ 的整个翻译过程是这样一系列传播步骤的序列。初始条件在密码子 1 开始时给出：新生链从状态 $k_0$ 开始。这对应于一个初始概率向量 $\\mathbf{p}_1$，其中索引 $k_0$ 处的元素为1，所有其他元素为0。\n在密码子 2 开始时的分布是 $\\mathbf{p}_2 = M_1 \\mathbf{p}_1$。\n在密码子 3 开始时的分布是 $\\mathbf{p}_3 = M_2 \\mathbf{p}_2 = M_2 M_1 \\mathbf{p}_1$。\n这个迭代过程对所有 $L$ 个密码子继续进行。在密码子 $L$ 的停留时间结束后，最终的概率分布由下式给出：\n$$\n\\mathbf{p}_{\\text{final}} = M_L M_{L-1} \\cdots M_2 M_1 \\mathbf{p}_1\n$$\n错误折叠概率是该最终向量中对应于吸收的错误折叠状态 $K$ 的分量。设我们的状态索引为 $\\{0, 1, \\dots, K\\}$。那么，错误折叠概率 $P_{\\text{misfold}}$ 就是 $\\mathbf{p}_{\\text{final}}$ 在索引 $K$ 处的元素：\n$$\nP_{\\text{misfold}} = [\\mathbf{p}_{\\text{final}}]_K\n$$\n\n计算的算法流程如下：\n1.  根据问题陈述初始化常数：$K=5$，$k_0=3$，$L=60$，以及生物物理参数 $a_0$、$s$、$b_0$、$t$、$\\gamma$。\n2.  预计算与状态相关但与密码子无关的速率系数 $a_k$ 和 $b_k$，其中 $k \\in \\{1, \\dots, K-1\\}$。\n3.  对于每个测试用例（由分子伴侣浓度 $C$ 和两个延伸剖面 `baseline` 和 `paused` 定义），对每个剖面执行一次以下计算循环，共执行两次。\n4.  对于给定的剖面，初始化大小为 $(K+1)$ 的概率向量 $\\mathbf{p}$，在索引 $k_0=3$ 处设为1，其余处设为0。\n5.  从 $1$ 到 $L$ 遍历密码子 $i$。在每次迭代中：\n    a. 从剖面确定密码子依赖的权重 $w_i$ 和延伸速率 $r_i$。\n    b. 计算折叠速率 $\\lambda_i(k) = w_i a_k$ 和 $\\mu_i(k) = (1+\\gamma C) b_k / w_i$。\n    c. 为一个在状态 $\\{1, \\dots, K-1\\}$ 上的生灭过程构建 $(K+1) \\times (K+1)$ 的生成元矩阵 $Q_i$，其在 $0$ 和 $K$ 处有吸收边界。非零的非对角元素为 $[Q_i]_{k, k+1} = \\lambda_i(k)$ 和 $[Q_i]_{k, k-1} = \\mu_i(k)$，其中状态 $k$ 不是边界。对角线元素为 $[Q_i]_{k,k} = -(\\sum_{j \\ne k} Q_{k,j})$。状态 $0$ 和 $K$ 对应的行为零。\n    d. 使用数值线性代数，特别是矩阵求逆，计算传播子矩阵 $M_i = r_i (r_i I - Q_i^T)^{-1}$。\n    e. 更新概率向量：$\\mathbf{p} \\leftarrow M_i \\mathbf{p}$。\n6.  遍历所有 $L$ 个密码子后，获得最终向量 $\\mathbf{p}$。错误折叠概率是元素 $\\mathbf{p}[K]$。\n7.  计算完 `baseline` ($P_{\\text{base}}$) 和 `paused` ($P_{\\text{paused}}$) 两种剖面的错误折叠概率后，计算差值 $\\Delta P = P_{\\text{paused}} - P_{\\text{base}}$。\n8.  最终输出是所有测试用例的这些差值的列表。\n\n此程序构成了对所提问题的完整而精确的解决方案。它按照要求，直接从连续时间马尔可夫链的定义和指数分布的性质推导得出。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import inv\n\ndef solve():\n    \"\"\"\n    Computes the change in misfolding probability due to translational pauses\n    based on a co-translational folding model.\n    \"\"\"\n    \n    # Define problem constants and parameters\n    K = 5\n    k0 = 3\n    L = 60\n    a0 = 0.5\n    s = 0.3\n    b0 = 0.8\n    t = 0.2\n    gamma = 0.06\n\n    # Pre-calculate state-dependent but codon-independent rate coefficients\n    # k runs from 1 to K-1=4\n    k_vals = np.arange(1, K)\n    a_k_base = a0 * (1 + s * (k_vals - 1))\n    b_k_base = b0 * (1 + t * (K - 1 - k_vals))\n\n    def get_w(i):\n        \"\"\"Returns the codon-dependent weight w_i for codon i.\"\"\"\n        if 1 = i = 24:\n            return 0.7\n        elif 25 = i = 45:\n            return 1.8\n        elif 46 = i = 60:\n            return 1.2\n        else:\n            # This case should not be reached with L=60\n            raise ValueError(\"Codon index out of bounds\")\n\n    def calculate_misfolding_prob(C, r_profile):\n        \"\"\"\n        Calculates the final misfolding probability for a given chaperone\n        concentration and elongation rate profile.\n        \"\"\"\n        # Initialize probability vector p, with the system starting in state k0\n        p = np.zeros(K + 1)\n        p[k0] = 1.0\n\n        # Calculate chaperone rescue factor\n        chaperone_factor = 1 + gamma * C\n\n        # Iterate through all codons from 1 to L\n        for i in range(1, L + 1):\n            wi = get_w(i)\n            ri = r_profile[i - 1] # r_profile is 0-indexed\n\n            # Calculate position-specific rates lambda_i(k), mu_i(k)\n            # These are for k in {1, ..., K-1}\n            lambda_i = wi * a_k_base\n            mu_i = (chaperone_factor * b_k_base) / wi\n\n            # Build the generator matrix Q_i of size (K+1)x(K+1)\n            Q = np.zeros((K + 1, K + 1))\n            \n            # Populate Q for intermediate states k=1 to K-1 (indices 1 to 4)\n            for k_idx, k in enumerate(range(1, K)):\n                lam = lambda_i[k_idx]\n                mu = mu_i[k_idx]\n                \n                Q[k, k + 1] = lam  # Transition k -> k+1\n                Q[k, k - 1] = mu   # Transition k -> k-1\n                Q[k, k] = -(lam + mu) # Total rate out of k\n\n            # Propagator matrix M_i = r_i * inv(r_i * I - Q_i^T)\n            I = np.identity(K + 1)\n            Q_T = Q.T\n            M = ri * inv(ri * I - Q_T)\n\n            # Update probability vector: p_{i+1} = M_i * p_i\n            p = M @ p\n        \n        # Final misfolding probability is the probability in the last state, K\n        misfolding_prob = p[K]\n        return misfolding_prob\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        # Case 1\n        {\"C\": 1.0, \"r_base_val\": 10.0, \"r_paused_val\": 2.0, \"pause_window\": (30, 35)},\n        # Case 2\n        {\"C\": 5.0, \"r_base_val\": 10.0, \"r_paused_val\": 2.0, \"pause_window\": (30, 45)},\n        # Case 3\n        {\"C\": 10.0, \"r_base_val\": 10.0, \"r_paused_val\": 2.0, \"pause_window\": (30, 45)},\n        # Case 4\n        {\"C\": 0.0, \"r_base_val\": 20.0, \"r_paused_val\": 0.5, \"pause_window\": (25, 45)},\n    ]\n\n    results = []\n    for case in test_cases:\n        C = case[\"C\"]\n        r_base_val = case[\"r_base_val\"]\n        r_paused_val = case[\"r_paused_val\"]\n        start, end = case[\"pause_window\"]\n        \n        # Create baseline and paused elongation rate profiles\n        r_base_profile = np.full(L, r_base_val)\n        \n        r_paused_profile = np.full(L, r_base_val)\n        # Apply pause (note: 1-based index from problem to 0-based Python slicing)\n        r_paused_profile[start - 1 : end] = r_paused_val\n\n        # Calculate misfolding probability for both profiles\n        prob_base = calculate_misfolding_prob(C, r_base_profile)\n        prob_paused = calculate_misfolding_prob(C, r_paused_profile)\n        \n        # The result is the difference: paused - baseline\n        diff = prob_paused - prob_base\n        results.append(diff)\n\n    # Format the final output string as specified\n    output_str = \",\".join([f\"{res:.6f}\" for res in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n```", "id": "2765779"}]}