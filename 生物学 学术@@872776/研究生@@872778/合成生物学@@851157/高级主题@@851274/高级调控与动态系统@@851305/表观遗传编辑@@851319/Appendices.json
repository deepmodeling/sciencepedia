{"hands_on_practices": [{"introduction": "要真正地工程化一个生物系统，你必须首先能够测量它。本练习将教你一项基本技能：如何将表观遗传标记的写入和擦除过程建模为一个动力学过程，并从实验数据中量化其速率。这项技能是评估和优化表观遗传编辑器的核心。[@problem_id:2737422]", "problem": "给定单个基因组位点上组蛋白标记富集度的时间进程测量数据，该数据通过染色质免疫沉淀后进行定量聚合酶链式反应 (ChIP-qPCR) 获得。富集度被归一化，表示为 $0$ 到 $1$ 之间的一个分数。一个合成表观遗传编辑器在时间 $t=0$ 被诱导，并在已知时间 $T_{\\mathrm{wash}}$ 被移除（洗脱）。假设在均质细胞群体中，该位点上标记的写入和擦除遵循一级质量作用动力学：在诱导期间，被标记核小体的比例 $M(t)$ 根据常微分方程 (ODE) $dM/dt = k_{\\mathrm{write}}(1 - M) - k_{\\mathrm{erase}} M$ 演变；洗脱后只剩下擦除过程，其演变由 $dM/dt = -k_{\\mathrm{erase}} M$ 描述。此处，$k_{\\mathrm{write}} \\ge 0$ 和 $k_{\\mathrm{erase}} \\ge 0$ 是待从数据中推断的常数。初始标记比例为 $M(0) = M_0$，在本问题中，应将其取为每个测试集中的第一个测量值。编辑器移除后的半衰期定义为 $t_{1/2} = \\ln(2)/k_{\\mathrm{erase}}$。\n\n任务：对于下方的每个测试案例，通过将两阶段模型（诱导后洗脱）与所提供的测量数据进行最小二乘法拟合，来估计 $k_{\\mathrm{write}}$ 和 $k_{\\mathrm{erase}}$，然后计算洗脱后的半衰期 $t_{1/2}$。以小时为单位表示 $t_{1/2}$。将每个报告的数字四舍五入到三位小数。\n\n基础出发点：使用分子生物学的中心法则作为背景知识（转录需要特定的染色质状态），并使用一级质量作用动力学来描述标记的写入和擦除。不要假设任何预先推导的时间进程快捷公式；从给定的常微分方程推导您需要的一切。\n\n物理单位：时间 $t$ 和 $T_{\\mathrm{wash}}$ 以小时为单位，$t_{1/2}$ 必须以小时为单位报告。\n\n角度单位：不适用。\n\n百分比：不适用。\n\n测试套件（每个案例指定 $(T_{\\mathrm{wash}}, \\{t_i\\}, \\{M_i\\})$）：\n- 案例 A：\n  - $T_{\\mathrm{wash}} = 4$\n  - 时间点 $t$：$[0, 1, 2, 3, 4, 8, 12]$\n  - 测量的富集度 $M$：$[0, \\tfrac{3}{8}, \\tfrac{9}{16}, \\tfrac{21}{32}, \\tfrac{45}{64}, \\tfrac{45}{128}, \\tfrac{45}{256}]$\n- 案例 B：\n  - $T_{\\mathrm{wash}} = 3$\n  - 时间点 $t$：$[0, 1, 2, 3, 6, 9]$\n  - 测量的富集度 $M$：$[0, \\tfrac{4}{9}, \\tfrac{16}{27}, \\tfrac{52}{81}, \\tfrac{52}{243}, \\tfrac{52}{729}]$\n- 案例 C：\n  - $T_{\\mathrm{wash}} = 2$\n  - 时间点 $t$：$[0, 1, 2, 10, 18]$\n  - 测量的富集度 $M$：$[\\tfrac{1}{8}, \\tfrac{1}{2}, \\tfrac{11}{16}, \\tfrac{11}{32}, \\tfrac{11}{64}]$\n\n估算目标：对于每个案例，拟合 $k_{\\mathrm{write}}$ 和 $k_{\\mathrm{erase}}$，其中 $M(0)$ 固定为该案例的第一个测量值 $M_0$。使用与上述常微分方程一致的两阶段解：一种形式适用于 $0 \\le t \\le T_{\\mathrm{wash}}$（诱导），另一种独立的形式适用于 $t \\ge T_{\\mathrm{wash}}$（洗脱）。\n\n要求的最终输出格式：您的程序应生成一行输出，其中包含一个扁平的、用逗号分隔的列表，并用方括号括起来，依次包含案例 A 的 3 个结果、案例 B 的 3 个结果、案例 C 的 3 个结果，每个案例的顺序为 $[k_{\\mathrm{write}}, k_{\\mathrm{erase}}, t_{1/2}]$。将每个数字四舍五入到三位小数。例如，一个包含三个案例的输出应类似于 $[x_1,y_1,z_1,x_2,y_2,z_2,x_3,y_3,z_3]$，其中每个 $x_i, y_i, z_i$ 都是四舍五入到三位小数的浮点数。", "solution": "问题陈述经过验证，被认为是具有科学依据、适定且客观的。它描述了一个针对常微分方程 (ODE) 系统的标准参数估计任务，该系统代表了质量作用动力学，这是化学和生物科学中的一个基本概念。该问题为确定唯一解提供了所有必要的数据和约束。因此，我们可以继续进行推导和求解。\n\n被标记核小体比例 $M(t)$ 的演变由一个两阶段动力学模型描述。\n\n阶段1：诱导 ($0 \\le t \\le T_{\\mathrm{wash}}$)\n主导的常微分方程为：\n$$\\frac{dM}{dt} = k_{\\mathrm{write}}(1 - M) - k_{\\mathrm{erase}} M$$\n这是一个一阶线性非齐次常微分方程。我们将其重排为标准形式 $\\frac{dy}{dx} + P(x)y = Q(x)$：\n$$\\frac{dM}{dt} + (k_{\\mathrm{write}} + k_{\\mathrm{erase}})M = k_{\\mathrm{write}}$$\n令 $k_{\\mathrm{sum}} = k_{\\mathrm{write}} + k_{\\mathrm{erase}}$。方程变为 $\\frac{dM}{dt} + k_{\\mathrm{sum}}M = k_{\\mathrm{write}}$。\n该常微分方程在初始条件 $M(0) = M_0$ 下的解为：\n$$M_1(t) = M_{\\mathrm{ss}} + (M_0 - M_{\\mathrm{ss}})e^{-k_{\\mathrm{sum}}t}$$\n其中 $M_{\\mathrm{ss}}$ 是稳态浓度，通过设置 $\\frac{dM}{dt} = 0$ 求得。\n$$k_{\\mathrm{write}}(1 - M_{\\mathrm{ss}}) - k_{\\mathrm{erase}} M_{\\mathrm{ss}} = 0 \\implies k_{\\mathrm{write}} = (k_{\\mathrm{write}} + k_{\\mathrm{erase}})M_{\\mathrm{ss}}$$\n$$M_{\\mathrm{ss}} = \\frac{k_{\\mathrm{write}}}{k_{\\mathrm{write}} + k_{\\mathrm{erase}}} = \\frac{k_{\\mathrm{write}}}{k_{\\mathrm{sum}}}$$\n因此，诱导阶段的解为：\n$$M_1(t) = \\frac{k_{\\mathrm{write}}}{k_{\\mathrm{sum}}} + \\left(M_0 - \\frac{k_{\\mathrm{write}}}{k_{\\mathrm{sum}}}\\right)e^{-k_{\\mathrm{sum}}t} \\quad \\text{for } 0 \\le t \\le T_{\\mathrm{wash}}$$\n\n阶段2：洗脱 ($t > T_{\\mathrm{wash}}$)\n在 $T_{\\mathrm{wash}}$ 时刻移除编辑器后，写入过程停止，常微分方程简化为：\n$$\\frac{dM}{dt} = -k_{\\mathrm{erase}} M$$\n这是一个表示指数衰减的一阶线性齐次常微分方程。其通解为：\n$$M(t) = C e^{-k_{\\mathrm{erase}}t}$$\n其中 $C$ 是一个积分常数。我们通过在过渡时间 $t = T_{\\mathrm{wash}}$ 强制组蛋白标记比例的连续性来确定 $C$。洗脱阶段开始时的 $M$ 值必须等于诱导阶段结束时的值。令 $M(T_{\\mathrm{wash}}) = M_1(T_{\\mathrm{wash}})$。\n$$M_1(T_{\\mathrm{wash}}) = C e^{-k_{\\mathrm{erase}}T_{\\mathrm{wash}}}$$\n求解 $C$，我们得到 $C = M_1(T_{\\mathrm{wash}}) e^{k_{\\mathrm{erase}}T_{\\mathrm{wash}}}$。将其代回通解，得到洗脱阶段的特解：\n$$M_2(t) = \\left(M_1(T_{\\mathrm{wash}}) e^{k_{\\mathrm{erase}}T_{\\mathrm{wash}}}\\right) e^{-k_{\\mathrm{erase}}t} = M_1(T_{\\mathrm{wash}}) e^{-k_{\\mathrm{erase}}(t - T_{\\mathrm{wash}})} \\quad \\text{for } t > T_{\\mathrm{wash}}$$\n\n参数估计\n参数 $k_{\\mathrm{write}}$ 和 $k_{\\mathrm{erase}}$ 是未知的。为了估计它们，我们将完整的两阶段模型拟合到实验数据 $\\{t_i, M_i\\}$。模型预测 $M_{\\mathrm{model}}(t_i; k_{\\mathrm{write}}, k_{\\mathrm{erase}})$ 是一个分段函数：\n$$M_{\\mathrm{model}}(t) = \\begin{cases} M_1(t)  \\text{if } 0 \\le t \\le T_{\\mathrm{wash}} \\\\ M_2(t)  \\text{if } t > T_{\\mathrm{wash}} \\end{cases}$$\n我们寻求使模型预测与测量数据之间的残差平方和 (SSE) 最小化的参数：\n$$S(k_{\\mathrm{write}}, k_{\\mathrm{erase}}) = \\sum_i (M_i - M_{\\mathrm{model}}(t_i; k_{\\mathrm{write}}, k_{\\mathrm{erase}}))^2$$\n这构成了一个非线性最小二乘优化问题。我们对每个测试案例进行数值求解，并遵循物理约束 $k_{\\mathrm{write}} \\ge 0$ 和 $k_{\\mathrm{erase}} \\ge 0$。\n\n找到 $k_{\\mathrm{erase}}$ 的最优值后，洗脱后半衰期 $t_{1/2}$ 使用给定的定义计算：\n$$t_{1/2} = \\frac{\\ln(2)}{k_{\\mathrm{erase}}}$$\n\n该实现将利用 SciPy 库中的一个数值优化算法来找出使每个数据集的残差平方和 (SSE) 最小化的 $k_{\\mathrm{write}}$ 和 $k_{\\mathrm{erase}}$ 值。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves for epigenetic kinetic parameters from time-course data.\n    \"\"\"\n    test_cases = [\n        {\n            \"T_wash\": 4.0,\n            \"t\": np.array([0, 1, 2, 3, 4, 8, 12], dtype=float),\n            \"M\": np.array([0, 3/8, 9/16, 21/32, 45/64, 45/128, 45/256], dtype=float)\n        },\n        {\n            \"T_wash\": 3.0,\n            \"t\": np.array([0, 1, 2, 3, 6, 9], dtype=float),\n            \"M\": np.array([0, 4/9, 16/27, 52/81, 52/243, 52/729], dtype=float)\n        },\n        {\n            \"T_wash\": 2.0,\n            \"t\": np.array([0, 1, 2, 10, 18], dtype=float),\n            \"M\": np.array([1/8, 1/2, 11/16, 11/32, 11/64], dtype=float)\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        t_data = case[\"t\"]\n        M_data = case[\"M\"]\n        T_wash = case[\"T_wash\"]\n        M0 = M_data[0]\n\n        def model_predictions(params):\n            \"\"\"\n            Calculates model predictions for a full time course.\n            \"\"\"\n            k_write, k_erase = params\n            \n            # Use small epsilon to avoid division by zero or log(0)\n            epsilon = 1e-12\n            k_sum = k_write + k_erase\n            \n            # Vectorized calculation for the induction phase\n            t_ind = t_data[t_data = T_wash]\n            if k_sum > epsilon:\n                M_ss = k_write / k_sum\n                M_pred_ind = M_ss + (M0 - M_ss) * np.exp(-k_sum * t_ind)\n                M_at_washout = M_ss + (M0 - M_ss) * np.exp(-k_sum * T_wash)\n            else: # If rates are zero, no change from M0\n                M_pred_ind = np.full_like(t_ind, M0)\n                M_at_washout = M0\n            \n            # Vectorized calculation for the washout phase\n            t_wash = t_data[t_data > T_wash]\n            if t_wash.size > 0:\n                M_pred_wash = M_at_washout * np.exp(-k_erase * (t_wash - T_wash))\n                predictions = np.concatenate((M_pred_ind, M_pred_wash))\n            else:\n                predictions = M_pred_ind\n                \n            return predictions\n\n        def objective_function(params):\n            \"\"\"\n            Objective function for least squares minimization (Sum of Squared Errors).\n            \"\"\"\n            M_pred = model_predictions(params)\n            return np.sum((M_data - M_pred)**2)\n\n        # Initial guess and bounds for the optimizer\n        initial_guess = [0.5, 0.5]\n        bounds = [(0, None), (0, None)]\n\n        # Perform optimization\n        result = minimize(\n            objective_function,\n            initial_guess,\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'ftol': 1e-12, 'gtol': 1e-12}\n        )\n        \n        k_write_fit, k_erase_fit = result.x\n\n        # Calculate half-life, protecting against k_erase being zero\n        if k_erase_fit > 1e-12:\n            t_half_life = np.log(2) / k_erase_fit\n        else:\n            t_half_life = np.inf\n\n        # Format and store results\n        all_results.extend([\n            f\"{k_write_fit:.3f}\",\n            f\"{k_erase_fit:.3f}\",\n            f\"{t_half_life:.3f}\"\n        ])\n\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2737422"}, {"introduction": "建立模型并拟合数据只是第一步。一个严谨的科学家会接着问：我的结论有多可靠？本练习将引导你探索参数可辨识性的概念，这是一个评估实验数据是否足以唯一确定模型参数的关键步骤。通过分析费雪信息矩阵（Fisher Information Matrix），你将学会如何从理论上评估实验设计的优劣，并理解为何某些实验无法给出明确的答案。[@problem_id:2737391]", "problem": "您将使用基于费雪信息原理的分析和显式数值评估，分析在持续写入和擦除作用下，单一位点表观遗传标记的两个动力学参数的结构可辨识性。考虑标记位点的比例 $m(t)$，其在恒定的写入酶和擦除酶活性下，遵循质量作用动力学，\n$$\\frac{dm}{dt} \\;=\\; k_{\\text{write}}\\,(1 - m) \\;-\\; k_{\\text{erase}}\\,m,$$\n初始条件为 $m(0) = m_0$。对 $m(t)$ 的测量会受到已知的标准差为 $\\sigma_m$ 的独立零均值高斯噪声的干扰。您将通过计算费雪信息矩阵（Fisher Information Matrix, FIM）并检验参数相关性，来评估 $k_{\\text{write}}$ 和 $k_{\\text{erase}}$ 是否能从带噪声的时程测量中局部辨识。您还将评估添加指定的额外可观测量如何解决简并性问题。\n\n请使用以下基本事实作为您推导和算法设计的基础：\n- 分子生物学中心法则启发我们将写入和擦除活性分离为不同的过程；在此，标记状态遵循上述的一级动力学。\n- 对于方差已知的独立高斯噪声，费雪信息矩阵等于所有观测值的灵敏度（模型预测值相对于参数的梯度）外积之和，再除以该观测值的方差。\n- 当费雪信息矩阵非奇异时，克拉默-拉奥下界（Cramér–Rao lower bound, CRLB）协方差是 FIM 的逆矩阵；当 FIM 是病态的时，可以使用摩尔-彭若斯伪逆来近似不确定性结构。\n- 参数间的绝对相关性可以从 CRLB 协方差矩阵 $C$ 中获得，公式为 $|\\rho| = |C_{12}| / \\sqrt{C_{11} C_{22}}$。\n\n您的程序必须为每个测试用例实现以下步骤：\n1. 从上述微分方程出发，导出 $m(t)$ 及其关于 $k_{\\text{write}}$ 和 $k_{\\text{erase}}$ 的灵敏度表达式。使用该案例中所有指定的观测值构建 FIM。观测值包括：\n   - 时程测量：一组以小时为单位的时间点 $\\{t_i\\}$，在这些时间点上测量 $m(t_i)$，其标准差为 $\\sigma_m$（无量纲，因为 $m$ 是一个比例）。\n   - 可选的稳态可观测量：一个额外的稳态比例 $m_{\\infty}$ 的观测值，其标准差为 $\\sigma_{\\infty}$。\n   - 可选的初始斜率可观测量：一个额外的初始斜率 $s_0 = \\left.\\frac{dm}{dt}\\right|_{t=0}$ 的观测值，其标准差为 $\\sigma_{s}$。\n   所有速率的单位必须视为 $\\text{h}^{-1}$，时间的单位为 $\\text{h}$。下面的输出是无量纲的，不需要物理单位。\n2. 根据 FIM，计算：\n   - 使用 CRLB 协方差计算绝对参数相关性 $|\\rho|$（如果数值稳定，则使用矩阵的逆；否则使用摩尔-彭若斯伪逆）。\n   - FIM 条件数的以 10 为底的对数 $\\log_{10}(\\kappa)$，其中 $\\kappa$ 是最大特征值与最小特征值的比值（将非正的最小特征值视为 $\\kappa = \\infty$）。\n   - 一个布尔值的可辨识性决策，当且仅当 $|\\rho|  0.9$ 且 $\\log_{10}(\\kappa)  6$ 时为 $\\text{True}$，否则为 $\\text{False}$。\n3. 汇总所有测试用例的结果，并打印单行输出，其中包含一个各用例结果的列表，每个用例的结果形式为 $[|\\rho|,\\log_{10}(\\kappa),\\text{decision}]$。两个浮点值必须四舍五入到六位小数。例如，一个包含两个用例的输出可能看起来像 $[[0.123456,2.345678,True],[0.987654,9.876543,False]]$。\n\n测试套件。所有案例使用相同的动力学参数和初始条件：$k_{\\text{write}} = 0.3\\,\\text{h}^{-1}$，$k_{\\text{erase}} = 0.2\\,\\text{h}^{-1}$，以及 $m_0 = 0$。所有时程测量的 $\\sigma_m = 0.02$。当存在额外可观测量时，使用指定的噪声值。\n\n- 案例 A（条件良好，宽时间窗口）：\n  - 时间（小时）：$[0,1,2,3,4,5,6,7,8,9,10,11,12]$。\n  - 无额外可观测量。\n\n- 案例 B（简并，短时间窗口）：\n  - 时间（小时）：$[0,0.05,0.1,0.15,0.2,0.25,0.3,0.35,0.4,0.45,0.5]$。\n  - 无额外可观测量。\n\n- 案例 C（短时间窗口加稳态可观测量）：\n  - 时间（小时）：$[0,0.05,0.1,0.15,0.2,0.25,0.3,0.35,0.4,0.45,0.5]$。\n  - 额外可观测量：一个 $m_{\\infty}$ 的测量值，其 $\\sigma_{\\infty} = 0.02$。\n\n- 案例 D（短时间窗口加初始斜率可观测量）：\n  - 时间（小时）：$[0,0.05,0.1,0.15,0.2,0.25,0.3,0.35,0.4,0.45,0.5]$。\n  - 额外可观测量：一个 $s_0$ 的测量值，其 $\\sigma_{s} = 0.05$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素都是一个三元列表 $[|\\rho|,\\log_{10}(\\kappa),\\text{decision}]$，浮点值四舍五入到六位小数，并按案例 A、案例 B、案例 C、案例 D 的顺序排列。", "solution": "所提出的问题是有效的。它在科学上基于质量作用动力学和系统辨识理论，在数学上是适定的，并且为获得唯一的数值解提供了所有必要的参数和条件。我们将着手进行分析。\n\n目标是根据表观遗传标记比例状态 $m(t)$ 的时间序列和其他测量数据，评估两个动力学参数——写入速率 $k_{\\text{write}}$ 和擦除速率 $k_{\\text{erase}}$——的局部结构可辨识性。分析将使用费雪信息矩阵（FIM）进行。\n\n系统的状态由以下线性一阶常微分方程控制：\n$$\n\\frac{dm}{dt} = k_{\\text{write}}(1 - m) - k_{\\text{erase}}m\n$$\n初始条件为 $m(0) = m_0$。\n\n我们可以将方程重写为：\n$$\n\\frac{dm}{dt} + (k_{\\text{write}} + k_{\\text{erase}})m = k_{\\text{write}}\n$$\n这是一个标准的线性常微分方程。令 $k_s = k_{\\text{write}} + k_{\\text{erase}}$。使用积分因子 $e^{k_s t}$ 可以找到 $m(t)$ 的唯一解。解的形式如下：\n$$\nm(t) = \\frac{k_{\\text{write}}}{k_{\\text{write}} + k_{\\text{erase}}} + \\left(m_0 - \\frac{k_{\\text{write}}}{k_{\\text{write}} + k_{\\text{erase}}}\\right) e^{-(k_{\\text{write}} + k_{\\text{erase}})t}\n$$\n当 $t \\to \\infty$ 时，稳态值为 $m_{\\infty} = \\frac{k_{\\text{write}}}{k_{\\text{write}} + k_{\\text{erase}}}$。因此，我们可以更紧凑地表示解：\n$$\nm(t) = m_{\\infty} + (m_0 - m_{\\infty})e^{-k_s t}\n$$\n\n为了进行可辨识性分析，我们构建费雪信息矩阵。对于一组具有高斯噪声（方差为 $\\{\\sigma_i^2\\}$）的独立测量值 $\\{y_i\\}$，参数矢量 $\\theta$ 的 FIM 由以下公式给出：\n$$\n\\text{FIM} = \\sum_i \\frac{1}{\\sigma_i^2} \\left( \\nabla_{\\theta} f_i(\\theta) \\right) \\left( \\nabla_{\\theta} f_i(\\theta) \\right)^T\n$$\n其中 $f_i(\\theta)$ 是对第 $i$ 个测量值的模型预测，$\\nabla_{\\theta} f_i(\\theta)$ 是预测值相对于参数的梯度，也称为灵敏度矢量。我们的参数矢量是 $\\theta = [k_{\\text{write}}, k_{\\text{erase}}]^T$。\n\n总 FIM 是每种类型测量的贡献之和：\n$$\n\\text{FIM}_{\\text{total}} = \\text{FIM}_{\\text{time-course}} + \\text{FIM}_{\\text{steady-state}} + \\text{FIM}_{\\text{initial-slope}}\n$$\n\n首先，我们需要时程可观测量 $m(t)$ 关于 $k_{\\text{write}}$ 和 $k_{\\text{erase}}$ 的灵敏度。令 $S_w(t) = \\frac{\\partial m(t)}{\\partial k_{\\text{write}}}$ 和 $S_e(t) = \\frac{\\partial m(t)}{\\partial k_{\\text{erase}}}$。使用链式法则和乘积法则：\n$$\nS_w(t) = \\frac{\\partial m(t)}{\\partial k_{\\text{write}}} = \\frac{\\partial m_{\\infty}}{\\partial k_{\\text{write}}}(1 - e^{-k_s t}) + (m_0 - m_{\\infty})(-t e^{-k_s t})\\frac{\\partial k_s}{\\partial k_{\\text{write}}}\n$$\n$$\nS_e(t) = \\frac{\\partial m(t)}{\\partial k_{\\text{erase}}} = \\frac{\\partial m_{\\infty}}{\\partial k_{\\text{erase}}}(1 - e^{-k_s t}) + (m_0 - m_{\\infty})(-t e^{-k_s t})\\frac{\\partial k_s}{\\partial k_{\\text{erase}}}\n$$\n各分量灵敏度为：\n$$\n\\frac{\\partial k_s}{\\partial k_{\\text{write}}} = 1, \\quad \\frac{\\partial k_s}{\\partial k_{\\text{erase}}} = 1\n$$\n$$\n\\frac{\\partial m_{\\infty}}{\\partial k_{\\text{write}}} = \\frac{1 \\cdot (k_{\\text{write}} + k_{\\text{erase}}) - k_{\\text{write}} \\cdot 1}{(k_{\\text{write}} + k_{\\text{erase}})^2} = \\frac{k_{\\text{erase}}}{k_s^2}\n$$\n$$\n\\frac{\\partial m_{\\infty}}{\\partial k_{\\text{erase}}} = \\frac{0 \\cdot (k_{\\text{write}} + k_{\\text{erase}}) - k_{\\text{write}} \\cdot 1}{(k_{\\text{write}} + k_{\\text{erase}})^2} = \\frac{-k_{\\text{write}}}{k_s^2}\n$$\n将这些代入 $S_w(t)$ 和 $S_e(t)$ 的表达式中，得到：\n$$\nS_w(t) = \\frac{k_{\\text{erase}}}{k_s^2}(1 - e^{-k_s t}) - t(m_0 - m_{\\infty})e^{-k_s t}\n$$\n$$\nS_e(t) = \\frac{-k_{\\text{write}}}{k_s^2}(1 - e^{-k_s t}) - t(m_0 - m_{\\infty})e^{-k_s t}\n$$\n对于一组方差为 $\\sigma_m^2$ 的时间点测量值 $\\{t_i\\}$，FIM 的贡献是：\n$$\n\\text{FIM}_{\\text{time-course}} = \\frac{1}{\\sigma_m^2} \\sum_i \\begin{pmatrix} S_w(t_i)^2  S_w(t_i)S_e(t_i) \\\\ S_w(t_i)S_e(t_i)  S_e(t_i)^2 \\end{pmatrix}\n$$\n\n对于一个方差为 $\\sigma_{\\infty}^2$ 的额外稳态测量值 $m_{\\infty}$，灵敏度矢量为 $\\nabla_{\\theta} m_{\\infty} = [\\frac{\\partial m_{\\infty}}{\\partial k_{\\text{write}}}, \\frac{\\partial m_{\\infty}}{\\partial k_{\\text{erase}}}]^T$。FIM 的贡献是：\n$$\n\\text{FIM}_{\\text{steady-state}} = \\frac{1}{\\sigma_{\\infty}^2} \\begin{pmatrix} (\\frac{k_{\\text{erase}}}{k_s^2})^2  \\frac{-k_{\\text{write}}k_{\\text{erase}}}{k_s^4} \\\\ \\frac{-k_{\\text{write}}k_{\\text{erase}}}{k_s^4}  (\\frac{-k_{\\text{write}}}{k_s^2})^2 \\end{pmatrix}\n$$\n\n对于一个方差为 $\\sigma_s^2$ 的额外初始斜率测量值 $s_0 = \\left.\\frac{dm}{dt}\\right|_{t=0} = k_{\\text{write}}(1-m_0) - k_{\\text{erase}}m_0$，灵敏度为：\n$$\n\\frac{\\partial s_0}{\\partial k_{\\text{write}}} = 1-m_0\n$$\n$$\n\\frac{\\partial s_0}{\\partial k_{\\text{erase}}} = -m_0\n$$\nFIM 的贡献是：\n$$\n\\text{FIM}_{\\text{initial-slope}} = \\frac{1}{\\sigma_s^2} \\begin{pmatrix} (1-m_0)^2  -(1-m_0)m_0 \\\\ -(1-m_0)m_0  m_0^2 \\end{pmatrix}\n$$\n在 $m_0=0$ 的特定情况下，这简化为 $\\frac{\\partial s_0}{\\partial k_{\\text{write}}} = 1$ 和 $\\frac{\\partial s_0}{\\partial k_{\\text{erase}}} = 0$，表明初始斜率仅提供关于 $k_{\\text{write}}$ 的信息。\n\n从总 FIM 中，我们计算克拉默-拉奥下界（CRLB）协方差矩阵 $C = \\text{FIM}_{\\text{total}}^{-1}$。为确保数值稳定性，我们使用摩尔-彭若斯伪逆。参数估计值之间的绝对相关系数是：\n$$\n|\\rho| = \\frac{|C_{12}|}{\\sqrt{C_{11} C_{22}}}\n$$\nFIM 的条件数 $\\kappa$ 是其最大特征值 $\\lambda_{\\text{max}}$ 与最小特征值 $\\lambda_{\\text{min}}$ 的比值。大的条件数表示问题是病态的，可辨识性差。如果 $\\lambda_{\\text{min}} \\le 0$，则 FIM 是奇异的，我们定义 $\\kappa = \\infty$。我们计算 $\\log_{10}(\\kappa)$。\n\n对每个测试用例，算法按以下步骤进行：\n1. 初始化一个 $2 \\times 2$ 的 FIM 为零矩阵。\n2. 对于指定时程中的每个时间点 $t_i$，计算灵敏度矢量 $[S_w(t_i), S_e(t_i)]^T$，并将其贡献（按 $1/\\sigma_m^2$ 缩放）加到 FIM 中。\n3. 如果提供了稳态测量值，计算其灵敏度矢量，并将相应的贡献（按 $1/\\sigma_{\\infty}^2$ 缩放）加到 FIM 中。\n4. 如果提供了初始斜率测量值，计算其灵敏度矢量，并将相应的贡献（按 $1/\\sigma_s^2$ 缩放）加到 FIM 中。\n5. 计算得到的总 FIM 的特征值，以求得 $\\kappa$ 和 $\\log_{10}(\\kappa)$。\n6. 计算 FIM 的伪逆以获得 CRLB 协方差矩阵 $C$。\n7. 从 $C$ 的元素中计算绝对相关性 $|\\rho|$。\n8. 做出可辨识性决策：如果 $|\\rho|  0.9$ 且 $\\log_{10}(\\kappa)  6$，则为 $\\text{True}$，否则为 $\\text{False}$。\n\n此过程将被执行以评估四个指定的案例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the identifiability problem for all test cases.\n    \"\"\"\n\n    # Common parameters for all test cases\n    k_write_true = 0.3  # h^-1\n    k_erase_true = 0.2  # h^-1\n    m0 = 0.0\n    sigma_m = 0.02\n\n    # Define the test cases\n    test_cases = {\n        'A': {\n            'times': np.linspace(0, 12, 13),\n            'sigma_m': sigma_m,\n            'ss_obs': None,\n            's0_obs': None,\n        },\n        'B': {\n            'times': np.linspace(0, 0.5, 11),\n            'sigma_m': sigma_m,\n            'ss_obs': None,\n            's0_obs': None,\n        },\n        'C': {\n            'times': np.linspace(0, 0.5, 11),\n            'sigma_m': sigma_m,\n            'ss_obs': {'sigma_inf': 0.02},\n            's0_obs': None,\n        },\n        'D': {\n            'times': np.linspace(0, 0.5, 11),\n            'sigma_m': sigma_m,\n            'ss_obs': None,\n            's0_obs': {'sigma_s': 0.05},\n        }\n    }\n\n    results = []\n    # Process cases in specified order: A, B, C, D\n    for case_name in sorted(test_cases.keys()):\n        params = test_cases[case_name]\n        case_result = analyze_identifiability(\n            k_write=k_write_true,\n            k_erase=k_erase_true,\n            m0=m0,\n            times=params['times'],\n            sigma_m=params['sigma_m'],\n            ss_obs=params['ss_obs'],\n            s0_obs=params['s0_obs']\n        )\n        results.append(case_result)\n\n    # Format the final output string as per requirements\n    output_parts = []\n    for res in results:\n        # res is [abs_rho, log10_kappa, decision]\n        abs_rho_rounded = round(res[0], 6)\n        log10_kappa_rounded = round(res[1], 6) if np.isfinite(res[1]) else res[1]\n        decision = res[2]\n        # Format inner list string manually to remove spaces\n        inner_str = f\"[{abs_rho_rounded},{log10_kappa_rounded},{'True' if decision else 'False'}]\"\n        output_parts.append(inner_str)\n\n    # Note: `str(np.inf)` prints 'inf'. The example output suggests this is implicitly handled,\n    # but for strictness one might replace it. However, the problem definition is fulfilled\n    # by standard float-to-string conversion. The Boolean 'True'/'False' also matches.\n    final_output = f\"[{','.join(output_parts)}]\"\n    print(final_output)\n\ndef analyze_identifiability(k_write, k_erase, m0, times, sigma_m, ss_obs, s0_obs):\n    \"\"\"\n    Calculates identifiability metrics for a single case.\n    \"\"\"\n    # Initialize Fisher Information Matrix (FIM)\n    fim = np.zeros((2, 2))\n    \n    # Pre-calculate common terms\n    k_s = k_write + k_erase\n    k_s_sq = k_s**2\n    m_inf = k_write / k_s if k_s != 0 else 0\n    m0_minus_minf = m0 - m_inf\n\n    # 1. Contribution from time-course measurements\n    for t in times:\n        exp_term = np.exp(-k_s * t)\n        common_term1 = (1 - exp_term) / k_s_sq\n        common_term2 = -t * m0_minus_minf * exp_term\n\n        s_w = k_erase * common_term1 + common_term2\n        s_e = -k_write * common_term1 + common_term2\n        \n        grad = np.array([s_w, s_e])\n        fim += np.outer(grad, grad) / (sigma_m**2)\n\n    # 2. Contribution from steady-state measurement (if any)\n    if ss_obs:\n        sigma_inf = ss_obs['sigma_inf']\n        # Sensitivities of m_inf\n        grad_inf = np.array([k_erase / k_s_sq, -k_write / k_s_sq])\n        fim += np.outer(grad_inf, grad_inf) / (sigma_inf**2)\n\n    # 3. Contribution from initial slope measurement (if any)\n    if s0_obs:\n        sigma_s = s0_obs['sigma_s']\n        # Sensitivities of s0 = k_write*(1-m0) - k_erase*m0\n        grad_s0 = np.array([1 - m0, -m0])\n        fim += np.outer(grad_s0, grad_s0) / (sigma_s**2)\n\n    # 4. Compute metrics from FIM\n    # Eigenvalues for condition number. use eigvalsh for symmetric matrix.\n    try:\n        eigs = np.linalg.eigvalsh(fim)\n        min_eig, max_eig = np.min(eigs), np.max(eigs)\n\n        if min_eig = 1e-12:  # Treat near-zero or negative as singular\n            kappa = np.inf\n            log10_kappa = np.inf\n        else:\n            kappa = max_eig / min_eig\n            log10_kappa = np.log10(kappa)\n    except np.linalg.LinAlgError:\n        log10_kappa = np.inf\n\n    # CRLB Covariance Matrix and Correlation\n    # Use pseudoinverse for stability, as per problem description\n    crlb_cov = np.linalg.pinv(fim)\n    \n    # Check for non-invertibility manifest as zero diagonal elements\n    if crlb_cov[0, 0] = 0 or crlb_cov[1, 1] = 0:\n        abs_rho = 1.0 # Maximum correlation\n    else:\n        rho = crlb_cov[0, 1] / np.sqrt(crlb_cov[0, 0] * crlb_cov[1, 1])\n        abs_rho = np.abs(rho)\n\n    # 5. Make identifiability decision\n    is_identifiable = bool(abs_rho  0.9 and log10_kappa  6)\n\n    return [abs_rho, log10_kappa, is_identifiable]\n\nsolve()\n```", "id": "2737391"}, {"introduction": "细胞群体并非整齐划一，理解其异质性是现代生物学的核心挑战之一。本高级练习将带你进入单细胞分析的前沿领域，处理模拟的ATAC和RNA联合测序数据。你将运用统计推断，将观察到的细胞间差异分解为两个部分：细胞内在的随机波动，以及由编辑效率不完美造成的群体异质性，从而更深刻地理解编辑干预的真实效果。[@problem_id:2737397]", "problem": "给定一个简化的单细胞多组学数据生成模型，该模型联合测量了在同质细胞群中进行表观遗传编辑干预后，单个目标位点的转座酶可及性染色质分析（ATAC）和核糖核酸（RNA）丰度。假定每个细胞处于两种潜伏状态之一：未编辑状态或已编辑状态。设细胞的二维观测读出值为向量 $y \\in \\mathbb{R}^2$，其中第一个坐标代表 ATAC 可及性，第二个坐标代表 RNA 表达，两者都经过对数尺度变换，使其无量纲。设隐藏状态为 $z \\in \\{0,1\\}$，其中 $\\mathbb{P}(z=1)=p \\in (0,1)$ 捕获了群体水平上的编辑完整性（例如，通过对编辑位点进行靶向基因分型来测量）。在给定 $z$ 的条件下，假定一个位置偏移的高斯模型，其状态内协方差相等：$y \\mid z=0 \\sim \\mathcal{N}(\\mu_0,\\Sigma_{\\text{intrinsic}})$ 和 $y \\mid z=1 \\sim \\mathcal{N}(\\mu_0 + d,\\Sigma_{\\text{intrinsic}})$，其中 $d \\in \\mathbb{R}^2$ 是由编辑引起的均值偏移，代表对 ATAC 和 RNA 的耦合效应，而 $\\Sigma_{\\text{intrinsic}} \\in \\mathbb{R}^{2 \\times 2}$ 捕获了已编辑和未编辑细胞共享的细胞内源性变异。假定内源性变异是各向同性的，即 $\\Sigma_{\\text{intrinsic}} = s^2 I_2$，其中 $s^2 \\ge 0$，$I_2$ 是 $2 \\times 2$ 单位矩阵。向量 $u \\in \\mathbb{R}^2$ 是一个已知的单位向量，代表编辑预期在 ATAC-RNA 联合空间中作用的方向，该方向由扰动设计或正交校准先验确定；效应向量 $d$ 假定与 $u$ 共线，即 $d = \\|d\\| u$。你可用于对单个靶点进行推断的唯一数据是从许多细胞中估计出的经验协方差矩阵 $S \\in \\mathbb{R}^{2 \\times 2}$、已知的 $p$ 和已知的单位向量 $u$。你的任务是，在上述模型和假设下，从第一性原理出发，推导一种方法，将观测到的变异性分解为由不完全编辑与细胞内源性变异所贡献的组分，然后实现它。\n\n你可以使用的基本事实和定义：分子生物学中心法则建立了从脱氧核糖核酸（DNA）到 RNA 再到蛋白质的因果链，而表观遗传编辑旨在改变染色质状态和转录。在数学上，你可以使用随机变量的全期望定律和全方差定律，以及多元正态分布的标准性质。除了这些基础原理外，不要假定任何其他公式。\n\n你的程序必须为每个测试用例，仅根据上述假设下的 $S$、$u$ 和 $p$ 计算以下量：\n- 编辑引起的位移的估计幅度 $\\|d\\|$，表示为非负实数。\n- 估计的内源性方差 $s^2$，表示为非负实数。\n- 一个异质性指数 $H$，定义为总方差（二维空间中总协方差的迹）中可归因于不完全编辑的部分，表示为 $[0,1]$ 区间内的实数。\n\n计算的重要要求和约定：\n- 设 $v_{\\perp} \\in \\mathbb{R}^2$ 表示与 $u$ 正交的任意单位向量。使用 $v_{\\perp} = (-u_2, u_1)$ 归一化为单位长度，其中 $u = (u_1,u_2)$。\n- 使用全方差定律将沿 $u$ 和沿 $v_{\\perp}$ 的状态内方差与状态间方差分开，并使用各向同性假设来识别 $s^2$。\n- 如果由于抽样噪声，数值估计得出沿 $u$ 的状态间贡献为负估计值，则将该贡献限制在 $0$ 以保持物理可解释性，并将此限制一致地传播到 $\\|d\\|$ 和 $H$ 的估计中。\n- 所有计算都是无量纲的。将所有输出表示为四舍五入到 $6$ 位小数的实数。\n\n用于检验您实现的一组参数值测试套件：\n- 情况 1 (一般情况，沿旋转轴对齐): $p = 0.5$, $u = \\left(\\frac{1}{\\sqrt{2}},\\frac{1}{\\sqrt{2}}\\right)$, $S = \\begin{bmatrix} 0.325  0.125 \\\\ 0.125  0.325 \\end{bmatrix}$。\n- 情况 2 (无可检测的编辑效应): $p = 0.6$, $u = (1.0, 0.0)$, $S = \\begin{bmatrix} 0.3  0.0 \\\\ 0.0  0.3 \\end{bmatrix}$。\n- 情况 3 (编辑完整性高，但未完成比例小): $p = 0.95$, $u = (0.6, 0.8)$, $S = \\begin{bmatrix} 0.138475  0.0513 \\\\ 0.0513  0.1684 \\end{bmatrix}$。\n- 情况 4 (边缘情况，沿 $u$ 的表观方差不超过正交方向): $p = 0.5$, $u = (1.0, 0.0)$, $S = \\begin{bmatrix} 0.19  0.0 \\\\ 0.0  0.2 \\end{bmatrix}$。\n- 情况 5 (沿斜向的强效应): $p = 0.3$, $u = (-0.8, 0.6)$, $S = \\begin{bmatrix} 0.115856  -0.049392 \\\\ -0.049392  0.087044 \\end{bmatrix}$。\n\n最终输出规格：\n- 对于每种情况，输出一个列表 $\\left[\\|d\\|, s^2, H\\right]$，其中每个条目都四舍五入到 $6$ 位小数。\n- 将所有情况的结果聚合到一行，作为一个用方括号括起来的逗号分隔列表，没有空格，其中每个元素是每个情况的列表。例如，整体输出格式必须是 $[[a_1,b_1,c_1],[a_2,b_2,c_2],\\dots]$ 的形式。", "solution": "该问题提出了一个有效的统计推断任务，该任务基于一个简化的表观遗传编辑生物物理模型。该模型假设细胞群体是未编辑 ($z=0$) 和已编辑 ($z=1$) 两种状态的混合体，具有已知的混合比例 $p = \\mathbb{P}(z=1)$。细胞的二维观测数据 $y \\in \\mathbb{R}^2$，包括转座酶可及性染色质分析 (ATAC) 和核糖核酸 (RNA) 读出值，由一个高斯混合模型建模。具体而言，条件分布由 $y \\mid z=0 \\sim \\mathcal{N}(\\mu_0, \\Sigma_{\\text{intrinsic}})$ 和 $y \\mid z=1 \\sim \\mathcal{N}(\\mu_0 + d, \\Sigma_{\\text{intrinsic}})$ 给出。内源性协方差假定为各向同性，$\\Sigma_{\\text{intrinsic}} = s^2 I_2$，编辑效应向量 $d$ 假定与已知单位向量 $u$ 共线，即 $d = \\|d\\|u$。我们已知观测数据 $y$ 的经验协方差矩阵 $S$、编辑概率 $p$ 和效应方向向量 $u$。任务是从第一性原理出发，推导一种估计编辑效应幅度 $\\|d\\|$、内源性方差 $s^2$ 和异质性指数 $H$ 的方法。\n\n推导过程通过应用全方差定律，将模型参数与可观测的总协方差矩阵 $\\Sigma_y$ 联系起来，后者由经验协方差矩阵 $S$ 估计。全方差定律表述为：\n$$\n\\Sigma_y = \\text{Var}(y) = \\mathbb{E}[\\text{Var}(y|z)] + \\text{Var}(\\mathbb{E}[y|z])\n$$\n\n第一项 $\\mathbb{E}[\\text{Var}(y|z)]$ 代表平均状态内协方差。鉴于状态内协方差 $\\text{Var}(y|z) = \\Sigma_{\\text{intrinsic}} = s^2 I_2$ 对于两种状态 $z=0$ 和 $z=1$ 是相同的，其关于 $z$ 的期望很简单：\n$$\n\\mathbb{E}[\\text{Var}(y|z)] = (1-p)(s^2 I_2) + p(s^2 I_2) = s^2 I_2\n$$\n\n第二项 $\\text{Var}(\\mathbb{E}[y|z])$ 代表状态间协方差，它源于状态间均值向量的差异。条件均值向量为 $\\mathbb{E}[y|z=0] = \\mu_0$ 和 $\\mathbb{E}[y|z=1] = \\mu_0 + d$。随机变量 $\\mathbb{E}[y|z]$ 分别以概率 $1-p$ 和 $p$ 取这两个向量值。该随机变量的均值为 $\\mathbb{E}_{\\!z}[\\mathbb{E}_y[y|z]] = (1-p)\\mu_0 + p(\\mu_0+d) = \\mu_0 + pd$。方差则计算如下：\n$$\n\\begin{aligned}\n\\text{Var}(\\mathbb{E}[y|z]) = (1-p)(\\mu_0 - (\\mu_0+pd))(\\mu_0 - (\\mu_0+pd))^T + p((\\mu_0+d) - (\\mu_0+pd))((\\mu_0+d) - (\\mu_0+pd))^T \\\\\n= (1-p)(-pd)(-pd)^T + p((1-p)d)((1-p)d)^T \\\\\n= (1-p)p^2 dd^T + p(1-p)^2 dd^T \\\\\n= p(1-p)(p + (1-p)) dd^T \\\\\n= p(1-p) dd^T\n\\end{aligned}\n$$\n\n结合这两个分量，总的理论协方差矩阵是：\n$$\n\\Sigma_y = s^2 I_2 + p(1-p) dd^T\n$$\n代入假设 $d = \\|d\\|u$，其中 $u$ 是单位向量：\n$$\n\\Sigma_y = s^2 I_2 + p(1-p)\\|d\\|^2 uu^T\n$$\n我们将这个理论协方差与经验协方差矩阵 $S$ 等同起来，作为我们估计程序的基础。为了求解两个标量未知数 $s^2$ 和 $\\|d\\|$，我们将协方差矩阵投影到由效应方向 $u$ 及其正交向量 $v_{\\perp}$ 定义的标准正交基上。数据投影到任意单位向量 $v$ 上的方差由 $v^T S v$ 给出。将此应用于我们的模型 $S \\approx \\Sigma_y$：\n$$\nv^T S v \\approx v^T(s^2 I_2 + p(1-p)\\|d\\|^2 uu^T)v = s^2(v^T v) + p(1-p)\\|d\\|^2 (v^T u)(u^T v) = s^2 + p(1-p)\\|d\\|^2 (v \\cdot u)^2\n$$\n我们选择 $v = v_{\\perp}$，一个与 $u$ 正交的单位向量。对于这个选择，$v_{\\perp} \\cdot u = 0$。投影方差为：\n$$\n\\sigma^2_{\\perp} = v_{\\perp}^T S v_{\\perp} = s^2 + 0 = s^2\n$$\n这为内源性方差提供了一个直接的估计量：$\\hat{s}^2 = v_{\\perp}^T S v_{\\perp}$。由于 $S$ 是半正定矩阵，$\\hat{s}^2$ 保证是非负的。\n\n接下来，我们选择 $v = u$。由于 $u$ 是单位向量，$u \\cdot u = 1$。沿 $u$ 的投影方差是：\n$$\n\\sigma^2_u = u^T S u = s^2 + p(1-p)\\|d\\|^2\n$$\n项 $p(1-p)\\|d\\|^2$ 表示由状态混合所增加的方差，投影在均值偏移的方向上。我们可以通过代入我们对 $s^2$ 的估计量来解出这一项：\n$$\np(1-p)\\|d\\|^2 = \\sigma^2_u - s^2 = u^T S u - v_{\\perp}^T S v_{\\perp}\n$$\n由于 $S$ 中的抽样变异性，项 $u^T S u - v_{\\perp}^T S v_{\\perp}$ 可能是负的。由于方差不能为负，我们将此估计值限制在零。设 $\\hat{V}_{between, u}$ 为沿 $u$ 方向的估计的状态间方差贡献：\n$$\n\\hat{V}_{between, u} = \\max(0, u^T S u - v_{\\perp}^T S v_{\\perp})\n$$\n由此，我们估计效应向量的幅度 $\\|d\\|$。因为 $p \\in (0,1)$，所以 $p(1-p)>0$：\n$$\n\\|\\hat{d}\\| = \\sqrt{\\frac{\\hat{V}_{between, u}}{p(1-p)}}\n$$\n最后，我们计算异质性指数 $H$，定义为可归因于不完全编辑的总方差的比例。总方差是协方差矩阵的迹，$\\text{Tr}(S)$。可归因于编辑的方差是状态间协方差分量的迹，$\\text{Tr}(p(1-p)dd^T)$。利用迹的循环性质，$\\text{Tr}(dd^T) = \\text{Tr}(d^T d) = \\|d\\|^2$，这变为 $p(1-p)\\|d\\|^2$。因此，$H$ 的估计量是我们估计的状态间方差与总方差的比率：\n$$\n\\hat{H} = \\frac{\\hat{V}_{between, u}}{\\text{Tr}(S)}\n$$\n恒等式 $\\text{Tr}(S) = u^T S u + v_{\\perp}^T S v_{\\perp}$ 证实了总方差是沿标准正交基向量的投影方差之和，从而确保 $\\hat{H} \\in [0,1]$。\n这就完成了 $\\|d\\|$、$s^2$ 和 $H$ 的估计量的推导。该过程在提供的 Python 代码中实现。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the variance decomposition problem for a series of test cases.\n    \"\"\"\n    # Test suite of parameter values.\n    # Each case is a tuple: (p, u, S)\n    test_cases = [\n        (0.5, np.array([1/np.sqrt(2), 1/np.sqrt(2)]), np.array([[0.325, 0.125], [0.125, 0.325]])),\n        (0.6, np.array([1.0, 0.0]), np.array([[0.3, 0.0], [0.0, 0.3]])),\n        (0.95, np.array([0.6, 0.8]), np.array([[0.138475, 0.0513], [0.0513, 0.1684]])),\n        (0.5, np.array([1.0, 0.0]), np.array([[0.19, 0.0], [0.0, 0.2]])),\n        (0.3, np.array([-0.8, 0.6]), np.array([[0.115856, -0.049392], [-0.049392, 0.087044]]))\n    ]\n\n    results = []\n    \n    for p, u, S in test_cases:\n        # Define the unit vector orthogonal to u.\n        # For u = (u1, u2), v_perp = (-u2, u1) is orthogonal and has the same length.\n        # Since u is a unit vector, v_perp is also a unit vector.\n        v_perp = np.array([-u[1], u[0]])\n\n        # Calculate the variance of the data projected onto u and v_perp.\n        # var(v^T y) = v^T S v\n        sigma_sq_u = u.T @ S @ u\n        sigma_sq_perp = v_perp.T @ S @ v_perp\n\n        # 1. Estimate intrinsic variance s^2.\n        # s^2 is the variance in the direction orthogonal to the effect.\n        s_squared_hat = sigma_sq_perp\n\n        # 2. Estimate the magnitude of the editing-induced shift ||d||.\n        # The between-state variance contribution along u is V_between_u = sigma_sq_u - s^2.\n        # It must be non-negative, so we clamp at 0.\n        V_between_u_hat = max(0, sigma_sq_u - s_squared_hat)\n        \n        # Denominator p*(1-p) for calculating ||d||^2.\n        p_factor = p * (1 - p)\n        \n        # Calculate ||d||. Handle potential division by zero although p is in (0,1).\n        if p_factor > 0:\n            d_norm_hat = np.sqrt(V_between_u_hat / p_factor)\n        else:\n            d_norm_hat = 0.0\n\n        # 3. Estimate the heterogeneity index H.\n        # H is the fraction of total variance (Tr(S)) from between-state variance.\n        # Total variance Tr(S) can also be computed as sigma_sq_u + sigma_sq_perp.\n        total_variance = np.trace(S)\n        \n        if total_variance > 0:\n            H_hat = V_between_u_hat / total_variance\n        else:\n            H_hat = 0.0\n\n        # Collect results, rounded to 6 decimal places.\n        results.append([\n            round(d_norm_hat, 6),\n            round(s_squared_hat, 6),\n            round(H_hat, 6)\n        ])\n\n    # Format the final output string as specified.\n    # e.g., [[a1,b1,c1],[a2,b2,c2],...]\n    output_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]},{r[2]}]\" for r in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "2737397"}]}