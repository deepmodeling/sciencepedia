{"hands_on_practices": [{"introduction": "合成致死（synthetic lethality）是揭示基因功能关系和指导基因组简化的核心概念。本练习旨在建立一个量化框架，从适应性数据出发，定义并测量基因间的相互作用。通过这个练习，你将把合成致死的定性概念与精确的数学定义联系起来，这是理解和设计遗传回路的关键一步（[@problem_id:2741623]）。", "problem": "一项在模式细菌中进行的基因组最小化研究将生长量化为细胞数量的指数增长 $N(t) = N_{0}\\exp(r t)$，其中 $r$ 是马尔萨斯增长率。突变体的相对适应度 $w$ 定义为其增长率与野生型增长率之比。假设在没有遗传相互作用（无上位性）的情况下，两个基因缺失 $A$ 和 $B$ 对相对适应度的综合效应是乘积性的。在成对必需基因图谱筛选中，合成致死在操作上定义为生长表型低于检测阈值 $w  \\tau$（$\\tau$ 由实验指定）而无法检测到，而每个单一缺失株仍高于该阈值。\n\n仅从这些定义和假设出发，完成以下任务：\n- 推导缺失 $A$ 和 $B$ 之间的上位性参数 $\\epsilon$ 的表达式，其表示观测到的双缺失相对适应度与独立性期望的偏差。\n- 使用基于阈值的合成致死定义，推导一个以 $\\epsilon$、$w_{A}$、$w_{B}$ 和 $\\tau$ 表示的不等式，该不等式保证即使两个单一缺失株都存活，也会发生合成致死。\n- 一个特定的数据集报告了指数增长率 $r_{\\mathrm{WT}} = 1.00\\,\\mathrm{h}^{-1}$、$r_{A} = 0.80\\,\\mathrm{h}^{-1}$ 和 $r_{B} = 0.85\\,\\mathrm{h}^{-1}$。双缺失株未显示可检测到的生长，因此在计算中可以取 $w_{AB} \\approx 0$。计算该数据集的 $\\epsilon$ 的数值。报告你的 $\\epsilon$ 的最终数值答案（无量纲）。将答案四舍五入至四位有效数字。", "solution": "在尝试解答之前，将对所述问题进行验证。\n\n**步骤1：提取已知条件**\n- 细胞生长模型：$N(t) = N_{0}\\exp(r t)$，其中 $r$ 是马尔萨斯增长率。\n- 相对适应度 $w$ 的定义：突变体增长率与野生型增长率之比。\n- 无上位性的假设：两个基因缺失 $A$ 和 $B$ 对相对适应度的综合效应是乘积性的。\n- 合成致死的定义：双突变体表型的相对适应度 $w  \\tau$（其中 $\\tau$ 是检测阈值），而每个单一缺失株的相对适应度均高于该阈值。\n- 任务1：推导上位性参数 $\\epsilon$ 的表达式，其表示观测到的双缺失相对适应度与独立性期望的偏差。\n- 任务2：推导一个以 $\\epsilon$、$w_{A}$、$w_{B}$ 和 $\\tau$ 表示的合成致死不等式。\n- 任务3：对于增长率为 $r_{\\mathrm{WT}} = 1.00\\,\\mathrm{h}^{-1}$、$r_{A} = 0.80\\,\\mathrm{h}^{-1}$、$r_{B} = 0.85\\,\\mathrm{h}^{-1}$ 的数据集，在双缺失株无可见生长（即 $w_{AB} \\approx 0$）的假设下，计算 $\\epsilon$ 的数值。$\\epsilon$ 的最终值必须四舍五入至四位有效数字。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据。马尔萨斯增长、相对适应度、乘积性上位性模型和合成致死的概念在数量遗传学和合成生物学中是标准且成熟的。问题阐述清晰，提供了进行推导和计算所需的所有必要定义和数据。语言客观、精确。没有矛盾、信息缺失或伪科学论断。该问题是应用基本生物学原理的一个有效且可形式化的练习。\n\n**结论与行动：**\n问题有效。将提供完整解答。\n\n**解答推导**\n\n解答需要依次推导上位性参数、合成致死的条件，并进行数值计算。\n\n首先，我们形式化相对适应度的定义。突变体的相对适应度是其马尔萨斯增长率 $r_{\\mathrm{mut}}$ 与野生型增长率 $r_{\\mathrm{WT}}$ 之比。对于单基因缺失 $A$，相对适应度为 $w_{A}$。对于单基因缺失 $B$，相对适应度为 $w_{B}$。对于双缺失 $AB$，相对适应度为 $w_{AB}$。\n$$w_{A} = \\frac{r_{A}}{r_{\\mathrm{WT}}}$$\n$$w_{B} = \\frac{r_{B}}{r_{\\mathrm{WT}}}$$\n$$w_{AB} = \\frac{r_{AB}}{r_{\\mathrm{WT}}}$$\n野生型菌株的相对适应度为 $w_{\\mathrm{WT}} = \\frac{r_{\\mathrm{WT}}}{r_{\\mathrm{WT}}} = 1$。\n\n**任务1：上位性参数 $\\epsilon$ 的推导**\n问题陈述，在没有遗传相互作用（上位性）的情况下，两个缺失对相对适应度的综合效应是乘积性的。这为独立性建立了零假设。在无上位性的假设下，双突变体 $AB$ 的期望相对适应度（记为 $w_{AB, \\text{exp}}$）因此是各单个相对适应度值的乘积：\n$$w_{AB, \\text{exp}} = w_{A} w_{B}$$\n上位性参数 $\\epsilon$ 定义为观测到的双缺失相对适应度 $w_{AB}$ 与此独立性期望之间的偏差。该偏差计算为观测值与期望值之差。\n$$\\epsilon = w_{AB} - w_{AB, \\text{exp}}$$\n代入期望适应度的表达式，我们得到乘积性上位性参数的正式表达式：\n$$\\epsilon = w_{AB} - w_{A} w_{B}$$\n这个方程量化了遗传相互作用。如果 $\\epsilon = 0$，则基因不发生相互作用。如果 $\\epsilon > 0$，则相互作用是正向的（缓解效应）。如果 $\\epsilon  0$，则相互作用是负向的（加重效应）。\n\n**任务2：合成致死不等式的推导**\n合成致死由一组条件定义。单一缺失株必须是存活的，意味着它们的生长是可检测的。这在操作上定义为其相对适应度高于检测阈值 $\\tau$。\n$$w_{A} > \\tau \\quad \\text{and} \\quad w_{B} > \\tau$$\n然而，双缺失株必须是致死的或具有不可检测的生长表型。这定义为其相对适应度低于同一阈值 $\\tau$。\n$$w_{AB}  \\tau$$\n为了找到一个以 $\\epsilon$ 表示的不等式，我们使用推导出的上位性表达式来重写 $w_{AB}$。从 $\\epsilon = w_{AB} - w_{A} w_{B}$，我们可以将观测到的双突变体适应度表示为：\n$$w_{AB} = w_{A} w_{B} + \\epsilon$$\n将此代入双缺失表型的条件中，得到：\n$$w_{A} w_{B} + \\epsilon  \\tau$$\n整理这个不等式以分离出 $\\epsilon$，得到保证合成致死的条件（前提是单突变体存活）：\n$$\\epsilon  \\tau - w_{A} w_{B}$$\n该不等式指明了，对于给定的单突变体适应度值对和给定的检测阈值，产生合成致死相互作用所需的负上位性的大小。\n\n**任务3：$\\epsilon$ 的数值计算**\n问题提供了以下数据：\n- 野生型增长率：$r_{\\mathrm{WT}} = 1.00\\,\\mathrm{h}^{-1}$\n- 单突变体 A 增长率：$r_{A} = 0.80\\,\\mathrm{h}^{-1}$\n- 单突变体 B 增长率：$r_{B} = 0.85\\,\\mathrm{h}^{-1}$\n- 双突变体 $AB$ 未显示可检测到的生长，这意味着其相对适应度 $w_{AB}$ 约等于零：$w_{AB} \\approx 0$。\n\n首先，我们计算单个突变体的相对适应度：\n$$w_{A} = \\frac{r_{A}}{r_{\\mathrm{WT}}} = \\frac{0.80\\,\\mathrm{h}^{-1}}{1.00\\,\\mathrm{h}^{-1}} = 0.80$$\n$$w_{B} = \\frac{r_{B}}{r_{\\mathrm{WT}}} = \\frac{0.85\\,\\mathrm{h}^{-1}}{1.00\\,\\mathrm{h}^{-1}} = 0.85$$\n现在我们使用给定的值代入 $\\epsilon$ 的表达式：\n$$\\epsilon = w_{AB} - w_{A} w_{B}$$\n代入数值：\n$$\\epsilon \\approx 0 - (0.80)(0.85)$$\n单突变体适应度值的乘积是：\n$$(0.80)(0.85) = 0.68$$\n因此，上位性参数是：\n$$\\epsilon \\approx -0.68$$\n问题要求答案报告为四位有效数字。输入数据（$r_A$ 和 $r_B$ 有两位有效数字）的精度通常会将结果的精度限制为两位有效数字。然而，遵循明确的指令，我们通过添加尾随零来报告该值。\n$$\\epsilon = -0.6800$$\n这个强烈的负上位性值是合成致死相互作用的典型特征。", "answer": "$$\\boxed{-0.6800}$$", "id": "2741623"}, {"introduction": "流平衡分析（Flux Balance Analysis, FBA）是一种强大的计算工具，能够从基因型层面预测代谢表型。通过系统地模拟移除单个反应（即基因的生化功能），我们可以在计算机上筛选出对于特定细胞目标（如生长）至关重要的基因。本练习将让你亲手实践这种基础的 *in silico*（计算机模拟）筛选方法，这是在系统层面鉴定必需基因的常用策略（[@problem_id:2741599]）。", "problem": "给定一个处于稳态的代谢网络的标准流量平衡分析 (FBA) 设置，其中反应流量由向量 $v \\in \\mathbb{R}^{n}$ 表示，内部代谢物的质量平衡由化学计量矩阵 $S \\in \\mathbb{R}^{m \\times n}$ 编码。稳态假设意味着 $S v = 0$。反应边界满足 $l \\le v \\le u$，其中 $l, u \\in \\mathbb{R}^{n}$ 且对于所有索引 $i \\in \\{0,\\ldots,n-1\\}$ 都有 $l_i \\le u_i$。一个线性目标 $c^{\\top} v$ 代表一个选定的细胞目标（如生长），其中 $c \\in \\mathbb{R}^{n}$。对索引 $j$ 的反应“敲除”是在现有约束之外强制执行 $v_j = 0$。定义一个阈值 $\\mu_0 \\in \\mathbb{R}$，如果反应 $j$ 在敲除 $v_j = 0$ 的条件下，$c^{\\top} v$ 的最优值严格小于 $\\mu_0$，则称该反应是 $\\mu_0$-必需的。为避免平凡分类，如果未受扰动问题（无敲除）的最优值严格小于 $\\mu_0$，则按照惯例返回空集（在这种情况下，没有反应被报告为 $\\mu_0$-必需的）。\n\n从稳态质量守恒 $S v = 0$、边界 $l \\le v \\le u$ 以及反应敲除的定义 $v_j = 0$ 出发，为每个反应 $j$ 构建一个用于判断 $\\mu_0$-必需性的线性规划 (LP) 问题。实现一个算法，在给定 $(S,l,u,c,\\mu_0)$ 的情况下，返回作为 $\\mu_0$-必需的反应的从零开始的索引 $j$ 的排序列表。\n\n您的实现必须求解 LP\n$$\n\\max_{v \\in \\mathbb{R}^{n}} \\; c^{\\top} v \\quad \\text{subject to} \\quad S v = 0,\\;\\; l \\le v \\le u\n$$\n以获得未受扰动的最优值，并对每个反应敲除索引 $j \\in \\{0,\\ldots,n-1\\}$，求解\n$$\n\\max_{v \\in \\mathbb{R}^{n}} \\; c^{\\top} v \\quad \\text{subject to} \\quad S v = 0,\\;\\; l \\le v \\le u,\\;\\; v_j = 0.\n$$\n使用严格比较“$$”来测试敲除后的最优值是否低于 $\\mu_0$。如果未受扰动的最优值严格小于 $\\mu_0$，则按照惯例返回空集。\n\n测试套件。使用以下测试用例，每个用例由 $(S,l,u,c,\\mu_0)$ 指定，所有数组均以行主序给出。下面定义中的所有数字都是精确实数。\n\n- 测试用例 $1$（冗余通路，阈值等于野生型最优值）：\n  $$\n  S_1 =\n  \\begin{bmatrix}\n  1  -1  0  -1  -1 \\\\\n  0  1  -1  0  1\n  \\end{bmatrix},\\quad\n  l_1 = \\begin{bmatrix} 0  0  0  0  0 \\end{bmatrix},\\quad\n  u_1 = \\begin{bmatrix} 10  1000  1000  1000  1000 \\end{bmatrix},\n  $$\n  $$\n  c_1 = \\begin{bmatrix} 0  0  1  0  0 \\end{bmatrix},\\quad\n  \\mu_{0,1} = 10.\n  $$\n  反应按 $S_1$ 的列排序：索引 $0$ 是摄取，索引 $2$ 是目标流出。\n\n- 测试用例 $2$（相同网络，零阈值）：\n  $$\n  S_2 = S_1,\\;\\; l_2 = l_1,\\;\\; u_2 = u_1,\\;\\; c_2 = c_1,\\;\\; \\mu_{0,2} = 0.\n  $$\n\n- 测试用例 $3$（存在阻塞反应，阈值等于野生型最优值）：\n  $$\n  S_3 = \\begin{bmatrix} 1  -1  -1 \\end{bmatrix},\\quad\n  l_3 = \\begin{bmatrix} 0  0  0 \\end{bmatrix},\\quad\n  u_3 = \\begin{bmatrix} 1  1000  0 \\end{bmatrix},\\quad\n  c_3 = \\begin{bmatrix} 0  1  0 \\end{bmatrix},\\quad\n  \\mu_{0,3} = 1.\n  $$\n\n- 测试用例 $4$（阈值高于野生型最优值，按惯例返回空集）：\n  $$\n  S_4 = S_3,\\;\\; l_4 = l_3,\\;\\; u_4 = u_3,\\;\\; c_4 = c_3,\\;\\; \\mu_{0,4} = 2.\n  $$\n\n您的程序必须为每个测试用例计算在所述惯例下是 $\\mu_0$-必需的反应的从零开始的索引的排序列表。最终输出格式为单行，其中包含所有测试用例的结果，形式为方括号括起来的逗号分隔列表。对应于一个测试用例的每个元素本身也应该是一个整数列表。例如，一个包含四个测试用例的有效输出可能如下所示\n$[ [0,2], [], [0,1], [] ]$。\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[result1,result2,result3,result4]$）。本问题不涉及单位。不涉及角度。任何地方都不得使用百分比；如果需要，任何比例都必须表示为小数。", "solution": "对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- 化学计量矩阵：$S \\in \\mathbb{R}^{m \\times n}$\n- 反应流量向量：$v \\in \\mathbb{R}^{n}$\n- 稳态方程：$S v = 0$\n- 流量边界：$l \\le v \\le u$，其中 $l, u \\in \\mathbb{R}^{n}$ 且对于 $i \\in \\{0,\\ldots,n-1\\}$ 有 $l_i \\le u_i$\n- 线性目标函数：最大化 $c^{\\top} v$，其中 $c \\in \\mathbb{R}^{n}$\n- 索引 $j$ 的反应敲除：$v_j = 0$\n- 必需性阈值：$\\mu_0 \\in \\mathbb{R}$\n- $\\mu_0$-必需性的定义：如果在约束 $v_j=0$ 下，$c^{\\top} v$ 的最优值严格小于 $\\mu_0$，则反应 $j$ 是 $\\mu_0$-必需的。\n- 惯例：如果未受扰动的最优值严格小于 $\\mu_0$，则 $\\mu_0$-必需反应的集合为空。\n- 任务：给定 $(S,l,u,c,\\mu_0)$，找到 $\\mu_0$-必需反应的从零开始的索引的排序列表。\n- 问题提供了四个具体的测试用例，包含 $(S,l,u,c,\\mu_0)$ 的数值。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据**：该问题是使用流量平衡分析 (FBA) 的标准“计算机模拟”单基因/反应敲除分析。FBA 是代谢网络基于约束建模的基石。整个公式根植于化学计量学、质量平衡和数学优化的既定原则。它是科学上有效的。\n- **良构性**：该问题需要求解一系列线性规划 (LP)。一个通过在线性等式和不等式描述的可行域上最大化线性目标来定义的 LP 是一个良构的数学问题。可行域 $P = \\{v \\in \\mathbb{R}^n \\mid Sv=0, l \\le v \\le u\\}$ 是一个凸多面体。如果 $P$ 是非空且有界的（这在具有受限摄取的代谢模型中是典型情况），则保证存在最优解。必需性的标准是用数学精度（严格不等式）定义的，没有歧义。该问题是良构的。\n- **客观性**：问题陈述使用了精确的数学语言和定义。所有术语都经过了形式化指定。没有主观或非科学内容。\n\n**步骤3：结论与行动**\n该问题是有效的。这是一个基于可靠的科学和数学原理的、定义明确的计算任务。将提供一个算法解决方案。\n\n**基于原则的解决方案设计**\n\n任务是识别代谢网络中的 $\\mu_0$-必需反应。这是通过系统地模拟每个反应的敲除，并观察其对细胞目标（如生物质生产）的影响来实现的。整个过程是一个基于线性规划 (LP) 的计算工作流。\n\n**1. 线性规划公式**\n分析的核心是求解以下形式的 LP：\n$$\n\\max_{v \\in \\mathbb{R}^{n}} \\; c^{\\top} v \\quad \\text{subject to} \\quad S v = 0,\\;\\; l \\le v \\le u\n$$\n标准 LP 求解器（如 `scipy.optimize.linprog`）被设计用于解决最小化问题。最大化问题 $\\max c^{\\top}v$ 等价于最小化问题 $\\min (-c)^{\\top}v$。因此，我们将求解：\n$$\n\\min_{v \\in \\mathbb{R}^{n}} \\; (-c)^{\\top} v \\quad \\text{subject to} \\quad S v = 0,\\;\\; l \\le v \\le u\n$$\n约束按如下方式处理：\n- 等式约束 $S v = 0$ 直接作为 `A_eq`$=S$ 和 `b_eq`$=0$ 传递给求解器。\n- 不等式约束 $l \\le v \\le u$ 作为变量向量 $v$ 的逐元素边界传递。\n\n**2. 算法流程**\n该算法分三个主要阶段进行：\n\n**阶段 A：分析未受扰动的系统**\n首先，我们求解原始、未受扰动网络的 LP，以确定最大可能的目标值，我们将其表示为 $z_{wt}$。\n$$\nz_{wt} = \\max_{v} \\{c^{\\top}v \\mid Sv=0, l \\le v \\le u\\}\n$$\n该值作为野生型生物体性能的基线。\n\n**阶段 B：应用必需性惯例**\n问题指定了一个惯例来处理野生型性能已经低于阈值的情况。如果 $z_{wt}  \\mu_0$，我们立即得出结论，相对于此阈值，没有任何反应可以被有意义地分类为必需的，并且算法必须返回一个空的索引集。\n\n**阶段 C：分析单反应敲除**\n如果 $z_{wt} \\ge \\mu_0$，我们继续单独测试每个反应。对于每个反应索引 $j \\in \\{0, \\ldots, n-1\\}$：\n1.  **构建敲除 LP**：通过添加约束 $v_j = 0$ 来模拟敲除。最简单的方法是修改反应 $j$ 的边界为 $[0, 0]$，即 $l'_j = u'_j = 0$。\n2.  **求解敲除 LP**：我们求解修改后的 LP，以找到敲除条件下的最优目标值 $z_{ko,j}$。\n    $$\n    z_{ko,j} = \\max_{v} \\{c^{\\top}v \\mid Sv=0, l \\le v \\le u, v_j=0\\}\n    $$\n3.  **测试必需性**：我们应用 $\\mu_0$-必需性的定义。如果 $z_{ko,j}  \\mu_0$，则反应 $j$ 被视为必需的，并将其索引添加到我们的结果列表中。\n\n如果一个敲除使得 LP 不可行，即不存在可能的稳态流量分布，则会出现一个特殊情况。在这种情况下，该反应对网络的完整性至关重要。目标值实际上是 $-\\infty$，它严格小于任何有限的 $\\mu_0$。因此，根据定义，任何其敲除导致问题不可行的反应都是 $\\mu_0$-必需的。我们的实现必须正确处理 LP 求解器返回的“不可行”状态。\n\n最终输出将是所有被识别为必需的索引 $j$ 的列表。由于反应是按其索引的递增顺序进行测试的，因此结果列表将自然排序。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and compute the final result.\n    \"\"\"\n\n    # Test Case 1\n    S1 = np.array([\n        [1, -1, 0, -1, -1],\n        [0, 1, -1, 0, 1]\n    ])\n    l1 = np.array([0, 0, 0, 0, 0])\n    u1 = np.array([10, 1000, 1000, 1000, 1000])\n    c1 = np.array([0, 0, 1, 0, 0])\n    mu0_1 = 10.0\n\n    # Test Case 2\n    S2, l2, u2, c2 = S1, l1, u1, c1\n    mu0_2 = 0.0\n\n    # Test Case 3\n    S3 = np.array([[1, -1, -1]])\n    l3 = np.array([0, 0, 0])\n    u3 = np.array([1, 1000, 0])\n    c3 = np.array([0, 1, 0])\n    mu0_3 = 1.0\n\n    # Test Case 4\n    S4, l4, u4, c4 = S3, l3, u3, c3\n    mu0_4 = 2.0\n\n    test_cases = [\n        (S1, l1, u1, c1, mu0_1),\n        (S2, l2, u2, c2, mu0_2),\n        (S3, l3, u3, c3, mu0_3),\n        (S4, l4, u4, c4, mu0_4),\n    ]\n\n    def _solve_lp(c, S, l, u, knockout_idx=None):\n        \"\"\"\n        Helper function to solve the FBA linear program.\n        Maximizes c^T v subject to Sv=0 and l = v = u.\n        A knockout sets the flux of a specific reaction to zero.\n        Returns the optimal objective value, or -np.inf if infeasible.\n        \"\"\"\n        # We use linprog to minimize, so we minimize (-c)^T v\n        c_min = -np.array(c, dtype=float)\n        \n        # Prepare constraints\n        S_mat = np.array(S, dtype=float)\n        m, n = S_mat.shape\n        b_eq = np.zeros(m)\n        \n        # Prepare bounds\n        bounds = list(zip(l, u))\n        if knockout_idx is not None:\n            # Enforce v_j = 0 by setting bounds to (0, 0)\n            bounds[knockout_idx] = (0.0, 0.0)\n\n        # Solve the LP\n        res = linprog(c=c_min, A_eq=S_mat, b_eq=b_eq, bounds=bounds, method='highs')\n\n        # Return objective value for the maximization problem\n        if res.success:\n            return -res.fun\n        else:\n            # If infeasible (status=2) or another error, the maximum objective value \n            # is effectively negative infinity.\n            return -np.inf\n\n    def find_essential_reactions(S, l, u, c, mu_0):\n        \"\"\"\n        Identifies mu_0-essential reactions based on the problem definition.\n        \"\"\"\n        num_reactions = len(c)\n        \n        # 1. Solve the unperturbed (wild-type) problem\n        opt_wt = _solve_lp(c, S, l, u)\n        \n        # 2. Apply the convention for trivial classification\n        # We use a small tolerance for floating point comparisons to be robust,\n        # although direct comparison works for the given test cases.\n        # The problem asks for \"strictly less than\".\n        if opt_wt  mu_0:\n            return []\n            \n        essential_indices = []\n        # 3. Iterate through all possible single-reaction knockouts\n        for j in range(num_reactions):\n            opt_ko = _solve_lp(c, S, l, u, knockout_idx=j)\n            \n            # 4. Check if the knockout objective is strictly less than the threshold\n            if opt_ko  mu_0:\n                essential_indices.append(j)\n                \n        # The list is already sorted as we iterate from 0 to n-1.\n        return essential_indices\n\n    results = []\n    for case in test_cases:\n        S, l, u, c, mu_0 = case\n        result = find_essential_reactions(S, l, u, c, mu_0)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The output should be a string representation of a list of lists, with no spaces.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n\n```", "id": "2741599"}, {"introduction": "基因组简化的最终目标之一是设计出功能可靠的最小化“底盘细胞”。本练习将引导你从“分析”（在给定系统中识别必需基因）转向“综合”（设计能满足特定性能指标的最小系统）。你将接触到一种更高级的优化技术——混合整数线性规划（Mixed-Integer Linear Programming, MILP），来解决这个合成生物学中的核心设计难题（[@problem_id:2741604]）。", "problem": "给定一个稳态代谢网络，旨在基因组最小化和必需基因定位的背景下，模拟一个支持最小生长需求的反应子集。该代谢模型遵循稳态下的质量平衡、分子生物学中心法则（DNA到RNA到蛋白质）以及流平衡分析（FBA）。稳态假设要求对于一个胞内代谢物池，其净产生速率在时间上等于其净消耗速率。在网络表示中，这通过一个化学计量矩阵 $S \\in \\mathbb{R}^{m \\times J}$ 和一个通量向量 $v \\in \\mathbb{R}^{J}$ 来体现，并满足稳态约束 $S v = 0$。每个反应 $j$ 都有下界和上界 $l_j \\le v_j \\le u_j$，这些边界反映了热力学和容量的约束。为了在基因组最小化的背景下模拟反应活性，引入二进制变量 $z_j \\in \\{0,1\\}$，用以指示反应 $j$ 是否允许有通量（$z_j = 1$）或被强制为零（$z_j = 0$）。通过大M约束 $\\lvert v_j \\rvert \\le M z_j$ 来强制执行活性，其中 $M$ 是一个足够大的常数，其值不小于所有反应中绝对边界值的最大值。生长由一个指定的生物质反应来量化，该反应索引为 $j^\\star$，其通量为 $v_{j^\\star} = \\mu$，单位为 $\\text{h}^{-1}$。目标是在达到目标生长速率 $\\mu_0$ 的同时，最小化活跃反应的数量。\n\n形式上，对于一个给定的实例，考虑由变量 $v \\in \\mathbb{R}^{J}$ 和 $z \\in \\{0,1\\}^{J}$ 定义的混合整数线性规划（MILP）问题：\n- 最小化 $\\sum_{j=1}^{J} z_j$，\n- 约束条件为 $S v = 0$，\n- 对所有 $j \\in \\{1,\\dots,J\\}$，满足 $l_j \\le v_j \\le u_j$，\n- 对所有 $j \\in \\{1,\\dots,J\\}$，满足 $-M z_j \\le v_j \\le M z_j$，\n- $v_{j^\\star} \\ge \\mu_0$。\n\n您的任务是编写一个程序，为每个提供的测试用例，通过枚举二进制向量 $z \\in \\{0,1\\}^{J}$ 来精确求解上述 MILP 问题。对于每个 $z$，在上述约束条件下求解关于 $v$ 的一个可行性线性规划（LP）问题，然后返回所有可行 $z$ 中最小的 $\\sum_j z_j$。如果没有 $z$ 能产生满足 $v_{j^\\star} \\ge \\mu_0$ 的可行 $v$，则返回 $-1$。程序必须使用下面给出的单一、一致的化学计量矩阵 $S$；每个测试用例仅边界和生长阈值不同。\n\n网络定义（所有测试用例共用）：\n- 代谢物：胞内 $A$ 和 $B$ ($m = 2$）。\n- 反应（$J = 5$），按 $[v_0, v_1, v_2, v_3, v_4]$ 排序，其生化含义如下：\n  - $v_0$：摄取反应 $A_{\\text{ext}} \\rightarrow A$，\n  - $v_1$：途径 $A \\rightarrow B$（酶 1），\n  - $v_2$：途径 $A \\rightarrow B$（酶 2），\n  - $v_3$：可逆互变 $A \\leftrightarrow B$（当 $v_3  0$ 时模拟为 $B \\rightarrow A$，当 $v_3  0$ 时模拟为 $A \\rightarrow B$），\n  - $v_4$：生物质反应 $B \\rightarrow \\text{Biomass}$，其中 $j^\\star = 4$，因此 $v_4 = \\mu$。\n- 化学计量矩阵 $S \\in \\mathbb{R}^{2 \\times 5}$，其行按 $[A, B]$ 排序，列按 $[v_0, v_1, v_2, v_3, v_4]$ 排序：\n  $$\n  S =\n  \\begin{bmatrix}\n  +1  -1  -1  +1  0 \\\\\n  0  +1  +1  -1  -1\n  \\end{bmatrix}.\n  $$\n- 基础边界（在测试用例特定值覆盖之前）：\n  - 下界 $l = [0, 0, 0, -100, 0]$，\n  - 上界 $u = [b_0, 100, 100, 100, u_{\\text{bio}}]$，\n  其中 $b_0$ 和 $u_{\\text{bio}}$ 是测试用例特定的值，所有通量单位中 $v_4$ 为 $\\text{h}^{-1}$，其他通量为一致的内部单位。使用 $M = 100$。\n\n测试套件。对于每个测试用例，给定 $(\\mu_0, b_0, u_{\\text{bio}})$：\n- Case $1$: $(\\mu_0, b_0, u_{\\text{bio}}) = (3, 10, 100)$，\n- Case $2$: $(\\mu_0, b_0, u_{\\text{bio}}) = (0, 10, 100)$，\n- Case $3$: $(\\mu_0, b_0, u_{\\text{bio}}) = (12, 10, 100)$，\n- Case $4$: $(\\mu_0, b_0, u_{\\text{bio}}) = (10, 10, 100)$。\n\n科学真实性说明：稳态约束 $S v = 0$ 强制执行胞内质量平衡。边界 $l \\le v \\le u$ 反映了容量和热力学约束。大M约束 $|v_j| \\le M z_j$ 编码了反应使用情况，将基因活性（作为反应存在的代理）与允许的通量联系起来。生物质通量 $v_4$ 被解释为比生长速率 $\\mu$，单位为 $\\text{h}^{-1}$，而实现 $v_4 \\ge \\mu_0$ 则模拟了一个生长阈值。\n\n您的程序必须：\n- 为每个测试用例，计算满足约束的最小整数 $\\sum_j z_j$。如果不存在，则返回 $-1$。\n- 通过任何正确的方法解决 LP 可行性检查，确保其精确遵守所有给定的约束。\n- 生成单行输出，其中包含按测试用例顺序排列的结果，形式为逗号分隔的列表并用方括号括起，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 是一个整数。\n\n所有生长速率 $\\mu_0$ 必须以 $\\text{h}^{-1}$ 为单位进行解释。输出中不需要其他单位。最终输出必须是仅包含结果列表的一行，不得有任何额外文本。", "solution": "所呈现的问题是一个定义良好的混合整数线性规划（MILP）优化实例，其基础是代谢网络流平衡分析（FBA）的既定原则。它要求找出维持指定生物质生产速率所需的最小活跃反应集。该问题在科学上是合理的、自洽的，并且是定量定义的。因此，它被认为是有效的，可以构建一个严谨的解。\n\n目标是找到一个活跃反应集合的最小基数，该集合由二进制向量 $z \\in \\{0,1\\}^J$ 表示，并允许存在一个满足一系列线性约束的通量分布 $v \\in \\mathbb{R}^J$。反应数量很小，$J=5$，这使得通过系统性枚举所有 $2^5 = 32$ 种可能的二进制向量 $z$ 来获得精确解在计算上是可行的。任务的核心是为每个固定的 $z$ 设计一个正确且高效的方法来检查系统的可行性。\n\n首先，我们分析线性约束的结构。稳态质量平衡由 $S v = 0$ 给出，其中化学计量矩阵为\n$$\nS =\n\\begin{bmatrix}\n+1  -1  -1  +1  0 \\\\\n0  +1  +1  -1  -1\n\\end{bmatrix}.\n$$\n该矩阵方程对应于通量 $v = [v_0, v_1, v_2, v_3, v_4]^T$ 的两个线性方程：\n$$\nv_0 - v_1 - v_2 + v_3 = 0\n$$\n$$\nv_1 + v_2 - v_3 - v_4 = 0\n$$\n从第二个方程，我们推导出 $v_4 = v_1 + v_2 - v_3$。将此代入第一个方程得到 $v_0 - v_4 = 0$，这意味着一个关键关系：$v_0 = v_4$。这意味着外部底物 $A$ 的摄取通量必须恰好等于生物质生产通量。这一简化是获得解析解的关键。\n\n问题在于找到 $\\sum_{j=0}^{4} z_j$ 的最小值，使得存在一个通量向量 $v$ 满足：\n1. $v_0 = v_4$\n2. $v_4 = v_1 + v_2 - v_3$\n3. 如果 $z_j=0$，则 $v_j=0$\n4. 如果 $z_j=1$，则 $l_j \\le v_j \\le u_j$\n5. $v_4 \\ge \\mu_0$\n\n对于一个给定的二进制向量 $z$，我们可以为每个通量 $v_j$ 定义有效边界 $[l'_j, u'_j]$。如果反应 $j$ 不活跃（$z_j=0$），其通量必须为零，因此其有效边界为 $[0, 0]$。如果反应活跃（$z_j=1$），其通量受给定边界 $[l_j, u_j]$ 的约束。所提供的大M常数 $M=100$ 与最大绝对边界值一致，因此条件 $|v_j| \\le M z_j$ 正确地强制执行了这一逻辑，而不会对活跃反应施加额外约束。\n\n对于固定的 $z$，系统的可行性可以无需使用通用 LP 求解器，而是通过区间算术进行评估。我们必须确定是否存在通量 $v_1, v_2, v_3$ 在其有效边界内，使得产生的通量 $v_4 = v_1 + v_2 - v_3$ 位于其自身允许的范围内。\n\n和 $v_1 + v_2 - v_3$ 的可能值范围是一个区间 $I_{sum} = [L_{sum}, U_{sum}]$，其中：\n$$\nL_{sum} = l'_1 + l'_2 - u'_3\n$$\n$$\nU_{sum} = u'_1 + u'_2 - l'_3\n$$\n\n生物质通量 $v_4$ 的所需范围由几个约束条件决定：\n- 生长需求：$v_4 \\ge \\mu_0$。\n- $v_4$ 本身的边界：$l'_4 \\le v_4 \\le u'_4$。\n- 从 $v_0 = v_4$ 推导出的约束：$l'_0 \\le v_4 \\le u'_0$。\n\n综合这些， $v_4$ 的所需区间为 $I_{req} = [L_{req}, U_{req}]$，其中：\n$$\nL_{req} = \\max(\\mu_0, l'_0, l'_4)\n$$\n$$\nU_{req} = \\min(u'_0, u'_4)\n$$\n当且仅当所需区间 $I_{req}$ 有效（即 $L_{req} \\le U_{req}$）并且它与可达总和值区间 $I_{sum}$ 的交集非空时，存在可行解。交集非空的条件是 $\\max(L_{req}, L_{sum}) \\le \\min(U_{req}, U_{sum})$。\n\n总体算法如下：对于每个测试用例，我们遍历活跃反应的数量 $k = \\sum z_j$，从 $k=0$ 到 $k=5$。对于每个 $k$，我们生成所有 $k$ 个活跃反应的组合，从而定义向量 $z$。对于每个 $z$，我们执行上述的解析可行性检查。第一个找到可行 $z$ 的 $k$ 值就是最小反应数。如果循环完成而没有找到任何可行配置，则不存在解决方案，结果为 $-1$。此策略保证能找到精确的最小值。\n\n对于一个参数为 $(\\mu_0, b_0, u_{\\text{bio}})$ 的测试用例：\n- 基础边界为 $l=[0, 0, 0, -100, 0]$ 和 $u=[b_0, 100, 100, 100, u_{\\text{bio}}]$。\n- 对于给定的 $z$，有效边界 $[l'_j, u'_j]$ 在 $z_j=1$ 时为 $[l_j, u_j]$，在 $z_j=0$ 时为 $[0, 0]$。\n- 然后我们计算 $I_{sum}$ 和 $I_{req}$ 并检查是否存在非空交集。\n- 重复此过程，直到找到最小的 $k$ 或遍历完所有 $32$ 种组合。\n\n例如，如果 $\\mu_0  0$，任何可行解都必须有 $z_0=1$ 和 $z_4=1$，因为 $v_4 \\ge \\mu_0  0$ 要求 $v_4$ 非零，并且由于 $v_0=v_4$，$v_0$ 也必须非零。这立即意味着最小活跃反应数必须至少为 $2$。这类逻辑推导可以剪枝搜索空间，但对于 $J=5$ 来说，直接实现完整的组合搜索已经足够高效。", "answer": "```python\nimport numpy as np\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Solves for the minimum number of active reactions for a series of metabolic network problems.\n    \"\"\"\n    test_cases = [\n        # (mu_0, b_0, u_bio)\n        (3, 10, 100),   # Case 1\n        (0, 10, 100),   # Case 2\n        (12, 10, 100),  # Case 3\n        (10, 10, 100),  # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        mu0, b0, u_bio = case\n        result = _solve_case(mu0, b0, u_bio)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _solve_case(mu0, b0, u_bio):\n    \"\"\"\n    Finds the minimum number of active reactions for a single test case.\n\n    The solution is based on an analytical feasibility check derived from the system's\n    stoichiometry, which simplifies to v_0 = v_4 and v_4 = v_1 + v_2 - v_3.\n    \"\"\"\n    base_l = np.array([0., 0., 0., -100., 0.])\n    base_u = np.array([b0, 100., 100., 100., u_bio])\n    num_reactions = 5\n\n    # Iterate through the number of active reactions, k, from 0 to 5.\n    for k in range(num_reactions + 1):\n        # Generate all combinations of k active reactions.\n        for indices in combinations(range(num_reactions), k):\n            z = np.zeros(num_reactions, dtype=int)\n            if k > 0:\n                z[list(indices)] = 1\n\n            # Determine effective flux bounds [l_prime, u_prime] based on z.\n            # If z_j = 0, flux v_j must be 0, so bounds are [0, 0].\n            # If z_j = 1, flux v_j is constrained by [base_l[j], base_u[j]].\n            l_prime = np.zeros(num_reactions)\n            u_prime = np.zeros(num_reactions)\n            for j in range(num_reactions):\n                if z[j] == 1:\n                    l_prime[j] = base_l[j]\n                    u_prime[j] = base_u[j]\n            \n            # Calculate the interval of achievable flux sum (I_sum) from v1, v2, v3.\n            # I_sum corresponds to the range of v_4 = v_1 + v_2 - v_3.\n            L_sum = l_prime[1] + l_prime[2] - u_prime[3]\n            U_sum = u_prime[1] + u_prime[2] - l_prime[3]\n\n            # Calculate the required interval for v_4 (I_req) based on all constraints.\n            # Constraints: v_4 >= mu_0, and v_4 must be within the bounds of v_0 and v_4.\n            L_req = max(mu0, l_prime[0], l_prime[4])\n            U_req = min(u_prime[0], u_prime[4])\n\n            # A feasible flux distribution exists if the required interval I_req is valid\n            # and has a non-empty intersection with the achievable interval I_sum.\n            is_valid_req = L_req = U_req\n            has_intersection = max(L_req, L_sum) = min(U_req, U_sum)\n\n            if is_valid_req and has_intersection:\n                # Found a feasible solution. Since we iterate k in increasing order,\n                # this is the minimum number of reactions.\n                return k\n\n    # If the loops complete without finding a feasible solution.\n    return -1\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "2741604"}]}