{"hands_on_practices": [{"introduction": "为了设计出行为可预测的基因线路，我们首先必须理解支配其行为的基本原理。本练习将深入分析合成生物学的一个基石——作为记忆元件的基因拨动开关。通过应用线性稳定性分析，你将发现一个关键的设计原则：转录抑制的协同性（cooperativity, $n$）如何产生双稳态（bistability），而双稳态正是使开关能够存储信息的特性。[@problem_id:2723594]", "problem": "对称互抑基因开关通常在遗传电路的计算机辅助设计 (CAD) 工具中进行分析，其方法是通过使用源于准平衡状态下协同绑定的希尔函数 (Hill functions) 来模拟转录调控。考虑两个具有相同参数的转录抑制子，其动力学由具有希尔型抑制和线性稀释-降解的一阶质量平衡常微分方程 (ODE) 描述。具体来说，设蛋白质浓度为 $x(t)$ 和 $y(t)$，并假设有相同的最大合成速率 $\\alpha  0$、描述协同绑定的希尔系数 (Hill coefficient) $n \\geq 0$，以及一个时间尺度，使得有效的一阶损失率为 $1$。标准的对称 ODE 模型是\n$$\n\\frac{dx}{dt} \\;=\\; \\frac{\\alpha}{1 + y^{n}} \\;-\\; x, \n\\qquad\n\\frac{dy}{dt} \\;=\\; \\frac{\\alpha}{1 + x^{n}} \\;-\\; y.\n$$\n这些方程源于分子生物学的中心法则（转录和翻译产生蛋白质），结合了一阶损失和一个希尔抑制函数 $\\alpha/(1+(\\cdot)^{n})$，后者是协同绑定的一个经过充分检验的唯象简化模型。\n\n使用线性稳定性分析和仅上述基本定义，分析协同性 $n$ 如何影响该对称系统中双稳态的存在。特别地，确定存在某个 $\\alpha$ 能产生双稳态（两个通过交换对称性相关的不同稳定稳态）的最小希尔系数（解释为实数 $n$ 的下确界）。将您的最终答案表示为单个实数。无需四舍五入。", "solution": "所述问题具有科学依据、提法明确且客观。它使用标准的数学形式描述了合成生物学中的一个典型模型——对称开关。参数已定义，控制方程已给出，目标是一个精确的数学问题。没有矛盾、歧义或事实错误。因此，该问题是有效的，我将继续提供完整的解答。\n\n描述蛋白质浓度 $x(t)$ 和 $y(t)$ 的常微分方程组如下：\n$$\n\\frac{dx}{dt} = \\frac{\\alpha}{1 + y^{n}} - x\n$$\n$$\n\\frac{dy}{dt} = \\frac{\\alpha}{1 + x^{n}} - y\n$$\n这里，$\\alpha  0$ 是最大合成速率，$n \\geq 0$ 是代表协同性的希尔系数，有效的降解速率常数被缩放为 $1$。\n\n双稳态指的是存在两个不同的稳定稳态。在这个对称系统中，双稳态通常表现为两个稳定的不对称稳态 $(\\bar{x}_a, \\bar{y}_a)$ 和 $(\\bar{y}_a, \\bar{x}_a)$（其中 $\\bar{x}_a \\neq \\bar{y}_a$）与一个不稳定的对称稳态 $(\\bar{x}_s, \\bar{y}_s)$（其中 $\\bar{x}_s = \\bar{y}_s$）共存。因此，双稳态的出现与对称稳态的失稳有关。我们首先分析这个对称状态的稳定性。\n\n首先，我们求解对称稳态浓度，记为 $x_s$。通过设置 $\\frac{dx}{dt} = 0$ 和 $x=y=x_s$，我们得到：\n$$\nx_s = \\frac{\\alpha}{1 + x_s^{n}}\n$$\n这可以重写为 $\\alpha = x_s(1 + x_s^n)$。\n\n为了分析稳定性，我们通过计算雅可比矩阵 $J$ 将系统在稳态 $(x_s, x_s)$ 附近线性化。\n$$\nJ(x, y) = \\begin{pmatrix} \\frac{\\partial}{\\partial x}\\left(\\frac{\\alpha}{1 + y^{n}} - x\\right)  \\frac{\\partial}{\\partial y}\\left(\\frac{\\alpha}{1 + y^{n}} - x\\right) \\\\ \\frac{\\partial}{\\partial x}\\left(\\frac{\\alpha}{1 + x^{n}} - y\\right)  \\frac{\\partial}{\\partial y}\\left(\\frac{\\alpha}{1 + x^{n}} - y\\right) \\end{pmatrix} = \\begin{pmatrix} -1  -\\frac{\\alpha n y^{n-1}}{(1+y^n)^2} \\\\ -\\frac{\\alpha n x^{n-1}}{(1+x^n)^2}  -1 \\end{pmatrix}\n$$\n在对称稳态 $(x_s, x_s)$ 处计算雅可比矩阵：\n$$\nJ(x_s, x_s) = \\begin{pmatrix} -1  -\\frac{\\alpha n x_s^{n-1}}{(1+x_s^n)^2} \\\\ -\\frac{\\alpha n x_s^{n-1}}{(1+x_s^n)^2}  -1 \\end{pmatrix}\n$$\n我们可以通过代入 $\\alpha = x_s(1 + x_s^n)$ 来简化非对角线项：\n$$\n-\\frac{\\alpha n x_s^{n-1}}{(1+x_s^n)^2} = -\\frac{x_s(1+x_s^n) n x_s^{n-1}}{(1+x_s^n)^2} = -\\frac{n x_s^n}{1+x_s^n}\n$$\n我们定义一个量 $S = \\frac{n x_s^n}{1+x_s^n}$。雅可比矩阵变为：\n$$\nJ_s = \\begin{pmatrix} -1  -S \\\\ -S  -1 \\end{pmatrix}\n$$\n$J_s$ 的特征值 $\\lambda$ 可通过特征方程 $\\det(J_s - \\lambda I) = 0$ 求得：\n$$\n(-1-\\lambda)^2 - (-S)^2 = 0 \\implies (1+\\lambda)^2 = S^2\n$$\n这给出两个特征值：\n$$\n\\lambda_1 = -1 - S\n$$\n$$\n\\lambda_2 = -1 + S\n$$\n为了使稳态稳定，两个特征值的实部都必须为负。由于 $\\alpha  0$ 且 $n \\geq 0$，因此 $x_s  0$ 且 $S = \\frac{n x_s^n}{1+x_s^n} \\geq 0$。\n因此，$\\lambda_1 = -1 - S \\leq -1$ 总是负的。\n对称稳态的稳定性完全由 $\\lambda_2$ 的符号决定。如果 $\\lambda_2  0$，状态是稳定的；如果 $\\lambda_2  0$，状态是不稳定的。当 $\\lambda_2 = 0$ 时发生分岔，此时稳定性丧失，双稳态可能出现。\n\n为了使对称状态不稳定（这是双稳态的必要条件），我们需要 $\\lambda_2  0$：\n$$\n-1 + S  0 \\implies S  1\n$$\n代入 $S$ 的表达式：\n$$\n\\frac{n x_s^n}{1+x_s^n}  1\n$$\n这个不等式是对称稳态不稳定的条件。问题要求的是，存在*某个* $\\alpha  0$ 能产生双稳态的最小的 $n$。这意味着我们在寻找能够通过某个 $\\alpha$ 的选择来满足不稳定条件的最小的 $n$。\n\n稳态值 $x_s$ 通过方程 $\\alpha = x_s(1+x_s^n)$ 依赖于 $\\alpha$。我们考虑函数 $f(x_s) = x_s(1+x_s^n)$。对于 $x_s  0$ 和 $n \\geq 0$，该函数是连续且严格递增的，从 $f(0)=0$ 开始，当 $x_s \\to \\infty$ 时趋于 $\\infty$。这意味着对于任何 $\\alpha  0$ 的选择，都存在一个唯一的对应 $x_s  0$。反之，对于任何期望的 $x_s  0$ 值，我们都可以找到一个对应的 $\\alpha  0$，使其成为对称稳态。\n\n因此，不稳定条件 $\\frac{n x_s^n}{1+x_s^n}  1$ 能否对某个 $\\alpha$ 成立的问题，等价于该不等式能否对某个 $x_s  0$ 成立。\n我们来分析表达式 $\\frac{n x_s^n}{1+x_s^n}$。令 $u = x_s^n$。由于 $x_s$ 可以在 $(0, \\infty)$ 中取任何值，所以 $u$ 的范围也是 $(0, \\infty)$。该表达式变为 $u$ 和 $n$ 的函数：\n$$\nG(u) = \\frac{nu}{1+u}\n$$\n我们需要确定对于哪些 $n$ 值，$G(u)$ 在 $u \\in (0, \\infty)$ 上的值域包含大于 $1$ 的值。\n函数 $G(u)$ 在 $u  0$ 时是单调递增的。其值域由区间 $(\\lim_{u\\to 0^+} G(u), \\lim_{u\\to\\infty} G(u))$ 给出。\n$$\n\\lim_{u\\to 0^+} G(u) = \\frac{n \\cdot 0}{1+0} = 0\n$$\n$$\n\\lim_{u\\to\\infty} G(u) = \\lim_{u\\to\\infty} \\frac{nu}{u(1/u+1)} = \\lim_{u\\to\\infty} \\frac{n}{1/u+1} = n\n$$\n因此，对于给定的 $n$，量 $S = \\frac{n x_s^n}{1+x_s^n}$ 的所有可能值（通过改变 $\\alpha$ 从而改变 $x_s$）的集合是开区间 $(0, n)$。\n\n不稳定的条件 $S  1$ 能被满足，当且仅当区间 $(0, n)$ 包含大于 $1$ 的值。这当且仅当该区间的上确界 $n$ 大于 $1$ 时才成立。\n$$\nn  1\n$$\n如果 $n \\leq 1$，表达式 $\\frac{n x_s^n}{1+x_s^n}$ 永远不会大于 $1$，因此对称稳态总是稳定的，不会出现双稳态。如果 $n  1$，我们总能找到一个足够大的 $\\alpha$，使得 $x_s$ 也足够大，从而满足 $\\frac{n x_s^n}{1+x_s^n}  1$，导致对称状态不稳定，并出现两个稳定的不对称状态（这是该系统的一个标准超临界叉式分岔情景）。\n\n因此，对于某个 $\\alpha$ 的选择，存在双稳态的希尔系数条件是 $n1$。问题要求的是这样的最小希尔系数，解释为实数 $n$ 的下确界。可能出现双稳态的 $n$ 值集合是区间 $(1, \\infty)$。该集合的下确界是 $1$。", "answer": "$$\n\\boxed{1}\n$$", "id": "2723594"}, {"introduction": "理论模型（如拨动开关模型）为线路功能提供了定性蓝图，但定量预测需要精确的参数值。本练习旨在弥合理论与实验之间的鸿沟，演示如何从真实世界的数据中提取关键的动力学参数，例如转录和翻译速率。你将使用一种常用技术，将一个确定性的基因表达模型与假设的时间序列荧光数据进行拟合，这是构建和验证基因线路预测模型的一项基本技能。[@problem_id:2723649]", "problem": "给定来自无细胞转录-翻译 (TX-TL) 反应的批量转录-翻译荧光时间序列数据，其中信使核糖核酸 (mRNA) 和蛋白质的荧光随时间被记录。假设以下基于中心法则（脱氧核糖核酸到核糖核酸到蛋白质）和一级质量作用动力学的基本且广泛使用的建模假设：\n\n- mRNA 浓度动态满足以下常微分方程 (ODE)：$$\\frac{dm}{dt} = k_{\\mathrm{tx}} - \\delta_m m,$$ 其中 $m$ 是 mRNA 浓度，单位为 $\\mathrm{nM}$，$k_{\\mathrm{tx}}$ 是转录速率，单位为 $\\mathrm{nM}\\,\\mathrm{min}^{-1}$，$\\delta_m$ 是 mRNA 的一级降解速率，单位为 $\\mathrm{min}^{-1}$。\n- 蛋白质浓度动态满足以下 ODE：$$\\frac{dp}{dt} = k_{\\mathrm{tl}}\\, m - \\delta_p p,$$ 其中 $p$ 是蛋白质浓度，单位为 $\\mathrm{nM}$，$k_{\\mathrm{tl}}$ 是翻译速率，单位为 $\\mathrm{min}^{-1}$，$\\delta_p$ 是蛋白质的一级降解/稀释速率，单位为 $\\mathrm{min}^{-1}$。\n- 记录的荧光信号通过已知的校准（增益）和基线（偏移）与浓度呈线性关系：$$y_m = s_m\\, m + b_m,\\quad y_p = s_p\\, p + b_p,$$ 其中 $y_m$ 和 $y_p$ 是荧光强度，单位为任意单位 (au)，$s_m$ 和 $s_p$ 是校准增益，单位为 $\\mathrm{au}\\,\\mathrm{nM}^{-1}$，$b_m$ 和 $b_p$ 是基线偏移，单位为 $\\mathrm{au}$。\n\n仅使用这些基本假设和离散采样的时间点，通过将 ODE 重构为使用时间导数的前向差分近似的参数线性回归，来估计参数 $k_{\\mathrm{tx}}$、$\\delta_m$、$k_{\\mathrm{tl}}$ 和 $\\delta_p$。具体来说，对于连续的时间点 $t_i$ 和 $t_{i+1}$，近似为：$$\\left.\\frac{dm}{dt}\\right|_{t_i} \\approx \\frac{m_{i+1}-m_i}{t_{i+1}-t_i},\\qquad \\left.\\frac{dp}{dt}\\right|_{t_i} \\approx \\frac{p_{i+1}-p_i}{t_{i+1}-t_i},$$ 形成线性系统：$$\\frac{m_{i+1}-m_i}{t_{i+1}-t_i} = -\\delta_m\\, m_i + k_{\\mathrm{tx}},\\qquad \\frac{p_{i+1}-p_i}{t_{i+1}-t_i} = k_{\\mathrm{tl}}\\, m_i - \\delta_p\\, p_i,$$ 并对所有有效索引 $i$ 以最小二乘意义求解 $k_{\\mathrm{tx}}$、$\\delta_m$、$k_{\\mathrm{tl}}$ 和 $\\delta_p$。\n\n重要的实现要求：\n- 在计算导数之前，使用 $m_i = (y_{m,i} - b_m)/s_m$ 和 $p_i = (y_{p,i} - b_p)/s_p$ 将荧光转换为浓度。\n- 完全按照上面所写的方式使用前向差分，将 $\\frac{m_{i+1}-m_i}{t_{i+1}-t_i}$ 与每个区间左端的状态值 $m_i$ 和 $p_i$ 配对。\n- 所有速率参数均以指定单位表示：$k_{\\mathrm{tx}}$ 单位为 $\\mathrm{nM}\\,\\mathrm{min}^{-1}$，$\\delta_m$ 单位为 $\\mathrm{min}^{-1}$， $k_{\\mathrm{tl}}$ 单位为 $\\mathrm{min}^{-1}$，$\\delta_p$ 单位为 $\\mathrm{min}^{-1}$。\n- 您的程序应生成单行输出，其中包含结果，形式为逗号分隔的列表的列表，每个内部列表按 $[k_{\\mathrm{tx}}, \\delta_m, k_{\\mathrm{tl}}, \\delta_p]$ 的顺序排列一个测试用例，并且所有值都四舍五入到六位小数。最终格式必须与单行上的 `\\texttt{[[v_11,v_12,v_13,v_14],[v_21,v_22,v_23,v_24],...]}` 完全一样，不含空格。\n\n测试套件：\n对于下面的每个测试用例，请使用提供的时间向量、荧光轨迹和校准常数。\n\n- 测试用例 1：\n  - 时间（分钟）：$[0, 2, 4, 6, 8, 10, 12]$。\n  - mRNA 荧光 $y_m$（任意单位）：$[400, 1600, 2320, 2752, 3011.2, 3166.72, 3260.032]$。\n  - 蛋白质荧光 $y_p$（任意单位）：$[1000, 1000, 1450, 2125, 2894.5, 3684.25, 4453.345]$。\n  - 校准增益和基线：$s_m = 120\\,\\mathrm{au}\\,\\mathrm{nM}^{-1}$，$b_m = 400\\,\\mathrm{au}$，$s_p = 15\\,\\mathrm{au}\\,\\mathrm{nM}^{-1}$，$b_p = 1000\\,\\mathrm{au}$。\n- 测试用例 2：\n  - 时间（分钟）：$[0, 2, 4, 6, 8, 10]$。\n  - mRNA 荧光 $y_m$（任意单位）：$[100, 900, 1700, 2500, 3300, 4100]$。\n  - 蛋白质荧光 $y_p$（任意单位）：$[500, 500, 628, 858.4, 1170.72, 1548.576]$。\n  - 校准增益和基线：$s_m = 200\\,\\mathrm{au}\\,\\mathrm{nM}^{-1}$，$b_m = 100\\,\\mathrm{au}$，$s_p = 20\\,\\mathrm{au}\\,\\mathrm{nM}^{-1}$，$b_p = 500\\,\\mathrm{au}$。\n- 测试用例 3：\n  - 时间（分钟）：$[0, 1, 2, 3, 4, 5, 6, 7]$。\n  - mRNA 荧光 $y_m$（任意单位）：$[200, 2000, 2900, 3350, 3575, 3687.5, 3743.75, 3771.875]$。\n  - 蛋白质荧光 $y_p$（任意单位）：$[900, 900, 1188, 1533.6, 1847.52, 2103.264, 2300.2848, 2447.19936]$。\n  - 校准增益和基线：$s_m = 150\\,\\mathrm{au}\\,\\mathrm{nM}^{-1}$，$b_m = 200\\,\\mathrm{au}$，$s_p = 12\\,\\mathrm{au}\\,\\mathrm{nM}^{-1}$，$b_p = 900\\,\\mathrm{au}$。\n\n输出规范：\n- 对于每个测试用例，使用所述的线性回归方法估计 $(k_{\\mathrm{tx}}, \\delta_m, k_{\\mathrm{tl}}, \\delta_p)$。\n- 您的程序应生成一行输出，其中包含一个包含三个内部列表的单一列表，每个测试用例一个，顺序为 $[[k_{\\mathrm{tx},1},\\delta_{m,1},k_{\\mathrm{tl},1},\\delta_{p,1}],[k_{\\mathrm{tx},2},\\delta_{m,2},k_{\\mathrm{tl},2},\\delta_{p,2}],[k_{\\mathrm{tx},3},\\delta_{m,3},k_{\\mathrm{tl},3},\\delta_{p,3}]]$，所有数字均四舍五入到六位小数，且无空格。", "solution": "该问题被验证为具有科学依据、提法恰当、客观且完整。它描述了系统生物学中的一个标准且合理的任务：从时间序列数据中估计动力学参数。所规定的方法虽然基础，却是数值近似和线性回归的有效应用。我们继续进行求解。\n\n目标是估计中心法则模型的四个动力学参数：转录速率 $k_{\\mathrm{tx}}$、信使 RNA (mRNA) 降解速率 $\\delta_m$、翻译速率 $k_{\\mathrm{tl}}$ 和蛋白质降解速率 $\\delta_p$。该估计是使用离散的 mRNA 和蛋白质荧光时间序列测量值进行的。\n\n该系统由一对线性常微分方程 (ODE) 控制：\n$$\n\\frac{dm}{dt} = k_{\\mathrm{tx}} - \\delta_m m(t) \\quad \\text{(1)}\n$$\n$$\n\\frac{dp}{dt} = k_{\\mathrm{tl}}\\, m(t) - \\delta_p p(t) \\quad \\text{(2)}\n$$\n其中 $m(t)$ 和 $p(t)$ 分别表示在时间 $t$ 的 mRNA 和蛋白质浓度。\n\n原始荧光数据 $y_m$ 和 $y_p$ 首先使用提供的线性校准常数转换为浓度 $m$ 和 $p$：\n$$\nm_i = \\frac{y_{m,i} - b_m}{s_m}\n$$\n$$\np_i = \\frac{y_{p,i} - b_p}{s_p}\n$$\n对于每个时间点 $t_i$。\n\n该方法的核心是将微分方程转换为适用于线性回归的代数方程。这是通过使用一阶前向差分格式来近似时间导数实现的。对于时间区间 $[t_i, t_{i+1}]$，在时间 $t_i$ 的导数近似为：\n$$\n\\left.\\frac{dm}{dt}\\right|_{t_i} \\approx \\frac{m_{i+1}-m_i}{t_{i+1}-t_i} \\quad \\text{和} \\quad \\left.\\frac{dp}{dt}\\right|_{t_i} \\approx \\frac{p_{i+1}-p_i}{t_{i+1}-t_i}\n$$\n将这些近似值代入方程 ($1$) 和 ($2$)，得到两组线性方程，一组用于 mRNA 动态，另一组用于蛋白质动态。\n\n对于 mRNA 参数，方程 ($1$) 变为：\n$$\n\\frac{m_{i+1}-m_i}{t_{i+1}-t_i} \\approx k_{\\mathrm{tx}} - \\delta_m m_i\n$$\n该方程在未知参数 $k_{\\mathrm{tx}}$ 和 $\\delta_m$ 上是线性的。我们可以通过为每个测量区间 $i = 0, 1, \\dots, N-2$ 写出这样一个方程来构建一个 $A_m \\mathbf{x}_m = \\mathbf{b}_m$ 形式的线性系统，其中 $N$ 是总时间点数。系统各组成部分为：\n- 参数向量 $\\mathbf{x}_m = \\begin{bmatrix} k_{\\mathrm{tx}} \\\\ \\delta_m \\end{bmatrix}$。\n- 目标向量 $\\mathbf{b}_m$，一个 $(N-1) \\times 1$ 的列向量，其元素为 $(\\mathbf{b}_m)_i = \\frac{m_{i+1}-m_i}{t_{i+1}-t_i}$。\n- 回归矩阵 $A_m$，一个 $(N-1) \\times 2$ 的矩阵，其行为 $(A_m)_i = \\begin{bmatrix} 1  -m_i \\end{bmatrix}$。\n\n类似地，对于蛋白质参数，方程 ($2$) 变为：\n$$\n\\frac{p_{i+1}-p_i}{t_{i+1}-t_i} \\approx k_{\\mathrm{tl}} m_i - \\delta_p p_i\n$$\n这在参数 $k_{\\mathrm{tl}}$ 和 $\\delta_p$ 上是线性的。为 $i = 0, 1, \\dots, N-2$ 构建一个线性系统 $A_p \\mathbf{x}_p = \\mathbf{b}_p$：\n- 参数向量 $\\mathbf{x}_p = \\begin{bmatrix} k_{\\mathrm{tl}} \\\\ \\delta_p \\end{bmatrix}$。\n- 目标向量 $\\mathbf{b}_p$，一个 $(N-1) \\times 1$ 的列向量，其元素为 $(\\mathbf{b}_p)_i = \\frac{p_{i+1}-p_i}{t_{i+1}-t_i}$。\n- 回归矩阵 $A_p$，一个 $(N-1) \\times 2$ 的矩阵，其行为 $(A_p)_i = \\begin{bmatrix} m_i  -p_i \\end{bmatrix}$。\n\n参数向量 $\\mathbf{x}_m$ 和 $\\mathbf{x}_p$ 是通过在最小二乘意义上求解这些超定线性系统来独立估计的。最小二乘解 $\\hat{\\mathbf{x}}$ 最小化了残差平方和 $\\| A\\mathbf{x} - \\mathbf{b} \\|_2^2$，并由正规方程的解给出：\n$$\n\\hat{\\mathbf{x}} = (A^T A)^{-1} A^T \\mathbf{b}\n$$\n这个解可以使用标准的数值线性代数程序高效地计算出来。每个测试用例的最终估计参数集是排序后的集合 $[k_{\\mathrm{tx}}, \\delta_m, k_{\\mathrm{tl}}, \\delta_p]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for genetic circuit parameters using linear regression on\n    discretized ODEs for multiple test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"times\": np.array([0, 2, 4, 6, 8, 10, 12], dtype=float),\n            \"y_m\": np.array([400, 1600, 2320, 2752, 3011.2, 3166.72, 3260.032], dtype=float),\n            \"y_p\": np.array([1000, 1000, 1450, 2125, 2894.5, 3684.25, 4453.345], dtype=float),\n            \"calib\": {\"s_m\": 120.0, \"b_m\": 400.0, \"s_p\": 15.0, \"b_p\": 1000.0}\n        },\n        {\n            \"times\": np.array([0, 2, 4, 6, 8, 10], dtype=float),\n            \"y_m\": np.array([100, 900, 1700, 2500, 3300, 4100], dtype=float),\n            \"y_p\": np.array([500, 500, 628, 858.4, 1170.72, 1548.576], dtype=float),\n            \"calib\": {\"s_m\": 200.0, \"b_m\": 100.0, \"s_p\": 20.0, \"b_p\": 500.0}\n        },\n        {\n            \"times\": np.array([0, 1, 2, 3, 4, 5, 6, 7], dtype=float),\n            \"y_m\": np.array([200, 2000, 2900, 3350, 3575, 3687.5, 3743.75, 3771.875], dtype=float),\n            \"y_p\": np.array([900, 900, 1188, 1533.6, 1847.52, 2103.264, 2300.2848, 2447.19936], dtype=float),\n            \"calib\": {\"s_m\": 150.0, \"b_m\": 200.0, \"s_p\": 12.0, \"b_p\": 900.0}\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        # Extract data for the current case\n        t = case[\"times\"]\n        y_m = case[\"y_m\"]\n        y_p = case[\"y_p\"]\n        s_m, b_m = case[\"calib\"][\"s_m\"], case[\"calib\"][\"b_m\"]\n        s_p, b_p = case[\"calib\"][\"s_p\"], case[\"calib\"][\"b_p\"]\n\n        # 1. Convert fluorescence to concentration\n        m = (y_m - b_m) / s_m\n        p = (y_p - b_p) / s_p\n        \n        # Number of data points\n        N = len(t)\n        if N  2:\n            continue\n\n        # 2. Calculate time differences for derivative approximation\n        dt = np.diff(t)\n        \n        # 3. Estimate mRNA parameters (k_tx, delta_m)\n        # Approximate dm/dt using forward difference\n        dm_dt_approx = np.diff(m) / dt\n        # Regressors are taken at time t_i\n        m_reg = m[:-1]\n        # Construct the regressor matrix A_m for mRNA\n        A_m = np.vstack([np.ones(N - 1), -m_reg]).T\n        # Solve the linear system A_m * [k_tx, delta_m]^T = dm_dt_approx\n        theta_m, _, _, _ = np.linalg.lstsq(A_m, dm_dt_approx, rcond=None)\n        k_tx, delta_m = theta_m[0], theta_m[1]\n\n        # 4. Estimate protein parameters (k_tl, delta_p)\n        # Approximate dp/dt using forward difference\n        dp_dt_approx = np.diff(p) / dt\n        # Regressors are m_i and p_i\n        p_reg = p[:-1]\n        # Construct the regressor matrix A_p for protein\n        A_p = np.vstack([m_reg, -p_reg]).T\n        # Solve the linear system A_p * [k_tl, delta_p]^T = dp_dt_approx\n        theta_p, _, _, _ = np.linalg.lstsq(A_p, dp_dt_approx, rcond=None)\n        k_tl, delta_p = theta_p[0], theta_p[1]\n\n        all_results.append([k_tx, delta_m, k_tl, delta_p])\n\n    # Final print statement in the exact required format.\n    formatted_results = []\n    for res in all_results:\n        # Format each inner list with 6 decimal places\n        inner_str = \",\".join([f\"{val:.6f}\" for val in res])\n        formatted_results.append(f\"[{inner_str}]\")\n    \n    # Combine all formatted inner lists into the final string\n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2723649"}, {"introduction": "计算工具的最终目标是实现复杂生物系统的自动化设计。最后的这个练习将从分析转向综合，阐释如何将线路设计构建为一个形式化的优化问题。你将通过从一个离散的元件库中选择最佳组件，来应对构建一个双输入异或（XOR）逻辑门的挑战，这模拟了现代合成生物学计算机辅助设计（CAD）工具的功能。该练习展示了计算搜索如何系统地探索设计空间，以工程化具有期望功能的线路。[@problem_id:2723633]", "problem": "给定一个小的、完全指定的混合整数线性规划 (MILP) 实例，该实例抽象了一个双输入异或 (XOR) 遗传逻辑功能到一个使用离散阈值门库的分层遗传电路中的映射。该问题使用分子生物学的中心法则（DNA到RNA到蛋白质）和基因调控的数字阈值近似来构建，这在遗传电路设计的计算工具中是一种广泛使用的抽象。该模型假设每个遗传门可以表示为一个单输入单输出设备，具有两种可能的输出水平和一个阈值，该阈值根据其输入浓度决定输出是处于高水平还是低水平。\n\n从以下基础开始：\n- 分子生物学的中心法则确保基因表达由转录和翻译介导，启动子可以被转录因子以单调方式激活或抑制。\n- 在数字抽象中，遗传门被建模为一个阈值设备：对于激活子，当输入浓度超过一个阈值时，输出从低切换到高；对于抑制子，当输入超过一个阈值时，输出从高切换到低。\n- 通过组合这些门来构建一个前馈分层遗传电路，其在固定真值表上的行为可以使用线性误差度量与期望的数字功能进行比较。\n\n架构和建模假设：\n- 两个输入，表示为 $A$ 和 $B$，各自取两个浓度水平：低水平 $x_\\text{low} = 1\\,\\text{nM}$ 和高水平 $x_\\text{high} = 50\\,\\text{nM}$。\n- 使用一个具有三个节点的分层电路：\n  - 节点 $1$ 通过从库中选择的门接收输入 $A$。\n  - 节点 $2$ 通过从库中选择的门接收输入 $B$。\n  - 节点 $3$ 接收来自节点 $1$ 和 $2$ 的输出之和 $z = y_1 + y_2$（单位为任意单位（AU））作为输入，其本身也是从库中选择的门。\n- 每个门要么是具有固定阈值和固定低/高输出水平的激活子，要么是抑制子：\n  - 对于一个阈值为 $\\theta$（单位与其输入相同）、输出水平为 $L$ 和 $H$（单位为 AU）的激活子，如果输入 $x \\ge \\theta$，则输出 $y$ 为 $H$，否则为 $L$。\n  - 对于一个阈值为 $\\theta$、输出水平为 $L$ 和 $H$（单位为 AU）的抑制子，如果输入 $x \\le \\theta$，则输出 $y$ 为 $H$，否则为 $L$。\n- 期望的 XOR 输出水平以 AU 为单位指定：对于表示低/高浓度的 $A, B \\in \\{0,1\\}$，期望输出 $y^\\text{true}$ 对于（$A,B$）$\\in \\{(0,0),(1,1)\\}$ 为 $0$ AU，对于（$A,B$）$\\in \\{(0,1),(1,0)\\}$ 为 $Y_\\text{true}$ AU。\n\nMILP 决策变量和约束：\n- 设输入案例集为 $c \\in \\{0,1,2,3\\}$，对应于（$A,B$）$\\in \\{(0,0),(0,1),(1,0),(1,1)\\}$。\n- 定义二进制选择变量 $t_m \\in \\{0,1\\}$，其中 $m \\in \\{1,\\dots,8\\}$，每个 $m$ 编码了节点 $1$、$2$ 和 $3$ 的门选择的八种组合之一（每个节点有两个选项）。必须恰好选择一个组合：\n  $$\\sum_{m=1}^{8} t_m = 1.$$\n- 对于每个 $m$ 和每个案例 $c$，输出 $y^{(m)}_{3,c}$ 是一个常数，通过确定性地应用阈值规则从输入浓度计算节点 $1$ 和节点 $2$ 的输出，然后从它们的和 $z$ 计算节点 $3$ 的输出；这在下面解释，并且是所提供数据的一部分。\n- 对于每个案例 $c$，所选电路的实际输出是\n  $$y_{3,c} = \\sum_{m=1}^{8} t_m \\, y^{(m)}_{3,c}.$$\n- 引入非负误差变量 $e_c \\ge 0$，并通过线性不等式强制实现与期望输出的绝对偏差：\n  $$e_c \\ge y_{3,c} - y^\\text{true}_c,\\quad e_c \\ge -(y_{3,c} - y^\\text{true}_c).$$\n- 目标是最小化所有四个输入案例的绝对偏差之和：\n  $$\\min \\sum_{c=0}^{3} e_c.$$\n- 最终目标值应以任意单位（AU）的浮点数形式报告。\n\n门库和测试套件：\n- 输入单位为 nM：$x_\\text{low} = 1$，$x_\\text{high} = 50$。\n- 节点 $1$ 库（任选其一）：\n  - $G_{1A}$：激活子，阈值 $\\theta = 10$ nM，低输出 $L = 5$ AU，高输出 $H = 110$ AU。\n  - $G_{1R}$：抑制子，阈值 $\\theta = 10$ nM，低输出 $L = 5$ AU，高输出 $H = 110$ AU。\n- 节点 $2$ 库（任选其一）：\n  - $G_{2A}$：激活子，阈值 $\\theta = 20$ nM，低输出 $L = 2$ AU，高输出 $H = 90$ AU。\n  - $G_{2R}$：抑制子，阈值 $\\theta = 20$ nM，低输出 $L = 2$ AU，高输出 $H = 90$ AU。\n- 节点 $3$ 库（每个实例任选其一）：\n  - $G_{3A}$：激活子，阈值 $\\Theta$ AU，低输出 $L = 0$ AU，高输出 $H = H_3$ AU。\n  - $G_{3R}$：抑制子，阈值 $\\Theta$ AU，低输出 $L = 0$ AU，高输出 $H = H_3$ AU。\n- 期望的 XOR 水平：$Y_\\text{true} = 100$ AU，因此根据 XOR 真值表，$y^\\text{true}_c \\in \\{0, 100\\}$。\n\n您的程序必须为以下三个独立的实例（节点 3 的参数化）精确求解 MILP，并报告每个实例的最优目标值：\n- 实例 1：$\\Theta = 80$ AU, $H_3 = 120$ AU。\n- 实例 2：$\\Theta = 130$ AU, $H_3 = 120$ AU。\n- 实例 3：$\\Theta = 80$ AU, $H_3 = 100$ AU。\n\n重要细节：\n- 对于每个实例，您可以通过详尽评估八种门组合和四种输入案例来预计算所有常数 $y^{(m)}_{3,c}$。因为这是一个小实例，对二进制选择空间进行精确枚举是可接受的，并且等同于求解 MILP。\n- 科学真实性：阈值和输出水平被选择为单调和饱和的，这与经过充分研究的遗传设备数字抽象一致。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的三个最优目标值（以 AU 为单位）的逗号分隔列表，例如，“[x1,x2,x3]”。\n- 所有三个值都必须是以 AU 为单位打印的浮点数，在文本输出中不带单位。\n\n测试套件覆盖原理：\n- 实例 1 是一个典型的“顺利路径”案例，具有适中的最终阈值和高于期望的高输出，用于测试错误高值与超出期望水平的真实高值之间的权衡。\n- 实例 2 是一个边界移动案例，具有较高的最终阈值，该阈值翻转了中间和的分类，用于测试对 $\\Theta$ 的敏感性。\n- 实例 3 将最终高输出与期望的高水平对齐，用于测试输出缩放是否能减少最优偏差。", "solution": "问题陈述已经过验证，被认为是科学有据、定义明确且客观的。它提出了一个可解的优化问题，该问题植根于遗传电路的数字抽象，这是计算合成生物学中的一种常用方法。任务是确定使用预定义的遗传门库实现双输入异或（XOR）功能时的最小可能误差。这被构建为一个小型混合整数线性规划（MILP）问题，由于其规模有限，可以通过对所有可能的电路配置进行穷举枚举来解决。\n\n问题指定了一个前馈电路，它有两个输入 $A$ 和 $B$，其浓度水平为 $x_\\text{low} = 1\\,\\text{nM}$ 和 $x_\\text{high} = 50\\,\\text{nM}$。该电路有三个节点。节点 1 处理输入 $A$ 以产生输出 $y_1$，节点 2 处理输入 $B$ 以产生输出 $y_2$。节点 3 的输入是和 $z = y_1 + y_2$，其输出 $y_3$ 是电路的最终输出。\n\n每个门的行为由一个阈值模型定义。对于输入为 $x$、阈值为 $\\theta$、低输出为 $L$、高输出为 $H$ 的激活子，如果 $x \\ge \\theta$，则输出为 $H$，否则为 $L$。对于抑制子，如果 $x \\le \\theta$，则输出为 $H$，否则为 $L$。期望的 XOR 逻辑对应于四个输入案例 $c \\in \\{0, 1, 2, 3\\}$（分别代表（低, 低）、（低, 高）、（高, 低）和（高, 高）的 $(A,B)$ 输入对）的目标输出向量。目标输出向量为 $y^\\text{true} = [0, 100, 100, 0]$，单位为任意单位（AU）。\n\n解决方案策略包括遍历所有 $2 \\times 2 \\times 2 = 8$ 种可能的门组合（用于三个节点）。对于每种组合，我们计算总绝对误差 $E = \\sum_{c=0}^{3} |y_{3,c} - y^\\text{true}_c|$，其中 $y_{3,c}$ 是电路在输入案例 $c$ 下的输出。所有 8 种组合中的最小误差就是给定一组节点 3 参数的解。\n\n首先，我们为可用的门和输入水平预先计算节点 1（$y_1$）和节点 2（$y_2$）的输出。\n\n节点 1 门库：\n- $G_{1A}$（激活子）: $\\theta_1 = 10\\,\\text{nM}$，$L_1 = 5\\,\\text{AU}$，$H_1 = 110\\,\\text{AU}$。\n  - 对于 $x_A = x_\\text{low} = 1\\,\\text{nM}  10\\,\\text{nM}$，$y_1 = 5\\,\\text{AU}$。\n  - 对于 $x_A = x_\\text{high} = 50\\,\\text{nM} \\ge 10\\,\\text{nM}$，$y_1 = 110\\,\\text{AU}$。\n- $G_{1R}$（抑制子）: $\\theta_1 = 10\\,\\text{nM}$，$L_1 = 5\\,\\text{AU}$，$H_1 = 110\\,\\text{AU}$。\n  - 对于 $x_A = x_\\text{low} = 1\\,\\text{nM} \\le 10\\,\\text{nM}$，$y_1 = 110\\,\\text{AU}$。\n  - 对于 $x_A = x_\\text{high} = 50\\,\\text{nM}  10\\,\\text{nM}$，$y_1 = 5\\,\\text{AU}$。\n\n节点 2 门库：\n- $G_{2A}$（激活子）: $\\theta_2 = 20\\,\\text{nM}$，$L_2 = 2\\,\\text{AU}$，$H_2 = 90\\,\\text{AU}$。\n  - 对于 $x_B = x_\\text{low} = 1\\,\\text{nM}  20\\,\\text{nM}$，$y_2 = 2\\,\\text{AU}$。\n  - 对于 $x_B = x_\\text{high} = 50\\,\\text{nM} \\ge 20\\,\\text{nM}$，$y_2 = 90\\,\\text{AU}$。\n- $G_{2R}$（抑制子）: $\\theta_2 = 20\\,\\text{nM}$，$L_2 = 2\\,\\text{AU}$，$H_2 = 90\\,\\text{AU}$。\n  - 对于 $x_B = x_\\text{low} = 1\\,\\text{nM} \\le 20\\,\\text{nM}$，$y_2 = 90\\,\\text{AU}$。\n  - 对于 $x_B = x_\\text{high} = 50\\,\\text{nM}  20\\,\\text{nM}$，$y_2 = 2\\,\\text{AU}$。\n\n根据这些，我们可以计算节点 3 的输入 $z = y_1 + y_2$，它涵盖了四种第一层门组合在四种输入案例下的情况：\n- 案例 0：（$x_A, x_B$） = （1, 1）$\\,\\text{nM}$\n- 案例 1：（$x_A, x_B$） = （1, 50）$\\,\\text{nM}$\n- 案例 2：（$x_A, x_B$） = （50, 1）$\\,\\text{nM}$\n- 案例 3：（$x_A, x_B$） = （50, 50）$\\,\\text{nM}$\n\n下面以表格形式列出了 $z$ 的值（单位为 AU）：\n| 门组合（节点 1, 节点 2） | 案例 0（L,L） | 案例 1（L,H） | 案例 2（H,L） | 案例 3（H,H） |\n|---|---|---|---|---|\n| （$G_{1A}, G_{2A}$） | $7$ | $95$ | $112$ | $200$ |\n| （$G_{1A}, G_{2R}$） | $95$ | $7$ | $200$ | $112$ |\n| （$G_{1R}, G_{2A}$） | $112$ | $200$ | $7$ | $95$ |\n| （$G_{1R}, G_{2R}$） | $200$ | $112$ | $95$ | $7$ |\n\n我们现在通过评估所有 8 种门配置来为三个指定实例中的每一个求解问题。\n\n实例 1：$\\Theta = 80\\,\\text{AU}$，$H_3 = 120\\,\\text{AU}$。\n节点 3 的门具有 $L_3 = 0\\,\\text{AU}$。\n- $G_{3A}$：如果 $z \\ge 80$，输出为 $120$，否则为 $0$。\n- $G_{3R}$：如果 $z \\le 80$，输出为 $120$，否则为 $0$。\n通过枚举所有 8 种配置，我们发现最小总误差为 $120\\,\\text{AU}$。这个结果可以通过两种配置实现。例如，配置（$G_{1A}, G_{2R}, G_{3R}$）：\n- 中间和的向量为 $z = [95, 7, 200, 112]$。\n- 应用 $G_{3R}$ 规则（$z \\le 80 \\to 120$）：\n  - 案例 0（$z=95$）：$y_3=0$。误差：$|0-0|=0$。\n  - 案例 1（$z=7$）：$y_3=120$。误差：$|120-100|=20$。\n  - 案例 2（$z=200$）：$y_3=0$。误差：$|0-100|=100$。\n  - 案例 3（$z=112$）：$y_3=0$。误差：$|0-0|=0$。\n- 总误差为 $0 + 20 + 100 + 0 = 120\\,\\text{AU}$。\n\n实例 2：$\\Theta = 130\\,\\text{AU}$，$H_3 = 120\\,\\text{AU}$。\n节点 3 的门具有 $L_3 = 0\\,\\text{AU}$。\n- $G_{3A}$：如果 $z \\ge 130$，输出为 $120$，否则为 $0$。\n- $G_{3R}$：如果 $z \\le 130$，输出为 $120$，否则为 $0$。\n枚举所有 8 种配置显示最小总误差为 $120\\,\\text{AU}$。这个值可以通过两种配置实现。例如，配置（$G_{1A}, G_{2R}, G_{3A}$）：\n- 中间和的向量为 $z = [95, 7, 200, 112]$。\n- 应用 $G_{3A}$ 规则（$z \\ge 130 \\to 120$）：\n  - 案例 0（$z=95$）：$y_3=0$。误差：$|0-0|=0$。\n  - 案例 1（$z=7$）：$y_3=0$。误差：$|0-100|=100$。\n  - 案例 2（$z=200$）：$y_3=120$。误差：$|120-100|=20$。\n  - 案例 3（$z=112$）：$y_3=0$。误差：$|0-0|=0$。\n- 总误差为 $0 + 100 + 20 + 0 = 120\\,\\text{AU}$。\n\n实例 3：$\\Theta = 80\\,\\text{AU}$，$H_3 = 100\\,\\text{AU}$。\n这里，节点 3 的高输出与 XOR 的期望高输出 ($100\\,\\text{AU}$) 相匹配。阈值与实例 1 相同。\n- $G_{3A}$：如果 $z \\ge 80$，输出为 $100$，否则为 $0$。\n- $G_{3R}$：如果 $z \\le 80$，输出为 $100$，否则为 $0$。\n最小总误差被发现为 $100\\,\\text{AU}$。这个结果可以通过四种配置实现。例如，配置（$G_{1R}, G_{2A}, G_{3R}$）：\n- 中间和的向量为 $z = [112, 200, 7, 95]$。\n- 应用 $G_{3R}$ 规则（$z \\le 80 \\to 100$）：\n  - 案例 0（$z=112$）：$y_3=0$。误差：$|0-0|=0$。\n  - 案例 1（$z=200$）：$y_3=0$。误差：$|0-100|=100$。\n  - 案例 2（$z=7$）：$y_3=100$。误差：$|100-100|=0$。\n  - 案例 3（$z=95$）：$y_3=0$。误差：$|0-0|=0$。\n- 总误差为 $0 + 100 + 0 + 0 = 100\\,\\text{AU}$。\n\n因此，三个实例的最优目标值分别为 $120.0$、$120.0$ 和 $100.0$ AU。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the minimum error of a genetic XOR gate for three different\n    parameterizations of the final stage.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple contains (Theta_3, H_3) for Node 3.\n    test_cases = [\n        (80.0, 120.0),  # Instance 1\n        (130.0, 120.0), # Instance 2\n        (80.0, 100.0),  # Instance 3\n    ]\n\n    results = []\n    for case in test_cases:\n        Theta_3, H_3 = case\n        min_error = calculate_min_error_for_instance(Theta_3, H_3)\n        results.append(min_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_min_error_for_instance(Theta_3, H_3):\n    \"\"\"\n    Calculates the minimum total error for a single instance of Node 3 parameters\n    by enumerating all 8 possible gate combinations.\n    \"\"\"\n    # Fixed parameters from the problem statement\n    x_low = 1.0\n    x_high = 50.0\n    y_true = np.array([0.0, 100.0, 100.0, 0.0])\n\n    # Input cases (A, B) corresponding to (low, low), (low, high), etc.\n    input_concentrations = [\n        (x_low, x_low),\n        (x_low, x_high),\n        (x_high, x_low),\n        (x_high, x_high)\n    ]\n    \n    # Gate library definitions as dictionaries\n    g1a = {'type': 'activator', 'theta': 10.0, 'L': 5.0, 'H': 110.0}\n    g1r = {'type': 'repressor', 'theta': 10.0, 'L': 5.0, 'H': 110.0}\n    g2a = {'type': 'activator', 'theta': 20.0, 'L': 2.0, 'H': 90.0}\n    g2r = {'type': 'repressor', 'theta': 20.0, 'L': 2.0, 'H': 90.0}\n    g3a = {'type': 'activator', 'theta': Theta_3, 'L': 0.0, 'H': H_3}\n    g3r = {'type': 'repressor', 'theta': Theta_3, 'L': 0.0, 'H': H_3}\n\n    # List of all possible gate choices for each node\n    node_gate_choices = [\n        [g1a, g1r],\n        [g2a, g2r],\n        [g3a, g3r]\n    ]\n    \n    def gate_output(x, params):\n        \"\"\"Calculates the output of a single genetic gate.\"\"\"\n        if params['type'] == 'activator':\n            return params['H'] if x >= params['theta'] else params['L']\n        elif params['type'] == 'repressor':\n            return params['H'] if x = params['theta'] else params['L']\n        # This case should not be reached with valid parameters\n        return 0.0\n\n    min_total_error = float('inf')\n\n    # Exhaustively enumerate all 8 gate combinations (2x2x2)\n    for g1_params in node_gate_choices[0]:\n        for g2_params in node_gate_choices[1]:\n            for g3_params in node_gate_choices[2]:\n                \n                y3_outputs = np.zeros(4)\n                \n                # Evaluate the circuit for all 4 input cases\n                for c, (x_A, x_B) in enumerate(input_concentrations):\n                    # Layer 1 outputs\n                    y1 = gate_output(x_A, g1_params)\n                    y2 = gate_output(x_B, g2_params)\n                    \n                    # Layer 2 input\n                    z = y1 + y2\n                    \n                    # Layer 2 output (final circuit output)\n                    y3 = gate_output(z, g3_params)\n                    y3_outputs[c] = y3\n\n                # Calculate the sum of absolute deviations (total error)\n                total_error = np.sum(np.abs(y3_outputs - y_true))\n                \n                # Update the minimum error found\n                if total_error  min_total_error:\n                    min_total_error = total_error\n\n    return min_total_error\n\nsolve()\n```", "id": "2723633"}]}