{"hands_on_practices": [{"introduction": "为了真正理解代谢分工的优势，我们必须超越定性讨论，建立定量模型。流平衡分析（Flux Balance Analysis, FBA）是一种强大的基于约束的建模框架，它使我们能够预测在资源限制下的代谢途径活性。这项动手实践 [@problem_id:2729044] 提供了一个极简但富有洞察力的 FBA 模型，用于直接比较单个工程菌株与双菌株群落的性能。通过实施并求解该模型，您将探索在不同条件下，拆分代谢途径如何减轻例如蛋白质组总量限制等胞内负担，并最终实现更高的群落产出。", "problem": "考虑一个极简的、有科学依据的流通平衡分析 (FBA) 模型，该模型捕捉了一个工程化的双菌株微生物群落中交换中间代谢物的劳动分工现象。在稳态下，FBA 的基本约束是质量守恒，写为线性系统 $S \\, v = 0$，其中 $S \\in \\mathbb{R}^{m \\times n}$ 是化学计量矩阵，$v \\in \\mathbb{R}^{n}$ 是反应通量向量，每个反应通量都有各自的下界和上界。目标是最大化一个作为生长速率线性代理的指标（生物质通量）。为了模拟细胞内资源限制，使用一个带有非负、不可逆反应的线性蛋白质组预算约束。\n\n单菌株公式（基线）：使用一个单细胞网络，包含代谢物 $\\{A, I, B\\}$ 和反应 $\\{v_{A}, v_{1}, v_{2}, v_{\\mathrm{bio}}\\}$，所有反应通量均约束为非负。化学计量矩阵 $S_{\\mathrm{single}} \\in \\mathbb{R}^{3 \\times 4}$ 为\n$$\nS_{\\mathrm{single}} \\,=\\, \n\\begin{bmatrix}\n1  -1  0  0 \\\\\n0  \\;\\;1  -1  0 \\\\\n0  \\;\\;0  \\;\\;1  -1\n\\end{bmatrix},\n$$\n对应于 $A$: $v_{A} - v_{1} = 0$，$I$: $v_{1} - v_{2} = 0$，以及 $B$: $v_{2} - v_{\\mathrm{bio}} = 0$。底物摄取上限为 $v_{A} \\le U_{A}$ 且 $v_{A} \\ge 0$。线性蛋白质组预算为 $a_{1} v_{1} + a_{2} v_{2} \\le E$，其中 $a_{1} \\ge 0$, $a_{2} \\ge 0$ 且 $E \\ge 0$。目标是最大化 $v_{\\mathrm{bio}}$。\n\n双菌株群落公式（劳动分工）：将反应分配到两个菌株中，并允许通过从菌株1到菌株2的单向菌株间转移通量 $u \\ge 0$ 来交换中间代谢物 $I$。菌株1执行 $A \\to I$；菌株2执行 $I \\to B \\to$ 生物质。决策变量为 $v_{A}^{(1)}, v_{1}^{(1)}, v_{2}^{(2)}, v_{\\mathrm{bio}}^{(2)}, u$，所有变量均 $\\ge 0$。联合群落模型的化学计量矩阵 $S_{\\mathrm{comm}} \\in \\mathbb{R}^{4 \\times 5}$ 为\n$$\nS_{\\mathrm{comm}} \\,=\\, \n\\begin{bmatrix}\n1  -1  0  0  0 \\\\\n0  \\;\\;1  0  0  -1 \\\\\n0  \\;\\;0  -1  0  \\;\\;1 \\\\\n0  \\;\\;0  \\;\\;1  -1  0\n\\end{bmatrix},\n$$\n对应于 $A^{(1)}$: $v_{A}^{(1)} - v_{1}^{(1)} = 0$，$I^{(1)}$: $v_{1}^{(1)} - u = 0$，$I^{(2)}$: $-v_{2}^{(2)} + u = 0$，$B^{(2)}$: $v_{2}^{(2)} - v_{\\mathrm{bio}}^{(2)} = 0$。群落底物摄取上限为 $v_{A}^{(1)} \\le U_{A}$ 且 $v_{A}^{(1)} \\ge 0$。蛋白质组预算独立应用于每个菌株：$a_{1} v_{1}^{(1)} \\le E_{1}$ 和 $a_{2} v_{2}^{(2)} \\le E_{2}$，其中 $E_{1}, E_{2} \\ge 0$。可选地，可以应用菌株间交换能力上限 $u \\le U_{I}$（如果指定；否则视为无上界）。目标是最大化群落生物质 $v_{\\mathrm{bio}}^{(2)}$。\n\n任务：实现一个程序，为下面的每个测试用例，构建并求解上述描述的单菌株和双菌株群落线性规划问题。每个问题都需满足稳态约束 $S \\, v = 0$、所有通量的非负性，以及由摄取、蛋白质组预算和（如果存在）交换能力给出的线性不等式。在每种情况下，使用线性规划最大化相应的生物质通量。然后，为每个测试用例，返回一个三元组，包含：\n- 最优的单菌株生物质值，\n- 最优的双菌株群落生物质值，\n- 一个布尔值，指示分工是否足够放宽细胞内约束以严格改善目标（即，群落最优值严格大于单菌株最优值）。\n\n程序在报告每个生物质值之前必须将其四舍五入到3位小数。不需要物理单位。最终输出必须是单行，包含一个方括号括起来的逗号分隔列表，其中每个元素本身是一个形式为 $[ \\text{single}, \\text{community}, \\text{improved} ]$ 的列表。例如，格式必须像 $[[x_{1},y_{1},b_{1}],[x_{2},y_{2},b_{2}],\\dots]$。\n\n测试套件：\n- 案例1（容量限制，分工有益）：$U_{A} = 10$, $a_{1} = 1$, $a_{2} = 1$, $E = 6$，对于分工情况，$E_{1} = 6$, $E_{2} = 6$，无 $U_{I}$ 上限。\n- 案例2（底物限制，无益处）：$U_{A} = 2$, $a_{1} = 1$, $a_{2} = 1$, $E = 100$，对于分工情况，$E_{1} = 100$, $E_{2} = 100$，无 $U_{I}$ 上限。\n- 案例3（不对称酶成本，分工有益）：$U_{A} = 100$, $a_{1} = 2$, $a_{2} = 1$, $E = 6$，对于分工情况，$E_{1} = 6$, $E_{2} = 6$，无 $U_{I}$ 上限。\n- 案例4（交换限制，分工有害）：$U_{A} = 100$, $a_{1} = 1$, $a_{2} = 1$, $E = 100$，对于分工情况，$E_{1} = 100$, $E_{2} = 100$，交换能力 $U_{I} = 1$。\n\n您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表，每个内部三元组按 $[\\text{single},\\text{community},\\text{improved}]$ 排序，并且两个数值条目都四舍五入到3位小数。", "solution": "首先将对问题陈述进行严格验证。\n\n步骤 1：提取已知条件\n\n提供的信息如下：\n\n- **通用框架**：稳态下的流通平衡分析 (FBA)，由 $S \\mathbf{v} = \\mathbf{0}$ 控制。所有反应通量均为非负 ($v_i \\ge 0$)。目标是最大化生物质通量。资源限制通过线性蛋白质组预算建模。\n\n- **单菌株模型**：\n    - 代谢物：$\\{A, I, B\\}$\n    - 反应（通量向量 $v$）：$\\{v_{A}, v_{1}, v_{2}, v_{\\mathrm{bio}}\\}$，所有 $v_i \\ge 0$。\n    - 化学计量矩阵 $S_{\\mathrm{single}}$：\n      $$S_{\\mathrm{single}} = \\begin{bmatrix} 1  -1  0  0 \\\\ 0  1  -1  0 \\\\ 0  0  1  -1 \\end{bmatrix}$$\n    - 底物摄取约束：$v_{A} \\le U_{A}$。\n    - 蛋白质组预算约束：$a_{1} v_{1} + a_{2} v_{2} \\le E$。\n    - 目标：最大化 $v_{\\mathrm{bio}}$。\n\n- **双菌株群落模型**：\n    - 菌株 $1$：$A \\to I$。菌株 $2$：$I \\to B \\to$ 生物质。\n    - 交换通量：从菌株 $1$ 到菌株 $2$ 的 $u \\ge 0$。\n    - 反应（通量向量 $v$）：$\\{v_{A}^{(1)}, v_{1}^{(1)}, v_{2}^{(2)}, v_{\\mathrm{bio}}^{(2)}, u\\}$，所有均 $\\ge 0$。\n    - 化学计量矩阵 $S_{\\mathrm{comm}}$：\n      $$S_{\\mathrm{comm}} = \\begin{bmatrix} 1  -1  0  0  0 \\\\ 0  1  0  0  -1 \\\\ 0  0  -1  0  1 \\\\ 0  0  1  -1  0 \\end{bmatrix}$$\n    - 底物摄取约束：$v_{A}^{(1)} \\le U_{A}$。\n    - 蛋白质组预算约束：$a_{1} v_{1}^{(1)} \\le E_{1}$ 和 $a_{2} v_{2}^{(2)} \\le E_{2}$。\n    - 交换能力约束：$u \\le U_{I}$（可选）。\n    - 目标：最大化 $v_{\\mathrm{bio}}^{(2)}$。\n\n- **测试用例**：\n    - 案例 $1$：$U_{A} = 10$, $a_{1} = 1$, $a_{2} = 1$, $E = 6$, $E_{1} = 6$, $E_{2} = 6$，无 $U_{I}$。\n    - 案例 $2$：$U_{A} = 2$, $a_{1} = 1$, $a_{2} = 1$, $E = 100$, $E_{1} = 100$, $E_{2} = 100$，无 $U_{I}$。\n    - 案例 $3$：$U_{A} = 100$, $a_{1} = 2$, $a_{2} = 1$, $E = 6$, $E_{1} = 6$, $E_{2} = 6$，无 $U_{I}$。\n    - 案例 $4$：$U_{A} = 100$, $a_{1} = 1$, $a_{2} = 1$, $E = 100$, $E_{1} = 100$, $E_{2} = 100$, $U_{I} = 1$。\n\n- **任务**：对于每个案例，求解两个模型的最优生物质，四舍五入到 $3$ 位小数，并报告一个三元组 $[\\text{single}, \\text{community}, \\text{improved}]$，其中 `improved` 是一个布尔值。\n\n步骤 2：使用提取的已知条件进行验证\n\n对照验证标准对问题进行分析。\n- **科学依据**：该问题是流通平衡分析的一个简化但标准的应用，流通平衡分析是计算系统生物学中一个广泛使用和验证的框架。约束条件——质量平衡 ($S \\mathbf{v} = \\mathbf{0}$)、热力学不可逆性 ($v_i \\ge 0$) 和资源分配（蛋白质组预算）——是细胞代谢建模中的基本概念。该问题是合理的。\n- **良构性**：该问题被构建为两个独立的线性规划 (LP) 问题。对于每个模型，目标是通量的线性函数，所有约束都是线性等式或不等式。这构成了一个良构的 LP 问题，只要可行域非空且有界（在此情况下是成立的），就保证有唯一、稳定且有意义的解。\n- **客观性**：该问题使用精确的数学语言陈述，所有参数和变量都得到了清晰的定义。它没有主观论断或歧义。\n- **完整性**：所有必要的数据和参数（$U_A, a_1, a_2, E, E_1, E_2$ 以及可选的 $U_I$）都已提供。模型结构已完全指定。\n- **一致性**：每个模型内部的约束不相互矛盾。参数在物理上是现实的（非负的成本、容量等）。\n\n该问题未违反任何指定的无效标准。它是一个可形式化的、科学相关的、结构良好的合成生物学问题。\n\n步骤 3：结论与行动\n\n问题是有效的。将提供一个解决方案。\n\n问题的核心是为每组参数求解两个优化问题。两者都是线性规划问题，由于其简单性，可以解析求解，也可以使用标准求解器进行数值求解。基于原理的方法是从第一性原理推导出解，然后为计算将其形式化。\n\n**单菌株模型分析**\n\n稳态质量平衡方程由 $S_{\\mathrm{single}} \\mathbf{v} = \\mathbf{0}$ 给出，其中 $\\mathbf{v} = [v_{A}, v_{1}, v_{2}, v_{\\mathrm{bio}}]^T$。展开如下：\n$v_{A} - v_{1} = 0 \\implies v_{A} = v_{1}$\n$v_{1} - v_{2} = 0 \\implies v_{1} = v_{2}$\n$v_{2} - v_{\\mathrm{bio}} = 0 \\implies v_{2} = v_{\\mathrm{bio}}$\n这表明在稳态下，这个简单线性通路中的所有通量必须相等：$v_A = v_1 = v_2 = v_{\\mathrm{bio}}$。我们将这个共同的通量值称为 $z$。目标是最大化 $v_{\\mathrm{bio}} = z$。\n\n对 $z$ 的约束是：\n1. 非负性：$z \\ge 0$。\n2. 底物摄取：$v_{A} \\le U_{A} \\implies z \\le U_{A}$。\n3. 蛋白质组预算：$a_{1}v_{1} + a_{2}v_{2} \\le E \\implies a_{1}z + a_{2}z \\le E \\implies (a_{1} + a_{2})z \\le E$。这意味著 $z \\le \\frac{E}{a_{1} + a_{2}}$，假设 $a_1+a_2  0$，这对所有测试用例都成立。\n\n为了最大化 $z$，我们必须同时满足所有约束。因此，最优生物质产量受最严格约束的限制：\n$$v_{\\mathrm{bio}, \\text{opt}} = \\max(z) = \\min \\left( U_{A}, \\frac{E}{a_{1} + a_{2}} \\right)$$\n\n**双菌株群落模型分析**\n\n稳态质量平衡方程由 $S_{\\mathrm{comm}} \\mathbf{v} = \\mathbf{0}$ 给出，其中 $\\mathbf{v} = [v_{A}^{(1)}, v_{1}^{(1)}, v_{2}^{(2)}, v_{\\mathrm{bio}}^{(2)}, u]^T$。展开如下：\n$v_{A}^{(1)} - v_{1}^{(1)} = 0 \\implies v_{A}^{(1)} = v_{1}^{(1)}$\n$v_{1}^{(1)} - u = 0 \\implies v_{1}^{(1)} = u$\n$-v_{2}^{(2)} + u = 0 \\implies v_{2}^{(2)} = u$\n$v_{2}^{(2)} - v_{\\mathrm{bio}}^{(2)} = 0 \\implies v_{2}^{(2)} = v_{\\mathrm{bio}}^{(2)}$\n这再次表明所有通量必须相等：$v_{A}^{(1)} = v_{1}^{(1)} = u = v_{2}^{(2)} = v_{\\mathrm{bio}}^{(2)}$。我们将这个共同的通量值称为 $w$。目标是最大化 $v_{\\mathrm{bio}}^{(2)} = w$。\n\n对 $w$ 的约束是：\n1. 非负性：$w \\ge 0$。\n2. 底物摄取：$v_{A}^{(1)} \\le U_{A} \\implies w \\le U_{A}$。\n3. 菌株 $1$ 的蛋白质组预算：$a_{1}v_{1}^{(1)} \\le E_{1} \\implies a_{1}w \\le E_{1} \\implies w \\le \\frac{E_{1}}{a_{1}}$，假设 $a_1  0$。如果 $a_1=0$，此约束不具约束力。\n4. 菌株 $2$ 的蛋白质组预算：$a_{2}v_{2}^{(2)} \\le E_{2} \\implies a_{2}w \\le E_{2} \\implies w \\le \\frac{E_{2}}{a_{2}}$，假设 $a_2  0$。如果 $a_2=0$，此约束不具约束力。\n5. 交换能力（如果指定）：$u \\le U_{I} \\implies w \\le U_{I}$。\n\n关键的洞见是，在单菌株情况下是总和的蛋白质组预算，现在被分成了两个独立的约束。为了最大化 $w$，我们同样必须满足所有适用的约束：\n$$v_{\\mathrm{bio}, \\text{opt}}^{(2)} = \\max(w) = \\min \\left( U_{A}, \\frac{E_{1}}{a_{1}}, \\frac{E_{2}}{a_{2}}, U_{I} \\right)$$\n仅当提供了 $U_I$ 的值时才包含该项；否则，它被视为无穷大，不约束解。\n\n问题询问群落最优值是否严格大于单菌株最优值。这是一个直接比较：$v_{\\mathrm{bio}, \\text{opt}}^{(2)}  v_{\\mathrm{bio}, \\text{opt}}$。\n\n**实现策略**\n\n虽然解析解很直接，但一个健壮的程序应该使用数值线性规划求解器。这种方法可以推广到更复杂的化学计量矩阵，在那些情况下，这样简单的解析简化是不可能的。实现将使用 `scipy.optimize.linprog`。\n\n对于每个模型，问题将被转换为标准形式：在 $A_{eq} x = b_{eq}$、$A_{ub} x \\le b_{ub}$ 以及对 $x$ 的逐元素界限的约束下，最小化 $c^T x$。\n\n- **单菌株 LP**：\n  - 通量向量：$x = [v_{A}, v_{1}, v_{2}, v_{\\mathrm{bio}}]^T$。\n  - 目标：最小化 $c^T x = [0, 0, 0, -1] x$（以最大化 $v_{\\mathrm{bio}}$）。\n  - 等式约束：$A_{eq} = S_{\\mathrm{single}}$，$b_{eq} = [0, 0, 0]^T$。\n  - 不等式约束：$A_{ub} = \\begin{bmatrix} 1  0  0  0 \\\\ 0  a_1  a_2  0 \\end{bmatrix}$，$b_{ub} = \\begin{bmatrix} U_A \\\\ E \\end{bmatrix}$。\n  - 界限：对所有 $i$，$x_i \\ge 0$。\n\n- **双菌株 LP**：\n  - 通量向量：$x = [v_{A}^{(1)}, v_{1}^{(1)}, v_{2}^{(2)}, v_{\\mathrm{bio}}^{(2)}, u]^T$。\n  - 目标：最小化 $c^T x = [0, 0, 0, -1, 0] x$（以最大化 $v_{\\mathrm{bio}}^{(2)}$）。\n  - 等式约束：$A_{eq} = S_{\\mathrm{comm}}$，$b_{eq} = [0, 0, 0, 0]^T$。\n  - 不等式约束：$A_{ub}$ 和 $b_{ub}$ 由约束 $v_{A}^{(1)} \\le U_{A}$、$a_{1}v_{1}^{(1)} \\le E_{1}$、$a_{2}v_{2}^{(2)} \\le E_{2}$ 以及可选的 $u \\le U_{I}$ 组装而成。\n  - 界限：对所有 $i$，$x_i \\ge 0$。\n\n程序将遍历所提供的测试用例，为每个用例构建并求解这两个 LP，并按指定格式化结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Formulates and solves the single-strain and two-strain community FBA problems\n    for a series of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: (UA, a1, a2, E, E1, E2, UI) -- capacity-limited\n        (10, 1, 1, 6, 6, 6, None),\n        # Case 2: (UA, a1, a2, E, E1, E2, UI) -- substrate-limited\n        (2, 1, 1, 100, 100, 100, None),\n        # Case 3: (UA, a1, a2, E, E1, E2, UI) -- asymmetric cost\n        (100, 2, 1, 6, 6, 6, None),\n        # Case 4: (UA, a1, a2, E, E1, E2, UI) -- exchange-limited\n        (100, 1, 1, 100, 100, 100, 1),\n    ]\n\n    # Define the stoichiometric matrices from the problem statement.\n    S_single = np.array([\n        [1, -1, 0, 0],\n        [0, 1, -1, 0],\n        [0, 0, 1, -1]\n    ])\n\n    S_comm = np.array([\n        [1, -1, 0, 0, 0],   # A_1 balance\n        [0, 1, 0, 0, -1],  # I_1 balance\n        [0, 0, -1, 0, 1],   # I_2 balance\n        [0, 0, 1, -1, 0]    # B_2 balance\n    ])\n\n    results = []\n\n    for case in test_cases:\n        UA, a1, a2, E, E1, E2, UI = case\n\n        # === Solve Single-Strain Model ===\n        # Objective: Maximize v_bio, which is to minimize -v_bio\n        # Variables: [v_A, v_1, v_2, v_bio]\n        c_single = np.array([0, 0, 0, -1])\n\n        # Equality constraints: S_single * v = 0\n        A_eq_single = S_single\n        b_eq_single = np.zeros(S_single.shape[0])\n\n        # Inequality constraints:\n        # v_A = UA\n        # a1*v1 + a2*v2 = E\n        A_ub_single = np.array([\n            [1, 0, 0, 0],\n            [0, a1, a2, 0]\n        ])\n        b_ub_single = np.array([UA, E])\n\n        # Bounds: all fluxes are non-negative\n        bounds_single = (0, None)\n\n        # Solve the linear program\n        res_single = linprog(\n            c_single,\n            A_ub=A_ub_single,\n            b_ub=b_ub_single,\n            A_eq=A_eq_single,\n            b_eq=b_eq_single,\n            bounds=bounds_single,\n            method='highs'\n        )\n\n        single_opt = -res_single.fun if res_single.success else 0.0\n\n        # === Solve Two-Strain Community Model ===\n        # Objective: Maximize v_bio^(2), which is to minimize -v_bio^(2)\n        # Variables: [v_A^(1), v_1^(1), v_2^(2), v_bio^(2), u]\n        c_comm = np.array([0, 0, 0, -1, 0])\n\n        # Equality constraints: S_comm * v = 0\n        A_eq_comm = S_comm\n        b_eq_comm = np.zeros(S_comm.shape[0])\n\n        # Inequality constraints:\n        # v_A^(1) = UA\n        # a1*v_1^(1) = E1\n        # a2*v_2^(2) = E2\n        # u = UI (if specified)\n        A_ub_comm_list = [\n            [1, 0, 0, 0, 0],\n            [0, a1, 0, 0, 0],\n            [0, 0, a2, 0, 0]\n        ]\n        b_ub_comm_list = [UA, E1, E2]\n        if UI is not None:\n            A_ub_comm_list.append([0, 0, 0, 0, 1])\n            b_ub_comm_list.append(UI)\n        \n        A_ub_comm = np.array(A_ub_comm_list)\n        b_ub_comm = np.array(b_ub_comm_list)\n\n        # Bounds: all fluxes are non-negative\n        bounds_comm = (0, None)\n\n        # Solve the linear program\n        res_comm = linprog(\n            c_comm,\n            A_ub=A_ub_comm,\n            b_ub=b_ub_comm,\n            A_eq=A_eq_comm,\n            b_eq=b_eq_comm,\n            bounds=bounds_comm,\n            method='highs'\n        )\n\n        community_opt = -res_comm.fun if res_comm.success else 0.0\n\n        # Round results and determine if community improved performance\n        single_opt_rounded = round(single_opt, 3)\n        community_opt_rounded = round(community_opt, 3)\n        improved = community_opt_rounded > single_opt_rounded\n\n        results.append(f\"[{single_opt_rounded:.3f},{community_opt_rounded:.3f},{str(improved).lower()}]\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2729044"}, {"introduction": "在确定了劳动分工的潜在益处后，合成生物学家的下一个关键步骤是确定任务的*最优*分配方式。这是一个经典的设计问题，可以通过双层优化（bilevel optimization）进行优雅地建模，即上层“设计者”做出战略选择，影响下层系统的行为。在这项高级实践 [@problem_id:2729123] 中，您将通过 Lotka-Volterra 方程对群落种群动态进行建模，来形式化地定义这个任务分配问题。这项挑战在于推导出一个能最大化群落层面目标的解决方案，并揭示一个复杂的分层问题如何可以被简化为一个易于处理的几何投影问题。", "problem": "要求您形式化并求解一个受工程微生物群落分工启发的双层优化问题。上层问题在任务间分配精力，下层问题代表竞争性种群动态下的群落稳态。推导必须从质量作用和资源限制性增长原理（最终导出竞争性Lotka–Volterra动力学）以及基础凸分析出发。\n\n模型设定：\n\n- 存在 $n$ 个菌株和 $T$ 个任务。上层决策是一个任务分配向量 $u \\in \\mathbb{R}^T$，其约束在概率单纯形上\n$$\n\\Delta_T \\equiv \\left\\{ u \\in \\mathbb{R}^T \\,\\middle|\\, \\sum_{j=1}^{T} u_j = 1,\\; u_j \\ge 0\\ \\forall j \\right\\}.\n$$\n\n- 丰度向量 $x(t) \\in \\mathbb{R}^n_{\\ge 0}$ 的下层群落动力学由竞争性Lotka–Volterra常微分方程给出，该方程源于质量作用相互作用和资源限制：\n$$\n\\frac{d x_i}{dt} = x_i \\left( a_i(u) - \\sum_{k=1}^{n} C_{ik} x_k \\right),\\quad i \\in \\{1,\\dots,n\\},\n$$\n其中 $C \\in \\mathbb{R}^{n \\times n}$ 是对称正定矩阵（相互作用矩阵），内禀增长项 $a(u) \\in \\mathbb{R}^n$ 通过以下方式线性依赖于 $u$\n$$\na(u) = s + M u,\n$$\n其中 $s \\in \\mathbb{R}^n$ 且 $M \\in \\mathbb{R}^{n \\times T}$。假设参数的选择使得 $a(u)$ 在 $\\Delta_T$ 上各分量均为正。\n\n- 下层稳态 $x^\\star(u) \\in \\mathbb{R}^n_{0}$ 是该动力学系统的正平衡点。\n\n- 上层目标是最大化稳态带来的群落层面线性收益，并以一个关于 $u$ 的严格凸二次正则化项进行惩罚：\n$$\n\\max_{u \\in \\Delta_T} \\; J(u) \\equiv L^\\top x^\\star(u) \\;-\\; \\frac{\\alpha}{2} \\,\\|u\\|_2^2,\n$$\n其中 $L \\in \\mathbb{R}^n$ 且 $\\alpha \\in \\mathbb{R}_{0}$。\n\n任务：\n\n1) 从给定的模型定义出发，并基于 $C$ 是对称正定且 $a(u)$ 在 $\\Delta_T$ 上各分量均为正的假设，分析下层正平衡点的存在性和唯一性。然后分析上层最大化解的存在性和唯一性。您的分析必须基于基本原理，使用动力系统和凸分析的标准结论，并且不能将目标结果作为出发点。\n\n2) 当 $x^\\star(u)$ 的所有分量均为正时，为其推导一个显式代数表达式，然后在给定假设下，将上层目标函数化简为一个关于 $u$ 的严格凹函数，其惩罚项形式为 $\\frac{\\alpha}{2}\\|u\\|_2^2$（其中标量 $\\alpha  0$）。\n\n3) 证明所得的上层问题等价于将参数的一个仿射变换投影到单纯形 $\\Delta_T$ 上。提出一个计算最优任务分配 $u^\\star$ 的算法并说明其合理性。\n\n4) 实现一个程序，对以下每个测试用例，计算并输出保留六位小数的最优分配 $u^\\star$。所有矩阵和向量均在下方指定；确保您的程序不需要用户输入。最终输出必须是单行文本，包含一个用方括号括起来的、以逗号分隔的列表的列表（例如，形如 $[\\,[\\cdot,\\cdot],\\,[\\cdot,\\cdot]\\,]$ 的一行）。所有量均不涉及物理单位。\n\n测试集：\n\n- 情况 A（内部解，通用参数）：\n  - $n = 2$, $T = 2$.\n  - $C = \\begin{bmatrix} 1.2  0.1 \\\\ 0.1  1.1 \\end{bmatrix}$.\n  - $s = \\begin{bmatrix} 0.3 \\\\ 0.2 \\end{bmatrix}$.\n  - $M = \\begin{bmatrix} 0.5  0.2 \\\\ 0.1  0.4 \\end{bmatrix}$.\n  - $L = \\begin{bmatrix} 1.0 \\\\ 0.8 \\end{bmatrix}$.\n  - $\\alpha = 0.5$.\n\n- 情况 B（$\\Delta_T$ 顶点上的边界解）：\n  - $n = 2$, $T = 2$.\n  - $C = \\begin{bmatrix} 1.0  0.0 \\\\ 0.0  1.0 \\end{bmatrix}$.\n  - $s = \\begin{bmatrix} 1.0 \\\\ 1.0 \\end{bmatrix}$.\n  - $M = \\begin{bmatrix} 2.0  -0.5 \\\\ 1.0  0.0 \\end{bmatrix}$.\n  - $L = \\begin{bmatrix} 1.0 \\\\ 1.0 \\end{bmatrix}$.\n  - $\\alpha = 0.2$.\n\n- 情况 C（产生均匀分配的对称参数）：\n  - $n = 2$, $T = 3$.\n  - $C = \\begin{bmatrix} 1.0  0.0 \\\\ 0.0  1.0 \\end{bmatrix}$.\n  - $s = \\begin{bmatrix} 0.1 \\\\ 0.1 \\end{bmatrix}$.\n  - $M = \\begin{bmatrix} 0.5  0.5  0.5 \\\\ 0.5  0.5  0.5 \\end{bmatrix}$.\n  - $L = \\begin{bmatrix} 1.0 \\\\ 1.0 \\end{bmatrix}$.\n  - $\\alpha = 0.3$.\n\n答案规格：\n\n- 您的程序必须为每种情况计算 $u^\\star$，并生成单行输出，格式为 $[u^\\star_A,u^\\star_B,u^\\star_C]$，其中每个 $u^\\star$ 打印为保留六位小数的浮点数列表，不含任何额外文本。\n\n- 每个返回的内部列表的长度必须为相应情况下的 $T$，且其元素之和在数值舍入误差范围内应为 $1.000000$。所有条目必须为十进制形式（浮点数）。", "solution": "所述问题具有科学依据，是适定的、客观的且内部一致的。它为根植于成熟的种群动力学和凸优化原理的双层优化问题提供了一个有效的公式化表达。因此，我们可以直接进行推导和求解。\n\n分析将按要求分四部分进行。\n\n第一部分：存在性和唯一性分析\n\n首先，我们分析下层问题，它涉及群落动力学的稳态。该动力学由竞争性Lotka-Volterra方程描述：\n$$\n\\frac{d x_i}{dt} = x_i \\left( a_i(u) - \\sum_{k=1}^{n} C_{ik} x_k \\right) \\quad \\text{for } i \\in \\{1,\\dots,n\\}.\n$$\n我们寻求一个正平衡点，记为 $x^\\star(u)$，其中对所有 $i$ 都有 $x^\\star_i(u)  0$ 且 $\\frac{d x_i}{dt} = 0$。对于正平衡点，条件 $\\frac{d x_i}{dt} = 0$ 意味着括号内的项必须为零：\n$$\na_i(u) - \\sum_{k=1}^{n} C_{ik} x^\\star_k(u) = 0.\n$$\n用向量形式表示，这是一个线性系统 $a(u) - C x^\\star(u) = 0$。问题陈述中指出相互作用矩阵 $C \\in \\mathbb{R}^{n \\times n}$ 是对称正定的（SPD）。根据定义，正定矩阵是可逆的。因此，对于任意给定的向量 $a(u)$，该线性系统存在唯一解：\n$$\nx^\\star(u) = C^{-1} a(u).\n$$\n问题陈述中明确假设这个唯一平衡点是正的，即对于所有有效的 $u$，都有 $x^\\star(u) \\in \\mathbb{R}^n_{0}$。此外，对于竞争性Lotka-Volterra系统，正平衡点的存在性与正定相互作用矩阵 $C$ 相结合，是该平衡点对于所有正初始条件全局渐近稳定的充分条件。因此，对于任何给定的任务分配 $u$，群落动力学收敛到一个唯一的、稳定的、正的稳态 $x^\\star(u)$。\n\n接下来，我们分析上层问题：\n$$\n\\max_{u \\in \\Delta_T} \\; J(u) \\equiv L^\\top x^\\star(u) - \\frac{\\alpha}{2} \\|u\\|_2^2.\n$$\n优化在定义域 $\\Delta_T$（即 $\\mathbb{R}^T$ 中的标准概率单纯形）上进行。单纯形是一个非空、紧致且凸的集合。为确定最大化解的存在性和唯一性，我们必须分析目标函数 $J(u)$ 的性质。代入 $x^\\star(u)$ 的表达式和 $a(u) = s + Mu$ 的定义，我们得到：\n$$\nJ(u) = L^\\top (C^{-1}(s + Mu)) - \\frac{\\alpha}{2} \\|u\\|_2^2.\n$$\n展开此表达式得到：\n$$\nJ(u) = L^\\top C^{-1}s + (L^\\top C^{-1} M) u - \\frac{\\alpha}{2} \\|u\\|_2^2.\n$$\n该函数是一个常数项（$L^\\top C^{-1}s$）、一个关于 $u$ 的线性项（$(L^\\top C^{-1} M) u$）和一个二次惩罚项（$-\\frac{\\alpha}{2} \\|u\\|_2^2$）的和。线性函数既是凸函数也是凹函数。二次项 $-\\frac{\\alpha}{2} \\|u\\|_2^2$ 是严格凹的，因为它的Hessian矩阵是 $-\\alpha I_T$，其中 $I_T$ 是 $T \\times T$ 单位矩阵。由于给定 $\\alpha  0$，该Hessian矩阵是负定的。一个凹函数与一个严格凹函数的和是严格凹的。因此，$J(u)$ 是关于 $u$ 的严格凹函数。\n\n问题是在一个非空、紧致、凸集上最大化一个连续的严格凹函数。根据Weierstrass极值定理，紧集上的连续函数必能达到其最大值。根据凹函数的性质，凸集上的严格凹函数至多有一个全局最大化解。因此，上层优化问题存在唯一的解 $u^\\star$。\n\n第二部分：显式公式和目标函数化简\n\n如上所推导，平衡条件 $a(u) - C x^\\star = 0$ 以及SPD矩阵 $C$ 的可逆性，给出了正稳态的显式代数公式：\n$$\nx^\\star(u) = C^{-1} a(u) = C^{-1} (s + M u).\n$$\n将其代入上层目标函数 $J(u)$ 中得到：\n$$\nJ(u) = L^\\top \\left( C^{-1} (s + M u) \\right) - \\frac{\\alpha}{2} \\|u\\|_2^2.\n$$\n利用矩阵乘法的线性性质，我们将 $L^\\top C^{-1}$ 分配进去：\n$$\nJ(u) = L^\\top C^{-1} s + (L^\\top C^{-1} M) u - \\frac{\\alpha}{2} \\|u\\|_2^2.\n$$\n这就是所求的目标函数关于 $u$ 的化简形式。如前所述，这是一个关于 $u$ 的严格凹二次函数，证实了第一部分的结论。\n\n第三部分：与单纯形投影的等价性及算法\n\n优化问题是 $\\max_{u \\in \\Delta_T} J(u)$。这等价于最小化目标函数的负数，即 $\\min_{u \\in \\Delta_T} -J(u)$。\n$$\n-J(u) = -\\left(L^\\top C^{-1} M\\right) u - L^\\top C^{-1} s + \\frac{\\alpha}{2} \\|u\\|_2^2.\n$$\n常数项 $-L^\\top C^{-1}s$ 不影响最小化解的位置，因此可以忽略。问题等价于：\n$$\n\\min_{u \\in \\Delta_T} \\left\\{ \\frac{\\alpha}{2} \\|u\\|_2^2 - (M^\\top (C^{-1})^\\top L)^\\top u \\right\\}.\n$$\n已知 $C$ 是对称的，这意味着其逆矩阵 $C^{-1}$ 也是对称的，所以 $(C^{-1})^\\top = C^{-1}$。因此问题变为：\n$$\n\\min_{u \\in \\Delta_T} \\left\\{ \\frac{\\alpha}{2} \\|u\\|_2^2 - (M^\\top C^{-1} L)^\\top u \\right\\}.\n$$\n我们定义一个向量 $v \\in \\mathbb{R}^T$ 如下：\n$$\nv = \\frac{1}{\\alpha} M^\\top C^{-1} L.\n$$\n通过将目标函数乘以正常数 $1/\\alpha$，优化问题可以改写为：\n$$\n\\min_{u \\in \\Delta_T} \\left\\{ \\frac{1}{2} \\|u\\|_2^2 - v^\\top u \\right\\}.\n$$\n这个目标函数可以看作是欧几里得范数平方的一部分。我们进行配方：\n$$\n\\frac{1}{2} \\|u\\|_2^2 - v^\\top u = \\frac{1}{2} (u^\\top u - 2v^\\top u + v^\\top v) - \\frac{1}{2}v^\\top v = \\frac{1}{2} \\|u - v\\|_2^2 - \\frac{1}{2} \\|v\\|_2^2.\n$$\n由于 $\\frac{1}{2}\\|v\\|_2^2$ 是一个关于 $u$ 的常数，最小化此表达式等价于最小化 $\\|u - v\\|_2^2$。因此，问题是：\n$$\n\\min_{u \\in \\Delta_T} \\|u - v\\|_2^2.\n$$\n这就是将向量 $v$ 欧几里得投影到概率单纯形 $\\Delta_T$ 上的定义。最优分配 $u^\\star$ 是单纯形上距离向量 $v = \\frac{1}{\\alpha} M^\\top C^{-1} L$ 最近的点。\n\n一个计算此投影的高效算法基于此约束二次规划的Karush-Kuhn-Tucker (KKT) 条件。解 $u^\\star$ 由 $u^\\star_j = \\max(0, v_j - \\theta)$ 给出（对于 $j=1,\\dots,T$），其中阈值 $\\theta$ 的选择要满足约束 $\\sum_j u^\\star_j = 1$。一种找到 $\\theta$ 的稳健方法如下：\n1. 将向量 $v$ 的分量按降序排列：$v_{(1)} \\ge v_{(2)} \\ge \\dots \\ge v_{(T)}$。\n2. 找到最大的整数 $\\rho \\in \\{1, \\dots, T\\}$，使得 $v_{(\\rho)} - \\frac{1}{\\rho}\\left(\\sum_{j=1}^{\\rho} v_{(j)} - 1\\right)  0$。\n3. 计算阈值 $\\theta = \\frac{1}{\\rho}\\left(\\sum_{j=1}^{\\rho} v_{(j)} - 1\\right)$。\n4. 最优分配则由 $u^\\star_j = \\max(0, v_j - \\theta)$ 给出（对于所有 $j$）。\n\n第四部分：实现\n程序将实现推导出的解法。对每个测试用例，它将：\n1. 构建矩阵 $C, M$ 和向量 $s, L$。\n2. 计算向量 $v = \\frac{1}{\\alpha} M^\\top C^{-1} L$。这需要对 $C$ 求逆。\n3. 使用上述算法将 $v$ 投影到单纯形 $\\Delta_T$ 上以找到 $u^\\star$。\n4. 按规定格式收集并格式化结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef project_simplex(v: np.ndarray) - np.ndarray:\n    \"\"\"\n    Projects a vector v onto the probability simplex using the algorithm\n    by Duchi et al. (2008).\n    \"\"\"\n    T = v.shape[0]\n    \n    # Sort v in descending order\n    # It's faster to sort in-place, but this is clearer.\n    # We keep track of original indices to reconstruct the output vector.\n    v_sorted = np.sort(v)[::-1]\n    \n    # Compute the cumulative sum of the sorted vector\n    cssv = np.cumsum(v_sorted)\n    \n    # Find the largest rho such that v_sorted[rho] > (cssv[rho] - 1) / (rho + 1)\n    # The condition is checked for rho = 0, 1, ..., T-1\n    # This is equivalent to finding j in {1..T} in the paper's notation\n    indices = np.arange(1, T + 1)\n    condition = v_sorted - (cssv - 1) / indices  0\n    \n    # The last index (from a 0-based array) where condition is true\n    # np.where returns a tuple of arrays, we need the first one.\n    rho_idx = np.where(condition)[0][-1]\n    \n    # The threshold theta (lambda in the paper)\n    theta = (cssv[rho_idx] - 1) / (rho_idx + 1)\n    \n    # Compute the projection\n    u_star = np.maximum(v - theta, 0)\n    \n    return u_star\n\ndef solve():\n    \"\"\"\n    Solves the bilevel optimization problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        # Case A (interior solution, generic parameters)\n        {\n            \"C\": np.array([[1.2, 0.1], [0.1, 1.1]]),\n            \"s\": np.array([0.3, 0.2]),\n            \"M\": np.array([[0.5, 0.2], [0.1, 0.4]]),\n            \"L\": np.array([1.0, 0.8]),\n            \"alpha\": 0.5,\n        },\n        # Case B (boundary solution at a vertex of Delta_T)\n        {\n            \"C\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n            \"s\": np.array([1.0, 1.0]),\n            \"M\": np.array([[2.0, -0.5], [1.0, 0.0]]),\n            \"L\": np.array([1.0, 1.0]),\n            \"alpha\": 0.2,\n        },\n        # Case C (symmetric parameters yielding a uniform allocation)\n        {\n            \"C\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n            \"s\": np.array([0.1, 0.1]),\n            \"M\": np.array([[0.5, 0.5, 0.5], [0.5, 0.5, 0.5]]),\n            \"L\": np.array([1.0, 1.0]),\n            \"alpha\": 0.3,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        C = case[\"C\"]\n        M = case[\"M\"]\n        L = case[\"L\"]\n        alpha = case[\"alpha\"]\n\n        # Step 1: Invert the interaction matrix C\n        C_inv = np.linalg.inv(C)\n\n        # Step 2: Compute the vector v to be projected\n        # v = (1/alpha) * M^T * C^{-1} * L\n        v = (1 / alpha) * M.T @ C_inv @ L\n\n        # Step 3: Project v onto the simplex to find the optimal allocation u*\n        u_star = project_simplex(v)\n        \n        # Round the result to six decimal places and format as a list of floats\n        rounded_u_star = [f\"{x:.6f}\" for x in u_star]\n        results.append(f\"[{','.join(rounded_u_star)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2729123"}]}