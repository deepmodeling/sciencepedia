{"hands_on_practices": [{"introduction": "理解胚胎模式如何从信号动态中涌现，是发育生物学的核心目标。本练习要求您构建一个计算模型，模拟Nodal、Wnt和BMP等关键形态发生素的精确时序和空间分布，如何在合成胚胎样结构中调控胚层的指定。通过实现这个模拟 [@problem_id:2780289]，您将亲身体验自组织原理，并掌握运用计算模型来检验关于发育过程假说的强大能力。", "problem": "设计并实现一个模拟程序，该程序模拟 Nodal、Wnt 和骨形态发生蛋白 (BMP) 通路活动的时间序列如何在一个代表合成胚胎样结构的球面上分配胚层。模拟必须围绕一个固定轴呈轴对称，因此活动仅取决于极角。使用基于常微分方程 (ODE) 的低通滤波器来捕捉有限的信号传导时间尺度，并使用 Hill 型转导非线性来捕捉决定胚层命运的基因调控响应。\n\n建模假设和定义：\n- 几何与坐标：使用单位球面，并具有轴对称性，因此状态仅取决于极角 $\\theta \\in [0,\\pi]$（弧度）。在球面上进行平均的表面积权重为 $\\sin(\\theta)$。\n- 时间：在 $t \\in [0,T]$ 上进行模拟，其中 $T>0$（无量纲时间）。使用一个固定的时间步长 $\\Delta t$，其选择应足够小以解析 ODE 动态。\n- 通路：对于每个通路 $P \\in \\{\\text{Nodal} (\\mathcal{N}), \\text{Wnt} (\\mathcal{W}), \\text{BMP} (\\mathcal{B})\\}$，定义一个浓度场 $c_P(\\theta,t)$，其受以下一阶线性 ODE 控制\n  $$\\frac{\\mathrm{d}c_P(\\theta,t)}{\\mathrm{d}t} \\;=\\; -\\lambda_P\\,c_P(\\theta,t) \\;+\\; \\alpha_P\\, s_P(t)\\, g_P(\\theta), \\quad c_P(\\theta,0)=0,$$\n  其中 $\\lambda_P>0$ 是衰减率，$\\alpha_P>0$ 是输入增益，$s_P(t)$ 是时间源分布，$g_P(\\theta)$ 是位置依赖性敏感度（两者均在下文定义）。此 ODE 在每个 $\\theta$ 处实现对源输入的的一阶低通滤波。\n- 时间源分布：对于每个通路 $P$，使用一个矩形脉冲\n  $$s_P(t) \\;=\\; A_P \\cdot \\mathbf{1}\\!\\left[t_{\\mathrm{on},P} \\le t  t_{\\mathrm{on},P} + \\tau_P\\right],$$\n  其中 $A_P \\ge 0$ 是振幅，$t_{\\mathrm{on},P}\\ge 0$ 是起始时间，$\\tau_P \\ge 0$ 是持续时间。\n- 空间敏感度：对于每个通路 $P$，使用一个以 $\\mu_P$ 为中心、宽度为 $\\sigma_P0$ 的关于极角的高斯函数，\n  $$g_P(\\theta) \\;=\\; \\exp\\!\\left(-\\frac{\\left(\\theta-\\mu_P\\right)^2}{2\\,\\sigma_P^2}\\right),$$\n  其最大值为 $1$，通过此方式隐式归一化。\n- 信号转导：通过对 Hill 函数进行时间平均，将浓度映射到转录响应，\n  $$H(x;K,h) \\;=\\; \\frac{x^h}{K^h + x^h}, \\qquad r_P(\\theta) \\;=\\; \\frac{1}{T}\\int_{0}^{T} H\\!\\left(c_P(\\theta,t); K_P, h_P\\right)\\,\\mathrm{d}t,$$\n  其中 $K_P0$ 是激活常数，$h_P\\ge 1$ 是 Hill 系数。量 $r_P(\\theta)\\in[0,1]$ 是时间平均的通路响应。\n- 命运评分与分配：根据平均响应 $r_{\\mathcal{N}}(\\theta)$、$r_{\\mathcal{W}}(\\theta)$ 和 $r_{\\mathcal{B}}(\\theta)$ 计算三个命运分数，\n  $$S_{\\mathrm{end}}(\\theta) \\;=\\; r_{\\mathcal{N}}(\\theta)\\,\\bigl(1 - \\tfrac{1}{2} r_{\\mathcal{B}}(\\theta)\\bigr),$$\n  $$S_{\\mathrm{mes}}(\\theta) \\;=\\; r_{\\mathcal{W}}(\\theta)\\, r_{\\mathcal{B}}(\\theta)\\,\\bigl(\\tfrac{1}{2} + \\tfrac{1}{2} r_{\\mathcal{N}}(\\theta)\\bigr),$$\n  $$S_{\\mathrm{ect}}(\\theta) \\;=\\; \\bigl(1 - r_{\\mathcal{N}}(\\theta)\\bigr)\\,\\bigl(1 - r_{\\mathcal{W}}(\\theta)\\bigr)\\,\\bigl(\\tfrac{1}{2} + \\tfrac{1}{2} r_{\\mathcal{B}}(\\theta)\\bigr).$$\n  通过最大分数来分配角度 $\\theta$ 处的命运。如果出现完全平局，则按内胚层  中胚层  外胚层的顺序确定性地打破平局。\n- 面积分数：通过将分配给每个命运的指示函数与正确的表面积权重进行积分，报告分配给每种命运的球面面积分数。如果 $\\mathcal{F}_i$ 是分配给命运 $i\\in\\{\\mathrm{ect},\\mathrm{mes},\\mathrm{end}\\}$ 的 $\\theta$ 集合，计算\n  $$f_i \\;=\\; \\frac{\\int_{0}^{\\pi} \\mathbf{1}\\!\\left[\\theta \\in \\mathcal{F}_i\\right] \\sin(\\theta)\\,\\mathrm{d}\\theta}{\\int_{0}^{\\pi} \\sin(\\theta)\\,\\mathrm{d}\\theta} \\;=\\; \\frac{1}{2}\\int_{0}^{\\pi} \\mathbf{1}\\!\\left[\\theta \\in \\mathcal{F}_i\\right] \\sin(\\theta)\\,\\mathrm{d}\\theta.$$\n  分数 $f_{\\mathrm{ect}}, f_{\\mathrm{mes}}, f_{\\mathrm{end}}$ 的总和必须为 $1$（允许数值舍入误差）。将每个分数表示为小数点后保留三位的小数。\n\n除非在测试用例中另有说明，否则全程使用以下参数值：\n- 共享的几何与动力学参数：$\\;T=10.0,\\;\\Delta t=0.01.$\n- 衰减与增益：$\\;\\lambda_{\\mathcal{N}}=\\lambda_{\\mathcal{W}}=\\lambda_{\\mathcal{B}}=1.0,\\;\\alpha_{\\mathcal{N}}=\\alpha_{\\mathcal{W}}=\\alpha_{\\mathcal{B}}=1.0.$\n- 空间敏感度中心和宽度（弧度）：$\\;\\mu_{\\mathcal{N}}=2.4,\\;\\mu_{\\mathcal{W}}=\\frac{\\pi}{2},\\;\\mu_{\\mathcal{B}}=0.4,\\;$ 且 $\\;\\sigma_{\\mathcal{N}}=\\sigma_{\\mathcal{W}}=\\sigma_{\\mathcal{B}}=0.5.$\n- Hill 参数：$\\;K_{\\mathcal{N}}=K_{\\mathcal{W}}=K_{\\mathcal{B}}=0.5,\\;h_{\\mathcal{N}}=h_{\\mathcal{W}}=h_{\\mathcal{B}}=2.$\n- 角度离散化：在 $[0,\\pi]$ 上对 $\\theta$ 使用一个足够精细的均匀网格，以解析高斯分布和 $\\sin(\\theta)$ 权重。\n\n测试套件：\n为以下四种源时序场景提供面积分数 $\\bigl[f_{\\mathrm{ect}},f_{\\mathrm{mes}},f_{\\mathrm{end}}\\bigr]$，每种场景由一个包含九个标量的元组 $(A_{\\mathcal{N}}, t_{\\mathrm{on},\\mathcal{N}}, \\tau_{\\mathcal{N}}, A_{\\mathcal{W}}, t_{\\mathrm{on},\\mathcal{W}}, \\tau_{\\mathcal{W}}, A_{\\mathcal{B}}, t_{\\mathrm{on},\\mathcal{B}}, \\tau_{\\mathcal{B}})$ 指定：\n- 情况 1（顺序 $\\mathcal{N}\\to \\mathcal{W}\\to \\mathcal{B}$）：$\\;(A_{\\mathcal{N}}, t_{\\mathrm{on},\\mathcal{N}}, \\tau_{\\mathcal{N}}, A_{\\mathcal{W}}, t_{\\mathrm{on},\\mathcal{W}}, \\tau_{\\mathcal{W}}, A_{\\mathcal{B}}, t_{\\mathrm{on},\\mathcal{B}}, \\tau_{\\mathcal{B}}) = (1.0, 0.0, 3.0, 1.0, 2.0, 3.0, 1.0, 4.0, 3.0)$。\n- 情况 2（同步）：$\\;(1.0, 0.0, 3.0, 1.0, 0.0, 3.0, 1.0, 0.0, 3.0)$。\n- 情况 3（逆序 $\\mathcal{B}\\to \\mathcal{W}\\to \\mathcal{N}$）：$\\;(1.0, 4.0, 3.0, 1.0, 2.0, 3.0, 1.0, 0.0, 3.0)$。\n- 情况 4（空输入）：$\\;(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)$。\n\n程序要求：\n- 在每个 $\\theta$ 处，为每个通路使用前向欧拉法实现 ODE 积分。\n- 按照上述定义计算时间平均的 Hill 响应和命运分数。\n- 使用 argmax 和指定的平局打破规则来分配命运。\n- 计算面积加权分数 $f_{\\mathrm{ect}}, f_{\\mathrm{mes}}, f_{\\mathrm{end}}$，并将每个分数四舍五入到小数点后三位。\n- 角度必须以弧度为单位。没有物理单位。\n- 最终输出格式：程序应生成单行输出，包含四个案例的结果，格式为一个由方括号括起来的列表组成的逗号分隔列表，例如，\"[[x11,x12,x13],[x21,x22,x23],[x31,x32,x33],[x41,x42,x43]]\"，其中每个 $x_{ij}$ 是一个小数点后恰好有三位数字的小数。", "solution": "问题陈述已经过严格验证。它描述了一个定义明确、有科学依据且计算上可行的模型，该模型模拟了在合成生物学背景下由形态发生素驱动的细胞命运决定。该公式是自洽的，所有参数和函数都有明确定义。没有矛盾、歧义或违反科学原则之处。因此，该问题被认为是有效的，我们可以继续进行解的推导和实现。\n\n任务是模拟一个常微分方程 (ODE) 系统，该系统对信号通路动力学进行建模，并随后根据这些通路的时间积分活动来确定胚层命运。该解决方案需要一种数值方法，对时间和单一空间维度（极角 $\\theta$）进行离散化。\n\n**1. 区域的离散化**\n\n为了进行数值计算，必须对连续变量时间 $t$ 和极角 $\\theta$ 进行离散化。\n\n-   **时间离散化**：模拟在区间 $t \\in [0, T]$ 上运行，其中 $T=10.0$。指定了一个固定的时间步长 $\\Delta t = 0.01$。这定义了一组离散的时间点 $t_k = k \\cdot \\Delta t$，其中 $k = 0, 1, \\dots, N_t$，总步数为 $N_t = T / \\Delta t = 10.0 / 0.01 = 1000$。这产生了 $N_t+1 = 1001$ 个时间点。\n\n-   **空间离散化**：空间域是极角 $\\theta \\in [0, \\pi]$。我们必须选择一个足够精细的网格来解析空间特征，这些特征是标准差为 $\\sigma_P = 0.5$ 弧度的高斯分布。使用一个包含 $N_\\theta$ 个点的均匀网格是合适的。我们选择 $N_\\theta = 1001$ 个点，这提供了一个高分辨率，角步长为 $\\Delta\\theta = \\pi / (N_\\theta - 1) = \\pi / 1000 \\approx 0.00314$ 弧度。离散角度为 $\\theta_j = j \\cdot \\Delta\\theta$，其中 $j = 0, 1, \\dots, N_\\theta - 1$。这个网格足以精确地表示高斯敏感度函数 $g_P(\\theta)$ 和表面积加权因子 $\\sin(\\theta)$。\n\n**2. 信号 ODE 的数值解**\n\n对于每个通路 $P \\in \\{\\mathcal{N}, \\mathcal{W}, \\mathcal{B}\\}$，浓度 $c_P(\\theta, t)$ 由以下 ODE 控制：\n$$\n\\frac{\\mathrm{d}c_P(\\theta,t)}{\\mathrm{d}t} = -\\lambda_P c_P(\\theta,t) + \\alpha_P s_P(t) g_P(\\theta), \\quad c_P(\\theta,0) = 0\n$$\n问题指定使用前向欧拉法进行积分。对于给定的空间点 $\\theta_j$，从时间 $t_k$ 到 $t_{k+1}$ 的更新规则是：\n$$\nc_P(\\theta_j, t_{k+1}) = c_P(\\theta_j, t_k) + \\Delta t \\left( -\\lambda_P c_P(\\theta_j, t_k) + \\alpha_P s_P(t_k) g_P(\\theta_j) \\right)\n$$\n为了提高计算效率，这可以重写为：\n$$\nc_P(\\theta_j, t_{k+1}) = (1 - \\lambda_P \\Delta t) c_P(\\theta_j, t_k) + (\\alpha_P \\Delta t) s_P(t_k) g_P(\\theta_j)\n$$\n此更新从 $k=0$ 到 $N_t - 1$ 的每个时间步迭代应用，起始条件为对所有 $j$ 都有 $c_P(\\theta_j, t_0) = 0$。该计算可以在每个时间步对所有空间点 $\\theta_j$ 进行向量化。\n\n**3. 时间平均通路响应的计算**\n\n在计算了浓度 $c_P(\\theta_j, t_k)$ 的完整时间演化后，我们确定时间平均的通路响应 $r_P(\\theta_j)$。对于每个通路 $P$ 和空间点 $\\theta_j$，这涉及两个步骤：通过 Hill 函数的非线性转导，然后是时间积分。\nHill 函数由下式给出：\n$$\nH(x; K_P, h_P) = \\frac{x^{h_P}}{K_P^{h_P} + x^{h_P}}\n$$\n我们将此函数应用于每个 $k=0, \\dots, N_t$ 的浓度时间序列 $c_P(\\theta_j, t_k)$。时间平均响应 $r_P(\\theta_j)$ 是积分：\n$$\nr_P(\\theta_j) = \\frac{1}{T} \\int_{0}^{T} H(c_P(\\theta_j, t); K_P, h_P) \\, \\mathrm{d}t\n$$\n该积分使用梯形法则进行数值近似，这比简单的黎曼和提供了更高的准确性：\n$$\nr_P(\\theta_j) \\approx \\frac{1}{T} \\sum_{k=0}^{N_t-1} \\frac{H(c_P(\\theta_j, t_k)) + H(c_P(\\theta_j, t_{k+1}))}{2} \\Delta t = \\frac{1}{T} \\cdot \\mathrm{trapz}(H(c_P(\\theta_j, :)), \\mathrm{dx}=\\Delta t)\n$$\n该计算产生三个积分通路响应的空间分布：$r_{\\mathcal{N}}(\\theta_j)$、$r_{\\mathcal{W}}(\\theta_j)$ 和 $r_{\\mathcal{B}}(\\theta_j)$。\n\n**4. 通过分数最大化进行命运分配**\n\n每个位置 $\\theta_j$ 的胚层命运通过比较三个命运分数来确定，这些分数是上述响应分布的函数：\n$$\nS_{\\mathrm{end}}(\\theta_j) = r_{\\mathcal{N}}(\\theta_j) \\left(1 - \\frac{1}{2} r_{\\mathcal{B}}(\\theta_j)\\right)\n$$\n$$\nS_{\\mathrm{mes}}(\\theta_j) = r_{\\mathcal{W}}(\\theta_j) r_{\\mathcal{B}}(\\theta_j) \\left(\\frac{1}{2} + \\frac{1}{2} r_{\\mathcal{N}}(\\theta_j)\\right)\n$$\n$$\nS_{\\mathrm{ect}}(\\theta_j) = \\left(1 - r_{\\mathcal{N}}(\\theta_j)\\right) \\left(1 - r_{\\mathcal{W}}(\\theta_j)\\right) \\left(\\frac{1}{2} + \\frac{1}{2} r_{\\mathcal{B}}(\\theta_j)\\right)\n$$\n分配给位置 $\\theta_j$ 的命运是对应于最大分数的那个。问题指定了一个确定性的平局打破规则：内胚层  中胚层  外胚层。通过以这个精确的顺序检查最大分数来实现这种层级。在编程上，这可以通过按 $[S_{\\mathrm{end}}, S_{\\mathrm{mes}}, S_{\\mathrm{ect}}]$ 的顺序堆叠分数并找到沿此新轴的最大值的索引来实现。返回最大值首次出现索引的 `argmax` 函数自然地执行了这个平局打破规则。\n\n**5. 面积分数的计算**\n\n最后一步是计算每个胚层所占据的总球面面积的分数。对于给定的命运 $i \\in \\{\\mathrm{ect}, \\mathrm{mes}, \\mathrm{end}\\}$，面积分数 $f_i$ 由以下积分给出：\n$$\nf_i = \\frac{\\int_{0}^{\\pi} \\mathbf{1}[\\theta \\in \\mathcal{F}_i] \\sin(\\theta) \\, \\mathrm{d}\\theta}{\\int_{0}^{\\pi} \\sin(\\theta) \\, \\mathrm{d}\\theta} = \\frac{1}{2} \\int_{0}^{\\pi} \\mathbf{1}[\\theta \\in \\mathcal{F}_i] \\sin(\\theta) \\, \\mathrm{d}\\theta\n$$\n其中 $\\mathbf{1}[\\theta \\in \\mathcal{F}_i]$ 是一个指示函数，如果 $\\theta$ 处的命运是 $i$，则为 $1$，否则为 $0$。我们再次使用梯形法则对离散网格 $\\theta_j$ 进行数值近似该积分，以获得更高的准确性：\n$$\nf_i \\approx \\frac{1}{2} \\cdot \\mathrm{trapz}(\\mathbf{1}[\\theta_j \\in \\mathcal{F}_i] \\sin(\\theta_j), \\mathrm{x}=\\theta_j)\n$$\n我们对三种命运中的每一种都执行此计算。得到的分数 $f_{\\mathrm{ect}}, f_{\\mathrm{mes}}, f_{\\mathrm{end}}$ 的总和必须为 $1$，允许有数值精度误差。最终值将报告为四舍五入到三位小数。\n\n这完成了模拟的逻辑设计。实现将对所提供的四个测试用例中的每一个遵循这些步骤。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n\n    # --- Model Parameters ---\n    # Shared geometry and dynamics\n    T = 10.0\n    DT = 0.01\n    N_THETA = 1001  # Number of spatial grid points for theta\n\n    # Pathway-specific parameters\n    PATHWAYS = ['Nodal', 'Wnt', 'BMP']\n    LAMBDAS = {'Nodal': 1.0, 'Wnt': 1.0, 'BMP': 1.0}\n    ALPHAS = {'Nodal': 1.0, 'Wnt': 1.0, 'BMP': 1.0}\n    MUS = {'Nodal': 2.4, 'Wnt': np.pi / 2, 'BMP': 0.4}\n    SIGMAS = {'Nodal': 0.5, 'Wnt': 0.5, 'BMP': 0.5}\n    KS = {'Nodal': 0.5, 'Wnt': 0.5, 'BMP': 0.5}\n    HS = {'Nodal': 2.0, 'Wnt': 2.0, 'BMP': 2.0}\n\n    # --- Test Cases ---\n    # Each case is a tuple of (A_N, t_on_N, tau_N, A_W, t_on_W, tau_W, A_B, t_on_B, tau_B)\n    test_cases = [\n        (1.0, 0.0, 3.0, 1.0, 2.0, 3.0, 1.0, 4.0, 3.0),  # Case 1: Sequential\n        (1.0, 0.0, 3.0, 1.0, 0.0, 3.0, 1.0, 0.0, 3.0),  # Case 2: Synchronous\n        (1.0, 4.0, 3.0, 1.0, 2.0, 3.0, 1.0, 0.0, 3.0),  # Case 3: Reverse Sequential\n        (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0),  # Case 4: Null\n    ]\n\n    # --- Discretization Setup ---\n    theta_grid = np.linspace(0, np.pi, N_THETA)\n    n_t_steps = int(T / DT)\n    time_grid = np.linspace(0, T, n_t_steps + 1)\n\n    results = []\n    for case in test_cases:\n        source_params = {\n            'Nodal': {'A': case[0], 't_on': case[1], 'tau': case[2]},\n            'Wnt': {'A': case[3], 't_on': case[4], 'tau': case[5]},\n            'BMP': {'A': case[6], 't_on': case[7], 'tau': case[8]},\n        }\n\n        r = {}  # To store time-averaged responses r_P(theta)\n\n        for p_name in PATHWAYS:\n            # Get parameters for the current pathway\n            lambda_p, alpha_p = LAMBDAS[p_name], ALPHAS[p_name]\n            mu_p, sigma_p = MUS[p_name], SIGMAS[p_name]\n            K_p, h_p = KS[p_name], HS[p_name]\n            A_p = source_params[p_name]['A']\n            t_on_p = source_params[p_name]['t_on']\n            tau_p = source_params[p_name]['tau']\n\n            # Spatial sensitivity profile\n            g_p = np.exp(-((theta_grid - mu_p)**2) / (2 * sigma_p**2))\n\n            # --- ODE Integration (Forward Euler) ---\n            c_history = np.zeros((n_t_steps + 1, N_THETA))\n            for k in range(n_t_steps):\n                t_k = time_grid[k]\n                \n                # Rectangular pulse source term\n                s_p_k = A_p if t_on_p = t_k  t_on_p + tau_p else 0.0\n                \n                # Euler update step (vectorized over theta)\n                c_current = c_history[k, :]\n                c_next = (c_current * (1 - lambda_p * DT) + \n                          (alpha_p * DT) * s_p_k * g_p)\n                c_history[k + 1, :] = c_next\n            \n            # --- Time-Averaged Response Calculation ---\n            # Hill function transduction\n            with np.errstate(divide='ignore', invalid='ignore'):\n                 c_history_h = np.power(c_history, h_p)\n                 K_p_h = K_p**h_p\n                 H_history = np.nan_to_num(c_history_h / (K_p_h + c_history_h))\n\n            # Numerical integration using trapezoidal rule\n            r[p_name] = (1 / T) * np.trapz(H_history, dx=DT, axis=0)\n\n        # Unpack responses\n        r_N, r_W, r_B = r['Nodal'], r['Wnt'], r['BMP']\n\n        # --- Fate Scoring ---\n        S_end = r_N * (1 - 0.5 * r_B)\n        S_mes = r_W * r_B * (0.5 + 0.5 * r_N)\n        S_ect = (1 - r_N) * (1 - r_W) * (0.5 + 0.5 * r_B)\n\n        # --- Fate Allocation with Tie-breaking ---\n        # Stacking order (end, mes, ect) implements the tie-breaking rule\n        # because np.argmax returns the index of the first maximum.\n        scores = np.stack([S_end, S_mes, S_ect], axis=0)\n        # fate_indices: 0=end, 1=mes, 2=ect\n        fate_indices = np.argmax(scores, axis=0)\n\n        # --- Area Fraction Calculation ---\n        # Integrands for each fate\n        integrand_end = (fate_indices == 0) * np.sin(theta_grid)\n        integrand_mes = (fate_indices == 1) * np.sin(theta_grid)\n        integrand_ect = (fate_indices == 2) * np.sin(theta_grid)\n\n        # Numerical integration using trapezoidal rule\n        f_end = 0.5 * np.trapz(integrand_end, x=theta_grid)\n        f_mes = 0.5 * np.trapz(integrand_mes, x=theta_grid)\n        f_ect = 0.5 * np.trapz(integrand_ect, x=theta_grid)\n\n        # Append results in specified order: [ect, mes, end]\n        results.append([f_ect, f_mes, f_end])\n\n    # --- Format and Print Final Output ---\n    case_results_str = []\n    for res in results:\n        # Round to three decimal places and format as a string list\n        case_results_str.append(f\"[{res[0]:.3f},{res[1]:.3f},{res[2]:.3f}]\")\n\n    final_output_str = f\"[{','.join(case_results_str)}]\"\n    print(final_output_str)\n\nsolve()\n```", "id": "2780289"}, {"introduction": "除了化学信号，来自微环境的物理线索在指导细胞命运中也扮演着至关重要的角色。本练习聚焦于机械转导——即细胞感知并响应诸如基质刚度等机械刺激的过程。您将构建一个系统级模型 [@problem_id:2780330]，该模型将基质刚度与YAP/TAZ转录共激活因子的核定位联系起来，最终决定细胞的命运概率，从而深入了解物理力如何塑造发育过程。", "problem": "您正在建模Yes相关蛋白 (YAP) 和含PDZ结合基序的转录共激活因子 (TAZ) 的机械转导如何将基质硬度与合成的类胚胎结构和类器官中的细胞命运决定耦合起来。请建立一个最小系统模型，将基质硬度与核转运和转录输出联系起来，然后将转录输出转换为命运决定的概率。仅使用第一性原理的动力学平衡和标准的S型响应曲线作为基础，并从这些基础上推导出所需的任何稳态关系。在一个评估指定测试套件的程序中实现推导出的关系。\n\n使用的基础理论：\n- 在稳态下，YAP/TAZ的核-质穿梭遵循质量作用的区室动力学和守恒定律。\n- 肌动球蛋白介导的机械感应响应基质硬度，呈饱和希尔型函数形式。\n- 作为核内YAP/TAZ分数的函数，转录激活呈饱和希尔型函数形式。\n- 从转录活性到二元命运选择概率的逻辑斯谛输入-输出映射。\n\n模型结构和定义：\n- 令 $Y_{\\text{N}}$ 和 $Y_{\\text{C}}$ 分别为总YAP/TAZ库中的核内组分和胞质组分，满足 $Y_{\\text{N}} + Y_{\\text{C}} = 1$。令 $k_{\\text{in}}(E)$ 为核输入速率，$k_{\\text{out}}$ 为核输出速率。其动力学遵循\n$$\\frac{dY_{\\text{N}}}{dt} = k_{\\text{in}}(E)\\,Y_{\\text{C}} - k_{\\text{out}}\\,Y_{\\text{N}}.$$\n施加稳态条件，并根据 $k_{\\text{in}}(E)$、$k_{\\text{out}}$ 和守恒约束推导出稳态核内组分 $f_{\\text{N}} = Y_{\\text{N}}^{\\ast}$。\n- 输入速率 $k_{\\text{in}}(E)$ 随着基质杨氏模量 $E$ 的增加而增加，通过一个由希尔函数描述的机械传感器 $M(E)$，其希尔系数为 $n$，硬度标度为 $K_{E}$：\n$$M(E) = \\frac{E^{n}}{K_{E}^{n} + E^{n}},\\quad k_{\\text{in}}(E) = k_{\\text{in0}}\\left(1 + \\alpha\\,M(E)\\right).$$\n- 由核内YAP/TAZ驱动的转录活性 $A$ 是 $f_{\\text{N}}$ 的希尔函数，其希尔系数为 $m$，半激活值为 $K_{T}$：\n$$A = T_{\\max}\\,\\frac{f_{\\text{N}}^{m}}{K_{T}^{m} + f_{\\text{N}}^{m}}.$$\n- 选择命运 $\\mathcal{F}_{A}$ 而不是备选命运 $\\mathcal{F}_{B}$ 的概率由 $A$ 的逻辑斯谛函数给出，其斜率为 $\\beta$，中点为 $A_{50}$：\n$$p_{A} = \\frac{1}{1 + \\exp\\!\\left(-\\beta\\,(A - A_{50})\\right)}.$$\n\n参数值：\n- 基础输入速率 $k_{\\text{in0}} = 0.02\\,\\text{s}^{-1}$。\n- 输出速率 $k_{\\text{out}} = 0.05\\,\\text{s}^{-1}$。\n- 机械敏感性振幅 $\\alpha = 8$ (无量纲)。\n- 机械传感器希尔系数 $n = 2$ (无量纲)。\n- 硬度半饱和 $K_{E} = 5\\,\\text{kPa}$。\n- 最大转录活性 $T_{\\max} = 1$ (无量纲)。\n- 转录希尔系数 $m = 3$ (无量纲)。\n- 转录半激活 $K_{T} = 0.5$ (无量纲，单位为 $f_{\\text{N}}$)。\n- 逻辑斯谛斜率 $\\beta = 8$ (无量纲)。\n- 逻辑斯谛中点 $A_{50} = 0.4$ (无量纲)。\n\n单位和输入：\n- 基质硬度 $E$ 必须以 $\\text{kPa}$ 为单位提供。\n- 输出概率 $p_{A}$ 必须以 $[0,1]$ 范围内的小数形式报告。\n\n任务：\n- 根据稳态条件和守恒定律，推导出 $f_{\\text{N}}$ 关于 $k_{\\text{in}}(E)$ 和 $k_{\\text{out}}$ 的显式表达式。\n- 组合映射 $E \\mapsto M(E) \\mapsto k_{\\text{in}}(E) \\mapsto f_{\\text{N}} \\mapsto A \\mapsto p_{A}$ 并进行数值实现。\n\n测试套件：\n- 针对以下基质硬度值（均以 $\\text{kPa}$ 为单位）评估模型：$E \\in \\{0,\\,0.2,\\,1,\\,5,\\,20,\\,100\\}$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个 $p_{A}$ 四舍五入到 $6$ 位小数，顺序与测试套件相同（例如，$\"[0.123456,0.234567,\\dots]\"$）。", "solution": "问题陈述已经过评估，并被确定为有效。它具有科学依据，问题设定良好、客观，并为标准系统生物学模型提供了一套完整、一致的定义和参数。这是一个计算建模中的可解问题，而不是一个不适定或伪深刻的问题。因此，我们将着手解决。\n\n解决方案需要两个连续的任务：首先，推导一个解析表达式；其次，对整个模型进行数值实现。\n\n**1. 稳态核内YAP/TAZ分数的推导**\n\nYAP/TAZ核内分数 $Y_{\\text{N}}$ 的动力学由以下常微分方程给出：\n$$\n\\frac{dY_{\\text{N}}}{dt} = k_{\\text{in}}(E)\\,Y_{\\text{C}} - k_{\\text{out}}\\,Y_{\\text{N}}\n$$\n此处，$Y_{\\text{C}}$ 是胞质分数，$k_{\\text{in}}(E)$ 是依赖于硬度的核输入速率，$k_{\\text{out}}$ 是恒定的核输出速率。\n\n总YAP/TAZ库是守恒的，因此各分数之和必须为1：\n$$\nY_{\\text{N}} + Y_{\\text{C}} = 1\n$$\n这使我们能够将 $Y_{\\text{C}}$ 表示为 $Y_{\\text{N}}$ 的函数，即 $Y_{\\text{C}} = 1 - Y_{\\text{N}}$。\n\n问题要求的是稳态解。在稳态时，核内浓度的净变化为零。我们将稳态分数表示为 $Y_{\\text{N}}^{\\ast}$ 和 $Y_{\\text{C}}^{\\ast}$。条件是：\n$$\n\\frac{dY_{\\text{N}}}{dt} = 0\n$$\n代入速率和浓度的表达式，得到：\n$$\nk_{\\text{in}}(E)\\,Y_{\\text{C}}^{\\ast} - k_{\\text{out}}\\,Y_{\\text{N}}^{\\ast} = 0\n$$\n现在我们使用守恒定律来消除 $Y_{\\text{C}}^{\\ast}$：\n$$\nk_{\\text{in}}(E)\\,(1 - Y_{\\text{N}}^{\\ast}) - k_{\\text{out}}\\,Y_{\\text{N}}^{\\ast} = 0\n$$\n问题将稳态核内分数定义为 $f_{\\text{N}} = Y_{\\text{N}}^{\\ast}$。我们对上述线性代数方程求解 $f_{\\text{N}}$：\n$$\nk_{\\text{in}}(E) - k_{\\text{in}}(E)\\,f_{\\text{N}} - k_{\\text{out}}\\,f_{\\text{N}} = 0\n$$\n$$\nk_{\\text{in}}(E) = f_{\\text{N}}\\,(k_{\\text{in}}(E) + k_{\\text{out}})\n$$\n分离 $f_{\\text{N}}$ 得到关于动力学速率的显式表达式：\n$$\nf_{\\text{N}} = \\frac{k_{\\text{in}}(E)}{k_{\\text{in}}(E) + k_{\\text{out}}}\n$$\n这完成了第一个任务。该表达式表明，稳态核内分数是输入和输出速率的简单比率函数。\n\n**2. 映射的组合与数值评估**\n\n第二个任务是组合从基质硬度 $E$ 到命运决定概率 $p_{A}$ 的完整映射序列，并为给定的测试套件评估该模型。计算序列如下，所有参数均取自问题陈述。\n\n步骤 1：计算机械传感器活性 $M(E)$ 作为基质硬度 $E$ (单位为 $\\text{kPa}$) 的函数。\n$$\nM(E) = \\frac{E^{n}}{K_{E}^{n} + E^{n}}\n$$\n其中 $n=2$ 且 $K_{E}=5\\,\\text{kPa}$。\n\n步骤 2：计算核输入速率 $k_{\\text{in}}(E)$ 作为 $M(E)$ 的函数。\n$$\nk_{\\text{in}}(E) = k_{\\text{in0}}\\left(1 + \\alpha\\,M(E)\\right)\n$$\n其中 $k_{\\text{in0}}=0.02\\,\\text{s}^{-1}$ 且 $\\alpha=8$。\n\n步骤 3：使用推导出的表达式计算稳态核内分数 $f_{\\text{N}}$。\n$$\nf_{\\text{N}}(E) = \\frac{k_{\\text{in}}(E)}{k_{\\text{in}}(E) + k_{\\text{out}}}\n$$\n其中 $k_{\\text{out}}=0.05\\,\\text{s}^{-1}$。\n\n步骤 4：计算转录活性 $A$ 作为 $f_{\\text{N}}$ 的函数。\n$$\nA(f_{\\text{N}}) = T_{\\max}\\,\\frac{f_{\\text{N}}^{m}}{K_{T}^{m} + f_{\\text{N}}^{m}}\n$$\n其中 $T_{\\max}=1$，$m=3$ 且 $K_{T}=0.5$。\n\n步骤 5：计算命运 $\\mathcal{F}_{A}$ 的最终概率，记为 $p_{A}$，作为 $A$ 的函数。\n$$\np_{A}(A) = \\frac{1}{1 + \\exp\\!\\left(-\\beta\\,(A - A_{50})\\right)}\n$$\n其中 $\\beta=8$ 且 $A_{50}=0.4$。\n\n这五个步骤构成了完整的函数 $p_{A}(E)$。我们现在将为测试套件 $\\{0,\\,0.2,\\,1,\\,5,\\,20,\\,100\\}\\,\\text{kPa}$ 中的每个 $E$ 值进行数值实现。最终程序将执行此计算链并按指定格式输出结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the YAP/TAZ mechanotransduction model for a given test suite of substrate stiffness values.\n    \"\"\"\n    # Define model parameters as provided in the problem statement.\n    k_in0 = 0.02   # Basal import rate (s^-1)\n    k_out = 0.05   # Export rate (s^-1)\n    alpha = 8.0    # Mechanosensitivity amplitude (dimensionless)\n    n = 2.0        # Mechanosensor Hill coefficient (dimensionless)\n    K_E = 5.0      # Stiffness half-saturation (kPa)\n    T_max = 1.0    # Maximum transcriptional activity (dimensionless)\n    m = 3.0        # Transcriptional Hill coefficient (dimensionless)\n    K_T = 0.5      # Transcriptional half-activation (dimensionless fraction)\n    beta = 8.0     # Logistic slope (dimensionless)\n    A_50 = 0.4     # Logistic midpoint (dimensionless)\n\n    # Define the test suite of substrate stiffness values.\n    test_cases_E = [0.0, 0.2, 1.0, 5.0, 20.0, 100.0]\n\n    # List to store the calculated probabilities.\n    results = []\n\n    # Iterate through each stiffness value and calculate the fate probability.\n    for E in test_cases_E:\n        # Step 1: Calculate mechanosensor activity M(E).\n        # The term E^n can be zero, so we handle division by zero for E=0\n        # although adding a small epsilon is more robust, direct check is fine here.\n        if E == 0.0:\n            M_E = 0.0\n        else:\n            M_E = (E**n) / (K_E**n + E**n)\n\n        # Step 2: Calculate the stiffness-dependent nuclear import rate k_in(E).\n        k_in_E = k_in0 * (1.0 + alpha * M_E)\n\n        # Step 3: Calculate the steady-state nuclear fraction f_N.\n        f_N = k_in_E / (k_in_E + k_out)\n\n        # Step 4: Calculate transcriptional activity A.\n        A = T_max * (f_N**m) / (K_T**m + f_N**m)\n        \n        # Step 5: Calculate the probability of fate A, p_A.\n        p_A = 1.0 / (1.0 + np.exp(-beta * (A - A_50)))\n        \n        # Append the formatted result to the list.\n        results.append(f\"{p_A:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solver function.\nsolve()\n```", "id": "2780330"}, {"introduction": "观察到一种模式只是第一步；一个关键挑战是推断其生成机制。这项高级练习将为您提供定量工具，以区分两种基本的模式形成方式：自发性对称破缺和边界驱动的极性。通过实施一个基于空间自相关和相位随机化代理数据的检验方法 [@problem_id:2780370]，您将学习一种严谨的、数据驱动的方法来形成和检验关于生物组织起源的假说。", "problem": "设计并实现一个完整的、可运行的程序，该程序能在模拟圆形合成类器官区域上标记物分布的二维标量场中，定量地区分“边界驱动的极性”和“自发对称性破缺”。您的程序必须使用空间自相关和相位随机化控制，从第一性原理出发，实现一个决策测试。您必须使用的基本原理包括：(i) 通过莫兰指数 I（Moran's I (MI)）定义空间自相关，(ii) 圆形域上的边界距离场的概念，以及 (iii) 通过保持振幅的傅里叶相位随机化方法构建代理零模型。除这些原理外，您不得使用任何捷径。\n\n定义和必要计算：\n- 空间自相关：给定一个定义在二值圆形掩模 $\\mathcal{M}$ 内部、由索引 $i \\in \\{1,\\dots,N\\}$ 标记的像素上的标量场 $X$，莫兰指数 I (MI) 是为一个对称的二值最近邻权重矩阵 $W = [w_{ij}]$ 定义的，其中如果 $i$ 和 $j$ 是正交网格上的四邻域像素且均位于 $\\mathcal{M}$ 内，则 $w_{ij} = 1$，否则 $w_{ij} = 0$。设 $\\bar{X} = \\frac{1}{|\\mathcal{M}|}\\sum_{i \\in \\mathcal{M}} X_i$ 且 $S_0 = \\sum_{i}\\sum_{j} w_{ij}$。则\n$$\nI = \\frac{|\\mathcal{M}|}{S_0} \\cdot \\frac{\\sum_{i}\\sum_{j} w_{ij}\\,(X_i - \\bar{X})(X_j - \\bar{X})}{\\sum_{i \\in \\mathcal{M}} (X_i - \\bar{X})^2}.\n$$\n- 边界距离场：对于一个以 $(c_x,c_y)$ 为中心、半径为 $R$ 的圆形掩模，定义位于 $(x,y)$ 的像素到边界的欧几里得距离为：在圆内 $d_b(x,y) = R - \\sqrt{(x-c_x)^2 + (y-c_y)^2}$，在圆外 $d_b(x,y) = 0$。在 $\\mathcal{M}$ 上将其归一化到 $[0,1]$ 区间，即 $\\tilde{d}_b = d_b / R$。\n- 边界耦合统计量：计算在 $\\mathcal{M}$ 内所有像素上 $X$ 和 $\\tilde{d}_b$ 之间的皮尔逊相关系数。设此相关系数为 $\\rho$，并定义其大小为 $|\\rho|$。\n- 相位随机化代理数据：设 $\\mathcal{F}\\{X\\}$ 表示完整图像的二维离散傅里叶变换，其中 $\\mathcal{M}$ 之外的像素值被设为零。通过保留振幅谱 $|\\mathcal{F}\\{X\\}|$ 并将相位在 $[-\\pi,\\pi]$ 上进行均匀随机化来构建代理场 $X^{(s)}$，同时强制执行厄米对称性以确保逆变换结果为实数。将重建的场与掩模 $\\mathcal{M}$ 相乘以恢复其定义域。这会创建一个零假设集，其功率谱（以及因此的总体空间自相关尺度）与观测数据相匹配，但破坏了特定的相关系。对于每个代理数据，计算其相对于 $\\tilde{d}_b$ 的边界耦合大小 $|\\rho^{(s)}|$。从 $S$ 个代理数据中，估计 $|\\rho^{(s)}|$ 的均值 $\\mu_{\\mathrm{null}}$ 和标准差 $\\sigma_{\\mathrm{null}}$。定义 $z$-分数\n$$\nz = \\frac{|\\rho| - \\mu_{\\mathrm{null}}}{\\sigma_{\\mathrm{null}} + \\epsilon},\n$$\n其中 $\\epsilon$ 是一个很小的数，以避免除以零。\n\n基于以上内容的决策规则：\n- 首先，通过要求足够大的正空间自相关来评估是否存在空间模式：如果 $I  \\tau_I$，则判定为“无模式”。\n- 否则，通过边界耦合的显著性来评估边界驱动的极性：如果 $z \\ge \\tau_z$，则判定为“边界驱动的极性”；如果 $z  \\tau_z$，则判定为“自发对称性破缺”。\n- 使用 $\\tau_I = 0.02$, $\\tau_z = 3.0$ 和 $\\epsilon = 10^{-9}$。\n\n用于确保覆盖率的测试套件：\n所有场都在一个大小为 $N \\times N$（其中 $N=64$）的方形网格上生成，带有一个以 $(c_x,c_y) = (N/2,N/2)$ 为中心、半径为 $R=28$ 的圆形掩模。程序必须在内部合成以下四种情况，并使用独立的随机种子以确保可复现性。噪声是在生成基础场之后添加的独立同分布高斯噪声；每个案例都指定了标准差 $\\sigma$。基础场在掩模之外的值始终为零。\n1) 边界驱动，径向中心高值：基础场为 $X(x,y) = \\tilde{d}_b(x,y)$ (对于 $(x,y) \\in \\mathcal{M}$)，加上标准差为 $\\sigma = 0.05$ 的噪声。随机种子 $s = 1$。\n2) 自发对称性破缺，线性偶极子：设 $\\mathbf{u} = (\\cos\\theta, \\sin\\theta)$，其中 $\\theta = 37^\\circ$ 为固定角度（以弧度表示）。基础场为 $X(x,y) = \\frac{(x-c_x)u_x + (y-c_y)u_y}{R}$ (对于 $(x,y) \\in \\mathcal{M}$)，加上标准差为 $\\sigma = 0.05$ 的噪声。随机种子 $s = 2$。\n3) 无模式（白噪声）：基础场 $X(x,y) = 0$ (对于所有 $(x,y)$)；添加标准差为 $\\sigma = 1.0$ 的噪声。随机种子 $s = 3$。\n4) 边界驱动，径向外周高值：基础场为 $X(x,y) = 1 - \\tilde{d}_b(x,y)$ (对于 $(x,y) \\in \\mathcal{M}$)，加上标准差为 $\\sigma = 0.05$ 的噪声。随机种子 $s = 4$。\n\n代理数据配置：每个案例使用 $S = 64$ 个代理数据。\n\n必需的输出和格式：\n- 对每个案例，输出一个分类整数：$0$ 代表“无模式”，$1$ 代表“自发对称性破缺”，$2$ 代表“边界驱动的极性”。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[2,1,0,2]”），按上文列出的顺序对应四个案例的结果。\n- 程序不接受用户输入；它必须是完全自包含且可复现的。\n\n科学真实性约束：\n- 对于需要限制在特定域内进行平均和相关计算的统计量，确保所有计算都只在掩模 $\\mathcal{M}$ 内部的像素上进行。\n- 相位随机化代理数据的构建必须严格保留振幅谱 $|\\mathcal{F}\\{X\\}|$ 并强制执行厄米对称性，以确保逆变换结果为实数值，从而提供一个有效的控制组，该控制组保留了空间自相关的长度尺度，同时消除了边界-相位耦合。", "solution": "所提出的问题陈述是有效的。它在科学上基于空间统计和信号处理的原理，其定义完整且一致，问题阐述清晰，并且其表述是客观的。它要求实现一个定量测试，用以区分生物系统中两种基本的模式形成方式——边界驱动的极性和自发对称性破缺——这两种方式被建模为圆形域上的标量场。整个过程是可验证且计算上可行的。我们将根据指定的第一性原理，进行严谨的、分步的实现。\n\n该解决方案通过实现一系列算法来构建，每个算法对应决策过程中的一个特定概念步骤。\n\n**1. 合成数据和参考场的生成**\n\n首先，我们建立计算域。我们定义一个大小为 $N \\times N$（其中 $N=64$）的方形网格。在此网格上，定义一个以 $(c_x, c_y) = (N/2, N/2)$ 为中心、半径为 $R=28$ 的圆形掩模 $\\mathcal{M}$。如果网格坐标为 $(i, j)$ 的像素满足 $\\sqrt{(i-c_x)^2 + (j-c_y)^2}  R$，则该像素属于掩模。\n\n问题需要一个 **边界距离场**，它作为一个空间模板来描述径向组织的模式。对于掩模内每个位于 $(x,y)$ 的像素，其到边界的欧几里得距离定义为 $d_b(x,y) = R - \\sqrt{(x-c_x)^2 + (y-c_y)^2}$。该场通过半径 $R$ 进行归一化，以创建一个无量纲的场 $\\tilde{d}_b = d_b / R$，其值范围从边界处的 $0$ 到中心处的 $1$。\n\n按照规定合成了四个测试案例。每个案例代表圆形域上不同类别的空间模式。生成一个基础场，然后用具有指定标准差 $\\sigma$ 的加性高斯噪声进行扰动，并使用唯一的随机种子以保证可复现性。最终的场 $X$ 被掩模处理，即其在 $\\mathcal{M}$ 之外的值被设为 $0$。\n\n- **案例 1 (边界驱动，中心高值):** $X(x,y) = \\tilde{d}_b(x,y) + \\text{noise}(\\sigma=0.05)$。\n- **案例 2 (自发偶极子):** $X(x,y) = ((x-c_x)u_x + (y-c_y)u_y)/R + \\text{noise}(\\sigma=0.05)$，其中 $\\mathbf{u}$ 是一个固定角度的单位向量。这代表一个线性梯度，是一种与圆形边界不一致的简单形式的自发对称性破缺。\n- **案例 3 (无模式):** $X(x,y) = \\text{noise}(\\sigma=1.0)$，代表空间不相关的白噪声。\n- **案例 4 (边界驱动，外周高值):** $X(x,y) = 1 - \\tilde{d}_b(x,y) + \\text{noise}(\\sigma=0.05)$。\n\n**2. 空间自相关：莫兰指数 I**\n\n决策规则的第一步是确定是否存在任何显著的空间模式。我们使用 **莫兰指数 I**，一种衡量全局空间自相关的指标。其公式为：\n$$\nI = \\frac{|\\mathcal{M}|}{S_0} \\cdot \\frac{\\sum_{i \\in \\mathcal{M}}\\sum_{j \\in \\mathcal{M}} w_{ij}\\,(X_i - \\bar{X})(X_j - \\bar{X})}{\\sum_{i \\in \\mathcal{M}} (X_i - \\bar{X})^2}\n$$\n在此， $|\\mathcal{M}|$ 是掩模内的像素数量。$\\bar{X}$ 是场 $X$ 在掩模上的均值。权重矩阵 $W=[w_{ij}]$ 的定义为：如果像素 $i$ 和 $j$ 是四连通的邻居（上、下、左、右）且均在 $\\mathcal{M}$ 内，则 $w_{ij}=1$；否则 $w_{ij}=0$。项 $S_0 = \\sum_i \\sum_j w_{ij}$ 是权重的总和，对应于掩模内邻居链接数量的两倍。\n\n分子项 $\\sum_i \\sum_j w_{ij}(X_i - \\bar{X})(X_j - \\bar{X})$ 量化了像素值与其邻居值之间的协方差。这一项可以被高效计算。设 $X'$ 是中心化后的场（即在 $\\mathcal{M}$ 内 $X' = X - \\bar{X}$，在外部为 $0$）。该和可以写为 $\\sum_i X'_i (\\sum_j w_{ij} X'_j)$。内层和 $\\sum_j w_{ij} X'_j$ 是场 $X'$ 与一个代表4邻域连接性的核的离散卷积。这通过 `scipy.ndimage.convolve` 实现。如果 $I  \\tau_I = 0.02$，我们将模式分类为“无模式”（代码 $0$）。\n\n**3. 边界耦合统计量**\n\n如果检测到模式（$I \\ge \\tau_I$），我们必须区分其来源。一个关键的区分指标是模式与圆形边界的对齐程度。我们使用 **皮尔逊相关系数** $\\rho$ 来量化这一点，该系数是数据场 $X$ 与归一化边界距离场 $\\tilde{d}_b$ 之间的相关性。相关性仅在掩模 $\\mathcal{M}$ 内的像素上计算。\n$$\n\\rho = \\frac{\\sum_{i \\in \\mathcal{M}} (X_i - \\bar{X})(\\tilde{d}_{b,i} - \\bar{\\tilde{d}}_b)}{\\sqrt{\\sum_{i \\in \\mathcal{M}} (X_i - \\bar{X})^2 \\sum_{i \\in \\mathcal{M}} (\\tilde{d}_{b,i} - \\bar{\\tilde{d}}_b)^2}}\n$$\n由于边界驱动的模式可能在中心处值高（正相关）或在外周处值高（负相关），我们使用相关性的绝对值 $|\\rho|$ 作为我们的统计量。\n\n**4. 通过相位随机化代理数据构建零模型**\n\n一个高的 $|\\rho|$ 值可能是偶然出现的，特别是当场具有强的低频空间相关性时。为了评估观测到的 $|\\rho|$ 的统计显著性，我们将其与一个零分布进行比较。这个零分布是使用 **保持振幅的相位随机化** 方法生成的。\n\n该过程如下：\n1.  计算数据场 $X$ 的二维离散傅里叶变换，得到复系数 $\\mathcal{F}\\{X\\}$。为了效率和正确处理实值数据的厄米对称性，我们使用实数到复数的变换 `numpy.fft.rfft2`。\n2.  保留原始数据的振幅谱 $|\\mathcal{F}\\{X\\}|$。这确保了代理场将具有相同的功率谱，因此具有相同的总体空间自相关特性（例如，莫兰指数 I 的期望值相同）。\n3.  通过从 $[0, 2\\pi)$ 的均匀分布中抽样，将每个傅里叶系数的相位随机化。为确保逆变换得到实值场，直流分量（$k=0$）和奈奎斯特频率分量的相位被设为 $0$。\n4.  使用原始振幅和新的随机相位构建代理傅里叶谱 $\\mathcal{F}\\{X^{(s)}\\}$。\n5.  应用逆傅里叶变换 (`numpy.fft.irfft2`) 以获得实值的代理场 $X^{(s)}$。\n6.  最后，将圆形掩模 $\\mathcal{M}$ 重新应用于代理场。\n\n这个过程生成的代理场在空间纹理和自相关长度尺度方面与原始场统计上相似，但任何特定的相位对齐——例如那种会导致与径向边界距离场强相关的对齐——都被破坏了。这提供了一个稳健的零假设。\n\n**5. 决策规则**\n\n通过生成大量代理数据（$S=64$），我们创建了一个 $|\\rho^{(s)}|$ 值的集合。从这个集合中，我们估计均值 $\\mu_{\\mathrm{null}}$ 和标准差 $\\sigma_{\\mathrm{null}}$。观测到的边界耦合 $|\\rho|$ 的显著性随后通过 $z$-分数来量化：\n$$\nz = \\frac{|\\rho| - \\mu_{\\mathrm{null}}}{\\sigma_{\\mathrm{null}} + \\epsilon}\n$$\n其中 $\\epsilon=10^{-9}$ 是一个很小的常数，用于防止除以零。\n\n一个大的 $z$-分数表明，观测到的与边界的相关性极不可能是由于随机机会产生的，即使考虑了场固有的空间结构。最终的分类如下：\n- 如果 $z \\ge \\tau_z = 3.0$：该模式与边界显著耦合。我们将其分类为 **“边界驱动的极性”** （代码 $2$）。\n- 如果 $z  \\tau_z = 3.0$：模式存在（$I \\ge \\tau_I$）但与边界没有显著耦合。我们将其分类为 **“自发对称性破缺”** （代码 $1$）。\n\n这个完整的算法将被应用于四个测试案例中的每一个，以生成最终输出。", "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import convolve\n\ndef solve():\n    \"\"\"\n    Main function to run the classification on the four test cases.\n    \"\"\"\n    \n    # Define parameters from the problem statement\n    params = {\n        'N': 64,          # Grid size\n        'R': 28,          # Mask radius\n        'S': 64,          # Number of surrogates\n        'tau_I': 0.02,    # Moran's I threshold\n        'tau_z': 3.0,     # Z-score threshold\n        'epsilon': 1e-9   # Epsilon for z-score calculation\n    }\n\n    test_cases = [\n        {'case_id': 1, 'type': 'boundary-driven_center-high', 'sigma': 0.05, 'seed': 1},\n        {'case_id': 2, 'type': 'spontaneous_dipole', 'sigma': 0.05, 'seed': 2},\n        {'case_id': 3, 'type': 'no_pattern_noise', 'sigma': 1.0, 'seed': 3},\n        {'case_id': 4, 'type': 'boundary-driven_periphery-high', 'sigma': 0.05, 'seed': 4},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Generate the specific data field for the current test case\n        X, M, d_b_norm = generate_test_case(case, params)\n        \n        # Classify the pattern\n        classification = classify_pattern(X, M, d_b_norm, params)\n        results.append(classification)\n\n    # Print results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef generate_test_case(case_info, params):\n    \"\"\"\n    Generates the scalar field X, mask M, and boundary distance field d_b_norm for a given test case.\n    \"\"\"\n    N = params['N']\n    R = params['R']\n    cx, cy = N / 2, N / 2\n    \n    np.random.seed(case_info['seed'])\n\n    # Create grid and mask\n    x = np.arange(N)\n    y = np.arange(N)\n    xx, yy = np.meshgrid(x, y)\n    dist_from_center = np.sqrt((xx - cx)**2 + (yy - cy)**2)\n    M = dist_from_center  R\n    \n    # Create normalized boundary distance field\n    d_b = R - dist_from_center\n    d_b_norm = np.zeros_like(d_b)\n    d_b_norm[M] = d_b[M] / R\n\n    # Generate the base field based on the case type\n    base_field = np.zeros((N, N))\n    if case_info['type'] == 'boundary-driven_center-high':\n        base_field = d_b_norm\n    elif case_info['type'] == 'spontaneous_dipole':\n        theta = np.deg2rad(37)\n        u = np.array([np.cos(theta), np.sin(theta)])\n        base_field = ((xx - cx) * u[0] + (yy - cy) * u[1]) / R\n    elif case_info['type'] == 'no_pattern_noise':\n        pass # Base field remains zero\n    elif case_info['type'] == 'boundary-driven_periphery-high':\n        base_field = 1.0 - d_b_norm\n        \n    # Add noise and apply mask\n    noise = np.random.normal(0, case_info['sigma'], (N, N))\n    X = base_field + noise\n    X[~M] = 0.0\n    \n    return X, M, d_b_norm\n\ndef calculate_morans_i(X, M):\n    \"\"\"\n    Calculates Moran's I for a given field X on a mask M.\n    \"\"\"\n    num_pixels_in_mask = np.sum(M)\n    if num_pixels_in_mask = 1:\n        return 0.0\n\n    X_masked_vals = X[M]\n    mean_X = np.mean(X_masked_vals)\n    \n    # Create mean-centered field\n    X_centered = np.zeros_like(X)\n    X_centered[M] = X_masked_vals - mean_X\n\n    # Define 4-neighbor kernel\n    kernel = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\n    \n    # Calculate sum of weights S0\n    W_matrix_image = convolve(M.astype(float), kernel, mode='constant', cval=0.0) * M\n    S0 = np.sum(W_matrix_image)\n    if S0 == 0:\n        return 0.0\n\n    # Numerator term calculation using convolution\n    convolved_X_centered = convolve(X_centered, kernel, mode='constant', cval=0.0)\n    numerator = np.sum(X_centered * convolved_X_centered)\n    \n    # Denominator term\n    denominator = np.sum(X_centered**2)\n    if denominator == 0:\n        return 0.0\n\n    I = (num_pixels_in_mask / S0) * (numerator / denominator)\n    return I\n\ndef calculate_boundary_coupling(X, d_b_norm, M):\n    \"\"\"\n    Calculates the absolute Pearson correlation between X and the boundary distance field.\n    \"\"\"\n    X_vec = X[M]\n    d_vec = d_b_norm[M]\n    \n    if len(X_vec)  2:\n        return 0.0\n        \n    # np.corrcoef returns a matrix, we need the off-diagonal element\n    corr_matrix = np.corrcoef(X_vec, d_vec)\n    rho = corr_matrix[0, 1]\n    \n    return np.abs(rho)\n\ndef generate_surrogates(X, M, S):\n    \"\"\"\n    Generates phase-randomized surrogate fields.\n    \"\"\"\n    N, _ = X.shape\n    \n    # Compute FFT of the real-valued input field\n    F = np.fft.rfft2(X)\n    amplitudes = np.abs(F)\n\n    surrogates = []\n    for _ in range(S):\n        # Generate random phases\n        random_phases = np.random.uniform(0, 2 * np.pi, size=F.shape)\n        \n        # Create surrogate Fourier spectrum\n        F_surr = amplitudes * np.exp(1j * random_phases)\n        \n        # Enforce reality condition for real-valued output.\n        # This is handled by irfft2 if rfft2 was used, but we must\n        # ensure Nyquist/DC components are handled correctly if we manipulate them.\n        # For simplicity, we trust irfft2 to handle symmetry.\n        # The main idea is randomizing phase angles that have a symmetric counterpart.\n        \n        # Inverse FFT to get real-valued surrogate field\n        surrogate = np.fft.irfft2(F_surr, s=(N, N))\n        \n        # Apply mask\n        surrogate[~M] = 0.0\n        surrogates.append(surrogate)\n        \n    return surrogates\n\ndef classify_pattern(X, M, d_b_norm, params):\n    \"\"\"\n    Implements the full decision rule to classify the pattern.\n    \"\"\"\n    # Unpack parameters\n    tau_I = params['tau_I']\n    tau_z = params['tau_z']\n    S = params['S']\n    epsilon = params['epsilon']\n\n    # Step 1: Check for presence of a pattern using Moran's I\n    I = calculate_morans_i(X, M)\n    if I  tau_I:\n        return 0  # No pattern\n\n    # Step 2: Calculate observed boundary coupling\n    rho_obs = calculate_boundary_coupling(X, d_b_norm, M)\n    \n    # Step 3: Generate surrogates and their boundary couplings for the null model\n    surrogate_fields = generate_surrogates(X, M, S)\n    rho_surrogates = [calculate_boundary_coupling(s, d_b_norm, M) for s in surrogate_fields]\n\n    # Step 4: Calculate z-score\n    mu_null = np.mean(rho_surrogates)\n    sigma_null = np.std(rho_surrogates)\n    \n    z_score = (rho_obs - mu_null) / (sigma_null + epsilon)\n    \n    # Step 5: Apply decision rule based on z-score\n    if z_score >= tau_z:\n        return 2  # Boundary-driven polarity\n    else:\n        return 1  # Spontaneous symmetry breaking\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2780370"}]}