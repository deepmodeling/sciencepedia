{"hands_on_practices": [{"introduction": "许多工程化的生物功能依赖于群体合作，例如分泌“公共物品”来改善环境。然而，这种系统常常受到不产生但仍受益的“欺骗者”突变体的威胁。本练习将引导你通过一个数学模型，量化分析微生物菌落的物理尺寸如何影响欺骗者战胜生产者的动态过程，从而深入理解空间结构在合作演化中的关键作用 [@problem_id:2738997]。", "problem": "考虑一个由工程生产者细胞和不产生可扩散公共物品分子的欺骗者细胞散布组成的克隆微菌落。该微菌落近似为一个半径为 $R$（单位：$\\mu\\mathrm{m}$）、面细胞密度均匀为 $\\rho$（单位：cells $\\mu\\mathrm{m}^{-2}$）的圆盘。每个生产者以速率 $q$（单位：molecule-units $\\mathrm{h}^{-1}$）释放分子。分子经历三种相互竞争的一阶风险：(i) 由释放分子自身的生产者以速率 $k_s$（单位：$\\mathrm{h}^{-1}$）进行的自身吸收，(ii) 由邻近的其他细胞以每个邻近细胞 $k_u$（单位：$\\mathrm{h}^{-1}$ per neighboring cell）的速率进行的吸收，以及 (iii) 以依赖于菌落大小的速率 $k_e(R)$（单位：$\\mathrm{h}^{-1}$）从菌落中扩散逃逸。由于扩散和衰变，相互作用范围是有限的，并由一个有效扩散长度 $L$（单位：$\\mu\\mathrm{m}$）来概括，超出此长度的吸收可以忽略不计。逃逸速率与菌落的表面积与体积之比成比例，即 $k_e(R) = k_{e0}\\, (L/R)$，其中 $k_{e0}$（单位：$\\mathrm{h}^{-1}$）是一个常数前置因子。相互作用范围内的有效邻居数量由下式给出：\n$$\nN(R) = \\max\\!\\left(0,\\, \\rho\\, \\pi\\, \\min(R^2, L^2) - 1\\right).\n$$\n在这些假设下，一个生产者释放的分子所面临的总竞争风险率为\n$$\nH(R) = k_s + k_u\\, N(R) + k_{e0}\\, \\frac{L}{R}.\n$$\n对于一个给定的已释放分子，被发射者捕获的概率是 $k_s/H(R)$，而被任何其他特定细胞捕获的概率是 $k_u/H(R)$（根据每个細胞吸收风险的对称性）。设从捕获的分子单位到每个细胞马尔萨斯增长率增量的转换为 $\\alpha$（单位：$\\mathrm{h}^{-1}$ per molecule-unit $\\mathrm{h}^{-1}$）。生产者支付一个恒定的生产成本 $c$（单位：$\\mathrm{h}^{-1}$）。设生产者和欺骗者的单位细胞马尔萨斯增长率分别为 $w_P$ 和 $w_C$。假设菌落内随机混合，且吸收风险是无记忆和可加的，则增长率的差异简化为\n$$\nw_C - w_P \\equiv \\Delta w(R) = c - \\alpha q\\, \\frac{k_s - k_u}{H(R)}.\n$$\n设 $x(t)$ 是时间 $t$（单位：$\\mathrm{h}$）时生产者的比例，其演化遵循由适应度差异驱动的频率动态学，根据常微分方程（ODE）$dx/dt = x(1 - x)(w_P - w_C) = -x(1 - x)\\, \\Delta w(R)$。定义初始生产者比例 $x_0 \\in (0,1)$ 和一个生产者阈值 $x_f \\in (0,1)$，该阈值编码了目标欺骗者比例为 $1 - x_f$ 时的欺骗者取代。欺骗者取代所需的时间 $T(R)$（单位：$\\mathrm{h}$）则为\n$$\nT(R) =\n\\begin{cases}\n+\\infty, & \\text{如果 } \\Delta w(R) \\le 0,\\\\[6pt]\n\\displaystyle \\frac{1}{\\Delta w(R)} \\ln\\!\\left(\\frac{x_0 (1 - x_f)}{x_f (1 - x_0)}\\right), & \\text{如果 } \\Delta w(R) > 0.\n\\end{cases}\n$$\n\n仅使用上述定义和关系，实现一个程序，为以下参数集计算欺骗者取代时间 $T(R)$，这组参数对于细菌微菌落是科学上合理的：\n\n- $\\rho = 0.01$ (cells $\\mu\\mathrm{m}^{-2}$),\n- $L = 30$ ($\\mu\\mathrm{m}$),\n- $k_s = 0.5$ ($\\mathrm{h}^{-1}$),\n- $k_u = 0.05$ ($\\mathrm{h}^{-1}$ per cell),\n- $k_{e0} = 0.02$ ($\\mathrm{h}^{-1}$),\n- $q = 100$ (molecule-units $\\mathrm{h}^{-1}$),\n- $\\alpha = 0.001$ ($\\mathrm{h}^{-1}$ per molecule-unit $\\mathrm{h}^{-1}$),\n- $c = 0.03$ ($\\mathrm{h}^{-1}$),\n- $x_0 = 0.99$,\n- $x_f = 0.1$.\n\n您的程序必须评估以下微菌落半径的测试套件\n$$\nR \\in \\{\\, 8,\\, 20,\\, 26,\\, 30,\\, 100 \\,\\}\\ \\text{in}\\ \\mu\\mathrm{m}.\n$$\n对于每个测试用例，计算 $T(R)$（单位：小时），有限值四舍五入到三位小数。如果 $\\Delta w(R) \\le 0$，则输出 $+\\infty$。最终输出格式必须是单行，包含一个 Python 风格的列表，其中包含五个结果，顺序与测试套件相同，例如 $[t_1,t_2,t_3,t_4,t_5]$，其中每个 $t_i$ 是一个浮点数或表示为 IEEE 浮点数无穷大的 $+\\infty$。不应打印其他任何文本。", "solution": "问题陈述已经过验证，被认为是有科学依据的、适定的且自洽的。它提出了一个来自理论生物学的标准（尽管简化了）数学模型，涉及合作与欺骗的进化动力学。所有参数、变量和函数关系都已明确定义，允许进行直接而明確的计算。我们将继续进行求解。\n\n目标是为一组微菌落半径 $R$ 计算欺骗者取代时间 $T(R)$。计算遵循问题陈述中提供的定义所导出的一系列步骤。\n\n首先，我们必须确定半径为 $R$ 的菌落内一个细胞的有效邻居数量 $N(R)$。这由以下公式给出：\n$$\nN(R) = \\max\\!\\left(0,\\, \\rho\\, \\pi\\, \\min(R^2, L^2) - 1\\right)\n$$\n这里，$\\rho$ 是面细胞密度，$L$ 是有效扩散长度。该函数考虑了相互作用的几何形状，该几何形状受菌落大小（对于 $R \\le L$）或扩散长度（对于 $R > L$）的限制。术语 “-1” 减去了生产者细胞自身。\n\n其次，我们计算由生产者释放的分子所面临的总竞争风险率 $H(R)$。该速率是三个相互排斥事件速率的总和：自身吸收、邻居吸收和扩散逃逸。公式为：\n$$\nH(R) = k_s + k_u\\, N(R) + k_{e0}\\, \\frac{L}{R}\n$$\n其中 $k_s$ 是自身吸收速率，$k_u$ 是邻居的单位细胞吸收速率，$k_e(R) = k_{e0} (L/R)$ 是依赖于大小的逃逸速率。\n\n第三，我们计算欺骗者和生产者之间的马尔萨斯增长率差异 $\\Delta w(R)$。这个量决定了选择的方向和速度。其定义为：\n$$\n\\Delta w(R) = c - \\alpha q\\, \\frac{k_s - k_u}{H(R)}\n$$\n在此表达式中，$c$ 是固定的生产成本。第二项代表了生产者的净私有收益，按生产速率 $q$ 和转换因子 $\\alpha$ 进行缩放。项 $k_s - k_u$ 反映了利己的捕获风险 $k_s$ 与社会可用的捕获风险 $k_u$ 之间的差异。如果 $\\Delta w(R) > 0$，欺骗者具有更高的增长率，其频率将会增加。如果 $\\Delta w(R) \\le 0$，生产者在进化上对欺骗者是稳定的或中性的。\n\n最后，我们计算欺骗者取代时间 $T(R)$。该动力学遵循标准的复制子方程，从初始生产者比例 $x_0$ 过渡到最终比例 $x_f$ 所需的时间由下式给出：\n$$\nT(R) =\n\\begin{cases}\n+\\infty, & \\text{if } \\Delta w(R) \\le 0, \\\\\n\\displaystyle \\frac{1}{\\Delta w(R)} \\ln\\!\\left(\\frac{x_0 (1 - x_f)}{x_f (1 - x_0)}\\right), & \\text{if } \\Delta w(R) > 0.\n\\end{cases}\n$$\n对于固定的 $x_0$ 和 $x_f$，对数项是一个常数。如果选择有利于生产者（$\\Delta w(R) \\le 0$）或是中性的（$\\Delta w(R) = 0$），欺骗者的比例不会增长至固定，取代时间定义为无穷大。\n\n该实现将使用以下指定的参数值：\n-   $\\rho = 0.01 \\text{ cells}\\,\\mu\\mathrm{m}^{-2}$\n-   $L = 30 \\,\\mu\\mathrm{m}$\n-   $k_s = 0.5 \\,\\mathrm{h}^{-1}$\n-   $k_u = 0.05 \\,\\mathrm{h}^{-1}$ per cell\n-   $k_{e0} = 0.02 \\,\\mathrm{h}^{-1}$\n-   $q = 100$ molecule-units $\\mathrm{h}^{-1}$\n-   $\\alpha = 0.001 \\,\\mathrm{h}^{-1}$ per molecule-unit $\\mathrm{h}^{-1}$\n-   $c = 0.03 \\,\\mathrm{h}^{-1}$\n-   $x_0 = 0.99$\n-   $x_f = 0.1$\n\n程序将遍历测试套件中的半径 $R \\in \\{8, 20, 26, 30, 100\\}$ $\\mu$m。对于每个 $R$ 值，它将执行上述四个步骤。如果 $T(R)$ 的结果是有限的，它将被四舍五入到三位小数。如果是无穷大，它将由 IEEE 754 无穷大标准表示。最终输出是这些结果的有序列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Computes the cheater takeover time T(R) for a range of microcolony radii.\n    \"\"\"\n    \n    # Define the parameters from the problem statement.\n    params = {\n        'rho': 0.01,    # cells µm⁻²\n        'L': 30.0,      # µm\n        'k_s': 0.5,     # h⁻¹\n        'k_u': 0.05,    # h⁻¹ per cell\n        'k_e0': 0.02,   # h⁻¹\n        'q': 100.0,     # molecule-units h⁻¹\n        'alpha': 0.001, # h⁻¹ per molecule-unit h⁻¹\n        'c': 0.03,      # h⁻¹\n        'x_0': 0.99,    # initial producer fraction\n        'x_f': 0.1,     # final producer fraction\n    }\n\n    # Define the test suite of microcolony radii.\n    radii = [8.0, 20.0, 26.0, 30.0, 100.0]  # in µm\n\n    results = []\n\n    # Pre-calculate the constant logarithmic term for T(R).\n    # This term is derived from the solution to the replicator ODE.\n    log_term = math.log(\n        (params['x_0'] * (1 - params['x_f'])) / \n        (params['x_f'] * (1 - params['x_0']))\n    )\n\n    for R in radii:\n        # Step 1: Calculate the effective number of neighbors, N(R).\n        # The interaction area is the minimum of the colony area and diffusion area.\n        min_R_L_sq = min(R**2, params['L']**2)\n        N_R = max(0.0, params['rho'] * math.pi * min_R_L_sq - 1.0)\n\n        # Step 2: Calculate the total competing hazard rate, H(R).\n        # This is the sum of self-uptake, neighbor uptake, and escape hazards.\n        # A check for R=0 is good practice, although not required by the test cases.\n        if R == 0:\n            # The escape rate would be infinite, making H(R) infinite.\n            # This implies any secreted molecule is instantly lost.\n            H_R = float('inf')\n        else:\n            H_R = params['k_s'] + params['k_u'] * N_R + params['k_e0'] * params['L'] / R\n        \n        # Step 3: Calculate the fitness difference between cheaters and producers, Δw(R).\n        # This determines the direction of selection.\n        if H_R == 0:\n             # Avoid division by zero; physically H(R) is always positive.\n             # This case implies Δw -> -inf, so producers are strongly favored.\n             delta_w_R = -float('inf')\n        else:\n            net_private_benefit = (params['alpha'] * params['q'] * \n                                  (params['k_s'] - params['k_u'])) / H_R\n            delta_w_R = params['c'] - net_private_benefit\n\n        # Step 4: Calculate the cheater takeover time, T(R).\n        if delta_w_R = 0:\n            # If cheaters are not favored, takeover time is infinite.\n            T_R = float('inf')\n        else:\n            # If cheaters are favored, calculate the finite takeover time.\n            T_R = (1 / delta_w_R) * log_term\n            # Round to three decimal places as required.\n            T_R = round(T_R, 3)\n\n        results.append(T_R)\n    \n    # Final print statement in the exact required format.\n    # The string representation of float('inf') is 'inf'.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2738997"}, {"introduction": "工程功能的演化命运并非只有“保留”或“丢失”两种。一个更复杂且现实的情况是，宿主细胞可能“挪用”或“重新利用”工程模块以获得自身生存优势。本练习将运用经典的群体遗传学模型，探讨当这种“挪用者”亚群出现时，种群的长期演化平衡会发生怎样的变化，这对于预测和设计长期稳定的合成系统至关重要 [@problem_id:2739051]。", "problem": "考虑一个无性的、均匀混合的微生物种群，其中一种工程功能可以按设计维持、丢失，或被宿主为自身利益而重新利用。存在恰好$3$种可遗传的基因型：工程功能生产者$P$、已丢失该功能的工程功能欺骗者$C$，以及保留了工程功能但通过突变重构调控以提供宿主自身效益的再利用者$R$。种群足够大，可以忽略随机漂变，且世代重叠。假设在无限种群、连续时间选择—突变极限下，繁殖遵循质量作用定律。\n\n每种基因型 $i \\in \\{P,C,R\\}$ 具有恒定的马尔萨斯适应度 $w_i$，该适应度取决于产生工程功能的代价，以及对于再利用者而言，还取决于宿主获得的自身效益：\n- $w_P = 1 - c$\n- $w_C = 1$\n- $w_R = 1 - c_r + b$\n\n其中 $c \\in (0,1)$ 和 $c_r \\in (0,1)$ 分别是 $P$ 和 $R$ 支付的代价，$b \\ge 0$ 是仅由 $R$ 实现的宿主自身效益。\n\n突变在繁殖时发生。设 $Q$ 是一个 $3 \\times 3$ 的行随机突变矩阵，其元素 $Q_{j i}$ 等于 $j$ 型亲代的后代为 $i$ 型的概率。非对角线元素由小的正向或反向突变率给出，对角线元素则设定为确保每行总和为 $1$。\n\n对于下方的每个测试案例，您必须计算在此设定下标准选择—突变动态的全局吸引不动点处的渐近基因型组成。根据该组成，计算携带功能基因型的平衡分数，\n$$\nF^\\star = x_P^\\star + x_R^\\star,\n$$\n其中 $x_P^\\star$ 和 $x_R^\\star$ 分别是 $P$ 和 $R$ 的平衡频率。报告 $F^\\star$ 的值，该值需四舍五入到恰好 $6$ 位小数，并以 $[0,1]$ 区间内的实数形式表示。\n\n测试套件参数化。对于每个案例，给定 $(c, c_r, b)$ 和非对角突变率 $(u_{P\\to C}, u_{P\\to R}, u_{C\\to P}, u_{C\\to R}, u_{R\\to P}, u_{R\\to C})$。通过将这些突变率放置在相应的非对角位置并设定每个对角线元素 $Q_{j j} = 1 - \\sum_{i \\ne j} Q_{j i}$ 来构建 $Q$。使用以下 $5$ 个案例：\n\n- 案例 $1$ (无再利用效益):\n  - $(c, c_r, b) = (0.05, 0.05, 0.0)$\n  - $(u_{P\\to C}, u_{P\\to R}, u_{C\\to P}, u_{C\\to R}, u_{R\\to P}, u_{R\\to C}) = (0.0001, 0.00001, 0.000001, 0.000001, 0.00001, 0.0001)$\n\n- 案例 $2$ (再利用具有强效益):\n  - $(c, c_r, b) = (0.05, 0.05, 0.08)$\n  - $(u_{P\\to C}, u_{P\\to R}, u_{C\\to P}, u_{C\\to R}, u_{R\\to P}, u_{R\\to C}) = (0.0001, 0.00001, 0.000001, 0.000001, 0.00001, 0.0001)$\n\n- 案例 $3$ (再利用效益边际，相对于 $C$ 净中性):\n  - $(c, c_r, b) = (0.05, 0.05, 0.05)$\n  - $(u_{P\\to C}, u_{P\\to R}, u_{C\\to P}, u_{C\\to R}, u_{R\\to P}, u_{R\\to C}) = (0.0001, 0.00001, 0.000001, 0.000001, 0.00001, 0.0001)$\n\n- 案例 $4$ (再利用效益不足以弥补更高的代价):\n  - $(c, c_r, b) = (0.10, 0.08, 0.05)$\n  - $(u_{P\\to C}, u_{P\\to R}, u_{C\\to P}, u_{C\\to R}, u_{R\\to P}, u_{R\\to C}) = (0.0001, 0.00001, 0.000001, 0.000001, 0.00001, 0.0001)$\n\n- 案例 $5$ (再利用有益但向功能丢失方向的突变压力高):\n  - $(c, c_r, b) = (0.05, 0.05, 0.08)$\n  - $(u_{P\\to C}, u_{P\\to R}, u_{C\\to P}, u_{C\\to R}, u_{R\\to P}, u_{R\\to C}) = (0.0001, 0.00001, 0.000001, 0.000001, 0.00001, 0.01)$\n\n您的程序必须生成单行输出，其中包含 $5$ 个结果，以逗号分隔列表的形式并用方括号括起来，顺序与上述案例相同，例如，$[0.123456,0.234567,0.345678,0.456789,0.567890]$。输出中的所有数字必须四舍五入到恰好 $6$ 位小数，并且必须是 $[0,1]$ 区间内的小数（不含百分号）。", "solution": "问题陈述已通过验证。\n\n**第1步：提取给定条件**\n\n该问题定义了一个包含三种基因型的系统：生产者（$P$）、欺骗者（$C$）和再利用者（$R$）。它们的动态由一个均匀混合、无性繁殖、无限大的种群中的连续时间选择-突变模型决定。\n\n对于 $i \\in \\{P, C, R\\}$，马尔萨斯适应度 $w_i$ 由下式给出：\n- $w_P = 1 - c$\n- $w_C = 1$\n- $w_R = 1 - c_r + b$\n\n其中 $c \\in (0,1)$，$c_r \\in (0,1)$，且 $b \\ge 0$。\n\n突变由一个 $3 \\times 3$ 的行随机矩阵 $Q$ 描述，其中 $Q_{ji}$ 是 $j$ 型亲代产生 $i$ 型后代的概率。对于 $i \\ne j$，非对角线元素 $Q_{ji}$ 由突变率 $u_{j \\to i}$ 给出。对角线元素为 $Q_{jj} = 1 - \\sum_{i \\ne j} Q_{ji}$。\n\n目标是计算携带功能基因型的平衡分数 $F^\\star = x_P^\\star + x_R^\\star$，其中 $x_P^\\star$ 和 $x_R^\\star$ 是基因型 $P$ 和 $R$ 的平衡频率。\n\n提供了五个测试案例，每个案例都给定了 $(c, c_r, b)$ 和六个非对角突变率 $(u_{P\\to C}, u_{P\\to R}, u_{C\\to P}, u_{C\\to R}, u_{R\\to P}, u_{R\\to C})$ 的具体值。\n\n**第2步：使用提取的给定条件进行验证**\n\n根据指定的验证标准对问题进行分析。\n\n- **科学上合理：** 该模型是标准复制子-突变子方程的一个实例，这是理论种群遗传学和进化动力学中一个基础且成熟的框架。它在科学上是合理的。\n- **良态（Well-Posed）：** 已知所描述的动态系统拥有一个唯一的、全局吸引的不动点（平衡点）。如解答中所述，这由应用于该动态系统矩阵的佩伦-弗罗贝尼乌斯定理保证。因此，该问题是良态的。\n- **客观性：** 问题使用精确的数学语言和客观参数来表述，不含任何主观或模糊的术语。\n\n该问题未表现出任何列出的缺陷（科学上不合理、非形式化、设定不完整、不切实际、病态、伪深奥或无法验证）。所有必要的参数都已提供，模型是标准的且可解的，并且要求的是一个具体的、可计算的量。\n\n**第3步：结论与行动**\n\n问题被判定为**有效**。将提供完整解答。\n\n**解答推导**\n\n令三种基因型的频率由向量 $\\mathbf{x} = [x_P, x_C, x_R]^T$ 表示。连续时间选择-突变动态由以下常微分方程组描述：\n$$\n\\frac{dx_i}{dt} = \\sum_{j \\in \\{P,C,R\\}} x_j w_j Q_{ji} - \\bar{w} x_i\n$$\n其中 $\\bar{w} = \\sum_{k \\in \\{P,C,R\\}} x_k w_k$ 是种群的平均适应度。\n\n在平衡状态下，频率是恒定的，因此对所有 $i$ 都有 $\\frac{dx_i}{dt} = 0$。这导出了方程组：\n$$\n\\bar{w} x_i^\\star = \\sum_{j \\in \\{P,C,R\\}} x_j^\\star w_j Q_{ji}\n$$\n其中 $\\mathbf{x}^\\star = [x_P^\\star, x_C^\\star, x_R^\\star]^T$ 是平衡频率向量。\n\n为将其表示为矩阵形式，设 $W$ 为适应度的对角矩阵：\n$$\nW = \\begin{pmatrix} w_P  0  0 \\\\ 0  w_C  0 \\\\ 0  0  w_R \\end{pmatrix}\n$$\n平衡方程可以写成：\n$$\n\\bar{w} \\mathbf{x}^\\star = (Q^T W) \\mathbf{x}^\\star\n$$\n这是一个右特征向量方程。平衡频率向量 $\\mathbf{x}^\\star$ 是矩阵 $M = Q^T W$ 的右特征向量，平衡时的平均适应度 $\\bar{w}$ 是相应的特征值。\n\n矩阵 $M$ 构建如下：\n$$\nM = Q^T W = \n\\begin{pmatrix}\nQ_{PP}  Q_{CP}  Q_{RP} \\\\\nQ_{PC}  Q_{CC}  Q_{RC} \\\\\nQ_{PR}  Q_{CR}  Q_{RR}\n\\end{pmatrix}\n\\begin{pmatrix}\nw_P  0  0 \\\\\n0  w_C  0 \\\\\n0  0  w_R\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nQ_{PP}w_P  Q_{CP}w_C  Q_{RP}w_R \\\\\nQ_{PC}w_P  Q_{CC}w_C  Q_{RC}w_R \\\\\nQ_{PR}w_P  Q_{CR}w_C  Q_{RR}w_R\n\\end{pmatrix}\n$$\n\n由于所有适应度 $w_i  0$ 且所有突变率 $u_{j \\to i}  0$，突变矩阵 $Q$ 的所有元素都是严格为正的。因此，矩阵 $M$ 的所有元素也都是严格为正的。根据正矩阵的佩伦-弗罗贝尼乌斯定理，$M$ 有一个唯一的最大实特征值，它是单重的且为正。这就是佩伦-弗罗贝尼乌斯特征值 $\\lambda_{PF}$。对应的特征向量在缩放意义下是唯一的，并且可以选择使其所有分量都为正。\n\n该特征向量代表了种群的稳定基因型组成。计算步骤如下：\n1.  对于每个测试案例，构建适应度向量 $\\mathbf{w} = [w_P, w_C, w_R]^T$ 和突变矩阵 $Q$。\n2.  构建矩阵 $M = Q^T \\text{diag}(\\mathbf{w})$。\n3.  计算 $M$ 的特征值和右特征向量。\n4.  找到与佩伦-弗罗贝尼乌斯（最大实数）特征值对应的特征向量。\n5.  通过将该特征向量的每个分量除以它们的总和来进行归一化，得到平衡频率向量 $\\mathbf{x}^\\star$。\n6.  计算最终量 $F^\\star = x_P^\\star + x_R^\\star$。\n7.  报告四舍五入到 $6$ 位小数的 $F^\\star$。\n\n此过程将针对所提供的五个测试案例中的每一个进行实施。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the equilibrium fraction of function-bearing genotypes\n    for a series of test cases based on a replicator-mutator model.\n    \"\"\"\n\n    # Define the 5 test cases from the problem statement.\n    # Each case is a tuple: ((c, c_r, b), (mutation_rates))\n    # mutation_rates = (u_PC, u_PR, u_CP, u_CR, u_RP, u_RC)\n    test_cases = [\n        # Case 1 (no repurposing benefit)\n        ((0.05, 0.05, 0.0), (0.0001, 0.00001, 0.000001, 0.000001, 0.00001, 0.0001)),\n        # Case 2 (repurposing strongly beneficial)\n        ((0.05, 0.05, 0.08), (0.0001, 0.00001, 0.000001, 0.000001, 0.00001, 0.0001)),\n        # Case 3 (repurposing marginally beneficial, net neutral relative to C)\n        ((0.05, 0.05, 0.05), (0.0001, 0.00001, 0.000001, 0.000001, 0.00001, 0.0001)),\n        # Case 4 (repurposing not beneficial enough given higher cost)\n        ((0.10, 0.08, 0.05), (0.0001, 0.00001, 0.000001, 0.000001, 0.00001, 0.0001)),\n        # Case 5 (repurposing beneficial but mutation pressure toward loss is high)\n        ((0.05, 0.05, 0.08), (0.0001, 0.00001, 0.000001, 0.000001, 0.00001, 0.01)),\n    ]\n\n    results = []\n    for params in test_cases:\n        fitness_params, mutation_rates = params\n        c, c_r, b = fitness_params\n        \n        # Calculate Malthusian fitnesses for P, C, R\n        w = np.array([1 - c, 1.0, 1 - c_r + b])\n\n        # Unpack mutation rates\n        u_PC, u_PR, u_CP, u_CR, u_RP, u_RC = mutation_rates\n        \n        # Construct the 3x3 row-stochastic mutation matrix Q\n        # Q[j, i] is the probability of parent j producing offspring i\n        Q = np.array([\n            [1 - u_PC - u_PR, u_PC, u_PR],  # Parent P (j=0) to P, C, R (i=0,1,2)\n            [u_CP, 1 - u_CP - u_CR, u_CR],  # Parent C (j=1) to P, C, R (i=0,1,2)\n            [u_RP, u_RC, 1 - u_RP - u_RC]   # Parent R (j=2) to P, C, R (i=0,1,2)\n        ])\n        \n        # Construct the governing matrix M = Q^T W\n        W = np.diag(w)\n        M = Q.T @ W\n        \n        # Find the eigenvalues and right eigenvectors of M\n        eigenvalues, eigenvectors = np.linalg.eig(M)\n        \n        # The Perron-Frobenius eigenvalue is the largest real eigenvalue.\n        # Its corresponding eigenvector gives the stable state.\n        pf_index = np.argmax(eigenvalues.real)\n        pf_eigenvector = eigenvectors[:, pf_index].real\n        \n        # Normalize the eigenvector to get frequencies (sum to 1).\n        # The vector can have an arbitrary sign, so we use its absolute value.\n        x_star = np.abs(pf_eigenvector) / np.sum(np.abs(pf_eigenvector))\n        \n        x_P_star, x_C_star, x_R_star = x_star\n        \n        # Calculate the total fraction of function-bearing genotypes\n        F_star = x_P_star + x_R_star\n        \n        # Round to exactly 6 decimal places and store\n        results.append(f\"{F_star:.6f}\")\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2739051"}, {"introduction": "任何工程功能的演化稳定性最终都取决于其潜在的突变路径，这些路径共同构成了所谓的“适应度景观”。本练习将使用经典的 N–K 模型来构建和分析这种景观，通过计算保留功能的、符合选择压力的突变路径数量，你将亲身体验基因间的相互作用（即上位性）如何塑造景观的崎岖度，并最终决定工程功能的演化可及性与稳定性 [@problem_id:2738940]。", "problem": "要求您在一个随机化的 N–K 适应度景观上，形式化并计算在选择作用下保留工程化功能活性的突变路径的可及性，其中 $N$ 是基因座的数量，$K$ 是每个基因座的上位相互作用伙伴的数量。目标是将景观的崎岖性（随 $K$ 增加）与从一个指定的工程化起始基因型到全局适应度最大值的、保留活性且符合选择的突变路径数量联系起来。\n\n基本基础：\n- N–K 适应度景观模型为每个基因型赋予一个适应度，该适应度计算为 $N$ 个局部贡献的平均值，其中每个基因座 $i$ 的贡献值取决于基因座 $i$ 的状态和 $K$ 个上位相互作用伙伴基因座的状态。每个基因座都有一个独立的查找表，将其 $(K+1)$-位的局部配置映射到闭区间 $[0,1]$ 内的一个贡献值。对于一个基因型 $g \\in \\{0,1\\}^N$，其适应度 $W(g)$ 是这 $N$ 个贡献的算术平均值。\n- 在达尔文选择下，可及的突变步骤是那些不降低所选性状的步骤。在此，为将选择与工程化功能直接联系起来，假设工程化功能的活性与适应度 $W(g)$ 成正比，并且生存需要一个最低活性水平 $A$（生存阈值），因此只有满足 $W(g) \\ge A$ 的基因型被认为保留了功能。符合选择的路径要求在突变序列中 $W$ 值非递减。\n\n您必须精确实现的定义：\n1. 景观构建。对于给定的 $N$ 和 $K$（其中 $0 \\le K \\le N-1$），对每个基因座 $i \\in \\{0,\\dots,N-1\\}$：\n   - 从 $\\{0,\\dots,N-1\\}\\setminus\\{i\\}$ 中无放回地均匀随机选择 $K$ 个不同的伙伴基因座。基因座 $i$ 的有序相互作用集定义为一个列表，其中 $i$ 在首位，其后是按严格升序排列的伙伴基因座。\n   - 从 $[0,1]$ 上的连续分布（使用 $[0,1]$ 上的均匀分布）中抽取独立实现值，生成一个大小为 $2^{K+1}$ 的表，该表将每个 $(K+1)$ 位的局部配置映射到 $[0,1]$ 内的一个贡献值。\n   - 对于一个基因型 $g$，基因座 $i$ 的表的索引是通过读取 $g$ 在基因座 $i$ 的有序相互作用集指定位置上的位，并将其解释为一个二进制数（列表中第一个基因座为最高有效位）来计算的。适应度为 $W(g)=\\frac{1}{N}\\sum_{i=0}^{N-1} c_i(g)$，其中 $c_i(g)$ 是基因型 $g$ 的局部配置在基因座 $i$ 的表中的查找值。\n\n2. 起始与目标基因型。设工程化起始基因型为 $g_0=(0,0,\\dots,0) \\in \\{0,1\\}^N$。设目标基因型 $g^\\star$ 是使字典序对 $(W(g), \\mathrm{index}(g))$ 最大化的唯一基因型，其中 $\\mathrm{index}(g)$ 是将 $g$ 解释为二进制数（第0位为最低有效位）所形成的整数。也就是说，$g^\\star$ 是具有最大适应度的基因型，若适应度相同，则选择二进制索引较大的那个。\n\n3. 活性保留选择下的突变路径与可及性。从 $g_0$到 $g^\\star$ 的突变路径是一个单基因座翻转序列，它通过以某种顺序将 $g_0$ 和 $g^\\star$ 之间存在差异的每个基因座翻转一次（无回复突变），从而将 $g_0$ 转换为 $g^\\star$。设 $D=\\{i \\in \\{0,\\dots,N-1\\} : g_0[i]\\ne g^\\star[i]\\}$ 且 $H=|D|$。因此，该路径恰好有 $H$ 步。\n   - 活性保留要求路径上的每个中间基因型 $g$ 都满足 $W(g)\\ge A$，其中 $A\\in(0,1)$ 是一个固定的生存阈值。\n   - 选择一致性要求路径上的适应度值序列在以下严格排序规则下非递减，以避免出现平局时的歧义：对于两个连续的基因型 $g \\to g'$，如果 $W(g')W(g)$ 或者 $W(g')=W(g)$ 且 $\\mathrm{index}(g')\\mathrm{index}(g)$，则该步骤是允许的。这在潜在的步骤上引入了一个无环方向，确保了允许路径的计数是明确定义的。\n\n4. 可及性度量。在选择下保留活性的突变路径的可及性定义为从 $g_0$ 到 $g^\\star$ 且同时满足上述活性保留和选择一致性条件的独特突变路径的数量。如果 $H=0$，当 $W(g_0)\\ge A$ 时数量为 $1$，否则为 $0$。\n\n您的任务：\n- 对于每个测试用例，使用指定的随机种子构建 N–K 景观，计算 $g^\\star$，然后计算如上定义的可及性计数。\n- 使用精确的整数计数作为输出。\n\n测试套件：\n为以下参数集提供结果，每个参数集格式为 $(N,K,\\text{seed},A)$：\n- 案例 1：$(6,0,7,0.5)$。\n- 案例 2：$(6,5,7,0.5)$。\n- 案例 3：$(8,0,123,0.5)$。\n- 案例 4：$(8,3,123,0.5)$。\n- 案例 5：$(8,7,123,0.5)$。\n- 案例 6（具有严格生存阈值的边缘案例）：$(7,6,99,0.9)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。第 $i$ 个条目必须是案例 $i$ 的可及性计数，按从案例1到案例6的顺序排列，例如 $[x_1,x_2,x_3,x_4,x_5,x_6]$，其中每个 $x_i$ 是一个整数。", "solution": "该问题被验证为具有科学依据、客观且计算上是可行的。它提出了计算进化生物学中一个明确定义的任务，具体而言是在崎岖的适应度景观上分析突变可及性。N–K 模型是此类研究的典型工具。问题陈述是自包含的，所有参数、条件和定义都得到了明确的指定。包含随机种子和精确的平局打破规则确保了解决方案的唯一性和可复现性。\n\n解决方案是通过一个系统的、基于原则的算法构建的，该算法包括四个主要阶段：\n1.  **景观生成**：根据指定的参数 $(N, K)$ 和给定的随机种子构建 N–K 适应度景观。\n2.  **适应度空间评估**：计算并存储空间 $\\{0,1\\}^N$ 中每个基因型的适应度。\n3.  **目标基因型识别**：识别全局最优基因型 $g^\\star$。\n4.  **路径枚举**：使用动态规划计算从起始基因型 $g_0$ 到 $g^\\star$ 的可及的、保留活性的突变路径数量。\n\n每个阶段详述如下。\n\n**1. 景观生成**\n对于给定的基因座数量 $N$ 和上位性水平 $K$，景观由每个基因座的适应度贡献定义。对于每个基因座 $i \\in \\{0, \\dots, N-1\\}$：\n-   从其他 $N-1$ 个基因座中均匀随机选择一组 $K$ 个独特的上位相互作用伙伴。基因座 $i$ 的有序相互作用集是一个列表，包含 $i$ 本身作为第一个元素（最高有效位），其后是按升序排列的 $K$ 个伙伴。\n-   生成一个大小为 $2^{K+1}$ 的贡献表（一个向量）。其条目是从 $[0,1]$ 上的均匀分布中抽取的独立随机变量。该表将相互作用集的 $2^{K+1}$ 种可能的局部遗传构型中的每一种映射到一个适应度贡献值。\n使用固定的伪随机数生成器种子确保了此构建过程是确定性和可复现的。\n\n**2. 适应度空间评估**\n基因型 $g \\in \\{0,1\\}^N$ 的适应度定义为所有 $N$ 个基因座贡献的算术平均值：\n$$W(g) = \\frac{1}{N} \\sum_{i=0}^{N-1} c_i(g)$$\n其中 $c_i(g)$ 是基因座 $i$ 的贡献。为找到 $c_i(g)$，从 $g$ 中提取基因座 $i$ 的相互作用集中各基因座的状态。这 $K+1$ 个位被解释为一个二进制整数，用作基因座 $i$ 的贡献表的索引。鉴于测试套件中 $N$ 的值较小（最大为8），预先计算所有 $2^N$ 个基因型的适应度值并将其存储在一个数组中是高效的，该数组通过基因型的整数表示进行索引。\n\n**3. 目标基因型识别**\n进化的目标是全局最优的基因型 $g^\\star$。根据问题描述，$g^\\star$ 是使字典序对 $(W(g), \\mathrm{index}(g))$ 最大化的唯一基因型。术语 $\\mathrm{index}(g)$ 表示二进制基因型字符串 $g$ 的整数值，其中位置0的位是最低有效位。此平局打破规则确保总能找到一个唯一的目标。通过扫描预先计算的适应度数组来识别这个 $g^\\star$。\n\n**4. 通过动态规划进行路径枚举**\n问题的核心是计算从起始基因型 $g_0 = (0, \\dots, 0)$ 到目标基因型 $g^\\star$ 的有效突变路径的数量。一条路径是一个单比特翻转序列，对于 $g_0$ 和 $g^\\star$ 之间存在差异的每个基因座，都进行一次翻转。设 $D$ 为 $g_0$ 和 $g^\\star$ 之间存在差异的基因座集合，$H = |D|$ 为汉明距离。我们正在计算这 $H$ 个突变的排列中，构成有效路径的数量。\n\n一条路径在每一步都必须满足两个标准才算有效：\n-   **活性保留**：对于路径上的每个中间基因型 $g_{path}$，其适应度必须大于或等于生存阈值，$W(g_{path}) \\ge A$。\n-   **选择一致性**：对于每一步 $g \\to g'$，适应度不得降低。为处理适应度平局，施加了严格的排序规则：如果 $W(g')  W(g)$，或者 $W(g') = W(g)$ 且 $\\mathrm{index}(g')  \\mathrm{index}(g)$，则该步骤是允许的。\n\n这个路径计数问题可以使用动态规划高效解决。设 $dp(g)$ 是从 $g_0$ 到由 $g_0$ 和 $g^\\star$ 张成的子超立方体上的任意基因型 $g$ 的有效路径数量。\n\n-   **基本情况**：过程从 $g_0$ 开始。如果 $W(g_0)  A$，则没有路径是可能的，计数为 $0$。否则，$dp(g_0) = 1$。对于所有其他基因型 $g$，$dp(g)$ 初始化为 $0$。\n\n-   **递推关系**：到达基因型 $g_{next}$ 的路径数是到达其所有有效直接前驱的路径数之和。动态规划通过按与 $g_0$ 的汉明距离递增的顺序遍历基因型来进行。对于距离为 $d$ 的基因型 $g_{curr}$，我们考虑所有距离为 $d+1$ 的潜在后继基因型 $g_{next}$（通过翻转 $g_{curr}$ 中属于集合 $D$ 的一个位形成）。如果步骤 $g_{curr} \\to g_{next}$ 是有效的（同时满足活性保留和选择一致性），我们更新 $g_{next}$ 的路径计数：\n    $$dp(g_{next}) \\mathrel{+}= dp(g_{curr})$$\n\n-   **最终结果**：在遍历了直到 $H-1$ 的所有汉明距离后，$dp(g^\\star)$ 的值将保存从 $g_0$ 到 $g^\\star$ 的有效突变路径总数。如果 $g_0 = g^\\star$（即 $H=0$），当 $W(g_0) \\ge A$ 时计数为 $1$，否则为 $0$。此逻辑被实现用于计算每个测试用例所需的可及性度量。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the mutational path accessibility problem for the given test suite.\n    \"\"\"\n\n    class AccessibilityCalculator:\n        \"\"\"\n        Encapsulates the logic for solving one instance of the N-K landscape problem.\n        \"\"\"\n        def __init__(self, N, K, seed, A):\n            self.N = N\n            self.K = K\n            self.A = A\n            self.rng = np.random.default_rng(seed)\n            self.interaction_sets = {}\n            self.contribution_tables = {}\n            self.fitness_vals = np.zeros(2**self.N)\n\n        def _generate_landscape(self):\n            \"\"\"Constructs the N-K landscape: interaction sets and contribution tables.\"\"\"\n            all_loci = np.arange(self.N)\n            for i in range(self.N):\n                if self.K > 0:\n                    other_loci = np.delete(all_loci, i)\n                    partners = self.rng.choice(other_loci, size=self.K, replace=False)\n                    partners.sort()\n                    self.interaction_sets[i] = [i] + list(partners)\n                else:\n                    self.interaction_sets[i] = [i]\n                \n                table_size = 2**(self.K + 1)\n                self.contribution_tables[i] = self.rng.uniform(0.0, 1.0, size=table_size)\n\n        def _compute_all_fitnesses(self):\n            \"\"\"Pre-computes and stores the fitness for all 2^N genotypes.\"\"\"\n            num_genotypes = 2**self.N\n            for g_idx in range(num_genotypes):\n                total_contribution = 0.0\n                for i in range(self.N):\n                    interaction_set = self.interaction_sets[i]\n                    \n                    table_idx = 0\n                    for locus_pos in interaction_set:\n                        bit = (g_idx >> locus_pos)  1\n                        table_idx = (table_idx  1) | bit\n                    \n                    total_contribution += self.contribution_tables[i][table_idx]\n                \n                self.fitness_vals[g_idx] = total_contribution / self.N\n            \n        def _find_target_genotype(self):\n            \"\"\"Finds the target genotype g_star by maximizing (W(g), index(g)).\"\"\"\n            best_fitness = -1.0\n            g_star_idx = -1\n            \n            num_genotypes = 2**self.N\n            for g_idx in range(num_genotypes):\n                fitness = self.fitness_vals[g_idx]\n                if fitness > best_fitness:\n                    best_fitness = fitness\n                    g_star_idx = g_idx\n                elif fitness == best_fitness:\n                    if g_idx > g_star_idx:\n                        g_star_idx = g_idx\n            return g_star_idx\n\n        def compute_accessibility(self):\n            \"\"\"Calculates the number of accessible, activity-preserving paths.\"\"\"\n            self._generate_landscape()\n            self._compute_all_fitnesses()\n            \n            g0_idx = 0\n            g_star_idx = self._find_target_genotype()\n            \n            diff_mask = g0_idx ^ g_star_idx \n            diff_indices = [i for i in range(self.N) if (diff_mask >> i)  1]\n            H = len(diff_indices)\n            \n            if H == 0:\n                return 1 if self.fitness_vals[g0_idx] >= self.A else 0\n                \n            if self.fitness_vals[g0_idx]  self.A:\n                return 0\n                \n            dp = np.zeros(2**self.N, dtype=np.int64)\n            dp[g0_idx] = 1\n            \n            genotypes_by_dist = [[] for _ in range(H + 1)]\n            for g_idx in range(2**self.N):\n                if (g_idx  ~diff_mask) == 0:\n                    dist = bin(g_idx).count('1')\n                    genotypes_by_dist[dist].append(g_idx)\n                    \n            for d in range(H):\n                for g_curr_idx in genotypes_by_dist[d]:\n                    if dp[g_curr_idx] == 0:\n                        continue\n                    \n                    f_curr = self.fitness_vals[g_curr_idx]\n                    \n                    for bit_to_flip in diff_indices:\n                        if not ((g_curr_idx >> bit_to_flip)  1):\n                            g_next_idx = g_curr_idx | (1  bit_to_flip)\n                            \n                            f_next = self.fitness_vals[g_next_idx]\n                            \n                            is_viable = (f_next >= self.A)\n                            is_selection_consistent = (f_next > f_curr) or \\\n                                                      (f_next == f_curr and g_next_idx > g_curr_idx)\n\n                            if is_viable and is_selection_consistent:\n                                dp[g_next_idx] += dp[g_curr_idx]\n\n            return dp[g_star_idx]\n\n    test_cases = [\n        (6, 0, 7, 0.5),\n        (6, 5, 7, 0.5),\n        (8, 0, 123, 0.5),\n        (8, 3, 123, 0.5),\n        (8, 7, 123, 0.5),\n        (7, 6, 99, 0.9),\n    ]\n\n    results = []\n    for params in test_cases:\n        N, K, seed, A = params\n        calculator = AccessibilityCalculator(N, K, seed, A)\n        result = calculator.compute_accessibility()\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2738940"}]}