{"hands_on_practices": [{"introduction": "Bienenstock-Cooper-Munro (BCM) 理论是理解神经元活动历史如何塑造突触强度的经典框架。本练习将运用 BCM 模型的“滑动阈值”概念，模拟一个感觉剥夺（暗饲养）的假想场景，以预测在恢复正常活动后突触的反应。这项实践有助于深入理解稳态可塑性的核心原理。[@problem_id:2757529]", "problem": "考虑一个位于初级视皮层的锥体神经元，其突触遵循 Bienenstock–Cooper–Munro (BCM) 理论精神的滑动阈值可塑性规则，其中突触修饰阈值 $\\theta_{M}(t)$ 会适应近期的突触后激活水平。设无量纲的突触后激活为 $y(t) \\ge 0$。假设以下基本要素成立。\n1. 滑动阈值遵循朝向近期均方激活的一阶松弛过程：\n$$\n\\frac{d \\theta_{M}}{dt} \\;=\\; \\frac{1}{\\tau_{\\theta}}\\Big(\\langle y^{2}\\rangle - \\theta_{M}\\Big),\n$$\n其中适应时间常数 $\\tau_{\\theta}$ 为固定值。\n2. 在持续条件下，稳态阈值等于均方激活：$\\theta_{M}^{\\ast}=\\langle y^{2}\\rangle$。\n3. 突触权重漂移与 $y\\big(y-\\theta_{M}\\big)$ 成正比，因此在输入统计特性发生阶跃变化后，突触漂移的符号取决于其诱发的突触后响应 $y$ 是否超过当前的 $\\theta_{M}$。\n\n在基线状态（正常饲养）下，神经元已达到稳态，其 $\\theta_{M}(0)=\\langle y^{2}\\rangle_{\\mathrm{N}}=0.49$。随后，将动物进行为期 $T$ 的暗饲养，在此期间，平均突触后激活相对于正常水平被一个常数因子 $\\alpha$ 进行乘性缩减，使得 $\\langle y^{2}\\rangle_{\\mathrm{D}}=\\alpha^{2}\\langle y^{2}\\rangle_{\\mathrm{N}}$。取 $\\alpha=0.4$，$T=10$ 天，$\\tau_{\\theta}=5$ 天。在 $t=T^{+}$ 时刻（即在 $\\theta_{M}$ 重新调整之前）立即重新暴露于正常感觉输入时，假设所有突触的瞬时诱发突触后激活在区间 $[y_{\\min},y_{\\max}]$ 上呈均匀分布，其中 $y_{\\min}=0.1$ 且 $y_{\\max}=0.9$（无量纲）。\n\n在这些假设和时间尺度分离（在重新暴露的瞬间，突触修饰相对于阈值适应是快速的）的前提下，将突触的“初始存活”定义为在 $t=T^{+}$ 时具有正向漂移，这对于其诱发响应 $y$ 而言，可简化为条件 $y>\\theta_{M}(T)$。计算在 $t=T^{+}$ 时突触的预期存活分数 $S$，即均匀分布中高于阈值 $\\theta_{M}(T)$ 的部分。仅报告 $S$ 的小数形式，并四舍五入到四位有效数字。无需单位。", "solution": "问题陈述已经过评估，被认为是有效的。它在科学上基于已建立的突触可塑性模型（特别是BCM理论），问题提法清晰，提供了所有必要的参数，并以客观、正式的语言表述。它提出了一个计算神经科学中可解的问题，没有内部矛盾或歧义。\n\n主要任务是计算在时间 $t=T^{+}$ 时突触的预期存活分数 $S$。该分数定义为突触后响应 $y$ 在那一刻超过修饰阈值 $\\theta_{M}$ 的突触比例。此存活条件为 $y > \\theta_{M}(T)$。为了求得 $S$，我们必须首先确定在暗饲养期结束时阈值 $\\theta_{M}(T)$ 的值。\n\n阈值 $\\theta_{M}$ 的演化由以下一阶线性常微分方程描述：\n$$\n\\frac{d \\theta_{M}}{dt} = \\frac{1}{\\tau_{\\theta}}\\Big(\\langle y^{2}\\rangle - \\theta_{M}\\Big)\n$$\n该问题分为两个阶段。第一阶段是暗饲养期，从 $t=0$ 持续到 $t=T$，在此期间神经元处于活动水平降低的状态。在 $t=0$ 时，神经元处于正常饲养对应的稳态，因此其初始阈值为 $\\theta_{M}(0) = \\langle y^{2}\\rangle_{\\mathrm{N}} = 0.49$。在暗饲养期间（$0 < t \\le T$），均方激活是一个恒定值，$\\langle y^{2}\\rangle = \\langle y^{2}\\rangle_{\\mathrm{D}}$。\n$\\langle y^{2}\\rangle_{\\mathrm{D}}$ 的值由下式给出：\n$$\n\\langle y^{2}\\rangle_{\\mathrm{D}} = \\alpha^{2}\\langle y^{2}\\rangle_{\\mathrm{N}}\n$$\n代入给定值 $\\alpha = 0.4$ 和 $\\langle y^{2}\\rangle_{\\mathrm{N}} = 0.49$：\n$$\n\\langle y^{2}\\rangle_{\\mathrm{D}} = (0.4)^{2} \\times 0.49 = 0.16 \\times 0.49 = 0.0784\n$$\n让我们将此目标阈值表示为 $\\theta_{\\mathrm{D}} = \\langle y^{2}\\rangle_{\\mathrm{D}}$。在此期间，$\\theta_{M}(t)$ 的微分方程为：\n$$\n\\frac{d \\theta_{M}}{dt} = -\\frac{1}{\\tau_{\\theta}}(\\theta_{M} - \\theta_{\\mathrm{D}})\n$$\n这是一个标准的松弛方程。给定初始条件 $\\theta_{M}(0)$，其解为：\n$$\n\\theta_{M}(t) = \\theta_{\\mathrm{D}} + \\Big(\\theta_{M}(0) - \\theta_{\\mathrm{D}}\\Big)\\exp\\left(-\\frac{t}{\\tau_{\\theta}}\\right)\n$$\n我们需要求出暗饲养期结束时（即 $t=T$ 时）的阈值。给定 $T=10$ 天和 $\\tau_{\\theta}=5$ 天。\n$$\n\\theta_{M}(T) = \\theta_{\\mathrm{D}} + \\Big(\\theta_{M}(0) - \\theta_{\\mathrm{D}}\\Big)\\exp\\left(-\\frac{T}{\\tau_{\\theta}}\\right)\n$$\n代入数值：\n$$\n\\theta_{M}(T) = 0.0784 + (0.49 - 0.0784)\\exp\\left(-\\frac{10}{5}\\right)\n$$\n$$\n\\theta_{M}(T) = 0.0784 + 0.4116 \\exp(-2)\n$$\n由于问题要求最终答案为小数，我们必须使用 $\\exp(-2)$ 的数值。使用 $\\exp(-2) \\approx 0.135335$：\n$$\n\\theta_{M}(T) \\approx 0.0784 + 0.4116 \\times 0.135335 \\approx 0.0784 + 0.055708 = 0.134108\n$$\n这就是在 $t=T^{+}$ 时刻，重新暴露于正常感觉输入后，突触修饰阈值的瞬时值。\n\n第二阶段是计算存活分数 $S$。在 $t=T^{+}$ 时，诱发的突触后激活 $y$ 从区间 $[y_{\\min}, y_{\\max}]$ 上的均匀概率分布中抽取，其中 $y_{\\min}=0.1$ 和 $y_{\\max}=0.9$。其概率密度函数 $p(y)$ 为：\n$$\np(y) = \n\\begin{cases} \n\\frac{1}{y_{\\max} - y_{\\min}} & \\text{for } y_{\\min} \\le y \\le y_{\\max} \\\\\n0 & \\text{otherwise}\n\\end{cases}\n$$\n存活分数 $S$ 是随机选择的突触其诱发响应 $y$ 大于阈值 $\\theta_{M}(T)$ 的概率。这由以下积分给出：\n$$\nS = P(y > \\theta_{M}(T)) = \\int_{\\theta_{M}(T)}^{y_{\\max}} p(y) \\, dy\n$$\n首先，我们确认计算出的阈值 $\\theta_{M}(T) \\approx 0.134108$ 位于区间 $[y_{\\min}, y_{\\max}] = [0.1, 0.9]$ 之内，事实确实如此。积分变为：\n$$\nS = \\int_{\\theta_{M}(T)}^{y_{\\max}} \\frac{1}{y_{\\max} - y_{\\min}} \\, dy = \\frac{1}{y_{\\max} - y_{\\min}} [y]_{\\theta_{M}(T)}^{y_{\\max}} = \\frac{y_{\\max} - \\theta_{M}(T)}{y_{\\max} - y_{\\min}}\n$$\n代入数值：\n$$\nS = \\frac{0.9 - 0.134108}{0.9 - 0.1} = \\frac{0.765892}{0.8}\n$$\n$$\nS \\approx 0.957365\n$$\n问题要求答案四舍五入到四位有效数字。\n$$\nS \\approx 0.9574\n$$\n这代表了在感觉剥夺期之后立即经历长时程增强 (LTP) 的突触比例，这一现象与稳态可塑性的实验观察结果一致。", "answer": "$$\n\\boxed{0.9574}\n$$", "id": "2757529"}, {"introduction": "现在我们将焦点从抽象的规则转向具体的分子机制。补体系统 (C3) 和小胶质细胞 (CR3) 是介导突触清除的关键执行者。本练习使用生物化学的基石——米氏动力学模型——来模拟突触修剪过程，从而定量预测药物（拮抗剂）将如何干扰这一过程，这有助于将理论概念与潜在的治疗干预联系起来。[@problem_id:2757593]", "problem": "在发育过程中，小胶质细胞通过补体受体3（CR3）介导的吞噬作用来清除被补体成分3（C3）标记的突触元件。在一个组织切片样本中，小胶质细胞的吞噬速率受到C3-CR3相互作用的限制，其单位小胶质细胞的摄取速率可通过Michaelis–Menten型关系式 $v = V_{\\max}\\,[\\mathrm{C3}]/(K_{m} + [\\mathrm{C3}])$ 来建模，其中 $[\\mathrm{C3}]$ 是突触C3调理素的浓度，$K_{m}$ 是米氏常数，$V_{\\max}$ 是最大摄取能力。施加一种与C3竞争结合CR3的小分子CR3拮抗剂。在拮抗剂浓度为 $[\\mathrm{I}]$、抑制常数为 $K_{i}$ 的竞争性拮抗作用下，表观米氏常数变为 $K_{m}^{\\mathrm{app}} = K_{m}\\left(1 + [\\mathrm{I}]/K_{i}\\right)$，而 $V_{\\max}$ 保持不变。\n\n假设以下经实验确定的数值：$[\\mathrm{C3}] = 50\\,\\mathrm{nM}$，$K_{m} = 30\\,\\mathrm{nM}$，$K_{i} = 10\\,\\mathrm{nM}$，以及 $[\\mathrm{I}] = 20\\,\\mathrm{nM}$。此外，假设被标记的突触群体 $N(t)$ 的突触修剪动力学遵循一级损失规律 $dN/dt = -k\\,N$，速率常数 $k = \\gamma\\,v$，其中 $\\gamma$ 是一个在所考虑范围内与 $[\\mathrm{I}]$ 和 $[\\mathrm{C3}]$ 无关的比例因子。\n\n计算施加拮抗剂后，修剪半衰期 $t_{1/2}$ 相对于对照组（无拮抗剂）的倍数变化，定义为 $t_{1/2}^{\\mathrm{blocked}}/t_{1/2}^{\\mathrm{control}}$。请以一个无单位的实数形式提供答案；无需四舍五入。", "solution": "该问题陈述已经过验证，被认为是科学上合理、阐述清晰且客观的。它基于酶动力学（Michaelis-Menten）和一级衰变过程的既定原理，这些是细胞神经科学和生物化学中的标准模型。所有必要的数据均已提供，且目标明确。因此，将提供解答。\n\n遵循一级衰变动力学的过程，其半衰期 $t_{1/2}$ 由微分方程 $dN/dt = -k\\,N$ 描述，并通过以下关系式给出：\n$$\nt_{1/2} = \\frac{\\ln(2)}{k}\n$$\n此处，$k$ 是一级速率常数。该方程表明，半衰期与速率常数成反比。\n\n我们需要计算施加竞争性拮抗剂后半衰期的倍数变化，即比值 $t_{1/2}^{\\mathrm{blocked}} / t_{1/2}^{\\mathrm{control}}$。利用半衰期与速率常数之间的反比关系，我们可以写出：\n$$\n\\frac{t_{1/2}^{\\mathrm{blocked}}}{t_{1/2}^{\\mathrm{control}}} = \\frac{\\ln(2)/k_{\\mathrm{blocked}}}{\\ln(2)/k_{\\mathrm{control}}} = \\frac{k_{\\mathrm{control}}}{k_{\\mathrm{blocked}}}\n$$\n问题陈述指出，速率常数 $k$ 与小胶质细胞摄取速率 $v$ 成正比，比例因子为 $\\gamma$：$k = \\gamma\\,v$。由于 $\\gamma$ 在实验范围内是恒定的，速率常数的比值等于摄取速率的比值：\n$$\n\\frac{k_{\\mathrm{control}}}{k_{\\mathrm{blocked}}} = \\frac{\\gamma v_{\\mathrm{control}}}{\\gamma v_{\\mathrm{blocked}}} = \\frac{v_{\\mathrm{control}}}{v_{\\mathrm{blocked}}}\n$$\n因此，问题简化为计算在对照（无拮抗剂）和阻断（有拮抗剂）条件下摄取速率的比值。\n\n在对照条件下，摄取速率 $v_{\\mathrm{control}}$ 遵循标准的Michaelis-Menten动力学：\n$$\nv_{\\mathrm{control}} = \\frac{V_{\\max}\\,[\\mathrm{C3}]}{K_{m} + [\\mathrm{C3}]}\n$$\n在阻断条件下，存在竞争性拮抗剂。对于竞争性抑制，最大速率 $V_{\\max}$ 不变，但米氏常数 $K_m$ 被表观米氏常数 $K_{m}^{\\mathrm{app}}$ 所取代。因此，摄取速率 $v_{\\mathrm{blocked}}$ 为：\n$$\nv_{\\mathrm{blocked}} = \\frac{V_{\\max}\\,[\\mathrm{C3}]}{K_{m}^{\\mathrm{app}} + [\\mathrm{C3}]}\n$$\n表观米氏常数由 $K_{m}^{\\mathrm{app}} = K_{m}\\left(1 + \\frac{[\\mathrm{I}]}{K_{i}}\\right)$ 给出，其中 $[\\mathrm{I}]$ 是拮抗剂浓度，$K_{i}$ 是其抑制常数。\n\n现在我们可以计算所求的比值：\n$$\n\\frac{t_{1/2}^{\\mathrm{blocked}}}{t_{1/2}^{\\mathrm{control}}} = \\frac{v_{\\mathrm{control}}}{v_{\\mathrm{blocked}}} = \\frac{\\frac{V_{\\max}\\,[\\mathrm{C3}]}{K_{m} + [\\mathrm{C3}]}}{\\frac{V_{\\max}\\,[\\mathrm{C3}]}{K_{m}^{\\mathrm{app}} + [\\mathrm{C3}]}}\n$$\n分子中的 $V_{\\max}$ 和 $[\\mathrm{C3}]$ 项相互抵消，表达式简化为：\n$$\n\\frac{t_{1/2}^{\\mathrm{blocked}}}{t_{1/2}^{\\mathrm{control}}} = \\frac{K_{m}^{\\mathrm{app}} + [\\mathrm{C3}]}{K_{m} + [\\mathrm{C3}]}\n$$\n代入 $K_{m}^{\\mathrm{app}}$ 的表达式：\n$$\n\\frac{t_{1/2}^{\\mathrm{blocked}}}{t_{1/2}^{\\mathrm{control}}} = \\frac{K_{m}\\left(1 + \\frac{[\\mathrm{I}]}{K_{i}}\\right) + [\\mathrm{C3}]}{K_{m} + [\\mathrm{C3}]}\n$$\n我们已知以下数值：$[\\mathrm{C3}] = 50\\,\\mathrm{nM}$，$K_{m} = 30\\,\\mathrm{nM}$，$K_{i} = 10\\,\\mathrm{nM}$，以及 $[\\mathrm{I}] = 20\\,\\mathrm{nM}$。我们将这些数值代入推导出的表达式中。请注意，单位（$\\mathrm{nM}$）是一致的，将会抵消，从而得到一个无量纲的比值。\n$$\n\\frac{t_{1/2}^{\\mathrm{blocked}}}{t_{1/2}^{\\mathrm{control}}} = \\frac{30\\left(1 + \\frac{20}{10}\\right) + 50}{30 + 50}\n$$\n首先，我们计算括号中表示抑制作用的项：\n$$\n1 + \\frac{20}{10} = 1 + 2 = 3\n$$\n接下来，我们计算主表达式的分子，它对应于阻断条件下速率方程的分母：\n$$\n30(3) + 50 = 90 + 50 = 140\n$$\n然后，我们计算主表达式的分母，它对应于对照条件下速率方程的分母：\n$$\n30 + 50 = 80\n$$\n最后，我们计算该比值：\n$$\n\\frac{140}{80} = \\frac{14}{8} = \\frac{7}{4} = 1.75\n$$\n修剪半衰期的倍数变化为 $1.75$。这意味着在存在竞争性拮抗剂的情况下，被标记突触的半衰期增加了 $1.75$ 倍。这是一个合理的结果，因为拮抗剂减慢了突触清除的速率，从而延长了清除一半突触群体所需的时间。", "answer": "$$\n\\boxed{1.75}\n$$", "id": "2757593"}, {"introduction": "本练习旨在搭建建模与实验科学之间的桥梁。在观察到诸如补体蛋白 C1q 出现在突触上等现象后，我们需要严谨的统计方法来检验这种标记是否真正依赖于神经活动。本练习将指导你设计并实现一个非参数的置换检验，这是一个对数据分布做最少假设的强大工具，用以分析模拟的实验结果，从而强调在现代神经科学中稳健数据分析的重要性。[@problem_id:2757423]", "problem": "您将获得在两种条件下，即正常活动和使用河豚毒素 (TTX) 阻断活动时，单个突触处补体成分1q (C1q) 的免疫染色强度测量值。您的目标是基于假设检验和可交换性的第一性原理，设计、论证并实现一个非参数、双样本、活动依赖性检验，以确定C1q标记是否依赖于神经活动。使用以下基本原则，以纯数学术语表述该问题：(i) 条件标签是可交换的原假设的定义，(ii) 将检验统计量定义为样本的泛函，以及 (iii) 通过标签置换构建零分布以计算双边p值。避免对数据分布进行参数化假设。\n\n使用的定义：\n- 原假设 $H_0$：两个样本来自同一总体；标签“正常”和“TTX”是可交换的。\n- 检验统计量 $T$：两种条件下样本均值之间的绝对差。\n- 双边置换检验：在 $H_0$ 下，通过对合并观测值的标签进行置换来生成 $T$ 的抽样分布。\n- 决策规则：如果 $p \\le \\alpha$，则拒绝 $H_0$，其中 $\\alpha = 0.05$。\n- 效应量：报告 Cliff's delta，其定义为 $\\delta = \\frac{n_{+} - n_{-}}{n_1 n_2}$，其中 $n_{+}$ 统计满足 $y > x$ 的配对 $(y, x)$ 的数量，$n_{-}$ 统计满足 $y < x$ 的配对数量，方向为 $(\\text{TTX} - \\text{正常})$。此处 $n_1$ 和 $n_2$ 分别是正常组和 TTX 组的样本大小。\n\n算法要求：\n1. 设正常条件样本为 $X = \\{x_i\\}_{i=1}^{n_1}$，TTX 条件样本为 $Y = \\{y_j\\}_{j=1}^{n_2}$。计算观测到的统计量 $T_{\\text{obs}} = \\left|\\bar{y} - \\bar{x}\\right|$，其中 $\\bar{x}$ 和 $\\bar{y}$ 分别是 $X$ 和 $Y$ 的样本均值。\n2. 通过对合并数据 $Z = X \\cup Y$ 的标签进行置换来构建 $T$ 的零分布：\n   - 如果 $n_1 + n_2 \\le 14$，则通过枚举所有 $\\binom{n_1 + n_2}{n_1}$ 种分割来计算精确的零分布。\n   - 否则，通过至少 $100000$ 次标签的随机均匀置换进行蒙特卡洛近似，并使用固定的伪随机种子 $12345$ 以保证可复现性。\n3. 将双边p值计算为置换统计量中大于或等于 $T_{\\text{obs}}$ 的比例。对于蒙特卡洛近似，您可以应用标准的“加一”校正以避免p值为零。\n4. 计算方向为 $(\\text{TTX} - \\text{正常})$ 的 Cliff's delta $\\delta$。\n5. 使用显著性水平 $\\alpha = 0.05$，并将决策编码为整数：如果 $p \\le \\alpha$ 则输出 $1$，否则输出 $0$。\n6. 四舍五入和输出格式：\n   - p值四舍五入至 $6$ 位小数。\n   - Cliff's delta 四舍五入至 $3$ 位小数。\n   - 决策必须是整数（$0$ 或 $1$）。\n   - 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个三元组，顺序为 $[p,\\text{decision},\\delta]$，例如：$[[0.012345,1,0.876],[0.543210,0,-0.123]]$。\n\n测试套件（按此顺序准确使用这四个案例；所有值均为无单位的强度）：\n- 案例 A（中等样本量，差异明显；测试蒙特卡洛分支）：\n  - 正常：$[0.85, 0.90, 0.95, 1.00, 1.05, 1.10, 1.15, 1.20, 0.92, 1.08, 1.12, 0.88]$\n  - TTX：$[1.35, 1.40, 1.45, 1.50, 1.55, 1.60, 1.65, 1.70, 1.38, 1.62, 1.58, 1.42]$\n- 案例 B（退化相等；测试精确分支和对并列值的处理）：\n  - 正常：$[1.00, 1.00, 1.00, 1.00, 1.00]$\n  - TTX：$[1.00, 1.00, 1.00, 1.00, 1.00]$\n- 案例 C（小样本，显著差异；测试精确分支）：\n  - 正常：$[0.80, 0.90, 1.00]$\n  - TTX：$[1.10, 1.30, 1.20]$\n- 案例 D（平衡小样本，细微差异；测试边界附近的精确分支）：\n  - 正常：$[0.95, 1.02, 1.10, 1.08, 0.99, 1.03, 1.00]$\n  - TTX：$[1.04, 0.98, 1.06, 1.01, 1.00, 1.02, 1.03]$\n\n您的程序必须实现上述测试并以精确格式生成单行输出：\n- 一个包含四个条目的列表，按 A, B, C, D 的顺序，每个案例一个条目。\n- 每个条目是一个形式为 $[p,\\text{decision},\\delta]$ 的列表，其中 $p$ 是一个四舍五入到 $6$ 位小数的浮点数，$\\text{decision}$ 是一个整数，$\\delta$ 是一个四舍五入到 $3$ 位小数的浮点数。\n- 所需外部格式示例：$[[p_A,d_A,\\delta_A],[p_B,d_B,\\delta_B],[p_C,d_C,\\delta_C],[p_D,d_D,\\delta_D]]$。\n\n不涉及物理单位，也不涉及角度。所有数值输出必须遵循指定的四舍五入规则。该算法必须从原假设和可交换性原理推导得出，不得调用参数分布假设。", "solution": "所提出的问题是计算统计学中一个定义明确、有科学依据的任务，应用于细胞神经科学领域的一个现实问题。它要求实现一个双样本置换检验，以评估由补体成分$1q$ ($C1q$) 完成的突触标记是否依赖于被河豚毒素 ($TTX$) 阻断的神经活动。所有提供的定义、数据和算法约束都是内部一致、明确且充分的，足以开发出唯一且可验证的解决方案。因此，该问题被认定为有效。\n\n问题的核心是假设检验。我们得到两个独立的 $C1q$ 强度测量样本：来自“正常”活动条件的 $X = \\{x_i\\}_{i=1}^{n_1}$，以及来自“TTX”活动阻断条件的 $Y = \\{y_j\\}_{j=1}^{n_2}$。我们希望确定这些样本所来自的潜在分布是否不同。\n\n置换检验的基本原理依赖于原假设 $H_0$。在 $H_0$ 下，两种条件之间没有差异；两个样本中的数据都来自相同的潜在总体分布。由此得出的一个直接逻辑推论是可交换性原理：如果 $H_0$ 为真，那么组标签（“正常”、“TTX”）是任意的，可以在数据点之间交换或“置换”，而不会改变合并数据的联合概率分布。\n\n程序步骤如下：\n\n1.  **定义检验统计量**：我们必须选择一个数据函数，即检验统计量 $T$，以量化两个样本之间的差异。问题指定了样本均值的绝对差：\n    $$T = |\\bar{y} - \\bar{x}| = \\left| \\frac{1}{n_2}\\sum_{j=1}^{n_2} y_j - \\frac{1}{n_1}\\sum_{i=1}^{n_1} x_i \\right|$$\n    这是一个合理的选择，因为它直接衡量了两组中心趋势的差异。较大的 $T$ 值表明样本来自不同的总体。我们为我们的观测数据计算此统计量，得到 $T_{\\text{obs}}$。\n\n2.  **构建零分布**：为了以统计上显著的方式确定 $T_{\\text{obs}}$ 是否“大”，我们必须将其与原假设为真时所期望的 $T$ 的分布进行比较。这就是零分布。我们通过模拟可交换性原理来生成此分布。我们将所有观测值合并到一个大小为 $N = n_1 + n_2$ 的集合 $Z = X \\cup Y$ 中。然后，我们通过将 $Z$ 分别划分为大小为 $n_1$ 和 $n_2$ 的子集来重复创建新的伪样本 $X'$ 和 $Y'$。对于每个这样的划分，我们计算相应的检验统计量 $T'$。所有可能的 $T'$ 值的集合构成了零分布。\n\n    问题正确地区分了用于此构建的两种方案：\n    -   **精确检验**：如果总样本量 $N$ 较小（此处为 $N \\le 14$），则枚举所有可能的划分在计算上是可行的。从总共 $N$ 个元素中为第一组选择 $n_1$ 个元素的唯一方式数量由二项式系数 $\\binom{N}{n_1}$ 给出。通过为每个划分计算 $T'$，我们就可以获得精确的零分布。\n    -   **蒙特卡洛近似**：对于较大的 $N$（此处为 $N > 14$），组合数量在计算上变得不可行。因此，我们通过生成大量（按规定为 $100000$）标签的随机置换来近似零分布。对于每个随机置换，我们计算 $T'$。由此得到的统计量集合可作为真实零分布的经验近似。通过使用固定的伪随机种子（$12345$）可确保可复现性。\n\n3.  **计算p值**：双边p值是在假设 $H_0$ 为真的情况下，观测到至少与 $T_{\\text{obs}}$ 一样极端的检验统计量的概率。由于我们的统计量 $T = |\\bar{y} - \\bar{x}|$ 本身是绝对值，它能捕捉双向的偏差。因此，p值为：\n    $$p = P(T' \\ge T_{\\text{obs}} | H_0)$$\n    该概率计算为所构建的零分布中大于或等于 $T_{\\text{obs}}$ 的统计量的比例。对于蒙特卡洛方法，会应用一种标准校正以避免报告p值为0，因为p值为0在理论上是站不住脚的。如果在 $M$ 次蒙特卡洛置换中有 $k$ 次的结果为 $T' \\ge T_{\\text{obs}}$，则p值计算为 $p = (k+1) / (M+1)$。对于精确检验，p值就是 $k/M_{total}$，其中 $M_{total} = \\binom{N}{n_1}$ 且 $k$ 是产生 $T' \\ge T_{\\text{obs}}$ 的划分数量。\n\n4.  **决策与效应量**：通过将p值与预定义的显著性水平 $\\alpha = 0.05$ 进行比较来做出统计决策。如果 $p \\le \\alpha$，我们拒绝 $H_0$ 并得出结论，认为各组之间存在显著差异，这与活动依赖性 $C1q$ 标记一致。此决策编码为 $1$。否则（$p > \\alpha$），我们不拒绝 $H_0$，决策编码为 $0$。\n\n    最后，为量化与样本量无关的差异幅度，我们计算非参数效应量 Cliff's delta ($\\delta$)。其定义为：\n    $$\\delta = \\frac{n_{+} - n_{-}}{n_1 n_2}$$\n    其中 $n_{+}$ 是满足 $y_j > x_i$ 的配对 $(y_j, x_i)$ 的数量，$n_{-}$ 是满足 $y_j < x_i$ 的配对数量。指定方向为 $(\\text{TTX} - \\text{正常})$，这意味着 $Y$ 是 TTX 样本，$X$ 是正常样本。$\\delta$ 的取值范围为 $-1$ 到 $1$，其中 $1$ 表示 TTX 组的所有值都大于正常组的所有值，而 $0$ 表示分布完全重叠。\n\n整个过程避免了对数据遵循特定参数分布（例如高斯分布）的任何假设，使其成为一个针对该问题的稳健且适当的方法。实现过程将为所提供的四个测试用例精确地遵循这些步骤。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import combinations\nimport scipy  # Per library requirements, though not directly used in this implementation\n\ndef perform_activity_dependence_test(normal_data, ttx_data, alpha=0.05, mc_perms=100000, seed=12345):\n    \"\"\"\n    Performs a nonparametric permutation test to determine if C1q tagging is activity-dependent.\n\n    Args:\n        normal_data (list): C1q intensity values for the normal condition.\n        ttx_data (list): C1q intensity values for the TTX condition.\n        alpha (float): Significance level.\n        mc_perms (int): Number of permutations for Monte Carlo approximation.\n        seed (int): Seed for the pseudorandom number generator.\n\n    Returns:\n        tuple: A tuple containing the p-value (float), decision (int), and Cliff's delta (float).\n    \"\"\"\n    X = np.array(normal_data, dtype=np.float64)\n    Y = np.array(ttx_data, dtype=np.float64)\n    n1, n2 = len(X), len(Y)\n    \n    # Step 1: Compute observed test statistic\n    mean_x, mean_y = np.mean(X), np.mean(Y)\n    T_obs = np.abs(mean_y - mean_x)\n    \n    # Step 2  3: Construct null distribution and compute p-value\n    Z = np.concatenate((X, Y))\n    total_n = n1 + n2\n    \n    # Use a small tolerance for floating point comparisons\n    TOLERANCE = 1e-9\n\n    if total_n = 14:\n        # Exact Test\n        indices = range(total_n)\n        perm_stats = []\n        for group1_indices in combinations(indices, n1):\n            group2_indices = [i for i in indices if i not in group1_indices]\n            \n            perm_X = Z[list(group1_indices)]\n            perm_Y = Z[list(group2_indices)]\n            \n            perm_T = np.abs(np.mean(perm_Y) - np.mean(perm_X))\n            perm_stats.append(perm_T)\n        \n        perm_stats_arr = np.array(perm_stats)\n        num_extreme = np.sum(perm_stats_arr >= T_obs - TOLERANCE)\n        p_value = num_extreme / len(perm_stats_arr)\n    else:\n        # Monte Carlo Approximation\n        rng = np.random.RandomState(seed)\n        num_extreme = 0\n        for _ in range(mc_perms):\n            permuted_Z = rng.permutation(Z)\n            perm_X = permuted_Z[:n1]\n            perm_Y = permuted_Z[n1:]\n            \n            perm_T = np.abs(np.mean(perm_Y) - np.mean(perm_X))\n            if perm_T >= T_obs - TOLERANCE:\n                num_extreme += 1\n        \n        # Apply plus-one correction\n        p_value = (num_extreme + 1) / (mc_perms + 1)\n        \n    # Step 4: Compute Cliff's Delta\n    if n1 == 0 or n2 == 0:\n        cliff_delta = 0.0\n    else:\n        n_plus = 0\n        n_minus = 0\n        for y_val in Y:\n            for x_val in X:\n                if y_val > x_val:\n                    n_plus += 1\n                elif y_val  x_val:\n                    n_minus += 1\n        cliff_delta = (n_plus - n_minus) / (n1 * n2)\n\n    # Step 5: Make Decision\n    decision = 1 if p_value = alpha else 0\n    \n    return p_value, decision, cliff_delta\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        (\n            [0.85, 0.90, 0.95, 1.00, 1.05, 1.10, 1.15, 1.20, 0.92, 1.08, 1.12, 0.88],\n            [1.35, 1.40, 1.45, 1.50, 1.55, 1.60, 1.65, 1.70, 1.38, 1.62, 1.58, 1.42]\n        ),\n        # Case B\n        (\n            [1.00, 1.00, 1.00, 1.00, 1.00],\n            [1.00, 1.00, 1.00, 1.00, 1.00]\n        ),\n        # Case C\n        (\n            [0.80, 0.90, 1.00],\n            [1.10, 1.30, 1.20]\n        ),\n        # Case D\n        (\n            [0.95, 1.02, 1.10, 1.08, 0.99, 1.03, 1.00],\n            [1.04, 0.98, 1.06, 1.01, 1.00, 1.02, 1.03]\n        )\n    ]\n\n    results = []\n    for normal_data, ttx_data in test_cases:\n        p_val, dec, delta = perform_activity_dependence_test(normal_data, ttx_data)\n        results.append([p_val, dec, delta])\n\n    # Final print statement in the exact required format.\n    # Rounding is handled by the f-string formatting.\n    inner_parts = [f\"[{p:.6f},{d},{delta:.3f}]\" for p, d, delta in results]\n    final_output = f\"[{','.join(inner_parts)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2757423"}]}