{"hands_on_practices": [{"introduction": "在神经元中，货物的轴突运输并非一条平坦的单行道。通过细胞成像技术，我们观察到货物会经历快速的前向运动、后向运动以及频繁的暂停。本练习 [@problem_id:2699442] 将引导你分析这种复杂的双向运动，通过将运动分解为重复的循环来计算长时间内的净位移，从而将从图像（如动态图）中观察到的瞬时速度与宏观运输效率联系起来。", "problem": "使用动态记录图 (kymograph) 沿一条笔直的轴突追踪一个单层膜结合的货物。动态记录图上每条线段的斜率等于货物的瞬时速度，正斜率表示顺向运动，负斜率表示逆向运动。在长时间内，货物表现出严格交替的序列：顺向运动、暂停、逆向运动、暂停，如此循环。在运动期间，观察到的运动斜率大小恒定：顺向运动的速度为 $v_{a} = +1\\,\\mu\\mathrm{m}\\,\\mathrm{s}^{-1}$，逆向运动的速度为 $v_{r} = -0.8\\,\\mu\\mathrm{m}\\,\\mathrm{s}^{-1}$。暂停期间速度为零，根据经验测得的平均持续时间为 $3\\,\\mathrm{s}$。假设顺向运动和逆向运动的持续时间相等，并且为了计算长时间记录中的时间平均输运，您可以将暂停持续时间替换为其平均值。进一步假设，运动持续时间等于平均暂停时间，即每次运动持续 $\\tau_{r} = 3\\,\\mathrm{s}$，并且该序列以一次顺向运动开始，此后完美交替。\n\n仅使用以下定义：(i) 速度 $v(t)$ 满足 $v(t) = dx/dt$；(ii) 一段时间间隔内的净输运距离是 $v(t)$ 的时间积分。计算在总计 $10\\,\\mathrm{min}$ 的记录时间内累积的净输运距离（顺向位移减去逆向位移）。以微米为单位表示最终答案，并四舍五入至三位有效数字。", "solution": "已根据指定标准审查了问题陈述的有效性。该问题描述了一个简化的、但物理上自洽的一维运动模型，这是一维运动是生物物理学和细胞神经科学的核心主题。所提供的参数是明确、无矛盾的，并且处于快速轴突运输的实际生物学范围内。该问题是适定的、客观的且可形式化的。因此，判定该问题有效，并将在下文提供严谨的解答。\n\n该问题要求计算货物在指定时间间隔内的净输运距离。其运动被描述为一个由离散阶段组成的周期性序列。\n\n首先，我们确定问题陈述中给出的参数：\n顺向速度：$v_{a} = +1\\,\\mu\\mathrm{m}\\,\\mathrm{s}^{-1}$\n逆向速度：$v_{r} = -0.8\\,\\mu\\mathrm{m}\\,\\mathrm{s}^{-1}$\n暂停速度：$v_{p} = 0\\,\\mu\\mathrm{m}\\,\\mathrm{s}^{-1}$\n\n问题陈述指出，顺向和逆向运动的持续时间相等，且这个共同的运动持续时间等于平均暂停持续时间 $3\\,\\mathrm{s}$。因此，每个运动阶段的持续时间都相同。设这个共同的持续时间为 $\\tau$：\n$\\tau = 3\\,\\mathrm{s}$\n\n运动序列是严格交替的：顺向运动 (A)、暂停 (P)、逆向运动 (R)、暂停 (P)，如此循环。因此，一个完整的运动周期可以定义为序列 (A, P, R, P)。\n\n一个完整周期的时间 $T_{cycle}$ 是其四个组成阶段持续时间之和：\n$$T_{cycle} = \\tau_{A} + \\tau_{P} + \\tau_{R} + \\tau_{P} = \\tau + \\tau + \\tau + \\tau = 4\\tau$$\n代入 $\\tau$ 的值：\n$$T_{cycle} = 4 \\times 3\\,\\mathrm{s} = 12\\,\\mathrm{s}$$\n\n在一个时间间隔内的净位移 $\\Delta x$ 是速度函数 $v(t)$ 的时间积分。对于一个速度为常数 $v$ 且持续时间为 $\\Delta t$ 的阶段，其位移即为 $\\Delta x = v \\Delta t$。现在我们可以计算一个完整周期内的净位移 $\\Delta x_{cycle}$。\n\n顺向运动期间的位移：\n$$\\Delta x_{a} = v_{a} \\tau = (1\\,\\mu\\mathrm{m}\\,\\mathrm{s}^{-1}) \\times (3\\,\\mathrm{s}) = 3\\,\\mu\\mathrm{m}$$\n第一次暂停期间的位移：\n$$\\Delta x_{p1} = v_{p} \\tau = (0\\,\\mu\\mathrm{m}\\,\\mathrm{s}^{-1}) \\times (3\\,\\mathrm{s}) = 0\\,\\mu\\mathrm{m}$$\n逆向运动期间的位移：\n$$\\Delta x_{r} = v_{r} \\tau = (-0.8\\,\\mu\\mathrm{m}\\,\\mathrm{s}^{-1}) \\times (3\\,\\mathrm{s}) = -2.4\\,\\mu\\mathrm{m}$$\n第二次暂停期间的位移：\n$$\\Delta x_{p2} = v_{p} \\tau = (0\\,\\mu\\mathrm{m}\\,\\mathrm{s}^{-1}) \\times (3\\,\\mathrm{s}) = 0\\,\\mu\\mathrm{m}$$\n\n一个周期内的总净位移是这些单独位移的总和：\n$$\\Delta x_{cycle} = \\Delta x_{a} + \\Delta x_{p1} + \\Delta x_{r} + \\Delta x_{p2} = 3\\,\\mu\\mathrm{m} + 0\\,\\mu\\mathrm{m} - 2.4\\,\\mu\\mathrm{m} + 0\\,\\mu\\mathrm{m} = 0.6\\,\\mu\\mathrm{m}$$\n\n给定的总记录时间为 $T_{total} = 10\\,\\mathrm{min}$。我们必须将其转换为秒，以便与其他单位保持一致：\n$$T_{total} = 10\\,\\mathrm{min} \\times \\frac{60\\,\\mathrm{s}}{1\\,\\mathrm{min}} = 600\\,\\mathrm{s}$$\n\n现在我们确定在总记录时间内发生的完整周期数 $N_{cycles}$：\n$$N_{cycles} = \\frac{T_{total}}{T_{cycle}} = \\frac{600\\,\\mathrm{s}}{12\\,\\mathrm{s}} = 50$$\n由于总时间是周期持续时间的确切整数倍，因此输运过程恰好包含 $50$ 个完整周期。\n\n总净输运距离 $\\Delta x_{total}$ 是周期数与每周期净位移的乘积：\n$$\\Delta x_{total} = N_{cycles} \\times \\Delta x_{cycle} = 50 \\times 0.6\\,\\mu\\mathrm{m} = 30\\,\\mu\\mathrm{m}$$\n\n问题要求最终答案以微米表示，并四舍五入至三位有效数字。计算出的值 $30\\,\\mu\\mathrm{m}$ 必须写成 $30.0\\,\\mu\\mathrm{m}$ 才能满足此条件。", "answer": "$$\\boxed{30.0}$$", "id": "2699442"}, {"introduction": "上一个练习描述了货物运动的“现象”，而本练习则深入探讨其背后的“机制”。货物之所以会双向运动，是因为它同时被向两个相反方向移动的分子马达（驱动蛋白和动力蛋白）团队牵引，这被称为“拔河模型”。通过这个练习 [@problem_id:2699392]，你将应用概率论来模拟马达的随机结合与解离过程，并根据力平衡来计算货物向某一方向运动的概率，从而理解分子层面的随机事件如何决定细胞层面的运输方向。", "problem": "轴突中的一个货物通过dynein和kinesin马达同时与细胞骨架轨道耦合，这些马达的附着状态因随机的结合与解离而波动。考虑一个货物，有一个包含 $n_d=3$ 个细胞质dynein和 $n_k=2$ 个kinesin的集合可供结合。每个马达根据一个两状态连续时间马尔可夫过程，在未结合状态和结合状态之间独立切换：当未结合时，马达以速率 $k_{\\mathrm{on}}$ 附着到货物-轨道复合物上；当结合时，dynein以速率 $k_{\\mathrm{off},d}$ 解离，kinesin以速率 $k_{\\mathrm{off},k}$ 解离。假设两种马达的附着速率相等，均为 $k_{\\mathrm{on}}=1\\,\\mathrm{s}^{-1}$，dynein的解离速率为 $k_{\\mathrm{off},d}=2\\,\\mathrm{s}^{-1}$，kinesin的解离速率为 $k_{\\mathrm{off},k}=1\\,\\mathrm{s}^{-1}$。这些马达进行一场简单的拔河比赛，它们的失速力不相等：dynein的失速力为 $F_d=7\\,\\mathrm{pN}$，kinesin的失速力为 $F_k=6\\,\\mathrm{pN}$。忽略附着和解离速率的任何负载依赖性，以及除了下文描述的力平衡之外的马达之间的任何相互作用。在附着-解离动力学的稳态下进行分析，并假设结合的dynein和kinesin的数量在不同马达之间以及不同类型之间是独立的。\n\n在某个观察时刻，采用“赢者通吃”的准则来判断运动方向：如果结合的dynein数量为 $i_d$ 且结合的kinesin数量为 $i_k$，则货物发生逆行运动（朝向胞体）当且仅当 $F_d\\,i_d>F_k\\,i_k$；如果 $F_d\\,i_d=F_k\\,i_k$，则将货物视为不进行逆行运动。\n\n从两状态连续时间马尔可夫过程的主方程和基本概率论出发，推导出每种类型结合马达的稳态分布，并用它来计算在上述假设下，货物在任意观察时刻进行逆行运动的概率。将最终答案表示为一个精确分数，不带单位，不要四舍五入。", "solution": "问题要求计算在相互竞争的dynein和kinesin马达驱动下，货物发生逆行运动的稳态概率。分析将分三步进行：首先，确定单个马达处于结合状态的稳态概率；其次，推导结合的dynein和kinesin数量的概率分布；最后，对所有导致逆行运动的状态的概率求和。\n\n单个马达被建模为一个具有未结合状态 ($U$) 和结合状态 ($B$) 的两状态连续时间马尔可夫过程。转换过程为 $U \\xrightarrow{k_{\\mathrm{on}}} B$ 和 $B \\xrightarrow{k_{\\mathrm{off}}} U$。设 $P_B(t)$ 和 $P_U(t)$ 分别为马达在时间 $t$ 处于结合状态和未结合状态的概率。结合状态的主方程为：\n$$ \\frac{dP_B}{dt} = k_{\\mathrm{on}} P_U - k_{\\mathrm{off}} P_B $$\n总概率守恒，$P_U(t) + P_B(t) = 1$。在稳态下，概率是恒定的，因此 $\\frac{dP_B}{dt} = 0$。设 $p_b$ 和 $p_u$ 表示稳态概率。主方程变为：\n$$ 0 = k_{\\mathrm{on}} p_u - k_{\\mathrm{off}} p_b $$\n代入 $p_u = 1 - p_b$，我们得到 $k_{\\mathrm{on}}(1 - p_b) = k_{\\mathrm{off}} p_b$。解出 $p_b$ 可得：\n$$ k_{\\mathrm{on}} = (k_{\\mathrm{on}} + k_{\\mathrm{off}}) p_b \\implies p_b = \\frac{k_{\\mathrm{on}}}{k_{\\mathrm{on}} + k_{\\mathrm{off}}} $$\n我们将此通用公式应用于dynein和kinesin马达，使用给定的速率常数：两者均为 $k_{\\mathrm{on}} = 1\\,\\mathrm{s}^{-1}$，dynein的解离速率为 $k_{\\mathrm{off},d} = 2\\,\\mathrm{s}^{-1}$，kinesin的解离速率为 $k_{\\mathrm{off},k} = 1\\,\\mathrm{s}^{-1}$。\n\n单个dynein马达处于结合状态的稳态概率为：\n$$ p_{b,d} = \\frac{k_{\\mathrm{on}}}{k_{\\mathrm{on}} + k_{\\mathrm{off},d}} = \\frac{1}{1 + 2} = \\frac{1}{3} $$\n单个kinesin马达处于结合状态的稳态概率为：\n$$ p_{b,k} = \\frac{k_{\\mathrm{on}}}{k_{\\mathrm{on}} + k_{\\mathrm{off},k}} = \\frac{1}{1 + 1} = \\frac{1}{2} $$\n问题陈述有 $n_d = 3$ 个dynein和 $n_k = 2$ 个kinesin可用，且它们的结合/解离事件是独立的。因此，每种类型结合马达的数量（用随机变量 $I_d$ 和 $I_k$ 表示）服从二项分布。\n\n在 $n_d=3$ 个dynein中有 $i_d$ 个结合的概率由 $P(I_d=i_d) = \\binom{n_d}{i_d} (p_{b,d})^{i_d} (1-p_{b,d})^{n_d-i_d}$ 给出。当 $p_{b,d} = 1/3$ 时，概率为：\n$$ P(I_d=0) = \\binom{3}{0}\\left(\\frac{1}{3}\\right)^0\\left(\\frac{2}{3}\\right)^3 = 1 \\cdot 1 \\cdot \\frac{8}{27} = \\frac{8}{27} $$\n$$ P(I_d=1) = \\binom{3}{1}\\left(\\frac{1}{3}\\right)^1\\left(\\frac{2}{3}\\right)^2 = 3 \\cdot \\frac{1}{3} \\cdot \\frac{4}{9} = \\frac{12}{27} $$\n$$ P(I_d=2) = \\binom{3}{2}\\left(\\frac{1}{3}\\right)^2\\left(\\frac{2}{3}\\right)^1 = 3 \\cdot \\frac{1}{9} \\cdot \\frac{2}{3} = \\frac{6}{27} $$\n$$ P(I_d=3) = \\binom{3}{3}\\left(\\frac{1}{3}\\right)^3\\left(\\frac{2}{3}\\right)^0 = 1 \\cdot \\frac{1}{27} \\cdot 1 = \\frac{1}{27} $$\n在 $n_k=2$ 个kinesin中有 $i_k$ 个结合的概率由 $P(I_k=i_k) = \\binom{n_k}{i_k} (p_{b,k})^{i_k} (1-p_{b,k})^{n_k-i_k}$ 给出。当 $p_{b,k} = 1/2$ 时，概率为：\n$$ P(I_k=0) = \\binom{2}{0}\\left(\\frac{1}{2}\\right)^0\\left(\\frac{1}{2}\\right)^2 = 1 \\cdot 1 \\cdot \\frac{1}{4} = \\frac{1}{4} $$\n$$ P(I_k=1) = \\binom{2}{1}\\left(\\frac{1}{2}\\right)^1\\left(\\frac{1}{2}\\right)^1 = 2 \\cdot \\frac{1}{2} \\cdot \\frac{1}{2} = \\frac{2}{4} $$\n$$ P(I_k=2) = \\binom{2}{2}\\left(\\frac{1}{2}\\right)^2\\left(\\frac{1}{2}\\right)^0 = 1 \\cdot \\frac{1}{4} \\cdot 1 = \\frac{1}{4} $$\n逆行运动的准则是来自结合的dynein的总力超过来自结合的kinesin的总力：$F_d \\cdot i_d > F_k \\cdot i_k$。当失速力为 $F_d = 7\\,\\mathrm{pN}$ 和 $F_k = 6\\,\\mathrm{pN}$ 时，该条件为 $7i_d > 6i_k$。\n\n逆行运动的总概率 $P_{\\text{retrograde}}$ 是所有满足此不等式的状态 $(i_d, i_k)$ 的概率之和。由于dynein和kinesin群体的结合是独立的，其联合概率为 $P(I_d=i_d, I_k=i_k) = P(I_d=i_d)P(I_k=i_k)$。\n$$ P_{\\text{retrograde}} = \\sum_{i_d=0}^{3} \\sum_{i_k=0}^{2} \\mathbb{I}(7i_d > 6i_k) P(I_d=i_d)P(I_k=i_k) $$\n其中 $\\mathbb{I}(\\cdot)$ 是指示函数。计算其互补事件，即非逆行运动（当 $7i_d \\le 6i_k$ 时发生）的概率会更有效率。我们列举满足此条件的状态 $(i_d, i_k)$：\n- 如果 $i_d = 0$：$0 \\le 6i_k$ 对所有 $i_k \\in \\{0, 1, 2\\}$ 均成立。状态：$(0,0), (0,1), (0,2)$。\n- 如果 $i_d = 1$：$7 \\le 6i_k \\implies i_k \\ge 7/6$。所以 $i_k=2$。状态：$(1,2)$。\n- 如果 $i_d = 2$：$14 \\le 6i_k \\implies i_k \\ge 14/6 \\approx 2.33$。没有可能的 $i_k$。\n- 如果 $i_d = 3$：$21 \\le 6i_k \\implies i_k \\ge 21/6 = 3.5$。没有可能的 $i_k$。\n\n非逆行运动的状态集合为 $\\{(0,0), (0,1), (0,2), (1,2)\\}$。其概率 $P_{\\text{non-retrograde}}$ 为：\n$$ P_{\\text{non-retrograde}} = P(I_d=0, I_k=0) + P(I_d=0, I_k=1) + P(I_d=0, I_k=2) + P(I_d=1, I_k=2) $$\n这可以因式分解为：\n$$ P_{\\text{non-retrograde}} = P(I_d=0) \\left[ P(I_k=0) + P(I_k=1) + P(I_k=2) \\right] + P(I_d=1)P(I_k=2) $$\n由于 $\\sum_{i_k=0}^{2} P(I_k=i_k) = 1$，这可以简化为：\n$$ P_{\\text{non-retrograde}} = P(I_d=0) + P(I_d=1)P(I_k=2) $$\n代入计算出的概率：\n$$ P_{\\text{non-retrograde}} = \\frac{8}{27} + \\left(\\frac{12}{27}\\right)\\left(\\frac{1}{4}\\right) = \\frac{8}{27} + \\frac{3}{27} = \\frac{11}{27} $$\n逆行运动的概率为 $P_{\\text{retrograde}} = 1 - P_{\\text{non-retrograde}}$。\n$$ P_{\\text{retrograde}} = 1 - \\frac{11}{27} = \\frac{16}{27} $$\n为了验证，我们可以直接计算总和。逆行运动的状态是所有其他状态：$(1,0), (1,1)$, $(2,0), (2,1), (2,2)$, $(3,0), (3,1), (3,2)$。\n$P(i_d=1) \\left[P(i_k=0)+P(i_k=1)\\right] = \\frac{12}{27}\\left(\\frac{1}{4}+\\frac{2}{4}\\right) = \\frac{12}{27} \\cdot \\frac{3}{4} = \\frac{9}{27}$。\n$P(i_d=2) \\left[P(i_k=0)+P(i_k=1)+P(i_k=2)\\right] = P(i_d=2) \\cdot 1 = \\frac{6}{27}$。\n$P(i_d=3) \\left[P(i_k=0)+P(i_k=1)+P(i_k=2)\\right] = P(i_d=3) \\cdot 1 = \\frac{1}{27}$。\n将这些相加可得：\n$$ P_{\\text{retrograde}} = \\frac{9}{27} + \\frac{6}{27} + \\frac{1}{27} = \\frac{16}{27} $$\n两种方法得出了相同的结果。计算是一致的。", "answer": "$$\\boxed{\\frac{16}{27}}$$", "id": "2699392"}, {"introduction": "理论模型为我们理解单个货物的行为提供了框架，但在实际研究中，我们常常面对的是包含成百上千个货物运动的群体数据，例如速度直方图。这些数据混合了不同类型的运输过程（如慢速组分和快速组分），如何从中分离并量化这些组分是一个关键挑战。这个实践练习 [@problem_id:2699441] 将教会你一种强大的统计分析方法——期望最大化（EM）算法，来拟合混合模型，从而从复杂的实验数据中提取出不同运输群体的特征和比例。", "problem": "给定瞬时轴突货物速度的直方图，单位为微米/秒。这些速度源于轴突运输中的两个机理群体：以慢速组分b (SCb)为特征的慢速、间歇性爆发，以及持续的快速运行。\n\n一个物理上现实且统计上适宜的假设是，严格为正的速度分布为两个对数正态总体的混合，分别对应于一个类SCb的低速组分和一个快速的高速组分。测量得到的直方图在$0.05$和$1.2$微米/秒附近显示出峰值。\n\n仅使用以下基本原理和定义，推导并实现一个通用估计器，用于计算总体中类SCb爆发所占的比例：\n- 观测的独立性允许对似然函数进行因子分解。\n- 混合模型定义指出，一个观测的边缘概率密度是各组分密度的凸组合。\n- 对于正速度$v$，其对数正态概率密度函数（对数空间参数为$(\\mu,\\sigma)$）为 $f_{\\mathrm{LN}}(v\\mid\\mu,\\sigma)=\\dfrac{1}{v\\sigma\\sqrt{2\\pi}}\\exp\\!\\left(-\\dfrac{(\\ln v-\\mu)^{2}}{2\\sigma^{2}}\\right)$，其中 $v>0$。\n- 用于有限混合模型的期望最大化(EM)原理通过在期望步骤中交替计算响应度，并在最大化步骤中最大化期望完全数据对数似然来最大化似然函数；对于高斯族，在自然参数空间中的最大化可简化为加权均值和方差的计算。\n\n您必须将直方图的组中心视为观测值，其整数权重等于直方图的计数。对于一个双组分对数正态混合模型，其中类SCb组分的混合权重为 $\\pi\\in(0,1)$，类SCb速度的对数空间参数为 $(\\mu_{1},\\sigma_{1})$，快速速度的对数空间参数为 $(\\mu_{2},\\sigma_{2})$，请根据第一性原理推导基于加权数据 $(v_{i},w_{i})$ 的EM更新规则。请确保类SCb组分对应于较小的对数均值，即在每次迭代中通过必要时交换标签来强制执行 $\\mu_{1}\\le \\mu_{2}$。初始化参数为 $\\mu_{1}=\\ln 0.05$, $\\mu_{2}=\\ln 1.2$, $\\sigma_{1}=\\sigma_{2}=0.5$ 和 $\\pi=0.5$。使用停止准则：参数变化量的欧几里得范数低于 $10^{-8}$ 或达到最大迭代次数1000次，以先满足者为准。为避免退化解，将 $\\sigma_{1}$ 和 $\\sigma_{2}$ 约束为至少$0.05$。\n\n计算并返回以下每个测试直方图的估计类SCb比例 $\\pi$。每个直方图共享相同的组中心 $v_{i}$ (单位为微米/秒)，但整数计数 $w_{i}$ 不同。速度单位是微米/秒，但您必须只报告估计的比例 $\\pi$，它是无量纲的。将每个 $\\pi$ 报告为四舍五入到三位小数的小数。\n\n组中心 $v_{i}$ (微米/秒):\n$[0.02, 0.03, 0.04, 0.05, 0.065, 0.08, 0.10, 0.15, 0.25, 0.40, 0.60, 0.80, 1.00, 1.20, 1.40, 1.70, 2.00]$。\n\n直方图测试集 (每个列表是与组中心对齐的计数):\n- 案例 A (平衡混合，在$0.05$和$1.2$附近有两个可见峰): $[3, 8, 15, 28, 22, 16, 12, 8, 6, 5, 5, 8, 14, 26, 18, 10, 6]$。\n- 案例 B (SCb主导；低速峰更强): $[6, 14, 28, 45, 30, 20, 14, 8, 5, 3, 2, 3, 4, 6, 4, 3, 2]$。\n- 案例 C (快速组分主导；高速峰更强): $[1, 2, 3, 6, 5, 4, 4, 5, 6, 8, 12, 16, 24, 38, 30, 20, 12]$。\n- 案例 D (数据更稀疏、噪声更大；两个峰都存在但计数很少): $[0, 1, 2, 3, 2, 1, 1, 0, 1, 1, 2, 3, 5, 7, 5, 2, 1]$。\n\n您的程序必须：\n- 实现所述的双组分对数正态混合模型的期望最大化估计器，使用基于直方图计数的加权数据，并通过 $\\mu_{1}\\le\\mu_{2}$ 将类SCb组分定义为低速组分。\n- 将该估计器应用于测试集中的所有四个案例。\n- 生成单行输出，其中包含四个估计的类SCb组分比例，四舍五入到三位小数，格式为方括号内以逗号分隔的列表，例如 $[0.412,0.735,0.113,0.508]$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表 (例如, $[0.412,0.735,0.113,0.508]$)。", "solution": "该问题要求推导并实现一个期望最大化(EM)算法，以估计一个双组分对数正态混合模型的混合比例 $\\pi$。该模型描述了轴突货物速度的分布，这些速度以直方图数据的形式提供。数据表示为组中心 $(v_i)$ 和计数 $(w_i)$ 的数据对。分析必须从第一性原理推导。\n\n设混合模型的两个组分分别用 $k=1$ (类SCb，慢速) 和 $k=2$ (快速) 表示。模型参数为 $\\theta = (\\pi, \\mu_1, \\sigma_1, \\mu_2, \\sigma_2)$，其中 $\\pi$ 是组分1的混合比例，$(\\mu_k, \\sigma_k)$ 是组分$k$的速度对数的均值和标准差。对数正态分布的概率密度函数(PDF)如下：\n$$ f_{\\mathrm{LN}}(v \\mid \\mu, \\sigma) = \\frac{1}{v\\sigma\\sqrt{2\\pi}} \\exp\\left(-\\frac{(\\ln v - \\mu)^2}{2\\sigma^2}\\right) $$\n观测值 $v$ 的总概率密度是这两个组分的混合：\n$$ p(v \\mid \\theta) = \\pi f_{\\mathrm{LN}}(v \\mid \\mu_1, \\sigma_1) + (1-\\pi) f_{\\mathrm{LN}}(v \\mid \\mu_2, \\sigma_2) $$\n数据以直方图形式提供，我们将其视为 $M$ 个不同的速度值 $v_i$，每个值被观测了 $w_i$ 次。总观测数为 $N = \\sum_{i=1}^M w_i$。观测数据的对数似然为：\n$$ \\mathcal{L}(\\theta) = \\ln \\prod_{i=1}^M [p(v_i \\mid \\theta)]^{w_i} = \\sum_{i=1}^M w_i \\ln\\left[ \\pi f_{\\mathrm{LN}}(v_i \\mid \\mu_1, \\sigma_1) + (1-\\pi) f_{\\mathrm{LN}}(v_i \\mid \\mu_2, \\sigma_2) \\right] $$\n由于对数函数内部存在加法，直接最大化 $\\mathcal{L}(\\theta)$ 很复杂。EM算法通过引入隐变量来规避这个问题。设 $z_{ik}$ 为一个指示变量，如果来自组$i$的一个观测属于组分$k$，则其值为1，否则为0。\n\n假设隐变量的值已知，完全数据对数似然为：\n$$ \\mathcal{L}_c(\\theta; v, w, z) = \\sum_{i=1}^M w_i \\sum_{k=1}^2 z_{ik} \\ln \\left[ \\pi_k f_{\\mathrm{LN}}(v_i \\mid \\mu_k, \\sigma_k) \\right] $$\n$$ = \\sum_{i=1}^M w_i \\sum_{k=1}^2 z_{ik} \\left( \\ln(\\pi_k) + \\ln(f_{\\mathrm{LN}}(v_i \\mid \\mu_k, \\sigma_k)) \\right) $$\n其中 $\\pi_1 = \\pi$ 且 $\\pi_2 = 1-\\pi$。\n\nEM算法是一个包含两个步骤的迭代过程：\n\n**E-Step (期望步):**\n在此步骤中，我们计算完全数据对数似然的期望值，该期望值以观测数据$v$和当前参数估计$\\theta^{(t)}$为条件。这等价于计算观测$v_i$属于组分$k$的后验概率，也称为响应度$\\gamma_{ik}$。\n$$ \\gamma_{ik} = E[z_{ik} \\mid v_i, \\theta^{(t)}] = P(k \\mid v_i, \\theta^{(t)}) = \\frac{p(v_i \\mid k, \\theta^{(t)}) P(k \\mid \\theta^{(t)})}{p(v_i \\mid \\theta^{(t)})} $$\n代入模型定义：\n$$ \\gamma_{i1}^{(t+1)} = \\frac{\\pi^{(t)} f_{\\mathrm{LN}}(v_i \\mid \\mu_1^{(t)}, \\sigma_1^{(t)})}{\\pi^{(t)} f_{\\mathrm{LN}}(v_i \\mid \\mu_1^{(t)}, \\sigma_1^{(t)}) + (1-\\pi^{(t)}) f_{\\mathrm{LN}}(v_i \\mid \\mu_2^{(t)}, \\sigma_2^{(t)})} $$\n且 $\\gamma_{i2}^{(t+1)} = 1 - \\gamma_{i1}^{(t+1)}$。在M步中需要最大化的函数，即Q函数，是$\\mathcal{L}_c$在这些响应度下的期望：\n$$ Q(\\theta \\mid \\theta^{(t)}) = \\sum_{i=1}^M w_i \\sum_{k=1}^2 \\gamma_{ik}^{(t+1)} \\left[ \\ln(\\pi_k) + \\ln(f_{\\mathrm{LN}}(v_i \\mid \\mu_k, \\sigma_k)) \\right] $$\n\n**M-Step (最大化步):**\n在此步骤中，我们找到使Q函数最大化的参数$\\theta^{(t+1)}$。我们可以独立地对$\\pi_k$和$(\\mu_k, \\sigma_k)$进行优化。\n\n1.  **更新$\\pi_k$**: 我们最大化$\\sum_{i=1}^M w_i \\sum_{k=1}^2 \\gamma_{ik}^{(t+1)} \\ln(\\pi_k)$，约束条件为$\\sum_k \\pi_k = 1$。使用拉格朗日乘子，可以得到一个直观的结果：组分$k$的新混合比例是该组分在所有观测上的平均响应度：\n    $$ \\pi_k^{(t+1)} = \\frac{\\sum_{i=1}^M w_i \\gamma_{ik}^{(t+1)}}{\\sum_{i=1}^M w_i} = \\frac{\\sum_{i=1}^M w_i \\gamma_{ik}^{(t+1)}}{N} $$\n    对于$k=1$，得到$\\pi$的更新公式：$\\pi^{(t+1)} = \\frac{\\sum_i w_i \\gamma_{i1}^{(t+1)}}{N}$。\n\n2.  **更新$\\mu_k$和$\\sigma_k$**: 我们必须最大化涉及对数正态PDF的项。处理对数变换后的速度$x_i = \\ln(v_i)$会更简单。如果$v$服从参数为$(\\mu, \\sigma)$的对数正态分布，那么$x = \\ln(v)$服从均值为$\\mu$、标准差为$\\sigma$的正态分布。对于每个组分$k$需要最大化的项是：\n    $$ \\sum_{i=1}^M w_i \\gamma_{ik}^{(t+1)} \\ln(f_{\\mathrm{LN}}(v_i \\mid \\mu_k, \\sigma_k)) = \\sum_{i=1}^M w_i \\gamma_{ik}^{(t+1)} \\left[ -\\ln(v_i) - \\ln(\\sigma_k) - \\frac{1}{2}\\ln(2\\pi) - \\frac{(\\ln(v_i) - \\mu_k)^2}{2\\sigma_k^2} \\right] $$\n    对此式关于$\\mu_k$和$\\sigma_k$进行最大化，等价于对一个正态分布进行加权最大似然估计，其数据点为$x_i = \\ln(v_i)$，权重为$w_i \\gamma_{ik}^{(t+1)}$。其众所周知的解是加权均值和加权标准差。\n    设 $W_k = \\sum_{i=1}^M w_i \\gamma_{ik}^{(t+1)}$ 为组分$k$的有效总权重。\n    $$ \\mu_k^{(t+1)} = \\frac{1}{W_k} \\sum_{i=1}^M w_i \\gamma_{ik}^{(t+1)} \\ln(v_i) $$\n    $$ (\\sigma_k^{(t+1)})^2 = \\frac{1}{W_k} \\sum_{i=1}^M w_i \\gamma_{ik}^{(t+1)} (\\ln(v_i) - \\mu_k^{(t+1)})^2 $$\n\n**算法总结:**\n1.  **初始化**: 设置初始参数 $\\theta^{(0)} = (\\pi^{(0)}, \\mu_1^{(0)}, \\sigma_1^{(0)}, \\mu_2^{(0)}, \\sigma_2^{(0)})$，按题目给定：$\\pi^{(0)}=0.5$, $\\mu_1^{(0)}=\\ln(0.05)$, $\\mu_2^{(0)}=\\ln(1.2)$, $\\sigma_1^{(0)}=0.5$, $\\sigma_2^{(0)}=0.5$。\n2.  **迭代**: 对于$t=0, 1, 2, \\dots$直到收敛：\n    a.  **E-Step**: 使用上面推导的公式和参数$\\theta^{(t)}$，计算所有$i=1, \\dots, M$的响应度$\\gamma_{i1}^{(t+1)}$和$\\gamma_{i2}^{(t+1)}$。为保证数值稳定性，最好在对数空间中使用log-sum-exp技巧进行计算，以避免下溢/上溢。\n    b.  **M-Step**: 使用上面推导的加权数据更新规则，更新参数至$\\theta^{(t+1)}$。\n    c.  **约束**: 应用所需的约束。强制$\\sigma_k^{(t+1)} \\ge 0.05$。为保持慢速和快速组分的身份，强制$\\mu_1^{(t+1)} \\le \\mu_2^{(t+1)}$。如果违反此条件，则交换参数$(\\mu_1, \\sigma_1)$与$(\\mu_2, \\sigma_2)$，并将$\\pi$更新为$1-\\pi$。\n    d.  **收敛性检查**: 计算参数向量变化的欧几里得范数$\\| \\theta^{(t+1)} - \\theta^{(t)} \\|_2$。如果范数小于$10^{-8}$，或者迭代次数超过1000次，则终止算法。\n\n最终估计的$\\pi$值即为每个直方图案例的结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the estimation process for all test cases.\n    \"\"\"\n    v = np.array([\n        0.02, 0.03, 0.04, 0.05, 0.065, 0.08, 0.10, 0.15, 0.25, 0.40,\n        0.60, 0.80, 1.00, 1.20, 1.40, 1.70, 2.00\n    ])\n\n    test_cases = [\n        # Case A: balanced mixture\n        np.array([3, 8, 15, 28, 22, 16, 12, 8, 6, 5, 5, 8, 14, 26, 18, 10, 6]),\n        # Case B: SCb-dominated\n        np.array([6, 14, 28, 45, 30, 20, 14, 8, 5, 3, 2, 3, 4, 6, 4, 3, 2]),\n        # Case C: fast-dominated\n        np.array([1, 2, 3, 6, 5, 4, 4, 5, 6, 8, 12, 16, 24, 38, 30, 20, 12]),\n        # Case D: sparse, noisy data\n        np.array([0, 1, 2, 3, 2, 1, 1, 0, 1, 1, 2, 3, 5, 7, 5, 2, 1])\n    ]\n\n    results = []\n    for w in test_cases:\n        pi_estimate = estimate_mixture_fraction(v, w)\n        # Round to three decimal places as specified\n        results.append(f\"{pi_estimate:.3f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef estimate_mixture_fraction(v, w):\n    \"\"\"\n    Implements the EM algorithm to estimate the mixture fraction pi.\n    \n    Args:\n        v (np.ndarray): Array of velocity bin centers.\n        w (np.ndarray): Array of histogram counts for each bin.\n        \n    Returns:\n        float: The estimated mixture fraction pi for the SCb component.\n    \"\"\"\n    # Filter out bins with zero counts\n    non_zero_indices = w > 0\n    v = v[non_zero_indices]\n    w = w[non_zero_indices]\n    \n    # Pre-compute log-velocities and total count\n    x = np.log(v)\n    total_w = np.sum(w)\n\n    # Initialization\n    pi = 0.5\n    mu1 = np.log(0.05)\n    mu2 = np.log(1.2)\n    sigma1 = 0.5\n    sigma2 = 0.5\n\n    # Hyperparameters\n    max_iter = 1000\n    tolerance = 1e-8\n    sigma_min = 0.05\n\n    params = np.array([pi, mu1, sigma1, mu2, sigma2])\n\n    for _ in range(max_iter):\n        # --- E-Step ---\n        # Calculate log-probabilities for numerical stability\n        log_pdf1 = -np.log(sigma1) - 0.5 * ((x - mu1) / sigma1)**2\n        log_pdf2 = -np.log(sigma2) - 0.5 * ((x - mu2) / sigma2)**2\n        \n        # Add a small constant to prevent log(0) if pi is at the boundary\n        log_pi1 = np.log(pi + 1e-15)\n        log_pi2 = np.log(1.0 - pi + 1e-15)\n\n        log_numerator1 = log_pi1 + log_pdf1\n        log_numerator2 = log_pi2 + log_pdf2\n\n        # Use log-sum-exp trick for stable denominator calculation\n        max_log = np.maximum(log_numerator1, log_numerator2)\n        log_denominator = max_log + np.log(np.exp(log_numerator1 - max_log) + np.exp(log_numerator2 - max_log))\n        \n        # Responsibilities (gamma values)\n        gamma1 = np.exp(log_numerator1 - log_denominator)\n        gamma2 = 1.0 - gamma1\n\n        # --- M-Step ---\n        # Effective weights for each component\n        W1 = np.sum(w * gamma1)\n        W2 = np.sum(w * gamma2)\n\n        # If a component vanishes, stop to avoid division by zero\n        if W1  1e-9 or W2  1e-9:\n            break\n\n        # Update parameters\n        pi = W1 / total_w\n        mu1 = np.sum(w * gamma1 * x) / W1\n        mu2 = np.sum(w * gamma2 * x) / W2\n        \n        # Use updated means for variance calculation\n        sigma1_sq = np.sum(w * gamma1 * (x - mu1)**2) / W1\n        sigma2_sq = np.sum(w * gamma2 * (x - mu2)**2) / W2\n        \n        sigma1 = np.sqrt(sigma1_sq)\n        sigma2 = np.sqrt(sigma2_sq)\n\n        # --- Apply Constraints ---\n        sigma1 = max(sigma1, sigma_min)\n        sigma2 = max(sigma2, sigma_min)\n\n        # Enforce mu1 = mu2 to maintain component identity\n        if mu1 > mu2:\n            mu1, mu2 = mu2, mu1\n            sigma1, sigma2 = sigma2, sigma1\n            pi = 1.0 - pi\n            \n        # --- Convergence Check ---\n        params_new = np.array([pi, mu1, sigma1, mu2, sigma2])\n        if np.linalg.norm(params_new - params)  tolerance:\n            break\n        params = params_new\n        \n    return pi\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "2699441"}]}