{"hands_on_practices": [{"introduction": "在临床免疫学中，评估诊断测试的性能至关重要。此练习提供了一个将贝叶斯定理应用于解读IV型超敏反应诊断测试（例如斑贴试验）的实践机会。通过计算阳性预测值（PPV），您将学会如何量化评估阳性测试结果在特定人群中的真正临床意义。[@problem_id:2904769]", "problem": "一家皮肤科诊所正在评估一种用于诊断由1型辅助T细胞（Th1）介导的对特定接触性过敏原的迟发型超敏反应（DTH）的斑贴试验。该斑贴试验在48-72小时后进行判读，如果在施用部位出现特征性的湿疹样反应，则认为结果为阳性，这反映了皮肤中抗原特异性记忆T细胞的活化。在一个疑似接触性皮炎的目标门诊人群中，真实过敏原致敏的患病率为$0.10$。先前的验证性研究报告称，对于这种过敏原，该试验的敏感性为$0.85$，特异性为$0.95$。请仅使用概率论中敏感性、特异性、患病率和贝叶斯定理的核心定义，推导出计算该试验在该人群中阳性预测值（PPV）所需的表达式，然后计算该PPV。最后，用一句话陈述该PPV在此DTH背景下解释阳性斑贴试验的临床意义。将最终的PPV表示为小数，并四舍五入至四位有效数字。", "solution": "在尝试解答之前，对问题陈述进行验证。\n\n首先，逐字提取已知条件：\n- 真实过敏原致敏的患病率为$0.10$。\n- 试验敏感性为$0.85$。\n- 试验特异性为$0.95$。\n- 任务是推导阳性预测值（PPV）的表达式，计算其值，并陈述其临床意义。\n- 最终数值答案必须是四舍五入到四位有效数字的小数。\n\n其次，根据所需标准对问题进行验证。该问题具有科学依据，因为它描述了诊断免疫学中关于迟发型超敏反应（DTH）的标准场景，并使用了正确的术语和现实的参数。患病率、敏感性、特异性和阳性预测值的概念是生物统计学和流行病学中的基本原则。该问题提法得当；它提供了使用贝叶斯定理计算唯一且有意义的解所需的所有数据。它客观且没有歧义、矛盾或逻辑缺陷。因此，该问题被认为是有效的，并将提供解答。\n\n为了推导阳性预测值（PPV）的表达式，我们必须首先用概率术语定义相关事件。\n设$D$为患者真实存在过敏原致敏（“患病”）的事件。\n设$D^c$为患者没有真实存在过敏原致敏的事件。\n设$T^+$为斑贴试验结果为阳性的事件。\n设$T^-$为斑贴试验结果为阴性的事件。\n\n根据问题陈述，我们将给定信息转化为条件概率：\n- 患病率是具有致敏性的先验概率：$P(D) = 0.10$。\n- 敏感性是在患者致敏的情况下测试结果为阳性的概率（真阳性）：$P(T^+ | D) = 0.85$。\n- 特异性是在患者未致敏的情况下测试结果为阴性的概率（真阴性）：$P(T^- | D^c) = 0.95$。\n\n阳性预测值（PPV）是在测试结果为阳性的情况下，患者确实致敏的概率。这是条件概率$P(D | T^+)$。\n\n使用贝叶斯定理，PPV的表达式为：\n$$ \\text{PPV} = P(D | T^+) = \\frac{P(T^+ | D) P(D)}{P(T^+)} $$\n\n分母$P(T^+)$是测试结果为阳性的总概率，可以使用全概率定律求得。阳性测试结果可能以两种互斥的方式发生：真阳性（患者致敏且测试为阳性）或假阳性（患者未致敏但测试为阳性）。\n$$ P(T^+) = P(T^+ \\cap D) + P(T^+ \\cap D^c) $$\n$$ P(T^+) = P(T^+ | D) P(D) + P(T^+ | D^c) P(D^c) $$\n\n我们需要确定$P(D^c)$和$P(T^+ | D^c)$这两项。\n未致敏的概率是患病率的补集：\n$$ P(D^c) = 1 - P(D) = 1 - 0.10 = 0.90 $$\n在未致敏患者中测试结果为阳性的概率$P(T^+ | D^c)$是假阳性率。它是特异性（真阴性率）的补集：\n$$ P(T^+ | D^c) = 1 - P(T^- | D^c) = 1 - 0.95 = 0.05 $$\n\n现在，我们将这些表达式代回$P(T^+)$的公式中：\n$$ P(T^+) = (0.85)(0.10) + (0.05)(0.90) $$\n\n最后，我们将$P(T^+)$的完整表达式代入PPV的贝叶斯定理公式中。这提供了问题所要求的完整推导表达式：\n$$ \\text{PPV} = P(D | T^+) = \\frac{P(T^+ | D) P(D)}{P(T^+ | D) P(D) + P(T^+ | D^c) P(D^c)} $$\n\n现在，我们通过代入给定的概率来计算其数值：\n$$ \\text{PPV} = \\frac{(0.85)(0.10)}{(0.85)(0.10) + (0.05)(0.90)} $$\n$$ \\text{PPV} = \\frac{0.085}{0.085 + 0.045} $$\n$$ \\text{PPV} = \\frac{0.085}{0.130} $$\n$$ \\text{PPV} \\approx 0.65384615... $$\n\n四舍五入到四位有效数字，阳性预测值为$0.6538$。\n\n该阳性预测值的临床意义是，对于该门诊人群中斑贴试验呈阳性的患者，其真实存在过敏原致敏的概率仅为$65.38\\%$，这表明有相当一部分阳性结果（约$35\\%$）是假阳性。", "answer": "$$\\boxed{0.6538}$$", "id": "2904769"}, {"introduction": "IV型超敏反应的“迟发”特性是其核心特征，但这究竟意味着什么？本练习将引导您运用生物物理学原理，估算趋化因子在组织内扩散所需的时间。通过将这个物理时间尺度与整个免疫反应的生物学时间尺度进行比较，您将能深刻理解决定DTH反应速率的关键限制性步骤。[@problem_id:2904780]", "problem": "迟发型超敏反应（DTH）是由T淋巴细胞在常驻细胞和浸润细胞产生的趋化因子梯度引导下，募集到抗原攻击部位所驱动的。考虑一个简化的、一维、均匀、各向同性的皮肤组织间隙环境，其中没有对流，结合作用可忽略不计。从菲克第二扩散定律 $\\frac{\\partial C}{\\partial t} = D \\frac{\\partial^{2} C}{\\partial x^{2}}$ 出发，并根据一个经过充分验证的观察——即对于从局部源扩散的情况，均方位移随时间线性增长——推导出一个趋化因子仅通过一维扩散探索距离 $L$ 所需的特征时间尺度 $t$ 的表达式。然后，对于在组织间隙中扩散系数为 $D = 100\\,\\mu\\text{m}^{2}\\!/\\text{s}$ 的小分子趋化因子，估算探索距离 $L = 500\\,\\mu\\text{m}$ 所需的时间。\n\n最后，利用关于迟发型超敏反应的核心免疫学知识，简要说明仅趋化因子扩散是否可能是DTH反应（通常在数十小时的量级上出现）发生的速率限制步骤。\n\n仅报告您计算出的扩散时间的数值，以分钟为单位表示，并将您的答案四舍五入到三位有效数字。报告值使用分钟作为单位。在最终的方框答案中不要包含任何单位。", "solution": "所述问题具有科学依据，提法恰当且客观。它基于扩散的基本原理和免疫学中已确立的概念。所有必需的信息都已提供。因此，该问题是有效的，我们将着手解决它。\n\n该问题要求完成三项任务：首先，推导扩散一段距离 $L$ 的特征时间尺度；其次，为给定的趋化因子计算这个时间；第三，将此时间尺度置于迟发型超敏反应（DTH）的已知生物学背景中进行分析。\n\n分析始于扩散与扩散粒子均方位移（MSD）之间的关系。问题正确地指出，对于从局部源的扩散，MSD随时间线性增长。对于一维扩散，这种关系，即著名的爱因斯坦关系式，由下式给出：\n$$\n\\langle x^2(t) \\rangle = 2Dt\n$$\n其中 $\\langle x^2(t) \\rangle$ 是在时间 $t$ 时的均方位移，而 $D$ 是扩散系数。一个粒子“探索”距离 $L$ 所需的特征时间 $t$ 可以定义为均方根（RMS）位移 $\\sqrt{\\langle x^2(t) \\rangle}$ 等于 $L$ 的时间。\n\n将RMS位移设为等于距离 $L$：\n$$\n\\sqrt{\\langle x^2(t) \\rangle} = L\n$$\n代入爱因斯坦关系式：\n$$\n\\sqrt{2Dt} = L\n$$\n为了求解特征时间 $t$，我们将方程两边平方：\n$$\n2Dt = L^2\n$$\n这就给出了一维特征扩散时间 $t$ 的表达式：\n$$\nt = \\frac{L^2}{2D}\n$$\n这就是所要求的一般表达式。\n\n接下来，我们必须根据所提供的具体参数计算这个时间。给定的扩散系数为 $D = 100\\,\\mu\\text{m}^{2}\\!/\\text{s}$，要探索的距离为 $L = 500\\,\\mu\\text{m}$。我们将这些值代入我们推导出的公式中：\n$$\nt = \\frac{(500\\,\\mu\\text{m})^2}{2 \\times (100\\,\\mu\\text{m}^{2}\\!/\\text{s})} = \\frac{250000\\,\\mu\\text{m}^2}{200\\,\\mu\\text{m}^{2}\\!/\\text{s}}\n$$\n单位 $\\mu\\text{m}^2$ 消去，时间单位剩下秒：\n$$\nt = \\frac{2500}{2}\\,\\text{s} = 1250\\,\\text{s}\n$$\n问题要求答案以分钟表示。一分钟有 $60$ 秒，因此我们进行单位转换：\n$$\nt_{\\text{min}} = \\frac{1250\\,\\text{s}}{60\\,\\text{s/min}} = \\frac{125}{6}\\,\\text{min} \\approx 20.833... \\,\\text{min}\n$$\n按照要求，四舍五入到三位有效数字，得到 $20.8$ 分钟。\n\n最后，我们必须评估趋化因子扩散是否为DTH反应发生的速率限制步骤。计算出的扩散时间尺度约为 $20.8$ 分钟，即大约三分之一小时。DTH反应，如结核菌素皮肤试验，其典型特征是在更长的时间段内显现，通常在抗原暴露后 $48$ 到 $72$ 小时达到高峰。趋化因子扩散的时间尺度比整个DTH反应的时间尺度小几个数量级 ($20.8\\,\\text{min} \\ll 48\\,\\text{h}$)。\n\n因此，与协调DTH反应的生物学过程相比，趋化因子在亚毫米级组织距离上的纯物理扩散过程是极其迅速的。速率限制步骤完全是生物学性质的，包括：\n$1$. 抗原呈递细胞（例如，Langerhans细胞，真皮树突状细胞）从皮肤迁移到引流淋巴结。\n$2$. 在淋巴结中对抗原进行加工并呈递给初始T淋巴细胞。\n$3$. 抗原特异性辅助T细胞（Th1细胞）的活化和克隆扩增，这个过程需要数天。\n$4$. 这些新生成的效应T细胞从淋巴结出发，通过循环系统，进入炎症组织部位的运输过程。\n$5$. 这些T细胞随后在局部被再次活化，并通过释放细胞因子（例如，IFN-$\\gamma$）来协调炎症反应，从而导致巨噬细胞的募集和活化。\n\n这些细胞层面的每一个过程都在数小时到数天的时间尺度上运作。通过扩散快速建立趋化因子梯度是反应的一个必要但不充分的条件，并且绝不是速率限制因素。“迟发型”超敏反应中的“迟发”是细胞免疫应答发展和动员所需时间的直接结果。", "answer": "$$\n\\boxed{20.8}\n$$", "id": "2904780"}, {"introduction": "现代免疫学越来越依赖计算模型来整合复杂的细胞相互作用。这项高级练习将挑战您从第一性原理出发，构建一个接触性超敏反应的智能体模型（Agent-Based Model）。通过将免疫学规则转化为计算算法，您将亲身体验细胞间的局部互动如何涌现出宏观的组织损伤，从而获得对DTH病理发生机制的系统级动态理解。[@problem_id:2904755]", "problem": "您需要实现一个接触性超敏反应的最小化基于智能体的模拟。这是一种皮肤微观解剖结构中的迟发型细胞介导反应，其中表皮角质形成细胞的损伤由携带抗原的树突状细胞、募集的T淋巴细胞和巨噬细胞之间的相互作用所引起。此模拟必须根据与既定免疫学一致的第一性原理构建：抗原暴露会引起受损角质形成细胞发出危险信号，树突状细胞活化并迁移至淋巴结，经过一段延迟后，效应T细胞返回组织，激活巨噬细胞，并加剧角质形成细胞的损伤。\n\n您的程序必须执行一个基于这些核心生物学基础的离散时间、二维的基于智能体的模型，不得依赖任何特定领域的“黑箱”公式。请使用以下基本依据和核心定义作为您模型设计的起点：\n\n- 细胞智能体占据一个二维网格，并根据局部相互作用和随机运动性进行随机的状态改变和移动；此类规则通过随机游走和依赖于邻域的转移概率，在微观时间尺度上近似模拟扩散和趋化性。\n- 树突状细胞在淋巴结中向T细胞呈递抗原；效应T细胞的扩增和返回组织相对于初始暴露有延迟，这是IV型迟发型超敏反应的特征。\n- 1型辅助T效应细胞产生干扰素-γ并激活巨噬细胞；被激活的巨噬细胞通过炎症效应功能介导对角质形成细胞的附带组织损伤。\n- 局部相互作用速率可以建模为每时间步的伯努利过程，其概率源自类似质量作用定律的对邻居数量的依赖性。\n\n请完全按照规定实现以下模型、参数和规则。\n\n状态空间与几何结构：\n- 使用大小为 $N \\times N$ 的方形网格，其中 $N = 20$。索引为整数，$x \\in \\{0,\\dots,N-1\\}$ 且 $y \\in \\{0,\\dots,N-1\\}$。\n- 表皮占据行 $y \\in \\{0,\\dots,N_{e}-1\\}$，真皮占据行 $y \\in \\{N_{e},\\dots,N-1\\}$，其中 $N_{e} = \\lfloor N/2 \\rfloor = 10$。\n- 角质形成细胞隐式地存在于表皮网格位置，并具有一个二元损伤状态 $K(y,x,t) \\in \\{0,1\\}$，其中 $1$ 表示在时间步 $t$ 时受损。\n- 树突状细胞、T细胞和巨噬细胞是显式智能体，其整数网格位置 $(x,y)$ 在所有时间内都限制在真皮中，即 $y \\geq N_{e}$。\n\n时间与初始化：\n- 模拟离散时间步 $t = 0,1,2,\\dots,T_{\\text{end}}-1$，其中 $T_{\\text{end}} = 72$。\n- 延迟效应阶段始于 $t = \\tau_{\\text{sens}}$，其中 $\\tau_{\\text{sens}} = 24$。\n- 在 $t=0$ 时，施加一个以 $(x_{c},y_{c}) = (\\lfloor N/2 \\rfloor,\\lfloor N_{e}/2 \\rfloor)$ 为中心、半径为 $R(d) = 2 + \\lfloor d \\rfloor$ 的圆形半抗原贴片，其中 $d$ 是来自测试套件的半抗原剂量参数。欧几里得距离中心 $\\leq R(d)$ 的每个角质形成细胞 $(y,x)$ 以概率 $p_{0}(d) = 1 - e^{-\\alpha d}$ 独立受损，其中 $\\alpha = 0.5$。\n- 初始化 $N_{\\text{DC}} = 40$ 个树突状细胞智能体，位于 $y \\in \\{N_{e},N_{e}+1,N_{e}+2\\}$ 和 $x \\in \\{0,\\dots,N-1\\}$ 的均匀随机真皮位置，全部处于静息状态。\n- 初始化 $N_{\\text{M}} = 60$ 个巨噬细胞智能体，位于 $y \\in \\{N_{e},\\dots,N-1\\}$ 和 $x \\in \\{0,\\dots,N-1\\}$ 的均匀随机真皮位置，全部处于静息状态。\n- 在 $t=0$ 时初始化零个T细胞。效应T细胞将如下文所述在 $t=\\tau_{\\text{sens}}$ 时引入。\n\n随机性与可复现性：\n- 使用伪随机数生成器，并为每个测试用例设置确定性种子：种子必须是 $12345 + i$，其中 $i$ 是所提供测试套件中测试用例的零基索引。一个测试用例中的所有随机抽取必须源自此种子。\n\n每时间步规则：\n- 树突状细胞的活化与迁移：\n  - 对于每个位于位置 $(x,y)$ 且 $y \\geq N_{e}$ 的树突状细胞，将其表皮接触邻域定义为基底层表皮行 $y^{*} = N_{e}-1$ 处的列 $x + \\Delta x$，其中 $\\Delta x \\in \\{-1,0,1\\}$，并限制在网格边界内。令 $n_{d}(t)$ 为在时间 $t$ 这些位置中受损角质形成细胞的数量。\n  - 一个静息的树突状细胞在时间 $t$ 以概率 $p_{\\text{act}}(t) = 1 - e^{-\\beta n_{d}(t)}$ 被激活，其中 $\\beta = 0.25$。\n  - 一个已激活的树突状细胞尝试向底部边界的淋巴出口迁移。在每个时间步，它以概率 $m$（一个测试用例参数）向 $(x, y+1)$ 移动一个网格步，如果 $y  N-1$。如果 $y = N-1$，则它以概率 $m$ 离开组织并被移除，且已离开的树突状细胞计数 $E(t)$ 增加 $1$。如果由于伯努利试验结果它没有移动，则在该步骤中停留在原地。\n  - 一个静息的树突状细胞以概率 $p_{\\text{jitter}} = 0.3$ 进行随机抖动，即以均匀随机的方式移动到真皮中的一个 $3 \\times 3$ 摩尔邻域（切比雪夫步长最多为 $1$）；否则，它保持在原地。所有位置必须被限制以保持在真皮内 ($y \\geq N_{e}$) 。\n- 效应T细胞的募集：\n  - 在 $t = \\tau_{\\text{sens}}$ 时，引入 $N_{\\text{T}}(\\tau_{\\text{sens}}) = \\left\\lfloor 0.5 + k_{T} \\cdot E(\\tau_{\\text{sens}}) \\right\\rfloor$ 个效应T细胞，位于均匀随机的真皮位置，其中 $k_{T} = 0.8$，而 $E(\\tau_{\\text{sens}})$ 是截至并包括时间 $\\tau_{\\text{sens}}$ 时已离开的树突状细胞的累积数量。在 $t = \\tau_{\\text{sens}}$ 之后不再引入额外的T细胞。\n  - 对于所有 $t \\geq \\tau_{\\text{sens}}$，每个T细胞执行简单的随机游走：在每个步骤中，它移动到真皮中一个均匀选择的摩尔邻域（切比雪夫步长最多为 $1$），并进行网格限制以强制 $y \\geq N_{e}$。\n- 巨噬细胞的活化与角质形成细胞损伤的放大：\n  - 对于所有 $t \\geq \\tau_{\\text{sens}}$，任何切比雪夫距离 $\\leq 1$ 内至少有一个T细胞的巨噬细胞会被激活，并在此后保持激活状态。\n  - 每个已激活的巨噬细胞在每时间步独立尝试损伤一个表皮角质形成细胞。它从可用选项中以等概率选择一个目标表皮位点 $(x',y')$，其中 $x' \\in \\{x-1,x,x+1\\}$（限制在网格边界内），$y' \\in \\{N_{e}-2,N_{e}-1\\}$（限制在 $\\{0,\\dots,N_{e}-1\\}$ 内）。如果该角质形成细胞尚未受损，它会以概率 $p_{K} = \\min(1,c)$ 受损，其中 $c$ 是测试用例的T细胞-巨噬细胞相互作用强度参数。\n\n输出可观测量：\n- 损伤大小定义为模拟结束时受损角质形成细胞的总数，即 $L = \\sum_{y=0}^{N_{e}-1} \\sum_{x=0}^{N-1} K(y,x,T_{\\text{end}})$，这是一个整数计数。\n\n无输入执行与测试套件：\n- 您的程序必须在没有任何输入的情况下运行，并且必须为以下每个测试用例执行模拟，其中每个测试用例是一个三元组 $(d,m,c)$：\n  - 用例 $0$：$(d,m,c) = (1.5,0.6,0.4)$。\n  - 用例 $1$：$(d,m,c) = (0.0,0.8,0.7)$。\n  - 用例 $2$：$(d,m,c) = (3.0,0.9,0.9)$。\n  - 用例 $3$：$(d,m,c) = (1.5,0.1,0.9)$。\n- 对于每个用例 $i \\in \\{0,1,2,3\\}$，使用指定的参数运行模型，使用随机种子 $12345 + i$，并计算 $L_{i}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含以逗号分隔并用方括号括起来的结果列表，损伤大小按用例顺序排列，即确切的字符串格式必须是 $[L_{0},L_{1},L_{2},L_{3}]$，其中每个 $L_{i}$ 是以十进制数字书写的整数，无空格。", "solution": "问题陈述已经过严格验证，被认为是有效的。它为迟发型超敏反应的基于智能体的模型提供了一个完整、自洽且科学上合理的规范。所有参数、初始条件和动态规则都已明确定义，从而允许一个唯一且可复现的计算解决方案。该模型虽然是一种简化，但其基础是既定的免疫学原理：危险信号、树突状细胞的抗原呈递、T细胞的延迟克隆扩增以及巨噬细胞介导的效应功能。问题是适定且客观的。我们现在开始进行求解。\n\n问题的核心是构建一个离散时间、二维的基于智能体的模拟。我们将通过定义状态空间以及控制智能体和环境随时间演化的动态规则来设计此模拟，并严格遵守所提供的规范。\n\n**1. 状态空间表示**\n\n系统在任何时间步 $t$ 的状态由其各组成部分的状态定义：代表皮肤组织的网格和移动细胞智能体的种群。\n\n-   **皮肤网格**：组织是一个 $N \\times N$ 的网格，其中 $N=20$。它被划分为表皮（$y \\in \\{0, \\dots, N_e-1\\}$）和真皮（$y \\in \\{N_e, \\dots, N-1\\}$），其中 $N_e = \\lfloor N/2 \\rfloor = 10$。\n    -   **角质形成细胞损伤**：表皮的状态由一个大小为 $N_e \\times N$ 的二维整数数组 $K$ 表示。元素 $K(y,x,t) = 1$ 表示在时间 $t$ 位置 $(x,y)$ 的角质形成细胞受损，而 $K(y,x,t) = 0$ 表示其未受损。\n\n-   **细胞智能体**：树突状细胞 (DCs)、T细胞和巨噬细胞被表示为独立的智能体。对于这种规模的模拟，为每种细胞类型使用一个数据结构列表（例如，Python字典）是高效的。每个智能体的状态至少包括其位置 $(x,y)$ 和一个激活状态。\n    -   **树突状细胞 (DCs)**：一个包含 $N_{DC} = 40$ 个智能体的列表，每个智能体由其在真皮中的位置 $(x,y)$（$y \\ge N_e$）及其状态（静息或激活）定义。\n    -   **T细胞**：一个最初为空的智能体列表。每个智能体由其在真皮中的位置 $(x,y)$ 定义。\n    -   **巨噬细胞 (Ms)**：一个包含 $N_M = 60$ 个智能体的列表，每个智能体由其固定的真皮位置 $(x,y)$ 及其状态（静息或激活）定义。\n\n-   **全局变量**：\n    -   $E(t)$：到时间 $t$ 为止已离开组织的DCs的累积计数。\n\n**2. 初始化 (时间 $t=0$)**\n\n模拟开始时，根据问题规则设置初始状态。为确保可复现性，使用特定种子 $12345 + i$（其中 $i$ 是测试用例的索引）来初始化伪随机数生成器 (PRNG)。\n\n-   **初始角质形成细胞损伤**：创建一个圆形的初始损伤区域。中心为 $(x_c, y_c) = (\\lfloor N/2 \\rfloor, \\lfloor N_e/2 \\rfloor) = (10, 5)$。半径为 $R(d) = 2 + \\lfloor d \\rfloor$。对于此半径内的每个角质形成细胞，从PRNG中抽取一个随机数。如果此数小于初始损伤概率 $p_0(d) = 1 - e^{-\\alpha d}$（其中 $\\alpha = 0.5$），则角质形成细胞状态 $K(y,x,0)$ 设置为 $1$。\n\n-   **初始智能体种群**：\n    -   创建 $N_{DC} = 40$ 个DCs，其位置在真皮上部（$y \\in \\{10, 11, 12\\}$ 和 $x \\in \\{0, \\dots, 19\\}$）均匀随机分布，并全部设置为“静息”状态。\n    -   创建 $N_M = 60$ 个巨噬细胞，其位置在整个真皮（$y \\in \\{10, \\dots, 19\\}$ 和 $x \\in \\{0, \\dots, 19\\}$）均匀随机分布，并全部设置为“静息”状态。\n    -   T细胞种群初始为零。\n    -   已离开的DC计数 $E(0)$ 初始化为 $0$。\n\n**3. 模拟动力学 (时间演化)**\n\n模拟以离散时间步从 $t=0$ 进行到 $t=T_{\\text{end}}-1$，其中 $T_{\\text{end}} = 72$。在每个步骤中，系统状态根据顺序应用于每个智能体种群的规则进行更新。\n\n-   **树突状细胞动力学**：\n    1.  **激活**：对于每个处于“静息”状态、位置为 $(x,y)$ 的DC，我们计算其感知邻域内受损角质形成细胞的数量 $n_d(t)$。该邻域包括三个基底层表皮位点 $\\{(x-1, N_e-1), (x, N_e-1), (x+1, N_e-1)\\}$，其x坐标被限制在网格边界 $\\{0, \\dots, N-1\\}$ 内。该DC以概率 $p_{\\text{act}}(t) = 1 - e^{-\\beta n_d(t)}$ 被激活，其中 $\\beta = 0.25$。一旦被激活，DC将保持激活状态。\n    2.  **移动**：一个已激活的DC试图向淋巴出口迁移。它以概率 $m$（一个测试参数）向y正方向移动一步至 $(x, y+1)$。如果它位于边界 $y=N-1$，此移动将导致其离开模拟。离开的DCs被移除，计数器 $E(t)$ 增加。一个“静息”的DC以概率 $p_{\\text{jitter}} = 0.3$ 进行随机抖动。这包括移动到一个从其 $3 \\times 3$ 摩尔邻域（包括其当前位置）中均匀选择的新位置，新位置被限制在真皮内（$y' \\ge N_e$）。\n\n-   **T细胞募集与动力学**：\n    1.  **募集**：在一个特定的时间点 $t = \\tau_{\\text{sens}} = 24$，引入效应T细胞。其数量为 $N_T = \\lfloor 0.5 + k_T \\cdot E(\\tau_{\\text{sens}}) \\rfloor$，其中 $k_T = 0.8$，$E(\\tau_{\\text{sens}})$ 是此时已离开的DCs的总数。这些T细胞被放置在真皮内的均匀随机位置。\n    2.  **移动**：对于所有 $t \\ge \\tau_{\\text{sens}}$，每个T细胞执行随机游走。在每个时间步，它移动到其八个相邻的摩尔邻域之一（不包括其当前位置），该邻域被均匀随机地选择。新位置被限制在真皮边界内。\n\n-   **巨噬细胞动力学**：\n    1.  **激活**：对于所有 $t \\ge \\tau_{\\text{sens}}$，如果一个静息的巨噬细胞的切比雪夫距离为 $1$ 内（即在其 $3 \\times 3$ 的摩尔邻域内）至少有一个T细胞，它就会被永久激活。巨噬细胞是固定的，不移动。\n    2.  **角质形成细胞损伤**：每个已激活的巨噬细胞在每时间步尝试诱导一次损伤。它从位点 $(x', y')$ 中均匀随机地选择一个目标角质形成细胞，其中 $x' \\in \\{x_M-1, x_M, x_M+1\\}$（被限制）且 $y' \\in \\{N_e-2, N_e-1\\}$，其中 $(x_M, y_M)$ 是巨噬细胞的位置。如果所选的角质形成细胞尚未受损，它会以概率 $p_K = \\min(1, c)$ 受损，其中 $c$ 是一个测试参数。\n\n**4. 输出计算**\n\n在最后一个时间步 $t=T_{\\text{end}}-1=71$ 后，模拟终止。最终的损伤大小 $L$ 计算为受损角质形成细胞的总数：\n$$L = \\sum_{y=0}^{N_e-1} \\sum_{x=0}^{N-1} K(y,x,T_{\\text{end}})$$\n对每个测试用例重复此过程，并报告最终的整数损伤大小。\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\nimport itertools\n\nclass ContactHypersensitivitySim:\n    \"\"\"\n    Implements a discrete-time, 2D agent-based model of contact hypersensitivity.\n    \"\"\"\n\n    def __init__(self, d, m, c, seed):\n        # Test case parameters\n        self.d = d\n        self.m = m\n        self.c = c\n        self.seed = seed\n        self.rng = np.random.default_rng(self.seed)\n\n        # Model constants\n        self.N = 20\n        self.N_e = self.N // 2\n        self.T_end = 72\n        self.tau_sens = 24\n        self.alpha = 0.5\n        self.beta = 0.25\n        self.p_jitter = 0.3\n        self.k_T = 0.8\n        self.N_DC = 40\n        self.N_M = 60\n        self.p_K = min(1.0, self.c)\n\n        # Agent state storage\n        self.K = np.zeros((self.N_e, self.N), dtype=np.int8)\n        self.dc_agents = []\n        self.mac_agents = []\n        self.t_cell_agents = []\n        self.E = 0  # Cumulative exited DC count\n\n        # Pre-calculated offsets for Moore neighborhoods\n        self.moore_offsets_8 = np.array([p for p in itertools.product([-1, 0, 1], repeat=2) if p != (0, 0)])\n        self.moore_offsets_9 = np.array(list(itertools.product([-1, 0, 1], repeat=2)))\n\n    def run_simulation(self):\n        \"\"\"Initializes and runs the full simulation, returning the final lesion size.\"\"\"\n        self._initialize_state()\n        for t in range(self.T_end):\n            self._tick(t)\n        return int(np.sum(self.K))\n\n    def _initialize_state(self):\n        \"\"\"Sets up the initial state of the simulation at t=0.\"\"\"\n        # 1. Initial keratinocyte damage\n        x_c, y_c = self.N // 2, self.N_e // 2\n        R_d = 2 + math.floor(self.d)\n        p0_d = 1.0 - math.exp(-self.alpha * self.d)\n\n        if self.d > 0:\n            for y in range(self.N_e):\n                for x in range(self.N):\n                    dist = math.sqrt((x - x_c)**2 + (y - y_c)**2)\n                    if dist = R_d:\n                        if self.rng.random()  p0_d:\n                            self.K[y, x] = 1\n\n        # 2. Initial DC population\n        xs_dc = self.rng.integers(0, self.N, size=self.N_DC)\n        ys_dc = self.rng.integers(self.N_e, self.N_e + 3, size=self.N_DC)\n        self.dc_agents = [{'pos': (xs_dc[i], ys_dc[i]), 'state': 'resting'} for i in range(self.N_DC)]\n\n        # 3. Initial macrophage population\n        xs_m = self.rng.integers(0, self.N, size=self.N_M)\n        ys_m = self.rng.integers(self.N_e, self.N, size=self.N_M)\n        self.mac_agents = [{'pos': (xs_m[i], ys_m[i]), 'state': 'resting'} for i in range(self.N_M)]\n\n    def _tick(self, t):\n        \"\"\"Executes a single time step of the simulation.\"\"\"\n        self._update_dcs()\n        self._recruit_t_cells(t)\n        self._update_t_cells_and_macrophages(t)\n\n    def _update_dcs(self):\n        \"\"\"Updates the state and position of all dendritic cells.\"\"\"\n        next_dc_agents = []\n        exited_this_step = 0\n\n        for dc in self.dc_agents:\n            pos = dc['pos']\n            current_state = dc['state']\n            is_activated = (current_state == 'activated')\n\n            if not is_activated:\n                # Check for activation\n                x_dc, _ = pos\n                n_d = 0\n                for dx in [-1, 0, 1]:\n                    x_contact = np.clip(x_dc + dx, 0, self.N - 1)\n                    if self.K[self.N_e - 1, x_contact] == 1:\n                        n_d += 1\n                \n                p_act = 1.0 - math.exp(-self.beta * n_d) if n_d > 0 else 0.0\n                if self.rng.random()  p_act:\n                    is_activated = True\n\n            # Movement logic\n            if is_activated:\n                if self.rng.random()  self.m:\n                    if pos[1] == self.N - 1:\n                        exited_this_step += 1\n                        continue  # DC exits and is removed\n                    else:\n                        pos = (pos[0], pos[1] + 1)\n            else:  # Resting DC jitter\n                if self.rng.random()  self.p_jitter:\n                    offset = self.rng.choice(self.moore_offsets_9, axis=0)\n                    new_x = np.clip(pos[0] + offset[0], 0, self.N - 1)\n                    new_y = np.clip(pos[1] + offset[1], self.N_e, self.N - 1)\n                    pos = (new_x, new_y)\n\n            next_dc_agents.append({'pos': pos, 'state': 'activated' if is_activated else 'resting'})\n\n        self.dc_agents = next_dc_agents\n        self.E += exited_this_step\n\n    def _recruit_t_cells(self, t):\n        \"\"\"Introduces T cells at the sensitization time.\"\"\"\n        if t == self.tau_sens:\n            n_t = math.floor(0.5 + self.k_T * self.E)\n            if n_t > 0:\n                xs_t = self.rng.integers(0, self.N, size=n_t)\n                ys_t = self.rng.integers(self.N_e, self.N, size=n_t)\n                self.t_cell_agents = [{'pos': (xs_t[i], ys_t[i])} for i in range(n_t)]\n\n    def _update_t_cells_and_macrophages(self, t):\n        \"\"\"Updates T-cell positions, macrophage activation, and macrophage-mediated damage.\"\"\"\n        if t  self.tau_sens or not self.t_cell_agents:\n            return\n\n        # Update T-cell positions\n        for tc in self.t_cell_agents:\n            offset = self.rng.choice(self.moore_offsets_8, axis=0)\n            new_x = np.clip(tc['pos'][0] + offset[0], 0, self.N - 1)\n            new_y = np.clip(tc['pos'][1] + offset[1], self.N_e, self.N - 1)\n            tc['pos'] = (new_x, new_y)\n        \n        t_cell_locs = {tc['pos'] for tc in self.t_cell_agents}\n\n        # Update macrophages and damage\n        for mac in self.mac_agents:\n            # Activation\n            if mac['state'] == 'resting':\n                mac_x, mac_y = mac['pos']\n                for dx in [-1, 0, 1]:\n                    for dy in [-1, 0, 1]:\n                        neighbor_pos = (mac_x + dx, mac_y + dy)\n                        if neighbor_pos in t_cell_locs:\n                            mac['state'] = 'activated'\n                            break\n                    if mac['state'] == 'activated':\n                        break\n\n            # Damage amplification\n            if mac['state'] == 'activated':\n                mac_x, _ = mac['pos']\n                \n                # Determine valid targets\n                valid_x = [x for x in range(mac_x - 1, mac_x + 2) if 0 = x  self.N]\n                valid_y = [self.N_e - 2, self.N_e - 1]\n                target_choices = list(itertools.product(valid_x, valid_y))\n                \n                if not target_choices:\n                    continue\n\n                target_idx = self.rng.integers(0, len(target_choices))\n                target_x, target_y = target_choices[target_idx]\n\n                if self.K[target_y, target_x] == 0:\n                    if self.rng.random()  self.p_K:\n                        self.K[target_y, target_x] = 1\n\ndef solve():\n    \"\"\"\n    Runs the simulation for all specified test cases and prints the final results.\n    \"\"\"\n    test_cases = [\n        (1.5, 0.6, 0.4),  # Case 0\n        (0.0, 0.8, 0.7),  # Case 1\n        (3.0, 0.9, 0.9),  # Case 2\n        (1.5, 0.1, 0.9),  # Case 3\n    ]\n\n    results = []\n    for i, (d, m, c) in enumerate(test_cases):\n        seed = 12345 + i\n        sim = ContactHypersensitivitySim(d, m, c, seed)\n        lesion_size = sim.run_simulation()\n        results.append(lesion_size)\n\n    # Format the final output string exactly as required\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "answer": "[65,0,165,22]", "id": "2904755"}]}