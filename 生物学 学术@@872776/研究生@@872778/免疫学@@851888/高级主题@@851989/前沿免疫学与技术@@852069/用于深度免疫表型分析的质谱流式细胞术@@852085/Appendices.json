{"hands_on_practices": [{"introduction": "质谱流式抗体 panel 的设计是实验成功的关键，其中一个核心挑战是相邻质量通道间的信号“溢出”（spillover）。这种溢出不仅会引入系统误差，其相关的计数噪声也会传播，形成所谓的“扩散误差”（spreading error），从而可能掩盖低丰度抗原的真实信号。本练习将引导您从第一性原理出发，定量计算这种扩散误差，这是在设计高维 panel 时评估标记物布局方案的一项基本技能 [@problem_id:2866257]。", "problem": "一个质谱流式抗体组合被设计用于定量分配在一个质量通道上的低密度抗原，而一个高密度共表达的标志物被分配在紧邻的质量通道上。在电感耦合等离子体飞行时间质谱流式细胞术中，信号与离子计数呈线性关系，信号溢出来自两个公认的来源：同位素杂质和检测器峰拖尾至相邻通道。假设以下经验表征的和科学上标准的条件。\n\n- 检测器响应是线性的，离子到达遵循计数统计。对于平均离子计数为 $\\mu$ 的情况，计数过程的方差为 $\\mu$。根据经验，有时会观察到过度离散现象；通过法诺因子 $F$ 对此进行建模，因此方差变为 $F \\mu$。\n- 在两个通道中测得的原始强度 $Y_{A}$ 和 $Y_{B}$，通过一个线性系统与真实的潜在信号 $A_{\\text{true}}$ 和 $B_{\\text{true}}$ 相关联，该系统包含从通道 B 到通道 A 的少量信号溢出。使用已知的溢出比例应用标准线性解混。\n- 各通道间的测量噪声源是独立的，且在下述条件下，基线电子噪声与计数噪声相比可忽略不计。\n\n给定以下特定于抗体组合和样本的参数，所有参数均在稳定的采集条件下测得：\n- 通道 B 中的高密度标志物每个事件的平均原始计数为 $\\mu_{B} = 7.5 \\times 10^{4}$ 个离子计数。\n- 通道 B 的过度离散因子（法诺因子）为 $F_{B} = 1.15$。\n- 从通道 B 到相邻通道 A 的溢出比例是同位素杂质部分 $s_{\\text{iso}} = 0.0022$ 和检测器拖尾部分 $s_{\\text{tail}} = 0.0013$ 的总和。\n- 通道 A 中的抗原是低密度的，你需要计算在线性解混后仅由通道 B 引起的预期扩展误差，该误差定义为由通道 B 的噪声通过解混步骤传播到通道 A 所产生的标准差贡献。在此计算中，忽略通道 A 本身的任何内在方差。\n\n仅使用上述原理，计算通道 A 中预期的扩展误差标准差（单位为每个事件的离子计数）。以每个事件的离子计数为单位表达最终答案，并将您的答案四舍五入到三位有效数字。", "solution": "该问题要求计算质谱流式细胞术通道中的扩展误差标准差，该误差源于相邻高信号通道的信号溢出。这是一个线性系统中误差传播的标准问题。\n\n首先，我们将测量过程形式化。设 $A_{\\text{true}}$ 和 $B_{\\text{true}}$ 分别为通道 A 和 B 中给定事件的真实潜在离子信号。测得的原始强度，由随机变量 $Y_A$ 和 $Y_B$ 表示，受到信号溢出的影响。已知信号溢出以已知的比例 $s$ 从通道 B 发生到通道 A，则测量信号的模型为：\n$$ Y_A = A_{\\text{true}}' + s \\cdot Y_B $$\n$$ Y_B = B_{\\text{true}}' $$\n此处，$A_{\\text{true}}'$ 和 $B_{\\text{true}}'$ 代表真实信号加上它们自身的内在计数噪声。为了清晰地说明传播过程，我们考虑真实信号的估计量与测量信号之间的关系。线性解混（补偿）的目标是从原始测量值中估计出真实信号。设 $\\hat{A}_{\\text{true}}$ 和 $\\hat{B}_{\\text{true}}$ 为估计量。解混过程反转了测量模型：\n$$ \\hat{B}_{\\text{true}} = Y_B $$\n$$ \\hat{A}_{\\text{true}} = Y_A - s \\cdot Y_B $$\n\n我们被要求找出通道 A 中仅由通道 B 的噪声引起的误差的标准差。该误差会传播到估计量 $\\hat{A}_{\\text{true}}$ 中。我们首先计算 $\\hat{A}_{\\text{true}}$ 的方差。\n$$ \\text{Var}(\\hat{A}_{\\text{true}}) = \\text{Var}(Y_A - s \\cdot Y_B) $$\n\n问题陈述，各通道间的测量噪声源是独立的。因此，$Y_A$ 和 $Y_B$ 之间的协方差为零。使用独立随机变量的方差性质，我们有：\n$$ \\text{Var}(\\hat{A}_{\\text{true}}) = \\text{Var}(Y_A) + \\text{Var}(-s \\cdot Y_B) $$\n$$ \\text{Var}(\\hat{A}_{\\text{true}}) = \\text{Var}(Y_A) + (-s)^2 \\text{Var}(Y_B) $$\n$$ \\text{Var}(\\hat{A}_{\\text{true}}) = \\text{Var}(Y_A) + s^2 \\text{Var}(Y_B) $$\n\n通道 A 中补偿后信号的总方差由两项组成：通道 A 测量的内在方差 $\\text{Var}(Y_A)$，以及来自通道 B 的方差贡献 $s^2 \\text{Var}(Y_B)$。后一项定义为扩展误差方差，$\\sigma_{\\text{spread}}^2$。\n$$ \\sigma_{\\text{spread}}^2 = s^2 \\text{Var}(Y_B) $$\n\n问题要求的是扩展误差标准差 $\\sigma_{\\text{spread}}$，即该方差的平方根。\n$$ \\sigma_{\\text{spread}} = \\sqrt{s^2 \\text{Var}(Y_B)} = |s| \\sqrt{\\text{Var}(Y_B)} $$\n由于溢出比例 $s$ 是正数，这可以简化为：\n$$ \\sigma_{\\text{spread}} = s \\cdot \\sigma_B $$\n其中 $\\sigma_B = \\sqrt{\\text{Var}(Y_B)}$ 是通道 B 中原始信号的标准差。\n\n现在我们必须根据给定的参数计算 $s$ 和 $\\text{Var}(Y_B)$ 的值。\n\n总溢出比例 $s$ 是同位素杂质和检测器拖尾部分的总和：\n$$ s = s_{\\text{iso}} + s_{\\text{tail}} $$\n给定 $s_{\\text{iso}} = 0.0022$ 和 $s_{\\text{tail}} = 0.0013$：\n$$ s = 0.0022 + 0.0013 = 0.0035 $$\n\n通道 B 中计数过程的方差由模型 $\\text{Var}(Y_B) = F_B \\mu_B$ 给出，其中 $\\mu_B$ 是平均离子计数，而 $F_B$ 是法诺因子。\n给定 $\\mu_B = 7.5 \\times 10^4$ 个离子计数和 $F_B = 1.15$：\n$$ \\text{Var}(Y_B) = F_B \\cdot \\mu_B = 1.15 \\times (7.5 \\times 10^4) = 86250 $$\n\n现在，将这些值代回到扩展误差标准差的表达式中：\n$$ \\sigma_{\\text{spread}} = s \\cdot \\sqrt{\\text{Var}(Y_B)} = 0.0035 \\times \\sqrt{86250} $$\n计算数值：\n$$ \\sqrt{86250} \\approx 293.6835 $$\n$$ \\sigma_{\\text{spread}} \\approx 0.0035 \\times 293.6835 \\approx 1.02789 $$\n\n问题要求将最终答案四舍五入到三位有效数字。\n$$ \\sigma_{\\text{spread}} \\approx 1.03 $$\n由于通道 B 的信号溢出，通道 A 中预期的扩展误差标准差约为每个事件 $1.03$ 个离子计数。", "answer": "$$\\boxed{1.03}$$", "id": "2866257"}, {"introduction": "即使经过精心设计，信号溢出在质谱流式数据中仍不可避免，因此必须通过计算进行“补偿”（compensation）。这个过程可以通过一个线性混合模型 $\\mathbf{s} = \\mathbf{A}\\mathbf{t}$ 来描述，其中补偿的目标是从测量信号 $\\mathbf{s}$ 中恢复出真实的生物信号 $\\mathbf{t}$。在本练习中，您将通过实现一个基于非负最小二乘法 (NNLS) 的补偿算法，来实践这一关键的数据预处理步骤，并学习如何评估补偿模型的性能 [@problem_id:2866251]。", "problem": "给定一个用于质谱流式细胞术（CyTOF, Cytometry by Time of Flight）信号的线性混合模型，其中单个事件在 $C$ 个通道上的测量强度向量 $\\mathbf{s} \\in \\mathbb{R}_{\\ge 0}^{C}$ 与潜在的真实标记强度 $\\mathbf{t} \\in \\mathbb{R}_{\\ge 0}^{C}$ 通过关系式 $\\mathbf{s} = \\mathbf{A}\\mathbf{t} + \\boldsymbol{\\eta}$ 相关联。这里，$\\mathbf{A} \\in \\mathbb{R}^{C \\times C}$ 是从单染对照（每个通道一个对照）中估计出的溢出矩阵，$\\boldsymbol{\\eta}$ 表示测量噪声和模型失配。溢出矩阵 $\\mathbf{A}$ 编码了对角线上的主信号和非对角线上的交叉通道污染。对于一个有 $E$ 个事件的测试样本，测量数据被排列成一个矩阵 $\\mathbf{S} \\in \\mathbb{R}_{\\ge 0}^{E \\times C}$，其第 $i$ 行为 $\\mathbf{s}_i^\\top$。\n\n您的任务是使用非负最小二乘法（NNLS）计算补偿信号，并量化每个通道的残余污染。请使用以下原则性定义：\n\n1.  对于每个事件 $i \\in \\{1,\\dots,E\\}$，通过求解 NNLS 问题来估计补偿后的真实信号 $\\widehat{\\mathbf{t}}_i$：\n$$\n\\widehat{\\mathbf{t}}_i \\;=\\; \\arg\\min_{\\mathbf{t} \\in \\mathbb{R}_{\\ge 0}^{C}} \\left\\| \\mathbf{A}\\mathbf{t} - \\mathbf{s}_i \\right\\|_2^2.\n$$\n\n2.  对于每个 $i$ 和通道 $j \\in \\{1,\\dots,C\\}$，定义模型预测的测量信号 $\\widehat{\\mathbf{s}}_i = \\mathbf{A}\\widehat{\\mathbf{t}}_i$ 和通道 $j$ 中的非对角线预测污染为\n$$\n\\operatorname{offdiag}_{i,j} \\;=\\; \\left(\\widehat{\\mathbf{s}}_i\\right)_j \\;-\\; A_{j,j}\\, \\left(\\widehat{\\mathbf{t}}_i\\right)_j \\;=\\; \\sum_{\\substack{k=1\\\\k \\ne j}}^{C} A_{j,k}\\,\\left(\\widehat{\\mathbf{t}}_i\\right)_k.\n$$\n\n3.  为了以数值稳定的方式量化可能具有零测量强度的通道的污染和残差，定义每个事件、每个通道的分母\n$$\nd_{i,j} \\;=\\; \\max\\!\\left( \\left(\\mathbf{s}_i\\right)_j, \\delta \\right),\n$$\n其中固定的小常数 $\\delta = 10^{-9}$。\n\n4.  事件 $i$ 在通道 $j$ 中的预测分数污染是\n$$\nf^{\\mathrm{pred}}_{i,j} \\;=\\; \\frac{\\operatorname{offdiag}_{i,j}}{d_{i,j}},\n$$\n残余分数误差是\n$$\nf^{\\mathrm{resid}}_{i,j} \\;=\\; \\frac{\\left| \\left(\\mathbf{s}_i\\right)_j - \\left(\\widehat{\\mathbf{s}}_i\\right)_j \\right|}{d_{i,j}}.\n$$\n\n5.  跨事件聚合以获得两个每个通道的摘要：\n   - 每个通道的平均预测污染：\n   $$\n   \\overline{f}^{\\mathrm{pred}}_{j} \\;=\\; \\frac{1}{E}\\sum_{i=1}^{E} f^{\\mathrm{pred}}_{i,j}.\n   $$\n   - 每个通道的最大残余分数误差：\n   $$\n   f^{\\mathrm{resid,max}}_{j} \\;=\\; \\max_{1 \\le i \\le E} f^{\\mathrm{resid}}_{i,j}.\n   $$\n\n实现一个程序，对于下面提供的每个测试案例，使用上述定义计算向量 $\\left(\\overline{f}^{\\mathrm{pred}}_{j}\\right)_{j=1}^{C}$ 和 $\\left(f^{\\mathrm{resid,max}}_{j}\\right)_{j=1}^{C}$。所有案例均使用 $C = 3$ 个通道。强度不需要物理单位。所有输出必须四舍五入到 $6$ 位小数。\n\n测试套件（三个案例）：\n\n- 案例 $1$（良态溢出，无噪声样本）：\n  - $C = 3$, $E = 4$。\n  - 溢出矩阵\n    $$\n    \\mathbf{A}_1 = \\begin{bmatrix}\n    1.0  0.02  0.01\\\\\n    0.015  1.0  0.025\\\\\n    0.0  0.03  1.0\n    \\end{bmatrix}.\n    $$\n  - 测量样本矩阵\n    $$\n    \\mathbf{S}_1 = \\begin{bmatrix}\n    1001.1  65.25  11.5\\\\\n    10.0  500.0  15.0\\\\\n    206.0  208.0  206.0\\\\\n    1.0  2.5  100.0\n    \\end{bmatrix}.\n    $$\n\n- 案例 $2$（单位溢出，包含零的任意信号）：\n  - $C = 3$, $E = 3$。\n  - 溢出矩阵\n    $$\n    \\mathbf{A}_2 = \\begin{bmatrix}\n    1.0  0.0  0.0\\\\\n    0.0  1.0  0.0\\\\\n    0.0  0.0  1.0\n    \\end{bmatrix}.\n    $$\n  - 测量样本矩阵\n    $$\n    \\mathbf{S}_2 = \\begin{bmatrix}\n    10.0  0.0  0.0\\\\\n    0.0  20.0  30.0\\\\\n    5.0  5.0  5.0\n    \\end{bmatrix}.\n    $$\n\n- 案例 $3$（强串扰，轻度加性噪声）：\n  - $C = 3$, $E = 4$。\n  - 溢出矩阵\n    $$\n    \\mathbf{A}_3 = \\begin{bmatrix}\n    1.0  0.4  0.3\\\\\n    0.35  1.0  0.45\\\\\n    0.25  0.5  1.0\n    \\end{bmatrix}.\n    $$\n  - 含噪声的测量样本矩阵\n    $$\n    \\mathbf{S}_3 = \\begin{bmatrix}\n    150.3  141.5  125.2\\\\\n    47.9  120.0  60.1\\\\\n    65.0  40.2  62.2\\\\\n    6.05  4.27  3.23\n    \\end{bmatrix}.\n    $$\n\n最终输出规范：\n\n- 对于每个测试案例 $m \\in \\{1,2,3\\}$，计算两个列表：\n  - $\\left[\\overline{f}^{\\mathrm{pred}}_{1}, \\overline{f}^{\\mathrm{pred}}_{2}, \\overline{f}^{\\mathrm{pred}}_{3}\\right]$,\n  - $\\left[f^{\\mathrm{resid,max}}_{1}, f^{\\mathrm{resid,max}}_{2}, f^{\\mathrm{resid,max}}_{3}\\right]$,\n  所有条目四舍五入到 $6$ 位小数。\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表包含三个元素，每个元素本身是如上所述的双元素列表，并且没有空格。例如，顶层结构必须如下所示\n  $$\n  \\big[\\,[\\,[\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot]\\,],\\;[\\,[\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot]\\,],\\;[\\,[\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot]\\,]\\,\\big]\n  $$\n  其中每个 $\\cdot$ 是一个四舍五入到 $6$ 位的小数。\n在所有分母 $d_{i,j}$ 中使用 $\\delta = 10^{-9}$，如上定义。不涉及角度。所有输出必须是实值小数；不要使用百分比或符号。", "solution": "所述问题已经过严格验证，并被证实是有效的。它在科学上基于质谱流式细胞术的原理，在数学上是适定的，并为所有必需的计算提供了完整而明确的规范。因此，我们将着手构建解决方案。\n\n目标是通过首先补偿信号溢出，然后量化此溢出的程度和模型的残余误差，来分析模拟的质谱流式细胞术数据。该过程是对每个细胞事件应用一系列明确定义的分析步骤，然后对所有事件的指标进行聚合。\n\n基础模型是线性混合方程 $\\mathbf{s} = \\mathbf{A}\\mathbf{t} + \\boldsymbol{\\eta}$。在此，$\\mathbf{s} \\in \\mathbb{R}_{\\ge 0}^{C}$ 是单个细胞在 $C$ 个通道上的测量信号强度向量。向量 $\\mathbf{t} \\in \\mathbb{R}_{\\ge 0}^{C}$ 代表真实的、未观测到的生物标记强度，物理上限制为非负。溢出矩阵 $\\mathbf{A} \\in \\mathbb{R}^{C \\times C}$ 是一个系统矩阵，量化了信号从一个通道泄漏到其他通道的方式。其对角元素 $A_{j,j}$ 代表主信号灵敏度，而非对角元素 $A_{j,k}$ ($j \\ne k$) 代表交叉通道污染。$\\boldsymbol{\\eta}$ 项解释了测量噪声以及与理想线性模型的任何偏差。\n\n用于分析由矩阵 $\\mathbf{S} \\in \\mathbb{R}_{\\ge 0}^{E \\times C}$ 表示的 $E$ 个事件的数据集的算法过程包括以下步骤：\n\n1.  **逐事件信号反卷积：** 对于每个事件 $i$（$\\mathbf{S}$ 的每一行 $\\mathbf{s}_i$），我们必须估计真实的潜在信号向量 $\\mathbf{t}_i$。由于真实的标记物表达不能为负，我们使用非负最小二乘法（NNLS）来解决优化问题：\n    $$\n    \\widehat{\\mathbf{t}}_i \\;=\\; \\arg\\min_{\\mathbf{t} \\in \\mathbb{R}_{\\ge 0}^{C}} \\left\\| \\mathbf{A}\\mathbf{t} - \\mathbf{s}_i \\right\\|_2^2.\n    $$\n    此公式找到了最优的非负真实信号向量 $\\widehat{\\mathbf{t}}_i$，当通过溢出矩阵 $\\mathbf{A}$ 变换时，它在欧几里得范数意义上最接近地重构了测量的信号向量 $\\mathbf{s}_i$。这是核心的信号补偿步骤。\n\n2.  **模型预测信号和污染的计算：** 一旦估计了补偿信号 $\\widehat{\\mathbf{t}}_i$，我们计算模型预测的理想化测量信号：\n    $$\n    \\widehat{\\mathbf{s}}_i = \\mathbf{A}\\widehat{\\mathbf{t}}_i.\n    $$\n    特定通道 $j$ 中的非对角线污染是预测信号 $\\left(\\widehat{\\mathbf{s}}_i\\right)_j$ 中源于其他通道 $k \\ne j$ 真实信号的部分。其计算方式如下：\n    $$\n    \\operatorname{offdiag}_{i,j} \\;=\\; \\sum_{\\substack{k=1\\\\k \\ne j}}^{C} A_{j,k}\\,\\left(\\widehat{\\mathbf{t}}_i\\right)_k.\n    $$\n\n3.  **分数污染和残余误差的量化：** 为了使这些量在不同信号幅度间具有可比性并确保数值稳定性，它们被归一化。事件 $i$ 的每个通道 $j$ 的分母定义为 $d_{i,j} = \\max\\!\\left( \\left(\\mathbf{s}_i\\right)_j, \\delta \\right)$，其中 $\\delta = 10^{-9}$ 是一个小的常数，以防止除以零。\n    -   预测的分数污染是非对角线贡献与测量信号的比率：\n        $$\n        f^{\\mathrm{pred}}_{i,j} \\;=\\; \\frac{\\operatorname{offdiag}_{i,j}}{d_{i,j}}.\n        $$\n    -   残余分数误差衡量了测量信号与模型重构信号之间的差异，指示了拟合优度：\n        $$\n        f^{\\mathrm{resid}}_{i,j} \\;=\\; \\frac{\\left| \\left(\\mathbf{s}_i\\right)_j - \\left(\\widehat{\\mathbf{s}}_i\\right)_j \\right|}{d_{i,j}}.\n        $$\n    非零残差可归因于噪声项 $\\boldsymbol{\\eta}$ 或线性模型的基本不准确性。\n\n4.  **每个通道统计数据的聚合：** 最后，将事件级别的指标在所有 $E$ 个事件上进行聚合，以产生两个维度为 $C$ 的摘要向量：\n    -   每个通道的平均预测污染 $\\overline{f}^{\\mathrm{pred}}_{j}$，提供了溢出对细胞群体中通道 $j$ 影响的平均度量：\n        $$\n        \\overline{f}^{\\mathrm{pred}}_{j} \\;=\\; \\frac{1}{E}\\sum_{i=1}^{E} f^{\\mathrm{pred}}_{i,j}.\n        $$\n    -   每个通道的最大残余分数误差 $f^{\\mathrm{resid,max}}_{j}$，标识了通道 $j$ 的最坏情况模型失效，这是模型性能的关键诊断指标：\n        $$\n        f^{\\mathrm{resid,max}}_{j} \\;=\\; \\max_{1 \\le i \\le E} f^{\\mathrm{resid}}_{i,j}.\n        $$\n\n实现将系统地将这整个过程应用于每个提供的测试案例。它将利用 `scipy.optimize` 库中的 `nnls` 函数进行核心优化步骤，并使用 `numpy` 进行高效的矩阵和向量运算。每个案例的最终结果，包括两个向量 $(\\overline{f}^{\\mathrm{pred}}_{j})_{j=1}^{C}$ 和 $(f^{\\mathrm{resid,max}}_{j})_{j=1}^{C}$，将按照指定格式进行格式化。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import nnls\n\ndef solve():\n    \"\"\"\n    Solves the mass cytometry compensation problem for the given test cases.\n    \"\"\"\n    \n    # Test case 1 data\n    A1 = np.array([\n        [1.0, 0.02, 0.01],\n        [0.015, 1.0, 0.025],\n        [0.0, 0.03, 1.0]\n    ])\n    S1 = np.array([\n        [1001.1, 65.25, 11.5],\n        [10.0, 500.0, 15.0],\n        [206.0, 208.0, 206.0],\n        [1.0, 2.5, 100.0]\n    ])\n\n    # Test case 2 data\n    A2 = np.array([\n        [1.0, 0.0, 0.0],\n        [0.0, 1.0, 0.0],\n        [0.0, 0.0, 1.0]\n    ])\n    S2 = np.array([\n        [10.0, 0.0, 0.0],\n        [0.0, 20.0, 30.0],\n        [5.0, 5.0, 5.0]\n    ])\n\n    # Test case 3 data\n    A3 = np.array([\n        [1.0, 0.4, 0.3],\n        [0.35, 1.0, 0.45],\n        [0.25, 0.5, 1.0]\n    ])\n    S3 = np.array([\n        [150.3, 141.5, 125.2],\n        [47.9, 120.0, 60.1],\n        [65.0, 40.2, 62.2],\n        [6.05, 4.27, 3.23]\n    ])\n\n    test_cases = [\n        (A1, S1),\n        (A2, S2),\n        (A3, S3)\n    ]\n\n    delta = 1e-9\n    all_results_str = []\n\n    for A, S in test_cases:\n        E, C = S.shape\n        \n        f_pred_matrix = np.zeros((E, C))\n        f_resid_matrix = np.zeros((E, C))\n\n        # Pre-calculate the off-diagonal part of A\n        A_offdiag = A - np.diag(np.diag(A))\n\n        for i in range(E):\n            s_i = S[i, :]\n            \n            # Step 1: Solve NNLS problem for the current event\n            t_hat_i, _ = nnls(A, s_i)\n            \n            # Step 2: Calculate predicted signal and off-diagonal contamination\n            s_hat_i = A @ t_hat_i\n            offdiag_i_vector = A_offdiag @ t_hat_i\n            \n            # Step 3: Calculate denominators for normalization\n            d_i = np.maximum(s_i, delta)\n            \n            # Step 4: Calculate fractional contamination and residual error\n            f_pred_i = offdiag_i_vector / d_i\n            f_resid_i = np.abs(s_i - s_hat_i) / d_i\n            \n            f_pred_matrix[i, :] = f_pred_i\n            f_resid_matrix[i, :] = f_resid_i\n            \n        # Step 5: Aggregate across events\n        mean_f_pred = np.mean(f_pred_matrix, axis=0)\n        max_f_resid = np.max(f_resid_matrix, axis=0)\n        \n        # Format results for the current test case\n        pred_list_str = [f\"{x:.6f}\" for x in mean_f_pred]\n        resid_list_str = [f\"{x:.6f}\" for x in max_f_resid]\n        \n        case_result_str = f\"[[{','.join(pred_list_str)}],[{','.join(resid_list_str)}]]\"\n        all_results_str.append(case_result_str)\n\n    # Final print statement must produce a single line with no extra characters\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```", "id": "2866251"}, {"introduction": "在识别出细胞亚群后，免疫学研究的核心任务往往是比较不同条件下（如治疗前后）细胞亚群丰度的变化。为了得到可靠的结论，必须采用与实验设计（尤其是配对样本）相匹配的统计检验方法。本练习将指导您实现一个精确的置换检验，这是一种强大的非参数方法，它能够利用配对设计的优势，在不依赖强分布假设的情况下，严格地评估处理效应的统计显著性 [@problem_id:2866321]。", "problem": "给定来自供体的配对飞行时间质谱流式细胞技术 (CyTOF) 细胞簇计数，这些供体在对照条件下进行了测量，并在处理条件下进行了再次测量。为了进行保留配对信息的供体水平推断，请设计并实现一个基于供体内差异符号翻转的精确置换检验，以评估处理是否改变了细胞簇的丰度，同时在零假设（即处理对各供体转换后的细胞簇比例均值没有影响）下控制 I 型错误。\n\n基本原理和假设：\n- 通过质谱流式细胞技术测量的细胞簇事件计数被建模为以每个样本的总事件数为条件的二项式抽取。具体来说，对于供体索引 $i \\in \\{1,\\dots,n\\}$ 和条件 $c \\in \\{\\text{control}, \\text{treatment}\\}$，令 $Y_{i,c}$ 为细胞簇计数，$N_{i,c}$ 为总事件计数，其中 $Y_{i,c} \\mid N_{i,c} \\sim \\text{Binomial}(N_{i,c}, p_{i,c})$。细胞簇比例为 $P_{i,c} = Y_{i,c}/N_{i,c}$。\n- 使用反正弦平方根方差稳定变换 $g(p) = \\arcsin(\\sqrt{p})$，角度以弧度为单位。定义供体内转换差异 $D_i = g(P_{i,\\text{treatment}}) - g(P_{i,\\text{control}})$。\n- 在尖锐零假设（即处理不改变供体内细胞簇比例分布）下，$D_i$ 的符号在供体之间是可交换的。一个枚举 $\\{D_i\\}_{i=1}^n$ 上所有 $2^n$ 种符号模式的符号翻转置换检验，可以为 $D_i$ 均值为零的零假设提供一个水平为 $\\alpha$ 的精确双边检验。\n- 定义学生化检验统计量 $T = \\dfrac{\\bar{D}}{S_D/\\sqrt{n}}$，其中 $\\bar{D}$ 是 $\\{D_i\\}$ 的样本均值，$S_D$ 是使用自由度校正 $n-1$ 计算的无偏样本标准差。\n\n需要实现的算法：\n- 给定配对计数 $\\{(N_{i,\\text{control}}, Y_{i,\\text{control}}, N_{i,\\text{treatment}}, Y_{i,\\text{treatment}})\\}_{i=1}^n$，计算 $P_{i,c} = Y_{i,c}/N_{i,c}$，$D_i = \\arcsin(\\sqrt{P_{i,\\text{treatment}}}) - \\arcsin(\\sqrt{P_{i,\\text{control}}})$（以弧度为单位），$\\bar{D}$，$S_D$ 以及 $T_{\\text{obs}} = \\bar{D}/(S_D/\\sqrt{n})$。\n- 枚举所有 $2^n$ 种符号模式 $\\mathbf{s} \\in \\{-1, +1\\}^n$ 以生成置换后的差异 $D_i^{(\\mathbf{s})} = s_i D_i$，为每个置换类似地计算 $T^{(\\mathbf{s})}$，并计算精确的双边置换 $p$ 值 $p_{\\text{perm}} = \\dfrac{1}{2^n} \\sum_{\\mathbf{s}} \\mathbf{1}\\{\\,|T^{(\\mathbf{s})}| \\ge |T_{\\text{obs}}|\\,\\}$。\n- 使用双边显著性水平 $\\alpha = 0.05$，当 $p_{\\text{perm}} \\le \\alpha$ 时拒绝。\n- 角度单位要求：反正弦函数必须以弧度为单位进行计算。\n\n测试套件：\n实现您的程序以运行以下四个独立的测试用例。每个用例都以一个明确的供体列表形式提供，其中每个供体是一个元组 $(N_{\\text{control}}, Y_{\\text{control}}, N_{\\text{treatment}}, Y_{\\text{treatment}})$。\n\n- 用例 A（类零假设，混合小变化，$n = 8$）：\n$$\n\\text{case}_A =\n[(12000,180,13000,195),\n(9000,90,9500,105),\n(15000,300,14500,280),\n(11000,132,11500,130),\n(8000,80,8500,88),\n(10000,140,12000,168),\n(13000,169,12500,162),\n(14000,210,15000,240)].\n$$\n\n- 用例 B（处理增加丰度，$n = 10$）：\n$$\n\\text{case}_B =\n[(10000,100,10000,200),\n(12000,96,11000,220),\n(9000,90,9000,180),\n(15000,225,15000,450),\n(16000,128,16000,256),\n(11000,110,12000,240),\n(8000,72,8000,160),\n(20000,220,20000,440),\n(14000,140,13000,299),\n(10000,130,9000,216)].\n$$\n\n- 用例 C（含零和小计数的边界情况，$n = 6$）：\n$$\n\\text{case}_C =\n[(5000,0,5000,10),\n(6000,0,6000,0),\n(7000,7,7000,0),\n(8000,0,8000,16),\n(9000,9,9000,18),\n(10000,10,10000,8)].\n$$\n\n- 用例 D（小样本，一致增加，$n = 3$）：\n$$\n\\text{case}_D =\n[(10000,100,10000,180),\n(12000,60,12000,120),\n(15000,150,15000,300)].\n$$\n\n任务：\n- 对于每个用例，按照规定计算精确的双边置换 $p$ 值，并返回一个布尔值，指示在 $\\alpha = 0.05$ 的水平上是否拒绝零假设。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\text{Case A}, \\text{Case B}, \\text{Case C}, \\text{Case D}]$，其中每个元素为 True 或 False，例如 $[\\text{True},\\text{False},\\text{True},\\text{False}]$。\n\n注意：\n- 所有三角函数的计算都必须以弧度为单位执行。\n- 如果 $S_D = 0$，当 $\\bar{D} = 0$ 时定义 $T = 0$，否则为了置换比较的目的，定义 $T = \\text{sign}(\\bar{D}) \\cdot \\infty$。", "solution": "所陈述的问题是有效的。它基于既定的生物统计学原理，提出了一个清晰、独立且科学上合理的任务。实验背景，即质谱流式细胞技术，与所提出的数据结构是相符的。模型假设，包括细胞计数的二项分布和使用反正弦平方根变换进行方差稳定，是分析比例数据的标准做法。问题的核心是实现一个精确置换检验，这是一种非参数方法，通过直接从数据生成零分布来稳健地控制 I 型错误。该问题是适定的，提供了所有必要的数据、参数和确定性算法，确保了唯一且可验证的解。\n\n我们将通过系统地实现指定的算法来解决问题。此过程的基础是对配对数据的统计分析，其中每个供体提供一对测量值：一个在对照条件下，一个在处理条件下。\n\n首先，我们形式化初始数据转换。对于每个供体 $i \\in \\{1, \\dots, n\\}$，我们得到分析的细胞总数 $N_{i,c}$，以及属于特定细胞簇的细胞数 $Y_{i,c}$，对于每个条件 $c \\in \\{\\text{control}, \\text{treatment}\\}$。细胞簇中的细胞比例估计为 $P_{i,c} = Y_{i,c} / N_{i,c}$。这些比例是随机变量的实现，它们的方差依赖于底层的真实概率，这对于许多统计检验来说是不理想的。为了缓解这个问题，我们应用反正弦平方根变换，这是一种用于二项式比例的标准方差稳定变换。转换后的值为 $g(p) = \\arcsin(\\sqrt{p})$，角度以弧度为单位测量。$g(P_{i,c})$ 的方差近似为 $\\frac{1}{4N_{i,c}}$，这与比例 $p_{i,c}$ 无关。\n\n通过计算转换后比例的供体内差异，可以利用实验设计的配对性质：\n$$\nD_i = g(P_{i,\\text{treatment}}) - g(P_{i,\\text{control}}) = \\arcsin(\\sqrt{P_{i,\\text{treatment}}}) - \\arcsin(\\sqrt{P_{i,\\text{control}}})\n$$\n差异集合 $\\{D_i\\}_{i=1}^n$ 成为我们检验的基础数据。待检验的零假设是处理对细胞簇丰度没有影响，这意味着抽取 $D_i$ 的分布的均值为零。\n\n检验过程是基于符号翻转的精确置换检验。该方法由尖锐零假设证明其合理性，该假设指出对于任何给定的供体，处理绝对没有影响。在此假设下，“对照”和“处理”的标签是可互换的。交换供体 $i$ 的这些标签只会改变计算出的差异 $D_i$ 的符号。因此，在尖锐零假设下，每个 $D_i$ 的符号可以被视为来自抛硬币（$\\{-1, +1\\}$，概率相等）的随机结果，并且在供体之间是独立的。这个原理允许我们通过考虑观测到的差异 $\\{D_i\\}_{i=1}^n$ 的所有 $2^n$ 种可能的符号组合来生成任何检验统计量的完整零分布。\n\n指定的检验统计量是差异的学生化均值，其形式与单样本 t 统计量相同：\n$$\nT = \\frac{\\bar{D}}{S_D / \\sqrt{n}}\n$$\n其中 $\\bar{D} = \\frac{1}{n} \\sum_{i=1}^n D_i$ 是差异的样本均值，而 $S_D = \\sqrt{\\frac{1}{n-1} \\sum_{i=1}^n (D_i - \\bar{D})^2}$ 是无偏样本标准差。我们首先为观测数据计算这个统计量，得到 $T_{\\text{obs}}$。\n\n算法的核心是枚举零分布。我们生成所有 $2^n$ 个符号向量 $\\mathbf{s} = (s_1, s_2, \\dots, s_n)$，其中每个 $s_i \\in \\{-1, +1\\}$。对于每个向量 $\\mathbf{s}$，我们创建一个置换后的差异集合 $\\{D_i^{(\\mathbf{s})} = s_i D_i\\}_{i=1}^n$。对于每个这样的集合，我们使用相同的公式计算相应的检验统计量 $T^{(\\mathbf{s})}$：\n$$\nT^{(\\mathbf{s})} = \\frac{\\bar{D}^{(\\mathbf{s})}}{S_D^{(\\mathbf{s})} / \\sqrt{n}}\n$$\n其中 $\\bar{D}^{(\\mathbf{s})}$ 和 $S_D^{(\\mathbf{s})}$ 是置换后差异 $\\{D_i^{(\\mathbf{s})}\\}_{i=1}^n$ 的均值和标准差。如果置换集合的标准差 $S_D^{(\\mathbf{s})}$ 为零，则会出现特殊情况。如果均值 $\\bar{D}^{(\\mathbf{s})}$ 也为零，则 $T^{(\\mathbf{s})}$ 定义为 $0$。如果 $\\bar{D}^{(\\mathbf{s})}$ 非零，则 $T^{(\\mathbf{s})}$ 定义为 $\\text{sign}(\\bar{D}^{(\\mathbf{s})}) \\cdot \\infty$ 以正确反映无限显著的偏差。这 $2^n$ 个 $T^{(\\mathbf{s})}$值的集合构成了该统计量的精确零分布。\n\n然后，双边 p 值的计算方法是：其检验统计量至少与观测统计量一样极端的置换所占的比例。形式上，\n$$\np_{\\text{perm}} = \\frac{1}{2^n} \\sum_{\\mathbf{s} \\in \\{-1, +1\\}^n} \\mathbf{1}\\{|T^{(\\mathbf{s})}| \\ge |T_{\\text{obs}}|\\}\n$$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数，如果条件为真则等于 $1$，否则为 $0$。\n\n最后，根据预定义的显著性水平 $\\alpha$ 做出决策。问题指定 $\\alpha = 0.05$。如果 $p_{\\text{perm}} \\le 0.05$，我们拒绝零假设，并得出结论：有统计上显著的证据表明处理影响了细胞簇丰度。否则，如果 $p_{\\text{perm}} > 0.05$，我们则无法拒绝零假设。现在将为所提供的四个测试用例分别实现此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import product\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis on all test cases specified in the problem.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = {\n        \"Case A\": [\n            (12000, 180, 13000, 195), (9000, 90, 9500, 105), (15000, 300, 14500, 280),\n            (11000, 132, 11500, 130), (8000, 80, 8500, 88), (10000, 140, 12000, 168),\n            (13000, 169, 12500, 162), (14000, 210, 15000, 240)\n        ],\n        \"Case B\": [\n            (10000, 100, 10000, 200), (12000, 96, 11000, 220), (9000, 90, 9000, 180),\n            (15000, 225, 15000, 450), (16000, 128, 16000, 256), (11000, 110, 12000, 240),\n            (8000, 72, 8000, 160), (20000, 220, 20000, 440), (14000, 140, 13000, 299),\n            (10000, 130, 9000, 216)\n        ],\n        \"Case C\": [\n            (5000, 0, 5000, 10), (6000, 0, 6000, 0), (7000, 7, 7000, 0),\n            (8000, 0, 8000, 16), (9000, 9, 9000, 18), (10000, 10, 10000, 8)\n        ],\n        \"Case D\": [\n            (10000, 100, 10000, 180), (12000, 60, 12000, 120), (15000, 150, 15000, 300)\n        ]\n    }\n\n    alpha = 0.05\n    results = []\n\n    # Order of cases for final output\n    case_order = [\"Case A\", \"Case B\", \"Case C\", \"Case D\"]\n\n    for case_name in case_order:\n        data = test_cases[case_name]\n        \n        n_donors = len(data)\n        \n        # Unpack data and calculate proportions\n        counts_ctrl = np.array([d[1] for d in data], dtype=float)\n        totals_ctrl = np.array([d[0] for d in data], dtype=float)\n        counts_treat = np.array([d[3] for d in data], dtype=float)\n        totals_treat = np.array([d[2] for d in data], dtype=float)\n\n        # Avoid division by zero, although not present in test data\n        prop_ctrl = np.divide(counts_ctrl, totals_ctrl, out=np.zeros_like(counts_ctrl), where=totals_ctrl!=0)\n        prop_treat = np.divide(counts_treat, totals_treat, out=np.zeros_like(counts_treat), where=totals_treat!=0)\n\n        # Arcsine square root transformation (in radians) and calculate differences\n        transformed_ctrl = np.arcsin(np.sqrt(prop_ctrl))\n        transformed_treat = np.arcsin(np.sqrt(prop_treat))\n        \n        D = transformed_treat - transformed_ctrl\n\n        def calculate_statistic(diffs):\n            \"\"\"Calculates the studentized test statistic for a given set of differences.\"\"\"\n            n = len(diffs)\n            if n  2: return 0.0 # Standard deviation is not defined for n  2\n            \n            mean_d = np.mean(diffs)\n            std_d = np.std(diffs, ddof=1) # ddof=1 for unbiased sample std dev\n\n            if std_d == 0:\n                if mean_d == 0:\n                    return 0.0\n                else:\n                    return np.sign(mean_d) * np.inf\n            \n            return mean_d / (std_d / np.sqrt(n))\n\n        # Calculate observed statistic\n        t_obs = calculate_statistic(D)\n        \n        num_permutations = 2**n_donors\n        extreme_count = 0\n        \n        # Enumerate all 2^n sign patterns\n        for s in product([-1, 1], repeat=n_donors):\n            sign_vector = np.array(s)\n            d_perm = D * sign_vector\n            t_perm = calculate_statistic(d_perm)\n            \n            if np.abs(t_perm) >= np.abs(t_obs):\n                extreme_count += 1\n                \n        # Calculate permutation p-value\n        p_value = extreme_count / num_permutations\n        \n        # Decision rule\n        reject_null = p_value = alpha\n        results.append(reject_null)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2866321"}]}