## 引言
系统发育树，或称“[生命之树](@entry_id:139693)”，是现代[演化生物学](@entry_id:145480)的核心图标。它不仅以图形化的方式呈现了物种间的[亲缘关系](@entry_id:172505)，更提供了一个强大的分析框架，用以追溯数百万年乃至数十亿年的生命历史。从理解[物种多样性](@entry_id:139929)的起源到追踪疾病的传播，[系统发育分析](@entry_id:172534)已经渗透到生物学的各个角落，成为解答基础科学问题和应对实际挑战不可或缺的工具。

然而，一棵系统发育树的价值并不仅仅在于它的外观，而在于其背后严谨的数学原理、统计模型和生物学假设。对于研究者而言，仅仅生成一棵树是远远不够的；真正的挑战在于如何精确地解读其结构，审慎地评估其推断结果的可靠性，并创造性地将其应用于解决具体的科学问题。从纷繁复杂的性状数据中提炼出演化信号，并在多种推断方法中做出明智选择，是每一位演化生物学家的必修课。

本文旨在为研究生及相关领域的研究人员提供一个关于[系统发育分析](@entry_id:172534)的全面指南，系统地弥合理论与实践之间的鸿沟。我们将通过三个章节，循序渐进地构建您的知识体系。在第一章 **“原理与机制”** 中，我们将深入剖析[系统发育树](@entry_id:140506)的数学基础，详细介绍[最大简约法](@entry_id:168212)和[统计系统发育学](@entry_id:163123)的核心算法与模型。接下来的第二章 **“应用与跨学科联系”** 将展示这些理论工具的强大实践能力，通过一系列案例探讨如何重建演化时间线、检验适应性假说，乃至将[系统发育](@entry_id:137790)思想应用于[文化演化](@entry_id:165218)等前沿领域。最后，在第三章 **“动手实践”** 中，我们设计了一系列练习，帮助您巩固对关键概念的理解。

通过学习本文，您将不仅能够“阅读”系统发育树，更能够理解其“语言”，批判性地评估他人的研究，并充满信心地设计和执行自己的[系统发育分析](@entry_id:172534)。让我们首先从构建这门语言的基本语法开始——探索[系统发育分析](@entry_id:172534)的核心原理与机制。

## 原理与机制

本章将深入探讨[系统发育分析](@entry_id:172534)的核心原理与机制。在上一章介绍背景之后，我们将进入技术性细节，系统地剖析[系统发育树](@entry_id:140506)的结构、用于构建树的性状数据，以及推断[进化关系](@entry_id:175708)的主要方法学框架。本章旨在为您提供解读和评估系统发育假说的必备理论基础。

### 系统发育树的结构

从根本上说，一棵[系统发育树](@entry_id:140506)是对进化历史的图形化假说。为了精确地理解和操作这些假说，我们需要采用形式化的定义。

#### 树的数学表示：拓扑与枝长

在数学上，一棵关于一组分类单元 $X$ 的系统发育树被建模为一个连通的[无环图](@entry_id:272495) $T=(V,E)$，其中 $V$ 是顶点（或节点）的集合，$E$ 是边（或分支）的集合。树的[叶节点](@entry_id:266134)（或末端节点，度为1的顶点）通过一个标签函数 $\ell$ 与我们观察到的分类单元（如物种或基因）[一一对应](@entry_id:143935)。非[叶节点](@entry_id:266134)的内部节点代表了假定的[共同祖先](@entry_id:175919)。

一棵系统发育树包含两个核心信息要素：**拓扑 (topology)** 和 **枝长 (branch lengths)**。

**拓扑**是指树的连接模式或分支结构。它描述了分类单元之间的相对亲缘关系，即谁与谁构成姐妹群。拓扑由顶点的邻接关系决定，而不考虑枝条的具体长度或其在平面上的绘制方式。因此，对树的某些操作会保持其拓扑不变。例如，在一个内部节点上交换其子树的左右绘制顺序（即改变其[平面嵌入](@entry_id:263159)），并不会改变任何邻接关系，因此不会改变拓扑。同样，将所有枝长乘以一个正常数 $c$ 也不影响拓扑。更有趣的是，在一个边上插入一个度为2的新顶点（即细分一个分支），虽然在[图论](@entry_id:140799)上改变了图，但在系统发育中，这通常被认为不改变拓扑，因为它不改变由任何边切割所产生的分类单元[集合的划分](@entry_id:136683)（即“分裂”）。[@problem_id:2810388]

**枝长**是分配给树中每个边的非负实数值，用 $w:E \to \mathbb{R}_{\ge 0}$ 表示。枝长可以量化多种进化距离，例如，预期的每位点替换数、进化时间或[形态差异](@entry_id:172490)量。带有枝长的树称为“度量树”（metric tree）或“[系统发育图](@entry_id:166959)”（phylogram）。

#### [有根树](@entry_id:266860)与[无根树](@entry_id:199885)

[系统发育树](@entry_id:140506)的一个根本区别在于其是否**有根 (rooted)**。

一棵**[无根树](@entry_id:199885) (unrooted tree)** 描述了分类单元之间的[亲缘关系](@entry_id:172505)，但没有指定进化的方向。它展示了分类单元的分组，但没有指定任何一个节点是所有其他节点的[共同祖先](@entry_id:175919)。因此，在[无根树](@entry_id:199885)上，“祖先”和“后代”的概念是无意义的。它只编码了分类单元的分裂（bipartitions），即移除任意一条边会将所有分类单元分为两个[子集](@entry_id:261956)。

相反，一棵**[有根树](@entry_id:266860) (rooted tree)** 包含一个特殊的节点，称为**根 (root)**，它代表了树中所有分类单元的[最近共同祖先](@entry_id:136722)（Most Recent Common Ancestor, MRCA）。根的存在为树赋予了时间的流向，从根（最古老的祖先）指向叶节点（后代）。这使得我们能够明确定义祖先-后代关系，并对性状变化的极性（例如，从“原始”状态到“衍生”状态）进行推断。

从一棵[无根树](@entry_id:199885)中产生一棵[有根树](@entry_id:266860)的过程称为**生根 (rooting)**。最常用的方法是**外群生根 (outgroup rooting)**。该方法假设我们有一个或多个已知在系统发育上位于我们感兴趣的分类单元（即**内群 (ingroup)**）之外的外群。根被放置在连接外群和内群的枝上。这一操作至关重要，因为它确立了内群的[单系性](@entry_id:174362)，并为所有后续的[性状演化](@entry_id:165250)分析提供了时间框架。[@problem_id:2810392]

#### 树的[文本表示](@entry_id:635254)法：Newick格式

为了在计算机程序之间方便地交换树结构，生物信息学家开发了 **Newick 格式**。这是一种使用嵌套括号的[文本表示](@entry_id:635254)法，能够[编码树](@entry_id:271241)的拓扑、枝长和节点标签。其语法规则如下：
*   一对括号 `()` 定义一个子树或进化枝。
*   括号内的逗号 `,` 分隔姐妹群（即拥有相同直接祖先的节点）。
*   分类单元的名称（**标签 (labels)**）直接出现。
*   冒号 `:` 后面跟随一个数字，表示通向该标签或子树的枝的**枝长 (branch length)**。
*   一个分号 `;` 标志着树定义的结束。

例如，考虑 Newick 字符串 `((A:0.1,B:0.2):0.3,(C:0.2,D:0.2):0.3);`。[@problem_id:2810431] 我们可以这样解析它：
*   最外层的括号包含由一个逗号分隔的两个主要进化枝。
*   第一个进化枝是 `(A:0.1,B:0.2):0.3`。这表示 $A$ 和 $B$ 是姐妹群。通向 $A$ 的枝长为 $0.1$，通向 $B$ 的为 $0.2$。这个 $(A,B)$ 进化枝的祖先节点由一个长度为 $0.3$ 的枝连接到根。
*   第二个进化枝是 `(C:0.2,D:0.2):0.3`。这表示 $C$ 和 $D$ 是姐妹群，它们各自的枝长都是 $0.2$。这个 $(C,D)$ 进化枝由一个长度为 $0.3$ 的枝连接到根。
*   这个字符串代表了一棵[有根树](@entry_id:266860)，根是两个主要进化枝的连接点。所有内部节点都是**二分的 (bifurcating)**，即每个节点都有两个直接后代。

值得注意的是，如果一棵树的所有叶节点到根的路径总长度都相等，那么这棵树被称为**[超度量树](@entry_id:168934) (ultrametric tree)**。这通常在分子钟假设下解释为时间树。在上述例子中，从根到 $A$ 的路径长度是 $0.3 + 0.1 = 0.4$，而到 $B$、$C$、$D$ 的路径长度均为 $0.3 + 0.2 = 0.5$。由于路径长度不全相等，这棵树不是[超度量树](@entry_id:168934)。[@problem_id:2810431]

### 在树上定义关系

有了树的结构，我们就可以用精确的术语来描述分类单元之间的进化关系。

#### 单系、并系与复系

在系统发育中，任何一组分类单元都可以根据其在树上的关系被归类为以下三种之一：

*   **[单系群](@entry_id:142386) (monophyletic group)**：也称为**进化枝 (clade)**，它包含一个[共同祖先](@entry_id:175919)及其**所有**后代。这是现代系统学中唯一被认为是“自然”的分类单元。
*   **[并系群](@entry_id:147411) (paraphyletic group)**：包含一个共同祖先，但**并未包含其所有**后代。例如，传统意义上的“爬行动物”就是一个[并系群](@entry_id:147411)，因为它包含了爬行动物的[最近共同祖先](@entry_id:136722)，但排除了其后代——鸟类。
*   **复系群 (polyphyletic group)**：其成员来自不同的进化谱系，并且该群组不包含其所有成员的[最近共同祖先](@entry_id:136722)。例如，由蝙蝠和鸟类组成的“飞行动物”群就是一个复系群，因为它们的飞行能力是独立演化出来的（趋同演化）。

评估一个群组的性质必须在一棵[有根树](@entry_id:266860)的背景下进行，因为“祖先”和“后代”的概念依赖于根的位置。[@problem_id:2810392] 例如，在一个[无根树](@entry_id:199885)中，一个分裂（split）所定义的类群集合，只有在根位于连接该集合与其他类群的枝上时，才能成为一个[单系群](@entry_id:142386)。

考虑一棵拓扑为 `((A,B),(C,(D,E)))` 的[有根树](@entry_id:266860)。[@problem_id:2810359]
*   集合 $\{A,B\}$ 是一个[单系群](@entry_id:142386)，因为它包含了 $A$ 和 $B$ 的[最近共同祖先](@entry_id:136722)及其所有后代。同样，$\{D,E\}$ 和 $\{C,D,E\}$ 也是[单系群](@entry_id:142386)。
*   集合 $\{A,B,C\}$ 是一个[并系群](@entry_id:147411)。其[最近共同祖先](@entry_id:136722)是整棵树的根，但该集合排除了根的另外两个后代 $D$ 和 $E$。
*   集合 $\{B,D\}$ 是一个复系群。其[最近共同祖先](@entry_id:136722)是树的根，但该集合不仅排除了根的其他后代（$A,C,E$），其成员本身也并非彼此最亲近的亲戚。

#### 进化枝的形式化定义

为了消除[歧义](@entry_id:276744)，系统学家使用两种主要方式来形式化定义进化枝：

*   **基于节点的定义 (Node-based definition)**：通过指定两个或多个“内部指定符”（通常是现存物种），将进化枝定义为“这些指定符的[最近共同祖先](@entry_id:136722)及其所有后代”。例如，在树 `((A,B),(C,(D,E)))` 上，由 $C$ 和 $E$ 的[最近共同祖先](@entry_id:136722)定义的基于节点的进化枝恰好是 $\{C,D,E\}$。[@problem_id:2810359]

*   **基于分支的定义 (Branch-based definition)**：也称为基于谱系的定义（stem-based），它通过一个“内部指定符” $I$ 和一个“外部指定符” $E$ 来定义。该进化枝被定义为“包含 $I$ 但不包含 $E$ 的最广义进化枝”，或者等价地，“所有与 $I$ 的[亲缘关系](@entry_id:172505)比与 $E$ 的亲缘关系更近的分类单元”。例如，同样在该树上，如果我们将 $D$ 作为内部指定符，$A$ 作为外部指定符，那么生成的基于分支的进化枝是 $\{C,D,E\}$，因为它恰好是包含 $D$ 但不包含 $A$ 的最广义进化枝。[@problem_id:2810359]

### [系统发育](@entry_id:137790)数据的性质：性状与状态

[系统发育树](@entry_id:140506)是根据**性状 (characters)** 数据推断出来的。一个性状是生物体可遗传的、可观察的特征，它可以以不同的**状态 (states)** 存在。对性状进行正确的分类和编码是任何[系统发育分析](@entry_id:172534)的基石。[@problem_id:2810354]

#### 性状的类型

*   **离散性状 (Discrete characters)**：其状态是可数的、独立的类别。例如，“椎骨数量”（状态为28、29、30等）或“后骨盆棘的存在与否”（状态为存在、缺失）。
    *   **二元性状 (Binary characters)**：只有两个状态，如存在/缺失，通常编码为 `1` 和 `0`。
    *   **多状态性状 (Multistate characters)**：有三个或更多状态，如DNA位点的[核苷酸](@entry_id:275639)（A, C, G, T）或侧腹颜色（红、蓝、黄）。

*   **连续性状 (Continuous characters)**：其状态在一个区间或比率尺度上变化，理论上可以取任意小的差值。例如，以毫米为单位的体长。分析连续性状通常需要不同于离散性状的数学模型，例如基于布朗运动的模型，或者通过设定阈值将其“离散化”为几个类别（如“小”、“中”、“大”）。

#### [性状状态](@entry_id:151081)的编码：有序与无序

对于多状态的离散性状，一个关键的决定是如何处理不同状态之间的转变。

*   **无序编码 (Unordered coding)**：这是默认的假设，认为任何一个状态都可以通过一步演化转变为任何其他状态，且所有转变的“成本”都相等。这适用于状态之间没有明确的过渡顺序的情况。例如，对于侧腹颜色（红、蓝、黄），没有生物学理由认为从“红”到“黄”的转变必须经过“蓝”色阶段。在简约法分析中，这对应于 **Fitch 简约法**。

*   **有序编码 (Ordered coding)**：当[性状状态](@entry_id:151081)代表一个潜在定量轴上的连续等级时，这种编码是合理的。它假设演化必须逐步通过中间状态。例如，一个生物不可能从拥有28节椎骨直接演化到拥有30节，而必须经过29节的阶段。因此，对于“椎骨数量”或“按厚度分级的牙釉质层”（状态0, 1, 2）这类性状，有序编码是恰当的。在简约法分析中，这对应于 **Wagner 简约法**，其中从状态 $i$ 变为状态 $j$ 的成本是 $|i-j|$。

需要强调的是，使用整数（如0, 1, 2）标记状态本身并不意味着这些状态是有序的；这仅仅是一种编码便利。排序的理由必须来自外部的生物学假说。此外，**排序 (ordering)** 指定了状态间的邻接关系和转变成本，但并不预设演化的**极性 (polarity)**，即哪个状态是祖先状态。极性需要通过[外群分析](@entry_id:264592)等方法来推断。[@problem_id:2810354]

### [系统发育推断](@entry_id:182186)机制 I：[最大简约法](@entry_id:168212)

**[最大简约法](@entry_id:168212) (Maximum Parsimony, MP)** 是系统发育学中最古老也最直观的推断方法之一。其核心思想是**奥卡姆剃刀原理**：在所有可能的[树拓扑](@entry_id:165290)中，我们偏好那棵能够用最少演化步骤（即[性状状态](@entry_id:151081)变化次数）来解释我们观察到的末端性状数据的树。

#### 推断祖先状态：Fitch算法

对于一个给定的[树拓扑](@entry_id:165290)和一组末端分类单元的[性状状态](@entry_id:151081)（对于一个无序性状），我们可以使用 **[Fitch 算法](@entry_id:156591)**来计算该树所需的最小变化次数（即简约法得分），并推断内部节点的可能祖先状态。该算法包含两个阶段：[@problem_id:2810377]

1.  **[后序遍历](@entry_id:273478)（自下而上）**：
    从叶节点开始向上移动到根。对于每个内部节点 $v$，其子节点为 $c_1$ 和 $c_2$，其可能的状态集 $S(v)$ 按以下规则确定：
    *   如果子节点的状态集交集非空 ($S(c_1) \cap S(c_2) \neq \emptyset$)，则 $S(v) = S(c_1) \cap S(c_2)$。该节点不增加变化次数。
    *   如果子节点的状态集交集为空 ($S(c_1) \cap S(c_2) = \emptyset$)，则 $S(v) = S(c_1) \cup S(c_2)$。该节点的变化次数加1。
    树的总简约法得分是所有节点上增加的变化次数之和。

    以拓扑为 `((T1,T2),(T3,(T4,T5)))` 的树为例，末端状态为 $T_1=0, T_2=1, T_3=0, T_4=1, T_5=2$。
    *   节点 $v_{12}$（$T_1, T_2$的祖先）：$S(T_1)=\{0\}, S(T_2)=\{1\}$。交集为空，所以 $S(v_{12})=\{0,1\}$，得分加1。
    *   节点 $v_{45}$（$T_4, T_5$的祖先）：$S(T_4)=\{1\}, S(T_5)=\{2\}$。交集为空，所以 $S(v_{45})=\{1,2\}$，得分加1。
    *   节点 $v_{3,45}$（$T_3, v_{45}$的祖先）：$S(T_3)=\{0\}, S(v_{45})=\{1,2\}$。交集为空，所以 $S(v_{3,45})=\{0,1,2\}$，得分加1。
    *   根节点 $r$（$v_{12}, v_{3,45}$的祖先）：$S(v_{12})=\{0,1\}, S(v_{3,45})=\{0,1,2\}$。交集为 $\{0,1\}$，非空。所以 $S(r)=\{0,1\}$，得分加0。
    总简约法得分为 $1+1+1+0 = 3$ 步。

2.  **[前序遍历](@entry_id:263452)（自上而下）**：
    从根节点开始向下移动，为每个内部节点分配一个确定的状态，从而得到一种具体的最简约重建方案（Most Parsimonious Reconstruction, MPR）。
    *   为根节点 $r$ 从其状态集 $S(r)$ 中任选一个状态。
    *   对于每个子节点 $v$，如果其父节点分配的状态在其状态集 $S(v)$ 中，则将 $v$ 也分配为该状态。否则，可从 $S(v)$ 中任选一个状态。

    继续上面的例子，根节点的状态集是 $\{0,1\}$。如果我们选择根的状态为 $1$，我们可以向下推导出一种重建方案，其中总变化次数确实为3。[@problem_id:2810377]

#### 处理歧义性：ACCTRAN 与 DELTRAN

在某些情况下，一个节点的祖先状态可能存在**[歧义](@entry_id:276744) (ambiguity)**，即选择不同的状态都可以得到相同的总简约法得分。这会导致多种同样简约的重建方案（MPRs）。**ACCTRAN** 和 **DELTRAN** 是两种解决这种[歧义](@entry_id:276744)的优化标准，它们揭示了简约法背后隐藏的演化假说。[@problem_id:2810397]

*   **ACCTRAN (Accelerated Transformation)**：加速演化。它倾向于将性状变化尽可能早地（靠近根）放置在树上。这通常导致一个早期的获得（gain），随后在某些谱系中发生逆转（loss）。这种方案隐含的假设是：[趋同演化](@entry_id:263490)（平行获得）是罕见的，而性状丢失则相对普遍。

*   **DELTRAN (Delayed Transformation)**：延迟演化。它倾向于将性状变化尽可能晚地（靠近叶）放置在树上。这通常导致在多个谱系中发生独立的平行获得，而逆转事件则最少。这种方案隐含的假设是：性状丢失是罕见的，而平行获得则相对普遍。

考虑一个例子，外群状态为 $0$，内群状态为 $A=1, B=0, C=1, D=0, E=1$。总简约法得分为3步。
*   ACCTRAN会推断出：在内群的基部发生了一次 $0 \to 1$ 的获得，然后在 $B$ 和 $D$ 谱系中分别发生了一次 $1 \to 0$ 的丢失。总计：1次获得，2次丢失。
*   DELTRAN会推断出：祖先状态一直保持为 $0$，然后在 $A$, $C$, $E$ 三个谱系中分别独立发生了三次 $0 \to 1$ 的获得。总计：3次获得，0次丢失。

这两种方案的总变化数相同（均为3），但它们描绘了截然不同的演化故事。选择哪一种取决于研究者对特定[性状演化](@entry_id:165250)模式的先验判断。

### [系统发育推断](@entry_id:182186)机制 II：[统计系统发育学](@entry_id:163123)

与简约法不同，**[统计系统发育学](@entry_id:163123) (Statistical Phylogenetics)**（包括[最大似然](@entry_id:146147)法和贝叶斯推断）使用明确的**演化模型 (evolutionary model)** 来计算观察到数据的概率。

#### 连续时间马尔可夫模型：Mk模型

离散性状的演化通常被建模为**[连续时间马尔可夫链](@entry_id:276307) (Continuous-Time Markov Chain, CTMC)**。其中最简单的模型是 **Mk 模型**，它假设一个有 $k$ 个状态的性状，任何一个状态转变为任何其他不同状态的[瞬时速率](@entry_id:182981)都相等。[@problem_id:2810398]

该模型由一个 $k \times k$ 的**速率矩阵 $Q$** 定义：
*   对角[线元](@entry_id:196833)素 $q_{ii}$ 代表状态 $i$ 离开的速率，为负值。
*   非对角[线元](@entry_id:196833)素 $q_{ij}$ ($i \neq j$) 代表从状态 $i$ 转变为状态 $j$ 的[瞬时速率](@entry_id:182981)，为非负值。
*   矩阵的每一行之和必须为0，即 $q_{ii} = - \sum_{j \neq i} q_{ij}$。

对于所有 $i \neq j$，$q_{ij} = \mu$ 的 Mk 模型，其对角[线元](@entry_id:196833)素为 $q_{ii} = -(k-1)\mu$。通过矩阵指数运算，可以得到在时间 $t$ 后从状态 $i$ 变为状态 $j$ 的**转移[概率矩阵](@entry_id:274812) $P(t) = \exp(Qt)$**。对于 Mk 模型，其概率有解析解：
*   $p_{ii}(t) = \frac{1}{k} + \frac{k-1}{k} \exp(-k \mu t)$  (保持状态 $i$ 的概率)
*   $p_{ij}(t) = \frac{1}{k} - \frac{1}{k} \exp(-k \mu t)$  (从状态 $i$ 变为状态 $j$ 的概率)

当时间 $t \to \infty$ 时，系统达到一个**平稳分布 (stationary distribution)** $\pi$，其中每个状态的概率不再改变。对于对称的 Mk 模型，[平稳分布](@entry_id:194199)是均匀的，即 $\pi_i = 1/k$。在系统发育似然计算中，$\pi$ 通常被用作根节点状态的先验概率。[@problem_id:2810398]

#### [长枝吸引](@entry_id:141763)的挑战

统计方法的优势之一是能够处理简约法等方法难以应对的某些系统性偏差。其中最著名的就是**[长枝吸引](@entry_id:141763) (Long-Branch Attraction, LBA)**。[@problem_id:2810422]

LBA 是一种推断错误，当两个或多个谱系在很长的时间里独立演化时，它们会因为随机积累了大量变化而显得彼此相似。这些由**[趋同演化](@entry_id:263490) (homoplasy)** 造成的虚假相似性，会被那些倾向于最小化变化次数的方法（如简约法）错误地解释为共同祖先的证据（**同源性 (homology)**），从而将这些不相关的长枝错误地聚合在一起。

这种现象在所谓的“**Felsenstein 区**”尤为突出：一棵四分类单元的树，其中两条不相关的长外部枝被一条极短的内部枝隔开。在这种情况下：
*   **[最大简约法](@entry_id:168212)是统计上不一致的 (statistically inconsistent)**。这意味着随着数据量（如序列长度）的增加，它会越来越确信一个错误的拓扑。因为它无法区分由单次变化产生的真实信号（在短枝上发生）和由多次平行变化产生的噪声（在长枝上发生）。
*   **[最大似然](@entry_id:146147)法（使用正确的模型）是统计上一致的 (statistically consistent)**。因为它通过演化模型明确地考虑了在长枝上发生多次替换的可能性。因此，它能够正确地将观察到的相似性归因于高概率的趋同演化，而不是[共同祖先](@entry_id:175919)，从而推断出正确的树。

### 评估[系统发育推断](@entry_id:182186)的置信度

推断出一棵“最佳”树只是分析的第一步。我们还需要评估其结果的可靠性，特别是树中每个进化枝的可信度。

#### 非[参数自举](@entry_id:178143)法

**非[参数自举](@entry_id:178143)法 (Nonparametric Bootstrap)**，或称自助法，是一种在系统发育学中广泛使用的评估进化枝稳定性的统计技术。[@problem_id:2810363] 其基本过程如下：

1.  **重采样**：从原始的[多序列比对](@entry_id:176306)（包含 $L$ 个位点）中，通过**有放回地 (with replacement)** 随机抽样，生成一个新的、同样长度为 $L$ 的“[伪重复](@entry_id:176246)”比对数据。
2.  **重复推断**：对这个[伪重复](@entry_id:176246)数据集使用与原始分析完全相同的流程（例如，最大似然法）推断一棵树。
3.  **迭代**：重复以上步骤 $B$ 次（通常 $B \ge 1000$），得到 $B$ 棵自举树。
4.  **计算支持率**：对于原始最佳树上的每一个进化枝，计算它在这 $B$ 棵自举树中出现的频率。这个频率，称为**[自举支持率](@entry_id:164000) (bootstrap proportion)**，或自举值。

[自举支持率](@entry_id:164000)衡量的是一个进化枝在数据受到抽样扰动时的**稳定性**或**[可重复性](@entry_id:194541)**。一个高的自举值（例如 > 0.9）通常被解释为该进化枝在数据中拥有强烈的、一致的[系统发育信号](@entry_id:265115)。

一个至关重要的警示是：**[自举支持率](@entry_id:164000)不是[贝叶斯后验概率](@entry_id:197730)**。一个85%的自举值并不意味着“该进化枝有85%的概率是真实的”。它只是表示，在85%的[伪重复](@entry_id:176246)数据集中，我们能够重新推断出这个进化枝。这是两种来自不同统计学派（频率学派与贝叶斯学派）的概念。

此外，标准的位点自举法假设比对中的所有位点都是[独立同分布](@entry_id:169067)的。如果位点之间存在强烈的相关性（例如，由于连锁或共同的功能约束），这种方法可能会破坏真实的信号结构，导致对某些进化枝的支持率被错误地夸大。[@problem_id:2810363]