{"hands_on_practices": [{"introduction": "庞尼特方格 (Punnett square) 是预测遗传杂交结果不可或缺的可视化工具。然而，在研究生层面，理解其所代表的数学原理至关重要。本练习 [@problem_id:2819168] 旨在挑战您跳出方格的限制，仅使用概率论和孟德尔分离定律的基本法则，从第一性原理推导出经典的 $1:2:1$ 基因型比例，从而巩固您对这些比例如何产生的深刻理解。", "problem": "考虑一个二倍体生物中的单个常染色体基因座，其等位基因为 $A$ 和 $a$。两个杂合子亲本交配，因此亲本基因型为 $Aa \\times Aa$。假设满足经典孟德尔遗传条件：分离定律成立，因此每个杂合子亲本以相等的概率传递每个等位基因；配子随机结合；配子或合子之间不存在分离失真或存活率差异。仅使用这些基本原理以及概率的加法和乘法法则，按以下步骤进行，不要绘制庞尼特方格：\n\n(1) 为母方和父方的配子等位基因定义随机变量，每个变量的取值范围为 $\\{A,a\\}$。从第一性原理出发，将配子等位基因的联合分布形式化为一个 $2 \\times 2$ 的概率矩阵，其行对应于父方配子的等位基因，列对应于母方配子的等位基因。\n\n(2) 使用该矩阵和基因型是该基因座上等位基因的无序对的定义，推导出后代 $P(AA)$、$P(Aa)$ 和 $P(aa)$ 的精确值。\n\n将您的最终答案以单行矩阵 $(P(AA),\\,P(Aa),\\,P(aa))$ 的形式报告，其中条目以精确分数形式给出。不要四舍五入。", "solution": "设 $M$ 为代表母方配子贡献的等位基因的随机变量，设 $P$ 为代表父方配子贡献的等位基因的随机变量。双亲均为基因型为 $Aa$ 的杂合子。两个随机变量的样本空间都是等位基因集合 $\\{A, a\\}$。\n\n根据所述的分离定律，杂合子亲本以相等的概率传递其两个等位基因中的每一个。\n对于母方亲本（$Aa$），其配子中等位基因的概率为：\n$P(M = A) = \\frac{1}{2}$\n$P(M = a) = \\frac{1}{2}$\n\n同样，对于父方亲本（$Aa$），其配子中等位基因的概率为：\n$P(P = A) = \\frac{1}{2}$\n$P(P = a) = \\frac{1}{2}$\n\n**第（1）部分：配子等位基因的联合分布**\n问题陈述了配子是随机结合的。在概率论术语中，这意味着母方等位基因的选择和父方等位基因的选择是独立事件。一个特定的父方等位基因和一个特定的母方等位基因结合的联合概率由独立事件的乘法法则给出：\n$P(P=i, M=j) = P(P=i) \\times P(M=j)$，对于任何等位基因 $i, j \\in \\{A, a\\}$。\n\n我们现在可以构建 $2 \\times 2$ 的联合概率矩阵，其中行代表父方等位基因，列代表母方等位基因。\n\n第 $i$ 行和第 $j$ 列的条目是 $P(P=i, M=j)$。\n-   $P(P=A, M=A) = P(P=A) \\times P(M=A) = \\frac{1}{2} \\times \\frac{1}{2} = \\frac{1}{4}$。这是后代从父亲那里获得一个 $A$ 等位基因并从母亲那里获得一个 $A$ 等位基因的概率。\n-   $P(P=A, M=a) = P(P=A) \\times P(M=a) = \\frac{1}{2} \\times \\frac{1}{2} = \\frac{1}{4}$。这是后代从父亲那里获得一个 $A$ 等位基因并从母亲那里获得一个 $a$ 等位基因的概率。\n-   $P(P=a, M=A) = P(P=a) \\times P(M=A) = \\frac{1}{2} \\times \\frac{1}{2} = \\frac{1}{4}$。这是后代从父亲那里获得一个 $a$ 等位基因并从母亲那里获得一个 $A$ 等位基因的概率。\n-   $P(P=a, M=a) = P(P=a) \\times P(M=a) = \\frac{1}{2} \\times \\frac{1}{2} = \\frac{1}{4}$。这是后代从父亲那里获得一个 $a$ 等位基因并从母亲那里获得一个 $a$ 等位基因的概率。\n\n得到的联合概率矩阵是：\n$$\n\\begin{array}{c|cc}\n   M=A  M=a \\\\\n\\hline\nP=A  \\frac{1}{4}  \\frac{1}{4} \\\\\nP=a  \\frac{1}{4}  \\frac{1}{4}\n\\end{array}\n$$\n\n**第（2）部分：后代基因型概率的推导**\n后代的基因型是从亲本遗传的等位基因的无序对。我们使用联合概率矩阵和互斥事件的概率加法法则来计算三种可能基因型（$AA$、$Aa$ 和 $aa$）的概率。\n\n-   **基因型 $AA$ 的概率**：\n    纯合显性基因型 $AA$ 只能以一种方式形成：从父亲遗传一个 $A$ 等位基因，并从母亲遗传一个 $A$ 等位基因。这对应于单一结果 $(P=A, M=A)$。\n    $$P(AA) = P(P=A, M=A) = \\frac{1}{4}$$\n\n-   **基因型 $aa$ 的概率**：\n    纯合隐性基因型 $aa$ 也只能以一种方式形成：从父亲遗传一个 $a$ 等位基因，并从母亲遗传一个 $a$ 等位基因。这对应于单一结果 $(P=a, M=a)$。\n    $$P(aa) = P(P=a, M=a) = \\frac{1}{4}$$\n\n-   **基因型 $Aa$ 的概率**：\n    如果后代遗传一个 $A$ 等位基因和一个 $a$ 等位基因，则形成杂合基因型 $Aa$。这可以通过两种互斥的方式发生：\n    1.  后代从父亲那里遗传 $A$ 并从母亲那里遗传 $a$。这是事件 $(P=A, M=a)$。\n    2.  后代从父亲那里遗传 $a$ 并从母亲那里遗传 $A$。这是事件 $(P=a, M=A)$。\n\n    由于这些是互斥事件，形成杂合基因型的总概率是它们各自概率的总和（加法法则）：\n    $$P(Aa) = P(P=A, M=a) + P(P=a, M=A)$$\n    使用我们矩阵中的值：\n    $$P(Aa) = \\frac{1}{4} + \\frac{1}{4} = \\frac{2}{4} = \\frac{1}{2}$$\n\n后代基因型的概率为 $P(AA) = \\frac{1}{4}$、$P(Aa) = \\frac{1}{2}$ 和 $P(aa) = \\frac{1}{4}$。作为必要的检验，这些概率的总和必须为 $1$：$\\frac{1}{4} + \\frac{1}{2} + \\frac{1}{4} = 1$。计算是一致的。最终结果是这些概率的有序三元组。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{4}  \\frac{1}{2}  \\frac{1}{4}\n\\end{pmatrix}\n}\n$$", "id": "2819168"}, {"introduction": "现实世界中的遗传分析远不止简单的常染色体杂交，它还要求我们解读家族史，并根据新信息更新评估。本实践问题 [@problem_id:2819132] 深入探讨了X连锁遗传这一重要领域。它将指导您如何基于系谱图计算初始的携带者概率，并展示如何运用贝叶斯推理，根据新的证据修正该概率——这是遗传咨询和诊断的一项核心技能。", "problem": "一个单基因座X连锁隐性性状由突变等位基因 $a$ 和野生型等位基因 $A$ 决定。在完全外显的情况下，基因型为 $X^{a}Y$ 的男性患病，基因型为 $X^{A}Y$ 的男性未患病；女性仅在基因型为 $X^{a}X^{a}$ 时患病，而杂合子女性 $X^{A}X^{a}$ 是表型正常的携带者。除非另有说明，否则假设新发突变可忽略不计，且交配伴侣无亲缘关系且未患病。\n\n考虑一名女性 $W$，她的亲生兄弟 $B$ 患病，父亲 $F$ 未患病；母亲 $M$ 表型正常。第一部分：仅使用上述定义和性染色体的孟德尔分离定律，计算 $W$ 在有任何子女之前是杂合携带者的先验概率。第二部分：后来，$W$ 与一个无亲缘关系、未患病的男性伴侣育有一子 $S$，$S$ 表型正常。根据这一观察，使用基于孟德尔分离定律的条件概率第一性原理，更新 $W$ 是携带者的概率。\n\n将先验概率和更新后的概率都表示为精确分数。不要四舍五入。以行向量 $\\big(P_{\\text{prior}},\\,P_{\\text{posterior}}\\big)$ 的形式给出你的最终答案。", "solution": "设 $A$ 表示野生型等位基因，$a$ 表示单基因座X连锁性状的突变等位基因。基因型和相应的表型如下：\n- 男性：$X^{A}Y$ (未患病), $X^{a}Y$ (患病)\n- 女性：$X^{A}X^{A}$ (未患病), $X^{A}X^{a}$ (未患病的携带者), $X^{a}X^{a}$ (患病)\n\n该问题涉及一个家庭，包括一名女性 $W$、她的亲生兄弟 $B$、她的父亲 $F$ 和她的母亲 $M$。我们已知以下信息：\n- 兄弟 $B$ 患病，这意味着他的基因型是 $X^{a}Y$。\n- 父亲 $F$ 未患病，这意味着他的基因型是 $X^{A}Y$。\n- 母亲 $M$ 表型正常。\n\n由此，我们推断出母亲 $M$ 的基因型。儿子从母亲那里继承他的X染色体。由于兄弟 $B$ 的基因型为 $X^{a}Y$，他的母亲 $M$ 必须至少拥有一个 $X^{a}$ 等位基因。因为 $M$ 同时表型正常，她的基因型不可能是 $X^{a}X^{a}$。唯一剩下的可能性是母亲 $M$ 是一个杂合携带者，基因型为 $X^{A}X^{a}$。这是一个必然结论，而非概率性结论。\n\n**第一部分：先验概率**\n\n我们需要计算女性 $W$ 是杂合携带者的先验概率，记作 $P_{\\text{prior}}$。$W$ 是母亲 $M$（基因型 $X^{A}X^{a}$）和父亲 $F$（基因型 $X^{A}Y$）的女儿。\n\n女儿从母亲和父亲各继承一条X染色体。\n- 从她的父亲 $F$ ($X^{A}Y$)那里，她必须继承 $X^{A}$ 染色体。\n- 从她的母亲 $M$ ($X^{A}X^{a}$)那里，根据孟德尔分离定律，她继承 $X^{A}$ 等位基因或 $X^{a}$ 等位基因的概率各为 $\\frac{1}{2}$。\n\n因此，$W$ 可能的基因型是：\n1. 从母亲处遗传到 $X^{A}$：基因型为 $X^{A}X^{A}$（未患病，非携带者）。此事件的概率为 $\\frac{1}{2}$。\n2. 从母亲处遗传到 $X^{a}$：基因型为 $X^{A}X^{a}$（未患病，携带者）。此事件的概率为 $\\frac{1}{2}$。\n\n因此，$W$ 是携带者（$X^{A}X^{a}$）的先验概率恰好是：\n$$ P_{\\text{prior}} = P(W \\text{ is } X^{A}X^{a}) = \\frac{1}{2} $$\n\n**第二部分：后验概率**\n\n我们得到了新的信息：$W$ 有一个儿子 $S$，他表型正常。我们必须根据这个证据更新 $W$ 是携带者的概率。设 $C$ 为事件“$W$ 是携带者（$X^{A}X^{a}$）”，设 $NC$ 为事件“$W$ 是非携带者（$X^{A}X^{A}$）”。从第一部分，我们有先验概率：\n$$ P(C) = \\frac{1}{2} $$\n$$ P(NC) = \\frac{1}{2} $$\n\n设 $E$ 为证据“她的儿子 $S$ 未患病”。未患病的儿子必须具有基因型 $X^{A}Y$。我们希望计算后验概率 $P(C|E)$，即在给定证据 $E$ 的情况下 $W$ 是携带者的概率。我们应用贝叶斯定理：\n$$ P(C|E) = \\frac{P(E|C) P(C)}{P(E)} $$\n证据 $E$ 的总概率 $P(E)$ 由全概率定律给出：\n$$ P(E) = P(E|C) P(C) + P(E|NC) P(NC) $$\n所以，后验概率的完整表达式是：\n$$ P(C|E) = \\frac{P(E|C) P(C)}{P(E|C) P(C) + P(E|NC) P(NC)} $$\n\n现在我们必须确定条件概率（似然）：\n- $P(E|C)$：在 $W$ 是携带者（$X^{A}X^{a}$）的情况下，她儿子未患病（$X^{A}Y$）的概率。儿子从母亲那里获得他的X染色体。如果母亲是 $X^{A}X^{a}$，她将以 $\\frac{1}{2}$ 的概率传递 $X^{A}$ 等位基因，以 $\\frac{1}{2}$ 的概率传递 $X^{a}$ 等位基因。为了使儿子未患病（$X^{A}Y$），他必须遗传 $X^{A}$ 等位基因。因此，$P(E|C) = \\frac{1}{2}$。\n- $P(E|NC)$：在 $W$ 是非携带者（$X^{A}X^{A}$）的情况下，她儿子未患病（$X^{A}Y$）的概率。如果母亲是 $X^{A}X^{A}$，她只能传递 $X^{A}$ 等位基因。因此，她所生的任何儿子都必须是未患病的。因此，$P(E|NC) = 1$。\n\n将这些值代入 $P(C|E)$ 的公式中：\n$$ P_{\\text{posterior}} = P(C|E) = \\frac{(\\frac{1}{2}) \\cdot (\\frac{1}{2})}{(\\frac{1}{2}) \\cdot (\\frac{1}{2}) + (1) \\cdot (\\frac{1}{2})} $$\n$$ P_{\\text{posterior}} = \\frac{\\frac{1}{4}}{\\frac{1}{4} + \\frac{1}{2}} = \\frac{\\frac{1}{4}}{\\frac{3}{4}} = \\frac{1}{3} $$\n\n$W$ 是携带者的先验概率是 $\\frac{1}{2}$。在观察到她的第一个儿子未患病后，她作为携带者的更新（后验）概率降低到 $\\frac{1}{3}$。\n最终答案是有序对 $(P_{\\text{prior}}, P_{\\text{posterior}})$。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{1}{2}  \\frac{1}{3} \\end{pmatrix}}\n$$", "id": "2819132"}, {"introduction": "在生物信息学时代，将生物学原理转化为计算模型是一项至关重要的技能。本练习 [@problem_id:2819142] 要求您将单基因杂交的规则形式化为一个能够以编程方式生成庞尼特方格的精确算法。通过构建和验证这个模型，您将更深刻地体会到支撑孟德尔遗传学及其在计算生物学中应用的明确、无歧义的逻辑。", "problem": "实现一个程序，该程序能直接根据两个亲本基因型，为任何双等位基因单杂交构建一个旁氏表（Punnett square），并根据一个小测试套件的期望值验证所得的子代基因型分布。您的设计必须从以下基本原理和定义出发：(i) 孟德尔分离定律，即在一个杂合二倍体亲本中，两个等位基因分离，使得每个配子以相等的概率恰好接收到一个等位基因；(ii) 受精时配子随机结合；(iii) 基因型是单个基因座上的一对有序等位基因，此处限定为单个字母，大写表示显性等位基因，其小写对应字母表示隐性等位基因；(iv) 单杂交恰好涉及一个具有两个等位基因的基因座。基于这些原理，推导出一个通用算法，该算法通过计算两个亲本配子集的笛卡尔积来生成一个 $2 \\times 2$ 的旁氏表，并使用该方格来计算基因型概率。\n\n约束和假设：\n- 输入表示：每个亲本基因型以长度为 $2$ 的字符串形式提供，该字符串由单个字母组成，其大小写表示等位基因状态，例如 \"AA\"、\"Aa\"、\"aA\"、\"aa\"、\"Bb\"。一个基因型的两个字符必须是同一个字母（忽略大小写）；两个亲本必须涉及同一个字母（忽略大小写）。\n- 配子形成：根据孟德尔分离定律，纯合子产生两个相同的配子（均为相同等位基因），而杂合子产生两种不同的配子，每种概率为 $1/2$。\n- 旁氏表构建：总是使用第一个亲本的两个配子作为行标题，第二个亲本的两个配子作为列标题，来构建一个 $2 \\times 2$ 的方格。通过将行和列的等位基因组合成子代基因型来填充每个单元格，并通过将大写等位基因（如果存在）放在前面来进行规范化，例如，\"Aa\" 而不是 \"aA\"。\n- 概率模型：因为每一行和每一列被选择的概率均为 $1/2$，所以 $2 \\times 2$ 网格中的每个单元格的概率为 $1/4$。基因型分布是每种基因型类别（纯合显性 ($DD$)、杂合 ($DR$)、纯合隐性 ($RR$)）的相对频率，其中 $D$ 表示大写等位基因字母，$R$ 表示其小写对应字母。\n- 验证：对于每个测试用例，将计算出的分布与期望分布进行比较，每个分量使用 $10^{-9}$ 的绝对容差。\n\n程序任务：\n1. 实现一个例程，在给定两个亲本基因型的情况下，构建 $2 \\times 2$ 的旁氏表，并计算子代基因型概率分布，结果为一个包含三个浮点数的列表，顺序为 $[P(DD), P(DR), P(RR)]$。\n2. 使用以下测试套件验证该例程，其中每个用例的格式为（亲本$1$，亲本$2$，期望的 $[P(DD), P(DR), P(RR)]$）：\n   - (\"AA\", \"aa\", [$0$, $1$, $0$])\n   - (\"Aa\", \"Aa\", [$0.25$, $0.5$, $0.25$])\n   - (\"Aa\", \"aa\", [$0$, $0.5$, $0.5$])\n   - (\"Aa\", \"AA\", [$0.5$, $0.5$, $0$])\n   - (\"aa\", \"aa\", [$0$, $0$, $1$])\n   - (\"aA\", \"Aa\", [$0.25$, $0.5$, $0.25$])  // 顺序无关性检查\n   - (\"Bb\", \"Bb\", [$0.25$, $0.5$, $0.25$])  // 非\"A/a\"等位基因字母检查\n3. 您的程序应产生单行输出，其中包含验证结果，格式为用方括号括起来的逗号分隔列表，每个测试用例对应一个布尔值，顺序与上述相同，例如，如果运行了三个测试，则为 `\"[True,True,False]\"`。\n\n附加要求：\n- 程序不得请求用户输入，也不得从文件读取或向文件写入数据。\n- 所有浮点数的数值比较必须使用 $10^{-9}$ 的绝对容差。\n- 本问题不涉及物理单位。\n- 最终输出必须是符合指定格式的单行文本。", "solution": "算法推导如下：任务是为双等位基因单杂交构建一个计算模型。这将根据给定的原理系统地进行开发。\n\n**1. 从亲本基因型形成配子**\n亲本基因型，表示为 $G_p$，是一个长度为 $2$ 的字符串，由两个等位基因 $a_1$ 和 $a_2$ 组成。根据问题陈述，一个亲本为构建 $2 \\times 2$ 的旁氏表产生两个配子。这两个配子就是构成基因型的两个等位基因。\n设 $G_{p1}$ 和 $G_{p2}$ 分别为亲本 $1$ 和亲本 $2$ 的基因型。\n- 亲本 $1$ 的配子集 $S_1$ 是 `{`$G_{p1}[0], G_{p1}[1]$`}`。\n- 亲本 $2$ 的配子集 $S_2$ 是 `{`$G_{p2}[0], G_{p2}[1]$`}`。\n\n对于像 \"Aa\" 这样的杂合亲本，配子集是 `{`'A', 'a'`}`。对于像 \"AA\" 这样的純合亲本，配子集是 `{`'A', 'A'`}`，为了构建方格，我们必须将其视为两个不同的实体。\n\n**2. 作为笛卡尔积的旁氏表**\n旁氏表表示来自两个亲本的所有可能配子组合。这在形式上是两个配子集 $S_1 \\times S_2$ 的笛卡尔积。结果是一个包含 $2 \\times 2 = 4$ 个子代基因型的集合。\n设 $g_{1,i} \\in S_1$ 和 $g_{2,j} \\in S_2$，其中 $i, j \\in \\{1, 2\\}$。旁氏表的每个单元格包含一个由每个亲本的一个配子结合形成的子代基因型，即 `{`$g_{1,i}, g_{2,j}$`}`。\n\n**3. 子代基因型的规范化**\n问题要求基因型有规范的表示方法：显性（大写）等位基因必须出现在前面。对于形成子代的任意两个等位基因 $a_i, a_j$，基因型字符串 $G_o$ 通过对其进行排序来构建，使得 `str.islower` 是次要排序键（或等效地，`str.isupper` 是主要排序键）。\n例如，如果配子是 'a' 和 'A'，组合 `('a', 'A')` 被规范化为字符串 \"Aa\"。组合 `('B', 'b')` 被规范化为 \"Bb\"。\n\n**4. 概率计算**\n分离定律意味着，对于杂合亲本，两种不同等位基因中的每一种都以 $1/2$ 的概率传递给配子。对于纯合亲本，单一等位基因类型以概率 $1$ 传递。问题通过规定亲本集合 $S_p$ 中的两个配子（即使相同）中的每一个都以 $1/2$ 的概率被选中，从而简化了这一点。\n根据随机结合原理，任何特定配子组合 $g_{1,i}$ 和 $g_{2,j}$ 的概率是它们各自概率的乘积：`$P(g_{1,i} \\text{ and } g_{2,j}) = P(g_{1,i}) \\times P(g_{2,j}) = (1/2) \\times (1/2) = 1/4$`。\n这证实了给定的前提：旁氏表中的 $4$ 个单元格中的每一个都代表一个概率为 $1/4$ 的结果。\n\n为了找到一个基因型类别（例如，纯合显性，$DD$）的概率，我们必须将所有对应于该类别的结果的概率相加。设 $C(G_o)$ 是方格的 $4$ 个单元格中一个规范化基因型 $G_o$ 出现的次数。该基因型的概率是：\n`$$P(G_o) = \\frac{C(G_o)}{4}$$`\n\n最终的概率分布是一个包含三个值的列表：`$[P(DD), P(DR), P(RR)]$`。必须从输入基因型中识别出特定的等位基因字母（A、B等）。设该字母为 $L$。那么 $D = L.upper()$，$R = L.lower()$。所需的三个概率是 $P(DD), P(DR), P(RR)$。\n\n**算法综合**\n完整的算法如下：\n\n1.  **输入**：两个亲本基因型字符串，$G_{p1}$ 和 $G_{p2}$。\n2.  **识别等位基因**：从输入基因型中确定显性（$D$）和隐性（$R$）等位基因字符，例如，$D = G_{p1}[0].upper()$，$R = G_{p1}[0].lower()$。\n3.  **定义基因型类别**：为三种基因型类别构建字符串表示：$G_{DD} = D+D$，$G_{DR} = D+R$，$G_{RR} = R+R$。\n4.  **生成配子**：提取每个亲本的配子：$S_1 = list(G_{p1})$，$S_2 = list(G_{p2})$。\n5.  **初始化计数器**：为每个基因型类别创建计数器，并初始化为零：$C_{DD} = 0, C_{DR} = 0, C_{RR} = 0$。\n6.  **迭代和分类**：遍历所有 $4$ 种配子组合 $(g_1, g_2)$，其中 $g_1 \\in S_1$ 且 $g_2 \\in S_2$。\n    a. 对于每对 $(g_1, g_2)$，通过对等位基因排序来形成规范的子代基因型字符串 $G_o$。\n    b. 将 $G_o$ 与类别字符串进行比较，并增加相应的计数器。如果 $G_o = G_{DD}$，则 $C_{DD}$ 加一。如果 $G_o = G_{DR}$，则 $C_{DR}$ 加一。否则，$C_{RR}$ 加一。\n7.  **计算概率**：通过将每个计数除以 $4.0$ 来计算最终概率：\n    - `$P(DD) = C_{DD} / 4.0$`\n    - `$P(DR) = C_{DR} / 4.0$`\n    - `$P(RR) = C_{RR} / 4.0$`\n8.  **输出**：返回列表 `$[P(DD), P(DR), P(RR)]$`。\n\n该算法是将问题指定的第一性原理直接转换为确定性计算过程。它将被实现以验证测试套件。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef punnett_square_probabilities(parent1_genotype: str, parent2_genotype: str) -> list[float]:\n    \"\"\"\n    Computes offspring genotype probabilities from a bi-allelic monohybrid cross.\n\n    This function implements the principles of Mendelian genetics to derive the\n    probability distribution for offspring genotypes from two parental genotypes.\n\n    Args:\n        parent1_genotype: A string of length 2 representing the first parent's genotype (e.g., \"Aa\").\n        parent2_genotype: A string of length 2 representing the second parent's genotype (e.g., \"aa\").\n\n    Returns:\n        A list of three floats representing the probabilities of homozygous dominant (DD),\n        heterozygous (DR), and homozygous recessive (RR) offspring, in that order.\n    \"\"\"\n    # Principle 1: Gamete Formation\n    # Each parent contributes two gametes, which are the two alleles in its genotype.\n    gametes1 = list(parent1_genotype)\n    gametes2 = list(parent2_genotype)\n\n    # From the genotypes, determine the dominant (D) and recessive (R) allele characters.\n    # We can use the first allele of the first parent, as all alleles for a given\n    # cross must be the same letter.\n    allele_char = parent1_genotype[0]\n    dominant_allele = allele_char.upper()\n    recessive_allele = allele_char.lower()\n\n    # Define the canonical string representations for the three genotype classes.\n    homozygous_dominant_str = dominant_allele + dominant_allele\n    heterozygous_str = dominant_allele + recessive_allele\n    homozygous_recessive_str = recessive_allele + recessive_allele\n\n    # Initialize counters for each of the 4 possible offspring genotypes in the Punnett square.\n    offspring_genotype_counts = {\n        homozygous_dominant_str: 0,\n        heterozygous_str: 0,\n        homozygous_recessive_str: 0\n    }\n\n    # Principle 2  3: Punnett Square Construction and Canonicalization\n    # The Punnett square is the Cartesian product of the gamete sets. We iterate through it.\n    for gamete1 in gametes1:\n        for gamete2 in gametes2:\n            # Combine gametes to form an offspring's alleles.\n            offspring_alleles = [gamete1, gamete2]\n            \n            # Canonicalize the genotype string: dominant allele (uppercase) must be first.\n            # sorted() with a key is a clean way to enforce this rule.\n            # str.islower returns True for lowercase, False for uppercase.\n            # Sorting by this value (False=0, True=1) places uppercase letters first.\n            canonical_genotype = \"\".join(sorted(offspring_alleles, key=str.islower))\n            \n            # Increment the counter for the resulting genotype class.\n            if canonical_genotype in offspring_genotype_counts:\n                offspring_genotype_counts[canonical_genotype] += 1\n\n    # Principle 4: Probability Calculation\n    # Each of the 4 cells in the Punnett square has a probability of 1/4.\n    # The probability of a genotype is its count divided by the total number of cells (4).\n    total_outcomes = 4.0\n    prob_dd = offspring_genotype_counts[homozygous_dominant_str] / total_outcomes\n    prob_dr = offspring_genotype_counts[heterozygous_str] / total_outcomes\n    prob_rr = offspring_genotype_counts[homozygous_recessive_str] / total_outcomes\n    \n    return [prob_dd, prob_dr, prob_rr]\n\ndef solve():\n    \"\"\"\n    Runs the validation of the Punnett square routine against the specified test suite.\n    \"\"\"\n    # The test suite provided in the problem statement.\n    # Format: (parent1_genotype, parent2_genotype, expected_probabilities)\n    test_cases = [\n        (\"AA\", \"aa\", [0.0, 1.0, 0.0]),\n        (\"Aa\", \"Aa\", [0.25, 0.5, 0.25]),\n        (\"Aa\", \"aa\", [0.0, 0.5, 0.5]),\n        (\"Aa\", \"AA\", [0.5, 0.5, 0.0]),\n        (\"aa\", \"aa\", [0.0, 0.0, 1.0]),\n        (\"aA\", \"Aa\", [0.25, 0.5, 0.25]),  # Order-insensitivity check\n        (\"Bb\", \"Bb\", [0.25, 0.5, 0.25]),  # Non-\"A/a\" allele letter check\n    ]\n\n    validation_results = []\n    \n    # Absolute tolerance for floating-point comparisons.\n    tolerance = 1e-9\n\n    for case in test_cases:\n        parent1, parent2, expected = case\n        \n        # Calculate the probabilities using the derived function.\n        calculated = punnett_square_probabilities(parent1, parent2)\n        \n        # Validate the calculated distribution against the expected distribution.\n        # np.allclose is used for robust floating-point array comparison.\n        # rtol=0 ensures the comparison is based purely on the absolute tolerance (atol).\n        is_valid = np.allclose(calculated, expected, rtol=0, atol=tolerance)\n        validation_results.append(is_valid)\n\n    # Final print statement must produce the exact required format.\n    print(f\"[{','.join(map(str, validation_results))}]\")\n\nsolve()\n\n```", "id": "2819142"}]}