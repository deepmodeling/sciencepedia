{"hands_on_practices": [{"introduction": "在病毒学实验中，将病毒接种到细胞群体上是一个随机过程。这个练习将指导你从基本原理出发，推导出描述病毒感染分布的泊松分布模型 [@problem_id:2544916]。通过掌握感染复数（MOI）这一核心概念，你将能够计算在给定条件下未感染、单次感染和多次感染细胞的比例，并将其应用于理解病毒遗传互补等重要生物学现象。", "problem": "一个易感细胞的克隆群体暴露于裂解性病毒接种物中，其感染复数 (MOI) 为 $m = 0.3$。假设单个病毒粒子对特定细胞的吸附事件是独立且罕见的，每个细胞的总吸附事件数是许多具有很小成功概率的独立伯努利试验的总和。基于这一独立性假设和稀有事件定律，推导出每个细胞吸附的病毒粒子数量的分布，然后使用该分布计算群体分数。\n\n从第一性原理出发（即 $N$ 个病毒粒子在 $M$ 个细胞间的独立吸附，每个病毒粒子对每个细胞的命中概率为 $p = 1/M$，并在 $N \\to \\infty$，$p \\to 0$ 时保持 $m = Np$ 不变），推导一个给定细胞吸附的病毒粒子数 $K$ 的概率质量函数。然后，对于 $m = 0.3$，计算未感染细胞 ($K = 0$)、单一感染细胞 ($K = 1$) 和多重感染细胞 ($K \\ge 2$) 的比例。最后，考虑一个严格的遗传互补情景，其中产生有活力的病毒后代需要至少两个不同的病毒基因组共感染同一个细胞；在理想化假设下，任何具有 $K \\ge 2$ 共感染的细胞实现互补的概率为1，而 $K \\le 1$ 的细胞不发生互补。请确定在 MOI $m = 0.3$ 时，能够发生互补的细胞的预期比例。\n\n仅报告能够互补的细胞比例作为最终答案，以小数形式表示，并四舍五入到 $4$ 位有效数字。不要使用百分号。", "solution": "问题陈述经评估有效。这是一个定义明确的数学生物学问题，其基础是病毒感染动力学和统计力学的既定原理。假设陈述清晰，目标可量化。我们将继续进行求解。\n\n问题要求在指定的“稀有事件定律”极限条件下，推导吸附到单个细胞上的病毒粒子数 $K$ 的分布。给定 $N$ 个病毒粒子和 $M$ 个细胞。对于任何单个病毒粒子，其吸附到某个特定指定细胞的概率为 $p = 1/M$。每个病毒粒子对我们目标细胞的吸附都是一个独立的伯努利试验。因此，成功吸附事件的总数 $K$ 服从参数为 $N$（试验次数）和 $p$（成功概率）的二项分布：\n$$P(K=k) = \\binom{N}{k} p^k (1-p)^{N-k}$$\n问题要求我们考虑在 $N \\to \\infty$ 和 $M \\to \\infty$ 且感染复数 (MOI) $m = N/M$ 保持不变的极限情况。概率 $p$ 与 $m$ 和 $N$ 的关系为 $p = m/N$。当 $N \\to \\infty$ 而 $m$ 固定时，可推断出 $p \\to 0$。这是二项分布的经典泊松极限。我们进行正式推导。\n\n将 $p = m/N$ 代入二项概率质量函数：\n$$P(K=k) = \\frac{N!}{k!(N-k)!} \\left(\\frac{m}{N}\\right)^k \\left(1-\\frac{m}{N}\\right)^{N-k}$$\n我们重新排列各项来分析 $N \\to \\infty$ 时的极限：\n$$P(K=k) = \\frac{m^k}{k!} \\frac{N(N-1)\\cdots(N-k+1)}{N^k} \\left(1-\\frac{m}{N}\\right)^N \\left(1-\\frac{m}{N}\\right)^{-k}$$\n我们评估当 $N \\to \\infty$ 时每个部分的极限：\n1.  项 $\\frac{m^k}{k!}$ 与 $N$ 无关。\n2.  乘积 $\\frac{N(N-1)\\cdots(N-k+1)}{N^k} = \\frac{N}{N} \\cdot \\frac{N-1}{N} \\cdots \\frac{N-k+1}{N} = 1 \\cdot \\left(1-\\frac{1}{N}\\right) \\cdots \\left(1-\\frac{k-1}{N}\\right)$。对于任何固定的整数 $k$，当 $N \\to \\infty$ 时，这个乘积趋近于 $1$。\n3.  根据指数函数的定义，$\\lim_{N\\to\\infty} \\left(1-\\frac{m}{N}\\right)^N = \\exp(-m)$。\n4.  对于任何固定的 $k$，$\\lim_{N\\to\\infty} \\left(1-\\frac{m}{N}\\right)^{-k} = (1-0)^{-k} = 1$。\n\n结合这些结果，极限分布为：\n$$\\lim_{N\\to\\infty} P(K=k) = \\frac{m^k}{k!} \\cdot 1 \\cdot \\exp(-m) \\cdot 1 = \\frac{\\exp(-m) m^k}{k!}$$\n这是参数为 $m$ 的泊松分布的概率质量函数。在一个大群体中，被恰好 $k$ 个病毒粒子感染的细胞比例可以很好地用这个概率来近似。\n\n问题要求能够支持遗传互补的细胞比例。根据所述条件，当且仅当一个细胞被至少两个病毒粒子感染，即 $K \\ge 2$ 时，才会发生互补。这类细胞的比例，记作 $F_{comp}$，因此是 $P(K \\ge 2)$。更直接的计算方法是求其互补事件 $K=0$ 和 $K=1$ 的概率之和，然后用 $1$ 减去这个和。\n$$F_{comp} = P(K \\ge 2) = 1 - P(K  2) = 1 - \\big( P(K=0) + P(K=1) \\big)$$\n使用推导出的泊松概率质量函数 (PMF)：\n$$P(K=0) = \\frac{\\exp(-m) m^0}{0!} = \\exp(-m)$$\n$$P(K=1) = \\frac{\\exp(-m) m^1}{1!} = m \\exp(-m)$$\n将这些代入 $F_{comp}$ 的表达式中：\n$$F_{comp} = 1 - (\\exp(-m) + m \\exp(-m)) = 1 - (1+m)\\exp(-m)$$\n给定 MOI 为 $m = 0.3$。我们将这个值代入我们推导出的公式：\n$$F_{comp} = 1 - (1+0.3)\\exp(-0.3) = 1 - 1.3\\exp(-0.3)$$\n现在，我们计算数值。\n$$ \\exp(-0.3) \\approx 0.74081822 $$\n$$ F_{comp} \\approx 1 - 1.3 \\times 0.74081822 = 1 - 0.963063686 = 0.036936314 $$\n问题要求答案四舍五入到 $4$ 位有效数字。前四位有效数字是 $3$、$6$、$9$、$3$。第五位有效数字是 $6$，所以我们将第四位数字向上取整。\n$$ F_{comp} \\approx 0.03694 $$\n这就是群体中能够发生互补的细胞的预期比例。", "answer": "$$\\boxed{0.03694}$$", "id": "2544916"}, {"introduction": "病毒复制周期产生的病毒颗粒并非全部具有感染性，“颗粒与噬菌斑形成单位的比率”（particle-to-PFU ratio）是衡量病毒制剂质量的关键指标。本练习通过一个案例研究，让你学习如何运用这一比率来诊断病毒生命周期中的特定缺陷 [@problem_id:2544906]。你将通过分析和比较野生型与突变株（装配缺陷型和进入缺陷型）的实验数据，学习如何将定量检测结果与病毒复制的具体阶段（如装配或进入）联系起来。", "problem": "一种病毒制剂通过两种独立的检测方法进行表征，这两种方法探究病毒复制周期的不同阶段。噬菌斑测定法报告感染性病毒粒子的浓度，单位为噬菌斑形成单位 (PFU)，这反映了成功完成吸附、进入、基因组递送以及启动增殖性感染。一种衣壳保护的定量聚合酶链式反应 (qPCR) 检测，在经过核酸酶处理以去除未被衣壳包裹的核酸后进行，报告细胞外上清液中含基因组颗粒的浓度，这反映了成功完成组装和释放具有基因组包装能力的病毒粒子，无论其后续是否具有感染性。根据病毒学中使用的核心定义，给定病毒制剂的颗粒-PFU比率等于每个感染单位所含的基因组颗粒数量，而该比率的倒数是具有感染性的颗粒所占的比例。\n\n你分析了三种除特定突变外均为同基因的病毒株：野生型 (WT)、MutA (一种衣壳组装突变体) 和 MutE (一种进入/融合突变体)。对于每种病毒株，你在感染后的同一时间点，从澄清的上清液中测量了以下指标：\n- WT: 噬菌斑测定滴度为 $2.5 \\times 10^{8}$ PFU/mL，衣壳保护的qPCR基因组计数为 $1.0 \\times 10^{10}$ 基因组/mL。\n- MutA: 噬菌斑测定滴度为 $1.5 \\times 10^{8}$ PFU/mL，衣壳保护的qPCR基因组计数为 $4.5 \\times 10^{10}$ 基因组/mL。\n- MutE: 噬菌斑测定滴度为 $2.0 \\times 10^{7}$ PFU/mL，衣壳保护的qPCR基因组计数为 $1.2 \\times 10^{10}$ 基因组/mL。\n\n仅使用每种检测方法在病毒生命周期中所测量内容的基本定义（吸附和进入对应感染性；组装和释放对应含基因组颗粒的产生），首先根据所提供的数据推导出每种病毒株的颗粒-PFU比率。然后，将病毒株 $i$ 相对于野生型的颗粒-PFU比率的倍数变化定义为 $F_{i} = \\left(\\text{病毒株 } i \\text{ 的颗粒-PFU比率}\\right) \\Big/ \\left(\\text{WT 的颗粒-PFU比率}\\right)$。最后，计算比较指数\n$$\nR \\equiv \\frac{F_{\\mathrm{MutE}}}{F_{\\mathrm{MutA}}}\n$$\n将 $R$ 报告为一个纯数（无单位），并四舍五入到 $3$ 位有效数字。\n\n在你的推理中，利用复制周期的各个阶段（吸附、进入、合成、组装和释放），从机理上解释为什么组装缺陷与进入缺陷预期会以不同方式改变颗粒-PFU比率，以及为什么上述比率 $R$ 能够捕捉到这种差异。最终答案只应提供 $R$ 的单个数值。", "solution": "所提出的问题是基于标准病毒学检测方法对病毒感染性进行的定量分析。在进行解答之前，我们必须首先验证问题陈述的科学合理性、逻辑一致性和完整性。\n\n**问题验证**\n\n步骤1：提取已知条件\n- 噬菌斑测定法测量感染性病毒粒子的浓度，表示为噬菌斑形成单位/mL (PFU/mL)。该检测量化了吸附、进入和感染启动的成功完成。\n- 衣壳保护的定量聚合酶链式反应 (qPCR) 检测测量含基因组颗粒的浓度，单位为基因组/mL。该检测量化了病毒粒子组装和释放的成功完成。\n- 颗粒-PFU比率定义为每个感染单位的含基因组颗粒数。\n- 颗粒-PFU比率的倒数是具有感染性的颗粒所占的比例。\n- 提供了三种病毒株的实验数据：野生型 (WT)、一个组装突变体 (MutA) 和一个进入/融合突变体 (MutE)。\n- WT 数据：噬菌斑滴度为 $2.5 \\times 10^{8}$ PFU/mL；基因组计数为 $1.0 \\times 10^{10}$ 基因组/mL。\n- MutA 数据：噬菌斑滴度为 $1.5 \\times 10^{8}$ PFU/mL；基因组计数为 $4.5 \\times 10^{10}$ 基因组/mL。\n- MutE 数据：噬菌斑滴度为 $2.0 \\times 10^{7}$ PFU/mL；基因组计数为 $1.2 \\times 10^{10}$ 基因组/mL。\n- 病毒株 $i$ 相对于 WT 的颗粒-PFU比率的倍数变化定义为 $F_{i} = \\left(\\text{病毒株 } i \\text{ 的颗粒-PFU比率}\\right) \\Big/ \\left(\\text{WT 的颗粒-PFU比率}\\right)$。\n- 目标是计算比较指数 $R \\equiv \\frac{F_{\\mathrm{MutE}}}{F_{\\mathrm{MutA}}}$ 并将结果四舍五入到 $3$ 位有效数字。\n\n步骤2：使用提取的已知条件进行验证\n该问题具有科学依据，使用了定量病毒学的标准概念和方法。所提供的定义是正确和常规的。问题提取得当，因为所有必要的数据和关系都已明确给出，可以计算出唯一解。数据对于病毒制剂而言在数值上是合理的。没有矛盾、歧义或依赖伪科学之处。\n\n步骤3：结论与行动\n问题有效。我们现在将进行求解。\n\n**求解推导**\n\n设 $T_{i}$ 表示病毒株 $i$ 的噬菌斑测定滴度（单位：PFU/mL），$G_{i}$ 表示其衣壳保护的基因组计数（单位：基因组/mL），其中 $i \\in \\{\\text{WT, MutA, MutE}\\}$。\n\n颗粒-PFU比率，我们记为 $\\rho_{i}$，定义为含基因组颗粒的浓度与感染单位浓度的比值。\n$$\n\\rho_{i} = \\frac{G_{i}}{T_{i}}\n$$\n该比率是比感染性的一个反向度量；较高的值表示产生单个感染事件需要更多的物理颗粒，表明制剂中病毒颗粒的质量较低。\n\n从机理上讲，颗粒-PFU比率对病毒生命周期不同阶段的缺陷很敏感。qPCR检测量化了成功完成组装和释放的颗粒。噬菌斑测定除了量化这些，还要求颗粒能够成功完成吸附和进入。\n- 组装突变 (MutA) 影响病毒粒子本身的形成。这可能导致产生更多含有基因组的缺陷颗粒（$G_{\\text{MutA}}$ 较高），但这些颗粒结构不健全，因此无法感染（$T_{\\text{MutA}}$ 较低或减少）。这将导致比率 $\\rho_{\\text{MutA}}$ 相对于野生型 $\\rho_{\\text{WT}}$ 增加。\n- 进入突变 (MutE) 影响颗粒形成后的一个步骤。病毒粒子可能被正确组装和释放（$G_{\\text{MutE}}$ 可能接近正常值），但它们进入宿主细胞的功能受损。这导致对于给定数量的物理颗粒，感染单位（$T_{\\text{MutE}}$）急剧下降，从而显著增加比率 $\\rho_{\\text{MutE}}$。\n\n指数 $R = F_{\\mathrm{MutE}}/F_{\\mathrm{MutA}}$ 比较了进入突变体与组装突变体对单个颗粒感染性缺陷的严重程度，这是在将两者都与野生型基线进行归一化之后进行的比较。\n\n我们现在使用提供的数据计算必要的量。\n\n$1$. 计算每个病毒株的颗粒-PFU比率 ($\\rho_{i}$) :\n- 对于野生型 (WT):\n$T_{\\text{WT}} = 2.5 \\times 10^{8}$ PFU/mL\n$G_{\\text{WT}} = 1.0 \\times 10^{10}$ 基因组/mL\n$$\n\\rho_{\\text{WT}} = \\frac{G_{\\text{WT}}}{T_{\\text{WT}}} = \\frac{1.0 \\times 10^{10}}{2.5 \\times 10^{8}} = \\frac{100 \\times 10^{8}}{2.5 \\times 10^{8}} = 40\n$$\n- 对于组装突变体 (MutA):\n$T_{\\text{MutA}} = 1.5 \\times 10^{8}$ PFU/mL\n$G_{\\text{MutA}} = 4.5 \\times 10^{10}$ 基因组/mL\n$$\n\\rho_{\\text{MutA}} = \\frac{G_{\\text{MutA}}}{T_{\\text{MutA}}} = \\frac{4.5 \\times 10^{10}}{1.5 \\times 10^{8}} = \\frac{450 \\times 10^{8}}{1.5 \\times 10^{8}} = 300\n$$\n- 对于进入突变体 (MutE):\n$T_{\\text{MutE}} = 2.0 \\times 10^{7}$ PFU/mL\n$G_{\\text{MutE}} = 1.2 \\times 10^{10}$ 基因组/mL\n$$\n\\rho_{\\text{MutE}} = \\frac{G_{\\text{MutE}}}{T_{\\text{MutE}}} = \\frac{1.2 \\times 10^{10}}{2.0 \\times 10^{7}} = \\frac{1200 \\times 10^{7}}{2.0 \\times 10^{7}} = 600\n$$\n\n$2$. 计算相对于 WT 的倍数变化 ($F_{i}$) :\n- 对于 MutA:\n$$\nF_{\\text{MutA}} = \\frac{\\rho_{\\text{MutA}}}{\\rho_{\\text{WT}}} = \\frac{300}{40} = 7.5\n$$\n- 对于 MutE:\n$$\nF_{\\text{MutE}} = \\frac{\\rho_{\\text{MutE}}}{\\rho_{\\text{WT}}} = \\frac{600}{40} = 15\n$$\n\n$3$. 计算比较指数 $R$:\n$$\nR = \\frac{F_{\\mathrm{MutE}}}{F_{\\mathrm{MutA}}} = \\frac{15}{7.5} = 2\n$$\n\n结果是一个精确的整数 $2$。问题要求答案四舍五入到 $3$ 位有效数字。因此，我们将答案表示为 $2.00$。$R=2.00$ 这个值表明，MutE 中的特定进入缺陷导致的颗粒-PFU比率（相对于 WT）增加量是 MutA 中组装缺陷所导致的两倍。", "answer": "$$\n\\boxed{2.00}\n$$", "id": "2544906"}, {"introduction": "分节段病毒在复制过程中面临一个独特的挑战：必须将每个不同的基因组节段都包装进同一个病毒颗粒中，才能产生具有感染性的后代。这个练习将引导你建立一个计算模型，以探索这种“共包装问题”如何形成病毒复制的概率瓶颈 [@problem_id:2544941]。通过这个高级实践，你将学习如何运用概率论和编程来模拟这一复杂的生物学过程，从而理解分子水平的合成效率如何影响病毒的整体繁殖成功率。", "problem": "考虑一种分节段负链单链RNA（-ssRNA）病毒，该病毒需要 $S$ 个不同基因组节段各一个拷贝，才能组装成一个具感染性的病毒粒子。仅使用核心、经过充分检验的微生物学和概率论原理作为建模基础：\n- 在合成阶段，每个基因组节段独立复制，在一个复制周期内，每个受感染细胞中产生的拷贝数量是随机的。根据稀有事件定律和分子独立性假设，这些数量可以用独立的Poisson随机变量来建模。\n- 一个节段的拷贝以一定概率具备包装能力，且与其他拷贝相互独立；Poisson过程的稀疏化意味着具备包装能力的拷贝数量仍然服从Poisson分布。\n- 组装步骤需要每个节段恰好一个具备包装能力的拷贝；因此，每个受感染细胞中完全组装的感染性病毒粒子数量等于所有节段拷贝数中的最小值。\n- 附着/进入和释放步骤通过一个单个病毒粒子的成功因子来体现，该因子将释放的感染性病毒粒子数量映射到下一代新感染细胞的期望数量。\n\n将以下模型形式化。设 $S$ 为节段数。对于节段 $i \\in \\{1,\\dots,S\\}$，设 $\\mu_i$ 表示在一个复制周期内，每个受感染细胞在合成阶段产生的总拷贝数的期望值，设 $p_i \\in [0,1]$ 表示节段 $i$ 的一个给定拷贝具备包装能力的概率。节段 $i$ 的具备包装能力的拷贝数被建模为 $N_i \\sim \\mathrm{Poisson}(\\lambda_i)$，其中 $\\lambda_i = \\mu_i \\, p_i$，且各节段间相互独立。在一个周期内，从一个受感染细胞中释放的完全组装的感染性病毒粒子数量为 $V = \\min_{1 \\le i \\le S} N_i$。设 $\\beta  0$ 为有效的单个病毒粒子成功常数，它综合了附着、进入和产生有效感染的过程。由单个受感染细胞在下一复制周期产生的新感染细胞的期望数定义为 $R = \\beta \\, \\mathbb{E}[V]$。\n\n你的任务是编写一个程序，在给定 $S$、向量 $\\mu_i$、向量 $p_i$ 和 $\\beta$ 的情况下，通过仅使用第一性原理和标准概率恒等式，以足够的精度数值计算 $\\mathbb{E}[ \\min_{i} N_i ]$，从而求得 $R$。除了可以从定义以及Poisson和独立性假设推导出的公式外，不要假定任何简化公式。每个测试用例的输出必须是单个实数 $R$，四舍五入到 $6$ 位小数。\n\n测试套件：\n- A例（均衡合成）：$S = 3$，$ \\mu = [50, 50, 50]$，$p = [1, 1, 1]$，$\\beta = 0.02$。\n- B例（一个限制性节段）：$S = 3$，$ \\mu = [50, 50, 5]$，$p = [1, 1, 1]$，$\\beta = 0.02$。\n- C例（低拷贝数情况）：$S = 3$，$ \\mu = [1, 1, 1]$，$p = [1, 1, 1]$，$\\beta = 1$。\n- D例（包装能力瓶颈）：$S = 3$，$ \\mu = [40, 40, 40]$，$p = [0.5, 0.5, 0.1]$，$\\beta = 0.05$。\n- E例（无法组装）：$S = 3$，$ \\mu = [10, 0, 10]$，$p = [1, 1, 1]$，$\\beta = 1$。\n\n要求：\n- 你的程序必须通过对上述模型中的 $\\mathbb{E}[V]$ 进行数值收敛计算来求得每个案例的 $R$，而不是通过模拟，也不能依赖于并非从定义直接推导的封闭形式简化表达式。\n- 将每个 $R$ 四舍五入到 $6$ 位小数。\n- 最终输出格式：你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按A例到E例的顺序列出结果，例如 $[r_A,r_B,r_C,r_D,r_E]$，其中每个 $r_*$ 都是一个恰好有 $6$ 位小数的十进制数。\n- 答案中不要求物理单位，也不涉及角度。所有分数值必须是小数，而不是比例。", "solution": "所述问题在科学上是合理的、提法恰当、客观，并包含了获得唯一解所需的所有信息。该模型基于病毒学和概率论的既定原理，特别是使用泊松过程来建模分子数量，并从组件属性推导系统行为。所有指定测试用例的参数都已提供。因此，我将着手求解。\n\n核心任务是计算新感染细胞的期望数 $R$，由方程 $R = \\beta \\, \\mathbb{E}[V]$ 定义。这里，$\\beta$ 是一个给定的常数，$V$ 是在单个细胞中组装的感染性病毒粒子的数量。病毒粒子数受最稀缺的具备包装能力的基因组节段限制，因此 $V = \\min_{1 \\le i \\le S} N_i$。变量 $N_i$ 代表节段 $i$ 具备包装能力的拷贝数，并被建模为独立的泊松随机变量，$N_i \\sim \\mathrm{Poisson}(\\lambda_i)$，其率参数为 $\\lambda_i = \\mu_i p_i$。\n\n为计算 $R$，我们必须首先确定期望值 $\\mathbb{E}[V] = \\mathbb{E}[\\min_{1 \\le i \\le S} N_i]$。由于 $V$ 是一个非负整数值随机变量，其期望可以使用尾和公式计算，这通常比基于概率质量函数的直接定义更便于计算。该公式表述为：\n$$ \\mathbb{E}[V] = \\sum_{k=1}^{\\infty} P(V \\ge k) $$\n该恒等式推导如下：\n$$ \\mathbb{E}[V] = \\sum_{j=0}^{\\infty} j \\cdot P(V=j) = \\sum_{j=1}^{\\infty} j \\cdot P(V=j) = \\sum_{j=1}^{\\infty} \\sum_{k=1}^{j} P(V=j) $$\n通过改变求和顺序，我们得到：\n$$ \\mathbb{E}[V] = \\sum_{k=1}^{\\infty} \\sum_{j=k}^{\\infty} P(V=j) = \\sum_{k=1}^{\\infty} P(V \\ge k) $$\n\n事件 $\\{V \\ge k\\}$ 等价于事件 $\\{\\min_{1 \\le i \\le S} N_i \\ge k\\}$，它发生的充要条件是对于所有节段 $i \\in \\{1, \\dots, S\\}$ 都有 $N_i \\ge k$。\n$$ P(V \\ge k) = P(N_1 \\ge k, N_2 \\ge k, \\dots, N_S \\ge k) $$\n因为随机变量 $N_i$ 是独立的，所以联合概率是边际概率的乘积：\n$$ P(V \\ge k) = \\prod_{i=1}^{S} P(N_i \\ge k) $$\n项 $P(N_i \\ge k)$ 是参数为 $\\lambda_i$ 的泊松分布的生存函数。它是累积分布函数（CDF）在 $k-1$ 处的补集：\n$$ P(N_i \\ge k) = 1 - P(N_i \\le k-1) = 1 - \\sum_{m=0}^{k-1} \\frac{e^{-\\lambda_i} \\lambda_i^m}{m!} $$\n将此代入 $\\mathbb{E}[V]$ 的表达式中，我们得到用于数值计算的公式：\n$$ \\mathbb{E}[V] = \\sum_{k=1}^{\\infty} \\left( \\prod_{i=1}^{S} P(N_i \\ge k) \\right) $$\n\n为了实现数值解，这个无穷级数必须被截断。级数的项是正的，并随着 $k$ 的增加而减小，最终变得可以忽略不计。我们可以通过求和到一个足够大的整数 $K_{max}$ 来近似该和，选择的 $K_{max}$ 要使后续项的贡献小于预定义的数值公差 $\\epsilon$。算法如下：\n1. 对于给定的测试用例，使用参数 $S$、$\\{\\mu_i\\}_{i=1}^S$、$\\{p_i\\}_{i=1}^S$ 和 $\\beta$ 来计算每个节段的泊松率参数 $\\lambda_i = \\mu_i p_i$。\n2. 一个重要的边界情况是当任意 $\\lambda_i = 0$ 时。一个率为 $0$ 的泊松变量恒为 $0$ ($P(N_i=0)=1$)。在这种情况下，$V = \\min_i N_i = 0$，因此其期望 $\\mathbb{E}[V]$ 为 $0$，从而 $R = 0$。这在E例中出现。\n3. 对于所有 $\\lambda_i  0$ 的一般情况，我们将 $\\mathbb{E}[V]$ 的和初始化为 $0.0$。\n4. 我们从 $k = 1, 2, 3, \\dots$ 开始迭代。在每次迭代中，我们计算项 $T_k = \\prod_{i=1}^{S} P(N_i \\ge k)$。\n5. 每个节段的生存函数 $P(N_i \\ge k)$ 使用一个鲁棒的数值库函数（`scipy.stats.poisson.sf`）计算，该函数提供稳定而精确的评估。\n6. 将项 $T_k$ 加到 $\\mathbb{E}[V]$ 的运行总和中。\n7. 迭代继续，直到 $T_k$ 低于一个很小的公差（例如 $\\epsilon = 10^{-18}$），此时认为级数已收敛。\n8. 最终的期望值 $\\mathbb{E}[V]$ 乘以成功因子 $\\beta$ 以获得 $R$。\n9. 每个案例的结果 $R$ 按要求四舍五入到 $6$ 位小数。此过程应用于每个测试案例以生成最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import poisson\n\ndef compute_r(S, mu, p, beta):\n    \"\"\"\n    Computes the expected number of newly infected cells, R.\n\n    This function implements the numerical calculation of R based on the derived\n    tail-sum formula for the expectation of the minimum of independent Poisson\n    random variables.\n    \"\"\"\n    # Step 1: Calculate Poisson rate parameters lambda_i\n    # The parameters lambda_i = mu_i * p_i\n    lambdas = np.array(mu) * np.array(p)\n\n    # Step 2: Handle the edge case where a segment is not produced\n    # If any lambda_i is 0, then N_i is always 0, so min(N_i) is 0.\n    if np.any(lambdas == 0):\n        return 0.0\n\n    # Step 3: Compute E[V] using the tail-sum formula\n    # E[V] = sum_{k=1 to infinity} P(V >= k)\n    #      = sum_{k=1 to infinity} product_{i=1 to S} P(N_i >= k)\n    expected_v = 0.0\n    k = 1\n    # Tolerance for numerical convergence\n    tolerance = 1e-18\n\n    while True:\n        # P(N_i >= k) is the survival function at k-1\n        # scipy.stats.poisson.sf(k-1, lambda) computes P(N > k-1)\n        prob_ge_k_all_segments = poisson.sf(k - 1, lambdas)\n\n        # The term to be added in the sum\n        term_k = np.prod(prob_ge_k_all_segments)\n\n        # Check for convergence\n        if term_k  tolerance:\n            break\n\n        # Add term to the expectation\n        expected_v += term_k\n        k += 1\n\n    # Step 4: Calculate R\n    R = beta * expected_v\n    return R\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (S, mu, p, beta)\n        (3, [50, 50, 50], [1, 1, 1], 0.02),      # Case A\n        (3, [50, 50, 5], [1, 1, 1], 0.02),       # Case B\n        (3, [1, 1, 1], [1, 1, 1], 1.0),          # Case C\n        (3, [40, 40, 40], [0.5, 0.5, 0.1], 0.05),# Case D\n        (3, [10, 0, 10], [1, 1, 1], 1.0)         # Case E\n    ]\n\n    results = []\n    for S, mu, p, beta in test_cases:\n        r_val = compute_r(S, mu, p, beta)\n        # Format the result to 6 decimal places.\n        results.append(f\"{r_val:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2544941"}]}