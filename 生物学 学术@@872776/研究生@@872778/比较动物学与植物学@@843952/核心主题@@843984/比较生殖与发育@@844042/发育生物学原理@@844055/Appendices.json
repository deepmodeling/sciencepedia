{"hands_on_practices": [{"introduction": "形态发生素梯度是发育生物学中解释模式形成的基本机制之一。这个练习将探讨经典的“合成-扩散-降解”模型，该模型是定量理解梯度形成的核心框架。通过推导稳态下的浓度分布，我们可以揭示一个关键参数——特征长度尺度，它从物理上限制了可被此机制调控的组织尺寸[@problem_id:2604622]。", "problem": "在动物胚胎和植物分生组织中，可扩散的形态发生素会建立浓度梯度，该梯度可为细胞命运决定编码位置信息。考虑一个占据 $x \\ge 0$ 的一维组织，在 $x=0$ 处有一个局域的形态发生素源。假设在组织内，形态发生素进行扩散，扩散系数为 $D$，并以速率常数 $k$ 进行一级移除（例如，通过降解或受体介导的吸收）。从带有一级损失项的菲克第二定律出发，\n$$\n\\frac{\\partial c(x,t)}{\\partial t} \\;=\\; D\\frac{\\partial^{2} c(x,t)}{\\partial x^{2}} \\;-\\; k\\,c(x,t),\n$$\n推导远离源的 $x>0$ 区域的稳态浓度分布 $c(x)$，并通过考察其空间依赖性，确定决定 $c(x)$ 随距离衰减快慢的涌现特征长度尺度。然后，使用该特征长度，计算当肽形态发生素的 $D = 9.0\\,\\mu\\mathrm{m}^{2}\\,\\mathrm{s}^{-1}$ 和 $k = 2.2 \\times 10^{-4}\\,\\mathrm{s}^{-1}$ 时，该长度的数值。\n\n在您的推导中，将源视为局域在 $x=0$ 处，并施加物理上合理的条件，即当 $x \\to \\infty$ 时 $c(x)$ 保持有限。您可以假设在 $x=0$ 处的任何特定于源的边界条件仅确定 $c(x)$ 的振幅，而不改变远离源的空间衰减率。\n\n根据您的推导，解释该特征长度如何限制了位置信息能够在不同分类群的组织中（例如，在脊椎动物的肢芽与植物的根分生组织中）被可靠编码的空间范围。\n\n以微米为单位表示特征长度的最终数值，并将答案四舍五入到四位有效数字。", "solution": "在尝试任何解答之前，将首先分析所述问题的有效性。\n\n首先，逐字提取问题的已知条件。\n1.  系统是一个 $x \\ge 0$ 的一维组织。\n2.  在 $x=0$ 处存在一个局域的形态发生素源。\n3.  形态发生素浓度 $c(x,t)$ 的控制偏微分方程是带有一级损失项的菲克第二定律：$\\frac{\\partial c(x,t)}{\\partial t} = D\\,\\frac{\\partial^{2} c(x,t)}{\\partial x^{2}} - k\\,c(x,t)$。\n4.  扩散系数为 $D$。一级移除速率常数为 $k$。\n5.  必须推导出 $x>0$ 的稳态浓度分布 $c(x)$。\n6.  必须从 $c(x)$ 的空间依赖性中确定一个特征长度尺度。\n7.  必须计算在 $D = 9.0\\,\\mu\\mathrm{m}^{2}\\,\\mathrm{s}^{-1}$ 和 $k = 2.2 \\times 10^{-4}\\,\\mathrm{s}^{-1}$ 条件下该长度尺度的数值。\n8.  给出了一个边界条件：当 $x \\to \\infty$ 时 $c(x)$ 必须保持有限。\n9.  做出了一个假设：$x=0$ 处的源固定了 $c(x)$ 的振幅，但不改变其空间衰减率。\n10. 需要解释该长度尺度如何限制位置信息的空间范围。\n11. 最终数值答案必须以微米为单位，并四舍五入到四位有效数字。\n\n现在，评估该问题的有效性。\n该问题具有科学依据。它提出了一个标准的反应-扩散模型，这是定量发育生物学中解释形态发生素梯度形成的基石。其控制方程是一个公认的线性偏微分方程。该问题是适定的；它要求解一个具有物理上合理边界条件的微分方程的稳态解，这会导出一个唯一的衰减函数形式。语言客观而精确。所提供的参数对于细胞环境中的生物分子扩散和降解是物理上现实的。该问题并非无足轻重；它需要正确应用数学方法来解微分方程，并随后在生物学背景下解释解的参数。满足了有效问题的所有标准。因此，该问题被认为是有效的，我将继续进行解答。\n\n出发点是浓度 $c(x,t)$ 的控制方程：\n$$\n\\frac{\\partial c(x,t)}{\\partial t} = D\\,\\frac{\\partial^{2} c(x,t)}{\\partial x^{2}} - k\\,c(x,t)\n$$\n为了找到稳态浓度分布，我们必须施加浓度不随时间变化的条件。在数学上，这对应于将时间导数设为零：$\\frac{\\partial c}{\\partial t} = 0$。因此，该偏微分方程简化为关于稳态分布 $c(x)$ 的二阶常微分方程（ODE）：\n$$\n0 = D\\,\\frac{d^{2} c}{d x^{2}} - k\\,c(x)\n$$\n该方程通常被重排为具有常系数的线性齐次常微分方程的标准形式：\n$$\n\\frac{d^{2} c}{d x^{2}} - \\frac{k}{D}c(x) = 0\n$$\n为了解这个常微分方程，我们假设一个形式为 $c(x) = \\exp(rx)$ 的解，并将其代入方程，得到参数 $r$ 的特征方程：\n$$\nr^{2} - \\frac{k}{D} = 0\n$$\n该特征方程的根是 $r_{1,2} = \\pm\\sqrt{\\frac{k}{D}}$。$c(x)$ 的通解是与这些根对应的两个独立解的线性组合：\n$$\nc(x) = A\\,\\exp\\left(\\sqrt{\\frac{k}{D}}x\\right) + B\\,\\exp\\left(-\\sqrt{\\frac{k}{D}}x\\right)\n$$\n其中 $A$ 和 $B$ 是待由边界条件确定的常数。\n\n问题指定了两个边界条件。首先，当与源的距离趋于无穷大时，浓度必须保持有限，即当 $x \\to \\infty$ 时，$c(x)$是有界的。由于 $D$ 和 $k$ 都是正的物理常数，项 $A\\,\\exp\\left(\\sqrt{\\frac{k}{D}}x\\right)$ 随着 $x \\to \\infty$ 无界增长。为了满足有限浓度的条件，系数 $A$ 必须为零。这将解简化为：\n$$\nc(x) = B\\,\\exp\\left(-\\sqrt{\\frac{k}{D}}x\\right)\n$$\n第二个边界条件与 $x=0$ 处的源有关。问题指出，该条件设定了浓度分布的振幅。我们可以将源处的浓度定义为 $c(0) = c_0$。将 $x=0$ 代入我们的解中，得到 $c(0) = B\\,\\exp(0) = B$。因此，常数 $B$ 等于源处的浓度 $c_0$。完整的稳态浓度分布为：\n$$\nc(x) = c_0\\,\\exp\\left(-\\sqrt{\\frac{k}{D}}x\\right)\n$$\n问题要求确定控制空间衰减的特征长度尺度。解显示了随距离 $x$ 的指数衰减。一个通用的指数衰减函数写作 $f(x) = f_0 \\exp(-x/\\lambda)$，其中 $\\lambda$ 是函数值减小为原来的 $e$ 分之一所经过的特征长度尺度。通过将我们推导的解与此通用形式进行比较：\n$$\n\\exp\\left(-\\frac{x}{\\lambda}\\right) = \\exp\\left(-x\\sqrt{\\frac{k}{D}}\\right)\n$$\n我们可以令指数相等，从而确定特征长度尺度 $\\lambda$：\n$$\n\\lambda = \\sqrt{\\frac{D}{k}}\n$$\n这个长度尺度，通常称为衰减长度或空间常数，由扩散系数与移除速率常数的比值决定。它代表了形态发生素浓度从其源头值下降到 $1/e$（约 $37\\%$）时所经过的距离。\n\n现在，我们使用给定的参数计算 $\\lambda$ 的数值：$D = 9.0\\,\\mu\\mathrm{m}^{2}\\,\\mathrm{s}^{-1}$ 和 $k = 2.2 \\times 10^{-4}\\,\\mathrm{s}^{-1}$。\n$$\n\\lambda = \\sqrt{\\frac{9.0\\,\\mu\\mathrm{m}^{2}\\,\\mathrm{s}^{-1}}{2.2 \\times 10^{-4}\\,\\mathrm{s}^{-1}}} = \\sqrt{\\frac{9.0}{2.2 \\times 10^{-4}}}\\,\\mu\\mathrm{m}\n$$\n进行计算：\n$$\n\\lambda = \\sqrt{40909.0909...}\\,\\mu\\mathrm{m} \\approx 202.2600...\\,\\mu\\mathrm{m}\n$$\n按照指示，将结果四舍五入到四位有效数字：\n$$\n\\lambda \\approx 202.3\\,\\mu\\mathrm{m}\n$$\n最后，必须解释该特征长度的生物学意义。长度尺度 $\\lambda$ 从根本上限制了可以通过简单形态发生素梯度进行模式发育的组织的物理尺寸。为了让梯度能够编码位置信息，处于不同位置的细胞必须能够区分不同的局部形态发生素浓度。如果待模式发育的组织的长度 $L$ 远大于 $\\lambda$（例如，$L \\gg 3\\lambda$），那么在组织的大部分区域，浓度将衰减到可忽略的水平（$c  c_0 e^{-3} \\approx 0.05 c_0$）。在这种大组织情况下，梯度在源附近过于陡峭，而在远离源的地方实际上是平坦的（为零），这意味着大多数细胞经历的是相同的最低浓度，因此无法确定其位置。相反，如果组织与 $\\lambda$ 相比非常小（$L \\ll \\lambda$），指数函数可以近似为线性函数（$c(x) \\approx c_0(1-x/\\lambda)$），但整个组织内的浓度总变化很小，这可能使细胞难以在固有的生物化学噪声之上分辨出浓度差异。\n\n因此，这种扩散-降解机制在对尺寸为特征长度 $\\lambda$ 的几倍数量级的组织进行模式发育时最为有效。对于计算出的 $\\lambda \\approx 202.3\\,\\mu\\mathrm{m}$ 的值，该机制非常适合对几百微米范围的场进行模式发育，这个尺度对于像植物的根尖分生组织或昆虫的成虫盘这样的结构是很常见的。对于更大的结构，例如长度可达几毫米的脊椎动物肢芽，具有这种衰减长度的简单梯度不足以指定整个结构的位置。这意味着较大的生物体必须采用更复杂的模式发育策略，例如产生稳定图案的反应-扩散网络（Turing patterns）、顺序诱导、细胞传播信号的信号中继，或者动态调节参数 $D$ 和 $k$ 以使梯度与生长的组织尺寸相匹配。因此，$\\lambda$ 的值是一个关键的生物物理参数，它将分子特性（$D$, $k$）与宏观发育结果（器官大小和模式）联系起来。", "answer": "$$\n\\boxed{202.3}\n$$", "id": "2604622"}, {"introduction": "与基于扩散的梯度不同，许多生物学模式是通过局部细胞间的通讯和反馈产生的。本练习将介绍侧向抑制，一种通过Notch-Delta信号通路在相邻细胞间建立差异的强大机制。我们将运用动力学系统理论来分析一个双细胞模型，通过寻找系统的稳态并分析其稳定性，理解一个初始均一的细胞群体是如何自发地发生对称性破缺，从而产生细胞分化的[@problem_id:2604680]。", "problem": "考虑一个 Notch-Delta 侧向抑制的最小双细胞模型，该模型适用于发育中组织内的相邻上皮细胞。令 $N_i(t)$ 表示细胞 $i \\in \\{1,2\\}$ 中激活的 Notch 水平，令 $D_i(t)$ 表示细胞 $i$ 中的 Delta 配体水平。转录和翻译后过程通过常微分方程在粗粒度水平上表示，这些方程基于 (i) 相邻细胞的 Delta 对 Notch 的饱和式反式激活，以及 (ii) 细胞自身的 Notch 对 Delta 生成的双曲抑制。假设 $N_i$ 和 $D_i$ 均具有一阶周转（降解或有效清除）。该模型为\n$$\n\\frac{dN_i}{dt} \\;=\\; \\alpha_N \\,\\frac{D_j}{K_T + D_j} \\;-\\; \\beta_N \\, N_i,\\quad j \\neq i,\n$$\n$$\n\\frac{dD_i}{dt} \\;=\\; \\alpha_D \\,\\frac{1}{1 + \\frac{N_i}{K_C}} \\;-\\; \\beta_D \\, D_i,\n$$\n其中 $K_T$ 和 $K_C$ 分别是设定激活和抑制尺度的正常数，而 $\\alpha_N,\\beta_N,\\alpha_D,\\beta_D$ 是正的动力学参数。该公式建立在标准的生物化学动力学假设之上：用于 Notch 激活的饱和式配体-受体相互作用和用于 Delta 生成的双曲抑制，以及一阶周转。\n\n假设以下参数值和单位：$\\alpha_N = 2\\,\\text{h}^{-1}$，$\\beta_N = 1\\,\\text{h}^{-1}$，$\\alpha_D = 1\\,\\text{h}^{-1}$，$\\beta_D = 1\\,\\text{h}^{-1}$，$K_T = 1$（任意浓度单位），$K_C = 1$（相同浓度单位）。所有状态变量 $N_i,D_i$ 均以相同的任意浓度单位度量；时间以小时为单位度量。\n\n任务：\n- 仅使用上述定义和方程，推导双细胞系统的所有不动点 $(N_1^{\\ast},N_2^{\\ast},D_1^{\\ast},D_2^{\\ast})$。明确找出其中 $N_1^{\\ast} = N_2^{\\ast}$ 和 $D_1^{\\ast} = D_2^{\\ast}$ 的对称不动点。\n- 通过计算雅可比矩阵及其特征值，将动力学在对称不动点附近线性化。将线性化后的动力学分解为对称和反对称扰动模式，以从第一性原理评估稳定性。\n- 指出对称不动点对于对称和反对称扰动是稳定还是不稳定的，并报告在对称不动点处完整雅可比矩阵的主导特征值（实部最大的那个）。以每小时为单位表示最终增长率。以单个精确的封闭形式表达式提供最终答案（不需要数值四舍五入，且最终答案框中不包含单位）。", "solution": "该问题在科学上和数学上都是适定的，我们将继续进行解答。\n\n该动力学系统由以下常微分方程描述：\n$$\n\\frac{dN_i}{dt} = \\alpha_N \\frac{D_j}{K_T + D_j} - \\beta_N N_i, \\quad j \\neq i\n$$\n$$\n\\frac{dD_i}{dt} = \\alpha_D \\frac{1}{1 + \\frac{N_i}{K_C}} - \\beta_D D_i\n$$\n给定的参数为：$\\alpha_N = 2$, $\\beta_N = 1$, $\\alpha_D = 1$, $\\beta_D = 1$, $K_T = 1$, $K_C = 1$。\n\n**1. 寻找不动点**\n不动点满足 $\\frac{dN_i}{dt} = 0$ 和 $\\frac{dD_i}{dt} = 0$。\n$$\nN_i^* = \\frac{\\alpha_N}{\\beta_N} \\frac{D_j^*}{K_T + D_j^*} = 2 \\frac{D_j^*}{1 + D_j^*}\n$$\n$$\nD_i^* = \\frac{\\alpha_D}{\\beta_D} \\frac{1}{1 + N_i^*/K_C} = \\frac{1}{1 + N_i^*}\n$$\n**对称不动点**：设 $N_1^* = N_2^* = N^*$ 且 $D_1^* = D_2^* = D^*$。方程变为：\n$$\nN^* = \\frac{2D^*}{1+D^*} \\quad \\text{和} \\quad D^* = \\frac{1}{1+N^*}\n$$\n将第一个方程代入第二个方程：\n$$\nD^* = \\frac{1}{1 + \\frac{2D^*}{1+D^*}} = \\frac{1+D^*}{1+D^*+2D^*} = \\frac{1+D^*}{1+3D^*}\n$$\n$D^*(1+3D^*) = 1+D^* \\implies D^* + 3(D^*)^2 = 1+D^* \\implies 3(D^*)^2 = 1$。\n由于浓度必须为非负值，我们取正根：$D^* = \\frac{1}{\\sqrt{3}}$。\n代回求 $N^*$：$N^* = \\frac{1}{D^*} - 1 = \\sqrt{3} - 1$。\n因此，对称不动点为 $(\\sqrt{3}-1, \\sqrt{3}-1, 1/\\sqrt{3}, 1/\\sqrt{3})$。\n\n**所有不动点**：将一个细胞的方程代入另一个细胞的方程。从 $D_i = 1/(1+N_i)$，我们有 $N_i = 1/D_i-1$。代入 $N_j$ 的方程：\n$1/D_j - 1 = 2 \\frac{D_i}{1+D_i} \\implies \\frac{1-D_j}{D_j} = \\frac{2D_i}{1+D_i}$。\n这必须对 $(i,j)=(1,2)$ 和 $(i,j)=(2,1)$ 都成立。考虑函数 $F(D) = \\frac{1}{1+N(D)} = \\frac{1}{1 + 2D/(1+D)} = \\frac{1+D}{1+3D}$。不动点必须满足 $D_2^*=F(D_1^*)$ 和 $D_1^*=F(D_2^*)$。这等价于求解 $D_1^* = F(F(D_1^*))$。\n$F(F(D)) = \\frac{1+F(D)}{1+3F(D)} = \\frac{1+\\frac{1+D}{1+3D}}{1+3\\frac{1+D}{1+3D}} = \\frac{1+3D+1+D}{1+3D+3(1+D)} = \\frac{2+4D}{4+6D} = \\frac{1+2D}{2+3D}$。\n求解 $D = F(F(D))$：\n$D(2+3D) = 1+2D \\implies 2D+3D^2=1+2D \\implies 3D^2=1 \\implies D=1/\\sqrt{3}$。\n这表明，任何不动点都必须满足 $D_1^*=1/\\sqrt{3}$，这意味着 $D_2^*=F(D_1^*)=F(1/\\sqrt{3})=1/\\sqrt{3}$。因此，对称不动点是此参数下唯一的实数非负不动点。\n\n**2. 线性稳定性分析**\n状态向量为 $X = (N_1, D_1, N_2, D_2)^T$。雅可比矩阵 $J$ 在不动点处求值。\n$\\dot{N}_1 = f_N(D_2) - \\beta_N N_1$，$f_N(D) = \\alpha_N \\frac{D}{K_T+D}$。\n$\\dot{D}_1 = f_D(N_1) - \\beta_D D_1$，$f_D(N) = \\alpha_D \\frac{K_C}{K_C+N}$。\n导数为：\n$C_N = f_N'(D^*) = \\alpha_N \\frac{K_T}{(K_T+D^*)^2} = 2 \\frac{1}{(1+1/\\sqrt{3})^2} = \\frac{2 \\cdot 3}{(\\sqrt{3}+1)^2} = \\frac{6}{4+2\\sqrt{3}} = 3(2-\\sqrt{3})$。\n$C_D = f_D'(N^*) = -\\frac{\\alpha_D K_C}{(K_C+N^*)^2} = -\\frac{1 \\cdot 1}{(1+\\sqrt{3}-1)^2} = -1/3$。\n雅可比矩阵为：\n$$\nJ = \\begin{pmatrix}\n-\\beta_N  0  0  C_N \\\\\nC_D  -\\beta_D  0  0 \\\\\n0  C_N  -\\beta_N  0 \\\\\n0  0  C_D  -\\beta_D\n\\end{pmatrix} = \\begin{pmatrix}\n-1  0  0  3(2-\\sqrt{3}) \\\\\n-1/3  -1  0  0 \\\\\n0  3(2-\\sqrt{3})  -1  0 \\\\\n0  0  -1/3  -1\n\\end{pmatrix}\n$$\n由于对称性，该矩阵对对称和反对称扰动是块对角化的。\n\n**对称模式** ($v_S \\propto (1,1,1,1)$)：动力学由 $J_S = \\begin{pmatrix} -\\beta_N  C_N \\\\ C_D  -\\beta_D \\end{pmatrix} = \\begin{pmatrix} -1  3(2-\\sqrt{3}) \\\\ -1/3  -1 \\end{pmatrix}$ 决定。\n特征值 $\\lambda_S$ 满足 $(\\lambda_S+1)^2 - C_N C_D = 0 \\implies (\\lambda_S+1)^2 - (3(2-\\sqrt{3}))(-1/3) = 0 \\implies (\\lambda_S+1)^2 + (2-\\sqrt{3}) = 0$。\n$\\lambda_S = -1 \\pm i\\sqrt{2-\\sqrt{3}}$。由于 $\\text{Re}(\\lambda_S) = -1  0$，对称不动点对对称扰动是稳定的。\n\n**反对称模式** ($v_A \\propto (1,1,-1,-1)$)：动力学由 $J_A = \\begin{pmatrix} -\\beta_N  -C_N \\\\ C_D  -\\beta_D \\end{pmatrix} = \\begin{pmatrix} -1  -3(2-\\sqrt{3}) \\\\ -1/3  -1 \\end{pmatrix}$ 决定。\n特征值 $\\lambda_A$ 满足 $(\\lambda_A+1)^2 - (-C_N)C_D = 0 \\implies (\\lambda_A+1)^2 + C_N C_D = 0 \\implies (\\lambda_A+1)^2 - (2-\\sqrt{3}) = 0$。\n$\\lambda_A = -1 \\pm \\sqrt{2-\\sqrt{3}}$。\n我们可以简化 $\\sqrt{2-\\sqrt{3}} = \\sqrt{\\frac{4-2\\sqrt{3}}{2}} = \\frac{\\sqrt{(\\sqrt{3}-1)^2}}{\\sqrt{2}} = \\frac{\\sqrt{3}-1}{\\sqrt{2}}$。\n由于 $\\sqrt{3} \\approx 1.732$ 和 $\\sqrt{2} \\approx 1.414$，有 $\\sqrt{3}-1 \\approx 0.732  \\sqrt{2}$。因此 $\\frac{\\sqrt{3}-1}{\\sqrt{2}}  1$。\n两个特征值 $\\lambda_A = -1 \\pm \\frac{\\sqrt{3}-1}{\\sqrt{2}}$ 都是负实数。因此，对称不动点对反对称扰动也是稳定的。\n\n**结论**：对称不动点对于对称和反对称扰动都是稳定的。主导特征值是四个特征值中实部最大的一个。\n特征值集合为 $\\{ -1 \\pm i\\sqrt{2-\\sqrt{3}}, -1 \\pm \\sqrt{2-\\sqrt{3}} \\}$。\n实部分别为 $-1, -1, -1+\\sqrt{2-\\sqrt{3}}, -1-\\sqrt{2-\\sqrt{3}}$。\n最大的实部是 $-1 + \\sqrt{2-\\sqrt{3}}$。\n该值为 $-1 + \\frac{\\sqrt{3}-1}{\\sqrt{2}}$。", "answer": "$$\\boxed{-1 + \\frac{\\sqrt{3}-1}{\\sqrt{2}}}$$", "id": "2604680"}, {"introduction": "细胞如何解读上游的信号梯度并将其转化为特定的基因表达模式？答案在于基因组中的增强子逻辑。本练习将引导你采用一种现代的、数据驱动的方法，通过模型拟合来推断增强子整合多个转录因子信号的规则（例如“与”逻辑或“或”逻辑）。这个计算任务展示了如何利用定量数据来揭示基因调控的基本原理，是连接理论模型与实验观测的重要实践[@problem_id:2604658]。", "problem": "您的任务是通过将一个简约的转录因子占据模型拟合到报告基因强度数据，来推断一个空间发育梯度上的增强子逻辑。在比较动物学和植物学中，顺式调控逻辑的保守原理通常可以通过源自准平衡结合和转录因子结合位点独立性的简单概率模型来捕捉。目标是判断一个增强子是根据“与”逻辑还是“或”逻辑来整合两个转录因子。您必须实现一个程序，该程序无需输入，构建一个固定的合成数据集测试套件，通过最小化均方误差将两种候选模型拟合到每个数据集，并按如下规定，在单行中为每个数据集输出一个推断。\n\n假设和简约模型：\n- 设空间坐标为 $x \\in [0,1]$，在 $N$ 个均匀间隔的位置 $\\{x_i\\}_{i=1}^N$ 上采样。对于每个位置 $x_i$，有两个转录因子浓度 $c_A(x_i)$ 和 $c_B(x_i)$。\n- 在准平衡结合和独立位点占据的假设下，因子 $A$ 的单位点结合概率由 Hill 函数 $p_A(x) = \\dfrac{c_A(x)^{n_A}}{K_A^{n_A} + c_A(x)^{n_A}}$ 建模，因子 $B$ 的情况类似，其参数为 $K_B$ 和 $n_B$。\n- 增强子的激活逻辑由一个函数 $F(p_A, p_B)$ 捕捉，该函数将单位点占据率映射到一个激活概率。考虑两种假设：\n  - “与”逻辑：$F_{\\mathrm{AND}}(p_A, p_B) = p_A \\cdot p_B$。\n  - “或”逻辑：$F_{\\mathrm{OR}}(p_A, p_B) = 1 - (1 - p_A)(1 - p_B)$。\n- 报告基因强度建模为 $y(x) \\approx b + s \\cdot F(p_A(x), p_B(x))$，其中 $b$ 是基线强度，$s$ 是一个比例因子。\n\n拟合目标：\n- 对于一个给定的数据集 $\\{(x_i, c_A(x_i), c_B(x_i), y_i)\\}_{i=1}^N$，在每种逻辑下估计参数 $\\theta = (K_A, K_B, n_A, n_B, s, b)$，以最小化均方误差 (MSE)：\n$$\\mathrm{MSE}(\\theta) = \\dfrac{1}{N} \\sum_{i=1}^N \\left(y_i - \\left[b + s \\cdot F\\big(p_A(x_i), p_B(x_i)\\big)\\right]\\right)^2.$$\n- 为强制执行一个简约且可识别的参数化，在边界 $K_A \\in (0, 2]$、$K_B \\in (0, 2]$、$n_A \\in [1, 4]$、$n_B \\in [1, 4]$ 内优化 $(K_A, K_B, n_A, n_B)$，并在此条件下，通过对线性模型 $y_i \\approx b + s \\cdot F_i$（其中 $F_i = F\\big(p_A(x_i), p_B(x_i)\\big)$）应用普通最小二乘法来估计 $(s, b)$。\n\n决策规则：\n- 对于每个数据集，拟合 $F_{\\mathrm{AND}}$ 和 $F_{\\mathrm{OR}}$ 两种模型，计算最小化的 $\\mathrm{MSE}_{\\mathrm{AND}}$ 和 $\\mathrm{MSE}_{\\mathrm{OR}}$。如果 $\\mathrm{MSE}_{\\mathrm{AND}}  \\mathrm{MSE}_{\\mathrm{OR}} - \\varepsilon$，则输出整数 $1$，否则输出 $0$（在相等或几乎相等的情况下偏向“或”逻辑），其中 $\\varepsilon = 10^{-6}$。\n\n测试套件：\n使用在 $[0,1]$ 上均匀间隔的 $N = 101$ 个位置 $x_i$ 构建三个数据集。除非另有说明，所有数据集使用相同的“真实”参数：$K_A^{\\mathrm{true}} = 0.3$，$K_B^{\\mathrm{true}} = 0.35$，$n_A^{\\mathrm{true}} = 2$，$n_B^{\\mathrm{true}} = 2$，$s^{\\mathrm{true}} = 1000$，$b^{\\mathrm{true}} = 50$。对于所有数据集，使用真实参数通过 Hill 形式计算 $p_A(x)$ 和 $p_B(x)$，然后计算特定逻辑的真实 $F$ 和报告基因 $y(x) = b^{\\mathrm{true}} + s^{\\mathrm{true}} \\cdot F(p_A(x), p_B(x))$。向 $y(x)$ 添加具有指定标准差的零均值高斯噪声以模拟测量噪声。所有浓度必须在 $[0,1]$ 范围内，单位为任意单位。\n\n- 数据集 $1$（“与”逻辑基准真相；“单中心域”）：\n  - $c_A(x) = \\exp\\!\\left(-\\dfrac{(x - \\mu_A)^2}{2 \\sigma_A^2}\\right)$，其中 $\\mu_A = 0.35$，$\\sigma_A = 0.20$。\n  - $c_B(x) = \\exp\\!\\left(-\\dfrac{(x - \\mu_B)^2}{2 \\sigma_B^2}\\right)$，其中 $\\mu_B = 0.65$，$\\sigma_B = 0.18$。\n  - 生成 $y$ 的逻辑：“与”逻辑，$F = F_{\\mathrm{AND}}$。\n  - 添加标准差为 $\\sigma_y = 25$ 的高斯噪声。\n- 数据集 $2$（“或”逻辑基准真相；“双叶域”）：\n  - $c_A(x) = \\exp\\!\\left(-\\dfrac{(x - \\mu_A)^2}{2 \\sigma_A^2}\\right)$，其中 $\\mu_A = 0.25$，$\\sigma_A = 0.22$。\n  - $c_B(x) = \\exp\\!\\left(-\\dfrac{(x - \\mu_B)^2}{2 \\sigma_B^2}\\right)$，其中 $\\mu_B = 0.75$，$\\sigma_B = 0.22$。\n  - 生成 $y$ 的逻辑：“或”逻辑，$F = F_{\\mathrm{OR}}$。\n  - 添加标准差为 $\\sigma_y = 25$ 的高斯噪声。\n- 数据集 $3$（“或”逻辑基准真相；“仅A边界情况”）：\n  - $c_A(x) = 1 - x$。\n  - 对于所有 $x$，$c_B(x) = 0.05$。\n  - 使用修改后的真实参数 $K_A^{\\mathrm{true}} = 0.25$，$K_B^{\\mathrm{true}} = 0.50$，$n_A^{\\mathrm{true}} = 2$，$n_B^{\\mathrm{true}} = 2$，$s^{\\mathrm{true}} = 900$，$b^{\\mathrm{true}} = 40$。\n  - 生成 $y$ 的逻辑：“或”逻辑，$F = F_{\\mathrm{OR}}$。\n  - 添加标准差为 $\\sigma_y = 5$ 的高斯噪声。\n\n实现细节：\n- 使用固定的随机种子以确保结果是确定性的。为生成所有噪声，设种子为 $0$。\n- 为确保计算 $p(c; K, n)$ 时的数值稳定性，在计算过程中如有需要，通过添加一个很小的 $\\epsilon = 10^{-12}$ 来确保分母不为零。\n- 对每个逻辑假设执行 $(K_A, K_B, n_A, n_B)$ 的有界优化；对于每个试探性的 $(K_A, K_B, n_A, n_B)$，计算 $F_i$，然后通过对 $y_i \\approx b + s F_i$ 应用最小二乘法来估计 $(s, b)$。使用最小化的 MSE 作为该假设的得分。\n- 为 $(K_A, K_B, n_A, n_B)$ 使用多个初始猜测值，以降低陷入局部最小值的风险；至少包括初始值 $(0.2, 0.2, 1.5, 1.5)$、$(0.5, 0.5, 2.5, 2.5)$ 和 $(1.0, 1.0, 3.5, 3.5)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于顺序为 $(1,2,3)$ 的每个数据集，如果拟合的“与”模型的 MSE 比拟合的“或”模型的 MSE 低超过 $\\varepsilon = 10^{-6}$，则输出整数 $1$，否则输出 $0$。例如，一个有效的输出行看起来像 $[1,0,0]$。", "solution": "所述问题在科学上是合理的，在计算上是适定的。它提出了定量生物学中的一个标准任务：基于对实验数据的拟合进行模型选择。用于转录因子结合（Hill 函数）和组合逻辑（“与”/“或”）的模型是从报告基因表达模式推断基因调控原理所使用的典型简化模型。该问题提供了所有必要的数据、参数和一个明确的目标函数（均方误差），以及一个用于模型拟合和选择的确定性程序。因此，可以推导出一个解决方案。\n\n该任务是针对三个合成数据集，区分顺式调控逻辑的两个竞争性假设——“与”逻辑整合与“或”逻辑整合。这需要一个计算过程来生成数据集，然后将两种模型拟合到每个数据集，最终选择产生更低均方误差（MSE）的模型。\n\n问题的核心在于每个模型的参数估计。报告基因强度模型 $y(x) \\approx b + s \\cdot F(p_A(x), p_B(x))$ 的完整参数集是 $\\theta = (K_A, K_B, n_A, n_B, s, b)$。参数 $(K_A, K_B, n_A, n_B)$ 定义了非线性的结合概率 $p_A(x)$ 和 $p_B(x)$，而 $(s, b)$ 是线性缩放参数。问题指定了一种嵌套优化策略，也称为变量投影法，这是解决此类问题的有效方法。非线性参数在一个外循环中被优化，对于每一组候选的非线性参数，最优的线性参数都是通过解析方式求得的。\n\n让我们将针对单个数据集和单个逻辑假设 $F$ 的过程形式化。\n数据集由 $N$ 个点 $(x_i, c_{A,i}, c_{B,i}, y_i)$ 组成。\n\n1.  **外部优化**：我们搜索最优的非线性参数 $\\theta_{nl}^* = (K_A^*, K_B^*, n_A^*, n_B^*)$ 以最小化 MSE。搜索在指定的边界内执行：$K_A, K_B \\in (0, 2]$ 以及 $n_A, n_B \\in [1, 4]$。\n    $$\n    \\theta_{nl}^* = \\arg\\min_{(K_A, K_B, n_A, n_B)} \\mathrm{MSE}(K_A, K_B, n_A, n_B)\n    $$\n\n2.  **内部 OLS 步骤**：对于任意给定的非线性参数集 $(K_A, K_B, n_A, n_B)$，我们首先计算激活概率。\n    对于所有 $i = 1, \\dots, N$，结合概率计算如下：\n    $$\n    p_{A,i} = \\frac{c_{A,i}^{n_A}}{K_A^{n_A} + c_{A,i}^{n_A}} \\quad \\text{和} \\quad p_{B,i} = \\frac{c_{B,i}^{n_B}}{K_B^{n_B} + c_{B,i}^{n_B}}\n    $$\n    由此，逻辑函数值 $F_i = F(p_{A,i}, p_{B,i})$ 被确定。对于“与”逻辑，$F_i = p_{A,i} \\cdot p_{B,i}$。对于“或”逻辑，$F_i = 1 - (1-p_{A,i})(1-p_{B,i})$。\n\n    然后，我们通过最小化线性模型 $y_i = b + s \\cdot F_i$ 的误差平方和来找到最优的线性参数 $(s, b)$。这是一个标准的普通最小二乘法 (OLS) 问题。我们定义一个设计矩阵 $\\mathbf{X}$ 和一个响应向量 $\\mathbf{y}$：\n    $$\n    \\mathbf{X} = \\begin{pmatrix} 1  F_1 \\\\ 1  F_2 \\\\ \\vdots  \\vdots \\\\ 1  F_N \\end{pmatrix}, \\quad \\mathbf{y} = \\begin{pmatrix} y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_N \\end{pmatrix}\n    $$\n    参数向量 $\\boldsymbol{\\beta} = [b, s]^T$ 的 OLS 估计是：\n    $$\n    \\hat{\\boldsymbol{\\beta}} = (\\mathbf{X}^T \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{y}\n    $$\n    此线性拟合得到的最小化残差平方和 (SSR) 是 $\\sum_{i=1}^N (y_i - (\\hat{b} + \\hat{s} F_i))^2$。MSE 则是 $\\mathrm{SSR}/N$。这个 MSE 值就是外部优化循环试图最小化的目标函数。\n\n3.  **数值优化**：使用诸如 L-BFGS-B 之类的数值优化算法，在有界参数空间上对 $(K_A, K_B, n_A, n_B)$ 执行最小化。为了减轻找到局部而非全局最小值的风险，优化过程会从指定的多个初始起点重复进行：$(0.2, 0.2, 1.5, 1.5)$、$(0.5, 0.5, 2.5, 2.5)$ 和 $(1.0, 1.0, 3.5, 3.5)$。在所有运行中产生最低 MSE 的那组参数被选为该逻辑的最佳拟合。\n\n4.  **模型选择**：对“与”逻辑 ($F_{\\mathrm{AND}}$) 和“或”逻辑 ($F_{\\mathrm{OR}}$) 都执行这整个过程，产生两个最小化的误差值 $\\mathrm{MSE}_{\\mathrm{AND}}$ 和 $\\mathrm{MSE}_{\\mathrm{OR}}$。最终决策基于规则：如果 $\\mathrm{MSE}_{\\mathrm{AND}}  \\mathrm{MSE}_{\\mathrm{OR}} - \\varepsilon$（其中 $\\varepsilon = 10^{-6}$），则增强子被分类为“与”逻辑（输出 $1$）；否则，它被分类为“或”逻辑（输出 $0$）。\n\n这种结构化方法将被系统地应用于三个合成数据集中的每一个。首先，使用指定的“真实”参数、浓度分布、逻辑以及为保证可复现性而使用固定随机种子 $0$ 添加的高斯噪声来生成数据集。\n\n整体算法如下：\n- 初始化一个结果列表。\n- 对于每个数据集 (1, 2, 3)：\n    - 根据其规格生成数据 $(x_i, c_{A,i}, c_{B,i}, y_i)$。\n    - 通过运行有界的、多起点、嵌套的优化，找到“与”模型的最佳拟合 MSE，即 $\\mathrm{MSE}_{\\mathrm{AND}}$。\n    - 使用相同的过程，找到“或”模型的最佳拟合 MSE，即 $\\mathrm{MSE}_{\\mathrm{OR}}$。\n    - 使用决策规则比较 MSE 值，并将得到的结果 $0$ 或 $1$ 附加到结果列表中。\n- 将结果列表格式化为指定的字符串 `\"[r1,r2,r3]\"` 并输出。\n\n该实现将利用 `numpy` 进行数值计算，并利用 `scipy.optimize.minimize` 进行非线性优化部分。对于 $(s,b)$ 的 OLS 步骤将通过 `numpy.linalg.lstsq` 高效处理，该函数直接提供残差平方和。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Main function to generate datasets, fit models, and determine enhancer logic.\n    \"\"\"\n    # Set the random seed for reproducible noise generation.\n    np.random.seed(0)\n\n    # Global parameters\n    N = 101\n    x = np.linspace(0, 1, N)\n    epsilon_mse = 1e-6\n\n    # Optimization settings\n    initial_guesses = [\n        (0.2, 0.2, 1.5, 1.5),\n        (0.5, 0.5, 2.5, 2.5),\n        (1.0, 1.0, 3.5, 3.5),\n    ]\n    # Bounds for K are (0, 2], we use a small positive number for the lower bound.\n    bounds = [(1e-9, 2.0), (1e-9, 2.0), (1.0, 4.0), (1.0, 4.0)]\n\n    # --- Dataset Definitions ---\n    # Common true parameters for datasets 1 and 2\n    params_true_1_2 = {'KA': 0.3, 'KB': 0.35, 'nA': 2.0, 'nB': 2.0, 's': 1000.0, 'b': 50.0}\n    # Modified true parameters for dataset 3\n    params_true_3 = {'KA': 0.25, 'KB': 0.50, 'nA': 2.0, 'nB': 2.0, 's': 900.0, 'b': 40.0}\n\n    all_datasets = [\n        {\n            'name': 'Dataset 1 (AND)',\n            'cA': np.exp(-((x - 0.35)**2) / (2 * 0.20**2)),\n            'cB': np.exp(-((x - 0.65)**2) / (2 * 0.18**2)),\n            'true_params': params_true_1_2,\n            'true_logic': 'AND',\n            'noise_std': 25.0\n        },\n        {\n            'name': 'Dataset 2 (OR)',\n            'cA': np.exp(-((x - 0.25)**2) / (2 * 0.22**2)),\n            'cB': np.exp(-((x - 0.75)**2) / (2 * 0.22**2)),\n            'true_params': params_true_1_2,\n            'true_logic': 'OR',\n            'noise_std': 25.0\n        },\n        {\n            'name': 'Dataset 3 (OR, boundary)',\n            'cA': 1.0 - x,\n            'cB': np.full_like(x, 0.05),\n            'true_params': params_true_3,\n            'true_logic': 'OR',\n            'noise_std': 5.0\n        }\n    ]\n\n    # --- Helper Functions ---\n    def hill(c, K, n):\n        \"\"\"Computes the Hill function for binding probability.\"\"\"\n        # Add a small epsilon to denominator to prevent division by zero if c and K are zero,\n        # though bounds prevent K=0.\n        c_n = c**n\n        K_n = K**n\n        return c_n / (K_n + c_n + 1e-12)\n\n    def logic_F(pA, pB, logic_type):\n        \"\"\"Computes the activation probability based on logic type.\"\"\"\n        if logic_type == 'AND':\n            return pA * pB\n        elif logic_type == 'OR':\n            return 1.0 - (1.0 - pA) * (1.0 - pB)\n        else:\n            raise ValueError(\"Unknown logic type\")\n\n    def generate_y_data(dataset_def):\n        \"\"\"Generates the reporter intensity data with noise.\"\"\"\n        p = dataset_def['true_params']\n        pA_true = hill(dataset_def['cA'], p['KA'], p['nA'])\n        pB_true = hill(dataset_def['cB'], p['KB'], p['nB'])\n        F_true = logic_F(pA_true, pB_true, dataset_def['true_logic'])\n        y_true = p['b'] + p['s'] * F_true\n        noise = np.random.normal(0, dataset_def['noise_std'], size=N)\n        return y_true + noise\n\n    def calculate_mse_for_params(params, cA, cB, y_data, logic_type):\n        \"\"\"\n        Objective function for the optimizer.\n        For a given set of non-linear parameters, it calculates the optimal\n        linear parameters (s, b) via OLS and returns the corresponding MSE.\n        \"\"\"\n        KA, KB, nA, nB = params\n        \n        pA = hill(cA, KA, nA)\n        pB = hill(cB, KB, nB)\n        \n        F_vec = logic_F(pA, pB, logic_type)\n        \n        # OLS for s and b: y = b * 1 + s * F\n        X = np.vstack([np.ones_like(F_vec), F_vec]).T\n        \n        # Using numpy.linalg.lstsq to solve for [b, s]\n        # It robustly handles the linear regression and returns sum of squared residuals\n        _, residuals, _, _ = np.linalg.lstsq(X, y_data, rcond=None)\n        \n        if residuals.size == 0:\n            # This can happen if the design matrix is singular, e.g., F_vec is constant.\n            # Predict with mean and calculate MSE.\n            y_pred = np.mean(y_data)\n            mse = np.mean((y_data - y_pred)**2)\n        else:\n            sum_sq_resid = residuals[0]\n            mse = sum_sq_resid / N\n            \n        return mse\n\n    def fit_logic_model(cA, cB, y_data, logic_type):\n        \"\"\"\n        Fits a model (AND or OR) to the data by finding the best non-linear\n        parameters that minimize MSE. Runs optimizer from multiple starting points.\n        \"\"\"\n        min_mse_found = np.inf\n        for start_point in initial_guesses:\n            result = minimize(\n                fun=calculate_mse_for_params,\n                x0=start_point,\n                args=(cA, cB, y_data, logic_type),\n                method='L-BFGS-B',\n                bounds=bounds\n            )\n            if result.fun  min_mse_found:\n                min_mse_found = result.fun\n        return min_mse_found\n\n    # --- Main Loop ---\n    results = []\n    for dataset in all_datasets:\n        y_noisy = generate_y_data(dataset)\n        \n        mse_and = fit_logic_model(dataset['cA'], dataset['cB'], y_noisy, 'AND')\n        mse_or = fit_logic_model(dataset['cB'], dataset['cA'], y_noisy, 'OR')\n        \n        # Decision rule\n        if mse_and  mse_or - epsilon_mse:\n            results.append(1)  # AND model is better\n        else:\n            results.append(0)  # OR model is better or they are too close\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2604658"}]}