{"hands_on_practices": [{"introduction": "我们对协同演化的探索始于个体层面。传粉者在觅食时，持续在充满不确定性的环境中做出决策，因为并非所有信号都绝对可靠。第一个实践练习运用了信号检测理论——一个源自心理学和工程学的强大框架——来模拟这一挑战 [@problem_id:2602882]。通过推导最优决策规则，我们可以理解塑造传粉者觅食策略的认知压力，以及反过来作用于花部性状展示的演化驱动力。", "problem": "一只摄食花蜜的传粉者通过颜色来决定是否要探查一朵花。设感知到的标量颜色度量为 $x \\in \\mathbb{R}$。由于色素表型的重叠，有回报的花朵（$R$）和无回报的花朵（$N$）的颜色度量服从方差相同但均值不同的高斯密度分布：如果花朵有回报，$x \\sim \\mathcal{N}(\\mu_{R}, \\sigma^{2})$；如果花朵无回报，$x \\sim \\mathcal{N}(\\mu_{N}, \\sigma^{2})$，其中 $\\mu_{R} > \\mu_{N}$ 且 $\\sigma > 0$。遇到一朵有回报的花的先验概率为 $p_{R} \\in (0,1)$，而 $p_{N} = 1 - p_{R}$。如果传粉者探查一朵花且其有回报，它将获得价值为 $E > 0$ 的花蜜（以一致的能量等效单位计算）；如果它探查的花朵无回报，它将获得0花蜜，并产生一个净能量/机会成本 $K > 0$。跳过一朵花收益为0，且不产生任何成本。假设每次决策是独立的，且传粉者根据信号检测理论（SDT）中的贝叶斯更新来最大化每次决策的预期花蜜摄入量。\n\n仅从贝叶斯定理和期望效用最大化出发，推导出形式为“当且仅当 $x \\ge x^{\\ast}$ 时进行探查”的贝叶斯最优决策规则，并获得最优阈值 $x^{\\ast}$ 关于 $\\mu_{R}$、$\\mu_{N}$、$\\sigma$、$p_{R}$、$p_{N}$、$E$ 和 $K$ 的闭式表达式。将最终答案表示为 $x^{\\ast}$ 的解析表达式；无需四舍五入，表达式中不应包含单位。", "solution": "该问题要求基于贝叶斯决策理论和期望效用最大化的原则，为摄食花蜜的传粉者推导出一个最优决策阈值。这是信号检测理论中的一个经典问题。\n\n设一朵花的两种可能状态为有回报（$R$）和无回报（$N$）。传粉者观察到一个连续的颜色度量 $x \\in \\mathbb{R}$。需要做出的决策是在两种行动之间选择：探查（$A_P$）或跳过（$A_S$）。目标是选择能最大化期望效用或能量增益的行动。\n\n无论观察值 $x$ 为何，跳过一朵花的效用始终为零。\n$$\n\\mathbb{E}[U(A_S | x)] = 0\n$$\n\n在给定观察值 $x$ 的条件下，探查一朵花的期望效用是每种可能状态的效用之和，并按给定观察值下该状态的后验概率进行加权。\n$$\n\\mathbb{E}[U(A_P | x)] = U(A_P, R) \\cdot P(R | x) + U(A_P, N) \\cdot P(N | x)\n$$\n根据问题描述，探查有回报花朵的效用是获得增益 $E$，所以 $U(A_P, R) = E$。探查无回报花朵的效用是付出成本 $K$，所以 $U(A_P, N) = -K$。因此，探查的期望效用为：\n$$\n\\mathbb{E}[U(A_P | x)] = E \\cdot P(R | x) - K \\cdot P(N | x)\n$$\n贝叶斯最优决策规则规定，传粉者应该探查当且仅当探查的期望效用大于或等于跳过的期望效用。\n$$\n\\mathbb{E}[U(A_P | x)] \\ge \\mathbb{E}[U(A_S | x)]\n$$\n$$\nE \\cdot P(R | x) - K \\cdot P(N | x) \\ge 0\n$$\n这个不等式可以重排为：\n$$\n\\frac{P(R | x)}{P(N | x)} \\ge \\frac{K}{E}\n$$\n后验概率 $P(R | x)$ 和 $P(N | x)$ 没有直接给出。我们必须使用贝叶斯定理，用观察值的似然 $P(x|R)$ 和 $P(x|N)$ 以及先验概率 $P(R) = p_R$ 和 $P(N) = p_N$ 来表示它们。\n$$\nP(R | x) = \\frac{P(x | R) P(R)}{P(x)} \\quad \\text{和} \\quad P(N | x) = \\frac{P(x | N) P(N)}{P(x)}\n$$\n将这些代入决策规则不等式中：\n$$\n\\frac{\\frac{P(x | R) p_R}{P(x)}}{\\frac{P(x | N) p_N}{P(x)}} \\ge \\frac{K}{E}\n$$\n证据项 $P(x)$ 被消去，得到似然比检验：\n$$\n\\frac{P(x | R)}{P(x | N)} \\ge \\frac{K p_N}{E p_R}\n$$\n问题陈述，颜色度量服从高斯密度分布。设 $P(x|R) = f_R(x)$ 且 $P(x|N) = f_N(x)$。\n$$\nf_R(x) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left(-\\frac{(x - \\mu_{R})^2}{2\\sigma^{2}}\\right)\n$$\n$$\nf_N(x) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left(-\\frac{(x - \\mu_{N})^2}{2\\sigma^{2}}\\right)\n$$\n似然比 $\\lambda(x) = \\frac{f_R(x)}{f_N(x)}$ 为：\n$$\n\\lambda(x) = \\frac{\\exp\\left(-\\frac{(x - \\mu_{R})^2}{2\\sigma^{2}}\\right)}{\\exp\\left(-\\frac{(x - \\mu_{N})^2}{2\\sigma^{2}}\\right)} = \\exp\\left(\\frac{1}{2\\sigma^{2}} \\left[ (x - \\mu_{N})^2 - (x - \\mu_{R})^2 \\right] \\right)\n$$\n决策规则为当 $\\lambda(x) \\ge \\frac{K p_N}{E p_R}$ 时进行探查。由于自然对数函数 $\\ln(\\cdot)$ 是单调递增的，我们可以对不等式两边取对数而不改变决策。\n$$\n\\ln(\\lambda(x)) \\ge \\ln\\left(\\frac{K p_N}{E p_R}\\right)\n$$\n$$\n\\frac{1}{2\\sigma^{2}} \\left[ (x - \\mu_{N})^2 - (x - \\mu_{R})^2 \\right] \\ge \\ln\\left(\\frac{K p_N}{E p_R}\\right)\n$$\n我们展开括号中的二次项：\n$$\n(x - \\mu_{N})^2 - (x - \\mu_{R})^2 = (x^2 - 2x\\mu_N + \\mu_N^2) - (x^2 - 2x\\mu_R + \\mu_R^2)\n$$\n$$\n= 2x(\\mu_R - \\mu_N) - (\\mu_R^2 - \\mu_N^2)\n$$\n使用平方差公式 $\\mu_R^2 - \\mu_N^2 = (\\mu_R - \\mu_N)(\\mu_R + \\mu_N)$，上式简化为：\n$$\n= (\\mu_R - \\mu_N) [2x - (\\mu_R + \\mu_N)]\n$$\n将此代回不等式中：\n$$\n\\frac{(\\mu_R - \\mu_N)}{2\\sigma^{2}} [2x - (\\mu_R + \\mu_N)] \\ge \\ln\\left(\\frac{K p_N}{E p_R}\\right)\n$$\n现在，我们必须解出 $x$。因为给定 $\\mu_R > \\mu_N$，所以 $(\\mu_R - \\mu_N)$ 项是正的。我们可以进行乘除运算而不改变不等号的方向。\n$$\n2x - (\\mu_R + \\mu_N) \\ge \\frac{2\\sigma^{2}}{\\mu_R - \\mu_N} \\ln\\left(\\frac{K p_N}{E p_R}\\right)\n$$\n$$\n2x \\ge (\\mu_R + \\mu_N) + \\frac{2\\sigma^{2}}{\\mu_R - \\mu_N} \\ln\\left(\\frac{K p_N}{E p_R}\\right)\n$$\n最后，两边除以2，得到传粉者必须进行探查时 $x$ 所满足的条件：\n$$\nx \\ge \\frac{\\mu_R + \\mu_N}{2} + \\frac{\\sigma^{2}}{\\mu_R - \\mu_N} \\ln\\left(\\frac{K p_N}{E p_R}\\right)\n$$\n这就是“当且仅当 $x \\ge x^{\\ast}$ 时进行探查”的形式。因此，最优决策阈值 $x^{\\ast}$ 是右侧的表达式。这个表达式正确地平衡了感官证据（第一项，即分布的中点）与先验概率和收益（对数调整项）。", "answer": "$$\\boxed{\\frac{\\mu_{R} + \\mu_{N}}{2} + \\frac{\\sigma^{2}}{\\mu_{R} - \\mu_{N}} \\ln\\left(\\frac{K p_{N}}{E p_{R}}\\right)}$$", "id": "2602882"}, {"introduction": "个体的决策并非在真空中做出；它们是策略性相互作用的一部分。植物对花蜜的投入只有在传粉者访问时才值得，而传粉者的努力也只有在植物提供花蜜时才能得到回报。本练习使用博弈论框架，将这种相互依赖的关系建模为两个命运相连的参与者之间的策略协商 [@problem_id:2602899]。通过计算纳什均衡，你将揭示一个稳定的、互惠的伙伴关系得以演化所需的精确条件，并阐明协调失败的风险。", "problem": "植物与传粉者之间的相互作用被建模为代表性植物和代表性传粉者之间的同步博弈。植物选择一个非负的花蜜奖励水平，该水平表示为每朵花单位时间的奖励，记作 $r \\ge 0$；传粉者选择一个非负的访问努力，记作 $e \\ge 0$。生态约束意味着花蜜生产成本会随着访问频率的增加而增加，因为高访问频率迫使植物更频繁地补充花蜜；同时，高奖励水平下的处理时间会增加访问的边际能量成本。假设单位时间的收益如下：\n\n- 植物的适应度（经过缩放）由下式给出：\n$$\nU_{p}(r;e) \\;=\\; s \\, n \\, e \\, r \\;-\\; \\frac{1}{2}\\, c \\, \\bigl(1 + b\\, e\\bigr)\\, r^{2},\n$$\n其中 $s>0$ 将传粉服务转化为种子成功率，$n>0$ 将乘积 $e r$ 转化为花粉转移量，$c>0$ 是花蜜生产的基础边际成本参数，$b>0$ 用以衡量花蜜补充成本随访问频率 $e$ 增加的幅度。\n\n- 传粉者的净能量摄入（经过缩放的效用）由下式给出：\n$$\nU_{m}(e;r) \\;=\\; m \\, r \\, e \\;-\\; \\frac{1}{2}\\, k \\, \\bigl(1 + f\\, r\\bigr)\\, e^{2},\n$$\n其中 $m>0$ 将花蜜奖励转化为传粉者的能量收益，$k>0$ 是努力的基础边际成本参数，$f>0$ 用以衡量因处理时间导致努力成本随奖励 $r$ 增加的幅度。\n\n对于任何固定的对手策略，双方的收益函数在其自身策略上都是严格凹函数。\n\n任务：\n\n- 仅使用纳什均衡的定义和凹性条件下的一阶最优性条件，推导每个参与者的最佳反应函数，并解析求解所有满足 $r^{\\ast} \\ge 0$ 和 $e^{\\ast} \\ge 0$ 的对称纳什均衡 $(r^{\\ast}, e^{\\ast})$。\n\n- 确定存在严格正（内部）均衡（即 $r^{\\ast} > 0$ 和 $e^{\\ast} > 0$）的参数条件。从该生态环境中的策略性互动的基本原理出发，解释何时会出现多重均衡，以及这与植物和传粉者之间的协调失败有何关系。\n\n- 当内部纳什均衡存在时，将其策略对 $(r^{\\ast}, e^{\\ast})$ 表示为关于 $s, n, c, b, m, k,$ 和 $f$ 的闭式解析表达式。将最终答案以单行向量 $(r^{\\ast}, e^{\\ast})$ 的形式报告；不需要数值近似，也不需要单位。", "solution": "在尝试任何解答之前，需对问题进行验证。\n\n首先，我们从问题陈述中逐字提取已知条件。\n参与者：代表性植物和代表性传粉者。\n策略：植物选择花蜜奖励水平 $r \\ge 0$。传粉者选择访问努力 $e \\ge 0$。\n植物的收益函数：$U_{p}(r;e) = s \\, n \\, e \\, r - \\frac{1}{2}\\, c \\, (1 + b\\, e)\\, r^{2}$。\n传粉者的收益函数：$U_{m}(e;r) = m \\, r \\, e - \\frac{1}{2}\\, k \\, (1 + f\\, r)\\, e^{2}$。\n参数：$s>0$, $n>0$, $c>0$, $b>0$, $m>0$, $k>0$, $f>0$。\n性质：对于任何固定的对手策略，双方的收益函数在其自身策略上都是严格凹函数。\n任务：\n1. 推导最佳反应函数并求解所有非负纳什均衡 $(r^{\\ast}, e^{\\ast})$。\n2. 确定严格正（内部）均衡的参数条件，并解释多重均衡和协调失败的背景。\n3. 将内部纳什均衡表示为闭式解析表达式。\n\n现在，我们来验证这个问题。该问题是博弈论在演化生态学问题上的一个标准应用，属于指定的STEM领域。它具有科学依据，用广为接受的成本和收益假设来模拟互利共生互动。收益函数在数学上是良定义的，所陈述的凹性性质确保了一阶条件足以找到最佳反应，这使得问题是良定的。术语精确客观。没有违反科学原理之处，没有缺失信息，也没有内部矛盾。问题是有效的。我们将继续进行解答。\n\n纳什均衡 $(r^{\\ast}, e^{\\ast})$ 是一个策略组合，在该组合中，任何一方都不能通过单方面改变其策略来提高其收益。鉴于收益函数的严格凹性，每个参与者的最佳反应函数可以通过将其收益函数对自身策略的一阶偏导数设为零来求得，前提是解为非负。\n\n首先，我们确定植物的最佳反应函数 $BR_p(e)$，即对于给定的 $e \\ge 0$，使 $U_p(r;e)$ 最大化的 $r$ 值。\n$$ \\frac{\\partial U_p}{\\partial r} = s \\, n \\, e - c(1 + b\\,e)r = 0 $$\n求解 $r$ 得到植物的反应函数：\n$$ r(e) = \\frac{s \\, n \\, e}{c(1 + b\\,e)} $$\n由于所有参数（$s, n, c, b$）均为正且 $e \\ge 0$，因此 $r(e) \\ge 0$。\n\n其次，我们确定传粉者的最佳反应函数 $BR_m(r)$，即对于给定的 $r \\ge 0$，使 $U_m(e;r)$ 最大化的 $e$ 值。\n$$ \\frac{\\partial U_m}{\\partial e} = m \\, r - k(1 + f\\,r)e = 0 $$\n求解 $e$ 得到传粉者的反应函数：\n$$ e(r) = \\frac{m \\, r}{k(1 + f\\,r)} $$\n由于所有参数（$m, k, f$）均为正且 $r \\ge 0$，因此 $e(r) \\ge 0$。\n\n纳什均衡 $(r^{\\ast}, e^{\\ast})$ 必须同时满足两个最佳反应函数：\n$$ r^{\\ast} = \\frac{s \\, n \\, e^{\\ast}}{c(1 + b\\,e^{\\ast})} \\quad \\text{和} \\quad e^{\\ast} = \\frac{m \\, r^{\\ast}}{k(1 + f\\,r^{\\ast})} $$\n我们分析这个方程组的解。\n经检验，$(r^{\\ast}, e^{\\ast}) = (0, 0)$ 是一个解。如果 $e^{\\ast}=0$，第一个方程给出 $r^{\\ast}=0$。如果 $r^{\\ast}=0$，第二个方程给出 $e^{\\ast}=0$。这是一个平凡均衡，代表植物和传粉者之间没有相互作用的状态。\n\n为了找到任何满足 $r^{\\ast} > 0$ 和 $e^{\\ast} > 0$ 的非平凡（或内部）均衡，我们将 $e^{\\ast}$ 的表达式代入第一个方程：\n$$ r^{\\ast} = \\frac{s \\, n}{c} \\frac{\\frac{m \\, r^{\\ast}}{k(1 + f\\,r^{\\ast})}}{1 + b\\left(\\frac{m \\, r^{\\ast}}{k(1 + f\\,r^{\\ast})}\\right)} $$\n因为我们假设 $r^{\\ast} > 0$，所以方程两边可以同除以 $r^{\\ast}$：\n$$ 1 = \\frac{s \\, n}{c} \\frac{\\frac{m}{k(1 + f\\,r^{\\ast})}}{\\frac{k(1 + f\\,r^{\\ast}) + b\\,m\\,r^{\\ast}}{k(1 + f\\,r^{\\ast})}} $$\n$$ 1 = \\frac{s \\, n \\, m}{c(k(1 + f\\,r^{\\ast}) + b\\,m\\,r^{\\ast})} $$\n$$ c(k + k\\,f\\,r^{\\ast} + b\\,m\\,r^{\\ast}) = s \\, n \\, m $$\n$$ c\\,k + c(k\\,f + b\\,m)r^{\\ast} = s \\, n \\, m $$\n我们求解 $r^{\\ast}$：\n$$ r^{\\ast} = \\frac{s \\, n \\, m - c \\, k}{c(k\\,f + b\\,m)} $$\n要使这是一个严格正的均衡策略，必须有 $r^{\\ast} > 0$。由于分母中的所有参数都为正，这个条件要求分子为正：\n$$ s \\, n \\, m - c \\, k > 0 \\implies s \\, n \\, m > c \\, k $$\n如果这个条件成立，我们就有一个唯一的、严格正的 $r^{\\ast}$。相应的均衡努力 $e^{\\ast}$ 可以通过将这个 $r^{\\ast}$ 代入传粉者的最佳反应函数来求得。或者，根据对称性，我们可以将 $r^{\\ast}$ 代入第二个最佳反应方程，并求解 $e^{\\ast} > 0$。这将得出：\n$$ e^{\\ast} = \\frac{s\\,n\\,m - c\\,k}{k(c\\,b + s\\,n\\,f)} $$\n$e^{\\ast}$ 的正性也取决于相同的条件 $s \\, n \\, m > c \\, k$。\n\n因此，存在一个严格正（内部）均衡的充要条件是 $s\\,n\\,m > c\\,k$。这个不等式可以写成 $\\frac{s\\,n\\,m}{c\\,k} > 1$。这个条件有一个清晰的生态学解释。项 $s\\,n\\,m$ 是与互动边际收益相关的项的乘积，而 $c\\,k$ 是基础边际成本的乘积。该条件表明，要使一个互利共生互动能够自我维持，边际收益的乘积必须超过在原点处（即当 $r$ 和 $e$ 接近于零时）的边际成本的乘积。\n\n当 $s\\,n\\,m > c\\,k$ 时，存在两个纳什均衡：平凡均衡 $(0, 0)$ 和内部均衡 $(r^{\\ast}, e^{\\ast})$。这是一个经典的协调博弈。在内部均衡点，收益为 $U_p^{\\ast} = \\frac{1}{2}c(1+be^{\\ast})(r^{\\ast})^2 > 0$ 和 $U_m^{\\ast} = \\frac{1}{2}k(1+fr^{\\ast})(e^{\\ast})^2 > 0$，这严格大于平凡均衡点的零收益。因此，内部均衡是帕累托占优的。如果系统因为每个参与者都预期对方选择零策略而被困在 $(0, 0)$ 均衡点，就会发生协调失败。这是合作演化中的一个基本问题：存在一个互利的状态，但要达到这个状态需要双方进行协调的“投资”。如果缺乏这种协调，系统将停留在没有相互作用的状态，而这个状态在演化上也是稳定的。\n\n内部纳什均衡策略对 $(r^{\\ast}, e^{\\ast})$ 由以下闭式表达式给出：\n$$ r^{\\ast} = \\frac{s \\, n \\, m - c \\, k}{c(k\\,f + b\\,m)} $$\n$$ e^{\\ast} = \\frac{s\\,n\\,m - c\\,k}{k(c\\,b + s\\,n\\,f)} $$\n这就是所要求的解析结果。", "answer": "$$ \\boxed{ \\begin{pmatrix} \\frac{s\\,n\\,m - c\\,k}{c(k\\,f + b\\,m)}  \\frac{s\\,n\\,m - c\\,k}{k(c\\,b + s\\,n\\,f)} \\end{pmatrix} } $$", "id": "2602899"}, {"introduction": "从个体配对的互动中，我们现在将视角放大到整个生态群落：即植物与传粉者相互作用的完整生态网络。这些复杂的系统是群落稳定性的基石。最后一个计算实践将为你装备网络生态学的方法，以分析这些群落的结构和恢复力 [@problem_id:2602895]。通过编程实现计算关键网络指标的算法，你将获得分析真实生态数据和评估生态系统如何应对物种丧失等干扰的实践经验。", "problem": "给你一些代表经验性传粉网络的二分植物-传粉者相互作用矩阵，其中植物构成一个功能群，动物传粉者构成另一个功能群。从网络生态学的基本原理出发，为一个大小为 $I \\times J$ 的二分邻接矩阵 $A$ 定义以下内容，其条目 $A_{ij} \\in \\{0,1\\}$ 表示植物 $i$ 和传粉者 $j$ 之间是否存在相互作用：\n\n1. 二分网络的连接度 $C$ 是根据“在所有可能的相互作用中已实现的相互作用”这一核心生态学概念定义的。令 $L = \\sum_{i=1}^{I} \\sum_{j=1}^{J} A_{ij}$ 为已实现相互作用的数量。连接度为 $C = L / (I \\cdot J)$。\n\n2. 在受度约束的独立连接零模型（Barber 模块度）下，二分模块度 $Q$ 衡量了模块内相互作用相对于一个配置模型的超额量。令 $k_i^{(P)} = \\sum_{j=1}^{J} A_{ij}$ 为植物 $i$ 的度， $k_j^{(A)} = \\sum_{i=1}^{I} A_{ij}$ 为传粉者 $j$ 的度。将每个节点（植物或传粉者）分配一个模块标签 $g$，该标签由其在 $A$ 诱导的无向二分图中的连通分量给出（因此，同一连通分量内的所有节点共享相同的模块标签；孤立节点各自形成自己的模块）。定义克罗内克 δ 函数 $\\delta(g_i,g_j) = 1$ 如果植物 $i$ 和传粉者 $j$ 共享一个模块标签，否则 $\\delta(g_i,g_j) = 0$。二分模块度为\n$$\nQ = \n\\begin{cases}\n\\frac{1}{L} \\sum_{i=1}^{I} \\sum_{j=1}^{J} \\left( A_{ij} - \\frac{k_i^{(P)} \\, k_j^{(A)}}{L} \\right) \\delta(g_i,g_j),   \\text{if } L > 0, \\\\\n0,  \\text{if } L = 0.\n\\end{cases}\n$$\n\n3. 传粉者相继丧失下的次级灭绝源于一个生态学原理：一种植物能持续存在，当且仅当它至少保留一个传粉者。考虑一个长度为 $J$ 的传粉者移除序列 $\\pi$，并用 $k_i^{(P)}(t)$ 表示在移除 $\\pi$ 中的前 $t$ 个传粉者后植物 $i$ 的剩余度（其中 $t \\in \\{0,1,\\dots,J\\}$ 且 $k_i^{(P)}(0) = k_i^{(P)}$）。定义在步骤 $t$ 的植物存活分数为\n$$\ns(t) = \\frac{1}{I} \\sum_{i=1}^{I} \\mathbf{1}\\!\\left( k_i^{(P)}(t)  0 \\right),\n$$\n其中 $\\mathbf{1}(\\cdot)$ 是指示函数。网络对传粉者丧失的稳健性 $R$ 是存活曲线下的离散面积，\n$$\nR(\\pi) = \\frac{1}{J} \\sum_{t=0}^{J} s(t).\n$$\n对于随机序列，通过对 $n$ 个独立排列进行蒙特卡洛平均来估计稳健性，使用固定的伪随机种子 $s$，\n$$\n\\widehat{R} = \\frac{1}{n} \\sum_{\\ell=1}^{n} R(\\pi^{(\\ell)}).\n$$\n\n你的任务是编写一个完整的程序，对下面的每个测试用例，计算由指定的移除协议定义的 $C$、$Q$ 和 $R$。所有输出必须四舍五入到 $6$ 位小数。最终程序必须生成单行输出，该行是一个列表的列表，其中每个内部列表是某个测试用例的 $[C,Q,R]$，以无空格的 Python 风格列表字面量形式打印（例如 $[[0.1,0.2,0.3],[...],...]$）。\n\n使用的定义：\n- 网络是二分的，有 $I$ 种植物和 $J$ 种传粉者。\n- 邻接矩阵 $A$ 的条目为 $A_{ij} \\in \\{0,1\\}$。\n- 连接度为 $C = L/(I \\cdot J)$，其中 $L = \\sum_{i=1}^{I}\\sum_{j=1}^{J} A_{ij}$。\n- 模块度 $Q$ 的模块分配由 $A$ 诱导的无向二分图的连通分量给出；孤立节点各自形成自己的模块。\n- 如果 $L=0$，按惯例设 $Q=0$。\n- 稳健性 $R$ 是植物存活曲线 $s(t)$ 下的面积，其中 $t$ 以移除的传粉者数量度量。在 $t=0$ 时，初始度为零的植物对 $s(0)$ 的贡献为 $0$。\n\n角度单位不适用。没有物理单位。所有分数必须表示为小数。\n\n测试套件：\n对每个测试用例 $k$，给你 $(A^{(k)}, \\text{移除协议参数})$。请精确实现指定的协议以确保确定性结果。\n\n- 测试用例 1（一般情况；随机移除蒙特卡洛）：\n  - $I=4$, $J=5$,\n  - $A^{(1)} = \\begin{bmatrix}\n  1   1   0   0   1 \\\\\n  0   1   1   0   0 \\\\\n  1   0   0   1   0 \\\\\n  0   0   1   1   0 \\\\\n  \\end{bmatrix}$,\n  - 移除协议：使用种子 $s=17$ 和 $n=200$ 个独立排列的随机传粉者排列。计算 $\\widehat{R}$。\n\n- 测试用例 2（边界情况；完全连接；定向移除）：\n  - $I=2$, $J=2$,\n  - $A^{(2)} = \\begin{bmatrix}\n  1   1 \\\\\n  1   1 \\\\\n  \\end{bmatrix}$,\n  - 移除协议：根据初始度一次性计算的度最高者优先的定向移除；通过升序传粉者索引打破平局。为此单一序列计算 $R$。\n\n- 测试用例 3（边缘情况；不连通且有孤立节点；随机移除蒙特卡洛）：\n  - $I=3$, $J=3$,\n  - $A^{(3)} = \\begin{bmatrix}\n  1   0   0 \\\\\n  1   0   0 \\\\\n  0   0   0 \\\\\n  \\end{bmatrix}$,\n  - 移除协议：使用种子 $s=5$ 和 $n=1000$ 个独立排列的随机传粉者排列。计算 $\\widehat{R}$。\n\n程序要求：\n- 不要读取输入；硬编码测试用例。\n- 对每个测试用例，计算如上定义的 $C$、$Q$ 和 $R$（或 $\\widehat{R}$）。\n- 将 $C$、$Q$ 和 $R$ 分别四舍五入到 $6$ 位小数。\n- 输出单行，即包含三个三元组的 Python 风格列表字面量，例如 $[[C_1,Q_1,R_1],[C_2,Q_2,R_2],[C_3,Q_3,R_3]]$，不含空格。\n\n你的解决方案必须严格基于上述基本定义，不得调用任何外部网络分析库或依赖于未指定的模块度最大化。所有用于 $Q$ 的模块必须是本问题中定义的由 $A$ 诱导的连通分量。", "solution": "问题陈述经过严格验证，确认有效。它在科学上基于网络生态学的既定原则，问题设定良好，具有精确的数学定义和确定性的计算程序，并以客观、明确的语言阐述。测试用例所需的所有数据和参数均已完全提供。因此，我将着手提供一个完整的解决方案。\n\n任务是为三个给定的植物-传粉者相互作用网络计算三个网络指标——连接度（$C$）、二分模块度（$Q$）和稳健性（$R$）。每个指标的解法都直接源于所提供的定义。\n\n**1. 连接度（$C$）的计算**\n\n连接度定义为已实现的相互作用（$L$）与二分网络中所有可能的相互作用（$I \\times J$）之比。已实现的相互作用数 $L$ 是邻接矩阵 $A$ 中非零条目的总数。\n公式为：\n$$\nC = \\frac{L}{I \\cdot J} = \\frac{\\sum_{i=1}^{I} \\sum_{j=1}^{J} A_{ij}}{I \\cdot J}\n$$\n对每个测试用例，只需将给定矩阵 $A$ 的元素求和，然后除以其维度的乘积，即可直接计算。\n\n**2. 二分模块度（$Q$）的计算**\n\n二分模块度 $Q$ 量化了网络划分为不同模块的程度。问题明确规定，模块由邻接矩阵 $A$ 诱导的无向二分图的连通分量定义。这一规定避免了通常情况下复杂的模块度最大化任务。\n\n$Q$ 的公式为：\n$$\nQ = \\frac{1}{L} \\sum_{i=1}^{I} \\sum_{j=1}^{J} \\left( A_{ij} - \\frac{k_i^{(P)} \\, k_j^{(A)}}{L} \\right) \\delta(g_i,g_j)\n$$\n其中，如果植物 $i$ 和传粉者 $j$ 在同一模块（连通分量）中，则 $\\delta(g_i,g_j)=1$，否则为 $0$。如果 $L=0$，$Q=0$。\n\n这个表达式可以通过对模块求和而不是对单个节点求和来简化。设 $\\mathcal{M}$ 为模块（连通分量）的集合。设 $L_m$ 为模块 $m$ 内的链接数。由于模块是连通分量，任何链接 $A_{ij}=1$ 的端点 $i$ 和 $j$ 必在同一分量内。因此，$\\sum_{m \\in \\mathcal{M}} L_m = L$。\n\n求和可以按模块划分：\n$$\nQ = \\frac{1}{L} \\sum_{m \\in \\mathcal{M}} \\sum_{i \\in m_P, j \\in m_A} \\left( A_{ij} - \\frac{k_i^{(P)} k_j^{(A)}}{L} \\right)\n$$\n其中 $m_P$ 和 $m_A$ 是模块 $m$ 中的植物和传粉者节点集。这可以简化为：\n$$\nQ = \\frac{1}{L} \\sum_{m \\in \\mathcal{M}} \\left( L_m - \\frac{(\\sum_{i \\in m_P} k_i^{(P)}) (\\sum_{j \\in m_A} k_j^{(A)})}{L} \\right)\n$$\n对于一个连通分量 $m$，其植物节点度的总和等于其传粉者节点度的总和，这又等于该分量内的链接数 $L_m$。即 $\\sum_{i \\in m_P} k_i^{(P)} = \\sum_{j \\in m_A} k_j^{(A)} = L_m$。\n代入此式可得：\n$$\nQ = \\sum_{m \\in \\mathcal{M}} \\left( \\frac{L_m}{L} - \\left(\\frac{L_m}{L}\\right)^2 \\right)\n$$\n令 $e_m = L_m/L$ 为模块 $m$ 中的链接比例，则公式变为 $Q = \\sum_{m \\in \\mathcal{M}} (e_m - e_m^2)$。\n\n算法如下：\n1.  从矩阵 $A$ 构建二分图。该图有 $I+J$ 个节点。\n2.  使用广度优先搜索（BFS）或深度优先搜索（DFS）找到所有连通分量。每个分量即为一个模块。\n3.  对每个模块 $m$，计算其包含的链接数 $L_m$。\n4.  使用简化后的公式计算 $Q$。\n\n**3. 网络稳健性（$R$）的计算**\n\n稳健性衡量在传粉者相继被移除后植物的持续存在能力。我们必须根据每个测试用例指定的移除协议来模拟此过程。\n\n对于单个移除序列 $\\pi$ 的过程是：\n1.  初始化存活分数列表。在步骤 $t=0$（任何移除前），计算初始植物度 $k_i^{(P)}(0)$。存活分数为 $s(0) = \\frac{1}{I} \\sum_{i=1}^{I} \\mathbf{1}(k_i^{(P)}(0) > 0)$。\n2.  对于从 $1$ 到 $J$ 的每一步 $t$，移除序列 $\\pi$ 中的第 $t$ 个传粉者。这对应于将邻接矩阵的一列设为零。\n3.  每次移除后，重新计算所有植物的度 $k_i^{(P)}(t)$，并计算新的存活分数 $s(t)$。\n4.  在所有 $J$ 个传粉者被移除后，我们得到一个包含 $J+1$ 个存活分数的序列：$s(0), s(1), \\dots, s(J)$。注意 $s(J)$ 始终为 $0$。\n5.  此序列的稳健性按规定计算：\n$$\nR(\\pi) = \\frac{1}{J} \\sum_{t=0}^{J} s(t)\n$$\n\n对每个测试用例，协议是：\n-   **测试用例 1 和 3（随机移除）**：通过对 $n$ 个独立随机排列 $\\pi^{(\\ell)}$ 的 $R(\\pi^{(\\ell)})$进行平均，得到估计值 $\\widehat{R}$，使用固定的伪随机种子以保证可复现性。\n-   **测试用例 2（定向移除）**：通过将传粉者按其初始度降序排序来构建一个单一的、确定性的移除序列，平局时按传粉者索引升序处理。为这一个序列计算 $R$。\n\n所有计算都将执行，并且每个测试用例的 $[C, Q, R]$ 最终结果将四舍五入到 $6$ 位小数。\n\n**测试用例计算：**\n\n-   **测试用例 1**：$I=4, J=5$。$L=8$。$C = 8/20 = 0.4$。该图是完全连通的，形成一个模块。因此 $L_1=L=8$, $e_1=1$, 且 $Q = 1 - 1^2 = 0$。$\\widehat{R}$ 通过蒙特卡洛模拟计算。\n-   **测试用例 2**：$I=2, J=2$。$L=4$。$C = 4/4 = 1.0$。该图是一个完全二分图，因此只有一个连通分量。$Q=0$。对于定向移除，两个传粉者的度都是 $2$。通过索引打破平局，得到移除序列 $(0, 1)$。这导致 $s(0)=1.0, s(1)=1.0, s(2)=0.0$。$R = (1.0+1.0+0.0)/2 = 1.0$。\n-   **测试用例 3**：$I=3, J=3$。$L=2$。$C = 2/9 \\approx 0.222222$。该图有一个包含所有链接的非平凡分量，以及多个孤立节点分量。因此，$L_1=L=2$, $e_1=1$, 且 $Q = 1 - 1^2 = 0$。$\\widehat{R}$ 通过蒙特卡洛模拟计算。\n\n实现将精确遵循这些原则。", "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases, calculating Connectance (C),\n    Bipartite Modularity (Q), and Robustness (R) for each.\n    \"\"\"\n\n    def calculate_c(A):\n        \"\"\"Calculates connectance C.\"\"\"\n        if A.size == 0:\n            return 0.0\n        I, J = A.shape\n        L = np.sum(A)\n        return L / (I * J)\n\n    def calculate_q(A):\n        \"\"\"Calculates bipartite modularity Q.\"\"\"\n        I, J = A.shape\n        L = np.sum(A)\n        if L == 0:\n            return 0.0\n\n        num_nodes = I + J\n        adj = [[] for _ in range(num_nodes)]\n        for i in range(I):\n            for j in range(J):\n                if A[i, j] == 1:\n                    adj[i].append(I + j)\n                    adj[I + j].append(i)\n\n        visited = [False] * num_nodes\n        components = []\n        for i in range(num_nodes):\n            if not visited[i]:\n                current_component = []\n                queue = deque([i])\n                visited[i] = True\n                while queue:\n                    u = queue.popleft()\n                    current_component.append(u)\n                    for v in adj[u]:\n                        if not visited[v]:\n                            visited[v] = True\n                            queue.append(v)\n                components.append(current_component)\n\n        L_m_list = []\n        for comp in components:\n            plant_nodes = sorted([node for node in comp if node  I])\n            pollinator_nodes = sorted([node - I for node in comp if node >= I])\n\n            if not plant_nodes or not pollinator_nodes:\n                # This component consists only of one type of node (isolated),\n                # so it has no links within it.\n                L_m_list.append(0)\n            else:\n                sub_matrix = A[np.ix_(plant_nodes, pollinator_nodes)]\n                L_m = np.sum(sub_matrix)\n                L_m_list.append(L_m)\n\n        q_val = 0.0\n        for L_m in L_m_list:\n            if L > 0:\n                e_m = L_m / L\n                q_val += e_m - e_m**2\n        return q_val\n\n    def _calculate_r_for_sequence(A, pi):\n        \"\"\"Helper function to calculate R for a single permutation.\"\"\"\n        I, J = A.shape\n        if J == 0:\n             if I > 0:\n                 k_p_0 = np.sum(A, axis=1) if A.shape[1] > 0 else np.zeros(I)\n                 s0 = np.sum(k_p_0 > 0) / I\n                 # R is sum(s(t))/J. If J=0, it's ill-defined. The problem implies J>=1.\n                 # Let's return s(0) as a reasonable edge case, though not strictly per formula.\n                 return s0\n             return 0.0\n\n        A_current = A.copy()\n        s_values = []\n\n        # t=0\n        plant_degrees = np.sum(A_current, axis=1)\n        s_values.append(np.sum(plant_degrees > 0) / I)\n\n        # t=1 to J\n        for pollinator_idx in pi:\n            A_current[:, pollinator_idx] = 0\n            plant_degrees = np.sum(A_current, axis=1)\n            s_values.append(np.sum(plant_degrees > 0) / I)\n        \n        return np.sum(s_values) / J\n    \n    def calculate_r(A, protocol):\n        \"\"\"Calculates robustness R based on the specified protocol.\"\"\"\n        I, J = A.shape\n        removal_type = protocol['type']\n        \n        if removal_type == 'random':\n            seed = protocol['seed']\n            n = protocol['n']\n            rng = np.random.default_rng(seed)\n            r_values = []\n            for _ in range(n):\n                pi = rng.permutation(J)\n                r_values.append(_calculate_r_for_sequence(A, pi))\n            return np.mean(r_values)\n\n        elif removal_type == 'targeted':\n            pollinator_degrees = np.sum(A, axis=0)\n            indices = np.arange(J)\n            sorted_indices = sorted(indices, key=lambda i: (-pollinator_degrees[i], i))\n            pi = np.array(sorted_indices)\n            return _calculate_r_for_sequence(A, pi)\n        \n        else:\n            raise ValueError(\"Unknown removal protocol\")\n\n    test_cases = [\n        {\n            \"A\": np.array([\n                [1, 1, 0, 0, 1],\n                [0, 1, 1, 0, 0],\n                [1, 0, 0, 1, 0],\n                [0, 0, 1, 1, 0]\n            ]),\n            \"protocol\": {\"type\": \"random\", \"seed\": 17, \"n\": 200}\n        },\n        {\n            \"A\": np.array([\n                [1, 1],\n                [1, 1]\n            ]),\n            \"protocol\": {\"type\": \"targeted\"}\n        },\n        {\n            \"A\": np.array([\n                [1, 0, 0],\n                [1, 0, 0],\n                [0, 0, 0]\n            ]),\n            \"protocol\": {\"type\": \"random\", \"seed\": 5, \"n\": 1000}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        A = case[\"A\"]\n        protocol = case[\"protocol\"]\n        \n        C = calculate_c(A)\n        Q = calculate_q(A)\n        R = calculate_r(A, protocol)\n        \n        results.append([round(C, 6), round(Q, 6), round(R, 6)])\n\n    print(str(results).replace(\" \",\"\"))\n\nsolve()\n```", "id": "2602895"}]}