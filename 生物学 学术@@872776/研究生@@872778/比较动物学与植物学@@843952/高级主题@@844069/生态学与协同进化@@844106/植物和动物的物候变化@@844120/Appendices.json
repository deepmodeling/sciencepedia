{"hands_on_practices": [{"introduction": "积温模型，特别是生长度日（Growing Degree Days, GDD）模型，是预测植物和变温动物物候事件的基石。该模型将物候发生与一个关键的环境驱动因素——温度联系起来。通过这个练习，您将亲手实践应用GDD模型，并学习如何量化物候时间对气候变暖的敏感性，这是评估气候变化影响的一项关键技能。[@problem_id:2595740]", "problem": "基于阈值的积温模型被广泛用于表示对温度有响应的动植物物候事件的时间。在该模型中，事件（例如，首次开花或首次迁徙到达）发生在最早的日期指数 $D^{\\ast}$，使得累积生长度日等于物种特定的需求量 $H$。每日生长度日计算为高于基准温度 $T_{b}$ 的正值部分：\n$$\nG(T) = \\max\\{T - T_{b}, 0\\},\n$$\n截至第 $d$ 天的累积积温为\n$$\nC(d) = \\sum_{i=1}^{d} G(T_i).\n$$\n始见日 $D^{\\ast}$ 是满足 $C(d) \\ge H$ 的最小 $d$。考虑一个地点，其基准温度 $T_{b} = 5\\,^{\\circ}\\mathrm{C}$，积温需求量 $H = 100$ 度日（高于基准温度）。从年日序 $\\mathrm{DOY} = 80$ 开始，第 $i = 1,\\dots,22$ 天的历史日平均温度（单位：摄氏度）由以下给出：\n$$\n[T_1,\\dots,T_{22}] = [4.2,\\, 6.1,\\, 7.3,\\, 5.2,\\, 8.0,\\, 9.4,\\, 10.1,\\, 12.3,\\, 8.7,\\, 6.4,\\, 7.2,\\, 11.5,\\, 13.6,\\, 14.2,\\, 10.8,\\, 9.1,\\, 12.7,\\, 13.4,\\, 15.0,\\, 16.3,\\, 17.1,\\, 16.8].\n$$\n假设一个大小为 $\\Delta T$（单位：$^{\\circ}\\mathrm{C}$）的均匀增温，在事件发生前的每一天都将日平均温度提高相同的量，而 $H$ 和 $T_b$ 保持不变。\n\n仅使用上述定义和微分的第一性原理，执行以下操作：\n\n- 通过对始见条件关于 $\\Delta T$ 进行隐式微分，并将 $d$ 在 $D^{\\ast}$ 附近视为连续可松弛变量，推导始见指数相对于均匀增温的一阶变化 $\\frac{\\partial D^{\\ast}}{\\partial \\Delta T}$，在 $\\Delta T = 0^+$ 处求值。清晰地陈述求导所需的任何正则性假设。\n\n- 使用所提供的数据，计算每 $+1\\,^{\\circ}\\mathrm{C}$ 均匀增温导致的始见日期变化的数值。最终答案以“天/摄氏度”为单位，并四舍五入至四位有效数字。\n\n- 简要解释在 $\\Delta T = 1\\,^{\\circ}\\mathrm{C}$ 处求值的、由\n$$\n\\mathcal{E} \\equiv \\left.\\frac{\\partial D^{\\ast}}{\\partial \\Delta T}\\right|_{\\Delta T=0^{+}} \\cdot \\frac{\\Delta T}{D^{\\ast}},\n$$\n定义的物候时间相对于均匀增温的相应弹性 $\\mathcal{E}$，用对积温有贡献的天数比例和始见日的边际度日累积量来解释。\n\n您最终报告的值必须是每 $+1\\,^{\\circ}\\mathrm{C}$ 增温导致的始见日期变化的单一数值，单位为“天/摄氏度”，并四舍五入至四位有效数字。", "solution": "该问题要求推导和计算物候始见日指数 $D^{\\ast}$ 相对于均匀增温 $\\Delta T$ 的一阶变化。这个量就是 $\\frac{\\partial D^{\\ast}}{\\partial \\Delta T}$。\n\n首先，我们必须确定在 $\\Delta T = 0$ 的历史温度条件下的基准始见日，记为 $D^{\\ast}_0$。每日生长度日 (GDD) 的模型是 $G(T) = \\max\\{T - T_{b}, 0\\}$，基准温度为 $T_{b} = 5\\,^{\\circ}\\mathrm{C}$。始见事件发生在累积 GDD $C(d) = \\sum_{i=1}^{d} G(T_i)$ 达到或超过所需积温 $H = 100$ 度日的第一个日期指数 $D^{\\ast}$。\n\n我们使用提供的温度数据计算每日的 GDD $G(T_i)$，然后计算累积和 $C(d)$。\n对于 $i=1$，$T_1=4.2$，因此 $G(T_1) = \\max\\{4.2 - 5, 0\\} = 0$。$C(1)=0$。\n对于 $i=2$，$T_2=6.1$，因此 $G(T_2) = \\max\\{6.1 - 5, 0\\} = 1.1$。$C(2)=1.1$。\n对所有后续日期重复此过程：\n$C(3) = C(2) + \\max\\{7.3 - 5, 0\\} = 1.1 + 2.3 = 3.4$。\n$C(4) = C(3) + \\max\\{5.2 - 5, 0\\} = 3.4 + 0.2 = 3.6$。\n$C(5) = 3.6 + 3.0 = 6.6$。\n$C(6) = 6.6 + 4.4 = 11.0$。\n$C(7) = 11.0 + 5.1 = 16.1$。\n$C(8) = 16.1 + 7.3 = 23.4$。\n$C(9) = 23.4 + 3.7 = 27.1$。\n$C(10) = 27.1 + 1.4 = 28.5$。\n$C(11) = 28.5 + 2.2 = 30.7$。\n$C(12) = 30.7 + 6.5 = 37.2$。\n$C(13) = 37.2 + 8.6 = 45.8$。\n$C(14) = 45.8 + 9.2 = 55.0$。\n$C(15) = 55.0 + 5.8 = 60.8$。\n$C(16) = 60.8 + 4.1 = 64.9$。\n$C(17) = 64.9 + 7.7 = 72.6$。\n$C(18) = 72.6 + 8.4 = 81.0$。\n$C(19) = 81.0 + \\max\\{15.0 - 5, 0\\} = 81.0 + 10.0 = 91.0$。\n$C(20) = 91.0 + \\max\\{16.3 - 5, 0\\} = 91.0 + 11.3 = 102.3$。\n\n累积和 $C(d)$ 在第 $d=20$ 天首次超过 $H=100$，因为 $C(19)=91.0  100$ 且 $C(20)=102.3 \\ge 100$。因此，基准始见日为 $D^{\\ast}_0 = 20$。\n\n接下来，我们推导灵敏度 $\\frac{\\partial D^{\\ast}}{\\partial \\Delta T}$。问题陈述，日期指数 $d$ 在始见日 $D^{\\ast}$ 附近可以被视为一个连续变量 $D$。始见条件于是成为一个方程 $C(D^{\\ast}, \\Delta T) = H$，其中 $D^{\\ast}$ 被视为增温 $\\Delta T$ 的函数。累积和函数为：\n$$C(D^{\\ast}, \\Delta T) = \\sum_{i=1}^{\\lfloor D^{\\ast} \\rfloor} \\max\\{T_i + \\Delta T - T_b, 0\\}$$\n为了应用微积分，我们假设 $D^{\\ast}(\\Delta T)$ 是一个可微函数，并且累积和函数 $C$ 对其参数 $D$ 和 $\\Delta T$ 也是可微的。一个必要的正则性假设是，对于给定的温度，在任何一天 $i$，$T_i + \\Delta T \\neq T_b$ 都成立，这确保了 $\\max$ 函数的可微性。\n\n我们对始见条件 $C(D^{\\ast}(\\Delta T), \\Delta T) = H$ 关于 $\\Delta T$ 进行隐式微分。由于 $H$ 是一个常数，其导数为 $0$。使用多变量链式法则：\n$$ \\frac{dC}{d\\Delta T} = \\frac{\\partial C}{\\partial D^{\\ast}} \\frac{\\partial D^{\\ast}}{\\partial \\Delta T} + \\frac{\\partial C}{\\partial \\Delta T} = 0 $$\n求解所需的灵敏度，得到：\n$$ \\frac{\\partial D^{\\ast}}{\\partial \\Delta T} = - \\frac{\\partial C / \\partial \\Delta T}{\\partial C / \\partial D^{\\ast}} $$\n偏导数 $\\frac{\\partial C}{\\partial D^{\\ast}}$ 表示每天的 GDD 累积率。在连续近似中，这是始见日 $D^{\\ast}$ 的 GDD 值：\n$$ \\frac{\\partial C}{\\partial D^{\\ast}} \\approx G(T_{D^{\\ast}} + \\Delta T) = \\max\\{T_{D^{\\ast}} + \\Delta T - T_b, 0\\} $$\n偏导数 $\\frac{\\partial C}{\\partial \\Delta T}$ 是由于增温 $\\Delta T$ 导致的截至第 $D^{\\ast}$ 天的总累积 GDD 的变化：\n$$ \\frac{\\partial C}{\\partial \\Delta T} = \\frac{\\partial}{\\partial \\Delta T} \\sum_{i=1}^{D^{\\ast}} \\max\\{T_i + \\Delta T - T_b, 0\\} = \\sum_{i=1}^{D^{\\ast}} \\frac{\\partial}{\\partial \\Delta T} \\max\\{T_i + \\Delta T - T_b, 0\\} $$\n在我们的正则性假设下，$\\max$ 项的导数是指示函数 $\\mathbb{I}(T_i + \\Delta T  T_b)$，如果条件成立则为 $1$，否则为 $0$。\n$$ \\frac{\\partial C}{\\partial \\Delta T} = \\sum_{i=1}^{D^{\\ast}} \\mathbb{I}(T_i + \\Delta T  T_b) = N(D^{\\ast}, \\Delta T) $$\n这个和 $N(D^{\\ast}, \\Delta T)$ 是截至 $D^{\\ast}$ 天对积温有贡献的天数。\n\n结合这些分量，灵敏度为：\n$$ \\frac{\\partial D^{\\ast}}{\\partial \\Delta T} = - \\frac{N(D^{\\ast}, \\Delta T)}{\\max\\{T_{D^{\\ast}} + \\Delta T - T_b, 0\\}} $$\n我们在 $\\Delta T = 0^{+}$ 处计算此表达式的值，此时 $D^{\\ast} = D^{\\ast}_0 = 20$。\n分母是基准始见日的 GDD：\n$$ \\max\\{T_{20} + 0 - T_b, 0\\} = \\max\\{16.3 - 5, 0\\} = 11.3 $$\n分子 $N(20, 0)$ 是从 $i=1$ 到 $i=20$ 满足 $T_i  T_b=5$ 的天数。检查数据发现，只有 $T_1 = 4.2$ 不高于 $5$。因此，有贡献的天数为 $N(20, 0) = 20 - 1 = 19$。\n\n因此，灵敏度为：\n$$ \\left. \\frac{\\partial D^{\\ast}}{\\partial \\Delta T} \\right|_{\\Delta T = 0^{+}} = - \\frac{19}{11.3} \\approx -1.6814159... $$\n问题要求这个数值，它表示每 $+1\\,^{\\circ}\\mathrm{C}$ 增温导致的始见日期变化，四舍五入到四位有效数字。该值为 $-1.681$。负号正确地表示了增温导致始见日提前（即一个更小的日期指数 $D^{\\ast}$）。\n\n对于弹性 $\\mathcal{E} \\equiv \\left.\\frac{\\partial D^{\\ast}}{\\partial \\Delta T}\\right|_{\\Delta T=0^{+}} \\cdot \\frac{\\Delta T}{D^{\\ast}}$ 的解释，当在 $\\Delta T = 1\\,^{\\circ}\\mathrm{C}$ 处求值时：\n$$ \\mathcal{E} = \\left(-\\frac{N(D_0^{\\ast}, 0)}{G(T_{D_0^{\\ast}})}\\right) \\cdot \\frac{\\Delta T}{D_0^{\\ast}} = -\\frac{\\Delta T}{G(T_{D_0^{\\ast}})} \\left(\\frac{N(D_0^{\\ast}, 0)}{D_0^{\\ast}}\\right) $$\n这个表达式表明，弹性（对于给定的 $\\Delta T = 1$）与一个比率成反比。项 $\\frac{N(D_0^{\\ast}, 0)}{D_0^{\\ast}}$ 是到始见日为止对积温有积极贡献的天数比例（在本例中为 $19/20$）。项 $G(T_{D_0^{\\ast}})$ 是在跨过阈值的特定日子的边际 GDD 累积量（在本例中为 $11.3$）。因此，当始见前时期内有更高比例的天数对增温有贡献时，物候响应更强；而当最后一天的 GDD 累积量很大时，物候响应则较弱。\n\n最终答案是灵敏度导数的数值。", "answer": "$$\\boxed{-1.681}$$", "id": "2595740"}, {"introduction": "物候变化并非孤立发生，其生态影响往往取决于它们如何改变物种间的相互作用，例如可能导致“物候失配”。本练习介绍了一种量化物种间同步性的有力工具——重叠积分，它可以衡量植物与其传粉者等相互作用物种在时间上的匹配程度。通过解决这个问题，您将掌握计算和解释这一关键生态指标的分析方法，从而能够评估物候变化对物种同步性的潜在影响。[@problem_id:2595735]", "problem": "在比较动物学和植物学中，一种资源与一种消费者之间的物候同步性，可以通过它们标准化的活动曲线之间的时间重叠面积来量化。设 $R(t)$ 表示标准化的资源可用性曲线（例如，一种植物随时间变化的开花强度），$D(t)$ 表示标准化的消费者需求曲线（例如，一个传粉者随时间变化的觅食需求）。假设两者都是非负函数，且其对时间的积分为 $1$，因此每个都可以被视为概率密度函数（PDF）。一个广泛使用的时间同步性的无量纲度量是由以下定义的重叠积分：\n$$\nS \\equiv \\int_{-\\infty}^{\\infty} \\min\\big(R(t),D(t)\\big)\\,dt,\n$$\n该积分的取值范围为 $[0,1]$，当且仅当 $R(t)\\equiv D(t)$ 几乎处处成立时，其值等于 $1$。\n\n从概率密度函数的基本定义和积分的基本性质出发，推导出一个关于 $S$ 的闭式表达式，该表达式应使用 $R(t)=D(t)$ 时的交点时间以及与 $R(t)$ 和 $D(t)$ 对应的累积分布函数（CDFs）来表示。然后，将植物资源曲线和动物需求曲线建模为具有不同均值和方差的高斯（正态）PDF：\n$$\nR(t)=\\frac{1}{\\sigma_{R}\\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{(t-\\mu_{R})^{2}}{2\\sigma_{R}^{2}}\\right),\\quad\nD(t)=\\frac{1}{\\sigma_{D}\\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{(t-\\mu_{D})^{2}}{2\\sigma_{D}^{2}}\\right),\n$$\n参数为 $\\mu_{R}=\\;120$（年积日），$\\sigma_{R}=\\;10$（天），$\\mu_{D}=\\;135$（年积日），以及 $\\sigma_{D}=\\;15$（天）。计算这些参数值下的同步性 $S$。将最终数值答案四舍五入到 $4$ 位有效数字。最终答案以纯数字形式表示，不带单位。", "solution": "问题要求一个分为两部分的解答：首先，推导同步性指数 $S$ 的一个通用表达式；其次，为两个特定的高斯分布计算其值。\n\n我们从同步性指数 $S$ 的定义开始：\n$$\nS = \\int_{-\\infty}^{\\infty} \\min\\big(R(t), D(t)\\big)\\,dt\n$$\n其中 $R(t)$ 和 $D(t)$ 是概率密度函数（PDFs）。这意味着它们是非负的，并且积分为 $1$：\n$$\n\\int_{-\\infty}^{\\infty} R(t)\\,dt = 1, \\quad \\int_{-\\infty}^{\\infty} D(t)\\,dt = 1\n$$\n$\\min(R(t), D(t))$ 的值取决于在给定的时间 $t$，哪个函数更小。让我们定义交点集合 $T_{int} = \\{t | R(t) = D(t)\\}$。这些点将实数线划分为 $R(t) \\le D(t)$ 或 $R(t)  D(t)$ 的区域。然后我们可以将 $S$ 的积分拆分：\n$$\nS = \\int_{\\{t | R(t) \\le D(t)\\}} R(t)\\,dt + \\int_{\\{t | R(t)  D(t)\\}} D(t)\\,dt\n$$\n对于两个具有不同方差的独立高斯分布，通常有两个交点，我们将其表示为 $t_1$ 和 $t_2$，且 $t_1  t_2$。在区间 $(-\\infty, t_1)$、$(t_1, t_2)$ 和 $(t_2, \\infty)$ 中，函数值的相对大小取决于它们的参数。高斯函数 $N(\\mu, \\sigma^2)$ 的尾部以 $\\exp(-t^2/(2\\sigma^2))$ 的形式衰减到零。较大的方差 $\\sigma^2$ 导致较慢的衰减。PDF 的峰值高度与 $\\sigma$ 成反比，具体为 $1/(\\sigma\\sqrt{2\\pi})$。\n\n在给定的特定情况下，$\\sigma_R = 10$ 且 $\\sigma_D = 15$。由于 $\\sigma_D > \\sigma_R$，函数 $D(t)$ 的尾部比 $R(t)$ 更“重”，但 $R(t)$ 的峰值更高。因此，当 $t \\to \\pm\\infty$ 时，$D(t)$ 将大于 $R(t)$。在两个交点之间，$R(t)$ 将占主导地位（即值更大）。因此，我们有：\n- 对于 $t \\in (-\\infty, t_1] \\cup [t_2, \\infty)$，$R(t) \\le D(t)$\n- 对于 $t \\in (t_1, t_2)$，$R(t)  D(t)$\n\n将这些区域代入 $S$ 的积分中：\n$$\nS = \\int_{-\\infty}^{t_1} R(t)\\,dt + \\int_{t_1}^{t_2} D(t)\\,dt + \\int_{t_2}^{\\infty} R(t)\\,dt\n$$\n现在，我们使用累积分布函数（CDFs）$F_R(t) = \\int_{-\\infty}^{t} R(\\tau)\\,d\\tau$ 和 $F_D(t) = \\int_{-\\infty}^{t} D(\\tau)\\,d\\tau$ 来表示这些积分。\n第一项是 $\\int_{-\\infty}^{t_1} R(t)\\,dt = F_R(t_1)$。\n第二项是 $\\int_{t_1}^{t_2} D(t)\\,dt = F_D(t_2) - F_D(t_1)$。\n第三项是 $\\int_{t_2}^{\\infty} R(t)\\,dt = \\int_{-\\infty}^{\\infty} R(t)\\,dt - \\int_{-\\infty}^{t_2} R(t)\\,dt = 1 - F_R(t_2)$。\n\n将这些项组合起来，得到 $S$ 的所需闭式表达式：\n$$\nS = F_R(t_1) + \\big(F_D(t_2) - F_D(t_1)\\big) + \\big(1 - F_R(t_2)\\big)\n$$\n$$\nS = 1 + F_R(t_1) - F_R(t_2) + F_D(t_2) - F_D(t_1)\n$$\n这就完成了问题的第一部分。\n\n对于第二部分，我们必须为给定的高斯PDFs计算 $S$：\n$R(t) \\sim N(\\mu_R, \\sigma_R^2)$，其中 $\\mu_R = 120, \\sigma_R = 10$。\n$D(t) \\sim N(\\mu_D, \\sigma_D^2)$，其中 $\\mu_D = 135, \\sigma_D = 15$。\n\n首先，我们通过求解 $R(t) = D(t)$ 来找到交点 $t_1, t_2$：\n$$\n\\frac{1}{\\sigma_{R}\\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{(t-\\mu_{R})^{2}}{2\\sigma_{R}^{2}}\\right) = \\frac{1}{\\sigma_{D}\\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{(t-\\mu_{D})^{2}}{2\\sigma_{D}^{2}}\\right)\n$$\n对两边取自然对数并重新整理各项，得到一个二次方程 $At^2+Bt+C=0$：\n$$\n\\ln\\left(\\frac{1}{\\sigma_R}\\right) - \\frac{(t-\\mu_R)^2}{2\\sigma_R^2} = \\ln\\left(\\frac{1}{\\sigma_D}\\right) - \\frac{(t-\\mu_D)^2}{2\\sigma_D^2}\n$$\n$$\n\\left(\\frac{1}{2\\sigma_D^2} - \\frac{1}{2\\sigma_R^2}\\right)t^2 + \\left(\\frac{\\mu_R}{\\sigma_R^2} - \\frac{\\mu_D}{\\sigma_D^2}\\right)t + \\left(\\frac{\\mu_D^2}{2\\sigma_D^2} - \\frac{\\mu_R^2}{2\\sigma_R^2} + \\ln\\left(\\frac{\\sigma_R}{\\sigma_D}\\right)\\right) = 0\n$$\n系数是：\n$A = \\frac{\\sigma_R^2 - \\sigma_D^2}{2\\sigma_R^2\\sigma_D^2} = \\frac{10^2 - 15^2}{2 \\cdot 10^2 \\cdot 15^2} = \\frac{100 - 225}{45000} = \\frac{-125}{45000} = -\\frac{1}{360}$\n$B = \\frac{\\mu_R}{\\sigma_R^2} - \\frac{\\mu_D}{\\sigma_D^2} = \\frac{120}{100} - \\frac{135}{225} = 1.2 - 0.6 = 0.6$\n$C = \\frac{135^2}{2 \\cdot 15^2} - \\frac{120^2}{2 \\cdot 10^2} + \\ln\\left(\\frac{10}{15}\\right) = \\frac{18225}{450} - \\frac{14400}{200} - \\ln(1.5) = 40.5 - 72 - \\ln(1.5) = -31.5 - \\ln(1.5)$\n\n二次方程为 $-\\frac{1}{360}t^2 + 0.6t - (31.5+\\ln(1.5)) = 0$。两边乘以 $-360$：\n$t^2 - 216t + 360(31.5+\\ln(1.5)) = 0$\n$t^2 - 216t + 11340 + 360\\ln(1.5) = 0$\n使用二次公式求解 $t$：\n$$\nt = \\frac{216 \\pm \\sqrt{216^2 - 4(11340 + 360\\ln(1.5))}}{2} = 108 \\pm \\sqrt{108^2 - (11340 + 360\\ln(1.5))}\n$$\n$$\nt = 108 \\pm \\sqrt{11664 - 11340 - 360\\ln(1.5)} = 108 \\pm \\sqrt{324 - 360\\ln(1.5)}\n$$\n使用 $\\ln(1.5) \\approx 0.405465$ 的值：\n$t = 108 \\pm \\sqrt{324 - 360(0.405465)} = 108 \\pm \\sqrt{324 - 145.9674} = 108 \\pm \\sqrt{178.0326}$\n$t \\approx 108 \\pm 13.3429$\n这给出了交点：\n$t_1 \\approx 108 - 13.3429 = 94.6571$\n$t_2 \\approx 108 + 13.3429 = 121.3429$\n\n接下来，我们计算这些点上的累积分布函数值。对于一个一般的正态分布 $N(\\mu, \\sigma^2)$，其CDF为 $F(t) = \\Phi\\left(\\frac{t-\\mu}{\\sigma}\\right)$，其中 $\\Phi(z)$ 是标准正态CDF。\n我们计算标准化的自变量：\n$z_{R1} = \\frac{t_1 - \\mu_R}{\\sigma_R} = \\frac{94.6571 - 120}{10} = -2.53429$\n$z_{R2} = \\frac{t_2 - \\mu_R}{\\sigma_R} = \\frac{121.3429 - 120}{10} = 0.13429$\n$z_{D1} = \\frac{t_1 - \\mu_D}{\\sigma_D} = \\frac{94.6571 - 135}{15} = -2.68953$\n$z_{D2} = \\frac{t_2 - \\mu_D}{\\sigma_D} = \\frac{121.3429 - 135}{15} = -0.91047$\n\n我们找到对应的 $\\Phi(z)$ 值：\n$F_R(t_1) = \\Phi(-2.53429) \\approx 0.005634$\n$F_R(t_2) = \\Phi(0.13429) \\approx 0.55343$\n$F_D(t_1) = \\Phi(-2.68953) \\approx 0.003577$\n$F_D(t_2) = \\Phi(-0.91047) \\approx 0.18129$\n\n最后，将这些值代入 $S$ 的表达式中：\n$S = 1 + F_R(t_1) - F_R(t_2) + F_D(t_2) - F_D(t_1)$\n$S \\approx 1 + 0.005634 - 0.55343 + 0.18129 - 0.003577$\n$S \\approx 1 - (0.55343 - 0.005634) + (0.18129 - 0.003577)$\n$S \\approx 1 - 0.547796 + 0.177713 = 1 - 0.370083 = 0.629917$\n\n将结果四舍五入到 $4$ 位有效数字，得到 $0.6299$。", "answer": "$$\n\\boxed{0.6299}\n$$", "id": "2595735"}, {"introduction": "在分析长期物候记录时，一个核心问题是确定所观察到的变化是渐进的趋势还是在某个特定时间发生的突变。贝叶斯变点模型为解决这一问题提供了一个严谨的统计框架，它不仅能识别这种转变最可能发生的时间，还能量化与该时间点相关的不确定性。这项实践将引导您深入了解该模型的理论推导和计算实现，为您提供一个分析真实世界物候时间序列的强大工具。[@problem_id:2595654]", "problem": "给您一个物种在连续日历年序列中春季物候事件起始年积日（DOY）的年度观测数据。年积日（DOY）值的单位是天。您将把潜在的物候变化建模为平均 DOY 的单个变点，并计算在指定候选日历年发生变化的后验概率。\n\n假设基于高斯分布测量误差和使用共轭先验的贝叶斯推断等经过充分检验的事实，采用以下生成模型：\n- 观测到的 DOY 序列表示为 $x_{1},\\dots,x_{N}$，对应于严格递增的日历年 $y_{1},\\dots,y_{N}$。\n- 以变点年份 $\\tau$（或无变化）为条件，该序列被分割成至多两个连续的分段。在每个分段 $s \\in \\{1,2\\}$ 内，观测值是独立同分布的，$x_{i} \\mid \\mu_{s},\\sigma^{2} \\sim \\mathcal{N}(\\mu_{s},\\sigma^{2})$，其中 $\\sigma^{2}$ 是已知的，而 $\\mu_{s}$ 是未知的特定分段的均值。\n- 分段均值具有独立的高斯先验 $\\mu_{s} \\sim \\mathcal{N}(\\mu_{0},v_{0})$，其中超参数 $\\mu_{0}$ 和 $v_{0}$ 是已知的。\n- 变点位置的先验在 $N$ 个互斥状态上是均匀分布的：要么“无变化”（一个分段跨越所有 $N$ 年），要么变化始于某个内部日历年 $\\{y_{2},\\dots,y_{N}\\}$（对于某个 $j \\in \\{2,\\dots,N\\}$，在 $y_{j-1}$ 和 $y_{j}$ 之间分割成两个分段）。因此，先验为这 $N$ 个状态中的每一个分配了相等的概率质量 $1/N$。\n\n任务：\n1) 从高斯似然、高斯先验、观测独立性和贝叶斯定理的定义出发，通过解析地积分掉未知的均值参数 $\\mu_{s}$，推导出离散变点状态后验分布的闭式表达式。您的推导必须为每个候选变点状态生成一个对数后验表达式（不含加性归一化常数），该表达式是分段充分统计量的函数。除了基本的高斯恒等式和共轭性之外，不要假设任何“捷径”公式。\n\n2) 设计一个算法，该算法：\n- 枚举所有候选变点状态（包括“无变化”状态）。\n- 使用您推导的表达式计算每个状态的未归一化对数后验。\n- 使用数值稳定的 log-sum-exp 变换对这些值进行归一化，以获得精确的后验概率。\n- 提取在指定的查询日历年 $q \\in \\{y_{2},\\dots,y_{N}\\}$ 处开始变化的后验概率；如果 $q \\notin \\{y_{2},\\dots,y_{N}\\}$，根据模型设计，该概率应定义为 $0$。\n\n3) 将此算法实现为一个完整、可运行的程序，并使用以下测试套件。对于每个测试用例，计算在指定的查询日历年开始变化的后验概率。所有 DOY 值的单位都是天。最终答案是概率，必须表示为小数。\n\n测试套件（每个案例提供 $(\\text{年份}, \\text{DOY}, \\sigma, \\mu_{0}, v_{0}, q)$）：\n- 案例 A:\n  - 年份: (2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015)\n  - DOY: (121,118,119,122,120,123,117,119,106,104,107,103,108,105,104)\n  - 已知标准差: $\\sigma=3.0$ 天\n  - 先验均值: $\\mu_{0}=110.0$ 天\n  - 先验方差: $v_{0}=100.0$ 天²\n  - 查询年份: q=2009\n- 案例 B:\n  - 年份: (2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015)\n  - DOY: (111,112,113,110,114,112,111,113,112,110,113,112,111,114,112)\n  - 已知标准差: $\\sigma=2.5$ 天\n  - 先验均值: $\\mu_{0}=112.0$ 天\n  - 先验方差: $v_{0}=25.0$ 天²\n  - 查询年份: q=2010\n- 案例 C:\n  - 年份: (2012,2013,2014,2015,2016)\n  - DOY: (131,129,123,125,124)\n  - 已知标准差: $\\sigma=2.0$ 天\n  - 先验均值: $\\mu_{0}=127.0$ 天\n  - 先验方差: $v_{0}=25.0$ 天²\n  - 查询年份: q=2014\n- 案例 D:\n  - 年份: (2010,2011,2012,2013,2014)\n  - DOY: (100,101,102,99,103)\n  - 已知标准差: $\\sigma=2.0$ 天\n  - 先验均值: $\\mu_{0}=101.0$ 天\n  - 先验方差: $v_{0}=25.0$ 天²\n  - 查询年份: q=2010（边界情况；应产生零概率）\n- 案例 E:\n  - 年份: (2005,2006,2007,2008,2009,2010,2011,2012,2013,2014)\n  - DOY: (117,121,116,120,118,114,109,115,111,113)\n  - 已知标准差: $\\sigma=6.0$ 天\n  - 先验均值: $\\mu_{0}=115.0$ 天\n  - 先验方差: $v_{0}=100.0$ 天²\n  - 查询年份: q=2010\n\n实现和输出要求：\n- 您的程序必须实现上述推导和算法，为每个测试用例计算在指定的查询年份 $q$ 开始变化的后验概率。\n- 单位：输入的 DOY 值和超参数 $\\mu_{0}$、$\\sigma$ 的单位是天，$v_{0}$ 的单位是平方天，输出的概率是无单位的小数。\n- 最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个概率都四舍五入到恰好六位小数（例如，$\\left[\\text{0.123456},\\text{0.000000}\\right]$）。", "solution": "我们将 DOY 值建模为均值可能发生单次变化的高斯分布。设 $x_{1:N}=(x_{1},\\dots,x_{N})$ 表示与递增的日历年 $y_{1:N}=(y_{1},\\dots,y_{N})$ 对齐的观测年积日（DOY）测量值（单位为天）。已知的观测方差为 $\\sigma^{2}$（单位为平方天）。分段均值的先验为 $\\mu_{s}\\sim\\mathcal{N}(\\mu_{0},v_{0})$，其中 $\\mu_{0}$ 的单位为天，$v_{0}$ 的单位为平方天。变点状态 $\\tau$ 取 $N$ 个值之一：要么“无变化”（一个分段），要么“变化始于年份 $y_{j}$”（对于 $j\\in\\{2,\\dots,N\\}$，分段为索引 $1:(j-1)$ 和 $j:N$）。在这 $N$ 个状态上的先验是均匀的，每个状态的概率质量为 $1/N$。\n\n原理与推导：\n1) 分段的似然。对于包含 $m$ 个观测值的任意分段 $s$，以其均值 $\\mu_{s}$ 和已知方差 $\\sigma^{2}$ 为条件，似然因独立性而可分解为：\n$$\np(x_{1:m}\\mid \\mu_{s},\\sigma^{2})=(2\\pi\\sigma^{2})^{-m/2}\\exp\\left(-\\frac{1}{2\\sigma^{2}}\\sum_{i=1}^{m}(x_{i}-\\mu_{s})^{2}\\right).\n$$\n共轭先验为 $\\mu_{s}\\sim\\mathcal{N}(\\mu_{0},v_{0})$，其密度为\n$$\np(\\mu_{s})=(2\\pi v_{0})^{-1/2}\\exp\\left(-\\frac{(\\mu_{s}-\\mu_{0})^{2}}{2v_{0}}\\right).\n$$\n单个分段的边际似然通过积分掉 $\\mu_{s}$ 获得：\n$$\np(x_{1:m}\\mid \\mu_{0},v_{0},\\sigma^{2})=\\int p(x_{1:m}\\mid \\mu_{s},\\sigma^{2})\\,p(\\mu_{s})\\,d\\mu_{s}.\n$$\n在指数上配方可得到一个高斯积分。定义充分统计量\n$$\nS_{1}=\\sum_{i=1}^{m}x_{i},\\quad S_{2}=\\sum_{i=1}^{m}x_{i}^{2}.\n$$\n设\n$$\nA=\\frac{m}{\\sigma^{2}}+\\frac{1}{v_{0}},\\quad B=\\frac{S_{1}}{\\sigma^{2}}+\\frac{\\mu_{0}}{v_{0}},\\quad C=\\frac{S_{2}}{\\sigma^{2}}+\\frac{\\mu_{0}^{2}}{v_{0}}.\n$$\n使用标准高斯积分恒等式，可以得到闭式边际似然\n$$\np(x_{1:m}\\mid \\mu_{0},v_{0},\\sigma^{2})=(2\\pi)^{-m/2}\\,\\sigma^{-m}\\,v_{0}^{-1/2}\\,A^{-1/2}\\,\\exp\\left(-\\frac{1}{2}\\left(C-\\frac{B^{2}}{A}\\right)\\right).\n$$\n因此，对数边际似然为\n$$\n\\log p(x_{1:m})=-\\frac{m}{2}\\log(2\\pi)-m\\log\\sigma-\\frac{1}{2}\\log v_{0}-\\frac{1}{2}\\log A-\\frac{1}{2}\\left(C-\\frac{B^{2}}{A}\\right).\n$$\n\n2) 变点状态。对于一个始于年份 $y_{j}$（其中 $j\\in\\{2,\\dots,N\\}$）的候选变化，我们有两个独立的分段，因此边际似然可分解为：\n$$\np(x_{1:N}\\mid \\tau=y_{j})=p(x_{1:(j-1)}\\mid \\mu_{0},v_{0},\\sigma^{2})\\cdot p(x_{j:N}\\mid \\mu_{0},v_{0},\\sigma^{2}).\n$$\n对于“无变化”状态，只有一个分段：\n$$\np(x_{1:N}\\mid \\tau=\\text{no change})=p(x_{1:N}\\mid \\mu_{0},v_{0},\\sigma^{2}).\n$$\n\n3) 状态的后验。根据贝叶斯定理，在 $N$ 个状态上使用均匀先验，\n$$\np(\\tau\\mid x_{1:N})=\\frac{p(x_{1:N}\\mid \\tau)\\,p(\\tau)}{\\sum_{\\tau'}p(x_{1:N}\\mid \\tau')\\,p(\\tau')},\\quad p(\\tau)=\\frac{1}{N}.\n$$\n为保证数值稳定性，计算未归一化的对数后验\n$$\n\\ell(\\tau)=\\log p(x_{1:N}\\mid \\tau)+\\log p(\\tau),\n$$\n然后通过 log-sum-exp 变换进行归一化。设 $\\{\\ell_{k}\\}_{k=1}^{N}$ 为所有 $N$ 个状态的对数未归一化值，并设 $M=\\max_{k}\\ell_{k}$。则归一化后的后验概率为\n$$\nw_{k}=\\frac{\\exp(\\ell_{k}-M)}{\\sum_{j=1}^{N}\\exp(\\ell_{j}-M)}.\n$$\n\n4) 查询概率。在指定日历年 $q$ 开始变化的后验概率等于 $p(\\tau=q\\mid x_{1:N})$，如果 $q\\in\\{y_{2},\\dots,y_{N}\\}$。如果 $q\\notin\\{y_{2},\\dots,y_{N}\\}$（包括边界 $q=y_{1}$），我们根据模型的状态空间将该概率定义为零。\n\n算法设计：\n- 预计算累积充分统计量是可选的；因为每个候选变化最多涉及两个分段，直接进行分段求和就足够了。\n- 对于每个候选状态（包括“无变化”），使用上述分段公式计算相应的对数边际似然，并加上常数先验 $\\log(1/N)$。\n- 通过 log-sum-exp 归一化以获得状态的后验概率。\n- 如果查询年份 $q$ 有效，则将其映射到其状态索引并报告相应的后验概率质量；否则返回零。\n\n单位和输出：\n- 输入 $\\{x_{i}\\}$、$\\mu_{0}$ 和 $\\sigma$ 的单位是天；$v_{0}$ 的单位是平方天。得到的后验概率是无单位的小数。\n- 对于测试套件，计算查询年份的后验概率，并将每个概率四舍五入到恰好六位小数。将结果汇总成单行，格式为用方括号括起来的逗号分隔列表。\n\n此方法基于观测的独立性、已知方差的高斯似然、高斯先验（共轭性）和贝叶斯定理，从而对未知的分段均值进行精确的闭式边缘化，并实现了跨离散变点状态的数值稳定的归一化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef log_marginal_segment(x: np.ndarray, mu0: float, v0: float, sigma: float) - float:\n    \"\"\"\n    Compute log p(x | mu0, v0, sigma^2) for a single segment by integrating out the mean.\n    x: 1D numpy array of observations (in days)\n    mu0: prior mean (in days)\n    v0: prior variance (in days^2)\n    sigma: known standard deviation (in days)\n    \"\"\"\n    m = x.size\n    if m == 0:\n        # Empty segment should not occur in our construction; return -inf to avoid using it.\n        return -np.inf\n    sigma2 = sigma * sigma\n    S1 = float(np.sum(x))\n    S2 = float(np.sum(x * x))\n    A = m / sigma2 + 1.0 / v0\n    B = S1 / sigma2 + mu0 / v0\n    C = S2 / sigma2 + (mu0 * mu0) / v0\n    log_term = - (m / 2.0) * np.log(2.0 * np.pi) - m * np.log(sigma) - 0.5 * np.log(v0) - 0.5 * np.log(A)\n    quad_term = -0.5 * (C - (B * B) / A)\n    return log_term + quad_term\n\ndef posterior_probs_over_states(years, x, sigma, mu0, v0):\n    \"\"\"\n    Compute posterior probabilities over all change-point states:\n    - 'no_change' state\n    - change begins at each interior year years[j], j=1..N-1\n    Returns:\n      state_names: list of state identifiers (strings for 'no_change' and ints for years)\n      probs: numpy array of posterior probabilities aligned with state_names\n    \"\"\"\n    years = np.array(years, dtype=int)\n    x = np.array(x, dtype=float)\n    N = len(years)\n    assert len(x) == N, \"years and x must have the same length\"\n    # Build states: 0 - 'no_change', 1..N-1 - change begins at years[j]\n    state_names = ['no_change'] + [int(y) for y in years[1:]]\n    log_priors = np.full(N, -np.log(N))  # uniform over N states\n    log_liks = np.empty(N, dtype=float)\n\n    # No change: single segment\n    log_liks[0] = log_marginal_segment(x, mu0, v0, sigma)\n\n    # Each change candidate: split into two segments\n    for j in range(1, N):\n        x1 = x[:j]\n        x2 = x[j:]\n        log_lik = log_marginal_segment(x1, mu0, v0, sigma) + log_marginal_segment(x2, mu0, v0, sigma)\n        log_liks[j] = log_lik\n\n    # Unnormalized log posteriors\n    log_post = log_liks + log_priors\n    # Normalize with log-sum-exp\n    m = np.max(log_post)\n    weights = np.exp(log_post - m)\n    probs = weights / np.sum(weights)\n    return state_names, probs\n\ndef query_year_posterior(years, x, sigma, mu0, v0, q_year):\n    \"\"\"\n    Compute posterior probability that change begins at calendar year q_year.\n    Returns 0.0 if q_year is not a valid interior change candidate.\n    \"\"\"\n    state_names, probs = posterior_probs_over_states(years, x, sigma, mu0, v0)\n    # Valid change years are interior years: years[1:]\n    valid_years = set(state_names[1:])  # all ints\n    if q_year not in valid_years:\n        return 0.0\n    # Find index of q_year in state_names\n    idx = state_names.index(q_year)\n    return float(probs[idx])\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (years, DOY, sigma, mu0, v0, query_year)\n    test_cases = [\n        # Case A\n        (\n            [2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015],\n            [121,118,119,122,120,123,117,119,106,104,107,103,108,105,104],\n            3.0,\n            110.0,\n            100.0,\n            2009\n        ),\n        # Case B\n        (\n            [2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015],\n            [111,112,113,110,114,112,111,113,112,110,113,112,111,114,112],\n            2.5,\n            112.0,\n            25.0,\n            2010\n        ),\n        # Case C\n        (\n            [2012,2013,2014,2015,2016],\n            [131,129,123,125,124],\n            2.0,\n            127.0,\n            25.0,\n            2014\n        ),\n        # Case D (boundary query; should yield zero)\n        (\n            [2010,2011,2012,2013,2014],\n            [100,101,102,99,103],\n            2.0,\n            101.0,\n            25.0,\n            2010\n        ),\n        # Case E (larger variance, ambiguous)\n        (\n            [2005,2006,2007,2008,2009,2010,2011,2012,2013,2014],\n            [117,121,116,120,118,114,109,115,111,113],\n            6.0,\n            115.0,\n            100.0,\n            2010\n        ),\n    ]\n\n    results = []\n    for years, doy, sigma, mu0, v0, q in test_cases:\n        p = query_year_posterior(years, doy, sigma, mu0, v0, q)\n        # Round to 6 decimals in string formatting later\n        results.append(p)\n\n    # Final print statement in the exact required format with six decimal places.\n    formatted = \"[\" + \",\".join(f\"{r:.6f}\" for r in results) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2595654"}]}