{"hands_on_practices": [{"introduction": "模块化的核心思想是比较模块内和模块间性状的协变强度。协变率（Covariance Ratio, $CR$）是量化这一思想的直接且直观的指标。本练习旨在通过一个基础性的计算，将抽象的模块化概念具体化，让你亲手实践如何从给定的协方差矩阵中检验模块化假设。[@problem_id:2590340]", "problem": "在比较动物学和植物学中，模块性假说提出，同一形态或功能模块内的性状之间的协变性要强于它们与其他模块中性状的协变性。考虑一个在相关物种分支中测量的四性状数据集，其经验性状协方差矩阵概括如下：\n$$\nS \\;=\\; \\begin{pmatrix}\n1  & 0.6 & 0.1 & 0.0\\\\\n0.6 & 1 & 0.0 & 0.1\\\\\n0.1 & 0.0 & 1 & 0.7\\\\\n0.0 & 0.1 & 0.7 & 1\n\\end{pmatrix}.\n$$\n假设假定的模块划分为 $\\{1,2\\}$ 与 $\\{3,4\\}$。使用协方差和矩阵分块的核心定义，计算协方差比率 (CR)，其定义为平均模块间协方差与平均模块内协方差的比值，其中平均值仅对唯一的性状对进行计算（使用相应分块的上三角、非对角线元素；不包括方差）。\n\n然后，基于一个模块划分应产生小于 $1$ 的 $CR$ 值（即平均模块间协方差低于平均模块内协方差）的普遍预期，解释指定的划分是否对给定数据显示出模块性。最终答案仅报告 $CR$ 的数值；以精确形式表示，不要四舍五入或带单位。", "solution": "该问题要求计算协方差比率 ($CR$)，其定义为平均模块间协方差与平均模块内协方差的比值。提供的数据包括一个 $4 \\times 4$ 的性状协方差矩阵 $S$，以及一个将四个性状划分为两个模块 $M_1 = \\{1, 2\\}$ 和 $M_2 = \\{3, 4\\}$ 的假定模块划分。\n\n协方差矩阵 $S$ 如下所示：\n$$\nS \\;=\\; \\begin{pmatrix}\n1  & 0.6 & 0.1 & 0.0\\\\\n0.6 & 1 & 0.0 & 0.1\\\\\n0.1 & 0.0 & 1 & 0.7\\\\\n0.0 & 0.1 & 0.7 & 1\n\\end{pmatrix}.\n$$\n$S$ 的对角线元素是方差（在此案例中归一化为 $1$），非对角线元素 $S_{ij}$ 代表性状 $i$ 和性状 $j$ 之间的协方差。\n\n模块划分 $\\{1, 2\\}$ 与 $\\{3, 4\\}$ 允许我们将矩阵 $S$ 构造成对应于模块内和模块间协方差的分块：\n$$\nS = \\begin{pmatrix} S_{11} & S_{12} \\\\ S_{21} & S_{22} \\end{pmatrix}\n$$\n在这里，$S_{11}$ 是模块 $M_1$ 中性状间协方差的 $2 \\times 2$ 子矩阵，$S_{22}$ 是模块 $M_2$ 的 $2 \\times 2$ 子矩阵，而 $S_{12}$ 是模块 $M_1$ 和 $M_2$ 中性状间协方差的 $2 \\times 2$ 子矩阵。子矩阵 $S_{21}$ 是 $S_{12}$ 的转置。\n\n从 $S$ 中提取这些分块：\n模块 $M_1 = \\{1, 2\\}$ 的模块内协方差分块为：\n$$\nS_{11} = \\begin{pmatrix} 1 & 0.6 \\\\ 0.6 & 1 \\end{pmatrix}\n$$\n模块 $M_2 = \\{3, 4\\}$ 的模块内协方差分块为：\n$$\nS_{22} = \\begin{pmatrix} 1 & 0.7 \\\\ 0.7 & 1 \\end{pmatrix}\n$$\n模块间协方差分块为：\n$$\nS_{12} = \\begin{pmatrix} 0.1 & 0.0 \\\\ 0.0 & 0.1 \\end{pmatrix}\n$$\n\n协方差比率 ($CR$) 定义为：\n$$\nCR = \\frac{\\bar{c}_{_B}}{\\bar{c}_{_W}}\n$$\n其中 $\\bar{c}_{_W}$ 是平均模块内协方差，$\\bar{c}_{_B}$ 是平均模块间协方差。根据题目要求，平均值是针对唯一的、非对角线的性状对计算的。\n\n首先，我们计算平均模块内协方差 $\\bar{c}_{_W}$。这是分块 $S_{11}$ 和 $S_{22}$ 内唯一的非对角线协方差的平均值。题目指定使用上三角、非对角线元素来计算唯一的配对。\n从分块 $S_{11}$ 中，唯一的非对角线协方差是 $S_{12} = 0.6$。\n从分块 $S_{22}$ 中，唯一的非对角线协方差是 $S_{34} = 0.7$。\n总共有两个这样的模块内协方差。其平均值为：\n$$\n\\bar{c}_{_W} = \\frac{0.6 + 0.7}{2} = \\frac{1.3}{2} = 0.65\n$$\n\n其次，我们计算平均模块间协方差 $\\bar{c}_{_B}$。这是来自不同模块的性状之间所有协方差的平均值。这些是分块 $S_{12}$ 的所有元素，代表了来自 $M_1$ 的性状和来自 $M_2$ 的性状之间的协方差。\n$S_{12}$ 的元素为 $\\{0.1, 0.0, 0.0, 0.1\\}$。\n共有 $2 \\times 2 = 4$ 个模块间协方差。其平均值为：\n$$\n\\bar{c}_{_B} = \\frac{0.1 + 0.0 + 0.0 + 0.1}{4} = \\frac{0.2}{4} = 0.05\n$$\n\n最后，我们使用计算出的平均值来计算 $CR$：\n$$\nCR = \\frac{\\bar{c}_{_B}}{\\bar{c}_{_W}} = \\frac{0.05}{0.65}\n$$\n为了将此值表示为精确的分数形式，我们进行除法运算：\n$$\nCR = \\frac{\\frac{5}{100}}{\\frac{65}{100}} = \\frac{5}{65} = \\frac{1}{13}\n$$\n对于一个有效的模块划分，期望 $CR  1$。我们的结果 $CR = \\frac{1}{13}$ 远小于 $1$，这表明模块内的平均协方差是模块间平均协方差的 $13$ 倍。这为假定的模块结构提供了强有力的支持。然而，问题只要求提供 $CR$ 的数值。", "answer": "$$\n\\boxed{\\frac{1}{13}}\n$$", "id": "2590340"}, {"introduction": "计算出一个指标只是第一步；一个可靠的科学结论更依赖于方法论上无懈可击的研究流程。本练习将挑战你从研究设计者的角度进行批判性思考，识别出一个完整的形态计量学分析中的关键步骤与常见陷阱，从基于发育生物学知识提出假设，到正确控制体型和系统发育等混淆变量。[@problem_id:2590390]", "problem": "在脊椎动物颅骨和复叶的比较分析中，研究人员通常将形态模块推断为一组标志点，这些标志点在集合内部的协变性比集合之间的协变性更强。考虑一个数据集，其中包含 $n$ 个哺乳动物颅骨标本，由 $p$ 个同源的三维标志点捕获；以及 $m$ 个豆科植物复叶标本，由 $q$ 个同源的二维标志点捕获。对于颅骨，每个标志点可以映射到一个已命名的颅骨元件，该元件具有已知的胚胎细胞谱系（神经嵴与中胚层）及其骨缝环境；对于叶片，每个标志点可以映射到一个小叶级序和维管束迹，其从边缘分生组织起始的顺序是已知的。您的任务是，以一种在解剖学同源性和发育起源方面有原则的方式，将标志点分配到假设的模块中，并检验所假设的划分是否在“模块内形态整合强于模块间”的意义上表现出模块性。\n\n使用以下基本定义和事实：\n- 同源性是由于共同祖先而产生的相似性；同源标志点必须在不同标本中映射到相同的结构，跨分类群的比较必须尊重这种映射。\n- 形态模块是一组性状，在去除平凡相似性变换（平移、旋转、缩放）引起的变异后，其集合内部的协变性超过集合之间的协变性。\n- 形态整合可以从去除尺寸和位置影响后的形状变量的协方差结构中评估；其显著性可以通过一个随机化分配的零模型来评估，该模型与不存在特殊的集合内凝聚力的情况相一致。\n- 当标本代表多个物种时，系统发育相关性可以诱导协方差；比较分析在估计协方差时必须考虑共同的祖先。\n\n以下哪个选项描述了一种有原则、可检验的程序，用于将标志点分配到模块并评估模块性，该程序与这些基础相符，并且同时适用于脊椎动物颅骨和复叶？\n\nA. 通过将标志点映射到由同源性和发育起源支持的离散解剖元件（对于颅骨：骨骼及其已知的细胞谱系和骨缝边界；对于叶片：沿叶轴-叶片轴的小叶级序和维管束域），来先验地定义候选模块。执行广义普氏叠合以去除平移、旋转和尺度，然后在每个分支或物种内将形状对质心大小的对数进行回归，以去除异速生长。如果包含多个物种，则在经系统发育校正的残差上估计协方差。对于每个候选划分，组合模块内和模块间的协方差块，并计算一个对比模块内与模块间协变性的标量模块化统计量。通过置换检验评估显著性，这些置换应保持解剖单元的完整性（例如，不拆分来自同一块骨骼或小叶的所有标志点）和模块的大小，并在测试多个划分时对多重比较进行校正。选择在两个系统中都得到强有力支持的划分，并验证推断出的模块与已记录的发育边界相对应。\n\nB. 通过对普氏叠合后的标志点坐标应用 $k$-均值聚类，将标志点聚类成模块，其中 $k$ 的选择是通过最大化由第一主成分解释的总普氏方差来确定。忽略同源性和发育起源以避免偏见，如果同一聚类中标志点之间的平均欧几里得距离小于聚类之间的距离，则接受该聚类结果。\n\nC. 仅根据成体功能角色（对于颅骨：摄食与呼吸；对于叶片：光合作用与机械支持）分配模块，而不考虑发育起源。计算每个模块的平均形状，如果模块平均值之间的皮尔逊相关系数低于一个固定阈值，则宣布存在模块性，而不去除异速生长或考虑系统发育。\n\nD. 构建一个网络，其中节点是标志点，边权重是所有标本和物种在未经叠合的情况下汇集的原始标志点坐标的成对相关性。应用一个社群检测算法，如果网络模块度超过一个固定的截止值，则接受这些社群为模块，并省略任何发育或同源性信息以防止循环论证。\n\n选择唯一的最佳选项。", "solution": "该问题要求确定一个有原则且可检验的程序，用于将标志点分配给形态模块，并评估该模块性假设在两个不同的生物系统（脊椎动物颅骨和复叶）中的有效性。该程序的有效性必须根据比较生物学和几何形态计量学领域提供的一系列定义和事实来判断。\n\n**问题陈述验证**\n\n首先，我将验证问题陈述本身。\n\n**步骤1：提取已知条件**\n\n*   **数据集1：** $n$ 个哺乳动物颅骨标本， $p$ 个三维标志点。标志点元数据包括：关联的颅骨元件名称、胚胎细胞谱系（神经嵴与中胚层）和骨缝环境。\n*   **数据集2：** $m$ 个豆科植物复叶标本， $q$ 个二维标志点。标志点元数据包括：关联的小叶级序、维管束迹以及从边缘分生组织起始的已知顺序。\n*   **定义1（同源性）：** 由于共同祖先而产生的相似性；同源标志点在不同标本和分类群中被映射到相同的结构。\n*   **定义2（形态模块）：** 一组性状，在去除平移、旋转和缩放的变异后，其集合内部的协变性超过集合之间的协变性。\n*   **定义3（形态整合）：** 从去除尺寸和位置影响后的形状变量的协方差结构中评估。显著性通过零模型进行检验。\n*   **定义4（系统发育效应）：** 在多物种比较分析中，必须考虑由共同祖先引起的协方差。\n*   **目标：** 确定一个选项，该选项描述了一个有原则、可检验的模块分配和模块性评估程序，该程序与给定的基础相符，并且同时适用于颅骨和叶片数据集。\n\n**步骤2：使用提取的已知条件进行验证**\n\n该问题陈述在科学上基于几何形态计量学和演化发育生物学的既定原则。同源性、模块性、整合、普氏分析和系统发育比较方法等概念是现代定量形态学的基石。所使用的例子——脊椎动物颅骨和复叶——是研究这些现象的经典模型系统。问题提取得当，要求根据一套明确的标准来评估方法论选项。问题是客观的，并使用了精确、无歧义的术语。所提供的信息是自洽的，足以评估各个选项。问题不包含任何科学谬误、矛盾或不切实际的条件。它代表了现代演化生物学中一个标准的、有深度的人物。\n\n**步骤3：结论与行动**\n\n问题陈述有效。我将继续分析各个选项。\n\n**选项分析**\n\n正确的程序必须满足从问题陈述中得出的几个关键要求：\n1.  **假设驱动：** 它必须是“有原则的”，利用解剖学同源性和发育起源来定义关于模块划分的*先验*假设。\n2.  **正确的数据准备：** 它必须去除与形状无关的变异（平移、旋转、尺度），并考虑异速生长（与尺寸相关的形状变异）。这是几何形态计量学的范畴。\n3.  **系统发育控制：** 如果分析了多个物种，必须校正因共同祖先导致的统计非独立性。\n4.  **正确的模块性度量：** 它必须通过比较模块内部的协变性与模块之间的协变性来评估模块性。\n5.  **严格的显著性检验：** 它必须根据一个恰当构建的零模型（例如，通过置换检验）来评估观察到的模块性。\n\n现在我将根据这些标准评估每个选项。\n\n**选项A：**\n此选项提出了一个多步骤的程序。\n1.  **假设构建：** “通过将标志点映射到由同源性和发育起源支持的离散解剖元件...来先验地定义候选模块...” 这直接对应了问题所要求的“有原则”的方法，利用了所提供的生物学信息（骨骼身份、细胞谱系、小叶级序等）。\n2.  **数据准备：** “执行广义普氏叠合以去除平移、旋转和尺度，然后将形状对质心大小的对数进行回归以去除异速生长...” 这正确地实施了标准的几何形态计量学工作流程，以获得独立于尺寸和位置的形状变量。对质心大小进行对数转换是标准做法。\n3.  **系统发育控制：** “如果包含多个物种，则在经系统发育校正的残差上估计协方差。” 这正确地解决了考虑共同祖先的要求。\n4.  **模块性量化与检验：** “...计算一个对比模块内与模块间协变性的标量模块化统计量。通过置换检验评估显著性，这些置换应保持解剖单元的完整性...并对多重比较进行校正...” 这正确地指出了模块性的核心比较，使用了复杂且适当的置换方案进行显著性检验（避免了破坏具有生物学意义的单元），并包含了检验多个假设时必要的统计校正。\n该程序是全面的、方法论上健全的，并且直接遵循了问题陈述中列出的所有原则和定义。它适用于二维和三维标志点数据。\n\n**对A的判定：** **正确**。\n\n**选项B：**\n此选项建议使用$k$-均值聚类。\n1.  **方法：** “$k$-均值”聚类是根据标志点的平均空间邻近度进行分组，而不是根据它们的协变性。模块性是协方差结构的属性，而不是平均形状中的空间邻近度的属性。这是一个根本性的概念错误。\n2.  **$k$的选择标准：** 选择聚类数 $k$ 的标准——“最大化由第一主成分解释的总普氏方差”——是无稽之谈。聚类数 $k$ 与单个主成分所解释的方差没有直接、有意义的关系。\n3.  **生物信息的使用：** 它明确指出要“忽略同源性和发育起源以避免偏见”。这直接违背了问题要求的基于这些信息进行“有原则的”分析。这不是避免偏见，而是抛弃了假设检验的整个理论框架。\n4.  **度量：** “...同一聚类中标志点之间的平均欧几里得距离小于聚类之间的距离”只是对$k$-均值聚类功能的重述；它不是对协变性意义上的模块性的检验。\n\n**对B的判定：** **不正确**。该方法不适用于检验基于协变性的模块性，并且它抛弃了必需的生物学信息。\n\n**选项C：**\n此选项关注功能角色。\n1.  **假设构建：** 虽然功能可以作为假设的有效基础，但此选项声明要“不考虑发育起源”来分配模块，这与问题设定的一个关键部分相矛盾。\n2.  **方法论：** 它建议“计算每个模块的平均形状”，然后对这些平均值进行相关性分析。模块性是由单个标志点*在模块内部*和*模块之间*的协变性定义的，而不是由模块平均值的相关性定义的。这是一种严重的过度简化，丢失了关键信息。\n3.  **混杂因素：** 它明确指出“...不去除异速生长或考虑系统发育。” 这违反了对形状进行有效比较分析的两个关键且明确指出的要求。其结果将是人为的、无法解释的。\n\n**对C的判定：** **不正确**。该方法论过于简单且存在缺陷，并且未能控制主要的混杂变量。\n\n**选项D：**\n此选项建议进行网络分析。\n1.  **数据：** 整个分析基于“原始标志点坐标的成对相关性”。这是一个致命的缺陷。原始坐标包含了由于标本尺寸、位置和方向引起的变异。这些坐标的相关性将主要由这些无关紧要的因素主导，而不是由生物学形状变异主导。这违反了形态模块的明确定义，该定义要求去除这些影响。“未经叠合”一词证实了这一根本性错误。\n2.  **生物信息的使用：** 它建议“省略任何发育或同源性信息以防止循环论证”。这反映了对假设检验科学方法的误解。基于先验知识（发育生物学）构建假设，并用不同类型的数据（协变模式）对其进行检验，这不是循环论证；这是标准的假设-演绎过程。这也与问题对“有原则”方法的要求相矛盾。\n\n**对D的判定：** **不正确**。该程序基于存在根本性缺陷的输入数据（原始坐标），使得任何后续分析都无效。\n\n**结论**\n只有选项A描述了一个科学上合理、统计上严谨、并且与问题陈述中提供的所有原则和定义都一致的程序。它正确地概述了用于形态模块性假设驱动检验的现代工作流程，从有原则的假设构建到正确的数据处理和稳健的统计评估。", "answer": "$$\\boxed{A}$$", "id": "2590390"}, {"introduction": "当我们计算出一个模块化指标后，一个至关重要的问题是：这个结果具有生物学意义，还是仅仅是随机产生的？置换检验（Permutation Test）为回答该问题提供了一个强大的非参数方法。本编程练习旨在将理论与实践相结合，让你亲手实现一个置换检验，从而具体理解如何通过构建零分布来评估模块化分区的统计显著性。[@problem_id:2590370]", "problem": "给定一个在多个样本上测量的数量性状矩阵，以及一个预先指定的性状模块划分。科学目标是检验观察到的划分是否反映了模块化组织，即模块内部性状间的协变异是否强于模块间的协变异。您的推理和实现应基于协方差的核心定义以及原假设下的可交换性。\n\n设 $X \\in \\mathbb{R}^{n \\times p}$ 是一个数据矩阵，包含 $n$ 个独立样本（行）和 $p$ 个性状（列）。设 $S \\in \\mathbb{R}^{p \\times p}$ 表示 $X$ 列的样本协方差矩阵，其元素 $s_{ij}$ 由通常的无偏协方差估计量定义。设预先指定的模块划分为 $\\mathcal{M} = \\{M_1, M_2, \\ldots, M_K\\}$，其中 $M_k \\subset \\{1,2,\\ldots,p\\}$ 是不相交的非空集合，其并集为 $\\{1,2,\\ldots,p\\}$。\n\n定义一个标量模块化指数，作为总的模块间协方差与总的模块内协方差之比，通过对 $S$ 的非对角协方差求和计算如下。设：\n*   $C_{within}$ 为模块内协方差总和，即所有属于同一模块的性状对 $(i, j)$ (其中 $ij$) 的协方差 $s_{ij}$ 之和。\n*   $C_{between}$ 为模块间协方差总和，即所有属于不同模块的性状对 $(i, j)$ (其中 $ij$) 的协方差 $s_{ij}$ 之和。\n模块化指数 $R$ 定义为 $R = C_{between} / C_{within}$。\n\n您的任务是实现一个置换检验程序来计算单尾 $p$ 值，以检验观察到的模块化指数 $\\mathrm{R}_{\\mathrm{obs}}$ 是否显著地小于在原假设（即性状分配到模块是随机的）下预期的值。在原假设下，性状标签相对于模块结构是可交换的。置换过程应通过随机置换性状标签并保持原始模块大小不变来生成零分布。\n\n根据以下三个测试用例运行您的程序，并报告每个用例的 $\\mathrm{R}_{\\mathrm{obs}}$ 和 $p_{\\mathrm{perm}}$，四舍五入到6位小数。\n\n**用例 A：**\n*   $n=200$, $p=6$, $\\mathcal{M} = \\{\\{0,1,2\\}, \\{3,4,5\\}\\}$\n*   真实协方差矩阵 $\\Sigma$ 结构：对角线为1，模块内协方差为0.8，模块间协方差为0.05。\n*   $s_{\\mathrm{data}}=42$, $s_{\\mathrm{perm}}=4242$, $B=999$ 次置换。\n\n**用例 B：**\n*   $n=300$, $p=8$, $\\mathcal{M} = \\{\\{0,1,2,3\\}, \\{4,5,6,7\\}\\}$\n*   真实协方差矩阵 $\\Sigma$ 结构：对角线为1，模块内协方差为0.5，模块间协方差为0.5（即无模块化结构）。\n*   $s_{\\mathrm{data}}=7$, $s_{\\mathrm{perm}}=7007$, $B=999$ 次置换。\n\n**用例 C：**\n*   $n=180$, $p=6$, $\\mathcal{M} = \\{\\{0,1\\}, \\{2,3\\}, \\{4,5\\}\\}$\n*   真实协方差矩阵 $\\Sigma$ 结构：对角线为1，模块内协方差为0.7，模块间协方差为0.01。\n*   $s_{\\mathrm{data}}=99$, $s_{\\mathrm{perm}}=9090$, $B=999$ 次置换。\n\n最终答案应为一个包含6个浮点数的列表，格式为 `[R_A, p_A, R_B, p_B, R_C, p_C]`。", "solution": "问题陈述已经过严格审查，并被确定为有效。它在科学上基于统计假设检验，问题提法得当，提供了所有必要信息，并以客观、正式的语言表达。不存在矛盾、歧义或事实不准确之处。该问题是计算统计学应用于生物学问题的一个标准（尽管不简单）的练习。因此，我们可以继续进行解答。\n\n目标是执行置换检验，以评估数量性状模块划分的统计显著性。核心思想是将观察到的模块化指数 $\\mathrm{R}_{\\mathrm{obs}}$ 与一个零分布进行比较，该零分布是通过随机置换性状到模块的分配而生成的。指数值较小表示模块化程度较强，意味着模块内的协方差远大于模块间的协方差。\n\n设数据矩阵为 $X \\in \\mathbb{R}^{n \\times p}$，包含 $n$ 个样本和 $p$ 个性状。计算样本协方差矩阵 $S \\in \\mathbb{R}^{p \\times p}$，其中元素 $s_{ij}$ 是性状 $i$ 和性状 $j$ 之间的无偏样本协方差：\n$$ s_{ij} = \\frac{1}{n-1} \\sum_{k=1}^{n} (x_{ki} - \\bar{x}_i)(x_{kj} - \\bar{x}_j) $$\n其中 $\\bar{x}_i$ 是第 $i$ 个性状的样本均值。\n\n$p$ 个性状划分为 $K$ 个模块的分区表示为 $\\mathcal{M} = \\{M_1, M_2, \\ldots, M_K\\}$，其中每个 $M_k$ 是一组性状指数，$\\bigcup_{k=1}^K M_k = \\{1, 2, \\ldots, p\\}$，且当 $k \\ne k'$ 时，$M_k \\cap M_{k'} = \\emptyset$。为方便计算，我们可以定义一个映射 $\\mathrm{mod}(i)$，它返回包含性状 $i$ 的模块 $M_k$ 的索引 $k$。\n\n总的模块内非对角协方差 $C_{within}$ 是所有属于同一模块的不同性状对的协方差之和：\n$$ C_{within} = \\sum_{1 \\le i  j \\le p, \\atop \\mathrm{mod}(i) = \\mathrm{mod}(j)} s_{ij} $$\n总的模块间协方差 $C_{between}$ 是所有属于不同模块的性状对的协方差之和：\n$$ C_{between} = \\sum_{1 \\le i  j \\le p, \\atop \\mathrm{mod}(i) \\ne \\mathrm{mod}(j)} s_{ij} $$\n模块化指数 $\\mathrm{R}$ 是这两个总和的比值：\n$$ \\mathrm{R} = \\frac{C_{between}}{C_{within}} $$\n假设协方差主要为正，较小的 $\\mathrm{R}$ 值表明更强的模块化。我们为观察到的划分 $\\mathcal{M}$ 计算此值，得到 $\\mathrm{R}_{\\mathrm{obs}}$。\n\n原假设 $H_0$ 假定性状身份与模块结构之间没有特殊对应关系。也就是说，标签 $\\{1, \\ldots, p\\}$ 相对于划分结构是可交换的。我们使用置换检验来检验此假设。该过程需要生成大量（$B$ 个）置换后的划分。每个置换划分是通过随机置换所有性状指数的集合 $\\{1, \\ldots, p\\}$，然后在保持原始模块大小 $\\{|M_1|, \\ldots, |M_K|\\}$ 不变的情况下将它们重新分配到模块中来创建的。\n\n设 $\\pi$ 是 $\\{1, \\ldots, p\\}$ 的一个置换。可以通过创建新模块 $M'_k = \\{\\pi(i) | i \\in M_k\\}$ 来构建一个置换后的分配。对于 $B$ 个这样的随机置换中的每一个，我们使用原始协方差矩阵 $S$ 但采用置换后的划分来计算模块化指数 $\\mathrm{R}_b$。这样就生成了 $\\mathrm{R}$ 值的零分布。\n\n然后，通过将 $\\mathrm{R}_{\\mathrm{obs}}$ 与置换值的集合 $\\{\\mathrm{R}_b\\}_{b=1}^B$ 进行比较，计算用于检测模块化（即检验 $\\mathrm{R}_{\\mathrm{obs}}$ 是否显著小）的单尾 $p$ 值。公式为：\n$$ p_{\\mathrm{perm}} = \\frac{1 + |\\{b \\in \\{1, \\ldots, B\\} : \\mathrm{R}_b \\le \\mathrm{R}_{\\mathrm{obs}}\\}|}{1 + B} $$\n在分子和分母中都包含 1，是为了将观测值本身计为零分布的一个元素。\n\n对于每个指定的测试用例，实施以下步骤：\n1. 根据问题规则构建真实的协方差矩阵 $\\Sigma \\in \\mathbb{R}^{p \\times p}$。\n2. 使用指定的数据生成种子 $s_{\\mathrm{data}}$，从多元正态分布 $\\mathcal{N}(\\mathbf{0}, \\Sigma)$ 中抽取 $n$ 个独立样本，生成数据矩阵 $X \\in \\mathbb{R}^{n \\times p}$。\n3. 从 $X$ 计算无偏样本协方差矩阵 $S$。\n4. 使用 $S$ 和给定的划分 $\\mathcal{M}$ 计算观察到的模块化指数 $\\mathrm{R}_{\\mathrm{obs}}$。\n5. 使用置换种子 $s_{\\mathrm{perm}}$ 初始化伪随机数生成器。\n6. 执行 $B$ 次置换。在每次迭代中，生成一个置换后的划分，计算相应的指数 $\\mathrm{R}_b$，并将其与 $\\mathrm{R}_{\\mathrm{obs}}$ 比较。\n7. 根据小于或等于 $\\mathrm{R}_{\\mathrm{obs}}$ 的置换指数计数，计算最终的 $p$ 值 $p_{\\mathrm{perm}}$。\n8. 将得到的值 $\\mathrm{R}_{\\mathrm{obs}}$ 和 $p_{\\mathrm{perm}}$ 四舍五入到 6 位小数。\n\n此过程应用于三个测试用例中的每一个，并将结果汇总为所需的最终格式。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n\n    def construct_sigma(p, partition, within_cov, between_cov):\n        \"\"\"Constructs the true covariance matrix Sigma.\"\"\"\n        sigma = np.full((p, p), between_cov)\n        for module in partition:\n            # Create index arrays for advanced indexing\n            indices = np.ix_(module, module)\n            sigma[indices] = within_cov\n        np.fill_diagonal(sigma, 1.0)\n        return sigma\n\n    def calculate_modularity_index(S, p, module_map):\n        \"\"\"Calculates the modularity index R.\"\"\"\n        within_sum = 0.0\n        between_sum = 0.0\n        for i in range(p):\n            for j in range(i + 1, p):\n                if module_map[i] == module_map[j]:\n                    within_sum += S[i, j]\n                else:\n                    between_sum += S[i, j]\n        \n        if within_sum == 0:\n            # Handle the case of zero within-module covariance to avoid division by zero.\n            # This is unlikely given the problem setup but is good practice.\n            return np.inf if between_sum > 0 else 0.0\n\n        return between_sum / within_sum\n\n    def run_permutation_test(n, p, partition, sigma_params, s_data, s_perm, B):\n        \"\"\"\n        Runs the full analysis for a single test case.\n        \"\"\"\n        # 1. Construct Sigma and generate data\n        rng_data = np.random.default_rng(s_data)\n        sigma = construct_sigma(p, partition, sigma_params['within'], sigma_params['between'])\n        mean_vec = np.zeros(p)\n        X = rng_data.multivariate_normal(mean=mean_vec, cov=sigma, size=n)\n\n        # 2. Compute the sample covariance matrix S\n        # np.cov with rowvar=False and default ddof=1 computes the unbiased estimator\n        S = np.cov(X, rowvar=False)\n\n        # 3. Compute the observed modularity index\n        # Create a map from trait index to module index for efficient lookup\n        module_map_obs = np.zeros(p, dtype=int)\n        for module_idx, module in enumerate(partition):\n            for trait_idx in module:\n                module_map_obs[trait_idx] = module_idx\n        \n        r_obs = calculate_modularity_index(S, p, module_map_obs)\n        \n        # 4. Perform the permutation test\n        rng_perm = np.random.default_rng(s_perm)\n        trait_indices = np.arange(p)\n        module_sizes = [len(m) for m in partition]\n        module_starts = np.concatenate(([0], np.cumsum(module_sizes[:-1])))\n\n        count_le = 0\n        for _ in range(B):\n            permuted_indices = rng_perm.permutation(trait_indices)\n            \n            # Create the permuted module map\n            module_map_perm = np.zeros(p, dtype=int)\n            for module_idx, start_pos in enumerate(module_starts):\n                 size = module_sizes[module_idx]\n                 permuted_module_traits = permuted_indices[start_pos : start_pos + size]\n                 for trait_idx in permuted_module_traits:\n                     module_map_perm[trait_idx] = module_idx\n            \n            r_perm = calculate_modularity_index(S, p, module_map_perm)\n            \n            if r_perm = r_obs:\n                count_le += 1\n        \n        # 5. Calculate the p-value\n        p_perm = (1 + count_le) / (1 + B)\n\n        return round(r_obs, 6), round(p_perm, 6)\n    \n    # Define test cases from the problem statement\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"n\": 200, \"p\": 6, \"B\": 999,\n            \"partition\": [[0, 1, 2], [3, 4, 5]],\n            \"sigma_params\": {\"within\": 0.8, \"between\": 0.05},\n            \"s_data\": 42, \"s_perm\": 4242\n        },\n        {\n            \"name\": \"Case B\",\n            \"n\": 300, \"p\": 8, \"B\": 999,\n            \"partition\": [[0, 1, 2, 3], [4, 5, 6, 7]],\n            \"sigma_params\": {\"within\": 0.5, \"between\": 0.5},\n            \"s_data\": 7, \"s_perm\": 7007\n        },\n        {\n            \"name\": \"Case C\",\n            \"n\": 180, \"p\": 6, \"B\": 999,\n            \"partition\": [[0, 1], [2, 3], [4, 5]],\n            \"sigma_params\": {\"within\": 0.7, \"between\": 0.01},\n            \"s_data\": 99, \"s_perm\": 9090\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        r_obs, p_perm = run_permutation_test(\n            n=case[\"n\"],\n            p=case[\"p\"],\n            partition=case[\"partition\"],\n            sigma_params=case[\"sigma_params\"],\n            s_data=case[\"s_data\"],\n            s_perm=case[\"s_perm\"],\n            B=case[\"B\"]\n        )\n        all_results.extend([r_obs, p_perm])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n\n```", "id": "2590370"}]}