{"hands_on_practices": [{"introduction": "本练习旨在探讨MADS-box基因功能的生物化学基础。蛋白质复合体，特别是被称为“花发育四聚体”的四聚体，其形成对于DNA结合和基因调控至关重要。通过本练习，您将亲身实践如何应用质量作用定律来计算这些复合体的平衡浓度，从而将总蛋白水平与活性调控单位的形成联系起来[@problem_id:2588110]。", "problem": "在花发育模型中，几种MADS Intervening Keratin-like C-terminal (MIKC) 类型的 MADS-box 蛋白形成DNA结合二聚体和更高阶的四聚体，这些复合体在所谓的“花四重奏”组装中调节靶基因。考虑一个处于平衡状态的体外寡聚化系统，该系统包含一种 MIKC 类型的 MADS 蛋白，它可以以单体、二聚体和四聚体形式存在。令 $M$ 表示单体，$D$ 表示由 $M + M \\rightleftharpoons D$ 形成的二聚体，而 $T$ 表示由 $D + D \\rightleftharpoons T$ 形成的四聚体。解离常数由质量作用定律定义为 $K_d^{\\mathrm{dimer}} = \\frac{[M]^2}{[D]}$ 和 $K_d^{\\mathrm{tetramer}} = \\frac{[D]^2}{[T]}$。总蛋白质浓度（以单体等效物计算）守恒，为 $[P]_{\\mathrm{tot}} = [M] + 2[D] + 4[T]$。\n\n仅使用质量作用定律和质量守恒定律，并假设理想溶液行为和平衡状态，计算四聚体中总单体等效物的分数，定义为 $f_T = \\frac{4[T]}{[P]_{\\mathrm{tot}}}$。其中 $[P]_{\\mathrm{tot}} = 100\\,\\mathrm{nM}$，$K_d^{\\mathrm{dimer}} = 10\\,\\mathrm{nM}$，以及 $K_d^{\\mathrm{tetramer}} = 50\\,\\mathrm{nM}$。将您的答案表示为小数（无单位），并四舍五入至四位有效数字。", "solution": "所述问题具有科学依据，表述清晰且客观。这是一个基于质量作用定律和质量守恒（化学和物理学的基本原理）的标准平衡问题。参数定义明确，方程组可解。因此，我将开始解答。\n\n问题要求计算处于四聚体状态的总单体等效物的分数，$f_T$。该系统涉及处于平衡状态的单体（$M$）、二聚体（$D$）和四聚体（$T$）。\n\n控制方程如下：\n二聚体形成的解离常数：\n$$K_d^{\\mathrm{dimer}} = \\frac{[M]^2}{[D]}$$\n四聚体形成的解离常数：\n$$K_d^{\\mathrm{tetramer}} = \\frac{[D]^2}{[T]}$$\n总蛋白质守恒（以单体等效物计算）：\n$$[P]_{\\mathrm{tot}} = [M] + 2[D] + 4[T]$$\n\n我们被要求计算 $f_T = \\frac{4[T]}{[P]_{\\mathrm{tot}}}$，给定以下值：\n$[P]_{\\mathrm{tot}} = 100\\,\\mathrm{nM}$\n$K_d^{\\mathrm{dimer}} = 10\\,\\mathrm{nM}$\n$K_d^{\\mathrm{tetramer}} = 50\\,\\mathrm{nM}$\n\n策略是用单个变量（我们选择单体浓度 $[M]$）来表示所有物种的浓度。\n\n根据 $K_d^{\\mathrm{dimer}}$ 的定义，我们将二聚体浓度 $[D]$ 表示为 $[M]$ 的函数：\n$$[D] = \\frac{[M]^2}{K_d^{\\mathrm{dimer}}}$$\n\n根据 $K_d^{\\mathrm{tetramer}}$ 的定义，我们将四聚体浓度 $[T]$ 表示为 $[D]$ 的函数：\n$$[T] = \\frac{[D]^2}{K_d^{\\mathrm{tetramer}}}$$\n\n我们可以将 $[D]$ 的表达式代入 $[T]$ 的表达式，从而将 $[T]$ 直接与 $[M]$ 关联起来：\n$$[T] = \\frac{1}{K_d^{\\mathrm{tetramer}}} \\left( \\frac{[M]^2}{K_d^{\\mathrm{dimer}}} \\right)^2 = \\frac{[M]^4}{(K_d^{\\mathrm{dimer}})^2 K_d^{\\mathrm{tetramer}}}$$\n\n现在，我们将 $[D]$ 和 $[T]$ 的表达式代入质量守恒方程：\n$$[P]_{\\mathrm{tot}} = [M] + 2 \\left( \\frac{[M]^2}{K_d^{\\mathrm{dimer}}} \\right) + 4 \\left( \\frac{[M]^4}{(K_d^{\\mathrm{dimer}})^2 K_d^{\\mathrm{tetramer}}} \\right)$$\n\n这个方程是关于变量 $[M]$ 的四次多项式。我们可以将其写成标准形式：\n$$\\left( \\frac{4}{(K_d^{\\mathrm{dimer}})^2 K_d^{\\mathrm{tetramer}}} \\right) [M]^4 + \\left( \\frac{2}{K_d^{\\mathrm{dimer}}} \\right) [M]^2 + [M] - [P]_{\\mathrm{tot}} = 0$$\n\n现在，我们将给定的数值代入系数中。所有浓度单位均为 $nM$，因此在计算中可以省略它们。\n当 $K_d^{\\mathrm{dimer}} = 10$, $K_d^{\\mathrm{tetramer}} = 50$, 且 $[P]_{\\mathrm{tot}} = 100$ 时，方程变为：\n$$\\left( \\frac{4}{(10)^2 \\cdot 50} \\right) [M]^4 + \\left( \\frac{2}{10} \\right) [M]^2 + [M] - 100 = 0$$\n$$\\frac{4}{5000} [M]^4 + \\frac{2}{10} [M]^2 + [M] - 100 = 0$$\n$$0.0008 [M]^4 + 0.2 [M]^2 + [M] - 100 = 0$$\n\n这个关于 $[M]$ 的多项式方程没有简单的解析解，必须通过数值方法求解。我们寻找一个具有物理意义的根，它必须是正实数。求解该方程可得到 $[M]$ 的唯一正实根：\n$$[M] \\approx 14.971844\\,\\mathrm{nM}$$\n\n使用这个 $[M]$ 值，我们可以计算其他物种的浓度：\n$$[D] = \\frac{[M]^2}{K_d^{\\mathrm{dimer}}} \\approx \\frac{(14.971844)^2}{10} \\approx 22.41561\\,\\mathrm{nM}$$\n$$[T] = \\frac{[D]^2}{K_d^{\\mathrm{tetramer}}} \\approx \\frac{(22.41561)^2}{50} \\approx 10.04919\\,\\mathrm{nM}$$\n\n作为计算的验证，我们检查质量守恒定律是否满足：\n$$[M] + 2[D] + 4[T] \\approx 14.971844 + 2(22.41561) + 4(10.04919)$$\n$$\\approx 14.971844 + 44.83122 + 40.19676 = 99.999824\\,\\mathrm{nM}$$\n这个总和与指定的总浓度 $100\\,\\mathrm{nM}$ 足够接近，证实了所计算浓度的正确性。\n\n最后一步是计算分数 $f_T$：\n$$f_T = \\frac{4[T]}{[P]_{\\mathrm{tot}}} \\approx \\frac{4 \\cdot 10.04919}{100} = \\frac{40.19676}{100} = 0.4019676$$\n\n问题要求答案四舍五入至四位有效数字。第五位有效数字是 $6$，所以我们将第四位数字向上取整。\n$$f_T \\approx 0.4020$$", "answer": "$$\n\\boxed{0.4020}\n$$", "id": "2588110"}, {"introduction": "在理解了蛋白质复合体的基础上，我们现在将视角提升到基因调控网络的层面。本练习采用布尔网络模型——一种系统生物学中的强大抽象工具——来模拟不同MADS-box基因类别之间的相互作用如何动态地在花的不同轮中建立起独特的器官特征。通过实现该模型，您将探索简单的局部基因互动规则如何生成稳健的全局模式，以及改变这些互动的时序将如何导致发育边界的移动[@problem_id:2588089]。", "problem": "你需要使用ABCE及D类MADS-box基因框架，形式化一个用于确定花器官特征的最小布尔基因调控网络，并模拟B类基因激活时间改变对器官特征边界的影响。该模型必须以纯逻辑和数学术语来陈述和执行。该网络由四个同心花轮组成，从最外层到最内层索引为 $i \\in \\{1,2,3,4\\}$，在离散时间步 $t = 0,1,2,\\dots$ 中演化。目标是在B类基因激活的几种时间扰动下，计算指定读出时间 $T$ 时各个花轮的器官特征。\n\n基本原理和假设：\n- 分子生物学的中心法则（DNA到RNA到蛋白质）支持使用稳定的基因表达状态作为调控决策的代理。基因调控网络的最小布尔近似将基因状态设置为激活（$1$）或非激活（$0$），并使用同步更新，这在系统生物学中是经过充分检验的、用于模拟基因回路定性动态的抽象方法。\n- 用于确定花器官特征的MADS-box基因类别被表示为每个花轮的布尔变量：$A_i(t)$、 $B_i(t)$、 $C_i(t)$、 $D_i(t)$、 $E_i(t) \\in \\{0,1\\}$。E类基因（SEPALLATA）被视为组成型表达（对所有 $i,t$，$E_i(t)=1$）。A类和C类基因相互抑制，这与经典的ABCE模型一致。B类基因与A类或C类基因共表达时，分别指定花瓣和雄蕊的特征。D类基因在心皮内部指定胚珠特征，并在最内层区域依赖于C类基因。这些假设将植物发育遗传学中经过充分检验的事实编码为模型的基础。\n\n空间预定模式和初始条件：\n- 预定模式函数确定了易受A类和C类基因活动影响的区域：当 $i \\in \\{1,2\\}$ 时 $A^{\\mathrm{pre}}_i = 1$，否则为 $0$；当 $i \\in \\{3,4\\}$ 时 $C^{\\mathrm{pre}}_i = 1$，否则为 $0$。这些代表了外部区域与内部区域。\n- $t=0$ 时的初始状态为，对所有 $i$，$A_i(0)=B_i(0)=C_i(0)=D_i(0)=0$；对所有 $i,t$，$E_i(t)=1$。\n\n更新规则（同步布尔动态）：\n- A类和C类基因在各自预定模式下的相互拮抗作用：\n  $$A_i(t+1) = A^{\\mathrm{pre}}_i \\land \\neg C_i(t), \\quad C_i(t+1) = C^{\\mathrm{pre}}_i \\land \\neg A_i(t)。$$\n- 定义一个“边界”谓词，用于根据最近邻检测A类和C类基因区域之间的位置。设 $\\mathrm{nbr}_L(i)=i-1$ 和 $\\mathrm{nbr}_R(i)=i+1$（如果在范围内），否则不存在的邻居被视为 $A=C=0$。时间 $t$ 的边界条件是：\n  $$\\mathrm{BOUNDARY}_i(t) \\equiv \\big(A_{\\mathrm{nbr}_L(i)}(t) \\land C_{\\mathrm{nbr}_R(i)}(t)\\big) \\lor \\big(C_{\\mathrm{nbr}_L(i)}(t) \\land A_{\\mathrm{nbr}_R(i)}(t)\\big)。$$\n- B类基因的激活具有花轮特异性的起始时间 $\\tau^{(B)}_2$ 和 $\\tau^{(B)}_3$，并且只在边界位置发生：\n  $$B_i(t+1) = B_i(t) \\lor \\big( \\mathrm{BOUNDARY}_i(t) \\land [\\, t \\ge \\tau^{(B)}_i \\,] \\big), \\quad \\text{其中 } \\tau^{(B)}_1=\\tau^{(B)}_4=+\\infty。$$\n- D类基因的激活依赖于最内层花轮中的C类基因，并具有固定的起始时间 $\\tau^{(D)}$：\n  $$D_i(t+1) = \\begin{cases}\n  1  \\text{若 } i=4,\\ t \\ge \\tau^{(D)},\\ \\text{且 } C_4(t)=1,\\\\\n  0  \\text{否则}。\n  \\end{cases}$$\n- E类基因为组成型表达：对所有 $i,t$，$E_i(t)=1$。\n\n时间 $T$ 的器官特征读出：\n- 使用以下规则，将时间 $T$ 时的基因组合映射为每个花轮 $i \\in \\{1,2,3,4\\}$ 的整数器官特征编码：\n  - 萼片：$A_i(T)=1,\\ B_i(T)=0,\\ C_i(T)=0 \\Rightarrow 1$。\n  - 花瓣：$A_i(T)=1,\\ B_i(T)=1,\\ C_i(T)=0 \\Rightarrow 2$。\n  - 雄蕊：$A_i(T)=0,\\ B_i(T)=1,\\ C_i(T)=1 \\Rightarrow 3$。\n  - 心皮：$A_i(T)=0,\\ B_i(T)=0,\\ C_i(T)=1 \\Rightarrow 4$。\n  - 任何其他组合（包括全零）被视为不确定，编码为 $0$。\n- D类基因在这里不改变花轮层面的器官编码；它在内部将心皮组织细化为胚珠特征，这与D类基因的功能一致，但四花轮的离散化将包含它的器官报告为编码 $4$。\n\n扰动和时间参数：\n- 所有模拟均使用 $\\tau^{(D)}=1$。\n- 测试套件改变 $(\\tau^{(B)}_2,\\tau^{(B)}_3,T)$，包含以下四种情况：\n  - 情况A（基线“理想路径”）：$(0,0,2)$。\n  - 情况B（B类基因全局延迟激活）：$(3,3,2)$。\n  - 情况C（B类基因在内部边界不对称延迟激活）：$(0,3,2)$。\n  - 情况D（在B类基因边界巩固前提前读出）：$(0,0,1)$。\n\n任务：\n- 实现上述从 $t=0$ 开始到（并包括）时间 $T$ 读出的同步更新布尔网络。\n- 对每个测试用例，计算一个包含四个整数的列表 $[I_1,I_2,I_3,I_4]$，给出从最外层（$i=1$）到最内层（$i=4$）在时间 $T$ 的器官特征编码。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身也是一个列表，例如：$[[a_1,a_2,a_3,a_4],[b_1,b_2,b_3,b_4],\\dots]$。输出是纯整数，没有单位。\n\n你的程序不能要求任何输入，并且必须按上面列出的顺序，为四个指定的测试用例精确计算结果。", "solution": "该问题提出了一个形式化的、确定性的花器官特化模型，该模型基于植物发育遗传学中广为人知的ABCE模型。任务是计算四个同心花轮在不同基因激活时间条件下的发育命运。该问题具有科学依据，是适定的，并且所有参数和规则都已明确规定，没有歧义。因此，它被认为是一个有效的问题，可以通过直接模拟找到唯一解。\n\n该模型是一个定义在四个空间域（或花轮）上的同步布尔网络，索引为 $i \\in \\{1, 2, 3, 4\\}$。系统在任何离散时间步 $t$ 的状态由五个基因类别的布尔状态集合给出：$\\{A_i(t), B_i(t), C_i(t), D_i(t), E_i(t)\\}_{i=1}^4$。\n\n动态由一组确定性的更新规则控制，这些规则在每个时间步同步应用。我们从 $t=0$ 时的指定初始状态开始，将系统在时间上向前迭代，直到指定的读出时间 $T$。\n\n模型的关键组成部分如下：\n\n1.  **状态变量和初始条件**：\n    每个花轮 $i$ 在时间 $t$ 的状态是一个布尔基因活性的向量。问题指定在 $t=0$ 时，所有基因活性都为零，即对所有 $i \\in \\{1,2,3,4\\}$，$A_i(0)=B_i(0)=C_i(0)=D_i(0)=0$。E类基因被假定为组成型激活，因此对所有 $i$ 和 $t$，$E_i(t)=1$。\n\n2.  **空间预定模式**：\n    A类和C类基因活动的潜在区域由固定的空间预定模式建立，这些模式与时间无关。\n    $$A^{\\mathrm{pre}}_i = \\begin{cases} 1  \\text{若 } i \\in \\{1,2\\} \\\\ 0  \\text{否则} \\end{cases}$$\n    $$C^{\\mathrm{pre}}_i = \\begin{cases} 1  \\text{若 } i \\in \\{3,4\\} \\\\ 0  \\text{否则} \\end{cases}$$\n\n3.  **同步更新规则**：\n    系统在时间 $t+1$ 的状态完全基于其在时间 $t$ 的状态来计算。\n\n    -   **A类和C类基因**：这些基因在它们各自的预定模式区域内被激活，并表现出相互抑制。\n        $$A_i(t+1) = A^{\\mathrm{pre}}_i \\land \\neg C_i(t)$$\n        $$C_i(t+1) = C^{\\mathrm{pre}}_i \\land \\neg A_i(t)$$\n\n    -   **B类基因**：B类基因的激活仅限于位于A类和C类基因区域交界处的花轮。这通过一个 `BOUNDARY` 谓词来形式化。相邻花轮用 $\\mathrm{nbr}_L(i)=i-1$ 和 $\\mathrm{nbr}_R(i)=i+1$ 表示。超出 $[1,4]$ 范围的花轮被视为基因活性为零（$A=0, C=0$）。\n        $$\\mathrm{BOUNDARY}_i(t) \\equiv \\big(A_{\\mathrm{nbr}_L(i)}(t) \\land C_{\\mathrm{nbr}_R(i)}(t)\\big) \\lor \\big(C_{\\mathrm{nbr}_L(i)}(t) \\land A_{\\mathrm{nbr}_R(i)}(t)\\big)$$\n        B类基因一旦被激活，就保持激活状态（一种锁存机制）。激活取决于边界条件的满足以及一个花轮特异性的时间延迟参数 $\\tau^{(B)}_i$。\n        $$B_i(t+1) = B_i(t) \\lor \\big( \\mathrm{BOUNDARY}_i(t) \\land [\\, t \\ge \\tau^{(B)}_i \\,] \\big)$$\n        问题指定 $\\tau^{(B)}_1=\\tau^{(B)}_4=+\\infty$，这有效地阻止了B类基因在花轮 $1$ 和 $4$ 中的激活。\n\n    -   **D类基因**：D类基因的激活仅限于最内层的花轮（$i=4$），并依赖于C类基因的活性和一个时间延迟 $\\tau^{(D)}$。\n        $$D_i(t+1) = \\begin{cases} 1  \\text{若 } i=4,\\ t \\ge \\tau^{(D)},\\ \\text{且 } C_4(t)=1 \\\\ 0  \\text{否则} \\end{cases}$$\n\n4.  **算法模拟**：\n    对于每个由三元组 $(\\tau^{(B)}_2, \\tau^{(B)}_3, T)$ 定义的测试用例，模拟过程如下：\n    -   在 $t=0$ 时，将所有四个花轮的 $A, B, C, D$ 状态向量初始化为 $0$。\n    -   从 $t=0$ 迭代到 $T-1$。在每一步中：\n        a.  存储所有基因的当前状态 $\\{A_i(t), B_i(t), C_i(t), D_i(t)\\}$。\n        b.  使用更新规则和步骤（a）中存储的状态，为所有 $i$ 计算下一状态 $\\{A_i(t+1), B_i(t+1), C_i(t+1), D_i(t+1)\\}$ 的值。\n        c.  用新计算的下一状态替换当前状态。\n    -   循环完成后，状态向量持有时间 $T$ 的值。\n\n5.  **器官特征读出**：\n    时间 $T$ 的最终状态向量被映射为器官特征编码。对于每个花轮 $i$，基因活性组合 $(A_i(T), B_i(T), C_i(T))$ 根据经典的ABCE模型转换为整数编码：\n    -   $(A=1, B=0, C=0) \\rightarrow 1$ (萼片)\n    -   $(A=1, B=1, C=0) \\rightarrow 2$ (花瓣)\n    -   $(A=0, B=1, C=1) \\rightarrow 3$ (雄蕊)\n    -   $(A=0, B=0, C=1) \\rightarrow 4$ (心皮)\n    -   任何其他组合导致编码 $0$ (不确定)。\n\n此过程对四个指定的测试用例中的每一个都执行一次，并将得到的器官特征编码列表聚合到一个最终的输出列表中。D类基因的状态不影响器官特征编码，这与其在心皮内指定胚珠的生物学作用一致。在所有模拟中都使用固定参数 $\\tau^{(D)}=1$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the floral organ identity problem for all specified test cases.\n    \"\"\"\n    test_cases = [\n        # Case A: (tau_B_2, tau_B_3, T)\n        (0, 0, 2),\n        # Case B\n        (3, 3, 2),\n        # Case C\n        (0, 3, 2),\n        # Case D\n        (0, 0, 1),\n    ]\n\n    results = []\n    for case in test_cases:\n        tau_B_2, tau_B_3, T = case\n        organ_identities = simulate_flower_development(tau_B_2, tau_B_3, T)\n        results.append(organ_identities)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef simulate_flower_development(tau_B_2, tau_B_3, T):\n    \"\"\"\n    Simulates the Boolean gene regulatory network for a single test case.\n\n    Args:\n        tau_B_2 (int): Activation time for B-class in whorl 2.\n        tau_B_3 (int): Activation time for B-class in whorl 3.\n        T (int): Readout time.\n\n    Returns:\n        list: A list of four integers representing organ identity codes.\n    \"\"\"\n    num_whorls = 4\n    \n    # Prepattern functions\n    A_pre = np.array([1, 1, 0, 0], dtype=np.int8)\n    C_pre = np.array([0, 0, 1, 1], dtype=np.int8)\n\n    # Timing parameters\n    tau_D = 1\n    tau_B = np.array([np.inf, tau_B_2, tau_B_3, np.inf])\n\n    # Initial state at t=0\n    A = np.zeros(num_whorls, dtype=np.int8)\n    B = np.zeros(num_whorls, dtype=np.int8)\n    C = np.zeros(num_whorls, dtype=np.int8)\n    \n    # Simulation loop from t=0 to T-1\n    for t in range(T):\n        # Store current state for synchronous update\n        A_current, B_current, C_current = A.copy(), B.copy(), C.copy()\n\n        # Update A and C genes based on mutual repression\n        A_next = A_pre  (1 - C_current)\n        C_next = C_pre  (1 - A_current)\n\n        # Calculate BOUNDARY predicate based on state at time t\n        boundary = np.zeros(num_whorls, dtype=np.int8)\n        # For whorl 2 (index 1), boundary is between whorls 1 and 3\n        boundary[1] = (A_current[0]  C_current[2]) | (C_current[0]  A_current[2])\n        # For whorl 3 (index 2), boundary is between whorls 2 and 4\n        boundary[2] = (A_current[1]  C_current[3]) | (C_current[1]  A_current[3])\n\n        # Update B gene (latching logic)\n        activation_signal = np.zeros(num_whorls, dtype=np.int8)\n        for i in range(num_whorls):\n            if t >= tau_B[i]:\n                activation_signal[i] = boundary[i]\n        \n        B_next = B_current | activation_signal\n\n        # Update D gene (non-latching)\n        # Note: D is not used for readout, but computed for model completeness.\n        D_next = np.zeros(num_whorls, dtype=np.int8)\n        if t >= tau_D and C_current[3] == 1:\n            D_next[3] = 1\n\n        # Atomically update all states for the next time step\n        A, B, C = A_next, B_next, C_next\n    \n    # Readout at time T, using the final state of A, B, C\n    organ_identities = []\n    for i in range(num_whorls):\n        state = (A[i], B[i], C[i])\n        if state == (1, 0, 0):\n            organ_identities.append(1)  # Sepal\n        elif state == (1, 1, 0):\n            organ_identities.append(2)  # Petal\n        elif state == (0, 1, 1):\n            organ_identities.append(3)  # Stamen\n        elif state == (0, 0, 1):\n            organ_identities.append(4)  # Carpel\n        else:\n            organ_identities.append(0)  # Indeterminate\n\n    return organ_identities\n\nsolve()\n```", "id": "2588089"}, {"introduction": "要想理解花的起源，我们必须在不同植物谱系间比较MADS-box基因，而这需要准确鉴定直系同源基因——即因物种分化而产生的基因。这项高级练习将指导您构建一个严谨的生物信息学流程，该流程整合了来自系统发育学、溯祖理论和基因组同线性分析的证据。您将推导并实现一个贝叶斯框架，以便对基因的直系同源关系做出有原则的判断，这是任何比较或进化研究所面临的关键任务[@problem_id:2588053]。", "problem": "要求您通过整合三个证据流：最大似然系统发育证据、感知溯祖的物种树证据和共线性相似性，来形式化并用代码实现一个有原则的决策流程，用于跨物种的APETALA1/FRUITFULL类 (AP1/FUL类) MADS盒基因的直系同源分配。您的实现必须从基本且经过充分检验的原则出发，避免任何临时的或启发式的捷径。科学背景是花的起源和多样化，其中AP1/FUL类基因与种子植物和被子植物的辐射演化协同复制和多样化，并且由于不完全谱系分选，可能会出现基因树与物种树不一致的情况。\n\n使用的基本原理：\n- 最大似然 (ML) 原理：给定两个假设，似然比是它们最大似然值的比率；在独立性假设下，对数似然差可相加。如果 $\\ell_{1}$ 和 $\\ell_{2}$ 是两个备选假设的对数似然值，那么似然比为 $\\exp(\\ell_{1}-\\ell_{2})$。\n- 三分类单元物种树的多物种溯祖 (MSC) 模型：如果内部支长以溯祖单位计为 $\\tau$，则基因树与物种树一致的概率为 $p_{\\text{conc}}=1-\\frac{2}{3}e^{-\\tau}$；不一致的基因树的总概率为 $1-p_{\\text{conc}}$。\n- 共线性作为邻域保守性：给定两个基因组位点，在每个位点周围定义一组邻近基因标识符；一个标准的、无偏的相似性度量是 Jaccard 相似性 $s \\in [0,1]$，定义为 $s=\\frac{|N_{1}\\cap N_{2}|}{|N_{1}\\cup N_{2}|}$，这可以解释为两个随机抽取的邻居基因重合概率的经验估计。\n\n任务：\n- 使用贝叶斯定理和给定直系同源状态下证据流条件独立的假设，从这三个要素中推导出一个后验优势整合器。该决策规则必须在后验概率至少达到指定阈值时，将一个候选跨物种基因对分类为直系同源。\n- 您的推导过程必须仅使用上述基本陈述、逻辑概率演算以及从给定输入到似然或优势的显式映射。您必须通过在将基因树证据转换为直系同源似然贡献时，明确地利用MSC一致性概率 $p_{\\text{conc}}$，来考虑不完全谱系分选。您还必须使用平滑常数 $\\epsilon$ 在适当情况下避免除以零，将共线性相似性 $s$ 转换为一个没有任意不连续性的、定义良好的优势贡献。\n- 将推导出的决策规则实现为一个程序，该程序处理嵌入在代码中的测试用例（无输入），并输出相应的布尔决策。\n\n约定和要求：\n- 设直系同源的先验概率为 $\\pi\\in(0,1)$，先验优势为 $\\frac{\\pi}{1-\\pi}$。\n- 设 ML 比较被编码为 $\\Delta \\ell=\\ell_{\\text{sister}}-\\ell_{\\text{alt}}$，即把候选对置为姐妹关系的基因树拓扑的最佳对数似然与不这样做（即采用最佳备选拓扑）的最佳对数似然之差。\n- 设 $\\tau\\ge 0$ 为以溯祖单位计的内部支长，与所比较物种及其在物种树中最近外群的分化相关。\n- 设 $s\\in[0,1]$ 为候选位点邻域的 Jaccard 共线性相似性，并设 $\\epsilon0$ 为一个固定的微小常数，仅用于避免在 $s=0$ 或 $s=1$ 时出现未定义的优势。\n- 对后验概率使用一个硬决策阈值 $\\theta\\in(0,1)$，当且仅当后验概率至少为 $\\theta$ 时，一对基因被称为直系同源。\n\n测试套件：\n提供一个程序，精确评估以下五个案例，每个案例由元组 $(\\Delta \\ell,\\tau,s,\\pi)$ 指定，所有测试共享固定的 $\\epsilon$ 和阈值 $\\theta$。以下所有数值均为无量纲。\n1. 案例A（深层分歧，强系统发育信号，强共线性）：$(\\Delta \\ell=\\;5.0,\\;\\tau=\\;2.0,\\;s=\\;0.8,\\;\\pi=\\;0.6)$。\n2. 案例B（浅层分歧，因不完全谱系分选导致系统发育信号弱，共线性非常强）：$(\\Delta \\ell=\\;1.0,\\;\\tau=\\;0.2,\\;s=\\;0.9,\\;\\pi=\\;0.5)$。\n3. 案例C（中度分歧，系统发育支持备选分组，共线性差）：$(\\Delta \\ell=\\;-2.0,\\;\\tau=\\;1.5,\\;s=\\;0.1,\\;\\pi=\\;0.5)$。\n4. 案例D（类似多歧分枝，无系统发育偏好，共线性完美）：$(\\Delta \\ell=\\;0.0,\\;\\tau=\\;0.0,\\;s=\\;1.0,\\;\\pi=\\;0.5)$。\n5. 案例E（近零分支，ML信号强但共线性近乎随机）：$(\\Delta \\ell=\\;3.0,\\;\\tau=\\;0.01,\\;s=\\;0.0,\\;\\pi=\\;0.3)$。\n\n固定常数：\n- 使用 $\\epsilon=\\;0.01$ 进行共线性优势平滑。\n- 使用 $\\theta=\\;0.5$ 作为后验概率阈值。\n\n输出规范：\n- 对于五个案例中的每一个，您的程序必须使用您推导出的、感知溯祖的、整合了ML和共线性的公式来计算直系同源的后验概率，并通过与阈值 $\\theta$ 比较，为每个案例返回一个布尔决策。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，列表字面量）形式的结果，其顺序与测试套件中的案例顺序相同。例如，一个有效的输出格式类似于：\"[True,False,True,True,False]\"。", "solution": "所述问题是有效的。它在科学上基于分子进化和生物信息学的既定原则，在数学上是适定的，其组成部分的定义足够精确，可以进行形式化推导和实现。该问题要求开发一个贝叶斯决策流程来评估基因对之间的直系同源性，这是比较基因组学中的一项标准任务。解决方案将按照规定从第一性原理推导得出。\n\n我们的目标是计算直系同源的后验概率 $P(O | D)$，其中 $O$ 是给定基因对为直系同源的假设，而 $D$ 代表来自三个证据流的全部证据：最大似然 ($D_{ML}$)、多物种溯祖 ($D_{MSC}$) 和共线性 ($D_{Syn}$)。如果 $P(O | D) \\ge \\theta$（其中 $\\theta$ 是指定的阈值），则做出将该基因对分类为直系同源的决策。\n\n我们采用贝叶斯定理的优势形式。直系同源的后验优势是先验优势与贝叶斯因子（或总似然比）的乘积：\n$$\n\\frac{P(O | D)}{P(\\neg O | D)} = \\frac{P(D | O)}{P(D | \\neg O)} \\times \\frac{P(O)}{P(\\neg O)}\n$$\n此处，$\\neg O$ 代表备选假设（旁系同源），先验优势由 $\\frac{\\pi}{1-\\pi}$ 给出，其中 $\\pi = P(O)$ 是直系同源的先验概率。\n\n问题规定，在给定直系同源状态下，证据流应被视为条件独立的。然而，来自最大似然 ($\\Delta \\ell$) 和多物种溯祖 ($\\tau$) 的系统发育证据是内在相关的。溯祖模型提供了基因树-物种树一致性的先验概率，这对于解释基因树的ML得分是必要的。因此，我们将从 $\\Delta \\ell$ 和 $\\tau$ 构建一个统一的系统发育似然比 $LR_{phylo}$。共线性证据 ($s$) 被视为一个独立的、条件独立的流，产生一个似然比 $LR_{Syn}$。总似然比为 $LR_{total} = LR_{phylo} \\times LR_{Syn}$。那么，后验优势 $O_{post}$ 为：\n$$\nO_{post} = \\left(\\frac{\\pi}{1-\\pi}\\right) \\times LR_{phylo} \\times LR_{Syn}\n$$\n\n系统发育似然比 ($LR_{phylo}$) 的推导：\n设 $A$ 为序列比对数据。ML 证据由 $\\Delta \\ell = \\ell_{sister} - \\ell_{alt} = \\ln P(A|T_{sis}) - \\ln P(A|T_{alt})$ 给出，其中 $T_{sis}$ 是候选基因为姐妹关系的基因树拓扑，而 $T_{alt}$ 是最佳备选拓扑。由此，这些拓扑的似然比率为 $P(A|T_{sis})/P(A|T_{alt}) = e^{\\Delta \\ell}$。\n\n三分类单元物种树的溯祖模型给出了基因树与物种树一致的概率为 $p_{conc} = 1 - \\frac{2}{3}e^{-\\tau}$，其中 $\\tau$ 是以溯祖单位计的内部支长。直系同源关系 ($O$) 意味着物种形成事件定义了基因分化，因此在给定直系同源关系的情况下，在基因树中观察到姐妹关系的概率为 $P(T_{sis}|O) = p_{conc}$。观察到不一致拓扑的概率为 $P(T_{alt}|O) = 1-p_{conc}$。\n\n在旁系同源假设 ($\\neg O$)下，基因复制事件早于我们关注的物种形成事件。基因树拓扑不受物种树的约束。对于三分类单元的情况，存在三种可能的有根拓扑。假设它们先验等可能（这是深度溯祖的标准假设），则偶然观察到姐妹拓扑的概率为 $P(T_{sis}|\\neg O) = 1/3$，非姐妹拓扑的概率为 $P(T_{alt}|\\neg O) = 2/3$。\n\n在每种假设下，比对数据 $A$ 的总似然是通过对可能的基因树拓扑进行边缘化来求得的：\n$$\nP(A|O) = P(A|T_{sis})P(T_{sis}|O) + P(A|T_{alt})P(T_{alt}|O)\n$$\n$$\nP(A|\\neg O) = P(A|T_{sis})P(T_{sis}|\\neg O) + P(A|T_{alt})P(T_{alt}|\\neg O)\n$$\n系统发育似然比是这些量的比率：\n$$\nLR_{phylo} = \\frac{P(A|O)}{P(A|\\neg O)} = \\frac{P(A|T_{sis}) p_{conc} + P(A|T_{alt})(1-p_{conc})}{P(A|T_{sis})\\frac{1}{3} + P(A|T_{alt})\\frac{2}{3}}\n$$\n将分子和分母同除以 $P(A|T_{alt})$ 并代入 $e^{\\Delta \\ell}$ 可得：\n$$\nLR_{phylo} = \\frac{e^{\\Delta \\ell} p_{conc} + (1-p_{conc})}{\\frac{1}{3}e^{\\Delta \\ell} + \\frac{2}{3}} = 3 \\frac{e^{\\Delta \\ell} p_{conc} + 1-p_{conc}}{e^{\\Delta \\ell} + 2}\n$$\n\n共线性似然比 ($LR_{Syn}$) 的推导：\nJaccard 相似性 $s \\in [0,1]$ 是在两个基因位点之间找到一个共享邻居的概率的经验估计。$s$ 的高值支持直系同源，而低值支持旁系同源。一种将其转换为似然比的简单且有原则的方法是将其解释为优势比，$LR_{Syn} \\approx \\frac{s}{1-s}$。然而，这在 $s=1$ 时未定义，在 $s=0$ 时为零，这意味着从单一、可能有噪声的证据中得出了绝对确定的结论。\n为了按要求创建一个定义良好且更平滑的优势贡献，我们首先对概率估计 $s$ 进行正则化。我们使用线性变换将 $s \\in [0,1]$ 映射到一个新值 $s' \\in [\\epsilon, 1-\\epsilon]$：$s' = (1-2\\epsilon)s + \\epsilon$。这可以防止概率达到 $0$ 或 $1$ 的极端值。然后将似然比取为此平滑概率的优势：\n$$\nLR_{Syn} = \\frac{s'}{1-s'} = \\frac{(1-2\\epsilon)s + \\epsilon}{1 - [(1-2\\epsilon)s+\\epsilon]} = \\frac{(1-2\\epsilon)s + \\epsilon}{1 - \\epsilon - (1-2\\epsilon)s}\n$$\n这种变换正确地使用了平滑常数 $\\epsilon$，以确保对于 $s \\in [0,1]$，优势始终是有限且非零的。\n\n最终决策规则：\n后验优势通过组合以下部分计算得出：\n$$\nO_{post} = \\left(\\frac{\\pi}{1-\\pi}\\right) \\times \\left(3 \\frac{e^{\\Delta \\ell} (1 - \\frac{2}{3}e^{-\\tau}) + \\frac{2}{3}e^{-\\tau}}{e^{\\Delta \\ell} + 2}\\right) \\times \\left(\\frac{(1-2\\epsilon)s + \\epsilon}{1 - \\epsilon - (1-2\\epsilon)s}\\right)\n$$\n决策规则是，如果后验概率 $P(O|D) = \\frac{O_{post}}{1+O_{post}} \\ge \\theta$，则分类为直系同源。这等价于对后验优势设置一个阈值：$O_{post} \\ge \\frac{\\theta}{1-\\theta}$。给定固定常数 $\\theta = 0.5$，优势阈值为 $\\frac{0.5}{1-0.5} = 1$。因此，当且仅当 $O_{post} \\ge 1$ 时，一个基因对被分类为直系同源。下面的程序实现了这个推导出的逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the orthology assignment problem by deriving and implementing a \n    Bayesian decision pipeline.\n    \"\"\"\n\n    # Define the fixed constants from the problem statement.\n    EPSILON = 0.01\n    THETA = 0.5\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (delta_ell, tau, s, pi)\n    test_cases = [\n        # Case A: deep split, strong phylogeny, strong synteny\n        (5.0, 2.0, 0.8, 0.6),\n        # Case B: shallow split, weak phylogeny (ILS), strong synteny\n        (1.0, 0.2, 0.9, 0.5),\n        # Case C: moderate split, phylogeny favors alternative, poor synteny\n        (-2.0, 1.5, 0.1, 0.5),\n        # Case D: polytomy-like branch, no phylo preference, perfect synteny\n        (0.0, 0.0, 1.0, 0.5),\n        # Case E: near-zero branch, strong ML, near-random synteny\n        (3.0, 0.01, 0.0, 0.3),\n    ]\n\n    results = []\n    # The decision threshold on the posterior odds is theta / (1 - theta).\n    # For theta = 0.5, this threshold is 1.0.\n    odds_threshold = THETA / (1.0 - THETA)\n\n    for case in test_cases:\n        delta_ell, tau, s, pi = case\n\n        # 1. Calculate Prior Odds\n        # O_prior = pi / (1 - pi)\n        # Handle the edge case where pi is 1.0, though the problem states pi is in (0,1).\n        if pi == 1.0:\n            prior_odds = float('inf')\n        else:\n            prior_odds = pi / (1.0 - pi)\n\n        # 2. Calculate Phylogenetic Likelihood Ratio (LR_phylo)\n        # This combines Maximum Likelihood (delta_ell) and Multispecies Coalescent (tau).\n        \n        # 2a. Calculate the probability of gene tree concordance (p_conc)\n        p_conc = 1.0 - (2.0 / 3.0) * np.exp(-tau)\n        \n        # 2b. Calculate LR_phylo using the derived formula\n        exp_delta_ell = np.exp(delta_ell)\n        phylo_numerator = exp_delta_ell * p_conc + (1.0 - p_conc)\n        phylo_denominator = (1.0 / 3.0) * exp_delta_ell + (2.0 / 3.0)\n        \n        # The full expression is 3 * numerator / (exp_delta_ell + 2), which is\n        # equivalent to numerator / denominator.\n        lr_phylo = phylo_numerator / phylo_denominator\n        \n        # 3. Calculate Synteny Likelihood Ratio (LR_syn)\n        # This transforms the Jaccard similarity 's' into an odds contribution\n        # using a smoothing constant epsilon.\n        \n        # 3a. Apply smoothing to s to get s_prime\n        s_prime = (1.0 - 2.0 * EPSILON) * s + EPSILON\n        \n        # 3b. Calculate LR_syn as the odds of the smoothed probability s_prime\n        lr_syn = s_prime / (1.0 - s_prime)\n\n        # 4. Calculate Posterior Odds\n        # O_post = O_prior * LR_phylo * LR_syn\n        posterior_odds = prior_odds * lr_phylo * lr_syn\n        \n        # 5. Make the decision\n        # The pair is orthologous if the posterior odds meet or exceed the threshold.\n        is_orthologous = posterior_odds >= odds_threshold\n        results.append(is_orthologous)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2588053"}]}