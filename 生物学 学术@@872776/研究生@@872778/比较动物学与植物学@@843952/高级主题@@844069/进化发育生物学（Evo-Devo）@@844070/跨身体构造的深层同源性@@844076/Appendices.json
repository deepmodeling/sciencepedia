{"hands_on_practices": [{"introduction": "深入同源性的核心在于验证跨物种的调控逻辑是否保守。现代基因编辑技术（如CRISPR）使我们能够以前所未有的精度检验这一思想，例如通过“增强子互换”实验。这项练习将挑战你设计一个严谨的实验 [@problem_id:2564636]，以测试一个来自小鼠的Hox基因增强子能否在果蝇的内源基因座上正常工作，从而迫使你思考基因组背景、必要对照和定量读数等关键细节。", "problem": "在比较动物学和植物学中，深层同源性指的是即使形态不同，基因调控网络在远缘相关的身体构型中仍然保守。一个核心的测试是，来自一个物种的顺式调控增强子是否能在另一个物种的内源基因座上功能性地替代其直系同源物。请考虑以下框架：分子生物学的中心法则指出，DNA转录为RNA，再翻译为蛋白质；为了实现转录的空间和时间特异性，顺式调控模块（增强子）通过序列特异性结合位点整合转录因子的输入，以调节启动子活性。在Hox基因簇中，保守的前后轴表达域是由包括增强子、绝缘子以及限制在拓扑关联域（TADs）内的三维基因组拓扑结构所构成的调控结构建立的。假设增强子的直系同源关系可以通过保守的基因共线性和共享的基序含量来确定，而不是严格的序列一致性。您的任务是从以下选项中，找出最严谨的、基于成簇规律间隔短回文重复序列（CRISPR）的跨物种增强子交换实验，该实验能直接测试Hox调控结构在不同动物门之间是否功能保守，并能从第一性原理中识别出适当的预测和对照组。该设计应能分离增强子功能、避免位置效应、尊重局部染色质拓扑结构，并提供定量的、具备空间解析度的基因功能读数。\n\n哪个选项最能满足这些标准？\n\nA. 使用CRISPR相关蛋白9（Cas9）和同源指导修复（HDR）在果蝇的内源基因座上，对一个已定义的、必需的Hox增强子进行无痕替换，用其直系同源的小鼠增强子取而代之，在同一拓扑关联域（TAD）内保持增强子与启动子的方向和距离。包括在直系同源的小鼠基因座上进行相互交换。使用经全基因组测序确认的单拷贝编辑，并利用等位基因特异性报告基因来区分编辑后的等位基因与野生型。利用单分子RNA荧光原位杂交（RNA-FISH）来量化空间表达，通过染色质免疫沉淀后测序（ChIP-seq）评估转录因子占用情况，并在敏感化突变体背景中测试表型拯救效果。包括对照组：物种匹配的增强子替换（阳性对照）、大小匹配的非直系同源增强子（阴性对照），以及碱基组成相同但序列随机打乱的增强子（阴性对照）。预测如果调控结构是保守的，跨物种增强子将驱动表达域边界位于沿前后轴野生型位置的大约$10\\%$范围内，并拯救体节身份缺陷，同时保持通过染色体构象捕获测量到的适当三维接触。\n\nB. 产生携带多拷贝质粒的转基因果蝇胚胎，该质粒上带有小鼠Hox增强子，在一个异源最小启动子下驱动绿色荧光蛋白（GFP）的表达，并插入到随机的基因组位置。如果GFP在任何轴向域中表达，则断定调控结构是保守的。无需相互交换实验或内源基因座替换，大量RNA测序足以量化保守性，无需空间分析。\n\nC. 使用CRISPR-Cas9将果蝇Hox编码序列替换为小鼠Hox编码序列，并保持所有果蝇增强子不变。如果小鼠编码序列拯救了果蝇的体节身份表型，则断定Hox调控结构在物种间是保守的。增强子的操作是不必要的，因为编码区的拯救证明了深层同源性。\n\nD. 使用CRISPR-Cas9将小鼠增强子插入到果蝇基因组中Hox基因簇外的一个安全港位点，同时删除内源的Hox增强子。在单一时间点，从整个胚胎中通过大量定量聚合酶链式反应（qPCR）测量总Hox mRNA水平。如果总mRNA在野生型的$2$倍范围内，则解释为功能保守，因为即使位置不同，增强子仍然增加了转录。\n\nE. 通过在内源基因座上用植物KNOX基因增强子替换果蝇Hox增强子来测试跨界保守性。如果在$24$小时后通过免疫染色检测到果蝇Hox表达的任何变化，则断定Hox调控结构的深层同源性延伸至动物和植物之间，使得动物间的比较变得不必要。\n\n选择最佳选项。", "solution": "对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- **概念**：深层同源性是远缘相关身体构型中基因调控网络的保守性。\n- **测试**：一个物种的顺式调控增强子在另一物种的内源基因座上功能性地替代其直系同源物。\n- **生物学框架**：中心法则（DNA $\\rightarrow$ RNA $\\rightarrow$ 蛋白质）；增强子整合转录因子（TF）输入以调节启动子活性，从而实现时空特异性的基因表达。\n- **模型系统**：Hox基因簇，其表达域由包括增强子、绝缘子和三维基因组拓扑结构（拓扑关联域，或TADs）在内的调控结构设定。\n- **假设**：增强子的直系同源关系由保守的基因共线性和共享的基序含量决定，而非严格的序列一致性。\n- **任务**：找出最严谨的、基于CRISPR的跨物种增强子交换实验，以测试Hox调控结构在不同动物门之间的功能保守性。\n- **实验设计标准**：\n    1. 分离增强子功能。\n    2. 避免位置效应。\n    3. 尊重局部染色质拓扑结构。\n    4. 提供定量的、具备空间解析度的基因功能读数。\n    5. 包括适当的预测和对照组。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据。它准确地描述了分子生物学、演化生物学和发育生物学中已確立的原理，包括深层同源性、顺式调控元件的功能、Hox基因调控的结构，以及CRISPR-Cas9等现代基因组学和基因编辑技术的应用。问题的设定良好，要求根据一组清晰而严谨的标准来评估实验设计。语言客观而精确。问题本身是自洽的，没有矛盾或缺失的信息。所提出的情境是对该领域前沿研究的一个真实（尽管具有挑战性）的再现。\n\n**步骤 3：结论与行动**\n问题陈述有效。它在实验设计方面提出一个复杂而正确的挑战。我将对提供的选项进行全面分析。\n\n**解题推导与选项分析**\n\n任务要求找出最严谨的实验设计，以测试*调控结构*的功能保守性。这意味着实验必须尽可能地保持调控元件在其原生环境中的背景，因为结构是由各组分之间的关系所定义的。这类实验的核心必须是在内源基因组位点上精确替换目标元件（增强子），并将所有其他干扰降至最低。读数必须足夠灵敏，以检测基因表达中细微的、空间上定义的变化，这是Hox基因增强子的关键功能。\n\n**选项A分析**\n此选项建议使用CRISPR相关蛋白9（Cas9）和同源指导修复（HDR）在*果蝇*的内源基因座上，用其小鼠直系同源物进行无痕替换。\n- **`内源基因座`替换**：这是最关键的特征。它直接在增强子的原生染色质环境中测试其功能，包括其与正确的启动子、绝缘子以及拓扑关联域（TAD）内的三维接触的相互作用。此方法正确地满足了避免位置效应和尊重局部染色质拓扑结构的标准。\n- **`无痕`替换及保持`方向`和`距离`**：这些细节展示了高度的实验严谨性，确保唯一的变量是增强子序列本身，而不是编辑过程的产物或基因组几何结构的改变。\n- **`相互交换`**：在两种宿主生物（*果蝇*和小鼠）中都进行实验，为保守功能提供了最强有力的证据。\n- **读数**：使用单分子RNA荧光原位杂交（smFISH或RNA-FISH）提供了必要的定量和空间解析表达数据（标准$4$）。染色质免疫沉淀后测序（ChIP-seq）直接探究其机制——即宿主转录因子是否结合外源增强子。表型拯救则在生物体层面评估功能。这是一个多层次、全面的方法。\n- **对照组**：包含物种匹配的阳性对照、非直系同源的阴性对照以及序列随机打乱的阴性对照，堪称典范。这使得任何观察到的功能都能明确地归因于直系同源增强子中特定的、保守的调控信息。\n- **预测**：预测是具体的、定量的（例如，表达域边界在$10\\%$范围内），并且有其机制基础，反映了一个清晰的假设。\n**结论：正确**。此选项描述了“黄金标准”实验，满足了问题中陈述的所有关于严谨性、精确性和全面分析的标准。\n\n**选项B分析**\n此选项建议产生带有携带小鼠增强子和报告基因质粒的转基因*果蝇*，并随机插入。\n- **`随机基因组位置`**：这是一个根本性缺陷。它完全没有在其原生调控结构背景下测试增强子。表达将受到插入位点周围染色质的「位置效应」影响，使得结果对于原始Hox基因座而言无法解释。\n- **`多拷贝质粒`**：这引入了基因剂量的人为影响，是另一个严重的混淆变量。\n- **`异源最小启动子`**：这将增强子与其原生的同源启动子解耦，未能测试调控结构中一个可能保守的方面。\n- **`大量RNA测序`**：这种读数没有空间解析度，因此不足以评估Hox增强子的主要功能，即创建精确的空间表达模式。\n- **结论逻辑**：基于「任何轴向域」的表达就得出保守性的结论，是一个不可接受的低证据标准。\n**结论：错误**。该设计原始且存在多个致命缺陷。\n\n**选项C分析**\n此选项建议用小鼠直系同源物替换*果蝇*的Hox*编码序列*（基因的蛋白质编码部分）。\n- **操纵目标**：该实验测试的是Hox*蛋白质*的功能保守性，而不是顺式调控结构（增强子）。问题明确要求测试*调控结构*。因此，这个实验虽然可能因其他原因而有趣，但并未解决所提出的问题。\n- **逻辑错误**：得出调控结构保守的结论是一个不合逻辑的推论。该实验没有提供任何关于增强子功能的信息。\n**结论：错误**。此选项从根本上误解了顺式调控元件和蛋白质编码基因之间的区别，未能测试指定的假设。\n\n**选项D分析**\n此选项建议将小鼠增强子插入一个“安全港”位点，同时删除内源增强子。\n- **`安全港位点`**：虽然比随机插入有所改进，但这仍然将增强子从其原生的TAD及其与目标启动子的正确邻近性和方向性中移除。它未能测试增强子作为内源结构一部分的功能，因此违反了标准$3$。定义该结构的三维环化和相互作用都已丢失。\n- **读数**：使用大量定量聚合酶链式反应（qPCR）与大量RNA-seq一样，是空间盲的。它无法测量表达域的精确性，而这才是关键的功能输出。测量总mRNA水平是一个粗略的替代指标，忽略了本质的生物学功能。\n- **解释**：总mRNA的$2$倍变化是一个过于简化的指标，忽略了所有空间信息，不能构成对保守模式形成功能的严谨证明。\n**结论：错误**。该设计未能在适当的背景下测试增强子，并使用了不充分的测量技术。\n\n**选项E分析**\n此选项建议进行跨界交换，用植物*KNOX*基因增强子替换*果蝇*Hox增强子。\n- **科学前提**：这在科学上是不合理的。虽然*KNOX*和*Hox*基因都涉及同源异型结构域，但植物（Plantae）和动物（Animalia）已经独立演化了超过十亿年。它们的转录调控网络，包括转录因子及它们结合的DNA序列基序，并不保守。这样的实验并非对「深层同源性」（该术语用于动物门时有其特定意义）的测试，而更多是基于表面类比的推测。没有先验理由预期它们具有功能相容性。\n- **实验严谨性**：成功的标准，「果蝇Hox表达的任何变化」，是模糊且无益的。最可能的結果是表达被破坏，而这并不能证明任何关于保守性的问题。\n- **结论**：认为这将使动物间的比较变得不必要的结论是不合逻辑的，并且与所有已建立的演化生物学原理背道而驰。\n**结论：错误**。此选项基于有缺陷的科学前提，代表了一个构思拙劣的实验。\n\n总而言之，选项A是唯一描述了一个科学严谨、方法学上合理且全面的实验，直接解决了保守调控结构的问题，并满足所有指定标准的选项。", "answer": "$$\\boxed{A}$$", "id": "2564636"}, {"introduction": "在设计了精密的实验之后，下一步便是严谨地分析由此产生的数据。这项练习 [@problem_id:2564809] 提出了一个真实的定量分析挑战，聚焦于经典的“背腹轴反转”假说。面对两种生物的信号梯度数据，你必须选择一个能够恰当处理数据复杂性（如空间自相关）和假说精髓（单调的镜像关系）的统计方法，从而学会避免常见的统计陷阱。", "problem": "在比较动物学和植物学中，深层同源性理论预测，保守的基因调控网络可以构成不同身体构造的基础。对于背腹模式的形成，骨形态发生蛋白 (Bone Morphogenetic Protein, BMP) 信号通常会沿着背腹轴形成一个梯度分布。考虑两个分类单元 $\\mathcal{T}_1$ 和 $\\mathcal{T}_2$，在它们可比较的发育阶段，沿着标准化的背腹坐标 $x \\in [0,1]$ 测量了其空间的 BMP 浓度分布，得到了离散样本 $\\{(x_i, g_1(x_i))\\}_{i=1}^n$ 和 $\\{(x_i, g_2(x_i))\\}_{i=1}^n$，其中对所有 $i$ 都有 $x_{i+1}-x_i=\\Delta x$ 且 $n \\ge 20$。假设这两个分布曲线都是平滑的，并且沿着 $x$ 具有空间自相关性。一个经典的体轴反转假说预测了镜像对应关系，即，在翻转其中一个轴后，存在一个未知的单调递增变换 $h$ 和常数 $\\alpha \\in \\mathbb{R}$ 与 $\\beta > 0$，使得：\n$$\ng_2(x) \\approx \\alpha + \\beta \\, h\\!\\big(g_1(1-x)\\big) + \\varepsilon(x),\n$$\n其中 $\\varepsilon(x)$ 是均值为零且沿着 $x$ 具有空间自相关性的噪声。\n\n您的目标是选择一个统计检验，该检验从假设检验的基本原理出发，同时考虑到空间自相关性和信号幅度的未知单调变换，用以评估这两个分布曲线是否表现出与体轴反转假说一致的显著镜像对应关系。该检验应在 $\\alpha = 0.05$ 的水平上控制 I 型错误，并且不假设样本在 $x$ 轴上是独立的。\n\n哪个选项最恰当地描述了这样一个检验？\n\nA. 对 $\\mathcal{T}_1$ 进行 $R(x)=1-x$ 翻转，在共享网格上对翻转后的 $g_1$ 和 $g_2$ 进行秩变换以获得秩 $\\tilde{g}_1(1-x_i)$ 和 $\\tilde{g}_2(x_i)$，计算 Spearman 秩相关系数 $T_{\\mathrm{obs}}=\\rho_s\\big(\\tilde{g}_1(1-x_i),\\tilde{g}_2(x_i)\\big)$，从经验自相关函数的第一个过零点估计自相关长度 $b$，通过对 $\\tilde{g}_2(x_i)$ 以长度为 $b$ 的连续块进行分块置换生成零分布（重复 $B \\ge 1000$ 次），计算置换 $p$ 值 $p=\\frac{1+\\#\\{T_b \\ge T_{\\mathrm{obs}}\\}}{1+B}$，当 $p < 0.05$ 时拒绝原假设。\n\nB. 在 $\\alpha=0.05$ 的水平上，应用双样本 Kolmogorov–Smirnov 检验来比较 $g_1$ 和 $g_2$ 的经验分布（不进行翻转）。如果分布相同的原假设未被拒绝，则断定存在与体轴反转一致的镜像对应关系。\n\nC. 计算 $g_1(x_i)$ 和 $g_2(x_i)$ 之间的 Pearson 相关系数 $r$（不进行翻转）。如果 $r < -0.8$ 且在自由度为 $n-2$ 的常规相关性 $t$ 检验下于 $\\alpha=0.05$ 水平上显著，则断定存在体轴反转。\n\nD. 通过普通最小二乘法拟合线性模型 $g_2(x_i)=\\alpha+\\beta g_1(x_i)+\\epsilon_i$（不进行翻转），然后在 $\\alpha=0.05$ 水平上检验 $H_0\\!:\\beta=0$ 对 $H_1\\!:\\beta < 0$。如果 $H_0$ 被拒绝，则断定存在指示体轴反转的镜像对应关系。\n\n假设除了共享的标准化坐标网格之外，没有可用于配准的、稳健的跨分类单元解剖学标志，并且任何有效的检验都必须明确地处理信号幅度的未知单调重缩放和沿背腹轴的空间自相关。请选择唯一的最佳选项。", "solution": "问题要求选择一个合适的统计检验来评估发育生物学中的经典体轴反转假说。该假说假设两个分类单元 $\\mathcal{T}_1$ 和 $\\mathcal{T}_2$ 的背腹模式形成信号分布之间存在镜像对应关系。\n\n首先，我们必须验证问题陈述的有效性。\n\n**步骤1：提取已知条件**\n- 数据包含两个空间分布 $g_1(x)$ 和 $g_2(x)$，在共享的、标准化的网格 $x \\in [0,1]$ 上采样，有 $n \\ge 20$ 个点。采样位置为 $\\{x_i\\}_{i=1}^n$。\n- 这些分布是代表 BMP 浓度的信号：$\\{(x_i, g_1(x_i))\\}$ 和 $\\{(x_i, g_2(x_i))\\}$。\n- 陈述中指出，这些分布是平滑的，并且沿着坐标 $x$ 具有空间自相关性。\n- 体轴反转假说的数学表达式为 $g_2(x) \\approx \\alpha + \\beta \\, h\\!\\big(g_1(1-x)\\big) + \\varepsilon(x)$。\n- 在这个模型中：\n    - $1-x$ 代表空间轴的翻转。\n    - $h$ 是一个未知的单调递增函数。\n    - $\\alpha \\in \\mathbb{R}$ 和 $\\beta > 0$ 是用于偏移和缩放的未知常数。\n    - $\\varepsilon(x)$ 是一个均值为零且具有空间自相关性的噪声项。\n- 目标是找到一个满足以下条件的统计检验：\n    1.  评估镜像对应关系。\n    2.  考虑未知的单调变换 $h$。\n    3.  考虑空间自相关性。\n    4.  在 $\\alpha = 0.05$ 的水平上控制 I 型错误。\n    5.  不假设样本是独立的。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据：**该问题基于进化发育生物学中公认的背腹轴反转假说，这是该领域的核心概念。使用 BMP 信号作为具体例子是经典做法。该问题在科学上是合理的。\n- **良构性：**该问题是良构的。它定义了一个具体的假说，描述了数据的性质，并要求一个尊重这些性质的合适统计程序。这些约束（自相关性、未知的单调函数）是明确的，并指向一类特定的统计方法。\n- **客观性：**问题陈述是客观的，并使用了精确的数学和生物学术语。\n- **结论：**问题陈述是有效的。它不包含科学或逻辑上的缺陷，定义明确，并在应用统计学中提出了一个非平凡的挑战。\n\n**步骤3：结论与行动**\n- **结论：**问题有效。\n- **行动：**继续推导解决方案并评估各个选项。\n\n**合适检验的推导**\n\n假说是 $g_2(x) \\approx \\alpha + \\beta \\, h\\!\\big(g_1(1-x)\\big)$。我们必须构建一个检验来处理该模型的每个组成部分。\n\n1.  **镜像分量 ($g_1(1-x)$):** 该假说并非关于 $g_1(x)$ 与 $g_2(x)$ 之间的直接关系，而是关于 $g_2(x)$ 与 $g_1(x)$ 的空间翻转版本之间的关系。因此，第一步必须是计算翻转后的分布，我们称之为 $g_{1,R}(x) = g_1(1-x)$。然后，假说就变成了 $g_2(x)$ 与 $g_{1,R}(x)$ 之间存在正相关关系。\n\n2.  **未知的单调变换 ($h$):** 信号幅度之间的关系不一定是线性的。函数 $h$ 仅被指定为单调递增。这意味着如果 $u > v$，那么 $h(u) \\ge h(v)$。通过 $\\beta>0$ 进行的线性缩放和通过 $\\alpha$ 进行的偏移会保持这种单调性。因此，该假说是一个关于 $g_2(x)$ 和 $g_{1,R}(x) = g_1(1-x)$ 之间存在*单调关联*的假说。像 Pearson 相关性这样的线性关联检验是不正确的，因为它在一般单调变换下不是不变的。正确的方法是使用基于秩的方法。Spearman 秩相关系数 $\\rho_s$ 专门用于衡量单调关系的强度。它是通过计算秩变换后数据的 Pearson 相关性得出的。通过将 $g_2(x_i)$ 和 $g_{1,R}(x_i)$ 的值转换为它们各自的秩，我们有效地使关系线性化，使其适合进行相关性分析。由此产生的检验统计量将是 $T = \\rho_s(\\text{rank}(g_2), \\text{rank}(g_{1,R}))$。一个大的正值 $T$ 将支持该假说。\n\n3.  **空间自相关性 ($\\varepsilon(x)$):** 问题陈述数据是空间自相关的。这意味着样本 $(x_i, g(x_i))$ 不是独立同分布的 ($i.i.d.$)。用于检验相关系数显著性的标准统计检验（例如，使用 $r$ 或 $\\rho_s$ 的变换的 $t$ 检验）严重依赖于独立性假设。当正自相关违反此假设时，有效自由度远小于样本数减2，而草率地应用标准检验会导致 I 型错误率严重膨胀（即，我们将过于频繁地偶然发现显著相关）。为了正确评估显著性，我们必须为检验统计量 ($T = \\rho_s$) 生成一个能保留原始时间序列自相关结构的零分布。这可以通过**分块置换检验**来实现。在两个分布之间没有关联的原假设下，我们可以将一个分布相对于另一个进行洗牌。为了保留自相关性，我们不洗牌单个数据点，而是将被洗牌的序列（例如，秩变换后的 $g_2$ 分布）分成长度为 $b$ 的连续块，然后对这些块进行洗牌。块长 $b$ 的选择应能近似数据的自相关长度。这个过程创建了一组与原假设一致但具有与原始数据相同短程时间结构的代理数据集。\n\n**正确程序的总结：**\n1.  创建 $\\mathcal{T}_1$ 的翻转分布：$\\{g_1(1-x_i)\\}_{i=1}^n$。\n2.  计算 $\\mathcal{T}_1$ 的翻转分布和 $\\mathcal{T}_2$ 分布中数据的秩。记为 $\\{\\tilde{g}_1(1-x_i)\\}$ 和 $\\{\\tilde{g}_2(x_i)\\}$。\n3.  计算观察到的 Spearman 秩相关系数：$T_{\\mathrm{obs}} = \\rho_s\\big(\\{\\tilde{g}_1(1-x_i)\\}, \\{\\tilde{g}_2(x_i)\\}\\big)$。\n4.  从数据中估计一个合适的块长 $b$，例如，从其中一个序列的自相关函数中估计。\n5.  通过重复（$B$ 次，例如 $B \\ge 1000$）以下步骤生成一个零分布：\n    a. 通过对原始秩序列 $\\{\\tilde{g}_2(x_i)\\}$ 以长度为 $b$ 的块进行洗牌，创建一个置换后的秩序列 $\\{\\tilde{g}_2^*(x_i)\\}$。\n    b. 计算此重复样本的相关性：$T_j = \\rho_s\\big(\\{\\tilde{g}_1(1-x_i)\\}, \\{\\tilde{g}_2^*(x_i)\\}\\big)$。\n6.  将单尾 $p$ 值计算为模拟统计量中至少与观察值一样极端的比例：$p = (1 + \\#\\{T_j \\ge T_{\\mathrm{obs}}\\}) / (1 + B)$。\n7.  将 $p$ 值与显著性水平 $\\alpha=0.05$ 进行比较。如果 $p < 0.05$，则拒绝原假设。\n\n现在，我们对照这个推导出的程序来评估给出的选项。\n\n**逐项分析**\n\n**A. 对 $\\mathcal{T}_1$ 进行 $R(x)=1-x$ 翻转，在共享网格上对翻转后的 $g_1$ 和 $g_2$ 进行秩变换以获得秩 $\\tilde{g}_1(1-x_i)$ 和 $\\tilde{g}_2(x_i)$，计算 Spearman 秩相关系数 $T_{\\mathrm{obs}}=\\rho_s\\big(\\tilde{g}_1(1-x_i),\\tilde{g}_2(x_i)\\big)$，从经验自相关函数的第一个过零点估计自相关长度 $b$，通过对 $\\tilde{g}_2(x_i)$ 以长度为 $b$ 的连续块进行分块置换生成零分布（重复 $B \\ge 1000$ 次），计算置换 $p$ 值 $p=\\frac{1+\\#\\{T_b \\ge T_{\\mathrm{obs}}\\}}{1+B}$，当 $p < 0.05$ 时拒绝原假设。**\n\n该选项与从第一性原理推导出的程序完全匹配。它正确地指出了需要 (1) 翻转坐标轴，(2) 使用秩相关（Spearman 的 $\\rho_s$）来处理未知的单调函数 $h$，以及 (3) 使用分块置换来生成一个正确考虑空间自相关性的零分布。估计块长和计算 $p$ 值的方法是标准且合适的。\n**结论：正确。**\n\n**B. 在 $\\alpha=0.05$ 的水平上，应用双样本 Kolmogorov–Smirnov 检验来比较 $g_1$ 和 $g_2$ 的经验分布（不进行翻转）。如果分布相同的原假设未被拒绝，则断定存在与体轴反转一致的镜像对应关系。**\n\n这个程序在几个方面有根本性的缺陷。首先，它没有执行坐标轴翻转（$1-x$），而这是体轴反转假说的核心组成部分。其次，Kolmogorov-Smirnov (K-S) 检验比较的是值的整体分布，但没有说明它们的空间顺序。体轴反转假说是关于特定（翻转后）空间位置的值的对应关系。两个序列可以有完全相同的分布，但在空间上不相关。第三，变换 $h$ 和常数 $\\alpha, \\beta$ 通常会改变 $g_1(1-x)$ 的分布，所以即使假设成立，也没有理由期望 $g_1$ 和 $g_2$ 的分布是相同的。第四，标准的 K-S 检验假定样本是独立的，这与问题陈述的空间自相关性相违背。最后，从未能拒绝原假设就得出等价的结论是一个逻辑谬误，称为“接受原假设”。\n**结论：不正确。**\n\n**C. 计算 $g_1(x_i)$ 和 $g_2(x_i)$ 之间的 Pearson 相关系数 $r$（不进行翻转）。如果 $r < -0.8$ 且在自由度为 $n-2$ 的常规相关性 $t$ 检验下于 $\\alpha=0.05$ 水平上显著，则断定存在体轴反转。**\n\n这个选项在多个方面都是不正确的。首先，它没有翻转坐标轴。一个正确的检验应该在翻转后寻找正相关，而不是在不翻转的情况下寻找负相关。其次，它使用 Pearson 相关性，该方法测量*线性*关联。问题指定了一个通用的*单调*函数 $h$，这使得 Pearson 相关性不适用。第三，它使用标准的 $t$ 检验来判断显著性，该检验假定数据点是独立的。这与问题陈述中明确提出的空间自相关性相矛盾，使得该检验无效并容易产生假阳性。$r < -0.8$ 的阈值也是任意的。\n**结论：不正确。**\n\n**D. 通过普通最小二乘法拟合线性模型 $g_2(x_i)=\\alpha+\\beta g_1(x_i)+\\epsilon_i$（不进行翻转），然后在 $\\alpha=0.05$ 水平上检验 $H_0\\!:\\beta=0$ 对 $H_1\\!:\\beta < 0$。如果 $H_0$ 被拒绝，则断定存在指示体轴反转的镜像对应关系。**\n\n这也是不正确的。与选项 C 类似，它没有翻转坐标轴。它通过省略函数 $h$ 来假设一个线性关系，这与问题陈述相矛盾。此外，它建议使用普通最小二乘法 (OLS)，该方法假定误差是独立且同方差的（$\\epsilon_i$）。陈述的空间自相关性违反了独立性假设，使得与 OLS 相关的标准误和显著性检验无效。虽然可以使用广义最小二乘法 (GLS) 来处理自相关性，但由于错误地假设了线性关系，模型仍然是设定不当的。\n**结论：不正确。**", "answer": "$$\\boxed{A}$$", "id": "2564809"}, {"introduction": "为了将视野从单个基因或通路扩展到整个基因调控网络，计算方法是必不可少的。这项练习 [@problem_id:2564709] 提供了一个动手编程挑战，要求你实现一个算法，用于在以图结构表示的基因调控网络中寻找保守的“模块”。这项实践将生物学概念与其形式化的计算表示联系起来，这是现代系统生物学中的一项关键技能。", "problem": "一个基因调控网络被建模为一个有向图 $G = (V,E)$，该图基于一个有限的分类单元集 $T$。每个节点 $v \\in V$ 都标注有一个分类单元存在集 $P_V(v) \\subseteq T$，表示存在一个直系同源基因的分类单元。每条有向边 $e = (u \\rightarrow w) \\in E$ 都标注有一个分类单元存在集 $P_E(e) \\subseteq T$，表示该调控相互作用存在的分类单元。对于任何节点子集 $V_H \\subseteq V$，定义其导出子图为 $H = (V_H, E_H)$，其中 $E_H = \\{ (u \\rightarrow w) \\in E \\mid u \\in V_H, w \\in V_H \\}$。定义子图 $H$ 的支持度为\n$$\n\\mathrm{supp}(H) = \\left( \\bigcap_{v \\in V_H} P_V(v) \\right) \\cap \\left( \\bigcap_{e \\in E_H} P_E(e) \\right),\n$$\n并约定 $\\bigcap \\emptyset = T$。如果一个子图 $H$ 满足 $|\\mathrm{supp}(H)| \\ge k$，则称其为 $k$-保守的。如果一个子图 $H$ 的底层无向图是连通的，则称其为连通的。一个 $k$-保守模块是一个连通的、$k$-保守的导出子图。如果将任意节点 $x \\in V \\setminus V_H$ 添加到 $V_H \\cup \\{x\\}$ 上形成的导出子图不再保持 $k$-保守，则称该 $k$-保守模块是极大的。\n\n利用集合交集基数的基本反单调性，即对于任意集合族 $\\{A_i\\}_{i=1}^m$ 和任意额外集合 $B$，恒有 $|\\bigcap_{i=1}^m A_i \\cap B| \\le |\\bigcap_{i=1}^m A_i|$，设计并实现一个确定性的字典序贪心算法，按如下方式枚举候选的深度同源模块：\n\n- 对于每个 $|P_V(s)| \\ge k$ 的种子节点 $s \\in V$，初始化 $V_H \\leftarrow \\{s\\}$。\n- 重复尝试从候选邻居集 $C = \\{ x \\in V \\setminus V_H \\mid \\exists v \\in V_H \\text{ 使得 } (x \\rightarrow v) \\in E \\text{ 或 } (v \\rightarrow x) \\in E \\}$ 中一次添加一个节点，严格按照其整数标识符的升序扫描节点。对于一个候选节点 $x \\in C$，令 $V_H' = V_H \\cup \\{x\\}$，其导出子图为 $H' = (V_H', E_{H'})$。如果 $|\\mathrm{supp}(H')| \\ge k$，则接受该添加，设置 $V_H \\leftarrow V_H'$，并从更新后的候选集中的最小标识符重新开始扫描。如果没有候选节点可以在不违反阈值的情况下被添加，则停止；在 $V_H$ 上的最终导出子图就是从种子 $s$ 派生出的模块。\n- 处理完所有种子后，通过它们的节点集对模块进行去重，以获得此字典序贪心过程产生的不同极大模块的集合。\n\n实现这个精确的算法，并将其应用于以下测试套件。每个测试用例提供 $T$、$V$、$E$（带有存在集）和 $k$。节点标识符是非负整数。存在集由分类单元名称指定。在贪心添加过程中，必须使用底层无向图的连通性准则（由候选邻居的构建方式所定义）来测试连通性。每个测试用例的输出是算法产生的不同极大 $k$-保守模块的总数。您的程序应生成一行输出，其中包含一个由方括号括起来的逗号分隔列表的结果（例如，\"[1,2,3]\"）。\n\n测试套件：\n\n- 案例 $1$（正常路径）：\n  - $T = \\{\\mathrm{A}, \\mathrm{B}, \\mathrm{C}, \\mathrm{D}\\}$。\n  - $V = \\{0,1,2,3,4,5\\}$，节点存在集如下：\n    - $P_V(0) = \\{\\mathrm{A},\\mathrm{B},\\mathrm{C},\\mathrm{D}\\}$,\n    - $P_V(1) = \\{\\mathrm{A},\\mathrm{B},\\mathrm{C}\\}$,\n    - $P_V(2) = \\{\\mathrm{A},\\mathrm{C},\\mathrm{D}\\}$,\n    - $P_V(3) = \\{\\mathrm{B},\\mathrm{C}\\}$,\n    - $P_V(4) = \\{\\mathrm{A},\\mathrm{D}\\}$,\n    - $P_V(5) = \\{\\mathrm{C},\\mathrm{D}\\}$。\n  - 有向边及其存在集：\n    - $(0 \\rightarrow 1): \\{\\mathrm{A},\\mathrm{B},\\mathrm{C}\\}$,\n    - $(1 \\rightarrow 2): \\{\\mathrm{A},\\mathrm{C}\\}$,\n    - $(2 \\rightarrow 3): \\{\\mathrm{C}\\}$,\n    - $(0 \\rightarrow 4): \\{\\mathrm{A},\\mathrm{D}\\}$,\n    - $(4 \\rightarrow 2): \\{\\mathrm{A},\\mathrm{D}\\}$,\n    - $(5 \\rightarrow 2): \\{\\mathrm{C},\\mathrm{D}\\}$,\n    - $(3 \\rightarrow 5): \\{\\mathrm{C}\\}$,\n    - $(1 \\rightarrow 3): \\{\\mathrm{B},\\mathrm{C}\\}$,\n    - $(4 \\rightarrow 5): \\{\\mathrm{D}\\}$。\n  - 阈值 $k = 2$。\n\n- 案例 $2$（保守性严格度的边界情况）：\n  - 与案例 $1$ 相同的 $T$、$V$ 和 $E$。\n  - 阈值 $k = 3$。\n\n- 案例 $3$（仅有单元素模块的边缘情况）：\n  - $T = \\{\\mathrm{A}, \\mathrm{B}\\}$。\n  - $V = \\{0,1,2\\}$，节点存在集如下：\n    - $P_V(0) = \\{\\mathrm{A},\\mathrm{B}\\}$,\n    - $P_V(1) = \\{\\mathrm{A}\\}$,\n    - $P_V(2) = \\{\\mathrm{B}\\}$。\n  - 有向边及其存在集：\n    - $(0 \\rightarrow 1): \\{\\mathrm{A}\\}$,\n    - $(0 \\rightarrow 2): \\{\\mathrm{B}\\}$。\n  - 阈值 $k = 2$。\n\n您的程序必须为每个测试用例计算由指定算法找到的不同极大 $k$-保守模块的数量，并打印一行包含这三个整数的、按顺序排列的、由方括号括起来的逗号分隔列表。", "solution": "问题陈述已经过严格分析，被认为是有效的。它在计算系统生物学领域，特别是在鉴定保守基因调控模块方面，具有科学依据。该问题在数学上是适定的，为所有组成部分提供了无歧义的定义——包括图模型、节点和边的标注、支持度度量 $\\mathrm{supp}(H)$，以及成为一个 $k$-保守模块的属性。为测试用例提供了所有必要的数据和约束，构成了一个自洽且可解的计算任务。指定的算法是确定性的，确保了唯一的解。\n\n任务是实现一个特定的字典序贪心算法，用于在基因调控网络中识别候选的深度同源模块。支撑这种贪心方法的基本原理是集合交集基数的反单调性。对于一个集合族 $\\{A_i\\}$，当一个新的集合 $B$ 加入交集时，其交集的基数不会增加：$|\\bigcap A_i \\cap B| \\le |\\bigcap A_i|$。在问题的背景下，子图 $H'$ 的支持度 $\\mathrm{supp}(H')$ 是其节点和边的存在集的交集。如果我们将一个子图 $H$ 扩展为一个更大的子图 $H''$（通过添加节点或边），那么 $H''$ 的支持度是一个更大集合族的交集。因此，$\\mathrm{supp}(H'') \\subseteq \\mathrm{supp}(H)$，这意味着 $|\\mathrm{supp}(H'')| \\le |\\mathrm{supp}(H)|$。这个性质确保了如果通过添加一个新节点形成的潜在子图未能通过 $k$-保守性测试（即其支持度太小），那么该子图的任何进一步扩展都永远无法满足该标准。这验证了在违反保守性阈值后立即终止扩展路径的贪心策略。\n\n该算法将按照以下结构化步骤实现：\n\n1.  **数据表示**：分类单元集 $T$ 和所有存在集（节点的 $P_V(v)$ 和边的 $P_E(e)$）将表示为 Python 中的 `set` 对象，以便进行高效的交集操作。图 $G=(V, E)$ 将使用一种邻接结构来存储，该结构允许高效查找一个节点的所有邻居（包括入度和出度），这是识别用于模块扩展的候选节点所必需的。\n\n2.  **种子识别**：算法从每个“种子”节点启动搜索过程。如果一个节点 $s \\in V$ 本身能形成一个 $k$-保守模块，则它是一个有效的种子。在 $V_H=\\{s\\}$ 上的单节点导出子图 $H_s$ 的边集为空，即 $E_H=\\emptyset$。根据空交集产生全集 $T$ 的约定，其支持度为 $\\mathrm{supp}(H_s) = P_V(s) \\cap T = P_V(s)$。因此，一个节点 $s$ 是有效种子的充要条件是 $|P_V(s)| \\ge k$。所有这样的种子节点将被识别并按其整数标识符的升序处理，以确保确定性行为，尽管问题并未强制要求处理种子的特定顺序。\n\n3.  **贪心模块扩展**：对于每个种子节点 $s$，一个模块将迭代地增长。\n    - **初始化**：模块以节点集 $V_H = \\{s\\}$ 初始化，其支持度为 `supp_H` $= P_V(s)$。\n    - **迭代**：算法进入一个循环，只要模块可以扩展就继续。在每次迭代中，它识别一个候选节点集 $C$。一个节点 $x \\in V \\setminus V_H$ 是候选节点，如果它与当前模块 $V_H$ 中的至少一个节点相邻。这种构建方式确保了最终的模块保持连通。\n    - **候选评估**：$C$ 中的候选节点将严格按照其整数标识符的字典序升序进行评估。对于每个候选节点 $x$，考虑在顶点集 $V'_H = V_H \\cup \\{x\\}$ 上的一个潜在新模块 $H'$。通过取当前模块的支持度 `supp_H`，并与新节点的存在集 $P_V(x)$ 以及所有新产生的边的存在集进行交集，可以高效地计算其支持度。这些新边是连接 $x$ 与已在 $V_H$ 中的节点的边。\n    - **接受与重启**：如果潜在模块的支持度 $|\\mathrm{supp}(H')|$ 大于或等于阈值 $k$，则接受候选节点 $x$。模块被更新（$V_H \\leftarrow V'_H$，`supp_H` $\\leftarrow \\mathrm{supp}(H')$），并且候选评估循环立即以新的、更大的模块重新开始。这种“首次适应”的贪心选择是该算法定义的关键。\n    - **终止**：如果在对所有排序后的候选节点进行完整遍历后，没有节点可以在不违反 $k$-保守性准则的情况下被添加，则当前种子的扩展循环终止。生成的模块 $V_H$ 根据算法的定义被认为是极大的。\n\n4.  **去重与最终计数**：每个生成的模块的节点集将被存储。由于不同的种子可能导致相同的最终模块，这些集合将以一种允许自动去重的方式存储，例如，通过将节点集的 `frozenset` 表示添加到主 `set` 中。每个测试用例的最终结果是找到的唯一模块的总数。\n\n这个详细的、基于原则的设计将被转化为一个 Python 程序，该程序精确遵循指定的逻辑和数据，从而保证对问题给出正确的解决方案。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define, run, and print results for all test cases.\n    \"\"\"\n    \n    # Test Case 1\n    case1 = {\n        \"T\": {\"A\", \"B\", \"C\", \"D\"},\n        \"V\": list(range(6)),\n        \"P_V\": [\n            {\"A\", \"B\", \"C\", \"D\"},  # Node 0\n            {\"A\", \"B\", \"C\"},      # Node 1\n            {\"A\", \"C\", \"D\"},      # Node 2\n            {\"B\", \"C\"},           # Node 3\n            {\"A\", \"D\"},           # Node 4\n            {\"C\", \"D\"},           # Node 5\n        ],\n        \"E\": {\n            (0, 1): {\"A\", \"B\", \"C\"},\n            (1, 2): {\"A\", \"C\"},\n            (2, 3): {\"C\"},\n            (0, 4): {\"A\", \"D\"},\n            (4, 2): {\"A\", \"D\"},\n            (5, 2): {\"C\", \"D\"},\n            (3, 5): {\"C\"},\n            (1, 3): {\"B\", \"C\"},\n            (4, 5): {\"D\"},\n        },\n        \"k\": 2,\n    }\n\n    # Test Case 2\n    case2 = {\n        \"T\": case1[\"T\"],\n        \"V\": case1[\"V\"],\n        \"P_V\": case1[\"P_V\"],\n        \"E\": case1[\"E\"],\n        \"k\": 3,\n    }\n\n    # Test Case 3\n    case3 = {\n        \"T\": {\"A\", \"B\"},\n        \"V\": list(range(3)),\n        \"P_V\": [\n            {\"A\", \"B\"},  # Node 0\n            {\"A\"},      # Node 1\n            {\"B\"},      # Node 2\n        ],\n        \"E\": {\n            (0, 1): {\"A\"},\n            (0, 2): {\"B\"},\n        },\n        \"k\": 2,\n    }\n\n    test_cases = [case1, case2, case3]\n    results = []\n\n    for case in test_cases:\n        result = find_modules(case[\"T\"], case[\"V\"], case[\"P_V\"], case[\"E\"], case[\"k\"])\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef find_modules(T, V_ids, P_V, E, k):\n    \"\"\"\n    Implements the specified lexicographic-greedy algorithm to find k-conserved modules.\n    \n    Args:\n        T (set): The set of all taxa.\n        V_ids (list): A list of integer node identifiers.\n        P_V (list): A list where P_V[i] is the presence set for node i.\n        E (dict): A dictionary where keys are edge tuples (u, v) and values are presence sets.\n        k (int): The conservation threshold.\n    \n    Returns:\n        int: The number of distinct maximal k-conserved modules found.\n    \"\"\"\n    \n    all_neighbors = {v: set() for v in V_ids}\n    for u, w in E:\n        all_neighbors[u].add(w)\n        all_neighbors[w].add(u)\n\n    found_modules = set()\n\n    seed_nodes = sorted([v for v in V_ids if len(P_V[v]) >= k])\n\n    for seed in seed_nodes:\n        V_H = {seed}\n        current_support = P_V[seed]\n\n        while True:\n            added_node_in_iteration = False\n            \n            candidate_neighbors = set()\n            for node in V_H:\n                candidate_neighbors.update(all_neighbors[node])\n            candidate_neighbors -= V_H\n            \n            sorted_candidates = sorted(list(candidate_neighbors))\n            \n            for candidate in sorted_candidates:\n                # Calculate the support for the potential new module\n                potential_support = current_support.intersection(P_V[candidate])\n                \n                # If potential support is already too small, no need to check edges\n                if len(potential_support)  k:\n                    continue\n\n                for node_in_module in V_H:\n                    if (node_in_module, candidate) in E:\n                        potential_support = potential_support.intersection(E[(node_in_module, candidate)])\n                    if (candidate, node_in_module) in E:\n                        potential_support = potential_support.intersection(E[(candidate, node_in_module)])\n                \n                if len(potential_support) >= k:\n                    V_H.add(candidate)\n                    current_support = potential_support\n                    added_node_in_iteration = True\n                    break  # Restart candidate search with the new_V_H\n            \n            if not added_node_in_iteration:\n                break  # Module is maximal for this seed, stop expansion\n\n        found_modules.add(frozenset(V_H))\n\n    return len(found_modules)\n\nsolve()\n```", "id": "2564709"}]}