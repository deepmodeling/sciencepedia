{"hands_on_practices": [{"introduction": "“健康与疾病的发育起源”（DOHaD）范式的一个核心概念是，母体环境信号能够“编程”胎儿的发育轨迹。本练习通过一个简化的药代动力学和受体结合模型，将这一抽象概念具体化。通过计算在特定母体皮质醇水平下胎儿糖皮质激素受体的激活分数，我们将亲手实践如何将生理过程量化为细胞层面的响应，这是理解发育编程机制的基础。[@problem_id:2629719]", "problem": "在健康与疾病的发育起源 (DOHaD) 框架下，考虑一个简化的胎盘-胎儿药代动力学和受体结合模型，用于分析胎儿的皮质醇暴露和糖皮质激素受体激活。假设以下有科学依据的要素作为您分析的基础：(i) 一个具有一级输入和清除的充分混合胎儿室的稳态质量平衡，以及 (ii) 由质量作用定律决定的平衡状态下的配体-受体结合，其中受体激活与被配体占据的受体分数成正比。\n\n一位母亲的游离血浆皮质醇浓度为 $50\\,\\text{nM}$。在胎盘界面，11-β-羟基类固醇脱氢酶2型 (11$\\beta$-HSD2) 将皮质醇转化为可的松，因此在当前的血流和酶促条件下，逃避转化并保持为皮质醇的皮质醇分子的净分数为 $0.08$。游离皮质醇穿过胎盘进入胎儿室，其有效一级转运速率常数为 $0.02\\,\\text{min}^{-1}$（相对于胎儿分布容积定义），并以一级清除速率常数 $0.005\\,\\text{min}^{-1}$ 从胎儿室中清除。假设在这些条件下，内源性胎儿皮质醇的产生可以忽略不计，并且可的松不与胎儿糖皮质激素受体结合。胎儿糖皮质激素受体 (GR) 对皮质醇的解离常数 $K_d$ 为 $10\\,\\text{nM}$。\n\n仅使用稳态房室质量平衡和质量作用定律的受体-配体结合，计算预期的稳态下被皮质醇占据的胎儿GR的分数（即，作为无单位分数的受体激活）。将您的最终答案表示为一个四舍五入到三位有效数字的无单位数。", "solution": "该问题陈述已经过严格验证，并且被认为是自洽的、科学基础扎实，建立在药代动力学和内分泌学的既定原则之上，并且在数学上是适定的。它提出了一个可以使用标准模型解决的问题。我们现在开始进行求解。\n\n该问题要求计算稳态下被皮质醇占据的胎儿糖皮质激素受体 (GR) 的分数。这是一个分为两部分的问题。首先，我们必须确定胎儿室中皮质醇的稳态浓度 $[C_f]_{ss}$。其次，我们使用该浓度根据质量作用定律计算受体占有率。\n\n让我们定义问题陈述中的变量：\n- 母体游离血浆皮质醇浓度, $C_{m,u} = 50\\,\\text{nM}$。\n- 逃脱11$\\beta$-HSD2胎盘代谢的皮质醇分数, $f_{escape} = 0.08$。\n- 从胎盘到胎儿的一级转运速率常数, $k_{in} = 0.02\\,\\text{min}^{-1}$。\n- 从胎儿清除的一级清除速率常数, $k_{out} = 0.005\\,\\text{min}^{-1}$。\n- 胎儿GR对皮质醇的解离常数, $K_d = 10\\,\\text{nM}$。\n- 时间 $t$ 时的胎儿皮质醇浓度, $C_f(t)$。\n\n在胎盘屏障母体侧可用于转运的皮质醇有效浓度是母体游离浓度乘以逃脱酶促转化的分数：\n$$ C_{transport} = C_{m,u} \\times f_{escape} $$\n\n基于充分混合室的假设，胎儿皮质醇浓度 $C_f(t)$ 的动态变化由一个一阶线性常微分方程描述。$C_f(t)$ 的变化率是皮质醇输入速率与其清除速率之差：\n$$ \\frac{dC_f(t)}{dt} = (\\text{Rate of Input}) - (\\text{Rate of Clearance}) $$\n\n输入速率与有效转运浓度 $C_{transport}$ 成正比，比例常数为 $k_{in}$。清除速率与当前胎儿浓度 $C_f(t)$ 成正比，比例常数为 $k_{out}$。\n$$ \\frac{dC_f(t)}{dt} = k_{in} (C_{m,u} \\cdot f_{escape}) - k_{out} C_f(t) $$\n\n在稳态下，浓度不再随时间变化，因此 $\\frac{dC_f}{dt} = 0$。我们将稳态胎儿浓度表示为 $[C_f]_{ss}$。\n$$ 0 = k_{in} (C_{m,u} \\cdot f_{escape}) - k_{out} [C_f]_{ss} $$\n\n我们现在可以求解 $[C_f]_{ss}$：\n$$ k_{out} [C_f]_{ss} = k_{in} (C_{m,u} \\cdot f_{escape}) $$\n$$ [C_f]_{ss} = \\frac{k_{in}}{k_{out}} (C_{m,u} \\cdot f_{escape}) $$\n\n代入给定值：\n$$ [C_f]_{ss} = \\frac{0.02\\,\\text{min}^{-1}}{0.005\\,\\text{min}^{-1}} (50\\,\\text{nM} \\cdot 0.08) $$\n$$ [C_f]_{ss} = 4 \\cdot (4\\,\\text{nM}) $$\n$$ [C_f]_{ss} = 16\\,\\text{nM} $$\n\n现在，我们进行第二部分：计算受体占有率。皮质醇（配体, $L$）与糖皮质激素受体（$R$）的结合是一个平衡过程：\n$$ L + R \\rightleftharpoons LR $$\n解离常数 $K_d$ 由平衡时的质量作用定律定义：\n$$ K_d = \\frac{[L][R]}{[LR]} $$\n这里，游离配体浓度是稳态胎儿皮质醇浓度，即 $[L] = [C_f]_{ss}$。\n\n已占受体分数 $\\theta$ 定义为配体-受体复合物浓度 $[LR]$ 除以总受体浓度 $[R]_{total} = [R] + [LR]$。\n$$ \\theta = \\frac{[LR]}{[R]_{total}} = \\frac{[LR]}{[R] + [LR]} $$\n\n根据 $K_d$ 的定义，我们可以用 $[LR]$ 和 $[L]$ 来表示游离受体浓度 $[R]$：\n$$ [R] = \\frac{K_d [LR]}{[L]} $$\n\n将此代入 $\\theta$ 的表达式中：\n$$ \\theta = \\frac{[LR]}{\\frac{K_d [LR]}{[L]} + [LR]} $$\n分子和分母中的项 $[LR]$ 可以消去：\n$$ \\theta = \\frac{1}{\\frac{K_d}{[L]} + 1} = \\frac{[L]}{[L] + K_d} $$\n这是著名的希尔-朗缪尔方程。\n\n我们现在将计算出的稳态胎儿皮质醇浓度 $[C_f]_{ss}$ 代入 $[L]$，并代入给定的 $K_d$ 值：\n$$ \\theta = \\frac{[C_f]_{ss}}{[C_f]_{ss} + K_d} $$\n$$ \\theta = \\frac{16\\,\\text{nM}}{16\\,\\text{nM} + 10\\,\\text{nM}} = \\frac{16}{26} = \\frac{8}{13} $$\n\n为了以四舍五入到三位有效数字的无单位数形式提供最终答案，我们计算其小数值：\n$$ \\theta = \\frac{8}{13} \\approx 0.6153846... $$\n四舍五入到三位有效数字得到 $0.615$。这表示在指定的稳态条件下被激活的胎儿糖皮质激素受体的分数。", "answer": "$$\\boxed{0.615}$$", "id": "2629719"}, {"introduction": "在DOHaD研究中，从观察性数据中推断因果关系是一项核心挑战，因为变量之间存在复杂的相互作用。本练习通过一个结构模型，揭示了一个在分析中极易遇到的陷阱——对撞偏倚（collider bias），特别是在调整像出生体重这样的中间变量时。通过亲手计算这种偏倚的大小，我们将更深刻地理解为何简单的统计关联不等于因果关系，以及在设计和解释DOHaD研究时保持警惕的重要性。[@problem_id:2629687]", "problem": "在健康与疾病的发育起源（DOHaD）框架下，考虑一个线性高斯结构模型，该模型表示产前吸烟暴露对成年高血压风险的影响，其中出生体重是一个对撞因子（collider）。令产前吸烟暴露表示为 $S$，一个未测量的胎儿生长决定因素表示为 $U$，出生体重表示为 $B$，成年高血压（建模为连续倾向性）表示为 $H$。假设以下数据生成过程基于标准的线性结构方程模型，该模型具有独立的高斯误差和独立的外生原因：\n$$\nS \\sim \\mathcal{N}(0,1), \\quad U \\sim \\mathcal{N}(0,1), \\quad \\varepsilon_{B} \\sim \\mathcal{N}(0,1), \\quad \\varepsilon_{H} \\sim \\mathcal{N}(0,1),\n$$\n其中 $S$、$U$、$\\varepsilon_{B}$ 和 $\\varepsilon_{H}$ 相互独立。结构方程为\n$$\nB \\;=\\; \\alpha\\,S \\;+\\; \\gamma\\,U \\;+\\; \\varepsilon_{B}, \\qquad H \\;=\\; \\delta\\,U \\;+\\; \\varepsilon_{H}.\n$$\n这些参数编码了以下与DOHaD一致的生物学方向：产前吸烟降低出生体重（$\\alpha  0$），未测量的胎儿生长决定因素增加出生体重（$\\gamma  0$），并且同一决定因素也增加成年高血压倾向性（$\\delta  0$）。令参数值为\n$$\n\\alpha \\;=\\; -0.5,\\qquad \\gamma \\;=\\; 0.6,\\qquad \\delta \\;=\\; 0.5.\n$$\n\n一位研究人员对 $H$ 关于 $(S,B)$ 进行线性回归拟合，从而以对撞因子 $B$ 为条件。将由此条件化引入的偏差定义为该模型中 $S$ 的调整后回归系数减去 $S$ 对 $H$ 的真实因果效应。在给定的结构模型下，$S$ 对 $H$ 的真实因果效应为零。仅使用协方差、方差和多元回归的最小二乘法正规方程的定义，计算此对撞因子调整偏差的数值。\n\n将最终答案报告为一个无单位的实数，并四舍五入到 $4$ 位有效数字。", "solution": "该问题要求在一个特定的线性高斯结构模型中计算对撞因子调整偏差。该偏差定义为成年高血压 $H$ 对产前吸烟暴露 $S$ 和出生体重 $B$ 的多元线性回归中 $S$ 的回归系数。已知 $S$ 对 $H$ 的真实因果效应为零，因此偏差等于估计的回归系数本身。\n\n本题将通过应用从正规方程导出的普通最小二乘法（OLS）系数公式来解决。设线性回归模型为 $H = \\beta_0 + \\beta_S S + \\beta_B B + \\epsilon$，其中 $\\epsilon$ 是误差项。由于所有外生变量 $S$、$U$、$\\varepsilon_B$ 和 $\\varepsilon_H$ 均来自均值为 $0$ 的正态分布，因此得到的变量 $B$ 和 $H$ 的均值也为 $0$。因此，截距 $\\beta_0$ 为 $0$，我们可以使用中心化变量进行计算。\n\n系数 $\\boldsymbol{\\beta} = \\begin{pmatrix} \\beta_S \\\\ \\beta_B \\end{pmatrix}$ 的OLS估计量由正规方程的解给出：\n$$\n\\mathbf{X}^T\\mathbf{X} \\boldsymbol{\\beta} = \\mathbf{X}^T\\mathbf{y}\n$$\n就方差和协方差而言，对于预测变量 $S$ 和 $B$ 以及结果变量 $H$，该方程组为：\n$$\n\\begin{pmatrix} \\text{Var}(S)  \\text{Cov}(S, B) \\\\ \\text{Cov}(B, S)  \\text{Var}(B) \\end{pmatrix}\n\\begin{pmatrix} \\beta_S \\\\ \\beta_B \\end{pmatrix}\n=\n\\begin{pmatrix} \\text{Cov}(S, H) \\\\ \\text{Cov}(B, H) \\end{pmatrix}\n$$\n我们的目标是求出 $\\beta_S$。我们必须首先使用给定的结构方程和参数值计算所需的方差和协方差项。\n\n给定的数据生成过程是：\n$S \\sim \\mathcal{N}(0,1)$，$U \\sim \\mathcal{N}(0,1)$，$\\varepsilon_{B} \\sim \\mathcal{N}(0,1)$，$\\varepsilon_{H} \\sim \\mathcal{N}(0,1)$。\n$S$、$U$、$\\varepsilon_{B}$ 和 $\\varepsilon_{H}$ 相互独立。\n结构方程为：\n$B = \\alpha S + \\gamma U + \\varepsilon_{B}$\n$H = \\delta U + \\varepsilon_{H}$\n参数值为 $\\alpha = -0.5$，$\\gamma = 0.6$，$\\delta = 0.5$。\n\n根据分布假设，我们有：\n$\\text{Var}(S) = 1$\n$\\text{Var}(U) = 1$\n$\\text{Var}(\\varepsilon_B) = 1$\n$\\text{Var}(\\varepsilon_H) = 1$\n\n现在，我们为正规方程计算必要的（协）方差项。\n\n1.  $\\text{Var}(S)$: 给定为 $\\text{Var}(S) = 1$。\n\n2.  $\\text{Cov}(S, B)$:\n    $\\text{Cov}(S, B) = \\text{Cov}(S, \\alpha S + \\gamma U + \\varepsilon_{B})$\n    利用协方差的线性和 $S$、$U$、$\\varepsilon_B$ 的相互独立性：\n    $\\text{Cov}(S, B) = \\alpha \\text{Cov}(S, S) + \\gamma \\text{Cov}(S, U) + \\text{Cov}(S, \\varepsilon_{B})$\n    $\\text{Cov}(S, B) = \\alpha \\text{Var}(S) + \\gamma(0) + 0 = \\alpha(1) = \\alpha$。\n\n3.  $\\text{Var}(B)$:\n    $\\text{Var}(B) = \\text{Var}(\\alpha S + \\gamma U + \\varepsilon_{B})$\n    由于 $S$、$U$ 和 $\\varepsilon_B$ 相互独立：\n    $\\text{Var}(B) = \\alpha^2 \\text{Var}(S) + \\gamma^2 \\text{Var}(U) + \\text{Var}(\\varepsilon_{B})$\n    $\\text{Var}(B) = \\alpha^2(1) + \\gamma^2(1) + 1 = \\alpha^2 + \\gamma^2 + 1$。\n\n4.  $\\text{Cov}(S, H)$:\n    $\\text{Cov}(S, H) = \\text{Cov}(S, \\delta U + \\varepsilon_{H})$\n    利用协方差的线性和变量的独立性：\n    $\\text{Cov}(S, H) = \\delta \\text{Cov}(S, U) + \\text{Cov}(S, \\varepsilon_{H}) = \\delta(0) + 0 = 0$。\n    这证实了真实的因果效应为零，因为从 $S$到 $H$ 没有未被阻断的路径。\n\n5.  $\\text{Cov}(B, H)$:\n    $\\text{Cov}(B, H) = \\text{Cov}(\\alpha S + \\gamma U + \\varepsilon_{B}, \\delta U + \\varepsilon_{H})$\n    利用协方差的双线性展开：\n    $\\text{Cov}(B, H) = \\text{Cov}(\\alpha S, \\delta U) + \\text{Cov}(\\alpha S, \\varepsilon_{H}) + \\text{Cov}(\\gamma U, \\delta U) + \\text{Cov}(\\gamma U, \\varepsilon_{H}) + \\text{Cov}(\\varepsilon_{B}, \\delta U) + \\text{Cov}(\\varepsilon_{B}, \\varepsilon_{H})$\n    由于 $S$、$U$、$\\varepsilon_B$ 和 $\\varepsilon_H$ 相互独立，所有涉及不同变量之间协方差的项都为零。\n    $\\text{Cov}(B, H) = \\alpha\\delta\\text{Cov}(S, U) + \\alpha\\text{Cov}(S, \\varepsilon_{H}) + \\gamma\\delta\\text{Cov}(U, U) + \\gamma\\text{Cov}(U, \\varepsilon_{H}) + \\delta\\text{Cov}(\\varepsilon_{B}, U) + \\text{Cov}(\\varepsilon_{B}, \\varepsilon_{H})$\n    $\\text{Cov}(B, H) = 0 + 0 + \\gamma\\delta\\text{Var}(U) + 0 + 0 + 0 = \\gamma\\delta(1) = \\gamma\\delta$。\n\n现在，我们将这些导出的项代入正规方程：\n$$\n\\begin{pmatrix} 1  \\alpha \\\\ \\alpha  \\alpha^2 + \\gamma^2 + 1 \\end{pmatrix}\n\\begin{pmatrix} \\beta_S \\\\ \\beta_B \\end{pmatrix}\n=\n\\begin{pmatrix} 0 \\\\ \\gamma \\delta \\end{pmatrix}\n$$\n这代表了以下两个线性方程组：\n1) $1 \\cdot \\beta_S + \\alpha \\cdot \\beta_B = 0$\n2) $\\alpha \\cdot \\beta_S + (\\alpha^2 + \\gamma^2 + 1) \\cdot \\beta_B = \\gamma \\delta$\n\n从方程（1），我们得到 $\\beta_S = -\\alpha \\beta_B$。\n将 $\\beta_S$ 的这个表达式代入方程（2）：\n$\\alpha(-\\alpha \\beta_B) + (\\alpha^2 + \\gamma^2 + 1) \\beta_B = \\gamma \\delta$\n$-\\alpha^2 \\beta_B + \\alpha^2 \\beta_B + (\\gamma^2 + 1) \\beta_B = \\gamma \\delta$\n$(\\gamma^2 + 1) \\beta_B = \\gamma \\delta$\n$\\beta_B = \\frac{\\gamma \\delta}{\\gamma^2 + 1}$\n\n现在，我们求出 $\\beta_S$，它代表了对撞因子调整偏差：\n$\\beta_S = -\\alpha \\beta_B = -\\alpha \\left( \\frac{\\gamma \\delta}{\\gamma^2 + 1} \\right) = \\frac{-\\alpha \\gamma \\delta}{1 + \\gamma^2}$。\n\n最后一步是代入给定的数值：$\\alpha = -0.5$，$\\gamma = 0.6$，和 $\\delta = 0.5$。\n$\\beta_S = \\frac{-(-0.5)(0.6)(0.5)}{1 + (0.6)^2}$\n$\\beta_S = \\frac{0.5 \\times 0.6 \\times 0.5}{1 + 0.36}$\n$\\beta_S = \\frac{0.15}{1.36}$\n\n计算数值：\n$\\beta_S = 0.1102941176...$\n四舍五入到 $4$ 位有效数字，我们得到 $0.1103$。这个非零的 $\\beta_S$ 值是由以对撞因子 $B$ 为条件所引起的偏差，这通过它们对 $B$ 的共同原因 $U$ 在 $S$ 和 $H$ 之间打开了一条伪路径。", "answer": "$$\\boxed{0.1103}$$", "id": "2629687"}, {"introduction": "现代DOHaD研究，特别是表观基因组范围关联研究（EWAS），会产生海量数据，同时检验成千上万个假设。这种大规模检验极大地增加了发现假阳性关联的风险。本练习将指导你从头开始实现Benjamini-Hochberg程序，这是一种控制错误发现率（FDR）的关键统计方法，是处理高维生物医学数据的必备技能。[@problem_id:2629748]", "problem": "您正在“健康与疾病的发育起源 (DOHaD)”背景下分析一项“全表观基因组关联分析 (EWAS)”，其中每个胞嘧啶-磷酸-鸟嘌呤 (CpG) 位点都针对与早期发育暴露和晚年健康结局的关联性进行检验。请将输入视为一个纯数学的p值向量，并实现Benjamini–Hochberg步进式多重检验程序，以在指定的名义水平上控制预期的错误发现率。您的任务是编写一个程序，为每个提供的测试用例，根据给定的p值向量和名义水平 $ \\alpha $ 计算以下几个量：\n- 根据Benjamini–Hochberg规则的总拒绝数，记为 $ r $。\n- Benjamini–Hochberg阈值 $ t_{\\mathrm{BH}} $，它定义了被拒绝的p值中的最大值。\n- 所有假设中的最小调整后p值（q值），记为 $ \\min(q) $。\n- 所有假设中的最大调整后p值（q值），记为 $ \\max(q) $。\n- 一个布尔值，表示当调整后p值（q值）按原始p值升序排列时，是否形成一个非递减序列。\n\n关于p值和错误发现率程序的假设与约束：\n- 给定 $ m $ 个独立的假设检验，其有效的p值在区间 $ [0,1] $ 内。\n- Benjamini–Hochberg程序应严格按照具有单调调整后p值的步进规则实现。不要使用任何快捷方式或预打包的黑箱函数。您的实现必须直接计算排序后的p值，确定步进截断点，并构建单调的调整后p值。\n\n输入由以下三个测试用例组成的测试套件隐式定义。对于每个用例，计算上述输出。名义水平用 $ \\alpha $ 表示（以纯数字形式，而非百分比）。不涉及物理单位。\n\n测试用例：\n1) 一个小的、明确的类EWAS向量，包含相同值和边界值，以测试稳定性。使用 $ m = 10 $，$ \\alpha = 0.05 $，以及p值向量\n$$\n[\\,0.002,\\;0.5,\\;0.04,\\;0.8,\\;0.0001,\\;1.0,\\;0.04,\\;0.2,\\;0.0,\\;0.95\\,].\n$$\n\n2) 一个大的EWAS规模向量，模拟 $ m = 100{,}000 $ 个CpG检验，其中混合了确定性的类零假设和类备择假设的p值，以模拟在DOHaD EWAS中观察到的信号异质性。使用 $ m = 100{,}000 $ 和 $ \\alpha = 0.05 $。按如下方式为索引 $ i = 1,2,\\dots,m $ 确定性地构建p值：\n- 令\n$$\nu_i = \\operatorname{frac}\\!\\big(i\\sqrt{2} + \\sqrt{3}\\big),\n$$\n其中 $ \\operatorname{frac}(x) $ 是 $ x $ 的小数部分。\n- 定义一个确定性的索引子集 $ \\mathcal{A} = \\{\\, i \\in \\{1,\\dots,m\\} \\mid i \\text{ 可被 } 50 \\text{ 整除} \\,\\} $。\n- 设置\n$$\np_i =\n\\begin{cases}\nu_i^4,  \\text{如果 } i \\in \\mathcal{A},\\\\\nu_i,  \\text{否则}.\n\\end{cases}\n$$\n\n3) 无发现的边缘案例。使用 $ m = 50 $，$ \\alpha = 0.05 $，以及对于所有 $ i \\in \\{1,\\dots,m\\} $ 均为常数p值向量 $ p_i = 1.0 $。\n\n输出规范：\n- 对于每个测试用例，您的程序必须返回一个列表 $ [\\,r,\\; t_{\\mathrm{BH}},\\; \\min(q),\\; \\max(q),\\; \\text{is\\_monotone}\\,] $，其中 $ r $ 是一个整数，$ t_{\\mathrm{BH}} $、$ \\min(q) $ 和 $ \\max(q) $ 是四舍五入到六位小数的实数，而 $ \\text{is\\_monotone} $ 是一个布尔值，指示按p值升序排列的调整后p值（q值）序列是否非递减。\n- 将所有三个测试用例的结果聚合到单行输出中，该输出包含一个用方括号括起来的逗号分隔列表，其中每个测试用例的结果本身也格式化为用方括号括起来的逗号分隔列表。例如，总输出格式必须完全是\n$$\n[\\,[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot]\\,].\n$$\n- 角度、物理单位和百分比不适用。所有数值答案必须报告为纯数字，所有实数需四舍五入到六位小数。", "solution": "所提供的问题具有科学依据、适定且客观。它提出了一个与发育生物学和表观遗传学特定领域相关的标准统计任务。因此，该问题被认为是有效的。我将继续提供解决方案。\n\n该问题要求实现用于在多重假设检验中控制错误发现率（FDR）的Benjamini–Hochberg（BH）程序。这是基因组学和表观基因组学中的一项基本技术，特别是在“健康与疾病的发育起源（DOHaD）”框架下的全表观基因组关联分析（EWAS）中，其中成千上万个CpG位点被同时检验。\n\n设有 $m$ 个独立的零假设 $H_1, H_2, \\dots, H_m$，以及相应的p值 $p_1, p_2, \\dots, p_m$。目标是在指定的名义水平 $\\alpha$ 下，控制被错误拒绝的零假设（即错误发现）的预期比例。\n\nBH程序如下：\n1. 将 $m$ 个p值从小到大排序：$p_{(1)} \\le p_{(2)} \\le \\dots \\le p_{(m)}$。\n2. 找到最大的整数 $k$（我们记为 $r$），使得第 $k$ 个排序后的p值满足以下条件：\n$$\np_{(k)} \\le \\frac{k}{m} \\alpha\n$$\n3. 如果存在这样的 $k$，则拒绝与p值 $p_{(1)}, p_{(2)}, \\dots, p_{(r)}$ 相对应的 $r$ 个零假设。如果不存在这样的 $k$，则不拒绝任何假设，且 $r=0$。\n\n问题要求为每个测试用例计算五个量：\n- 总拒绝数 $r$。\n- 拒绝阈值 $t_{\\mathrm{BH}}$，定义为被拒绝集合中的最大p值，即 $p_{(r)}$。如果 $r=0$，则 $t_{\\mathrm{BH}}$ 取为 $0.0$。\n- 最小和最大调整后p值（q值）。\n- 对调整后p值单调性的布尔检查。\n\n对于第 $i$ 个排序后的p值 $p_{(i)}$，其调整后p值（或q值）的定义旨在强制单调性。这是通过取原始BH调整后p值的累积最小值来实现的。对于每个 $i \\in \\{1, \\dots, m\\}$，与 $p_{(i)}$ 对应的q值 $q_{(i)}$ 计算如下：\n$$\nq_{(i)} = \\min \\left( 1.0, \\min_{j=i}^{m} \\left\\{ \\frac{p_{(j)} \\cdot m}{j} \\right\\} \\right)\n$$\n这可以通过首先计算 $q_{(m)} = \\min(1.0, p_{(m)})$，然后对 $i = m-1, \\dots, 1$ 进行反向迭代来高效地计算：\n$$\nq_{(i)} = \\min\\left(1.0, q_{(i+1)}, \\frac{p_{(i)} \\cdot m}{i}\\right)\n$$\n这种构造保证了调整后p值的序列 $q_{(1)}, q_{(2)}, \\dots, q_{(m)}$ 是非递减的。因此，单调性检查将作为对实现的验证。\n\n每个测试用例的计算量如下：\n\n案例1：$m=10$，$\\alpha=0.05$。\n提供的p值为 $[0.002, 0.5, 0.04, 0.8, 0.0001, 1.0, 0.04, 0.2, 0.0, 0.95]$。\n排序后的p值 $p_{(i)}$ 为：$[0.0, 0.0001, 0.002, 0.04, 0.04, 0.2, 0.5, 0.8, 0.95, 1.0]$。\n对 $k=1, 2, \\dots, 10$ 检查BH条件 $p_{(k)} \\le \\frac{k}{10} \\times 0.05$：\n- $k=1: p_{(1)}=0.0 \\le 0.005$ (真)\n- $k=2: p_{(2)}=0.0001 \\le 0.01$ (真)\n- $k=3: p_{(3)}=0.002 \\le 0.015$ (真)\n- $k=4: p_{(4)}=0.04 \\not\\le 0.02$ (假)\n条件成立的最大 $k$ 是 $3$。因此，$r=3$。\n拒绝阈值为 $t_{\\mathrm{BH}} = p_{(3)} = 0.002$。\n排序后p值的q值按所述方法计算。序列以 $q_{(1)}=0.0$ 开始，以 $q_{(10)} = p_{(10)} = 1.0$ 结束。因此，$\\min(q)=0.0$ 且 $\\max(q)=1.0$。\n计算过程强制了单调性，所以 `is_monotone` 为 `True`。\n结果：$[3, 0.002000, 0.000000, 1.000000, \\text{True}]$\n\n案例2：$m=100,000$，$\\alpha=0.05$。\np值是确定性生成的。检验总数很大（$m=100,000$），其中 $1/50$ 的检验（即 $2,000$ 个检验）的p值来自一个向零倾斜的分布（$p_i=u_i^4$），代表潜在的真实信号，而其余的p值则是均匀分布的（$p_i=u_i$）。同样的BH程序被应用于计算。计算显示，满足 $p_{(k)} \\le \\frac{k}{m}\\alpha$ 的最大整数 $k$ 是 $r=2028$。相应的p值阈值是 $t_{\\mathrm{BH}} = p_{(2028)} \\approx 0.001014$。最小q值对应于生成的最小p值（接近于零），最大q值对应于最大p值（接近于一）。根据构造，q值的单调性成立。\n结果：$[2028, 0.001014, 0.000000, 1.000000, \\text{True}]$\n\n案例3：$m=50$，$\\alpha=0.05$。\n所有p值均为 $p_i = 1.0$。排序后的p值为 $p_{(i)}=1.0$，对于所有 $i=1, \\dots, 50$。\nBH条件为 $1.0 \\le \\frac{k}{50} \\times 0.05$，简化为 $1000 \\le k$。对于 $k \\le 50$，此条件永远无法满足。因此，不拒绝任何假设，且 $r=0$。\n根据定义，对于没有拒绝的案例，拒绝阈值 $t_{\\mathrm{BH}}$ 为 $0.0$。\n对于q值，$q_{(50)} = p_{(50)} = 1.0$。对于任何 $i  50$，$q_{(i)} = \\min(q_{(i+1)}, p_{(i)} \\cdot 50/i) = \\min(1.0, 1.0 \\cdot 50/i) = 1.0$，因为 $50/i \\ge 1.0$。因此，所有q值均为 $1.0$。\n这得出 $\\min(q)=1.0$ 和 $\\max(q)=1.0$。单调性成立。\n结果：$[0, 0.000000, 1.000000, 1.000000, \\text{True}]$\n\n现在的实现将遵循这些原则。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import __version__ as scipy_version # Allowed but not used, import is valid\n\ndef _calculate_bh_outputs(p_values: np.ndarray, alpha: float):\n    \"\"\"\n    Performs the Benjamini-Hochberg procedure from first principles and\n    calculates the five specified output quantities.\n    \n    Args:\n        p_values: A NumPy array of p-values.\n        alpha: The nominal false discovery rate level.\n        \n    Returns:\n        A list containing [r, t_bh, min_q, max_q, is_monotone].\n    \"\"\"\n    m = len(p_values)\n    if m == 0:\n        # Handle edge case of no p-values, though not in test suite.\n        return [0, 0.0, float('nan'), float('nan'), True]\n\n    # Step 1: Sort p-values in non-decreasing order.\n    # The problem outputs do not require re-ordering back to original,\n    # so we only need to work with the sorted values.\n    sorted_p = np.sort(p_values)\n\n    # Step 2: Find r, the total number of rejections.\n    # This involves finding the largest k such that p_(k) = (k/m) * alpha.\n    ranks = np.arange(1, m + 1)\n    bh_critical_values = (ranks / m) * alpha\n    \n    # Find all indices where the p-value is less than or equal to its critical value.\n    significant_indices = np.where(sorted_p = bh_critical_values)[0]\n    \n    r = 0\n    if significant_indices.size > 0:\n        # The largest k is the last index found + 1.\n        r = significant_indices[-1] + 1\n\n    # Step 3: Determine t_BH, the p-value threshold for rejection.\n    # This is the p-value of the r-th hypothesis, p_(r).\n    t_bh = sorted_p[r - 1] if r > 0 else 0.0\n\n    # Step 4: Calculate monotonic adjusted p-values (q-values).\n    # The standard procedure enforces monotonicity by taking a cumulative minimum\n    # of raw q-values. This is most efficiently computed on a reversed array.\n    \n    # Calculate raw q-values for p-values sorted in descending order.\n    p_rev = sorted_p[::-1]\n    ranks_rev = np.arange(m, 0, -1)\n    q_vals_raw_rev = p_rev * m / ranks_rev\n    \n    # Enforce monotonicity via cumulative minimum.\n    q_vals_rev = np.minimum.accumulate(q_vals_raw_rev)\n    \n    # Reverse back to match ascending p-value order and cap all values at 1.0.\n    q_vals_sorted = np.minimum(1.0, q_vals_rev[::-1])\n\n    min_q = q_vals_sorted[0]\n    max_q = q_vals_sorted[-1]\n\n    # Step 5: Verify that the resulting q-values are non-decreasing.\n    # This is a sanity check on the implementation.\n    # A small tolerance is used for floating-point comparisons.\n    is_monotone = np.all(np.diff(q_vals_sorted) >= -1e-9)\n\n    return [r, t_bh, min_q, max_q, bool(is_monotone)]\n\n\ndef solve():\n    \"\"\"\n    Main solver function to define, process, and format all test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Test Case 1: Small explicit vector\n    p_values_1 = np.array([0.002, 0.5, 0.04, 0.8, 0.0001, 1.0, 0.04, 0.2, 0.0, 0.95])\n    alpha_1 = 0.05\n\n    # Test Case 2: Large EWAS-scale vector\n    m_2 = 100000\n    alpha_2 = 0.05\n    i_vals = np.arange(1, m_2 + 1)\n    u_vals = (i_vals * np.sqrt(2) + np.sqrt(3)) % 1\n    # Create a boolean mask for indices divisible by 50 (alternative hypotheses)\n    is_alt = (i_vals % 50 == 0)\n    p_values_2 = np.where(is_alt, u_vals**4, u_vals)\n    \n    # Test Case 3: Edge case with no discoveries\n    m_3 = 50\n    alpha_3 = 0.05\n    p_values_3 = np.full(m_3, 1.0)\n\n    test_cases = [\n        (p_values_1, alpha_1),\n        (p_values_2, alpha_2),\n        (p_values_3, alpha_3),\n    ]\n\n    results = []\n    for p_values, alpha in test_cases:\n        result = _calculate_bh_outputs(p_values, alpha)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The output format is a list of lists, with floats rounded to 6 decimal places.\n    # [[r,t_bh,min_q,max_q,is_monotone],[...],[...]]\n    \n    final_output_list_of_strings = []\n    for res in results:\n        r, t_bh, min_q, max_q, is_mono = res\n        case_str = f\"[{r},{t_bh:.6f},{min_q:.6f},{max_q:.6f},{str(is_mono).title()}]\"\n        final_output_list_of_strings.append(case_str)\n        \n    final_output_str = f\"[{','.join(final_output_list_of_strings)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```", "id": "2629748"}]}