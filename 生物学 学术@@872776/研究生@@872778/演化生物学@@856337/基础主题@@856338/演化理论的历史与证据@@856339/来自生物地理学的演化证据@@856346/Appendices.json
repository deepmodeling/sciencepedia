{"hands_on_practices": [{"introduction": "热点群岛，如夏威夷群岛，为检验进化理论提供了一个天然的实验室。其“演进法则”预测，物种的定植和分化应遵循从老岛屿到新岛屿的顺序。本练习旨在通过应用肯德尔等级相关性（一种稳健的非参数统计方法），来量化检验这一经典的生物地理学假说，从而将宏观进化模式与具体的统计技能直接联系起来。通过这个练习，你将学会如何评估系统发育分化时间与岛屿地质年龄之间的关联强度，为演化过程提供可量化的证据 [@problem_id:2705037]。", "problem": "一个火山热点群岛形成了一个线性的岛链，这些岛屿的出现年龄得到了很好的限定。根据岛屿生物地理学中热点群岛的演进法则，一个演化支内的定殖或原位分化应从较老的岛屿向较年轻的岛屿进行，从而在岛屿地质年龄与根据系统发育分化时间推断的定殖年龄之间产生单调关联。考虑一个目标特有植物演化支，其在每个岛屿上的定殖年龄是使用群岛外部的化石校准的驰豫分子钟系统发育估计的。\n\n给定以下 $n=8$ 个岛屿的配对数据，每对数据列出了岛屿的出现年龄（单位：百万年前，Ma）和该岛上该演化支的估计定殖年龄（单位：Ma）。每次定殖事件都晚于岛屿的出现。\n\n- 岛屿 $1$：$(5.6,\\ 4.7)$\n- 岛屿 $2$：$(4.9,\\ 4.3)$\n- 岛屿 $3$：$(4.1,\\ 3.0)$\n- 岛屿 $4$：$(3.4,\\ 3.1)$\n- 岛屿 $5$：$(2.6,\\ 1.5)$\n- 岛屿 $6$：$(1.9,\\ 1.7)$\n- 岛屿 $7$：$(1.1,\\ 0.9)$\n- 岛屿 $8$：$(0.6,\\ 0.4)$\n\n假设任一变量中都没有重复值（ties），并且为了进行等级相关分析，将每个岛屿视为一个独立的观测单位。仅使用等级信息，计算岛屿年龄和定殖年龄之间的肯德尔(Kendall)τ等级相关系数，以评估演进法则。然后在无关联的原假设下，对肯德尔τ进行显著性水平为 $\\alpha=0.05$ 的双侧显著性检验，使用不带连续性校正的肯德尔统计量的标准零方差。\n\n将肯德尔τ的值作为最终答案报告，四舍五入到四位有效数字。最终答案不需要单位。", "solution": "该问题提供了一组岛屿出现年龄和演化支定殖年龄的配对数据，并要求使用肯德尔(Kendall)等级相关性对“演进法则”假说进行统计评估。该问题在科学上植根于岛屿生物地理学，并提出了一个定义明确的统计学问题。它没有矛盾、歧义和事实错误。因此，这是一个有效的问题，并将提供解答。\n\n目标是计算肯德尔(Kendall)等级相关系数 $\\tau$，并检验其统计显著性。肯德尔τ衡量两个测量量之间的序数关联。对于一组 $n$ 对观测值 $(x_i, y_i)$，肯德尔τ定义为：\n$$\n\\tau = \\frac{N_c - N_d}{\\frac{1}{2} n(n-1)}\n$$\n其中 $N_c$ 是一致对的数量，$N_d$ 是不一致对的数量。分母是观测值对的总数。如果一对观测值 $(x_i, y_i)$ 和 $(x_j, y_j)$ 中两个元素的等级一致（即，如果 $x_i > x_j$ 且 $y_i > y_j$，或如果 $x_i < x_j$ 且 $y_i < y_j$），则该对是一致的。如果等级不一致（即，如果 $x_i > x_j$ 且 $y_i < y_j$，或如果 $x_i < x_j$ 且 $y_i > y_j$），则该对是不一致的。问题说明没有重复值，这简化了计算。\n\n给定数据包含 $n=8$ 对，其中岛屿出现年龄为变量 $X$，定殖年龄为变量 $Y$，单位均为百万年前（Ma）。这些数据对是：$(5.6, 4.7)$、$(4.9, 4.3)$、$(4.1, 3.0)$、$(3.4, 3.1)$、$(2.6, 1.5)$、$(1.9, 1.7)$、$(1.1, 0.9)$ 和 $(0.6, 0.4)$。\n\n为了计算 $N_c$ 和 $N_d$，我们首先根据一个变量（例如 $X$）对数据进行排序。数据已按岛屿年龄 $X$ 的降序排列。\n$X: 5.6 > 4.9 > 4.1 > 3.4 > 2.6 > 1.9 > 1.1 > 0.6$\n对应的 $Y$ 值序列是：\n$Y: 4.7, 4.3, 3.0, 3.1, 1.5, 1.7, 0.9, 0.4$\n\n现在，对于每个 $y_i$，我们计算其后的值 $y_j$ (其中 $j>i$) 中比它小（一致）或比它大（不一致）的数量。\n\n1.  对于 $y_1 = 4.7$：其后的值为 $\\{4.3, 3.0, 3.1, 1.5, 1.7, 0.9, 0.4\\}$。所有 $7$ 个值都更小。\n    一致计数 = $7$。不一致计数 = $0$。\n\n2.  对于 $y_2 = 4.3$：其后的值为 $\\{3.0, 3.1, 1.5, 1.7, 0.9, 0.4\\}$。所有 $6$ 个值都更小。\n    一致计数 = $6$。不一致计数 = $0$。\n\n3.  对于 $y_3 = 3.0$：其后的值为 $\\{3.1, 1.5, 1.7, 0.9, 0.4\\}$。更小的值为 $\\{1.5, 1.7, 0.9, 0.4\\}$（$4$ 个值）。更大的值为 $\\{3.1\\}$（$1$ 个值）。\n    一致计数 = $4$。不一致计数 = $1$。\n\n4.  对于 $y_4 = 3.1$：其后的值为 $\\{1.5, 1.7, 0.9, 0.4\\}$。所有 $4$ 个值都更小。\n    一致计数 = $4$。不一致计数 = $0$。\n\n5.  对于 $y_5 = 1.5$：其后的值为 $\\{1.7, 0.9, 0.4\\}$。更小的值为 $\\{0.9, 0.4\\}$（$2$ 个值）。更大的值为 $\\{1.7\\}$（$1$ 个值）。\n    一致计数 = $2$。不一致计数 = $1$。\n\n6.  对于 $y_6 = 1.7$：其后的值为 $\\{0.9, 0.4\\}$。所有 $2$ 个值都更小。\n    一致计数 = $2$。不一致计数 = $0$。\n\n7.  对于 $y_7 = 0.9$：其后的值为 $\\{0.4\\}$。这 $1$ 个值更小。\n    一致计数 = $1$。不一致计数 = $0$。\n\n一致对的总数是各个计数的总和：\n$$\nN_c = 7 + 6 + 4 + 4 + 2 + 2 + 1 = 26\n$$\n不一致对的总数是：\n$$\nN_d = 0 + 0 + 1 + 0 + 1 + 0 + 0 = 2\n$$\n总对数是 $\\binom{n}{2} = \\binom{8}{2} = \\frac{8 \\times 7}{2} = 28$。\n作为检验，$N_c + N_d = 26 + 2 = 28$，这是正确的。\n\n现在，我们计算肯德尔τ：\n$$\n\\tau = \\frac{N_c - N_d}{N_c + N_d} = \\frac{26 - 2}{26 + 2} = \\frac{24}{28} = \\frac{6}{7}\n$$\n作为小数，$\\tau \\approx 0.8571428...$。四舍五入到四位有效数字，$\\tau = 0.8571$。\n\n接下来，我们进行双侧显著性检验。\n原假设 $H_0$ 是变量之间没有关联，即 $\\tau = 0$。\n备择假设 $H_1$ 是存在关联，即 $\\tau \\neq 0$。\n显著性水平为 $\\alpha = 0.05$。\n\n对于样本量 $n > 10$，在 $H_0$ 下，统计量 $S = N_c - N_d$ 的分布近似为正态分布。我们将按照隐含的指示使用此近似。\n在 $H_0$ 下，$S$ 的期望值为 $E[S] = 0$。\n$S$ 的方差（在没有重复值的情况下）由下式给出：\n$$\n\\sigma_S^2 = \\text{Var}(S) = \\frac{n(n-1)(2n+5)}{18}\n$$\n对于 $n=8$，我们计算方差：\n$$\n\\sigma_S^2 = \\frac{8(8-1)(2(8)+5)}{18} = \\frac{8 \\times 7 \\times (16+5)}{18} = \\frac{8 \\times 7 \\times 21}{18} = \\frac{1176}{18} = \\frac{196}{3}\n$$\n标准差是：\n$$\n\\sigma_S = \\sqrt{\\frac{196}{3}} = \\frac{14}{\\sqrt{3}} \\approx 8.083\n$$\n根据指定，检验统计量 $Z$ 的计算不使用连续性校正：\n$$\nZ = \\frac{S - E[S]}{\\sigma_S} = \\frac{S}{\\sigma_S}\n$$\n我们观测到的 $S$ 值为 $N_c - N_d = 24$。\n$$\nZ = \\frac{24}{14/\\sqrt{3}} = \\frac{24\\sqrt{3}}{14} = \\frac{12\\sqrt{3}}{7} \\approx 2.969\n$$\n对于 $\\alpha = 0.05$ 的双侧检验，临界值为 $Z_{\\alpha/2} = \\pm 1.96$。\n由于我们观测到的检验统计量 $|Z| \\approx 2.969$ 大于临界值 $1.96$，我们拒绝原假设 $H_0$。此检验的p值为 $p = 2 \\times P(Z \\ge 2.969) \\approx 0.003$，远小于 $\\alpha=0.05$。\n结论是岛屿年龄和定殖年龄之间存在统计上显著的正相关关系，这与演进法则一致。\n\n问题只要求肯德尔τ的值。\n$$\n\\tau = \\frac{6}{7} \\approx 0.8571\n$$", "answer": "$$\n\\boxed{0.8571}\n$$", "id": "2705037"}, {"introduction": "历史生物地理学的一个核心挑战是区分异域成种（vicariance）和扩散（dispersal）。现代研究方法已经超越了定性推断，转向了定量的、概率性的比较。本练习将指导你通过蒙特卡洛模拟，在物种分化时间和地理屏障形成时间均存在不确定性的情况下，计算物种分化先于屏障形成的概率。这个练习使你能够掌握在不确定性下，如何正式地权衡支持扩散与异域成种假说的证据，这是现代系统地理学研究的一项核心技能 [@problem_id:2705264]。", "problem": "您将处理一个进化生物地理学中的决策问题，该问题旨在评估一个分化事件（系统发育节点年龄）是否可能早于一个地理障碍的形成。这种时间比较为解释生物地理格局的隔离分化与扩散这两种理论提供了相关证据。标准的预期是：如果障碍在分化之前形成，那么隔离分化是合理的；如果分化早于障碍的形成，那么需要用扩散来解释当前的物种分布。形式上，令 $T_{\\text{node}}$ 表示以百万年前（Ma）为单位的分化时间，令 $T_{\\text{barrier}}$ 表示以百万年前（Ma）为单位的障碍形成时间。假设时间是从现在往回计算，因此数值越大代表越古老。关键的量是在两个量都存在不确定性的情况下，概率 $P\\!\\left(T_{\\text{node}} > T_{\\text{barrier}}\\right)$，我们将其表示为 $P_{\\text{precede}}$。\n\n基本基础、假设和定义：\n- 后验样本：后验样本是通过马尔可夫链蒙特卡洛（MCMC）等方法从后验分布中抽取得到的有限样本集，代表在贝叶斯模型下观察数据后参数的不确定性。在这里，$T_{\\text{node}}$ 将由后验样本表示。\n- 障碍不确定性：障碍形成时间 $T_{\\text{barrier}}$ 是不确定的，将通过一个参数分布来建模。\n- 独立性：在系统发育和地质分析的条件下，为此模型检查的目的，将 $T_{\\text{node}}$ 和 $T_{\\text{barrier}}$ 视为独立的。\n- 蒙特卡洛估计：对于独立的随机变量 $X$ 和 $Y$，概率 $P(X > Y)$ 可以表示为积分 $\\int \\int \\mathbf{1}\\{x > y\\}\\,p_{X}(x)\\,p_{Y}(y)\\,dx\\,dy$。蒙特卡洛估计器通过计算联合抽样上的指示函数平均值来替代该积分。\n\n任务：\n- 对于每个测试案例，使用 $T_{\\text{node}}$ 的后验样本（单位：Ma）和 $T_{\\text{barrier}}$ 的指定不确定性模型（单位：Ma），通过蒙特卡洛方法计算 $P_{\\text{precede}} = P\\!\\left(T_{\\text{node}} > T_{\\text{barrier}}\\right)$ 的估计值。\n- 然后，使用 $P_{\\text{precede}}$，为扩散与隔离分化提供一个数值决策支持代码：\n  - 如果 $P_{\\text{precede}} \\geq \\tau_{\\text{hi}}$，输出 $+1$（支持扩散），\n  - 如果 $P_{\\text{precede}} \\leq \\tau_{\\text{lo}}$，输出 $-1$（支持隔离分化），\n  - 否则输出 $0$（模棱两可）。\n- 使用阈值 $\\tau_{\\text{hi}} = 0.95$ 和 $\\tau_{\\text{lo}} = 0.05$。\n\n蒙特卡洛协议：\n- 对于每个测试案例，首先通过从指定的对数正态分布中抽取 $N_{\\text{node}}$ 个值，为 $T_{\\text{node}}$ 生成一个经验后验样本。具体来说，如果 $\\ln T_{\\text{node}} \\sim \\mathcal{N}(\\mu_{\\text{node}}, \\sigma_{\\text{node}}^{2})$，则 $T_{\\text{node}} = \\exp(Z)$，其中 $Z \\sim \\mathcal{N}(\\mu_{\\text{node}}, \\sigma_{\\text{node}}^{2})$。这些样本代表了节点年龄的后验不确定性。\n- 障碍不确定性也建模为对数正态分布：$\\ln T_{\\text{barrier}} \\sim \\mathcal{N}(\\mu_{\\text{barrier}}, \\sigma_{\\text{barrier}}^{2})$。\n- 通过 $M$ 次联合抽样来估计 $P_{\\text{precede}}$：\n  - 从 $N_{\\text{node}}$ 个后验样本中通过自助法（bootstrap）重抽样 $T_{\\text{node}}$ 的值。\n  - 从其对数正态模型中独立抽取 $T_{\\text{barrier}}$ 的值。\n  - 计算这 $M$ 对样本上指示函数 $\\mathbf{1}\\{T_{\\text{node}} > T_{\\text{barrier}}\\}$ 的平均值。\n- 为了可复现性，使用固定的基础伪随机种子 $S = 20231105$。对于从 $0$ 开始的测试案例索引 $i$，使用种子 $S + i$ 来初始化该案例的生成器。\n- 对所有案例使用 $N_{\\text{node}} = 20000$ 和 $M = 400000$。\n- 所有年龄单位均为 Ma；将概率以小数形式报告（不带百分号）。\n\n测试套件：\n对于每个案例，您将获得节点年龄和障碍年龄的对数正态分布参数，这些参数以其在原始 Ma 标度上的均值和在对数标度上的标准差给出。具体来说，取 $\\mu = \\ln(\\text{mean\\_Ma})$，并将指定的 $\\sigma$ 作为对数标度标准差。四个测试案例是：\n\n- 案例 A:\n  - 节点：通过 $\\mu_{\\text{node}} = \\ln(13)$ 在对数标度上均值为 $\\ln(13)$，$\\sigma_{\\text{node}} = 0.15$。\n  - 障碍：$\\mu_{\\text{barrier}} = \\ln(8)$，$\\sigma_{\\text{barrier}} = 0.20$。\n\n- 案例 B:\n  - 节点：$\\mu_{\\text{node}} = \\ln(6)$，$\\sigma_{\\text{node}} = 0.15$。\n  - 障碍：$\\mu_{\\text{barrier}} = \\ln(10)$，$\\sigma_{\\text{barrier}} = 0.10$。\n\n- 案例 C:\n  - 节点：$\\mu_{\\text{node}} = \\ln(9)$，$\\sigma_{\\text{node}} = 0.20$。\n  - 障碍：$\\mu_{\\text{barrier}} = \\ln(9.5)$，$\\sigma_{\\text{barrier}} = 0.15$。\n\n- 案例 D:\n  - 节点：$\\mu_{\\text{node}} = \\ln(10)$，$\\sigma_{\\text{node}} = 0.05$。\n  - 障碍：$\\mu_{\\text{barrier}} = \\ln(10)$，$\\sigma_{\\text{barrier}} = 0.50$。\n\n每个案例所需的算法输出：\n- 计算 $P_{\\text{precede}}$ 作为 $[0,1]$ 区间内的蒙特卡洛估计值。\n- 使用 $\\tau_{\\text{hi}} = 0.95$ 和 $\\tau_{\\text{lo}} = 0.05$ 计算决策代码（在 $\\{-1,0,+1\\}$ 中）。\n- 将 $P_{\\text{precede}}$ 四舍五入到 $6$ 位小数进行输出。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试案例的结果本身是一个形式为 $[p,c]$ 的双元素列表，其中 $p$ 是四舍五入后的概率， $c$ 是整数代码。例如，整体输出应类似于 $[[p_{A},c_{A}],[p_{B},c_{B}],[p_{C},c_{C}],[p_{D},c_{D}]]$，不含空格。程序必须硬编码上述指定的测试套件，并且不需要用户输入。", "solution": "问题陈述在参数描述上存在轻微的不精确。具体而言，通用规则“取 $\\mu = \\ln(\\text{mean\\_Ma})$”之后是诸如“$\\mu_{\\text{node}} = \\ln(13)$”的测试案例规范，这可能产生歧义。严格解读可能会发现矛盾。然而，一个有能力的从业者会明白，针对特定测试案例的显式参数值赋值必须优先于措辞不佳的通用描述规则。因此，我将把每个案例中为 $\\mu_{\\text{node}}$ 和 $\\mu_{\\text{barrier}}$ 明确提供的方程作为正确、明确的规范来执行。除此之外，该问题定义明确且科学上合理。\n\n问题的核心是评估概率 $P_{\\text{precede}} = P(T_{\\text{node}} > T_{\\text{barrier}})$，其中 $T_{\\text{node}}$ 是物种分化时间的随机变量，而 $T_{\\text{barrier}}$ 是地理障碍形成时间的随机变量。两个时间都以百万年前（Ma）为单位，因此数值越大代表越古老。条件 $T_{\\text{node}} > T_{\\text{barrier}}$ 意味着分化事件发生在障碍形成之前，这为解释当前物种跨越障碍分布的基于扩散的理论提供了证据。\n\n$T_{\\text{node}}$ 的不确定性由一组后验样本表示，我们被指示通过从指定的对数正态分布中抽取 $N_{\\text{node}} = 20000$ 个值来模拟这些样本。让这些初始样本表示为集合 $\\mathcal{S}_{\\text{node}} = \\{t_{1}, t_{2}, \\dots, t_{N_{\\text{node}}}\\}$。节点年龄的分布由 $\\ln(T_{\\text{node}}) \\sim \\mathcal{N}(\\mu_{\\text{node}}, \\sigma_{\\text{node}}^2)$ 给出。\n\n$T_{\\text{barrier}}$ 的不确定性直接由一个参数化的对数正态分布建模，$\\ln(T_{\\text{barrier}}) \\sim \\mathcal{N}(\\mu_{\\text{barrier}}, \\sigma_{\\text{barrier}}^2)$。\n\n问题要求一个特定的蒙特卡洛协议来估计 $P_{\\text{precede}}$。这并非两种参数分布的简单比较，而是对一个经验分布（来自 $T_{\\text{node}}$ 的 $N_{\\text{node}}$ 个样本）和一个参数分布（$T_{\\text{barrier}}$）的比较。该估计通过 $M=400000$ 次试验进行。对于每次试验 $j \\in \\{1, \\dots, M\\}$：\n$1$. 通过从先前生成的经验样本集 $\\mathcal{S}_{\\text{node}}$ 中有放回地抽取，得到节点年龄值 $t_{\\text{node}}^{(j)}$。这是一个自助法重抽样步骤。\n$2$. 从其对数正态分布 $\\text{Lognormal}(\\mu_{\\text{barrier}}, \\sigma_{\\text{barrier}}^2)$ 中抽取一个障碍年龄值 $t_{\\text{barrier}}^{(j)}$。\n$3$. 计算一个指示变量 $I_j$：$I_j = \\mathbf{1}\\{t_{\\text{node}}^{(j)} > t_{\\text{barrier}}^{(j)}\\}$，其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数，当其参数为真时等于 $1$，否则为 $0$。\n\n$P_{\\text{precede}}$ 的蒙特卡洛估计值是这些指示变量在所有 $M$ 次试验中的平均值：\n$$\n\\hat{P}_{\\text{precede}} = \\frac{1}{M} \\sum_{j=1}^{M} I_j\n$$\n这个过程正确地模拟了对两个量的不确定性进行积分的过程，其中一个量由有限样本非参数化地表示。\n\n最后，根据估计的概率 $\\hat{P}_{\\text{precede}}$ 和两个阈值 $\\tau_{\\text{hi}} = 0.95$ 与 $\\tau_{\\text{lo}} = 0.05$ 来分配决策代码。\n- 如果 $\\hat{P}_{\\text{precede}} \\ge 0.95$，代码为 $+1$，支持扩散。\n- 如果 $\\hat{P}_{\\text{precede}} \\le 0.05$，代码为 $-1$，支持隔离分化。\n- 否则（$0.05  < \\hat{P}_{\\text{precede}}  < 0.95$），代码为 $0$，表示模棱两可。\n\n为了可复现性，每个测试案例 $i$（$i$ 从 $0$ 开始）的伪随机数生成器使用 $S+i$ 进行播种，其中基础种子是 $S = 20231105$。\n\n每个测试案例的计算算法如下：\n$1$. 使用适合该案例的种子设置随机数生成器。\n$2$. 定义节点和障碍的对数尺度参数：$\\mu_{\\text{node}}$、$\\sigma_{\\text{node}}$、$\\mu_{\\text{barrier}}$ 和 $\\sigma_{\\text{barrier}}$。\n$3$. 从 $\\text{Lognormal}(\\mu_{\\text{node}}, \\sigma_{\\text{node}}^2)$ 生成大小为 $N_{\\text{node}} = 20000$ 的 $T_{\\text{node}}$ 初始“后验样本”。\n$4$. 通过从上一步生成的样本中有放回地抽取，生成 $M = 400000$ 个 $T_{\\text{node}}$ 的自助法重抽样样本。\n$5$. 从 $\\text{Lognormal}(\\mu_{\\text{barrier}}, \\sigma_{\\text{barrier}}^2)$ 生成 $M = 400000$ 个 $T_{\\text{barrier}}$ 样本。\n$6$. 逐元素比较两个大小为 $M$ 的样本数组，计算 $T_{\\text{node}} > T_{\\text{barrier}}$ 的实例数量。\n$7$. 将此计数除以 $M$ 得到 $\\hat{P}_{\\text{precede}}$。\n$8$. 将结果四舍五入到 $6$ 位小数，并应用决策规则找到代码。\n$9$. 收集所有测试案例的结果，并按指定格式化最终输出。\n整个过程将使用 Python 及其 NumPy 库来实现数值运算和随机数生成。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the biogeographic decision problem for four test cases.\n    \"\"\"\n    # Define constants and thresholds from the problem statement.\n    N_node = 20000\n    M = 400000\n    base_seed = 20231105\n    tau_hi = 0.95\n    tau_lo = 0.05\n\n    # Test suite: [ (mu_node, sigma_node), (mu_barrier, sigma_barrier) ]\n    test_cases = [\n        # Case A\n        {'node_params': {'mu': np.log(13), 'sigma': 0.15},\n         'barrier_params': {'mu': np.log(8), 'sigma': 0.20}},\n        # Case B\n        {'node_params': {'mu': np.log(6), 'sigma': 0.15},\n         'barrier_params': {'mu': np.log(10), 'sigma': 0.10}},\n        # Case C\n        {'node_params': {'mu': np.log(9), 'sigma': 0.20},\n         'barrier_params': {'mu': np.log(9.5), 'sigma': 0.15}},\n        # Case D\n        {'node_params': {'mu': np.log(10), 'sigma': 0.05},\n         'barrier_params': {'mu': np.log(10), 'sigma': 0.50}},\n    ]\n\n    results = []\n\n    for i, case in enumerate(test_cases):\n        # Initialize the random number generator with the case-specific seed.\n        seed = base_seed + i\n        rng = np.random.default_rng(seed)\n\n        # Extract parameters for the current case.\n        mu_node = case['node_params']['mu']\n        sigma_node = case['node_params']['sigma']\n        mu_barrier = case['barrier_params']['mu']\n        sigma_barrier = case['barrier_params']['sigma']\n\n        # Step 1: Generate an empirical posterior sample for T_node.\n        # numpy.random.lognormal takes mean and sigma of the underlying normal distribution,\n        # which corresponds to mu and sigma in the problem.\n        T_node_posterior_samples = rng.lognormal(mean=mu_node, sigma=sigma_node, size=N_node)\n\n        # Step 2: Estimate P_precede using M joint draws.\n        # Resample T_node values by bootstrap from the posterior samples.\n        T_node_resamples = rng.choice(T_node_posterior_samples, size=M, replace=True)\n\n        # Independently draw T_barrier values from its lognormal model.\n        T_barrier_samples = rng.lognormal(mean=mu_barrier, sigma=sigma_barrier, size=M)\n\n        # Compute the average of the indicator function 1{T_node > T_barrier}.\n        precedence_count = np.sum(T_node_resamples > T_barrier_samples)\n        p_precede = precedence_count / M\n\n        # Step 3: Round the probability and derive the decision code.\n        p_rounded = round(p_precede, 6)\n\n        if p_precede >= tau_hi:\n            decision_code = 1\n        elif p_precede <= tau_lo:\n            decision_code = -1\n        else:\n            decision_code = 0\n\n        results.append(f\"[{p_rounded},{decision_code}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2705264"}, {"introduction": "在评估解释物种区系演化的过程模型时，一个关键问题是如何避免“过度拟合”。例如，在扩散-绝灭-成种（DEC）模型中加入奠基者事件（DEC+J），虽然可能提升模型对现有数据的拟合度，但这种提升未必具有真正的预测能力。本练习介绍了一种严谨的模型比较技术——留一交叉验证法，用于评估增加模型复杂性（如“+J”参数）是否能真正提高对新数据的预测性能。通过这个高级练习，你将学会如何判断一个参数的加入是科学上合理的改进，还是仅仅是“特设”的修正 [@problem_id:2705112]。", "problem": "本题为您提供一个源于历史生物地理学的模型比较问题的简化且可检验的表述，其中比较了 Dispersal-Extinction-Cladogenesis (DEC) 模型与一个增加了奠基者事件物种形成 (founder-event speciation) 的增强版 DEC 模型 (DEC+J)。\n其科学背景是利用生物地理事件模式来评估跨支系的扩散和物种形成过程所驱动的演化证据。\n其目的在于，通过评估在留出支系上的样本外预测性能，来判断用一个奠基者事件参数增强 DEC 模型是否是一种特定情况下的(ad hoc)做法。\n\n基本依据和假设：\n- 每个支系的数据由谱系发生事件的计数来概括：对于支系索引 $i \\in \\{1,\\dots, n\\}$，令 $N_i$ 表示被评估的谱系发生事件的总数，令 $K_i$ 表示其中表现出奠基者事件特征（即与物种形成相关的跳跃式扩散）的事件数量。\n- 在支系可交换性和似然原理的假设下，可使用留一支系交叉验证的预测密度来进行模型比较。\n- 在 DEC 模型下，真实的奠基者事件概率恰好为 $p_J = 0$，因此对于 $K_i$ 的预测概率，当 $K_i = 0$ 时为 $1$，当 $K_i > 0$ 时为 $0$。\n- 在 DEC+J 模型下，奠基者事件概率 $p_J$ 是一个带有贝塔先验 $p_J \\sim \\mathrm{Beta}(\\alpha,\\beta)$ 的参数，其超参数 $\\alpha > 0$ 和 $\\beta > 0$ 的选择是为了编码一个经过充分检验的经验预期，即奠基者事件是罕见的。给定训练支系的留一法后验为 $p_J \\mid \\text{train} \\sim \\mathrm{Beta}(\\alpha + \\sum_{j \\neq i} K_j, \\beta + \\sum_{j \\neq i} (N_j - K_j))$。在给定 $N_i$ 的条件下，留出支系的奠基者事件计数 $K_i$ 的预测分布是贝塔-二项分布，其概率质量函数为\n$$\n\\Pr(K_i \\mid N_i, \\text{train}) \\;=\\; \\binom{N_i}{K_i} \\frac{B\\!\\left(\\alpha_{\\text{post}} + K_i,\\, \\beta_{\\text{post}} + N_i - K_i\\right)}{B\\!\\left(\\alpha_{\\text{post}},\\, \\beta_{\\text{post}}\\right)},\n$$\n其中 $B(\\cdot,\\cdot)$ 是贝塔函数，且 $\\alpha_{\\text{post}} = \\alpha + \\sum_{j \\neq i} K_j$，$\\beta_{\\text{post}} = \\beta + \\sum_{j \\neq i} (N_j - K_j)$。\n- 比较指标是平均留一支系对数预测密度（即在每个模型下，对留出支系 $K_i$ 的预测概率取对数，再在所有支系上求平均值）。如果 DEC+J 模型相对于 DEC 模型严格改进了这一平均值，即差值\n$$\n\\Delta \\;=\\; \\frac{1}{n} \\sum_{i=1}^n \\log \\Pr_{\\text{DEC+J}}(K_i \\mid N_i, \\text{train}_{-i}) \\;-\\; \\frac{1}{n} \\sum_{i=1}^n \\log \\Pr_{\\text{DEC}}(K_i \\mid N_i)\n$$\n严格大于 $0$，则认为添加 $J$ 参数不是特定情况下的(ad hoc)做法。\n\n任务：\n- 实现一个程序，该程序对下述测试套件中的每个数据集，使用贝塔-二项预测为 DEC+J 模型、使用结构性零预测为 DEC 模型计算留一支系平均对数预测密度，然后返回一个布尔值，指示是否 $\\Delta > 0$。\n- 对 $\\mathrm{Beta}(\\alpha,\\beta)$ 先验使用超参数 $\\alpha = 1$ 和 $\\beta = 19$，以编码先验均值 $\\mathbb{E}[p_J] = \\alpha/(\\alpha+\\beta) = 1/20$，这反映了与许多岛屿生物地理系统一致的罕见奠基者事件。\n- 所有对数必须是自然对数。\n\n测试套件：\n- 数据集 $\\mathcal{D}_1$（理想情况，其中 DEC 模型因某些支系出现奠基者事件而失败）：\n  - $[(N_1,K_1),\\dots,(N_6,K_6)] = [(12,2),(9,0),(15,1),(8,0),(10,0),(11,1)]$。\n- 数据集 $\\mathcal{D}_2$（对照组，未观测到奠基者事件）：\n  - $[(N_1,K_1),\\dots,(N_5,K_5)] = [(12,0),(9,0),(15,0),(8,0),(10,0)]$。\n- 数据集 $\\mathcal{D}_3$（边界情况，在少数几个支系中出现单个奠基者事件）：\n  - $[(N_1,K_1),\\dots,(N_5,K_5)] = [(5,0),(7,0),(6,0),(8,0),(10,1)]$。\n\n待计算量：\n- 对每个数据集，计算布尔结果 $R \\in \\{\\text{True},\\text{False}\\}$，其中如果 $\\Delta > 0$ 则 $R = \\text{True}$，否则 $R = \\text{False}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按 $[\\mathcal{D}_1,\\mathcal{D}_2,\\mathcal{D}_3]$ 顺序排列的结果，形式为方括号括起来的逗号分隔列表。例如，如果三个布尔值是 True, False, True，则输出必须是 `[True,False,True]`。\n- 不涉及物理单位；所有报告值均为无量纲实数和布尔值。", "solution": "所述问题已经过验证，被认为是良置的、有科学依据且内部一致的。它展示了在历史生物地理学背景下，使用留一法交叉验证进行贝叶斯模型比较的一个标准（尽管简化了的）应用。所有必需的数据、模型和评估标准均已提供。因此，我们可以着手进行严谨的解析求解。\n\n目标是为每个数据集确定 DEC+J 模型是否比其嵌套的 DEC 模型提供严格更优的样本外预测拟合。这通过它们平均留一支系对数预测密度的差值符号来量化，记为 $\\Delta$。一个正的 $\\Delta$ 表明，纳入奠基者事件物种形成参数 $p_J$ 是受数据支持的。决策规则是评估是否 $\\Delta > 0$，其中\n$$\n\\Delta = L_{\\text{DEC+J}} - L_{\\text{DEC}} = \\frac{1}{n} \\sum_{i=1}^n \\log \\Pr_{\\text{DEC+J}}(K_i \\mid N_i, \\text{train}_{-i}) - \\frac{1}{n} \\sum_{i=1}^n \\log \\Pr_{\\text{DEC}}(K_i \\mid N_i).\n$$\n\n我们将为每个数据集计算 $L_{\\text{DEC}}$ 和 $L_{\\text{DEC+J}}$ 这两项。\n\n**1. DEC 模型的对数预测密度**\n\nDEC 模型的结构由奠基者事件概率 $p_J$ 恰好为 $0$ 这一约束所定义。因此，观测到 $K_i$ 个奠基者事件的概率是：\n$$\n\\Pr_{\\text{DEC}}(K_i \\mid N_i) = \\begin{cases} 1  &\\text{if } K_i = 0 \\\\ 0  &\\text{if } K_i > 0 \\end{cases}\n$$\n该预测概率对应的自然对数是：\n$$\n\\log \\Pr_{\\text{DEC}}(K_i \\mid N_i) = \\begin{cases} \\log(1) = 0  &\\text{if } K_i = 0 \\\\ \\log(0) = -\\infty  &\\text{if } K_i > 0 \\end{cases}\n$$\n平均对数预测密度 $L_{\\text{DEC}}$ 是这些值在所有 $n$ 个支系上的平均值。\n- 如果对于所有支系 $i$，$K_i=0$，那么和中的每一项都是 $0$，且 $L_{\\text{DEC}} = 0$。\n- 如果哪怕只存在一个支系 $i$ 使得 $K_i > 0$，和中将至少包含一个 $-\\infty$ 项，从而使得整个和以及其平均值 $L_{\\text{DEC}} = -\\infty$。\n\n**2. DEC+J 模型的对数预测密度**\n\n对于 DEC+J 模型，我们执行留一法交叉验证。对于每个支系 $i$（作为留出集），剩下的 $n-1$ 个支系构成训练集，记为 $\\text{train}_{-i}$。\n\n首先，我们计算整个数据集上奠基者事件和非奠基者事件的总数：$S_K^{\\text{total}} = \\sum_{j=1}^n K_j$ 和 $S_{N-K}^{\\text{total}} = \\sum_{j=1}^n (N_j - K_j)$。\n\n对于每个留出支系 $i$，训练集的计数为 $S_K^{\\text{train}} = S_K^{\\text{total}} - K_i$ 和 $S_{N-K}^{\\text{train}} = S_{N-K}^{\\text{total}} - (N_i - K_i)$。然后使用训练数据从先验 $\\mathrm{Beta}(\\alpha, \\beta)$ 更新 $p_J$ 的后验超参数：\n$$\n\\alpha_{\\text{post}} = \\alpha + S_K^{\\text{train}}\n$$\n$$\n\\beta_{\\text{post}} = \\beta + S_{N-K}^{\\text{train}}\n$$\n在给定总事件数为 $N_i$ 的情况下，在留出支系中观测到 $K_i$ 个奠基者事件的预测概率遵循贝塔-二项分布。我们计算其自然对数：\n$$\n\\log \\Pr_{\\text{DEC+J}}(K_i \\mid N_i, \\text{train}_{-i}) = \\log\\left[ \\binom{N_i}{K_i} \\frac{B(\\alpha_{\\text{post}} + K_i, \\beta_{\\text{post}} + N_i - K_i)}{B(\\alpha_{\\text{post}}, \\beta_{\\text{post}})} \\right]\n$$\n为了数值稳定性，该计算使用对数伽马函数（通过对数贝塔函数 $\\text{lbeta}$）和二项式系数的对数来完成：\n$$\n\\log \\Pr_i = \\log\\binom{N_i}{K_i} + \\mathrm{lbeta}(\\alpha_{\\text{post}} + K_i, \\beta_{\\text{post}} + N_i - K_i) - \\mathrm{lbeta}(\\alpha_{\\text{post}}, \\beta_{\\text{post}})\n$$\n由于超参数 $\\alpha, \\beta$ 严格为正（$1$ 和 $19$）且计数 $K_j, N_j-K_j$ 为非负，贝塔函数的参数总是正的。因此，预测概率总是一个有限的非零数，其对数 $\\log \\Pr_i$ 是一个有限实数。\n\nDEC+J 的平均对数预测密度是这些对数概率的平均值：\n$$\nL_{\\text{DEC+J}} = \\frac{1}{n} \\sum_{i=1}^n \\log \\Pr_i\n$$\n该量将总是一个有限实数。\n\n**3. 条件 $\\Delta > 0$ 的评估**\n\n我们现在必须评估条件 $L_{\\text{DEC+J}} > L_{\\text{DEC}}$。\n\n**情况1：至少有一个 $K_i > 0$。**\n在这种情况下，$L_{\\text{DEC}} = -\\infty$。由于 $L_{\\text{DEC+J}}$ 是一个有限值，不等式变为：\n$$\nL_{\\text{DEC+J}} > -\\infty\n$$\n这永远为真。因此，如果在数据集中观测到任何奠基者事件，DEC+J 模型则被严格偏好。结果是 **True**。\n\n**情况2：所有 $K_i = 0$。**\n在这种情况下，$L_{\\text{DEC}} = 0$。不等式变为：\n$$\nL_{\\text{DEC+J}} > 0\n$$\n让我们分析 $L_{\\text{DEC+J}}$。如果所有 $K_j=0$，那么对于任何留出支系 $i$，我们也有 $K_i=0$。训练集的 $S_K^{\\text{train}} = 0$。后验参数变为 $\\alpha_{\\text{post}} = \\alpha$ 和 $\\beta_{\\text{post}} = \\beta + S_{N-K}^{\\text{train}}$。支系 $i$ 的对数预测概率是：\n$$\n\\log \\Pr_i = \\log\\binom{N_i}{0} + \\mathrm{lbeta}(\\alpha, \\beta_{\\text{post}} + N_i) - \\mathrm{lbeta}(\\alpha, \\beta_{\\text{post}})\n$$\n由于 $\\binom{N_i}{0}=1$，其对数为 $0$。该表达式简化为：\n$$\n\\log \\Pr_i = \\log B(\\alpha, \\beta_{\\text{post}} + N_i) - \\log B(\\alpha, \\beta_{\\text{post}})\n$$\n给定 $N_i > 0$，我们有 $\\beta_{\\text{post}} + N_i > \\beta_{\\text{post}}$。对于固定的 $a>0$，贝塔函数 $B(a,b)$ 是 $b$ 的递减函数。因此，$B(\\alpha, \\beta_{\\text{post}} + N_i)  < B(\\alpha, \\beta_{\\text{post}})$。所以，对于每个支系 $i$，$\\log \\Pr_i  < 0$。这些负项的平均值 $L_{\\text{DEC+J}}$ 也必然为负。因此条件 $L_{\\text{DEC+J}} > 0$ 为假。结果是 **False**。\n\n**结论**\n该分析严谨地建立了一个简单的决策规则：条件 $\\Delta > 0$ 成立当且仅当数据集中至少包含一个观测到的奠基者事件（$K_i > 0$）。出于形式上的严谨，代码实现将执行完整的计算，但这个推导出的规则为结果提供了一个独立的验证。\n\n-   **数据集 $\\mathcal{D}_1$**：包含 $K=2$、$K=1$ 的支系。结果必须为 **True**。\n-   **数据集 $\\mathcal{D}_2$**：所有支系的 $K=0$。结果必须为 **False**。\n-   **数据集 $\\mathcal{D}_3$**：包含一个 $K=1$ 的支系。结果必须为 **True**。\n\n因此，预期的输出是 `[True,False,True]`。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import betaln\nfrom scipy.special import comb as scipy_comb\nfrom math import log\n\ndef compute_delta_positive(data, alpha, beta):\n    \"\"\"\n    Computes if the mean log predictive density of DEC+J is strictly greater\n    than that of DEC using leave-one-clade-out cross-validation.\n\n    This corresponds to checking if Delta > 0.\n    \"\"\"\n    n = len(data)\n    if n == 0:\n        # Undefined for empty dataset, but problem context implies n > 0.\n        return False\n\n    # Calculate total sums over the entire dataset once to optimize the loop.\n    total_K = sum(k for _, k in data)\n    total_N = sum(n_val for n_val, _ in data)\n    total_N_minus_K = total_N - total_K\n\n    # 1. Compute the average log predictive density for the DEC model.\n    # If any K_i > 0, Pr(K_i | DEC) = 0, so log(Pr) = -inf. The average is -inf.\n    # If all K_i = 0, Pr(K_i | DEC) = 1, so log(Pr) = 0. The average is 0.\n    avg_logpd_dec = -np.inf if total_K > 0 else 0.0\n\n    # 2. Compute the average log predictive density for the DEC+J model.\n    sum_logpd_decj = 0.0\n    for i in range(n):\n        # The i-th clade is the hold-out set.\n        N_i, K_i = data[i]\n\n        # The remaining n-1 clades are the training set.\n        # Calculate sums for the training set by subtracting the hold-out clade's contribution.\n        sum_K_train = total_K - K_i\n        sum_N_minus_K_train = total_N_minus_K - (N_i - K_i)\n\n        # Update prior to get posterior hyperparameters based on the training set.\n        alpha_post = alpha + sum_K_train\n        beta_post = beta + sum_N_minus_K_train\n\n        # Calculate the log of the beta-binomial predictive probability for the hold-out clade.\n        # log Pr(K_i|...) = log(C(N_i, K_i)) + betaln(a_post+K_i, b_post+N_i-K_i) - betaln(a_post, b_post)\n        \n        # Using scipy.special.comb with exact=False to get a float for log calculation.\n        # comb(N, K) is 0 if K > N or K < 0.\n        c = scipy_comb(N_i, K_i, exact=False)\n        \n        if c == 0:\n            # This case corresponds to Pr=0, so log(Pr) = -inf.\n            # It should not happen with valid problem data where 0 <= K <= N.\n            log_prob_i = -np.inf\n        else:\n            log_binom_coeff = log(c)\n            # Use scipy's betaln for the log of the Beta function.\n            log_beta_numerator = betaln(alpha_post + K_i, beta_post + N_i - K_i)\n            log_beta_denominator = betaln(alpha_post, beta_post)\n            log_prob_i = log_binom_coeff + log_beta_numerator - log_beta_denominator\n        \n        sum_logpd_decj += log_prob_i\n\n    avg_logpd_decj = sum_logpd_decj / n\n    \n    # 3. The condition is Delta > 0, which is equivalent to avg_logpd_decj > avg_logpd_dec.\n    return avg_logpd_decj > avg_logpd_dec\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis on the test suite and print the results.\n    \"\"\"\n    # Define the hyperparameters for the Beta prior on p_J.\n    alpha = 1.0\n    beta = 19.0\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Dataset D1: Some founder events observed.\n        [(12, 2), (9, 0), (15, 1), (8, 0), (10, 0), (11, 1)],\n        # Dataset D2: No founder events observed.\n        [(12, 0), (9, 0), (15, 0), (8, 0), (10, 0)],\n        # Dataset D3: A single founder event observed.\n        [(5, 0), (7, 0), (6, 0), (8, 0), (10, 1)],\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_delta_positive(case, alpha, beta)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The map(str,...) correctly converts Python booleans (True, False)\n    # into the required strings \"True\" and \"False\".\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solution.\nsolve()\n```", "id": "2705112"}]}