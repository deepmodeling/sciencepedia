{"hands_on_practices": [{"introduction": "仿真是理解随机过程的基石。在分析真实数据之前，首先对我们的模型如何产生各种模式建立一个生成性的理解是极其宝贵的。本练习将引导您从Ornstein-Uhlenbeck (OU) 过程的定义性随机微分方程出发，推导出其在单个分支上的精确条件分布。通过将其作为在整个系统发育树上的模拟算法来实现，您将对选择强度 ($\\alpha$) 和随机速率 ($\\sigma$) 等参数如何与树结构相互作用以塑造性状变异，获得具体而深刻的直觉。[@problem_id:2735150]", "problem": "设计一个程序，用于模拟一个连续性状在有根、有向的系统发育树的枝上，根据奥恩斯坦-乌伦贝克（OU）过程的演化。从奥恩斯坦-乌伦贝克过程作为由标准布朗运动驱动的线性随机微分方程解的基本定义出发。具体来说，使用以下随机微分方程\n$$\ndX_t = \\alpha \\left(\\theta - X_t\\right)\\,dt + \\sigma\\, dB_t,\n$$\n其中 $X_t$ 是时间 $t$ 时的性状值，$B_t$ 是标准布朗运动，$\\alpha \\ge 0$ 是朝向最适值 $\\theta \\in \\mathbb{R}$ 的稳定化选择强度，$\\sigma \\ge 0$ 是扩散系数。假设一个分支在时间 $0$ 从父节点开始，其值为 $X_0 = x_{\\text{parent}}$，并在时间 $t > 0$ 于子节点结束。\n\n任务1（推导）：从上述随机微分方程和 Itô 积分的标准结果出发，推导在给定 $X_0 = x_{\\text{parent}}$ 的条件下，$X_t$ 对任意 $t \\ge 0$ 的条件分布。提供条件均值和条件方差作为 $t$、$\\alpha$、$\\sigma$、$\\theta$ 和 $x_{\\text{parent}}$ 的函数的显式表达式。然后，推导当 $\\alpha \\to 0$ 时的连续时间极限，并展示它如何退化为沿分支的布朗运动。你的推导必须证明为什么线性解中的 Itô 积分均值为零，并使用 Itô 等距性计算其方差。\n\n任务2（算法设计）：使用任务1中得到的条件分布作为沿分支的转移核，为一棵有根树设计一个模拟程序：\n- 树以有向边 $(p, c, \\ell)$ 的列表形式给出，其中 $p$ 是父节点索引，$c$ 是子节点索引，$\\ell \\ge 0$ 是枝长（从 $p$到 $c$ 的时间）。同时提供根节点索引及其初始性状值 $x_{\\text{root}}$。\n- 从根节点开始，以任何有效的拓扑顺序遍历树，模拟每个节点的性状值。对于每条边，使用其父节点的性状值作为条件值，从任务1中推导的条件分布中抽样子节点的值。对于 $\\alpha = 0$ 的情况，使用你推导出的布朗运动极限，以避免除以零。对于 $\\ell = 0$ 的情况，证明子节点几乎必然等于父节点。\n- 为了在 $\\alpha$ 非常小且 $\\ell > 0$ 时保证数值稳定性，你必须将低于某个小阈值的 $\\alpha$ 视为零，并回退到布朗运动极限。为双精度算术选择一个合适的阈值，并在你的解决方案中证明其合理性。\n\n任务3（实现与输出）：在一个程序中实现该模拟，该程序使用伪随机数生成器，并为每个测试用例独立设定种子。对于每个分支的转移，抽取一个独立的标准正态变量来构建具有适当方差的正态增量。对于每个测试用例，按节点索引的升序输出所有末端（叶）节点的模拟性状值。将报告的每个浮点数结果四舍五入到小数点后恰好六位。\n\n测试套件：\n使用以下四个测试用例。对于每个测试用例，程序必须将伪随机数生成器重新初始化为指定的种子，模拟树的演化，并按所述方式收集末端值。\n\n- 测试用例1（单分支，一般OU过程）：\n  - 参数：$\\alpha = 0.5$, $\\sigma = 1.2$, $\\theta = 2.0$, $x_{\\text{root}} = 0.0$。\n  - 树：边 $[(0,1,1.0)]$，根节点 $0$。\n  - 种子：$7$。\n  - 此用例的输出：节点 $1$ 处的单个末端值，为浮点数，四舍五入至六位小数。\n\n- 测试用例2（零长度分支，退化检查）：\n  - 参数：$\\alpha = 0.7$, $\\sigma = 2.0$, $\\theta = 10.0$, $x_{\\text{root}} = 1.23$。\n  - 树：边 $[(0,1,0.0)]$，根节点 $0$。\n  - 种子：$11$。\n  - 此用例的输出：节点 $1$ 处的单个末端值，为浮点数，四舍五入至六位小数。\n\n- 测试用例3（小型分叉树，多末端OU过程）：\n  - 参数：$\\alpha = 2.0$, $\\sigma = 0.8$, $\\theta = -1.0$, $x_{\\text{root}} = 3.0$。\n  - 树：边 $[(0,1,0.5),(1,3,0.3),(0,2,0.7),(2,4,0.2)]$，根节点 $0$。\n  - 种子：$13$。\n  - 此用例的输出：一个列表，包含节点 $[3,4]$ 处的两个末端值，按升序排列，每个值四舍五入至六位小数。\n\n- 测试用例4（布朗运动极限，$\\alpha = 0$）：\n  - 参数：$\\alpha = 0.0$, $\\sigma = 1.5$, $\\theta = 0.0$, $x_{\\text{root}} = -0.5$。\n  - 树：边 $[(0,1,0.4),(1,2,0.6)]$，根节点 $0$。\n  - 种子：$17$。\n  - 此用例的输出：节点 $2$ 处的单个末端值，为浮点数，四舍五入至六位小数。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含四个测试用例的结果，形式为一个逗号分隔的列表，并用方括号括起来。条目必须按上述测试用例的顺序出现。对于有多个末端的用例，将该用例的结果报告为一个列表。例如，输出必须类似于\n[float_case1,float_case2,[float_tip3,float_tip4],float_case4]\n其中每个浮点数都四舍五入到六位小数，并且不打印任何额外文本。", "solution": "问题陈述已经过审查，并被确定为有效。它在科学上是合理的，数学上是适定的，并为计算演化生物学中的一个标准模拟任务提供了完整而明确的规范。因此，我们可以着手解决。\n\n任务是推导奥恩斯坦-乌伦贝克（OU）过程的转移概率核，然后应用它来模拟系统发育树上的性状演化。解决方案按要求分为三个部分：数学推导、算法设计和实现说明。\n\n### 任务1：条件分布的推导\n\n给定奥恩斯坦-乌伦贝克随机微分方程（SDE）：\n$$\ndX_t = \\alpha (\\theta - X_t) dt + \\sigma dB_t\n$$\n其中 $X_t$ 是时间 $t$ 时的性状值，$\\alpha \\ge 0$ 是选择强度，$\\theta \\in \\mathbb{R}$ 是最适性状值，$\\sigma \\ge 0$ 是扩散率，而 $B_t$ 是标准维纳过程（布朗运动）。给定初始条件 $X_0 = x_{\\text{parent}}$。\n\n为求解此线性SDE，我们将其重排为标准形式：\n$$\ndX_t + \\alpha X_t dt = \\alpha \\theta dt + \\sigma dB_t\n$$\n我们采用积分因子的方法。设积分因子为 $I_t = e^{\\int \\alpha \\,ds} = e^{\\alpha t}$。我们定义一个新过程 $Y_t = X_t I_t = X_t e^{\\alpha t}$。根据 Itô 乘积法则，微分 $dY_t$ 为：\n$$\ndY_t = d(X_t e^{\\alpha t}) = (\\alpha X_t e^{\\alpha t}) dt + e^{\\alpha t} dX_t\n$$\n注意，涉及 $(dX_t)^2$ 的二阶项为零，因为 $\\frac{\\partial^2}{\\partial X_t^2} (X_t e^{\\alpha t}) = 0$。代入 $dX_t$ 的表达式：\n$$\ndY_t = \\alpha X_t e^{\\alpha t} dt + e^{\\alpha t} \\left( \\alpha \\theta dt - \\alpha X_t dt + \\sigma dB_t \\right)\n$$\n包含 $X_t$ 的项相互抵消，这正是积分因子的目的。\n$$\ndY_t = \\alpha \\theta e^{\\alpha t} dt + \\sigma e^{\\alpha t} dB_t\n$$\n我们将此表达式从 $s=0$ 积分到 $s=t$：\n$$\n\\int_0^t dY_s = Y_t - Y_0 = \\int_0^t \\alpha \\theta e^{\\alpha s} ds + \\int_0^t \\sigma e^{\\alpha s} dB_s\n$$\n代回 $Y_t = X_t e^{\\alpha t}$ 和 $Y_0 = X_0 e^0 = X_0 = x_{\\text{parent}}$：\n$$\nX_t e^{\\alpha t} - x_{\\text{parent}} = \\alpha \\theta \\left[ \\frac{1}{\\alpha} e^{\\alpha s} \\right]_0^t + \\sigma \\int_0^t e^{\\alpha s} dB_s\n$$\n$$\nX_t e^{\\alpha t} - x_{\\text{parent}} = \\theta (e^{\\alpha t} - 1) + \\sigma \\int_0^t e^{\\alpha s} dB_s\n$$\n通过乘以 $e^{-\\alpha t}$ 来解出 $X_t$：\n$$\nX_t = x_{\\text{parent}} e^{-\\alpha t} + \\theta (1 - e^{-\\alpha t}) + \\sigma e^{-\\alpha t} \\int_0^t e^{\\alpha s} dB_s\n$$\n该随机积分可以通过改变积分变量的参照系来重写：\n$$\nX_t = x_{\\text{parent}} e^{-\\alpha t} + \\theta(1 - e^{-\\alpha t}) + \\sigma \\int_0^t e^{-\\alpha(t-s)} dB_s\n$$\n这是 $X_t$ 的正式解。$X_t$ 在给定 $X_0 = x_{\\text{parent}}$ 条件下的分布是正态分布，因为它是确定性部分与一个 Itô 积分的和，而 Itô 积分是一个高斯过程。我们现在求其条件均值和方差。\n\n**条件均值：**\n条件期望 $E[X_t | X_0 = x_{\\text{parent}}]$ 是：\n$$\nE[X_t | X_0] = E \\left[ x_{\\text{parent}} e^{-\\alpha t} + \\theta(1 - e^{-\\alpha t}) + \\sigma \\int_0^t e^{-\\alpha(t-s)} dB_s \\right]\n$$\n根据期望的线性性质，且前两项在给定 $X_0$ 时是确定性的：\n$$\nE[X_t | X_0] = x_{\\text{parent}} e^{-\\alpha t} + \\theta(1 - e^{-\\alpha t}) + \\sigma E \\left[ \\int_0^t e^{-\\alpha(t-s)} dB_s \\right]\n$$\nItô 积分的一个基本性质是，对于任何确定性的、平方可积的函数 $f(s)$，其期望为零：$E[\\int_0^t f(s) dB_s] = 0$。被积函数 $e^{-\\alpha(t-s)}$ 是 $s$ 的确定性函数。因此，积分项的期望为 $0$。\n条件均值为：\n$$\n\\mu_t = E[X_t | X_0 = x_{\\text{parent}}] = x_{\\text{parent}} e^{-\\alpha t} + \\theta(1 - e^{-\\alpha t})\n$$\n\n**条件方差：**\n条件方差为 $\\text{Var}(X_t | X_0 = x_{\\text{parent}})$。确定性项对方差没有贡献。\n$$\nV_t = \\text{Var}(X_t | X_0) = \\text{Var} \\left( \\sigma \\int_0^t e^{-\\alpha(t-s)} dB_s \\right) = \\sigma^2 \\text{Var} \\left( \\int_0^t e^{-\\alpha(t-s)} dB_s \\right)\n$$\n我们使用 Itô 等距性，该性质表明 $\\text{Var}(\\int_0^t f(s) dB_s) = E[(\\int_0^t f(s) dB_s)^2] = \\int_0^t E[f(s)^2] ds$。由于我们的被积函数 $f(s) = e^{-\\alpha(t-s)}$ 是确定性的，这简化为 $\\int_0^t f(s)^2 ds$。\n$$\nV_t = \\sigma^2 \\int_0^t \\left( e^{-\\alpha(t-s)} \\right)^2 ds = \\sigma^2 \\int_0^t e^{-2\\alpha(t-s)} ds = \\sigma^2 e^{-2\\alpha t} \\int_0^t e^{2\\alpha s} ds\n$$\n该积分的计算结果为：\n$$\n\\int_0^t e^{2\\alpha s} ds = \\left[ \\frac{1}{2\\alpha} e^{2\\alpha s} \\right]_0^t = \\frac{1}{2\\alpha} (e^{2\\alpha t} - 1)\n$$\n将此结果代回方差表达式，对于 $\\alpha > 0$：\n$$\nV_t = \\sigma^2 e^{-2\\alpha t} \\frac{1}{2\\alpha} (e^{2\\alpha t} - 1) = \\frac{\\sigma^2}{2\\alpha} (1 - e^{-2\\alpha t})\n$$\n因此，对于长度为 $t$ 的分支，条件分布为 $X_t | X_0=x_{\\text{parent}} \\sim \\mathcal{N}(\\mu_t, V_t)$。\n\n**布朗运动的渐近极限（$\\alpha \\to 0$）：**\n在 $\\alpha \\rightarrow 0$ 的极限下，SDE 中的选择项消失，方程变为 $dX_t = \\sigma dB_t$。其解为 $X_t = X_0 + \\sigma B_t$，这是一个漂移为 $0$、初始值为 $X_0$、方差为 $\\sigma^2 t$ 的布朗运动。我们现在证明我们推导出的条件矩收敛于此。\n- **均值极限：**\n$$\n\\lim_{\\alpha \\to 0} \\mu_t = \\lim_{\\alpha \\to 0} \\left( x_{\\text{parent}} e^{-\\alpha t} + \\theta(1 - e^{-\\alpha t}) \\right) = x_{\\text{parent}} \\cdot 1 + \\theta(1-1) = x_{\\text{parent}}\n$$\n这与极限布朗运动的均值相匹配。\n- **方差极限：** $V_t$ 的极限是一个 $0/0$ 的不定式。我们对 $\\alpha$ 应用洛必达法则。\n$$\n\\lim_{\\alpha \\to 0} V_t = \\lim_{\\alpha \\to 0} \\frac{\\sigma^2(1 - e^{-2\\alpha t})}{2\\alpha} = \\frac{\\sigma^2}{2} \\lim_{\\alpha \\to 0} \\frac{\\frac{d}{d\\alpha}(1 - e^{-2\\alpha t})}{\\frac{d}{d\\alpha}(\\alpha)} = \\frac{\\sigma^2}{2} \\lim_{\\alpha \\to 0} \\frac{2t e^{-2\\alpha t}}{1} = \\sigma^2 t\n$$\n这与极限布朗运动的方差相匹配。因此，奥恩斯坦-乌伦贝克过程在 $\\alpha \\to 0$ 时正确地收敛于布朗运动。\n\n### 任务2：算法设计\n\n模拟过程通过从根到末端遍历系统发育树来进行。子节点的性状值从上面推导的条件正态分布中抽取，其中父节点的性状值作为初始条件 $x_{\\text{parent}}$，枝长作为时间持续 $t$。\n\n**树的遍历：** 树被指定为有向边 $(p, c, \\ell)$ 的列表。为确保父节点在其子节点之前处理，从根节点开始的广度优先搜索（BFS）是一种自然且正确的方法。我们可以使用一个以根节点初始化的队列。我们还需要一个数据结构，如字典，来存储每个节点的模拟性状值。\n\n**模拟程序：**\n1.  从输入的边列表构建树的邻接表表示，例如，一个将父节点映射到（子节点，长度）元组列表的字典。\n2.  用根节点索引初始化一个队列，并用根的初始性状值初始化一个字典 `trait_values`。\n3.  当队列不为空时：\n    a. 从队列中取出一个父节点 $p$。设其性状值为 $x_p$。\n    b. 对于每个通过长度为 $\\ell$ 的分支与 $p$ 相连的子节点 $c$：\n        i. 计算给定 $X_0=x_p$ 时 $X_\\ell$ 的条件分布参数。\n        ii. 从标准正态分布中抽取一个随机变量 $Z \\sim \\mathcal{N}(0,1)$。\n        iii. 计算子节点的性状值 $x_c = \\mu_\\ell + \\sqrt{V_\\ell} \\cdot Z$。\n        iv. 将 $x_c$ 存储在 `trait_values` 中，并将 $c$ 入队。\n4.  遍历完成后，识别出末端节点（即不作为父节点的节点）。\n5.  提取末端节点的性状值，并按节点索引排序。\n\n**特殊情况处理：**\n- **零长度分支（$\\ell = 0$）：**\n  如果 $\\ell=0$，均值变为 $\\mu_0 = x_p e^0 + \\theta(1-e^0) = x_p$。方差变为 $V_0 = \\frac{\\sigma^2}{2\\alpha}(1-e^0) = 0$。分布退化为在 $x_p$ 处的一个点质量。因此，$X_0 = x_p$ 几乎必然成立。子节点的值必须设置得与父节点的值相等。不抽取随机数。\n\n- **布朗运动极限（小 $\\alpha$）：**\n  方差表达式 $V_t = \\frac{\\sigma^2}{2\\alpha}(1-e^{-2\\alpha t})$ 由于在项 $(1 - e^{-2\\alpha t})$ 中存在灾难性抵消，在 $\\alpha$ 很小时数值上不稳定。虽然像 `expm1` 这样的专用函数可以缓解此问题，但题目要求在 $\\alpha$ 低于某个阈值时，明确切换到布朗运动极限。\n  我们必须选择一个阈值。对于标准的双精度浮点运算，像 $\\alpha_{\\text{thresh}} = 10^{-8}$ 这样的值是合适的。如果给定的 $\\alpha$ 小于此阈值，我们必须使用布朗运动公式：\n  - 均值：$\\mu_t = x_p$\n  - 方差：$V_t = \\sigma^2 t$\n  这种方法是合理的，因为对于 $\\alpha < 10^{-8}$ 和典型的枝长 $\\ell \\sim O(1)$，参数 $x = 2\\alpha t$ 足够小，使得泰勒级数近似 $1-e^{-x} \\approx x - x^2/2!$ 高度精确。使用一阶项，$V_t \\approx \\frac{\\sigma^2}{2\\alpha}(2\\alpha t) = \\sigma^2 t$，这正是布朗运动的方差。这种切换可以防止浮点误差，并正确地捕捉了极限行为。\n\n### 任务3：实现细节\n\n该算法使用 Python 的 `numpy` 库实现。\n- **数据结构**：树的边被处理成一个邻接表（一个 Python 字典）。节点的性状值也存储在一个字典中。\n- **随机数生成**：对于每个测试用例，使用 `numpy.random.default_rng` 和指定的种子创建一个新的伪随机数生成器。这确保了可复现性。对于每个需要随机分量的分支转移，使用生成器的 `normal()` 方法抽取一个标准正态变量。\n- **寻找末端节点**：末端节点被识别为所有在树定义中出现但从未在边列表中作为父节点出现的节点。将它们收集起来并按其整数索引排序，以确保正确的输出顺序。\n- **输出格式**：收集每个测试用例的结果。使用一个自定义的格式化函数来生成最终的输出字符串，该字符串必须与指定的格式 `[result1,result2,[tipA,tipB],...]` 完全匹配，所有浮点数都四舍五入到六位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\nimport math\n\n# No other libraries are used. The scipy library listed in the environment\n# description is not necessary for solving this problem.\n\ndef simulate_ou_on_tree(alpha, sigma, theta, x_root, root_node, edges, seed):\n    \"\"\"\n    Simulates trait evolution on a phylogenetic tree under the Ornstein-Uhlenbeck process.\n    \"\"\"\n    # Initialize the pseudorandom number generator for this test case\n    rng = np.random.default_rng(seed)\n    \n    # Store trait values for each node\n    trait_values = {root_node: x_root}\n    \n    # Build adjacency list for easy traversal: parent -> list of (child, length)\n    adj = defaultdict(list)\n    parent_nodes = set()\n    all_nodes = set([root_node])\n    for p, c, l in edges:\n        adj[p].append((c, l))\n        parent_nodes.add(p)\n        all_nodes.add(p)\n        all_nodes.add(c)\n\n    # Simulation using a breadth-first traversal\n    queue = [root_node]\n    \n    # Small alpha threshold for numerical stability\n    ALPHA_THRESHOLD = 1e-8\n\n    while queue:\n        p = queue.pop(0)\n        x_p = trait_values[p]\n        \n        if p in adj:\n            for c, l in adj[p]:\n                x_c = 0.0\n                \n                # Case 1: Zero-length branch, child value equals parent value\n                if l == 0.0:\n                    x_c = x_p\n                # Case 2: Brownian motion limit (alpha is zero or very small)\n                elif alpha < ALPHA_THRESHOLD:\n                    mean = x_p\n                    variance = sigma**2 * l\n                    std_dev = math.sqrt(variance)\n                    # Draw a standard normal variate\n                    z = rng.normal()\n                    x_c = mean + std_dev * z\n                # Case 3: General Ornstein-Uhlenbeck process\n                else:\n                    exp_al = math.exp(-alpha * l)\n                    mean = x_p * exp_al + theta * (1.0 - exp_al)\n                    \n                    # Note on variance calculation:\n                    # 1 - exp(-2*alpha*l) can be written as -expm1(-2*alpha*l) \n                    # for better precision with small arguments. However, our explicit\n                    # thresholding for small alpha makes this optimization redundant.\n                    variance = (sigma**2 / (2.0 * alpha)) * (1.0 - math.exp(-2.0 * alpha * l))\n                    std_dev = math.sqrt(variance)\n                    # Draw a standard normal variate\n                    z = rng.normal()\n                    x_c = mean + std_dev * z\n                \n                trait_values[c] = x_c\n                queue.append(c)\n\n    # Identify tip (leaf) nodes: nodes that are not parents\n    tip_nodes = sorted(list(all_nodes - parent_nodes))\n    \n    # Collect results for tip nodes\n    tip_values = [trait_values[tip] for tip in tip_nodes]\n    \n    if len(tip_values) == 1:\n        return round(tip_values[0], 6)\n    else:\n        return [round(v, 6) for v in tip_values]\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the OU simulation problem.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (single branch, general OU)\n        {\n            \"params\": {\"alpha\": 0.5, \"sigma\": 1.2, \"theta\": 2.0},\n            \"tree\": {\"x_root\": 0.0, \"root_node\": 0, \"edges\": [(0, 1, 1.0)]},\n            \"seed\": 7\n        },\n        # Test case 2 (zero-length branch, degeneracy check)\n        {\n            \"params\": {\"alpha\": 0.7, \"sigma\": 2.0, \"theta\": 10.0},\n            \"tree\": {\"x_root\": 1.23, \"root_node\": 0, \"edges\": [(0, 1, 0.0)]},\n            \"seed\": 11\n        },\n        # Test case 3 (small bifurcating tree, multi-tip OU)\n        {\n            \"params\": {\"alpha\": 2.0, \"sigma\": 0.8, \"theta\": -1.0},\n            \"tree\": {\"x_root\": 3.0, \"root_node\": 0, \"edges\": [(0, 1, 0.5), (1, 3, 0.3), (0, 2, 0.7), (2, 4, 0.2)]},\n            \"seed\": 13\n        },\n        # Test case 4 (Brownian-motion limit, alpha = 0)\n        {\n            \"params\": {\"alpha\": 0.0, \"sigma\": 1.5, \"theta\": 0.0},\n            \"tree\": {\"x_root\": -0.5, \"root_node\": 0, \"edges\": [(0, 1, 0.4), (1, 2, 0.6)]},\n            \"seed\": 17\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = simulate_ou_on_tree(\n            alpha=case[\"params\"][\"alpha\"],\n            sigma=case[\"params\"][\"sigma\"],\n            theta=case[\"params\"][\"theta\"],\n            x_root=case[\"tree\"][\"x_root\"],\n            root_node=case[\"tree\"][\"root_node\"],\n            edges=case[\"tree\"][\"edges\"],\n            seed=case[\"seed\"]\n        )\n        results.append(result)\n\n    # Custom formatter to match the specified output string format\n    def format_result(res):\n        if isinstance(res, list):\n            return f\"[{','.join(f'{x:.6f}' for x in res)}]\"\n        else:\n            return f'{res:.6f}'\n\n    formatted_results = [format_result(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2735150"}, {"introduction": "在观察了跨物种的性状数据后，一个主要挑战是如何解释它们共享的进化历史，因为这会导致数据点之间不独立。系统发育独立比较 (Phylogenetic Independent Contrasts, PICs) 是一种奠基性的方法，它假设性状遵循布朗运动 (Brownian motion, BM) 模型演化，并将谱系顶端的数据转换为一组统计上独立且同分布的值。本练习要求您从第一性原理推导出PIC算法，使您深入理解它如何校正系统发育的非独立性，从而能够有效地使用标准的统计检验。[@problem_id:2735174]", "problem": "一个连续性状沿着一个已知的二叉系统发育树，在速率参数为 $\\sigma^{2}$ 的布朗运动过程下演化。因此，在任何长度为 $t$ 的分支上，性状值的变化服从均值为0、方差为 $\\sigma^{2} t$ 的正态分布，并且在给定祖先状态的条件下，不同分支上的变化是相互独立的。系统发育独立比较（PICs）被定义为每个内部节点处后代性状值的线性组合，这些线性组合 (i) 在布朗运动模型下均值为0，(ii) 经过缩放以具有相同的期望方差，以及 (iii) 在不同节点之间相互独立。从这些原理和多元正态分布的标准性质出发，通过以下步骤推导 PICs 的逐节点构建方法：\n- 从一个内部节点的两个直接后代获得该节点祖先状态的逆方差加权估计量，以及将在树的更高层使用的相关传播方差，并且\n- 展示一个节点处的比较是如何由其两个后代的值及其相关方差形成的，包括后代枝长的作用。\n\n然后，将您的推导应用于以下具有4个叶尖的有根系统发育树：\n- 叶尖 $A$ 和 $B$ 在节点 $N_{1}$ 处汇合；枝长分别为 $A$–$N_{1}$ 为 $0.5$，$B$–$N_{1}$ 为 $0.25$。从 $N_{1}$ 到根节点 $R$ 的分支长度为 $0.25$。\n- 叶尖 $C$ 和 $D$ 在节点 $N_{2}$ 处汇合；枝长分别为 $C$–$N_{2}$ 为 $0.5$，$D$–$N_{2}$ 为 $0.25$。从 $N_{2}$ 到根节点 $R$ 的分支长度为 $0.5$。\n- 根节点 $R$ 仅连接到 $N_{1}$ 和 $N_{2}$（$R$ 之上没有分支）。\n\n观测到的叶尖性状值为 $x_{A}=1$, $x_{B}=4$, $x_{C}=2$, $x_{D}=5$。使用您推导的在布朗运动模型下的递归、枝长加权的 PICs 构建方法，计算由两个直接后代 $N_{1}$ 和 $N_{2}$ 在根节点 $R$ 处形成的标准化比较。对于数值计算，取 $\\sigma^{2}=1$。将您的最终数值答案四舍五入到四位有效数字。不要包含单位。", "solution": "该问题是有效的，因为它科学地基于已建立的布朗运动下性状演化理论和系统发育独立比较（PICs）方法。它提法明确、客观，并为得出唯一解提供了所有必要信息。\n\n首先，我们推导在布朗运动（BM）模型下逐节点构建 PICs 的通用公式。设一个内部节点 $k$ 有两个直接后代 $i$ 和 $j$，其性状值分别为 $X_i$ 和 $X_j$。节点 $k$ 处的祖先状态为 $X_k$。从 $k$ 到 $i$ 和 $j$ 的枝长分别为 $v_i$ 和 $v_j$。在 BM 模型下，性状值之间的关系如下：\n$$X_i = X_k + \\epsilon_i, \\quad \\text{其中} \\quad \\epsilon_i \\sim N(0, \\sigma^2 v_i)$$\n$$X_j = X_k + \\epsilon_j, \\quad \\text{其中} \\quad \\epsilon_j \\sim N(0, \\sigma^2 v_j)$$\n随机变量 $\\epsilon_i$ 和 $\\epsilon_j$ 代表沿两个分支发生的独立演化变化。\n\n祖先状态 $X_k$ 的最佳线性无偏估计（BLUE），在此高斯情境下等同于最大似然估计（MLE），是后代状态的逆方差加权平均值。从 $X_k$ 到 $X_i$ 的变化方差为 $\\sigma^2 v_i$，因此 $X_i$ 的权重与 $1/v_i$ 成正比。$X_k$ 的估计量 $\\hat{X}_k$ 为：\n$$\\hat{X}_k = \\frac{\\frac{1}{\\sigma^2 v_i} X_i + \\frac{1}{\\sigma^2 v_j} X_j}{\\frac{1}{\\sigma^2 v_i} + \\frac{1}{\\sigma^2 v_j}} = \\frac{\\frac{X_i}{v_i} + \\frac{X_j}{v_j}}{\\frac{1}{v_i} + \\frac{1}{v_j}} = \\frac{v_j X_i + v_i X_j}{v_i + v_j}$$\n\n一个标准化比较 $C_k$ 是 $X_i$ 和 $X_j$ 的线性组合，其期望值为0且方差为常数。设 $C_k = a_1 X_i + a_2 X_j$。为使期望为0，则 $E[C_k] = E[a_1 X_i + a_2 X_j] = (a_1+a_2) E[X_k] = 0$。这要求 $a_1 + a_2 = 0$，因此 $a_2 = -a_1$。比较必须具有 $C_k = a_1(X_i - X_j)$ 的形式。\n这个比较的方差是：\n$$Var(C_k) = a_1^2 Var(X_i - X_j) = a_1^2 Var((X_k + \\epsilon_i) - (X_k + \\epsilon_j)) = a_1^2 Var(\\epsilon_i - \\epsilon_j)$$\n由于 $\\epsilon_i$ 和 $\\epsilon_j$ 是独立的：\n$$Var(C_k) = a_1^2 (Var(\\epsilon_i) + Var(\\epsilon_j)) = a_1^2 (\\sigma^2 v_i + \\sigma^2 v_j) = a_1^2 \\sigma^2 (v_i + v_j)$$\n为了将此方差标准化为 $\\sigma^2$，我们设 $a_1^2 \\sigma^2 (v_i + v_j) = \\sigma^2$，得到 $a_1 = 1/\\sqrt{v_i + v_j}$。因此，标准化比较为：\n$$C_k = \\frac{X_i - X_j}{\\sqrt{v_i + v_j}}$$\n\n为了使不同节点间的比较相互独立，比较 $C_k$ 必须与传递到树上层的估计祖先状态 $\\hat{X}_k$ 统计独立。我们通过证明它们的协方差为零来验证这一点。使用以基于 $X_k$ 的独立误差项 $\\epsilon_i$ 和 $\\epsilon_j$ 表示的表达式：\n$$C_k = \\frac{\\epsilon_i - \\epsilon_j}{\\sqrt{v_i + v_j}}$$\n$$\\hat{X}_k - X_k = \\frac{v_j \\epsilon_i + v_i \\epsilon_j}{v_i + v_j}$$\n$$Cov(C_k, \\hat{X}_k - X_k) = \\frac{1}{\\sqrt{v_i+v_j}(v_i+v_j)} Cov(\\epsilon_i - \\epsilon_j, v_j \\epsilon_i + v_i \\epsilon_j)$$\n$$= \\frac{1}{(\\cdot)} [v_j Var(\\epsilon_i) - v_i Var(\\epsilon_j)] = \\frac{1}{(\\cdot)} [v_j(\\sigma^2 v_i) - v_i(\\sigma^2 v_j)] = 0$$\n由于它们是正态变量的线性组合，零协方差意味着独立性。\n\n最后，对于递归算法，我们将值为 $\\hat{X}_k$ 的估计节点 $k$ 视为一个新的叶尖。通往这个新叶尖的分支必须进行调整。设从 $k$ 的父节点（节点 $p$）到 $k$ 的原始分支长度为 $v_{kp}$。$\\hat{X}_k$ 相对于父节点状态 $X_p$ 的方差定义了新的有效枝长。\n$$Var(\\hat{X}_k - X_p) = Var(\\hat{X}_k - X_k + X_k - X_p) = Var(\\hat{X}_k - X_k) + Var(X_k - X_p)$$\n这两项是独立的。我们有 $Var(X_k - X_p) = \\sigma^2 v_{kp}$。估计误差的方差为：\n$$Var(\\hat{X}_k - X_k) = Var\\left(\\frac{v_j \\epsilon_i + v_i \\epsilon_j}{v_i + v_j}\\right) = \\frac{v_j^2 Var(\\epsilon_i) + v_i^2 Var(\\epsilon_j)}{(v_i + v_j)^2} = \\frac{v_j^2 \\sigma^2 v_i + v_i^2 \\sigma^2 v_j}{(v_i + v_j)^2} = \\frac{\\sigma^2 v_i v_j (v_i + v_j)}{(v_i + v_j)^2} = \\sigma^2 \\frac{v_i v_j}{v_i + v_j}$$\n所以，$Var(\\hat{X}_k - X_p) = \\sigma^2 v_{kp} + \\sigma^2 \\frac{v_i v_j}{v_i + v_j} = \\sigma^2 \\left(v_{kp} + \\frac{v_i v_j}{v_i + v_j}\\right)$。从 $p$ 到 $k$ 的新枝长，记作 $v'_{kp}$，变为 $v_{kp} + \\frac{v_i v_j}{v_i + v_j}$。项 $\\frac{v_i v_j}{v_i + v_j}$ 代表从估计中传播的误差，被转换成等效的枝长。\n\n现在我们将此算法应用于给定的系统发育树，其中 $\\sigma^2=1$。\n树结构为：$((A:0.5, B:0.25)N_1:0.25, (C:0.5, D:0.25)N_2:0.5)R$。\n叶尖值为 $x_A=1$, $x_B=4$, $x_C=2$, $x_D=5$。\n\n步骤1：处理节点 $N_1$（A, B的祖先）。\n- 枝长：$v_A=0.5$, $v_B=0.25$。\n- 在 $N_1$ 处的估计状态：\n$$\\hat{x}_{N_1} = \\frac{x_A/v_A + x_B/v_B}{1/v_A + 1/v_B} = \\frac{1/0.5 + 4/0.25}{1/0.5 + 1/0.25} = \\frac{2 + 16}{2 + 4} = \\frac{18}{6} = 3$$\n- 从根节点 $R$ 到 $N_1$ 的枝长为 $v_{N_1} = 0.25$。更新后的长度 $v'_{N_1}$ 为：\n$$v'_{N_1} = v_{N_1} + \\frac{v_A v_B}{v_A + v_B} = 0.25 + \\frac{0.5 \\times 0.25}{0.5 + 0.25} = \\frac{1}{4} + \\frac{0.125}{0.75} = \\frac{1}{4} + \\frac{1}{6} = \\frac{3+2}{12} = \\frac{5}{12}$$\n\n步骤2：处理节点 $N_2$（C, D的祖先）。\n- 枝长：$v_C=0.5$, $v_D=0.25$。\n- 在 $N_2$ 处的估计状态：\n$$\\hat{x}_{N_2} = \\frac{x_C/v_C + x_D/v_D}{1/v_C + 1/v_D} = \\frac{2/0.5 + 5/0.25}{1/0.5 + 1/0.25} = \\frac{4 + 20}{2 + 4} = \\frac{24}{6} = 4$$\n- 从根节点 $R$ 到 $N_2$ 的枝长为 $v_{N_2} = 0.5$。更新后的长度 $v'_{N_2}$ 为：\n$$v'_{N_2} = v_{N_2} + \\frac{v_C v_D}{v_C + v_D} = 0.5 + \\frac{0.5 \\times 0.25}{0.5 + 0.25} = \\frac{1}{2} + \\frac{1}{6} = \\frac{3+1}{6} = \\frac{4}{6} = \\frac{2}{3}$$\n\n步骤3：处理根节点 $R$（$N_1$, $N_2$的祖先）。\n- 算法现在将 $N_1$ 和 $N_2$ 视为值为 $\\hat{x}_{N_1}=3$ 和 $\\hat{x}_{N_2}=4$ 的“叶尖”。\n- 从根节点到这些“叶尖”的枝长为 $v'_{N_1} = 5/12$ 和 $v'_{N_2} = 2/3$。\n- 根节点处的标准化比较为：\n$$C_R = \\frac{\\hat{x}_{N_1} - \\hat{x}_{N_2}}{\\sqrt{v'_{N_1} + v'_{N_2}}}$$\n- 枝长之和为：\n$$v'_{N_1} + v'_{N_2} = \\frac{5}{12} + \\frac{2}{3} = \\frac{5}{12} + \\frac{8}{12} = \\frac{13}{12}$$\n- 状态之差为 $\\hat{x}_{N_1} - \\hat{x}_{N_2} = 3 - 4 = -1$。\n- 根节点处的比较为：\n$$C_R = \\frac{-1}{\\sqrt{13/12}} = -\\sqrt{\\frac{12}{13}}$$\n数值上，这个值为 $C_R \\approx -0.9607689...$。四舍五入到四位有效数字得到 $-0.9608$。", "answer": "$$\\boxed{-0.9608}$$", "id": "2735174"}, {"introduction": "Ornstein-Uhlenbeck (OU) 模型引入了一个参数 $\\alpha$，代表稳定选择的强度，但直观地解释其数值可能具有挑战性。一个用于理解 $\\alpha$ 的高度直观的度量是“系统发育半衰期”，即一个谱系的期望性状值回归到进化最优值一半所需的时间。本练习将指导您推导出这个半衰期，并用它来计算一个无量纲的比率，将选择的特征时间尺度与系统发育的整体时间尺度进行比较，从而为您提供一种强有力的方式来将模型发现置于具体情境中进行解释和交流。[@problem_id:2735167]", "problem": "在一个总高度为 $T = 12$ Myr 的超度量系统发育树的叶尖处，测量了 $65$ 个物种的一个连续性状。该性状被建模为遵循 Ornstein–Uhlenbeck (OU) 过程沿树演化，该过程由以下随机微分方程 (SDE) 定义\n$$\ndX_{t} = -\\alpha\\left(X_{t} - \\theta\\right) \\, dt + \\sigma \\, dB_{t},\n$$\n其中 $X_{t}$ 是时间 $t$ 时的性状值，$\\alpha$ 是朝向适应性最优值 $\\theta$ 的稳定选择强度，$\\sigma$ 是随机波动的强度，$B_{t}$ 是标准布朗运动。将此模型通过最大似然法与叶尖数据进行拟合，得到的估计值为 $\\hat{\\alpha} = 0.18$ Myr$^{-1}$。\n\n从上述 OU SDE 定义出发，并仅使用线性 SDE 解的期望的基本性质，推导系统发育半衰期 $t_{1/2}$ 的表达式。$t_{1/2}$ 定义为与最优值 $\\theta$ 的期望偏差减小一半所需的时间。然后计算比率\n$$\nR \\equiv \\frac{t_{1/2}}{T}\n$$\n以评估在系统发育树的时间尺度上稳定选择的相对强度。\n\n仅报告 $R$ 的数值作为最终答案。将您的答案四舍五入到四位有效数字。最终答案应为无单位（无量纲）。", "solution": "该问题要求推导 Ornstein–Uhlenbeck (OU) 过程的系统发育半衰期 $t_{1/2}$，并计算无量纲比率 $R$。分析必须从定义 OU 过程的随机微分方程 (SDE) 所体现的基本原理开始。\n\n给定的 SDE 为：\n$$\ndX_{t} = -\\alpha(X_{t} - \\theta) \\, dt + \\sigma \\, dB_{t}\n$$\n在此，$X_t$ 是性状值，$\\alpha > 0$ 是选择强度，$\\theta$ 是最优值，$\\sigma$ 是随机噪声幅度，$B_t$ 是标准布朗运动。\n\n为求期望轨迹，我们将与最优值的偏差定义为 $Y_{t} = X_{t} - \\theta$。由于 $\\theta$ 是一个常数参数，$Y_t$ 的微分是 $dY_t = dX_t$。将此代入原始 SDE，得到偏差过程的方程：\n$$\ndY_{t} = -\\alpha Y_{t} \\, dt + \\sigma \\, dB_{t}\n$$\n我们关心的是该偏差的期望值。我们对整个方程取期望。利用期望算子的线性性质，我们得到：\n$$\nE[dY_{t}] = E[-\\alpha Y_{t} \\, dt + \\sigma \\, dB_{t}] = -\\alpha E[Y_{t}] \\, dt + \\sigma E[dB_{t}]\n$$\n在标准正则性条件下，微分的期望等于期望的微分，即 $E[dY_{t}] = dE[Y_{t}]$。标准布朗运动过程（模拟随机游走的极限）的一个基本性质是其增量的期望为零。即 $E[dB_{t}] = 0$。这将平均偏差的方程简化为一阶线性齐次常微分方程 (ODE)：\n$$\ndE[Y_{t}] = -\\alpha E[Y_{t}] \\, dt\n$$\n让我们将期望偏差记为 $\\mu(t) = E[Y_t]$。则该 ODE 为：\n$$\n\\frac{d\\mu(t)}{dt} = -\\alpha \\mu(t)\n$$\n该 ODE 可以通过分离变量法求解。假设在时间 $t=0$ 时的初始期望偏差为 $\\mu(0)$：\n$$\n\\int_{\\mu(0)}^{\\mu(t)} \\frac{1}{u} \\, du = \\int_{0}^{t} -\\alpha \\, ds\n$$\n$$\n[\\ln|u|]_{\\mu(0)}^{\\mu(t)} = [-\\alpha s]_{0}^{t}\n$$\n$$\n\\ln|\\mu(t)| - \\ln|\\mu(0)| = -\\alpha t\n$$\n$$\n\\ln\\left(\\frac{|\\mu(t)|}{|\\mu(0)|}\\right) = -\\alpha t\n$$\n对两边取指数，得到时间 $t$ 时期望偏差的解：\n$$\n\\mu(t) = \\mu(0) \\exp(-\\alpha t)\n$$\n用原始过程变量 $X_t$ 表示，即为：\n$$\nE[X_{t} - \\theta] = E[X_{0} - \\theta] \\exp(-\\alpha t)\n$$\n该方程表明，与最优值的期望偏差随时间呈指数衰减。\n\n系统发育半衰期 $t_{1/2}$ 定义为与最优值的期望偏差减小一半所需的时间。因此，我们设 $\\mu(t_{1/2}) = \\frac{1}{2} \\mu(0)$：\n$$\n\\frac{1}{2} \\mu(0) = \\mu(0) \\exp(-\\alpha t_{1/2})\n$$\n假设初始期望偏差非零，即 $\\mu(0) \\neq 0$，我们可以除以 $\\mu(0)$：\n$$\n\\frac{1}{2} = \\exp(-\\alpha t_{1/2})\n$$\n为解出 $t_{1/2}$，我们对两边取自然对数：\n$$\n\\ln\\left(\\frac{1}{2}\\right) = -\\alpha t_{1/2}\n$$\n$$\n-\\ln(2) = -\\alpha t_{1/2}\n$$\n这就给出了半衰期的解析表达式：\n$$\nt_{1/2} = \\frac{\\ln(2)}{\\alpha}\n$$\n问题要求计算比率 $R = \\frac{t_{1/2}}{T}$，其中 $T$ 是系统发育树的总高度。我们代入 $t_{1/2}$ 的表达式：\n$$\nR = \\frac{\\ln(2)}{\\alpha T}\n$$\n我们已知估计参数 $\\hat{\\alpha} = 0.18$ Myr$^{-1}$ 和树高 $T = 12$ Myr。使用 $\\hat{\\alpha}$ 代替 $\\alpha$，我们计算 $R$ 的数值：\n$$\nR = \\frac{\\ln(2)}{(0.18 \\text{ Myr}^{-1})(12 \\text{ Myr})} = \\frac{\\ln(2)}{2.16}\n$$\n单位 Myr$^{-1}$ 和 Myr 相互抵消，得到所要求的无量纲比率。计算如下：\n$$\nR \\approx \\frac{0.69314718}{2.16} \\approx 0.32090147\n$$\n将此值四舍五入到四位有效数字，得到 $0.3209$。", "answer": "$$\\boxed{0.3209}$$", "id": "2735167"}]}