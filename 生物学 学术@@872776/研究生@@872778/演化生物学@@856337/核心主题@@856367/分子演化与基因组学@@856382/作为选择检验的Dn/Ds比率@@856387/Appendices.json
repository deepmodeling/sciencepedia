{"hands_on_practices": [{"introduction": "本练习将引导你从第一性原理出发，完成一次基础的 $dN/dS$ 比率计算。通过将 Nei-Gojobori 方法和 Jukes-Cantor 校正模型应用于一对假设的低分歧序列，你将巩固对同义和非同义位点计数以及如何校正多次替换的理解。在学习更复杂的模型之前，这个实践对于掌握 $\\omega$ 估算的核心组成部分至关重要 [@problem_id:2757639]。", "problem": "两个直系同源编码序列的成对序列比对显示出低分化度。你将使用 Jukes–Cantor (JC) 模型下的 Nei–Gojobori (NG86) 方法来估计每个非同义位点的非同义替换率 ($dN$)、每个同义位点的同义替换率 ($dS$) 及其比率 $\\omega \\equiv dN/dS$，然后通过将差异计数近似为泊松分布，为 $\\omega$ 构建一个保守的置信区间。\n\n假设以下科学上合理的设定和数据。\n\n- 编码区长度为 $L = 100$ 个密码子（$300$ 个核苷酸），无比对缺口，无内部终止密码子，并适用标准遗传密码。\n- 在标准遗传密码下，逐个密码子进行 NG86 计数，得到该基因中总共有 $S = 78.0$ 个同义位点和 $N = 222.0$ 个非同义位点。\n- 在整个比对中，由 NG86 分类观察到的单核苷酸差异总数为 $X_{S} = 3$ 个同义差异和 $X_{N} = 2$ 个非同义差异。碱基组成近似相等，因此 JC 模型适合作为多次替换的一阶校正。\n- 在 NG86 和 JC 模型下，令 $\\hat{p}_{S} \\equiv X_{S}/S$ 和 $\\hat{p}_{N} \\equiv X_{N}/N$ 分别为每个位点上观察到的同义和非同义差异的比例。JC 校正通过 Jukes–Cantor 模型下的一个单调变换，将观察到的差异比例 $p$ 与进化距离 $d$（每个位点的替换数）联系起来。\n\n任务：\n\n1. 从 $d$ 是每个位点的预期替换数的核心定义出发，并使用 Jukes–Cantor 模型作为一个经过充分检验的替换模型，从 $\\hat{p}_{S}$ 和 $\\hat{p}_{N}$ 推导出 NG86 估计量 $\\hat{d}_{S}$ 和 $\\hat{d}_{N}$，并为给定数据计算 $\\hat{d}_{S}$、$\\hat{d}_{N}$ 和 $\\hat{\\omega} \\equiv \\hat{d}_{N}/\\hat{d}_{S}$ 的数值。\n2. 使用一个保守近似法，其中 $X_{S}$ 和 $X_{N}$ 被视为均值分别为 $\\lambda_{S}$ 和 $\\lambda_{N}$ 的独立泊松计数，为 $\\lambda_{S}$ 和 $\\lambda_{N}$ 构建精确的双侧 Garwood $95\\%$ 置信区间。通过分别除以 $S$ 和 $N$，将这些区间映射为 $p_{S}$ 和 $p_{N}$ 的区间，然后将每个端点转换到 JC 校正的 $d$ 尺度上，以获得保守的 $95\\%$ 区间 $[d_{S}^{L}, d_{S}^{U}]$ 和 $[d_{N}^{L}, d_{N}^{U}]$。\n3. 利用变换的单调性，构建 $\\omega$ 的一个保守 $95\\%$ 置信区间，形式为 $[\\omega^{L}, \\omega^{U}] = [d_{N}^{L}/d_{S}^{U},\\ d_{N}^{U}/d_{S}^{L}]$。\n\n将上端点 $\\omega^{U}$ 作为最终报告值。将最终答案四舍五入至三位有效数字。", "solution": "在尝试任何解答之前，首先将对所提出的问题进行严格的验证程序。\n\n从问题陈述中逐字提取的已知条件如下：\n- 编码区长度为 $L = 100$ 个密码子（$300$ 个核苷酸）。\n- 无比对缺口，无内部终止密码子。\n- 适用标准遗传密码。\n- 同义位点总数（由 NG86 计数）：$S = 78.0$。\n- 非同义位点总数（由 NG86 计数）：$N = 222.0$。\n- 观察到的同义差异总数：$X_{S} = 3$。\n- 观察到的非同义差异总数：$X_{N} = 2$。\n- 将使用 Jukes-Cantor (JC) 模型。\n- 观察到的同义差异比例：$\\hat{p}_{S} \\equiv X_{S}/S$。\n- 观察到的非同义差异比例：$\\hat{p}_{N} \\equiv X_{N}/N$。\n- 进化距离 $d$ 与观察到的差异比例 $p$ 通过 Jukes–Cantor 模型下的一个单调变换相关联。\n- 任务1：使用 JC 模型从 $\\hat{p}_{S}$ 和 $\\hat{p}_{N}$ 推导出 NG86 估计量 $\\hat{d}_{S}$ 和 $\\hat{d}_{N}$，并计算 $\\hat{d}_{S}$、$\\hat{d}_{N}$ 和 $\\hat{\\omega} \\equiv \\hat{d}_{N}/\\hat{d}_{S}$ 的数值。\n- 任务2：通过将 $X_S$ 和 $X_N$ 视为泊松计数并使用 Garwood 区间来计算泊松均值，为 $d_S$ 和 $d_N$ 构建保守的 $95\\%$ 置信区间。\n- 任务3：构建 $\\omega$ 的保守 $95\\%$ 置信区间，形式为 $[\\omega^{L}, \\omega^{U}] = [d_{N}^{L}/d_{S}^{U},\\ d_{N}^{U}/d_{S}^{L}]$，并提供 $\\omega^{U}$ 作为最终答案。\n\n根据验证标准对问题进行审查。该问题具有科学依据，植根于分子进化的标准理论，特别是 Nei-Gojobori 方法和 Jukes-Cantor 替换模型。该问题是良置的，提供了所有必要的数据和清晰、逻辑性强的任务序列，可导出唯一解。语言精确客观。所提供的数据对于低分化度的短基因比对是合理的。问题不违反任何基本原则，不是不完整或矛盾的，并且并非不重要。因此，该问题被认为是有效的，并将提供完整的解答。\n\n**任务1：替换率及其比率的点估计**\n\n首先，我们推导 Jukes-Cantor (JC69) 校正。JC69 模型假设核苷酸频率相等（$1/4$），且任意两个不同核苷酸之间的替换率 $\\alpha$ 相等。核苷酸 $i$ 在时间 $t$ 内变为核苷酸 $j$ 的概率 $P_{ij}(t)$ 由主方程控制。一个位点未发生变化的概率 $P_{ii}(t)$ 遵循以下微分方程：\n$$ \\frac{dP_{ii}(t)}{dt} = -3\\alpha P_{ii}(t) + \\alpha \\sum_{j \\neq i} P_{ji}(t) $$\n由于模型的对称性，对于任何 $j, k \\neq i$ 都有 $P_{ji}(t) = P_{ki}(t)$。此外，$\\sum_{k} P_{ik}(t) = 1$，这意味着 $P_{ii}(t) + 3P_{ji}(t) = 1$。将 $3P_{ji}(t) = 1 - P_{ii}(t)$ 代入微分方程得到：\n$$ \\frac{dP_{ii}(t)}{dt} = -3\\alpha P_{ii}(t) + \\alpha (1-P_{ii}(t)) = \\alpha - 4\\alpha P_{ii}(t) $$\n在初始条件 $P_{ii}(0)=1$ 下，解为：\n$$ P_{ii}(t) = \\frac{1}{4} + \\frac{3}{4}\\exp(-4\\alpha t) $$\n在一个位点上观察到差异的概率 $p$ 是 $1 - P_{ii}(t)$：\n$$ p(t) = 1 - \\left( \\frac{1}{4} + \\frac{3}{4}\\exp(-4\\alpha t) \\right) = \\frac{3}{4} \\left( 1 - \\exp(-4\\alpha t) \\right) $$\n进化距离 $d$ 定义为每个位点的预期替换数。在 JC 模型中，任何核苷酸发生替换的速率是 $3\\alpha$，所以 $d = 3\\alpha t$。将 $4\\alpha t = \\frac{4}{3}d$ 代入 $p(t)$ 的方程得到：\n$$ p = \\frac{3}{4} \\left( 1 - \\exp(-\\frac{4}{3}d) \\right) $$\n反转此方程以 $p$（可观察到的差异比例）来求解 $d$，得到 JC 校正：\n$$ d = -\\frac{3}{4} \\ln\\left(1 - \\frac{4}{3}p\\right) $$\n此关系在 $p  3/4$ 时成立。\n\n现在，我们将此应用于给定数据。\n观察到的差异比例为：\n$$ \\hat{p}_{S} = \\frac{X_{S}}{S} = \\frac{3}{78.0} \\approx 0.03846 $$\n$$ \\hat{p}_{N} = \\frac{X_{N}}{N} = \\frac{2}{222.0} \\approx 0.009009 $$\n使用 JC 校正，我们估计每个位点的替换率：\n$$ \\hat{d}_{S} = -\\frac{3}{4} \\ln\\left(1 - \\frac{4}{3}\\hat{p}_{S}\\right) = -\\frac{3}{4} \\ln\\left(1 - \\frac{4}{3} \\cdot \\frac{3}{78.0}\\right) = -\\frac{3}{4} \\ln\\left(1 - \\frac{4}{78.0}\\right) \\approx 0.03948 $$\n$$ \\hat{d}_{N} = -\\frac{3}{4} \\ln\\left(1 - \\frac{4}{3}\\hat{p}_{N}\\right) = -\\frac{3}{4} \\ln\\left(1 - \\frac{4}{3} \\cdot \\frac{2}{222.0}\\right) = -\\frac{3}{4} \\ln\\left(1 - \\frac{8}{666.0}\\right) \\approx 0.009064 $$\n比率 $\\omega = d_N/d_S$ 的点估计为：\n$$ \\hat{\\omega} = \\frac{\\hat{d}_{N}}{\\hat{d}_{S}} \\approx \\frac{0.009064}{0.03948} \\approx 0.2296 $$\n\n**任务2：替换率的置信区间**\n\n我们将差异计数 $X_S$ 和 $X_N$ 视为独立的泊松随机变量。对于给定的观测值 $x$，泊松均值 $\\lambda$ 的精确 $100(1-\\alpha)\\%$ Garwood 置信区间为 $[\\lambda_L, \\lambda_U]$，其中：\n$$ \\lambda_L = \\frac{1}{2} \\chi^2_{\\alpha/2, 2x} \\quad \\text{and} \\quad \\lambda_U = \\frac{1}{2} \\chi^2_{1-\\alpha/2, 2(x+1)} $$\n这里，我们构建 $95\\%$ 的置信区间，所以 $\\alpha=0.05$, $\\alpha/2=0.025$, and $1-\\alpha/2=0.975$。$\\chi^2_{q, \\nu}$ 是具有 $\\nu$ 个自由度的卡方分布的分位数函数。\n\n对于同义差异，$X_S=3$：\n$$ \\lambda_{S}^{L} = \\frac{1}{2} \\chi^2_{0.025, 2(3)} = \\frac{1}{2} \\chi^2_{0.025, 6} \\approx \\frac{1}{2}(1.2373) = 0.6187 $$\n$$ \\lambda_{S}^{U} = \\frac{1}{2} \\chi^2_{0.975, 2(3+1)} = \\frac{1}{2} \\chi^2_{0.975, 8} \\approx \\frac{1}{2}(17.5345) = 8.7673 $$\n对于非同义差异，$X_N=2$：\n$$ \\lambda_{N}^{L} = \\frac{1}{2} \\chi^2_{0.025, 2(2)} = \\frac{1}{2} \\chi^2_{0.025, 4} \\approx \\frac{1}{2}(0.4844) = 0.2422 $$\n$$ \\lambda_{N}^{U} = \\frac{1}{2} \\chi^2_{0.975, 2(2+1)} = \\frac{1}{2} \\chi^2_{0.975, 6} \\approx \\frac{1}{2}(14.4494) = 7.2247 $$\n接下来，我们通过除以位点数 $S$ 和 $N$ 将这些区间映射为比例 $p_S$ 和 $p_N$ 的区间：\n$$ [p_{S}^{L}, p_{S}^{U}] = [\\frac{\\lambda_{S}^{L}}{S}, \\frac{\\lambda_{S}^{U}}{S}] = [\\frac{0.6187}{78.0}, \\frac{8.7673}{78.0}] \\approx [0.007932, 0.1124] $$\n$$ [p_{N}^{L}, p_{N}^{U}] = [\\frac{\\lambda_{N}^{L}}{N}, \\frac{\\lambda_{N}^{U}}{N}] = [\\frac{0.2422}{222.0}, \\frac{7.2247}{222.0}] \\approx [0.001091, 0.03254] $$\n最后，我们将单调递增的 JC 变换 $d(p) = -\\frac{3}{4} \\ln(1 - \\frac{4}{3}p)$ 应用于这些区间的端点，以获得 $d_S$ 和 $d_N$ 的置信区间：\n$$ d_{S}^{L} = d(p_{S}^{L}) = -\\frac{3}{4} \\ln(1 - \\frac{4}{3} \\cdot 0.007932) \\approx 0.007975 $$\n$$ d_{S}^{U} = d(p_{S}^{U}) = -\\frac{3}{4} \\ln(1 - \\frac{4}{3} \\cdot 0.1124) \\approx 0.1218 $$\n$$ d_{N}^{L} = d(p_{N}^{L}) = -\\frac{3}{4} \\ln(1 - \\frac{4}{3} \\cdot 0.001091) \\approx 0.001092 $$\n$$ d_{N}^{U} = d(p_{N}^{U}) = -\\frac{3}{4} \\ln(1 - \\frac{4}{3} \\cdot 0.03254) \\approx 0.03328 $$\n$d_S$ 的 $95\\%$ 置信区间约为 $[0.007975, 0.1218]$，$d_N$ 的 $95\\%$ 置信区间约为 $[0.001092, 0.03328]$。\n\n**任务3：$\\omega$ 的置信区间**\n\n通过取能使比率最大化和最小化的区间端点之比，构建 $\\omega = d_N/d_S$ 的保守 $95\\%$ 置信区间：\n$$ [\\omega^{L}, \\omega^{U}] = \\left[\\frac{d_{N}^{L}}{d_{S}^{U}}, \\frac{d_{N}^{U}}{d_{S}^{L}}\\right] $$\n代入计算出的值：\n$$ \\omega^{L} = \\frac{0.001092}{0.1218} \\approx 0.008966 $$\n$$ \\omega^{U} = \\frac{0.03328}{0.007975} \\approx 4.173 $$\n由此得到的 $\\omega$ 的保守 $95\\%$ 置信区间约为 $[0.00897, 4.173]$。点估计 $\\hat{\\omega} \\approx 0.23$ 在此区间内，正如从极低的观察差异计数中所预期的那样，该区间很宽。\n问题要求此区间的上端点 $\\omega^{U}$，并四舍五入至三位有效数字。\n$$ \\omega^{U} \\approx 4.173 $$\n四舍五入至三位有效数字得到 $4.17$。", "answer": "$$\\boxed{4.17}$$", "id": "2757639"}, {"introduction": "在基础估算框架之上，本练习引入了一个更符合实际的替换模型。你将学习如何通过应用 Kimura 双参数（K80）模型来考虑转换/颠换偏好（分子演化中的一个普遍特征），从而优化你的 $dN$ 和 $dS$ 估算值。该练习展示了如何通过选择一个更能拟合潜在演化过程的模型来提高 $\\omega$ 计算的准确性 [@problem_id:2757616]。", "problem": "给定两个在标准遗传密码下演化的直系同源基因之间的逐对密码子比对。你的任务是使用 Nei–Gojobori $1986$ 框架 (NG86; Nei–Gojobori $1986$)，并结合 Kimura 双参数模型 (K80; Kimura $1980$) 来分别校正转换和颠换的多次命中，从而估算每个位点的非同义替换与同义替换之比。具体来说，计算经 Kimura 双参数 (K80) 模型校正的同义距离 $d_S$ 和非同义距离 $d_N$，然后计算比率 $\\omega = d_N/d_S$。使用以下假设和数据：\n\n- 使用标准遗传密码来识别同义和非同义变化。\n- 根据嘌呤-嘌呤或嘧啶-嘧啶的变化（转换）与嘌呤-嘧啶的变化（颠换）的定义来处理转换和颠换。\n- 遵循 Nei–Gojobori 定义计算每个密码子的同义位点数和非同义位点数：对于每个密码子位置，计算 $3$ 种可能的单核苷酸变化中会导致同义变化的数量，将三个位置的这个数值相加，得到该密码子的同义位点数，然后将该密码子的非同义位点数设为 $3$ 减去该值。对每个序列分别进行此操作，然后取两个序列的平均值，以获得比对的总同义位点数 $S$ 和总非同义位点数 $N$。\n- 逐个密码子计算两个序列之间观察到的差异。该比对的构建方式使得每对不同的密码子仅在一个核苷酸上存在差异（没有密码子对存在多个核苷酸差异），这使得每个差异的分类没有歧义。\n- 对于 K80 校正，在同义类别中使用观察到的同义转换比例 $P_S$ 和同义颠换比例 $Q_S$（均用 $S$ 进行归一化），在非同义类别中使用观察到的非同义转换比例 $P_N$ 和非同义颠换比例 $Q_N$（均用 $N$ 进行归一化）。然后使用K80模型，分别由$P_S, Q_S$计算$d_S$，由$P_N, Q_N$计算$d_N$。\n- 最后计算 $\\omega = d_N/d_S$。\n- 将最终答案四舍五入到 $4$ 位有效数字。将 $\\omega$ 报告为无量纲量。\n\n长度为 $10$ 个密码子的密码子比对（序列 $1$ 与序列 $2$）如下：\n\n$1.$ $\\text{GCT}$ vs $\\text{GCC}$\n\n$2.$ $\\text{GGT}$ vs $\\text{GGA}$\n\n$3.$ $\\text{ACT}$ vs $\\text{ATT}$\n\n$4.$ $\\text{CCT}$ vs $\\text{CAT}$\n\n$5.$ $\\text{GTT}$ vs $\\text{GAT}$\n\n$6.$ $\\text{TTT}$ vs $\\text{TTC}$\n\n$7.$ $\\text{TCC}$ vs $\\text{TCT}$\n\n$8.$ $\\text{GCA}$ vs $\\text{GTA}$\n\n$9.$ $\\text{ACC}$ vs $\\text{ACA}$\n\n$10.$ $\\text{GGC}$ vs $\\text{AGC}$\n\n在此 NG86+K80 流程下，$\\omega = d_N/d_S$ 的值是多少？将你的答案四舍五入到 $4$ 位有效数字。", "solution": "该问题在科学和数学上是有效的。它要求使用 Nei–Gojobori (NG86) 方法进行位点计数，并使用 Kimura 双参数 (K80) 模型进行多次命中校正，来计算给定密码子比对的非同义与同义替换率之比 $\\omega = d_N/d_S$。\n\n该过程分五个步骤执行：\n1.  计算同义位点数 ($S$) 和非同义位点数 ($N$) 。\n2.  对观察到的替换类型进行分类和计数。\n3.  计算同义和非同义位点上转换和颠换替换的比例。\n4.  应用 K80 校正来计算同义距离 ($d_S$) 和非同义距离 ($d_N$)。\n5.  计算最终比率 $\\omega = d_N/d_S$。\n\n**步骤 1：计算同义 ($S$) 和非同义 ($N$) 位点**\n\n根据标准遗传密码，给定密码子的同义位点数 ($s$) 计算为 $s = \\sum_{i=1}^{3} f_i$，其中 $f_i$ 是位置 $i$ 上导致同义变化的单核苷酸变化的比例。非同义位点数是 $n = 3 - s$。比对的总位点数 $S$ 和 $N$ 是两个序列位点数的平均值。该比对长度为 $10$ 个密码子，总共有 $30$ 个核苷酸位点。\n\n对于序列 1：\n- 密码子 GCT, GGT, ACT, CCT, GTT, TCC, GCA, ACC, GGC（$9$ 个密码子）各有 $s=1$ 和 $n=2$。\n- 密码子 TTT 有 $s=1/3$ 和 $n=8/3$。它对于 Phe（苯丙氨酸）是二重简并的（TTC 同义，TTA/TTG 非同义）。\n序列 1 的总同义位点数：$S_1 = 9 \\times 1 + 1/3 = 28/3$。\n序列 1 的总非同义位点数：$N_1 = 30 - S_1 = 30 - 28/3 = 62/3$。\n\n对于序列 2：\n- 密码子 GCC, GGA, TCT, GTA, ACA（$5$ 个密码子）各有 $s=1$ 和 $n=2$。\n- 密码子 ATT 有 $s=2/3$ 和 $n=7/3$。\n- 密码子 CAT, GAT, TTC, AGC（$4$ 个密码子）各有 $s=1/3$ 和 $n=8/3$。\n序列 2 的总同义位点数：$S_2 = 5 \\times 1 + 1 \\times (2/3) + 4 \\times (1/3) = 5 + 6/3 = 7$。\n序列 2 的总非同义位点数：$N_2 = 30 - S_2 = 30 - 7 = 23$。\n\n比对的平均位点数是：\n$$ S = \\frac{S_1 + S_2}{2} = \\frac{28/3 + 7}{2} = \\frac{(28+21)/3}{2} = \\frac{49/3}{2} = \\frac{49}{6} $$\n$$ N = \\frac{N_1 + N_2}{2} = \\frac{62/3 + 23}{2} = \\frac{(62+69)/3}{2} = \\frac{131/3}{2} = \\frac{131}{6} $$\n检查：$S+N = 49/6 + 131/6 = 180/6 = 30$。这是正确的。\n\n**步骤 2：对观察到的替换进行分类和计数**\n\n将 $10$ 对有差异的密码子中的每一对都分类为同义或非同义变化，以及转换 (Ti) 或颠换 (Tv)。\n1.  GCT(丙氨酸) $\\rightarrow$ GCC(丙氨酸): 同义，T$\\rightarrow$C (转换)。\n2.  GGT(甘氨酸) $\\rightarrow$ GGA(甘氨酸): 同义，T$\\rightarrow$A (颠换)。\n3.  ACT(苏氨酸) $\\rightarrow$ ATT(异亮氨酸): 非同义，C$\\rightarrow$T (转换)。\n4.  CCT(脯氨酸) $\\rightarrow$ CAT(组氨酸): 非同义，C$\\rightarrow$A (颠换)。\n5.  GTT(缬氨酸) $\\rightarrow$ GAT(天冬氨酸): 非同义，T$\\rightarrow$A (颠换)。\n6.  TTT(苯丙氨酸) $\\rightarrow$ TTC(苯丙氨酸): 同义，T$\\rightarrow$C (转换)。\n7.  TCC(丝氨酸) $\\rightarrow$ TCT(丝氨酸): 同义，C$\\rightarrow$T (转换)。\n8.  GCA(丙氨酸) $\\rightarrow$ GTA(缬氨酸): 非同义，C$\\rightarrow$T (转换)。\n9.  ACC(苏氨酸) $\\rightarrow$ ACA(苏氨酸): 同义，C$\\rightarrow$A (颠换)。\n10. GGC(甘氨酸) $\\rightarrow$ AGC(丝氨酸): 非同义，G$\\rightarrow$A (转换)。\n\n观察到的差异总结：\n- 同义转换数 ($S_{ti}$): $3$\n- 同义颠换数 ($S_{tv}$): $2$\n- 非同义转换数 ($N_{ti}$): $3$\n- 非同义颠换数 ($N_{tv}$): $2$\n\n**步骤 3：计算比例 ($P, Q$)**\n\n分别计算同义和非同义位点的观察到的转换 ($P$) 和颠换 ($Q$) 比例。\n对于同义位点：\n$$ P_S = \\frac{S_{ti}}{S} = \\frac{3}{49/6} = \\frac{18}{49} $$\n$$ Q_S = \\frac{S_{tv}}{S} = \\frac{2}{49/6} = \\frac{12}{49} $$\n对于非同义位点：\n$$ P_N = \\frac{N_{ti}}{N} = \\frac{3}{131/6} = \\frac{18}{131} $$\n$$ Q_N = \\frac{N_{tv}}{N} = \\frac{2}{131/6} = \\frac{12}{131} $$\n\n**步骤 4：对 $d_S$ 和 $d_N$ 进行 K80 校正**\n\nKimura 双参数距离由公式 $d = -\\frac{1}{2} \\ln(1 - 2P - Q) - \\frac{1}{4} \\ln(1 - 2Q)$ 给出。\n\n对于同义距离 $d_S$：\n对数内的项是：\n$$ 1 - 2P_S - Q_S = 1 - 2\\left(\\frac{18}{49}\\right) - \\frac{12}{49} = 1 - \\frac{36}{49} - \\frac{12}{49} = \\frac{49 - 48}{49} = \\frac{1}{49} $$\n$$ 1 - 2Q_S = 1 - 2\\left(\\frac{12}{49}\\right) = 1 - \\frac{24}{49} = \\frac{25}{49} $$\n所以，同义距离是：\n$$ d_S = -\\frac{1}{2} \\ln\\left(\\frac{1}{49}\\right) - \\frac{1}{4} \\ln\\left(\\frac{25}{49}\\right) = \\frac{1}{2} \\ln(49) - \\frac{1}{4} (\\ln(25) - \\ln(49)) $$\n$$ d_S = \\ln(7) - \\frac{1}{4} (2\\ln(5) - 2\\ln(7)) = \\ln(7) - \\frac{1}{2}\\ln(5) + \\frac{1}{2}\\ln(7) = \\frac{3}{2}\\ln(7) - \\frac{1}{2}\\ln(5) $$\n数值上，$d_S \\approx 2.114146$。\n\n对于非同义距离 $d_N$：\n对数内的项是：\n$$ 1 - 2P_N - Q_N = 1 - 2\\left(\\frac{18}{131}\\right) - \\frac{12}{131} = 1 - \\frac{36}{131} - \\frac{12}{131} = \\frac{131 - 48}{131} = \\frac{83}{131} $$\n$$ 1 - 2Q_N = 1 - 2\\left(\\frac{12}{131}\\right) = 1 - \\frac{24}{131} = \\frac{107}{131} $$\n所以，非同义距离是：\n$$ d_N = -\\frac{1}{2} \\ln\\left(\\frac{83}{131}\\right) - \\frac{1}{4} \\ln\\left(\\frac{107}{131}\\right) $$\n$$ d_N = -\\frac{1}{2}(\\ln(83)-\\ln(131)) - \\frac{1}{4}(\\ln(107)-\\ln(131)) = \\frac{3}{4}\\ln(131) - \\frac{1}{2}\\ln(83) - \\frac{1}{4}\\ln(107) $$\n数值上，$d_N \\approx 0.278770$。\n\n**步骤 5：计算 $\\omega = d_N/d_S$**\n\n最后，计算比率 $\\omega$：\n$$ \\omega = \\frac{d_N}{d_S} = \\frac{\\frac{3}{4}\\ln(131) - \\frac{1}{2}\\ln(83) - \\frac{1}{4}\\ln(107)}{\\frac{3}{2}\\ln(7) - \\frac{1}{2}\\ln(5)} $$\n$$ \\omega \\approx \\frac{0.278770}{2.114146} \\approx 0.13185966 $$\n四舍五入到 $4$ 位有效数字，得到 $\\omega = 0.1319$。", "answer": "$$\\boxed{0.1319}$$", "id": "2757616"}, {"introduction": "这项高级实践将带领你从简单的成对比较，转向一种强大的、基于系统发育的方法来检测个别氨基酸位点上的正选择。你将亲手实现用于分析分支-位点模型输出的经验贝叶斯程序，这是分子演化领域中的一个前沿工具。通过计算后验概率并应用错误发现率控制，你将在识别可能受正选择作用的特定位点的关键最后一步中获得实践经验 [@problem_id:2757614]。", "problem": "给定一个固定的、具有指定前景分支的系统发育树，以及一个密码子比对，该比对已使用最大似然法在标准分支-位点密码子模型下进行了分析。分支-位点模型将位点划分为三个潜在类别：类别 $0$（在所有分支上均为纯化选择，满足 $0  \\omega_0  1$），类别 $1$（在所有分支上均为中性进化，满足 $\\omega_1 = 1$），以及类别 $2$（在前景分支上为正向选择，满足 $\\omega_2 > 1$，在背景分支上则满足 $0  \\omega_0  1$ 或 $\\omega_1 = 1$）。对于每个位点 $i$，拟合后的模型在估计的参数向量 $\\widehat{\\theta}$ 下，产生对数似然贡献 $L_{i,k} = \\log f(\\text{data at site } i \\mid \\text{class } k, \\widehat{\\theta})$（其中 $k \\in \\{0,1,2\\}$），以及一个关于类别的混合先验 $\\pi = (\\pi_0,\\pi_1,\\pi_2)$（其中 $\\pi_k \\ge 0$ 且 $\\sum_k \\pi_k = 1$）。您的任务是实现以下步骤：\n\n1. 使用贝叶斯定理，结合类别先验 $\\pi_k$ 和每个位点、每个类别的对数似然 $L_{i,k}$，计算每个位点 $i$ 在前景分支上受到正向选择的经验贝叶斯后验概率，即 $P(C=2 \\mid \\text{data at site } i)$。为了保证数值稳定性，请使用稳定的对数-和-指数计算，在对数空间中执行运算。\n\n2. 对每个位点 $i$，定义局部错误发现率为 $\\ell_i = P(\\text{null} \\mid \\text{data at site } i) = 1 - P(C=2 \\mid \\text{data at site } i)$，其中原假设是类别 $0$ 和 $1$ 的并集（即前景分支上没有正向选择）。为了将预期错误发现率控制在目标水平 $\\alpha$ 以下，请使用贝叶斯错误发现率法则：将位点按 $\\ell_i$ 值升序排序，对前 $k$ 个排好序的位点 $(j)$ 计算累积均值 $\\bar{\\ell}_k = \\frac{1}{k} \\sum_{j=1}^k \\ell_{(j)}$，然后选择满足 $\\bar{\\ell}_{k^\\star} \\le \\alpha$ 的最大 $k^\\star$。将相应的 $k^\\star$ 个位点声明为发现。如果没有任何 $\\bar{\\ell}_k$ 满足该不等式，则不做出任何发现。\n\n3. 对于每个测试用例，报告所有位点的后验概率 $P(C=2 \\mid \\text{data at site } i)$ 列表（四舍五入到六位小数）以及使用从零开始的索引表示的已发现位点索引列表。\n\n您在推理和实现中可以引用的基础知识：\n- 非同义替换率与同义替换率之比 ($\\omega = d_N/d_S$) 的定义及其在纯化选择 ($\\omega  1$)、中性 ($\\omega = 1$) 和正向选择 ($\\omega > 1$) 中的解释。\n- 使用先验权重和似然计算后验概率的似然原理和贝叶斯定理。\n- 错误发现率的定义，即在所有发现中错误发现的预期比例。\n\n请实现一个算法，在给定先验 $\\pi_k$、每个位点的对数似然 $L_{i,k}$ 以及目标水平 $\\alpha$ 的情况下，计算后验概率并应用所述的贝叶斯错误发现率控制方法。\n\n测试套件：\n请提供一个程序来解决以下三种情况。在每种情况下，您都会获得类别先验向量 $\\pi$、目标贝叶斯错误发现率水平 $\\alpha$，以及每个位点、每个类别的对数似然矩阵 $L$（其中行索引位点，列按 $k = 0, 1, 2$ 的顺序索引类别）。\n\n- 情况 A (理想路径，一个明确的发现):\n  $$\\pi = [0.7, 0.25, 0.05], \\quad \\alpha = 0.1,$$\n  $$L = \\begin{bmatrix}\n  -5.0  -4.8  0.5 \\\\\n  -2.2  -1.5  -3.0 \\\\\n  -1.0  -1.1  -1.2 \\\\\n  -6.0  -5.8  -3.9 \\\\\n  -0.2  -0.5  -2.5\n  \\end{bmatrix}.$$\n\n- 情况 B (边界条件，各类别证据相同):\n  $$\\pi = [0.49, 0.49, 0.02], \\quad \\alpha = 0.05,$$\n  $$L = \\begin{bmatrix}\n  -2.0  -2.0  -2.0 \\\\\n  -2.0  -2.0  -2.0 \\\\\n  -2.0  -2.0  -2.0 \\\\\n  -2.0  -2.0  -2.0\n  \\end{bmatrix}.$$\n\n- 情况 C (边缘情况，一个极强的发现，其他为零假设或模棱两可):\n  $$\\pi = [0.6, 0.35, 0.05], \\quad \\alpha = 0.1,$$\n  $$L = \\begin{bmatrix}\n  -10.0  -10.0  -0.1 \\\\\n  -0.1  -0.2  -5.0 \\\\\n  -1.0  -0.8  -4.0 \\\\\n  -5.0  -5.0  -5.0 \\\\\n  -3.0  -2.8  -1.9 \\\\\n  -0.5  -0.7  -2.2\n  \\end{bmatrix}.$$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果本身必须是一个包含两个元素的列表：第一个是每个位点的后验概率 $P(C=2 \\mid \\text{data at site } i)$ 列表（四舍五入到六位小数），第二个是根据指定 $\\alpha$ 下的贝叶斯错误发现率法则发现的位点索引（从零开始）列表。例如，您的输出必须具有以下结构：`[[posteriors_A, discoveries_A], [posteriors_B, discoveries_B], [posteriors_C, discoveries_C]]`。", "solution": "该问题要求实现一个计算生物学中用于识别蛋白质编码基因中受正向选择位点的标准统计程序。该程序包含两个主要部分：首先，使用经验贝叶斯方法计算位点类别的后验概率；其次，应用错误发现率控制程序来识别一组具有正向选择强有力证据的位点。\n\n该方法的基础是贝叶斯定理。对于比对中的每个位点 $i$，我们希望计算在给定该位点观测数据 $D_i$ 的条件下，它属于正向选择类别（类别 $k=2$）的后验概率。设 $C_i$ 为位点 $i$ 的类别分配的随机变量。后验概率由下式给出：\n$$ P(C_i=2 \\mid D_i) = \\frac{f(D_i \\mid C_i=2) P(C_i=2)}{\\sum_{j=0}^{2} f(D_i \\mid C_i=j) P(C_i=j)} $$\n问题提供了必要的组成部分：类别的先验概率 $P(C_i=k) = \\pi_k$，以及每个位点、每个类别的对数似然 $L_{i,k} = \\log f(D_i \\mid C_i=k, \\widehat{\\theta})$，其中 $\\widehat{\\theta}$ 代表模型参数的最大似然估计。将这些代入公式，我们得到：\n$$ P(C_i=2 \\mid D_i) = \\frac{\\pi_2 \\exp(L_{i,2})}{\\sum_{j=0}^{2} \\pi_j \\exp(L_{i,j})} $$\n直接计算该表达式在数值上是不稳定的，因为对可能为很大负数的对数似然值进行指数函数运算可能导致下溢或上溢。为确保稳定性，所有计算必须在对数空间中进行。我们定义位点数据和类别分配的联合概率的对数为 $J_{i,k} = \\log(\\pi_k) + L_{i,k}$。分母是位点 $i$ 数据的边缘似然 $f(D_i)$，其对数 $M_i$ 可表示为：\n$$ M_i = \\log \\left( \\sum_{j=0}^{2} \\exp(J_{i,j}) \\right) $$\n这是一个对数-和-指数（log-sum-exp）运算。为了稳健地计算它，我们使用恒等式 $\\log(\\sum_j \\exp(x_j)) = m + \\log(\\sum_j \\exp(x_j - m))$，其中 $m = \\max_j(x_j)$。对于每个位点 $i$，我们找到 $m_i = \\max_{k \\in \\{0,1,2\\}} (J_{i,k})$ 并计算对数边缘似然为：\n$$ M_i = m_i + \\log \\left( \\sum_{j=0}^{2} \\exp(J_{i,j} - m_i) \\right) $$\n然后，位点 $i$ 属于类别 $2$ 的后验概率可以计算为：\n$$ P(C_i=2 \\mid D_i) = \\exp(\\log P(C_i=2 \\mid D_i)) = \\exp(J_{i,2} - M_i) $$\n对每个位点 $i$ 应用此程序，以获得一个后验概率向量。\n\n任务的第二部分是识别一个位点子集，可以断言这些位点受到正向选择，同时控制错误发现率（FDR）。问题指定使用贝叶斯FDR程序。首先，我们将每个位点 $i$ 的局部错误发现率 $\\ell_i$ 定义为原假设的后验概率。原假设是位点 $i$ 不受正向选择，即它属于类别 $0$ 或类别 $1$。因此：\n$$ \\ell_i = P(C_i \\in \\{0,1\\} \\mid D_i) = P(C_i=0 \\mid D_i) + P(C_i=1 \\mid D_i) = 1 - P(C_i=2 \\mid D_i) $$\n为了将整体FDR控制在目标水平 $\\alpha$ 以下，我们遵循以下步骤：\n$1$. 将比对中的 $N$ 个位点根据其局部错误发现率 $\\ell_i$ 按升序排序。设排序后的值为 $\\ell_{(1)} \\le \\ell_{(2)} \\le \\dots \\le \\ell_{(N)}$，对应的位点索引为 $i_{(1)}, i_{(2)}, \\dots, i_{(N)}$。\n$2$. 对于从 $1$ 到 $N$ 的每个排名 $k$，我们计算排好序的局部FDR的累积均值：\n$$ \\bar{\\ell}_k = \\frac{1}{k} \\sum_{j=1}^{k} \\ell_{(j)} $$\n该值 $\\bar{\\ell}_k$ 表示如果我们将前 $k$ 个位点（即 $\\ell_i$ 值最小的那些）宣称为受正向选择，则错误发现的预期比例。\n$3$. 我们找到满足预期FDR不超过目标水平 $\\alpha$ 的最大整数 $k^\\star$，即 $\\bar{\\ell}_{k^\\star} \\le \\alpha$。\n$4$. 如果存在这样的 $k^\\star \\ge 1$，则将与前 $k^\\star$ 个排好序的局部FDR相对应的位点 $\\{i_{(1)}, i_{(2)}, \\dots, i_{(k^\\star)}\\}$ 宣称为发现。如果没有满足条件的 $k$，则 $k^\\star = 0$，不做出任何发现。\n\n最终算法首先计算所有位点的后验概率 $P(C_i=2 \\mid D_i)$，然后用这些概率计算局部FDR $\\ell_i$。接着，在FDR控制程序中使用这些值来找到发现位点的集合。最后，为每个测试用例报告结果，包括所有后验概率的列表和发现位点索引的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef analyze_case(pi, L, alpha):\n    \"\"\"\n    Analyzes a single test case for positive selection.\n\n    Args:\n        pi (np.ndarray): Prior probabilities for the site classes.\n        L (np.ndarray): Per-site, per-class log-likelihood matrix.\n        alpha (float): Target Bayesian false discovery rate.\n\n    Returns:\n        list: A list containing two elements:\n              1. A list of posterior probabilities P(C=2 | data) for each site,\n                 rounded to six decimals.\n              2. A list of zero-based indices of discovered sites, sorted.\n    \"\"\"\n    # Defensive check for empty inputs\n    if L.shape[0] == 0:\n        return [[], []]\n        \n    # Step 1: Compute posterior probabilities using a stable log-sum-exp\n    log_pi = np.log(pi)\n    \n    # J_ik = log(pi_k) + L_ik (joint log probability)\n    J = L + log_pi  # Broadcasting adds log_pi to each row of L\n    \n    # m_i = max_k(J_ik)\n    m = np.max(J, axis=1, keepdims=True)\n    # M_i = m_i + log(sum_k exp(J_ik - m_i)) (log marginal likelihood)\n    log_marginal_lik = m + np.log(np.sum(np.exp(J - m), axis=1, keepdims=True))\n\n    # log P(C=2 | data_i) = J_i2 - M_i\n    log_post_prob_k2 = J[:, 2] - log_marginal_lik.flatten()\n    post_prob_k2 = np.exp(log_post_prob_k2)\n    \n    posteriors_rounded = np.round(post_prob_k2, 6).tolist()\n    \n    # Step 2: Bayesian False Discovery Rate (FDR) control\n    # l_i = 1 - P(C=2 | data_i) (local false discovery rate)\n    local_fdr = 1 - post_prob_k2\n    \n    # Sort sites by local_fdr in ascending order\n    sorted_indices = np.argsort(local_fdr)\n    sorted_lfdr = local_fdr[sorted_indices]\n    \n    # Compute cumulative means of sorted local FDRs\n    num_sites = len(local_fdr)\n    k_vals = np.arange(1, num_sites + 1)\n    cumulative_means = np.cumsum(sorted_lfdr) / k_vals\n    \n    # Find the largest k such that cumulative_mean[k-1] = alpha\n    valid_k_indices = np.where(cumulative_means = alpha)[0]\n    \n    if len(valid_k_indices) == 0:\n        k_star = 0\n    else:\n        # np.where返回的是从0开始的索引。k的值是索引+1。\n        k_star = valid_k_indices[-1] + 1\n        \n    # Get the indices of discovered sites\n    discovered_site_indices = sorted_indices[:k_star]\n    \n    # Report discovered indices sorted for consistency\n    discoveries = sorted(discovered_site_indices.tolist())\n    \n    return [posteriors_rounded, discoveries]\n\ndef solve():\n    \"\"\"\n    Wrapper function to define test cases and print results in the required format.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"pi\": np.array([0.7, 0.25, 0.05]),\n            \"alpha\": 0.1,\n            \"L\": np.array([\n                [-5.0, -4.8, 0.5],\n                [-2.2, -1.5, -3.0],\n                [-1.0, -1.1, -1.2],\n                [-6.0, -5.8, -3.9],\n                [-0.2, -0.5, -2.5]\n            ])\n        },\n        {\n            \"name\": \"Case B\",\n            \"pi\": np.array([0.49, 0.49, 0.02]),\n            \"alpha\": 0.05,\n            \"L\": np.array([\n                [-2.0, -2.0, -2.0],\n                [-2.0, -2.0, -2.0],\n                [-2.0, -2.0, -2.0],\n                [-2.0, -2.0, -2.0]\n            ])\n        },\n        {\n            \"name\": \"Case C\",\n            \"pi\": np.array([0.6, 0.35, 0.05]),\n            \"alpha\": 0.1,\n            \"L\": np.array([\n                [-10.0, -10.0, -0.1],\n                [-0.1, -0.2, -5.0],\n                [-1.0, -0.8, -4.0],\n                [-5.0, -5.0, -5.0],\n                [-3.0, -2.8, -1.9],\n                [-0.5, -0.7, -2.2]\n            ])\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = analyze_case(case[\"pi\"], case[\"L\"], case[\"alpha\"])\n        all_results.append(result)\n\n    # Final print statement in the exact required format.\n    # The default string representation of a list is what is needed.\n    # The map(str, ...) converts each result list (e.g., [[...],[...]])\n    # to its string form, and join combines them with commas.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "2757614"}]}