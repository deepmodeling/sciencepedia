{"hands_on_practices": [{"introduction": "近交系数 $F$ 是研究近交的核心。在我们分析其影响之前，我们必须首先掌握其计算方法。本练习将通过一个常见而简单的谱系结构（一级表亲），让您亲手实践使用路径法计算 $F$ 值，这对从事保育遗传学或动物育种的研究者来说是一项基本技能。[@problem_id:1940055]", "problem": "在一个针对极度濒危的伊比利亚猞猁的圈养繁殖计划中，一只名为“Zara”的新幼崽出生了。动物园管理员正在评估种群的遗传健康状况，需要计算这只新个体的近交水平。Zara的父母是“Félix”和“Isabel”。谱系记录显示，Félix的父亲和Isabel的父亲是兄弟。假设他们近期谱系中的所有其他祖先都没有亲缘关系，且自身不是近交所生。近交系数，用$F$表示，量化了个体中任意给定基因座上的两个等位基因因出自共同祖先而相同的概率。计算Zara的近交系数$F$。将你的答案表示为精确分数。", "solution": "个体的近交系数$F$等于一个基因座上的两个等位基因因出自共同祖先而相同的概率，根据Wright的路径系数法，其计算公式为\n$$\nF = \\sum_{A} \\left( \\frac{1}{2} \\right)^{n_1+n_2+1} (1+F_A),\n$$\n其中，求和遍及个体父母的所有共同祖先$A$，$n_{1}$和$n_{2}$是从$A$到每个亲本的世代数，$F_{A}$是祖先$A$的近交系数。\n\n从谱系可知，Félix的父亲和Isabel的父亲是兄弟，所以Félix和Isabel是第一代表兄妹。他们唯一的共同祖先是那对兄弟的父母，即他们的两位祖父母。所有其他祖先都没有亲缘关系且非近交，因此对于每个共同祖先$A$，我们有$F_{A}=0$。\n\n对于两位共同的祖父母中的每一位：\n- 从$A$到Félix的路径长度为$n_{1}=2$（祖父母 $\\to$ 父亲 $\\to$ Félix）。\n- 从$A$到Isabel的路径长度为$n_{2}=2$（祖父母 $\\to$ 父亲 $\\to$ Isabel）。\n\n因此，每个共同的祖父母贡献的系数为\n$$\n\\left( \\frac{1}{2} \\right)^{2+2+1}(1+0) = \\left( \\frac{1}{2} \\right)^5 = \\frac{1}{32}.\n$$\n有两位这样的祖父母，所以总和为\n$$\nF = 2 \\times \\frac{1}{32} = \\frac{1}{16}.\n$$\n\n作为一致性检验，第一代表兄妹之间的亲缘系数是$\\frac{1}{8}$，而亲缘关系系数（当父母非近交时，该系数等于后代的$F$）是其一半，即$\\frac{1}{16}$，与上述结果相符。", "answer": "$$\\boxed{\\frac{1}{16}}$$", "id": "1940055"}, {"introduction": "得到近交系数 $F$ 之后，它对一个种群究竟意味着什么？近交通过增加纯合度，导致基因型频率偏离哈迪-温伯格平衡。本练习将抽象的 $F$ 值与其具体的遗传学后果联系起来：基因型频率的可预测变化，特别是那些通常表现出有害性状的隐性纯合子频率的变化。[@problem_id:1940005]", "problem": "一个由保护生物学家组成的团队正在研究一个稀有山狐物种的孤立种群。这种隔离导致了可测量程度的近亲繁殖。生物学家们正专注于一个负责耳廓形态的基因座，该基因座有两个等位基因：显性等位基因 `T` 决定典型耳，隐性等位基因 `t` 决定簇状耳。簇状耳表型仅在纯合隐性基因型 (`tt`) 的个体中表达。\n\n对该种群的遗传调查确定，隐性等位基因 `t` 的频率为 $q = 0.2$。通过对谱系和遗传标记的进一步分析，生物学家们估算出该种群的平均近交系数为 $F = 0.1$。\n\n假设该种群的遗传结构在这些条件下处于平衡状态，那么长有簇状耳的山狐的预期频率是多少？将您的答案表示为保留三位有效数字的小数。", "solution": "该问题要求计算在一个已知等位基因频率和近交系数的种群中，纯合隐性个体 (`tt`) 的预期频率。\n\n隐性等位基因 `t` 的频率为 $q = 0.2$。\n近交系数为 $F = 0.1$。\n\n在一个随机交配的种群中（即 $F=0$ 时），基因型频率将遵循哈迪-温伯格平衡，纯合隐性个体的频率将简单地为 $q^2$。然而，近亲繁殖增加了个体成为纯合子的概率，因为它增加了接收到同源等位基因的机会。\n\n在一个近交系数为 $F$ 的种群中，基因型频率的通用公式为：\n- `TT` 的频率 ($P_{TT}$): $p^2(1-F) + pF$\n- `Tt` 的频率 ($P_{Tt}$): $2pq(1-F)$\n- `tt` 的频率 ($P_{tt}$): $q^2(1-F) + qF$\n\n此处，$p$ 是显性等位基因 `T` 的频率，$q$ 是隐性等位基因 `t` 的频率。由于该基因座只有两个等位基因，它们的频率之和必须为1。\n$p + q = 1$\n$p = 1 - q = 1 - 0.2 = 0.8$\n\n我们需要计算纯合隐性基因型 $P_{tt}$ 的频率，这对应于簇状耳的表型。我们使用以下公式：\n$$P_{tt} = q^2(1-F) + qF$$\n\n让我们分解这个公式。项 $(1-F)$ 代表了种群中可以被认为是随机交配的部分。在这部分中，个体为纯合隐性的概率是 $q^2$。项 $F$ 代表了因近亲繁殖导致等位基因同源的种群部分。在这部分中，个体为等位基因 `t` 纯合子的概率就是该等位基因的频率 $q$。\n\n现在我们将给定的值代入方程：\n$q = 0.2$\n$F = 0.1$\n\n$$P_{tt} = (0.2)^2(1 - 0.1) + (0.2)(0.1)$$\n计算每一项：\n$$(0.2)^2 = 0.04$$\n$$(1 - 0.1) = 0.9$$\n$$(0.2)(0.1) = 0.02$$\n\n将这些结果代回 $P_{tt}$ 的方程：\n$$P_{tt} = (0.04)(0.9) + 0.02$$\n$$P_{tt} = 0.036 + 0.02$$\n$$P_{tt} = 0.056$$\n\n问题要求答案保留三位有效数字。计算出的值为 $0.056$。第一位有效数字是5，第二位是6。要用三位有效数字表示，我们必须在末尾添加一个零。\n\n因此，长有簇状耳的山狐的预期频率为 $0.0560$。", "answer": "$$\\boxed{0.0560}$$", "id": "1940005"}, {"introduction": "在演化和保育生物学中，近交最关键的后果是近交衰退——即适合度的降低。这最后一个练习从遗传学原理转向了其在现实世界中的适合度效应。它演示了如何使用存活数据的回归分析来估计近交衰退的严重程度（通过“致死当量” $B$ 来量化），从而将理论与经验数据分析联系起来，这是生物学家的一项关键技能。[@problem_id:2725930]", "problem": "给定多个个体组的分组生存结局，每组具有已知的近交系数 $F$、个体总数 $n$ 和存活个体数 $s$。在进化生物学中，近交衰退的概念通常通过每个二倍体基因组的致死当量（表示为 $B$）来量化，该值衡量生存率随近交的变化。出发点是这样一个基本原理：许多独立的、稀有的、有害基因座的生存效应以乘性方式组合，并且有效致死打击的期望数量随着同源恒等概率以加性方式累积。由此可知，对数转换可将生存因子的乘积转化为和。使用这些原理，推导生存概率的自然对数与近交系数 $F$ 之间的线性关系。然后，通过将观测生存比例的自然对数对 $F$ 进行带截距项的回归，利用分组二项数据设计一个 $B$ 的估计量。使用总组大小 $n$ 作为权重，以考虑各组之间抽样方差的差异。将估计斜率的负值解释为 $B$ 的估计值。\n\n您的程序必须精确实现以下算法：\n- 对于每组参数为 $(F_i,n_i,s_i)$ 的组 $i$，计算观测生存比例 $p_i = s_i/n_i$。假设所有提供的数据都满足 $0  p_i  1$。\n- 对 $y_i = \\ln(p_i)$ 关于 $x_i = F_i$ 建立带截距项的加权最小二乘回归，使用权重 $w_i = n_i$。也就是说，通过最小化 $\\sum_i w_i\\,(y_i - \\beta_0 - \\beta_1 x_i)^2$ 来估计截距和斜率 $(\\beta_0,\\beta_1)$。\n- 定义 $\\widehat{B} = -\\widehat{\\beta}_1$。\n- 对于每个数据集，以浮点数形式输出 $\\widehat{B}$，并四舍五入到 $6$ 位小数。\n\n测试套件：\n提供代码计算以下数据集的 $\\widehat{B}$。每个数据集是一个由三元组 $(F,n,s)$ 组成的列表。\n\n- 数据集 A:\n  - $(0, 400, 320)$\n  - $(0.0625, 300, 222)$\n  - $(0.125, 350, 230)$\n  - $(0.25, 320, 190)$\n\n- 数据集 B:\n  - $(0, 500, 450)$\n  - $(0.25, 500, 325)$\n  - $(0.5, 500, 250)$\n\n- 数据集 C:\n  - $(0, 40, 36)$\n  - $(0.125, 30, 24)$\n  - $(0.375, 20, 11)$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果的顺序与数据集的顺序相同，例如 $[b_A,b_B,b_C]$，其中每个条目都四舍五入到 $6$ 位小数，且不含任何附加文本。", "solution": "我们从一个适用于进化生物学和近交研究的基本原理出发：当生存等适应度组分反映了许多独立的、稀有的、有害等位基因的综合效应时，个体的总体生存率可以建模为各个基因座生存贡献的乘积。设远交个体每个基因座对生存的贡献接近于1，并设因自身合子性而暴露的有效致死或半致死打击的期望数量与近交系数 $F$ 成正比增加。这与两个经过充分检验的事实相符：同源恒等使纯合性按比例 $F$ 增加，而独立基因座间的乘性适应度意味着适应度的对数在基因座间是加性的。\n\n用 $S(F)$ 表示近交系数为 $F$ 时的生存概率，用 $S(0)$ 表示远交状态下的基线生存概率。如果许多稀有的、主要为隐性的有害等位基因在纯合状态下各自对生存率产生一个小的乘性降低，那么这类表达出来的有害效应的期望数量会随 $F$ 近似线性增加。根据稀有事件定律，暴露的有效致死当量的数量可以用一个均值与 $F$ 成正比的泊松随机变量来近似。此时，生存概率等于基线生存率乘以零次有效致死打击的概率，这就得出了一个指数形式。因此，近交衰退中一个标准且经过充分检验的模型是\n$$\nS(F) = S(0)\\,\\exp(-B\\,F),\n$$\n其中 $B$ 是每个二倍体基因组的致死当量数。取自然对数，\n$$\n\\ln S(F) = \\ln S(0) - B\\,F.\n$$\n这表明 $\\ln S(F)$ 与 $F$ 呈线性关系，斜率为 $-B$，截距为 $\\ln S(0)$。\n\n在实践中，我们观察到的是分组二项数据：对于每个具有共同 $F_i$ 的组 $i$，有 $n_i$ 个个体和 $s_i$ 个存活者，从而得到观测比例\n$$\np_i = \\frac{s_i}{n_i}.\n$$\n对于大的 $n_i$ 和中等的 $p_i$，$\\ln p_i$ 的抽样方差近似与 $n_i$ 成反比，这为在 $\\ln p_i$ 对 $F_i$ 的回归中采用 $n_i$ 加权提供了依据。具体来说，定义 $y_i = \\ln(p_i)$，$x_i = F_i$，权重为 $w_i = n_i$。我们寻求 $(\\beta_0,\\beta_1)$ 来最小化加权平方和\n$$\nQ(\\beta_0,\\beta_1) = \\sum_i w_i\\left(y_i - \\beta_0 - \\beta_1 x_i\\right)^2.\n$$\n加权正规方程可以得到闭式估计量。定义加权和\n$$\nS_0 = \\sum_i w_i,\\quad S_x = \\sum_i w_i x_i,\\quad S_y = \\sum_i w_i y_i,\\quad S_{xx} = \\sum_i w_i x_i^2,\\quad S_{xy} = \\sum_i w_i x_i y_i.\n$$\n那么，只要 $x_i$ 存在变异，行列式 $D = S_0 S_{xx} - S_x^2$ 就为正。加权最小二乘估计量为\n$$\n\\widehat{\\beta}_1 = \\frac{S_0 S_{xy} - S_x S_y}{D},\\qquad \\widehat{\\beta}_0 = \\frac{S_y - \\widehat{\\beta}_1 S_x}{S_0}.\n$$\n根据模型 $\\ln S(F) = \\ln S(0) - B F$，斜率满足 $\\beta_1 = -B$，因此每个二倍体基因组的致死当量数的估计量为\n$$\n\\widehat{B} = -\\widehat{\\beta}_1.\n$$\n\n程序的算法设计：\n- 对于每个由三元组 $(F_i,n_i,s_i)$ 组成的数据集：\n  - 对所有组 $i$ 计算 $p_i = s_i/n_i$。\n  - 计算 $y_i = \\ln(p_i)$ 和 $x_i = F_i$，并设 $w_i = n_i$。\n  - 累加加权和 $S_0, S_x, S_y, S_{xx}, S_{xy}$。\n  - 计算 $\\widehat{\\beta}_1$，然后计算 $\\widehat{B} = -\\widehat{\\beta}_1$。\n  - 将 $\\widehat{B}$ 四舍五入到6位小数。\n- 将三个四舍五入后的 $\\widehat{B}$ 值按数据集的顺序汇总到一个列表中，并以单行、方括号内逗号分隔的形式打印，不含任何额外文本。\n\n科学真实性与测试覆盖范围：\n- 数据集 A 涵盖了从 $F=0$ 到 $F=0.25$ 的低到中等近交系数，样本量较大；观测到的存活率随 $F$ 的增加而下降，与近交衰退一致。\n- 数据集 B 包括高达 $F=0.5$ 的更高近交水平，样本量均衡且较大，用于探究更强的衰退情景。\n- 数据集 C 使用较小的样本量来测试加权行为和数值稳定性，同时保持 $0", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef estimate_B_wls(dataset):\n    \"\"\"\n    Estimate B (lethal equivalents per diploid genome) by weighted least squares\n    regression of ln(p_i) on F_i with intercept, weights w_i = n_i.\n\n    dataset: list of tuples (F_i, n_i, s_i)\n    returns: float, estimated B\n    \"\"\"\n    F = np.array([row[0] for row in dataset], dtype=float)\n    n = np.array([row[1] for row in dataset], dtype=float)\n    s = np.array([row[2] for row in dataset], dtype=float)\n\n    # Observed survival proportions\n    p = s / n\n\n    # Numerical safety: assume 0  p  1 as guaranteed by the problem statement.\n    # Compute transformed response\n    y = np.log(p)\n    x = F\n    w = n\n\n    # Weighted sums for closed-form WLS with intercept\n    S0 = np.sum(w)\n    Sx = np.sum(w * x)\n    Sy = np.sum(w * y)\n    Sxx = np.sum(w * x * x)\n    Sxy = np.sum(w * x * y)\n\n    D = S0 * Sxx - Sx * Sx\n    if D == 0.0:\n        # Should not happen with varying F; handle gracefully\n        raise ValueError(\"Design matrix is singular; variation in F is required.\")\n\n    beta1 = (S0 * Sxy - Sx * Sy) / D\n    # beta0 = (Sy - beta1 * Sx) / S0  # not needed for B\n\n    B_hat = -beta1\n    return B_hat\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each dataset is a list of (F, n, s) tuples.\n    dataset_A = [\n        (0.0, 400, 320),\n        (0.0625, 300, 222),\n        (0.125, 350, 230),\n        (0.25, 320, 190),\n    ]\n    dataset_B = [\n        (0.0, 500, 450),\n        (0.25, 500, 325),\n        (0.5, 500, 250),\n    ]\n    dataset_C = [\n        (0.0, 40, 36),\n        (0.125, 30, 24),\n        (0.375, 20, 11),\n    ]\n\n    test_cases = [dataset_A, dataset_B, dataset_C]\n\n    results = []\n    for data in test_cases:\n        B_est = estimate_B_wls(data)\n        # Round to 6 decimal places as required\n        results.append(f\"{B_est:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2725930"}]}