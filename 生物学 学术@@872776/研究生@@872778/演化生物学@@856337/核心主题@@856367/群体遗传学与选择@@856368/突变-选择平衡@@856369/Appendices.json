{"hands_on_practices": [{"introduction": "有害等位基因在群体中的平衡频率，关键取决于它在何种程度上暴露于自然选择之下。这个练习通过一个假想的甲虫物种，直接对比了一个完全隐性的致死等位基因和一个具有轻微显性效应的等位基因。通过计算并比较两种情况下的平衡频率[@problem_id:1505297]，你将亲身体会到，即使是极小的显性系数（$h$）也会让等位基因在杂合子中“暴露”，从而极大地提高选择效率，并显著降低其在群体中的持久性。", "problem": "在一个大型、随机交配的假想甲虫物种群体中，一种罕见的遗传病——几丁质合成缺陷（Chitin Synthesis Deficiency, CSD）——通过突变和自然选择之间的平衡得以维持。该病由单个基因控制，该基因有两个等位基因：显性野生型等位基因 $B$ 和导致CSD的隐性等位基因 $b$。从等位基因 $B$ 到等位基因 $b$ 的正向突变率为每代 $\\mu = 1.0 \\times 10^{-6}$。具有纯合隐性基因型 ($bb$) 的个体无法产生功能性外骨骼，因此无法存活，在繁殖前死亡。\n\n首先，假设有害等位基因 $b$ 是完全隐性的，并且对杂合子 ($Bb$) 的表型或适合度没有影响，计算该等位基因的平衡频率。\n\n接下来，假设进一步的研究表明等位基因 $b$ 并非完全隐性。虽然杂合子能够存活，但其外骨骼表现出细微的结构弱点，这降低了它们的总体适合度。这种效应通过显性系数 $h=0.05$ 来量化。针对致死纯合隐性基因型 ($bb$) 的选择系数仍为 $s=1$。在这种部分显性的条件下，计算等位基因 $b$ 的新平衡频率。\n\n分别提供完全隐性和部分显性两种情况下计算出的平衡频率，结果保留三位有效数字。将你的答案表示为一个行矩阵，按要求的顺序包含这两个值。", "solution": "设有害等位基因的频率为 $q$，野生型等位基因的频率为 $p$，其中 $p=1-q$。从 $B$ 到 $b$ 的正向突变率为 $\\mu$，我们忽略反向突变。选择作用下各基因型的适合度设为 $w_{BB}=1$、$w_{Bb}=1-hs$ 和 $w_{bb}=1-s$，其中 $s$ 是选择系数，$h$ 是显性系数。\n\n在突变-选择平衡状态下，每代由突变增加的 $b$ 等位基因数量等于由选择减少的数量，因此 $\\Delta q=\\Delta q_{\\text{mut}}+\\Delta q_{\\text{sel}}=0$。\n\n**完全隐性情况 ($h=0$)**:\n- 当 $h=0$ 时，选择仅作用于纯合隐性个体。对于稀有的 $b$ ($q\\ll 1$)，基因型为 $bb$ 的个体比例约为 $q^{2}$，平均适合度约为 $1$，因选择而损失的 $b$ 等位基因比例约为 $s q^{2}$。对于 $q\\ll 1$，由突变带来的增加量为 $\\mu p\\approx \\mu$。\n- 在平衡状态下，令突变输入等于选择移除，可得\n$$\n\\mu \\approx s q^{2} \\quad \\Rightarrow \\quad \\hat{q} \\approx \\sqrt{\\frac{\\mu}{s}}.\n$$\n- 当 $s=1$ 且 $\\mu=1.0 \\times 10^{-6}$ 时，可得\n$$\n\\hat{q}=\\sqrt{1.0 \\times 10^{-6}}=1.00 \\times 10^{-3}.\n$$\n\n**部分显性情况 ($0  h \\le 1$)**:\n- 当 $h>0$ 时，选择作用于杂合子和纯合子。对于稀有的 $b$ ($q\\ll 1$)，绝大多数受选择的等位基因存在于频率约为 $2pq \\approx 2q$ 的杂合子中。因选择而损失的 $b$ 等位基因比例约为 $hsq$。\n- 在平衡状态下，突变输入与选择移除相平衡：\n$$\n\\mu \\approx hs q \\quad \\Rightarrow \\quad \\hat{q} \\approx \\frac{\\mu}{hs}.\n$$\n- 当 $s=1$、$h=0.05$ 且 $\\mu=1.0 \\times 10^{-6}$ 时，可得\n$$\n\\hat{q}=\\frac{1.0 \\times 10^{-6}}{0.05 \\times 1}=2.00 \\times 10^{-5}.\n$$", "answer": "$$\\boxed{\\begin{pmatrix}1.00 \\times 10^{-3}  2.00 \\times 10^{-5}\\end{pmatrix}}$$", "id": "1505297"}, {"introduction": "在真实世界中，自然选择的压力很少在整个群体中完全均一。该练习探讨了一个更为复杂的情景：一个有害的隐性等位基因只在雄性个体中表达其效应[@problem_id:1505347]。这个思想实验将促使你思考，当选择只作用于群体的一部分（此处为雄性）时，我们应如何量化其对整个基因库的平均效应，以及这种性别限制性选择（sex-limited selection）如何改变突变-选择平衡的结果。", "problem": "在一个二倍体、有性生殖生物的大型随机交配种群中，一个有害的常染色体隐性等位基因 `b` 以恒定的突变率 $\\mu$ 从野生型等位基因 `B` 产生。从 `b` 到 `B` 的回复突变被认为可以忽略不计。我们分析该等位基因在两种不同选择情景下的平衡频率。\n\n**情景 A：** 当纯合时，隐性等位基因 `b` 是有害的。基因型为 `bb` 的个体相对于基因型为 `BB` 或 `Bb`（适合度为 1）的个体，其相对适合度为 $1-s$。这种选择劣势对雄性和雌性同样适用。\n\n**情景 B：** 隐性等位基因 `b` 的有害效应是性别限制的。它只影响纯合雄性的适合度。基因型为 `bb` 的雄性个体的相对适合度为 $1-s$，而基因型为 `bb` 的雌性个体的适合度为 1，与所有 `BB` 和 `Bb` 个体相同。假设种群的性别比为 1:1。\n\n对于两个分别对应于两种情景的大型种群，最终会建立突变-选择平衡。设 $\\hat{q}_A$ 为情景 A 中等位基因 `b` 的平衡频率，$\\hat{q}_B$ 为情景 B 中等位基因 `b` 的平衡频率。\n\n确定比率 $\\frac{\\hat{q}_B}{\\hat{q}_A}$。将您的答案表示为单个解析表达式。", "solution": "设 $p$ 表示选择前合子中 $B$ 的频率，$q$ 表示 $b$ 的频率，且 $p=1-q$。突变是单向的，从 $B$ 到 $b$ 的突变率为 $\\mu$，回复突变可以忽略不计。随机交配产生选择前的哈迪-温伯格基因型频率。\n\n**情景 A（在两性中纯合时均有害）**：基因型适合度为 $w_{BB}=1$、$w_{Bb}=1$、$w_{bb}=1-s$。经过生存力选择后，平均适合度为 $\\bar{w}=1-s q^{2}$，等位基因 $b$ 的频率变为\n$$\nq_{s}=\\frac{q^{2}(1-s)+pq}{\\bar{w}}=\\frac{q(1-s q)}{1-s q^{2}}。\n$$\n然后，突变将等位基因频率更新为\n$$\nq_{t+1}=(1-\\mu)q_{s}+\\mu。\n$$\n在平衡状态下，设 $q_{t+1}=q=\\hat{q}_{A}$ 并使用 $q\\ll 1$（有害隐性基因以低频率维持）。将 $q_{s}$ 展开到二阶：因为 $q_{s}=\\frac{q-s q^{2}}{1-s q^{2}}=(q-s q^{2})(1+s q^{2}+O(q^{4}))=q-s q^{2}+O(q^{3})$，我们得到\n$$\nq_{t+1}=q-s q^{2}+\\mu+O(q^{3},\\mu q)。\n$$\n在平衡状态下忽略高阶项，得到\n$$\n0=-s \\hat{q}_{A}^{2}+\\mu \\quad \\Rightarrow \\quad \\hat{q}_{A}=\\sqrt{\\frac{\\mu}{s}}。\n$$\n\n**情景 B（仅在纯合雄性中有害）**：雄性适合度为 $w^{m}_{BB}=1$、$w^{m}_{Bb}=1$、$w^{m}_{bb}=1-s$。雌性适合度均为 $1$。选择后，雄性等位基因频率为\n$$\nq^{m}_{s}=\\frac{q(1-s q)}{1-s q^{2}}，\n$$\n而雌性等位基因频率保持为 $q^{f}_{s}=q$。在性别比为 1:1 且配子贡献相等的情况下，突变前的配子库具有\n$$\nq_{s}=\\frac{1}{2}\\left(q^{m}_{s}+q^{f}_{s}\\right)=\\frac{1}{2}\\left(\\frac{q(1-s q)}{1-s q^{2}}+q\\right)。\n$$\n然后突变给出\n$$\nq_{t+1}=(1-\\mu)q_{s}+\\mu。\n$$\n对于 $q\\ll 1$，像之前一样展开：$q^{m}_{s}=q-s q^{2}+O(q^{3})$，因此\n$$\nq_{s}=q-\\frac{s}{2}q^{2}+O(q^{3})，\n$$\n于是\n$$\nq_{t+1}=q-\\frac{s}{2}q^{2}+\\mu+O(q^{3},\\mu q)。\n$$\n在平衡状态下，忽略高阶项得到\n$$\n0=-\\frac{s}{2}\\hat{q}_{B}^{2}+\\mu \\quad \\Rightarrow \\quad \\hat{q}_{B}=\\sqrt{\\frac{2\\mu}{s}}。\n$$\n\n因此，平衡频率的比率为\n$$\n\\frac{\\hat{q}_{B}}{\\hat{q}_{A}}=\\frac{\\sqrt{\\frac{2\\mu}{s}}}{\\sqrt{\\frac{\\mu}{s}}}=\\sqrt{2}。\n$$", "answer": "$$\\boxed{\\sqrt{2}}$$", "id": "1505347"}, {"introduction": "对突变-选择平衡的深刻理解，不仅在于计算静态的平衡点，更在于掌握群体基因频率如何响应动态变化的环境。这个高级练习要求你从静态分析转向动态模拟，构建一个单倍体模型来追踪等位基因频率在选择系数$s$随时间分段变化时的演化轨迹[@problem_id:2738125]。通过编写程序来模拟这一过程并分析其稳定性（例如，是否存在“过冲”现象），你将深入探索群体遗传系统对环境变化的响应机制。", "problem": "考虑一个确定性的无限群体单倍体模型，该模型包含两个等位基因：野生型等位基因 $A$ 和突变型等位基因 $a$。时间以离散的世代 $t \\in \\{0,1,2,\\dots\\}$ 进行。在第 $t$ 代，突变型等位基因的频率为 $q(t) \\in [0,1]$，$A$ 的频率为 $p(t) = 1 - q(t)$。假设每一代中，先发生生存力选择，然后发生突变，并遵循以下基本定义：\n\n- $A$ 的适应度为 $1$；$a$ 的适应度为 $1 - s(t)$，其中 $s(t)$ 在时间上是分段常数，在每个指定的世代区间内取一个恒定值。\n- 从 $A$到 $a$ 的正向突变以每代速率 $\\mu \\in [0,1)$ 发生，从 $a$ 到 $A$ 的反向突变以每代速率 $\\nu \\in [0,1)$ 发生。\n- 在每一代中，选择先于突变发生。\n\n从这些定义出发，对于一个给定的常数选择系数 $s$，推导一代中从 $q(t)$ 到 $q(t+1)$ 的确定性更新公式，然后将其扩展到分段常数 $s(t)$ 的情况。对于任何固定的 $s$，将突变-选择平衡 $q^\\star(s)$ 定义为一个不动点，它在选择系数为 $s$ 的单代更新映射 $f_s$ 下满足 $q^\\star(s) \\in [0,1]$ 和 $q^\\star(s) = f_s(q^\\star(s))$。你必须推导出 $q^\\star(s)$ 关于 $\\mu$、$\\nu$ 和 $s$ 的显式闭式表达式，该表达式对 $s \\neq 0$ 有效，并给出 $s=0$ 时的正确极限表达式。\n\n定义“相对于最后一次变化后的新平衡的过冲”如下。假设 $s(t)$ 是分段常数，最后一次变化发生在第 $t_0$ 代；设此后的常数值为 $s_{\\mathrm{final}}$，其平衡点为 $q^\\star_{\\mathrm{final}} = q^\\star(s_{\\mathrm{final}})$。给定由确定性更新和初始条件 $q(0)$ 生成的轨迹 $q(t)$，我们称该轨迹对 $q^\\star_{\\mathrm{final}}$ 发生了过冲，当且仅当存在一个整数 $t \\ge t_0$，使得 $q(t) - q^\\star_{\\mathrm{final}}$ 和 $q(t+1) - q^\\star_{\\mathrm{final}}$ 的符号严格相反。为了进行符号比较，将与 $q^\\star_{\\mathrm{final}}$ 的绝对差值小于或等于 $10^{-12}$ 的值视为完全相等。\n\n实现一个程序，该程序能够：\n- 从第一性原理推导上述选择和突变作用下单代 $q(t)$ 的更新公式。\n- 推导并计算对于任意给定 $s$ 的 $q^\\star(s)$ 的闭式表达式，并正确处理 $s = 0$ 的情况。\n- 在给定初始 $q(0)$ 的情况下，对 $s(t)$ 的每个分段常数段，向前模拟 $q(t)$ 的演化。\n- 检测在最后一次变化之后，是否发生如上文定义的相对于 $q^\\star_{\\mathrm{final}}$ 的过冲。\n\n你的程序必须执行一套指定的参数集测试套件。每个测试用例由 $(\\mu,\\nu,q(0),\\text{schedule})$ 指定，其中 $\\text{schedule}$ 是一个 $(\\Delta,t)$ 对的列表，表示“将 $s(t)$ 保持为给定的选择系数，持续 $\\Delta$ 代”，并按顺序执行。模拟的总世代数是所有 $\\Delta$ 的总和。除非特别说明，所有数值都是无量纲的频率或每代概率。\n\n使用以下测试套件：\n\n- 测试 1：$\\mu = 10^{-3}$，$\\nu = 0$，$q(0) = q^\\star(0.2)$，计划表 $[(300,\\,0.2),(400,\\,0.05)]$。确定相对于 $q^\\star(0.05)$ 的过冲。\n- 测试 2：$\\mu = 0.02$，$\\nu = 0.01$，$q(0) = 0.8$，计划表 $[(100,\\,0.4),(600,\\,0.1)]$。确定相对于 $q^\\star(0.1)$ 的过冲。\n- 测试 3：$\\mu = 0.05$，$\\nu = 0.05$，$q(0) = 0.2$，计划表 $[(150,\\,0.0),(600,\\,0.3)]$。确定相对于 $q^\\star(0.3)$ 的过冲。\n- 测试 4：$\\mu = 0.0$，$\\nu = 0.1$，$q(0) = 0.9$，计划表 $[(120,\\,0.2),(600,\\,0.7)]$。确定相对于 $q^\\star(0.7)$ 的过冲。\n- 测试 5：$\\mu = 10^{-5}$，$\\nu = 10^{-5}$，$q(0) = q^\\star(-0.2)$，计划表 $[(300,\\,-0.2),(600,\\,-0.05)]$。确定相对于 $q^\\star(-0.05)$ 的过冲。\n- 测试 6：$\\mu = 10^{-3}$，$\\nu = 0$，$q(0) = q^\\star(0.8)$，计划表 $[(100,\\,0.8),(50,\\,0.05),(700,\\,0.3)]$。确定相对于 $q^\\star(0.3)$ 的过冲。\n\n你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为结果，顺序与测试用例相同（例如，$[{\\rm True},{\\rm False},\\dots]$）。每个条目必须是一个布尔值，指示在该测试中 $s(t)$ 最后一次变化后是否发生了如上定义的过冲。", "solution": "所提供的问题是理论群体遗传学中一个有效且适定的练习。它科学地基于经典的突变-选择平衡模型，并提供了一套完整且一致的定义和参数。我将着手解决。\n\n该问题要求推导群体遗传状态，特别是突变等位基因 $a$ 的频率 $q(t)$ 如何随离散世代 $t$ 变化。该模型对于单倍体、无限群体是确定性的。一个世代内的生命周期包括两个相继的事件：生存力选择，然后是突变。\n\n首先，我们必须推导 $q(t)$ 的单代更新方程。设 $q(t)$ 为第 $t$ 代开始时等位基因 $a$ 的频率。野生型等位基因 $A$ 的频率为 $p(t)=1-q(t)$。\n\n_第 1 步：选择_\n等位基因 $A$ 的适应度为 $w_A=1$，等位基因 $a$ 的适应度为 $w_a = 1-s$，其中 $s$ 是选择系数（在此推导中假定为常数）。选择之后，等位基因的频率按其适应度加权。群体的平均适应度为 $\\bar{w}(t) = p(t)w_A + q(t)w_a = (1-q(t)) \\cdot 1 + q(t)(1-s) = 1 - sq(t)$。\n选择后等位基因 $a$ 的频率，我们记作 $q'(t)$，为：\n$$\nq'(t) = \\frac{q(t)w_a}{\\bar{w}(t)} = \\frac{q(t)(1-s)}{1-sq(t)}\n$$\n选择后等位基因 $A$ 的频率为 $p'(t) = 1-q'(t) = \\frac{1-q(t)}{1-sq(t)}$。\n\n_第 2 步：突变_\n选择之后，发生突变。野生型等位基因 $A$ 以速率 $\\mu$ 突变为 $a$，突变型等位基因 $a$ 以速率 $\\nu$ 反向突变为 $A$。下一代中等位基因 $a$ 的频率 $q(t+1)$，是未突变的 $a$ 等位基因和新从 $A$ 突变来的等位基因的总和：\n$$\nq(t+1) = q'(t)(1-\\nu) + p'(t)\\mu\n$$\n代入 $q'(t)$ 和 $p'(t)$ 的表达式：\n$$\nq(t+1) = \\frac{q(t)(1-s)}{1-sq(t)}(1-\\nu) + \\frac{1-q(t)}{1-sq(t)}\\mu\n$$\n这可以化简为单代更新映射，$q(t+1) = f_s(q(t))$：\n$$\nq(t+1) = \\frac{q(t)(1-s)(1-\\nu) + (1-q(t))\\mu}{1-sq(t)}\n$$\n\n接下来，我们通过设 $q(t+1) = q(t) = q^\\star$ 并求解 $q^\\star$ 来推导突变-选择平衡频率 $q^\\star(s)$：\n$$\nq^\\star = \\frac{q^\\star(1-s)(1-\\nu) + (1-q^\\star)\\mu}{1-sq^\\star}\n$$\n重新整理此方程可得到关于 $q^\\star$ 的一个二次方程：\n$$\nq^\\star(1-sq^\\star) = q^\\star(1-s)(1-\\nu) + \\mu - \\mu q^\\star\n$$\n$$\nq^\\star - s(q^\\star)^2 = q^\\star(1-s-\\nu+s\\nu) + \\mu - \\mu q^\\star\n$$\n$$\n-s(q^\\star)^2 = q^\\star(-s-\\nu+s\\nu-\\mu) + \\mu\n$$\n$$\ns(q^\\star)^2 - (s(1-\\nu)+\\mu+\\nu)q^\\star + \\mu = 0\n$$\n这是一个标准形式为 $Ax^2+Bx+C=0$ 的二次方程，其中 $x=q^\\star$，$A=s$，$B=-(s(1-\\nu)+\\mu+\\nu)$，$C=\\mu$。解由二次方程求根公式给出：\n$$\nq^\\star = \\frac{s(1-\\nu)+\\mu+\\nu \\pm \\sqrt{(s(1-\\nu)+\\mu+\\nu)^2 - 4s\\mu}}{2s}\n$$\n对于一个生物学上有意义的解，$q^\\star$ 必须位于 $[0,1]$ 区间内。通过分析连续函数 $g(q) = f_s(q) - q$，我们发现 $g(0)=\\mu \\ge 0$ 且 $g(1)=-\\nu \\le 0$。根据介值定理，在 $[0,1]$ 区间内必定存在至少一个根。详细分析表明，正确的稳定解是通过在分子中取负号得到的：\n$$\nq^\\star(s) = \\frac{s(1-\\nu)+\\mu+\\nu - \\sqrt{(s(1-\\nu)+\\mu+\\nu)^2 - 4s\\mu}}{2s} \\quad (\\text{对于 } s \\neq 0)\n$$\n对于 $s=0$ 的情况，二次方程退化为线性方程：$(\\mu+\\nu)q^\\star = \\mu$，从而得出 $q^\\star(0) = \\frac{\\mu}{\\mu+\\nu}$。这个结果也可以通过对通解在 $s \\to 0$ 时使用洛必达法则取极限得到。\n\n问题要求检测“过冲”，其定义为 $q(t)$ 的轨迹穿过最终的平衡频率 $q^\\star_{\\mathrm{final}}$。这种行为取决于更新映射 $f_s(q)$ 的性质。具体来说，只有当动力学行为是振荡的时才会发生过冲，这要求映射在不动点附近是非单调的（$f'_s(q)  0$）或非常陡峭地递增（$f'_s(q^\\star) > 1$）。让我们分析更新映射的导数：\n$$\nf_s(q) = \\frac{q((1-s)(1-\\nu)-\\mu) + \\mu}{1-sq}\n$$\n对于一个映射 $f(q)=(Aq+B)/(Cq+D)$，其导数为 $f'_s(q) = \\frac{AD-BC}{(Cq+D)^2}$。这里 $A=(1-s)(1-\\nu)-\\mu$，$B=\\mu$，$C=-s$，$D=1$。\n$$\nf'_s(q) = \\frac{((1-s)(1-\\nu)-\\mu)(1) - (\\mu)(-s)}{(1-sq)^2} = \\frac{1 - s - \\nu + s\\nu - \\mu + s\\mu}{(1-sq)^2}\n$$\n分母总是正的。对于测试套件中给出的所有参数值，分子 $N=1 - (s+\\nu+\\mu) + s(\\nu+\\mu)$ 都是正的。例如，对于参数值最大的测试 4（$s=0.7, \\nu=0.1, \\mu=0$），$N = 1 - 0.7 - 0.1 + 0.7(0.1) = 0.27 > 0$。\n由于对于所有相关参数都有 $f'_s(q) > 0$，更新映射 $f_s(q)$ 是单调递增的。单调映射意味着序列 $q(t)$ 将单调地趋近于其稳定不动点 $q^\\star(s)$。也就是说，如果 $q(t_0) > q^\\star(s)$，那么对于所有 $t > t_0$ 都有 $q(t) > q^\\star(s)$。类似地，如果 $q(t_0)  q^\\star(s)$，那么对于所有 $t > t_0$ 都有 $q(t)  q^\\star(s)$。\n因此，对于任何常数 $s_{\\mathrm{final}}$，一旦模拟在时刻 $t_0$ 进入最终阶段，轨迹 $q(t)$（对于 $t \\ge t_0$）将始终保持在最终平衡点 $q^\\star_{\\mathrm{final}}$ 的一侧。它永远不会穿过平衡点。因此，在指定条件下，问题中定义的过冲在理论上是不可能发生的。\n\n所有测试用例的正确答案都必须是 `False`。以下程序实现了指定的完整模拟，它可作为此解析结论的验证。该代码计算平衡频率，根据给定的计划表模拟轨迹，并在最终阶段的每一步检查过冲条件。\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem described.\n    It simulates allele frequency dynamics under piecewise-constant selection\n    and checks for overshoot relative to the final equilibrium.\n    \"\"\"\n\n    def calculate_q_star(s, mu, nu):\n        \"\"\"\n        Calculates the equilibrium frequency q_star for given s, mu, and nu.\n        \n        Args:\n            s (float): Selection coefficient.\n            mu (float): Forward mutation rate (A to a).\n            nu (float): Back mutation rate (a to A).\n\n        Returns:\n            float: The equilibrium frequency q_star.\n        \"\"\"\n        if abs(s)  1e-15:\n            if mu + nu == 0:\n                # Neutral case with no mutation. Any frequency is an equilibrium.\n                # This ambiguous case does not occur in the test suite.\n                # A reasonable default might be the initial frequency, but we return 0.5.\n                return 0.5\n            return mu / (mu + nu)\n        else:\n            # Solve the quadratic equation:\n            # s*q^2 - (s(1-nu)+mu+nu)*q + mu = 0\n            b_term = s * (1 - nu) + mu + nu\n            \n            # The discriminant term can be written as (s(1-nu)+mu+nu)^2 - 4*s*mu\n            # This should be non-negative for valid evolutionary parameters.\n            discriminant = b_term**2 - 4 * s * mu\n            if discriminant  0:\n                # Clamp to zero to handle potential floating-point inaccuracies\n                discriminant = 0\n            \n            sqrt_discriminant = np.sqrt(discriminant)\n            \n            # The smaller root corresponds to the stable equilibrium.\n            numerator = b_term - sqrt_discriminant\n            denominator = 2 * s\n            \n            return numerator / denominator\n\n    def update_q(q, s, mu, nu):\n        \"\"\"\n        Calculates the frequency q in the next generation based on selection and mutation.\n        \n        Args:\n            q (float): Current frequency of allele 'a'.\n            s (float): Selection coefficient.\n            mu (float): Forward mutation rate.\n            nu (float): Back mutation rate.\n            \n        Returns:\n            float: Frequency of allele 'a' in the next generation.\n        \"\"\"\n        denominator = 1 - q * s\n        # Avoid division by zero, though unlikely with problem constraints\n        if abs(denominator)  1e-15:\n            return q\n            \n        numerator = q * (1 - s) * (1 - nu) + (1 - q) * mu\n        return numerator / denominator\n\n    def run_simulation(mu, nu, q0_spec, schedule):\n        \"\"\"\n        Runs one full simulation for a given test case.\n        \"\"\"\n        if isinstance(q0_spec, tuple) and q0_spec[0] == 'q_star':\n            s_init = q0_spec[1]\n            q_current = calculate_q_star(s_init, mu, nu)\n        else:\n            q_current = q0_spec\n        \n        s_final = schedule[-1][1]\n        q_star_final = calculate_q_star(s_final, mu, nu)\n        \n        last_change_time = sum(duration for duration, _ in schedule[:-1])\n        \n        overshoot_detected = False\n        current_time = 0\n        tolerance = 1e-12\n\n        for duration, s in schedule:\n            for _ in range(duration):\n                if overshoot_detected:\n                    break\n                \n                q_previous = q_current\n                q_current = update_q(q_previous, s, mu, nu)\n                \n                if current_time >= last_change_time:\n                    diff_prev = q_previous - q_star_final\n                    diff_curr = q_current - q_star_final\n                    \n                    if (diff_prev > tolerance and diff_curr  -tolerance) or \\\n                       (diff_prev  -tolerance and diff_curr > tolerance):\n                        overshoot_detected = True\n                        \n                current_time += 1\n            if overshoot_detected:\n                break\n                \n        return overshoot_detected\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1\n        (1e-3, 0, ('q_star', 0.2), [(300, 0.2), (400, 0.05)]),\n        # Test 2\n        (0.02, 0.01, 0.8, [(100, 0.4), (600, 0.1)]),\n        # Test 3\n        (0.05, 0.05, 0.2, [(150, 0.0), (600, 0.3)]),\n        # Test 4\n        (0.0, 0.1, 0.9, [(120, 0.2), (600, 0.7)]),\n        # Test 5\n        (1e-5, 1e-5, ('q_star', -0.2), [(300, -0.2), (600, -0.05)]),\n        # Test 6\n        (1e-3, 0, ('q_star', 0.8), [(100, 0.8), (50, 0.05), (700, 0.3)])\n    ]\n    \n    results = []\n    for case in test_cases:\n        mu, nu, q0_spec, schedule = case\n        result = run_simulation(mu, nu, q0_spec, schedule)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "answer": "[False,False,False,False,False,False]", "id": "2738125"}]}