{"hands_on_practices": [{"introduction": "信号转导始于配体与受体的结合。在许多简化模型中，我们常常假设配体浓度远高于受体浓度，因此在结合过程中保持不变。然而，在真实的生物系统中，尤其是在受体丰度较高或配体有限的情况下，受体结合会显著消耗游离配体，这种现象称为“配体耗竭”。本练习将引导你超越这一简化假设，通过严格应用质量作用定律和质量守恒定律，精确计算考虑了配体耗竭的结合平衡 [@problem_id:2605662]。掌握这种基本计算是准确建模信号通路资源竞争和网络交互的基础。", "problem": "在一个充分混合的细胞外室中，一种单一的细胞膜受体通过响应可溶性配体来介导信号起始。假设每个受体只有一个结合位点的单价结合，没有受体二聚化，没有内化，也没有竞争性结合伴侣或脱靶汇（即没有网络串扰）。该反应是热力学可逆的，并达到平衡。总受体浓度为 $R_T = 100\\,\\mathrm{nM}$，总配体浓度为 $L_T = 50\\,\\mathrm{nM}$，平衡解离常数为 $K_d = 10\\,\\mathrm{nM}$。仅使用质量作用定律、平衡解离常数的定义和质量守恒，计算与配体结合的受体的平衡分数，并正确考虑配体耗尽。将最终答案表示为四舍五入到 $4$ 位有效数字的无量纲小数。", "solution": "我们考虑游离受体 $R$ 和游离配体 $L$ 之间形成复合物 $C$ 的单一可逆结合反应：\n$$\nR + L \\rightleftharpoons C.\n$$\n根据平衡时的质量作用定律，平衡解离常数 $K_d$ 定义为\n$$\nK_d = \\frac{[R][L]}{[C]}.\n$$\n质量守恒得出\n$$\nR_T = [R] + [C], \\quad L_T = [L] + [C],\n$$\n其中 $R_T$ 和 $L_T$ 分别表示总受体浓度和总配体浓度。令 $x = [C]$ 为复合物的平衡浓度。则 $[R] = R_T - x$ 且 $[L] = L_T - x$。代入 $K_d$ 的定义式得到\n$$\nK_d = \\frac{(R_T - x)(L_T - x)}{x}.\n$$\n重新整理，\n$$\nK_d x = (R_T - x)(L_T - x) = R_T L_T - (R_T + L_T)x + x^2,\n$$\n这得到了关于 $x$ 的二次方程：\n$$\nx^2 - (R_T + L_T + K_d)x + R_T L_T = 0.\n$$\n物理上可接受的根（即介于 $0$ 和 $\\min\\{R_T, L_T\\}$ 之间的根）是\n$$\nx = \\frac{(R_T + L_T + K_d) - \\sqrt{(R_T + L_T + K_d)^2 - 4 R_T L_T}}{2}.\n$$\n与配体结合的受体的平衡分数是\n$$\nf = \\frac{[C]}{R_T} = \\frac{x}{R_T}.\n$$\n现在我们代入给定值 $R_T = 100\\,\\mathrm{nM}$，$L_T = 50\\,\\mathrm{nM}$ 和 $K_d = 10\\,\\mathrm{nM}$：\n$$\nR_T + L_T + K_d = 100 + 50 + 10 = 160\\,\\mathrm{nM},\n$$\n$$\n4 R_T L_T = 4 \\times 100 \\times 50 = 20000\\,\\mathrm{nM}^2,\n$$\n$$\n(R_T + L_T + K_d)^2 = 160^2 = 25600\\,\\mathrm{nM}^2,\n$$\n所以判别式为\n$$\n\\Delta = 25600 - 20000 = 5600\\,\\mathrm{nM}^2,\n$$\n且\n$$\n\\sqrt{\\Delta} = \\sqrt{5600} \\approx 74.83314773547883\\,\\mathrm{nM}.\n$$\n因此\n$$\nx = \\frac{160 - 74.83314773547883}{2}\\,\\mathrm{nM} \\approx 42.58342613226058\\,\\mathrm{nM},\n$$\n且结合分数为\n$$\nf = \\frac{x}{R_T} \\approx \\frac{42.58342613226058}{100} = 0.4258342613226058.\n$$\n作为无量纲小数，四舍五入到 $4$ 位有效数字，\n$$\nf \\approx 0.4258.\n$$", "answer": "$$\\boxed{0.4258}$$", "id": "2605662"}, {"introduction": "理论原则最终需要通过具体的生物系统来检验和理解。NF-$\\kappa$B 信号通路是阐明负反馈调控动态行为的经典范例。在这个系统中，NF-$\\kappa$B 蛋白入核后会激活其抑制蛋白 I$\\kappa$B 的转录，从而形成一个包含固有时间延迟（转录和翻译所需的时间）的负反馈回路。本计算实践将指导你模拟一个 NF-$\\kappa$B 振荡器的动力学模型 [@problem_id:2605661]。通过改变上游激酶 IKK 的脉冲刺激时长，你将亲手探索系统响应的动态模式（如振荡次数）如何依赖于输入信号的特征，从而获得对生物振荡器工作原理的直观感受。", "problem": "给定一个活化B细胞核因子κ轻链增强子 (NF-$\\kappa$B) 信号传导的最小动力学模型，该模型包含κB抑制剂 (I$\\kappa$B) 负反馈和脉冲式IκB激酶 (IKK) 输入。该模型基于质量作用式动力学和希尔型转录调控，这些都是生化反应网络建模中的标准方法。您将实现该模型，针对一组IKK脉冲持续时间进行模拟，并计算每种情况下核内NF-$\\kappa$B易位的峰值数量。最后，您将使用时间尺度论证来解释观察到的对脉冲持续时间的依赖性。\n\n基本原理和假设：\n- 使用源自质量平衡和类质量作用动力学的常微分方程来描述物质的相互转化和降解。\n- 使用希尔函数来表示核内NF-$\\kappa$B对I$\\kappa$B信使核糖核酸 (mRNA) 的转录激活，这是对协同启动子激活的标准粗粒化表示。\n- 保持NF-$\\kappa$B总丰度为一个固定值，并通过减少可用于核输入的池来表示I$\\kappa$B对胞质NF-$\\kappa$B的隔离。\n\n状态变量：\n- $N_n(t)$: 核内NF-$\\kappa$B丰度（任意单位）。\n- $I_m(t)$: I$\\kappa$B mRNA丰度（任意单位）。\n- $I(t)$: I$\\kappa$B蛋白丰度（任意单位）。\n\n输入：\n- $u(t)$: IKK活性，建模为振幅为$A$、持续时间为$D$分钟的矩形脉冲，其中当$0 \\le t \\le D$时$u(t) = A$，否则$u(t) = 0$。\n\n模型方程：\n- $$\\frac{d I_m}{dt} = k_{\\mathrm{tx}} \\cdot \\frac{N_n(t)^h}{K^h + N_n(t)^h} - k_{\\mathrm{mdeg}} \\cdot I_m(t)$$\n- $$\\frac{d I}{dt} = k_{\\mathrm{tl}} \\cdot I_m(t) - \\left(k_{\\mathrm{deg0}} + k_{\\mathrm{deg1}} \\cdot u(t)\\right) \\cdot I(t)$$\n- $$\\frac{d N_n}{dt} = k_{\\mathrm{in}} \\cdot N_{\\mathrm{free}}(t) - k_{\\mathrm{out}} \\cdot N_n(t)$$\n其中\n- $$N_{\\mathrm{free}}(t) = \\frac{N_{\\mathrm{tot}} - N_n(t)}{1 + \\alpha \\cdot I(t)}$$\n该式在现象学上捕捉了I$\\kappa$B对NF-$\\kappa$B的胞质隔离。\n\n使用的参数（时间单位为分钟，所有其他量均使用一致的任意单位）：\n- $N_{\\mathrm{tot}} = 1.0$\n- $k_{\\mathrm{in}} = 0.5$\n- $k_{\\mathrm{out}} = 0.05$\n- $\\alpha = 50.0$\n- $k_{\\mathrm{tx}} = 0.5$\n- $K = 0.2$\n- $h = 4$\n- $k_{\\mathrm{mdeg}} = 0.01$\n- $k_{\\mathrm{tl}} = 0.1$\n- $k_{\\mathrm{deg0}} = 0.002$\n- $k_{\\mathrm{deg1}} = 0.01$\n- $A = 1.0$\n\n模拟协议：\n- 通过在无刺激条件下（即$u(t) \\equiv 0$）从$t = 0$到$t = T_{\\mathrm{pre}}$（其中$T_{\\mathrm{pre}} = 1000$分钟）进行模拟，来预先平衡系统。使用任何合理的非负初始条件，并将结束状态作为脉冲模拟在$t = 0$时的稳态初始条件。\n- 对于每个脉冲持续时间$D$，根据上面定义的输入$u(t)$，将系统从$t = 0$模拟到$t = T_{\\mathrm{sim}}(D)$，其中$T_{\\mathrm{sim}}(D) = D + T_{\\mathrm{post}}$且$T_{\\mathrm{post}} = 360$分钟。时间单位为分钟。\n- 以足够精细的均匀分辨率对核NF-$\\kappa$B轨迹$N_n(t)$进行采样以检测峰值；$\\Delta t = 0.5$分钟的步长是足够的。\n\n峰值计数：\n- 定义一个核易位峰值为$N_n(t)$的局部最大值，该最大值需满足最小高度条件$N_n \\ge N_{\\mathrm{th}}$和最小峰突出度以避免计数噪声，其中$N_{\\mathrm{th}} = 0.15$，最小峰突出度为$0.05$（与$N_n$使用相同的任意单位）。\n- 为避免对时间序列最开始处可能存在的数值伪影进行计数，丢弃在$t_{\\mathrm{min}} = 1.0$分钟之前出现的任何峰值。\n- 强制峰值之间至少有$\\Delta t_{\\mathrm{min}} = 20$分钟的时间间隔，以反映与I$\\kappa$B再合成相关的生物不应期。\n\n所需输出：\n- 对于每个脉冲持续时间$D$，根据上述标准计算在区间$t \\in [0, T_{\\mathrm{sim}}(D)]$内$N_n(t)$的整数峰值数量。\n\n测试套件：\n- 使用以下IKK脉冲持续时间（单位：分钟）：$[0.0, 5.0, 30.0, 120.0, 480.0]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如，$\"[r_1,r_2,r_3,r_4,r_5]\"$，其中每个$r_i$是按给定顺序对应的测试用例的整数峰值数。\n\n交付物：\n- 一个完整的程序，该程序执行预平衡，针对指定的脉冲持续时间运行模拟，按规定计数峰值，并以上述确切格式打印单行输出。在注释或文档中，包含一个简要的基于时间尺度的论证，解释为什么增加IKK脉冲持续时间$D$会倾向于增加这个负反馈系统中核易位峰值的数量。所有时间量必须以分钟为单位进行解释，输出为无单位整数。", "solution": "该问题已经过验证。\n\n**第1步：提取已知信息**\n所提供的信息包括一个常微分方程(ODEs)系统、参数和模拟协议。\n- 状态变量：$I_m(t)$ (I$\\kappa$B mRNA)，$I(t)$ (I$\\kappa$B蛋白)，$N_n(t)$ (核内NF-$\\kappa$B)。\n- 输入信号：$u(t)$代表IKK活性，其中当$0 \\le t \\le D$时为$u(t) = A$，否则为$u(t) = 0$。\n- 模型方程：\n$$ \\frac{d I_m}{dt} = k_{\\mathrm{tx}} \\cdot \\frac{N_n(t)^h}{K^h + N_n(t)^h} - k_{\\mathrm{mdeg}} \\cdot I_m(t) $$\n$$ \\frac{d I}{dt} = k_{\\mathrm{tl}} \\cdot I_m(t) - \\left(k_{\\mathrm{deg0}} + k_{\\mathrm{deg1}} \\cdot u(t)\\right) \\cdot I(t) $$\n$$ \\frac{d N_n}{dt} = k_{\\mathrm{in}} \\cdot N_{\\mathrm{free}}(t) - k_{\\mathrm{out}} \\cdot N_n(t) $$\n- 辅助方程：\n$$ N_{\\mathrm{free}}(t) = \\frac{N_{\\mathrm{tot}} - N_n(t)}{1 + \\alpha \\cdot I(t)} $$\n- 参数：$N_{\\mathrm{tot}} = 1.0$, $k_{\\mathrm{in}} = 0.5 \\text{ min}^{-1}$, $k_{\\mathrm{out}} = 0.05 \\text{ min}^{-1}$, $\\alpha = 50.0$, $k_{\\mathrm{tx}} = 0.5 \\text{ min}^{-1}$, $K = 0.2$, $h = 4$, $k_{\\mathrm{mdeg}} = 0.01 \\text{ min}^{-1}$, $k_{\\mathrm{tl}} = 0.1 \\text{ min}^{-1}$, $k_{\\mathrm{deg0}} = 0.002 \\text{ min}^{-1}$, $k_{\\mathrm{deg1}} = 0.01 \\text{ min}^{-1}$, $A = 1.0$。\n- 模拟协议：\n  - 预平衡：$T_{\\mathrm{pre}} = 1000$ 分钟，其中$u(t)=0$。\n  - 模拟：对于每个持续时间$D$，从$t=0$积分到$T_{\\mathrm{sim}}(D) = D + 360$分钟。\n  - 采样时间步长：$\\Delta t = 0.5$ 分钟。\n- 峰值计数标准：\n  - 最小高度：$N_{\\mathrm{th}} = 0.15$。\n  - 最小峰突出度：$0.05$。\n  - 最小起始时间：$t_{\\mathrm{min}} = 1.0$ 分钟。\n  - 最小间隔：$\\Delta t_{\\mathrm{min}} = 20$ 分钟。\n- $D$的测试用例：$[0.0, 5.0, 30.0, 120.0, 480.0]$ 分钟。\n\n**第2步：使用提取的已知信息进行验证**\n对问题进行有效性分析。\n- **科学依据**：该模型是NF-$\\kappa$B信号通路的标准表示，这是一个由负反馈回路驱动的生物振荡器的典型例子。使用质量作用动力学和希尔函数的数学公式是系统生物学中一种公认且科学合理的方法。\n- **适定性**：该问题定义了一个一阶非自治常微分方程系统，并给定了特定参数和确定初始条件的过程。常微分方程系统的右侧由在生物学相关域（非负浓度）上连续可微（利普希茨连续）的初等函数构成。这保证了对于给定的初始条件，解的存在性和唯一性，使其成为一个适定的初值问题。\n- **完整性与一致性**：该问题是自包含的。所有必需的方程、常数、初始/边界条件和分析过程都已明确提供。没有矛盾之处。单位是一致的（时间单位为分钟，浓度单位为任意单位）。\n\n**第3步：结论与行动**\n该问题是**有效的**。它是一个定义明确、具有科学依据的计算系统生物学问题。我将继续进行求解。\n\n**求解步骤**\n\n求解过程包括三个主要阶段：系统预平衡、刺激-响应模拟和用于峰值计数的轨迹分析。\n\n1.  **系统预平衡**：为了建立系统的基础、未受刺激的状态，我们必须首先在没有IKK刺激的情况下找到所有物质的稳态浓度。这通过求解输入$u(t)$在所有时间都设置为零的常微分方程系统来实现。\n    待解系统为：\n    $$ \\frac{d I_m}{dt} = k_{\\mathrm{tx}} \\frac{N_n^h}{K^h + N_n^h} - k_{\\mathrm{mdeg}} I_m $$\n    $$ \\frac{d I}{dt} = k_{\\mathrm{tl}} I_m - k_{\\mathrm{deg0}} I $$\n    $$ \\frac{d N_n}{dt} = k_{\\mathrm{in}} \\frac{N_{\\mathrm{tot}} - N_n}{1 + \\alpha I} - k_{\\mathrm{out}} N_n $$\n    我们从一个非负初始条件（例如$[I_m, I, N_n] = [0, 0, 0]$）开始，对该系统进行数值积分，持续时间为$T_{\\mathrm{pre}} = 1000$分钟。这段时间足够长，可以使系统收敛到其不动点。在$t = T_{\\mathrm{pre}}$时的状态向量随后被用作后续模拟的初始条件$\\vec{y}_0 = [I_m(0), I(0), N_n(0)]$。\n\n2.  **刺激-响应模拟**：对于所提供的测试套件中的每个脉冲持续时间$D$，模拟包括时变输入$u(t)$的完整系统。从预平衡状态$\\vec{y}_0$开始，将常微分方程系统从$t=0$积分到$T_{\\mathrm{sim}}(D) = D + 360$分钟。输入$u(t)$实现为分段函数：\n    $$ u(t) = \\begin{cases} A,  \\text{if } 0 \\le t \\le D \\\\ 0,  \\text{if } t > D \\end{cases} $$\n    使用鲁棒的常微分方程求解器（如`scipy.integrate.solve_ivp`）进行数值积分，并在$\\Delta t = 0.5$分钟的均匀时间间隔上评估解，以生成$N_n(t)$的时间序列。\n\n3.  **峰值检测与计数**：分析模拟的核内NF-$\\kappa$B轨迹$N_n(t)$，以量化易位事件的数量。峰值被定义为$N_n(t)$信号中的局部最大值。我们使用标准的峰值检测算法，例如`scipy.signal.find_peaks`，来识别这些最大值。然后根据以下严格标准对识别出的峰值进行筛选：\n    - 峰高必须满足$N_n(t_{\\text{peak}}) \\ge N_{\\mathrm{th}} = 0.15$。\n    - 峰必须具有至少$0.05$的峰突出度。峰突出度衡量一个峰值从其周围信号中脱颖而出的程度。\n    - 丢弃在$t_{\\mathrm{min}} = 1.0$分钟之前出现的峰值，以避免模拟开始时的数值伪影。\n    - 强制连续峰值之间有$\\Delta t_{\\mathrm{min}} = 20$分钟的最小时间间隔。这反映了生物学上的不应期。\n    通过所有筛选器的最终峰值计数是给定脉冲持续时间$D$的结果。\n\n对测试套件中的每个$D$值重复整个过程，以生成最终的结果列表。对于所得趋势的解释在实现代码的文档中提供。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.signal import find_peaks\n\ndef solve():\n    \"\"\"\n    This program solves a minimal dynamical model of NF-kB signaling to determine\n    the number of nuclear translocation peaks as a function of stimulus duration.\n\n    Timescale-based justification for observed behavior:\n    The NF-kB signaling system modeled here is a classic negative feedback oscillator.\n    1.  Stimulus Onset: The IKK stimulus `u(t)` enhances degradation of the inhibitor `I` (IkB).\n        This frees NF-kB from cytoplasmic sequestration.\n    2.  First Peak: Free NF-kB translocates to the nucleus, causing `N_n` to rise and form a peak.\n    3.  Negative Feedback: High `N_n` transcriptionally upregulates its own inhibitor `I` via an intermediate `I_m` (IkB mRNA).\n        This feedback has an inherent time delay due to the sequential processes of transcription and translation.\n    4.  Repression: As newly synthesized `I` protein accumulates, it sequesters NF-kB in the cytoplasm again,\n        and nuclear export further reduces `N_n`, causing the signal to fall.\n    5.  Sustained Oscillations: If the stimulus duration `D` is long enough to outlast the feedback delay,\n        the IKK activity will degrade the newly synthesized inhibitor, re-initiating the cycle and\n        leading to subsequent peaks. The system's intrinsic oscillatory period is determined by the\n        timescales of transcription, translation, and nuclear transport.\n    6.  Dependence on D: The number of peaks is therefore dependent on the ratio of the stimulus duration `D` to the\n        system's intrinsic feedback period `tau_fb`.\n        - If `D` is very short (shorter than the time to the first peak), no significant response occurs.\n        - If `D` is long enough for one response but shorter than `tau_fb`, one peak is observed.\n        - As `D` increases, it can encompass multiple cycles of `tau_fb`, allowing the system to oscillate\n          and produce a greater number of peaks before the stimulus is removed and the system damps\n          back to its steady state. Thus, the number of peaks is expected to be a non-decreasing\n          function of `D`.\n    \"\"\"\n\n    # Define model parameters\n    params = {\n        'N_tot': 1.0,\n        'k_in': 0.5,\n        'k_out': 0.05,\n        'alpha': 50.0,\n        'k_tx': 0.5,\n        'K': 0.2,\n        'h': 4.0,\n        'k_mdeg': 0.01,\n        'k_tl': 0.1,\n        'k_deg0': 0.002,\n        'k_deg1': 0.01,\n        'A': 1.0,  # Amplitude of u(t)\n    }\n\n    # Simulation and analysis parameters\n    T_pre = 1000.0  # min\n    T_post = 360.0  # min\n    dt = 0.5  # min\n\n    # Peak counting parameters\n    N_th = 0.15\n    prominence = 0.05\n    t_min_peak = 1.0  # min\n    delta_t_min_peak = 20.0  # min\n    \n    # Test suite for pulse durations D\n    test_cases = [0.0, 5.0, 30.0, 120.0, 480.0]\n\n    # --- Step 1: Pre-equilibration ---\n    def odes_pre(t, y, p):\n        I_m, I, N_n = y\n        # No stimulus, u(t) = 0\n        N_free = (p['N_tot'] - N_n) / (1.0 + p['alpha'] * I)\n        \n        dIm_dt = p['k_tx'] * (N_n**p['h']) / (p['K']**p['h'] + N_n**p['h']) - p['k_mdeg'] * I_m\n        dI_dt = p['k_tl'] * I_m - p['k_deg0'] * I\n        dNn_dt = p['k_in'] * N_free - p['k_out'] * N_n\n        \n        return [dIm_dt, dI_dt, dNn_dt]\n\n    y0_initial = [0.0, 0.0, 0.0]\n    sol_pre = solve_ivp(\n        odes_pre,\n        [0, T_pre],\n        y0_initial,\n        args=(params,),\n        dense_output=True\n    )\n    y0_ss = sol_pre.sol(T_pre)\n\n    # --- Step 2  3: Simulation and Peak Counting Loop ---\n    \n    def odes_pulse(t, y, p, D):\n        I_m, I, N_n = y\n        \n        u_t = p['A'] if 0 <= t <= D else 0.0\n        \n        N_free = (p['N_tot'] - N_n) / (1.0 + p['alpha'] * I)\n        \n        dIm_dt = p['k_tx'] * (N_n**p['h']) / (p['K']**p['h'] + N_n**p['h']) - p['k_mdeg'] * I_m\n        dI_dt = p['k_tl'] * I_m - (p['k_deg0'] + p['k_deg1'] * u_t) * I\n        dNn_dt = p['k_in'] * N_free - p['k_out'] * N_n\n        \n        return [dIm_dt, dI_dt, dNn_dt]\n\n    results = []\n    for D in test_cases:\n        T_sim = D + T_post\n        t_eval = np.arange(0, T_sim + dt, dt)\n        \n        sol = solve_ivp(\n            odes_pulse,\n            [0, T_sim],\n            y0_ss,\n            args=(params, D),\n            t_eval=t_eval,\n            method='RK45'\n        )\n        \n        t_traj = sol.t\n        Nn_traj = sol.y[2, :]\n\n        # Peak counting\n        distance_indices = int(delta_t_min_peak / dt)\n        \n        peaks, _ = find_peaks(\n            Nn_traj,\n            height=N_th,\n            prominence=prominence,\n            distance=distance_indices\n        )\n        \n        # Filter peaks by minimum time\n        final_peaks = [p for p in peaks if t_traj[p] >= t_min_peak]\n        \n        num_peaks = len(final_peaks)\n        results.append(num_peaks)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2605661"}]}