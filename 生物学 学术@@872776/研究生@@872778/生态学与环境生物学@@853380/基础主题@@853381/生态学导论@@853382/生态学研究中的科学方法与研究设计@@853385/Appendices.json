{"hands_on_practices": [{"introduction": "在实验生态学中，有效的统计推断的基石是真正的重复。本练习展示了一种常见的分层设计，在这种设计中，真正的实验单元很容易被混淆，这是一个被称为“伪重复”（pseudoreplication）的严重错误。通过仔细剖析这个研究设计[@problem_id:2538657]，你将练习识别独立施加处理的单元，这是确保统计检验有效性的关键一步。", "problem": "一项实验室微观世界实验测试了温度对一种小型水生无脊椎动物单位个体代谢率的影响。实验设置了 $3$ 个温度处理：$12$、$18$ 和 $24$ 摄氏度。为实施处理，实验室为每个温度维持了 $2$ 个独立的水浴，每个水浴都有自己的恒温器和再循环回路。在每个水浴内，有 $4$ 个曝气箱放置在同一个架子上，并专门连接到该水浴。每个箱子包含 $8$ 个从一个大型、充分混合的储备种群中随机抽取的个体。使用校准过的呼吸测量仪，连续三天对每个个体的耗氧率进行 $3$ 次测量。温度仅在水浴层面进行控制；所有连接到同一水浴的箱子共享相同的循环水和环境微气候。不存在其他区组因素。假设没有死亡，没有缺失数据，并且所有测量误差在其设计层次的相应水平内是独立同分布的。\n\n研究人员计划使用固定效应单因素方差分析 (ANOVA) 来检验不同温度下的平均代谢率是否存在差异。从实验单元、重复和自由度的核心定义出发，确定能避免该设计中伪重复的恰当分析单元，并在一个尊重随机化、基于设计（design-based）的分析下，计算温度效应 $F$ 检验的分母自由度。\n\n以整数形式提供温度效应 $F$ 检验的分母自由度作为你的最终答案。无需四舍五入。", "solution": "该问题要求在一个分层实验设计中，确定用于检验处理效应的 $F$ 检验的恰当分析单元及其对应的分母自由度。解决方案要求严格应用实验单元和重复的定义，以避免伪重复这一统计谬误。\n\n首先，我们必须定义核心概念。**实验单元**是指独立接受一种处理的实验材料的最小单位。真正的**重复**是指将一种处理应用于多个独立的实验单元。**伪重复**发生于将来自单个实验单元的子样本或重复测量值当作独立重复来处理。在方差分析 ($ANOVA$) 中，处理效应检验的分母自由度必须基于真正实验单元的数量，而不是子样本或测量的数量。\n\n让我们剖析所述实验的分层结构。\n处理因素是温度，有 $a=3$ 个水平：$12^\\circ\\text{C}$、$18^\\circ\\text{C}$ 和 $24^\\circ\\text{C}$。\n\n处理之下的实验结构最高层次是**水浴**。问题陈述道：“为每个温度，[有] $2$ 个独立的水浴，每个水浴都有自己的恒温器和再循环回路。” 这句话至关重要。特定温度的应用是在水浴层面上控制的。因为每个水浴都有自己的恒温器，所以将一个温度分配给一个水浴在物理上和统计上都独立于对任何其他水浴的分配。因此，**水浴是实验单元**。\n每个温度处理的真正重复数是 $n=2$。\n整个实验中的实验单元总数是处理数乘以每个处理的重复数：$N = a \\times n = 3 \\times 2 = 6$。\n\n设计层次中的后续层次是这些实验单元内的子样本。\n- **箱子**：在每个水浴内，有 $k=4$ 个箱子。这些箱子“共享相同的循环水和环境微气候”。因此，来自同一水浴内不同箱子的观测值不是独立的。它们受到与该特定水浴的温度调节和水化学相关的相同随机误差的影响。这些箱子是**子样本**或**观测单元**，而不是实验单元。\n- **个体**：在每个箱子内，有 $m=8$ 个个体。这些个体也是子样本，嵌套在箱子内。它们的代谢率不是独立的，因为它们共享箱子的共同环境，并延伸到水浴的共同环境。\n- **测量**：每个个体被测量 $p=3$ 次。这些是对同一个体的**重复测量**，也不是温度效应的独立重复。\n\n单因素 $ANOVA$ 检验处理组均值相等的假设。该检验的 $F$ 统计量是处理均方与误差均方之比：\n$$ F = \\frac{\\text{MS}_{\\text{Treatment}}}{\\text{MS}_{\\text{Error}}} $$\n$\\text{MS}_{\\text{Treatment}}$ 量化了 $a=3$ 个温度组的平均代谢率*之间*的变异。其自由度为 $\\text{df}_{\\text{Treatment}} = a - 1 = 3 - 1 = 2$。\n$\\text{MS}_{\\text{Error}}$ 必须量化每个处理组内*真正实验单元之间*的随机变异。这就是水浴之间的变异。这个误差项的自由度，也就是 $F$ 检验的分母自由度，是根据实验单元总数 ($N$) 和处理组数 ($a$) 计算的。\n\n分母自由度由下式给出：\n$$ \\text{df}_{\\text{Error}} = N - a $$\n在此设计中，实验单元（水浴）的总数是 $N=6$，处理组（温度）的数量是 $a=3$。\n因此，温度效应 $F$ 检验的分母自由度是：\n$$ \\text{df}_{\\text{Error}} = 6 - 3 = 3 $$\n任何使用箱子总数（$24$）、个体总数（$192$）或测量总数（$576$）来计算误差自由度（例如，$24-3=21$，$192-3=189$ 或 $576-3=573$）的分析都会犯下伪重复的错误，导致统计功效的无效膨胀和犯第一类错误的高概率。正确的分析尊重了随机化，而随机化发生在水浴层面。温度效应的恰当误差项是在 $a=3$ 个温度中，每个温度下 $n=2$ 个水浴之间观察到的变异。", "answer": "$$\\boxed{3}$$", "id": "2538657"}, {"introduction": "与受控实验不同，观测研究常常面临数据不完善的挑战，例如即使物种存在也未能探测到它。本练习探讨了“不完美探测”（imperfect detection）的后果，并将物种存在的朴素估计与稳健的基于模型的估计进行对比[@problem_id:2538648]。掌握这些概念对于从真实的调查数据中准确评估物种分布至关重要。", "problem": "一位研究人员设计了一项在 $N$ 个空间上分离的样点进行的重复访问物种探测研究。每个样点使用标准化的方案访问 $K$ 次，每次访问可能产生“探测到”或“未探测到”两种结果。假设该研究设计满足以下理想化条件：在调查窗口期内，样点的入住状态不发生改变；在给定样点真实入住状态的条件下，各次访问是条件独立的；探测概率和假阳性率在所有访问和样点中保持不变；由于错误识别或传感器噪声等原因，未入住的样点也可能记录到探测。设 $\\psi$ 表示一个随机选择的样点被真实入住的概率，$p$ 表示在样点真实入住的情况下单次访问记录到探测的概率，而 $f$ 表示在样点真实未入住的情况下单次访问记录到探测的概率。将朴素入住率估计量定义为在 $K$ 次访问中至少有1次探测记录的样点所占的比例。基于模型的入住率估计使用每个样点在 $K$ 次访问中的完整探测历史，在一个正确指定的似然函数下，联合推断 $\\psi$ 和观测过程参数。\n\n选择在此框架下所有正确的陈述。\n\nA. 探测概率 $p$ 是在物种真实存在于样点的条件下，单次调查记录到探测的条件概率；入住率 $\\psi$ 是一个随机选择的样点被真实入住的边际概率；假阳性率 $f$ 是在物种真实不存在的情况下，单次调查记录到探测的条件概率。\n\nB. 当 $f = 0$ 且 $0  p  1$ 时，朴素入住率估计量的期望值等于 $\\psi\\, p^{K}$，因为一个入住的样点只有在所有 $K$ 次访问中都被探测到时，才对朴素入住率有贡献。\n\nC. 当 $f = 0$ 且 $0  p  1$ 时，朴素入住率估计量的期望值等于 $\\psi \\,[1 - (1-p)^{K}]$，因此朴素估计量对于 $\\psi$ 是偏低的，除非 $p = 1$ 或者 $K$ 足够大以至于 $(1-p)^{K}$ 可以忽略不计。\n\nD. 当 $f > 0$ 时，朴素入住率估计量的期望值等于 $\\psi \\,[1 - (1-p)^{K}] + (1-\\psi)\\,[1 - (1-f)^{K}]$，因此朴素入住率可能比 $\\psi$ 大或小，具体取决于 $p$、$f$ 和 $K$。一个使用完整探测历史来同时考虑 $p$ 和 $f$ 的基于模型的估计量，在模型设定正确的情况下，对于 $\\psi$ 可以是近似无偏的。\n\nE. 基于模型的入住率估计忽略了样点内部的探测历史（只要至少有1次探测即可），因此等同于朴素估计量。\n\nF. 解决不完美探测的唯一方法是增加 $K$ 直到每个入住的样点都至少被探测到一次；没有真实的“存在-缺失”数据，统计建模无法对不完美探测或假阳性进行调整。", "solution": "在尝试解答之前，将对问题陈述进行验证。\n\n### 步骤1：提取已知条件\n- 样点数：$N$\n- 每个样点的访问次数：$K$\n- 观测结果：探测到或未探测到\n- 假设1：在调查窗口期内，样点入住状态保持不变（封闭性）。\n- 假设2：在给定样点真实入住状态的条件下，各次访问是条件独立的。\n- 假设3：探测概率和假阳性率在所有访问和样点中保持不变。\n- 假设4：未入住的样点也可能记录到探测。\n- $\\psi$：一个随机选择的样点被真实入住的概率。\n- $p$：在样点真实入住的情况下单次访问记录到探测的概率。\n- $f$：在样点真实未入住的情况下单次访问记录到探测的概率。\n- 朴素入住率估计量：在 $K$ 次访问中至少有1次探测记录的样点所占的比例。\n- 基于模型的入住率估计：使用完整探测历史，通过一个正确指定的似然函数来联合推断 $\\psi$、$p$ 和 $f$。\n\n### 步骤2：使用提取的已知条件进行验证\n问题陈述描述了一个标准的生态统计学场景，即入住率模型。参数 $\\psi$、$p$ 和 $f$ 的定义与既有文献（例如，MacKenzie et al., 2002; Royle  Link, 2006）一致。封闭性、独立性和参数恒定的假设是最简单但也是基础的入住率模型的基石。朴素估计和基于模型的估计之间的区别也是该领域的核心。该问题具有科学依据，提法恰当且客观。它提供了所有必要的定义和假设，以便严格评估所给出的陈述。没有矛盾、歧义或事实上的不健全之处。\n\n### 步骤3：结论与行动\n问题陈述是有效的。将对每个选项进行全面分析。\n\n### 选项分析\n\n设 $Z$ 为一个随机选择的样点的真实入住状态的随机变量，其中当样点被入住时 $Z=1$，未入住时 $Z=0$。根据问题定义，$P(Z=1) = \\psi$ 且 $P(Z=0) = 1-\\psi$。\n设 $Y_k$ 为第 $k$ 次访问的观测结果的随机变量，其中 $Y_k=1$ 表示探测到，$Y_k=0$ 表示未探测到。问题定义了以下条件概率：\n- $p = P(Y_k=1 | Z=1)$\n- $f = P(Y_k=1 | Z=0)$\n\n朴素入住率估计量 $\\hat{\\psi}_{\\text{naive}}$ 是在 $K$ 次访问中至少记录到一次探测的样点所占的比例。该估计量的期望值 $E[\\hat{\\psi}_{\\text{naive}}]$ 是一个随机选择的样点至少有一次探测的概率。设 $D$ 为一个样点至少有一次探测的事件。\n$$E[\\hat{\\psi}_{\\text{naive}}] = P(D) = P(D|Z=1)P(Z=1) + P(D|Z=0)P(Z=0)$$\n\n在一个入住的样点，单次访问*未*探测到的概率是 $1-p$。在 $K$ 次独立访问中均*未*探测到的概率是 $(1-p)^K$。因此，至少有一次探测到的概率是 $P(D|Z=1) = 1 - (1-p)^K$。\n类似地，在一个未入住的样点，至少有一次假阳性探测的概率是 $P(D|Z=0) = 1 - (1-f)^K$。\n将这些代入 $P(D)$ 的表达式，得到朴素估计量期望值的一般公式：\n$$E[\\hat{\\psi}_{\\text{naive}}] = \\psi[1 - (1-p)^K] + (1-\\psi)[1 - (1-f)^K]$$\n\n我们现在将使用这个框架来评估每个陈述。\n\n**A. 探测概率 $p$ 是在物种真实存在于样点的条件下，单次调查记录到探测的条件概率；入住率 $\\psi$ 是一个随机选择的样点被真实入住的边际概率；假阳性率 $f$ 是在物种真实不存在的情况下，单次调查记录到探测的条件概率。**\n\n该陈述为这些参数提供了形式化的概率定义。\n- 参数 $p$ 在问题中定义为“在样点真实入住的情况下单次访问记录到探测的概率”，这正是条件概率 $P(\\text{探测到} | \\text{存在})$。\n- 参数 $\\psi$ 定义为“一个随机选择的样点被真实入住的概率”，这是边际概率 $P(\\text{存在})$。\n- 参数 $f$ 定义为“在样点真实未入住的情况下单次访问记录到探测的概率”，这是条件概率 $P(\\text{探测到} | \\text{不存在})$。\n该陈述是对问题陈述中定义的正确而精确的表述。\n**结论：正确。**\n\n**B. 当 $f = 0$ 且 $0  p  1$ 时，朴素入住率估计量的期望值等于 $\\psi\\, p^{K}$，因为一个入住的样点只有在所有 $K$ 次访问中都被探测到时，才对朴素入住率有贡献。**\n\n一个样点对朴素入住率计数有贡献的条件是它有*至少一次*探测，而不是在*所有* $K$ 次访问中都被探测到。其推理从根本上是错误的。\n使用我们的一般期望值公式并设 $f=0$：\n$$E[\\hat{\\psi}_{\\text{naive}}] = \\psi[1 - (1-p)^K] + (1-\\psi)[1 - (1-0)^K]$$\n$$E[\\hat{\\psi}_{\\text{naive}}] = \\psi[1 - (1-p)^K] + (1-\\psi)[1 - 1^K] = \\psi[1 - (1-p)^K]$$\n该陈述声称期望值为 $\\psi p^K$。这是不正确的。量 $p^K$ 是在物种存在的情况下，在*所有* $K$ 次访问中都探测到该物种的概率。该陈述的公式和推理都是不正确的。\n**结论：不正确。**\n\n**C. 当 $f = 0$ 且 $0  p  1$ 时，朴素入住率估计量的期望值等于 $\\psi \\,[1 - (1-p)^{K}]$，因此朴素估计量对于 $\\psi$ 是偏低的，除非 $p = 1$ 或者 $K$ 足够大以至于 $(1-p)^{K}$ 可以忽略不计。**\n\n根据对选项B的分析，期望值的公式是正确的：$E[\\hat{\\psi}_{\\text{naive}}] = \\psi[1 - (1-p)^K]$。\n一个估计量的偏差是其期望值与真实参数值之间的差异。\n$$\\text{偏差} = E[\\hat{\\psi}_{\\text{naive}}] - \\psi = \\psi[1 - (1-p)^K] - \\psi = \\psi - \\psi(1-p)^K - \\psi = -\\psi(1-p)^K$$\n鉴于 $\\psi > 0$ 且 $0  p  1$，可得 $0  1-p  1$。对于任何有限整数 $K \\ge 1$，$(1-p)^K$ 是一个正数。因此，偏差 $-\\psi(1-p)^K$ 是严格为负的。具有负偏差的估计量被称为“偏低”。\n偏差仅在 $\\psi = 0$（一个平凡情况）或 $(1-p)^K = 0$ 时为零。第二个条件在 $p=1$（完美探测）时或在 $K \\to \\infty$ 的极限情况下满足。关于偏差在 $K$ 足够大时变得可以忽略不计的说法也是正确的，因为 $\\lim_{K\\to\\infty} (1-p)^K = 0$。该陈述完全正确。\n**结论：正确。**\n\n**D. 当 $f > 0$ 时，朴素入住率估计量的期望值等于 $\\psi \\,[1 - (1-p)^{K}] + (1-\\psi)\\,[1 - (1-f)^{K}]$，因此朴素入住率可能比 $\\psi$ 大或小，具体取决于 $p$、$f$ 和 $K$。一个使用完整探测历史来同时考虑 $p$ 和 $f$ 的基于模型的估计量，在模型设定正确的情况下，对于 $\\psi$ 可以是近似无偏的。**\n\n该陈述的第一部分提供了朴素估计量期望值的公式。这与本分析开头推导的一般公式相符。\n$$E[\\hat{\\psi}_{\\text{naive}}] = \\psi[1 - (1-p)^K] + (1-\\psi)[1 - (1-f)^K]$$\n偏差为：\n$$\\text{偏差} = E[\\hat{\\psi}_{\\text{naive}}] - \\psi = -\\psi(1-p)^K + (1-\\psi)[1 - (1-f)^K]$$\n该偏差由两部分组成：一个由入住样点的不完美探测引起的负分量 $-\\psi(1-p)^K$，以及一个由未入住样点的假阳性探测引起的正分量 $(1-\\psi)[1 - (1-f)^K]$。由于总偏差是一个负项和一个正项的和，其符号取决于它们的相对大小，而这些大小是 $\\psi$、$p$、$f$ 和 $K$ 的函数。因此，朴素估计量可能高估（$\\text{偏差} > 0$）或低估（$\\text{偏差}  0$）真实入住率 $\\psi$。\n该陈述的第二部分阐述了基于模型的估计的效用。从完整探测历史构建似然函数的全部目的，是将生态状态过程（参数 $\\psi$）与观测过程（参数 $p$ 和 $f$）分离开来。从此类模型中导出的最大似然估计量，在模型设定正确的情况下，是已知的一致且渐近无偏的。对于有限的样本量 $N$，它们是近似无偏的。该陈述准确地描述了基于模型的入住率估计的一个主要优势。\n**结论：正确。**\n\n**E. 基于模型的入住率估计忽略了样点内部的探测历史（只要至少有1次探测即可），因此等同于朴素估计量。**\n\n该陈述与问题陈述中给出的定义直接矛盾，该定义指出基于模型的估计“使用完整探测历史”。完整的探测历史是一个结果序列，如 $(0, 1, 0, 0, \\dots)$，而不仅仅是是否有任何探测发生的摘要。朴素估计量将此详细信息压缩为一个二元变量（总体上探测到/未探测到）。基于模型的方法使用完整的序列来构建似然函数，从中可以估计像 $p$ 和 $f$ 这样的参数。例如，两个历史记录 $(1, 0, 0, 0)$ 和 $(1, 1, 1, 1)$ 会产生相同的朴素结果，但为估计 $p$ 提供了截然不同的信息。因此，基于模型的估计与朴素估计量有根本的不同，且不等价。\n**结论：不正确。**\n\n**F. 解决不完美探测的唯一方法是增加 $K$ 直到每个入住的样点都至少被探测到一次；没有真实的“存在-缺失”数据，统计建模无法对不完美探测或假阳性进行调整。**\n\n该陈述提出了两个强硬但不正确的论断。首先，它声称增加 $K$ 是解决不完美探测的*唯一*方法。这是错误的。整个问题的前提是，统计建模提供了一种替代方法来考虑不完美探测，并在不要求 $p=1$ 或 $K \\to \\infty$ 的情况下获得 $\\psi$ 的无偏估计。\n其次，它声称“没有真实的‘存在-缺失’数据，统计建模无法对不完美探测或假阳性进行调整。” 这正是入住率模型旨在克服的谬误。通过在样点进行重复观测，模型可以直接从数据中估计观测过程参数（$p$ 和 $f$），即使没有一组预先验证过的入住和未入住的样点。调查设计中的重复性为分离状态过程和观测过程提供了统计功效。\n**结论：不正确。**", "answer": "$$\\boxed{ACD}$$", "id": "2538648"}, {"introduction": "生态数据很少是相互独立的；地理位置上更近的样本点往往更相似，这种现象被称为“空间自相关”（spatial autocorrelation）。空间数据的这一基本特性会使标准的模型评估技术（如k-fold交叉验证）失效，从而导致对预测性能的评估过于乐观。这个高级练习[@problem_id:2538654]将指导你设计一个能感知空间结构的验证方案，并量化其相对于传统方法所能减少的偏差，这对于构建预测性空间模型的生态学家来说是一项关键技能。", "problem": "您正在研究如何在存在空间自相关的情况下评估生境适宜性模型。在这种情况下，由于测试点在空间上与训练点接近，朴素的随机 $k$ 折交叉验证可能会对预测性能产生乐观的估计。请提出一种 $k$ 折空间交叉验证设计以减少这种乐观性，并在一个明确指定的随机空间模型下，量化相对于随机分折的最近邻预测误差估计的偏差预期减少量。您的程序必须实现所需的计算，并为提供的测试套件输出数值结果。\n\n假设空间位置上的观测值遵循以下生成模型。位置从平面上的均匀泊松点过程 (PPP) 中抽样，其强度为 $\\lambda$（单位面积内的期望点数）。位于 $\\mathbf{s}$ 的每个观测值为\n$$\ny(\\mathbf{s}) = f(\\mathbf{s}) + \\varepsilon(\\mathbf{s}),\n$$\n其中 $f(\\cdot)$ 是一个零均值高斯过程 (GP)，其指数协方差为 $\\operatorname{Cov}(f(\\mathbf{s}), f(\\mathbf{t})) = \\sigma_f^2 \\exp(-\\|\\mathbf{s}-\\mathbf{t}\\|/\\phi)$，范围参数 $\\phi  0$，而 $\\varepsilon(\\mathbf{s}) \\sim \\mathcal{N}(0,\\sigma_\\varepsilon^2)$ 是独立同分布的，并且独立于 $f(\\cdot)$。\n\n考虑以下两种交叉验证方案。\n\n- 随机 $k$ 折交叉验证：将 $n$ 个点随机划分为 $k$ 个折，轮流使用每个折进行测试，同时在其余 $k-1$ 个折上进行训练。在 PPP 模型的大域极限下，训练集构成了 PPP 的一个独立稀疏化，其强度为 $\\lambda_t = \\lambda \\cdot \\frac{k-1}{k}$。\n\n- 带缓冲区的空间块 $k$ 折交叉验证：将空间划分为 $k$ 个不相交、空间连续的测试块（例如，用 $k$ 个等面积块进行平铺）。对于每个折，取一个块作为测试集，并从训练集中移除每个测试位置周围半径为 $b$ 的缓冲区内的所有点；仅在缓冲区外的点上进行训练。在 PPP 下，以测试位置周围半径 $b$ 内没有训练点为条件，并利用 PPP 在面积上的无记忆性，从测试位置到其最近邻训练位置的距离的条件分布的支撑集在 $[b,\\infty)$ 上。\n\n为了量化由于空间自相关导致的预测性能的乐观性，使用以下标准化参考预测器：对于位于 $\\mathbf{s}^\\star$ 的测试点，通过其最近邻训练点的响应进行预测，\n$$\n\\hat{y}(\\mathbf{s}^\\star) = y(\\mathbf{s}_{\\text{nn}}),\n$$\n其中 $\\mathbf{s}_{\\text{nn}}$ 是使到 $\\mathbf{s}^\\star$ 的欧几里得距离最小化的训练位置。在此预测器下，给定最近邻距离 $D$ 的条件均方预测误差 (MSE) 为\n$$\n\\operatorname{MSE}(D) = \\mathbb{E}\\big[(y(\\mathbf{s}^\\star) - \\hat{y}(\\mathbf{s}^\\star))^2 \\mid D\\big] = 2\\sigma_f^2\\big(1 - e^{-D/\\phi}\\big) + 2\\sigma_\\varepsilon^2.\n$$\n因此，期望 MSE 取决于在 $D$ 的适当分布下的期望值 $\\mathbb{E}[e^{-D/\\phi}]$。\n\nPPP 的基本事实意味着以下内容。对于随机 $k$ 折交叉验证，从一个测试点到其最近邻训练点的距离 $D_{\\text{rnd}}$ 服从瑞利分布，其密度为\n$$\nf_{\\text{rnd}}(d) = 2\\pi \\lambda_t d \\, e^{-\\pi \\lambda_t d^2}, \\quad d \\ge 0,\n$$\n其中 $\\lambda_t = \\lambda \\cdot \\frac{k-1}{k}$。对于带缓冲半径 $b$ 的空间块 $k$ 折交叉验证，最近邻训练距离 $D_{\\text{blk}}$ 的条件密度为\n$$\nf_{\\text{blk}}(d \\mid b) = 2\\pi \\lambda_t d \\, e^{-\\pi \\lambda_t (d^2 - b^2)}, \\quad d \\ge b.\n$$\n\n将两种方案下的期望 MSE 定义为\n$$\n\\mathbb{E}[\\operatorname{MSE}_{\\text{rnd}}] = 2\\sigma_f^2 \\big(1 - \\mathbb{E}[e^{-D_{\\text{rnd}}/\\phi}]\\big) + 2\\sigma_\\varepsilon^2,\n$$\n$$\n\\mathbb{E}[\\operatorname{MSE}_{\\text{blk}}] = 2\\sigma_f^2 \\big(1 - \\mathbb{E}[e^{-D_{\\text{blk}}/\\phi}]\\big) + 2\\sigma_\\varepsilon^2.\n$$\n因此，通过空间分块相对于随机 $k$ 折实现的乐观偏差的预期减少量，即用带缓冲区的空间折代替随机折时估计 MSE 的增加量，为\n$$\n\\Delta_{\\text{bias}} = \\mathbb{E}[\\operatorname{MSE}_{\\text{blk}}] - \\mathbb{E}[\\operatorname{MSE}_{\\text{rnd}}] = 2\\sigma_f^2 \\left(\\mathbb{E}[e^{-D_{\\text{rnd}}/\\phi}] - \\mathbb{E}[e^{-D_{\\text{blk}}/\\phi}]\\right).\n$$\n\n您的任务：\n\n- 精确指定一个 $k$ 折空间交叉验证方案，该方案通过使用如上所述的、由 $k$ 和缓冲半径 $b$ 参数化的带缓冲区的空间块来考虑空间自相关。\n\n- 对测试套件中的每个参数集，使用以下积分表示来计算 $\\Delta_{\\text{bias}}$：\n$$\n\\mathbb{E}[e^{-D_{\\text{rnd}}/\\phi}] = \\int_{0}^{\\infty} e^{-d/\\phi} \\, 2\\pi \\lambda_t d \\, e^{-\\pi \\lambda_t d^2} \\, \\mathrm{d}d,\n$$\n$$\n\\mathbb{E}[e^{-D_{\\text{blk}}/\\phi}] = \\int_{b}^{\\infty} e^{-d/\\phi} \\, 2\\pi \\lambda_t d \\, e^{-\\pi \\lambda_t (d^2 - b^2)} \\, \\mathrm{d}d.\n$$\n\n实现一个程序，对这些积分进行数值计算并报告 $\\Delta_{\\text{bias}}$。\n\n测试套件：\n\n为以下参数集 $(\\lambda, \\phi, \\sigma_f^2, \\sigma_\\varepsilon^2, k, b)$ 提供输出：\n\n- 情况 1：$(\\lambda=\\;0.01,\\; \\phi=\\;5.0,\\; \\sigma_f^2=\\;1.0,\\; \\sigma_\\varepsilon^2=\\;0.25,\\; k=\\;5,\\; b=\\;5.0)$。\n- 情况 2：$(\\lambda=\\;0.01,\\; \\phi=\\;0.5,\\; \\sigma_f^2=\\;1.0,\\; \\sigma_\\varepsilon^2=\\;0.25,\\; k=\\;5,\\; b=\\;5.0)$。\n- 情况 3：$(\\lambda=\\;0.1,\\; \\phi=\\;5.0,\\; \\sigma_f^2=\\;1.0,\\; \\sigma_\\varepsilon^2=\\;0.25,\\; k=\\;10,\\; b=\\;5.0)$。\n- 情况 4：$(\\lambda=\\;0.01,\\; \\phi=\\;10.0,\\; \\sigma_f^2=\\;2.0,\\; \\sigma_\\varepsilon^2=\\;0.5,\\; k=\\;2,\\; b=\\;10.0)$。\n- 情况 5（边界一致性）：$(\\lambda=\\;0.01,\\; \\phi=\\;5.0,\\; \\sigma_f^2=\\;1.0,\\; \\sigma_\\varepsilon^2=\\;0.25,\\; k=\\;5,\\; b=\\;0.0)$。\n\n输出规格：\n\n- 对每种情况，计算单个浮点数 $\\Delta_{\\text{bias}}$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序与上述情况相同，每个浮点数四舍五入到六位小数（例如，$\\texttt{[0.123456,0.000001,0.500000]}$）。", "solution": "我们从适用于生态抽样设计的空间自相关和点过程理论的基本定义开始。位置由强度为 $\\lambda$ 的均匀泊松点过程 (PPP) 建模，这是平面上随机抽样的典范基准。物种-生境信号被建模为一个零均值高斯过程 (GP) $f(\\cdot)$，具有平稳、各向同性的指数协方差 $\\operatorname{Cov}(f(\\mathbf{s}), f(\\mathbf{t})) = \\sigma_f^2 \\exp(-\\|\\mathbf{s}-\\mathbf{t}\\|/\\phi)$，这是一个与衰减的空间相关性一致且经过充分检验的模型。观测噪声 $\\varepsilon(\\mathbf{s})$ 是独立同分布的，方差为 $\\sigma_\\varepsilon^2$。\n\n科学设计原理与方案：一个 $k$ 折空间交叉验证设计应产生与训练数据在空间上至少相隔一个缓冲距离 $b$ 的测试折，以减少训练集和测试集之间的依赖性。这通过确保测试位置与训练位置在距离 $b$ 以内的范围内不存在空间自相关，从而遵循了交叉验证中隐含的“独立性”假设。具体而言，将空间域划分为 $k$ 个不相交的、面积近似相等的连续块（例如，通过空间网格或空间约束聚类）。对于折 $j \\in \\{1,\\dots,k\\}$，将块 $j$ 指定为测试集，并从训练集中排除任何测试点距离 $b$ 内的所有点。在剩余的点上训练模型。此方案依赖于参数 $k$ 和 $b$；选择 $b \\gtrsim \\phi$ 旨在抑制训练和测试之间的大部分空间自相关。\n\n偏差建模原理：为了以基于原理的方式推导偏差，我们在 GP 和 PPP 假设下，分离出一个具有解析上可处理误差的参考预测器。我们选择最近邻预测器\n$$\n\\hat{y}(\\mathbf{s}^\\star) = y(\\mathbf{s}_{\\text{nn}}),\n$$\n它使用最近邻训练位置 $\\mathbf{s}_{\\text{nn}}$ 处的观测响应来预测测试位置 $\\mathbf{s}^\\star$。该预测器将空间依赖性的影响集中在最近邻距离上，从而在空间相关性和预测误差之间建立了精确的联系。以最近邻距离 $D = \\|\\mathbf{s}^\\star - \\mathbf{s}_{\\text{nn}}\\|$ 为条件，预测误差为\n$$\ny(\\mathbf{s}^\\star) - \\hat{y}(\\mathbf{s}^\\star) = f(\\mathbf{s}^\\star) - f(\\mathbf{s}_{\\text{nn}}) + \\varepsilon(\\mathbf{s}^\\star) - \\varepsilon(\\mathbf{s}_{\\text{nn}}).\n$$\n根据 $f(\\cdot)$ 和 $\\varepsilon(\\cdot)$ 的独立性以及 $f(\\cdot)$ 的平稳性，\n$$\n\\mathbb{E}\\!\\left[(y(\\mathbf{s}^\\star) - \\hat{y}(\\mathbf{s}^\\star))^2 \\mid D\\right] = \\operatorname{Var}(f(\\mathbf{s}^\\star) - f(\\mathbf{s}_{\\text{nn}})) + \\operatorname{Var}(\\varepsilon(\\mathbf{s}^\\star) - \\varepsilon(\\mathbf{s}_{\\text{nn}})).\n$$\n对于一个平稳过程，$\\operatorname{Var}(f(\\mathbf{s}) - f(\\mathbf{t})) = 2\\sigma_f^2\\left(1 - \\exp(-\\|\\mathbf{s}-\\mathbf{t}\\|/\\phi)\\right)$，对于独立噪声，$\\operatorname{Var}(\\varepsilon(\\mathbf{s}) - \\varepsilon(\\mathbf{t})) = 2\\sigma_\\varepsilon^2$。因此，\n$$\n\\operatorname{MSE}(D) = 2\\sigma_f^2\\left(1 - e^{-D/\\phi}\\right) + 2\\sigma_\\varepsilon^2.\n$$\n\nPPP 稀疏化下的最近邻距离分布：在随机 $k$ 折交叉验证下，训练集是 PPP 的一个独立稀疏化，强度为 $\\lambda_t = \\lambda \\cdot \\frac{k-1}{k}$。PPP 的一个基本结果表明，从一个固定位置到点过程的最近邻距离服从瑞利密度\n$$\nf_{\\text{rnd}}(d) = 2\\pi \\lambda_t d \\, e^{-\\pi \\lambda_t d^2}, \\quad d \\ge 0.\n$$\n对于带缓冲半径 $b$ 的空间块交叉验证，以测试位置半径 $b$ 内没有训练点为条件，缓冲区外的 PPP 仍然是具有相同强度的 PPP（根据面积上的无记忆性）。最近邻训练距离的生存函数满足\n$$\n\\mathbb{P}(D_{\\text{blk}}  d \\mid D_{\\text{blk}} \\ge b) = e^{-\\pi \\lambda_t (d^2 - b^2)}, \\quad d \\ge b,\n$$\n因此，在 $[b,\\infty)$ 上的条件密度为\n$$\nf_{\\text{blk}}(d \\mid b) = 2\\pi \\lambda_t d \\, e^{-\\pi \\lambda_t (d^2 - b^2)}, \\quad d \\ge b.\n$$\n\n期望性能与偏差减少：对 $D$ 取期望可得\n$$\n\\mathbb{E}[\\operatorname{MSE}_{\\text{rnd}}] = 2\\sigma_f^2\\left(1 - \\int_{0}^{\\infty} e^{-d/\\phi} \\, 2\\pi \\lambda_t d \\, e^{-\\pi \\lambda_t d^2} \\, \\mathrm{d}d \\right) + 2\\sigma_\\varepsilon^2,\n$$\n$$\n\\mathbb{E}[\\operatorname{MSE}_{\\text{blk}}] = 2\\sigma_f^2\\left(1 - \\int_{b}^{\\infty} e^{-d/\\phi} \\, 2\\pi \\lambda_t d \\, e^{-\\pi \\lambda_t (d^2 - b^2)} \\, \\mathrm{d}d \\right) + 2\\sigma_\\varepsilon^2.\n$$\n相减可得，\n$$\n\\Delta_{\\text{bias}} = \\mathbb{E}[\\operatorname{MSE}_{\\text{blk}}] - \\mathbb{E}[\\operatorname{MSE}_{\\text{rnd}}] = 2\\sigma_f^2 \\left( \\int_{0}^{\\infty} e^{-d/\\phi} \\, 2\\pi \\lambda_t d \\, e^{-\\pi \\lambda_t d^2} \\, \\mathrm{d}d \\;-\\; \\int_{b}^{\\infty} e^{-d/\\phi} \\, 2\\pi \\lambda_t d \\, e^{-\\pi \\lambda_t (d^2 - b^2)} \\, \\mathrm{d}d \\right).\n$$\n该差值为非负，因为第二个积分是关于一个在 $d$ 上随机更大的分布进行的，而核 $e^{-d/\\phi}$ 在 $d$ 上是递减的。注意 $\\sigma_\\varepsilon^2$ 被消掉了，因为对于最近邻预测器，噪声对两种方案的影响是相同的。\n\n算法设计：对于每个测试用例 $(\\lambda, \\phi, \\sigma_f^2, \\sigma_\\varepsilon^2, k, b)$，\n- 计算 $\\lambda_t = \\lambda \\cdot \\frac{k-1}{k}$。\n- 使用在 $d \\in [0,\\infty)$ 和 $d \\in [b,\\infty)$ 上的一维求积法，以及各自的密度 $f_{\\text{rnd}}$ 和 $f_{\\text{blk}}$ 与核 $e^{-d/\\phi}$，数值计算两个期望值。\n- 计算 $\\Delta_{\\text{bias}} = 2\\sigma_f^2 \\left(\\mathbb{E}[e^{-D_{\\text{rnd}}/\\phi}] - \\mathbb{E}[e^{-D_{\\text{blk}}/\\phi}]\\right)$。\n- 为保证输出一致性，结果四舍五入到六位小数。\n\n设计覆盖范围和边缘情况：测试套件包括一个典型的中等自相关场景（情况 1），一个偏差减少应为最小的近乎无自相关场景（情况 2，$\\phi$ 较小），一个高密度多折场景，增加了随机分折下小最近邻距离的可能性（情况 3），一个强自相关、大缓冲区、小 $k$ 值的情况（情况 4），以及一个边界检查 $b=0$，此时空间分块退化为随机分折，$\\Delta_{\\text{bias}}$ 在数值上应为零（情况 5）。\n\n该程序在规定的假设下，确定性地执行这些步骤，无需模拟，从而确保可复现性和科学真实性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef expected_exp_neg_d_over_phi_random(lmbda, k, phi):\n    \"\"\"E[exp(-D/phi)] for nearest-neighbor distance D under random k-fold (Rayleigh with lambda_t).\"\"\"\n    lambda_t = lmbda * (k - 1.0) / k\n\n    def integrand(d):\n        return np.exp(-d / phi) * 2.0 * np.pi * lambda_t * d * np.exp(-np.pi * lambda_t * d * d)\n\n    # Integrate from 0 to infinity\n    val, _ = quad(integrand, 0.0, np.inf, epsabs=1e-10, epsrel=1e-10, limit=200)\n    return val\n\ndef expected_exp_neg_d_over_phi_block(lmbda, k, phi, b):\n    \"\"\"E[exp(-D/phi)] for nearest-neighbor distance D under block CV with buffer b.\"\"\"\n    lambda_t = lmbda * (k - 1.0) / k\n\n    if b == 0.0:\n        # Reduce to random case\n        return expected_exp_neg_d_over_phi_random(lmbda, k, phi)\n\n    def integrand(d):\n        # Use the conditional density directly to avoid overflow: exp(-pi*lambda_t*(d^2 - b^2))\n        return np.exp(-d / phi) * 2.0 * np.pi * lambda_t * d * np.exp(-np.pi * lambda_t * (d * d - b * b))\n\n    # Integrate from b to infinity\n    val, _ = quad(integrand, b, np.inf, epsabs=1e-10, epsrel=1e-10, limit=200)\n    return val\n\ndef bias_reduction(lmbda, phi, sigma_f2, sigma_eps2, k, b):\n    # Compute 2 * sigma_f^2 * (E_random - E_block). Note sigma_eps2 cancels.\n    e_rnd = expected_exp_neg_d_over_phi_random(lmbda, k, phi)\n    e_blk = expected_exp_neg_d_over_phi_block(lmbda, k, phi, b)\n    delta = 2.0 * sigma_f2 * (e_rnd - e_blk)\n    return delta\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (lambda, phi, sigma_f^2, sigma_eps^2, k, b)\n    test_cases = [\n        (0.01, 5.0, 1.0, 0.25, 5, 5.0),    # Case 1\n        (0.01, 0.5, 1.0, 0.25, 5, 5.0),    # Case 2\n        (0.1, 5.0, 1.0, 0.25, 10, 5.0),    # Case 3\n        (0.01, 10.0, 2.0, 0.5, 2, 10.0),   # Case 4\n        (0.01, 5.0, 1.0, 0.25, 5, 0.0),    # Case 5 (boundary: no buffer)\n    ]\n\n    results = []\n    for case in test_cases:\n        lmbda, phi, sigma_f2, sigma_eps2, k, b = case\n        delta = bias_reduction(lmbda, phi, sigma_f2, sigma_eps2, k, b)\n        # Round to six decimals as specified\n        results.append(f\"{delta:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2538654"}]}