{"hands_on_practices": [{"introduction": "生态修复的一个核心目标是重建一个特征性的生物群落。为了评估修复工作的成功与否，我们需要量化工具来比较修复后场地与参考场地的物种组成。本练习将通过计算两个基础的群落生态学相似性指数，来帮助你确定一个场地是否达到了其修复目标 [@problem_id:2526256]。", "problem": "一个恢复监测团队正在评估一处河岸草甸恢复项目在$5$年后是否达到了类似参考点的群落组成。决策框架要求使用两种源于群落生态学的互补相似性度量方法，将一个候选恢复点与一个参考点进行比较：基于原始丰度的Bray–Curtis相似性和基于存在–缺失数据的Jaccard相似性。只有当两种相似性度量均至少为$0.7$时，才算符合项目的参考条件标准。为了定量地总结绩效，该团队报告一个保守合规分数，该分数定义为两个相似性值中较小的一个。\n\n现给出参考点（$R$）和恢复点（$S$）$10$个核心物种的标准化植物物种丰度（每$100 \\ \\mathrm{m}^2$的茎数）：\n\n- 物种 A：$R = 20$, $S = 18$\n- 物种 B：$R = 15$, $S = 11$\n- 物种 C：$R = 5$, $S = 6$\n- 物种 D：$R = 8$, $S = 7$\n- 物种 E：$R = 12$, $S = 10$\n- 物种 F：$R = 0$, $S = 2$\n- 物种 G：$R = 9$, $S = 8$\n- 物种 H：$R = 3$, $S = 2$\n- 物种 I：$R = 10$, $S = 9$\n- 物种 J：$R = 2$, $S = 0$\n\n请仅使用这些指数的基本定义，直接从数据中计算两种相似性，判断该地点是否满足参考条件标准（两种相似性均至少为$0.7$），并报告保守合规分数，该分数定义为两个相似性值中较小的一个。将合规分数以小数形式表示（不带百分号），并将答案四舍五入至四位有效数字。最终报告的数字不需要单位。", "solution": "我们从群落生态学中使用的标准基本定义开始：\n\n1. 对于Bray–Curtis族，两个非负丰度向量 $\\mathbf{x}$ 和 $\\mathbf{y}$ 之间的Bray–Curtis相异性定义为\n$$\n\\mathrm{BC\\_dissim}(\\mathbf{x},\\mathbf{y}) \\;=\\; \\frac{\\sum_{i} |x_{i} - y_{i}|}{\\sum_{i} (x_{i} + y_{i})}.\n$$\nBray–Curtis相似性则定义为\n$$\n\\mathrm{BC\\_sim}(\\mathbf{x},\\mathbf{y}) \\;=\\; 1 - \\mathrm{BC\\_dissim}(\\mathbf{x},\\mathbf{y}).\n$$\n一个等效且通常在计算上更方便的形式是\n$$\n\\mathrm{BC\\_sim}(\\mathbf{x},\\mathbf{y}) \\;=\\; \\frac{2 \\sum_{i} \\min(x_{i},y_{i})}{\\sum_{i} (x_{i} + y_{i})},\n$$\n这可由非负数 $x_{i},y_{i}$ 的恒等式 $x_{i} + y_{i} = |x_{i}-y_{i}| + 2\\min(x_{i},y_{i})$ 推导得出。\n\n2. 对于存在–缺失数据，两个集合 $A$ 和 $B$（每个群落中存在的物种集合）之间的Jaccard相似性定义为\n$$\nJ(A,B) \\;=\\; \\frac{|A \\cap B|}{|A \\cup B|},\n$$\n其中 $|\\,\\cdot\\,|$ 表示集合的基数，“存在”定义为观测到的丰度严格为正。\n\n我们现在从第一性原理计算这两种相似性。\n\n步骤 1：基于原始丰度的Bray–Curtis相似性。\n\n设 $\\mathbf{r}$ 表示参考点丰度，$\\mathbf{s}$ 表示恢复点丰度，物种按A、B、C、D、E、F、G、H、I、J的顺序列出：\n$$\n\\mathbf{r} = (20,\\,15,\\,5,\\,8,\\,12,\\,0,\\,9,\\,3,\\,10,\\,2), \\quad\n\\mathbf{s} = (18,\\,11,\\,6,\\,7,\\,10,\\,2,\\,8,\\,2,\\,9,\\,0).\n$$\n计算 $\\sum_{i} (r_{i} + s_{i})$：\n- 物种 A：$20 + 18 = 38$\n- 物种 B：$15 + 11 = 26$\n- 物种 C：$5 + 6 = 11$\n- 物种 D：$8 + 7 = 15$\n- 物种 E：$12 + 10 = 22$\n- 物种 F：$0 + 2 = 2$\n- 物种 G：$9 + 8 = 17$\n- 物种 H：$3 + 2 = 5$\n- 物种 I：$10 + 9 = 19$\n- 物种 J：$2 + 0 = 2$\n\n求和得到\n$$\n\\sum_{i} (r_{i} + s_{i}) = 38 + 26 + 11 + 15 + 22 + 2 + 17 + 5 + 19 + 2 = 157.\n$$\n计算 $\\sum_{i} \\min(r_{i}, s_{i})$：\n- 物种 A：$\\min(20,18) = 18$\n- 物种 B：$\\min(15,11) = 11$\n- 物种 C：$\\min(5,6) = 5$\n- 物种 D：$\\min(8,7) = 7$\n- 物种 E：$\\min(12,10) = 10$\n- 物种 F：$\\min(0,2) = 0$\n- 物种 G：$\\min(9,8) = 8$\n- 物种 H：$\\min(3,2) = 2$\n- 物种 I：$\\min(10,9) = 9$\n- 物种 J：$\\min(2,0) = 0$\n\n求和得到\n$$\n\\sum_{i} \\min(r_{i}, s_{i}) = 18 + 11 + 5 + 7 + 10 + 0 + 8 + 2 + 9 + 0 = 70.\n$$\n因此，\n$$\n\\mathrm{BC\\_sim}(\\mathbf{r},\\mathbf{s}) = \\frac{2 \\times 70}{157} = \\frac{140}{157}.\n$$\n为了解释和阈值比较，我们计算其小数值：\n$$\n\\frac{140}{157} \\approx 0.891719745 \\quad \\Rightarrow \\quad \\mathrm{BC\\_sim} \\approx 0.89172.\n$$\n\n步骤 2：基于存在–缺失数据的Jaccard相似性。\n\n分别通过包含 $\\mathbf{r}$ 和 $\\mathbf{s}$ 中丰度严格为正的每个物种来定义存在集合 $A_{R}$ 和 $A_{S}$。\n\n从 $\\mathbf{r}$ 中，存在的物种是 A、B、C、D、E、G、H、I、J（物种 F 的丰度为零），因此\n$$\n|A_{R}| = 9.\n$$\n从 $\\mathbf{s}$ 中，存在的物种是 A、B、C、D、E、F、G、H、I（物种 J 的丰度为零），因此\n$$\n|A_{S}| = 9.\n$$\n交集 $A_{R} \\cap A_{S}$ 包含两个列表中都存在的物种：A、B、C、D、E、G、H、I，所以\n$$\n|A_{R} \\cap A_{S}| = 8.\n$$\n并集的基数为\n$$\n|A_{R} \\cup A_{S}| = |A_{R}| + |A_{S}| - |A_{R} \\cap A_{S}| = 9 + 9 - 8 = 10.\n$$\n因此Jaccard相似性为\n$$\nJ(A_{R}, A_{S}) = \\frac{|A_{R} \\cap A_{S}|}{|A_{R} \\cup A_{S}|} = \\frac{8}{10} = 0.8.\n$$\n\n步骤 3：参考条件判定和保守合规分数。\n\n标准要求两种相似性均至少为 $0.7$。我们得到\n$$\n\\mathrm{BC\\_sim} \\approx 0.89172 \\quad \\text{和} \\quad J = 0.8,\n$$\n所以两者都至少为 $0.7$，该地点满足参考条件标准。\n\n根据定义，保守合规分数是两个相似性值中较小的一个：\n$$\nS_{\\mathrm{cons}} = \\min\\!\\big(\\mathrm{BC\\_sim},\\, J\\big) = \\min\\!\\big(0.89172,\\, 0.8\\big) = 0.8.\n$$\n四舍五入到四位有效数字并以小数形式表示（不带百分号），合规分数为\n$$\n0.8000.\n$$", "answer": "$$\\boxed{0.8000}$$", "id": "2526256"}, {"introduction": "成功的生态修复不仅在于恢复可见的植被结构，更在于重建关键的生态系统功能，例如养分循环。本练习将从监测转向主动管理，运用生态化学计量学原理，精确计算所需的土壤改良剂用量，从而引导退化生态系统的生物地球化学状态回归参考条件 [@problem_id:2526278]。", "problem": "为进行生态恢复，对一片退化的温带草原土壤的表层土壤微生物生物量化学计量进行了测量。测得的微生物生物量碳储量为每公顷 $180$ 千克碳，测得的碳:氮:磷摩尔比为 $80:6:0.8$。通过正式的参考条件评估，确定了一个附近的具有相同土壤类型和植被的参考点，其微生物生物量具有稳定的碳:氮:磷摩尔比，为 $60:7:1$。作为第一步干预措施，恢复计划旨在将微生物生物量化学计量恢复到参考比率，而在此阶段不改变微生物生物量碳储量。假设添加的氮和磷能完全并立即并入微生物生物量库（无气体损失、淋溶或吸附到其他库中），并且改良剂带来的碳输入可忽略不计。\n\n现有两种改良剂产品：一种硝酸铵肥料，其中氮的质量分数为 $0.35$（无量纲）；一种重过磷酸钙，其中磷的质量分数为 $0.20$（无量纲）。使用原子量：碳为 $12$ 克/摩尔，氮为 $14$ 克/摩尔，磷为 $31$ 克/摩尔。\n\n仅使用质量平衡以及摩尔比和质量分数的定义，计算使用这两种产品将微生物生物量化学计量恢复到参考比率所需的改良剂的最小总质量（单位：每公顷）。报告两种产品质量之和。将您的答案四舍五入到四位有效数字，并以千克/公顷为单位表示。", "solution": "该问题经验证，提法得当，有科学依据且内部一致。这是一个生态学中标准的化学计量质量平衡计算。我将开始解答。\n\n目标是计算所需的硝酸铵和重过磷酸钙改良剂的总质量，以将退化土壤的微生物生物量化学计量改变为与参考点相匹配。在此初始恢复步骤中，假定微生物生物量中的碳储量保持不变。\n\n首先，我们确定退化土壤微生物生物量中碳（C）、氮（N）和磷（P）的初始摩尔量。\n给定的初始微生物生物量碳储量为 $C_{\\text{stock, initial}} = 180$ kg C/ha。\n给定的碳原子量为 $M_C = 12$ g/mol。\n为了以摩尔为单位进行计算，我们首先将碳储量转换为克：\n$C_{\\text{stock, initial}} = 180 \\text{ kg} \\times \\frac{1000 \\text{ g}}{1 \\text{ kg}} = 180000$ g C/ha。\n初始碳的摩尔数为：\n$$C_{\\text{moles, initial}} = \\frac{C_{\\text{stock, initial}}}{M_C} = \\frac{180000 \\text{ g/ha}}{12 \\text{ g/mol}} = 15000 \\text{ mol C/ha}$$\n\n给定的初始C:N:P摩尔比为 $80:6:0.8$。利用这个比率，我们可以求出N和P的初始摩尔量。\n$$N_{\\text{moles, initial}} = C_{\\text{moles, initial}} \\times \\frac{6}{80} = 15000 \\text{ mol/ha} \\times 0.075 = 1125 \\text{ mol N/ha}$$\n$$P_{\\text{moles, initial}} = C_{\\text{moles, initial}} \\times \\frac{0.8}{80} = 15000 \\text{ mol/ha} \\times 0.01 = 150 \\text{ mol P/ha}$$\n\n接下来，我们确定达到参考化学计量所需的目标C、N和P摩尔量。题目指出微生物生物量碳储量保持不变。因此，目标碳摩尔数与初始量相同：\n$$C_{\\text{moles, target}} = C_{\\text{moles, initial}} = 15000 \\text{ mol C/ha}$$\n目标参考C:N:P摩尔比为 $60:7:1$。我们使用这个目标比率和固定的碳量来计算目标N和P摩尔量。\n$$N_{\\text{moles, target}} = C_{\\text{moles, target}} \\times \\frac{7}{60} = 15000 \\text{ mol/ha} \\times \\frac{7}{60} = 1750 \\text{ mol N/ha}$$\n$$P_{\\text{moles, target}} = C_{\\text{moles, target}} \\times \\frac{1}{60} = 15000 \\text{ mol/ha} \\times \\frac{1}{60} = 250 \\text{ mol P/ha}$$\n\n现在，我们计算N和P的亏缺量，即必须添加到土壤中的每种元素的量。\n所需氮的摩尔量为：\n$$\\Delta N_{\\text{moles}} = N_{\\text{moles, target}} - N_{\\text{moles, initial}} = 1750 \\text{ mol/ha} - 1125 \\text{ mol/ha} = 625 \\text{ mol N/ha}$$\n所需磷的摩尔量为：\n$$\\Delta P_{\\text{moles}} = P_{\\text{moles, target}} - P_{\\text{moles, initial}} = 250 \\text{ mol/ha} - 150 \\text{ mol/ha} = 100 \\text{ mol P/ha}$$\n\n我们使用氮（$M_N = 14$ g/mol）和磷（$M_P = 31$ g/mol）的原子量将这些摩尔量转换为质量。\n需要添加的氮的质量为：\n$$\\Delta N_{\\text{mass}} = \\Delta N_{\\text{moles}} \\times M_N = 625 \\text{ mol/ha} \\times 14 \\text{ g/mol} = 8750 \\text{ g N/ha} = 8.75 \\text{ kg N/ha}$$\n需要添加的磷的质量为：\n$$\\Delta P_{\\text{mass}} = \\Delta P_{\\text{moles}} \\times M_P = 100 \\text{ mol/ha} \\times 31 \\text{ g/mol} = 3100 \\text{ g P/ha} = 3.1 \\text{ kg P/ha}$$\n\n最后，我们计算所需每种改良剂产品的质量。硝酸铵肥料的氮质量分数为 $w_{N, AN} = 0.35$。重过磷酸钙的磷质量分数为 $w_{P, TSP} = 0.20$。题目假设改良剂分别是N和P的纯来源，碳含量可忽略不计。\n所需硝酸铵（AN）的质量为：\n$$m_{AN} = \\frac{\\Delta N_{\\text{mass}}}{w_{N, AN}} = \\frac{8.75 \\text{ kg N/ha}}{0.35} = 25 \\text{ kg AN/ha}$$\n所需重过磷酸钙（TSP）的质量为：\n$$m_{TSP} = \\frac{\\Delta P_{\\text{mass}}}{w_{P, TSP}} = \\frac{3.1 \\text{ kg P/ha}}{0.20} = 15.5 \\text{ kg TSP/ha}$$\n\n改良剂的总质量是两种产品质量之和。\n$$m_{\\text{total}} = m_{AN} + m_{TSP} = 25 \\text{ kg/ha} + 15.5 \\text{ kg/ha} = 40.5 \\text{ kg/ha}$$\n\n题目要求答案四舍五入到四位有效数字。\n$$40.5 = 40.50$$\n因此，所需的改良剂总质量为 $40.50$ 千克/公顷。", "answer": "$$\n\\boxed{40.50}\n$$", "id": "2526278"}, {"introduction": "现实世界中的修复项目很少只关注单一指标，其成功与否通常需要跨越物种组成、生态系统功能和自然过程等多个维度进行综合评判。本练习介绍了一个多标准决策分析 (MCDA) 框架，它能够将不同的数据流整合为统一的评分，从而对多种修复方案进行排序，这是修复管理者制定透明、客观决策的关键技能 [@problem_id:2526263]。", "problem": "你的任务是设计并实现一个程序，该程序执行基于原则的多标准决策分析（MCDA），通过衡量生态恢复备选方案与参考条件在三个生态支柱（组成、功能和过程）上的接近程度来对其进行排名。该程序必须操作化国际生态恢复学会（SER）的原则，其中参考条件作为目标状态，生态恢复旨在最小化与这些参考状态的偏离。该方法的核心必须在数学上得到良好指定，并由基本定义证明其合理性：与参考状态的距离通过归一化的相异度来量化，总体目标由各标准相异度的凸组合构成。\n\n基本基础：\n- 参考条件由每个标准的目标值向量定义，表示为 $r_{k,j}$，其中 $k$ 是标准（组成、功能、过程）的索引，$j$ 是标准内指标的索引。\n- 指标通过合理范围 $[L_{k,j}, U_{k,j}]$ 进行归一化，使得每个指标的标准化偏离计算如下：$s_{i,k,j} = \\lvert x_{i,k,j} - r_{k,j} \\rvert / (U_{k,j} - L_{k,j})$，其中 $i$ 是备选方案的索引。超出范围的值不被裁剪；当备选方案超出合理范围时，标准化的相异度可能超过 $1$。\n- 每个标准的相异度 $D_{i,k}$ 计算为标准化偏离的欧几里得范数除以 $\\sqrt{n_k}$，其中 $n_k$ 是标准 $k$ 中指标的数量：\n$$\nD_{i,k} = \\frac{\\sqrt{\\sum_{j=1}^{n_k} s_{i,k,j}^2}}{\\sqrt{n_k}}。\n$$\n- 从提供的原始权重 $w$ 中获得一个归一化的非负权重向量 $w' = (w'_C, w'_F, w'_P)$，计算方法为 $w'_k = w_k / \\sum_{\\ell \\in \\{C,F,P\\}} w_\\ell$，假设 $\\sum_\\ell w_\\ell > 0$。备选方案 $i$ 的综合 MCDA 得分为\n$$\nS_i = \\sum_{k \\in \\{C,F,P\\}} w'_k \\, D_{i,k}。\n$$\n较低的 $S_i$ 值表示与参考状态的相似度更高，因此更优。\n\n排名规则：\n- 备选方案按 $S_i$ 的升序排名。\n- 平局使用以下确定性规则解决，容差为 $\\varepsilon = 10^{-12}$：\n  - 如果 $\\lvert S_i - S_{i'} \\rvert \\le \\varepsilon$，优先选择具有较小最大标准相异度 $M_i = \\max_{k} D_{i,k}$ 的备选方案。\n  - 如果在容差范围内仍然平局，优先选择索引较小的备选方案（稳定的索引顺序）。\n\n单位与指标：\n- 组成指标是物种相对丰度的分数（无量纲，以小数表示）。\n- 功能指标包括：净初级生产力，单位为克碳/平方米/年（g C m$^{-2}$ yr$^{-1}$），以及氮保留率的分数（小数）。\n- 过程指标包括：火灾重现间隔，单位为年，以及一个无量纲的泥沙输送指数（小数）。\n\n你的实现必须使用上述定义和规则计算下面每个测试用例的排名。程序不得读取任何输入；所有参数都嵌入在程序中。程序必须输出一行，其中包含所有测试用例的排名列表，每个排名是按从优到劣顺序排列的备选方案索引列表。格式是一个表示列表的列表的单行字符串，不含空格，例如：\"[[a,b,c],[d,e]]\"，其中每个字母代表一个整数索引。\n\n测试套件：\n- 测试用例A（一般情况，平衡权重）：\n  - 原始权重 $w = (0.5, 0.3, 0.2)$。\n  - 组成：三个物种相对丰度的分数，其中 $L_C = (0, 0, 0)$，$U_C = (1, 1, 1)$，$r_C = (0.4, 0.3, 0.3)$。\n  - 功能：两个指标，净初级生产力，其中 $L_F = (200, 0)$，$U_F = (1200, 1)$，$r_F = (800, 0.7)$。第一个指标的单位是克碳/平方米/年，第二个指标是小数分数。\n  - 过程：两个指标，火灾重现间隔和泥沙指数，其中 $L_P = (2, 0)$，$U_P = (20, 1)$，$r_P = (8, 0.5)$。单位分别是年和小数分数。\n  - 备选方案：\n    - 备选方案 $0$：组成 $(0.35, 0.35, 0.30)$，功能 $(850, 0.6)$，过程 $(10, 0.45)$。\n    - 备选方案 $1$：组成 $(0.40, 0.30, 0.30)$，功能 $(900, 0.65)$，过程 $(7, 0.5)$。\n    - 备选方案 $2$：组成 $(0.30, 0.45, 0.25)$，功能 $(600, 0.8)$，过程 $(15, 0.7)$。\n- 测试用例B（权重归一化和零权重标准）：\n  - 原始权重 $w = (2, 1, 0)$，需在内部进行归一化。\n  - 组成、功能、过程使用与测试用例A中相同的 $L$、$U$ 和 $r$。\n  - 备选方案：\n    - 备选方案 $0$：组成 $(0.40, 0.30, 0.30)$，功能 $(1200, 0.2)$，过程 $(5, 0.9)$。\n    - 备选方案 $1$：组成 $(0.40, 0.30, 0.30)$，功能 $(800, 0.7)$，过程 $(9, 0.6)$。\n- 测试用例C（综合得分明确平局，通过最大标准相异度打破平局）：\n  - 原始权重 $w = (0.5, 0.4, 0.1)$。\n  - 对于组成、功能和过程中的每一个，都只有一个指标，其 $L = (0)$，$U = (1)$，$r = (0)$；所有值都是 $0$ 到 $1$ 之间的小数。\n  - 备选方案：\n    - 备选方案 $0$：组成 $(0.2)$，功能 $(0.0)$，过程 $(0.5)$。\n    - 备选方案 $1$：组成 $(0.0)$，功能 $(0.2)$，过程 $(0.7)$。\n    - 备选方案 $2$：组成 $(0.1)$，功能 $(0.1)$，过程 $(0.4)$。\n- 测试用例D（仅过程有权重，存在与参考完全匹配的方案）：\n  - 原始权重 $w = (0, 0, 1)$。\n  - 组成、功能、过程使用与测试用例A中相同的 $L$、$U$ 和 $r$。\n  - 备选方案：\n    - 备选方案 $0$：组成 $(0.50, 0.25, 0.25)$，功能 $(1000, 0.4)$，过程 $(8, 0.5)$。\n    - 备选方案 $1$：组成 $(0.40, 0.25, 0.35)$，功能 $(400, 0.9)$，过程 $(20, 0.0)$。\n    - 备选方案 $2$：组成 $(0.60, 0.20, 0.20)$，功能 $(700, 0.8)$，过程 $(9, 0.45)$。\n\n最终输出格式要求：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的列表，列表内不含空格，每个元素是按A、B、C、D顺序排列的测试用例的排名列表。例如：\"[[1,0,2],[1,0],[2,0,1],[0,2,1]]\"。", "solution": "问题陈述已经过严格审查并被确定为有效。它具有科学依据，即生态恢复的原则；在数学上是适定的，具有明确的定义和公式；并且完全客观。为得到唯一、可验证的解所需的所有数据和条件均已提供。因此，我们可以着手求解。\n\n任务是实现一个多标准决策分析（MCDA）模型，以对生态恢复备选方案进行排序。该排序基于备选方案与一个已定义参考状态的接近程度。这种接近程度被量化为一个加权相异度得分。整个过程遵循一套精确定义的数学规则。\n\n算法设计是这些规则的直接转译。\n\n首先，必须对利益相关者的偏好进行归一化，这些偏好以每个生态标准 $k \\in \\{C, F, P\\}$ （组成、功能、过程）的原始权重 $w_k$ 的形式提供。归一化权重 $w'_k$ 由下式给出：\n$$\nw'_k = \\frac{w_k}{\\sum_{\\ell \\in \\{C,F,P\\}} w_\\ell}\n$$\n这确保了权重之和为一，从而形成一个规范的凸组合。问题陈述中说明，可以假设原始权重之和为正。\n\n其次，对于每个备选方案 $i$ 和每个标准 $k$，我们必须量化其与参考状态的偏离。这是在单个指标的层面上完成的。给定一个备选方案的指标值 $x_{i,k,j}$、其参考值 $r_{k,j}$ 以及一个合理范围 $[L_{k,j}, U_{k,j}]$，标准化偏离 $s_{i,k,j}$ 计算如下：\n$$\ns_{i,k,j} = \\frac{\\lvert x_{i,k,j} - r_{k,j} \\rvert}{U_{k,j} - L_{k.j}}\n$$\n该值表示与目标的偏差分数，已通过指标的合理范围进行归一化。注意，假设范围有效性 $U_{k,j} > L_{k,j}$。\n\n第三，一个标准 $k$ 内所有指标的偏离被聚合成一个单一的、按标准计算的相异度得分 $D_{i,k}$。这被计算为标准化偏离的均方根（RMS）：\n$$\nD_{i,k} = \\frac{\\sqrt{\\sum_{j=1}^{n_k} s_{i,k,j}^2}}{\\sqrt{n_k}}\n$$\n其中 $n_k$ 是标准 $k$ 的指标数量。此公式提供了该标准偏离平均大小的度量。$D_{i,k} = 0$ 的值表示在标准 $k$ 上与参考状态完美匹配。\n\n第四，计算每个备选方案 $i$ 的综合 MCDA 得分 $S_i$，作为各标准相异度的加权和：\n$$\nS_i = \\sum_{k \\in \\{C,F,P\\}} w'_k \\, D_{i,k}\n$$\n较低的 $S_i$ 分数表示与参考状态的总体相异度较小，因此更可取。\n\n最后，根据备选方案的综合得分对其进行排名。排名按 $S_i$ 的升序进行。指定了一个确定性的多级平局打破程序，以确保唯一的排名：\n1.  如果两个备选方案的得分 $S_i$ 和 $S_{i'}$ 没有显著差异，即 $\\lvert S_i - S_{i'} \\rvert \\le \\varepsilon$，其中 $\\varepsilon = 10^{-12}$，则通过比较它们的最大标准相异度 $M_i = \\max_{k} D_{i,k}$ 来解决平局。具有较小 $M_i$ 值的备选方案被优先选择。该规则优先考虑在任何单个标准上避免极端失败的备选方案。\n2.  如果备选方案仍然平局（即，它们的 $S_i$ 得分在 $\\varepsilon$ 范围内，且它们的 $M_i$ 得分实际上相等），则通过备选方案的原始索引来打破平局。索引较低的备选方案排名更高。这确保了排序的稳定性和确定性。\n\n实现将处理一套四个测试用例。对于每个用例，它将为所有备选方案计算 $D_{i,k}$、$S_i$ 和 $M_i$ 值。然后，它将使用一个严格执行指定排名和平局打破逻辑的自定义排序函数。利用 `numpy` 库进行高效、精确的向量化数值计算。每个测试用例的数据被封装并顺序处理，最终的排名被聚合成所需的输出格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom functools import cmp_to_key\n\ndef solve():\n    \"\"\"\n    Solves the ecological restoration MCDA ranking problem for a suite of test cases.\n    \"\"\"\n    \n    test_cases = [\n        # Test Case A\n        {\n            \"w\": np.array([0.5, 0.3, 0.2]),\n            \"criteria\": {\n                \"C\": {\"n\": 3, \"L\": np.array([0, 0, 0]), \"U\": np.array([1, 1, 1]), \"r\": np.array([0.4, 0.3, 0.3])},\n                \"F\": {\"n\": 2, \"L\": np.array([200, 0]), \"U\": np.array([1200, 1]), \"r\": np.array([800, 0.7])},\n                \"P\": {\"n\": 2, \"L\": np.array([2, 0]), \"U\": np.array([20, 1]), \"r\": np.array([8, 0.5])},\n            },\n            \"alternatives\": [\n                {\"C\": np.array([0.35, 0.35, 0.30]), \"F\": np.array([850, 0.6]), \"P\": np.array([10, 0.45])},\n                {\"C\": np.array([0.40, 0.30, 0.30]), \"F\": np.array([900, 0.65]), \"P\": np.array([7, 0.5])},\n                {\"C\": np.array([0.30, 0.45, 0.25]), \"F\": np.array([600, 0.8]), \"P\": np.array([15, 0.7])},\n            ]\n        },\n        # Test Case B\n        {\n            \"w\": np.array([2.0, 1.0, 0.0]),\n            \"criteria\": {\n                \"C\": {\"n\": 3, \"L\": np.array([0, 0, 0]), \"U\": np.array([1, 1, 1]), \"r\": np.array([0.4, 0.3, 0.3])},\n                \"F\": {\"n\": 2, \"L\": np.array([200, 0]), \"U\": np.array([1200, 1]), \"r\": np.array([800, 0.7])},\n                \"P\": {\"n\": 2, \"L\": np.array([2, 0]), \"U\": np.array([20, 1]), \"r\": np.array([8, 0.5])},\n            },\n            \"alternatives\": [\n                {\"C\": np.array([0.40, 0.30, 0.30]), \"F\": np.array([1200, 0.2]), \"P\": np.array([5, 0.9])},\n                {\"C\": np.array([0.40, 0.30, 0.30]), \"F\": np.array([800, 0.7]), \"P\": np.array([9, 0.6])},\n            ]\n        },\n        # Test Case C\n        {\n            \"w\": np.array([0.5, 0.4, 0.1]),\n            \"criteria\": {\n                \"C\": {\"n\": 1, \"L\": np.array([0]), \"U\": np.array([1]), \"r\": np.array([0])},\n                \"F\": {\"n\": 1, \"L\": np.array([0]), \"U\": np.array([1]), \"r\": np.array([0])},\n                \"P\": {\"n\": 1, \"L\": np.array([0]), \"U\": np.array([1]), \"r\": np.array([0])},\n            },\n            \"alternatives\": [\n                {\"C\": np.array([0.2]), \"F\": np.array([0.0]), \"P\": np.array([0.5])},\n                {\"C\": np.array([0.0]), \"F\": np.array([0.2]), \"P\": np.array([0.7])},\n                {\"C\": np.array([0.1]), \"F\": np.array([0.1]), \"P\": np.array([0.4])},\n            ]\n        },\n        # Test Case D\n        {\n            \"w\": np.array([0.0, 0.0, 1.0]),\n            \"criteria\": {\n                \"C\": {\"n\": 3, \"L\": np.array([0, 0, 0]), \"U\": np.array([1, 1, 1]), \"r\": np.array([0.4, 0.3, 0.3])},\n                \"F\": {\"n\": 2, \"L\": np.array([200, 0]), \"U\": np.array([1200, 1]), \"r\": np.array([800, 0.7])},\n                \"P\": {\"n\": 2, \"L\": np.array([2, 0]), \"U\": np.array([20, 1]), \"r\": np.array([8, 0.5])},\n            },\n            \"alternatives\": [\n                {\"C\": np.array([0.50, 0.25, 0.25]), \"F\": np.array([1000, 0.4]), \"P\": np.array([8, 0.5])},\n                {\"C\": np.array([0.40, 0.25, 0.35]), \"F\": np.array([400, 0.9]), \"P\": np.array([20, 0.0])},\n                {\"C\": np.array([0.60, 0.20, 0.20]), \"F\": np.array([700, 0.8]), \"P\": np.array([9, 0.45])},\n            ]\n        }\n    ]\n\n    final_rankings = []\n    criterion_keys = ['C', 'F', 'P']\n    epsilon = 1e-12\n\n    for case in test_cases:\n        # Step 1: Normalize weights\n        raw_weights = case[\"w\"]\n        weight_sum = np.sum(raw_weights)\n        if weight_sum > 0:\n            norm_weights = raw_weights / weight_sum\n        else:\n            # As per problem, assume sum > 0.\n            # Handle this case defensively anyway.\n            norm_weights = np.zeros_like(raw_weights)\n\n        # Step 2: Calculate scores for each alternative\n        alt_scores = []\n        for i, alt_data in enumerate(case[\"alternatives\"]):\n            dissimilarities = []\n            \n            for k in criterion_keys:\n                crit_params = case[\"criteria\"][k]\n                x = alt_data[k]\n                r = crit_params[\"r\"]\n                L = crit_params[\"L\"]\n                U = crit_params[\"U\"]\n                \n                # Standardized departures\n                range_diff = U - L\n                # Avoid division by zero if L=U, though not in test data.\n                s = np.zeros_like(x)\n                non_zero_range = range_diff > 0\n                s[non_zero_range] = np.abs(x[non_zero_range] - r[non_zero_range]) / range_diff[non_zero_range]\n\n                # Per-criterion dissimilarity\n                n_k = crit_params[\"n\"]\n                d_ik = np.sqrt(np.sum(s**2)) / np.sqrt(n_k)\n                dissimilarities.append(d_ik)\n            \n            dissimilarities = np.array(dissimilarities)\n            \n            # Composite MCDA score S_i\n            s_i = np.sum(norm_weights * dissimilarities)\n            \n            # Maximum criterion dissimilarity M_i\n            m_i = np.max(dissimilarities)\n            \n            alt_scores.append({\"S\": s_i, \"M\": m_i, \"idx\": i})\n\n        # Step 3: Rank alternatives using custom comparator\n        def comparator(item1, item2):\n            # Primary sort key: S_i (ascending)\n            s_diff = item1[\"S\"] - item2[\"S\"]\n            if abs(s_diff) > epsilon:\n                return 1 if s_diff > 0 else -1\n\n            # Tie-breaker 1: M_i (ascending)\n            m_diff = item1[\"M\"] - item2[\"M\"]\n            if abs(m_diff) > epsilon: # Use epsilon for float comparison safety\n                return 1 if m_diff > 0 else -1\n            \n            # Tie-breaker 2: index (ascending)\n            idx_diff = item1[\"idx\"] - item2[\"idx\"]\n            return 1 if idx_diff > 0 else -1 if idx_diff  0 else 0\n\n        sorted_alts = sorted(alt_scores, key=cmp_to_key(comparator))\n        ranking = [alt[\"idx\"] for alt in sorted_alts]\n        final_rankings.append(ranking)\n\n    # Format the final output string\n    result_str = \",\".join([str(r) for r in final_rankings]).replace(\" \", \"\")\n    print(f\"[[{result_str}]]\")\n\nsolve()\n```", "id": "2526263"}]}