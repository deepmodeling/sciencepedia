{"hands_on_practices": [{"introduction": "在任何营养级再引入项目中，理解捕食者与其猎物之间的核心互动机制是预测其生态影响的第一步。捕食者的捕食率并非固定不变，而是随着猎物密度的变化而变化，这种关系被称为“功能性响应”。本练习将引导你从最基本的时间分配原则出发，推导出两种经典的捕食模型——Holling II型和III型功能性响应 [@problem_id:2529170]，从而深入理解饱和效应和捕食者学习等现象如何影响生态系统的动态。", "problem": "一个野化项目将一只独居的顶级捕食者重新引入一个有围栏的稀树草原保护区，那里存在着中等体型的有蹄类猎物。管理团队希望预测，在重新引入后的第一年里，如果猎物密度翻倍，捕食者的单位捕食率将如何变化。假设只有一只捕食者和一种目标猎物，混合是均匀的，并且功能性反应是由捕食者觅食的时间分配所产生的。\n\n使用以下基本依据和假设：\n- 捕食者在搜索和处理猎物之间交替，每只猎物的处理时间为常数$h$。\n- 在搜索时，导致成功攻击的相遇发生率与猎物密度$N$成正比，系数为$a$。\n- 对于饱和响应（II型），将相遇系数视为不随$N$变化的常数。\n- 对于低密度加速响应（III型），假设在低密度附近攻击效率随$N$线性增加，因此有效相遇系数与$N$成正比。\n\n仅从这些原理以及“单位摄入率是单位时间内每只捕食者消耗的猎物数量”这一定义出发，推导出II型和III型情况下单位摄入率作为$N$的函数。设初始猎物密度为$N_0 = 1$只/平方公里，相遇系数为$a = 0.1$平方公里/捕食者·天，处理时间为$h = 1$天/猎物。\n\n定义由于猎物密度加倍引起的单位捕食率的倍数变化为 $F \\equiv \\frac{f(2N_0)}{f(N_0)}$。计算II型情况下的$F_{\\mathrm{II}}$和III型情况下的$F_{\\mathrm{III}}$，然后计算单一的汇总量\n$$R \\equiv \\frac{F_{\\mathrm{II}}}{F_{\\mathrm{III}}}.$$\n将$R$的最终答案以一个无量纲数的形式给出。如果存在精确值，请报告精确值；否则，将答案四舍五入到四位有效数字。", "solution": "问题要求基于时间分配模型，推导和比较两种类型的捕食者功能性反应，并计算一个描述当猎物密度翻倍时其行为的特定比率。该问题在科学上基于已建立的生态学理论，并且问题提法很严谨。我们将从第一性原理出发进行推导。\n\n设$T$为可用于觅食的总时间。这个时间被划分为搜索猎物所花费的时间$T_s$和处理猎物所花费的时间$T_h$。因此，时间分配由以下方程给出：\n$$T = T_s + T_h$$\n在此期间消耗的猎物总数$N_e$，根据定义，与单位摄入率$f(N)$相关，关系为$N_e = f(N)T$。总处理时间是消耗的猎物数量与每只猎物的处理时间$h$的乘积：\n$$T_h = N_e h = f(N) T h$$\n将此代入时间分配方程，我们可以将搜索时间表示为：\n$$T = T_s + f(N) T h \\implies T_s = T(1 - f(N)h)$$\n消耗的猎物数量$N_e$也必须等于在搜索时间$T_s$内发生的成功相遇次数。单位搜索时间内的这些相遇率，我们记为攻击率$\\mathcal{A}(N)$，是猎物密度$N$的函数。因此：\n$$N_e = \\mathcal{A}(N) T_s$$\n通过令$N_e$的两个表达式相等，我们得到：\n$$f(N)T = \\mathcal{A}(N) T_s$$\n代入$T_s$的表达式：\n$$f(N)T = \\mathcal{A}(N) T(1 - f(N)h)$$\n假设$T > 0$，我们可以两边除以$T$，得到摄入率$f(N)$和攻击率$\\mathcal{A}(N)$之间的一般关系：\n$$f(N) = \\mathcal{A}(N) (1 - f(N)h) = \\mathcal{A}(N) - \\mathcal{A}(N) f(N) h$$\n求解$f(N)$：\n$$f(N) (1 + \\mathcal{A}(N)h) = \\mathcal{A}(N) \\implies f(N) = \\frac{\\mathcal{A}(N)}{1 + h\\mathcal{A}(N)}$$\n现在我们将此通用公式应用于两个指定的情况。\n\n对于II型功能性反应，问题指出，在搜索期间，成功攻击的发生率与猎物密度$N$成正比，比例常数为$a$。这对应于单位搜索时间的攻击率为：\n$$\\mathcal{A}(N) = aN$$\n将此代入$f(N)$的通用公式，得到Holling II型功能性反应：\n$$f_{\\mathrm{II}}(N) = \\frac{aN}{1 + ahN}$$\n\n对于III型功能性反应，问题指出，有效相遇系数与$N$成正比。在我们的框架中，攻击率是$\\mathcal{A}(N) = a_{\\mathrm{eff}}(N) \\cdot N$，其中$a_{\\mathrm{eff}}(N)$是相遇系数。条件是$a_{\\mathrm{eff}}(N)$与$N$成正比，所以我们写成$a_{\\mathrm{eff}}(N) = cN$，其中$c$是某个比例常数。这导致单位搜索时间的攻击率对$N$具有二次依赖性：\n$$\\mathcal{A}(N) = cN^2$$\n将此代入$f(N)$的通用公式，得到Holling III型功能性反应：\n$$f_{\\mathrm{III}}(N) = \\frac{cN^2}{1 + chN^2}$$\n问题提供了参数$a$的值，但没有提供$c$的值。为了使两个模型具有可比性并使问题定义明确，我们必须建立$c$和$a$之间的关系。一个合乎逻辑的假设是校准III型模型，使得在初始参考猎物密度$N_0$下，有效相遇系数$a_{\\mathrm{eff}}(N_0)$等于II型模型中的常数系数$a$。\n$$a_{\\mathrm{eff}}(N_0) = cN_0 = a \\implies c = \\frac{a}{N_0}$$\n这使得两个模型在初始密度下的攻击效率相等。将$c$的这个表达式代入III型方程，得到：\n$$f_{\\mathrm{III}}(N) = \\frac{(a/N_0)N^2}{1 + (a/N_0)hN^2}$$\n现在我们为两种情况计算倍数变化$F \\equiv \\frac{f(2N_0)}{f(N_0)}$。\n\n对于II型响应：\n$$F_{\\mathrm{II}} = \\frac{f_{\\mathrm{II}}(2N_0)}{f_{\\mathrm{II}}(N_0)} = \\frac{\\frac{a(2N_0)}{1 + ah(2N_0)}} {\\frac{aN_0}{1 + ahN_0}} = \\frac{2aN_0}{1 + 2ahN_0} \\cdot \\frac{1 + ahN_0}{aN_0} = 2 \\frac{1 + ahN_0}{1 + 2ahN_0}$$\n\n对于III型响应：\n$$F_{\\mathrm{III}} = \\frac{f_{\\mathrm{III}}(2N_0)}{f_{\\mathrm{III}}(N_0)} = \\frac{\\frac{c(2N_0)^2}{1 + ch(2N_0)^2}} {\\frac{c(N_0)^2}{1 + ch(N_0)^2}} = \\frac{4cN_0^2}{1 + 4chN_0^2} \\cdot \\frac{1 + chN_0^2}{cN_0^2} = 4 \\frac{1 + chN_0^2}{1 + 4chN_0^2}$$\n现在，我们将$c=a/N_0$代入$F_{\\mathrm{III}}$的表达式中：\n$$F_{\\mathrm{III}} = 4 \\frac{1 + (a/N_0)hN_0^2}{1 + 4(a/N_0)hN_0^2} = 4 \\frac{1 + ahN_0}{1 + 4ahN_0}$$\n\n最后，我们计算比率$R \\equiv \\frac{F_{\\mathrm{II}}}{F_{\\mathrm{III}}}$：\n$$R = \\frac{2 \\frac{1 + ahN_0}{1 + 2ahN_0}}{4 \\frac{1 + ahN_0}{1 + 4ahN_0}} = \\frac{2}{4} \\cdot \\frac{1 + ahN_0}{1 + 2ahN_0} \\cdot \\frac{1 + 4ahN_0}{1 + ahN_0}$$\n项 $(1 + ahN_0)$被消掉了：\n$$R = \\frac{1}{2} \\cdot \\frac{1 + 4ahN_0}{1 + 2ahN_0}$$\n这是所需比率的一般符号表达式。现在我们代入给定的数值：$a = 0.1$，$h = 1$，$N_0 = 1$。单位是一致的，使得乘积$ahN_0$是无量纲的：\n$$ahN_0 = (0.1 \\text{ km}^2/\\text{day}) \\cdot (1 \\text{ day}/\\text{prey}) \\cdot (1 \\text{ prey}/\\text{km}^2) = 0.1$$\n将此值代入$R$的表达式中：\n$$R = \\frac{1}{2} \\cdot \\frac{1 + 4(0.1)}{1 + 2(0.1)} = \\frac{1}{2} \\cdot \\frac{1 + 0.4}{1 + 0.2} = \\frac{1}{2} \\cdot \\frac{1.4}{1.2} = \\frac{1}{2} \\cdot \\frac{14}{12} = \\frac{1}{2} \\cdot \\frac{7}{6} = \\frac{7}{12}$$\n结果是一个精确的有理数。", "answer": "$$\\boxed{\\frac{7}{12}}$$", "id": "2529170"}, {"introduction": "捕食者的回归不仅仅是减少了食草动物的数量，更深刻地改变了整个生态系统的结构与功能，这种现象被称为营养级联。现代生态学研究揭示，这种影响包含两个截然不同的途径：由于捕食导致的食草动物数量下降（密度介导效应），以及幸存者因恐惧而改变觅食行为（行为介导效应或“恐惧生态学”）。本练习 [@problem_id:2529126] 提供了一个量化框架，让你能够利用模拟的野外数据，将植被恢复的总效果分解为这两个部分，这对于评估“恐惧生态学”在野化项目中的实际作用至关重要。", "problem": "一个再野化计划将一种顶级捕食者重新引入一个温带生态系统，改变了食草动物的行为和密度。给定再引入前后的食草动物密度、警戒时间比例以及主动啃食时的单位个体咬食速率的野外估算值。假设以下基本原则：\n\n- 时间分配恒等式：可用于进食的时间比例是警戒时间的补集，因此有效单位个体啃食速率是主动咬食速率乘以非警戒时间比例。\n- 食草质量作用：总啃食压力等于食草动物密度乘以单位个体啃食速率。\n- 短期植被响应：在一个固定的短期监测区间内，植被恢复与总啃食压力的减少量成正比，其比例常数在再引入前后条件下相同，因此在计算比率时会消去。\n\n使用这些原则来构建一个植被恢复的分解模型，将其分解为一个密度介导的组分（仅由食草动物密度的变化引起）和一个行为介导的组分（仅由警戒和主动咬食速率的变化引起，同时保持再引入后的密度不变）。通过计算行为介导组分与总恢复量的比率，估算归因于行为介导效应的植被恢复比例。如果总恢复量为零或负数，则该比例报告为$0$。\n\n设 $N_{\\text{pre}}$ 和 $N_{\\text{post}}$ 分别表示再引入前后的食草动物密度（单位：$\\text{individuals}\\,\\text{ha}^{-1}$）。设 $v_{\\text{pre}}$ 和 $v_{\\text{post}}$ 分别表示再引入前后的警戒时间比例（无单位，十进制小数）。设 $b_{\\text{pre}}$ 和 $b_{\\text{post}}$ 分别表示再引入前后主动啃食时的单位个体咬食速率（单位：$\\text{g}\\,\\text{h}^{-1}\\,\\text{ind}^{-1}$）。那么，有效单位个体啃食速率为 $I_{\\text{pre}} = (1 - v_{\\text{pre}})\\,b_{\\text{pre}}$ 和 $I_{\\text{post}} = (1 - v_{\\text{post}})\\,b_{\\text{post}}$，总啃食压力为 $B_{\\text{pre}} = N_{\\text{pre}} I_{\\text{pre}}$ 和 $B_{\\text{post}} = N_{\\text{post}} I_{\\text{post}}$。仅考虑密度的反事实啃食压力，即行为保持再引入前的值而密度取再引入后的值，为 $B_{\\text{dens}} = N_{\\text{post}} I_{\\text{pre}}$。使用这些量来计算所要求的比例。\n\n实现一个程序，对下面的每个测试案例，计算行为介导的比例，结果为四舍五入到小数点后六位的十进制数。单位必须严格按照上述规定使用。\n\n测试集（每个案例为 $(N_{\\text{pre}}, v_{\\text{pre}}, b_{\\text{pre}}, N_{\\text{post}}, v_{\\text{post}}, b_{\\text{post}})$）：\n- 案例 A：$(30, 0.1, 120, 20, 0.25, 110)$，其中 $30$ 和 $20$ 的单位是 $\\text{individuals}\\,\\text{ha}^{-1}$，$0.1$ 和 $0.25$ 是比例，而 $120$ 和 $110$ 的单位是 $\\text{g}\\,\\text{h}^{-1}\\,\\text{ind}^{-1}$。\n- 案例 B：$(40, 0.2, 100, 25, 0.2, 100)$。\n- 案例 C：$(30, 0.05, 130, 30, 0.3, 120)$。\n- 案例 D：$(20, 0.1, 100, 25, 0.05, 95)$。\n- 案例 E：$(50, 0.1, 150, 40, 0.3, 170)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[0.123456,0.000000,1.000000]”），结果按案例 A 到 E 的顺序排列。所有输出必须是四舍五入到小数点后六位的十进制数，不带单位。", "solution": "所述问题具有科学依据，提法恰当且客观。它基于已确立的生态学原理，即营养级联，特别是捕食者对植物群落的密度介导和行为介导的间接效应之间的区别。所有变量、常数和关系都得到了明确定义，从而能够得出一个唯一且有意义的解。该问题是有效的。\n\n我们的任务是在捕食者再引入后，将食草行为的总变化分解为由食草动物密度变化驱动的组分和由食草动物行为变化驱动的组分。归因于行为的总效应比例是所求的量。\n\n让我们定义状态变量：\n- $N_{\\text{pre}}$ 和 $N_{\\text{post}}$：再引入前后的食草动物密度 [个体数 $\\cdot$ 公顷$^{-1}$]。\n- $v_{\\text{pre}}$ 和 $v_{\\text{post}}$：再引入前后的警戒时间比例 [无单位]。\n- $b_{\\text{pre}}$ 和 $b_{\\text{post}}$：再引入前后主动啃食期间的单位个体咬食速率 [克 $\\cdot$ 小时$^{-1}$ $\\cdot$ 个体$^{-1}$]。\n\n根据所提供的基本原则，我们将系统动态形式化。可用于进食的时间比例为 $(1 - v)$。因此，有效单位个体啃食速率 $I$ 是主动咬食速率与可用于啃食时间的乘积。\n$$I = (1 - v) \\cdot b$$\n再引入前后时期的速率为：\n$$I_{\\text{pre}} = (1 - v_{\\text{pre}}) \\cdot b_{\\text{pre}}$$\n$$I_{\\text{post}} = (1 - v_{\\text{post}}) \\cdot b_{\\text{post}}$$\n\n总啃食压力 $B$ 代表单位面积、单位时间内消耗的植被总生物量，由质量作用定律给出：食草动物密度与有效单位个体啃食速率的乘积。\n$$B = N \\cdot I$$\n因此，再引入前后的总啃食压力为：\n$$B_{\\text{pre}} = N_{\\text{pre}} \\cdot I_{\\text{pre}}$$\n$$B_{\\text{post}} = N_{\\text{post}} \\cdot I_{\\text{post}}$$\n\n题目说明植被恢复与总啃食压力的减少量成正比。这个总减少量，我们记为 $\\Delta B_{\\text{total}}$，是：\n$$\\Delta B_{\\text{total}} = B_{\\text{pre}} - B_{\\text{post}}$$\n\n为了分解这一总效应，我们引入一个反事实情景。我们定义一个假设的啃食压力 $B_{\\text{dens}}$，它表示如果食草动物密度变为再引入后的水平（$N_{\\text{post}}$），而行为保持在再引入前的状态（以 $I_{\\text{pre}}$ 为特征）时将会出现的啃食压力。\n$$B_{\\text{dens}} = N_{\\text{post}} \\cdot I_{\\text{pre}}$$\n\n利用这个反事实，我们通过加上和减去 $B_{\\text{dens}}$ 来划分啃食压力的总变化：\n$$\\Delta B_{\\text{total}} = (B_{\\text{pre}} - B_{\\text{dens}}) + (B_{\\text{dens}} - B_{\\text{post}})$$\n\n第一项 $\\Delta B_{\\text{density}} = B_{\\text{pre}} - B_{\\text{dens}}$ 代表变化的密度介导组分。它在保持行为不变的情况下，单独分离出食草动物数量变化的影响。\n$$\\Delta B_{\\text{density}} = N_{\\text{pre}}I_{\\text{pre}} - N_{\\text{post}}I_{\\text{pre}} = (N_{\\text{pre}} - N_{\\text{post}})I_{\\text{pre}}$$\n\n第二项 $\\Delta B_{\\text{behavior}} = B_{\\text{dens}} - B_{\\text{post}}$ 代表行为介导的组分。它在保持密度为其最终的再引入后水平不变的情况下，单独分离出食草动物行为（警戒和咬食速率）变化的影响。\n$$\\Delta B_{\\text{behavior}} = N_{\\text{post}}I_{\\text{pre}} - N_{\\text{post}}I_{\\text{post}} = N_{\\text{post}}(I_{\\text{pre}} - I_{\\text{post}})$$\n\n归因于行为介导效应的植被恢复比例 $P$ 是行为介导的啃食减少量与总减少量的比值。\n$$P = \\frac{\\Delta B_{\\text{behavior}}}{\\Delta B_{\\text{total}}} = \\frac{B_{\\text{dens}} - B_{\\text{post}}}{B_{\\text{pre}} - B_{\\text{post}}}$$\n代入完整表达式：\n$$P = \\frac{N_{\\text{post}}((1 - v_{\\text{pre}})b_{\\text{pre}} - (1 - v_{\\text{post}})b_{\\text{post}})}{N_{\\text{pre}}(1 - v_{\\text{pre}})b_{\\text{pre}} - N_{\\text{post}}(1 - v_{\\text{post}})b_{\\text{post}}}$$\n\n一个关键条件是，如果总恢复量为零或负数（即 $\\Delta B_{\\text{total}} \\le 0$），则该比例报告为 $0$。这在生态学上是合理的，因为如果啃食压力没有下降，就没有任何“恢复”可以归因于任何原因。\n\n让我们演示案例 A 的计算过程：$(N_{\\text{pre}}=30, v_{\\text{pre}}=0.1, b_{\\text{pre}}=120, N_{\\text{post}}=20, v_{\\text{post}}=0.25, b_{\\text{post}}=110)$。\n1.  计算单位个体速率：\n    $I_{\\text{pre}} = (1 - 0.1) \\cdot 120 = 0.9 \\cdot 120 = 108$\n    $I_{\\text{post}} = (1 - 0.25) \\cdot 110 = 0.75 \\cdot 110 = 82.5$\n2.  计算总啃食压力和反事实啃食压力：\n    $B_{\\text{pre}} = 30 \\cdot 108 = 3240$\n    $B_{\\text{post}} = 20 \\cdot 82.5 = 1650$\n    $B_{\\text{dens}} = 20 \\cdot 108 = 2160$\n3.  计算总减少量和行为减少量：\n    $\\Delta B_{\\text{total}} = 3240 - 1650 = 1590$。由于 $1590 > 0$，我们继续计算。\n    $\\Delta B_{\\text{behavior}} = 2160 - 1650 = 510$\n4.  计算比例：\n    $P = \\frac{510}{1590} = \\frac{17}{53} \\approx 0.3207547...$\n    四舍五入到小数点后六位，结果是 $0.320755$。\n\n对所有测试案例应用相同的程序以生成最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the rewilding decomposition problem for a suite of test cases.\n    \"\"\"\n    # Test suite: each case is (N_pre, v_pre, b_pre, N_post, v_post, b_post)\n    test_cases = [\n        # Case A: (N_pre, v_pre, b_pre, N_post, v_post, b_post)\n        (30, 0.1, 120, 20, 0.25, 110),\n        # Case B\n        (40, 0.2, 100, 25, 0.2, 100),\n        # Case C\n        (30, 0.05, 130, 30, 0.3, 120),\n        # Case D\n        (20, 0.1, 100, 25, 0.05, 95),\n        # Case E\n        (50, 0.1, 150, 40, 0.3, 170),\n    ]\n\n    results = []\n    for case in test_cases:\n        n_pre, v_pre, b_pre, n_post, v_post, b_post = case\n\n        # Calculate effective per-capita browsing rates\n        # I = (1 - v) * b\n        i_pre = (1.0 - v_pre) * b_pre\n        i_post = (1.0 - v_post) * b_post\n\n        # Calculate total browsing pressures\n        # B = N * I\n        b_pre_total = n_pre * i_pre\n        b_post_total = n_post * i_post\n\n        # Calculate total reduction in browsing pressure (proportional to total recovery)\n        # delta_B_total = B_pre - B_post\n        delta_b_total = b_pre_total - b_post_total\n\n        # If total recovery is zero or negative, proportion is 0\n        if delta_b_total = 0:\n            proportion = 0.0\n        else:\n            # Calculate the density-only counterfactual browsing pressure\n            # B_dens = N_post * I_pre\n            b_dens_counterfactual = n_post * i_pre\n\n            # Calculate the behaviorally mediated reduction in browsing pressure\n            # delta_B_behavior = B_dens - B_post\n            delta_b_behavior = b_dens_counterfactual - b_post_total\n\n            # Calculate the proportion of recovery attributable to behavior\n            # P = delta_B_behavior / delta_B_total\n            proportion = delta_b_behavior / delta_b_total\n        \n        # Format the result to six decimal places.\n        results.append(f\"{proportion:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "2529126"}, {"introduction": "成功的野化不仅需要深刻的生态学理解，还需要严谨的战略规划和资源配置。在现实世界中，保护机构往往面临预算有限、多个候选地点以及再引入成功率不确定的复杂局面。本练习 [@problem_id:2529192] 将你置于决策者的位置，要求你应用机会约束规划方法来解决一个选址优化问题。你将学习如何在一个投资组合中平衡成本、预期生态效益和成功概率，以在满足可靠性目标的同时，最大化整体的生态恢复成果。", "problem": "一个保护机构正计划进行一系列顶级捕食者再引入，以恢复多个候选地点的营养级联。每个候选地点都有固定的实施成本、在顶级捕食者成功建立后可实现的估计生态效益，以及释放后成功建立的独立概率。该机构有固定的预算。该机构希望选择一个地点子集，以最大化预期的实现生态效益，同时确保至少有指定数量的地点成功建立的概率达到一个可靠性阈值。假设不同地点成功建立的结果是相互独立的。使用标准的伯努利试验概率论和期望的线性性质作为基本基础，不援引任何未经检验或推测性的生态机制。\n\n设存在 $N$ 个候选地点，索引为 $i \\in \\{0,1,\\dots,N-1\\}$。对于每个地点 $i$：\n- 成本为 $c_i$ 百万美元（USD）。所有成本和预算都必须以“百万美元”为单位处理。\n- 如果成功建立，效益为 $b_i$，单位为任意但固定的“营养功能单位”。\n- 成功建立的概率为 $p_i \\in [0,1]$。\n- 令 $X_i \\in \\{0,1\\}$ 表示地点 $i$ 是否被选中，令 $Y_i \\in \\{0,1\\}$ 表示在地点 $i$ 被选中的条件下，指示成功建立的伯努利随机变量，其中 $\\mathbb{P}(Y_i=1)=p_i$ 且各地点之间相互独立。\n\n将选定地点中成功建立的总数定义为 $K=\\sum_{i=0}^{N-1} X_i Y_i$。机会约束要求 $\\mathbb{P}(K \\ge r) \\ge \\alpha$，其中 $r$ 是成功建立最小数量的非负整数目标，$\\alpha \\in [0,1]$ 是以小数表示的可靠性阈值。预算约束要求 $\\sum_{i=0}^{N-1} c_i X_i \\le B$，其中 $B$ 是以百万美元为单位的总预算。目标是最大化预期实现效益 $\\mathbb{E}\\left[\\sum_{i=0}^{N-1} b_i X_i Y_i\\right]$。\n\n您的程序必须为下面的每个测试用例计算一个选定地点的最优索引集 $S=\\{i : X_i=1\\}$，该集合需满足预算约束和机会约束，并能最大化预期实现效益。如果存在多个最优解，选择总成本最小的解来打破平局；如果仍然平局，选择字典序最小的排序索引列表 $S$。\n\n如果不存在可行子集，则输出空列表作为选定索引，目标值为 $0.0$，实现的机会约束尾部概率为 $0.0$。\n\n测试套件：\n- 案例 A：\n  - $N=6$\n  - $B=10.0$ 百万美元\n  - $c=(3.0,4.0,2.0,5.0,3.0,1.0)$ 百万美元\n  - $b=(10.0,12.0,7.0,15.0,9.0,4.0)$ 营养功能单位\n  - $p=(0.7,0.5,0.8,0.4,0.6,0.3)$\n  - $r=2$\n  - $\\alpha=0.8$\n- 案例 B：\n  - $N=5$\n  - $B=8.0$ 百万美元\n  - $c=(4.0,4.0,3.0,2.0,1.0)$ 百万美元\n  - $b=(14.0,13.0,9.0,6.0,3.0)$ 营养功能单位\n  - $p=(0.9,0.6,0.5,0.4,0.2)$\n  - $r=3$\n  - $\\alpha=0.95$\n- 案例 C：\n  - $N=4$\n  - $B=5.0$ 百万美元\n  - $c=(2.0,2.0,2.0,2.0)$ 百万美元\n  - $b=(5.0,6.0,5.0,1.0)$ 营养功能单位\n  - $p=(0.0,0.9,0.9,1.0)$\n  - $r=2$\n  - $\\alpha=0.8$\n- 案例 D：\n  - $N=3$\n  - $B=3.0$ 百万美元\n  - $c=(1.0,1.0,1.0)$ 百万美元\n  - $b=(2.0,2.0,2.0)$ 营养功能单位\n  - $p=(0.2,0.2,0.2)$\n  - $r=1$\n  - $\\alpha=0.5$\n\n要求：\n- 使用 $Y_i$ 的独立性和伯努利试验的定义作为基础概率模型。期望值必须使用期望的线性性质计算。\n- 机会约束必须在独立性假设下精确评估。对于任何选定的子集 $S$，计算 $K$ 的分布（一个泊松二项分布），然后通过伯努利概率质量函数的精确卷积来评估尾部概率 $\\mathbb{P}(K \\ge r)$。\n- 每个测试用例的输出必须是一个形式为 $[\\text{indices}, \\text{objective}, \\text{achieved}]$ 的列表，其中 $\\text{indices}$ 是一个按升序排列的、使用零基索引的选定地点索引列表，$\\text{objective}$ 是最大预期实现效益，以浮点数表示并四舍五入到六位小数，而 $\\text{achieved}$ 是实现的尾部概率 $\\mathbb{P}(K \\ge r)$，以浮点数表示并四舍五入到六位小数。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个逗号分隔的列表，并用方括号括起来，例如：$[[\\dots],[\\dots],[\\dots],[\\dots]]$。\n\n注：不涉及角度。百分比必须表示为小数，例如 $\\alpha=0.8$，而不是使用百分号。所有货币量必须以百万美元为单位处理，但输出仅报告指定的索引以及无量纲的目标值和概率值。", "solution": "所呈现的问题是一个约束优化问题，具体来说是背包问题的一个变体，带有一个额外的概率性或机会性约束。任务是选择一个项目地点子集，在满足预算和可靠性约束的前提下，最大化总预期效益。该问题定义明确，并在概率论和优化方面有坚实的科学基础。\n\n首先，让我们将问题的组成部分形式化。\n令 $S$ 为选定地点的索引集合，使得决策变量 $X_i=1$ 当 $i \\in S$ 时成立，否则 $X_i=0$。\n\n目标是最大化总预期实现生态效益。根据期望的线性性质，目标函数为：\n$$ \\mathbb{E}\\left[\\sum_{i=0}^{N-1} b_i X_i Y_i\\right] = \\sum_{i=0}^{N-1} b_i X_i \\mathbb{E}[Y_i] = \\sum_{i \\in S} b_i p_i $$\n其中 $\\mathbb{E}[Y_i] = p_i$，因为 $Y_i$ 是一个成功参数为 $p_i$ 的伯努利随机变量。令 $E_S = \\sum_{i \\in S} b_i p_i$ 表示给定集合 $S$ 的这个预期效益。\n\n选择受两个主要约束的限制：\n1.  预算约束：选定地点的总成本不得超过预算 $B$。\n    $$ C_S = \\sum_{i \\in S} c_i \\le B $$\n2.  机会约束：成功建立的数量 $K_S = \\sum_{i \\in S} Y_i$ 至少为 $r$ 的概率必须达到可靠性阈值 $\\alpha$。\n    $$ \\mathbb{P}(K_S \\ge r) \\ge \\alpha $$\n\n问题的核心在于机会约束的评估。随机变量 $K_S$ 是 $|S|$ 个独立但不必同分布的伯努利随机变量之和。这种和的分布被称为泊松二项分布。为了计算概率 $\\mathbb{P}(K_S \\ge r)$，我们首先需要 $K_S$ 的概率质量函数（PMF），我们将其表示为 $P_S(k) = \\mathbb{P}(K_S = k)$。这个 PMF 可以使用动态规划方法高效计算。\n令集合 $S$ 中地点的成功概率为 $\\{p_i\\}_{i \\in S}$。我们可以迭代地构建这个和的 PMF。\n从零个变量之和的 PMF 开始：$P_0(0) = 1$。然后，对于 $S$ 中的每个成功概率为 $p_i$ 的地点 $i$，我们更新 PMF。如果 $P_{m-1}$ 是 $m-1$ 个地点之和的 PMF，那么 $m$ 个地点之和的 PMF $P_m$ 由以下递推关系给出：\n$$ P_m(k) = P_{m-1}(k) \\cdot (1-p_i) + P_{m-1}(k-1) \\cdot p_i $$\n并理解当 $k0$ 或 $k \\ge m$ 时 $P_{m-1}(k)=0$。这等价于生成函数的乘法，具体来说是 $\\prod_{i \\in S}((1-p_i)+p_i z)$。所得 $z$ 的多项式系数给出了 PMF $P_S(k)$。\n在计算出集合 $S$ 的完整 PMF 后，所需的尾部概率计算如下：\n$$ \\mathbb{P}(K_S \\ge r) = \\sum_{k=r}^{|S|} P_S(k) $$\n\n鉴于所有测试用例中的地点数量 $N$ 都很小（最多为 $N=6$），对所有 $2^N$ 个可能的子集 $S$ 进行穷举搜索在计算上是可行的。算法如下：\n1. 初始化一个最优解记录，包括一个空集、目标值 $0.0$、实现的概率 $0.0$ 和一个无限大的成本，以处理初始状态和打破平局。\n2. 遍历 $N$ 个地点的所有 $2^N$ 个子集。这可以通过遍历从 $0$ 到 $N$ 的所有可能的子集大小，并为每个大小生成所有地点组合来完成。对于每个子集 $S$：\n    a. 计算总成本 $C_S = \\sum_{i \\in S} c_i$。如果 $C_S > B$，则该子集不可行，予以丢弃。\n    b. 如果满足预算约束，使用所述的动态规划方法计算 $S$ 中地点的成功次数的 PMF。然后，计算尾部概率 $P_{achieved} = \\mathbb{P}(K_S \\ge r)$。如果 $P_{achieved}  \\alpha$，则该子集不可行，予以丢弃。\n    c. 如果子集是可行的（满足两个约束），计算目标函数值 $E_S = \\sum_{i \\in S} b_i p_i$。\n    d. 将此可行解 $(S, E_S, C_S, P_{achieved})$ 与当前最优解进行比较。如果新解的目标值 $E_S$更高，则其严格更优。如果目标值持平（在由于浮点运算引起的微小容差 $\\epsilon$ 内），则优先选择成本 $C_S$ 较低的解。如果成本也持平，则选择字典序较小的排序索引列表的解。\n3. 如果在整个搜索过程中没有找到可行子集，则按照问题规范返回初始的空集解。\n4. 每个测试用例的最终结果包括最优子集的索引列表、其对应的目标值和实现的尾部概率，数值格式化为六位小数。", "answer": "```python\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Solves the apex predator reintroduction optimization problem for a suite of test cases.\n    \"\"\"\n    \n    test_cases = [\n        # Case A\n        {\n            \"N\": 6, \"B\": 10.0, \"r\": 2, \"alpha\": 0.8,\n            \"c\": np.array([3.0, 4.0, 2.0, 5.0, 3.0, 1.0]),\n            \"b\": np.array([10.0, 12.0, 7.0, 15.0, 9.0, 4.0]),\n            \"p\": np.array([0.7, 0.5, 0.8, 0.4, 0.6, 0.3])\n        },\n        # Case B\n        {\n            \"N\": 5, \"B\": 8.0, \"r\": 3, \"alpha\": 0.95,\n            \"c\": np.array([4.0, 4.0, 3.0, 2.0, 1.0]),\n            \"b\": np.array([14.0, 13.0, 9.0, 6.0, 3.0]),\n            \"p\": np.array([0.9, 0.6, 0.5, 0.4, 0.2])\n        },\n        # Case C\n        {\n            \"N\": 4, \"B\": 5.0, \"r\": 2, \"alpha\": 0.8,\n            \"c\": np.array([2.0, 2.0, 2.0, 2.0]),\n            \"b\": np.array([5.0, 6.0, 5.0, 1.0]),\n            \"p\": np.array([0.0, 0.9, 0.9, 1.0])\n        },\n        # Case D\n        {\n            \"N\": 3, \"B\": 3.0, \"r\": 1, \"alpha\": 0.5,\n            \"c\": np.array([1.0, 1.0, 1.0]),\n            \"b\": np.array([2.0, 2.0, 2.0]),\n            \"p\": np.array([0.2, 0.2, 0.2])\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        N, B, r, alpha = case[\"N\"], case[\"B\"], case[\"r\"], case[\"alpha\"]\n        c, b, p = case[\"c\"], case[\"b\"], case[\"p\"]\n\n        best_indices = []\n        best_objective = 0.0\n        best_achieved_prob = 0.0\n        best_cost = float('inf')\n        \n        # Epsilon for floating point comparisons\n        epsilon = 1e-9\n\n        all_indices = list(range(N))\n        \n        # Iterate over all possible subsets of sites\n        for k in range(N + 1):\n            for indices_tuple in itertools.combinations(all_indices, k):\n                indices = list(indices_tuple)\n                \n                # 1. Budget Constraint\n                current_cost = np.sum(c[indices])\n                if current_cost > B:\n                    continue\n                \n                # 2. Chance Constraint\n                subset_probs = p[indices]\n                \n                # Calculate PMF of the Poisson Binomial distribution\n                if not indices:\n                    pmf = np.array([1.0])\n                else:\n                    pmf = np.array([1.0])\n                    for prob in subset_probs:\n                        new_pmf = np.zeros(len(pmf) + 1)\n                        new_pmf[:-1] += pmf * (1 - prob)\n                        new_pmf[1:] += pmf * prob\n                        pmf = new_pmf\n                \n                # Calculate achieved probability P(K >= r)\n                if r >= len(pmf):\n                    achieved_prob = 0.0\n                else:\n                    achieved_prob = np.sum(pmf[r:])\n                \n                if achieved_prob  alpha:\n                    continue\n\n                # 3. Objective Function\n                current_objective = np.sum(b[indices] * p[indices])\n                \n                #\n                # Compare with best solution found so far\n                #\n                is_better = False\n                if current_objective - best_objective > epsilon:\n                    is_better = True\n                elif abs(current_objective - best_objective) = epsilon:\n                    if best_cost - current_cost > epsilon:\n                        is_better = True\n                    elif abs(current_cost - best_cost) = epsilon:\n                        if indices  best_indices:\n                            is_better = True\n                \n                if is_better:\n                    best_indices = indices\n                    best_objective = current_objective\n                    best_achieved_prob = achieved_prob\n                    best_cost = current_cost\n        \n        # Handle the case where no feasible solution is found\n        if not best_indices and best_objective == 0.0:\n             # Initially best_achieved_prob is 0.0, this handles the specified output.\n             pass\n\n        # Format output for this test case\n        formatted_result = [\n            best_indices,\n            f\"{best_objective:.6f}\",\n            f\"{best_achieved_prob:.6f}\"\n        ]\n        results.append(str(formatted_result).replace(\"'\", \"\"))\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2529192"}]}