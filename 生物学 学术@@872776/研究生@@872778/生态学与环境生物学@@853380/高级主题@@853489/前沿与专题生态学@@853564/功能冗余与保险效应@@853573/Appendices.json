{"hands_on_practices": [{"introduction": "本练习旨在通过直接计算来量化保险效应。通过对比两种不同的物种协方差情景——同步波动（正相关）和补偿性波动（负相关），我们可以清晰地揭示物种间的异步性如何提升生态系统功能的稳定性。这个练习将帮助您建立对群落稳定性如何从物种间的相互作用动态中涌现出来的具体理解 [@problem_id:2493347]。", "problem": "一个由 $S$ 个功能冗余物种组成的群落，其对单一的生态系统总功能 $F(t)$（例如，总固氮速率）做出加性贡献，因此 $F(t)=\\sum_{i=1}^{S} X_i(t)$，其中 $X_i(t)$ 是物种 $i$ 的瞬时贡献。假设每个物种具有相同的平稳均值 $\\mathbb{E}[X_i]=\\mu$ 和方差 $\\mathrm{Var}(X_i)=\\sigma^{2}$，并且对于所有 $i\\neq j$，其联合波动是弱平稳的，具有恒定的两两相关性 $\\rho$。这体现了功能冗余（相等的边际贡献），同时允许通过异步性产生保险效应的不同协方差结构。\n\n采用以下两种协方差结构情景，它们共享相同的 $\\mu$ 和 $\\sigma^{2}$，但在 $\\rho$ 上有所不同：\n- 情景A（同步波动）：$\\rho_{A}=0.6$。\n- 情景B（补偿性波动）：$\\rho_{B}=-0.2$。\n\n使用以下参数：$S=5$, $\\mu=4$, and $\\sigma^{2}=1$。将总功能 $F$ 的恒定性定义为 $I=1/\\mathrm{CV}^{2}(F)$，其中变异系数 (CV) 为 $\\mathrm{CV}(F)=\\sqrt{\\mathrm{Var}(F)}/\\mathbb{E}[F]$。分别计算情景 A 和 B 的 $I_{A}$ 和 $I_{B}$，然后将保险效应量化为 $\\Delta I = I_{B}-I_{A}$。以纯数（无单位）形式报告 $\\Delta I$，并四舍五入到四位有效数字。", "solution": "该问题要求计算保险效应，其定义为两种物种协方差结构情景之间恒定性的差异 $\\Delta I = I_B - I_A$。问题的核心在于计算生态系统总功能 $F(t)$ 的均值和方差。\n\n首先，我们验证问题陈述的有效性。\n已知条件如下：\n- 物种数量：$S=5$\n- 总功能：$F(t) = \\sum_{i=1}^{S} X_i(t)$\n- 每个物种的平均贡献：$\\mathbb{E}[X_i] = \\mu = 4$\n- 每个物种贡献的方差：$\\mathrm{Var}(X_i) = \\sigma^2 = 1$\n- 对于 $i \\neq j$ 的两两相关性：$\\rho$\n- 情景A相关性：$\\rho_A = 0.6$\n- 情景B相关性：$\\rho_B = -0.2$\n- 恒定性的定义：$I = 1/\\mathrm{CV}^{2}(F)$\n- 变异系数的定义：$\\mathrm{CV}(F) = \\sqrt{\\mathrm{Var}(F)}/\\mathbb{E}[F]$\n\n该问题在科学上基于生态稳定性理论，提法恰当，包含所有必要信息，且陈述客观。一个关键的检查是参数所隐含的协方差矩阵的半正定性。这要求 $\\rho \\ge -\\frac{1}{S-1}$。当 $S=5$ 时，条件是 $\\rho \\ge -\\frac{1}{4} = -0.25$。给定的两个相关性 $\\rho_A = 0.6$ 和 $\\rho_B = -0.2$ 都满足这个条件。因此，该问题是有效的，我们可以继续求解。\n\n求解过程首先从推导恒定性 $I$ 的一个通用表达式开始。\n总功能 $F$ 的均值可以通过期望算子的线性性求得：\n$$\n\\mathbb{E}[F] = \\mathbb{E}\\left[\\sum_{i=1}^{S} X_i\\right] = \\sum_{i=1}^{S} \\mathbb{E}[X_i]\n$$\n给定对于所有 $i=1, \\dots, S$ 都有 $\\mathbb{E}[X_i] = \\mu$，则均值为：\n$$\n\\mathbb{E}[F] = \\sum_{i=1}^{S} \\mu = S\\mu\n$$\n总功能 $F$ 的方差是相关随机变量之和的方差：\n$$\n\\mathrm{Var}(F) = \\mathrm{Var}\\left(\\sum_{i=1}^{S} X_i\\right) = \\sum_{i=1}^{S} \\sum_{j=1}^{S} \\mathrm{Cov}(X_i, X_j)\n$$\n这个和可以分解为方差之和（当 $i=j$ 时）和协方差之和（当 $i \\neq j$ 时）：\n$$\n\\mathrm{Var}(F) = \\sum_{i=1}^{S} \\mathrm{Var}(X_i) + \\sum_{i \\neq j} \\mathrm{Cov}(X_i, X_j)\n$$\n我们已知 $\\mathrm{Var}(X_i) = \\sigma^2$。对于 $i \\neq j$ 的协方差与相关系数 $\\rho$ 的关系为 $\\mathrm{Cov}(X_i, X_j) = \\rho \\sqrt{\\mathrm{Var}(X_i)\\mathrm{Var}(X_j)} = \\rho \\sigma^2$。共有 $S$ 个方差项和 $S(S-1)$ 个协方差项。\n将这些代入 $\\mathrm{Var}(F)$ 的表达式中：\n$$\n\\mathrm{Var}(F) = S\\sigma^2 + S(S-1)\\rho\\sigma^2 = S\\sigma^2 \\left(1 + (S-1)\\rho\\right)\n$$\n恒定性 $I$ 定义为变异系数平方 $\\mathrm{CV}^2(F)$ 的倒数：\n$$\nI = \\frac{1}{\\mathrm{CV}^2(F)} = \\frac{(\\mathbb{E}[F])^2}{\\mathrm{Var}(F)}\n$$\n代入推导出的均值和方差表达式：\n$$\nI = \\frac{(S\\mu)^2}{S\\sigma^2(1 + (S-1)\\rho)} = \\frac{S^2\\mu^2}{S\\sigma^2(1 + (S-1)\\rho)} = \\frac{S\\mu^2}{\\sigma^2(1 + (S-1)\\rho)}\n$$\n这个通用公式使我们能够计算每种情景下的恒定性。\n\n对于情景A（同步波动），我们使用 $\\rho_A = 0.6$ 和给定的参数 $S=5$, $\\mu=4$, 以及 $\\sigma^2=1$：\n$$\nI_A = \\frac{5 \\cdot 4^2}{1 \\cdot (1 + (5-1) \\cdot 0.6)} = \\frac{5 \\cdot 16}{1 + 4 \\cdot 0.6} = \\frac{80}{1 + 2.4} = \\frac{80}{3.4} = \\frac{400}{17}\n$$\n对于情景B（补偿性波动），我们使用 $\\rho_B = -0.2$：\n$$\nI_B = \\frac{5 \\cdot 4^2}{1 \\cdot (1 + (5-1) \\cdot (-0.2))} = \\frac{5 \\cdot 16}{1 + 4 \\cdot (-0.2)} = \\frac{80}{1 - 0.8} = \\frac{80}{0.2} = 400\n$$\n保险效应是差值 $\\Delta I = I_B - I_A$：\n$$\n\\Delta I = 400 - \\frac{400}{17} = 400 \\left(1 - \\frac{1}{17}\\right) = 400 \\left(\\frac{16}{17}\\right) = \\frac{6400}{17}\n$$\n为了给出最终答案，我们计算其数值并按要求四舍五入到四位有效数字：\n$$\n\\Delta I = \\frac{6400}{17} \\approx 376.470588...\n$$\n四舍五入到四位有效数字得到 $376.5$。", "answer": "$$\\boxed{376.5}$$", "id": "2493347"}, {"introduction": "在理解了如何量化生态系统功能的稳定性（不变性）之后，我们可以将这一理论知识应用于实际的管理决策中。本练习模拟了一个常见的生态恢复或物种保护情景：在有限的预算下，如何挑选一组物种来最大化整个生态系统的功能稳定性。这个实践将理论概念转化为一个实用的优化决策工具，展示了功能冗余理论在资源管理中的应用价值 [@problem_id:2493430]。", "problem": "考虑一个生态系统功能，该功能是物种层面随机性能贡献的加和。设有 $n$ 个物种，对于每个物种 $i \\in \\{0,1,\\dots,n-1\\}$，将其随机贡献表示为 $X_i$，其期望贡献表示为 $\\mu_i = \\mathbb{E}[X_i]$，其标准差表示为 $\\sigma_i = \\sqrt{\\mathrm{Var}(X_i)}$。设成对相关性由一个对称相关矩阵 $\\mathbf{R} = [\\rho_{ij}]$ 指定，其中对所有 $i$ 都有 $\\rho_{ii} = 1$，因此协方差矩阵由 $\\mathrm{Cov}(X_i,X_j) = \\rho_{ij}\\sigma_i \\sigma_j$ 确定。对于物种的任意选定子集 $S \\subseteq \\{0,1,\\dots,n-1\\}$，总生态系统功能为 $F_S = \\sum_{i \\in S} X_i$。将子集 $S$ 的功能恒定性（稳定性生态学中用于捕捉保险效应的标准度量）定义为 $I(S) = \\frac{(\\mathbb{E}[F_S])^2}{\\mathrm{Var}(F_S)}$。当多个物种对同一功能做出贡献并表现出异步或弱相关的波动时，就会产生功能冗余和保险效应，从而相对于 $(\\mathbb{E}[F_S])^2$ 降低了 $\\mathrm{Var}(F_S)$。\n\n您必须从第一性原理出发，构建并解决以下优化问题。仅从随机变量和的期望、方差和协方差的核心定义出发，推导出为任何候选子集 $S$ 评估 $I(S)$ 所需的表达式，包括如何在给定 $(\\mu_i)$、$(\\sigma_i)$ 和 $\\mathbf{R}$ 的情况下计算 $\\mathbb{E}[F_S]$ 和 $\\mathrm{Var}(F_S)$。然后，在带有物种成本的资源预算约束下，选择使恒定性 $I(S)$ 最大化的子集 $S$。约束条件是总成本不超过预算，且子集必须为非空。如果多个子集达到相同的最大恒定性，则通过选择总成本最小的子集来打破平局；如果仍然存在平局，则在物种索引按升序排序时，选择字典序最小的子集。物种索引是基于 $0$ 的，并且必须按此报告。\n\n您的程序必须为以下四个测试用例中的每一个评估最优子集。对于每个测试用例，您将获得：\n- 物种数量 $n$，\n- 成本向量 $\\mathbf{c}$，其中 $c_i$ 是物种 $i$ 的成本，\n- 预算 $B$，\n- 均值向量 $\\boldsymbol{\\mu}$，\n- 标准差向量 $\\boldsymbol{\\sigma}$，\n- 相关矩阵 $\\mathbf{R}$。\n\n对于每个测试，在所有满足 $\\sum_{i \\in S} c_i \\le B$ 的非空子集 $S \\subseteq \\{0,1,\\dots,n-1\\}$ 上最大化 $I(S)$。\n\n测试用例 1（具有混合相关性和多种可行基数的理想路径）：\n- $n = 5$\n- $\\mathbf{c} = \\left[3,\\,2,\\,2,\\,4,\\,1\\right]$\n- $B = 5$\n- $\\boldsymbol{\\mu} = \\left[1.2,\\,1.1,\\,0.9,\\,1.0,\\,0.8\\right]$\n- $\\boldsymbol{\\sigma} = \\left[0.4,\\,0.5,\\,0.3,\\,0.6,\\,0.35\\right]$\n- $\\mathbf{R} = \\begin{bmatrix}\n1   0.05   -0.05   0.08   0.00\\\\\n0.05   1   0.02   -0.04   0.06\\\\\n-0.05   0.02   1   0.01   -0.03\\\\\n0.08   -0.04   0.01   1   0.02\\\\\n0.00   0.06   -0.03   0.02   1\n\\end{bmatrix}$\n\n测试用例 2（边界情况，强调高相关性，这会削弱某些选择的保险效应）：\n- $n = 4$\n- $\\mathbf{c} = \\left[3,\\,1,\\,1,\\,3\\right]$\n- $B = 4$\n- $\\boldsymbol{\\mu} = \\left[1.5,\\,1.0,\\,0.6,\\,1.1\\right]$\n- $\\boldsymbol{\\sigma} = \\left[0.9,\\,0.2,\\,0.15,\\,0.3\\right]$\n- $\\mathbf{R} = \\begin{bmatrix}\n1   0.10   0.00   0.60\\\\\n0.10   1   0.10   0.10\\\\\n0.00   0.10   1   0.00\\\\\n0.60   0.10   0.00   1\n\\end{bmatrix}$\n\n测试用例 3（边缘情况，预算非常紧张，只允许单元素解）：\n- $n = 3$\n- $\\mathbf{c} = \\left[5,\\,2,\\,3\\right]$\n- $B = 2$\n- $\\boldsymbol{\\mu} = \\left[1.0,\\,0.9,\\,1.1\\right]$\n- $\\boldsymbol{\\sigma} = \\left[0.4,\\,0.2,\\,0.5\\right]$\n- $\\mathbf{R} = \\begin{bmatrix}\n1   0.10   0.00\\\\\n0.10   1   0.00\\\\\n0.00   0.00   1\n\\end{bmatrix}$\n\n测试用例 4（边缘情况，通过负相关说明强保险效应）：\n- $n = 3$\n- $\\mathbf{c} = \\left[2,\\,2,\\,2\\right]$\n- $B = 4$\n- $\\boldsymbol{\\mu} = \\left[0.8,\\,0.8,\\,0.8\\right]$\n- $\\boldsymbol{\\sigma} = \\left[0.4,\\,0.4,\\,0.4\\right]$\n- $\\mathbf{R} = \\begin{bmatrix}\n1   -0.40   0.00\\\\\n-0.40   1   0.00\\\\\n0.00   0.00   1\n\\end{bmatrix}$\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个结果本身必须是对应测试用例的所选基于 $0$ 的物种索引的升序列表。例如，四个测试用例的有效输出形式为 $\\left[\\left[i_{1,1},i_{1,2},\\dots\\right],\\left[i_{2,1},\\dots\\right],\\left[\\dots\\right],\\left[\\dots\\right]\\right]$，不含空格。", "solution": "所提出的问题是一个定义明确的优化任务，其基础是理论生态学和统计学的原理。它在科学上是合理的、客观的，并包含确定唯一解所需的所有信息。因此，我们将直接进行推导和求解。\n\n该问题要求我们从总共 $n$ 个物种中找到一个非空子集 $S$，在预算约束下最大化功能恒定性 $I(S)$。恒定性定义为 $I(S) = \\frac{(\\mathbb{E}[F_S])^2}{\\mathrm{Var}(F_S)}$，其中 $F_S = \\sum_{i \\in S} X_i$ 是子集 $S$ 中物种提供的总生态系统功能。此处，$X_i$ 是物种 $i$ 的随机性能贡献。\n\n我们首先从第一性原理推导期望 $\\mathbb{E}[F_S]$ 和方差 $\\mathrm{Var}(F_S)$ 的表达式。\n\n首先，我们确定总生态系统功能的期望 $\\mathbb{E}[F_S]$。总功能是单个物种贡献的总和：$F_S = \\sum_{i \\in S} X_i$。根据期望算子的线性性质，和的期望等于期望的和：\n$$ \\mathbb{E}[F_S] = \\mathbb{E}\\left[\\sum_{i \\in S} X_i\\right] = \\sum_{i \\in S} \\mathbb{E}[X_i] $$\n我们已知 $\\mu_i = \\mathbb{E}[X_i]$ 是物种 $i$ 的期望贡献。因此，子集 $S$ 的期望总功能是其构成物种的平均贡献之和：\n$$ \\mathbb{E}[F_S] = \\sum_{i \\in S} \\mu_i $$\n\n接下来，我们确定总生态系统功能的方差 $\\mathrm{Var}(F_S)$。随机变量和的方差由其协方差矩阵中所有元素的总和给出。具体来说，对于 $F_S = \\sum_{i \\in S} X_i$：\n$$ \\mathrm{Var}(F_S) = \\mathrm{Var}\\left(\\sum_{i \\in S} X_i\\right) = \\sum_{i \\in S} \\sum_{j \\in S} \\mathrm{Cov}(X_i, X_j) $$\n该表达式包括单个物种的方差（当 $i=j$ 时）和物种对之间的协方差（当 $i \\ne j$ 时）。我们已知每个物种 $i$ 的标准差 $\\sigma_i$ 和相关矩阵 $\\mathbf{R} = [\\rho_{ij}]$。协方差由相关性和标准差定义为 $\\mathrm{Cov}(X_i, X_j) = \\rho_{ij}\\sigma_i\\sigma_j$。注意，当 $i=j$ 时，我们有 $\\rho_{ii}=1$，因此 $\\mathrm{Cov}(X_i, X_i) = \\sigma_i^2 = \\mathrm{Var}(X_i)$，这符合要求。将协方差的定义代入方差公式，得到：\n$$ \\mathrm{Var}(F_S) = \\sum_{i \\in S} \\sum_{j \\in S} \\rho_{ij}\\sigma_i\\sigma_j $$\n这个公式正确地捕捉了保险效应：对于一组给定的个体方差，负相关或弱正相关 $\\rho_{ij}$ 会降低总方差 $\\mathrm{Var}(F_S)$，从而增加聚合功能的稳定性。\n\n有了这些表达式，优化问题就是找到解决以下问题的子集 $S^*$：\n$$ \\max_{S \\subseteq \\{0, \\dots, n-1\\}} I(S) = \\frac{\\left(\\sum_{i \\in S} \\mu_i\\right)^2}{\\sum_{i \\in S} \\sum_{j \\in S} \\rho_{ij}\\sigma_i\\sigma_j} $$\n约束条件如下：\n1. 子集必须为非空：$S \\ne \\emptyset$。\n2. 总成本不得超过预算 $B$：$\\sum_{i \\in S} c_i \\le B$。\n\n如果 $I(S)$ 的最大值出现平局，平局打破规则如下：\n1. 选择总成本 $\\sum_{i \\in S} c_i$ 最小的子集。\n2. 如果仍然存在平局，则选择排序后索引的字典序最小的子集。\n\n鉴于所提供测试用例中的物种数量较少（$n \\le 5$），直接的穷举搜索是最稳健和直接的算法方法。我们将遍历 $n$ 个物种的所有可能的非空子集。共有 $2^n - 1$ 个这样的子集。\n\n算法如下：\n1. 初始化最优解的跟踪变量：将 `max_invariability` 设置为 $-1$，`min_cost` 设置为无穷大，`best_subset` 设置为 `None`。\n2. 生成物种索引 $\\{0, 1, \\dots, n-1\\}$ 的所有非空子集。这可以通过迭代一个从 $1$ 到 $2^n - 1$ 的整数，并使用其二进制表示作为掩码来选择物种来实现。\n3. 对于每个子集 $S$：\n    a. 计算其总成本 $C_S = \\sum_{i \\in S} c_i$。\n    b. 如果 $C_S  B$，则该子集不可行；舍弃并处理下一个子集。\n    c. 如果可行，计算 $E_S = \\sum_{i \\in S} \\mu_i$ 和 $V_S = \\sum_{i \\in S} \\sum_{j \\in S} \\rho_{ij}\\sigma_i\\sigma_j$。\n    d. 计算恒定性 $I(S) = (E_S)^2 / V_S$。由于所有 $\\sigma_i  0$，任何子集的协方差矩阵都将是正定的，从而确保 $V_S  0$。\n    e. 将 $I(S)$ 与 `max_invariability` 进行比较。如果 $I(S)$ 更大，它就成为新的最优解。如果 $I(S)$ 相等，则根据成本和字典序应用指定的平局打破规则。\n4. 评估完所有子集后，`best_subset` 将包含最优物种组合的排序后索引。\n\n为了计算效率，预先计算完整的协方差矩阵 $\\mathbf{C}$，其元素为 $C_{ij} = \\rho_{ij}\\sigma_i\\sigma_j$。然后，对于每个子集 $S$，总方差 $V_S$ 就是与 $S$ 中索引对应的 $\\mathbf{C}$ 子矩阵所有元素的总和。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the species subset selection problem for all test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"n\": 5,\n            \"c\": np.array([3, 2, 2, 4, 1]),\n            \"B\": 5,\n            \"mu\": np.array([1.2, 1.1, 0.9, 1.0, 0.8]),\n            \"sigma\": np.array([0.4, 0.5, 0.3, 0.6, 0.35]),\n            \"R\": np.array([\n                [1, 0.05, -0.05, 0.08, 0.00],\n                [0.05, 1, 0.02, -0.04, 0.06],\n                [-0.05, 0.02, 1, 0.01, -0.03],\n                [0.08, -0.04, 0.01, 1, 0.02],\n                [0.00, 0.06, -0.03, 0.02, 1]\n            ])\n        },\n        {\n            \"n\": 4,\n            \"c\": np.array([3, 1, 1, 3]),\n            \"B\": 4,\n            \"mu\": np.array([1.5, 1.0, 0.6, 1.1]),\n            \"sigma\": np.array([0.9, 0.2, 0.15, 0.3]),\n            \"R\": np.array([\n                [1, 0.10, 0.00, 0.60],\n                [0.10, 1, 0.10, 0.10],\n                [0.00, 0.10, 1, 0.00],\n                [0.60, 0.10, 0.00, 1]\n            ])\n        },\n        {\n            \"n\": 3,\n            \"c\": np.array([5, 2, 3]),\n            \"B\": 2,\n            \"mu\": np.array([1.0, 0.9, 1.1]),\n            \"sigma\": np.array([0.4, 0.2, 0.5]),\n            \"R\": np.array([\n                [1, 0.10, 0.00],\n                [0.10, 1, 0.00],\n                [0.00, 0.00, 1]\n            ])\n        },\n        {\n            \"n\": 3,\n            \"c\": np.array([2, 2, 2]),\n            \"B\": 4,\n            \"mu\": np.array([0.8, 0.8, 0.8]),\n            \"sigma\": np.array([0.4, 0.4, 0.4]),\n            \"R\": np.array([\n                [1, -0.40, 0.00],\n                [-0.40, 1, 0.00],\n                [0.00, 0.00, 1]\n            ])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        optimal_subset = find_optimal_subset(\n            case[\"n\"], case[\"c\"], case[\"B\"],\n            case[\"mu\"], case[\"sigma\"], case[\"R\"]\n        )\n        results.append(optimal_subset)\n\n    # Format the output string to be a list of lists with no spaces\n    # Example: [[0,1],[2],[0,2]]\n    output_str = f\"[{','.join([f'[{\",\".join(map(str, r))}]' for r in results])}]\"\n    print(output_str)\n\ndef find_optimal_subset(n, c, B, mu, sigma, R):\n    \"\"\"\n    Finds the optimal species subset by iterating through all possibilities.\n    \"\"\"\n    # Pre-calculate the covariance matrix: Cov(Xi, Xj) = rho_ij * sigma_i * sigma_j\n    cov_matrix = np.outer(sigma, sigma) * R\n\n    best_subset = None\n    max_invariability = -1.0\n    min_cost = float('inf')\n\n    # Iterate through all non-empty subsets using a bitmask (1 to 2^n - 1)\n    for i in range(1, 1  n):\n        subset_indices = []\n        for j in range(n):\n            if (i >> j)  1:\n                subset_indices.append(j)\n\n        current_cost = np.sum(c[subset_indices])\n\n        if current_cost > B:\n            continue\n\n        total_mean = np.sum(mu[subset_indices])\n        \n        # Extract the sub-covariance matrix for the current subset\n        # and sum all its elements to get the total variance\n        sub_cov_matrix = cov_matrix[np.ix_(subset_indices, subset_indices)]\n        total_variance = np.sum(sub_cov_matrix)\n\n        if total_variance = 0:\n            # This case is unlikely with positive sigmas and valid correlation matrices.\n            # If total_mean is non-zero, invariability is infinite.\n            invariability = float('inf') if total_mean != 0 else 0.0\n        else:\n            invariability = (total_mean ** 2) / total_variance\n\n        # Apply maximization and tie-breaking rules with a small tolerance for float comparisons\n        if invariability > max_invariability + 1e-9:\n            max_invariability = invariability\n            min_cost = current_cost\n            best_subset = subset_indices\n        elif abs(invariability - max_invariability)  1e-9:\n            if current_cost  min_cost - 1e-9:\n                min_cost = current_cost\n                best_subset = subset_indices\n            elif abs(current_cost - min_cost)  1e-9:\n                # subset_indices are naturally sorted, compare lexicographically\n                if best_subset is None or subset_indices  best_subset:\n                    best_subset = subset_indices\n\n    return best_subset if best_subset is not None else []\n\nsolve()\n```", "id": "2493430"}, {"introduction": "本练习将我们的视角从理论建模转向数据分析与假设检验。在生态学研究中，我们观察到的模式可能是有意义的生物学信号，也可能仅仅是随机过程的结果。此练习引入了一种强大的统计方法——零模型分析，通过它我们可以检验在一个群落中观测到的功能冗余水平是否显著高于随机预期的水平，从而为实证研究提供一项关键的分析技能 [@problem_id:2493359]。", "problem": "考虑一个由 $S$ 个物种组成的群落，物种索引为 $i \\in \\{1,\\dots,S\\}$。每个物种具有一个非负丰度 $a_i \\in \\mathbb{R}_{\\ge 0}$ 和一个分类性状标签 $c_i \\in \\{0,1,\\dots,T-1\\}$，该标签指示其属于 $T$ 个性状类别之一。令 $A = \\sum_{i=1}^S a_i$ 表示总丰度，对于每个性状 $t \\in \\{0,1,\\dots,T-1\\}$，定义 $A_t = \\sum_{i: c_i = t} a_i$ 为属于性状 $t$ 的总丰度。假设 $A  0$。功能冗余的操作性定义如下。考虑一个两阶段随机实验：首先，从整个群落中以与丰度成正比的概率抽取一个个体，得到性状 $t$ 的概率为 $p_t = A_t/A$。然后，在给定性状 $t$ 的条件下，从性状为 $t$ 的子群落中独立地（有放回地）抽取另一个个体。性状 $t$ 的功能冗余是指这两个独立抽取的个体属于性状 $t$ 内不同物种的概率。群落水平的功能冗余定义为所有性状的这些性状水平概率的 $p_t$ 加权平均值。仅根据这些定义，推导出一个关于物种丰度 $a_i$ 及其性状标签 $c_i$ 的群落水平功能冗余的显式可计算表达式。\n\n您将使用这个推导出的表达式来构建一个零模型，该模型在物种间随机化性状标签，同时保持物种丰度向量不变。该零模型是对应用于物种的性状标签向量 $(c_1,\\dots,c_S)$ 的一个均匀随机排列，它保留了性状标签的多重集（因此也保留了每个性状的物种数量），但打破了性状标签与丰度大小之间的任何关联。对于给定的观测群落，计算观测冗余，并将其与由 $M$ 次独立随机排列生成的冗余分布进行比较。使用连续性校正估计量\n$$\np = \\frac{1 + K}{1 + M},\n$$\n报告仅凭机遇产生至少与观测值一样大的冗余的单侧概率，其中 $K$ 是冗余大于或等于观测冗余的零模型排列次数。为保证可复现性，请使用固定的伪随机种子。\n\n您的任务是实现一个程序，对下面指定的每个测试用例执行以下步骤：\n- 根据上述推导的第一性原理，计算观测到的群落水平功能冗余。\n- 生成 $M$ 个性状标签的零模型排列，每次都使用保持不变的丰度向量重新计算冗余。\n- 按规定计算单侧概率 $p$。\n- 将所有测试用例的 $p$ 值列表输出到单行，格式为用方括号括起来的逗号分隔列表。\n\n所有性状标签都是 $\\{0,1,\\dots,T-1\\}$ 中的整数，所有丰度也都是整数，但您的计算除了使用给定值外，不应假设其具有整数性。在程序内的所有随机化操作中，使用固定的伪随机种子 $2025$。\n\n测试套件：\n- 用例 $1$：$S = 6$， $T = 3$，丰度 $(40,30,20,10,0,0)$，性状标签 $(0,0,1,1,2,2)$，排列次数 $M = 5000$。\n- 用例 $2$：$S = 8$， $T = 2$，丰度 $(10,10,10,10,10,10,10,10)$，性状标签 $(0,0,0,1,1,1,1,1)$，排列次数 $M = 5000$。\n- 用例 $3$：$S = 4$， $T = 4$，丰度 $(25,25,25,25)$，性状标签 $(0,1,2,3)$，排列次数 $M = 3000$。\n- 用例 $4$：$S = 7$， $T = 3$，丰度 $(50,1,1,1,1,1,1)$，性状标签 $(0,0,0,1,1,2,2)$，排列次数 $M = 5000$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[0.412,0.5,0.001,0.873]”）。不应打印其他任何文本。角度或物理单位不适用。所有实值答案必须以标准字符串格式的十进制浮点数打印。", "solution": "该问题要求推导群落水平功能冗余的表达式，并将其用于零模型分析，以检验物种丰度与其功能性状之间是否存在非随机关联。整个过程必须以无可指摘的逻辑和数学严谨性来执行。\n\n首先，我们将根据所提供的定义推导群落水平功能冗余 $R_{comm}$ 的表达式。\n\n设物种集合的索引为 $i \\in \\{1, \\dots, S\\}$，其对应的丰度为 $a_i \\ge 0$，性状标签为 $c_i \\in \\{0, \\dots, T-1\\}$。\n群落总丰度为 $A = \\sum_{i=1}^S a_i$。给定条件为 $A  0$。\n特定性状类别 $t$ 的总丰度为 $A_t = \\sum_{i: c_i = t} a_i$。\n\n分析从单个的性状类别 $t$ 的水平开始。性状 $t$ 的功能冗余（记作 $R_t$）定义为：从拥有性状 $t$ 的物种子群落中独立有放回地抽取两个个体，这两个个体属于不同物种的概率。在性状为 $t$ 的条件下，从该子群落中抽到物种 $i$ 的个体的概率是 $a_i / A_t$，假设 $A_t  0$。\n\n两次这样的独立抽取均得到同一物种 $i$ 的个体的概率是 $(a_i/A_t)^2$。为了求出两次抽取得到同一个物种（类别 $t$ 内的任何物种）的个体的概率，我们将此概率对所有属于性状类别 $t$ 的物种 $i$ 求和：\n$$\nP(\\text{same species} | \\text{trait } t) = \\sum_{i: c_i=t} \\left(\\frac{a_i}{A_t}\\right)^2 = \\frac{\\sum_{i: c_i=t} a_i^2}{A_t^2}\n$$\n此表达式是性状 $t$ 的子群落的辛普森集中指数的一种形式。\n\n功能冗余 $R_t$ 是其互补概率——即两个个体属于不同物种的概率：\n$$\nR_t = 1 - P(\\text{same species} | \\text{trait } t) = 1 - \\frac{\\sum_{i: c_i=t} a_i^2}{A_t^2}\n$$\n这在 $A_t  0$ 时有定义。如果 $A_t = 0$，则该性状类别为空。无法抽取任何个体，因此其中的冗余概念没有实际意义。在这种情况下，我们可以定义 $R_t = 0$。\n\n接下来，群落水平功能冗余 $R_{comm}$ 定义为所有性状的性状水平冗余 $R_t$ 的加权平均值。每个性状 $t$ 的权重因子是从整个群落中抽到具有该性状的个体的概率 $p_t$。该概率与该性状类别的总丰度成正比，因此 $p_t = A_t/A$。\n\n$$\nR_{comm} = \\sum_{t=0}^{T-1} p_t R_t = \\sum_{t=0}^{T-1} \\frac{A_t}{A} R_t\n$$\n如果 $A_t=0$，那么 $p_t=0$，性状 $t$ 的项对总和的贡献为零。因此，我们只需对 $A_t  0$ 的性状求和。\n代入 $R_t$ 的表达式：\n$$\nR_{comm} = \\sum_{t: A_t  0} \\frac{A_t}{A} \\left( 1 - \\frac{\\sum_{i: c_i=t} a_i^2}{A_t^2} \\right)\n$$\n为了更稳定地计算，此表达式可以进行代数简化：\n$$\nR_{comm} = \\frac{1}{A} \\sum_{t: A_t  0} A_t \\left( 1 - \\frac{\\sum_{i: c_i=t} a_i^2}{A_t^2} \\right) = \\frac{1}{A} \\sum_{t: A_t  0} \\left( A_t - \\frac{\\sum_{i: c_i=t} a_i^2}{A_t} \\right)\n$$\n这就是群落水平功能冗余的最终、显式且可计算的表达式。\n\n解决该问题的计算步骤如下：\n\n1.  基于推导出的公式实现一个函数 `calculate_redundancy`。该函数以物种丰度向量 $(a_1, \\dots, a_S)$ 和相应的性状标签向量 $(c_1, \\dots, c_S)$ 作为输入。为确保计算效率和鲁棒性，使用向量化操作。具体而言，同时对所有性状类别 $t \\in \\{0, \\dots, T-1\\}$ 进行操作：\n    *   计算每个性状的总丰度 $A_t$。\n    *   计算每个性状的丰度平方和 $\\sum_{i:c_i=t} a_i^2$。\n    *   使用这些数组根据推导的公式计算 $R_{comm}$，并仔细处理 $A_t = 0$ 的情况以避免除以零。\n\n2.  对于每个测试用例，使用给定的物种丰度和性状标签计算观测到的群落水平冗余 $R_{obs}$。\n\n3.  通过生成性状标签向量 $(c_1, \\dots, c_S)$ 的 $M$ 个随机排列来构建一个零模型。对于每次排列，物种丰度向量保持不变，但将排列后的性状标签分配给物种。此过程打破了丰度值和性状标签之间的任何观测关联，同时保留了丰度分布和每个性状类别的物种数量（即性状标签的多重集）。\n\n4.  对于 $M$ 个零模型配置中的每一个，重新计算冗余 $R_{null}$。\n\n5.  统计所得冗余大于或等于观测冗余（$R_{null} \\ge R_{obs}$）的零模型模拟次数 $K$。\n\n6.  然后使用连续性校正估计量计算单侧 p 值：\n    $$\n    p = \\frac{1 + K}{1 + M}\n    $$\n该值表示在物种丰度与功能性状之间没有关联的零假设下，获得至少与观测值一样大的冗余的概率。\n\n使用固定的伪随机种子来确保随机化过程的可复现性。该过程应用于每个测试用例，并将所得的 p 值收集起来并以要求的格式呈现。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the functional redundancy problem for a suite of test cases.\n    \"\"\"\n    \n    # Set the fixed seed for pseudorandom number generation to ensure reproducibility.\n    SEED = 2025\n    rng = np.random.default_rng(SEED)\n\n    def calculate_redundancy(abundances: np.ndarray, traits: np.ndarray, T: int) -> float:\n        \"\"\"\n        Computes community-level functional redundancy from first principles.\n\n        Args:\n            abundances: A 1D numpy array of species abundances.\n            traits: A 1D numpy array of species trait labels.\n            T: The total number of trait classes.\n\n        Returns:\n            The community-level functional redundancy as a float.\n        \"\"\"\n        # Total community abundance\n        A = np.sum(abundances)\n        if A == 0:\n            return 0.0\n\n        # Calculate total abundance per trait (A_t)\n        # np.bincount is highly efficient for this grouped summation.\n        A_t = np.bincount(traits, weights=abundances, minlength=T)\n\n        # Calculate sum of squared abundances per trait\n        sum_sq_a_t = np.bincount(traits, weights=abundances**2, minlength=T)\n\n        # Identify traits with non-zero abundance to avoid division by zero\n        non_zero_At_mask = A_t > 0\n        \n        # Initialize array for trait-level redundancies\n        R_t = np.zeros(T, dtype=float)\n\n        # Calculate redundancy only for traits with positive abundance\n        R_t[non_zero_At_mask] = 1.0 - sum_sq_a_t[non_zero_At_mask] / (A_t[non_zero_At_mask]**2)\n\n        # Calculate trait probabilities (p_t = A_t / A)\n        p_t = A_t / A\n\n        # Community-level redundancy is the p_t-weighted average of R_t\n        community_redundancy = np.sum(p_t * R_t)\n\n        return community_redundancy\n\n    # Test suite provided in the problem statement\n    test_cases = [\n        {'S': 6, 'T': 3, 'abundances': np.array([40, 30, 20, 10, 0, 0]), 'traits': np.array([0, 0, 1, 1, 2, 2]), 'M': 5000},\n        {'S': 8, 'T': 2, 'abundances': np.array([10, 10, 10, 10, 10, 10, 10, 10]), 'traits': np.array([0, 0, 0, 0, 1, 1, 1, 1]), 'M': 5000},\n        {'S': 4, 'T': 4, 'abundances': np.array([25, 25, 25, 25]), 'traits': np.array([0, 1, 2, 3]), 'M': 3000},\n        {'S': 7, 'T': 3, 'abundances': np.array([50, 1, 1, 1, 1, 1, 1]), 'traits': np.array([0, 0, 0, 1, 1, 2, 2]), 'M': 5000},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        abundances = case['abundances']\n        traits = case['traits']\n        T = case['T']\n        M = case['M']\n\n        # Step 1: Compute observed redundancy\n        observed_redundancy = calculate_redundancy(abundances, traits, T)\n\n        # Step 2: Run null model simulation\n        K = 0  # Counter for null_R >= observed_R\n        shuffled_traits = traits.copy()\n\n        for _ in range(M):\n            rng.shuffle(shuffled_traits)\n            null_redundancy = calculate_redundancy(abundances, shuffled_traits, T)\n            if null_redundancy >= observed_redundancy:\n                K += 1\n        \n        # Step 3: Compute the one-sided p-value\n        p_value = (1 + K) / (1 + M)\n        results.append(p_value)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{r:.16f}'.rstrip('0').rstrip('.') for r in results)}]\")\n\nsolve()\n```", "id": "2493359"}]}