{"hands_on_practices": [{"introduction": "生境破碎化会产生小而孤立的种群，这些种群极易受到随机人口事件（即人口随机性）的影响而灭绝。本练习 [@problem_id:2497287] 应用了种群生态学中的一个基础工具——高尔顿-沃森分支过程，来量化这种灭绝风险。通过解决这个问题，您将具体理解在退化的生境片段中，个体平均补充量的下降如何直接转化为一个可计算的种群灭绝概率。", "problem": "一个小型、孤立的森林碎片中栖息着一种领域性鸟类，其种群密度极低，因此密度依赖性可以忽略不计。在这个退化的生境中，每个成鸟在一个繁殖季节产下一窝幼鸟。在本地补充并存活到下一代成为繁殖者的后代数量（由随机变量 $K$ 表示）反映了边缘效应驱动的巢捕食和幼鸟存活率下降。对此碎片的实证监测估计，一代时间内每个成鸟的后代补充分布如下：$\\mathbb{P}(K=0)=0.3$, $\\mathbb{P}(K=1)=0.3$, 和 $\\mathbb{P}(K=2)=0.4$。假设世代不重叠，每个谱系在每一代中都根据相同的人均后代补充分布进行独立同分布（i.i.d.）的繁殖，并且没有外来迁入。\n\n将种群动态视为一个高尔顿-沃森（Galton–Watson）分支过程，这在小型碎片中低密度、存在人口随机性的情况下是合适的。从第0代的 $n=4$ 个成鸟开始，计算在此条件下种群的最终灭绝概率。将最终答案表示为一个无量纲数，并四舍五入到四位有效数字。", "solution": "在尝试任何解答之前，将对所述问题进行严格的验证。\n\n步骤1：提取已知条件。\n已知条件如下：\n- 模型：种群动态被视为一个高尔顿-沃森分支过程。\n- 初始种群规模：第0代有 $n=4$ 个成鸟。\n- 后代随机变量：$K$ 是每个成鸟产生的、存活到下一代的本地补充后代数量。\n- 后代概率分布：$\\mathbb{P}(K=0)=0.3$, $\\mathbb{P}(K=1)=0.3$, 以及 $\\mathbb{P}(K=2)=0.4$。\n- 假设：\n    - 密度依赖性可以忽略。\n    - 世代不重叠。\n    - 每个谱系独立同分布（i.i.d.）繁殖。\n    - 没有外来迁入。\n- 任务：计算种群的最终灭绝概率。\n- 格式要求：最终答案必须是一个无量纲数，并四舍五入到四位有效数字。\n\n步骤2：使用提取的已知条件进行验证。\n根据指定标准对问题进行验证。\n- **科学依据**：高尔顿-沃森过程是用于描述低密度种群的标准且合适的数学模型，在这种情况下，人口随机性是主导动态，并且忽略密度依赖性的假设是合理的。所提供的生态背景，即生境破碎化导致后代补充减少，是一个公认的现象。后代概率分布是有效的，因为各概率之和为1：$0.3 + 0.3 + 0.4 = 1$。该问题在科学上和数学上都是合理的。\n- **适定性**：该问题是适定的。分支过程理论为在给定初始种群规模和后代分布的情况下确定最终灭绝概率提供了清晰且唯一的方法。\n- **客观性**：该问题以精确、客观的语言陈述，没有主观或模棱两可的术语。\n\n结论：该问题有效。这是将分支过程理论应用于种群生态学问题的标准应用。开始解答。\n\n种群动态由一个高尔顿-沃森分支过程描述。令 $Z_t$ 表示第 $t$ 代的个体数量。初始条件为 $Z_0 = 4$。单个个体产生的后代数量 $K$ 服从以下分布：\n$$ \\mathbb{P}(K=0) = p_0 = 0.3 $$\n$$ \\mathbb{P}(K=1) = p_1 = 0.3 $$\n$$ \\mathbb{P}(K=2) = p_2 = 0.4 $$\n对于 $k > 2$，所有其他概率 $\\mathbb{P}(K=k)$ 均为零。\n\n分析此类过程的核心工具是后代分布的概率生成函数（PGF）。PGF记为 $G(s)$，定义为 $G(s) = \\mathbb{E}[s^K]$。对于给定的分布，它为：\n$$ G(s) = \\sum_{k=0}^{\\infty} p_k s^k = p_0 s^0 + p_1 s^1 + p_2 s^2 $$\n代入给定的概率：\n$$ G(s) = 0.3 + 0.3s + 0.4s^2 $$\n\n分支过程理论的一个基本结果指出，从单个个体开始的谱系的最终灭绝概率（我们记为 $q$）是方程 $G(s) = s$ 的最小非负根。\n\n首先，我们计算人均后代数量的均值，$\\mu = \\mathbb{E}[K]$。这由 $\\mu = G'(1)$ 给出。\n$$ G'(s) = \\frac{d}{ds} (0.3 + 0.3s + 0.4s^2) = 0.3 + 0.8s $$\n$$ \\mu = G'(1) = 0.3 + 0.8(1) = 1.1 $$\n由于 $\\mu = 1.1 > 1$，该过程是超临界的。这意味着存在一个非零的永久存活概率，因此，灭绝概率 $q$ 将严格小于 $1$。\n\n我们现在求解方程 $G(s) = s$ 来找到 $q$ 的值：\n$$ 0.3 + 0.3s + 0.4s^2 = s $$\n将其整理成标准二次方程形式 $as^2 + bs + c = 0$：\n$$ 0.4s^2 + (0.3 - 1)s + 0.3 = 0 $$\n$$ 0.4s^2 - 0.7s + 0.3 = 0 $$\n为了简化，我们可以将整个方程乘以 $10$：\n$$ 4s^2 - 7s + 3 = 0 $$\n这个二次方程可以使用求根公式 $s = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$ 来求解：\n$$ s = \\frac{-(-7) \\pm \\sqrt{(-7)^2 - 4(4)(3)}}{2(4)} $$\n$$ s = \\frac{7 \\pm \\sqrt{49 - 48}}{8} $$\n$$ s = \\frac{7 \\pm \\sqrt{1}}{8} $$\n$$ s = \\frac{7 \\pm 1}{8} $$\n这得到了两个根：\n$$ s_1 = \\frac{7 - 1}{8} = \\frac{6}{8} = \\frac{3}{4} = 0.75 $$\n$$ s_2 = \\frac{7 + 1}{8} = \\frac{8}{8} = 1 $$\n灭绝概率 $q$ 是最小的非负根，即 $q = 0.75$。这是一个由单个个体开始的谱系最终灭绝的概率。\n\n问题要求的是整个种群的灭绝概率，该种群从 $Z_0 = n = 4$ 个个体开始。由于每个个体的繁殖是一个独立同分布的过程，总种群灭绝当且仅当所有4个初始个体的谱系都灭绝。\n\n因此，从 $n$ 个个体开始的种群的灭绝概率 $q_n$ 是各个体灭绝概率的乘积：\n$$ q_n = q^n $$\n对于这个问题，当 $n=4$ 且 $q=0.75$ 时：\n$$ q_4 = (0.75)^4 = \\left(\\frac{3}{4}\\right)^4 = \\frac{3^4}{4^4} = \\frac{81}{256} $$\n\n为了以所要求的格式提供答案，我们必须将此分数转换为小数，并四舍五入到四位有效数字。\n$$ \\frac{81}{256} = 0.31640625 $$\n将此值四舍五入到四位有效数字得到 $0.3164$。\n这是种群的最终灭绝概率。", "answer": "$$\\boxed{0.3164}$$", "id": "2497287"}, {"introduction": "连接生境斑块的景观基质并非空无一物，其特征会影响生物体的移动能力。我们可以使用“成本表面”来模拟景观对移动的阻力，并找到使该成本最小化的最优路径。本练习 [@problem_id:2497296] 将向您介绍最小成本路径分析，这是景观遗传学和野生动物廊道设计的保护规划基石。通过在网格上实现戴克斯特拉（Dijkstra）算法，您将学习如何以计算方式识别最佳移动路线，并评估不同生态策略之间的权衡，例如最小化能量消耗与最小化被捕食风险。", "problem": "考虑在因生境破坏和退化而造成的破碎化景观中的移动，这种景观由一个空间变化的能量消耗表面来表示。一个生物体从指定的起始位置沿连续路径移动到指定的目标位置。沿路径所需的累积移动能量被建模为局部能量消耗密度的路径积分，而沿路径的累积捕食风险被建模为局部捕食风险密度的路径积分。基本依据是路径上局部速率的可加性：如果一个量的局部累积速率由空间上的一个场给出，那么沿路径累积的总量等于该场沿路径对弧长的积分。形式上，设能量消耗密度为函数 $C(x,y)$（单位：千焦/公里），捕食风险密度为函数 $\\rho(x,y)$（单位：风险/公里），路径表示为由弧长 $s$（从 $s=0$ 到 $s=L$）参数化的曲线 $\\gamma(s)$。沿路径的累积能量消耗和累积风险分别为：\n$$\nE[\\gamma] = \\int_{0}^{L} C(\\gamma(s))\\, ds,\\quad R[\\gamma] = \\int_{0}^{L} \\rho(\\gamma(s))\\, ds.\n$$\n规定了一个移动预算 $B$（单位：千焦）。当且仅当一条路径的能量满足 $E[\\gamma] \\le B$ 时，该路径是可行的。\n\n由于在异质景观上的精确连续优化通常是难以处理的，您必须通过一个均匀的方形网格来近似该区域，并通过连接单元中心的网格边段上的黎曼和来近似线积分。使用以下离散化和算法规范，这些规范基于线积分定义和用于分段平均的梯形法则：\n\n- 设网格有 $N_x$ 列和 $N_y$ 行方形单元，每个单元的边长为 $\\Delta$ 公里。具有整数索引 $(i,j)$（列 $i$ 从左起，行 $j$ 从下起）的单元中心，其中 $i \\in \\{0,\\dots,N_x-1\\}$ 且 $j \\in \\{0,\\dots,N_y-1\\}$，其坐标为 $(x_i,y_j) = (i\\Delta,j\\Delta)$ 公里。\n- 允许在 $8$ 邻域（水平、垂直和对角线）中任意一对相邻单元的中心之间移动。相邻单元 $(i,j)$ 和 $(i',j')$ 之间的步长，对于水平和垂直移动是 $\\Delta$，对于对角线移动是 $\\Delta\\sqrt{2}$。\n- 对于连接相邻单元 $(i,j)$ 和 $(i',j')$ 的任意边，使用梯形法则近似 $C$ 在该短段上的积分，得到边能量权重\n$$\nw_C\\big((i,j)\\to(i',j')\\big) = \\frac{C_{i,j} + C_{i',j'}}{2} \\cdot \\ell\\big((i,j),(i',j')\\big),\n$$\n并近似 $\\rho$ 在该段上的积分为\n$$\nw_\\rho\\big((i,j)\\to(i',j')\\big) = \\frac{\\rho_{i,j} + \\rho_{i',j'}}{2} \\cdot \\ell\\big((i,j),(i',j')\\big),\n$$\n其中 $\\ell\\big((i,j),(i',j')\\big)$ 是步长（公里），且 $C_{i,j} = C(x_i,y_j)$, $\\rho_{i,j} = \\rho(x_i,y_j)$。\n- 离散路径上的累积能量是其各边 $w_C$ 的总和，累积风险是其各边 $w_\\rho$ 的总和。\n- 起始索引 $(i_s,j_s)$ 和目标索引 $(i_t,j_t)$ 之间的最低能量路径是最小化连接它们的所有 $8$ 邻域路径上 $w_C$ 总和的路径。最低风险路径是最小化 $w_\\rho$ 总和的路径。为计算每条路径，应在具有相应非负边权重的网格图上应用正确的单源最短路径算法。找到每条路径后，使用相同的边权重定义评估该路径的累积能量和累积风险。当且仅当一条路径的累积能量小于或等于 $B$ 时，该路径在预算下是可行的。\n\n科学现实性说明：生境破坏和退化通过提高 $C$ 的值以及在相关情况下提高 $\\rho$ 的值来建模，这反映了在退化或开阔区域中能量障碍和捕食暴露的增加。当 $\\rho$ 与 $C$ 成正比时，两条最优路径预计会重合，因为在相同的边界条件下，最小化一个泛函等同于最小化另一个泛函（相差一个正常数因子）。\n\n任务。实现一个程序，为下面的每个测试用例构建离散化景观，计算 (i) 最低能量路径和 (ii) 最低风险路径，报告每条路径的能量和风险，并根据移动预算评估其可行性。所有能量以千焦表示，风险以小数表示。所有报告的浮点结果四舍五入到三位小数。\n\n离散化和边权重规则必须与上述规定完全一致。索引是基于零的。以下所有常数和数值均为精确值。\n\n测试套件。所有用例均使用 $N_x = N_y = 21$ 和 $\\Delta = 0.5$ 公里。共有 $4$ 个测试用例：\n\n- 用例 $1$ (具有向北递增风险的部分可绕行能量屏障):\n  - 起点 $(i_s,j_s) = (0,10)$, 终点 $(i_t,j_t) = (20,10)$, 预算 $B = 20$ 千焦。\n  - 定义一个屏障指示符 $\\mathbb{I}_{\\mathrm{bar}}(i,j)$，当且仅当 $i \\in \\{9,10,11\\}$ 且 $j \\in \\{6,7,8,9,10,11,12,13,14\\}$ 时为 $1$，否则为 $0$。\n  - 能量消耗场: $C_{i,j} = 1 + 9\\,\\mathbb{I}_{\\mathrm{bar}}(i,j)$ (单位：千焦/公里)。\n  - 捕食风险场: $\\rho_{i,j} = 0.1 + 0.5\\,\\mathbb{I}_{\\mathrm{bar}}(i,j) + 0.01\\, y_j$ (单位：风险/公里)，其中 $y_j = j\\Delta$ (单位：公里)。\n\n- 用例 $2$ (与用例1景观相同，但预算更紧):\n  - 起点 $(i_s,j_s) = (0,10)$, 终点 $(i_t,j_t) = (20,10)$, 预算 $B = 12$ 千焦。\n  - $C_{i,j}$ 和 $\\rho_{i,j}$ 与用例1完全相同。\n\n- 用例 $3$ (恶劣基质中的廊道):\n  - 起点 $(i_s,j_s) = (0,0)$, 终点 $(i_t,j_t) = (20,20)$, 预算 $B = 16$ 千焦。\n  - 定义一个廊道指示符 $\\mathbb{I}_{\\mathrm{cor}}(i,j)$，当且仅当 $|i - j| \\le 1$ 时为 $1$，否则为 $0$。\n  - 能量消耗场: $C_{i,j} = 1\\cdot \\mathbb{I}_{\\mathrm{cor}}(i,j) + 4\\cdot \\big(1 - \\mathbb{I}_{\\mathrm{cor}}(i,j)\\big)$ (单位：千焦/公里)。\n  - 捕食风险场: $\\rho_{i,j} = 0.05\\cdot \\mathbb{I}_{\\mathrm{cor}}(i,j) + 0.4\\cdot \\big(1 - \\mathbb{I}_{\\mathrm{cor}}(i,j)\\big)$ (单位：风险/公里)。\n\n- 用例 $4$ (风险与能量消耗成正比):\n  - 起点 $(i_s,j_s) = (0,10)$, 终点 $(i_t,j_t) = (20,10)$, 预算 $B = 30$ 千焦。\n  - 能量消耗场: 如果 $j \\in \\{8,9,10,11,12\\}$，则 $C_{i,j} = 2$，否则 $C_{i,j} = 1$ (单位：千焦/公里)。\n  - 捕食风险场: $\\rho_{i,j} = 0.05\\, C_{i,j}$ (单位：风险/公里)。\n\n所需输出。对于每个用例，您必须按顺序生成以下六个值：\n- 最低能量路径的总能量（千焦），四舍五入到三位小数。\n- 最低能量路径的总风险（小数），四舍五入到三位小数。\n- 一个布尔值，指示最低能量路径在预算下的可行性。\n- 最低风险路径的总能量（千焦），四舍五入到三位小数。\n- 最低风险路径的总风险（小数），四舍五入到三位小数。\n- 一个布尔值，指示最低风险路径在预算下的可行性。\n\n最终输出格式。您的程序应生成一行输出，其中包含所有用例的所有结果，这些结果汇集成一个单一的扁平列表，按用例顺序排列，值以逗号分隔，并用方括号括起来（例如，$[e_1,r_1,b_1,e_2,r_2,b_2,\\dots]$）。不要打印任何额外的文本。所有能量必须以千焦为单位，所有风险以小数表示。不使用角度。不得使用百分比；风险仅以小数表示。", "solution": "用户提供了一个来自景观生态学领域的明确定义的计算问题。对问题陈述的验证证实了它具有科学依据、数学上适定、客观，并包含了进行唯一求解所需的所有信息。因此，该问题被认为是**有效的**。\n\n任务是确定生物体在异质景观中移动的最优路径，其中“最优”可以通过最小化累积能量消耗或累积捕食风险来定义。景观被离散化为一个网格，移动被建模为图上的路径。\n\n**基于原则的解决方案设计**\n\n1.  **景观的图表示**：连续的景观通过一个大小为 $N_x \\times N_y$ 的均匀方形网格来近似。每个网格单元 $(i,j)$ 的中心被视为图中的一个节点。总节点数为 $N = N_x \\times N_y$。如果任意两个节点对应的单元在 $8$ 连通意义上（水平、垂直或对角）是邻居，则它们之间存在一条边。这种结构代表了生物体可以进行的所有短距离移动。为了计算方便，二维网格索引 $(i,j)$ 被映射到一个一维节点索引 $k = i + j \\cdot N_x$。\n\n2.  **边权重公式**：问题陈述指出，沿路径 $\\gamma$ 累积的总能量 $E$ 和总风险 $R$ 分别是成本密度 $C(x,y)$ 和 $\\rho(x,y)$ 的路径积分。在离散网格上，每个短边段上的积分使用梯形法则进行近似。对于连接节点 $(i,j)$ 和 $(i',j')$ 的边，其能量权重 $w_C$ 和风险权重 $w_\\rho$ 为：\n    $$\n    w_C = \\frac{C_{i,j} + C_{i',j'}}{2} \\cdot \\ell((i,j), (i',j'))\n    $$\n    $$\n    w_\\rho = \\frac{\\rho_{i,j} + \\rho_{i',j'}}{2} \\cdot \\ell((i,j), (i',j'))\n    $$\n    这里，$C_{i,j}$ 和 $\\rho_{i,j}$ 是在单元 $(i,j)$ 中心评估的成本密度，$\\ell$ 是单元中心之间的欧几里得距离。对于单元边长为 $\\Delta$ 的网格，基数移动（水平/垂直）的 $\\ell = \\Delta$，对角线移动的 $\\ell = \\Delta\\sqrt{2}$。由于所有成本密度和长度都是非负的，所有边权重也都是非负的。这是选择算法的一个关键属性。\n\n3.  **通过Dijkstra算法计算最优路径**：寻找从起始节点到目标节点具有最小累积成本（无论是能量还是风险）的路径是一个经典的单源最短路径（SSSP）问题。由于所有边权重都是非负的，Dijkstra算法是找到解决方案的合适且高效的方法。\n    -   我们构建两个带权的、具有对称边的有向图，用稀疏矩阵表示：$G_C$ 的边权重为 $w_C$，$G_R$ 的边权重为 $w_\\rho$。\n    -   Dijkstra算法执行两次：\n        1.  在图 $G_C$ 上，以指定的起始节点开始。这会找到到每个其他节点的路径的最小能量。到目标节点的 resultante 路径是**最低能量路径（LEP）**。\n        2.  在图 $G_R$ 上，以指定的起始节点开始。这会找到到每个其他节点的路径的最小风险。到目标节点的 resultante 路径是**最低风险路径（MRP）**。\n    -   该算法产生一个从源点出发的最短距离数组和一个前驱节点数组，这使得可以重构最短路径本身。\n\n4.  **路径分析与可行性**：除非成本函数成比例，否则两条最优路径（LEP 和 MRP）通常不相同。问题要求计算这两条路径各自的能量和风险。\n    -   对于 LEP，其总能量直接从在 $G_C$ 上运行 Dijkstra 算法的输出中获得。要找到其总风险，首先从前驱节点数组重构路径。然后，对构成该路径的所有边，将其风险权重 $w_\\rho$ 相加。\n    -   对于 MRP，遵循一个对称的程序：其总风险由在 $G_R$ 上运行 Dijkstra 算法给出，其总能量通过重构路径并沿其边累加能量权重 $w_C$ 来找到。\n    -   最后，对于每条路径，将其总能量 $E$ 与移动预算 $B$ 进行比较。如果 $E \\le B$，则该路径是可行的。\n\n5.  **实现**：该解决方案用 Python 实现。每个测试用例的成本场被生成为 `numpy` 数组。图的构建使用 `scipy.sparse.csr_matrix` 格式存储边权重以提高效率。`scipy.sparse.csgraph.dijkstra` 函数提供了 SSSP 算法的稳健实现。一个辅助函数从 Dijkstra 返回的前驱节点重构路径，并通过查找预先计算的边权重来计算次要成本（例如，能量最优路径上的风险）。所有测试用例的结果被汇总并按规定格式化。", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import dijkstra\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the solver for each, \n    and print the final formatted output.\n    \"\"\"\n    NX, NY, DELTA = 21, 21, 0.5\n\n    # Case 1 Setup\n    I_bar_1 = np.zeros((NY, NX))\n    I_bar_1[6:15, 9:12] = 1.0  # Rows 6-14, Cols 9-11\n    C1 = 1.0 + 9.0 * I_bar_1\n    y_coords_j = (np.arange(NY) * DELTA)[:, np.newaxis]  # Shape (NY, 1)\n    rho1 = 0.1 + 0.5 * I_bar_1 + 0.01 * y_coords_j\n\n    # Case 2 Setup (same landscape as Case 1)\n    C2, rho2 = C1, rho1\n\n    # Case 3 Setup\n    I_cor_3 = np.zeros((NY, NX))\n    for j in range(NY):\n        for i in range(NX):\n            if abs(i - j) = 1:\n                I_cor_3[j, i] = 1.0\n    C3 = 1.0 * I_cor_3 + 4.0 * (1.0 - I_cor_3)\n    rho3 = 0.05 * I_cor_3 + 0.4 * (1.0 - I_cor_3)\n\n    # Case 4 Setup\n    C4 = np.ones((NY, NX))\n    C4[8:13, :] = 2.0  # Rows 8-12\n    rho4 = 0.05 * C4\n\n    test_cases = [\n        {'nx': NX, 'ny': NY, 'delta': DELTA, 'start_idx': (0, 10), 'target_idx': (20, 10), 'budget': 20.0, 'C_grid': C1, 'rho_grid': rho1},\n        {'nx': NX, 'ny': NY, 'delta': DELTA, 'start_idx': (0, 10), 'target_idx': (20, 10), 'budget': 12.0, 'C_grid': C2, 'rho_grid': rho2},\n        {'nx': NX, 'ny': NY, 'delta': DELTA, 'start_idx': (0, 0),   'target_idx': (20, 20), 'budget': 16.0, 'C_grid': C3, 'rho_grid': rho3},\n        {'nx': NX, 'ny': NY, 'delta': DELTA, 'start_idx': (0, 10), 'target_idx': (20, 10), 'budget': 30.0, 'C_grid': C4, 'rho_grid': rho4},\n    ]\n\n    all_results = []\n    for case_params in test_cases:\n        results = solve_case(**case_params)\n        all_results.extend(results)\n\n    formatted_results = [f\"{x:.3f}\" if isinstance(x, float) else str(x) for x in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\ndef solve_case(nx, ny, delta, start_idx, target_idx, budget, C_grid, rho_grid):\n    \"\"\"\n    Solves a single test case for least-energy and minimum-risk paths.\n    \"\"\"\n    num_nodes = nx * ny\n    start_node = start_idx[0] + start_idx[1] * nx\n    target_node = target_idx[0] + target_idx[1] * nx\n\n    row_ind, col_ind = [], []\n    energy_data, risk_data = [], []\n    edge_weights_C = {}\n    edge_weights_R = {}\n\n    moves = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n    dist_hor_ver = delta\n    dist_diag = delta * np.sqrt(2.0)\n\n    for j in range(ny):\n        for i in range(nx):\n            node_u = i + j * nx\n            for di, dj in moves:\n                ni, nj = i + di, j + dj\n                if 0 = ni  nx and 0 = nj  ny:\n                    node_v = ni + nj * nx\n                    length = dist_diag if di != 0 and dj != 0 else dist_hor_ver\n                    \n                    w_c = (C_grid[j, i] + C_grid[nj, ni]) / 2.0 * length\n                    w_r = (rho_grid[j, i] + rho_grid[nj, ni]) / 2.0 * length\n                    \n                    row_ind.append(node_u)\n                    col_ind.append(node_v)\n                    energy_data.append(w_c)\n                    risk_data.append(w_r)\n                    \n                    edge_weights_C[(node_u, node_v)] = w_c\n                    edge_weights_R[(node_u, node_v)] = w_r\n\n    graph_C = csr_matrix((energy_data, (row_ind, col_ind)), shape=(num_nodes, num_nodes))\n    graph_R = csr_matrix((risk_data, (row_ind, col_ind)), shape=(num_nodes, num_nodes))\n\n    def get_secondary_cost(start, target, predecessors, weights_secondary):\n        if predecessors[target] == -9999 and start != target:\n            return float('inf')\n\n        path = []\n        curr = target\n        while curr != -9999:\n            path.append(curr)\n            if curr == start: break\n            curr = predecessors[curr]\n        path.reverse()\n        \n        if not path or path[0] != start:\n            return float('inf')\n\n        secondary_cost = 0.0\n        for k in range(len(path) - 1):\n            u, v = path[k], path[k+1]\n            secondary_cost += weights_secondary.get((u, v), 0)\n        return secondary_cost\n\n    # 1. Least-Energy Path (LEP)\n    dist_C, pred_C = dijkstra(csgraph=graph_C, directed=True, indices=start_node, return_predecessors=True)\n    energy_LEP = dist_C[target_node]\n    risk_LEP = get_secondary_cost(start_node, target_node, pred_C, edge_weights_R)\n    feasible_LEP = energy_LEP = budget\n\n    # 2. Minimum-Risk Path (MRP)\n    dist_R, pred_R = dijkstra(csgraph=graph_R, directed=True, indices=start_node, return_predecessors=True)\n    risk_MRP = dist_R[target_node]\n    energy_MRP = get_secondary_cost(start_node, target_node, pred_R, edge_weights_C)\n    feasible_MRP = energy_MRP = budget\n    \n    return [energy_LEP, risk_LEP, feasible_LEP, energy_MRP, risk_MRP, feasible_MRP]\n\nsolve()\n```", "id": "2497296"}, {"introduction": "现实世界中的保护工作需要在有限的预算和多重目标下，就保护哪些地块做出艰难的抉择。系统性保护规划为此类复杂问题提供了寻找最优或近优解的定量框架。本练习 [@problem_id:2497331] 使用一个简化的Marxan式目标函数来模拟这一决策过程，Marxan是该领域广泛使用的软件工具。通过寻找最优的规划单元组合，您将直接处理在成本、物种代表性目标和生境连通性之间进行权衡的挑战，这些都是现代保护科学的核心。", "problem": "要求您实现并分析一个小型、精确、Marxan 风格的保护区设计问题，该问题通过成本、物种特异性代表性目标以及随边界长度增加的连通性惩罚来捕捉生境的破坏、退化和破碎化。您的程序必须通过穷举搜索，根据一个精确的目标函数，计算规划单元的最优选择。然后，它必须将所提供测试套件的最优选择汇总为单行输出。\n\n考虑一组规划单元，索引为 $i \\in \\{0,1,2,3,4,5,6,7\\}$（从零开始索引）。设 $N = 8$ 且 $S = 3$。每个规划单元 $i$ 都有一个非负成本 $c_i$。每个规划单元 $i$ 为每个物种 $s \\in \\{0,1,2\\}$ 贡献数量为 $A_{i,s}$ 的适宜生境（无单位的适宜性）。物种具有代表性目标量 $T_s  0$。定义一个二元决策向量 $x \\in \\{0,1\\}^N$，其中如果规划单元 $i$ 被选中，则 $x_i = 1$，否则 $x_i = 0$。规划单元之间的连通性由一个具有非负项的对称权重矩阵 $W \\in \\mathbb{R}^{N \\times N}$ 捕捉。需要最小化的总体目标是\n$$\nF(x \\mid \\lambda,\\gamma) \\;=\\; \\sum_{i=0}^{N-1} c_i x_i \\;+\\; \\gamma \\sum_{0 \\le i  j \\le N-1} W_{i,j} \\, |x_i - x_j| \\;+\\; \\sum_{s=0}^{S-1} \\lambda_s \\, \\max\\!\\left(0,\\; T_s - \\sum_{i=0}^{N-1} A_{i,s} x_i \\right),\n$$\n其中 $\\lambda = (\\lambda_0,\\lambda_1,\\lambda_2)$ 是非负的物种惩罚权重，$\\gamma \\ge 0$ 是非负的连通性惩罚权重。该目标包括一个成本项，一个边界长度连通性惩罚（该惩罚随着所选和未选规划单元之间切割边（cut edges）的数量和强度而增加），以及一个物种不足惩罚（该惩罚所施加的成本与每个物种未达到其代表性目标的程度成正比）。\n\n使用以下固定的数据集，该数据集对于研究生高阶示例而言，在科学上是合理的且自洽的：\n\n- 规划单元数量：$N = 8$。\n- 物种数量：$S = 3$。\n- 成本（无单位的成本指数）：\n$$\nc \\;=\\; \\big[\\, 2.0,\\; 3.5,\\; 2.5,\\; 5.0,\\; 4.5,\\; 3.0,\\; 6.0,\\; 1.5 \\,\\big].\n$$\n- 物种适宜性矩阵（无单位），行由规划单元 $i \\in \\{0,\\dots,7\\}$ 索引，列由物种 $s \\in \\{0,1,2\\}$ 索引：\n$$\nA \\;=\\;\n\\begin{bmatrix}\n0.8  0.1  0.0 \\\\\n0.6  0.2  0.1 \\\\\n0.1  0.5  0.4 \\\\\n0.0  0.7  0.6 \\\\\n0.3  0.1  0.8 \\\\\n0.4  0.0  0.5 \\\\\n0.2  0.4  0.2 \\\\\n0.9  0.0  0.0\n\\end{bmatrix}.\n$$\n- 物种目标（无单位）：\n$$\nT \\;=\\; \\big[\\, 1.8,\\; 1.2,\\; 1.5 \\,\\big].\n$$\n- 连通性权重：规划单元呈线性链状，因此\n$$\nW_{i,j} \\;=\\;\n\\begin{cases}\n1,  \\text{若 } |i-j| = 1,\\\\\n0,  \\text{其他情况,}\n\\end{cases}\n$$\n对于所有 $0 \\le i,j \\le 7$。在此 $W$ 下，连通性项简化为 $\\gamma \\sum_{i=0}^{6} |x_i - x_{i+1}|$。\n\n您的程序必须通过枚举所有 $2^N$ 个子集来精确最小化 $F(x \\mid \\lambda,\\gamma)$，以确保这个小实例的全局最优性。如果出现平局（在数值容差范围内，多个 $x$ 达到相同的最小目标值），请按顺序应用以下规则来打破平局：\n- 首先，选择所选集合基数 $\\sum_{i=0}^{N-1} x_i$ 最小的解。\n- 其次，如果仍然存在平局，则选择按索引 $i=0,1,\\dots,N-1$ 递增顺序读取时字典序最小的二元向量 $x$。\n\n为研究惩罚权重如何影响所选解，请评估以下六个测试案例，每个案例指定了物种惩罚权重 $\\lambda$ 和连通性惩罚权重 $\\gamma$：\n- 案例 $\\mathrm{A}$：$\\lambda = [\\, 0.0,\\; 0.0,\\; 0.0 \\,]$，$\\gamma = 0.0$。\n- 案例 $\\mathrm{B}$：$\\lambda = [\\, 3.0,\\; 3.0,\\; 3.0 \\,]$，$\\gamma = 0.0$。\n- 案例 $\\mathrm{C}$：$\\lambda = [\\, 3.0,\\; 3.0,\\; 3.0 \\,]$，$\\gamma = 3.0$。\n- 案例 $\\mathrm{D}$：$\\lambda = [\\, 10.0,\\; 1.0,\\; 1.0 \\,]$，$\\gamma = 0.0$。\n- 案例 $\\mathrm{E}$：$\\lambda = [\\, 50.0,\\; 50.0,\\; 50.0 \\,]$，$\\gamma = 0.0$。\n- 案例 $\\mathrm{F}$：$\\lambda = [\\, 10.0,\\; 10.0,\\; 10.0 \\,]$，$\\gamma = 5.0$。\n\n您的任务是实现一个程序，为每个案例计算出最优的规划单元选择集。将每个最优选择表示为一个排序后的、由满足 $x_i = 1$ 的从零开始的索引 $i$ 组成的列表。\n\n最终输出格式：您的程序应生成单行输出，其中包含六个案例的结果，格式为一个由方括号括起来的逗号分隔列表，其中每个元素是该案例的所选索引列表。例如，一个包含三个案例的有效输出可能看起来像 $[\\,[0,2],\\,[\\,],\\,[1,3,4]\\,]$；对于本问题，您必须按此精确的单行格式输出六个列表。不涉及物理单位。不涉及角度。任何小数数量在代码和计算中都必须表示为十进制数。", "solution": "所呈现的问题是一个定义明确的组合优化问题，源于计算保护规划领域。它具有科学依据，数学上严谨，并且其规范是完整的。我已经验证了其组成部分，没有发现任何不一致或违反科学原则之处。因此，我将着手提供一个解决方案。\n\n任务是找到使给定目标函数最小化的规划单元的最优选择。规划单元集由 $i \\in \\{0, 1, \\dots, N-1\\}$ 索引，其中 $N=8$。一个选择由二元向量 $x \\in \\{0,1\\}^N$ 表示，其中 $x_i=1$ 表示单元 $i$ 被选中，$x_i=0$ 表示未被选中。可能的选择总数为 $2^N = 2^8 = 256$，这个数字足够小，可以进行穷举搜索以找到全局最优解。\n\n需要最小化的目标函数是：\n$$\nF(x \\mid \\lambda,\\gamma) \\;=\\; \\sum_{i=0}^{N-1} c_i x_i \\;+\\; \\gamma \\sum_{0 \\le i  j \\le N-1} W_{i,j} \\, |x_i - x_j| \\;+\\; \\sum_{s=0}^{S-1} \\lambda_s \\, \\max\\!\\left(0,\\; T_s - \\sum_{i=0}^{N-1} A_{i,s} x_i \\right)\n$$\n该函数由三个不同的项组成：\n1.  **总成本**：项 $\\sum_{i=0}^{N-1} c_i x_i$ 代表所有选定规划单元的成本总和。这可以计算为成本向量 $c$ 和选择向量 $x$ 的点积。\n2.  **连通性惩罚**：项 $\\gamma \\sum_{0 \\le i  j \\le N-1} W_{i,j} |x_i - x_j|$ 对破碎化进行惩罚。问题指定了一个线性链结构，其中如果 $|i-j|=1$ 则 $W_{i,j}=1$，否则为 $0$。这使得该项简化为 $\\gamma \\sum_{i=0}^{N-2} |x_i - x_{i+1}|$。这个总和计算了相邻的已选和未选单元之间的“断裂”或“边界”的数量，并按惩罚权重 $\\gamma$ 进行缩放。\n3.  **物种不足惩罚**：项 $\\sum_{s=0}^{S-1} \\lambda_s \\max(0, T_s - \\sum_{i=0}^{N-1} A_{i,s} x_i)$ 对未能满足物种代表性目标的情况施加惩罚。对于每个物种 $s$，所选单元提供的生境总量为 $\\sum_{i=0}^{N-1} A_{i,s} x_i$。如果该数量小于目标 $T_s$，则出现不足。惩罚是此不足量的大小乘以特定物种的惩罚权重 $\\lambda_s$。\n\n解决策略如下：\n将实现一个算法，遍历所有 $2^8 = 256$ 种可能的选择向量 $x$。对于每个向量，使用提供的数据（$c, A, T$）和特定测试案例的参数（$\\lambda, \\gamma$）计算目标函数 $F(x \\mid \\lambda, \\gamma)$ 的值。\n\n在迭代过程中，该算法会维护迄今为止找到的最小目标值以及相应的最优选择向量列表。如果一个选择向量产生的函数值低于当前最小值，它就成为新的唯一最优解。如果一个向量产生的值等于当前最小值（在小的数值容差范围内，例如 $10^{-9}$），则将其添加到最优解列表中。\n\n在评估完所有 $2^N$ 个向量后，如果存在多个最优解，则严格按顺序应用指定的平局打破程序：\n1.  对解进行筛选，只保留那些基数最小的解，即所选单元数量 $\\sum_{i=0}^{N-1} x_i$ 最小的解。\n2.  如果平局仍然存在，则选择字典序最小的二元向量 $x$。这是当从左到右（索引 $i=0$ 到 $N-1$）读取时，代表最小整数的向量。\n\n这一完整程序保证为问题中定义的六个测试案例中的每一个找到唯一的全局最优解。最终输出将呈现每个案例的所选索引集。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the optimal selection of planning units for a series of test cases\n    by performing an exhaustive search over all possible selections.\n    \"\"\"\n    # Define the fixed dataset for the reserve design problem.\n    N = 8  # Number of planning units\n    S = 3  # Number of species\n\n    # Costs for each planning unit\n    c = np.array([2.0, 3.5, 2.5, 5.0, 4.5, 3.0, 6.0, 1.5])\n    \n    # Species suitability matrix A[i, s]\n    A = np.array([\n        [0.8, 0.1, 0.0],\n        [0.6, 0.2, 0.1],\n        [0.1, 0.5, 0.4],\n        [0.0, 0.7, 0.6],\n        [0.3, 0.1, 0.8],\n        [0.4, 0.0, 0.5],\n        [0.2, 0.4, 0.2],\n        [0.9, 0.0, 0.0]\n    ])\n    \n    # Species representation targets\n    T = np.array([1.8, 1.2, 1.5])\n\n    # Define the six test cases with varying penalty weights.\n    test_cases = [\n        # Case A\n        {'lambda_': np.array([0.0, 0.0, 0.0]), 'gamma': 0.0},\n        # Case B\n        {'lambda_': np.array([3.0, 3.0, 3.0]), 'gamma': 0.0},\n        # Case C\n        {'lambda_': np.array([3.0, 3.0, 3.0]), 'gamma': 3.0},\n        # Case D\n        {'lambda_': np.array([10.0, 1.0, 1.0]), 'gamma': 0.0},\n        # Case E\n        {'lambda_': np.array([50.0, 50.0, 50.0]), 'gamma': 0.0},\n        # Case F\n        {'lambda_': np.array([10.0, 10.0, 10.0]), 'gamma': 5.0}\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        lambda_s = case['lambda_']\n        gamma = case['gamma']\n        \n        min_objective_value = float('inf')\n        best_solutions = []\n\n        # Exhaustive search over all 2^N possible selections.\n        for i in range(2**N):\n            # Generate the binary selection vector x from integer i.\n            # The format string ensures correct lexicographical ordering.\n            x = np.array([int(digit) for digit in f'{i:0{N}b}'])\n            \n            # 1. Cost Term\n            cost_term = np.dot(c, x)\n            \n            # 2. Connectivity Penalty Term\n            # Simplified for a linear chain of units.\n            connectivity_term = gamma * np.sum(np.abs(x[1:] - x[:-1]))\n            \n            # 3. Species Shortfall Penalty Term\n            achieved_amounts = x @ A\n            shortfalls = T - achieved_amounts\n            penalties = np.maximum(0, shortfalls)\n            shortfall_penalty_term = np.dot(lambda_s, penalties)\n            \n            current_value = cost_term + connectivity_term + shortfall_penalty_term\n            \n            # Check for new minimum or a tie.\n            # Using a tolerance for floating-point comparisons.\n            if abs(current_value - min_objective_value)  1e-9:\n                best_solutions.append(x)\n            elif current_value  min_objective_value:\n                min_objective_value = current_value\n                best_solutions = [x]\n\n        # Apply tie-breaking rules if multiple optimal solutions were found.\n        # Rule 1: Choose solution with the smallest cardinality.\n        if len(best_solutions) > 1:\n            min_cardinality = min(sol.sum() for sol in best_solutions)\n            best_solutions = [sol for sol in best_solutions if sol.sum() == min_cardinality]\n            \n        # Rule 2: Choose the lexicographically smallest vector.\n        if len(best_solutions) > 1:\n            # Convert numpy arrays to sortable tuples.\n            solution_tuples = [tuple(sol) for sol in best_solutions]\n            solution_tuples.sort()\n            final_x = np.array(solution_tuples[0])\n        else:\n            final_x = best_solutions[0]\n            \n        # Convert the final binary vector to a list of selected indices.\n        selected_indices = np.where(final_x == 1)[0].tolist()\n        all_results.append(selected_indices)\n        \n    # Print the final aggregated result in the specified format.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2497331"}]}