{"hands_on_practices": [{"introduction": "生物网络是由单个分子间的相互作用构成的。因此，理解这些相互作用的定量性质是网络生物学研究的基石。本练习将指导你从基本的反应速率出发，推导描述相互作用强度的核心参数——解离常数（$K_d$），并计算启动子的占据率，这直接关系到基因的调控水平。通过这个练习，你将掌握将微观动力学与宏观平衡状态联系起来的基本技能。[@problem_id:2956839]", "problem": "在一个基因调控网络 (GRN) 中，一个转录因子 (TF) 结合到启动子位点以调控转录。考虑一个单一的TF结合位点，其双分子可逆结合遵循质量作用定律，反应式为 $P + L \\rightleftharpoons PL$。其中，$P$ 表示未结合的启动子，$L$ 表示游离的TF，$PL$ 表示TF-启动子复合物。微观结合速率常数和解离速率常数分别为 $k_{\\text{on}}=10^{6}\\,\\text{M}^{-1}\\text{s}^{-1}$ 和 $k_{\\text{off}}=10^{-2}\\,\\text{s}^{-1}$。假设在充分混合条件下，配体耗尽可忽略不计（因此游离配体浓度等于总TF浓度），并且系统处于热力学平衡状态。仅从质量作用定律和平衡解离常数的定义出发，首先推导用 $k_{\\text{on}}$ 和 $k_{\\text{off}}$ 表示的平衡解离常数 $K_{d}$ 的表达式，然后推导平衡启动子占有率（结合分数）$\\theta$ 作为游离TF浓度 $[L]$ 和 $K_{d}$ 的函数。最后，计算在 $[L]=10\\,\\text{nM}$ 时 $K_{d}$ 和 $\\theta$ 的值。用摩尔单位表示 $K_{d}$，用无量纲小数表示 $\\theta$。将两个报告值都四舍五入至三位有效数字。只提供最终的数值结果。", "solution": "对问题陈述进行验证。已知条件为：双分子可逆反应 $P + L \\rightleftharpoons PL$；结合速率常数 $k_{\\text{on}}=10^{6}\\,\\text{M}^{-1}\\text{s}^{-1}$；解离速率常数 $k_{\\text{off}}=10^{-2}\\,\\text{s}^{-1}$；系统处于热力学平衡状态；配体耗尽可忽略不计。问题要求推导平衡解离常数 $K_{d}$ 和启动子占有率 $\\theta$，然后计算在游离转录因子浓度为 $[L]=10\\,\\text{nM}$ 时的数值。该问题科学上基于质量作用定律，是适定的、客观的，并包含获得唯一解所需的所有信息。因此，该问题被认为是有效的。我们继续进行推导和计算。\n\n首先，我们推导平衡解离常数 $K_{d}$ 的表达式。反应式为 $P + L \\rightleftharpoons PL$。根据质量作用定律，正向结合反应的速率 $v_{\\text{f}}$ 与反应物的浓度成正比：\n$$\nv_{\\text{f}} = k_{\\text{on}} [P] [L]\n$$\n逆向解离反应的速率 $v_{\\text{r}}$ 与生成物的浓度成正比：\n$$\nv_{\\text{r}} = k_{\\text{off}} [PL]\n$$\n在热力学平衡时，反应的净速率为零，这意味着正向和逆向速率相等：$v_{\\text{f}} = v_{\\text{r}}$。\n$$\nk_{\\text{on}} [P] [L] = k_{\\text{off}} [PL]\n$$\n平衡解离常数 $K_{d}$ 定义为平衡时解离物质的浓度与复合物浓度的比值：\n$$\nK_{d} = \\frac{[P][L]}{[PL]}\n$$\n通过重排平衡时的速率等式，我们得到：\n$$\n\\frac{[P][L]}{[PL]} = \\frac{k_{\\text{off}}}{k_{\\text{on}}}\n$$\n因此，用微观速率常数表示的 $K_{d}$ 表达式为：\n$$\nK_{d} = \\frac{k_{\\text{off}}}{k_{\\text{on}}}\n$$\n接下来，我们推导平衡启动子占有率 $\\theta$ 的表达式。占有率定义为被配体（转录因子）结合的启动子位点占总启动子位点的分数。\n$$\n\\theta = \\frac{\\text{结合启动子浓度}}{\\text{总启动子浓度}} = \\frac{[PL]}{[P]_{\\text{total}}}\n$$\n总启动子浓度 $[P]_{\\text{total}}$ 是未结合的（游离的）启动子浓度 $[P]$ 和结合的启动子浓度 $[PL]$ 之和。\n$$\n[P]_{\\text{total}} = [P] + [PL]\n$$\n将此代入 $\\theta$ 的表达式中：\n$$\n\\theta = \\frac{[PL]}{[P] + [PL]}\n$$\n根据 $K_{d}$ 的定义，我们可以用 $[PL]$、$[L]$ 和 $K_{d}$ 表示游离启动子的浓度 $[P]$：\n$$\n[P] = K_{d} \\frac{[PL]}{[L]}\n$$\n将这个 $[P]$ 的表达式代入 $\\theta$ 的方程中：\n$$\n\\theta = \\frac{[PL]}{K_{d} \\frac{[PL]}{[L]} + [PL]}\n$$\n项 $[PL]$ 是分数中所有项的公因式，在 $[PL] > 0$ 的条件下可以消去：\n$$\n\\theta = \\frac{1}{\\frac{K_{d}}{[L]} + 1}\n$$\n分子和分母同乘以 $[L]$，我们得到结合等温线的标准形式，通常称为非协同结合的朗缪尔-希尔方程：\n$$\n\\theta = \\frac{[L]}{K_{d} + [L]}\n$$\n现在，我们进行数值计算。\n首先，我们使用给定的速率常数计算 $K_{d}$ 的值：\n$$\nK_{d} = \\frac{k_{\\text{off}}}{k_{\\text{on}}} = \\frac{10^{-2}\\,\\text{s}^{-1}}{10^{6}\\,\\text{M}^{-1}\\text{s}^{-1}} = 10^{-8}\\,\\text{M}\n$$\n问题要求将此值四舍五入至三位有效数字，所以 $K_{d} = 1.00 \\times 10^{-8}\\,\\text{M}$。\n\n接下来，我们计算在游离配体浓度 $[L] = 10\\,\\text{nM}$ 时的占有率 $\\theta$。我们必须首先转换 $[L]$ 的单位，使其与以摩尔浓度 (M) 为单位的 $K_{d}$ 一致。\n$$\n[L] = 10\\,\\text{nM} = 10 \\times 10^{-9}\\,\\text{M} = 10^{-8}\\,\\text{M}\n$$\n现在我们将 $[L]$ 和 $K_{d}$ 的数值代入推导出的 $\\theta$ 表达式中：\n$$\n\\theta = \\frac{[L]}{K_{d} + [L]} = \\frac{10^{-8}\\,\\text{M}}{1.00 \\times 10^{-8}\\,\\text{M} + 10^{-8}\\,\\text{M}} = \\frac{10^{-8}\\,\\text{M}}{2.00 \\times 10^{-8}\\,\\text{M}} = \\frac{1}{2} = 0.5\n$$\n问题要求将此值表示为四舍五入至三位有效数字的无量纲小数。因此，$\\theta = 0.500$。\n问题只要求提供最终的数值结果，即 $K_{d} = 1.00 \\times 10^{-8}\\,\\text{M}$ 和 $\\theta = 0.500$。", "answer": "$$\\boxed{\\begin{pmatrix} 1.00 \\times 10^{-8}  0.500 \\end{pmatrix}}$$", "id": "2956839"}, {"introduction": "在复杂的调控网络中，特定的连接模式（称为网络基序）会反复出现，并执行特定的信息处理功能。本练习聚焦于一种重要的网络基序——相干前馈环路（coherent feed-forward loop）。你将运用网络理论中的一个关键指标“介数中心性”（betweenness centrality）来分析其结构特性，从而揭示网络拓扑如何决定信息流动的潜在路径，并理解节点在网络中的重要性。[@problem_id:2956735]", "problem": "在一个基因调控网络中，节点代表转录因子，有向边代表从一个调控因子到其靶标的调控影响。考虑一个由三个转录因子 $A$、$B$ 和 $C$ 构成的有向无权网络，它们通过边 $A \\to B$、$B \\to C$ 和 $A \\to C$ 形成一个相干前馈模体。使用基于测地线（最短）路径的有向图介数中心性的标准图论定义，以及将含有 $n$ 个节点的有向网络的值缩放到单位区间的常用归一化方法，计算每个节点的介数中心性。按顺序 $\\big(C_{B}(A), C_{B}(B), C_{B}(C)\\big)$ 报告中心性值。然后，按照 $A \\mapsto 1$、$B \\mapsto 2$、$C \\mapsto 3$ 的顺序，返回最大中心性值所对应节点的索引 $v^{\\ast}$，从而确定最中心的节点。如有平局，则按字母顺序决胜。\n\n将你的最终答案表示为单个行矩阵\n$$\n\\begin{pmatrix}\nC_{B}(A)  C_{B}(B)  C_{B}(C)  v^{\\ast}\n\\end{pmatrix}.\n$$\n\n无需四舍五入。单位不适用。你的推导应从有向最短路径和介数中心性的核心定义开始，并应对每一步进行论证。", "solution": "问题陈述已经过验证，被认为是有效的。这是一个在网络理论应用于分子生物学领域中提法恰当、具有科学依据的问题。所有必要信息均已提供，且定义均为标准定义。我们现在开始解答。\n\n该问题要求计算一个特定有向图——相干前馈环路——中每个节点的归一化介数中心性。该网络包含 $n=3$ 个节点，$V = \\{A, B, C\\}$，以及一组有向无权边 $E = \\{(A, B), (B, C), (A, C)\\}$。\n\n首先，我们必须回顾节点 $v$ 的介数中心性的正式定义。未归一化的介数中心性 $C_B^{\\text{unnorm}}(v)$ 定义为，所有其他节点对 $(s, t)$ 之间经过节点 $v$ 的最短路径（测地线）所占比例的总和。在数学上，这表示为：\n$$\nC_B^{\\text{unnorm}}(v) = \\sum_{s \\neq v \\neq t \\in V} \\frac{\\sigma_{st}(v)}{\\sigma_{st}}\n$$\n其中 $\\sigma_{st}$ 是从节点 $s$ 到节点 $t$ 的最短路径总数，而 $\\sigma_{st}(v)$ 是这些最短路径中经过节点 $v$ 的数量。节点 $v$ 必须是路径上的中间节点，即 $s \\neq v$ 且 $t \\neq v$。\n\n问题指定使用有向图的标准公式将值归一化到单位区间。归一化因子是节点 $v$ 可以作为中间节点的所有节点对 $(s, t)$ 的最大可能数量。对于一个有 $n$ 个节点的有向图，这个数量是 $(n-1)(n-2)$。在我们的例子中，$n=3$，所以归一化因子是 $(3-1)(3-2) = 2 \\times 1 = 2$。\n因此，归一化的介数中心性为：\n$$\nC_B(v) = \\frac{C_B^{\\text{unnorm}}(v)}{(n-1)(n-2)} = \\frac{1}{2} \\sum_{s \\neq v \\neq t \\in V} \\frac{\\sigma_{st}(v)}{\\sigma_{st}}\n$$\n\n为了计算中心性，我们必须首先确定所有节点对 $(s, t)$ 及其对应的最短路径。该图是有向无环图。可能的路径有：\n\\begin{enumerate}\n    \\item 从 $A$ 到 $B$：唯一的路径是 $A \\to B$。其长度为 $1$。这是最短路径。因此，$\\sigma_{AB} = 1$。\n    \\item 从 $A$ 到 $C$：有两条路径：$A \\to C$ 长度为 $1$，以及 $A \\to B \\to C$ 长度为 $2$。最短路径（测地线）是 $A \\to C$。因此，最短路径长度为 $d(A,C)=1$，且只有一条这样的路径，$\\sigma_{AC} = 1$。\n    \\item 从 $B$ 到 $C$：唯一的路径是 $B \\to C$。其长度为 $1$。这是最短路径。因此，$\\sigma_{BC} = 1$。\n\\end{enumerate}\n对于所有其他不同的节点对，如 $(B, A)$、$(C, A)$ 或 $(C, B)$，不存在路径。\n\n现在，我们通过检查每个节点是否位于任何已确定的最短路径上，来计算其未归一化的中心性。\n\n对于节点 $A$：\n一个节点只有在作为中间节点时，才能对另一个节点的介数中心性有贡献。节点 $A$ 是一个源节点（其入度为 $0$）。它不可能是任何路径上的中间节点，更不用说最短路径了。因此，对于所有节点对 $(s, t)$，$\\sigma_{st}(A) = 0$。\n$$\nC_B^{\\text{unnorm}}(A) = 0\n$$\n\n对于节点 $C$：\n节点 $C$ 是一个汇节点（其出度为 $0$）。它不可能是任何路径上的中间节点，因为没有路径可以从 $C$ 出发。因此，对于所有节点对 $(s, t)$，$\\sigma_{st}(C) = 0$。\n$$\nC_B^{\\text{unnorm}}(C) = 0\n$$\n\n对于节点 $B$：\n节点 $B$ 有可能作为从 $A$ 到 $C$ 的路径上的中间节点。该路径为 $A \\to B \\to C$。然而，如前所述，这条路径的长度为 $2$，而从 $A$ 到 $C$ 的最短路径是长度为 $1$ 的直连边 $A \\to C$。由于介数中心性的定义严格基于测地线（最短路径），较长的路径 $A \\to B \\to C$ 不计入计算。从 $A$ 到 $C$ 唯一的最短路径是 $A \\to C$，它不经过 $B$。因此，$\\sigma_{AC}(B) = 0$。不存在其他节点对 $(s,t)$，使得 $B$ 能在它们的最短路径上充当中间节点。因此，节点 $B$ 的总和为零。\n$$\nC_B^{\\text{unnorm}}(B) = \\frac{\\sigma_{AC}(B)}{\\sigma_{AC}} = \\frac{0}{1} = 0\n$$\n\n所有节点的未归一化中心性均为零。应用归一化因子 $2$ 不会改变这个结果：\n$$\nC_B(A) = \\frac{0}{2} = 0\n$$\n$$\nC_B(B) = \\frac{0}{2} = 0\n$$\n$$\nC_B(C) = \\frac{0}{2} = 0\n$$\n这个结果是直连边 $A \\to C$ 的直接后果，该边使得通过 $B$ 的路径成为非测地线。如果没有这条边，节点 $B$ 将具有非零的中心性。\n\n最后，我们必须确定最中心的节点 $v^{\\ast}$。中心性值分别为 $C_B(A)=0$、$C_B(B)=0$ 和 $C_B(C)=0$。由于所有值都相等，出现了三方平局。问题规定按字母顺序决胜。按字母顺序，$A$ 排在 $B$ 和 $C$ 之前。节点索引给定为 $A \\mapsto 1$、$B \\mapsto 2$、$C \\mapsto 3$。因此，最中心的节点是 $A$，其索引为 $v^{\\ast} = 1$。\n\n最终答案需以单个行矩阵 $\\begin{pmatrix} C_B(A)  C_B(B)  C_B(C)  v^{\\ast} \\end{pmatrix}$ 报告。\n代入计算出的值，我们得到：\n$\\begin{pmatrix} 0  0  0  1 \\end{pmatrix}$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0  0  0  1\n\\end{pmatrix}\n}\n$$", "id": "2956735"}, {"introduction": "网络生物学的最终目标之一是理解网络结构如何产生特定的生物学功能。这个高级练习将静态结构与动态行为联系起来。你将为前馈环路基序构建一个基于常微分方程（ODE）的动态模型，并通过数值模拟来探索其对不同输入信号的响应。通过这个实践，你将亲眼见证这一特定的网络布线图如何使细胞能够区分暂时的“噪音”和持续的信号，从而实现“持久性检测”的功能。[@problem_id:2956867]", "problem": "为基因调控网络中的1型相干前馈环构建一个动态模型，并用它来算法化地测试对阶跃输入和短脉冲的持续性检测。该网络包含三个节点：一个上游转录因子 $X$、一个被 $X$ 激活的中间转录因子 $Y$、以及一个被 $X$ 和 $Y$ 共同激活的目标基因产物 $Z$。输入 $u(t)$ 是一个控制 $X$ 合成的外部信号。所要求的模型和分析必须严格基于以下基本原理进行推导和实现：\n\n- 分子生物学中心法则和基因调控：转录因子通过启动子占有率来调控目标基因的合成速率，基因产物的降解速率与其浓度成正比。\n- 质量作用降解：每个物种 $S \\in \\{X,Y,Z\\}$ 的衰减项与其浓度成正比，衰减常数为 $\\gamma_S$。\n- 单一激活剂的Hill型激活：启动子占有率是激活剂浓度的饱和函数，由Hill系数 $n$ 和半饱和常数 $K$ 参数化。\n- 对于整合 $X$ 和 $Y$ 并具有“与”逻辑的 $Z$ 启动子，假设 $X$ 和 $Y$ 独立地结合到启动子上不同的调控位点，因此启动子活性在独立性假设下与联合占有率成正比。\n\n根据这些原理，推导出一个由 $u(t)$ 驱动的关于 $X$、$Y$ 和 $Z$ 的常微分方程组（ODEs），初始条件为 $X(0)=0$，$Y(0)=0$，$Z(0)=0$。所有浓度单位均为任意一致单位，时间单位为任意时间单位。您必须为每个参数集实现两种输入刺激：\n\n- 持续阶跃：对于所有 $t \\ge 0$，$u(t)=u_{\\mathrm{amp}}$。\n- 有限脉冲：对于 $0 \\le t  T_{\\mathrm{pulse}}$，$u(t)=u_{\\mathrm{amp}}$；对于 $t \\ge T_{\\mathrm{pulse}}$，$u(t)=0$。\n\n对于每个参数集，在有限时间范围 $[0, T_{\\mathrm{end}}]$ 内模拟该ODE系统。将 $Z$ 的“阈值穿越”定义为存在某个 $t \\in [0, T_{\\mathrm{end}}]$ 使得 $Z(t) \\ge z_{\\mathrm{thresh}}$。当且仅当持续阶跃输入导致阈值穿越而有限脉冲输入未导致阈值穿越时，定义“持续性检测”为真。对于下方的每个测试用例，您的程序必须输出一个布尔值，指示持续性检测是否成立。\n\n测试套件（每行为一个测试用例；请完全按照给定的符号和数值使用）：\n\n- 案例1（理想情况，慢速 $Y$ 和严格的 $Z$ 门控）：$ \\alpha_X=5.0$, $ \\gamma_X=1.0$, $ \\alpha_Y=0.6$, $ \\gamma_Y=0.1$, $ K_{XY}=3.0$, $ n_{XY}=2.0$, $ \\alpha_Z=1.0$, $ \\gamma_Z=0.5$, $ K_{XZ}=3.0$, $ n_{XZ}=2.0$, $ K_{YZ}=4.0$, $ n_{YZ}=2.0$, $ u_{\\mathrm{amp}}=1.0$, $ T_{\\mathrm{pulse}}=10.0$, $ T_{\\mathrm{end}}=120.0$, $ z_{\\mathrm{thresh}}=0.6$。\n- 案例2（边界情况，快速且强的 $Y$ 使得短脉冲也能引发响应）：$ \\alpha_X=5.0$, $ \\gamma_X=1.0$, $ \\alpha_Y=3.0$, $ \\gamma_Y=0.5$, $ K_{XY}=1.0$, $ n_{XY}=2.0$, $ \\alpha_Z=1.0$, $ \\gamma_Z=0.5$, $ K_{XZ}=1.0$, $ n_{XZ}=2.0$, $ K_{YZ}=1.0$, $ n_{YZ}=2.0$, $ u_{\\mathrm{amp}}=1.0$, $ T_{\\mathrm{pulse}}=10.0$, $ T_{\\mathrm{end}}=60.0$, $ z_{\\mathrm{thresh}}=0.6$。\n- 案例3（低协同性，更严格的 $Z$ 门控仍能实现持续性检测）：$ \\alpha_X=5.0$, $ \\gamma_X=1.0$, $ \\alpha_Y=0.4$, $ \\gamma_Y=0.1$, $ K_{XY}=3.0$, $ n_{XY}=1.0$, $ \\alpha_Z=1.0$, $ \\gamma_Z=0.5$, $ K_{XZ}=3.0$, $ n_{XZ}=1.0$, $ K_{YZ}=3.0$, $ n_{YZ}=1.0$, $ u_{\\mathrm{amp}}=1.0$, $ T_{\\mathrm{pulse}}=6.0$, $ T_{\\mathrm{end}}=120.0$, $ z_{\\mathrm{thresh}}=0.5$。\n- 案例4（弱的 $Z$ 合成阻止任何阈值穿越）：$ \\alpha_X=5.0$, $ \\gamma_X=1.0$, $ \\alpha_Y=0.6$, $ \\gamma_Y=0.1$, $ K_{XY}=3.0$, $ n_{XY}=2.0$, $ \\alpha_Z=0.2$, $ \\gamma_Z=0.5$, $ K_{XZ}=3.0$, $ n_{XZ}=2.0$, $ K_{YZ}=4.0$, $ n_{YZ}=2.0$, $ u_{\\mathrm{amp}}=1.0$, $ T_{\\mathrm{pulse}}=10.0$, $ T_{\\mathrm{end}}=120.0$, $ z_{\\mathrm{thresh}}=0.6$。\n\n您的程序必须实现所推导的ODE模型，对每个案例的两种刺激进行数值积分，并确定每个案例的布尔值“持续性检测”结果。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”），其中每个结果是对应于上述案例的布尔值，并按顺序排列。", "solution": "我们使用基于基因调控核心原理的常微分方程，构建并分析了一个1型相干前馈环。该网络的逻辑如下：物种 $X$ 的合成速率与外部输入 $u(t)$ 成正比，并以一级动力学方式降解；$Y$ 由一个被 $X$ 激活的启动子合成，并以一级动力学方式降解；$Z$ 由一个需要 $X$ 和 $Y$ 共同激活（“与”逻辑）的启动子合成，同样以一级动力学方式降解。\n\n使用的原理：\n\n- 分子生物学中心法则和标准基因调控理论意味着基因产物的合成速率可以建模为启动子活性（占有率）乘以一个最大合成速率。\n- 质量作用降解为每个物种 $S \\in \\{X,Y,Z\\}$ 产生一个线性衰减项 $-\\gamma_S S$，其中衰减常数为 $\\gamma_S$。\n- 对于浓度为 $A$ 的激活剂，结合到一个有 $n$ 个相同有效结合位点、半饱和常数为 $K$ 的启动子上，其启动子占有率遵循Hill函数。这是一个经过充分检验的唯象模型，提供了随 $A$ 增大的平滑饱和激活。\n- 对于两个作为“与”门作用的独立激活剂 $X$ 和 $Y$，它们独立地结合到不同位点，使得两个位点都被占据的联合概率等于它们各自占有率的乘积。\n\nODE模型的推导：\n\n- 物种 $X$：其合成与外部输入 $u(t)$ 成正比，最大速率为 $\\alpha_X$，并以速率 $\\gamma_X X$ 降解。因此\n$$\n\\frac{dX}{dt} = \\alpha_X\\, u(t) - \\gamma_X X.\n$$\n\n- 物种 $Y$：其合成速率通过Hill型激活依赖于 $X$，系数为 $n_{XY}$，半饱和常数为 $K_{XY}$，并按最大速率 $\\alpha_Y$ 进行缩放。其衰减项为 $-\\gamma_Y Y$。因此\n$$\n\\frac{dY}{dt} = \\alpha_Y \\cdot \\frac{X^{n_{XY}}}{K_{XY}^{n_{XY}} + X^{n_{XY}}} - \\gamma_Y Y.\n$$\n\n- 物种 $Z$：其启动子需要 $X$ 和 $Y$。在独立结合和“与”逻辑下，其活性是 $X$ 引起的占有率和 $Y$ 引起的占有率的乘积，两者分别由参数为 $(n_{XZ}, K_{XZ})$ 和 $(n_{YZ}, K_{YZ})$ 的Hill函数表示。设最大速率为 $\\alpha_Z$，衰减项为 $-\\gamma_Z Z$，我们得到\n$$\n\\frac{dZ}{dt} = \\alpha_Z \\cdot \\left( \\frac{X^{n_{XZ}}}{K_{XZ}^{n_{XZ}} + X^{n_{XZ}}} \\right) \\cdot \\left( \\frac{Y^{n_{YZ}}}{K_{YZ}^{n_{YZ}} + Y^{n_{YZ}}} \\right) - \\gamma_Z Z.\n$$\n\n初始条件为 $X(0)=0$，$Y(0)=0$，$Z(0)=0$。\n\n刺激的定义：\n\n- 持续阶跃：对于所有 $t \\ge 0$，$u(t)=u_{\\mathrm{amp}}$。\n- 有限脉冲：对于 $0 \\le t  T_{\\mathrm{pulse}}$，$u(t)=u_{\\mathrm{amp}}$；对于 $t \\ge T_{\\mathrm{pulse}}$，$u(t)=0$。\n\n算法检测标准：\n\n- 对每个参数集，在 $[0, T_{\\mathrm{end}}]$ 上对持续阶跃和有限脉冲两种情况分别对ODE系统进行积分。\n- 对于每次运行，计算 $\\max_{t \\in [0, T_{\\mathrm{end}}]} Z(t)$。\n- 如果 $\\max Z(t) \\ge z_{\\mathrm{thresh}}$，则定义为发生阈值穿越。\n- 如果持续阶跃输入穿越了阈值而有限脉冲输入没有，则定义持续性检测为真。\n\n在具有“与”逻辑整合的1型相干前馈环中实现持续性检测的原理阐述：\n\n- 直接激活通路 $X \\rightarrow Z$ 提供了一个快速输入，而间接通路 $X \\rightarrow Y \\rightarrow Z$ 引入了延迟，因为 $Y$ 必须积累到一定程度后，$Z$ 的启动子才能被完全激活。\n- 对于短脉冲， $X$ 会快速上升和下降，但 $Y$ 没有足够的时间来累积；因此“与”门在很大程度上保持非激活状态，$Z$ 保持在阈值以下。\n- 对于持续输入，$Y$ 会累积起来，并与 $X$ 一起驱动 $Z$ 超过阈值。这就实现了一个持续性检测器，它能拒绝短暂输入，同时接受较长的输入。\n\n数值实现细节：\n\n- 该ODE系统根据参数不同会有一定程度的刚性；一个带有自适应步长的鲁棒显式求解器（例如龙格-库塔法）在给定的时间范围内是足够的。\n- 为可靠地评估阈值穿越，数值解在 $[0, T_{\\mathrmd}]$ 内足够精细的时间网格上进行采样，并计算 $Z(t)$ 的最大值。\n- 测试套件包括4个案例：\n  - 案例1使用较慢的 $Y$ 动力学和相对严格的 $Z$ 门控，使得只有持续阶跃能穿越阈值。\n  - 案例2使用更快且更强的 $Y$ 激活，使得即使是短脉冲也能产生足够的 $Y$，导致有限脉冲穿越阈值；持续性检测应为假。\n  - 案例3使用较低的协同性 ($n=1$) 和更严格的 $Z$ 门控，仍能实现持续性检测行为。\n  - 案例4使用弱的 $Z$ 合成，使得即使是持续阶跃也不会发生阈值穿越；持续性检测应为假。\n\n该实现计算每个案例的布尔结果，并按要求的格式打印单行输出：一个用方括号括起来的、按顺序排列 $[ \\text{案例1}, \\text{案例2}, \\text{案例3}, \\text{案例4} ]$ 的逗号分隔布尔值列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef hill_activation(a, K, n):\n    # Hill activation function a^n / (K^n + a^n)\n    # Ensure non-negativity for numerical robustness\n    a = max(a, 0.0)\n    return (a ** n) / (K ** n + a ** n) if (K > 0) else 1.0\n\ndef and_gate_activity(x, y, Kx, nx, Ky, ny):\n    # Independent binding AND gate: product of two Hill activations\n    return hill_activation(x, Kx, nx) * hill_activation(y, Ky, ny)\n\ndef simulate_case(params, stimulus_type):\n    # Unpack parameters\n    alpha_x = params['alpha_x']\n    gamma_x = params['gamma_x']\n    alpha_y = params['alpha_y']\n    gamma_y = params['gamma_y']\n    K_xy = params['K_xy']\n    n_xy = params['n_xy']\n    alpha_z = params['alpha_z']\n    gamma_z = params['gamma_z']\n    K_xz = params['K_xz']\n    n_xz = params['n_xz']\n    K_yz = params['K_yz']\n    n_yz = params['n_yz']\n    u_amp = params['u_amp']\n    T_pulse = params['T_pulse']\n    T_end = params['T_end']\n\n    # Define input u(t)\n    if stimulus_type == 'step':\n        def u(t):\n            return u_amp\n    elif stimulus_type == 'pulse':\n        def u(t):\n            return u_amp if (t  T_pulse) else 0.0\n    else:\n        raise ValueError(\"Unknown stimulus_type\")\n\n    # ODE system\n    def ode(t, state):\n        X, Y, Z = state\n        dXdt = alpha_x * u(t) - gamma_x * X\n        f_XY = hill_activation(X, K_xy, n_xy)\n        dYdt = alpha_y * f_XY - gamma_y * Y\n        f_AND = and_gate_activity(X, Y, K_xz, n_xz, K_yz, n_yz)\n        dZdt = alpha_z * f_AND - gamma_z * Z\n        return [dXdt, dYdt, dZdt]\n\n    # Initial conditions\n    y0 = [0.0, 0.0, 0.0]\n\n    # Time grid for evaluation\n    dt = 0.05\n    t_eval = np.arange(0.0, T_end + dt, dt)\n\n    # Integrate ODEs\n    sol = solve_ivp(\n        ode,\n        (0.0, T_end),\n        y0,\n        method='RK45',\n        t_eval=t_eval,\n        rtol=1e-7,\n        atol=1e-9\n    )\n\n    # Extract Z over time and compute max\n    Z_traj = sol.y[2]\n    # Numerical safety: clip tiny negatives\n    Z_traj = np.maximum(Z_traj, 0.0)\n    Z_max = float(np.max(Z_traj))\n    return Z_max\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            'alpha_x': 5.0, 'gamma_x': 1.0,\n            'alpha_y': 0.6, 'gamma_y': 0.1, 'K_xy': 3.0, 'n_xy': 2.0,\n            'alpha_z': 1.0, 'gamma_z': 0.5, 'K_xz': 3.0, 'n_xz': 2.0, 'K_yz': 4.0, 'n_yz': 2.0,\n            'u_amp': 1.0, 'T_pulse': 10.0, 'T_end': 120.0, 'z_thresh': 0.6\n        },\n        # Case 2\n        {\n            'alpha_x': 5.0, 'gamma_x': 1.0,\n            'alpha_y': 3.0, 'gamma_y': 0.5, 'K_xy': 1.0, 'n_xy': 2.0,\n            'alpha_z': 1.0, 'gamma_z': 0.5, 'K_xz': 1.0, 'n_xz': 2.0, 'K_yz': 1.0, 'n_yz': 2.0,\n            'u_amp': 1.0, 'T_pulse': 10.0, 'T_end': 60.0, 'z_thresh': 0.6\n        },\n        # Case 3\n        {\n            'alpha_x': 5.0, 'gamma_x': 1.0,\n            'alpha_y': 0.4, 'gamma_y': 0.1, 'K_xy': 3.0, 'n_xy': 1.0,\n            'alpha_z': 1.0, 'gamma_z': 0.5, 'K_xz': 3.0, 'n_xz': 1.0, 'K_yz': 3.0, 'n_yz': 1.0,\n            'u_amp': 1.0, 'T_pulse': 6.0, 'T_end': 120.0, 'z_thresh': 0.5\n        },\n        # Case 4\n        {\n            'alpha_x': 5.0, 'gamma_x': 1.0,\n            'alpha_y': 0.6, 'gamma_y': 0.1, 'K_xy': 3.0, 'n_xy': 2.0,\n            'alpha_z': 0.2, 'gamma_z': 0.5, 'K_xz': 3.0, 'n_xz': 2.0, 'K_yz': 4.0, 'n_yz': 2.0,\n            'u_amp': 1.0, 'T_pulse': 10.0, 'T_end': 120.0, 'z_thresh': 0.6\n        },\n    ]\n\n    results = []\n    for params in test_cases:\n        # Simulate sustained step\n        Zmax_step = simulate_case(params, 'step')\n        # Simulate finite pulse\n        Zmax_pulse = simulate_case(params, 'pulse')\n        # Threshold crossing checks\n        z_thresh = params['z_thresh']\n        crossed_step = Zmax_step >= z_thresh\n        crossed_pulse = Zmax_pulse >= z_thresh\n        # Persistence detection: step crosses AND pulse does not\n        result = (crossed_step and (not crossed_pulse))\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2956867"}]}