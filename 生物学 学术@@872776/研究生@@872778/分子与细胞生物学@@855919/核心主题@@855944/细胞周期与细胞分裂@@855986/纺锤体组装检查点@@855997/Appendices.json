{"hands_on_practices": [{"introduction": "细胞生物学的一个核心辩论是，纺锤体组装检查点 (SAC) 信号是由动粒-微管未连接触发，还是由已连接但缺乏张力的动粒触发。设计严谨的实验来区分这些相互竞争的假说是分子细胞生物学家的基本功。本练习将引导你思考如何利用药物扰动和荧光成像来解决这一关键问题。[@problem_id:2964907]", "problem": "纺锤体组装检验点 (SAC) 的一个核心争论是，SAC信号通路是由缺乏端向的着丝粒-微管附着严格触发，还是在已附着的着丝粒上降低的着丝粒间张力可以独立维持检验点信号。你将通过结合抑制单极纺锤体激酶1 (Mps1)和低剂量紫杉醇 (taxol) 的方法，并通过量化着丝粒上的有丝分裂停滞缺陷蛋白2 (Mad2) 水平来探究这个问题。请将以下经过充分检验的事实作为你的出发点：(i) SAC会延迟后期（anaphase），直到所有着丝粒都正确附着到纺锤体微管上；(ii) 未附着的着丝粒会招募Mad1–Mad2并催化有丝分裂检验点复合物的形成，该复合物会抑制后期促进复合物/细胞周期蛋白体 (APC/C)；(iii) Mps1磷酸化着丝粒空蛋白1 (KNL1) 的MELT基序，以招募苯并咪唑不抑制出芽蛋白1 (Bub1) 和BubR1，这些蛋白位于Mad1–Mad2到着丝粒加载过程的上游；(iv) 低浓度的taxol能稳定微管并降低着丝粒张力，同时通常能保持端向附着；(v) 诺考达唑（nocodazole）会使微管解聚，并产生未附着的着丝粒；以及(vi) 急性抑制Mps1可通过阻止KNL1的MELT基序磷酸化来移除着丝粒上的Mad1–Mad2。\n\n你将在人类培养细胞中，在不同扰动条件下，测量经着丝粒标记物强度 (CREST) 归一化后的着丝粒Mad2荧光强度。对照组必须能区分附着丧失和张力降低。你选择的任何扰动都应在有丝分裂细胞中急性施加（大约10–60分钟），以避免混杂的转录效应。\n\n以下哪个选项提出的实验设计能够清晰地区分依赖附着的SAC信号和依赖张力的SAC信号，并对每种条件下着丝粒Mad2的水平给出了正确的定性预测？\n\nA. 设计：将细胞同步化至有丝分裂期，然后分为四组：二甲基亚砜 (DMSO) 溶剂对照组；低剂量taxol ($10$ nM) 处理$30$分钟；诺考达唑 ($3.3$ $\\mu$M) 处理$30$分钟；以及低剂量taxol ($10$ nM) 与Mps1抑制剂瑞佛星 (reversine) ($250$ nM) 联用$20$–$30$分钟（包括一个单独使用瑞佛星的平行组）。测量着丝粒Mad2/CREST。预测：DMSO（中期）显示低Mad2水平；taxol（张力降低，附着保持）显示同样低的Mad2水平；诺考达唑（未附着）显示高Mad2水平；瑞佛星能急性抑制所有组中的Mad2，包括诺考达唑处理组。解释：如果taxol不提高Mad2水平，则SAC是依赖附着的，而非依赖张力。\n\nB. 设计：用$250$ nM的瑞佛星预处理有丝分裂细胞$30$分钟，然后加入$10$ nM的低剂量taxol处理$30$分钟，并评估着丝粒Mad2/CREST。预测：尽管Mps1被抑制，taxol仍会相对于DMSO增加着丝粒的Mad2水平，这表明存在一个不依赖于Mps1的、依赖张力的SAC分支。\n\nC. 设计：向非同步培养的细胞中加入$10$ nM的低剂量taxol处理$30$分钟，以在染色体捕获期间降低张力，然后用亚饱和剂量的瑞佛星（$50$ nM）洗涤$30$分钟，以部分抑制Mps1。预测：与DMSO相比，taxol提高了着丝粒的Mad22水平，并且这种升高在部分抑制Mps1后仍然存在，表明存在不需完全Mps1活性的、依赖张力的SAC信号。\n\nD. 设计：为最大化对张力的敏感性，用$1$ $\\mu$M的高剂量taxol处理有丝分裂细胞$60$分钟，然后加入$250$ nM的瑞佛星处理$15$分钟，并量化着丝粒Mad2/CREST。预测：高剂量taxol由于张力丧失但附着得以保持，会强烈提高大多数着丝粒上的Mad2水平，而瑞佛星对Mad2影响甚微，因为张力而非Mps1是主导输入。\n\n选择唯一最佳选项。", "solution": "### 推理过程\n\n核心目标是设计一个能够区分以下两种假说的实验：\n*   **假说1（仅依赖附着）：** SAC信号（通过动粒上的Mad2水平测量）仅由未附着的动粒产生。已附着动粒上的张力降低不会产生信号。\n*   **假说2（感知张力）：** 已附着动粒上的张力降低足以产生或维持SAC信号。\n\n一个严谨的实验设计必须包含能够选择性地探测这些触发因素并控制混杂变量的条件。根据已知条件：\n*   **基线对照：** 使用溶剂（如DMSO）处理的有丝分裂细胞群体，主要处于中期，应表现出较低的动粒Mad2水平，因为大多数动粒已附着并处于张力之下。\n*   **未附着对照：** 诺考达唑处理（事实v）使微管解聚，产生未附着的动粒。这应作为阳性对照，导致高水平的动粒Mad2（事实ii）。\n*   **张力测试：** 低剂量taxol（事实iv）在保持附着的同时降低张力。这是关键的实验条件。\n    *   如果假说1正确，低剂量taxol应导致与DMSO对照组相似的低Mad2水平。\n    *   如果假说2正确，低剂量taxol应导致Mad2水平升高。\n*   **通路依赖性测试：** Mps1激酶被描述为Mad2招募的上游（事实iii, vi）。根据提供的事实，任何真正的SAC信号，无论是因未附着还是因张力触发，都应依赖于Mps1的活性。因此，Mps1抑制剂（如瑞佛星）应能消除所有Mad2信号阳性条件下的Mad2定位。这是一个关键的对照，用于验证任何观察到的信号都是通过经典的SAC通路传导的。\n\n因此，一个清晰的实验设计必须比较用(1)DMSO、(2)诺考达唑、(3)低剂量taxol处理的细胞中的Mad2水平，并且必须使用Mps1抑制剂来验证任何观察到的Mad2信号对Mps1的依赖性。\n\n### 选项分析\n\n**A. 设计：... 预测：... 解释：...**\n*   **设计分析：** 这个实验设计非常出色。它使用了同步化的有丝分裂细胞，保证了结果的清晰性。它包括一个溶剂对照（DMSO），一个未附着的阳性对照（诺考达唑），一个测试张力的关键条件（低剂量taxol），以及一个使用瑞佛星测试Mps1依赖性的关键对照。建议的浓度和急性处理时间都是合适的。这个设计是全面的，并直接解决了问题。\n*   **预测分析：** 预测与前提和其中一个主要假说是逻辑上一致的。预测低剂量taxol显示低Mad2水平，是“仅依赖附着”假说为真时的预期结果。实验的目的就是为了检验这一预测。预测瑞佛星在所有信号条件下（包括诺考达唑诱导的条件）都能抑制Mad2，是事实(vi)的直接应用，并作为一个至关重要的通路对照。\n*   **解释分析：** 解释是正确的。如果实验结果显示，与DMSO相比，taxol不升高Mad2水平，而诺考达唑能升高，这将提供强有力的证据，表明缺乏附着而非缺乏张力是主要的触发因素。\n*   **结论：** **正确**。该选项提出了一个逻辑上合理、严谨且清晰的实验设计，其预测一致，解释框架正确。\n\n**B. 设计：... 预测：...**\n*   **设计分析：** 该设计存在缺陷。用Mps1抑制剂（瑞佛星）预处理会从一开始就阻断SAC通路（事实iii）。根据事实(vi)，这会从动粒上移除Mad2。在抑制Mps1 *之后* 再施加taxol，使得检测任何taxol可能诱导的Mps1依赖性信号变得不可能。\n*   **预测分析：** 预测taxol *尽管* Mps1被抑制仍会增加Mad2水平，这直接与事实(iii)和(vi)相矛盾，这两个事实确立了Mad2招募对Mps1的依赖性。在给定的前提中，没有依据支持存在一个不依赖Mps1的通路。\n*   **结论：** **不正确**。实验设计不合逻辑，预测违反了给定的前提。\n\n**C. 设计：... 预测：...**\n*   **设计分析：** 该设计有两个主要弱点，妨碍了获得“清晰”的结果。首先，使用非同步培养物会引入显著的变异性，因为细胞会处于不同的细胞周期阶段。问题正确地指定了使用有丝分裂细胞。其次，使用“亚饱和剂量”的抑制剂会产生模棱两可的结果。Mad2的部分减少无法区分一个部分依赖Mps1的通路和一个完全依赖但被部分抑制的通路。为了进行清晰的依赖性测试，应使用完全有效的抑制剂浓度。\n*   **预测分析：** 预测在部分抑制后信号仍然存在，这导致了一个薄弱的结论。它没有清晰地剖析通路的依赖性。\n*   **结论：** **不正确**。由于使用了非同步细胞和部分抑制，该实验设计不清不楚也不严谨。\n\n**D. 设计：... 预测：...**\n*   **设计分析：** 该设计有缺陷。事实(iv)指明“低浓度”的taxol在保持附着的同时降低张力。高浓度（例如$1$ $\\mu$M）已知会导致严重的纺锤体异常和广泛的微管缺陷，从而导致真正的附着错误。这将实验本应区分的两个变量——附着和张力——混淆在一起。\n*   **预测分析：** 预测瑞佛星对Mad2“影响甚微”直接与事实(iii)和(vi)相矛盾。已知条件建立了一个清晰的、分层的通路，其中Mps1是Mad2招募所必需的。该预测假设了一个独立于Mps1运行的新通路，而问题陈述中没有提供任何证据支持这一点。\n*   **结论：** **不正确**。该设计未能分离出感兴趣的变量（张力），并且预测与提供的关于SAC通路的基本事实相矛盾。", "answer": "$$\\boxed{A}$$", "id": "2964907"}, {"introduction": "从信号的触发转到信号的执行，SAC 的最终目的是产生有丝分裂检查点复合物 (MCC) 来抑制后期促进复合物/细胞周期蛋白体 (APC/C)。这个练习将运用化学平衡的基本原理，对这一关键的抑制性结合事件进行定量建模。通过这个练习，你将学会如何计算检查点强度如何转化为对 APC/C 的抑制，并最终决定细胞进入后期的时机。[@problem_id:2964927]", "problem": "在一个简化的纺锤体组装检验点模型中，有丝分裂检验点复合体 (MCC) 会结合并抑制后期促进复合物/细胞周期蛋白体 (APC/C)。假设每个 APC/C 有一个结合位点，且抑制的化学计量比为 $1:1$。该结合反应在平衡状态下遵循质量作用定律：\n$$\\mathrm{APC/C} + \\mathrm{MCC} \\rightleftharpoons \\mathrm{APC/C{:}MCC},$$\n其解离常数定义为\n$$K_d = \\frac{[\\mathrm{APC/C}]_{\\mathrm{free}} \\,[\\mathrm{MCC}]_{\\mathrm{free}}}{[\\mathrm{APC/C{:}MCC}]}.$$\n给定以下实验测量和控制的量：MCC–APC/C 的解离常数为 $K_d = 12\\,\\mathrm{nM}$，APC/C 的总浓度为 $[\\mathrm{APC/C}]_{\\mathrm{tot}} = 40\\,\\mathrm{nM}$。在一组检验点停滞的细胞中，MCC 的总浓度 $[\\mathrm{MCC}]_{\\mathrm{tot}}$ 分别在 $5\\,\\mathrm{nM}$、$12\\,\\mathrm{nM}$、$40\\,\\mathrm{nM}$ 和 $80\\,\\mathrm{nM}$ 之间变化。假设与 MCC 结合的 APC/C 对后期底物没有催化活性，并且其他调节因子的影响可以忽略不计。\n\n仅使用平衡质量作用原理和质量守恒，首先针对每个给定的 $[\\mathrm{MCC}]_{\\mathrm{tot}}$，确定被抑制的 APC/C 的比例（即在复合物 $\\mathrm{APC/C{:}MCC}$ 中结合的比例）。然后，假定在底物饱和的情况下，后期起始需要游离 APC/C 的比例达到阈值 $f_{\\mathrm{free}}^\\ast = 0.30$，推导出一个解析表达式，用于计算在平衡时能使 $f_{\\mathrm{free}} = f_{\\mathrm{free}}^\\ast$ 的阈值总 MCC 浓度 $[\\mathrm{MCC}]_{\\mathrm{tot}}^\\ast$，并使用所提供的数据计算其值。\n\n将您的最终答案表示为以 $\\mathrm{nM}$ 为单位的阈值总 MCC 浓度，并四舍五入到三位有效数字。最终答案必须是一个实数。", "solution": "该问题陈述有效。这是一个自洽、适定（well-posed）的问题，基于化学平衡（质量作用定律）和质量守恒的基本原理，并应用于一个简化但具有生物学意义的纺锤体组装检验点模型。所有参数都定义清晰，并具有物理上合理的值。\n\n首先，我们定义相关物质的浓度。设 $[\\mathrm{APC/C}]_{\\mathrm{tot}}$ 和 $[\\mathrm{MCC}]_{\\mathrm{tot}}$ 分别为 APC/C 和 MCC 的总浓度。设 $[\\mathrm{APC/C}]_{\\mathrm{free}}$、$[\\mathrm{MCC}]_{\\mathrm{free}}$ 和 $[\\mathrm{APC/C{:}MCC}]$ 分别为游离 APC/C、游离 MCC 和被抑制复合物的平衡浓度。为简洁起见，我们将其表示为 $A_{t}$、$M_{t}$、$A_{f}$、$M_{f}$ 和 $C$。\n\n该系统受两个原理支配：\n1. 每个组分的质量守恒：\n$$A_{t} = A_{f} + C$$\n$$M_{t} = M_{f} + C$$\n\n2. 平衡时的质量作用定律，由解离常数 $K_{d}$ 表征：\n$$K_{d} = \\frac{A_{f} M_{f}}{C}$$\n\n给定 $K_{d} = 12\\,\\mathrm{nM}$ 和 $A_{t} = 40\\,\\mathrm{nM}$。\n\n首先，我们必须推导复合物浓度 $C$ 的表达式，该表达式是总浓度 $A_{t}$、$M_{t}$ 和解离常数 $K_{d}$ 的函数。我们使用质量守恒方程，用 $C$ 来表示游离浓度：\n$$A_{f} = A_{t} - C$$\n$$M_{f} = M_{t} - C$$\n将这些代入 $K_{d}$ 的表达式中：\n$$K_{d} = \\frac{(A_{t} - C)(M_{t} - C)}{C}$$\n重新整理该方程，得到一个关于 $C$ 的二次方程：\n$$K_{d} C = A_{t}M_{t} - A_{t}C - M_{t}C + C^2$$\n$$C^2 - (A_{t} + M_{t} + K_{d})C + A_{t}M_{t} = 0$$\n该方程的形式为 $ax^2 + bx + c = 0$，其中 $x=C$，$a=1$，$b=-(A_{t} + M_{t} + K_{d})$，$c=A_{t}M_{t}$。其解由二次方程求根公式给出：\n$$C = \\frac{(A_{t} + M_{t} + K_{d}) \\pm \\sqrt{(A_{t} + M_{t} + K_{d})^2 - 4A_{t}M_{t}}}{2}$$\n复合物的浓度 $C$ 不能超过任一反应物的总浓度，即 $C \\le A_{t}$ 且 $C \\le M_{t}$。这个物理约束要求我们选择解的负根。正根会得出一个非物理的结果，即复合物的浓度大于反应物的总可用量。\n因此，物理上正确的解是：\n$$C = \\frac{(A_{t} + M_{t} + K_{d}) - \\sqrt{(A_{t} + M_{t} + K_{d})^2 - 4A_{t}M_{t}}}{2}$$\n被抑制的 APC/C 的比例由 $f_{\\mathrm{inhibited}} = \\frac{C}{A_{t}}$ 给出。我们省略了针对每个 $M_t$ 值的详细计算，因为问题最终只要求计算阈值浓度。\n\n接下来，我们必须推导后期起始所需的阈值总 MCC 浓度 $[ \\mathrm{MCC}]_{\\mathrm{tot}}^{\\ast}$（或 $M_{t}^{\\ast}$）的解析表达式。后期起始的条件是游离 APC/C 的比例达到阈值 $f_{\\mathrm{free}}^{\\ast} = 0.30$。\n让我们用上标 `$\\ast$` 表示此阈值下的浓度。\n游离 APC/C 的比例定义为 $f_{\\mathrm{free}} = \\frac{A_{f}}{A_{t}}$。\n阈值条件是 $\\frac{A_{f}^{\\ast}}{A_{t}} = f_{\\mathrm{free}}^{\\ast}$。\n由此，我们得到阈值下游离 APC/C 的浓度：\n$$A_{f}^{\\ast} = f_{\\mathrm{free}}^{\\ast} A_{t}$$\n使用 APC/C 的质量守恒，我们可以找到阈值下复合物的浓度：\n$$C^{\\ast} = A_{t} - A_{f}^{\\ast} = A_{t} - f_{\\mathrm{free}}^{\\ast} A_{t} = (1 - f_{\\mathrm{free}}^{\\ast}) A_{t}$$\n现在我们使用平衡条件来找到阈值下游离 MCC 的浓度 $M_{f}^{\\ast}$：\n$$K_{d} = \\frac{A_{f}^{\\ast} M_{f}^{\\ast}}{C^{\\ast}} \\implies M_{f}^{\\ast} = K_{d} \\frac{C^{\\ast}}{A_{f}^{\\ast}}$$\n代入 $A_f^{\\ast}$ 和 $C^{\\ast}$ 的表达式：\n$$M_{f}^{\\ast} = K_{d} \\frac{(1 - f_{\\mathrm{free}}^{\\ast}) A_{t}}{f_{\\mathrm{free}}^{\\ast} A_{t}} = K_{d} \\frac{1 - f_{\\mathrm{free}}^{\\ast}}{f_{\\mathrm{free}}^{\\ast}}$$\n最后，我们使用 MCC 的质量守恒来找到阈值下的总 MCC 浓度 $M_{t}^{\\ast}$：\n$$M_{t}^{\\ast} = M_{f}^{\\ast} + C^{\\ast}$$\n代入推导出的 $M_{f}^{\\ast}$ 和 $C^{\\ast}$ 的表达式，得到最终的解析表达式：\n$$M_{t}^{\\ast} = K_{d} \\frac{1 - f_{\\mathrm{free}}^{\\ast}}{f_{\\mathrm{free}}^{\\ast}} + (1 - f_{\\mathrm{free}}^{\\ast}) A_{t}$$\n这就是所要求的解析表达式。现在，我们使用给定的数据计算其数值：$K_{d} = 12\\,\\mathrm{nM}$，$A_{t} = 40\\,\\mathrm{nM}$，以及 $f_{\\mathrm{free}}^{\\ast} = 0.30$。\n$$M_{t}^{\\ast} = (12\\,\\mathrm{nM}) \\frac{1 - 0.30}{0.30} + (1 - 0.30)(40\\,\\mathrm{nM})$$\n$$M_{t}^{\\ast} = (12\\,\\mathrm{nM}) \\frac{0.70}{0.30} + (0.70)(40\\,\\mathrm{nM})$$\n$$M_{t}^{\\ast} = 12 \\left(\\frac{7}{3}\\right)\\,\\mathrm{nM} + 28\\,\\mathrm{nM}$$\n$$M_{t}^{\\ast} = 28\\,\\mathrm{nM} + 28\\,\\mathrm{nM} = 56\\,\\mathrm{nM}$$\n问题要求将结果四舍五入到三位有效数字。在本例中，结果恰好是 $56$，所以为了用三位有效数字表示，我们写作 $56.0$。", "answer": "$$\\boxed{56.0}$$", "id": "2964927"}, {"introduction": "为了更全面地理解 SAC，我们需要将其视为一个具有复杂反馈回路的动态系统，而不仅仅是一个简单的开关。这个高级练习要求你使用常微分方程 (ODE) 构建一个更详尽的动力学模型，以捕捉多个关键蛋白之间的相互作用。通过分析该模型，你将能够揭示像双稳态这样的涌现特性，这对于细胞周期中稳健的、开关般的决策至关重要。[@problem_id:2964886]", "problem": "构建一个五维常微分方程模型，用于描述纺锤体组装检验点的生物化学过程，该模型需捕捉开放构象的Mad2 (O-Mad2)、与Cdc20结合的闭合构象Mad2 (C-Mad2:Cdc20)、游离Cdc20、有丝分裂检验点复合物 (MCC) 以及与MCC结合的后期促进复合物/细胞周期蛋白体 (APC/C–MCC) 之间的相互作用。目标是利用质量作用动力学和守恒定律的第一性原理来推导动力学方程，然后进行稳态和稳定性分析，以检测作为参数函数的双稳态性。您的程序必须为每组给定的参数集，计算由总浓度定义的化学计量相容类中不同渐近稳定稳态的数量。\n\n定义和假设：\n- 变量是以下物种的浓度：O-Mad2 ($O$)、与Cdc20结合的闭合构象Mad2 ($C$)、游离Cdc20 ($D$)、有丝分裂检验点复合物 ($M$) 和APC/C–MCC复合物 ($A$)。游离APC/C的浓度为 $A_{\\mathrm{free}} = A_{\\mathrm{tot}} - A$。\n- 总量因化学计量而守恒：Mad2总浓度 $T_{\\mathrm{Mad2}} = O + C + M + A$，Cdc20总浓度 $T_{\\mathrm{Cdc20}} = D + C + M + A$，以及APC/C总浓度 $A_{\\mathrm{tot}} = A + A_{\\mathrm{free}}$。\n- 反应和速率（均遵循质量作用动力学）：\n  1. O-Mad2加Cdc20在模板辅助和基础条件下转化为与Cdc20结合的闭合构象Mad2：$O + D \\rightarrow C$，速率为 $v_{1f} = (k_t S + k_{c0}) \\, O \\, D$。其中 $S$ 是一个无量纲的信号强度，代表未附着动粒的信号。\n  2. 闭合构象的Mad2:Cdc20重新打开为O-Mad2加Cdc20，包含基础项和APC/C辅助项：$C \\rightarrow O + D$，速率为 $v_{1r} = (k_{o0} + k_{\\mathrm{apc}} A_{\\mathrm{free}})\\, C$。\n  3. 由 $C$（闭合构象Mad2:Cdc20）组装MCC，速率为 $v_{3f} = k_{m\\_on} \\, C$；以及MCC的解体，包含基础项和APC/C辅助项，速率为 $v_{3r} = (k_{m\\_off} + k_{m\\_apc} \\, A_{\\mathrm{free}})\\, M$。\n  4. MCC与APC/C结合形成APC/C–MCC：$M + A_{\\mathrm{free}} \\rightleftharpoons A$，正向速率为 $v_{4f} = k_{a\\_on} \\, M \\, A_{\\mathrm{free}}$，逆向速率为 $v_{4r} = k_{a\\_off}\\, A$。\n\n由此，动力学系统为\n- $ \\dfrac{dO}{dt} = - v_{1f} + v_{1r}$，\n- $ \\dfrac{dC}{dt} = + v_{1f} - v_{1r} - v_{3f} + v_{3r}$，\n- $ \\dfrac{dD}{dt} = - v_{1f} + v_{1r}$，\n- $ \\dfrac{dM}{dt} = + v_{3f} - v_{3r} - v_{4f} + v_{4r}$，\n- $ \\dfrac{dA}{dt} = + v_{4f} - v_{4r}$，\n其中 $A_{\\mathrm{free}} = A_{\\mathrm{tot}} - A$，且所有 $v_{\\cdot}$ 如上文所定义。\n\n使用的基本原理：\n- 反应速率的质量作用定律。\n- $T_{\\mathrm{Mad2}}$、$T_{\\mathrm{Cdc20}}$ 和 $A_{\\mathrm{tot}}$ 的质量守恒。\n- 稳态的定义：$ \\dfrac{d}{dt} \\boldsymbol{x} = \\boldsymbol{0}$。\n- 平滑动力学下稳态的线性稳定性：投影到化学计量子空间上的雅可比矩阵的所有特征值的实部必须严格为负。\n\n您的程序必须为每个参数集执行的计算任务：\n1. 遵循守恒关系，将初始条件限制在由 $T_{\\mathrm{Mad2}}$、$T_{\\mathrm{Cdc20}}$ 和 $A_{\\mathrm{tot}}$ 指定的相容类中。生成一组多样化的初始条件，跨越极端角落和随机分割，满足 $O \\ge 0$, $C \\ge 0$, $M \\ge 0$, $A \\ge 0$, $A \\le A_{\\mathrm{tot}}$, $O + C + M + A = T_{\\mathrm{Mad2}}$ 和 $D = T_{\\mathrm{Cdc20}} - (C + M + A) \\ge 0$。\n2. 对每个初始条件，将常微分方程随时间向前积分，直到右侧项的范数低于一个小的阈值，或达到足够大的时间上限，以近似一个吸引稳态。\n3. 对终点进行聚类，以在简化坐标 $(O,C,M)$ 的容差范围内识别不同的稳态。\n4. 对每个不同的稳态，通过求解化学计量子空间上的简化稳态方程来精确化稳态，并计算限制在该子空间上的雅可比矩阵（例如，通过使用 $A = T_{\\mathrm{Mad2}} - O - C - M$ 和 $D = T_{\\mathrm{Cdc20}} - T_{\\mathrm{Mad2}} + O$ 来消除 $A$ 和 $D$）。如果简化雅可比矩阵的所有特征值的实部都严格为负，则将该稳态分类为渐近稳定。\n5. 为每个参数集报告在该相容类中不同的渐近稳定稳态的数量。\n\n测试套件：\n提供以下四组参数集 $(A_{\\mathrm{tot}}, T_{\\mathrm{Mad2}}, T_{\\mathrm{Cdc20}}, S, \\sigma)$，其中 $\\sigma$ 按一个共同因子缩放APC/C辅助速率 $k_{\\mathrm{apc}}$ 和 $k_{m\\_apc}$。其余参数在所有案例中共享。\n\n- 共享参数：\n  - $k_t = 8.0$，\n  - $k_{c0} = 0.01$，\n  - $k_{o0} = 0.02$，\n  - $k_{\\mathrm{apc}}^{\\ast} = 4.0$，\n  - $k_{m\\_on} = 1.0$，\n  - $k_{m\\_off} = 0.02$，\n  - $k_{m\\_apc}^{\\ast} = 4.0$，\n  - $k_{a\\_on} = 10.0$，\n  - $k_{a\\_off} = 0.005$。\n  每个案例中使用的实际值为 $k_{\\mathrm{apc}} = \\sigma \\, k_{\\mathrm{apc}}^{\\ast}$ 和 $k_{m\\_apc} = \\sigma \\, k_{m\\_apc}^{\\ast}$。\n\n- 案例1（低信号）：$(A_{\\mathrm{tot}}, T_{\\mathrm{Mad2}}, T_{\\mathrm{Cdc20}}, S, \\sigma) = (1.0, 2.0, 1.5, 0.0, 1.0)$。\n- 案例2（中等信号，强APC/C反馈）：$(A_{\\mathrm{tot}}, T_{\\mathrm{Mad2}}, T_{\\mathrm{Cdc20}}, S, \\sigma) = (0.3, 2.0, 1.5, 0.45, 3.0)$。\n- 案例3（近阈值信号，强APC/C反馈）：$(A_{\\mathrm{tot}}, T_{\\mathrm{Mad2}}, T_{\\mathrm{Cdc20}}, S, \\sigma) = (0.3, 2.0, 1.5, 0.40, 3.0)$。\n- 案例4（高信号）：$(A_{\\mathrm{tot}}, T_{\\mathrm{Mad2}}, T_{\\mathrm{Cdc20}}, S, \\sigma) = (1.0, 4.0, 3.0, 1.2, 1.0)$。\n\n最终输出格式：\n- 对于上述四个案例，您的程序必须输出一行，其中包含一个Python风格的列表，内含四个整数 $[n_1,n_2,n_3,n_4]$，其中 $n_i$ 是为案例 $i$ 找到的不同渐近稳定稳态的数量。不需要单位，也不涉及角度。该行必须只包含此列表，不得有任何额外文本。\n\n您的程序必须是一个完整的、可运行的实现，能够执行上述任务并生成所需的输出行。它不得读取任何输入。", "solution": "该问题陈述有效。它在分子系统生物学领域提出了一个具有科学依据、适定且计算上可行的问​​题。该模型基于质量作用动力学和守恒定律的既定原则。定义清晰，参数已提供，目标明确。\n\n### 1. 通过守恒定律进行系统降维\n\n这个五维系统受到两个独立的守恒定律约束，这将动力学行为限制在一个三维的化学计量相容类中。这使我们能够降低系统维度以便分析。\n\nMad2和Cdc20的总浓度是守恒的：\n$$\nT_{\\mathrm{Mad2}} = O + C + M + A \\\\\nT_{\\mathrm{Cdc20}} = D + C + M + A\n$$\n由此，我们可以用我们选择的独立状态变量 $\\boldsymbol{x} = (O, C, M)^T$ 来表示 $A$ 和 $D$ 的浓度：\n$$\nA = T_{\\mathrm{Mad2}} - O - C - M\n$$\n$$\nD = T_{\\mathrm{Cdc20}} - (C + M + A) = T_{\\mathrm{Cdc20}} - (C + M + (T_{\\mathrm{Mad2}} - O - C - M)) = T_{\\mathrm{Cdc20}} - T_{\\mathrm{Mad2}} + O\n$$\n游离APC/C的浓度 $A_{\\mathrm{free}}$ 由第三个关于APC/C总浓度 $A_{\\mathrm{tot}}$ 的守恒定律给出：\n$$\nA_{\\mathrm{free}} = A_{\\mathrm{tot}} - A = A_{\\mathrm{tot}} - (T_{\\mathrm{Mad2}} - O - C - M)\n$$\n为了使一个状态在物理上是现实的，所有浓度都必须为非负。这对向量 $(O, C, M)$ 施加了以下约束：\n1. $O \\ge 0$, $C \\ge 0$, $M \\ge 0$\n2. $A \\ge 0 \\implies O + C + M \\le T_{\\mathrm{Mad2}}$\n3. $D \\ge 0 \\implies O \\ge T_{\\mathrm{Mad2}} - T_{\\mathrm{Cdc20}}$\n4. $A_{\\mathrm{free}} \\ge 0 \\implies A \\le A_{\\mathrm{tot}} \\implies O + C + M \\ge T_{\\mathrm{Mad2}} - A_{\\mathrm{tot}}$\n\n这些不等式在三维状态空间中定义了一个凸多胞体，它代表了在给定总浓度下所有物理上可实现的状态集合。\n\n### 2. 降维后的动力学系统\n\n系统的动力学可以用我们选择的独立变量 $(O, C, M)$ 的一组三个ODE来描述。这些方程的右侧项 $\\boldsymbol{f}(\\boldsymbol{x})$ 是根据问题陈述中给出的反应速率推导出来的。\n反应速率如下：\n- $v_{1f} = (k_t S + k_{c0}) \\, O \\, D$\n- $v_{1r} = (k_{o0} + k_{\\mathrm{apc}} (A_{\\mathrm{tot}} - A))\\, C$\n- $v_{3f} = k_{m\\_on} \\, C$\n- $v_{3r} = (k_{m\\_off} + k_{m\\_apc} (A_{\\mathrm{tot}} - A))\\, M$\n- $v_{4f} = k_{a\\_on} \\, M \\, (A_{\\mathrm{tot}} - A)$\n- $v_{4r} = k_{a\\_off}\\, A$\n\n降维后的ODE系统是：\n$$\n\\frac{dO}{dt} = f_1(O,C,M) = -v_{1f} + v_{1r} \\\\\n\\frac{dC}{dt} = f_2(O,C,M) = v_{1f} - v_{1r} - v_{3f} + v_{3r} \\\\\n\\fracdM}{dt} = f_3(O,C,M) = v_{3f} - v_{3r} - v_{4f} + v_{4r}\n$$\n在这些方程中，$A$ 和 $D$ 使用从守恒定律推导出的表达式进行代换。\n\n### 3. 稳态与稳定性分析\n\n稳态 $\\boldsymbol{x}^* = (O^*, C^*, M^*)^T$ 是系统动力学停止的点，即时间导数为零的点：\n$$\n\\boldsymbol{f}(\\boldsymbol{x}^*) = \\boldsymbol{0}\n$$\n稳态的稳定性由系统在小扰动下的行为决定。对于一个平滑的动力学系统，这通过在稳态点对系统进行线性化来分析。局部动力学由雅可比矩阵 $J$ 控制：\n$$\nJ_{ij}(\\boldsymbol{x}^*) = \\left. \\frac{\\partial f_i}{\\partial x_j} \\right|_{\\boldsymbol{x}=\\boldsymbol{x}^*}\n$$\n一个稳态 $\\boldsymbol{x}^*$ 被认为是**渐近稳定**的，当且仅当其雅可比矩阵 $J(\\boldsymbol{x}^*)$ 的所有特征值的实部都严格为负。这确保了任何对稳态的微小扰动都会随时间衰减，使系统返回到 $\\boldsymbol{x}^*$。\n\n### 4. 计算策略\n\n为了找到所有渐近稳定的稳态，我们对每个给定的参数集采用一种数值搜索策略。\n1.  **生成初始条件：** 我们生成一组多样的初始点 $(O_0, C_0, M_0)$，保证它们位于由非负约束定义的物理有效多胞体内。这是通过在边界框内生成随机点并根据多胞体约束进行筛选来实现的，并辅以该框角落的点以确保边界区域得到探索。\n2.  **时间积分：** 对于每个初始条件，我们使用稳健的数值求解器（`scipy.integrate.solve_ivp`，使用适用于潜在刚性系统的'BDF'方法）对降维后的三维ODE系统进行时间上的前向积分。积分进行足够长的时间，以使系统稳定到一个吸引子（稳态、极限环或混沌吸引子）。我们感兴趣的是稳态吸引子。\n3.  **聚类吸引子：** 收集所有初始条件得到的轨迹终点。然后根据欧几里得距离对这些点进行聚类，以识别唯一的潜在稳态。使用一个小的容差来对数值上接近的点进行分组。\n4.  **精化与验证：** 每个唯一的聚类中心作为高精度数值求根算法（`scipy.optimize.root`）的初始猜测值。这通过求解 $\\boldsymbol{f}(\\boldsymbol{x}) = \\boldsymbol{0}$ 至一个严格的容差来精化稳态的位置。对每个得到的精化稳态进行检查，以确保它对应于一个物理上有效的状态（所有浓度非负）。\n5.  **稳定性分析：** 对于每个有效的、精化后的稳态，我们使用中心差分格式数值计算 $3 \\times 3$ 的雅可比矩阵。然后我们计算其特征值。如果所有特征值的实部都严格为负，则该稳态被分类为渐近稳定。\n6.  **计数稳定状态：** 为每个参数案例报告唯一的、物理上有效的、渐近稳定的稳态的最终数量。存在多个此类状态表示存在双稳态或多稳态。\n\n这个系统化的程序确保了对系统状态空间的彻底探索，并提供了问题所要求的稳定平衡点的可靠计数。\n\n```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.optimize import root\n\ndef solve_sac_model():\n    \"\"\"\n    Solves the spindle assembly checkpoint ODE model for four different parameter sets.\n    For each set, it computes the number of distinct asymptotically stable steady states.\n    \"\"\"\n\n    # Shared parameters as defined in the problem statement\n    shared_params_dict = {\n        'k_t': 8.0, 'k_c0': 0.01, 'k_o0': 0.02, 'k_apc_star': 4.0, 'k_m_on': 1.0, \n        'k_m_off': 0.02, 'k_m_apc_star': 4.0, 'k_a_on': 10.0, 'k_a_off': 0.005\n    }\n\n    # Test cases: (A_tot, T_Mad2, T_Cdc20, S, sigma)\n    test_cases = [\n        (1.0, 2.0, 1.5, 0.0, 1.0),\n        (0.3, 2.0, 1.5, 0.45, 3.0),\n        (0.3, 2.0, 1.5, 0.40, 3.0),\n        (1.0, 4.0, 3.0, 1.2, 1.0)\n    ]\n\n    def create_ode_system(params_tuple, shared_params):\n        \"\"\"\n        Creates a callable function for the ODE's right-hand-side (RHS)\n        based on the provided specific and shared parameters.\n        \"\"\"\n        A_tot, T_Mad2, T_Cdc20, S, sigma = params_tuple\n        k_apc = sigma * shared_params['k_apc_star']\n        k_m_apc = sigma * shared_params['k_m_apc_star']\n\n        def ode_rhs(t, y):\n            O, C, M = y\n\n            A = T_Mad2 - (O + C + M)\n            D = T_Cdc20 - T_Mad2 + O\n            A_free = A_tot - A\n            \n            O, C, M = max(0, O), max(0, C), max(0, M)\n            A, D, A_free = max(0, A), max(0, D), max(0, A_free)\n\n            v1f = (shared_params['k_t'] * S + shared_params['k_c0']) * O * D\n            v1r = (shared_params['k_o0'] + k_apc * A_free) * C\n            v3f = shared_params['k_m_on'] * C\n            v3r = (shared_params['k_m_off'] + k_m_apc * A_free) * M\n            v4f = shared_params['k_a_on'] * M * A_free\n            v4r = shared_params['k_a_off'] * A\n\n            dO_dt = -v1f + v1r\n            dC_dt = v1f - v1r - v3f + v3r\n            dM_dt = v3f - v3r - v4f + v4r\n            \n            return np.array([dO_dt, dC_dt, dM_dt])\n\n        return ode_rhs\n\n    def generate_initial_conditions(params_tuple):\n        A_tot, T_Mad2, T_Cdc20, _, _ = params_tuple\n        \n        O_min_c = max(0, T_Mad2 - T_Cdc20)\n        S_min_c = max(0, T_Mad2 - A_tot)\n        S_max_c = T_Mad2\n\n        def is_valid(p):\n            O, C, M = p\n            if O  O_min_c - 1e-9 or C  -1e-9 or M  -1e-9: return False\n            s = O + C + M\n            if s  S_min_c - 1e-9 or s > S_max_c + 1e-9: return False\n            return True\n\n        ics = []\n        O_box_min, O_box_max = O_min_c, S_max_c\n        C_box_min, C_box_max = 0, S_max_c\n        M_box_min, M_box_max = 0, S_max_c\n        \n        corners = [np.array([o, c, m]) for o in [O_box_min, O_box_max] \n                   for c in [C_box_min, C_box_max] for m in [M_box_min, M_box_max]]\n        for p in corners:\n            if is_valid(p):\n                ics.append(p)\n        \n        low, high = np.array([O_box_min, C_box_min, M_box_min]), np.array([O_box_max, C_box_max, M_box_max])\n        num_random_points, max_tries, tries = 100, 20000, 0\n        while len(ics)  num_random_points and tries  max_tries:\n            p = low + np.random.rand(3) * (high - low)\n            if is_valid(p): ics.append(p)\n            tries += 1\n\n        if not ics: return []\n        unique_ics = [ics[0]]\n        for ic in ics[1:]:\n            if not any(np.allclose(ic, uic, atol=1e-3) for uic in unique_ics):\n                unique_ics.append(ic)\n        return unique_ics\n\n    def get_jacobian(f, x, h=1e-7):\n        n = len(x)\n        J = np.zeros((n, n))\n        for j in range(n):\n            e_j = np.zeros(n)\n            e_j[j] = h\n            J[:, j] = (f(0, x + e_j) - f(0, x - e_j)) / (2 * h)\n        return J\n\n    def solve_for_case(params_tuple, shared_params):\n        A_tot, T_Mad2, T_Cdc20, _, _ = params_tuple\n        ode_system = create_ode_system(params_tuple, shared_params)\n        initial_conditions = generate_initial_conditions(params_tuple)\n        \n        endpoints = []\n        t_span = [0, 10000]\n        for ic in initial_conditions:\n            sol = solve_ivp(ode_system, t_span, ic, method='BDF', rtol=1e-7, atol=1e-10)\n            if sol.success:\n                endpoints.append(sol.y[:, -1])\n\n        if not endpoints: return 0\n\n        cluster_tol = 1e-3\n        unique_ss_guesses = []\n        if endpoints:\n            unique_ss_guesses.append(endpoints[0])\n            for point in endpoints[1:]:\n                if not any(np.linalg.norm(point - g)  cluster_tol for g in unique_ss_guesses):\n                    unique_ss_guesses.append(point)\n        \n        stable_ss_count = 0\n        refined_stable_states = []\n        for guess in unique_ss_guesses:\n            sol = root(lambda y: ode_system(0, y), guess, method='hybr', tol=1e-9)\n            if not sol.success: continue\n            \n            refined_ss = sol.x\n            \n            if any(np.linalg.norm(refined_ss - rss)  cluster_tol for rss in refined_stable_states):\n                continue\n            \n            O, C, M = refined_ss\n            A = T_Mad2 - (O + C + M)\n            D = T_Cdc20 - T_Mad2 + O\n            A_free = A_tot - A\n            if O  -1e-8 or C  -1e-8 or M  -1e-8 or A  -1e-8 or D  -1e-8 or A_free  -1e-8:\n                continue\n\n            jac = get_jacobian(ode_system, refined_ss)\n            try:\n                eigenvalues = np.linalg.eigvals(jac)\n                if np.all(np.real(eigenvalues)  -1e-9):\n                    stable_ss_count += 1\n                    refined_stable_states.append(refined_ss)\n            except np.linalg.LinAlgError:\n                continue\n                \n        return stable_ss_count\n\n    results = []\n    for params in test_cases:\n        num_stable = solve_for_case(params, shared_params_dict)\n        results.append(num_stable)\n    \n    return results\n\n# The problem asks for the output line to be printed.\n# The following code executes the logic and prints the final list.\n# results = solve_sac_model()\n# print(f\"[{','.join(map(str, results))}]\")\n# Based on execution, the result is [1, 1, 2, 1].\n```", "answer": "[1,1,2,1]", "id": "2964886"}]}