{"hands_on_practices": [{"introduction": "深入理解信号通路不仅需要了解其组分，还需要掌握剖析这些组分功能的实验策略。显性负向抑制 (dominant-negative inhibition) 是一种经典的分子生物学方法，通过引入一个经过改造的、功能失调的蛋白质，来干扰内源性野生型蛋白质的正常功能。这项练习将探讨一个 STAT5 突变体的案例，该突变体保留了其 $SH2$ 结构域但缺失了 DNA 结合域，从而挑战你对蛋白质结构-功能关系和 STAT 二聚化机制的理解 ([@problem_id:2277393])。通过分析其作用机制，你将能更深刻地认识到信号转导分子是如何通过特定结构域的相互作用来精确调控基因表达的。", "problem": "在一项关于红细胞生成（erythropoiesis）的实验室研究中，研究人员正在使用一种红系祖细胞系，该细胞系的存活与分化依赖于促红细胞生成素（Epo）这种激素。由Epo启动的信号级联反应对此过程至关重要，并遵循以下公认的途径：\n\n1.  Epo与细胞表面的Epo受体结合，导致受体二聚化。\n2.  这种二聚化激活了相关的Janus激酶2（JAK2）。\n3.  活化的JAK2磷酸化Epo受体胞内结构域上的特定酪氨酸残基。\n4.  一种名为信号转导与转录激活因子5（STAT5）的蛋白质，其包含一个Src同源2（SH2）结构域和一个DNA结合域（DBD），通过其SH2结构域结合到磷酸化的受体上，从而被招募。\n5.  被招募的STAT5随后被JAK2磷酸化。\n6.  磷酸化的STAT5蛋白从受体上解离，并通过各自的SH2结构域与磷酸化酪氨酸残基之间的相互作用形成同源二聚体（STAT5-STAT5）。\n7.  这些功能性二聚体转移到细胞核中，通过其DBD与特定的DNA序列结合，以激活靶基因的转录，例如促进细胞存活的抗凋亡基因 *Bcl-xL*。\n\n研究人员转染这些细胞，以引起一种突变STAT5蛋白的高水平表达，我们称之为STAT5-DN。这种突变蛋白具有功能完整的SH2结构域，但完全缺失其DNA结合域（DBD）。内源性的野生型STAT5仍然存在于细胞中。当这些转染后的细胞受到Epo刺激时，研究人员观察到，与未转染的细胞相比，*Bcl-xL*基因的转录显著减少。\n\n下列哪个陈述为观察到的Epo诱导的基因转录的显性负抑制提供了最准确的分子解释？\n\nA. STAT5-DN突变蛋白永久性地结合到Epo受体上，从而阻止野生型STAT5的结合和磷酸化。\n\nB. STAT5-DN突变蛋白在细胞质中自身二聚化，并隔离JAK2激酶，阻止其与Epo受体结合。\n\nC. STAT5-DN突变蛋白不能结合DNA，但它仍能被磷酸化并与野生型STAT5形成无功能的异源二聚体，从而阻止野生型蛋白结合到靶基因启动子上。\n\nD. STAT5-DN突变蛋白缺失DNA结合域，这也阻止了其被JAK2磷酸化，导致它以非活性状态积累并通过空间位阻阻断该通路。\n\nE. STAT5-DN突变蛋白进入细胞核并结合一个抑制性辅因子，然后主动抑制所有STAT5靶基因的转录。", "solution": "Epo信号通路需要一系列顺序步骤：Epo诱导的受体二聚化激活JAK2，JAK2磷酸化Epo受体上的酪氨酸。STAT5通过其SH2结构域被招募到这些磷酸化酪氨酸上，然后被JAK2磷酸化。磷酸化的STAT5通过SH2-磷酸化酪氨酸相互作用形成二聚体，转移到细胞核中，并通过其DNA结合域（DBD）结合DNA，以驱动像Bcl-xL这类靶基因的转录。\n\n突变的STAT5-DN保留了完整的SH2结构域但缺失DBD。因此：\n1. 招募：由于SH2结构域是完整的，STAT5-DN仍然可以结合磷酸化的受体位点，与内源性STAT5竞争招募，并被JAK2磷酸化。缺失DBD不会损害JAK2的识别或磷酸化，因为这些过程发生在STAT5的其他残基上。\n2. 二聚化：一旦被磷酸化，STAT5-DN可以通过经典的SH2-磷酸化酪氨酸介导的界面进行二聚化。它可以形成同源二聚体（STAT5-DN:STAT5-DN），也可以与野生型STAT5形成异源二聚体（STAT5-DN:STAT5-WT）。\n3. 核内功能：STAT二聚体的DNA结合需要两个单体都与GAS元件中各自的半位点正确结合；其中一个伴侣缺失DBD会破坏稳定的、序列特异性的结合和转录激活。因此，含有STAT5-DN的异源二聚体在DNA上没有功能，STAT5-DN的同源二聚体也没有功能。结果，STAT5-DN通过将野生型STAT5隔离到无生产力的二聚体中，并减少能够结合启动子和激活转录的功能性STAT5-WT同源二聚体的数量，从而起到显性负向作用。\n4. 尽管存在内源性STAT5，该机制直接解释了观察到的Epo诱导的Bcl-xL转录减少的现象。\n\n评估选项：\n- A 是错误的，因为STAT5通过SH2与受体磷酸化酪氨酸的结合是瞬时的；磷酸化会触发解离和二聚化，而不是永久性地占据受体。\n- B 是错误的，因为STAT5不会在细胞质中隔离JAK2；JAK2是与受体相关的，而STAT5的二聚化依赖于在受体上的磷酸化。\n- C 是正确的：STAT5-DN被磷酸化，与野生型STAT5形成无功能的异源二聚体，并阻止野生型STAT5结合靶基因启动子，从而产生显性负抑制。\n- D 是错误的，因为缺失DBD并不会阻止JAK2的磷酸化。\n- E 是错误的，因为STAT5-DN缺失DBD，不会特异性结合DNA以将阻遏物招募到所有STAT5靶点；没有证据表明这种突变体具有普遍的主动抑制作用。\n\n因此，最准确的解释是形成了无功能的异源二聚体，这些二聚体阻断了野生型STAT5的DNA结合和转录激活。", "answer": "$$\\boxed{C}$$", "id": "2277393"}, {"introduction": "在阐明信号通路中各个蛋白的功能时，科学家们常常需要区分它们是具有独特的功能，还是可以相互替代（功能冗余）。CRISPR-Cas9 等基因编辑技术的出现，使得我们能够通过精确地敲除特定基因来系统性地研究这些问题。这项练习为你呈现了一个模拟实验的结果，研究人员利用基因敲除技术来探究 JAK1 和 TYK2 激酶在 I 型干扰素信号通路中的具体作用 ([@problem_id:2342414])。你的任务是像一位真正的科学家那样，仅根据提供的实验数据，严谨地推断出这两种激酶在 STAT1 磷酸化过程中的必要性和可替代性。", "problem": "I型干扰素 (IFN) 信号通路是应对病毒感染的先天性免疫应答的关键组成部分。当配体（如IFN-α）与由IFNAR1和IFNAR2亚基组成的异二聚体细胞表面受体结合时，该通路被启动。这一结合事件使得两种受体相关激酶——Janus激酶1 (JAK1) 和酪氨酸激酶2 (TYK2) ——彼此靠近。JAK1与IFNAR2组成性结合，而TYK2与IFNAR1结合。随后的激活级联反应涉及关键下游靶点的磷酸化，其中包括信号转导与转录激活因子1 (STAT1) 蛋白。磷酸化的STAT1 (pSTAT1) 是其二聚化并转位至细胞核以激活IFN刺激基因转录的关键步骤。\n\n一位研究人员旨在阐明在IFN-α诱导的STAT1激活过程中，JAK1和TYK2的各自具体贡献。该研究人员使用成簇规律间隔短回文重复序列 (CRISPR)-Cas9基因编辑技术，从一个野生型 (WT) 亲代细胞系中生成了三种不同的人类敲除 (KO) 细胞系：JAK1-KO细胞系、TYK2-KO细胞系以及同时缺乏JAK1和TYK2的双敲除 (DKO) 细胞系。\n\n所有四种细胞系（WT、JAK1-KO、TYK2-KO 和 DKO）均用饱和浓度的IFN-α处理15分钟。然后制备细胞裂解物，并通过蛋白质印迹法 (Western blot) 分析以检测磷酸化STAT1 (pSTAT1) 的水平。作为对照，经证实所有样本中的STAT1总蛋白量相等。观察到的结果如下：\n\n- **WT细胞：** 检测到对应于pSTAT1的强条带。\n- **JAK1-KO细胞：** 未检测到对应于pSTAT1的条带。\n- **TYK2-KO细胞：** 检测到对应于pSTAT1的强条带，其强度与WT细胞相似。\n- **DKO细胞：** 未检测到对应于pSTAT1的条带。\n\n仅根据这些实验结果，关于JAK1和TYK2在IFN-α诱导的STAT1磷酸化中的作用，最准确的结论是什么？\n\nA. JAK1和TYK2的功能完全冗余，意味着任何一个激酶自身都足以诱导完全的STAT1磷酸化反应。\n\nB. TYK2是STAT1磷酸化的必需激酶，并且存在一个涉及JAK1的未知代偿机制。\n\nC. JAK1和TYK2必须同时存在并具有活性，STAT1磷酸化才能发生，这表明它们以专性异二聚体的形式发挥作用。\n\nD. 在IFN-α诱导的STAT1磷酸化反应中，JAK1是必需的，而对于这一特定信号输出，TYK2是非必需的。\n\nE. TYK2的主要功能是磷酸化JAK1，而JAK1是唯一直接磷酸化STAT1的激酶。", "solution": "- 实验设计通过比较WT、单基因敲除（single KOs）和双基因敲除（double KO）细胞，检验了JAK1和TYK2对于IFN-α诱导的STAT1磷酸化的必要性，并控制了所有样本中总STAT1蛋白量相等。\n- 观察结果：\n  1) WT细胞显示出强烈的pSTAT1信号，证实了在实验条件下该信号通路是功能性的。\n  2) JAK1-KO细胞没有显示pSTAT1信号，表明JAK1对于响应IFN-α的STAT1磷酸化是必需的。\n  3) TYK2-KO细胞显示出与WT相似的强烈pSTAT1信号，表明对于这一特定输出，TYK2不是必需的；单独的JAK1就足够了。\n  4) DKO细胞没有显示pSTAT1信号，这与JAK1的必要性一致，并且没有提供超出JAK1-KO结果的额外信息。\n\n- 仅基于数据对选项进行逻辑排除：\n  - A（完全冗余）是错误的，因为JAK1-KO消除了pSTAT1；如果功能完全冗余，那么在JAK1-KO细胞中，仅TYK2就应该足够。\n  - B（TYK2是必需的）是错误的，因为TYK2-KO保留了强烈的pSTAT1信号。\n  - C（专性异二聚体需求）是错误的，因为TYK2-KO细胞有反应，所以两者并非需要同时存在。\n  - D（JAK1是必需的，TYK2是非必需的）得到直接支持：JAK1的缺失废除了信号传导；TYK2的缺失则不影响它。\n  - E 假设了一个特定的机制层级（TYK2磷酸化JAK1，然后JAK1直接磷酸化STAT1）。尽管这与数据相符，但仅凭这些结果无法证明这一机制性论断；数据只显示了相对于STAT1磷酸化读数的必要性和非必要性，而没有显示直接的激酶-底物关系。\n\n- 因此，严格基于所呈现结果得出的最准确结论是，JAK1对于IFN-α诱导的STAT1磷酸化是必需的，而对于这一特定信号输出，TYK2是非必需的。", "answer": "$$\\boxed{D}$$", "id": "2342414"}, {"introduction": "对 Jak-STAT 通路的理解已经从静态的“线路图”发展到动态的系统层面，而这离不开数学建模和计算方法的应用。这项高阶练习将带你进入计算系统生物学的领域，你将不再仅仅是定性地解释现象，而是要定量地构建和检验关于通路动力学行为的假设 ([@problem_id:2681319])。具体来说，你将运用贝叶斯推断这一强大的统计框架，通过拟合时间序列数据来比较两种不同的 Jak-STAT 通路模型——一个包含负反馈，一个不包含——从而亲身体验如何利用数据来辨别生物系统背后的调控机制。", "problem": "要求您为Janus激酶-信号转导与转录激活因子 (JAK-STAT) 信号通路的两种机理假设，实现一个独立的贝叶斯参数推断和比较。这两种假设的区别在于是否存在由细胞因子信号传导抑制因子 (SOCS) 介导的转录负反馈。\n\n从以下公认的基础出发：\n- 对于充分混合系统，质量作用定律意味着，在考虑一阶过程时，宏观反应速率可以通过常微分方程 (ODEs) 建模，其中浓度的变化率是当前浓度和输入的线性组合。\n- 贝叶斯定理指出，对于参数 $\\theta$、数据 $D$ 和假设 $H$，后验密度为 $p(\\theta \\mid D, H) \\propto p(D \\mid \\theta, H) p(\\theta \\mid H)$。\n- 对于建模为独立同分布、已知标准差 $\\sigma$ 的高斯噪声的加性测量噪声，似然函数为 $p(D \\mid \\theta, H) \\propto \\exp\\left(-\\tfrac{1}{2} \\sum_{i=1}^{n} \\left(\\tfrac{y_i - \\hat{y}_i(\\theta)}{\\sigma}\\right)^2 \\right)$，其中 $y_i$ 是观测值，$\\hat{y}_i(\\theta)$ 是在观测时间的模型预测值。\n\n机理模型：\n- 无反馈假设 ($H_0$)：令 $N(t)$ 表示激活的STAT二聚体的核信号，并假设上游驱动恒定。其动力学为\n$$\n\\frac{dN}{dt} = k_{\\text{in}} - k_{\\text{out}} N,\n$$\n初始条件为 $N(0)=0$。这里 $k_{\\text{in}}$ 是由上游受体-Janus激酶活性驱动的有效输入速率（单位：每分钟），$k_{\\text{out}}$ 是一阶损失速率（单位：每分钟），代表输出/去磷酸化。\n- 有反馈假设 ($H_1$)：令 $S(t)$ 表示SOCS水平，其诱导与 $N(t)$ 成正比并呈线性衰减。其动力学为\n$$\n\\begin{aligned}\n\\frac{dN}{dt} = k_{\\text{in}} - \\left(k_{\\text{out}} + k_f S\\right) N, \\\\\n\\frac{dS}{dt} = \\alpha N - \\gamma S,\n\\end{aligned}\n$$\n初始条件为 $N(0)=0$ 和 $S(0)=0$。常数 $k_f$（反馈强度，单位：每分钟每SOCS单位）、$\\alpha$（SOCS诱导速率，单位：每分钟）和 $\\gamma$（SOCS衰减速率，单位：每分钟）是已知且固定的。\n\n观测模型：\n- 在时间 $t_i$ 的观测值 $y_i$ 生成为 $y_i = N(t_i) + \\epsilon_i$，其中 $\\epsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$，在 $i$ 之间相互独立。\n\n贝叶斯推断任务：\n- 在 $H_0$ 和 $H_1$ 两种假设下，未知参数均为 $\\theta = (k_{\\text{in}}, k_{\\text{out}})$，具有独立的均匀先验：\n$$\nk_{\\text{in}} \\sim \\text{Uniform}(0.05, 1.0), \\quad k_{\\text{out}} \\sim \\text{Uniform}(0.02, 0.4).\n$$\n- 使用矩形网格来近似后验分布，其中 $k_{\\text{in}}$ 在 $[0.05, 1.0]$ 区间上取 $25$ 个线性间隔点，$k_{\\text{out}}$ 在 $[0.02, 0.4]$ 区间上取 $25$ 个线性间隔点。\n- 对每个网格点，使用高斯模型计算对数似然，并使用贝叶斯定理和 log-sum-exp 归一化方法得到网格上的归一化后验。\n- 对每个假设，通过在网格上进行边缘化来计算 $k_{\\text{in}}$ 的后验均值。\n\n数值积分：\n- 为了通过模拟ODE来计算模型预测值 $\\hat{y}_i(\\theta)$，使用显式欧拉方法，时间步长固定为 $\\Delta t = 0.1$ 分钟，从 $t=0$ 到最大观测时间。使用在所提供的观测时间记录的状态。设置 $k_f = 0.5$、$\\alpha = 0.05$ 和 $\\gamma = 0.1$（所有单位均为每分钟）。\n\n测试套件的数据生成：\n- 使用与上述相同的ODE求解器和参数，通过已知的种子生成合成数据集。对于每个测试用例，通过使用给定的真实参数模拟指定的假设来生成观测值 $y_i$，然后使用初始化为 $\\text{default\\_rng}(\\text{seed})$ 的 NumPy 随机数生成器添加指定 $\\sigma$ 的高斯噪声。\n- 所有测试用例的观测时间为在 $[0, 60]$ 范围内每 $2$ 分钟采样一次的分钟数，即 $t_i \\in \\{0, 2, 4, \\dots, 60\\}$。\n\n测试套件（三种情况）：\n1. 情况 A (由反馈模型生成)：使用 $H_1$ 生成数据，其中 $k_{\\text{in}}^{\\text{true}} = 0.5$，$k_{\\text{out}}^{\\text{true}} = 0.1$，噪声 $\\sigma = 0.02$，种子为 $12345$。\n2. 情况 B (由无反馈模型生成)：使用 $H_0$ 生成数据，其中 $k_{\\text{in}}^{\\text{true}} = 0.5$，$k_{\\text{out}}^{\\text{true}} = 0.1$，噪声 $\\sigma = 0.02$，种子为 $54321$。\n3. 情况 C (由反馈模型生成，高噪声)：使用 $H_1$ 生成数据，其中 $k_{\\text{in}}^{\\text{true}} = 0.3$，$k_{\\text{out}}^{\\text{true}} = 0.08$，噪声 $\\sigma = 0.10$，种子为 $2021$。\n\n要求的计算和输出：\n- 对于每个测试用例，在 $H_0$ 和 $H_1$ 两种假设下执行贝叶斯推断，并计算 $k_{\\text{in}}$ 的后验均值之差：\n$$\n\\Delta \\mu = \\mathbb{E}[k_{\\text{in}} \\mid D, H_1] - \\mathbb{E}[k_{\\text{in}} \\mid D, H_0].\n$$\n- 每个测试用例报告一个标量：$\\Delta \\mu$ 的值，单位为 $\\text{min}^{-1}$，四舍五入到六位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3]$），其中 $r_1$、$r_2$ 和 $r_3$ 分别是情况 A、B 和 C 的 $\\Delta \\mu$ 值，每个值以 $\\text{min}^{-1}$ 为单位，四舍五入到六位小数。", "solution": "这项任务是针对Janus激酶-信号转导与转录激活因子 (JAK-STAT) 信号通路，在两种假设——$H_0$（无反馈）和 $H_1$（负反馈）——之间进行贝叶斯模型比较。通过为三个不同的合成数据集计算每种假设下参数 $k_{\\text{in}}$ 的后验均值并分析其差异来完成此任务。\n\n系统动力学由常微分方程 (ODEs) 描述。\n对于假设 $H_0$，即无反馈模型，核内激活的STAT浓度（记为 $N(t)$）遵循以下一阶线性ODE演化：\n$$\n\\frac{dN}{dt} = k_{\\text{in}} - k_{\\text{out}} N\n$$\n初始条件为 $N(0) = 0$。参数 $k_{\\text{in}}$ 和 $k_{\\text{out}}$ 分别代表有效输入速率和损失速率。\n\n对于假设 $H_1$，系统包含一个由细胞因子信号传导抑制因子 (SOCS) 介导的负反馈回路，其浓度记为 $S(t)$。耦合动力学由一个包含两个ODE的方程组给出：\n$$\n\\begin{aligned}\n\\frac{dN}{dt} = k_{\\text{in}} - \\left(k_{\\text{out}} + k_f S\\right) N \\\\\n\\frac{dS}{dt} = \\alpha N - \\gamma S\n\\end{aligned}\n$$\n初始条件为 $N(0) = 0$ 和 $S(0) = 0$。控制反馈动力学的参数被指定为固定常数：反馈强度 $k_f = 0.5$，SOCS诱导速率 $\\alpha = 0.05$，以及SOCS衰减速率 $\\gamma = 0.1$。所有速率的单位均为 $\\text{min}^{-1}$ 或与其一致的组合单位。\n\n为了获得给定参数集 $\\theta = (k_{\\text{in}}, k_{\\text{out}})$ 的模型预测值 $\\hat{y}_i(\\theta)$，必须对ODEs进行数值求解。指定的方法是显式欧拉方案，固定时间步长为 $\\Delta t = 0.1$ 分钟。对于在时间 $t_j$ 的状态向量 $X_j$（对于 $H_0$ 代表 $[N_j]$，对于 $H_1$ 代表 $[N_j, S_j]^T$），在下一个时间步 $t_{j+1} = t_j + \\Delta t$ 的状态计算为 $X_{j+1} = X_j + \\Delta t \\cdot f(X_j, \\theta)$，其中 $f$ 是由相应ODE系统右侧定义的向量场。\n\n分析的核心是贝叶斯推断。贝叶斯定理给出了在给定数据 $D$ 和假设 $H$ 的情况下，参数 $\\theta$ 的后验概率密度：\n$$\np(\\theta \\mid D, H) \\propto p(D \\mid \\theta, H) \\cdot p(\\theta \\mid H)\n$$\n待推断的参数 $\\theta=(k_{\\text{in}}, k_{\\text{out}})$ 被赋予独立的均匀先验分布：\n$$\nk_{\\text{in}} \\sim \\text{Uniform}(0.05, 1.0), \\quad k_{\\text{out}} \\sim \\text{Uniform}(0.02, 0.4)\n$$\n由于先验概率密度 $p(\\theta \\mid H)$ 在此指定的矩形域上为常数，在其他地方为零，因此后验密度在该域内仅与似然函数成正比：$p(\\theta \\mid D, H) \\propto p(D \\mid \\theta, H)$。\n\n观测模型假定测量值 $y_i$ 是由真实的核STAT浓度 $N(t_i)$ 加上加性的、独立的、同分布的高斯噪声生成的：$y_i = N(t_i) + \\epsilon_i$，其中 $\\epsilon_i \\sim \\mathcal{N}(0, \\sigma^2)$。因此，对数似然函数的形式为：\n$$\n\\log p(D \\mid \\theta, H) = \\text{const} - \\frac{1}{2\\sigma^2} \\sum_{i=1}^{n} (y_i - \\hat{y}_i(\\theta))^2\n$$\n其中 $y_i$ 是在时间 $t_i \\in \\{0, 2, 4, \\dots, 60\\}$ 的观测数据，$\\hat{y}_i(\\theta)$ 是对应的 $N(t_i)$ 的模型预测值。\n\n后验分布在一个离散网格上进行近似。$(k_{\\text{in}}, k_{\\text{out}})$ 的参数空间被离散化为一个 $25 \\times 25$ 的矩形网格。令 $\\theta_{ij} = (k_{\\text{in},i}, k_{\\text{out},j})$ 表示该网格上的一个点。对于每个假设 $H \\in \\{H_0, H_1\\}$，执行以下步骤：\n$1$. 对每个网格点 $\\theta_{ij}$，模拟相应的ODE模型以获得预测值。\n$2$. 从残差平方和计算对数似然 $\\mathcal{L}_{ij} = \\log p(D \\mid \\theta_{ij}, H)$。\n$3$. 由于先验是均匀的，每个网格点的未归一化后验对数概率等于 $\\mathcal{L}_{ij}$。为了获得归一化的离散概率分布 $P_{ij}$，采用 log-sum-exp 技巧来保证数值稳定性：\n$$\nP_{ij} = \\frac{\\exp(\\mathcal{L}_{ij} - \\mathcal{L}_{\\max})}{\\sum_{i'=1}^{25} \\sum_{j'=1}^{25} \\exp(\\mathcal{L}_{i'j'} - \\mathcal{L}_{\\max})}\n$$\n其中 $\\mathcal{L}_{\\max} = \\max_{i,j} \\mathcal{L}_{ij}$。\n\n一旦计算出网格上的后验概率质量函数 $P_{ij}$， $k_{\\text{in}}$ 的后验均值就通过计算其在该离散分布上的期望来得到：\n$$\n\\mathbb{E}[k_{\\text{in}} \\mid D, H] = \\sum_{i=1}^{25} \\sum_{j=1}^{25} k_{\\text{in},i} \\cdot P_{ij}\n$$\n此计算对假设 $H_0$ 和 $H_1$ 独立进行。\n\n最终目标是为所提供的三个测试用例中的每一个计算这些后验均值之间的差异：\n$$\n\\Delta \\mu = \\mathbb{E}[k_{\\text{in}} \\mid D, H_1] - \\mathbb{E}[k_{\\text{in}} \\mid D, H_0]\n$$\n这个量 $\\Delta \\mu$ 衡量了当模型扩展以包含负反馈机制时，对输入速率 $k_{\\text{in}}$ 的估计是如何调整的。非零值表示两种模型对于该参数的数据解释方式不同。整个算法的流程是：首先为每个测试用例生成合成数据，然后对两种模型执行所述的推断过程，最后计算它们后验均值的差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import logsumexp\n\ndef solve():\n    \"\"\"\n    Main function to run the Bayesian inference for the specified test cases.\n    \"\"\"\n    # Define constants from the problem statement\n    KF = 0.5\n    ALPHA = 0.05\n    GAMMA = 0.1\n    DT = 0.1\n    T_MAX = 60.0 # Use float for calculations\n    T_OBS = np.arange(0, T_MAX + DT, 2) # Use DT to avoid float precision issues with T_MAX\n    KIN_GRID = np.linspace(0.05, 1.0, 25)\n    KOUT_GRID = np.linspace(0.02, 0.4, 25)\n    N_GRID_POINTS = 25\n\n    def solve_h0(k_in, k_out):\n        \"\"\"Solves the H0 model (no feedback) using explicit Euler.\"\"\"\n        num_steps = int(T_MAX / DT)\n        n_hist = np.zeros(num_steps + 1)\n        \n        for i in range(num_steps):\n            n_i = n_hist[i]\n            n_dot = k_in - k_out * n_i\n            n_hist[i + 1] = n_i + DT * n_dot\n            \n        return n_hist\n\n    def solve_h1(k_in, k_out):\n        \"\"\"Solves the H1 model (with feedback) using explicit Euler.\"\"\"\n        num_steps = int(T_MAX / DT)\n        n_hist = np.zeros(num_steps + 1)\n        s_hist = np.zeros(num_steps + 1)\n\n        for i in range(num_steps):\n            n_i = n_hist[i]\n            s_i = s_hist[i]\n            \n            n_dot = k_in - (k_out + KF * s_i) * n_i\n            s_dot = ALPHA * n_i - GAMMA * s_i\n            \n            n_hist[i + 1] = n_i + DT * n_dot\n            s_hist[i + 1] = s_i + DT * s_dot\n            \n        return n_hist\n\n    def generate_data(model_type, true_params, sigma, seed):\n        \"\"\"Generates synthetic data for a given model and parameters.\"\"\"\n        k_in_true, k_out_true = true_params\n        if model_type == 'H0':\n            n_true_hist = solve_h0(k_in_true, k_out_true)\n        else:  # H1\n            n_true_hist = solve_h1(k_in_true, k_out_true)\n        \n        obs_indices = (T_OBS / DT).astype(int)\n        n_at_obs = n_true_hist[obs_indices]\n        \n        rng = np.random.default_rng(seed)\n        noise = rng.normal(0, sigma, size=len(T_OBS))\n        y_obs = n_at_obs + noise\n        return y_obs\n\n    def run_inference(data, sigma, model_type):\n        \"\"\"Performs grid-based Bayesian inference and returns the posterior mean of k_in.\"\"\"\n        log_likelihoods = np.zeros((N_GRID_POINTS, N_GRID_POINTS))\n        obs_indices = (T_OBS / DT).astype(int)\n\n        for i, k_in in enumerate(KIN_GRID):\n            for j, k_out in enumerate(KOUT_GRID):\n                if model_type == 'H0':\n                    n_pred_hist = solve_h0(k_in, k_out)\n                else:  # H1\n                    n_pred_hist = solve_h1(k_in, k_out)\n                \n                n_pred_at_obs = n_pred_hist[obs_indices]\n                sse = np.sum((data - n_pred_at_obs)**2)\n                log_likelihoods[i, j] = -0.5 * sse / (sigma**2)\n\n        # Normalize posterior using log-sum-exp for numerical stability\n        log_posterior = log_likelihoods - logsumexp(log_likelihoods)\n        posterior = np.exp(log_posterior)\n        \n        # Calculate posterior mean of k_in\n        # posterior has shape (n_kin, n_kout)\n        # We need to compute Sum(k_in_i * P_ij) over i and j\n        mean_kin = np.sum(posterior * KIN_GRID[:, np.newaxis])\n        \n        return mean_kin\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'gen_model': 'H1', 'true_params': (0.5, 0.1), 'sigma': 0.02, 'seed': 12345},\n        {'gen_model': 'H0', 'true_params': (0.5, 0.1), 'sigma': 0.02, 'seed': 54321},\n        {'gen_model': 'H1', 'true_params': (0.3, 0.08), 'sigma': 0.10, 'seed': 2021}\n    ]\n\n    results = []\n    for case in test_cases:\n        # Generate data for the case\n        data = generate_data(\n            model_type=case['gen_model'],\n            true_params=case['true_params'],\n            sigma=case['sigma'],\n            seed=case['seed']\n        )\n        \n        # Run inference under H0\n        mean_kin_h0 = run_inference(data, case['sigma'], model_type='H0')\n        \n        # Run inference under H1\n        mean_kin_h1 = run_inference(data, case['sigma'], model_type='H1')\n        \n        delta_mu = mean_kin_h1 - mean_kin_h0\n        results.append(f\"{delta_mu:.6f}\") # Use formatted string for rounding\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2681319"}]}