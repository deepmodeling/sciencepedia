{"hands_on_practices": [{"introduction": "重排距离是量化两个基因组间演化差异的基石度量。本练习 [@problem_id:2854174] 将引导您一步步实践断点图方法，这是一个将基因组重排与清晰的组合结构联系起来的强大工具。掌握这一计算是理解比较基因组学理论基础的必要步骤。", "problem": "考虑两个小型基因组，它们表示为保守同线性区块的带符号排列。设基因组 $\\mathcal{A}$ 为 $n=6$ 个区块上的带符号排列\n$$\\pi_{\\mathcal{A}} = (+1,\\,-2,\\,-3,\\,-4,\\,-5,\\,+6),$$\n且设基因组 $\\mathcal{B}$ 为单位带符号排列\n$$\\pi_{\\mathcal{B}} = (+1,\\,+2,\\,+3,\\,+4,\\,+5,\\,+6).$$\n对带符号排列的连续片段 $[i, j]$ 进行的一次反转操作，会颠倒该片段中区块的顺序并翻转它们的符号。断点图是基于区块的有向端点构建的，使用标准映射将带符号区块 $+i$ 映射到有序对 $(2i-1,\\,2i)$，将带符号区块 $-i$ 映射到有序对 $(2i,\\,2i-1)$，然后在该序列的两端加上哨兵端点 $0$ 和 $2n+1$。灰边连接 $(2k,\\,2k+1)$（其中 $k=0,1,\\dots,n$），而黑边连接从增广序列中依次取出的连续顶点对。断点是增广序列中相邻条目之间的位置，在这些位置上，后继者不恰好比前驱者大一。\n\n仅从上述核心定义和基因组重排的原理（特别是，一次反转会翻转方向并改变邻接关系，以及断点图会分解为交替的黑灰循环）出发，完成以下任务：\n\n- 构建相对于 $\\pi_{\\mathcal{B}}$（即单位排列）的 $\\pi_{\\mathcal{A}}$ 的有向端点（也称为 ob）增广序列，包括哨兵 $0$ 和 $2n+1$。\n- 根据此增广序列，构建断点图，并计算初始交替循环数 $c_{0}$ 和有向断点数 $B_{0}$，其中 $B_{0}$ 是增广序列中不满足 $x,\\,x+1$ 形式的相邻对的数量。\n- 设计一个将 $\\pi_{\\mathcal{A}}$ 转换为 $\\pi_{\\mathcal{B}}$ 的反转序列。每次反转后，明确更新增广序列，重新计算有向断点数 $B$，并给出断点图中的循环数 $c$，解释 $c$ 为何以及如何变化。\n- 仅使用“任何单次反转最多能使循环数改变 $1$”以及“单位排列恰好有 $n+1$ 个循环”这两个原理，证明您的序列达到了可能的最小反转次数。然后，报告该最小数目。\n\n您的最终答案必须是确切的最小反转次数（一个整数）。无需四舍五入，也无需单位。", "solution": "所提出的问题是计算基因组学领域一个定义明确的练习，具体涉及通过反转对带符号排列进行排序。所有提供的定义——关于基因组、反转和断点图——都是标准的且内部一致。该问题具有科学依据、自成体系且可通过算法求解。不存在任何使其无效的缺陷。我们开始进行解答。\n\n问题要求将一个给定的带符号排列 $\\pi_{\\mathcal{A}}$ 转换为单位排列 $\\pi_{\\mathcal{B}}$ 所需的最小反转次数。这是反转距离问题。解决方案在于分析断点图分解为交替循环的情况。\n\n给定的基因组是 $n=6$ 个区块的排列：\n$$ \\pi_{\\mathcal{A}} = (+1, -2, -3, -4, -5, +6) $$\n$$ \\pi_{\\mathcal{B}} = (+1, +2, +3, +4, +5, +6) $$\n\n首先，我们构建 $\\pi_{\\mathcal{A}}$ 的有向端点表示。一个带符号区块 $+i$ 映射到顶点对 $(2i-1, 2i)$，一个区块 $-i$ 映射到 $(2i, 2i-1)$。该排列在开头增广了哨兵顶点 $0$，在末尾增广了 $2n+1=13$。\n\n对于 $\\pi_{\\mathcal{A}} = (+1, -2, -3, -4, -5, +6)$：\n- $+1 \\rightarrow (1, 2)$\n- $-2 \\rightarrow (4, 3)$\n- $-3 \\rightarrow (6, 5)$\n- $-4 \\rightarrow (8, 7)$\n- $-5 \\rightarrow (10, 9)$\n- $+6 \\rightarrow (11, 12)$\n\n增广的顶点序列是：\n$$ S_0 = (0, 1, 2, 4, 3, 6, 5, 8, 7, 10, 9, 11, 12, 13) $$\n\n断点图建立在顶点 $\\{0, 1, \\dots, 13\\}$ 上。\n- **黑边**连接 $\\pi_{\\mathcal{A}}$ 中相邻区块的端点。它们是：$(0,1)$, $(2,4)$, $(3,6)$, $(5,8)$, $(7,10)$, $(9,11)$, $(12,13)$。\n- **灰边**连接在单位排列 $\\pi_{\\mathcal{B}}$ 中相邻的端点。它们是：$(0,1)$, $(2,3)$, $(4,5)$, $(6,7)$, $(8,9)$, $(10,11)$, $(12,13)$。\n\n初始交替循环数 $c_0$ 是通过沿交替的黑边和灰边遍历图来找到的：\n1.  $0 \\xrightarrow{\\text{黑边}} 1 \\xrightarrow{\\text{灰边}} 0$。这是循环 $(0,1)$。\n2.  $12 \\xrightarrow{\\text{黑边}} 13 \\xrightarrow{\\text{灰边}} 12$。这是循环 $(12,13)$。\n3.  从顶点 $2$ 开始：$2 \\xrightarrow{\\text{灰边}} 3 \\xrightarrow{\\text{黑边}} 6 \\xrightarrow{\\text{灰边}} 7 \\xrightarrow{\\text{黑边}} 10 \\xrightarrow{\\text{灰边}} 11 \\xrightarrow{\\text{黑边}} 9 \\xrightarrow{\\text{灰边}} 8 \\xrightarrow{\\text{黑边}} 5 \\xrightarrow{\\text{灰边}} 4 \\xrightarrow{\\text{黑边}} 2$。这形成了循环 $(2,3,6,7,10,11,9,8,5,4)$。\n\n因此，图分解为 $c_0 = 3$ 个循环。\n\n初始有向断点数 $B_0$ 是增广序列 $S_0$ 中满足 $v_{k+1} \\neq v_k+1$ 的相邻对 $(v_k, v_{k+1})$ 的数量。\n对于 $S_0 = (0, 1, 2, 4, 3, 6, 5, 8, 7, 10, 9, 11, 12, 13)$：\n- 非断点对：$(0,1), (1,2), (11,12), (12,13)$。\n- 断点对：$(2,4), (4,3), (3,6), (6,5), (5,8), (8,7), (7,10), (10,9), (9,11)$。\n计数为 $B_0=9$。\n\n为了找到最优的反转序列，我们必须应用能够增加循环数的反转。这类反转被称为“排序反转”。对同一循环中的两条黑边进行的排序反转会将其分裂为两个循环，从而使循环数增加一。\n\n**反转 1：**\n我们的目标是修复 $\\pi_0$ 中的第一个不正确的邻接关系 $(+1, -2)$。目标是 $(+1, +2)$。我们可以通过反转仅包含区块 $-2$ 的片段来实现。这是对 $\\pi_0$ 的反转 $\\rho(2,2)$。\n- **新排列：** $\\pi_1 = (+1, +2, -3, -4, -5, +6)$。\n- 这次反转打破了邻接关系 $(+1,-2)$ 和 $(-2,-3)$，对应于黑边 $(2,4)$ 和 $(3,6)$。它创建了新的邻接关系 $(+1,+2)$ 和 $(+2,-3)$，对应于新的黑边 $(2,3)$ 和 $(4,6)$。\n- **对循环的影响：** 新的黑边 $(2,3)$ 同时也是一条灰边，形成一个新的二元循环 $(2,3)$。原来的长循环 $(2,3,6,7,10,11,9,8,5,4)$ 被打破。黑边 $(2,4)$ 和 $(3,6)$ 被替换为 $(2,3)$ 和 $(4,6)$。新的黑边 $(2,3)$ 和灰边 $(2,3)$ 形成一个循环。原循环的其余部分形成一个新的、更短的循环：$(4,6,7,10,11,9,8,5)$。\n- **循环数：** $c_1 = c_0 + 1 = 3+1 = 4$。\n- **新增广序列：** 对于 $\\pi_1 = (+1, +2, -3, -4, -5, +6)$：$S_1 = (0, 1, 2, 3, 4, 6, 5, 8, 7, 10, 9, 11, 12, 13)$。\n- **新断点数：** 断点位于对应于对 $(4,6), (6,5), (5,8), (8,7), (7,10), (10,9), (9,11)$ 的位置。因此，$B_1=7$。\n\n**反转 2：**\n我们继续修复 $\\pi_1$ 中的下一个不正确的邻接关系 $(+2,-3)$。我们通过 $\\rho(3,3)$ 单独反转区块 $-3$。\n- **新排列：** $\\pi_2 = (+1, +2, +3, -4, -5, +6)$。\n- 这次反转打破了邻接关系 $(+2,-3)$ 和 $(-3,-4)$，对应于 $\\pi_1$ 图中的黑边 $(4,6)$ 和 $(5,8)$。这两条边都属于循环 $(4,6,7,10,11,9,8,5)$。反转创建了新的邻接关系 $(+2,+3)$ 和 $(+3,-4)$，对应新的黑边 $(4,5)$ 和 $(6,8)$。\n- **对循环的影响：** 新的黑边 $(4,5)$ 同时也是一条灰边，形成一个新的二元循环 $(4,5)$。它所属的原循环的剩余部分形成了新的循环 $(6,8,9,11,10,7)$。\n- **循环数：** $c_2 = c_1 + 1 = 4+1 = 5$。\n- **新增广序列：** 对于 $\\pi_2 = (+1, +2, +3, -4, -5, +6)$：$S_2 = (0, 1, 2, 3, 4, 5, 6, 8, 7, 10, 9, 11, 12, 13)$。\n- **新断点数：** 断点位于 $(6,8), (8,7), (7,10), (10,9), (9,11)$。因此，$B_2=5$。\n\n**反转 3：**\n我们通过 $\\rho(4,4)$ 反转区块 $-4$ 来修复 $\\pi_2$ 中的邻接关系 $(+3,-4)$。\n- **新排列：** $\\pi_3 = (+1, +2, +3, +4, -5, +6)$。\n- 这次反转打破了邻接关系 $(+3,-4)$ 和 $(-4,-5)$，对应于 $\\pi_2$ 图中循环 $(6,8,9,11,10,7)$ 内的黑边 $(6,8)$ 和 $(7,10)$。形成了新的邻接关系 $(+3,+4)$ 和 $(+4,-5)$，对应新的黑边 $(6,7)$ 和 $(8,10)$。\n- **对循环的影响：** 黑边 $(6,7)$ 同时也是一条灰边，创建了循环 $(6,7)$。剩余的循环是 $(8,10,11,9)$。\n- **循环数：** $c_3 = c_2 + 1 = 5+1 = 6$。\n- **新增广序列：** 对于 $\\pi_3 = (+1, +2, +3, +4, -5, +6)$：$S_3 = (0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 9, 11, 12, 13)$。\n- **新断点数：** 断点位于 $(8,10), (10,9), (9,11)$。因此，$B_3=3$。\n\n**反转 4：**\n最后，我们通过 $\\rho(5,5)$ 反转区块 $-5$ 来修复 $\\pi_3$ 中的邻接关系 $(+4,-5)$。\n- **新排列：** $\\pi_4 = (+1, +2, +3, +4, +5, +6) = \\pi_{\\mathcal{B}}$。\n- 这次反转打破了邻接关系 $(+4,-5)$ 和 $(-5,+6)$，即来自循环 $(8,10,11,9)$ 的黑边 $(8,10)$ 和 $(9,11)$。它创建了邻接关系 $(+4,+5)$ 和 $(+5,+6)$，对应黑边 $(8,9)$ 和 $(10,11)$。\n- **对循环的影响：** 两条新的黑边 $(8,9)$ 和 $(10,11)$ 同时也是灰边。它们形成两个新的二元循环，将四元循环分裂。虽然这创建了两个新循环，但由于一个循环被分解为两个，单次反转操作的净循环数变化仍为+1。\n- **循环数：** $c_4 = c_3 + 1 = 6+1=7$。\n- **新增广序列：** 对于 $\\pi_4$：$S_4 = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13)$。\n- **新断点数：** 不存在满足 $v_{k+1} \\neq v_k+1$ 的对 $(v_k, v_{k+1})$。因此，$B_4=0$。\n\n我们通过 $4$ 次反转达到了单位排列。\n\n**最小性证明：**\n问题允许我们使用两个事实：\n1. 单次反转能带来的循环数最大增量为 $\\Delta c_{max} = 1$。\n2. $n$ 个区块上的单位排列的断点图恰好有 $n+1$ 个循环。\n\n初始排列 $\\pi_{\\mathcal{A}}$ 的断点图有 $c_0 = 3$ 个循环。\n目标排列 $\\pi_{\\mathcal{B}}$ 的断点图有 $c_{target} = n+1 = 6+1 = 7$ 个循环。\n所需的循环总增量为 $\\Delta c_{total} = c_{target} - c_0 = 7 - 3 = 4$。\n\n设 $d$ 为反转次数。循环总变化量是每次反转变化量的总和：$\\sum_{k=1}^{d} \\Delta c_k = \\Delta c_{total}$。\n由于每次反转都有 $\\Delta c_k \\le 1$，所以最小反转次数 $d_{min}$ 必须满足：\n$$ d_{min} \\ge \\frac{\\Delta c_{total}}{\\Delta c_{max}} = \\frac{4}{1} = 4 $$\n反转次数的下界是 $4$。我们已经演示了一个恰好包含 $4$ 次反转的序列，该序列将 $\\pi_{\\mathcal{A}}$ 转换为 $\\pi_{\\mathcal{B}}$。因此，这个序列是最小的。\n最小反转次数是 $4$。", "answer": "$$\\boxed{4}$$", "id": "2854174"}, {"introduction": "真实世界的基因组由于基因重复等事件，并非简单的排列组合，这给研究带来了挑战。本练习 [@problem_id:2854124] 旨在挑战您批判性地评估重复基因如何打破标准模型的假设，并探索扩展这些模型的原则性方法。这将培养您为适应真实生物数据的复杂性而调整理论框架的关键技能。", "problem": "比较同线性分析的一个基石是将每个基因组建模为一个带符号的、唯一标记的标记物的有序序列，并测量需要多少次片段倒位（逆转）才能将一个基因组的顺序转换为另一个基因组的顺序。在这个经典模型中，每个标记物恰好出现一次，因此该顺序是 $n$ 个不同元素上的一个带符号排列。因此，逆转距离是定义在标记物集合之间的双射上的，并且是相对于一个良定义的邻接结构来计算的。然而，在真实的基因组中，基因重复是常见的。考虑两个线性基因组，每个基因组都在基因家族和方向的层面上进行了注释，其中基因家族 $B$ 发生了重复，因此两个基因组都携带了 $B$ 的两个拷贝。设\n- $G_1 = (+A,\\,+B,\\,+B,\\,+C)$ 且\n- $G_2 = (+B,\\,+C,\\,+B,\\,+A)$，\n其中 $+X$ 表示家族 $X$ 的正向。假设为单染色体、线性基因组。您可以使用的基本事实包括：(i) 经典的逆转距离要求标记物集合之间存在一一对应关系；(ii) 线性基因顺序的邻接点和断点的概念，其中长度为 $n$ 的顺序有 $n-1$ 个内部邻接点，并且每次逆转最多可以消除 $2$ 个断点；(iii) 双断裂与连接 (DCJ) 模型（Double Cut and Join (DCJ)），其中逆转是一个特例，在没有重复基因的情况下，该模型给出了逆转距离的一个下界。不应假设任何其他快捷公式。\n\n任务：识别以下哪个选项正确解释了为什么重复基因违反了标准逆转距离的假设，并提出一个有原则的修改或映射，使得能够对含有重复基因的情况进行近似距离计算。您的推理应基于上述基本定义，并且对于具体的一对 $(G_1,G_2)$，应量化至少一个与所选修改或映射一致的非平凡界。\n\n选择所有适用项。\n\nA. 重复基因为代表基因组的带符号排列所需的双射关系带来了破坏。一个实用的修改是在每个基因组中为每个基因家族选择一个单一的范例以获得两个带符号排列，然后计算这些范例上的逆转距离。在所有范例选择中取最小值得到的“范例逆转距离”，为真实的、考虑了重复的逆转距离提供了一个下界；在实践中，可以通过在邻接图上使用最大匹配启发式算法来最大化共享邻接点，从而近似这个最小化过程。\n\nB. 重复基因可以通过将一个家族的所有拷贝在每个基因组中替换为单个出现来进行折叠，之后在折叠后的顺序上计算的标准逆转距离，等于对重复基因组所需的真实最小逆转次数，无论拷贝如何排列。\n\nC. 可以任意标记重复的拷贝以获得一个带符号排列，并计算标准逆转距离。因为所有标记方式在重标记对称性下是等价的，所以该距离与重复基因如何被标记无关。\n\nD. 一个考虑重复的匹配模型在基因组之间映射拷贝：为每个家族的拷贝之间选择一个双射，以在唯一标记物上导出一个带符号排列，然后在导出的实例上计算一个经典距离（例如，DCJ 或逆转距离）。在所有这类匹配上最小化所得到的距离，会得到真实考虑重复的逆转距离的一个下界；这个最小化过程可以通过在断点图中的最大环或最大邻接匹配来近似。\n\nE. 重复基因应被视为基因家族上的实值权重；计算家族权重剖面之间的推土机距离 (EMD)，忽略顺序，会得到一个可证明对所有输入都等于考虑重复的逆转距离的量。", "solution": "对问题陈述进行验证。\n\n### 第一步：提取已知条件\n-   基因组被建模为带符号的、唯一标记的标记物的有序序列。标准模型适用于带符号排列（标记物集合之间的双射）。\n-   问题引入了基因重复，破坏了一一对应关系。\n-   给定了两个线性基因组：\n    -   $G_1 = (+A,\\,+B,\\,+B,\\,+C)$\n    -   $G_2 = (+B,\\,+C,\\,+B,\\,+A)$\n-    基本事实：\n    1.  经典的逆转距离要求标记物一一对应。\n    2.  为线性顺序定义了邻接点和断点。对于长度为 $n$ 的序列，有 $n-1$ 个内部邻接点。一次逆转最多可以修复 $2$ 个断点。\n    3.  双断裂与连接 (DCJ) 距离是排列的逆转距离的一个下界。\n-   任务：评估解释重复基因问题的选项，并提出有原则的修改，包括为给定的 $(G_1, G_2)$ 对计算一个非平凡的界。\n\n### 第二步：使用提取的已知条件进行验证\n该问题在科学和数学上是合理的。它解决了一个计算基因组学中基本且众所周知的挑战：扩展基因组重排模型以处理非唯一的基因内容。这些概念——逆转距离、带符号排列、断点、邻接点、DCJ 和基因重复——都是该领域的标准概念。该问题是良定义的，提供了清晰的背景、一个具体的例子和一套用于推理的既定原则。它是客观的，并且不包含事实错误、矛盾或歧义。\n\n### 第三步：结论与行动\n该问题是**有效的**。将对各选项进行全面分析。\n\n### 问题分析\n基因重复引发的核心问题是两个基因组的基因集合之间的双射映射被破坏。一个带符号排列要求每个元素恰好出现一次。当像 $B$ 这样的基因家族以多个拷贝的形式出现时，如在 $G_1$ 和 $G_2$ 中，就不再存在一个规范的一一对应关系。$G_1$ 中的第一个 $B$ 拷贝可能对应 $G_2$ 中的第一个或第二个 $B$ 拷贝。必须解决这种歧义，才能应用基于排列的距离算法。因此，一个有原则的修改必须解决重复基因的这种“匹配问题”。\n\n我们基于这个核心要求来分析每个选项。\n\n### 逐项分析\n\n**A. 重复基因为代表基因组的带符号排列所需的双射关系带来了破坏。一个实用的修改是在每个基因组中为每个基因家族选择一个单一的范例以获得两个带符号排列，然后计算这些范例上的逆转距离。在所有范例选择中取最小值得到的“范例逆转距离”，为真实的、考虑了重复的逆转距离提供了一个下界；在实践中，可以通过在邻接图上使用最大匹配启发式算法来最大化共享邻接点，从而近似这个最小化过程。**\n\n这个陈述是正确的。\n1.  **对问题的解释**：它正确地指出了重复基因破坏了带符号排列所需的双射关系。\n2.  **提出的修改**：“范例模型”是一个已知的、有原则的简化方法。通过为每个基因家族选择一个拷贝，问题被简化为一个标准的排列问题，从而可以计算距离。\n3.  **界的正确性**：所得到的“范例距离”，在所有选择上取最小值，是一个更完整的模型（该模型追踪所有基因拷贝，如选项 D 中的模型）中距离的有效下界。在完整基因组上的一个最优逆转序列可以投影到所选的范例上，从而为范例生成一个有效（但不一定最优）的逆转序列。这个投影序列的长度小于或等于原始长度。因此，最优的范例距离不能超过最优的完整基因组距离。\n4.  **启发式方法**：最大化共享邻接点是最小化基于断点的距离的正确且标准的启发式方法。\n5.  **对 $(G_1, G_2)$ 的量化**：\n    -   $G_1 = (+A,\\,+B,\\,+B,\\,+C)$。对 $B$ 的任何范例选择都会得到顺序 $(+A, +B, +C)$。\n    -   $G_2 = (+B,\\,+C,\\,+B,\\,+A)$。对 $B$ 的任何范例选择都会得到顺序 $(+B, +C, +A)$。\n    -   我们必须找到 $\\pi_1 = (+A, +B, +C)$ 和 $\\pi_2 = (+B, +C, +A)$ 之间的逆转距离。这等同于当 $A=1, B=2, C=3$ 时，对排列 $p = \\pi_2 \\circ \\pi_1^{-1} = (+2, +3, +1)$ 进行排序的距离。\n    -   带有端粒 $T_0, T_4$ 的扩展线性排列是 $p_{ext} = (T_0, +2, +3, +1, T_4)$。目标是 $(T_0, +1, +2, +3, T_4)$。\n    -   $p_{ext}$ 中的邻接点：$(T_0, +2), (+2, +3), (+3, +1), (+1, T_4)$。\n    -   目标中的邻接点：$(T_0, +1), (+1, +2), (+2, +3), (+3, T_4)$。\n    -   有一个共享邻接点 $(+2, +3)$。在总共 $n-1+2=4$ 个邻接点中，有 $3$ 个是断裂的。\n    -   断点数为 $3$。由于每次逆转最多可以消除 $2$ 个断点，逆转距离的下界是 $\\lceil \\text{断点数} / 2 \\rceil = \\lceil 3/2 \\rceil = 2$。这是一个非平凡的界。\n该选项内部一致且事实正确。\n结论：**正确**。\n\n**B. 重复基因可以通过将一个家族的所有拷贝在每个基因组中替换为单个出现来进行折叠，之后在折叠后的顺序上计算的标准逆转距离，等于对重复基因组所需的真实最小逆转次数，无论拷贝如何排列。**\n\n这个陈述是不正确的。\n第一部分，折叠重复基因，等同于选项 A 中的范例方法。然而，声称所得距离“等于真实的最小逆转次数……无论拷贝如何排列”是错误的。重复拷贝的排列和相对方向包含着关键信息，这些信息在折叠后会丢失。例如，如果 $G_1 = (+A, +B, -B)$ 而 $G_2 = (+A, +B, +B)$，将两者都折叠会得到 $(+A, +B)$，距离为 $0$。然而，$G_1$ 和 $G_2$ 并不相同，至少需要一次逆转才能将一个转换为另一个。“相等”的说法过于绝对，而且明显是错误的。\n结论：**不正确**。\n\n**C. 可以任意标记重复的拷贝以获得一个带符号排列，并计算标准逆转距离。因为所有标记方式在重标记对称性下是等价的，所以该距离与重复基因如何被标记无关。**\n\n这个陈述是不正确的。其核心论点，即所得距离与标记方式无关，是错误的。不同的标记方式对应着关于基因拷贝之间同源关系的不同假设，从而导致具有不同距离的不同排列实例。\n让我们用 $(G_1, G_2)$ 来证明：\n-   $G_1 = (+A, +B_1, +B_2, +C)$ 在标记其拷贝后。\n-   **匹配 1**：将 $G_1$ 中的第一个 $B$ 映射到 $G_2$ 中的第一个 $B$，以此类推。这得到 $G_2' = (+B_1, +C, +B_2, +A)$。\n    -   $G_1$ 中的邻接点：$(A, B_1), (B_1, B_2), (B_2, C)$。\n    -   $G_2'$ 中的邻接点：$(B_1, C), (C, B_2), (B_2, A)$。\n    -   共享邻接点数量：$0$。\n-   **匹配 2**：将 $G_1$ 中的第一个 $B$ 映射到 $G_2$ 中的第二个 $B$，并将 $G_1$ 中的第二个 $B$ 映射到 $G_2$ 中的第一个 $B$。这得到 $G_2'' = (+B_2, +C, +B_1, +A)$。\n    -   $G_1$ 中的邻接点：$(A, B_1), (B_1, B_2), (B_2, C)$。\n    -   $G_2''$ 中的邻接点：$(B_2, C), (C, B_1), (B_1, A)$。\n    -   共享邻接点数量：$1$（邻接点 $(+B_2, +C)$）。\n由于共享邻接点的数量不同，断点的数量也不同，因此逆转距离通常也会不同。独立性的说法是错误的。\n结论：**不正确**。\n\n**D. 一个考虑重复的匹配模型在基因组之间映射拷贝：为每个家族的拷贝之间选择一个双射，以在唯一标记物上导出一个带符号排列，然后在导出的实例上计算一个经典距离（例如，DCJ 或逆转距离）。在所有这类匹配上最小化所得到的距离，会得到真实考虑重复的逆转距离的一个下界；这个最小化过程可以通过在断点图中的最大环或最大邻接匹配来近似。**\n\n这个陈述是正确的。\n1.  **提出的修改**：这描述了计算含有重复基因的基因组之间重排距离的标准且最完整的表述（在仅考虑逆转的模型中）。它正确地将问题形式化为寻找一个能最小化重排距离的基因拷贝的最优匹配。\n2.  **界的正确性**：它将所得距离描述为“真实考虑重复的逆转距离的一个下界”。这是一个正确且精辟的陈述。“真实”距离可以被概念化为一个更抽象、更复杂的数学对象（例如，多重集上的图）上的距离，对于这个距离，在所有排列实例上进行最小化可以作为一个可计算的下界。另外，如果“真实”距离允许其他操作如基因插入/删除，那么在一组固定的基因上的仅逆转距离通常是一个上界。然而，在从第一性原理定义问题的理论背景下，前一种解释是标准的。该过程在仅逆转模型中定义了距离本身。\n3.  **启发式方法**：它正确地指出，这个最小化问题通常通过寻找一个能最大化保守邻接点数量（或在断点/邻接图中的环数）的拷贝匹配来近似，这是一种合理且广泛使用的算法策略。\n4.  **对 $(G_1, G_2)$ 的量化**：如对选项 C 的分析，我们对基因 $B$ 的两个拷贝有两种可能的匹配。\n    -   **匹配 1**：$0$ 个共享邻接点，因此有 $5$ 个断点（包括端粒）。$d_{rev} \\ge \\lceil 5/2 \\rceil = 3$。\n    -   **匹配 2**：$1$ 个共享邻接点，因此有 $4$ 个断点。$d_{rev} \\ge \\lceil 4/2 \\rceil = 2$。\n    因此，在所有匹配中，最小距离至少为 $2$。这提供了一个非平凡的界。\n该选项为标准理论模型提供了正确而完整的描述。\n结论：**正确**。\n\n**E. 重复基因应被视为基因家族上的实值权重；计算家族权重剖面之间的推土机距离 (EMD)，忽略顺序，会得到一个可证明对所有输入都等于考虑重复的逆转距离的量。**\n\n这个陈述是不正确的。它在多个层面上都存在概念性缺陷。\n1.  **忽略顺序**：逆转距离本质上是衡量*基因顺序*差异的指标。任何“忽略顺序”的度量都不可能与逆转距离相关，更不用说“可证明相等”了。\n2.  **EMD 应用**：对于给定的基因组 $G_1$ 和 $G_2$，它们的“家族权重剖面”是相同的：一个 $A$ 的拷贝，两个 $B$ 的拷贝，一个 $C$ 的拷贝。两个相同分布之间的推土机距离为 $0$。而逆转距离显然非零。\n3.  **“可证明相等”**：这个强烈的论断可由上述一点轻易证伪。\n这个选项将一个组合测序问题与一个统计分布比较问题混为一谈。\n结论：**不正确**。", "answer": "$$\\boxed{AD}$$", "id": "2854124"}, {"introduction": "现代比较基因组学常常涉及同时分析数十甚至数百个基因组。本练习 [@problem_id:2854131] 将指导您实现一个基于图的算法，用以检测跨多个基因组的保守基因顺序，即便该顺序被间隙所打断。您将学习如何利用图的传递性来推断“隐藏”的演化关系，这项技术是许多现代同线性分析工具的核心。", "problem": "给定多个基因组，每个基因组表示为基因家族标识符的有序列表。基因家族是一组源自共同祖先的同源基因；根据分子生物学中心法则和比较基因组学的原理，同源性意味着从序列相似性和系统发育推断出的共同祖先。跨基因组的保守基因顺序（共线性）可以建模为一个图论问题，其中节点是基因家族，边编码了允许间隙（简并共线性）的支持性优先约束。\n\n设计并实现一个程序，对于每个测试用例，构建一个跨基因组的共有优先图，并使用图的传递性来推断隐藏的锚点，具体如下。\n\n基本定义和假设：\n- 每个基因组是一个整数的有序列表；每个整数是一个基因家族标识符。如果一个家族在基因组中多次出现，仅使用其最左侧的出现位置来定义该基因组中的顺序（这在构建锚点时，为重复基因模拟了一种保守的选择）。\n- 设有一组基因组 $\\mathcal{G}$ 和两个整数参数：最大间隙 $k$ 和最小支持阈值 $t$。\n- 将家族的共现集合 $V$ 定义为在 $\\mathcal{G}$ 中至少出现于 $t$ 个基因组的那些基因家族。\n- 对于一个基因组 $G \\in \\mathcal{G}$，其在 $V$ 上的基因组内邻接集合 $E_G(k)$ 定义如下：如果 $a \\in V$ 和 $b \\in V$ 都出现在 $G$ 中，且 $a$ 位于 $b$ 之前，并且 $G$ 中 $b$ 的最左侧出现位置与 $a$ 的最左侧出现位置的索引差最多为 $k$，则包含有向对 $(a,b)$。\n- 将有向对 $(a,b)$ 的跨基因组支持度定义为 $s(a,b) = \\left| \\{ G \\in \\mathcal{G} : (a,b) \\in E_G(k) \\} \\right|$。\n- 定义基础共有图 $G_t = (V, E_t)$，其中 $E_t = \\{ (a,b) : s(a,b) \\ge t \\}$。\n- 假设 $G_t$ 必须是无环的，以模拟一致的共有顺序。如果 $G_t$ 包含环，则迭代地移除环内具有最小 $s(a,b)$ 值的边，直到图变为无环。\n- 令 $\\mathrm{clo}(G_t)$ 表示 $G_t$ 的传递闭包（所有可达的有序对）。\n- 定义一个隐藏锚点为一个有序对 $(a,b)$，它属于 $\\mathrm{clo}(G_t)$，满足 $a \\ne b$，并且在任何单个基因组中间隙约束下的直接支持度为零，即 $s(a,b) = 0$。直观地说，图的传递性揭示了 $(a,b)$ 是一个隐含的共线性关系，即使在任何 $E_G(k)$ 中都从未直接观察到它。\n\n对于每个测试用例，计算：\n- $L$：无环基础共有图 $G_t$ 中最长路径的节点长度（这是共有关系下最大简并共线性块的大小）。\n- $H$：由传递性推断出的隐藏锚点数量，定义为满足 $a \\ne b$ 且在 $\\mathrm{clo}(G_t)$ 中但 $s(a,b)=0$ 的有序对 $(a,b)$ 的数量。\n\n如果 $V$ 为空，则定义 $L=0$ 和 $H=0$。\n\n您的程序必须精确实现上述定义，并为每个测试用例生成 $[L, H]$。\n\n测试套件（每个案例指定一个基因组列表，然后是 $k$ 和 $t$）：\n- 案例 1（由传递性恢复简并性的正常路径）：\n  - 基因组：$G_1 = [1,2,3,4]$，$G_2 = [1,2,4,3]$，$G_3 = [5,1,2,3,4,6]$\n  - 参数：$k=1$，$t=2$\n- 案例 2（单基因组边界；通过传递性出现隐藏锚点）：\n  - 基因组：$G_1 = [10,20,30]$\n  - 参数：$k=1$，$t=1$\n- 案例 3（重复家族处理且无共有边）：\n  - 基因组：$G_1 = [1,2,2,3]$，$G_2 = [1,3,2]$\n  - 参数：$k=1$，$t=2$\n- 案例 4（多基因组，更大的间隙容忍度，完全支持的链）：\n  - 基因组：$G_1 = [7,1,2,3,8]$，$G_2 = [1,4,2,3]$，$G_3 = [9,1,2,5,3]$\n  - 参数：$k=2$，$t=2$\n- 案例 5（没有家族满足共现阈值的边缘案例）：\n  - 基因组：$G_1 = [1,2]$，$G_2 = [3,4]$\n  - 参数：$k=1$，$t=2$\n\n最终输出格式：\n- 您的程序应生成一行输出，包含一个用方括号括起来的逗号分隔列表，其中每个案例的结果是一个双元素列表 $[L,H]$。例如：$[[L_1,H_1],[L_2,H_2],\\dots]$。\n- 所有输出 $L$ 和 $H$ 都必须是整数。", "solution": "该问题要求设计一种算法来分析多个基因组间的共线性（即保守的基因顺序）。这是通过构建一个共有优先图、解决不一致性，并通过传递性推断非显而易见的关系来完成的。该解决方案通过一系列离散且定义明确的步骤有条不紊地进行。根据问题规范的要求，每个数学符号、变量或数字都使用 LaTeX 排版。\n\n该算法对每个测试用例执行，每个测试用例提供一组基因组 $\\mathcal{G}$、一个最大间隙参数 $k$ 和一个最小支持阈值 $t$。\n\n**步骤 1：共现集合与支持度计算**\n\n首先，我们确定用于跨基因组比较的相关基因家族集合。共现集合，表示为 $V$，被定义为在 $\\mathcal{G}$ 中至少出现于 $t$ 个基因组的所有基因家族的集合。如果 $V$ 为空，则无法形成共有关系；因此，最大共线性块的长度 $L$ 和隐藏锚点的数量 $H$ 均为 $0$，该测试用例的处理终止。\n\n对于每个基因组 $G \\in \\mathcal{G}$，我们建立来自 $V$ 的基因家族之间的优先关系。问题指定仅使用基因家族在基因组内最左侧的出现位置来定义其位置。这为每个家族在每个基因组中提供了一个唯一的索引。如果 $a$ 出现在 $b$ 之前，并且它们的位置足够近，那么一对有向的基因家族 $(a,b)$（其中 $a,b \\in V$）被认为在基因组 $G$ 中是一个受支持的邻接关系。这构成了基因组内邻接集合 $E_G(k)$，其中，如果 $b$ 最左侧出现位置的索引减去 $a$ 最左侧出现位置的索引大于 $0$ 且不大于 $k$，则 $(a,b) \\in E_G(k)$。\n\n然后计算任意给定有序对 $(a,b)$ 的跨基因组支持度，记为 $s(a,b)$。此支持度是 $\\mathcal{G}$ 中包含该对 $(a,b)$ 在其各自邻接集合中的基因组总数，即 $s(a,b) = \\left| \\{ G \\in \\mathcal{G} : (a,b) \\in E_G(k) \\} \\right|$。这对所有可能的对 $(a,b)$（其中 $a,b \\in V$）进行计算。\n\n**步骤 2：共有图的构建与无环化**\n\n利用计算出的支持度，我们构建基础共有图 $G_t = (V, E_t)$。顶点集是共现集合 $V$，当且仅当其支持度达到最小阈值，即 $s(a,b) \\ge t$ 时，边 $(a,b)$ 才存在于边集 $E_t$ 中。\n\n一致的基因顺序不能包含环（例如，$a$ 在 $b$ 之前，$b$ 在 $c$ 之前，而 $c$ 又在 $a$ 之前）。因此，图 $G_t$ 必须是一个有向无环图（DAG）。如果构建的 $G_t$ 包含环，则必须将其打破。指定的过程是迭代地识别一个环，找到该环内具有最小支持度值 $s(a,b)$ 的边，并移除这样的一条边。为了在出现平局（即一个环中有多条边共享相同的最小支持度）时确保确定性的结果，会应用一个决胜规则，例如移除字典序最小的边 $(u,v)$。重复此过程，直到图中不再有环。得到的无环图是最终的共有图，我们可以称之为 $G'_t$。\n\n**步骤 3：传递闭包与最长路径 ($L$) 计算**\n\n无环图 $G'_t$ 的传递闭包，记为 $\\mathrm{clo}(G'_t)$，揭示了所有隐含的优先关系。如果从节点 $a$ 到节点 $b$ 在 $G'_t$ 中存在一条路径，则有序对 $(a,b)$ 就在 $\\mathrm{clo}(G'_t)$ 中。传递闭包可以使用诸如在 $G'_t$ 的邻接矩阵上运行 Floyd-Warshall 算法，或从 $V$ 中的每个节点执行深度优先搜索（DFS）或广度优先搜索（BFS）来高效计算。\n\n值 $L$ 代表 $G'_t$ 中最长路径的长度（以节点数计）。由于 $G'_t$ 是一个 DAG，这可以使用动态规划来解决。首先，获得 $V$ 中节点的拓扑排序。然后，按拓扑顺序遍历节点，我们可以计算以每个节点结束的最长路径的长度。设 $dp[u]$ 为以节点 $u$ 结束的最长路径的长度。递推关系为对于每条边 $(u,v)$，$dp[v] = \\max(dp[v], dp[u] + 1)$。所有节点 $u$ 的基础情况是 $dp[u] = 1$。$L$ 的最终值是 $dp$ 数组中的最大值。如果 $V$ 非空，$L$ 至少为 $1$。\n\n**步骤 4：隐藏锚点 ($H$) 计算**\n\n隐藏锚点是一个有序对 $(a,b)$，它代表一个由其他受支持的邻接关系链推断出的保守基因排序，但在任何单个基因组中从未被直接观察到具有足够的邻近度。形式上，如果一对 $a \\ne b$ 的有序对 $(a,b)$ 满足两个条件，则它是一个隐藏锚点：\n1. 该对在最终无环图的传递闭包中：$(a,b) \\in \\mathrm{clo}(G'_t)$。\n2. 该对在所有基因组中的直接支持度为零：$s(a,b) = 0$。\n\n为了计算 $H$，我们遍历传递闭包中存在的所有对 $(a,b)$。对于每个这样的对，我们检查其预先计算的支持度值 $s(a,b)$。如果支持度为 $0$，我们增加 $H$ 的计数器。最终的计数就是隐藏锚点的总数。\n\n这样就完成了为给定测试用例确定 $L$ 和 $H$ 的完整算法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import Counter, defaultdict\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        ({'genomes': [[1, 2, 3, 4], [1, 2, 4, 3], [5, 1, 2, 3, 4, 6]], 'k': 1, 't': 2}, [4, 2]),\n        # Case 2\n        ({'genomes': [[10, 20, 30]], 'k': 1, 't': 1}, [3, 1]),\n        # Case 3\n        ({'genomes': [[1, 2, 2, 3], [1, 3, 2]], 'k': 1, 't': 2}, [1, 0]),\n        # Case 4\n        ({'genomes': [[7, 1, 2, 3, 8], [1, 4, 2, 3], [9, 1, 2, 5, 3]], 'k': 2, 't': 2}, [3, 0]),\n        # Case 5\n        ({'genomes': [[1, 2], [3, 4]], 'k': 1, 't': 2}, [0, 0]),\n    ]\n\n    results = []\n    for case_data, _ in test_cases:\n        result = _solve_one_case(case_data['genomes'], case_data['k'], case_data['t'])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _solve_one_case(genomes, k, t):\n    \"\"\"\n    Solves a single test case for synteny analysis.\n    \"\"\"\n    # Step 1: Determine the co-occurrence set V\n    if not genomes:\n        return [0, 0]\n    \n    gene_counts = Counter()\n    for genome in genomes:\n        gene_counts.update(set(genome))\n    \n    V = {gene for gene, count in gene_counts.items() if count >= t}\n    if not V:\n        return [0, 0]\n\n    nodes = sorted(list(V))\n    node_to_idx = {node: i for i, node in enumerate(nodes)}\n    num_nodes = len(nodes)\n\n    # Step 2: Pre-process genomes for leftmost indices\n    genome_indices = []\n    for genome in genomes:\n        indices = {}\n        for i, gene in enumerate(genome):\n            if gene in V and gene not in indices:\n                indices[gene] = i\n        genome_indices.append(indices)\n\n    # Step 3: Compute supports s(a,b)\n    supports = defaultdict(int)\n    for indices in genome_indices:\n        present_genes = sorted(list(indices.keys()))\n        for i in range(len(present_genes)):\n            for j in range(len(present_genes)):\n                if i == j:\n                    continue\n                gene_a, gene_b = present_genes[i], present_genes[j]\n                idx_a, idx_b = indices[gene_a], indices[gene_b]\n                \n                if idx_a  idx_b and idx_b - idx_a = k:\n                    supports[(gene_a, gene_b)] += 1\n\n    # Step 4: Construct base consensus graph G_t\n    edges = {pair for pair, sup in supports.items() if sup >= t}\n\n    # Step 5: Make the graph acyclic\n    adj = {node: [] for node in nodes}\n    for u, v in edges:\n        adj[u].append(v)\n\n    while True:\n        recursion_stack = set()\n        visited = set()\n        pred = {}\n        cycle_nodes_path = None\n\n        def _find_cycle_dfs(u):\n            nonlocal cycle_nodes_path\n            visited.add(u)\n            recursion_stack.add(u)\n            \n            # Deterministic traversal\n            for v in sorted(adj.get(u, [])):\n                if cycle_nodes_path: return\n                \n                pred[v] = u\n                if v in recursion_stack:\n                    # Cycle detected: from u to v\n                    path = [v]\n                    curr = u\n                    while curr != v:\n                        path.append(curr)\n                        curr = pred[curr]\n                    path.reverse()\n                    cycle_nodes_path = [u] + path\n\n                    return\n                if v not in visited:\n                    _find_cycle_dfs(v)\n            \n            recursion_stack.remove(u)\n        \n        for node in nodes:\n            if node not in visited:\n                _find_cycle_dfs(node)\n                if cycle_nodes_path: break\n        \n        if not cycle_nodes_path:\n            break # No more cycles\n\n        # A cycle was found, identify and break the weakest link\n        cycle_edges = []\n        for i in range(len(cycle_nodes_path) - 1):\n             cycle_edges.append((cycle_nodes_path[i], cycle_nodes_path[i+1]))\n        cycle_edges.append((cycle_nodes_path[-1], cycle_nodes_path[0]))\n        \n        min_support = float('inf')\n        weakest_edges = []\n        for u, v in cycle_edges:\n            if (u,v) not in edges: continue # Edge might have been removed in a prior iteration\n            support_val = supports.get((u, v), 0)\n            if support_val  min_support:\n                min_support = support_val\n                weakest_edges = [(u, v)]\n            elif support_val == min_support:\n                weakest_edges.append((u, v))\n        \n        weakest_edges.sort()\n        edge_to_remove = weakest_edges[0]\n        edges.remove(edge_to_remove)\n        adj[edge_to_remove[0]].remove(edge_to_remove[1])\n\n    acyclic_edges = edges\n\n    # Step 6: Compute transitive closure\n    adj_matrix = np.zeros((num_nodes, num_nodes), dtype=bool)\n    for u, v in acyclic_edges:\n        u_idx, v_idx = node_to_idx[u], node_to_idx[v]\n        adj_matrix[u_idx, v_idx] = True\n\n    # Floyd-Warshall for transitive closure\n    closure_matrix = np.copy(adj_matrix)\n    for i_k in range(num_nodes):\n        for i_i in range(num_nodes):\n            for i_j in range(num_nodes):\n                if closure_matrix[i_i, i_k] and closure_matrix[i_k, i_j]:\n                    closure_matrix[i_i, i_j] = True\n    \n    # Step 7: Calculate H (hidden anchors)\n    H = 0\n    for i in range(num_nodes):\n        for j in range(num_nodes):\n            if i == j: continue\n            if closure_matrix[i, j]:\n                u, v = nodes[i], nodes[j]\n                if supports.get((u, v), 0) == 0:\n                    H += 1\n\n    # Step 8: Calculate L (longest path)\n    if not V:\n        L = 0\n    elif not acyclic_edges:\n        L = 1\n    else:\n        # Topological Sort\n        topo_order = []\n        visited = set()\n        \n        adj_final = {node: [] for node in nodes}\n        for u, v in acyclic_edges:\n            adj_final[u].append(v)\n            \n        def topo_dfs(u):\n            visited.add(u)\n            for v in sorted(adj_final.get(u, [])):\n                if v not in visited:\n                    topo_dfs(v)\n            topo_order.append(u)\n\n        for node in nodes:\n            if node not in visited:\n                topo_dfs(node)\n        topo_order.reverse()\n        \n        # Longest path DP\n        dist = {node: 1 for node in nodes}\n        for u in topo_order:\n            for v in sorted(adj_final.get(u, [])):\n                dist[v] = max(dist[v], dist[u] + 1)\n        \n        L = max(dist.values()) if dist else 1\n\n    return [L, H]\n\n\nsolve()\n```", "id": "2854131"}]}