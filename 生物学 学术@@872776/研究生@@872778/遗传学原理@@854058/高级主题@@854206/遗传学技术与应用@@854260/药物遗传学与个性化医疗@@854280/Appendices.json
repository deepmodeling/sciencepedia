{"hands_on_practices": [{"introduction": "`CYP2D6` 是药物代谢中的一个关键酶，其基因变异（包括拷贝数变异）会显著影响个体对药物的代谢能力。为了将复杂的基因型转化为可预测的代谢表型并标准化临床建议，临床药理遗传学实施联盟 (CPIC) 等机构建立了“活性评分”系统。本练习将让你亲手实践这一关键的转化过程，这是解读药理遗传学测试报告的一项核心技能 [@problem_id:2836780]。", "problem": "一家临床药物基因组学实验室使用长读长测序、读段支持的定相和定量拷贝数判定技术，分析了个体的细胞色素P450家族2亚家族D成员6（CYP2D6）基因座。结果显示了以下星号等位基因和拷贝数的定相构型：\n\n- 单倍型1包含两个相同的CYP2D6单元的串联重复，每个单元均被标注为星号等位基因CYP2D6*2。\n- 单倍型2包含一个单一的CYP2D6单元，被标注为星号等位基因CYP2D6*4。\n- 没有证据表明存在所述之外的融合基因或额外拷贝，并且除了所述拷贝数所隐含的之外，没有基因缺失。\n\n请使用以下与临床药物遗传学实施联盟（CPIC）惯例一致的共识框架：\n\n- 功能分类到活性值的映射：正常功能等位基因的活性值为1.0，功能减弱等位基因的活性值为0.5，无功能等位基因的活性值为0.0。\n- 单倍型活性是该单倍型上存在的所有CYP2D6拷贝的活性值之和。个体水平的CYP2D6活性分数是各单倍型活性之和。\n- 按CYP2D6总活性分数划分的表型分组：0为慢代谢者，大于0且小于等于1.0的任何值为中间代谢者，大于等于1.25且小于等于2.25的任何值为正常代谢者，大于2.25的任何值为超快代谢者。\n\n假设根据这些惯例，CYP2D6*2是正常功能等位基因，CYP2D6*4是无功能等位基因。仅使用这些规则，计算该个体的CYP2D6活性分数并对其代谢表型进行分类。请将活性分数作为您的最终数值答案报告（无单位）。无需四舍五入。", "solution": "该问题陈述已经过严格验证，被认为是科学上合理、提法恰当且内部一致的。它呈现了临床药物基因组学中一个标准的、尽管简化的场景，提供了所有必要的定义、数据和规则，以推导出唯一且明确的解。因此，我们可以继续进行分析。\n\n目标是计算个体的`CYP2D6`活性分数，并根据所提供的框架对其代谢表型进行分类。此过程必须严格遵守给定的规则来执行。\n\n首先，我们必须根据问题的功能分类映射，为指定的`CYP2D6`星号等位基因分配数值活性值。\n`CYP2D6*2`等位基因被定义为正常功能等位基因。因此，其活性值为1.0。\n`CYP2D6*4`等位基因被定义为无功能等位基因。因此，其活性值为0.0。\n\n接下来，我们计算两个单倍型中每一个的单倍型活性。问题陈述指出，单倍型活性是该单倍型上存在的所有`CYP2D6`基因拷贝的活性值之和。\n\n对于单倍型$1$，其构型是两个相同的`CYP2D6*2`单元的串联重复。这意味着在这个单倍型上有两个`CYP2D6*2`等位基因的拷贝。单倍型$1$的活性，我们记为$A_{H1}$，是这两个拷贝的活性之和。\n$$ A_{H1} = (\\text{Activity of } CYP2D6*2) + (\\text{Activity of } CYP2D6*2) $$\n$$ A_{H1} = 1.0 + 1.0 = 2.0 $$\n\n对于单倍型$2$，其构型由一个单一的`CYP2D6*4`单元组成。单倍型$2$的活性，记为$A_{H2}$，就是这个单一等位基因的活性。\n$$ A_{H2} = \\text{Activity of } CYP2D6*4 $$\n$$ A_{H2} = 0.0 $$\n\n个体水平的`CYP2D6`总活性分数，我们记为$A_{Total}$，定义为各单倍型活性之和。\n$$ A_{Total} = A_{H1} + A_{H2} $$\n代入计算出的值：\n$$ A_{Total} = 2.0 + 0.0 = 2.0 $$\n\n因此，该个体的`CYP2D6`活性分数为2.0。\n\n最后，我们必须通过将这个总活性分数与提供的表型分组进行比较，来对代谢表型进行分类。\n- 慢代谢者：分数为0。我们的分数不是0。\n- 中间代谢者：分数大于0且小于等于1.0。我们的分数2.0不在此范围$(0, 1.0]$内。\n- 正常代谢者：分数大于等于1.25且小于等于2.25。我们的分数2.0满足此条件，因为$1.25 \\le 2.0 \\le 2.25$。\n- 超快代谢者：分数大于2.25。我们的分数不大于2.25。\n\n该个体被分类为正常代谢者。然而，问题只要求将活性分数作为最终的数值答案。\n计算出的活性分数为2.0。", "answer": "$$\\boxed{2.0}$$", "id": "2836780"}, {"introduction": "虽然活性评分系统提供了一个实用的框架，但理解其生物化学基础至关重要。本练习将深入探讨酶动力学的基本原理，以模拟基因剂量（即活性基因拷贝的数量）如何直接影响代谢速率。通过从米氏方程出发进行推导，你将建立起对代谢能力为何与基因拷贝数成比例的第一性原理理解，从而超越简单的规则记忆，获得更深层次的机理洞察 [@problem_id:2836759]。", "problem": "一个个体携带拷贝数变异 (CNV)，导致其拥有三个细胞色素P450家族2亚家族D成员6 (CYP2D6) 基因的活性拷贝。假设在固定的底物浓度 $[S]$ 下，CYP2D6 的药物代谢遵循 Michaelis–Menten (MM) 动力学，且在初始速率测量过程中底物浓度 $[S]$ 保持不变。假设每个基因拷贝根据分子生物学的中心法则产生酶，且每个拷贝具有相同的转录和翻译效率以及相同的降解动力学，并且每个酶的催化参数在不同拷贝间保持不变。在线性剂量模型中，稳态酶丰度与活性基因拷贝数成正比。\n\n将标准化活性分数 $\\mathcal{A}(n)$ 定义为具有 $n$ 个活性CYP2D6拷贝时的初始反应速率 $v(n)$ 与具有 $2$ 个活性拷贝时的初始反应速率 $v(2)$ 的比值，两者均在相同的固定底物浓度 $[S]$ 下测得：\n$$\n\\mathcal{A}(n) \\equiv \\frac{v(n)}{v(2)}.\n$$\n从上述原理和定义出发，推导 $\\mathcal{A}(n)$ 的闭式表达式，然后在线性剂量模型下计算当 $n=3$ 时的值。从机理上简要解释在线性剂量假设在药物遗传学背景下可能在何种情况以及为何不成立，但最终答案只需报告 $\\mathcal{A}(3)$ 的值。将最终答案表示为一个不带单位的精确数字。", "solution": "该问题要求基于 Michaelis-Menten 动力学和线性基因剂量模型的原理，为一个携带特定基因拷贝数变异的个体推导标准化的酶活性分数。该问题的有效性得以确立，因为其前提在科学上基于酶动力学和分子遗传学，并且问题提法明确。\n\n酶催化反应的初始速率 $v$ 由 Michaelis-Menten 方程描述：\n$$\nv = \\frac{V_{\\text{max}} [S]}{K_M + [S]}\n$$\n此处，$[S]$ 是底物浓度，$K_M$ 是 Michaelis 常数，$V_{\\text{max}}$ 是最大反应速率。$V_{\\text{max}}$ 的值与活性酶的总浓度 $[E]_{\\text{total}}$ 成正比，其关系式为 $V_{\\text{max}} = k_{\\text{cat}} [E]_{\\text{total}}$，其中 $k_{\\text{cat}}$ 是酶的转换数或催化常数。\n\n问题陈述该个体拥有 $n$ 个 CYP2D6 基因的活性拷贝。“线性剂量模型”假设稳态酶丰度与活性基因拷贝数成正比。我们可以将其正式表达为：\n$$\n[E]_{\\text{total}}(n) = c_1 \\cdot n\n$$\n其中 $c_1$ 是一个比例常数，它综合了转录、翻译和蛋白质稳定性的效率，并假设每个基因拷贝的这些效率都是相同的。\n\n将此关系式代入 $V_{\\text{max}}$ 的表达式中，我们发现 $V_{\\text{max}}$ 也是基因拷贝数 $n$ 的线性函数：\n$$\nV_{\\text{max}}(n) = k_{\\text{cat}} [E]_{\\text{total}}(n) = k_{\\text{cat}} (c_1 \\cdot n) = c_2 \\cdot n\n$$\n其中 $c_2 = k_{\\text{cat}} c_1$ 是一个新的常数。\n\n因此，对于一个拥有 $n$ 个基因拷贝的个体，在固定底物浓度 $[S]$ 下，其初始反应速率 $v(n)$ 由下式给出：\n$$\nv(n) = \\frac{V_{\\text{max}}(n) [S]}{K_M + [S]} = \\frac{(c_2 \\cdot n) [S]}{K_M + [S]}\n$$\n问题将标准化活性分数 $\\mathcal{A}(n)$ 定义为 $n$ 个拷贝时的速率与一个具有 $n=2$ 个拷贝的正常二倍体个体的速率之比：\n$$\n\\mathcal{A}(n) \\equiv \\frac{v(n)}{v(2)}\n$$\n我们现在可以将 $v(n)$ 的表达式代入此定义中。当 $n=2$ 个拷贝时，速率为：\n$$\nv(2) = \\frac{(c_2 \\cdot 2) [S]}{K_M + [S]}\n$$\n那么比值为：\n$$\n\\mathcal{A}(n) = \\frac{\\frac{(c_2 \\cdot n) [S]}{K_M + [S]}}{\\frac{(c_2 \\cdot 2) [S]}{K_M + [S]}}\n$$\n项 $\\frac{c_2 [S]}{K_M + [S]}$ 是分子和分母的公因式。由于反应参数（$c_2$, $K_M$）和实验条件（$[S]$）在两次测量中是相同的，只要该项不为零，它就可以被约去。这种简化得出了在线性剂量模型下标准化活性分数的闭式表达式：\n$$\n\\mathcal{A}(n) = \\frac{n}{2}\n$$\n这一结果表明，在此模型中，活性分数与底物浓度和酶的内在动力学参数无关；它仅取决于基因拷贝数。\n\n问题指定了一个拥有三个活性拷贝的个体，所以我们必须计算当 $n=3$ 时的 $\\mathcal{A}(n)$：\n$$\n\\mathcal{A}(3) = \\frac{3}{2} = 1.5\n$$\n这个个体将被归类为超快代谢者，其代谢能力是正常代谢者的1.5倍。\n\n最后，问题要求对线性剂量假设可能失效的原因给出一个简短的机理学解释。假设 $[E]_{\\text{total}} \\propto n$ 意味着每个额外的基因拷贝都对总酶库贡献相等的量。在真实的生物系统中，这种线性关系可能因多种原因而失效。首先，用于基因表达的细胞机制（例如，RNA聚合酶、核糖体、特异性转录因子）是有限的。当拷贝数 $n$ 变得很大时，这些组分之一或多个可能成为限速因素，导致每个基因拷贝产生的酶量减少。这将导致饱和效应，即 $[E]_{\\text{total}}$ 的增加相对于 $n$ 呈次线性关系。类似地，必需辅因子（如P450酶所需的血红素）的可用性或蛋白质折叠和运输机制的限制，也可能在高表达水平上造成瓶颈，从而破坏线性关系。因此，虽然线性模型对于拷贝数的微小变化是一个有用的近似，但它可能会高估非常高的基因扩增所带来的功能性后果。", "answer": "$$\n\\boxed{1.5}\n$$", "id": "2836759"}, {"introduction": "个性化医疗的精髓在于整合遗传易感性与实时患者数据，以动态优化治疗方案。这项高级练习通过构建一个贝叶斯自适应剂量算法来模拟这一过程。在本练习中，你将利用基因型信息来建立患者药物清除率的初始（先验）估计，然后使用治疗药物监测数据来更新这一估计，并计算出真正个性化的下一次给药剂量 [@problem_id:2836657]。这个编程挑战完整地展示了临床反馈回路，连接了遗传学、药代动力学和计算建模。", "problem": "要求您为一个在稳态给药下的单室线性药代动力学系统实现一个贝叶斯自适应给药算法，其中基因型可为清除率提供先验分布信息。该算法必须利用治疗药物监测中观测到的稳态谷浓度来更新清除率的后验分布，并计算以指定的稳态谷浓度为目标的下一次剂量。您程序中的所有量都必须使用下面指定的单位进行处理，并且所有输出必须严格遵循要求的格式。\n\n使用的基本建模假设：\n- 分子生物学中心法则与酶介导的药物代谢：基因序列变异可以改变酶的水平或功能，进而调节药物清除率。清除率定义为单位时间内从血浆中清除药物的体积。\n- 具有线性动力学和一级消除的单室模型，在重复给药下达到稳态。叠加原理和几何衰减意味着，在稳态下，每隔 $\\tau$ 小时给予一次弹丸式剂量 $D$，清除率为 $CL$ (单位 $\\mathrm{L/h}$)，分布容积为 $V$ (单位 $\\mathrm{L}$)，则下一次给药前的稳态谷浓度为\n$$\nC_{\\mathrm{trough}}(CL; D,\\tau,V) \\;=\\; \\frac{D}{V}\\,\\frac{e^{-\\left(\\frac{CL}{V}\\right)\\tau}}{1 - e^{-\\left(\\frac{CL}{V}\\right)\\tau}} \\quad \\text{in mg/L.}\n$$\n- 由基因型信息决定的清除率先验分布：$CL$ 的先验分布为对数正态分布，其对数尺度上的参数由群体典型清除率乘以基因型效应决定。具体来说，令 $CL_{\\mathrm{pop}}$ 表示正常代谢者的典型清除率，令 $g$ 表示基因型乘法因子。那么\n$$\n\\ln(CL) \\sim \\mathcal{N}\\!\\left(\\mu_{\\mathrm{prior}}, \\sigma_{\\mathrm{prior}}^2\\right), \\quad \\mu_{\\mathrm{prior}} = \\ln\\!\\left(g \\cdot CL_{\\mathrm{pop}}\\right).\n$$\n- 谷浓度的残差模型：以 $CL$ 为条件，每个观测到的稳态谷浓度 $y_i$（单位 $\\mathrm{mg/L}$）独立地围绕模型预测值 $C_{\\mathrm{trough}}(CL; D,\\tau,V)$ 服从对数正态分布，其对数残差标准差为 $\\sigma_{\\mathrm{res}}$：\n$$\n\\ln(y_i) \\mid CL \\sim \\mathcal{N}\\!\\left(\\ln\\!\\left(C_{\\mathrm{trough}}(CL; D,\\tau,V)\\right),\\, \\sigma_{\\mathrm{res}}^2\\right).\n$$\n- 贝叶斯更新目标：计算 $CL$ 的后验均值，\n$$\n\\mathbb{E}[CL \\mid \\{y_i\\}] \\;=\\; \\int_{0}^{\\infty} CL \\, p(CL \\mid \\{y_i\\}) \\, dCL,\n$$\n并将其作为置入估计量用于下面的给药方程中。\n\n给药控制目标：\n- 给定目标稳态谷浓度 $C_{\\mathrm{target}}$（单位 $\\mathrm{mg/L}$）和固定给药间隔 $\\tau$（单位 $\\mathrm{h}$），计算在后验均值清除率下预期能达到 $C_{\\mathrm{target}}$ 的下一次剂量 $D_{\\mathrm{next}}$（单位 $\\mathrm{mg}$）。通过求解稳态谷浓度方程中的 $D$（设 $k = \\frac{CL}{V}$）得到\n$$\nD_{\\mathrm{next}} \\;=\\; V \\cdot C_{\\mathrm{target}} \\left(\\exp\\!\\left(\\frac{\\mathbb{E}[CL \\mid \\{y_i\\}]}{V}\\,\\tau\\right) - 1\\right).\n$$\n\n为确保可测试性和可复现性的计算要求：\n- 使用离散网格的数值积分方法来近似 $CL$ 的后验分布：\n  - 在包含端点的 $[0.5, 15.0]$ $\\mathrm{L/h}$ 区间上，使用一个包含 $N = 20001$ 个点的均匀线性网格对 $CL$ 进行划分。\n  - 在每个网格点上评估对数先验和对数似然；将它们相加以获得未归一化的对数后验。为保证数值稳定性，在取指数前减去最大对数值，然后进行归一化以获得总和为 $1$ 的离散后验权重。\n  - 通过网格上的加权和计算后验均值。\n- 先验超参数：\n  - 群体典型清除率 $CL_{\\mathrm{pop}} = 4.5$ $\\mathrm{L/h}$。\n  - 自然对数尺度上的对数先验标准差 $\\sigma_{\\mathrm{prior}} = 0.35$。\n- 残差：\n  - 自然对数尺度上的对数残差标准差 $\\sigma_{\\mathrm{res}} = 0.25$。\n- 基因型到因子 $g$ 的映射：\n  - 正常代谢者 (NM): $g = 1.0$\n  - 中间代谢者 (IM): $g = 0.8$\n  - 慢代谢者 (PM): $g = 0.6$\n  - 超快代谢者 (UM): $g = 1.5$\n\n单位与取整：\n- 清除率 $CL$ 单位为 $\\mathrm{L/h}$，分布容积 $V$ 单位为 $\\mathrm{L}$，给药间隔 $\\tau$ 单位为 $\\mathrm{h}$，浓度单位为 $\\mathrm{mg/L}$，剂量单位为 $\\mathrm{mg}$。\n- 您的程序必须为每个测试用例输出 $D_{\\mathrm{next}}$，单位为 $\\mathrm{mg}$，并四舍五入到最近的整数。\n\n程序输入规范：\n- 没有输入。请将下面的测试套件硬编码到程序中，并生成指定的单行输出。\n\n测试套件：\n对每个案例，使用提供的精确值构成的元组 $(\\text{基因型}, V, \\tau, D_{\\mathrm{prev}}, \\{y_i\\}, C_{\\mathrm{target}})$。\n\n- 案例 1: $\\text{基因型} = \\text{\"NM\"}$, $V = 50$ $\\mathrm{L}$, $\\tau = 12$ $\\mathrm{h}$, $D_{\\mathrm{prev}} = 1000$ $\\mathrm{mg}$, 观测谷浓度 $\\{9.0, 8.5\\}$ $\\mathrm{mg/L}$, $C_{\\mathrm{target}} = 15.0$ $\\mathrm{mg/L}$。\n- 案例 2: $\\text{基因型} = \\text{\"PM\"}$, $V = 50$ $\\mathrm{L}$, $\\tau = 12$ $\\mathrm{h}$, $D_{\\mathrm{prev}} = 1000$ $\\mathrm{mg}$, 观测谷浓度 $\\{22.0, 24.0, 23.0\\}$ $\\mathrm{mg/L}$, $C_{\\mathrm{target}} = 15.0$ $\\mathrm{mg/L}$。\n- 案例 3: $\\text{基因型} = \\text{\"UM\"}$, $V = 50$ $\\mathrm{L}$, $\\tau = 12$ $\\mathrm{h}$, $D_{\\mathrm{prev}} = 1000$ $\\mathrm{mg}$, 观测谷浓度 $\\{4.0\\}$ $\\mathrm{mg/L}$, $C_{\\mathrm{target}} = 15.0$ $\\mathrm{mg/L}$。\n- 案例 4: $\\text{基因型} = \\text{\"IM\"}$, $V = 50$ $\\mathrm{L}$, $\\tau = 24$ $\\mathrm{h}$, $D_{\\mathrm{prev}} = 1500$ $\\mathrm{mg}$, 观测谷浓度 $\\{7.0, 6.5\\}$ $\\mathrm{mg/L}$, $C_{\\mathrm{target}} = 10.0$ $\\mathrm{mg/L}$。\n- 案例 5: $\\text{基因型} = \\text{\"NM\"}$, $V = 50$ $\\mathrm{L}$, $\\tau = 24$ $\\mathrm{h}$, $D_{\\mathrm{prev}} = 1000$ $\\mathrm{mg}$, 观测谷浓度 $\\{5.0\\}$ $\\mathrm{mg/L}$, $C_{\\mathrm{target}} = 5.0$ $\\mathrm{mg/L}$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含 $5$ 个计算出的下一次剂量（单位为 $\\mathrm{mg}$），四舍五入到最近的整数，以逗号分隔的列表形式并用方括号括起来。例如，包含三个结果的输出应如 $[a,b,c]$，但此处您必须按上述案例的顺序输出恰好五个整数。", "solution": "该问题陈述在科学上是合理的、适定的且客观的。它为实现一个贝叶斯自适应给药算法提供了一整套方程、参数和计算规范。任务是根据药物遗传学信息和治疗药物监测数据，为一系列模拟患者案例计算最佳的下一次剂量。该问题是有效的，并且可以构建一个解决方案。\n\n问题的核心是实施一个贝叶斯推断过程，以更新我们对患者药物清除率 ($CL$) 的认知，然后利用这个更新后的认知来指导给药。该算法分为两个主要阶段：贝叶斯更新和剂量控制。\n\n首先，我们建立贝叶斯模型的各个组成部分。感兴趣的参数是药物清除率 $CL$，单位为 $\\mathrm{L/h}$。\n\n$CL$ 的先验分布由患者的基因型决定。它被指定为对数正态分布，这等同于说清除率的自然对数服从正态分布：\n$$\n\\ln(CL) \\sim \\mathcal{N}(\\mu_{\\mathrm{prior}}, \\sigma_{\\mathrm{prior}}^2)\n$$\n该分布的均值 $\\mu_{\\mathrm{prior}}$ 由群体典型清除率 $CL_{\\mathrm{pop}}$ 经基因型特异性因子 $g$ 调整后确定。其公式为：\n$$\n\\mu_{\\mathrm{prior}} = \\ln(g \\cdot CL_{\\mathrm{pop}})\n$$\n标准差 $\\sigma_{\\mathrm{prior}}$ 反映了即使在同一基因型组内，清除率也存在个体间变异。问题提供了 $CL_{\\mathrm{pop}}$、$\\sigma_{\\mathrm{prior}}$ 以及从基因型（NM, IM, PM, UM）到因子 $g$ 的映射值。\n\n似然函数量化了对于给定的 $CL$ 值，观测数据出现的可能性有多大。数据由一个或多个稳态谷浓度 $\\{y_i\\}$ 组成。根据所提供的单室药代动力学模型，对于清除率为 $CL$、分布容积为 $V$ 的患者，每隔 $\\tau$ 小时给予剂量 $D$ 后，预测的谷浓度 $C_{\\mathrm{trough}}$ 为：\n$$\nC_{\\mathrm{trough}}(CL; D, \\tau, V) = \\frac{D}{V} \\frac{e^{-(\\frac{CL}{V})\\tau}}{1 - e^{-(\\frac{CL}{V})\\tau}}\n$$\n观测值 $y_i$ 被假定围绕此模型预测值服从对数正态分布，这考虑了测量误差和模型设定误差。因此，观测值的对数 $\\ln(y_i)$ 服从正态分布：\n$$\n\\ln(y_i) \\mid CL \\sim \\mathcal{N}(\\ln(C_{\\mathrm{trough}}(CL; D, \\tau, V)), \\sigma_{\\mathrm{res}}^2)\n$$\n其中 $\\sigma_{\\mathrm{res}}$ 是对数尺度上的残差标准差。对于一组独立观测值 $\\{y_i\\}$，总对数似然是各个对数似然之和：\n$$\n\\ln\\mathcal{L}(CL \\mid \\{y_i\\}) = \\sum_{i} \\ln p(y_i \\mid CL)\n$$\n\n根据贝叶斯定理，$CL$ 在给定数据下的后验概率与先验概率和似然的乘积成正比：$p(CL \\mid \\{y_i\\}) \\propto p(\\{y_i\\} \\mid CL) \\cdot p(CL)$。在对数空间中，这变为：\n$$\n\\ln p(CL \\mid \\{y_i\\}) = \\ln\\mathcal{L}(CL \\mid \\{y_i\\}) + \\ln p(CL) + \\text{constant}\n$$\n问题指定了一种计算后验分布的数值方法。我们将 $CL$ 的连续范围离散化为一个从 $0.5$ 到 $15.0$ $\\mathrm{L/h}$，包含 $N = 20001$ 个点的精细网格。对于网格上的每个点 $CL_j$，我们计算对数先验和总对数似然，然后将它们相加得到未归一化的对数后验。为了获得归一化的离散概率分布（后验权重），我们对对数后验值取指数（为保证数值稳定性，先减去最大值），然后将结果值归一化，使其总和为一。\n\n第二阶段是剂量控制。目标是找到下一次剂量 $D_{\\mathrm{next}}$，使其能够达到目标谷浓度 $C_{\\mathrm{target}}$。问题规定使用清除率的后验均值 $\\mathbb{E}[CL \\mid \\{y_i\\}]$ 作为真实清除率的“置入”估计。该后验均值通过网格上 $CL$ 值的加权平均计算得出，权重为后验概率：\n$$\n\\mathbb{E}[CL \\mid \\{y_i\\}] = \\sum_{j} CL_j \\cdot p(CL_j \\mid \\{y_i\\})\n$$\n通过重新整理谷浓度公式，并将 $\\mathbb{E}[CL \\mid \\{y_i\\}]$ 代替 $CL$、将 $C_{\\mathrm{target}}$ 代替 $C_{\\mathrm{trough}}$，我们解出下一次剂量：\n$$\nD_{\\mathrm{next}} = V \\cdot C_{\\mathrm{target}} \\left(\\exp\\left(\\frac{\\mathbb{E}[CL \\mid \\{y_i\\}]}{V}\\tau\\right) - 1\\right)\n$$\n对每个指定的测试用例执行此计算。最终剂量以毫克为单位，四舍五入到最近的整数。实现将使用 `numpy` 进行高效的数组计算，并使用 `scipy.stats.lognorm` 来评估先验和似然计算中的对数概率密度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import lognorm\n\ndef solve():\n    # Define problem constants and parameters.\n    CL_POP = 4.5  # L/h\n    SIGMA_PRIOR = 0.35\n    SIGMA_RES = 0.25\n    \n    GENOTYPE_FACTORS = {\n        \"NM\": 1.0,\n        \"IM\": 0.8,\n        \"PM\": 0.6,\n        \"UM\": 1.5,\n    }\n    \n    # Computational grid for Clearance (CL)\n    CL_GRID_MIN = 0.5   # L/h\n    CL_GRID_MAX = 15.0  # L/h\n    N_POINTS = 20001\n    cl_grid = np.linspace(CL_GRID_MIN, CL_GRID_MAX, N_POINTS)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (genotype, V, tau, D_prev, observed_troughs, C_target)\n        (\"NM\", 50.0, 12.0, 1000.0, [9.0, 8.5], 15.0),\n        (\"PM\", 50.0, 12.0, 1000.0, [22.0, 24.0, 23.0], 15.0),\n        (\"UM\", 50.0, 12.0, 1000.0, [4.0], 15.0),\n        (\"IM\", 50.0, 24.0, 1500.0, [7.0, 6.5], 10.0),\n        (\"NM\", 50.0, 24.0, 1000.0, [5.0], 5.0),\n    ]\n\n    def calculate_next_dose(genotype, V, tau, D_prev, y_obs, C_target):\n        \"\"\"\n        Calculates the next dose based on Bayesian adaptive dosing.\n        \"\"\"\n        # 1. Calculate log-prior\n        g = GENOTYPE_FACTORS[genotype]\n        mu_prior_ln_cl = np.log(g * CL_POP)\n        prior_scale = np.exp(mu_prior_ln_cl)\n        \n        # Using scipy.stats.lognorm.logpdf\n        # s = sigma, scale = exp(mu)\n        log_prior = lognorm.logpdf(cl_grid, s=SIGMA_PRIOR, scale=prior_scale)\n        \n        # 2. Calculate log-likelihood\n        # Calculate predicted trough concentrations for all CL values on the grid\n        k = cl_grid / V\n        exp_term = np.exp(-k * tau)\n        \n        # Avoid division by zero for very small k * tau (though not an issue with given grid)\n        # Using np.expm1 for better precision with small arguments\n        c_trough_pred = (D_prev / V) * exp_term / -np.expm1(-k * tau)\n\n        # Sum log-likelihoods over all observations\n        total_log_likelihood = np.zeros_like(cl_grid)\n        for y in y_obs:\n            # Likelihood of observing y given the predicted trough (as scale)\n            # The model is y ~ LogNormal(mean=c_trough_pred, sigma=SIGMA_RES)\n            # This means ln(y) ~ Normal(mean=ln(c_trough_pred), sigma=SIGMA_RES)\n            # The scale parameter in scipy's lognorm is exp(mu_normal) = c_trough_pred\n            log_lik_y = lognorm.logpdf(y, s=SIGMA_RES, scale=c_trough_pred)\n            total_log_likelihood += log_lik_y\n            \n        # 3. Calculate unnormalized log-posterior\n        log_posterior = log_prior + total_log_likelihood\n        \n        # 4. Normalize the posterior for numerical stability\n        log_posterior_shifted = log_posterior - np.max(log_posterior)\n        unnormalized_posterior = np.exp(log_posterior_shifted)\n        posterior_weights = unnormalized_posterior / np.sum(unnormalized_posterior)\n        \n        # 5. Compute the posterior mean of CL\n        E_cl_posterior = np.sum(cl_grid * posterior_weights)\n        \n        # 6. Calculate the next dose\n        exp_arg = (E_cl_posterior / V) * tau\n        # Use np.expm1 for precision: exp(x) - 1\n        D_next = V * C_target * np.expm1(exp_arg)\n        \n        return round(D_next)\n\n    results = []\n    for case in test_cases:\n        result = calculate_next_dose(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2836657"}]}