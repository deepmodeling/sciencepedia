{"hands_on_practices": [{"introduction": "在开启一项古DNA测序项目之前，一个关键的规划步骤是估算所需的测序数据量。这个计算将项目的科学目标（例如，获得特定覆盖度）与样本的内在质量（例如，内源DNA含量）以及测序技术的参数联系起来。本练习 ([@problem_id:2691892]) 将指导你完成这一核心计算，确保测序实验在成本和成功率之间达到合理的平衡。", "problem": "在古DNA（aDNA）测序项目中，规划测序深度需要将预期的内源性含量、重复率和读长与目标基因组上的有效唯一覆盖度联系起来。考虑一次单端Illumina测序，其读长为 $75 \\ \\mathrm{bp}$，目标基因组大小为 $3 \\times 10^{9} \\ \\mathrm{bp}$。您的目标是在目标基因组上实现 $0.5\\times$ 的有效去重后覆盖度。预实验数据表明，内源性含量为 $0.05$（即原始读数中有 $0.05$ 的比例来自目标类群），且文库复杂度表明 $0.30$ 的内源性读数将在去重过程中被标记为重复并移除。\n\n假设遵循以下与古基因组学实践一致的标准近似：\n- 覆盖度定义为比对上的唯一目标碱基总数除以单倍体基因组大小。\n- 内源性比例均匀适用于所有原始读数，且所有内源性读数均以 $75 \\ \\mathrm{bp}$ 的完整可用长度正确比对。\n- 去重过程移除 $0.30$ 比例的内源性读数，留下 $0.70$ 比例的内源性读数作为唯一读数。污染读数不提供任何目标区域覆盖度。\n- 除上述假设外，由接头修剪、碱基质量过滤和比对失败造成的损失在此计算中可忽略不计。\n\n在这些假设下，计算为达到目标有效覆盖度所需的原始读数数量。将最终答案表示为读数数量，并四舍五入至三位有效数字。", "solution": "对问题陈述进行验证。\n\n原文提取的已知条件如下：\n- 读长：$L = 75 \\ \\mathrm{bp}$\n- 基因组大小：$G = 3 \\times 10^{9} \\ \\mathrm{bp}$\n- 目标有效去重后覆盖度：$C_{eff} = 0.5\\times$\n- 内源性含量：$f_{endo} = 0.05$\n- 内源性读数的重复比例：$f_{dup} = 0.30$\n- 内源性读数的唯一比例：$1 - f_{dup} = 1 - 0.30 = 0.70$\n- 覆盖度定义：比对上的唯一目标碱基总数除以单倍体基因组大小。\n- 假设：内源性比例是均匀的；所有内源性读数均以完整长度 $L$ 比对；去重移除比例为 $f_{dup}$ 的读数；其他损失可忽略不计。\n- 要求输出：所需的原始读数数量，四舍五入至三位有效数字。\n\n验证结论：该问题有效。它基于基因组学和测序分析的科学原理，提供了一个定义明确、客观且自洽的定量问题，参数符合实际。它没有违反任何无效标准。所提供的假设是古基因组学中用于此类初步计算的标准简化。\n\n求解过程如下。\n\n设 $N_{raw}$ 为所需的原始读数总数。\n目标有效覆盖度 $C_{eff}$ 定义为唯一的、位于目标区域的碱基总数（我们称之为 $B_{eff}$）除以基因组大小 $G$。\n$$C_{eff} = \\frac{B_{eff}}{G}$$\n由此，达到目标覆盖度所需的有效碱基总数为：\n$$B_{eff} = C_{eff} \\times G$$\n现在，我们必须将 $B_{eff}$ 与原始读数总数 $N_{raw}$ 联系起来。这个过程涉及反映数据处理流程的几个步骤。\n\n首先，原始读数总数 $N_{raw}$ 乘以内源性含量比例 $f_{endo}$，以确定源自目标基因组的读数数量 $N_{endo}$。\n$$N_{endo} = N_{raw} \\times f_{endo}$$\n其次，对这些内源性读数进行去重。比例为 $f_{dup}$ 的读数被识别为重复并被移除。剩余的唯一读数比例为 $(1 - f_{dup})$。因此，唯一的内源性读数数量 $N_{unique}$ 为：\n$$N_{unique} = N_{endo} \\times (1 - f_{dup}) = N_{raw} \\times f_{endo} \\times (1 - f_{dup})$$\n根据问题的假设，每个唯一的内源性读数都以其完整长度 $L$ 贡献给有效碱基计数。因此，有效碱基总数 $B_{eff}$ 可以表示为：\n$$B_{eff} = N_{unique} \\times L = N_{raw} \\times f_{endo} \\times (1 - f_{dup}) \\times L$$\n我们现在有两个关于 $B_{eff}$ 的表达式。通过令它们相等，我们可以构建一个方程来求解未知量 $N_{raw}$。\n$$C_{eff} \\times G = N_{raw} \\times f_{endo} \\times (1 - f_{dup}) \\times L$$\n重新整理以求解 $N_{raw}$：\n$$N_{raw} = \\frac{C_{eff} \\times G}{f_{endo} \\times (1 - f_{dup}) \\times L}$$\n现在，我们将给定值代入此表达式：\n- $C_{eff} = 0.5$\n- $G = 3 \\times 10^{9}$\n- $f_{endo} = 0.05$\n- $f_{dup} = 0.30$\n- $L = 75$\n\n$$N_{raw} = \\frac{0.5 \\times (3 \\times 10^{9})}{0.05 \\times (1 - 0.30) \\times 75}$$\n我们分别计算分子和分母。\n分子：\n$$0.5 \\times 3 \\times 10^{9} = 1.5 \\times 10^{9}$$\n分母：\n$$0.05 \\times (1 - 0.30) \\times 75 = 0.05 \\times 0.70 \\times 75 = 0.035 \\times 75 = 2.625$$\n现在，我们进行除法运算：\n$$N_{raw} = \\frac{1.5 \\times 10^{9}}{2.625}$$\n$$N_{raw} = \\frac{1500}{2.625} \\times 10^{6} = 571428571.428...$$\n为了用标准科学记数法表示，我们写作：\n$$N_{raw} \\approx 5.7142857... \\times 10^{8}$$\n问题要求答案四舍五入至三位有效数字。\n$$N_{raw} \\approx 5.71 \\times 10^{8}$$\n这是在给定条件下，为达到指定有效覆盖度目标必须生成的原始测序读数总数。", "answer": "$$\\boxed{5.71 \\times 10^8}$$", "id": "2691892"}, {"introduction": "获得测序数据后，首要任务之一是进行质量控制，以识别并量化古DNA特有的损伤信号。胞嘧啶 ($C$) 脱氨是最常见的损伤形式，它会在测序结果中表现为$C$到$T$的替换，这需要与真实的遗传变异区分开来。这个练习 ([@problem_id:1468882]) 介绍了一种通过检测链偏向性来量化这种损伤伪迹的方法，这是古DNA数据认证中的一个基本步骤。", "problem": "在古基因组学领域，一个重大的挑战是区分真实的遗传变异与死后DNA损伤。这类损伤最常见的形式之一是胞嘧啶 (C) 脱氨基形成尿嘧啶 (U)。在研究微量古代DNA所必需的聚合酶链式反应 (PCR) 扩增过程中，DNA聚合酶会将这个U读取为胸腺嘧啶 (T)。因此，古代生物DNA中的一个C碱基可能会被测序仪错误地报告为T碱基，从而模拟出C到T的单核苷酸多态性 (SNP)。\n\nDNA的双链性质使这个问题进一步复杂化。如果反向链上的一个C发生脱氨基，其在正向链上原始的配对碱基是鸟嘌呤 (G)。反向链上受损的C到U的变化将被读取为T，而生物信息学分析流程会推断其在正向链上的互补碱基为腺嘌呤 (A)。因此，根据损伤发生在在哪条链上，胞嘧啶脱氨基损伤在最终的测序数据中可能表现为C到T或G到A的替换。\n\n识别这些损伤假象的一个关键诊断方法是检查链偏好性。一个真正的杂合SNP应该存在于源自正向链和反向链的DNA片段上。相比之下，损伤引起的替换是一种化学假象，在给定位置上更可能在一条链上比另一条链上累积。\n\n考虑一个场景，您正在分析一个古代DNA样本中的单个核苷酸位置。参考基因组在该位置有一个鸟嘌呤 (G)，但您的测序读数显示了 'G' 和 'A' 两种碱基的混合。计数如下：\n- $n_{f,A}$：比对到正向链且显示为 'A' 的读数数量。\n- $n_{f,G}$：比对到正向链且显示为 'G' 的读数数量。\n- $n_{r,A}$：比对到反向链且显示为 'A' 的读数数量。\n- $n_{r,G}$：比对到反向链且显示为 'G' 的读数数量。\n\n为了量化 'A' 碱基的链偏好程度，我们定义一个自定义的“不对称性得分”，$S_{bias}$。该得分定义为在正向链上观察到的 'A' 读数分数与无偏好假设下的期望分数之间的绝对差，再用此期望分数进行归一化。\n- 观察分数 $F_{obs}$ 是所有观察到的 'A' 读数中，映射到正向链的比例。\n- 期望分数 $F_{exp}$ 是所有读数（任何碱基）中，映射到正向链的比例。这代表了在 'A' 读数没有任何链偏好性、随机分布的情况下，其分布的基线期望。\n\n因此，不对称性得分由下式给出：$S_{bias} = \\frac{|F_{obs} - F_{exp}|}{F_{exp}}$。\n\n请根据四个测量量：$n_{f,A}$、$n_{f,G}$、$n_{r,A}$ 和 $n_{r,G}$，推导出一个关于 $S_{bias}$ 的解析闭式表达式。", "solution": "目标是利用所提供的计数，推导出不对称性得分 $S_{bias}$ 的闭式表达式。该得分的公式为 $S_{bias} = \\frac{|F_{obs} - F_{exp}|}{F_{exp}}$。我们需要根据给定的变量找出 $F_{obs}$ 和 $F_{exp}$ 的表达式。\n\n首先，我们根据四个基本测量值定义中间的总计数：\n- 显示为 'A' 的总读数数量为 $N_A = n_{f,A} + n_{r,A}$。\n- 显示为 'G' 的总读数数量为 $N_G = n_{f,G} + n_{r,G}$。\n- 比对到正向链的总读数数量为 $N_f = n_{f,A} + n_{f,G}$。\n- 比对到反向链的总读数数量为 $N_r = n_{r,A} + n_{r,G}$。\n- 覆盖此位置的所有读数的总数量为 $N_{total} = N_f + N_r = n_{f,A} + n_{f,G} + n_{r,A} + n_{r,G}$。\n\n现在，我们可以根据问题陈述中的定义，构建 $F_{obs}$ 和 $F_{exp}$ 的表达式。\n\n步骤1：确定 $F_{obs}$ 的表达式。\n$F_{obs}$ 是所有 'A' 读数中，在正向链上观察到的分数。这是正向链上的 'A' 读数数量除以 'A' 读数的总数量。\n$$F_{obs} = \\frac{n_{f,A}}{N_A} = \\frac{n_{f,A}}{n_{f,A} + n_{r,A}}$$\n\n步骤2：确定 $F_{exp}$ 的表达式。\n$F_{exp}$ 是在无偏好假设下，正向链上 'A' 读数的期望分数。问题将其定义为所有读数中映射到正向链的总体比例。这是正向读数的总数除以所有读数的总数。\n$$F_{exp} = \\frac{N_f}{N_{total}} = \\frac{n_{f,A} + n_{f,G}}{n_{f,A} + n_{f,G} + n_{r,A} + n_{r,G}}$$\n\n步骤3：将 $F_{obs}$ 和 $F_{exp}$ 的表达式代入 $S_{bias}$ 的定义中。\n$$S_{bias} = \\frac{|F_{obs} - F_{exp}|}{F_{exp}} = \\frac{\\left| \\frac{n_{f,A}}{n_{f,A} + n_{r,A}} - \\frac{n_{f,A} + n_{f,G}}{n_{f,A} + n_{f,G} + n_{r,A} + n_{r,G}} \\right|}{\\frac{n_{f,A} + n_{f,G}}{n_{f,A} + n_{f,G} + n_{r,A} + n_{r,G}}}$$\n\n步骤4：简化表达式。我们从分子中绝对值内的差值开始。\n为了对分数进行减法，我们找到一个公分母，即 $(n_{f,A} + n_{r,A})(n_{f,A} + n_{f,G} + n_{r,A} + n_{r,G})$。\n$$F_{obs} - F_{exp} = \\frac{n_{f,A}(n_{f,A} + n_{f,G} + n_{r,A} + n_{r,G}) - (n_{f,A} + n_{f,G})(n_{f,A} + n_{r,A})}{(n_{f,A} + n_{r,A})(n_{f,A} + n_{f,G} + n_{r,A} + n_{r,G})}$$\n现在，展开此表达式的分子：\n$$n_{f,A}(n_{f,A} + n_{f,G} + n_{r,A} + n_{r,G}) = n_{f,A}^2 + n_{f,A}n_{f,G} + n_{f,A}n_{r,A} + n_{f,A}n_{r,G}$$\n$$(n_{f,A} + n_{f,G})(n_{f,A} + n_{r,A}) = n_{f,A}^2 + n_{f,A}n_{r,A} + n_{f,G}n_{f,A} + n_{f,G}n_{r,A}$$\n从第一个展开项中减去第二个展开项：\n$$(n_{f,A}^2 + n_{f,A}n_{f,G} + n_{f,A}n_{r,A} + n_{f,A}n_{r,G}) - (n_{f,A}^2 + n_{f,A}n_{r,A} + n_{f,G}n_{f,A} + n_{f,G}n_{r,A})$$\n$n_{f,A}^2$、$n_{f,A}n_{f,G}$ 和 $n_{f,A}n_{r,A}$ 项相互抵消，剩下：\n$$n_{f,A}n_{r,G} - n_{f,G}n_{r,A}$$\n所以，差值为：\n$$F_{obs} - F_{exp} = \\frac{n_{f,A}n_{r,G} - n_{f,G}n_{r,A}}{(n_{f,A} + n_{r,A})(n_{f,A} + n_{f,G} + n_{r,A} + n_{r,G})}$$\n\n步骤5：将这个简化后的差值代回 $S_{bias}$ 的表达式中。\n$$S_{bias} = \\frac{\\left| \\frac{n_{f,A}n_{r,G} - n_{f,G}n_{r,A}}{(n_{f,A} + n_{r,A})(n_{f,A} + n_{f,G} + n_{r,A} + n_{r,G})} \\right|}{\\frac{n_{f,A} + n_{f,G}}{n_{f,A} + n_{f,G} + n_{r,A} + n_{r,G}}}$$\n我们可以消去同时出现在分子分母和主分母中的项 $(n_{f,A} + n_{f,G} + n_{r,A} + n_{r,G})$。\n$$S_{bias} = \\frac{\\frac{|n_{f,A}n_{r,G} - n_{f,G}n_{r,A}|}{n_{f,A} + n_{r,A}}}{\\frac{n_{f,A} + n_{f,G}}{1}} = \\frac{|n_{f,A}n_{r,G} - n_{f,G}n_{r,A}|}{(n_{f,A} + n_{r,A})(n_{f,A} + n_{f,G})}$$\n这就是不对称性得分的最终简化闭式表达式。", "answer": "$$\\boxed{\\frac{|n_{f,A}n_{r,G} - n_{f,G}n_{r,A}|}{(n_{f,A} + n_{r,A})(n_{f,A} + n_{f,G})}}$$", "id": "1468882"}, {"introduction": "在诊断出DNA损伤后，下一步是通过生物信息学方法来减轻其对下游分析的影响。一个常见的策略是切除DNA片段末端受损最严重的区域，但这需要在去除错误和保留真实遗传信息之间做出权衡。这个高级练习 ([@problem_id:2691922]) 将引导你建立一个数学模型，以确定最佳的切除长度$k$，从而在信号（真实变异）和噪声（损伤错误）之间达到最优平衡。", "problem": "给定一个关于古DNA末端损伤和测序读段修剪的数学模型。目标是选择一个整数修剪长度 $k$（单位为碱基对），从每个读段的两端移除，以最大化一个原则性目标函数。该目标函数旨在平衡保留真实的单核苷酸多态性（SNP）与避免损伤驱动的错误。平均片段长度固定为 $45$ 个碱基对。\n\n基本建模假设和定义（所有参数均为非负数，并且对于古DNA分析和古基因组学而言在科学上是合理的）：\n\n- 末端损伤模型：距离读段末端位置为 $i$ 的碱基，其损伤概率呈指数衰减，即 $d(i) = d_{0} \\exp(-\\alpha i)$，其中 $i \\in \\{1,2,\\dots\\}$，$d_{0} \\in [0,1)$ 是末端损伤振幅，$\\alpha > 0$ 是衰减率。\n- 双末端损伤近似：对于长度为 $L$ 的片段中距离左端为 $j$ 的碱基，其损伤概率在小概率假设下（在古DNA分析中广泛使用）近似为来自两端的独立贡献之和，因此对于一个保留的碱基，其碱基水平的损伤概率约为 $d_{0}\\exp(-\\alpha j) + d_{0}\\exp(-\\alpha (L-j+1))$。\n- 修剪：对每个片段的两端应用一个固定的整数 $k \\ge 0$；只保留位置 $j \\in \\{k+1, k+2, \\dots, L-k\\}$。如果 $L \\le 2k$，则该片段不贡献任何保留位置。\n- 片段长度分布：读段长度 $L$ 被建模为在 $\\{1,2,\\dots\\}$ 上均值为 $\\mu = 45$ 的几何分布。这意味着 $P(L=\\ell) = q (1-q)^{\\ell - 1}$，其中 $q = 1/\\mu = 1/45$ 且 $1-q = 44/45$。\n- 真实变异密度：设 $p_{s} \\in [0,1]$ 为一个基因组位置是真实SNP（单核苷酸多态性）的单位碱基概率，并视其与损伤无关。\n- 错误成本权重：设 $\\beta > 0$ 用于量化一个损伤驱动的错误相对于保留一个真实SNP所获奖励的惩罚。目标函数应随保留的真实SNP数量增加而增加，随预期的损伤驱动错误数量增加而减少。\n\n仅使用这些假设和标准概率法则（期望的线性性质、小概率的独立性近似），按以下步骤进行：\n\n1. 推导修剪 $k$ 个碱基后，每个片段保留位置的期望数量的表达式，记为 $E[(L - 2k)_{+}]$，其中 $(x)_{+} = \\max\\{x,0\\}$。用 $q$ 和 $k$ 表示该期望值。\n2. 通过对保留索引上的双末端单位碱基损伤概率求和，并对 $L$ 的几何分布取期望，推导每个片段所有保留位置上的预期总损伤概率质量的表达式，该表达式是关于 $k$、$d_{0}$ 和 $\\alpha$ 的函数。\n3. 定义一个标量目标函数 $F(k)$，其值为预期的保留真实SNP数量减去加权的预期损伤驱动错误数量，即\n   $$F(k) = p_{s} \\,\\mathbb{E}\\big[(L - 2k)_{+}\\big] \\;-\\; \\beta \\,\\mathbb{E}\\big[\\text{total damage over retained positions}\\big].$$\n   您必须使用步骤1和2中推导出的期望值来为任何给定的参数集评估 $F(k)$。\n4. 对于下面测试套件中的每个参数集，计算使 $F(k)$ 最大化的整数 $k^{\\ast} \\in \\{0,1,2,\\dots\\}$。如果在数值容差范围内有多个 $k$ 达到相同的 $F(k)$ 最大值，则选择其中最小的 $k$。\n5. 单位和格式：$k^{\\ast}$ 必须以非负整数形式报告，单位为碱基对（输出中不要附加任何单位符号）。不涉及角度。像 $p_{s}$ 这样的量必须解释为小数，而不是百分比。\n\n您必须实现一个程序，该程序精确地评估所定义的 $F(k)$，并在 $k \\in \\{0,1,2,\\dots,K_{\\max}\\}$ 的范围内进行搜索，其中 $K_{\\max}$ 是一个固定的足够大的上界，以保证在实践中 argmax 的收敛性。使用 $K_{\\max} = 80$。\n\n测试套件（所有情况下平均长度 $\\mu = 45$ 固定；每个元组为 $(d_{0}, \\alpha, p_{s}, \\beta)$）：\n\n- 情况 1：$(0.3, 0.5, 0.001, 0.05)$\n- 情况 2：$(0.05, 0.5, 0.001, 0.05)$\n- 情况 3：$(0.3, 1.2, 0.001, 0.05)$\n- 情况 4：$(0.3, 0.5, 0.001, 0.2)$\n- 情况 5：$(0.3, 0.5, 0.00001, 0.05)$\n\n您的程序应生成单行输出，其中包含五个最优修剪长度，形式为用方括号括起来的逗号分隔列表（例如，“[3,0,1,5,2]”）。只打印这一行。输出值必须是整数。修剪长度 $k$ 的单位是碱基对（bp）。", "solution": "所述问题具有科学依据、定义明确且客观。它代表了古基因组学领域中一个简化但标准的定量问题，特别涉及古DNA的分析。DNA损伤模型和片段长度的统计分布是实践中使用的合理近似。目标函数提供了一种原则性的方法，用以平衡保留有用遗传信息（单核苷酸多态性，即SNP）和过滤掉人为产物（损伤引起的错误）之间的权衡。所有参数都已定义，目标是一个明确的优化任务。因此，该问题是有效的，我们可以进行形式化的推导和求解。\n\n目标是找到一个整数修剪长度 $k \\ge 0$，以最大化以下函数：\n$$F(k) = p_{s} \\,\\mathbb{E}\\big[(L - 2k)_{+}\\big] \\;-\\; \\beta \\,\\mathbb{E}\\big[\\text{total damage over retained positions}\\big]$$\n其中 $(x)_{+} = \\max\\{x,0\\}$。这需要推导两个作为 $k$ 的函数的期望值。\n\n首先，我们推导保留碱基对的期望数量 $\\mathbb{E}\\big[(L - 2k)_{+}\\big]$ 的表达式。片段长度 $L$ 服从集合 $\\{1, 2, 3, \\dots\\}$ 上的几何分布，均值为 $\\mu = 45$。其概率质量函数为 $P(L=\\ell) = q(1-q)^{\\ell-1}$（对于 $\\ell \\ge 1$），其中 $q = 1/\\mu = 1/45$。令 $p = 1-q$。如果 $\\ell > 2k$，则保留的碱基数量为 $\\ell-2k$，否则为0。\n因此，期望值为：\n$$\n\\mathbb{E}\\big[(L - 2k)_{+}\\big] = \\sum_{\\ell=1}^{\\infty} (\\ell-2k)_{+} P(L=\\ell) = \\sum_{\\ell=2k+1}^{\\infty} (\\ell-2k) q p^{\\ell-1}\n$$\n我们可以通过重新索引来计算这个和。令 $j = \\ell - (2k+1)$，这意味着 $\\ell = j+2k+1$ 且 $\\ell-2k = j+1$。该和变为：\n$$\n\\mathbb{E}\\big[(L - 2k)_{+}\\big] = q \\sum_{j=0}^{\\infty} (j+1) p^{j+2k} = q p^{2k} \\sum_{j=0}^{\\infty} (j+1) p^j\n$$\n和 $\\sum_{j=0}^{\\infty} (j+1) p^j$ 是几何级数分析中的一个已知结果，其值为 $1/(1-p)^2 = 1/q^2$。将其代回，我们得到：\n$$\n\\mathbb{E}\\big[(L - 2k)_{+}\\big] = q p^{2k} \\frac{1}{q^2} = \\frac{p^{2k}}{q} = \\frac{(1-q)^{2k}}{q}\n$$\n这是我们目标函数的第一个组成部分。\n\n其次，我们推导所有保留位置上的预期总损伤。在长度为 $L$ 的片段中，位置 $j$ 处的单位碱基损伤概率由 $d(j, L) = d_0 \\exp(-\\alpha j) + d_0 \\exp(-\\alpha (L-j+1))$ 给出。保留的位置是从 $k+1$ 到 $L-k$。对于长度为 $L$ 的片段，其总损伤我们记为 $D_k(L)$，是这些位置上的和，在 $L \\ge 2k+1$ 时有效：\n$$\nD_k(L) = \\sum_{j=k+1}^{L-k} \\left( d_0 e^{-\\alpha j} + d_0 e^{-\\alpha (L-j+1)} \\right)\n$$\n根据求和索引的对称性，和中的两项相等。因此：\n$$\nD_k(L) = 2 d_0 \\sum_{j=k+1}^{L-k} e^{-\\alpha j} \\quad (\\text{对于 } L \\ge 2k+1)\n$$\n我们需要计算其期望值，$\\mathbb{E}[D_k(L)] = \\sum_{\\ell=2k+1}^{\\infty} D_k(\\ell) P(L=\\ell)$。\n$$\n\\mathbb{E}[D_k(L)] = \\sum_{\\ell=2k+1}^{\\infty} \\left( 2 d_0 \\sum_{j=k+1}^{\\ell-k} e^{-\\alpha j} \\right) q p^{\\ell-1}\n$$\n我们可以改变求和的顺序。求和区域由 $j \\ge k+1$ 和 $\\ell \\ge j+k$ 定义。\n$$\n\\mathbb{E}[D_k(L)] = 2 d_0 q \\sum_{j=k+1}^{\\infty} e^{-\\alpha j} \\left( \\sum_{\\ell=j+k}^{\\infty} p^{\\ell-1} \\right)\n$$\n内层和是一个几何级数尾部：$\\sum_{\\ell=j+k}^{\\infty} p^{\\ell-1} = p^{j+k-1} / (1-p) = p^{j+k-1} / q$。\n将此代入主表达式得到：\n$$\n\\mathbb{E}[D_k(L)] = 2 d_0 q \\sum_{j=k+1}^{\\infty} e^{-\\alpha j} \\frac{p^{j+k-1}}{q} = 2 d_0 p^{k-1} \\sum_{j=k+1}^{\\infty} (p e^{-\\alpha})^j\n$$\n剩余的和是一个几何级数：$\\sum_{j=k+1}^{\\infty} (p e^{-\\alpha})^j = \\frac{(p e^{-\\alpha})^{k+1}}{1 - p e^{-\\alpha}}$。\n将这些部分组合起来，我们得到预期总损伤的最终表达式：\n$$\n\\mathbb{E}[D_k(L)] = 2 d_0 p^{k-1} \\frac{p^{k+1} e^{-\\alpha(k+1)}}{1 - p e^{-\\alpha}} = \\frac{2 d_0 p^{2k} e^{-\\alpha(k+1)}}{1 - p e^{-\\alpha}}\n$$\n代入 $p=1-q$：\n$$\n\\mathbb{E}[\\text{total damage}] = \\frac{2 d_0 (1-q)^{2k} e^{-\\alpha(k+1)}}{1 - (1-q)e^{-\\alpha}}\n$$\n\n推导出两个期望值后，我们现在可以写出完整的目标函数 $F(k)$：\n$$\nF(k) = p_s \\frac{(1-q)^{2k}}{q} - \\beta \\frac{2 d_0 (1-q)^{2k} e^{-\\alpha(k+1)}}{1 - (1-q)e^{-\\alpha}}\n$$\n提出公因式 $(1-q)^{2k}$：\n$$\nF(k) = (1-q)^{2k} \\left( \\frac{p_s}{q} - \\frac{2 \\beta d_0 e^{-\\alpha} e^{-\\alpha k}}{1 - (1-q)e^{-\\alpha}} \\right)\n$$\n该函数必须在非负整数 $k \\in \\{0, 1, 2, \\dots\\}$ 上最大化。当 $k \\to \\infty$ 时，$(1-q)^{2k}$ 和 $e^{-\\alpha k}$ 两项都趋于零，确保 $F(k) \\to 0$。由于 $F(k)$ 并非恒为零，因此最大值必然存在。我们将在一个足够大的 $k$ 值范围内进行搜索，以找到最优值 $k^*$。问题指定了搜索范围为 $k \\in \\{0, 1, \\dots, 80\\}$，考虑到所涉及的衰减率，这个范围是足够的。问题还规定，如果 $F(k)$ 的最大值出现平局，应选择最小的 $k$。我们的算法将通过保留找到的第一个最优 $k$ 来自然地遵守这一规则。\n\n为每个参数集找到 $k^*$ 的算法如下：\n1. 定义常数：平均片段长度 $\\mu=45$，概率 $q=1/45$。\n2. 对于每组参数 $(d_0, \\alpha, p_s, \\beta)$：\n3. 初始化 `max_F` 为一个非常小的数（例如，负无穷大），`optimal_k` 为 $0$。\n4. 在 $k$ 从 $0$ 到 $K_{\\max}=80$ 的范围内进行迭代。\n5. 在每次迭代中，使用推导出的公式计算 $F(k)$。\n6. 如果计算出的 $F(k)$ 大于当前的 `max_F`，则将 `max_F` 更新为 $F(k)$，并将 `optimal_k` 更新为当前的 $k$。\n7. 循环结束后，就为给定的参数找到了一个 `optimal_k`。\n8. 为每个测试用例存储这个整数结果。\n此过程将在以下 Python 程序中实现。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the optimal trimming length k* for ancient DNA reads.\n\n    The function iterates through a set of predefined test cases. For each case,\n    it calculates an objective function F(k) over a range of possible integer\n    trimming lengths k. The k that maximizes F(k) is chosen as the optimal\n    value k*.\n\n    The objective function F(k) is derived from a model of ancient DNA damage\n    and balances retaining true genetic variants (SNPs) against introducing\n    damage-related errors. It is defined as:\n\n    F(k) = p_s * E[retained length] - beta * E[total damage]\n\n    where the expectations are taken over a geometric distribution of DNA\n    fragment lengths. The analytical form derived is:\n\n    F(k) = (1-q)**(2*k) * (p_s/q - (2*beta*d0*exp(-alpha)*exp(-alpha*k)) /\n                                   (1 - (1-q)*exp(-alpha)))\n    \"\"\"\n    # Fixed parameters from the problem statement\n    mean_length = 45.0\n    q = 1.0 / mean_length\n    p = 1.0 - q\n    K_max = 80\n\n    # Test suite: each tuple is (d0, alpha, ps, beta)\n    test_cases = [\n        (0.3, 0.5, 0.001, 0.05),\n        (0.05, 0.5, 0.001, 0.05),\n        (0.3, 1.2, 0.001, 0.05),\n        (0.3, 0.5, 0.001, 0.2),\n        (0.3, 0.5, 0.00001, 0.05),\n    ]\n\n    optimal_k_results = []\n\n    for d0, alpha, ps, beta in test_cases:\n        max_F = -np.inf\n        optimal_k = 0\n\n        # Pre-calculate parts of the F(k) expression that are constant over k\n        term1 = ps / q\n        e_neg_alpha = np.exp(-alpha)\n        term2_numerator = 2 * beta * d0 * e_neg_alpha\n        term2_denominator = 1 - p * e_neg_alpha\n        term2_const = term2_numerator / term2_denominator\n\n        p_pow_2k = 1.0\n        e_pow_neg_alpha_k = 1.0\n        p_squared = p**2\n        \n        # Search for k* in the range [0, K_max]\n        for k in range(K_max + 1):\n            # Calculate F(k)\n            # F(k) = p**(2*k) * (term1 - term2_const * np.exp(-alpha * k))\n            # Iterative update is more efficient than repeated power/exp calls\n            F_k = p_pow_2k * (term1 - term2_const * e_pow_neg_alpha_k)\n\n            # Update optimal_k if a new maximum is found.\n            # The strict inequality '>' ensures the smallest k is chosen in case of a tie.\n            if F_k > max_F:\n                max_F = F_k\n                optimal_k = k\n            \n            # Update terms for next iteration\n            p_pow_2k *= p_squared\n            e_pow_neg_alpha_k *= e_neg_alpha\n\n        optimal_k_results.append(optimal_k)\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, optimal_k_results))}]\")\n\nsolve()\n```", "id": "2691922"}]}