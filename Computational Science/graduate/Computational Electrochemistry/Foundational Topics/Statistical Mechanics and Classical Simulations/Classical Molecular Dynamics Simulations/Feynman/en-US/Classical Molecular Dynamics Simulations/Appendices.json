{
    "hands_on_practices": [
        {
            "introduction": "A classical molecular dynamics simulation begins with its most fundamental component: the force field. This exercise guides you through the essential task of defining pairwise interaction potentials, the building blocks that dictate all subsequent dynamics and emergent properties. By applying the standard Lorentz–Berthelot combining rules and constructing a total potential energy function, you will explore the direct relationship between microscopic forces and macroscopic structure, using the potential minimum as a proxy for the first peak in the radial distribution function .",
            "id": "4238306",
            "problem": "Consider a classical molecular dynamics setting relevant to computational electrochemistry, in which ions are modeled using the Lennard–Jones (LJ) potential and Coulombic interactions, and water is represented by the Transferable Intermolecular Potential with 3 Points (TIP3P). Two fundamental ingredients are required: combining rules for cross interactions and the mapping from microscopic potentials to structural observables. Assume the following well-tested definitions and relations: (i) the Lorentz–Berthelot combining rules for cross LJ parameters, $\\sigma_{ij} = (\\sigma_i + \\sigma_j)/2$ and $\\epsilon_{ij} = \\sqrt{\\epsilon_i \\epsilon_j}$; (ii) the LJ pair potential $U_{\\mathrm{LJ}}(r) = 4 \\epsilon_{ij}\\left[\\left(\\frac{\\sigma_{ij}}{r}\\right)^{12} - \\left(\\frac{\\sigma_{ij}}{r}\\right)^{6}\\right]$; and (iii) the Coulombic interaction $U_{\\mathrm{C}}(r) = \\frac{k_e q_i q_j}{\\varepsilon_r r}$, where $k_e$ is the Coulomb constant in energy-distance units, $q_i$ and $q_j$ are particle charges in elementary charge units, and $\\varepsilon_r$ is the relative dielectric constant of the medium. The total pair potential is $U_{\\mathrm{tot}}(r) = U_{\\mathrm{LJ}}(r) + U_{\\mathrm{C}}(r)$.\n\nIn liquids, the radial distribution function $g(r)$ relates to the potential of mean force $W(r)$ via $g(r) \\propto \\exp\\left(-\\beta W(r)\\right)$ with $\\beta = 1/(k_{\\mathrm{B}} T)$, where $k_{\\mathrm{B}}$ is Boltzmann's constant and $T$ is the absolute temperature. When approximating $W(r)$ by the pair potential $U_{\\mathrm{tot}}(r)$, the first peak position of $g(r)$ can be estimated by the location of the minimum of $U_{\\mathrm{tot}}(r)$, i.e., $r^\\star = \\arg\\min_{r>0} U_{\\mathrm{tot}}(r)$. Although this mapping is an approximation, it is commonly used to reason about hydration structure sensitivity.\n\nYour task is to write a complete program that, for specified Lennard–Jones parameters of sodium ($\\mathrm{Na}^+$) and chloride ($\\mathrm{Cl}^-$), and given TIP3P oxygen parameters, performs the following:\n\n1. Compute the cross-interaction LJ parameters for the $\\mathrm{Na}$–$\\mathrm{Cl}$ pair using the Lorentz–Berthelot combining rules, i.e., compute $\\sigma_{\\mathrm{NaCl}}$ and $\\epsilon_{\\mathrm{NaCl}}$.\n2. Compute the cross-interaction LJ parameters for the $\\mathrm{Na}$–$\\mathrm{O}$ pair, where $\\mathrm{O}$ is the TIP3P oxygen, i.e., compute $\\sigma_{\\mathrm{NaO}}$ and $\\epsilon_{\\mathrm{NaO}}$.\n3. Using the total potential $U_{\\mathrm{tot}}(r)$ between $\\mathrm{Na}$ and $\\mathrm{O}$, with $q_{\\mathrm{Na}} = +1$ and $q_{\\mathrm{O}} = -0.834$, evaluate the location of the first peak of $g_{\\mathrm{NaO}}(r)$ by computing $r^\\star = \\arg\\min_{r \\in [r_{\\min}, r_{\\max}]} U_{\\mathrm{tot}}(r)$, with a search interval $[r_{\\min}, r_{\\max}]$ chosen to be $[0.5, 6.0]$ in angstroms. Use the Coulomb constant $k_e = 13.8935456$ in units of $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{\\AA}\\,e^{-2}$ so that energy is in $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$ when $r$ is in $\\mathrm{\\AA}$ and charges are in units of elementary charge.\n\nReport the following quantities for each test case:\n- $\\sigma_{\\mathrm{NaCl}}$ in angstroms,\n- $\\epsilon_{\\mathrm{NaCl}}$ in $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$,\n- $r^\\star$ in angstroms, rounded to three decimal places.\n\nUse the TIP3P oxygen Lennard–Jones parameters $\\sigma_{\\mathrm{O}} = 3.15061$ angstroms and $\\epsilon_{\\mathrm{O}} = 0.636386$ $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$, and charges $q_{\\mathrm{Na}} = +1$, $q_{\\mathrm{O}} = -0.834$ (dimensionless in elementary charge units). Angles do not appear in this problem.\n\nTest Suite:\nProvide outputs for the following four parameter sets, each given as $(\\sigma_{\\mathrm{Na}}, \\epsilon_{\\mathrm{Na}}, \\sigma_{\\mathrm{Cl}}, \\epsilon_{\\mathrm{Cl}}, \\varepsilon_r)$:\n- Case A (typical aqueous conditions): $(2.589, 0.3526418, 4.401, 0.100, 78.4)$.\n- Case B (stronger effective Coulomb due to lower dielectric): $(2.589, 0.3526418, 4.401, 0.100, 30.0)$.\n- Case C (alternative sodium Lennard–Jones parameters, same dielectric as Case A): $(2.350, 0.544, 4.401, 0.100, 78.4)$.\n- Case D (high dielectric screening): $(2.589, 0.3526418, 4.401, 0.100, 150.0)$.\n\nScientific realism note: The numerical choices are plausible and internally consistent for demonstration. This problem frames sensitivity of hydration structure via $g_{\\mathrm{NaO}}(r)$ peak positions as the minimum of $U_{\\mathrm{tot}}(r)$, a standard approximation grounded in equilibrium statistical mechanics.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element corresponds to one test case and must itself be a list of the form $[\\sigma_{\\mathrm{NaCl}}, \\epsilon_{\\mathrm{NaCl}}, r^\\star]$ in the units specified above, with all numbers rounded to three decimal places. For example, the output format is like $[[x_1,y_1,z_1],[x_2,y_2,z_2],[x_3,y_3,z_3],[x_4,y_4,z_4]]$.",
            "solution": "The problem is valid. It is well-posed, scientifically grounded in the principles of classical statistical mechanics and molecular simulation, and all necessary data and definitions are provided. The tasks are computationally straightforward, involving direct application of defined formulas and a standard one-dimensional numerical optimization.\n\nThe problem requires a series of calculations for four different test cases, each defined by a set of Lennard-Jones (LJ) parameters for sodium ($\\mathrm{Na}^+$) and chloride ($\\mathrm{Cl}^-$) ions and a value for the relative dielectric constant ($\\varepsilon_r$). The parameters for the TIP3P water model's oxygen atom ($\\mathrm{O}$) are given as constants.\n\nThe three main tasks for each test case are:\n1.  Compute the cross-interaction LJ parameters, $\\sigma_{\\mathrm{NaCl}}$ and $\\epsilon_{\\mathrm{NaCl}}$, for the $\\mathrm{Na}^+$-$\\mathrm{Cl}^-$ pair.\n2.  Compute the cross-interaction LJ parameters, $\\sigma_{\\mathrm{NaO}}$ and $\\epsilon_{\\mathrm{NaO}}$, for the $\\mathrm{Na}^+$-$\\mathrm{O}$ pair. (These are intermediate values needed for the next step).\n3.  Estimate the first peak position, $r^\\star$, of the $\\mathrm{Na}^+$-$\\mathrm{O}$ radial distribution function, $g_{\\mathrm{NaO}}(r)$, by finding the minimum of the total pair potential, $U_{\\mathrm{tot}}(r)$.\n\nThe logical steps for the solution are as follows:\n\n**1. Calculation of Cross-Interaction Lennard-Jones Parameters**\n\nThe problem specifies the use of the Lorentz-Berthelot combining rules:\n$$ \\sigma_{ij} = \\frac{\\sigma_i + \\sigma_j}{2} $$\n$$ \\epsilon_{ij} = \\sqrt{\\epsilon_i \\epsilon_j} $$\n\nFor the $\\mathrm{Na}^+$-$\\mathrm{Cl}^-$ pair, given the parameters $(\\sigma_{\\mathrm{Na}}, \\epsilon_{\\mathrm{Na}})$ and $(\\sigma_{\\mathrm{Cl}}, \\epsilon_{\\mathrm{Cl}})$ for a specific test case, the cross-interaction parameters are calculated as:\n$$ \\sigma_{\\mathrm{NaCl}} = \\frac{\\sigma_{\\mathrm{Na}} + \\sigma_{\\mathrm{Cl}}}{2} $$\n$$ \\epsilon_{\\mathrm{NaCl}} = \\sqrt{\\epsilon_{\\mathrm{Na}} \\epsilon_{\\mathrm{Cl}}} $$\nThese are two of the three quantities to be reported for each case.\n\nFor the $\\mathrm{Na}^+$-$\\mathrm{O}$ pair, we use the given parameters for $\\mathrm{Na}^+$ and the constant parameters for the TIP3P oxygen atom, $\\sigma_{\\mathrm{O}} = 3.15061 \\, \\mathrm{\\AA}$ and $\\epsilon_{\\mathrm{O}} = 0.636386 \\, \\mathrm{kJ}\\,\\mathrm{mol}^{-1}$. The calculations are analogous:\n$$ \\sigma_{\\mathrm{NaO}} = \\frac{\\sigma_{\\mathrm{Na}} + \\sigma_{\\mathrm{O}}}{2} $$\n$$ \\epsilon_{\\mathrm{NaO}} = \\sqrt{\\epsilon_{\\mathrm{Na}} \\epsilon_{\\mathrm{O}}} $$\nThese parameters are necessary for constructing the potential function in the next step.\n\n**2. Determination of the First Hydration Shell Peak Position ($r^\\star$)**\n\nThe position of the first peak in the radial distribution function $g(r)$ is a key indicator of local structure in a liquid. The problem states that $g(r)$ is related to the potential of mean force, $W(r)$, by $g(r) \\propto \\exp(-\\beta W(r))$, where $\\beta = 1/(k_B T)$. The peak of $g(r)$ therefore corresponds to the minimum of $W(r)$. The problem employs a common approximation where the potential of mean force $W(r)$ is replaced by the direct pair potential $U_{\\mathrm{tot}}(r)$. Thus, we seek the value $r^\\star$ that minimizes $U_{\\mathrm{tot}}(r)$:\n$$ r^\\star = \\arg\\min_{r > 0} U_{\\mathrm{tot}}(r) $$\n\nThe total pair potential for the $\\mathrm{Na}^+$-$\\mathrm{O}$ interaction is the sum of the Lennard-Jones and Coulombic potentials:\n$$ U_{\\mathrm{tot}}(r) = U_{\\mathrm{LJ}}(r) + U_{\\mathrm{C}}(r) $$\n\nSubstituting the expressions for each component, we get:\n$$ U_{\\mathrm{tot}}(r) = 4 \\epsilon_{\\mathrm{NaO}}\\left[\\left(\\frac{\\sigma_{\\mathrm{NaO}}}{r}\\right)^{12} - \\left(\\frac{\\sigma_{\\mathrm{NaO}}}{r}\\right)^{6}\\right] + \\frac{k_e q_{\\mathrm{Na}} q_{\\mathrm{O}}}{\\varepsilon_r r} $$\n\nThe parameters required are:\n- $\\sigma_{\\mathrm{NaO}}$ and $\\epsilon_{\\mathrm{NaO}}$, calculated as described above.\n- The partial charges: $q_{\\mathrm{Na}} = +1 \\, e$ and $q_{\\mathrm{O}} = -0.834 \\, e$.\n- The Coulomb constant: $k_e = 13.8935456 \\, \\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{\\AA}\\,e^{-2}$.\n- The relative dielectric constant $\\varepsilon_r$, which is provided for each test case.\n\nThe task is to find the value of $r$ that minimizes this function. Since $U_{\\mathrm{tot}}(r)$ is a non-linear function, we must use a numerical optimization method. The search for the minimum is to be performed over the interval $r \\in [0.5, 6.0]$ in angstroms. A one-dimensional scalar minimization algorithm, such as the one provided by `scipy.optimize.minimize_scalar`, is suitable for this purpose. The function to be minimized is defined in terms of $r$ for the specific set of parameters corresponding to each test case. The result of this minimization is the value $r^\\star$.\n\n**3. Algorithmic Implementation**\n\nThe overall algorithm is as follows:\n1.  Define the constant parameters: $\\sigma_{\\mathrm{O}}$, $\\epsilon_{\\mathrm{O}}$, $q_{\\mathrm{Na}}$, $q_{\\mathrm{O}}$, and $k_e$.\n2.  Define the list of four test cases, where each case is a tuple $(\\sigma_{\\mathrm{Na}}, \\epsilon_{\\mathrm{Na}}, \\sigma_{\\mathrm{Cl}}, \\epsilon_{\\mathrm{Cl}}, \\varepsilon_r)$.\n3.  Initialize an empty list to store the final results.\n4.  Iterate through each test case:\n    a. Extract the parameters $(\\sigma_{\\mathrm{Na}}, \\epsilon_{\\mathrm{Na}}, \\sigma_{\\mathrm{Cl}}, \\epsilon_{\\mathrm{Cl}}, \\varepsilon_r)$ for the current case.\n    b. Calculate $\\sigma_{\\mathrm{NaCl}}$ and $\\epsilon_{\\mathrm{NaCl}}$ using the Lorentz-Berthelot rules.\n    c. Calculate the intermediate parameters $\\sigma_{\\mathrm{NaO}}$ and $\\epsilon_{\\mathrm{NaO}}$.\n    d. Define the total potential function $U_{\\mathrm{tot}}(r)$ for the $\\mathrm{Na}^+$-$\\mathrm{O}$ pair using the parameters from the current case.\n    e. Numerically find $r^\\star$, the value of $r$ in the interval $[0.5, 6.0]$ that minimizes $U_{\\mathrm{tot}}(r)$.\n    f. Store the triplet $[\\sigma_{\\mathrm{NaCl}}, \\epsilon_{\\mathrm{NaCl}}, r^\\star]$ for the current case.\n5.  After processing all test cases, format the collected results into a single string as specified: a list of lists, with each number rounded to three decimal places and no spaces within the inner lists, e.g., `[[x1,y1,z1],[x2,y2,z2],...]`.\n6.  Print the final formatted string.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize_scalar\n\ndef solve():\n    \"\"\"\n    Solves the computational electrochemistry problem for a given set of test cases.\n    \"\"\"\n\n    # Define constants given in the problem statement.\n    # TIP3P Oxygen parameters\n    SIGMA_O = 3.15061  # angstroms\n    EPSILON_O = 0.636386  # kJ/mol\n\n    # Charges in elementary charge units\n    Q_NA = 1.0\n    Q_O = -0.834\n\n    # Coulomb constant\n    K_E = 13.8935456  # kJ/mol * A * e^-2\n\n    # Search interval for r*\n    R_BOUNDS = (0.5, 6.0)  # angstroms\n\n    # Define the test cases from the problem statement.\n    # Each case is (sigma_Na, epsilon_Na, sigma_Cl, epsilon_Cl, epsilon_r)\n    test_cases = [\n        # Case A: (typical aqueous conditions)\n        (2.589, 0.3526418, 4.401, 0.100, 78.4),\n        # Case B: (stronger effective Coulomb due to lower dielectric)\n        (2.589, 0.3526418, 4.401, 0.100, 30.0),\n        # Case C: (alternative sodium Lennard-Jones parameters, same dielectric as Case A)\n        (2.350, 0.544, 4.401, 0.100, 78.4),\n        # Case D: (high dielectric screening)\n        (2.589, 0.3526418, 4.401, 0.100, 150.0),\n    ]\n\n    final_results = []\n    \n    for case in test_cases:\n        sigma_na, epsilon_na, sigma_cl, epsilon_cl, epsilon_r = case\n\n        # 1. Compute the cross-interaction LJ parameters for the Na-Cl pair\n        sigma_nacl = (sigma_na + sigma_cl) / 2.0\n        epsilon_nacl = np.sqrt(epsilon_na * epsilon_cl)\n\n        # 2. Compute the cross-interaction LJ parameters for the Na-O pair\n        sigma_nao = (sigma_na + SIGMA_O) / 2.0\n        epsilon_nao = np.sqrt(epsilon_na * EPSILON_O)\n\n        # 3. Define the total potential U_tot(r) for the Na-O pair\n        def u_total_nao(r, s_nao, e_nao, ep_r):\n            \"\"\"\n            Calculates the total pair potential between Na+ and O.\n            U_tot(r) = U_LJ(r) + U_C(r)\n            \"\"\"\n            # Lennard-Jones potential\n            # Using pre-computation of (sigma/r) for efficiency\n            sr6 = (s_nao / r)**6\n            sr12 = sr6**2\n            u_lj = 4.0 * e_nao * (sr12 - sr6)\n\n            # Coulombic potential\n            u_c = (K_E * Q_NA * Q_O) / (ep_r * r)\n\n            return u_lj + u_c\n\n        # Find r*, the location of the minimum of U_tot(r) for Na-O\n        # We pass the parameters for the current case to the function\n        # to be minimized.\n        result = minimize_scalar(\n            u_total_nao,\n            bounds=R_BOUNDS,\n            method='bounded',\n            args=(sigma_nao, epsilon_nao, epsilon_r)\n        )\n        r_star = result.x\n        \n        # Store the results for this case\n        final_results.append((sigma_nacl, epsilon_nacl, r_star))\n\n    # Format the output string as per the problem specification:\n    # [[x1,y1,z1],[x2,y2,z2],...] with numbers rounded to three decimal places\n    # and no spaces inside the inner lists.\n    formatted_strings = []\n    for s_nacl, e_nacl, r_star in final_results:\n        formatted_strings.append(f\"[{s_nacl:.3f},{e_nacl:.3f},{r_star:.3f}]\")\n    \n    final_output_string = f\"[{','.join(formatted_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "Classical molecular dynamics simulations provide a powerful bridge between microscopic particle behavior and macroscopic material properties. This practice challenges you to derive and apply one of the most important results of linear response theory: the connection between the static dielectric constant and the equilibrium fluctuations of the system's total dipole moment. By analyzing a time series of the dipole moment, you will learn how a key macroscopic observable emerges directly from the collective dynamics of the microscopic constituents .",
            "id": "4238365",
            "problem": "Consider a neutral, isotropic, periodic simulation cell of an aqueous electrolyte modeled by Classical Molecular Dynamics (MD). The total dipole moment vector of the cell at a given time is defined by the fundamental electrostatic relation $ \\mathbf{M} = \\sum_{i} q_i \\mathbf{r}_i $, where $ q_i $ are particle charges and $ \\mathbf{r}_i $ their position vectors with respect to a fixed origin. The macroscopic polarization is $ \\mathbf{P} = \\mathbf{M}/V $, where $ V $ is the system volume. In the presence of a weak, spatially uniform external electric field $ \\mathbf{E} $, the Hamiltonian gains a coupling term $ -\\mathbf{M}\\cdot\\mathbf{E} $, and the canonical ensemble at temperature $ T $ applies. Under conducting (tin-foil) boundary conditions in a cubic and isotropic cell, linear response and equilibrium statistical mechanics connect field-induced polarization to equilibrium dipole fluctuations through the Fluctuation-Dissipation Theorem (FDT).\n\nStarting only from:\n- Newton’s laws of motion applied to MD trajectories,\n- the canonical ensemble definition with the Boltzmann factor $ \\exp(-\\beta H) $, $ \\beta = 1/(k_B T) $,\n- the definition of polarization $ \\mathbf{P} = \\mathbf{M}/V $,\n- the material relation $ \\mathbf{D} = \\epsilon_0 \\mathbf{E} + \\mathbf{P} $,\nand treating the response as linear and isotropic at zero field, derive an equilibrium fluctuation expression for the static relative permittivity (static dielectric constant) $ \\epsilon_r $ in terms of dipole moment fluctuations of $ \\mathbf{M} $ in the absence of external fields. Express $ \\epsilon_r $ in terms of time averages of $ \\mathbf{M} $ from an MD trajectory, the vacuum permittivity $ \\epsilon_0 $, the box volume $ V $, Boltzmann’s constant $ k_B $, and temperature $ T $.\n\nThen, implement a program that, given discrete time samples of the total dipole moment vector $ \\mathbf{M}(t) $, computes $ \\epsilon_r $ by replacing ensemble averages with time averages. Your program must:\n- Convert dipole data provided in Debye to Coulomb-meter using $ 1 $ Debye $ = 3.33564\\times 10^{-30} $ Coulomb-meter.\n- Use $ \\epsilon_0 = 8.854187817\\times 10^{-12} $ Farad/meter, $ k_B = 1.380649\\times 10^{-23} $ Joule/Kelvin.\n- Compute the volume from a cubic box of edge length $ L $ given in nanometers: $ V = (L\\times 10^{-9})^3 $ $\\text{m}^3$.\n- Treat each dataset as isotropic unless a nonzero mean emerges; ensure the computation subtracts any nonzero mean dipole vector appropriately.\n\nPhysical units: your final answers for $ \\epsilon_r $ must be dimensionless.\n\nAngle units: not applicable.\n\nPercentages: not applicable.\n\nTest suite. For each case, construct a synthetic MD trajectory with $ N = 4 $ time frames by scaling a base pattern of dipole vectors by a specified amplitude $ a $ (in Debye) and optionally adding a constant drift vector $ \\mathbf{d} $ (in Debye) to all frames. The base pattern is:\n- Frame $ 1 $: $ [a, a, a] $,\n- Frame $ 2 $: $ [-a, -a, -a] $,\n- Frame $ 3 $: $ [a, -a, a] $,\n- Frame $ 4 $: $ [-a, a, -a] $.\nIf a drift $ \\mathbf{d} = [d_x, d_y, d_z] $ is specified, add it to each frame’s vector component-wise before converting units.\n\nEvaluate the following cases:\n1. Case $ 1 $ (nominal pure water-like): $ T = 298.15 $ K, $ L = 3.0 $ nm, amplitude $ a = 82.5 $ Debye, no drift ($ \\mathbf{d} = [0,0,0] $).\n2. Case $ 2 $ (aqueous sodium chloride at moderate concentration with slight polarization drift): $ T = 298.15 $ K, $ L = 3.0 $ nm, amplitude $ a = 80.3 $ Debye, drift $ \\mathbf{d} = [5.0, -3.0, 2.0] $ Debye.\n3. Case $ 3 $ (more concentrated electrolyte in a smaller box): $ T = 298.15 $ K, $ L = 2.5 $ nm, amplitude $ a = 59.0 $ Debye, no drift ($ \\mathbf{d} = [0,0,0] $).\n4. Case $ 4 $ (high ionic strength at slightly elevated temperature in a larger box): $ T = 310.0 $ K, $ L = 3.5 $ nm, amplitude $ a = 93.6 $ Debye, no drift ($ \\mathbf{d} = [0,0,0] $).\n\nYour program should produce a single line of output containing the four computed values of $ \\epsilon_r $ for the cases above as a comma-separated list enclosed in square brackets, in the same order as the cases (e.g., $ [\\epsilon_{r,1},\\epsilon_{r,2},\\epsilon_{r,3},\\epsilon_{r,4}] $).",
            "solution": "We begin by connecting microscopic dipole fluctuations to macroscopic dielectric response using equilibrium statistical mechanics under the canonical ensemble. Let $ H_0 $ denote the Hamiltonian of the electrolyte in the absence of external electric fields, and let $ \\mathbf{E} $ be a uniform external electric field. The field couples to the system via the interaction energy $ H_{\\text{int}} = -\\mathbf{M}\\cdot\\mathbf{E} $, so that the full Hamiltonian is $ H = H_0 - \\mathbf{M}\\cdot\\mathbf{E} $. The canonical partition function at temperature $ T $ is $ Z(\\mathbf{E}) = \\int \\mathrm{d}\\Gamma \\exp\\left( -\\beta \\left( H_0(\\Gamma) - \\mathbf{M}(\\Gamma)\\cdot\\mathbf{E} \\right) \\right) $, where $ \\Gamma $ denotes the phase space coordinates and $ \\beta = 1/(k_B T) $.\n\nThe thermal average of the dipole moment under $ \\mathbf{E} $ is\n$$\n\\langle \\mathbf{M} \\rangle_{\\mathbf{E}} = \\frac{1}{Z(\\mathbf{E})} \\int \\mathrm{d}\\Gamma \\, \\mathbf{M}(\\Gamma) \\exp\\left( -\\beta \\left( H_0(\\Gamma) - \\mathbf{M}(\\Gamma)\\cdot\\mathbf{E} \\right) \\right).\n$$\nDifferentiating with respect to the field and evaluating at zero field gives the linear response susceptibility tensor\n$$\n\\chi_{\\alpha\\beta} = \\left. \\frac{\\partial \\langle M_\\alpha \\rangle_{\\mathbf{E}}}{\\partial E_\\beta} \\right|_{\\mathbf{E}=\\mathbf{0}} = \\beta \\left( \\langle M_\\alpha M_\\beta \\rangle - \\langle M_\\alpha \\rangle \\langle M_\\beta \\rangle \\right),\n$$\nwhich is a standard equilibrium fluctuation formula arising from the Fluctuation-Dissipation Theorem (FDT). For an isotropic system, the susceptibility tensor reduces to a scalar susceptibility $ \\chi $ so that $ \\chi_{\\alpha\\beta} = \\delta_{\\alpha\\beta} \\chi $, and the trace gives\n$$\n\\chi = \\frac{1}{3} \\beta \\left( \\langle \\mathbf{M}^2 \\rangle - \\langle \\mathbf{M} \\rangle^2 \\right),\n$$\nwhere $ \\mathbf{M}^2 = \\mathbf{M}\\cdot\\mathbf{M} $ and $ \\langle \\mathbf{M} \\rangle^2 = \\langle \\mathbf{M} \\rangle \\cdot \\langle \\mathbf{M} \\rangle $. Macroscopically, the polarization is $ \\mathbf{P} = \\mathbf{M}/V $, and the constitutive relation for a linear, isotropic, homogeneous medium is $ \\mathbf{D} = \\epsilon_0 \\mathbf{E} + \\mathbf{P} = \\epsilon \\mathbf{E} $, with $ \\epsilon = \\epsilon_r \\epsilon_0 $ the absolute permittivity. From continuum electrostatics, the polarization is also given by $\\mathbf{P} = \\epsilon_0(\\epsilon_r - 1)\\mathbf{E}$. The average polarization from our simulation is $\\langle \\mathbf{P} \\rangle_\\mathbf{E} = \\langle \\mathbf{M} \\rangle_\\mathbf{E} / V = (\\chi/V)\\mathbf{E}$. Equating these two expressions for the polarization connects the macroscopic dielectric constant to the microscopic dipole fluctuations derived earlier: $\\epsilon_0(\\epsilon_r - 1) = \\chi/V$. Rearranging and substituting the expression for $\\chi$ gives the final formula:\n$$\n\\epsilon_r = 1 + \\frac{ \\langle \\mathbf{M}^2 \\rangle - \\langle \\mathbf{M} \\rangle^2 }{ 3 \\epsilon_0 V k_B T }.\n$$\nTo compute $ \\epsilon_r $ from an MD trajectory, we replace ensemble averages by time averages over the discrete samples. Given $ N $ frames of $ \\mathbf{M}(t_j) $, with components $ M_x(t_j), M_y(t_j), M_z(t_j) $, the required averages are\n$$\n\\langle \\mathbf{M} \\rangle \\approx \\frac{1}{N} \\sum_{j=1}^{N} \\mathbf{M}(t_j), \\qquad \\langle \\mathbf{M}^2 \\rangle \\approx \\frac{1}{N} \\sum_{j=1}^{N} \\left( \\mathbf{M}(t_j)\\cdot \\mathbf{M}(t_j) \\right).\n$$\nWe then compute\n$$\n\\mathrm{Var}(\\mathbf{M}) = \\langle \\mathbf{M}^2 \\rangle - \\langle \\mathbf{M} \\rangle^2,\n$$\nand finally\n$$\n\\epsilon_r = 1 + \\frac{ \\mathrm{Var}(\\mathbf{M}) }{ 3 \\epsilon_0 V k_B T }.\n$$\n\nUnit handling is essential. The input dipole vectors are provided in Debye, so we convert each vector to the International System of Units (SI) using $ 1 $ Debye $ = 3.33564\\times 10^{-30} $ Coulomb-meter. The box is cubic with edge length $ L $ given in nanometers, so $ V = (L\\times 10^{-9})^3 $ meter$^3$. We use $ \\epsilon_0 = 8.854187817\\times 10^{-12} $ Farad/meter and $ k_B = 1.380649\\times 10^{-23} $ Joule/Kelvin.\n\nAlgorithmic steps for each case:\n1. Construct the $ N = 4 $ dipole frames in Debye from the base pattern with the given amplitude $ a $ (Debye) and add the drift $ \\mathbf{d} $ (Debye) if specified.\n2. Convert each frame to Coulomb-meter by multiplying by $ 3.33564\\times 10^{-30} $.\n3. Compute $ \\langle \\mathbf{M} \\rangle $, $ \\langle \\mathbf{M}^2 \\rangle $, and $ \\mathrm{Var}(\\mathbf{M}) $.\n4. Compute $ V $ from $ L $ and $ \\epsilon_r $ from the fluctuation expression.\n5. Report the dimensionless $ \\epsilon_r $.\n\nApplying these steps to the specified test suite yields dimensionless outputs. Because the base patterns are symmetric, any nonzero drift $ \\mathbf{d} $ contributes only to $ \\langle \\mathbf{M} \\rangle $ and $ \\langle \\mathbf{M}^2 \\rangle $, but it cancels in $ \\mathrm{Var}(\\mathbf{M}) $ through the subtraction $ \\langle \\mathbf{M}^2 \\rangle - \\langle \\mathbf{M} \\rangle^2 $. For the chosen amplitudes and box/temperature parameters, the computed values are consistent with physically plausible static dielectric constants for aqueous electrolytes at the given conditions. The final program computes and outputs the four values in the required single-line bracketed format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Physical constants (SI units)\nEPS0 = 8.854187817e-12  # vacuum permittivity (F/m)\nKB = 1.380649e-23       # Boltzmann constant (J/K)\nDEBYE_TO_CM = 3.33564e-30  # Debye to Coulomb-meter\n\ndef construct_frames(amplitude_D, drift_D=None):\n    \"\"\"\n    Construct 4 dipole frames in Debye based on the specified pattern, amplitude, and optional drift.\n    Returns an array of shape (4, 3).\n    \"\"\"\n    a = amplitude_D\n    base_frames = np.array([\n        [ a,  a,  a],\n        [-a, -a, -a],\n        [ a, -a,  a],\n        [-a,  a, -a]\n    ], dtype=float)\n    if drift_D is not None:\n        drift = np.array(drift_D, dtype=float)\n        base_frames = base_frames + drift\n    return base_frames\n\ndef compute_eps_r(frames_D, T_K, L_nm):\n    \"\"\"\n    Compute the static relative permittivity epsilon_r from dipole frames in Debye,\n    temperature T in K, and cubic box length L in nm.\n    \"\"\"\n    # Convert frames to SI (C·m)\n    frames_SI = frames_D * DEBYE_TO_CM\n\n    # Compute averages\n    M_mean = np.mean(frames_SI, axis=0)                   # vector mean\n    M2_mean = np.mean(np.sum(frames_SI**2, axis=1))       # mean of M·M\n    var_M = M2_mean - np.dot(M_mean, M_mean)              # vector variance\n\n    # Volume in m^3\n    L_m = L_nm * 1e-9\n    V = L_m ** 3\n\n    # Compute epsilon_r\n    eps_r = 1.0 + var_M / (3.0 * EPS0 * V * KB * T_K)\n    return eps_r\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Each case: (T_K, L_nm, amplitude_D, drift_D or None)\n        (298.15, 3.0, 82.5, None),                     # Case 1\n        (298.15, 3.0, 80.3, [5.0, -3.0, 2.0]),         # Case 2\n        (298.15, 2.5, 59.0, None),                     # Case 3\n        (310.0,  3.5, 93.6, None),                     # Case 4\n    ]\n\n    results = []\n    for T_K, L_nm, amplitude_D, drift in test_cases:\n        frames_D = construct_frames(amplitude_D, drift)\n        eps_r = compute_eps_r(frames_D, T_K, L_nm)\n        results.append(eps_r)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The ultimate test of a computational model is its ability to reproduce and predict experimental results. This final practice immerses you in the critical workflow of calibrating and validating a model of an electrochemical interface, a central task in computational electrochemistry. You will learn to align simulation and experimental potential scales by anchoring to the potential of zero charge ($V_{\\mathrm{PZC}}$), compute the differential capacitance, and quantitatively assess your model's accuracy against real-world data .",
            "id": "4238391",
            "problem": "You are tasked with designing a program that performs calibration and discrepancy quantification for electrode–electrolyte systems using outputs that would arise from classical molecular dynamics simulations in computational electrochemistry. The program must operate on discretely sampled data for electrode potential and corresponding surface charge density, and compare the resulting differential capacitance curve to experimental data. The derivation and algorithm must be grounded in first principles of classical mechanics and electrostatics.\n\nStarting from foundational principles, use the following bases:\n- Newton's Second Law for classical particles: $\\sum \\mathbf{F}_i = m_i \\, d^2 \\mathbf{r}_i / dt^2$ for particle $i$ of mass $m_i$ and position $\\mathbf{r}_i$.\n- The definition of surface charge density: $\\sigma(V)$ is the net electrode charge per unit area obtained from the simulated constant-potential boundary condition at electrode potential $V$.\n- The definition of differential capacitance per unit area: $C(V) = d\\sigma / dV$.\n\nDefinitions:\n- Potential of zero charge (PZC): $V_{\\mathrm{PZC}}$ is the electrode potential at which $\\sigma(V_{\\mathrm{PZC}}) = 0$.\n- Work function calibration offset: In classical molecular dynamics simulations, the absolute potential reference may be offset relative to experiments due to the electrode work function. Calibrate an effective potential offset $\\Delta V$ so that the simulated $V_{\\mathrm{PZC}}$ aligns with the experimental $V_{\\mathrm{PZC}}$. Use an additive calibration of the simulated potentials $V_{\\mathrm{cal}} = V_{\\mathrm{sim}} - \\Delta V$, with $\\Delta V = V_{\\mathrm{PZC}}^{\\mathrm{sim}} - V_{\\mathrm{PZC}}^{\\mathrm{exp}}$.\n\nAlgorithmic requirements:\n1. Given a discrete set of simulation potentials $V_{\\mathrm{sim}}$ in volts and corresponding surface charge densities $\\sigma_{\\mathrm{sim}}$ in $\\mathrm{C}/\\mathrm{m}^2$, compute $V_{\\mathrm{PZC}}^{\\mathrm{sim}}$ by:\n   - If there exists an index pair $(i,i+1)$ such that $\\sigma_{\\mathrm{sim}}(V_i) \\cdot \\sigma_{\\mathrm{sim}}(V_{i+1}) \\le 0$, compute the zero crossing via linear interpolation between $(V_i,\\sigma_i)$ and $(V_{i+1},\\sigma_{i+1})$.\n   - If no sign change occurs in the domain, estimate $V_{\\mathrm{PZC}}^{\\mathrm{sim}}$ by least squares linear regression $\\sigma(V) \\approx a V + b$ and compute $V_{\\mathrm{PZC}}^{\\mathrm{sim}} = -b/a$ (assuming $a \\ne 0$).\n2. Given $V_{\\mathrm{PZC}}^{\\mathrm{exp}}$ in volts, compute the work function calibration offset $\\Delta V = V_{\\mathrm{PZC}}^{\\mathrm{sim}} - V_{\\mathrm{PZC}}^{\\mathrm{exp}}$ in volts, and the calibrated potentials $V_{\\mathrm{cal}} = V_{\\mathrm{sim}} - \\Delta V$.\n3. Compute the differential capacitance per unit area $C_{\\mathrm{sim}}(V_{\\mathrm{cal}})$ in $\\mathrm{F}/\\mathrm{m}^2$ by numerically differentiating $\\sigma_{\\mathrm{sim}}$ with respect to $V_{\\mathrm{cal}}$ using second-order accurate central differences for interior points and first-order forward/backward differences at the endpoints.\n4. Given the experimental capacitance curve samples $(V_{\\mathrm{exp}}, C_{\\mathrm{exp}})$, interpolate $C_{\\mathrm{sim}}(V_{\\mathrm{cal}})$ onto the $V_{\\mathrm{exp}}$ grid over the shared potential domain and compute:\n   - Root mean square error (RMSE) between the interpolated simulated capacitance and experimental capacitance over the overlap, in $\\mathrm{F}/\\mathrm{m}^2$.\n   - Maximum absolute deviation (MAD) over the same overlap, in $\\mathrm{F}/\\mathrm{m}^2$.\n5. Compute the calibrated PZC on the calibrated scale $V_{\\mathrm{PZC}}^{\\mathrm{cal}} = V_{\\mathrm{PZC}}^{\\mathrm{sim}} - \\Delta V$, which should equal $V_{\\mathrm{PZC}}^{\\mathrm{exp}}$ if the offset is applied as specified.\n\nUnits:\n- All potentials must be in volts (V).\n- Surface charge densities must be in coulombs per square meter ($\\mathrm{C}/\\mathrm{m}^2$).\n- Capacitances must be in farads per square meter ($\\mathrm{F}/\\mathrm{m}^2$).\n\nThe test suite is defined by the following three cases, to be used unchanged by your program:\n- Case 1 (happy path; monotonic $\\sigma(V)$ with zero crossing in-domain):\n  - $V_{\\mathrm{sim}} = [-1.0,-0.5,0.0,0.5,1.0]$.\n  - $\\sigma_{\\mathrm{sim}} = [-0.25,-0.12,0.0,0.12,0.26]$.\n  - $V_{\\mathrm{exp}} = [-0.5,0.0,0.5,1.0]$.\n  - $C_{\\mathrm{exp}} = [0.23,0.24,0.26,0.28]$.\n  - $V_{\\mathrm{PZC}}^{\\mathrm{exp}} = 0.10$.\n- Case 2 (edge case; no zero crossing in-domain requiring extrapolated PZC):\n  - $V_{\\mathrm{sim}} = [0.2,0.6,1.0,1.4]$.\n  - $\\sigma_{\\mathrm{sim}} = [0.05,0.15,0.26,0.36]$.\n  - $V_{\\mathrm{exp}} = [0.0,0.4,0.8,1.2,1.6]$.\n  - $C_{\\mathrm{exp}} = [0.24,0.25,0.27,0.29,0.305]$.\n  - $V_{\\mathrm{PZC}}^{\\mathrm{exp}} = 0.00$.\n- Case 3 (nonlinear $\\sigma(V)$ with in-domain zero crossing and modest curvature):\n  - $V_{\\mathrm{sim}} = [-1.5,-1.0,-0.5,0.0,0.5,1.0,1.5]$.\n  - $\\sigma_{\\mathrm{sim}} = [-0.30,-0.22,-0.12,-0.02,0.09,0.21,0.35]$.\n  - $V_{\\mathrm{exp}} = [-1.0,-0.5,0.0,0.5,1.0,1.5]$.\n  - $C_{\\mathrm{exp}} = [0.18,0.20,0.22,0.25,0.28,0.32]$.\n  - $V_{\\mathrm{PZC}}^{\\mathrm{exp}} = 0.15$.\n\nYour program must produce a single line of output containing a list of sublists, one per case, each sublist with four floats in the order $[\\Delta V, V_{\\mathrm{PZC}}^{\\mathrm{cal}}, \\mathrm{RMSE}, \\mathrm{MAD}]$, with no spaces. For example, the final output format must look like \"[[d1,v1,r1,m1],[d2,v2,r2,m2],[d3,v3,r3,m3]]\". All reported values must be in SI units as specified above.",
            "solution": "The principles of classical mechanics and electrostatics provide the foundation for molecular dynamics simulations of electrochemical interfaces. Newton's second law, $\\sum \\mathbf{F}_i = m_i d^2 \\mathbf{r}_i / dt^2$, governs the motion of each particle $i$ with mass $m_i$ and position $\\mathbf{r}_i$ under the influence of interatomic forces. In constant-potential simulations, the electrode is maintained at a specified potential $V$, and the system evolves to an equilibrium state characterized by a net surface charge density, $\\sigma(V)$, on the electrode. The relationship between these two quantities defines the electrochemical behavior of the interface. A key metric is the differential capacitance per unit area, $C(V)$, defined as the rate of change of surface charge density with respect to the electrode potential:\n$$C(V) = \\frac{d\\sigma}{dV}$$\nThis problem requires developing an algorithm to process discrete data sets of $(V_{\\mathrm{sim}}, \\sigma_{\\mathrm{sim}})$ from simulations and compare the resulting capacitance curve with experimental data $(V_{\\mathrm{exp}}, C_{\\mathrm{exp}})$. A critical step in this comparison is the calibration of the potential scale. Simulations compute potentials relative to an intrinsic reference (e.g., the vacuum level), whereas experimental potentials are typically reported against a standard reference electrode. This discrepancy, largely due to the electrode's work function, introduces a constant offset. We can correct for this by aligning a key physical feature common to both simulation and experiment: the potential of zero charge, $V_{\\mathrm{PZC}}$, where $\\sigma(V_{\\mathrm{PZC}}) = 0$. The calibration offset $\\Delta V$ is determined such that the simulated PZC aligns with the experimental one. The calibrated potential scale is then $V_{\\mathrm{cal}} = V_{\\mathrm{sim}} - \\Delta V$, where $\\Delta V = V_{\\mathrm{PZC}}^{\\mathrm{sim}} - V_{\\mathrm{PZC}}^{\\mathrm{exp}}$.\n\nThe algorithmic procedure is as follows:\n\n1.  **Determination of the Simulated Potential of Zero Charge, $V_{\\mathrm{PZC}}^{\\mathrm{sim}}$**:\n    Given a discrete set of points $(V_i, \\sigma_i)$ from the simulation, we must find the potential $V$ where $\\sigma(V)=0$.\n    -   If the charge density data $\\sigma_{\\mathrm{sim}}$ contains a sign change between adjacent points, i.e., $\\sigma_i \\cdot \\sigma_{i+1} \\le 0$ for some index $i$, the $V_{\\mathrm{PZC}}^{\\mathrm{sim}}$ lies within the interval $[V_i, V_{i+1}]$ (or $[V_{i+1}, V_i]$). We approximate the function $\\sigma(V)$ as a straight line between $(V_i, \\sigma_i)$ and $(V_{i+1}, \\sigma_{i+1})$. The potential at which this line crosses $\\sigma = 0$ is found by linear interpolation. The slope is $m = (\\sigma_{i+1} - \\sigma_i) / (V_{i+1} - V_i)$. The equation of the line is $\\sigma(V) - \\sigma_i = m (V - V_i)$. Setting $\\sigma(V)=0$, we solve for $V=V_{\\mathrm{PZC}}^{\\mathrm{sim}}$:\n        $$V_{\\mathrm{PZC}}^{\\mathrm{sim}} = V_i - \\frac{\\sigma_i}{m} = V_i - \\sigma_i \\frac{V_{i+1} - V_i}{\\sigma_{i+1} - \\sigma_i}$$\n    -   If $\\sigma_{\\mathrm{sim}}$ does not change sign over the sampled potential range, we must extrapolate to find the $V_{\\mathrm{PZC}}^{\\mathrm{sim}}$. Assuming the relationship is approximately linear over the given range, we perform a least-squares linear regression to fit the model $\\sigma(V) \\approx aV + b$ to the $(V_{\\mathrm{sim}}, \\sigma_{\\mathrm{sim}})$ data. The coefficients $a$ and $b$ are determined by minimizing the sum of squared residuals. Once the best-fit line is found, the PZC is estimated by solving for $V$ where $\\sigma(V)=0$:\n        $$V_{\\mathrm{PZC}}^{\\mathrm{sim}} = -\\frac{b}{a}$$\n\n2.  **Potential Scale Calibration**:\n    With $V_{\\mathrm{PZC}}^{\\mathrm{sim}}$ and the given experimental value $V_{\\mathrm{PZC}}^{\\mathrm{exp}}$, the additive potential offset is calculated:\n    $$\\Delta V = V_{\\mathrm{PZC}}^{\\mathrm{sim}} - V_{\\mathrm{PZC}}^{\\mathrm{exp}}$$\n    This offset is then applied to the entire set of simulated potentials to obtain the calibrated potential scale:\n    $$V_{\\mathrm{cal},i} = V_{\\mathrm{sim},i} - \\Delta V$$\n    By construction, the calibrated potential of zero charge, $V_{\\mathrm{PZC}}^{\\mathrm{cal}} = V_{\\mathrm{PZC}}^{\\mathrm{sim}} - \\Delta V$, will be equal to $V_{\\mathrm{PZC}}^{\\mathrm{exp}}$.\n\n3.  **Calculation of Simulated Differential Capacitance, $C_{\\mathrm{sim}}$**:\n    The capacitance $C_{\\mathrm{sim}}$ is the derivative of $\\sigma_{\\mathrm{sim}}$ with respect to the calibrated potential $V_{\\mathrm{cal}}$. Since $V_{\\mathrm{cal}}$ is a simple shift of $V_{\\mathrm{sim}}$ ($dV_{\\mathrm{cal}} = dV_{\\mathrm{sim}}$), we can differentiate $\\sigma_{\\mathrm{sim}}$ with respect to $V_{\\mathrm{sim}}$. For discrete data, we use finite differences. To maintain accuracy, a second-order central difference scheme is used for interior points:\n    $$C_i = \\frac{\\sigma_{i+1} - \\sigma_{i-1}}{V_{i+1} - V_{i-1}}, \\quad \\text{for } i \\in [1, N-2]$$\n    At the boundaries of the data range, where a central difference is not possible, first-order forward/backward difference schemes are used:\n    $$C_0 = \\frac{\\sigma_1 - \\sigma_0}{V_1 - V_0} \\quad \\text{(forward difference)}$$\n    $$C_{N-1} = \\frac{\\sigma_{N-1} - \\sigma_{N-2}}{V_{N-1} - V_{N-2}} \\quad \\text{ (backward difference)}$$\n    This yields a set of capacitance values $C_{\\mathrm{sim}}$ corresponding to the potentials $V_{\\mathrm{cal}}$.\n\n4.  **Discrepancy Quantification**:\n    To compare the simulated capacitance curve $(V_{\\mathrm{cal}}, C_{\\mathrm{sim}})$ with the experimental one $(V_{\\mathrm{exp}}, C_{\\mathrm{exp}})$, they must be evaluated on a common potential grid. We first identify the overlapping potential domain: $[\\max(\\min(V_{\\mathrm{cal}}), \\min(V_{\\mathrm{exp}})), \\min(\\max(V_{\\mathrm{cal}}), \\max(V_{\\mathrm{exp}}))]$. We select the experimental potential points, $V_{\\mathrm{exp},j}$, that fall within this overlap. Then, we use linear interpolation on the $(V_{\\mathrm{cal}}, C_{\\mathrm{sim}})$ data to find the simulated capacitance values, $C_{\\mathrm{sim,interp},j}$, at each of these common potentials $V_{\\mathrm{exp},j}$. With the two capacitance sets, $C_{\\mathrm{sim,interp}}$ and the corresponding subset of $C_{\\mathrm{exp}}$, on the same potential grid, we compute two standard error metrics:\n    -   Root Mean Square Error (RMSE):\n        $$\\mathrm{RMSE} = \\sqrt{\\frac{1}{M}\\sum_{j=1}^{M} (C_{\\mathrm{sim,interp},j} - C_{\\mathrm{exp},j})^2}$$\n        where $M$ is the number of points in the overlapping domain.\n    -   Maximum Absolute Deviation (MAD):\n        $$\\mathrm{MAD} = \\max_{j} |C_{\\mathrm{sim,interp},j} - C_{\\mathrm{exp},j}|$$\nThese metrics quantify the agreement between the simulation and experiment after calibration.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef process_case(case):\n    \"\"\"\n    Processes a single test case for electrode-electrolyte system calibration.\n\n    Args:\n        case (tuple): A tuple containing simulation and experimental data:\n                      (V_sim, sigma_sim, V_exp, C_exp, V_pzc_exp).\n\n    Returns:\n        list: A list of four floats [delta_V, V_pzc_cal, rmse, mad].\n    \"\"\"\n    V_sim, sigma_sim, V_exp, C_exp, V_pzc_exp = case\n    V_sim = np.array(V_sim, dtype=float)\n    sigma_sim = np.array(sigma_sim, dtype=float)\n    V_exp = np.array(V_exp, dtype=float)\n    C_exp = np.array(C_exp, dtype=float)\n\n    # 1. Compute V_pzc_sim\n    V_pzc_sim = None\n    found_crossing = False\n    for i in range(len(sigma_sim) - 1):\n        if sigma_sim[i] * sigma_sim[i+1] <= 0:\n            V1, s1 = V_sim[i], sigma_sim[i]\n            V2, s2 = V_sim[i+1], sigma_sim[i+1]\n            \n            # Avoid division by zero if sigma values are identical\n            if s2 - s1 == 0:\n                # This implies both are zero if their product is <= 0\n                V_pzc_sim = V1 if s1 == 0 else V2\n            else:\n                m = (s2 - s1) / (V2 - V1)\n                V_pzc_sim = V1 - s1 / m\n            \n            found_crossing = True\n            break\n            \n    if not found_crossing:\n        # Least squares linear regression: sigma = aV + b\n        a, b = np.polyfit(V_sim, sigma_sim, 1)\n        if a == 0:\n            # Physically unlikely edge case, but handle to avoid division by zero\n            # If a=0, sigma is constant. If that constant is not 0, PZC is at infinity.\n            # We set it to a large number as a placeholder, though problem implies a!=0.\n            V_pzc_sim = np.inf if b != 0 else 0\n        else:\n            V_pzc_sim = -b / a\n            \n    # 2. Compute offset and calibrated potentials\n    delta_V = V_pzc_sim - V_pzc_exp\n    V_cal = V_sim - delta_V\n\n    # 3. Compute simulated capacitance C_sim\n    # np.gradient uses 2nd-order central differences and 1st-order at boundaries by default\n    C_sim = np.gradient(sigma_sim, V_sim)\n\n    # 4. Quantify discrepancy\n    V_overlap_min = max(np.min(V_cal), np.min(V_exp))\n    V_overlap_max = min(np.max(V_cal), np.max(V_exp))\n    \n    overlap_mask = (V_exp >= V_overlap_min) & (V_exp <= V_overlap_max)\n    V_compare = V_exp[overlap_mask]\n    C_exp_compare = C_exp[overlap_mask]\n\n    rmse = 0.0\n    mad = 0.0\n    \n    if V_compare.size > 0:\n        # Interpolate C_sim onto the comparison potential grid\n        C_sim_interp = np.interp(V_compare, V_cal, C_sim)\n        \n        # Calculate error metrics\n        errors = C_sim_interp - C_exp_compare\n        rmse = np.sqrt(np.mean(errors**2))\n        mad = np.max(np.abs(errors))\n\n    # 5. Compute calibrated PZC\n    V_pzc_cal = V_pzc_sim - delta_V\n\n    return [delta_V, V_pzc_cal, rmse, mad]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (\n            [-1.0,-0.5,0.0,0.5,1.0],\n            [-0.25,-0.12,0.0,0.12,0.26],\n            [-0.5,0.0,0.5,1.0],\n            [0.23,0.24,0.26,0.28],\n            0.10\n        ),\n        (\n            [0.2,0.6,1.0,1.4],\n            [0.05,0.15,0.26,0.36],\n            [0.0,0.4,0.8,1.2,1.6],\n            [0.24,0.25,0.27,0.29,0.305],\n            0.00\n        ),\n        (\n            [-1.5,-1.0,-0.5,0.0,0.5,1.0,1.5],\n            [-0.30,-0.22,-0.12,-0.02,0.09,0.21,0.35],\n            [-1.0,-0.5,0.0,0.5,1.0,1.5],\n            [0.18,0.20,0.22,0.25,0.28,0.32],\n            0.15\n        )\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(case)\n        results.append(result)\n\n    # Format the final output string as specified\n    output_str = \",\".join([f\"[{','.join(map(str, r))}]\" for r in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n```"
        }
    ]
}