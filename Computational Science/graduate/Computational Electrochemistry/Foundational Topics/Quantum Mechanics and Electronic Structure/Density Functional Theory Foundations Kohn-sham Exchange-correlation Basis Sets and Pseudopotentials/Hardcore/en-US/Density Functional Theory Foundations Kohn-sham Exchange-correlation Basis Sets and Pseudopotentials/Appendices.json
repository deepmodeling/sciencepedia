{
    "hands_on_practices": [
        {
            "introduction": "A prerequisite for any reliable Density Functional Theory (DFT) calculation is ensuring that the results are converged with respect to the key numerical parameters. In plane-wave calculations, the most important parameters are the kinetic energy cutoff for the basis set, $E_{\\mathrm{cut}}$, and the density of the $k$-point mesh for sampling the Brillouin zone. This practice provides a hands-on method for systematically testing convergence and using a physically-motivated model to extrapolate to the limit of a complete basis set and infinitely dense $k$-point sampling, an essential skill for producing accurate and reproducible energetic data. ",
            "id": "4241387",
            "problem": "You are tasked with constructing a program that assesses the convergence of adsorption energy in plane-wave Density Functional Theory (DFT) computations with respect to the plane-wave kinetic energy cutoff and $k$-point sampling, in the context of computational electrochemistry. Begin from the foundational Kohn-Sham formulation of Density Functional Theory (DFT), which states that for an interacting electron system the ground-state energy can be obtained from a non-interacting reference system governed by the Kohn-Sham equations under an effective potential. In a standard plane-wave implementation with norm-conserving or projector augmented-wave pseudopotentials, the total energy depends on the plane-wave basis truncation at kinetic energy cutoff $E_{\\mathrm{cut}}$ and the Brillouin-zone integral approximated by a discrete set of $k$-points of cardinality $N_k$. The adsorption energy is defined as $E_{\\mathrm{ads}} = E_{\\mathrm{tot}}(\\mathrm{slab}+\\mathrm{adsorbate}) - E_{\\mathrm{tot}}(\\mathrm{slab}) - E_{\\mathrm{tot}}(\\mathrm{adsorbate})$, expressed in $\\mathrm{eV}$.\n\nFrom first principles, the variational property of the Kohn-Sham method with a truncated plane-wave basis implies an error that decreases as basis completeness increases, and the Brillouin-zone integration error decreases as the density of $k$-points increases. In plane-wave pseudopotential calculations, the highest reciprocal lattice vectors included are bounded by $G_{\\max}$, which is related to $E_{\\mathrm{cut}}$, and the quadrature over the Brillouin zone introduces sampling error dependent on $N_k$. These two sources of error can be modeled asymptotically with separable dependencies on $E_{\\mathrm{cut}}$ and $N_k$ based on the smoothness of the integrand and the decay of high-$G$ Fourier components. Using these physical bases, construct a linear least squares estimator that produces an infinite-cutoff and infinite-$k$-point adsorption energy $E_{\\infty}$ from measured values at finite $E_{\\mathrm{cut}}$ and $N_k$. Then, estimate the residual error at the best available $(E_{\\mathrm{cut,max}}, N_{k,\\mathrm{max}})$ by evaluating the estimator’s deviation from $E_{\\infty}$ at that pair, and determine whether this meets a specified electrochemical accuracy tolerance.\n\nYour program must:\n- For each test case, fit a linear model in features $x_1 = E_{\\mathrm{cut}}^{-p}$ and $x_2 = N_k^{-q}$ plus a constant offset, where $p$ and $q$ are given. Use linear least squares to estimate the parameters and extract $E_{\\infty}$ as the constant term.\n- Compute the estimated absolute deviation $\\Delta = \\left|E_{\\mathrm{ads}}^{\\mathrm{est}}(E_{\\mathrm{cut,max}}, N_{k,\\mathrm{max}}) - E_{\\infty}\\right|$ in $\\mathrm{eV}$, where $(E_{\\mathrm{cut,max}}, N_{k,\\mathrm{max}})$ are the maximum values of $E_{\\mathrm{cut}}$ and $N_k$ present in the test case data.\n- Compare $\\Delta$ to the tolerance $\\tau$ (in $\\mathrm{eV}$) specified for each case. If $\\Delta \\le \\tau$, output a boolean $True$ for that case; otherwise output $False$.\n\nPhysical units:\n- All energies are in $\\mathrm{eV}$.\n- $E_{\\mathrm{cut}}$ is in $\\mathrm{eV}$.\n- $N_k$ is unitless (cardinality of the sampling grid).\n- All outputs are booleans, with no units.\n\nTest suite:\nProvide the following measured adsorption energies and parameters. Each test case is a list of triples $(E_{\\mathrm{cut}}, N_k, E_{\\mathrm{ads}})$ along with exponents $(p,q)$ and tolerance $\\tau$ in $\\mathrm{eV}$.\n\n- Case 1 (insulating oxide surface; well-converged with respect to $E_{\\mathrm{cut}}$ and $k$-points):\n  Data points in $\\mathrm{eV}$:\n  $(300, 4, -0.4974774955135062)$,\n  $(400, 4, -0.50155)$,\n  $(400, 9, -0.5110808641975309)$,\n  $(500, 9, -0.513158728243)$,\n  $(600, 16, -0.5158166809128011)$.\n  Exponents: $p = 1.5$, $q = 2$.\n  Tolerance: $\\tau = 0.03$ $\\mathrm{eV}$.\n\n- Case 2 (metallic surface; slow $k$-point convergence):\n  Data points in $\\mathrm{eV}$:\n  $(400, 2, -0.08795)$,\n  $(500, 3, -0.1728500517603336)$,\n  $(700, 4, -0.215280751)$,\n  $(700, 6, -0.257047418)$.\n  Exponents: $p = 1.5$, $q = 1$.\n  Tolerance: $\\tau = 0.03$ $\\mathrm{eV}$.\n\n- Case 3 (molecular adsorbate; few-point dataset but sufficiently converged):\n  Data points in $\\mathrm{eV}$:\n  $(300, 6, -0.1071666667)$,\n  $(400, 8, -0.11069375)$,\n  $(500, 12, -0.112893889)$.\n  Exponents: $p = 2$, $q = 2$.\n  Tolerance: $\\tau = 0.03$ $\\mathrm{eV}$.\n\n- Case 4 (challenging metallic convergence; under-sampled $k$-mesh):\n  Data points in $\\mathrm{eV}$:\n  $(300, 2, -0.1418019964108)$,\n  $(350, 3, -0.3108561)$,\n  $(400, 3, -0.3114667)$,\n  $(450, 4, -0.39581038)$.\n  Exponents: $p = 1.5$, $q = 1$.\n  Tolerance: $\\tau = 0.03$ $\\mathrm{eV}$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[result_1, result_2, result_3, result_4]$, where each $result_i$ is the boolean value for case $i$ in the order listed above.",
            "solution": "The problem requires an assessment of the convergence of adsorption energies, $E_{\\mathrm{ads}}$, calculated using plane-wave Density Functional Theory (DFT), with respect to the kinetic energy cutoff, $E_{\\mathrm{cut}}$, and the number of $k$-points, $N_k$. The assessment is based on a physically motivated extrapolation model and a specified numerical tolerance, $\\tau$.\n\nThe foundational principle is the Kohn-Sham formulation of DFT, where the ground-state properties of an interacting electron system are determined via a non-interacting auxiliary system. In practical plane-wave basis set implementations, the Kohn-Sham orbitals are expanded in a basis of plane waves, truncated at a maximum kinetic energy, $E_{\\mathrm{cut}} = \\frac{\\hbar^2}{2m_e} G_{\\max}^2$. This truncation introduces a basis set incompleteness error. Furthermore, integrals over the first Brillouin zone, necessary for periodic systems, are approximated by a discrete sum over a grid of $k$-points, introducing a sampling error.\n\nAccording to the variational principle, the calculated ground-state energy is an upper bound to the true ground-state energy, and it monotonically decreases towards the exact basis set limit as $E_{\\mathrm{cut}}$ increases. The error in total energy often exhibits an asymptotic power-law decay with respect to $E_{\\mathrm{cut}}$, commonly modeled as $A \\cdot E_{\\mathrm{cut}}^{-p}$. Similarly, the error from Brillouin zone integration decreases as the density of the $k$-point mesh, represented here by its cardinality $N_k$, increases. This error can also be modeled by a power law, $B \\cdot N_k^{-q}$. The exponents $p$ and $q$ depend on the properties of the system, such as the smoothness of the pseudopotential and whether the system is metallic or insulating.\n\nFor the adsorption energy, $E_{\\mathrm{ads}} = E_{\\mathrm{tot}}(\\mathrm{slab}+\\mathrm{adsorbate}) - E_{\\mathrm{tot}}(\\mathrm{slab}) - E_{\\mathrm{tot}}(\\mathrm{adsorbate})$, we assume that the errors in the component energies combine such that $E_{\\mathrm{ads}}$ itself follows a similar asymptotic behavior. By assuming separability of the errors, we can formulate a model for the calculated adsorption energy at finite $E_{\\mathrm{cut}}$ and $N_k$:\n$$\nE_{\\mathrm{ads}}(E_{\\mathrm{cut}}, N_k) \\approx E_{\\infty} + c_1 E_{\\mathrm{cut}}^{-p} + c_2 N_k^{-q}\n$$\nHere, $E_{\\infty}$ represents the desired, fully converged adsorption energy, extrapolated to an infinite basis set ($E_{\\mathrm{cut}} \\to \\infty$) and an infinitely dense $k$-point mesh ($N_k \\to \\infty$). The terms $c_1 E_{\\mathrm{cut}}^{-p}$ and $c_2 N_k^{-q}$ represent the leading-order residual errors due to basis set and $k$-point sampling limitations, respectively.\n\nThis model is linear in the parameters $\\beta_0 = E_{\\infty}$, $\\beta_1 = c_1$, and $\\beta_2 = c_2$. Given a set of $m$ computed data points $(E_{\\mathrm{cut},i}, N_{k,i}, E_{\\mathrm{ads},i})$, we can determine these parameters via linear least squares. We define the features $x_{1,i} = E_{\\mathrm{cut},i}^{-p}$ and $x_{2,i} = N_{k,i}^{-q}$, and the response variable $y_i = E_{\\mathrm{ads},i}$. The model becomes a standard multilinear regression problem:\n$$\ny_i = \\beta_0 \\cdot 1 + \\beta_1 x_{1,i} + \\beta_2 x_{2,i} + \\epsilon_i\n$$\nThis can be expressed in matrix form as $\\mathbf{y} = \\mathbf{A}\\beta + \\epsilon$, where $\\mathbf{y}$ is the vector of observed energies, $\\beta = [\\beta_0, \\beta_1, \\beta_2]^T$ is the vector of parameters to be estimated, and $\\mathbf{A}$ is the $m \\times 3$ design matrix with rows $[1, x_{1,i}, x_{2,i}]$. The least squares estimate for $\\beta$, denoted $\\hat{\\beta}$, minimizes the sum of squared residuals and is found by solving the normal equations $(\\mathbf{A}^T\\mathbf{A})\\hat{\\beta} = \\mathbf{A}^T\\mathbf{y}$. This is efficiently solved using numerical linear algebra libraries.\n\nOnce the parameters $\\hat{\\beta} = [\\hat{\\beta}_0, \\hat{\\beta}_1, \\hat{\\beta}_2]^T$ are determined, the extrapolated energy is $\\hat{E}_{\\infty} = \\hat{\\beta}_0$. The problem then asks to estimate the residual error at the highest level of theory available in the provided dataset, identified by $(E_{\\mathrm{cut,max}}, N_{k,\\mathrm{max}})$. The estimated adsorption energy from the model at these parameters is:\n$$\nE_{\\mathrm{ads}}^{\\mathrm{est}}(E_{\\mathrm{cut,max}}, N_{k,\\mathrm{max}}) = \\hat{\\beta}_0 + \\hat{\\beta}_1 E_{\\mathrm{cut,max}}^{-p} + \\hat{\\beta}_2 N_{k,\\mathrm{max}}^{-q}\n$$\nThe absolute deviation from the extrapolated limit is a measure of the remaining convergence error:\n$$\n\\Delta = \\left|E_{\\mathrm{ads}}^{\\mathrm{est}}(E_{\\mathrm{cut,max}}, N_{k,\\mathrm{max}}) - \\hat{E}_{\\infty}\\right| = \\left|\\hat{\\beta}_1 E_{\\mathrm{cut,max}}^{-p} + \\hat{\\beta}_2 N_{k,\\mathrm{max}}^{-q}\\right|\n$$\nFinally, this deviation $\\Delta$ is compared to a given electrochemical accuracy tolerance, $\\tau$. If $\\Delta \\le \\tau$, the calculation is deemed sufficiently converged; otherwise, it is not. The procedure involves, for each test case, constructing the design matrix $\\mathbf{A}$ and response vector $\\mathbf{y}$ from the given data and exponents, solving for the coefficient vector $\\hat{\\beta}$, calculating $\\Delta$ using the maximum $E_{\\mathrm{cut}}$ and $N_k$ values from the data, and comparing $\\Delta$ to $\\tau$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DFT convergence problem for a suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"id\": 1,\n            \"data\": [\n                (300, 4, -0.4974774955135062),\n                (400, 4, -0.50155),\n                (400, 9, -0.5110808641975309),\n                (500, 9, -0.513158728243),\n                (600, 16, -0.5158166809128011),\n            ],\n            \"p\": 1.5,\n            \"q\": 2.0,\n            \"tau\": 0.03,\n        },\n        {\n            \"id\": 2,\n            \"data\": [\n                (400, 2, -0.08795),\n                (500, 3, -0.1728500517603336),\n                (700, 4, -0.215280751),\n                (700, 6, -0.257047418),\n            ],\n            \"p\": 1.5,\n            \"q\": 1.0,\n            \"tau\": 0.03,\n        },\n        {\n            \"id\": 3,\n            \"data\": [\n                (300, 6, -0.1071666667),\n                (400, 8, -0.11069375),\n                (500, 12, -0.112893889),\n            ],\n            \"p\": 2.0,\n            \"q\": 2.0,\n            \"tau\": 0.03,\n        },\n        {\n            \"id\": 4,\n            \"data\": [\n                (300, 2, -0.1418019964108),\n                (350, 3, -0.3108561),\n                (400, 3, -0.3114667),\n                (450, 4, -0.39581038),\n            ],\n            \"p\": 1.5,\n            \"q\": 1.0,\n            \"tau\": 0.03,\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        data = case[\"data\"]\n        p = case[\"p\"]\n        q = case[\"q\"]\n        tau = case[\"tau\"]\n\n        # Unpack data into separate lists/arrays\n        E_cuts = np.array([d[0] for d in data])\n        N_ks = np.array([d[1] for d in data])\n        E_ads_vals = np.array([d[2] for d in data])\n\n        # Construct the design matrix A for the linear model\n        # E_ads = beta_0 + beta_1 * E_cut**(-p) + beta_2 * N_k**(-q)\n        num_points = len(data)\n        A = np.zeros((num_points, 3))\n        A[:, 0] = 1.0  # Constant term for beta_0 (E_infinity)\n        A[:, 1] = E_cuts ** (-p)  # Feature for beta_1\n        A[:, 2] = N_ks ** (-q)    # Feature for beta_2\n        \n        # Define the response vector y\n        y = E_ads_vals\n\n        # Solve the linear least squares problem A*beta = y for beta\n        # np.linalg.lstsq returns (solution, residuals, rank, singular values)\n        # We need the solution vector, which are the coefficients [beta_0, beta_1, beta_2]\n        coeffs = np.linalg.lstsq(A, y, rcond=None)[0]\n        \n        # The coefficients are:\n        # beta_0 = E_infinity (extrapolated energy)\n        # beta_1 = c1 (coefficient for E_cut term)\n        # beta_2 = c2 (coefficient for N_k term)\n        beta_1 = coeffs[1]\n        beta_2 = coeffs[2]\n\n        # Find the maximum E_cut and N_k from the dataset\n        E_cut_max = np.max(E_cuts)\n        N_k_max = np.max(N_ks)\n\n        # Calculate the estimated absolute deviation Delta\n        # Delta = |E_ads_est(E_cut_max, N_k_max) - E_infinity|\n        # Delta = |(beta_0 + beta_1*x1_max + beta_2*x2_max) - beta_0|\n        # Delta = |beta_1*E_cut_max**(-p) + beta_2*N_k_max**(-q)|\n        delta = abs(beta_1 * (E_cut_max ** (-p)) + beta_2 * (N_k_max ** (-q)))\n\n        # Compare Delta to the tolerance tau\n        is_converged = delta <= tau\n        results.append(is_converged)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Beyond numerical convergence, a deep understanding of DFT requires grasping the physical meaning of its theoretical constructs, such as the Kohn-Sham eigenvalues. Janak's theorem provides this crucial link, stating that the derivative of the total energy with respect to the occupation number of an orbital is exactly equal to that orbital's eigenvalue: $\\frac{\\partial E_{\\mathrm{tot}}}{\\partial f_i} = \\epsilon_i$. This exercise guides you through the construction of a simple self-consistent field (SCF) model to numerically verify this theorem, offering profound insight into the relationship between energy, electronic states, and fractional charges at electrochemical interfaces. ",
            "id": "4241335",
            "problem": "Consider a minimal Kohn–Sham formulation of Density Functional Theory (DFT) for a simple two-orbital system modeling a molecule adsorbed on a metal surface. The system is represented in a minimal orthonormal basis set of two localized orbitals: one centered on the adsorbate site and one on the metal site. The electron is treated as spinless for simplicity, and the number of occupied Kohn–Sham orbitals is two, with the lowest-energy orbital filled with occupation $f_1 = 1$, and the higher-energy orbital carrying a fractional occupation $f_2 \\in [0,1]$. The total energy functional and effective Kohn–Sham Hamiltonian should be constructed from first principles using the following ingredients.\n\nFoundational base:\n- The Kohn–Sham energy functional from Density Functional Theory (DFT) is given by the sum of the non-interacting kinetic energy, the ionic (pseudopotential) external potential energy, the classical Hartree energy, and the exchange–correlation energy.\n- The Hartree energy on a discrete lattice is modeled as a local quadratic form. The exchange–correlation energy is modeled within the Local Density Approximation (LDA) using a simplified exchange-only form.\n\nDefinitions and modeling assumptions:\n- The effective Kohn–Sham Hamiltonian $H_{\\mathrm{KS}}$ is a $2 \\times 2$ real symmetric matrix in an orthonormal basis set, consisting of on-site terms and a coupling term. Let the on-site ionic pseudopotential energies be $v_{\\mathrm{ion},A}$ and $v_{\\mathrm{ion},M}$ for the adsorbate and metal sites, respectively. Let the adsorbate–metal coupling be $t$.\n- The site densities $n_A$ and $n_M$ are computed self-consistently from the occupied Kohn–Sham orbitals: $n_s = \\sum_{k=1}^{2} f_k |\\langle s | \\psi_k \\rangle|^2$ for $s \\in \\{A,M\\}$, where $|\\psi_k\\rangle$ are normalized eigenvectors of $H_{\\mathrm{KS}}$ and $f_k$ are the corresponding occupations.\n- The Hartree energy is $E_H[n] = \\frac{1}{2} U \\left(n_A^2 + n_M^2\\right)$, with $U > 0$ a local Coulomb interaction parameter. The corresponding Hartree potentials are $v_{H,s}(n_s) = \\frac{\\partial E_H}{\\partial n_s} = U n_s$ for $s \\in \\{A,M\\}$.\n- The exchange energy is modeled by a Local Density Approximation (LDA) exchange-only term $E_x[n] = -\\alpha \\left(n_A^{4/3} + n_M^{4/3}\\right)$, with $\\alpha > 0$. The exchange potential is $v_{x,s}(n_s) = \\frac{\\partial E_x}{\\partial n_s} = -\\frac{4}{3} \\alpha n_s^{1/3}$.\n- The effective Kohn–Sham Hamiltonian is\n$$\nH_{\\mathrm{KS}}(n_A,n_M) =\n\\begin{pmatrix}\nv_{\\mathrm{ion},A} + U n_A + v_{x,A}(n_A) & t \\\\\nt & v_{\\mathrm{ion},M} + U n_M + v_{x,M}(n_M)\n\\end{pmatrix}.\n$$\n- The total energy is computed from the Kohn–Sham eigenvalues $\\{\\epsilon_k\\}$ and site densities $\\{n_A,n_M\\}$ using the standard double-counting corrections:\n$$\nE_{\\mathrm{tot}}[n] = \\sum_{k=1}^{2} f_k \\epsilon_k - E_H[n] - \\sum_{s \\in \\{A,M\\}} n_s v_{x,s}(n_s) + E_x[n].\n$$\n- Self-consistency: For each given fractional occupation $f_2$, the site densities $\\{n_A,n_M\\}$ must be determined self-consistently by iterating the mapping from densities to Hamiltonian, to eigenvectors and occupations, and back to densities, until a fixed point is reached within a numerical tolerance.\n\nGoal:\n- Numerically verify the relationship between the sensitivity of the total energy $E_{\\mathrm{tot}}$ to the fractional occupation $f_2$ and the Kohn–Sham eigenvalue $\\epsilon_2$ associated with the fractionally occupied state, by computing the numerical derivative $\\frac{dE_{\\mathrm{tot}}}{df_2}$ and comparing it to $\\epsilon_2$ across a set of fractional occupations. The comparison should be quantified by the maximum absolute deviation between $\\frac{dE_{\\mathrm{tot}}}{df_2}$ and $\\epsilon_2$ over a prescribed grid of $f_2$ values.\n\nComputational electrochemistry context:\n- The adsorbate–metal model mimics a molecule adsorbed onto a metallic surface in an electrochemical environment. The pseudopotential terms $v_{\\mathrm{ion},A}$ and $v_{\\mathrm{ion},M}$ represent effective ionic potentials appropriate to a minimal basis set treatment. The Local Density Approximation (LDA) exchange term emulates the exchange contribution commonly used in practical Density Functional Theory (DFT) for metals and adsorbates, and the Hartree term models classical electrostatic interactions due to charge redistribution upon adsorption.\n\nTasks to implement:\n- Construct and solve the self-consistent Kohn–Sham equations for the two-orbital system for each specified $f_2$ and parameter set.\n- Compute the total energy $E_{\\mathrm{tot}}(f_2)$ using the specified expression.\n- Compute the numerical derivative $\\frac{dE_{\\mathrm{tot}}}{df_2}$ via finite differences using a small increment $\\delta f$; use a central difference where possible and one-sided differences at the boundaries $f_2=0$ and $f_2=1$.\n- For each $f_2$ value, compute the absolute deviation $|\\frac{dE_{\\mathrm{tot}}}{df_2}-\\epsilon_2|$ and report the maximum deviation across the grid for each parameter set.\n- All energies must be expressed in electronvolts, abbreviated as eV. The final deviations must be reported in eV.\n\nTest suite:\n- Use the fractional occupation grid $f_2 \\in \\{0.0, 0.25, 0.5, 0.75, 1.0\\}$ and a finite-difference increment $\\delta f = 10^{-3}$.\n- Provide the following parameter sets, each as a tuple $(v_{\\mathrm{ion},A}, v_{\\mathrm{ion},M}, t, U, \\alpha)$ in eV:\n    1. $( -5.0, 0.0, 0.8, 1.0, 0.5 )$ representing a typical adsorbate below the metal level, moderate coupling, and moderate interactions.\n    2. $( -2.0, 0.0, 0.1, 1.0, 0.5 )$ representing weak adsorbate–metal coupling.\n    3. $( -1.0, 0.5, 1.2, 0.0, 0.0 )$ representing the non-interacting limit to test the baseline behavior.\n    4. $( -3.0, 0.0, 1.5, 4.0, 1.0 )$ representing strong electrostatic and exchange interactions.\n- Convergence tolerance for the self-consistency loop should be set to $10^{-10}$ in absolute density, and a simple linear mixing scheme may be employed with a mixing parameter in $(0,1)$ and a maximum iteration count of at least $1000$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the maximum deviations for the four parameter sets as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"). Each result must be a float in eV.\n\nNo external input should be read; all constants and parameters must be defined inside the program. The code must be self-contained and runnable in any standard Python environment adhering to the given library constraints.",
            "solution": "The task is to numerically verify the relationship $\\frac{dE_{\\mathrm{tot}}}{df_2} = \\epsilon_2$ for a model two-orbital system described within the Kohn-Sham (KS) DFT framework. Here, $E_{\\mathrm{tot}}$ is the total energy, $f_2$ is the fractional occupation of the second KS orbital, and $\\epsilon_2$ is the corresponding KS eigenvalue. This relationship is a form of Janak's theorem, which states that the derivative of the total energy with respect to the occupation number of an orbital is equal to the energy of that orbital. This verification requires implementing a self-consistent field (SCF) procedure to solve the KS equations for various values of $f_2$.\n\nThe core of the problem lies in the self-consistent determination of the site densities, $\\{n_A, n_M\\}$, for the adsorbate and metal sites. The process begins with an initial guess for the densities, which are used to construct the KS Hamiltonian, $H_{\\mathrm{KS}}$. The Hamiltonian depends on the densities through the Hartree potential, $v_{H,s}(n_s) = U n_s$, and the exchange potential, $v_{x,s}(n_s) = -\\frac{4}{3} \\alpha n_s^{1/3}$. The $2 \\times 2$ KS Hamiltonian matrix is given by:\n$$\nH_{\\mathrm{KS}}(n_A,n_M) =\n\\begin{pmatrix}\nv_{\\mathrm{ion},A} + U n_A - \\frac{4}{3} \\alpha n_A^{1/3} & t \\\\\nt & v_{\\mathrm{ion},M} + U n_M - \\frac{4}{3} \\alpha n_M^{1/3}\n\\end{pmatrix}\n$$\nDiagonalizing this Hamiltonian yields two eigenvalues, $\\epsilon_1 \\le \\epsilon_2$, and their corresponding normalized eigenvectors, $|\\psi_1\\rangle$ and $|\\psi_2\\rangle$. These eigenvectors are used to compute new site densities according to the formula:\n$$\nn_s = \\sum_{k=1}^{2} f_k |\\langle s | \\psi_k \\rangle|^2 = (1.0) \\cdot |\\langle s | \\psi_1 \\rangle|^2 + f_2 \\cdot |\\langle s | \\psi_2 \\rangle|^2 \\quad \\text{for } s \\in \\{A,M\\}\n$$\nwhere $f_1=1$ and $f_2$ is a given parameter. The new densities are then mixed with the old densities, and the process is iterated until the densities converge to a fixed point, i.e., the difference between input and output densities is below a specified tolerance. This iterative procedure is known as the self-consistent field (SCF) cycle.\n\nOnce the densities and KS orbitals are converged for a given $f_2$, the total energy $E_{\\mathrm{tot}}$ is calculated. The problem provides the standard expression for the total energy, which corrects for the double-counting of electron-electron interactions in the sum of eigenvalues:\n$$\nE_{\\mathrm{tot}}[n] = \\sum_{k=1}^{2} f_k \\epsilon_k - E_H[n] - \\sum_{s \\in \\{A,M\\}} n_s v_{x,s}(n_s) + E_x[n]\n$$\nSubstituting the given forms for the Hartree and exchange-only LDA energies and potentials, $E_H[n] = \\frac{1}{2} U (n_A^2 + n_M^2)$, $E_x[n] = -\\alpha (n_A^{4/3} + n_M^{4/3})$, and $v_{x,s}(n_s) = -\\frac{4}{3} \\alpha n_s^{1/3}$, allows for a simplification of the energy expression:\n$$\n\\begin{align*}\nE_{\\mathrm{tot}}[n] &= \\sum_{k=1}^{2} f_k \\epsilon_k - \\frac{1}{2} U(n_A^2 + n_M^2) - \\left[ n_A \\left(-\\frac{4}{3}\\alpha n_A^{1/3}\\right) + n_M \\left(-\\frac{4}{3}\\alpha n_M^{1/3}\\right) \\right] + \\left[ -\\alpha(n_A^{4/3} + n_M^{4/3}) \\right] \\\\\n&= \\sum_{k=1}^{2} f_k \\epsilon_k - \\frac{1}{2} U(n_A^2 + n_M^2) + \\frac{4}{3}\\alpha(n_A^{4/3} + n_M^{4/3}) - \\alpha(n_A^{4/3} + n_M^{4/3}) \\\\\n&= \\sum_{k=1}^{2} f_k \\epsilon_k - \\frac{1}{2} U(n_A^2 + n_M^2) + \\frac{1}{3}\\alpha(n_A^{4/3} + n_M^{4/3})\n\\end{align*}\n$$\nThis simplified form is computationally more direct and robust.\n\nTo verify Janak's theorem, we need to compute the derivative $\\frac{dE_{\\mathrm{tot}}}{df_2}$. This is done numerically using finite differences. For each point $f_{2,i}$ in the specified grid $\\{0.0, 0.25, 0.5, 0.75, 1.0\\}$, the derivative is approximated as:\n- Forward difference at $f_{2,i}=0.0$: $\\frac{E_{\\mathrm{tot}}(f_{2,i}+\\delta f) - E_{\\mathrm{tot}}(f_{2,i})}{\\delta f}$\n- Backward difference at $f_{2,i}=1.0$: $\\frac{E_{\\mathrm{tot}}(f_{2,i}) - E_{\\mathrm{tot}}(f_{2,i}-\\delta f)}{\\delta f}$\n- Central difference for interior points: $\\frac{E_{\\mathrm{tot}}(f_{2,i}+\\delta f) - E_{\\mathrm{tot}}(f_{2,i}-\\delta f)}{2\\delta f}$\nwhere $\\delta f = 10^{-3}$ is a small increment. Calculating each $E_{\\mathrm{tot}}$ value requires running a full SCF cycle.\n\nFinally, for each $f_{2,i}$ in the grid, we calculate the absolute deviation $|\\frac{dE_{\\mathrm{tot}}}{df_2} - \\epsilon_2(f_{2,i})|$, where $\\epsilon_2(f_{2,i})$ is the eigenvalue of the second KS orbital obtained from the converged SCF calculation at occupation $f_2 = f_{2,i}$. The maximum of these deviations across the grid is the final result for each parameter set.\n\nThe algorithm is implemented for each provided parameter set, and the maximum deviation is reported. The non-interacting case (where $U=0, \\alpha=0$) serves as a crucial baseline, for which Janak's theorem is expected to hold exactly, with any deviation arising purely from numerical precision and finite-difference approximation error. The other test cases probe the validity of the theorem under increasing interaction strengths.",
            "answer": "```python\nimport numpy as np\n\ndef solve_scf(f2, params, mixing_beta=0.5, tol=1e-10, max_iter=1000):\n    \"\"\"\n    Solves the Kohn-Sham equations self-consistently for a given\n    fractional occupation f2 and parameter set.\n\n    Args:\n        f2 (float): Fractional occupation of the second KS orbital.\n        params (tuple): (v_ion_a, v_ion_m, t, U, alpha).\n        mixing_beta (float): Linear mixing parameter for SCF iterations.\n        tol (float): Convergence tolerance for the site densities.\n        max_iter (int): Maximum number of SCF iterations.\n\n    Returns:\n        tuple: (epsilon_2, E_total) where epsilon_2 is the eigenvalue of the\n               second KS orbital and E_total is the total energy.\n    \"\"\"\n    v_ion_a, v_ion_m, t, U, alpha = params\n    f1 = 1.0\n\n    # Initial guess for densities, preserving the total number of electrons\n    total_electrons = f1 + f2\n    n_a = 0.5 * total_electrons\n    n_m = 0.5 * total_electrons\n\n    for _ in range(max_iter):\n        n_a_old, n_m_old = n_a, n_m\n\n        # Exchange potentials. Use np.cbrt for cubic root.\n        vx_a = -4/3 * alpha * np.cbrt(n_a) if n_a > 0 else 0.0\n        vx_m = -4/3 * alpha * np.cbrt(n_m) if n_m > 0 else 0.0\n\n        # Construct the Kohn-Sham Hamiltonian\n        h_ks = np.array([\n            [v_ion_a + U * n_a + vx_a, t],\n            [t, v_ion_m + U * n_m + vx_m]\n        ])\n\n        # Diagonalize H_KS to get eigenvalues and eigenvectors\n        eigenvalues, eigenvectors = np.linalg.eigh(h_ks)\n        eps1, eps2 = eigenvalues\n        psi1, psi2 = eigenvectors[:, 0], eigenvectors[:, 1]\n        \n        # Components of eigenvectors: psi_k = (c_Ak, c_Mk)^T\n        # numpy eigenvectors are columns: eigenvectors = [[c_A1, c_A2], [c_M1, c_M2]]\n        c_a1_sq = psi1[0]**2\n        c_m1_sq = psi1[1]**2\n        c_a2_sq = psi2[0]**2\n        c_m2_sq = psi2[1]**2\n\n        # Calculate new densities from occupied orbitals\n        n_a_new = f1 * c_a1_sq + f2 * c_a2_sq\n        n_m_new = f1 * c_m1_sq + f2 * c_m2_sq\n\n        # Check for convergence\n        density_diff = max(abs(n_a_new - n_a), abs(n_m_new - n_m))\n        if density_diff < tol:\n            n_a, n_m = n_a_new, n_m_new\n            break\n\n        # Linear mixing of densities for next iteration\n        n_a = (1 - mixing_beta) * n_a + mixing_beta * n_a_new\n        n_m = (1 - mixing_beta) * n_m + mixing_beta * n_m_new\n    else:\n        # This block executes if the loop finishes without converging\n        # For this problem, we assume convergence is always reached\n        pass\n\n    # Calculate total energy using the simplified expression\n    # E_tot = sum(f_k*eps_k) - 0.5*U*sum(n_s^2) + (1/3)*alpha*sum(n_s^(4/3))\n    # Using np.power for n_s^(4/3) is robust for n_s=0.\n    e_tot = (f1 * eps1 + f2 * eps2) - 0.5 * U * (n_a**2 + n_m**2) \\\n            + (1/3) * alpha * (np.power(n_a, 4/3) + np.power(n_m, 4/3))\n\n    return eps2, e_tot\n\ndef solve():\n    \"\"\"\n    Main function to run the DFT calculation for all test cases and print the result.\n    \"\"\"\n    # Parameter sets: (v_ion_A, v_ion_M, t, U, alpha) in eV\n    test_cases = [\n        (-5.0, 0.0, 0.8, 1.0, 0.5),\n        (-2.0, 0.0, 0.1, 1.0, 0.5),\n        (-1.0, 0.5, 1.2, 0.0, 0.0),\n        (-3.0, 0.0, 1.5, 4.0, 1.0)\n    ]\n\n    f2_grid = [0.0, 0.25, 0.5, 0.75, 1.0]\n    delta_f = 1e-3\n    \n    all_max_deviations = []\n\n    for params in test_cases:\n        deviations = []\n        for f2_val in f2_grid:\n            # Get the KS eigenvalue at the grid point f2_val\n            eps2_at_f2, _ = solve_scf(f2_val, params)\n\n            # Compute numerical derivative dE_tot/df2\n            if f2_val == 0.0:\n                # Forward difference at the lower boundary\n                _, e_tot_0 = solve_scf(f2_val, params)\n                _, e_tot_p = solve_scf(f2_val + delta_f, params)\n                dE_df2 = (e_tot_p - e_tot_0) / delta_f\n            elif f2_val == 1.0:\n                # Backward difference at the upper boundary\n                _, e_tot_0 = solve_scf(f2_val, params)\n                _, e_tot_m = solve_scf(f2_val - delta_f, params)\n                dE_df2 = (e_tot_0 - e_tot_m) / delta_f\n            else:\n                # Central difference for interior points\n                _, e_tot_p = solve_scf(f2_val + delta_f, params)\n                _, e_tot_m = solve_scf(f2_val - delta_f, params)\n                dE_df2 = (e_tot_p - e_tot_m) / (2 * delta_f)\n\n            # Calculate and store the deviation\n            dev = abs(dE_df2 - eps2_at_f2)\n            deviations.append(dev)\n        \n        # Find the maximum deviation for the current parameter set\n        all_max_deviations.append(max(deviations))\n\n    # Print results in the required format\n    print(f\"[{','.join(f'{dev:.12f}' for dev in all_max_deviations)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While powerful, the practical application of DFT relies on approximate exchange-correlation functionals, which can introduce systematic errors. A particularly important failure is the delocalization error, which arises because most approximations violate the exact piecewise linearity of the total energy $E(N)$ as a function of the number of electrons $N$. This practice uses a clear and illustrative model to demonstrate how this incorrect convex curvature of $E(N)$ artificially favors the delocalization of fractional charges, a critical concept for correctly modeling charge transfer and redox processes in electrochemistry. ",
            "id": "4241373",
            "problem": "Consider the foundational principles of Density Functional Theory (DFT) as used in computational electrochemistry, specifically the Hohenberg–Kohn variational principle, the Kohn–Sham noninteracting reference system, and the ensemble formulation for noninteger electron numbers. The exact ground-state energy as a function of electron number, denoted by $E(N)$, exhibits a mathematically precise structure for $N$ between integers that is central to charge transfer and surface charging in electrochemical environments. In exact theory, $E(N)$ between integers is constrained by variational arguments and ensemble mixing. In practice, approximate exchange–correlation functionals and finite basis sets with pseudopotentials can induce curvature in $E(N)$ for fractional electron numbers, which is known to cause delocalization error, an artifact whereby fractional charge spreads across spatially separated regions to spuriously lower the energy. Your task is to derive from these principles a quantitative test of piecewise linearity and a diagnostic for delocalization error using a mathematically self-consistent model that mimics Kohn–Sham DFT with pseudopotentials and a finite basis on a model surface.\n\nYou must design a program that implements two energy models for a surface fragment under fractional charging in an electrochemical setting:\n- An exact model for $E(N)$ between integers derived from the ensemble variational principle and justified via Janak’s theorem (derivative of the total energy with respect to orbital occupation equals the Kohn–Sham eigenvalue) and the derivative discontinuity at integers.\n- An approximate model that captures a convex deviation from piecewise linearity associated with semilocal exchange–correlation and finite-basis/pseudopotential effects. The approximation must be parameterized by a single curvature parameter that represents the magnitude of deviation from linearity between integers.\n\nYou must formalize a two-site noninteracting surface model with $m$ identical, noninteracting patches that can accept fractional electron charge. Fractional charge is controlled by an electrochemical potential and enters the energy through the electron affinity for addition or the ionization potential for removal. For identical patches, the exact theory must not prefer delocalization of fractional charge across patches, whereas the approximate convex model must lower the energy by delocalizing fractional charge. For heterogeneous patches with different frontier energetics, exact theory must prefer localization on the patch with more favorable frontier energetics.\n\nYour program must compute, for each test case:\n1. A scalar quantification of the deviation from piecewise linearity at a specified fractional electron amount on a single patch. This quantity must be defined as the signed deviation of the approximate energy at the fractional electron number from the linear interpolation between the adjacent integers implied by exact theory. Output in $\\mathrm{eV}$.\n2. The energy advantage of delocalization across patches in the approximate model, computed as the total energy change when a fixed total fractional electron is split equally across patches versus localized entirely on the most favorable single patch. Output in $\\mathrm{eV}$ (negative values indicate a preference for delocalization).\n3. A boolean that indicates whether the approximate model prefers delocalization across patches (true if the equally split state has lower energy than the localized state).\n4. A scalar verification for the exact model equal-split versus localized energy difference. For identical patches, this must be zero; for heterogeneous patches, this must be a positive value that indicates localization onto the more favorable patch is preferred in exact theory. Output in $\\mathrm{eV}$.\n\nAll energies must be expressed in electronvolts, i.e., in $\\mathrm{eV}$, and all electron-number quantities are dimensionless. If angles are used they must be specified in radians, but no angles are needed here.\n\nThe test suite consists of five cases that collectively probe the happy path, boundary conditions, addition and removal, heterogeneity, and scaling with the number of patches:\n- Test $1$ (happy path, addition on identical patches): electron affinity $A = 3.0\\,\\mathrm{eV}$, curvature parameter $c = 0.6\\,\\mathrm{eV}$, total fractional electron to add $\\delta = 0.4$ (dimensionless), number of identical patches $m = 2$.\n- Test $2$ (boundary integer, addition on identical patches): electron affinity $A = 3.0\\,\\mathrm{eV}$, curvature parameter $c = 0.6\\,\\mathrm{eV}$, total fractional electron to add $\\delta = 1.0$, number of identical patches $m = 2$.\n- Test $3$ (removal on identical patches): ionization potential $I = 5.0\\,\\mathrm{eV}$, curvature parameter $c = 0.3\\,\\mathrm{eV}$, total fractional electron to remove $\\varphi = 0.25$ (dimensionless), number of identical patches $m = 2$.\n- Test $4$ (heterogeneous patches, addition): patch electron affinity list $A_1 = 2.5\\,\\mathrm{eV}$ and $A_2 = 3.0\\,\\mathrm{eV}$, curvature parameter $c = 0.5\\,\\mathrm{eV}$ applied identically to both patches, total fractional electron to add $\\delta = 0.6$, number of patches $m = 2$.\n- Test $5$ (many identical patches, addition): electron affinity $A = 3.5\\,\\mathrm{eV}$, curvature parameter $c = 0.4\\,\\mathrm{eV}$, total fractional electron to add $\\delta = 0.8$, number of identical patches $m = 10$.\n\nImplement the energy models using the following context-appropriate bases:\n- The ensemble variational principle for $E(N)$ between integers and constancy of the slope given by frontier energetics for addition or removal.\n- Janak’s theorem for Kohn–Sham DFT linking orbital occupations to energy derivatives, and the derivative discontinuity at integer $N$.\n- The noninteracting Kohn–Sham mapping in the presence of pseudopotentials and basis sets, modeled here by frontier parameters (electron affinity for addition and ionization potential for removal) and a single curvature parameter that summarizes exchange–correlation and representation error.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is a list of four values in the exact order prescribed above. For example: $[[$case\\_1\\_result$],[$case\\_2\\_result$],\\dots]$. Round no values; return raw floating-point results as computed.",
            "solution": "We start from the Hohenberg–Kohn variational principle, which states that the ground-state energy $E[n]$ is a functional of the electron density $n(\\mathbf{r})$ and that the correct ground-state density minimizes the functional. In the ensemble generalization applicable to fractional electron numbers, the exact ground-state energy $E(N)$ between integers is the convex hull of the integer $E(M)$ values and is therefore a straight line between adjacent integers. For $N = M + \\alpha$ with $0 \\le \\alpha \\le 1$, it follows that $E(N)$ is the ensemble mixture of the $M$- and $(M+1)$-electron energies, which is linear in $\\alpha$. For addition of electrons, the slope of $E(N)$ between integers is determined by frontier energetics and equals the negative electron affinity for the next integer, and for removal the slope equals the ionization potential. This can be connected to Kohn–Sham theory through Janak’s theorem, which yields $\\partial E / \\partial f_i = \\varepsilon_i$ for orbital occupation $f_i$ and Kohn–Sham eigenvalue $\\varepsilon_i$. The derivative discontinuity at integer $N$ is associated with a jump in the exchange–correlation potential ensuring correct piecewise linearity.\n\nApproximate exchange–correlation functionals (such as local and semilocal forms) and finite representation via basis sets and pseudopotentials typically lack the derivative discontinuity and induce curvature in $E(N)$, often convex with respect to electron number. Convexity implies that, for separated fragments, the energy of fractional charge distribution is spuriously lowered relative to the correct linear interpolation, creating the delocalization error: fractional charge spreads across multiple fragments to gain energy, contrary to the exact theory for identical fragments where distribution should not affect energy.\n\nWe model these facts with two energy forms that distill the essential physics while remaining purely mathematical:\n- Exact energy between integers for addition: for a single surface patch, define the energy change as linear in the added electron fraction $\\alpha$, with slope set by the electron affinity. Similarly, for removal, define the energy change linear in the removed fraction $\\varphi$, with slope set by the ionization potential. This realizes the ensemble piecewise linearity and constant slope between integers.\n- Approximate energy between integers: we introduce a convex deviation represented by a single curvature parameter $c$ such that the energy between integers is a linear baseline plus a convex term. For addition, this convex term lowers the energy at intermediate fractional occupancy, and similarly for removal.\n\nWe construct a surface model with $m$ noninteracting patches. For identical patches, the exact energy summed over patches is independent of how a fixed total fractional electron is distributed because all patches share the same linear slope; hence the equal split and localization on a single patch yield the same total energy. For heterogeneous patches, exact theory prefers localization on the patch with larger electron affinity (for addition) or smaller ionization energy (for removal), which minimizes the linear energy with respect to distribution. In contrast, for the approximate convex model, splitting a fixed fractional charge evenly across $m$ identical patches lowers the total energy relative to localizing on a single patch, with a stronger preference as $m$ grows.\n\nAlgorithmic design:\n1. For addition on a single patch, define a signed deviation from linearity at fractional $\\alpha$ as the difference between the approximate energy at $\\alpha$ and the linear interpolation between integer endpoints. This quantity is negative for convex deviation, and its magnitude characterizes the piecewise linearity error.\n2. For $m$ patches and a total fractional electron $\\delta$ to add, compute two energies: localized (all $\\delta$ placed on the most favorable patch) and delocalized (equal split $\\delta/m$ placed on each patch). For identical patches, the most favorable patch can be any. Compare the energies in the approximate model to determine the energy advantage of delocalization and a boolean preference. Compute the same difference under the exact model as a check: zero for identical patches, positive for heterogeneous patches when localized on the best patch is optimal.\n3. For removal, mirror the definitions using the ionization potential and fractional removal $\\varphi$.\n\nFor each of the five tests:\n- Test $1$: identical patch addition case with $\\delta = 0.4$, $m = 2$, electron affinity $A = 3.0\\,\\mathrm{eV}$, curvature $c = 0.6\\,\\mathrm{eV}$. The piecewise linear deviation on one patch at $\\alpha = 0.4$ is computed, and the energy change for splitting across two patches is compared to localization on one patch in the approximate and exact models.\n- Test $2$: integer boundary with $\\delta = 1.0$ shows zero single-patch linearity deviation but still a multi-patch delocalization preference in the approximate model because splitting one electron across two identical patches lowers the energy via curvature, while the exact model yields no difference.\n- Test $3$: removal on identical patches with $\\varphi = 0.25$, $I = 5.0\\,\\mathrm{eV}$, $c = 0.3\\,\\mathrm{eV}$ mirrors the addition case; the piecewise linear deviation and delocalization preference are computed analogously.\n- Test $4$: heterogeneous patches with $A_1 = 2.5\\,\\mathrm{eV}$ and $A_2 = 3.0\\,\\mathrm{eV}$, $c = 0.5\\,\\mathrm{eV}$, $\\delta = 0.6$, $m = 2$ demonstrate that exact theory prefers localization on the higher-$A$ patch, producing a positive exact equal-split versus localized difference, while the approximate model may still prefer delocalization depending on the curvature parameter.\n- Test $5$: $m = 10$ identical patches with $A = 3.5\\,\\mathrm{eV}$, $c = 0.4\\,\\mathrm{eV}$, and $\\delta = 0.8$ illustrate that the delocalization advantage grows with the number of patches under convex curvature.\n\nImplementation details:\n- Electron affinity $A$ and ionization potential $I$ are inputs in $\\mathrm{eV}$.\n- Curvature $c$ is in $\\mathrm{eV}$ and controls the magnitude of convex deviation; larger $c$ yields stronger delocalization preference.\n- All computed energies are in $\\mathrm{eV}$, and electron fractions $\\alpha$, $\\delta$, and $\\varphi$ are dimensionless.\n\nThe final output is a single line: a list of five sublists, one per test, each containing four elements: the single-patch deviation from linearity (in $\\mathrm{eV}$), the approximate model energy advantage of equal split over localization (in $\\mathrm{eV}$), the boolean preference for delocalization, and the exact model equal-split versus localized energy difference (in $\\mathrm{eV}$). No rounding is applied.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef E_exact_add(alpha: float, A: float) -> float:\n    \"\"\"\n    Exact piecewise-linear energy change for adding alpha electrons to a single patch.\n    E(N) between integers is linear; for addition the slope is -A (electron affinity).\n    \"\"\"\n    return -A * alpha\n\ndef E_approx_add(alpha: float, A: float, c: float) -> float:\n    \"\"\"\n    Approximate convex energy model for adding alpha electrons to a single patch.\n    Linear baseline (-A*alpha) plus a convex deviation captured by -c * alpha * (1 - alpha).\n    \"\"\"\n    return -A * alpha - c * alpha * (1.0 - alpha)\n\ndef E_exact_remove(phi: float, I: float) -> float:\n    \"\"\"\n    Exact piecewise-linear energy change for removing phi electrons from a single patch.\n    For removal, the slope is +I (ionization potential).\n    \"\"\"\n    return +I * phi\n\ndef E_approx_remove(phi: float, I: float, c: float) -> float:\n    \"\"\"\n    Approximate convex energy model for removing phi electrons from a single patch.\n    Linear baseline (+I*phi) plus a convex deviation captured by -c * phi * (1 - phi).\n    \"\"\"\n    return +I * phi - c * phi * (1.0 - phi)\n\ndef linear_interpolation_add(alpha: float, A: float, c: float) -> float:\n    \"\"\"\n    Linear interpolation between integer endpoints for the approximate model baseline\n    (used only to compute deviation; note endpoints are consistent with exact theory).\n    At alpha=0: E=0; at alpha=1: E=-A (convex term vanishes at endpoints).\n    \"\"\"\n    E0 = 0.0\n    E1 = -A\n    return (1.0 - alpha) * E0 + alpha * E1\n\ndef linear_interpolation_remove(phi: float, I: float, c: float) -> float:\n    \"\"\"\n    Linear interpolation between integer endpoints for removal.\n    At phi=0: E=0; at phi=1: E=+I (convex term vanishes at endpoints).\n    \"\"\"\n    E0 = 0.0\n    E1 = +I\n    return (1.0 - phi) * E0 + phi * E1\n\ndef total_energy_add_distribution(delta: float, A_list, c: float, m: int, equal_split: bool) -> float:\n    \"\"\"\n    Total energy for addition across m patches, with either localization on the best patch\n    or equal split across all patches. A_list may be a scalar (identical) or a list per patch.\n    \"\"\"\n    # Normalize A_list to per-patch list\n    if isinstance(A_list, (int, float)):\n        A_vals = [float(A_list)] * m\n    else:\n        A_vals = list(A_list)\n        if len(A_vals) < m:\n            # If fewer provided, repeat last; if more, truncate.\n            if len(A_vals) < m:\n                A_vals = A_vals + [A_vals[-1]] * (m - len(A_vals))\n            else:\n                A_vals = A_vals[:m]\n\n    if equal_split:\n        frac = delta / m\n        return sum(E_approx_add(frac, A_vals[i], c) for i in range(m))\n    else:\n        # Localize on the patch with the largest A (most favorable for addition).\n        best_idx = int(np.argmax(A_vals))\n        energy = 0.0\n        for i in range(m):\n            if i == best_idx:\n                energy += E_approx_add(delta, A_vals[i], c)\n            else:\n                energy += 0.0  # no change on other patches\n        return energy\n\ndef total_energy_add_distribution_exact(delta: float, A_list, m: int, equal_split: bool) -> float:\n    \"\"\"\n    Exact total energy for addition across m patches for distribution comparison.\n    \"\"\"\n    if isinstance(A_list, (int, float)):\n        A_vals = [float(A_list)] * m\n    else:\n        A_vals = list(A_list)\n        if len(A_vals) < m:\n            if len(A_vals) < m:\n                A_vals = A_vals + [A_vals[-1]] * (m - len(A_vals))\n            else:\n                A_vals = A_vals[:m]\n\n    if equal_split:\n        frac = delta / m\n        return sum(E_exact_add(frac, A_vals[i]) for i in range(m))\n    else:\n        best_idx = int(np.argmax(A_vals))\n        energy = 0.0\n        for i in range(m):\n            if i == best_idx:\n                energy += E_exact_add(delta, A_vals[i])\n            else:\n                energy += 0.0\n        return energy\n\ndef total_energy_remove_distribution(phi: float, I_list, c: float, m: int, equal_split: bool) -> float:\n    \"\"\"\n    Total energy for removal across m patches, approximate model.\n    I_list may be scalar or list per patch.\n    \"\"\"\n    if isinstance(I_list, (int, float)):\n        I_vals = [float(I_list)] * m\n    else:\n        I_vals = list(I_list)\n        if len(I_vals) < m:\n            if len(I_vals) < m:\n                I_vals = I_vals + [I_vals[-1]] * (m - len(I_vals))\n            else:\n                I_vals = I_vals[:m]\n\n    if equal_split:\n        frac = phi / m\n        return sum(E_approx_remove(frac, I_vals[i], c) for i in range(m))\n    else:\n        # For removal, localize on the patch with the smallest I (least energy increase).\n        best_idx = int(np.argmin(I_vals))\n        energy = 0.0\n        for i in range(m):\n            if i == best_idx:\n                energy += E_approx_remove(phi, I_vals[i], c)\n            else:\n                energy += 0.0\n        return energy\n\ndef total_energy_remove_distribution_exact(phi: float, I_list, m: int, equal_split: bool) -> float:\n    \"\"\"\n    Exact total energy for removal across m patches for distribution comparison.\n    \"\"\"\n    if isinstance(I_list, (int, float)):\n        I_vals = [float(I_list)] * m\n    else:\n        I_vals = list(I_list)\n        if len(I_vals) < m:\n            if len(I_vals) < m:\n                I_vals = I_vals + [I_vals[-1]] * (m - len(I_vals))\n            else:\n                I_vals = I_vals[:m]\n\n    if equal_split:\n        frac = phi / m\n        return sum(E_exact_remove(frac, I_vals[i]) for i in range(m))\n    else:\n        best_idx = int(np.argmin(I_vals))\n        energy = 0.0\n        for i in range(m):\n            if i == best_idx:\n                energy += E_exact_remove(phi, I_vals[i])\n            else:\n                energy += 0.0\n        return energy\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: happy path addition on identical patches\n        {\"kind\": \"add_identical\", \"A\": 3.0, \"c\": 0.6, \"delta\": 0.4, \"m\": 2},\n        # Test 2: boundary integer addition on identical patches\n        {\"kind\": \"add_identical\", \"A\": 3.0, \"c\": 0.6, \"delta\": 1.0, \"m\": 2},\n        # Test 3: removal on identical patches\n        {\"kind\": \"remove_identical\", \"I\": 5.0, \"c\": 0.3, \"phi\": 0.25, \"m\": 2},\n        # Test 4: addition on heterogeneous patches\n        {\"kind\": \"add_hetero\", \"A_list\": [2.5, 3.0], \"c\": 0.5, \"delta\": 0.6, \"m\": 2},\n        # Test 5: addition on many identical patches\n        {\"kind\": \"add_identical\", \"A\": 3.5, \"c\": 0.4, \"delta\": 0.8, \"m\": 10},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        kind = case[\"kind\"]\n        if kind == \"add_identical\":\n            A = float(case[\"A\"])\n            c = float(case[\"c\"])\n            delta = float(case[\"delta\"])\n            m = int(case[\"m\"])\n\n            # 1) Single-patch deviation from piecewise linearity at alpha = delta (use approximate model vs linear interpolation)\n            approx = E_approx_add(delta, A, c)\n            lin = linear_interpolation_add(delta, A, c)\n            deviation = approx - lin  # in eV\n\n            # 2) Approximate model energy advantage of equal split over localization\n            E_deloc_approx = total_energy_add_distribution(delta, A, c, m, equal_split=True)\n            E_local_approx = total_energy_add_distribution(delta, A, c, m, equal_split=False)\n            advantage = E_deloc_approx - E_local_approx  # negative favors delocalization\n\n            # 3) Boolean preference for delocalization\n            prefer_deloc = E_deloc_approx < E_local_approx\n\n            # 4) Exact model equal-split vs localized energy difference\n            E_deloc_exact = total_energy_add_distribution_exact(delta, A, m, equal_split=True)\n            E_local_exact = total_energy_add_distribution_exact(delta, A, m, equal_split=False)\n            exact_diff = E_deloc_exact - E_local_exact  # should be 0 for identical patches\n\n            results.append([deviation, advantage, prefer_deloc, exact_diff])\n\n        elif kind == \"remove_identical\":\n            I = float(case[\"I\"])\n            c = float(case[\"c\"])\n            phi = float(case[\"phi\"])\n            m = int(case[\"m\"])\n\n            # 1) Single-patch deviation from piecewise linearity at phi (approximate vs linear interpolation)\n            approx = E_approx_remove(phi, I, c)\n            lin = linear_interpolation_remove(phi, I, c)\n            deviation = approx - lin  # in eV\n\n            # 2) Approximate model energy advantage of equal split over localization\n            E_deloc_approx = total_energy_remove_distribution(phi, I, c, m, equal_split=True)\n            E_local_approx = total_energy_remove_distribution(phi, I, c, m, equal_split=False)\n            advantage = E_deloc_approx - E_local_approx  # negative favors delocalization\n\n            # 3) Boolean preference for delocalization\n            prefer_deloc = E_deloc_approx < E_local_approx\n\n            # 4) Exact model equal-split vs localized energy difference\n            E_deloc_exact = total_energy_remove_distribution_exact(phi, I, m, equal_split=True)\n            E_local_exact = total_energy_remove_distribution_exact(phi, I, m, equal_split=False)\n            exact_diff = E_deloc_exact - E_local_exact  # should be 0 for identical patches\n\n            results.append([deviation, advantage, prefer_deloc, exact_diff])\n\n        elif kind == \"add_hetero\":\n            A_list = case[\"A_list\"]\n            c = float(case[\"c\"])\n            delta = float(case[\"delta\"])\n            m = int(case[\"m\"])\n\n            # For hetero, define single-patch deviation using the more favorable patch's A (max A)\n            A_best = float(np.max(A_list))\n            approx = E_approx_add(delta, A_best, c)\n            lin = linear_interpolation_add(delta, A_best, c)\n            deviation = approx - lin  # in eV\n\n            # Approximate model energy advantage of equal split over localization on best patch\n            E_deloc_approx = total_energy_add_distribution(delta, A_list, c, m, equal_split=True)\n            E_local_approx = total_energy_add_distribution(delta, A_list, c, m, equal_split=False)\n            advantage = E_deloc_approx - E_local_approx\n            prefer_deloc = E_deloc_approx < E_local_approx\n\n            # Exact model equal-split vs localized on best patch; for hetero, exact prefers localization\n            E_deloc_exact = total_energy_add_distribution_exact(delta, A_list, m, equal_split=True)\n            E_local_exact = total_energy_add_distribution_exact(delta, A_list, m, equal_split=False)\n            exact_diff = E_deloc_exact - E_local_exact  # expected positive\n\n            results.append([deviation, advantage, prefer_deloc, exact_diff])\n\n        else:\n            # Unknown case kind; skip\n            results.append([np.nan, np.nan, False, np.nan])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}