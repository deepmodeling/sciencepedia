{
    "hands_on_practices": [
        {
            "introduction": "基于平面波的密度泛函理论（DFT）计算的准确性在根本上取决于两个关键的数值参数：动能截断能 $E_{\\mathrm{cut}}$（决定了基组的完备性）和 $k$ 点网格（决定了布里渊区积分的精度）。任何严谨的计算研究都必须通过系统性的收敛性测试来确保计算结果的可靠性。本练习  将指导你通过一个基于物理模型的能量外推法，来评估和确保吸附能等关键物理量的计算收敛性，这是进行可靠计算电化学模拟的一项基本技能。",
            "id": "4241387",
            "problem": "您的任务是构建一个程序，用于在计算电化学的背景下，评估平面波密度泛函理论 (DFT) 计算中吸附能相对于平面波动能截止和 $k$ 点采样的收敛性。从密度泛函理论 (DFT) 的基础 Kohn-Sham 表述开始，该表述指出，对于一个相互作用的电子系统，其基态能量可以通过一个在有效势作用下、由 Kohn-Sham 方程所描述的无相互作用参考系统来获得。在一个使用模守恒或投影缀加波赝势的标准平面波实现中，总能量取决于在动能截止 $E_{\\mathrm{cut}}$ 处的平面波基组截断，以及由基数为 $N_k$ 的离散 $k$ 点集所近似的布里渊区积分。吸附能定义为 $E_{\\mathrm{ads}} = E_{\\mathrm{tot}}(\\mathrm{slab}+\\mathrm{adsorbate}) - E_{\\mathrm{tot}}(\\mathrm{slab}) - E_{\\mathrm{tot}}(\\mathrm{adsorbate})$，单位为 $\\mathrm{eV}$。\n\n从第一性原理出发，使用截断平面波基组的 Kohn-Sham 方法的变分性质意味着，随着基组完备性的增加，误差会减小；随着 $k$ 点密度的增加，布里渊区积分误差会减小。在平面波赝势计算中，所包含的最高倒格矢受 $G_{\\max}$ 限制，而 $G_{\\max}$ 与 $E_{\\mathrm{cut}}$ 相关；对布里渊区的求积会引入一个依赖于 $N_k$ 的采样误差。这两种误差源可以根据被积函数的平滑度和高 $G$ 傅里叶分量的衰减情况，通过对 $E_{\\mathrm{cut}}$ 和 $N_k$ 的可分离依赖关系进行渐近建模。基于这些物理基础，构建一个线性最小二乘估计器，该估计器能从在有限 $E_{\\mathrm{cut}}$ 和 $N_k$ 下的测量值中，产生一个无限截止和无限 $k$ 点的吸附能 $E_{\\infty}$。然后，通过计算该估计器在该点对上与 $E_{\\infty}$ 的偏差，来估计在现有最佳 $(E_{\\mathrm{cut,max}}, N_{k,\\mathrm{max}})$ 下的残余误差，并确定该误差是否满足指定的电化学精度容差。\n\n您的程序必须：\n- 对于每个测试用例，拟合一个关于特征 $x_1 = E_{\\mathrm{cut}}^{-p}$ 和 $x_2 = N_k^{-q}$ 外加一个常数偏移的线性模型，其中 $p$ 和 $q$ 是给定的。使用线性最小二乘法估计参数，并将 $E_{\\infty}$ 提取为常数项。\n- 计算估计的绝对偏差 $\\Delta = \\left|E_{\\mathrm{ads}}^{\\mathrm{est}}(E_{\\mathrm{cut,max}}, N_{k,\\mathrm{max}}) - E_{\\infty}\\right|$，单位为 $\\mathrm{eV}$，其中 $(E_{\\mathrm{cut,max}}, N_{k,\\mathrm{max}})$ 是测试用例数据中存在的 $E_{\\mathrm{cut}}$ 和 $N_k$ 的最大值。\n- 将 $\\Delta$ 与为每个用例指定的容差 $\\tau$（单位为 $\\mathrm{eV}$）进行比较。如果 $\\Delta \\le \\tau$，则该用例输出布尔值 $True$；否则输出 $False$。\n\n物理单位：\n- 所有能量单位均为 $\\mathrm{eV}$。\n- $E_{\\mathrm{cut}}$ 的单位为 $\\mathrm{eV}$。\n- $N_k$ 是无单位的（采样网格的基数）。\n- 所有输出均为布尔值，无单位。\n\n测试套件：\n提供以下测量的吸附能和参数。每个测试用例是一个三元组 $(E_{\\mathrm{cut}}, N_k, E_{\\mathrm{ads}})$ 的列表，以及指数 $(p,q)$ 和容差 $\\tau$（单位为 $\\mathrm{eV}$）。\n\n- 用例 1（绝缘氧化物表面；相对于 $E_{\\mathrm{cut}}$ 和 $k$ 点收敛良好）：\n  数据点（单位 $\\mathrm{eV}$）：\n  $(300, 4, -0.4974774955135062)$,\n  $(400, 4, -0.50155)$,\n  $(400, 9, -0.5110808641975309)$,\n  $(500, 9, -0.513158728243)$,\n  $(600, 16, -0.5158166809128011)$。\n  指数：$p = 1.5$, $q = 2$。\n  容差：$\\tau = 0.03$ $\\mathrm{eV}$。\n\n- 用例 2（金属性表面；$k$ 点收敛慢）：\n  数据点（单位 $\\mathrm{eV}$）：\n  $(400, 2, -0.08795)$,\n  $(500, 3, -0.1728500517603336)$,\n  $(700, 4, -0.215280751)$,\n  $(700, 6, -0.257047418)$。\n  指数：$p = 1.5$, $q = 1$。\n  容差：$\\tau = 0.03$ $\\mathrm{eV}$。\n\n- 用例 3（分子吸附物；数据点少但已充分收敛）：\n  数据点（单位 $\\mathrm{eV}$）：\n  $(300, 6, -0.1071666667)$,\n  $(400, 8, -0.11069375)$,\n  $(500, 12, -0.112893889)$。\n  指数：$p = 2$, $q = 2$。\n  容差：$\\tau = 0.03$ $\\mathrm{eV}$。\n\n- 用例 4（具有挑战性的金属性收敛；$k$ 网格采样不足）：\n  数据点（单位 $\\mathrm{eV}$）：\n  $(300, 2, -0.1418019964108)$,\n  $(350, 3, -0.3108561)$,\n  $(400, 3, -0.3114667)$,\n  $(450, 4, -0.39581038)$。\n  指数：$p = 1.5$, $q = 1$。\n  容差：$\\tau = 0.03$ $\\mathrm{eV}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，例如 $[result_1, result_2, result_3, result_4]$，其中每个 $result_i$ 是上述顺序中用例 $i$ 的布尔值。",
            "solution": "该问题要求评估使用平面波密度泛函理论 (DFT) 计算的吸附能 $E_{\\mathrm{ads}}$ 相对于动能截止 $E_{\\mathrm{cut}}$ 和 $k$ 点数量 $N_k$ 的收敛性。此评估基于一个有物理动机的外推模型和一个指定的数值容差 $\\tau$。\n\n其基本原理是 DFT 的 Kohn-Sham 表述，其中相互作用电子系统的基态性质是通过一个无相互作用的辅助系统来确定的。在实际的平面波基组实现中，Kohn-Sham 轨道在一个平面波基组中展开，并在最大动能 $E_{\\mathrm{cut}} = \\frac{\\hbar^2}{2m_e} G_{\\max}^2$ 处截断。这种截断引入了基组不完备性误差。此外，对于周期性系统必需的、对第一布里渊区的积分，通过在一个 $k$ 点网格上进行离散求和来近似，这引入了采样误差。\n\n根据变分原理，计算出的基态能量是真实基态能量的一个上界，并且随着 $E_{\\mathrm{cut}}$ 的增加，它会单调递减地趋近于精确的基组极限。总能量的误差通常表现出相对于 $E_{\\mathrm{cut}}$ 的渐近幂律衰减，通常建模为 $A \\cdot E_{\\mathrm{cut}}^{-p}$。类似地，来自布里渊区积分的误差随着 $k$ 点网格密度（此处用其基数 $N_k$ 表示）的增加而减小。这个误差也可以用幂律 $B \\cdot N_k^{-q}$ 来建模。指数 $p$ 和 $q$ 取决于系统的性质，例如赝势的平滑度以及系统是金属性还是绝缘性。\n\n对于吸附能 $E_{\\mathrm{ads}} = E_{\\mathrm{tot}}(\\mathrm{slab}+\\mathrm{adsorbate}) - E_{\\mathrm{tot}}(\\mathrm{slab}) - E_{\\mathrm{tot}}(\\mathrm{adsorbate})$，我们假设各组分能量中的误差相结合，使得 $E_{\\mathrm{ads}}$ 本身也遵循类似的渐近行为。通过假设误差的可分离性，我们可以为在有限 $E_{\\mathrm{cut}}$ 和 $N_k$ 下计算的吸附能建立一个模型：\n$$\nE_{\\mathrm{ads}}(E_{\\mathrm{cut}}, N_k) \\approx E_{\\infty} + c_1 E_{\\mathrm{cut}}^{-p} + c_2 N_k^{-q}\n$$\n这里，$E_{\\infty}$ 代表所期望的、完全收敛的吸附能，它是外推到无限基组（$E_{\\mathrm{cut}} \\to \\infty$）和无限密集 $k$ 点网格（$N_k \\to \\infty$）的结果。项 $c_1 E_{\\mathrm{cut}}^{-p}$ 和 $c_2 N_k^{-q}$ 分别代表由基组和 $k$ 点采样限制引起的领头阶残余误差。\n\n该模型在参数 $\\beta_0 = E_{\\infty}$、$\\beta_1 = c_1$ 和 $\\beta_2 = c_2$ 上是线性的。给定一组 $m$ 个计算数据点 $(E_{\\mathrm{cut},i}, N_{k,i}, E_{\\mathrm{ads},i})$，我们可以通过线性最小二乘法确定这些参数。我们定义特征 $x_{1,i} = E_{\\mathrm{cut},i}^{-p}$ 和 $x_{2,i} = N_{k,i}^{-q}$，以及响应变量 $y_i = E_{\\mathrm{ads},i}$。该模型变成一个标准的多重线性回归问题：\n$$\ny_i = \\beta_0 \\cdot 1 + \\beta_1 x_{1,i} + \\beta_2 x_{2,i} + \\epsilon_i\n$$\n这可以表示为矩阵形式 $\\mathbf{y} = \\mathbf{A}\\beta + \\epsilon$，其中 $\\mathbf{y}$ 是观测能量的向量，$\\beta = [\\beta_0, \\beta_1, \\beta_2]^T$ 是待估计参数的向量，$\\mathbf{A}$ 是 $m \\times 3$ 的设计矩阵，其行为 $[1, x_{1,i}, x_{2,i}]$。$\\beta$ 的最小二乘估计（表示为 $\\hat{\\beta}$）使残差平方和最小化，可通过求解正规方程 $(\\mathbf{A}^T\\mathbf{A})\\hat{\\beta} = \\mathbf{A}^T\\mathbf{y}$ 来找到。这可以使用数值线性代数库高效求解。\n\n一旦参数 $\\hat{\\beta} = [\\hat{\\beta}_0, \\hat{\\beta}_1, \\hat{\\beta}_2]^T$ 被确定，外推能量即为 $\\hat{E}_{\\infty} = \\hat{\\beta}_0$。问题接着要求估计在所提供数据集中可用的最高理论水平（由 $(E_{\\mathrm{cut,max}}, N_{k,\\mathrm{max}})$ 标识）下的残余误差。模型在这些参数下的估计吸附能为：\n$$\nE_{\\mathrm{ads}}^{\\mathrm{est}}(E_{\\mathrm{cut,max}}, N_{k,\\mathrm{max}}) = \\hat{\\beta}_0 + \\hat{\\beta}_1 E_{\\mathrm{cut,max}}^{-p} + \\hat{\\beta}_2 N_{k,\\mathrm{max}}^{-q}\n$$\n与外推极限的绝对偏差是衡量剩余收敛误差的指标：\n$$\n\\Delta = \\left|E_{\\mathrm{ads}}^{\\mathrm{est}}(E_{\\mathrm{cut,max}}, N_{k,\\mathrm{max}}) - \\hat{E}_{\\infty}\\right| = \\left|\\hat{\\beta}_1 E_{\\mathrm{cut,max}}^{-p} + \\hat{\\beta}_2 N_{k,\\mathrm{max}}^{-q}\\right|\n$$\n最后，将此偏差 $\\Delta$ 与给定的电化学精度容差 $\\tau$ 进行比较。如果 $\\Delta \\le \\tau$，则认为计算已充分收敛；否则，未收敛。该过程包括：对于每个测试用例，根据给定的数据和指数构建设计矩阵 $\\mathbf{A}$ 和响应向量 $\\mathbf{y}$，求解系数向量 $\\hat{\\beta}$，使用数据中的最大 $E_{\\mathrm{cut}}$ 和 $N_k$ 值计算 $\\Delta$，并将 $\\Delta$ 与 $\\tau$ 进行比较。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DFT convergence problem for a suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"id\": 1,\n            \"data\": [\n                (300, 4, -0.4974774955135062),\n                (400, 4, -0.50155),\n                (400, 9, -0.5110808641975309),\n                (500, 9, -0.513158728243),\n                (600, 16, -0.5158166809128011),\n            ],\n            \"p\": 1.5,\n            \"q\": 2.0,\n            \"tau\": 0.03,\n        },\n        {\n            \"id\": 2,\n            \"data\": [\n                (400, 2, -0.08795),\n                (500, 3, -0.1728500517603336),\n                (700, 4, -0.215280751),\n                (700, 6, -0.257047418),\n            ],\n            \"p\": 1.5,\n            \"q\": 1.0,\n            \"tau\": 0.03,\n        },\n        {\n            \"id\": 3,\n            \"data\": [\n                (300, 6, -0.1071666667),\n                (400, 8, -0.11069375),\n                (500, 12, -0.112893889),\n            ],\n            \"p\": 2.0,\n            \"q\": 2.0,\n            \"tau\": 0.03,\n        },\n        {\n            \"id\": 4,\n            \"data\": [\n                (300, 2, -0.1418019964108),\n                (350, 3, -0.3108561),\n                (400, 3, -0.3114667),\n                (450, 4, -0.39581038),\n            ],\n            \"p\": 1.5,\n            \"q\": 1.0,\n            \"tau\": 0.03,\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        data = case[\"data\"]\n        p = case[\"p\"]\n        q = case[\"q\"]\n        tau = case[\"tau\"]\n\n        # Unpack data into separate lists/arrays\n        E_cuts = np.array([d[0] for d in data])\n        N_ks = np.array([d[1] for d in data])\n        E_ads_vals = np.array([d[2] for d in data])\n\n        # Construct the design matrix A for the linear model\n        # E_ads = beta_0 + beta_1 * E_cut**(-p) + beta_2 * N_k**(-q)\n        num_points = len(data)\n        A = np.zeros((num_points, 3))\n        A[:, 0] = 1.0  # Constant term for beta_0 (E_infinity)\n        A[:, 1] = E_cuts ** (-p)  # Feature for beta_1\n        A[:, 2] = N_ks ** (-q)    # Feature for beta_2\n        \n        # Define the response vector y\n        y = E_ads_vals\n\n        # Solve the linear least squares problem A*beta = y for beta\n        # np.linalg.lstsq returns (solution, residuals, rank, singular values)\n        # We need the solution vector, which are the coefficients [beta_0, beta_1, beta_2]\n        coeffs = np.linalg.lstsq(A, y, rcond=None)[0]\n        \n        # The coefficients are:\n        # beta_0 = E_infinity (extrapolated energy)\n        # beta_1 = c1 (coefficient for E_cut term)\n        # beta_2 = c2 (coefficient for N_k term)\n        beta_1 = coeffs[1]\n        beta_2 = coeffs[2]\n\n        # Find the maximum E_cut and N_k from the dataset\n        E_cut_max = np.max(E_cuts)\n        N_k_max = np.max(N_ks)\n\n        # Calculate the estimated absolute deviation Delta\n        # Delta = |E_ads_est(E_cut_max, N_k_max) - E_infinity|\n        # Delta = |(beta_0 + beta_1*x1_max + beta_2*x2_max) - beta_0|\n        # Delta = |beta_1*E_cut_max**(-p) + beta_2*N_k_max**(-q)|\n        delta = abs(beta_1 * (E_cut_max ** (-p)) + beta_2 * (N_k_max ** (-q)))\n\n        # Compare Delta to the tolerance tau\n        is_converged = delta = tau\n        results.append(is_converged)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Kohn-Sham (KS) 本征值 $\\epsilon_i$ 是 DFT 计算的核心产物，但它们的物理意义常常被误解。Janak 定理揭示了其深刻含义：KS 本征值等于总能量对相应轨道占据数 $f_i$ 的偏导数，即 $\\frac{\\partial E_{\\mathrm{tot}}}{\\partial f_i} = \\epsilon_i$。本练习  让你通过构建一个简化的自洽场（SCF）模型，亲手数值验证这一基本定理，从而深化对分数电荷转移过程中总能量与 KS 谱之间关系的理解。",
            "id": "4241335",
            "problem": "考虑一个密度泛函理论 (DFT) 的最小 Kohn–Sham 方程形式，用于模拟一个吸附在金属表面的分子的简单双轨道系统。该系统在一个由两个局域轨道组成的最小标准正交基组中表示：一个轨道以吸附物位点为中心，另一个以金属位点为中心。为简化起见，电子被视为无自旋，占据的 Kohn–Sham 轨道数量为二，能量最低的轨道被占据数 $f_1 = 1$ 填满，能量较高的轨道带有分数占据数 $f_2 \\in [0,1]$。总能量泛函和有效 Kohn–Sham 哈密顿量应使用以下要素从第一性原理构建。\n\n基本原理：\n- 密度泛函理论 (DFT) 中的 Kohn–Sham 能量泛函由非相互作用动能、离子（赝势）外势能、经典 Hartree 能量和交换关联能的总和给出。\n- 离散格点上的 Hartree 能量被建模为局域二次型。交换关联能则在局域密度近似 (LDA) 框架内，使用简化的纯交换形式进行建模。\n\n定义与建模假设：\n- 有效 Kohn–Sham 哈密顿量 $H_{\\mathrm{KS}}$ 是一个在标准正交基组中的 $2 \\times 2$ 实对称矩阵，由在位项和耦合项组成。设吸附物和金属位点的在位离子赝势能分别为 $v_{\\mathrm{ion},A}$ 和 $v_{\\mathrm{ion},M}$。设吸附物-金属耦合为 $t$。\n- 位点密度 $n_A$ 和 $n_M$ 通过占据的 Kohn–Sham 轨道自洽计算：$n_s = \\sum_{k=1}^{2} f_k |\\langle s | \\psi_k \\rangle|^2$，其中 $s \\in \\{A,M\\}$，$|\\psi_k\\rangle$ 是 $H_{\\mathrm{KS}}$ 的归一化本征矢量，$f_k$ 是对应的占据数。\n- Hartree 能量为 $E_H[n] = \\frac{1}{2} U \\left(n_A^2 + n_M^2\\right)$，其中 $U  0$ 是一个局域库仑相互作用参数。相应的 Hartree 势为 $v_{H,s}(n_s) = \\frac{\\partial E_H}{\\partial n_s} = U n_s$，其中 $s \\in \\{A,M\\}$。\n- 交换能通过局域密度近似 (LDA) 的纯交换项 $E_x[n] = -\\alpha \\left(n_A^{4/3} + n_M^{4/3}\\right)$ 进行建模，其中 $\\alpha  0$。交换势为 $v_{x,s}(n_s) = \\frac{\\partial E_x}{\\partial n_s} = -\\frac{4}{3} \\alpha n_s^{1/3}$。\n- 有效 Kohn–Sham 哈密顿量为\n$$\nH_{\\mathrm{KS}}(n_A,n_M) =\n\\begin{pmatrix}\nv_{\\mathrm{ion},A} + U n_A + v_{x,A}(n_A)  t \\\\\nt  v_{\\mathrm{ion},M} + U n_M + v_{x,M}(n_M)\n\\end{pmatrix}.\n$$\n- 总能量根据 Kohn–Sham 本征值 $\\{\\epsilon_k\\}$ 和位点密度 $\\{n_A,n_M\\}$，使用标准的双重计数校正进行计算：\n$$\nE_{\\mathrm{tot}}[n] = \\sum_{k=1}^{2} f_k \\epsilon_k - E_H[n] - \\sum_{s \\in \\{A,M\\}} n_s v_{x,s}(n_s) + E_x[n].\n$$\n- 自洽性：对于每个给定的分数占据数 $f_2$，必须通过迭代从密度到哈密顿量、再到本征矢量和占据数、最后回到密度的映射，来自洽地确定位点密度 $\\{n_A,n_M\\}$，直到在数值容差内达到一个不动点。\n\n目标：\n- 通过计算数值导数 $\\frac{dE_{\\mathrm{tot}}}{df_2}$ 并将其与 $\\epsilon_2$ 在一系列分数占据数上进行比较，数值验证总能量 $E_{\\mathrm{tot}}$ 对分数占据数 $f_2$ 的敏感度与分数占据态对应的 Kohn–Sham 本征值 $\\epsilon_2$ 之间的关系。该比较应通过在预设的 $f_2$ 值网格上计算 $\\frac{dE_{\\mathrm{tot}}}{df_2}$ 和 $\\epsilon_2$ 之间的最大绝对偏差来量化。\n\n计算电化学背景：\n- 该吸附物-金属模型模拟了在电化学环境中吸附到金属表面上的分子。赝势项 $v_{\\mathrm{ion},A}$ 和 $v_{\\mathrm{ion},M}$ 代表了适用于最小基组处理的有效离子势。局域密度近似 (LDA) 交换项模拟了在金属和吸附物的实用密度泛函理论 (DFT) 计算中常用的交换贡献，而 Hartree 项则模拟了吸附时电荷重新分布引起的经典静电相互作用。\n\n需实现的任务：\n- 对每个指定的 $f_2$ 和参数集，构建并求解双轨道系统的自洽 Kohn–Sham 方程。\n- 使用指定的表达式计算总能量 $E_{\\mathrm{tot}}(f_2)$。\n- 使用小增量 $\\delta f$ 通过有限差分计算数值导数 $\\frac{dE_{\\mathrm{tot}}}{df_2}$；在可能的情况下使用中心差分，并在边界 $f_2=0$ 和 $f_2=1$ 处使用单边差分。\n- 对于每个 $f_2$ 值，计算绝对偏差 $|\\frac{dE_{\\mathrm{tot}}}{df_2}-\\epsilon_2|$，并报告每个参数集在网格上的最大偏差。\n- 所有能量必须以电子伏特（缩写为 eV）表示。最终偏差必须以 eV 报告。\n\n测试套件：\n- 使用分数占据数网格 $f_2 \\in \\{0.0, 0.25, 0.5, 0.75, 1.0\\}$ 和有限差分增量 $\\delta f = 10^{-3}$。\n- 提供以下参数集，每个参数集均为 eV 单位的元组 $(v_{\\mathrm{ion},A}, v_{\\mathrm{ion},M}, t, U, \\alpha)$：\n    1. $( -5.0, 0.0, 0.8, 1.0, 0.5 )$ 代表一个典型的、能量低于金属能级的吸附物，具有中等耦合和中等相互作用。\n    2. $( -2.0, 0.0, 0.1, 1.0, 0.5 )$ 代表弱吸附物-金属耦合。\n    3. $( -1.0, 0.5, 1.2, 0.0, 0.0 )$ 代表非相互作用极限，用于测试基线行为。\n    4. $( -3.0, 0.0, 1.5, 4.0, 1.0 )$ 代表强静电和交换相互作用。\n- 自洽循环的收敛容差应设为绝对密度的 $10^{-10}$，可采用简单的线性混合方案，混合参数在 $(0,1)$ 之间，最大迭代次数至少为 $1000$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含四个参数集的最大偏差，格式为逗号分隔的列表并用方括号括起来（例如，“[result1,result2,result3,result4]”）。每个结果必须是 eV 单位的浮点数。\n\n不应读取任何外部输入；所有常量和参数必须在程序内部定义。代码必须是自包含的，并能在任何符合给定库约束的标准 Python 环境中运行。",
            "solution": "问题陈述已经过严格审查，并被确定为有效。它在科学上基于密度泛函理论 (DFT) 的原理，问题设定良好，目标明确且可实现，并且是自包含的，所有必要的定义、参数和计算过程都已指定。该问题是在电子结构理论中一个标准的、尽管是简化的计算练习，旨在检验一个被称为 Janak 定理的基本 DFT 结果的数值有效性。\n\n任务是为一个在 Kohn-Sham (KS) DFT 框架内描述的模型双轨道系统，数值验证关系 $\\frac{dE_{\\mathrm{tot}}}{df_2} = \\epsilon_2$。这里，$E_{\\mathrm{tot}}$ 是总能量，$f_2$ 是第二个 KS 轨道的带分数占据数，$\\epsilon_2$ 是相应的 KS 本征值。这个关系是 Janak 定理的一种形式，该定理指出总能量对某个轨道占据数的导数等于该轨道的能量。此验证需要实现一个自洽场 (SCF) 过程来求解不同 $f_2$ 值下的 KS 方程。\n\n问题的核心在于自洽地确定吸附物和金属位点的位点密度 $\\{n_A, n_M\\}$。该过程从对密度的初始猜测开始，这些密度用于构建 KS 哈密顿量 $H_{\\mathrm{KS}}$。哈密顿量通过 Hartree 势 $v_{H,s}(n_s) = U n_s$ 和交换势 $v_{x,s}(n_s) = -\\frac{4}{3} \\alpha n_s^{1/3}$ 依赖于密度。$2 \\times 2$ 的 KS 哈密顿矩阵由下式给出：\n$$\nH_{\\mathrm{KS}}(n_A,n_M) =\n\\begin{pmatrix}\nv_{\\mathrm{ion},A} + U n_A - \\frac{4}{3} \\alpha n_A^{1/3}  t \\\\\nt  v_{\\mathrm{ion},M} + U n_M - \\frac{4}{3} \\alpha n_M^{1/3}\n\\end{pmatrix}\n$$\n对角化该哈密顿量可得到两个本征值 $\\epsilon_1 \\le \\epsilon_2$ 及其对应的归一化本征矢量 $|\\psi_1\\rangle$ 和 $|\\psi_2\\rangle$。这些本征矢量用于根据以下公式计算新的位点密度：\n$$\nn_s = \\sum_{k=1}^{2} f_k |\\langle s | \\psi_k \\rangle|^2 = (1.0) \\cdot |\\langle s | \\psi_1 \\rangle|^2 + f_2 \\cdot |\\langle s | \\psi_2 \\rangle|^2 \\quad \\text{for } s \\in \\{A,M\\}\n$$\n其中 $f_1=1$，$f_2$ 是一个给定参数。然后将新密度与旧密度混合，并迭代该过程，直到密度收敛到一个不动点，即输入和输出密度之间的差异低于指定的容差。这个迭代过程被称为自洽场 (SCF) 循环。\n\n一旦对于给定的 $f_2$，密度和 KS 轨道收敛，就可以计算总能量 $E_{\\mathrm{tot}}$。问题提供了总能量的标准表达式，该表达式校正了本征值总和中电子-电子相互作用的双重计数：\n$$\nE_{\\mathrm{tot}}[n] = \\sum_{k=1}^{2} f_k \\epsilon_k - E_H[n] - \\sum_{s \\in \\{A,M\\}} n_s v_{x,s}(n_s) + E_x[n]\n$$\n代入给定的 Hartree 和纯交换 LDA 能量和势的形式，$E_H[n] = \\frac{1}{2} U (n_A^2 + n_M^2)$，$E_x[n] = -\\alpha (n_A^{4/3} + n_M^{4/3})$，以及 $v_{x,s}(n_s) = -\\frac{4}{3} \\alpha n_s^{1/3}$，可以简化能量表达式：\n$$\n\\begin{align*}\nE_{\\mathrm{tot}}[n] = \\sum_{k=1}^{2} f_k \\epsilon_k - \\frac{1}{2} U(n_A^2 + n_M^2) - \\left[ n_A \\left(-\\frac{4}{3}\\alpha n_A^{1/3}\\right) + n_M \\left(-\\frac{4}{3}\\alpha n_M^{1/3}\\right) \\right] + \\left[ -\\alpha(n_A^{4/3} + n_M^{4/3}) \\right] \\\\\n= \\sum_{k=1}^{2} f_k \\epsilon_k - \\frac{1}{2} U(n_A^2 + n_M^2) + \\frac{4}{3}\\alpha(n_A^{4/3} + n_M^{4/3}) - \\alpha(n_A^{4/3} + n_M^{4/3}) \\\\\n= \\sum_{k=1}^{2} f_k \\epsilon_k - \\frac{1}{2} U(n_A^2 + n_M^2) + \\frac{1}{3}\\alpha(n_A^{4/3} + n_M^{4/3})\n\\end{align*}\n$$\n这种简化形式在计算上更直接、更稳健。\n\n为了验证 Janak 定理，我们需要计算导数 $\\frac{dE_{\\mathrm{tot}}}{df_2}$。这通过有限差分法进行数值计算。对于指定网格 $\\{0.0, 0.25, 0.5, 0.75, 1.0\\}$ 中的每个点 $f_{2,i}$，导数近似为：\n- 在 $f_{2,i}=0.0$ 处的向前差分：$\\frac{E_{\\mathrm{tot}}(f_{2,i}+\\delta f) - E_{\\mathrm{tot}}(f_{2,i})}{\\delta f}$\n- 在 $f_{2,i}=1.0$ 处的向后差分：$\\frac{E_{\\mathrm{tot}}(f_{2,i}) - E_{\\mathrm{tot}}(f_{2,i}-\\delta f)}{\\delta f}$\n- 在内部点的中心差分：$\\frac{E_{\\mathrm{tot}}(f_{2,i}+\\delta f) - E_{\\mathrm{tot}}(f_{2,i}-\\delta f)}{2\\delta f}$\n其中 $\\delta f = 10^{-3}$ 是一个小增量。计算每个 $E_{\\mathrm{tot}}$ 值都需要运行一个完整的 SCF 循环。\n\n最后，对于网格中的每个 $f_{2,i}$，我们计算绝对偏差 $|\\frac{dE_{\\mathrm{tot}}}{df_2} - \\epsilon_2(f_{2,i})|$，其中 $\\epsilon_2(f_{2,i})$ 是在占据数为 $f_2 = f_{2,i}$ 的收敛 SCF 计算中得到的第二个 KS 轨道的本征值。这些偏差在整个网格中的最大值是每个参数集的最终结果。\n\n该算法针对每个提供的参数集实现，并报告最大偏差。非相互作用情况（其中 $U=0, \\alpha=0$）作为一个关键基准，在这种情况下，Janak 定理预计将精确成立，任何偏差都纯粹由数值精度和有限差分近似误差引起。其他测试用例则探究了该定理在不断增加的相互作用强度下的有效性。",
            "answer": "```python\nimport numpy as np\n\ndef solve_scf(f2, params, mixing_beta=0.5, tol=1e-10, max_iter=1000):\n    \"\"\"\n    Solves the Kohn-Sham equations self-consistently for a given\n    fractional occupation f2 and parameter set.\n\n    Args:\n        f2 (float): Fractional occupation of the second KS orbital.\n        params (tuple): (v_ion_a, v_ion_m, t, U, alpha).\n        mixing_beta (float): Linear mixing parameter for SCF iterations.\n        tol (float): Convergence tolerance for the site densities.\n        max_iter (int): Maximum number of SCF iterations.\n\n    Returns:\n        tuple: (epsilon_2, E_total) where epsilon_2 is the eigenvalue of the\n               second KS orbital and E_total is the total energy.\n    \"\"\"\n    v_ion_a, v_ion_m, t, U, alpha = params\n    f1 = 1.0\n\n    # Initial guess for densities, preserving the total number of electrons\n    total_electrons = f1 + f2\n    n_a = 0.5 * total_electrons\n    n_m = 0.5 * total_electrons\n\n    for _ in range(max_iter):\n        n_a_old, n_m_old = n_a, n_m\n\n        # Exchange potentials. Use np.cbrt for cubic root.\n        vx_a = -4/3 * alpha * np.cbrt(n_a) if n_a > 0 else 0.0\n        vx_m = -4/3 * alpha * np.cbrt(n_m) if n_m > 0 else 0.0\n\n        # Construct the Kohn-Sham Hamiltonian\n        h_ks = np.array([\n            [v_ion_a + U * n_a + vx_a, t],\n            [t, v_ion_m + U * n_m + vx_m]\n        ])\n\n        # Diagonalize H_KS to get eigenvalues and eigenvectors\n        eigenvalues, eigenvectors = np.linalg.eigh(h_ks)\n        eps1, eps2 = eigenvalues\n        psi1, psi2 = eigenvectors[:, 0], eigenvectors[:, 1]\n        \n        # Components of eigenvectors: psi_k = (c_Ak, c_Mk)^T\n        # numpy eigenvectors are columns: eigenvectors = [[c_A1, c_A2], [c_M1, c_M2]]\n        c_a1_sq = psi1[0]**2\n        c_m1_sq = psi1[1]**2\n        c_a2_sq = psi2[0]**2\n        c_m2_sq = psi2[1]**2\n\n        # Calculate new densities from occupied orbitals\n        n_a_new = f1 * c_a1_sq + f2 * c_a2_sq\n        n_m_new = f1 * c_m1_sq + f2 * c_m2_sq\n\n        # Check for convergence\n        density_diff = max(abs(n_a_new - n_a), abs(n_m_new - n_m))\n        if density_diff  tol:\n            n_a, n_m = n_a_new, n_m_new\n            break\n\n        # Linear mixing of densities for next iteration\n        n_a = (1 - mixing_beta) * n_a + mixing_beta * n_a_new\n        n_m = (1 - mixing_beta) * n_m + mixing_beta * n_m_new\n    else:\n        # This block executes if the loop finishes without converging\n        # For this problem, we assume convergence is always reached\n        pass\n\n    # Calculate total energy using the simplified expression\n    # E_tot = sum(f_k*eps_k) - 0.5*U*sum(n_s^2) + (1/3)*alpha*sum(n_s^(4/3))\n    # Using np.power for n_s^(4/3) is robust for n_s=0.\n    e_tot = (f1 * eps1 + f2 * eps2) - 0.5 * U * (n_a**2 + n_m**2) \\\n            + (1/3) * alpha * (np.power(n_a, 4/3) + np.power(n_m, 4/3))\n\n    return eps2, e_tot\n\ndef solve():\n    \"\"\"\n    Main function to run the DFT calculation for all test cases and print the result.\n    \"\"\"\n    # Parameter sets: (v_ion_A, v_ion_M, t, U, alpha) in eV\n    test_cases = [\n        (-5.0, 0.0, 0.8, 1.0, 0.5),\n        (-2.0, 0.0, 0.1, 1.0, 0.5),\n        (-1.0, 0.5, 1.2, 0.0, 0.0),\n        (-3.0, 0.0, 1.5, 4.0, 1.0)\n    ]\n\n    f2_grid = [0.0, 0.25, 0.5, 0.75, 1.0]\n    delta_f = 1e-3\n    \n    all_max_deviations = []\n\n    for params in test_cases:\n        deviations = []\n        for f2_val in f2_grid:\n            # Get the KS eigenvalue at the grid point f2_val\n            eps2_at_f2, _ = solve_scf(f2_val, params)\n\n            # Compute numerical derivative dE_tot/df2\n            if f2_val == 0.0:\n                # Forward difference at the lower boundary\n                _, e_tot_0 = solve_scf(f2_val, params)\n                _, e_tot_p = solve_scf(f2_val + delta_f, params)\n                dE_df2 = (e_tot_p - e_tot_0) / delta_f\n            elif f2_val == 1.0:\n                # Backward difference at the upper boundary\n                _, e_tot_0 = solve_scf(f2_val, params)\n                _, e_tot_m = solve_scf(f2_val - delta_f, params)\n                dE_df2 = (e_tot_0 - e_tot_m) / delta_f\n            else:\n                # Central difference for interior points\n                _, e_tot_p = solve_scf(f2_val + delta_f, params)\n                _, e_tot_m = solve_scf(f2_val - delta_f, params)\n                dE_df2 = (e_tot_p - e_tot_m) / (2 * delta_f)\n\n            # Calculate and store the deviation\n            dev = abs(dE_df2 - eps2_at_f2)\n            deviations.append(dev)\n        \n        # Find the maximum deviation for the current parameter set\n        all_max_deviations.append(max(deviations))\n\n    # Print results in the required format\n    print(f\"[{','.join(f'{dev:.12f}' for dev in all_max_deviations)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "对于精确的密度泛函理论，总能量 $E$ 作为电子数 $N$ 的函数，其图形在整数 $N$ 之间应为一系列直线段，这被称为分片线性条件。然而，许多广泛使用的近似交换关联泛函（如 LDA 和 GGA）违反了这一条件，呈现出错误的凸曲线行为，从而导致了被称为“离域误差”的严重计算赝象。本练习  将通过一个解析模型，帮助你量化地诊断这种偏离线性的行为，并理解它为何会导致分数电荷不合物理地分散在多个区域，这对于正确模拟电化学界面上的充电和电荷转移至关重要。",
            "id": "4241373",
            "problem": "考虑计算电化学中使用的密度泛函理论 (DFT) 的基本原理，特别是 Hohenberg–Kohn 变分原理、Kohn–Sham 无相互作用参考体系，以及针对非整数电子数的系综表述。作为电子数函数的精确基态能量，记为 $E(N)$，对于整数之间的 $N$ 值，其数学结构是精确的，这对于电化学环境中的电荷转移和表面充电至关重要。在精确理论中，$E(N)$ 在整数之间的值受到变分论证和系综混合的约束。在实践中，近似的交换关联泛函和带有赝势的有限基组会引起 $E(N)$ 在分数电子数下的曲率，这已知会导致离域误差——这是一种假象，分数电荷会扩散到空间上分离的区域，从而虚假地降低能量。您的任务是：从这些原理出发，使用一个在模型表面上模拟带有赝势和有限基组的 Kohn–Sham DFT 的数学自洽模型，推导出一个分段线性的定量测试和一个离域误差的诊断方法。\n\n您必须设计一个程序，为电化学环境中经历分数充电的表面片段实现两种能量模型：\n- 一个在整数之间 $E(N)$ 的精确模型，该模型源于系综变分原理，并通过 Janak 定理（总能量对轨道占据数的一阶导数等于 Kohn–Sham 本征值）和整数电子数处的导数不连续性得到证明。\n- 一个近似模型，它捕捉了与半局域交换关联和有限基组/赝势效应相关的、偏离分段线性的凸性偏差。该近似必须由一个单一的曲率参数来参数化，该参数表示整数之间偏离线性的程度。\n\n您必须形式化一个具有 $m$ 个相同、无相互作用片区的双位点无相互作用表面模型，这些片区可以接受分数电子电荷。分数电荷由电化学势控制，并通过增加电子的电子亲和能或移除电子的电离势进入能量计算。对于相同的片区，精确理论不能偏好分数电荷跨片区的离域，而近似的凸模型必须通过离域分数电荷来降低能量。对于具有不同前线轨道能量学的非均匀片区，精确理论必须偏好将电荷定域在具有更有利前线轨道能量学的片区上。\n\n您的程序必须为每个测试用例计算：\n1. 在单个片区上，于指定分数电子量下偏离分段线性的标量量化。此量必须定义为近似能量在分数电子数处与精确理论所暗示的相邻整数之间线性插值的有符号偏差。以 $\\mathrm{eV}$ 为单位输出。\n2. 在近似模型中，电荷跨片区离域的能量优势，计算方法为：将固定的总分数电子平均分配到各个片区与将其完全定域在最有利的单个片区上时的总能量变化。以 $\\mathrm{eV}$ 为单位输出（负值表示偏好离域）。\n3. 一个布尔值，指示近似模型是否偏好跨片区离域（如果平均分配状态的能量低于定域状态，则为真）。\n4. 一个标量验证值，用于精确模型中平均分配与定域的能量差异。对于相同的片区，此值必须为零；对于非均匀片区，此值必须为正，表示在精确理论中偏好将电荷定域在更有利的片区上。以 $\\mathrm{eV}$ 为单位输出。\n\n所有能量必须以电子伏特（即 $\\mathrm{eV}$）表示，所有电子数均为无量纲量。如果使用角度，必须以弧度为单位指定，但此处不需要角度。\n\n测试套件包括五个案例，共同探测理想情况、边界条件、电子增加和移除、非均匀性以及随片区数量扩展的情况：\n- 测试 $1$（理想情况，在相同片区上增加电子）：电子亲和能 $A = 3.0\\,\\mathrm{eV}$，曲率参数 $c = 0.6\\,\\mathrm{eV}$，要增加的总分数电子数 $\\delta = 0.4$（无量纲），相同片区数量 $m = 2$。\n- 测试 $2$（整数边界，在相同片区上增加电子）：电子亲和能 $A = 3.0\\,\\mathrm{eV}$，曲率参数 $c = 0.6\\,\\mathrm{eV}$，要增加的总分数电子数 $\\delta = 1.0$，相同片区数量 $m = 2$。\n- 测试 $3$（在相同片区上移除电子）：电离势 $I = 5.0\\,\\mathrm{eV}$，曲率参数 $c = 0.3\\,\\mathrm{eV}$，要移除的总分数电子数 $\\varphi = 0.25$（无量纲），相同片区数量 $m = 2$。\n- 测试 $4$（非均匀片区，增加电子）：片区电子亲和能列表 $A_1 = 2.5\\,\\mathrm{eV}$ 和 $A_2 = 3.0\\,\\mathrm{eV}$，曲率参数 $c = 0.5\\,\\mathrm{eV}$ 同样应用于两个片区，要增加的总分数电子数 $\\delta = 0.6$，片区数量 $m = 2$。\n- 测试 $5$（多个相同片区，增加电子）：电子亲和能 $A = 3.5\\,\\mathrm{eV}$，曲率参数 $c = 0.4\\,\\mathrm{eV}$，要增加的总分数电子数 $\\delta = 0.8$，相同片区数量 $m = 10$。\n\n使用以下符合上下文的基础来实现能量模型：\n- 用于整数之间 $E(N)$ 的系综变分原理，以及由增加或移除电子的前线轨道能量学给出的斜率恒定性。\n- 用于 Kohn–Sham DFT 的 Janak 定理，将轨道占据数与能量导数联系起来，以及在整数 $N$ 处的导数不连续性。\n- 在存在赝势和基组的情况下的无相互作用 Kohn–Sham 映射，此处通过前线参数（增加电子的电子亲和能和移除电子的电离势）和概括了交换关联及表示误差的单一曲率参数来建模。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果是按上述确切顺序排列的四个值的列表。例如：$[[$case\\_1\\_result$],[$case\\_2\\_result$],\\dots]$。不要对任何值进行四舍五入；按计算返回原始浮点结果。",
            "solution": "我们从 Hohenberg–Kohn 变分原理出发，该原理指出基态能量 $E[n]$ 是电子密度 $n(\\mathbf{r})$ 的一个泛函，并且正确的基态密度使该泛函最小化。在适用于分数电子数的系综推广中，整数之间的精确基态能量 $E(N)$ 是整数 $E(M)$ 值的凸包，因此是相邻整数之间的一条直线。对于 $N = M + \\alpha$ 且 $0 \\le \\alpha \\le 1$，可以得出 $E(N)$ 是 $M$-电子和 $(M+1)$-电子能量的系综混合，其在 $\\alpha$ 上是线性的。对于增加电子，整数之间 $E(N)$ 的斜率由前线轨道能量学决定，等于下一个整数的负电子亲和能；对于移除电子，斜率等于电离势。这可以通过 Janak 定理与 Kohn–Sham 理论联系起来，该定理得出 $\\partial E / \\partial f_i = \\varepsilon_i$，其中 $f_i$ 是轨道占据数，$\\varepsilon_i$ 是 Kohn–Sham 本征值。整数 $N$ 处的导数不连续性与交换关联势的跳跃有关，确保了正确的分段线性。\n\n近似的交换关联泛函（如局域和半局域形式）以及通过基组和赝势的有限表示通常缺乏导数不连续性，并导致 $E(N)$ 出现曲率，通常相对于电子数是凸的。凸性意味着，对于分离的片段，分数电荷分布的能量相对于正确的线性插值被虚假地降低了，从而产生了离域误差：分数电荷扩散到多个片段以获得能量，这与相同片段的精确理论相反，在精确理论中分布不应影响能量。\n\n我们用两种能量形式来模拟这些事实，这些形式提炼了核心物理，同时保持纯数学性：\n- 增加电子时整数之间的精确能量：对于单个表面片区，将能量变化定义为增加的电子分数 $\\alpha$ 的线性函数，斜率由电子亲和能设定。类似地，对于移除电子，将能量变化定义为移除的分数 $\\varphi$ 的线性函数，斜率由电离势设定。这实现了系综的分段线性和整数之间的恒定斜率。\n- 整数之间的近似能量：我们引入一个由单一曲率参数 $c$ 表示的凸性偏差，使得整数之间的能量是一个线性基线加上一个凸项。对于增加电子，这个凸项在中间分数占据时降低了能量，移除电子时也类似。\n\n我们构建一个具有 $m$ 个无相互作用片区的表面模型。对于相同的片区，由于所有片区共享相同的线性斜率，因此对片区求和的精确总能量与如何分布固定的总分数电子无关；因此，平均分配和定域在单个片区上产生相同的总能量。对于非均匀片区，精确理论偏好将电荷定域在电子亲和能较大（对于增加电子）或电离能较小（对于移除电子）的片区上，这使线性总能量相对于分布最小化。相比之下，对于近似的凸模型，将固定的分数电荷平均分配到 $m$ 个相同片区上会相对于定域在单个片区上降低总能量，且随着 $m$ 的增长，这种偏好更强。\n\n算法设计：\n1. 对于在单个片区上增加电子，将分数 $\\alpha$ 处与线性的有符号偏差定义为近似能量在 $\\alpha$ 处与整数端点之间线性插值的差值。对于凸性偏差，此量为负，其大小表征了分段线性误差。\n2. 对于 $m$ 个片区和要增加的总分数电子 $\\delta$，计算两种能量：定域（所有 $\\delta$ 放置在最有利的片区上）和离域（每个片区上平均分配 $\\delta/m$）。对于相同的片区，最有利的片区可以是任何一个。比较近似模型中的能量，以确定离域的能量优势和一个布尔偏好。在精确模型下计算相同的差异作为检验：对于相同的片区为零，对于非均匀片区且当电荷定域在最佳片区上时为正。\n3. 对于移除电子，使用电离势和分数移除 $\\varphi$ 来镜像定义。\n\n对于五个测试中的每一个：\n- 测试 $1$：相同片区增加电子的情况，$\\delta = 0.4$, $m = 2$, 电子亲和能 $A = 3.0\\,\\mathrm{eV}$, 曲率 $c = 0.6\\,\\mathrm{eV}$。计算一个片区上 $\\alpha = 0.4$ 时的分段线性偏差，并在近似和精确模型中比较跨两个片区分配与在一个片区上定域的能量变化。\n- 测试 $2$：整数边界 $\\delta = 1.0$ 显示单片区线性偏差为零，但在近似模型中仍存在多片区离域偏好，因为将一个电子跨两个相同片区分配通过曲率降低了能量，而精确模型则没有差异。\n- 测试 $3$：在相同片区上移除电子，$\\varphi = 0.25$, $I = 5.0\\,\\mathrm{eV}$, $c = 0.3\\,\\mathrm{eV}$，这与增加电子的情况类似；分段线性偏差和离域偏好以类似方式计算。\n- 测试 $4$：非均匀片区，$A_1 = 2.5\\,\\mathrm{eV}$ 和 $A_2 = 3.0\\,\\mathrm{eV}$, $c = 0.5\\,\\mathrm{eV}$, $\\delta = 0.6$, $m = 2$，这表明精确理论偏好将电荷定域在 $A$ 值较高的片区上，产生一个正的精确模型平均分配与定域的差异，而近似模型可能仍然偏好离域，具体取决于曲率参数。\n- 测试 $5$：$m = 10$ 个相同片区，$A = 3.5\\,\\mathrm{eV}$, $c = 0.4\\,\\mathrm{eV}$ 和 $\\delta = 0.8$，这说明在凸曲率下，离域优势随着片区数量的增加而增长。\n\n实现细节：\n- 电子亲和能 $A$ 和电离势 $I$ 以 $\\mathrm{eV}$ 为单位输入。\n- 曲率 $c$ 的单位是 $\\mathrm{eV}$，控制凸性偏差的大小；较大的 $c$ 产生更强的离域偏好。\n- 所有计算出的能量单位均为 $\\mathrm{eV}$，电子分数 $\\alpha$、$\\delta$ 和 $\\varphi$ 是无量纲的。\n\n最终输出为单行：一个包含五个子列表的列表，每个子列表对应一个测试，每个子列表包含四个元素：单片区与线性的偏差（单位 $\\mathrm{eV}$），近似模型中平均分配相对于定域的能量优势（单位 $\\mathrm{eV}$），对离域的布尔偏好，以及精确模型中平均分配与定域的能量差异（单位 $\\mathrm{eV}$）。不进行四舍五入。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef E_exact_add(alpha: float, A: float) - float:\n    \"\"\"\n    Exact piecewise-linear energy change for adding alpha electrons to a single patch.\n    E(N) between integers is linear; for addition the slope is -A (electron affinity).\n    \"\"\"\n    return -A * alpha\n\ndef E_approx_add(alpha: float, A: float, c: float) - float:\n    \"\"\"\n    Approximate convex energy model for adding alpha electrons to a single patch.\n    Linear baseline (-A*alpha) plus a convex deviation captured by -c * alpha * (1 - alpha).\n    \"\"\"\n    return -A * alpha - c * alpha * (1.0 - alpha)\n\ndef E_exact_remove(phi: float, I: float) - float:\n    \"\"\"\n    Exact piecewise-linear energy change for removing phi electrons from a single patch.\n    For removal, the slope is +I (ionization potential).\n    \"\"\"\n    return +I * phi\n\ndef E_approx_remove(phi: float, I: float, c: float) - float:\n    \"\"\"\n    Approximate convex energy model for removing phi electrons from a single patch.\n    Linear baseline (+I*phi) plus a convex deviation captured by -c * phi * (1 - phi).\n    \"\"\"\n    return +I * phi - c * phi * (1.0 - phi)\n\ndef linear_interpolation_add(alpha: float, A: float, c: float) - float:\n    \"\"\"\n    Linear interpolation between integer endpoints for the approximate model baseline\n    (used only to compute deviation; note endpoints are consistent with exact theory).\n    At alpha=0: E=0; at alpha=1: E=-A (convex term vanishes at endpoints).\n    \"\"\"\n    E0 = 0.0\n    E1 = -A\n    return (1.0 - alpha) * E0 + alpha * E1\n\ndef linear_interpolation_remove(phi: float, I: float, c: float) - float:\n    \"\"\"\n    Linear interpolation between integer endpoints for removal.\n    At phi=0: E=0; at phi=1: E=+I (convex term vanishes at endpoints).\n    \"\"\"\n    E0 = 0.0\n    E1 = +I\n    return (1.0 - phi) * E0 + phi * E1\n\ndef total_energy_add_distribution(delta: float, A_list, c: float, m: int, equal_split: bool) - float:\n    \"\"\"\n    Total energy for addition across m patches, with either localization on the best patch\n    or equal split across all patches. A_list may be a scalar (identical) or a list per patch.\n    \"\"\"\n    # Normalize A_list to per-patch list\n    if isinstance(A_list, (int, float)):\n        A_vals = [float(A_list)] * m\n    else:\n        A_vals = list(A_list)\n        if len(A_vals) != m:\n            # If fewer provided, repeat last; if more, truncate.\n            if len(A_vals)  m:\n                A_vals = A_vals + [A_vals[-1]] * (m - len(A_vals))\n            else:\n                A_vals = A_vals[:m]\n\n    if equal_split:\n        frac = delta / m\n        return sum(E_approx_add(frac, A_vals[i], c) for i in range(m))\n    else:\n        # Localize on the patch with the largest A (most favorable for addition).\n        best_idx = int(np.argmax(A_vals))\n        energy = 0.0\n        for i in range(m):\n            if i == best_idx:\n                energy += E_approx_add(delta, A_vals[i], c)\n            else:\n                energy += 0.0  # no change on other patches\n        return energy\n\ndef total_energy_add_distribution_exact(delta: float, A_list, m: int, equal_split: bool) - float:\n    \"\"\"\n    Exact total energy for addition across m patches for distribution comparison.\n    \"\"\"\n    if isinstance(A_list, (int, float)):\n        A_vals = [float(A_list)] * m\n    else:\n        A_vals = list(A_list)\n        if len(A_vals) != m:\n            if len(A_vals)  m:\n                A_vals = A_vals + [A_vals[-1]] * (m - len(A_vals))\n            else:\n                A_vals = A_vals[:m]\n\n    if equal_split:\n        frac = delta / m\n        return sum(E_exact_add(frac, A_vals[i]) for i in range(m))\n    else:\n        best_idx = int(np.argmax(A_vals))\n        energy = 0.0\n        for i in range(m):\n            if i == best_idx:\n                energy += E_exact_add(delta, A_vals[i])\n            else:\n                energy += 0.0\n        return energy\n\ndef total_energy_remove_distribution(phi: float, I_list, c: float, m: int, equal_split: bool) - float:\n    \"\"\"\n    Total energy for removal across m patches, approximate model.\n    I_list may be scalar or list per patch.\n    \"\"\"\n    if isinstance(I_list, (int, float)):\n        I_vals = [float(I_list)] * m\n    else:\n        I_vals = list(I_list)\n        if len(I_vals) != m:\n            if len(I_vals)  m:\n                I_vals = I_vals + [I_vals[-1]] * (m - len(I_vals))\n            else:\n                I_vals = I_vals[:m]\n\n    if equal_split:\n        frac = phi / m\n        return sum(E_approx_remove(frac, I_vals[i], c) for i in range(m))\n    else:\n        # For removal, localize on the patch with the smallest I (least energy increase).\n        best_idx = int(np.argmin(I_vals))\n        energy = 0.0\n        for i in range(m):\n            if i == best_idx:\n                energy += E_approx_remove(phi, I_vals[i], c)\n            else:\n                energy += 0.0\n        return energy\n\ndef total_energy_remove_distribution_exact(phi: float, I_list, m: int, equal_split: bool) - float:\n    \"\"\"\n    Exact total energy for removal across m patches for distribution comparison.\n    \"\"\"\n    if isinstance(I_list, (int, float)):\n        I_vals = [float(I_list)] * m\n    else:\n        I_vals = list(I_list)\n        if len(I_vals) != m:\n            if len(I_vals)  m:\n                I_vals = I_vals + [I_vals[-1]] * (m - len(I_vals))\n            else:\n                I_vals = I_vals[:m]\n\n    if equal_split:\n        frac = phi / m\n        return sum(E_exact_remove(frac, I_vals[i]) for i in range(m))\n    else:\n        best_idx = int(np.argmin(I_vals))\n        energy = 0.0\n        for i in range(m):\n            if i == best_idx:\n                energy += E_exact_remove(phi, I_vals[i])\n            else:\n                energy += 0.0\n        return energy\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: happy path addition on identical patches\n        {\"kind\": \"add_identical\", \"A\": 3.0, \"c\": 0.6, \"delta\": 0.4, \"m\": 2},\n        # Test 2: boundary integer addition on identical patches\n        {\"kind\": \"add_identical\", \"A\": 3.0, \"c\": 0.6, \"delta\": 1.0, \"m\": 2},\n        # Test 3: removal on identical patches\n        {\"kind\": \"remove_identical\", \"I\": 5.0, \"c\": 0.3, \"phi\": 0.25, \"m\": 2},\n        # Test 4: addition on heterogeneous patches\n        {\"kind\": \"add_hetero\", \"A_list\": [2.5, 3.0], \"c\": 0.5, \"delta\": 0.6, \"m\": 2},\n        # Test 5: addition on many identical patches\n        {\"kind\": \"add_identical\", \"A\": 3.5, \"c\": 0.4, \"delta\": 0.8, \"m\": 10},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        kind = case[\"kind\"]\n        if kind == \"add_identical\":\n            A = float(case[\"A\"])\n            c = float(case[\"c\"])\n            delta = float(case[\"delta\"])\n            m = int(case[\"m\"])\n\n            # 1) Single-patch deviation from piecewise linearity at alpha = delta (use approximate model vs linear interpolation)\n            approx = E_approx_add(delta, A, c)\n            lin = linear_interpolation_add(delta, A, c)\n            deviation = approx - lin  # in eV\n\n            # 2) Approximate model energy advantage of equal split over localization\n            E_deloc_approx = total_energy_add_distribution(delta, A, c, m, equal_split=True)\n            E_local_approx = total_energy_add_distribution(delta, A, c, m, equal_split=False)\n            advantage = E_deloc_approx - E_local_approx  # negative favors delocalization\n\n            # 3) Boolean preference for delocalization\n            prefer_deloc = E_deloc_approx  E_local_approx\n\n            # 4) Exact model equal-split vs localized energy difference\n            E_deloc_exact = total_energy_add_distribution_exact(delta, A, m, equal_split=True)\n            E_local_exact = total_energy_add_distribution_exact(delta, A, m, equal_split=False)\n            exact_diff = E_deloc_exact - E_local_exact  # should be 0 for identical patches\n\n            results.append([deviation, advantage, prefer_deloc, exact_diff])\n\n        elif kind == \"remove_identical\":\n            I = float(case[\"I\"])\n            c = float(case[\"c\"])\n            phi = float(case[\"phi\"])\n            m = int(case[\"m\"])\n\n            # 1) Single-patch deviation from piecewise linearity at phi (approximate vs linear interpolation)\n            approx = E_approx_remove(phi, I, c)\n            lin = linear_interpolation_remove(phi, I, c)\n            deviation = approx - lin  # in eV\n\n            # 2) Approximate model energy advantage of equal split over localization\n            E_deloc_approx = total_energy_remove_distribution(phi, I, c, m, equal_split=True)\n            E_local_approx = total_energy_remove_distribution(phi, I, c, m, equal_split=False)\n            advantage = E_deloc_approx - E_local_approx  # negative favors delocalization\n\n            # 3) Boolean preference for delocalization\n            prefer_deloc = E_deloc_approx  E_local_approx\n\n            # 4) Exact model equal-split vs localized energy difference\n            E_deloc_exact = total_energy_remove_distribution_exact(phi, I, m, equal_split=True)\n            E_local_exact = total_energy_remove_distribution_exact(phi, I, m, equal_split=False)\n            exact_diff = E_deloc_exact - E_local_exact  # should be 0 for identical patches\n\n            results.append([deviation, advantage, prefer_deloc, exact_diff])\n\n        elif kind == \"add_hetero\":\n            A_list = case[\"A_list\"]\n            c = float(case[\"c\"])\n            delta = float(case[\"delta\"])\n            m = int(case[\"m\"])\n\n            # For hetero, define single-patch deviation using the more favorable patch's A (max A)\n            A_best = float(np.max(A_list))\n            approx = E_approx_add(delta, A_best, c)\n            lin = linear_interpolation_add(delta, A_best, c)\n            deviation = approx - lin  # in eV\n\n            # Approximate model energy advantage of equal split over localization on best patch\n            E_deloc_approx = total_energy_add_distribution(delta, A_list, c, m, equal_split=True)\n            E_local_approx = total_energy_add_distribution(delta, A_list, c, m, equal_split=False)\n            advantage = E_deloc_approx - E_local_approx\n            prefer_deloc = E_deloc_approx  E_local_approx\n\n            # Exact model equal-split vs localized on best patch; for hetero, exact prefers localization\n            E_deloc_exact = total_energy_add_distribution_exact(delta, A_list, m, equal_split=True)\n            E_local_exact = total_energy_add_distribution_exact(delta, A_list, m, equal_split=False)\n            exact_diff = E_deloc_exact - E_local_exact  # expected positive\n\n            results.append([deviation, advantage, prefer_deloc, exact_diff])\n\n        else:\n            # Unknown case kind; skip\n            results.append([np.nan, np.nan, False, np.nan])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}