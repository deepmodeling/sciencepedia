{
    "hands_on_practices": [
        {
            "introduction": "在基于平面波的密度泛函理论（DFT）计算中，结果的准确性严重依赖于数值参数的选择，例如平面波基组的能量截断值$E_{\\text{cut}}$。为了获得可靠的吸附能，必须系统地测试计算结果随这些参数的变化是否收敛。本实践将指导你建立一个自动化协议，通过对合成数据的拟合来确定达到目标精度所需的最小参数，这是所有DFT计算工作流程中至关重要的第一步。",
            "id": "4241951",
            "problem": "要求您设计并实现一个完整的、可运行的程序。该程序基于第一性原理定义和平面波密度泛函理论 (DFT) 中公认的数值误差行为，分析平面波基组截断能和实空间网格密度如何影响计算得到的吸附能，并为平面波截断能构建一个系统性的收敛协议。吸附质与表面结合的吸附能定义为总能量之差，即$E_{\\text{ads}} = E_{\\text{slab+ads}} - E_{\\text{slab}} - E_{\\text{adsorbate}}$，其中每个总能量都通过平面波 DFT 方法计算。在平面波方法中，平面波基的截断由一个能量截断参数$E_{\\text{cut}}$控制，该参数设定了平面波基的最大倒易空间矢量模长。用于表示电荷密度和势的实空间网格通过一个特征网格间距$h$与最大倒易空间频率相关联。在与周期函数的傅里叶分析一致的最简单理想化模型中，所包含的最大倒易空间矢量模长按$G_{\\max} \\propto \\sqrt{E_{\\text{cut}}}$缩放，而代表性的实空间网格间距则按$h \\propto \\frac{1}{G_{\\max}}}$反向缩放。引入一个无量纲的网格密度因子$s \\geq 1$来乘以倒易空间分辨率（$s$越大意味着实空间网格越密集），我们采用关系式$h(E_{\\text{cut}},s) = \\frac{\\alpha}{\\sqrt{E_{\\text{cut}}}\\, s}$，其中$\\alpha$是研究中固定的一个正常数。\n\n根据足够光滑函数的傅里叶表示的截断和离散化误差理论，我们假设每个总能量（带吸附质的板、单独的板、单独的吸附质）的主阶数值误差是两个正贡献项之和：一个基组截断误差，它随$E_{\\text{cut}}$以幂律形式衰减；一个网格离散化误差，它随$h$以幂律形式衰减。对于实体$X \\in \\{\\text{slab+ads}, \\text{slab}, \\text{adsorbate}\\}$，我们将计算出的总能量建模为\n$$\nE_X(E_{\\text{cut}}, s) = E_X^{\\text{true}} + B_X\\, E_{\\text{cut}}^{-p_X} + G_X\\, h(E_{\\text{cut}},s)^{q_X},\n$$\n其中$E_X^{\\text{true}}$是真实的总能量，$B_X$和$G_X$是正的误差前置因子，$p_X > 0$和$q_X > 0$是收敛指数。然后，吸附能可以根据上述定义以及在形成能量差时部分误差的抵消得出：\n$$\nE_{\\text{ads}}(E_{\\text{cut}},s) = E_{\\text{slab+ads}}(E_{\\text{cut}},s) - E_{\\text{slab}}(E_{\\text{cut}},s) - E_{\\text{adsorbate}}(E_{\\text{cut}},s).\n$$\n为完成此编程挑战，您将使用上述误差模型生成合成数据，然后实现一个收敛协议。该收敛协议必须：\n- 通过将在最密集网格$s_{\\max}$下的$E_{\\text{ads}}(E_{\\text{cut}}, s_{\\max})$拟合到形式为$E_{\\text{ads}}(E_{\\text{cut}}, s_{\\max}) \\approx E_{\\text{ads}}^{\\infty} + K\\, E_{\\text{cut}}^{-p}$的反幂律模型，来估计对应于$E_{\\text{cut}} \\to \\infty$和足够密集网格的渐近吸附能$E_{\\text{ads}}^{\\infty}$，其中$K$和$p$是通过非线性最小二乘法确定的参数。\n- 定义并计算一个推荐的最小平面波截断能$E_{\\text{cut}}^{\\text{rec}}$，使得剩余的基组截断误差大小$|K| E_{\\text{cut}}^{-p}$低于给定的容差$\\varepsilon > 0$，即\n$$\nE_{\\text{cut}}^{\\text{rec}} \\ge \\left(\\frac{|K|}{\\varepsilon}\\right)^{1/p}.\n$$\n- 在推荐截断能$E_{\\text{cut}}^{\\text{rec}}$下，确定最小网格密度因子$s^{\\text{rec}}$，使得差值$|E_{\\text{ads}}(E_{\\text{cut}}^{\\text{rec}}, s) - E_{\\text{ads}}(E_{\\text{cut}}^{\\text{rec}}, s_{\\max})|$不大于$\\varepsilon$，选择满足此条件的最小$s$。\n- 为每个测试用例返回推荐的截断能$E_{\\text{cut}}^{\\text{rec}}$、推荐的网格密度因子$s^{\\text{rec}}$、估计的收敛吸附能$E_{\\text{ads}}^{\\infty}$，以及一个布尔标志，指示在提供的离散截断能和网格因子集合内是否可以实现收敛目标。\n\n您必须用代码实现您的协议，并将其应用于以下明确的测试套件场景。能量单位为$\\mathrm{eV}$，截断能单位为$\\mathrm{eV}$，网格间距单位为$\\mathrm{\\AA}$；最终的吸附能必须以$\\mathrm{eV}$表示。请使用下面给出的离散截断能和网格因子集合；在选择推荐截断能时，您必须选择满足上述不等式的所提供截断能集合中的最小元素，如果无法满足不等式，则选择可用的最大截断能。在选择推荐的网格密度因子时，您必须选择满足网格容差标准的所提供网格因子集合中的最小元素，如果没有元素满足标准，则选择可用的最大网格因子。容差$\\varepsilon$应以$\\mathrm{eV}$为单位应用。\n\n采用网格间距模型\n$$\nh(E_{\\text{cut}},s) = \\frac{\\alpha}{\\sqrt{E_{\\text{cut}}}\\, s}.\n$$\n\n定义包含三个场景的测试套件，每个场景为$X \\in \\{\\text{slab+ads}, \\text{slab}, \\text{adsorbate}\\}$提供$(E_X^{\\text{true}}, B_X, p_X, G_X, q_X)$，以及共享的常数$\\alpha$、离散截断能集合、离散网格因子集合和容差$\\varepsilon$：\n\n- 场景 1（一般的“理想路径”）：\n  - $E_{\\text{slab+ads}}^{\\text{true}} = -100.0\\,\\mathrm{eV}$, $E_{\\text{slab}}^{\\text{true}} = -99.3\\,\\mathrm{eV}$, $E_{\\text{adsorbate}}^{\\text{true}} = -0.2\\,\\mathrm{eV}$。\n  - $B_{\\text{slab+ads}} = 12.0$, $p_{\\text{slab+ads}} = 1.8$; $B_{\\text{slab}} = 11.4$, $p_{\\text{slab}} = 1.8$; $B_{\\text{adsorbate}} = 0.3$, $p_{\\text{adsorbate}} = 1.8$。\n  - $G_{\\text{slab+ads}} = 0.20$, $q_{\\text{slab+ads}} = 2.0$; $G_{\\text{slab}} = 0.18$, $q_{\\text{slab}} = 2.0$; $G_{\\text{adsorbate}} = 0.01$, $q_{\\text{adsorbate}} = 2.0$。\n  - $\\alpha = 20.0$。\n  - 离散截断能集合: $\\{300.0, 400.0, 500.0, 600.0\\}\\,\\mathrm{eV}$。\n  - 离散网格因子集合: $\\{1.0, 1.5, 2.0\\}$。\n  - 容差: $\\varepsilon = 0.01\\,\\mathrm{eV}$。\n\n- 场景 2（基组收敛缓慢的边界情况）：\n  - $E_{\\text{slab+ads}}^{\\text{true}} = -250.0\\,\\mathrm{eV}$, $E_{\\text{slab}}^{\\text{true}} = -249.0\\,\\mathrm{eV}$, $E_{\\text{adsorbate}}^{\\text{true}} = -0.8\\,\\mathrm{eV}$。\n  - $B_{\\text{slab+ads}} = 20.0$, $p_{\\text{slab+ads}} = 0.8$; $B_{\\text{slab}} = 5.0$, $p_{\\text{slab}} = 1.6$; $B_{\\text{adsorbate}} = 2.0$, $p_{\\text{adsorbate}} = 1.2$。\n  - $G_{\\text{slab+ads}} = 0.10$, $q_{\\text{slab+ads}} = 2.0$; $G_{\\text{slab}} = 0.10$, $q_{\\text{slab}} = 2.0$; $G_{\\text{adsorbate}} = 0.05$, $q_{\\text{adsorbate}} = 2.0$。\n  - $\\alpha = 20.0$。\n  - 离散截断能集合: $\\{300.0, 400.0, 500.0, 600.0\\}\\,\\mathrm{eV}$。\n  - 离散网格因子集合: $\\{1.0, 1.5, 2.0\\}$。\n  - 容差: $\\varepsilon = 0.01\\,\\mathrm{eV}$。\n\n- 场景 3（$E_{\\text{ads}}$ 中存在强误差抵消的边缘情况）：\n  - $E_{\\text{slab+ads}}^{\\text{true}} = -150.0\\,\\mathrm{eV}$, $E_{\\text{slab}}^{\\text{true}} = -149.4\\,\\mathrm{eV}$, $E_{\\text{adsorbate}}^{\\text{true}} = -0.4\\,\\mathrm{eV}$。\n  - $B_{\\text{slab+ads}} = 8.0$, $p_{\\text{slab+ads}} = 1.6$; $B_{\\text{slab}} = 7.98$, $p_{\\text{slab}} = 1.6$; $B_{\\text{adsorbate}} = 0.01$, $p_{\\text{adsorbate}} = 1.6$。\n  - $G_{\\text{slab+ads}} = 0.08$, $q_{\\text{slab+ads}} = 2.0$; $G_{\\text{slab}} = 0.079$, $q_{\\text{slab}} = 2.0$; $G_{\\text{adsorbate}} = 0.001$, $q_{\\text{adsorbate}} = 2.0$。\n  - $\\alpha = 20.0$。\n  - 离散截断能集合: $\\{300.0, 400.0, 500.0, 600.0\\}\\,\\mathrm{eV}$。\n  - 离散网格因子集合: $\\{1.0, 1.5, 2.0\\}$。\n  - 容差: $\\varepsilon = 0.01\\,\\mathrm{eV}$。\n\n您的程序必须为每个场景，在所提供的离散截断能集合中的每个$E_{\\text{cut}}$和所提供的离散网格因子集合中的每个$s$的组合下生成$E_{\\text{ads}}(E_{\\text{cut}}, s)$，在最密集的网格$s_{\\max} = \\max\\{s\\}$下执行截断能收敛拟合，估计$E_{\\text{ads}}^{\\infty}$，根据离散截断能集合计算$E_{\\text{cut}}^{\\text{rec}}$，根据离散网格因子集合找到$s^{\\text{rec}}$，并确定在给定的离散集合下目标是否可实现。\n\n最终输出格式要求：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个场景一个条目。每个场景的条目本身必须是$[E_{\\text{cut}}^{\\text{rec}}, s^{\\text{rec}}, E_{\\text{ads}}^{\\infty}, \\text{is\\_converged}]$形式的列表，其中$E_{\\text{cut}}^{\\text{rec}}$和$E_{\\text{ads}}^{\\infty}$是以$\\mathrm{eV}$为单位的浮点数，$s^{\\text{rec}}$是一个浮点数，而$\\text{is\\_converged}$是一个布尔值。例如，输出格式应类似于$[[x_1,y_1,z_1,b_1],[x_2,y_2,z_2,b_2],[x_3,y_3,z_3,b_3]]$，不含任何额外文本。",
            "solution": "用户提供了一个定义明确的计算问题，该问题基于平面波密度泛函理论 (DFT) 的原理。问题是为两个关键数值参数实现一个收敛性测试协议：平面波截断能$E_{\\text{cut}}$和实空间网格密度因子$s$。该协议将应用于根据一个合理的误差模型生成的合成数据，该模型描述了一种物质在表面上的吸附能$E_{\\text{ads}}$。\n\n该问题是有效的，因为它具有科学依据、自成体系且算法上已明确规定。它代表了计算材料科学和化学中一个常见且关键的工作流程。我们将逐步进行求解。\n\n首先，我们形式化数据生成过程。任何组分$X \\in \\{\\text{slab+ads}, \\text{slab}, \\text{adsorbate}\\}$的总能量被建模为$E_{\\text{cut}}$和$s$的函数：\n$$\nE_X(E_{\\text{cut}}, s) = E_X^{\\text{true}} + B_X E_{\\text{cut}}^{-p_X} + G_X h(E_{\\text{cut}},s)^{q_X}\n$$\n项$E_X^{\\text{true}}$是精确的、完全收敛的能量。第二项$B_X E_{\\text{cut}}^{-p_X}$代表基组截断误差，它随截断能以幂律形式衰减。第三项$G_X h(E_{\\text{cut}},s)^{q_X}$代表实空间网格离散化误差，它随网格间距$h$以幂律形式衰减。网格间距$h$本身是$E_{\\text{cut}}$和无量纲网格密度因子$s$的函数：\n$$\nh(E_{\\text{cut}},s) = \\frac{\\alpha}{\\sqrt{E_{\\text{cut}}}\\, s}\n$$\n吸附能$E_{\\text{ads}}$是我们感兴趣的量，定义为总能量之差：\n$$\nE_{\\text{ads}}(E_{\\text{cut}},s) = E_{\\text{slab+ads}}(E_{\\text{cut}},s) - E_{\\text{slab}}(E_{\\text{cut}},s) - E_{\\text{adsorbate}}(E_{\\text{cut}},s)\n$$\n通过代入每个总能量的表达式，我们得到计算吸附能的模型。对于每个场景，我们将使用这些方程为所提供的离散$E_{\\text{cut}}$和$s$值的每种组合生成一个$E_{\\text{ads}}$值表。\n\n收敛协议包括四个主要步骤，我们将为每个测试场景实现这些步骤。\n\n1.  **估计渐近吸附能$E_{\\text{ads}}^{\\infty}$**：\n    第一步是估计在无限基组极限下（$E_{\\text{cut}} \\to \\infty$）的吸附能。该协议指定使用来自最密集可用实空间网格的数据，即在$s_{\\max} = \\max\\{s_i\\}$处，其中$\\{s_i\\}$是提供的网格密度因子集合。计算值$E_{\\text{ads}}(E_{\\text{cut}}, s_{\\max})$使用非线性最小二乘法拟合到以下简化模型：\n    $$\n    E_{\\text{ads}}(E_{\\text{cut}}, s_{\\max}) \\approx E_{\\text{ads}}^{\\infty} + K\\, E_{\\text{cut}}^{-p}\n    $$\n    拟合产生参数$E_{\\text{ads}}^{\\infty}$、$K$和$p$。我们将为此目的使用`scipy.optimize.curve_fit`函数。该函数需要参数的初始猜测值；我们将使用理论上已知的真实吸附能$E_{\\text{ads}}^{\\text{true}} = E_{\\text{slab+ads}}^{\\text{true}} - E_{\\text{slab}}^{\\text{true}} - E_{\\text{adsorbate}}^{\\text{true}}$作为$E_{\\text{ads}}^{\\infty}$的猜测值，并为$K$和$p$提供合理的起始值。\n\n2.  **确定推荐的平面波截断能$E_{\\text{cut}}^{\\text{rec}}$**：\n    使用拟合得到的参数，我们将给定截断能下的剩余基组误差估计为$|K| E_{\\text{cut}}^{-p}$。协议要求找到一个推荐的截断能$E_{\\text{cut}}^{\\text{rec}}$，使得此误差小于或等于指定的容差$\\varepsilon$。该条件表示为：\n    $$\n    |K|\\,(E_{\\text{cut}}^{\\text{rec}})^{-p} \\le \\varepsilon \\quad \\Longleftrightarrow \\quad E_{\\text{cut}}^{\\text{rec}} \\ge \\left(\\frac{|K|}{\\varepsilon}\\right)^{1/p}\n    $$\n    我们必须从可用的离散截断能集合中选择$E_{\\text{cut}}^{\\text{rec}}$。规则是选择集合中满足此不等式的最小截断能。如果集合中没有截断能满足该条件，则将$E_{\\text{cut}}^{\\text rec}$设置为可用的最大截断能。\n\n3.  **确定推荐的网格密度因子$s^{\\text{rec}}$**：\n    接下来，我们将截断能固定在$E_{\\text{cut}}^{\\text{rec}}$值，并确定收敛网格依赖误差所需的最小网格密度因子$s^{\\text{rec}}$。收敛性是与最密集可用网格$s_{\\max}$下的结果进行比较来衡量的。条件是：\n    $$\n    |E_{\\text{ads}}(E_{\\text{cut}}^{\\text{rec}}, s^{\\text{rec}}) - E_{\\text{ads}}(E_{\\text{cut}}^{\\text{rec}}, s_{\\max})| \\le \\varepsilon\n    $$\n    我们必须从可用的离散网格因子集合中选择$s^{\\text{rec}}$。规则是选择满足此条件的最小因子$s$。如果集合中没有因子满足该条件，则将$s^{\\textrec}$设置为可用的最大因子。\n\n4.  **评估收敛可实现性`is_converged`**：\n    确定一个布尔标志`is_converged`，用于报告$E_{\\text{cut}}$和$s$的收敛目标是否在提供的离散集合内都已实现。只有当*同时*为$E_{\\text{cut}}^{\\text{rec}}$和$s^{\\text{rec}}$找到了满足容差的候选值时，此标志才为`True`。如果任一参数因为无法满足容差而不得不默认使用可用的最大值，则该标志将为`False`。\n\n该实现将处理三个场景中的每一个，执行这个四步协议，并将结果（$E_{\\text{cut}}^{\\text{rec}}$、$s^{\\text{rec}}$、$E_{\\text{ads}}^{\\infty}$、`is_converged`）整理到一个最终列表中。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef solve():\n    \"\"\"\n    Implements and runs a convergence analysis protocol for plane-wave DFT calculations\n    based on a provided error model and test scenarios.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Scenario 1: General \"happy path\"\n        {\n            \"params\": {\n                \"slab+ads\": {\"E_true\": -100.0, \"B\": 12.0, \"p\": 1.8, \"G\": 0.20, \"q\": 2.0},\n                \"slab\":     {\"E_true\": -99.3,  \"B\": 11.4, \"p\": 1.8, \"G\": 0.18, \"q\": 2.0},\n                \"adsorbate\":{\"E_true\": -0.2,   \"B\": 0.3, \"p\": 1.8, \"G\": 0.01, \"q\": 2.0}\n            },\n            \"alpha\": 20.0,\n            \"cutoffs\": np.array([300.0, 400.0, 500.0, 600.0]),\n            \"s_factors\": np.array([1.0, 1.5, 2.0]),\n            \"epsilon\": 0.01\n        },\n        # Scenario 2: Boundary case with slow basis convergence\n        {\n            \"params\": {\n                \"slab+ads\": {\"E_true\": -250.0, \"B\": 20.0, \"p\": 0.8, \"G\": 0.10, \"q\": 2.0},\n                \"slab\":     {\"E_true\": -249.0, \"B\": 5.0,  \"p\": 1.6, \"G\": 0.10, \"q\": 2.0},\n                \"adsorbate\":{\"E_true\": -0.8,   \"B\": 2.0,  \"p\": 1.2, \"G\": 0.05, \"q\": 2.0}\n            },\n            \"alpha\": 20.0,\n            \"cutoffs\": np.array([300.0, 400.0, 500.0, 600.0]),\n            \"s_factors\": np.array([1.0, 1.5, 2.0]),\n            \"epsilon\": 0.01\n        },\n        # Scenario 3: Edge case with strong error cancellation\n        {\n            \"params\": {\n                \"slab+ads\": {\"E_true\": -150.0, \"B\": 8.0,  \"p\": 1.6, \"G\": 0.08,  \"q\": 2.0},\n                \"slab\":     {\"E_true\": -149.4, \"B\": 7.98, \"p\": 1.6, \"G\": 0.079, \"q\": 2.0},\n                \"adsorbate\":{\"E_true\": -0.4,   \"B\": 0.01, \"p\": 1.6, \"G\": 0.001, \"q\": 2.0}\n            },\n            \"alpha\": 20.0,\n            \"cutoffs\": np.array([300.0, 400.0, 500.0, 600.0]),\n            \"s_factors\": np.array([1.0, 1.5, 2.0]),\n            \"epsilon\": 0.01\n        }\n    ]\n\n    def h_spacing(E_cut, s, alpha):\n        return alpha / (np.sqrt(E_cut) * s)\n\n    def total_energy(E_cut, s, E_true, B, p, G, q, alpha):\n        h = h_spacing(E_cut, s, alpha)\n        return E_true + B * E_cut**(-p) + G * h**q\n\n    def ads_energy(E_cut, s, params, alpha):\n        E_sad = total_energy(E_cut, s, **params[\"slab+ads\"], alpha=alpha)\n        E_sl = total_energy(E_cut, s, **params[\"slab\"], alpha=alpha)\n        E_ad = total_energy(E_cut, s, **params[\"adsorbate\"], alpha=alpha)\n        return E_sad - E_sl - E_ad\n\n    def fit_model(E_cut, E_ads_inf, K, p):\n        return E_ads_inf + K * E_cut**(-p)\n\n    results = []\n    for case in test_cases:\n        params = case[\"params\"]\n        alpha = case[\"alpha\"]\n        cutoffs = case[\"cutoffs\"]\n        s_factors = case[\"s_factors\"]\n        epsilon = case[\"epsilon\"]\n\n        # Step 1: Fit for asymptotic energy E_ads_inf\n        s_max = np.max(s_factors)\n        E_ads_at_s_max = np.array([ads_energy(ec, s_max, params, alpha) for ec in cutoffs])\n        \n        true_E_ads_inf = params[\"slab+ads\"][\"E_true\"] - params[\"slab\"][\"E_true\"] - params[\"adsorbate\"][\"E_true\"]\n        p0 = [true_E_ads_inf, 1.0, 1.5] # Initial guess for E_ads_inf, K, p\n        \n        try:\n            popt, _ = curve_fit(fit_model, cutoffs, E_ads_at_s_max, p0=p0, maxfev=5000)\n            E_ads_inf, K, p_fit = popt\n            fit_valid = p_fit > 0 and not np.isinf(K) and not np.isnan(K)\n        except RuntimeError:\n            fit_valid = False\n\n        if not fit_valid:\n            E_cut_rec = np.max(cutoffs)\n            s_rec = np.max(s_factors)\n            is_converged = False\n            results.append([float(E_cut_rec), float(s_rec), np.nan, is_converged])\n            continue\n\n        # Step 2: Determine recommended cutoff E_cut_rec\n        E_cut_thresh = (np.abs(K) / epsilon)**(1 / p_fit)\n        E_cut_candidates = cutoffs[cutoffs >= E_cut_thresh]\n        \n        if E_cut_candidates.size > 0:\n            E_cut_rec = np.min(E_cut_candidates)\n            cutoff_converged = True\n        else:\n            E_cut_rec = np.max(cutoffs)\n            cutoff_converged = False\n\n        # Step 3: Determine recommended grid factor s_rec\n        E_ads_target_grid = ads_energy(E_cut_rec, s_max, params, alpha)\n        s_rec_candidates = []\n        for s_val in s_factors:\n            E_ads_current_s = ads_energy(E_cut_rec, s_val, params, alpha)\n            if np.abs(E_ads_current_s - E_ads_target_grid) = epsilon:\n                s_rec_candidates.append(s_val)\n\n        if s_rec_candidates:\n            s_rec = np.min(s_rec_candidates)\n            grid_converged = True\n        else:\n            s_rec = np.max(s_factors)\n            grid_converged = False\n\n        # Step 4: Determine final convergence status\n        is_converged = cutoff_converged and grid_converged\n\n        results.append([float(E_cut_rec), float(s_rec), E_ads_inf, is_converged])\n\n    # Final print statement in the exact required format.\n    # Manually construct string to match example format [[a,b,c,d],[e,f,g,h]] with no spaces.\n    outer_parts = []\n    for res_list in results:\n        # Format boolean as lowercase true/false\n        inner_parts = [str(v) for v in res_list[:-1]] + [str(res_list[-1]).lower()]\n        outer_parts.append(f\"[{','.join(inner_parts)}]\")\n    \n    print(f\"[{','.join(outer_parts)}]\")\n    \nsolve()\n```"
        },
        {
            "introduction": "直接从DFT计算中获得的吸附能通常对应于真空或气相环境，要将其与真实的电化学条件联系起来，需要引入热力学模型。计算氢电极（Computational Hydrogen Electrode, CHE）模型是实现这一目标的核心工具，它能够将吸附自由能与电极电势$U$和溶液pH值关联起来。本实践将以OH*吸附为例，向你展示如何计算一个电化学反应的吸附自由能，并分析其如何随电化学环境的变化而改变。",
            "id": "4241890",
            "problem": "考虑一个在周期性边界条件下，用于密度泛函理论 (DFT) 计算中性吸附质在导电电极表面上的金属板模型。吸附质结合能定义为$E_{\\text{ads}} = E_{\\text{slab+ads}} - E_{\\text{slab}} - E_{\\text{adsorbate}}$，其中每一项都是为明确定义的状态计算的总能量。在每个超胞含有一个吸附质的周期性超胞方法中，非零覆盖度会引起周期性镜像之间的横向相互作用。这些相互作用在$E_{\\text{ads}}$中产生有限尺寸误差，该误差取决于超胞面积$A$和隐含的覆盖度$\\theta$。从基本物理考虑出发，假设吸附质是中性的，在周期性镜像间不发生反应，且横向相互作用是短程的，足以存在一个系统性的小覆盖度展开。目标是通过构建一个与覆盖度相关的小参数相一致的渐近模型，进行回归分析，并选择足以描述数据的最简化模型，将$E_{\\text{ads}}$外推到稀释极限（无限面积，零覆盖度）。\n\n您的任务是：\n- 推导一个关于$E_{\\text{ads}}$的最小参数族，它应是与每个超胞一个吸附质所产生的覆盖度相关的强度量的函数，与小覆盖度展开和周期性镜像相互作用一致，且不假设任何特定的微观相互作用势。\n- 实现两个候选模型：小参数的一阶截断和二阶截断模型，使用最小二乘法将两个模型与数据进行拟合，并通过一个惩罚复杂度的客观标准选择更优的模型。\n- 对于每个提供的数据集，外推稀释极限下的结合能，并量化在最小超胞处的有限尺寸误差。\n\n物理单位与惯例：\n- 面积$A$必须以平方埃$\\text{\\AA}^2$为单位处理。\n- 能量$E_{\\text{ads}}$必须以电子伏特 (eV) 为单位处理。\n- 覆盖度$\\theta$是单位面积的吸附质数量，单位为$\\text{adsorbates}/\\text{\\AA}^2$，在每个超胞含一个吸附质且覆盖度不为零的情况下，$\\theta = 1/A$。\n\n数值任务：\n- 对于每个数据集，将两个候选模型与测量的$E_{\\text{ads}}$值进行拟合，作为由给定面积所隐含的、与覆盖度相关的适当强度量的函数。\n- 使用最小二乘法获得模型参数，计算残差均方根误差，并使用惩罚参数数量的客观标准进行模型选择。如果两个模型在数值容差范围内同样充分，则选择参数较少的模型。\n- 通过在零覆盖度（无限面积）下评估拟合模型，外推稀释极限结合能$E_{\\infty}$。\n- 计算最小超胞处的有限尺寸误差，定义为$\\Delta = E_{\\text{ads}}(A_{\\min}) - E_{\\infty}$。\n- 所有能量以 eV 表示，四舍五入到四位小数。\n\n测试集（面积单位为$\\text{\\AA}^2$，能量单位为 eV，每个超胞含一个吸附质）：\n- 情况 $1$（单调趋近稀释极限）：\n  - $A$: $\\{96, 144, 216, 384\\}$\n  - $E_{\\text{ads}}$: $\\{-0.2395833, -0.3263889, -0.3842593, -0.4348958\\}$\n- 情况 $2$（有限尺寸标度中存在显著曲率）：\n  - $A$: $\\{100, 150, 300, 600\\}$\n  - $E_{\\text{ads}}$: $\\{0.2800, -0.0800, -0.2900, -0.355556\\}$\n- 情况 $3$（有限尺寸效应可忽略不计）：\n  - $A$: $\\{64, 128, 256\\}$\n  - $E_{\\text{ads}}$: $\\{-0.6000, -0.6000, -0.6000\\}$\n\n最终输出规格：\n- 对于每种情况，生成一个包含三个条目的列表：$[E_{\\infty}, M, \\Delta]$，其中$E_{\\infty}$是外推的稀释极限结合能，单位为 eV，四舍五入到四位小数；$M$是所选模型阶数，为整数（$1$代表一阶截断，$2$代表二阶截断）；$\\Delta$是在$A_{\\min}$处的有限尺寸误差，单位为 eV，四舍五入到四位小数。\n- 您的程序应生成一行输出，其中包含一个由方括号括起来的逗号分隔列表，按顺序为每种情况提供一个三元列表：$[\\,[E_{\\infty}^{(1)}, M^{(1)}, \\Delta^{(1)}], [E_{\\infty}^{(2)}, M^{(2)}, \\Delta^{(2)}], [E_{\\infty}^{(3)}, M^{(3)}, \\Delta^{(3)}]\\,]$。",
            "solution": "该问题要求将使用密度泛函理论 (DFT) 在周期性边界条件下计算的吸附质结合能$E_{\\text{ads}}$外推至无限超胞面积极限$A \\to \\infty$。此过程旨在校正由吸附质与其周期性镜像之间虚假的横向相互作用引起的有限尺寸误差。该方法包括：推导一个物理上合理的$E_{\\text{ads}}$关于超胞面积的渐近模型，将候选模型与所提供的数据进行拟合，选择最合适的模型，并用它来确定稀释极限下的结合能$E_{\\infty}$。\n\n**1. 渐近模型的推导**\n\n在有限面积$A$的超胞中，结合能是无限稀释时的真实结合能$E_{\\infty}$与一个相互作用能项$\\Delta E_{\\text{int}}(A)$的和，后者表示一个吸附质与所有其周期性镜像的相互作用总和。\n$$\nE_{\\text{ads}}(A) = E_{\\infty} + \\Delta E_{\\text{int}}(A)\n$$\n问题指定吸附质为中性，并假设横向相互作用是短程的。这种物理情况允许能量对与吸附质密度相关的小参数进行系统性展开。在每个超胞含一个吸附质的周期性超胞计算中，表面覆盖度$\\theta$（定义为单位面积的吸附质数量）由$\\theta = 1/A$给出。当超胞面积$A$变大时，覆盖度$\\theta$变小，可作为展开的自然小参数。\n\n因此，我们可以将$E_{\\text{ads}}$表示为在$\\theta = 0$附近的泰勒级数：\n$$\nE_{\\text{ads}}(\\theta) = E_{\\text{ads}}|_{\\theta=0} + \\left.\\frac{dE_{\\text{ads}}}{d\\theta}\\right|_{\\theta=0} \\theta + \\frac{1}{2!} \\left.\\frac{d^2E_{\\text{ads}}}{d\\theta^2}\\right|_{\\theta=0} \\theta^2 + \\mathcal{O}(\\theta^3)\n$$\n根据定义，项$E_{\\text{ads}}|_{\\theta=0}$是稀释极限下的结合能$E_{\\infty}$。导数是常数，代表了在表面上积分得到的双体、三体及更高阶相互作用的主导贡献。我们将此展开的系数表示为$c_1$和$c_2$。\n$$\nE_{\\text{ads}}(\\theta) = E_{\\infty} + c_1 \\theta + c_2 \\theta^2 + \\mathcal{O}(\\theta^3)\n$$\n代入$\\theta = 1/A$，我们得到$E_{\\text{ads}}$作为超胞面积$A$的函数的渐近模型：\n$$\nE_{\\text{ads}}(A) = E_{\\infty} + \\frac{c_1}{A} + \\frac{c_2}{A^2} + \\mathcal{O}(A^{-3})\n$$\n此展开式提供了将有限面积数据外推至$A \\to \\infty$极限（此时$1/A \\to 0$）的函数形式。\n\n**2. 候选模型与最小二乘拟合**\n\n问题要求我们考虑该级数的一阶和二阶截断。设自变量为$x = 1/A$，因变量为$y = E_{\\text{ads}}$。\n\n**模型 1 (M=1)：一阶截断**\n该模型在$x = 1/A$上是线性的。它有$p_1 = 2$个参数：截距$E_{\\infty}$和斜率$c_1$。\n$$\ny(x) = c_1 x + E_{\\infty}\n$$\n\n**模型 2 (M=2)：二阶截断**\n该模型在$x = 1/A$上是二次的。它有$p_2 = 3$个参数：$E_{\\infty}$、$c_1$和$c_2$。\n$$\ny(x) = c_2 x^2 + c_1 x + E_{\\infty}\n$$\n对于每个数据集，我们使用最小二乘法将两个模型与数据点$(x_i, y_i) = (1/A_i, E_{\\text{ads},i})$进行拟合，以确定模型 1 的最优参数$\\{E_{\\infty}, c_1\\}$和模型 2 的最优参数$\\{E_{\\infty}, c_1, c_2\\}$。\n\n**3. 模型选择**\n\n为了在两个模型之间进行选择，我们必须使用一个惩罚复杂度的客观标准，以防止过拟合。一个合适的度量是残差标准误$s_k$，它是约化卡方统计量的平方根。它是残差标准差的无偏估计量。\n$$\ns_k = \\sqrt{\\frac{RSS_k}{N - p_k}}\n$$\n这里，$RSS_k = \\sum_{i=1}^{N} (y_i - y_{\\text{fit},i})^2$是模型$k$的残差平方和，$N$是数据点数量，$p_k$是模型中的参数数量。项$N - p_k$代表自由度。较低的$s_k$值表示经模型复杂度调整后拟合效果更好。\n\n选择程序如下：\n- 我们分别为模型 1 和模型 2 计算$s_1$和$s_2$。\n- 对于具有$N > 3$个数据点的数据集，$s_1$和$s_2$均有明确定义。我们选择具有较小$s_k$值的模型。\n- 对于具有$N = 3$个点的数据集，模型 2 有$p_2 = 3$个参数，剩下$N-p_2 = 0$个自由度。该模型将完美拟合这三个点，导致$RSS_2 = 0$，使得$s_2$变得无定义。在这种情况下，我们必须依赖平局决胜规则：如果两个模型同样充分，则选择较简单的模型。如果模型 1 也提供了完美或接近完美的拟合（$RSS_1 \\approx 0$，导致$s_1 \\approx 0$），则认为它“同样充分”，并因其简约性而被选中。如果模型 1 拟合不佳（$RSS_1$很大），则数据必有显著曲率，应选择模型 2。\n\n**4. 外推能量与有限尺寸误差的计算**\n\n一旦选定最优模型（阶数$M$），稀释极限结合能$E_{\\infty}$即为拟合的截距（零阶多项式系数）。\n\n在最小超胞面积$A_{\\min}$处的有限尺寸误差$\\Delta$定义为该面积下测得的能量与无限面积下外推能量之差。\n$$\n\\Delta = E_{\\text{ads}}(A_{\\min}) - E_{\\infty}\n$$\n$E_{\\text{ads}}(A_{\\min})$是输入数据集中对应于最小面积$A_{\\min}$的能量值。所有最终能量值均以 eV 报告，四舍五入到四位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DFT finite-size correction problem for a series of test cases.\n    \"\"\"\n    # Test suite (areas in Å^2, energies in eV)\n    test_cases = [\n        {\n            \"A\": np.array([96.0, 144.0, 216.0, 384.0]),\n            \"E_ads\": np.array([-0.2395833, -0.3263889, -0.3842593, -0.4348958]),\n        },\n        {\n            \"A\": np.array([100.0, 150.0, 300.0, 600.0]),\n            \"E_ads\": np.array([0.2800, -0.0800, -0.2900, -0.355556]),\n        },\n        {\n            \"A\": np.array([64.0, 128.0, 256.0]),\n            \"E_ads\": np.array([-0.6000, -0.6000, -0.6000]),\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        A_vals = case[\"A\"]\n        E_ads_vals = case[\"E_ads\"]\n        \n        # The independent variable for the fit is x = 1/A\n        x_vals = 1.0 / A_vals\n        y_vals = E_ads_vals\n        \n        N = len(x_vals)\n        \n        # --- Fit Model 1 (linear, M=1) ---\n        # y = c1*x + E_inf. p1 = [c1, E_inf]\n        p1 = np.polyfit(x_vals, y_vals, 1)\n        E_inf_1 = p1[1]\n        y_fit_1 = np.polyval(p1, x_vals)\n        rss1 = np.sum((y_vals - y_fit_1)**2)\n        p_1 = 2 # Number of parameters in Model 1\n        dof1 = N - p_1\n        \n        s1 = np.inf\n        if dof1 > 0:\n            s1 = np.sqrt(rss1 / dof1)\n\n        # --- Fit Model 2 (quadratic, M=2) ---\n        # y = c2*x^2 + c1*x + E_inf. p2 = [c2, c1, E_inf]\n        p2 = np.polyfit(x_vals, y_vals, 2)\n        E_inf_2 = p2[2]\n        y_fit_2 = np.polyval(p2, x_vals)\n        rss2 = np.sum((y_vals - y_fit_2)**2)\n        p_2 = 3 # Number of parameters in Model 2\n        dof2 = N - p_2\n\n        s2 = np.inf\n        if dof2 > 0:\n            s2 = np.sqrt(rss2 / dof2)\n\n        # --- Model Selection ---\n        chosen_M = 0\n        chosen_E_inf = 0.0\n        \n        if N  p_1: # Not enough points for even model 1\n             # This case is not in the test suite but is good practice\n             # Default to simplest model if possible, otherwise invalid\n             chosen_M = 1\n             chosen_E_inf = E_inf_1\n\n        elif N  p_2: # N=3, enough for M1 but M2 is exact interpolation\n            # dof2 is 0, so s2 is not well-defined.\n            # M2 fits perfectly (rss2=0). If M1 also fits nearly perfectly (rss1~0),\n            # choose M1 for parsimony. Otherwise, the data is curved, so choose M2.\n            if np.isclose(rss1, 0.0):\n                chosen_M = 1\n                chosen_E_inf = E_inf_1\n            else:\n                chosen_M = 2\n                chosen_E_inf = E_inf_2\n        else: # N > 3, both s1 and s2 are well-defined\n            # Choose the model with the lower residual standard error (s_k)\n            if s1 = s2:\n                chosen_M = 1\n                chosen_E_inf = E_inf_1\n            else:\n                chosen_M = 2\n                chosen_E_inf = E_inf_2\n                \n        # --- Calculate Finite-Size Error ---\n        A_min = np.min(A_vals)\n        E_at_Amin = y_vals[np.argmin(A_vals)]\n        \n        Delta = E_at_Amin - chosen_E_inf\n        \n        # Format results to 4 decimal places\n        E_inf_rounded = round(chosen_E_inf, 4)\n        Delta_rounded = round(Delta, 4)\n\n        # Handle negative zero for formatting consistency\n        if E_inf_rounded == -0.0: E_inf_rounded = 0.0\n        if Delta_rounded == -0.0: Delta_rounded = 0.0\n\n        result_list = [E_inf_rounded, chosen_M, Delta_rounded]\n        results.append(result_list)\n        \n    # Format final output string as a list of lists.\n    # str(list) provides the required '[...]' formatting for each inner list.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "直接从DFT计算中获得的吸附能通常对应于真空或气相环境，要将其与真实的电化学条件联系起来，需要引入热力学模型。计算氢电极（Computational Hydrogen Electrode, CHE）模型是实现这一目标的核心工具，它能够将吸附自由能与电极电势$U$和溶液pH值关联起来。本实践将以OH*吸附为例，向你展示如何计算一个电化学反应的吸附自由能，并分析其如何随电化学环境的变化而改变。",
            "id": "4241853",
            "problem": "您的任务是构建一个完整的计算方案，并以可运行程序的形式表达，用以计算羟基在表面上的吸附自由能$E_{\\text{ads}}$ ($\\mathrm{OH^*}$)。计算中需使用水分子$\\mathrm{H_2O}$和氢分子$\\mathrm{H_2}$在密度泛函理论 (DFT) 水平下的能量作为参考。同时，您需要将这些结果与在指定电极电势和酸度下通过计算氢电极 (CHE) 框架获得的结果进行比较。该程序必须从第一性原理出发实现此方案，而非调用现成公式，并且必须按照下述严格定义的格式输出结果。\n\n使用的基础原理：\n- 一个物种的热力学自由能为$G = E_{\\text{elec}} + E_{\\text{ZPE}} - T S$，其中$E_{\\text{elec}}$是电子能量，$E_{\\text{ZPE}}$是零点能，$T$是绝对温度，$S$是熵。\n- 待考虑的吸附反应为$\\mathrm{H_2O(l)} + * \\rightarrow \\mathrm{OH^*} + \\mathrm{H^+} + \\mathrm{e^-}$，其中$*$表示一个空的表面位点。在标准条件下，初始态和最终态自由能的化学计量组合定义了相对于$\\mathrm{H_2O}$和$\\mathrm{H_2}$参考物的吸附自由能。\n- 在计算氢电极 (CHE) 框架中，质子-电子对的化学势由其在给定电极电势和酸度 (pH) 下与分子氢的平衡决定。您必须在有限温度下，使用玻尔兹曼统计一致地引入电极电势和 pH 的影响，其中会出现热因子$k_B T$，$k_B$为玻尔兹曼常数。\n\n使用的热力学和物理常数：\n- 温度$T = 298.15$ K。\n- 玻尔兹曼常数$k_B = 8.617333262145\\times 10^{-5}$ eV/K。\n- 10的自然对数$\\ln(10)$。\n- 阿伏伽德罗常数$N_A = 6.02214076\\times 10^{23}$ mol$^{-1}$。\n- 元电荷$e = 1.602176634\\times 10^{-19}$ C。\n- 当将摩尔熵转换为单粒子能量单位时，使用单位为$\\mathrm{J/mol}$的$T S$，通过除以$N_A$转换为每个粒子的能量（单位为$\\mathrm{J}$），然后通过除以$e$转换为$\\mathrm{eV}$。\n\n方案要求：\n1. 使用给定的 DFT 电子能量、零点能和摩尔熵，计算自由能$G(\\mathrm{H_2})$和$G(\\mathrm{H_2O})$。所有能量和输出必须以电子伏特 (eV) 为单位报告。\n2. 对于表面，根据给定的带$\\mathrm{OH^*}$的平板和裸平板的 DFT 电子能量，计算$G(\\mathrm{OH^*}) - G(*)$，包括吸附羟基的零点能和熵（假设吸附羟基的熵可忽略不计，取$S(\\mathrm{OH^*}) = 0 \\ \\text{J/mol/K}$）。\n3. 构建在标准条件下（相对于可逆氢电极为$U = 0 \\ \\text{V}$，$\\mathrm{pH} = 0$）相对于$\\mathrm{H_2O}$和$\\mathrm{H_2}$参考物的吸附自由能，记为$E_{\\text{ads}}^{\\mathrm{ref0}}$。\n4. 使用 CHE 框架，通过将质子-电子化学势替换为在指定$U$和$\\mathrm{pH}$下其与$\\mathrm{H_2}$的平衡形式，来调整吸附自由能以适应有限的$U$和$\\mathrm{pH}$，从而得到$E_{\\text{ads}}^{\\mathrm{CHE}}(U,\\mathrm{pH})$。确保对$U$和$\\mathrm{pH}$的依赖性通过适用于酸度的$k_B T$和$\\ln(10)$正确地引入。\n5. 所有最终数值答案必须是浮点数，单位为 eV，并四舍五入到三位小数。\n\n此任务不涉及角度单位。\n\n测试套件：\n对于每个测试用例，给定 DFT 电子能量$E_{\\text{DFT}}$ (单位 eV)，零点能$E_{\\text{ZPE}}$ (单位 eV)，摩尔熵$S$ (单位 J/mol/K)，以及电化学状态（$U$单位 V，$\\mathrm{pH}$）。对于所有情况，均假设$S(\\mathrm{OH^*}) = 0 \\ \\text{J/mol/K}$。对于所有情况，温度均为$T = 298.15$ K。\n\n- 测试用例 1 (正常路径；等式检查):\n  - $E_{\\text{DFT}}(\\text{slab}) = -100.000$ eV\n  - $E_{\\text{DFT}}(\\text{slab}+\\mathrm{OH^*}) = -101.180$ eV\n  - $E_{\\text{DFT}}(\\mathrm{H_2O}) = -0.560$ eV, $E_{\\text{ZPE}}(\\mathrm{H_2O}) = 0.560$ eV, $S(\\mathrm{H_2O}) = 69.95$ J/mol/K\n  - $E_{\\text{DFT}}(\\mathrm{H_2}) = -0.270$ eV, $E_{\\text{ZPE}}(\\mathrm{H_2}) = 0.270$ eV, $S(\\mathrm{H_2}) = 130.68$ J/mol/K\n  - $E_{\\text{ZPE}}(\\mathrm{OH^*}) = 0.360$ eV\n  - $U = 0.0$ V, $\\mathrm{pH} = 0.0$\n- 测试用例 2 (边界电位；酸性):\n  - $E_{\\text{DFT}}(\\text{slab}) = -220.000$ eV\n  - $E_{\\text{DFT}}(\\text{slab}+\\mathrm{OH^*}) = -221.050$ eV\n  - $E_{\\text{DFT}}(\\mathrm{H_2O}) = -0.600$ eV, $E_{\\text{ZPE}}(\\mathrm{H_2O}) = 0.560$ eV, $S(\\mathrm{H_2O}) = 69.95$ J/mol/K\n  - $E_{\\text{DFT}}(\\mathrm{H_2}) = -0.310$ eV, $E_{\\text{ZPE}}(\\mathrm{H_2}) = 0.270$ eV, $S(\\mathrm{H_2}) = 130.68$ J/mol/K\n  - $E_{\\text{ZPE}}(\\mathrm{OH^*}) = 0.360$ eV\n  - $U = 1.23$ V, $\\mathrm{pH} = 0.0$\n- 测试用例 3 (碱性；中等电位):\n  - $E_{\\text{DFT}}(\\text{slab}) = -150.000$ eV\n  - $E_{\\text{DFT}}(\\text{slab}+\\mathrm{OH^*}) = -150.650$ eV\n  - $E_{\\text{DFT}}(\\mathrm{H_2O}) = -0.580$ eV, $E_{\\text{ZPE}}(\\mathrm{H_2O}) = 0.560$ eV, $S(\\mathrm{H_2O}) = 69.95$ J/mol/K\n  - $E_{\\text{DFT}}(\\mathrm{H_2}) = -0.280$ eV, $E_{\\text{ZPE}}(\\mathrm{H_2}) = 0.270$ eV, $S(\\mathrm{H_2}) = 130.68$ J/mol/K\n  - $E_{\\text{ZPE}}(\\mathrm{OH^*}) = 0.360$ eV\n  - $U = 0.50$ V, $\\mathrm{pH} = 13.0$\n- 测试用例 4 (弱吸附；负电位；中性pH):\n  - $E_{\\text{DFT}}(\\text{slab}) = -180.000$ eV\n  - $E_{\\text{DFT}}(\\text{slab}+\\mathrm{OH^*}) = -180.100$ eV\n  - $E_{\\text{DFT}}(\\mathrm{H_2O}) = -0.620$ eV, $E_{\\text{ZPE}}(\\mathrm{H_2O}) = 0.560$ eV, $S(\\mathrm{H_2O}) = 69.95$ J/mol/K\n  - $E_{\\text{DFT}}(\\mathrm{H_2}) = -0.290$ eV, $E_{\\text{ZPE}}(\\mathrm{H_2}) = 0.270$ eV, $S(\\mathrm{H_2}) = 130.68$ J/mol/K\n  - $E_{\\text{ZPE}}(\\mathrm{OH^*}) = 0.360$ eV\n  - $U = -0.10$ V, $\\mathrm{pH} = 7.0$\n\n每个测试用例的任务：\n- 使用反应$\\mathrm{H_2O(l)} + * \\rightarrow \\mathrm{OH^*} + \\mathrm{H^+} + \\mathrm{e^-}$推导出的化学计量自由能，通过将质子-电子对与$\\mathrm{H_2}$和$\\mathrm{H_2O}$关联消除，计算在$U = 0 \\ \\text{V}$和$\\mathrm{pH} = 0$下的吸附自由能$E_{\\text{ads}}^{\\mathrm{ref0}}$ (单位 eV)。\n- 通过有限温度化学势引入 CHE 对$U$和$\\mathrm{pH}$的依赖性，计算$E_{\\text{ads}}^{\\mathrm{CHE}}(U,\\mathrm{pH})$ (单位 eV)。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含每个测试用例的两个浮点数$[E_{\\text{ads}}^{\\mathrm{ref0}}, E_{\\text{ads}}^{\\mathrm{CHE}}]$，四舍五入到三位小数，并合并到所有测试用例的单个列表中。例如，输出应类似于$[r_{1,\\mathrm{ref0}}, r_{1,\\mathrm{CHE}}, r_{2,\\mathrm{ref0}}, r_{2,\\mathrm{CHE}}, \\dots]$，其中每个$r$的单位为 eV。",
            "solution": "该问题具有科学依据，表述清晰且客观。它概述了计算电化学中的一个标准方案（计算氢电极模型），并使用了基本的热力学原理。所提供的数据、常数和反应是一致且充分的，足以推导出一个唯一且有意义的解。因此，该问题是有效的。\n\n计算方案从第一性原理构建如下。\n\n1. 单个物种的自由能\n任何物种的吉布斯自由能$G$由其电子能量$E_{\\text{elec}}$、零点振动能$E_{\\text{ZPE}}$和在给定温度$T$下的熵$S$给出：\n$$ G = E_{\\text{elec}} + E_{\\text{ZPE}} - T S $$\n电子能量$E_{\\text{elec}}$取自密度泛函理论 (DFT) 的计算能量$E_{\\text{DFT}}$。为保持一致性，所有能量都必须以电子伏特 ($\\mathrm{eV}$) 为单位。问题提供了单位为$\\mathrm{J/mol/K}$的摩尔熵$S$。熵贡献项$TS$必须从$\\mathrm{J/mol}$转换为$\\mathrm{eV}$。此转换通过除以阿伏伽德罗常数$N_A$得到单位为焦耳的单粒子能量，然后除以元电荷$e$得到单位为$\\mathrm{eV}$的能量：\n$$ TS \\ [\\mathrm{eV}] = \\frac{T S \\ [\\mathrm{J/mol}]}{N_A e} $$\n其中$N_A e$是法拉第常数$F$。\n\n因此，参考分子水 ($\\mathrm{H_2O}$) 和氢气 ($\\mathrm{H_2}$) 的自由能为：\n$$ G(\\mathrm{H_2O}) = E_{\\text{DFT}}(\\mathrm{H_2O}) + E_{\\text{ZPE}}(\\mathrm{H_2O}) - \\frac{T S(\\mathrm{H_2O})}{N_A e} $$\n$$ G(\\mathrm{H_2}) = E_{\\text{DFT}}(\\mathrm{H_2}) + E_{\\text{ZPE}}(\\mathrm{H_2}) - \\frac{T S(\\mathrm{H_2})}{N_A e} $$\n\n2. 吸附态的自由能\n表面上羟基吸附物$\\mathrm{OH^*}$的自由能是相对于裸表面（表示为$*$）计算的。此相对自由能是带有吸附物的平板的自由能与裸平板的自由能之差：\n$$ G(\\mathrm{OH^*}) - G(*) = [G(\\text{slab}+\\mathrm{OH^*})] - [G(\\text{slab})] $$\n$$ G(\\mathrm{OH^*}) - G(*) = (E_{\\text{DFT}}(\\text{slab}+\\mathrm{OH^*}) - E_{\\text{DFT}}(\\text{slab})) + (E_{\\text{ZPE}}(\\text{slab}+\\mathrm{OH^*}) - E_{\\text{ZPE}}(\\text{slab})) - T(S(\\text{slab}+\\mathrm{OH^*}) - S(\\text{slab})) $$\n振动贡献仅限于吸附物，因此$E_{\\text{ZPE}}(\\text{slab}+\\mathrm{OH^*}) - E_{\\text{ZPE}}(\\text{slab}) = E_{\\text{ZPE}}(\\mathrm{OH^*})$。问题指明忽略吸附羟基的熵，$S(\\mathrm{OH^*}) = 0 \\ \\text{J/mol/K}$，这是一种常见的近似方法，将熵项简化为零。因此，吸附物的相对自由能为：\n$$ G(\\mathrm{OH^*}) - G(*) = (E_{\\text{DFT}}(\\text{slab}+\\mathrm{OH^*}) - E_{\\text{DFT}}(\\text{slab})) + E_{\\text{ZPE}}(\\mathrm{OH^*}) $$\n\n3. 标准条件下的吸附自由能 ($E_{\\text{ads}}^{\\mathrm{ref0}}$)\n吸附反应为：\n$$ \\mathrm{H_2O(l)} + * \\rightarrow \\mathrm{OH^*} + \\mathrm{H^+} + \\mathrm{e^-} $$\n该反应的自由能变化$\\Delta G_{\\text{ads}}$是产物自由能与反应物自由能之差：\n$$ \\Delta G_{\\text{ads}} = (G(\\mathrm{OH^*}) - G(*)) + \\mu(\\mathrm{H^+}) + \\mu(\\mathrm{e^-}) - G(\\mathrm{H_2O}) $$\n其中$\\mu$表示化学势。\n计算氢电极 (CHE) 模型将质子-电子对的化学势$\\mu(\\mathrm{H^+}) + \\mu(\\mathrm{e^-})$设置为在压力$p=1 \\ \\text{bar}$下与分子氢处于平衡状态：\n$$ \\mathrm{H^+} + \\mathrm{e^-} \\rightleftharpoons \\frac{1}{2}\\mathrm{H_2(g)} $$\n在标准条件下（$U=0 \\ \\text{V}$ vs. RHE, $\\mathrm{pH}=0$），此平衡规定一个质子-电子对的化学势与半个氢分子的化学势相同：\n$$ \\mu(\\mathrm{H^+}) + \\mu(\\mathrm{e^-}) = \\frac{1}{2}G(\\mathrm{H_2}) $$\n将此代入$\\Delta G_{\\text{ads}}$的表达式，得到标准条件下的吸附自由能，问题中记为$E_{\\text{ads}}^{\\mathrm{ref0}}$：\n$$ E_{\\text{ads}}^{\\mathrm{ref0}} = \\Delta G_{\\text{ads}}(U=0, \\mathrm{pH}=0) = (G(\\mathrm{OH^*}) - G(*)) + \\frac{1}{2}G(\\mathrm{H_2}) - G(\\mathrm{H_2O}) $$\n\n4. 有限电势和酸度下的吸附自由能 ($E_{\\text{ads}}^{\\mathrm{CHE}}$)\n为了求得在任意电极电势$U$和$\\mathrm{pH}$下的吸附自由能，我们必须调整质子-电子对的化学势。相对于标准氢电极，电子的化学势偏移了$-eU$。质子的化学势从其标准态（活度$a_{\\mathrm{H^+}}=1$）偏移了一个与浓度相关的项。$\\mathrm{pH}$定义为$\\mathrm{pH} = -\\log_{10}(a_{\\mathrm{H^+}})$，这意味着$\\ln(a_{\\mathrm{H^+}}) = -\\mathrm{pH}\\ln(10)$。\n该对的总化学势变为：\n$$ \\mu(\\mathrm{H^+}) + \\mu(\\mathrm{e^-}) = \\frac{1}{2}G(\\mathrm{H_2}) - eU + k_B T \\ln(a_{\\mathrm{H^+}}) $$\n$$ \\mu(\\mathrm{H^+}) + \\mu(\\mathrm{e^-}) = \\frac{1}{2}G(\\mathrm{H_2}) - eU - k_B T \\ln(10) \\times \\mathrm{pH} $$\n此处，如果$U$的单位是伏特，则项$eU$的单位是$\\mathrm{eV}$，因此在计算中我们可以简单地减去$U$的数值。项$k_B T$是以$\\mathrm{eV}$为单位的热能。\n将这个调整后的化学势代入$\\Delta G_{\\text{ads}}$的表达式中，得到$E_{\\text{ads}}^{\\mathrm{CHE}}(U, \\mathrm{pH})$：\n$$ E_{\\text{ads}}^{\\mathrm{CHE}}(U, \\mathrm{pH}) = (G(\\mathrm{OH^*}) - G(*)) + \\left( \\frac{1}{2}G(\\mathrm{H_2}) - U - k_B T \\ln(10) \\times \\mathrm{pH} \\right) - G(\\mathrm{H_2O}) $$\n通过与$E_{\\text{ads}}^{\\mathrm{ref0}}$的表达式进行比较，我们得到最终关系式：\n$$ E_{\\text{ads}}^{\\mathrm{CHE}}(U, \\mathrm{pH}) = E_{\\text{ads}}^{\\mathrm{ref0}} - U - k_B T \\ln(10) \\times \\mathrm{pH} $$\n程序将对每个测试用例实施这些方程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the adsorption free energy of hydroxyl on a surface using DFT-level energies\n    and the Computational Hydrogen Electrode (CHE) framework.\n    \"\"\"\n\n    # Thermodynamic and physical constants\n    T = 298.15  # Temperature in Kelvin\n    KB = 8.617333262145e-5  # Boltzmann constant in eV/K\n    NA = 6.02214076e23  # Avogadro's number in mol^-1\n    E_CHARGE = 1.602176634e-19  # Elementary charge in C\n    LN_10 = np.log(10) # Natural logarithm of 10\n\n    # Faraday constant in C/mol, for unit conversion\n    FARADAY_CONSTANT = NA * E_CHARGE\n\n    # Test suite from the problem statement\n    test_cases = [\n        # Test Case 1\n        {\n            \"E_dft_slab\": -100.000, \"E_dft_slab_OH\": -101.180,\n            \"E_dft_h2o\": -0.560, \"E_zpe_h2o\": 0.560, \"S_h2o\": 69.95,\n            \"E_dft_h2\": -0.270, \"E_zpe_h2\": 0.270, \"S_h2\": 130.68,\n            \"E_zpe_oh\": 0.360, \"S_oh\": 0.0,\n            \"U\": 0.0, \"pH\": 0.0\n        },\n        # Test Case 2\n        {\n            \"E_dft_slab\": -220.000, \"E_dft_slab_OH\": -221.050,\n            \"E_dft_h2o\": -0.600, \"E_zpe_h2o\": 0.560, \"S_h2o\": 69.95,\n            \"E_dft_h2\": -0.310, \"E_zpe_h2\": 0.270, \"S_h2\": 130.68,\n            \"E_zpe_oh\": 0.360, \"S_oh\": 0.0,\n            \"U\": 1.23, \"pH\": 0.0\n        },\n        # Test Case 3\n        {\n            \"E_dft_slab\": -150.000, \"E_dft_slab_OH\": -150.650,\n            \"E_dft_h2o\": -0.580, \"E_zpe_h2o\": 0.560, \"S_h2o\": 69.95,\n            \"E_dft_h2\": -0.280, \"E_zpe_h2\": 0.270, \"S_h2\": 130.68,\n            \"E_zpe_oh\": 0.360, \"S_oh\": 0.0,\n            \"U\": 0.50, \"pH\": 13.0\n        },\n        # Test Case 4\n        {\n            \"E_dft_slab\": -180.000, \"E_dft_slab_OH\": -180.100,\n            \"E_dft_h2o\": -0.620, \"E_zpe_h2o\": 0.560, \"S_h2o\": 69.95,\n            \"E_dft_h2\": -0.290, \"E_zpe_h2\": 0.270, \"S_h2\": 130.68,\n            \"E_zpe_oh\": 0.360, \"S_oh\": 0.0,\n            \"U\": -0.10, \"pH\": 7.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Step 1: Compute free energies G = E_elec + E_ZPE - T*S\n        \n        # Free energy of H2O\n        ts_h2o_ev = (T * case[\"S_h2o\"]) / FARADAY_CONSTANT\n        g_h2o = case[\"E_dft_h2o\"] + case[\"E_zpe_h2o\"] - ts_h2o_ev\n        \n        # Free energy of H2\n        ts_h2_ev = (T * case[\"S_h2\"]) / FARADAY_CONSTANT\n        g_h2 = case[\"E_dft_h2\"] + case[\"E_zpe_h2\"] - ts_h2_ev\n        \n        # Step 2: Compute relative free energy of adsorbed OH*\n        # G(OH*) - G(*) = (E_DFT(slab+OH*) - E_DFT(slab)) + E_ZPE(OH*) - T*S(OH*)\n        # S(OH*) is assumed to be 0.\n        g_oh_rel = (case[\"E_dft_slab_OH\"] - case[\"E_dft_slab\"]) + case[\"E_zpe_oh\"]\n\n        # Step 3: Compute adsorption free energy at standard conditions (U=0, pH=0)\n        # E_ads^ref0 = (G(OH*) - G(*)) + 0.5*G(H2) - G(H2O)\n        e_ads_ref0 = g_oh_rel + 0.5 * g_h2 - g_h2o\n\n        # Step 4: Compute adsorption free energy at given U and pH using CHE\n        # E_ads^CHE = E_ads^ref0 - U - k_B*T*ln(10)*pH\n        ph_correction = KB * T * LN_10 * case[\"pH\"]\n        e_ads_che = e_ads_ref0 - case[\"U\"] - ph_correction\n        \n        # Step 5: Round results to three decimal places and append\n        results.append(round(e_ads_ref0, 3))\n        results.append(round(e_ads_che, 3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.3f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}