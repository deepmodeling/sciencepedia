{
    "hands_on_practices": [
        {
            "introduction": "密度泛函理论（DFT）计算的可靠性在很大程度上取决于关键数值参数的正确选择。本练习将指导您完成一个基本但至关重要的工作流程：为平面波 DFT 计算建立一个系统性的收敛测试协议。通过使用一个基于物理原理的误差模型，您将学习如何量化平面波截止能 $E_{\\text{cut}}$ 和实空间网格密度对计算出的吸附能的影响，并确定达到预定精度所需的最小参数值 。掌握此协议对于确保您的计算结果在数值上稳健、可复现，并具有物理意义至关重要。",
            "id": "4241951",
            "problem": "要求您设计并实现一个完整、可运行的程序。该程序需基于第一性原理定义以及平面波密度泛函理论 (DFT) 中广泛接受的数值误差行为，分析平面波基组截断能和实空间网格密度如何影响计算得到的吸附能，并为平面波截断能构建一个系统性的收敛方案。吸附在表面上的吸附质的吸附能定义为总能量之差，即 $E_{\\text{ads}} = E_{\\text{slab+ads}} - E_{\\text{slab}} - E_{\\text{adsorbate}}$，其中每个总能量都通过平面波DFT方法计算。在平面波方法中，平面波基组的截断由一个能量截断参数 $E_{\\text{cut}}$ 控制，该参数设定了平面波基组的最大倒易空间矢量大小。用于表示电荷密度和势的实空间网格通过一个特征网格间距 $h$ 与最大倒易空间频率相关。在与周期函数的傅里叶分析一致的最简单理想化情况下，所包含的最大倒易空间矢量大小满足 $G_{\\max} \\propto \\sqrt{E_{\\text{cut}}}$，而一个代表性的实空间网格间距则成反比关系 $h \\propto \\frac{1}{G_{\\max}}$。引入一个无量纲的网格密度因子 $s \\geq 1$ 来调整倒易空间的分辨率（较大的 $s$ 意味着更密的实空间网格），我们采用关系式 $h(E_{\\text{cut}},s) = \\frac{\\alpha}{\\sqrt{E_{\\text{cut}}}\\, s}$，其中 $\\alpha$ 是本研究中固定的一个正常数。\n\n与足够光滑函数的傅里叶表示的截断和离散化误差理论一致，我们假设每个总能量（带吸附质的板、单独的板、单独的吸附质）的主阶数值误差是两个正贡献项之和：一个随 $E_{\\text{cut}}$ 按幂律衰减的基组截断误差，以及一个随 $h$ 按幂律衰减的网格离散化误差。对于实体 $X \\in \\{\\text{slab+ads}, \\text{slab}, \\text{adsorbate}\\}$，我们将计算得到的总能量建模为\n$$\nE_X(E_{\\text{cut}}, s) = E_X^{\\text{true}} + B_X\\, E_{\\text{cut}}^{-p_X} + G_X\\, h(E_{\\text{cut}},s)^{q_X},\n$$\n其中 $E_X^{\\text{true}}$ 是真实总能量，$B_X$ 和 $G_X$ 是正常数误差前置因子，$p_X > 0$ 和 $q_X > 0$ 是收敛指数。吸附能则根据上述定义以及在形成能量差时某些误差的抵消而得出：\n$$\nE_{\\text{ads}}(E_{\\text{cut}},s) = E_{\\text{slab+ads}}(E_{\\text{cut}},s) - E_{\\text{slab}}(E_{\\text{cut}},s) - E_{\\text{adsorbate}}(E_{\\text{cut}},s).\n$$\n在本编程挑战中，您将使用上述误差模型生成合成数据，然后实现一个收敛方案。该收敛方案必须：\n- 通过将最密网格 $s_{\\max}$ 下的 $E_{\\text{ads}}(E_{\\text{cut}}, s_{\\max})$ 拟合到形式为\n$$\nE_{\\text{ads}}(E_{\\text{cut}}, s_{\\max}) \\approx E_{\\text{ads}}^{\\infty} + K\\, E_{\\text{cut}}^{-p},\n$$\n的反幂律模型，来估算对应于 $E_{\\text{cut}} \\to \\infty$ 和足够密网格的渐近吸附能 $E_{\\text{ads}}^{\\infty}$，其中 $K$ 和 $p$ 是通过非线性最小二乘法确定的参数。\n- 定义并计算一个推荐的最小平面波截断能 $E_{\\text{cut}}^{\\text{rec}}$，使得剩余的基组截断误差大小 $|K| E_{\\text{cut}}^{-p}$ 低于给定的容差 $\\varepsilon > 0$，即\n$$\nE_{\\text{cut}}^{\\text{rec}} \\ge \\left(\\frac{|K|}{\\varepsilon}\\right)^{1/p}.\n$$\n- 在推荐截断能 $E_{\\text{cut}}^{\\text{rec}}$ 下，确定最小网格密度因子 $s^{\\text{rec}}$，使得差值 $|E_{\\text{ads}}(E_{\\text{cut}}^{\\text{rec}}, s) - E_{\\text{ads}}(E_{\\text{cut}}^{\\text{rec}}, s_{\\max})|$ 不大于 $\\varepsilon$，并选择满足此条件的最小 $s$。\n- 为每个测试用例返回推荐的截断能 $E_{\\text{cut}}^{\\text{rec}}$、推荐的网格密度因子 $s^{\\text{rec}}$、估算的收敛吸附能 $E_{\\text{ads}}^{\\infty}$，以及一个布尔标志，指示是否可以在所提供的离散截断能和网格因子集合内实现收敛目标。\n\n您必须用代码实现您的方案，并将其应用于以下明确的测试套件场景。能量单位为 $\\mathrm{eV}$，截断能单位为 $\\mathrm{eV}$，网格间距单位为 $\\mathrm{\\AA}$；最终的吸附能必须以 $\\mathrm{eV}$ 表示。请使用下面给出的离散截断能和网格因子集合；在选择推荐截断能时，您必须从提供的截断能集合中选择满足上述不等式的最小元素，如果无法满足不等式，则选择可用的最大截断能。在选择推荐的网格密度因子时，您必须从提供的网格因子集合中选择满足网格容差标准的最小元素，如果没有满足标准的，则选择可用的最大网格因子。容差 $\\varepsilon$ 应以 $\\mathrm{eV}$ 为单位应用。\n\n采用网格间距模型\n$$\nh(E_{\\text{cut}},s) = \\frac{\\alpha}{\\sqrt{E_{\\text{cut}}}\\, s}.\n$$\n\n定义包含三个场景的测试套件，每个场景为 $X \\in \\{\\text{slab+ads}, \\text{slab}, \\text{adsorbate}\\}$ 提供 $(E_X^{\\text{true}}, B_X, p_X, G_X, q_X)$，以及共享的常数 $\\alpha$、离散截断能集合、离散网格因子集合和容差 $\\varepsilon$：\n\n- 场景 1（通用“理想路径”）：\n  - $E_{\\text{slab+ads}}^{\\text{true}} = -100.0\\,\\mathrm{eV}$, $E_{\\text{slab}}^{\\text{true}} = -99.3\\,\\mathrm{eV}$, $E_{\\text{adsorbate}}^{\\text{true}} = -0.2\\,\\mathrm{eV}$。\n  - $B_{\\text{slab+ads}} = 12.0$, $p_{\\text{slab+ads}} = 1.8$；$B_{\\text{slab}} = 11.4$, $p_{\\text{slab}} = 1.8$；$B_{\\text{adsorbate}} = 0.3$, $p_{\\text{adsorbate}} = 1.8$。\n  - $G_{\\text{slab+ads}} = 0.20$, $q_{\\text{slab+ads}} = 2.0$；$G_{\\text{slab}} = 0.18$, $q_{\\text{slab}} = 2.0$；$G_{\\text{adsorbate}} = 0.01$, $q_{\\text{adsorbate}} = 2.0$。\n  - $\\alpha = 20.0$。\n  - 离散截断能集合: $\\{300.0, 400.0, 500.0, 600.0\\}\\,\\mathrm{eV}$。\n  - 离散网格因子集合: $\\{1.0, 1.5, 2.0\\}$。\n  - 容差: $\\varepsilon = 0.01\\,\\mathrm{eV}$。\n\n- 场景 2（基组收敛缓慢的边界情况）：\n  - $E_{\\text{slab+ads}}^{\\text{true}} = -250.0\\,\\mathrm{eV}$, $E_{\\text{slab}}^{\\text{true}} = -249.0\\,\\mathrm{eV}$, $E_{\\text{adsorbate}}^{\\text{true}} = -0.8\\,\\mathrm{eV}$。\n  - $B_{\\text{slab+ads}} = 20.0$, $p_{\\text{slab+ads}} = 0.8$；$B_{\\text{slab}} = 5.0$, $p_{\\text{slab}} = 1.6$；$B_{\\text{adsorbate}} = 2.0$, $p_{\\text{adsorbate}} = 1.2$。\n  - $G_{\\text{slab+ads}} = 0.10$, $q_{\\text{slab+ads}} = 2.0$；$G_{\\text{slab}} = 0.10$, $q_{\\text{slab}} = 2.0$；$G_{\\text{adsorbate}} = 0.05$, $q_{\\text{adsorbate}} = 2.0$。\n  - $\\alpha = 20.0$。\n  - 离散截断能集合: $\\{300.0, 400.0, 500.0, 600.0\\}\\,\\mathrm{eV}$。\n  - 离散网格因子集合: $\\{1.0, 1.5, 2.0\\}$。\n  - 容差: $\\varepsilon = 0.01\\,\\mathrm{eV}$。\n\n- 场景 3（$E_{\\text{ads}}$ 中存在强误差抵消的边缘情况）：\n  - $E_{\\text{slab+ads}}^{\\text{true}} = -150.0\\,\\mathrm{eV}$, $E_{\\text{slab}}^{\\text{true}} = -149.4\\,\\mathrm{eV}$, $E_{\\text{adsorbate}}^{\\text{true}} = -0.4\\,\\mathrm{eV}$。\n  - $B_{\\text{slab+ads}} = 8.0$, $p_{\\text{slab+ads}} = 1.6$；$B_{\\text{slab}} = 7.98$, $p_{\\text{slab}} = 1.6$；$B_{\\text{adsorbate}} = 0.01$, $p_{\\text{adsorbate}} = 1.6$。\n  - $G_{\\text{slab+ads}} = 0.08$, $q_{\\text{slab+ads}} = 2.0$；$G_{\\text{slab}} = 0.079, $q_{\\text{slab}} = 2.0$；$G_{\\text{adsorbate}} = 0.001, $q_{\\text{adsorbate}} = 2.0$。\n  - $\\alpha = 20.0$。\n  - 离散截断能集合: $\\{300.0, 400.0, 500.0, 600.0\\}\\,\\mathrm{eV}$。\n  - 离散网格因子集合: $\\{1.0, 1.5, 2.0\\}$。\n  - 容差: $\\varepsilon = 0.01\\,\\mathrm{eV}$。\n\n您的程序必须对每个场景，在所提供的离散截断能集合中的每个 $E_{\\text{cut}}$ 和所提供的离散网格因子集合中的每个 $s$ 的组合下生成 $E_{\\text{ads}}(E_{\\text{cut}}, s)$，在最密的网格 $s_{\\max} = \\max\\{s\\}$ 下执行截断能收敛拟合，估算 $E_{\\text{ads}}^{\\infty}$，根据离散截断能集合计算 $E_{\\text{cut}}^{\\text{rec}}$，根据离散网格因子集合找到 $s^{\\text{rec}}$，并确定在给定的离散集合下目标是否可实现。\n\n最终输出格式要求：您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，每个场景对应一个条目。每个场景的条目本身必须是 $[E_{\\text{cut}}^{\\text{rec}}, s^{\\text{rec}}, E_{\\text{ads}}^{\\infty}, \\text{is\\_converged}]$ 形式的列表，其中 $E_{\\text{cut}}^{\\text{rec}}$ 和 $E_{\\text{ads}}^{\\infty}$ 是以 $\\mathrm{eV}$ 为单位的浮点数，$s^{\\text{rec}}$ 是一个浮点数，$\\text{is\\_converged}$ 是一个布尔值。例如，输出格式应类似于 $[[x_1,y_1,z_1,b_1],[x_2,y_2,z_2,b_2],[x_3,y_3,z_3,b_3]]$，不含任何额外文本。",
            "solution": "用户提供了一个定义明确的计算问题，该问题基于平面波密度泛函理论（DFT）的原理。问题在于为两个关键数值参数——平面波截断能 $E_{\\text{cut}}$ 和实空间网格密度因子 $s$——实现一个收敛性测试方案。该方案将应用于根据一个合理的表面物种吸附能 $E_{\\text{ads}}$ 误差模型生成的合成数据。\n\n该问题是有效的，因为它具有科学依据、自成体系且算法上已明确规定。它代表了计算材料科学和化学中一个常见且至关重要的工作流程。我们将逐步进行求解。\n\n首先，我们形式化数据生成过程。任何组分 $X \\in \\{\\text{slab+ads}, \\text{slab}, \\text{adsorbate}\\}$ 的总能量被建模为 $E_{\\text{cut}}$ 和 $s$ 的函数：\n$$\nE_X(E_{\\text{cut}}, s) = E_X^{\\text{true}} + B_X E_{\\text{cut}}^{-p_X} + G_X h(E_{\\text{cut}},s)^{q_X}\n$$\n$E_X^{\\text{true}}$ 项是精确的、完全收敛的能量。第二项 $B_X E_{\\text{cut}}^{-p_X}$ 代表基组截断误差，它随截断能按幂律衰减。第三项 $G_X h(E_{\\text{cut}},s)^{q_X}$ 代表实空间网格离散化误差，它随网格间距 $h$ 按幂律衰减。网格间距 $h$ 本身是 $E_{\\text{cut}}$ 和无量纲网格密度因子 $s$ 的函数：\n$$\nh(E_{\\text{cut}},s) = \\frac{\\alpha}{\\sqrt{E_{\\text{cut}}}\\, s}\n$$\n我们关心的量是吸附能 $E_{\\text{ads}}$，定义为总能量的差值：\n$$\nE_{\\text{ads}}(E_{\\text{cut}},s) = E_{\\text{slab+ads}}(E_{\\text{cut}},s) - E_{\\text{slab}}(E_{\\text{cut}},s) - E_{\\text{adsorbate}}(E_{\\text{cut}},s)\n$$\n通过代入每个总能量的表达式，我们得到了计算吸附能的模型。对于每个场景，我们将使用这些方程为所提供的离散 $E_{\\text{cut}}$ 和 $s$ 值的每个组合生成一个 $E_{\\text{ads}}$ 值表。\n\n收敛方案包含四个主要步骤，我们将为每个测试场景实现这些步骤。\n\n1.  **估算渐近吸附能, $E_{\\text{ads}}^{\\infty}$**:\n    第一步是估算在无限基组（$E_{\\text{cut}} \\to \\infty$）极限下的吸附能。该方案规定使用来自最密实空间网格的数据，即在 $s_{\\max} = \\max\\{s_i\\}$ 处，其中 $\\{s_i\\}$ 是所提供的网格密度因子集合。计算出的值 $E_{\\text{ads}}(E_{\\text{cut}}, s_{\\max})$ 将使用非线性最小二乘法拟合到以下简化模型：\n    $$\n    E_{\\text{ads}}(E_{\\text{cut}}, s_{\\max}) \\approx E_{\\text{ads}}^{\\infty} + K\\, E_{\\text{cut}}^{-p}\n    $$\n    拟合将产生参数 $E_{\\text{ads}}^{\\infty}$、$K$ 和 $p$。我们将为此使用 `scipy.optimize.curve_fit` 函数。该函数需要参数的初始猜测值；我们将使用理论上已知的真实吸附能 $E_{\\text{ads}}^{\\text{true}} = E_{\\text{slab+ads}}^{\\text{true}} - E_{\\text{slab}}^{\\text{true}} - E_{\\text{adsorbate}}^{\\text{true}}$ 作为 $E_{\\text{ads}}^{\\infty}$ 的猜测值，并为 $K$ 和 $p$ 提供合理的初始值。\n\n2.  **确定推荐的平面波截断能, $E_{\\text{cut}}^{\\text{rec}}$**:\n    使用拟合得到的参数，我们将给定截断能下的剩余基组误差估算为 $|K| E_{\\text{cut}}^{-p}$。方案要求找到一个推荐的截断能 $E_{\\text{cut}}^{\\text{rec}}$，使得该误差小于或等于指定的容差 $\\varepsilon$。此条件表示为：\n    $$\n    |K|\\,(E_{\\text{cut}}^{\\text{rec}})^{-p} \\le \\varepsilon \\quad \\Longleftrightarrow \\quad E_{\\text{cut}}^{\\text{rec}} \\ge \\left(\\frac{|K|}{\\varepsilon}\\right)^{1/p}\n    $$\n    我们必须从可用的离散截断能集合中选择 $E_{\\text{cut}}^{\\text{rec}}$。规则是选择集合中满足此不等式的最小截断能。如果集合中没有截断能满足该条件，则将 $E_{\\text{cut}}^{\\text rec}$ 设为可用的最大截断能。\n\n3.  **确定推荐的网格密度因子, $s^{\\text{rec}}$**:\n    接下来，我们将截断能固定在 $E_{\\text{cut}}^{\\text{rec}}$ 值，并确定收敛网格相关误差所需的最小网格密度因子 $s^{\\text{rec}}$。收敛性是相对于在最密可用网格 $s_{\\max}$ 下的结果来衡量的。条件是：\n    $$\n    |E_{\\text{ads}}(E_{\\text{cut}}^{\\text{rec}}, s^{\\text{rec}}) - E_{\\text{ads}}(E_{\\text{cut}}^{\\text{rec}}, s_{\\max})| \\le \\varepsilon\n    $$\n    我们必须从可用的离散网格因子集合中选择 $s^{\\text{rec}}$。规则是选择满足此条件的最小因子 $s$。如果集合中没有因子满足它，则将 $s^{\\textrec}$ 设为可用的最大因子。\n\n4.  **评估收敛可实现性, `is_converged`**:\n    确定一个布尔标志 `is_converged`，用于报告是否在提供的离散集合内实现了对 $E_{\\text{cut}}$ 和 $s$ 的收敛目标。只有当为 $E_{\\text{cut}}^{\\text{rec}}$ 和 $s^{\\text{rec}}$ *都* 找到了满足容差的候选值时，此标志才为 `True`。如果任一参数因为无法满足容差而不得不默认使用可用的最大值，则该标志将为 `False`。\n\n实现过程将处理三个场景中的每一个，执行这个四步方案，并将结果（$E_{\\text{cut}}^{\\text{rec}}$、$s^{\\text{rec}}$、$E_{\\text{ads}}^{\\infty}$、`is_converged`）整理到一个最终列表中。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef solve():\n    \"\"\"\n    Implements and runs a convergence analysis protocol for plane-wave DFT calculations\n    based on a provided error model and test scenarios.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Scenario 1: General \"happy path\"\n        {\n            \"params\": {\n                \"slab+ads\": {\"E_true\": -100.0, \"B\": 12.0, \"p\": 1.8, \"G\": 0.20, \"q\": 2.0},\n                \"slab\":     {\"E_true\": -99.3,  \"B\": 11.4, \"p\": 1.8, \"G\": 0.18, \"q\": 2.0},\n                \"adsorbate\":{\"E_true\": -0.2,   \"B\": 0.3, \"p\": 1.8, \"G\": 0.01, \"q\": 2.0}\n            },\n            \"alpha\": 20.0,\n            \"cutoffs\": np.array([300.0, 400.0, 500.0, 600.0]),\n            \"s_factors\": np.array([1.0, 1.5, 2.0]),\n            \"epsilon\": 0.01\n        },\n        # Scenario 2: Boundary case with slow basis convergence\n        {\n            \"params\": {\n                \"slab+ads\": {\"E_true\": -250.0, \"B\": 20.0, \"p\": 0.8, \"G\": 0.10, \"q\": 2.0},\n                \"slab\":     {\"E_true\": -249.0, \"B\": 5.0,  \"p\": 1.6, \"G\": 0.10, \"q\": 2.0},\n                \"adsorbate\":{\"E_true\": -0.8,   \"B\": 2.0,  \"p\": 1.2, \"G\": 0.05, \"q\": 2.0}\n            },\n            \"alpha\": 20.0,\n            \"cutoffs\": np.array([300.0, 400.0, 500.0, 600.0]),\n            \"s_factors\": np.array([1.0, 1.5, 2.0]),\n            \"epsilon\": 0.01\n        },\n        # Scenario 3: Edge case with strong error cancellation\n        {\n            \"params\": {\n                \"slab+ads\": {\"E_true\": -150.0, \"B\": 8.0,  \"p\": 1.6, \"G\": 0.08,  \"q\": 2.0},\n                \"slab\":     {\"E_true\": -149.4, \"B\": 7.98, \"p\": 1.6, \"G\": 0.079, \"q\": 2.0},\n                \"adsorbate\":{\"E_true\": -0.4,   \"B\": 0.01, \"p\": 1.6, \"G\": 0.001, \"q\": 2.0}\n            },\n            \"alpha\": 20.0,\n            \"cutoffs\": np.array([300.0, 400.0, 500.0, 600.0]),\n            \"s_factors\": np.array([1.0, 1.5, 2.0]),\n            \"epsilon\": 0.01\n        }\n    ]\n\n    def h_spacing(E_cut, s, alpha):\n        return alpha / (np.sqrt(E_cut) * s)\n\n    def total_energy(E_cut, s, E_true, B, p, G, q, alpha):\n        h = h_spacing(E_cut, s, alpha)\n        return E_true + B * E_cut**(-p) + G * h**q\n\n    def ads_energy(E_cut, s, params, alpha):\n        E_sad = total_energy(E_cut, s, **params[\"slab+ads\"], alpha=alpha)\n        E_sl = total_energy(E_cut, s, **params[\"slab\"], alpha=alpha)\n        E_ad = total_energy(E_cut, s, **params[\"adsorbate\"], alpha=alpha)\n        return E_sad - E_sl - E_ad\n\n    def fit_model(E_cut, E_ads_inf, K, p):\n        return E_ads_inf + K * E_cut**(-p)\n\n    results = []\n    for case in test_cases:\n        params = case[\"params\"]\n        alpha = case[\"alpha\"]\n        cutoffs = case[\"cutoffs\"]\n        s_factors = case[\"s_factors\"]\n        epsilon = case[\"epsilon\"]\n\n        # Step 1: Fit for asymptotic energy E_ads_inf\n        s_max = np.max(s_factors)\n        E_ads_at_s_max = np.array([ads_energy(ec, s_max, params, alpha) for ec in cutoffs])\n        \n        true_E_ads_inf = params[\"slab+ads\"][\"E_true\"] - params[\"slab\"][\"E_true\"] - params[\"adsorbate\"][\"E_true\"]\n        p0 = [true_E_ads_inf, 1.0, 1.5] # Initial guess for E_ads_inf, K, p\n        \n        try:\n            popt, _ = curve_fit(fit_model, cutoffs, E_ads_at_s_max, p0=p0, maxfev=5000)\n            E_ads_inf, K, p_fit = popt\n            fit_valid = p_fit > 0 and not np.isinf(K) and not np.isnan(K)\n        except RuntimeError:\n            fit_valid = False\n\n        if not fit_valid:\n            E_cut_rec = np.max(cutoffs)\n            s_rec = np.max(s_factors)\n            is_converged = False\n            results.append([float(E_cut_rec), float(s_rec), np.nan, is_converged])\n            continue\n\n        # Step 2: Determine recommended cutoff E_cut_rec\n        E_cut_thresh = (np.abs(K) / epsilon)**(1 / p_fit)\n        E_cut_candidates = cutoffs[cutoffs >= E_cut_thresh]\n        \n        if E_cut_candidates.size > 0:\n            E_cut_rec = np.min(E_cut_candidates)\n            cutoff_converged = True\n        else:\n            E_cut_rec = np.max(cutoffs)\n            cutoff_converged = False\n\n        # Step 3: Determine recommended grid factor s_rec\n        E_ads_target_grid = ads_energy(E_cut_rec, s_max, params, alpha)\n        s_rec_candidates = []\n        for s_val in s_factors:\n            E_ads_current_s = ads_energy(E_cut_rec, s_val, params, alpha)\n            if np.abs(E_ads_current_s - E_ads_target_grid) = epsilon:\n                s_rec_candidates.append(s_val)\n\n        if s_rec_candidates:\n            s_rec = np.min(s_rec_candidates)\n            grid_converged = True\n        else:\n            s_rec = np.max(s_factors)\n            grid_converged = False\n\n        # Step 4: Determine final convergence status\n        is_converged = cutoff_converged and grid_converged\n\n        results.append([float(E_cut_rec), float(s_rec), E_ads_inf, is_converged])\n\n    # Final print statement in the exact required format.\n    # Manually construct string to match example format [[a,b,c,d],[e,f,g,h]] with no spaces.\n    outer_parts = []\n    for res_list in results:\n        # Format boolean as lowercase true/false\n        inner_parts = [str(v) for v in res_list[:-1]] + [str(res_list[-1]).lower()]\n        outer_parts.append(f\"[{','.join(inner_parts)}]\")\n    \n    print(f\"[{','.join(outer_parts)}]\")\n    \nsolve()\n```"
        },
        {
            "introduction": "虽然在真空中计算吸附能是理解表面相互作用的第一步，但电化学的真正复杂性在于电极-电解质界面。吸附物在电极上的稳定性并不是一个恒定值，而是电极电势 $U$ 和电解质酸碱度 $\\text{pH}$ 的函数。本练习将向您介绍计算氢电极（CHE）模型，这是现代计算电化学的基石，它使我们能够将这些环境效应纳入我们的计算中 。您将学习如何从基本的 DFT 总能量出发，结合统计热力学校正，计算出关键中间体（如 $\\mathrm{OH^*}$）在任意电势和 $\\text{pH}$ 条件下的吸附自由能。",
            "id": "4241853",
            "problem": "您需要构建一个完整的计算方案，并以可运行程序的形式呈现，以计算羟基在表面上（$\\mathrm{OH^*}$）的吸附自由能 $E_{\\text{ads}}$。该计算使用水 $\\mathrm{H_2O}$ 和氢气 $\\mathrm{H_2}$ 的密度泛函理论 (DFT) 级别的能量作为参考，并将这些结果与在指定电极电势和酸度下通过计算氢电极 (CHE) 框架获得的结果进行比较。该程序必须从第一性原理出发实现该方案，而不是通过调用现成的公式，并且必须按照下述严格定义的格式输出结果。\n\n需要使用的基本原理：\n- 一个物种的热力学自由能为 $G = E_{\\text{elec}} + E_{\\text{ZPE}} - T S$，其中 $E_{\\text{elec}}$ 是电子能量，$E_{\\text{ZPE}}$ 是零点能，$T$ 是绝对温度，$S$ 是熵。\n- 要考虑的吸附反应是 $\\mathrm{H_2O(l)} + * \\rightarrow \\mathrm{OH^*} + \\mathrm{H^+} + \\mathrm{e^-}$，其中 $*$ 表示一个空的表面位点。初始态和最终态自由能的化学计量组合定义了在标准条件下相对于 $\\mathrm{H_2O}$ 和 $\\mathrm{H_2}$ 参考的吸附自由能。\n- 在计算氢电极 (CHE) 框架中，质子-电子对的化学势由其与分子氢在给定电极电势和酸度 (pH) 下的平衡决定。您必须在有限温度下使用玻尔兹曼统计一致地引入电极电势和 pH 的影响，其中出现热因子 $k_B T$，$k_B$ 是玻尔兹曼常数。\n\n需要使用的热力学和物理常数：\n- 温度 $T = 298.15$ K。\n- 玻尔兹曼常数 $k_B = 8.617333262145\\times 10^{-5}$ eV/K。\n- 10的自然对数 $\\ln(10)$。\n- 阿伏伽德罗常数 $N_A = 6.02214076\\times 10^{23}$ mol$^{-1}$。\n- 元电荷 $e = 1.602176634\\times 10^{-19}$ C。\n- 当将摩尔熵转换为单粒子能量单位时，使用单位为 $\\mathrm{J/mol}$ 的 $T S$，通过除以 $N_A$ 将其转换为每个粒子的焦耳数，然后通过除以 $e$ 将其转换为 $\\mathrm{eV}$。\n\n方案要求：\n1. 使用给定的 DFT 电子能量、零点能和摩尔熵，计算自由能 $G(\\mathrm{H_2})$ 和 $G(\\mathrm{H_2O})$。所有能量和输出必须以电子伏特 (eV) 为单位报告。\n2. 对于表面，根据给定的带有 $\\mathrm{OH^*}$ 的板层和裸板层的 DFT 电子能量，计算 $G(\\mathrm{OH^*}) - G(*)$，包括吸附羟基的零点能和熵（假设吸附羟基的熵可忽略不计，取 $S(\\mathrm{OH^*}) = 0$ J/mol/K）。\n3. 构建在标准条件下（$U = 0$ V 相对于可逆氢电极，$\\mathrm{pH} = 0$）相对于 $\\mathrm{H_2O}$ 和 $\\mathrm{H_2}$ 参考的吸附自由能，记为 $E_{\\text{ads}}^{\\mathrm{ref0}}$。\n4. 使用 CHE 框架，通过将质子-电子对的化学势替换为在指定 $U$ 和 $\\mathrm{pH}$ 下相对于 $\\mathrm{H_2}$ 的平衡形式，调整吸附自由能以适应有限的 $U$ 和 $\\mathrm{pH}$，从而获得 $E_{\\text{ads}}^{\\mathrm{CHE}}(U,\\mathrm{pH})$，确保对 $U$ 和 $\\mathrm{pH}$ 的依赖性通过 $k_B T$ 和 $\\ln(10)$（适用于酸度）适当地引入。\n5. 所有最终数值答案必须是浮点数，单位为 eV，并四舍五入到三位小数。\n\n本任务不涉及角度单位。\n\n测试套件：\n对于每个测试用例，您将获得 DFT 电子能量 $E_{\\text{DFT}}$ (eV)、零点能 $E_{\\text{ZPE}}$ (eV)、摩尔熵 $S$ (J/mol/K) 和电化学状态（$U$ (V), $\\mathrm{pH}$）。对于所有情况，假设 $S(\\mathrm{OH^*}) = 0$ J/mol/K。对于所有情况，温度为 $T = 298.15$ K。\n\n- 测试用例 1 (正常路径；相等性检查):\n  - $E_{\\text{DFT}}(\\text{slab}) = -100.000$ eV\n  - $E_{\\text{DFT}}(\\text{slab}+\\mathrm{OH^*}) = -101.180$ eV\n  - $E_{\\text{DFT}}(\\mathrm{H_2O}) = -0.560$ eV, $E_{\\text{ZPE}}(\\mathrm{H_2O}) = 0.560$ eV, $S(\\mathrm{H_2O}) = 69.95$ J/mol/K\n  - $E_{\\text{DFT}}(\\mathrm{H_2}) = -0.270$ eV, $E_{\\text{ZPE}}(\\mathrm{H_2}) = 0.270$ eV, $S(\\mathrm{H_2}) = 130.68$ J/mol/K\n  - $E_{\\text{ZPE}}(\\mathrm{OH^*}) = 0.360$ eV\n  - $U = 0.0$ V, $\\mathrm{pH} = 0.0$\n- 测试用例 2 (边界电势；酸性):\n  - $E_{\\text{DFT}}(\\text{slab}) = -220.000$ eV\n  - $E_{\\text{DFT}}(\\text{slab}+\\mathrm{OH^*}) = -221.050$ eV\n  - $E_{\\text{DFT}}(\\mathrm{H_2O}) = -0.600$ eV, $E_{\\text{ZPE}}(\\mathrm{H_2O}) = 0.560$ eV, $S(\\mathrm{H_2O}) = 69.95$ J/mol/K\n  - $E_{\\text{DFT}}(\\mathrm{H_2}) = -0.310$ eV, $E_{\\text{ZPE}}(\\mathrm{H_2}) = 0.270$ eV, $S(\\mathrm{H_2}) = 130.68$ J/mol/K\n  - $E_{\\text{ZPE}}(\\mathrm{OH^*}) = 0.360$ eV\n  - $U = 1.23$ V, $\\mathrm{pH} = 0.0$\n- 测试用例 3 (碱性；中等电势):\n  - $E_{\\text{DFT}}(\\text{slab}) = -150.000$ eV\n  - $E_{\\text{DFT}}(\\text{slab}+\\mathrm{OH^*}) = -150.650$ eV\n  - $E_{\\text{DFT}}(\\mathrm{H_2O}) = -0.580$ eV, $E_{\\text{ZPE}}(\\mathrm{H_2O}) = 0.560$ eV, $S(\\mathrm{H_2O}) = 69.95$ J/mol/K\n  - $E_{\\text{DFT}}(\\mathrm{H_2}) = -0.280$ eV, $E_{\\text{ZPE}}(\\mathrm{H_2}) = 0.270$ eV, $S(\\mathrm{H_2}) = 130.68$ J/mol/K\n  - $E_{\\text{ZPE}}(\\mathrm{OH^*}) = 0.360$ eV\n  - $U = 0.50$ V, $\\mathrm{pH} = 13.0$\n- 测试用例 4 (弱吸附；负电势；中性 pH):\n  - $E_{\\text{DFT}}(\\text{slab}) = -180.000$ eV\n  - $E_{\\text{DFT}}(\\text{slab}+\\mathrm{OH^*}) = -180.100$ eV\n  - $E_{\\text{DFT}}(\\mathrm{H_2O}) = -0.620$ eV, $E_{\\text{ZPE}}(\\mathrm{H_2O}) = 0.560$ eV, $S(\\mathrm{H_2O}) = 69.95$ J/mol/K\n  - $E_{\\text{DFT}}(\\mathrm{H_2}) = -0.290$ eV, $E_{\\text{ZPE}}(\\mathrm{H_2}) = 0.270$ eV, $S(\\mathrm{H_2}) = 130.68$ J/mol/K\n  - $E_{\\text{ZPE}}(\\mathrm{OH^*}) = 0.360$ eV\n  - $U = -0.10$ V, $\\mathrm{pH} = 7.0$\n\n每个测试用例的任务：\n- 使用从反应 $\\mathrm{H_2O(l)} + * \\rightarrow \\mathrm{OH^*} + \\mathrm{H^+} + \\mathrm{e^-}$ 推导出的化学计量自由能，并通过参考 $\\mathrm{H_2}$ 和 $\\mathrm{H_2O}$ 来消除质子-电子对，计算在 $U = 0$ V 和 $\\mathrm{pH} = 0$ 下的 $E_{\\text{ads}}^{\\mathrm{ref0}}$ (eV)。\n- 通过有限温度下的化学势引入 CHE 对 $U$ 和 $\\mathrm{pH}$ 的依赖性，计算 $E_{\\text{ads}}^{\\mathrm{CHE}}(U,\\mathrm{pH})$ (eV)。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含每个测试用例的两个浮点数 $[E_{\\text{ads}}^{\\mathrm{ref0}}, E_{\\text{ads}}^{\\mathrm{CHE}}]$，四舍五入到三位小数，并将所有情况的结果扁平化为一个列表。例如，输出应类似于 $[r_{1,\\mathrm{ref0}}, r_{1,\\mathrm{CHE}}, r_{2,\\mathrm{ref0}}, r_{2,\\mathrm{CHE}}, \\dots]$，其中每个 $r$ 的单位都是 eV。",
            "solution": "该问题具有科学依据，提法明确且客观。它概述了计算电化学中的一个标准方案（计算氢电极模型），该方案使用了基本的热力学原理。所提供的数据、常数和反应是一致且充分的，足以推导出一个唯一且有意义的解。因此，该问题是有效的。\n\n该计算方案从第一性原理出发，构建过程如下。\n\n1. 单个物种的自由能\n任何物种的吉布斯自由能 $G$ 由其在给定温度 $T$ 下的电子能量 $E_{\\text{elec}}$、零点振动能 $E_{\\text{ZPE}}$ 和熵 $S$ 给出：\n$$ G = E_{\\text{elec}} + E_{\\text{ZPE}} - T S $$\n电子能量 $E_{\\text{elec}}$ 取自密度泛函理论 (DFT) 计算的能量 $E_{\\text{DFT}}$。为保持一致性，所有能量都必须以电子伏特 ($\\mathrm{eV}$) 为单位。问题给出的摩尔熵 $S$ 的单位是 $\\mathrm{J/mol/K}$。$TS$ 项必须从 $\\mathrm{J/mol}$ 转换为 $\\mathrm{eV}$。此转换通过除以阿伏伽德罗常数 $N_A$ 得到每个粒子的能量（以焦耳为单位），然后除以元电荷 $e$ 得到能量（以 $\\mathrm{eV}$ 为单位）来完成：\n$$ T S \\ [\\mathrm{eV}] = \\frac{T S \\ [\\mathrm{J/mol}]}{N_A e} $$\n其中 $N_A e$ 是法拉第常数 $F$。\n\n因此，参考分子水 ($\\mathrm{H_2O}$) 和氢气 ($\\mathrm{H_2}$) 的自由能为：\n$$ G(\\mathrm{H_2O}) = E_{\\text{DFT}}(\\mathrm{H_2O}) + E_{\\text{ZPE}}(\\mathrm{H_2O}) - \\frac{T S(\\mathrm{H_2O})}{N_A e} $$\n$$ G(\\mathrm{H_2}) = E_{\\text{DFT}}(\\mathrm{H_2}) + E_{\\text{ZPE}}(\\mathrm{H_2}) - \\frac{T S(\\mathrm{H_2})}{N_A e} $$\n\n2. 吸附态的自由能\n表面上的羟基吸附物 $\\mathrm{OH^*}$ 的自由能是相对于裸表面（表示为 $*$）计算的。这个相对自由能是带有吸附物的板层的自由能与裸板层的自由能之差：\n$$ G(\\mathrm{OH^*}) - G(*) = [G(\\text{slab}+\\mathrm{OH^*})] - [G(\\text{slab})] $$\n$$ G(\\mathrm{OH^*}) - G(*) = (E_{\\text{DFT}}(\\text{slab}+\\mathrm{OH^*}) - E_{\\text{DFT}}(\\text{slab})) + (E_{\\text{ZPE}}(\\text{slab}+\\mathrm{OH^*}) - E_{\\text{ZPE}}(\\text{slab})) - T(S(\\text{slab}+\\mathrm{OH^*}) - S(\\text{slab})) $$\n振动贡献仅限于吸附物，所以 $E_{\\text{ZPE}}(\\text{slab}+\\mathrm{OH^*}) - E_{\\text{ZPE}}(\\text{slab}) = E_{\\text{ZPE}}(\\mathrm{OH^*})$。问题指定忽略吸附羟基的熵，$S(\\mathrm{OH^*}) = 0 \\ \\mathrm{J/mol/K}$，这是一个常见的近似，将熵项简化为零。因此，吸附物的相对自由能为：\n$$ G(\\mathrm{OH^*}) - G(*) = (E_{\\text{DFT}}(\\text{slab}+\\mathrm{OH^*}) - E_{\\text{DFT}}(\\text{slab})) + E_{\\text{ZPE}}(\\mathrm{OH^*}) $$\n\n3. 标准条件下的吸附自由能 ($E_{\\text{ads}}^{\\mathrm{ref0}}$)\n吸附反应为：\n$$ \\mathrm{H_2O(l)} + * \\rightarrow \\mathrm{OH^*} + \\mathrm{H^+} + \\mathrm{e^-} $$\n此反应的自由能变化 $\\Delta G_{\\text{ads}}$ 是产物和反应物自由能之差：\n$$ \\Delta G_{\\text{ads}} = (G(\\mathrm{OH^*}) - G(*)) + \\mu(\\mathrm{H^+}) + \\mu(\\mathrm{e^-}) - G(\\mathrm{H_2O}) $$\n其中 $\\mu$ 表示化学势。\n计算氢电极 (CHE) 模型将质子-电子对的化学势 $\\mu(\\mathrm{H^+}) + \\mu(\\mathrm{e^-})$ 设置为与压力为 $p=1$ bar 的分子氢处于平衡状态：\n$$ \\mathrm{H^+} + \\mathrm{e^-} \\rightleftharpoons \\frac{1}{2}\\mathrm{H_2(g)} $$\n在标准条件下（$U=0 \\ \\mathrm{V}$ vs. RHE，$\\mathrm{pH}=0$），此平衡规定质子-电子对的化学势与半个氢分子的化学势相同：\n$$ \\mu(\\mathrm{H^+}) + \\mu(\\mathrm{e^-}) = \\frac{1}{2}G(\\mathrm{H_2}) $$\n将此代入 $\\Delta G_{\\text{ads}}$ 的表达式中，即可得到标准条件下的吸附自由能，问题中记为 $E_{\\text{ads}}^{\\mathrm{ref0}}$：\n$$ E_{\\text{ads}}^{\\mathrm{ref0}} = \\Delta G_{\\text{ads}}(U=0, \\mathrm{pH}=0) = (G(\\mathrm{OH^*}) - G(*)) + \\frac{1}{2}G(\\mathrm{H_2}) - G(\\mathrm{H_2O}) $$\n\n4. 有限电势和酸度下的吸附自由能 ($E_{\\text{ads}}^{\\mathrm{CHE}}$)\n为了求得在任意电极电势 $U$ 和 $\\mathrm{pH}$ 下的吸附自由能，我们必须调整质子-电子对的化学势。相对于标准氢电极，电子的化学势偏移了 $-eU$。质子的化学势从其标准态（活度 $a_{\\mathrm{H^+}}=1$）偏移了一个与浓度相关的项。$\\mathrm{pH}$ 的定义为 $\\mathrm{pH} = -\\log_{10}(a_{\\mathrm{H^+}})$，这意味着 $\\ln(a_{\\mathrm{H^+}}) = -\\mathrm{pH}\\ln(10)$。\n该对的总化学势变为：\n$$ \\mu(\\mathrm{H^+}) + \\mu(\\mathrm{e^-}) = \\frac{1}{2}G(\\mathrm{H_2}) - eU + k_B T \\ln(a_{\\mathrm{H^+}}) $$\n$$ \\mu(\\mathrm{H^+}) + \\mu(\\mathrm{e^-}) = \\frac{1}{2}G(\\mathrm{H_2}) - eU - k_B T \\ln(10) \\times \\mathrm{pH} $$\n这里，如果 $U$ 以伏特为单位，则 $eU$ 项以 $\\mathrm{eV}$ 为单位，因此在计算中，我们可以简单地减去 $U$ 的数值。$k_B T$ 项是热能，单位为 $\\mathrm{eV}$。\n将此调整后的化学势代入 $\\Delta G_{\\text{ads}}$ 的表达式中，得到 $E_{\\text{ads}}^{\\mathrm{CHE}}(U, \\mathrm{pH})$：\n$$ E_{\\text{ads}}^{\\mathrm{CHE}}(U, \\mathrm{pH}) = (G(\\mathrm{OH^*}) - G(*)) + \\left( \\frac{1}{2}G(\\mathrm{H_2}) - U - k_B T \\ln(10) \\times \\mathrm{pH} \\right) - G(\\mathrm{H_2O}) $$\n通过与 $E_{\\text{ads}}^{\\mathrm{ref0}}$ 的表达式进行比较，我们得到最终关系式：\n$$ E_{\\text{ads}}^{\\mathrm{CHE}}(U, \\mathrm{pH}) = E_{\\text{ads}}^{\\mathrm{ref0}} - U - k_B T \\ln(10) \\times \\mathrm{pH} $$\n程序将对每个测试用例实现这些方程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the adsorption free energy of hydroxyl on a surface using DFT-level energies\n    and the Computational Hydrogen Electrode (CHE) framework.\n    \"\"\"\n\n    # Thermodynamic and physical constants\n    T = 298.15  # Temperature in Kelvin\n    KB = 8.617333262145e-5  # Boltzmann constant in eV/K\n    NA = 6.02214076e23  # Avogadro's number in mol^-1\n    E_CHARGE = 1.602176634e-19  # Elementary charge in C\n    LN_10 = np.log(10) # Natural logarithm of 10\n\n    # Faraday constant in C/mol, for unit conversion\n    FARADAY_CONSTANT = NA * E_CHARGE\n\n    # Test suite from the problem statement\n    test_cases = [\n        # Test Case 1\n        {\n            \"E_dft_slab\": -100.000, \"E_dft_slab_OH\": -101.180,\n            \"E_dft_h2o\": -0.560, \"E_zpe_h2o\": 0.560, \"S_h2o\": 69.95,\n            \"E_dft_h2\": -0.270, \"E_zpe_h2\": 0.270, \"S_h2\": 130.68,\n            \"E_zpe_oh\": 0.360, \"S_oh\": 0.0,\n            \"U\": 0.0, \"pH\": 0.0\n        },\n        # Test Case 2\n        {\n            \"E_dft_slab\": -220.000, \"E_dft_slab_OH\": -221.050,\n            \"E_dft_h2o\": -0.600, \"E_zpe_h2o\": 0.560, \"S_h2o\": 69.95,\n            \"E_dft_h2\": -0.310, \"E_zpe_h2\": 0.270, \"S_h2\": 130.68,\n            \"E_zpe_oh\": 0.360, \"S_oh\": 0.0,\n            \"U\": 1.23, \"pH\": 0.0\n        },\n        # Test Case 3\n        {\n            \"E_dft_slab\": -150.000, \"E_dft_slab_OH\": -150.650,\n            \"E_dft_h2o\": -0.580, \"E_zpe_h2o\": 0.560, \"S_h2o\": 69.95,\n            \"E_dft_h2\": -0.280, \"E_zpe_h2\": 0.270, \"S_h2\": 130.68,\n            \"E_zpe_oh\": 0.360, \"S_oh\": 0.0,\n            \"U\": 0.50, \"pH\": 13.0\n        },\n        # Test Case 4\n        {\n            \"E_dft_slab\": -180.000, \"E_dft_slab_OH\": -180.100,\n            \"E_dft_h2o\": -0.620, \"E_zpe_h2o\": 0.560, \"S_h2o\": 69.95,\n            \"E_dft_h2\": -0.290, \"E_zpe_h2\": 0.270, \"S_h2\": 130.68,\n            \"E_zpe_oh\": 0.360, \"S_oh\": 0.0,\n            \"U\": -0.10, \"pH\": 7.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Step 1: Compute free energies G = E_elec + E_ZPE - T*S\n        \n        # Free energy of H2O\n        ts_h2o_ev = (T * case[\"S_h2o\"]) / FARADAY_CONSTANT\n        g_h2o = case[\"E_dft_h2o\"] + case[\"E_zpe_h2o\"] - ts_h2o_ev\n        \n        # Free energy of H2\n        ts_h2_ev = (T * case[\"S_h2\"]) / FARADAY_CONSTANT\n        g_h2 = case[\"E_dft_h2\"] + case[\"E_zpe_h2\"] - ts_h2_ev\n        \n        # Step 2: Compute relative free energy of adsorbed OH*\n        # G(OH*) - G(*) = (E_DFT(slab+OH*) - E_DFT(slab)) + E_ZPE(OH*) - T*S(OH*)\n        # S(OH*) is assumed to be 0.\n        g_oh_rel = (case[\"E_dft_slab_OH\"] - case[\"E_dft_slab\"]) + case[\"E_zpe_oh\"]\n\n        # Step 3: Compute adsorption free energy at standard conditions (U=0, pH=0)\n        # E_ads^ref0 = (G(OH*) - G(*)) + 0.5*G(H2) - G(H2O)\n        e_ads_ref0 = g_oh_rel + 0.5 * g_h2 - g_h2o\n\n        # Step 4: Compute adsorption free energy at given U and pH using CHE\n        # E_ads^CHE = E_ads^ref0 - U - k_B*T*ln(10)*pH\n        ph_correction = KB * T * LN_10 * case[\"pH\"]\n        e_ads_che = e_ads_ref0 - case[\"U\"] - ph_correction\n        \n        # Step 5: Round results to three decimal places and append\n        results.append(round(e_ads_ref0, 3))\n        results.append(round(e_ads_che, 3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.3f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在计算出可靠且与实验条件相关的吸附能之后，下一个科学问题是：为什么这个能量值是这样的？化学键的本质是什么？为了从“数字”走向“洞见”，我们需要能够剖析和理解计算结果的分析工具。本练习将介绍晶体轨道哈密顿布居（COHP）分析，这是一种强大的后处理技术，可将复杂的总相互作用能分解为化学上直观的成键和反键贡献 。通过在一个简化的紧束缚模型中实施 COHP 工作流程，您将学习如何量化吸附物-基底键的稳定和失稳组分，从而深入理解表面化学键的性质。",
            "id": "4241821",
            "problem": "您需要设计并实现一个用于晶体轨道哈密顿布居 (COHP) 分析的计算工作流，以便在 Kohn-Sham 密度泛函理论 (DFT) 框架内，将吸附质在表面上的结合能分解为成键和反键贡献。在一个代表了投影到一组原子中心轨道上的 Kohn-Sham 哈密顿量的最小局域正交紧束缚基组中进行工作。从以下原理和定义出发，推导出一个计算该分解的算法。\n\n基本原理：\n- Kohn-Sham 有效单粒子哈密顿量在局域基组中表示为矩阵 $H$，其元素为 $H_{ij}$。\n- 在正交基组近似（重叠矩阵 $S=I$）中，能带能量为 $E_{\\text{band}}=\\sum_{n \\in \\text{occ}} \\epsilon_n$，其中 $\\epsilon_n$ 是 $H$ 的本征值。\n- 密度矩阵为 $P = \\sum_{n \\in \\text{occ}} \\mathbf{c}^{(n)} \\mathbf{c}^{(n)\\top}$，其中 $\\mathbf{c}^{(n)}$ 是 $H$ 对于本征态 $n$ 的归一化本征矢量。\n- 在正交基组中，与一对基函数（或原子）$i$ 和 $j$ 相关联的能量贡献可以与 $P_{ij} H_{ij}$ 关联。\n- 晶体轨道哈密顿布居 (COHP) 对一个原子对 $(i,j)$ 的能量分辨定义为 $-\\mathrm{COHP}_{ij}(E) = -\\sum_n c_i^{(n)} c_j^{(n)} H_{ij} \\, \\delta(E - \\epsilon_n)$，其中 $c_i^{(n)}$ 是 $\\mathbf{c}^{(n)}$ 的第 $i$ 个分量。符号约定为，$-\\mathrm{COHP}$ 的负值表示成键贡献，正值表示反键贡献。\n- 积分到费米能级 $E_{\\mathrm{F}}$ 的 COHP 为 $\\mathrm{ICOHP}_{ij} = \\int_{-\\infty}^{E_{\\mathrm{F}}} \\left(-\\mathrm{COHP}_{ij}(E)\\right)\\, dE$。在一个自旋简并、零温模型中，占据数是一个阶跃函数，每个占据态贡献一个因子 $g=2$。\n- 在正交基组中，由于吸附质和衬底之间形成化学键而引起的能带能量变化，可以通过对吸附质-衬底对的积分成对 $-\\mathrm{COHP}$ 项求和来近似。通过在占据谱上分离 $-\\mathrm{COHP}_{ij}(E)$ 的负值和正值部分，可以将其分解为成键和反键贡献。\n\n您的任务：\n- 给定一个代表带有吸附质的表面的实对称哈密顿矩阵 $H$（单位为电子伏特）、一个费米能级 $E_{\\mathrm{F}}$（单位为电子伏特），以及一个定义了界面键的吸附质-衬底对列表 $(i,j)$（$H$ 中从零开始的索引），构建一个算法来计算：\n  1. 成键贡献 $E_{\\text{bond}}$，单位为电子伏特，定义为对所有占据本征态的 $-\\sum_{(i,j)} c_i^{(n)} c_j^{(n)} H_{ij}$ 的负值部分求和，再乘以自旋简并度 $g=2$。\n  2. 反键贡献 $E_{\\text{antibond}}$，单位为电子伏特，定义为对所有占据本征态的 $-\\sum_{(i,j)} c_i^{(n)} c_j^{(n)} H_{ij}$ 的正值部分求和，再乘以 $g=2$。\n  3. 净吸附结合能的替代值 $E_{\\text{ads}}$，单位为电子伏特，近似为 $E_{\\text{bond}} + E_{\\text{antibond}}$。\n  4. 反键分数 $r$，以小数表示，定义为 $r = \\frac{E_{\\text{antibond}}}{|E_{\\text{bond}}|}$（如果 $|E_{\\text{bond}}|0$），否则 $r=0$。\n\n假设与约束：\n- 使用零温（$T=0$）和自旋简并度 $g=2$。\n- 将基组视为正交（$S=I$）且 $H$ 为实对称矩阵。\n- 占据数是一个阶跃函数：能量 $\\epsilon_n \\le E_{\\mathrm{F}}$ 的态是占据的，否则是未占据的。\n- 所有能量必须以电子伏特 (eV) 为单位报告。\n- 程序必须是自包含的，且不得依赖任何外部文件或输入。\n\n测试套件：\n在以下四个测试案例上实现您的工作流。每个案例提供 $H$、$E_{\\mathrm{F}}$ 和吸附质-衬底对列表。索引 0 和 1 表示两个衬底位点，索引 2 表示吸附质位点。\n\n- 案例 1（通用正常路径，中等耦合）：\n  - $$H = \\begin{bmatrix}\n  0.0  -2.0  -1.0 \\\\\n  -2.0  0.0  -0.5 \\\\\n  -1.0  -0.5  -5.0\n  \\end{bmatrix}\\ \\text{eV},\\quad E_{\\mathrm{F}} = -0.5\\ \\text{eV},\\quad \\text{pairs} = [(2,0),(2,1)].$$\n- 案例 2（弱耦合边界情况）：\n  - $$H = \\begin{bmatrix}\n  0.0  -2.0  -0.1 \\\\\n  -2.0  0.0  -0.05 \\\\\n  -0.1  -0.05  -5.0\n  \\end{bmatrix}\\ \\text{eV},\\quad E_{\\mathrm{F}} = -0.5\\ \\text{eV},\\quad \\text{pairs} = [(2,0),(2,1)].$$\n- 案例 3（高费米能级导致的占据反键态）：\n  - $$H = \\begin{bmatrix}\n  0.0  -2.0  -1.5 \\\\\n  -2.0  0.0  -1.0 \\\\\n  -1.5  -1.0  -5.0\n  \\end{bmatrix}\\ \\text{eV},\\quad E_{\\mathrm{F}} = 1.0\\ \\text{eV},\\quad \\text{pairs} = [(2,0),(2,1)].$$\n- 案例 4（无耦合边界条件）：\n  - $$H = \\begin{bmatrix}\n  0.0  -2.0  0.0 \\\\\n  -2.0  0.0  0.0 \\\\\n  0.0  0.0  -5.0\n  \\end{bmatrix}\\ \\text{eV},\\quad E_{\\mathrm{F}} = -0.5\\ \\text{eV},\\quad \\text{pairs} = [(2,0),(2,1)].$$\n\n要求输出：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表。\n- 每个测试案例的结果必须是包含四个浮点数的列表，单位为电子伏特，四舍五入到六位小数，顺序为 $[E_{\\text{bond}}, E_{\\text{antibond}}, E_{\\text{ads}}, r]$。\n- 最终输出必须是包含四个案例结果的单个列表，例如：\n  $$[[E_{\\text{bond}}^{(1)}, E_{\\text{antibond}}^{(1)}, E_{\\text{ads}}^{(1)}, r^{(1)}],[E_{\\text{bond}}^{(2)}, E_{\\text{antibond}}^{(2)}, E_{\\text{ads}}^{(2)}, r^{(2)}],[E_{\\text{bond}}^{(3)}, E_{\\text{antibond}}^{(3)}, E_{\\text{ads}}^{(3)}, r^{(3)}],[E_{\\text{bond}}^{(4)}, E_{\\text{antibond}}^{(4)}, E_{\\text{ads}}^{(4)}, r^{(4)}]].$$",
            "solution": "该问题陈述是有效的。它提出了一个有科学依据、适定且客观的任务，根植于计算量子化学的原理。具体来说，它要求在一个源自密度泛函理论 (DFT) 的简化正交紧束缚框架内，实现晶体轨道哈密顿布居 (COHP) 分析，这是一种用于解析化学键的标准技术。所有必要的数据、定义和约束都已提供，从而可以构建一个唯一且可验证的算法解决方案。\n\n目标是将吸附质和衬底之间的相互作用能分解为稳定（成键）和非稳定（反键）的贡献。这是通过分析给定的 Kohn-Sham 哈密顿矩阵 $H$（代表该体系）的本征态来完成的。\n\n其理论基础是基于在局域原子轨道基组中对单粒子哈密顿量的表示。在指定的正交基组近似中，重叠矩阵是单位矩阵，$S = I$。体系的电子结构由哈密顿矩阵的本征值 $\\epsilon_n$ 和本征矢量 $\\mathbf{c}^{(n)}$ 描述，它们是矩阵形式的定态薛定谔方程的解：\n$$\nH\\mathbf{c}^{(n)} = \\epsilon_n \\mathbf{c}^{(n)}\n$$\n这里，$\\epsilon_n$ 代表第 $n$ 个分子轨道（或在周期性体系中的晶体轨道）的能量，而本征矢量 $\\mathbf{c}^{(n)}$ 包含描述第 $i$ 个原子轨道对第 $n$ 个分子轨道贡献的系数 $c_i^{(n)}$。\n\nCOHP 分析的核心是将能带能量 $E_{\\text{band}} = \\sum_{n \\in \\text{occ}} \\epsilon_n$ 分解为成对的轨道贡献。与轨道 $i$ 和 $j$ 之间相互作用相关的能量贡献由布居加权的哈密顿矩阵元 $P_{ij}H_{ij}$ 给出，其中 $P$ 是密度矩阵。对于单个本征态 $n$，这个贡献是 $c_i^{(n)} c_j^{(n)} H_{ij}$。COHP 定义时带有一个负号，即 $-\\mathrm{COHP}_{ij}(E)$，这样负值（对于通常为负的非对角元 $H_{ij}$，来源于 $c_i^{(n)} c_j^{(n)} H_{ij}  0$）表示成键相互作用，而正值表示反键相互作用。\n\n该问题要求在零温近似（$T=0$）下进行直至费米能级 $E_{\\mathrm{F}}$ 的积分分析。这意味着我们只考虑占据的本征态，即能量 $\\epsilon_n \\le E_{\\mathrm{F}}$ 的那些态。计算所要求的量——$E_{\\text{bond}}$、$E_{\\text{antibond}}$、$E_{\\text{ads}}$ 和 $r$——的算法如下。\n\n1.  **对角化**：第一步是求解给定的实对称哈密顿矩阵 $H$ 的本征值问题。这将得到一套完备的实数本征值 $\\{\\epsilon_n\\}$ 和一套相应的正交归一化本征矢量 $\\{\\mathbf{c}^{(n)}\\}$。\n\n2.  **态分辨的相互作用总和**：对于每个本征态 $n$，我们计算一个量，称之为 $Y_n$，它代表了所有指定的吸附质-衬底相互作用 $(i,j)$ 对该态能量的总贡献。它被定义为在给定原子对上对单个类 COHP 项求和：\n    $$\n    Y_n = -\\sum_{(i,j) \\in \\text{pairs}} c_i^{(n)} c_j^{(n)} H_{ij}\n    $$\n    在这里，$Y_n$ 的负值表示态 $n$ 相对于吸附质-衬底界面具有净成键特性，而正值表示净反键特性。\n\n3.  **对占据态进行累加**：我们将总成键能 $E_{\\text{bond}}$ 和总反键能 $E_{\\text{antibond}}$ 初始化为零。然后我们遍历每个本征态 $n$。如果一个态是占据的（$\\epsilon_n \\le E_{\\mathrm{F}}$），我们就分析它的贡献：\n    -   成键贡献是所有占据态的 $Y_n$ 的负值部分之和。\n    -   反键贡献是所有占据态的 $Y_n$ 的正值部分之和。\n    通过将这些和乘以自旋简并因子 $g=2$ 来获得总能量。\n    算法如下：\n    对于每个本征态 $n=0, \\dots, N-1$：\n    如果 $\\epsilon_n \\le E_{\\mathrm{F}}$：\n        计算 $Y_n = -\\sum_{(i,j) \\in \\text{pairs}} c_i^{(n)} c_j^{(n)} H_{ij}$。\n        如果 $Y_n  0$：\n            $E_{\\text{bond}} \\leftarrow E_{\\text{bond}} + g \\cdot Y_n$\n        如果 $Y_n  0$：\n            $E_{\\text{antibond}} \\leftarrow E_{\\text{antibond}} + g \\cdot Y_n$\n\n4.  **最终指标的计算**：在完成对所有占据态的求和后，计算最终的量：\n    -   净吸附结合能的替代值 $E_{\\text{ads}}$ 是成键和反键分量的总和：\n        $$\n        E_{\\text{ads}} = E_{\\text{bond}} + E_{\\text{antibond}}\n        $$\n    -   反键分数 $r$ 用于量化非稳定相互作用的相对重要性，其定义为：\n        $$\n        r = \\begin{cases} \\frac{E_{\\text{antibond}}}{|E_{\\text{bond}}|}  \\text{若 } |E_{\\text{bond}}|  0 \\\\ 0  \\text{若 } |E_{\\text{bond}}| = 0 \\end{cases}\n        $$\n\n这个过程提供了对吸附质-衬底相互作用能的定量分解，为理解界面化学键的本质提供了见解。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the COHP analysis problem for a given set of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"H\": np.array([\n                [0.0, -2.0, -1.0],\n                [-2.0, 0.0, -0.5],\n                [-1.0, -0.5, -5.0]\n            ]),\n            \"E_F\": -0.5,\n            \"pairs\": [(2, 0), (2, 1)]\n        },\n        {\n            \"H\": np.array([\n                [0.0, -2.0, -0.1],\n                [-2.0, 0.0, -0.05],\n                [-0.1, -0.05, -5.0]\n            ]),\n            \"E_F\": -0.5,\n            \"pairs\": [(2, 0), (2, 1)]\n        },\n        {\n            \"H\": np.array([\n                [0.0, -2.0, -1.5],\n                [-2.0, 0.0, -1.0],\n                [-1.5, -1.0, -5.0]\n            ]),\n            \"E_F\": 1.0,\n            \"pairs\": [(2, 0), (2, 1)]\n        },\n        {\n            \"H\": np.array([\n                [0.0, -2.0, 0.0],\n                [-2.0, 0.0, 0.0],\n                [0.0, 0.0, -5.0]\n            ]),\n            \"E_F\": -0.5,\n            \"pairs\": [(2, 0), (2, 1)]\n        }\n    ]\n\n    all_results = []\n    g = 2.0  # Spin degeneracy factor\n\n    for case in test_cases:\n        H = case[\"H\"]\n        E_F = case[\"E_F\"]\n        pairs = case[\"pairs\"]\n\n        # Step 1: Diagonalize the Hamiltonian\n        # np.linalg.eigh is used for Hermitian (or real symmetric) matrices.\n        # It returns eigenvalues in ascending order and corresponding normalized eigenvectors.\n        eigenvalues, eigenvectors = np.linalg.eigh(H)\n        \n        # Initialize accumulators\n        E_bond = 0.0\n        E_antibond = 0.0\n        \n        # Step 2  3: Iterate over eigenstates, check occupation, and accumulate contributions\n        num_states = H.shape[0]\n        for n in range(num_states):\n            epsilon_n = eigenvalues[n]\n            \n            # Check if the state is occupied\n            if epsilon_n = E_F:\n                c_n = eigenvectors[:, n] # nth eigenvector as a column\n                \n                # Calculate the state-resolved interaction sum Y_n\n                Y_n = 0.0\n                for i, j in pairs:\n                    # H is symmetric, so H_ij = H_ji\n                    Y_n -= c_n[i] * c_n[j] * H[i, j]\n                \n                # Decompose into bonding and antibonding contributions\n                if Y_n  0:\n                    E_bond += g * Y_n\n                elif Y_n > 0:\n                    E_antibond += g * Y_n\n        \n        # Step 4: Final calculations\n        E_ads = E_bond + E_antibond\n        \n        if abs(E_bond) > 1e-9: # Use a small tolerance for floating point comparison\n            r = E_antibond / abs(E_bond)\n        else:\n            r = 0.0\n            \n        result_tuple = [\n            round(E_bond, 6), \n            round(E_antibond, 6), \n            round(E_ads, 6), \n            round(r, 6)\n        ]\n        all_results.append(result_tuple)\n\n    # Format the final output string as specified\n    case_strings = []\n    for res in all_results:\n        # Format each number to 6 decimal places and join with commas\n        formatted_res = f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f},{res[3]:.6f}]\"\n        case_strings.append(formatted_res)\n    \n    # Join the individual case strings and enclose in brackets\n    final_output_string = f\"[{','.join(case_strings)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}