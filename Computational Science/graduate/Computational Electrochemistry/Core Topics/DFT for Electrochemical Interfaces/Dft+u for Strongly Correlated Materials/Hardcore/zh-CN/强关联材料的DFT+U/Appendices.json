{
    "hands_on_practices": [
        {
            "introduction": "在进行任何基于平面波的DFT+U计算之前，首要任务是确保结果的数值可靠性。计算的准确性严重依赖于两个关键的数值参数：平面波截断能（$E_{\\mathrm{cut}}$）和布里渊区$k$点采样的密度。本练习  将指导你通过一个计算实验，系统地评估这些参数的收敛性，这是一个任何严谨的计算研究所必需的基础步骤。",
            "id": "4242214",
            "problem": "要求您设计并实现一个程序，用于评估密度泛函理论加哈伯德 $U$ (DFT+$U$) 计算，针对一个模型关联氧化物，在平面波截断能和布里渊区采样密度（表示为 $k$ 点网格）方面的收敛性。您的程序必须使用一个科学上合理的代理模型来描述总能量和力中的离散化误差，并且必须根据明确定义的标准提出可靠的设置。目标是编写出计算电化学家会遵循的逻辑，以确保在平面波 DFT+$U$ 计算中获得可靠的总能量和力，而无需调用任何外部模拟引擎。\n\n推导应基于以下基本原则和广泛接受的标度律事实：\n- 总能量的平面波基组不完备性误差随平面波动能截断 $E_{\\mathrm{cut}}$ 以幂律形式衰减，因为波函数和电荷密度的傅里叶表示会随着所包含的最大平面波矢量的增加而代数收敛。这可以用指数 $p$ 和一个依赖于 $U$ 的前置因子 $a(U)$ 来表示，即能量误差贡献为 $\\propto a(U)\\,E_{\\mathrm{cut}}^{-p}$。\n- 布里渊区积分（有限 $k$ 点采样）误差随着 $k$ 点总数 $N_k$ 以幂律形式衰减，其指数 $q(U)$ 取决于电子结构。对于金属性体系（小带隙或无带隙），$q(U)$ 小于绝缘性体系（有限带隙），因为后者的被积函数更平滑。此贡献表示为 $\\propto b(U)\\,N_k^{-q(U)}$。\n- DFT+$U$ 中的哈伯德修正会改变在位电子相互作用，通常会在关联氧化物中打开一个随 $U$ 增大的能隙。这会改变布里渊区被积函数的平滑度，从而改变 $k$ 点收敛的有效指数 $q(U)$。它还会改变前置因子 $a(U)$ 和 $b(U)$，因为波函数的特性以及对基组和采样的敏感性会随着带隙的变化而变化。\n- 力的误差遵循类似的趋势，其基组（类 Pulay）贡献和布里渊区采样贡献也随 $E_{\\mathrm{cut}}$ 和 $N_k$ 以幂律形式衰减，但其指数和前置因子可能与总能量的不同。\n\n为了创建一个通用的、可测试的程序，请采用以下编码了上述原则的代理误差模型：\n- 定义一个有效带隙 $E_{\\mathrm{g}}(U)$，它随 $U$ 增大而增加，并在一个对关联氧化物而言物理上现实的上限处饱和：\n$$\nE_{\\mathrm{g}}(U)=\\min\\left(0.5\\,U,\\ 3.0\\right)\\ \\text{(单位为 eV)}。\n$$\n- 对能量和力的误差使用幂律指数：\n$$\np=2.1,\\quad q(U)=1.1+0.9\\,\\tanh\\!\\left(\\frac{E_{\\mathrm{g}}(U)}{1.5}\\right),\\quad r=1.2,\\quad s(U)=0.9+0.8\\,\\tanh\\!\\left(\\frac{E_{\\mathrm{g}}(U)}{1.5}\\right).\n$$\n- 使用随带隙增大而减小的、依赖于 $U$ 的前置因子：\n$$\na(U)=\\frac{100.0}{1.0+E_{\\mathrm{g}}(U)},\\quad b(U)=\\frac{5.0}{1.0+E_{\\mathrm{g}}(U)},\\quad f_a(U)=\\frac{20.0}{1.0+E_{\\mathrm{g}}(U)},\\quad f_b(U)=\\frac{2.0}{1.0+E_{\\mathrm{g}}(U)}.\n$$\n- 将代理总能量 $E_{\\mathrm{model}}(U,E_{\\mathrm{cut}},N_k)$ 建模为一个真实但未知的基线 $E_{\\mathrm{true}}(U)$ 加上来自基组不完备性和 $k$ 点采样的离散化误差，并包含一个弱交叉项以模拟耦合误差：\n$$\nE_{\\mathrm{model}}(U,E_{\\mathrm{cut}},N_k)=E_{\\mathrm{true}}(U)+a(U)\\,E_{\\mathrm{cut}}^{-p}+b(U)\\,N_k^{-q(U)}+\\frac{1}{2}\\sqrt{a(U)\\,b(U)}\\,E_{\\mathrm{cut}}^{-p/2}\\,N_k^{-q(U)/2}.\n$$\n- 将平衡构型下的代理力的大小 $F_{\\mathrm{model}}(U,E_{\\mathrm{cut}},N_k)$（此时物理力为零，仅剩下数值误差）建模为：\n$$\nF_{\\mathrm{model}}(U,E_{\\mathrm{cut}},N_k)=f_a(U)\\,E_{\\mathrm{cut}}^{-r}+f_b(U)\\,N_k^{-s(U)}+0.3\\,\\sqrt{f_a(U)\\,f_b(U)}\\,E_{\\mathrm{cut}}^{-r/2}\\,N_k^{-s(U)/2}.\n$$\n- 为了在不同设置间进行数值比较，您可以将基线设置为一个简单的关于 $U$ 的线性形式 $E_{\\mathrm{true}}(U)=-100.0+0.1\\,U$ (单位为 eV)，并注意在通过与一个共同的高精度参考值的差异来评估收敛性时，实际值会相互抵消。\n\n使用标准计算实践来定义可靠性标准：\n- 对于一个候选设置 $\\left(E_{\\mathrm{cut}},\\mathbf{k}\\right)$，其中 $\\mathbf{k}=(n_x,n_y,n_z)$ 且 $N_k=n_x n_y n_z$，使用测试用例中可用的最大 $E_{\\mathrm{cut}}$ 和最密集的 $k$ 点网格（最大的 $N_k$）来计算参考能量 $E_{\\mathrm{ref}}$。如果满足以下条件，则候选设置是能量收敛的：\n$$\n\\left|E_{\\mathrm{model}}(U,E_{\\mathrm{cut}},N_k)-E_{\\mathrm{ref}}\\right|\\le \\varepsilon_E,\n$$\n其中 $\\varepsilon_E$ 是指定的能量容差（单位为 eV）。\n- 如果满足以下条件，则候选设置是力收敛的：\n$$\nF_{\\mathrm{model}}(U,E_{\\mathrm{cut}},N_k)\\le \\varepsilon_F,\n$$\n其中 $\\varepsilon_F$ 是指定的力容差（单位为 eV/\\AA）。\n- 如果一个候选设置同时满足能量收敛和力收敛，则该设置是可靠的。在所有可靠的候选设置中，选择使计算成本的简单代理最小化的一个，该代理与基组大小和 $k$ 点数量的乘积成正比：\n$$\nC(E_{\\mathrm{cut}},N_k)=E_{\\mathrm{cut}}^{1.5}\\,N_k.\n$$\n如果没有候选设置同时满足这两个标准，则报告未达到收敛，并报告在所提供的设置中观察到的最小能量差和最小力的大小。\n\n物理单位：\n- 平面波截断 $E_{\\mathrm{cut}}$ 必须以 eV 为单位指定。\n- 能量差必须以 eV 为单位。\n- 力的大小必须以 eV/\\AA 为单位。\n\n本问题不使用角度单位。\n\n您的程序必须实现代理模型，为每个测试用例评估所有候选设置，应用可靠性标准，在可能的情况下选择推荐的设置，并按如下规定将结果汇总到单行中。\n\n测试套件：\n请精确实现以下四个测试用例。在每个用例中，$U$ 的单位是 eV，$E_{\\mathrm{cut}}$ 值的单位是 eV，$k$ 点网格是整数三元组 $(n_x,n_y,n_z)$，总点数 $N_k=n_x n_y n_z$，容差以 $(\\varepsilon_E,\\varepsilon_F)$ 的形式给出，单位为 $(\\text{eV},\\ \\text{eV}/\\AA)$。\n- 用例 1：$U=4.0$；$E_{\\mathrm{cut}}\\in\\{350.0,400.0,450.0,500.0,600.0\\}$；$k$ 点网格 $\\{(4,4,4),(6,6,6),(8,8,8)\\}$；容差 $(\\varepsilon_E,\\varepsilon_F)=(0.001,0.005)$。\n- 用例 2：$U=0.0$；$E_{\\mathrm{cut}}\\in\\{350.0,400.0,500.0,600.0\\}$；$k$ 点网格 $\\{(2,2,2),(4,4,4),(6,6,6)\\}$；容差 $(\\varepsilon_E,\\varepsilon_F)=(0.001,0.005)$。\n- 用例 3：$U=6.0$；$E_{\\mathrm{cut}}\\in\\{300.0,350.0,400.0\\}$；$k$ 点网格 $\\{(3,3,3),(4,4,4)\\}$；容差 $(\\varepsilon_E,\\varepsilon_F)=(0.001,0.005)$。\n- 用例 4：$U=3.0$；$E_{\\mathrm{cut}}\\in\\{300.0,320.0,340.0\\}$；$k$ 点网格 $\\{(2,2,2)\\}$；容差 $(\\varepsilon_E,\\varepsilon_F)=(0.0005,0.002)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个测试用例的结果，形式为由列表组成的、以逗号分隔的列表，并包含在方括号中。每个内部列表必须按以下顺序包含五个条目：\n$[\\text{converged},E_{\\mathrm{cut}}^{\\star},N_k^{\\star},\\Delta E^{\\star},F^{\\star}]$，其中：\n- 如果找到可靠的设置，$\\text{converged}$ 为 $1$，否则为 $0$。\n- $E_{\\mathrm{cut}}^{\\star}$ 是推荐的平面波截断能（单位为 eV），如果未收敛则为 $-1$。\n- $N_k^{\\star}$ 是推荐的 $k$ 点总数，如果未收敛则为 $-1$。\n- $\\Delta E^{\\star}$ 是在推荐设置下与参考值的绝对能量差（如果未收敛，则为观察到的最小差值），单位为 eV，四舍五入到六位小数。\n- $F^{\\star}$ 是在推荐设置下的力的大小（如果未收敛，则为观察到的最小力的大小），单位为 eV/\\AA，四舍五入到六位小数。\n\n整个输出必须是如下所示的单行：\n$[[\\dots],[\\dots],[\\dots],[\\dots]]$\n不含任何额外的字符或空格。",
            "solution": "该问题要求设计并实现一个程序，以确定密度泛函理论加哈伯德 $U$ (DFT+$U$) 计算的最佳计算设置，这是基于一个提供的关于数值误差的代理模型。此任务模拟了计算材料科学中标准的收敛性测试工作流程。解决方案的结构是首先实现代理模型的数学函数，然后创建一个算法，根据指定的可靠性和成本标准系统地评估候选设置。\n\n问题的核心在于为总能量 $E_{\\mathrm{model}}$ 和原子力大小 $F_{\\mathrm{model}}$ 提供的代理模型，它们是哈伯德参数 $U$、平面波动能截断 $E_{\\mathrm{cut}}$ 和布里渊区采样点总数 $N_k$ 的函数。\n\n首先，我们形式化代理模型的各个组成部分。模型的行为主要由一个有效的电子带隙 $E_{\\mathrm{g}}(U)$ 控制，该带隙取决于哈伯德 $U$ 参数。这是一个关键的物理特征，因为带隙的存在与大小会显著影响数值收敛性。有效带隙由以下公式给出：\n$$\nE_{\\mathrm{g}}(U) = \\min(0.5 \\cdot U, 3.0)\n$$\n其中 $U$ 的单位为 eV。该函数模拟了带隙随 $U$ 增大而打开，并在一个对关联氧化物而言现实的值 $3.0\\,\\text{eV}$ 处饱和的现象。\n\n能量和力关于 $E_{\\mathrm{cut}}$ 和 $N_k$ 的收敛性由幂律描述。这些幂律的指数要么是常数，要么依赖于带隙 $E_{\\mathrm{g}}(U)$。这些指数是：\n- $p = 2.1$ (能量误差 vs. $E_{\\mathrm{cut}}$)\n- $q(U) = 1.1 + 0.9 \\cdot \\tanh\\left(\\frac{E_{\\mathrm{g}}(U)}{1.5}\\right)$ (能量误差 vs. $N_k$)\n- $r = 1.2$ (力误差 vs. $E_{\\mathrm{cut}}$)\n- $s(U) = 0.9 + 0.8 \\cdot \\tanh\\left(\\frac{E_{\\mathrm{g}}(U)}{1.5}\\right)$ (力误差 vs. $N_k$)\n\n双曲正切函数 $\\tanh$ 为指数 $q$ 和 $s$ 提供了一个平滑的过渡，当体系从金属性（$E_{\\mathrm{g}} \\approx 0$）变为绝缘性（$E_{\\mathrm{g}}  0$）时。\n\n这些幂律的前置因子也依赖于带隙，这模拟了有带隙的体系通常对离散化误差不太敏感这一事实：\n- $a(U) = \\frac{100.0}{1.0 + E_{\\mathrm{g}}(U)}$ (能量 vs. $E_{\\mathrm{cut}}$ 前置因子)\n- $b(U) = \\frac{5.0}{1.0 + E_{\\mathrm{g}}(U)}$ (能量 vs. $N_k$ 前置因子)\n- $f_a(U) = \\frac{20.0}{1.0 + E_{\\mathrm{g}}(U)}$ (力 vs. $E_{\\mathrm{cut}}$ 前置因子)\n- $f_b(U) = \\frac{2.0}{1.0 + E_{\\mathrm{g}}(U)}$ (力 vs. $N_k$ 前置因子)\n\n总模型能量 $E_{\\mathrm{model}}$ 和力的大小 $F_{\\mathrm{model}}$ 是这些误差贡献的总和，包括一个弱交叉项以解释非加性效应：\n$$\nE_{\\mathrm{model}}(U, E_{\\mathrm{cut}}, N_k) = E_{\\mathrm{true}}(U) + a(U)E_{\\mathrm{cut}}^{-p} + b(U)N_k^{-q(U)} + \\frac{1}{2}\\sqrt{a(U)b(U)} E_{\\mathrm{cut}}^{-p/2} N_k^{-q(U)/2}\n$$\n$$\nF_{\\mathrm{model}}(U, E_{\\mathrm{cut}}, N_k) = f_a(U)E_{\\mathrm{cut}}^{-r} + f_b(U)N_k^{-s(U)} + 0.3\\sqrt{f_a(U)f_b(U)} E_{\\mathrm{cut}}^{-r/2} N_k^{-s(U)/2}\n$$\n基线能量给出为 $E_{\\mathrm{true}}(U) = -100.0 + 0.1 \\cdot U$。\n\n每个测试用例的算法流程如下：\n1.  **初始化**：对于给定的测试用例，其参数包括 $U$、一系列 $E_{\\mathrm{cut}}$ 值和 $k$ 点网格，以及容差 $(\\varepsilon_E, \\varepsilon_F)$，首先计算依赖于 $U$ 的模型参数：$E_{\\mathrm{g}}(U)$、$q(U)$、$s(U)$ 和所有前置因子。对每个网格，计算 $k$ 点总数 $N_k = n_x n_y n_z$。\n\n2.  **参考计算**：计算一个高精度的参考能量 $E_{\\mathrm{ref}}$。这是通过使用测试用例中提供的最大可用 $E_{\\mathrm{cut}}$ 和最大可用 $N_k$ 来评估 $E_{\\mathrm{model}}$ 完成的。这模仿了使用计算成本最高的设置作为基准的实际方法。\n\n3.  **候选设置评估**：算法遍历所提供集合中 $(E_{\\mathrm{cut}}, N_k)$ 的每个可能组合。对于每个候选设置：\n    a. 计算 $E_{\\mathrm{model}}$ 和 $F_{\\mathrm{model}}$。\n    b. 计算与参考值的绝对能量差：$\\Delta E = |E_{\\mathrm{model}} - E_{\\mathrm{ref}}|$。\n    c. 通过与容差比较来检查设置是否可靠：\n       - 能量收敛：$\\Delta E \\le \\varepsilon_E$。\n       - 力收敛：$F_{\\mathrm{model}} \\le \\varepsilon_F$。\n    d. 如果一个设置是可靠的（同时满足两个标准），则将其添加到一个可靠候选设置的列表中。\n    e. 在此过程中，会分别跟踪所有候选设置中观察到的最小 $\\Delta E$ 和最小 $F_{\\mathrm{model}}$。如果没有找到可靠的设置，则使用这些值。\n\n4.  **最优设置选择**：\n    a. 如果可靠候选设置的列表不为空，算法将继续寻找计算效率最高的一个。计算成本 $C$ 估计为 $C(E_{\\mathrm{cut}}, N_k) = E_{\\mathrm{cut}}^{1.5} \\cdot N_k$。选择成本最低的可靠候选设置作为推荐设置 $(E_{\\mathrm{cut}}^{\\star}, N_k^{\\star})$。结果被标记为收敛（标志为 1）。\n    b. 如果可靠候选设置的列表为空，则该用例被标记为未收敛（标志为 0），并将推荐设置设为占位符值，$E_{\\mathrm{cut}}^{\\star} = -1.0$ 和 $N_k^{\\star} = -1$。\n\n5.  **输出格式化**：测试用例的最终结果被组合成一个包含五个值的列表：$[\\text{converged}, E_{\\mathrm{cut}}^{\\star}, N_k^{\\star}, \\Delta E^{\\star}, F^{\\star}]$。\n    - 对于收敛的用例，$\\Delta E^{\\star}$ 和 $F^{\\star}$ 是在推荐设置下的能量差和力的大小。\n    - 对于未收敛的用例，$\\Delta E^{\\star}$ 和 $F^{\\star}$ 分别是观察到的最小能量差和最小力的大小。\n    - 根据要求，所有能量和力的值都四舍五入到六位小数。对所有测试用例重复此过程，并将最终结果汇总到单行输出中。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Evaluates DFT+U convergence for model correlated oxides using a surrogate model.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"U\": 4.0,\n            \"E_cut_values\": [350.0, 400.0, 450.0, 500.0, 600.0],\n            \"k_meshes\": [(4, 4, 4), (6, 6, 6), (8, 8, 8)],\n            \"tolerances\": (0.001, 0.005)\n        },\n        {\n            \"U\": 0.0,\n            \"E_cut_values\": [350.0, 400.0, 500.0, 600.0],\n            \"k_meshes\": [(2, 2, 2), (4, 4, 4), (6, 6, 6)],\n            \"tolerances\": (0.001, 0.005)\n        },\n        {\n            \"U\": 6.0,\n            \"E_cut_values\": [300.0, 350.0, 400.0],\n            \"k_meshes\": [(3, 3, 3), (4, 4, 4)],\n            \"tolerances\": (0.001, 0.005)\n        },\n        {\n            \"U\": 3.0,\n            \"E_cut_values\": [300.0, 320.0, 340.0],\n            \"k_meshes\": [(2, 2, 2)],\n            \"tolerances\": (0.0005, 0.002)\n        }\n    ]\n\n    all_results = []\n    \n    # Static exponents\n    p = 2.1\n    r = 1.2\n\n    for case in test_cases:\n        U = case[\"U\"]\n        E_cut_values = case[\"E_cut_values\"]\n        k_meshes = case[\"k_meshes\"]\n        epsilon_E, epsilon_F = case[\"tolerances\"]\n\n        # Calculate U-dependent parameters\n        E_g = min(0.5 * U, 3.0)\n        tanh_term = np.tanh(E_g / 1.5)\n        \n        q = 1.1 + 0.9 * tanh_term\n        s = 0.9 + 0.8 * tanh_term\n        \n        a = 100.0 / (1.0 + E_g)\n        b = 5.0 / (1.0 + E_g)\n        f_a = 20.0 / (1.0 + E_g)\n        f_b = 2.0 / (1.0 + E_g)\n        \n        E_true = -100.0 + 0.1 * U\n\n        def get_E_model(E_cut, Nk):\n            term1 = a * (E_cut ** -p)\n            term2 = b * (Nk ** -q)\n            cross_term = 0.5 * np.sqrt(a * b) * (E_cut ** (-p / 2.0)) * (Nk ** (-q / 2.0))\n            return E_true + term1 + term2 + cross_term\n\n        def get_F_model(E_cut, Nk):\n            term1 = f_a * (E_cut ** -r)\n            term2 = f_b * (Nk ** -s)\n            cross_term = 0.3 * np.sqrt(f_a * f_b) * (E_cut ** (-r / 2.0)) * (Nk ** (-s / 2.0))\n            return term1 + term2 + cross_term\n\n        def get_cost(E_cut, Nk):\n            return (E_cut ** 1.5) * Nk\n\n        Nk_values = [k[0] * k[1] * k[2] for k in k_meshes]\n        candidates = [(ecut, nk) for ecut in E_cut_values for nk in Nk_values]\n        \n        # Reference calculation\n        E_cut_ref = max(E_cut_values)\n        Nk_ref = max(Nk_values)\n        E_ref = get_E_model(E_cut_ref, Nk_ref)\n        \n        reliable_candidates = []\n        min_delta_E = float('inf')\n        min_F = float('inf')\n        \n        for ecut, nk in candidates:\n            E_model_val = get_E_model(ecut, nk)\n            F_model_val = get_F_model(ecut, nk)\n            \n            delta_E = abs(E_model_val - E_ref)\n            \n            if delta_E  min_delta_E:\n                min_delta_E = delta_E\n            if F_model_val  min_F:\n                min_F = F_model_val\n                \n            is_energy_converged = delta_E = epsilon_E\n            is_force_converged = F_model_val = epsilon_F\n            \n            if is_energy_converged and is_force_converged:\n                cost = get_cost(ecut, nk)\n                reliable_candidates.append({\n                    \"E_cut\": ecut, \"Nk\": nk, \"cost\": cost, \n                    \"delta_E\": delta_E, \"F\": F_model_val\n                })\n\n        if reliable_candidates:\n            best_candidate = min(reliable_candidates, key=lambda x: x['cost'])\n            result = [\n                1,\n                float(best_candidate[\"E_cut\"]),\n                int(best_candidate[\"Nk\"]),\n                round(best_candidate[\"delta_E\"], 6),\n                round(best_candidate[\"F\"], 6)\n            ]\n        else:\n            result = [\n                0,\n                -1.0,\n                -1,\n                round(min_delta_E, 6),\n                round(min_F, 6)\n            ]\n            \n        all_results.append(result)\n\n    # Format the final output string exactly as specified\n    result_strings = [str(r).replace(\" \", \"\") for r in all_results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "DFT+U方法的预测能力在很大程度上取决于哈伯德参数$U$和双重计数方案的恰当选择。然而，这些参数并非普适，通常需要针对特定材料进行校准。本练习  模拟了这一关键研究过程，指导你通过一个稳健的基准测试流程，将计算得到的带隙与实验数据进行比较，从而确定最佳的参数组合。",
            "id": "4242185",
            "problem": "给定离散数据集，包含通过密度泛函理论加哈伯德参数 (DFT+U) 为两种双重计数校正方案——完全局域极限 (Fully Localized Limit, FLL) 和围绕平均场 (Around Mean Field, AMF)——计算出的科恩-尚 (Kohn–Sham) 带隙。任务是数学上评估计算出的带隙对双重计数方案选择和哈伯德参数 $U$ 的灵敏度，并构建一个针对实验光学吸收和光电发射可观测值的稳健基准度量。\n\n基本原理。DFT+U 能量泛函可以写成密度泛函理论 (DFT) 能量、一个 Hubbard 校正项减去一个双重计数项的形式，即 $E_{\\mathrm{DFT}+U} = E_{\\mathrm{DFT}} + E_U - E_{\\mathrm{DC}}$，其中 $E_U$ 取决于 $U$ 和局域化轨道的占据数，而 $E_{\\mathrm{DC}}$ 是双重计数校正。两种广泛使用的双重计数选择是完全局域极限 (FLL) 和围绕平均场 (AMF)。$U$ 的变化会改变相关子空间的分裂，从而改变带隙 $E_g$。光学吸收通常探测光学带隙 $E_g^{\\mathrm{opt}}$，由于激子结合能 $E_b$ 的存在，该值可能低于基本带隙。光电发射和反光电发射提供了基本带隙 $E_g^{\\mathrm{pes}}$ 的估计值。\n\n您的程序必须为每个提供的测试用例执行以下步骤：\n\n1. 灵敏度估计。给定一个 Hubbard 参数网格 $U_i$ (单位 $\\mathrm{eV}$) 以及相应计算出的带隙 $E_g^{\\mathrm{FLL}}(U_i)$ 和 $E_g^{\\mathrm{AMF}}(U_i)$ (单位 $\\mathrm{eV}$)，通过有限差分法计算方案 $s \\in \\{\\mathrm{FLL}, \\mathrm{AMF}\\}$ 的离散灵敏度 $S^{s}(U_i)$：\n   • 对于具有邻近点 $i-1$ 和 $i+1$ 的内部点 $i$，定义\n   $$S^{s}(U_i) = \\frac{E_g^{s}(U_{i+1}) - E_g^{s}(U_{i-1})}{U_{i+1} - U_{i-1}}.$$\n   • 对于端点，使用单边差分：\n   $$S^{s}(U_0) = \\frac{E_g^{s}(U_1) - E_g^{s}(U_0)}{U_1 - U_0}, \\quad S^{s}(U_{N-1}) = \\frac{E_g^{s}(U_{N-1}) - E_g^{s}(U_{N-2})}{U_{N-1} - U_{N-2}}.$$\n   以 $\\mathrm{eV}/\\mathrm{eV}$ 为单位，以浮点数形式报告灵敏度。\n\n2. 稳健基准损失。将光学校正后的基本目标值定义为 $E_g^{\\mathrm{opt}} + E_b$ (单位 $\\mathrm{eV}$)，并使用光电发射基本目标值 $E_g^{\\mathrm{pes}}$ (单位 $\\mathrm{eV}$)。对于给定的方案 $s$ 和参数 $U_i$，定义每个方案的组合稳健损失\n   $$L_s(U_i) = \\frac{1}{2}\\left(\\mathrm{Huber}\\left(E_g^s(U_i) - \\left(E_g^{\\mathrm{opt}} + E_b\\right), \\delta\\right) + \\mathrm{Huber}\\left(E_g^s(U_i) - E_g^{\\mathrm{pes}}, \\delta\\right)\\right),$$\n   其中 Huber 损失为\n   $$\\mathrm{Huber}(r, \\delta) = \\begin{cases}\n   \\frac{1}{2} r^2,  |r| \\le \\delta,\\\\\n   \\delta|r| - \\frac{1}{2} \\delta^2,  |r|  \\delta.\n   \\end{cases}$$\n   使用 $\\delta = 0.2$ $\\mathrm{eV}$。\n\n3. 方案和参数选择。找到使 $L_s(U_i)$ 在所有方案和所有网格点 $U_i$ 上最小化的方案 $s^\\ast \\in \\{\\mathrm{FLL}, \\mathrm{AMF}\\}$ 和参数 $U^\\ast$。如果在数值公差范围内，最小损失存在平局，则优先选择 $\\mathrm{FLL}$ 而非 $\\mathrm{AMF}$；如果对于所选方案，在多个 $U_i$ 上仍存在平局，则选择最小的 $U_i$。\n\n4. 要输出的摘要指标。对于每个测试用例，计算并输出以下项目列表：\n   • 所选方案索引的整数：$\\mathrm{FLL}$ 为 $0$，$\\mathrm{AMF}$ 为 $1$。\n   • 所选 $U^\\ast$ 的浮点数，单位 $\\mathrm{eV}$。\n   • 灵敏度 $S^{s^\\ast}(U^\\ast)$ (浮点数，单位 $\\mathrm{eV}/\\mathrm{eV}$)。\n   • 灵敏度比率 $S^{\\mathrm{FLL}}(U^\\ast)/S^{\\mathrm{AMF}}(U^\\ast)$ (浮点数；如果分母为零且分子非零，则返回 $\\infty$；如果分子和分母均为零，则返回 $1.0$)。\n   • 最小稳健损失 $L_{s^\\ast}(U^\\ast)$ 的浮点数，单位 $\\mathrm{eV}$。\n   • 一个布尔值 $b$ 指示拟合是否可接受，如果 $L_{s^\\ast}(U^\\ast) \\le T$ 则 $b = \\mathrm{True}$，否则 $b = \\mathrm{False}$，使用阈值 $T = 0.1$ $\\mathrm{eV}$。\n\n物理和数值单位。所有能量和 Hubbard 参数 $U$ 都必须以 $\\mathrm{eV}$ 为单位处理。灵敏度以 $\\mathrm{eV}/\\mathrm{eV}$ 为单位报告。不涉及角度。不需要百分比。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素本身都是包含上述六项的列表。例如：\n$$[ [\\text{case1\\_item1}, \\ldots, \\text{case1\\_item6}], [\\text{case2\\_item1}, \\ldots, \\text{case2\\_item6}], \\ldots ]$$\n\n测试套件。使用以下测试用例：\n\n测试用例 A (通用情况，斜率不同的单调函数)：\n• $U$ 网格：$[0, 1, 2, 3, 4, 5]$ $\\mathrm{eV}$。\n• $E_g^{\\mathrm{FLL}}(U)$：$[0.8, 1.5, 2.3, 3.1, 3.8, 4.5]$ $\\mathrm{eV}$。\n• $E_g^{\\mathrm{AMF}}(U)$：$[0.6, 1.0, 1.5, 1.9, 2.3, 2.7]$ $\\mathrm{eV}$。\n• $E_g^{\\mathrm{opt}} = 2.2$ $\\mathrm{eV}$，$E_g^{\\mathrm{pes}} = 2.8$ $\\mathrm{eV}$，$E_b = 0.4$ $\\mathrm{eV}$。\n\n测试用例 B (边界情况，对 $U$ 的依赖性较弱)：\n• $U$ 网格：$[0, 2, 4, 6, 8]$ $\\mathrm{eV}$。\n• $E_g^{\\mathrm{FLL}}(U)$：$[1.0, 1.1, 1.2, 1.25, 1.3]$ $\\mathrm{eV}$。\n• $E_g^{\\mathrm{AMF}}(U)$：$[0.9, 0.95, 1.0, 1.05, 1.1]$ $\\mathrm{eV}$。\n• $E_g^{\\mathrm{opt}} = 1.05$ $\\mathrm{eV}$，$E_g^{\\mathrm{pes}} = 1.2$ $\\mathrm{eV}$，$E_b = 0.1$ $\\mathrm{eV}$。\n\n测试用例 C (边缘情况，大 $U$ 值下饱和)：\n• $U$ 网格：$[0, 1, 2, 3, 4, 5, 6]$ $\\mathrm{eV}$。\n• $E_g^{\\mathrm{FLL}}(U)$：$[0.5, 1.2, 1.8, 2.2, 2.4, 2.5, 2.5]$ $\\mathrm{eV}$。\n• $E_g^{\\mathrm{AMF}}(U)$：$[0.4, 0.9, 1.3, 1.6, 1.8, 1.9, 1.9]$ $\\mathrm{eV}$。\n• $E_g^{\\mathrm{opt}} = 1.7$ $\\mathrm{eV}$，$E_g^{\\mathrm{pes}} = 2.1$ $\\mathrm{eV}$，$E_b = 0.3$ $\\mathrm{eV}$。\n\n请完全按照规定实现选择和报告规则，并为三个测试用例生成所需格式的单行输出。",
            "solution": "该问题陈述已经过严格审查，并被确定为有效。它在科学上基于计算材料科学的原理，特别是密度泛函理论 (DFT)，并且问题定义明确，提供了所有必要的数据、参数和定义，以获得唯一且可验证的解。该问题要求实现一个计算协议，用于对照实验数据对 DFT+U 计算进行基准测试，这是该领域的标准做法。\n\n该过程涉及四个主要步骤：估计计算出的带隙对 Hubbard 参数 $U$ 的灵敏度，定义并计算用于与实验可观测值进行比较的稳健损失函数，选择最佳的计算方案和参数，最后报告一组摘要指标。下文将详细介绍每个步骤，并遵循所提供的定义。所有数学量都将按要求以 LaTeX 格式呈现。\n\n其基本背景是 DFT+U 能量泛函 $E_{\\mathrm{DFT}+U} = E_{\\mathrm{DFT}} + E_U - E_{\\mathrm{DC}}$。双重计数校正 $E_{\\mathrm{DC}}$ 的选择会影响计算出的电子结构，包括基本带隙 $E_g$。我们获得了两种常用方案的数据，即完全局域极限 (Fully Localized Limit, FLL) 和围绕平均场 (Around Mean Field, AMF)。\n\n**步骤1：灵敏度估计**\n\n灵敏度 $S^{s}(U_i)$ 量化了对于给定方案 $s \\in \\{\\mathrm{FLL}, \\mathrm{AMF}\\}$，在特定点 $U_i$ 处带隙 $E_g^s$ 相对于 Hubbard 参数 $U$ 的变化率。它是导数 $\\frac{dE_g^s}{dU}$ 的数值近似。问题指定对离散 $U$ 网格的内部点使用中心差分公式，对端点使用单边有限差分。\n\n对于内部网格点 $U_i$，其中 $i \\in \\{1, 2, \\dots, N-2\\}$，灵敏度计算如下：\n$$S^{s}(U_i) = \\frac{E_g^{s}(U_{i+1}) - E_g^{s}(U_{i-1})}{U_{i+1} - U_{i-1}}$$\n这种二阶精确公式比一阶单边差分提供了更稳定的局部斜率估计。\n\n对于第一个点 $U_0$，使用前向差分：\n$$S^{s}(U_0) = \\frac{E_g^{s}(U_1) - E_g^{s}(U_0)}{U_1 - U_0}$$\n对于最后一个点 $U_{N-1}$，使用后向差分：\n$$S^{s}(U_{N-1}) = \\frac{E_g^{s}(U_{N-1}) - E_g^{s}(U_{N-2})}{U_{N-1} - U_{N-2}}$$\n对 FLL 和 AMF 两种方案，均在其各自的 $U$ 网格上计算这些灵敏度。单位为 $\\mathrm{eV}/\\mathrm{eV}$。\n\n**步骤2：稳健基准损失**\n\n需要一个损失函数来量化计算出的带隙 $E_g^s(U_i)$ 与实验测量值之间的差异。问题要求与两个不同的实验目标进行比较：\n1. 由激子结合能 $E_b$ 校正的光学吸收带隙 $E_g^{\\mathrm{opt}}$。这个总和 $E_g^{\\mathrm{opt}} + E_b$ 作为从光学测量中获得的基本带隙的估计值。\n2. 光电发射带隙 $E_g^{\\mathrm{pes}}$，这是通过光电发射和反光电发射光谱法直接测量的基本带隙。\n\n采用 Huber 损失函数以提供对异常值的稳健性。它结合了平方误差损失 (L2 范数) 对小残差的理想特性和绝对误差损失 (L1 范数) 对大残差的理想特性。对于残差 $r$，带有阈值参数 $\\delta$ 的 Huber 损失为：\n$$\\mathrm{Huber}(r, \\delta) = \\begin{cases}\n\\frac{1}{2} r^2,  \\text{if } |r| \\le \\delta \\\\\n\\delta|r| - \\frac{1}{2} \\delta^2,  \\text{if } |r|  \\delta\n\\end{cases}$$\n问题指定 $\\delta = 0.2$ $\\mathrm{eV}$。\n\n对于给定方案 $s$ 和参数 $U_i$ 的总稳健损失，记为 $L_s(U_i)$，是针对两个实验目标计算出的 Huber 损失的平均值：\n$$L_s(U_i) = \\frac{1}{2}\\left(\\mathrm{Huber}\\left(E_g^s(U_i) - \\left(E_g^{\\mathrm{opt}} + E_b\\right), \\delta\\right) + \\mathrm{Huber}\\left(E_g^s(U_i) - E_g^{\\mathrm{pes}}, \\delta\\right)\\right)$$\n\n**步骤3：方案和参数选择**\n\n方案 $s^\\ast$ 和参数 $U^\\ast$ 的最优组合是能够使稳健损失函数 $L_s(U_i)$ 在所有方案 $s$ 和所有网格点 $U_i$ 上最小化的组合。通过为每对 $(s, U_i)$ 计算 $L_s(U_i)$ 并找出最小值来执行优化。\n\n为确保结果的确定性，规定了具体的决胜规则：\n1. 如果 FLL 和 AMF 方案都达到了最小损失值，则优先选择 FLL 方案 ($s^\\ast = \\mathrm{FLL}$) 。\n2. 如果对于所选方案 $s^\\ast$，在多个 $U_i$ 值上都达到了最小损失，则选择最小的 $U_i$ 值作为 $U^\\ast$。\n\n**步骤4：摘要指标**\n\n在确定最优对 $(s^\\ast, U^\\ast)$ 后，必须计算一组六个摘要指标用于输出：\n1. **方案索引：** $s^\\ast$ 的整数表示，其中 $0$ 对应 FLL，$1$ 对应 AMF。\n2. **选定的 $U^\\ast$：** 最优 Hubbard 参数，单位为 $\\mathrm{eV}$。\n3. **灵敏度 $S^{s^\\ast}(U^\\ast)$：** 在最优参数 $U^\\ast$ 下，最优方案的预计算灵敏度，单位为 $\\mathrm{eV}/\\mathrm{eV}$。\n4. **灵敏度比率：** 比值 $S^{\\mathrm{FLL}}(U^\\ast) / S^{\\mathrm{AMF}}(U^\\ast)$。需要对分母为零的情况进行特殊处理：如果 $S^{\\mathrm{AMF}}(U^\\ast)=0$ 且 $S^{\\mathrm{FLL}}(U^\\ast) \\ne 0$，则值为无穷大。如果两者均为零，则值为 $1.0$。\n5. **最小损失 $L_{s^\\ast}(U^\\ast)$：** 损失函数的最小值，单位为 $\\mathrm{eV}$。\n6. **可接受性：** 一个布尔值，如果最小损失 $L_{s^\\ast}(U^\\ast)$ 小于或等于阈值 $T = 0.1$ $\\mathrm{eV}$，则为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。\n\n这些步骤构成了一个完整而严谨的工作流程，用于对照实验数据对计算方法进行基准测试，从而实现有原则的模型参数选择。对于每个提供的测试用例，实现将精确遵循此逻辑。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DFT+U benchmarking problem for a suite of test cases.\n    \"\"\"\n    \n    # Define physical and model constants from the problem statement\n    delta = 0.2  # Huber loss parameter in eV\n    loss_threshold = 0.1  # Acceptability threshold T in eV\n\n    # Test cases as provided in the problem statement\n    test_cases = [\n        {\n            \"U\": np.array([0., 1., 2., 3., 4., 5.]),\n            \"Eg_FLL\": np.array([0.8, 1.5, 2.3, 3.1, 3.8, 4.5]),\n            \"Eg_AMF\": np.array([0.6, 1.0, 1.5, 1.9, 2.3, 2.7]),\n            \"Eg_opt\": 2.2, \"Eg_pes\": 2.8, \"Eb\": 0.4\n        },\n        {\n            \"U\": np.array([0., 2., 4., 6., 8.]),\n            \"Eg_FLL\": np.array([1.0, 1.1, 1.2, 1.25, 1.3]),\n            \"Eg_AMF\": np.array([0.9, 0.95, 1.0, 1.05, 1.1]),\n            \"Eg_opt\": 1.05, \"Eg_pes\": 1.2, \"Eb\": 0.1\n        },\n        {\n            \"U\": np.array([0., 1., 2., 3., 4., 5., 6.]),\n            \"Eg_FLL\": np.array([0.5, 1.2, 1.8, 2.2, 2.4, 2.5, 2.5]),\n            \"Eg_AMF\": np.array([0.4, 0.9, 1.3, 1.6, 1.8, 1.9, 1.9]),\n            \"Eg_opt\": 1.7, \"Eg_pes\": 2.1, \"Eb\": 0.3\n        },\n    ]\n\n    def compute_sensitivity(U, Eg):\n        \"\"\"\n        Calculates the discrete sensitivity S^s(U_i) using finite differences.\n        \"\"\"\n        N = len(U)\n        S = np.zeros(N, dtype=float)\n        if N  2:\n            return S\n        # Endpoint: forward difference\n        S[0] = (Eg[1] - Eg[0]) / (U[1] - U[0])\n        # Interior points: central difference\n        for i in range(1, N - 1):\n            S[i] = (Eg[i+1] - Eg[i-1]) / (U[i+1] - U[i-1])\n        # Endpoint: backward difference\n        S[N-1] = (Eg[N-1] - Eg[N-2]) / (U[N-1] - U[N-2])\n        return S\n\n    def huber_loss(r, delta):\n        \"\"\"\n        Calculates the Huber loss for a given residual r and delta.\n        \"\"\"\n        abs_r = np.abs(r)\n        if abs_r = delta:\n            return 0.5 * r**2\n        else:\n            return delta * abs_r - 0.5 * delta**2\n\n    def calculate_total_loss(Eg_val, E_target1, E_target2, delta):\n        \"\"\"\n        Calculates the combined robust loss L_s(U_i).\n        \"\"\"\n        r1 = Eg_val - E_target1\n        r2 = Eg_val - E_target2\n        loss1 = huber_loss(r1, delta)\n        loss2 = huber_loss(r2, delta)\n        return 0.5 * (loss1 + loss2)\n\n    all_results = []\n    for case in test_cases:\n        U, Eg_FLL, Eg_AMF = case[\"U\"], case[\"Eg_FLL\"], case[\"Eg_AMF\"]\n        Eg_opt, Eg_pes, Eb = case[\"Eg_opt\"], case[\"Eg_pes\"], case[\"Eb\"]\n\n        # Step 1: Sensitivity estimation\n        S_FLL = compute_sensitivity(U, Eg_FLL)\n        S_AMF = compute_sensitivity(U, Eg_AMF)\n        \n        # Define experimental targets\n        E_target1 = Eg_opt + Eb\n        E_target2 = Eg_pes\n\n        min_loss = float('inf')\n        best_scheme_idx = -1\n        best_U_idx = -1\n\n        # Step 2  3: Compute losses and find minimum\n        # Iterate FLL (0) then AMF (1) to handle tie-breaking\n        schemes = [(0, Eg_FLL), (1, Eg_AMF)]\n        for s_idx, Eg_s in schemes:\n            for i in range(len(U)):\n                loss = calculate_total_loss(Eg_s[i], E_target1, E_target2, delta)\n                \n                # Update if a strictly smaller loss is found, or if loss is equal\n                # but scheme is preferred (FLL=0). This logic is simplified\n                # by iterating FLL first. The first time a minimum loss is found,\n                # it will be stored. Any subsequent find must be strictly smaller.\n                if loss  min_loss:\n                    min_loss = loss\n                    best_scheme_idx = s_idx\n                    best_U_idx = i\n\n        # Step 4: Summary metrics\n        chosen_scheme_idx = best_scheme_idx\n        chosen_U = U[best_U_idx]\n        \n        if chosen_scheme_idx == 0: # FLL\n            chosen_S = S_FLL[best_U_idx]\n        else: # AMF\n            chosen_S = S_AMF[best_U_idx]\n            \n        # Sensitivity ratio\n        s_fll_at_U_star = S_FLL[best_U_idx]\n        s_amf_at_U_star = S_AMF[best_U_idx]\n        \n        if s_amf_at_U_star == 0.0:\n            if s_fll_at_U_star == 0.0:\n                S_ratio = 1.0\n            else:\n                S_ratio = float('inf')\n        else:\n            S_ratio = s_fll_at_U_star / s_amf_at_U_star\n            \n        min_loss_val = min_loss\n        is_acceptable = min_loss_val = loss_threshold\n        \n        result_list = [\n            chosen_scheme_idx,\n            float(chosen_U),\n            float(chosen_S),\n            float(S_ratio),\n            float(min_loss_val),\n            is_acceptable\n        ]\n        all_results.append(result_list)\n        \n    # Format the final output as specified\n    output_str = f\"[{','.join(map(str, all_results)).replace(' ', '')}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在计算材料科学中，一个常见且重要的问题是：为一个体系（例如，一种晶型或氧化态）确定的$U$参数，能否被“迁移”并用于一个相关的体系？本练习  旨在解决这一问题，通过建立一个定量框架来评估$U$参数的可迁移性。你将学习使用线性响应模型来预测物理量的变化，并根据一套多标准准则来判断迁移是否“可接受”。",
            "id": "4242215",
            "problem": "考虑在计算电化学中，评估密度泛函理论加哈伯德U (DFT+U)中的在位库仑相互作用参数在同一化合物的不同结构相、多晶型或氧化态之间的可迁移性。其理论基础是密度泛函理论(DFT)的总能泛函，该泛函通过一个类哈伯德在位罚函数进行增强，该罚函数能够为强关联子空间恢复能量相对于在位轨道占据数的分段线性关系。在此设置中，一个外部标量控制参数，即有效在位相互作用$U$，用于调整局域态分数占据的能量惩罚。对于在一个有限区间内是$U$的光滑函数的可观测量，围绕一个已知参考点$U_{\\mathrm{ref}}$的一阶泰勒展开可以为每个可观测量生成一个线性代理模型。$U$从源环境到目标环境的可迁移性是可接受的，当且仅当同时满足三个条件：(i) 迁移在线性化被假定为有效的范围内进行，(ii) 预测的可观测量误差保持在用户指定的容差内，以及 (iii) 跨可观测量的聚合、加权、归一化差异保持在阈值以下。\n\n您将得到一组测试用例。每个测试用例定义了：\n- 一个源值$U_{\\mathrm{src}}$（单位为$\\mathrm{eV}$），将被迁移到一个已知参考值为$U_{\\mathrm{ref}}$（单位为$\\mathrm{eV}$）的目标环境中。\n- 一个线性化有效性界限$\\Delta U_{\\max}$（单位为$\\mathrm{eV}$），它指定了在目标环境中，一阶线性化被假定为有效的$U$偏差的最大允许量级。\n- 一组由$j$索引的可观测量，每个可观测量具有：\n  - 在$U_{\\mathrm{ref}}$处的参考可观测量值$\\mathcal{O}_{j}^{\\mathrm{ref}}$（单位根据具体可观测量指定），\n  - 一个灵敏度$s_{j}$，定义为在$U_{\\mathrm{ref}}$处的一阶导数$d\\mathcal{O}_{j}/dU$（单位为可观测量单位每$\\mathrm{eV}$），\n  - 一个目标值$\\mathcal{O}_{j}^{\\mathrm{target}}$（一个参考真值，例如，充分收敛的理论或实验基准），\n  - 一个容差$\\tau_{j}$（单位与$\\mathcal{O}_{j}$相同），\n  - 一个非负权重$w_{j}$（无量纲）。\n- 一个聚合阈值$\\varepsilon$（无量纲）。\n\n对于每个可观测量$j$，使用围绕$U_{\\mathrm{ref}}$的一阶泰勒展开来预测在$U_{\\mathrm{src}}$处的值：\n$$\n\\mathcal{O}_{j}^{\\mathrm{pred}} = \\mathcal{O}_{j}^{\\mathrm{ref}} + s_{j}\\,\\left(U_{\\mathrm{src}} - U_{\\mathrm{ref}}\\right).\n$$\n定义绝对误差\n$$\n\\delta_{j} = \\left| \\mathcal{O}_{j}^{\\mathrm{pred}} - \\mathcal{O}_{j}^{\\mathrm{target}} \\right|,\n$$\n和归一化误差\n$$\ne_{j} = \\frac{\\delta_{j}}{\\tau_{j}}.\n$$\n定义归一化误差的加权均方根 (WRMSE)\n$$\n\\mathrm{WRMSE} = \\sqrt{ \\frac{ \\sum_{j} w_{j}\\, e_{j}^{2} }{ \\sum_{j} w_{j} } }.\n$$\n迁移是可接受的，当且仅当所有三个条件都成立：\n- 线性化条件：$\\left| U_{\\mathrm{src}} - U_{\\mathrm{ref}} \\right| \\le \\Delta U_{\\max}$，\n- 单个可观测量条件：对于每一个$j$，$\\delta_{j} \\le \\tau_{j}$，\n- 聚合条件：$\\mathrm{WRMSE} \\le \\varepsilon$。\n\n实现一个程序，对于每个提供的测试用例，评估这些条件并返回一个布尔结果，指示迁移是否可接受。\n\n单位和约定：\n- 在位相互作用参数$U_{\\mathrm{src}}$和$U_{\\mathrm{ref}}$必须以$\\mathrm{eV}$为单位解释。\n- 带隙必须以$\\mathrm{eV}$为单位解释。\n- 磁矩必须以$\\mu_{B}$为单位解释。\n- 电压必须以$\\mathrm{V}$为单位解释。\n- 最终输出为无量纲的布尔值。\n\n测试套件：\n- 测试用例 $1$（相同化合物，良性多晶型迁移）：\n  - $U_{\\mathrm{src}} = 4.2\\,\\mathrm{eV}$，$U_{\\mathrm{ref}} = 4.0\\,\\mathrm{eV}$，$\\Delta U_{\\max} = 0.5\\,\\mathrm{eV}$，$\\varepsilon = 0.6$。\n  - 可观测量：\n    - 带隙：$\\mathcal{O}_{\\mathrm{gap}}^{\\mathrm{ref}} = 1.2\\,\\mathrm{eV}$，$s_{\\mathrm{gap}} = 0.8\\,\\mathrm{eV}/\\mathrm{eV}$，$\\mathcal{O}_{\\mathrm{gap}}^{\\mathrm{target}} = 1.35\\,\\mathrm{eV}$，$\\tau_{\\mathrm{gap}} = 0.2\\,\\mathrm{eV}$，$w_{\\mathrm{gap}} = 1.0$。\n    - 磁矩：$\\mathcal{O}_{\\mu}^{\\mathrm{ref}} = 3.8\\,\\mu_{B}$，$s_{\\mu} = 0.2\\,\\mu_{B}/\\mathrm{eV}$，$\\mathcal{O}_{\\mu}^{\\mathrm{target}} = 3.83\\,\\mu_{B}$，$\\tau_{\\mu} = 0.1\\,\\mu_{B}$，$w_{\\mu} = 0.5$。\n    - 电压：$\\mathcal{O}_{V}^{\\mathrm{ref}} = 3.95\\,\\mathrm{V}$，$s_{V} = 0.15\\,\\mathrm{V}/\\mathrm{eV}$，$\\mathcal{O}_{V}^{\\mathrm{target}} = 3.98\\,\\mathrm{V}$，$\\tau_{V} = 0.08\\,\\mathrm{V}$，$w_{V} = 2.0$。\n- 测试用例 $2$（不同氧化环境，强不匹配）：\n  - $U_{\\mathrm{src}} = 5.5\\,\\mathrm{eV}$，$U_{\\mathrm{ref}} = 3.5\\,\\mathrm{eV}$，$\\Delta U_{\\max} = 1.0\\,\\mathrm{eV}$，$\\varepsilon = 0.6$。\n  - 可观测量：\n    - 带隙：$\\mathcal{O}_{\\mathrm{gap}}^{\\mathrm{ref}} = 0.5\\,\\mathrm{eV}$，$s_{\\mathrm{gap}} = 0.5\\,\\mathrm{eV}/\\mathrm{eV}$，$\\mathcal{O}_{\\mathrm{gap}}^{\\mathrm{target}} = 1.3\\,\\mathrm{eV}$，$\\tau_{\\mathrm{gap}} = 0.4\\,\\mathrm{eV}$，$w_{\\mathrm{gap}} = 1.0$。\n    - 磁矩：$\\mathcal{O}_{\\mu}^{\\mathrm{ref}} = 4.1\\,\\mu_{B}$，$s_{\\mu} = 0.1\\,\\mu_{B}/\\mathrm{eV}$，$\\mathcal{O}_{\\mu}^{\\mathrm{target}} = 4.2\\,\\mu_{B}$，$\\tau_{\\mu} = 0.2\\,\\mu_{B}$，$w_{\\mu} = 0.5$。\n    - 电压：$\\mathcal{O}_{V}^{\\mathrm{ref}} = 4.0\\,\\mathrm{V}$，$s_{V} = 0.4\\,\\mathrm{V}/\\mathrm{eV}$，$\\mathcal{O}_{V}^{\\mathrm{target}} = 4.3\\,\\mathrm{V}$，$\\tau_{V} = 0.1\\,\\mathrm{V}$，$w_{V} = 2.0$。\n- 测试用例 $3$（具有近零灵敏度的多晶型，线性区域边界）：\n  - $U_{\\mathrm{src}} = 4.0\\,\\mathrm{eV}$，$U_{\\mathrm{ref}} = 4.6\\,\\mathrm{eV}$，$\\Delta U_{\\max} = 0.6\\,\\mathrm{eV}$，$\\varepsilon = 0.6$。\n  - 可观测量：\n    - 带隙：$\\mathcal{O}_{\\mathrm{gap}}^{\\mathrm{ref}} = 2.0\\,\\mathrm{eV}$，$s_{\\mathrm{gap}} = 0.0\\,\\mathrm{eV}/\\mathrm{eV}$，$\\mathcal{O}_{\\mathrm{gap}}^{\\mathrm{target}} = 2.0\\,\\mathrm{eV}$，$\\tau_{\\mathrm{gap}} = 0.05\\,\\mathrm{eV}$，$w_{\\mathrm{gap}} = 1.0$。\n    - 磁矩：$\\mathcal{O}_{\\mu}^{\\mathrm{ref}} = 3.0\\,\\mu_{B}$，$s_{\\mu} = 0.0\\,\\mu_{B}/\\mathrm{eV}$，$\\mathcal{O}_{\\mu}^{\\mathrm{target}} = 3.05\\,\\mu_{B}$，$\\tau_{\\mu} = 0.1\\,\\mu_{B}$，$w_{\\mu} = 0.5$。\n    - 电压：$\\mathcal{O}_{V}^{\\mathrm{ref}} = 3.2\\,\\mathrm{V}$，$s_{V} = -0.05\\,\\mathrm{V}/\\mathrm{eV}$，$\\mathcal{O}_{V}^{\\mathrm{target}} = 3.23\\,\\mathrm{V}$，$\\tau_{V} = 0.05\\,\\mathrm{V}$，$w_{V} = 2.0$。\n\n您的任务：\n- 实现一个程序，使用上述三个条件为每个测试用例评估$U$迁移的可接受性。\n- 最终输出必须生成为单行，其中包含按测试用例顺序排列的Python风格的布尔值列表，例如，对于三个测试用例为$[\\mathrm{True},\\mathrm{False},\\mathrm{True}]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$\\left[\\mathrm{result}_{1},\\mathrm{result}_{2},\\mathrm{result}_{3}\\right]$）。",
            "solution": "该问题要求在密度泛函理论加哈伯德U (DFT+U)计算的背景下，验证在位哈伯德相互作用参数$U$的可迁移性。从具有参数$U_{\\mathrm{src}}$的源环境到具有已知参考点$(U_{\\mathrm{ref}}, \\{\\mathcal{O}_{j}^{\\mathrm{ref}}\\})$的目标环境的迁移被认为是可接受的，当且仅当三个指定条件同时满足。我们将根据这三个条件分析每个测试用例。\n\n分析的核心是基于每个可观测量$\\mathcal{O}_{j}$围绕参考点$U_{\\mathrm{ref}}$的一阶泰勒展开，以预测其在$U_{\\mathrm{src}}$处的值：\n$$\n\\mathcal{O}_{j}^{\\mathrm{pred}} = \\mathcal{O}_{j}^{\\mathrm{ref}} + s_{j}\\,(U_{\\mathrm{src}} - U_{\\mathrm{ref}})\n$$\n其中$s_{j} = d\\mathcal{O}_{j}/dU|_{U_{\\mathrm{ref}}}$是灵敏度。\n\n可接受迁移的三个条件是：\n1.  **线性化条件：** $U$的偏差必须在线性模型的假定有效范围内：$| U_{\\mathrm{src}} - U_{\\mathrm{ref}} | \\le \\Delta U_{\\max}$。\n2.  **单个可观测量条件：** 每个可观测量的绝对误差$\\delta_{j} = | \\mathcal{O}_{j}^{\\mathrm{pred}} - \\mathcal{O}_{j}^{\\mathrm{target}} |$不得超过其指定的容差$\\tau_{j}$。这可以等效地使用归一化误差$e_{j} = \\delta_{j} / \\tau_{j}$表示为对所有$j$都有$e_{j} \\le 1$。\n3.  **聚合条件：** 归一化误差的加权均方根（WRMSE）必须低于全局阈值$\\varepsilon$。WRMSE定义为：\n    $$\n    \\mathrm{WRMSE} = \\sqrt{ \\frac{ \\sum_{j} w_{j}\\, e_{j}^{2} }{ \\sum_{j} w_{j} } }\n    $$\n    因此，该条件为$\\mathrm{WRMSE} \\le \\varepsilon$。\n\n我们现在基于此框架评估每个测试用例。\n\n### 测试用例 $1$\n\n参数为：$U_{\\mathrm{src}} = 4.2\\,\\mathrm{eV}$，$U_{\\mathrm{ref}} = 4.0\\,\\mathrm{eV}$，$\\Delta U_{\\max} = 0.5\\,\\mathrm{eV}$，以及$\\varepsilon = 0.6$。可观测数据在问题陈述中提供。哈伯德参数的差异为$\\Delta U = U_{\\mathrm{src}} - U_{\\mathrm{ref}} = 4.2 - 4.0 = 0.2\\,\\mathrm{eV}$。\n\n**1. 线性化条件：**\n我们检查是否$|\\Delta U| \\le \\Delta U_{\\max}$。\n$|0.2| \\le 0.5$。此条件满足。\n\n**2. 单个可观测量和聚合条件：**\n我们计算每个可观测量的预测值、误差和归一化误差。\n-   **带隙 ($j=1$):**\n    $\\mathcal{O}_{\\mathrm{gap}}^{\\mathrm{pred}} = \\mathcal{O}_{\\mathrm{gap}}^{\\mathrm{ref}} + s_{\\mathrm{gap}}\\,\\Delta U = 1.2\\,\\mathrm{eV} + (0.8\\,\\mathrm{eV}/\\mathrm{eV}) \\times (0.2\\,\\mathrm{eV}) = 1.36\\,\\mathrm{eV}$。\n    $\\delta_{\\mathrm{gap}} = |1.36 - 1.35|\\,\\mathrm{eV} = 0.01\\,\\mathrm{eV}$。\n    $e_{\\mathrm{gap}} = \\delta_{\\mathrm{gap}} / \\tau_{\\mathrm{gap}} = 0.01 / 0.2 = 0.05$。\n-   **磁矩 ($j=2$):**\n    $\\mathcal{O}_{\\mu}^{\\mathrm{pred}} = \\mathcal{O}_{\\mu}^{\\mathrm{ref}} + s_{\\mu}\\,\\Delta U = 3.8\\,\\mu_{B} + (0.2\\,\\mu_{B}/\\mathrm{eV}) \\times (0.2\\,\\mathrm{eV}) = 3.84\\,\\mu_{B}$。\n    $\\delta_{\\mu} = |3.84 - 3.83|\\,\\mu_{B} = 0.01\\,\\mu_{B}$。\n    $e_{\\mu} = \\delta_{\\mu} / \\tau_{\\mu} = 0.01 / 0.1 = 0.1$。\n-   **电压 ($j=3$):**\n    $\\mathcal{O}_{V}^{\\mathrm{pred}} = \\mathcal{O}_{V}^{\\mathrm{ref}} + s_{V}\\,\\Delta U = 3.95\\,\\mathrm{V} + (0.15\\,\\mathrm{V}/\\mathrm{eV}) \\times (0.2\\,\\mathrm{eV}) = 3.98\\,\\mathrm{V}$。\n    $\\delta_{V} = |3.98 - 3.98|\\,\\mathrm{V} = 0.0\\,\\mathrm{V}$。\n    $e_{V} = \\delta_{V} / \\tau_{V} = 0.0 / 0.08 = 0.0$。\n\n现在我们检查这些条件。\n**单个可观测量条件：** 是否所有$e_{j} \\le 1$？\n$e_{\\mathrm{gap}} = 0.05 \\le 1$。\n$e_{\\mu} = 0.1 \\le 1$。\n$e_{V} = 0.0 \\le 1$。\n此条件满足。\n\n**聚合条件：** 是否$\\mathrm{WRMSE} \\le \\varepsilon$？权重为$w_{\\mathrm{gap}} = 1.0$，$w_{\\mu} = 0.5$ 和 $w_{V} = 2.0$。\n$\\sum_{j} w_{j} = 1.0 + 0.5 + 2.0 = 3.5$。\n$\\sum_{j} w_{j}\\,e_{j}^2 = (1.0)(0.05)^2 + (0.5)(0.1)^2 + (2.0)(0.0)^2 = 0.0025 + 0.005 + 0 = 0.0075$。\n$\\mathrm{WRMSE} = \\sqrt{0.0075 / 3.5} \\approx \\sqrt{0.002143} \\approx 0.0463$。\n$0.0463 \\le 0.6$。此条件满足。\n\n**测试用例1的结论：** 所有三个条件均满足。迁移是**可接受的**。\n\n### 测试用例 $2$\n\n参数为：$U_{\\mathrm{src}} = 5.5\\,\\mathrm{eV}$，$U_{\\mathrm{ref}} = 3.5\\,\\mathrm{eV}$，$\\Delta U_{\\max} = 1.0\\,\\mathrm{eV}$，以及$\\varepsilon = 0.6$。差异为$\\Delta U = U_{\\mathrm{src}} - U_{\\mathrm{ref}} = 5.5 - 3.5 = 2.0\\,\\mathrm{eV}$。\n\n**1. 线性化条件：**\n我们检查是否$|\\Delta U| \\le \\Delta U_{\\max}$。\n$|2.0| \\le 1.0$。这是假的。\n\n**测试用例2的结论：** 线性化条件未满足。迁移是在线性模型的假定有效区域之外进行的。因此，迁移是**不可接受的**。其余条件无需评估。\n\n### 测试用例 $3$\n\n参数为：$U_{\\mathrm{src}} = 4.0\\,\\mathrm{eV}$，$U_{\\mathrm{ref}} = 4.6\\,\\mathrm{eV}$，$\\Delta U_{\\max} = 0.6\\,\\mathrm{eV}$，以及$\\varepsilon = 0.6$。差异为$\\Delta U = U_{\\mathrm{src}} - U_{\\mathrm{ref}} = 4.0 - 4.6 = -0.6\\,\\mathrm{eV}$。\n\n**1. 线性化条件：**\n我们检查是否$|\\Delta U| \\le \\Delta U_{\\max}$。\n$|-0.6| = 0.6 \\le 0.6$。此条件满足，因为它正好落在边界上。\n\n**2. 单个可观测量和聚合条件：**\n我们计算预测值和误差。\n-   **带隙 ($j=1$):**\n    $\\mathcal{O}_{\\mathrm{gap}}^{\\mathrm{pred}} = 2.0\\,\\mathrm{eV} + (0.0\\,\\mathrm{eV}/\\mathrm{eV}) \\times (-0.6\\,\\mathrm{eV}) = 2.0\\,\\mathrm{eV}$。\n    $\\delta_{\\mathrm{gap}} = |2.0 - 2.0|\\,\\mathrm{eV} = 0.0\\,\\mathrm{eV}$。\n    $e_{\\mathrm{gap}} = 0.0 / 0.05 = 0.0$。\n-   **磁矩 ($j=2$):**\n    $\\mathcal{O}_{\\mu}^{\\mathrm{pred}} = 3.0\\,\\mu_{B} + (0.0\\,\\mu_{B}/\\mathrm{eV}) \\times (-0.6\\,\\mathrm{eV}) = 3.0\\,\\mu_{B}$。\n    $\\delta_{\\mu} = |3.0 - 3.05|\\,\\mu_{B} = 0.05\\,\\mu_{B}$。\n    $e_{\\mu} = 0.05 / 0.1 = 0.5$。\n-   **电压 ($j=3$):**\n    $\\mathcal{O}_{V}^{\\mathrm{pred}} = 3.2\\,\\mathrm{V} + (-0.05\\,\\mathrm{V}/\\mathrm{eV}) \\times (-0.6\\,\\mathrm{eV}) = 3.2 + 0.03 = 3.23\\,\\mathrm{V}$。\n    $\\delta_{V} = |3.23 - 3.23|\\,\\mathrm{V} = 0.0\\,\\mathrm{V}$。\n    $e_{V} = 0.0 / 0.05 = 0.0$。\n\n现在我们检查这些条件。\n**单个可观测量条件：** 是否所有$e_{j} \\le 1$？\n$e_{\\mathrm{gap}} = 0.0 \\le 1$。\n$e_{\\mu} = 0.5 \\le 1$。\n$e_{V} = 0.0 \\le 1$。\n此条件满足。\n\n**聚合条件：** 是否$\\mathrm{WRMSE} \\le \\varepsilon$？权重为$w_{\\mathrm{gap}} = 1.0$，$w_{\\mu} = 0.5$ 和 $w_{V} = 2.0$。\n$\\sum_{j} w_{j} = 1.0 + 0.5 + 2.0 = 3.5$。\n$\\sum_{j} w_{j}\\,e_{j}^2 = (1.0)(0.0)^2 + (0.5)(0.5)^2 + (2.0)(0.0)^2 = 0 + 0.5 \\times 0.25 + 0 = 0.125$。\n$\\mathrm{WRMSE} = \\sqrt{0.125 / 3.5} \\approx \\sqrt{0.035714} \\approx 0.189$。\n$0.189 \\le 0.6$。此条件满足。\n\n**测试用例3的结论：** 所有三个条件均满足。迁移是**可接受的**。\n\n**最终结果摘要：**\n- 测试用例 $1$：可接受 (True)\n- 测试用例 $2$：不可接受 (False)\n- 测试用例 $3$：可接受 (True)\n最终的布尔结果列表是$[\\mathrm{True}, \\mathrm{False}, \\mathrm{True}]$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Evaluates the acceptability of U parameter transfer for a set of test cases\n    based on a DFT+U linear surrogate model.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"U_src\": 4.2, \"U_ref\": 4.0, \"delta_U_max\": 0.5, \"epsilon\": 0.6,\n            \"observables\": [\n                # (O_ref, s, O_target, tau, w)\n                (1.2, 0.8, 1.35, 0.2, 1.0),   # Band gap\n                (3.8, 0.2, 3.83, 0.1, 0.5),   # Magnetic moment\n                (3.95, 0.15, 3.98, 0.08, 2.0) # Voltage\n            ]\n        },\n        {\n            \"U_src\": 5.5, \"U_ref\": 3.5, \"delta_U_max\": 1.0, \"epsilon\": 0.6,\n            \"observables\": [\n                (0.5, 0.5, 1.3, 0.4, 1.0),\n                (4.1, 0.1, 4.2, 0.2, 0.5),\n                (4.0, 0.4, 4.3, 0.1, 2.0)\n            ]\n        },\n        {\n            \"U_src\": 4.0, \"U_ref\": 4.6, \"delta_U_max\": 0.6, \"epsilon\": 0.6,\n            \"observables\": [\n                (2.0, 0.0, 2.0, 0.05, 1.0),\n                (3.0, 0.0, 3.05, 0.1, 0.5),\n                (3.2, -0.05, 3.23, 0.05, 2.0)\n            ]\n        }\n    ]\n\n    def evaluate_case(case_data):\n        \"\"\"Evaluates a single test case for acceptability.\"\"\"\n        U_src = case_data[\"U_src\"]\n        U_ref = case_data[\"U_ref\"]\n        delta_U_max = case_data[\"delta_U_max\"]\n        epsilon = case_data[\"epsilon\"]\n        observables = case_data[\"observables\"]\n\n        # Condition 1: Linearization validity\n        delta_U = U_src - U_ref\n        if abs(delta_U) > delta_U_max:\n            return False\n\n        norm_errors_sq = []\n        weights = []\n\n        # Condition 2: Per-observable tolerance\n        for O_ref, s, O_target, tau, w in observables:\n            # Predict observable value using first-order Taylor expansion\n            O_pred = O_ref + s * delta_U\n            \n            # Calculate absolute and normalized error\n            delta_j = abs(O_pred - O_target)\n            \n            # Check per-observable condition\n            if delta_j > tau:\n                return False\n            \n            # The case tau=0 could happen if the prediction is perfect.\n            # Avoid division by zero, but problem constraints imply tau > 0.\n            e_j = delta_j / tau if tau > 0 else 0.0\n            \n            norm_errors_sq.append(e_j**2)\n            weights.append(w)\n        \n        # Condition 3: Aggregate discrepancy (WRMSE)\n        weights_np = np.array(weights)\n        norm_errors_sq_np = np.array(norm_errors_sq)\n        \n        sum_weights = np.sum(weights_np)\n        \n        # Avoid division by zero if all weights are zero.\n        if sum_weights == 0:\n            # If all weights are 0, WRMSE is undefined or 0.\n            # If WRMSE is 0, it passes the aggregate check.\n            wrmse = 0.0\n        else:\n            wrmse = np.sqrt(np.sum(weights_np * norm_errors_sq_np) / sum_weights)\n\n        if wrmse > epsilon:\n            return False\n\n        # If all three conditions are met\n        return True\n\n    results = [evaluate_case(case) for case in test_cases]\n    \n    # Format the final output string exactly as required\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}