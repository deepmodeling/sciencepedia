{
    "hands_on_practices": [
        {
            "introduction": "在投入编写代码实现任何数值方案之前，深刻理解其内在的稳定性至关重要。本练习将指导你为三种常见的时间步进格式——前向欧拉（Forward Euler）、后向欧拉（Backward Euler）和 Crank-Nicolson——推导其放大因子。这个推导是进行冯·诺依曼（von Neumann）稳定性分析的核心，它为我们选择合适的时间步长和预测数值方案的行为提供了坚实的理论基础。",
            "id": "4246127",
            "problem": "考虑一种稀的、电中性的电解质，其中盐浓度场 $c(x,t)$ 的时空演化由 Fick 第二扩散定律支配，\n$$\n\\frac{\\partial c}{\\partial t} \\;=\\; D\\,\\frac{\\partial^{2} c}{\\partial x^{2}},\n$$\n其中扩散系数 $D>0$ 为常数。将空间域离散化到一个包含 $N$ 个节点、间距为 $\\Delta x$ 的均匀一维网格上，并施加周期性边界条件。在此网格上，使用标准的二阶中心差分来近似二阶导数，从而形成以下形式的半离散常微分方程组\n$$\n\\frac{d \\mathbf{c}}{dt} \\;=\\; \\frac{D}{\\Delta x^{2}}\\,\\mathbf{L}\\,\\mathbf{c},\n$$\n其中 $\\mathbf{c}\\in\\mathbb{C}^{N}$ 叠加了 $c$ 的节点值，而 $\\mathbf{L}\\in\\mathbb{R}^{N\\times N}$ 是在周期性环绕条件下、具有模板 $(1,-2,1)$ 的循环离散拉普拉斯算子。由于 $\\mathbf{L}$ 是循环矩阵，其特征向量是离散傅里叶模态，由整数 $m\\in\\{0,1,\\dots,N-1\\}$ 索引。每个傅里叶特征模态都作为一个标量线性常微分方程独立演化，其形式为\n$$\ny'(t) \\;=\\; \\lambda\\,y(t),\n$$\n其中 $\\lambda$ 等于 $\\frac{D}{\\Delta x^{2}}\\mathbf{L}$ 的相应特征值。考虑使用以下格式进行步长为 $\\Delta t$ 的单步时间积分：Forward Euler (FE)、Backward Euler (BE) 和 Crank–Nicolson (CN)。对于每种格式，一个步长内的演化会将傅里叶特征模态的振幅乘以一个放大因子，该因子取决于 $\\lambda$ 和 $\\Delta t$。\n\n从控制扩散定律及其有限差分半离散化出发，推导 $\\mathbf{L}$ 的离散傅里叶特征值，并用它们来表示在 FE、BE 和 CN 时间步进下第 $m$ 个扩散特征模态的放大因子。每个放大因子都应表示为关于 $D$、$\\Delta x$、$\\Delta t$、$N$ 和 $m$ 的闭式解析函数。将这三个放大因子按 (FE, BE, CN) 的顺序，以单个行矩阵的形式报告。最终答案必须是单个解析表达式；不要在最终表达式中包含单位。",
            "solution": "该问题是有效的。这是一个适定的、具有科学依据的问题，来自应用于偏微分方程的数值分析领域。所有必要信息均已提供，目标也已明确说明。我们可以开始推导。\n\n浓度场 $c(x,t)$ 的时空演化由 Fick 第二定律决定：\n$$\n\\frac{\\partial c}{\\partial t} = D\\,\\frac{\\partial^{2} c}{\\partial x^{2}}\n$$\n在具有间距 $\\Delta x$ 和周期性边界条件的均匀网格上进行空间离散化后，关于 $x$ 的二阶偏导数由二阶中心差分算子近似。对于网格节点 $j$，该近似为 $\\frac{c_{j+1} - 2c_j + c_{j-1}}{\\Delta x^2}$。这导出了半离散常微分方程组（ODEs）：\n$$\n\\frac{d \\mathbf{c}}{dt} = \\frac{D}{\\Delta x^{2}}\\,\\mathbf{L}\\,\\mathbf{c}\n$$\n此处，$\\mathbf{c}$ 是 $N$ 个网格节点上浓度值的向量，$\\mathbf{L}$ 是 $N \\times N$ 的离散拉普拉斯矩阵。给定模板 $(1, -2, 1)$ 和周期性边界条件，$\\mathbf{L}$ 是一个循环矩阵。$\\mathbf{L}$ 的第一行是 $(-2, 1, 0, \\dots, 0, 1)$。\n\n对于第一行为 $(c_0, c_1, \\dots, c_{N-1})$ 的循环矩阵，其特征值由公式 $\\mu_m = \\sum_{k=0}^{N-1} c_k \\omega^{mk}$ 给出，其中 $\\omega = \\exp(i 2\\pi / N)$ 是一个 N 次单位主根，索引 $m$ 从 $0$ 到 $N-1$。\n对于矩阵 $\\mathbf{L}$，第一行中唯一的非零元素是 $c_0 = -2$，$c_1 = 1$ 和 $c_{N-1} = 1$。因此，$\\mathbf{L}$ 的特征值 $\\mu_m$ 为：\n$$\n\\mu_m = c_0 \\omega^{m \\cdot 0} + c_1 \\omega^{m \\cdot 1} + c_{N-1} \\omega^{m(N-1)}\n$$\n$$\n\\mu_m = -2 + \\exp\\left(i\\frac{2\\pi m}{N}\\right) + \\exp\\left(i\\frac{2\\pi m(N-1)}{N}\\right)\n$$\n使用性质 $\\exp(i\\frac{2\\pi m(N-1)}{N}) = \\exp(i(2\\pi m - \\frac{2\\pi m}{N})) = \\exp(i 2\\pi m)\\exp(-i\\frac{2\\pi m}{N}) = \\exp(-i\\frac{2\\pi m}{N})$，表达式得以简化。\n$$\n\\mu_m = -2 + \\exp\\left(i\\frac{2\\pi m}{N}\\right) + \\exp\\left(-i\\frac{2\\pi m}{N}\\right)\n$$\n应用 Euler 公式，$\\cos(\\theta) = \\frac{\\exp(i\\theta) + \\exp(-i\\theta)}{2}$，我们得到：\n$$\n\\mu_m = -2 + 2\\cos\\left(\\frac{2\\pi m}{N}\\right)\n$$\n使用半角恒等式 $1 - \\cos(2\\theta) = 2\\sin^2(\\theta)$，上式变为：\n$$\n\\mu_m = -2\\left(1 - \\cos\\left(\\frac{2\\pi m}{N}\\right)\\right) = -4\\sin^2\\left(\\frac{\\pi m}{N}\\right)\n$$\n在 $\\mathbf{L}$ 的特征向量（离散傅里叶模态）基中，该半离散系统解耦。对于每个模态 $m$，系统表现得像一个标量 ODE $y'(t) = \\lambda_m y(t)$，其中 $\\lambda_m$ 是完整矩阵算子 $\\frac{D}{\\Delta x^2}\\mathbf{L}$ 的相应特征值。\n$$\n\\lambda_m = \\frac{D}{\\Delta x^2}\\mu_m = -\\frac{4D}{\\Delta x^2}\\sin^2\\left(\\frac{\\pi m}{N}\\right)\n$$\n我们现在分析应用于此模型方程的时间步进格式的稳定性。设 $y^n$ 是在时间 $t_n = n\\Delta t$ 的数值解。放大因子 $G_m$ 由关系式 $y^{n+1} = G_m y^n$ 定义。\n\n1.  **Forward Euler (FE)**：该格式为 $\\frac{y^{n+1} - y^n}{\\Delta t} = \\lambda_m y^n$。\n    $$\n    y^{n+1} = y^n + \\lambda_m \\Delta t y^n = (1 + \\lambda_m \\Delta t)y^n\n    $$\n    第 $m$ 个模态的放大因子是 $G_{FE,m} = 1 + \\lambda_m \\Delta t$。代入 $\\lambda_m$ 的表达式：\n    $$\n    G_{FE,m} = 1 - \\frac{4 D \\Delta t}{\\Delta x^2}\\sin^2\\left(\\frac{\\pi m}{N}\\right)\n    $$\n\n2.  **Backward Euler (BE)**：该格式为 $\\frac{y^{n+1} - y^n}{\\Delta t} = \\lambda_m y^{n+1}$。\n    $$\n    y^n = y^{n+1}(1 - \\lambda_m \\Delta t) \\implies y^{n+1} = \\frac{1}{1 - \\lambda_m \\Delta t}y^n\n    $$\n    放大因子是 $G_{BE,m} = (1 - \\lambda_m \\Delta t)^{-1}$。代入 $\\lambda_m$ 的表达式：\n    $$\n    G_{BE,m} = \\frac{1}{1 - (-\\frac{4D}{\\Delta x^2}\\sin^2(\\frac{\\pi m}{N})) \\Delta t} = \\frac{1}{1 + \\frac{4 D \\Delta t}{\\Delta x^2}\\sin^2\\left(\\frac{\\pi m}{N}\\right)}\n    $$\n\n3.  **Crank–Nicolson (CN)**：该格式为 $\\frac{y^{n+1} - y^n}{\\Delta t} = \\frac{1}{2}(\\lambda_m y^n + \\lambda_m y^{n+1})$。\n    $$\n    y^{n+1}\\left(1 - \\frac{\\lambda_m \\Delta t}{2}\\right) = y^n\\left(1 + \\frac{\\lambda_m \\Delta t}{2}\\right) \\implies y^{n+1} = \\frac{1 + \\lambda_m \\Delta t/2}{1 - \\lambda_m \\Delta t/2}y^n\n    $$\n    放大因子是 $G_{CN,m} = \\frac{1 + \\lambda_m \\Delta t/2}{1 - \\lambda_m \\Delta t/2}$。代入 $\\lambda_m$ 的表达式：\n    $$\n    G_{CN,m} = \\frac{1 + \\frac{\\Delta t}{2}(-\\frac{4D}{\\Delta x^2}\\sin^2(\\frac{\\pi m}{N}))}{1 - \\frac{\\Delta t}{2}(-\\frac{4D}{\\Delta x^2}\\sin^2(\\frac{\\pi m}{N}))} = \\frac{1 - \\frac{2 D \\Delta t}{\\Delta x^2}\\sin^2\\left(\\frac{\\pi m}{N}\\right)}{1 + \\frac{2 D \\Delta t}{\\Delta x^2}\\sin^2\\left(\\frac{\\pi m}{N}\\right)}\n    $$\n\n按要求，将第 $m$ 个特征模态的三个放大因子（表示为 $D$、$\\Delta x$、$\\Delta t$、$N$ 和 $m$ 的函数）收集到一个单行矩阵中。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 1 - \\frac{4 D \\Delta t}{\\Delta x^2}\\sin^2\\left(\\frac{\\pi m}{N}\\right) & \\frac{1}{1 + \\frac{4 D \\Delta t}{\\Delta x^2}\\sin^2\\left(\\frac{\\pi m}{N}\\right)} & \\frac{1 - \\frac{2 D \\Delta t}{\\Delta x^2}\\sin^2\\left(\\frac{\\pi m}{N}\\right)}{1 + \\frac{2 D \\Delta t}{\\Delta x^2}\\sin^2\\left(\\frac{\\pi m}{N}\\right)} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "当我们掌握了稳定性理论之后，就可以开始实现第一个数值方案了。本练习聚焦于显式的前向时间中心空间（Forward-Time Central-Space, FTCS）方法，这是一种在编码上最直接的格式。你将把该方法应用于一个扩散问题，并亲身体会到其稳定性条件在实际计算中的重要性，这直接关联到前一个练习中的理论分析 。",
            "id": "4246161",
            "problem": "考虑一种中性离子物质在等温、均匀的电解质板中的一维扩散。该动力学过程由 Fick 第二扩散定律控制，该定律指出浓度 $c(x,t)$ 根据以下偏微分方程（PDE）演化：$$\\frac{\\partial c}{\\partial t} = D \\frac{\\partial^2 c}{\\partial x^2},$$ 其中 $D$ 是扩散系数。假设板的两端均为零通量（Neumann）边界条件，意味着浓度在边界处的空间导数为零。\n\n您需要实现显式前向时间中心空间（FTCS）有限差分格式，并在其稳定性约束下模拟初始阶跃浓度的演化，并估算浓度分布达到指定的“平滑水平”所需的时间。FTCS 格式使用以下公式推进在网格索引 $i$ 和时间步长 $n$ 的离散浓度 $c_i^n$：$$c_i^{n+1} = c_i^n + r \\left(c_{i+1}^n - 2 c_i^n + c_{i-1}^n\\right),$$ 其中无量纲参数 $r = D \\Delta t / \\Delta x^2$ 必须满足稳定性条件 $r \\le \\frac{1}{2}$。零通量边界条件通过要求以下条件来强制执行：$$\\left.\\frac{\\partial c}{\\partial x}\\right|_{x=0} = 0 \\quad \\text{and} \\quad \\left.\\frac{\\partial c}{\\partial x}\\right|_{x=L} = 0,$$ 这在有限差分实现中可以通过镜像鬼点值或等效的单边更新来施加。\n\n将初始条件定义为在长度为 $L$ 的域中居中的阶跃浓度：$$c(x,0) = \\begin{cases} c_0, & x  \\frac{L}{2}, \\\\ 0,  x \\ge \\frac{L}{2}. \\end{cases}$$ 使用具有 $N$ 个点和间距 $\\Delta x = L/(N-1)$ 的均匀空间网格，并选择满足 FTCS 稳定性约束的时间步长 $\\Delta t$。“平滑水平”定义为整个域上的最大绝对空间梯度幅值降至指定阈值 $g_{\\mathrm{thr}}$ 以下，即：$$\\max_{x \\in [0,L]} \\left|\\frac{\\partial c}{\\partial x}(x,t)\\right| \\le g_{\\mathrm{thr}}.$$ 在离散设置中，使用中心差分估计内部点的梯度，使用单边差分估计边界点的梯度：\n- 内部：$\\left.\\frac{\\partial c}{\\partial x}\\right|_{x_i} \\approx \\frac{c_{i+1} - c_{i-1}}{2 \\Delta x}$,\n- 左边界：$\\left.\\frac{\\partial c}{\\partial x}\\right|_{x_0} \\approx \\frac{c_1 - c_0}{\\Delta x}$,\n- 右边界：$\\left.\\frac{\\partial c}{\\partial x}\\right|_{x_{N-1}} \\approx \\frac{c_{N-1} - c_{N-2}}{\\Delta x}$。\n\n实现一个程序，该程序：\n1. 在中点网格索引处构造带有阶跃的初始条件，\n2. 使用带有零通量边界条件的 FTCS 格式推进浓度，通过选择一个 $r \\le \\frac{1}{2}$ 并设置 $\\Delta t = r \\Delta x^2 / D$ 来强制执行稳定性约束 $r \\le \\frac{1}{2}$，\n3. 在每个时间步，计算整个域上的最大绝对梯度，\n4. 返回最大绝对梯度小于或等于 $g_{\\mathrm{thr}}$ 的最早时间 $t$（以秒为单位），\n5. 如果在 $t=0$ 时已经达到平滑水平，则返回 $0$ 秒，\n6. 如果在指定的最大模拟时间 $t_{\\max}$ 内未达到平滑水平，则返回 $-1.0$。\n\n所有物理量必须以其标准单位处理：$L$ 以米（$\\mathrm{m}$）为单位，$D$ 以平方米每秒（$\\mathrm{m}^2/\\mathrm{s}$）为单位，$c_0$ 以摩尔每立方米（$\\mathrm{mol}/\\mathrm{m}^3$）为单位，$g_{\\mathrm{thr}}$ 以摩尔每米的四次方（$\\mathrm{mol}/\\mathrm{m}^4$）为单位，时间以秒（$\\mathrm{s}$）为单位。每个测试用例的输出必须是一个浮点数，表示时间（以秒为单位）。\n\n测试套件：\n提供一组四个参数元组 $(L, N, D, c_0, r_{\\mathrm{choose}}, g_{\\mathrm{thr}}, t_{\\max})$ 进行独立模拟：\n- 情况1（一般情况）：$(1.0 \\times 10^{-3}, 801, 1.0 \\times 10^{-9}, 1000.0, 0.45, 5.0 \\times 10^{6}, 2.0)$。\n- 情况2（稳定性边界）：$(2.0 \\times 10^{-3}, 1001, 2.0 \\times 10^{-9}, 500.0, 0.50, 1.0 \\times 10^{6}, 0.5)$。\n- 情况3（初始时刻已平滑）：$(1.0 \\times 10^{-3}, 501, 1.0 \\times 10^{-9}, 1000.0, 0.49, 3.0 \\times 10^{8}, 1.0)$。\n- 情况4（在 $t_{\\max}$ 内未达到）：$(1.0 \\times 10^{-3}, 601, 1.0 \\times 10^{-9}, 1000.0, 0.45, 1.0 \\times 10^{2}, 0.05)$。\n\n您的程序应生成单行输出，其中包含这四个测试用例的结果，格式为方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”），其中每个结果都是以秒为单位的浮点数时间。不允许有任何额外的输出或注释。",
            "solution": "该问题要求实现一个数值模拟来求解一维扩散方程，并找出初始浓度分布平滑到指定水平所需的时间。对问题陈述的验证证实了其科学基础扎实、提法恰当且内部一致。因此，我们可以继续详细描述求解方法。\n\n控制性偏微分方程（PDE）是 Fick 第二扩散定律，适用于浓度为 $c(x,t)$、扩散系数为 $D$ 的物质：\n$$\n\\frac{\\partial c}{\\partial t} = D \\frac{\\partial^2 c}{\\partial x^2}\n$$\n模拟域是一个长度为 $L$ 的板，范围从 $x=0$ 到 $x=L$。两端的边界条件均为零通量（Neumann）类型：\n$$\n\\left.\\frac{\\partial c}{\\partial x}\\right|_{x=0} = 0 \\quad \\text{and} \\quad \\left.\\frac{\\partial c}{\\partial x}\\right|_{x=L} = 0\n$$\n初始浓度分布是域中心的一个阶跃函数：\n$$\nc(x,0) = \\begin{cases} c_0,  x  \\frac{L}{2} \\\\ 0,  x \\ge \\frac{L}{2} \\end{cases}\n$$\n\n为了数值求解此 PDE，我们采用前向时间中心空间（FTCS）有限差分法。首先，我们对时空域进行离散化。空间域 $[0, L]$ 被划分为一个包含 $N$ 个点的均匀网格，索引为 $i = 0, 1, \\dots, N-1$。空间网格间距为 $\\Delta x = L/(N-1)$，每个网格点的位置是 $x_i = i \\Delta x$。时间被离散化为大小为 $\\Delta t$ 的步长，即 $t_n = n \\Delta t$。网格点 $i$ 在时间步长 $n$ 的浓度表示为 $c_i^n$。\n\nFTCS 格式用前向差分近似时间导数，用中心差分近似空间二阶导数。这导出了内部网格点（$i=1, \\dots, N-2$）的显式更新规则：\n$$\n\\frac{c_i^{n+1} - c_i^n}{\\Delta t} = D \\frac{c_{i+1}^n - 2c_i^n + c_{i-1}^n}{\\Delta x^2}\n$$\n对 $c_i^{n+1}$ 进行整理，得到问题中提供的更新方程：\n$$\nc_i^{n+1} = c_i^n + r \\left(c_{i+1}^n - 2c_i^n + c_{i-1}^n\\right)\n$$\n其中 $r = D \\Delta t / \\Delta x^2$ 是一个无量纲参数。为使此显式格式数值稳定，$r$ 必须满足 von Neumann 稳定性条件 $r \\le 1/2$。问题指定选择一个值 $r_{\\mathrm{choose}} \\le 1/2$，由此确定时间步长为 $\\Delta t = r_{\\mathrm{choose}} \\Delta x^2 / D$。\n\n零通量 Neumann 边界条件需要特殊处理。我们可以使用“鬼点”来施加该条件。在左边界（$i=0$），零通量条件 $\\partial c / \\partial x = 0$ 的中心差分近似为 $(c_1^n - c_{-1}^n)/(2\\Delta x) = 0$，这意味着鬼点值 $c_{-1}^n$ 等于 $c_1^n$。将此代入 $i=0$ 处的通用 FTCS 公式：\n$$\nc_0^{n+1} = c_0^n + r(c_1^n - 2c_0^n + c_{-1}^n) = c_0^n + r(c_1^n - 2c_0^n + c_1^n) = c_0^n + 2r(c_1^n - c_0^n)\n$$\n同样，在右边界（$i=N-1$），零通量条件意味着鬼点值 $c_N^n = c_{N-2}^n$。更新规则变为：\n$$\nc_{N-1}^{n+1} = c_{N-1}^n + r(c_N^n - 2c_{N-1}^n + c_{N-2}^n) = c_{N-1}^n + r(c_{N-2}^n - 2c_{N-1}^n + c_{N-2}^n) = c_{N-1}^n + 2r(c_{N-2}^n - c_{N-1}^n)\n$$\n这三个更新规则（用于内部、左边界和右边界）使得浓度分布可以随时间演化。\n\n通过将阶跃函数映射到网格上来离散化初始条件。对于给定的测试用例，$N$ 始终是奇数。设 $N=2k+1$。网格索引为 $0, \\dots, 2k$。中点网格索引为 $k=(N-1)/2$，对应于物理位置 $x_k = k \\Delta x = \\frac{N-1}{2} \\frac{L}{N-1} = L/2$。因此，离散初始条件为：\n$$\nc_i^0 = c_0 \\quad \\text{for } i=0, \\dots, k-1\n$$\n$$\nc_i^0 = 0 \\quad \\text{for } i=k, \\dots, N-1\n$$\n\n当达到“平滑水平”时，模拟停止。这被定义为整个域上的最大绝对空间梯度降至阈值 $g_{\\mathrm{thr}}$ 以下。在每个时间步长 $n$，使用指定的有限差分公式估计每个网格点 $i$ 处的梯度：\n-   左边界（$i=0$）：$g_0^n = \\frac{c_1^n - c_0^n}{\\Delta x}$\n-   内部点（$i=1, \\dots, N-2$）：$g_i^n = \\frac{c_{i+1}^n - c_{i-1}^n}{2\\Delta x}$\n-   右边界（$i=N-1$）：$g_{N-1}^n = \\frac{c_{N-1}^n - c_{N-2}^n}{\\Delta x}$\n要检查的条件是 $\\max_{i} |g_i^n| \\le g_{\\mathrm{thr}}$。\n\n总体算法如下：\n1.  给定参数 $(L, N, D, c_0, r_{\\mathrm{choose}}, g_{\\mathrm{thr}}, t_{\\max})$，计算常数 $\\Delta x = L/(N-1)$ 和 $\\Delta t = r_{\\mathrm{choose}} \\Delta x^2 / D$。\n2.  根据离散阶跃函数初始条件，初始化一个包含 $N$ 个元素的浓度数组 $c$。\n3.  计算初始最大绝对梯度。如果它小于或等于 $g_{\\mathrm{thr}}$，则过程终止并返回 $t=0$。\n4.  进入时间步进循环。管理循环直到 $t_{\\max}$ 的一个安全方法是确定最大整数步数，`num_steps = floor(t_max / dt)`。\n5.  对于从 $1$ 到 `num_steps` 的每一步：\n    a. 使用所有网格点的 FTCS 更新方程，从当前分布 $c^n$ 计算下一个浓度分布 $c^{n+1}$。\n    b. 更新当前时间：$t_n = n \\Delta t$。\n    c. 计算新分布 $c^{n+1}$ 的最大绝对梯度。\n    d. 如果梯度小于或等于 $g_{\\mathrm{thr}}$，则模拟完成，并返回当前时间 $t_n$。\n6.  如果循环结束仍未达到阈值，则意味着在任何时间 $t \\le t_{\\max}$ 内条件都未满足。在这种情况下，返回一个值 $-1.0$。\n此过程将为提供的每个测试用例实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D diffusion equation using the FTCS method to find the time\n    to reach a specified smoothing level for a set of test cases.\n    \"\"\"\n    \n    # Test Suite: (L, N, D, c0, r_choose, g_thr, t_max)\n    test_cases = [\n        # Case 1 (general case)\n        (1.0e-3, 801, 1.0e-9, 1000.0, 0.45, 5.0e6, 2.0),\n        # Case 2 (boundary of stability)\n        (2.0e-3, 1001, 2.0e-9, 500.0, 0.50, 1.0e6, 0.5),\n        # Case 3 (already smooth at initial time)\n        (1.0e-3, 501, 1.0e-9, 1000.0, 0.49, 3.0e8, 1.0),\n        # Case 4 (not achieved within t_max)\n        (1.0e-3, 601, 1.0e-9, 1000.0, 0.45, 1.0e2, 0.05),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        L, N, D, c0, r_choose, g_thr, t_max = case\n\n        # 1. Discretization parameters\n        dx = L / (N - 1)\n        dt = r_choose * dx**2 / D\n        \n        # 2. Initial Condition\n        c = np.zeros(N)\n        mid_idx = (N - 1) // 2\n        c[:mid_idx] = c0\n\n        # 3. Function to compute maximum absolute gradient\n        def calculate_max_grad(conc, delta_x):\n            grad = np.zeros_like(conc)\n            # Left boundary: one-sided forward difference\n            grad[0] = (conc[1] - conc[0]) / delta_x\n            # Right boundary: one-sided backward difference\n            grad[-1] = (conc[-1] - conc[-2]) / delta_x\n            # Interior points: central difference\n            grad[1:-1] = (conc[2:] - conc[:-2]) / (2 * delta_x)\n            return np.max(np.abs(grad))\n\n        # 4. Check condition at t=0\n        initial_max_grad = calculate_max_grad(c, dx)\n        if initial_max_grad = g_thr:\n            results.append(0.0)\n            continue\n        \n        # 5. Time-stepping loop\n        found_time = -1.0\n        \n        # Use integer steps to avoid floating point issues in loop termination\n        if dt > 0:\n            num_steps = int(t_max / dt)\n        else:\n            num_steps = 0\n            \n        current_time = 0.0\n        c_new = np.copy(c)\n\n        for step in range(1, num_steps + 1):\n            current_time = step * dt\n            \n            # FTCS Update (vectorized)\n            # Interior points\n            c_new[1:-1] = c[1:-1] + r_choose * (c[2:] - 2 * c[1:-1] + c[:-2])\n            \n            # Boundary points (zero-flux)\n            c_new[0] = c[0] + 2 * r_choose * (c[1] - c[0])\n            c_new[-1] = c[-1] + 2 * r_choose * (c[-2] - c[-1])\n            \n            c = np.copy(c_new)\n\n            # Check for smoothing level\n            max_grad = calculate_max_grad(c, dx)\n            if max_grad = g_thr:\n                found_time = current_time\n                break\n        \n        results.append(found_time)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "为了克服显式格式的稳定性限制，我们转向使用隐式方法。本练习将实现无条件稳定的 Crank-Nicolson 格式。更重要的是，本练习将超越基础的编程实现，引入两种强大的数值分析技术：评估方案的收敛阶，以及利用理查森外推法（Richardson extrapolation）来提升解的精度。这标志着从简单模拟到严谨数值验证的关键一步。",
            "id": "4246157",
            "problem": "考虑溶解物质向平面电极的一维扩散，该过程在一个有限区间上通过菲克第二定律进行建模，以近似一个半无限域。设 $x \\in [0,L]$ 且 $t \\ge 0$。浓度场 $c(x,t)$ 满足偏微分方程 $c_t = D c_{xx}$，其中 $D$ 是扩散系数。初始条件和边界条件模拟了均匀的初始浓度，其中原点处为吸收电极，远场浓度保持在初始值：$c(x,0) = c_0$ 对于 $x \\in (0,L]$，$c(0,t) = 0$ 对于 $t \\ge 0$，以及 $c(L,t) = c_0$ 对于 $t \\ge 0$。在计算电化学中，此设置近似于向一个完全吸收的平面电极的半无限扩散，其中在 $x=L$ 处有一个固定浓度的储备区。\n\n您的任务是实现空间上的二阶中心有限差分，并结合 Crank-Nicolson (CN) 时间步进方法（Crank-Nicolson (CN) 是一种经典的无条件稳定、二阶精确的隐式时间离散化方法），使用两种网格间距 $h$ 和 $h/2$ 来计算在时间 $T$ 的数值解。使用该边值问题的半无限精确解作为参考来计算绝对误差（您必须在您的解答中推导并陈述该精确解）。然后：\n\n1. 在指定位置 $x_\\star$ 处，结合 $h$ 和 $h/2$ 的数值计算 Richardson 外推估计值。\n2. 使用在两种网格间距下计算出的绝对误差的以 2 为底的对数比，评估关于空间细化的观测精度阶数 $p$。\n\n所有量必须使用物理上一致的单位：$D$ 的单位为 $\\mathrm{m^2/s}$，$x$ 和 $L$ 的单位为 $\\mathrm{m}$，$t$ 和 $T$ 的单位为 $\\mathrm{s}$，以及 $c$ 的单位为 $\\mathrm{mol/m^3}$。报告的所有浓度单位均为 $\\mathrm{mol/m^3}$，观测阶数为无量纲数。不涉及角度。请勿使用百分比；任何比率都必须以小数形式报告。\n\n实现该算法，并将其应用于以下参数值的测试套件。对于每种情况，两个网格使用相同的时间步长 $\\,\\Delta t\\,$，以避免时间误差掩盖空间阶数。将使用的两个空间网格间距为 $h$ 和 $h/2$。\n\n- 情况 A（一般精度，远场边界无影响）：\n  - $D = 1.0 \\times 10^{-9}\\ \\mathrm{m^2/s}$,\n  - $c_0 = 1.0\\ \\mathrm{mol/m^3}$,\n  - $L = 1.0 \\times 10^{-3}\\ \\mathrm{m}$,\n  - $T = 0.1\\ \\mathrm{s}$,\n  - $x_\\star = 5.0 \\times 10^{-5}\\ \\mathrm{m}$,\n  - $h = 2.0 \\times 10^{-5}\\ \\mathrm{m}$,\n  - $\\Delta t = 5.0 \\times 10^{-4}\\ \\mathrm{s}$.\n\n- 情况 B（短时扩散层，较慢物质）：\n  - $D = 1.0 \\times 10^{-10}\\ \\mathrm{m^2/s}$,\n  - $c_0 = 1.0\\ \\mathrm{mol/m^3}$,\n  - $L = 1.0 \\times 10^{-3}\\ \\mathrm{m}$,\n  - $T = 0.01\\ \\mathrm{s}$,\n  - $x_\\star = 1.0 \\times 10^{-5}\\ \\mathrm{m}$,\n  - $h = 5.0 \\times 10^{-5}\\ \\mathrm{m}$,\n  - $\\Delta t = 5.0 \\times 10^{-5}\\ \\mathrm{s}$.\n\n- 情况 C（远场边界更近，可能因有限域导致精度下降）：\n  - $D = 1.0 \\times 10^{-9}\\ \\mathrm{m^2/s}$,\n  - $c_0 = 1.0\\ \\mathrm{mol/m^3}$,\n  - $L = 1.0 \\times 10^{-4}\\ \\mathrm{m}$,\n  - $T = 0.1\\ \\mathrm{s}$,\n  - $x_\\star = 5.0 \\times 10^{-5}\\ \\mathrm{m}$,\n  - $h = 2.0 \\times 10^{-6}\\ \\mathrm{m}$,\n  - $\\Delta t = 5.0 \\times 10^{-4}\\ \\mathrm{s}$.\n\n对于每种情况：\n- 计算两种网格在 $x_\\star$ 和 $t=T$ 处的数值浓度。\n- 计算在 $x_\\star$ 处相对于 $t=T$ 时半无限精确解的绝对误差。\n- 从与 $h$ 和 $h/2$ 相关的误差对计算观测阶数 $p$。\n- 使用两个网格值和观测阶数计算在 $x_\\star$ 处的 Richardson 外推浓度估计值。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个情况的结果本身是一个包含两个元素的列表。这两个元素按顺序分别是：在 $x_\\star$ 处的 Richardson 外推浓度，单位为 $\\mathrm{mol/m^3}$（四舍五入到六位小数），以及观测阶数 $p$（四舍五入到六位小数）。例如，输出格式必须与以下完全一样：\n\"[[c_A,p_A],[c_B,p_B],[c_C,p_C]]\"\n前后无任何附加文本。",
            "solution": "在进行求解之前，对问题进行验证。\n\n### 步骤 1：提取已知条件\n- **控制方程**：$c_t = D c_{xx}$ 对于 $x \\in [0,L]$ 和 $t \\ge 0$。\n- **初始条件**：$c(x,0) = c_0$ 对于 $x \\in (0,L]$。\n- **边界条件**：$c(0,t) = 0$ 对于 $t \\ge 0$ 和 $c(L,t) = c_0$ 对于 $t \\ge 0$。\n- **数值方法**：空间上的二阶中心有限差分；Crank-Nicolson (CN) 时间步进方法。\n- **分析任务**：\n  1. 使用网格间距 $h$ 和 $h/2$ 计算在时间 $T$ 的数值解，保持时间步长 $\\Delta t$ 不变。\n  2. 使用半无限精确解作为误差计算的参考。\n  3. 使用网格 $h$ 和 $h/2$ 的结果计算在 $x_\\star$ 处的 Richardson 外推估计值。\n  4. 从两个网格的绝对误差计算观测精度阶数 $p$。\n- **数据单位**：$D$ 的单位为 $\\mathrm{m^2/s}$，$x, L, h$ 的单位为 $\\mathrm{m}$，$t, T, \\Delta t$ 的单位为 $\\mathrm{s}$，$c, c_0$ 的单位为 $\\mathrm{mol/m^3}$。\n- **测试用例**：\n  - **情况 A**：$D = 1.0 \\times 10^{-9}\\ \\mathrm{m^2/s}$，$c_0 = 1.0\\ \\mathrm{mol/m^3}$，$L = 1.0 \\times 10^{-3}\\ \\mathrm{m}$，$T = 0.1\\ \\mathrm{s}$，$x_\\star = 5.0 \\times 10^{-5}\\ \\mathrm{m}$，$h = 2.0 \\times 10^{-5}\\ \\mathrm{m}$，$\\Delta t = 5.0 \\times 10^{-4}\\ \\mathrm{s}$。\n  - **情况 B**：$D = 1.0 \\times 10^{-10}\\ \\mathrm{m^2/s}$，$c_0 = 1.0\\ \\mathrm{mol/m^3}$，$L = 1.0 \\times 10^{-3}\\ \\mathrm{m}$，$T = 0.01\\ \\mathrm{s}$，$x_\\star = 1.0 \\times 10^{-5}\\ \\mathrm{m}$，$h = 5.0 \\times 10^{-5}\\ \\mathrm{m}$，$\\Delta t = 5.0 \\times 10^{-5}\\ \\mathrm{s}$。\n  - **情况 C**：$D = 1.0 \\times 10^{-9}\\ \\mathrm{m^2/s}$，$c_0 = 1.0\\ \\mathrm{mol/m^3}$，$L = 1.0 \\times 10^{-4}\\ \\mathrm{m}$，$T = 0.1\\ \\mathrm{s}$，$x_\\star = 5.0 \\times 10^{-5}\\ \\mathrm{m}$，$h = 2.0 \\times 10^{-6}\\ \\mathrm{m}$，$\\Delta t = 5.0 \\times 10^{-4}\\ \\mathrm{s}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学依据**：该问题描述了由菲克第二定律建模的一维扩散，这是传质学和电化学中的一个基本原理。边界条件对应于标准的计时电流法实验。数值方法（Crank-Nicolson）是求解抛物型偏微分方程的一种标准、成熟的技术。使用有限域来近似半无限域是一种常见且有效的计算策略。参数在物理上是现实的。该问题在科学上是合理的。\n2.  **适定性**：该问题是一个具有明确初始条件和狄利克雷边界条件的线性抛物型偏微分方程。这构成了一个适定的初边值问题，保证了唯一且稳定解的存在。\n3.  **客观性**：该问题以精确的数学和物理术语陈述，没有主观性或歧义。\n4.  **完整性**：每种情况所需的所有参数（$D, c_0, L, T, x_\\star, h, \\Delta t$）都已提供。该问题是自洽的。\n5.  **一致性**：没有内部矛盾。例如，使用半无限精确解作为有限域模拟的基准，是数值分析练习中有意为之且有效的一部分，旨在研究有限边界的影响。在情况 A 和 B 中，扩散长度 $\\delta \\approx \\sqrt{Dt}$ 远小于 $L$，这使得半无限近似非常出色。在情况 C 中，$\\delta$ 是 $L$ 的一个不可忽略的部分，这是一个有效的情景，用于测试该近似的局限性，正如问题中所述。\n\n### 步骤 3：结论与行动\n此问题是**有效的**。这是一个定义明确、科学上合理的计算电化学问题。将提供完整的解决方案。\n\n### 解决方案\n该问题要求对一维扩散方程进行数值求解，然后使用 Richardson 外推法进行误差分析。\n\n**1. 控制方程与精确解**\n\n朝平面电极扩散的物质浓度 $c(x,t)$ 由菲克第二定律控制：\n$$\n\\frac{\\partial c}{\\partial t} = D \\frac{\\partial^2 c}{\\partial x^2}\n$$\n该问题定义在有限域 $x \\in [0, L]$ 上，具有以下初始和边界条件：\n$$\nc(x,0) = c_0, \\quad x \\in (0, L]\n$$\n$$\nc(0,t) = 0, \\quad t \\ge 0\n$$\n$$\nc(L,t) = c_0, \\quad t \\ge 0\n$$\n此设置是半无限域问题（$L \\to \\infty$）的数值近似，其中远场浓度保持不变。对于半无限情况，边界条件 $c(L,t)=c_0$ 被替换为 $\\lim_{x\\to\\infty} c(x,t) = c_0$。这个半无限问题的精确解析解通常通过拉普拉斯变换或相似性变换推导得出，由 Cottrell 方程给出：\n$$\nc_{exact}(x,t) = c_0 \\text{erf}\\left(\\frac{x}{2\\sqrt{Dt}}\\right)\n$$\n其中 $\\text{erf}$ 是误差函数。这个精确解将作为我们比较数值结果的基准。有限域上的数值解与此精确解之间的差异将包括数值离散误差和来自有限域近似的建模误差。\n\n**2. 数值方法：Crank-Nicolson 格式**\n\n我们在空间和时间上对域进行离散化。设 $x_j = j h$，$j=0, 1, \\dots, N_x$，其中 $h$ 是空间步长且 $N_x h = L$。设 $t_n = n \\Delta t$，$n=0, 1, \\dots, N_t$，其中 $\\Delta t$ 是时间步长且 $N_t \\Delta t = T$。令 $c_j^n$ 表示 $c(x_j, t_n)$ 的数值近似。\n\n二阶空间导数使用二阶中心差分进行近似：\n$$\n\\frac{\\partial^2 c}{\\partial x^2}\\bigg|_{x_j, t_n} \\approx \\frac{c_{j-1}^n - 2c_j^n + c_{j+1}^n}{h^2}\n$$\nCrank-Nicolson 方法是一种隐式格式，它对当前时间步 $n$ 和下一个时间步 $n+1$ 的空间有限差分进行平均。这在时间上可以达到二阶精度。\n$$\n\\frac{c_j^{n+1} - c_j^n}{\\Delta t} = \\frac{D}{2} \\left( \\frac{c_{j-1}^{n+1} - 2c_j^{n+1} + c_{j+1}^{n+1}}{h^2} + \\frac{c_{j-1}^n - 2c_j^n + c_{j+1}^n}{h^2} \\right)\n$$\n这适用于内部网格点，$j = 1, 2, \\dots, N_x-1$。\n\n我们定义扩散数 $\\alpha = \\frac{D \\Delta t}{2h^2}$。我们重新整理该方程，将未知项（在时间步 $n+1$）分组到左侧（LHS），将已知项（在时间步 $n$）分组到右侧（RHS）：\n$$\n-\\alpha c_{j-1}^{n+1} + (1+2\\alpha)c_j^{n+1} - \\alpha c_{j+1}^{n+1} = \\alpha c_{j-1}^n + (1-2\\alpha)c_j^n + \\alpha c_{j+1}^n\n$$\n该方程为未知的内部浓度 $\\{c_j^{n+1}\\}_{j=1}^{N_x-1}$ 构成了一个包含 $N_x-1$ 个线性方程的方程组。该系统可以写成矩阵形式 $\\mathbf{A} \\mathbf{c}^{n+1} = \\mathbf{d}^n$，其中 $\\mathbf{A}$ 是一个 $(N_x-1) \\times (N_x-1)$ 的三对角矩阵，$\\mathbf{d}^n$ 是 RHS 向量。\n\n边界条件为 $c_0^n = c(0, t_n) = 0$ 和 $c_{N_x}^n = c(L, t_n) = c_0$ 对所有 $n$ 成立。这些值被并入第一个（$j=1$）和最后一个（$j=N_x-1$）内部点的方程中：\n\n对于 $j=1$：\n$$\n(1+2\\alpha)c_1^{n+1} - \\alpha c_2^{n+1} = \\alpha c_0^n + (1-2\\alpha)c_1^n + \\alpha c_2^n = (1-2\\alpha)c_1^n + \\alpha c_2^n\n$$\n（因为 $c_0^n=0$ 且 $c_0^{n+1}=0$）\n\n对于 $j=N_x-1$：\n$$\n-\\alpha c_{N_x-2}^{n+1} + (1+2\\alpha)c_{N_x-1}^{n+1} = \\alpha c_{N_x-2}^n + (1-2\\alpha)c_{N_x-1}^n + \\alpha c_{N_x}^n + \\alpha c_{N_x}^{n+1}\n$$\n由于 $c_{N_x}^n=c_{N_x}^{n+1}=c_0$，RHS 变为：\n$$\n\\text{RHS}_{N_x-1} = \\alpha c_{N_x-2}^n + (1-2\\alpha)c_{N_x-1}^n + 2\\alpha c_0\n$$\n在每个时间步求解所得的三对角系统。由于矩阵 $\\mathbf{A}$ 是常数，这在计算上是高效的，特别是当使用像托马斯算法这样的专用三对角求解器时。\n\n**3. 误差分析与外推**\n\n我们对每种情况进行两次模拟，一次使用空间步长 $h$，另一次使用 $h/2$，同时保持 $\\Delta t$ 不变。这可以分离出由空间离散化引起的误差贡献。\n\n**观测精度阶数 ($p$)**：\n空间离散误差的主导项形式为 $E_h \\approx K h^p$，其中 $K$ 是一个常数，$p$ 是精度阶数。对于我们的二阶中心差分格式，我们期望 $p \\approx 2$。给定步长为 $h$ 和 $h/2$ 时的数值误差 $E_h$ 和 $E_{h/2}$，我们可以估计 $p$：\n$$\n\\frac{E_h}{E_{h/2}} \\approx \\frac{K h^p}{K (h/2)^p} = 2^p \\implies p \\approx \\log_2\\left(\\frac{E_h}{E_{h/2}}\\right)\n$$\n其中 $E_h = |c_h(x_\\star,T) - c_{exact}(x_\\star,T)|$。\n\n**Richardson 外推法**：\n该技术通过结合来自两种不同网格间距的结果，提供对解的更精确估计。设 $C_h$ 和 $C_{h/2}$ 分别是步长为 $h$ 和 $h/2$ 时在 $x_\\star$ 处的数值解，$C_{exact}$ 是真实解。我们有：\n$$\nC_h \\approx C_{exact} + K h^p\n$$\n$$\nC_{h/2} \\approx C_{exact} + K (h/2)^p\n$$\n消去误差项 $K h^p$，我们得到一个改进的估计值 $C_{RE}$：\n$$\nC_{RE} = \\frac{2^p C_{h/2} - C_h}{2^p - 1} = C_{h/2} + \\frac{C_{h/2} - C_h}{2^p-1}\n$$\n根据问题要求，我们在此公式中使用数值观测到的阶数 $p$。\n\n**4. 计算策略**\n\n对于每个测试用例，算法如下：\n1.  为粗网格 ($h$) 和细网格 ($h/2$) 定义物理参数和数值参数。\n2.  对于每个网格：\n    a. 确定空间点数 $N_x$ 和时间步数 $N_t$。\n    b. 根据初始条件 $c(x,0)=c_0$（对于 $x0$）和 $c(0,0)=0$ 初始化浓度向量 $c$。\n    c. 以适用于 `scipy.linalg.solve_banded` 的带状格式构建三对角矩阵 $\\mathbf{A}$。\n    d. 从 $n=0$ 循环到 $N_t-1$：\n        i. 基于时间 $t_n$ 的浓度构建 RHS 向量 $\\mathbf{d}^n$。\n        ii. 求解线性系统 $\\mathbf{A} \\mathbf{c}^{n+1} = \\mathbf{d}^n$ 以找到时间 $t_{n+1}$ 的浓度。\n    e. 时间步进循环结束后，如果特定点 $x_\\star$ 不在网格节点上，则使用线性插值法求该点的浓度。\n3.  计算在 $(x_\\star, T)$ 处的精确解 $c_{exact}$。\n4.  计算绝对误差 $E_h$ 和 $E_{h/2}$。\n5.  计算观测精度阶数 $p$。\n6.  计算 Richardson 外推浓度 $C_{RE}$。\n7.  存储对 $[C_{RE}, p]$ 以供最终输出。\n8.  对所有测试用例重复上述步骤，并按规定格式化最终输出。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import erf\nfrom scipy.linalg import solve_banded\n\ndef run_simulation(D, c0, L, T, h, dt, x_star):\n    \"\"\"\n    Solves the 1D diffusion equation using the Crank-Nicolson method.\n\n    Returns:\n        float: The numerical concentration at position x_star and time T.\n    \"\"\"\n    # Grid setup\n    if not np.isclose(L/h, round(L/h)):\n        raise ValueError(\"L must be an integer multiple of h.\")\n    Nx = int(round(L / h))\n    Nt = int(round(T / dt))\n\n    # Grid points in space\n    x = np.linspace(0, L, Nx + 1)\n    \n    # Diffusion number\n    alpha = D * dt / (2.0 * h**2)\n\n    # Initial condition\n    c = np.full(Nx + 1, c0)\n    c[0] = 0.0\n\n    # Number of interior points\n    N_int = Nx - 1\n    if N_int = 0:\n        # If there are no interior points, the solution is determined by boundaries\n        # This is an edge case, but we handle it.\n        return np.interp(x_star, x, c)\n\n    # Tridiagonal matrix A for the LHS, in banded format for solve_banded\n    ab = np.zeros((3, N_int))\n    ab[0, 1:] = -alpha\n    ab[1, :] = 1.0 + 2.0 * alpha\n    ab[2, :-1] = -alpha\n\n    # Time stepping loop\n    for _ in range(Nt):\n        # Construct the RHS vector\n        rhs = np.zeros(N_int)\n        \n        # Vectorized calculation for internal points' contribution\n        # Corresponds to j = 2 to Nx-2\n        if N_int > 2:\n            rhs[1:-1] = alpha * c[1:-3] + (1.0 - 2.0 * alpha) * c[2:-2] + alpha * c[3:-1]\n\n        # First interior point (j=1)\n        rhs[0] = alpha * c[0] + (1.0 - 2.0 * alpha) * c[1] + alpha * c[2]\n        \n        # Last interior point (j=Nx-1)\n        if N_int > 1:\n            rhs[-1] = alpha * c[Nx-2] + (1.0 - 2.0 * alpha) * c[Nx-1] + alpha * c[Nx]\n        \n        # Add the implicit boundary condition terms to RHS\n        # At j=1, c_0^{n+1} is 0. Nothing to add.\n        # At j=Nx-1, we need to add alpha * c_{Nx}^{n+1} = alpha * c0\n        rhs[-1] += alpha * c0\n\n        # Solve the tridiagonal system\n        c_new_int = solve_banded((1, 1), ab, rhs)\n        c[1:Nx] = c_new_int\n\n    # Interpolate to find concentration at x_star\n    if not (0 = x_star = L):\n        raise ValueError(\"x_star must be within the domain [0, L]\")\n    \n    pos = x_star / h\n    j = int(np.floor(pos))\n    \n    if np.isclose(pos, j):\n        return c[j]\n    elif j + 1 = Nx:\n        frac = pos - j\n        return c[j] * (1.0 - frac) + c[j+1] * frac\n    else:\n        return c[Nx]\n\ndef solve():\n    test_cases = [\n        # Case A\n        {'D': 1.0e-9, 'c0': 1.0, 'L': 1.0e-3, 'T': 0.1, 'x_star': 5.0e-5, 'h': 2.0e-5, 'dt': 5.0e-4},\n        # Case B\n        {'D': 1.0e-10, 'c0': 1.0, 'L': 1.0e-3, 'T': 0.01, 'x_star': 1.0e-5, 'h': 5.0e-5, 'dt': 5.0e-5},\n        # Case C\n        {'D': 1.0e-9, 'c0': 1.0, 'L': 1.0e-4, 'T': 0.1, 'x_star': 5.0e-5, 'h': 2.0e-6, 'dt': 5.0e-4},\n    ]\n\n    results = []\n    for params in test_cases:\n        D, c0, L, T = params['D'], params['c0'], params['L'], params['T']\n        x_star, h, dt = params['x_star'], params['h'], params['dt']\n\n        # Run for coarse grid (h)\n        c_h = run_simulation(D, c0, L, T, h, dt, x_star)\n\n        # Run for fine grid (h/2)\n        c_h2 = run_simulation(D, c0, L, T, h / 2.0, dt, x_star)\n\n        # Calculate exact solution\n        c_exact = c0 * erf(x_star / (2.0 * np.sqrt(D * T)))\n\n        # Calculate errors\n        error_h = abs(c_h - c_exact)\n        error_h2 = abs(c_h2 - c_exact)\n\n        # Calculate observed order of accuracy, p\n        if error_h2 == 0 or error_h == 0:\n            p = np.inf if error_h > 0 else 0\n        else:\n            p = np.log2(error_h / error_h2)\n\n        # Calculate Richardson extrapolation\n        if np.isclose(2**p, 1.0):\n            c_richardson = c_h2\n        else:\n            c_richardson = c_h2 + (c_h2 - c_h) / (2.0**p - 1.0)\n        \n        results.append([c_richardson, p])\n\n    # Format output string\n    formatted_results = []\n    for res in results:\n        p_val = res[1] if np.isfinite(res[1]) else 0.0\n        formatted_results.append(f\"[{res[0]:.6f},{p_val:.6f}]\")\n    \n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}