{
    "hands_on_practices": [
        {
            "introduction": "Before implementing any numerical scheme, it is crucial to understand its theoretical properties, especially stability. This exercise guides you through a von Neumann stability analysis for the one-dimensional diffusion equation. You will derive the amplification factor for several common time-stepping schemes, which determines how the amplitude of each Fourier eigenmode of the solution evolves, providing a powerful tool for predicting the stability of a simulation.",
            "id": "4246127",
            "problem": "Consider a dilute, electroneutral electrolyte in which the spatiotemporal evolution of the salt concentration field $c(x,t)$ is governed by Fick's second law of diffusion,\n$$\n\\frac{\\partial c}{\\partial t} \\;=\\; D\\,\\frac{\\partial^{2} c}{\\partial x^{2}},\n$$\nwith a constant diffusion coefficient $D>0$. Discretize the spatial domain onto a uniform one-dimensional grid with $N$ nodes, spacing $\\Delta x$, and impose periodic boundary conditions. Approximate the second derivative by the standard second-order central difference on this grid, thereby forming a semi-discrete system of ordinary differential equations of the form\n$$\n\\frac{d \\mathbf{c}}{dt} \\;=\\; \\frac{D}{\\Delta x^{2}}\\,\\mathbf{L}\\,\\mathbf{c},\n$$\nwhere $\\mathbf{c}\\in\\mathbb{C}^{N}$ stacks the nodal values of $c$, and $\\mathbf{L}\\in\\mathbb{R}^{N\\times N}$ is the circulant discrete Laplacian with stencil $(1,-2,1)$ under periodic wrap-around. Because $\\mathbf{L}$ is circulant, its eigenvectors are discrete Fourier modes indexed by an integer $m\\in\\{0,1,\\dots,N-1\\}$, and each Fourier eigenmode evolves independently as a scalar linear ordinary differential equation of the form\n$$\ny'(t) \\;=\\; \\lambda\\,y(t),\n$$\nwith $\\lambda$ equal to the corresponding eigenvalue of $\\frac{D}{\\Delta x^{2}}\\mathbf{L}$. Consider single-step time integration with step size $\\Delta t$ using the following schemes: Forward Euler (FE), Backward Euler (BE), and Crank–Nicolson (CN). For each scheme, the evolution over one step multiplies the amplitude of a Fourier eigenmode by an amplification factor that depends on $\\lambda$ and $\\Delta t$.\n\nStarting from the governing diffusion law and its finite difference semi-discretization, derive the discrete Fourier eigenvalues of $\\mathbf{L}$ and use them to express the amplification factor for the $m$-th diffusion eigenmode under FE, BE, and CN time stepping, each as a closed-form analytic function of $D$, $\\Delta x$, $\\Delta t$, $N$, and $m$. Report the three amplification factors as a single row matrix in the order (FE, BE, CN). The final answer must be a single analytical expression; do not include units inside the final expression.",
            "solution": "The problem is valid. It is a well-posed, scientifically grounded problem from the field of numerical analysis applied to partial differential equations. All necessary information is provided, and the objective is clearly stated. We can proceed with the derivation.\n\nThe spatiotemporal evolution of the concentration field $c(x,t)$ is governed by Fick's second law:\n$$\n\\frac{\\partial c}{\\partial t} = D\\,\\frac{\\partial^{2} c}{\\partial x^{2}}\n$$\nUpon spatial discretization on a uniform grid with spacing $\\Delta x$ and periodic boundary conditions, the second partial derivative with respect to $x$ is approximated by the second-order central difference operator. For a grid node $j$, this is $\\frac{c_{j+1} - 2c_j + c_{j-1}}{\\Delta x^2}$. This leads to the semi-discrete system of ordinary differential equations (ODEs):\n$$\n\\frac{d \\mathbf{c}}{dt} = \\frac{D}{\\Delta x^{2}}\\,\\mathbf{L}\\,\\mathbf{c}\n$$\nHere, $\\mathbf{c}$ is the vector of concentration values at the $N$ grid nodes, and $\\mathbf{L}$ is the $N \\times N$ discrete Laplacian matrix. Given the stencil $(1, -2, 1)$ and periodic boundary conditions, $\\mathbf{L}$ is a circulant matrix. The first row of $\\mathbf{L}$ is $(-2, 1, 0, \\dots, 0, 1)$.\n\nThe eigenvalues of a circulant matrix with the first row $(c_0, c_1, \\dots, c_{N-1})$ are given by the formula $\\mu_m = \\sum_{k=0}^{N-1} c_k \\omega^{mk}$, where $\\omega = \\exp(i 2\\pi / N)$ is a principal $N$-th root of unity and the index $m$ runs from $0$ to $N-1$.\nFor the matrix $\\mathbf{L}$, the only non-zero elements in the first row are $c_0 = -2$, $c_1 = 1$, and $c_{N-1} = 1$. The eigenvalues $\\mu_m$ of $\\mathbf{L}$ are therefore:\n$$\n\\mu_m = c_0 \\omega^{m \\cdot 0} + c_1 \\omega^{m \\cdot 1} + c_{N-1} \\omega^{m(N-1)}\n$$\n$$\n\\mu_m = -2 + \\exp\\left(i\\frac{2\\pi m}{N}\\right) + \\exp\\left(i\\frac{2\\pi m(N-1)}{N}\\right)\n$$\nUsing the property $\\exp(i\\frac{2\\pi m(N-1)}{N}) = \\exp(i(2\\pi m - \\frac{2\\pi m}{N})) = \\exp(i 2\\pi m)\\exp(-i\\frac{2\\pi m}{N}) = \\exp(-i\\frac{2\\pi m}{N})$, the expression simplifies.\n$$\n\\mu_m = -2 + \\exp\\left(i\\frac{2\\pi m}{N}\\right) + \\exp\\left(-i\\frac{2\\pi m}{N}\\right)\n$$\nApplying Euler's formula, $\\cos(\\theta) = \\frac{\\exp(i\\theta) + \\exp(-i\\theta)}{2}$, we get:\n$$\n\\mu_m = -2 + 2\\cos\\left(\\frac{2\\pi m}{N}\\right)\n$$\nUsing the half-angle identity $1 - \\cos(2\\theta) = 2\\sin^2(\\theta)$, this becomes:\n$$\n\\mu_m = -2\\left(1 - \\cos\\left(\\frac{2\\pi m}{N}\\right)\\right) = -4\\sin^2\\left(\\frac{\\pi m}{N}\\right)\n$$\nThe semi-discrete system decouples in the basis of the eigenvectors of $\\mathbf{L}$ (the discrete Fourier modes). For each mode $m$, the system behaves like a scalar ODE $y'(t) = \\lambda_m y(t)$, where $\\lambda_m$ is the corresponding eigenvalue of the full matrix operator $\\frac{D}{\\Delta x^2}\\mathbf{L}$.\n$$\n\\lambda_m = \\frac{D}{\\Delta x^2}\\mu_m = -\\frac{4D}{\\Delta x^2}\\sin^2\\left(\\frac{\\pi m}{N}\\right)\n$$\nWe now analyze the stability of the time-stepping schemes applied to this model equation. Let $y^n$ be the numerical solution at time $t_n = n\\Delta t$. The amplification factor $G_m$ is defined by the relation $y^{n+1} = G_m y^n$.\n\n1.  **Forward Euler (FE)**: The scheme is $\\frac{y^{n+1} - y^n}{\\Delta t} = \\lambda_m y^n$.\n    $$\n    y^{n+1} = y^n + \\lambda_m \\Delta t y^n = (1 + \\lambda_m \\Delta t)y^n\n    $$\n    The amplification factor for the $m$-th mode is $G_{FE,m} = 1 + \\lambda_m \\Delta t$. Substituting the expression for $\\lambda_m$:\n    $$\n    G_{FE,m} = 1 - \\frac{4 D \\Delta t}{\\Delta x^2}\\sin^2\\left(\\frac{\\pi m}{N}\\right)\n    $$\n\n2.  **Backward Euler (BE)**: The scheme is $\\frac{y^{n+1} - y^n}{\\Delta t} = \\lambda_m y^{n+1}$.\n    $$\n    y^n = y^{n+1}(1 - \\lambda_m \\Delta t) \\implies y^{n+1} = \\frac{1}{1 - \\lambda_m \\Delta t}y^n\n    $$\n    The amplification factor is $G_{BE,m} = (1 - \\lambda_m \\Delta t)^{-1}$. Substituting the expression for $\\lambda_m$:\n    $$\n    G_{BE,m} = \\frac{1}{1 - (-\\frac{4D}{\\Delta x^2}\\sin^2(\\frac{\\pi m}{N})) \\Delta t} = \\frac{1}{1 + \\frac{4 D \\Delta t}{\\Delta x^2}\\sin^2\\left(\\frac{\\pi m}{N}\\right)}\n    $$\n\n3.  **Crank–Nicolson (CN)**: The scheme is $\\frac{y^{n+1} - y^n}{\\Delta t} = \\frac{1}{2}(\\lambda_m y^n + \\lambda_m y^{n+1})$.\n    $$\n    y^{n+1}\\left(1 - \\frac{\\lambda_m \\Delta t}{2}\\right) = y^n\\left(1 + \\frac{\\lambda_m \\Delta t}{2}\\right) \\implies y^{n+1} = \\frac{1 + \\lambda_m \\Delta t/2}{1 - \\lambda_m \\Delta t/2}y^n\n    $$\n    The amplification factor is $G_{CN,m} = \\frac{1 + \\lambda_m \\Delta t/2}{1 - \\lambda_m \\Delta t/2}$. Substituting the expression for $\\lambda_m$:\n    $$\n    G_{CN,m} = \\frac{1 + \\frac{\\Delta t}{2}(-\\frac{4D}{\\Delta x^2}\\sin^2(\\frac{\\pi m}{N}))}{1 - \\frac{\\Delta t}{2}(-\\frac{4D}{\\Delta x^2}\\sin^2(\\frac{\\pi m}{N}))} = \\frac{1 - \\frac{2 D \\Delta t}{\\Delta x^2}\\sin^2\\left(\\frac{\\pi m}{N}\\right)}{1 + \\frac{2 D \\Delta t}{\\Delta x^2}\\sin^2\\left(\\frac{\\pi m}{N}\\right)}\n    $$\n\nThe three amplification factors for the $m$-th eigenmode, expressed as functions of $D$, $\\Delta x$, $\\Delta t$, $N$, and $m$, are collected into a single row matrix as requested.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 1 - \\frac{4 D \\Delta t}{\\Delta x^2}\\sin^2\\left(\\frac{\\pi m}{N}\\right) & \\frac{1}{1 + \\frac{4 D \\Delta t}{\\Delta x^2}\\sin^2\\left(\\frac{\\pi m}{N}\\right)} & \\frac{1 - \\frac{2 D \\Delta t}{\\Delta x^2}\\sin^2\\left(\\frac{\\pi m}{N}\\right)}{1 + \\frac{2 D \\Delta t}{\\Delta x^2}\\sin^2\\left(\\frac{\\pi m}{N}\\right)} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "Moving from theory to practice, this exercise involves the hands-on implementation of the explicit Forward-Time Central-Space (FTCS) scheme, one of the most intuitive methods for solving parabolic equations. You will confront the practical consequences of the stability analysis performed previously  by implementing the stability constraint $r = D \\Delta t / \\Delta x^2 \\le 1/2$. This problem builds essential coding skills and a concrete understanding of how theoretical stability limits translate into practical code and simulation behavior.",
            "id": "4246161",
            "problem": "Consider one-dimensional diffusion of a neutral ionic species in an isothermal, homogeneous electrolyte slab. The dynamics are governed by Fick's second law of diffusion, which states that the concentration $c(x,t)$ evolves according to the partial differential equation $$\\frac{\\partial c}{\\partial t} = D \\frac{\\partial^2 c}{\\partial x^2},$$ where $D$ is the diffusion coefficient. Assume zero-flux (Neumann) boundary conditions at both ends of the slab, meaning the spatial derivative of the concentration is zero at the boundaries.\n\nYou are to implement the explicit Forward-Time Central-Space (FTCS) finite difference scheme under its stability constraint to simulate the evolution of an initial step concentration and to estimate the time needed for the profile to reach a specified \"smoothing level.\" The FTCS scheme advances the discrete concentration $c_i^n$ at grid index $i$ and time step $n$ using $$c_i^{n+1} = c_i^n + r \\left(c_{i+1}^n - 2 c_i^n + c_{i-1}^n\\right),$$ where the non-dimensional parameter $r = D \\Delta t / \\Delta x^2$ must satisfy the stability condition $r \\le \\frac{1}{2}$. The zero-flux boundary conditions are enforced by requiring $$\\left.\\frac{\\partial c}{\\partial x}\\right|_{x=0} = 0 \\quad \\text{and} \\quad \\left.\\frac{\\partial c}{\\partial x}\\right|_{x=L} = 0,$$ which in the finite difference implementation can be imposed via mirrored ghost values or equivalent one-sided updates.\n\nDefine the initial condition as a step concentration centered in the domain of length $L$: $$c(x,0) = \\begin{cases} c_0, & x < \\frac{L}{2}, \\\\ 0, & x \\ge \\frac{L}{2}. \\end{cases}$$ Use a uniform spatial grid with $N$ points and spacing $\\Delta x = L/(N-1)$, and a time step $\\Delta t$ chosen to satisfy the FTCS stability constraint. The \"smoothing level\" is defined as the maximum absolute spatial gradient magnitude across the domain dropping below a specified threshold $g_{\\mathrm{thr}}$, i.e., $$\\max_{x \\in [0,L]} \\left|\\frac{\\partial c}{\\partial x}(x,t)\\right| \\le g_{\\mathrm{thr}}.$$ In the discrete setting, estimate the gradient using central differences at interior points and one-sided differences at boundaries:\n- Interior: $\\left.\\frac{\\partial c}{\\partial x}\\right|_{x_i} \\approx \\frac{c_{i+1} - c_{i-1}}{2 \\Delta x}$,\n- Left boundary: $\\left.\\frac{\\partial c}{\\partial x}\\right|_{x_0} \\approx \\frac{c_1 - c_0}{\\Delta x}$,\n- Right boundary: $\\left.\\frac{\\partial c}{\\partial x}\\right|_{x_{N-1}} \\approx \\frac{c_{N-1} - c_{N-2}}{\\Delta x}$.\n\nImplement a program that:\n1. Constructs the initial condition with the step at the midpoint grid index,\n2. Advances the concentration using the FTCS scheme with zero-flux boundary conditions, enforcing the stability constraint $r \\le \\frac{1}{2}$ by selecting $\\Delta t = r \\Delta x^2 / D$ with a chosen $r \\le \\frac{1}{2}$,\n3. At each time step, computes the maximum absolute gradient across the domain,\n4. Returns the earliest time $t$ in seconds at which the maximum absolute gradient is less than or equal to $g_{\\mathrm{thr}}$,\n5. If the smoothing level is already achieved at $t=0$, returns $0$ seconds,\n6. If the smoothing level is not achieved by a specified maximum simulation time $t_{\\max}$, returns $-1.0$.\n\nAll physical quantities must be handled in their standard units: $L$ in meters ($\\mathrm{m}$), $D$ in square meters per second ($\\mathrm{m}^2/\\mathrm{s}$), $c_0$ in moles per cubic meter ($\\mathrm{mol}/\\mathrm{m}^3$), $g_{\\mathrm{thr}}$ in moles per fourth power of meter ($\\mathrm{mol}/\\mathrm{m}^4$), and time in seconds ($\\mathrm{s}$). The output for each test case must be a floating-point number representing time in seconds.\n\nTest Suite:\nProvide a set of four parameter tuples $(L, N, D, c_0, r_{\\mathrm{choose}}, g_{\\mathrm{thr}}, t_{\\max})$ to be simulated independently:\n- Case 1 (general case): $(1.0 \\times 10^{-3}, 801, 1.0 \\times 10^{-9}, 1000.0, 0.45, 5.0 \\times 10^{6}, 2.0)$.\n- Case 2 (boundary of stability): $(2.0 \\times 10^{-3}, 1001, 2.0 \\times 10^{-9}, 500.0, 0.50, 1.0 \\times 10^{6}, 0.5)$.\n- Case 3 (already smooth at initial time): $(1.0 \\times 10^{-3}, 501, 1.0 \\times 10^{-9}, 1000.0, 0.49, 3.0 \\times 10^{8}, 1.0)$.\n- Case 4 (not achieved within $t_{\\max}$): $(1.0 \\times 10^{-3}, 601, 1.0 \\times 10^{-9}, 1000.0, 0.45, 1.0 \\times 10^{2}, 0.05)$.\n\nYour program should produce a single line of output containing the results for these four test cases as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"), where each result is the time in seconds as a float. No additional output or commentary is permitted.",
            "solution": "The problem requires the implementation of a numerical simulation to solve the one-dimensional diffusion equation and find the time required for an initial concentration profile to smooth out to a specified level. The validation of the problem statement confirms that it is scientifically grounded, well-posed, and internally consistent. We can therefore proceed with a detailed description of the solution methodology.\n\nThe governing partial differential equation (PDE) is Fick's second law of diffusion for a species with concentration $c(x,t)$ and diffusion coefficient $D$:\n$$\n\\frac{\\partial c}{\\partial t} = D \\frac{\\partial^2 c}{\\partial x^2}\n$$\nThe simulation domain is a slab of length $L$, extending from $x=0$ to $x=L$. The boundary conditions are of the zero-flux (Neumann) type at both ends:\n$$\n\\left.\\frac{\\partial c}{\\partial x}\\right|_{x=0} = 0 \\quad \\text{and} \\quad \\left.\\frac{\\partial c}{\\partial x}\\right|_{x=L} = 0\n$$\nThe initial concentration profile is a step function centered in the domain:\n$$\nc(x,0) = \\begin{cases} c_0, & x < \\frac{L}{2} \\\\ 0, & x \\ge \\frac{L}{2} \\end{cases}\n$$\n\nTo solve this PDE numerically, we employ the Forward-Time Central-Space (FTCS) finite difference method. First, we discretize the spatio-temporal domain. The spatial domain $[0, L]$ is divided into a uniform grid of $N$ points, indexed by $i = 0, 1, \\dots, N-1$. The spatial grid spacing is $\\Delta x = L/(N-1)$, and the position of each grid point is $x_i = i \\Delta x$. Time is discretized into steps of size $\\Delta t$, with $t_n = n \\Delta t$. The concentration at grid point $i$ and time step $n$ is denoted by $c_i^n$.\n\nThe FTCS scheme approximates the time derivative with a forward difference and the spatial second derivative with a central difference. This leads to the explicit update rule for interior grid points ($i=1, \\dots, N-2$):\n$$\n\\frac{c_i^{n+1} - c_i^n}{\\Delta t} = D \\frac{c_{i+1}^n - 2c_i^n + c_{i-1}^n}{\\Delta x^2}\n$$\nRearranging for $c_i^{n+1}$ gives the update equation provided in the problem:\n$$\nc_i^{n+1} = c_i^n + r \\left(c_{i+1}^n - 2c_i^n + c_{i-1}^n\\right)\n$$\nwhere $r = D \\Delta t / \\Delta x^2$ is a non-dimensional parameter. For this explicit scheme to be numerically stable, $r$ must satisfy the von Neumann stability condition $r \\le 1/2$. The problem specifies that a value $r_{\\mathrm{choose}} \\le 1/2$ is selected, from which the time step $\\Delta t$ is determined as $\\Delta t = r_{\\mathrm{choose}} \\Delta x^2 / D$.\n\nThe zero-flux Neumann boundary conditions require special handling. We can use \"ghost points\" to enforce the condition. At the left boundary ($i=0$), a central difference approximation for the zero-flux condition $\\partial c / \\partial x = 0$ is $(c_1^n - c_{-1}^n)/(2\\Delta x) = 0$, which implies the ghost point value $c_{-1}^n$ is equal to $c_1^n$. Substituting this into the general FTCS formula at $i=0$:\n$$\nc_0^{n+1} = c_0^n + r(c_1^n - 2c_0^n + c_{-1}^n) = c_0^n + r(c_1^n - 2c_0^n + c_1^n) = c_0^n + 2r(c_1^n - c_0^n)\n$$\nSimilarly, at the right boundary ($i=N-1$), the zero-flux condition implies a ghost point value $c_N^n = c_{N-2}^n$. The update rule becomes:\n$$\nc_{N-1}^{n+1} = c_{N-1}^n + r(c_N^n - 2c_{N-1}^n + c_{N-2}^n) = c_{N-1}^n + r(c_{N-2}^n - 2c_{N-1}^n + c_{N-2}^n) = c_{N-1}^n + 2r(c_{N-2}^n - c_{N-1}^n)\n$$\nThese three update rules (for interior, left boundary, and right boundary) allow for the evolution of the concentration profile over time.\n\nThe initial condition is discretized by mapping the step function onto the grid. For the given test cases, $N$ is always an odd integer. Let $N=2k+1$. The grid indices are $0, \\dots, 2k$. The midpoint grid index is $k=(N-1)/2$, which corresponds to the physical position $x_k = k \\Delta x = \\frac{N-1}{2} \\frac{L}{N-1} = L/2$. The discrete initial condition is thus:\n$$\nc_i^0 = c_0 \\quad \\text{for } i=0, \\dots, k-1\n$$\n$$\nc_i^0 = 0 \\quad \\text{for } i=k, \\dots, N-1\n$$\n\nThe simulation stops when the \"smoothing level\" is reached. This is defined by the maximum absolute spatial gradient across the domain falling below a threshold $g_{\\mathrm{thr}}$. At each time step $n$, the gradient is estimated at each grid point $i$ using the specified finite difference formulas:\n-   Left boundary ($i=0$): $g_0^n = \\frac{c_1^n - c_0^n}{\\Delta x}$\n-   Interior points ($i=1, \\dots, N-2$): $g_i^n = \\frac{c_{i+1}^n - c_{i-1}^n}{2\\Delta x}$\n-   Right boundary ($i=N-1$): $g_{N-1}^n = \\frac{c_{N-1}^n - c_{N-2}^n}{\\Delta x}$\nThe condition to check is $\\max_{i} |g_i^n| \\le g_{\\mathrm{thr}}$.\n\nThe overall algorithm is as follows:\n1.  Given the parameters $(L, N, D, c_0, r_{\\mathrm{choose}}, g_{\\mathrm{thr}}, t_{\\max})$, calculate the constants $\\Delta x = L/(N-1)$ and $\\Delta t = r_{\\mathrm{choose}} \\Delta x^2 / D$.\n2.  Initialize an $N$-element array for the concentration $c$ according to the discrete step-function initial condition.\n3.  Calculate the initial maximum absolute gradient. If it is less than or equal to $g_{\\mathrm{thr}}$, the process terminates and returns $t=0$.\n4.  Enter a time-stepping loop. A safe way to manage the loop up to $t_{\\max}$ is to determine the maximum number of integer steps, `num_steps = floor(t_max / dt)`.\n5.  For each step from $1$ to `num_steps`:\n    a. Calculate the next concentration profile $c^{n+1}$ from the current profile $c^n$ using the FTCS update equations for all grid points.\n    b. Update the current time: $t_n = n \\Delta t$.\n    c. Calculate the maximum absolute gradient for the new profile $c^{n+1}$.\n    d. If the gradient is less than or equal to $g_{\\mathrm{thr}}$, the simulation is complete, and the current time $t_n$ is returned.\n6.  If the loop finishes without meeting the threshold, it means the condition was not satisfied for any time $t \\le t_{\\max}$. In this case, a value of $-1.0$ is returned.\nThis procedure will be implemented for each test case provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D diffusion equation using the FTCS method to find the time\n    to reach a specified smoothing level for a set of test cases.\n    \"\"\"\n    \n    # Test Suite: (L, N, D, c0, r_choose, g_thr, t_max)\n    test_cases = [\n        # Case 1 (general case)\n        (1.0e-3, 801, 1.0e-9, 1000.0, 0.45, 5.0e6, 2.0),\n        # Case 2 (boundary of stability)\n        (2.0e-3, 1001, 2.0e-9, 500.0, 0.50, 1.0e6, 0.5),\n        # Case 3 (already smooth at initial time)\n        (1.0e-3, 501, 1.0e-9, 1000.0, 0.49, 3.0e8, 1.0),\n        # Case 4 (not achieved within t_max)\n        (1.0e-3, 601, 1.0e-9, 1000.0, 0.45, 1.0e2, 0.05),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        L, N, D, c0, r_choose, g_thr, t_max = case\n\n        # 1. Discretization parameters\n        dx = L / (N - 1)\n        dt = r_choose * dx**2 / D\n        \n        # 2. Initial Condition\n        c = np.zeros(N)\n        mid_idx = (N - 1) // 2\n        c[:mid_idx] = c0\n\n        # 3. Function to compute maximum absolute gradient\n        def calculate_max_grad(conc, delta_x):\n            grad = np.zeros_like(conc)\n            # Left boundary: one-sided forward difference\n            grad[0] = (conc[1] - conc[0]) / delta_x\n            # Right boundary: one-sided backward difference\n            grad[-1] = (conc[-1] - conc[-2]) / delta_x\n            # Interior points: central difference\n            grad[1:-1] = (conc[2:] - conc[:-2]) / (2 * delta_x)\n            return np.max(np.abs(grad))\n\n        # 4. Check condition at t=0\n        initial_max_grad = calculate_max_grad(c, dx)\n        if initial_max_grad <= g_thr:\n            results.append(0.0)\n            continue\n        \n        # 5. Time-stepping loop\n        found_time = -1.0\n        \n        # Use integer steps to avoid floating point issues in loop termination\n        if dt > 0:\n            num_steps = int(t_max / dt)\n        else:\n            num_steps = 0\n            \n        current_time = 0.0\n        c_new = np.copy(c)\n\n        for step in range(1, num_steps + 1):\n            current_time = step * dt\n            \n            # FTCS Update (vectorized)\n            # Interior points\n            c_new[1:-1] = c[1:-1] + r_choose * (c[2:] - 2 * c[1:-1] + c[:-2])\n            \n            # Boundary points (zero-flux)\n            c_new[0] = c[0] + 2 * r_choose * (c[1] - c[0])\n            c_new[-1] = c[-1] + 2 * r_choose * (c[-2] - c[-1])\n            \n            c = np.copy(c_new)\n\n            # Check for smoothing level\n            max_grad = calculate_max_grad(c, dx)\n            if max_grad <= g_thr:\n                found_time = current_time\n                break\n        \n        results.append(found_time)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A critical step in scientific computing is verifying that a program produces accurate results. This practice introduces you to Richardson extrapolation, a powerful technique for assessing the convergence rate of a numerical simulation and obtaining a more accurate solution estimate. By implementing the robust Crank-Nicolson scheme and comparing results from two different grid resolutions, you will learn how to numerically confirm your code's order of accuracy and improve your predictions, a fundamental skill for any computational research.",
            "id": "4246157",
            "problem": "Consider one-dimensional diffusion of a dissolved species toward a planar electrode, modeled by Fick's second law on a finite interval to approximate a semi-infinite domain. Let $x \\in [0,L]$ and $t \\ge 0$. The concentration field $c(x,t)$ satisfies the partial differential equation $c_t = D c_{xx}$, where $D$ is the diffusion coefficient. The initial and boundary conditions model a uniform initial concentration with an absorbing electrode at the origin and a far-field concentration held at the initial value: $c(x,0) = c_0$ for $x \\in (0,L]$, $c(0,t) = 0$ for $t \\ge 0$, and $c(L,t) = c_0$ for $t \\ge 0$. In computational electrochemistry, this setup approximates semi-infinite diffusion toward a perfectly absorbing planar electrode with a fixed concentration reservoir at $x=L$.\n\nYour task is to implement a second-order central finite difference in space combined with the Crank–Nicolson (CN) time stepping method (Crank–Nicolson (CN) is a classical unconditionally stable, second-order accurate implicit time discretization) to compute the numerical solution at time $T$ using two grid spacings $h$ and $h/2$. Use the exact semi-infinite solution for this boundary value problem as the reference to compute absolute errors (you must derive and state the exact solution in your solution). Then:\n\n1. Compute the Richardson extrapolation estimate at a specified location $x_\\star$, combining the numerical values at $h$ and $h/2$.\n2. Assess the observed order of accuracy $p$ with respect to spatial refinement using the base-$2$ logarithmic ratio of the absolute errors computed at the two grid spacings.\n\nAll quantities must use physically consistent units: $D$ in $\\mathrm{m^2/s}$, $x$ and $L$ in $\\mathrm{m}$, $t$ and $T$ in $\\mathrm{s}$, and $c$ in $\\mathrm{mol/m^3}$. Report all concentrations in $\\mathrm{mol/m^3}$ and observed orders as dimensionless numbers. Angles are not involved. Do not use percentages; any ratios must be reported as decimals.\n\nImplement the algorithm and apply it to the following test suite of parameter values. For each case, use the same time step $\\,\\Delta t\\,$ for both grids so that temporal error does not mask spatial order. The two spatial grid spacings to be used are $h$ and $h/2$.\n\n- Case A (general accuracy, far boundary non-influential):\n  - $D = 1.0 \\times 10^{-9}\\ \\mathrm{m^2/s}$,\n  - $c_0 = 1.0\\ \\mathrm{mol/m^3}$,\n  - $L = 1.0 \\times 10^{-3}\\ \\mathrm{m}$,\n  - $T = 0.1\\ \\mathrm{s}$,\n  - $x_\\star = 5.0 \\times 10^{-5}\\ \\mathrm{m}$,\n  - $h = 2.0 \\times 10^{-5}\\ \\mathrm{m}$,\n  - $\\Delta t = 5.0 \\times 10^{-4}\\ \\mathrm{s}$.\n\n- Case B (short-time diffusion layer, slower species):\n  - $D = 1.0 \\times 10^{-10}\\ \\mathrm{m^2/s}$,\n  - $c_0 = 1.0\\ \\mathrm{mol/m^3}$,\n  - $L = 1.0 \\times 10^{-3}\\ \\mathrm{m}$,\n  - $T = 0.01\\ \\mathrm{s}$,\n  - $x_\\star = 1.0 \\times 10^{-5}\\ \\mathrm{m}$,\n  - $h = 5.0 \\times 10^{-5}\\ \\mathrm{m}$,\n  - $\\Delta t = 5.0 \\times 10^{-5}\\ \\mathrm{s}$.\n\n- Case C (far boundary closer, possible degradation due to finite domain):\n  - $D = 1.0 \\times 10^{-9}\\ \\mathrm{m^2/s}$,\n  - $c_0 = 1.0\\ \\mathrm{mol/m^3}$,\n  - $L = 1.0 \\times 10^{-4}\\ \\mathrm{m}$,\n  - $T = 0.1\\ \\mathrm{s}$,\n  - $x_\\star = 5.0 \\times 10^{-5}\\ \\mathrm{m}$,\n  - $h = 2.0 \\times 10^{-6}\\ \\mathrm{m}$,\n  - $\\Delta t = 5.0 \\times 10^{-4}\\ \\mathrm{s}$.\n\nFor each case:\n- Compute the numerical concentration at $x_\\star$ and $t=T$ for the two grids.\n- Compute the absolute errors at $x_\\star$ with respect to the exact semi-infinite solution at $t=T$.\n- Compute the observed order $p$ from the error pair associated with $h$ and $h/2$.\n- Compute the Richardson extrapolated concentration estimate at $x_\\star$ using the two grid values and the observed order.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each case's result is itself a two-element list. The two elements are, in order, the Richardson extrapolated concentration at $x_\\star$ in $\\mathrm{mol/m^3}$ (rounded to six decimal places) and the observed order $p$ (rounded to six decimal places). For example, the output format must be exactly like:\n[[c_A,p_A],[c_B,p_B],[c_C,p_C]]\nwith no additional text before or after.",
            "solution": "The problem is subjected to validation before proceeding with a solution.\n\n### Step 1: Extract Givens\n- **Governing Equation**: $c_t = D c_{xx}$ for $x \\in [0,L]$ and $t \\ge 0$.\n- **Initial Condition**: $c(x,0) = c_0$ for $x \\in (0,L]$.\n- **Boundary Conditions**: $c(0,t) = 0$ for $t \\ge 0$ and $c(L,t) = c_0$ for $t \\ge 0$.\n- **Numerical Method**: Second-order central finite difference in space; Crank-Nicolson (CN) method for time stepping.\n- **Analysis Tasks**:\n  1. Compute numerical solution at time $T$ for grid spacings $h$ and $h/2$, keeping the time step $\\Delta t$ constant.\n  2. Use the exact semi-infinite solution as a reference for error calculation.\n  3. Compute Richardson extrapolation estimate at $x_\\star$ using results from grids $h$ and $h/2$.\n  4. Compute the observed order of accuracy $p$ from the absolute errors of the two grids.\n- **Data Units**: $D$ in $\\mathrm{m^2/s}$, $x, L, h$ in $\\mathrm{m}$, $t, T, \\Delta t$ in $\\mathrm{s}$, $c, c_0$ in $\\mathrm{mol/m^3}$.\n- **Test Cases**:\n  - **Case A**: $D = 1.0 \\times 10^{-9}\\ \\mathrm{m^2/s}$, $c_0 = 1.0\\ \\mathrm{mol/m^3}$, $L = 1.0 \\times 10^{-3}\\ \\mathrm{m}$, $T = 0.1\\ \\mathrm{s}$, $x_\\star = 5.0 \\times 10^{-5}\\ \\mathrm{m}$, $h = 2.0 \\times 10^{-5}\\ \\mathrm{m}$, $\\Delta t = 5.0 \\times 10^{-4}\\ \\mathrm{s}$.\n  - **Case B**: $D = 1.0 \\times 10^{-10}\\ \\mathrm{m^2/s}$, $c_0 = 1.0\\ \\mathrm{mol/m^3}$, $L = 1.0 \\times 10^{-3}\\ \\mathrm{m}$, $T = 0.01\\ \\mathrm{s}$, $x_\\star = 1.0 \\times 10^{-5}\\ \\mathrm{m}$, $h = 5.0 \\times 10^{-5}\\ \\mathrm{m}$, $\\Delta t = 5.0 \\times 10^{-5}\\ \\mathrm{s}$.\n  - **Case C**: $D = 1.0 \\times 10^{-9}\\ \\mathrm{m^2/s}$, $c_0 = 1.0\\ \\mathrm{mol/m^3}$, $L = 1.0 \\times 10^{-4}\\ \\mathrm{m}$, $T = 0.1\\ \\mathrm{s}$, $x_\\star = 5.0 \\times 10^{-5}\\ \\mathrm{m}$, $h = 2.0 \\times 10^{-6}\\ \\mathrm{m}$, $\\Delta t = 5.0 \\times 10^{-4}\\ \\mathrm{s}$.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded**: The problem describes one-dimensional diffusion modeled by Fick's second law, a fundamental principle in mass transfer and electrochemistry. The boundary conditions correspond to a standard chronoamperometry experiment. The numerical method (Crank-Nicolson) is a standard, well-established technique for parabolic partial differential equations. The use of a finite domain to approximate a semi-infinite one is a common and valid computational strategy. The parameters are physically realistic. The problem is scientifically sound.\n2.  **Well-Posed**: The problem is a linear parabolic PDE with well-defined initial and Dirchlet boundary conditions. This constitutes a well-posed initial-boundary value problem, which guarantees the existence of a unique and stable solution.\n3.  **Objective**: The problem is stated in precise mathematical and physical terms, free of subjectivity or ambiguity.\n4.  **Completeness**: All necessary parameters ($D, c_0, L, T, x_\\star, h, \\Delta t$) are provided for each case. The problem is self-contained.\n5.  **Consistency**: There are no internal contradictions. For instance, the condition to use the semi-infinite exact solution as a benchmark for a finite-domain simulation is a deliberate and valid part of a numerical analysis exercise, designed to investigate the effect of the finite boundary. The diffusion length, $\\delta \\approx \\sqrt{Dt}$, is much less than $L$ in Cases A and B, making the semi-infinite approximation excellent. In Case C, $\\delta$ is a non-trivial fraction of $L$, which is a valid scenario to test the limitations of the approximation, as stated in the problem.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It is a well-defined, scientifically sound problem in computational electrochemistry. A complete solution will be provided.\n\n### Solution\nThe problem requires the numerical solution of the one-dimensional diffusion equation, followed by an error analysis using Richardson extrapolation.\n\n**1. Governing Equation and Exact Solution**\n\nThe concentration $c(x,t)$ of a species diffusing towards a planar electrode is governed by Fick's second law:\n$$\n\\frac{\\partial c}{\\partial t} = D \\frac{\\partial^2 c}{\\partial x^2}\n$$\nThe problem is defined on a finite domain $x \\in [0, L]$ with initial and boundary conditions:\n$$\nc(x,0) = c_0, \\quad x \\in (0, L]\n$$\n$$\nc(0,t) = 0, \\quad t \\ge 0\n$$\n$$\nc(L,t) = c_0, \\quad t \\ge 0\n$$\nThis setup is a numerical approximation of a semi-infinite domain problem ($L \\to \\infty$) where the far-field concentration remains undisturbed. For the semi-infinite case, the boundary condition $c(L,t)=c_0$ is replaced by $\\lim_{x\\to\\infty} c(x,t) = c_0$. The exact analytical solution for this semi-infinite problem, often derived using the Laplace transform or a similarity transformation, is given by the Cottrell equation:\n$$\nc_{exact}(x,t) = c_0 \\text{erf}\\left(\\frac{x}{2\\sqrt{Dt}}\\right)\n$$\nwhere $\\text{erf}$ is the error function. This exact solution will serve as the benchmark against which we compare our numerical results. The discrepancy between the numerical solution on the finite domain and this exact solution will comprise both the numerical discretization error and the modeling error from the finite-domain approximation.\n\n**2. Numerical Method: The Crank-Nicolson Scheme**\n\nWe discretize the domain in space and time. Let $x_j = j h$ for $j=0, 1, \\dots, N_x$ where $h$ is the spatial step and $N_x h = L$. Let $t_n = n \\Delta t$ for $n=0, 1, \\dots, N_t$ where $\\Delta t$ is the time step and $N_t \\Delta t = T$. Let $c_j^n$ denote the numerical approximation of $c(x_j, t_n)$.\n\nThe second spatial derivative is approximated using a second-order central difference:\n$$\n\\frac{\\partial^2 c}{\\partial x^2}\\bigg|_{x_j, t_n} \\approx \\frac{c_{j-1}^n - 2c_j^n + c_{j+1}^n}{h^2}\n$$\nThe Crank-Nicolson method is an implicit scheme that averages the spatial finite difference at the current time step $n$ and the next time step $n+1$. This yields second-order accuracy in time.\n$$\n\\frac{c_j^{n+1} - c_j^n}{\\Delta t} = \\frac{D}{2} \\left( \\frac{c_{j-1}^{n+1} - 2c_j^{n+1} + c_{j+1}^{n+1}}{h^2} + \\frac{c_{j-1}^n - 2c_j^n + c_{j+1}^n}{h^2} \\right)\n$$\nThis applies to the interior grid points, $j = 1, 2, \\dots, N_x-1$.\n\nLet's define the diffusion number $\\alpha = \\frac{D \\Delta t}{2h^2}$. We rearrange the equation to group unknown terms (at time step $n+1$) on the left-hand side (LHS) and known terms (at time step $n$) on the right-hand side (RHS):\n$$\n-\\alpha c_{j-1}^{n+1} + (1+2\\alpha)c_j^{n+1} - \\alpha c_{j+1}^{n+1} = \\alpha c_{j-1}^n + (1-2\\alpha)c_j^n + \\alpha c_{j+1}^n\n$$\nThis equation forms a system of $N_x-1$ linear equations for the unknown interior concentrations $\\{c_j^{n+1}\\}_{j=1}^{N_x-1}$. The system can be written in matrix form as $\\mathbf{A} \\mathbf{c}^{n+1} = \\mathbf{d}^n$, where $\\mathbf{A}$ is a $(N_x-1) \\times (N_x-1)$ tridiagonal matrix and $\\mathbf{d}^n$ is the RHS vector.\n\nThe boundary conditions are $c_0^n = c(0, t_n) = 0$ and $c_{N_x}^n = c(L, t_n) = c_0$ for all $n$. These values are incorporated into the equations for the first ($j=1$) and last ($j=N_x-1$) interior points:\n\nFor $j=1$:\n$$\n(1+2\\alpha)c_1^{n+1} - \\alpha c_2^{n+1} = \\alpha c_0^n + (1-2\\alpha)c_1^n + \\alpha c_2^n = (1-2\\alpha)c_1^n + \\alpha c_2^n\n$$\n(since $c_0^n=0$ and $c_0^{n+1}=0$)\n\nFor $j=N_x-1$:\n$$\n-\\alpha c_{N_x-2}^{n+1} + (1+2\\alpha)c_{N_x-1}^{n+1} = \\alpha c_{N_x-2}^n + (1-2\\alpha)c_{N_x-1}^n + \\alpha c_{N_x}^n + \\alpha c_{N_x}^{n+1}\n$$\nSince $c_{N_x}^n=c_{N_x}^{n+1}=c_0$, the RHS becomes:\n$$\n\\text{RHS}_{N_x-1} = \\alpha c_{N_x-2}^n + (1-2\\alpha)c_{N_x-1}^n + 2\\alpha c_0\n$$\nThe resulting tridiagonal system is solved at each time step. Since the matrix $\\mathbf{A}$ is constant, this is computationally efficient, especially when using a dedicated tridiagonal solver like the Thomas algorithm.\n\n**3. Error Analysis and Extrapolation**\n\nWe perform two simulations for each case, one with spatial step $h$ and another with $h/2$, keeping $\\Delta t$ constant. This isolates the error contribution from spatial discretization.\n\n**Observed Order of Accuracy ($p$)**:\nThe leading term of the spatial discretization error is of the form $E_h \\approx K h^p$, where $K$ is a constant and $p$ is the order of accuracy. For our second-order central difference scheme, we expect $p \\approx 2$. Given the numerical errors $E_h$ and $E_{h/2}$ for step sizes $h$ and $h/2$, we can estimate $p$:\n$$\n\\frac{E_h}{E_{h/2}} \\approx \\frac{K h^p}{K (h/2)^p} = 2^p \\implies p \\approx \\log_2\\left(\\frac{E_h}{E_{h/2}}\\right)\n$$\nwhere $E_h = |c_h(x_\\star,T) - c_{exact}(x_\\star,T)|$.\n\n**Richardson Extrapolation**:\nThis technique provides a more accurate estimate of the solution by combining results from two different grid spacings. Let $C_h$ and $C_{h/2}$ be the numerical solutions at $x_\\star$ for step sizes $h$ and $h/2$, and $C_{exact}$ be the true solution. We have:\n$$\nC_h \\approx C_{exact} + K h^p\n$$\n$$\nC_{h/2} \\approx C_{exact} + K (h/2)^p\n$$\nEliminating the error term $K h^p$, we obtain an improved estimate, $C_{RE}$:\n$$\nC_{RE} = \\frac{2^p C_{h/2} - C_h}{2^p - 1} = C_{h/2} + \\frac{C_{h/2} - C_h}{2^p-1}\n$$\nAs per the problem, we use the numerically observed order $p$ in this formula.\n\n**4. Computational Strategy**\n\nFor each test case, the algorithm is as follows:\n1.  Define the physical and numerical parameters for the coarse grid ($h$) and fine grid ($h/2$).\n2.  For each grid:\n    a. Determine the number of spatial points $N_x$ and time steps $N_t$.\n    b. Initialize the concentration vector $c$ according to the initial condition $c(x,0)=c_0$ for $x>0$ and $c(0,0)=0$.\n    c. Construct the tridiagonal matrix $\\mathbf{A}$ in a banded format suitable for `scipy.linalg.solve_banded`.\n    d. Loop from $n=0$ to $N_t-1$:\n        i. Construct the RHS vector $\\mathbf{d}^n$ based on the concentration at time $t_n$.\n        ii. Solve the linear system $\\mathbf{A} \\mathbf{c}^{n+1} = \\mathbf{d}^n$ to find the concentration at $t_{n+1}$.\n    e. After the time-stepping loop, use linear interpolation to find the concentration at the specific point $x_\\star$, if it does not fall on a grid node.\n3.  Calculate the exact solution $c_{exact}$ at $(x_\\star, T)$.\n4.  Compute the absolute errors $E_h$ and $E_{h/2}$.\n5.  Calculate the observed order of accuracy $p$.\n6.  Calculate the Richardson-extrapolated concentration $C_{RE}$.\n7.  Store the pair $[C_{RE}, p]$ for the final output.\n8.  Repeat for all test cases and format the final output as specified.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import erf\nfrom scipy.linalg import solve_banded\n\ndef run_simulation(D, c0, L, T, h, dt, x_star):\n    \"\"\"\n    Solves the 1D diffusion equation using the Crank-Nicolson method.\n\n    Returns:\n        float: The numerical concentration at position x_star and time T.\n    \"\"\"\n    # Grid setup\n    # Ensure L is a multiple of h to avoid issues at the boundary\n    if not np.isclose(L/h, round(L/h)):\n        raise ValueError(\"L must be an integer multiple of h.\")\n    Nx = int(round(L / h))\n    Nt = int(round(T / dt))\n\n    # Grid points in space\n    x = np.linspace(0, L, Nx + 1)\n    \n    # Diffusion number\n    alpha = D * dt / (2.0 * h**2)\n\n    # Initial condition\n    # c[j] corresponds to concentration at x_j\n    c = np.full(Nx + 1, c0)\n    c[0] = 0.0 # Boundary condition at x=0\n\n    # Number of interior points\n    N_int = Nx - 1\n\n    # Tridiagonal matrix A for the LHS, in banded format for solve_banded\n    # ab has 3 rows: super-diagonal, main-diagonal, sub-diagonal\n    ab = np.zeros((3, N_int))\n    ab[0, 1:] = -alpha      # Super-diagonal\n    ab[1, :] = 1.0 + 2.0 * alpha # Main diagonal\n    ab[2, :-1] = -alpha     # Sub-diagonal\n\n    # Time stepping loop\n    for _ in range(Nt):\n        # Construct the RHS vector rhs\n        rhs = np.zeros(N_int)\n        \n        # RHS for j=1 (index 0)\n        # alpha*c[0] is zero, so it is omitted.\n        rhs[0] = (1.0 - 2.0 * alpha) * c[1] + alpha * c[2]\n        \n        # RHS for j=2...Nx-2 (indices 1 to N_int-2)\n        if N_int > 2:\n            rhs[1:-1] = alpha * c[1:-3] + (1.0 - 2.0 * alpha) * c[2:-2] + alpha * c[3:-1]\n        \n        # RHS for j=Nx-1 (index N_int-1)\n        if N_int > 1:\n           rhs[-1] = alpha * c[Nx-2] + (1.0 - 2.0 * alpha) * c[Nx-1] + alpha * c[Nx]\n        \n        # Add the boundary condition terms to RHS\n        # At j=1, c_0^n+1 term is 0. Nothing to add.\n        # At j=Nx-1, we need to add alpha * c_{N_x}^{n+1} = alpha * c0\n        rhs[-1] += alpha * c0\n\n        # Solve the tridiagonal system for the next time step's interior points\n        c_new_int = solve_banded((1, 1), ab, rhs)\n        c[1:Nx] = c_new_int\n\n    # Interpolate to find concentration at x_star\n    # Find the index 'j' such that x[j] <= x_star < x[j+1]\n    if not (0 <= x_star <= L):\n        raise ValueError(\"x_star must be within the domain [0, L]\")\n    \n    pos = x_star / h\n    j = int(np.floor(pos))\n    \n    if np.isclose(pos, j): # x_star is a grid point\n        return c[j]\n    elif j + 1 <= Nx: # Linear interpolation\n        frac = pos - j\n        return c[j] * (1.0 - frac) + c[j+1] * frac\n    else: # Should not happen if x_star <= L\n        return c[Nx]\n\ndef solve():\n    test_cases = [\n        # Case A\n        {'D': 1.0e-9, 'c0': 1.0, 'L': 1.0e-3, 'T': 0.1, 'x_star': 5.0e-5, 'h': 2.0e-5, 'dt': 5.0e-4},\n        # Case B\n        {'D': 1.0e-10, 'c0': 1.0, 'L': 1.0e-3, 'T': 0.01, 'x_star': 1.0e-5, 'h': 5.0e-5, 'dt': 5.0e-5},\n        # Case C\n        {'D': 1.0e-9, 'c0': 1.0, 'L': 1.0e-4, 'T': 0.1, 'x_star': 5.0e-5, 'h': 2.0e-6, 'dt': 5.0e-4},\n    ]\n\n    results = []\n    for params in test_cases:\n        D, c0, L, T = params['D'], params['c0'], params['L'], params['T']\n        x_star, h, dt = params['x_star'], params['h'], params['dt']\n\n        # Run for coarse grid (h)\n        c_h = run_simulation(D, c0, L, T, h, dt, x_star)\n\n        # Run for fine grid (h/2)\n        c_h2 = run_simulation(D, c0, L, T, h / 2.0, dt, x_star)\n\n        # Calculate exact solution\n        c_exact = c0 * erf(x_star / (2.0 * np.sqrt(D * T)))\n\n        # Calculate errors\n        error_h = abs(c_h - c_exact)\n        error_h2 = abs(c_h2 - c_exact)\n\n        # Calculate observed order of accuracy, p\n        # Handle case where error is zero to avoid division by zero\n        if error_h2 == 0 or error_h == 0:\n            p = np.inf if error_h > 0 else 2.0 # Assume ideal second order if no error\n        else:\n            p = np.log2(error_h / error_h2)\n\n        # Calculate Richardson extrapolation\n        # c_RE = c_h2 + (c_h2 - c_h) / (2**p - 1)\n        # Handle case of p being such that 2**p - 1 is zero or near zero.\n        if np.isclose(2**p, 1.0):\n            # p is close to 0, extrapolation is unreliable. Best estimate is the finest grid.\n            c_richardson = c_h2\n        else:\n            c_richardson = c_h2 + (c_h2 - c_h) / (2.0**p - 1.0)\n        \n        results.append([c_richardson, p])\n\n    # Format output string\n    formatted_results = []\n    for res in results:\n        p_val = res[1] if np.isfinite(res[1]) else 0.0\n        formatted_results.append(f\"[{res[0]:.6f},{p_val:.6f}]\")\n    \n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}