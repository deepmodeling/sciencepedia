{
    "hands_on_practices": [
        {
            "introduction": "重组能 $\\lambda$ 是 Marcus 理论的基石，它量化了电子转移前后系统核构型变化所需的能量。然而，当氧化还原分子靠近金属电极时，由于介电屏蔽和镜像电荷效应，其有效 $\\lambda$ 值会发生改变。本练习将通过一个假设情景，探讨这种界面效应对 $\\lambda$ 的影响，并进一步分析其如何改变 Marcus-Hush-Chidsey (MHC) 模型中电流与过电势的依赖关系，从而加深对体相与界面电子转移差异的理解。",
            "id": "4260311",
            "problem": "一个氧化还原分子在浸入高介电常数溶剂的平面金属电极上进行外层电子转移。在本体溶液中，外层重组能为 $\\lambda_{\\text{bulk}} = 0.8$ 电子伏特 (eV)。在金属附近，介电屏蔽会降低外层重组能。假设存在一个基于物理原理、依赖于距离的折减因子 $\\alpha(d)$，该因子解释了镜像电荷屏蔽和溶剂极化抑制，使得局域重组能为 $\\lambda(d) = \\alpha(d)\\,\\lambda_{\\text{bulk}}$。在分子-电极间距为 $d = 5$ 埃时，一个计算连续介质静电学模型得出 $\\alpha(d) = 0.6$。\n\n利用电子转移理论的第一性原理，从重组能的定义（即在初始和最终电子态之间扭曲原子核与溶剂坐标所需的能量代价）出发。解释电子转移的自由能活化能垒如何从抛物线形自由能面中产生，以及驱动力如何依赖于过电势。然后，引用电极的连续电子态及其由费米-狄拉克分布所占据的情况，将这些思想与电极动力学的 Marcus–Hush–Chidsey 模型联系起来，并定性解释 $\\lambda$ 的减小如何影响速率/电流对过电势的依赖性。\n\n任务：\n1. 使用折减因子 $\\alpha(d)=0.6$，计算在 $d=5$ 埃时的修正重组能 $\\lambda(d)$。\n2. 简要讨论，利用抛物线形自由能图像以及金属的费米-狄拉克占据态的作用，$\\lambda$ 的减小如何改变非均相电子转移速率/电流对过电势的依赖性（对于单电子转移，使用反应驱动力通过界面电化学功包含过电势这一事实）。\n\n修正重组能以电子伏特 (eV) 表示。将您的数值答案四舍五入至三位有效数字。",
            "solution": "此问题的理论框架是 Marcus 外层电子转移理论，该理论描述了在两个保持电子弱耦合的化学物种之间（或一个物种与一个电极之间）电子移动的速率。\n\n**第 2 部分：理论解释（作为第 1 部分的基础）**\n\n该理论的核心是将系统（反应物和产物态）的自由能建模为集体原子核坐标 $q$ 的函数，该坐标代表了氧化还原分子中所有原子以及周围溶剂分子的位置。对于反应物（例如，氧化形式 + 电极中的电子，$O + e^-$）和产物（例如，还原形式，$R$）态，自由能面近似为抛物线：\n\n$$ G_R(q) = A q^2 $$\n$$ G_P(q) = A (q - q_0)^2 + \\Delta G^{0'} $$\n\n在这里，$\\Delta G^{0'}$ 是反应的电化学自由能，即驱动力。重组能 $\\lambda$ 定义为将反应物系统从其平衡核构型（$q=0$）扭曲到产物态的平衡核构型（$q=q_0$）所需的能量，而电子转移并未发生。在数学上，这对应于能量差 $G_R(q_0) - G_R(0)$。从抛物线模型可以看出，这也等于从产物最小值到反应物抛物线上对应点的能量：$G_P(0) - G_P(q_0)$。这给出了：\n\n$$ \\lambda = A q_0^2 $$\n\n电子转移最可能发生在这两个抛物线的交点处，在该点系统从一个电子态过渡到另一个电子态的能量代价最低（Franck-Condon 原理）。自由能活化能垒 $\\Delta G^{\\ddagger}$ 是反应物最小值与此交点之间的能量差。通过设 $G_R(q^*) = G_P(q^*)$ 来找到交叉坐标 $q^*$，然后计算 $G_R(q^*)$，可以得到著名的 Marcus 活化能垒表达式：\n\n$$ \\Delta G^{\\ddagger} = \\frac{(\\lambda + \\Delta G^{0'})^2}{4\\lambda} $$\n\n对于电极反应，驱动力 $\\Delta G^{0'}$ 与外加电极电势 $E$ 直接相关。对于单电子转移，驱动力依赖于过电势 $\\eta = E - E^0_{eq}$，其中 $E^0_{eq}$ 是平衡电势。电化学自由能变是 $\\Delta G^{0'} = -e\\eta$，其中 $e$ 是元电荷。因此，活化能垒成为过电势的函数：\n\n$$ \\Delta G^{\\ddagger}(\\eta) = \\frac{(\\lambda - e\\eta)^2}{4\\lambda} $$\n\nMarcus-Hush-Chidsey (MHC) 模型将此概念扩展到具有连续电子态的金属电极。总电子转移速率是通过对电极中每个能级 $\\epsilon$ 的单个速率进行积分得到的，积分时要乘以该态被占据的概率（由费米-狄拉克分布 $f(\\epsilon, T) = (1 + \\exp((\\epsilon - \\epsilon_F)/(k_B T)))^{-1}$ 给出，其中 $\\epsilon_F$ 是费米能级）以及末态为空的概率。这种积分平滑了简单 Marcus 模型为均相反应预测的尖锐“倒转区”。对 $\\lambda$ 和 $\\eta$ 的关键依赖性包含在被积函数的活化能项中。总电流与此积分速率成正比。\n\n现在，我们可以回答具体问题。\n\n**第 1 部分：修正重组能的计算**\n\n我们已知本体重组能 $\\lambda_{\\text{bulk}} = 0.8 \\text{ eV}$ 和在距离 $d = 5$ 埃时的折减因子 $\\alpha(d) = 0.6$。局域重组能 $\\lambda(d)$ 计算如下：\n\n$$ \\lambda(d) = \\alpha(d) \\lambda_{\\text{bulk}} $$\n$$ \\lambda(5 \\text{ 埃}) = (0.6) \\times (0.8 \\text{ eV}) = 0.48 \\text{ eV} $$\n\n四舍五入至三位有效数字，结果为 $0.480 \\text{ eV}$。与本体值相比的这种降低，物理上是由于导电金属电极的存在，它产生了一个镜像电荷，部分地稳定了活化过程中发生的电荷重新分布，从而降低了能量代价，特别是对于重组能的溶剂部分。\n\n**第 2 部分：$\\lambda$ 减小对速率-过电势依赖性的影响**\n\n为了理解 $\\lambda$ 的减小如何影响动力学，我们分析活化能垒表达式 $\\Delta G^{\\ddagger}(\\eta) = \\frac{(\\lambda - e\\eta)^2}{4\\lambda}$。速率常数 $k_{het}$ 通过一个类阿伦尼乌斯表达式与该能垒相关，即 $k_{het} \\propto \\exp(-\\Delta G^{\\ddagger}/(k_B T))$。\n\n1.  **在零过电势下的影响**：在 $\\eta=0$ 时，活化能垒为 $\\Delta G^{\\ddagger}(0) = \\frac{\\lambda^2}{4\\lambda} = \\frac{\\lambda}{4}$。较小的 $\\lambda$ 导致平衡时较小的活化能垒。这显著*增加*了电子转移的内禀速率，即交换电流密度 ($j_0$) 或标准非均相速率常数 ($k^0$)。\n\n2.  **对过电势依赖性的影响**：电流的对数与过电势之间的关系（塔菲尔图）由 $\\Delta G^{\\ddagger}$ 如何随 $\\eta$ 变化决定。Butler-Volmer 模型将这种关系在小 $\\eta$ 时近似为线性，其特征是传递系数 $\\alpha_{ET} \\approx 0.5$。在 Marcus 框架中，传递系数是依赖于电势的：\n    $$ \\alpha_{ET}(\\eta) = \\frac{\\partial \\Delta G^{\\ddagger}}{\\partial (e\\eta)} = \\frac{1}{e} \\frac{\\partial}{\\partial \\eta} \\left( \\frac{(\\lambda - e\\eta)^2}{4\\lambda} \\right) = \\frac{1}{e} \\left( \\frac{2(\\lambda - e\\eta)(-e)}{4\\lambda} \\right) = \\frac{1}{2} - \\frac{e\\eta}{2\\lambda} $$\n    该表达式表明：\n    - 在 $\\eta=0$ 时，$\\alpha_{ET} = 0.5$，与 Butler-Volmer 理论一致。\n    - 随着 $|\\eta|$ 的增加，$\\alpha_{ET}$ 偏离 $0.5$。\n    - 这种偏离的幅度与 $\\lambda$ 成反比。因此，一个*较小*的 $\\lambda$ 值使得传递系数对过电势的变化更加敏感。对于任何给定的 $\\eta \\neq 0$，项 $|e\\eta|/(2\\lambda)$ 会变得更大。\n\n总之，降低重组能 $\\lambda$ 有两个主要后果：\n(i) 它增加了电子转移的内禀速率（交换电流）。\n(ii) 它使得电流-过电势关系更加非线性。塔菲尔图（$\\ln|j|$ vs. $|\\eta|$）表现出更大的曲率，这意味着当过电势从零增加时，表观传递系数会更快地偏离 $0.5$。电流在高驱动力下更快地达到饱和。这反映了对于一个具有低重组能的系统，达到电子转移的最佳能量所需的过电势较低。",
            "answer": "$$\\boxed{0.480}$$"
        },
        {
            "introduction": "在理解了 MHC 模型的关键参数后，下一步是学习如何实际计算其预测的反应速率。MHC 速率常数的核心是一个积分表达式，它通常没有解析解，因此必须依赖数值方法。本实践将指导您使用一种高效且经典的数值技术——Gauss-Hermite 求积法，来精确计算该积分。通过完成这项任务，您将获得将理论公式转化为实用计算代码的宝贵经验，并深入了解数值方法的收敛性和准确性，这是计算化学领域的一项核心技能。",
            "id": "4260295",
            "problem": "你的任务是实现一个数值算法，用于计算 Marcus–Hush–Chidsey 电极动力学模型中出现的高斯-费米卷积。从统计力学和电子转移理论的基本原理出发，考虑一个位于电极上的电子，其化学势设为零，电子能量变量以热单位表示为 $x = \\varepsilon / (k_B T)$，其中 $k_B$ 是玻尔兹曼常数，$T$ 是绝对温度。费米-狄拉克占据因子为 $f(x) = 1 / \\left(1 + e^{x}\\right)$。核重组由一个高斯因子建模，其宽度由重组能 $\\lambda$ 控制，并对能量失配施加二次惩罚。在无量纲形式下，设 $\\Lambda = \\lambda / (k_B T)$，以及一个无量纲驱动参数 $\\delta$（过电势和标准自由能的平移组合，并由 $k_B T$ 进行缩放），速率评估的核心卷积积分可以写为\n$$\nI(\\delta,\\Lambda) = \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{(x - \\delta)^2}{4 \\Lambda}\\right)\\,\\frac{1}{1 + e^{x}}\\,dx.\n$$\n\n你的目标是通过将积分变换为带有权重 $\\exp(-u^2)$ 的标准 Hermite 形式，来实现 Gauss–Hermite 求积。具体来说，你必须：\n- 推导变量替换，将 $I(\\delta,\\Lambda)$ 变换为 $\\int_{-\\infty}^{\\infty} e^{-u^2} g(u)\\,du$ 形式的积分，其中 $g(u)$ 依赖于 $\\delta$ 和 $\\Lambda$。\n- 使用 n 点 Gauss–Hermite 法则来近似变换后的积分，从而近似 $I(\\delta,\\Lambda)$。\n- 通过与对变换后积分在 $u \\in (-\\infty,\\infty)$ 上进行直接数值积分计算出的高精度参考值进行比较，来验证关于节点数 $n$ 的收敛性。\n\n设计一个程序，对于一组指定的 $\\Lambda$ 和 $\\delta$ 值，计算在给定的一组 $n$ 值中，每个 $n$ 在 $\\delta$ 值网格上 Gauss–Hermite 近似的最大相对误差。然后，对于每个 $\\Lambda$，确定该组中能使最大相对误差小于指定容差 $\\varepsilon$ 的最小 $n$ 值。\n\n所有计算都应以无量纲形式进行；最终的数值结果中不需要物理单位。不涉及角度。相对误差必须表示为十进制数。\n\n使用以下测试套件：\n- 无量纲重组能 $\\Lambda \\in \\{\\,0.5,\\,2.0,\\,20.0,\\,50.0\\,\\}$。\n- 无量纲驱动参数 $\\delta \\in \\{\\, -10.0,\\, -2.0,\\, 0.0,\\, 2.0,\\, 10.0 \\,\\}$。\n- Gauss–Hermite 节点数 $n \\in \\{\\,4,\\,8,\\,16,\\,32,\\,64\\,\\}$。\n- 容差 $\\varepsilon = 10^{-8}$。\n\n你的程序必须：\n- 使用权重为 $\\exp(-u^2)$ 的标准节点和权重实现 Gauss–Hermite 近似。\n- 通过对变换后的 $u$ 积分进行直接数值积分，计算 $I(\\delta,\\Lambda)$ 的高精度参考值。\n- 对于每个 $\\Lambda$，计算在给定的 $\\delta$ 网格上每个 $n$ 的最大相对误差。\n- 对于每个 $\\Lambda$，返回集合 $\\{\\,4,\\,8,\\,16,\\,32,\\,64\\,\\}$ 中使得最大相对误差小于 $\\varepsilon$ 的最小 $n$。如果没有 $n$ 达到此容差，则返回最大的 $n$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个条目是按上述顺序对应于每个 $\\Lambda$ 的最小合格 $n$（例如，$[n_{\\Lambda=0.5},n_{\\Lambda=2.0},n_{\\Lambda=20.0},n_{\\Lambda=50.0}]$）。每个 $n$ 必须是整数。",
            "solution": "#### 为 Gauss-Hermite 求积进行的变换\n\n目标是将给定的积分 $I(\\delta, \\Lambda)$ 变换为 Gauss–Hermite 求积所需的标准形式，即 $\\int_{-\\infty}^{\\infty} e^{-u^2} g(u)\\,du$。\n\n初始积分为：\n$$\nI(\\delta,\\Lambda) = \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{(x - \\delta)^2}{4 \\Lambda}\\right)\\,\\frac{1}{1 + e^{x}}\\,dx\n$$\n我们引入变量替换，以匹配高斯权重函数 $e^{-u^2}$。令：\n$$\nu^2 = \\frac{(x - \\delta)^2}{4 \\Lambda}\n$$\n取平方根并解出 $u$ 可得：\n$$\nu = \\frac{x - \\delta}{2\\sqrt{\\Lambda}}\n$$\n由此，我们将 $x$ 表示为 $u$ 的函数：\n$$\nx(u) = 2\\sqrt{\\Lambda} u + \\delta\n$$\n通过对 $x(u)$ 关于 $u$ 求导，得到微分 $dx$：\n$$\ndx = 2\\sqrt{\\Lambda}\\,du\n$$\n$x$ 的积分限为 $(-\\infty, \\infty)$。由于从 $x$ 到 $u$ 的变换是线性的，所以 $u$ 的积分限仍然是 $(-\\infty, \\infty)$。\n\n将这些表达式代入 $I(\\delta, \\Lambda)$ 的积分中：\n$$\nI(\\delta, \\Lambda) = \\int_{-\\infty}^{\\infty} \\exp(-u^2) \\left( \\frac{1}{1 + \\exp(2\\sqrt{\\Lambda} u + \\delta)} \\right) (2\\sqrt{\\Lambda}\\,du)\n$$\n通过重新排列各项，我们得到所需的形式：\n$$\nI(\\delta, \\Lambda) = \\int_{-\\infty}^{\\infty} e^{-u^2} g(u; \\delta, \\Lambda)\\,du\n$$\n其中函数 $g(u; \\delta, \\Lambda)$ 被确定为：\n$$\ng(u; \\delta, \\Lambda) = 2\\sqrt{\\Lambda} \\frac{1}{1 + \\exp(2\\sqrt{\\Lambda} u + \\delta)}\n$$\n\n#### Gauss-Hermite 求积近似\n\nn 点 Gauss-Hermite 求积法则将变换后的积分近似为一个加权和：\n$$\n\\int_{-\\infty}^{\\infty} e^{-u^2} g(u)\\,du \\approx \\sum_{i=1}^{n} w_i g(u_i)\n$$\n这里，$\\{u_i\\}_{i=1}^n$ 是 n 次物理学家 Hermite 多项式 $H_n(u)$ 的根（节点），$\\{w_i\\}_{i=1}^n$ 是对应于权重函数 $e^{-u^2}$ 的权重。\n\n将此应用于我们的具体问题，积分的近似值为：\n$$\nI_{GH}(\\delta, \\Lambda; n) = \\sum_{i=1}^{n} w_i \\left( 2\\sqrt{\\Lambda} \\frac{1}{1 + \\exp(2\\sqrt{\\Lambda} u_i + \\delta)} \\right)\n$$\n节点 $u_i$ 和权重 $w_i$ 可以从标准数值库中获得，例如 `numpy.polynomial.hermite.hermgauss`。\n\n#### 数值与算法策略\n\n1.  **参考值计算**：对于每对 $(\\delta, \\Lambda)$，使用一个鲁棒的自适应求积方法（如 `scipy.integrate.quad`）应用于变换后的积分 $\\int_{-\\infty}^{\\infty} e^{-u^2} g(u; \\delta, \\Lambda)\\,du$，从而计算出一个高精度参考值 $I_{ref}(\\delta, \\Lambda)$。\n\n2.  **数值稳定性**：费米-狄拉克项中指数的参数 $y = 2\\sqrt{\\Lambda} u + \\delta$ 可能变得很大且为正，导致计算 $e^y$ 时出现浮点溢出。为确保数值稳定性，函数 $f(y) = 1/(1+e^y)$ 使用像 `scipy.special.expit(-y)` 这样的专门函数来实现，它在数值上是等效的但能避免溢出。\n\n3.  **误差分析**：对于每组参数 $(\\Lambda, \\delta, n)$，相对误差计算如下：\n    $$\n    E_{rel}(\\delta, \\Lambda; n) = \\left| \\frac{I_{GH}(\\delta, \\Lambda; n) - I_{ref}(\\delta, \\Lambda)}{I_{ref}(\\delta, \\Lambda)} \\right|\n    $$\n    被积函数是严格为正的，所以 $I_{ref}$ 总是非零，从而避免了除以零。对于每对 $(\\Lambda, n)$，在 $\\delta$ 值的网格上确定最大相对误差：\n    $$\n    E_{max}(\\Lambda; n) = \\max_{\\delta \\in \\text{grid}} \\{ E_{rel}(\\delta, \\Lambda; n) \\}\n    $$\n\n4.  **寻找最小所需节点数 ($n$)**：总体算法流程如下：\n    - 对于指定集合中的每个 $\\Lambda$ 值：\n        - 将此 $\\Lambda$ 的结果初始化为最大节点数 $n_{max} = 64$。\n        - 按升序遍历节点数 $n \\in \\{4, 8, 16, 32, 64\\}$。\n        - 对于每个 $n$，计算 $E_{max}(\\Lambda; n)$。\n        - 如果 $E_{max}(\\Lambda; n)  \\varepsilon=10^{-8}$，那么这个 $n$ 就是满足容差的最小节点数。将此 $n$ 存储为当前 $\\Lambda$ 的结果，并中断内层循环（对 $n$ 的循环），继续处理下一个 $\\Lambda$。\n        - 如果循环完成仍未找到满足条件的 $n$，则结果保持为默认值 $64$。\n    - 将所有 $\\Lambda$ 值的结果收集到一个列表中。\n    - 以指定格式打印最终列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\nfrom scipy.special import expit\n\ndef solve():\n    \"\"\"\n    Computes the smallest number of Gauss-Hermite nodes to achieve a specified\n    tolerance for the Marcus-Hush-Chidsey integral.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = {\n        'Lambda_vals': [0.5, 2.0, 20.0, 50.0],\n        'delta_vals': [-10.0, -2.0, 0.0, 2.0, 10.0],\n        'n_vals': [4, 8, 16, 32, 64],\n        'epsilon': 1e-8\n    }\n\n    Lambda_vals = test_cases['Lambda_vals']\n    delta_vals = test_cases['delta_vals']\n    n_vals = test_cases['n_vals']\n    epsilon = test_cases['epsilon']\n    \n    results = []\n\n    # The function g(u) from the derivation: g(u) = 2*sqrt(L) / (1 + exp(2*sqrt(L)*u + d))\n    # We use scipy.special.expit(-x) for the numerically stable calculation of 1/(1+exp(x)).\n    def g_func(u, delta, Lambda):\n        sqrt_Lambda = np.sqrt(Lambda)\n        arg = 2 * sqrt_Lambda * u + delta\n        return 2 * sqrt_Lambda * expit(-arg)\n\n    # The full integrand for the reference calculation: integrand(u) = exp(-u^2) * g(u)\n    def integrand_ref(u, delta, Lambda):\n        return np.exp(-u**2) * g_func(u, delta, Lambda)\n\n    # Loop over each reorganization energy Lambda\n    for Lambda in Lambda_vals:\n        # Default to the largest n as per instructions, if tolerance is not met\n        smallest_n = n_vals[-1]\n\n        # Loop over the number of nodes n to find the smallest that meets the tolerance\n        for n in n_vals:\n            # Get Gauss-Hermite nodes (u_i) and weights (w_i) for the weight function exp(-x^2)\n            nodes, weights = np.polynomial.hermite.hermgauss(n)\n            \n            max_relative_error = 0.0\n\n            # Loop over the driving parameter delta to find the max relative error for this (Lambda, n) pair\n            for delta in delta_vals:\n                # 1. Calculate the high-accuracy reference integral using a standard library routine.\n                # The integral is of the form int(exp(-u^2)*g(u) du) from -inf to inf.\n                try:\n                    I_ref, _ = integrate.quad(integrand_ref, -np.inf, np.inf, args=(delta, Lambda))\n                except Exception as e:\n                    # In case of integration failure, treat error as infinite to discard the 'n' value.\n                    max_relative_error = np.inf\n                    break\n                \n                # The integrand is strictly positive, so I_ref should be > 0.\n                # A zero or negative value indicates a numerical issue.\n                if I_ref = 0.0:\n                    relative_error = np.inf\n                else:\n                    # 2. Calculate the Gauss-Hermite approximation: I_gh = sum(w_i * g(u_i))\n                    g_values_at_nodes = g_func(nodes, delta, Lambda)\n                    I_gh = np.sum(weights * g_values_at_nodes)\n\n                    # 3. Calculate the relative error\n                    relative_error = np.abs((I_gh - I_ref) / I_ref)\n                \n                # Update the maximum relative error found for the current n\n                if relative_error > max_relative_error:\n                    max_relative_error = relative_error\n\n            # 4. Check if the tolerance is met for this n. If so, it's the smallest qualifying n\n            # because we are iterating n in increasing order.\n            if max_relative_error  epsilon:\n                smallest_n = n\n                break  # Exit the loop over n, as we have found our answer for this Lambda\n\n        results.append(smallest_n)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "理论模型的一个核心价值在于其能够解释和分析实验数据。例如，在自组装单分子层等实验中，我们可以测量电子转移速率如何随分子与电极间的距离而变化。本练习要求您首先从 MHC 模型出发，推导出速率常数 $k$ 对距离 $d$ 的依赖关系，然后利用该关系对一系列假设的实验数据集进行线性回归分析。这项实践将理论与实验联系起来，让您掌握如何从测量数据中提取如电子耦合衰减常数 $\\beta$ 这类的基本物理参数，这对于验证模型和定量理解分子体系至关重要。",
            "id": "4260340",
            "problem": "给定一组在不同溶剂和电极材料组合下测得的依赖于距离的非均相电子转移速率数据。从一个有效的基础理论出发，推导电极动力学的 Marcus-Hush-Chidsey (MHC) 模型中速率对距离依赖关系的主导项，并用它来推断表征倏逝电子耦合的指数衰减常数。然后，您将把推导出的关系实现为一个程序，用以从给定的数据集中拟合衰减常数，并输出拟合值。\n\n基础理论（用作推导的起点）：\n- Fermi 黄金定则：非绝热电子转移速率与电子耦合的平方和核因子成正比，即 $k \\propto \\lvert V \\rvert^{2} \\times \\mathrm{FCWD}$，其中 $\\mathrm{FCWD}$ 表示 Franck-Condon 加权密度。\n- Marcus 电子转移模型：在温度 $ T $ 下，核因子可以很好地由一个关于能量差的高斯函数描述，其重组能为 $ \\lambda $，而非均相情况则根据 Fermi-Dirac 分布对占据的电极电子态进行积分，从而得到电极动力学的 Marcus-Hush-Chidsey (MHC) 速率。\n- 电子耦合穿过有限厚度势垒的倏逝隧穿行为意味着耦合强度对距离呈指数依赖关系，因此耦合项依赖于分离距离。\n\n任务：\n1. 根据上述基础理论，在重组能 $ \\lambda $、驱动力（电极过电势）$ \\Delta G $ 和热环境固定的情况下，推导非均相电子转移速率 $k(d)$ 对分离距离 $d$ 的主导依赖关系。您的推导必须确定一个衰减参数 $ \\beta $，该参数概括了距离依赖性。\n2. 实现一个程序，在给定一组测量的距离和速率的情况下，通过您在步骤1中推导出的适当回归方法来拟合衰减参数 $ \\beta $。对任何对数变换均使用自然对数。假设在对数域中存在加性高斯噪声（等效于速率中的乘性对数正态噪声）。\n3. 物理单位：距离 $ d $ 的单位为 $ \\mathrm{nm} $，速率 $ k $ 的单位为 $ \\mathrm{s}^{-1} $。报告拟合出的 $ \\beta $，单位为 $ \\mathrm{nm}^{-1} $。\n4. 输出格式：您的程序应生成单行输出，其中包含所有拟合的 $ \\beta $ 值，四舍五入到三位小数，以逗号分隔的 Python 列表形式包含在方括号中，例如 $[0.123,4.567,8.910]$。\n\n测试套件（每个案例提供以 $ \\mathrm{nm} $ 为单位的距离 $ d $ 和以 $ \\mathrm{s}^{-1} $ 为单位的测量速率 $ k $ ）：\n- 案例 $1$（金电极在水中）：$d = [0.5, 1.0, 1.5, 2.0, 2.5]$, $k = [67379.47, 453.9993, 3.059023, 0.0206115, 0.000138879]$。\n- 案例 $2$（金电极在乙腈中）：$d = [0.5, 1.0, 1.5, 2.0, 2.5]$, $k = [91575.0, 1677.313, 30.72106, 0.5626759, 0.010305768]$。\n- 案例 $3$（石墨电极在水中）：$d = [0.5, 1.0, 1.5, 2.0, 2.5]$, $k = [49575.0, 122.88424, 0.3045994, 0.0007550268, 0.00000187152]$。\n- 案例 $4$（石墨电极在离子液体中）：$d = [0.5, 1.0, 1.5, 2.0, 2.5]$, $k = [149361.0, 7436.25, 370.229, 18.43264, 0.9177069]$。\n- 案例 $5$（慢衰减边缘情况）：$d = [0.5, 1.0, 1.5, 2.0, 2.5]$, $k = [7788.008, 6065.307, 4723.666, 3678.794, 2865.048]$。\n- 案例 $6$（零距离边界）：$d = [0.0, 0.1, 0.2, 0.3, 0.4]$, $k = [100000.0, 36787.944, 13533.528, 4978.707, 1831.564]$。\n\n答案规格：\n- 对于测试套件中的每个案例，计算拟合的衰减参数 $ \\beta $（单位为 $ \\mathrm{nm}^{-1} $），并四舍五入到三位小数。\n- 您的程序应生成单行输出，其中包含以逗号分隔的列表形式的结果，并用方括号括起来，例如 $[10.000,8.000,12.000,6.000,0.500,10.000]$。",
            "solution": "#### 距离依赖关系的推导\n\n分析始于非绝热电子转移过程速率常数 $k$ 的 Fermi 黄金定则。该定则指出，速率与电子耦合矩阵元 $\\lvert V \\rvert$ 的平方以及 Franck-Condon 加权态密度 (FCWD) 成正比：\n$$k \\propto \\lvert V \\rvert^2 \\times \\mathrm{FCWD}$$\n\n对于电极上的非均相电子转移，总速率常数 $k$ 是对电极导带内所有电子能级 $\\epsilon$ 的积分。综合性的 Marcus-Hush-Chidsey (MHC) 模型为该速率提供了以下表达式：\n$$k = C_{pre} \\int_{-\\infty}^{\\infty} \\rho(\\epsilon) \\lvert V(\\epsilon) \\rvert^2 f(\\epsilon, E_F, T) \\exp\\left(-\\frac{(\\lambda + \\Delta G - \\epsilon)^2}{4\\lambda k_B T}\\right) d\\epsilon$$\n在此方程中，$C_{pre}$ 是一组基本常数，$\\rho(\\epsilon)$ 是能量为 $\\epsilon$ 时的电极态密度，$\\lvert V(\\epsilon) \\rvert$ 是该能量下的电子耦合，$f(\\epsilon, E_F, T)$ 是温度为 $T$、Fermi 能级为 $E_F$ 时的 Fermi-Dirac 分布函数，$\\lambda$ 是重组能，$\\Delta G$ 是在标准电势下（与施加的过电势相关）反应的自由能变化，$k_B$ 是 Boltzmann 常数。\n\n问题指明，实验条件设定为重组能 ($\\lambda$)、驱动力 ($\\Delta G$) 和温度 ($T$) 保持不变。一个常用且有效的近似方法（尤其适用于主导项分析）是，在被积函数有显著值的能量范围内，将态密度 $\\rho(\\epsilon)$ 和电子耦合 $\\lvert V(\\epsilon) \\rvert$ 视为弱依赖于能量 $\\epsilon$。基于此假设，这些项可以被视为与能量无关的常数，并移到积分号外：\n$$k \\approx C_{pre} \\rho \\lvert V \\rvert^2 \\int_{-\\infty}^{\\infty} f(\\epsilon, E_F, T) \\exp\\left(-\\frac{(\\lambda + \\Delta G - \\epsilon)^2}{4\\lambda k_B T}\\right) d\\epsilon$$\n由于在给定实验中 $\\lambda$、$\\Delta G$ 和 $T$ 是常数，整个积分的计算结果是一个与分离距离 $d$ 无关的数值。我们将这个代表了对电极态积分的总核贡献的常数因子记为 $I_{\\mathrm{MHC}}$。\n$$I_{\\mathrm{MHC}} = \\int_{-\\infty}^{\\infty} f(\\epsilon, E_F, T) \\exp\\left(-\\frac{(\\lambda + \\Delta G - \\epsilon)^2}{4\\lambda k_B T}\\right) d\\epsilon$$\n因此，速率常数 $k$ 与依赖于距离的电子耦合的平方成正比：\n$$k(d) \\propto \\lvert V(d) \\rvert^2$$\n\n电子耦合 $\\lvert V(d) \\rvert$ 量化了氧化还原分子的轨道与电极电子态之间通过分离介质（势垒）的相互作用。量子力学隧穿效应主导了这种相互作用。电子隧穿通过厚度为 $d$ 的势垒的概率随厚度呈指数衰减。因此，电子耦合矩阵元表现出对距离的指数依赖性：\n$$\\lvert V(d) \\rvert = V_0 e^{-\\beta_{el} d}$$\n这里，$V_0$ 是参考距离（例如 $d=0$）处的耦合强度，$\\beta_{el}$ 是电子衰减常数，其值由势垒介质的性质决定。\n\n将此耦合表达式代入速率正比关系中，我们得到速率常数 $k(d)$ 对距离 $d$ 的主导依赖关系：\n$$k(d) \\propto \\left( V_0 e^{-\\beta_{el} d} \\right)^2 = V_0^2 e^{-2\\beta_{el} d}$$\n该关系通常写成简单的指数衰减形式：\n$$k(d) = k_0 e^{-\\beta d}$$\n在这个最终表达式中，$k_0$ 是外推到零距离（$d=0$）时的速率常数，它整合了 $V_0^2$ 和所有其他与距离无关的因子（例如 $C_{pre}$、$\\rho$、$I_{\\mathrm{MHC}}$）。参数 $\\beta$ 是速率的总衰减常数。通过比较形式，我们建立了可观测的速率衰减常数 $\\beta$ 与潜在的电子耦合衰减常数 $\\beta_{el}$ 之间的关键关系：\n$$\\beta = 2\\beta_{el}$$\n推导出的关系式 $k(d) = k_0 e^{-\\beta d}$ 构成了数据拟合程序的基础。\n\n#### 拟合步骤\n\n模型 $k(d) = k_0 e^{-\\beta d}$ 是一个指数函数。为了实现一个简单而稳健的拟合过程，我们通过对等式两边取自然对数来将其线性化：\n$$\\ln(k) = \\ln(k_0 e^{-\\beta d}) = \\ln(k_0) + \\ln(e^{-\\beta d})$$\n$$\\ln(k) = \\ln(k_0) - \\beta d$$\n这个方程是标准线性形式 $y = c + mx$，其中：\n- 因变量为 $y = \\ln(k)$。\n- 自变量为 $x = d$。\n- 斜率为 $m = -\\beta$。\n- y 轴截距为 $c = \\ln(k_0)$。\n\n问题陈述中假设在对数域中存在加性高斯噪声，这等效于原始速率中的乘性对数正态噪声。这一假设使得对对数转换后的数据 $(d_i, \\ln(k_i))$ 进行普通线性最小二乘回归成为统计上正确的参数估计方法。最佳拟合线的斜率 $m$ 将通过直接关系式 $\\beta = -m$ 给出衰减参数 $\\beta$。\n\n计算算法将对每个数据集执行以下步骤：\n1.  将速率数据 $k_i$ 转换为其自然对数 $\\ln(k_i)$。\n2.  对 $\\ln(k)$ 与 $d$ 进行线性回归，以确定斜率 $m$。\n3.  计算衰减参数为 $\\beta = -m$。\n\n物理单位是一致的。当 $d$ 的单位为 $\\mathrm{nm}$ 且 $\\ln(k)$ 为无量纲时，斜率 $m$ 的单位为 $\\mathrm{nm}^{-1}$。因此，计算出的衰减参数 $\\beta$ 也将具有所要求的单位 $\\mathrm{nm}^{-1}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives the exponential decay constant beta from distance-dependent electron\n    transfer rate data based on the Marcus-Hush-Chidsey model.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a dictionary containing distance (d) and rate (k) data.\n    test_cases = [\n        {\n            \"d\": [0.5, 1.0, 1.5, 2.0, 2.5],\n            \"k\": [67379.47, 453.9993, 3.059023, 0.0206115, 0.000138879]\n        },\n        {\n            \"d\": [0.5, 1.0, 1.5, 2.0, 2.5],\n            \"k\": [91575.0, 1677.313, 30.72106, 0.5626759, 0.010305768]\n        },\n        {\n            \"d\": [0.5, 1.0, 1.5, 2.0, 2.5],\n            \"k\": [49575.0, 122.88424, 0.3045994, 0.0007550268, 0.00000187152]\n        },\n        {\n            \"d\": [0.5, 1.0, 1.5, 2.0, 2.5],\n            \"k\": [149361.0, 7436.25, 370.229, 18.43264, 0.9177069]\n        },\n        {\n            \"d\": [0.5, 1.0, 1.5, 2.0, 2.5],\n            \"k\": [7788.008, 6065.307, 4723.666, 3678.794, 2865.048]\n        },\n        {\n            \"d\": [0.0, 0.1, 0.2, 0.3, 0.4],\n            \"k\": [100000.0, 36787.944, 13533.528, 4978.707, 1831.564]\n        }\n    ]\n\n    results = []\n    # Iterate through each test case to calculate the decay constant.\n    for case in test_cases:\n        # Convert lists to NumPy arrays for vectorized operations.\n        d = np.array(case[\"d\"])\n        k = np.array(case[\"k\"])\n\n        # The relationship k = k0 * exp(-beta * d) can be linearized by taking the natural log:\n        # ln(k) = ln(k0) - beta * d\n        # This is a linear equation of the form y = c + m*x, where y=ln(k), x=d, and m=-beta.\n        log_k = np.log(k)\n\n        # Perform a linear regression (polynomial fit of degree 1) on the transformed data.\n        # np.polyfit returns the coefficients [slope, intercept] for the best-fit line.\n        slope, _ = np.polyfit(d, log_k, 1)\n\n        # The decay parameter beta is the negative of the slope from the linear fit.\n        beta = -slope\n\n        # Append the calculated beta to the results list.\n        results.append(beta)\n\n    # Format the results to three decimal places as required.\n    formatted_results = [f\"{res:.3f}\" for res in results]\n\n    # Final print statement in the exact required format: a comma-separated list in brackets.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}