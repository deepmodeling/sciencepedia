{
    "hands_on_practices": [
        {
            "introduction": "在基于密度泛函理论（DFT）的周期性平板模型计算中，获得可靠的计算结果是后续所有分析的基石。本练习将指导你如何通过系统性测试，确定确保计算收敛所需的最小平板厚度和真空层尺寸，这是消除周期性边界条件带来的伪影并获得物理上有意义的吸附能的关键一步。通过解决这个问题 ()，你将掌握评估和确保计算精度的基本技能。",
            "id": "4252164",
            "problem": "您正在使用周期性平板、平面波密度泛函理论 (DFT) 方法，模拟过渡金属氧化物表面上析氧反应 (OER) 的吸附能学。在此类模拟中，吸附能相对于平板厚度和真空层间距的收敛对于获得具有物理意义的结果至关重要。您将实现一个程序，用于确定测试套件中每个参数集下，将吸附能收敛到指定容差内所需的最小平板厚度（以原子层为单位）和最小真空层间距（以埃为单位），并决定是否应对非对称平板应用偶极校正。\n\n使用以下有科学依据的基础模型：\n\n- 在周期性平板设置中，吸附能 $E_\\mathrm{ads}$ 可以分解为因固体中的电子屏蔽效应而随平板厚度收敛的项，以及因周期性镜像间的赝相互作用而随真空层间距收敛的项。分解式为：\n$$\nE_\\mathrm{ads}(L,V,p) = E_\\infty + \\Delta E_\\mathrm{thick}(L) + \\Delta E_\\mathrm{vac}(V,p),\n$$\n其中 $L$ 是以整数原子层为单位的平板厚度，$V$ 是以埃为单位的真空层间距，$p$ 是沿表面法线方向（$z$ 轴）的净偶极矩，用于表征平板的非对称性，$E_\\infty$ 是在无限厚平板、无限大真空极限下的吸附能。\n\n- 平板中的电子屏蔽效应导致与厚度相关的校正项呈指数衰减，\n$$\n\\Delta E_\\mathrm{thick}(L) = \\alpha \\exp\\!\\left(-\\frac{L}{\\lambda}\\right),\n$$\n其中 $\\alpha$ 为振幅（单位为电子伏特），$\\lambda$ 为特征屏蔽长度（单位为原子层）。\n\n- 真空方向上重复平板之间的赝静电相互作用导致能量与真空层间距成反比关系。一个简单且广泛使用的、与真空相关的校正项的有效模型表示为：\n$$\n\\Delta E_\\mathrm{vac}(V,p) = \\frac{\\beta + \\gamma p^2}{V},\n$$\n其中 $\\beta$（单位为电子伏特·埃）量化了非偶极镜像相互作用，$\\gamma$（单位为电子伏特·埃/平方偶极单位）量化了偶极镜像相互作用。$p$ 不为零表示平板是非对称的。偶极校正可以消除周期性镜像之间的赝偶极相互作用，在该模型中，这对应于在应用校正时将有效的 $p^2$ 贡献设置为零。\n\n收敛定义如下：\n\n- 当平板厚度增加一个原子层时，吸附能的增量变化绝对值小于指定的容差 $\\delta_\\mathrm{thick}$（单位为电子伏特），即达到平板厚度收敛，\n$$\n\\left| \\Delta E_\\mathrm{thick}(L) - \\Delta E_\\mathrm{thick}(L+1) \\right| \\le \\delta_\\mathrm{thick}.\n$$\n\n- 当真空层间距增加一个固定步长 $\\Delta V$ 时，吸附能的增量变化绝对值小于指定的容差 $\\delta_\\mathrm{vac}$（单位为电子伏特），即达到真空层间距收敛，\n$$\n\\left| \\Delta E_\\mathrm{vac}(V,p_\\mathrm{eff}) - \\Delta E_\\mathrm{vac}(V+\\Delta V,p_\\mathrm{eff}) \\right| \\le \\delta_\\mathrm{vac},\n$$\n其中，如果不施加偶极校正，$p_\\mathrm{eff} = p$；如果施加偶极校正，$p_\\mathrm{eff} = 0$。\n\n使用一个简单的、基于物理动机的准则来决定是否应用偶极校正：如果 $p \\ge p_\\mathrm{thresh}$，则应用校正，其中 $p_\\mathrm{thresh}$ 是一个指定的阈值。\n\n算法要求：\n\n- 对于厚度收敛，从 $L=1$ 开始以整数步长向上搜索 $L$，直到满足厚度收敛准则或达到指定的最大值 $L_\\mathrm{max}$。如果在界限内未满足收敛准则，则返回 $L_\\mathrm{max}$。\n\n- 对于真空收敛，从指定的起始值 $V_\\mathrm{start}$ 开始以 $\\Delta V$ 为步长向上搜索 $V$，直到满足真空收敛准则或达到指定的最大值 $V_\\mathrm{max}$。如果在界限内未满足收敛准则，则返回 $V_\\mathrm{max}$。在评估真空收敛准则时，根据是否认为需要偶极校正来使用上面定义的 $p_\\mathrm{eff}$。\n\n- 报告每个测试用例的结果，该结果为一个列表，包含最小平板厚度 $L_\\mathrm{min}$（整数，单位为原子层）、最小真空层间距 $V_\\mathrm{min}$（浮点数，单位为埃）以及一个指示是否应用偶极校正的布尔值。\n\n物理单位和输出要求：\n\n- 能量必须以电子伏特（$\\mathrm{eV}$）处理。真空层间距必须以埃（$\\mathrm{\\AA}$）处理。平板厚度以整数原子层为单位。\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3]$）。每个 $\\text{result}_i$ 必须是一个包含 $L_\\mathrm{min}$（整数）、$V_\\mathrm{min}$（浮点数）和偶极校正布尔值的列表。\n\n测试套件：\n\n使用以下参数集，以元组形式按顺序 $(\\alpha,\\lambda,\\beta,\\gamma,p,\\delta_\\mathrm{thick},\\delta_\\mathrm{vac},L_\\mathrm{max},V_\\mathrm{start},\\Delta V,V_\\mathrm{max},p_\\mathrm{thresh})$ 提供：\n\n- 情况 $1$（一般非对称平板）：\n  $(0.15, 2.0, 0.12, 0.08, 0.80, 0.01, 0.005, 12, 10.0, 2.0, 30.0, 0.20)$。\n\n- 情况 $2$（对称平板，无偶极矩）：\n  $(0.20, 1.5, 0.10, 0.05, 0.00, 0.02, 0.01, 10, 8.0, 4.0, 24.0, 0.10)$。\n\n- 情况 $3$（严格容差，强偶极矩）：\n  $(0.10, 3.0, 0.08, 0.12, 1.50, 0.001, 0.0005, 15, 12.0, 3.0, 45.0, 0.30)$。\n\n- 情况 $4$（小 $\\lambda$，大 $\\alpha$，大偶极矩）：\n  $(0.30, 1.0, 0.15, 0.20, 2.00, 0.03, 0.02, 8, 10.0, 5.0, 35.0, 0.50)$。\n\n您的程序必须在内部运行这些测试用例（无外部输入），使用上述规则计算所需的输出，并按规定在单行上打印最终的聚合列表。",
            "solution": "本问题要求实现一个算法，用于在周期性平板密度泛函理论 (DFT) 框架下，为收敛的吸附能计算确定最小平板厚度和最小真空层间距。同时，还必须根据给定准则决定是否应用偶极校正。\n\n总吸附能 $E_\\mathrm{ads}$ 作为平板厚度 $L$（以原子层为单位）、真空层间距 $V$（以埃为单位）以及平板净偶极矩 $p$（以任意偶极单位计）的函数，由以下模型给出：\n$$\nE_\\mathrm{ads}(L,V,p) = E_\\infty + \\Delta E_\\mathrm{thick}(L) + \\Delta E_\\mathrm{vac}(V,p)\n$$\n其中 $E_\\infty$ 是收敛的吸附能，$\\Delta E_\\mathrm{thick}(L)$ 和 $\\Delta E_\\mathrm{vac}(V,p)$ 是分别在 $L \\to \\infty$ 和 $V \\to \\infty$ 时消失的校正项。\n\n与厚度相关的校正项由指数衰减模型描述，反映了平板内部的电子屏蔽效应：\n$$\n\\Delta E_\\mathrm{thick}(L) = \\alpha \\exp\\!\\left(-\\frac{L}{\\lambda}\\right)\n$$\n这里，$\\alpha$ 是能量振幅（单位为 $\\mathrm{eV}$），$\\lambda$ 是特征屏蔽长度（单位为原子层）。\n\n与真空相关的校正项模拟了平板周期性镜像之间的赝静电相互作用，由下式给出：\n$$\n\\Delta E_\\mathrm{vac}(V,p) = \\frac{\\beta + \\gamma p^2}{V}\n$$\n参数 $\\beta$（单位为 $\\mathrm{eV\\cdot\\AA}$）表示非偶极相互作用，而 $\\gamma$（单位为 $\\mathrm{eV\\cdot\\AA}$/平方偶极单位）量化了周期性镜像的净偶极矩之间的相互作用。\n\n收敛是基于这些能量校正项的增量变化来定义的。\n当将厚度增加一个原子层所引起的能量变化绝对值低于容差 $\\delta_\\mathrm{thick}$ 时，平板厚度 $L$ 达到收敛：\n$$\n\\left| \\Delta E_\\mathrm{thick}(L) - \\Delta E_\\mathrm{thick}(L+1) \\right| \\le \\delta_\\mathrm{thick}\n$$\n代入 $\\Delta E_\\mathrm{thick}(L)$ 的表达式，条件变为：\n$$\n\\left| \\alpha e^{-L/\\lambda} - \\alpha e^{-(L+1)/\\lambda} \\right| = \\alpha e^{-L/\\lambda} \\left(1 - e^{-1/\\lambda}\\right) \\le \\delta_\\mathrm{thick}\n$$\n假设 $\\alpha > 0$ 且 $\\lambda > 0$。最小所需厚度 $L_\\mathrm{min}$，是通过从 $L=1$ 开始递增直到满足此不等式来找到的。如果对于任何 $L  L_\\mathrm{max}$ 都不满足该条件，则最小厚度取为 $L_\\mathrm{max}$。\n\n当将真空增加 $\\Delta V$ 所引起的能量变化低于容差 $\\delta_\\mathrm{vac}$ 时，真空层间距 $V$ 达到收敛：\n$$\n\\left| \\Delta E_\\mathrm{vac}(V,p_\\mathrm{eff}) - \\Delta E_\\mathrm{vac}(V+\\Delta V,p_\\mathrm{eff}) \\right| \\le \\delta_\\mathrm{vac}\n$$\n有效偶极矩 $p_\\mathrm{eff}$ 取决于是否应用偶极校正。偶极校正是一种计算技术，可以消除周期性镜像之间的赝长程偶极-偶极相互作用。在此模型中，应用校正等效于将偶极贡献设置为零，即 $p_\\mathrm{eff} = 0$。是否应用校正的决定基于一个启发式规则，即显著的偶极矩需要校正：如果 $p \\ge p_\\mathrm{thresh}$，则应用校正。如果不应用校正，则 $p_\\mathrm{eff} = p$。\n\n代入 $\\Delta E_\\mathrm{vac}(V, p_\\mathrm{eff})$ 的表达式，收敛条件为：\n$$\n\\left| \\frac{\\beta + \\gamma p_\\mathrm{eff}^2}{V} - \\frac{\\beta + \\gamma p_\\mathrm{eff}^2}{V+\\Delta V} \\right| = (\\beta + \\gamma p_\\mathrm{eff}^2) \\left(\\frac{\\Delta V}{V(V+\\Delta V)}\\right) \\le \\delta_\\mathrm{vac}\n$$\n最小所需真空 $V_\\mathrm{min}$，是通过从 $V=V_\\mathrm{start}$ 开始以 $\\Delta V$ 为步长递增直到满足不等式来找到的。如果在起始真空小于 $V_\\mathrm{max}$ 的任何步骤中都不满足该条件，则最小真空取为 $V_\\mathrm{max}$。\n\n对每个参数集，算法按以下步骤进行：\n1.  将平板偶极矩 $p$ 与阈值 $p_\\mathrm{thresh}$进行比较。如果 $p \\ge p_\\mathrm{thresh}$，则应用偶极校正（这将为真空计算设置 $p_\\mathrm{eff} = 0$）。否则，不应用校正（$p_\\mathrm{eff} = p$）。一个布尔标志记录此决定。\n2.  从 1 到 $L_\\mathrm{max}-1$ 迭代 $L$。对于每个 $L$，计算与厚度相关的能量变化。如果它小于或等于 $\\delta_\\mathrm{thick}$，则设置 $L_\\mathrm{min} = L$ 并终止厚度搜索。如果循环完成而未收敛，则设置 $L_\\mathrm{min} = L_\\mathrm{max}$。\n3.  从 $V_\\mathrm{start}$ 开始以 $\\Delta V$ 的增量迭代 $V$，只要 $V  V_\\mathrm{max}$。对于每个 $V$，使用适当的 $p_\\mathrm{eff}$ 计算与真空相关的能量变化。如果变化小于或等于 $\\delta_\\mathrm{vac}$，则设置 $V_\\mathrm{min} = V$ 并终止真空搜索。如果循环完成而未收敛，则设置 $V_\\mathrm{min} = V_\\mathrm{max}$。\n4.  报告三元组 $[L_\\mathrm{min}, V_\\mathrm{min}, \\text{dipole\\_applied\\_boolean}]$。\n\n将此过程应用于所提供的测试用例，得出以下结果：\n\n- **情况 1**：$(\\alpha, \\lambda, \\beta, \\gamma, p, \\delta_\\mathrm{thick}, \\delta_\\mathrm{vac}, L_\\mathrm{max}, V_\\mathrm{start}, \\Delta V, V_\\mathrm{max}, p_\\mathrm{thresh}) = (0.15, 2.0, 0.12, 0.08, 0.80, 0.01, 0.005, 12, 10.0, 2.0, 30.0, 0.20)$。\n  - 偶极校正决策：$p=0.80 \\ge p_\\mathrm{thresh}=0.20$。应用校正。`True`。$p_\\mathrm{eff}=0$。\n  - 厚度收敛：$L_\\mathrm{min} = 4$。\n  - 真空收敛：$V_\\mathrm{min} = 10.0$。\n  - 结果：$[4, 10.0, \\text{True}]$\n\n- **情况 2**：$(0.20, 1.5, 0.10, 0.05, 0.00, 0.02, 0.01, 10, 8.0, 4.0, 24.0, 0.10)$。\n  - 偶极校正决策：$p=0.00  p_\\mathrm{thresh}=0.10$。不应用校正。`False`。$p_\\mathrm{eff}=0.0$。\n  - 厚度收敛：$L_\\mathrm{min} = 3$。\n  - 真空收敛：$V_\\mathrm{min} = 8.0$。\n  - 结果：$[3, 8.0, \\text{False}]$\n\n- **情况 3**：$(0.10, 3.0, 0.08, 0.12, 1.50, 0.001, 0.0005, 15, 12.0, 3.0, 45.0, 0.30)$。\n  - 偶极校正决策：$p=1.50 \\ge p_\\mathrm{thresh}=0.30$。应用校正。`True`。$p_\\mathrm{eff}=0$。\n  - 厚度收敛：$L_\\mathrm{min} = 11$。\n  - 真空收敛：$V_\\mathrm{min} = 21.0$。\n  - 结果：$[11, 21.0, \\text{True}]$\n\n- **情况 4**：$(0.30, 1.0, 0.15, 0.20, 2.00, 0.03, 0.02, 8, 10.0, 5.0, 35.0, 0.50)$。\n  - 偶极校正决策：$p=2.00 \\ge p_\\mathrm{thresh}=0.50$。应用校正。`True`。$p_\\mathrm{eff}=0$。\n  - 厚度收敛：$L_\\mathrm{min} = 2$。\n  - 真空收敛：$V_\\mathrm{min} = 10.0$。\n  - 结果：$[2, 10.0, \\text{True}]$\n\n最终的实现将这些过程转化为代码。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_min_L(alpha, lam, delta_thick, L_max):\n    \"\"\"\n    Determines the minimum slab thickness L_min for convergence.\n\n    Args:\n        alpha (float): Amplitude of the thickness correction term.\n        lam (float): Characteristic screening length.\n        delta_thick (float): Convergence tolerance for thickness.\n        L_max (int): Maximum number of layers to test.\n\n    Returns:\n        int: The minimum converged number of layers, L_min.\n    \"\"\"\n    # Search L from L=1 up to L_max-1. The convergence criterion is for the\n    # difference between layer L and layer L+1.\n    for L in range(1, L_max):\n        # Calculate the magnitude of the energy change:\n        # |ΔE_thick(L) - ΔE_thick(L+1)| = α * exp(-L/λ) * (1 - exp(-1/λ))\n        # Since alpha > 0 and (1 - exp(-1/λ)) > 0 for λ > 0, we can drop abs().\n        energy_change = alpha * np.exp(-L / lam) * (1.0 - np.exp(-1.0 / lam))\n        \n        if energy_change = delta_thick:\n            return L\n    \n    # If the loop completes without meeting the criterion, return L_max.\n    return L_max\n\ndef find_min_V(beta, gamma, p_eff, delta_vac, V_start, delta_V, V_max):\n    \"\"\"\n    Determines the minimum vacuum spacing V_min for convergence.\n\n    Args:\n        beta (float): Non-dipolar interaction coefficient.\n        gamma (float): Dipolar interaction coefficient.\n        p_eff (float): Effective dipole moment after correction decision.\n        delta_vac (float): Convergence tolerance for vacuum.\n        V_start (float): Starting vacuum spacing.\n        delta_V (float): Increment for vacuum spacing.\n        V_max (float): Maximum vacuum spacing to test.\n\n    Returns:\n        float: The minimum converged vacuum spacing, V_min.\n    \"\"\"\n    V = V_start\n    C_vac = beta + gamma * (p_eff**2)\n    \n    # If there are no spurious vacuum interactions, the starting value is sufficient.\n    if np.isclose(C_vac, 0.0):\n        return V_start\n\n    # Search V from V_start, as long as V is less than V_max.\n    while V  V_max:\n        V_next = V + delta_V\n        \n        # Calculate the magnitude of the energy change:\n        # |ΔE_vac(V) - ΔE_vac(V+ΔV)| = C_vac * ΔV / (V * (V+ΔV))\n        # Since C_vac >= 0 and ΔV > 0, we can drop abs().\n        energy_change = C_vac * delta_V / (V * V_next)\n\n        if energy_change = delta_vac:\n            return V\n\n        V = V_next\n    \n    # If the loop completes without meeting the criterion, return V_max.\n    return V_max\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Tuple format:\n    # (alpha, lambda, beta, gamma, p, delta_thick, delta_vac,\n    #  L_max, V_start, delta_V, V_max, p_thresh)\n    test_cases = [\n        (0.15, 2.0, 0.12, 0.08, 0.80, 0.01, 0.005, 12, 10.0, 2.0, 30.0, 0.20),\n        (0.20, 1.5, 0.10, 0.05, 0.00, 0.02, 0.01, 10, 8.0, 4.0, 24.0, 0.10),\n        (0.10, 3.0, 0.08, 0.12, 1.50, 0.001, 0.0005, 15, 12.0, 3.0, 45.0, 0.30),\n        (0.30, 1.0, 0.15, 0.20, 2.00, 0.03, 0.02, 8, 10.0, 5.0, 35.0, 0.50),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        alpha, lam, beta, gamma, p, delta_thick, delta_vac, \\\n        L_max, V_start, delta_V, V_max, p_thresh = case\n\n        # Step 1: Decide whether to apply the dipole correction.\n        dipole_applied = p >= p_thresh\n        p_eff = 0.0 if dipole_applied else p\n        \n        # Step 2: Find the minimum slab thickness L_min.\n        L_min = find_min_L(alpha, lam, delta_thick, L_max)\n        \n        # Step 3: Find the minimum vacuum spacing V_min.\n        V_min = find_min_V(beta, gamma, p_eff, delta_vac, V_start, delta_V, V_max)\n        \n        # Step 4: Collect the results for this case.\n        all_results.append([L_min, float(V_min), dipole_applied])\n\n    # Final print statement in the exact required format.\n    # Convert list of lists to string and remove spaces for compact output.\n    final_output_string = str(all_results).replace(\" \", \"\")\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "在获得可靠的中间体吸附能之后，下一步是评估催化剂的理论活性。计算氢电极（CHE）模型提供了一个强大的框架，可以将DFT计算得到的能量转化为电化学反应步骤的自由能，并由此确定限制整体反应速率的步骤和理论过电势。本练习 () 将让你实践CHE模型的核心应用，通过给定的中间体自由能，计算析氧反应（OER）的决速步和极限电势。",
            "id": "4252157",
            "problem": "在温度 $T=298\\,\\mathrm{K}$ 和 $\\mathrm{pH}=0$ 的条件下，使用计算氢电极 (CHE) 框架对用于析氧反应 (OER) 的金属氧化物电催化剂进行建模。使用可逆氢电极 (RHE) 作为参比。考虑一个在未占据的表面位点 $*$ 上的单中心机理，该机理包含四个质子-电子转移步骤，每步转移一个质子和一个电子：\n(1) $* + \\mathrm{H_{2}O(l)} \\rightarrow *\\mathrm{OH} + \\mathrm{H^{+}} + \\mathrm{e^{-}}$，\n(2) $*\\mathrm{OH} \\rightarrow *\\mathrm{O} + \\mathrm{H^{+}} + \\mathrm{e^{-}}$，\n(3) $*\\mathrm{O} + \\mathrm{H_{2}O(l)} \\rightarrow *\\mathrm{OOH} + \\mathrm{H^{+}} + \\mathrm{e^{-}}$，\n(4) $*\\mathrm{OOH} \\rightarrow * + \\mathrm{O_{2}(g)} + \\mathrm{H^{+}} + \\mathrm{e^{-}}$。\n在 CHE 框架内，当电势 $U=0\\,\\mathrm{V}$（相对于 RHE）时，在固定覆盖度 $\\theta=1/4$ 单层下，中间体的吸附自由能（包括零点能和熵校正）给出如下：\n$G_{*\\mathrm{OH}}^{\\mathrm{CHE}} = 1.02\\,\\mathrm{eV}$，\n$G_{*\\mathrm{O}}^{\\mathrm{CHE}} = 2.75\\,\\mathrm{eV}$，\n$G_{*\\mathrm{OOH}}^{\\mathrm{CHE}} = 3.85\\,\\mathrm{eV}$，\n根据标准 CHE 惯例，这些自由能是相对于 $*$、$\\mathrm{H_{2}O(l)}$ 和 $\\tfrac{1}{2}\\mathrm{H_{2}(g)}$ 定义的。假设在 $T=298\\,\\mathrm{K}$ 和 $\\mathrm{pH}=0$ 时，总的 $\\mathrm{O_{2}}/\\mathrm{H_{2}O}$ 电对的标准平衡电势为 $1.23\\,\\mathrm{V}$，因此 OER 的总标准自由能变为 $4\\times 1.23\\,\\mathrm{eV}$。仅使用基本的 CHE 关系和自由能守恒，确定极限电势 $U_{L}$（即使所有四个基元步骤的自由能都下降的最小电势），并指出在 $U=0\\,\\mathrm{V}$ 时哪个基元步骤是速率限制步骤。只报告 $U_{L}$ 的值，以 V 为单位（相对于 RHE）表示。将您的最终数值答案四舍五入到三位有效数字。",
            "solution": "我们使用计算氢电极 (CHE) 框架对析氧反应 (OER) 进行建模。该反应通过一个在表面位点 $*$ 上进行的四步机理：\n1.  $* + \\mathrm{H_{2}O(l)} \\rightarrow *\\mathrm{OH} + \\mathrm{H^{+}} + \\mathrm{e^{-}}$\n2.  $*\\mathrm{OH} \\rightarrow *\\mathrm{O} + \\mathrm{H^{+}} + \\mathrm{e^{-}}$\n3.  $*\\mathrm{O} + \\mathrm{H_{2}O(l)} \\rightarrow *\\mathrm{OOH} + \\mathrm{H^{+}} + \\mathrm{e^{-}}$\n4.  $*\\mathrm{OOH} \\rightarrow * + \\mathrm{O_{2}(g)} + \\mathrm{H^{+}} + \\mathrm{e^{-}}$\n\n在电势 $U$（相对于 RHE）下，每个中间体的自由能与其 CHE 自由能 $G^{\\mathrm{CHE}}$（在 $U=0\\,\\mathrm{V}$ 时）的关系如下：\n$\\Delta G(U) = G^{\\mathrm{CHE}} - neU$，其中 $n$ 是转移的质子-电子对的数量。\n\n在电势 $U$ 下，四个基元步骤的自由能变化为：\n1.  $\\Delta G_{1}(U) = G_{*\\mathrm{OH}} - G_{*} - G_{\\mathrm{H_{2}O}} = (G_{*\\mathrm{OH}}^{\\mathrm{CHE}} - 1eU) - 0 = 1.02 - eU$\n2.  $\\Delta G_{2}(U) = G_{*\\mathrm{O}} - G_{*\\mathrm{OH}} = (G_{*\\mathrm{O}}^{\\mathrm{CHE}} - 2eU) - (G_{*\\mathrm{OH}}^{\\mathrm{CHE}} - 1eU) = (G_{*\\mathrm{O}}^{\\mathrm{CHE}} - G_{*\\mathrm{OH}}^{\\mathrm{CHE}}) - eU = (2.75 - 1.02) - eU = 1.73 - eU$\n3.  $\\Delta G_{3}(U) = G_{*\\mathrm{OOH}} - G_{*\\mathrm{O}} = (G_{*\\mathrm{OOH}}^{\\mathrm{CHE}} - 3eU) - (G_{*\\mathrm{O}}^{\\mathrm{CHE}} - 2eU) = (G_{*\\mathrm{OOH}}^{\\mathrm{CHE}} - G_{*\\mathrm{O}}^{\\mathrm{CHE}}) - eU = (3.85 - 2.75) - eU = 1.10 - eU$\n4.  $\\Delta G_{4}(U) = G_{*} + G_{\\mathrm{O_{2}}} - G_{*\\mathrm{OOH}}$。$\\mathrm{O_2(g)}$ 的自由能与总反应自由能相关。总反应 $2\\mathrm{H_{2}O} \\rightarrow \\mathrm{O_{2}} + 4\\mathrm{H^{+}} + 4\\mathrm{e^{-}}$ 的标准自由能变为 $\\Delta G_{\\mathrm{OER}}^{\\circ} = 4 \\times 1.23\\,\\mathrm{eV} = 4.92\\,\\mathrm{eV}$。\n这个总自由能也是在 $U=0\\,\\mathrm{V}$ 时各基元步骤自由能变化之和：$\\Delta G_{\\mathrm{OER}}^{\\circ} = \\Delta G_{1}(0) + \\Delta G_{2}(0) + \\Delta G_{3}(0) + \\Delta G_{4}(0)$。\n$\\Delta G_{1}(0) = G_{*\\mathrm{OH}}^{\\mathrm{CHE}} = 1.02\\,\\mathrm{eV}$\n$\\Delta G_{2}(0) = G_{*\\mathrm{O}}^{\\mathrm{CHE}} - G_{*\\mathrm{OH}}^{\\mathrm{CHE}} = 2.75 - 1.02 = 1.73\\,\\mathrm{eV}$\n$\\Delta G_{3}(0) = G_{*\\mathrm{OOH}}^{\\mathrm{CHE}} - G_{*\\mathrm{O}}^{\\mathrm{CHE}} = 3.85 - 2.75 = 1.10\\,\\mathrm{eV}$\n因此，$\\Delta G_{4}(0) = 4.92 - (1.02 + 1.73 + 1.10) = 4.92 - 3.85 = 1.07\\,\\mathrm{eV}$。\n因此，$\\Delta G_{4}(U) = \\Delta G_{4}(0) - eU = 1.07 - eU$。\n\n在电势 $U$ 下，四个步骤的自由能变化（单位为 eV）为：\n$\\Delta G_{1}(U) = 1.02 - U$\n$\\Delta G_{2}(U) = 1.73 - U$\n$\\Delta G_{3}(U) = 1.10 - U$\n$\\Delta G_{4}(U) = 1.07 - U$\n\n在 $U=0\\,\\mathrm{V}$ 时，所有的 $\\Delta G$ 都是正值，这意味着所有步骤的自由能都是上升的。速率限制步骤是具有最高自由能垒的步骤，即步骤2：$\\Delta G_{2}(0) = 1.73\\,\\mathrm{eV}$。\n\n极限电势 $U_{L}$ 是使所有步骤自由能都下降的最小电势，即对于所有的 $i=1, 2, 3, 4$，都有 $\\Delta G_{i}(U_{L}) \\le 0$。\n这意味着 $U_{L}$ 必须大于或等于在 $U=0$ 时的最大自由能垒：\n$U_{L} \\ge \\max(\\Delta G_{1}(0), \\Delta G_{2}(0), \\Delta G_{3}(0), \\Delta G_{4}(0))$\n$U_{L} \\ge \\max(1.02, 1.73, 1.10, 1.07)\\,\\mathrm{V}$\n$U_{L} \\ge 1.73\\,\\mathrm{V}$\n\n因此，所需的最小电势为 $U_{L} = 1.73\\,\\mathrm{V}$。在此电势下，步骤2变为热中性（$\\Delta G_2(U_L) = 0$），而所有其他步骤的自由能都下降。这是理论上的过电势决定步骤。\n\n极限电势为 $U_{L} = 1.73\\,\\mathrm{V}$。",
            "answer": "$$\\boxed{1.73}$$"
        },
        {
            "introduction": "虽然CHE模型可以评估反应的热力学瓶颈，但对催化过程的全面理解还需要探索其动力学，特别是活化能垒。微动弹性带（NEB）方法是计算化学中用于寻找反应物和产物之间最小能量路径和过渡态的标准技术。通过这个高级练习 ()，你将通过在一个简化的势能面上实现NEB算法，从而理解如何超越纯粹的热力学分析，去量化决定反应速率的动力学能垒。",
            "id": "4252075",
            "problem": "您需要设计并实现一个数值算法，该算法使用简化的代理势能面和带爬山镜像修正的微动弹性带（NEB）方法，来近似计算在单个吸附氧位点上发生的析氧反应（OER）中水亲核攻击（WNA）步骤的最小能量路径。您的实现必须是一个完整、可运行的程序，能够构建初始和最终状态，对镜像进行插值，应用适当的约束来表示固定的表面，并迭代地弛豫镜像链以定位鞍点和势垒高度。所有能量必须以电子伏特（eV）表示，所有距离必须以埃（Å）表示。最终的势垒能量必须以 eV 为单位，作为浮点数打印，并四舍五入到三位小数。\n\n使用的基础理论：\n- Born–Oppenheimer 近似指出，电子和原子核的运动可以分离，从而能够描述在势能面上演化的原子核位置。\n- 在势能面上，两个极小值之间的最小能量路径是在固定端点下使作用量最小化并通过一个一阶鞍点的路径。\n- 在过渡态理论（TST）中，活化势垒是鞍点与初始态极小值之间的能量差。\n\n物理模型和状态：\n- 考虑一个二维反应坐标 $(x,y)$，用于描述攻击水分子的氧相对于刚性表面上一个固定的吸附氧位点的位置。坐标 $x$ 表示水氧和吸附氧之间垂直于表面的分离距离，坐标 $y$ 表示横向位移。表面原子是固定的，没有被显式表示；约束将确保表面不发生移动，并可选择性地冻结 $y$。\n- 将标量势能面 $E(x,y)$（单位为 eV）定义为沿 $x$ 轴的成键项和沿 $y$ 轴的横向谐振项之和。该代理模型反映了 O–O 键形成的放能性质以及过渡态附近的局域势垒。\n- 初始状态：水氧远离表面氧，坐标为 $(x_{\\mathrm{i}},y_{\\mathrm{i}}) = (3.00\\,\\mathrm{\\AA}, 0.00\\,\\mathrm{\\AA})$。\n- 最终状态：O–O 键形成，坐标为 $(x_{\\mathrm{f}},y_{\\mathrm{f}}) = (1.35\\,\\mathrm{\\AA}, 0.00\\,\\mathrm{\\AA})$。\n\n算法要求：\n- 构建一个包含 $N$ 个镜像的链，其中包括固定的初始和最终端点，以及通过在 $(x,y)$ 坐标上进行线性插值初始化的 $N-2$ 个中间镜像。\n- 使用弹簧常数 $k_{\\mathrm{s}}$ 和爬山镜像修正来实现微动弹性带（NEB）弛豫，以将能量最高的镜像精确化为鞍点。端点保持固定。NEB 必须只包括垂直于路径的物理力分量和沿着路径的弹簧力。\n- 实现一个可选约束，在整个弛豫过程中将所有镜像的横向坐标 $y$ 冻结为 $0$。当此约束激活时，只允许更新 $x$ 坐标。\n- 迭代更新镜像位置，直到收敛到近似的最小能量路径和鞍点，收敛条件受力容差和迭代次数上限的限制。\n- 计算并报告活化势垒，其为能量差 $E_{\\mathrm{barrier}} = E_{\\mathrm{max}} - E(x_{\\mathrm{i}},y_{\\mathrm{i}})$，其中 $E_{\\mathrm{max}}$ 是收敛后链中能量最高镜像的能量。将势垒能量四舍五入到三位小数，并以 eV 为单位报告。\n\n数值代理势：\n- 对垂直于表面的坐标使用以下代理势：\n  - 一个类 Morse 的成键项，其势阱深度为 $D$，范围参数为 $a$，平衡键长为 $r_0$：$E_{\\mathrm{Morse}}(x) = D \\left(1 - e^{-a (x - r_0)}\\right)^2$。\n  - 一个局域高斯势垒，中心位于 $x_{\\mathrm{ts}}$，宽度为 $\\sigma$：$E_{\\mathrm{G}}(x) = B \\exp\\left(-\\dfrac{(x - x_{\\mathrm{ts}})^2}{2\\sigma^2}\\right)$。\n  - 一个稳定化偏移量 $-\\Delta E_{\\mathrm{form}}$，使得最终状态相对于初始状态是放能的。\n- 横向谐振项为 $E_y(y) = \\dfrac{1}{2} k_y y^2$。\n- 总能量：$E(x,y) = E_{\\mathrm{Morse}}(x) + E_{\\mathrm{G}}(x) - \\Delta E_{\\mathrm{form}} + E_y(y)$。\n- 使用物理上合理的常数：$D = 1.2\\,\\mathrm{eV}$，$a = 2.2\\,\\mathrm{\\AA}^{-1}$，$r_0 = 1.35\\,\\mathrm{\\AA}$，$B = 0.65\\,\\mathrm{eV}$，$x_{\\mathrm{ts}} = 2.00\\,\\mathrm{\\AA}$，$\\sigma = 0.20\\,\\mathrm{\\AA}$，$k_y = 0.50\\,\\mathrm{eV}/\\mathrm{\\AA}^2$，以及 $\\Delta E_{\\mathrm{form}} = 0.35\\,\\mathrm{eV}$。\n\n收敛参数：\n- 使用固定的步长进行位置更新，当任何中间镜像上的最大力的大小低于容差时终止。如果使用爬山镜像，则在初始的 NEB 弛豫阶段之后开始爬山。您可以为步长、容差和迭代上限选择合理的数值，以确保下面的测试套件能够收敛。\n\n测试套件：\n提供以下五个测试用例的势垒能量，每个用例指定为一个元组 $(N, k_{\\mathrm{s}}, \\mathrm{freezeY})$，其中 $N$ 是总镜像数，$k_{\\mathrm{s}}$ 是弹簧常数（单位为 $\\mathrm{eV}/\\mathrm{\\AA}^2$），$\\mathrm{freezeY}$ 是一个布尔值，指示是否冻结横向坐标 $y$：\n1. $(5, 5.0, \\mathrm{False})$ — 一般情况，中等数量的镜像和弹簧，允许横向弛豫。\n2. $(7, 10.0, \\mathrm{False})$ — 更多镜像和更强的弹簧，允许横向弛豫。\n3. $(3, 3.0, \\mathrm{True})$ — 最少数量的镜像和弱弹簧，冻结横向坐标；测试仅有端点的路径。\n4. $(8, 0.1, \\mathrm{False})$ — 许多镜像和非常软的弹簧；测试路径的凝聚性。\n5. $(6, 5.0, \\mathrm{True})$ — 中等数量的镜像和弹簧，冻结横向坐标。\n\n要求的输出格式：\n您的程序应生成单行输出，其中包含五个测试用例的势垒能量（单位为 eV），每个能量都四舍五入到三位小数，并以逗号分隔的列表形式放在方括号内（例如，“[0.512,0.498,0.476,0.521,0.505]”）。不应打印任何额外文本。\n\n单位：\n- 能量单位：电子伏特 (eV)。\n- 距离单位：埃 (Å)。\n- 本问题中不使用角度。",
            "solution": "用户要求设计并实现一个数值算法，以寻找一个简化的析氧反应（OER）中水亲核攻击（WNA）步骤模型的最小能量路径（MEP）和活化势垒。所选方法是带爬山镜像修正的微动弹性带（NEB）方法。\n\n### 步骤 1：问题验证\n\n问题陈述已经过验证，被认为是**有效的**。\n- **科学基础**：该问题建立在计算化学的公认原理之上，包括 Born-Oppenheimer 近似、势能面（PES）、过渡态理论和微动弹性带（NEB）方法。使用代理势是算法开发和定性分析的一种标准有效技术。\n- **良构性**：该问题提供了明确定义的初始状态、最终状态、势能的数学形式以及一组特定的参数。这种设置确保了一个唯一且有意义的解（最小能量路径及相关势垒）存在，并且可以通过指定的算法找到。\n- **客观性**：问题以精确、定量和无偏见的语言陈述，没有主观或模棱两可的术语。\n- **完整性**：提供了所有必要的常数、方程、边界条件和测试用例。选择合理的收敛参数的要求是数值算法实现的一个标准部分，而不是问题规范中的缺陷。\n\n该问题是实现计算物理和化学中一个典型算法的结构良好的练习。\n\n### 步骤 2：基于原理的解决方案设计\n\n解决方案将通过将基础物理原理与算法设计相结合来开发。\n\n#### 1. 势能面（PES）和力\n根据 Born-Oppenheimer 近似的规定，反应物种的运动由其下的势能面 $E(x,y)$ 决定。系统被简化为二维坐标空间 $(x, y)$，其中 $x$ 是 O-O 间距，$y$ 是横向位移。总能量由下式给出：\n$$\nE(x,y) = E_{\\mathrm{Morse}}(x) + E_{\\mathrm{G}}(x) - \\Delta E_{\\mathrm{form}} + E_y(y)\n$$\n其中：\n-   $E_{\\mathrm{Morse}}(x) = D \\left(1 - e^{-a (x - r_0)}\\right)^2$ 模拟 O-O 键的形成。\n-   $E_{\\mathrm{G}}(x) = B \\exp\\left(-\\frac{(x - x_{\\mathrm{ts}})^2}{2\\sigma^2}\\right)$ 代表一个局域能量势垒。\n-   $E_y(y) = \\frac{1}{2} k_y y^2$ 是一个限制横向运动的谐振势。\n-   $\\Delta E_{\\mathrm{form}}$ 是一个恒定的能量偏移。\n\n位于位置 $\\mathbf{R} = (x,y)$ 的粒子所受的力是势的负梯度，即 $\\mathbf{F}_{\\mathrm{true}} = -\\nabla E(\\mathbf{R})$。解析梯度为：\n$$\n\\frac{\\partial E}{\\partial x} = 2aD(e^{-a(x-r_0)} - e^{-2a(x-r_0)}) - B \\frac{x-x_{\\mathrm{ts}}}{\\sigma^2} \\exp\\left(-\\frac{(x - x_{\\mathrm{ts}})^2}{2\\sigma^2}\\right)\n$$\n$$\n\\frac{\\partial E}{\\partial y} = k_y y\n$$\n恒定偏移量 $-\\Delta E_{\\mathrm{form}}$ 对力没有贡献，并且作为一个常数，在计算活化势垒的能量差 $E_{\\mathrm{barrier}} = E_{\\mathrm{saddle}} - E_{\\mathrm{initial}}$ 时也会被抵消。\n\n#### 2. 微动弹性带（NEB）方法\nNEB 方法旨在寻找给定初始状态 $\\mathbf{R}_0$ 和最终状态 $\\mathbf{R}_{N-1}$ 之间的最小能量路径（MEP）。路径被离散化为由 $N$ 个构型或“镜像”组成的链，$\\lbrace \\mathbf{R}_0, \\mathbf{R}_1, \\dots, \\mathbf{R}_{N-1} \\rbrace$。中间镜像 $\\mathbf{R}_1, \\dots, \\mathbf{R}_{N-2}$ 被迭代地向最小能量路径弛豫。\n\n在每个中间镜像 $\\mathbf{R}_i$ 处，驱动弛豫的总力由两部分组成：\n1.  **真实力的垂直分量 ($\\mathbf{F}_{i,\\perp}$)**：真实势能力 $\\mathbf{F}_{\\mathrm{true},i} = -\\nabla E(\\mathbf{R}_i)$ 中垂直于路径的分量。这个力分量将镜像滑向最小能量路径，而不会使其沿着路径“下坡”滑向端点。它的计算公式为 $\\mathbf{F}_{i,\\perp} = \\mathbf{F}_{\\mathrm{true},i} - (\\mathbf{F}_{\\mathrm{true},i} \\cdot \\hat{\\mathbf{\\tau}}_i)\\hat{\\mathbf{\\tau}}_i$，其中 $\\hat{\\mathbf{\\tau}}_i$ 是路径在镜像 $i$ 处的归一化切向量。\n2.  **平行弹簧力 ($\\mathbf{F}_{i,s}$)**：一个平行于路径作用的虚拟弹簧力。它确保镜像之间保持大致相等的距离，防止它们在极小值处聚集。这个“弹性带”力由 $\\mathbf{F}_{i,s} = k_s (|\\mathbf{R}_{i+1} - \\mathbf{R}_i| - |\\mathbf{R}_i - \\mathbf{R}_{i-1}|) \\hat{\\mathbf{\\tau}}_i$ 给出，其中 $k_s$ 是弹簧常数。\n\n镜像 $i$ 上的总 NEB 力为 $\\mathbf{F}^{\\mathrm{NEB}}_i = \\mathbf{F}_{i,\\perp} + \\mathbf{F}_{i,s}$。\n\n#### 3. 爬山镜像 NEB (CI-NEB)\n标准的 NEB 计算可能无法精确定位鞍点，因为镜像是离散点，而真正的鞍点可能位于它们之间。爬山镜像修正解决了这个问题。经过初步弛豫后，能量最高的镜像被识别出来。对于这个“爬山镜像” $\\mathbf{R}_c$，力的计算被修改为：\n$$\n\\mathbf{F}^{\\mathrm{CI}}_c = \\mathbf{F}_{\\mathrm{true},c} - 2(\\mathbf{F}_{\\mathrm{true},c} \\cdot \\hat{\\mathbf{\\tau}}_c)\\hat{\\mathbf{\\tau}}_c\n$$\n这个力反转了真实力中平行于路径的分量，因此镜像被沿着能带向上驱动到精确的鞍点，同时仍在垂直方向上进行弛豫。对于这个镜像，弹簧力被有效地移除了。\n\n#### 4. 算法实现\n算法流程如下：\n1.  **初始化**：创建一个包含 $N$ 个镜像的链。端点 $\\mathbf{R}_0$ 和 $\\mathbf{R}_{N-1}$ 被设置为给定的初始和最终状态。中间镜像通过在端点之间进行线性插值来初始化。\n2.  **迭代**：算法进入一个循环，直到收敛。\n    a.  **能量计算**：为所有镜像计算势能。\n    b.  **爬山镜像选择**：如果在一定数量的初始迭代之后，将能量最高的中间镜像指定为爬山镜像。\n    c.  **力计算**：对于每个中间镜像 $i \\in \\{1, \\dots, N-2\\}$：\n        i.  估计局部路径切线 $\\hat{\\mathbf{\\tau}}_i$，例如，可以从相邻镜像 $\\mathbf{R}_{i-1}$ 和 $\\mathbf{R}_{i+1}$ 的位置来估计。\n        ii. 根据是否为爬山镜像，将力 $\\mathbf{F}_i$ 计算为 $\\mathbf{F}^{\\mathrm{NEB}}_i$ 或 $\\mathbf{F}^{\\mathrm{CI}}_i$。\n        iii. 如果 `freezeY` 约束被激活，则将计算出的力的 y 分量设置为零。\n    d.  **位置更新**：使用简单的梯度上升步骤更新中间镜像的位置：$\\mathbf{R}_i \\leftarrow \\mathbf{R}_i + \\alpha \\mathbf{F}_i$，其中 $\\alpha$ 是一个小的固定步长。\n    e.  **收敛检查**：如果任何镜像上的最大力矢量的大小低于指定的容差，或者达到最大迭代次数，则循环终止。\n3.  **势垒计算**：收敛后，活化势垒被计算为能量最高镜像（鞍点）与初始状态镜像之间的能量差：$E_{\\mathrm{barrier}} = E(\\mathbf{R}_c) - E(\\mathbf{R}_0)$。\n\n这个过程为在给定的势能面上定位鞍点和确定活化势垒提供了一个稳健的方法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Physical model and constants\nCONSTS = {\n    # Morse potential parameters\n    'D': 1.2,       # eV\n    'a': 2.2,       # Å^-1\n    'r0': 1.35,     # Å\n    # Gaussian barrier parameters\n    'B': 0.65,      # eV\n    'xts': 2.00,    # Å\n    'sigma': 0.20,  # Å\n    # Lateral potential and energy offset\n    'ky': 0.50,     # eV/Å^2\n    'DE_form': 0.35 # eV\n}\n\n# Initial and final states\nR_INITIAL = np.array([3.00, 0.00]) # Å\nR_FINAL = np.array([1.35, 0.00])   # Å\n\ndef potential_energy(pos):\n    \"\"\"Calculates the potential energy E(x,y) at a given position.\"\"\"\n    x, y = pos\n    \n    # Morse potential term\n    E_morse = CONSTS['D'] * (1 - np.exp(-CONSTS['a'] * (x - CONSTS['r0'])))**2\n    \n    # Gaussian barrier term\n    E_gauss = CONSTS['B'] * np.exp(-(x - CONSTS['xts'])**2 / (2 * CONSTS['sigma']**2))\n    \n    # Lateral harmonic term\n    E_y = 0.5 * CONSTS['ky'] * y**2\n    \n    # Total energy\n    E_total = E_morse + E_gauss - CONSTS['DE_form'] + E_y\n    return E_total\n\ndef analytical_force(pos):\n    \"\"\"Calculates the analytical force F = -grad(E) at a given position.\"\"\"\n    x, y = pos\n\n    # Gradient component for x-coordinate\n    term1_morse = 2 * CONSTS['a'] * CONSTS['D'] * (\n        np.exp(-CONSTS['a'] * (x - CONSTS['r0'])) - \n        np.exp(-2 * CONSTS['a'] * (x - CONSTS['r0']))\n    )\n    term2_gauss = -CONSTS['B'] * (x - CONSTS['xts']) / CONSTS['sigma']**2 * \\\n                  np.exp(-(x - CONSTS['xts'])**2 / (2 * CONSTS['sigma']**2))\n    \n    dEdx = term1_morse + term2_gauss\n    \n    # Gradient component for y-coordinate\n    dEdy = CONSTS['ky'] * y\n    \n    # Force is the negative gradient\n    return -np.array([dEdx, dEdy])\n\ndef calculate_barrier_neb(N, k_s, freezeY):\n    \"\"\"\n    Performs a Nudged Elastic Band calculation with climbing image modification.\n\n    Args:\n        N (int): Total number of images in the band.\n        k_s (float): Spring constant in eV/Å^2.\n        freezeY (bool): If True, freezes the y-coordinate.\n\n    Returns:\n        float: The calculated activation barrier in eV.\n    \"\"\"\n    # Convergence parameters\n    step_size = 0.01        # Step size for gradient ascent (alpha)\n    force_tol = 1e-4        # Convergence tolerance in eV/Å\n    max_iter = 5000         # Maximum number of iterations\n    climb_start_iter = 100  # Iteration to start climbing\n\n    # 1. Initialize the band of images by linear interpolation\n    images = np.zeros((N, 2))\n    for i in range(N):\n        images[i] = R_INITIAL + i * (R_FINAL - R_INITIAL) / (N - 1)\n\n    # Main optimization loop\n    for iteration in range(max_iter):\n        # 2. Calculate energies for all images\n        energies = np.array([potential_energy(img) for img in images])\n\n        # 3. Identify the climbing image (highest energy image, excluding endpoints)\n        is_climbing = iteration >= climb_start_iter\n        if is_climbing:\n            # Find index of max energy among movable images\n            climb_idx = np.argmax(energies[1:-1]) + 1\n        else:\n            climb_idx = -1 # Sentinel for not climbing\n\n        # 4. Calculate forces on intermediate images\n        total_forces = np.zeros((N, 2))\n        for i in range(1, N - 1):\n            # a. Calculate the path tangent\n            tangent = images[i+1] - images[i-1]\n            tangent_norm = np.linalg.norm(tangent)\n            if tangent_norm > 1e-9:\n                tangent /= tangent_norm\n            else:\n                # Fallback if images are collinear and overlapping\n                tangent = np.array([1.0, 0.0])\n\n            # b. Calculate the true force from the potential\n            F_true = analytical_force(images[i])\n\n            # c. Calculate NEB or Climbing Image force\n            if i == climb_idx:\n                # Climbing image force: invert parallel component\n                F_parallel_mag = np.dot(F_true, tangent)\n                F_total = F_true - 2 * F_parallel_mag * tangent\n            else:\n                # Standard NEB force\n                # Perpendicular component of true force\n                F_perp = F_true - np.dot(F_true, tangent) * tangent\n                # Parallel spring force\n                d_plus = np.linalg.norm(images[i+1] - images[i])\n                d_minus = np.linalg.norm(images[i] - images[i-1])\n                F_spring = k_s * (d_plus - d_minus) * tangent\n                F_total = F_perp + F_spring\n            \n            total_forces[i] = F_total\n\n        if freezeY:\n            total_forces[:, 1] = 0.0\n\n        # 5. Update image positions (simple gradient ascent)\n        images[1:-1] += step_size * total_forces[1:-1]\n\n        # 6. Check for convergence\n        max_force = np.max(np.linalg.norm(total_forces[1:-1], axis=1))\n        if max_force  force_tol:\n            break\n\n    # 7. Recalculate final energies and compute the barrier\n    final_energies = np.array([potential_energy(img) for img in images])\n    E_max = np.max(final_energies)\n    E_initial = final_energies[0]\n    barrier = E_max - E_initial\n    \n    return barrier\n\ndef solve():\n    \"\"\"\n    Runs the NEB calculation for all test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        (5, 5.0, False),  # Case 1\n        (7, 10.0, False), # Case 2\n        (3, 3.0, True),   # Case 3\n        (8, 0.1, False),  # Case 4\n        (6, 5.0, True),   # Case 5\n    ]\n\n    results = []\n    for N, k_s, freezeY in test_cases:\n        barrier = calculate_barrier_neb(N=N, k_s=k_s, freezeY=freezeY)\n        results.append(barrier)\n\n    # Format the results to three decimal places and print\n    formatted_results = [f\"{res:.3f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}