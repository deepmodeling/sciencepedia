{
    "hands_on_practices": [
        {
            "introduction": "The reliability of Density Functional Theory (DFT) calculations in surface science hinges on the careful mitigation of artifacts arising from periodic boundary conditions. Spurious interactions between a slab and its periodic images must be minimized by ensuring sufficient vacuum spacing and slab thickness. This practice provides hands-on experience in developing a systematic algorithm for convergence testing, a foundational and non-negotiable step for producing physically meaningful computational results in electrocatalysis research .",
            "id": "4252164",
            "problem": "You are modeling adsorption energetics for the Oxygen Evolution Reaction (OER) on a transition-metal oxide surface using a repeated-slab, plane-wave Density Functional Theory (DFT) approach. In such simulations, adsorption energy convergence with respect to slab thickness and vacuum spacing is essential to obtain physically meaningful results. You will implement a program to determine, for each parameter set in a test suite, the minimum slab thickness (in atomic layers) and the minimum vacuum spacing (in ångström) required to converge the adsorption energy to within prescribed tolerances, and to decide whether a dipole correction should be applied for asymmetric slabs.\n\nUse the following scientifically grounded base:\n\n- In a repeated-slab setup, the adsorption energy $E_\\mathrm{ads}$ can be decomposed into a term that converges with slab thickness due to electronic screening in the solid and a term that converges with vacuum spacing due to spurious interactions between periodic images. The decomposition is\n$$\nE_\\mathrm{ads}(L,V,p) = E_\\infty + \\Delta E_\\mathrm{thick}(L) + \\Delta E_\\mathrm{vac}(V,p),\n$$\nwhere $L$ is the slab thickness measured in integer atomic layers, $V$ is the vacuum spacing in ångström, $p$ is the net dipole moment along the surface normal (the $z$-axis) characterizing slab asymmetry, and $E_\\infty$ is the adsorption energy in the infinite-slab, infinite-vacuum limit.\n\n- Electronic screening in the slab leads to an exponential decay of the thickness-dependent correction,\n$$\n\\Delta E_\\mathrm{thick}(L) = \\alpha \\exp\\!\\left(-\\frac{L}{\\lambda}\\right),\n$$\nwith amplitude $\\alpha$ (in electronvolts) and characteristic screening length $\\lambda$ (in layers).\n\n- Spurious electrostatic interactions between repeated slabs in the vacuum direction lead to an inverse scaling with vacuum spacing. A simple and widely used effective-model representation for the vacuum-dependent correction is\n$$\n\\Delta E_\\mathrm{vac}(V,p) = \\frac{\\beta + \\gamma p^2}{V},\n$$\nwith $\\beta$ (in electronvolt·ångström) quantifying non-dipolar image interactions, and $\\gamma$ (in electronvolt·ångström per squared dipole unit) quantifying dipolar image interactions. The presence of a nonzero $p$ indicates slab asymmetry. A dipole correction removes the spurious dipolar interaction between periodic images, which in this model corresponds to setting the effective $p^2$ contribution to zero when the correction is applied.\n\nDefine convergence as follows:\n\n- Slab thickness convergence is achieved when the magnitude of the incremental change in adsorption energy upon increasing $L$ by one layer falls below a specified tolerance $\\delta_\\mathrm{thick}$ (in electronvolts),\n$$\n\\left| \\Delta E_\\mathrm{thick}(L) - \\Delta E_\\mathrm{thick}(L+1) \\right| \\le \\delta_\\mathrm{thick}.\n$$\n\n- Vacuum spacing convergence is achieved when the magnitude of the incremental change in adsorption energy upon increasing $V$ by a fixed step $\\Delta V$ falls below a specified tolerance $\\delta_\\mathrm{vac}$ (in electronvolts),\n$$\n\\left| \\Delta E_\\mathrm{vac}(V,p_\\mathrm{eff}) - \\Delta E_\\mathrm{vac}(V+\\Delta V,p_\\mathrm{eff}) \\right| \\le \\delta_\\mathrm{vac},\n$$\nwhere $p_\\mathrm{eff} = p$ if no dipole correction is applied, and $p_\\mathrm{eff} = 0$ if a dipole correction is applied.\n\nDecide whether to apply a dipole correction using a simple physically motivated criterion: apply the correction if $p \\ge p_\\mathrm{thresh}$, where $p_\\mathrm{thresh}$ is a specified threshold.\n\nAlgorithmic requirements:\n\n- For thickness convergence, search $L$ from $L=1$ upward in integer steps until the thickness convergence criterion is met or a specified maximum $L_\\mathrm{max}$ is reached. If the convergence criterion is not met within the bound, return $L_\\mathrm{max}$.\n\n- For vacuum convergence, search $V$ from a specified start $V_\\mathrm{start}$ upward in steps of $\\Delta V$ until the vacuum convergence criterion is met or a specified maximum $V_\\mathrm{max}$ is reached. If the convergence criterion is not met within the bound, return $V_\\mathrm{max}$. When evaluating the vacuum convergence criterion, use $p_\\mathrm{eff}$ as defined above depending on whether the dipole correction is deemed necessary.\n\n- Report for each test case a list containing the minimum slab thickness $L_\\mathrm{min}$ (integer, in layers), the minimum vacuum spacing $V_\\mathrm{min}$ (float, in ångström), and a boolean indicating whether the dipole correction is applied.\n\nPhysical units and output requirements:\n\n- Energies must be treated in electronvolts ($\\mathrm{eV}$). Vacuum spacings must be treated in ångström ($\\mathrm{\\AA}$). Slab thickness is in integer atomic layers.\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[\\text{result}_1,\\text{result}_2,\\text{result}_3]$). Each $\\text{result}_i$ must be a list containing $L_\\mathrm{min}$ (integer), $V_\\mathrm{min}$ (float), and the boolean for dipole correction.\n\nTest suite:\n\nUse the following parameter sets, provided as tuples in the order\n$(\\alpha,\\lambda,\\beta,\\gamma,p,\\delta_\\mathrm{thick},\\delta_\\mathrm{vac},L_\\mathrm{max},V_\\mathrm{start},\\Delta V,V_\\mathrm{max},p_\\mathrm{thresh})$:\n\n- Case $1$ (general asymmetric slab):\n  $(0.15, 2.0, 0.12, 0.08, 0.80, 0.01, 0.005, 12, 10.0, 2.0, 30.0, 0.20)$.\n\n- Case $2$ (symmetric slab, no dipole):\n  $(0.20, 1.5, 0.10, 0.05, 0.00, 0.02, 0.01, 10, 8.0, 4.0, 24.0, 0.10)$.\n\n- Case $3$ (tight tolerances, strong dipole):\n  $(0.10, 3.0, 0.08, 0.12, 1.50, 0.001, 0.0005, 15, 12.0, 3.0, 45.0, 0.30)$.\n\n- Case $4$ (small $\\lambda$, large $\\alpha$, large dipole):\n  $(0.30, 1.0, 0.15, 0.20, 2.00, 0.03, 0.02, 8, 10.0, 5.0, 35.0, 0.50)$.\n\nYour program must run these cases internally (no external input), compute the required outputs using the rules above, and print the final aggregated list on a single line as specified.",
            "solution": "The problem requires the implementation of an algorithm to determine the minimum slab thickness and vacuum spacing for converged adsorption energy calculations in a repeated-slab Density Functional Theory (DFT) framework. The decision of whether to apply a dipole correction must also be made based on a given criterion.\n\nThe total adsorption energy, $E_\\mathrm{ads}$, as a function of slab thickness $L$ (in atomic layers), vacuum spacing $V$ (in ångström), and the slab's net dipole moment $p$ (in arbitrary dipole units) is given by the model:\n$$\nE_\\mathrm{ads}(L,V,p) = E_\\infty + \\Delta E_\\mathrm{thick}(L) + \\Delta E_\\mathrm{vac}(V,p)\n$$\nwhere $E_\\infty$ is the converged adsorption energy, and $\\Delta E_\\mathrm{thick}(L)$ and $\\Delta E_\\mathrm{vac}(V,p)$ are correction terms that vanish as $L \\to \\infty$ and $V \\to \\infty$, respectively.\n\nThe thickness-dependent correction is modeled by an exponential decay, reflecting electronic screening effects within the slab:\n$$\n\\Delta E_\\mathrm{thick}(L) = \\alpha \\exp\\!\\left(-\\frac{L}{\\lambda}\\right)\n$$\nHere, $\\alpha$ is an energy amplitude (in $\\mathrm{eV}$), and $\\lambda$ is a characteristic screening length (in layers).\n\nThe vacuum-dependent correction models spurious electrostatic interactions between periodic images of the slab and is given by:\n$$\n\\Delta E_\\mathrm{vac}(V,p) = \\frac{\\beta + \\gamma p^2}{V}\n$$\nThe parameter $\\beta$ (in $\\mathrm{eV\\cdot\\AA}$) represents non-dipolar interactions, while $\\gamma$ (in $\\mathrm{eV\\cdot\\AA}$ per squared dipole unit) quantifies the interaction between the net dipoles of the periodic images.\n\nConvergence is defined based on the incremental change in these energy correction terms.\nSlab thickness convergence is achieved for a thickness $L$ when the magnitude of the energy change from increasing the thickness by one layer falls below a tolerance $\\delta_\\mathrm{thick}$:\n$$\n\\left| \\Delta E_\\mathrm{thick}(L) - \\Delta E_\\mathrm{thick}(L+1) \\right| \\le \\delta_\\mathrm{thick}\n$$\nSubstituting the expression for $\\Delta E_\\mathrm{thick}(L)$, the condition becomes:\n$$\n\\left| \\alpha e^{-L/\\lambda} - \\alpha e^{-(L+1)/\\lambda} \\right| = \\alpha e^{-L/\\lambda} \\left(1 - e^{-1/\\lambda}\\right) \\le \\delta_\\mathrm{thick}\n$$\nassuming $\\alpha > 0$ and $\\lambda > 0$. The minimum required thickness, $L_\\mathrm{min}$, is found by starting from $L=1$ and incrementing until this inequality is satisfied. If the condition is not met for any $L < L_\\mathrm{max}$, the minimum thickness is taken to be $L_\\mathrm{max}$.\n\nVacuum spacing convergence is achieved for a spacing $V$ when the energy change from increasing the vacuum by $\\Delta V$ falls below a tolerance $\\delta_\\mathrm{vac}$:\n$$\n\\left| \\Delta E_\\mathrm{vac}(V,p_\\mathrm{eff}) - \\Delta E_\\mathrm{vac}(V+\\Delta V,p_\\mathrm{eff}) \\right| \\le \\delta_\\mathrm{vac}\n$$\nThe effective dipole moment, $p_\\mathrm{eff}$, depends on whether a dipole correction is applied. A dipole correction is a computational technique that removes the spurious long-range dipole-dipole interaction between periodic images. Within this model, applying the correction is equivalent to setting the dipole contribution to zero, i.e., $p_\\mathrm{eff} = 0$. The decision to apply the correction is based on the heuristic that significant dipoles require correction: the correction is applied if $p \\ge p_\\mathrm{thresh}$. If no correction is applied, $p_\\mathrm{eff} = p$.\n\nSubstituting the expression for $\\Delta E_\\mathrm{vac}(V, p_\\mathrm{eff})$, the convergence condition is:\n$$\n\\left| \\frac{\\beta + \\gamma p_\\mathrm{eff}^2}{V} - \\frac{\\beta + \\gamma p_\\mathrm{eff}^2}{V+\\Delta V} \\right| = (\\beta + \\gamma p_\\mathrm{eff}^2) \\left(\\frac{\\Delta V}{V(V+\\Delta V)}\\right) \\le \\delta_\\mathrm{vac}\n$$\nThe minimum required vacuum, $V_\\mathrm{min}$, is found by starting from $V=V_\\mathrm{start}$ and incrementing by steps of $\\Delta V$ until the inequality is satisfied. If the condition is not met for any step where the starting vacuum is less than $V_\\mathrm{max}$, the minimum vacuum is taken to be $V_\\mathrm{max}$.\n\nThe algorithm proceeds as follows for each parameter set:\n1.  Compare the slab dipole moment $p$ with the threshold $p_\\mathrm{thresh}$. If $p \\ge p_\\mathrm{thresh}$, a dipole correction is applied (which sets $p_\\mathrm{eff} = 0$ for the vacuum calculation). Otherwise, no correction is applied ($p_\\mathrm{eff} = p$). A boolean flag records this decision.\n2.  Iterate $L$ from $1$ to $L_\\mathrm{max}-1$. For each $L$, calculate the thickness-dependent energy change. If it is less than or equal to $\\delta_\\mathrm{thick}$, set $L_\\mathrm{min} = L$ and terminate the search for thickness. If the loop completes without convergence, set $L_\\mathrm{min} = L_\\mathrm{max}$.\n3.  Iterate $V$ starting from $V_\\mathrm{start}$ in increments of $\\Delta V$, as long as $V < V_\\mathrm{max}$. For each $V$, calculate the vacuum-dependent energy change using the appropriate $p_\\mathrm{eff}$. If the change is less than or equal to $\\delta_\\mathrm{vac}$, set $V_\\mathrm{min} = V$ and terminate the search for vacuum. If the loop completes without convergence, set $V_\\mathrm{min} = V_\\mathrm{max}$.\n4.  Report the triplet $[L_\\mathrm{min}, V_\\mathrm{min}, \\text{dipole\\_applied\\_boolean}]$.\n\nApplying this procedure to the provided test cases yields the following results:\n\n- **Case 1**: $(\\alpha, \\lambda, \\beta, \\gamma, p, \\delta_\\mathrm{thick}, \\delta_\\mathrm{vac}, L_\\mathrm{max}, V_\\mathrm{start}, \\Delta V, V_\\mathrm{max}, p_\\mathrm{thresh}) = (0.15, 2.0, 0.12, 0.08, 0.80, 0.01, 0.005, 12, 10.0, 2.0, 30.0, 0.20)$.\n  - Dipole decision: $p=0.80 \\ge p_\\mathrm{thresh}=0.20$. Apply correction. `True`. $p_\\mathrm{eff}=0$.\n  - Thickness convergence: $L_\\mathrm{min} = 4$.\n  - Vacuum convergence: $V_\\mathrm{min} = 10.0$.\n  - Result: $[4, 10.0, \\text{True}]$\n\n- **Case 2**: $(0.20, 1.5, 0.10, 0.05, 0.00, 0.02, 0.01, 10, 8.0, 4.0, 24.0, 0.10)$.\n  - Dipole decision: $p=0.00 < p_\\mathrm{thresh}=0.10$. No correction. `False`. $p_\\mathrm{eff}=0.0$.\n  - Thickness convergence: $L_\\mathrm{min} = 3$.\n  - Vacuum convergence: $V_\\mathrm{min} = 8.0$.\n  - Result: $[3, 8.0, \\text{False}]$\n\n- **Case 3**: $(0.10, 3.0, 0.08, 0.12, 1.50, 0.001, 0.0005, 15, 12.0, 3.0, 45.0, 0.30)$.\n  - Dipole decision: $p=1.50 \\ge p_\\mathrm{thresh}=0.30$. Apply correction. `True`. $p_\\mathrm{eff}=0$.\n  - Thickness convergence: $L_\\mathrm{min} = 11$.\n  - Vacuum convergence: $V_\\mathrm{min} = 21.0$.\n  - Result: $[11, 21.0, \\text{True}]$\n\n- **Case 4**: $(0.30, 1.0, 0.15, 0.20, 2.00, 0.03, 0.02, 8, 10.0, 5.0, 35.0, 0.50)$.\n  - Dipole decision: $p=2.00 \\ge p_\\mathrm{thresh}=0.50$. Apply correction. `True`. $p_\\mathrm{eff}=0$.\n  - Thickness convergence: $L_\\mathrm{min} = 2$.\n  - Vacuum convergence: $V_\\mathrm{min} = 10.0$.\n  - Result: $[2, 10.0, \\text{True}]$\n\nThe final implementation translates these procedures into code.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_min_L(alpha, lam, delta_thick, L_max):\n    \"\"\"\n    Determines the minimum slab thickness L_min for convergence.\n\n    Args:\n        alpha (float): Amplitude of the thickness correction term.\n        lam (float): Characteristic screening length.\n        delta_thick (float): Convergence tolerance for thickness.\n        L_max (int): Maximum number of layers to test.\n\n    Returns:\n        int: The minimum converged number of layers, L_min.\n    \"\"\"\n    # Search L from L=1 up to L_max-1. The convergence criterion is for the\n    # difference between layer L and layer L+1.\n    for L in range(1, L_max):\n        # Calculate the magnitude of the energy change:\n        # |ΔE_thick(L) - ΔE_thick(L+1)| = α * exp(-L/λ) * (1 - exp(-1/λ))\n        # Since alpha > 0 and (1 - exp(-1/λ)) > 0 for λ > 0, we can drop abs().\n        energy_change = alpha * np.exp(-L / lam) * (1.0 - np.exp(-1.0 / lam))\n        \n        if energy_change <= delta_thick:\n            return L\n    \n    # If the loop completes without meeting the criterion, return L_max.\n    return L_max\n\ndef find_min_V(beta, gamma, p_eff, delta_vac, V_start, delta_V, V_max):\n    \"\"\"\n    Determines the minimum vacuum spacing V_min for convergence.\n\n    Args:\n        beta (float): Non-dipolar interaction coefficient.\n        gamma (float): Dipolar interaction coefficient.\n        p_eff (float): Effective dipole moment after correction decision.\n        delta_vac (float): Convergence tolerance for vacuum.\n        V_start (float): Starting vacuum spacing.\n        delta_V (float): Increment for vacuum spacing.\n        V_max (float): Maximum vacuum spacing to test.\n\n    Returns:\n        float: The minimum converged vacuum spacing, V_min.\n    \"\"\"\n    V = V_start\n    C_vac = beta + gamma * (p_eff**2)\n    \n    # If there are no spurious vacuum interactions, the starting value is sufficient.\n    if np.isclose(C_vac, 0.0):\n        return V_start\n\n    # Search V from V_start, as long as V is less than V_max.\n    while V < V_max:\n        V_next = V + delta_V\n        \n        # Calculate the magnitude of the energy change:\n        # |ΔE_vac(V) - ΔE_vac(V+ΔV)| = C_vac * ΔV / (V * (V+ΔV))\n        # Since C_vac >= 0 and ΔV > 0, we can drop abs().\n        energy_change = C_vac * delta_V / (V * V_next)\n\n        if energy_change <= delta_vac:\n            return V\n\n        V = V_next\n    \n    # If the loop completes without meeting the criterion, return V_max.\n    return V_max\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Tuple format:\n    # (alpha, lambda, beta, gamma, p, delta_thick, delta_vac,\n    #  L_max, V_start, delta_V, V_max, p_thresh)\n    test_cases = [\n        (0.15, 2.0, 0.12, 0.08, 0.80, 0.01, 0.005, 12, 10.0, 2.0, 30.0, 0.20),\n        (0.20, 1.5, 0.10, 0.05, 0.00, 0.02, 0.01, 10, 8.0, 4.0, 24.0, 0.10),\n        (0.10, 3.0, 0.08, 0.12, 1.50, 0.001, 0.0005, 15, 12.0, 3.0, 45.0, 0.30),\n        (0.30, 1.0, 0.15, 0.20, 2.00, 0.03, 0.02, 8, 10.0, 5.0, 35.0, 0.50),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        alpha, lam, beta, gamma, p, delta_thick, delta_vac, \\\n        L_max, V_start, delta_V, V_max, p_thresh = case\n\n        # Step 1: Decide whether to apply the dipole correction.\n        dipole_applied = p >= p_thresh\n        p_eff = 0.0 if dipole_applied else p\n        \n        # Step 2: Find the minimum slab thickness L_min.\n        L_min = find_min_L(alpha, lam, delta_thick, L_max)\n        \n        # Step 3: Find the minimum vacuum spacing V_min.\n        V_min = find_min_V(beta, gamma, p_eff, delta_vac, V_start, delta_V, V_max)\n        \n        # Step 4: Collect the results for this case.\n        all_results.append([L_min, float(V_min), dipole_applied])\n\n    # Final print statement in the exact required format.\n    # Convert list of lists to string and remove spaces for compact output.\n    final_output_string = str(all_results).replace(\" \", \"\")\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "Once converged adsorption energies for reaction intermediates are obtained, the next step is to construct a Gibbs free energy diagram to predict catalytic activity. The Computational Hydrogen Electrode (CHE) model provides a powerful framework for this, allowing us to determine the theoretical overpotential by identifying the most thermodynamically challenging elementary step. This exercise solidifies the core application of the CHE model, enabling you to translate raw DFT data into a key performance descriptor—the limiting potential $U_L$—for an electrocatalyst .",
            "id": "4252157",
            "problem": "A metal-oxide electrocatalyst for the oxygen evolution reaction (OER) is modeled using the computational hydrogen electrode (CHE) framework at temperature $T=298\\,\\mathrm{K}$ and $\\mathrm{pH}=0$. The reversible hydrogen electrode (RHE) is used as the reference. Consider a single-site mechanism on an unoccupied surface site $*$ consisting of four proton–electron transfer steps, each transferring one proton and one electron:\n(1) $* + \\mathrm{H_{2}O(l)} \\rightarrow *\\mathrm{OH} + \\mathrm{H^{+}} + \\mathrm{e^{-}}$,\n(2) $*\\mathrm{OH} \\rightarrow *\\mathrm{O} + \\mathrm{H^{+}} + \\mathrm{e^{-}}$,\n(3) $*\\mathrm{O} + \\mathrm{H_{2}O(l)} \\rightarrow *\\mathrm{OOH} + \\mathrm{H^{+}} + \\mathrm{e^{-}}$,\n(4) $*\\mathrm{OOH} \\rightarrow * + \\mathrm{O_{2}(g)} + \\mathrm{H^{+}} + \\mathrm{e^{-}}$.\nWithin CHE, the adsorption free energies at $U=0\\,\\mathrm{V}$ versus RHE (including zero-point energy and entropy corrections) for the intermediates at a fixed coverage of $\\theta=1/4$ monolayer are provided as\n$G_{*\\mathrm{OH}}^{\\mathrm{CHE}} = 1.02\\,\\mathrm{eV}$,\n$G_{*\\mathrm{O}}^{\\mathrm{CHE}} = 2.75\\,\\mathrm{eV}$,\n$G_{*\\mathrm{OOH}}^{\\mathrm{CHE}} = 3.85\\,\\mathrm{eV}$,\ndefined relative to $*$, $\\mathrm{H_{2}O(l)}$, and $\\tfrac{1}{2}\\mathrm{H_{2}(g)}$ in the standard CHE convention. Assume the standard equilibrium potential for the overall $\\mathrm{O_{2}}/\\mathrm{H_{2}O}$ couple is $1.23\\,\\mathrm{V}$ at $T=298\\,\\mathrm{K}$ and $\\mathrm{pH}=0$, so the total standard free energy change for $\\mathrm{OER}$ is $4\\times 1.23\\,\\mathrm{eV}$. Using only fundamental CHE relations and conservation of free energy, determine the limiting potential $U_{L}$ (the minimum potential at which all four elementary steps are downhill in free energy) and indicate which elementary step is rate-limiting at $U=0\\,\\mathrm{V}$. Report only the value of $U_{L}$, expressed in $\\mathrm{V}$ versus $\\mathrm{RHE}$. Round your final numerical answer to three significant figures.",
            "solution": "The problem requires finding the limiting potential, $U_L$, for the Oxygen Evolution Reaction (OER) based on the Computational Hydrogen Electrode (CHE) model. The limiting potential is determined by the most thermodynamically difficult step in the reaction mechanism at zero applied potential.\n\nThe OER mechanism consists of four elementary proton-coupled electron transfer (PCET) steps:\n1.  $* + \\mathrm{H_{2}O(l)} \\rightarrow *\\mathrm{OH} + \\mathrm{H^{+}} + \\mathrm{e^{-}}$\n2.  $*\\mathrm{OH} \\rightarrow *\\mathrm{O} + \\mathrm{H^{+}} + \\mathrm{e^{-}}$\n3.  $*\\mathrm{O} + \\mathrm{H_{2}O(l)} \\rightarrow *\\mathrm{OOH} + \\mathrm{H^{+}} + \\mathrm{e^{-}}$\n4.  $*\\mathrm{OOH} \\rightarrow * + \\mathrm{O_{2}(g)} + \\mathrm{H^{+}} + \\mathrm{e^{-}}$\n\nThe free energy change for each step at $U=0\\,\\mathrm{V}$ vs. RHE, denoted $\\Delta G_i$, can be calculated from the provided adsorption free energies of the intermediates ($G_{*\\mathrm{OH}}^{\\mathrm{CHE}}$, $G_{*\\mathrm{O}}^{\\mathrm{CHE}}$, $G_{*\\mathrm{OOH}}^{\\mathrm{CHE}}$). These energies are defined relative to the initial state ($*$, $\\mathrm{H_2O}$, and $\\mathrm{H_2}$).\n\nThe free energy for the first step is given directly:\n$$ \\Delta G_1 = G_{*\\mathrm{OH}}^{\\mathrm{CHE}} - G_* - G_{\\mathrm{H_2O}} + \\frac{1}{2}G_{\\mathrm{H_2}} = 1.02\\,\\mathrm{eV} $$\n\nFor the second step, the change is the difference between the free energies of the product and reactant adsorbates:\n$$ \\Delta G_2 = G_{*\\mathrm{O}}^{\\mathrm{CHE}} - G_{*\\mathrm{OH}}^{\\mathrm{CHE}} = 2.75\\,\\mathrm{eV} - 1.02\\,\\mathrm{eV} = 1.73\\,\\mathrm{eV} $$\n\nSimilarly, for the third step:\n$$ \\Delta G_3 = G_{*\\mathrm{OOH}}^{\\mathrm{CHE}} - G_{*\\mathrm{O}}^{\\mathrm{CHE}} = 3.85\\,\\mathrm{eV} - 2.75\\,\\mathrm{eV} = 1.10\\,\\mathrm{eV} $$\n\nThe total free energy change for the four-electron OER is fixed by the equilibrium potential, $\\Delta G_{\\mathrm{OER}} = 4e \\times 1.23\\,\\mathrm{V} = 4.92\\,\\mathrm{eV}$. Since $\\Delta G_{\\mathrm{OER}} = \\sum_{i=1}^4 \\Delta G_i$, we can find the free energy of the fourth step by conservation:\n$$ \\Delta G_4 = \\Delta G_{\\mathrm{OER}} - (\\Delta G_1 + \\Delta G_2 + \\Delta G_3) = 4.92\\,\\mathrm{eV} - (1.02 + 1.73 + 1.10)\\,\\mathrm{eV} = 4.92\\,\\mathrm{eV} - 3.85\\,\\mathrm{eV} = 1.07\\,\\mathrm{eV} $$\n\nThe elementary steps at $U=0\\,\\mathrm{V}$ have free energy changes: $\\Delta G_1 = 1.02\\,\\mathrm{eV}$, $\\Delta G_2 = 1.73\\,\\mathrm{eV}$, $\\Delta G_3 = 1.10\\,\\mathrm{eV}$, and $\\Delta G_4 = 1.07\\,\\mathrm{eV}$.\n\nAt an applied potential $U$, the free energy of each step is $\\Delta G_i(U) = \\Delta G_i - eU$. For all steps to be thermodynamically downhill ($\\Delta G_i(U) \\le 0$), the potential must satisfy $eU \\ge \\Delta G_i$ for all $i$. This requires the potential to overcome the largest barrier:\n$$ eU \\ge \\max(\\Delta G_1, \\Delta G_2, \\Delta G_3, \\Delta G_4) $$\n\nThe limiting potential, $U_L$, is the minimum potential that satisfies this condition:\n$$ U_L = \\frac{1}{e} \\max(1.02, 1.73, 1.10, 1.07)\\,\\mathrm{eV} = 1.73\\,\\mathrm{V} $$\n\nThe rate-limiting step at $U=0\\,\\mathrm{V}$ is the one with the highest free energy change, which is step (2), the oxidation of $*\\mathrm{OH}$ to $*\\mathrm{O}$.",
            "answer": "$$\\boxed{1.73}$$"
        },
        {
            "introduction": "While the CHE model offers invaluable insight into reaction thermodynamics, it does not describe the kinetic barriers that govern reaction rates. To probe kinetics, we must calculate the activation energy by locating the transition state on the potential energy surface. This exercise introduces the Nudged Elastic Band (NEB) method, a cornerstone algorithm for mapping the minimum energy path and identifying the saddle point corresponding to the transition state, providing a crucial link between theoretical models and experimentally observed kinetics .",
            "id": "4252075",
            "problem": "You are asked to design and implement a numerical algorithm that approximates the minimum energy path for the Water Nucleophilic Attack (WNA) step in the Oxygen Evolution Reaction (OER) on a single adsorbed oxygen site, using a simplified surrogate potential energy surface and the Nudged Elastic Band (NEB) method with a climbing image modification. Your implementation must be a complete, runnable program that constructs the initial and final states, interpolates images, applies appropriate constraints to represent the fixed surface, and iteratively relaxes the image chain to locate the saddle point and barrier height. All energies must be expressed in electronvolts (eV) and all distances in angstroms (Å). The final barrier energies must be printed in eV as floats rounded to three decimal places.\n\nFoundational base to be used:\n- The Born–Oppenheimer approximation states that electronic and nuclear motions can be separated, enabling the description of nuclear positions evolving on a potential energy surface.\n- On a potential energy surface, the minimum energy path between two minima is the path that minimizes the action under fixed endpoints and passes through a first-order saddle point.\n- In transition-state theory (TST), the activation barrier is the energy difference between the saddle point and the initial state minimum.\n\nPhysical model and states:\n- Consider a two-dimensional reaction coordinate $(x,y)$ for the attacking water oxygen relative to a fixed adsorbed oxygen site on a rigid surface. The coordinate $x$ represents the surface-normal separation between the water oxygen and the adsorbed oxygen, and $y$ represents a lateral displacement. The surface atoms are fixed and not explicitly represented; constraints will ensure no movement of the surface and optionally freeze $y$.\n- Define the scalar potential energy surface $E(x,y)$ in eV as the sum of a bond-forming term along $x$ and a lateral harmonic term along $y$. This surrogate reflects the exergonic nature of O–O bond formation and a localized barrier near the transition state.\n- Initial state: water oxygen far from the surface oxygen with $(x_{\\mathrm{i}},y_{\\mathrm{i}}) = (3.00\\,\\mathrm{\\AA}, 0.00\\,\\mathrm{\\AA})$.\n- Final state: O–O bond formed with $(x_{\\mathrm{f}},y_{\\mathrm{f}}) = (1.35\\,\\mathrm{\\AA}, 0.00\\,\\mathrm{\\AA})$.\n\nAlgorithmic requirements:\n- Construct a chain of $N$ images that includes the fixed initial and final endpoints and $N-2$ intermediate images initialized by linear interpolation in $(x,y)$.\n- Implement the Nudged Elastic Band (NEB) relaxation using a spring constant $k_{\\mathrm{s}}$ and the climbing image modification to refine the highest-energy image into the saddle point. The endpoints are held fixed. The NEB must only include the component of the physical force perpendicular to the path and the spring force along the path.\n- Implement an optional constraint that freezes the lateral coordinate $y$ of all images to $0$ throughout the relaxation. When this constraint is active, only $x$ updates are allowed.\n- Iterate image positions until convergence to an approximate minimum energy path and saddle point, subject to a force tolerance and iteration cap.\n- Compute and report the activation barrier as the energy difference $E_{\\mathrm{barrier}} = E_{\\mathrm{max}} - E(x_{\\mathrm{i}},y_{\\mathrm{i}})$, where $E_{\\mathrm{max}}$ is the energy at the highest-energy image of the converged chain. Round the barrier energies to three decimal places and report in eV.\n\nNumerical surrogate potential:\n- Use the following surrogate for the surface-normal coordinate:\n  - A Morse-like bond formation term with depth $D$ and range parameter $a$ about an equilibrium bond length $r_0$: $E_{\\mathrm{Morse}}(x) = D \\left(1 - e^{-a (x - r_0)}\\right)^2$.\n  - A localized Gaussian barrier centered at $x_{\\mathrm{ts}}$ with width $\\sigma$: $E_{\\mathrm{G}}(x) = B \\exp\\left(-\\dfrac{(x - x_{\\mathrm{ts}})^2}{2\\sigma^2}\\right)$.\n  - A stabilization offset $-\\Delta E_{\\mathrm{form}}$ to make the final state exergonic relative to the initial.\n- The lateral harmonic term is $E_y(y) = \\dfrac{1}{2} k_y y^2$.\n- Total energy: $E(x,y) = E_{\\mathrm{Morse}}(x) + E_{\\mathrm{G}}(x) - \\Delta E_{\\mathrm{form}} + E_y(y)$.\n- Use physically reasonable constants: $D = 1.2\\,\\mathrm{eV}$, $a = 2.2\\,\\mathrm{\\AA}^{-1}$, $r_0 = 1.35\\,\\mathrm{\\AA}$, $B = 0.65\\,\\mathrm{eV}$, $x_{\\mathrm{ts}} = 2.00\\,\\mathrm{\\AA}$, $\\sigma = 0.20\\,\\mathrm{\\AA}$, $k_y = 0.50\\,\\mathrm{eV}/\\mathrm{\\AA}^2$, and $\\Delta E_{\\mathrm{form}} = 0.35\\,\\mathrm{eV}$.\n\nConvergence parameters:\n- Use a fixed step size for position updates and terminate when the maximum force magnitude on any intermediate image falls below a tolerance. If the climbing image is used, begin climbing after an initial period of NEB relaxation. You may choose reasonable numerical values for the step size, tolerance, and iteration cap that ensure convergence for the test suite below.\n\nTest suite:\nProvide barrier energies for the following five test cases, each specified as a tuple $(N, k_{\\mathrm{s}}, \\mathrm{freezeY})$ where $N$ is the total number of images, $k_{\\mathrm{s}}$ is the spring constant in $\\mathrm{eV}/\\mathrm{\\AA}^2$, and $\\mathrm{freezeY}$ is a boolean indicating whether the lateral coordinate $y$ is frozen:\n1. $(5, 5.0, \\mathrm{False})$ — general case with moderate images and springs, lateral relaxation allowed.\n2. $(7, 10.0, \\mathrm{False})$ — more images and stiffer springs, lateral relaxation allowed.\n3. $(3, 3.0, \\mathrm{True})$ — minimal number of images with weak springs, lateral coordinate frozen; tests endpoint-only path.\n4. $(8, 0.1, \\mathrm{False})$ — many images with very soft springs; tests path cohesion.\n5. $(6, 5.0, \\mathrm{True})$ — moderate images and springs, lateral coordinate frozen.\n\nRequired output format:\nYour program should produce a single line of output containing the barrier energies for the five test cases in eV, each rounded to three decimal places, as a comma-separated list enclosed in square brackets (e.g., \"[0.512,0.498,0.476,0.521,0.505]\"). No additional text should be printed.\n\nUnits:\n- Energies in electronvolts (eV).\n- Distances in angstroms (Å).\n- Angles are not used in this problem.",
            "solution": "This problem requires implementing the Nudged Elastic Band (NEB) method with a climbing image modification to find the minimum energy path (MEP) and activation barrier for a reaction on a surrogate 2D potential energy surface (PES).\n\n**1. Potential Energy Surface (PES) and Forces**\nThe system's energy $E(x,y)$ is defined by a specific mathematical function. The force on any image in the band is the negative gradient of this potential, $\\mathbf{F}_{\\mathrm{true}} = -\\nabla E(x,y)$. The provided Python code implements functions `potential_energy` and `analytical_force` to compute these values for any given coordinate $(x,y)$.\n\n**2. Nudged Elastic Band (NEB) Algorithm**\nThe core of the solution is the NEB algorithm, which finds the MEP by relaxing a chain of 'images' (discretized configurations) connecting the initial and final states.\n- **Initialization:** A chain of $N$ images is created by linear interpolation between the fixed initial state $\\mathbf{R}_{\\mathrm{initial}} = (3.00, 0.00)$ and final state $\\mathbf{R}_{\\mathrm{final}} = (1.35, 0.00)$.\n- **Force Projection:** For each intermediate image $\\mathbf{R}_i$, the total force is a sum of two projected components:\n    1.  **Perpendicular Force ($\\mathbf{F}_{i,\\perp}$):** The component of the true force $\\mathbf{F}_{\\mathrm{true},i}$ perpendicular to the path tangent $\\hat{\\mathbf{\\tau}}_i$. This component moves the image towards the true MEP without letting it slide along the path. It is calculated as $\\mathbf{F}_{i,\\perp} = \\mathbf{F}_{\\mathrm{true},i} - (\\mathbf{F}_{\\mathrm{true},i} \\cdot \\hat{\\mathbf{\\tau}}_i)\\hat{\\mathbf{\\tau}}_i$.\n    2.  **Parallel Spring Force ($\\mathbf{F}_{i,s}$):** A fictitious spring force that acts along the path tangent to maintain an even distribution of images. It is given by $\\mathbf{F}_{i,s} = k_s (|\\mathbf{R}_{i+1} - \\mathbf{R}_i| - |\\mathbf{R}_i - \\mathbf{R}_{i-1}|) \\hat{\\mathbf{\\tau}}_i$.\nThe total NEB force is $\\mathbf{F}^{\\mathrm{NEB}}_i = \\mathbf{F}_{i,\\perp} + \\mathbf{F}_{i,s}$.\n\n**3. Climbing Image (CI-NEB) Modification**\nTo accurately locate the saddle point (the maximum energy point along the MEP), the climbing image modification is used.\n- After a few initial relaxation steps, the image with the highest energy is identified as the 'climbing image'.\n- For this image, the force calculation is changed: the component of the true force parallel to the path is inverted. This drives the image uphill along the elastic band to converge exactly on the saddle point. The force is calculated as $\\mathbf{F}^{\\mathrm{CI}}_i = \\mathbf{F}_{\\mathrm{true},i} - 2(\\mathbf{F}_{\\mathrm{true},i} \\cdot \\hat{\\mathbf{\\tau}}_i)\\hat{\\mathbf{\\tau}}_i$.\n\n**4. Implementation and Execution**\nThe provided Python script `calculate_barrier_neb` implements this iterative procedure:\n- It initializes the images.\n- It enters a loop that continues until the maximum force on any intermediate image falls below a tolerance `force_tol`.\n- Inside the loop, it calculates forces for each image (using CI-NEB for the highest-energy image after `climb_start_iter` iterations) and updates the image positions using a simple gradient ascent step: $\\mathbf{R}_i \\leftarrow \\mathbf{R}_i + \\alpha \\mathbf{F}_i$.\n- The `freezeY` constraint is implemented by setting the y-component of the force to zero for all images if active.\n- After convergence, the activation barrier is calculated as the difference between the maximum energy found along the path and the energy of the initial state: $E_{\\mathrm{barrier}} = E_{\\mathrm{max}} - E_{\\mathrm{initial}}$.\n\nThe main `solve()` function iterates through the five test cases, calls `calculate_barrier_neb` for each with the specified parameters, and formats the resulting barrier energies for output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Physical model and constants\nCONSTS = {\n    # Morse potential parameters\n    'D': 1.2,       # eV\n    'a': 2.2,       # Å^-1\n    'r0': 1.35,     # Å\n    # Gaussian barrier parameters\n    'B': 0.65,      # eV\n    'xts': 2.00,    # Å\n    'sigma': 0.20,  # Å\n    # Lateral potential and energy offset\n    'ky': 0.50,     # eV/Å^2\n    'DE_form': 0.35 # eV\n}\n\n# Initial and final states\nR_INITIAL = np.array([3.00, 0.00]) # Å\nR_FINAL = np.array([1.35, 0.00])   # Å\n\ndef potential_energy(pos):\n    \"\"\"Calculates the potential energy E(x,y) at a given position.\"\"\"\n    x, y = pos\n    \n    # Morse potential term\n    E_morse = CONSTS['D'] * (1 - np.exp(-CONSTS['a'] * (x - CONSTS['r0'])))**2\n    \n    # Gaussian barrier term\n    E_gauss = CONSTS['B'] * np.exp(-(x - CONSTS['xts'])**2 / (2 * CONSTS['sigma']**2))\n    \n    # Lateral harmonic term\n    E_y = 0.5 * CONSTS['ky'] * y**2\n    \n    # Total energy\n    E_total = E_morse + E_gauss - CONSTS['DE_form'] + E_y\n    return E_total\n\ndef analytical_force(pos):\n    \"\"\"Calculates the analytical force F = -grad(E) at a given position.\"\"\"\n    x, y = pos\n\n    # Gradient component for x-coordinate\n    term1_morse = 2 * CONSTS['a'] * CONSTS['D'] * (\n        np.exp(-CONSTS['a'] * (x - CONSTS['r0'])) - \n        np.exp(-2 * CONSTS['a'] * (x - CONSTS['r0']))\n    )\n    term2_gauss = -CONSTS['B'] * (x - CONSTS['xts']) / CONSTS['sigma']**2 * \\\n                  np.exp(-(x - CONSTS['xts'])**2 / (2 * CONSTS['sigma']**2))\n    \n    dEdx = term1_morse + term2_gauss\n    \n    # Gradient component for y-coordinate\n    dEdy = CONSTS['ky'] * y\n    \n    # Force is the negative gradient\n    return -np.array([dEdx, dEdy])\n\ndef calculate_barrier_neb(N, k_s, freezeY):\n    \"\"\"\n    Performs a Nudged Elastic Band calculation with climbing image modification.\n\n    Args:\n        N (int): Total number of images in the band.\n        k_s (float): Spring constant in eV/Å^2.\n        freezeY (bool): If True, freezes the y-coordinate.\n\n    Returns:\n        float: The calculated activation barrier in eV.\n    \"\"\"\n    # Convergence parameters\n    step_size = 0.01        # Step size for gradient ascent (alpha)\n    force_tol = 1e-4        # Convergence tolerance in eV/Å\n    max_iter = 5000         # Maximum number of iterations\n    climb_start_iter = 100  # Iteration to start climbing\n\n    # 1. Initialize the band of images by linear interpolation\n    images = np.zeros((N, 2))\n    for i in range(N):\n        images[i] = R_INITIAL + i * (R_FINAL - R_INITIAL) / (N - 1)\n\n    # Main optimization loop\n    for iteration in range(max_iter):\n        # 2. Calculate energies for all images\n        energies = np.array([potential_energy(img) for img in images])\n\n        # 3. Identify the climbing image (highest energy image, excluding endpoints)\n        is_climbing = iteration >= climb_start_iter\n        if is_climbing:\n            # Find index of max energy among movable images\n            climb_idx = np.argmax(energies[1:-1]) + 1\n        else:\n            climb_idx = -1 # Sentinel for not climbing\n\n        # 4. Calculate forces on intermediate images\n        total_forces = np.zeros((N, 2))\n        for i in range(1, N - 1):\n            # a. Calculate the path tangent\n            tangent = images[i+1] - images[i-1]\n            tangent_norm = np.linalg.norm(tangent)\n            if tangent_norm > 1e-9:\n                tangent /= tangent_norm\n            else:\n                # Fallback if images are collinear and overlapping\n                tangent = np.array([1.0, 0.0])\n\n            # b. Calculate the true force from the potential\n            F_true = analytical_force(images[i])\n\n            # c. Calculate NEB or Climbing Image force\n            if i == climb_idx:\n                # Climbing image force: invert parallel component\n                F_parallel_mag = np.dot(F_true, tangent)\n                F_total = F_true - 2 * F_parallel_mag * tangent\n            else:\n                # Standard NEB force\n                # Perpendicular component of true force\n                F_perp = F_true - np.dot(F_true, tangent) * tangent\n                # Parallel spring force\n                d_plus = np.linalg.norm(images[i+1] - images[i])\n                d_minus = np.linalg.norm(images[i] - images[i-1])\n                F_spring = k_s * (d_plus - d_minus) * tangent\n                F_total = F_perp + F_spring\n            \n            total_forces[i] = F_total\n\n        if freezeY:\n            total_forces[:, 1] = 0.0\n\n        # 5. Update image positions (simple gradient ascent)\n        images[1:-1] += step_size * total_forces[1:-1]\n\n        # 6. Check for convergence\n        max_force = np.max(np.linalg.norm(total_forces[1:-1], axis=1))\n        if max_force < force_tol:\n            break\n\n    # 7. Recalculate final energies and compute the barrier\n    final_energies = np.array([potential_energy(img) for img in images])\n    E_max = np.max(final_energies)\n    E_initial = final_energies[0]\n    barrier = E_max - E_initial\n    \n    return barrier\n\ndef solve():\n    \"\"\"\n    Runs the NEB calculation for all test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        (5, 5.0, False),  # Case 1\n        (7, 10.0, False), # Case 2\n        (3, 3.0, True),   # Case 3\n        (8, 0.1, False),  # Case 4\n        (6, 5.0, True),   # Case 5\n    ]\n\n    results = []\n    for N, k_s, freezeY in test_cases:\n        barrier = calculate_barrier_neb(N=N, k_s=k_s, freezeY=freezeY)\n        results.append(barrier)\n\n    # Format the results to three decimal places and print\n    formatted_results = [f\"{res:.3f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}