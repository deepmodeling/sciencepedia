{
    "hands_on_practices": [
        {
            "introduction": "在进行任何动态电池模拟之前，确保模型从一个物理上一致的静止状态出发是至关重要的。本练习  旨在引导您运用单颗粒模型的基本原理，推导电池在静息状态（即零电流 $I(t)=0$）下的特性。通过这个过程，您将确定初始浓度分布 $c_s(r,0)$ 和过电势 $\\eta(0)$，从而加深对宏观平衡与微观状态变量之间内在联系的理解。",
            "id": "4258880",
            "problem": "考虑一个用于锂离子电池正负极的单颗粒模型。设正负极球形活性颗粒中的固相锂浓度分别表示为 $c_{s,p}(r,t)$ 和 $c_{s,n}(r,t)$，其中 $r$ 是径向坐标，$t$ 是时间。体积平均固相浓度为 $\\bar{c}_{s,p}(t)$ 和 $\\bar{c}_{s,n}(t)$，相应的化学计量数定义为 $\\theta_{p}(t) = \\bar{c}_{s,p}(t)/c_{s,\\max,p}$ 和 $\\theta_{n}(t) = \\bar{c}_{s,n}(t)/c_{s,\\max,n}$，其中 $c_{s,\\max,p}$ 和 $c_{s,\\max,n}$ 分别是正负极颗粒中的最大位点浓度。正负极的界面过电势分别为 $\\eta_{p}(t)$ 和 $\\eta_{n}(t)$。\n\n假设在时间 $t=0$ 时，有以下符合物理实际的参数：\n- 正极最大浓度 $c_{s,\\max,p} = 2.5 \\times 10^{4}$ $\\mathrm{mol}\\ \\mathrm{m}^{-3}$。\n- 负极最大浓度 $c_{s,\\max,n} = 3.1 \\times 10^{4}$ $\\mathrm{mol}\\ \\mathrm{m}^{-3}$。\n- 初始化学计量数 $\\theta_{p}(0) = 0.55$ 和 $\\theta_{n}(0) = 0.80$。\n- 颗粒半径 $R_{p} = 2.0 \\times 10^{-6}$ $\\mathrm{m}$ 和 $R_{n} = 5.0 \\times 10^{-6}$ $\\mathrm{m}$。\n- 温度 $T$ 是恒定且有限的，在 $t=0$ 时交换电流密度是有限且非零的，电解质和固相欧姆电阻是有限的。\n\n已知外部施加的电流满足 $I(0) = 0$，测得的电池电压满足 $V(0) = U_{p}(\\theta_{p}(0)) - U_{n}(\\theta_{n}(0))$，其中 $U_{p}(\\cdot)$ 和 $U_{n}(\\cdot)$ 分别表示作为化学计量数函数的正负极开路平衡电势。\n\n使用适用于单颗粒模型的第一性原理（固相中的球形扩散、零界面摩尔通量下的无通量边界条件，以及界面处的标准电荷转移动力学），构建与 $I(0) = 0$ 和 $V(0) = U_{p}(\\theta_{p}(0)) - U_{n}(\\theta_{n}(0))$ 严格一致的初始条件。具体来说，确定：\n- 在 $0 \\le r \\le R_{p}$ 和 $0 \\le r \\le R_{n}$ 范围内的初始固相浓度场 $c_{s,p}(r,0)$ 和 $c_{s,n}(r,0)$。\n- 相应的体积平均浓度 $\\bar{c}_{s,p}(0)$ 和 $\\bar{c}_{s,n}(0)$。\n- 界面过电势 $\\eta_{p}(0)$ 和 $\\eta_{n}(0)$。\n\n以有序行矩阵 $\\big[c_{s,p}(r,0),\\ c_{s,n}(r,0),\\ \\bar{c}_{s,p}(0),\\ \\bar{c}_{s,n}(0),\\ \\eta_{p}(0),\\ \\eta_{n}(0)\\big]$ 的形式提供最终答案。浓度单位为 $\\mathrm{mol}\\ \\mathrm{m}^{-3}$，过电势单位为伏特。最终答案中的所有数值四舍五入至四位有效数字。",
            "solution": "该问题要求解在时间 $t=0$ 时锂离子电池单颗粒模型的初始条件，给定外部施加电流为零，$I(0)=0$，且电池电压处于其开路值，$V(0) = U_{p}(\\theta_{p}(0)) - U_{n}(\\theta_{n}(0))$。这些条件表明，在 $t=0$ 时，电池处于电化学平衡状态。我们将从该平衡状态的物理含义中推导出所求各量的值。\n\n首先，我们确定固相浓度分布，$c_{s,p}(r,0)$ 和 $c_{s,n}(r,0)$。\n球形活性材料颗粒内部的锂传输由球坐标系下的菲克第二扩散定律控制：\n$$ \\frac{\\partial c_s(r,t)}{\\partial t} = \\frac{1}{r^2}\\frac{\\partial}{\\partial r}\\left( D_s r^2 \\frac{\\partial c_s(r,t)}{\\partial r} \\right) $$\n其中 $D_s$ 是固相扩散系数。边界条件是：\n1.  颗粒中心（$r=0$）的对称性：$\\frac{\\partial c_s}{\\partial r}\\Big|_{r=0} = 0$。\n2.  颗粒表面（$r=R$）的通量：$-D_s \\frac{\\partial c_s}{\\partial r}\\Big|_{r=R} = j_n(t)$，其中 $j_n(t)$ 是穿过固-电解质界面的锂离子摩尔通量。\n\n总施加电流 $I(t)$ 与在电极面积上积分的总界面通量成正比。在单颗粒模型的背景下，零施加电流 $I(0)=0$ 意味着在 $t=0$ 时，两个电极的颗粒表面的局部摩尔通量均为零。即，$j_{n,p}(0)=0$ 和 $j_{n,n}(0)=0$。\n\n将此应用于表面边界条件，对于正负极颗粒均有：\n$$ \\frac{\\partial c_s}{\\partial r}\\Big|_{r=R} = 0 \\quad \\text{at } t=0 $$\n一个由扩散方程描述且在所有边界（$r=0$ 和 $r=R$）上都满足无通量条件的系统，只有在浓度分布空间均匀时才能处于稳态。任何存在的梯度都会引起扩散通量，使系统向均匀状态弛豫。由于系统在 $t=0$ 时处于平衡状态，因此不能有内部通量，这意味着不存在浓度梯度。因此，浓度分布必须是平坦的：\n$$ \\frac{\\partial c_s(r,0)}{\\partial r} = 0 \\quad \\text{for } 0 \\le r \\le R $$\n这意味着在每个电极颗粒中，初始浓度相对于径向位置 $r$ 是一个常数。设这些常数为 $C_p$ 和 $C_n$，则 $c_{s,p}(r,0) = C_p$ 且 $c_{s,n}(r,0) = C_n$。\n\n接下来，我们将这些均匀的浓度分布与给定的体积平均化学计量数联系起来。体积平均浓度 $\\bar{c}_{s}(t)$ 定义为：\n$$ \\bar{c}_{s}(t) = \\frac{\\int_0^R c_s(r,t) 4\\pi r^2 dr}{\\int_0^R 4\\pi r^2 dr} = \\frac{3}{R^3} \\int_0^R c_s(r,t) r^2 dr $$\n如果 $c_s(r,0)$ 是一个常数，比如 $C$，那么平均浓度为：\n$$ \\bar{c}_{s}(0) = \\frac{3}{R^3} \\int_0^R C r^2 dr = \\frac{3C}{R^3} \\left[ \\frac{r^3}{3} \\right]_0^R = C $$\n因此，每个颗粒中的初始均匀浓度等于初始体积平均浓度。我们可以根据给定的初始化学计量数 $\\theta_{p}(0)$ 和 $\\theta_{n}(0)$ 来计算这些值：\n$$ \\bar{c}_{s,p}(0) = \\theta_{p}(0) \\times c_{s,\\max,p} = 0.55 \\times (2.5 \\times 10^4 \\ \\mathrm{mol}\\ \\mathrm{m}^{-3}) = 13750 \\ \\mathrm{mol}\\ \\mathrm{m}^{-3} $$\n$$ \\bar{c}_{s,n}(0) = \\theta_{n}(0) \\times c_{s,\\max,n} = 0.80 \\times (3.1 \\times 10^4 \\ \\mathrm{mol}\\ \\mathrm{m}^{-3}) = 24800 \\ \\mathrm{mol}\\ \\mathrm{m}^{-3} $$\n因此，我们有：\n$c_{s,p}(r,0) = \\bar{c}_{s,p}(0) = 1.375 \\times 10^4 \\ \\mathrm{mol}\\ \\mathrm{m}^{-3}$。\n$c_{s,n}(r,0) = \\bar{c}_{s,n}(0) = 2.480 \\times 10^4 \\ \\mathrm{mol}\\ \\mathrm{m}^{-3}$。\n根据最终答案的要求，这些值表示为四位有效数字。\n\n现在，我们确定初始界面过电势 $\\eta_p(0)$ 和 $\\eta_n(0)$。颗粒-电解质界面处的电荷转移反应由过电势 $\\eta$ 驱动。该关系由描述局部电流密度 $i_{loc}$ 的巴特勒-沃尔默（Butler-Volmer）方程给出，该电流密度与摩尔通量 $j_n$ 成正比：\n$$ i_{loc} = F j_n = i_0 \\left( \\exp\\left(\\frac{\\alpha_a F \\eta}{RT}\\right) - \\exp\\left(-\\frac{\\alpha_c F \\eta}{RT}\\right) \\right) $$\n这里，$F$ 是法拉第常数，$R$ 是气体常数，$T$ 是温度，$\\alpha_a$ 和 $\\alpha_c$ 是转移系数，$i_0$ 是交换电流密度。已知在 $t=0$ 时，温度 $T$ 是有限的，交换电流密度 $i_{0,p}$ 和 $i_{0,n}$ 是有限且非零的。\n如前所述，$I(0)=0$ 意味着 $j_n(0)=0$，这又意味着两个电极的 $i_{loc}(0)=0$。巴特勒-沃尔默方程变为：\n$$ 0 = i_0 \\left( \\exp\\left(\\frac{\\alpha_a F \\eta(0)}{RT}\\right) - \\exp\\left(-\\frac{\\alpha_c F \\eta(0)}{RT}\\right) \\right) $$\n由于 $i_0 \\ne 0$，括号中的项必须为零：\n$$ \\exp\\left(\\frac{\\alpha_a F \\eta(0)}{RT}\\right) = \\exp\\left(-\\frac{\\alpha_c F \\eta(0)}{RT}\\right) $$\n这个等式成立的充要条件是指数相等。假设 $\\alpha_a + \\alpha_c \\ne 0$（这总是成立的，通常 $\\alpha_a + \\alpha_c = 1$），这就要求过电势为零。\n因此，对于两个电极：\n$$ \\eta_p(0) = 0 \\ \\mathrm{V} $$\n$$ \\eta_n(0) = 0 \\ \\mathrm{V} $$\n\n最后，我们检查与给定电池电压的一致性。单颗粒模型中电池电压的通用表达式为：\n$$ V(t) = U_p(c_{s,p,surf}(t)) - U_n(c_{s,n,surf}(t)) + \\eta_p(t) - \\eta_n(t) $$\n在 $t=0$ 时，我们已经发现 $\\eta_p(0)=0$ 和 $\\eta_n(0)=0$。此外，由于浓度分布是均匀的，表面浓度等于平均浓度：$c_{s,p,surf}(0) = \\bar{c}_{s,p}(0)$ 和 $c_{s,n,surf}(0) = \\bar{c}_{s,n}(0)$。因此，作为表面化学计量数函数的平衡电势，可以使用平均化学计量数来评估：$U_p(c_{s,p,surf}(0)) = U_p(\\theta_p(0))$ 和 $U_n(c_{s,n,surf}(0)) = U_n(\\theta_n(0))$。\n将这些代入 $t=0$ 时的电压方程，得到：\n$$ V(0) = U_p(\\theta_p(0)) - U_n(\\theta_n(0)) + 0 - 0 = U_p(\\theta_p(0)) - U_n(\\theta_n(0)) $$\n这与问题陈述中提供的初始条件相符，证实了我们推导出的初始状态是正确且一致的。所提供的颗粒半径 $R_p$ 和 $R_n$ 对于本次计算不是必需的，但它们是 $I(t) \\ne 0$ 的瞬态模拟中的基本参数。\n\n所求的初始条件是：\n- $c_{s,p}(r,0) = 1.375 \\times 10^4 \\ \\mathrm{mol}\\ \\mathrm{m}^{-3}$\n- $c_{s,n}(r,0) = 2.480 \\times 10^4 \\ \\mathrm{mol}\\ \\mathrm{m}^{-3}$\n- $\\bar{c}_{s,p}(0) = 1.375 \\times 10^4 \\ \\mathrm{mol}\\ \\mathrm{m}^{-3}$\n- $\\bar{c}_{s,n}(0) = 2.480 \\times 10^4 \\ \\mathrm{mol}\\ \\mathrm{m}^{-3}$\n- $\\eta_p(0) = 0 \\ \\mathrm{V}$\n- $\\eta_n(0) = 0 \\ \\mathrm{V}$\n\n我们将这些值组合成指定的行矩阵。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1.375 \\times 10^{4}  2.480 \\times 10^{4}  1.375 \\times 10^{4}  2.480 \\times 10^{4}  0  0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "从理论转向计算，一个数值模型只有在遵循基础物理定律（如质量守恒）时才是有用的。本实践  是一个编程练习，它通过对比两种不同的数值方案来求解球形扩散方程 $\\frac{\\partial c_s}{\\partial t} = \\nabla \\cdot (D_s \\nabla c_s)$。您将发现，一个简化的方案可能无法保证质量守恒，而一个“守恒的”有限体积法对于精确、长时的模拟至关重要，这有助于培养您对数值方法保真度的批判性思维。",
            "id": "4258857",
            "problem": "考虑球形活性材料颗粒中嵌入的单颗粒模型（SPM），该模型受球对称下的菲克扩散控制。其基本原理包括菲克第一定律和物质连续性方程。在球对称中，设 $c_s(r,t)$ 表示固相锂浓度，单位为 $\\mathrm{mol}/\\mathrm{m}^3$，$D_s$ 表示固相扩散系数，单位为 $\\mathrm{m}^2/\\mathrm{s}$，$r$ 表示径向坐标，单位为 $\\mathrm{m}$，其中 $0 \\le r \\le R$，$t$ 表示时间，单位为 $\\mathrm{s}$。控制方程是菲克定律下的物质连续性方程，在球坐标系下写作\n$$\\frac{\\partial c_s}{\\partial t} = \\frac{D_s}{r^2}\\frac{\\partial}{\\partial r}\\left(r^2 \\frac{\\partial c_s}{\\partial r}\\right), \\quad 0  r  R, \\quad t > 0.$$\n边界条件为中心对称，\n$$\\frac{\\partial c_s}{\\partial r}\\bigg|_{r=0} = 0,$$\n以及在颗粒半径处施加的表面摩尔通量，\n$$-D_s \\frac{\\partial c_s}{\\partial r}\\bigg|_{r=R} = j(t),$$\n其中 $j(t)$ 的单位为 $\\mathrm{mol}/(\\mathrm{m}^2\\cdot\\mathrm{s})$，定义为从固体向外为正。\n\n定义颗粒内的总锂摩尔数为\n$$m(t) = \\int_0^R c_s(r,t)\\,4\\pi r^2\\,dr.$$\n根据基本定律，$m(t)$ 的精确连续演化必须满足\n$$\\frac{d m(t)}{dt} = -4\\pi R^2\\,j(t).$$\n在数值离散化中，对球坐标拉普拉斯算子采用朴素的逐点有限差分可能会因通量的非守恒处理而违反这种精确的质量守恒，特别是在 $r=0$ 和 $r=R$ 附近。\n\n您的任务是编写一个完整的、可运行的程序，该程序：\n- 在均匀径向网格上实现两种显式时间推进离散化方法：\n  1. 一种朴素的中心有限差分格式，用于球坐标拉普拉斯算子 $\\frac{\\partial^2 c_s}{\\partial r^2} + \\frac{2}{r}\\frac{\\partial c_s}{\\partial r}$，在径向节点上进行评估，通过虚拟单元强制执行 $\\frac{\\partial c_s}{\\partial r}\\big|_{r=0}=0$，并通过一个虚拟单元在 $r=R$ 处施加诺伊曼边界条件，该虚拟单元使用一阶差分在边界面上强制执行 $-D_s \\frac{\\partial c_s}{\\partial r}\\big|_{r=R} = j(t)$。此格式更新逐点值 $c_s(r_i,t)$。\n  2. 一种守恒的有限体积格式，该格式演化球壳上的单元平均值 $\\bar{c}_i(t)$，球壳的界面位于 $r_{f,i}$，中心位于 $r_i$。它使用跨界面的通量 $F_{i+1/2}(t)$，对于内部界面，通量通过 $F_{i+1/2}(t) = -D_s\\,A_{i+1/2}\\,\\frac{\\bar{c}_{i+1}-\\bar{c}_i}{\\Delta r}$ 计算；在 $r=0$ 处，$F_{1/2}(t)=0$；在 $r=R$ 处，$F_{N+1/2}(t)=A_R\\,j(t)$，其中 $A_{i+1/2}=4\\pi r_{f,i+1/2}^2$，$A_R=4\\pi R^2$。通过以下公式更新单元平均值：\n  $$\\bar{c}_i^{n+1} = \\bar{c}_i^n + \\Delta t \\frac{F_{i-1/2}^n - F_{i+1/2}^n}{V_i},$$\n  其中 $V_i = \\frac{4\\pi}{3}\\left(r_{f,i+1/2}^3 - r_{f,i-1/2}^3\\right)$ 是球壳体积。\n- 对每种格式，通过球壳体积加权和计算最终时间 $T$ 的数值总摩尔数 $m_{\\text{num}}(T)$，\n  $$m_{\\text{num}}(T) \\approx \\sum_i \\bar{c}_i(T)\\,V_i,$$\n  两种格式使用相同的球壳体积 $V_i$（为积分目的，在朴素格式中将点值视为球壳平均值的近似）。\n- 使用在仿真过程中 $j(t)$ 的离散时间积分来计算由施加通量引起的精确质量变化，\n  $$m_{\\text{exact}}(T) = m(0) - 4\\pi R^2 \\sum_{n} j(t_n)\\,\\Delta t.$$\n- 报告每个格式在 $t=T$ 时的绝对质量守恒误差，\n  $$e_{\\text{naive}} = \\left|m_{\\text{num,naive}}(T) - m_{\\text{exact}}(T)\\right|, \\quad e_{\\text{cons}} = \\left|m_{\\text{num,cons}}(T) - m_{\\text{exact}}(T)\\right|.$$\n\n使用以下科学上真实的测试套件。所有物理单位必须严格遵守规定。\n\n- 测试用例 1（一般情况，中等分辨率）：\n  - 颗粒半径 $R = 5\\times 10^{-6}\\ \\mathrm{m}$。\n  - 扩散系数 $D_s = 1\\times 10^{-13}\\ \\mathrm{m}^2/\\mathrm{s}$。\n  - 径向控制体积数 $N = 21$。\n  - 时间步长 $\\Delta t = 1\\times 10^{-3}\\ \\mathrm{s}$。\n  - 最终时间 $T = 0.2\\ \\mathrm{s}$。\n  - 初始浓度 $c_s(r,0) = c_0 = 2.0\\times 10^{4}\\ \\mathrm{mol}/\\mathrm{m}^3$ （均匀）。\n  - 施加通量 $j(t) = j_0$ （恒定），其中 $j_0 = 1.0\\times 10^{-5}\\ \\mathrm{mol}/(\\mathrm{m}^2\\cdot\\mathrm{s})$。\n\n- 测试用例 2（边缘情况，粗糙空间分辨率）：\n  - 颗粒半径 $R = 5\\times 10^{-6}\\ \\mathrm{m}$。\n  - 扩散系数 $D_s = 1\\times 10^{-13}\\ \\mathrm{m}^2/\\mathrm{s}$。\n  - 径向控制体积数 $N = 5$。\n  - 时间步长 $\\Delta t = 2\\times 10^{-3}\\ \\mathrm{s}$。\n  - 最终时间 $T = 0.2\\ \\mathrm{s}$。\n  - 初始浓度 $c_s(r,0) = c_0 = 2.0\\times 10^{4}\\ \\mathrm{mol}/\\mathrm{m}^3$ （均匀）。\n  - 施加通量 $j(t) = j_0$ （恒定），其中 $j_0 = 1.0\\times 10^{-5}\\ \\mathrm{mol}/(\\mathrm{m}^2\\cdot\\mathrm{s})$。\n\n- 测试用例 3（时变通量，在整数个周期内净值为零）：\n  - 颗粒半径 $R = 5\\times 10^{-6}\\ \\mathrm{m}$。\n  - 扩散系数 $D_s = 1\\times 10^{-13}\\ \\mathrm{m}^2/\\mathrm{s}$。\n  - 径向控制体积数 $N = 21$。\n  - 时间步长 $\\Delta t = 5\\times 10^{-4}\\ \\mathrm{s}$。\n  - 最终时间 $T = 0.2\\ \\mathrm{s}$。\n  - 初始浓度 $c_s(r,0) = c_0 = 2.0\\times 10^{4}\\ \\mathrm{mol}/\\mathrm{m}^3$ （均匀）。\n  - 施加通量 $j(t) = j_0 \\sin\\left(2\\pi t / \\tau\\right)$，其中 $j_0 = 1.0\\times 10^{-5}\\ \\mathrm{mol}/(\\mathrm{m}^2\\cdot\\mathrm{s})$ 且 $\\tau = 5.0\\times 10^{-2}\\ \\mathrm{s}$。\n\n您的程序必须：\n- 对两种格式均使用显式欧拉时间积分器，在由界面 $r_{f,i} = i \\Delta r$（$i = 0,1,\\dots,N$），$\\Delta r = R/N$，和单元中心 $r_i = (r_{f,i} + r_{f,i+1})/2$ 定义的均匀径向网格上进行计算。\n- 对于朴素格式，在与守恒格式相同的 $r_i$ 处处理点值，并通过对 $\\frac{\\partial^2 c_s}{\\partial r^2}$ 和 $\\frac{2}{r}\\frac{\\partial c_s}{\\partial r}$ 的离散近似来计算球坐标拉普拉斯算子，使用虚拟值来实施边界条件。\n- 将所有测试用例的结果汇总到一行输出中，其中包含 6 个浮点误差 $[e_{\\text{naive},1},e_{\\text{cons},1},e_{\\text{naive},2},e_{\\text{cons},2},e_{\\text{naive},3},e_{\\text{cons},3}]$，形式为逗号分隔的列表并用方括号括起来。所有误差均以 $\\mathrm{mol}$ 为单位，表示为十进制浮点数。\n\n程序必须完全自包含，不需要用户输入，并遵守指定的单位和输出格式。",
            "solution": "我们从扩散和质量守恒的基本定律开始。菲克第一定律指出，摩尔通量密度为 $\\mathbf{N} = -D_s \\nabla c_s$，物质连续性方程为 $\\frac{\\partial c_s}{\\partial t} + \\nabla \\cdot \\mathbf{N} = 0$。在球对称下，球坐标系中的散度简化为\n$$\\nabla \\cdot \\mathbf{N} = \\frac{1}{r^2}\\frac{\\partial}{\\partial r}\\left(r^2 N_r\\right) = \\frac{1}{r^2}\\frac{\\partial}{\\partial r}\\left(-D_s r^2 \\frac{\\partial c_s}{\\partial r}\\right),$$\n因此，控制偏微分方程为\n$$\\frac{\\partial c_s}{\\partial t} = \\frac{D_s}{r^2}\\frac{\\partial}{\\partial r}\\left(r^2 \\frac{\\partial c_s}{\\partial r}\\right), \\quad 0  r  R.$$\n在中心处，对称性意味着 $\\frac{\\partial c_s}{\\partial r}\\big|_{r=0} = 0$。在表面处，诺伊曼边界条件将向外的摩尔通量与梯度关联起来，$-D_s \\frac{\\partial c_s}{\\partial r}\\big|_{r=R} = j(t)$。\n\n定义颗粒中的总摩尔数：\n$$m(t) = \\int_0^R c_s(r,t)\\,4\\pi r^2\\,dr.$$\n对时间求导并代入控制方程：\n$$\\frac{d m}{dt} = \\int_0^R \\frac{\\partial c_s}{\\partial t}\\,4\\pi r^2\\,dr = \\int_0^R 4\\pi D_s \\frac{\\partial}{\\partial r}\\left(r^2 \\frac{\\partial c_s}{\\partial r}\\right)\\,dr.$$\n根据微积分基本定理，\n$$\\frac{d m}{dt} = 4\\pi D_s \\left[r^2 \\frac{\\partial c_s}{\\partial r}\\right]_{r=0}^{r=R}.$$\n使用中心对称条件 $r^2 \\frac{\\partial c_s}{\\partial r}\\big|_{r=0} = 0$ 和表面通量条件 $-D_s \\frac{\\partial c_s}{\\partial r}\\big|_{r=R} = j(t)$，我们得到了精确的质量守恒：\n$$\\frac{d m}{dt} = -4\\pi R^2 j(t).$$\n该恒等式以积分形式表达了质量守恒，并表明内部扩散会重新分布浓度，但不会改变总质量；只有施加的表面通量会改变 $m(t)$。\n\n对球坐标拉普拉斯算子的朴素离散化使用逐点有限差分来计算 $\\frac{\\partial^2 c_s}{\\partial r^2}$ 和 $(2/r)\\frac{\\partial c_s}{\\partial r}$：\n$$\\left.\\frac{\\partial^2 c_s}{\\partial r^2}\\right|_{r=r_i} \\approx \\frac{c_{i+1} - 2 c_i + c_{i-1}}{\\Delta r^2}, \\quad \\left.\\frac{\\partial c_s}{\\partial r}\\right|_{r=r_i} \\approx \\frac{c_{i+1} - c_{i-1}}{2 \\Delta r},$$\n其中 $r_i$ 是均匀间隔的，$\\Delta r = R/N$，并使用虚拟节点来施加 $\\frac{\\partial c_s}{\\partial r}\\big|_{r=0}=0$ 和 $-D_s \\frac{\\partial c_s}{\\partial r}\\big|_{r=R}=j(t)$。每个点的显式欧拉更新为\n$$c_i^{n+1} = c_i^n + \\Delta t\\,D_s\\left(\\frac{c_{i+1}^n - 2 c_i^n + c_{i-1}^n}{\\Delta r^2} + \\frac{2}{r_i}\\frac{c_{i+1}^n - c_{i-1}^n}{2\\Delta r}\\right),$$\n其中包含适当的虚拟值。虽然在连续极限下，这种“朴素的”逐点方法对微分方程是一致的，但它不能确保球壳体积加权和 $\\sum_i c_i^n V_i$ 的演化与施加的边界通量步调一致，因为离散算子不是以控制体积界面通量的散度形式构建的。具体来说，当将 $D_s\\left(\\frac{c_{i+1}-2c_i+c_{i-1}}{\\Delta r^2} + \\frac{2}{r_i}\\frac{c_{i+1}-c_{i-1}}{2\\Delta r}\\right)$ 按球壳体积 $V_i$ 加权求和时，这些项不能对消以得到乘以 $4\\pi R^2$ 的净边界通量。这会产生一个随时间累积的离散质量守恒误差，尤其是在空间网格较粗或在 $r=0$ 附近粗略处理 $(2/r)$ 项时。\n\n基于原理的修正是通过有限体积法以通量形式对守恒定律进行离散化。将颗粒划分为 $N$ 个球壳，界面位于 $r_{f,i} = i\\Delta r$（$i=0,1,\\dots,N$），中心位于 $r_i = (r_{f,i} + r_{f,i+1})/2$。定义球壳体积 $V_i = \\frac{4\\pi}{3}\\left(r_{f,i+1}^3 - r_{f,i}^3\\right)$ 和界面面积 $A_{i+1/2} = 4\\pi r_{f,i+1}^2$。单元平均浓度 $\\bar{c}_i$ 的有限体积更新使用界面通量的离散散度：\n$$\\bar{c}_i^{n+1} = \\bar{c}_i^n + \\Delta t\\,\\frac{F_i^n - F_{i+1}^n}{V_i},$$\n其中 $F_j^n$ 是在时间步 $n$ 穿过界面 $j$ 的向外摩尔通量。对于内部界面 $j=1,2,\\dots,N-1$，我们使用中心梯度，\n$$F_j^n = -D_s\\,A_j\\,\\frac{\\bar{c}_{i+1}^n - \\bar{c}_i^n}{\\Delta r},$$\n其中 $i=j-1$ 且 $A_j = 4\\pi r_{f,j}^2$。在最内侧界面，对称性要求 $F_0^n = 0$（或等效地 $A_0 = 0$）。在最外侧界面，施加的边界条件规定 $F_N^n = A_R\\,j(t_n)$，其中 $A_R = 4\\pi R^2$。对所有球壳的更新求和得到\n$$\\sum_i V_i \\left(\\bar{c}_i^{n+1} - \\bar{c}_i^n\\right) = \\Delta t \\sum_i \\left(F_i^n - F_{i+1}^n\\right) = \\Delta t\\left(F_0^n - F_N^n\\right) = -\\Delta t\\,A_R\\,j(t_n),$$\n其求和项可以精确对消。因此，离散总质量 $m^n = \\sum_i \\bar{c}_i^n V_i$ 遵循\n$$m^{n+1} - m^n = -\\Delta t\\,A_R\\,j(t_n),$$\n累加后得到\n$$m^{N_t} = m^0 - A_R \\sum_{n=0}^{N_t-1} j(t_n)\\,\\Delta t,$$\n与从基本定律推导出的精确积分关系相匹配，误差在机器精度范围内。\n\n算法设计：\n- 对两种格式使用均匀网格，以便直接比较，并使用相同的球壳体积 $V_i$ 来近似两种格式的积分 $\\int_0^R c_s(r,t)\\,4\\pi r^2\\,dr$。\n- 实现带虚拟节点的朴素中心有限差分更新：\n  - 在 $r=0$ 处，通过镜像虚拟值 $c_{-1} = c_0$ 施加 $\\frac{\\partial c_s}{\\partial r}=0$。\n  - 在 $r=R$ 处，通过虚拟值 $c_{N} = c_{N-1} - \\frac{j(t)\\Delta r}{D_s}$ 施加 $-D_s \\frac{\\partial c_s}{\\partial r}=j(t)$，近似 $\\frac{\\partial c_s}{\\partial r}\\big|_{r=R} \\approx \\frac{c_N - c_{N-1}}{\\Delta r}$。\n  - 在每个中心点 $r_i$ 使用 $D_s\\left(\\frac{c_{i+1}-2c_i+c_{i-1}}{\\Delta r^2} + \\frac{2}{r_i}\\frac{c_{i+1}-c_{i-1}}{2\\Delta r}\\right)$ 更新 $c_i$。\n- 实现使用界面通量 $F_j$ 的守恒有限体积更新，如前所述；在内部界面使用中心梯度，在 $r=0$ 处设 $F_0=0$，在 $r=R$ 处设 $F_N=A_R\\,j(t)$。\n- 使用指定的 $\\Delta t$ 和 $T$ 进行显式欧拉时间积分，通过 $\\sum_n j(t_n)\\Delta t$ 计算 $j(t)$ 的离散时间积分，以形成 $m_{\\text{exact}}(T)=m(0) - A_R \\sum_n j(t_n)\\Delta t$。\n- 对于每个测试用例，计算误差度量 $e_{\\text{naive}}$ 和 $e_{\\text{cons}}$，即 $m_{\\text{num}}(T)$ 和 $m_{\\text{exact}}(T)$ 之间的绝对差值，单位为 $\\mathrm{mol}$。\n\n测试套件涵盖：\n- 一个具有中等分辨率和恒定通量的一般情况，以显示朴素格式的质量误差累积与守恒格式的精确守恒。\n- 一个具有粗糙分辨率的边缘情况，其中朴素格式的违规被放大，表明其对空间离散化的敏感性。\n- 一个在整数周期内净质量变化为零的时变通量，突显出守恒格式产生接近零的误差，而朴素格式可能发生漂移。\n\n最终输出必须是包含三种情况下六个误差的单行，格式为 $[e_{\\text{naive},1},e_{\\text{cons},1},e_{\\text{naive},2},e_{\\text{cons},2},e_{\\text{naive},3},e_{\\text{cons},3}]$，每个值都以 $\\mathrm{mol}$ 为单位，表示为十进制浮点数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef make_geometry(R, N):\n    \"\"\"\n    Construct uniform spherical shell geometry:\n    - Faces at r_f[i] = i*dr, i=0..N\n    - Centers at r_c[i] = (r_f[i] + r_f[i+1])/2, i=0..N-1\n    - Volumes V_i = 4/3*pi*(r_f[i+1]^3 - r_f[i]^3)\n    - Face areas A_j = 4*pi*r_f[j]^2\n    \"\"\"\n    dr = R / N\n    r_f = np.linspace(0.0, R, N + 1)                        # face radii\n    r_c = 0.5 * (r_f[:-1] + r_f[1:])                        # cell centers\n    V = (4.0 * np.pi / 3.0) * (r_f[1:]**3 - r_f[:-1]**3)    # shell volumes\n    A_faces = 4.0 * np.pi * r_f**2                          # face areas\n    A_R = A_faces[-1]\n    return dr, r_f, r_c, V, A_faces, A_R\n\ndef simulate_naive(R, D, N, dt, T, c0, j_func):\n    \"\"\"\n    Naive centered finite difference on spherical Laplacian:\n    c_t = D*(c_rr + (2/r)*c_r)\n    Points located at centers r_c.\n    Ghosts:\n      - at r=0: c_-1 = c_0 to enforce dc/dr=0\n      - at r=R: enforce -D * (c_N - c_{N-1})/dr = j(t) - c_N = c_{N-1} - (j*dr)/D\n    \"\"\"\n    dr, r_f, r_c, V, A_faces, A_R = make_geometry(R, N)\n    c = np.full(N, c0, dtype=float)\n    steps = int(round(T / dt))\n    # Accumulate discrete integral of j(t)\n    j_int = 0.0\n    for n in range(steps):\n        t = n * dt\n        j = j_func(t)\n        # Build ghost values\n        c_left_ghost = c[0]  # dc/dr=0 at r=0 - mirrored\n        c_right_ghost = c[-1] - (j * dr) / D  # enforce boundary flux at r=R\n        # Prepare next state\n        c_new = c.copy()\n        # Update loop\n        for i in range(N):\n            # Neighbors including ghosts\n            if i == 0:\n                c_im1 = c_left_ghost\n                c_ip1 = c[i+1]\n            elif i == N - 1:\n                c_im1 = c[i-1]\n                c_ip1 = c_right_ghost\n            else:\n                c_im1 = c[i-1]\n                c_ip1 = c[i+1]\n            # Center radius; avoid division by zero by using r_c[i] (strictly  0)\n            ri = r_c[i]\n            # Second derivative and first derivative approximations\n            d2c = (c_ip1 - 2.0*c[i] + c_im1) / (dr**2)\n            dcdr = (c_ip1 - c_im1) / (2.0*dr)\n            rhs = D * (d2c + (2.0/ri) * dcdr)\n            c_new[i] = c[i] + dt * rhs\n        c = c_new\n        j_int += j * dt\n    # Compute numerical total moles using shell volumes V\n    m_num = float(np.dot(c, V))\n    # Compute exact mass change from boundary flux integral\n    m0 = c0 * (4.0 * np.pi / 3.0) * (R**3)  # initial total moles\n    m_exact = m0 - A_R * j_int\n    err = abs(m_num - m_exact)\n    return err\n\ndef simulate_fv(R, D, N, dt, T, c0, j_func):\n    \"\"\"\n    Conservative finite volume scheme:\n    c_i^{n+1} = c_i^n + dt * (F_i - F_{i+1}) / V_i\n    Fluxes:\n      F_0 = 0 (symmetry)\n      F_j = -D * A_j * (c_{i+1} - c_i) / dr, j=1..N-1\n      F_N = A_R * j(t)\n    \"\"\"\n    dr, r_f, r_c, V, A_faces, A_R = make_geometry(R, N)\n    c = np.full(N, c0, dtype=float)\n    steps = int(round(T / dt))\n    j_int = 0.0\n    for n in range(steps):\n        t = n * dt\n        j = j_func(t)\n        # Compute face fluxes\n        F = np.zeros(N + 1, dtype=float)\n        F[0] = 0.0  # symmetry at center\n        # Interior faces\n        # Using centered gradient between cell centers across face j\n        # Here, r_c spacing equals dr for uniform mesh\n        for j_idx in range(1, N):\n            i_left = j_idx - 1\n            i_right = j_idx\n            grad = (c[i_right] - c[i_left]) / dr\n            F[j_idx] = -D * A_faces[j_idx] * grad\n        # Outer face imposed flux\n        F[N] = A_R * j\n        # Update concentrations\n        c += dt * (F[:-1] - F[1:]) / V\n        j_int += j * dt\n    m_num = float(np.dot(c, V))\n    m0 = c0 * (4.0 * np.pi / 3.0) * (R**3)\n    m_exact = m0 - A_R * j_int\n    err = abs(m_num - m_exact)\n    return err\n\ndef solve():\n    # Define test cases per problem statement\n    # Each case: (R, D, N, dt, T, c0, j_type, params)\n    def j_const(j0):\n        return lambda t: j0\n    def j_sine(j0, tau):\n        return lambda t: j0 * np.sin(2.0 * np.pi * t / tau)\n\n    test_cases = [\n        # Test 1: general case, constant flux\n        (5.0e-6, 1.0e-13, 21, 1.0e-3, 0.2, 2.0e4, 'const', {'j0': 1.0e-5}),\n        # Test 2: coarse resolution, constant flux\n        (5.0e-6, 1.0e-13, 5, 2.0e-3, 0.2, 2.0e4, 'const', {'j0': 1.0e-5}),\n        # Test 3: time-varying flux over integer periods\n        (5.0e-6, 1.0e-13, 21, 5.0e-4, 0.2, 2.0e4, 'sine', {'j0': 1.0e-5, 'tau': 5.0e-2}),\n    ]\n\n    results = []\n    for (R, D, N, dt, T, c0, j_type, params) in test_cases:\n        if j_type == 'const':\n            j_func = j_const(params['j0'])\n        elif j_type == 'sine':\n            j_func = j_sine(params['j0'], params['tau'])\n        else:\n            # Should not happen; default to zero flux\n            j_func = lambda t: 0.0\n\n        err_naive = simulate_naive(R, D, N, dt, T, c0, j_func)\n        err_cons = simulate_fv(R, D, N, dt, T, c0, j_func)\n        results.append(err_naive)\n        results.append(err_cons)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}