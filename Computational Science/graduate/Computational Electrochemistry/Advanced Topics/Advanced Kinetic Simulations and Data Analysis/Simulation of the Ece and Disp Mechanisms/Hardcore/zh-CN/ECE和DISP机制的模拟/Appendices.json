{
    "hands_on_practices": [
        {
            "introduction": "本练习是您将电化学理论付诸实践的核心。我们将模拟一个ECE和DISP机理相互竞争的完整动力学过程，这能让您深入理解不同反应路径如何影响最终产物分布。通过将基于Butler-Volmer和质量作用定律的反应网络转化为常微分方程组(ODEs)，并对其进行数值求解，您将学会如何预测在循环伏安扫描下各物质浓度随时间的变化 。",
            "id": "4258366",
            "problem": "给定一个电化学体系中竞争性机理路径的模型：电化学–化学–电化学（ECE）和歧化（DISP）。在薄层电极近似下，假设浓度在空间上是均匀的，并将电化学步骤表示为有效的准一级体相反应，其速率常数依赖于电位，由 Butler-Volmer 关系确定。您的任务是编写一个完整、可运行的程序，模拟在三角波电位扫描期间由 ECE 与 DISP 产生的物种的产物随时间分布，并为每个测试用例输出所需产物的最终分数（以小数值表示）。\n\n从以下基本原理出发：质量守恒、质量作用定律和 Butler-Volmer 关系。考虑物种 $A$ 经历以下序列和竞争：\n- 第一个电化学步骤：$A + e^- \\rightleftharpoons B$，\n- 化学步骤：$B \\rightarrow C$，\n- 第二个电化学步骤：$C + e^- \\rightleftharpoons D$，\n- 歧化（DISP）：$2B \\rightarrow A + C$。\n\n假设薄层电极的厚度足够小，以至于浓度的空间梯度可以忽略不计。使用有效的均相一级速率常数 $k_{1,f}(E)$、$k_{1,b}(E)$ 表示第一步电化学反应，使用 $k_{2,f}(E)$、$k_{2,b}(E)$ 表示第二步，其中 $E$ 是外加电位。对每个电子转移步骤使用 Butler-Volmer 形式：\n$$\nk_{i,f}(E) = k_{0,i}\\,\\exp\\!\\left(-\\alpha_i \\frac{F\\,(E - E_{0,i})}{R\\,T}\\right),\\qquad\nk_{i,b}(E) = k_{0,i}\\,\\exp\\!\\left((1-\\alpha_i) \\frac{F\\,(E - E_{0,i})}{R\\,T}\\right),\n$$\n其中 $i \\in \\{1,2\\}$ 索引第一和第二个电子转移步骤，$k_{0,i}$ 是单位为 $\\mathrm{s}^{-1}$ 的有效标准速率常数，$E_{0,i}$ 是单位为 $\\mathrm{V}$ 的标准电位，$\\alpha_i$ 是转移系数（无量纲），$F$ 是单位为 $\\mathrm{C\\,mol^{-1}}$ 的法拉第常数，$R$ 是单位为 $\\mathrm{J\\,mol^{-1}\\,K^{-1}}$ 的理想气体常数，$T$ 是单位为 $\\mathrm{K}$ 的绝对温度。化学步骤是一级反应，速率常数为 $k_c$（单位 $\\mathrm{s}^{-1}$），歧化反应是二级反应，速率常数为 $k_{\\mathrm{disp}}$（单位 $\\mathrm{m^3\\,mol^{-1}\\,s^{-1}}$）。\n\n设体相浓度为 $c_A(t)$、$c_B(t)$、$c_C(t)$、$c_D(t)$，单位为 $\\mathrm{mol\\,m^{-3}}$。在质量作用假设和上述化学计量下，控制常微分方程组为：\n$$\n\\frac{d c_A}{d t} = -k_{1,f}(E(t))\\,c_A + k_{1,b}(E(t))\\,c_B + k_{\\mathrm{disp}}\\,c_B^2,\n$$\n$$\n\\frac{d c_B}{d t} = k_{1,f}(E(t))\\,c_A - k_{1,b}(E(t))\\,c_B - k_c\\,c_B - 2\\,k_{\\mathrm{disp}}\\,c_B^2,\n$$\n$$\n\\frac{d c_C}{d t} = k_c\\,c_B + k_{\\mathrm{disp}}\\,c_B^2 - k_{2,f}(E(t))\\,c_C + k_{2,b}(E(t))\\,c_D,\n$$\n$$\n\\frac{d c_D}{d t} = k_{2,f}(E(t))\\,c_C - k_{2,b}(E(t))\\,c_D.\n$$\n\n使用由起始电位 $E_{\\mathrm{start}}$（单位 $\\mathrm{V}$）、顶点电位 $E_{\\mathrm{vertex}}$（单位 $\\mathrm{V}$）、终止电位 $E_{\\mathrm{end}}$（单位 $\\mathrm{V}$）和扫描速率 $\\nu$（单位 $\\mathrm{V\\,s^{-1}}$）定义的三角波电位程序。电位 $E(t)$ 以速率 $\\nu$ 从 $E_{\\mathrm{start}}$ 线性增减至 $E_{\\mathrm{vertex}}$，然后反转，以相同的速率 $\\nu$ 从 $E_{\\mathrm{vertex}}$ 线性扫描至 $E_{\\mathrm{end}}$。因此，\n$$\nt_1 = \\frac{|E_{\\mathrm{vertex}} - E_{\\mathrm{start}}|}{\\nu},\\quad\nt_2 = \\frac{|E_{\\mathrm{end}} - E_{\\mathrm{vertex}}|}{\\nu},\\quad\nT_{\\mathrm{end}} = t_1 + t_2,\n$$\n并且\n$$\nE(t) = \\begin{cases}\nE_{\\mathrm{start}} + \\mathrm{sgn}(E_{\\mathrm{vertex}} - E_{\\mathrm{start}})\\,\\nu\\,t, & 0 \\le t \\le t_1 \\\\\nE_{\\mathrm{vertex}} + \\mathrm{sgn}(E_{\\mathrm{end}} - E_{\\mathrm{vertex}})\\,\\nu\\,(t - t_1), & t_1 < t \\le T_{\\mathrm{end}}\n\\end{cases}\n$$\n\n初始条件为 $c_A(0) = c_{A,0}$（单位 $\\mathrm{mol\\,m^{-3}}$）和 $c_B(0) = c_C(0) = c_D(0) = 0$。使用 $F = 96485\\,\\mathrm{C\\,mol^{-1}}$，$R = 8.314\\,\\mathrm{J\\,mol^{-1}\\,K^{-1}}$ 和 $T = 298\\,\\mathrm{K}$。对于每个测试用例，模拟直到 $t = T_{\\mathrm{end}}$ 并报告目标产物 $D$ 的最终分数，\n$$\nf_D = \\frac{c_D(T_{\\mathrm{end}})}{c_A(T_{\\mathrm{end}}) + c_B(T_{\\mathrm{end}}) + c_C(T_{\\mathrm{end}}) + c_D(T_{\\mathrm{end}})},\n$$\n该分数为一个四舍五入到六位小数的小数（无量纲）。目标是通过调整 $E(t)$（通过 $E_{\\mathrm{start}}$、$E_{\\mathrm{vertex}}$、$E_{\\mathrm{end}}$）和扫描速率 $\\nu$ 来找到使 $f_D$ 最大化的条件。\n\n您的程序必须实现一个适用于刚性系统的数值稳定积分器，并且不得需要任何外部输入。它必须遍历以下测试用例集，其中所有量均以国际单位制给出：\n\n- 测试用例 1（ECE主导基准）：\n  - $c_{A,0} = 1.0\\,\\mathrm{mol\\,m^{-3}}$，\n  - $E_{\\mathrm{start}} = 0.0\\,\\mathrm{V}$，$E_{\\mathrm{vertex}} = -1.2\\,\\mathrm{V}$，$E_{\\mathrm{end}} = 0.0\\,\\mathrm{V}$，\n  - $\\nu = 0.1\\,\\mathrm{V\\,s^{-1}}$，\n  - $E_{0,1} = -0.2\\,\\mathrm{V}$，$E_{0,2} = -0.8\\,\\mathrm{V}$，\n  - $k_{0,1} = 5.0\\,\\mathrm{s^{-1}}$，$k_{0,2} = 5.0\\,\\mathrm{s^{-1}}$，\n  - $\\alpha_1 = 0.5$，$\\alpha_2 = 0.5$，\n  - $k_c = 2.0\\,\\mathrm{s^{-1}}$，\n  - $k_{\\mathrm{disp}} = 0.01\\,\\mathrm{m^3\\,mol^{-1}\\,s^{-1}}$。\n\n- 测试用例 2（DISP主导竞争）：\n  - $c_{A,0} = 1.0\\,\\mathrm{mol\\,m^{-3}}$，\n  - $E_{\\mathrm{start}} = 0.0\\,\\mathrm{V}$，$E_{\\mathrm{vertex}} = -1.2\\,\\mathrm{V}$，$E_{\\mathrm{end}} = 0.0\\,\\mathrm{V}$，\n  - $\\nu = 0.1\\,\\mathrm{V\\,s^{-1}}$，\n  - $E_{0,1} = -0.2\\,\\mathrm{V}$，$E_{0,2} = -0.8\\,\\mathrm{V}$，\n  - $k_{0,1} = 5.0\\,\\mathrm{s^{-1}}$，$k_{0,2} = 5.0\\,\\mathrm{s^{-1}}$，\n  - $\\alpha_1 = 0.5$，$\\alpha_2 = 0.5$，\n  - $k_c = 0.1\\,\\mathrm{s^{-1}}$，\n  - $k_{\\mathrm{disp}} = 0.5\\,\\mathrm{m^3\\,mol^{-1}\\,s^{-1}}$。\n\n- 测试用例 3（非常快的扫描速率）：\n  - $c_{A,0} = 1.0\\,\\mathrm{mol\\,m^{-3}}$，\n  - $E_{\\mathrm{start}} = 0.0\\,\\mathrm{V}$，$E_{\\mathrm{vertex}} = -1.2\\,\\mathrm{V}$，$E_{\\mathrm{end}} = 0.0\\,\\mathrm{V}$，\n  - $\\nu = 10.0\\,\\mathrm{V\\,s^{-1}}$，\n  - $E_{0,1} = -0.2\\,\\mathrm{V}$，$E_{0,2} = -0.8\\,\\mathrm{V}$，\n  - $k_{0,1} = 5.0\\,\\mathrm{s^{-1}}$，$k_{0,2} = 5.0\\,\\mathrm{s^{-1}}$，\n  - $\\alpha_1 = 0.5$，$\\alpha_2 = 0.5$，\n  - $k_c = 2.0\\,\\mathrm{s^{-1}}$，\n  - $k_{\\mathrm{disp}} = 0.01\\,\\mathrm{m^3\\,mol^{-1}\\,s^{-1}}$。\n\n- 测试用例 4（第二次还原的电位窗口不完整）：\n  - $c_{A,0} = 1.0\\,\\mathrm{mol\\,m^{-3}}$，\n  - $E_{\\mathrm{start}} = 0.0\\,\\mathrm{V}$，$E_{\\mathrm{vertex}} = -0.5\\,\\mathrm{V}$，$E_{\\mathrm{end}} = 0.0\\,\\mathrm{V}$，\n  - $\\nu = 0.1\\,\\mathrm{V\\,s^{-1}}$，\n  - $E_{0,1} = -0.2\\,\\mathrm{V}$，$E_{0,2} = -0.8\\,\\mathrm{V}$，\n  - $k_{0,1} = 5.0\\,\\mathrm{s^{-1}}$，$k_{0,2} = 5.0\\,\\mathrm{s^{-1}}$，\n  - $\\alpha_1 = 0.5$，$\\alpha_2 = 0.5$，\n  - $k_c = 2.0\\,\\mathrm{s^{-1}}$，\n  - $k_{\\mathrm{disp}} = 0.01\\,\\mathrm{m^3\\,mol^{-1}\\,s^{-1}}$。\n\n- 测试用例 5（无歧化，纯ECE）：\n  - $c_{A,0} = 1.0\\,\\mathrm{mol\\,m^{-3}}$，\n  - $E_{\\mathrm{start}} = 0.0\\,\\mathrm{V}$，$E_{\\mathrm{vertex}} = -1.2\\,\\mathrm{V}$，$E_{\\mathrm{end}} = 0.0\\,\\mathrm{V}$，\n  - $\\nu = 0.1\\,\\mathrm{V\\,s^{-1}}$，\n  - $E_{0,1} = -0.2\\,\\mathrm{V}$，$E_{0,2} = -0.8\\,\\mathrm{V}$，\n  - $k_{0,1} = 5.0\\,\\mathrm{s^{-1}}$，$k_{0,2} = 5.0\\,\\mathrm{s^{-1}}$，\n  - $\\alpha_1 = 0.5$，$\\alpha_2 = 0.5$，\n  - $k_c = 2.0\\,\\mathrm{s^{-1}}$，\n  - $k_{\\mathrm{disp}} = 0.0\\,\\mathrm{m^3\\,mol^{-1}\\,s^{-1}}$。\n\n角度单位不适用。物理单位已在上面指定，必须遵守。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$[0.123456,0.654321,0.000001]$），其中每个条目是按给定顺序对应测试用例的四舍五入后的小数 $f_D$。",
            "solution": "用户提供的问题是计算电化学领域一个定义明确的初值问题，适合进行数值模拟。它在科学上是合理的、自洽的且客观的。不存在矛盾、歧义或事实不正确之处。因此，我将提供完整的解决方案。\n\n该问题要求模拟一个包含电化学步骤和均相化学步骤的耦合化学反应系统。涉及的物种是 $A$、$B$、$C$ 和 $D$。反应网络如下：\n1. 第一个电化学步骤：$A + e^- \\rightleftharpoons B$\n2. 化学步骤（ECE路径）：$B \\rightarrow C$\n3. 第二个电化学步骤（ECE路径）：$C + e^- \\rightleftharpoons D$\n4. 歧化（DISP路径）：$2B \\rightarrow A + C$\n\n该系统在薄层近似下建模，这意味着所有浓度 $c_A(t)$、$c_B(t)$、$c_C(t)$ 和 $c_D(t)$ 在空间上是均匀的，仅依赖于时间 $t$。这些浓度的动力学由质量作用定律控制，从而得到一个由四个耦合常微分方程（ODE）组成的系统。设 $\\vec{y}(t) = [c_A(t), c_B(t), c_C(t), c_D(t)]^T$。该系统可以写成向量形式 $\\frac{d\\vec{y}}{dt} = \\vec{f}(t, \\vec{y})$。$\\vec{f}$ 的分量由反应的化学计量推导得出：\n$$\n\\frac{d c_A}{d t} = -k_{1,f}(E(t))\\,c_A + k_{1,b}(E(t))\\,c_B + k_{\\mathrm{disp}}\\,c_B^2\n$$\n$$\n\\frac{d c_B}{d t} = k_{1,f}(E(t))\\,c_A - k_{1,b}(E(t))\\,c_B - k_c\\,c_B - 2\\,k_{\\mathrm{disp}}\\,c_B^2\n$$\n$$\n\\frac{d c_C}{d t} = k_c\\,c_B + k_{\\mathrm{disp}}\\,c_B^2 - k_{2,f}(E(t))\\,c_C + k_{2,b}(E(t))\\,c_D\n$$\n$$\n\\frac{d c_D}{d t} = k_{2,f}(E(t))\\,c_C - k_{2,b}(E(t))\\,c_D\n$$\n由于二级歧化项 $k_{\\mathrm{disp}}\\,c_B^2$ 的存在，这些ODE是耦合且非线性的。\n\n电化学步骤的速率常数 $k_{i,f}$ 和 $k_{i,b}$（对于 $i \\in \\{1,2\\}$）依赖于外加电极电位 $E$，而 $E$ 本身是时间 $t$ 的函数，即 $E(t)$。这种依赖关系由 Butler-Volmer 方程描述：\n$$\nk_{i,f}(E) = k_{0,i}\\,\\exp\\!\\left(-\\alpha_i \\frac{F\\,(E - E_{0,i})}{R\\,T}\\right)\n$$\n$$\nk_{i,b}(E) = k_{0,i}\\,\\exp\\!\\left((1-\\alpha_i) \\frac{F\\,(E - E_{0,i})}{R\\,T}\\right)\n$$\n在这里，$k_{0,i}$ 是标准非均相速率常数（在薄层模型下单位为 $\\mathrm{s^{-1}}$），$\\alpha_i$ 是电荷转移系数，$E_{0,i}$ 是标准还原电位，$F$ 是法拉第常数，$R$ 是理想气体常数，$T$ 是温度。\n\n电位 $E(t)$ 遵循由起始电位 $E_{\\mathrm{start}}$、顶点电位 $E_{\\mathrm{vertex}}$、终止电位 $E_{\\mathrm{end}}$ 和恒定扫描速率 $\\nu$ 定义的三角波形。实验的总持续时间 $T_{\\mathrm{end}}$ 是正向扫描时间（$t_1$）和反向扫描时间（$t_2$）之和。函数 $E(t)$ 是分段线性的。\n\n该反应系统的一个关键特性是核心物种总摩尔数的守恒。将四个ODE相加得到：\n$$\n\\frac{d}{dt}(c_A + c_B + c_C + c_D) = 0\n$$\n这表明总浓度 $C_{\\mathrm{tot}} = c_A(t) + c_B(t) + c_C(t) + c_D(t)$ 是一个运动不变量。给定初始条件 $c_A(0) = c_{A,0}$ 和 $c_B(0)=c_C(0)=c_D(0)=0$，我们有 $C_{\\mathrm{tot}}(t) = c_{A,0}$ 对于所有 $t \\ge 0$。这简化了产物 $D$ 最终分数的计算：\n$$\nf_D = \\frac{c_D(T_{\\mathrm{end}})}{c_A(T_{\\mathrm{end}}) + c_B(T_{\\mathrm{end}}) + c_C(T_{\\mathrm{end}}) + c_D(T_{\\mathrm{end}})} = \\frac{c_D(T_{\\mathrm{end}})}{c_{A,0}}\n$$\n\n速率常数对电位的指数依赖性可能导致其在电位扫描过程中数值大小差异悬殊。这通常会导致一个“刚性”ODE系统，其中不同过程的时间尺度可能相差许多数量级。对于此类系统，标准的显式数值积分方法（如欧拉法或经典龙格-库塔法）计算效率低下，需要极小的时间步长来维持数值稳定性。因此，该问题正确地指明了需要一个适用于刚性系统的数值稳定积分器。\n\n我们的策略是使用标准科学库中的高质量数值ODE求解器。Python的SciPy库中的 `scipy.integrate.solve_ivp` 函数提供了几种高级求解器。我们将选择“BDF”（向后微分公式）方法，这是一种适用于刚性ODE的隐式多步法。\n\n算法如下：\n1. 定义所有物理常数（$F$、$R$、$T$）和每个测试用例的参数。\n2. 对每个测试用例，根据给定的扫描参数定义一个随时间变化的电位函数 $E(t)$。\n3. 实现一个函数，例如 `dydt(t, y, params)`，它接收当前时间 $t$、浓度状态向量 $\\vec{y}$ 和系统参数。该函数计算 $E(t)$，然后计算所有速率常数，并最终根据控制ODE返回导数向量 $\\frac{d\\vec{y}}{dt}$。\n4. 设置初始条件 $\\vec{y}(0) = [c_{A,0}, 0, 0, 0]^T$ 和积分时间区间 $[0, T_{\\mathrm{end}}]$。\n5. 使用“BDF”方法调用 `scipy.integrate.solve_ivp`，向其传递 `dydt` 函数、时间区间和初始条件。我们将使用适当小的相对和绝对容差（例如，分别为 $10^{-8}$ 和 $10^{-10}$）以确保高精度。\n6. 积分完成后，从求解器的输出中提取物种 $D$ 的最终浓度 $c_D(T_{\\mathrm{end}})$。\n7. 计算最终分数 $f_D = c_D(T_{\\mathrm{end}}) / c_{A,0}$。\n8. 将结果四舍五入到六位小数，并按指定格式输出。\n\n此过程将对所提供的五个测试用例中的每一个重复进行。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Simulates the ECE/DISP mechanism for a series of test cases and\n    calculates the final fraction of product D.\n    \"\"\"\n    # Define physical constants\n    F = 96485.0  # Faraday constant in C/mol\n    R = 8.314   # Ideal gas constant in J/(mol*K)\n    T = 298.0   # Temperature in K\n    FRT = F / (R * T)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (ECE-favorable baseline)\n        {\n            'cA0': 1.0, 'E_start': 0.0, 'E_vertex': -1.2, 'E_end': 0.0,\n            'nu': 0.1, 'E01': -0.2, 'E02': -0.8, 'k01': 5.0, 'k02': 5.0,\n            'alpha1': 0.5, 'alpha2': 0.5, 'kc': 2.0, 'k_disp': 0.01\n        },\n        # Test case 2 (DISP-dominant competition)\n        {\n            'cA0': 1.0, 'E_start': 0.0, 'E_vertex': -1.2, 'E_end': 0.0,\n            'nu': 0.1, 'E01': -0.2, 'E02': -0.8, 'k01': 5.0, 'k02': 5.0,\n            'alpha1': 0.5, 'alpha2': 0.5, 'kc': 0.1, 'k_disp': 0.5\n        },\n        # Test case 3 (very fast scan rate)\n        {\n            'cA0': 1.0, 'E_start': 0.0, 'E_vertex': -1.2, 'E_end': 0.0,\n            'nu': 10.0, 'E01': -0.2, 'E02': -0.8, 'k01': 5.0, 'k02': 5.0,\n            'alpha1': 0.5, 'alpha2': 0.5, 'kc': 2.0, 'k_disp': 0.01\n        },\n        # Test case 4 (incomplete potential window)\n        {\n            'cA0': 1.0, 'E_start': 0.0, 'E_vertex': -0.5, 'E_end': 0.0,\n            'nu': 0.1, 'E01': -0.2, 'E02': -0.8, 'k01': 5.0, 'k02': 5.0,\n            'alpha1': 0.5, 'alpha2': 0.5, 'kc': 2.0, 'k_disp': 0.01\n        },\n        # Test case 5 (no disproportionation, pure ECE)\n        {\n            'cA0': 1.0, 'E_start': 0.0, 'E_vertex': -1.2, 'E_end': 0.0,\n            'nu': 0.1, 'E01': -0.2, 'E02': -0.8, 'k01': 5.0, 'k02': 5.0,\n            'alpha1': 0.5, 'alpha2': 0.5, 'kc': 2.0, 'k_disp': 0.0\n        }\n    ]\n\n    results = []\n    _FRT = FRT  # Local alias for performance in the inner loop\n\n    for params in test_cases:\n        # Calculate timing for the potential scan\n        t1 = abs(params['E_vertex'] - params['E_start']) / params['nu']\n        t2 = abs(params['E_end'] - params['E_vertex']) / params['nu']\n        T_end = t1 + t2\n\n        sign1 = np.sign(params['E_vertex'] - params['E_start'])\n        sign2 = np.sign(params['E_end'] - params['E_vertex'])\n\n        def potential_E(t):\n            \"\"\"Calculates the potential E at a given time t.\"\"\"\n            if t = t1:\n                return params['E_start'] + sign1 * params['nu'] * t\n            else:\n                return params['E_vertex'] + sign2 * params['nu'] * (t - t1)\n\n        def dydt(t, y, p):\n            \"\"\"\n            Defines the system of ordinary differential equations.\n            y = [cA, cB, cC, cD]\n            \"\"\"\n            cA, cB, cC, cD = y\n\n            # Get potential at time t\n            E = potential_E(t)\n\n            # Calculate potential-dependent rate constants (Butler-Volmer)\n            E_minus_E01 = E - p['E01']\n            E_minus_E02 = E - p['E02']\n            \n            k1f = p['k01'] * np.exp(-p['alpha1'] * _FRT * E_minus_E01)\n            k1b = p['k01'] * np.exp((1 - p['alpha1']) * _FRT * E_minus_E01)\n            k2f = p['k02'] * np.exp(-p['alpha2'] * _FRT * E_minus_E02)\n            k2b = p['k02'] * np.exp((1 - p['alpha2']) * _FRT * E_minus_E02)\n\n            # System of ODEs\n            dcAdt = -k1f * cA + k1b * cB + p['k_disp'] * cB**2\n            dcBdt = k1f * cA - k1b * cB - p['kc'] * cB - 2 * p['k_disp'] * cB**2\n            dcCdt = p['kc'] * cB + p['k_disp'] * cB**2 - k2f * cC + k2b * cD\n            dcDdt = k2f * cC - k2b * cD\n\n            return [dcAdt, dcBdt, dcCdt, dcDdt]\n\n        # Initial conditions\n        y0 = [params['cA0'], 0.0, 0.0, 0.0]\n\n        # Time span for integration\n        t_span = [0, T_end]\n\n        # Solve the stiff ODE system\n        sol = solve_ivp(\n            fun=dydt,\n            t_span=t_span,\n            y0=y0,\n            method='BDF',\n            args=(params,),\n            rtol=1e-8,\n            atol=1e-10\n        )\n\n        # Extract the final concentration of product D\n        cD_final = sol.y[3, -1]\n\n        # Calculate the final fraction f_D\n        # The total concentration is conserved, so the denominator is cA0.\n        fD = cD_final / params['cA0']\n        \n        # Format result to 6 decimal places and add to list\n        results.append(f\"{fD:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在完成核心模拟后，本练习将引导您解决一个关键的数值挑战：刚性(stiffness)问题。在电化学系统中，反应和扩散过程的时间尺度可能相差悬殊，这使得数值模拟变得不稳定或效率低下。通过分析系统雅可比矩阵($\\mathbf{J}$)的特征值来量化刚性指数，本练习将让您亲身体会为何必须使用专为刚性系统设计的求解器，以确保模拟结果的可靠性 。",
            "id": "4258386",
            "problem": "考虑一个在有限区间上的齐次狄利克雷边界条件的一维扩散-反应模型，该模型代表了位于 $x=0$ 的平面电极和位于 $x=L$ 的本体储库。其基本原理是菲克第二扩散定律和化学动力学的质量作用定律。假设物种 $B$ 进行扩散，扩散系数为 $D_B$，并参与歧化（DISP）反应 $2B \\rightarrow C$，二级速率常数为 $k_d$。在线条法（MOL）下，空间域被离散化为 $N$ 个内部点，均匀间距为 $\\Delta x = L/(N+1)$，从而得到一个关于节点浓度 $y_i(t) \\equiv C_B(x_i,t)$（其中 $i=1,\\dots,N$）的常微分方程组：\n$$\n\\frac{dy_i}{dt} = D_B \\frac{y_{i-1} - 2 y_i + y_{i+1}}{\\Delta x^2} - 2 k_d y_i^2,\n$$\n其中使用了标准的二阶差分格式，并通过排除边界节点来实现齐次狄利克雷条件 $C_B(0,t)=0$ 和 $C_B(L,t)=0$。\n\n在均匀稳态分布 $y_i = C_{B,0}$ 下评估的MOL系统的雅可比矩阵 $\\mathbf{J}$ 是离散化扩散算子和对角反应雅可比之和：\n$$\n\\mathbf{J} = \\frac{D_B}{\\Delta x^2} \\mathbf{L}_D - 4 k_d C_{B,0} \\mathbf{I},\n$$\n其中 $\\mathbf{L}_D$ 是一个 $N \\times N$ 的三对角矩阵，其对角线上为 $-2$，第一亚对角线和超对角线上为 $+1$，而 $\\mathbf{I}$ 是单位矩阵。对于 $D_B0$ 和 $k_d \\ge 0$，$\\mathbf{J}$ 的所有特征值都具有严格为负的实部。\n\n将系统在指定状态下的刚性指数 $\\kappa$ 定义为雅可比矩阵特征值实部最大与最小绝对值之比：\n$$\n\\kappa = \\frac{\\max_i \\left| \\Re(\\lambda_i) \\right|}{\\min_i \\left| \\Re(\\lambda_i) \\right|},\n$$\n其中 $\\lambda_i$ 是 $\\mathbf{J}$ 的特征值，$\\Re(\\cdot)$ 表示实部。对于线性化系统 $y'=\\mathbf{J}y$，如果时间步长满足以下条件，则前向欧拉显式格式是稳定的：\n$$\n\\Delta t_{\\mathrm{FE,max}} = \\frac{2}{\\rho(\\mathbf{J})},\n$$\n其中 $\\rho(\\mathbf{J}) = \\max_i \\left| \\Re(\\lambda_i) \\right|$ 是 $\\mathbf{J}$ 的谱半径（取实部）。同时定义特征扩散时间尺度：\n$$\nT_D = \\frac{L^2}{D_B}.\n$$\n一个较大的比率 $R = T_D / \\Delta t_{\\mathrm{FE,max}}$ 表明显式格式效率低下，并促使使用反向微分公式（BDF）方法，该方法对于低阶是A-稳定的，并且能稳健地处理刚性系统。作为对比，一个具有一级均相化学步骤 $B \\rightarrow C$（速率常数为 $k_c$）的电化学-化学-电化学（ECE）替代模型产生的雅可比矩阵为：\n$$\n\\mathbf{J}_{\\mathrm{ECE}} = \\frac{D_B}{\\Delta x^2} \\mathbf{L}_D - k_c \\mathbf{I},\n$$\n该矩阵缺少非线性的 $C_B^2$ 依赖项，并且通常表现出较低的刚性。\n\n实现一个完整的、可运行的程序，该程序：\n- 对于给定的 $N$ 和 $L$，构造 $\\mathbf{L}_D$，在均匀 $C_{B,0}$ 下为DISP情况组装 $\\mathbf{J}$，计算其特征值，并评估 $\\kappa$、$\\Delta t_{\\mathrm{FE,max}}$（单位为秒）和 $\\rho(\\mathbf{J})$（单位为 $\\mathrm{s}^{-1}$）。同时计算 $R = T_D / \\Delta t_{\\mathrm{FE,max}}$（无量纲）。\n- 可选地，为一个具有一级速率常数 $k_c$ 的测试用例组装 $\\mathbf{J}_{\\mathrm{ECE}}$（此情况下设置 $k_d=0$），并计算相同的度量指标，以与DISP的刚性进行对比。\n- 如果 $\\kappa  100$，则将一个案例分类为刚性。\n\n您的测试套件必须包括以下参数集，每个参数集均以国际单位制（SI）表示：\n1. DISP，“理想路径”：$N=50$, $L=10^{-5}\\ \\mathrm{m}$, $D_B=10^{-9}\\ \\mathrm{m}^2/\\mathrm{s}$, $k_d=10^{6}\\ \\mathrm{m}^3/(\\mathrm{mol}\\cdot\\mathrm{s})$, $C_{B,0}=10\\ \\mathrm{mol}/\\mathrm{m}^3$。\n2. DISP，扩散主导边缘情况：$N=50$, $L=10^{-5}\\ \\mathrm{m}$, $D_B=10^{-9}\\ \\mathrm{m}^2/\\mathrm{s}$, $k_d=10^{6}\\ \\mathrm{m}^3/(\\mathrm{mol}\\cdot\\mathrm{s})$, $C_{B,0}=10^{-6}\\ \\mathrm{mol}/\\mathrm{m}^3$。\n3. DISP，网格细化：$N=200$, $L=10^{-5}\\ \\mathrm{m}$, $D_B=10^{-9}\\ \\mathrm{m}^2/\\mathrm{s}$, $k_d=10^{6}\\ \\mathrm{m}^3/(\\mathrm{mol}\\cdot\\mathrm{s})$, $C_{B,0}=10\\ \\mathrm{mol}/\\mathrm{m}^3$。\n4. ECE替代模型，线性反应：$N=50$, $L=10^{-5}\\ \\mathrm{m}$, $D_B=10^{-9}\\ \\mathrm{m}^2/\\mathrm{s}$, $k_d=0$, $k_c=100\\ \\mathrm{s}^{-1}$。\n\n对于每个测试用例，您的程序必须按以下顺序输出四个值：$\\kappa$（无量纲）、$\\Delta t_{\\mathrm{FE,max}}$（单位为s）、$\\rho(\\mathbf{J})$（单位为$\\mathrm{s}^{-1}$），以及一个指示刚性（$\\kappa100$）的布尔值。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔结果列表（例如，$\\left[\\text{result1},\\text{result2},\\dots\\right]$）。数值必须使用指定的基本SI单位；允许使用布尔值。",
            "solution": "问题陈述已经过严格验证，被认为是科学上合理、适定且信息完备的。它提出了一个计算化学动力学和数值分析中的标准问题，使用了公认的原理和现实的物理参数。所有必需的信息均已提供，目标清晰明确。因此，我们可以着手提供一个完整的解决方案。\n\n问题的核心是分析由一维反应-扩散偏微分方程（PDE）的线条法（MOL）离散化所产生的常微分方程组（ODEs）的刚性。该刚性由系统雅可比矩阵 $\\mathbf{J}$ 的谱来表征。本分析将针对两种反应机理——歧化（DISP）和一级电化学-化学-电化学（ECE）替代模型——在不同的参数体系下进行。\n\n在均匀分布 $y_i = C_{B,0}$ 下评估的MOL系统的雅可比矩阵由下式给出：\n$$ \\mathbf{J} = \\frac{D_B}{\\Delta x^2} \\mathbf{L}_D - C \\cdot \\mathbf{I} $$\n其中 $D_B$ 是扩散系数，$\\Delta x = L/(N+1)$ 是空间网格间距（$L$ 是区域长度，$N$ 是内部网格点数），$\\mathbf{L}_D$ 是代表二阶中心差分扩散算子的 $N \\times N$ 三对角矩阵，$\\mathbf{I}$ 是 $N \\times N$ 单位矩阵。常数 $C$ 代表了线性化反应动力学的贡献。\n对于DISP机理 $2B \\rightarrow C$，ODE中的反应项是 $-2 k_d y_i^2$。其关于 $y_i$ 在 $y_i = C_{B,0}$ 处的导数是 $-4 k_d C_{B,0}$。因此，对于DISP，有 $C = 4 k_d C_{B,0}$。\n对于ECE替代机理 $B \\rightarrow C$，反应项是 $-k_c y_i$。其关于 $y_i$ 的导数是 $-k_c$。因此，对于ECE，有 $C = k_c$。\n\n雅可比矩阵 $\\mathbf{J}$ 的特征值决定了ODE系统的稳定性和刚性特性。由于矩阵 $\\mathbf{L}_D$ 和 $\\mathbf{I}$ 可交换，它们的和 $\\mathbf{J}$ 的特征值是它们各自特征值的和。对于具有齐次狄利克雷边界条件的 $N$ 点离散化，矩阵 $\\mathbf{L}_D$ 的特征值有解析解：\n$$ \\mu_j(\\mathbf{L}_D) = -4 \\sin^2\\left(\\frac{j\\pi}{2(N+1)}\\right), \\quad \\text{for } j=1, 2, \\dots, N $$\n因此，雅可比矩阵 $\\mathbf{J}$ 的特征值为：\n$$ \\lambda_j(\\mathbf{J}) = \\frac{D_B}{\\Delta x^2} \\mu_j(\\mathbf{L}_D) - C = -\\frac{4 D_B}{\\Delta x^2} \\sin^2\\left(\\frac{j\\pi}{2(N+1)}\\right) - C $$\n鉴于所有物理参数（$D_B$、$k_d$、$C_{B,0}$、$k_c$）都是非负的，常数 $C$ 也是非负的。因此，所有特征值 $\\lambda_j$ 都是实数且非正。这简化了分析，因为实部 $\\Re(\\lambda_j)$ 就是 $\\lambda_j$，其绝对值 $|\\Re(\\lambda_j)|$ 就是 $|\\lambda_j|$。\n\n现在可以用这些特征值来表示所要求的度量指标：\n1.  **谱半径** $\\rho(\\mathbf{J})$：这是特征值实部绝对值的最大值，它决定了显式时间步进格式的稳定性极限。\n    $$ \\rho(\\mathbf{J}) = \\max_{j} |\\Re(\\lambda_j)| = \\max_{j} |\\lambda_j| $$\n    函数 $\\sin^2(x)$ 在与我们索引 $j$ 相关的区间上是单调递增的。因此，最大绝对值出现在 $j=N$ 时：\n    $$ |\\lambda_N| = \\frac{4 D_B}{\\Delta x^2} \\sin^2\\left(\\frac{N\\pi}{2(N+1)}\\right) + C $$\n    所以，$\\rho(\\mathbf{J}) = |\\lambda_N|$。\n\n2.  **最大前向欧拉时间步长** $\\Delta t_{\\mathrm{FE,max}}$：前向欧拉方法的稳定性判据是 $\\Delta t \\le 2 / \\rho(\\mathbf{J})$。\n    $$ \\Delta t_{\\mathrm{FE,max}} = \\frac{2}{\\rho(\\mathbf{J})} = \\frac{2}{|\\lambda_N|} $$\n\n3.  **刚性指数** $\\kappa$：这是特征值实部最大与最小绝对值之比。它量化了系统中时间尺度的跨度。\n    $$ \\kappa = \\frac{\\max_{j} |\\Re(\\lambda_j)|}{\\min_{j} |\\Re(\\lambda_j)|} = \\frac{\\max_{j} |\\lambda_j|}{\\min_{j} |\\lambda_j|} $$\n    最小绝对值对应于 $j=1$：\n    $$ |\\lambda_1| = \\frac{4 D_B}{\\Delta x^2} \\sin^2\\left(\\frac{\\pi}{2(N+1)}\\right) + C $$\n    因此，刚性指数为：\n    $$ \\kappa = \\frac{|\\lambda_N|}{|\\lambda_1|} = \\frac{\\frac{4 D_B}{\\Delta x^2} \\sin^2\\left(\\frac{N\\pi}{2(N+1)}\\right) + C}{\\frac{4 D_B}{\\Delta x^2} \\sin^2\\left(\\frac{\\pi}{2(N+1)}\\right) + C} $$\n\n4.  **刚性分类**：如果 $\\kappa  100$，则系统被分类为刚性。\n\n程序中实现的算法对每个测试用例按以下步骤进行：\n1.  识别反应类型（DISP或ECE）并检索参数 $N$、$L$、$D_B$、$k_d$、$C_{B,0}$ 和 $k_c$。\n2.  计算反应动力学常数 $C$。如果 $k_d  0$，则 $C=4 k_d C_{B,0}$。如果 $k_c  0$，则 $C=k_c$。\n3.  计算空间步长 $\\Delta x = L/(N+1)$。\n4.  使用上述推导的解析公式计算最小和最大特征值绝对值 $|\\lambda_1|$ 和 $|\\lambda_N|$。\n5.  计算 $\\rho(\\mathbf{J}) = |\\lambda_N|$、$\\Delta t_{\\mathrm{FE,max}} = 2/\\rho(\\mathbf{J})$ 和 $\\kappa = |\\lambda_N|/|\\lambda_1|$。\n6.  根据 $\\kappa  100$ 是否成立，确定布尔刚性分类。\n7.  存储四个结果值：$\\kappa$、$\\Delta t_{\\mathrm{FE,max}}$、$\\rho(\\mathbf{J})$ 和刚性布尔值。\n\n对所有指定的测试用例重复此过程，并将结果汇总到一个扁平列表中以供输出，遵循指定的格式。使用解析特征值表达式确保了高精度和计算效率，避免了显式矩阵构造和数值特征值求解器的需要。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases and print results.\n    \"\"\"\n    \n    # Each tuple represents a test case with parameters:\n    # (type, N, L, D_B, k_d, C_B0, k_c) in SI units.\n    test_cases = [\n        # 1. DISP, “happy path”\n        ('DISP', 50, 1e-5, 1e-9, 1e6, 10.0, 0.0),\n        # 2. DISP, diffusion-dominated edge\n        ('DISP', 50, 1e-5, 1e-9, 1e6, 1e-6, 0.0),\n        # 3. DISP, grid-refined\n        ('DISP', 200, 1e-5, 1e-9, 1e6, 10.0, 0.0),\n        # 4. ECE surrogate, linear reaction\n        ('ECE', 50, 1e-5, 1e-9, 0.0, 0.0, 100.0)\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        case_type, N, L, D_B, k_d, C_B0, k_c = case\n        \n        # Calculate the relevant constant C from the linearized reaction kinetics\n        if case_type == 'DISP':\n            # For 2B - C, reaction term is -2*kd*C^2, derivative is -4*kd*C\n            reaction_const = 4.0 * k_d * C_B0\n        elif case_type == 'ECE':\n            # For B - C, reaction term is -kc*C, derivative is -kc\n            reaction_const = k_c\n        else:\n            # Should not happen with the defined test cases\n            raise ValueError(f\"Unknown case type: {case_type}\")\n\n        # Calculate metrics for the current case\n        kappa, dt_fe_max, rho_J, is_stiff = compute_stiffness_metrics(\n            N, L, D_B, reaction_const\n        )\n        \n        # Append the four required values to the flat results list\n        results.extend([kappa, dt_fe_max, rho_J, is_stiff])\n\n    # Format the final output as a single line: [res1,res2,...]\n    # The map(str, ...) function correctly handles floats and booleans.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef compute_stiffness_metrics(N, L, D_B, reaction_const):\n    \"\"\"\n    Computes stiffness metrics based on the analytical eigenvalues of the Jacobian.\n    \n    Parameters:\n    - N (int): Number of interior spatial grid points.\n    - L (float): Length of the spatial domain in meters.\n    - D_B (float): Diffusion coefficient in m^2/s.\n    - reaction_const (float): The constant C in the Jacobian formula J = (D_B/dx^2)L_D - C*I.\n    \n    Returns:\n    - tuple: (kappa, dt_fe_max, rho_J, is_stiff)\n    \"\"\"\n    \n    # Calculate spatial step size\n    dx = L / (N + 1.0)\n    \n    # The eigenvalues of the Jacobian are lambda_j = -A * sin^2(j*pi/(2(N+1))) - C\n    # where A = 4 * D_B / dx^2 and C = reaction_const.\n    # All eigenvalues are real and negative. Their magnitudes are:\n    # |lambda_j| = A * sin^2(j*pi/(2(N+1))) + C\n    \n    diffusion_multiplier = 4.0 * D_B / (dx**2)\n    \n    # Smallest magnitude eigenvalue corresponds to j=1\n    j_min_arg = np.pi / (2.0 * (N + 1.0))\n    eig_mag_min = diffusion_multiplier * np.sin(j_min_arg)**2 + reaction_const\n    \n    # Largest magnitude eigenvalue corresponds to j=N\n    j_max_arg = N * np.pi / (2.0 * (N + 1.0))\n    eig_mag_max = diffusion_multiplier * np.sin(j_max_arg)**2 + reaction_const\n    \n    # 1. Spectral radius rho(J) is the max eigenvalue magnitude\n    rho_J = eig_mag_max\n    \n    # 2. Stiffness index kappa\n    # Avoid division by zero if all eigenvalues are zero (non-physical case here)\n    if eig_mag_min == 0.0:\n        kappa = np.inf\n    else:\n        kappa = eig_mag_max / eig_mag_min\n        \n    # 3. Max stable time step for Forward Euler\n    # Avoid division by zero if rho_J is zero\n    if rho_J == 0.0:\n        dt_fe_max = np.inf\n    else:\n        dt_fe_max = 2.0 / rho_J\n        \n    # 4. Stiffness classification\n    is_stiff = kappa  100.0\n    \n    return kappa, dt_fe_max, rho_J, is_stiff\n\n# Execute the main function\nsolve()\n```"
        },
        {
            "introduction": "最后一个练习关注计算科学的一个基本问题：如何确保您的代码是正确的。我们将介绍一种强大的代码验证技术——“人造解法”(Method of Manufactured Solutions, MMS)。本练习将指导您为反应-扩散方程构建一个人造解，并用它来严格测试有限差分法实现的准确性，这是开发可信赖的模拟工具所必备的一项关键技能 。",
            "id": "4258373",
            "problem": "要求您使用“制造解方法”(Method of Manufactured Solutions, MMS) 来验证两种典型电化学反应机理——电化学-化学-电化学 (Electrochemical–Chemical–Electrochemical, ECE) 和歧化反应 (Disproportionation, DISP)——的反应-扩散实现。请严格使用无量纲变量进行计算。考虑一个一维无量纲空间域 $x \\in [\\,0,\\,1\\,]$ 和一个无量纲时间域 $t \\in [\\,0,\\,1\\,]$。每个物种 $c_i(x,t)$ 的控制方程是基于菲克第二定律和质量作用动力学推导出的反应-扩散方程，并附加了一个制造源项 $s_i(x,t)$：\n$$\n\\frac{\\partial c_i}{\\partial t} \\;=\\; D_i \\,\\frac{\\partial^2 c_i}{\\partial x^2} \\;+\\; R_i\\!\\left(\\{c_j\\}\\right) \\;+\\; s_i(x,t),\n$$\n其中 $D_i$ 是物种 $i$ 的无量纲扩散系数，$R_i$ 是由反应机理给出的无量纲反应项，$s_i(x,t)$ 的选择是为了使一个预设的制造解成为该连续偏微分方程的精确解。\n\n定义齐次诺伊曼边界条件，使得在 $x=0$ 和 $x=1$ 处 $\\partial c_i/\\partial x = 0$，并选择一个满足这些边界条件的光滑制造解：\n$$\nc_i(x,t) \\;=\\; \\alpha_i \\;+\\; \\beta_i \\,\\cos\\!\\left(2\\pi x\\right)\\,\\sin\\!\\left(\\pi t\\right),\n$$\n其中常数 $\\alpha_i  0$ 和 $\\beta_i  0$ 在下方的测试套件中指定。\n\n对于 ECE 机理，使用四种物质，其体相反应项如下，模拟了连续的可逆-不可逆-可逆步骤：\n$$\nR_A \\;=\\; -k_{1f}\\,c_A \\;+\\; k_{1b}\\,c_B,\n$$\n$$\nR_B \\;=\\; k_{1f}\\,c_A \\;-\\; k_{1b}\\,c_B \\;-\\; k_2\\,c_B,\n$$\n$$\nR_C \\;=\\; k_2\\,c_B \\;-\\; k_{3f}\\,c_C \\;+\\; k_{3b}\\,c_D,\n$$\n$$\nR_D \\;=\\; k_{3f}\\,c_C \\;-\\; k_{3b}\\,c_D,\n$$\n其中 $k_{1f}$、$k_{1b}$、$k_2$、$k_{3f}$ 和 $k_{3b}$ 为无量纲速率常数。\n\n对于歧化 (DISP) 机理，使用三种物质，包含一个可逆的相互转化和一个中间产物的双分子歧化反应：\n$$\nR_A \\;=\\; -k_{1f}\\,c_A \\;+\\; k_{1b}\\,c_B \\;+\\; k_{\\mathrm{disp}}\\,c_B^2,\n$$\n$$\nR_B \\;=\\; k_{1f}\\,c_A \\;-\\; k_{1b}\\,c_B \\;-\\; 2\\,k_{\\mathrm{disp}}\\,c_B^2,\n$$\n$$\nR_C \\;=\\; k_{\\mathrm{disp}}\\,c_B^2,\n$$\n其中 $k_{1f}$、$k_{1b}$ 和 $k_{\\mathrm{disp}}$ 为无量纲速率常数。\n\n使用制造解 $c_i(x,t)$，定义源项 $s_i(x,t)$，使 $c_i(x,t)$ 成为精确的连续解：\n$$\ns_i(x,t) \\;=\\; \\frac{\\partial c_i}{\\partial t} \\;-\\; D_i \\,\\frac{\\partial^2 c_i}{\\partial x^2} \\;-\\; R_i\\!\\left(\\{c_j\\}\\right),\n$$\n其中\n$$\n\\frac{\\partial c_i}{\\partial t} \\;=\\; \\beta_i\\,\\pi\\,\\cos\\!\\left(2\\pi x\\right)\\,\\cos\\!\\left(\\pi t\\right),\n\\quad\n\\frac{\\partial^2 c_i}{\\partial x^2} \\;=\\; -4\\pi^2\\,\\beta_i\\,\\cos\\!\\left(2\\pi x\\right)\\,\\sin\\!\\left(\\pi t\\right).\n$$\n\n使用均匀网格对区域进行离散化：$x_m = m\\,\\Delta x$（$m = 0,1,\\dots,N_x-1$）和 $t_n = n\\,\\Delta t$（$n = 0,1,\\dots,N_t-1$），其中 $\\Delta x = 1/(N_x-1)$ 且 $\\Delta t = 1/(N_t-1)$。在内部点 $(t_n,x_m)$（其中 $n \\in \\{1,\\dots,N_t-2\\}$ 且 $m \\in \\{1,\\dots,N_x-2\\}$），为每个物种 $i$ 构建二阶中心有限差分残差：\n$$\n\\mathcal{R}_i^{n,m} \\;=\\; \n\\frac{c_i^{n+1,m} - c_i^{n-1,m}}{2\\,\\Delta t}\n\\;-\\;\nD_i\\,\\frac{c_i^{n,m+1} - 2\\,c_i^{n,m} + c_i^{n,m-1}}{\\Delta x^2}\n\\;-\\;\nR_i\\!\\left(\\{c_j^{n,m}\\}\\right)\n\\;-\\;\ns_i^{n,m}.\n$$\n计算所有内部时空点和所有物种的均方根残差：\n$$\n\\mathrm{RMS} \\;=\\; \\sqrt{\\frac{1}{N_{\\mathrm{samples}}}\\,\\sum_{n=1}^{N_t-2}\\sum_{m=1}^{N_x-2}\\sum_{i} \\left(\\mathcal{R}_i^{n,m}\\right)^2},\n$$\n其中 $N_{\\mathrm{samples}}$ 是求和项的总数。\n\n实现一个程序，对于下方的每个测试用例，构建制造解，计算 $s_i(x,t)$，形成离散残差 $\\mathcal{R}_i^{n,m}$，并将均方根残差作为单个浮点数输出。所有变量均为无量纲。使用以下测试套件：\n\n- 测试用例 1 (ECE，粗网格)：\n  - 物种与制造解参数：$(\\alpha_A,\\beta_A)=(\\,1.20,\\,0.10\\,)$，$(\\alpha_B,\\beta_B)=(\\,0.80,\\,0.07\\,)$，$(\\alpha_C,\\beta_C)=(\\,0.50,\\,0.05\\,)$，$(\\alpha_D,\\beta_D)=(\\,0.60,\\,0.04\\,)$。\n  - 扩散系数：$(D_A,D_B,D_C,D_D)=(\\,0.010,\\,0.015,\\,0.008,\\,0.012\\,)$。\n  - 速率常数：$(k_{1f},k_{1b},k_2,k_{3f},k_{3b})=(\\,1.00,\\,0.50,\\,0.70,\\,0.80,\\,0.40\\,)$。\n  - 网格：$N_x=33$， $N_t=33$。\n\n- 测试用例 2 (ECE，中等网格)：\n  - 物种与参数同测试用例 1。\n  - 网格：$N_x=65$，$N_t=65$。\n\n- 测试用例 3 (ECE，细网格)：\n  - 物种与参数同测试用例 1。\n  - 网格：$N_x=129$，$N_t=129$。\n\n- 测试用例 4 (DISP，中等网格)：\n  - 物种与制造解参数：$(\\alpha_A,\\beta_A)=(\\,1.00,\\,0.08\\,)$，$(\\alpha_B,\\beta_B)=(\\,0.90,\\,0.06\\,)$，$(\\alpha_C,\\beta_C)=(\\,0.70,\\,0.04\\,)$。\n  - 扩散系数：$(D_A,D_B,D_C)=(\\,0.012,\\,0.011,\\,0.009\\,)$。\n  - 速率常数：$(k_{1f},k_{1b},k_{\\mathrm{disp}})=(\\,0.90,\\,0.60,\\,0.30\\,)$。\n  - 网格：$N_x=129$，$N_t=101$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表顺序与上述测试用例相同（例如，$[\\,\\mathrm{r}_1,\\mathrm{r}_2,\\mathrm{r}_3,\\mathrm{r}_4\\,]$）。每个 $\\mathrm{r}_k$ 必须是一个浮点数。所有计算必须在无量纲单位下进行，并且三角函数中的角度默认为弧度。",
            "solution": "本问题的解决方案是严格按照“制造解方法”(MMS)的步骤来验证有限差分代码的准确性。其核心思想是，将一个已知的、平滑的解析函数（即“制造解”）代入离散化的偏微分方程中，然后计算该方程在多大程度上未能得到满足。这个差值被称为“残差”，一个正确的实现应该表现出残差随网格细化而减小的特性。\n\n算法步骤如下：\n1.  **网格与解的生成**：首先，根据给定的网格点数 $N_x$ 和 $N_t$，在时空域 $[0, 1] \\times [0, 1]$ 上构建一个均匀的离散网格。然后，在每个网格点 $(t_n, x_m)$ 上，计算所有物种 $i$ 的制造解 $c_i(t_n, x_m)$ 的值。\n2.  **源项的解析计算**：利用制造解的解析表达式，我们可以精确地计算出其时间导数 $\\partial c_i/\\partial t$、空间二阶导数 $\\partial^2 c_i/\\partial x^2$ 以及反应项 $R_i$。根据控制方程，将这些项组合起来，就可以得到在每个网格点上必须施加的源项 $s_i(t_n, x_m)$ 的精确值，以确保制造解是连续方程的精确解。\n3.  **残差的离散计算**：在所有内部网格点上，使用二阶中心差分格式来近似时间导数和空间导数。然后，将这些离散导数、在网格点上计算的反应项 $R_i$ 和源项 $s_i$ 代入离散化的控制方程中。理论上，如果有限差分格式与制造解的函数形式完全匹配，残差将为零（在机器精度内）。实际上，由于截断误差，会存在一个小的非零残差。\n4.  **RMS值的汇总**：最后，将所有内部网格点上、所有物种的残差值进行平方、求和、取平均，然后开方，得到最终的均方根(RMS)残差。这个单一的数值量化了离散化方案的整体精度。\n\n对于使用二阶差分格式的实现，我们预期当网格间距 $\\Delta x$ 和 $\\Delta t$ 减半时，RMS残差大约会减小到原来的四分之一（即二阶收敛）。通过观察测试用例1、2和3的结果，可以验证这一行为。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_rms(\n    mechanism_type: str,\n    Nx: int,\n    Nt: int,\n    alphas: tuple,\n    betas: tuple,\n    Ds: tuple,\n    ks: tuple,\n) -> float:\n    \"\"\"\n    Calculates the Root-Mean-Square (RMS) residual for a single test case\n    of the Method of Manufactured Solutions (MMS).\n\n    Args:\n        mechanism_type: The reaction mechanism ('ECE' or 'DISP').\n        Nx: Number of spatial grid points.\n        Nt: Number of temporal grid points.\n        alphas: Tuple of alpha parameters for the manufactured solution.\n        betas: Tuple of beta parameters for the manufactured solution.\n        Ds: Tuple of diffusion coefficients for each species.\n        ks: Tuple of rate constants for the reaction mechanism.\n\n    Returns:\n        The calculated RMS residual as a float.\n    \"\"\"\n    # 1. Setup Grid and Parameters\n    num_species = len(alphas)\n    x_grid = np.linspace(0.0, 1.0, Nx)\n    t_grid = np.linspace(0.0, 1.0, Nt)\n    dx = 1.0 / (Nx - 1)\n    dt = 1.0 / (Nt - 1)\n\n    # Use numpy arrays with added axes for broadcasting\n    alphas_np = np.array(alphas)[:, np.newaxis, np.newaxis]\n    betas_np = np.array(betas)[:, np.newaxis, np.newaxis]\n    Ds_np = np.array(Ds)\n\n    xx, tt = np.meshgrid(x_grid, t_grid)\n\n    # 2. Construct Analytical Terms on the Full Grid\n    # Evaluate trigonometric components once for efficiency\n    cos_2pix = np.cos(2 * np.pi * xx)\n    sin_pit = np.sin(np.pi * tt)\n\n    # Manufactured solution C(i, t, x)\n    C = alphas_np + betas_np * cos_2pix * sin_pit\n\n    # Continuous derivatives\n    dcdt_cont = betas_np * np.pi * cos_2pix * np.cos(np.pi * tt)\n    d2cdx2_cont = -4 * np.pi**2 * betas_np * cos_2pix * sin_pit\n\n    # Reaction term R(i, t, x)\n    R = np.zeros_like(C)\n    if mechanism_type == 'ECE':\n        k1f, k1b, k2, k3f, k3b = ks\n        cA, cB, cC, cD = C[0], C[1], C[2], C[3]\n        R[0] = -k1f * cA + k1b * cB\n        R[1] =  k1f * cA - k1b * cB - k2 * cB\n        R[2] =  k2  * cB - k3f * cC + k3b * cD\n        R[3] =  k3f * cC - k3b * cD\n    elif mechanism_type == 'DISP':\n        k1f, k1b, k_disp = ks\n        cA, cB, _ = C[0], C[1], C[2]\n        R[0] = -k1f * cA + k1b * cB + k_disp * cB**2\n        R[1] =  k1f * cA - k1b * cB - 2 * k_disp * cB**2\n        R[2] =  k_disp * cB**2\n    \n    # Source term S(i, t, x)\n    S = dcdt_cont - Ds_np[:, np.newaxis, np.newaxis] * d2cdx2_cont - R\n\n    # 3. Calculate Discrete Residual on the Interior Grid\n    # The residual is evaluated for n in [1, Nt-2] and m in [1, Nx-2].\n    # We use numpy slicing to operate on the interior grid efficiently.\n\n    # Discrete time derivative: (c(n+1) - c(n-1)) / (2*dt)\n    dcdt_disc = (C[:, 2:, 1:-1] - C[:, :-2, 1:-1]) / (2 * dt)\n\n    # Discrete spatial derivative: (c(m+1) - 2c(m) + c(m-1)) / dx^2\n    d2cdx2_disc = (C[:, 1:-1, 2:] - 2 * C[:, 1:-1, 1:-1] + C[:, 1:-1, :-2]) / (dx**2)\n\n    # Reaction and Source terms, sliced to match the interior grid\n    R_interior = R[:, 1:-1, 1:-1]\n    S_interior = S[:, 1:-1, 1:-1]\n\n    # Assemble the residual for all species on the interior grid\n    residual_grid = dcdt_disc - Ds_np[:, np.newaxis, np.newaxis] * d2cdx2_disc - R_interior - S_interior\n\n    # 4. Compute Final RMS Value\n    num_samples = residual_grid.size\n    rms = np.sqrt(np.sum(residual_grid**2) / num_samples)\n    \n    return rms\n\ndef solve():\n    \"\"\"\n    Defines the test cases, calculates the RMS residual for each,\n    and prints the results in the specified format.\n    \"\"\"\n    # Define common parameters for ECE test cases\n    ece_params = {\n        'mechanism_type': 'ECE',\n        'alphas': (1.20, 0.80, 0.50, 0.60),\n        'betas': (0.10, 0.07, 0.05, 0.04),\n        'Ds': (0.010, 0.015, 0.008, 0.012),\n        'ks': (1.00, 0.50, 0.70, 0.80, 0.40)\n    }\n\n    test_cases = [\n        # Test Case 1 (ECE, coarse grid)\n        {**ece_params, 'Nx': 33, 'Nt': 33},\n        # Test Case 2 (ECE, medium grid)\n        {**ece_params, 'Nx': 65, 'Nt': 65},\n        # Test Case 3 (ECE, fine grid)\n        {**ece_params, 'Nx': 129, 'Nt': 129},\n        # Test Case 4 (DISP, medium grid)\n        {\n            'mechanism_type': 'DISP',\n            'Nx': 129,\n            'Nt': 101,\n            'alphas': (1.00, 0.90, 0.70),\n            'betas': (0.08, 0.06, 0.04),\n            'Ds': (0.012, 0.011, 0.009),\n            'ks': (0.90, 0.60, 0.30)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        rms = calculate_rms(**case)\n        results.append(rms)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}